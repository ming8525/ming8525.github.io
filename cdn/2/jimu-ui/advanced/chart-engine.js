System.register(["esri/intl"], function(__WEBPACK_DYNAMIC_EXPORT__, __system_context__) {
	var __WEBPACK_EXTERNAL_MODULE_esri_intl__ = {};
	Object.defineProperty(__WEBPACK_EXTERNAL_MODULE_esri_intl__, "__esModule", { value: true });
	return {
		setters: [
			function(module) {
				Object.keys(module).forEach(function(key) {
					__WEBPACK_EXTERNAL_MODULE_esri_intl__[key] = module[key];
				});
			}
		],
		execute: function() {
			__WEBPACK_DYNAMIC_EXPORT__(
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@amcharts/amcharts5/.internal/charts/percent/PercentChart.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/charts/percent/PercentChart.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PercentChart: () => (/* binding */ PercentChart)
/* harmony export */ });
/* harmony import */ var _core_render_SerialChart__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/render/SerialChart */ "./node_modules/@amcharts/amcharts5/.internal/core/render/SerialChart.js");
/* harmony import */ var _PercentDefaultTheme__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./PercentDefaultTheme */ "./node_modules/@amcharts/amcharts5/.internal/charts/percent/PercentDefaultTheme.js");


/**
 * Base class for [[PieChart]].
 *
 * Also used for percent-based series, like [[FunnelSeries]], [[PyramidSeries]], etc.
 *
 * @important
 */
class PercentChart extends _core_render_SerialChart__WEBPACK_IMPORTED_MODULE_0__.SerialChart {
    _afterNew() {
        this._defaultThemes.push(_PercentDefaultTheme__WEBPACK_IMPORTED_MODULE_1__.PercentDefaultTheme.new(this._root));
        super._afterNew();
        this.chartContainer.children.push(this.seriesContainer);
        this.seriesContainer.children.push(this.bulletsContainer);
    }
    _processSeries(series) {
        super._processSeries(series);
        this.seriesContainer.children.moveValue(this.bulletsContainer, this.seriesContainer.children.length - 1);
    }
}
Object.defineProperty(PercentChart, "className", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: "PercentChart"
});
Object.defineProperty(PercentChart, "classNames", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: _core_render_SerialChart__WEBPACK_IMPORTED_MODULE_0__.SerialChart.classNames.concat([PercentChart.className])
});
//# sourceMappingURL=PercentChart.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/charts/percent/PercentDefaultTheme.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/charts/percent/PercentDefaultTheme.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PercentDefaultTheme: () => (/* binding */ PercentDefaultTheme)
/* harmony export */ });
/* harmony import */ var _core_Theme__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/Theme */ "./node_modules/@amcharts/amcharts5/.internal/core/Theme.js");
/* harmony import */ var _core_util_Percent__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../core/util/Percent */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Percent.js");
/* harmony import */ var _core_util_ColorSet__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../core/util/ColorSet */ "./node_modules/@amcharts/amcharts5/.internal/core/util/ColorSet.js");
/* harmony import */ var _themes_DefaultTheme__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../themes/DefaultTheme */ "./node_modules/@amcharts/amcharts5/.internal/themes/DefaultTheme.js");




/**
 * @ignore
 */
class PercentDefaultTheme extends _core_Theme__WEBPACK_IMPORTED_MODULE_0__.Theme {
    setupDefaultRules() {
        super.setupDefaultRules();
        const ic = this._root.interfaceColors;
        const r = this.rule.bind(this);
        /**
         * ========================================================================
         * charts/percent
         * ========================================================================
         */
        r("PercentSeries").setAll({
            legendLabelText: "{category}",
            legendValueText: "{valuePercentTotal.formatNumber('0.00p')}",
            colors: _core_util_ColorSet__WEBPACK_IMPORTED_MODULE_1__.ColorSet.new(this._root, {}),
            width: _core_util_Percent__WEBPACK_IMPORTED_MODULE_2__.p100,
            height: _core_util_Percent__WEBPACK_IMPORTED_MODULE_2__.p100
        });
        /**
         * ========================================================================
         * charts/pie
         * ========================================================================
         */
        r("PieChart").setAll({
            radius: (0,_core_util_Percent__WEBPACK_IMPORTED_MODULE_2__.percent)(80),
            startAngle: -90,
            endAngle: 270
        });
        r("PieSeries").setAll({
            alignLabels: true,
            startAngle: -90,
            endAngle: 270
        });
        r("PieSeries").states.create("hidden", { endAngle: -90, opacity: 0 });
        r("Slice", ["pie"]).setAll({
            position: "absolute",
            isMeasured: false,
            x: 0,
            y: 0,
            toggleKey: "active",
            tooltipText: "{category}: {valuePercentTotal.formatNumber('0.00p')}",
            strokeWidth: 1,
            strokeOpacity: 1,
            role: "figure",
            lineJoin: "round"
        });
        r("Slice", ["pie"]).states.create("active", { shiftRadius: 20, scale: 1 });
        r("Slice", ["pie"]).states.create("hoverActive", { scale: 1.04 });
        r("Slice", ["pie"]).states.create("hover", { scale: 1.04 });
        r("RadialLabel", ["pie"]).setAll({
            textType: "aligned",
            radius: 10,
            text: "{category}: {valuePercentTotal.formatNumber('0.00p')}",
            paddingTop: 5,
            paddingBottom: 5,
            populateText: true
        });
        r("Tick", ["pie"]).setAll({
            location: 1
        });
        /**
         * ========================================================================
         * charts/funnel
         * ========================================================================
         */
        r("SlicedChart").setAll({
            paddingLeft: 10,
            paddingRight: 10,
            paddingTop: 10,
            paddingBottom: 10
        });
        /**
         * ------------------------------------------------------------------------
         * charts/funnel: Funnel
         * ------------------------------------------------------------------------
         */
        r("FunnelSeries").setAll({
            startLocation: 0,
            endLocation: 1,
            orientation: "vertical",
            alignLabels: true,
            sequencedInterpolation: true
        });
        r("FunnelSlice").setAll({
            interactive: true,
            expandDistance: 0,
            //tooltipText: "{category}: {valuePercentTotal.formatNumber('0.00p')}"
        });
        r("FunnelSlice").states.create("hover", { expandDistance: 0.15 });
        r("Label", ["funnel"]).setAll({
            populateText: true,
            text: "{category}: {valuePercentTotal.formatNumber('0.00p')}",
            centerY: _core_util_Percent__WEBPACK_IMPORTED_MODULE_2__.p50
        });
        r("Label", ["funnel", "horizontal"]).setAll({
            centerX: 0,
            centerY: _core_util_Percent__WEBPACK_IMPORTED_MODULE_2__.p50,
            rotation: -90
        });
        // Class: Label
        r("Label", ["funnel", "vertical"]).setAll({
            centerY: _core_util_Percent__WEBPACK_IMPORTED_MODULE_2__.p50,
            centerX: 0
        });
        r("Tick", ["funnel"]).setAll({
            location: 1
        });
        r("FunnelSlice", ["funnel", "link"]).setAll({
            fillOpacity: 0.5,
            strokeOpacity: 0,
            expandDistance: -0.1
        });
        r("FunnelSlice", ["funnel", "link", "vertical"]).setAll({
            height: 10,
        });
        r("FunnelSlice", ["funnel", "link", "horizontal"]).setAll({
            width: 10
        });
        /**
         * ------------------------------------------------------------------------
         * charts/funnel: Pyramid
         * ------------------------------------------------------------------------
         */
        r("PyramidSeries").setAll({
            valueIs: "area"
        });
        r("FunnelSlice", ["pyramid", "link"]).setAll({
            fillOpacity: 0.5
        });
        r("FunnelSlice", ["pyramid", "link", "vertical"]).setAll({
            height: 0
        });
        r("FunnelSlice", ["pyramid", "link", "horizontal"]).setAll({
            width: 0
        });
        r("FunnelSlice", ["pyramid"]).setAll({
            interactive: true,
            expandDistance: 0
        });
        r("FunnelSlice", ["pyramid"]).states.create("hover", { expandDistance: 0.15 });
        r("Label", ["pyramid"]).setAll({
            populateText: true,
            text: "{category}: {valuePercentTotal.formatNumber('0.00p')}",
            centerY: _core_util_Percent__WEBPACK_IMPORTED_MODULE_2__.p50
        });
        r("Label", ["pyramid", "horizontal"]).setAll({
            centerX: 0,
            centerY: _core_util_Percent__WEBPACK_IMPORTED_MODULE_2__.p50,
            rotation: -90
        });
        r("Label", ["pyramid", "vertical"]).setAll({
            centerY: _core_util_Percent__WEBPACK_IMPORTED_MODULE_2__.p50,
            centerX: 0
        });
        r("Tick", ["pyramid"]).setAll({
            location: 1
        });
        /**
         * ------------------------------------------------------------------------
         * charts/funnel: Pictorial
         * ------------------------------------------------------------------------
         */
        // Class: FunnelSlice
        r("FunnelSlice", ["pictorial"]).setAll({
            interactive: true,
            tooltipText: "{category}: {valuePercentTotal.formatNumber('0.00p')}"
        });
        r("Label", ["pictorial"]).setAll({
            populateText: true,
            text: "{category}: {valuePercentTotal.formatNumber('0.00p')}",
            centerY: _core_util_Percent__WEBPACK_IMPORTED_MODULE_2__.p50
        });
        r("Label", ["pictorial", "horizontal"]).setAll({
            centerX: 0,
            centerY: _core_util_Percent__WEBPACK_IMPORTED_MODULE_2__.p50,
            rotation: -90
        });
        r("Label", ["pictorial", "vertical"]).setAll({
            centerY: _core_util_Percent__WEBPACK_IMPORTED_MODULE_2__.p50,
            centerX: 0
        });
        r("FunnelSlice", ["pictorial", "link"]).setAll({
            fillOpacity: 0.5,
            width: 0,
            height: 0
        });
        r("Tick", ["pictorial"]).setAll({
            location: 0.5
        });
        {
            const rule = r("Graphics", ["pictorial", "background"]);
            rule.setAll({
                fillOpacity: 0.2
            });
            (0,_themes_DefaultTheme__WEBPACK_IMPORTED_MODULE_3__.setColor)(rule, "fill", ic, "alternativeBackground");
        }
    }
}
//# sourceMappingURL=PercentDefaultTheme.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/charts/percent/PercentSeries.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/charts/percent/PercentSeries.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PercentSeries: () => (/* binding */ PercentSeries)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.mjs");
/* harmony import */ var _core_render_Series__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/render/Series */ "./node_modules/@amcharts/amcharts5/.internal/core/render/Series.js");
/* harmony import */ var _core_render_Container__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../core/render/Container */ "./node_modules/@amcharts/amcharts5/.internal/core/render/Container.js");
/* harmony import */ var _core_render_Graphics__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../core/render/Graphics */ "./node_modules/@amcharts/amcharts5/.internal/core/render/Graphics.js");
/* harmony import */ var _core_util_Array__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../core/util/Array */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Array.js");
/* harmony import */ var _core_util_Type__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../core/util/Type */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Type.js");






/**
 * A base class for any percent chart series.
 */
class PercentSeries extends _core_render_Series__WEBPACK_IMPORTED_MODULE_0__.Series {
    constructor() {
        super(...arguments);
        Object.defineProperty(this, "slicesContainer", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: this.children.push(_core_render_Container__WEBPACK_IMPORTED_MODULE_1__.Container.new(this._root, { position: "absolute", isMeasured: false }))
        });
        Object.defineProperty(this, "labelsContainer", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: this.children.push(_core_render_Container__WEBPACK_IMPORTED_MODULE_1__.Container.new(this._root, { position: "absolute", isMeasured: false }))
        });
        Object.defineProperty(this, "ticksContainer", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: this.children.push(_core_render_Container__WEBPACK_IMPORTED_MODULE_1__.Container.new(this._root, { position: "absolute", isMeasured: false }))
        });
        Object.defineProperty(this, "_lLabels", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
        });
        Object.defineProperty(this, "_rLabels", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
        });
        Object.defineProperty(this, "_hLabels", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
        });
        /**
         * A [[ListTemplate]] of all slices in series.
         *
         * `slices.template` can also be used to configure slices.
         */
        Object.defineProperty(this, "slices", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: this._makeSlices()
        });
        /**
         * A [[ListTemplate]] of all slice labels in series.
         *
         * `labels.template` can also be used to configure slice labels.
         */
        Object.defineProperty(this, "labels", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: this._makeLabels()
        });
        /**
         * A [[ListTemplate]] of all slice ticks in series.
         *
         * `ticks.template` can also be used to configure slice ticks.
         */
        Object.defineProperty(this, "ticks", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: this._makeTicks()
        });
    }
    /**
     * @ignore
     */
    makeSlice(dataItem) {
        const slice = this.slicesContainer.children.push(this.slices.make());
        slice.on("fill", () => {
            this.updateLegendMarker(dataItem);
        });
        slice.on("stroke", () => {
            this.updateLegendMarker(dataItem);
        });
        slice._setDataItem(dataItem);
        dataItem.set("slice", slice);
        this.slices.push(slice);
        return slice;
    }
    /**
     * @ignore
     */
    makeLabel(dataItem) {
        const label = this.labelsContainer.children.push(this.labels.make());
        label._setDataItem(dataItem);
        dataItem.set("label", label);
        this.labels.push(label);
        return label;
    }
    _shouldMakeBullet(dataItem) {
        if (dataItem.get("value") != null) {
            return true;
        }
        return false;
    }
    /**
     * @ignore
     */
    makeTick(dataItem) {
        const tick = this.ticksContainer.children.push(this.ticks.make());
        tick._setDataItem(dataItem);
        dataItem.set("tick", tick);
        this.ticks.push(tick);
        return tick;
    }
    _afterNew() {
        this.fields.push("category", "fill");
        super._afterNew();
    }
    _onDataClear() {
        const colors = this.get("colors");
        if (colors) {
            colors.reset();
        }
    }
    _prepareChildren() {
        super._prepareChildren();
        this._lLabels = [];
        this._rLabels = [];
        this._hLabels = [];
        if (this._valuesDirty) {
            let sum = 0;
            let absSum = 0;
            let valueHigh = 0;
            let valueLow = Infinity;
            let count = 0;
            _core_util_Array__WEBPACK_IMPORTED_MODULE_2__.each(this._dataItems, (dataItem) => {
                let valueWorking = dataItem.get("valueWorking", 0);
                sum += valueWorking;
                absSum += Math.abs(valueWorking);
            });
            _core_util_Array__WEBPACK_IMPORTED_MODULE_2__.each(this._dataItems, (dataItem) => {
                let value = dataItem.get("valueWorking", 0);
                if (value > valueHigh) {
                    valueHigh = value;
                }
                if (value < valueLow) {
                    valueLow = value;
                }
                count++;
                let percentTotal = value / absSum;
                if (absSum == 0) {
                    percentTotal = 0;
                }
                dataItem.setRaw("valuePercentTotal", percentTotal * 100);
            });
            this.setPrivateRaw("valueLow", valueLow);
            this.setPrivateRaw("valueHigh", valueHigh);
            this.setPrivateRaw("valueSum", sum);
            this.setPrivateRaw("valueAverage", sum / count);
            this.setPrivateRaw("valueAbsoluteSum", absSum);
        }
    }
    /**
     * Shows hidden series.
     *
     * @param   duration  Animation duration in milliseconds
     * @return            Animation promise
     */
    show(duration) {
        const _super = Object.create(null, {
            show: { get: () => super.show }
        });
        return (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__awaiter)(this, void 0, void 0, function* () {
            let promises = [];
            promises.push(_super.show.call(this, duration));
            promises.push(this._sequencedShowHide(true, duration));
            yield Promise.all(promises);
        });
    }
    /**
     * Hide whole series.
     *
     * @param   duration  Animation duration in milliseconds
     * @return            Animation promise
     */
    hide(duration) {
        const _super = Object.create(null, {
            hide: { get: () => super.hide }
        });
        return (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__awaiter)(this, void 0, void 0, function* () {
            let promises = [];
            promises.push(_super.hide.call(this, duration));
            promises.push(this._sequencedShowHide(false, duration));
            yield Promise.all(promises);
        });
    }
    /**
     * @ignore
     */
    _updateChildren() {
        super._updateChildren();
        if (this._valuesDirty) {
            _core_util_Array__WEBPACK_IMPORTED_MODULE_2__.each(this._dataItems, (dataItem) => {
                dataItem.get("label").text.markDirtyText();
            });
        }
        if (this.isDirty("legendLabelText") || this.isDirty("legendValueText")) {
            _core_util_Array__WEBPACK_IMPORTED_MODULE_2__.each(this._dataItems, (dataItem) => {
                this.updateLegendValue(dataItem);
            });
        }
        this._arrange();
    }
    _arrange() {
        this._arrangeDown(this._lLabels);
        this._arrangeUp(this._lLabels);
        this._arrangeDown(this._rLabels);
        this._arrangeUp(this._rLabels);
        this._arrangeLeft(this._hLabels);
        this._arrangeRight(this._hLabels);
        _core_util_Array__WEBPACK_IMPORTED_MODULE_2__.each(this.dataItems, (dataItem) => {
            this._updateTick(dataItem);
        });
    }
    _afterChanged() {
        super._afterChanged();
        this._arrange();
    }
    processDataItem(dataItem) {
        super.processDataItem(dataItem);
        if (dataItem.get("fill") == null) {
            let colors = this.get("colors");
            if (colors) {
                dataItem.setRaw("fill", colors.next());
            }
        }
    }
    /**
     * Shows series's data item.
     *
     * @param   dataItem  Data item
     * @param   duration  Animation duration in milliseconds
     * @return            Promise
     */
    showDataItem(dataItem, duration) {
        const _super = Object.create(null, {
            showDataItem: { get: () => super.showDataItem }
        });
        return (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__awaiter)(this, void 0, void 0, function* () {
            const promises = [_super.showDataItem.call(this, dataItem, duration)];
            if (!_core_util_Type__WEBPACK_IMPORTED_MODULE_4__.isNumber(duration)) {
                duration = this.get("stateAnimationDuration", 0);
            }
            const easing = this.get("stateAnimationEasing");
            let value = dataItem.get("value");
            const animation = dataItem.animate({ key: "valueWorking", to: value, duration: duration, easing: easing });
            if (animation) {
                promises.push(animation.waitForStop());
            }
            const tick = dataItem.get("tick");
            if (tick) {
                promises.push(tick.show(duration));
            }
            const label = dataItem.get("label");
            if (label) {
                promises.push(label.show(duration));
            }
            const slice = dataItem.get("slice");
            if (slice) {
                promises.push(slice.show(duration));
            }
            if (slice.get("active")) {
                slice.states.applyAnimate("active");
            }
            yield Promise.all(promises);
        });
    }
    /**
     * Hides series's data item.
     *
     * @param   dataItem  Data item
     * @param   duration  Animation duration in milliseconds
     * @return            Promise
     */
    hideDataItem(dataItem, duration) {
        const _super = Object.create(null, {
            hideDataItem: { get: () => super.hideDataItem }
        });
        return (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__awaiter)(this, void 0, void 0, function* () {
            const promises = [_super.hideDataItem.call(this, dataItem, duration)];
            const hiddenState = this.states.create("hidden", {});
            if (!_core_util_Type__WEBPACK_IMPORTED_MODULE_4__.isNumber(duration)) {
                duration = hiddenState.get("stateAnimationDuration", this.get("stateAnimationDuration", 0));
            }
            const easing = hiddenState.get("stateAnimationEasing", this.get("stateAnimationEasing"));
            const animation = dataItem.animate({ key: "valueWorking", to: 0, duration: duration, easing: easing });
            if (animation) {
                promises.push(animation.waitForStop());
            }
            const tick = dataItem.get("tick");
            if (tick) {
                promises.push(tick.hide(duration));
            }
            const label = dataItem.get("label");
            if (label) {
                promises.push(label.hide(duration));
            }
            const slice = dataItem.get("slice");
            slice.hideTooltip();
            if (slice) {
                promises.push(slice.hide(duration));
            }
            yield Promise.all(promises);
        });
    }
    /**
     * @ignore
     */
    disposeDataItem(dataItem) {
        super.disposeDataItem(dataItem);
        let label = dataItem.get("label");
        if (label) {
            this.labels.removeValue(label);
            label.dispose();
        }
        let tick = dataItem.get("tick");
        if (tick) {
            this.ticks.removeValue(tick);
            tick.dispose();
        }
        let slice = dataItem.get("slice");
        if (slice) {
            this.slices.removeValue(slice);
            slice.dispose();
        }
    }
    /**
     * Triggers hover on a series data item.
     *
     * @since 5.0.7
     * @param  dataItem  Target data item
     */
    hoverDataItem(dataItem) {
        const slice = dataItem.get("slice");
        if (slice && !slice.isHidden()) {
            slice.hover();
        }
    }
    /**
     * Triggers un-hover on a series data item.
     *
     * @since 5.0.7
     * @param  dataItem  Target data item
     */
    unhoverDataItem(dataItem) {
        const slice = dataItem.get("slice");
        if (slice) {
            slice.unhover();
        }
    }
    /**
     * @ignore
     */
    updateLegendMarker(dataItem) {
        if (dataItem) {
            const slice = dataItem.get("slice");
            if (slice) {
                const legendDataItem = dataItem.get("legendDataItem");
                if (legendDataItem) {
                    const markerRectangle = legendDataItem.get("markerRectangle");
                    _core_util_Array__WEBPACK_IMPORTED_MODULE_2__.each(_core_render_Graphics__WEBPACK_IMPORTED_MODULE_5__.visualSettings, (setting) => {
                        if (slice.get(setting) != null) {
                            markerRectangle.set(setting, slice.get(setting));
                        }
                    });
                }
            }
        }
    }
    _arrangeDown(labels) {
        if (labels) {
            let next = this._getNextDown();
            labels.sort((a, b) => {
                if (a.y > b.y) {
                    return 1;
                }
                else if (a.y < b.y) {
                    return -1;
                }
                else {
                    return 0;
                }
            });
            _core_util_Array__WEBPACK_IMPORTED_MODULE_2__.each(labels, (l) => {
                const bounds = l.label.adjustedLocalBounds();
                let labelTop = bounds.top;
                if (l.y + labelTop < next) {
                    l.y = next - labelTop;
                }
                l.label.set("y", l.y);
                next = l.y + bounds.bottom;
            });
        }
    }
    _getNextUp() {
        return this.labelsContainer.maxHeight();
    }
    _getNextDown() {
        return 0;
    }
    _arrangeUp(labels) {
        if (labels) {
            let next = this._getNextUp();
            labels.sort((a, b) => {
                if (a.y < b.y) {
                    return 1;
                }
                else if (a.y > b.y) {
                    return -1;
                }
                else {
                    return 0;
                }
            });
            _core_util_Array__WEBPACK_IMPORTED_MODULE_2__.each(labels, (l) => {
                const bounds = l.label.adjustedLocalBounds();
                let labelBottom = bounds.bottom;
                if (l.y + labelBottom > next) {
                    l.y = next - labelBottom;
                }
                l.label.set("y", l.y);
                next = l.y + bounds.top;
            });
        }
    }
    _arrangeRight(labels) {
        if (labels) {
            let next = 0;
            labels.sort((a, b) => {
                if (a.y > b.y) {
                    return 1;
                }
                else if (a.y < b.y) {
                    return -1;
                }
                else {
                    return 0;
                }
            });
            _core_util_Array__WEBPACK_IMPORTED_MODULE_2__.each(labels, (l) => {
                const bounds = l.label.adjustedLocalBounds();
                let labelLeft = bounds.left;
                if (l.y + labelLeft < next) {
                    l.y = next - labelLeft;
                }
                l.label.set("x", l.y);
                next = l.y + bounds.right;
            });
        }
    }
    _arrangeLeft(labels) {
        if (labels) {
            let next = this.labelsContainer.maxWidth();
            labels.sort((a, b) => {
                if (a.y < b.y) {
                    return 1;
                }
                else if (a.y > b.y) {
                    return -1;
                }
                else {
                    return 0;
                }
            });
            _core_util_Array__WEBPACK_IMPORTED_MODULE_2__.each(labels, (l) => {
                const bounds = l.label.adjustedLocalBounds();
                let labelRight = bounds.right;
                if (l.y + labelRight > next) {
                    l.y = next - labelRight;
                }
                l.label.set("x", l.y);
                next = l.y + bounds.left;
            });
        }
    }
    _updateSize() {
        super._updateSize();
        this.markDirty();
    }
    _updateTick(_dataItem) {
    }
    _dispose() {
        super._dispose();
        const chart = this.chart;
        if (chart) {
            chart.series.removeValue(this);
        }
    }
}
Object.defineProperty(PercentSeries, "className", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: "PercentSeries"
});
Object.defineProperty(PercentSeries, "classNames", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: _core_render_Series__WEBPACK_IMPORTED_MODULE_0__.Series.classNames.concat([PercentSeries.className])
});
//# sourceMappingURL=PercentSeries.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/charts/pie/PieChart.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/charts/pie/PieChart.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PieChart: () => (/* binding */ PieChart)
/* harmony export */ });
/* harmony import */ var _core_util_Percent__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../core/util/Percent */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Percent.js");
/* harmony import */ var _percent_PercentChart__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../percent/PercentChart */ "./node_modules/@amcharts/amcharts5/.internal/charts/percent/PercentChart.js");
/* harmony import */ var _core_util_Utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../core/util/Utils */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Utils.js");
/* harmony import */ var _core_util_Math__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../core/util/Math */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Math.js");





/**
 * Creates a pie chart.
 *
 * @see {@link https://www.amcharts.com/docs/v5/charts/percent-charts/pie-chart/} for more info
 * @important
 */
class PieChart extends _percent_PercentChart__WEBPACK_IMPORTED_MODULE_0__.PercentChart {
    constructor() {
        super(...arguments);
        Object.defineProperty(this, "_maxRadius", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 1
        });
    }
    _afterNew() {
        super._afterNew();
        this.seriesContainer.setAll({ x: _core_util_Percent__WEBPACK_IMPORTED_MODULE_1__.p50, y: _core_util_Percent__WEBPACK_IMPORTED_MODULE_1__.p50 });
    }
    _prepareChildren() {
        super._prepareChildren();
        const chartContainer = this.chartContainer;
        const w = chartContainer.innerWidth();
        const h = chartContainer.innerHeight();
        const startAngle = this.get("startAngle", 0);
        const endAngle = this.get("endAngle", 0);
        const innerRadius = this.get("innerRadius");
        let bounds = _core_util_Math__WEBPACK_IMPORTED_MODULE_2__.getArcBounds(0, 0, startAngle, endAngle, 1);
        const wr = w / (bounds.right - bounds.left);
        const hr = h / (bounds.bottom - bounds.top);
        let innerBounds = { left: 0, right: 0, top: 0, bottom: 0 };
        if (innerRadius instanceof _core_util_Percent__WEBPACK_IMPORTED_MODULE_1__.Percent) {
            let value = innerRadius.value;
            let mr = Math.min(wr, hr);
            value = Math.max(mr * value, mr - Math.min(h, w)) / mr;
            innerBounds = _core_util_Math__WEBPACK_IMPORTED_MODULE_2__.getArcBounds(0, 0, startAngle, endAngle, value);
            this.setPrivateRaw("irModifyer", value / innerRadius.value);
        }
        bounds = _core_util_Math__WEBPACK_IMPORTED_MODULE_2__.mergeBounds([bounds, innerBounds]);
        const prevRadius = this._maxRadius;
        this._maxRadius = Math.min(wr, hr);
        const radius = _core_util_Utils__WEBPACK_IMPORTED_MODULE_3__.relativeToValue(this.get("radius", 0), this._maxRadius);
        this.seriesContainer.setAll({
            dy: -radius * (bounds.bottom + bounds.top) / 2, dx: -radius * (bounds.right + bounds.left) / 2
        });
        if (this.isDirty("startAngle") || this.isDirty("endAngle") || prevRadius != this._maxRadius) {
            this.series.each((series) => {
                series._markDirtyKey("startAngle");
            });
        }
        if (this.isDirty("innerRadius") || this.isDirty("radius")) {
            this.series.each((series) => {
                series._markDirtyKey("innerRadius");
            });
        }
    }
    /**
     * Returns outer radius in pixels.
     *
     * If optional series parameter is passed in, it will return outer radius
     * of that particular series.
     *
     * @param   series  Series
     * @return          Radius in pixels
     */
    radius(series) {
        let radius = _core_util_Utils__WEBPACK_IMPORTED_MODULE_3__.relativeToValue(this.get("radius", 0), this._maxRadius);
        let innerRadius = _core_util_Utils__WEBPACK_IMPORTED_MODULE_3__.relativeToValue(this.get("innerRadius", 0), radius);
        if (series) {
            let index = this.series.indexOf(series);
            let length = this.series.length;
            let seriesRadius = series.get("radius");
            if (seriesRadius != null) {
                return innerRadius + _core_util_Utils__WEBPACK_IMPORTED_MODULE_3__.relativeToValue(seriesRadius, radius - innerRadius);
            }
            else {
                return innerRadius + (radius - innerRadius) / length * (index + 1);
            }
        }
        return radius;
    }
    /**
     * Returns inner radius in pixels.
     *
     * If optional series parameter is passed in, it will return inner radius
     * of that particular series.
     *
     * @param   series  Series
     * @return          Radius in pixels
     */
    innerRadius(series) {
        const radius = this.radius();
        let innerRadius = _core_util_Utils__WEBPACK_IMPORTED_MODULE_3__.relativeToValue(this.get("innerRadius", 0), radius);
        if (innerRadius < 0) {
            innerRadius = radius + innerRadius;
        }
        if (series) {
            let index = this.series.indexOf(series);
            let length = this.series.length;
            let seriesInnerRadius = series.get("innerRadius");
            if (seriesInnerRadius != null) {
                return innerRadius + _core_util_Utils__WEBPACK_IMPORTED_MODULE_3__.relativeToValue(seriesInnerRadius, radius - innerRadius);
            }
            else {
                return innerRadius + (radius - innerRadius) / length * index;
            }
        }
        return innerRadius;
    }
}
Object.defineProperty(PieChart, "className", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: "PieChart"
});
Object.defineProperty(PieChart, "classNames", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: _percent_PercentChart__WEBPACK_IMPORTED_MODULE_0__.PercentChart.classNames.concat([PieChart.className])
});
//# sourceMappingURL=PieChart.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/charts/pie/PieSeries.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/charts/pie/PieSeries.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PieSeries: () => (/* binding */ PieSeries)
/* harmony export */ });
/* harmony import */ var _percent_PercentSeries__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../percent/PercentSeries */ "./node_modules/@amcharts/amcharts5/.internal/charts/percent/PercentSeries.js");
/* harmony import */ var _core_util_Template__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../core/util/Template */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Template.js");
/* harmony import */ var _core_render_Slice__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../core/render/Slice */ "./node_modules/@amcharts/amcharts5/.internal/core/render/Slice.js");
/* harmony import */ var _core_render_Tick__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../core/render/Tick */ "./node_modules/@amcharts/amcharts5/.internal/core/render/Tick.js");
/* harmony import */ var _core_render_RadialLabel__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../core/render/RadialLabel */ "./node_modules/@amcharts/amcharts5/.internal/core/render/RadialLabel.js");
/* harmony import */ var _core_util_List__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../core/util/List */ "./node_modules/@amcharts/amcharts5/.internal/core/util/List.js");
/* harmony import */ var _core_util_Percent__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../core/util/Percent */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Percent.js");
/* harmony import */ var _core_util_Array__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../core/util/Array */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Array.js");
/* harmony import */ var _core_util_Math__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../core/util/Math */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Math.js");
/* harmony import */ var _core_util_Utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../core/util/Utils */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Utils.js");










/**
 * Creates a series for a [[PieChart]].
 *
 * @see {@link https://www.amcharts.com/docs/v5/charts/percent-charts/pie-chart/} for more info
 * @important
 */
class PieSeries extends _percent_PercentSeries__WEBPACK_IMPORTED_MODULE_0__.PercentSeries {
    _makeSlices() {
        return new _core_util_List__WEBPACK_IMPORTED_MODULE_1__.ListTemplate(_core_util_Template__WEBPACK_IMPORTED_MODULE_2__.Template.new({}), () => _core_render_Slice__WEBPACK_IMPORTED_MODULE_3__.Slice._new(this._root, {
            themeTags: _core_util_Utils__WEBPACK_IMPORTED_MODULE_4__.mergeTags(this.slices.template.get("themeTags", []), ["pie", "series"])
        }, [this.slices.template]));
    }
    _makeLabels() {
        return new _core_util_List__WEBPACK_IMPORTED_MODULE_1__.ListTemplate(_core_util_Template__WEBPACK_IMPORTED_MODULE_2__.Template.new({}), () => _core_render_RadialLabel__WEBPACK_IMPORTED_MODULE_5__.RadialLabel._new(this._root, {
            themeTags: _core_util_Utils__WEBPACK_IMPORTED_MODULE_4__.mergeTags(this.labels.template.get("themeTags", []), ["pie", "series"])
        }, [this.labels.template]));
    }
    _makeTicks() {
        return new _core_util_List__WEBPACK_IMPORTED_MODULE_1__.ListTemplate(_core_util_Template__WEBPACK_IMPORTED_MODULE_2__.Template.new({}), () => _core_render_Tick__WEBPACK_IMPORTED_MODULE_6__.Tick._new(this._root, {
            themeTags: _core_util_Utils__WEBPACK_IMPORTED_MODULE_4__.mergeTags(this.ticks.template.get("themeTags", []), ["pie", "series"])
        }, [this.ticks.template]));
    }
    processDataItem(dataItem) {
        super.processDataItem(dataItem);
        const slice = this.makeSlice(dataItem);
        slice.on("scale", () => {
            this._updateTick(dataItem);
        });
        slice.on("shiftRadius", () => {
            this._updateTick(dataItem);
        });
        slice.events.on("positionchanged", () => {
            this._updateTick(dataItem);
        });
        const label = this.makeLabel(dataItem);
        label.events.on("positionchanged", () => {
            this._updateTick(dataItem);
        });
        this.makeTick(dataItem);
        slice.events.on("positionchanged", () => {
            label.markDirty();
        });
    }
    _getNextUp() {
        const chart = this.chart;
        if (chart) {
            return chart._maxRadius;
        }
        return this.labelsContainer.maxHeight() / 2;
    }
    _getNextDown() {
        const chart = this.chart;
        if (chart) {
            return -chart._maxRadius;
        }
        return -this.labelsContainer.maxHeight() / 2;
    }
    _prepareChildren() {
        super._prepareChildren();
        const chart = this.chart;
        if (chart) {
            if (this.isDirty("alignLabels")) {
                let labelsTemplate = this.labels.template;
                if (this.get("alignLabels")) {
                    labelsTemplate.set("textType", "aligned");
                }
                else {
                    let textType = labelsTemplate.get("textType");
                    if (textType == null || textType == "aligned") {
                        labelsTemplate.set("textType", "adjusted");
                    }
                }
            }
            if (this._valuesDirty || this.isDirty("radius") || this.isDirty("innerRadius") || this.isDirty("startAngle") || this.isDirty("endAngle") || this.isDirty("alignLabels")) {
                this.markDirtyBounds();
                const startAngle = this.get("startAngle", chart.get("startAngle", -90));
                const endAngle = this.get("endAngle", chart.get("endAngle", 270));
                const arc = endAngle - startAngle;
                let currentAngle = startAngle;
                const radius = chart.radius(this);
                this.setPrivateRaw("radius", radius);
                let innerRadius = chart.innerRadius(this) * chart.getPrivate("irModifyer", 1);
                if (innerRadius < 0) {
                    innerRadius = radius + innerRadius;
                }
                //if (radius > 0) {
                _core_util_Array__WEBPACK_IMPORTED_MODULE_7__.each(this._dataItems, (dataItem) => {
                    this.updateLegendValue(dataItem);
                    let currentArc = arc * dataItem.get("valuePercentTotal") / 100;
                    const slice = dataItem.get("slice");
                    if (slice) {
                        slice.set("radius", radius);
                        slice.set("innerRadius", innerRadius);
                        slice.set("startAngle", currentAngle);
                        slice.set("arc", currentArc);
                        const color = dataItem.get("fill");
                        slice._setDefault("fill", color);
                        slice._setDefault("stroke", color);
                    }
                    let middleAngle = _core_util_Math__WEBPACK_IMPORTED_MODULE_8__.normalizeAngle(currentAngle + currentArc / 2);
                    const label = dataItem.get("label");
                    if (label) {
                        label.setPrivate("radius", radius);
                        label.setPrivate("innerRadius", innerRadius);
                        label.set("labelAngle", middleAngle);
                        if (label.get("textType") == "aligned") {
                            let labelRadius = radius + label.get("radius", 0);
                            let y = radius * _core_util_Math__WEBPACK_IMPORTED_MODULE_8__.sin(middleAngle);
                            if (middleAngle > 90 && middleAngle <= 270) {
                                if (!label.isHidden() && !label.isHiding()) {
                                    this._lLabels.push({ label: label, y: y });
                                }
                                labelRadius *= -1;
                                labelRadius -= this.labelsContainer.get("paddingLeft", 0);
                                label.set("centerX", _core_util_Percent__WEBPACK_IMPORTED_MODULE_9__.p100);
                                label.setPrivateRaw("left", true);
                            }
                            else {
                                if (!label.isHidden() && !label.isHiding()) {
                                    this._rLabels.push({ label: label, y: y });
                                }
                                labelRadius += this.labelsContainer.get("paddingRight", 0);
                                label.set("centerX", 0);
                                label.setPrivateRaw("left", false);
                            }
                            label.set("x", labelRadius);
                            label.set("y", radius * _core_util_Math__WEBPACK_IMPORTED_MODULE_8__.sin(middleAngle));
                        }
                    }
                    currentAngle += currentArc;
                    this._updateTick(dataItem);
                });
                //}
            }
        }
    }
    _updateTick(dataItem) {
        const tick = dataItem.get("tick");
        const label = dataItem.get("label");
        const slice = dataItem.get("slice");
        const location = tick.get("location", 1);
        if (tick && label && slice) {
            const radius = (slice.get("shiftRadius", 0) + slice.get("radius", 0)) * slice.get("scale", 1) * location;
            const labelAngle = label.get("labelAngle", 0);
            const cos = _core_util_Math__WEBPACK_IMPORTED_MODULE_8__.cos(labelAngle);
            const sin = _core_util_Math__WEBPACK_IMPORTED_MODULE_8__.sin(labelAngle);
            const labelsContainer = this.labelsContainer;
            const pl = labelsContainer.get("paddingLeft", 0);
            const pr = labelsContainer.get("paddingRight", 0);
            let x = 0;
            let y = 0;
            x = label.x();
            y = label.y();
            let points = [];
            if (x != 0 && y != 0) {
                if (label.get("textType") == "circular") {
                    const labelRadius = label.radius() - label.get("paddingBottom", 0);
                    const labelAngle = label.get("labelAngle", 0);
                    x = labelRadius * _core_util_Math__WEBPACK_IMPORTED_MODULE_8__.cos(labelAngle);
                    y = labelRadius * _core_util_Math__WEBPACK_IMPORTED_MODULE_8__.sin(labelAngle);
                }
                let dx = -pr;
                if (label.getPrivate("left")) {
                    dx = pl;
                }
                points = [{ x: slice.x() + radius * cos, y: slice.y() + radius * sin }, { x: x + dx, y: y }, { x: x, y: y }];
            }
            tick.set("points", points);
        }
    }
    _positionBullet(bullet) {
        const sprite = bullet.get("sprite");
        if (sprite) {
            const dataItem = sprite.dataItem;
            const slice = dataItem.get("slice");
            if (slice) {
                const innerRadius = slice.get("innerRadius", 0);
                const radius = slice.get("radius", 0);
                const startAngle = slice.get("startAngle", 0);
                const arc = slice.get("arc", 0);
                const locationX = bullet.get("locationX", 0.5);
                const locationY = bullet.get("locationY", 0.5);
                const angle = startAngle + arc * locationX;
                const r = innerRadius + (radius - innerRadius) * locationY;
                sprite.setAll({ x: _core_util_Math__WEBPACK_IMPORTED_MODULE_8__.cos(angle) * r, y: _core_util_Math__WEBPACK_IMPORTED_MODULE_8__.sin(angle) * r });
            }
        }
    }
}
Object.defineProperty(PieSeries, "className", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: "PieSeries"
});
Object.defineProperty(PieSeries, "classNames", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: _percent_PercentSeries__WEBPACK_IMPORTED_MODULE_0__.PercentSeries.classNames.concat([PieSeries.className])
});
//# sourceMappingURL=PieSeries.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/charts/xy/XYChart.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/charts/xy/XYChart.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   XYChart: () => (/* binding */ XYChart)
/* harmony export */ });
/* harmony import */ var _XYChartDefaultTheme__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./XYChartDefaultTheme */ "./node_modules/@amcharts/amcharts5/.internal/charts/xy/XYChartDefaultTheme.js");
/* harmony import */ var _core_render_Container__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../core/render/Container */ "./node_modules/@amcharts/amcharts5/.internal/core/render/Container.js");
/* harmony import */ var _core_render_Rectangle__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../core/render/Rectangle */ "./node_modules/@amcharts/amcharts5/.internal/core/render/Rectangle.js");
/* harmony import */ var _core_render_SerialChart__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/render/SerialChart */ "./node_modules/@amcharts/amcharts5/.internal/core/render/SerialChart.js");
/* harmony import */ var _core_util_List__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../core/util/List */ "./node_modules/@amcharts/amcharts5/.internal/core/util/List.js");
/* harmony import */ var _core_util_Percent__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../core/util/Percent */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Percent.js");
/* harmony import */ var _core_util_Color__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../core/util/Color */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Color.js");
/* harmony import */ var _core_render_Button__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../core/render/Button */ "./node_modules/@amcharts/amcharts5/.internal/core/render/Button.js");
/* harmony import */ var _core_render_Graphics__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../core/render/Graphics */ "./node_modules/@amcharts/amcharts5/.internal/core/render/Graphics.js");
/* harmony import */ var _core_util_Array__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../core/util/Array */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Array.js");
/* harmony import */ var _core_util_Type__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../../core/util/Type */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Type.js");
/* harmony import */ var _core_util_Order__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../../core/util/Order */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Order.js");
/* harmony import */ var _core_util_Object__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../core/util/Object */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Object.js");
/* harmony import */ var _core_util_Utils__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../core/util/Utils */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Utils.js");
;















/**
 * Creates an XY chart.
 *
 * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/} for more info
 * @important
 */
class XYChart extends _core_render_SerialChart__WEBPACK_IMPORTED_MODULE_0__.SerialChart {
    constructor() {
        super(...arguments);
        /**
         * A list of horizontal axes.
         */
        Object.defineProperty(this, "xAxes", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new _core_util_List__WEBPACK_IMPORTED_MODULE_1__.ListAutoDispose()
        });
        /**
         * A list of vertical axes.
         */
        Object.defineProperty(this, "yAxes", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new _core_util_List__WEBPACK_IMPORTED_MODULE_1__.ListAutoDispose()
        });
        /**
         * A [[Container]] located on top of the chart, used to store top horizontal
         * axes.
         *
         * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/xy-chart-containers/} for more info
         * @default Container.new()
         */
        Object.defineProperty(this, "topAxesContainer", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: this.chartContainer.children.push(_core_render_Container__WEBPACK_IMPORTED_MODULE_2__.Container.new(this._root, { width: _core_util_Percent__WEBPACK_IMPORTED_MODULE_3__.p100, layout: this._root.verticalLayout }))
        });
        /**
         * A [[Container]] located in the middle the chart, used to store vertical axes
         * and plot area container.
         *
         * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/xy-chart-containers/} for more info
         * @default Container.new()
         */
        Object.defineProperty(this, "yAxesAndPlotContainer", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: this.chartContainer.children.push(_core_render_Container__WEBPACK_IMPORTED_MODULE_2__.Container.new(this._root, { width: _core_util_Percent__WEBPACK_IMPORTED_MODULE_3__.p100, height: _core_util_Percent__WEBPACK_IMPORTED_MODULE_3__.p100, layout: this._root.horizontalLayout }))
        });
        /**
         * A [[Container]] located on bottom of the chart, used to store bottom
         * horizontal axes.
         *
         * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/xy-chart-containers/} for more info
         * @default Container.new()
         */
        Object.defineProperty(this, "bottomAxesContainer", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: this.chartContainer.children.push(_core_render_Container__WEBPACK_IMPORTED_MODULE_2__.Container.new(this._root, { width: _core_util_Percent__WEBPACK_IMPORTED_MODULE_3__.p100, layout: this._root.verticalLayout }))
        });
        /**
         * A [[Container]] located on left of the chart, used to store left-hand
         * vertical axes.
         *
         * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/xy-chart-containers/} for more info
         * @default Container.new()
         */
        Object.defineProperty(this, "leftAxesContainer", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: this.yAxesAndPlotContainer.children.push(_core_render_Container__WEBPACK_IMPORTED_MODULE_2__.Container.new(this._root, { height: _core_util_Percent__WEBPACK_IMPORTED_MODULE_3__.p100, layout: this._root.horizontalLayout }))
        });
        /**
         * A [[Container]] located in the middle of the chart, used to store plotContainer and topPlotContainer
         *
         * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/xy-chart-containers/} for more info
         * @default Container.new()
         */
        Object.defineProperty(this, "plotsContainer", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: this.yAxesAndPlotContainer.children.push(_core_render_Container__WEBPACK_IMPORTED_MODULE_2__.Container.new(this._root, { width: _core_util_Percent__WEBPACK_IMPORTED_MODULE_3__.p100, height: _core_util_Percent__WEBPACK_IMPORTED_MODULE_3__.p100, maskContent: false }))
        });
        /**
         * A [[Container]] located in the middle of the chart, used to store actual
         * plots (series).
         *
         * NOTE: `plotContainer` will automatically have its `background` preset. If
         * you need to modify background or outline for chart's plot area, you can
         * use `plotContainer.get("background")` for that.*
         *
         * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/xy-chart-containers/} for more info
         * @default Container.new()
         */
        Object.defineProperty(this, "plotContainer", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: this.plotsContainer.children.push(_core_render_Container__WEBPACK_IMPORTED_MODULE_2__.Container.new(this._root, { width: _core_util_Percent__WEBPACK_IMPORTED_MODULE_3__.p100, height: _core_util_Percent__WEBPACK_IMPORTED_MODULE_3__.p100 }))
        });
        /**
         * A [[Container]] used for any elements that need to be displayed over
         * regular `plotContainer`.
         *
         * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/xy-chart-containers/} for more info
         * @default Container.new()
         */
        Object.defineProperty(this, "topPlotContainer", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: this.plotsContainer.children.push(_core_render_Container__WEBPACK_IMPORTED_MODULE_2__.Container.new(this._root, { width: _core_util_Percent__WEBPACK_IMPORTED_MODULE_3__.p100, height: _core_util_Percent__WEBPACK_IMPORTED_MODULE_3__.p100 }))
        });
        /**
         * A [[Container]] axis grid elements are stored in.
         *
         * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/xy-chart-containers/} for more info
         * @default Container.new()
         */
        Object.defineProperty(this, "gridContainer", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: this.plotContainer.children.push(_core_render_Container__WEBPACK_IMPORTED_MODULE_2__.Container.new(this._root, { width: _core_util_Percent__WEBPACK_IMPORTED_MODULE_3__.p100, height: _core_util_Percent__WEBPACK_IMPORTED_MODULE_3__.p100, isMeasured: false }))
        });
        /**
         * A [[Container]] axis background grid elements are stored in.
         *
         * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/xy-chart-containers/} for more info
         * @default Container.new()
         */
        Object.defineProperty(this, "topGridContainer", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: _core_render_Container__WEBPACK_IMPORTED_MODULE_2__.Container.new(this._root, { width: _core_util_Percent__WEBPACK_IMPORTED_MODULE_3__.p100, height: _core_util_Percent__WEBPACK_IMPORTED_MODULE_3__.p100, isMeasured: false })
        });
        /**
         * A [[Container]] located on right of the chart, used to store right-hand
         * vertical axes.
         *
         * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/xy-chart-containers/} for more info
         * @default Container.new()
         */
        Object.defineProperty(this, "rightAxesContainer", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: this.yAxesAndPlotContainer.children.push(_core_render_Container__WEBPACK_IMPORTED_MODULE_2__.Container.new(this._root, { height: _core_util_Percent__WEBPACK_IMPORTED_MODULE_3__.p100, layout: this._root.horizontalLayout }))
        });
        /**
         * A [[Container]] axis headers are stored in.
         *
         * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/axis-headers/} for more info
         * @default Container.new()
         */
        Object.defineProperty(this, "axisHeadersContainer", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: this.plotContainer.children.push(_core_render_Container__WEBPACK_IMPORTED_MODULE_2__.Container.new(this._root, {}))
        });
        /**
         * A button that is shown when chart is not fully zoomed out.
         *
         * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/zoom-and-pan/#Zoom_out_button} for more info
         * @default Button.new()
         */
        Object.defineProperty(this, "zoomOutButton", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: this.topPlotContainer.children.push(_core_render_Button__WEBPACK_IMPORTED_MODULE_4__.Button.new(this._root, {
                themeTags: ["zoom"],
                icon: _core_render_Graphics__WEBPACK_IMPORTED_MODULE_5__.Graphics.new(this._root, {
                    themeTags: ["button", "icon"]
                })
            }))
        });
        Object.defineProperty(this, "_movePoint", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: { x: 0, y: 0 }
        });
        Object.defineProperty(this, "_wheelDp", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_otherCharts", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_movePoints", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {}
        });
        Object.defineProperty(this, "_downStartX", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_downEndX", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_downStartY", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_downEndY", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
    }
    _afterNew() {
        this._defaultThemes.push(_XYChartDefaultTheme__WEBPACK_IMPORTED_MODULE_6__.XYChartDefaultTheme.new(this._root));
        super._afterNew();
        this._disposers.push(this.xAxes);
        this._disposers.push(this.yAxes);
        const root = this._root;
        let verticalLayout = this._root.verticalLayout;
        const zoomOutButton = this.zoomOutButton;
        zoomOutButton.events.on("click", () => {
            this.zoomOut();
        });
        zoomOutButton.hide(0);
        zoomOutButton.states.lookup("default").set("opacity", 1);
        this.chartContainer.set("layout", verticalLayout);
        const plotContainer = this.plotContainer;
        plotContainer.children.push(this.seriesContainer);
        this._disposers.push(this._processAxis(this.xAxes, this.bottomAxesContainer));
        this._disposers.push(this._processAxis(this.yAxes, this.leftAxesContainer));
        plotContainer.children.push(this.topGridContainer);
        plotContainer.children.push(this.bulletsContainer);
        // Setting trasnparent background so that full body of the plot container
        // is interactive
        plotContainer.set("interactive", true);
        plotContainer.set("interactiveChildren", false);
        plotContainer.set("background", _core_render_Rectangle__WEBPACK_IMPORTED_MODULE_7__.Rectangle.new(root, {
            themeTags: ["xy", "background"],
            fill: _core_util_Color__WEBPACK_IMPORTED_MODULE_8__.Color.fromHex(0x000000),
            fillOpacity: 0
        }));
        this._disposers.push(plotContainer.events.on("pointerdown", (event) => {
            this._handlePlotDown(event);
        }));
        this._disposers.push(plotContainer.events.on("globalpointerup", (event) => {
            this._handlePlotUp(event);
        }));
        this._disposers.push(plotContainer.events.on("globalpointermove", (event) => {
            this._handlePlotMove(event);
        }));
        this._maskGrid();
        this._setUpTouch();
    }
    _beforeChanged() {
        super._beforeChanged();
        if (this.isDirty("pinchZoomX") || this.isDirty("pinchZoomY") || this.get("panX") || this.get("panY")) {
            this._setUpTouch();
        }
    }
    _setUpTouch() {
        if (!this.plotContainer._display.cancelTouch) {
            this.plotContainer._display.cancelTouch = (this.get("pinchZoomX") || this.get("pinchZoomY") || this.get("panX") || this.get("panY")) ? true : false;
        }
    }
    _maskGrid() {
        this.gridContainer.set("maskContent", true);
        this.topGridContainer.set("maskContent", true);
    }
    _removeSeries(series) {
        series._unstack();
        if (series._posXDp) {
            series._posXDp.dispose();
        }
        if (series._posYDp) {
            series._posYDp.dispose();
        }
        series.set("baseAxis", undefined);
        const xAxis = series.get("xAxis");
        if (xAxis) {
            _core_util_Array__WEBPACK_IMPORTED_MODULE_9__.remove(xAxis.series, series);
            xAxis.markDirtyExtremes();
        }
        const yAxis = series.get("yAxis");
        if (yAxis) {
            _core_util_Array__WEBPACK_IMPORTED_MODULE_9__.remove(yAxis.series, series);
            yAxis.markDirtyExtremes();
        }
        const cursor = this.get("cursor");
        if (cursor) {
            const snapToSeries = cursor.get("snapToSeries");
            if (snapToSeries) {
                _core_util_Array__WEBPACK_IMPORTED_MODULE_9__.remove(snapToSeries, series);
            }
        }
        super._removeSeries(series);
    }
    /**
     * This method is invoked when mouse wheel is used over chart's plot
     * container, and handles zooming/pan.
     *
     * You can invoke this method manually, if you need to mimic chart's wheel
     * behavior over other elements of the chart.
     */
    handleWheel(event) {
        const wheelX = this.get("wheelX");
        const wheelY = this.get("wheelY");
        const plotContainer = this.plotContainer;
        const wheelEvent = event.originalEvent;
        // Ignore wheel event if it is happening on a non-chart element, e.g. if
        // some page element is over the chart.
        if (_core_util_Utils__WEBPACK_IMPORTED_MODULE_10__.isLocalEvent(wheelEvent, this)) {
            wheelEvent.preventDefault();
        }
        else {
            return;
        }
        const plotPoint = plotContainer.toLocal(event.point);
        const wheelStep = this.get("wheelStep", 0.2);
        const shiftY = wheelEvent.deltaY / 100;
        const shiftX = wheelEvent.deltaX / 100;
        const wheelZoomPositionX = this.get("wheelZoomPositionX");
        const wheelZoomPositionY = this.get("wheelZoomPositionY");
        if ((wheelX === "zoomX" || wheelX === "zoomXY") && shiftX != 0) {
            this.xAxes.each((axis) => {
                if (axis.get("zoomX")) {
                    let start = axis.get("start");
                    let end = axis.get("end");
                    let position = axis.fixPosition(plotPoint.x / plotContainer.width());
                    if (wheelZoomPositionX != null) {
                        position = wheelZoomPositionX;
                    }
                    let newStart = start - wheelStep * (end - start) * shiftX * position;
                    let newEnd = end + wheelStep * (end - start) * shiftX * (1 - position);
                    if (1 / (newEnd - newStart) < axis.getPrivate("maxZoomFactor", Infinity) / axis.get("minZoomCount", 1)) {
                        this._handleWheelAnimation(axis.zoom(newStart, newEnd));
                    }
                }
            });
        }
        if ((wheelY === "zoomX" || wheelY === "zoomXY") && shiftY != 0) {
            this.xAxes.each((axis) => {
                if (axis.get("zoomX")) {
                    let start = axis.get("start");
                    let end = axis.get("end");
                    let position = axis.fixPosition(plotPoint.x / plotContainer.width());
                    if (wheelZoomPositionX != null) {
                        position = wheelZoomPositionX;
                    }
                    let newStart = start - wheelStep * (end - start) * shiftY * position;
                    let newEnd = end + wheelStep * (end - start) * shiftY * (1 - position);
                    if (1 / (newEnd - newStart) < axis.getPrivate("maxZoomFactor", Infinity) / axis.get("minZoomCount", 1)) {
                        this._handleWheelAnimation(axis.zoom(newStart, newEnd));
                    }
                }
            });
        }
        if ((wheelX === "zoomY" || wheelX === "zoomXY") && shiftX != 0) {
            this.yAxes.each((axis) => {
                if (axis.get("zoomY")) {
                    let start = axis.get("start");
                    let end = axis.get("end");
                    let position = axis.fixPosition(plotPoint.y / plotContainer.height());
                    if (wheelZoomPositionY != null) {
                        position = wheelZoomPositionY;
                    }
                    let newStart = start - wheelStep * (end - start) * shiftX * position;
                    let newEnd = end + wheelStep * (end - start) * shiftX * (1 - position);
                    if (1 / (newEnd - newStart) < axis.getPrivate("maxZoomFactor", Infinity) / axis.get("minZoomCount", 1)) {
                        this._handleWheelAnimation(axis.zoom(newStart, newEnd));
                    }
                }
            });
        }
        if ((wheelY === "zoomY" || wheelY === "zoomXY") && shiftY != 0) {
            this.yAxes.each((axis) => {
                if (axis.get("zoomY")) {
                    let start = axis.get("start");
                    let end = axis.get("end");
                    let position = axis.fixPosition(plotPoint.y / plotContainer.height());
                    if (wheelZoomPositionY != null) {
                        position = wheelZoomPositionY;
                    }
                    let newStart = start - wheelStep * (end - start) * shiftY * position;
                    let newEnd = end + wheelStep * (end - start) * shiftY * (1 - position);
                    if (1 / (newEnd - newStart) < axis.getPrivate("maxZoomFactor", Infinity) / axis.get("minZoomCount", 1)) {
                        this._handleWheelAnimation(axis.zoom(newStart, newEnd));
                    }
                }
            });
        }
        if ((wheelX === "panX" || wheelX === "panXY") && shiftX != 0) {
            this.xAxes.each((axis) => {
                if (axis.get("panX")) {
                    let start = axis.get("start");
                    let end = axis.get("end");
                    let delta = this._getWheelSign(axis) * wheelStep * (end - start) * shiftX;
                    let newStart = start + delta;
                    let newEnd = end + delta;
                    let se = this._fixWheel(newStart, newEnd);
                    newStart = se[0];
                    newEnd = se[1];
                    this._handleWheelAnimation(axis.zoom(newStart, newEnd));
                }
            });
        }
        if ((wheelY === "panX" || wheelY === "panXY") && shiftY != 0) {
            this.xAxes.each((axis) => {
                if (axis.get("panX")) {
                    let start = axis.get("start");
                    let end = axis.get("end");
                    let delta = this._getWheelSign(axis) * wheelStep * (end - start) * shiftY;
                    let newStart = start + delta;
                    let newEnd = end + delta;
                    let se = this._fixWheel(newStart, newEnd);
                    newStart = se[0];
                    newEnd = se[1];
                    this._handleWheelAnimation(axis.zoom(newStart, newEnd));
                }
            });
        }
        if ((wheelX === "panY" || wheelX === "panXY") && shiftX != 0) {
            this.yAxes.each((axis) => {
                if (axis.get("panY")) {
                    let start = axis.get("start");
                    let end = axis.get("end");
                    let delta = this._getWheelSign(axis) * wheelStep * (end - start) * shiftX;
                    let newStart = start + delta;
                    let newEnd = end + delta;
                    let se = this._fixWheel(newStart, newEnd);
                    newStart = se[0];
                    newEnd = se[1];
                    this._handleWheelAnimation(axis.zoom(newStart, newEnd));
                }
            });
        }
        if ((wheelY === "panY" || wheelY === "panXY") && shiftY != 0) {
            this.yAxes.each((axis) => {
                if (axis.get("panY")) {
                    let start = axis.get("start");
                    let end = axis.get("end");
                    let delta = this._getWheelSign(axis) * wheelStep * (end - start) * shiftY;
                    let newStart = start - delta;
                    let newEnd = end - delta;
                    let se = this._fixWheel(newStart, newEnd);
                    newStart = se[0];
                    newEnd = se[1];
                    this._handleWheelAnimation(axis.zoom(newStart, newEnd));
                }
            });
        }
    }
    _handleSetWheel() {
        const wheelX = this.get("wheelX");
        const wheelY = this.get("wheelY");
        const plotContainer = this.plotContainer;
        if (wheelX !== "none" || wheelY !== "none") {
            this._wheelDp = plotContainer.events.on("wheel", (event) => {
                const wheelEvent = event.originalEvent;
                if ((wheelX !== "none" && Math.abs(wheelEvent.deltaX) != 0) || (wheelY !== "none" && Math.abs(wheelEvent.deltaY) != 0)) {
                    this.handleWheel(event);
                }
            });
            this._disposers.push(this._wheelDp);
        }
        else {
            if (this._wheelDp) {
                this._wheelDp.dispose();
            }
        }
    }
    _getWheelSign(axis) {
        let sign = 1;
        if (axis.get("renderer").get("inversed")) {
            sign = -1;
        }
        return sign;
    }
    _fixWheel(start, end) {
        const diff = end - start;
        if (start < 0) {
            start = 0;
            end = start + diff;
        }
        if (end > 1) {
            end = 1;
            start = end - diff;
        }
        return [start, end];
    }
    _handlePlotDown(event) {
        const originalEvent = event.originalEvent;
        if (originalEvent.button == 2) {
            return;
        }
        const plotContainer = this.plotContainer;
        let local = plotContainer.toLocal(event.point);
        if (this.get("pinchZoomX") || this.get("pinchZoomY")) {
            const pointerId = originalEvent.pointerId;
            if (pointerId) {
                if (_core_util_Object__WEBPACK_IMPORTED_MODULE_11__.keys(plotContainer._downPoints).length > 0) {
                    const xAxis = this.xAxes.getIndex(0);
                    const yAxis = this.yAxes.getIndex(0);
                    if (xAxis) {
                        this._downStartX = xAxis.get("start", 0);
                        this._downEndX = xAxis.get("end", 1);
                    }
                    if (yAxis) {
                        this._downStartY = yAxis.get("start", 0);
                        this._downEndY = yAxis.get("end", 1);
                    }
                }
            }
        }
        if (this.get("panX") || this.get("panY")) {
            if (local.x >= 0 && local.y >= 0 && local.x <= plotContainer.width() && local.y <= this.height()) {
                //this._downPoint = local;
                this._downPoint = { x: originalEvent.clientX, y: originalEvent.clientY };
                const panX = this.get("panX");
                const panY = this.get("panY");
                if (panX) {
                    this.xAxes.each((axis) => {
                        axis._panStart = axis.get("start");
                        axis._panEnd = axis.get("end");
                    });
                }
                if (panY) {
                    this.yAxes.each((axis) => {
                        axis._panStart = axis.get("start");
                        axis._panEnd = axis.get("end");
                    });
                }
                const eventType = "panstarted";
                if (this.events.isEnabled(eventType)) {
                    this.events.dispatch(eventType, { type: eventType, target: this, originalEvent: event.originalEvent });
                }
            }
        }
    }
    _handleWheelAnimation(animation) {
        if (animation) {
            animation.events.on("stopped", () => {
                this._dispatchWheelAnimation();
            });
        }
        else {
            this._dispatchWheelAnimation();
        }
    }
    _dispatchWheelAnimation() {
        const eventType = "wheelended";
        if (this.events.isEnabled(eventType)) {
            this.events.dispatch(eventType, { type: eventType, target: this });
        }
    }
    _handlePlotUp(event) {
        const downPoint = this._downPoint;
        if (downPoint) {
            if (this.get("panX") || this.get("panY")) {
                let local = this.plotContainer.toLocal(event.point);
                if (local.x == downPoint.x && local.y == downPoint.y) {
                    const eventType = "pancancelled";
                    if (this.events.isEnabled(eventType)) {
                        this.events.dispatch(eventType, { type: eventType, target: this, originalEvent: event.originalEvent });
                    }
                }
                const eventType = "panended";
                if (this.events.isEnabled(eventType)) {
                    this.events.dispatch(eventType, { type: eventType, target: this, originalEvent: event.originalEvent });
                }
            }
        }
        // TODO: handle multitouch
        this._downPoint = undefined;
        this.xAxes.each((xAxis) => {
            xAxis._isPanning = false;
        });
        this.yAxes.each((yAxis) => {
            yAxis._isPanning = false;
        });
    }
    _handlePlotMove(event) {
        const plotContainer = this.plotContainer;
        if (this.get("pinchZoomX") || this.get("pinchZoomY")) {
            const touchEvent = event.originalEvent;
            const pointerId = touchEvent.pointerId;
            if (pointerId) {
                this._movePoints[pointerId] = event.point;
                if (_core_util_Object__WEBPACK_IMPORTED_MODULE_11__.keys(plotContainer._downPoints).length > 1) {
                    this._handlePinch();
                    return;
                }
            }
        }
        let downPoint = this._downPoint;
        if (downPoint) {
            downPoint = plotContainer.toLocal(this._root.documentPointToRoot(downPoint));
            let local = plotContainer.toLocal(event.point);
            const panX = this.get("panX");
            const panY = this.get("panY");
            if (panX) {
                let scrollbarX = this.get("scrollbarX");
                if (scrollbarX) {
                    scrollbarX.events.disableType("rangechanged");
                }
                this.xAxes.each((axis) => {
                    if (axis.get("panX")) {
                        axis._isPanning = true;
                        //const maxDeviation = axis.get("maxDeviation", 0);
                        let panStart = axis._panStart;
                        let panEnd = axis._panEnd;
                        let difference = (panEnd - panStart);
                        let deltaX = difference * (downPoint.x - local.x) / plotContainer.width();
                        if (axis.get("renderer").get("inversed")) {
                            deltaX *= -1;
                        }
                        let start = panStart + deltaX;
                        let end = panEnd + deltaX;
                        if (end - start < 1 + axis.get("maxDeviation", 1) * 2) {
                            axis.set("start", start);
                            axis.set("end", end);
                        }
                    }
                });
                if (scrollbarX) {
                    scrollbarX.events.enableType("rangechanged");
                }
            }
            if (panY) {
                let scrollbarY = this.get("scrollbarY");
                if (scrollbarY) {
                    scrollbarY.events.disableType("rangechanged");
                }
                this.yAxes.each((axis) => {
                    if (axis.get("panY")) {
                        axis._isPanning = true;
                        //const maxDeviation = axis.get("maxDeviation", 0);
                        let panStart = axis._panStart;
                        let panEnd = axis._panEnd;
                        let difference = (panEnd - panStart);
                        let deltaY = difference * (downPoint.y - local.y) / plotContainer.height();
                        if (axis.get("renderer").get("inversed")) {
                            deltaY *= -1;
                        }
                        let start = panStart - deltaY;
                        let end = panEnd - deltaY;
                        if (end - start < 1 + axis.get("maxDeviation", 1) * 2) {
                            axis.set("start", start);
                            axis.set("end", end);
                        }
                    }
                });
                if (scrollbarY) {
                    scrollbarY.events.enableType("rangechanged");
                }
            }
        }
    }
    _handlePinch() {
        const plotContainer = this.plotContainer;
        let i = 0;
        let downPoints = [];
        let movePoints = [];
        _core_util_Object__WEBPACK_IMPORTED_MODULE_11__.each(plotContainer._downPoints, (k, point) => {
            downPoints[i] = point;
            let movePoint = this._movePoints[k];
            if (movePoint) {
                movePoints[i] = movePoint;
            }
            i++;
        });
        if (downPoints.length > 1 && movePoints.length > 1) {
            const w = plotContainer.width();
            const h = plotContainer.height();
            let downPoint0 = downPoints[0];
            let downPoint1 = downPoints[1];
            let movePoint0 = movePoints[0];
            let movePoint1 = movePoints[1];
            if (downPoint0 && downPoint1 && movePoint0 && movePoint1) {
                movePoint0 = plotContainer.toLocal(movePoint0);
                movePoint1 = plotContainer.toLocal(movePoint1);
                downPoint0 = plotContainer.toLocal(downPoint0);
                downPoint1 = plotContainer.toLocal(downPoint1);
                if (this.get("pinchZoomX")) {
                    const downStartX = this._downStartX;
                    const downEndX = this._downEndX;
                    if (downStartX != null && downEndX != null) {
                        if (downPoint0.x > downPoint1.x) {
                            [downPoint0, downPoint1] = [downPoint1, downPoint0];
                            [movePoint0, movePoint1] = [movePoint1, movePoint0];
                        }
                        let downPos0 = downStartX + (downPoint0.x / w) * (downEndX - downStartX);
                        let downPos1 = downStartX + (downPoint1.x / w) * (downEndX - downStartX);
                        let movePos0 = downStartX + (movePoint0.x / w) * (downEndX - downStartX);
                        let movePos1 = downStartX + (movePoint1.x / w) * (downEndX - downStartX);
                        let initialDistance = Math.max(0.001, downPos1 - downPos0);
                        let currentDistance = Math.max(0.001, movePos1 - movePos0);
                        let d = initialDistance / currentDistance;
                        let s = downStartX * d + downPos0 - movePos0 * d;
                        let e = downEndX * d + downPos1 - movePos1 * d;
                        this.xAxes.each((xAxis) => {
                            let sa = xAxis.fixPosition(s);
                            let ea = xAxis.fixPosition(e);
                            xAxis.zoom(sa, ea, 0);
                        });
                    }
                }
                if (this.get("pinchZoomY")) {
                    const downStartY = this._downStartY;
                    const downEndY = this._downEndY;
                    if (downStartY != null && downEndY != null) {
                        if (downPoint0.y < downPoint1.y) {
                            [downPoint0, downPoint1] = [downPoint1, downPoint0];
                            [movePoint0, movePoint1] = [movePoint1, movePoint0];
                        }
                        let downPos0 = downStartY + (1 - downPoint0.y / h) * (downEndY - downStartY);
                        let downPos1 = downStartY + (1 - downPoint1.y / h) * (downEndY - downStartY);
                        let movePos0 = downStartY + (1 - movePoint0.y / h) * (downEndY - downStartY);
                        let movePos1 = downStartY + (1 - movePoint1.y / h) * (downEndY - downStartY);
                        let initialDistance = Math.max(0.001, downPos1 - downPos0);
                        let currentDistance = Math.max(0.001, movePos1 - movePos0);
                        let d = initialDistance / currentDistance;
                        let s = downStartY * d + downPos0 - movePos0 * d;
                        let e = downEndY * d + downPos1 - movePos1 * d;
                        this.yAxes.each((yAxis) => {
                            let sa = yAxis.fixPosition(s);
                            let ea = yAxis.fixPosition(e);
                            yAxis.zoom(sa, ea, 0);
                        });
                    }
                }
            }
        }
    }
    _handleCursorPosition() {
        const cursor = this.get("cursor");
        if (cursor) {
            const cursorPoint = cursor.getPrivate("point");
            let snapToSeries = cursor.get("snapToSeries");
            if (cursor._downPoint) {
                snapToSeries = undefined;
            }
            if (snapToSeries && cursorPoint) {
                const snapToSeriesBy = cursor.get("snapToSeriesBy");
                const dataItems = [];
                _core_util_Array__WEBPACK_IMPORTED_MODULE_9__.each(snapToSeries, (series) => {
                    if (!series.isHidden() && !series.isHiding()) {
                        if (snapToSeriesBy != "x!" && snapToSeriesBy != "y!") {
                            const startIndex = series.startIndex();
                            const endIndex = series.endIndex();
                            for (let i = startIndex; i < endIndex; i++) {
                                const dataItem = series.dataItems[i];
                                if (dataItem && !dataItem.isHidden()) {
                                    dataItems.push(dataItem);
                                }
                            }
                        }
                        else {
                            const tooltipDataItem = series.get("tooltipDataItem");
                            if (tooltipDataItem) {
                                dataItems.push(tooltipDataItem);
                            }
                        }
                    }
                });
                let minDistance = Infinity;
                let closestItem;
                _core_util_Array__WEBPACK_IMPORTED_MODULE_9__.each(dataItems, (dataItem) => {
                    const point = dataItem.get("point");
                    if (point) {
                        let distance = 0;
                        if (snapToSeriesBy == "x" || snapToSeriesBy == "x!") {
                            distance = Math.abs(cursorPoint.x - point.x);
                        }
                        else if (snapToSeriesBy == "y" || snapToSeriesBy == "y!") {
                            distance = Math.abs(cursorPoint.y - point.y);
                        }
                        else {
                            distance = Math.hypot(cursorPoint.x - point.x, cursorPoint.y - point.y);
                        }
                        if (distance < minDistance) {
                            minDistance = distance;
                            closestItem = dataItem;
                        }
                    }
                });
                _core_util_Array__WEBPACK_IMPORTED_MODULE_9__.each(snapToSeries, (series) => {
                    const tooltip = series.get("tooltip");
                    if (tooltip) {
                        tooltip._setDataItem(undefined);
                    }
                });
                if (closestItem) {
                    let series = closestItem.component;
                    series.showDataItemTooltip(closestItem);
                    const point = closestItem.get("point");
                    if (point) {
                        // removing x and y to solve #72225
                        cursor.handleMove(series.toGlobal({ x: point.x - series.x(), y: point.y - series.y() }), true);
                    }
                }
            }
        }
    }
    _updateCursor() {
        let cursor = this.get("cursor");
        if (cursor) {
            cursor.updateCursor();
        }
    }
    _addCursor(cursor) {
        this.plotContainer.children.push(cursor);
    }
    _prepareChildren() {
        super._prepareChildren();
        this.series.each((series) => {
            this._colorize(series);
        });
        if (this.isDirty("wheelX") || this.isDirty("wheelY")) {
            this._handleSetWheel();
        }
        if (this.isDirty("cursor")) {
            const previous = this._prevSettings.cursor;
            const cursor = this.get("cursor");
            if (cursor !== previous) {
                this._disposeProperty("cursor");
                if (previous) {
                    previous.dispose();
                }
                if (cursor) {
                    cursor._setChart(this);
                    this._addCursor(cursor);
                    this._pushPropertyDisposer("cursor", cursor.events.on("selectended", () => {
                        this._handleCursorSelectEnd();
                    }));
                }
                //this.setRaw("cursor", cursor) // to reset previous value
                this._prevSettings.cursor = cursor;
            }
        }
        if (this.isDirty("scrollbarX")) {
            const previous = this._prevSettings.scrollbarX;
            const scrollbarX = this.get("scrollbarX");
            if (scrollbarX !== previous) {
                this._disposeProperty("scrollbarX");
                if (previous) {
                    previous.dispose();
                }
                if (scrollbarX) {
                    if (!scrollbarX.parent) {
                        this.topAxesContainer.children.push(scrollbarX);
                    }
                    this._pushPropertyDisposer("scrollbarX", scrollbarX.events.on("rangechanged", (e) => {
                        this._handleScrollbar(this.xAxes, e.start, e.end, e.grip);
                    }));
                    // Used to populate `ariaLabel` with meaningful values
                    scrollbarX.setPrivate("positionTextFunction", (position) => {
                        const axis = this.xAxes.getIndex(0);
                        return axis ? axis.getTooltipText(position, false) || "" : "";
                    });
                }
                this._prevSettings.scrollbarX = scrollbarX;
            }
        }
        if (this.isDirty("scrollbarY")) {
            const previous = this._prevSettings.scrollbarY;
            const scrollbarY = this.get("scrollbarY");
            if (scrollbarY !== previous) {
                this._disposeProperty("scrollbarY");
                if (previous) {
                    previous.dispose();
                }
                if (scrollbarY) {
                    if (!scrollbarY.parent) {
                        this.rightAxesContainer.children.push(scrollbarY);
                    }
                    this._pushPropertyDisposer("scrollbarY", scrollbarY.events.on("rangechanged", (e) => {
                        this._handleScrollbar(this.yAxes, e.start, e.end, e.grip);
                    }));
                    // Used to populate `ariaLabel` with meaningful values
                    scrollbarY.setPrivate("positionTextFunction", (position) => {
                        const axis = this.yAxes.getIndex(0);
                        return axis ? axis.getTooltipText(position, false) || "" : "";
                    });
                }
                this._prevSettings.scrollbarY = scrollbarY;
            }
        }
        this._handleZoomOut();
    }
    _processSeries(series) {
        super._processSeries(series);
        const xAxis = series.get("xAxis");
        const yAxis = series.get("yAxis");
        _core_util_Array__WEBPACK_IMPORTED_MODULE_9__.move(xAxis.series, series);
        _core_util_Array__WEBPACK_IMPORTED_MODULE_9__.move(yAxis.series, series);
        series._posXDp = series.addDisposer(xAxis.events.on("positionchanged", () => {
            series._fixPosition();
        }));
        series._posXDp = series.addDisposer(yAxis.events.on("positionchanged", () => {
            series._fixPosition();
        }));
        if (!series.get("baseAxis")) {
            if (yAxis.isType("CategoryAxis") || yAxis.isType("DateAxis")) {
                series.set("baseAxis", yAxis);
            }
            else {
                series.set("baseAxis", xAxis);
            }
        }
        if (series.get("stacked")) {
            series._markDirtyKey("stacked");
            _core_util_Array__WEBPACK_IMPORTED_MODULE_9__.each(series.dataItems, (dataItem) => {
                dataItem.set("stackToItemY", undefined);
                dataItem.set("stackToItemX", undefined);
            });
        }
        series._markDirtyAxes();
        yAxis.markDirtyExtremes();
        xAxis.markDirtyExtremes();
        this._colorize(series);
    }
    _colorize(series) {
        const colorSet = this.get("colors");
        if (colorSet) {
            if (series.get("fill") == null) {
                const color = colorSet.next();
                series._setSoft("stroke", color);
                series._setSoft("fill", color);
            }
        }
    }
    _handleCursorSelectEnd() {
        const cursor = this.get("cursor");
        const behavior = cursor.get("behavior");
        const downPositionX = cursor.getPrivate("downPositionX", 0);
        const downPositionY = cursor.getPrivate("downPositionY", 0);
        const positionX = Math.min(1, Math.max(0, cursor.getPrivate("positionX", 0.5)));
        const positionY = Math.min(1, Math.max(0, cursor.getPrivate("positionY", 0.5)));
        this.xAxes.each((axis) => {
            if (behavior === "zoomX" || behavior === "zoomXY") {
                let position0 = axis.toAxisPosition(downPositionX);
                let position1 = axis.toAxisPosition(positionX);
                axis.zoom(position0, position1);
            }
            axis.setPrivate("updateScrollbar", true);
        });
        this.yAxes.each((axis) => {
            if (behavior === "zoomY" || behavior === "zoomXY") {
                let position0 = axis.toAxisPosition(downPositionY);
                let position1 = axis.toAxisPosition(positionY);
                axis.zoom(position0, position1);
            }
            axis.setPrivate("updateScrollbar", true);
        });
    }
    _handleScrollbar(axes, start, end, priority) {
        axes.each((axis) => {
            let axisStart = axis.fixPosition(start);
            let axisEnd = axis.fixPosition(end);
            let zoomAnimation = axis.zoom(axisStart, axisEnd, undefined, priority);
            const updateScrollbar = "updateScrollbar";
            axis.setPrivateRaw(updateScrollbar, false);
            if (zoomAnimation) {
                zoomAnimation.events.on("stopped", () => {
                    axis.setPrivateRaw(updateScrollbar, true);
                });
            }
            else {
                axis.setPrivateRaw(updateScrollbar, true);
            }
        });
    }
    _processAxis(axes, container) {
        return axes.events.onAll((change) => {
            if (change.type === "clear") {
                _core_util_Array__WEBPACK_IMPORTED_MODULE_9__.each(change.oldValues, (axis) => {
                    this._removeAxis(axis);
                });
            }
            else if (change.type === "push") {
                container.children.push(change.newValue);
                change.newValue.processChart(this);
            }
            else if (change.type === "setIndex") {
                container.children.setIndex(change.index, change.newValue);
                change.newValue.processChart(this);
            }
            else if (change.type === "insertIndex") {
                container.children.insertIndex(change.index, change.newValue);
                change.newValue.processChart(this);
            }
            else if (change.type === "removeIndex") {
                this._removeAxis(change.oldValue);
            }
            else if (change.type === "moveIndex") {
                container.children.moveValue(change.value, change.newIndex);
                change.value.processChart(this);
            }
            else {
                throw new Error("Unknown IListEvent type");
            }
        });
    }
    _removeAxis(axis) {
        if (!axis.isDisposed()) {
            const axisParent = axis.parent;
            if (axisParent) {
                axisParent.children.removeValue(axis);
            }
            const gridContainer = axis.gridContainer;
            const gridParent = gridContainer.parent;
            if (gridParent) {
                gridParent.children.removeValue(gridContainer);
            }
            const topGridContainer = axis.topGridContainer;
            const topGridParent = topGridContainer.parent;
            if (topGridParent) {
                topGridParent.children.removeValue(topGridContainer);
            }
        }
    }
    _updateChartLayout() {
        const left = this.leftAxesContainer.width();
        const right = this.rightAxesContainer.width();
        const bottomAxesContainer = this.bottomAxesContainer;
        bottomAxesContainer.set("paddingLeft", left);
        bottomAxesContainer.set("paddingRight", right);
        const topAxesContainer = this.topAxesContainer;
        topAxesContainer.set("paddingLeft", left);
        topAxesContainer.set("paddingRight", right);
    }
    /**
     * @ignore
     */
    processAxis(axis) {
        var cursor = this.get("cursor");
        if (cursor) {
            this.addDisposer(axis.on("start", () => {
                this._updateCursor();
            }));
            this.addDisposer(axis.on("end", () => {
                this._updateCursor();
            }));
        }
    }
    _handleAxisSelection(axis, force) {
        let start = axis.fixPosition(axis.get("start", 0));
        let end = axis.fixPosition(axis.get("end", 1));
        if (start > end) {
            [start, end] = [end, start];
        }
        if (this.xAxes.indexOf(axis) != -1) {
            if (force || axis.getPrivate("updateScrollbar")) {
                let scrollbarX = this.get("scrollbarX");
                if (scrollbarX && (!scrollbarX.getPrivate("isBusy") || force)) {
                    scrollbarX.setRaw("start", start);
                    scrollbarX.setRaw("end", end);
                    scrollbarX.updateGrips();
                }
            }
        }
        else if (this.yAxes.indexOf(axis) != -1) {
            if (force || axis.getPrivate("updateScrollbar")) {
                let scrollbarY = this.get("scrollbarY");
                if (scrollbarY && (!scrollbarY.getPrivate("isBusy") || force)) {
                    scrollbarY.setRaw("start", start);
                    scrollbarY.setRaw("end", end);
                    scrollbarY.updateGrips();
                }
            }
        }
        this._handleZoomOut();
    }
    _handleZoomOut() {
        let zoomOutButton = this.zoomOutButton;
        if (zoomOutButton && zoomOutButton.parent) {
            let visible = false;
            this.xAxes.each((axis) => {
                if (axis.get("start") != 0 || axis.get("end") != 1) {
                    visible = true;
                }
            });
            this.yAxes.each((axis) => {
                if (axis.get("start") != 0 || axis.get("end") != 1) {
                    visible = true;
                }
            });
            if (visible) {
                if (zoomOutButton.isHidden()) {
                    zoomOutButton.show();
                }
            }
            else {
                zoomOutButton.hide();
            }
        }
    }
    /**
     * Checks if point is within plot area.
     *
     * @param   point  Reference point
     * @return         Is within plot area?
     */
    inPlot(point) {
        const plotContainer = this.plotContainer;
        const otherCharts = this.getPrivate("otherCharts", this._otherCharts);
        const global = plotContainer.toGlobal(point);
        if (point.x >= -0.5 && point.y >= -0.5 && point.x <= plotContainer.width() + 0.5 && point.y <= plotContainer.height() + 0.5) {
            return true;
        }
        if (otherCharts) {
            for (let i = otherCharts.length - 1; i >= 0; i--) {
                const chart = otherCharts[i];
                if (chart != this) {
                    const chartPlotContainer = chart.plotContainer;
                    const documentPoint = this._root.rootPointToDocument(global);
                    const chartRoot = chart._root.documentPointToRoot(documentPoint);
                    const local = chartPlotContainer.toLocal(chartRoot);
                    if (local.x >= -0.1 && local.y >= -0.1 && local.x <= chartPlotContainer.width() + 0.1 && local.y <= chartPlotContainer.height() + 0.1) {
                        return true;
                    }
                }
            }
        }
        return false;
    }
    /**
     * @ignore
     */
    arrangeTooltips() {
        const plotContainer = this.plotContainer;
        const w = plotContainer.width();
        const h = plotContainer.height();
        const hh = this.height();
        let plotT = plotContainer._display.toGlobal({ x: 0, y: 0 });
        let plotB = plotContainer._display.toGlobal({ x: w, y: h });
        const tooltips = [];
        let sum = 0;
        let minDistance = Infinity;
        let movePoint = this._movePoint;
        let maxTooltipDistance = this.get("maxTooltipDistance");
        let maxTooltipDistanceBy = this.get("maxTooltipDistanceBy", "xy");
        let closest;
        let closestPoint;
        if (_core_util_Type__WEBPACK_IMPORTED_MODULE_12__.isNumber(maxTooltipDistance)) {
            this.series.each((series) => {
                if (!series.isHidden()) {
                    const tooltip = series.get("tooltip");
                    if (tooltip) {
                        let point = tooltip.get("pointTo");
                        if (point) {
                            let distance = Math.hypot(movePoint.x - point.x, movePoint.y - point.y);
                            if (maxTooltipDistanceBy == "x") {
                                distance = Math.abs(movePoint.x - point.x);
                            }
                            else if (maxTooltipDistanceBy == "y") {
                                distance = Math.abs(movePoint.y - point.y);
                            }
                            if (distance < minDistance) {
                                minDistance = distance;
                                closest = series;
                                closestPoint = point;
                            }
                        }
                    }
                }
            });
        }
        const tooltipSeries = [];
        this.series.each((series) => {
            const tooltip = series.get("tooltip");
            if (tooltip && !tooltip.get("forceHidden")) {
                let hidden = false;
                let point = tooltip.get("pointTo");
                if (point) {
                    if (maxTooltipDistance >= 0) {
                        let point = tooltip.get("pointTo");
                        if (point && closestPoint) {
                            if (series != closest) {
                                let distance = Math.hypot(closestPoint.x - point.x, closestPoint.y - point.y);
                                if (maxTooltipDistanceBy == "x") {
                                    distance = Math.abs(closestPoint.x - point.x);
                                }
                                else if (maxTooltipDistanceBy == "y") {
                                    distance = Math.abs(closestPoint.y - point.y);
                                }
                                if (distance > maxTooltipDistance) {
                                    hidden = true;
                                }
                            }
                        }
                    }
                    else if (maxTooltipDistance == -1) {
                        if (series != closest) {
                            hidden = true;
                        }
                    }
                    if (!this.inPlot(this._tooltipToLocal(point)) || !tooltip.dataItem) {
                        hidden = true;
                    }
                    else {
                        if (!hidden) {
                            sum += point.y;
                        }
                    }
                    if (hidden || series.isHidden() || series.isHiding()) {
                        tooltip.hide(0);
                    }
                    else {
                        tooltip.show();
                        tooltips.push(tooltip);
                        tooltipSeries.push(series);
                    }
                }
            }
        });
        this.setPrivate("tooltipSeries", tooltipSeries);
        if (this.get("arrangeTooltips")) {
            const tooltipContainer = this._root.tooltipContainer;
            const count = tooltips.length;
            const average = sum / count;
            if (average > h / 2 + plotT.y) {
                tooltips.sort((a, b) => _core_util_Order__WEBPACK_IMPORTED_MODULE_13__.compareNumber(b.get("pointTo").y, a.get("pointTo").y));
                let prevY = plotB.y;
                _core_util_Array__WEBPACK_IMPORTED_MODULE_9__.each(tooltips, (tooltip) => {
                    let height = tooltip.height();
                    let centerY = tooltip.get("centerY");
                    if (centerY instanceof _core_util_Percent__WEBPACK_IMPORTED_MODULE_3__.Percent) {
                        height *= centerY.value;
                    }
                    height += tooltip.get("marginBottom", 0);
                    tooltip.set("bounds", { left: plotT.x, top: plotT.y, right: plotB.x, bottom: prevY });
                    tooltip.setPrivate("customData", { left: plotT.x, top: plotT.y, right: plotB.x, bottom: prevY });
                    prevY = Math.min(prevY - height, tooltip._fy - height);
                    if (tooltip.parent == tooltipContainer) {
                        tooltipContainer.children.moveValue(tooltip, 0);
                    }
                });
                if (prevY < 0) {
                    tooltips.reverse();
                    let prevBottom = prevY;
                    _core_util_Array__WEBPACK_IMPORTED_MODULE_9__.each(tooltips, (tooltip) => {
                        let bounds = tooltip.get("bounds");
                        if (bounds) {
                            let top = bounds.top - prevY;
                            let bottom = bounds.bottom - prevY;
                            if (top < prevBottom) {
                                top = prevBottom;
                                bottom = top + tooltip.height();
                            }
                            tooltip.set("bounds", { left: bounds.left, top: top, right: bounds.right, bottom: bottom });
                            prevBottom = bounds.bottom - prevY + tooltip.get("marginBottom", 0);
                        }
                    });
                }
            }
            else {
                tooltips.reverse();
                tooltips.sort((a, b) => _core_util_Order__WEBPACK_IMPORTED_MODULE_13__.compareNumber(a.get("pointTo").y, b.get("pointTo").y));
                let prevY = 0;
                _core_util_Array__WEBPACK_IMPORTED_MODULE_9__.each(tooltips, (tooltip) => {
                    let height = tooltip.height();
                    let centerY = tooltip.get("centerY");
                    if (centerY instanceof _core_util_Percent__WEBPACK_IMPORTED_MODULE_3__.Percent) {
                        height *= centerY.value;
                    }
                    height += tooltip.get("marginBottom", 0);
                    tooltip.set("bounds", { left: plotT.x, top: prevY, right: plotB.x, bottom: Math.max(plotT.y + hh, prevY + height) });
                    if (tooltip.parent == tooltipContainer) {
                        tooltipContainer.children.moveValue(tooltip, 0);
                    }
                    prevY = Math.max(prevY + height, tooltip._fy + height);
                });
                if (prevY > hh) {
                    tooltips.reverse();
                    let prevBottom = hh;
                    _core_util_Array__WEBPACK_IMPORTED_MODULE_9__.each(tooltips, (tooltip) => {
                        let bounds = tooltip.get("bounds");
                        if (bounds) {
                            let top = bounds.top - (hh - prevY);
                            let bottom = bounds.bottom - (hh - prevY);
                            if (bottom > prevBottom) {
                                bottom = prevBottom;
                                top = bottom - tooltip.height();
                            }
                            tooltip.set("bounds", { left: bounds.left, top: top, right: bounds.right, bottom: bottom });
                            prevBottom = bottom - tooltip.height() - tooltip.get("marginBottom", 0);
                        }
                    });
                }
            }
        }
    }
    _tooltipToLocal(point) {
        return this.plotContainer.toLocal(point);
    }
    /**
     * Fully zooms out the chart.
     */
    zoomOut() {
        this.xAxes.each((axis) => {
            axis.setPrivate("updateScrollbar", true);
            axis.zoom(0, 1);
        });
        this.yAxes.each((axis) => {
            axis.setPrivate("updateScrollbar", true);
            axis.zoom(0, 1);
        });
    }
}
Object.defineProperty(XYChart, "className", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: "XYChart"
});
Object.defineProperty(XYChart, "classNames", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: _core_render_SerialChart__WEBPACK_IMPORTED_MODULE_0__.SerialChart.classNames.concat([XYChart.className])
});
//# sourceMappingURL=XYChart.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/charts/xy/XYChartDefaultTheme.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/charts/xy/XYChartDefaultTheme.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   XYChartDefaultTheme: () => (/* binding */ XYChartDefaultTheme)
/* harmony export */ });
/* harmony import */ var _core_Theme__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/Theme */ "./node_modules/@amcharts/amcharts5/.internal/core/Theme.js");
/* harmony import */ var _core_util_Percent__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../core/util/Percent */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Percent.js");
/* harmony import */ var _core_util_ColorSet__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../core/util/ColorSet */ "./node_modules/@amcharts/amcharts5/.internal/core/util/ColorSet.js");
/* harmony import */ var _themes_DefaultTheme__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../themes/DefaultTheme */ "./node_modules/@amcharts/amcharts5/.internal/themes/DefaultTheme.js");
/* harmony import */ var _core_util_Time__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../core/util/Time */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Time.js");
/* harmony import */ var _core_util_Type__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../core/util/Type */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Type.js");
/* harmony import */ var _core_util_Math__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../core/util/Math */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Math.js");
/* harmony import */ var _core_util_Object__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../core/util/Object */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Object.js");
/* harmony import */ var _core_util_Array__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../core/util/Array */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Array.js");









/**
 * @ignore
 */
class XYChartDefaultTheme extends _core_Theme__WEBPACK_IMPORTED_MODULE_0__.Theme {
    setupDefaultRules() {
        super.setupDefaultRules();
        const ic = this._root.interfaceColors;
        const language = this._root.language;
        const r = this.rule.bind(this);
        /**
         * ========================================================================
         * charts/xy
         * ========================================================================
         */
        r("XYChart").setAll({
            colors: _core_util_ColorSet__WEBPACK_IMPORTED_MODULE_1__.ColorSet.new(this._root, {}),
            paddingLeft: 20,
            paddingRight: 20,
            paddingTop: 16,
            paddingBottom: 16,
            panX: false,
            panY: false,
            wheelStep: 0.25,
            arrangeTooltips: true,
            pinchZoomX: false,
            pinchZoomY: false
        });
        r("XYSeries").setAll({
            legendLabelText: "{name}"
        });
        /**
         * ------------------------------------------------------------------------
         * charts/xy: XYChartScrollbar
         * ------------------------------------------------------------------------
         */
        r("XYChart", ["scrollbar", "chart"]).setAll({
            paddingBottom: 0,
            paddingLeft: 0,
            paddingTop: 0,
            paddingRight: 0,
            colors: _core_util_ColorSet__WEBPACK_IMPORTED_MODULE_1__.ColorSet.new(this._root, {
                saturation: 0
            })
        });
        {
            const rule = r("Graphics", ["scrollbar", "overlay"]);
            rule.setAll({
                fillOpacity: 0.5
            });
            (0,_themes_DefaultTheme__WEBPACK_IMPORTED_MODULE_2__.setColor)(rule, "fill", ic, "background");
        }
        // Class: RoundedRectangle
        r("RoundedRectangle", ["xy", "scrollbar", "thumb"]).setAll({
            cornerRadiusTR: 0,
            cornerRadiusTL: 0,
            cornerRadiusBR: 0,
            cornerRadiusBL: 0,
            fillOpacity: 0,
            focusable: true
        });
        r("RoundedRectangle", ["xy", "scrollbar", "thumb"]).states.create("hover", { fillOpacity: 0.4 });
        r("RoundedRectangle", ["xy", "scrollbar", "chart", "background"]).setAll({
            cornerRadiusTL: 0,
            cornerRadiusBL: 0,
            cornerRadiusTR: 0,
            cornerRadiusBR: 0
        });
        r("RoundedRectangle", ["xy", "scrollbar", "chart", "background", "resize", "button"]).setAll({
            cornerRadiusBL: 40,
            cornerRadiusBR: 40,
            cornerRadiusTL: 40,
            cornerRadiusTR: 40
        });
        r("AxisRendererX", ["xy", "chart", "scrollbar"]).setAll({
            strokeOpacity: 0,
            inside: true
        });
        r("AxisRendererY", ["xy", "chart", "scrollbar"]).setAll({
            strokeOpacity: 0,
            inside: true,
            minGridDistance: 5
        });
        r("AxisLabel", ["xy", "scrollbar", "x"]).setAll({
            opacity: 0.5,
            centerY: _core_util_Percent__WEBPACK_IMPORTED_MODULE_3__.p100,
            minPosition: 0.01,
            maxPosition: 0.99,
            fontSize: "0.8em"
        });
        r("AxisLabel", ["category"]).setAll({
            text: "{category}",
            populateText: true
        });
        r("AxisLabel", ["x"]).setAll({
            centerY: 0
        });
        r("AxisLabel", ["x", "inside"]).setAll({
            centerY: _core_util_Percent__WEBPACK_IMPORTED_MODULE_3__.p100
        });
        r("AxisLabel", ["x", "inside", "opposite"]).setAll({
            centerY: 0
        });
        r("AxisLabel", ["x", "opposite"]).setAll({
            centerY: _core_util_Percent__WEBPACK_IMPORTED_MODULE_3__.p100
        });
        r("AxisLabel", ["y"]).setAll({
            centerX: _core_util_Percent__WEBPACK_IMPORTED_MODULE_3__.p100
        });
        r("AxisLabel", ["y", "inside"]).setAll({
            centerX: 0
        });
        r("AxisLabel", ["y", "inside", "opposite"]).setAll({
            centerX: _core_util_Percent__WEBPACK_IMPORTED_MODULE_3__.p100
        });
        r("AxisLabel", ["y", "opposite"]).setAll({
            centerX: 0
        });
        r("AxisLabel", ["minor"]).setAll({
            fontSize: "0.6em"
        });
        r("AxisLabel", ["xy", "scrollbar", "y"]).setAll({
            visible: false
        });
        // Class: Grid
        r("Grid", ["xy", "scrollbar", "y"]).setAll({
            visible: false
        });
        // Class: Grid
        r("Grid", ["xy", "scrollbar", "x"]).setAll({
            opacity: 0.5
        });
        /**
         * ------------------------------------------------------------------------
         * charts/xy: Cursor
         * ------------------------------------------------------------------------
         */
        r("XYCursor").setAll({
            behavior: "none",
            layer: 30,
            exportable: false,
            snapToSeriesBy: "xy",
            moveThreshold: 1
        });
        {
            const rule = r("Grid", ["cursor", "x"]);
            rule.setAll({
                strokeOpacity: 0.8,
                strokeDasharray: [2, 2],
                ariaLabel: language.translate("Use left and right arrows to move selection")
            });
            (0,_themes_DefaultTheme__WEBPACK_IMPORTED_MODULE_2__.setColor)(rule, "stroke", ic, "alternativeBackground");
        }
        {
            const rule = r("Grid", ["cursor", "y"]);
            rule.setAll({
                strokeOpacity: 0.8,
                strokeDasharray: [2, 2],
                ariaLabel: language.translate("Use up and down arrows to move selection")
            });
            (0,_themes_DefaultTheme__WEBPACK_IMPORTED_MODULE_2__.setColor)(rule, "stroke", ic, "alternativeBackground");
        }
        {
            const rule = r("Graphics", ["cursor", "selection"]);
            rule.setAll({
                fillOpacity: 0.15,
            });
            (0,_themes_DefaultTheme__WEBPACK_IMPORTED_MODULE_2__.setColor)(rule, "fill", ic, "alternativeBackground");
        }
        /**
         * ------------------------------------------------------------------------
         * charts/xy: Axes
         * ------------------------------------------------------------------------
         */
        r("Axis").setAll({
            start: 0,
            end: 1,
            minZoomCount: 1,
            maxZoomCount: Infinity,
            maxZoomFactor: 1000,
            maxDeviation: 0.1,
            snapTooltip: true,
            tooltipLocation: 0.5,
            panX: true,
            panY: true,
            zoomX: true,
            zoomY: true,
            fixAxisSize: true
        });
        r("AxisLabel").setAll({
            location: 0.5,
            multiLocation: 0,
            centerX: _core_util_Percent__WEBPACK_IMPORTED_MODULE_3__.p50,
            centerY: _core_util_Percent__WEBPACK_IMPORTED_MODULE_3__.p50,
            paddingTop: 3,
            paddingBottom: 3,
            paddingLeft: 5,
            paddingRight: 5
        });
        // The following is deprecated following text measuring updates in 5.0.5
        // r("AxisLabel", ["y"]).setAll({
        // 	textAlign: "right"
        // });
        // r("AxisLabel", ["y", "opposite"]).setAll({
        // 	textAlign: "left"
        // });
        r("Container", ["axis", "header"]).setAll({
            layer: 30
        });
        r("Rectangle", ["axis", "header", "background"]).setAll({
            crisp: true
        });
        {
            const rule = r("AxisRenderer");
            rule.setAll({
                crisp: true,
                strokeOpacity: 0
            });
            (0,_themes_DefaultTheme__WEBPACK_IMPORTED_MODULE_2__.setColor)(rule, "stroke", ic, "grid");
        }
        r("AxisRendererX").setAll({
            minGridDistance: 120,
            opposite: false,
            inversed: false,
            cellStartLocation: 0,
            cellEndLocation: 1,
            width: _core_util_Percent__WEBPACK_IMPORTED_MODULE_3__.p100
        });
        r("AxisRendererY").setAll({
            minGridDistance: 40,
            opposite: false,
            inversed: false,
            cellStartLocation: 0,
            cellEndLocation: 1,
            height: _core_util_Percent__WEBPACK_IMPORTED_MODULE_3__.p100
        });
        {
            const rule = r("Rectangle", ["axis", "thumb"]);
            rule.setAll({
                fillOpacity: 0
            });
            (0,_themes_DefaultTheme__WEBPACK_IMPORTED_MODULE_2__.setColor)(rule, "fill", ic, "alternativeBackground");
            rule.states.create("hover", { fillOpacity: 0.1 });
        }
        r("Rectangle", ["axis", "thumb", "x"]).setAll({
            cursorOverStyle: "ew-resize"
        });
        r("Rectangle", ["axis", "thumb", "y"]).setAll({
            cursorOverStyle: "ns-resize"
        });
        {
            const rule = r("Grid");
            rule.setAll({
                location: 0,
                strokeOpacity: 0.15,
                crisp: true
            });
            (0,_themes_DefaultTheme__WEBPACK_IMPORTED_MODULE_2__.setColor)(rule, "stroke", ic, "grid");
        }
        {
            const rule = r("Grid", ["minor"]);
            rule.setAll({
                location: 0,
                strokeOpacity: 0.07,
                crisp: true
            });
            (0,_themes_DefaultTheme__WEBPACK_IMPORTED_MODULE_2__.setColor)(rule, "stroke", ic, "grid");
        }
        r("Grid", ["base"]).setAll({
            strokeOpacity: 0.3
        });
        {
            const rule = r("Graphics", ["axis", "fill"]);
            rule.setAll({
                visible: false,
                isMeasured: false,
                position: "absolute",
                fillOpacity: 0.05,
            });
            (0,_themes_DefaultTheme__WEBPACK_IMPORTED_MODULE_2__.setColor)(rule, "fill", ic, "alternativeBackground");
        }
        r("Graphics", ["axis", "fill", "range"]).setAll({
            isMeasured: true
        });
        // hides all elements of series axis range
        r("Graphics", ["series", "fill", "range"]).setAll({
            visible: false,
            isMeasured: true
        });
        r("Grid", ["series", "range"]).setAll({
            visible: false
        });
        r("AxisTick", ["series", "range"]).setAll({
            visible: false
        });
        r("AxisLabel", ["series", "range"]).setAll({
            visible: false
        });
        {
            const rule = r("AxisTick");
            rule.setAll({
                location: 0.5,
                multiLocation: 0,
                strokeOpacity: 1,
                isMeasured: false,
                position: "absolute",
                visible: false
            });
            (0,_themes_DefaultTheme__WEBPACK_IMPORTED_MODULE_2__.setColor)(rule, "stroke", ic, "grid");
        }
        r("CategoryAxis").setAll({
            startLocation: 0,
            endLocation: 1,
            fillRule: (dataItem, index) => {
                const axisFill = dataItem.get("axisFill");
                if (axisFill) {
                    if (!_core_util_Type__WEBPACK_IMPORTED_MODULE_4__.isNumber(index) || index % 2 == 0) {
                        axisFill.setPrivate("visible", true);
                    }
                    else {
                        axisFill.setPrivate("visible", false);
                    }
                }
            }
        });
        const gridIntervals = [
            { timeUnit: "millisecond", count: 1 },
            { timeUnit: "millisecond", count: 5 },
            { timeUnit: "millisecond", count: 10 },
            { timeUnit: "millisecond", count: 50 },
            { timeUnit: "millisecond", count: 100 },
            { timeUnit: "millisecond", count: 500 },
            { timeUnit: "second", count: 1 },
            { timeUnit: "second", count: 5 },
            { timeUnit: "second", count: 10 },
            { timeUnit: "second", count: 30 },
            { timeUnit: "minute", count: 1 },
            { timeUnit: "minute", count: 5 },
            { timeUnit: "minute", count: 10 },
            { timeUnit: "minute", count: 15 },
            { timeUnit: "minute", count: 30 },
            { timeUnit: "hour", count: 1 },
            { timeUnit: "hour", count: 3 },
            { timeUnit: "hour", count: 6 },
            { timeUnit: "hour", count: 12 },
            { timeUnit: "day", count: 1 },
            { timeUnit: "day", count: 2 },
            { timeUnit: "day", count: 3 },
            { timeUnit: "day", count: 4 },
            { timeUnit: "day", count: 5 },
            { timeUnit: "week", count: 1 },
            { timeUnit: "month", count: 1 },
            { timeUnit: "month", count: 2 },
            { timeUnit: "month", count: 3 },
            { timeUnit: "month", count: 6 },
            { timeUnit: "year", count: 1 },
            { timeUnit: "year", count: 2 },
            { timeUnit: "year", count: 5 },
            { timeUnit: "year", count: 10 },
            { timeUnit: "year", count: 50 },
            { timeUnit: "year", count: 100 },
            { timeUnit: "year", count: 200 },
            { timeUnit: "year", count: 500 },
            { timeUnit: "year", count: 1000 },
            { timeUnit: "year", count: 2000 },
            { timeUnit: "year", count: 5000 },
            { timeUnit: "year", count: 10000 },
            { timeUnit: "year", count: 100000 }
        ];
        const dateFormats = {
            "millisecond": language.translate("_date_millisecond"),
            "second": language.translate("_date_second"),
            "minute": language.translate("_date_minute"),
            "hour": language.translate("_date_hour"),
            "day": language.translate("_date_day"),
            "week": language.translate("_date_day"),
            "month": language.translate("_date_month"),
            "year": language.translate("_date_year")
        };
        const periodChangeDateFormats = {
            "millisecond": language.translate("_date_millisecond"),
            "second": language.translate("_date_second"),
            "minute": language.translate("_date_minute"),
            "hour": language.translate("_date_day"),
            "day": language.translate("_date_day"),
            "week": language.translate("_date_day"),
            "month": language.translate("_date_month") + " " + language.translate("_date_year"),
            "year": language.translate("_date_year")
        };
        const tooltipDateFormats = {
            "millisecond": language.translate("_date_millisecond_full"),
            "second": language.translate("_date_second_full"),
            "minute": language.translate("_date_minute_full"),
            "hour": language.translate("_date_hour_full"),
            "day": language.translate("_date_day_full"),
            "week": language.translate("_date_week_full"),
            "month": language.translate("_date_month_full"),
            "year": language.translate("_date_year")
        };
        r("CategoryDateAxis").setAll({
            markUnitChange: true,
            gridIntervals: _core_util_Array__WEBPACK_IMPORTED_MODULE_5__.copy(gridIntervals),
            dateFormats: _core_util_Object__WEBPACK_IMPORTED_MODULE_6__.copy(dateFormats),
            periodChangeDateFormats: _core_util_Object__WEBPACK_IMPORTED_MODULE_6__.copy(periodChangeDateFormats)
        });
        r("DateAxis").setAll({
            maxZoomFactor: null,
            strictMinMax: true,
            startLocation: 0,
            endLocation: 1,
            markUnitChange: true,
            groupData: false,
            groupCount: 500,
            gridIntervals: _core_util_Array__WEBPACK_IMPORTED_MODULE_5__.copy(gridIntervals),
            dateFormats: _core_util_Object__WEBPACK_IMPORTED_MODULE_6__.copy(dateFormats),
            periodChangeDateFormats: _core_util_Object__WEBPACK_IMPORTED_MODULE_6__.copy(periodChangeDateFormats),
            tooltipDateFormats: tooltipDateFormats,
            groupIntervals: [
                { timeUnit: "millisecond", count: 1 },
                { timeUnit: "millisecond", count: 10 },
                { timeUnit: "millisecond", count: 100 },
                { timeUnit: "second", count: 1 },
                { timeUnit: "second", count: 10 },
                { timeUnit: "minute", count: 1 },
                { timeUnit: "minute", count: 10 },
                { timeUnit: "hour", count: 1 },
                { timeUnit: "day", count: 1 },
                { timeUnit: "week", count: 1 },
                { timeUnit: "month", count: 1 },
                { timeUnit: "year", count: 1 }
            ],
            fillRule: (dataItem) => {
                const axisFill = dataItem.get("axisFill");
                if (axisFill) {
                    const axis = dataItem.component;
                    const value = dataItem.get("value");
                    const endValue = dataItem.get("endValue");
                    const intervalDuration = axis.intervalDuration();
                    const baseInterval = axis.getPrivate("baseInterval");
                    const gridInterval = axis.getPrivate("gridInterval", baseInterval);
                    let min = axis.getPrivate("min", 0);
                    min = _core_util_Time__WEBPACK_IMPORTED_MODULE_7__.round(new Date(min), gridInterval.timeUnit, gridInterval.count, this._root.locale.firstDayOfWeek, this._root.utc, undefined, this._root.timezone).getTime();
                    if (value != null && endValue != null) {
                        const val = Math.round(Math.round((value - min) / intervalDuration)) / 2;
                        if (val == Math.round(val)) {
                            axisFill.setPrivate("visible", true);
                        }
                        else {
                            axisFill.setPrivate("visible", false);
                        }
                    }
                }
            }
        });
        r("GaplessDateAxis").setAll({
            fillRule: (dataItem) => {
                const axisFill = dataItem.get("axisFill");
                if (axisFill) {
                    const index = dataItem.get("index");
                    let visible = false;
                    if (!_core_util_Type__WEBPACK_IMPORTED_MODULE_4__.isNumber(index) || index % 2 == 0) {
                        visible = true;
                    }
                    axisFill.setPrivate("visible", visible);
                }
            }
        });
        r("ValueAxis").setAll({
            baseValue: 0,
            logarithmic: false,
            strictMinMax: false,
            autoZoom: true,
            fillRule: (dataItem) => {
                const axisFill = dataItem.get("axisFill");
                if (axisFill) {
                    const axis = dataItem.component;
                    const value = dataItem.get("value");
                    const step = axis.getPrivate("step");
                    if (_core_util_Type__WEBPACK_IMPORTED_MODULE_4__.isNumber(value) && _core_util_Type__WEBPACK_IMPORTED_MODULE_4__.isNumber(step)) {
                        if (_core_util_Math__WEBPACK_IMPORTED_MODULE_8__.round(value / step / 2, 5) == Math.round(value / step / 2)) {
                            axisFill.setPrivate("visible", false);
                        }
                        else {
                            axisFill.setPrivate("visible", true);
                        }
                    }
                }
            }
        });
        r("DurationAxis").setAll({
            baseUnit: "second"
        });
        /**
         * ------------------------------------------------------------------------
         * charts/xy: Series
         * ------------------------------------------------------------------------
         */
        r("XYSeries").setAll({
            maskBullets: true,
            stackToNegative: true,
            locationX: 0.5,
            locationY: 0.5,
            snapTooltip: false,
            openValueXGrouped: "open",
            openValueYGrouped: "open",
            valueXGrouped: "close",
            valueYGrouped: "close",
            seriesTooltipTarget: "series"
        });
        r("BaseColumnSeries").setAll({
            adjustBulletPosition: true
        });
        r("ColumnSeries").setAll({
            clustered: true
        });
        r("RoundedRectangle", ["series", "column"]).setAll({
            position: "absolute",
            isMeasured: false,
            width: (0,_core_util_Percent__WEBPACK_IMPORTED_MODULE_3__.percent)(70),
            height: (0,_core_util_Percent__WEBPACK_IMPORTED_MODULE_3__.percent)(70),
            strokeWidth: 1,
            strokeOpacity: 1,
            cornerRadiusBL: 0,
            cornerRadiusTL: 0,
            cornerRadiusBR: 0,
            cornerRadiusTR: 0,
            fillOpacity: 1,
            role: "figure"
        });
        r("LineSeries").setAll({
            connect: true,
            autoGapCount: 1.1,
            stackToNegative: false
        });
        r("Graphics", ["series", "stroke"]).setAll({
            position: "absolute",
            strokeWidth: 1,
            strokeOpacity: 1,
            isMeasured: false
        });
        r("Graphics", ["series", "fill"]).setAll({
            visible: false,
            fillOpacity: 0,
            position: "absolute",
            strokeWidth: 0,
            strokeOpacity: 0,
            isMeasured: false
        });
        r("Graphics", ["line", "series", "legend", "marker", "stroke"]).setAll({
            draw: (display, sprite) => {
                const parent = sprite.parent;
                if (parent) {
                    const h = parent.height();
                    const w = parent.width();
                    display.moveTo(0, h / 2);
                    display.lineTo(w, h / 2);
                }
            }
        });
        {
            const rule = r("Graphics", ["line", "series", "legend", "marker", "stroke"]).states.create("disabled", {});
            (0,_themes_DefaultTheme__WEBPACK_IMPORTED_MODULE_2__.setColor)(rule, "stroke", ic, "disabled");
        }
        r("Graphics", ["line", "series", "legend", "marker", "fill"]).setAll({
            draw: (display, sprite) => {
                const parent = sprite.parent;
                if (parent) {
                    const h = parent.height();
                    const w = parent.width();
                    display.moveTo(0, 0);
                    display.lineTo(w, 0);
                    display.lineTo(w, h);
                    display.lineTo(0, h);
                    display.lineTo(0, 0);
                }
            }
        });
        {
            const rule = r("Graphics", ["line", "series", "legend", "marker", "fill"]).states.create("disabled", {});
            (0,_themes_DefaultTheme__WEBPACK_IMPORTED_MODULE_2__.setColor)(rule, "stroke", ic, "disabled");
        }
        r("SmoothedXYLineSeries").setAll({
            tension: 0.5
        });
        r("SmoothedXLineSeries").setAll({
            tension: 0.5
        });
        r("SmoothedYLineSeries").setAll({
            tension: 0.5
        });
        r("Candlestick").setAll({
            position: "absolute",
            isMeasured: false,
            width: (0,_core_util_Percent__WEBPACK_IMPORTED_MODULE_3__.percent)(50),
            height: (0,_core_util_Percent__WEBPACK_IMPORTED_MODULE_3__.percent)(50),
            strokeWidth: 1,
            strokeOpacity: 1,
            cornerRadiusBL: 0,
            cornerRadiusTL: 0,
            cornerRadiusBR: 0,
            cornerRadiusTR: 0,
            fillOpacity: 1,
            role: "figure"
        });
        r("OHLC").setAll({
            width: (0,_core_util_Percent__WEBPACK_IMPORTED_MODULE_3__.percent)(80),
            height: (0,_core_util_Percent__WEBPACK_IMPORTED_MODULE_3__.percent)(80)
        });
        r("CandlestickSeries").setAll({
            lowValueXGrouped: "low",
            lowValueYGrouped: "low",
            highValueXGrouped: "high",
            highValueYGrouped: "high",
            openValueXGrouped: "open",
            openValueYGrouped: "open",
            valueXGrouped: "close",
            valueYGrouped: "close"
        });
        // These rules can be used for regular columns, too
        {
            const rule = r("Rectangle", ["column", "autocolor"]).states.create("riseFromOpen", {});
            (0,_themes_DefaultTheme__WEBPACK_IMPORTED_MODULE_2__.setColor)(rule, "fill", ic, "positive");
            (0,_themes_DefaultTheme__WEBPACK_IMPORTED_MODULE_2__.setColor)(rule, "stroke", ic, "positive");
        }
        {
            const rule = r("Rectangle", ["column", "autocolor"]).states.create("dropFromOpen", {});
            (0,_themes_DefaultTheme__WEBPACK_IMPORTED_MODULE_2__.setColor)(rule, "fill", ic, "negative");
            (0,_themes_DefaultTheme__WEBPACK_IMPORTED_MODULE_2__.setColor)(rule, "stroke", ic, "negative");
        }
        // Hollow
        r("Rectangle", ["column", "autocolor", "pro"]).states.create("riseFromOpen", { fillOpacity: 0 });
        r("Rectangle", ["column", "autocolor", "pro"]).states.create("dropFromOpen", { fillOpacity: 1 });
        {
            const rule = r("Rectangle", ["column", "autocolor", "pro"]).states.create("riseFromPrevious", {});
            (0,_themes_DefaultTheme__WEBPACK_IMPORTED_MODULE_2__.setColor)(rule, "fill", ic, "positive");
            (0,_themes_DefaultTheme__WEBPACK_IMPORTED_MODULE_2__.setColor)(rule, "stroke", ic, "positive");
        }
        {
            const rule = r("Rectangle", ["column", "autocolor", "pro"]).states.create("dropFromPrevious", {});
            (0,_themes_DefaultTheme__WEBPACK_IMPORTED_MODULE_2__.setColor)(rule, "fill", ic, "negative");
            (0,_themes_DefaultTheme__WEBPACK_IMPORTED_MODULE_2__.setColor)(rule, "stroke", ic, "negative");
        }
        // AXIS RANGE GRIP
        {
            const rule = r("RoundedRectangle", ["rangegrip"]);
            rule.setAll({
                strokeOpacity: 0,
                fillOpacity: 0,
                strokeWidth: 1,
                width: 12,
                height: 12
            });
        }
        {
            const rule = r("Graphics", ["rangegrip", "button", "icon"]);
            rule.setAll({
                interactive: false,
                crisp: true,
                strokeOpacity: 0.5,
                draw: (display) => {
                    display.moveTo(0, 0.5);
                    display.lineTo(0, 12.5);
                    display.moveTo(2, 0.5);
                    display.lineTo(2, 12.5);
                    display.moveTo(4, 0.5);
                    display.lineTo(4, 12.5);
                }
            });
            (0,_themes_DefaultTheme__WEBPACK_IMPORTED_MODULE_2__.setColor)(rule, "stroke", ic, "secondaryButtonText");
        }
        r("Button", ["rangegrip"]).setAll({
            draggable: true,
            paddingTop: 0,
            paddingBottom: 0
        });
        r("Button", ["rangegrip", "vertical"]).setAll({
            rotation: 90,
            cursorOverStyle: "ns-resize",
            centerX: _core_util_Percent__WEBPACK_IMPORTED_MODULE_3__.p50
        });
        r("Button", ["rangegrip", "horizontal"]).setAll({
            cursorOverStyle: "ew-resize",
            centerX: _core_util_Percent__WEBPACK_IMPORTED_MODULE_3__.p50
        });
        r("Button", ["rangegrip", "vertical", "left"]).setAll({
            centerY: _core_util_Percent__WEBPACK_IMPORTED_MODULE_3__.p100
        });
        r("Button", ["rangegrip", "vertical", "right"]).setAll({
            centerY: 0
        });
        r("Button", ["rangegrip", "horizontal", "top"]).setAll({
            centerY: 0
        });
        r("Button", ["rangegrip", "horizontal", "bottom"]).setAll({
            centerY: _core_util_Percent__WEBPACK_IMPORTED_MODULE_3__.p100
        });
    }
}
//# sourceMappingURL=XYChartDefaultTheme.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/charts/xy/XYCursor.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/charts/xy/XYCursor.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   XYCursor: () => (/* binding */ XYCursor)
/* harmony export */ });
/* harmony import */ var _core_render_Container__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/render/Container */ "./node_modules/@amcharts/amcharts5/.internal/core/render/Container.js");
/* harmony import */ var _core_util_Percent__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../core/util/Percent */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Percent.js");
/* harmony import */ var _core_render_Graphics__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../core/render/Graphics */ "./node_modules/@amcharts/amcharts5/.internal/core/render/Graphics.js");
/* harmony import */ var _axes_Grid__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./axes/Grid */ "./node_modules/@amcharts/amcharts5/.internal/charts/xy/axes/Grid.js");
/* harmony import */ var _core_util_Type__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../core/util/Type */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Type.js");
/* harmony import */ var _core_util_Utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../core/util/Utils */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Utils.js");
/* harmony import */ var _core_util_Math__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../core/util/Math */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Math.js");
/* harmony import */ var _core_util_Array__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../core/util/Array */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Array.js");
/* harmony import */ var _core_util_Object__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../core/util/Object */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Object.js");




//import { Animations } from "../core/util/Animation";





/**
 * Creates a chart cursor for an [[XYChart]].
 *
 * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/cursor/} for more info
 * @important
 */
class XYCursor extends _core_render_Container__WEBPACK_IMPORTED_MODULE_0__.Container {
    constructor() {
        super(...arguments);
        /**
         * A [[Grid]] elment that used for horizontal line of the cursor crosshair.
         *
         * @default Grid.new()
         */
        Object.defineProperty(this, "lineX", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: this.children.push(_axes_Grid__WEBPACK_IMPORTED_MODULE_1__.Grid.new(this._root, {
                themeTags: ["x"]
            }))
        });
        /**
         * A [[Grid]] elment that used for horizontal line of the cursor crosshair.
         *
         * @default Grid.new()
         */
        Object.defineProperty(this, "lineY", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: this.children.push(_axes_Grid__WEBPACK_IMPORTED_MODULE_1__.Grid.new(this._root, {
                themeTags: ["y"]
            }))
        });
        /**
         * An element that represents current selection.
         *
         * @default Graphics.new()
         */
        Object.defineProperty(this, "selection", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: this.children.push(_core_render_Graphics__WEBPACK_IMPORTED_MODULE_2__.Graphics.new(this._root, {
                themeTags: ["selection", "cursor"], layer: 30
            }))
        });
        Object.defineProperty(this, "_movePoint", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_lastPoint", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: { x: 0, y: 0 }
        });
        Object.defineProperty(this, "_tooltipX", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        Object.defineProperty(this, "_tooltipY", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        /**
         * A chart cursor is attached to.
         */
        Object.defineProperty(this, "chart", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_toX", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_toY", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
    }
    _afterNew() {
        this._settings.themeTags = _core_util_Utils__WEBPACK_IMPORTED_MODULE_3__.mergeTags(this._settings.themeTags, ["xy", "cursor"]);
        super._afterNew();
        this.setAll({ "width": _core_util_Percent__WEBPACK_IMPORTED_MODULE_4__.p100, height: _core_util_Percent__WEBPACK_IMPORTED_MODULE_4__.p100, isMeasured: true, position: "absolute" });
        this.states.create("hidden", { visible: true, opacity: 0 });
        this._drawLines();
        this.setPrivateRaw("visible", false);
        this._disposers.push(this.setTimeout(() => {
            this.setPrivate("visible", true);
        }, 500));
        this._disposers.push(this.lineX.events.on("positionchanged", () => {
            this._handleXLine();
        }));
        this._disposers.push(this.lineY.events.on("positionchanged", () => {
            this._handleYLine();
        }));
        this._disposers.push(this.lineX.events.on("focus", (ev) => this._handleLineFocus(ev.target)));
        this._disposers.push(this.lineX.events.on("blur", (ev) => this._handleLineBlur(ev.target)));
        this._disposers.push(this.lineY.events.on("focus", (ev) => this._handleLineFocus(ev.target)));
        this._disposers.push(this.lineY.events.on("blur", (ev) => this._handleLineBlur(ev.target)));
        if (_core_util_Utils__WEBPACK_IMPORTED_MODULE_3__.supports("keyboardevents")) {
            this._disposers.push(_core_util_Utils__WEBPACK_IMPORTED_MODULE_3__.addEventListener(document, "keydown", (ev) => {
                this._handleLineMove(ev.keyCode);
            }));
        }
    }
    _setUpTouch() {
        const chart = this.chart;
        if (chart) {
            chart.plotContainer._display.cancelTouch = this.get("behavior") != "none" ? true : false;
        }
    }
    _handleXLine() {
        let x = this.lineX.x();
        let visible = true;
        if (x < 0 || x > this.width()) {
            visible = false;
        }
        this.lineX.setPrivate("visible", visible);
    }
    _handleYLine() {
        let y = this.lineY.y();
        let visible = true;
        if (y < 0 || y > this.height()) {
            visible = false;
        }
        this.lineY.setPrivate("visible", visible);
    }
    _handleLineMove(keyCode) {
        let dir = "";
        let position = 0;
        let increment = 0.1;
        const chart = this.chart;
        if (this._root.focused(this.lineX)) {
            if (chart && chart.xAxes.length) {
                increment = chart.xAxes.getIndex(0).getCellWidthPosition();
            }
            position = this.getPrivate("positionX", 0);
            dir = "positionX";
            if (keyCode == 37) {
                position -= increment;
            }
            else if (keyCode == 39) {
                position += increment;
            }
        }
        else if (this._root.focused(this.lineY)) {
            if (chart && chart.yAxes.length) {
                increment = chart.yAxes.getIndex(0).getCellWidthPosition();
            }
            position = this.getPrivate("positionY", 0);
            dir = "positionY";
            if (keyCode == 38) {
                position -= increment;
            }
            else if (keyCode == 40) {
                position += increment;
            }
        }
        if (position < 0) {
            position = 0;
        }
        else if (position > 1) {
            position = 1;
        }
        if (dir != "") {
            this.set(dir, position);
        }
    }
    _handleLineFocus(_line) {
        this.setAll({
            positionX: this.getPrivate("positionX"),
            positionY: this.getPrivate("positionY"),
            alwaysShow: true
        });
    }
    _handleLineBlur(_line) {
        this.setAll({
            positionX: undefined,
            positionY: undefined,
            alwaysShow: false
        });
    }
    _prepareChildren() {
        super._prepareChildren();
        if (this.isDirty("xAxis")) {
            this._tooltipX = false;
            const xAxis = this.get("xAxis");
            if (xAxis) {
                const tooltip = xAxis.get("tooltip");
                if (tooltip) {
                    this._tooltipX = true;
                    this._disposers.push(tooltip.on("pointTo", () => {
                        this._updateXLine(tooltip);
                    }));
                }
            }
        }
        if (this.isDirty("yAxis")) {
            this._tooltipY = false;
            const yAxis = this.get("yAxis");
            if (yAxis) {
                const tooltip = yAxis.get("tooltip");
                if (tooltip) {
                    this._tooltipY = true;
                    this._disposers.push(tooltip.on("pointTo", () => {
                        this._updateYLine(tooltip);
                    }));
                }
            }
        }
    }
    _handleSyncWith() {
        const chart = this.chart;
        if (chart) {
            const syncWith = this.get("syncWith");
            const otherCharts = [];
            if (syncWith) {
                _core_util_Array__WEBPACK_IMPORTED_MODULE_5__.each(syncWith, (cursor) => {
                    const chart = cursor.chart;
                    if (chart) {
                        otherCharts.push(chart);
                    }
                });
            }
            chart._otherCharts = otherCharts;
        }
    }
    _updateChildren() {
        super._updateChildren();
        this._handleSyncWith();
        if (this.isDirty("positionX") || this.isDirty("positionY")) {
            const positionX = this.get("positionX");
            const positionY = this.get("positionY");
            if (positionX == null && positionY == null) {
                this.hide(0);
            }
            else {
                this._movePoint = this.toGlobal(this._getPoint(this.get("positionX", 0), this.get("positionY", 0)));
                this.handleMove();
            }
        }
    }
    _updateXLine(tooltip) {
        let x = _core_util_Math__WEBPACK_IMPORTED_MODULE_6__.round(this._display.toLocal(tooltip.get("pointTo", { x: 0, y: 0 })).x, 2);
        if (this._toX != x) {
            this.lineX.animate({ key: "x", to: x, duration: tooltip.get("animationDuration", 0), easing: tooltip.get("animationEasing") });
            this._toX = x;
        }
    }
    _updateYLine(tooltip) {
        let y = _core_util_Math__WEBPACK_IMPORTED_MODULE_6__.round(this._display.toLocal(tooltip.get("pointTo", { x: 0, y: 0 })).y, 2);
        if (this._toY != y) {
            this.lineY.animate({ key: "y", to: y, duration: tooltip.get("animationDuration", 0), easing: tooltip.get("animationEasing") });
            this._toY = y;
        }
    }
    _drawLines() {
        this.lineX.set("draw", (display) => {
            display.moveTo(0, 0);
            display.lineTo(0, this.height());
        });
        this.lineY.set("draw", (display) => {
            display.moveTo(0, 0);
            display.lineTo(this.width(), 0);
        });
    }
    updateCursor() {
        if (this.get("alwaysShow")) {
            this._movePoint = this.toGlobal(this._getPoint(this.get("positionX", 0), this.get("positionY", 0)));
        }
        this.handleMove();
    }
    _setChart(chart) {
        this.chart = chart;
        this._handleSyncWith();
        const plotContainer = chart.plotContainer;
        this.events.on("boundschanged", () => {
            this._disposers.push(this.setTimeout(() => {
                this.updateCursor();
            }, 50));
        });
        //this._display.interactive = true;
        if (_core_util_Utils__WEBPACK_IMPORTED_MODULE_3__.supports("touchevents")) {
            this._disposers.push(plotContainer.events.on("click", (event) => {
                if (_core_util_Utils__WEBPACK_IMPORTED_MODULE_3__.isTouchEvent(event.originalEvent)) {
                    this._handleMove(event);
                }
            }));
            this._setUpTouch();
        }
        this._disposers.push(plotContainer.events.on("pointerdown", (event) => {
            this._handleCursorDown(event);
        }));
        this._disposers.push(plotContainer.events.on("globalpointerup", (event) => {
            this._handleCursorUp(event);
            if (!event.native && !this.isHidden()) {
                this._handleMove(event);
            }
        }));
        this._disposers.push(plotContainer.events.on("globalpointermove", (event) => {
            if (!this.get("syncWith")) {
                if (_core_util_Object__WEBPACK_IMPORTED_MODULE_7__.keys(plotContainer._downPoints).length == 0 && !event.native && this.isHidden()) {
                    // Ignore mouse movement if it originates on outside element and
                    // we're not dragging.
                    return;
                }
            }
            this._handleMove(event);
        }));
        const parent = this.parent;
        if (parent) {
            parent.children.moveValue(this.selection);
        }
    }
    _inPlot(point) {
        const chart = this.chart;
        if (chart) {
            return chart.inPlot(point);
        }
        return false;
    }
    _handleCursorDown(event) {
        if (event.originalEvent.button == 2) {
            return;
        }
        const rootPoint = event.point;
        let local = this._display.toLocal(rootPoint);
        const chart = this.chart;
        this.selection.set("draw", () => { });
        if (chart && this._inPlot(local)) {
            this._downPoint = local;
            if (this.get("behavior") != "none") {
                this.selection.show();
                const type = "selectstarted";
                if (this.events.isEnabled(type)) {
                    this.events.dispatch(type, { type: type, target: this, originalEvent: event.originalEvent });
                }
            }
            let positionX = this._getPosition(local).x;
            let positionY = this._getPosition(local).y;
            this.setPrivate("downPositionX", positionX);
            this.setPrivate("downPositionY", positionY);
        }
    }
    _handleCursorUp(event) {
        // TODO: handle multitouch
        if (this._downPoint) {
            const behavior = this.get("behavior", "none");
            if (behavior != "none") {
                if (behavior.charAt(0) === "z") {
                    this.selection.hide();
                }
                const rootPoint = event.point;
                let local = this._display.toLocal(rootPoint);
                const downPoint = this._downPoint;
                const moveThreshold = this.get("moveThreshold", 1);
                if (local && downPoint) {
                    let dispatch = false;
                    if (behavior === "zoomX" || behavior === "zoomXY" || behavior === "selectX" || behavior === "selectXY") {
                        if (Math.abs(local.x - downPoint.x) > moveThreshold) {
                            dispatch = true;
                        }
                    }
                    if (behavior === "zoomY" || behavior === "zoomXY" || behavior === "selectY" || behavior === "selectXY") {
                        if (Math.abs(local.y - downPoint.y) > moveThreshold) {
                            dispatch = true;
                        }
                    }
                    if (dispatch) {
                        const type = "selectended";
                        if (this.events.isEnabled(type)) {
                            this.events.dispatch(type, { type: type, target: this, originalEvent: event.originalEvent });
                        }
                    }
                    else {
                        const type = "selectcancelled";
                        if (this.events.isEnabled(type)) {
                            this.events.dispatch(type, { type: type, target: this, originalEvent: event.originalEvent });
                        }
                    }
                }
            }
        }
        this._downPoint = undefined;
    }
    _handleMove(event) {
        if (this.getPrivate("visible")) {
            const chart = this.chart;
            if (chart && _core_util_Object__WEBPACK_IMPORTED_MODULE_7__.keys(chart.plotContainer._downPoints).length > 1) {
                this.set("forceHidden", true);
                return;
            }
            else {
                this.set("forceHidden", false);
            }
            // TODO: handle multitouch
            const rootPoint = event.point;
            const lastPoint = this._lastPoint;
            if (Math.round(lastPoint.x) === Math.round(rootPoint.x) && Math.round(lastPoint.y) === Math.round(rootPoint.y)) {
                return;
            }
            this._lastPoint = rootPoint;
            this.setPrivate("lastPoint", rootPoint);
            this.handleMove({ x: rootPoint.x, y: rootPoint.y }, false, event.originalEvent);
        }
    }
    _getPosition(point) {
        return { x: point.x / this.width(), y: point.y / this.height() };
    }
    /**
     * Moves the cursor to X/Y coordinates within chart container (`point`).
     *
     * If `skipEvent` parameter is set to `true`, the move will not invoke
     * the `"cursormoved"` event.
     *
     * @param  point      X/Y to move cursor to
     * @param  skipEvent  Do not fire "cursormoved" event
     */
    handleMove(point, skipEvent, originalEvent) {
        if (!point) {
            point = this._movePoint;
        }
        const alwaysShow = this.get("alwaysShow");
        if (!point) {
            this.hide(0);
            return;
        }
        this._movePoint = point;
        let local = this._display.toLocal(point);
        let chart = this.chart;
        if (chart && (this._inPlot(local) || this._downPoint)) {
            chart._movePoint = point;
            if (this.isHidden()) {
                this.show();
                const behavior = this.get("behavior", "");
                if (behavior.charAt(0) == "z") {
                    this.selection.set("draw", () => { });
                }
            }
            let x = local.x;
            let y = local.y;
            let xyPos = this._getPosition(local);
            this.setPrivate("point", local);
            let snapToSeries = this.get("snapToSeries");
            if (this._downPoint) {
                snapToSeries = undefined;
            }
            let userPositionX = this.get("positionX");
            let positionX = xyPos.x;
            if (_core_util_Type__WEBPACK_IMPORTED_MODULE_8__.isNumber(userPositionX)) {
                positionX = userPositionX;
            }
            let userPositionY = this.get("positionY");
            let positionY = xyPos.y;
            if (_core_util_Type__WEBPACK_IMPORTED_MODULE_8__.isNumber(userPositionY)) {
                positionY = userPositionY;
            }
            this.setPrivate("positionX", positionX);
            this.setPrivate("positionY", positionY);
            const xy = this._getPoint(positionX, positionY);
            x = xy.x;
            y = xy.y;
            chart.xAxes.each((axis) => {
                axis._handleCursorPosition(positionX, snapToSeries);
                if (alwaysShow) {
                    axis.handleCursorShow();
                }
            });
            chart.yAxes.each((axis) => {
                axis._handleCursorPosition(positionY, snapToSeries);
                if (alwaysShow) {
                    axis.handleCursorShow();
                }
            });
            if (!skipEvent) {
                chart._handleCursorPosition();
                const type = "cursormoved";
                if (this.events.isEnabled(type)) {
                    this.events.dispatch(type, { type: type, target: this, point: point, originalEvent: originalEvent });
                }
            }
            this._updateLines(x, y);
            chart.arrangeTooltips();
        }
        else if (!this._downPoint) {
            if (!alwaysShow) {
                this.hide(0);
                const type = "cursorhidden";
                if (this.events.isEnabled(type)) {
                    this.events.dispatch(type, { type: type, target: this });
                }
            }
        }
        if (this._downPoint && this.get("behavior") != "none") {
            this._updateSelection(local);
        }
    }
    _getPoint(positionX, positionY) {
        return { x: this.width() * positionX, y: this.height() * positionY };
    }
    _updateLines(x, y) {
        if (!this._tooltipX) {
            this.lineX.set("x", x);
        }
        if (!this._tooltipY) {
            this.lineY.set("y", y);
        }
        this._drawLines();
    }
    _updateSelection(point) {
        const selection = this.selection;
        const behavior = this.get("behavior");
        const w = this.width();
        const h = this.height();
        if (point.x < 0) {
            point.x = 0;
        }
        if (point.x > w) {
            point.x = w;
        }
        if (point.y < 0) {
            point.y = 0;
        }
        if (point.y > h) {
            point.y = h;
        }
        selection.set("draw", (display) => {
            const downPoint = this._downPoint;
            if (downPoint) {
                if (behavior === "zoomXY" || behavior === "selectXY") {
                    display.moveTo(downPoint.x, downPoint.y);
                    display.lineTo(downPoint.x, point.y);
                    display.lineTo(point.x, point.y);
                    display.lineTo(point.x, downPoint.y);
                    display.lineTo(downPoint.x, downPoint.y);
                }
                else if (behavior === "zoomX" || behavior === "selectX") {
                    display.moveTo(downPoint.x, 0);
                    display.lineTo(downPoint.x, h);
                    display.lineTo(point.x, h);
                    display.lineTo(point.x, 0);
                    display.lineTo(downPoint.x, 0);
                }
                else if (behavior === "zoomY" || behavior === "selectY") {
                    display.moveTo(0, downPoint.y);
                    display.lineTo(w, downPoint.y);
                    display.lineTo(w, point.y);
                    display.lineTo(0, point.y);
                    display.lineTo(0, downPoint.y);
                }
            }
        });
    }
    _onHide() {
        if (this.isHidden()) {
            let chart = this.chart;
            if (chart) {
                chart.xAxes.each((axis) => {
                    axis.handleCursorHide();
                });
                chart.yAxes.each((axis) => {
                    axis.handleCursorHide();
                });
                chart.series.each((series) => {
                    series.handleCursorHide();
                });
            }
        }
        super._onHide();
    }
    _onShow() {
        if (!this.isHidden()) {
            let chart = this.chart;
            if (chart) {
                chart.xAxes.each((axis) => {
                    axis.handleCursorShow();
                });
                chart.yAxes.each((axis) => {
                    axis.handleCursorShow();
                });
            }
        }
        super._onShow();
    }
    _dispose() {
        super._dispose();
        this.selection.dispose();
    }
}
Object.defineProperty(XYCursor, "className", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: "XYCursor"
});
Object.defineProperty(XYCursor, "classNames", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: _core_render_Container__WEBPACK_IMPORTED_MODULE_0__.Container.classNames.concat([XYCursor.className])
});
//# sourceMappingURL=XYCursor.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/charts/xy/axes/Axis.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/charts/xy/axes/Axis.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Axis: () => (/* binding */ Axis)
/* harmony export */ });
/* harmony import */ var _core_render_Component__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../core/render/Component */ "./node_modules/@amcharts/amcharts5/.internal/core/render/Component.js");
/* harmony import */ var _core_render_Container__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../core/render/Container */ "./node_modules/@amcharts/amcharts5/.internal/core/render/Container.js");
/* harmony import */ var _core_util_Percent__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../core/util/Percent */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Percent.js");
/* harmony import */ var _core_util_List__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../core/util/List */ "./node_modules/@amcharts/amcharts5/.internal/core/util/List.js");
/* harmony import */ var _core_render_Rectangle__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../core/render/Rectangle */ "./node_modules/@amcharts/amcharts5/.internal/core/render/Rectangle.js");
/* harmony import */ var _core_util_Array__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../core/util/Array */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Array.js");
/* harmony import */ var _core_util_Type__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../../core/util/Type */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Type.js");
/* harmony import */ var _core_util_Utils__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../../core/util/Utils */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Utils.js");









/**
 * A base class for all axes.
 *
 * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/#Adding_axes} for more info
 */
class Axis extends _core_render_Component__WEBPACK_IMPORTED_MODULE_0__.Component {
    constructor() {
        super(...arguments);
        Object.defineProperty(this, "_series", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
        });
        Object.defineProperty(this, "_isPanning", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        /**
         * Array of minor data items.
         */
        Object.defineProperty(this, "minorDataItems", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
        });
        /**
         * A [[Container]] that holds all the axis label elements.
         *
         * @default Container.new()
         */
        Object.defineProperty(this, "labelsContainer", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: this.children.push(_core_render_Container__WEBPACK_IMPORTED_MODULE_1__.Container.new(this._root, {}))
        });
        /**
         * A [[Container]] that holds all the axis grid and fill elements.
         *
         * @default Container.new()
         */
        Object.defineProperty(this, "gridContainer", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: _core_render_Container__WEBPACK_IMPORTED_MODULE_1__.Container.new(this._root, { width: _core_util_Percent__WEBPACK_IMPORTED_MODULE_2__.p100, height: _core_util_Percent__WEBPACK_IMPORTED_MODULE_2__.p100 })
        });
        /**
         * A [[Container]] that holds axis grid elements which goes above the series.
         *
         * @default Container.new()
         */
        Object.defineProperty(this, "topGridContainer", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: _core_render_Container__WEBPACK_IMPORTED_MODULE_1__.Container.new(this._root, { width: _core_util_Percent__WEBPACK_IMPORTED_MODULE_2__.p100, height: _core_util_Percent__WEBPACK_IMPORTED_MODULE_2__.p100 })
        });
        /**
         * A [[Container]] that holds all the axis bullet elements.
         *
         * @default new Container
         */
        Object.defineProperty(this, "bulletsContainer", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: this.children.push(_core_render_Container__WEBPACK_IMPORTED_MODULE_1__.Container.new(this._root, { isMeasured: false, width: _core_util_Percent__WEBPACK_IMPORTED_MODULE_2__.p100, height: _core_util_Percent__WEBPACK_IMPORTED_MODULE_2__.p100, position: "absolute" }))
        });
        /**
         * A referenece to the the chart the axis belongs to.
         */
        Object.defineProperty(this, "chart", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_rangesDirty", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        Object.defineProperty(this, "_panStart", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        Object.defineProperty(this, "_panEnd", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 1
        });
        Object.defineProperty(this, "_sAnimation", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_eAnimation", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_skipSync", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        /**
         * A list of axis ranges.
         *
         * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/axis-ranges/} for more info
         * @default new List()
         */
        Object.defineProperty(this, "axisRanges", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new _core_util_List__WEBPACK_IMPORTED_MODULE_3__.List()
        });
        Object.defineProperty(this, "_seriesAxisRanges", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
        });
        /**
         * A control label that is invisible but is used to keep width the width of
         * the axis constant.
         *
         * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/value-axis/#Ghost_label} for more info
         */
        Object.defineProperty(this, "ghostLabel", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_cursorPosition", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: -1
        });
        Object.defineProperty(this, "_snapToSeries", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_seriesValuesDirty", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        /**
         * A container above the axis that can be used to add additional stuff into
         * it. For example a legend, label, or an icon.
         *
         * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/axis-headers/} for more info
         * @default new Container
         */
        Object.defineProperty(this, "axisHeader", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: this.children.push(_core_render_Container__WEBPACK_IMPORTED_MODULE_1__.Container.new(this._root, {
                themeTags: ["axis", "header"],
                position: "absolute",
                background: _core_render_Rectangle__WEBPACK_IMPORTED_MODULE_4__.Rectangle.new(this._root, {
                    themeTags: ["header", "background"],
                    fill: this._root.interfaceColors.get("background")
                })
            }))
        });
        Object.defineProperty(this, "_bullets", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {}
        });
    }
    _dispose() {
        // these could be in other parents, so disposing just in case
        this.gridContainer.dispose();
        this.topGridContainer.dispose();
        this.bulletsContainer.dispose();
        this.labelsContainer.dispose();
        this.axisHeader.dispose();
        super._dispose();
    }
    _afterNew() {
        super._afterNew();
        this.setPrivate("updateScrollbar", true);
        this._disposers.push(this.axisRanges.events.onAll((change) => {
            if (change.type === "clear") {
                _core_util_Array__WEBPACK_IMPORTED_MODULE_5__.each(change.oldValues, (dataItem) => {
                    this.disposeDataItem(dataItem);
                });
            }
            else if (change.type === "push") {
                this._processAxisRange(change.newValue, ["range"]);
            }
            else if (change.type === "setIndex") {
                this._processAxisRange(change.newValue, ["range"]);
            }
            else if (change.type === "insertIndex") {
                this._processAxisRange(change.newValue, ["range"]);
            }
            else if (change.type === "removeIndex") {
                this.disposeDataItem(change.oldValue);
            }
            else if (change.type === "moveIndex") {
                this._processAxisRange(change.value, ["range"]);
            }
            else {
                throw new Error("Unknown IStreamEvent type");
            }
        }));
        const renderer = this.get("renderer");
        if (renderer) {
            renderer.axis = this;
            renderer.processAxis();
        }
        this.children.push(renderer);
        this.ghostLabel = renderer.makeLabel(new _core_render_Component__WEBPACK_IMPORTED_MODULE_0__.DataItem(this, undefined, {}), []);
        this.ghostLabel.adapters.disable("text");
        this.ghostLabel.setAll({ opacity: 0, tooltipText: undefined, tooltipHTML: undefined, interactive: false });
        this.ghostLabel.events.disable();
    }
    _updateFinals(_start, _end) {
    }
    /**
     * Zooms the axis to relative locations.
     *
     * Both `start` and `end` are relative: 0 means start of the axis, 1 - end.
     *
     * @param   start     Relative start
     * @param   end       Relative end
     * @param   duration  Duration of the zoom animation in milliseconds
     * @return            Zoom animation
     */
    zoom(start, end, duration, priority) {
        this._updateFinals(start, end);
        if (this.get("start") !== start || this.get("end") != end) {
            let sAnimation = this._sAnimation;
            let eAnimation = this._eAnimation;
            let maxDeviation = this.get("maxDeviation", 0.5) * Math.min(1, (end - start));
            if (start < -maxDeviation) {
                start = -maxDeviation;
            }
            if (end > 1 + maxDeviation) {
                end = 1 + maxDeviation;
            }
            if (start > end) {
                [start, end] = [end, start];
            }
            if (!_core_util_Type__WEBPACK_IMPORTED_MODULE_6__.isNumber(duration)) {
                duration = this.get("interpolationDuration", 0);
            }
            if (!priority) {
                priority = "end";
            }
            let maxZoomFactor = this.getPrivate("maxZoomFactor", this.get("maxZoomFactor", 100));
            let maxZoomFactorReal = maxZoomFactor;
            if (end === 1 && start !== 0) {
                if (start < this.get("start")) {
                    priority = "start";
                }
                else {
                    priority = "end";
                }
            }
            if (start === 0 && end !== 1) {
                if (end > this.get("end")) {
                    priority = "end";
                }
                else {
                    priority = "start";
                }
            }
            let minZoomCount = this.get("minZoomCount");
            let maxZoomCount = this.get("maxZoomCount");
            if (_core_util_Type__WEBPACK_IMPORTED_MODULE_6__.isNumber(minZoomCount)) {
                maxZoomFactor = maxZoomFactorReal / minZoomCount;
            }
            let minZoomFactor = 1;
            if (_core_util_Type__WEBPACK_IMPORTED_MODULE_6__.isNumber(maxZoomCount)) {
                minZoomFactor = maxZoomFactorReal / maxZoomCount;
            }
            // most likely we are dragging left scrollbar grip here, so we tend to modify end
            if (priority === "start") {
                if (maxZoomCount > 0) {
                    // add to the end
                    if (1 / (end - start) < minZoomFactor) {
                        end = start + 1 / minZoomFactor;
                    }
                }
                // add to the end
                if (1 / (end - start) > maxZoomFactor) {
                    end = start + 1 / maxZoomFactor;
                }
                //unless end is > 0
                if (end > 1 && end - start < 1 / maxZoomFactor) {
                    //end = 1;
                    start = end - 1 / maxZoomFactor;
                }
            }
            // most likely we are dragging right, so we modify left
            else {
                if (maxZoomCount > 0) {
                    // add to the end
                    if (1 / (end - start) < minZoomFactor) {
                        start = end - 1 / minZoomFactor;
                    }
                }
                // remove from start
                if (1 / (end - start) > maxZoomFactor) {
                    start = end - 1 / maxZoomFactor;
                }
                if (start < 0 && end - start < 1 / maxZoomFactor) {
                    //start = 0;
                    end = start + 1 / maxZoomFactor;
                }
            }
            if (1 / (end - start) > maxZoomFactor) {
                end = start + 1 / maxZoomFactor;
            }
            if (1 / (end - start) > maxZoomFactor) {
                start = end - 1 / maxZoomFactor;
            }
            if (maxZoomCount != null && minZoomCount != null && (start == this.get("start") && end == this.get("end"))) {
                const chart = this.chart;
                if (chart) {
                    chart._handleAxisSelection(this, true);
                }
            }
            if (((sAnimation && sAnimation.playing && sAnimation.to == start) || this.get("start") == start) && ((eAnimation && eAnimation.playing && eAnimation.to == end) || this.get("end") == end)) {
                return;
            }
            if (duration > 0) {
                let easing = this.get("interpolationEasing");
                let sAnimation, eAnimation;
                if (this.get("start") != start) {
                    sAnimation = this.animate({ key: "start", to: start, duration: duration, easing: easing });
                }
                if (this.get("end") != end) {
                    eAnimation = this.animate({ key: "end", to: end, duration: duration, easing: easing });
                }
                this._sAnimation = sAnimation;
                this._eAnimation = eAnimation;
                if (sAnimation) {
                    return sAnimation;
                }
                else if (eAnimation) {
                    return eAnimation;
                }
            }
            else {
                this.set("start", start);
                this.set("end", end);
                // otherwise bullets and line out of sync, as series is not redrawn
                this._root.events.once("frameended", () => {
                    this._markDirtyKey("start");
                    this._root._markDirty();
                });
            }
        }
        else {
            if (this._sAnimation) {
                this._sAnimation.stop();
            }
            if (this._eAnimation) {
                this._eAnimation.stop();
            }
        }
    }
    /**
     * A list of series using this axis.
     *
     * @return Series
     */
    get series() {
        return this._series;
    }
    _processAxisRange(dataItem, themeTags) {
        dataItem.setRaw("isRange", true);
        this._createAssets(dataItem, themeTags);
        this._rangesDirty = true;
        this._prepareDataItem(dataItem);
        const above = dataItem.get("above");
        const container = this.topGridContainer;
        const grid = dataItem.get("grid");
        if (above && grid) {
            container.children.moveValue(grid);
        }
        const fill = dataItem.get("axisFill");
        if (above && fill) {
            container.children.moveValue(fill);
        }
    }
    _prepareDataItem(_dataItem, _index) { }
    /**
     * @ignore
     */
    markDirtyExtremes() {
    }
    /**
     * @ignore
     */
    markDirtySelectionExtremes() {
    }
    _calculateTotals() {
    }
    _updateAxisRanges() {
        this._bullets = {};
        this.axisRanges.each((axisRange) => {
            this._prepareDataItem(axisRange);
        });
        _core_util_Array__WEBPACK_IMPORTED_MODULE_5__.each(this._seriesAxisRanges, (axisRange) => {
            this._prepareDataItem(axisRange);
        });
    }
    _prepareChildren() {
        super._prepareChildren();
        if (this.get("fixAxisSize")) {
            this.ghostLabel.set("visible", true);
        }
        else {
            this.ghostLabel.set("visible", false);
        }
        if (this.isDirty("start") || this.isDirty("end")) {
            const chart = this.chart;
            if (chart) {
                chart._updateCursor();
            }
            let start = this.get("start", 0);
            let end = this.get("end", 1);
            let maxDeviation = this.get("maxDeviation", 0.5) * Math.min(1, (end - start));
            if (start < -maxDeviation) {
                let delta = start + maxDeviation;
                start = -maxDeviation;
                this.setRaw("start", start);
                if (this.isDirty("end")) {
                    this.setRaw("end", end - delta);
                }
            }
            if (end > 1 + maxDeviation) {
                let delta = end - 1 - maxDeviation;
                end = 1 + maxDeviation;
                this.setRaw("end", end);
                if (this.isDirty("start")) {
                    this.setRaw("start", start - delta);
                }
            }
        }
        const renderer = this.get("renderer");
        renderer._start = this.get("start");
        renderer._end = this.get("end");
        renderer._inversed = renderer.get("inversed", false);
        renderer._axisLength = renderer.axisLength() / (renderer._end - renderer._start);
        renderer._updateLC();
        if (this.isDirty("tooltip")) {
            const tooltip = this.get("tooltip");
            if (tooltip) {
                const rendererTags = renderer.get("themeTags");
                tooltip.addTag("axis");
                tooltip.addTag(this.className.toLowerCase());
                tooltip._applyThemes();
                if (rendererTags) {
                    tooltip.set("themeTags", _core_util_Utils__WEBPACK_IMPORTED_MODULE_7__.mergeTags(tooltip.get("themeTags"), rendererTags));
                    tooltip.label._applyThemes();
                }
            }
        }
    }
    _updateTooltipBounds() {
        const tooltip = this.get("tooltip");
        if (tooltip) {
            this.get("renderer").updateTooltipBounds(tooltip);
        }
    }
    _updateBounds() {
        super._updateBounds();
        this._updateTooltipBounds();
    }
    /**
     * @ignore
     */
    processChart(chart) {
        this.chart = chart;
        const renderer = this.get("renderer");
        renderer.chart = chart;
        chart.gridContainer.children.push(this.gridContainer);
        chart.topGridContainer.children.push(this.topGridContainer);
        chart.axisHeadersContainer.children.push(this.axisHeader);
        this.on("start", () => {
            chart._handleAxisSelection(this);
        });
        this.on("end", () => {
            chart._handleAxisSelection(this);
        });
        chart.plotContainer.onPrivate("width", () => {
            this.markDirtySize();
        });
        chart.plotContainer.onPrivate("height", () => {
            this.markDirtySize();
        });
        chart.processAxis(this);
    }
    /**
     * @ignore
     */
    hideDataItem(dataItem) {
        this._toggleFHDataItem(dataItem, true);
        return super.hideDataItem(dataItem);
    }
    /**
     * @ignore
     */
    showDataItem(dataItem) {
        this._toggleFHDataItem(dataItem, false);
        return super.showDataItem(dataItem);
    }
    _toggleFHDataItem(dataItem, forceHidden) {
        const fh = "forceHidden";
        const label = dataItem.get("label");
        if (label) {
            label.set(fh, forceHidden);
        }
        const grid = dataItem.get("grid");
        if (grid) {
            grid.set(fh, forceHidden);
        }
        const tick = dataItem.get("tick");
        if (tick) {
            tick.set(fh, forceHidden);
        }
        const axisFill = dataItem.get("axisFill");
        if (axisFill) {
            axisFill.set(fh, forceHidden);
        }
        const bullet = dataItem.get("bullet");
        if (bullet) {
            const sprite = bullet.get("sprite");
            if (sprite) {
                sprite.set(fh, forceHidden);
            }
        }
    }
    _toggleDataItem(dataItem, visible) {
        const label = dataItem.get("label");
        const v = "visible";
        if (label) {
            label.setPrivate(v, visible);
        }
        const grid = dataItem.get("grid");
        if (grid) {
            grid.setPrivate(v, visible);
        }
        const tick = dataItem.get("tick");
        if (tick) {
            tick.setPrivate(v, visible);
        }
        const axisFill = dataItem.get("axisFill");
        if (axisFill) {
            axisFill.setPrivate(v, visible);
        }
        const bullet = dataItem.get("bullet");
        if (bullet) {
            const sprite = bullet.get("sprite");
            if (sprite) {
                sprite.setPrivate(v, visible);
            }
        }
    }
    _createAssets(dataItem, tags, minor) {
        var _a, _b, _c;
        const renderer = this.get("renderer");
        let m = "minor";
        const label = dataItem.get("label");
        if (!label) {
            renderer.makeLabel(dataItem, tags);
        }
        else {
            let themeTags = label.get("themeTags");
            let remove = false;
            if (minor) {
                if ((themeTags === null || themeTags === void 0 ? void 0 : themeTags.indexOf(m)) == -1) {
                    remove = true;
                }
            }
            else {
                if ((themeTags === null || themeTags === void 0 ? void 0 : themeTags.indexOf(m)) != -1) {
                    remove = true;
                }
            }
            if (remove) {
                (_a = label.parent) === null || _a === void 0 ? void 0 : _a.children.removeValue(label);
                renderer.makeLabel(dataItem, tags);
                label.dispose();
                renderer.labels.removeValue(label);
            }
        }
        const grid = dataItem.get("grid");
        if (!grid) {
            renderer.makeGrid(dataItem, tags);
        }
        else {
            let themeTags = grid.get("themeTags");
            let remove = false;
            if (minor) {
                if ((themeTags === null || themeTags === void 0 ? void 0 : themeTags.indexOf(m)) == -1) {
                    remove = true;
                }
            }
            else {
                if ((themeTags === null || themeTags === void 0 ? void 0 : themeTags.indexOf(m)) != -1) {
                    remove = true;
                }
            }
            if (remove) {
                (_b = grid.parent) === null || _b === void 0 ? void 0 : _b.children.removeValue(grid);
                renderer.makeGrid(dataItem, tags);
                grid.dispose();
                renderer.grid.removeValue(grid);
            }
        }
        const tick = dataItem.get("tick");
        if (!tick) {
            renderer.makeTick(dataItem, tags);
        }
        else {
            let remove = false;
            let themeTags = tick.get("themeTags");
            if (minor) {
                if ((themeTags === null || themeTags === void 0 ? void 0 : themeTags.indexOf(m)) == -1) {
                    remove = true;
                }
            }
            else {
                if ((themeTags === null || themeTags === void 0 ? void 0 : themeTags.indexOf(m)) != -1) {
                    remove = true;
                }
            }
            if (remove) {
                (_c = tick.parent) === null || _c === void 0 ? void 0 : _c.children.removeValue(tick);
                renderer.makeTick(dataItem, tags);
                tick.dispose();
                renderer.ticks.removeValue(tick);
            }
        }
        if (!minor && !dataItem.get("axisFill")) {
            renderer.makeAxisFill(dataItem, tags);
        }
        this._processBullet(dataItem);
    }
    _processBullet(dataItem) {
        let bullet = dataItem.get("bullet");
        let axisBullet = this.get("bullet");
        if (!bullet && axisBullet && !dataItem.get("isRange")) {
            bullet = axisBullet(this._root, this, dataItem);
        }
        if (bullet) {
            bullet.axis = this;
            const sprite = bullet.get("sprite");
            if (sprite) {
                sprite._setDataItem(dataItem);
                dataItem.setRaw("bullet", bullet);
                if (!sprite.parent) {
                    this.bulletsContainer.children.push(sprite);
                }
            }
        }
    }
    _afterChanged() {
        super._afterChanged();
        const chart = this.chart;
        if (chart) {
            chart._updateChartLayout();
            chart.axisHeadersContainer.markDirtySize();
        }
        this.get("renderer")._updatePositions();
    }
    /**
     * @ignore
     */
    disposeDataItem(dataItem) {
        super.disposeDataItem(dataItem);
        const renderer = this.get("renderer");
        const label = dataItem.get("label");
        if (label) {
            renderer.labels.removeValue(label);
            label.dispose();
        }
        const tick = dataItem.get("tick");
        if (tick) {
            renderer.ticks.removeValue(tick);
            tick.dispose();
        }
        const grid = dataItem.get("grid");
        if (grid) {
            renderer.grid.removeValue(grid);
            grid.dispose();
        }
        const axisFill = dataItem.get("axisFill");
        if (axisFill) {
            renderer.axisFills.removeValue(axisFill);
            axisFill.dispose();
        }
        const bullet = dataItem.get("bullet");
        if (bullet) {
            bullet.dispose();
        }
    }
    _updateGhost() {
        this.setPrivate("cellWidth", this.getCellWidthPosition() * this.get("renderer").axisLength());
        const ghostLabel = this.ghostLabel;
        if (!ghostLabel.isHidden()) {
            const bounds = ghostLabel.localBounds();
            const gWidth = Math.ceil(bounds.right - bounds.left);
            let text = ghostLabel.get("text");
            _core_util_Array__WEBPACK_IMPORTED_MODULE_5__.each(this.dataItems, (dataItem) => {
                const label = dataItem.get("label");
                if (label && !label.isHidden()) {
                    const bounds = label.localBounds();
                    const w = Math.ceil(bounds.right - bounds.left);
                    if (w > gWidth) {
                        text = label.text._getText();
                    }
                }
            });
            ghostLabel.set("text", text);
        }
        let start = this.get("start", 0);
        let end = this.get("end", 1);
        this.get("renderer").updateLabel(ghostLabel, start + (end - start) * 0.5);
    }
    _handleCursorPosition(position, snapToSeries) {
        const renderer = this.get("renderer");
        position = renderer.toAxisPosition(position);
        this._cursorPosition = position;
        this._snapToSeries = snapToSeries;
        this.updateTooltip();
    }
    /**
     * Can be called when axis zoom changes and you need to update tooltip
     * position.
     */
    updateTooltip() {
        const snapToSeries = this._snapToSeries;
        let position = this._cursorPosition;
        const tooltip = this.get("tooltip");
        const renderer = this.get("renderer");
        if (_core_util_Type__WEBPACK_IMPORTED_MODULE_6__.isNumber(position)) {
            _core_util_Array__WEBPACK_IMPORTED_MODULE_5__.each(this.series, (series) => {
                if (series.get("baseAxis") === this) {
                    const dataItem = this.getSeriesItem(series, position, this.get("tooltipLocation"));
                    series.setRaw("tooltipDataItem", dataItem);
                    if (snapToSeries && snapToSeries.indexOf(series) != -1) {
                        series.updateLegendMarker(dataItem);
                        series.updateLegendValue(dataItem);
                    }
                    else {
                        series.showDataItemTooltip(dataItem);
                    }
                }
            });
            if (tooltip) {
                renderer.updateTooltipBounds(tooltip);
                if (this.get("snapTooltip")) {
                    position = this.roundAxisPosition(position, this.get("tooltipLocation", 0.5));
                }
                if (!_core_util_Type__WEBPACK_IMPORTED_MODULE_6__.isNaN(position)) {
                    this.setPrivateRaw("tooltipPosition", position);
                    this._updateTooltipText(tooltip, position);
                    renderer.positionTooltip(tooltip, position);
                    if (position < this.get("start") || position > this.get("end")) {
                        tooltip.hide(0);
                    }
                    else {
                        tooltip.show(0);
                    }
                }
                else {
                    tooltip.hide(0);
                }
            }
        }
    }
    _updateTooltipText(tooltip, position) {
        tooltip.label.set("text", this.getTooltipText(position));
    }
    /**
     * @ignore
     */
    roundAxisPosition(position, _location) {
        return position;
    }
    /**
     * @ignore
     */
    handleCursorShow() {
        let tooltip = this.get("tooltip");
        if (tooltip) {
            tooltip.show();
        }
    }
    /**
     * @ignore
     */
    handleCursorHide() {
        let tooltip = this.get("tooltip");
        if (tooltip) {
            tooltip.hide();
        }
    }
    /**
     * @ignore
     */
    processSeriesDataItem(_dataItem, _fields) {
    }
    _clearDirty() {
        super._clearDirty();
        this._sizeDirty = false;
        this._rangesDirty = false;
    }
    /**
     * Converts pixel coordinate to a relative position on axis.
     *
     * @param   coordinate  Coordinate
     * @return              Relative position
     */
    coordinateToPosition(coordinate) {
        const renderer = this.get("renderer");
        return renderer.toAxisPosition(coordinate / renderer.axisLength());
    }
    /**
     * Converts relative position of the plot area to relative position of the
     * axis with zoom taken into account.
     *
     * @param position Position
     * @return Relative position
     */
    toAxisPosition(position) {
        return this.get("renderer").toAxisPosition(position);
    }
    /**
     * Converts relative position of the axis to a global position taking current
     * zoom into account (opposite to what `toAxisPosition` does).
     *
     * @since 5.4.2
     * @param position Position
     * @return Global position
     */
    toGlobalPosition(position) {
        return this.get("renderer").toGlobalPosition(position);
    }
    /**
     * Adjusts position with inversed taken into account.
     *
     * @ignore
     */
    fixPosition(position) {
        return this.get("renderer").fixPosition(position);
    }
    /**
     * @ignore
     */
    shouldGap(_dataItem, _nextItem, _autoGapCount, _fieldName) {
        return false;
    }
    /**
     * Creates and returns an axis range object.
     *
     * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/axis-ranges/} for more info
     * @param   axisDataItem  Axis data item
     * @return                Axis range
     */
    createAxisRange(axisDataItem) {
        return this.axisRanges.push(axisDataItem);
    }
    /**
     * @ignore
     */
    _groupSeriesData(_series) { }
    /**
     * Returns relative position between two grid lines of the axis.
     *
     * @return Position
     */
    getCellWidthPosition() {
        return 0.05;
    }
}
Object.defineProperty(Axis, "className", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: "Axis"
});
Object.defineProperty(Axis, "classNames", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: _core_render_Component__WEBPACK_IMPORTED_MODULE_0__.Component.classNames.concat([Axis.className])
});
//# sourceMappingURL=Axis.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/charts/xy/axes/AxisLabel.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/charts/xy/axes/AxisLabel.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AxisLabel: () => (/* binding */ AxisLabel)
/* harmony export */ });
/* harmony import */ var _core_render_Label__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../core/render/Label */ "./node_modules/@amcharts/amcharts5/.internal/core/render/Label.js");

/**
 * Draws an axis label.
 *
 * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/#Labels} for more info
 * @important
 */
class AxisLabel extends _core_render_Label__WEBPACK_IMPORTED_MODULE_0__.Label {
    constructor() {
        super(...arguments);
        Object.defineProperty(this, "_tickPoints", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
        });
    }
}
Object.defineProperty(AxisLabel, "className", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: "AxisLabel"
});
Object.defineProperty(AxisLabel, "classNames", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: _core_render_Label__WEBPACK_IMPORTED_MODULE_0__.Label.classNames.concat([AxisLabel.className])
});
//# sourceMappingURL=AxisLabel.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/charts/xy/axes/AxisRenderer.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/charts/xy/axes/AxisRenderer.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AxisRenderer: () => (/* binding */ AxisRenderer)
/* harmony export */ });
/* harmony import */ var _core_render_Graphics__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../core/render/Graphics */ "./node_modules/@amcharts/amcharts5/.internal/core/render/Graphics.js");
/* harmony import */ var _core_util_Template__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../core/util/Template */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Template.js");
/* harmony import */ var _core_util_List__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../core/util/List */ "./node_modules/@amcharts/amcharts5/.internal/core/util/List.js");
/* harmony import */ var _AxisTick__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./AxisTick */ "./node_modules/@amcharts/amcharts5/.internal/charts/xy/axes/AxisTick.js");
/* harmony import */ var _Grid__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Grid */ "./node_modules/@amcharts/amcharts5/.internal/charts/xy/axes/Grid.js");
/* harmony import */ var _AxisLabel__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./AxisLabel */ "./node_modules/@amcharts/amcharts5/.internal/charts/xy/axes/AxisLabel.js");
/* harmony import */ var _core_util_Utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../core/util/Utils */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Utils.js");







/**
 * Base class for an axis renderer.
 *
 * Should not be used on its own.
 *
 * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/#Axis_renderer} for more info
 */
class AxisRenderer extends _core_render_Graphics__WEBPACK_IMPORTED_MODULE_0__.Graphics {
    constructor() {
        super(...arguments);
        // save for quick access
        Object.defineProperty(this, "_axisLength", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 100
        });
        Object.defineProperty(this, "_start", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        Object.defineProperty(this, "_end", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 1
        });
        Object.defineProperty(this, "_inversed", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        Object.defineProperty(this, "_minSize", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        /**
         * Chart the renderer is used in.
         */
        Object.defineProperty(this, "chart", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_lc", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 1
        });
        Object.defineProperty(this, "_ls", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        Object.defineProperty(this, "_thumbDownPoint", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_downStart", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_downEnd", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /**
         * A list of ticks in the axis.
         *
         * `ticks.template` can be used to configure ticks.
         *
         * @default new ListTemplate<AxisTick>
         */
        Object.defineProperty(this, "ticks", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new _core_util_List__WEBPACK_IMPORTED_MODULE_1__.ListTemplate(_core_util_Template__WEBPACK_IMPORTED_MODULE_2__.Template.new({}), () => _AxisTick__WEBPACK_IMPORTED_MODULE_3__.AxisTick._new(this._root, {
                themeTags: _core_util_Utils__WEBPACK_IMPORTED_MODULE_4__.mergeTags(this.ticks.template.get("themeTags", []), this.get("themeTags", []))
            }, [this.ticks.template]))
        });
        /**
         * A list of grid elements in the axis.
         *
         * `grid.template` can be used to configure grid.
         *
         * @default new ListTemplate<Grid>
         */
        Object.defineProperty(this, "grid", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new _core_util_List__WEBPACK_IMPORTED_MODULE_1__.ListTemplate(_core_util_Template__WEBPACK_IMPORTED_MODULE_2__.Template.new({}), () => _Grid__WEBPACK_IMPORTED_MODULE_5__.Grid._new(this._root, {
                themeTags: _core_util_Utils__WEBPACK_IMPORTED_MODULE_4__.mergeTags(this.grid.template.get("themeTags", []), this.get("themeTags", []))
            }, [this.grid.template]))
        });
        /**
         * A list of fills in the axis.
         *
         * `axisFills.template` can be used to configure axis fills.
         *
         * @default new ListTemplate<Graphics>
         */
        Object.defineProperty(this, "axisFills", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new _core_util_List__WEBPACK_IMPORTED_MODULE_1__.ListTemplate(_core_util_Template__WEBPACK_IMPORTED_MODULE_2__.Template.new({}), () => _core_render_Graphics__WEBPACK_IMPORTED_MODULE_0__.Graphics._new(this._root, {
                themeTags: _core_util_Utils__WEBPACK_IMPORTED_MODULE_4__.mergeTags(this.axisFills.template.get("themeTags", ["axis", "fill"]), this.get("themeTags", []))
            }, [this.axisFills.template]))
        });
        /**
         * A list of labels in the axis.
         *
         * `labels.template` can be used to configure axis labels.
         *
         * @default new ListTemplate<AxisLabel>
         */
        Object.defineProperty(this, "labels", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new _core_util_List__WEBPACK_IMPORTED_MODULE_1__.ListTemplate(_core_util_Template__WEBPACK_IMPORTED_MODULE_2__.Template.new({}), () => _AxisLabel__WEBPACK_IMPORTED_MODULE_6__.AxisLabel._new(this._root, {
                themeTags: _core_util_Utils__WEBPACK_IMPORTED_MODULE_4__.mergeTags(this.labels.template.get("themeTags", []), this.get("themeTags", []))
            }, [this.labels.template]))
        });
        /**
         * An [[Axis]] renderer is for.
         */
        Object.defineProperty(this, "axis", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "thumb", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
    }
    /**
     * @ignore
     */
    makeTick(dataItem, themeTags) {
        const tick = this.ticks.make();
        tick._setDataItem(dataItem);
        dataItem.setRaw("tick", tick);
        tick.set("themeTags", _core_util_Utils__WEBPACK_IMPORTED_MODULE_4__.mergeTags(tick.get("themeTags"), themeTags));
        this.axis.labelsContainer.children.push(tick);
        this.ticks.push(tick);
        return tick;
    }
    /**
     * @ignore
     */
    makeGrid(dataItem, themeTags) {
        const grid = this.grid.make();
        grid._setDataItem(dataItem);
        dataItem.setRaw("grid", grid);
        grid.set("themeTags", _core_util_Utils__WEBPACK_IMPORTED_MODULE_4__.mergeTags(grid.get("themeTags"), themeTags));
        this.axis.gridContainer.children.push(grid);
        this.grid.push(grid);
        return grid;
    }
    /**
     * @ignore
     */
    makeAxisFill(dataItem, themeTags) {
        const axisFill = this.axisFills.make();
        axisFill._setDataItem(dataItem);
        axisFill.set("themeTags", _core_util_Utils__WEBPACK_IMPORTED_MODULE_4__.mergeTags(axisFill.get("themeTags"), themeTags));
        this.axis.gridContainer.children.push(axisFill);
        dataItem.setRaw("axisFill", axisFill);
        this.axisFills.push(axisFill);
        return axisFill;
    }
    /**
     * @ignore
     */
    makeLabel(dataItem, themeTags) {
        const label = this.labels.make();
        label.set("themeTags", _core_util_Utils__WEBPACK_IMPORTED_MODULE_4__.mergeTags(label.get("themeTags"), themeTags));
        this.axis.labelsContainer.children.moveValue(label, 0);
        label._setDataItem(dataItem);
        dataItem.setRaw("label", label);
        this.labels.push(label);
        return label;
    }
    axisLength() {
        return 0;
    }
    /**
     * @ignore
     */
    gridCount() {
        return this.axisLength() / this.get("minGridDistance", 50);
    }
    _updatePositions() {
    }
    _afterNew() {
        super._afterNew();
        this.set("isMeasured", false);
        const thumb = this.thumb;
        if (thumb) {
            this._disposers.push(thumb.events.on("pointerdown", (event) => {
                this._handleThumbDown(event);
            }));
            this._disposers.push(thumb.events.on("globalpointerup", (event) => {
                this._handleThumbUp(event);
            }));
            this._disposers.push(thumb.events.on("globalpointermove", (event) => {
                this._handleThumbMove(event);
            }));
        }
    }
    _beforeChanged() {
        super._beforeChanged();
        if (this.isDirty("minGridDistance")) {
            this.root.events.once("frameended", () => {
                this.axis.markDirtySize();
            });
        }
    }
    _changed() {
        super._changed();
        if (this.isDirty("pan")) {
            const thumb = this.thumb;
            if (thumb) {
                const labelsContainer = this.axis.labelsContainer;
                const pan = this.get("pan");
                if (pan == "zoom") {
                    labelsContainer.children.push(thumb);
                }
                else if (pan == "none") {
                    labelsContainer.children.removeValue(thumb);
                }
            }
        }
    }
    _handleThumbDown(event) {
        this._thumbDownPoint = this.toLocal(event.point);
        const axis = this.axis;
        this._downStart = axis.get("start");
        this._downEnd = axis.get("end");
    }
    _handleThumbUp(_event) {
        this._thumbDownPoint = undefined;
    }
    _handleThumbMove(event) {
        const downPoint = this._thumbDownPoint;
        if (downPoint) {
            const point = this.toLocal(event.point);
            const downStart = this._downStart;
            const downEnd = this._downEnd;
            const extra = this._getPan(point, downPoint) * Math.min(1, (downEnd - downStart)) / 2;
            this.axis.zoom(downStart - extra, downEnd + extra, 0);
        }
    }
    _getPan(_point1, _point2) {
        return 0;
    }
    /**
     * Converts relative position (0-1) on axis to a pixel coordinate.
     *
     * @param position  Position (0-1)
     * @return Coordinate (px)
     */
    positionToCoordinate(position) {
        if (this._inversed) {
            return (this._end - position) * this._axisLength;
        }
        else {
            return (position - this._start) * this._axisLength;
        }
    }
    /**
     * @ignore
     */
    updateTooltipBounds(_tooltip) { }
    _updateSize() {
        this.markDirty();
        this._clear = true;
    }
    /**
     * @ignore
     */
    toAxisPosition(position) {
        const start = this._start || 0;
        const end = this._end || 1;
        position = position * (end - start);
        if (!this.get("inversed")) {
            position = start + position;
        }
        else {
            position = end - position;
        }
        return position;
    }
    /**
     * @ignore
     */
    toGlobalPosition(position) {
        const start = this._start || 0;
        const end = this._end || 1;
        if (!this.get("inversed")) {
            position = position - start;
        }
        else {
            position = end - position;
        }
        position = position / (end - start);
        return position;
    }
    /**
     * @ignore
     */
    fixPosition(position) {
        if (this.get("inversed")) {
            return 1 - position;
        }
        return position;
    }
    /**
     * @ignore
     */
    _updateLC() {
    }
    toggleVisibility(sprite, position, minPosition, maxPosition) {
        let axis = this.axis;
        const start = axis.get("start", 0);
        const end = axis.get("end", 1);
        let updatedStart = start + (end - start) * (minPosition - 0.0001);
        let updatedEnd = start + (end - start) * (maxPosition + 0.0001);
        if (position < updatedStart || position > updatedEnd) {
            sprite.setPrivate("visible", false);
        }
        else {
            sprite.setPrivate("visible", true);
        }
    }
    _positionTooltip(tooltip, point) {
        const chart = this.chart;
        if (chart) {
            if (chart.inPlot(point)) {
                tooltip.set("pointTo", this._display.toGlobal(point));
            }
            else {
                tooltip.hide();
            }
        }
    }
    processAxis() { }
}
Object.defineProperty(AxisRenderer, "className", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: "AxisRenderer"
});
Object.defineProperty(AxisRenderer, "classNames", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: _core_render_Graphics__WEBPACK_IMPORTED_MODULE_0__.Graphics.classNames.concat([AxisRenderer.className])
});
//# sourceMappingURL=AxisRenderer.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/charts/xy/axes/AxisRendererX.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/charts/xy/axes/AxisRendererX.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AxisRendererX: () => (/* binding */ AxisRendererX)
/* harmony export */ });
/* harmony import */ var _AxisRenderer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AxisRenderer */ "./node_modules/@amcharts/amcharts5/.internal/charts/xy/axes/AxisRenderer.js");
/* harmony import */ var _core_util_Percent__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../core/util/Percent */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Percent.js");
/* harmony import */ var _core_util_Type__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../core/util/Type */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Type.js");
/* harmony import */ var _core_util_Utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../core/util/Utils */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Utils.js");
/* harmony import */ var _core_render_Rectangle__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../core/render/Rectangle */ "./node_modules/@amcharts/amcharts5/.internal/core/render/Rectangle.js");





/**
 * Used to render horizontal axis.
 *
 * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/#Axis_renderer} for more info
 * @important
 */
class AxisRendererX extends _AxisRenderer__WEBPACK_IMPORTED_MODULE_0__.AxisRenderer {
    constructor() {
        super(...arguments);
        Object.defineProperty(this, "thumb", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: _core_render_Rectangle__WEBPACK_IMPORTED_MODULE_1__.Rectangle.new(this._root, { width: _core_util_Percent__WEBPACK_IMPORTED_MODULE_2__.p100, isMeasured: false, themeTags: ["axis", "x", "thumb"] })
        });
    }
    _afterNew() {
        this._settings.themeTags = _core_util_Utils__WEBPACK_IMPORTED_MODULE_3__.mergeTags(this._settings.themeTags, ["renderer", "x"]);
        super._afterNew();
        this.setPrivateRaw("letter", "X");
        const gridTemplate = this.grid.template;
        gridTemplate.set("height", _core_util_Percent__WEBPACK_IMPORTED_MODULE_2__.p100);
        gridTemplate.set("width", 0);
        gridTemplate.set("draw", (display, graphics) => {
            display.moveTo(0, 0);
            display.lineTo(0, graphics.height());
        });
        this.set("draw", (display, graphics) => {
            display.moveTo(0, 0);
            display.lineTo(graphics.width(), 0);
        });
    }
    _changed() {
        super._changed();
        const axis = this.axis;
        axis.ghostLabel.setPrivate("visible", !this.get("inside"));
        axis.ghostLabel.set("x", -1000);
        const opposite = "opposite";
        const inside = "inside";
        if (this.isDirty(opposite) || this.isDirty(inside)) {
            const chart = this.chart;
            const axisChildren = axis.children;
            if (this.get(inside)) {
                axis.addTag(inside);
            }
            else {
                axis.removeTag(inside);
            }
            if (chart) {
                if (this.get(opposite)) {
                    const children = chart.topAxesContainer.children;
                    if (children.indexOf(axis) == -1) {
                        children.insertIndex(0, axis);
                    }
                    axis.addTag(opposite);
                    axisChildren.moveValue(this);
                }
                else {
                    const children = chart.bottomAxesContainer.children;
                    if (children.indexOf(axis) == -1) {
                        children.moveValue(axis);
                    }
                    axis.removeTag(opposite);
                    axisChildren.moveValue(this, 0);
                }
                axis.ghostLabel._applyThemes();
                this.labels.each((label) => {
                    label._applyThemes();
                });
                this.root._markDirtyRedraw();
            }
            axis.markDirtySize();
        }
        this.thumb.setPrivate("height", axis.labelsContainer.height());
    }
    _getPan(point1, point2) {
        return (point2.x - point1.x) / this.width();
    }
    /**
     * @ignore
     */
    toAxisPosition(position) {
        const start = this._start || 0;
        const end = this._end || 1;
        position -= this._ls;
        position = position * (end - start) / this._lc;
        if (!this.get("inversed")) {
            position = start + position;
        }
        else {
            position = end - position;
        }
        return position;
    }
    /**
     * @ignore
     */
    toGlobalPosition(position) {
        const start = this._start || 0;
        const end = this._end || 1;
        if (!this.get("inversed")) {
            position = position - start;
        }
        else {
            position = end - position;
        }
        position = position / (end - start) * this._lc;
        position += this._ls;
        return position;
    }
    /**
     * @ignore
     */
    _updateLC() {
        const axis = this.axis;
        const parent = axis.parent;
        if (parent) {
            const w = parent.innerWidth();
            this._lc = this.axisLength() / w;
            this._ls = (axis.x() - parent.get("paddingLeft", 0)) / w;
        }
    }
    /**
     * @ignore
     */
    _updatePositions() {
        const axis = this.axis;
        const x = axis.x() - _core_util_Utils__WEBPACK_IMPORTED_MODULE_3__.relativeToValue(axis.get("centerX", 0), axis.width()) - axis.parent.get("paddingLeft", 0);
        axis.gridContainer.set("x", x);
        axis.topGridContainer.set("x", x);
        axis.bulletsContainer.set("y", this.y());
        const chart = axis.chart;
        if (chart) {
            const plotContainer = chart.plotContainer;
            const axisHeader = axis.axisHeader;
            let width = axis.get("marginLeft", 0);
            let x = axis.x() - width;
            const parent = axis.parent;
            if (parent) {
                x -= parent.get("paddingLeft", 0);
            }
            if (axisHeader.children.length > 0) {
                width = axis.axisHeader.width();
                axis.set("marginLeft", width + 1);
            }
            else {
                axisHeader.set("width", width);
            }
            axisHeader.setAll({ x: x, y: -1, height: plotContainer.height() + 2 });
        }
    }
    /**
     * @ignore
     */
    processAxis() {
        super.processAxis();
        const axis = this.axis;
        axis.set("width", _core_util_Percent__WEBPACK_IMPORTED_MODULE_2__.p100);
        const verticalLayout = this._root.verticalLayout;
        axis.set("layout", verticalLayout);
        axis.labelsContainer.set("width", _core_util_Percent__WEBPACK_IMPORTED_MODULE_2__.p100);
        axis.axisHeader.setAll({ layout: verticalLayout });
    }
    /**
     * @ignore
     */
    axisLength() {
        return this.axis.width();
    }
    /**
     * Converts axis relative position to actual coordinate in pixels.
     *
     * @param   position  Position
     * @return            Point
     */
    positionToPoint(position) {
        return { x: this.positionToCoordinate(position), y: 0 };
    }
    /**
     * @ignore
     */
    updateTick(tick, position, endPosition, count) {
        if (tick) {
            if (!_core_util_Type__WEBPACK_IMPORTED_MODULE_4__.isNumber(position)) {
                position = 0;
            }
            let location = 0.5;
            if (_core_util_Type__WEBPACK_IMPORTED_MODULE_4__.isNumber(count) && count > 1) {
                location = tick.get("multiLocation", location);
            }
            else {
                location = tick.get("location", location);
            }
            if (_core_util_Type__WEBPACK_IMPORTED_MODULE_4__.isNumber(endPosition) && endPosition != position) {
                position = position + (endPosition - position) * location;
            }
            tick.set("x", this.positionToCoordinate(position));
            let length = tick.get("length", 0);
            const inside = tick.get("inside", this.get("inside", false));
            if (this.get("opposite")) {
                tick.set("y", _core_util_Percent__WEBPACK_IMPORTED_MODULE_2__.p100);
                if (!inside) {
                    length *= -1;
                }
            }
            else {
                tick.set("y", 0);
                if (inside) {
                    length *= -1;
                }
            }
            tick.set("draw", (display) => {
                display.moveTo(0, 0);
                display.lineTo(0, length);
            });
            this.toggleVisibility(tick, position, tick.get("minPosition", 0), tick.get("maxPosition", 1));
        }
    }
    /**
     * @ignore
     */
    updateLabel(label, position, endPosition, count) {
        if (label) {
            let location = 0.5;
            if (_core_util_Type__WEBPACK_IMPORTED_MODULE_4__.isNumber(count) && count > 1) {
                location = label.get("multiLocation", location);
            }
            else {
                location = label.get("location", location);
            }
            if (!_core_util_Type__WEBPACK_IMPORTED_MODULE_4__.isNumber(position)) {
                position = 0;
            }
            const inside = label.get("inside", this.get("inside", false));
            const opposite = this.get("opposite");
            if (opposite) {
                if (!inside) {
                    label.set("position", "relative");
                    label.set("y", _core_util_Percent__WEBPACK_IMPORTED_MODULE_2__.p100);
                }
                else {
                    label.set("position", "absolute");
                    label.set("y", 0);
                }
            }
            else {
                if (!inside) {
                    label.set("y", undefined);
                    label.set("position", "relative");
                }
                else {
                    label.set("y", 0);
                    label.set("position", "absolute");
                }
            }
            if (_core_util_Type__WEBPACK_IMPORTED_MODULE_4__.isNumber(endPosition) && endPosition != position) {
                position = position + (endPosition - position) * location;
            }
            label.set("x", this.positionToCoordinate(position));
            this.toggleVisibility(label, position, label.get("minPosition", 0), label.get("maxPosition", 1));
        }
    }
    /**
     * @ignore
     */
    updateGrid(grid, position, endPosition) {
        if (grid) {
            if (!_core_util_Type__WEBPACK_IMPORTED_MODULE_4__.isNumber(position)) {
                position = 0;
            }
            let location = grid.get("location", 0.5);
            if (_core_util_Type__WEBPACK_IMPORTED_MODULE_4__.isNumber(endPosition) && endPosition != position) {
                position = position + (endPosition - position) * location;
            }
            grid.set("x", this.positionToCoordinate(position));
            this.toggleVisibility(grid, position, 0, 1);
        }
    }
    /**
     * @ignore
     */
    updateBullet(bullet, position, endPosition) {
        if (bullet) {
            const sprite = bullet.get("sprite");
            if (sprite) {
                if (!_core_util_Type__WEBPACK_IMPORTED_MODULE_4__.isNumber(position)) {
                    position = 0;
                }
                let location = bullet.get("location", 0.5);
                if (_core_util_Type__WEBPACK_IMPORTED_MODULE_4__.isNumber(endPosition) && endPosition != position) {
                    position = position + (endPosition - position) * location;
                }
                let bulletPosition = this.axis.roundAxisPosition(position, location);
                let previousBullet = this.axis._bullets[bulletPosition];
                let d = -1;
                if (this.get("opposite")) {
                    d = 1;
                }
                if (bullet.get("stacked")) {
                    if (previousBullet) {
                        let previousSprite = previousBullet.get("sprite");
                        if (previousSprite) {
                            sprite.set("y", previousSprite.y() + previousSprite.height() * d);
                        }
                    }
                    else {
                        sprite.set("y", 0);
                    }
                }
                this.axis._bullets[bulletPosition] = bullet;
                sprite.set("x", this.positionToCoordinate(position));
                this.toggleVisibility(sprite, position, 0, 1);
            }
        }
    }
    /**
     * @ignore
     */
    updateFill(fill, position, endPosition) {
        if (fill) {
            if (!_core_util_Type__WEBPACK_IMPORTED_MODULE_4__.isNumber(position)) {
                position = 0;
            }
            if (!_core_util_Type__WEBPACK_IMPORTED_MODULE_4__.isNumber(endPosition)) {
                endPosition = 1;
            }
            let x0 = this.positionToCoordinate(position);
            let x1 = this.positionToCoordinate(endPosition);
            this.fillDrawMethod(fill, x0, x1);
        }
    }
    fillDrawMethod(fill, x0, x1) {
        fill.set("draw", (display) => {
            //display.drawRect(x0, 0, x1 - x0, this.axis!.gridContainer.height());
            // using for holes, so can not be rectangle
            const h = this.axis.gridContainer.height();
            const w = this.width();
            if (x1 < x0) {
                [x1, x0] = [x0, x1];
            }
            if (x0 > w || x1 < 0) {
                return;
            }
            /*
            const limit = 10000;

            x0 = Math.max(-limit, x0);
            x1 = Math.min(limit, x1);
            */
            display.moveTo(x0, 0);
            display.lineTo(x1, 0);
            display.lineTo(x1, h);
            display.lineTo(x0, h);
            display.lineTo(x0, 0);
        });
    }
    /**
     * @ignore
     */
    positionTooltip(tooltip, position) {
        this._positionTooltip(tooltip, { x: this.positionToCoordinate(position), y: 0 });
    }
    /**
     * @ignore
     */
    updateTooltipBounds(tooltip) {
        const inside = this.get("inside");
        const num = 100000;
        let global = this._display.toGlobal({ x: 0, y: 0 });
        let x = global.x;
        let y = 0;
        let w = this.axisLength();
        let h = num;
        let pointerOrientation = "up";
        if (this.get("opposite")) {
            if (inside) {
                pointerOrientation = "up";
                y = global.y;
                h = num;
            }
            else {
                pointerOrientation = "down";
                y = global.y - num;
                h = num;
            }
        }
        else {
            if (inside) {
                pointerOrientation = "down";
                y = global.y - num;
                h = num;
            }
            else {
                pointerOrientation = "up";
                y = global.y;
                h = num;
            }
        }
        const bounds = { left: x, right: x + w, top: y, bottom: y + h };
        const oldBounds = tooltip.get("bounds");
        if (!_core_util_Utils__WEBPACK_IMPORTED_MODULE_3__.sameBounds(bounds, oldBounds)) {
            tooltip.set("bounds", bounds);
            tooltip.set("pointerOrientation", pointerOrientation);
        }
    }
}
Object.defineProperty(AxisRendererX, "className", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: "AxisRendererX"
});
Object.defineProperty(AxisRendererX, "classNames", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: _AxisRenderer__WEBPACK_IMPORTED_MODULE_0__.AxisRenderer.classNames.concat([AxisRendererX.className])
});
//# sourceMappingURL=AxisRendererX.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/charts/xy/axes/AxisRendererY.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/charts/xy/axes/AxisRendererY.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AxisRendererY: () => (/* binding */ AxisRendererY)
/* harmony export */ });
/* harmony import */ var _AxisRenderer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AxisRenderer */ "./node_modules/@amcharts/amcharts5/.internal/charts/xy/axes/AxisRenderer.js");
/* harmony import */ var _core_util_Percent__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../core/util/Percent */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Percent.js");
/* harmony import */ var _core_util_Type__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../core/util/Type */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Type.js");
/* harmony import */ var _core_util_Utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../core/util/Utils */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Utils.js");
/* harmony import */ var _core_render_Rectangle__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../core/render/Rectangle */ "./node_modules/@amcharts/amcharts5/.internal/core/render/Rectangle.js");





/**
 * Used to render vertical axis.
 *
 * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/#Axis_renderer} for more info
 * @important
 */
class AxisRendererY extends _AxisRenderer__WEBPACK_IMPORTED_MODULE_0__.AxisRenderer {
    constructor() {
        super(...arguments);
        Object.defineProperty(this, "_downY", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "thumb", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: _core_render_Rectangle__WEBPACK_IMPORTED_MODULE_1__.Rectangle.new(this._root, { height: _core_util_Percent__WEBPACK_IMPORTED_MODULE_2__.p100, isMeasured: false, themeTags: ["axis", "y", "thumb"] })
        });
    }
    _afterNew() {
        this._settings.themeTags = _core_util_Utils__WEBPACK_IMPORTED_MODULE_3__.mergeTags(this._settings.themeTags, ["renderer", "y"]);
        if (this._settings.opposite) {
            this._settings.themeTags.push("opposite");
        }
        super._afterNew();
        this.setPrivateRaw("letter", "Y");
        const gridTemplate = this.grid.template;
        gridTemplate.set("width", _core_util_Percent__WEBPACK_IMPORTED_MODULE_2__.p100);
        gridTemplate.set("height", 0);
        gridTemplate.set("draw", (display, graphics) => {
            display.moveTo(0, 0);
            display.lineTo(graphics.width(), 0);
        });
        this.set("draw", (display, renderer) => {
            display.moveTo(0, 0);
            display.lineTo(0, renderer.height());
        });
    }
    _getPan(point1, point2) {
        return (point1.y - point2.y) / this.height();
    }
    _changed() {
        super._changed();
        const axis = this.axis;
        axis.ghostLabel.setPrivate("visible", !this.get("inside"));
        axis.ghostLabel.set("y", -1000);
        const thumb = this.thumb;
        const opposite = "opposite";
        const inside = "inside";
        const chart = this.chart;
        if (this.isDirty(opposite) || this.isDirty(inside)) {
            const axisChildren = axis.children;
            if (this.get(inside)) {
                axis.addTag(inside);
            }
            else {
                axis.removeTag(inside);
            }
            if (chart) {
                if (this.get(opposite)) {
                    const children = chart.rightAxesContainer.children;
                    if (children.indexOf(axis) == -1) {
                        children.moveValue(axis, 0);
                    }
                    axis.addTag(opposite);
                    axisChildren.moveValue(this, 0);
                }
                else {
                    const children = chart.leftAxesContainer.children;
                    if (children.indexOf(axis) == -1) {
                        children.moveValue(axis);
                    }
                    axis.removeTag(opposite);
                    axisChildren.moveValue(this);
                }
                axis.ghostLabel._applyThemes();
                this.labels.each((label) => {
                    label._applyThemes();
                });
                this.root._markDirtyRedraw();
            }
            axis.markDirtySize();
        }
        const w = axis.labelsContainer.width();
        if (chart) {
            if (this.get(opposite)) {
                thumb.set("centerX", 0);
            }
            else {
                thumb.set("centerX", w);
            }
        }
        thumb.setPrivate("width", w);
    }
    /**
     * @ignore
     */
    processAxis() {
        super.processAxis();
        const axis = this.axis;
        if (axis.get("height") == null) {
            axis.set("height", _core_util_Percent__WEBPACK_IMPORTED_MODULE_2__.p100);
        }
        const horizontalLayout = this._root.horizontalLayout;
        axis.set("layout", horizontalLayout);
        axis.labelsContainer.set("height", _core_util_Percent__WEBPACK_IMPORTED_MODULE_2__.p100);
        axis.axisHeader.set("layout", horizontalLayout);
    }
    _updatePositions() {
        const axis = this.axis;
        const y = axis.y() - _core_util_Utils__WEBPACK_IMPORTED_MODULE_3__.relativeToValue(axis.get("centerY", 0), axis.height());
        axis.gridContainer.set("y", y);
        axis.topGridContainer.set("y", y);
        axis.bulletsContainer.set("x", this.x());
        const chart = axis.chart;
        if (chart) {
            const plotContainer = chart.plotContainer;
            const axisHeader = axis.axisHeader;
            let height = axis.get("marginTop", 0);
            if (axisHeader.children.length > 0) {
                height = axis.axisHeader.height();
                axis.set("marginTop", height + 1);
            }
            else {
                axisHeader.set("height", height);
            }
            axisHeader.setAll({ y: axis.y() - height, x: -1, width: plotContainer.width() + 2 });
        }
    }
    /**
     * @ignore
     */
    axisLength() {
        return this.axis.innerHeight();
    }
    /**
     * Converts axis relative position to actual coordinate in pixels.
     *
     * @param   position  Position
     * @return            Point
     */
    positionToPoint(position) {
        return { x: 0, y: this.positionToCoordinate(position) };
    }
    /**
     * @ignore
     */
    updateLabel(label, position, endPosition, count) {
        if (label) {
            if (!_core_util_Type__WEBPACK_IMPORTED_MODULE_4__.isNumber(position)) {
                position = 0;
            }
            let location = 0.5;
            if (_core_util_Type__WEBPACK_IMPORTED_MODULE_4__.isNumber(count) && count > 1) {
                location = label.get("multiLocation", location);
            }
            else {
                location = label.get("location", location);
            }
            const opposite = this.get("opposite");
            const inside = label.get("inside", this.get("inside", false));
            if (opposite) {
                label.set("x", 0);
                if (inside) {
                    label.set("position", "absolute");
                }
                else {
                    label.set("position", "relative");
                }
            }
            else {
                if (inside) {
                    label.set("x", 0);
                    label.set("position", "absolute");
                }
                else {
                    label.set("x", undefined);
                    label.set("position", "relative");
                }
            }
            if (_core_util_Type__WEBPACK_IMPORTED_MODULE_4__.isNumber(endPosition) && endPosition != position) {
                position = position + (endPosition - position) * location;
            }
            label.set("y", this.positionToCoordinate(position));
            this.toggleVisibility(label, position, label.get("minPosition", 0), label.get("maxPosition", 1));
        }
    }
    /**
     * @ignore
     */
    updateGrid(grid, position, endPosition) {
        if (grid) {
            if (!_core_util_Type__WEBPACK_IMPORTED_MODULE_4__.isNumber(position)) {
                position = 0;
            }
            let location = grid.get("location", 0.5);
            if (_core_util_Type__WEBPACK_IMPORTED_MODULE_4__.isNumber(endPosition) && endPosition != position) {
                position = position + (endPosition - position) * location;
            }
            grid.set("y", this.positionToCoordinate(position));
            this.toggleVisibility(grid, position, 0, 1);
        }
    }
    /**
     * @ignore
     */
    updateTick(tick, position, endPosition, count) {
        if (tick) {
            if (!_core_util_Type__WEBPACK_IMPORTED_MODULE_4__.isNumber(position)) {
                position = 0;
            }
            let location = 0.5;
            if (_core_util_Type__WEBPACK_IMPORTED_MODULE_4__.isNumber(count) && count > 1) {
                location = tick.get("multiLocation", location);
            }
            else {
                location = tick.get("location", location);
            }
            if (_core_util_Type__WEBPACK_IMPORTED_MODULE_4__.isNumber(endPosition) && endPosition != position) {
                position = position + (endPosition - position) * location;
            }
            tick.set("y", this.positionToCoordinate(position));
            let length = tick.get("length", 0);
            const inside = tick.get("inside", this.get("inside", false));
            if (this.get("opposite")) {
                tick.set("x", 0);
                if (inside) {
                    length *= -1;
                }
            }
            else {
                if (!inside) {
                    length *= -1;
                }
            }
            tick.set("draw", (display) => {
                display.moveTo(0, 0);
                display.lineTo(length, 0);
            });
            this.toggleVisibility(tick, position, tick.get("minPosition", 0), tick.get("maxPosition", 1));
        }
    }
    /**
     * @ignore
     */
    updateBullet(bullet, position, endPosition) {
        if (bullet) {
            const sprite = bullet.get("sprite");
            if (sprite) {
                if (!_core_util_Type__WEBPACK_IMPORTED_MODULE_4__.isNumber(position)) {
                    position = 0;
                }
                let location = bullet.get("location", 0.5);
                if (_core_util_Type__WEBPACK_IMPORTED_MODULE_4__.isNumber(endPosition) && endPosition != position) {
                    position = position + (endPosition - position) * location;
                }
                let bulletPosition = this.axis.roundAxisPosition(position, location);
                let previousBullet = this.axis._bullets[bulletPosition];
                let d = 1;
                if (this.get("opposite")) {
                    d = -1;
                }
                if (bullet.get("stacked")) {
                    if (previousBullet) {
                        let previousSprite = previousBullet.get("sprite");
                        if (previousSprite) {
                            sprite.set("x", previousSprite.x() + previousSprite.width() * d);
                        }
                    }
                    else {
                        sprite.set("x", 0);
                    }
                }
                this.axis._bullets[bulletPosition] = bullet;
                sprite.set("y", this.positionToCoordinate(position));
                this.toggleVisibility(sprite, position, 0, 1);
            }
        }
    }
    /**
     * @ignore
     */
    updateFill(fill, position, endPosition) {
        if (fill) {
            if (!_core_util_Type__WEBPACK_IMPORTED_MODULE_4__.isNumber(position)) {
                position = 0;
            }
            if (!_core_util_Type__WEBPACK_IMPORTED_MODULE_4__.isNumber(endPosition)) {
                endPosition = 1;
            }
            let y0 = this.positionToCoordinate(position);
            let y1 = this.positionToCoordinate(endPosition);
            this.fillDrawMethod(fill, y0, y1);
        }
    }
    fillDrawMethod(fill, y0, y1) {
        fill.set("draw", (display) => {
            // using for holes, so can not be rectangle
            const w = this.axis.gridContainer.width();
            const h = this.height();
            if (y1 < y0) {
                [y1, y0] = [y0, y1];
            }
            if (y0 > h || y1 < 0) {
                return;
            }
            //y0 = Math.max(0, y0);
            //y1 = Math.min(h, y1);
            display.moveTo(0, y0);
            display.lineTo(w, y0);
            display.lineTo(w, y1);
            display.lineTo(0, y1);
            display.lineTo(0, y0);
        });
    }
    /**
     * Converts relative position (0-1) on axis to a pixel coordinate.
     *
     * @param position  Position (0-1)
     * @return Coordinate (px)
     */
    positionToCoordinate(position) {
        if (!this._inversed) {
            return (this._end - position) * this._axisLength;
        }
        else {
            return (position - this._start) * this._axisLength;
        }
    }
    /**
     * @ignore
     */
    positionTooltip(tooltip, position) {
        this._positionTooltip(tooltip, { x: 0, y: this.positionToCoordinate(position) });
    }
    /**
     * @ignore
     */
    updateTooltipBounds(tooltip) {
        const inside = this.get("inside");
        const num = 100000;
        let global = this._display.toGlobal({ x: 0, y: 0 });
        let y = global.y;
        let x = 0;
        let h = this.axisLength();
        let w = num;
        let pointerOrientation = "right";
        if (this.get("opposite")) {
            if (inside) {
                pointerOrientation = "right";
                x = global.x - num;
                w = num;
            }
            else {
                pointerOrientation = "left";
                x = global.x;
                w = num;
            }
        }
        else {
            if (inside) {
                pointerOrientation = "left";
                x = global.x;
                w = num;
            }
            else {
                pointerOrientation = "right";
                x = global.x - num;
                w = num;
            }
        }
        const bounds = { left: x, right: x + w, top: y, bottom: y + h };
        const oldBounds = tooltip.get("bounds");
        if (!_core_util_Utils__WEBPACK_IMPORTED_MODULE_3__.sameBounds(bounds, oldBounds)) {
            tooltip.set("bounds", bounds);
            tooltip.set("pointerOrientation", pointerOrientation);
        }
    }
    /**
     * @ignore
     */
    _updateLC() {
        const axis = this.axis;
        const parent = axis.parent;
        if (parent) {
            const h = parent.innerHeight();
            this._lc = this.axisLength() / h;
            this._ls = axis.y() / h;
        }
    }
    /**
     * @ignore
     */
    toAxisPosition(position) {
        const start = this._start || 0;
        const end = this._end || 1;
        position -= this._ls;
        position = position * (end - start) / this._lc;
        if (this.get("inversed")) {
            position = start + position;
        }
        else {
            position = end - position;
        }
        return position;
    }
    /**
     * @ignore
     */
    toGlobalPosition(position) {
        const start = this._start || 0;
        const end = this._end || 1;
        if (this.get("inversed")) {
            position = position - start;
        }
        else {
            position = end - position;
        }
        position = position / (end - start) * this._lc;
        position += this._ls;
        return position;
    }
    /**
     * @ignore
     */
    fixPosition(position) {
        if (!this.get("inversed")) {
            return 1 - position;
        }
        return position;
    }
}
Object.defineProperty(AxisRendererY, "className", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: "AxisRendererY"
});
Object.defineProperty(AxisRendererY, "classNames", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: _AxisRenderer__WEBPACK_IMPORTED_MODULE_0__.AxisRenderer.classNames.concat([AxisRendererY.className])
});
//# sourceMappingURL=AxisRendererY.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/charts/xy/axes/AxisTick.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/charts/xy/axes/AxisTick.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AxisTick: () => (/* binding */ AxisTick)
/* harmony export */ });
/* harmony import */ var _core_render_Tick__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../core/render/Tick */ "./node_modules/@amcharts/amcharts5/.internal/core/render/Tick.js");

/**
 * Draws an axis tick.
 *
 * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/#Ticks} for more info
 * @important
 */
class AxisTick extends _core_render_Tick__WEBPACK_IMPORTED_MODULE_0__.Tick {
    constructor() {
        super(...arguments);
        Object.defineProperty(this, "_tickPoints", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
        });
    }
}
Object.defineProperty(AxisTick, "className", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: "AxisTick"
});
Object.defineProperty(AxisTick, "classNames", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: _core_render_Tick__WEBPACK_IMPORTED_MODULE_0__.Tick.classNames.concat([AxisTick.className])
});
//# sourceMappingURL=AxisTick.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/charts/xy/axes/CategoryAxis.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/charts/xy/axes/CategoryAxis.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CategoryAxis: () => (/* binding */ CategoryAxis)
/* harmony export */ });
/* harmony import */ var _Axis__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Axis */ "./node_modules/@amcharts/amcharts5/.internal/charts/xy/axes/Axis.js");
/* harmony import */ var _core_util_Array__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../core/util/Array */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Array.js");
/* harmony import */ var _core_util_Type__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../core/util/Type */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Type.js");
/* harmony import */ var _core_util_Math__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../core/util/Math */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Math.js");
/* harmony import */ var _core_util_Utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../core/util/Utils */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Utils.js");
/* harmony import */ var _core_util_PopulateString__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../core/util/PopulateString */ "./node_modules/@amcharts/amcharts5/.internal/core/util/PopulateString.js");






/**
 * Creates a category axis.
 *
 * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/category-axis/} for more info
 * @important
 */
class CategoryAxis extends _Axis__WEBPACK_IMPORTED_MODULE_0__.Axis {
    constructor() {
        super(...arguments);
        Object.defineProperty(this, "_frequency", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 1
        });
        Object.defineProperty(this, "_itemMap", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {}
        });
    }
    _afterNew() {
        this._settings.themeTags = _core_util_Utils__WEBPACK_IMPORTED_MODULE_1__.mergeTags(this._settings.themeTags, ["axis"]);
        this.fields.push("category");
        this.setPrivateRaw("name", "category");
        this.addTag("category");
        super._afterNew();
    }
    _prepareChildren() {
        super._prepareChildren();
        const len = this.dataItems.length;
        let i = 0;
        if (this._valuesDirty) {
            this._itemMap = {};
            _core_util_Array__WEBPACK_IMPORTED_MODULE_2__.each(this.dataItems, (dataItem) => {
                dataItem.setRaw("index", i);
                this._itemMap[dataItem.get("category")] = dataItem;
                i++;
            });
            this.setPrivateRaw("maxZoomFactor", len);
        }
        this.setPrivateRaw("startIndex", Math.max(Math.round(this.get("start", 0) * len), 0));
        this.setPrivateRaw("endIndex", Math.min(Math.round(this.get("end", 1) * len), len));
        if (this._sizeDirty || this._valuesDirty || (this.isDirty("start") || this.isDirty("end") || this.isPrivateDirty("endIndex") || this.isPrivateDirty("startIndex") || this.isPrivateDirty("width") || this.isPrivateDirty("height"))) {
            if (this.dataItems.length > 0) {
                this._handleRangeChange();
                this._prepareAxisItems();
                this._updateAxisRanges();
            }
        }
    }
    _handleRangeChange() {
        _core_util_Array__WEBPACK_IMPORTED_MODULE_2__.each(this.series, (series) => {
            let startCategory = this.dataItems[this.startIndex()].get("category");
            let endCategory = this.dataItems[this.endIndex() - 1].get("category");
            let baseAxis = series.get("baseAxis");
            let xAxis = series.get("xAxis");
            let yAxis = series.get("yAxis");
            if (xAxis instanceof CategoryAxis && yAxis instanceof CategoryAxis) {
                series._markDirtyAxes();
            }
            else if (baseAxis === this) {
                let key;
                let openKey;
                let otherAxis = yAxis;
                if (xAxis === baseAxis) {
                    if (series.get("categoryXField")) {
                        key = "categoryX";
                    }
                    if (series.get("openCategoryXField")) {
                        openKey = "openCategoryX";
                    }
                }
                else if (yAxis === baseAxis) {
                    if (series.get("categoryYField")) {
                        key = "categoryY";
                    }
                    if (series.get("openCategoryYField")) {
                        openKey = "openCategoryY";
                    }
                    otherAxis = xAxis;
                }
                if (otherAxis.className == "ValueAxis") {
                    if (key || openKey) {
                        let startDataItem;
                        let endDataItem;
                        for (let i = 0, len = series.dataItems.length; i < len; i++) {
                            let dataItem = series.dataItems[i];
                            if (key) {
                                if (dataItem.get(key) === startCategory) {
                                    startDataItem = dataItem;
                                    break;
                                }
                            }
                            if (openKey) {
                                if (dataItem.get(openKey) === startCategory) {
                                    startDataItem = dataItem;
                                    break;
                                }
                            }
                        }
                        for (let i = series.dataItems.length - 1; i >= 0; i--) {
                            let dataItem = series.dataItems[i];
                            if (key) {
                                if (dataItem.get(key) === endCategory) {
                                    endDataItem = dataItem;
                                    break;
                                }
                            }
                            if (openKey) {
                                if (dataItem.get(openKey) === endCategory) {
                                    endDataItem = dataItem;
                                    break;
                                }
                            }
                        }
                        let startIndex = 0;
                        let endIndex = series.dataItems.length;
                        if (startDataItem) {
                            startIndex = series.dataItems.indexOf(startDataItem);
                        }
                        if (endDataItem) {
                            endIndex = series.dataItems.indexOf(endDataItem) + 1;
                        }
                        series.setPrivate("startIndex", startIndex);
                        series.setPrivate("endIndex", endIndex);
                        let hasValue = false;
                        for (let i = startIndex; i < endIndex; i++) {
                            const dataItem = series.dataItems[i];
                            _core_util_Array__WEBPACK_IMPORTED_MODULE_2__.each(series.__valueXShowFields, (key) => {
                                let value = dataItem.get(key);
                                if (value != null) {
                                    hasValue = true;
                                }
                            });
                            _core_util_Array__WEBPACK_IMPORTED_MODULE_2__.each(series.__valueYShowFields, (key) => {
                                let value = dataItem.get(key);
                                if (value != null) {
                                    hasValue = true;
                                }
                            });
                            if (hasValue) {
                                break;
                            }
                        }
                        series.setPrivate("outOfSelection", !hasValue);
                    }
                }
                series._markDirtyAxes(); // must be outside
            }
        });
    }
    _prepareAxisItems() {
        var _a;
        const renderer = this.get("renderer");
        const len = this.dataItems.length;
        let startIndex = this.startIndex();
        if (startIndex > 0) {
            startIndex--;
        }
        let endIndex = this.endIndex();
        if (endIndex < len) {
            endIndex++;
        }
        const minorLabelsEnabled = renderer.get("minorLabelsEnabled");
        const minorGridEnabled = renderer.get("minorGridEnabled", minorLabelsEnabled);
        let maxCount = renderer.axisLength() / Math.max(renderer.get("minGridDistance"), 1);
        let frequency = Math.max(1, Math.min(len, Math.ceil((endIndex - startIndex) / maxCount)));
        startIndex = Math.floor(startIndex / frequency) * frequency;
        this._frequency = frequency;
        for (let j = 0; j < len; j++) {
            this._toggleDataItem(this.dataItems[j], false);
        }
        let f = this.dataItems[startIndex].get("index", 0);
        for (let i = startIndex; i < endIndex; i = i + frequency) {
            let dataItem = this.dataItems[i];
            this._createAssets(dataItem, []);
            this._toggleDataItem(dataItem, true);
            let count = frequency;
            if (minorGridEnabled) {
                count = 1;
            }
            this._prepareDataItem(dataItem, f, count);
            f++;
        }
        if (renderer.get("minorGridEnabled")) {
            for (let i = startIndex; i < endIndex; i++) {
                let dataItem = this.dataItems[i];
                if (i % frequency != 0) {
                    this._createAssets(dataItem, ["minor"], true);
                    this._toggleDataItem(dataItem, true);
                    this._prepareDataItem(dataItem, 0, 1);
                    if (!minorLabelsEnabled) {
                        (_a = dataItem.get("label")) === null || _a === void 0 ? void 0 : _a.setPrivate("visible", false);
                    }
                }
            }
        }
        this._updateGhost();
    }
    _prepareDataItem(dataItem, fillIndex, count) {
        let renderer = this.get("renderer");
        let categoryLocation = dataItem.get("categoryLocation", 0);
        let endCategoryLocation = dataItem.get("endCategoryLocation", 1);
        let index = dataItem.get("index");
        if (!_core_util_Type__WEBPACK_IMPORTED_MODULE_3__.isNumber(index)) {
            index = this.categoryToIndex(dataItem.get("category"));
        }
        let position = this.indexToPosition(index, categoryLocation);
        let endCategory = dataItem.get("endCategory");
        let endIndex;
        if (endCategory) {
            endIndex = this.categoryToIndex(endCategory);
            if (!_core_util_Type__WEBPACK_IMPORTED_MODULE_3__.isNumber(endIndex)) {
                endIndex = index;
            }
        }
        else {
            endIndex = index;
        }
        let endPosition = this.indexToPosition(endIndex, endCategoryLocation);
        let fillEndIndex;
        let fillEndPosition;
        if (dataItem.get("isRange")) {
            fillEndIndex = endIndex;
        }
        else {
            fillEndIndex = index + this._frequency - 1;
        }
        fillEndPosition = this.indexToPosition(fillEndIndex, endCategoryLocation);
        renderer.updateLabel(dataItem.get("label"), position, endPosition, count);
        renderer.updateGrid(dataItem.get("grid"), position, endPosition);
        renderer.updateTick(dataItem.get("tick"), position, endPosition, count);
        renderer.updateFill(dataItem.get("axisFill"), position, fillEndPosition);
        this._processBullet(dataItem);
        renderer.updateBullet(dataItem.get("bullet"), position, endPosition);
        const fillRule = this.get("fillRule");
        if (fillRule) {
            fillRule(dataItem, fillIndex);
        }
    }
    startIndex() {
        let len = this.dataItems.length;
        return Math.min(Math.max(this.getPrivate("startIndex", 0), 0), len - 1);
    }
    endIndex() {
        let len = this.dataItems.length;
        return Math.max(1, Math.min(this.getPrivate("endIndex", len), len));
    }
    /**
     * @ignore
     */
    baseValue() {
    }
    /**
     * @ignore
     */
    basePosition() {
        return 0;
    }
    /**
     * Returns X coordinate in pixels corresponding to specific category index.
     *
     * @param   value  Index
     * @return         X coordinate
     */
    getX(value) {
        let axisDataItem = this._itemMap[value];
        if (axisDataItem) {
            return this._settings.renderer.positionToCoordinate(this.indexToPosition(axisDataItem.get("index", 0)));
        }
        return NaN;
    }
    /**
     * Returns Y coordinate in pixels corresponding to specific category index.
     *
     * @param   value  Index
     * @return         Y coordinate
     */
    getY(value) {
        let axisDataItem = this._itemMap[value];
        if (axisDataItem) {
            return this._settings.renderer.positionToCoordinate(this.indexToPosition(axisDataItem.get("index", 0)));
        }
        return NaN;
    }
    /**
     * @ignore
     */
    getDataItemPositionX(dataItem, field, cellLocation, _axisLocation) {
        const category = dataItem.get(field);
        const axisDataItem = this._itemMap[category];
        if (axisDataItem) {
            return this.indexToPosition(axisDataItem.get("index", 0), cellLocation);
        }
        return NaN;
    }
    /**
     * @ignore
     */
    getDataItemCoordinateX(dataItem, field, cellLocation, _axisLocation) {
        return this._settings.renderer.positionToCoordinate(this.getDataItemPositionX(dataItem, field, cellLocation, _axisLocation));
    }
    /**
     * @ignore
     */
    getDataItemPositionY(dataItem, field, cellLocation, _axisLocation) {
        const category = dataItem.get(field);
        const axisDataItem = this._itemMap[category];
        if (axisDataItem) {
            return this.indexToPosition(axisDataItem.get("index", 0), cellLocation);
        }
        return NaN;
    }
    /**
     * @ignore
     */
    getDataItemCoordinateY(dataItem, field, cellLocation, _axisLocation) {
        return this._settings.renderer.positionToCoordinate(this.getDataItemPositionY(dataItem, field, cellLocation, _axisLocation));
    }
    /**
     * Converts category index to a relative position.
     *
     * `location` indicates relative position within category: 0 - start, 1 - end.
     *
     * If not set, will use middle (0.5) of the category.
     *
     * @param   index     Index
     * @param   location  Location
     * @return            Index
     */
    indexToPosition(index, location) {
        if (!_core_util_Type__WEBPACK_IMPORTED_MODULE_3__.isNumber(location)) {
            location = 0.5;
        }
        let len = this.dataItems.length;
        let startLocation = this.get("startLocation", 0);
        let endLocation = this.get("endLocation", 1);
        len -= startLocation;
        len -= (1 - endLocation);
        let position = (index + location - startLocation) / len;
        let dataItem = this.dataItems[index];
        if (dataItem) {
            position += dataItem.get("deltaPosition", 0);
        }
        return position;
    }
    /**
     * Returns an index of a category.
     *
     * @param   category  Category to look up
     * @return            Index
     */
    categoryToIndex(category) {
        let dataItem = this._itemMap[category];
        if (dataItem) {
            return dataItem.get("index");
        }
        return NaN;
    }
    /**
     * @ignore
     */
    dataItemToPosition(dataItem) {
        return this.indexToPosition(dataItem.get("index"));
    }
    /**
     * @ignore
     */
    roundAxisPosition(position, location) {
        position += (0.5 - location) / this.dataItems.length;
        return this.indexToPosition(this.axisPositionToIndex(position), location);
    }
    /**
     * Returns an index of the category that corresponds to specific pixel
     * position within axis.
     *
     * @param position  Position (px)
     * @return Category index
     */
    axisPositionToIndex(position) {
        let len = this.dataItems.length;
        return _core_util_Math__WEBPACK_IMPORTED_MODULE_4__.fitToRange(Math.floor(position * len), 0, len - 1); //$math.fitToRange(Math.floor((end - start) * len * position + len * start), 0, len - 1);
    }
    /**
     * Returns text to be used in an axis tooltip for specific relative position.
     *
     * @param   position  Position
     * @return            Tooltip text
     */
    getTooltipText(position, _adjustPosition) {
        //@todo number formatter + tag
        const dataItem = this.dataItems[this.axisPositionToIndex(position)];
        if (dataItem) {
            const label = dataItem.get("label");
            if (label) {
                return (0,_core_util_PopulateString__WEBPACK_IMPORTED_MODULE_5__.populateString)(label, this.get("tooltipText", ""));
            }
        }
    }
    _updateTooltipText(tooltip, position) {
        tooltip._setDataItem(this.dataItems[this.axisPositionToIndex(position)]);
        tooltip.label.text.markDirtyText();
    }
    /**
     * Returns a data item from series that is closest to the `position`.
     *
     * @param   series    Series
     * @param   position  Relative position
     * @return            Data item
     */
    getSeriesItem(series, position) {
        if (this.dataItems.length > 0) {
            let fieldName = (this.getPrivate("name") + this.get("renderer").getPrivate("letter"));
            let index = this.axisPositionToIndex(position);
            // try simple first
            let seriesDataItem = series.dataItems[index];
            let axisDataItem = this.dataItems[index];
            let category = axisDataItem.get("category");
            if (seriesDataItem && axisDataItem) {
                if (seriesDataItem.get(fieldName) === category) {
                    return seriesDataItem;
                }
            }
            // if not found, try looking
            for (let i = 0, len = series.dataItems.length; i < len; i++) {
                let dataItem = series.dataItems[i];
                if (dataItem.get(fieldName) === category) {
                    return dataItem;
                }
            }
        }
    }
    /**
     * Zooms the axis to specific `start` and `end` indexes.
     *
     * Optional `duration` specifies duration of zoom animation in milliseconds.
     *
     * @param  start     Start index
     * @param  end       End index
     * @param  duration  Duration in milliseconds
     */
    zoomToIndexes(start, end, duration) {
        let len = this.dataItems.length;
        this.zoom(start / len, end / len, duration);
    }
    zoomToCategories(startCategory, endCategory, duration) {
        this.zoomToIndexes(this.categoryToIndex(startCategory), this.categoryToIndex(endCategory) + 1, duration);
    }
    /**
     * Returns position span between start and end of a single cell in axis.
     *
     * @since 5.2.30
     * @return Position
     */
    getCellWidthPosition() {
        return this._frequency / this.dataItems.length / (this.get("end", 1) - this.get("start", 0));
    }
}
Object.defineProperty(CategoryAxis, "className", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: "CategoryAxis"
});
Object.defineProperty(CategoryAxis, "classNames", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: _Axis__WEBPACK_IMPORTED_MODULE_0__.Axis.classNames.concat([CategoryAxis.className])
});
//# sourceMappingURL=CategoryAxis.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/charts/xy/axes/Grid.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/charts/xy/axes/Grid.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Grid: () => (/* binding */ Grid)
/* harmony export */ });
/* harmony import */ var _core_render_Graphics__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../core/render/Graphics */ "./node_modules/@amcharts/amcharts5/.internal/core/render/Graphics.js");

/**
 * Creates an axis grid line.
 *
 * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/#Grid} for more info
 * @important
 */
class Grid extends _core_render_Graphics__WEBPACK_IMPORTED_MODULE_0__.Graphics {
    _beforeChanged() {
        super._beforeChanged();
        if (this.isPrivateDirty("width") || this.isPrivateDirty("height")) {
            this._clear = true;
        }
    }
}
Object.defineProperty(Grid, "className", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: "Grid"
});
Object.defineProperty(Grid, "classNames", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: _core_render_Graphics__WEBPACK_IMPORTED_MODULE_0__.Graphics.classNames.concat([Grid.className])
});
//# sourceMappingURL=Grid.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/charts/xy/axes/ValueAxis.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/charts/xy/axes/ValueAxis.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ValueAxis: () => (/* binding */ ValueAxis)
/* harmony export */ });
/* harmony import */ var _core_render_Component__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../core/render/Component */ "./node_modules/@amcharts/amcharts5/.internal/core/render/Component.js");
/* harmony import */ var _Axis__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Axis */ "./node_modules/@amcharts/amcharts5/.internal/charts/xy/axes/Axis.js");
/* harmony import */ var _core_util_Disposer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../core/util/Disposer */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Disposer.js");
/* harmony import */ var _core_util_Type__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../core/util/Type */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Type.js");
/* harmony import */ var _core_util_Array__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../../core/util/Array */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Array.js");
/* harmony import */ var _core_util_Math__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../core/util/Math */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Math.js");
/* harmony import */ var _core_util_Utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../core/util/Utils */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Utils.js");







/**
 * Creates a value axis.
 *
 * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/value-axis/} for more info
 * @important
 */
class ValueAxis extends _Axis__WEBPACK_IMPORTED_MODULE_0__.Axis {
    constructor() {
        super(...arguments);
        Object.defineProperty(this, "_dirtyExtremes", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        Object.defineProperty(this, "_dirtySelectionExtremes", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        Object.defineProperty(this, "_deltaMinMax", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 1
        });
        Object.defineProperty(this, "_minReal", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_maxReal", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_baseValue", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        Object.defineProperty(this, "_syncDp", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_minLogAdjusted", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 1
        });
    }
    /**
     * @ignore
     */
    markDirtyExtremes() {
        this._dirtyExtremes = true;
        this.markDirty();
    }
    /**
     * @ignore
     */
    markDirtySelectionExtremes() {
        this._dirtySelectionExtremes = true;
        this.markDirty();
    }
    _afterNew() {
        this._settings.themeTags = _core_util_Utils__WEBPACK_IMPORTED_MODULE_1__.mergeTags(this._settings.themeTags, ["axis"]);
        this.setPrivateRaw("name", "value");
        this.addTag("value");
        super._afterNew();
    }
    _prepareChildren() {
        super._prepareChildren();
        if (this.isDirty("syncWithAxis")) {
            let previousValue = this._prevSettings.syncWithAxis;
            if (previousValue) {
                if (this._syncDp) {
                    this._syncDp.dispose();
                }
            }
            let syncWithAxis = this.get("syncWithAxis");
            if (syncWithAxis) {
                this._syncDp = new _core_util_Disposer__WEBPACK_IMPORTED_MODULE_2__.MultiDisposer([
                    syncWithAxis.onPrivate("selectionMinFinal", () => {
                        this._dirtySelectionExtremes = true;
                    }),
                    syncWithAxis.onPrivate("selectionMaxFinal", () => {
                        this._dirtySelectionExtremes = true;
                    })
                ]);
            }
        }
        let someDirty = false;
        if (this.isDirty("min") || this.isDirty("max") || this.isDirty("maxPrecision") || this.isDirty("numberFormat")) {
            someDirty = true;
            this.ghostLabel.set("text", "");
        }
        //if (this._dirtyExtremes || this.isPrivateDirty("width") || this.isPrivateDirty("height") || this.isDirty("min") || this.isDirty("max") || this.isDirty("extraMin") || this.isDirty("extraMax") || this.isDirty("logarithmic") || this.isDirty("treatZeroAs") || this.isDirty("baseValue") || this.isDirty("strictMinMax") || this.isDirty("maxPrecision")) {
        if (this._sizeDirty || this._dirtyExtremes || this._valuesDirty || someDirty || this.isPrivateDirty("width") || this.isPrivateDirty("height") || this.isDirty("extraMin") || this.isDirty("extraMax") || this.isDirty("logarithmic") || this.isDirty("treatZeroAs") || this.isDirty("baseValue") || this.isDirty("strictMinMax") || this.isDirty("strictMinMaxSelection")) {
            this._getMinMax();
            this._dirtyExtremes = false;
        }
        if (this._dirtySelectionExtremes && !this._isPanning && this.get("autoZoom", true)) {
            this._getSelectionMinMax();
            this._dirtySelectionExtremes = false;
        }
        this._groupData();
        if (this._sizeDirty || this._valuesDirty || this.isDirty("start") || this.isDirty("end") || this.isPrivateDirty("min") || this.isPrivateDirty("selectionMax") || this.isPrivateDirty("selectionMin") || this.isPrivateDirty("max") || this.isPrivateDirty("step") || this.isPrivateDirty("width") || this.isPrivateDirty("height") || this.isDirty("logarithmic")) {
            this._handleRangeChange();
            this._prepareAxisItems();
            this._updateAxisRanges();
        }
        this._baseValue = this.baseValue();
    }
    _groupData() {
    }
    _formatText(value) {
        const numberFormat = this.get("numberFormat");
        const formatter = this.getNumberFormatter();
        let text = "";
        if (numberFormat) {
            text = formatter.format(value, numberFormat);
        }
        else {
            text = formatter.format(value, undefined, this.getPrivate("stepDecimalPlaces"));
        }
        return text;
    }
    _prepareAxisItems() {
        const min = this.getPrivate("min");
        const max = this.getPrivate("max");
        if (_core_util_Type__WEBPACK_IMPORTED_MODULE_3__.isNumber(min) && _core_util_Type__WEBPACK_IMPORTED_MODULE_3__.isNumber(max)) {
            const logarithmic = this.get("logarithmic");
            const step = this.getPrivate("step");
            const selectionMin = this.getPrivate("selectionMin");
            const selectionMax = this.getPrivate("selectionMax") + step;
            let value = selectionMin - step;
            let differencePower = 1;
            let minLog = min;
            if (logarithmic) {
                value = this._minLogAdjusted;
                if (value < selectionMin) {
                    while (value < selectionMin) {
                        value += step;
                    }
                }
                minLog = value;
                if (minLog <= 0) {
                    minLog = 1;
                    if (step < 1) {
                        minLog = step;
                    }
                }
                differencePower = Math.log(selectionMax - step) * Math.LOG10E - Math.log(minLog) * Math.LOG10E;
                if (differencePower > 2) {
                    value = Math.pow(10, Math.log(minLog) * Math.LOG10E - 5);
                }
            }
            /// minor grid
            const renderer = this.get("renderer");
            const minorLabelsEnabled = renderer.get("minorLabelsEnabled");
            const minorGridEnabled = renderer.get("minorGridEnabled", minorLabelsEnabled);
            let stepPower = Math.pow(10, Math.floor(Math.log(Math.abs(step)) * Math.LOG10E));
            const stepAdjusted = Math.round(step / stepPower);
            let minorGridCount = 2;
            if (_core_util_Math__WEBPACK_IMPORTED_MODULE_4__.round(stepAdjusted / 5, 10) % 1 == 0) {
                minorGridCount = 5;
            }
            if (_core_util_Math__WEBPACK_IMPORTED_MODULE_4__.round(stepAdjusted / 10, 10) % 1 == 0) {
                minorGridCount = 10;
            }
            let minorStep = step / minorGridCount;
            // end of minor grid
            let i = 0;
            let m = 0;
            let previous = -Infinity;
            while (value < selectionMax) {
                let dataItem;
                if (this.dataItems.length < i + 1) {
                    dataItem = new _core_render_Component__WEBPACK_IMPORTED_MODULE_5__.DataItem(this, undefined, {});
                    this._dataItems.push(dataItem);
                    this.processDataItem(dataItem);
                }
                else {
                    dataItem = this.dataItems[i];
                }
                this._createAssets(dataItem, []);
                this._toggleDataItem(dataItem, true);
                dataItem.setRaw("value", value);
                const label = dataItem.get("label");
                if (label) {
                    label.set("text", this._formatText(value));
                }
                this._prepareDataItem(dataItem);
                let nextValue = value;
                if (!logarithmic) {
                    nextValue += step;
                }
                else {
                    if (differencePower > 2) {
                        nextValue = Math.pow(10, Math.log(minLog) * Math.LOG10E + i - 5);
                    }
                    else {
                        nextValue += step;
                    }
                }
                // minor grid
                if (minorGridEnabled) {
                    let minorValue = value + minorStep;
                    if (logarithmic) {
                        if (differencePower > 2) {
                            let minorMinMaxStep = this._adjustMinMax(value, nextValue, 10);
                            minorStep = minorMinMaxStep.step;
                        }
                        minorValue = value + minorStep;
                    }
                    while (minorValue < nextValue - step * 0.00000000001) {
                        let minorDataItem;
                        if (this.minorDataItems.length < m + 1) {
                            minorDataItem = new _core_render_Component__WEBPACK_IMPORTED_MODULE_5__.DataItem(this, undefined, {});
                            this.minorDataItems.push(minorDataItem);
                            this.processDataItem(minorDataItem);
                        }
                        else {
                            minorDataItem = this.minorDataItems[m];
                        }
                        this._createAssets(minorDataItem, ["minor"], true);
                        this._toggleDataItem(minorDataItem, true);
                        minorDataItem.setRaw("value", minorValue);
                        const minorLabel = minorDataItem.get("label");
                        if (minorLabel) {
                            if (minorLabelsEnabled) {
                                minorLabel.set("text", this._formatText(minorValue));
                            }
                            else {
                                minorLabel.setPrivate("visible", false);
                            }
                        }
                        this._prepareDataItem(minorDataItem);
                        minorValue += minorStep;
                        m++;
                    }
                }
                value = nextValue;
                if (previous == value) {
                    break;
                }
                let stepPower = Math.pow(10, Math.floor(Math.log(Math.abs(step)) * Math.LOG10E));
                if (stepPower < 1) {
                    // exponent is less then 1 too. Count decimals of exponent
                    let decCount = Math.round(Math.abs(Math.log(Math.abs(stepPower)) * Math.LOG10E)) + 2;
                    // round value to avoid floating point issues
                    value = _core_util_Math__WEBPACK_IMPORTED_MODULE_4__.round(value, decCount);
                }
                i++;
                previous = value;
            }
            for (let j = i; j < this.dataItems.length; j++) {
                this._toggleDataItem(this.dataItems[j], false);
            }
            for (let j = m; j < this.minorDataItems.length; j++) {
                this._toggleDataItem(this.minorDataItems[j], false);
            }
            _core_util_Array__WEBPACK_IMPORTED_MODULE_6__.each(this.series, (series) => {
                if (series.inited) {
                    series._markDirtyAxes();
                }
            });
            this._updateGhost();
        }
    }
    _prepareDataItem(dataItem, count) {
        let renderer = this.get("renderer");
        let value = dataItem.get("value");
        let endValue = dataItem.get("endValue");
        let position = this.valueToPosition(value);
        let endPosition = position;
        let fillEndPosition = this.valueToPosition(value + this.getPrivate("step"));
        if (_core_util_Type__WEBPACK_IMPORTED_MODULE_3__.isNumber(endValue)) {
            endPosition = this.valueToPosition(endValue);
            fillEndPosition = endPosition;
        }
        if (dataItem.get("isRange")) {
            if (endValue == null) {
                fillEndPosition = position;
            }
        }
        let labelEndPosition = endPosition;
        let labelEndValue = dataItem.get("labelEndValue");
        if (labelEndValue != null) {
            labelEndPosition = this.valueToPosition(labelEndValue);
        }
        renderer.updateLabel(dataItem.get("label"), position, labelEndPosition, count);
        const grid = dataItem.get("grid");
        renderer.updateGrid(grid, position, endPosition);
        if (grid) {
            if (value == this.get("baseValue", 0)) {
                grid.addTag("base");
                grid._applyThemes();
            }
            else if (grid.hasTag("base")) {
                grid.removeTag("base");
                grid._applyThemes();
            }
        }
        renderer.updateTick(dataItem.get("tick"), position, labelEndPosition, count);
        renderer.updateFill(dataItem.get("axisFill"), position, fillEndPosition);
        this._processBullet(dataItem);
        renderer.updateBullet(dataItem.get("bullet"), position, endPosition);
        if (!dataItem.get("isRange")) {
            const fillRule = this.get("fillRule");
            if (fillRule) {
                fillRule(dataItem);
            }
        }
    }
    _handleRangeChange() {
        let selectionMin = this.positionToValue(this.get("start", 0));
        let selectionMax = this.positionToValue(this.get("end", 1));
        const gridCount = this.get("renderer").gridCount();
        let minMaxStep = this._adjustMinMax(selectionMin, selectionMax, gridCount, true);
        let stepDecimalPlaces = _core_util_Utils__WEBPACK_IMPORTED_MODULE_1__.decimalPlaces(minMaxStep.step);
        this.setPrivateRaw("stepDecimalPlaces", stepDecimalPlaces);
        selectionMin = _core_util_Math__WEBPACK_IMPORTED_MODULE_4__.round(selectionMin, stepDecimalPlaces);
        selectionMax = _core_util_Math__WEBPACK_IMPORTED_MODULE_4__.round(selectionMax, stepDecimalPlaces);
        minMaxStep = this._adjustMinMax(selectionMin, selectionMax, gridCount, true);
        let step = minMaxStep.step;
        selectionMin = minMaxStep.min;
        selectionMax = minMaxStep.max;
        if (this.getPrivate("selectionMin") !== selectionMin || this.getPrivate("selectionMax") !== selectionMax || this.getPrivate("step") !== step) {
            // do not change to setPrivate, will cause SO
            this.setPrivateRaw("selectionMin", selectionMin);
            this.setPrivateRaw("selectionMax", selectionMax);
            this.setPrivateRaw("step", step);
        }
    }
    /**
     * Converts a relative position to a corresponding numeric value from axis
     * scale.
     *
     * @param   position  Relative position
     * @return            Value
     */
    positionToValue(position) {
        const min = this.getPrivate("min");
        const max = this.getPrivate("max");
        if (!this.get("logarithmic")) {
            return position * (max - min) + min;
        }
        else {
            return Math.pow(Math.E, (position * ((Math.log(max) * Math.LOG10E - Math.log(min) * Math.LOG10E)) + Math.log(min) * Math.LOG10E) / Math.LOG10E);
        }
    }
    /**
     * Convers value to a relative position on axis.
     *
     * @param   value  Value
     * @return         Relative position
     */
    valueToPosition(value) {
        const min = this.getPrivate("min");
        const max = this.getPrivate("max");
        if (!this.get("logarithmic")) {
            return (value - min) / (max - min);
        }
        else {
            if (value <= 0) {
                let treatZeroAs = this.get("treatZeroAs");
                if (_core_util_Type__WEBPACK_IMPORTED_MODULE_3__.isNumber(treatZeroAs)) {
                    value = treatZeroAs;
                }
            }
            return (Math.log(value) * Math.LOG10E - Math.log(min) * Math.LOG10E) / ((Math.log(max) * Math.LOG10E - Math.log(min) * Math.LOG10E));
        }
    }
    /**
     * @ignore
     */
    valueToFinalPosition(value) {
        const min = this.getPrivate("minFinal");
        const max = this.getPrivate("maxFinal");
        if (!this.get("logarithmic")) {
            return (value - min) / (max - min);
        }
        else {
            if (value <= 0) {
                let treatZeroAs = this.get("treatZeroAs");
                if (_core_util_Type__WEBPACK_IMPORTED_MODULE_3__.isNumber(treatZeroAs)) {
                    value = treatZeroAs;
                }
            }
            return (Math.log(value) * Math.LOG10E - Math.log(min) * Math.LOG10E) / ((Math.log(max) * Math.LOG10E - Math.log(min) * Math.LOG10E));
        }
    }
    /**
     * Returns X coordinate in pixels corresponding to specific value.
     *
     * @param   value     Numeric value
     * @param   location  Location
     * @param   baseValue Base value
     * @return            X coordinate
     */
    getX(value, location, baseValue) {
        value = baseValue + (value - baseValue) * location;
        const position = this.valueToPosition(value);
        return this._settings.renderer.positionToCoordinate(position);
    }
    /**
     * Returns X coordinate in pixels corresponding to specific value.
     *
     * @param   value     Numeric value
     * @param   location  Location
     * @param   baseValue Base value
     * @return            X coordinate
     */
    getY(value, location, baseValue) {
        value = baseValue + (value - baseValue) * location;
        const position = this.valueToPosition(value);
        return this._settings.renderer.positionToCoordinate(position);
    }
    /**
     * @ignore
     */
    getDataItemCoordinateX(dataItem, field, _cellLocation, axisLocation) {
        return this._settings.renderer.positionToCoordinate(this.getDataItemPositionX(dataItem, field, _cellLocation, axisLocation));
    }
    /**
     * @ignore
     */
    getDataItemPositionX(dataItem, field, _cellLocation, axisLocation) {
        let value = dataItem.get(field);
        const stackToItem = dataItem.get("stackToItemX");
        if (stackToItem) {
            const series = dataItem.component;
            value = value * axisLocation + series.getStackedXValueWorking(dataItem, field);
        }
        else {
            value = this._baseValue + (value - this._baseValue) * axisLocation;
        }
        return this.valueToPosition(value);
    }
    /**
     * @ignore
     */
    getDataItemCoordinateY(dataItem, field, _cellLocation, axisLocation) {
        return this._settings.renderer.positionToCoordinate(this.getDataItemPositionY(dataItem, field, _cellLocation, axisLocation));
    }
    /**
     * @ignore
     */
    getDataItemPositionY(dataItem, field, _cellLocation, axisLocation) {
        let value = dataItem.get(field);
        const stackToItem = dataItem.get("stackToItemY");
        if (stackToItem) {
            const series = dataItem.component;
            value = value * axisLocation + series.getStackedYValueWorking(dataItem, field);
        }
        else {
            value = this._baseValue + (value - this._baseValue) * axisLocation;
        }
        return this.valueToPosition(value);
    }
    /**
     * Returns relative position of axis' `baseValue`.
     *
     * @return  Base value position
     */
    basePosition() {
        return this.valueToPosition(this.baseValue());
    }
    /**
     * Base value of the [[ValueAxis]], which determines positive and negative
     * values.
     *
     * @return Base value
     */
    baseValue() {
        const min = Math.min(this.getPrivate("minFinal", -Infinity), this.getPrivate("selectionMin", -Infinity));
        const max = Math.max(this.getPrivate("maxFinal", Infinity), this.getPrivate("selectionMax", Infinity));
        let baseValue = this.get("baseValue", 0);
        if (baseValue < min) {
            baseValue = min;
        }
        if (baseValue > max) {
            baseValue = max;
        }
        return baseValue;
    }
    /**
     * @ignore
     */
    cellEndValue(value) {
        return value;
    }
    fixSmallStep(step) {
        // happens because of floating point error
        if (1 + step === 1) {
            step *= 2;
            return this.fixSmallStep(step);
        }
        return step;
    }
    _fixMin(min) {
        return min;
    }
    _fixMax(max) {
        return max;
    }
    _calculateTotals() {
        if (this.get("calculateTotals")) {
            let series = this.series[0];
            if (series) {
                let startIndex = series.startIndex();
                if (series.dataItems.length > 0) {
                    if (startIndex > 0) {
                        startIndex--;
                    }
                    let endIndex = series.endIndex();
                    if (endIndex < series.dataItems.length) {
                        endIndex++;
                    }
                    let field;
                    let vc;
                    if (series.get("yAxis") == this) {
                        field = "valueY";
                        vc = "vcy";
                    }
                    else if (series.get("xAxis") == this) {
                        field = "valueX";
                        vc = "vcx";
                    }
                    let fieldWorking = field + "Working";
                    if (field) {
                        for (let i = startIndex; i < endIndex; i++) {
                            let sum = 0;
                            let total = 0;
                            _core_util_Array__WEBPACK_IMPORTED_MODULE_6__.each(this.series, (series) => {
                                if (!series.get("excludeFromTotal")) {
                                    let dataItem = series.dataItems[i];
                                    if (dataItem) {
                                        let value = dataItem.get(fieldWorking) * series.get(vc);
                                        if (!_core_util_Type__WEBPACK_IMPORTED_MODULE_3__.isNaN(value)) {
                                            sum += value;
                                            total += Math.abs(value);
                                        }
                                    }
                                }
                            });
                            _core_util_Array__WEBPACK_IMPORTED_MODULE_6__.each(this.series, (series) => {
                                if (!series.get("excludeFromTotal")) {
                                    let dataItem = series.dataItems[i];
                                    if (dataItem) {
                                        let value = dataItem.get(fieldWorking) * series.get(vc);
                                        if (!_core_util_Type__WEBPACK_IMPORTED_MODULE_3__.isNaN(value)) {
                                            dataItem.set((field + "Total"), total);
                                            dataItem.set((field + "Sum"), sum);
                                            dataItem.set((field + "TotalPercent"), value / total * 100);
                                        }
                                    }
                                }
                            });
                        }
                    }
                }
            }
        }
    }
    _getSelectionMinMax() {
        const min = this.getPrivate("minFinal");
        const max = this.getPrivate("maxFinal");
        const minDefined = this.get("min");
        const maxDefined = this.get("max");
        let extraMin = this.get("extraMin", 0);
        let extraMax = this.get("extraMax", 0);
        if (this.get("logarithmic")) {
            if (this.get("extraMin") == null) {
                extraMin = 0.1;
            }
            if (this.get("extraMax") == null) {
                extraMax = 0.2;
            }
        }
        const gridCount = this.get("renderer").gridCount();
        const selectionStrictMinMax = this.get("strictMinMaxSelection");
        const strictMinMax = this.get("strictMinMax");
        if (_core_util_Type__WEBPACK_IMPORTED_MODULE_3__.isNumber(min) && _core_util_Type__WEBPACK_IMPORTED_MODULE_3__.isNumber(max)) {
            let selectionMin = max;
            let selectionMax = min;
            _core_util_Array__WEBPACK_IMPORTED_MODULE_6__.each(this.series, (series) => {
                if (!series.get("ignoreMinMax")) {
                    let seriesMin;
                    let seriesMax;
                    const outOfSelection = series.getPrivate("outOfSelection");
                    if (series.get("xAxis") === this) {
                        if (!outOfSelection) {
                            let minX = series.getPrivate("minX");
                            let maxX = series.getPrivate("maxX");
                            // solves #90085
                            if (series.startIndex() != 0 || series.endIndex() != series.dataItems.length) {
                                minX = undefined;
                                maxX = undefined;
                            }
                            seriesMin = series.getPrivate("selectionMinX", minX);
                            seriesMax = series.getPrivate("selectionMaxX", maxX);
                        }
                    }
                    else if (series.get("yAxis") === this) {
                        if (!outOfSelection) {
                            let minY = series.getPrivate("minY");
                            let maxY = series.getPrivate("maxY");
                            // solves #90085
                            if (series.startIndex() != 0 || series.endIndex() != series.dataItems.length) {
                                minY = undefined;
                                maxY = undefined;
                            }
                            seriesMin = series.getPrivate("selectionMinY", minY);
                            seriesMax = series.getPrivate("selectionMaxY", maxY);
                        }
                    }
                    if (!series.isHidden() && !series.isShowing()) {
                        if (_core_util_Type__WEBPACK_IMPORTED_MODULE_3__.isNumber(seriesMin)) {
                            selectionMin = Math.min(selectionMin, seriesMin);
                        }
                        if (_core_util_Type__WEBPACK_IMPORTED_MODULE_3__.isNumber(seriesMax)) {
                            selectionMax = Math.max(selectionMax, seriesMax);
                        }
                    }
                }
            });
            this.axisRanges.each((range) => {
                if (range.get("affectsMinMax")) {
                    let value = range.get("value");
                    if (value != null) {
                        selectionMin = Math.min(selectionMin, value);
                        selectionMax = Math.max(selectionMax, value);
                    }
                    value = range.get("endValue");
                    if (value != null) {
                        selectionMin = Math.min(selectionMin, value);
                        selectionMax = Math.max(selectionMax, value);
                    }
                }
            });
            if (selectionMin > selectionMax) {
                [selectionMin, selectionMax] = [selectionMax, selectionMin];
            }
            if (_core_util_Type__WEBPACK_IMPORTED_MODULE_3__.isNumber(minDefined)) {
                if (strictMinMax) {
                    selectionMin = minDefined;
                }
                else {
                    selectionMin = min;
                }
            }
            else if (strictMinMax) {
                if (_core_util_Type__WEBPACK_IMPORTED_MODULE_3__.isNumber(this._minReal)) {
                    selectionMin = this._minReal;
                }
            }
            if (_core_util_Type__WEBPACK_IMPORTED_MODULE_3__.isNumber(maxDefined)) {
                if (strictMinMax) {
                    selectionMax = maxDefined;
                }
                else {
                    selectionMax = max;
                }
            }
            else if (strictMinMax) {
                if (_core_util_Type__WEBPACK_IMPORTED_MODULE_3__.isNumber(this._maxReal)) {
                    selectionMax = this._maxReal;
                }
            }
            if (selectionMin === selectionMax) {
                selectionMin -= this._deltaMinMax;
                selectionMax += this._deltaMinMax;
                let minMaxStep2 = this._adjustMinMax(selectionMin, selectionMax, gridCount, strictMinMax);
                selectionMin = minMaxStep2.min;
                selectionMax = minMaxStep2.max;
            }
            let selectionMinReal = selectionMin;
            let selectionMaxReal = selectionMax;
            selectionMin -= (selectionMax - selectionMin) * extraMin;
            selectionMax += (selectionMax - selectionMin) * extraMax;
            let minMaxStep = this._adjustMinMax(selectionMin, selectionMax, gridCount);
            selectionMin = minMaxStep.min;
            selectionMax = minMaxStep.max;
            selectionMin = _core_util_Math__WEBPACK_IMPORTED_MODULE_4__.fitToRange(selectionMin, min, max);
            selectionMax = _core_util_Math__WEBPACK_IMPORTED_MODULE_4__.fitToRange(selectionMax, min, max);
            // do it for the second time !important			
            minMaxStep = this._adjustMinMax(selectionMin, selectionMax, gridCount, true);
            if (!strictMinMax) {
                selectionMin = minMaxStep.min;
                selectionMax = minMaxStep.max;
            }
            const syncWithAxis = this.get("syncWithAxis");
            if (syncWithAxis) {
                minMaxStep = this._syncAxes(selectionMin, selectionMax, minMaxStep.step, syncWithAxis.getPrivate("selectionMinFinal", syncWithAxis.getPrivate("minFinal", 0)), syncWithAxis.getPrivate("selectionMaxFinal", syncWithAxis.getPrivate("maxFinal", 1)), syncWithAxis.getPrivate("selectionStepFinal", syncWithAxis.getPrivate("step", 1)));
                selectionMin = minMaxStep.min;
                selectionMax = minMaxStep.max;
            }
            if (strictMinMax) {
                if (_core_util_Type__WEBPACK_IMPORTED_MODULE_3__.isNumber(minDefined)) {
                    selectionMin = Math.max(selectionMin, minDefined);
                }
                if (_core_util_Type__WEBPACK_IMPORTED_MODULE_3__.isNumber(maxDefined)) {
                    selectionMax = Math.min(selectionMax, maxDefined);
                }
            }
            if (selectionStrictMinMax) {
                selectionMin = selectionMinReal - (selectionMax - selectionMin) * extraMin;
                selectionMax = selectionMaxReal + (selectionMax - selectionMin) * extraMax;
            }
            if (this.get("logarithmic")) {
                if (selectionMin <= 0) {
                    selectionMin = selectionMinReal * (1 - Math.min(extraMin, 0.99));
                }
                if (selectionMin < min) {
                    selectionMin = min;
                }
                if (selectionMax > max) {
                    selectionMax = max;
                }
            }
            let len = Math.min(20, Math.ceil(Math.log(this.getPrivate("maxZoomFactor", 100) + 1) / Math.LN10) + 2);
            let start = _core_util_Math__WEBPACK_IMPORTED_MODULE_4__.round(this.valueToFinalPosition(selectionMin), len);
            let end = _core_util_Math__WEBPACK_IMPORTED_MODULE_4__.round(this.valueToFinalPosition(selectionMax), len);
            this.setPrivateRaw("selectionMinFinal", selectionMin);
            this.setPrivateRaw("selectionMaxFinal", selectionMax);
            this.setPrivateRaw("selectionStepFinal", minMaxStep.step);
            this.zoom(start, end);
        }
    }
    _getMinMax() {
        let minDefined = this.get("min");
        let maxDefined = this.get("max");
        let min = Infinity;
        let max = -Infinity;
        let extraMin = this.get("extraMin", 0);
        let extraMax = this.get("extraMax", 0);
        if (this.get("logarithmic")) {
            if (this.get("extraMin") == null) {
                extraMin = 0.1;
            }
            if (this.get("extraMax") == null) {
                extraMax = 0.2;
            }
        }
        let minDiff = Infinity;
        _core_util_Array__WEBPACK_IMPORTED_MODULE_6__.each(this.series, (series) => {
            if (!series.get("ignoreMinMax")) {
                let seriesMin;
                let seriesMax;
                if (series.get("xAxis") === this) {
                    seriesMin = series.getPrivate("minX");
                    seriesMax = series.getPrivate("maxX");
                }
                else if (series.get("yAxis") === this) {
                    seriesMin = series.getPrivate("minY");
                    seriesMax = series.getPrivate("maxY");
                }
                if (_core_util_Type__WEBPACK_IMPORTED_MODULE_3__.isNumber(seriesMin) && _core_util_Type__WEBPACK_IMPORTED_MODULE_3__.isNumber(seriesMax)) {
                    min = Math.min(min, seriesMin);
                    max = Math.max(max, seriesMax);
                    let diff = seriesMax - seriesMin;
                    if (diff <= 0) {
                        diff = Math.abs(seriesMax / 100);
                    }
                    if (diff < minDiff) {
                        minDiff = diff;
                    }
                }
            }
        });
        this.axisRanges.each((range) => {
            if (range.get("affectsMinMax")) {
                let value = range.get("value");
                if (value != null) {
                    min = Math.min(min, value);
                    max = Math.max(max, value);
                }
                value = range.get("endValue");
                if (value != null) {
                    min = Math.min(min, value);
                    max = Math.max(max, value);
                }
            }
        });
        if (this.get("logarithmic")) {
            let treatZeroAs = this.get("treatZeroAs");
            if (_core_util_Type__WEBPACK_IMPORTED_MODULE_3__.isNumber(treatZeroAs)) {
                if (min <= 0) {
                    min = treatZeroAs;
                }
            }
            if (min <= 0) {
                new Error("Logarithmic value axis can not have values <= 0.");
            }
        }
        if (min === 0 && max === 0) {
            max = 0.9;
            min = -0.9;
        }
        if (_core_util_Type__WEBPACK_IMPORTED_MODULE_3__.isNumber(minDefined)) {
            min = minDefined;
        }
        if (_core_util_Type__WEBPACK_IMPORTED_MODULE_3__.isNumber(maxDefined)) {
            max = maxDefined;
        }
        // meaning no min/max found on series/ranges and no min/max was defined
        if (min === Infinity || max === -Infinity) {
            this.setPrivate("minFinal", undefined);
            this.setPrivate("maxFinal", undefined);
            return;
        }
        const initialMin = min;
        const initialMax = max;
        // adapter
        let minAdapted = this.adapters.fold("min", min);
        let maxAdapted = this.adapters.fold("max", max);
        if (_core_util_Type__WEBPACK_IMPORTED_MODULE_3__.isNumber(minAdapted)) {
            min = minAdapted;
        }
        if (_core_util_Type__WEBPACK_IMPORTED_MODULE_3__.isNumber(maxAdapted)) {
            max = maxAdapted;
        }
        // DateAxis does some magic here
        min = this._fixMin(min);
        max = this._fixMax(max);
        // this happens if starLocation and endLocation are 0.5 and DateAxis has only one date		
        if (max - min <= 1 / Math.pow(10, 15)) {
            if (max - min !== 0) {
                this._deltaMinMax = (max - min) / 2;
            }
            else {
                this._getDelta(max);
            }
            min -= this._deltaMinMax;
            max += this._deltaMinMax;
        }
        // add extras
        min -= (max - min) * extraMin;
        max += (max - min) * extraMax;
        if (this.get("logarithmic")) {
            // don't let min go below 0 if real min is >= 0
            if (min < 0 && initialMin >= 0) {
                min = 0;
            }
            // don't let max go above 0 if real max is <= 0
            if (max > 0 && initialMax <= 0) {
                max = 0;
            }
        }
        this._minReal = min;
        this._maxReal = max;
        let strictMinMax = this.get("strictMinMax");
        let strictMinMaxSelection = this.get("strictMinMaxSelection", false);
        if (strictMinMaxSelection) {
            strictMinMax = strictMinMaxSelection;
        }
        let strict = strictMinMax;
        if (_core_util_Type__WEBPACK_IMPORTED_MODULE_3__.isNumber(maxDefined)) {
            strict = true;
        }
        let gridCount = this.get("renderer").gridCount();
        let minMaxStep = this._adjustMinMax(min, max, gridCount, strict);
        min = minMaxStep.min;
        max = minMaxStep.max;
        // do it for the second time with strict true (importat!)
        minMaxStep = this._adjustMinMax(min, max, gridCount, true);
        min = minMaxStep.min;
        max = minMaxStep.max;
        // return min max if strict
        if (strictMinMax) {
            if (_core_util_Type__WEBPACK_IMPORTED_MODULE_3__.isNumber(minDefined)) {
                min = minDefined;
            }
            else {
                min = this._minReal;
            }
            if (_core_util_Type__WEBPACK_IMPORTED_MODULE_3__.isNumber(maxDefined)) {
                max = maxDefined;
            }
            else {
                max = this._maxReal;
            }
            if (max - min <= 0.00000001) {
                min -= this._deltaMinMax;
                max += this._deltaMinMax;
            }
            min -= (max - min) * extraMin;
            max += (max - min) * extraMax;
        }
        minAdapted = this.adapters.fold("min", min);
        maxAdapted = this.adapters.fold("max", max);
        if (_core_util_Type__WEBPACK_IMPORTED_MODULE_3__.isNumber(minAdapted)) {
            min = minAdapted;
        }
        if (_core_util_Type__WEBPACK_IMPORTED_MODULE_3__.isNumber(maxAdapted)) {
            max = maxAdapted;
        }
        if (minDiff == Infinity) {
            minDiff = (max - min);
        }
        // this is to avoid floating point number error
        let decCount = Math.round(Math.abs(Math.log(Math.abs(max - min)) * Math.LOG10E)) + 5;
        min = _core_util_Math__WEBPACK_IMPORTED_MODULE_4__.round(min, decCount);
        max = _core_util_Math__WEBPACK_IMPORTED_MODULE_4__.round(max, decCount);
        const syncWithAxis = this.get("syncWithAxis");
        if (syncWithAxis) {
            minMaxStep = this._syncAxes(min, max, minMaxStep.step, syncWithAxis.getPrivate("minFinal", syncWithAxis.getPrivate("min", 0)), syncWithAxis.getPrivate("maxFinal", syncWithAxis.getPrivate("max", 1)), syncWithAxis.getPrivate("step", 1));
            min = minMaxStep.min;
            max = minMaxStep.max;
        }
        this.setPrivateRaw("maxZoomFactor", Math.max(1, Math.ceil((max - min) / minDiff * this.get("maxZoomFactor", 100))));
        this._fixZoomFactor();
        if (this.get("logarithmic")) {
            this._minLogAdjusted = min;
            min = this._minReal;
            max = this._maxReal;
            if (min <= 0) {
                min = initialMin * (1 - Math.min(extraMin, 0.99));
            }
        }
        if (_core_util_Type__WEBPACK_IMPORTED_MODULE_3__.isNumber(min) && _core_util_Type__WEBPACK_IMPORTED_MODULE_3__.isNumber(max)) {
            if (this.getPrivate("minFinal") !== min || this.getPrivate("maxFinal") !== max) {
                this.setPrivate("minFinal", min);
                this.setPrivate("maxFinal", max);
                this._saveMinMax(min, max);
                const duration = this.get("interpolationDuration", 0);
                const easing = this.get("interpolationEasing");
                this.animatePrivate({ key: "min", to: min, duration, easing });
                this.animatePrivate({ key: "max", to: max, duration, easing });
            }
        }
    }
    _fixZoomFactor() {
    }
    _getDelta(max) {
        // the number by which we need to raise 10 to get difference
        let exponent = Math.log(Math.abs(max)) * Math.LOG10E;
        // here we find a number which is power of 10 and has the same count of numbers as difference has
        let power = Math.pow(10, Math.floor(exponent));
        // reduce this number by 10 times
        power = power / 10;
        this._deltaMinMax = power;
    }
    _saveMinMax(_min, _max) {
    }
    _adjustMinMax(min, max, gridCount, strictMode) {
        // will fail if 0
        if (gridCount <= 1) {
            gridCount = 1;
        }
        gridCount = Math.round(gridCount);
        let initialMin = min;
        let initialMax = max;
        let difference = max - min;
        // in case min and max is the same, use max
        if (difference === 0) {
            difference = Math.abs(max);
        }
        // the number by which we need to raise 10 to get difference
        let exponent = Math.log(Math.abs(difference)) * Math.LOG10E;
        // here we find a number which is power of 10 and has the same count of numbers as difference has
        let power = Math.pow(10, Math.floor(exponent));
        // reduce this number by 10 times
        power = power / 10;
        let extra = power;
        if (strictMode) {
            extra = 0;
        }
        // round down min
        if (strictMode) {
            min = Math.floor(min / power) * power;
            // round up max
            max = Math.ceil(max / power) * power;
        }
        else {
            min = Math.ceil(min / power) * power - extra;
            // round up max
            max = Math.floor(max / power) * power + extra;
        }
        // don't let min go below 0 if real min is >= 0
        if (min < 0 && initialMin >= 0) {
            min = 0;
        }
        // don't let max go above 0 if real max is <= 0
        if (max > 0 && initialMax <= 0) {
            max = 0;
        }
        exponent = Math.log(Math.abs(difference)) * Math.LOG10E;
        power = Math.pow(10, Math.floor(exponent));
        power = power / 100; // used to be 10 in v4, but this caused issue that there could be limited number of grids with even very small minGridDistance
        // approximate difference between two grid lines
        let step = Math.ceil((difference / gridCount) / power) * power;
        let stepPower = Math.pow(10, Math.floor(Math.log(Math.abs(step)) * Math.LOG10E));
        // the step should divide by  2, 5, and 10.
        let stepDivisor = Math.ceil(step / stepPower); // number 0 - 10
        if (stepDivisor > 5) {
            stepDivisor = 10;
        }
        else if (stepDivisor <= 5 && stepDivisor > 2) {
            stepDivisor = 5;
        }
        // now get real step
        step = Math.ceil(step / (stepPower * stepDivisor)) * stepPower * stepDivisor;
        let maxPrecision = this.get("maxPrecision");
        if (_core_util_Type__WEBPACK_IMPORTED_MODULE_3__.isNumber(maxPrecision)) {
            let ceiledStep = _core_util_Math__WEBPACK_IMPORTED_MODULE_4__.ceil(step, maxPrecision);
            if (maxPrecision < Number.MAX_VALUE && step !== ceiledStep) {
                step = ceiledStep;
            }
        }
        let decCount = 0;
        // in case numbers are smaller than 1
        if (stepPower < 1) {
            // exponent is less then 1 too. Count decimals of exponent
            decCount = Math.round(Math.abs(Math.log(Math.abs(stepPower)) * Math.LOG10E)) + 1;
            // round step
            step = _core_util_Math__WEBPACK_IMPORTED_MODULE_4__.round(step, decCount);
        }
        // final min and max
        let minCount = Math.floor(min / step);
        min = _core_util_Math__WEBPACK_IMPORTED_MODULE_4__.round(step * minCount, decCount);
        let maxCount;
        if (!strictMode) {
            maxCount = Math.ceil(max / step);
        }
        else {
            maxCount = Math.floor(max / step);
        }
        if (maxCount === minCount) {
            maxCount++;
        }
        max = _core_util_Math__WEBPACK_IMPORTED_MODULE_4__.round(step * maxCount, decCount);
        if (max < initialMax) {
            max = max + step;
        }
        if (min > initialMin) {
            min = min - step;
        }
        step = this.fixSmallStep(step);
        return { min: min, max: max, step: step };
    }
    /**
     * Returns text to be used in an axis tooltip for specific relative position.
     *
     * @param   position  Position
     * @return            Tooltip text
     */
    getTooltipText(position, _adjustPosition) {
        const numberFormat = this.get("tooltipNumberFormat", this.get("numberFormat"));
        const formatter = this.getNumberFormatter();
        const extraDecimals = this.get("extraTooltipPrecision", 0);
        const decimals = this.getPrivate("stepDecimalPlaces", 0) + extraDecimals;
        const value = _core_util_Math__WEBPACK_IMPORTED_MODULE_4__.round(this.positionToValue(position), decimals);
        if (numberFormat) {
            return formatter.format(value, numberFormat);
        }
        else {
            return formatter.format(value, undefined, decimals);
        }
    }
    /**
     * Returns a data item from series that is closest to the `position`.
     *
     * @param   series    Series
     * @param   position  Relative position
     * @return            Data item
     */
    getSeriesItem(series, position) {
        let fieldName = (this.getPrivate("name") + this.get("renderer").getPrivate("letter"));
        let value = this.positionToValue(position);
        let index = undefined;
        let oldDiff;
        _core_util_Array__WEBPACK_IMPORTED_MODULE_6__.each(series.dataItems, (dataItem, i) => {
            const diff = Math.abs(dataItem.get(fieldName) - value);
            if (index === undefined || diff < oldDiff) {
                index = i;
                oldDiff = diff;
            }
        });
        if (index != null) {
            return series.dataItems[index];
        }
    }
    /**
     * Zooms the axis to specific `start` and `end` values.
     *
     * Optional `duration` specifies duration of zoom animation in milliseconds.
     *
     * @param  start     Start value
     * @param  end       End value
     * @param  duration  Duration in milliseconds
     */
    zoomToValues(start, end, duration) {
        const min = this.getPrivate("minFinal", 0);
        const max = this.getPrivate("maxFinal", 0);
        if (this.getPrivate("min") != null && this.getPrivate("max") != null) {
            this.zoom((start - min) / (max - min), (end - min) / (max - min), duration);
        }
    }
    /**
     * Syncs with a target axis.
     *
     * @param  min  Min
     * @param  max  Max
     * @param  step Step
     */
    _syncAxes(min, max, step, syncMin, syncMax, syncStep) {
        let axis = this.get("syncWithAxis");
        if (axis) {
            let count = Math.round(syncMax - syncMin) / syncStep;
            let currentCount = Math.round((max - min) / step);
            let gridCount = this.get("renderer").gridCount();
            if (_core_util_Type__WEBPACK_IMPORTED_MODULE_3__.isNumber(count) && _core_util_Type__WEBPACK_IMPORTED_MODULE_3__.isNumber(currentCount)) {
                let synced = false;
                let c = 0;
                let diff = (max - min) * 0.01;
                let omin = min;
                let omax = max;
                let ostep = step;
                while (synced != true) {
                    synced = this._checkSync(omin, omax, ostep, count);
                    c++;
                    if (c > 500) {
                        synced = true;
                    }
                    if (!synced) {
                        if (c / 3 == Math.round(c / 3)) {
                            omin = min - diff * c;
                            if (min >= 0 && omin < 0) {
                                omin = 0;
                            }
                        }
                        else {
                            omax = max + diff * c;
                            if (omax <= 0 && omax > 0) {
                                omax = 0;
                            }
                        }
                        let minMaxStep = this._adjustMinMax(omin, omax, gridCount, true);
                        omin = minMaxStep.min;
                        omax = minMaxStep.max;
                        ostep = minMaxStep.step;
                    }
                    else {
                        min = omin;
                        max = omax;
                        step = ostep;
                    }
                }
            }
        }
        return { min: min, max: max, step: step };
    }
    /**
     * Returns `true` if axis needs to be resunced with some other axis.
     */
    _checkSync(min, max, step, count) {
        let currentCount = (max - min) / step;
        for (let i = 1; i < count; i++) {
            if (_core_util_Math__WEBPACK_IMPORTED_MODULE_4__.round(currentCount / i, 1) == count || currentCount * i == count) {
                return true;
            }
        }
        return false;
    }
    /**
     * Returns relative position between two grid lines of the axis.
     *
     * @return Position
     */
    getCellWidthPosition() {
        let max = this.getPrivate("selectionMax", this.getPrivate("max"));
        let min = this.getPrivate("selectionMin", this.getPrivate("min"));
        if (_core_util_Type__WEBPACK_IMPORTED_MODULE_3__.isNumber(max) && _core_util_Type__WEBPACK_IMPORTED_MODULE_3__.isNumber(min)) {
            return this.getPrivate("step", 1) / (max - min);
        }
        return 0.05;
    }
}
Object.defineProperty(ValueAxis, "className", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: "ValueAxis"
});
Object.defineProperty(ValueAxis, "classNames", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: _Axis__WEBPACK_IMPORTED_MODULE_0__.Axis.classNames.concat([ValueAxis.className])
});
//# sourceMappingURL=ValueAxis.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/charts/xy/series/BaseColumnSeries.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/charts/xy/series/BaseColumnSeries.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BaseColumnSeries: () => (/* binding */ BaseColumnSeries)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.mjs");
/* harmony import */ var _XYSeries__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./XYSeries */ "./node_modules/@amcharts/amcharts5/.internal/charts/xy/series/XYSeries.js");
/* harmony import */ var _core_util_Percent__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../core/util/Percent */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Percent.js");
/* harmony import */ var _core_render_Graphics__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../core/render/Graphics */ "./node_modules/@amcharts/amcharts5/.internal/core/render/Graphics.js");
/* harmony import */ var _core_util_Array__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../core/util/Array */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Array.js");
/* harmony import */ var _core_util_Type__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../core/util/Type */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Type.js");






/**
 * Base class for all "column-based" series
 */
class BaseColumnSeries extends _XYSeries__WEBPACK_IMPORTED_MODULE_0__.XYSeries {
    constructor() {
        super(...arguments);
        Object.defineProperty(this, "_ph", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        Object.defineProperty(this, "_pw", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
    }
    _makeGraphics(listTemplate, dataItem) {
        return this.makeColumn(dataItem, listTemplate);
    }
    _makeFieldNames() {
        super._makeFieldNames();
        const xAxis = this.get("xAxis");
        const yAxis = this.get("yAxis");
        const categoryAxis = "CategoryAxis";
        const valueAxis = "ValueAxis";
        if (xAxis.isType(categoryAxis)) {
            if (!this.get("openCategoryXField")) {
                this._xOpenField = this._xField;
            }
        }
        if (xAxis.isType(valueAxis)) {
            if (!this.get("openValueXField")) {
                this._xOpenField = this._xField;
            }
        }
        if (yAxis.isType(categoryAxis)) {
            if (!this.get("openCategoryYField")) {
                this._yOpenField = this._yField;
            }
        }
        if (yAxis.isType(valueAxis)) {
            if (!this.get("openValueYField")) {
                this._yOpenField = this._yField;
            }
        }
    }
    _prepareChildren() {
        super._prepareChildren();
        const xAxis = this.get("xAxis");
        const yAxis = this.get("yAxis");
        const len = this.dataItems.length;
        const startIndex = Math.max(0, this.startIndex() - 2);
        const endIndex = Math.min(this.endIndex() + 2, len - 1);
        if (xAxis.inited && yAxis.inited) {
            for (let i = startIndex; i <= endIndex; i++) {
                let dataItem = this.dataItems[i];
                this._createGraphics(dataItem);
            }
        }
    }
    _updateChildren() {
        const chart = this.chart;
        if (chart) {
            this._ph = chart.plotContainer.height();
            this._pw = chart.plotContainer.width();
        }
        const xAxis = this.get("xAxis");
        const yAxis = this.get("yAxis");
        const baseAxis = this.get("baseAxis");
        const columnsTemplate = this.columns.template;
        if (this.isDirty("fill")) {
            if (columnsTemplate.get("fill") == null) {
                columnsTemplate.set("fill", this.get("fill"));
            }
        }
        if (this.isDirty("stroke")) {
            if (columnsTemplate.get("stroke") == null) {
                columnsTemplate.set("stroke", this.get("stroke"));
            }
        }
        let index = 0;
        let clusterCount = 0;
        let i = 0;
        _core_util_Array__WEBPACK_IMPORTED_MODULE_1__.each(baseAxis.series, (series) => {
            if (series instanceof BaseColumnSeries) {
                const stacked = series.get("stacked");
                if (stacked && i == 0) {
                    clusterCount++;
                }
                if (!stacked && series.get("clustered")) {
                    clusterCount++;
                }
            }
            if (series === this) {
                index = clusterCount - 1;
            }
            i++;
        });
        if (!this.get("clustered")) {
            index = 0;
            clusterCount = 1;
        }
        if (clusterCount === 0) {
            clusterCount = 1;
            index = 0;
        }
        const xRenderer = xAxis.get("renderer");
        const yRenderer = yAxis.get("renderer");
        const cellStartLocation = "cellStartLocation";
        const cellEndLocation = "cellEndLocation";
        const cellLocationX0 = xRenderer.get(cellStartLocation, 0);
        const cellLocationX1 = xRenderer.get(cellEndLocation, 1);
        const cellLocationY0 = yRenderer.get(cellStartLocation, 0);
        const cellLocationY1 = yRenderer.get(cellEndLocation, 1);
        this._aLocationX0 = cellLocationX0 + (index / clusterCount) * (cellLocationX1 - cellLocationX0);
        this._aLocationX1 = cellLocationX0 + (index + 1) / clusterCount * (cellLocationX1 - cellLocationX0);
        ;
        this._aLocationY0 = cellLocationY0 + (index / clusterCount) * (cellLocationY1 - cellLocationY0);
        this._aLocationY1 = cellLocationY0 + (index + 1) / clusterCount * (cellLocationY1 - cellLocationY0);
        if (xAxis.inited && yAxis.inited) {
            if (this._axesDirty || this._valuesDirty || this._stackDirty || this.isDirty("vcx") || this.isDirty("vcy") || this._sizeDirty) {
                const len = this.dataItems.length;
                let startIndex = Math.max(0, this.startIndex() - 2);
                let endIndex = Math.min(this.endIndex() + 2, len - 1);
                for (let i = 0; i < startIndex; i++) {
                    this._toggleColumn(this.dataItems[i], false);
                }
                let previous = this.dataItems[startIndex];
                for (let i = startIndex; i <= endIndex; i++) {
                    let dataItem = this.dataItems[i];
                    if (dataItem.get("valueX") != null && dataItem.get("valueY") != null) {
                        previous = dataItem;
                        if (i > 0 && startIndex > 0) {
                            for (let j = i - 1; j >= 0; j--) {
                                let dataItem = this.dataItems[j];
                                if (dataItem.get("valueX") != null && dataItem.get("valueY") != null) {
                                    previous = dataItem;
                                    break;
                                }
                            }
                        }
                        break;
                    }
                    else {
                        this._toggleColumn(dataItem, false);
                    }
                }
                for (let i = startIndex; i <= endIndex; i++) {
                    let dataItem = this.dataItems[i];
                    this._updateGraphics(dataItem, previous);
                    if (dataItem.get("valueX") != null && dataItem.get("valueY") != null) {
                        previous = dataItem;
                    }
                }
                for (let i = endIndex + 1; i < len; i++) {
                    this._toggleColumn(this.dataItems[i], false);
                }
            }
        }
        else {
            this._skipped = true;
        }
        this.updateLegendMarker(this.get("tooltipDataItem"));
        super._updateChildren();
    }
    _createGraphics(dataItem) {
        let graphics = dataItem.get("graphics");
        if (!graphics) {
            graphics = this._makeGraphics(this.columns, dataItem);
            dataItem.set("graphics", graphics);
            graphics._setDataItem(dataItem);
            const legendDataItem = dataItem.get("legendDataItem");
            if (legendDataItem) {
                const markerRectangle = legendDataItem.get("markerRectangle");
                if (markerRectangle) {
                    const ds = markerRectangle.states.lookup("default");
                    _core_util_Array__WEBPACK_IMPORTED_MODULE_1__.each(_core_render_Graphics__WEBPACK_IMPORTED_MODULE_2__.visualSettings, (setting) => {
                        const value = graphics.get(setting, this.get(setting));
                        markerRectangle.set(setting, value);
                        ds.set(setting, value);
                    });
                }
            }
            let graphicsArray = dataItem.get("rangeGraphics");
            if (graphicsArray) {
                _core_util_Array__WEBPACK_IMPORTED_MODULE_1__.each(graphicsArray, (graphics) => {
                    graphics.dispose();
                });
            }
            graphicsArray = [];
            dataItem.setRaw("rangeGraphics", graphicsArray);
            this.axisRanges.each((axisRange) => {
                const container = axisRange.container;
                const rangeGraphics = this._makeGraphics(axisRange.columns, dataItem);
                if (graphicsArray) {
                    graphicsArray.push(rangeGraphics);
                }
                rangeGraphics.setPrivate("list", axisRange.columns);
                container.children.push(rangeGraphics);
            });
        }
    }
    createAxisRange(axisDataItem) {
        _core_util_Array__WEBPACK_IMPORTED_MODULE_1__.each(this.dataItems, (dataItem) => {
            const graphics = dataItem.get("graphics");
            if (graphics) {
                graphics.dispose();
                dataItem.set("graphics", undefined);
            }
        });
        return super.createAxisRange(axisDataItem);
    }
    _updateGraphics(dataItem, previousDataItem) {
        let graphics = dataItem.get("graphics");
        //if (!graphics) {
        //	this._createGraphics(dataItem);
        //	graphics = dataItem.get("graphics")!;
        //}
        const xField = this._xField;
        const yField = this._yField;
        const valueX = dataItem.get(xField);
        const valueY = dataItem.get(yField);
        if (valueX != null && valueY != null) {
            const xOpenField = this._xOpenField;
            const yOpenField = this._yOpenField;
            const locationX = this.get("locationX", dataItem.get("locationX", 0.5));
            const locationY = this.get("locationY", dataItem.get("locationY", 0.5));
            const openLocationX = this.get("openLocationX", dataItem.get("openLocationX", locationX));
            const openLocationY = this.get("openLocationY", dataItem.get("openLocationY", locationY));
            const width = graphics.get("width");
            const height = graphics.get("height");
            const stacked = this.get("stacked");
            const xAxis = this.get("xAxis");
            const yAxis = this.get("yAxis");
            const baseAxis = this.get("baseAxis");
            const xStart = xAxis.get("start");
            const xEnd = xAxis.get("end");
            const yStart = yAxis.get("start");
            const yEnd = yAxis.get("end");
            let l;
            let r;
            let t;
            let b;
            let vcy = this.get("vcy", 1);
            let vcx = this.get("vcx", 1);
            let fitW = false;
            let fitH = false;
            if (yAxis.isType("CategoryAxis") && xAxis.isType("CategoryAxis")) {
                let startLocation = this._aLocationX0 + openLocationX - 0.5;
                let endLocation = this._aLocationX1 + locationX - 0.5;
                if (width instanceof _core_util_Percent__WEBPACK_IMPORTED_MODULE_3__.Percent) {
                    let offset = (endLocation - startLocation) * (1 - width.value) / 2;
                    startLocation += offset;
                    endLocation -= offset;
                }
                l = xAxis.getDataItemPositionX(dataItem, xOpenField, startLocation, vcx);
                r = xAxis.getDataItemPositionX(dataItem, xField, endLocation, vcx);
                startLocation = this._aLocationY0 + openLocationY - 0.5;
                endLocation = this._aLocationY1 + locationY - 0.5;
                if (height instanceof _core_util_Percent__WEBPACK_IMPORTED_MODULE_3__.Percent) {
                    let offset = (endLocation - startLocation) * (1 - height.value) / 2;
                    startLocation += offset;
                    endLocation -= offset;
                }
                t = yAxis.getDataItemPositionY(dataItem, yOpenField, startLocation, vcy);
                b = yAxis.getDataItemPositionY(dataItem, yField, endLocation, vcy);
                dataItem.setRaw("point", { x: l + (r - l) / 2, y: t + (b - t) / 2 });
            }
            else if (xAxis === baseAxis) {
                let startLocation = this._aLocationX0 + openLocationX - 0.5;
                let endLocation = this._aLocationX1 + locationX - 0.5;
                if (width instanceof _core_util_Percent__WEBPACK_IMPORTED_MODULE_3__.Percent) {
                    let offset = (endLocation - startLocation) * (1 - width.value) / 2;
                    startLocation += offset;
                    endLocation -= offset;
                }
                l = xAxis.getDataItemPositionX(dataItem, xOpenField, startLocation, vcx);
                r = xAxis.getDataItemPositionX(dataItem, xField, endLocation, vcx);
                t = yAxis.getDataItemPositionY(dataItem, yField, locationY, vcy);
                if (this._yOpenField !== this._yField) {
                    b = yAxis.getDataItemPositionY(dataItem, yOpenField, openLocationY, vcy);
                }
                else {
                    if (stacked) {
                        let stackToItemY = dataItem.get("stackToItemY");
                        if (stackToItemY) {
                            b = yAxis.getDataItemPositionY(stackToItemY, yField, openLocationY, stackToItemY.component.get("vcy"));
                        }
                        else {
                            b = yAxis.basePosition();
                        }
                    }
                    else {
                        b = yAxis.basePosition();
                    }
                }
                dataItem.setRaw("point", { x: l + (r - l) / 2, y: t });
                fitH = true;
            }
            else if (yAxis === baseAxis) {
                let startLocation = this._aLocationY0 + openLocationY - 0.5;
                let endLocation = this._aLocationY1 + locationY - 0.5;
                if (height instanceof _core_util_Percent__WEBPACK_IMPORTED_MODULE_3__.Percent) {
                    let offset = (endLocation - startLocation) * (1 - height.value) / 2;
                    startLocation += offset;
                    endLocation -= offset;
                }
                t = yAxis.getDataItemPositionY(dataItem, yOpenField, startLocation, vcy);
                b = yAxis.getDataItemPositionY(dataItem, yField, endLocation, vcy);
                r = xAxis.getDataItemPositionX(dataItem, xField, locationX, vcx);
                if (this._xOpenField !== this._xField) {
                    l = xAxis.getDataItemPositionX(dataItem, xOpenField, openLocationX, vcx);
                }
                else {
                    if (stacked) {
                        let stackToItemX = dataItem.get("stackToItemX");
                        if (stackToItemX) {
                            l = xAxis.getDataItemPositionX(stackToItemX, xField, openLocationX, stackToItemX.component.get("vcx"));
                        }
                        else {
                            l = xAxis.basePosition();
                        }
                    }
                    else {
                        l = xAxis.basePosition();
                    }
                }
                fitW = true;
                dataItem.setRaw("point", { x: r, y: t + (b - t) / 2 });
            }
            this._updateSeriesGraphics(dataItem, graphics, l, r, t, b, fitW, fitH);
            if ((l < xStart && r < xStart) || (l > xEnd && r > xEnd) || (t < yStart && b <= yStart) || (t >= yEnd && b > yEnd) || _core_util_Type__WEBPACK_IMPORTED_MODULE_4__.isNaN(l) || _core_util_Type__WEBPACK_IMPORTED_MODULE_4__.isNaN(t)) {
                this._toggleColumn(dataItem, false);
            }
            else {
                this._toggleColumn(dataItem, true);
            }
            let rangeGraphics = dataItem.get("rangeGraphics");
            if (rangeGraphics) {
                _core_util_Array__WEBPACK_IMPORTED_MODULE_1__.each(rangeGraphics, (graphics) => {
                    this._updateSeriesGraphics(dataItem, graphics, l, r, t, b, fitW, fitH);
                });
            }
            this._applyGraphicsStates(dataItem, previousDataItem);
        }
    }
    _updateSeriesGraphics(dataItem, graphics, l, r, t, b, fitW, fitH) {
        const width = graphics.get("width");
        const height = graphics.get("height");
        const maxWidth = graphics.get("maxWidth");
        const maxHeight = graphics.get("maxHeight");
        const ptl = this.getPoint(l, t);
        const pbr = this.getPoint(r, b);
        const tooltipPoint = dataItem.get("point");
        if (tooltipPoint) {
            const point = this.getPoint(tooltipPoint.x, tooltipPoint.y);
            tooltipPoint.x = point.x + this._x;
            tooltipPoint.y = point.y + this._y;
        }
        l = ptl.x;
        r = pbr.x;
        t = ptl.y;
        b = pbr.y;
        if (_core_util_Type__WEBPACK_IMPORTED_MODULE_4__.isNumber(width)) {
            const offset = ((r - l) - width) / 2;
            l += offset;
            r -= offset;
        }
        if (_core_util_Type__WEBPACK_IMPORTED_MODULE_4__.isNumber(maxWidth) && maxWidth < Math.abs(r - l)) {
            const offset = ((r - l) - maxWidth) / 2;
            l += offset;
            r -= offset;
        }
        if (_core_util_Type__WEBPACK_IMPORTED_MODULE_4__.isNumber(height)) {
            const offset = ((b - t) - height) / 2;
            t += offset;
            b -= offset;
        }
        if (_core_util_Type__WEBPACK_IMPORTED_MODULE_4__.isNumber(maxHeight) && maxHeight < Math.abs(b - t)) {
            const offset = ((b - t) - maxHeight) / 2;
            t += offset;
            b -= offset;
        }
        if (this.get("adjustBulletPosition")) {
            if (fitW) {
                r = Math.min(Math.max(0, r), this._pw);
                l = Math.min(Math.max(0, l), this._pw);
            }
            if (fitH) {
                t = Math.min(Math.max(0, t), this._ph);
                b = Math.min(Math.max(0, b), this._ph);
            }
        }
        dataItem.setRaw("left", l);
        dataItem.setRaw("right", r);
        dataItem.setRaw("top", t);
        dataItem.setRaw("bottom", b);
        graphics.setPrivate("width", r - l);
        graphics.setPrivate("height", b - t);
        graphics.set("x", l);
        graphics.set("y", b - (b - t));
    }
    _handleDataSetChange() {
        super._handleDataSetChange();
        _core_util_Array__WEBPACK_IMPORTED_MODULE_1__.each(this._dataItems, (dataItem) => {
            this._toggleColumn(dataItem, false);
        });
    }
    _applyGraphicsStates(dataItem, previousDataItem) {
        const graphics = dataItem.get("graphics");
        const dropFromOpen = graphics.states.lookup("dropFromOpen");
        const riseFromOpen = graphics.states.lookup("riseFromOpen");
        const dropFromPrevious = graphics.states.lookup("dropFromPrevious");
        const riseFromPrevious = graphics.states.lookup("riseFromPrevious");
        if (dropFromOpen || dropFromPrevious || riseFromOpen || riseFromPrevious) {
            const xAxis = this.get("xAxis");
            const yAxis = this.get("yAxis");
            const baseAxis = this.get("baseAxis");
            let open;
            let close;
            let previousClose;
            if (baseAxis === xAxis && yAxis.isType("ValueAxis")) {
                open = dataItem.get(this._yOpenField);
                close = dataItem.get(this._yField);
                previousClose = previousDataItem.get(this._yField);
            }
            else if (baseAxis === yAxis && xAxis.isType("ValueAxis")) {
                open = dataItem.get(this._xOpenField);
                close = dataItem.get(this._xField);
                previousClose = previousDataItem.get(this._xField);
            }
            if (_core_util_Type__WEBPACK_IMPORTED_MODULE_4__.isNumber(open) && _core_util_Type__WEBPACK_IMPORTED_MODULE_4__.isNumber(close)) {
                if (close < open) {
                    if (dropFromOpen) {
                        dropFromOpen.apply();
                    }
                }
                else {
                    if (riseFromOpen) {
                        riseFromOpen.apply();
                    }
                }
                if (_core_util_Type__WEBPACK_IMPORTED_MODULE_4__.isNumber(previousClose)) {
                    if (close < previousClose) {
                        if (dropFromPrevious) {
                            dropFromPrevious.apply();
                        }
                    }
                    else {
                        if (riseFromPrevious) {
                            riseFromPrevious.apply();
                        }
                    }
                }
            }
        }
    }
    /**
     * @ignore
     */
    disposeDataItem(dataItem) {
        super.disposeDataItem(dataItem);
        const graphics = dataItem.get("graphics");
        if (graphics) {
            this.columns.removeValue(graphics);
            graphics.dispose();
        }
        const rangeGraphics = dataItem.get("rangeGraphics");
        if (rangeGraphics) {
            _core_util_Array__WEBPACK_IMPORTED_MODULE_1__.each(rangeGraphics, (graphics) => {
                const list = graphics.getPrivate("list");
                if (list) {
                    list.removeValue(graphics);
                }
                graphics.dispose();
            });
        }
    }
    /**
     * Hides series's data item.
     *
     * @param   dataItem  Data item
     * @param   duration  Animation duration in milliseconds
     * @return            Promise
     */
    hideDataItem(dataItem, duration) {
        const _super = Object.create(null, {
            hideDataItem: { get: () => super.hideDataItem }
        });
        return (0,tslib__WEBPACK_IMPORTED_MODULE_5__.__awaiter)(this, void 0, void 0, function* () {
            const promises = [_super.hideDataItem.call(this, dataItem, duration)];
            const graphics = dataItem.get("graphics");
            if (graphics) {
                promises.push(graphics.hide(duration));
            }
            const rangeGraphics = dataItem.get("rangeGraphics");
            if (rangeGraphics) {
                _core_util_Array__WEBPACK_IMPORTED_MODULE_1__.each(rangeGraphics, (graphics) => {
                    promises.push(graphics.hide(duration));
                });
            }
            yield Promise.all(promises);
        });
    }
    _toggleColumn(dataItem, visible) {
        const graphics = dataItem.get("graphics");
        if (graphics) {
            graphics.setPrivate("visible", visible);
        }
        const rangeGraphics = dataItem.get("rangeGraphics");
        if (rangeGraphics) {
            _core_util_Array__WEBPACK_IMPORTED_MODULE_1__.each(rangeGraphics, (graphics) => {
                graphics.setPrivate("visible", visible);
            });
        }
        const bullets = dataItem.bullets;
        if (bullets) {
            _core_util_Array__WEBPACK_IMPORTED_MODULE_1__.each(bullets, (bullet) => {
                bullet.setPrivate("hidden", !visible);
            });
        }
    }
    /**
     * Shows series's data item.
     *
     * @param   dataItem  Data item
     * @param   duration  Animation duration in milliseconds
     * @return            Promise
     */
    showDataItem(dataItem, duration) {
        const _super = Object.create(null, {
            showDataItem: { get: () => super.showDataItem }
        });
        return (0,tslib__WEBPACK_IMPORTED_MODULE_5__.__awaiter)(this, void 0, void 0, function* () {
            const promises = [_super.showDataItem.call(this, dataItem, duration)];
            const graphics = dataItem.get("graphics");
            if (graphics) {
                promises.push(graphics.show(duration));
            }
            const rangeGraphics = dataItem.get("rangeGraphics");
            if (rangeGraphics) {
                _core_util_Array__WEBPACK_IMPORTED_MODULE_1__.each(rangeGraphics, (graphics) => {
                    promises.push(graphics.show(duration));
                });
            }
            yield Promise.all(promises);
        });
    }
    /**
     * @ignore
     */
    updateLegendMarker(dataItem) {
        let legendDataItem = this.get("legendDataItem");
        if (this.get("useLastColorForLegendMarker")) {
            if (!dataItem) {
                const lastDataItem = this.dataItems[this.endIndex() - 1];
                if (lastDataItem) {
                    dataItem = lastDataItem;
                }
            }
        }
        if (legendDataItem) {
            let graphics = this.columns.template;
            if (dataItem) {
                let column = dataItem.get("graphics");
                if (column) {
                    graphics = column;
                }
            }
            const markerRectangle = legendDataItem.get("markerRectangle");
            if (markerRectangle) {
                if (!legendDataItem.get("itemContainer").get("disabled")) {
                    const ds = markerRectangle.states.lookup("default");
                    _core_util_Array__WEBPACK_IMPORTED_MODULE_1__.each(_core_render_Graphics__WEBPACK_IMPORTED_MODULE_2__.visualSettings, (setting) => {
                        const value = graphics.get(setting, this.get(setting));
                        markerRectangle.set(setting, value);
                        ds.set(setting, value);
                    });
                }
            }
        }
    }
    _getTooltipTarget(dataItem) {
        if (this.get("seriesTooltipTarget") == "bullet") {
            return super._getTooltipTarget(dataItem);
        }
        let column = dataItem.get("graphics");
        if (column) {
            return column;
        }
        return this;
    }
}
Object.defineProperty(BaseColumnSeries, "className", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: "BaseColumnSeries"
});
Object.defineProperty(BaseColumnSeries, "classNames", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: _XYSeries__WEBPACK_IMPORTED_MODULE_0__.XYSeries.classNames.concat([BaseColumnSeries.className])
});
//# sourceMappingURL=BaseColumnSeries.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/charts/xy/series/ColumnSeries.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/charts/xy/series/ColumnSeries.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ColumnSeries: () => (/* binding */ ColumnSeries)
/* harmony export */ });
/* harmony import */ var _BaseColumnSeries__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./BaseColumnSeries */ "./node_modules/@amcharts/amcharts5/.internal/charts/xy/series/BaseColumnSeries.js");
/* harmony import */ var _core_util_Template__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../core/util/Template */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Template.js");
/* harmony import */ var _core_util_List__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../core/util/List */ "./node_modules/@amcharts/amcharts5/.internal/core/util/List.js");
/* harmony import */ var _core_render_RoundedRectangle__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../core/render/RoundedRectangle */ "./node_modules/@amcharts/amcharts5/.internal/core/render/RoundedRectangle.js");
/* harmony import */ var _core_util_Utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../core/util/Utils */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Utils.js");





class ColumnSeries extends _BaseColumnSeries__WEBPACK_IMPORTED_MODULE_0__.BaseColumnSeries {
    constructor() {
        super(...arguments);
        /**
         * A [[TemplateList]] of all columns in series.
         *
         * `columns.template` can be used to set default settings for all columns,
         * or to change on existing ones.
         */
        Object.defineProperty(this, "columns", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new _core_util_List__WEBPACK_IMPORTED_MODULE_1__.ListTemplate(_core_util_Template__WEBPACK_IMPORTED_MODULE_2__.Template.new({}), () => _core_render_RoundedRectangle__WEBPACK_IMPORTED_MODULE_3__.RoundedRectangle._new(this._root, {
                position: "absolute",
                themeTags: _core_util_Utils__WEBPACK_IMPORTED_MODULE_4__.mergeTags(this.columns.template.get("themeTags", []), ["series", "column"])
            }, [this.columns.template]))
        });
    }
    /**
     * @ignore
     */
    makeColumn(dataItem, listTemplate) {
        const column = this.mainContainer.children.push(listTemplate.make());
        column._setDataItem(dataItem);
        listTemplate.push(column);
        return column;
    }
    _processAxisRange(axisRange) {
        super._processAxisRange(axisRange);
        axisRange.columns = new _core_util_List__WEBPACK_IMPORTED_MODULE_1__.ListTemplate(_core_util_Template__WEBPACK_IMPORTED_MODULE_2__.Template.new({}), () => _core_render_RoundedRectangle__WEBPACK_IMPORTED_MODULE_3__.RoundedRectangle._new(this._root, {
            position: "absolute",
            themeTags: _core_util_Utils__WEBPACK_IMPORTED_MODULE_4__.mergeTags(axisRange.columns.template.get("themeTags", []), ["series", "column"]),
        }, [this.columns.template, axisRange.columns.template]));
    }
}
Object.defineProperty(ColumnSeries, "className", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: "ColumnSeries"
});
Object.defineProperty(ColumnSeries, "classNames", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: _BaseColumnSeries__WEBPACK_IMPORTED_MODULE_0__.BaseColumnSeries.classNames.concat([ColumnSeries.className])
});
//# sourceMappingURL=ColumnSeries.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/charts/xy/series/LineSeries.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/charts/xy/series/LineSeries.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   LineSeries: () => (/* binding */ LineSeries)
/* harmony export */ });
/* harmony import */ var _XYSeries__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./XYSeries */ "./node_modules/@amcharts/amcharts5/.internal/charts/xy/series/XYSeries.js");
/* harmony import */ var _core_render_Graphics__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../core/render/Graphics */ "./node_modules/@amcharts/amcharts5/.internal/core/render/Graphics.js");
/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-shape */ "./node_modules/d3-shape/src/line.js");
/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-shape */ "./node_modules/d3-shape/src/area.js");
/* harmony import */ var _core_util_Template__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../core/util/Template */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Template.js");
/* harmony import */ var _core_util_List__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../core/util/List */ "./node_modules/@amcharts/amcharts5/.internal/core/util/List.js");
/* harmony import */ var _core_util_Color__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../../core/util/Color */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Color.js");
/* harmony import */ var _core_render_Component__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../../core/render/Component */ "./node_modules/@amcharts/amcharts5/.internal/core/render/Component.js");
/* harmony import */ var _core_render_Rectangle__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../../core/render/Rectangle */ "./node_modules/@amcharts/amcharts5/.internal/core/render/Rectangle.js");
/* harmony import */ var _core_util_Type__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../../core/util/Type */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Type.js");
/* harmony import */ var _core_util_Array__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../../core/util/Array */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Array.js");
/* harmony import */ var _core_util_Utils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../../core/util/Utils */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Utils.js");











/**
 * Used to plot line and/or area series.
 *
 * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/series/line-series/} for more info
 * @important
 */
class LineSeries extends _XYSeries__WEBPACK_IMPORTED_MODULE_0__.XYSeries {
    constructor() {
        super(...arguments);
        Object.defineProperty(this, "_endIndex", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_strokeGenerator", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: (0,d3_shape__WEBPACK_IMPORTED_MODULE_1__["default"])()
        });
        Object.defineProperty(this, "_fillGenerator", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: (0,d3_shape__WEBPACK_IMPORTED_MODULE_2__["default"])()
        });
        Object.defineProperty(this, "_legendStroke", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_legendFill", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /**
         * A [[TemplateList]] of all line segments in series.
         *
         * `strokes.template` can be used to set default settings for all line
         * segments, or to change on existing ones.
         *
         * @default new ListTemplate<Graphics>
         */
        Object.defineProperty(this, "strokes", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new _core_util_List__WEBPACK_IMPORTED_MODULE_3__.ListTemplate(_core_util_Template__WEBPACK_IMPORTED_MODULE_4__.Template.new({}), () => _core_render_Graphics__WEBPACK_IMPORTED_MODULE_5__.Graphics._new(this._root, {
                themeTags: _core_util_Utils__WEBPACK_IMPORTED_MODULE_6__.mergeTags(this.strokes.template.get("themeTags", []), ["line", "series", "stroke"])
            }, [this.strokes.template]))
        });
        /**
         * A [[TemplateList]] of all segment fills in series.
         *
         * `fills.template` can be used to set default settings for all segment
         * fills, or to change on existing ones.
         *
         * @default new ListTemplate<Graphics>
         */
        Object.defineProperty(this, "fills", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new _core_util_List__WEBPACK_IMPORTED_MODULE_3__.ListTemplate(_core_util_Template__WEBPACK_IMPORTED_MODULE_4__.Template.new({}), () => _core_render_Graphics__WEBPACK_IMPORTED_MODULE_5__.Graphics._new(this._root, {
                themeTags: _core_util_Utils__WEBPACK_IMPORTED_MODULE_6__.mergeTags(this.strokes.template.get("themeTags", []), ["line", "series", "fill"])
            }, [this.fills.template]))
        });
        // custom set from data
        Object.defineProperty(this, "_fillTemplate", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_strokeTemplate", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_previousPoint", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: [0, 0, 0, 0]
        });
        Object.defineProperty(this, "_dindex", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        Object.defineProperty(this, "_sindex", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
    }
    _afterNew() {
        this._fillGenerator.y0(function (p) {
            return p[3];
        });
        this._fillGenerator.x0(function (p) {
            return p[2];
        });
        this._fillGenerator.y1(function (p) {
            return p[1];
        });
        this._fillGenerator.x1(function (p) {
            return p[0];
        });
        super._afterNew();
    }
    /**
     * @ignore
     */
    makeStroke(strokes) {
        const stroke = this.mainContainer.children.push(strokes.make());
        strokes.push(stroke);
        return stroke;
    }
    /**
     * @ignore
     */
    makeFill(fills) {
        const fill = this.mainContainer.children.push(fills.make());
        fills.push(fill);
        return fill;
    }
    _updateChildren() {
        this._strokeTemplate = undefined;
        this._fillTemplate = undefined;
        let xAxis = this.get("xAxis");
        let yAxis = this.get("yAxis");
        if (this.isDirty("stroke")) {
            const stroke = this.get("stroke");
            this.strokes.template.set("stroke", stroke);
            const legendStroke = this._legendStroke;
            if (legendStroke) {
                legendStroke.states.lookup("default").set("stroke", stroke);
            }
        }
        if (this.isDirty("fill")) {
            const fill = this.get("fill");
            this.fills.template.set("fill", fill);
            const legendFill = this._legendFill;
            if (legendFill) {
                legendFill.states.lookup("default").set("fill", fill);
            }
        }
        if (this.isDirty("curveFactory")) {
            const curveFactory = this.get("curveFactory");
            if (curveFactory) {
                this._strokeGenerator.curve(curveFactory);
                this._fillGenerator.curve(curveFactory);
            }
        }
        if (xAxis.inited && yAxis.inited) {
            if (this._axesDirty || this._valuesDirty || this._stackDirty || this.isDirty("vcx") || this.isDirty("vcy") || this._sizeDirty || this.isDirty("connect") || this.isDirty("curveFactory")) {
                this.fills.each((fill) => {
                    fill.setPrivate("visible", false);
                });
                this.strokes.each((fill) => {
                    fill.setPrivate("visible", false);
                });
                this.axisRanges.each((axisRange) => {
                    let fills = axisRange.fills;
                    if (fills) {
                        fills.each((fill) => {
                            fill.setPrivate("visible", false);
                        });
                    }
                    let strokes = axisRange.strokes;
                    if (strokes) {
                        strokes.each((stroke) => {
                            stroke.setPrivate("visible", false);
                        });
                    }
                });
                let startIndex = this.startIndex();
                let strokeTemplateField = this.strokes.template.get("templateField");
                let fillTemplateField = this.fills.template.get("templateField");
                let strokeTemplateFound = true;
                let fillTemplateFound = true;
                if (strokeTemplateField) {
                    strokeTemplateFound = false;
                }
                if (fillTemplateField) {
                    fillTemplateFound = false;
                }
                for (let i = startIndex - 1; i >= 0; i--) {
                    let dataItem = this.dataItems[i];
                    let hasValues = true;
                    let dataContext = dataItem.dataContext;
                    if (strokeTemplateField) {
                        if (dataContext[strokeTemplateField]) {
                            strokeTemplateFound = true;
                        }
                    }
                    if (fillTemplateField) {
                        if (dataContext[fillTemplateField]) {
                            fillTemplateFound = true;
                        }
                    }
                    _core_util_Array__WEBPACK_IMPORTED_MODULE_7__.each(this._valueFields, (field) => {
                        if (!_core_util_Type__WEBPACK_IMPORTED_MODULE_8__.isNumber(dataItem.get(field))) {
                            hasValues = false;
                        }
                    });
                    if (hasValues && strokeTemplateFound && fillTemplateFound) {
                        startIndex = i;
                        break;
                    }
                }
                let len = this.dataItems.length;
                let endIndex = this.endIndex();
                if (endIndex < len) {
                    endIndex++;
                    for (let i = endIndex; i < len; i++) {
                        let dataItem = this.dataItems[i];
                        let hasValues = true;
                        _core_util_Array__WEBPACK_IMPORTED_MODULE_7__.each(this._valueFields, (field) => {
                            if (!_core_util_Type__WEBPACK_IMPORTED_MODULE_8__.isNumber(dataItem.get(field))) {
                                hasValues = false;
                            }
                        });
                        if (hasValues) {
                            endIndex = i + 1;
                            break;
                        }
                    }
                }
                if (startIndex > 0) {
                    startIndex--;
                }
                this._endIndex = endIndex;
                this._clearGraphics();
                this._sindex = 0;
                this._dindex = startIndex;
                if (this.dataItems.length == 1) {
                    this._startSegment(0);
                }
                else {
                    // this is done to avoid recursion with a lot of segments 
                    while (this._dindex < endIndex - 1) {
                        this._startSegment(this._dindex);
                        this._sindex++;
                    }
                }
            }
        }
        else {
            this._skipped = true;
        }
        super._updateChildren();
    }
    _clearGraphics() {
        this.strokes.clear();
        this.fills.clear();
    }
    _startSegment(dataItemIndex) {
        let endIndex = this._endIndex;
        let currentEndIndex = endIndex;
        const autoGapCount = this.get("autoGapCount");
        const connect = this.get("connect");
        const fill = this.makeFill(this.fills);
        const fillTemplate = this._fillTemplate;
        const originalTemplate = this.fills.template;
        if (fillTemplate && fillTemplate != originalTemplate) {
            fill.template = fillTemplate;
        }
        fill.setPrivate("visible", true);
        const stroke = this.makeStroke(this.strokes);
        const strokeTemplate = this._strokeTemplate;
        if (strokeTemplate && strokeTemplate != this.strokes.template) {
            stroke.template = strokeTemplate;
        }
        stroke.setPrivate("visible", true);
        let xAxis = this.get("xAxis");
        let yAxis = this.get("yAxis");
        let baseAxis = this.get("baseAxis");
        let vcx = this.get("vcx", 1);
        let vcy = this.get("vcy", 1);
        let xField = this._xField;
        let yField = this._yField;
        let xOpenField = this._xOpenField;
        let yOpenField = this._yOpenField;
        const xOpenFieldValue = this.get("openValueXField");
        const yOpenFieldValue = this.get("openValueYField");
        if (!xOpenFieldValue) {
            xOpenField = this._xField;
        }
        if (!yOpenFieldValue) {
            yOpenField = this._yField;
        }
        const stacked = this.get("stacked");
        const basePosX = xAxis.basePosition();
        const basePosY = yAxis.basePosition();
        let baseField;
        if (baseAxis === yAxis) {
            baseField = this._yField;
        }
        else {
            baseField = this._xField;
        }
        const segments = [];
        let points = [];
        segments.push(points);
        const strokeTemplateField = this.strokes.template.get("templateField");
        const fillTemplateField = this.fills.template.get("templateField");
        let locationX = this.get("locationX", 0.5);
        let locationY = this.get("locationY", 0.5);
        let openLocationX = this.get("openLocationX", locationX);
        let openLocationY = this.get("openLocationY", locationY);
        const minDistance = this.get("minDistance", 0);
        let i;
        let fillVisible = this.fills.template.get("visible");
        if (this.axisRanges.length > 0) {
            fillVisible = true;
        }
        let getOpen = false;
        if (stacked || xOpenFieldValue || yOpenFieldValue) {
            getOpen = true;
        }
        const o = {
            points, segments, stacked, getOpen, basePosX, basePosY, fillVisible, xField, yField, xOpenField, yOpenField, vcx, vcy, baseAxis, xAxis, yAxis, locationX, locationY, openLocationX, openLocationY, minDistance
        };
        for (i = dataItemIndex; i < currentEndIndex; i++) {
            this._dindex = i;
            const dataItem = this._dataItems[i];
            let valueX = dataItem.get(xField);
            let valueY = dataItem.get(yField);
            if (valueX == null || valueY == null) {
                if (!connect) {
                    points = [];
                    segments.push(points);
                    o.points = points;
                }
            }
            else {
                this._getPoints(dataItem, o);
            }
            if (strokeTemplateField) {
                let strokeTemplate = dataItem.dataContext[strokeTemplateField];
                if (strokeTemplate) {
                    if (!(strokeTemplate instanceof _core_util_Template__WEBPACK_IMPORTED_MODULE_4__.Template)) {
                        strokeTemplate = _core_util_Template__WEBPACK_IMPORTED_MODULE_4__.Template.new(strokeTemplate);
                    }
                    this._strokeTemplate = strokeTemplate;
                    if (i > dataItemIndex) {
                        currentEndIndex = i;
                        break;
                    }
                    else {
                        stroke.template = strokeTemplate;
                    }
                }
            }
            if (fillTemplateField) {
                let fillTemplate = dataItem.dataContext[fillTemplateField];
                if (fillTemplate) {
                    if (!(fillTemplate instanceof _core_util_Template__WEBPACK_IMPORTED_MODULE_4__.Template)) {
                        fillTemplate = _core_util_Template__WEBPACK_IMPORTED_MODULE_4__.Template.new(fillTemplate);
                    }
                    this._fillTemplate = fillTemplate;
                    if (i > dataItemIndex) {
                        currentEndIndex = i;
                        break;
                    }
                    else {
                        fill.template = fillTemplate;
                    }
                }
            }
            if (!connect) {
                let nextItem = this.dataItems[i + 1];
                if (nextItem) {
                    if (baseAxis.shouldGap(dataItem, nextItem, autoGapCount, baseField)) {
                        points = [];
                        segments.push(points);
                        o.points = points;
                    }
                }
            }
        }
        fill.setRaw("userData", [dataItemIndex, i]);
        stroke.setRaw("userData", [dataItemIndex, i]);
        if (i === endIndex) {
            this._endLine(points, segments[0][0]);
        }
        if (stroke) {
            this._drawStroke(stroke, segments);
        }
        if (fill) {
            this._drawFill(fill, segments);
        }
        this.axisRanges.each((axisRange) => {
            const container = axisRange.container;
            const fills = axisRange.fills;
            const fill = this.makeFill(fills);
            if (container) {
                container.children.push(fill);
            }
            fill.setPrivate("visible", true);
            this._drawFill(fill, segments);
            const strokes = axisRange.strokes;
            const stroke = this.makeStroke(strokes);
            if (container) {
                container.children.push(stroke);
            }
            stroke.setPrivate("visible", true);
            this._drawStroke(stroke, segments);
            fill.setRaw("userData", [dataItemIndex, i]);
            stroke.setRaw("userData", [dataItemIndex, i]);
        });
    }
    _getPoints(dataItem, o) {
        let points = o.points;
        let itemLocationX = dataItem.get("locationX", o.locationX);
        let itemLocationY = dataItem.get("locationY", o.locationY);
        let xPos = o.xAxis.getDataItemPositionX(dataItem, o.xField, itemLocationX, o.vcx);
        let yPos = o.yAxis.getDataItemPositionY(dataItem, o.yField, itemLocationY, o.vcy);
        if (this._shouldInclude(xPos)) {
            const iPoint = this.getPoint(xPos, yPos);
            const point = [iPoint.x, iPoint.y];
            iPoint.x += this._x;
            iPoint.y += this._y;
            dataItem.set("point", iPoint);
            if (o.fillVisible) {
                let xPos0 = xPos;
                let yPos0 = yPos;
                if (o.baseAxis === o.xAxis) {
                    yPos0 = o.basePosY;
                }
                else if (o.baseAxis === o.yAxis) {
                    xPos0 = o.basePosX;
                }
                if (o.getOpen) {
                    let valueX = dataItem.get(o.xOpenField);
                    let valueY = dataItem.get(o.yOpenField);
                    if (valueX != null && valueY != null) {
                        let itemLocationX = dataItem.get("openLocationX", o.openLocationX);
                        let itemLocationY = dataItem.get("openLocationY", o.openLocationY);
                        if (o.stacked) {
                            let stackToItemX = dataItem.get("stackToItemX");
                            let stackToItemY = dataItem.get("stackToItemY");
                            if (stackToItemX) {
                                xPos0 = o.xAxis.getDataItemPositionX(stackToItemX, o.xField, itemLocationX, stackToItemX.component.get("vcx"));
                                if (_core_util_Type__WEBPACK_IMPORTED_MODULE_8__.isNaN(xPos0)) {
                                    xPos0 = o.basePosX;
                                }
                            }
                            else {
                                if (o.yAxis === o.baseAxis) {
                                    xPos0 = o.basePosX;
                                }
                                else {
                                    xPos0 = o.xAxis.getDataItemPositionX(dataItem, o.xOpenField, itemLocationX, o.vcx);
                                }
                            }
                            if (stackToItemY) {
                                yPos0 = o.yAxis.getDataItemPositionY(stackToItemY, o.yField, itemLocationY, stackToItemY.component.get("vcy"));
                                if (_core_util_Type__WEBPACK_IMPORTED_MODULE_8__.isNaN(yPos0)) {
                                    yPos0 = o.basePosY;
                                }
                            }
                            else {
                                if (o.xAxis === o.baseAxis) {
                                    yPos0 = o.basePosY;
                                }
                                else {
                                    yPos0 = o.yAxis.getDataItemPositionY(dataItem, o.yOpenField, itemLocationY, o.vcy);
                                }
                            }
                        }
                        else {
                            xPos0 = o.xAxis.getDataItemPositionX(dataItem, o.xOpenField, itemLocationX, o.vcx);
                            yPos0 = o.yAxis.getDataItemPositionY(dataItem, o.yOpenField, itemLocationY, o.vcy);
                        }
                    }
                }
                let closeIPoint = this.getPoint(xPos0, yPos0);
                point[2] = closeIPoint.x;
                point[3] = closeIPoint.y;
            }
            if (o.minDistance > 0) {
                const p0 = point[0];
                const p1 = point[1];
                const p2 = point[2];
                const p3 = point[3];
                const prev = this._previousPoint;
                const pp0 = prev[0];
                const pp1 = prev[1];
                const pp2 = prev[2];
                const pp3 = prev[3];
                if (Math.hypot(p0 - pp0, p1 - pp1) > o.minDistance || (p2 && p3 && Math.hypot(p2 - pp2, p3 - pp3) > o.minDistance)) {
                    points.push(point);
                    this._previousPoint = point;
                }
            }
            else {
                points.push(point);
            }
        }
    }
    _endLine(_points, _firstPoint) {
    }
    _drawStroke(graphics, segments) {
        if (graphics.get("visible") && !graphics.get("forceHidden")) {
            graphics.set("draw", (display) => {
                _core_util_Array__WEBPACK_IMPORTED_MODULE_7__.each(segments, (segment) => {
                    this._strokeGenerator.context(display);
                    this._strokeGenerator(segment);
                });
            });
        }
    }
    _drawFill(graphics, segments) {
        if (graphics.get("visible") && !graphics.get("forceHidden")) {
            graphics.set("draw", (display) => {
                _core_util_Array__WEBPACK_IMPORTED_MODULE_7__.each(segments, (segment) => {
                    this._fillGenerator.context(display);
                    this._fillGenerator(segment);
                });
            });
        }
    }
    _processAxisRange(axisRange) {
        super._processAxisRange(axisRange);
        axisRange.fills = new _core_util_List__WEBPACK_IMPORTED_MODULE_3__.ListTemplate(_core_util_Template__WEBPACK_IMPORTED_MODULE_4__.Template.new({}), () => _core_render_Graphics__WEBPACK_IMPORTED_MODULE_5__.Graphics._new(this._root, {
            themeTags: _core_util_Utils__WEBPACK_IMPORTED_MODULE_6__.mergeTags(axisRange.fills.template.get("themeTags", []), ["line", "series", "fill"]),
        }, [this.fills.template, axisRange.fills.template]));
        axisRange.strokes = new _core_util_List__WEBPACK_IMPORTED_MODULE_3__.ListTemplate(_core_util_Template__WEBPACK_IMPORTED_MODULE_4__.Template.new({}), () => _core_render_Graphics__WEBPACK_IMPORTED_MODULE_5__.Graphics._new(this._root, {
            themeTags: _core_util_Utils__WEBPACK_IMPORTED_MODULE_6__.mergeTags(axisRange.strokes.template.get("themeTags", []), ["line", "series", "stroke"]),
        }, [this.strokes.template, axisRange.strokes.template]));
    }
    /**
     * @ignore
     */
    createLegendMarker(_dataItem) {
        const legendDataItem = this.get("legendDataItem");
        if (legendDataItem) {
            const marker = legendDataItem.get("marker");
            const markerRectangle = legendDataItem.get("markerRectangle");
            if (markerRectangle) {
                markerRectangle.setPrivate("visible", false);
            }
            marker.set("background", _core_render_Rectangle__WEBPACK_IMPORTED_MODULE_9__.Rectangle.new(marker._root, { fillOpacity: 0, fill: (0,_core_util_Color__WEBPACK_IMPORTED_MODULE_10__.color)(0x000000) }));
            const legendStroke = marker.children.push(_core_render_Graphics__WEBPACK_IMPORTED_MODULE_5__.Graphics._new(marker._root, {
                themeTags: ["line", "series", "legend", "marker", "stroke"], interactive: false
            }, [this.strokes.template]));
            this._legendStroke = legendStroke;
            const legendFill = marker.children.push(_core_render_Graphics__WEBPACK_IMPORTED_MODULE_5__.Graphics._new(marker._root, {
                themeTags: ["line", "series", "legend", "marker", "fill"]
            }, [this.fills.template]));
            this._legendFill = legendFill;
            const disabledColor = this._root.interfaceColors.get("disabled");
            legendStroke.states.create("disabled", { fill: disabledColor, stroke: disabledColor });
            legendFill.states.create("disabled", { fill: disabledColor, stroke: disabledColor });
            if (this.bullets.length > 0) {
                const bulletFunction = this.bullets.getIndex(0);
                if (bulletFunction) {
                    const bullet = bulletFunction(marker._root, this, new _core_render_Component__WEBPACK_IMPORTED_MODULE_11__.DataItem(this, { legend: true }, {}));
                    if (bullet) {
                        const sprite = bullet.get("sprite");
                        if (sprite instanceof _core_render_Graphics__WEBPACK_IMPORTED_MODULE_5__.Graphics) {
                            sprite.states.create("disabled", { fill: disabledColor, stroke: disabledColor });
                        }
                        if (sprite) {
                            sprite.set("tooltipText", undefined);
                            sprite.set("tooltipHTML", undefined);
                            marker.children.push(sprite);
                            sprite.setAll({ x: marker.width() / 2, y: marker.height() / 2 });
                            marker.events.on("boundschanged", () => {
                                sprite.setAll({ x: marker.width() / 2, y: marker.height() / 2 });
                            });
                        }
                    }
                }
            }
        }
    }
}
Object.defineProperty(LineSeries, "className", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: "LineSeries"
});
Object.defineProperty(LineSeries, "classNames", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: _XYSeries__WEBPACK_IMPORTED_MODULE_0__.XYSeries.classNames.concat([LineSeries.className])
});
//# sourceMappingURL=LineSeries.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/charts/xy/series/XYSeries.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/charts/xy/series/XYSeries.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   XYSeries: () => (/* binding */ XYSeries)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.mjs");
/* harmony import */ var _core_render_Component__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../core/render/Component */ "./node_modules/@amcharts/amcharts5/.internal/core/render/Component.js");
/* harmony import */ var _core_render_Series__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../core/render/Series */ "./node_modules/@amcharts/amcharts5/.internal/core/render/Series.js");
/* harmony import */ var _core_util_List__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../core/util/List */ "./node_modules/@amcharts/amcharts5/.internal/core/util/List.js");
/* harmony import */ var _core_render_Container__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../core/render/Container */ "./node_modules/@amcharts/amcharts5/.internal/core/render/Container.js");
/* harmony import */ var _core_render_Graphics__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../../core/render/Graphics */ "./node_modules/@amcharts/amcharts5/.internal/core/render/Graphics.js");
/* harmony import */ var _core_util_Type__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../../core/util/Type */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Type.js");
/* harmony import */ var _core_util_Object__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../../core/util/Object */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Object.js");
/* harmony import */ var _core_util_Array__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../core/util/Array */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Array.js");
/* harmony import */ var _core_util_Utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../core/util/Utils */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Utils.js");










/**
 * @ignore
 */
function min(left, right) {
    if (left == null) {
        return right;
    }
    else if (right == null) {
        return left;
    }
    else if (right < left) {
        return right;
    }
    else {
        return left;
    }
}
/**
 * @ignore
 */
function max(left, right) {
    if (left == null) {
        return right;
    }
    else if (right == null) {
        return left;
    }
    else if (right > left) {
        return right;
    }
    else {
        return left;
    }
}
/**
 * A base class for all XY chart series.
 *
 * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/series/} for more info
 */
class XYSeries extends _core_render_Series__WEBPACK_IMPORTED_MODULE_0__.Series {
    constructor() {
        super(...arguments);
        Object.defineProperty(this, "_xField", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_yField", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_xOpenField", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_yOpenField", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_xLowField", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_xHighField", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_yLowField", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_yHighField", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_axesDirty", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        Object.defineProperty(this, "_stackDirty", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        Object.defineProperty(this, "_selectionProcessed", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        Object.defineProperty(this, "_dataSets", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {}
        });
        Object.defineProperty(this, "_mainContainerMask", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_x", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        Object.defineProperty(this, "_y", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        Object.defineProperty(this, "_bullets", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {}
        });
        /**
         * A [[Container]] that us used to put series' elements in.
         *
         * @default Container.new()
         */
        Object.defineProperty(this, "mainContainer", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: this.children.push(_core_render_Container__WEBPACK_IMPORTED_MODULE_1__.Container.new(this._root, {}))
        });
        /**
         * A list of axis ranges that affect the series.
         *
         * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/axis-ranges/} for more info
         */
        Object.defineProperty(this, "axisRanges", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new _core_util_List__WEBPACK_IMPORTED_MODULE_2__.List()
        });
        Object.defineProperty(this, "_skipped", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        Object.defineProperty(this, "_couldStackTo", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
        });
        Object.defineProperty(this, "_reallyStackedTo", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {}
        });
        Object.defineProperty(this, "_stackedSeries", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {}
        });
        Object.defineProperty(this, "_aLocationX0", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        Object.defineProperty(this, "_aLocationX1", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 1
        });
        Object.defineProperty(this, "_aLocationY0", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        Object.defineProperty(this, "_aLocationY1", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 1
        });
        Object.defineProperty(this, "_showBullets", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: true
        });
        Object.defineProperty(this, "valueXFields", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: [
                "valueX",
                "openValueX",
                "lowValueX",
                "highValueX"
            ]
        });
        Object.defineProperty(this, "valueYFields", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: [
                "valueY",
                "openValueY",
                "lowValueY",
                "highValueY"
            ]
        });
        Object.defineProperty(this, "_valueXFields", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_valueYFields", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        // used for full min/max
        Object.defineProperty(this, "_valueXShowFields", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_valueYShowFields", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        // used for selection (uses working)
        Object.defineProperty(this, "__valueXShowFields", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "__valueYShowFields", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_emptyDataItem", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new _core_render_Component__WEBPACK_IMPORTED_MODULE_3__.DataItem(this, undefined, {})
        });
        Object.defineProperty(this, "_dataSetId", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_tooltipFieldX", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_tooltipFieldY", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_posXDp", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_posYDp", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
    }
    _afterNew() {
        this.fields.push("categoryX", "categoryY", "openCategoryX", "openCategoryY");
        this.valueFields.push("valueX", "valueY", "openValueX", "openValueY", "lowValueX", "lowValueY", "highValueX", "highValueY");
        this._setRawDefault("vcx", 1);
        this._setRawDefault("vcy", 1);
        // this can't go to themes, as data might be parsed before theme
        this._setRawDefault("valueXShow", "valueXWorking");
        this._setRawDefault("valueYShow", "valueYWorking");
        this._setRawDefault("openValueXShow", "openValueXWorking");
        this._setRawDefault("openValueYShow", "openValueYWorking");
        this._setRawDefault("lowValueXShow", "lowValueXWorking");
        this._setRawDefault("lowValueYShow", "lowValueYWorking");
        this._setRawDefault("highValueXShow", "highValueXWorking");
        this._setRawDefault("highValueYShow", "highValueYWorking");
        this._setRawDefault("lowValueXGrouped", "low");
        this._setRawDefault("lowValueYGrouped", "low");
        this._setRawDefault("highValueXGrouped", "high");
        this._setRawDefault("highValueYGrouped", "high");
        super._afterNew();
        this.set("maskContent", true);
        this._disposers.push(this.axisRanges.events.onAll((change) => {
            if (change.type === "clear") {
                _core_util_Array__WEBPACK_IMPORTED_MODULE_4__.each(change.oldValues, (axisRange) => {
                    this._removeAxisRange(axisRange);
                });
            }
            else if (change.type === "push") {
                this._processAxisRange(change.newValue);
            }
            else if (change.type === "setIndex") {
                this._processAxisRange(change.newValue);
            }
            else if (change.type === "insertIndex") {
                this._processAxisRange(change.newValue);
            }
            else if (change.type === "removeIndex") {
                this._removeAxisRange(change.oldValue);
            }
            else if (change.type === "moveIndex") {
                this._processAxisRange(change.value);
            }
            else {
                throw new Error("Unknown IStreamEvent type");
            }
        }));
        this.states.create("hidden", { opacity: 1, visible: false });
        this._makeFieldNames();
    }
    _processAxisRange(axisRange) {
        const container = _core_render_Container__WEBPACK_IMPORTED_MODULE_1__.Container.new(this._root, {});
        axisRange.container = container;
        this.children.push(container);
        axisRange.series = this;
        const axisDataItem = axisRange.axisDataItem;
        axisDataItem.setRaw("isRange", true);
        const axis = axisDataItem.component;
        if (axis) {
            axis._processAxisRange(axisDataItem, ["range", "series"]);
            const bullet = axisDataItem.get("bullet");
            if (bullet) {
                const sprite = bullet.get("sprite");
                if (sprite) {
                    sprite.setPrivate("visible", false);
                }
            }
            const axisFill = axisDataItem.get("axisFill");
            if (axisFill) {
                container.set("mask", axisFill);
            }
            axis._seriesAxisRanges.push(axisDataItem);
        }
    }
    _removeAxisRange(axisRange) {
        const axisDataItem = axisRange.axisDataItem;
        const axis = axisDataItem.component;
        axis.disposeDataItem(axisDataItem);
        _core_util_Array__WEBPACK_IMPORTED_MODULE_4__.remove(axis._seriesAxisRanges, axisDataItem);
        const container = axisRange.container;
        if (container) {
            container.dispose();
        }
    }
    _updateFields() {
        super._updateFields();
        this._valueXFields = [];
        this._valueYFields = [];
        this._valueXShowFields = [];
        this._valueYShowFields = [];
        this.__valueXShowFields = [];
        this.__valueYShowFields = [];
        if (this.valueXFields) {
            _core_util_Array__WEBPACK_IMPORTED_MODULE_4__.each(this.valueXFields, (key) => {
                const field = this.get((key + "Field"));
                if (field) {
                    this._valueXFields.push(key);
                    let field = this.get((key + "Show"));
                    this.__valueXShowFields.push(field);
                    if (field.indexOf("Working") != -1) {
                        this._valueXShowFields.push(field.split("Working")[0]);
                    }
                    else {
                        this._valueXShowFields.push(field);
                    }
                }
            });
        }
        if (this.valueYFields) {
            _core_util_Array__WEBPACK_IMPORTED_MODULE_4__.each(this.valueYFields, (key) => {
                const field = this.get((key + "Field"));
                if (field) {
                    this._valueYFields.push(key);
                    let field = this.get((key + "Show"));
                    this.__valueYShowFields.push(field);
                    if (field.indexOf("Working") != -1) {
                        this._valueYShowFields.push(field.split("Working")[0]);
                    }
                    else {
                        this._valueYShowFields.push(field);
                    }
                }
            });
        }
    }
    _dispose() {
        super._dispose();
        this._bullets = {};
        const chart = this.chart;
        if (chart) {
            chart.series.removeValue(this);
        }
        _core_util_Array__WEBPACK_IMPORTED_MODULE_4__.removeFirst(this.get("xAxis").series, this);
        _core_util_Array__WEBPACK_IMPORTED_MODULE_4__.removeFirst(this.get("yAxis").series, this);
    }
    // TODO use  SelectKeys<this["_privateSettings"], number | undefined>
    _min(key, value) {
        let newValue = min(this.getPrivate(key), value);
        this.setPrivate(key, newValue);
    }
    // TODO use  SelectKeys<this["_privateSettings"], number | undefined>
    _max(key, value) {
        let newValue = max(this.getPrivate(key), value);
        this.setPrivate(key, newValue);
    }
    _shouldMakeBullet(dataItem) {
        const xAxis = this.get("xAxis");
        const yAxis = this.get("yAxis");
        const baseAxis = this.get("baseAxis");
        if (!xAxis.inited || !yAxis.inited) {
            return false;
        }
        const minBulletDistance = this.get("minBulletDistance", 0);
        if (minBulletDistance > 0) {
            let startIndex = this.startIndex();
            let endIndex = this.endIndex();
            let count = endIndex - startIndex;
            if (xAxis == baseAxis) {
                if (xAxis.get("renderer").axisLength() / count < minBulletDistance / 5) {
                    return false;
                }
            }
            else if (yAxis == baseAxis) {
                if (yAxis.get("renderer").axisLength() / count < minBulletDistance / 5) {
                    return false;
                }
            }
        }
        if (dataItem.get(this._xField) != null && dataItem.get(this._yField) != null) {
            return true;
        }
        return false;
    }
    _makeFieldNames() {
        const xAxis = this.get("xAxis");
        const yAxis = this.get("yAxis");
        const xName = xAxis.getPrivate("name");
        const xCapName = _core_util_Utils__WEBPACK_IMPORTED_MODULE_5__.capitalizeFirst(xName);
        const yName = yAxis.getPrivate("name");
        const yCapName = _core_util_Utils__WEBPACK_IMPORTED_MODULE_5__.capitalizeFirst(yName);
        const xLetter = xAxis.get("renderer").getPrivate("letter");
        const yLetter = yAxis.get("renderer").getPrivate("letter");
        const open = "open";
        const low = "low";
        const high = "high";
        const show = "Show";
        if (xAxis.className === "ValueAxis") {
            this._xField = this.get((xName + xLetter + show));
            this._xOpenField = this.get((open + xCapName + xLetter + show));
            this._xLowField = this.get((low + xCapName + xLetter + show));
            this._xHighField = this.get((high + xCapName + xLetter + show));
        }
        else {
            this._xField = (xName + xLetter);
            this._xOpenField = (open + xCapName + xLetter);
            this._xLowField = (low + xCapName + xLetter);
            this._xHighField = (high + xCapName + xLetter);
        }
        if (yAxis.className === "ValueAxis") {
            this._yField = this.get((yName + yLetter + show));
            this._yOpenField = this.get((open + yCapName + yLetter + show));
            this._yLowField = this.get((low + yCapName + yLetter + show));
            this._yHighField = this.get((high + yCapName + yLetter + show));
        }
        else {
            this._yField = (yName + yLetter);
            this._yOpenField = (open + yCapName + yLetter);
            this._yLowField = (low + yCapName + yLetter);
            this._yHighField = (high + yCapName + yLetter);
        }
    }
    _fixVC() {
        const xAxis = this.get("xAxis");
        const yAxis = this.get("yAxis");
        const baseAxis = this.get("baseAxis");
        const hiddenState = this.states.lookup("hidden");
        const sequencedInterpolation = this.get("sequencedInterpolation");
        if (hiddenState) {
            let value = 0;
            if (sequencedInterpolation) {
                value = 0.999999999999; // makes animate, good for stacked
            }
            if (xAxis === baseAxis) {
                hiddenState.set("vcy", value);
            }
            else if (yAxis === baseAxis) {
                hiddenState.set("vcx", value);
            }
            else {
                hiddenState.set("vcy", value);
                hiddenState.set("vcx", value);
            }
        }
    }
    _handleMaskBullets() {
        if (this.isDirty("maskBullets")) {
            this.bulletsContainer.set("maskContent", this.get("maskBullets"));
        }
    }
    _fixPosition() {
        const xAxis = this.get("xAxis");
        const yAxis = this.get("yAxis");
        this.set("x", xAxis.x() - _core_util_Utils__WEBPACK_IMPORTED_MODULE_5__.relativeToValue(xAxis.get("centerX", 0), xAxis.width()) - xAxis.parent.get("paddingLeft", 0));
        this.set("y", yAxis.y() - _core_util_Utils__WEBPACK_IMPORTED_MODULE_5__.relativeToValue(yAxis.get("centerY", 0), yAxis.height()) - yAxis.parent.get("paddingTop", 0));
        this.bulletsContainer.set("y", this.y());
        this.bulletsContainer.set("x", this.x());
    }
    _prepareChildren() {
        super._prepareChildren();
        this._bullets = {};
        if (this.isDirty("valueYShow") || this.isDirty("valueXShow") || this.isDirty("openValueYShow") || this.isDirty("openValueXShow") || this.isDirty("lowValueYShow") || this.isDirty("lowValueXShow") || this.isDirty("highValueYShow") || this.isDirty("highValueXShow")) {
            this._updateFields();
            this._makeFieldNames();
            this._valuesDirty = true;
        }
        if (this.isDirty("xAxis") || this.isDirty("yAxis")) {
            this._valuesDirty = true;
        }
        this.set("width", this.get("xAxis").width());
        this.set("height", this.get("yAxis").height());
        this._handleMaskBullets();
        const xAxis = this.get("xAxis");
        const yAxis = this.get("yAxis");
        const baseAxis = this.get("baseAxis");
        const tooltipPositionX = this.get("tooltipPositionX");
        let tooltipFieldX;
        switch (tooltipPositionX) {
            case "open":
                tooltipFieldX = this._xOpenField;
                break;
            case "low":
                tooltipFieldX = this._xLowField;
                break;
            case "high":
                tooltipFieldX = this._xHighField;
                break;
            default:
                tooltipFieldX = this._xField;
        }
        this._tooltipFieldX = tooltipFieldX;
        const tooltipPositionY = this.get("tooltipPositionY");
        let tooltipFieldY;
        switch (tooltipPositionY) {
            case "open":
                tooltipFieldY = this._yOpenField;
                break;
            case "low":
                tooltipFieldY = this._yLowField;
                break;
            case "high":
                tooltipFieldY = this._yHighField;
                break;
            default:
                tooltipFieldY = this._yField;
        }
        this._tooltipFieldY = tooltipFieldY;
        if (this.isDirty("baseAxis")) {
            this._fixVC();
        }
        this._fixPosition();
        const stacked = this.get("stacked");
        if (this.isDirty("stacked")) {
            if (stacked) {
                if (this._valuesDirty && !this._dataProcessed) {
                }
                else {
                    this._stack();
                }
            }
            else {
                this._unstack();
            }
        }
        if (this._valuesDirty && !this._dataProcessed) {
            this._dataProcessed = true;
            if (stacked) {
                this._stack();
            }
            _core_util_Array__WEBPACK_IMPORTED_MODULE_4__.each(this.dataItems, (dataItem) => {
                _core_util_Array__WEBPACK_IMPORTED_MODULE_4__.each(this._valueXShowFields, (key) => {
                    let value = dataItem.get(key);
                    if (value != null) {
                        if (stacked) {
                            value += this.getStackedXValue(dataItem, key);
                        }
                        this._min("minX", value);
                        this._max("maxX", value);
                    }
                });
                _core_util_Array__WEBPACK_IMPORTED_MODULE_4__.each(this._valueYShowFields, (key) => {
                    let value = dataItem.get(key);
                    if (value != null) {
                        if (stacked) {
                            value += this.getStackedYValue(dataItem, key);
                        }
                        this._min("minY", value);
                        this._max("maxY", value);
                    }
                });
                xAxis.processSeriesDataItem(dataItem, this._valueXFields);
                yAxis.processSeriesDataItem(dataItem, this._valueYFields);
            });
            xAxis._seriesValuesDirty = true;
            yAxis._seriesValuesDirty = true;
            if (!this.get("ignoreMinMax")) {
                if (this.isPrivateDirty("minX") || this.isPrivateDirty("maxX")) {
                    xAxis.markDirtyExtremes();
                }
                if (this.isPrivateDirty("minY") || this.isPrivateDirty("maxY")) {
                    yAxis.markDirtyExtremes();
                }
            }
            this._markStakedDirtyStack();
            //this.updateLegendMarker(undefined); // causes legend marker to change color instantly when on
            if (!this.get("tooltipDataItem")) {
                this.updateLegendValue(undefined);
            }
        }
        if (this.isDirty("vcx") || this.isDirty("vcy")) {
            this._markStakedDirtyStack();
        }
        if (!this._dataGrouped) {
            xAxis._groupSeriesData(this);
            yAxis._groupSeriesData(this);
            this._dataGrouped = true;
        }
        if (this._valuesDirty || this.isPrivateDirty("startIndex") || this.isPrivateDirty("endIndex") || this.isDirty("vcx") || this.isDirty("vcy") || this._stackDirty) {
            let startIndex = this.startIndex();
            let endIndex = this.endIndex();
            let minBulletDistance = this.get("minBulletDistance", 0);
            if (minBulletDistance > 0 && baseAxis) {
                if (baseAxis.get("renderer").axisLength() / (endIndex - startIndex) > minBulletDistance) {
                    this._showBullets = true;
                }
                else {
                    this._showBullets = false;
                }
            }
            if ((this._psi != startIndex || this._pei != endIndex || this.isDirty("vcx") || this.isDirty("vcy") || this._stackDirty || this._valuesDirty) && !this._selectionProcessed) {
                this._selectionProcessed = true;
                const vcx = this.get("vcx", 1);
                const vcy = this.get("vcy", 1);
                const stacked = this.get("stacked", false);
                const outOfSelection = this.getPrivate("outOfSelection");
                if (baseAxis === xAxis || !baseAxis) {
                    yAxis._calculateTotals();
                    this.setPrivateRaw("selectionMinY", undefined);
                    this.setPrivateRaw("selectionMaxY", undefined);
                    if (!outOfSelection) {
                        for (let i = startIndex; i < endIndex; i++) {
                            this.processYSelectionDataItem(this.dataItems[i], vcy, stacked);
                        }
                    }
                    else {
                        yAxis.markDirtySelectionExtremes();
                    }
                }
                if (baseAxis === yAxis || !baseAxis) {
                    xAxis._calculateTotals();
                    this.setPrivateRaw("selectionMinX", undefined);
                    this.setPrivateRaw("selectionMaxX", undefined);
                    if (!outOfSelection) {
                        for (let i = startIndex; i < endIndex; i++) {
                            this.processXSelectionDataItem(this.dataItems[i], vcx, stacked);
                        }
                    }
                    else {
                        yAxis.markDirtySelectionExtremes();
                    }
                }
                if (baseAxis === xAxis || !baseAxis) {
                    if (this.get("valueYShow") !== "valueYWorking") {
                        const selectionMinY = this.getPrivate("selectionMinY");
                        if (selectionMinY != null) {
                            this.setPrivateRaw("minY", selectionMinY);
                            yAxis.markDirtyExtremes();
                        }
                        const selectionMaxY = this.getPrivate("selectionMaxY");
                        if (selectionMaxY != null) {
                            this.setPrivateRaw("maxY", selectionMaxY);
                            yAxis.markDirtyExtremes();
                        }
                    }
                }
                if (baseAxis === yAxis || !baseAxis) {
                    if (this.get("valueXShow") !== "valueXWorking") {
                        const selectionMinX = this.getPrivate("selectionMinX");
                        if (selectionMinX != null) {
                            this.setPrivateRaw("minX", selectionMinX);
                            yAxis.markDirtyExtremes();
                        }
                        const selectionMaxX = this.getPrivate("selectionMaxX");
                        if (selectionMaxX != null) {
                            this.setPrivateRaw("maxX", selectionMaxX);
                            xAxis.markDirtyExtremes();
                        }
                    }
                }
                if (this.isPrivateDirty("selectionMinX") || this.isPrivateDirty("selectionMaxX")) {
                    xAxis.markDirtySelectionExtremes();
                }
                if (this.isPrivateDirty("selectionMinY") || this.isPrivateDirty("selectionMaxY")) {
                    yAxis.markDirtySelectionExtremes();
                }
                // this.updateLegendValue(undefined); flickers while panning
            }
        }
    }
    _makeRangeMask() {
        if (this.axisRanges.length > 0) {
            let mainContainerMask = this._mainContainerMask;
            if (mainContainerMask == null) {
                mainContainerMask = this.children.push(_core_render_Graphics__WEBPACK_IMPORTED_MODULE_6__.Graphics.new(this._root, {}));
                this._mainContainerMask = mainContainerMask;
                mainContainerMask.set("draw", (display, target) => {
                    const parent = this.parent;
                    if (parent) {
                        const w = this._root.container.width();
                        const h = this._root.container.height();
                        display.moveTo(-w, -h);
                        display.lineTo(-w, h * 2);
                        display.lineTo(w * 2, h * 2);
                        display.lineTo(w * 2, -h);
                        display.lineTo(-w, -h);
                        this.axisRanges.each((axisRange) => {
                            const fill = axisRange.axisDataItem.get("axisFill");
                            if (parent) {
                                if (fill) {
                                    let draw = fill.get("draw");
                                    if (draw) {
                                        draw(display, target);
                                    }
                                }
                            }
                        });
                    }
                    this.mainContainer._display.mask = mainContainerMask._display;
                });
            }
            mainContainerMask.markDirty();
            mainContainerMask._markDirtyKey("fill");
        }
        else {
            this.mainContainer._display.mask = null;
        }
    }
    _updateChildren() {
        super._updateChildren();
        // save for performance
        this._x = this.x();
        this._y = this.y();
        this._makeRangeMask();
    }
    _stack() {
        const chart = this.chart;
        if (chart) {
            const seriesIndex = chart.series.indexOf(this);
            this._couldStackTo = [];
            if (seriesIndex > 0) {
                let series;
                for (let i = seriesIndex - 1; i >= 0; i--) {
                    series = chart.series.getIndex(i);
                    if (series.get("xAxis") === this.get("xAxis") && series.get("yAxis") === this.get("yAxis") && series.className === this.className) {
                        this._couldStackTo.push(series);
                        if (!series.get("stacked")) {
                            break;
                        }
                    }
                }
            }
            this._stackDataItems();
        }
    }
    _unstack() {
        _core_util_Object__WEBPACK_IMPORTED_MODULE_7__.each(this._reallyStackedTo, (_key, value) => {
            delete (value._stackedSeries[this.uid]);
        });
        this._reallyStackedTo = {};
        _core_util_Array__WEBPACK_IMPORTED_MODULE_4__.each(this.dataItems, (dataItem) => {
            dataItem.setRaw("stackToItemY", undefined);
            dataItem.setRaw("stackToItemX", undefined);
        });
    }
    _stackDataItems() {
        // this works only with the same number of data @todo: search by date/category?
        const baseAxis = this.get("baseAxis");
        const xAxis = this.get("xAxis");
        const yAxis = this.get("yAxis");
        let field;
        let stackToItemKey;
        if (baseAxis === xAxis) {
            field = "valueY";
            stackToItemKey = "stackToItemY";
        }
        else if (baseAxis === yAxis) {
            field = "valueX";
            stackToItemKey = "stackToItemX";
        }
        let len = this._couldStackTo.length;
        let index = 0;
        const stackToNegative = this.get("stackToNegative");
        this._reallyStackedTo = {};
        _core_util_Array__WEBPACK_IMPORTED_MODULE_4__.each(this.dataItems, (dataItem) => {
            for (let s = 0; s < len; s++) {
                let stackToSeries = this._couldStackTo[s];
                let stackToItem = stackToSeries.dataItems[index];
                let value = dataItem.get(field);
                if (stackToItem) {
                    let stackValue = stackToItem.get(field);
                    if (stackToNegative) {
                        if (_core_util_Type__WEBPACK_IMPORTED_MODULE_8__.isNumber(value)) {
                            if (_core_util_Type__WEBPACK_IMPORTED_MODULE_8__.isNumber(stackValue)) {
                                if (value >= 0 && stackValue >= 0) {
                                    dataItem.setRaw(stackToItemKey, stackToItem);
                                    this._reallyStackedTo[stackToSeries.uid] = stackToSeries;
                                    stackToSeries._stackedSeries[this.uid] = this;
                                    break;
                                }
                                if (value < 0 && stackValue < 0) {
                                    dataItem.setRaw(stackToItemKey, stackToItem);
                                    this._reallyStackedTo[stackToSeries.uid] = stackToSeries;
                                    stackToSeries._stackedSeries[this.uid] = this;
                                    break;
                                }
                            }
                        }
                        else {
                            break;
                        }
                    }
                    else {
                        if (_core_util_Type__WEBPACK_IMPORTED_MODULE_8__.isNumber(value) && _core_util_Type__WEBPACK_IMPORTED_MODULE_8__.isNumber(stackValue)) {
                            dataItem.setRaw(stackToItemKey, stackToItem);
                            this._reallyStackedTo[stackToSeries.uid] = stackToSeries;
                            stackToSeries._stackedSeries[this.uid] = this;
                            break;
                        }
                    }
                }
            }
            index++;
        });
    }
    processXSelectionDataItem(dataItem, vcx, stacked) {
        _core_util_Array__WEBPACK_IMPORTED_MODULE_4__.each(this.__valueXShowFields, (key) => {
            let value = dataItem.get(key);
            if (value != null) {
                if (stacked) {
                    value += this.getStackedXValueWorking(dataItem, key);
                }
                this._min("selectionMinX", value);
                this._max("selectionMaxX", value * vcx);
            }
        });
    }
    processYSelectionDataItem(dataItem, vcy, stacked) {
        _core_util_Array__WEBPACK_IMPORTED_MODULE_4__.each(this.__valueYShowFields, (key) => {
            let value = dataItem.get(key);
            if (value != null) {
                if (stacked) {
                    value += this.getStackedYValueWorking(dataItem, key);
                }
                this._min("selectionMinY", value);
                this._max("selectionMaxY", value * vcy);
            }
        });
    }
    /**
     * @ignore
     */
    getStackedYValueWorking(dataItem, key) {
        const stackToItem = dataItem.get("stackToItemY");
        if (stackToItem) {
            const stackedToSeries = stackToItem.component;
            return stackToItem.get(key, 0) * stackedToSeries.get("vcy", 1) + this.getStackedYValueWorking(stackToItem, key);
        }
        return 0;
    }
    /**
     * @ignore
     */
    getStackedXValueWorking(dataItem, key) {
        const stackToItem = dataItem.get("stackToItemX");
        if (stackToItem) {
            const stackedToSeries = stackToItem.component;
            return stackToItem.get(key, 0) * stackedToSeries.get("vcx", 1) + this.getStackedXValueWorking(stackToItem, key);
        }
        return 0;
    }
    /**
     * @ignore
     */
    getStackedYValue(dataItem, key) {
        const stackToItem = dataItem.get("stackToItemY");
        if (stackToItem) {
            return stackToItem.get(key, 0) + this.getStackedYValue(stackToItem, key);
        }
        return 0;
    }
    /**
     * @ignore
     */
    getStackedXValue(dataItem, key) {
        const stackToItem = dataItem.get("stackToItemX");
        if (stackToItem) {
            return stackToItem.get(key, 0) + this.getStackedXValue(stackToItem, key);
        }
        return 0;
    }
    /**
     * @ignore
     */
    createLegendMarker(_dataItem) {
        this.updateLegendMarker();
    }
    _markDirtyAxes() {
        this._axesDirty = true;
        this.markDirty();
    }
    _markDataSetDirty() {
        this._afterDataChange();
        this._valuesDirty = true;
        this._dataProcessed = false;
        this._aggregatesCalculated = false;
        this.markDirty();
    }
    _clearDirty() {
        super._clearDirty();
        this._axesDirty = false;
        this._selectionProcessed = false;
        this._stackDirty = false;
        this._dataProcessed = false;
    }
    _positionBullet(bullet) {
        let sprite = bullet.get("sprite");
        if (sprite) {
            let dataItem = sprite.dataItem;
            let locationX = bullet.get("locationX", dataItem.get("locationX", 0.5));
            let locationY = bullet.get("locationY", dataItem.get("locationY", 0.5));
            let xAxis = this.get("xAxis");
            let yAxis = this.get("yAxis");
            let positionX = xAxis.getDataItemPositionX(dataItem, this._xField, locationX, this.get("vcx", 1));
            let positionY = yAxis.getDataItemPositionY(dataItem, this._yField, locationY, this.get("vcy", 1));
            let point = this.getPoint(positionX, positionY);
            let left = dataItem.get("left", point.x);
            let right = dataItem.get("right", point.x);
            let top = dataItem.get("top", point.y);
            let bottom = dataItem.get("bottom", point.y);
            let x = 0;
            let y = 0;
            let w = right - left;
            let h = bottom - top;
            if (this._shouldShowBullet(positionX, positionY)) {
                sprite.setPrivate("visible", !bullet.getPrivate("hidden"));
                let field = bullet.get("field");
                const baseAxis = this.get("baseAxis");
                const xAxis = this.get("xAxis");
                const yAxis = this.get("yAxis");
                if (field != undefined) {
                    let realField;
                    if (baseAxis == xAxis) {
                        if (field == "value") {
                            realField = this._yField;
                        }
                        else if (field == "open") {
                            realField = this._yOpenField;
                        }
                        else if (field == "high") {
                            realField = this._yHighField;
                        }
                        else if (field == "low") {
                            realField = this._yLowField;
                        }
                        if (realField) {
                            positionY = yAxis.getDataItemPositionY(dataItem, realField, 0, this.get("vcy", 1));
                            point = yAxis.get("renderer").positionToPoint(positionY);
                            y = point.y;
                            x = left + w * locationX;
                        }
                    }
                    else {
                        if (field == "value") {
                            realField = this._xField;
                        }
                        else if (field == "open") {
                            realField = this._xOpenField;
                        }
                        else if (field == "high") {
                            realField = this._xHighField;
                        }
                        else if (field == "low") {
                            realField = this._xLowField;
                        }
                        if (realField) {
                            positionX = xAxis.getDataItemPositionX(dataItem, realField, 0, this.get("vcx", 1));
                            point = xAxis.get("renderer").positionToPoint(positionX);
                            x = point.x;
                            y = bottom - h * locationY;
                        }
                    }
                }
                else {
                    x = left + w * locationX;
                    y = bottom - h * locationY;
                }
                const stacked = bullet.get("stacked");
                if (stacked) {
                    const chart = this.chart;
                    if (baseAxis == xAxis) {
                        let previousBullet = this._bullets[positionX + "_" + positionY];
                        if (previousBullet) {
                            let previousBounds = previousBullet.bounds();
                            let bounds = sprite.localBounds();
                            let yo = y;
                            y = previousBounds.top;
                            if (stacked == "down") {
                                y = previousBounds.bottom - bounds.top;
                            }
                            else if (stacked == "auto") {
                                if (chart) {
                                    if (yo < chart.plotContainer.height() / 2) {
                                        y = previousBounds.bottom - bounds.top;
                                    }
                                    else {
                                        y += bounds.bottom;
                                    }
                                }
                            }
                            else {
                                y += bounds.bottom;
                            }
                        }
                        this._bullets[positionX + "_" + positionY] = sprite;
                    }
                    else {
                        let previousBullet = this._bullets[positionX + "_" + positionY];
                        if (previousBullet) {
                            let previousBounds = previousBullet.bounds();
                            let bounds = sprite.localBounds();
                            let xo = x;
                            x = previousBounds.right;
                            if (stacked == "down") {
                                x = previousBounds.left - bounds.right;
                            }
                            else if (stacked == "auto") {
                                if (chart) {
                                    if (xo < chart.plotContainer.width() / 2) {
                                        x = previousBounds.left - bounds.right;
                                    }
                                    else {
                                        x -= bounds.left;
                                    }
                                }
                            }
                            else {
                                x -= bounds.left;
                            }
                        }
                        this._bullets[positionX + "_" + positionY] = sprite;
                    }
                }
                if (sprite.isType("Label")) {
                    sprite.setPrivate("maxWidth", Math.abs(w));
                    sprite.setPrivate("maxHeight", Math.abs(h));
                }
                sprite.setAll({ x, y });
            }
            else {
                sprite.setPrivate("visible", false);
            }
        }
    }
    _shouldShowBullet(_positionX, _positionY) {
        return this._showBullets;
    }
    /**
     * @ignore
     */
    setDataSet(id) {
        if (this._dataSets[id]) {
            this._handleDataSetChange();
            this._dataItems = this._dataSets[id];
            this._markDataSetDirty();
            this._dataSetId = id;
            const type = "datasetchanged";
            if (this.events.isEnabled(type)) {
                this.events.dispatch(type, { type: type, target: this, id: id });
            }
        }
    }
    /**
     * @ignore
     */
    resetGrouping() {
        _core_util_Object__WEBPACK_IMPORTED_MODULE_7__.each(this._dataSets, (_key, dataSet) => {
            if (dataSet != this._mainDataItems) {
                _core_util_Array__WEBPACK_IMPORTED_MODULE_4__.each(dataSet, (dataItem) => {
                    this.disposeDataItem(dataItem);
                });
            }
        });
        this._dataSets = {};
        this._dataItems = this.mainDataItems;
    }
    _handleDataSetChange() {
        _core_util_Array__WEBPACK_IMPORTED_MODULE_4__.each(this._dataItems, (dataItem) => {
            let bullets = dataItem.bullets;
            if (bullets) {
                _core_util_Array__WEBPACK_IMPORTED_MODULE_4__.each(bullets, (bullet) => {
                    if (bullet) {
                        let sprite = bullet.get("sprite");
                        if (sprite) {
                            sprite.setPrivate("visible", false);
                        }
                    }
                });
            }
        });
        this._selectionProcessed = false; // for totals to be calculated
    }
    /**
     * Shows hidden series.
     *
     * @param   duration  Duration of animation in milliseconds
     * @return            Animation promise
     */
    show(duration) {
        const _super = Object.create(null, {
            show: { get: () => super.show }
        });
        return (0,tslib__WEBPACK_IMPORTED_MODULE_9__.__awaiter)(this, void 0, void 0, function* () {
            this._fixVC();
            let promises = [];
            promises.push(_super.show.call(this, duration).then(() => {
                this._isShowing = false;
                let xAxis = this.get("xAxis");
                let yAxis = this.get("yAxis");
                let baseAxis = this.get("baseAxis");
                if (yAxis !== baseAxis) {
                    yAxis.markDirtySelectionExtremes();
                }
                if (xAxis !== baseAxis) {
                    xAxis.markDirtySelectionExtremes();
                }
            }));
            promises.push(this.bulletsContainer.show(duration));
            promises.push(this._sequencedShowHide(true, duration));
            yield Promise.all(promises);
        });
    }
    /**
     * Hides series.
     *
     * @param   duration  Duration of animation in milliseconds
     * @return            Animation promise
     */
    hide(duration) {
        const _super = Object.create(null, {
            hide: { get: () => super.hide }
        });
        return (0,tslib__WEBPACK_IMPORTED_MODULE_9__.__awaiter)(this, void 0, void 0, function* () {
            this._fixVC();
            let promises = [];
            promises.push(_super.hide.call(this, duration).then(() => {
                this._isHiding = false;
            }));
            promises.push(this.bulletsContainer.hide(duration));
            promises.push(this._sequencedShowHide(false, duration));
            yield Promise.all(promises);
        });
    }
    /**
     * Shows series's data item.
     *
     * @param   dataItem  Data item
     * @param   duration  Animation duration in milliseconds
     * @return            Promise
     */
    showDataItem(dataItem, duration) {
        const _super = Object.create(null, {
            showDataItem: { get: () => super.showDataItem }
        });
        return (0,tslib__WEBPACK_IMPORTED_MODULE_9__.__awaiter)(this, void 0, void 0, function* () {
            const promises = [_super.showDataItem.call(this, dataItem, duration)];
            if (!_core_util_Type__WEBPACK_IMPORTED_MODULE_8__.isNumber(duration)) {
                duration = this.get("stateAnimationDuration", 0);
            }
            const easing = this.get("stateAnimationEasing");
            _core_util_Array__WEBPACK_IMPORTED_MODULE_4__.each(this._valueFields, (key) => {
                promises.push(dataItem.animate({ key: key + "Working", to: dataItem.get(key), duration: duration, easing: easing }).waitForStop());
            });
            yield Promise.all(promises);
        });
    }
    /**
     * Hides series's data item.
     *
     * @param   dataItem  Data item
     * @param   duration  Animation duration in milliseconds
     * @return            Promise
     */
    hideDataItem(dataItem, duration) {
        const _super = Object.create(null, {
            hideDataItem: { get: () => super.hideDataItem }
        });
        return (0,tslib__WEBPACK_IMPORTED_MODULE_9__.__awaiter)(this, void 0, void 0, function* () {
            const promises = [_super.hideDataItem.call(this, dataItem, duration)];
            const hiddenState = this.states.create("hidden", {});
            if (!_core_util_Type__WEBPACK_IMPORTED_MODULE_8__.isNumber(duration)) {
                duration = hiddenState.get("stateAnimationDuration", this.get("stateAnimationDuration", 0));
            }
            const easing = hiddenState.get("stateAnimationEasing", this.get("stateAnimationEasing"));
            const xAxis = this.get("xAxis");
            const yAxis = this.get("yAxis");
            const baseAxis = this.get("baseAxis");
            const stacked = this.get("stacked");
            if (baseAxis === xAxis || !baseAxis) {
                _core_util_Array__WEBPACK_IMPORTED_MODULE_4__.each(this._valueYFields, (key) => {
                    let min = yAxis.getPrivate("min");
                    let baseValue = yAxis.baseValue();
                    if (_core_util_Type__WEBPACK_IMPORTED_MODULE_8__.isNumber(min) && min > baseValue) {
                        baseValue = min;
                    }
                    if (stacked) {
                        baseValue = 0;
                    }
                    let value = dataItem.get(key);
                    if (value != null) {
                        promises.push(dataItem.animate({ key: key + "Working", to: baseValue, duration: duration, easing: easing }).waitForStop());
                    }
                });
            }
            if (baseAxis === yAxis || !baseAxis) {
                let min = xAxis.getPrivate("min");
                let baseValue = xAxis.baseValue();
                if (_core_util_Type__WEBPACK_IMPORTED_MODULE_8__.isNumber(min) && min > baseValue) {
                    baseValue = min;
                }
                if (stacked) {
                    baseValue = 0;
                }
                _core_util_Array__WEBPACK_IMPORTED_MODULE_4__.each(this._valueXFields, (key) => {
                    let value = dataItem.get(key);
                    if (value != null) {
                        promises.push(dataItem.animate({ key: key + "Working", to: baseValue, duration: duration, easing: easing }).waitForStop());
                    }
                });
            }
            yield Promise.all(promises);
        });
    }
    _markDirtyStack() {
        this._stackDirty = true;
        this.markDirty();
        this._markStakedDirtyStack();
    }
    _markStakedDirtyStack() {
        const stackedSeries = this._stackedSeries;
        if (stackedSeries) {
            _core_util_Object__WEBPACK_IMPORTED_MODULE_7__.each(stackedSeries, (_key, value) => {
                if (!value._stackDirty) {
                    value._markDirtyStack();
                }
            });
        }
    }
    _afterChanged() {
        super._afterChanged();
        if (this._skipped) {
            this._markDirtyAxes();
            this._skipped = false;
        }
    }
    /**
     * Shows a tooltip for specific data item.
     *
     * @param  dataItem  Data item
     */
    showDataItemTooltip(dataItem) {
        this.updateLegendMarker(dataItem);
        this.updateLegendValue(dataItem);
        const tooltip = this.get("tooltip");
        if (tooltip) {
            if (!this.isHidden()) {
                tooltip._setDataItem(dataItem);
                if (dataItem) {
                    let locationX = this.get("locationX", 0);
                    let locationY = this.get("locationY", 1);
                    let itemLocationX = dataItem.get("locationX", locationX);
                    let itemLocationY = dataItem.get("locationY", locationY);
                    const xAxis = this.get("xAxis");
                    const yAxis = this.get("yAxis");
                    const vcx = this.get("vcx", 1);
                    const vcy = this.get("vcy", 1);
                    const xPos = xAxis.getDataItemPositionX(dataItem, this._tooltipFieldX, this._aLocationX0 + (this._aLocationX1 - this._aLocationX0) * itemLocationX, vcx);
                    const yPos = yAxis.getDataItemPositionY(dataItem, this._tooltipFieldY, this._aLocationY0 + (this._aLocationY1 - this._aLocationY0) * itemLocationY, vcy);
                    const point = this.getPoint(xPos, yPos);
                    let show = true;
                    _core_util_Array__WEBPACK_IMPORTED_MODULE_4__.each(this._valueFields, (field) => {
                        if (dataItem.get(field) == null) {
                            show = false;
                        }
                    });
                    if (show) {
                        const chart = this.chart;
                        if (chart && chart.inPlot(point)) {
                            tooltip.label.text.markDirtyText();
                            tooltip.set("tooltipTarget", this._getTooltipTarget(dataItem));
                            tooltip.set("pointTo", this._display.toGlobal({ x: point.x, y: point.y }));
                        }
                        else {
                            tooltip._setDataItem(undefined);
                        }
                    }
                    else {
                        tooltip._setDataItem(undefined);
                    }
                }
            }
            else {
                this.hideTooltip();
            }
        }
    }
    hideTooltip() {
        const tooltip = this.get("tooltip");
        if (tooltip) {
            tooltip.set("tooltipTarget", this);
        }
        return super.hideTooltip();
    }
    _getTooltipTarget(dataItem) {
        if (this.get("seriesTooltipTarget") == "bullet") {
            const bullets = dataItem.bullets;
            if (bullets && bullets.length > 0) {
                const bullet = bullets[0];
                const sprite = bullet.get("sprite");
                if (sprite) {
                    return sprite;
                }
            }
        }
        return this;
    }
    /**
     * @ignore
     */
    updateLegendValue(dataItem) {
        const legendDataItem = this.get("legendDataItem");
        if (legendDataItem) {
            const label = legendDataItem.get("label");
            if (label) {
                let txt = "";
                if (dataItem) {
                    label._setDataItem(dataItem);
                    txt = this.get("legendLabelText", label.get("text", this.get("name", "")));
                }
                else {
                    label._setDataItem(this._emptyDataItem);
                    txt = this.get("legendRangeLabelText", this.get("legendLabelText", label.get("text", this.get("name", ""))));
                }
                label.set("text", txt);
            }
            const valueLabel = legendDataItem.get("valueLabel");
            if (valueLabel) {
                let txt = "";
                if (dataItem) {
                    valueLabel._setDataItem(dataItem);
                    txt = this.get("legendValueText", valueLabel.get("text", ""));
                }
                else {
                    valueLabel._setDataItem(this._emptyDataItem);
                    txt = this.get("legendRangeValueText", valueLabel.get("text", ""));
                }
                valueLabel.set("text", txt);
            }
        }
    }
    _getItemReaderLabel() {
        let text = "X: {" + this._xField;
        if (this.get("xAxis").isType("DateAxis")) {
            text += ".formatDate()";
        }
        text += "}; Y: {" + this._yField;
        if (this.get("yAxis").isType("DateAxis")) {
            text += ".formatDate()";
        }
        text += "}";
        return text;
    }
    /**
     * @ignore
     */
    getPoint(positionX, positionY) {
        let x = this.get("xAxis").get("renderer").positionToCoordinate(positionX);
        let y = this.get("yAxis").get("renderer").positionToCoordinate(positionY);
        // if coordinate is super big, canvas fails to draw line, capping to some big number (won't make any visual difference)
        let max = 999999999;
        if (y < -max) {
            y = -max;
        }
        if (y > max) {
            y = max;
        }
        if (x < -max) {
            x = -max;
        }
        if (x > max) {
            x = max;
        }
        return { x: x, y: y };
    }
    _shouldInclude(_position) {
        return true;
    }
    /**
     * @ignore
     */
    handleCursorHide() {
        this.hideTooltip();
        this.updateLegendValue(undefined);
        this.updateLegendMarker(undefined);
    }
    _afterDataChange() {
        super._afterDataChange();
        this.get("xAxis")._markDirtyKey("start");
        this.get("yAxis")._markDirtyKey("start");
        this.resetExtremes();
    }
    /**
     * Resets cached axis scale values.
     */
    resetExtremes() {
        this.setPrivate("selectionMinX", undefined);
        this.setPrivate("selectionMaxX", undefined);
        this.setPrivate("selectionMinY", undefined);
        this.setPrivate("selectionMaxY", undefined);
        this.setPrivate("minX", undefined);
        this.setPrivate("minY", undefined);
        this.setPrivate("maxX", undefined);
        this.setPrivate("maxY", undefined);
    }
    /**
     * Creates and returns an axis range object.
     *
     * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/axis-ranges/} for more info
     * @param   axisDataItem  Axis data item
     * @return                Axis range
     */
    createAxisRange(axisDataItem) {
        return this.axisRanges.push({
            axisDataItem: axisDataItem
        });
    }
    /**
     * A list of series's main (ungrouped) data items.
     *
     * @return  Data items
     */
    get mainDataItems() {
        return this._mainDataItems;
    }
}
Object.defineProperty(XYSeries, "className", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: "XYSeries"
});
Object.defineProperty(XYSeries, "classNames", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: _core_render_Series__WEBPACK_IMPORTED_MODULE_0__.Series.classNames.concat([XYSeries.className])
});
//# sourceMappingURL=XYSeries.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/core/Registry.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/core/Registry.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Registry: () => (/* binding */ Registry),
/* harmony export */   addLicense: () => (/* binding */ addLicense),
/* harmony export */   disposeAllRootElements: () => (/* binding */ disposeAllRootElements),
/* harmony export */   registry: () => (/* binding */ registry)
/* harmony export */ });
/**
 * @ignore
 */
class Registry {
    constructor() {
        /**
         * Currently running version of amCharts.
         */
        Object.defineProperty(this, "version", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "5.6.2"
        });
        /**
         * List of applied licenses.
         * @ignore
         */
        Object.defineProperty(this, "licenses", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
        });
        /**
         * Entities that have their `id` setting set.
         */
        Object.defineProperty(this, "entitiesById", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {}
        });
        /**
         * All created [[Root]] elements.
         */
        Object.defineProperty(this, "rootElements", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
        });
    }
}
/**
    * @ignore
 */
const registry = new Registry();
/**
 * Adds a license, e.g.:
 *
 * ```TypeScript
 * am5.addLicense("xxxxxxxx");
 * ```
 * ```JavaScript
 * am5.addLicense("xxxxxxxx");
 * ```
 *
 * Multiple licenses can be added to cover for multiple products.
 *
 * @param  license  License key
 */
function addLicense(license) {
    registry.licenses.push(license);
}
/**
 * Disposes all [[Root]] elements.
 */
function disposeAllRootElements() {
    let root;
    while (root = registry.rootElements.pop()) {
        root.dispose();
    }
}
//# sourceMappingURL=Registry.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/core/Root.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/core/Root.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Root: () => (/* binding */ Root)
/* harmony export */ });
/* harmony import */ var _render_Container__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./render/Container */ "./node_modules/@amcharts/amcharts5/.internal/core/render/Container.js");
/* harmony import */ var _render_Text__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./render/Text */ "./node_modules/@amcharts/amcharts5/.internal/core/render/Text.js");
/* harmony import */ var _render_HorizontalLayout__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./render/HorizontalLayout */ "./node_modules/@amcharts/amcharts5/.internal/core/render/HorizontalLayout.js");
/* harmony import */ var _render_VerticalLayout__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./render/VerticalLayout */ "./node_modules/@amcharts/amcharts5/.internal/core/render/VerticalLayout.js");
/* harmony import */ var _render_GridLayout__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./render/GridLayout */ "./node_modules/@amcharts/amcharts5/.internal/core/render/GridLayout.js");
/* harmony import */ var _util_Disposer__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./util/Disposer */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Disposer.js");
/* harmony import */ var _util_ResizeSensor__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./util/ResizeSensor */ "./node_modules/@amcharts/amcharts5/.internal/core/util/ResizeSensor.js");
/* harmony import */ var _util_InterfaceColors__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./util/InterfaceColors */ "./node_modules/@amcharts/amcharts5/.internal/core/util/InterfaceColors.js");
/* harmony import */ var _render_Graphics__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./render/Graphics */ "./node_modules/@amcharts/amcharts5/.internal/core/render/Graphics.js");
/* harmony import */ var _render_Rectangle__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./render/Rectangle */ "./node_modules/@amcharts/amcharts5/.internal/core/render/Rectangle.js");
/* harmony import */ var _render_Tooltip__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./render/Tooltip */ "./node_modules/@amcharts/amcharts5/.internal/core/render/Tooltip.js");
/* harmony import */ var _util_NumberFormatter__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./util/NumberFormatter */ "./node_modules/@amcharts/amcharts5/.internal/core/util/NumberFormatter.js");
/* harmony import */ var _util_DateFormatter__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./util/DateFormatter */ "./node_modules/@amcharts/amcharts5/.internal/core/util/DateFormatter.js");
/* harmony import */ var _util_DurationFormatter__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./util/DurationFormatter */ "./node_modules/@amcharts/amcharts5/.internal/core/util/DurationFormatter.js");
/* harmony import */ var _util_Language__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util/Language */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Language.js");
/* harmony import */ var _util_EventDispatcher__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util/EventDispatcher */ "./node_modules/@amcharts/amcharts5/.internal/core/util/EventDispatcher.js");
/* harmony import */ var _themes_DefaultTheme__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ../themes/DefaultTheme */ "./node_modules/@amcharts/amcharts5/.internal/themes/DefaultTheme.js");
/* harmony import */ var _render_backend_CanvasRenderer__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./render/backend/CanvasRenderer */ "./node_modules/@amcharts/amcharts5/.internal/core/render/backend/CanvasRenderer.js");
/* harmony import */ var _util_Percent__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./util/Percent */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Percent.js");
/* harmony import */ var _util_Color__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./util/Color */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Color.js");
/* harmony import */ var _util_PopulateString__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./util/PopulateString */ "./node_modules/@amcharts/amcharts5/.internal/core/util/PopulateString.js");
/* harmony import */ var _Registry__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./Registry */ "./node_modules/@amcharts/amcharts5/.internal/core/Registry.js");
/* harmony import */ var _util_Order__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./util/Order */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Order.js");
/* harmony import */ var _util_Array__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./util/Array */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Array.js");
/* harmony import */ var _util_Object__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./util/Object */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Object.js");
/* harmony import */ var _util_Utils__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./util/Utils */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Utils.js");
/* harmony import */ var _util_Type__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./util/Type */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Type.js");
/* harmony import */ var _locales_en__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../locales/en */ "./node_modules/@amcharts/amcharts5/locales/en.js");




























function rAF(fps, callback) {
    if (fps == null) {
        requestAnimationFrame(callback);
    }
    else {
        setTimeout(() => {
            requestAnimationFrame(callback);
        }, 1000 / fps);
    }
}
// TODO implement Disposer
/**
 * Root element of the chart.
 *
 * @see {@link https://www.amcharts.com/docs/v5/getting-started/#Root_element} for more info
 */
class Root {
    constructor(id, settings = {}, isReal) {
        /**
         * A reference to original chart container (div element).
         */
        Object.defineProperty(this, "dom", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_inner", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_settings", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_isDirty", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        Object.defineProperty(this, "_isDirtyParents", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        Object.defineProperty(this, "_dirty", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {}
        });
        Object.defineProperty(this, "_dirtyParents", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {}
        });
        Object.defineProperty(this, "_dirtyBounds", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {}
        });
        Object.defineProperty(this, "_dirtyPositions", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {}
        });
        Object.defineProperty(this, "_ticker", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: null
        });
        Object.defineProperty(this, "_tickers", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
        });
        Object.defineProperty(this, "_updateTick", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: true
        });
        /**
         * Root's event dispatcher.
         *
         * @see {@link https://www.amcharts.com/docs/v5/concepts/events/} for more info
         */
        Object.defineProperty(this, "events", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new _util_EventDispatcher__WEBPACK_IMPORTED_MODULE_0__.EventDispatcher()
        });
        /**
         * @ignore
         * @todo needs description
         */
        Object.defineProperty(this, "animationTime", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: null
        });
        Object.defineProperty(this, "_animations", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
        });
        Object.defineProperty(this, "_renderer", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_rootContainer", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /**
         * Main content container.
         */
        Object.defineProperty(this, "container", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /**
         * A [[Container]] used to display tooltips in.
         */
        Object.defineProperty(this, "tooltipContainer", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_tooltipContainerSettings", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_tooltip", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        // Locale-related
        /**
         * @ignore
         */
        Object.defineProperty(this, "language", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: _util_Language__WEBPACK_IMPORTED_MODULE_1__.Language.new(this, {})
        });
        /**
         * Locale used by the chart.
         *
         * @see {@link https://www.amcharts.com/docs/v5/concepts/locales/}
         */
        Object.defineProperty(this, "locale", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: _locales_en__WEBPACK_IMPORTED_MODULE_2__["default"]
        });
        // Date-time related
        /**
         * Use UTC when formatting date/time.
         *
         * @see {@link https://www.amcharts.com/docs/v5/concepts/formatters/formatting-dates/#utc-and-time-zones} for more info
         */
        Object.defineProperty(this, "utc", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        /**
         * If set, will format date/time in specific time zone.
         *
         * The value should be named time zone, e.g.:
         * `"America/Vancouver"`, `"Australia/Sydney"`, `"UTC"`.
         *
         * NOTE: Using time zone feature may noticeable affect performance of the
         * chart, especially with large data sets, since every single date will need
         * to be recalculated.
         *
         * @see {@link https://www.amcharts.com/docs/v5/getting-started/root-element/#time-zone} for more info
         * @since 5.1.0
         */
        Object.defineProperty(this, "timezone", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /**
         * The maximum FPS that the Root will run at.
         *
         * If `undefined` it will run at the highest FPS.
         *
         * @see {@link https://www.amcharts.com/docs/v5/getting-started/root-element/#Performance} for more info
         */
        Object.defineProperty(this, "fps", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /**
         * Number formatter.
         *
         * @see {@link https://www.amcharts.com/docs/v5/concepts/formatters/formatting-numbers/} for more info
         */
        Object.defineProperty(this, "numberFormatter", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: _util_NumberFormatter__WEBPACK_IMPORTED_MODULE_3__.NumberFormatter.new(this, {})
        });
        /**
         * Date/time formatter.
         *
         * @see {@link https://www.amcharts.com/docs/v5/concepts/formatters/formatting-dates/} for more info
         */
        Object.defineProperty(this, "dateFormatter", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: _util_DateFormatter__WEBPACK_IMPORTED_MODULE_4__.DateFormatter.new(this, {})
        });
        /**
         * Duration formatter.
         *
         * @see {@link https://www.amcharts.com/docs/v5/concepts/formatters/formatting-dates/} for more info
         */
        Object.defineProperty(this, "durationFormatter", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: _util_DurationFormatter__WEBPACK_IMPORTED_MODULE_5__.DurationFormatter.new(this, {})
        });
        // Accessibility
        /**
         * Global tab index for using for the whole chart
         *
         * @see {@link https://www.amcharts.com/docs/v5/concepts/accessibility/} for more info
         */
        Object.defineProperty(this, "tabindex", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        //@todo maybe make this better
        Object.defineProperty(this, "_tabindexes", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
        });
        Object.defineProperty(this, "_a11yD", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        Object.defineProperty(this, "_focusElementDirty", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        Object.defineProperty(this, "_focusElementContainer", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_focusedSprite", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_isShift", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_keyboardDragPoint", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_tooltipElementContainer", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_readerAlertElement", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_logo", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_tooltipDiv", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /**
         * Used for dynamically-created CSS and JavaScript with strict source policies.
         */
        Object.defineProperty(this, "nonce", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /**
         * Special color set to be used for various controls.
         *
         * @see {@link https://www.amcharts.com/docs/v5/concepts/colors-gradients-and-patterns/#Interface_colors} for more info
         */
        Object.defineProperty(this, "interfaceColors", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /**
         * An instance of vertical layout object that can be used to set `layout` setting
         * of a [[Container]].
         *
         * @default VerticalLayout.new()
         */
        Object.defineProperty(this, "verticalLayout", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: _render_VerticalLayout__WEBPACK_IMPORTED_MODULE_6__.VerticalLayout.new(this, {})
        });
        /**
         * An instance of horizontal layout object that can be used to set `layout` setting
         * of a [[Container]].
         *
         * @default HorizontalLayout.new()
         */
        Object.defineProperty(this, "horizontalLayout", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: _render_HorizontalLayout__WEBPACK_IMPORTED_MODULE_7__.HorizontalLayout.new(this, {})
        });
        /**
         * An instance of grid layout object that can be used to set `layout` setting
         * of a [[Container]].
         *
         * @default VerticalLayout.new()
         */
        Object.defineProperty(this, "gridLayout", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: _render_GridLayout__WEBPACK_IMPORTED_MODULE_8__.GridLayout.new(this, {})
        });
        Object.defineProperty(this, "_paused", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        /**
         * Indicates whether chart should resized automatically when parent container
         * width and/or height changes.
         *
         * If disabled (`autoResize = false`) you can make the chart resize manually
         * by calling root element's `resize()` method.
         */
        Object.defineProperty(this, "autoResize", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: true
        });
        Object.defineProperty(this, "_fontHash", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: ""
        });
        Object.defineProperty(this, "_isDisposed", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        Object.defineProperty(this, "_disposers", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
        });
        Object.defineProperty(this, "_resizeSensorDisposer", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_tooltips", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
        });
        Object.defineProperty(this, "_htmlElementContainer", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_htmlEnabledContainers", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
        });
        if (!isReal) {
            throw new Error("You cannot use `new Class()`, instead use `Class.new()`");
        }
        this._settings = settings;
        if (settings.accessible == false) {
            this._a11yD = true;
        }
        if (settings.useSafeResolution == null) {
            settings.useSafeResolution = true;
        }
        let resolution;
        if (settings.useSafeResolution) {
            resolution = _util_Utils__WEBPACK_IMPORTED_MODULE_9__.getSafeResolution();
        }
        this._renderer = new _render_backend_CanvasRenderer__WEBPACK_IMPORTED_MODULE_10__.CanvasRenderer(resolution);
        let dom;
        if (id instanceof HTMLElement) {
            dom = id;
        }
        else {
            dom = document.getElementById(id);
        }
        _util_Array__WEBPACK_IMPORTED_MODULE_11__.each(_Registry__WEBPACK_IMPORTED_MODULE_12__.registry.rootElements, (root) => {
            if (root.dom === dom) {
                throw new Error("You cannot have multiple Roots on the same DOM node");
            }
        });
        this.interfaceColors = _util_InterfaceColors__WEBPACK_IMPORTED_MODULE_13__.InterfaceColors.new(this, {});
        if (dom === null) {
            throw new Error("Could not find HTML element with id `" + id + "`");
        }
        this.dom = dom;
        let inner = document.createElement("div");
        inner.style.position = "relative";
        inner.style.width = "100%";
        inner.style.height = "100%";
        dom.appendChild(inner);
        const tooltipContainerBounds = settings.tooltipContainerBounds;
        if (tooltipContainerBounds) {
            this._tooltipContainerSettings = tooltipContainerBounds;
        }
        this._inner = inner;
        this._updateComputedStyles();
        _Registry__WEBPACK_IMPORTED_MODULE_12__.registry.rootElements.push(this);
    }
    static new(id, settings) {
        const root = new Root(id, settings, true);
        root._init();
        return root;
    }
    moveDOM(id) {
        let dom;
        if (id instanceof HTMLElement) {
            dom = id;
        }
        else {
            dom = document.getElementById(id);
        }
        if (dom) {
            while (this.dom.childNodes.length > 0) {
                dom.appendChild(this.dom.childNodes[0]);
            }
            this.dom = dom;
            this._initResizeSensor();
            this.resize();
        }
    }
    _handleLogo() {
        if (this._logo) {
            const w = this.dom.offsetWidth;
            const h = this.dom.offsetHeight;
            if ((w <= 150) || (h <= 60)) {
                this._logo.hide();
            }
            else {
                this._logo.show();
            }
        }
    }
    _showBranding() {
        if (!this._logo) {
            const logo = this.tooltipContainer.children.push(_render_Container__WEBPACK_IMPORTED_MODULE_14__.Container.new(this, {
                interactive: true,
                interactiveChildren: false,
                position: "absolute",
                setStateOnChildren: true,
                paddingTop: 9,
                paddingRight: 9,
                paddingBottom: 9,
                paddingLeft: 9,
                scale: .6,
                y: (0,_util_Percent__WEBPACK_IMPORTED_MODULE_15__.percent)(100),
                centerY: _util_Percent__WEBPACK_IMPORTED_MODULE_15__.p100,
                tooltipText: "Created using amCharts 5",
                tooltipX: _util_Percent__WEBPACK_IMPORTED_MODULE_15__.p100,
                cursorOverStyle: "pointer",
                background: _render_Rectangle__WEBPACK_IMPORTED_MODULE_16__.Rectangle.new(this, {
                    fill: (0,_util_Color__WEBPACK_IMPORTED_MODULE_17__.color)(0x474758),
                    fillOpacity: 0,
                    tooltipY: 5
                })
            }));
            const tooltip = _render_Tooltip__WEBPACK_IMPORTED_MODULE_18__.Tooltip.new(this, {
                pointerOrientation: "horizontal",
                paddingTop: 4,
                paddingRight: 7,
                paddingBottom: 4,
                paddingLeft: 7
            });
            tooltip.label.setAll({
                fontSize: 12
            });
            tooltip.get("background").setAll({
                fill: this.interfaceColors.get("background"),
                stroke: this.interfaceColors.get("grid"),
                strokeOpacity: 0.3
            });
            logo.set("tooltip", tooltip);
            logo.events.on("click", () => {
                window.open("https://www.amcharts.com/", "_blank");
            });
            logo.states.create("hover", {});
            const m = logo.children.push(_render_Graphics__WEBPACK_IMPORTED_MODULE_19__.Graphics.new(this, {
                stroke: (0,_util_Color__WEBPACK_IMPORTED_MODULE_17__.color)(0xcccccc),
                strokeWidth: 3,
                svgPath: "M5 25 L13 25h13.6c3.4 0 6 0 10.3-4.3s5.2-12 8.6-12c3.4 0 4.3 8.6 7.7 8.6M83.4 25H79.8c-3.4 0-6 0-10.3-4.3s-5.2-12-8.6-12-4.3 8.6-7.7 8.6"
            }));
            m.states.create("hover", { stroke: (0,_util_Color__WEBPACK_IMPORTED_MODULE_17__.color)(0x3CABFF) });
            const a = logo.children.push(_render_Graphics__WEBPACK_IMPORTED_MODULE_19__.Graphics.new(this, {
                stroke: (0,_util_Color__WEBPACK_IMPORTED_MODULE_17__.color)(0x888888),
                strokeWidth: 3,
                svgPath: "M83.4 25h-31C37 25 39.5 4.4 28.4 4.4S18.9 24.2 4.3 25H0"
            }));
            a.states.create("hover", { stroke: (0,_util_Color__WEBPACK_IMPORTED_MODULE_17__.color)(0x474758) });
            //logo.set("tooltip", this._tooltip);
            //logo.setPrivate("tooltipTarget", logo.get("background"));
            this._logo = logo;
            this._handleLogo();
        }
    }
    _getRealSize() {
        return this.dom.getBoundingClientRect();
    }
    _getCalculatedSize(rect) {
        if (this._settings.calculateSize) {
            return this._settings.calculateSize(rect);
        }
        else {
            return {
                width: rect.width,
                height: rect.height,
            };
        }
    }
    _init() {
        const settings = this._settings;
        if (settings.accessible !== false) {
            if (settings.focusable) {
                this._inner.setAttribute("focusable", "true");
                this._inner.setAttribute("tabindex", this.tabindex + "");
            }
            if (settings.ariaLabel) {
                this._inner.setAttribute("aria-label", settings.ariaLabel);
            }
            if (settings.role) {
                this._inner.setAttribute("role", settings.role);
            }
        }
        const renderer = this._renderer;
        const rect = this._getRealSize();
        const size = this._getCalculatedSize(rect);
        const width = Math.floor(size.width);
        const height = Math.floor(size.height);
        const realWidth = Math.floor(rect.width);
        const realHeight = Math.floor(rect.height);
        const rootContainer = _render_Container__WEBPACK_IMPORTED_MODULE_14__.Container.new(this, {
            visible: true,
            width: width,
            height: height,
        });
        this._rootContainer = rootContainer;
        this._rootContainer._defaultThemes.push(_themes_DefaultTheme__WEBPACK_IMPORTED_MODULE_20__.DefaultTheme.new(this));
        const container = rootContainer.children.push(_render_Container__WEBPACK_IMPORTED_MODULE_14__.Container.new(this, { visible: true, width: _util_Percent__WEBPACK_IMPORTED_MODULE_15__.p100, height: _util_Percent__WEBPACK_IMPORTED_MODULE_15__.p100 }));
        this.container = container;
        renderer.resize(realWidth, realHeight, width, height);
        //@todo: better appendChild - refer
        this._inner.appendChild(renderer.view);
        // TODO: TMP TMP TMP for testing only, remove
        //renderer.debugGhostView = true;
        this._initResizeSensor();
        // HTML content holder
        const htmlElementContainer = document.createElement("div");
        this._htmlElementContainer = htmlElementContainer;
        htmlElementContainer.className = "am5-html-container";
        htmlElementContainer.style.position = "absolute";
        htmlElementContainer.style.pointerEvents = "none";
        if (!this._tooltipContainerSettings) {
            htmlElementContainer.style.overflow = "hidden";
        }
        this._inner.appendChild(htmlElementContainer);
        if (this._a11yD !== true) {
            // Create element which is used to make announcements to screen reader
            const readerAlertElement = document.createElement("div");
            readerAlertElement.className = "am5-reader-container";
            readerAlertElement.setAttribute("role", "alert");
            // readerAlertElement.style.zIndex = "-100000";
            // readerAlertElement.style.opacity = "0";
            // readerAlertElement.style.top = "0";
            readerAlertElement.style.position = "absolute";
            readerAlertElement.style.width = "1px";
            readerAlertElement.style.height = "1px";
            readerAlertElement.style.overflow = "hidden";
            readerAlertElement.style.clip = "rect(1px, 1px, 1px, 1px)";
            this._readerAlertElement = readerAlertElement;
            this._inner.appendChild(this._readerAlertElement);
            const focusElementContainer = document.createElement("div");
            focusElementContainer.className = "am5-focus-container";
            focusElementContainer.style.position = "absolute";
            focusElementContainer.style.pointerEvents = "none";
            focusElementContainer.style.top = "0px";
            focusElementContainer.style.left = "0px";
            focusElementContainer.style.overflow = "hidden";
            focusElementContainer.style.width = width + "px";
            focusElementContainer.style.height = height + "px";
            focusElementContainer.setAttribute("role", "graphics-document");
            _util_Utils__WEBPACK_IMPORTED_MODULE_9__.setInteractive(focusElementContainer, false);
            this._focusElementContainer = focusElementContainer;
            this._inner.appendChild(this._focusElementContainer);
            const tooltipElementContainer = document.createElement("div");
            this._tooltipElementContainer = tooltipElementContainer;
            tooltipElementContainer.className = "am5-tooltip-container";
            this._inner.appendChild(tooltipElementContainer);
            // Add keyboard events for accessibility, e.g. simulating drag with arrow
            // keys and click with ENTER
            if (_util_Utils__WEBPACK_IMPORTED_MODULE_9__.supports("keyboardevents")) {
                this._disposers.push(_util_Utils__WEBPACK_IMPORTED_MODULE_9__.addEventListener(window, "keydown", (ev) => {
                    if (ev.keyCode == 16) {
                        this._isShift = true;
                    }
                    else if (ev.keyCode == 9) {
                        this._isShift = ev.shiftKey;
                    }
                }));
                this._disposers.push(_util_Utils__WEBPACK_IMPORTED_MODULE_9__.addEventListener(window, "keyup", (ev) => {
                    if (ev.keyCode == 16) {
                        this._isShift = false;
                    }
                }));
                this._disposers.push(_util_Utils__WEBPACK_IMPORTED_MODULE_9__.addEventListener(focusElementContainer, "click", () => {
                    // Some screen readers convert ENTER (and some SPACE) press whil on
                    // focused element to a "click" event, preventing actual "keydown"
                    // event from firing. We're using this "click" event to still
                    // generate internal click events.
                    const focusedSprite = this._focusedSprite;
                    if (focusedSprite) {
                        const downEvent = renderer.getEvent(new MouseEvent("click"));
                        focusedSprite.events.dispatch("click", {
                            type: "click",
                            originalEvent: downEvent.event,
                            point: downEvent.point,
                            simulated: true,
                            target: focusedSprite
                        });
                    }
                }));
                this._disposers.push(_util_Utils__WEBPACK_IMPORTED_MODULE_9__.addEventListener(focusElementContainer, "keydown", (ev) => {
                    const focusedSprite = this._focusedSprite;
                    if (focusedSprite) {
                        if (ev.keyCode == 27) {
                            // ESC pressed - lose current focus
                            _util_Utils__WEBPACK_IMPORTED_MODULE_9__.blur();
                            this._focusedSprite = undefined;
                        }
                        let dragOffsetX = 0;
                        let dragOffsetY = 0;
                        // TODO: figure out if using bogus MouseEvent is fine, or it will
                        // fail on some platforms
                        switch (ev.keyCode) {
                            case 13:
                                ev.preventDefault();
                                const downEvent = renderer.getEvent(new MouseEvent("click"));
                                focusedSprite.events.dispatch("click", {
                                    type: "click",
                                    originalEvent: downEvent.event,
                                    point: downEvent.point,
                                    simulated: true,
                                    target: focusedSprite
                                });
                                return;
                            case 37:
                                dragOffsetX = -6;
                                break;
                            case 39:
                                dragOffsetX = 6;
                                break;
                            case 38:
                                dragOffsetY = -6;
                                break;
                            case 40:
                                dragOffsetY = 6;
                                break;
                            default:
                                return;
                        }
                        if (dragOffsetX != 0 || dragOffsetY != 0) {
                            ev.preventDefault();
                            if (!focusedSprite.isDragging()) {
                                // Start dragging
                                this._keyboardDragPoint = {
                                    x: 0,
                                    y: 0
                                };
                                const downEvent = renderer.getEvent(new MouseEvent("mousedown", {
                                    clientX: 0,
                                    clientY: 0
                                }));
                                if (focusedSprite.events.isEnabled("pointerdown")) {
                                    focusedSprite.events.dispatch("pointerdown", {
                                        type: "pointerdown",
                                        originalEvent: downEvent.event,
                                        point: downEvent.point,
                                        simulated: true,
                                        target: focusedSprite
                                    });
                                }
                            }
                            else {
                                // Move focus marker
                                //this._positionFocusElement(focusedSprite);
                            }
                            // Move incrementally
                            const dragPoint = this._keyboardDragPoint;
                            dragPoint.x += dragOffsetX;
                            dragPoint.y += dragOffsetY;
                            const moveEvent = renderer.getEvent(new MouseEvent("mousemove", {
                                clientX: dragPoint.x,
                                clientY: dragPoint.y
                            }), false);
                            if (focusedSprite.events.isEnabled("globalpointermove")) {
                                focusedSprite.events.dispatch("globalpointermove", {
                                    type: "globalpointermove",
                                    originalEvent: moveEvent.event,
                                    point: moveEvent.point,
                                    simulated: true,
                                    target: focusedSprite
                                });
                            }
                        }
                    }
                }));
                this._disposers.push(_util_Utils__WEBPACK_IMPORTED_MODULE_9__.addEventListener(focusElementContainer, "keyup", (ev) => {
                    if (this._focusedSprite) {
                        const focusedSprite = this._focusedSprite;
                        const keyCode = ev.keyCode;
                        switch (keyCode) {
                            case 37:
                            case 39:
                            case 38:
                            case 40:
                                if (focusedSprite.isDragging()) {
                                    // Simulate drag stop
                                    const dragPoint = this._keyboardDragPoint;
                                    const upEvent = renderer.getEvent(new MouseEvent("mouseup", {
                                        clientX: dragPoint.x,
                                        clientY: dragPoint.y
                                    }));
                                    if (focusedSprite.events.isEnabled("globalpointerup")) {
                                        focusedSprite.events.dispatch("globalpointerup", {
                                            type: "globalpointerup",
                                            originalEvent: upEvent.event,
                                            point: upEvent.point,
                                            simulated: true,
                                            target: focusedSprite
                                        });
                                    }
                                    //this._positionFocusElement(focusedSprite);
                                    this._keyboardDragPoint = undefined;
                                    // @todo dispatch mouseup event instead of calling dragStop?
                                    // this._dispatchEvent("globalpointerup", target, upEvent);
                                    return;
                                }
                                else if (focusedSprite.get("focusableGroup")) {
                                    // Find next item in focusable group
                                    const group = focusedSprite.get("focusableGroup");
                                    const items = this._tabindexes.filter((item) => {
                                        return item.get("focusableGroup") == group && item.getPrivate("focusable") !== false ? true : false;
                                    });
                                    let index = items.indexOf(focusedSprite);
                                    const lastIndex = items.length - 1;
                                    index += (keyCode == 39 || keyCode == 40) ? 1 : -1;
                                    if (index < 0) {
                                        index = lastIndex;
                                    }
                                    else if (index > lastIndex) {
                                        index = 0;
                                    }
                                    _util_Utils__WEBPACK_IMPORTED_MODULE_9__.focus(items[index].getPrivate("focusElement").dom);
                                }
                                break;
                        }
                    }
                }));
            }
        }
        this._startTicker();
        this.setThemes([]);
        this._addTooltip();
        if (!this._hasLicense()) {
            this._showBranding();
        }
    }
    _initResizeSensor() {
        if (this._resizeSensorDisposer) {
            this._resizeSensorDisposer.dispose();
        }
        this._resizeSensorDisposer = new _util_ResizeSensor__WEBPACK_IMPORTED_MODULE_21__.ResizeSensor(this.dom, () => {
            if (this.autoResize) {
                this.resize();
            }
        });
        this._disposers.push(this._resizeSensorDisposer);
    }
    /**
     * If automatic resizing of char is disabled (`root.autoResize = false`), it
     * can be resized manually by calling this method.
     */
    resize() {
        const rect = this._getRealSize();
        const size = this._getCalculatedSize(rect);
        const w = Math.floor(size.width);
        const h = Math.floor(size.height);
        if (w > 0 && h > 0) {
            const realWidth = Math.floor(rect.width);
            const realHeight = Math.floor(rect.height);
            const htmlElementContainer = this._htmlElementContainer;
            htmlElementContainer.style.width = w + "px";
            htmlElementContainer.style.height = h + "px";
            if (this._a11yD !== true) {
                const focusElementContainer = this._focusElementContainer;
                focusElementContainer.style.width = w + "px";
                focusElementContainer.style.height = h + "px";
            }
            this._renderer.resize(realWidth, realHeight, w, h);
            const rootContainer = this._rootContainer;
            rootContainer.setPrivate("width", w);
            rootContainer.setPrivate("height", h);
            this._render();
            this._handleLogo();
        }
    }
    _render() {
        this._renderer.render(this._rootContainer._display);
        if (this._focusElementDirty) {
            this._updateCurrentFocus();
            this._focusElementDirty = false;
        }
    }
    _runTickers(currentTime) {
        _util_Array__WEBPACK_IMPORTED_MODULE_11__.each(this._tickers, (f) => {
            f(currentTime);
        });
    }
    _runAnimations(currentTime) {
        _util_Array__WEBPACK_IMPORTED_MODULE_11__.keepIf(this._animations, (animation) => {
            return animation._runAnimation(currentTime);
        });
    }
    _runDirties() {
        //console.log("tick **************************************************************");
        let allParents = {};
        while (this._isDirtyParents) {
            // This must be before calling _prepareChildren
            this._isDirtyParents = false;
            _util_Object__WEBPACK_IMPORTED_MODULE_22__.keys(this._dirtyParents).forEach((key) => {
                const parent = this._dirtyParents[key];
                delete this._dirtyParents[key];
                if (!parent.isDisposed()) {
                    allParents[parent.uid] = parent;
                    parent._prepareChildren();
                }
            });
        }
        _util_Object__WEBPACK_IMPORTED_MODULE_22__.keys(allParents).forEach((key) => {
            allParents[key]._updateChildren();
        });
        const objects = [];
        //		console.log("_beforeChanged")
        _util_Object__WEBPACK_IMPORTED_MODULE_22__.keys(this._dirty).forEach((key) => {
            const entity = this._dirty[key];
            if (entity.isDisposed()) {
                delete this._dirty[entity.uid];
            }
            else {
                objects.push(entity);
                entity._beforeChanged();
            }
        });
        //		console.log("_changed")
        objects.forEach((entity) => {
            entity._changed();
            delete this._dirty[entity.uid];
            entity._clearDirty();
        });
        this._isDirty = false;
        const depths = {};
        const bounds = [];
        _util_Object__WEBPACK_IMPORTED_MODULE_22__.keys(this._dirtyBounds).forEach((key) => {
            const entity = this._dirtyBounds[key];
            delete this._dirtyBounds[key];
            if (!entity.isDisposed()) {
                depths[entity.uid] = entity.depth();
                bounds.push(entity);
            }
        });
        this._positionHTMLElements();
        // High depth -> low depth
        bounds.sort((x, y) => {
            return _util_Order__WEBPACK_IMPORTED_MODULE_23__.compare(depths[y.uid], depths[x.uid]);
        });
        //		console.log("_updateBounds")
        bounds.forEach((entity) => {
            entity._updateBounds();
        });
        //		console.log("_updatePosition")
        const dirtyPositions = this._dirtyPositions;
        _util_Object__WEBPACK_IMPORTED_MODULE_22__.keys(dirtyPositions).forEach((key) => {
            const sprite = dirtyPositions[key];
            delete dirtyPositions[key];
            if (!sprite.isDisposed()) {
                sprite._updatePosition();
            }
        });
        //		console.log("_afterChanged")
        objects.forEach((entity) => {
            entity._afterChanged();
        });
    }
    _renderFrame(currentTime) {
        if (this._updateTick) {
            if (this.events.isEnabled("framestarted")) {
                this.events.dispatch("framestarted", {
                    type: "framestarted",
                    target: this,
                    timestamp: currentTime,
                });
            }
            this._checkComputedStyles();
            this._runTickers(currentTime);
            this._runAnimations(currentTime);
            this._runDirties();
            this._render();
            this._positionHTMLElements();
            if (this.events.isEnabled("frameended")) {
                this.events.dispatch("frameended", {
                    type: "frameended",
                    target: this,
                    timestamp: currentTime,
                });
            }
            return this._tickers.length === 0 &&
                this._animations.length === 0 &&
                !this._isDirty;
        }
        else {
            return true;
        }
    }
    _runTicker(currentTime, now) {
        if (!this.isDisposed()) {
            this.animationTime = currentTime;
            const done = this._renderFrame(currentTime);
            // No more work to do
            if (done) {
                this._ticker = null;
                this.animationTime = null;
            }
            else {
                if (!this._paused) {
                    if (now) {
                        this._ticker;
                    }
                    else {
                        rAF(this.fps, this._ticker);
                    }
                }
            }
        }
    }
    _runTickerNow(timeout = 10000) {
        if (!this.isDisposed()) {
            const endTime = performance.now() + timeout;
            for (;;) {
                const currentTime = performance.now();
                if (currentTime >= endTime) {
                    this.animationTime = null;
                    break;
                }
                this.animationTime = currentTime;
                const done = this._renderFrame(currentTime);
                if (done) {
                    this.animationTime = null;
                    break;
                }
            }
        }
    }
    _startTicker() {
        if (this._ticker === null) {
            this.animationTime = null;
            this._ticker = (currentTime) => {
                this._runTicker(currentTime);
            };
            rAF(this.fps, this._ticker);
        }
    }
    /**
     * Returns whether the root is updating or not.
     */
    get updateTick() {
        return this._updateTick;
    }
    /**
     * Enables or disables the root updating.
     */
    set updateTick(value) {
        this._updateTick = value;
        if (value) {
            this._startTicker();
        }
    }
    _addDirtyEntity(entity) {
        if (this._dirty[entity.uid] === undefined) {
            this._isDirty = true;
            this._dirty[entity.uid] = entity;
            this._startTicker();
        }
    }
    _addDirtyParent(parent) {
        if (this._dirtyParents[parent.uid] === undefined) {
            this._isDirty = true;
            this._isDirtyParents = true;
            this._dirtyParents[parent.uid] = parent;
            this._startTicker();
        }
    }
    _addDirtyBounds(entity) {
        if (this._dirtyBounds[entity.uid] === undefined) {
            this._isDirty = true;
            this._dirtyBounds[entity.uid] = entity;
            this._startTicker();
        }
    }
    _addDirtyPosition(sprite) {
        if (this._dirtyPositions[sprite.uid] === undefined) {
            this._isDirty = true;
            this._dirtyPositions[sprite.uid] = sprite;
            this._startTicker();
        }
    }
    _addAnimation(animation) {
        // TODO use numeric id instead
        if (this._animations.indexOf(animation) === -1) {
            this._animations.push(animation);
            this._startTicker();
        }
    }
    _markDirty() {
        this._isDirty = true;
    }
    _markDirtyRedraw() {
        this.events.once("frameended", () => {
            this._isDirty = true;
            this._startTicker();
        });
    }
    eachFrame(f) {
        this._tickers.push(f);
        this._startTicker();
        return new _util_Disposer__WEBPACK_IMPORTED_MODULE_24__.Disposer(() => {
            _util_Array__WEBPACK_IMPORTED_MODULE_11__.removeFirst(this._tickers, f);
        });
    }
    markDirtyGlobal(container) {
        if (!container) {
            container = this.container;
        }
        container.walkChildren((child) => {
            if (child instanceof _render_Container__WEBPACK_IMPORTED_MODULE_14__.Container) {
                this.markDirtyGlobal(child);
            }
            child.markDirty();
            child.markDirtyBounds();
        });
    }
    /**
     * Returns width of the target container, in pixels.
     *
     * @return Width
     */
    width() {
        // TODO make this more efficient, maybe just return the renderer's width ?
        return Math.floor(this._getCalculatedSize(this._getRealSize()).width);
    }
    /**
     * Returns height of the target container, in pixels.
     *
     * @return Height
     */
    height() {
        // TODO make this more efficient, maybe just return the renderer's height ?
        return Math.floor(this._getCalculatedSize(this._getRealSize()).height);
    }
    /**
     * Disposes root and all the content in it.
     */
    dispose() {
        if (!this._isDisposed) {
            this._isDisposed = true;
            this._rootContainer.dispose();
            this._renderer.dispose();
            this.horizontalLayout.dispose();
            this.verticalLayout.dispose();
            this.interfaceColors.dispose();
            _util_Array__WEBPACK_IMPORTED_MODULE_11__.each(this._disposers, (x) => {
                x.dispose();
            });
            if (this._inner) {
                _util_Utils__WEBPACK_IMPORTED_MODULE_9__.removeElement(this._inner);
            }
            _util_Array__WEBPACK_IMPORTED_MODULE_11__.remove(_Registry__WEBPACK_IMPORTED_MODULE_12__.registry.rootElements, this);
        }
    }
    /**
     * Returns `true` if root element is disposed.
     *
     * @return Disposed?
     */
    isDisposed() {
        return this._isDisposed;
    }
    /**
     * Triggers screen reader read out a message.
     *
     * @see {@link https://www.amcharts.com/docs/v5/concepts/accessibility/} for more info
     * @param  text  Alert text
     */
    readerAlert(text) {
        if (this._a11yD !== true) {
            this._readerAlertElement.innerHTML = _util_Utils__WEBPACK_IMPORTED_MODULE_9__.stripTags(text);
        }
    }
    /**
     * Sets themes to be used for the chart.
     *
     * @see {@link https://www.amcharts.com/docs/v5/concepts/themes/} for more info
     * @param  themes  A list of themes
     */
    setThemes(themes) {
        this._rootContainer.set("themes", themes);
        // otherwise new themes are not applied
        const tooltipContainer = this.tooltipContainer;
        if (tooltipContainer) {
            tooltipContainer._applyThemes();
        }
        // @todo review this
        const interfaceColors = this.interfaceColors;
        if (interfaceColors) {
            interfaceColors._applyThemes();
        }
    }
    _addTooltip() {
        if (!this.tooltipContainer) {
            const tooltipContainerSettings = this._tooltipContainerSettings;
            const tooltipContainer = this._rootContainer.children.push(_render_Container__WEBPACK_IMPORTED_MODULE_14__.Container.new(this, {
                position: "absolute",
                isMeasured: false,
                width: _util_Percent__WEBPACK_IMPORTED_MODULE_15__.p100,
                height: _util_Percent__WEBPACK_IMPORTED_MODULE_15__.p100,
                layer: tooltipContainerSettings ? 35 : 30,
                layerMargin: tooltipContainerSettings ? tooltipContainerSettings : undefined
            }));
            this.tooltipContainer = tooltipContainer;
            const tooltip = _render_Tooltip__WEBPACK_IMPORTED_MODULE_18__.Tooltip.new(this, {});
            this.container.set("tooltip", tooltip);
            tooltip.hide(0);
            this._tooltip = tooltip;
        }
    }
    /**
     * Accesibility
     */
    _registerTabindexOrder(target) {
        if (this._a11yD == true) {
            return;
        }
        if (target.get("focusable")) {
            _util_Array__WEBPACK_IMPORTED_MODULE_11__.pushOne(this._tabindexes, target);
        }
        else {
            _util_Array__WEBPACK_IMPORTED_MODULE_11__.remove(this._tabindexes, target);
        }
        this._invalidateTabindexes();
    }
    _unregisterTabindexOrder(target) {
        if (this._a11yD == true) {
            return;
        }
        _util_Array__WEBPACK_IMPORTED_MODULE_11__.remove(this._tabindexes, target);
        this._invalidateTabindexes();
    }
    _invalidateTabindexes() {
        if (this._a11yD == true) {
            return;
        }
        this._tabindexes.sort((a, b) => {
            const aindex = a.get("tabindexOrder", 0);
            const bindex = b.get("tabindexOrder", 0);
            if (aindex == bindex) {
                return 0;
            }
            else if (aindex > bindex) {
                return 1;
            }
            else {
                return -1;
            }
        });
        const groups = [];
        _util_Array__WEBPACK_IMPORTED_MODULE_11__.each(this._tabindexes, (item, index) => {
            if (!item.getPrivate("focusElement")) {
                this._makeFocusElement(index, item);
            }
            else {
                this._moveFocusElement(index, item);
            }
            const group = item.get("focusableGroup");
            if (group && item.getPrivate("focusable") !== false) {
                if (groups.indexOf(group) !== -1) {
                    // Non-first element in the group, make it not directly focusable
                    item.getPrivate("focusElement").dom.setAttribute("tabindex", "-1");
                }
                else {
                    groups.push(group);
                }
            }
        });
    }
    _updateCurrentFocus() {
        if (this._a11yD == true) {
            return;
        }
        if (this._focusedSprite) {
            this._decorateFocusElement(this._focusedSprite);
            this._positionFocusElement(this._focusedSprite);
        }
    }
    _decorateFocusElement(target, focusElement) {
        if (this._a11yD == true) {
            return;
        }
        // Decorate with proper accessibility attributes
        if (!focusElement) {
            focusElement = target.getPrivate("focusElement").dom;
        }
        if (!focusElement) {
            return;
        }
        const role = target.get("role");
        if (role) {
            focusElement.setAttribute("role", role);
        }
        else {
            focusElement.removeAttribute("role");
        }
        const ariaLabel = target.get("ariaLabel");
        if (ariaLabel) {
            const label = (0,_util_PopulateString__WEBPACK_IMPORTED_MODULE_25__.populateString)(target, ariaLabel);
            focusElement.setAttribute("aria-label", label);
        }
        else {
            focusElement.removeAttribute("aria-label");
        }
        const ariaLive = target.get("ariaLive");
        if (ariaLive) {
            focusElement.setAttribute("aria-live", ariaLive);
        }
        else {
            focusElement.removeAttribute("aria-live");
        }
        const ariaChecked = target.get("ariaChecked");
        if (ariaChecked != null) {
            focusElement.setAttribute("aria-checked", ariaChecked ? "true" : "false");
        }
        else {
            focusElement.removeAttribute("aria-checked");
        }
        if (target.get("ariaHidden")) {
            focusElement.setAttribute("aria-hidden", "true");
        }
        else {
            focusElement.removeAttribute("aria-hidden");
        }
        const ariaOrientation = target.get("ariaOrientation");
        if (ariaOrientation) {
            focusElement.setAttribute("aria-orientation", ariaOrientation);
        }
        else {
            focusElement.removeAttribute("aria-orientation");
        }
        const ariaValueNow = target.get("ariaValueNow");
        if (ariaValueNow) {
            focusElement.setAttribute("aria-valuenow", ariaValueNow);
        }
        else {
            focusElement.removeAttribute("aria-valuenow");
        }
        const ariaValueMin = target.get("ariaValueMin");
        if (ariaValueMin) {
            focusElement.setAttribute("aria-valuemin", ariaValueMin);
        }
        else {
            focusElement.removeAttribute("aria-valuemin");
        }
        const ariaValueMax = target.get("ariaValueMax");
        if (ariaValueMax) {
            focusElement.setAttribute("aria-valuemax", ariaValueMax);
        }
        else {
            focusElement.removeAttribute("aria-valuemax");
        }
        const ariaValueText = target.get("ariaValueText");
        if (ariaValueText) {
            focusElement.setAttribute("aria-valuetext", ariaValueText);
        }
        else {
            focusElement.removeAttribute("aria-valuetext");
        }
        const ariaControls = target.get("ariaControls");
        if (ariaControls) {
            focusElement.setAttribute("aria-controls", ariaControls);
        }
        else {
            focusElement.removeAttribute("aria-controls");
        }
        if (target.get("visible") && target.get("opacity") !== 0 && target.get("role") != "tooltip" && !target.isHidden() && target.getPrivate("focusable") !== false) {
            if (focusElement.getAttribute("tabindex") != "-1") {
                focusElement.setAttribute("tabindex", "" + this.tabindex);
            }
            focusElement.removeAttribute("aria-hidden");
        }
        else {
            focusElement.removeAttribute("tabindex");
            focusElement.setAttribute("aria-hidden", "true");
        }
    }
    _makeFocusElement(index, target) {
        if (target.getPrivate("focusElement") || this._a11yD == true) {
            return;
        }
        // Init
        const focusElement = document.createElement("div");
        if (target.get("role") != "tooltip") {
            focusElement.tabIndex = this.tabindex;
        }
        focusElement.style.position = "absolute";
        _util_Utils__WEBPACK_IMPORTED_MODULE_9__.setInteractive(focusElement, false);
        const disposers = [];
        target.setPrivate("focusElement", {
            dom: focusElement,
            disposers,
        });
        this._decorateFocusElement(target);
        disposers.push(_util_Utils__WEBPACK_IMPORTED_MODULE_9__.addEventListener(focusElement, "focus", (ev) => {
            this._handleFocus(ev, index);
        }));
        disposers.push(_util_Utils__WEBPACK_IMPORTED_MODULE_9__.addEventListener(focusElement, "blur", (ev) => {
            this._handleBlur(ev, index);
        }));
        this._moveFocusElement(index, target);
    }
    _removeFocusElement(target) {
        if (this._a11yD == true) {
            return;
        }
        _util_Array__WEBPACK_IMPORTED_MODULE_11__.remove(this._tabindexes, target);
        const focusElement = target.getPrivate("focusElement");
        if (focusElement) {
            const container = this._focusElementContainer;
            container.removeChild(focusElement.dom);
            _util_Array__WEBPACK_IMPORTED_MODULE_11__.each(focusElement.disposers, (x) => {
                x.dispose();
            });
        }
    }
    _hideFocusElement(target) {
        if (this._a11yD == true) {
            return;
        }
        const focusElement = target.getPrivate("focusElement");
        focusElement.dom.style.display = "none";
    }
    _moveFocusElement(index, target) {
        if (this._a11yD == true) {
            return;
        }
        // Get container
        const container = this._focusElementContainer;
        const focusElement = target.getPrivate("focusElement").dom;
        if (focusElement === this._focusElementContainer.children[index]) {
            // Nothing to do
            return;
        }
        const next = this._focusElementContainer.children[index + 1];
        if (next) {
            container.insertBefore(focusElement, next);
        }
        else {
            container.append(focusElement);
        }
    }
    _positionFocusElement(target) {
        if (this._a11yD == true || target == undefined) {
            return;
        }
        const bounds = target.globalBounds();
        let width = bounds.right == bounds.left ? target.width() : bounds.right - bounds.left;
        let height = bounds.top == bounds.bottom ? target.height() : bounds.bottom - bounds.top;
        const padding = this._settings.focusPadding !== undefined ? this._settings.focusPadding : 2;
        let x = bounds.left - padding;
        let y = bounds.top - padding;
        if (width < 0) {
            x += width;
            width = Math.abs(width);
        }
        if (height < 0) {
            y += height;
            height = Math.abs(height);
        }
        const focusElement = target.getPrivate("focusElement").dom;
        focusElement.style.top = y + "px";
        focusElement.style.left = x + "px";
        focusElement.style.width = (width + padding * 2) + "px";
        focusElement.style.height = (height + padding * 2) + "px";
    }
    _handleFocus(ev, index) {
        if (this._a11yD == true) {
            return;
        }
        // Get element
        const focused = this._tabindexes[index];
        // Jump over hidden elements
        if (!focused.isVisibleDeep()) {
            this._focusNext(ev.target, this._isShift ? -1 : 1);
            return;
        }
        // Size and position
        this._positionFocusElement(focused);
        //this._decorateFocusElement(focused);
        this._focusedSprite = focused;
        if (focused.events.isEnabled("focus")) {
            focused.events.dispatch("focus", {
                type: "focus",
                originalEvent: ev,
                target: focused
            });
        }
    }
    _focusNext(el, direction) {
        if (this._a11yD == true) {
            return;
        }
        const focusableElements = Array.from(document.querySelectorAll([
            'a[href]',
            'area[href]',
            'button:not([disabled])',
            'details',
            'input:not([disabled])',
            'iframe:not([disabled])',
            'select:not([disabled])',
            'textarea:not([disabled])',
            '[contentEditable=""]',
            '[contentEditable="true"]',
            '[contentEditable="TRUE"]',
            '[tabindex]:not([tabindex^="-"])',
            //':not([disabled])'
        ].join(',')));
        let index = focusableElements.indexOf(el) + direction;
        if (index < 0) {
            index = focusableElements.length - 1;
        }
        else if (index >= focusableElements.length) {
            index = 0;
        }
        focusableElements[index].focus();
    }
    _handleBlur(ev, _index) {
        if (this._a11yD == true) {
            return;
        }
        const focused = this._focusedSprite;
        if (focused && !focused.isDisposed() && focused.events.isEnabled("blur")) {
            focused.events.dispatch("blur", {
                type: "blur",
                originalEvent: ev,
                target: focused
            });
        }
        this._focusedSprite = undefined;
    }
    /**
     * @ignore
     */
    updateTooltip(target) {
        if (this._a11yD == true) {
            return;
        }
        const text = _util_Utils__WEBPACK_IMPORTED_MODULE_9__.stripTags(target._getText());
        let tooltipElement = target.getPrivate("tooltipElement");
        if (target.get("role") == "tooltip" && text != "") {
            if (!tooltipElement) {
                tooltipElement = this._makeTooltipElement(target);
            }
            if (tooltipElement.innerHTML != text) {
                tooltipElement.innerHTML = text;
            }
        }
        else if (tooltipElement) {
            tooltipElement.remove();
            target.removePrivate("tooltipElement");
        }
    }
    _makeTooltipElement(target) {
        const container = this._tooltipElementContainer;
        const tooltipElement = document.createElement("div");
        tooltipElement.style.position = "absolute";
        tooltipElement.style.width = "1px";
        tooltipElement.style.height = "1px";
        tooltipElement.style.overflow = "hidden";
        tooltipElement.style.clip = "rect(1px, 1px, 1px, 1px)";
        _util_Utils__WEBPACK_IMPORTED_MODULE_9__.setInteractive(tooltipElement, false);
        this._decorateFocusElement(target, tooltipElement);
        container.append(tooltipElement);
        target.setPrivate("tooltipElement", tooltipElement);
        return tooltipElement;
    }
    _removeTooltipElement(target) {
        if (this._a11yD == true) {
            return;
        }
        const tooltipElement = target.getPrivate("tooltipElement");
        if (tooltipElement) {
            const parent = tooltipElement.parentElement;
            if (parent) {
                parent.removeChild(tooltipElement);
            }
        }
    }
    _invalidateAccessibility(target) {
        if (this._a11yD == true) {
            return;
        }
        this._focusElementDirty = true;
        const focusElement = target.getPrivate("focusElement");
        if (target.get("focusable")) {
            if (focusElement) {
                this._decorateFocusElement(target);
                this._positionFocusElement(target);
            }
            // else {
            // 	this._renderer._makeFocusElement(0, this);
            // }
        }
        else if (focusElement) {
            this._removeFocusElement(target);
        }
        //this.updateCurrentFocus();
    }
    /**
     * Returns `true` if `target` is currently focused.
     *
     * @param   target  Target
     * @return          Focused?
     */
    focused(target) {
        return this._focusedSprite === target;
    }
    /**
     * Converts document coordinates to coordinates withing root element.
     *
     * @param   point  Document point
     * @return         Root point
     */
    documentPointToRoot(point) {
        const rect = this._getRealSize();
        const size = this._getCalculatedSize(rect);
        const scaleWidth = size.width / rect.width;
        const scaleHeight = size.height / rect.height;
        return {
            x: (point.x - rect.left) * scaleWidth,
            y: (point.y - rect.top) * scaleHeight,
        };
    }
    /**
     * Converts root coordinates to document
     *
     * @param   point  Document point
     * @return         Root point
     */
    rootPointToDocument(point) {
        const rect = this._getRealSize();
        const size = this._getCalculatedSize(rect);
        const scaleWidth = size.width / rect.width;
        const scaleHeight = size.height / rect.height;
        return {
            x: (point.x / scaleWidth) + rect.left,
            y: (point.y / scaleHeight) + rect.top
        };
    }
    /**
     * @ignore
     */
    addDisposer(disposer) {
        this._disposers.push(disposer);
        return disposer;
    }
    _updateComputedStyles() {
        const styles = window.getComputedStyle(this.dom);
        let fontHash = "";
        _util_Object__WEBPACK_IMPORTED_MODULE_22__.each(styles, (key, val) => {
            if (_util_Type__WEBPACK_IMPORTED_MODULE_26__.isString(key) && key.match(/^font/)) {
                fontHash += val;
            }
        });
        const changed = fontHash != this._fontHash;
        if (changed) {
            this._fontHash = fontHash;
        }
        return changed;
    }
    _checkComputedStyles() {
        if (this._updateComputedStyles()) {
            this._invalidateLabelBounds(this.container);
        }
    }
    _invalidateLabelBounds(target) {
        if (target instanceof _render_Container__WEBPACK_IMPORTED_MODULE_14__.Container) {
            target.children.each((child) => {
                this._invalidateLabelBounds(child);
            });
        }
        else if (target instanceof _render_Text__WEBPACK_IMPORTED_MODULE_27__.Text) {
            target.markDirtyBounds();
        }
    }
    /**
     * To all the clever heads out there. Yes, we did not make any attempts to
     * scramble this.
     *
     * This is a part of a tool meant for our users to manage their commercial
     * licenses for removal of amCharts branding from charts.
     *
     * The only legit way to do so is to purchase a commercial license for amCharts:
     * https://www.amcharts.com/online-store/
     *
     * Removing or altering this code, or disabling amCharts branding in any other
     * way is against the license and thus illegal.
     */
    _hasLicense() {
        for (let i = 0; i < _Registry__WEBPACK_IMPORTED_MODULE_12__.registry.licenses.length; i++) {
            if (_Registry__WEBPACK_IMPORTED_MODULE_12__.registry.licenses[i].match(/^AM5C.{5,}/i)) {
                return true;
            }
        }
        return false;
    }
    _licenseApplied() {
        if (this._logo) {
            this._logo.set("forceHidden", true);
        }
    }
    /**
     * @ignore
     */
    get debugGhostView() {
        return this._renderer.debugGhostView;
    }
    /**
     * @ignore
     */
    set debugGhostView(value) {
        this._renderer.debugGhostView = value;
    }
    /**
     * Set this to `true` if you need chart to require first a tap onto it before
     * touch gesture related functionality like zoom/pan is turned on.
     *
     * @see {@link https://www.amcharts.com/docs/v5/getting-started/root-element/#Touch_related_options} for more info
     * @default false
     * @since 5.2.9
     * @param  value  Needs a tap to activate touch functions
     */
    set tapToActivate(value) {
        this._renderer.tapToActivate = value;
    }
    /**
     * @return Needs a tap to activate touch functions
     */
    get tapToActivate() {
        return this._renderer.tapToActivate;
    }
    /**
     * If `tapToActivate` is set to `true`, this setting will determine number
     * of milliseconds the chart will stay "active", before releasing the
     * controls back to the page.
     *
     * @see {@link https://www.amcharts.com/docs/v5/getting-started/root-element/#Touch_related_options} for more info
     * @default 3000
     * @since 5.2.9
     * @param  value  Timeout
     */
    set tapToActivateTimeout(value) {
        this._renderer.tapToActivateTimeout = value;
    }
    /**
     * @return Timeout
     */
    get tapToActivateTimeout() {
        return this._renderer.tapToActivateTimeout;
    }
    _makeHTMLElement(target) {
        // Get container
        const container = this._htmlElementContainer;
        // Init
        const htmlElement = document.createElement("div");
        target.setPrivate("htmlElement", htmlElement);
        //htmlElement.tabIndex = this.tabindex;
        htmlElement.style.position = "absolute";
        htmlElement.style.overflow = "auto";
        htmlElement.style.boxSizing = "border-box";
        _util_Utils__WEBPACK_IMPORTED_MODULE_9__.setInteractive(htmlElement, target.get("interactive", false));
        // Translate events
        if (target.events.isEnabled("click")) {
            _util_Utils__WEBPACK_IMPORTED_MODULE_9__.setInteractive(htmlElement, true);
            this._disposers.push(_util_Utils__WEBPACK_IMPORTED_MODULE_9__.addEventListener(htmlElement, "click", (ev) => {
                const downEvent = this._renderer.getEvent(ev);
                target.events.dispatch("click", {
                    type: "click",
                    originalEvent: downEvent.event,
                    point: downEvent.point,
                    simulated: false,
                    target: target
                });
            }));
        }
        this._positionHTMLElement(target);
        container.append(htmlElement);
        _util_Array__WEBPACK_IMPORTED_MODULE_11__.pushOne(this._htmlEnabledContainers, target);
        return htmlElement;
    }
    _positionHTMLElements() {
        _util_Array__WEBPACK_IMPORTED_MODULE_11__.each(this._htmlEnabledContainers, (target) => {
            this._positionHTMLElement(target);
        });
    }
    _positionHTMLElement(target) {
        const htmlElement = target.getPrivate("htmlElement");
        if (htmlElement) {
            // Translate settings
            const visualSettings = ["paddingTop", "paddingRight", "paddingBottom", "paddingLeft", "minWidth", "minHeight", "maxWidth", "maxHeight"];
            _util_Array__WEBPACK_IMPORTED_MODULE_11__.each(visualSettings, (setting) => {
                const value = target.get(setting);
                if (value) {
                    htmlElement.style[setting] = value + "px";
                }
                else {
                    htmlElement.style[setting] = "";
                }
            });
            // Deal with opacity
            const opacity = target.compositeOpacity();
            setTimeout(() => {
                htmlElement.style.opacity = opacity + "";
            }, 10);
            const visible = target.isVisibleDeep();
            if (visible) {
                htmlElement.style.display = "block";
            }
            // Deal with position
            const bounds = target.globalBounds();
            htmlElement.style.top = (bounds.top) + "px";
            htmlElement.style.left = (bounds.left) + "px";
            // Use width/height if those are set
            const width = target.get("width");
            const height = target.get("height");
            let w = 0;
            let h = 0;
            if (width) {
                w = target.width();
            }
            if (height) {
                h = target.height();
            }
            if (!width || !height) {
                htmlElement.style.position = "fixed";
                htmlElement.style.width = "";
                htmlElement.style.height = "";
                const bbox = htmlElement.getBoundingClientRect();
                htmlElement.style.position = "absolute";
                w = bbox.width;
                h = bbox.height;
                target._adjustedLocalBounds = { left: 0, right: 0, top: 0, bottom: 0 };
                target.setPrivate("minWidth", w);
                target.setPrivate("minHeight", h);
            }
            else {
                target.removePrivate("minWidth");
                target.removePrivate("minHeight");
            }
            if (w > 0) {
                htmlElement.style.minWidth = (w) + "px";
            }
            if (h > 0) {
                htmlElement.style.minHeight = (h) + "px";
            }
            // Hide or show
            if (!visible || opacity == 0) {
                htmlElement.style.display = "none";
            }
        }
    }
    _setHTMLContent(target, html) {
        let htmlElement = target.getPrivate("htmlElement");
        if (!htmlElement) {
            htmlElement = this._makeHTMLElement(target);
        }
        if (htmlElement.innerHTML != html) {
            htmlElement.innerHTML = html;
        }
    }
    _removeHTMLContent(target) {
        let htmlElement = target.getPrivate("htmlElement");
        if (htmlElement) {
            this._htmlElementContainer.removeChild(htmlElement);
            target.removePrivate("htmlElement");
        }
        _util_Array__WEBPACK_IMPORTED_MODULE_11__.remove(this._htmlEnabledContainers, target);
    }
}
//# sourceMappingURL=Root.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/core/Theme.js":
/*!******************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/core/Theme.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Theme: () => (/* binding */ Theme)
/* harmony export */ });
/* harmony import */ var _util_Template__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./util/Template */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Template.js");
/* harmony import */ var _util_Order__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util/Order */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Order.js");
/* harmony import */ var _util_Array__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util/Array */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Array.js");



/**
 * A base class for an amCharts theme.
 *
 * @see {@link https://www.amcharts.com/docs/v5/concepts/themes/} for more info
 * @important
 */
class Theme {
    constructor(root, isReal) {
        Object.defineProperty(this, "_root", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_rules", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {}
        });
        this._root = root;
        if (!isReal) {
            throw new Error("You cannot use `new Class()`, instead use `Class.new()`");
        }
    }
    /**
     * Use this method to create an instance of this class.
     *
     * @see {@link https://www.amcharts.com/docs/v5/getting-started/#New_element_syntax} for more info
     * @param   root      Root element
     * @param   settings  Settings
     * @param   template  Template
     * @return            Instantiated object
     */
    static new(root) {
        const x = (new this(root, true));
        x.setupDefaultRules();
        return x;
    }
    setupDefaultRules() { }
    /**
     * Looks up the rules for a specific theme class.
     *
     * @see {@link https://www.amcharts.com/docs/v5/themes/} for more info
     * @param   themeClass Theme class
     * @return             Array<IRule<A>>
     */
    _lookupRules(themeClass) {
        return this._rules[themeClass];
    }
    /**
     * Creates a [[Template]] for specific theme class and tags.
     *
     * NOTE: the difference from `rule()` is that `ruleRaw()` does not do any
     * type checks.
     *
     * @see {@link https://www.amcharts.com/docs/v5/themes/} for more info
     * @param   themeClass Theme class
     * @param   themeTags  Theme tags
     * @return             Template
     */
    ruleRaw(themeClass, themeTags = []) {
        let rules = this._rules[themeClass];
        if (!rules) {
            rules = this._rules[themeClass] = [];
        }
        themeTags.sort(_util_Order__WEBPACK_IMPORTED_MODULE_0__.compare);
        const { index, found } = _util_Array__WEBPACK_IMPORTED_MODULE_1__.getSortedIndex(rules, (x) => {
            const order = _util_Order__WEBPACK_IMPORTED_MODULE_0__.compare(x.tags.length, themeTags.length);
            if (order === 0) {
                return _util_Order__WEBPACK_IMPORTED_MODULE_0__.compareArray(x.tags, themeTags, _util_Order__WEBPACK_IMPORTED_MODULE_0__.compare);
            }
            else {
                return order;
            }
        });
        if (found) {
            return rules[index].template;
        }
        else {
            const template = _util_Template__WEBPACK_IMPORTED_MODULE_2__.Template.new({});
            rules.splice(index, 0, {
                tags: themeTags,
                template,
            });
            return template;
        }
    }
    /**
     * Creates a [[Template]] for specific theme class and tags.
     *
     * @see {@link https://www.amcharts.com/docs/v5/themes/} for more info
     * @param   themeClass Theme class
     * @param   themeTags  Theme tags
     * @return             Template
     */
    rule(themeClass, themeTags = []) {
        return this.ruleRaw(themeClass, themeTags);
    }
}
//# sourceMappingURL=Theme.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/core/render/Bullet.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/core/render/Bullet.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Bullet: () => (/* binding */ Bullet)
/* harmony export */ });
/* harmony import */ var _core_util_Entity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/util/Entity */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Entity.js");

/**
 * A universal placeholder for bullet elements.
 *
 * @see {@link https://www.amcharts.com/docs/v5/concepts/common-elements/bullets/} for more info
 */
class Bullet extends _core_util_Entity__WEBPACK_IMPORTED_MODULE_0__.Entity {
    constructor() {
        super(...arguments);
        // used by MapPolygons where one data item can have multiple bullets of the same kind
        Object.defineProperty(this, "_index", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /**
         * Target series object if it's a bullet for series.
         */
        Object.defineProperty(this, "series", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
    }
    _afterNew() {
        // Applying themes because bullet will not have parent
        super._afterNewApplyThemes();
    }
    _beforeChanged() {
        super._beforeChanged();
        if (this.isDirty("sprite")) {
            const sprite = this.get("sprite");
            if (sprite) {
                sprite.setAll({ position: "absolute", role: "figure" });
                this._disposers.push(sprite);
            }
        }
        if (this.isDirty("locationX") || this.isDirty("locationY")) {
            if (this.series) {
                this.series._positionBullet(this);
            }
        }
    }
}
Object.defineProperty(Bullet, "className", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: "Bullet"
});
Object.defineProperty(Bullet, "classNames", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: _core_util_Entity__WEBPACK_IMPORTED_MODULE_0__.Entity.classNames.concat([Bullet.className])
});
//# sourceMappingURL=Bullet.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/core/render/Button.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/core/render/Button.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Button: () => (/* binding */ Button)
/* harmony export */ });
/* harmony import */ var _render_RoundedRectangle__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../render/RoundedRectangle */ "./node_modules/@amcharts/amcharts5/.internal/core/render/RoundedRectangle.js");
/* harmony import */ var _Container__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Container */ "./node_modules/@amcharts/amcharts5/.internal/core/render/Container.js");
/* harmony import */ var _core_util_Utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../core/util/Utils */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Utils.js");



/**
 * Draws an interactive button.
 *
 * @see {@link https://www.amcharts.com/docs/v5/concepts/common-elements/buttons/} for more info
 * @important
 */
class Button extends _Container__WEBPACK_IMPORTED_MODULE_0__.Container {
    _afterNew() {
        this._settings.themeTags = _core_util_Utils__WEBPACK_IMPORTED_MODULE_1__.mergeTags(this._settings.themeTags, ["button"]);
        super._afterNew();
        if (!this._settings.background) {
            this.set("background", _render_RoundedRectangle__WEBPACK_IMPORTED_MODULE_2__.RoundedRectangle.new(this._root, {
                themeTags: _core_util_Utils__WEBPACK_IMPORTED_MODULE_1__.mergeTags(this._settings.themeTags, ["background"])
            }));
        }
        this.setPrivate("trustBounds", true);
    }
    _prepareChildren() {
        super._prepareChildren();
        if (this.isDirty("icon")) {
            const previous = this._prevSettings.icon;
            const icon = this.get("icon");
            if (icon !== previous) {
                this._disposeProperty("icon");
                if (previous) {
                    previous.dispose();
                }
                if (icon) {
                    this.children.push(icon);
                }
                this._prevSettings.icon = icon;
            }
        }
        if (this.isDirty("label")) {
            const previous = this._prevSettings.label;
            const label = this.get("label");
            if (label !== previous) {
                this._disposeProperty("label");
                if (previous) {
                    previous.dispose();
                }
                if (label) {
                    this.children.push(label);
                }
                this._prevSettings.label = label;
            }
        }
    }
}
Object.defineProperty(Button, "className", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: "Button"
});
Object.defineProperty(Button, "classNames", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: _Container__WEBPACK_IMPORTED_MODULE_0__.Container.classNames.concat([Button.className])
});
//# sourceMappingURL=Button.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/core/render/Chart.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/core/render/Chart.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Chart: () => (/* binding */ Chart)
/* harmony export */ });
/* harmony import */ var _core_render_Container__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/render/Container */ "./node_modules/@amcharts/amcharts5/.internal/core/render/Container.js");
/* harmony import */ var _core_util_Percent__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../core/util/Percent */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Percent.js");


/**
 * A base class for all charts.
 */
class Chart extends _core_render_Container__WEBPACK_IMPORTED_MODULE_0__.Container {
    constructor() {
        super(...arguments);
        /**
         * A [[Container]] chart places its elements in.
         *
         * @default Container.new()
         */
        Object.defineProperty(this, "chartContainer", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: this.children.push(_core_render_Container__WEBPACK_IMPORTED_MODULE_0__.Container.new(this._root, { width: _core_util_Percent__WEBPACK_IMPORTED_MODULE_1__.p100, height: _core_util_Percent__WEBPACK_IMPORTED_MODULE_1__.p100, interactiveChildren: false }))
        });
        /**
         * A [[Container]] chart places its bullets in.
         *
         * @default Container.new()
         */
        Object.defineProperty(this, "bulletsContainer", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: _core_render_Container__WEBPACK_IMPORTED_MODULE_0__.Container.new(this._root, { interactiveChildren: false, isMeasured: false, position: "absolute", width: _core_util_Percent__WEBPACK_IMPORTED_MODULE_1__.p100, height: _core_util_Percent__WEBPACK_IMPORTED_MODULE_1__.p100 })
        });
    }
}
Object.defineProperty(Chart, "className", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: "Chart"
});
Object.defineProperty(Chart, "classNames", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: _core_render_Container__WEBPACK_IMPORTED_MODULE_0__.Container.classNames.concat([Chart.className])
});
//# sourceMappingURL=Chart.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/core/render/Circle.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/core/render/Circle.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Circle: () => (/* binding */ Circle)
/* harmony export */ });
/* harmony import */ var _Graphics__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Graphics */ "./node_modules/@amcharts/amcharts5/.internal/core/render/Graphics.js");

/**
 * Draws a circle.
 *
 * @see {@link https://www.amcharts.com/docs/v5/concepts/common-elements/graphics/} for more info
 * @important
 */
class Circle extends _Graphics__WEBPACK_IMPORTED_MODULE_0__.Graphics {
    _afterNew() {
        super._afterNew();
        this._display.isMeasured = true;
        this.setPrivateRaw("trustBounds", true);
    }
    _beforeChanged() {
        super._beforeChanged();
        if (this.isDirty("radius")) {
            this._clear = true;
        }
    }
    _changed() {
        super._changed();
        if (this._clear) {
            this._display.drawCircle(0, 0, this.get("radius", 10));
        }
    }
}
Object.defineProperty(Circle, "className", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: "Circle"
});
Object.defineProperty(Circle, "classNames", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: _Graphics__WEBPACK_IMPORTED_MODULE_0__.Graphics.classNames.concat([Circle.className])
});
//# sourceMappingURL=Circle.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/core/render/Component.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/core/render/Component.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Component: () => (/* binding */ Component),
/* harmony export */   DataItem: () => (/* binding */ DataItem)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.mjs");
/* harmony import */ var _util_Entity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/Entity */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Entity.js");
/* harmony import */ var _Container__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Container */ "./node_modules/@amcharts/amcharts5/.internal/core/render/Container.js");
/* harmony import */ var _util_Data__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/Data */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Data.js");
/* harmony import */ var _util_Array__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util/Array */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Array.js");
/* harmony import */ var _util_Object__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../util/Object */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Object.js");






/**
 * A base element that holds data bit (data item) for any [[Component]].
 */
class DataItem extends _util_Entity__WEBPACK_IMPORTED_MODULE_0__.Settings {
    constructor(component, dataContext, settings) {
        super(settings);
        /**
         * A data item's owener [[Component]].
         */
        Object.defineProperty(this, "component", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /**
         * A reference to actual item in source data this item is based on.
         */
        Object.defineProperty(this, "dataContext", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /**
         * @todo requires description
         */
        Object.defineProperty(this, "bullets", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /**
         * A set of "open" values.
         */
        Object.defineProperty(this, "open", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /**
         * A set of "close" values.
         */
        Object.defineProperty(this, "close", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.dataContext = dataContext;
        this.component = component;
        this._settings.visible = true;
        this._checkDirty();
    }
    /**
     * @ignore
     */
    markDirty() {
        this.component.markDirtyValues(this);
    }
    _startAnimation() {
        this.component._root._addAnimation(this);
    }
    _animationTime() {
        return this.component._root.animationTime;
    }
    _dispose() {
        if (this.component) {
            this.component.disposeDataItem(this);
        }
        super._dispose();
    }
    /**
     * Shows a data item that's currently hidden.
     */
    show(duration) {
        this.setRaw("visible", true);
        if (this.component) {
            this.component.showDataItem(this, duration);
        }
    }
    /**
     * Hides a data item that's currently visible.
     */
    hide(duration) {
        this.setRaw("visible", false);
        if (this.component) {
            this.component.hideDataItem(this, duration);
        }
    }
    isHidden() {
        return !this.get("visible");
    }
}
/**
 * A base class for elements that make use of data.
 */
class Component extends _Container__WEBPACK_IMPORTED_MODULE_1__.Container {
    constructor() {
        super(...arguments);
        Object.defineProperty(this, "_data", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new _util_Data__WEBPACK_IMPORTED_MODULE_2__.ListData()
        });
        Object.defineProperty(this, "_dataItems", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
        });
        Object.defineProperty(this, "_mainDataItems", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: this._dataItems
        });
        Object.defineProperty(this, "valueFields", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
        });
        Object.defineProperty(this, "fields", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: ["id"]
        });
        Object.defineProperty(this, "_valueFields", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_valueFieldsF", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_fields", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_fieldsF", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_valuesDirty", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        Object.defineProperty(this, "_dataChanged", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        Object.defineProperty(this, "_dataGrouped", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        /**
         * Indicates if the component has already been initialized.
         */
        Object.defineProperty(this, "inited", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
    }
    /**
     * Component's data.
     *
     * @see {@link https://www.amcharts.com/docs/v5/concepts/data/} for more info
     */
    set data(data) {
        data.incrementRef();
        this._data.decrementRef();
        this._data = data;
    }
    /**
     * @return  Data
     */
    get data() {
        return this._data;
    }
    _dispose() {
        super._dispose();
        this._data.decrementRef();
    }
    _onDataClear() {
    }
    _afterNew() {
        super._afterNew();
        this._data.incrementRef();
        this._updateFields();
        this._disposers.push(this.data.events.onAll((change) => {
            const dataItems = this._mainDataItems;
            this.markDirtyValues();
            this._markDirtyGroup();
            this._dataChanged = true;
            if (change.type === "clear") {
                _util_Array__WEBPACK_IMPORTED_MODULE_3__.each(dataItems, (dataItem) => {
                    dataItem.dispose();
                });
                dataItems.length = 0;
                this._onDataClear();
            }
            else if (change.type === "push") {
                const dataItem = new DataItem(this, change.newValue, this._makeDataItem(change.newValue));
                dataItems.push(dataItem);
                this.processDataItem(dataItem);
            }
            else if (change.type === "setIndex") {
                const dataItem = dataItems[change.index];
                const properties = this._makeDataItem(change.newValue);
                if (dataItem.bullets && dataItem.bullets.length == 0) {
                    dataItem.bullets = undefined;
                }
                _util_Object__WEBPACK_IMPORTED_MODULE_4__.keys(properties).forEach((key) => {
                    dataItem.animate({
                        key: key,
                        to: properties[key],
                        duration: this.get("interpolationDuration", 0),
                        easing: this.get("interpolationEasing"),
                    });
                });
                dataItem.dataContext = change.newValue;
            }
            else if (change.type === "insertIndex") {
                const dataItem = new DataItem(this, change.newValue, this._makeDataItem(change.newValue));
                dataItems.splice(change.index, 0, dataItem);
                this.processDataItem(dataItem);
            }
            else if (change.type === "removeIndex") {
                const dataItem = dataItems[change.index];
                dataItem.dispose();
                dataItems.splice(change.index, 1);
            }
            else if (change.type === "moveIndex") {
                const dataItem = dataItems[change.oldIndex];
                dataItems.splice(change.oldIndex, 1);
                dataItems.splice(change.newIndex, 0, dataItem);
            }
            else {
                throw new Error("Unknown IStreamEvent type");
            }
            this._afterDataChange();
        }));
    }
    _updateFields() {
        if (this.valueFields) {
            this._valueFields = [];
            this._valueFieldsF = {};
            _util_Array__WEBPACK_IMPORTED_MODULE_3__.each(this.valueFields, (key) => {
                const field = this.get((key + "Field"));
                if (field) {
                    this._valueFields.push(key);
                    this._valueFieldsF[key] = { fieldKey: key + "Field", workingKey: key + "Working" };
                }
            });
        }
        if (this.fields) {
            this._fields = [];
            this._fieldsF = {};
            _util_Array__WEBPACK_IMPORTED_MODULE_3__.each(this.fields, (key) => {
                const field = this.get((key + "Field"));
                if (field) {
                    this._fields.push(key);
                    this._fieldsF[key] = key + "Field";
                }
            });
        }
    }
    /**
     * A list of component's data items.
     *
     * @return  Data items
     */
    get dataItems() {
        return this._dataItems;
    }
    processDataItem(_dataItem) { }
    _makeDataItem(data) {
        //const output: this["_dataItemSettings"] = {};
        const output = {}; // temporary to solve error
        if (this._valueFields) {
            _util_Array__WEBPACK_IMPORTED_MODULE_3__.each(this._valueFields, (key) => {
                const field = this.get((this._valueFieldsF[key].fieldKey));
                output[key] = data[field];
                output[this._valueFieldsF[key].workingKey] = output[key];
            });
        }
        if (this._fields) {
            _util_Array__WEBPACK_IMPORTED_MODULE_3__.each(this._fields, (key) => {
                const field = this.get((this._fieldsF[key]));
                output[key] = data[field];
            });
        }
        return output;
    }
    /**
     * @ignore
     */
    makeDataItem(data) {
        let dataItem = new DataItem(this, undefined, data);
        this.processDataItem(dataItem);
        return dataItem;
    }
    /**
     * @ignore
     */
    pushDataItem(data) {
        const dataItem = this.makeDataItem(data);
        this._mainDataItems.push(dataItem);
        return dataItem;
    }
    /**
     * @ignore
     */
    disposeDataItem(_dataItem) {
    }
    /**
     * Shows component's data item.
     *
     * @param   dataItem   Data item
     * @param   _duration  Animation duration in milliseconds
     * @return             Promise
     */
    showDataItem(dataItem, _duration) {
        return (0,tslib__WEBPACK_IMPORTED_MODULE_5__.__awaiter)(this, void 0, void 0, function* () {
            dataItem.set("visible", true);
        });
    }
    /**
     * Hides component's data item.
     *
     * @param   dataItem   Data item
     * @param   _duration  Animation duration in milliseconds
     * @return             Promise
     */
    hideDataItem(dataItem, _duration) {
        return (0,tslib__WEBPACK_IMPORTED_MODULE_5__.__awaiter)(this, void 0, void 0, function* () {
            dataItem.set("visible", false);
        });
    }
    _clearDirty() {
        super._clearDirty();
        this._valuesDirty = false;
    }
    _afterDataChange() {
    }
    _afterChanged() {
        super._afterChanged();
        if (this._dataChanged) {
            const type = "datavalidated";
            if (this.events.isEnabled(type)) {
                this.events.dispatch(type, { type: type, target: this });
            }
            this._dataChanged = false;
        }
        this.inited = true;
    }
    /**
     * Forces a repaint of the element which relies on data.
     *
     * @since 5.0.21
     */
    markDirtyValues(_dataItem) {
        this.markDirty();
        this._valuesDirty = true;
    }
    _markDirtyGroup() {
        this._dataGrouped = false;
    }
    /**
     * @ignore
     */
    markDirtySize() {
        this._sizeDirty = true;
        this.markDirty();
    }
}
Object.defineProperty(Component, "className", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: "Component"
});
Object.defineProperty(Component, "classNames", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: _Container__WEBPACK_IMPORTED_MODULE_1__.Container.classNames.concat([Component.className])
});
//# sourceMappingURL=Component.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/core/render/Container.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/core/render/Container.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Container: () => (/* binding */ Container)
/* harmony export */ });
/* harmony import */ var _util_Children__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/Children */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Children.js");
/* harmony import */ var _util_Percent__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../util/Percent */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Percent.js");
/* harmony import */ var _Sprite__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Sprite */ "./node_modules/@amcharts/amcharts5/.internal/core/render/Sprite.js");
/* harmony import */ var _Rectangle__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Rectangle */ "./node_modules/@amcharts/amcharts5/.internal/core/render/Rectangle.js");
/* harmony import */ var _HorizontalLayout__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./HorizontalLayout */ "./node_modules/@amcharts/amcharts5/.internal/core/render/HorizontalLayout.js");
/* harmony import */ var _VerticalLayout__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./VerticalLayout */ "./node_modules/@amcharts/amcharts5/.internal/core/render/VerticalLayout.js");
/* harmony import */ var _GridLayout__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./GridLayout */ "./node_modules/@amcharts/amcharts5/.internal/core/render/GridLayout.js");
/* harmony import */ var _util_PopulateString__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../util/PopulateString */ "./node_modules/@amcharts/amcharts5/.internal/core/util/PopulateString.js");
/* harmony import */ var _util_Array__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/Array */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Array.js");
/* harmony import */ var _util_Type__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../util/Type */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Type.js");
/* harmony import */ var _util_Utils__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../util/Utils */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Utils.js");











/**
 * A basic element that can have child elements, maintain their layout, and
 * have a background.
 *
 * It can have any [[Sprite]] element as a child, from very basic shapes, to
 * full-fledged charts.
 *
 * @see {@link https://www.amcharts.com/docs/v5/concepts/common-elements/containers/} for more info
 * @important
 */
class Container extends _Sprite__WEBPACK_IMPORTED_MODULE_0__.Sprite {
    constructor() {
        super(...arguments);
        Object.defineProperty(this, "_display", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: this._root._renderer.makeContainer()
        });
        Object.defineProperty(this, "_childrenDisplay", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: this._root._renderer.makeContainer()
        });
        /**
         * List of Container's child elements.
         */
        Object.defineProperty(this, "children", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new _util_Children__WEBPACK_IMPORTED_MODULE_1__.Children(this)
        });
        Object.defineProperty(this, "_percentageSizeChildren", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
        });
        Object.defineProperty(this, "_percentagePositionChildren", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
        });
        Object.defineProperty(this, "_prevWidth", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        Object.defineProperty(this, "_prevHeight", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        Object.defineProperty(this, "_contentWidth", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        Object.defineProperty(this, "_contentHeight", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        Object.defineProperty(this, "_contentMask", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_vsbd0", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_vsbd1", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
    }
    _afterNew() {
        super._afterNew();
        this._display.addChild(this._childrenDisplay);
    }
    _dispose() {
        _util_Array__WEBPACK_IMPORTED_MODULE_2__.eachReverse(this.allChildren(), (child) => {
            child.dispose();
        });
        if (this.getPrivate("htmlElement")) {
            this._root._removeHTMLContent(this);
        }
        super._dispose();
    }
    _changed() {
        super._changed();
        if (this.isDirty("interactiveChildren")) {
            this._display.interactiveChildren = this.get("interactiveChildren", false);
        }
        if (this.isDirty("layout")) {
            this._prevWidth = 0;
            this._prevHeight = 0;
            this.markDirtyBounds();
            if (this._prevSettings.layout) {
                this.children.each((child) => {
                    child.removePrivate("x");
                    child.removePrivate("y");
                });
            }
        }
        if (this.isDirty("paddingTop") || this.isDirty("paddingBottom") || this.isDirty("paddingLeft") || this.isDirty("paddingRight")) {
            this.children.each((child) => {
                child.markDirtyPosition();
            });
        }
        if (this.isDirty("maskContent")) {
            const childrenDisplay = this._childrenDisplay;
            let contentMask = this._contentMask;
            if (this.get("maskContent")) {
                if (!contentMask) {
                    contentMask = _Rectangle__WEBPACK_IMPORTED_MODULE_3__.Rectangle.new(this._root, {
                        x: -.5,
                        y: -.5,
                        width: this.width() + 1,
                        height: this.height() + 1
                    });
                    this._contentMask = contentMask;
                    childrenDisplay.addChildAt(contentMask._display, 0);
                    childrenDisplay.mask = contentMask._display;
                }
            }
            else {
                if (contentMask) {
                    childrenDisplay.removeChild(contentMask._display);
                    childrenDisplay.mask = null;
                    contentMask.dispose();
                    this._contentMask = undefined;
                }
            }
        }
    }
    _updateSize() {
        super._updateSize();
        _util_Array__WEBPACK_IMPORTED_MODULE_2__.each(this._percentageSizeChildren, (child) => {
            child._updateSize();
        });
        _util_Array__WEBPACK_IMPORTED_MODULE_2__.each(this._percentagePositionChildren, (child) => {
            child.markDirtyPosition();
            child._updateSize();
        });
        this.updateBackground();
    }
    updateBackground() {
        const background = this.get("background");
        let bounds = this._localBounds;
        if (bounds && !this.isHidden()) {
            let x = bounds.left;
            let y = bounds.top;
            let w = bounds.right - x;
            let h = bounds.bottom - y;
            let maxWidth = this.get("maxWidth");
            let maxHeight = this.get("maxHeight");
            if (maxHeight) {
                if (h > maxHeight) {
                    h = maxHeight;
                }
            }
            if (maxWidth) {
                if (w > maxWidth) {
                    w = maxWidth;
                }
            }
            let width = this.width();
            let height = this.height();
            if (background) {
                background.setAll({ width: w, height: h, x: x, y: y });
                if (this._display.interactive) {
                    background._display.interactive = true;
                }
            }
            const contentMask = this._contentMask;
            if (contentMask) {
                contentMask.setAll({ width: width + 1, height: height + 1 });
            }
            const verticalScrollbar = this.get("verticalScrollbar");
            if (verticalScrollbar) {
                verticalScrollbar.set("height", height);
                verticalScrollbar.set("x", width - verticalScrollbar.width() - verticalScrollbar.get("marginRight", 0));
                verticalScrollbar.set("end", verticalScrollbar.get("start", 0) + height / this._contentHeight);
                const bg = verticalScrollbar.get("background");
                if (bg) {
                    bg.setAll({ width: verticalScrollbar.width(), height: height });
                }
                let visible = true;
                if (this._contentHeight <= height) {
                    visible = false;
                }
                verticalScrollbar.setPrivate("visible", visible);
            }
        }
    }
    _applyThemes(force = false) {
        if (super._applyThemes(force)) {
            this.eachChildren((child) => {
                child._applyThemes(force);
            });
            return true;
        }
        else {
            return false;
        }
    }
    _applyState(name) {
        super._applyState(name);
        if (this.get("setStateOnChildren")) {
            this.eachChildren((child) => {
                child.states.apply(name);
            });
        }
    }
    _applyStateAnimated(name, duration) {
        super._applyStateAnimated(name, duration);
        if (this.get("setStateOnChildren")) {
            this.eachChildren((child) => {
                child.states.applyAnimate(name, duration);
            });
        }
    }
    /**
     * Returns container's inner width (width without padding) in pixels.
     *
     * @return Inner width (px)
     */
    innerWidth() {
        return this.width() - this.get("paddingRight", 0) - this.get("paddingLeft", 0);
    }
    /**
     * Returns container's inner height (height without padding) in pixels.
     *
     * @return Inner height (px)
     */
    innerHeight() {
        return this.height() - this.get("paddingTop", 0) - this.get("paddingBottom", 0);
    }
    _getBounds() {
        let width = this.get("width");
        let height = this.get("height");
        let pWidth = this.getPrivate("width");
        let pHeight = this.getPrivate("height");
        let bounds = {
            left: 0,
            top: 0,
            right: this.width(),
            bottom: this.height(),
        };
        let layout = this.get("layout");
        let horizontal = false;
        let vertical = false;
        if (layout instanceof _HorizontalLayout__WEBPACK_IMPORTED_MODULE_4__.HorizontalLayout || layout instanceof _GridLayout__WEBPACK_IMPORTED_MODULE_5__.GridLayout) {
            horizontal = true;
        }
        if (layout instanceof _VerticalLayout__WEBPACK_IMPORTED_MODULE_6__.VerticalLayout) {
            vertical = true;
        }
        if ((width != null || pWidth != null) && (height != null || pHeight != null) && !this.get("verticalScrollbar")) {
            // void
        }
        else {
            let m = Number.MAX_VALUE;
            let l = m;
            let r = -m;
            let t = m;
            let b = -m;
            const paddingLeft = this.get("paddingLeft", 0);
            const paddingTop = this.get("paddingTop", 0);
            const paddingRight = this.get("paddingRight", 0);
            const paddingBottom = this.get("paddingBottom", 0);
            this.children.each((child) => {
                if (child.get("position") != "absolute" && child.get("isMeasured")) {
                    let childBounds = child.adjustedLocalBounds();
                    let childX = child.x();
                    let childY = child.y();
                    let cl = childX + childBounds.left;
                    let cr = childX + childBounds.right;
                    let ct = childY + childBounds.top;
                    let cb = childY + childBounds.bottom;
                    if (horizontal) {
                        cl -= child.get("marginLeft", 0);
                        cr += child.get("marginRight", 0);
                    }
                    if (vertical) {
                        ct -= child.get("marginTop", 0);
                        cb += child.get("marginBottom", 0);
                    }
                    if (cl < l) {
                        l = cl;
                    }
                    if (cr > r) {
                        r = cr;
                    }
                    if (ct < t) {
                        t = ct;
                    }
                    if (cb > b) {
                        b = cb;
                    }
                }
            });
            if (l == m) {
                l = 0;
            }
            if (r == -m) {
                r = 0;
            }
            if (t == m) {
                t = 0;
            }
            if (b == -m) {
                b = 0;
            }
            bounds.left = l - paddingLeft;
            bounds.top = t - paddingTop;
            bounds.right = r + paddingRight;
            bounds.bottom = b + paddingBottom;
        }
        this._contentWidth = bounds.right - bounds.left;
        this._contentHeight = bounds.bottom - bounds.top;
        if (_util_Type__WEBPACK_IMPORTED_MODULE_7__.isNumber(width)) {
            bounds.left = 0;
            bounds.right = width;
        }
        if (_util_Type__WEBPACK_IMPORTED_MODULE_7__.isNumber(pWidth)) {
            bounds.left = 0;
            bounds.right = pWidth;
        }
        if (_util_Type__WEBPACK_IMPORTED_MODULE_7__.isNumber(height)) {
            bounds.top = 0;
            bounds.bottom = height;
        }
        if (_util_Type__WEBPACK_IMPORTED_MODULE_7__.isNumber(pHeight)) {
            bounds.top = 0;
            bounds.bottom = pHeight;
        }
        this._localBounds = bounds;
    }
    _updateBounds() {
        const layout = this.get("layout");
        if (layout) {
            layout.updateContainer(this);
        }
        super._updateBounds();
        this.updateBackground();
    }
    /**
     * @ignore
     */
    markDirty() {
        super.markDirty();
        this._root._addDirtyParent(this);
    }
    _prepareChildren() {
        const innerWidth = this.innerWidth();
        const innerHeight = this.innerHeight();
        if (innerWidth != this._prevWidth || innerHeight != this._prevHeight) {
            let layout = this.get("layout");
            let horizontal = false;
            let vertical = false;
            if (layout) {
                if (layout instanceof _HorizontalLayout__WEBPACK_IMPORTED_MODULE_4__.HorizontalLayout || layout instanceof _GridLayout__WEBPACK_IMPORTED_MODULE_5__.GridLayout) {
                    horizontal = true;
                }
                if (layout instanceof _VerticalLayout__WEBPACK_IMPORTED_MODULE_6__.VerticalLayout) {
                    vertical = true;
                }
            }
            _util_Array__WEBPACK_IMPORTED_MODULE_2__.each(this._percentageSizeChildren, (child) => {
                if (!horizontal) {
                    let width = child.get("width");
                    if (width instanceof _util_Percent__WEBPACK_IMPORTED_MODULE_8__.Percent) {
                        child.setPrivate("width", width.value * innerWidth);
                    }
                }
                if (!vertical) {
                    let height = child.get("height");
                    if (height instanceof _util_Percent__WEBPACK_IMPORTED_MODULE_8__.Percent) {
                        child.setPrivate("height", height.value * innerHeight);
                    }
                }
            });
            _util_Array__WEBPACK_IMPORTED_MODULE_2__.each(this._percentagePositionChildren, (child) => {
                child.markDirtyPosition();
                child.markDirtyBounds();
            });
            this._prevWidth = innerWidth;
            this._prevHeight = innerHeight;
            this._sizeDirty = true;
            this.updateBackground();
        }
        this._handleStates();
    }
    _updateChildren() {
        if (this.isDirty("html")) {
            const html = this.get("html");
            if (html && html !== "") {
                this._root._setHTMLContent(this, (0,_util_PopulateString__WEBPACK_IMPORTED_MODULE_9__.populateString)(this, this.get("html", "")));
            }
            else {
                this._root._removeHTMLContent(this);
            }
            this._root._positionHTMLElement(this);
        }
        if (this.isDirty("verticalScrollbar")) {
            const verticalScrollbar = this.get("verticalScrollbar");
            if (verticalScrollbar) {
                verticalScrollbar._setParent(this);
                verticalScrollbar.startGrip.setPrivate("visible", false);
                verticalScrollbar.endGrip.setPrivate("visible", false);
                this.set("maskContent", true);
                this.set("paddingRight", verticalScrollbar.width() + verticalScrollbar.get("marginRight", 0) + verticalScrollbar.get("marginLeft", 0));
                let background = this.get("background");
                if (!background) {
                    background = this.set("background", _Rectangle__WEBPACK_IMPORTED_MODULE_3__.Rectangle.new(this._root, {
                        themeTags: ["background"],
                        fillOpacity: 0,
                        fill: this._root.interfaceColors.get("alternativeBackground")
                    }));
                }
                this._vsbd0 = this.events.on("wheel", (event) => {
                    const wheelEvent = event.originalEvent;
                    // Ignore wheel event if it is happening on a non-chart element, e.g. if
                    // some page element is over the chart.
                    if (_util_Utils__WEBPACK_IMPORTED_MODULE_10__.isLocalEvent(wheelEvent, this)) {
                        wheelEvent.preventDefault();
                    }
                    else {
                        return;
                    }
                    let shiftY = wheelEvent.deltaY / 5000;
                    const start = verticalScrollbar.get("start", 0);
                    const end = verticalScrollbar.get("end", 1);
                    if (start + shiftY <= 0) {
                        shiftY = -start;
                    }
                    if (end + shiftY >= 1) {
                        shiftY = 1 - end;
                    }
                    if (start + shiftY >= 0 && end + shiftY <= 1) {
                        verticalScrollbar.set("start", start + shiftY);
                        verticalScrollbar.set("end", end + shiftY);
                    }
                });
                this._disposers.push(this._vsbd0);
                this._vsbd1 = verticalScrollbar.events.on("rangechanged", () => {
                    let h = this._contentHeight;
                    const childrenDisplay = this._childrenDisplay;
                    const contentMask = this._contentMask;
                    childrenDisplay.y = -verticalScrollbar.get("start") * h;
                    childrenDisplay.markDirtyLayer();
                    if (contentMask) {
                        contentMask._display.y = -childrenDisplay.y;
                        childrenDisplay.mask = contentMask._display;
                    }
                });
                this._disposers.push(this._vsbd1);
                this._display.addChild(verticalScrollbar._display);
            }
            else {
                const previous = this._prevSettings.verticalScrollbar;
                if (previous) {
                    this._display.removeChild(previous._display);
                    if (this._vsbd0) {
                        this._vsbd0.dispose();
                    }
                    if (this._vsbd1) {
                        this._vsbd1.dispose();
                    }
                    const childrenDisplay = this._childrenDisplay;
                    childrenDisplay.y = 0;
                    this.setPrivate("height", undefined);
                    this.set("maskContent", false);
                    this.set("paddingRight", undefined);
                }
            }
        }
        if (this.isDirty("background")) {
            // TODO maybe this should dispose ?
            const previous = this._prevSettings["background"];
            if (previous) {
                this._display.removeChild(previous._display);
            }
            const background = this.get("background");
            if (background instanceof _Sprite__WEBPACK_IMPORTED_MODULE_0__.Sprite) {
                background.set("isMeasured", false);
                background._setParent(this);
                this._display.addChildAt(background._display, 0);
            }
        }
        if (this.isDirty("mask")) {
            const mask = this.get("mask");
            const previous = this._prevSettings["mask"];
            if (previous) {
                this._display.removeChild(previous._display);
                if (previous != mask) {
                    previous.dispose();
                }
            }
            if (mask) {
                const parent = mask.parent;
                if (parent) {
                    parent.children.removeValue(mask);
                }
                mask._setParent(this);
                this._display.addChildAt(mask._display, 0);
                this._childrenDisplay.mask = mask._display;
            }
        }
    }
    _processTemplateField() {
        super._processTemplateField();
        this.children.each((child) => {
            child._processTemplateField();
        });
    }
    /**
     * @ignore
     */
    walkChildren(f) {
        this.children.each((child) => {
            if (child instanceof Container) {
                child.walkChildren(f);
            }
            f(child);
        });
    }
    eachChildren(f) {
        const background = this.get("background");
        if (background) {
            f(background);
        }
        const verticalScrollbar = this.get("verticalScrollbar");
        if (verticalScrollbar) {
            f(verticalScrollbar);
        }
        const mask = this.get("mask");
        if (mask) {
            f(mask);
        }
        this.children.values.forEach((child) => {
            f(child);
        });
    }
    allChildren() {
        const output = [];
        this.eachChildren((x) => {
            output.push(x);
        });
        return output;
    }
    _setDataItem(dataItem) {
        const updated = (dataItem !== this._dataItem);
        super._setDataItem(dataItem);
        const html = this.get("html", "");
        if (html && html !== "" && updated) {
            this._root._setHTMLContent(this, (0,_util_PopulateString__WEBPACK_IMPORTED_MODULE_9__.populateString)(this, html));
        }
    }
}
Object.defineProperty(Container, "className", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: "Container"
});
Object.defineProperty(Container, "classNames", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: _Sprite__WEBPACK_IMPORTED_MODULE_0__.Sprite.classNames.concat([Container.className])
});
//# sourceMappingURL=Container.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/core/render/Graphics.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/core/render/Graphics.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Graphics: () => (/* binding */ Graphics),
/* harmony export */   visualSettings: () => (/* binding */ visualSettings)
/* harmony export */ });
/* harmony import */ var _render_patterns_PicturePattern__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../render/patterns/PicturePattern */ "./node_modules/@amcharts/amcharts5/.internal/core/render/patterns/PicturePattern.js");
/* harmony import */ var _Sprite__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Sprite */ "./node_modules/@amcharts/amcharts5/.internal/core/render/Sprite.js");
/* harmony import */ var _backend_Renderer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./backend/Renderer */ "./node_modules/@amcharts/amcharts5/.internal/core/render/backend/Renderer.js");
/* harmony import */ var _util_Type__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/Type */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Type.js");
/* harmony import */ var _util_Array__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util/Array */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Array.js");





const visualSettings = ["fill", "fillOpacity", "stroke", "strokeWidth", "strokeOpacity", "fillPattern", "strokePattern", "fillGradient", "strokeGradient", "strokeDasharray", "strokeDashoffset", "shadowBlur", "shadowColor", "shadowOpacity", "shadowOffsetX", "shadowOffsetY", "blur", "sepia", "invert", "brightness", "hue", "contrast", "saturate"];
/**
 * Base class used for drawing shapes.
 *
 * @see {@link https://www.amcharts.com/docs/v5/concepts/common-elements/graphics/} for more info
 * @important
 */
class Graphics extends _Sprite__WEBPACK_IMPORTED_MODULE_0__.Sprite {
    constructor() {
        super(...arguments);
        Object.defineProperty(this, "_display", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: this._root._renderer.makeGraphics()
        });
        Object.defineProperty(this, "_clear", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
    }
    _beforeChanged() {
        super._beforeChanged();
        if (this.isDirty("draw") || this.isDirty("svgPath")) {
            this.markDirtyBounds();
        }
        if (this.isDirty("fill") || this.isDirty("stroke") || this.isDirty("visible") || this.isDirty("forceHidden") || this.isDirty("scale") || this.isDirty("fillGradient") || this.isDirty("strokeGradient") || this.isDirty("fillPattern") || this.isDirty("strokePattern") || this.isDirty("fillOpacity") || this.isDirty("strokeOpacity") || this.isDirty("strokeWidth") || this.isDirty("draw") || this.isDirty("blendMode") || this.isDirty("strokeDasharray") || this.isDirty("strokeDashoffset") || this.isDirty("svgPath") || this.isDirty("lineJoin") || this.isDirty("shadowColor") || this.isDirty("shadowBlur") || this.isDirty("shadowOffsetX") || this.isDirty("shadowOffsetY")) {
            this._clear = true;
        }
        this._display.crisp = this.get("crisp", false);
        if (this.isDirty("fillGradient")) {
            const gradient = this.get("fillGradient");
            if (gradient) {
                this._display.isMeasured = true;
                const gradientTarget = gradient.get("target");
                if (gradientTarget) {
                    this._disposers.push(gradientTarget.events.on("boundschanged", () => {
                        this._markDirtyKey("fill");
                    }));
                    this._disposers.push(gradientTarget.events.on("positionchanged", () => {
                        this._markDirtyKey("fill");
                    }));
                }
            }
        }
        if (this.isDirty("strokeGradient")) {
            const gradient = this.get("strokeGradient");
            if (gradient) {
                this._display.isMeasured = true;
                const gradientTarget = gradient.get("target");
                if (gradientTarget) {
                    this._disposers.push(gradientTarget.events.on("boundschanged", () => {
                        this._markDirtyKey("stroke");
                    }));
                    this._disposers.push(gradientTarget.events.on("positionchanged", () => {
                        this._markDirtyKey("stroke");
                    }));
                }
            }
        }
    }
    _changed() {
        super._changed();
        if (this._clear) {
            this.markDirtyBounds();
            this.markDirtyLayer();
            this._display.clear();
            let strokeDasharray = this.get("strokeDasharray");
            if (_util_Type__WEBPACK_IMPORTED_MODULE_1__.isNumber(strokeDasharray)) {
                if (strokeDasharray < 0.5) {
                    strokeDasharray = [0];
                }
                else {
                    strokeDasharray = [strokeDasharray];
                }
            }
            this._display.setLineDash(strokeDasharray);
            const strokeDashoffset = this.get("strokeDashoffset");
            if (strokeDashoffset) {
                this._display.setLineDashOffset(strokeDashoffset);
            }
            const blendMode = this.get("blendMode", _backend_Renderer__WEBPACK_IMPORTED_MODULE_2__.BlendMode.NORMAL);
            this._display.blendMode = blendMode;
            const draw = this.get("draw");
            if (draw) {
                draw(this._display, this);
            }
            const svgPath = this.get("svgPath");
            if (svgPath != null) {
                this._display.svgPath(svgPath);
            }
        }
    }
    _afterChanged() {
        super._afterChanged();
        if (this._clear) {
            const fill = this.get("fill");
            const fillGradient = this.get("fillGradient");
            const fillPattern = this.get("fillPattern");
            const fillOpacity = this.get("fillOpacity");
            const stroke = this.get("stroke");
            const strokeGradient = this.get("strokeGradient");
            const strokePattern = this.get("strokePattern");
            const shadowColor = this.get("shadowColor");
            const shadowBlur = this.get("shadowBlur");
            const shadowOffsetX = this.get("shadowOffsetX");
            const shadowOffsetY = this.get("shadowOffsetY");
            const shadowOpacity = this.get("shadowOpacity");
            //const bounds = this._display.getLocalBounds();
            if (shadowColor && (shadowBlur || shadowOffsetX || shadowOffsetY)) {
                this._display.shadow(shadowColor, shadowBlur, shadowOffsetX, shadowOffsetY, shadowOpacity);
            }
            if (fill && !fillGradient) {
                this._display.beginFill(fill, fillOpacity);
                this._display.endFill();
            }
            if (fillGradient) {
                if (fill) {
                    const stops = fillGradient.get("stops", []);
                    if (stops.length) {
                        _util_Array__WEBPACK_IMPORTED_MODULE_3__.each(stops, (stop) => {
                            if ((!stop.color || stop.colorInherited) && fill) {
                                stop.color = fill;
                                stop.colorInherited = true;
                            }
                            if (stop.opacity == null || stop.opacityInherited) {
                                stop.opacity = fillOpacity;
                                stop.opacityInherited = true;
                            }
                        });
                    }
                }
                const gradient = fillGradient.getFill(this);
                if (gradient) {
                    this._display.beginFill(gradient, fillOpacity);
                    this._display.endFill();
                }
            }
            if (fillPattern) {
                /*
                let changed = false;
                if (fill && (!fillPattern.get("fill") || fillPattern.get("fillInherited"))) {
                    fillPattern.set("fill", fill);
                    fillPattern.set("fillInherited", true)
                    changed = true;
                }
                if (stroke && (!fillPattern.get("color") || fillPattern.get("colorInherited"))) {
                    fillPattern.set("color", stroke);
                    fillPattern.set("colorInherited", true)
                    changed = true;
                }
                if (changed) {
                    // @todo: is this OK?
                    fillPattern._changed();
                }
                */
                const pattern = fillPattern.pattern;
                if (pattern) {
                    this._display.beginFill(pattern, fillOpacity);
                    this._display.endFill();
                    if (fillPattern instanceof _render_patterns_PicturePattern__WEBPACK_IMPORTED_MODULE_4__.PicturePattern) {
                        fillPattern.events.once("loaded", () => {
                            this._clear = true;
                            this.markDirty();
                        });
                    }
                }
            }
            if (stroke || strokeGradient || strokePattern) {
                const strokeOpacity = this.get("strokeOpacity");
                let strokeWidth = this.get("strokeWidth", 1);
                if (this.get("nonScalingStroke")) {
                    strokeWidth = strokeWidth / this.get("scale", 1);
                }
                if (this.get("crisp")) {
                    strokeWidth /= this._root._renderer.resolution;
                }
                const lineJoin = this.get("lineJoin");
                if (stroke && !strokeGradient) {
                    this._display.lineStyle(strokeWidth, stroke, strokeOpacity, lineJoin);
                    this._display.endStroke();
                }
                if (strokeGradient) {
                    const stops = strokeGradient.get("stops", []);
                    if (stops.length) {
                        _util_Array__WEBPACK_IMPORTED_MODULE_3__.each(stops, (stop) => {
                            if ((!stop.color || stop.colorInherited) && stroke) {
                                stop.color = stroke;
                                stop.colorInherited = true;
                            }
                            if (stop.opacity == null || stop.opacityInherited) {
                                stop.opacity = strokeOpacity;
                                stop.opacityInherited = true;
                            }
                        });
                    }
                    const gradient = strokeGradient.getFill(this);
                    if (gradient) {
                        this._display.lineStyle(strokeWidth, gradient, strokeOpacity, lineJoin);
                        this._display.endStroke();
                    }
                }
                if (strokePattern) {
                    /*
                    let changed = false;
                    
                    if (stroke && (!strokePattern.get("color") || strokePattern.get("colorInherited"))) {
                        strokePattern.set("color", stroke);
                        strokePattern.set("colorInherited", true);
                        changed = true;
                    }
                    if (changed) {
                        // @todo: is this OK?
                        strokePattern._changed();
                    }
                    */
                    let pattern = strokePattern.pattern;
                    if (pattern) {
                        this._display.lineStyle(strokeWidth, pattern, strokeOpacity, lineJoin);
                        this._display.endStroke();
                        if (strokePattern instanceof _render_patterns_PicturePattern__WEBPACK_IMPORTED_MODULE_4__.PicturePattern) {
                            strokePattern.events.once("loaded", () => {
                                this._clear = true;
                                this.markDirty();
                            });
                        }
                    }
                }
            }
            if (this.getPrivate("showingTooltip")) {
                this.showTooltip();
            }
        }
        this._clear = false;
    }
}
Object.defineProperty(Graphics, "className", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: "Graphics"
});
Object.defineProperty(Graphics, "classNames", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: _Sprite__WEBPACK_IMPORTED_MODULE_0__.Sprite.classNames.concat([Graphics.className])
});
//# sourceMappingURL=Graphics.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/core/render/GridLayout.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/core/render/GridLayout.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GridLayout: () => (/* binding */ GridLayout)
/* harmony export */ });
/* harmony import */ var _Layout__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Layout */ "./node_modules/@amcharts/amcharts5/.internal/core/render/Layout.js");
/* harmony import */ var _util_Array__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/Array */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Array.js");
/* harmony import */ var _util_Math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/Math */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Math.js");



/**
 * A grid children layout for [[Container]].
 *
 * @see {@link https://www.amcharts.com/docs/v5/concepts/common-elements/containers/#Layout} for more info
 */
class GridLayout extends _Layout__WEBPACK_IMPORTED_MODULE_0__.Layout {
    _afterNew() {
        this._setRawDefault("maxColumns", Number.MAX_VALUE);
        super._afterNew();
    }
    /**
     * @ignore
     */
    updateContainer(container) {
        let paddingLeft = container.get("paddingLeft", 0);
        let paddingRight = container.get("paddingRight", 0);
        let paddingTop = container.get("paddingTop", 0);
        let availableWidth = container.maxWidth() - paddingLeft - paddingRight;
        let minCellWidth = availableWidth;
        let maxCellWidth = 1;
        (0,_Layout__WEBPACK_IMPORTED_MODULE_0__.eachChildren)(container, (child) => {
            if (child.get("visible") && child.getPrivate("visible") && !child.get("forceHidden")) {
                if (child.get("position") != "absolute") {
                    let childWidth = child.width();
                    if (childWidth < minCellWidth) {
                        minCellWidth = childWidth;
                    }
                    if (childWidth > maxCellWidth) {
                        maxCellWidth = childWidth;
                    }
                }
            }
        });
        minCellWidth = _util_Math__WEBPACK_IMPORTED_MODULE_1__.fitToRange(minCellWidth, 1, availableWidth);
        maxCellWidth = _util_Math__WEBPACK_IMPORTED_MODULE_1__.fitToRange(maxCellWidth, 1, availableWidth);
        let columnCount = 1;
        if (this.get("fixedWidthGrid")) {
            columnCount = availableWidth / maxCellWidth;
        }
        else {
            columnCount = availableWidth / minCellWidth;
        }
        columnCount = Math.max(1, Math.floor(columnCount));
        columnCount = Math.min(this.get("maxColumns", Number.MAX_VALUE), columnCount);
        let columnWidths = this.getColumnWidths(container, columnCount, maxCellWidth, availableWidth);
        let prevY = paddingTop;
        let column = 0;
        let maxColumnHeight = 0;
        columnCount = columnWidths.length;
        let prevX = paddingLeft;
        (0,_Layout__WEBPACK_IMPORTED_MODULE_0__.eachChildren)(container, (child) => {
            if (child.get("position") == "relative" && child.isVisible()) {
                const marginTop = child.get("marginTop", 0);
                const marginBottom = child.get("marginBottom", 0);
                let bounds = child.adjustedLocalBounds();
                let marginLeft = child.get("marginLeft", 0);
                let marginRight = child.get("marginRight", 0);
                let x = prevX + marginLeft - bounds.left;
                let y = prevY + marginTop - bounds.top;
                child.setPrivate("x", x);
                child.setPrivate("y", y);
                prevX += columnWidths[column] + marginRight;
                maxColumnHeight = Math.max(maxColumnHeight, child.height() + marginTop + marginBottom);
                column++;
                if (column >= columnCount) {
                    column = 0;
                    prevX = paddingLeft;
                    prevY += maxColumnHeight;
                }
            }
        });
    }
    /**
     * @ignore
     */
    getColumnWidths(container, columnCount, maxCellWidth, availableWidth) {
        let totalWidth = 0;
        let columnWidths = [];
        let column = 0;
        (0,_Layout__WEBPACK_IMPORTED_MODULE_0__.eachChildren)(container, (child) => {
            let bounds = child.adjustedLocalBounds();
            if (child.get("position") != "absolute" && child.isVisible()) {
                if (this.get("fixedWidthGrid")) {
                    columnWidths[column] = maxCellWidth;
                }
                else {
                    columnWidths[column] = Math.max(columnWidths[column] | 0, bounds.right - bounds.left + child.get("marginLeft", 0) + child.get("marginRight", 0));
                }
                if (column < container.children.length - 1) {
                    column++;
                    if (column == columnCount) {
                        column = 0;
                    }
                }
            }
        });
        _util_Array__WEBPACK_IMPORTED_MODULE_2__.each(columnWidths, (w) => {
            totalWidth += w;
        });
        if (totalWidth > availableWidth) {
            if (columnCount > 2) {
                columnCount -= 1;
                return this.getColumnWidths(container, columnCount, maxCellWidth, availableWidth);
            }
            else {
                return [availableWidth];
            }
        }
        return columnWidths;
    }
}
Object.defineProperty(GridLayout, "className", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: "GridLayout"
});
Object.defineProperty(GridLayout, "classNames", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: _Layout__WEBPACK_IMPORTED_MODULE_0__.Layout.classNames.concat([GridLayout.className])
});
//# sourceMappingURL=GridLayout.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/core/render/HorizontalLayout.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/core/render/HorizontalLayout.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   HorizontalLayout: () => (/* binding */ HorizontalLayout)
/* harmony export */ });
/* harmony import */ var _Layout__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Layout */ "./node_modules/@amcharts/amcharts5/.internal/core/render/Layout.js");
/* harmony import */ var _util_Type__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/Type */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Type.js");
/* harmony import */ var _util_Percent__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/Percent */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Percent.js");



/**
 * A horizontal children layout for [[Container]].
 *
 * @see {@link https://www.amcharts.com/docs/v5/concepts/common-elements/containers/#Layout} for more info
 */
class HorizontalLayout extends _Layout__WEBPACK_IMPORTED_MODULE_0__.Layout {
    /**
     * @ignore
     */
    updateContainer(container) {
        let paddingLeft = container.get("paddingLeft", 0);
        let availableWidth = container.innerWidth();
        let totalPercent = 0;
        (0,_Layout__WEBPACK_IMPORTED_MODULE_0__.eachChildren)(container, (child) => {
            if (child.isVisible()) {
                if (child.get("position") == "relative") {
                    let childWidth = child.get("width");
                    if (childWidth instanceof _util_Percent__WEBPACK_IMPORTED_MODULE_1__.Percent) {
                        totalPercent += childWidth.value;
                        let w = availableWidth * childWidth.value;
                        let minWidth = child.get("minWidth", child.getPrivate("minWidth", -Infinity));
                        if (minWidth > w) {
                            availableWidth -= minWidth;
                            totalPercent -= childWidth.value;
                        }
                        let maxWidth = child.get("maxWidth", child.getPrivate("maxWidth", Infinity));
                        if (w > maxWidth) {
                            availableWidth -= maxWidth;
                            totalPercent -= childWidth.value;
                        }
                    }
                    else {
                        if (!_util_Type__WEBPACK_IMPORTED_MODULE_2__.isNumber(childWidth)) {
                            childWidth = child.width();
                        }
                        availableWidth -= childWidth + child.get("marginLeft", 0) + child.get("marginRight", 0);
                    }
                }
            }
        });
        if (availableWidth <= 0 || availableWidth == Infinity) {
            availableWidth = .1;
        }
        //if (availableWidth > 0) {
        (0,_Layout__WEBPACK_IMPORTED_MODULE_0__.eachChildren)(container, (child) => {
            if (child.isVisible()) {
                if (child.get("position") == "relative") {
                    let childWidth = child.get("width");
                    if (childWidth instanceof _util_Percent__WEBPACK_IMPORTED_MODULE_1__.Percent) {
                        let privateWidth = availableWidth * childWidth.value / totalPercent - child.get("marginLeft", 0) - child.get("marginRight", 0);
                        let minWidth = child.get("minWidth", child.getPrivate("minWidth", -Infinity));
                        let maxWidth = child.get("maxWidth", child.getPrivate("maxWidth", Infinity));
                        privateWidth = Math.min(Math.max(minWidth, privateWidth), maxWidth);
                        child.setPrivate("width", privateWidth);
                    }
                    else {
                        if (child._prevSettings.width instanceof _util_Percent__WEBPACK_IMPORTED_MODULE_1__.Percent) {
                            child.setPrivate("width", undefined);
                        }
                    }
                }
            }
        });
        //}
        let prevX = paddingLeft;
        (0,_Layout__WEBPACK_IMPORTED_MODULE_0__.eachChildren)(container, (child) => {
            if (child.get("position") == "relative") {
                if (child.isVisible()) {
                    let bounds = child.adjustedLocalBounds();
                    let marginLeft = child.get("marginLeft", 0);
                    let marginRight = child.get("marginRight", 0);
                    let maxWidth = child.get("maxWidth");
                    let left = bounds.left;
                    let right = bounds.right;
                    if (maxWidth) {
                        if (right - left > maxWidth) {
                            right = left + maxWidth;
                        }
                    }
                    let x = prevX + marginLeft - left;
                    child.setPrivate("x", x);
                    prevX = x + right + marginRight;
                }
                else {
                    child.setPrivate("x", undefined);
                }
            }
        });
    }
}
Object.defineProperty(HorizontalLayout, "className", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: "HorizontalLayout"
});
Object.defineProperty(HorizontalLayout, "classNames", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: _Layout__WEBPACK_IMPORTED_MODULE_0__.Layout.classNames.concat([HorizontalLayout.className])
});
//# sourceMappingURL=HorizontalLayout.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/core/render/Label.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/core/render/Label.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Label: () => (/* binding */ Label)
/* harmony export */ });
/* harmony import */ var _render_Text__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../render/Text */ "./node_modules/@amcharts/amcharts5/.internal/core/render/Text.js");
/* harmony import */ var _util_Percent__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util/Percent */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Percent.js");
/* harmony import */ var _Container__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Container */ "./node_modules/@amcharts/amcharts5/.internal/core/render/Container.js");
/* harmony import */ var _core_util_Array__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../core/util/Array */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Array.js");
/* harmony import */ var _core_util_Type__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../core/util/Type */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Type.js");





/**
 * Creates a label with support for in-line styling and data bindings.
 *
 * @see {@link https://www.amcharts.com/docs/v5/concepts/common-elements/labels/} for more info
 */
class Label extends _Container__WEBPACK_IMPORTED_MODULE_0__.Container {
    constructor() {
        super(...arguments);
        Object.defineProperty(this, "_text", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_textKeys", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: [
                "text",
                "fill",
                "fillOpacity",
                "textAlign",
                "fontFamily",
                "fontSize",
                "fontStyle",
                "fontWeight",
                "fontStyle",
                "fontVariant",
                "textDecoration",
                "shadowColor",
                "shadowBlur",
                "shadowOffsetX",
                "shadowOffsetY",
                "shadowOpacity",
                // "leading",
                // "letterSpacing",
                "lineHeight",
                "baselineRatio",
                //"padding",
                // "stroke",
                // "strokeThickness",
                // "trim",
                // "wordWrap",
                "direction",
                "textBaseline",
                "oversizedBehavior",
                "breakWords",
                "ellipsis",
                "minScale",
                "populateText",
                "role",
                "ignoreFormatting"
            ]
        });
    }
    /**
     * @ignore Text is not to be used directly
     */
    get text() {
        return this._text;
    }
    _afterNew() {
        super._afterNew();
        this._makeText();
        _core_util_Array__WEBPACK_IMPORTED_MODULE_1__.each(this._textKeys, (property) => {
            const propValue = this.get(property);
            if (propValue != undefined) {
                this._text.set(property, propValue);
            }
        });
        if (this.get("html", "") !== "") {
            this._text.set("text", "");
        }
        this.onPrivate("maxWidth", () => {
            this._setMaxDimentions();
        });
        this.onPrivate("maxHeight", () => {
            this._setMaxDimentions();
        });
    }
    _makeText() {
        this._text = this.children.push(_render_Text__WEBPACK_IMPORTED_MODULE_2__.Text.new(this._root, {}));
    }
    _updateChildren() {
        super._updateChildren();
        _core_util_Array__WEBPACK_IMPORTED_MODULE_1__.each(this._textKeys, (property) => {
            this._text.set(property, this.get(property));
        });
        if (this.isDirty("maxWidth")) {
            this._setMaxDimentions();
        }
        if (this.isDirty("maxHeight")) {
            this._setMaxDimentions();
        }
        if (this.isDirty("rotation")) {
            this._setMaxDimentions();
        }
        // Do not show regular text if HTML is used
        if (this.get("html", "") !== "") {
            this._text.set("text", "");
        }
        else {
            this._text.set("text", this.get("text"));
        }
        if (this.isDirty("textAlign") || this.isDirty("width")) {
            const textAlign = this.get("textAlign");
            let x;
            if (this.get("width") != null) {
                if (textAlign == "right") {
                    x = _util_Percent__WEBPACK_IMPORTED_MODULE_3__.p100;
                }
                else if (textAlign == "center") {
                    x = _util_Percent__WEBPACK_IMPORTED_MODULE_3__.p50;
                }
                else {
                    x = 0;
                }
            }
            else {
                if (textAlign == "left" || textAlign == "start") {
                    x = this.get("paddingLeft");
                }
                else if (textAlign == "right" || textAlign == "end") {
                    x = -this.get("paddingRight");
                }
            }
            this.text.set("x", x);
        }
    }
    _setMaxDimentions() {
        const rotation = this.get("rotation");
        const vertical = rotation == 90 || rotation == 270 || rotation == -90;
        const maxWidth = this.get("maxWidth", this.getPrivate("maxWidth", Infinity));
        if (_core_util_Type__WEBPACK_IMPORTED_MODULE_4__.isNumber(maxWidth)) {
            this.text.set(vertical ? "maxHeight" : "maxWidth", maxWidth - this.get("paddingLeft", 0) - this.get("paddingRight", 0));
        }
        else {
            this.text.set(vertical ? "maxHeight" : "maxWidth", undefined);
        }
        const maxHeight = this.get("maxHeight", this.getPrivate("maxHeight", Infinity));
        if (_core_util_Type__WEBPACK_IMPORTED_MODULE_4__.isNumber(maxHeight)) {
            this.text.set(vertical ? "maxWidth" : "maxHeight", maxHeight - this.get("paddingTop", 0) - this.get("paddingBottom", 0));
        }
        else {
            this.text.set(vertical ? "maxWidth" : "maxHeight", undefined);
        }
    }
    _setDataItem(dataItem) {
        super._setDataItem(dataItem);
        this._markDirtyKey("text");
        if (this.text.get("populateText")) {
            this.text.markDirtyText();
        }
    }
    /**
     * Returns text with populated placeholders and formatting if `populateText` is
     * set to `true`.
     *
     * @return Populated text
     */
    getText() {
        return this._text._getText();
    }
}
Object.defineProperty(Label, "className", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: "Label"
});
Object.defineProperty(Label, "classNames", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: _Container__WEBPACK_IMPORTED_MODULE_0__.Container.classNames.concat([Label.className])
});
//# sourceMappingURL=Label.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/core/render/Layout.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/core/render/Layout.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Layout: () => (/* binding */ Layout),
/* harmony export */   eachChildren: () => (/* binding */ eachChildren)
/* harmony export */ });
/* harmony import */ var _util_Entity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/Entity */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Entity.js");

function eachChildren(container, f) {
    if (container.get("reverseChildren", false)) {
        container.children.eachReverse(f);
    }
    else {
        container.children.each(f);
    }
}
/**
 * Base class for [[Container]] layouts.
 */
class Layout extends _util_Entity__WEBPACK_IMPORTED_MODULE_0__.Entity {
}
Object.defineProperty(Layout, "className", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: "Layout"
});
Object.defineProperty(Layout, "classNames", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: _util_Entity__WEBPACK_IMPORTED_MODULE_0__.Entity.classNames.concat([Layout.className])
});
//# sourceMappingURL=Layout.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/core/render/Legend.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/core/render/Legend.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Legend: () => (/* binding */ Legend)
/* harmony export */ });
/* harmony import */ var _Series__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Series */ "./node_modules/@amcharts/amcharts5/.internal/core/render/Series.js");
/* harmony import */ var _core_render_Container__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../core/render/Container */ "./node_modules/@amcharts/amcharts5/.internal/core/render/Container.js");
/* harmony import */ var _core_render_Label__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../core/render/Label */ "./node_modules/@amcharts/amcharts5/.internal/core/render/Label.js");
/* harmony import */ var _core_render_RoundedRectangle__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../core/render/RoundedRectangle */ "./node_modules/@amcharts/amcharts5/.internal/core/render/RoundedRectangle.js");
/* harmony import */ var _core_util_Template__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../core/util/Template */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Template.js");
/* harmony import */ var _core_util_List__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../core/util/List */ "./node_modules/@amcharts/amcharts5/.internal/core/util/List.js");
/* harmony import */ var _core_util_Utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../core/util/Utils */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Utils.js");







/**
 * A universal legend control.
 *
 * @important
 * @see {@link https://www.amcharts.com/docs/v5/concepts/legend/} for more info
 */
class Legend extends _Series__WEBPACK_IMPORTED_MODULE_0__.Series {
    constructor() {
        super(...arguments);
        /**
         * List of all [[Container]] elements for legend items.
         *
         * @default new ListTemplate<Container>
         */
        Object.defineProperty(this, "itemContainers", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new _core_util_List__WEBPACK_IMPORTED_MODULE_1__.ListTemplate(_core_util_Template__WEBPACK_IMPORTED_MODULE_2__.Template.new({}), () => _core_render_Container__WEBPACK_IMPORTED_MODULE_3__.Container._new(this._root, {
                themeTags: _core_util_Utils__WEBPACK_IMPORTED_MODULE_4__.mergeTags(this.itemContainers.template.get("themeTags", []), ["legend", "item"]),
                themeTagsSelf: _core_util_Utils__WEBPACK_IMPORTED_MODULE_4__.mergeTags(this.itemContainers.template.get("themeTagsSelf", []), ["itemcontainer"]),
                background: _core_render_RoundedRectangle__WEBPACK_IMPORTED_MODULE_5__.RoundedRectangle.new(this._root, {
                    themeTags: _core_util_Utils__WEBPACK_IMPORTED_MODULE_4__.mergeTags(this.itemContainers.template.get("themeTags", []), ["legend", "item", "background"]),
                    themeTagsSelf: _core_util_Utils__WEBPACK_IMPORTED_MODULE_4__.mergeTags(this.itemContainers.template.get("themeTagsSelf", []), ["itemcontainer"])
                })
            }, [this.itemContainers.template]))
        });
        /**
         * List of legend marker elements.
         *
         * @default new ListTemplate<Container>
         */
        Object.defineProperty(this, "markers", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new _core_util_List__WEBPACK_IMPORTED_MODULE_1__.ListTemplate(_core_util_Template__WEBPACK_IMPORTED_MODULE_2__.Template.new({}), () => _core_render_Container__WEBPACK_IMPORTED_MODULE_3__.Container._new(this._root, {
                themeTags: _core_util_Utils__WEBPACK_IMPORTED_MODULE_4__.mergeTags(this.markers.template.get("themeTags", []), ["legend", "marker"])
            }, [this.markers.template]))
        });
        /**
         * List of legend label elements.
         *
         * @default new ListTemplate<Label>
         */
        Object.defineProperty(this, "labels", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new _core_util_List__WEBPACK_IMPORTED_MODULE_1__.ListTemplate(_core_util_Template__WEBPACK_IMPORTED_MODULE_2__.Template.new({}), () => _core_render_Label__WEBPACK_IMPORTED_MODULE_6__.Label._new(this._root, {
                themeTags: _core_util_Utils__WEBPACK_IMPORTED_MODULE_4__.mergeTags(this.labels.template.get("themeTags", []), ["legend", "label"])
            }, [this.labels.template]))
        });
        /**
         * List of legend value label elements.
         *
         * @default new ListTemplate<label>
         */
        Object.defineProperty(this, "valueLabels", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new _core_util_List__WEBPACK_IMPORTED_MODULE_1__.ListTemplate(_core_util_Template__WEBPACK_IMPORTED_MODULE_2__.Template.new({}), () => _core_render_Label__WEBPACK_IMPORTED_MODULE_6__.Label._new(this._root, {
                themeTags: _core_util_Utils__WEBPACK_IMPORTED_MODULE_4__.mergeTags(this.valueLabels.template.get("themeTags", []), ["legend", "label", "value"])
            }, [this.valueLabels.template]))
        });
        /**
         * List of rectangle elements used for default legend markers.
         *
         * @default new ListTemplate<RoundedRectangle>
         */
        Object.defineProperty(this, "markerRectangles", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new _core_util_List__WEBPACK_IMPORTED_MODULE_1__.ListTemplate(_core_util_Template__WEBPACK_IMPORTED_MODULE_2__.Template.new({}), () => _core_render_RoundedRectangle__WEBPACK_IMPORTED_MODULE_5__.RoundedRectangle._new(this._root, {
                themeTags: _core_util_Utils__WEBPACK_IMPORTED_MODULE_4__.mergeTags(this.markerRectangles.template.get("themeTags", []), ["legend", "marker", "rectangle"])
            }, [this.markerRectangles.template]))
        });
    }
    _afterNew() {
        this._settings.themeTags = _core_util_Utils__WEBPACK_IMPORTED_MODULE_4__.mergeTags(this._settings.themeTags, ["legend"]);
        this.fields.push("name", "stroke", "fill");
        super._afterNew();
    }
    /**
     * @ignore
     */
    makeItemContainer(dataItem) {
        const itemContainer = this.children.push(this.itemContainers.make());
        itemContainer._setDataItem(dataItem);
        this.itemContainers.push(itemContainer);
        itemContainer.states.create("disabled", {});
        return itemContainer;
    }
    /**
     * @ignore
     */
    makeMarker() {
        const marker = this.markers.make();
        this.markers.push(marker);
        marker.states.create("disabled", {});
        return marker;
    }
    /**
     * @ignore
     */
    makeLabel() {
        const label = this.labels.make();
        label.states.create("disabled", {});
        return label;
    }
    /**
     * @ignore
     */
    makeValueLabel() {
        const valueLabel = this.valueLabels.make();
        valueLabel.states.create("disabled", {});
        return valueLabel;
    }
    /**
     * @ignore
     */
    makeMarkerRectangle() {
        const markerRectangle = this.markerRectangles.make();
        markerRectangle.states.create("disabled", {});
        return markerRectangle;
    }
    processDataItem(dataItem) {
        super.processDataItem(dataItem);
        const itemContainer = this.makeItemContainer(dataItem);
        const nameField = this.get("nameField");
        const fillField = this.get("fillField");
        const strokeField = this.get("strokeField");
        if (itemContainer) {
            const clickTarget = this.get("clickTarget", "itemContainer");
            const item = dataItem.dataContext;
            if (item && item.set) {
                item.set("legendDataItem", dataItem);
            }
            itemContainer._setDataItem(dataItem);
            dataItem.set("itemContainer", itemContainer);
            const marker = this.makeMarker();
            if (marker) {
                itemContainer.children.push(marker);
                marker._setDataItem(dataItem);
                dataItem.set("marker", marker);
                const useDefaultMarker = this.get("useDefaultMarker");
                const markerRectangle = marker.children.push(this.makeMarkerRectangle());
                let fill = dataItem.get("fill");
                let stroke = dataItem.get("stroke");
                dataItem.set("markerRectangle", markerRectangle);
                if (item && item.get) {
                    fill = item.get(fillField, fill);
                    stroke = item.get(strokeField, stroke);
                }
                if (!stroke) {
                    stroke = fill;
                }
                if (!useDefaultMarker) {
                    if (item && item.createLegendMarker) {
                        item.createLegendMarker();
                    }
                }
                else {
                    if (item.on) {
                        item.on(fillField, () => {
                            markerRectangle.set("fill", item.get(fillField));
                        });
                        item.on(strokeField, () => {
                            markerRectangle.set("stroke", item.get(strokeField));
                        });
                    }
                }
                markerRectangle.setAll({ fill, stroke });
                // this solves if template field is set on slice
                const component = item.component;
                if (component && component.updateLegendMarker) {
                    component.updateLegendMarker(item);
                }
            }
            const label = this.makeLabel();
            if (label) {
                itemContainer.children.push(label);
                label._setDataItem(dataItem);
                dataItem.set("label", label);
                label.text.on("text", () => {
                    itemContainer.setRaw("ariaLabel", label.text._getText() + (this.get("clickTarget") !== "none" ? "; " + this._t("Press ENTER to toggle") : ""));
                    itemContainer.markDirtyAccessibility();
                });
                if (item && item.get) {
                    dataItem.set("name", item.get(nameField));
                }
                let name = dataItem.get("name");
                if (name) {
                    label.set("text", name);
                }
            }
            const valueLabel = this.makeValueLabel();
            if (valueLabel) {
                itemContainer.children.push(valueLabel);
                valueLabel._setDataItem(dataItem);
                dataItem.set("valueLabel", valueLabel);
            }
            if (item && item.show) {
                item.on("visible", (visible) => {
                    itemContainer.set("disabled", !visible);
                });
                if (!item.get("visible")) {
                    itemContainer.set("disabled", true);
                }
                if (clickTarget != "none") {
                    let clickContainer = itemContainer;
                    if (clickTarget == "marker") {
                        clickContainer = marker;
                    }
                    this._addClickEvents(clickContainer, item, dataItem);
                }
            }
            // Sort children
            this.children.values.sort((a, b) => {
                const targetA = a.dataItem.dataContext;
                const targetB = b.dataItem.dataContext;
                if (targetA && targetB) {
                    const indexA = this.data.indexOf(targetA);
                    const indexB = this.data.indexOf(targetB);
                    if (indexA > indexB) {
                        return 1;
                    }
                    else if (indexA < indexB) {
                        return -1;
                    }
                }
                return 0;
            });
            if (item && item.updateLegendValue) {
                item.updateLegendValue();
            }
        }
    }
    _addClickEvents(container, item, dataItem) {
        container.set("cursorOverStyle", "pointer");
        container.events.on("pointerover", () => {
            const component = item.component;
            if (component && component.hoverDataItem) {
                component.hoverDataItem(item);
            }
        });
        container.events.on("pointerout", () => {
            const component = item.component;
            if (component && component.hoverDataItem) {
                component.unhoverDataItem(item);
            }
        });
        container.events.on("click", () => {
            const labelText = dataItem.get("label").text._getText();
            if (item.show && item.isHidden && (item.isHidden() || item.get("visible") === false)) {
                item.show();
                container.set("disabled", false);
                this._root.readerAlert(this._t("%1 shown", this._root.locale, labelText));
            }
            else if (item.hide) {
                item.hide();
                container.set("disabled", true);
                this._root.readerAlert(this._t("%1 hidden", this._root.locale, labelText));
            }
        });
    }
    /**
     * @ignore
     */
    disposeDataItem(dataItem) {
        super.disposeDataItem(dataItem);
        const dataContext = dataItem.dataContext;
        if (dataContext && dataContext.get) {
            const di = dataContext.get("legendDataItem");
            if (di == dataItem) {
                dataContext.set("legendDataItem", undefined);
            }
        }
        let itemContainer = dataItem.get("itemContainer");
        if (itemContainer) {
            this.itemContainers.removeValue(itemContainer);
            itemContainer.dispose();
        }
        let marker = dataItem.get("marker");
        if (marker) {
            this.markers.removeValue(marker);
            marker.dispose();
        }
        let markerRectangle = dataItem.get("markerRectangle");
        if (markerRectangle) {
            this.markerRectangles.removeValue(markerRectangle);
            markerRectangle.dispose();
        }
        let label = dataItem.get("label");
        if (label) {
            this.labels.removeValue(label);
            label.dispose();
        }
        let valueLabel = dataItem.get("valueLabel");
        if (valueLabel) {
            this.valueLabels.removeValue(valueLabel);
            valueLabel.dispose();
        }
    }
}
Object.defineProperty(Legend, "className", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: "Legend"
});
Object.defineProperty(Legend, "classNames", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: _Series__WEBPACK_IMPORTED_MODULE_0__.Series.classNames.concat([Legend.className])
});
//# sourceMappingURL=Legend.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/core/render/Line.js":
/*!************************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/core/render/Line.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Line: () => (/* binding */ Line)
/* harmony export */ });
/* harmony import */ var _Graphics__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Graphics */ "./node_modules/@amcharts/amcharts5/.internal/core/render/Graphics.js");
/* harmony import */ var _util_Draw__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/Draw */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Draw.js");


/**
 * Draws a line.
 *
 * @see {@link https://www.amcharts.com/docs/v5/concepts/common-elements/graphics/} for more info
 * @important
 */
class Line extends _Graphics__WEBPACK_IMPORTED_MODULE_0__.Graphics {
    _beforeChanged() {
        super._beforeChanged();
        if (this.isDirty("points") || this.isDirty("segments") || this._sizeDirty || this.isPrivateDirty("width") || this.isPrivateDirty("height")) {
            this._clear = true;
        }
    }
    _changed() {
        super._changed();
        if (this._clear) {
            const points = this.get("points");
            const segments = this.get("segments");
            if (points && points.length > 0) {
                let point = points[0];
                this._display.moveTo(point.x, point.y);
                _util_Draw__WEBPACK_IMPORTED_MODULE_1__.segmentedLine(this._display, [[points]]);
            }
            else if (segments) {
                _util_Draw__WEBPACK_IMPORTED_MODULE_1__.segmentedLine(this._display, segments);
            }
            else if (!this.get("draw")) {
                let w = this.width();
                let h = this.height();
                this._display.moveTo(0, 0);
                this._display.lineTo(w, h);
            }
        }
    }
}
Object.defineProperty(Line, "className", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: "Line"
});
Object.defineProperty(Line, "classNames", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: _Graphics__WEBPACK_IMPORTED_MODULE_0__.Graphics.classNames.concat([Line.className])
});
//# sourceMappingURL=Line.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/core/render/PointedRectangle.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/core/render/PointedRectangle.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PointedRectangle: () => (/* binding */ PointedRectangle)
/* harmony export */ });
/* harmony import */ var _Graphics__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Graphics */ "./node_modules/@amcharts/amcharts5/.internal/core/render/Graphics.js");
/* harmony import */ var _util_Math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/Math */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Math.js");


/**
 * Draws a rectangle with a pointer.
 *
 * @see {@link https://www.amcharts.com/docs/v5/concepts/common-elements/graphics/} for more info
 * @important
 */
class PointedRectangle extends _Graphics__WEBPACK_IMPORTED_MODULE_0__.Graphics {
    _beforeChanged() {
        super._beforeChanged();
        if (this.isDirty("pointerBaseWidth") || this.isDirty("cornerRadius") || this.isDirty("pointerLength") || this.isDirty("pointerX") || this.isDirty("pointerY") || this.isDirty("width") || this.isDirty("height")) {
            this._clear = true;
        }
    }
    _changed() {
        super._changed();
        if (this._clear) {
            this.markDirtyBounds();
            let w = this.width();
            let h = this.height();
            if (w > 0 && h > 0) {
                let cr = this.get("cornerRadius", 8);
                cr = _util_Math__WEBPACK_IMPORTED_MODULE_1__.fitToRange(cr, 0, Math.min(w / 2, h / 2));
                let x = this.get("pointerX", 0);
                let y = this.get("pointerY", 0);
                let bwh = this.get("pointerBaseWidth", 15) / 2;
                // corner coordinates
                // top left
                let xtl = 0;
                let ytl = 0;
                // top right
                let xtr = w;
                let ytr = 0;
                // bottom right
                let xbr = w;
                let ybr = h;
                // bottom left
                let xbl = 0;
                let ybl = h;
                // find stem base side: http://$math.stackexchange.com/questions/274712/calculate-on-which-side-of-straign-line-is-dot-located
                // d=(x−x1)(y2−y1)−(y−y1)(x2−x1)
                let d1 = (x - xtl) * (ybr - ytl) - (y - ytl) * (xbr - xtl);
                let d2 = (x - xbl) * (ytr - ybl) - (y - ybl) * (xtr - xbl);
                const display = this._display;
                // top
                display.moveTo(cr, 0);
                if (d1 > 0 && d2 > 0) {
                    let stemX = Math.round(_util_Math__WEBPACK_IMPORTED_MODULE_1__.fitToRange(x, cr + bwh, w - bwh - cr));
                    y = _util_Math__WEBPACK_IMPORTED_MODULE_1__.fitToRange(y, -Infinity, 0);
                    display.lineTo(stemX - bwh, 0);
                    display.lineTo(x, y);
                    display.lineTo(stemX + bwh, 0);
                }
                display.lineTo(w - cr, 0);
                display.arcTo(w, 0, w, cr, cr);
                // right
                if (d1 > 0 && d2 < 0) {
                    let stemY = Math.round(_util_Math__WEBPACK_IMPORTED_MODULE_1__.fitToRange(y, cr + bwh, h - bwh - cr));
                    x = _util_Math__WEBPACK_IMPORTED_MODULE_1__.fitToRange(x, w, Infinity);
                    display.lineTo(w, cr);
                    display.lineTo(w, Math.max(stemY - bwh, cr));
                    display.lineTo(x, y);
                    display.lineTo(w, stemY + bwh);
                }
                display.lineTo(w, h - cr);
                display.arcTo(w, h, w - cr, h, cr);
                // bottom
                if (d1 < 0 && d2 < 0) {
                    let stemX = Math.round(_util_Math__WEBPACK_IMPORTED_MODULE_1__.fitToRange(x, cr + bwh, w - bwh - cr));
                    y = _util_Math__WEBPACK_IMPORTED_MODULE_1__.fitToRange(y, h, Infinity);
                    display.lineTo(w - cr, h);
                    display.lineTo(stemX + bwh, h);
                    display.lineTo(x, y);
                    display.lineTo(stemX - bwh, h);
                }
                display.lineTo(cr, h);
                display.arcTo(0, h, 0, h - cr, cr);
                // left
                if (d1 < 0 && d2 > 0) {
                    let stemY = Math.round(_util_Math__WEBPACK_IMPORTED_MODULE_1__.fitToRange(y, cr + bwh, h - cr - bwh));
                    x = _util_Math__WEBPACK_IMPORTED_MODULE_1__.fitToRange(x, -Infinity, 0);
                    display.lineTo(0, h - cr);
                    display.lineTo(0, stemY + bwh);
                    display.lineTo(x, y);
                    display.lineTo(0, Math.max(stemY - bwh, cr));
                }
                display.lineTo(0, cr);
                display.arcTo(0, 0, cr, 0, cr);
                display.closePath();
            }
        }
    }
}
Object.defineProperty(PointedRectangle, "className", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: "PointedRectangle"
});
Object.defineProperty(PointedRectangle, "classNames", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: _Graphics__WEBPACK_IMPORTED_MODULE_0__.Graphics.classNames.concat([PointedRectangle.className])
});
//# sourceMappingURL=PointedRectangle.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/core/render/RadialLabel.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/core/render/RadialLabel.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   RadialLabel: () => (/* binding */ RadialLabel)
/* harmony export */ });
/* harmony import */ var _util_Percent__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../util/Percent */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Percent.js");
/* harmony import */ var _Label__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Label */ "./node_modules/@amcharts/amcharts5/.internal/core/render/Label.js");
/* harmony import */ var _RadialText__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./RadialText */ "./node_modules/@amcharts/amcharts5/.internal/core/render/RadialText.js");
/* harmony import */ var _util_Math__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util/Math */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Math.js");
/* harmony import */ var _util_Utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/Utils */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Utils.js");
// import * as $object from "../util/Object";





class RadialLabel extends _Label__WEBPACK_IMPORTED_MODULE_0__.Label {
    constructor() {
        super(...arguments);
        Object.defineProperty(this, "_flipped", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
    }
    _afterNew() {
        this._textKeys.push("textType", "kerning");
        super._afterNew();
    }
    _makeText() {
        this._text = this.children.push(_RadialText__WEBPACK_IMPORTED_MODULE_1__.RadialText.new(this._root, {}));
    }
    /**
     * Returns base radius in pixels.
     *
     * @return Base radius
     */
    baseRadius() {
        const radiusPrivate = this.getPrivate("radius", 0);
        const innerRadiusPrivate = this.getPrivate("innerRadius", 0);
        const baseRadius = this.get("baseRadius", 0);
        return innerRadiusPrivate + _util_Utils__WEBPACK_IMPORTED_MODULE_2__.relativeToValue(baseRadius, radiusPrivate - innerRadiusPrivate);
    }
    /**
     * Returns radius adjustment in pixels.
     *
     * @return Radius
     */
    radius() {
        const inside = this.get("inside", false);
        return this.baseRadius() + this.get("radius", 0) * (inside ? -1 : 1);
    }
    _updateChildren() {
        super._updateChildren();
        if (this.isDirty("baseRadius") || this.isPrivateDirty("radius") || this.isPrivateDirty("innerRadius") || this.isDirty("labelAngle") || this.isDirty("radius") || this.isDirty("inside") || this.isDirty("orientation") || this.isDirty("textType")) {
            const textType = this.get("textType", "adjusted");
            const inside = this.get("inside", false);
            const orientation = this.get("orientation");
            let labelAngle = _util_Math__WEBPACK_IMPORTED_MODULE_3__.normalizeAngle(this.get("labelAngle", 0));
            this._text.set("startAngle", this.get("labelAngle", 0));
            this._text.set("inside", inside);
            const sin = _util_Math__WEBPACK_IMPORTED_MODULE_3__.sin(labelAngle);
            const cos = _util_Math__WEBPACK_IMPORTED_MODULE_3__.cos(labelAngle);
            let baseRadius = this.baseRadius();
            let radius = this.radius();
            this._display.angle = 0;
            if (textType == "circular") {
                this.setAll({
                    paddingTop: 0,
                    paddingBottom: 0,
                    paddingLeft: 0,
                    paddingRight: 0
                });
                // Circular labels are handled and positioned differently
                this._text.set("orientation", orientation);
                this._text.set("radius", radius);
            }
            else {
                if (baseRadius == 0) {
                    labelAngle = 0;
                    radius = 0;
                }
                // Positioning of radial/regular labels are teh same
                let x = radius * cos;
                let y = radius * sin;
                if (textType == "radial") {
                    this.setRaw("x", x);
                    this.setRaw("y", y);
                    if ((labelAngle < 90) || (labelAngle > 270) || orientation != "auto") {
                        this._display.angle = labelAngle; // + 90;
                        this._flipped = false;
                    }
                    else {
                        this._display.angle = labelAngle + 180;
                        this._flipped = true;
                    }
                    this._dirty.rotation = false;
                }
                else if (textType == "adjusted") {
                    this.setRaw("centerX", _util_Percent__WEBPACK_IMPORTED_MODULE_4__.p50);
                    this.setRaw("centerY", _util_Percent__WEBPACK_IMPORTED_MODULE_4__.p50);
                    this.setRaw("x", x);
                    this.setRaw("y", y);
                }
                else if (textType == "regular") {
                    this.setRaw("x", x);
                    this.setRaw("y", y);
                }
            }
            this.markDirtyPosition();
            this.markDirtyBounds();
        }
    }
    _updatePosition() {
        const textType = this.get("textType", "regular");
        const inside = this.get("inside", false);
        let dx = 0;
        let dy = 0;
        let labelAngle = this.get("labelAngle", 0);
        let bounds = this.localBounds();
        let w = bounds.right - bounds.left;
        let h = bounds.bottom - bounds.top;
        if (textType == "radial") {
            if (this._flipped) {
                let centerX = this.get("centerX");
                if (centerX instanceof _util_Percent__WEBPACK_IMPORTED_MODULE_4__.Percent) {
                    w = w * (1 - centerX.value * 2);
                }
                dx = w * _util_Math__WEBPACK_IMPORTED_MODULE_3__.cos(labelAngle);
                dy = w * _util_Math__WEBPACK_IMPORTED_MODULE_3__.sin(labelAngle);
            }
        }
        else if (!inside && textType == "adjusted") {
            dx = w / 2 * _util_Math__WEBPACK_IMPORTED_MODULE_3__.cos(labelAngle);
            dy = h / 2 * _util_Math__WEBPACK_IMPORTED_MODULE_3__.sin(labelAngle);
        }
        this.setRaw("dx", dx);
        this.setRaw("dy", dy);
        super._updatePosition();
    }
    /**
     * @ignore
     */
    get text() {
        return this._text;
    }
}
Object.defineProperty(RadialLabel, "className", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: "RadialLabel"
});
Object.defineProperty(RadialLabel, "classNames", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: _Label__WEBPACK_IMPORTED_MODULE_0__.Label.classNames.concat([RadialLabel.className])
});
//# sourceMappingURL=RadialLabel.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/core/render/RadialText.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/core/render/RadialText.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   RadialText: () => (/* binding */ RadialText)
/* harmony export */ });
/* harmony import */ var _Text__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Text */ "./node_modules/@amcharts/amcharts5/.internal/core/render/Text.js");
/* harmony import */ var _util_Math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/Math */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Math.js");


/**
 * @ignore
 */
class RadialText extends _Text__WEBPACK_IMPORTED_MODULE_0__.Text {
    constructor() {
        super(...arguments);
        Object.defineProperty(this, "_display", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: this._root._renderer.makeRadialText("", this.textStyle)
        });
    }
    _afterNew() {
        super._afterNew();
    }
    _beforeChanged() {
        super._beforeChanged();
        this._display.clear();
        if (this.isDirty("textType")) {
            this._display.textType = this.get("textType");
            this.markDirtyBounds();
        }
        if (this.isDirty("radius")) {
            this._display.radius = this.get("radius");
            this.markDirtyBounds();
        }
        if (this.isDirty("startAngle")) {
            this._display.startAngle = (this.get("startAngle", 0) + 90) * _util_Math__WEBPACK_IMPORTED_MODULE_1__.RADIANS;
            this.markDirtyBounds();
        }
        if (this.isDirty("inside")) {
            this._display.inside = this.get("inside");
            this.markDirtyBounds();
        }
        if (this.isDirty("orientation")) {
            this._display.orientation = this.get("orientation");
            this.markDirtyBounds();
        }
        if (this.isDirty("kerning")) {
            this._display.kerning = this.get("kerning");
            this.markDirtyBounds();
        }
    }
}
Object.defineProperty(RadialText, "className", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: "RadialText"
});
Object.defineProperty(RadialText, "classNames", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: _Text__WEBPACK_IMPORTED_MODULE_0__.Text.classNames.concat([RadialText.className])
});
//# sourceMappingURL=RadialText.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/core/render/Rectangle.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/core/render/Rectangle.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Rectangle: () => (/* binding */ Rectangle)
/* harmony export */ });
/* harmony import */ var _Graphics__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Graphics */ "./node_modules/@amcharts/amcharts5/.internal/core/render/Graphics.js");

/**
 * Draws a rectangle.
 *
 * @see {@link https://www.amcharts.com/docs/v5/concepts/common-elements/graphics/} for more info
 * @important
 */
class Rectangle extends _Graphics__WEBPACK_IMPORTED_MODULE_0__.Graphics {
    _afterNew() {
        super._afterNew();
        this._display.isMeasured = true;
        this.setPrivateRaw("trustBounds", true);
    }
    _beforeChanged() {
        super._beforeChanged();
        if (this.isDirty("width") || this.isDirty("height") || this.isPrivateDirty("width") || this.isPrivateDirty("height")) {
            this._clear = true;
        }
    }
    _changed() {
        super._changed();
        if (this._clear && !this.get("draw")) {
            this._draw();
        }
    }
    _draw() {
        this._display.drawRect(0, 0, this.width(), this.height());
    }
    _updateSize() {
        this.markDirty();
        this._clear = true;
    }
}
Object.defineProperty(Rectangle, "className", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: "Rectangle"
});
Object.defineProperty(Rectangle, "classNames", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: _Graphics__WEBPACK_IMPORTED_MODULE_0__.Graphics.classNames.concat([Rectangle.className])
});
//# sourceMappingURL=Rectangle.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/core/render/RoundedRectangle.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/core/render/RoundedRectangle.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   RoundedRectangle: () => (/* binding */ RoundedRectangle)
/* harmony export */ });
/* harmony import */ var _util_Type__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/Type */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Type.js");
/* harmony import */ var _util_Math__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util/Math */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Math.js");
/* harmony import */ var _util_Utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/Utils */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Utils.js");
/* harmony import */ var _Rectangle__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Rectangle */ "./node_modules/@amcharts/amcharts5/.internal/core/render/Rectangle.js");




/**
 * Draws a rectangle with rounded corners.
 *
 * @see {@link https://www.amcharts.com/docs/v5/concepts/common-elements/graphics/} for more info
 * @important
 */
class RoundedRectangle extends _Rectangle__WEBPACK_IMPORTED_MODULE_0__.Rectangle {
    _beforeChanged() {
        super._beforeChanged();
        if (this.isDirty("cornerRadiusTL") || this.isDirty("cornerRadiusTR") || this.isDirty("cornerRadiusBR") || this.isDirty("cornerRadiusBL")) {
            this._clear = true;
        }
    }
    _draw() {
        let width = this.width();
        let height = this.height();
        let w = width;
        let h = height;
        let wSign = w / Math.abs(width);
        let hSign = h / Math.abs(height);
        if (_util_Type__WEBPACK_IMPORTED_MODULE_1__.isNumber(w) && _util_Type__WEBPACK_IMPORTED_MODULE_1__.isNumber(h)) {
            let minSide = Math.min(w, h) / 2;
            let crtl = _util_Utils__WEBPACK_IMPORTED_MODULE_2__.relativeToValue(this.get("cornerRadiusTL", 8), minSide);
            let crtr = _util_Utils__WEBPACK_IMPORTED_MODULE_2__.relativeToValue(this.get("cornerRadiusTR", 8), minSide);
            let crbr = _util_Utils__WEBPACK_IMPORTED_MODULE_2__.relativeToValue(this.get("cornerRadiusBR", 8), minSide);
            let crbl = _util_Utils__WEBPACK_IMPORTED_MODULE_2__.relativeToValue(this.get("cornerRadiusBL", 8), minSide);
            let maxcr = Math.min(Math.abs(w / 2), Math.abs(h / 2));
            crtl = _util_Math__WEBPACK_IMPORTED_MODULE_3__.fitToRange(crtl, 0, maxcr);
            crtr = _util_Math__WEBPACK_IMPORTED_MODULE_3__.fitToRange(crtr, 0, maxcr);
            crbr = _util_Math__WEBPACK_IMPORTED_MODULE_3__.fitToRange(crbr, 0, maxcr);
            crbl = _util_Math__WEBPACK_IMPORTED_MODULE_3__.fitToRange(crbl, 0, maxcr);
            const display = this._display;
            display.moveTo(crtl * wSign, 0);
            display.lineTo(w - crtr * wSign, 0);
            if (crtr > 0) {
                display.arcTo(w, 0, w, crtr * hSign, crtr);
            }
            display.lineTo(w, h - crbr * hSign);
            if (crbr > 0) {
                display.arcTo(w, h, w - crbr * wSign, h, crbr);
            }
            display.lineTo(crbl * wSign, h);
            if (crbl > 0) {
                display.arcTo(0, h, 0, h - crbl * hSign, crbl);
            }
            display.lineTo(0, crtl * hSign);
            if (crtl > 0) {
                display.arcTo(0, 0, crtl * wSign, 0, crtl);
            }
            display.closePath();
        }
    }
}
Object.defineProperty(RoundedRectangle, "className", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: "RoundedRectangle"
});
Object.defineProperty(RoundedRectangle, "classNames", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: _Rectangle__WEBPACK_IMPORTED_MODULE_0__.Rectangle.classNames.concat([RoundedRectangle.className])
});
//# sourceMappingURL=RoundedRectangle.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/core/render/Scrollbar.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/core/render/Scrollbar.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Scrollbar: () => (/* binding */ Scrollbar)
/* harmony export */ });
/* harmony import */ var _render_RoundedRectangle__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../render/RoundedRectangle */ "./node_modules/@amcharts/amcharts5/.internal/core/render/RoundedRectangle.js");
/* harmony import */ var _Container__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Container */ "./node_modules/@amcharts/amcharts5/.internal/core/render/Container.js");
/* harmony import */ var _Graphics__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Graphics */ "./node_modules/@amcharts/amcharts5/.internal/core/render/Graphics.js");
/* harmony import */ var _Button__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Button */ "./node_modules/@amcharts/amcharts5/.internal/core/render/Button.js");
/* harmony import */ var _util_Type__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../util/Type */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Type.js");
/* harmony import */ var _util_Utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/Utils */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Utils.js");






/**
 * A control that allows zooming chart's axes, or other uses requiring range
 * selection.
 *
 * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/scrollbars/} for more info
 */
class Scrollbar extends _Container__WEBPACK_IMPORTED_MODULE_0__.Container {
    constructor() {
        super(...arguments);
        /**
         * A thumb elment - a draggable square between the grips, used for panning
         * the selection.
         */
        Object.defineProperty(this, "thumb", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: this._makeThumb()
        });
        /**
         * Start grip button.
         */
        Object.defineProperty(this, "startGrip", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: this._makeButton()
        });
        /**
         * End grip button.
         */
        Object.defineProperty(this, "endGrip", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: this._makeButton()
        });
        Object.defineProperty(this, "_thumbBusy", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        Object.defineProperty(this, "_startDown", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        Object.defineProperty(this, "_endDown", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        Object.defineProperty(this, "_thumbDown", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        Object.defineProperty(this, "_gripDown", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
    }
    _addOrientationClass() {
        this._settings.themeTags = _util_Utils__WEBPACK_IMPORTED_MODULE_1__.mergeTags(this._settings.themeTags, ["scrollbar", this._settings.orientation]);
        if (!this._settings.background) {
            this._settings.background = _render_RoundedRectangle__WEBPACK_IMPORTED_MODULE_2__.RoundedRectangle.new(this._root, {
                themeTags: _util_Utils__WEBPACK_IMPORTED_MODULE_1__.mergeTags(this._settings.themeTags, ["main", "background"])
            });
        }
    }
    _makeButton() {
        return this.children.push(_Button__WEBPACK_IMPORTED_MODULE_3__.Button.new(this._root, {
            themeTags: ["resize", "button", this.get("orientation")], icon: _Graphics__WEBPACK_IMPORTED_MODULE_4__.Graphics.new(this._root, {
                themeTags: ["icon"]
            })
        }));
    }
    _makeThumb() {
        return this.children.push(_render_RoundedRectangle__WEBPACK_IMPORTED_MODULE_2__.RoundedRectangle.new(this._root, {
            themeTags: ["thumb", this.get("orientation")]
        }));
    }
    _handleAnimation(animation) {
        if (animation) {
            this._disposers.push(animation.events.on("stopped", () => {
                this.setPrivateRaw("isBusy", false);
                this._thumbBusy = false;
            }));
        }
    }
    _afterNew() {
        this._addOrientationClass();
        super._afterNew();
        const startGrip = this.startGrip;
        const endGrip = this.endGrip;
        const thumb = this.thumb;
        const background = this.get("background");
        if (background) {
            this._disposers.push(background.events.on("click", (event) => {
                this.setPrivateRaw("isBusy", true);
                const point = this._display.toLocal(event.point);
                const w = this.width();
                const h = this.height();
                const orientation = this.get("orientation");
                let newMiddle;
                if (orientation == "vertical") {
                    newMiddle = (point.y - thumb.height() / 2) / h;
                }
                else {
                    newMiddle = (point.x - thumb.width() / 2) / w;
                }
                let newCoordinate;
                let key;
                if (orientation == "vertical") {
                    newCoordinate = newMiddle * h;
                    key = "y";
                }
                else {
                    newCoordinate = newMiddle * w;
                    key = "x";
                }
                const duration = this.get("animationDuration", 0);
                if (duration > 0) {
                    this._thumbBusy = true;
                    this._handleAnimation(this.thumb.animate({ key: key, to: newCoordinate, duration: duration, easing: this.get("animationEasing") }));
                }
                else {
                    this.thumb.set(key, newCoordinate);
                    this._root.events.once("frameended", () => {
                        this.setPrivateRaw("isBusy", false);
                    });
                }
            }));
        }
        this._disposers.push(thumb.events.on("dblclick", (event) => {
            if (!_util_Utils__WEBPACK_IMPORTED_MODULE_1__.isLocalEvent(event.originalEvent, this)) {
                return;
            }
            const duration = this.get("animationDuration", 0);
            const easing = this.get("animationEasing");
            this.animate({ key: "start", to: 0, duration: duration, easing: easing });
            this.animate({ key: "end", to: 1, duration: duration, easing: easing });
        }));
        this._disposers.push(startGrip.events.on("pointerdown", () => {
            this.setPrivateRaw("isBusy", true);
            this._startDown = true;
            this._gripDown = "start";
        }));
        this._disposers.push(endGrip.events.on("pointerdown", () => {
            this.setPrivateRaw("isBusy", true);
            this._endDown = true;
            this._gripDown = "end";
        }));
        this._disposers.push(thumb.events.on("pointerdown", () => {
            this.setPrivateRaw("isBusy", true);
            this._thumbDown = true;
            this._gripDown = undefined;
        }));
        this._disposers.push(startGrip.events.on("globalpointerup", () => {
            if (this._startDown) {
                this.setPrivateRaw("isBusy", false);
            }
            this._startDown = false;
        }));
        this._disposers.push(endGrip.events.on("globalpointerup", () => {
            if (this._endDown) {
                this.setPrivateRaw("isBusy", false);
            }
            this._endDown = false;
        }));
        this._disposers.push(thumb.events.on("globalpointerup", () => {
            if (this._thumbDown) {
                this.setPrivateRaw("isBusy", false);
            }
            this._thumbDown = false;
        }));
        this._disposers.push(startGrip.on("x", () => {
            this._updateThumb();
        }));
        this._disposers.push(endGrip.on("x", () => {
            this._updateThumb();
        }));
        this._disposers.push(startGrip.on("y", () => {
            this._updateThumb();
        }));
        this._disposers.push(endGrip.on("y", () => {
            this._updateThumb();
        }));
        this._disposers.push(thumb.events.on("positionchanged", () => {
            this._updateGripsByThumb();
        }));
        if (this.get("orientation") == "vertical") {
            startGrip.set("x", 0);
            endGrip.set("x", 0);
            this._disposers.push(thumb.adapters.add("y", (value) => {
                return Math.max(Math.min(Number(value), this.height() - thumb.height()), 0);
            }));
            this._disposers.push(thumb.adapters.add("x", (_value) => {
                return this.width() / 2;
            }));
            this._disposers.push(startGrip.adapters.add("x", (_value) => {
                return this.width() / 2;
            }));
            this._disposers.push(endGrip.adapters.add("x", (_value) => {
                return this.width() / 2;
            }));
            this._disposers.push(startGrip.adapters.add("y", (value) => {
                return Math.max(Math.min(Number(value), this.height()), 0);
            }));
            this._disposers.push(endGrip.adapters.add("y", (value) => {
                return Math.max(Math.min(Number(value), this.height()), 0);
            }));
        }
        else {
            startGrip.set("y", 0);
            endGrip.set("y", 0);
            this._disposers.push(thumb.adapters.add("x", (value) => {
                return Math.max(Math.min(Number(value), this.width() - thumb.width()), 0);
            }));
            this._disposers.push(thumb.adapters.add("y", (_value) => {
                return this.height() / 2;
            }));
            this._disposers.push(startGrip.adapters.add("y", (_value) => {
                return this.height() / 2;
            }));
            this._disposers.push(endGrip.adapters.add("y", (_value) => {
                return this.height() / 2;
            }));
            this._disposers.push(startGrip.adapters.add("x", (value) => {
                return Math.max(Math.min(Number(value), this.width()), 0);
            }));
            this._disposers.push(endGrip.adapters.add("x", (value) => {
                return Math.max(Math.min(Number(value), this.width()), 0);
            }));
        }
    }
    _updateChildren() {
        super._updateChildren();
        if (this.isDirty("end") || this.isDirty("start") || this._sizeDirty) {
            this.updateGrips();
        }
    }
    _changed() {
        super._changed();
        if (this.isDirty("start") || this.isDirty("end")) {
            const eventType = "rangechanged";
            if (this.events.isEnabled(eventType)) {
                this.events.dispatch(eventType, { type: eventType, target: this, start: this.get("start", 0), end: this.get("end", 1), grip: this._gripDown });
            }
        }
    }
    /**
     * @ignore
     */
    updateGrips() {
        const startGrip = this.startGrip;
        const endGrip = this.endGrip;
        const orientation = this.get("orientation");
        const height = this.height();
        const width = this.width();
        if (orientation == "vertical") {
            startGrip.set("y", height * this.get("start", 0));
            endGrip.set("y", height * this.get("end", 1));
        }
        else {
            startGrip.set("x", width * this.get("start", 0));
            endGrip.set("x", width * this.get("end", 1));
        }
        const valueFunction = this.getPrivate("positionTextFunction");
        const from = Math.round(this.get("start", 0) * 100);
        const to = Math.round(this.get("end", 0) * 100);
        let fromValue;
        let toValue;
        if (valueFunction) {
            fromValue = valueFunction.call(this, this.get("start", 0));
            toValue = valueFunction.call(this, this.get("end", 0));
        }
        else {
            fromValue = from + "%";
            toValue = to + "%";
        }
        startGrip.set("ariaLabel", this._t("From %1", undefined, fromValue));
        startGrip.set("ariaValueNow", "" + from);
        startGrip.set("ariaValueText", from + "%");
        startGrip.set("ariaValueMin", "0");
        startGrip.set("ariaValueMax", "100");
        endGrip.set("ariaLabel", this._t("To %1", undefined, toValue));
        endGrip.set("ariaValueNow", "" + to);
        endGrip.set("ariaValueText", to + "%");
        endGrip.set("ariaValueMin", "0");
        endGrip.set("ariaValueMax", "100");
    }
    _updateThumb() {
        const thumb = this.thumb;
        const startGrip = this.startGrip;
        const endGrip = this.endGrip;
        const height = this.height();
        const width = this.width();
        let x0 = startGrip.x();
        let x1 = endGrip.x();
        let y0 = startGrip.y();
        let y1 = endGrip.y();
        let start = 0;
        let end = 1;
        if (this.get("orientation") == "vertical") {
            if (_util_Type__WEBPACK_IMPORTED_MODULE_5__.isNumber(y0) && _util_Type__WEBPACK_IMPORTED_MODULE_5__.isNumber(y1)) {
                if (!this._thumbBusy && !thumb.isDragging()) {
                    thumb.set("height", y1 - y0);
                    thumb.set("y", y0);
                }
                start = y0 / height;
                end = y1 / height;
            }
        }
        else {
            if (_util_Type__WEBPACK_IMPORTED_MODULE_5__.isNumber(x0) && _util_Type__WEBPACK_IMPORTED_MODULE_5__.isNumber(x1)) {
                if (!this._thumbBusy && !thumb.isDragging()) {
                    thumb.set("width", x1 - x0);
                    thumb.set("x", x0);
                }
                start = x0 / width;
                end = x1 / width;
            }
        }
        if (this.getPrivate("isBusy") && (this.get("start") != start || this.get("end") != end)) {
            this.set("start", start);
            this.set("end", end);
        }
        const valueFunction = this.getPrivate("positionTextFunction");
        const from = Math.round(this.get("start", 0) * 100);
        const to = Math.round(this.get("end", 0) * 100);
        let fromValue;
        let toValue;
        if (valueFunction) {
            fromValue = valueFunction.call(this, this.get("start", 0));
            toValue = valueFunction.call(this, this.get("end", 0));
        }
        else {
            fromValue = from + "%";
            toValue = to + "%";
        }
        thumb.set("ariaLabel", this._t("From %1 to %2", undefined, fromValue, toValue));
        thumb.set("ariaValueNow", "" + from);
        thumb.set("ariaValueText", from + "%");
    }
    _updateGripsByThumb() {
        const thumb = this.thumb;
        const startGrip = this.startGrip;
        const endGrip = this.endGrip;
        if (this.get("orientation") == "vertical") {
            const thumbSize = thumb.height();
            startGrip.set("y", thumb.y());
            endGrip.set("y", thumb.y() + thumbSize);
        }
        else {
            const thumbSize = thumb.width();
            startGrip.set("x", thumb.x());
            endGrip.set("x", thumb.x() + thumbSize);
        }
    }
}
Object.defineProperty(Scrollbar, "className", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: "Scrollbar"
});
Object.defineProperty(Scrollbar, "classNames", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: _Container__WEBPACK_IMPORTED_MODULE_0__.Container.classNames.concat([Scrollbar.className])
});
//# sourceMappingURL=Scrollbar.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/core/render/SerialChart.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/core/render/SerialChart.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SerialChart: () => (/* binding */ SerialChart)
/* harmony export */ });
/* harmony import */ var _Chart__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Chart */ "./node_modules/@amcharts/amcharts5/.internal/core/render/Chart.js");
/* harmony import */ var _core_render_Container__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../core/render/Container */ "./node_modules/@amcharts/amcharts5/.internal/core/render/Container.js");
/* harmony import */ var _core_util_List__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../core/util/List */ "./node_modules/@amcharts/amcharts5/.internal/core/util/List.js");
/* harmony import */ var _core_util_Percent__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../core/util/Percent */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Percent.js");
/* harmony import */ var _core_util_Array__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../core/util/Array */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Array.js");





/**
 * A base class for all series-based charts.
 */
class SerialChart extends _Chart__WEBPACK_IMPORTED_MODULE_0__.Chart {
    constructor() {
        super(...arguments);
        /**
         * A [[Container]] where chart will store all series.
         *
         * @default Container.new()
         */
        Object.defineProperty(this, "seriesContainer", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: _core_render_Container__WEBPACK_IMPORTED_MODULE_1__.Container.new(this._root, { width: _core_util_Percent__WEBPACK_IMPORTED_MODULE_2__.p100, height: _core_util_Percent__WEBPACK_IMPORTED_MODULE_2__.p100, isMeasured: false })
        });
        /**
         * A list of chart's series.
         */
        Object.defineProperty(this, "series", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new _core_util_List__WEBPACK_IMPORTED_MODULE_3__.ListAutoDispose()
        });
    }
    _afterNew() {
        super._afterNew();
        this._disposers.push(this.series);
        const children = this.seriesContainer.children;
        this._disposers.push(this.series.events.onAll((change) => {
            if (change.type === "clear") {
                _core_util_Array__WEBPACK_IMPORTED_MODULE_4__.each(change.oldValues, (series) => {
                    this._removeSeries(series);
                });
                const colors = this.get("colors");
                if (colors) {
                    colors.reset();
                }
            }
            else if (change.type === "push") {
                children.moveValue(change.newValue);
                this._processSeries(change.newValue);
            }
            else if (change.type === "setIndex") {
                children.setIndex(change.index, change.newValue);
                this._processSeries(change.newValue);
            }
            else if (change.type === "insertIndex") {
                children.insertIndex(change.index, change.newValue);
                this._processSeries(change.newValue);
            }
            else if (change.type === "removeIndex") {
                this._removeSeries(change.oldValue);
            }
            else if (change.type === "moveIndex") {
                children.moveValue(change.value, change.newIndex);
                this._processSeries(change.value);
            }
            else {
                throw new Error("Unknown IListEvent type");
            }
        }));
    }
    _processSeries(series) {
        series.chart = this;
        series._placeBulletsContainer(this);
    }
    _removeSeries(series) {
        if (!series.isDisposed()) {
            this.seriesContainer.children.removeValue(series);
            series._removeBulletsContainer();
        }
    }
}
Object.defineProperty(SerialChart, "className", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: "SerialChart"
});
Object.defineProperty(SerialChart, "classNames", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: _Chart__WEBPACK_IMPORTED_MODULE_0__.Chart.classNames.concat([SerialChart.className])
});
//# sourceMappingURL=SerialChart.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/core/render/Series.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/core/render/Series.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Series: () => (/* binding */ Series)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.mjs");
/* harmony import */ var _core_render_Component__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/render/Component */ "./node_modules/@amcharts/amcharts5/.internal/core/render/Component.js");
/* harmony import */ var _core_util_List__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../core/util/List */ "./node_modules/@amcharts/amcharts5/.internal/core/util/List.js");
/* harmony import */ var _core_util_Color__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../core/util/Color */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Color.js");
/* harmony import */ var _core_util_Animation__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../core/util/Animation */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Animation.js");
/* harmony import */ var _core_util_Percent__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../core/util/Percent */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Percent.js");
/* harmony import */ var _core_util_Array__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../core/util/Array */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Array.js");
/* harmony import */ var _core_util_Type__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../core/util/Type */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Type.js");
/* harmony import */ var _core_util_Time__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../core/util/Time */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Time.js");
/* harmony import */ var _core_render_Container__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../core/render/Container */ "./node_modules/@amcharts/amcharts5/.internal/core/render/Container.js");
/* harmony import */ var _core_render_Label__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../core/render/Label */ "./node_modules/@amcharts/amcharts5/.internal/core/render/Label.js");












/**
 * A base class for all series.
 */
class Series extends _core_render_Component__WEBPACK_IMPORTED_MODULE_0__.Component {
    constructor() {
        super(...arguments);
        Object.defineProperty(this, "_aggregatesCalculated", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        Object.defineProperty(this, "_selectionAggregatesCalculated", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        Object.defineProperty(this, "_dataProcessed", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        Object.defineProperty(this, "_psi", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_pei", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /**
         * A chart series belongs to.
         */
        Object.defineProperty(this, "chart", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /**
         * List of bullets to use for the series.
         *
         * @see {@link https://www.amcharts.com/docs/v5/concepts/common-elements/bullets/} for more info
         */
        Object.defineProperty(this, "bullets", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new _core_util_List__WEBPACK_IMPORTED_MODULE_1__.List()
        });
        /**
         * A [[Container]] series' bullets are stored in.
         *
         * @default Container.new()
         */
        Object.defineProperty(this, "bulletsContainer", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: _core_render_Container__WEBPACK_IMPORTED_MODULE_2__.Container.new(this._root, { width: _core_util_Percent__WEBPACK_IMPORTED_MODULE_3__.p100, height: _core_util_Percent__WEBPACK_IMPORTED_MODULE_3__.p100, position: "absolute" })
        });
    }
    _afterNew() {
        this.valueFields.push("value", "customValue");
        super._afterNew();
        this.setPrivate("customData", {});
        this._disposers.push(this.bullets.events.onAll((change) => {
            if (change.type === "clear") {
                this._handleBullets(this.dataItems);
            }
            else if (change.type === "push") {
                this._handleBullets(this.dataItems);
            }
            else if (change.type === "setIndex") {
                this._handleBullets(this.dataItems);
            }
            else if (change.type === "insertIndex") {
                this._handleBullets(this.dataItems);
            }
            else if (change.type === "removeIndex") {
                this._handleBullets(this.dataItems);
            }
            else if (change.type === "moveIndex") {
                this._handleBullets(this.dataItems);
            }
            else {
                throw new Error("Unknown IListEvent type");
            }
        }));
    }
    _dispose() {
        this.bulletsContainer.dispose(); // can be in a different parent
        super._dispose();
    }
    startIndex() {
        let len = this.dataItems.length;
        return Math.min(this.getPrivate("startIndex", 0), len);
    }
    endIndex() {
        let len = this.dataItems.length;
        return Math.min(this.getPrivate("endIndex", len), len);
    }
    _handleBullets(dataItems) {
        _core_util_Array__WEBPACK_IMPORTED_MODULE_4__.each(dataItems, (dataItem) => {
            const bullets = dataItem.bullets;
            if (bullets) {
                _core_util_Array__WEBPACK_IMPORTED_MODULE_4__.each(bullets, (bullet) => {
                    bullet.dispose();
                });
                dataItem.bullets = undefined;
            }
        });
        this.markDirtyValues();
    }
    /**
     * Looks up and returns a data item by its ID.
     *
     * @param   id  ID
     * @return      Data item
     */
    getDataItemById(id) {
        return _core_util_Array__WEBPACK_IMPORTED_MODULE_4__.find(this.dataItems, (dataItem) => {
            return dataItem.get("id") == id;
        });
    }
    _makeBullets(dataItem) {
        if (this._shouldMakeBullet(dataItem)) {
            dataItem.bullets = [];
            this.bullets.each((bulletFunction) => {
                this._makeBullet(dataItem, bulletFunction);
            });
        }
    }
    _shouldMakeBullet(_dataItem) {
        return true;
    }
    _makeBullet(dataItem, bulletFunction, index) {
        const bullet = bulletFunction(this._root, this, dataItem);
        if (bullet) {
            bullet._index = index;
            this._makeBulletReal(dataItem, bullet);
        }
        return bullet;
    }
    _makeBulletReal(dataItem, bullet) {
        let sprite = bullet.get("sprite");
        if (sprite) {
            sprite._setDataItem(dataItem);
            sprite.setRaw("position", "absolute");
            this.bulletsContainer.children.push(sprite);
        }
        bullet.series = this;
        dataItem.bullets.push(bullet);
    }
    /**
     * Adds bullet directly to a data item.
     *
     * Please note: method accepts [[Bullet]] instance as a paramter, not a
     * reference to a function.
     *
     * You should add Bullet instance, not a method like you do it on series.
     *
     * @see {@link https://www.amcharts.com/docs/v5/concepts/common-elements/bullets/#Adding_directly_to_data_item} for more info
     * @since 5.6.0
     *
     * @param  dataItem  Target data item
     * @param  bullet    Bullet instance
     */
    addBullet(dataItem, bullet) {
        if (!dataItem.bullets) {
            dataItem.bullets = [];
        }
        if (bullet) {
            this._makeBulletReal(dataItem, bullet);
        }
    }
    _clearDirty() {
        super._clearDirty();
        this._aggregatesCalculated = false;
        this._selectionAggregatesCalculated = false;
    }
    _prepareChildren() {
        super._prepareChildren();
        let startIndex = this.startIndex();
        let endIndex = this.endIndex();
        if (this.isDirty("name")) {
            this.updateLegendValue();
        }
        if (this.isDirty("heatRules")) {
            this._valuesDirty = true;
        }
        if (this.isPrivateDirty("baseValueSeries")) {
            const baseValueSeries = this.getPrivate("baseValueSeries");
            if (baseValueSeries) {
                this._disposers.push(baseValueSeries.onPrivate("startIndex", () => {
                    this.markDirtyValues();
                }));
            }
        }
        const calculateAggregates = this.get("calculateAggregates");
        if (calculateAggregates) {
            if (this._valuesDirty && !this._dataProcessed) {
                if (!this._aggregatesCalculated) {
                    this._calculateAggregates(0, this.dataItems.length);
                    this._aggregatesCalculated = true;
                }
            }
            if ((this._psi != startIndex || this._pei != endIndex) && !this._selectionAggregatesCalculated) {
                if (startIndex === 0 && endIndex === this.dataItems.length && this._aggregatesCalculated) {
                    // void
                }
                else {
                    this._calculateAggregates(startIndex, endIndex);
                }
                this._selectionAggregatesCalculated = true;
            }
        }
        if (this.isDirty("tooltip")) {
            let tooltip = this.get("tooltip");
            if (tooltip) {
                tooltip.hide(0);
                tooltip.set("tooltipTarget", this);
            }
        }
        if (this.isDirty("fill") || this.isDirty("stroke")) {
            let markerRectangle;
            const legendDataItem = this.get("legendDataItem");
            if (legendDataItem) {
                markerRectangle = legendDataItem.get("markerRectangle");
                if (markerRectangle) {
                    if (this.isVisible()) {
                        if (this.isDirty("stroke")) {
                            let stroke = this.get("stroke");
                            markerRectangle.set("stroke", stroke);
                        }
                        if (this.isDirty("fill")) {
                            let fill = this.get("fill");
                            markerRectangle.set("fill", fill);
                        }
                    }
                }
            }
            this.updateLegendMarker(undefined);
        }
        if (this.bullets.length > 0) {
            let startIndex = this.startIndex();
            let endIndex = this.endIndex();
            if (endIndex < this.dataItems.length) {
                endIndex++;
            }
            for (let i = startIndex; i < endIndex; i++) {
                let dataItem = this.dataItems[i];
                if (!dataItem.bullets) {
                    this._makeBullets(dataItem);
                }
            }
        }
    }
    _calculateAggregates(startIndex, endIndex) {
        let fields = this._valueFields;
        if (!fields) {
            throw new Error("No value fields are set for the series.");
        }
        const sum = {};
        const absSum = {};
        const count = {};
        const low = {};
        const high = {};
        const open = {};
        const close = {};
        const average = {};
        const previous = {};
        _core_util_Array__WEBPACK_IMPORTED_MODULE_4__.each(fields, (key) => {
            sum[key] = 0;
            absSum[key] = 0;
            count[key] = 0;
        });
        _core_util_Array__WEBPACK_IMPORTED_MODULE_4__.each(fields, (key) => {
            let change = key + "Change";
            let changePercent = key + "ChangePercent";
            let changePrevious = key + "ChangePrevious";
            let changePreviousPercent = key + "ChangePreviousPercent";
            let changeSelection = key + "ChangeSelection";
            let changeSelectionPercent = key + "ChangeSelectionPercent";
            let openKey = "valueY";
            if (key == "valueX" || key == "openValueX" || key == "lowValueX" || key == "highValueX") {
                openKey = "valueX";
            }
            const baseValueSeries = this.getPrivate("baseValueSeries");
            for (let i = startIndex; i < endIndex; i++) {
                const dataItem = this.dataItems[i];
                let value = dataItem.get(key);
                if (value != null) {
                    count[key]++;
                    sum[key] += value;
                    absSum[key] += Math.abs(value);
                    average[key] = sum[key] / count[key];
                    if (low[key] > value || low[key] == null) {
                        low[key] = value;
                    }
                    if (high[key] < value || high[key] == null) {
                        high[key] = value;
                    }
                    close[key] = value;
                    if (open[key] == null) {
                        open[key] = value;
                        previous[key] = value;
                        if (baseValueSeries) {
                            open[openKey] = baseValueSeries._getBase(openKey);
                        }
                    }
                    if (startIndex === 0) {
                        dataItem.setRaw((change), value - open[openKey]);
                        dataItem.setRaw((changePercent), (value - open[openKey]) / open[openKey] * 100);
                    }
                    dataItem.setRaw((changePrevious), value - previous[openKey]);
                    dataItem.setRaw((changePreviousPercent), (value - previous[openKey]) / previous[openKey] * 100);
                    dataItem.setRaw((changeSelection), value - open[openKey]);
                    dataItem.setRaw((changeSelectionPercent), (value - open[openKey]) / open[openKey] * 100);
                    previous[key] = value;
                }
            }
        });
        _core_util_Array__WEBPACK_IMPORTED_MODULE_4__.each(fields, (key) => {
            this.setPrivate((key + "AverageSelection"), average[key]);
            this.setPrivate((key + "CountSelection"), count[key]);
            this.setPrivate((key + "SumSelection"), sum[key]);
            this.setPrivate((key + "AbsoluteSumSelection"), absSum[key]);
            this.setPrivate((key + "LowSelection"), low[key]);
            this.setPrivate((key + "HighSelection"), high[key]);
            this.setPrivate((key + "OpenSelection"), open[key]);
            this.setPrivate((key + "CloseSelection"), close[key]);
        });
        if (startIndex === 0 && endIndex === this.dataItems.length) {
            _core_util_Array__WEBPACK_IMPORTED_MODULE_4__.each(fields, (key) => {
                this.setPrivate((key + "Average"), average[key]);
                this.setPrivate((key + "Count"), count[key]);
                this.setPrivate((key + "Sum"), sum[key]);
                this.setPrivate((key + "AbsoluteSum"), absSum[key]);
                this.setPrivate((key + "Low"), low[key]);
                this.setPrivate((key + "High"), high[key]);
                this.setPrivate((key + "Open"), open[key]);
                this.setPrivate((key + "Close"), close[key]);
            });
        }
    }
    _updateChildren() {
        super._updateChildren();
        this._psi = this.startIndex();
        this._pei = this.endIndex();
        if (this.isDirty("visible")) {
            this.bulletsContainer.set("visible", this.get("visible"));
        }
        // Apply heat rules
        const rules = this.get("heatRules");
        if (this._valuesDirty && rules && rules.length > 0) {
            _core_util_Array__WEBPACK_IMPORTED_MODULE_4__.each(rules, (rule) => {
                const minValue = rule.minValue || this.getPrivate((rule.dataField + "Low")) || 0;
                const maxValue = rule.maxValue || this.getPrivate((rule.dataField + "High")) || 0;
                _core_util_Array__WEBPACK_IMPORTED_MODULE_4__.each(rule.target._entities, (target) => {
                    const value = target.dataItem.get(rule.dataField);
                    if (!_core_util_Type__WEBPACK_IMPORTED_MODULE_5__.isNumber(value)) {
                        if (rule.neutral) {
                            target.set(rule.key, rule.neutral);
                        }
                        return;
                    }
                    if (rule.customFunction) {
                        rule.customFunction.call(this, target, minValue, maxValue, value);
                    }
                    else {
                        let percent;
                        if (rule.logarithmic) {
                            percent = (Math.log(value) * Math.LOG10E - Math.log(minValue) * Math.LOG10E) / ((Math.log(maxValue) * Math.LOG10E - Math.log(minValue) * Math.LOG10E));
                        }
                        else {
                            percent = (value - minValue) / (maxValue - minValue);
                        }
                        if (_core_util_Type__WEBPACK_IMPORTED_MODULE_5__.isNumber(value) && (!_core_util_Type__WEBPACK_IMPORTED_MODULE_5__.isNumber(percent) || Math.abs(percent) == Infinity)) {
                            percent = 0.5;
                        }
                        // fixes problems if all values are the same
                        let propertyValue;
                        if (_core_util_Type__WEBPACK_IMPORTED_MODULE_5__.isNumber(rule.min)) {
                            propertyValue = rule.min + (rule.max - rule.min) * percent;
                        }
                        else if (rule.min instanceof _core_util_Color__WEBPACK_IMPORTED_MODULE_6__.Color) {
                            propertyValue = _core_util_Color__WEBPACK_IMPORTED_MODULE_6__.Color.interpolate(percent, rule.min, rule.max);
                        }
                        else if (rule.min instanceof _core_util_Percent__WEBPACK_IMPORTED_MODULE_3__.Percent) {
                            propertyValue = (0,_core_util_Animation__WEBPACK_IMPORTED_MODULE_7__.percentInterpolate)(percent, rule.min, rule.max);
                        }
                        target.set(rule.key, propertyValue);
                    }
                });
            });
        }
        if (this.get("visible")) {
            //if (this.bullets.length > 0) {
            let count = this.dataItems.length;
            let startIndex = this.startIndex();
            let endIndex = this.endIndex();
            if (endIndex < count) {
                endIndex++;
            }
            if (startIndex > 0) {
                startIndex--;
            }
            for (let i = 0; i < startIndex; i++) {
                this._hideBullets(this.dataItems[i]);
            }
            for (let i = startIndex; i < endIndex; i++) {
                this._positionBullets(this.dataItems[i]);
            }
            for (let i = endIndex; i < count; i++) {
                this._hideBullets(this.dataItems[i]);
            }
            //}
        }
    }
    _positionBullets(dataItem) {
        if (dataItem.bullets) {
            _core_util_Array__WEBPACK_IMPORTED_MODULE_4__.each(dataItem.bullets, (bullet) => {
                this._positionBullet(bullet);
                const sprite = bullet.get("sprite");
                if (bullet.get("dynamic")) {
                    if (sprite) {
                        sprite._markDirtyKey("fill");
                        sprite.markDirtySize();
                    }
                    if (sprite instanceof _core_render_Container__WEBPACK_IMPORTED_MODULE_2__.Container) {
                        sprite.walkChildren((child) => {
                            child._markDirtyKey("fill");
                            child.markDirtySize();
                            if (child instanceof _core_render_Label__WEBPACK_IMPORTED_MODULE_8__.Label) {
                                child.text.markDirtyText();
                            }
                        });
                    }
                }
                if (sprite instanceof _core_render_Label__WEBPACK_IMPORTED_MODULE_8__.Label && sprite.get("populateText")) {
                    sprite.text.markDirtyText();
                }
            });
        }
    }
    _hideBullets(dataItem) {
        if (dataItem.bullets) {
            _core_util_Array__WEBPACK_IMPORTED_MODULE_4__.each(dataItem.bullets, (bullet) => {
                let sprite = bullet.get("sprite");
                if (sprite) {
                    sprite.setPrivate("visible", false);
                }
            });
        }
    }
    _positionBullet(_bullet) {
    }
    _placeBulletsContainer(chart) {
        chart.bulletsContainer.children.moveValue(this.bulletsContainer);
    }
    _removeBulletsContainer() {
        const bulletsContainer = this.bulletsContainer;
        if (bulletsContainer.parent) {
            bulletsContainer.parent.children.removeValue(bulletsContainer);
        }
    }
    /**
     * @ignore
     */
    disposeDataItem(dataItem) {
        //super.disposeDataItem(dataItem); // does nothing
        const bullets = dataItem.bullets;
        if (bullets) {
            _core_util_Array__WEBPACK_IMPORTED_MODULE_4__.each(bullets, (bullet) => {
                bullet.dispose();
            });
        }
    }
    _getItemReaderLabel() {
        return "";
    }
    /**
     * Shows series's data item.
     *
     * @param   dataItem  Data item
     * @param   duration  Animation duration in milliseconds
     * @return            Promise
     */
    showDataItem(dataItem, duration) {
        const _super = Object.create(null, {
            showDataItem: { get: () => super.showDataItem }
        });
        return (0,tslib__WEBPACK_IMPORTED_MODULE_9__.__awaiter)(this, void 0, void 0, function* () {
            const promises = [_super.showDataItem.call(this, dataItem, duration)];
            const bullets = dataItem.bullets;
            if (bullets) {
                _core_util_Array__WEBPACK_IMPORTED_MODULE_4__.each(bullets, (bullet) => {
                    const sprite = bullet.get("sprite");
                    if (sprite) {
                        promises.push(sprite.show(duration));
                    }
                });
            }
            yield Promise.all(promises);
        });
    }
    /**
     * Hides series's data item.
     *
     * @param   dataItem  Data item
     * @param   duration  Animation duration in milliseconds
     * @return            Promise
     */
    hideDataItem(dataItem, duration) {
        const _super = Object.create(null, {
            hideDataItem: { get: () => super.hideDataItem }
        });
        return (0,tslib__WEBPACK_IMPORTED_MODULE_9__.__awaiter)(this, void 0, void 0, function* () {
            const promises = [_super.hideDataItem.call(this, dataItem, duration)];
            const bullets = dataItem.bullets;
            if (bullets) {
                _core_util_Array__WEBPACK_IMPORTED_MODULE_4__.each(bullets, (bullet) => {
                    const sprite = bullet.get("sprite");
                    if (sprite) {
                        promises.push(sprite.hide(duration));
                    }
                });
            }
            yield Promise.all(promises);
        });
    }
    _sequencedShowHide(show, duration) {
        return (0,tslib__WEBPACK_IMPORTED_MODULE_9__.__awaiter)(this, void 0, void 0, function* () {
            if (this.get("sequencedInterpolation")) {
                if (!_core_util_Type__WEBPACK_IMPORTED_MODULE_5__.isNumber(duration)) {
                    duration = this.get("interpolationDuration", 0);
                }
                if (duration > 0) {
                    const startIndex = this.startIndex();
                    const endIndex = this.endIndex();
                    yield Promise.all(_core_util_Array__WEBPACK_IMPORTED_MODULE_4__.map(this.dataItems, (dataItem, i) => (0,tslib__WEBPACK_IMPORTED_MODULE_9__.__awaiter)(this, void 0, void 0, function* () {
                        let realDuration = duration || 0;
                        if (i < startIndex - 10 || i > endIndex + 10) {
                            realDuration = 0;
                        }
                        //let delay = this.get("sequencedDelay", 0) * i + realDuration * (i - startIndex) / (endIndex - startIndex);
                        let delay = this.get("sequencedDelay", 0) + realDuration / (endIndex - startIndex);
                        yield _core_util_Time__WEBPACK_IMPORTED_MODULE_10__.sleep(delay * (i - startIndex));
                        if (show) {
                            yield this.showDataItem(dataItem, realDuration);
                        }
                        else {
                            yield this.hideDataItem(dataItem, realDuration);
                        }
                    })));
                }
                else {
                    yield Promise.all(_core_util_Array__WEBPACK_IMPORTED_MODULE_4__.map(this.dataItems, (dataItem) => {
                        if (show) {
                            return this.showDataItem(dataItem, 0);
                        }
                        else {
                            return this.hideDataItem(dataItem, 0);
                        }
                    }));
                }
            }
        });
    }
    /**
     * @ignore
     */
    updateLegendValue(dataItem) {
        if (dataItem) {
            const legendDataItem = dataItem.get("legendDataItem");
            if (legendDataItem) {
                const valueLabel = legendDataItem.get("valueLabel");
                if (valueLabel) {
                    const text = valueLabel.text;
                    let txt = "";
                    valueLabel._setDataItem(dataItem);
                    txt = this.get("legendValueText", text.get("text", ""));
                    valueLabel.set("text", txt);
                    text.markDirtyText();
                }
                const label = legendDataItem.get("label");
                if (label) {
                    const text = label.text;
                    let txt = "";
                    label._setDataItem(dataItem);
                    txt = this.get("legendLabelText", text.get("text", ""));
                    label.set("text", txt);
                    text.markDirtyText();
                }
            }
        }
    }
    /**
     * @ignore
     */
    updateLegendMarker(_dataItem) {
    }
    _onHide() {
        super._onHide();
        const tooltip = this.getTooltip();
        if (tooltip) {
            tooltip.hide();
        }
    }
    /**
     * @ignore
     */
    hoverDataItem(_dataItem) { }
    /**
     * @ignore
     */
    unhoverDataItem(_dataItem) { }
    /**
     * @ignore
     */
    _getBase(key) {
        const dataItem = this.dataItems[this.startIndex()];
        if (dataItem) {
            return dataItem.get(key);
        }
        return 0;
    }
}
Object.defineProperty(Series, "className", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: "Series"
});
Object.defineProperty(Series, "classNames", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: _core_render_Component__WEBPACK_IMPORTED_MODULE_0__.Component.classNames.concat([Series.className])
});
//# sourceMappingURL=Series.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/core/render/Slice.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/core/render/Slice.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Slice: () => (/* binding */ Slice)
/* harmony export */ });
/* harmony import */ var _Graphics__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Graphics */ "./node_modules/@amcharts/amcharts5/.internal/core/render/Graphics.js");
/* harmony import */ var _util_Type__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/Type */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Type.js");
/* harmony import */ var _util_Percent__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util/Percent */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Percent.js");
/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-shape */ "./node_modules/d3-shape/src/arc.js");
/* harmony import */ var _util_Math__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../util/Math */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Math.js");





/**
 * Draws a slice shape.
 *
 * @see {@link https://www.amcharts.com/docs/v5/concepts/common-elements/graphics/} for more info
 */
class Slice extends _Graphics__WEBPACK_IMPORTED_MODULE_0__.Graphics {
    constructor() {
        super(...arguments);
        /**
         * @ignore
         */
        Object.defineProperty(this, "ix", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        /**
         * @ignore
         */
        Object.defineProperty(this, "iy", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        Object.defineProperty(this, "_generator", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: (0,d3_shape__WEBPACK_IMPORTED_MODULE_1__["default"])()
        });
    }
    _getTooltipPoint() {
        let tooltipX = this.get("tooltipX");
        let tooltipY = this.get("tooltipY");
        let x = 0;
        let y = 0;
        if (_util_Type__WEBPACK_IMPORTED_MODULE_2__.isNumber(tooltipX)) {
            x = tooltipX;
        }
        if (_util_Type__WEBPACK_IMPORTED_MODULE_2__.isNumber(tooltipY)) {
            y = tooltipY;
        }
        let radius = this.get("radius", 0);
        let innerRadius = this.get("innerRadius", 0);
        let dRadius = this.get("dRadius", 0);
        let dInnerRadius = this.get("dInnerRadius", 0);
        radius += dRadius;
        innerRadius += dInnerRadius;
        if (innerRadius < 0) {
            innerRadius = radius + innerRadius;
        }
        if (tooltipX instanceof _util_Percent__WEBPACK_IMPORTED_MODULE_3__.Percent) {
            x = this.ix * (innerRadius + (radius - innerRadius) * tooltipX.value);
        }
        if (tooltipY instanceof _util_Percent__WEBPACK_IMPORTED_MODULE_3__.Percent) {
            y = this.iy * (innerRadius + (radius - innerRadius) * tooltipY.value);
        }
        if (this.get("arc") >= 360 && innerRadius == 0) {
            x = 0;
            y = 0;
        }
        return { x, y };
    }
    _beforeChanged() {
        super._beforeChanged();
        if (this.isDirty("radius") || this.isDirty("arc") || this.isDirty("innerRadius") || this.isDirty("startAngle") || this.isDirty("dRadius") || this.isDirty("dInnerRadius") || this.isDirty("cornerRadius") || this.isDirty("shiftRadius")) {
            this._clear = true;
        }
    }
    _changed() {
        super._changed();
        if (this._clear) {
            let startAngle = this.get("startAngle", 0);
            let arc = this.get("arc", 0);
            const generator = this._generator;
            if (arc < 0) {
                startAngle = startAngle + arc;
                arc = arc * -1;
            }
            if (arc > 0.1) { // this fixes bug with full circle when arc is very small
                generator.cornerRadius(this.get("cornerRadius", 0));
            }
            generator.context(this._display);
            let radius = this.get("radius", 0);
            let innerRadius = this.get("innerRadius", 0);
            let dRadius = this.get("dRadius", 0);
            let dInnerRadius = this.get("dInnerRadius", 0);
            radius += dRadius;
            innerRadius += dInnerRadius;
            if (innerRadius < 0) {
                innerRadius = radius + innerRadius;
            }
            generator({ innerRadius: innerRadius, outerRadius: radius, startAngle: (startAngle + 90) * _util_Math__WEBPACK_IMPORTED_MODULE_4__.RADIANS, endAngle: (startAngle + arc + 90) * _util_Math__WEBPACK_IMPORTED_MODULE_4__.RADIANS });
            let middleAngle = startAngle + arc / 2;
            this.ix = _util_Math__WEBPACK_IMPORTED_MODULE_4__.cos(middleAngle);
            this.iy = _util_Math__WEBPACK_IMPORTED_MODULE_4__.sin(middleAngle);
            const shiftRadius = this.get("shiftRadius", 0);
            this.setRaw("dx", this.ix * shiftRadius);
            this.setRaw("dy", this.iy * shiftRadius);
            this.markDirtyPosition();
        }
    }
}
Object.defineProperty(Slice, "className", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: "Slice"
});
Object.defineProperty(Slice, "classNames", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: _Graphics__WEBPACK_IMPORTED_MODULE_0__.Graphics.classNames.concat([Slice.className])
});
//# sourceMappingURL=Slice.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/core/render/Sprite.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/core/render/Sprite.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Sprite: () => (/* binding */ Sprite)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.mjs");
/* harmony import */ var _util_Entity__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util/Entity */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Entity.js");
/* harmony import */ var _util_Template__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../util/Template */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Template.js");
/* harmony import */ var _util_Percent__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../util/Percent */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Percent.js");
/* harmony import */ var _util_EventDispatcher__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/EventDispatcher */ "./node_modules/@amcharts/amcharts5/.internal/core/util/EventDispatcher.js");
/* harmony import */ var _util_Disposer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/Disposer */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Disposer.js");
/* harmony import */ var _util_Animation__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../util/Animation */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Animation.js");
/* harmony import */ var _util_Utils__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../util/Utils */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Utils.js");
/* harmony import */ var _util_Array__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../util/Array */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Array.js");
/* harmony import */ var _util_Type__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../util/Type */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Type.js");
/* harmony import */ var _util_Object__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../util/Object */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Object.js");
/* harmony import */ var _util_Math__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/Math */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Math.js");












//import { populateString } from "../util/PopulateString";
/**
 * An [[EventDispatcher]] for [[Sprite]].
 *
 * @see {@link https://www.amcharts.com/docs/v5/concepts/events/} for more info
 */
class SpriteEventDispatcher extends _util_EventDispatcher__WEBPACK_IMPORTED_MODULE_0__.EventDispatcher {
    constructor(sprite) {
        super();
        Object.defineProperty(this, "_sprite", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_rendererDisposers", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {}
        });
        Object.defineProperty(this, "_dispatchParents", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: true
        });
        this._sprite = sprite;
    }
    _makePointerEvent(key, event) {
        return {
            type: key,
            originalEvent: event.event,
            point: event.point,
            simulated: event.simulated,
            native: event.native,
            target: this._sprite
        };
    }
    _onRenderer(key, dispatch) {
        // TODO: is this OK? it'd be good not to require to set this on each individual element
        this._sprite.set("interactive", true);
        this._sprite._display.interactive = true;
        let events = this._rendererDisposers[key];
        if (events === undefined) {
            const disposer = this._sprite._display.on(key, (e) => {
                dispatch.call(this, e);
            });
            events = this._rendererDisposers[key] = new _util_Disposer__WEBPACK_IMPORTED_MODULE_1__.CounterDisposer(() => {
                delete this._rendererDisposers[key];
                disposer.dispose();
            });
        }
        return events.increment();
    }
    _on(once, type, callback, context, shouldClone, dispatch) {
        const info = super._on(once, type, callback, context, shouldClone, dispatch);
        const rendererEvent = SpriteEventDispatcher.RENDERER_EVENTS[type];
        if (rendererEvent !== undefined) {
            info.disposer = new _util_Disposer__WEBPACK_IMPORTED_MODULE_1__.MultiDisposer([
                info.disposer,
                this._onRenderer(type, rendererEvent),
            ]);
        }
        return info;
    }
    /**
     * Will stop any bubbling up of the event to element's parents.
     *
     * Should be called in an event handler, e.g.:
     *
     * ```TypeScript
     * element.events.on("pointerdown", function(ev) {
     *   // Do something here and prevent from "pointerdown" bubbling up
     *   // ...
     *   ev.target.events.stopParentDispatch();
     * });
     * ```
     * ```JavaScript
     * element.events.on("pointerdown", function(ev) {
     *   // Do something here and prevent from "pointerdown" bubbling up
     *   // ...
     *   ev.target.events.stopParentDispatch();
     * });
     * ```
     */
    stopParentDispatch() {
        this._dispatchParents = false;
    }
    /**
     * @ignore
     */
    dispatchParents(type, event) {
        const old = this._dispatchParents;
        this._dispatchParents = true;
        try {
            this.dispatch(type, event);
            if (this._dispatchParents && this._sprite.parent) {
                this._sprite.parent.events.dispatchParents(type, event);
            }
        }
        finally {
            this._dispatchParents = old;
        }
    }
}
Object.defineProperty(SpriteEventDispatcher, "RENDERER_EVENTS", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: {
        "click": function (event) {
            if (this.isEnabled("click") && !this._sprite.isDragging() && this._sprite._hasDown() && !this._sprite._hasMoved(this._makePointerEvent("click", event))) {
                this.dispatch("click", this._makePointerEvent("click", event));
            }
        },
        "rightclick": function (event) {
            if (this.isEnabled("rightclick")) {
                this.dispatch("rightclick", this._makePointerEvent("rightclick", event));
            }
        },
        "middleclick": function (event) {
            if (this.isEnabled("middleclick")) {
                this.dispatch("middleclick", this._makePointerEvent("middleclick", event));
            }
        },
        "dblclick": function (event) {
            this.dispatchParents("dblclick", this._makePointerEvent("dblclick", event));
        },
        "pointerover": function (event) {
            const sprite = this._sprite;
            let dispatch = true;
            if (sprite.getPrivate("trustBounds")) {
                sprite._getBounds();
                const bounds = sprite.globalBounds();
                if (!_util_Math__WEBPACK_IMPORTED_MODULE_2__.inBounds(event.point, bounds)) {
                    dispatch = false;
                    sprite._root._renderer.removeHovering(sprite._display);
                }
            }
            if (dispatch && this.isEnabled("pointerover")) {
                this.dispatch("pointerover", this._makePointerEvent("pointerover", event));
            }
        },
        "pointerout": function (event) {
            if (this.isEnabled("pointerout")) {
                this.dispatch("pointerout", this._makePointerEvent("pointerout", event));
            }
        },
        "pointerdown": function (event) {
            this.dispatchParents("pointerdown", this._makePointerEvent("pointerdown", event));
        },
        "pointerup": function (event) {
            if (this.isEnabled("pointerup")) {
                this.dispatch("pointerup", this._makePointerEvent("pointerup", event));
            }
        },
        "globalpointerup": function (event) {
            if (this.isEnabled("globalpointerup")) {
                this.dispatch("globalpointerup", this._makePointerEvent("globalpointerup", event));
            }
        },
        "globalpointermove": function (event) {
            if (this.isEnabled("globalpointermove")) {
                this.dispatch("globalpointermove", this._makePointerEvent("globalpointermove", event));
            }
        },
        "wheel": function (event) {
            this.dispatchParents("wheel", {
                type: "wheel",
                target: this._sprite,
                originalEvent: event.event,
                point: event.point,
            });
        },
    }
});
/**
 * A base class for all visual elements.
 *
 * @important
 */
class Sprite extends _util_Entity__WEBPACK_IMPORTED_MODULE_3__.Entity {
    constructor() {
        super(...arguments);
        Object.defineProperty(this, "_adjustedLocalBounds", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: { left: 0, right: 0, top: 0, bottom: 0 }
        });
        Object.defineProperty(this, "_localBounds", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: { left: 0, right: 0, top: 0, bottom: 0 }
        });
        Object.defineProperty(this, "_parent", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_dataItem", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_templateField", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_sizeDirty", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        // Will be true only when dragging
        Object.defineProperty(this, "_isDragging", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        // The event when the dragging starts
        Object.defineProperty(this, "_dragEvent", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        // The position when dragging starts
        Object.defineProperty(this, "_dragPoint", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_isHidden", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        Object.defineProperty(this, "_isShowing", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        Object.defineProperty(this, "_isHiding", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        Object.defineProperty(this, "_isDown", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        Object.defineProperty(this, "_downPoint", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_downPoints", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {}
        });
        Object.defineProperty(this, "_toggleDp", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_dragDp", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_tooltipDp", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_hoverDp", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_focusDp", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_tooltipMoveDp", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_tooltipPointerDp", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_statesHandled", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
    }
    _afterNew() {
        this.setPrivateRaw("visible", true);
        super._afterNew();
    }
    _markDirtyKey(key) {
        super._markDirtyKey(key);
        if (key == "x" || key == "y" || key == "dx" || key == "dy") {
            this.markDirtyBounds();
            this._addPercentagePositionChildren();
            this.markDirtyPosition();
        }
    }
    _markDirtyPrivateKey(key) {
        super._markDirtyPrivateKey(key);
        if (key == "x" || key == "y") {
            this.markDirtyPosition();
        }
    }
    _removeTemplateField() {
        if (this._templateField) {
            this._templateField._removeObjectTemplate(this);
        }
    }
    _createEvents() {
        return new SpriteEventDispatcher(this);
    }
    _processTemplateField() {
        let template;
        const field = this.get("templateField");
        if (field) {
            const dataItem = this.dataItem;
            if (dataItem) {
                const context = dataItem.dataContext;
                if (context) {
                    template = context[field];
                    if (!(template instanceof _util_Template__WEBPACK_IMPORTED_MODULE_4__.Template) && template) {
                        template = _util_Template__WEBPACK_IMPORTED_MODULE_4__.Template.new(template);
                    }
                }
            }
        }
        if (this._templateField !== template) {
            this._removeTemplateField();
            this._templateField = template;
            if (template) {
                template._setObjectTemplate(this);
            }
            this._applyTemplates();
        }
    }
    // TODO change this to run before the element is added to the parent, so that way
    //      it doesn't need to apply the themes twice
    _setDataItem(dataItem) {
        const oldDataItem = this._dataItem;
        this._dataItem = dataItem;
        this._processTemplateField();
        const eventType = "dataitemchanged";
        if (dataItem != oldDataItem) {
            if (this.events.isEnabled(eventType)) {
                this.events.dispatch(eventType, {
                    type: eventType,
                    target: this,
                    oldDataItem: oldDataItem,
                    newDataItem: dataItem
                });
            }
        }
    }
    /**
     * A [[DataItem]] used for this element.
     *
     * NOTE: data item is being assigned automatically in most cases where it
     * matters. Use this accessor to set data item only if you know what you're
     * doing.
     *
     * @param  value  Data item
     */
    set dataItem(value) {
        this._setDataItem(value);
    }
    /**
     * @return DataItem
     */
    get dataItem() {
        if (this._dataItem) {
            return this._dataItem;
        }
        else {
            let parent = this._parent;
            while (parent) {
                if (parent._dataItem) {
                    return parent._dataItem;
                }
                else {
                    parent = parent._parent;
                }
            }
        }
    }
    _addPercentageSizeChildren() {
        let parent = this.parent;
        if (parent) {
            if (this.get("width") instanceof _util_Percent__WEBPACK_IMPORTED_MODULE_5__.Percent || this.get("height") instanceof _util_Percent__WEBPACK_IMPORTED_MODULE_5__.Percent) {
                _util_Array__WEBPACK_IMPORTED_MODULE_6__.pushOne(parent._percentageSizeChildren, this);
            }
            else {
                _util_Array__WEBPACK_IMPORTED_MODULE_6__.removeFirst(parent._percentageSizeChildren, this);
            }
        }
    }
    _addPercentagePositionChildren() {
        let parent = this.parent;
        if (parent) {
            if (this.get("x") instanceof _util_Percent__WEBPACK_IMPORTED_MODULE_5__.Percent || this.get("y") instanceof _util_Percent__WEBPACK_IMPORTED_MODULE_5__.Percent) {
                _util_Array__WEBPACK_IMPORTED_MODULE_6__.pushOne(parent._percentagePositionChildren, this);
            }
            else {
                _util_Array__WEBPACK_IMPORTED_MODULE_6__.removeFirst(parent._percentagePositionChildren, this);
            }
        }
    }
    /**
     * @ignore
     */
    markDirtyPosition() {
        this._root._addDirtyPosition(this);
    }
    updatePivotPoint() {
        const bounds = this._localBounds;
        if (bounds) {
            const centerX = this.get("centerX");
            if (centerX != null) {
                this._display.pivot.x = bounds.left + _util_Utils__WEBPACK_IMPORTED_MODULE_7__.relativeToValue(centerX, bounds.right - bounds.left);
            }
            const centerY = this.get("centerY");
            if (centerY != null) {
                this._display.pivot.y = bounds.top + _util_Utils__WEBPACK_IMPORTED_MODULE_7__.relativeToValue(centerY, bounds.bottom - bounds.top);
            }
        }
    }
    _beforeChanged() {
        super._beforeChanged();
        // handling states in beforeChanged, otherwise states is not applied without animated theme
        this._handleStates();
        if (this.isDirty("tooltip")) {
            const previous = this._prevSettings.tooltip;
            if (previous) {
                previous.dispose();
            }
        }
        if (this.isDirty("layer") || this.isDirty("layerMargin")) {
            this._display.setLayer(this.get("layer"), this.get("layerMargin"));
            this.markDirtyLayer();
        }
        if (this.isDirty("tooltipPosition")) {
            const tooltipMoveDp = this._tooltipMoveDp;
            if (tooltipMoveDp) {
                tooltipMoveDp.dispose();
                this._tooltipMoveDp = undefined;
            }
            const tooltipPointerDp = this._tooltipPointerDp;
            if (tooltipPointerDp) {
                tooltipPointerDp.dispose();
                this._tooltipPointerDp = undefined;
            }
            if (this.get("tooltipPosition") == "pointer") {
                if (this.isHover()) {
                    this._tooltipMoveDp = this.events.on("globalpointermove", (e) => {
                        this.showTooltip(e.point);
                    });
                }
                this._tooltipPointerDp = new _util_Disposer__WEBPACK_IMPORTED_MODULE_1__.MultiDisposer([
                    this.events.on("pointerover", () => {
                        this._tooltipMoveDp = this.events.on("globalpointermove", (e) => {
                            this.showTooltip(e.point);
                        });
                    }),
                    this.events.on("pointerout", () => {
                        const tooltipMoveDp = this._tooltipMoveDp;
                        if (tooltipMoveDp) {
                            tooltipMoveDp.dispose();
                            this._tooltipMoveDp = undefined;
                        }
                    })
                ]);
            }
        }
    }
    _handleStates() {
        if (!this._statesHandled) {
            if (this.isDirty("active")) {
                if (this.get("active")) {
                    this.states.applyAnimate("active");
                    this.set("ariaChecked", true);
                }
                else {
                    if (!this.isHidden()) {
                        this.states.applyAnimate("default");
                    }
                    this.set("ariaChecked", false);
                }
                this.markDirtyAccessibility();
            }
            if (this.isDirty("disabled")) {
                if (this.get("disabled")) {
                    this.states.applyAnimate("disabled");
                    this.set("ariaChecked", false);
                }
                else {
                    if (!this.isHidden()) {
                        this.states.applyAnimate("default");
                    }
                    this.set("ariaChecked", true);
                }
                this.markDirtyAccessibility();
            }
            this._statesHandled = true;
        }
    }
    _changed() {
        super._changed();
        const display = this._display;
        const events = this.events;
        if (this.isDirty("draggable")) {
            const draggable = this.get("draggable");
            if (draggable) {
                this.set("interactive", true);
                this._dragDp = new _util_Disposer__WEBPACK_IMPORTED_MODULE_1__.MultiDisposer([
                    events.on("pointerdown", (ev) => {
                        this.dragStart(ev);
                    }),
                    events.on("globalpointermove", (ev) => {
                        this.dragMove(ev);
                    }),
                    events.on("globalpointerup", (ev) => {
                        this.dragStop(ev);
                    })
                ]);
            }
            else {
                if (this._dragDp) {
                    this._dragDp.dispose();
                    this._dragDp = undefined;
                }
            }
            display.cancelTouch = draggable ? true : false;
        }
        if (this.isDirty("tooltipText") || this.isDirty("tooltipHTML") || this.isDirty("showTooltipOn")) {
            const tooltipText = this.get("tooltipText");
            const tooltipHTML = this.get("tooltipHTML");
            const showTooltipOn = this.get("showTooltipOn", "hover");
            if (this._tooltipDp) {
                this._tooltipDp.dispose();
                this._tooltipDp = undefined;
            }
            if (tooltipText || tooltipHTML) {
                if (showTooltipOn == "click") {
                    this._tooltipDp = new _util_Disposer__WEBPACK_IMPORTED_MODULE_1__.MultiDisposer([
                        events.on("click", () => {
                            this.setTimeout(() => this.showTooltip(), 10);
                        }),
                        _util_Utils__WEBPACK_IMPORTED_MODULE_7__.addEventListener(document, "click", (_ev) => {
                            this.hideTooltip();
                        })
                    ]);
                    this._disposers.push(this._tooltipDp);
                }
                else if (showTooltipOn == "always") {
                    // nothing
                }
                else {
                    this._tooltipDp = new _util_Disposer__WEBPACK_IMPORTED_MODULE_1__.MultiDisposer([
                        events.on("pointerover", () => {
                            this.showTooltip();
                        }),
                        events.on("pointerout", () => {
                            this.hideTooltip();
                        })
                    ]);
                    this._disposers.push(this._tooltipDp);
                }
            }
        }
        if (this.isDirty("toggleKey")) {
            let toggleKey = this.get("toggleKey");
            if (toggleKey && toggleKey != "none") {
                this._toggleDp = events.on("click", () => {
                    if (!this._isDragging) {
                        this.set(toggleKey, !this.get(toggleKey));
                    }
                });
            }
            else {
                if (this._toggleDp) {
                    this._toggleDp.dispose();
                    this._toggleDp = undefined;
                }
            }
        }
        if (this.isDirty("opacity")) {
            display.alpha = Math.max(0, this.get("opacity", 1));
            if (this.get("focusable")) {
                this.markDirtyAccessibility();
            }
        }
        if (this.isDirty("rotation")) {
            this.markDirtyBounds();
            display.angle = this.get("rotation", 0);
        }
        if (this.isDirty("scale")) {
            this.markDirtyBounds();
            display.scale = this.get("scale", 0);
        }
        if (this.isDirty("centerX") || this.isDirty("centerY")) {
            this.markDirtyBounds();
            this.updatePivotPoint();
        }
        if (this.isDirty("visible") || this.isPrivateDirty("visible") || this.isDirty("forceHidden")) {
            if (!this.get("visible") || !this.getPrivate("visible") || this.get("forceHidden")) {
                display.visible = false;
                this.hideTooltip();
            }
            else {
                display.visible = true;
            }
            this.markDirtyBounds();
            if (this.get("focusable")) {
                this.markDirtyAccessibility();
            }
        }
        if (this.isDirty("width") || this.isDirty("height")) {
            this.markDirtyBounds();
            this._addPercentageSizeChildren();
            const parent = this.parent;
            if (parent) {
                if ((this.isDirty("width") && this.get("width") instanceof _util_Percent__WEBPACK_IMPORTED_MODULE_5__.Percent) || (this.isDirty("height") && this.get("height") instanceof _util_Percent__WEBPACK_IMPORTED_MODULE_5__.Percent)) {
                    parent.markDirty();
                    parent._prevWidth = 0;
                }
            }
            this._sizeDirty = true;
        }
        if (this.isDirty("maxWidth") || this.isDirty("maxHeight") || this.isPrivateDirty("width") || this.isPrivateDirty("height") || this.isDirty("minWidth") || this.isDirty("minHeight") || this.isPrivateDirty("maxWidth") || this.isPrivateDirty("maxHeight") || this.isPrivateDirty("minWidth") || this.isPrivateDirty("minHeight")) {
            this.markDirtyBounds();
            this._sizeDirty = true;
        }
        if (this._sizeDirty) {
            this._updateSize();
        }
        if (this.isDirty("wheelable")) {
            const wheelable = this.get("wheelable");
            if (wheelable) {
                this.set("interactive", true);
            }
            display.wheelable = wheelable ? true : false;
        }
        // Accessibility
        if (this.isDirty("tabindexOrder") || this.isDirty("focusableGroup")) {
            if (this.get("focusable")) {
                this._root._registerTabindexOrder(this);
            }
            else {
                this._root._unregisterTabindexOrder(this);
            }
        }
        if (this.isDirty("filter")) {
            //this.markDirtyBounds();
            display.filter = this.get("filter");
        }
        let filter = this.get("filter", "");
        if (this.isDirty("blur")) {
            const blur = this.get("blur", 0);
            if (blur != 0) {
                filter += " blur(" + blur + "px)";
            }
        }
        if (this.isDirty("saturate")) {
            const saturate = this.get("saturate", 1);
            if (saturate != 1) {
                filter += " saturate(" + saturate + ")";
            }
        }
        if (this.isDirty("brightness")) {
            const brightness = this.get("brightness", 1);
            if (brightness != 1) {
                filter += " brightness(" + brightness + ")";
            }
        }
        if (this.isDirty("contrast")) {
            const contrast = this.get("contrast", 1);
            if (contrast != 1) {
                filter += " contrast(" + contrast + ")";
            }
        }
        if (this.isDirty("sepia")) {
            const sepia = this.get("sepia", 0);
            if (sepia != 0) {
                filter += " sepia(" + sepia + ")";
            }
        }
        if (this.isDirty("hue")) {
            const hue = this.get("hue", 0);
            if (hue != 0) {
                filter += " hue-rotate(" + hue + "deg)";
            }
        }
        if (this.isDirty("invert")) {
            const invert = this.get("invert", 0);
            if (invert != 0) {
                filter += " invert(" + invert + ")";
            }
        }
        if (filter) {
            display.filter = filter;
        }
        if (this.isDirty("cursorOverStyle")) {
            display.cursorOverStyle = this.get("cursorOverStyle");
        }
        if (this.isDirty("hoverOnFocus")) {
            if (this.get("hoverOnFocus")) {
                this._focusDp = new _util_Disposer__WEBPACK_IMPORTED_MODULE_1__.MultiDisposer([
                    events.on("focus", () => {
                        // TODO: proper hover, not just tooltip
                        this.showTooltip();
                    }),
                    events.on("blur", () => {
                        // TODO: proper hover, not just tooltip
                        this.hideTooltip();
                    })
                ]);
            }
            else {
                if (this._focusDp) {
                    this._focusDp.dispose();
                    this._focusDp = undefined;
                }
            }
        }
        if (this.isDirty("focusable")) {
            if (this.get("focusable")) {
                this._root._registerTabindexOrder(this);
            }
            else {
                this._root._unregisterTabindexOrder(this);
            }
            this.markDirtyAccessibility();
        }
        if (this.isPrivateDirty("focusable")) {
            this.markDirtyAccessibility();
        }
        if (this.isDirty("role") || this.isDirty("ariaLive") || this.isDirty("ariaChecked") || this.isDirty("ariaHidden") || this.isDirty("ariaOrientation") || this.isDirty("ariaValueNow") || this.isDirty("ariaValueMin") || this.isDirty("ariaValueMax") || this.isDirty("ariaValueText") || this.isDirty("ariaLabel") || this.isDirty("ariaControls")) {
            // display.accessibility.ariaLabel = populateString(this, this.get("ariaLabel", ""));
            // @todo make sure ariaLabel gets populated in Root
            this.markDirtyAccessibility();
        }
        if (this.isDirty("exportable")) {
            display.exportable = this.get("exportable");
        }
        if (this.isDirty("interactive")) {
            const events = this.events;
            if (this.get("interactive")) {
                this._hoverDp = new _util_Disposer__WEBPACK_IMPORTED_MODULE_1__.MultiDisposer([
                    events.on("click", (ev) => {
                        if (_util_Utils__WEBPACK_IMPORTED_MODULE_7__.isTouchEvent(ev.originalEvent)) {
                            if (!this.getPrivate("touchHovering")) {
                                this.setTimeout(() => {
                                    this._handleOver();
                                    if (this.get("tooltipText") || this.get("tooltipHTML")) {
                                        this.showTooltip();
                                    }
                                    this.setPrivateRaw("touchHovering", true);
                                    this.events.dispatch("pointerover", {
                                        type: "pointerover",
                                        target: ev.target,
                                        originalEvent: ev.originalEvent,
                                        point: ev.point,
                                        simulated: ev.simulated
                                    });
                                }, 10);
                            }
                        }
                    }),
                    events.on("globalpointerup", (ev) => {
                        if (_util_Utils__WEBPACK_IMPORTED_MODULE_7__.isTouchEvent(ev.originalEvent)) {
                            if (this.getPrivate("touchHovering")) {
                                this._handleOut();
                                if (this.get("tooltipText") || this.get("tooltipHTML")) {
                                    this.hideTooltip();
                                }
                                this.setPrivateRaw("touchHovering", false);
                                this.events.dispatch("pointerout", {
                                    type: "pointerout",
                                    target: ev.target,
                                    originalEvent: ev.originalEvent,
                                    point: ev.point,
                                    simulated: ev.simulated
                                });
                            }
                        }
                        if (this._isDown) {
                            this._handleUp(ev);
                        }
                        //this._isDown = false;
                    }),
                    events.on("pointerover", () => {
                        this._handleOver();
                    }),
                    events.on("pointerout", () => {
                        this._handleOut();
                    }),
                    events.on("pointerdown", (e) => {
                        this._handleDown(e);
                    })
                ]);
            }
            else {
                this._display.interactive = false;
                if (this._hoverDp) {
                    this._hoverDp.dispose();
                    this._hoverDp = undefined;
                }
            }
        }
        if (this.isDirty("forceInactive")) {
            this._display.inactive = this.get("forceInactive", null);
        }
        if (this.get("showTooltipOn") == "always" && this._display.visible) {
            this.showTooltip();
        }
    }
    /**
     * @ignore
     * @todo should this be user-accessible?
     */
    dragStart(e) {
        this._dragEvent = e;
        this.events.stopParentDispatch();
    }
    /**
     * @ignore
     * @todo should this be user-accessible?
     */
    dragStop(e) {
        this._dragEvent = undefined;
        this._dragPoint = undefined;
        this.events.stopParentDispatch();
        if (this._isDragging) {
            this._isDragging = false;
            const type = "dragstop";
            if (this.events.isEnabled(type)) {
                this.events.dispatch(type, {
                    type: type,
                    target: this,
                    originalEvent: e.originalEvent,
                    point: e.point,
                    simulated: e.simulated,
                });
            }
        }
    }
    _handleOver() {
        if (!this.isHidden()) {
            if (this.get("active") && this.states.lookup("hoverActive")) {
                this.states.applyAnimate("hoverActive");
            }
            else if (this.get("disabled") && this.states.lookup("hoverDisabled")) {
                this.states.applyAnimate("hoverDisabled");
            }
            else {
                this.states.applyAnimate("hover");
            }
            if (this.get("draggable") && this._isDown && this.states.lookup("down")) {
                this.states.applyAnimate("down");
            }
        }
    }
    _handleOut() {
        if (!this.isHidden()) {
            if (this.get("active") && this.states.lookup("active")) {
                this.states.applyAnimate("active");
            }
            else if (this.get("disabled") && this.states.lookup("disabled")) {
                this.states.applyAnimate("disabled");
            }
            else {
                if (this.states.lookup("hover") || this.states.lookup("hoverActive")) {
                    this.states.applyAnimate("default");
                }
            }
            if (this.get("draggable") && this._isDown && this.states.lookup("down")) {
                this.states.applyAnimate("down");
            }
        }
    }
    _handleUp(e) {
        if (!this.isHidden()) {
            if (this.get("active") && this.states.lookup("active")) {
                this.states.applyAnimate("active");
            }
            else if (this.get("disabled") && this.states.lookup("disabled")) {
                this.states.applyAnimate("disabled");
            }
            else if (this.states.lookup("down")) {
                if (this.isHover()) {
                    this.states.applyAnimate("hover");
                }
                else {
                    this.states.applyAnimate("default");
                }
            }
            // @todo remove this once migrated to _downPoints
            this._downPoint = undefined;
            const pointerId = _util_Utils__WEBPACK_IMPORTED_MODULE_7__.getPointerId(e.originalEvent);
            delete this._downPoints[pointerId];
            if (_util_Object__WEBPACK_IMPORTED_MODULE_8__.keys(this._downPoints).length == 0) {
                this._isDown = false;
            }
        }
    }
    _hasMoved(e) {
        // @todo remove this once migrated to _downPoints
        // if (this._downPoint) {
        // 	const x = Math.abs(this._downPoint.x - e.point.x);
        // 	const y = Math.abs(this._downPoint.y - e.point.y);
        // 	return (x > 5) || (y > 5);
        // }
        const pointerId = _util_Utils__WEBPACK_IMPORTED_MODULE_7__.getPointerId(e.originalEvent);
        const downPoint = this._downPoints[pointerId];
        if (downPoint) {
            const x = Math.abs(downPoint.x - e.point.x);
            const y = Math.abs(downPoint.y - e.point.y);
            return (x > 5) || (y > 5);
        }
        return false;
    }
    _hasDown() {
        return _util_Object__WEBPACK_IMPORTED_MODULE_8__.keys(this._downPoints).length > 0;
    }
    _handleDown(e) {
        const parent = this.parent;
        if (parent && !this.get("draggable")) {
            parent._handleDown(e);
        }
        if (this.get("interactive") && !this.isHidden()) {
            if (this.states.lookup("down")) {
                this.states.applyAnimate("down");
            }
            this._downPoint = {
                x: e.point.x,
                y: e.point.y
            };
            // @todo remove this once migrated to _downPoints
            this._isDown = true;
            const pointerId = _util_Utils__WEBPACK_IMPORTED_MODULE_7__.getPointerId(e.originalEvent);
            this._downPoints[pointerId] = {
                x: e.point.x,
                y: e.point.y
            };
        }
    }
    /**
     * @ignore
     * @todo should this be user-accessible?
     */
    dragMove(e) {
        let dragEvent = this._dragEvent;
        if (dragEvent) {
            if (dragEvent.simulated && !e.simulated) {
                return true;
            }
            let angle = 0;
            let parent = this.parent;
            while (parent != null) {
                angle += parent.get("rotation", 0);
                parent = parent.parent;
            }
            let x = e.point.x - dragEvent.point.x;
            let y = e.point.y - dragEvent.point.y;
            const events = this.events;
            if (dragEvent.simulated && !this._isDragging) {
                this._isDragging = true;
                this._dragEvent = e;
                this._dragPoint = {
                    x: this.x(),
                    y: this.y()
                };
                const type = "dragstart";
                if (events.isEnabled(type)) {
                    events.dispatch(type, {
                        type: type,
                        target: this,
                        originalEvent: e.originalEvent,
                        point: e.point,
                        simulated: e.simulated,
                    });
                }
            }
            if (this._isDragging) {
                let dragPoint = this._dragPoint;
                this.set("x", dragPoint.x + x * _util_Math__WEBPACK_IMPORTED_MODULE_2__.cos(angle) + y * _util_Math__WEBPACK_IMPORTED_MODULE_2__.sin(angle));
                this.set("y", dragPoint.y + y * _util_Math__WEBPACK_IMPORTED_MODULE_2__.cos(angle) - x * _util_Math__WEBPACK_IMPORTED_MODULE_2__.sin(angle));
                const type = "dragged";
                if (events.isEnabled(type)) {
                    events.dispatch(type, {
                        type: type,
                        target: this,
                        originalEvent: e.originalEvent,
                        point: e.point,
                        simulated: e.simulated,
                    });
                }
            }
            else {
                if (Math.hypot(x, y) > 5) {
                    this._isDragging = true;
                    this._dragEvent = e;
                    this._dragPoint = {
                        x: this.x(),
                        y: this.y()
                    };
                    const type = "dragstart";
                    if (events.isEnabled(type)) {
                        events.dispatch(type, {
                            type: type,
                            target: this,
                            originalEvent: e.originalEvent,
                            point: e.point,
                            simulated: e.simulated
                        });
                    }
                }
            }
        }
    }
    _updateSize() {
    }
    _getBounds() {
        this._localBounds = this._display.getLocalBounds();
    }
    /**
     * Returns depth (how deep in the hierachy of the content tree) of this
     * element.
     *
     * @return Depth
     */
    depth() {
        let self = this.parent;
        let depth = 0;
        while (true) {
            if (self) {
                ++depth;
                self = self.parent;
            }
            else {
                return depth;
            }
        }
    }
    /**
     * @ignore
     */
    markDirtySize() {
        this._sizeDirty = true;
        this.markDirty();
    }
    /**
     * @ignore
     */
    markDirtyBounds() {
        const display = this._display;
        if (this.get("isMeasured")) {
            this._root._addDirtyBounds(this);
            display.isMeasured = true;
            display.invalidateBounds();
            const parent = this.parent;
            if (parent && this.get("position") != "absolute") {
                if (parent.get("width") == null || parent.get("height") == null || parent.get("layout")) {
                    parent.markDirtyBounds();
                }
            }
            if (this.get("focusable") && this.isFocus()) {
                this.markDirtyAccessibility();
            }
        }
    }
    /**
     * @ignore
     */
    markDirtyAccessibility() {
        //if (this._root.focused(this)) {
        this._root._invalidateAccessibility(this);
        //}
    }
    /**
     * @ignore
     */
    markDirtyLayer() {
        //this._display.markDirtyLayer(this.isDirty("opacity") || this.isDirty("visible")); https://codepen.io/team/amcharts/pen/gOWZPmP <- problems
        this._display.markDirtyLayer(true);
    }
    /**
     * @ignore
     */
    markDirty() {
        super.markDirty();
        this.markDirtyLayer();
    }
    _updateBounds() {
        const oldBounds = this._adjustedLocalBounds;
        let newBounds;
        // if display.visible == false, it still returns bounds
        if (!this.get("visible") || !this.getPrivate("visible") || this.get("forceHidden")) {
            newBounds = {
                left: 0,
                right: 0,
                top: 0,
                bottom: 0
            };
            this._localBounds = newBounds;
            this._adjustedLocalBounds = newBounds;
        }
        else {
            this._getBounds();
            this._fixMinBounds(this._localBounds);
            this.updatePivotPoint();
            this._adjustedLocalBounds = this._display.getAdjustedBounds(this._localBounds);
            newBounds = this._adjustedLocalBounds;
        }
        if (!oldBounds || (oldBounds.left !== newBounds.left || oldBounds.top !== newBounds.top || oldBounds.right !== newBounds.right || oldBounds.bottom !== newBounds.bottom)) {
            const eventType = "boundschanged";
            if (this.events.isEnabled(eventType)) {
                this.events.dispatch(eventType, { type: eventType, target: this });
            }
            if (this.parent) {
                this.parent.markDirty();
                this.parent.markDirtyBounds();
            }
        }
    }
    _fixMinBounds(bounds) {
        let minWidth = this.get("minWidth", this.getPrivate("minWidth"));
        let minHeight = this.get("minHeight", this.getPrivate("minHeight"));
        if (_util_Type__WEBPACK_IMPORTED_MODULE_9__.isNumber(minWidth)) {
            if (bounds.right - bounds.left < minWidth) {
                bounds.right = bounds.left + minWidth;
            }
        }
        if (_util_Type__WEBPACK_IMPORTED_MODULE_9__.isNumber(minHeight)) {
            if (bounds.bottom - bounds.top < minHeight) {
                bounds.bottom = bounds.top + minHeight;
            }
        }
        let privateWidth = this.getPrivate("width");
        let privateHeight = this.getPrivate("height");
        if (_util_Type__WEBPACK_IMPORTED_MODULE_9__.isNumber(privateWidth)) {
            if (privateWidth > 0) {
                bounds.right = bounds.left + privateWidth;
            }
            else {
                bounds.left = bounds.right + privateWidth;
            }
        }
        if (_util_Type__WEBPACK_IMPORTED_MODULE_9__.isNumber(privateHeight)) {
            if (privateHeight > 0) {
                bounds.bottom = bounds.top + privateHeight;
            }
            else {
                bounds.top = bounds.bottom + privateHeight;
            }
        }
    }
    _removeParent(parent) {
        if (parent) {
            parent.children.removeValue(this);
            _util_Array__WEBPACK_IMPORTED_MODULE_6__.removeFirst(parent._percentageSizeChildren, this);
            _util_Array__WEBPACK_IMPORTED_MODULE_6__.removeFirst(parent._percentagePositionChildren, this);
        }
    }
    _clearDirty() {
        super._clearDirty();
        this._sizeDirty = false;
        this._statesHandled = false;
    }
    /**
     * Simulate hover over element.
     */
    hover() {
        this.showTooltip();
        this._handleOver();
    }
    /**
     * Simulate unhover over element.
     */
    unhover() {
        this.hideTooltip();
        this._handleOut();
    }
    /**
     * Shows element's [[Tooltip]].
     */
    showTooltip(point) {
        const tooltip = this.getTooltip();
        const tooltipText = this.get("tooltipText");
        const tooltipHTML = this.get("tooltipHTML");
        if ((tooltipText || tooltipHTML) && tooltip) {
            const tooltipPosition = this.get("tooltipPosition");
            const tooltipTarget = this.getPrivate("tooltipTarget", this);
            if (tooltipPosition == "fixed" || !point) {
                this._display._setMatrix();
                point = this.toGlobal(tooltipTarget._getTooltipPoint());
            }
            tooltip.set("pointTo", point);
            tooltip.set("tooltipTarget", tooltipTarget);
            if (!tooltip.get("x")) {
                tooltip.set("x", point.x);
            }
            if (!tooltip.get("y")) {
                tooltip.set("y", point.y);
            }
            if (tooltipText) {
                tooltip.label.set("text", tooltipText);
            }
            if (tooltipHTML) {
                tooltip.label.set("html", tooltipHTML);
            }
            const dataItem = this.dataItem;
            if (dataItem) {
                tooltip.label._setDataItem(dataItem);
            }
            if (this.get("showTooltipOn") == "always" && (point.x < 0 || point.x > this._root.width() || point.y < 0 || point.y > this._root.height())) {
                this.hideTooltip();
                return;
            }
            tooltip.label.text.markDirtyText();
            const promise = tooltip.show();
            this.setPrivateRaw("showingTooltip", true);
            return promise;
        }
    }
    /**
     * Hides element's [[Tooltip]].
     */
    hideTooltip() {
        const tooltip = this.getTooltip();
        if (tooltip) {
            if (tooltip.get("tooltipTarget") == this.getPrivate("tooltipTarget", this) || this.get("tooltip") == tooltip) {
                let timeout = tooltip.get("keepTargetHover") && tooltip.get("stateAnimationDuration", 0) == 0 ? 400 : undefined;
                const promise = tooltip.hide(timeout);
                this.setPrivateRaw("showingTooltip", false);
                return promise;
            }
        }
    }
    _getTooltipPoint() {
        const bounds = this._localBounds;
        if (bounds) {
            let x = 0;
            let y = 0;
            if (!this.get("isMeasured")) {
                x = _util_Utils__WEBPACK_IMPORTED_MODULE_7__.relativeToValue(this.get("tooltipX", 0), this.width());
                y = _util_Utils__WEBPACK_IMPORTED_MODULE_7__.relativeToValue(this.get("tooltipY", 0), this.height());
            }
            else {
                x = bounds.left + _util_Utils__WEBPACK_IMPORTED_MODULE_7__.relativeToValue(this.get("tooltipX", 0), bounds.right - bounds.left);
                y = bounds.top + _util_Utils__WEBPACK_IMPORTED_MODULE_7__.relativeToValue(this.get("tooltipY", 0), bounds.bottom - bounds.top);
            }
            return { x, y };
        }
        return { x: 0, y: 0 };
    }
    /**
     * Returns [[Tooltip]] used for this element.
     *
     * @return Tooltip
     */
    getTooltip() {
        let tooltip = this.get("tooltip");
        if (!tooltip) {
            let parent = this.parent;
            if (parent) {
                return parent.getTooltip();
            }
        }
        else {
            return tooltip;
        }
    }
    _updatePosition() {
        const parent = this.parent;
        let dx = this.get("dx", 0);
        let dy = this.get("dy", 0);
        let x = this.get("x");
        let _x = this.getPrivate("x");
        let xx = 0;
        let yy = 0;
        const position = this.get("position");
        if (x instanceof _util_Percent__WEBPACK_IMPORTED_MODULE_5__.Percent) {
            if (parent) {
                x = parent.innerWidth() * x.value + parent.get("paddingLeft", 0);
            }
            else {
                x = 0;
            }
        }
        if (_util_Type__WEBPACK_IMPORTED_MODULE_9__.isNumber(x)) {
            xx = x + dx;
        }
        else {
            if (_x != null) {
                xx = _x;
            }
            else if (parent) {
                if (position == "relative") {
                    xx = parent.get("paddingLeft", 0) + dx;
                }
            }
        }
        let y = this.get("y");
        let _y = this.getPrivate("y");
        if (y instanceof _util_Percent__WEBPACK_IMPORTED_MODULE_5__.Percent) {
            if (parent) {
                y = parent.innerHeight() * y.value + parent.get("paddingTop", 0);
            }
            else {
                y = 0;
            }
        }
        if (_util_Type__WEBPACK_IMPORTED_MODULE_9__.isNumber(y)) {
            yy = y + dy;
        }
        else {
            if (_y != null) {
                yy = _y;
            }
            else if (parent) {
                if (position == "relative") {
                    yy = parent.get("paddingTop", 0) + dy;
                }
            }
        }
        const display = this._display;
        if (display.x != xx || display.y != yy) {
            display.invalidateBounds();
            display.x = xx;
            display.y = yy;
            const eventType = "positionchanged";
            if (this.events.isEnabled(eventType)) {
                this.events.dispatch(eventType, { type: eventType, target: this });
            }
        }
        // Update tooltip position together with the Sprite
        if (this.getPrivate("showingTooltip")) {
            this.showTooltip();
        }
    }
    /**
     * Returns element's actual X position in pixels.
     *
     * @return X (px)
     */
    x() {
        let x = this.get("x");
        let _x = this.getPrivate("x");
        const parent = this.parent;
        if (parent) {
            if (x instanceof _util_Percent__WEBPACK_IMPORTED_MODULE_5__.Percent) {
                return _util_Utils__WEBPACK_IMPORTED_MODULE_7__.relativeToValue(x, parent.innerWidth()) + parent.get("paddingLeft", 0);
            }
            else {
                if (!_util_Type__WEBPACK_IMPORTED_MODULE_9__.isNumber(x)) {
                    if (_x != null) {
                        return _x;
                    }
                    else {
                        return parent.get("paddingLeft", this._display.x);
                    }
                }
                else {
                    return x;
                }
            }
        }
        return this._display.x;
    }
    /**
     * Returns element's actual Y position in pixels.
     *
     * @return Y (px)
     */
    y() {
        let _y = this.getPrivate("y");
        if (_y != null) {
            return _y;
        }
        let y = this.get("y");
        const parent = this.parent;
        if (parent) {
            if (y instanceof _util_Percent__WEBPACK_IMPORTED_MODULE_5__.Percent) {
                return _util_Utils__WEBPACK_IMPORTED_MODULE_7__.relativeToValue(y, parent.innerHeight()) + parent.get("paddingTop", 0);
            }
            else {
                if (!_util_Type__WEBPACK_IMPORTED_MODULE_9__.isNumber(y)) {
                    if (_y != null) {
                        return _y;
                    }
                    else {
                        return parent.get("paddingTop", this._display.y);
                    }
                }
                else {
                    return y;
                }
            }
        }
        return this._display.y;
    }
    _dispose() {
        super._dispose();
        this._display.dispose();
        this._removeTemplateField();
        this._removeParent(this.parent);
        this._root._removeFocusElement(this);
        const tooltip = this.get("tooltip");
        if (tooltip) {
            tooltip.dispose();
        }
        this.markDirty();
    }
    /**
     * @ignore
     */
    adjustedLocalBounds() {
        this._fixMinBounds(this._adjustedLocalBounds);
        return this._adjustedLocalBounds;
    }
    /**
     * Returns local coordinates of the element's bounds.
     *
     * @ignore
     * @return Global bounds
     */
    localBounds() {
        return this._localBounds;
    }
    /**
     * Returns adjusted local coordinates of the element's bounds.
     *
     * @ignore
     * @return Global bounds
     */
    bounds() {
        const bounds = this._adjustedLocalBounds;
        const x = this.x();
        const y = this.y();
        return { left: bounds.left + x, right: bounds.right + x, top: bounds.top + y, bottom: bounds.bottom + y };
    }
    /**
     * Returns global coordinates of the element's bounds.
     *
     * @ignore
     * @return Global bounds
     */
    globalBounds() {
        const bounds = this.localBounds();
        const p0 = this.toGlobal({ x: bounds.left, y: bounds.top });
        const p1 = this.toGlobal({ x: bounds.right, y: bounds.top });
        const p2 = this.toGlobal({ x: bounds.right, y: bounds.bottom });
        const p3 = this.toGlobal({ x: bounds.left, y: bounds.bottom });
        return {
            left: Math.min(p0.x, p1.x, p2.x, p3.x),
            top: Math.min(p0.y, p1.y, p2.y, p3.y),
            right: Math.max(p0.x, p1.x, p2.x, p3.x),
            bottom: Math.max(p0.y, p1.y, p2.y, p3.y)
        };
    }
    _onShow(_duration) {
    }
    _onHide(_duration) {
    }
    /**
     * Plays initial reveal animation regardless if element is currently hidden
     * or visible.
     *
     * @param   duration  Duration of the animation in milliseconds
     * @param   delay     Delay showing of the element by X milliseconds
     * @return            Promise
     */
    appear(duration, delay) {
        return (0,tslib__WEBPACK_IMPORTED_MODULE_10__.__awaiter)(this, void 0, void 0, function* () {
            yield this.hide(0);
            if (delay) {
                return new Promise((success, _error) => {
                    this.setTimeout(() => {
                        success(this.show(duration));
                    }, delay);
                });
            }
            else {
                return this.show(duration);
            }
        });
    }
    /**
     * Shows currently hidden element and returns a `Promise` which completes
     * when all showing animations are finished.
     *
     * ```TypeScript
     * series.show().then(function(ev) {
     *   console.log("Series is now fully visible");
     * })
     * ```
     * ```JavaScript
     * series.show().then(function(ev) {
     *   console.log("Series is now fully visible");
     * })
     * ```
     *
     * @return Promise
     */
    show(duration) {
        return (0,tslib__WEBPACK_IMPORTED_MODULE_10__.__awaiter)(this, void 0, void 0, function* () {
            if (!this._isShowing) {
                this._isHidden = false;
                this._isShowing = true;
                this._isHiding = false;
                if (this.states.lookup("default").get("visible")) {
                    this.set("visible", true);
                }
                this._onShow(duration);
                const animations = this.states.applyAnimate("default", duration);
                yield (0,_util_Animation__WEBPACK_IMPORTED_MODULE_11__.waitForAnimations)(animations);
                this._isShowing = false;
            }
        });
    }
    /**
     * Hides the element and returns a `Promise` which completes when all hiding
     * animations are finished.
     *
     * ```TypeScript
     * series.hide().then(function(ev) {
     *   console.log("Series finished hiding");
     * })
     * ```
     * ```JavaScript
     * series.hide().then(function(ev) {
     *   console.log("Series finished hiding");
     * })
     * ```
     *
     * @return Promise
     */
    hide(duration) {
        return (0,tslib__WEBPACK_IMPORTED_MODULE_10__.__awaiter)(this, void 0, void 0, function* () {
            if (!this._isHiding && !this._isHidden) {
                this._isHiding = true;
                this._isShowing = false;
                let state = this.states.lookup("hidden");
                if (!state) {
                    state = this.states.create("hidden", {
                        "opacity": 0,
                        "visible": false
                    });
                }
                this._isHidden = true;
                this._onHide(duration);
                const animations = this.states.applyAnimate("hidden", duration);
                yield (0,_util_Animation__WEBPACK_IMPORTED_MODULE_11__.waitForAnimations)(animations);
                this._isHiding = false;
            }
        });
    }
    /**
     * Returns `true` if this element is currently hidden.
     *
     * @return Is hidden?
     */
    isHidden() {
        return this._isHidden;
    }
    /**
     * Returns `true` if this element is currently animating to a default state.
     *
     * @return Is showing?
     */
    isShowing() {
        return this._isShowing;
    }
    /**
     * Returns `true` if this element is currently animating to a hidden state.
     *
     * @return Is hiding?
     */
    isHiding() {
        return this._isHiding;
    }
    /**
     * Returns `true` if this element is currently hovered by a pointer.
     *
     * @return Is hovered?
     */
    isHover() {
        return this._display.hovering();
    }
    /**
     * Returns `true` if this element does currently have focus.
     *
     * @return Is focused?
     */
    isFocus() {
        return this._root.focused(this);
    }
    /**
     * Returns `true` if this element is currently being dragged.
     *
     * @return Is dragged?
     */
    isDragging() {
        return this._isDragging;
    }
    /**
     * Returns `false` if if either public or private setting `visible` is set
     * to `false`, or `forceHidden` is set to `true`.
     *
     * @return Visible?
     */
    isVisible() {
        if (this.get("visible") && this.getPrivate("visible") && !this.get("forceHidden")) {
            return true;
        }
        return false;
    }
    /**
     * Same as `isVisible()`, except it checks all ascendants, too.
     *
     * @since 5.2.7
     * @return Visible?
     */
    isVisibleDeep() {
        return this._parent ? (this._parent.isVisibleDeep() && this.isVisible()) : this.isVisible();
    }
    /**
     * Returns an actual opacity of the element, taking into account all parents.
     *
     * @return Opacity
     * @since 5.2.11
     */
    compositeOpacity() {
        const opacity = this.get("opacity", 1);
        return this._parent ? (this._parent.compositeOpacity() * opacity) : opacity;
    }
    /**
     * Returns width of this element in pixels.
     *
     * @return Width (px)
     */
    width() {
        let width = this.get("width");
        let maxWidth = this.get("maxWidth", this.getPrivate("maxWidth"));
        let minWidth = this.get("minWidth", this.getPrivate("minWidth"));
        let privateWidth = this.getPrivate("width");
        let w = 0;
        if (_util_Type__WEBPACK_IMPORTED_MODULE_9__.isNumber(privateWidth)) {
            w = privateWidth;
        }
        else {
            if (width == null) {
                if (this._adjustedLocalBounds) {
                    w = this._adjustedLocalBounds.right - this._adjustedLocalBounds.left;
                }
            }
            else {
                if (width instanceof _util_Percent__WEBPACK_IMPORTED_MODULE_5__.Percent) {
                    const parent = this.parent;
                    if (parent) {
                        w = parent.innerWidth() * width.value;
                    }
                    else {
                        w = this._root.width() * width.value;
                    }
                }
                else if (_util_Type__WEBPACK_IMPORTED_MODULE_9__.isNumber(width)) {
                    w = width;
                }
            }
        }
        if (_util_Type__WEBPACK_IMPORTED_MODULE_9__.isNumber(minWidth)) {
            w = Math.max(minWidth, w);
        }
        if (_util_Type__WEBPACK_IMPORTED_MODULE_9__.isNumber(maxWidth)) {
            w = Math.min(maxWidth, w);
        }
        return w;
    }
    /**
     * Returns maximum allowed width of this element in pixels.
     *
     * @return Maximum width (px)
     */
    maxWidth() {
        let maxWidth = this.get("maxWidth", this.getPrivate("maxWidth"));
        if (_util_Type__WEBPACK_IMPORTED_MODULE_9__.isNumber(maxWidth)) {
            return maxWidth;
        }
        else {
            let width = this.get("width");
            if (_util_Type__WEBPACK_IMPORTED_MODULE_9__.isNumber(width)) {
                return width;
            }
        }
        const parent = this.parent;
        if (parent) {
            return parent.innerWidth();
        }
        return this._root.width();
    }
    /**
     * Returns maximum allowed height of this element in pixels.
     *
     * @return Maximum height (px)
     */
    maxHeight() {
        let maxHeight = this.get("maxHeight", this.getPrivate("maxHeight"));
        if (_util_Type__WEBPACK_IMPORTED_MODULE_9__.isNumber(maxHeight)) {
            return maxHeight;
        }
        else {
            let height = this.get("height");
            if (_util_Type__WEBPACK_IMPORTED_MODULE_9__.isNumber(height)) {
                return height;
            }
        }
        const parent = this.parent;
        if (parent) {
            return parent.innerHeight();
        }
        return this._root.height();
    }
    /**
     * Returns height of this element in pixels.
     *
     * @return Height (px)
     */
    height() {
        let height = this.get("height");
        let maxHeight = this.get("maxHeight", this.getPrivate("maxHeight"));
        let minHeight = this.get("minHeight", this.getPrivate("minHeight"));
        let privateHeight = this.getPrivate("height");
        let h = 0;
        if (_util_Type__WEBPACK_IMPORTED_MODULE_9__.isNumber(privateHeight)) {
            h = privateHeight;
        }
        else {
            if (height == null) {
                if (this._adjustedLocalBounds) {
                    h = this._adjustedLocalBounds.bottom - this._adjustedLocalBounds.top;
                }
            }
            else {
                if (height instanceof _util_Percent__WEBPACK_IMPORTED_MODULE_5__.Percent) {
                    const parent = this.parent;
                    if (parent) {
                        h = parent.innerHeight() * height.value;
                    }
                    else {
                        h = this._root.height() * height.value;
                    }
                }
                else if (_util_Type__WEBPACK_IMPORTED_MODULE_9__.isNumber(height)) {
                    h = height;
                }
            }
        }
        if (_util_Type__WEBPACK_IMPORTED_MODULE_9__.isNumber(minHeight)) {
            h = Math.max(minHeight, h);
        }
        if (_util_Type__WEBPACK_IMPORTED_MODULE_9__.isNumber(maxHeight)) {
            h = Math.min(maxHeight, h);
        }
        return h;
    }
    _findStaticTemplate(f) {
        // templateField overrides template
        if (this._templateField && f(this._templateField)) {
            return this._templateField;
        }
        return super._findStaticTemplate(f);
    }
    _walkParents(f) {
        if (this._parent) {
            this._walkParent(f);
        }
    }
    _walkParent(f) {
        if (this._parent) {
            this._parent._walkParent(f);
        }
        f(this);
    }
    /**
     * Parent [[Container]] of this element.
     *
     * @return Parent container
     */
    get parent() {
        return this._parent;
    }
    _setParent(parent, updateChildren = false) {
        const prevParent = this._parent;
        if (parent !== prevParent) {
            this.markDirtyBounds();
            parent.markDirty();
            this._parent = parent;
            if (updateChildren) {
                this._removeParent(prevParent);
                if (parent) {
                    this._addPercentageSizeChildren();
                    this._addPercentagePositionChildren();
                }
            }
            this.markDirtyPosition();
            this._applyThemes();
        }
    }
    /**
     * Returns an instance of [[NumberFormatter]] used in this element.
     *
     * If this element does not have it set, global one form [[Root]] is used.
     *
     * @see {@link https://www.amcharts.com/docs/v5/concepts/using-formatters/} for more info
     * @return NumberFormatter instace
     */
    getNumberFormatter() {
        return this.get("numberFormatter", this._root.numberFormatter);
    }
    /**
     * Returns an instance of [[DateFormatter]] used in this element.
     *
     * If this element does not have it set, global one form [[Root]] is used.
     *
     * @see {@link https://www.amcharts.com/docs/v5/concepts/using-formatters/} for more info
     * @return DateFormatter instace
     */
    getDateFormatter() {
        return this.get("dateFormatter", this._root.dateFormatter);
    }
    /**
     * Returns an instance of [[DurationFormatter]] used in this element.
     *
     * If this element does not have it set, global one form [[Root]] is used.
     *
     * @see {@link https://www.amcharts.com/docs/v5/concepts/using-formatters/} for more info
     * @return DurationFormatter instace
     */
    getDurationFormatter() {
        return this.get("durationFormatter", this._root.durationFormatter);
    }
    /**
     * Converts X/Y coordinate within this element to a global coordinate.
     *
     * @param  point  Local coordinate
     * @return        Global coordinate
     */
    toGlobal(point) {
        return this._display.toGlobal(point);
    }
    /**
     * Converts global X/Y coordinate to a coordinate within this element.
     *
     * @param  point  Global coordinate
     * @return        Local coordinate
     */
    toLocal(point) {
        return this._display.toLocal(point);
    }
    _getDownPoint() {
        const id = this._getDownPointId();
        if (id) {
            return this._downPoints[id];
        }
    }
    _getDownPointId() {
        if (this._downPoints) {
            return _util_Object__WEBPACK_IMPORTED_MODULE_8__.keysOrdered(this._downPoints, (a, b) => {
                if (a > b) {
                    return 1;
                }
                if (a < b) {
                    return -1;
                }
                return 0;
            })[0];
        }
    }
    /**
     * Moves sprite to the end of the parent's children array.
     *
     * Depending on `layout` setting of the parten container, it may effect the
     * positioning or overlapping order of the elements.
     */
    toFront() {
        const parent = this.parent;
        if (parent) {
            parent.children.moveValue(this, parent.children.length - 1);
        }
    }
    /**
     * Moves sprite to the beginning of the parent's children array.
     *
     * Depending on `layout` setting of the parten container, it may effect the
     * positioning or overlapping order of the elements.
     */
    toBack() {
        const parent = this.parent;
        if (parent) {
            parent.children.moveValue(this, 0);
        }
    }
}
Object.defineProperty(Sprite, "className", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: "Sprite"
});
Object.defineProperty(Sprite, "classNames", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: _util_Entity__WEBPACK_IMPORTED_MODULE_3__.Entity.classNames.concat([Sprite.className])
});
//# sourceMappingURL=Sprite.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/core/render/Text.js":
/*!************************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/core/render/Text.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Text: () => (/* binding */ Text)
/* harmony export */ });
/* harmony import */ var _Sprite__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Sprite */ "./node_modules/@amcharts/amcharts5/.internal/core/render/Sprite.js");
/* harmony import */ var _util_PopulateString__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util/PopulateString */ "./node_modules/@amcharts/amcharts5/.internal/core/util/PopulateString.js");
/* harmony import */ var _util_Array__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/Array */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Array.js");
/* harmony import */ var _util_Disposer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/Disposer */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Disposer.js");




/**
 * @ignore Text is an internal class. Use Label instead.
 */
class Text extends _Sprite__WEBPACK_IMPORTED_MODULE_0__.Sprite {
    constructor() {
        super(...arguments);
        Object.defineProperty(this, "textStyle", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: this._root._renderer.makeTextStyle()
        });
        Object.defineProperty(this, "_display", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: this._root._renderer.makeText("", this.textStyle)
        });
        Object.defineProperty(this, "_textStyles", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: [
                "textAlign",
                "fontFamily",
                "fontSize",
                "fontStyle",
                "fontWeight",
                "fontStyle",
                "fontVariant",
                "textDecoration",
                "shadowColor",
                "shadowBlur",
                "shadowOffsetX",
                "shadowOffsetY",
                "shadowOpacity",
                // "leading",
                // "letterSpacing",
                "lineHeight",
                "baselineRatio",
                //"padding",
                // "stroke",
                // "strokeThickness",
                // "trim",
                // "wordWrap",
                "direction",
                "textBaseline",
                "oversizedBehavior",
                "breakWords",
                "ellipsis",
                "minScale"
            ]
        });
        Object.defineProperty(this, "_originalScale", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
    }
    _updateBounds() {
        if (!this.get("text")) {
            let newBounds = {
                left: 0,
                right: 0,
                top: 0,
                bottom: 0,
            };
            this._adjustedLocalBounds = newBounds;
        }
        else {
            super._updateBounds();
        }
    }
    _changed() {
        super._changed();
        this._display.clear();
        let textStyle = this.textStyle;
        if (this.isDirty("opacity")) {
            let opacity = this.get("opacity", 1);
            this._display.alpha = opacity;
        }
        if (this.isDirty("text") || this.isDirty("populateText")) {
            this._display.text = this._getText();
            this.markDirtyBounds();
            if (this.get("role") == "tooltip") {
                this._root.updateTooltip(this);
            }
        }
        if (this.isPrivateDirty("tooltipElement")) {
            const tooltipElement = this.getPrivate("tooltipElement");
            if (tooltipElement) {
                this._disposers.push(new _util_Disposer__WEBPACK_IMPORTED_MODULE_1__.Disposer(() => {
                    this._root._removeTooltipElement(this);
                }));
            }
        }
        if (this.isDirty("width")) {
            textStyle.wordWrapWidth = this.width();
            this.markDirtyBounds();
        }
        if (this.isDirty("oversizedBehavior")) {
            textStyle.oversizedBehavior = this.get("oversizedBehavior", "none");
            this.markDirtyBounds();
        }
        if (this.isDirty("breakWords")) {
            textStyle.breakWords = this.get("breakWords", false);
            this.markDirtyBounds();
        }
        if (this.isDirty("ellipsis")) {
            textStyle.ellipsis = this.get("ellipsis");
            this.markDirtyBounds();
        }
        if (this.isDirty("ignoreFormatting")) {
            textStyle.ignoreFormatting = this.get("ignoreFormatting", false);
            this.markDirtyBounds();
        }
        if (this.isDirty("minScale")) {
            textStyle.minScale = this.get("minScale", 0);
            this.markDirtyBounds();
        }
        if (this.isDirty("fill")) {
            let fill = this.get("fill");
            if (fill) {
                textStyle.fill = fill;
            }
        }
        if (this.isDirty("fillOpacity")) {
            let fillOpacity = this.get("fillOpacity", 1);
            if (fillOpacity) {
                textStyle.fillOpacity = fillOpacity;
            }
        }
        if (this.isDirty("maxWidth") || this.isPrivateDirty("maxWidth")) {
            textStyle.maxWidth = this.get("maxWidth", this.getPrivate("maxWidth"));
            this.markDirtyBounds();
        }
        if (this.isDirty("maxHeight") || this.isPrivateDirty("maxHeight")) {
            textStyle.maxHeight = this.get("maxHeight", this.getPrivate("maxHeight"));
            this.markDirtyBounds();
        }
        _util_Array__WEBPACK_IMPORTED_MODULE_2__.each(this._textStyles, (styleName) => {
            if (this._dirty[styleName]) {
                textStyle[styleName] = this.get(styleName);
                this.markDirtyBounds();
            }
        });
        textStyle["fontSize"] = this.get("fontSize");
        textStyle["fontFamily"] = this.get("fontFamily");
        this._display.style = textStyle;
        if (this.isDirty("role") && this.get("role") == "tooltip") {
            this._root.updateTooltip(this);
        }
    }
    _getText() {
        const text = this.get("text", "");
        return this.get("populateText") ? (0,_util_PopulateString__WEBPACK_IMPORTED_MODULE_3__.populateString)(this, text) : text;
    }
    /**
     * Forces the text to be re-evaluated and re-populated.
     */
    markDirtyText() {
        this._display.text = this._getText();
        if (this.get("role") == "tooltip") {
            this._root.updateTooltip(this);
        }
        this.markDirtyBounds();
        this.markDirty();
    }
    _setDataItem(dataItem) {
        super._setDataItem(dataItem);
        if (this.get("populateText")) {
            this.markDirtyText();
        }
    }
    getNumberFormatter() {
        if (this.parent) {
            return this.parent.getNumberFormatter();
        }
        else {
            return super.getNumberFormatter();
        }
    }
    getDateFormatter() {
        if (this.parent) {
            return this.parent.getDateFormatter();
        }
        else {
            return super.getDateFormatter();
        }
    }
    getDurationFormatter() {
        if (this.parent) {
            return this.parent.getDurationFormatter();
        }
        else {
            return super.getDurationFormatter();
        }
    }
}
Object.defineProperty(Text, "className", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: "Text"
});
Object.defineProperty(Text, "classNames", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: _Sprite__WEBPACK_IMPORTED_MODULE_0__.Sprite.classNames.concat([Text.className])
});
//# sourceMappingURL=Text.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/core/render/Tick.js":
/*!************************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/core/render/Tick.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Tick: () => (/* binding */ Tick)
/* harmony export */ });
/* harmony import */ var _Line__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Line */ "./node_modules/@amcharts/amcharts5/.internal/core/render/Line.js");

/**
 * Draws a tick element (mostly used on axes).
 *
 * @see {@link https://www.amcharts.com/docs/v5/concepts/common-elements/graphics/} for more info
 */
class Tick extends _Line__WEBPACK_IMPORTED_MODULE_0__.Line {
}
Object.defineProperty(Tick, "className", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: "Tick"
});
Object.defineProperty(Tick, "classNames", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: _Line__WEBPACK_IMPORTED_MODULE_0__.Line.classNames.concat([Tick.className])
});
//# sourceMappingURL=Tick.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/core/render/Tooltip.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/core/render/Tooltip.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Tooltip: () => (/* binding */ Tooltip)
/* harmony export */ });
/* harmony import */ var _util_Disposer__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../util/Disposer */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Disposer.js");
/* harmony import */ var _render_Label__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../render/Label */ "./node_modules/@amcharts/amcharts5/.internal/core/render/Label.js");
/* harmony import */ var _render_PointedRectangle__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../render/PointedRectangle */ "./node_modules/@amcharts/amcharts5/.internal/core/render/PointedRectangle.js");
/* harmony import */ var _Container__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Container */ "./node_modules/@amcharts/amcharts5/.internal/core/render/Container.js");
/* harmony import */ var _util_Percent__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../util/Percent */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Percent.js");
/* harmony import */ var _util_Color__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../util/Color */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Color.js");
/* harmony import */ var _util_Math__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../util/Math */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Math.js");
/* harmony import */ var _util_Array__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../util/Array */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Array.js");
/* harmony import */ var _util_Utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/Utils */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Utils.js");









/**
 * Creates a tooltip.
 *
 * @see {@link https://www.amcharts.com/docs/v5/concepts/common-elements/tooltips/} for more info
 * @important
 */
class Tooltip extends _Container__WEBPACK_IMPORTED_MODULE_0__.Container {
    constructor(root, settings, isReal, templates = []) {
        super(root, settings, isReal, templates);
        Object.defineProperty(this, "_fx", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        Object.defineProperty(this, "_fy", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        Object.defineProperty(this, "_label", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_fillDp", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_strokeDp", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_labelDp", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_w", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        Object.defineProperty(this, "_h", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        Object.defineProperty(this, "_keepHoverDp", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_htmlContentHovered", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
    }
    _afterNew() {
        this._settings.themeTags = _util_Utils__WEBPACK_IMPORTED_MODULE_1__.mergeTags(this._settings.themeTags, ["tooltip"]);
        super._afterNew();
        this.set("background", _render_PointedRectangle__WEBPACK_IMPORTED_MODULE_2__.PointedRectangle.new(this._root, {
            themeTags: ["tooltip", "background"]
        }));
        this._label = this.children.push(_render_Label__WEBPACK_IMPORTED_MODULE_3__.Label.new(this._root, {}));
        this._disposers.push(this._label.events.on("boundschanged", () => {
            this._updateBackground();
        }));
        this._disposers.push(this.on("bounds", () => {
            this._updateBackground();
        }));
        this._updateTextColor();
        this._root.tooltipContainer.children.push(this);
        this.hide(0);
        this._disposers.push(this.label.onPrivate("htmlElement", (htmlElement) => {
            if (htmlElement) {
                _util_Utils__WEBPACK_IMPORTED_MODULE_1__.addEventListener(htmlElement, "pointerover", (_ev) => {
                    this._htmlContentHovered = true;
                });
                _util_Utils__WEBPACK_IMPORTED_MODULE_1__.addEventListener(htmlElement, "pointerout", (_ev) => {
                    this._htmlContentHovered = false;
                });
            }
        }));
        this._root._tooltips.push(this);
    }
    /**
     * A [[Label]] element for the tooltip.
     *
     * @readonly
     * @return Label
     */
    get label() {
        return this._label;
    }
    /**
     * Permanently disposes the tooltip.
     */
    dispose() {
        super.dispose();
        _util_Array__WEBPACK_IMPORTED_MODULE_4__.remove(this._root._tooltips, this);
    }
    _updateChildren() {
        super._updateChildren();
        if (this.isDirty("pointerOrientation") || this.isPrivateDirty("minWidth") || this.isPrivateDirty("minHeight")) {
            this.get("background")._markDirtyKey("width");
        }
        const labelText = this.get("labelText");
        if (labelText != null) {
            this.label.set("text", this.get("labelText"));
        }
        const labelHTML = this.get("labelHTML");
        if (labelHTML != null) {
            this.label.set("html", this.get("labelHTML"));
        }
    }
    _changed() {
        super._changed();
        if (this.isDirty("pointTo") || this.isDirty("pointerOrientation")) {
            // can't compare to previous, as sometimes pointTo is set twice (when pointer moves, so the position won't be udpated)
            this._updateBackground();
        }
        if (this.isDirty("tooltipTarget")) {
            this.updateBackgroundColor();
        }
        if (this.isDirty("keepTargetHover")) {
            const keephover = this.get("keepTargetHover");
            if (keephover) {
                const bg = this.get("background");
                this._keepHoverDp = new _util_Disposer__WEBPACK_IMPORTED_MODULE_5__.MultiDisposer([
                    bg.events.on("pointerover", (_ev) => {
                        let target = this.get("tooltipTarget");
                        if (target) {
                            if (target.parent && target.parent.getPrivate("tooltipTarget") == target) {
                                target = target.parent;
                            }
                            target.hover();
                        }
                    }),
                    bg.events.on("pointerout", (_ev) => {
                        let target = this.get("tooltipTarget");
                        if (target) {
                            if (target.parent && target.parent.getPrivate("tooltipTarget") == target) {
                                target = target.parent;
                            }
                            if (!this._htmlContentHovered) {
                                target.unhover();
                            }
                        }
                    })
                ]);
                this.label.onPrivate("htmlElement", (htmlElement) => {
                    if (this._keepHoverDp && htmlElement) {
                        this._keepHoverDp.disposers.push(_util_Utils__WEBPACK_IMPORTED_MODULE_1__.addEventListener(htmlElement, "pointerleave", (ev) => {
                            const outEvent = this.root._renderer.getEvent(ev);
                            bg.events.dispatch("pointerout", {
                                type: "pointerout",
                                originalEvent: outEvent.event,
                                point: outEvent.point,
                                simulated: false,
                                target: bg
                            });
                        }));
                    }
                });
            }
            else {
                if (this._keepHoverDp) {
                    this._keepHoverDp.dispose();
                    this._keepHoverDp = undefined;
                }
            }
        }
    }
    _onShow() {
        super._onShow();
        this.updateBackgroundColor();
    }
    updateBackgroundColor() {
        let tooltipTarget = this.get("tooltipTarget");
        const background = this.get("background");
        let fill;
        let stroke;
        if (tooltipTarget && background) {
            fill = tooltipTarget.get("fill");
            stroke = tooltipTarget.get("stroke");
            if (fill == null) {
                fill = stroke;
            }
            if (this.get("getFillFromSprite")) {
                if (this._fillDp) {
                    this._fillDp.dispose();
                }
                if (fill != null) {
                    background.set("fill", fill);
                }
                this._fillDp = tooltipTarget.on("fill", (fill) => {
                    if (fill != null) {
                        background.set("fill", fill);
                        this._updateTextColor(fill);
                    }
                });
                this._disposers.push(this._fillDp);
            }
            if (this.get("getStrokeFromSprite")) {
                if (this._strokeDp) {
                    this._strokeDp.dispose();
                }
                if (fill != null) {
                    background.set("stroke", fill);
                }
                this._strokeDp = tooltipTarget.on("fill", (fill) => {
                    if (fill != null) {
                        background.set("stroke", fill);
                    }
                });
                this._disposers.push(this._strokeDp);
            }
            if (this.get("getLabelFillFromSprite")) {
                if (this._labelDp) {
                    this._labelDp.dispose();
                }
                if (fill != null) {
                    this.label.set("fill", fill);
                }
                this._labelDp = tooltipTarget.on("fill", (fill) => {
                    if (fill != null) {
                        this.label.set("fill", fill);
                    }
                });
                this._disposers.push(this._labelDp);
            }
        }
        this._updateTextColor(fill);
    }
    _updateTextColor(fill) {
        if (this.get("autoTextColor")) {
            if (fill == null) {
                fill = this.get("background").get("fill");
            }
            if (fill == null) {
                fill = this._root.interfaceColors.get("background");
            }
            if (fill instanceof _util_Color__WEBPACK_IMPORTED_MODULE_6__.Color) {
                this.label.set("fill", _util_Color__WEBPACK_IMPORTED_MODULE_6__.Color.alternative(fill, this._root.interfaceColors.get("alternativeText"), this._root.interfaceColors.get("text")));
            }
        }
    }
    _setDataItem(dataItem) {
        super._setDataItem(dataItem);
        this.label._setDataItem(dataItem);
    }
    _updateBackground() {
        super.updateBackground();
        const parent = this._root.container;
        if (parent) {
            let cw = 0.5;
            let ch = 0.5;
            let centerX = this.get("centerX");
            if (centerX instanceof _util_Percent__WEBPACK_IMPORTED_MODULE_7__.Percent) {
                cw = centerX.value;
            }
            let centerY = this.get("centerY");
            if (centerY instanceof _util_Percent__WEBPACK_IMPORTED_MODULE_7__.Percent) {
                ch = centerY.value;
            }
            let parentW = parent.width();
            let parentH = parent.height();
            let tooltipContainer = this.parent;
            let xx = 0;
            let yy = 0;
            if (tooltipContainer) {
                xx = tooltipContainer.x();
                yy = tooltipContainer.y();
                const layerMargin = tooltipContainer.get("layerMargin");
                if (layerMargin) {
                    xx += layerMargin.left || 0;
                    yy += layerMargin.top || 0;
                    parentW += (layerMargin.left || 0) + (layerMargin.right || 0);
                    parentH += (layerMargin.top || 0) + (layerMargin.bottom || 0);
                }
            }
            const bounds = this.get("bounds", { left: -xx, top: -yy, right: parentW - xx, bottom: parentH - yy });
            this._updateBounds();
            let w = this.width();
            let h = this.height();
            // use old w and h,as when tooltip is hidden, these are 0 and unneeded animation happens
            if (w === 0) {
                w = this._w;
            }
            if (h === 0) {
                h = this._h;
            }
            let pointTo = this.get("pointTo", { x: parentW / 2, y: parentH / 2 });
            let x = pointTo.x;
            let y = pointTo.y;
            let pointerOrientation = this.get("pointerOrientation");
            let background = this.get("background");
            let pointerLength = 0;
            let bgStrokeSizeY = 0;
            let bgStrokeSizeX = 0;
            if (background instanceof _render_PointedRectangle__WEBPACK_IMPORTED_MODULE_2__.PointedRectangle) {
                pointerLength = background.get("pointerLength", 0);
                bgStrokeSizeY = background.get("strokeWidth", 0) / 2;
                bgStrokeSizeX = bgStrokeSizeY;
                background.set("width", w);
                background.set("height", h);
            }
            let pointerX = 0;
            let pointerY = 0;
            let boundsW = bounds.right - bounds.left;
            let boundsH = bounds.bottom - bounds.top;
            // horizontal
            if (pointerOrientation == "horizontal" || pointerOrientation == "left" || pointerOrientation == "right") {
                bgStrokeSizeY = 0;
                if (pointerOrientation == "horizontal") {
                    if (x > bounds.left + boundsW / 2) {
                        x -= (w * (1 - cw) + pointerLength);
                        bgStrokeSizeX *= -1;
                    }
                    else {
                        x += (w * cw + pointerLength);
                    }
                }
                else if (pointerOrientation == "left") {
                    x += (w * (1 - cw) + pointerLength);
                }
                else {
                    x -= (w * cw + pointerLength);
                    bgStrokeSizeX *= -1;
                }
            }
            // vertical pointer
            else {
                bgStrokeSizeX = 0;
                if (pointerOrientation == "vertical") {
                    if (y > bounds.top + h / 2 + pointerLength) {
                        y -= (h * (1 - ch) + pointerLength);
                    }
                    else {
                        y += (h * ch + pointerLength);
                        bgStrokeSizeY *= -1;
                    }
                }
                else if (pointerOrientation == "down") {
                    y -= (h * (1 - ch) + pointerLength);
                }
                else {
                    y += (h * ch + pointerLength);
                    bgStrokeSizeY *= -1;
                }
            }
            x = _util_Math__WEBPACK_IMPORTED_MODULE_8__.fitToRange(x, bounds.left + w * cw, bounds.left + boundsW - w * (1 - cw)) + bgStrokeSizeX;
            y = _util_Math__WEBPACK_IMPORTED_MODULE_8__.fitToRange(y, bounds.top + h * ch, bounds.top + boundsH - h * (1 - ch)) - bgStrokeSizeY;
            pointerX = pointTo.x - x + w * cw + bgStrokeSizeX;
            pointerY = pointTo.y - y + h * ch - bgStrokeSizeY;
            this._fx = x;
            this._fy = y;
            const animationDuration = this.get("animationDuration", 0);
            if (animationDuration > 0 && this.get("visible") && this.get("opacity") > 0.1) {
                const animationEasing = this.get("animationEasing");
                this.animate({ key: "x", to: x, duration: animationDuration, easing: animationEasing });
                this.animate({ key: "y", to: y, duration: animationDuration, easing: animationEasing });
            }
            else {
                this.set("x", x);
                this.set("y", y);
            }
            if (background instanceof _render_PointedRectangle__WEBPACK_IMPORTED_MODULE_2__.PointedRectangle) {
                background.set("pointerX", pointerX);
                background.set("pointerY", pointerY);
            }
            if (w > 0) {
                this._w = w;
            }
            if (h > 0) {
                this._h = h;
            }
        }
    }
}
Object.defineProperty(Tooltip, "className", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: "Tooltip"
});
Object.defineProperty(Tooltip, "classNames", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: _Container__WEBPACK_IMPORTED_MODULE_0__.Container.classNames.concat([Tooltip.className])
});
//# sourceMappingURL=Tooltip.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/core/render/Triangle.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/core/render/Triangle.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Triangle: () => (/* binding */ Triangle)
/* harmony export */ });
/* harmony import */ var _Graphics__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Graphics */ "./node_modules/@amcharts/amcharts5/.internal/core/render/Graphics.js");

/**
 * Draws a triangle.
 *
 * @see {@link https://www.amcharts.com/docs/v5/concepts/common-elements/graphics/} for more info
 * @important
 */
class Triangle extends _Graphics__WEBPACK_IMPORTED_MODULE_0__.Graphics {
    _beforeChanged() {
        super._beforeChanged();
        if (this.isDirty("width") || this.isDirty("height") || this.isPrivateDirty("width") || this.isPrivateDirty("height")) {
            this._clear = true;
        }
    }
    _changed() {
        super._changed();
        if (this._clear && !this.get("draw")) {
            this._draw();
        }
    }
    _draw() {
        const w = this.width();
        const h = this.height();
        const display = this._display;
        display.moveTo(-w / 2, h / 2);
        display.lineTo(0, -h / 2);
        display.lineTo(w / 2, h / 2);
        display.lineTo(-w / 2, h / 2);
        display.closePath();
    }
    _updateSize() {
        this.markDirty();
        this._clear = true;
    }
}
Object.defineProperty(Triangle, "className", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: "Triangle"
});
Object.defineProperty(Triangle, "classNames", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: _Graphics__WEBPACK_IMPORTED_MODULE_0__.Graphics.classNames.concat([Triangle.className])
});
//# sourceMappingURL=Triangle.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/core/render/VerticalLayout.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/core/render/VerticalLayout.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   VerticalLayout: () => (/* binding */ VerticalLayout)
/* harmony export */ });
/* harmony import */ var _Layout__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Layout */ "./node_modules/@amcharts/amcharts5/.internal/core/render/Layout.js");
/* harmony import */ var _util_Type__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/Type */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Type.js");
/* harmony import */ var _util_Percent__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/Percent */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Percent.js");



/**
 * A vertical children layout for [[Container]].
 *
 * @see {@link https://www.amcharts.com/docs/v5/concepts/common-elements/containers/#Layout} for more info
 */
class VerticalLayout extends _Layout__WEBPACK_IMPORTED_MODULE_0__.Layout {
    /**
     * @ignore
     */
    updateContainer(container) {
        let paddingTop = container.get("paddingTop", 0);
        let availableHeight = container.innerHeight();
        let totalPercent = 0;
        (0,_Layout__WEBPACK_IMPORTED_MODULE_0__.eachChildren)(container, (child) => {
            if (child.isVisible()) {
                if (child.get("position") == "relative") {
                    let childHeight = child.get("height");
                    if (childHeight instanceof _util_Percent__WEBPACK_IMPORTED_MODULE_1__.Percent) {
                        totalPercent += childHeight.value;
                        let h = availableHeight * childHeight.value;
                        let minHeight = child.get("minHeight", child.getPrivate("minHeight", -Infinity));
                        if (minHeight > h) {
                            availableHeight -= minHeight;
                            totalPercent -= childHeight.value;
                        }
                        let maxHeight = child.get("maxHeight", child.getPrivate("maxHeight", Infinity));
                        if (h > maxHeight) {
                            availableHeight -= maxHeight;
                            totalPercent -= childHeight.value;
                        }
                    }
                    else {
                        if (!_util_Type__WEBPACK_IMPORTED_MODULE_2__.isNumber(childHeight)) {
                            childHeight = child.height();
                        }
                        availableHeight -= childHeight + child.get("marginTop", 0) + child.get("marginBottom", 0);
                    }
                }
            }
        });
        if (availableHeight <= 0 || availableHeight == Infinity) {
            availableHeight = .1;
        }
        //if (availableHeight > 0) {
        (0,_Layout__WEBPACK_IMPORTED_MODULE_0__.eachChildren)(container, (child) => {
            if (child.isVisible()) {
                if (child.get("position") == "relative") {
                    let childHeight = child.get("height");
                    if (childHeight instanceof _util_Percent__WEBPACK_IMPORTED_MODULE_1__.Percent) {
                        let privateHeight = availableHeight * childHeight.value / totalPercent - child.get("marginTop", 0) - child.get("marginBottom", 0);
                        let minHeight = child.get("minHeight", child.getPrivate("minHeight", -Infinity));
                        let maxHeight = child.get("maxHeight", child.getPrivate("maxHeight", Infinity));
                        privateHeight = Math.min(Math.max(minHeight, privateHeight), maxHeight);
                        child.setPrivate("height", privateHeight);
                    }
                    else {
                        if (child._prevSettings.height instanceof _util_Percent__WEBPACK_IMPORTED_MODULE_1__.Percent) {
                            child.setPrivate("height", undefined);
                        }
                    }
                }
            }
        });
        //}
        let prevY = paddingTop;
        (0,_Layout__WEBPACK_IMPORTED_MODULE_0__.eachChildren)(container, (child) => {
            if (child.get("position") == "relative") {
                if (child.isVisible()) {
                    let bounds = child.adjustedLocalBounds();
                    let marginTop = child.get("marginTop", 0);
                    let top = bounds.top;
                    let bottom = bounds.bottom;
                    let maxHeight = child.get("maxHeight");
                    if (maxHeight) {
                        if (bottom - top > maxHeight) {
                            bottom = top + maxHeight;
                        }
                    }
                    let marginBottom = child.get("marginBottom", 0);
                    let y = prevY + marginTop - top;
                    child.setPrivate("y", y);
                    prevY = y + bottom + marginBottom;
                }
                else {
                    child.setPrivate("y", undefined);
                }
            }
        });
    }
}
Object.defineProperty(VerticalLayout, "className", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: "VerticalLayout"
});
Object.defineProperty(VerticalLayout, "classNames", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: _Layout__WEBPACK_IMPORTED_MODULE_0__.Layout.classNames.concat([VerticalLayout.className])
});
//# sourceMappingURL=VerticalLayout.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/core/render/backend/CanvasRenderer.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/core/render/backend/CanvasRenderer.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CanvasContainer: () => (/* binding */ CanvasContainer),
/* harmony export */   CanvasDisplayObject: () => (/* binding */ CanvasDisplayObject),
/* harmony export */   CanvasGraphics: () => (/* binding */ CanvasGraphics),
/* harmony export */   CanvasImage: () => (/* binding */ CanvasImage),
/* harmony export */   CanvasLayer: () => (/* binding */ CanvasLayer),
/* harmony export */   CanvasPivot: () => (/* binding */ CanvasPivot),
/* harmony export */   CanvasRadialText: () => (/* binding */ CanvasRadialText),
/* harmony export */   CanvasRenderer: () => (/* binding */ CanvasRenderer),
/* harmony export */   CanvasRendererEvent: () => (/* binding */ CanvasRendererEvent),
/* harmony export */   CanvasText: () => (/* binding */ CanvasText),
/* harmony export */   CanvasTextStyle: () => (/* binding */ CanvasTextStyle)
/* harmony export */ });
/* harmony import */ var _Renderer__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Renderer */ "./node_modules/@amcharts/amcharts5/.internal/core/render/backend/Renderer.js");
/* harmony import */ var _util_Color__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../util/Color */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Color.js");
/* harmony import */ var _util_Matrix__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../util/Matrix */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Matrix.js");
/* harmony import */ var _util_Percent__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../util/Percent */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Percent.js");
/* harmony import */ var _util_Disposer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../util/Disposer */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Disposer.js");
/* harmony import */ var _util_TextFormatter__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../util/TextFormatter */ "./node_modules/@amcharts/amcharts5/.internal/core/util/TextFormatter.js");
/* harmony import */ var _util_Utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/Utils */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Utils.js");
/* harmony import */ var _util_Array__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util/Array */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Array.js");
/* harmony import */ var _util_Object__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../util/Object */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Object.js");
/* harmony import */ var _util_Type__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../util/Type */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Type.js");
/* harmony import */ var _util_Math__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../util/Math */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Math.js");
/* harmony import */ var svg_arc_to_cubic_bezier__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! svg-arc-to-cubic-bezier */ "./node_modules/svg-arc-to-cubic-bezier/modules/index.js");
/** @ignore */ /** */




//import { Throttler } from "../../util/Throttler";








/**
 * @ignore
 */
function checkArgs(name, actual, expected) {
    if (actual !== expected) {
        throw new Error("Required " + expected + " arguments for " + name + " but got " + actual);
    }
}
/**
 * @ignore
 */
function checkMinArgs(name, actual, expected) {
    if (actual < expected) {
        throw new Error("Required at least " + expected + " arguments for " + name + " but got " + actual);
    }
}
/**
 * @ignore
 */
function checkEvenArgs(name, actual, expected) {
    checkMinArgs(name, actual, expected);
    if ((actual % expected) !== 0) {
        throw new Error("Arguments for " + name + " must be in pairs of " + expected);
    }
}
/**
 * @ignore
 * This splits the flag so that way 0017 will be processed as 0 0 17
 *
 * This is important for weird paths like `M17 5A1 1 0 0017 30 1 1 0 0017 5`
 */
function splitArcFlags(args) {
    for (let i = 0; i < args.length; i += 7) {
        let index = i + 3;
        let flag = args[index];
        if (flag.length > 1) {
            const a = /^([01])([01])(.*)$/.exec(flag);
            if (a !== null) {
                args.splice(index, 0, a[1]);
                ++index;
                args.splice(index, 0, a[2]);
                ++index;
                if (a[3].length > 0) {
                    args[index] = a[3];
                }
                else {
                    args.splice(index, 1);
                }
            }
        }
        ++index;
        flag = args[index];
        if (flag.length > 1) {
            const a = /^([01])(.+)$/.exec(flag);
            if (a !== null) {
                args.splice(index, 0, a[1]);
                ++index;
                args[index] = a[2];
            }
        }
    }
}
/**
 * @ignore
 */
function assertBinary(value) {
    if (value === 0 || value === 1) {
        return value;
    }
    else {
        throw new Error("Flag must be 0 or 1");
    }
}
//  1 -> 0xffffff * (2 / 2)
//  2 -> 0xffffff * (1 / 2)
//
//  3 -> 0xffffff * (3 / 4)
//  4 -> 0xffffff * (1 / 4)
//
//  5 -> 0xffffff * (7 / 8)
//  6 -> 0xffffff * (5 / 8)
//  7 -> 0xffffff * (3 / 8)
//  8 -> 0xffffff * (1 / 8)
//
//  9 -> 0xffffff * (15 / 16)
// 10 -> 0xffffff * (13 / 16)
// 11 -> 0xffffff * (11 / 16)
// 12 -> 0xffffff *  (9 / 16)
// 13 -> 0xffffff *  (7 / 16)
// 14 -> 0xffffff *  (5 / 16)
// 15 -> 0xffffff *  (3 / 16)
// 16 -> 0xffffff *  (1 / 16)
// @todo remove this old color distribution algo if the new one pans out
/*function distributeId(id: number): number {
    if (id === 1) {
        return 0x000001;

    } else {
        // Finds the closest power of 2
        const base = Math.pow(2, Math.ceil(Math.log(id) / Math.log(2)));

        // Translates the id into an odd fraction index
        const index = ((base - id) * 2) + 1;

        // TODO is Math.round correct ?
        return Math.round(0xffffff * (index / base));
    }
}*/
/**
 * Function by smeans:
 * https://lowcode.life/generating-unique-contrasting-colors-in-javascript/
 * @ignore
 */
function distributeId(id) {
    const rgb = [0, 0, 0];
    for (let i = 0; i < 24; i++) {
        rgb[i % 3] <<= 1;
        rgb[i % 3] |= id & 0x01;
        id >>= 1;
    }
    return (rgb[0] | 0) + (rgb[1] << 8) + (rgb[2] << 16);
}
/**
 * @ignore
 */
function eachTargets(hitTarget, f) {
    for (;;) {
        if (hitTarget.interactive) {
            if (!f(hitTarget)) {
                break;
            }
        }
        if (hitTarget._parent) {
            hitTarget = hitTarget._parent;
        }
        else {
            break;
        }
    }
}
// TODO feature detection for mouse/touch/pointer
/**
 * @ignore
 */
function onPointerEvent(element, name, f) {
    return _util_Utils__WEBPACK_IMPORTED_MODULE_1__.addEventListener(element, _util_Utils__WEBPACK_IMPORTED_MODULE_1__.getRendererEvent(name), (event) => {
        const target = _util_Utils__WEBPACK_IMPORTED_MODULE_1__.getEventTarget(event);
        let touches = event.touches;
        if (touches) {
            if (touches.length == 0) {
                touches = event.changedTouches;
            }
            f(_util_Array__WEBPACK_IMPORTED_MODULE_2__.copy(touches), target);
        }
        else {
            f([event], target);
        }
    });
}
/**
 * @ignore
 */
function isTainted(image) {
    const canvas = document.createElement("canvas");
    canvas.width = 1;
    canvas.height = 1;
    const context = canvas.getContext("2d", { willReadFrequently: true });
    context.drawImage(image, 0, 0, 1, 1);
    try {
        context.getImageData(0, 0, 1, 1);
        return false;
    }
    catch (err) {
        console.warn("Image \"" + image.src + "\" is loaded from different host and is not covered by CORS policy. For more information about the implications read here: https://www.amcharts.com/docs/v5/concepts/cors");
        return true;
    }
}
/**
 * This is needed to workaround a bug in iOS which causes it to not GC canvas elements.
 *
 * @ignore
 */
function clearCanvas(view) {
    view.width = 0;
    view.height = 0;
    view.style.width = "0px";
    view.style.height = "0px";
}
/**
 * Aligns the coordinate to the pixel, so it renders crisp
 *
 * @ignore
 */
function crisp(x) {
    return Math.floor(x) + .5;
}
/**
 * @ignore
 */
class CanvasPivot {
    constructor() {
        Object.defineProperty(this, "_x", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        Object.defineProperty(this, "_y", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
    }
    get x() {
        return this._x;
    }
    get y() {
        return this._y;
    }
    set x(value) {
        this._x = value;
    }
    set y(value) {
        this._y = value;
    }
}
/**
 * @ignore
 */
class CanvasDisplayObject extends _util_Disposer__WEBPACK_IMPORTED_MODULE_3__.DisposerClass {
    constructor(renderer) {
        super();
        Object.defineProperty(this, "_layer", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "mask", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: null
        });
        Object.defineProperty(this, "visible", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: true
        });
        Object.defineProperty(this, "exportable", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: true
        });
        Object.defineProperty(this, "interactive", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        Object.defineProperty(this, "inactive", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: null
        });
        Object.defineProperty(this, "wheelable", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        Object.defineProperty(this, "cancelTouch", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        Object.defineProperty(this, "isMeasured", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        Object.defineProperty(this, "buttonMode", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        Object.defineProperty(this, "alpha", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 1
        });
        Object.defineProperty(this, "compoundAlpha", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 1
        });
        Object.defineProperty(this, "angle", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        Object.defineProperty(this, "scale", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 1
        });
        Object.defineProperty(this, "x", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        Object.defineProperty(this, "y", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        Object.defineProperty(this, "crisp", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        Object.defineProperty(this, "pivot", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new CanvasPivot()
        });
        Object.defineProperty(this, "filter", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "cursorOverStyle", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_replacedCursorStyle", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_localMatrix", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new _util_Matrix__WEBPACK_IMPORTED_MODULE_4__.Matrix()
        });
        Object.defineProperty(this, "_matrix", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new _util_Matrix__WEBPACK_IMPORTED_MODULE_4__.Matrix()
        });
        // TODO can this be replaced with _localMatrix ?
        Object.defineProperty(this, "_uMatrix", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new _util_Matrix__WEBPACK_IMPORTED_MODULE_4__.Matrix()
        });
        Object.defineProperty(this, "_renderer", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_parent", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_localBounds", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_bounds", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_colorId", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this._renderer = renderer;
    }
    subStatus(status) {
        return {
            inactive: (this.inactive == null ? status.inactive : this.inactive),
            layer: this._layer || status.layer,
        };
    }
    _dispose() {
        this._renderer._removeObject(this);
        this.getLayer().dirty = true;
    }
    getCanvas() {
        return this.getLayer().view;
    }
    getLayer() {
        let self = this;
        for (;;) {
            if (self._layer) {
                return self._layer;
            }
            else if (self._parent) {
                self = self._parent;
            }
            else {
                return this._renderer.defaultLayer;
            }
        }
    }
    setLayer(order, margin) {
        if (order == null) {
            this._layer = undefined;
        }
        else {
            const visible = true;
            this._layer = this._renderer.getLayer(order, visible);
            this._layer.visible = visible;
            this._layer.margin = margin;
            if (margin) {
                _util_Utils__WEBPACK_IMPORTED_MODULE_1__.setInteractive(this._layer.view, false);
            }
            this._renderer._ghostLayer.setMargin(this._renderer.layers);
            if (this._parent) {
                this._parent.registerChildLayer(this._layer);
            }
            this._layer.dirty = true;
            this._renderer.resizeLayer(this._layer);
            this._renderer.resizeGhost();
        }
    }
    markDirtyLayer() {
        this.getLayer().dirty = true;
    }
    clear() {
        this.invalidateBounds();
    }
    invalidateBounds() {
        this._localBounds = undefined;
    }
    _addBounds(_bounds) { }
    _getColorId() {
        if (this._colorId === undefined) {
            this._colorId = this._renderer.paintId(this);
        }
        return this._colorId;
    }
    _isInteractive(status) {
        return !status.inactive && (this.interactive || this._renderer._forceInteractive > 0);
    }
    _isInteractiveMask(status) {
        return this._isInteractive(status);
    }
    contains(child) {
        for (;;) {
            if (child === this) {
                return true;
            }
            else if (child._parent) {
                child = child._parent;
            }
            else {
                return false;
            }
        }
    }
    toGlobal(point) {
        return this._matrix.apply(point);
    }
    toLocal(point) {
        return this._matrix.applyInverse(point);
    }
    getLocalMatrix() {
        this._uMatrix.setTransform(0, 0, this.pivot.x, this.pivot.y, this.angle * Math.PI / 180, this.scale);
        return this._uMatrix;
    }
    getLocalBounds() {
        if (!this._localBounds) {
            const bn = 10000000;
            this._localBounds = {
                left: bn,
                top: bn,
                right: -bn,
                bottom: -bn
            };
            this._addBounds(this._localBounds);
        }
        return this._localBounds;
    }
    getAdjustedBounds(bounds) {
        this._setMatrix();
        const matrix = this.getLocalMatrix();
        const p0 = matrix.apply({ x: bounds.left, y: bounds.top });
        const p1 = matrix.apply({ x: bounds.right, y: bounds.top });
        const p2 = matrix.apply({ x: bounds.right, y: bounds.bottom });
        const p3 = matrix.apply({ x: bounds.left, y: bounds.bottom });
        return {
            left: Math.min(p0.x, p1.x, p2.x, p3.x),
            top: Math.min(p0.y, p1.y, p2.y, p3.y),
            right: Math.max(p0.x, p1.x, p2.x, p3.x),
            bottom: Math.max(p0.y, p1.y, p2.y, p3.y)
        };
    }
    on(key, callback, context) {
        if (this.interactive) {
            return this._renderer._addEvent(this, key, callback, context);
        }
        else {
            return new _util_Disposer__WEBPACK_IMPORTED_MODULE_3__.Disposer(() => { });
        }
    }
    _setMatrix() {
        // TODO only calculate this if it has actually changed
        this._localMatrix.setTransform(this.x, this.y, this.pivot.x, this.pivot.y, 
        // Converts degrees to radians
        this.angle * Math.PI / 180, this.scale);
        this._matrix.copyFrom(this._localMatrix);
        if (this._parent) {
            // TODO only calculate this if it has actually changed
            this._matrix.prepend(this._parent._matrix);
        }
    }
    _transform(context, resolution) {
        const m = this._matrix;
        let tx = m.tx * resolution;
        let ty = m.ty * resolution;
        if (this.crisp) {
            tx = crisp(tx);
            ty = crisp(ty);
        }
        context.setTransform(m.a * resolution, m.b * resolution, m.c * resolution, m.d * resolution, tx, ty);
    }
    _transformMargin(context, resolution, margin) {
        const m = this._matrix;
        context.setTransform(m.a * resolution, m.b * resolution, m.c * resolution, m.d * resolution, (m.tx + margin.left) * resolution, (m.ty + margin.top) * resolution);
    }
    _transformLayer(context, resolution, layer) {
        if (layer.margin) {
            this._transformMargin(context, layer.scale || resolution, layer.margin);
        }
        else {
            this._transform(context, layer.scale || resolution);
        }
    }
    render(status) {
        if (this.visible && (this.exportable !== false || !this._renderer._omitTainted)) {
            this._setMatrix();
            const subStatus = this.subStatus(status);
            const resolution = this._renderer.resolution;
            const layers = this._renderer.layers;
            const ghostLayer = this._renderer._ghostLayer;
            const ghostContext = ghostLayer.context;
            const mask = this.mask;
            if (mask) {
                mask._setMatrix();
            }
            // TODO improve this
            _util_Array__WEBPACK_IMPORTED_MODULE_2__.each(layers, (layer) => {
                if (layer) {
                    const context = layer.context;
                    context.save();
                    // We must apply the mask before we transform the element
                    if (mask) {
                        mask._transformLayer(context, resolution, layer);
                        mask._runPath(context);
                        context.clip();
                    }
                    context.globalAlpha = this.compoundAlpha * this.alpha;
                    this._transformLayer(context, resolution, layer);
                    if (this.filter) {
                        context.filter = this.filter;
                    }
                }
            });
            ghostContext.save();
            // We must apply the mask before we transform the element
            if (mask && this._isInteractiveMask(subStatus)) {
                mask._transformMargin(ghostContext, resolution, ghostLayer.margin);
                mask._runPath(ghostContext);
                ghostContext.clip();
            }
            this._transformMargin(ghostContext, resolution, ghostLayer.margin);
            this._render(subStatus);
            ghostContext.restore();
            _util_Array__WEBPACK_IMPORTED_MODULE_2__.each(layers, (layer) => {
                if (layer) {
                    layer.context.restore();
                }
            });
        }
    }
    _render(status) {
        if (this.exportable === false) {
            status.layer.tainted = true;
        }
    }
    hovering() {
        return this._renderer._hovering.has(this);
    }
    dragging() {
        return this._renderer._dragging.some((x) => x.value === this);
    }
    shouldCancelTouch() {
        const renderer = this._renderer;
        if (renderer.tapToActivate && !renderer._touchActive) {
            return false;
        }
        if (this.cancelTouch) {
            return true;
        }
        else if (this._parent) {
            return this._parent.shouldCancelTouch();
        }
        return false;
    }
}
/**
 * @ignore
 */
class CanvasContainer extends CanvasDisplayObject {
    constructor() {
        super(...arguments);
        Object.defineProperty(this, "interactiveChildren", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: true
        });
        Object.defineProperty(this, "_childLayers", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_children", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
        });
    }
    _isInteractiveMask(status) {
        return this.interactiveChildren || super._isInteractiveMask(status);
    }
    addChild(child) {
        child._parent = this;
        this._children.push(child);
        if (child._layer) {
            this.registerChildLayer(child._layer);
        }
    }
    addChildAt(child, index) {
        child._parent = this;
        this._children.splice(index, 0, child);
        if (child._layer) {
            this.registerChildLayer(child._layer);
        }
    }
    removeChild(child) {
        child._parent = undefined;
        _util_Array__WEBPACK_IMPORTED_MODULE_2__.removeFirst(this._children, child);
    }
    _render(status) {
        super._render(status);
        const renderer = this._renderer;
        if (this.interactive && this.interactiveChildren) {
            ++renderer._forceInteractive;
        }
        _util_Array__WEBPACK_IMPORTED_MODULE_2__.each(this._children, (child) => {
            child.compoundAlpha = this.compoundAlpha * this.alpha;
            child.render(status);
        });
        if (this.interactive && this.interactiveChildren) {
            --renderer._forceInteractive;
        }
    }
    registerChildLayer(layer) {
        if (!this._childLayers) {
            this._childLayers = [];
        }
        _util_Array__WEBPACK_IMPORTED_MODULE_2__.pushOne(this._childLayers, layer);
        if (this._parent) {
            this._parent.registerChildLayer(layer);
        }
    }
    markDirtyLayer(deep = false) {
        super.markDirtyLayer();
        if (deep && this._childLayers) {
            _util_Array__WEBPACK_IMPORTED_MODULE_2__.each(this._childLayers, (layer) => layer.dirty = true);
        }
    }
    _dispose() {
        super._dispose();
        if (this._childLayers) {
            _util_Array__WEBPACK_IMPORTED_MODULE_2__.each(this._childLayers, (layer) => {
                layer.dirty = true;
            });
        }
    }
}
/**
 * @ignore
 */
function setPoint(bounds, point) {
    bounds.left = Math.min(bounds.left, point.x);
    bounds.top = Math.min(bounds.top, point.y);
    bounds.right = Math.max(bounds.right, point.x);
    bounds.bottom = Math.max(bounds.bottom, point.y);
}
/**
 * @ignore
 */
class Op {
    colorize(_context, _forceColor) { }
    path(_context) { }
    addBounds(_bounds) { }
}
/**
 * @ignore
 */
class BeginPath extends Op {
    colorize(context, _forceColor) {
        context.beginPath();
    }
}
/**
 * @ignore
 */
class BeginFill extends Op {
    constructor(color) {
        super();
        Object.defineProperty(this, "color", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: color
        });
    }
    colorize(context, forceColor) {
        if (forceColor !== undefined) {
            context.fillStyle = forceColor;
        }
        else {
            context.fillStyle = this.color;
        }
    }
}
/**
 * @ignore
 */
class EndFill extends Op {
    constructor(clearShadow) {
        super();
        Object.defineProperty(this, "clearShadow", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: clearShadow
        });
    }
    colorize(context, _forceColor) {
        context.fill();
        if (this.clearShadow) {
            context.shadowColor = "";
            context.shadowBlur = 0;
            context.shadowOffsetX = 0;
            context.shadowOffsetY = 0;
        }
    }
}
/**
 * @ignore
 */
class EndStroke extends Op {
    colorize(context, _forceColor) {
        context.stroke();
    }
}
/**
 * @ignore
 */
class LineStyle extends Op {
    constructor(width, color, lineJoin) {
        super();
        Object.defineProperty(this, "width", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: width
        });
        Object.defineProperty(this, "color", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: color
        });
        Object.defineProperty(this, "lineJoin", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: lineJoin
        });
    }
    colorize(context, forceColor) {
        if (forceColor !== undefined) {
            context.strokeStyle = forceColor;
        }
        else {
            context.strokeStyle = this.color;
        }
        context.lineWidth = this.width;
        if (this.lineJoin) {
            context.lineJoin = this.lineJoin;
        }
    }
}
/**
 * @ignore
 */
class LineDash extends Op {
    constructor(dash) {
        super();
        Object.defineProperty(this, "dash", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: dash
        });
    }
    colorize(context, _forceColor) {
        context.setLineDash(this.dash);
    }
}
/**
 * @ignore
 */
class LineDashOffset extends Op {
    constructor(dashOffset) {
        super();
        Object.defineProperty(this, "dashOffset", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: dashOffset
        });
    }
    colorize(context, _forceColor) {
        context.lineDashOffset = this.dashOffset;
    }
}
/**
 * @ignore
 */
class DrawRect extends Op {
    constructor(x, y, width, height) {
        super();
        Object.defineProperty(this, "x", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: x
        });
        Object.defineProperty(this, "y", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: y
        });
        Object.defineProperty(this, "width", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: width
        });
        Object.defineProperty(this, "height", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: height
        });
    }
    path(context) {
        context.rect(this.x, this.y, this.width, this.height);
    }
    addBounds(bounds) {
        const l = this.x;
        const t = this.y;
        const r = l + this.width;
        const b = t + this.height;
        setPoint(bounds, { x: l, y: t });
        setPoint(bounds, { x: r, y: t });
        setPoint(bounds, { x: l, y: b });
        setPoint(bounds, { x: r, y: b });
    }
}
/**
 * @ignore
 */
class DrawCircle extends Op {
    constructor(x, y, radius) {
        super();
        Object.defineProperty(this, "x", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: x
        });
        Object.defineProperty(this, "y", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: y
        });
        Object.defineProperty(this, "radius", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: radius
        });
    }
    path(context) {
        context.moveTo(this.x + this.radius, this.y);
        context.arc(this.x, this.y, this.radius, 0, 2 * Math.PI);
    }
    // TODO handle skewing and rotation
    addBounds(bounds) {
        setPoint(bounds, { x: this.x - this.radius, y: this.y - this.radius });
        setPoint(bounds, { x: this.x + this.radius, y: this.y + this.radius });
    }
}
/**
 * @ignore
 */
class DrawEllipse extends Op {
    constructor(x, y, radiusX, radiusY) {
        super();
        Object.defineProperty(this, "x", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: x
        });
        Object.defineProperty(this, "y", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: y
        });
        Object.defineProperty(this, "radiusX", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: radiusX
        });
        Object.defineProperty(this, "radiusY", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: radiusY
        });
    }
    path(context) {
        context.ellipse(0, 0, this.radiusX, this.radiusY, 0, 0, Math.PI * 2);
    }
    // TODO handle skewing and rotation
    addBounds(bounds) {
        setPoint(bounds, { x: this.x - this.radiusX, y: this.y - this.radiusY });
        setPoint(bounds, { x: this.x + this.radiusX, y: this.y + this.radiusY });
    }
}
/**
 * @ignore
 */
class Arc extends Op {
    constructor(cx, cy, radius, startAngle, endAngle, anticlockwise) {
        super();
        Object.defineProperty(this, "cx", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: cx
        });
        Object.defineProperty(this, "cy", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: cy
        });
        Object.defineProperty(this, "radius", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: radius
        });
        Object.defineProperty(this, "startAngle", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: startAngle
        });
        Object.defineProperty(this, "endAngle", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: endAngle
        });
        Object.defineProperty(this, "anticlockwise", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: anticlockwise
        });
    }
    path(context) {
        if (this.radius > 0) {
            context.arc(this.cx, this.cy, this.radius, this.startAngle, this.endAngle, this.anticlockwise);
        }
    }
    addBounds(bounds) {
        let arcBounds = _util_Math__WEBPACK_IMPORTED_MODULE_5__.getArcBounds(this.cx, this.cy, this.startAngle * _util_Math__WEBPACK_IMPORTED_MODULE_5__.DEGREES, this.endAngle * _util_Math__WEBPACK_IMPORTED_MODULE_5__.DEGREES, this.radius);
        setPoint(bounds, { x: arcBounds.left, y: arcBounds.top });
        setPoint(bounds, { x: arcBounds.right, y: arcBounds.bottom });
    }
}
/**
 * @ignore
 */
class ArcTo extends Op {
    constructor(x1, y1, x2, y2, radius) {
        super();
        Object.defineProperty(this, "x1", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: x1
        });
        Object.defineProperty(this, "y1", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: y1
        });
        Object.defineProperty(this, "x2", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: x2
        });
        Object.defineProperty(this, "y2", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: y2
        });
        Object.defineProperty(this, "radius", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: radius
        });
    }
    path(context) {
        if (this.radius > 0) {
            context.arcTo(this.x1, this.y1, this.x2, this.y2, this.radius);
        }
    }
    // TODO: add points
    addBounds(_bounds) {
        /*
        // not finished
        https://math.stackexchange.com/questions/1781438/finding-the-center-of-a-circle-given-two-points-and-a-radius-algebraically

        if (prevPoint) {
            let x1 = prevPoint.x;
            let y1 = prevPoint.y;
            let x2 = this.x2;
            let y2 = this.y2;
            let r = this.radius;

            let xa = (x2 - x1) / 2;
            let ya = (y2 - y1) / 2;

            let x0 = x1 + xa;
            let y0 = y1 + ya;

            let a = Math.hypot(xa, ya);
            let b = Math.sqrt(r * r - a * a);

            let cx = x0 + b * ya / a;
            let cy = y0 - b * xa / a;

            console.log(cx, cy);
        }*/
    }
}
/**
 * @ignore
 */
class LineTo extends Op {
    constructor(x, y) {
        super();
        Object.defineProperty(this, "x", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: x
        });
        Object.defineProperty(this, "y", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: y
        });
    }
    path(context) {
        context.lineTo(this.x, this.y);
    }
    addBounds(bounds) {
        setPoint(bounds, { x: this.x, y: this.y });
    }
}
/**
 * @ignore
 */
class MoveTo extends Op {
    constructor(x, y) {
        super();
        Object.defineProperty(this, "x", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: x
        });
        Object.defineProperty(this, "y", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: y
        });
    }
    path(context) {
        context.moveTo(this.x, this.y);
    }
    addBounds(bounds) {
        setPoint(bounds, { x: this.x, y: this.y });
    }
}
/**
 * @ignore
 */
class ClosePath extends Op {
    path(context) {
        context.closePath();
    }
}
/**
 * @ignore
 */
class BezierCurveTo extends Op {
    constructor(cpX, cpY, cpX2, cpY2, toX, toY) {
        super();
        Object.defineProperty(this, "cpX", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: cpX
        });
        Object.defineProperty(this, "cpY", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: cpY
        });
        Object.defineProperty(this, "cpX2", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: cpX2
        });
        Object.defineProperty(this, "cpY2", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: cpY2
        });
        Object.defineProperty(this, "toX", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: toX
        });
        Object.defineProperty(this, "toY", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: toY
        });
    }
    path(context) {
        context.bezierCurveTo(this.cpX, this.cpY, this.cpX2, this.cpY2, this.toX, this.toY);
    }
    // TODO: OK?
    addBounds(bounds) {
        setPoint(bounds, { x: this.cpX, y: this.cpY });
        setPoint(bounds, { x: this.cpX2, y: this.cpY2 });
        setPoint(bounds, { x: this.toX, y: this.toY });
    }
}
/**
 * @ignore
 */
class QuadraticCurveTo extends Op {
    constructor(cpX, cpY, toX, toY) {
        super();
        Object.defineProperty(this, "cpX", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: cpX
        });
        Object.defineProperty(this, "cpY", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: cpY
        });
        Object.defineProperty(this, "toX", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: toX
        });
        Object.defineProperty(this, "toY", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: toY
        });
    }
    path(context) {
        context.quadraticCurveTo(this.cpX, this.cpY, this.toX, this.toY);
    }
    // TODO: OK?
    addBounds(bounds) {
        setPoint(bounds, { x: this.cpX, y: this.cpY });
        setPoint(bounds, { x: this.toX, y: this.toY });
    }
}
/**
 * @ignore
 */
class Shadow extends Op {
    constructor(color, blur, offsetX, offsetY, opacity) {
        super();
        Object.defineProperty(this, "color", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: color
        });
        Object.defineProperty(this, "blur", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: blur
        });
        Object.defineProperty(this, "offsetX", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: offsetX
        });
        Object.defineProperty(this, "offsetY", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: offsetY
        });
        Object.defineProperty(this, "opacity", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: opacity
        });
    }
    colorize(context, _forceColor) {
        if (this.opacity) {
            context.fillStyle = this.color;
        }
        context.shadowColor = this.color;
        context.shadowBlur = this.blur;
        context.shadowOffsetX = this.offsetX;
        context.shadowOffsetY = this.offsetY;
    }
}
/**
 * @ignore
 */
class GraphicsImage extends Op {
    constructor(image, width, height, x, y) {
        super();
        Object.defineProperty(this, "image", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: image
        });
        Object.defineProperty(this, "width", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: width
        });
        Object.defineProperty(this, "height", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: height
        });
        Object.defineProperty(this, "x", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: x
        });
        Object.defineProperty(this, "y", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: y
        });
    }
    path(context) {
        context.drawImage(this.image, this.x, this.y, this.width, this.height);
    }
    // TODO: OK?
    addBounds(bounds) {
        setPoint(bounds, { x: this.x, y: this.y });
        setPoint(bounds, { x: this.width, y: this.height });
    }
}
/**
 * @ignore
 */
class CanvasGraphics extends CanvasDisplayObject {
    constructor() {
        super(...arguments);
        Object.defineProperty(this, "_operations", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
        });
        Object.defineProperty(this, "blendMode", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: _Renderer__WEBPACK_IMPORTED_MODULE_6__.BlendMode.NORMAL
        });
        Object.defineProperty(this, "_hasShadows", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        Object.defineProperty(this, "_fillAlpha", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_strokeAlpha", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
    }
    clear() {
        super.clear();
        this._operations.length = 0;
    }
    _pushOp(op) {
        this._operations.push(op);
    }
    beginFill(color, alpha = 1) {
        this._fillAlpha = alpha;
        if (color) {
            if (color instanceof _util_Color__WEBPACK_IMPORTED_MODULE_7__.Color) {
                this._pushOp(new BeginFill(color.toCSS(alpha)));
            }
            else {
                this.isMeasured = true;
                this._pushOp(new BeginFill(color));
            }
        }
        else {
            this._pushOp(new BeginFill("rgba(0, 0, 0, " + alpha + ")"));
        }
    }
    endFill() {
        this._pushOp(new EndFill(this._hasShadows));
    }
    endStroke() {
        this._pushOp(new EndStroke());
    }
    beginPath() {
        this._pushOp(new BeginPath());
    }
    lineStyle(width = 0, color, alpha = 1, lineJoin) {
        this._strokeAlpha = alpha;
        if (color) {
            if (color instanceof _util_Color__WEBPACK_IMPORTED_MODULE_7__.Color) {
                this._pushOp(new LineStyle(width, color.toCSS(alpha), lineJoin));
            }
            else {
                this._pushOp(new LineStyle(width, color, lineJoin));
            }
        }
        else {
            this._pushOp(new LineStyle(width, "rgba(0, 0, 0, " + alpha + ")", lineJoin));
        }
    }
    setLineDash(dash) {
        this._pushOp(new LineDash(dash ? dash : []));
    }
    setLineDashOffset(dashOffset = 0) {
        this._pushOp(new LineDashOffset(dashOffset));
    }
    drawRect(x, y, width, height) {
        this._pushOp(new DrawRect(x, y, width, height));
    }
    drawCircle(x, y, radius) {
        this._pushOp(new DrawCircle(x, y, radius));
    }
    drawEllipse(x, y, radiusX, radiusY) {
        this._pushOp(new DrawEllipse(x, y, radiusX, radiusY));
    }
    arc(cx, cy, radius, startAngle, endAngle, anticlockwise = false) {
        this._pushOp(new Arc(cx, cy, radius, startAngle, endAngle, anticlockwise));
    }
    arcTo(x1, y1, x2, y2, radius) {
        this._pushOp(new ArcTo(x1, y1, x2, y2, radius));
    }
    lineTo(x, y) {
        this._pushOp(new LineTo(x, y));
    }
    moveTo(x, y) {
        this._pushOp(new MoveTo(x, y));
    }
    bezierCurveTo(cpX, cpY, cpX2, cpY2, toX, toY) {
        this._pushOp(new BezierCurveTo(cpX, cpY, cpX2, cpY2, toX, toY));
    }
    quadraticCurveTo(cpX, cpY, toX, toY) {
        this._pushOp(new QuadraticCurveTo(cpX, cpY, toX, toY));
    }
    closePath() {
        this._pushOp(new ClosePath());
    }
    shadow(color, blur = 0, offsetX = 0, offsetY = 0, opacity) {
        this._hasShadows = true;
        this._pushOp(new Shadow(opacity ? color.toCSS(opacity) : color.toCSS(this._fillAlpha || this._strokeAlpha), blur, offsetX, offsetY));
    }
    image(image, width, height, x, y) {
        this._pushOp(new GraphicsImage(image, width, height, x, y));
    }
    // https://svgwg.org/svg2-draft/paths.html#DProperty
    // TODO better error checking
    svgPath(path) {
        let x = 0;
        let y = 0;
        let cpx = null;
        let cpy = null;
        let qcpx = null;
        let qcpy = null;
        const SEGMENTS_REGEXP = /([MmZzLlHhVvCcSsQqTtAa])([^MmZzLlHhVvCcSsQqTtAa]*)/g;
        const ARGS_REGEXP = /[\u0009\u0020\u000A\u000C\u000D]*([\+\-]?[0-9]*\.?[0-9]+(?:[eE][\+\-]?[0-9]+)?)[\u0009\u0020\u000A\u000C\u000D]*,?/g;
        let match;
        while ((match = SEGMENTS_REGEXP.exec(path)) !== null) {
            const name = match[1];
            const rest = match[2];
            const args = [];
            while ((match = ARGS_REGEXP.exec(rest)) !== null) {
                args.push(match[1]);
            }
            // Reset control point
            if (name !== "S" && name !== "s" && name !== "C" && name !== "c") {
                cpx = null;
                cpy = null;
            }
            // Reset control point
            if (name !== "Q" && name !== "q" && name !== "T" && name !== "t") {
                qcpx = null;
                qcpy = null;
            }
            switch (name) {
                case "M":
                    checkEvenArgs(name, args.length, 2);
                    x = +args[0];
                    y = +args[1];
                    this.moveTo(x, y);
                    for (let i = 2; i < args.length; i += 2) {
                        x = +args[i];
                        y = +args[i + 1];
                        this.lineTo(x, y);
                    }
                    break;
                case "m":
                    checkEvenArgs(name, args.length, 2);
                    x += +args[0];
                    y += +args[1];
                    this.moveTo(x, y);
                    for (let i = 2; i < args.length; i += 2) {
                        x += +args[i];
                        y += +args[i + 1];
                        this.lineTo(x, y);
                    }
                    break;
                case "L":
                    checkEvenArgs(name, args.length, 2);
                    for (let i = 0; i < args.length; i += 2) {
                        x = +args[i];
                        y = +args[i + 1];
                        this.lineTo(x, y);
                    }
                    break;
                case "l":
                    checkEvenArgs(name, args.length, 2);
                    for (let i = 0; i < args.length; i += 2) {
                        x += +args[i];
                        y += +args[i + 1];
                        this.lineTo(x, y);
                    }
                    break;
                case "H":
                    checkMinArgs(name, args.length, 1);
                    for (let i = 0; i < args.length; ++i) {
                        x = +args[i];
                        this.lineTo(x, y);
                    }
                    break;
                case "h":
                    checkMinArgs(name, args.length, 1);
                    for (let i = 0; i < args.length; ++i) {
                        x += +args[i];
                        this.lineTo(x, y);
                    }
                    break;
                case "V":
                    checkMinArgs(name, args.length, 1);
                    for (let i = 0; i < args.length; ++i) {
                        y = +args[i];
                        this.lineTo(x, y);
                    }
                    break;
                case "v":
                    checkMinArgs(name, args.length, 1);
                    for (let i = 0; i < args.length; ++i) {
                        y += +args[i];
                        this.lineTo(x, y);
                    }
                    break;
                case "C":
                    checkEvenArgs(name, args.length, 6);
                    for (let i = 0; i < args.length; i += 6) {
                        const x1 = +args[i];
                        const y1 = +args[i + 1];
                        cpx = +args[i + 2];
                        cpy = +args[i + 3];
                        x = +args[i + 4];
                        y = +args[i + 5];
                        this.bezierCurveTo(x1, y1, cpx, cpy, x, y);
                    }
                    break;
                case "c":
                    checkEvenArgs(name, args.length, 6);
                    for (let i = 0; i < args.length; i += 6) {
                        const x1 = +args[i] + x;
                        const y1 = +args[i + 1] + y;
                        cpx = +args[i + 2] + x;
                        cpy = +args[i + 3] + y;
                        x += +args[i + 4];
                        y += +args[i + 5];
                        this.bezierCurveTo(x1, y1, cpx, cpy, x, y);
                    }
                    break;
                case "S":
                    checkEvenArgs(name, args.length, 4);
                    if (cpx === null || cpy === null) {
                        cpx = x;
                        cpy = y;
                    }
                    for (let i = 0; i < args.length; i += 4) {
                        const x1 = 2 * x - cpx;
                        const y1 = 2 * y - cpy;
                        cpx = +args[i];
                        cpy = +args[i + 1];
                        x = +args[i + 2];
                        y = +args[i + 3];
                        this.bezierCurveTo(x1, y1, cpx, cpy, x, y);
                    }
                    break;
                case "s":
                    checkEvenArgs(name, args.length, 4);
                    if (cpx === null || cpy === null) {
                        cpx = x;
                        cpy = y;
                    }
                    for (let i = 0; i < args.length; i += 4) {
                        const x1 = 2 * x - cpx;
                        const y1 = 2 * y - cpy;
                        cpx = +args[i] + x;
                        cpy = +args[i + 1] + y;
                        x += +args[i + 2];
                        y += +args[i + 3];
                        this.bezierCurveTo(x1, y1, cpx, cpy, x, y);
                    }
                    break;
                case "Q":
                    checkEvenArgs(name, args.length, 4);
                    for (let i = 0; i < args.length; i += 4) {
                        qcpx = +args[i];
                        qcpy = +args[i + 1];
                        x = +args[i + 2];
                        y = +args[i + 3];
                        this.quadraticCurveTo(qcpx, qcpy, x, y);
                    }
                    break;
                case "q":
                    checkEvenArgs(name, args.length, 4);
                    for (let i = 0; i < args.length; i += 4) {
                        qcpx = +args[i] + x;
                        qcpy = +args[i + 1] + y;
                        x += +args[i + 2];
                        y += +args[i + 3];
                        this.quadraticCurveTo(qcpx, qcpy, x, y);
                    }
                    break;
                case "T":
                    checkEvenArgs(name, args.length, 2);
                    if (qcpx === null || qcpy === null) {
                        qcpx = x;
                        qcpy = y;
                    }
                    for (let i = 0; i < args.length; i += 2) {
                        qcpx = 2 * x - qcpx;
                        qcpy = 2 * y - qcpy;
                        x = +args[i];
                        y = +args[i + 1];
                        this.quadraticCurveTo(qcpx, qcpy, x, y);
                    }
                    break;
                case "t":
                    checkEvenArgs(name, args.length, 2);
                    if (qcpx === null || qcpy === null) {
                        qcpx = x;
                        qcpy = y;
                    }
                    for (let i = 0; i < args.length; i += 2) {
                        qcpx = 2 * x - qcpx;
                        qcpy = 2 * y - qcpy;
                        x += +args[i];
                        y += +args[i + 1];
                        this.quadraticCurveTo(qcpx, qcpy, x, y);
                    }
                    break;
                case "A":
                case "a":
                    const relative = (name === "a");
                    splitArcFlags(args);
                    checkEvenArgs(name, args.length, 7);
                    for (let i = 0; i < args.length; i += 7) {
                        let cx = +args[i + 5];
                        let cy = +args[i + 6];
                        if (relative) {
                            cx += x;
                            cy += y;
                        }
                        const bs = (0,svg_arc_to_cubic_bezier__WEBPACK_IMPORTED_MODULE_0__["default"])({
                            px: x,
                            py: y,
                            rx: +args[i],
                            ry: +args[i + 1],
                            xAxisRotation: +args[i + 2],
                            largeArcFlag: assertBinary(+args[i + 3]),
                            sweepFlag: assertBinary(+args[i + 4]),
                            cx,
                            cy,
                        });
                        _util_Array__WEBPACK_IMPORTED_MODULE_2__.each(bs, (b) => {
                            this.bezierCurveTo(b.x1, b.y1, b.x2, b.y2, b.x, b.y);
                            x = b.x;
                            y = b.y;
                        });
                    }
                    break;
                case "Z":
                case "z":
                    checkArgs(name, args.length, 0);
                    this.closePath();
                    break;
            }
        }
    }
    _runPath(context) {
        context.beginPath();
        _util_Array__WEBPACK_IMPORTED_MODULE_2__.each(this._operations, (op) => {
            op.path(context);
        });
    }
    _render(status) {
        super._render(status);
        const layerDirty = status.layer.dirty;
        const interactive = this._isInteractive(status);
        if (layerDirty || interactive) {
            const context = status.layer.context;
            const ghostContext = this._renderer._ghostLayer.context;
            if (layerDirty) {
                context.globalCompositeOperation = this.blendMode;
                context.beginPath();
            }
            let color;
            if (interactive) {
                ghostContext.beginPath();
                color = this._getColorId();
            }
            _util_Array__WEBPACK_IMPORTED_MODULE_2__.each(this._operations, (op) => {
                if (layerDirty) {
                    op.path(context);
                    op.colorize(context, undefined);
                }
                if (interactive) {
                    op.path(ghostContext);
                    op.colorize(ghostContext, color);
                }
            });
        }
    }
    renderDetached(context) {
        if (this.visible) {
            this._setMatrix();
            context.save();
            // We must apply the mask before we transform the element
            const mask = this.mask;
            if (mask) {
                mask._setMatrix();
                mask._transform(context, 1);
                mask._runPath(context);
                context.clip();
            }
            // TODO handle compoundAlpha somehow ?
            context.globalAlpha = this.compoundAlpha * this.alpha;
            this._transform(context, 1);
            if (this.filter) {
                context.filter = this.filter;
            }
            context.globalCompositeOperation = this.blendMode;
            context.beginPath();
            _util_Array__WEBPACK_IMPORTED_MODULE_2__.each(this._operations, (op) => {
                op.path(context);
                op.colorize(context, undefined);
            });
            context.restore();
        }
    }
    _addBounds(bounds) {
        if (this.visible && this.isMeasured) {
            _util_Array__WEBPACK_IMPORTED_MODULE_2__.each(this._operations, (op) => {
                op.addBounds(bounds);
            });
        }
    }
}
/**
 * @ignore
 */
class CanvasText extends CanvasDisplayObject {
    constructor(renderer, text, style) {
        super(renderer);
        Object.defineProperty(this, "text", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "style", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "resolution", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 1
        });
        Object.defineProperty(this, "textVisible", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: true
        });
        Object.defineProperty(this, "_textInfo", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_originalScale", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 1
        });
        this.text = text;
        this.style = style;
    }
    invalidateBounds() {
        super.invalidateBounds();
        this._textInfo = undefined;
    }
    _shared(context) {
        if (this.style.textAlign) {
            context.textAlign = this.style.textAlign;
        }
        if (this.style.direction) {
            context.direction = this.style.direction;
        }
        if (this.style.textBaseline) {
            context.textBaseline = this.style.textBaseline;
        }
    }
    _prerender(status, ignoreGhost = false, ignoreFontWeight = false) {
        super._render(status);
        const context = status.layer.context;
        const ghostContext = this._renderer._ghostLayer.context;
        // Font style
        const style = this.style;
        let fontStyle = this._getFontStyle(undefined, ignoreFontWeight);
        context.font = fontStyle;
        if (this._isInteractive(status) && !ignoreGhost) {
            ghostContext.font = fontStyle;
        }
        // Other parameters
        if (style.fill) {
            if (style.fill instanceof _util_Color__WEBPACK_IMPORTED_MODULE_7__.Color) {
                context.fillStyle = style.fill.toCSS(style.fillOpacity != undefined ? style.fillOpacity : 1);
            }
            else {
                context.fillStyle = style.fill;
            }
        }
        if (style.shadowColor) {
            status.layer.context.shadowColor = style.shadowColor.toCSS(style.shadowOpacity || 1);
        }
        if (style.shadowBlur) {
            status.layer.context.shadowBlur = style.shadowBlur;
        }
        if (style.shadowOffsetX) {
            status.layer.context.shadowOffsetX = style.shadowOffsetX;
        }
        if (style.shadowOffsetY) {
            status.layer.context.shadowOffsetY = style.shadowOffsetY;
        }
        this._shared(context);
        if (this._isInteractive(status) && !ignoreGhost) {
            ghostContext.fillStyle = this._getColorId();
            this._shared(ghostContext);
        }
    }
    _getFontStyle(style2, ignoreFontWeight = false) {
        // Process defaults
        const style = this.style;
        let fontStyle = [];
        if (style2 && style2.fontVariant) {
            fontStyle.push(style2.fontVariant);
        }
        else if (style.fontVariant) {
            fontStyle.push(style.fontVariant);
        }
        if (!ignoreFontWeight) {
            if (style2 && style2.fontWeight) {
                fontStyle.push(style2.fontWeight);
            }
            else if (style.fontWeight) {
                fontStyle.push(style.fontWeight);
            }
        }
        if (style2 && style2.fontStyle) {
            fontStyle.push(style2.fontStyle);
        }
        else if (style.fontStyle) {
            fontStyle.push(style.fontStyle);
        }
        if (style2 && style2.fontSize) {
            if (_util_Type__WEBPACK_IMPORTED_MODULE_8__.isNumber(style2.fontSize)) {
                style2.fontSize = style2.fontSize + "px";
            }
            fontStyle.push(style2.fontSize);
        }
        else if (style.fontSize) {
            if (_util_Type__WEBPACK_IMPORTED_MODULE_8__.isNumber(style.fontSize)) {
                style.fontSize = style.fontSize + "px";
            }
            fontStyle.push(style.fontSize);
        }
        if (style2 && style2.fontFamily) {
            fontStyle.push(style2.fontFamily);
        }
        else if (style.fontFamily) {
            fontStyle.push(style.fontFamily);
        }
        else if (fontStyle.length) {
            fontStyle.push("Arial");
        }
        return fontStyle.join(" ");
    }
    _render(status) {
        // We need measurements in order to properly position text for alignment
        if (!this._textInfo) {
            this._measure(status);
        }
        if (this.textVisible) {
            const interactive = this._isInteractive(status);
            const context = status.layer.context;
            const layerDirty = status.layer.dirty;
            const ghostContext = this._renderer._ghostLayer.context;
            context.save();
            ghostContext.save();
            this._prerender(status);
            // const lines = this.text.toString().replace(/\r/g, "").split(/\n/);
            // const x = this._localBounds && (this._localBounds.left < 0) ? Math.abs(this._localBounds.left) : 0;
            // Process text info produced by _measure()
            _util_Array__WEBPACK_IMPORTED_MODULE_2__.each(this._textInfo, (line, _index) => {
                _util_Array__WEBPACK_IMPORTED_MODULE_2__.each(line.textChunks, (chunk, _index) => {
                    // Set style
                    if (chunk.style) {
                        context.save();
                        ghostContext.save();
                        context.font = chunk.style;
                        if (this._isInteractive(status)) {
                            ghostContext.font = chunk.style;
                        }
                    }
                    if (chunk.fill) {
                        context.save();
                        context.fillStyle = chunk.fill.toCSS();
                        // Color does not affect ghostContext so we not set it
                    }
                    // Draw text
                    if (layerDirty) {
                        context.fillText(chunk.text, chunk.offsetX, line.offsetY + chunk.offsetY);
                    }
                    // Draw underline
                    if (chunk.textDecoration == "underline" || chunk.textDecoration == "line-through") {
                        let thickness = 1;
                        let offset = 1;
                        let fontSize = chunk.height;
                        let offsetX = chunk.offsetX;
                        switch (this.style.textAlign) {
                            case "right":
                            case "end":
                                offsetX -= chunk.width;
                                break;
                            case "center":
                                offsetX -= chunk.width / 2;
                                break;
                        }
                        if (chunk.style) {
                            const format = _util_TextFormatter__WEBPACK_IMPORTED_MODULE_9__.TextFormatter.getTextStyle(chunk.style);
                            switch (format.fontWeight) {
                                case "bolder":
                                case "bold":
                                case "700":
                                case "800":
                                case "900":
                                    thickness = 2;
                                    break;
                            }
                        }
                        if (fontSize) {
                            offset = fontSize / 20;
                        }
                        let y;
                        if (chunk.textDecoration == "line-through") {
                            y = thickness + line.offsetY + chunk.offsetY - chunk.height / 2;
                        }
                        else {
                            y = thickness + offset * 1.5 + line.offsetY + chunk.offsetY;
                        }
                        context.save();
                        context.beginPath();
                        if (chunk.fill) {
                            context.strokeStyle = chunk.fill.toCSS();
                        }
                        else if (this.style.fill && this.style.fill instanceof _util_Color__WEBPACK_IMPORTED_MODULE_7__.Color) {
                            context.strokeStyle = this.style.fill.toCSS();
                        }
                        context.lineWidth = thickness * offset;
                        context.moveTo(offsetX, y);
                        context.lineTo(offsetX + chunk.width, y);
                        context.stroke();
                        context.restore();
                    }
                    if (interactive && this.interactive) {
                        // Draw text in ghost canvas ONLY if it is set as interactive
                        // explicitly. This way we avoid hit test anomalies caused by anti
                        // aliasing of text.
                        ghostContext.fillText(chunk.text, chunk.offsetX, line.offsetY + chunk.offsetY);
                    }
                    if (chunk.fill) {
                        context.restore();
                        // Color does not affect ghostContext so we not set it
                    }
                    // Reset style
                    if (chunk.style) {
                        context.restore();
                        ghostContext.restore();
                    }
                });
            });
            context.restore();
            ghostContext.restore();
        }
    }
    _addBounds(bounds) {
        if (this.visible && this.isMeasured) {
            //if (this._textVisible) {
            const x = this._measure({
                inactive: this.inactive,
                layer: this.getLayer(),
            });
            setPoint(bounds, { x: x.left, y: x.top });
            setPoint(bounds, { x: x.right, y: x.bottom });
            //}
        }
    }
    _ignoreFontWeight() {
        return /apple/i.test(navigator.vendor);
    }
    _measure(status) {
        const context = status.layer.context;
        const ghostContext = this._renderer._ghostLayer.context;
        const rtl = this.style.direction == "rtl";
        // Reset text info
        this._textInfo = [];
        // Init
        const oversizedBehavior = this.style.oversizedBehavior;
        const maxWidth = this.style.maxWidth;
        const truncate = _util_Type__WEBPACK_IMPORTED_MODULE_8__.isNumber(maxWidth) && oversizedBehavior == "truncate";
        const wrap = _util_Type__WEBPACK_IMPORTED_MODULE_8__.isNumber(maxWidth) && (oversizedBehavior == "wrap" || oversizedBehavior == "wrap-no-break");
        // Pre-render
        context.save();
        ghostContext.save();
        this._prerender(status, true, this._ignoreFontWeight());
        // Get default font metrix
        const refText = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 ";
        // Split up text into lines
        const lines = this.text.toString().replace(/\r/g, "").split(/\n/);
        let styleRestored = true;
        let minX = 0;
        let maxX = 0;
        // Iterate through the lines
        let offsetY = 0;
        let currentStyle;
        _util_Array__WEBPACK_IMPORTED_MODULE_2__.each(lines, (line, _index) => {
            // Split up line into format/value chunks
            let chunks;
            if (line == "") {
                chunks = [{
                        type: "value",
                        text: ""
                    }];
            }
            else {
                chunks = _util_TextFormatter__WEBPACK_IMPORTED_MODULE_9__.TextFormatter.chunk(line, false, this.style.ignoreFormatting);
            }
            while (chunks.length > 0) {
                // Init line object
                let lineInfo = {
                    offsetY: offsetY,
                    ascent: 0,
                    width: 0,
                    height: 0,
                    left: 0,
                    right: 0,
                    textChunks: []
                };
                // Measure reference text
                const metrics = this._measureText(refText, context);
                const height = metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent;
                lineInfo.height = height;
                lineInfo.ascent = metrics.actualBoundingBoxAscent;
                let currentFormat;
                let currentDecoration = this.style.textDecoration;
                let currentFill;
                let currentChunkWidth;
                let skipFurtherText = false;
                let firstTextChunk = true;
                let leftoverChunks = [];
                let currentVerticalAlign;
                //let offsetX = 0;
                //let chunk;
                //while(chunk = chunks.shift()) {
                _util_Array__WEBPACK_IMPORTED_MODULE_2__.eachContinue(chunks, (chunk, index) => {
                    // Format chunk
                    if (chunk.type == "format") {
                        if (chunk.text == "[/]") {
                            if (!styleRestored) {
                                context.restore();
                                ghostContext.restore();
                                styleRestored = true;
                            }
                            currentFill = undefined;
                            currentStyle = undefined;
                            currentChunkWidth = undefined;
                            currentDecoration = this.style.textDecoration;
                            currentVerticalAlign = undefined;
                            currentFormat = chunk.text;
                        }
                        else {
                            if (!styleRestored) {
                                context.restore();
                                ghostContext.restore();
                            }
                            let format = _util_TextFormatter__WEBPACK_IMPORTED_MODULE_9__.TextFormatter.getTextStyle(chunk.text);
                            const fontStyle = this._getFontStyle(format);
                            context.save();
                            ghostContext.save();
                            context.font = fontStyle;
                            currentStyle = fontStyle;
                            currentFormat = chunk.text;
                            if (format.textDecoration) {
                                currentDecoration = format.textDecoration;
                            }
                            if (format.fill) {
                                currentFill = format.fill;
                            }
                            if (format.width) {
                                currentChunkWidth = _util_Type__WEBPACK_IMPORTED_MODULE_8__.toNumber(format.width);
                            }
                            if (format.verticalAlign) {
                                currentVerticalAlign = format.verticalAlign;
                            }
                            styleRestored = false;
                            // Measure reference text after change of format
                            const metrics = this._measureText(refText, context);
                            const height = metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent;
                            if (height > lineInfo.height) {
                                lineInfo.height = height;
                            }
                            if (metrics.actualBoundingBoxAscent > lineInfo.ascent) {
                                lineInfo.ascent = metrics.actualBoundingBoxAscent;
                            }
                        }
                    }
                    // Text chunk
                    else if (chunk.type == "value" && !skipFurtherText) {
                        // Measure
                        const metrics = this._measureText(chunk.text, context);
                        let chunkWidth = metrics.actualBoundingBoxLeft + metrics.actualBoundingBoxRight;
                        // Check for fit
                        if (truncate) {
                            // Break words?
                            let breakWords = firstTextChunk || this.style.breakWords || false;
                            // Measure ellipsis and check if it fits
                            const ellipsis = this.style.ellipsis || "";
                            const ellipsisMetrics = this._measureText(ellipsis, context);
                            const ellipsisWidth = ellipsisMetrics.actualBoundingBoxLeft + ellipsisMetrics.actualBoundingBoxRight;
                            // Check fit
                            if ((lineInfo.width + chunkWidth) > maxWidth) {
                                const excessWidth = maxWidth - lineInfo.width - ellipsisWidth;
                                chunk.text = this._truncateText(context, chunk.text, excessWidth, breakWords);
                                chunk.text += ellipsis;
                                skipFurtherText = true;
                            }
                        }
                        else if (wrap) {
                            // Check fit
                            if ((lineInfo.width + chunkWidth) > maxWidth) {
                                const excessWidth = maxWidth - lineInfo.width;
                                const tmpText = this._truncateText(context, chunk.text, excessWidth, false, (firstTextChunk && this.style.oversizedBehavior != "wrap-no-break"));
                                if (tmpText == "") {
                                    // Unable to fit a single letter - hide the whole label
                                    this.textVisible = true;
                                    return false;
                                }
                                //skipFurtherText = true;
                                //Add remaining chunks for the next line
                                leftoverChunks = chunks.slice(index + 1);
                                //Add remaining text of current chunk if it was forced-cut
                                if (_util_Utils__WEBPACK_IMPORTED_MODULE_1__.trim(tmpText) != _util_Utils__WEBPACK_IMPORTED_MODULE_1__.trim(chunk.text)) {
                                    leftoverChunks.unshift({
                                        type: "value",
                                        text: chunk.text.substr(tmpText.length)
                                    });
                                    if (currentFormat) {
                                        leftoverChunks.unshift({
                                            type: "format",
                                            text: currentFormat
                                        });
                                    }
                                }
                                // Set current chunk (truncated)
                                chunk.text = _util_Utils__WEBPACK_IMPORTED_MODULE_1__.trim(tmpText);
                                chunks = [];
                                skipFurtherText = true;
                            }
                        }
                        // Chunk width?
                        let leftBoundMod = 1;
                        let rightBoundMod = 1;
                        if (currentStyle && currentChunkWidth && (currentChunkWidth > chunkWidth)) {
                            // increase horizontal bounding boxes accordingly
                            const boundsMod = chunkWidth / currentChunkWidth;
                            switch (this.style.textAlign) {
                                case "right":
                                case "end":
                                    leftBoundMod = boundsMod;
                                    break;
                                case "center":
                                    leftBoundMod = boundsMod;
                                    rightBoundMod = boundsMod;
                                    break;
                                default:
                                    rightBoundMod = boundsMod;
                            }
                            chunkWidth = currentChunkWidth;
                        }
                        const chunkHeight = metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent;
                        if (chunkHeight > lineInfo.height) {
                            lineInfo.height = chunkHeight;
                        }
                        if (metrics.actualBoundingBoxAscent > lineInfo.ascent) {
                            lineInfo.ascent = metrics.actualBoundingBoxAscent;
                        }
                        lineInfo.width += chunkWidth;
                        lineInfo.left += metrics.actualBoundingBoxLeft / leftBoundMod;
                        lineInfo.right += metrics.actualBoundingBoxRight / rightBoundMod;
                        lineInfo.textChunks.push({
                            style: currentStyle,
                            fill: currentFill,
                            text: chunk.text,
                            width: chunkWidth,
                            height: chunkHeight,
                            left: metrics.actualBoundingBoxLeft,
                            right: metrics.actualBoundingBoxRight,
                            ascent: metrics.actualBoundingBoxAscent,
                            offsetX: 0,
                            offsetY: 0,
                            textDecoration: currentDecoration,
                            verticalAlign: currentVerticalAlign
                        });
                        //offsetX += chunkWidth;
                        firstTextChunk = false;
                    }
                    if (leftoverChunks) {
                        //return false;
                    }
                    return true;
                    //}
                });
                if (this.style.lineHeight instanceof _util_Percent__WEBPACK_IMPORTED_MODULE_10__.Percent) {
                    lineInfo.height *= this.style.lineHeight.value;
                    lineInfo.ascent *= this.style.lineHeight.value;
                }
                else {
                    lineInfo.height *= this.style.lineHeight || 1.2;
                    lineInfo.ascent *= this.style.lineHeight || 1.2;
                }
                if (minX < lineInfo.left) {
                    minX = lineInfo.left;
                }
                if (maxX < lineInfo.right) {
                    maxX = lineInfo.right;
                }
                this._textInfo.push(lineInfo);
                //lineInfo.offsetY += lineInfo.ascent;
                offsetY += lineInfo.height;
                // Reset chunks so that it can proceed to the next line
                chunks = leftoverChunks || [];
            }
        });
        if (!styleRestored) {
            context.restore();
            ghostContext.restore();
        }
        // Adjust chunk internal offsets
        _util_Array__WEBPACK_IMPORTED_MODULE_2__.each(this._textInfo, (lineInfo, _index) => {
            let currentChunkOffset = 0;
            _util_Array__WEBPACK_IMPORTED_MODULE_2__.each(lineInfo.textChunks, (chunk) => {
                chunk.offsetX = currentChunkOffset + chunk.left - lineInfo.left;
                chunk.offsetY += lineInfo.height - lineInfo.height * (this.style.baselineRatio || 0.19);
                currentChunkOffset += chunk.width;
                if (chunk.verticalAlign) {
                    switch (chunk.verticalAlign) {
                        case "super":
                            chunk.offsetY -= lineInfo.height / 2 - chunk.height / 2;
                            break;
                        case "sub":
                            chunk.offsetY += chunk.height / 2;
                            break;
                    }
                }
            });
        });
        const bounds = {
            left: rtl ? -maxX : -minX,
            top: 0,
            right: rtl ? minX : maxX,
            bottom: offsetY,
        };
        // We need to fit?
        if (oversizedBehavior !== "none") {
            const ratio = this._fitRatio(bounds);
            if (ratio < 1) {
                if (oversizedBehavior == "fit") {
                    if (_util_Type__WEBPACK_IMPORTED_MODULE_8__.isNumber(this.style.minScale) && (ratio < this.style.minScale)) {
                        this.textVisible = false;
                        bounds.left = 0;
                        bounds.top = 0;
                        bounds.right = 0;
                        bounds.bottom = 0;
                    }
                    else {
                        if (!this._originalScale || this._originalScale == 1) {
                            this._originalScale = this.scale;
                        }
                        this.scale = ratio;
                        this.textVisible = true;
                    }
                }
                else if (oversizedBehavior == "hide") {
                    this.textVisible = false;
                    bounds.left = 0;
                    bounds.top = 0;
                    bounds.right = 0;
                    bounds.bottom = 0;
                }
                else {
                    switch (this.style.textAlign) {
                        case "right":
                        case "end":
                            bounds.left = -maxWidth;
                            bounds.right = 0;
                            break;
                        case "center":
                            bounds.left = -maxWidth / 2;
                            bounds.right = maxWidth / 2;
                            break;
                        default:
                            bounds.left = 0;
                            bounds.right = maxWidth;
                    }
                    this.scale = this._originalScale || 1;
                    this._originalScale = undefined;
                    this.textVisible = true;
                }
            }
            else {
                this.scale = this._originalScale || 1;
                this._originalScale = undefined;
                this.textVisible = true;
            }
        }
        context.restore();
        ghostContext.restore();
        return bounds;
    }
    _fitRatio(bounds) {
        const maxW = this.style.maxWidth;
        const maxH = this.style.maxHeight;
        if (!_util_Type__WEBPACK_IMPORTED_MODULE_8__.isNumber(maxW) && !_util_Type__WEBPACK_IMPORTED_MODULE_8__.isNumber(maxH)) {
            return 1;
        }
        const w = bounds.right - bounds.left;
        const h = bounds.bottom - bounds.top;
        return Math.min(maxW / w || 1, maxH / h || 1);
    }
    _truncateText(context, text, maxWidth, breakWords = false, fallbackBreakWords = true) {
        let width;
        do {
            if (breakWords) {
                text = text.slice(0, -1);
            }
            else {
                let tmp = text.replace(/[^,;:!?\\\/\s​]+[,;:!?\\\/\s​]*$/g, "");
                if ((tmp == "" || tmp === text) && fallbackBreakWords) {
                    breakWords = true;
                }
                else if (tmp == "") {
                    return text;
                }
                else {
                    text = tmp;
                }
            }
            const metrics = this._measureText(text, context);
            width = metrics.actualBoundingBoxLeft + metrics.actualBoundingBoxRight;
        } while ((width > maxWidth) && text != "");
        return text;
    }
    _measureText(text, context) {
        let metrics = context.measureText(text);
        let fakeMetrics = {};
        if (metrics.actualBoundingBoxAscent == null) {
            const div = document.createElement("div");
            div.innerText = text;
            div.style.visibility = "hidden";
            div.style.position = "absolute";
            div.style.top = "-1000000px;";
            div.style.fontFamily = this.style.fontFamily || "";
            div.style.fontSize = this.style.fontSize + "";
            document.body.appendChild(div);
            const bbox = div.getBoundingClientRect();
            document.body.removeChild(div);
            const h = bbox.height;
            const w = metrics.width;
            let left = 0;
            let right = w;
            fakeMetrics = {
                actualBoundingBoxAscent: h,
                actualBoundingBoxDescent: 0,
                actualBoundingBoxLeft: left,
                actualBoundingBoxRight: right,
                fontBoundingBoxAscent: h,
                fontBoundingBoxDescent: 0,
                width: w
            };
            //return fake;
        }
        else {
            fakeMetrics = {
                actualBoundingBoxAscent: metrics.actualBoundingBoxAscent,
                actualBoundingBoxDescent: metrics.actualBoundingBoxDescent,
                actualBoundingBoxLeft: metrics.actualBoundingBoxLeft,
                actualBoundingBoxRight: metrics.actualBoundingBoxRight,
                fontBoundingBoxAscent: metrics.actualBoundingBoxAscent,
                fontBoundingBoxDescent: metrics.actualBoundingBoxDescent,
                width: metrics.width
            };
        }
        const w = metrics.width;
        switch (this.style.textAlign) {
            case "right":
            case "end":
                fakeMetrics.actualBoundingBoxLeft = w;
                fakeMetrics.actualBoundingBoxRight = 0;
                break;
            case "center":
                fakeMetrics.actualBoundingBoxLeft = w / 2;
                fakeMetrics.actualBoundingBoxRight = w / 2;
                break;
            default:
                fakeMetrics.actualBoundingBoxLeft = 0;
                fakeMetrics.actualBoundingBoxRight = w;
        }
        return fakeMetrics;
    }
}
/**
 * @ignore
 */
class CanvasTextStyle {
    constructor() {
        //public wordWrapWidth: number = 100;
        Object.defineProperty(this, "fill", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "fillOpacity", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "textAlign", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "fontFamily", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "fontSize", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "fontWeight", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "fontStyle", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "fontVariant", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "textDecoration", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "shadowColor", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "shadowBlur", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "shadowOffsetX", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "shadowOffsetY", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "shadowOpacity", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        // leading?: number;
        // letterSpacing?: number;
        Object.defineProperty(this, "lineHeight", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: (0,_util_Percent__WEBPACK_IMPORTED_MODULE_10__.percent)(120)
        });
        Object.defineProperty(this, "baselineRatio", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0.19
        });
        // padding?: number;
        // stroke?: number;
        // strokeThickness?: number;
        // trim?: number;
        // wordWrap?: boolean;
        Object.defineProperty(this, "direction", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "textBaseline", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "oversizedBehavior", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "none"
        });
        Object.defineProperty(this, "breakWords", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        Object.defineProperty(this, "ellipsis", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "…"
        });
        Object.defineProperty(this, "maxWidth", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "maxHeight", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "minScale", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "ignoreFormatting", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
    }
}
/**
 * @ignore
 */
class CanvasRadialText extends CanvasText {
    constructor() {
        super(...arguments);
        Object.defineProperty(this, "textType", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "circular"
        });
        Object.defineProperty(this, "radius", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "startAngle", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "inside", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        Object.defineProperty(this, "orientation", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "auto"
        });
        Object.defineProperty(this, "kerning", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        Object.defineProperty(this, "_textReversed", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
    }
    _render(status) {
        switch (this.textType) {
            case "circular":
                this._renderCircular(status);
                break;
            default:
                super._render(status);
                break;
        }
    }
    _renderCircular(status) {
        if (this.textVisible) {
            this._prerender(status);
            const interactive = this._isInteractive(status);
            const context = status.layer.context;
            const layerDirty = status.layer.dirty;
            const ghostContext = this._renderer._ghostLayer.context;
            // Savepoint
            context.save();
            if (interactive) {
                ghostContext.save();
            }
            // We need measurements in order to properly position text for alignment
            if (!this._textInfo) {
                this._measure(status);
            }
            // Init
            let radius = (this.radius || 0);
            let startAngle = (this.startAngle || 0);
            let deltaAngle = 0;
            let orientation = this.orientation;
            let inward = orientation == "auto" ? "auto" : orientation == "inward";
            const inside = this.inside;
            const align = this.style.textAlign || "left";
            const kerning = this.kerning || 0;
            let clockwise = align == "left" ? 1 : -1;
            const shouldReverse = !this._textReversed;
            // Check if we need to invert the whole stuff
            if (inward == "auto") {
                // Calc max angle so we know whether we need to flip it
                let maxAngle = 0;
                let midAngle = 0;
                _util_Array__WEBPACK_IMPORTED_MODULE_2__.each(this._textInfo, (line, _index) => {
                    const deltaAngle = startAngle + (line.width / (radius - line.height)) / 2 * -clockwise;
                    if (deltaAngle > maxAngle) {
                        maxAngle = deltaAngle;
                    }
                });
                if (align == "left") {
                    midAngle = (maxAngle + deltaAngle / 2) * _util_Math__WEBPACK_IMPORTED_MODULE_5__.DEGREES;
                }
                else if (align == "right") {
                    midAngle = (maxAngle - deltaAngle / 2) * _util_Math__WEBPACK_IMPORTED_MODULE_5__.DEGREES;
                }
                else {
                    midAngle = startAngle * _util_Math__WEBPACK_IMPORTED_MODULE_5__.DEGREES;
                }
                midAngle = _util_Math__WEBPACK_IMPORTED_MODULE_5__.normalizeAngle(midAngle);
                inward = (midAngle >= 270) || (midAngle <= 90);
            }
            if (inward == true && shouldReverse) {
                this._textInfo.reverse();
                this._textReversed = true;
            }
            // if ((inward == false && align == "left") || (inward == true && align == "right")) {
            // 	clockwise *= -1;
            // }
            // Process text info produced by _measure()
            _util_Array__WEBPACK_IMPORTED_MODULE_2__.each(this._textInfo, (line, _index) => {
                const textHeight = line.height;
                // Adjust radius (for `inside = false`)
                // Radius adjustment for `inside = false` is below the line calculation
                if (!inside) {
                    radius += textHeight;
                }
                // Reverse letters if we're painting them counter-clockwise
                if (((clockwise == -1 && inward) || (clockwise == 1 && !inward)) && shouldReverse) {
                    line.textChunks.reverse();
                }
                // Init angles
                let lineStartAngle = startAngle;
                deltaAngle = 0;
                // Adjust for center-align
                if (align == "center") {
                    lineStartAngle += (line.width / (radius - textHeight)) / 2 * -clockwise;
                    deltaAngle = lineStartAngle - startAngle;
                }
                // if (inward == "auto") {
                // 	let midAngle;
                // 	if (align == "left") {
                // 		midAngle = (lineStartAngle + deltaAngle / 2) * $math.DEGREES;
                // 	}
                // 	else if () {
                // 		midAngle = (lineStartAngle - deltaAngle / 2) * $math.DEGREES;
                // 	}
                // 	inward = (midAngle >= 270) || (midAngle <= 90);
                // }
                // Rotate letters if they are facing outward
                lineStartAngle += (Math.PI * (inward ? 0 : 1)); // Rotate 180 if outward
                // Savepoint
                context.save();
                if (interactive) {
                    ghostContext.save();
                }
                // Assume starting angle
                context.rotate(lineStartAngle);
                if (interactive) {
                    ghostContext.rotate(lineStartAngle);
                }
                let angleShift = 0;
                _util_Array__WEBPACK_IMPORTED_MODULE_2__.each(line.textChunks, (chunk, _index) => {
                    // Draw the letter
                    const char = chunk.text;
                    const charWidth = chunk.width;
                    // Rotate half a letter
                    angleShift = (charWidth / 2) / (radius - textHeight) * clockwise;
                    context.rotate(angleShift);
                    if (interactive) {
                        ghostContext.rotate(angleShift);
                    }
                    // Set style
                    if (chunk.style) {
                        context.save();
                        ghostContext.save();
                        context.font = chunk.style;
                        if (interactive) {
                            ghostContext.font = chunk.style;
                        }
                    }
                    if (chunk.fill) {
                        context.save();
                        context.fillStyle = chunk.fill.toCSS();
                        // Color does not affect ghostContext so we not set it
                    }
                    // Center letters
                    context.textBaseline = "middle";
                    context.textAlign = "center";
                    if (interactive) {
                        ghostContext.textBaseline = "middle";
                        ghostContext.textAlign = "center";
                    }
                    // Plop the letter
                    if (layerDirty) {
                        context.fillText(char, 0, (inward ? 1 : -1) * (0 - radius + textHeight / 2));
                    }
                    if (interactive) {
                        ghostContext.fillText(char, 0, (inward ? 1 : -1) * (0 - radius + textHeight / 2));
                    }
                    if (chunk.fill) {
                        context.restore();
                        // Color does not affect ghostContext so we not set it
                    }
                    // Reset style
                    if (chunk.style) {
                        context.restore();
                        ghostContext.restore();
                    }
                    // Rotate half a letter and add spacing
                    angleShift = (charWidth / 2 + kerning) / (radius - textHeight) * clockwise;
                    context.rotate(angleShift);
                    if (interactive) {
                        ghostContext.rotate(angleShift);
                    }
                });
                // Restore angle
                context.restore();
                if (interactive) {
                    ghostContext.restore();
                }
                // Adjust radius (for `inside = true`)
                if (inside) {
                    radius -= textHeight;
                }
            });
            // Restore
            context.restore();
            if (interactive) {
                ghostContext.restore();
            }
        }
    }
    _measure(status) {
        switch (this.textType) {
            case "circular":
                return this._measureCircular(status);
            default:
                return super._measure(status);
        }
    }
    _measureCircular(status) {
        const context = status.layer.context;
        const ghostContext = this._renderer._ghostLayer.context;
        const rtl = this.style.direction == "rtl";
        const oversizedBehavior = this.style.oversizedBehavior;
        const maxWidth = this.style.maxWidth;
        const truncate = _util_Type__WEBPACK_IMPORTED_MODULE_8__.isNumber(maxWidth) && oversizedBehavior == "truncate";
        const ellipsis = this.style.ellipsis || "";
        let ellipsisMetrics;
        //const wrap = $type.isNumber(maxWidth) && (oversizedBehavior == "wrap" || oversizedBehavior == "wrap-no-break");
        // Reset text info
        this.textVisible = true;
        this._textInfo = [];
        this._textReversed = false;
        // Pre-render
        context.save();
        ghostContext.save();
        this._prerender(status, true);
        // Split up text into lines
        const lines = this.text.toString().replace(/\r/g, "").split(/\n/);
        let styleRestored = true;
        let totalWidth = 0;
        // Iterate through the lines
        let offsetY = 0;
        _util_Array__WEBPACK_IMPORTED_MODULE_2__.each(lines, (line, _index) => {
            // Split up line into format/value chunks
            let chunks = _util_TextFormatter__WEBPACK_IMPORTED_MODULE_9__.TextFormatter.chunk(line, false, this.style.ignoreFormatting);
            // Init line object
            let lineInfo = {
                offsetY: offsetY,
                ascent: 0,
                width: 0,
                height: 0,
                left: 0,
                right: 0,
                textChunks: []
            };
            let currentStyle;
            let currentFill;
            let currentChunkWidth;
            //while(chunk = chunks.shift()) {
            _util_Array__WEBPACK_IMPORTED_MODULE_2__.each(chunks, (chunk, _index) => {
                // Format chunk
                if (chunk.type == "format") {
                    if (chunk.text == "[/]") {
                        if (!styleRestored) {
                            context.restore();
                            ghostContext.restore();
                            styleRestored = true;
                        }
                        currentFill = undefined;
                        currentStyle = undefined;
                        currentChunkWidth = undefined;
                    }
                    else {
                        let format = _util_TextFormatter__WEBPACK_IMPORTED_MODULE_9__.TextFormatter.getTextStyle(chunk.text);
                        const fontStyle = this._getFontStyle(format);
                        context.save();
                        ghostContext.save();
                        context.font = fontStyle;
                        currentStyle = fontStyle;
                        if (format.fill) {
                            currentFill = format.fill;
                        }
                        if (format.width) {
                            currentChunkWidth = _util_Type__WEBPACK_IMPORTED_MODULE_8__.toNumber(format.width);
                        }
                        styleRestored = false;
                    }
                    if (truncate) {
                        ellipsisMetrics = this._measureText(ellipsis, context);
                    }
                }
                // Text format
                else if (chunk.type == "value") {
                    // Measure each letter
                    const chars = chunk.text.match(/./ug) || [];
                    if (rtl) {
                        chars.reverse();
                    }
                    for (let i = 0; i < chars.length; i++) {
                        const char = chars[i];
                        // Measure
                        const metrics = this._measureText(char, context);
                        let chunkWidth = metrics.width;
                        // Chunk width?
                        if (currentStyle && currentChunkWidth && (currentChunkWidth > chunkWidth)) {
                            chunkWidth = currentChunkWidth;
                        }
                        const chunkHeight = metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent;
                        if (chunkHeight > lineInfo.height) {
                            lineInfo.height = chunkHeight;
                        }
                        if (metrics.actualBoundingBoxAscent > lineInfo.ascent) {
                            lineInfo.ascent = metrics.actualBoundingBoxAscent;
                        }
                        totalWidth += chunkWidth;
                        // Handle oversized behavior
                        if (truncate) {
                            // Measure ellipsis and check if it fits
                            if (!ellipsisMetrics) {
                                ellipsisMetrics = this._measureText(ellipsis, context);
                            }
                            const ellipsisWidth = ellipsisMetrics.actualBoundingBoxLeft + ellipsisMetrics.actualBoundingBoxRight;
                            //totalWidth += ellipsisWidth;
                            if ((totalWidth + ellipsisWidth) > maxWidth) {
                                if (lineInfo.textChunks.length == 1) {
                                    this.textVisible = false;
                                }
                                else {
                                    lineInfo.width += ellipsisWidth;
                                    lineInfo.left += ellipsisMetrics.actualBoundingBoxLeft;
                                    lineInfo.right += ellipsisMetrics.actualBoundingBoxRight;
                                    lineInfo.textChunks.push({
                                        style: currentStyle,
                                        fill: currentFill,
                                        text: ellipsis,
                                        width: ellipsisWidth,
                                        height: chunkHeight + ellipsisMetrics.actualBoundingBoxDescent,
                                        left: ellipsisMetrics.actualBoundingBoxLeft,
                                        right: ellipsisMetrics.actualBoundingBoxRight,
                                        ascent: ellipsisMetrics.actualBoundingBoxAscent,
                                        offsetX: 0,
                                        offsetY: chunkHeight,
                                        textDecoration: undefined
                                    });
                                }
                                break;
                            }
                        }
                        lineInfo.width += chunkWidth;
                        lineInfo.left += metrics.actualBoundingBoxLeft;
                        lineInfo.right += metrics.actualBoundingBoxRight;
                        lineInfo.textChunks.push({
                            style: currentStyle,
                            fill: currentFill,
                            text: char,
                            width: chunkWidth,
                            height: chunkHeight + metrics.actualBoundingBoxDescent,
                            left: metrics.actualBoundingBoxLeft,
                            right: metrics.actualBoundingBoxRight,
                            ascent: metrics.actualBoundingBoxAscent,
                            offsetX: 0,
                            offsetY: chunkHeight,
                            textDecoration: undefined
                        });
                        if (rtl) {
                            break;
                        }
                    }
                }
            });
            if (this.style.lineHeight instanceof _util_Percent__WEBPACK_IMPORTED_MODULE_10__.Percent) {
                lineInfo.height *= this.style.lineHeight.value;
            }
            else {
                lineInfo.height *= this.style.lineHeight || 1.2;
            }
            this._textInfo.push(lineInfo);
            //lineInfo.offsetY += lineInfo.ascent;
            offsetY += lineInfo.height;
        });
        if (!styleRestored) {
            context.restore();
            ghostContext.restore();
        }
        if (oversizedBehavior == "hide" && (totalWidth > maxWidth)) {
            this.textVisible = false;
        }
        // Adjust chunk internal offsets
        _util_Array__WEBPACK_IMPORTED_MODULE_2__.each(this._textInfo, (lineInfo) => {
            _util_Array__WEBPACK_IMPORTED_MODULE_2__.each(lineInfo.textChunks, (chunk) => {
                chunk.offsetY += Math.round((lineInfo.height - chunk.height + (lineInfo.ascent - chunk.ascent)) / 2);
            });
        });
        context.restore();
        ghostContext.restore();
        return {
            left: 0,
            top: 0,
            right: 0,
            bottom: 0,
        };
    }
}
/**
 * @ignore
 */
class CanvasImage extends CanvasDisplayObject {
    constructor(renderer, image) {
        super(renderer);
        Object.defineProperty(this, "width", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "height", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "image", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "tainted", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "shadowColor", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "shadowBlur", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "shadowOffsetX", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "shadowOffsetY", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "shadowOpacity", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_imageMask", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.image = image;
    }
    _dispose() {
        super._dispose();
        if (this._imageMask) {
            clearCanvas(this._imageMask);
        }
    }
    getLocalBounds() {
        if (!this._localBounds) {
            let w = 0;
            let h = 0;
            if (this.width) {
                w = this.width;
            }
            if (this.height) {
                h = this.height;
            }
            this._localBounds = {
                left: 0,
                top: 0,
                right: w,
                bottom: h
            };
            this._addBounds(this._localBounds);
        }
        return this._localBounds;
    }
    _render(status) {
        super._render(status);
        if (this.image) {
            if (this.tainted === undefined) {
                this.tainted = isTainted(this.image);
                status.layer.tainted = true;
            }
            if (this.tainted && this._renderer._omitTainted) {
                return;
            }
            if (status.layer.dirty) {
                if (this.shadowColor) {
                    status.layer.context.shadowColor = this.shadowColor.toCSS(this.shadowOpacity || 1);
                }
                if (this.shadowBlur) {
                    status.layer.context.shadowBlur = this.shadowBlur;
                }
                if (this.shadowOffsetX) {
                    status.layer.context.shadowOffsetX = this.shadowOffsetX;
                }
                if (this.shadowOffsetY) {
                    status.layer.context.shadowOffsetY = this.shadowOffsetY;
                }
                // TODO should this round ?
                const width = this.width || this.image.naturalWidth;
                const height = this.height || this.image.naturalHeight;
                status.layer.context.drawImage(this.image, 0, 0, width, height);
            }
            if (this.interactive && this._isInteractive(status)) {
                const mask = this._getMask(this.image);
                this._renderer._ghostLayer.context.drawImage(mask, 0, 0);
            }
        }
    }
    clear() {
        super.clear();
        this.image = undefined;
        this._imageMask = undefined;
    }
    _getMask(image) {
        if (this._imageMask === undefined) {
            // TODO should this round ?
            const width = this.width || image.naturalWidth;
            const height = this.height || image.naturalHeight;
            // We need to create a second canvas because destination-in clears out the entire canvas
            const canvas = document.createElement("canvas");
            canvas.width = width;
            canvas.height = height;
            const context = canvas.getContext("2d");
            context.imageSmoothingEnabled = false;
            context.fillStyle = this._getColorId();
            context.fillRect(0, 0, width, height);
            if (!isTainted(image)) {
                context.globalCompositeOperation = "destination-in";
                context.drawImage(image, 0, 0, width, height);
            }
            this._imageMask = canvas;
        }
        return this._imageMask;
    }
}
/**
 * @ignore
 */
class CanvasRendererEvent {
    constructor(event, originalPoint, point, bbox) {
        Object.defineProperty(this, "event", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: event
        });
        Object.defineProperty(this, "originalPoint", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: originalPoint
        });
        Object.defineProperty(this, "point", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: point
        });
        Object.defineProperty(this, "bbox", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: bbox
        });
        Object.defineProperty(this, "id", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "simulated", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        Object.defineProperty(this, "native", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: true
        });
        if (_util_Utils__WEBPACK_IMPORTED_MODULE_1__.supports("touchevents") && event instanceof Touch) {
            this.id = event.identifier;
        }
        else {
            this.id = null;
        }
    }
}
/**
 * @ignore
 */
class CanvasRenderer extends _util_Disposer__WEBPACK_IMPORTED_MODULE_3__.ArrayDisposer {
    /*protected _mouseMoveThrottler: Throttler = new Throttler(() => {
        this._dispatchGlobalMousemove(this._lastPointerMoveEvent.event, this._lastPointerMoveEvent.native);
    });
    */
    constructor(resolution) {
        super();
        Object.defineProperty(this, "view", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: document.createElement("div")
        });
        Object.defineProperty(this, "_layerDom", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: document.createElement("div")
        });
        Object.defineProperty(this, "layers", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
        });
        Object.defineProperty(this, "_dirtyLayers", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
        });
        Object.defineProperty(this, "defaultLayer", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: this.getLayer(0)
        });
        Object.defineProperty(this, "_ghostLayer", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new GhostLayer()
        });
        Object.defineProperty(this, "_patternCanvas", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: document.createElement("canvas")
        });
        Object.defineProperty(this, "_patternContext", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: this._patternCanvas.getContext("2d")
        });
        Object.defineProperty(this, "_realWidth", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        Object.defineProperty(this, "_realHeight", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        Object.defineProperty(this, "_calculatedWidth", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        Object.defineProperty(this, "_calculatedHeight", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        Object.defineProperty(this, "resolution", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "interactionsEnabled", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: true
        });
        Object.defineProperty(this, "_listeners", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {}
        });
        Object.defineProperty(this, "_events", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {}
        });
        Object.defineProperty(this, "_colorId", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        Object.defineProperty(this, "_colorMap", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {}
        });
        Object.defineProperty(this, "_forceInteractive", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        Object.defineProperty(this, "_omitTainted", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        // TODO this should store the Id as well
        Object.defineProperty(this, "_hovering", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new Set()
        });
        Object.defineProperty(this, "_dragging", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
        });
        Object.defineProperty(this, "_mousedown", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
        });
        Object.defineProperty(this, "_lastPointerMoveEvent", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "tapToActivate", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        Object.defineProperty(this, "tapToActivateTimeout", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 3000
        });
        Object.defineProperty(this, "_touchActive", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        Object.defineProperty(this, "_touchActiveTimeout", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        if (resolution == null) {
            this.resolution = window.devicePixelRatio;
        }
        else {
            this.resolution = resolution;
        }
        this.view.style.position = "absolute";
        this.view.setAttribute("aria-hidden", "true");
        this.view.appendChild(this._layerDom);
        this._disposers.push(new _util_Disposer__WEBPACK_IMPORTED_MODULE_3__.Disposer(() => {
            _util_Object__WEBPACK_IMPORTED_MODULE_11__.each(this._events, (_key, events) => {
                events.disposer.dispose();
            });
            _util_Array__WEBPACK_IMPORTED_MODULE_2__.each(this.layers, (layer) => {
                clearCanvas(layer.view);
                if (layer.exportableView) {
                    clearCanvas(layer.exportableView);
                }
            });
            clearCanvas(this._ghostLayer.view);
            clearCanvas(this._patternCanvas);
        }));
        /*
        this._disposers.push($utils.addEventListener(this._ghostLayer.view, "click", (originalEvent: MouseEvent) => {
            const event = this.getEvent(originalEvent);
            const target = this._getHitTarget(event.originalPoint, event.bbox);
            console.debug(target);
        }));
        */
        // Monitor for possible pixel ratio changes (when page is zoomed)
        this._disposers.push(_util_Utils__WEBPACK_IMPORTED_MODULE_1__.onZoom(() => {
            if (resolution == null) {
                this.resolution = window.devicePixelRatio;
            }
        }));
        // We need this in order top prevent default touch gestures when dragging
        // draggable elements
        if (_util_Utils__WEBPACK_IMPORTED_MODULE_1__.supports("touchevents")) {
            const listener = (ev) => {
                if (this._dragging.length !== 0) {
                    _util_Array__WEBPACK_IMPORTED_MODULE_2__.eachContinue(this._dragging, (item) => {
                        if (item.value.shouldCancelTouch()) {
                            ev.preventDefault();
                            return false;
                        }
                        return true;
                    });
                }
                // If touch down happends, delay touch out
                if (this._touchActiveTimeout) {
                    this._delayTouchDeactivate();
                }
            };
            this._disposers.push(_util_Utils__WEBPACK_IMPORTED_MODULE_1__.addEventListener(window, "touchstart", listener, { passive: false }));
            this._disposers.push(_util_Utils__WEBPACK_IMPORTED_MODULE_1__.addEventListener(this.view, "touchstart", listener, { passive: false }));
            this._disposers.push(_util_Utils__WEBPACK_IMPORTED_MODULE_1__.addEventListener(this.view, "touchmove", () => {
                // If touch is moving, delay touch out
                if (this._touchActiveTimeout) {
                    this._delayTouchDeactivate();
                }
            }, { passive: true }));
            this._disposers.push(_util_Utils__WEBPACK_IMPORTED_MODULE_1__.addEventListener(window, "click", (_ev) => {
                this._touchActive = false;
            }, { passive: true }));
            this._disposers.push(_util_Utils__WEBPACK_IMPORTED_MODULE_1__.addEventListener(this.view, "click", (_ev) => {
                window.setTimeout(() => {
                    this._touchActive = true;
                    this._delayTouchDeactivate();
                }, 100);
            }, { passive: true }));
        }
        // Prevent scrolling of the window when hovering on "wheelable" object
        if (_util_Utils__WEBPACK_IMPORTED_MODULE_1__.supports("wheelevents")) {
            this._disposers.push(_util_Utils__WEBPACK_IMPORTED_MODULE_1__.addEventListener(this.view, "wheel", (ev) => {
                let prevent = false;
                this._hovering.forEach((obj) => {
                    if (obj.wheelable) {
                        prevent = true;
                        return false;
                    }
                });
                if (prevent) {
                    ev.preventDefault();
                }
            }, { passive: false }));
        }
    }
    _delayTouchDeactivate() {
        if (this._touchActiveTimeout) {
            clearTimeout(this._touchActiveTimeout);
        }
        if (this.tapToActivateTimeout > 0) {
            this._touchActiveTimeout = window.setTimeout(() => {
                this._touchActive = false;
            }, this.tapToActivateTimeout);
        }
    }
    get debugGhostView() {
        return !!this._ghostLayer.view.parentNode;
    }
    set debugGhostView(value) {
        if (value) {
            if (!this._ghostLayer.view.parentNode) {
                this.view.appendChild(this._ghostLayer.view);
            }
        }
        else {
            if (this._ghostLayer.view.parentNode) {
                this._ghostLayer.view.parentNode.removeChild(this._ghostLayer.view);
            }
        }
    }
    createLinearGradient(x1, y1, x2, y2) {
        return this.defaultLayer.context.createLinearGradient(x1, y1, x2, y2);
    }
    createRadialGradient(x1, y1, radius1, x2, y2, radius2) {
        return this.defaultLayer.context.createRadialGradient(x1, y1, radius1, x2, y2, radius2);
    }
    createPattern(graphics, background, repetition, width, height) {
        // const patternCanvas = document.createElement("canvas");
        // const patternContext = patternCanvas.getContext("2d")!;
        // patternCanvas.width = width;
        // patternCanvas.height = height;
        // if (fill) {
        // 	patternContext.fillStyle = fill.toCSS();
        // 	patternContext.fillRect(0, 0, patternCanvas.width, patternCanvas.height);
        // }
        // const layer = {
        // 	view: patternCanvas,
        // 	context: patternContext,
        // 	visible: true,
        // 	order: 0,
        // 	width: width,
        // 	height: height,
        // 	dirty: true
        // };
        // // patternContext.arc(0, 0, 50, 0, .5 * Math.PI);
        // // patternContext.stroke();
        // image.targetLayer = layer;
        // image.render(layer);
        //this._layerDom.appendChild(patternCanvas);
        this._patternCanvas.width = width;
        this._patternCanvas.height = height;
        this._patternContext.clearRect(0, 0, width, height);
        // patternCanvas.style.width = width * this.resolution + "px";
        // patternCanvas.style.height = height * this.resolution + "px";
        background.renderDetached(this._patternContext);
        graphics.renderDetached(this._patternContext);
        return this._patternContext.createPattern(this._patternCanvas, repetition);
    }
    makeContainer() {
        return new CanvasContainer(this);
    }
    makeGraphics() {
        return new CanvasGraphics(this);
    }
    makeText(text, style) {
        return new CanvasText(this, text, style);
    }
    makeTextStyle() {
        return new CanvasTextStyle();
    }
    makeRadialText(text, style) {
        return new CanvasRadialText(this, text, style);
    }
    makePicture(image) {
        return new CanvasImage(this, image);
    }
    resizeLayer(layer) {
        layer.resize(this._calculatedWidth, this._calculatedHeight, this._calculatedWidth, this._calculatedHeight, this.resolution);
    }
    resizeGhost() {
        this._ghostLayer.resize(this._calculatedWidth, this._calculatedHeight, this._calculatedWidth, this._calculatedHeight, this.resolution);
    }
    resize(realWidth, realHeight, calculatedWidth, calculatedHeight) {
        this._realWidth = realWidth;
        this._realHeight = realHeight;
        this._calculatedWidth = calculatedWidth;
        this._calculatedHeight = calculatedHeight;
        _util_Array__WEBPACK_IMPORTED_MODULE_2__.each(this.layers, (layer) => {
            if (layer) {
                layer.dirty = true;
                this.resizeLayer(layer);
            }
        });
        this.resizeGhost();
        this.view.style.width = calculatedWidth + "px";
        this.view.style.height = calculatedHeight + "px";
    }
    createDetachedLayer(willReadFrequently = false) {
        const view = document.createElement("canvas");
        const context = view.getContext("2d", { willReadFrequently: willReadFrequently });
        const layer = new CanvasLayer(view, context);
        view.style.position = "absolute";
        view.style.top = "0px";
        view.style.left = "0px";
        return layer;
    }
    getLayerByOrder(order) {
        const layers = this.layers;
        const length = layers.length;
        for (let i = 0; i < length; i++) {
            const layer = layers[i];
            if (layer.order == order) {
                return layer;
            }
        }
    }
    getLayer(order, visible = true) {
        let existingLayer = this.getLayerByOrder(order);
        if (existingLayer) {
            return existingLayer;
        }
        const layer = this.createDetachedLayer(order == 99);
        layer.order = order;
        layer.visible = visible;
        layer.view.className = "am5-layer-" + order;
        if (layer.visible) {
            this.resizeLayer(layer);
        }
        const layers = this.layers;
        layers.push(layer);
        layers.sort((a, b) => {
            if (a.order > b.order) {
                return 1;
            }
            else if (a.order < b.order) {
                return -1;
            }
            else {
                return 0;
            }
        });
        const length = layers.length;
        const layerIndex = _util_Array__WEBPACK_IMPORTED_MODULE_2__.indexOf(layers, layer);
        let next;
        for (let i = layerIndex + 1; i < length; i++) {
            if (layers[i].visible) {
                next = layers[i];
                break;
            }
        }
        if (layer.visible) {
            if (next === undefined) {
                this._layerDom.appendChild(layer.view);
            }
            else {
                this._layerDom.insertBefore(layer.view, next.view);
            }
        }
        return layer;
    }
    render(root) {
        this._dirtyLayers.length = 0;
        _util_Array__WEBPACK_IMPORTED_MODULE_2__.each(this.layers, (layer) => {
            if (layer) {
                if (layer.dirty && layer.visible) {
                    this._dirtyLayers.push(layer);
                    layer.clear();
                }
            }
        });
        this._ghostLayer.clear();
        root.render({
            inactive: null,
            layer: this.defaultLayer,
        });
        this._ghostLayer.context.restore();
        //setTimeout(() => {
        // Remove this after the Chrome bug is fixed:
        // https://bugs.chromium.org/p/chromium/issues/detail?id=1279394
        _util_Array__WEBPACK_IMPORTED_MODULE_2__.each(this.layers, (layer) => {
            if (layer) {
                const context = layer.context;
                context.beginPath();
                context.moveTo(0, 0);
                context.stroke();
            }
        });
        _util_Array__WEBPACK_IMPORTED_MODULE_2__.each(this._dirtyLayers, (layer) => {
            layer.context.restore();
            layer.dirty = false;
        });
        //}, 100)
        if (this._hovering.size && this._lastPointerMoveEvent) {
            const { events, target, native } = this._lastPointerMoveEvent;
            //this._mouseMoveThrottler.run();
            _util_Array__WEBPACK_IMPORTED_MODULE_2__.each(events, (event) => {
                this._dispatchGlobalMousemove(event, target, native);
            });
        }
    }
    paintId(obj) {
        const id = distributeId(++this._colorId);
        const color = _util_Color__WEBPACK_IMPORTED_MODULE_7__.Color.fromHex(id).toCSS();
        this._colorMap[color] = obj;
        return color;
    }
    _removeObject(obj) {
        if (obj._colorId !== undefined) {
            delete this._colorMap[obj._colorId];
        }
    }
    // protected _identifyObjectByColor(colorId: number): CanvasDisplayObject | undefined {
    // 	return this._colorMap[colorId];
    // }
    _adjustBoundingBox(bbox) {
        const margin = this._ghostLayer.margin;
        return new DOMRect(-margin.left, -margin.top, bbox.width + margin.left + margin.right, bbox.height + margin.top + margin.bottom);
    }
    getEvent(originalEvent, adjustPoint = true) {
        const bbox = this.view.getBoundingClientRect();
        const x = originalEvent.clientX || 0;
        const y = originalEvent.clientY || 0;
        const widthScale = this._calculatedWidth / this._realWidth;
        const heightScale = this._calculatedHeight / this._realHeight;
        const originalPoint = {
            x: x - bbox.left,
            y: y - bbox.top,
        };
        const point = {
            x: (x - (adjustPoint ? bbox.left : 0)) * widthScale,
            y: (y - (adjustPoint ? bbox.top : 0)) * heightScale,
        };
        return new CanvasRendererEvent(originalEvent, originalPoint, point, this._adjustBoundingBox(bbox));
    }
    _getHitTarget(point, bbox, target) {
        if (bbox.width === 0 || bbox.height === 0 || point.x < bbox.left || point.x > bbox.right || point.y < bbox.top || point.y > bbox.bottom) {
            return;
        }
        if (!target || !this._layerDom.contains(target)) {
            return;
        }
        const pixel = this._ghostLayer.getImageData(point, bbox);
        if (pixel.data[0] === 0 && pixel.data[1] === 0 && pixel.data[2] === 0) {
            return false;
        }
        const colorId = _util_Color__WEBPACK_IMPORTED_MODULE_7__.Color.fromRGB(pixel.data[0], pixel.data[1], pixel.data[2]).toCSS();
        const hit = this._colorMap[colorId];
        return hit;
    }
    _withEvents(key, f) {
        const events = this._events[key];
        if (events !== undefined) {
            events.dispatching = true;
            try {
                f(events);
            }
            finally {
                events.dispatching = false;
                if (events.cleanup) {
                    events.cleanup = false;
                    _util_Array__WEBPACK_IMPORTED_MODULE_2__.keepIf(events.callbacks, (callback) => {
                        return !callback.disposed;
                    });
                    if (events.callbacks.length === 0) {
                        events.disposer.dispose();
                        delete this._events[key];
                    }
                }
            }
        }
    }
    _dispatchEventAll(key, event) {
        if (!this.interactionsEnabled) {
            return;
        }
        this._withEvents(key, (events) => {
            _util_Array__WEBPACK_IMPORTED_MODULE_2__.each(events.callbacks, (callback) => {
                if (!callback.disposed) {
                    callback.callback.call(callback.context, event);
                }
            });
        });
    }
    _dispatchEvent(key, target, event) {
        if (!this.interactionsEnabled) {
            return false;
        }
        let dispatched = false;
        this._withEvents(key, (events) => {
            _util_Array__WEBPACK_IMPORTED_MODULE_2__.each(events.callbacks, (callback) => {
                if (!callback.disposed && callback.object === target) {
                    callback.callback.call(callback.context, event);
                    dispatched = true;
                }
            });
        });
        return dispatched;
    }
    _dispatchMousedown(originalEvent, originalTarget) {
        const button = originalEvent.button;
        if (button != 0 && button != 2 && button != 1 && button !== undefined) {
            // Ignore non-primary mouse buttons
            return;
        }
        const event = this.getEvent(originalEvent);
        const target = this._getHitTarget(event.originalPoint, event.bbox, originalTarget);
        if (target) {
            const id = event.id;
            let dragged = false;
            eachTargets(target, (obj) => {
                const info = { id: id, value: obj };
                this._mousedown.push(info);
                if (!dragged && this._dispatchEvent("pointerdown", obj, event)) {
                    // Only dispatch the first element which matches
                    dragged = true;
                    const has = this._dragging.some((x) => {
                        return x.value === obj && x.id === id;
                    });
                    if (!has) {
                        this._dragging.push(info);
                    }
                }
                return true;
            });
        }
    }
    _dispatchGlobalMousemove(originalEvent, originalTarget, native) {
        const event = this.getEvent(originalEvent);
        const target = this._getHitTarget(event.originalPoint, event.bbox, originalTarget);
        event.native = native;
        if (target) {
            this._hovering.forEach((obj) => {
                if (!obj.contains(target)) {
                    this._hovering.delete(obj);
                    if (obj.cursorOverStyle) {
                        _util_Utils__WEBPACK_IMPORTED_MODULE_1__.setStyle(document.body, "cursor", obj._replacedCursorStyle);
                    }
                    this._dispatchEvent("pointerout", obj, event);
                }
            });
            if (event.native) {
                eachTargets(target, (obj) => {
                    if (!this._hovering.has(obj)) {
                        this._hovering.add(obj);
                        if (obj.cursorOverStyle) {
                            obj._replacedCursorStyle = _util_Utils__WEBPACK_IMPORTED_MODULE_1__.getStyle(document.body, "cursor");
                            _util_Utils__WEBPACK_IMPORTED_MODULE_1__.setStyle(document.body, "cursor", obj.cursorOverStyle);
                        }
                        this._dispatchEvent("pointerover", obj, event);
                    }
                    return true;
                });
            }
            //} else if (target === false) {
        }
        else {
            this._hovering.forEach((obj) => {
                if (obj.cursorOverStyle) {
                    _util_Utils__WEBPACK_IMPORTED_MODULE_1__.setStyle(document.body, "cursor", obj._replacedCursorStyle);
                }
                this._dispatchEvent("pointerout", obj, event);
            });
            this._hovering.clear();
        }
        this._dispatchEventAll("globalpointermove", event);
    }
    removeHovering(graphics) {
        this._hovering.delete(graphics);
        if (graphics.cursorOverStyle) {
            _util_Utils__WEBPACK_IMPORTED_MODULE_1__.setStyle(document.body, "cursor", graphics._replacedCursorStyle);
        }
    }
    _dispatchGlobalMouseup(originalEvent, native) {
        const event = this.getEvent(originalEvent);
        event.native = native;
        //const target = this._getHitTarget(event.originalPoint);
        this._dispatchEventAll("globalpointerup", event);
    }
    _dispatchDragMove(originalEvent) {
        if (this._dragging.length !== 0) {
            const event = this.getEvent(originalEvent);
            const id = event.id;
            this._dragging.forEach((obj) => {
                if (obj.id === id) {
                    this._dispatchEvent("pointermove", obj.value, event);
                }
            });
        }
    }
    _dispatchDragEnd(originalEvent, originalTarget) {
        const button = originalEvent.button;
        let clickevent;
        if (button == 0 || button === undefined) {
            clickevent = "click";
        }
        else if (button == 2) {
            clickevent = "rightclick";
        }
        else if (button == 1) {
            clickevent = "middleclick";
        }
        else {
            // Ignore non-primary mouse buttons
            return;
        }
        const event = this.getEvent(originalEvent);
        const id = event.id;
        if (this._mousedown.length !== 0) {
            const target = this._getHitTarget(event.originalPoint, event.bbox, originalTarget);
            if (target) {
                this._mousedown.forEach((obj) => {
                    if (obj.id === id && obj.value.contains(target)) {
                        this._dispatchEvent(clickevent, obj.value, event);
                    }
                });
            }
            this._mousedown.length = 0;
        }
        if (this._dragging.length !== 0) {
            this._dragging.forEach((obj) => {
                if (obj.id === id) {
                    this._dispatchEvent("pointerup", obj.value, event);
                }
            });
            this._dragging.length = 0;
        }
    }
    _dispatchDoubleClick(originalEvent, originalTarget) {
        const event = this.getEvent(originalEvent);
        const target = this._getHitTarget(event.originalPoint, event.bbox, originalTarget);
        if (target) {
            eachTargets(target, (obj) => {
                if (this._dispatchEvent("dblclick", obj, event)) {
                    return false;
                }
                else {
                    return true;
                }
            });
        }
    }
    _dispatchWheel(originalEvent, originalTarget) {
        const event = this.getEvent(originalEvent);
        const target = this._getHitTarget(event.originalPoint, event.bbox, originalTarget);
        if (target) {
            eachTargets(target, (obj) => {
                if (this._dispatchEvent("wheel", obj, event)) {
                    return false;
                }
                else {
                    return true;
                }
            });
        }
    }
    _makeSharedEvent(key, f) {
        if (this._listeners[key] === undefined) {
            const listener = f();
            this._listeners[key] = new _util_Disposer__WEBPACK_IMPORTED_MODULE_3__.CounterDisposer(() => {
                delete this._listeners[key];
                listener.dispose();
            });
        }
        return this._listeners[key].increment();
    }
    _onPointerEvent(name, f) {
        let native = false;
        let timer = null;
        function clear() {
            timer = null;
            native = false;
        }
        return new _util_Disposer__WEBPACK_IMPORTED_MODULE_3__.MultiDisposer([
            new _util_Disposer__WEBPACK_IMPORTED_MODULE_3__.Disposer(() => {
                if (timer !== null) {
                    clearTimeout(timer);
                }
                clear();
            }),
            _util_Utils__WEBPACK_IMPORTED_MODULE_1__.addEventListener(this.view, _util_Utils__WEBPACK_IMPORTED_MODULE_1__.getRendererEvent(name), (_) => {
                native = true;
                if (timer !== null) {
                    clearTimeout(timer);
                }
                timer = window.setTimeout(clear, 0);
            }),
            onPointerEvent(window, name, (ev, target) => {
                if (timer !== null) {
                    clearTimeout(timer);
                    timer = null;
                }
                f(ev, target, native);
                native = false;
            }),
        ]);
    }
    // This ensures that only a single DOM event is added (e.g. only a single mousemove event listener)
    _initEvent(key) {
        switch (key) {
            case "globalpointermove":
            case "pointerover":
            case "pointerout":
                return this._makeSharedEvent("pointermove", () => {
                    const listener = (events, target, native) => {
                        this._lastPointerMoveEvent = { events, target, native };
                        _util_Array__WEBPACK_IMPORTED_MODULE_2__.each(events, (event) => {
                            this._dispatchGlobalMousemove(event, target, native);
                        });
                    };
                    return new _util_Disposer__WEBPACK_IMPORTED_MODULE_3__.MultiDisposer([
                        this._onPointerEvent("pointerdown", listener),
                        this._onPointerEvent("pointermove", listener),
                    ]);
                });
            case "globalpointerup":
                return this._makeSharedEvent("pointerup", () => {
                    const mouseup = this._onPointerEvent("pointerup", (events, target, native) => {
                        _util_Array__WEBPACK_IMPORTED_MODULE_2__.each(events, (event) => {
                            this._dispatchGlobalMouseup(event, native);
                        });
                        this._lastPointerMoveEvent = { events, target, native };
                    });
                    const pointercancel = this._onPointerEvent("pointercancel", (events, target, native) => {
                        _util_Array__WEBPACK_IMPORTED_MODULE_2__.each(events, (event) => {
                            this._dispatchGlobalMouseup(event, native);
                        });
                        this._lastPointerMoveEvent = { events, target, native };
                    });
                    return new _util_Disposer__WEBPACK_IMPORTED_MODULE_3__.Disposer(() => {
                        mouseup.dispose();
                        pointercancel.dispose();
                    });
                });
            case "click":
            case "rightclick":
            case "middleclick":
            case "pointerdown":
            /*
                return this._makeSharedEvent("pointerdown", () => {
                    return this._onPointerEvent("pointerdown", (event, target, native) => {
                        this._lastPointerMoveEvent = { event, target, native };
                        this._dispatchMousedown(event)
                    });
                });
            */
            case "pointermove":
            case "pointerup":
                return this._makeSharedEvent("pointerdown", () => {
                    //const throttler = new Throttler();
                    const mousedown = this._onPointerEvent("pointerdown", (events, target) => {
                        _util_Array__WEBPACK_IMPORTED_MODULE_2__.each(events, (ev) => {
                            this._dispatchMousedown(ev, target);
                        });
                    });
                    // TODO handle throttling properly for multitouch
                    const mousemove = this._onPointerEvent("pointermove", (ev) => {
                        //throttler.throttle(() => {
                        _util_Array__WEBPACK_IMPORTED_MODULE_2__.each(ev, (ev) => {
                            this._dispatchDragMove(ev);
                        });
                        //});
                    });
                    const mouseup = this._onPointerEvent("pointerup", (ev, target) => {
                        _util_Array__WEBPACK_IMPORTED_MODULE_2__.each(ev, (ev) => {
                            this._dispatchDragEnd(ev, target);
                        });
                    });
                    const pointercancel = this._onPointerEvent("pointercancel", (ev, target) => {
                        _util_Array__WEBPACK_IMPORTED_MODULE_2__.each(ev, (ev) => {
                            this._dispatchDragEnd(ev, target);
                        });
                    });
                    return new _util_Disposer__WEBPACK_IMPORTED_MODULE_3__.Disposer(() => {
                        mousedown.dispose();
                        mousemove.dispose();
                        mouseup.dispose();
                        pointercancel.dispose();
                    });
                });
            case "dblclick":
                return this._makeSharedEvent("dblclick", () => {
                    return this._onPointerEvent("dblclick", (ev, target) => {
                        _util_Array__WEBPACK_IMPORTED_MODULE_2__.each(ev, (ev) => {
                            this._dispatchDoubleClick(ev, target);
                        });
                    });
                });
            case "wheel":
                return this._makeSharedEvent("wheel", () => {
                    return _util_Utils__WEBPACK_IMPORTED_MODULE_1__.addEventListener(window, _util_Utils__WEBPACK_IMPORTED_MODULE_1__.getRendererEvent("wheel"), (event) => {
                        this._dispatchWheel(event, _util_Utils__WEBPACK_IMPORTED_MODULE_1__.getEventTarget(event));
                    }, { passive: false });
                });
        }
    }
    _addEvent(object, key, callback, context) {
        let events = this._events[key];
        if (events === undefined) {
            events = this._events[key] = {
                disposer: this._initEvent(key),
                callbacks: [],
                dispatching: false,
                cleanup: false,
            };
        }
        const listener = { object, context, callback, disposed: false };
        events.callbacks.push(listener);
        return new _util_Disposer__WEBPACK_IMPORTED_MODULE_3__.Disposer(() => {
            listener.disposed = true;
            if (events.dispatching) {
                events.cleanup = true;
            }
            else {
                _util_Array__WEBPACK_IMPORTED_MODULE_2__.removeFirst(events.callbacks, listener);
                if (events.callbacks.length === 0) {
                    events.disposer.dispose();
                    delete this._events[key];
                }
            }
        });
    }
    getCanvas(root, options) {
        // Make sure everything is rendered
        this.render(root);
        if (!options) {
            options = {};
        }
        let scale = this.resolution;
        let canvasWidth = Math.floor(this._calculatedWidth * this.resolution);
        let canvasHeight = Math.floor(this._calculatedHeight * this.resolution);
        // Check if we need to scale
        if (options.minWidth && (options.minWidth > canvasWidth)) {
            let minScale = options.minWidth / canvasWidth;
            if (minScale > scale) {
                scale = minScale * this.resolution;
            }
        }
        if (options.minHeight && (options.minHeight > canvasHeight)) {
            let minScale = options.minHeight / canvasHeight;
            if (minScale > scale) {
                scale = minScale * this.resolution;
            }
        }
        if (options.maxWidth && (options.maxWidth < canvasWidth)) {
            let maxScale = options.maxWidth / canvasWidth;
            if (maxScale < scale) {
                scale = maxScale * this.resolution;
            }
        }
        if (options.maxHeight && (options.maxHeight > canvasHeight)) {
            let maxScale = options.maxHeight / canvasHeight;
            if (maxScale < scale) {
                scale = maxScale * this.resolution;
            }
        }
        // Check if we need to compensate for pixel ratio
        if (options.maintainPixelRatio) {
            scale /= this.resolution;
        }
        // Init list canvases to remove from DOM after export
        const canvases = [];
        // Set up new canvas for export
        let forceRender = false;
        const canvas = document.createElement("canvas");
        if (scale != this.resolution) {
            forceRender = true;
            canvasWidth = canvasWidth * scale / this.resolution;
            canvasHeight = canvasHeight * scale / this.resolution;
        }
        canvas.width = canvasWidth;
        canvas.height = canvasHeight;
        // Add to DOM so it inherits CSS
        canvas.style.position = "fixed";
        canvas.style.top = "-10000px";
        this.view.appendChild(canvas);
        canvases.push(canvas);
        // Context
        const context = canvas.getContext("2d");
        let width = 0;
        let height = 0;
        let needRerender = false;
        _util_Array__WEBPACK_IMPORTED_MODULE_2__.each(this.layers, (layer) => {
            if (layer && layer.visible) {
                if (layer.tainted || forceRender) {
                    needRerender = true;
                    layer.exportableView = layer.view;
                    layer.exportableContext = layer.context;
                    layer.view = document.createElement("canvas");
                    // Add to DOM so it inherits CSS
                    layer.view.style.position = "fixed";
                    layer.view.style.top = "-10000px";
                    this.view.appendChild(layer.view);
                    canvases.push(layer.view);
                    let extraX = 0;
                    let extraY = 0;
                    if (layer.margin) {
                        extraX += layer.margin.left || 0 + layer.margin.right || 0;
                        extraY += layer.margin.top || 0 + layer.margin.bottom || 0;
                    }
                    layer.view.width = canvasWidth + extraX;
                    layer.view.height = canvasHeight + extraY;
                    layer.context = layer.view.getContext("2d");
                    layer.dirty = true;
                    layer.scale = scale;
                }
            }
        });
        if (needRerender) {
            this._omitTainted = true;
            this.render(root);
            this._omitTainted = false;
        }
        _util_Array__WEBPACK_IMPORTED_MODULE_2__.each(this.layers, (layer) => {
            if (layer && layer.visible) {
                // Layer is fine. Just plop it into our target canvas
                let x = 0;
                let y = 0;
                if (layer.margin) {
                    x = -(layer.margin.left || 0) * this.resolution;
                    y = -(layer.margin.top || 0) * this.resolution;
                }
                context.drawImage(layer.view, x, y);
                // Restore layer original canvas
                if (layer.exportableView) {
                    layer.view = layer.exportableView;
                    layer.exportableView = undefined;
                }
                if (layer.exportableContext) {
                    layer.context = layer.exportableContext;
                    layer.exportableContext = undefined;
                }
                if (width < layer.view.clientWidth) {
                    width = layer.view.clientWidth;
                }
                if (height < layer.view.clientHeight) {
                    height = layer.view.clientHeight;
                }
                layer.scale = undefined;
            }
        });
        canvas.style.width = width + "px";
        canvas.style.height = height + "px";
        _util_Array__WEBPACK_IMPORTED_MODULE_2__.each(canvases, (canvas) => {
            canvas.style.position = "";
            canvas.style.top = "";
            this.view.removeChild(canvas);
        });
        return canvas;
    }
}
class GhostLayer {
    constructor() {
        Object.defineProperty(this, "view", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "context", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "margin", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {
                left: 0,
                right: 0,
                top: 0,
                bottom: 0,
            }
        });
        Object.defineProperty(this, "_width", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        Object.defineProperty(this, "_height", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        this.view = document.createElement("canvas");
        this.context = this.view.getContext("2d", { alpha: false, willReadFrequently: true });
        this.context.imageSmoothingEnabled = false;
        this.view.style.position = "absolute";
        this.view.style.top = "0px";
        this.view.style.left = "0px";
    }
    resize(canvasWidth, canvasHeight, domWidth, domHeight, resolution) {
        canvasWidth += (this.margin.left + this.margin.right);
        canvasHeight += (this.margin.top + this.margin.bottom);
        // TODO this should take into account calculateSize
        domWidth += (this.margin.left + this.margin.right);
        domHeight += (this.margin.top + this.margin.bottom);
        this.view.style.left = -this.margin.left + "px";
        this.view.style.top = -this.margin.top + "px";
        this._width = Math.floor(canvasWidth * resolution);
        this._height = Math.floor(canvasHeight * resolution);
        this.view.width = this._width;
        this.view.style.width = domWidth + "px";
        this.view.height = this._height;
        this.view.style.height = domHeight + "px";
    }
    getImageData(point, bbox) {
        return this.context.getImageData(
        // TODO should this round ?
        Math.round(((point.x - bbox.left) / bbox.width) * this._width), Math.round(((point.y - bbox.top) / bbox.height) * this._height), 1, 1);
    }
    setMargin(layers) {
        this.margin.left = 0;
        this.margin.right = 0;
        this.margin.top = 0;
        this.margin.bottom = 0;
        _util_Array__WEBPACK_IMPORTED_MODULE_2__.each(layers, (layer) => {
            if (layer.margin) {
                this.margin.left = Math.max(this.margin.left, layer.margin.left);
                this.margin.right = Math.max(this.margin.right, layer.margin.right);
                this.margin.top = Math.max(this.margin.top, layer.margin.top);
                this.margin.bottom = Math.max(this.margin.bottom, layer.margin.bottom);
            }
        });
    }
    clear() {
        this.context.save();
        this.context.fillStyle = '#000';
        this.context.fillRect(0, 0, this._width, this._height);
    }
}
/**
 * @ignore
 */
class CanvasLayer {
    constructor(view, context) {
        Object.defineProperty(this, "view", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "context", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "tainted", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: true
        });
        Object.defineProperty(this, "margin", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "order", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        Object.defineProperty(this, "visible", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: true
        });
        Object.defineProperty(this, "width", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "height", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "scale", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "dirty", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: true
        });
        Object.defineProperty(this, "exportableView", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "exportableContext", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_width", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        Object.defineProperty(this, "_height", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        this.view = view;
        this.context = context;
    }
    resize(canvasWidth, canvasHeight, domWidth, domHeight, resolution) {
        // TODO should this take into account calculateSize ?
        if (this.width != null) {
            canvasWidth = this.width;
            domWidth = this.width;
        }
        // TODO should this take into account calculateSize ?
        if (this.height != null) {
            canvasHeight = this.height;
            domHeight = this.height;
        }
        if (this.margin) {
            canvasWidth += (this.margin.left + this.margin.right);
            canvasHeight += (this.margin.top + this.margin.bottom);
            // TODO this should take into account calculateSize
            domWidth += (this.margin.left + this.margin.right);
            domHeight += (this.margin.top + this.margin.bottom);
            this.view.style.left = -this.margin.left + "px";
            this.view.style.top = -this.margin.top + "px";
        }
        else {
            this.view.style.left = "0px";
            this.view.style.top = "0px";
        }
        this._width = Math.floor(canvasWidth * resolution);
        this._height = Math.floor(canvasHeight * resolution);
        this.view.width = this._width;
        this.view.style.width = domWidth + "px";
        this.view.height = this._height;
        this.view.style.height = domHeight + "px";
    }
    clear() {
        this.context.save();
        this.context.clearRect(0, 0, this._width, this._height);
    }
}
//# sourceMappingURL=CanvasRenderer.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/core/render/backend/Renderer.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/core/render/backend/Renderer.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BlendMode: () => (/* binding */ BlendMode)
/* harmony export */ });
/**
 * From https://github.com/pixijs/pixi.js/blob/3dd0ff9a935f0bc13a09aefff9eb2872f02c51b9/packages/canvas/canvas-renderer/src/utils/mapCanvasBlendModesToPixi.ts#L13
 */
var BlendMode;
(function (BlendMode) {
    BlendMode["ADD"] = "lighter";
    BlendMode["COLOR"] = "color";
    BlendMode["COLOR_BURN"] = "color-burn";
    BlendMode["COLOR_DODGE"] = "color-dodge";
    BlendMode["DARKEN"] = "darken";
    BlendMode["DIFFERENCE"] = "difference";
    BlendMode["DST_OVER"] = "destination-over";
    BlendMode["EXCLUSION"] = "exclusion";
    BlendMode["HARD_LIGHT"] = "hard-light";
    BlendMode["HUE"] = "hue";
    BlendMode["LIGHTEN"] = "lighten";
    BlendMode["LUMINOSITY"] = "luminosity";
    BlendMode["MULTIPLY"] = "multiply";
    BlendMode["NORMAL"] = "source-over";
    BlendMode["OVERLAY"] = "overlay";
    BlendMode["SATURATION"] = "saturation";
    BlendMode["SCREEN"] = "screen";
    BlendMode["SOFT_LIGHT"] = "soft-light";
    BlendMode["SRC_ATOP"] = "source-atop";
    BlendMode["XOR"] = "xor";
})(BlendMode || (BlendMode = {}));
//# sourceMappingURL=Renderer.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/core/render/patterns/Pattern.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/core/render/patterns/Pattern.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Pattern: () => (/* binding */ Pattern)
/* harmony export */ });
/* harmony import */ var _util_Entity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util/Entity */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Entity.js");

/**
 * Base class for patterns.
 *
 * @see {@link https://www.amcharts.com/docs/v5/concepts/colors-gradients-and-patterns/patterns/} for more info
 */
class Pattern extends _util_Entity__WEBPACK_IMPORTED_MODULE_0__.Entity {
    constructor() {
        super(...arguments);
        Object.defineProperty(this, "_display", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: this._root._renderer.makeGraphics()
        });
        Object.defineProperty(this, "_backgroundDisplay", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: this._root._renderer.makeGraphics()
        });
        Object.defineProperty(this, "_clear", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        Object.defineProperty(this, "_pattern", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
    }
    _afterNew() {
        // Applying themes because pattern will not have parent
        super._afterNewApplyThemes();
    }
    get pattern() {
        return this._pattern;
    }
    _draw() { }
    _beforeChanged() {
        super._beforeChanged();
        if (this.isDirty("repetition") || this.isDirty("width") || this.isDirty("height") || this.isDirty("rotation") || this.isDirty("strokeWidth") || this.isDirty("strokeDasharray") || this.isDirty("strokeDashoffset") || this.isDirty("colorOpacity") || this.isDirty("fillOpacity")) {
            this._clear = true;
        }
        this._checkDirtyFill();
    }
    _checkDirtyFill() {
        if (this.isDirty("color") || this.isDirty("fill")) {
            this._clear = true;
        }
    }
    _changed() {
        super._changed();
        if (this._clear) {
            const repetition = this.get("repetition", "");
            const width = this.get("width", 100);
            const height = this.get("height", 100);
            const fill = this.get("fill");
            const fillOpacity = this.get("fillOpacity", 1);
            const backgroundDisplay = this._backgroundDisplay;
            const display = this._display;
            display.clear();
            backgroundDisplay.clear();
            if (fill && (fillOpacity > 0)) {
                backgroundDisplay.beginFill(fill, fillOpacity);
                backgroundDisplay.drawRect(0, 0, width, height);
                backgroundDisplay.endFill();
            }
            display.angle = this.get("rotation", 0);
            //display.pivot = { x: width / 2, y: height / 2 };
            this._draw();
            this._pattern = this._root._renderer.createPattern(display, backgroundDisplay, repetition, width, height);
        }
        this._clear = false;
    }
}
Object.defineProperty(Pattern, "className", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: "Pattern"
});
Object.defineProperty(Pattern, "classNames", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: _util_Entity__WEBPACK_IMPORTED_MODULE_0__.Entity.classNames.concat([Pattern.className])
});
//# sourceMappingURL=Pattern.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/core/render/patterns/PicturePattern.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/core/render/patterns/PicturePattern.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PicturePattern: () => (/* binding */ PicturePattern)
/* harmony export */ });
/* harmony import */ var _Pattern__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Pattern */ "./node_modules/@amcharts/amcharts5/.internal/core/render/patterns/Pattern.js");

/**
 * Picture pattern.
 *
 * @since 5.2.15
 *
 * @see {@link https://www.amcharts.com/docs/v5/concepts/colors-gradients-and-patterns/patterns/} for more info
 */
class PicturePattern extends _Pattern__WEBPACK_IMPORTED_MODULE_0__.Pattern {
    constructor() {
        super(...arguments);
        Object.defineProperty(this, "_image", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
    }
    _beforeChanged() {
        super._beforeChanged();
        this._clear = true;
        if (this.isDirty("src")) {
            this._load();
        }
        const canvas = this.get("canvas");
        if (canvas) {
            this.set("width", canvas.width);
            this.set("height", canvas.height);
        }
    }
    _draw() {
        super._draw();
        const image = this._image;
        if (image) {
            const patternWidth = this.get("width", 100);
            const patternHeight = this.get("height", 100);
            // Fit
            const fit = this.get("fit", "image");
            let width = 0;
            let height = 0;
            if (fit == "pattern") {
                width = patternWidth;
                height = patternHeight;
            }
            else {
                width = image.width;
                height = image.height;
                if (fit == "image") {
                    this.set("width", width);
                    this.set("height", height);
                }
            }
            // Position
            const centered = this.get("centered", true);
            let x = 0;
            let y = 0;
            if (centered) {
                x = patternWidth / 2 - width / 2;
                y = patternHeight / 2 - height / 2;
            }
            this._display.image(image, width, height, x, y);
        }
        const canvas = this.get("canvas");
        if (canvas) {
            this._display.image(canvas, canvas.width, canvas.height, 0, 0);
        }
    }
    _load() {
        const src = this.get("src");
        if (src) {
            const image = new Image();
            //image.crossOrigin = "Anonymous";
            image.src = src;
            image.decode().then(() => {
                this._image = image;
                this._draw();
                if (this.events.isEnabled("loaded")) {
                    this.events.dispatch("loaded", { type: "loaded", target: this });
                }
            }).catch((_error) => {
                // TODO: maybe raise error?
            });
        }
    }
}
Object.defineProperty(PicturePattern, "className", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: "PicturePattern"
});
Object.defineProperty(PicturePattern, "classNames", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: _Pattern__WEBPACK_IMPORTED_MODULE_0__.Pattern.classNames.concat([PicturePattern.className])
});
//# sourceMappingURL=PicturePattern.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/core/util/Animation.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/core/util/Animation.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AnimationTime: () => (/* binding */ AnimationTime),
/* harmony export */   colorInterpolate: () => (/* binding */ colorInterpolate),
/* harmony export */   defaultInterpolate: () => (/* binding */ defaultInterpolate),
/* harmony export */   getInterpolate: () => (/* binding */ getInterpolate),
/* harmony export */   normalize: () => (/* binding */ normalize),
/* harmony export */   percentInterpolate: () => (/* binding */ percentInterpolate),
/* harmony export */   range: () => (/* binding */ range),
/* harmony export */   waitForAnimations: () => (/* binding */ waitForAnimations)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.mjs");
/* harmony import */ var _Percent__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Percent */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Percent.js");
/* harmony import */ var _Color__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Color */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Color.js");
/* harmony import */ var _EventDispatcher__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./EventDispatcher */ "./node_modules/@amcharts/amcharts5/.internal/core/util/EventDispatcher.js");
/* harmony import */ var _Object__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Object */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Object.js");





/**
 * @ignore
 */
function waitForAnimations(animations) {
    return (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__awaiter)(this, void 0, void 0, function* () {
        if (animations !== undefined) {
            const promises = [];
            _Object__WEBPACK_IMPORTED_MODULE_1__.each(animations, (_, animation) => {
                promises.push(animation.waitForStop());
            });
            yield Promise.all(promises);
        }
    });
}
/**
 * @ignore
 */
function normalize(value, min, max) {
    if (min === max) {
        return 0;
    }
    else {
        return Math.min(Math.max((value - min) * (1 / (max - min)), 0), 1);
    }
}
/**
 * @ignore
 */
function range(diff, from, to) {
    return from + (diff * (to - from));
}
/**
 * @ignore
 */
function defaultInterpolate(diff, from, to) {
    if (diff >= 1) {
        return to;
    }
    else {
        return from;
    }
}
/**
 * @ignore
 */
function percentInterpolate(diff, from, to) {
    return new _Percent__WEBPACK_IMPORTED_MODULE_2__.Percent(range(diff, from.percent, to.percent));
}
/**
 * @ignore
 */
function colorInterpolate(diff, from, to) {
    return _Color__WEBPACK_IMPORTED_MODULE_3__.Color.interpolate(diff, from, to);
}
/**
 * @ignore
 */
function getInterpolate(from, to) {
    if (typeof from === "number" && typeof to === "number") {
        return range;
    }
    if (from instanceof _Percent__WEBPACK_IMPORTED_MODULE_2__.Percent && to instanceof _Percent__WEBPACK_IMPORTED_MODULE_2__.Percent) {
        return percentInterpolate;
    }
    if (from instanceof _Color__WEBPACK_IMPORTED_MODULE_3__.Color && to instanceof _Color__WEBPACK_IMPORTED_MODULE_3__.Color) {
        return colorInterpolate;
    }
    return defaultInterpolate;
}
/**
 * @ignore
 */
class AnimationTime {
    constructor(entity, duration) {
        Object.defineProperty(this, "_entity", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_duration", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_playingDuration", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: null
        });
        Object.defineProperty(this, "_startingTime", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: null
        });
        Object.defineProperty(this, "_current", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        Object.defineProperty(this, "_from", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        Object.defineProperty(this, "_to", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        Object.defineProperty(this, "events", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new _EventDispatcher__WEBPACK_IMPORTED_MODULE_4__.EventDispatcher()
        });
        Object.defineProperty(this, "easing", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this._entity = entity;
        this._duration = duration;
    }
    _stopEvent() {
        const type = "stopped";
        if (this.events.isEnabled(type)) {
            this.events.dispatch(type, { type: type, target: this });
        }
    }
    _runAnimation(currentTime) {
        if (this._playingDuration !== null) {
            if (this._startingTime === null) {
                this._startingTime = currentTime;
                return true;
            }
            else {
                const diff = (currentTime - this._startingTime) / this._playingDuration;
                if (diff >= 1) {
                    this._playingDuration = null;
                    this._startingTime = null;
                    this._from = this._to;
                    this._current = this._to;
                    this._entity.markDirty();
                    this._stopEvent();
                    const type = "ended";
                    if (this.events.isEnabled(type)) {
                        this.events.dispatch(type, { type: type, target: this });
                    }
                    return false;
                }
                else {
                    this._current = range(diff, this._from, this._to);
                    this._entity.markDirty();
                    const type = "progress";
                    if (this.events.isEnabled(type)) {
                        this.events.dispatch(type, { type: type, target: this, progress: diff });
                    }
                    return true;
                }
            }
        }
        else {
            return false;
        }
    }
    _play() {
        this._from = this._current;
        if (this._playingDuration === null) {
            this._entity._root._addAnimation(this);
            const type = "started";
            if (this.events.isEnabled(type)) {
                this.events.dispatch(type, { type: type, target: this });
            }
        }
        else {
            this._startingTime = null;
        }
        this._playingDuration = Math.abs(this._to - this._from) * this._duration;
    }
    get duration() {
        return this._duration;
    }
    set duration(value) {
        if (this._duration !== value) {
            this._duration = value;
            if (value === 0) {
                this.jumpTo(this._to);
            }
            else if (this._current !== this._to) {
                this._play();
            }
        }
    }
    get current() {
        if (this.easing) {
            return this.easing(this._current);
        }
        else {
            return this._current;
        }
    }
    stop() {
        this.jumpTo(this._current);
    }
    jumpTo(value) {
        if (this._current !== value) {
            this._entity.markDirty();
        }
        if (this._playingDuration !== null) {
            this._stopEvent();
        }
        this._playingDuration = null;
        this._startingTime = null;
        this._current = value;
        this._from = value;
        this._to = value;
    }
    tweenTo(value) {
        if (this._current === value || this._duration === 0) {
            this.jumpTo(value);
        }
        else {
            if (this._to !== value) {
                this._to = value;
                this._play();
            }
        }
    }
}
/*export class AnimationValue extends AnimationTime {
    public _min: number;
    public _max: number;

    constructor(entity: Entity, duration: number, min: number, max: number) {
        super(entity, duration);
        this._min = min;
        this._max = max;
    }

    public get min(): number {
        return this._min;
    }

    public set min(value: number) {
        if (this._min !== value) {
            this._min = value;
            this._entity.markDirty();
        }
    }

    public get max(): number {
        return this._max;
    }

    public set max(value: number) {
        if (this._max !== value) {
            this._max = value;
            this._entity.markDirty();
        }
    }

    public currentValue(): number {
        return range(super.currentTime(), this._min, this._max);
    }

    public jumpToValue(value: number) {
        super.jumpToTime(normalize(value, this._min, this._max));
    }

    public tweenToValue(value: number) {
        super.tweenToTime(normalize(value, this._min, this._max));
    }
}
*/
//# sourceMappingURL=Animation.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/core/util/Array.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/core/util/Array.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   add: () => (/* binding */ add),
/* harmony export */   any: () => (/* binding */ any),
/* harmony export */   copy: () => (/* binding */ copy),
/* harmony export */   each: () => (/* binding */ each),
/* harmony export */   eachContinue: () => (/* binding */ eachContinue),
/* harmony export */   eachReverse: () => (/* binding */ eachReverse),
/* harmony export */   find: () => (/* binding */ find),
/* harmony export */   findIndex: () => (/* binding */ findIndex),
/* harmony export */   findIndexReverse: () => (/* binding */ findIndexReverse),
/* harmony export */   findMap: () => (/* binding */ findMap),
/* harmony export */   findReverse: () => (/* binding */ findReverse),
/* harmony export */   first: () => (/* binding */ first),
/* harmony export */   getFirstSortedIndex: () => (/* binding */ getFirstSortedIndex),
/* harmony export */   getSortedIndex: () => (/* binding */ getSortedIndex),
/* harmony export */   has: () => (/* binding */ has),
/* harmony export */   indexOf: () => (/* binding */ indexOf),
/* harmony export */   insert: () => (/* binding */ insert),
/* harmony export */   insertIndex: () => (/* binding */ insertIndex),
/* harmony export */   keepIf: () => (/* binding */ keepIf),
/* harmony export */   last: () => (/* binding */ last),
/* harmony export */   map: () => (/* binding */ map),
/* harmony export */   move: () => (/* binding */ move),
/* harmony export */   pushAll: () => (/* binding */ pushAll),
/* harmony export */   pushOne: () => (/* binding */ pushOne),
/* harmony export */   remove: () => (/* binding */ remove),
/* harmony export */   removeFirst: () => (/* binding */ removeFirst),
/* harmony export */   removeIndex: () => (/* binding */ removeIndex),
/* harmony export */   replace: () => (/* binding */ replace),
/* harmony export */   setIndex: () => (/* binding */ setIndex),
/* harmony export */   shiftLeft: () => (/* binding */ shiftLeft),
/* harmony export */   shuffle: () => (/* binding */ shuffle),
/* harmony export */   slice: () => (/* binding */ slice),
/* harmony export */   toArray: () => (/* binding */ toArray)
/* harmony export */ });
/* harmony import */ var _Type__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Type */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Type.js");

/**
 * ============================================================================
 * UTILITY FUNCTIONS
 * ============================================================================
 * @hidden
 */
/**
 * Searches `array` for `value`.
 *
 * Returns -1 if not found.
 *
 * @param array  Source array
 * @param value  Value to search
 * @returns Index
 */
function indexOf(array, value) {
    const length = array.length;
    for (let i = 0; i < length; ++i) {
        // TODO handle NaN
        if (array[i] === value) {
            return i;
        }
    }
    return -1;
}
/**
 * Calls `test` for each element in `array`.
 *
 * If `test` returns `true` then it immediately returns `true`.
 *
 * If `test` returns `false` for all of the elements in `array` then it returns `false`.
 *
 * @param array  Source array
 * @param test   Function which is called on each element
 * @returns Whether `test` returned true or not
 */
function any(array, test) {
    const length = array.length;
    for (let i = 0; i < length; ++i) {
        if (test(array[i])) {
            return true;
        }
    }
    return false;
}
/**
 * Calls `fn` function for every member of array and returns a new array out
 * of all outputs.
 *
 * @param array  Source array
 * @param fn     Callback function
 * @returns New array
 */
function map(array, fn) {
    const length = array.length;
    const output = new Array(length);
    for (let i = 0; i < length; ++i) {
        output[i] = fn(array[i], i);
    }
    return output;
}
/**
 * Iterates through all items in array and calls `fn` function for each of
 * them.
 *
 * @param array  Source array
 * @param fn     Callback function
 */
function each(array, fn) {
    const length = array.length;
    for (let i = 0; i < length; ++i) {
        fn(array[i], i);
    }
}
/**
 * Iterates through all items in array in reverse order and calls `fn` function for each of
 * them.
 *
 * @param array  Source array
 * @param fn     Callback function
 */
function eachReverse(array, fn) {
    let i = array.length;
    while (i > 0) {
        --i;
        fn(array[i], i);
    }
}
/**
 * Iterates through all items in array and calls `fn` function for each of
 * them.
 *
 * If `fn` call evaluates to `false`, further iteration is cancelled.
 *
 * @param array  Source array
 * @param fn     Callback function
 */
function eachContinue(array, fn) {
    const length = array.length;
    for (let i = 0; i < length; ++i) {
        if (!fn(array[i], i)) {
            break;
        }
    }
}
/**
 * Shifts an item at `index` towards beginning of the array.
 *
 * @param array  Source array
 * @param index  Target element index
 */
function shiftLeft(array, index) {
    const length = array.length;
    for (let i = index; i < length; ++i) {
        array[i - index] = array[i];
    }
    array.length = length - index;
}
/**
 * Returns the last item of the array.
 *
 * @param array  Source array
 * @returns Last item
 */
function last(array) {
    const length = array.length;
    return length ? array[length - 1] : undefined;
}
/**
 * Returns the first item of the array.
 *
 * @param array  Source array
 * @returns Last item
 */
function first(array) {
    return array[0];
}
/**
 * Inserts `element` into `array` at `index`.
 *
 * Caps `index` to be between `0` and `array.length`
 *
 * @param array    Source array
 * @param element  Item to insert
 * @param array    Index to insert item at
 */
function insert(array, element, index) {
    //if (array) {
    index = Math.max(0, Math.min(index, array.length));
    array.splice(index, 0, element);
    //}
}
/**
 * Removes all copies of `element` from `array` (if they exist) and then
 * inserts `element` at `index`.
 *
 * @param array    Source array
 * @param element  Item
 * @param array    Index to move item to
 */
function setIndex(array, element, index) {
    remove(array, element);
    insert(array, element, index);
}
/**
 * Pushes all of the elements from `input` into `array`.
 *
 * @param array  Output array
 * @param input  Input array
 */
function pushAll(array, input) {
    const length = input.length;
    for (let i = 0; i < length; ++i) {
        array.push(input[i]);
    }
}
/**
 * Removes `element` from `array`.
 *
 * If there are multiple copies of `element`, they are all removed.
 *
 * @param array    Source array
 * @param element  Item to remove
 */
function remove(array, element) {
    let found = false;
    let index = 0;
    for (;;) {
        index = array.indexOf(element, index);
        if (index === -1) {
            return found;
        }
        else {
            found = true;
            array.splice(index, 1);
        }
    }
}
function removeFirst(array, element) {
    let index = array.indexOf(element);
    if (index !== -1) {
        array.splice(index, 1);
        return true;
    }
    else {
        return false;
    }
}
/**
 * Adds an `element` to `array`.
 *
 * If array already contains and item like this, it is removed before adding
 * it again.
 *
 * Optionally `toIndex` can be specified to add element at specific index.
 *
 * @param array    Source array
 * @param element  Item to add
 * @param array    Index to move item to
 */
function move(array, element, toIndex) {
    // @todo this implementation must be the same as the List.moveValue method
    // @todo don't do anything if the desired index is the same as the current index
    let index = indexOf(array, element);
    // @todo remove all old values rather than only the first ?
    if (index !== -1) {
        removeIndex(array, index);
    }
    if (toIndex == null) {
        array.push(element);
    }
    else {
        insertIndex(array, toIndex, element);
    }
}
/**
 * Inserts `element` into `array` at `index`.
 *
 * If `index` is not provided, it will insert `element` at the end of `array`.
 *
 * @param array    Source array
 * @param element  Item to add
 * @param array    Index to add item at
 */
function add(array, element, index) {
    // Append to the end if index is not set
    if (!_Type__WEBPACK_IMPORTED_MODULE_0__.isNumber(index)) {
        array.push(element);
    }
    // Add to the beginning of array if index is 0
    else if (index === 0) {
        array.unshift(element);
    }
    // Add to indicated place if index is set
    else {
        array.splice(index, 0, element);
    }
}
/**
 * Pushes `element` into `array` if it doesn't already exist.
 *
 * @param array    Source array
 * @param element  Item to add
 */
function pushOne(array, element) {
    if (array.indexOf(element) === -1) {
        array.push(element);
    }
}
/**
 * Removes `element` from `array` (if it exists) and then inserts `element` at
 * `index`.
 *
 * If `index` is not provided, it will insert `element` at the end of `array`.
 *
 * @param array    Source array
 * @param element  Item to remove
 * @param array    Index to move item to
 */
function replace(array, element, index) {
    // check if exists
    let ind = array.indexOf(element);
    // remove if exists
    if (ind !== -1) {
        array.splice(ind, 1);
    }
    // add to end if index is not set
    if (!_Type__WEBPACK_IMPORTED_MODULE_0__.isNumber(index)) {
        array.push(element);
    }
    // add to indicated place if index is set
    else {
        array.splice(index, 0, element);
    }
}
/**
 * Wraps `input` in an array, if it isn't already an array.
 *
 * @param input  Source value
 * @return An array
 */
function toArray(input) {
    if (Array.isArray(input)) {
        return input;
    }
    else {
        return [input];
    }
}
/**
 * Returns `true` if `element` exists in `array`.
 *
 * @param array    Source array
 * @param element  Item to search for
 * @returns Item in array?
 */
function has(array, element) {
    return indexOf(array, element) !== -1;
}
/**
 * Returns a shallow copy of `array`.
 *
 * @param array  Source array
 * @returns Copy of the array
 */
function copy(array) {
    const length = array.length;
    // It's faster to create the array with a pre-defined length
    const output = new Array(length);
    for (let i = 0; i < length; ++i) {
        // Because the array has a pre-defined length, we have to assign rather than push
        // This is also faster than pushing
        output[i] = array[i];
    }
    return output;
}
/**
 * Returns a copy of `array` which contains all the elements between `start`
 * and `end`. (including `start` and excluding `end`)
 *
 * If `end` is not provided, it defaults to `array.length`.
 *
 * @param array  Source array
 * @param start  Start index
 * @param end    End index
 * @returns Part of the array
 */
function slice(array, start, end = array.length) {
    const output = new Array(end - start);
    for (let i = start; i < end; ++i) {
        output[i - start] = array[i];
    }
    return output;
}
/**
 * Inserts a value into array at specific index.
 *
 * @param array  Source array
 * @param index  Index
 * @param value  Value to insert
 */
function insertIndex(array, index, value) {
    array.splice(index, 0, value);
}
/**
 * Removes a value from array at specific index.
 *
 * @param array  Source array
 * @param index  Index
 */
function removeIndex(array, index) {
    array.splice(index, 1);
}
/**
 * Searches the array using custom function and returns index of the item if
 * found.
 *
 * Will call `matches` function on all items of the array. If return value
 * evaluates to `true`, index is returned.
 *
 * Otherwise returns -1.
 *
 * @param array    Source array
 * @param matches  Search function
 * @returns Index of the item if found
 */
function findIndex(array, matches) {
    const length = array.length;
    for (let i = 0; i < length; ++i) {
        if (matches(array[i], i)) {
            return i;
        }
    }
    return -1;
}
/**
 * This is the same as `findIndex` except it searches from right to left.
 *
 * @param array    Source array
 * @param matches  Search function
 * @returns Index of the item if found
 */
function findIndexReverse(array, matches) {
    let i = array.length;
    while (i > 0) {
        --i;
        if (matches(array[i], i)) {
            return i;
        }
    }
    return -1;
}
/**
 * Searches the array using custom function and returns item if found.
 *
 * Will call `matches` function on all items of the array. If return value
 * evaluates to `true`, index is returned.
 *
 * Otherwise returns `undefined`.
 *
 * @param array    Source array
 * @param matches  Search function
 * @returns Item if found
 */
function find(array, matches) {
    const index = findIndex(array, matches);
    if (index !== -1) {
        return array[index];
    }
}
/**
 * This is the same as `find` except it searches from right to left.
 *
 * @param array    Source array
 * @param matches  Search function
 * @returns Item if found
 */
function findReverse(array, matches) {
    const index = findIndexReverse(array, matches);
    if (index !== -1) {
        return array[index];
    }
}
/**
 * Searches the array using custom function and returns item if found.
 *
 * Will call `matches` function on all items of the array. If value
 * is not `undefined`, it returns it.
 *
 * Otherwise returns `undefined`.
 *
 * @param array    Source array
 * @param matches  Search function
 * @returns Item if found
 */
function findMap(array, matches) {
    const length = array.length;
    for (let i = 0; i < length; ++i) {
        const value = matches(array[i], i);
        if (value !== undefined) {
            return value;
        }
    }
}
/**
 * Iterates through all items in array and calls `fn` function for each of
 * them.
 *
 * @param array  Source array
 * @param fn     Callback function
 */
function shuffle(array) {
    // https://stackoverflow.com/a/2450976/449477
    let currentIndex = array.length, temporaryValue, randomIndex;
    // While there remain elements to shuffle...
    while (0 !== currentIndex) {
        // Pick a remaining element...
        randomIndex = Math.floor(Math.random() * currentIndex);
        currentIndex -= 1;
        // And swap it with the current element.
        temporaryValue = array[currentIndex];
        array[currentIndex] = array[randomIndex];
        array[randomIndex] = temporaryValue;
    }
}
/**
 * Orders an array using specific `ordering` function and returns right-most index of
 * the `value`.
 *
 * @ignore Exclude from docs
 * @param array     Source array
 * @param ordering  An ordering function
 * @returns Result of the search
 */
function getSortedIndex(array, ordering) {
    let start = 0;
    let end = array.length;
    let found = false;
    while (start < end) {
        // TODO is this faster/slower than using Math.floor ?
        const pivot = (start + end) >> 1;
        const order = ordering(array[pivot]);
        // less
        if (order < 0) {
            start = pivot + 1;
            // equal
        }
        else if (order === 0) {
            found = true;
            start = pivot + 1;
            // more
        }
        else {
            end = pivot;
        }
    }
    return {
        found: found,
        index: (found ? start - 1 : start)
    };
}
/**
 * Orders an array using specific `ordering` function and returns left-most index of
 * the `value`.
 *
 * @ignore Exclude from docs
 * @param array     Source array
 * @param ordering  An ordering function
 * @returns Result of the search
 */
function getFirstSortedIndex(array, ordering) {
    let start = 0;
    let end = array.length;
    let found = false;
    while (start < end) {
        // TODO is this faster/slower than using Math.floor ?
        const pivot = (start + end) >> 1;
        const order = ordering(array[pivot]);
        // less
        if (order < 0) {
            start = pivot + 1;
            // equal
        }
        else if (order === 0) {
            found = true;
            end = pivot;
            // more
        }
        else {
            end = pivot;
        }
    }
    return {
        found: found,
        index: start
    };
}
function keepIf(array, keep) {
    let i = array.length;
    while (i > 0) {
        --i;
        if (!keep(array[i])) {
            array.splice(i, 1);
        }
    }
}
//# sourceMappingURL=Array.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/core/util/Children.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/core/util/Children.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Children: () => (/* binding */ Children)
/* harmony export */ });
/* harmony import */ var _List__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./List */ "./node_modules/@amcharts/amcharts5/.internal/core/util/List.js");
/* harmony import */ var _Array__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Array */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Array.js");


/**
 * A version of [[List]] to hold children of the [[Container]].
 *
 * @see {@link https://www.amcharts.com/docs/v5/concepts/common-elements/containers/} for more info
 */
class Children extends _List__WEBPACK_IMPORTED_MODULE_0__.List {
    constructor(container) {
        super();
        Object.defineProperty(this, "_disposed", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        Object.defineProperty(this, "_container", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_events", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this._container = container;
        this._events = this.events.onAll((change) => {
            if (change.type === "clear") {
                _Array__WEBPACK_IMPORTED_MODULE_1__.each(change.oldValues, (x) => {
                    this._onRemoved(x);
                });
            }
            else if (change.type === "push") {
                this._onInserted(change.newValue);
            }
            else if (change.type === "setIndex") {
                this._onRemoved(change.oldValue);
                this._onInserted(change.newValue, change.index);
            }
            else if (change.type === "insertIndex") {
                this._onInserted(change.newValue, change.index);
            }
            else if (change.type === "removeIndex") {
                this._onRemoved(change.oldValue);
            }
            else if (change.type === "moveIndex") {
                this._onRemoved(change.value);
                this._onInserted(change.value, change.newIndex);
            }
            else {
                throw new Error("Unknown IListEvent type");
            }
        });
    }
    _onInserted(child, index) {
        child._setParent(this._container, true);
        const childrenDisplay = this._container._childrenDisplay;
        if (index === undefined) {
            childrenDisplay.addChild(child._display);
        }
        else {
            childrenDisplay.addChildAt(child._display, index);
        }
    }
    _onRemoved(child) {
        this._container._childrenDisplay.removeChild(child._display);
        this._container.markDirtyBounds();
        this._container.markDirty();
    }
    /**
     * Returns `true` if obejct is disposed.
     */
    isDisposed() {
        return this._disposed;
    }
    /**
     * Permanently dispose this object.
     */
    dispose() {
        if (!this._disposed) {
            this._disposed = true;
            this._events.dispose();
            _Array__WEBPACK_IMPORTED_MODULE_1__.each(this.values, (child) => {
                child.dispose();
            });
        }
    }
}
//# sourceMappingURL=Children.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/core/util/Color.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/core/util/Color.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Color: () => (/* binding */ Color),
/* harmony export */   color: () => (/* binding */ color),
/* harmony export */   rgba2hex: () => (/* binding */ rgba2hex)
/* harmony export */ });
/* harmony import */ var _Animation__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Animation */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Animation.js");
/* harmony import */ var _Utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Utils */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Utils.js");
/* harmony import */ var _Type__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Type */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Type.js");



/**
 * @ignore
 */
function string2hex(string) {
    //string = cssColorNames[string.toLowerCase()] || string;
    if (string[0] === "#") {
        string = string.substr(1);
    }
    if (string.length == 3) {
        string = string[0].repeat(2) + string[1].repeat(2) + string[2].repeat(2);
    }
    return parseInt(string, 16);
}
/**
 * @ignore
 */
function rgba2hex(color) {
    color = color.replace(/[ ]/g, "");
    // Init
    let matches = color.match(/^rgb\(([0-9]*),([0-9]*),([0-9]*)\)/i);
    // Try rgb() format
    if (matches) {
        matches.push("1");
    }
    else {
        matches = color.match(/^rgba\(([0-9]*),([0-9]*),([0-9]*),([.0-9]*)\)/i);
        if (!matches) {
            return 0x000000;
        }
    }
    let hex = "";
    for (let i = 1; i <= 3; i++) {
        let val = parseInt(matches[i]).toString(16);
        if (val.length == 1) {
            val = "0" + val;
        }
        hex += val;
    }
    return string2hex(hex);
}
/**
 * Returns a new [[Color]] object base on input.
 *
 * Accepts parameters in CSS hex or rgb/rtba strings, or hex numbers.
 *
 * * `"#f00"`
 * * `"#ff0000"`
 * * `"rgb(255, 0, 0)"`
 * * `"rgba(255, 0, 0, 1)"`
 * * `0xff0000`
 *
 * @param   input  Input color
 * @return         Color
 */
function color(input) {
    return Color.fromAny(input);
}
/**
 * Wherever color needs to be specified in amCharts 5, `Color` object needs to
 * be used.
 *
 * @see {@link https://www.amcharts.com/docs/v5/concepts/colors-gradients-and-patterns/} for more info
 * @important
 */
class Color {
    constructor(hex) {
        Object.defineProperty(this, "_hex", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this._hex = hex | 0;
    }
    /**
     * Color numeric value.
     */
    get hex() {
        return this._hex;
    }
    /**
     * Value of color's R channel.
     * @return R value
     */
    get r() {
        return this._hex >>> 16;
    }
    /**
     * Value of color's G channel.
     * @return G value
     */
    get g() {
        return (this._hex >> 8) & 0xFF;
    }
    /**
     * Value of color's B channel.
     * @return B value
     */
    get b() {
        return this._hex & 0xFF;
    }
    /**
     * Returns color CSS representation in form of `rgba(r, g, b, a)` string.
     *
     * @param   alpha  Opacity
     * @return         CSS string
     */
    toCSS(alpha = 1) {
        return "rgba(" + this.r + ", " + this.g + ", " + this.b + ", " + alpha + ")";
    }
    /**
     * Returns color CSS representation in form of `#rgb` string.
     *
     * @return         CSS string
     */
    toCSSHex() {
        return "#" + _Utils__WEBPACK_IMPORTED_MODULE_0__.padString(this.r.toString(16), 2) + _Utils__WEBPACK_IMPORTED_MODULE_0__.padString(this.g.toString(16), 2) + _Utils__WEBPACK_IMPORTED_MODULE_0__.padString(this.b.toString(16), 2);
    }
    /**
     * Returns color's HSL info.
     * @param   alpha Opacity
     * @return        HSL info
     */
    toHSL(alpha = 1) {
        return _Utils__WEBPACK_IMPORTED_MODULE_0__.rgbToHsl({
            r: this.r,
            g: this.g,
            b: this.b,
            a: alpha
        });
    }
    /**
     * Converts HSL values into a new [[Color]] object.
     *
     * @param   h H value
     * @param   s S value
     * @param   l L value
     * @return    Color object
     */
    static fromHSL(h, s, l) {
        const rgb = _Utils__WEBPACK_IMPORTED_MODULE_0__.hslToRgb({
            h: h,
            s: s,
            l: l
        });
        return this.fromRGB(rgb.r, rgb.g, rgb.b);
    }
    toString() {
        return this.toCSSHex();
    }
    /**
     * Converts hex number into a new [[Color]] object.
     *
     * ```TypeScript
     * Color.fromHex(0xff0000) // red
     * ```
     * ```JavaScript
     * Color.fromHex(0xff0000) // red
     * ```
     *
     * @param   hex  Hex color
     * @return       Color
     */
    static fromHex(hex) {
        return new Color(hex);
    }
    /**
     * Converts RGB values to a new [[Color]] object.
     *
     * @param   r  R value
     * @param   g  G value
     * @param   b  B value
     * @return     Color
     */
    static fromRGB(r, g, b) {
        return new Color((b | 0) + (g << 8) + (r << 16));
    }
    /**
     * Converts RGB string to a new [[Color]] object.
     *
     * ```TypeScript
     * Color.fromString("#ff0000") // red
     * ```
     * ```JavaScript
     * Color.fromString("#ff0000") // red
     * ```
     *
     * @param   s  RGB string
     * @return     Color
     */
    static fromString(s) {
        return new Color(string2hex(s));
    }
    /**
     * Converts CSS rgba() syntax to a new [[Color]] object.
     *
     * ```TypeScript
     * Color.fromCSS("rgba(255, 0, 0, 1)") // red
     * ```
     * ```JavaScript
     * Color.fromCSS("rgba(255, 0, 0, 1)") // red
     * ```
     *
     * @param  {string} s [description]
     * @return {Color}    [description]
     */
    static fromCSS(s) {
        return new Color(rgba2hex(s));
    }
    /**
     * Convert to color from virtually anything.
     *
     * Will throw an exception if unable to resolve the color.
     *
     * @param   s  Source
     * @return     Color
     */
    static fromAny(s) {
        if (_Type__WEBPACK_IMPORTED_MODULE_1__.isString(s)) {
            if (s[0] == "#") {
                return Color.fromString(s);
            }
            else if (s.substr(0, 3) == "rgb") {
                return Color.fromCSS(s);
            }
        }
        else if (_Type__WEBPACK_IMPORTED_MODULE_1__.isNumber(s)) {
            return Color.fromHex(s);
        }
        else if (s instanceof Color) {
            return Color.fromHex(s.hex);
        }
        throw new Error("Unknown color syntax: " + s);
    }
    /**
     * Returns a new [[Color]] object based on either `lightAlternative` or
     * `darkAlternative` depending on which one is more contrasting with
     * the `color`.
     *
     * @param   color             Reference color
     * @param   lightAlternative  Light color
     * @param   darkAlternative   Dark color
     * @return                    Alternative color
     */
    static alternative(color, lightAlternative, darkAlternative) {
        const rgb = _Utils__WEBPACK_IMPORTED_MODULE_0__.alternativeColor({ r: color.r, g: color.g, b: color.b }, lightAlternative ? { r: lightAlternative.r, g: lightAlternative.g, b: lightAlternative.b } : undefined, darkAlternative ? { r: darkAlternative.r, g: darkAlternative.g, b: darkAlternative.b } : undefined);
        return this.fromRGB(rgb.r, rgb.g, rgb.b);
    }
    /**
     * Returns an intermediate Color between two reference colors depending on
     * the progress (`diff`) between the two.
     *
     * @param   diff  Progress
     * @param   from  Source color
     * @param   to    Target color
     * @param   mode  Interpolation mode
     * @return        Color
     */
    static interpolate(diff, from, to, mode = "rgb") {
        if (mode == "hsl") {
            const fromHSL = from.toHSL();
            const toHSL = to.toHSL();
            return Color.fromHSL((0,_Animation__WEBPACK_IMPORTED_MODULE_2__.range)(diff, fromHSL.h, toHSL.h), (0,_Animation__WEBPACK_IMPORTED_MODULE_2__.range)(diff, fromHSL.s, toHSL.s), (0,_Animation__WEBPACK_IMPORTED_MODULE_2__.range)(diff, fromHSL.l, toHSL.l));
        }
        else {
            return Color.fromRGB((0,_Animation__WEBPACK_IMPORTED_MODULE_2__.range)(diff, from.r, to.r), (0,_Animation__WEBPACK_IMPORTED_MODULE_2__.range)(diff, from.g, to.g), (0,_Animation__WEBPACK_IMPORTED_MODULE_2__.range)(diff, from.b, to.b));
        }
    }
    /**
     * Returns a new [[Color]] lightened by `percent` value.
     *
     * Use negative value to darken the color.
     *
     * @param   color    Source color
     * @param   percent  Percent
     * @return           New color
     */
    static lighten(color, percent) {
        const rgb = _Utils__WEBPACK_IMPORTED_MODULE_0__.lighten({ r: color.r, g: color.g, b: color.b }, percent);
        return Color.fromRGB(rgb.r, rgb.g, rgb.b);
    }
    /**
     * Returns a new [[Color]] brightened by `percent` value.
     *
     * Use negative value to dim the color.
     *
     * @param   color    Source color
     * @param   percent  Percent
     * @return           New color
     */
    static brighten(color, percent) {
        const rgb = _Utils__WEBPACK_IMPORTED_MODULE_0__.brighten({ r: color.r, g: color.g, b: color.b }, percent);
        return Color.fromRGB(rgb.r, rgb.g, rgb.b);
    }
    /**
     * Returns a new [[Color]] saturated by `percent` value.
     *
     * Value range is between `0` (fully desaturated), to `1` (full color).
     *
     * @param   color    Source color
     * @param   percent  Percent
     * @return           New color
     */
    static saturate(color, percent) {
        const rgb = _Utils__WEBPACK_IMPORTED_MODULE_0__.saturate({ r: color.r, g: color.g, b: color.b }, percent);
        return Color.fromRGB(rgb.r, rgb.g, rgb.b);
    }
}
//# sourceMappingURL=Color.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/core/util/ColorSet.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/core/util/ColorSet.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ColorSet: () => (/* binding */ ColorSet)
/* harmony export */ });
/* harmony import */ var _Entity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Entity */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Entity.js");
/* harmony import */ var _Color__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Color */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Color.js");


/**
 * An object which holds list of colors and can generate new ones.
 *
 * @see {@link https://www.amcharts.com/docs/v5/concepts/colors-gradients-and-patterns/#Color_sets} for more info
 */
class ColorSet extends _Entity__WEBPACK_IMPORTED_MODULE_0__.Entity {
    //protected _currentPass: number = 0;
    _afterNew() {
        // Applying themes because color set will not have parent
        super._afterNewApplyThemes();
        this._dirty["colors"] = false;
    }
    _beforeChanged() {
        if (this.isDirty("colors")) {
            this.reset();
        }
    }
    /**
     * @ignore
     */
    generateColors() {
        this.setPrivate("currentPass", this.getPrivate("currentPass", 0) + 1);
        const pass = this.getPrivate("currentPass");
        const colors = this.get("colors", [this.get("baseColor", _Color__WEBPACK_IMPORTED_MODULE_1__.Color.fromHex(0xff0000))]);
        if (!this.getPrivate("numColors")) {
            this.setPrivate("numColors", colors.length);
        }
        //const len = colors.length;
        const len = this.getPrivate("numColors");
        //const start = len - this.getPrivate("numColors")!;
        const start = 0;
        const passOptions = this.get("passOptions");
        const reuse = this.get("reuse");
        for (let i = start; i < len; i++) {
            if (reuse) {
                colors.push(colors[i]);
            }
            else {
                const hsl = colors[i].toHSL();
                let h = hsl.h + (passOptions.hue || 0) * pass;
                while (h > 1)
                    h -= 1;
                let s = hsl.s + (passOptions.saturation || 0) * pass;
                //if (s > 1) s -= Math.floor(s);
                if (s > 1)
                    s = 1;
                if (s < 0)
                    s = 0;
                let l = hsl.l + (passOptions.lightness || 0) * pass;
                //if (l > 1) l -= Math.floor(l);
                while (l > 1)
                    l -= 1;
                colors.push(_Color__WEBPACK_IMPORTED_MODULE_1__.Color.fromHSL(h, s, l));
            }
        }
    }
    /**
     * Returns a [[Color]] at specific index.
     *
     * If there's no color at this index, a new color is generated.
     *
     * @param   index  Index
     * @return         Color
     */
    getIndex(index) {
        const colors = this.get("colors", []);
        const saturation = this.get("saturation");
        if (index >= colors.length) {
            this.generateColors();
            return this.getIndex(index);
        }
        return saturation != null ? _Color__WEBPACK_IMPORTED_MODULE_1__.Color.saturate(colors[index], saturation) : colors[index];
    }
    /**
     * Returns next [[Color]] in the list.
     *
     * If the list is out of colors, new ones are generated dynamically.
     */
    next() {
        let currentStep = this.getPrivate("currentStep", this.get("startIndex", 0));
        this.setPrivate("currentStep", currentStep + this.get("step", 1));
        return this.getIndex(currentStep);
    }
    /**
     * Resets counter to the start of the list, so the next call for `next()` will
     * return the first color.
     */
    reset() {
        this.setPrivate("currentStep", this.get("startIndex", 0));
        this.setPrivate("currentPass", 0);
    }
}
Object.defineProperty(ColorSet, "className", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: "ColorSet"
});
Object.defineProperty(ColorSet, "classNames", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: _Entity__WEBPACK_IMPORTED_MODULE_0__.Entity.classNames.concat([ColorSet.className])
});
//# sourceMappingURL=ColorSet.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/core/util/Data.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/core/util/Data.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   JsonData: () => (/* binding */ JsonData),
/* harmony export */   ListData: () => (/* binding */ ListData)
/* harmony export */ });
/* harmony import */ var _List__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./List */ "./node_modules/@amcharts/amcharts5/.internal/core/util/List.js");

/**
 * A [[List]] that holds components data.
 *
 * @see {@link https://www.amcharts.com/docs/v5/concepts/data/} for more info
 */
class ListData extends _List__WEBPACK_IMPORTED_MODULE_0__.List {
    constructor() {
        super(...arguments);
        /**
         * An optional processor for data.
         *
         * @see {@link https://www.amcharts.com/docs/v5/concepts/data/#Pre_processing_data} for more info
         */
        Object.defineProperty(this, "processor", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
    }
    /**
     * @ignore
     */
    incrementRef() { }
    /**
     * @ignore
     */
    decrementRef() { }
    _onPush(newValue) {
        if (this.processor) {
            this.processor.processRow(newValue);
        }
        super._onPush(newValue);
    }
    _onInsertIndex(index, newValue) {
        if (this.processor) {
            this.processor.processRow(newValue);
        }
        super._onInsertIndex(index, newValue);
    }
    _onSetIndex(index, oldValue, newValue) {
        if (this.processor) {
            this.processor.processRow(newValue);
        }
        super._onSetIndex(index, oldValue, newValue);
    }
}
/**
 * @deprecated
 * @todo remove
 */
class JsonData {
    constructor(value) {
        Object.defineProperty(this, "processor", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_value", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this._value = value;
    }
    incrementRef() { }
    decrementRef() { }
}
//# sourceMappingURL=Data.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/core/util/DateFormatter.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/core/util/DateFormatter.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DateFormatter: () => (/* binding */ DateFormatter)
/* harmony export */ });
/* harmony import */ var _Entity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Entity */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Entity.js");
/* harmony import */ var _TextFormatter__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./TextFormatter */ "./node_modules/@amcharts/amcharts5/.internal/core/util/TextFormatter.js");
/* harmony import */ var _Timezone__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Timezone */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Timezone.js");
/* harmony import */ var _Type__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Type */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Type.js");
/* harmony import */ var _Utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Utils */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Utils.js");





class DateFormatter extends _Entity__WEBPACK_IMPORTED_MODULE_0__.Entity {
    _setDefaults() {
        // Defaults
        this._setDefault("capitalize", true);
        this._setDefault("dateFormat", "yyyy-MM-dd");
        super._setDefaults();
    }
    _beforeChanged() {
        super._beforeChanged();
    }
    format(source, format) {
        // Locale?
        // TODO
        // No format passed in or it's empty
        if (typeof format === "undefined" || format === "") {
            format = this.get("dateFormat", "yyyy-MM-dd");
        }
        // Init return value
        let formatted;
        // Cast?
        // TODO: decide if we need to cast
        let date = source;
        // Is it a built-in format or Intl.DateTimeFormat
        if (_Type__WEBPACK_IMPORTED_MODULE_1__.isObject(format)) {
            try {
                const locales = this.get("intlLocales");
                if (locales) {
                    return new Intl.DateTimeFormat(locales, format).format(date);
                }
                else {
                    return new Intl.DateTimeFormat(undefined, format).format(date);
                }
            }
            catch (e) {
                return "Invalid";
            }
        }
        // get format info (it will also deal with parser caching)
        let info = this.parseFormat(format);
        // Should we apply custom time zone?
        const timezone = this._root.timezone;
        if (timezone && !this._root.utc) {
            date = timezone.convertLocal(date);
        }
        // Check if it's a valid date
        if (!_Type__WEBPACK_IMPORTED_MODULE_1__.isNumber(date.getTime())) {
            // TODO translation
            //return this._t("Invalid date");
            return "Invalid date";
        }
        // Apply format
        formatted = this.applyFormat(date, info);
        // Capitalize
        if (this.get("capitalize")) {
            formatted = formatted.replace(/^.{1}/, formatted.substr(0, 1).toUpperCase());
        }
        // We're done
        return formatted;
    }
    /**
     * Applies format to Date.
     *
     * @param date      Date object
     * @param info      Parsed format information
     * @return Formatted date string
     */
    applyFormat(date, info) {
        // Init return value
        let res = info.template;
        // Get values
        let fullYear, month, weekday, day, hours, minutes, seconds, milliseconds, timestamp = date.getTime();
        if (this._root.utc) {
            fullYear = date.getUTCFullYear();
            month = date.getUTCMonth();
            weekday = date.getUTCDay();
            day = date.getUTCDate();
            hours = date.getUTCHours();
            minutes = date.getUTCMinutes();
            seconds = date.getUTCSeconds();
            milliseconds = date.getUTCMilliseconds();
        }
        else {
            fullYear = date.getFullYear();
            month = date.getMonth();
            weekday = date.getDay();
            day = date.getDate();
            hours = date.getHours();
            minutes = date.getMinutes();
            seconds = date.getSeconds();
            milliseconds = date.getMilliseconds();
        }
        // Go through each part and format/replace it in template
        for (let i = 0, len = info.parts.length; i < len; i++) {
            let value = "";
            switch (info.parts[i]) {
                case "G":
                    value = this._t(fullYear < 0
                        ? "_era_bc"
                        : "_era_ad");
                    break;
                case "yyyy":
                    value = Math.abs(fullYear).toString();
                    if (fullYear < 0) {
                        value += this._t("_era_bc");
                    }
                    break;
                case "yyy":
                case "yy":
                case "y":
                    value = Math.abs(fullYear).toString().substr(-info.parts[i].length);
                    if (fullYear < 0) {
                        value += this._t("_era_bc");
                    }
                    break;
                case "YYYY":
                case "YYY":
                case "YY":
                case "Y":
                    let year = _Utils__WEBPACK_IMPORTED_MODULE_2__.getWeekYear(date, this._root.utc);
                    if (info.parts[i] == "YYYY") {
                        value = Math.abs(year).toString();
                    }
                    else {
                        value = Math.abs(year).toString().substr(-info.parts[i].length);
                    }
                    if (year < 0) {
                        value += this._t("_era_bc");
                    }
                    break;
                case "u":
                    // @todo
                    break;
                case "q":
                    value = "" + Math.ceil((date.getMonth() + 1) / 3);
                    break;
                case "MMMMM":
                    value = this._t(this._getMonth(month)).substr(0, 1);
                    break;
                case "MMMM":
                    value = this._t(this._getMonth(month));
                    break;
                case "MMM":
                    value = this._t(this._getShortMonth(month));
                    break;
                case "MM":
                    value = _Utils__WEBPACK_IMPORTED_MODULE_2__.padString(month + 1, 2, "0");
                    break;
                case "M":
                    value = (month + 1).toString();
                    break;
                case "ww":
                    value = _Utils__WEBPACK_IMPORTED_MODULE_2__.padString(_Utils__WEBPACK_IMPORTED_MODULE_2__.getWeek(date, this._root.utc), 2, "0");
                    break;
                case "w":
                    value = _Utils__WEBPACK_IMPORTED_MODULE_2__.getWeek(date, this._root.utc).toString();
                    break;
                case "W":
                    value = _Utils__WEBPACK_IMPORTED_MODULE_2__.getMonthWeek(date, this._root.utc).toString();
                    break;
                case "dd":
                    value = _Utils__WEBPACK_IMPORTED_MODULE_2__.padString(day, 2, "0");
                    break;
                case "d":
                    value = day.toString();
                    break;
                case "DD":
                case "DDD":
                    value = _Utils__WEBPACK_IMPORTED_MODULE_2__.padString(_Utils__WEBPACK_IMPORTED_MODULE_2__.getYearDay(date, this._root.utc).toString(), info.parts[i].length, "0");
                    break;
                case "D":
                    value = _Utils__WEBPACK_IMPORTED_MODULE_2__.getYearDay(date, this._root.utc).toString();
                    break;
                case "F":
                    // @todo
                    break;
                case "g":
                    // @todo
                    break;
                case "t":
                    value = this._root.language.translateFunc("_dateOrd").call(this, day);
                    break;
                case "E":
                    value = (weekday || 7).toString();
                    break;
                case "EE":
                    value = _Utils__WEBPACK_IMPORTED_MODULE_2__.padString((weekday || 7).toString(), 2, "0");
                    break;
                case "EEE":
                case "eee":
                    value = this._t(this._getShortWeekday(weekday));
                    break;
                case "EEEE":
                case "eeee":
                    value = this._t(this._getWeekday(weekday));
                    break;
                case "EEEEE":
                case "eeeee":
                    value = this._t(this._getShortWeekday(weekday)).substr(0, 1);
                    break;
                case "e":
                case "ee":
                    value = (weekday - (this._root.locale.firstDayOfWeek || 1) + 1).toString();
                    if (info.parts[i] == "ee") {
                        value = _Utils__WEBPACK_IMPORTED_MODULE_2__.padString(value, 2, "0");
                    }
                    break;
                case "a":
                    if (hours >= 12) {
                        value = this._t("PM");
                    }
                    else {
                        value = this._t("AM");
                    }
                    break;
                case "aa":
                    if (hours >= 12) {
                        value = this._t("P.M.");
                    }
                    else {
                        value = this._t("A.M.");
                    }
                    break;
                case "aaa":
                    if (hours >= 12) {
                        value = this._t("P");
                    }
                    else {
                        value = this._t("A");
                    }
                    break;
                case "h":
                    value = _Utils__WEBPACK_IMPORTED_MODULE_2__.get12Hours(hours).toString();
                    break;
                case "hh":
                    value = _Utils__WEBPACK_IMPORTED_MODULE_2__.padString(_Utils__WEBPACK_IMPORTED_MODULE_2__.get12Hours(hours), 2, "0");
                    break;
                case "H":
                    value = hours.toString();
                    break;
                case "HH":
                    value = _Utils__WEBPACK_IMPORTED_MODULE_2__.padString(hours, 2, "0");
                    break;
                case "K":
                    value = _Utils__WEBPACK_IMPORTED_MODULE_2__.get12Hours(hours, 0).toString();
                    break;
                case "KK":
                    value = _Utils__WEBPACK_IMPORTED_MODULE_2__.padString(_Utils__WEBPACK_IMPORTED_MODULE_2__.get12Hours(hours, 0), 2, "0");
                    break;
                case "k":
                    value = (hours + 1).toString();
                    break;
                case "kk":
                    value = _Utils__WEBPACK_IMPORTED_MODULE_2__.padString(hours + 1, 2, "0");
                    break;
                case "m":
                    value = minutes.toString();
                    break;
                case "mm":
                    value = _Utils__WEBPACK_IMPORTED_MODULE_2__.padString(minutes, 2, "0");
                    break;
                case "s":
                    value = seconds.toString();
                    break;
                case "ss":
                    value = _Utils__WEBPACK_IMPORTED_MODULE_2__.padString(seconds, 2, "0");
                    break;
                case "S":
                case "SS":
                case "SSS":
                    value = Math.round((milliseconds / 1000) * Math.pow(10, info.parts[i].length)).toString();
                    break;
                case "x":
                    value = timestamp.toString();
                    break;
                case "n":
                case "nn":
                case "nnn":
                    value = _Utils__WEBPACK_IMPORTED_MODULE_2__.padString(milliseconds, info.parts[i].length, "0");
                    break;
                case "z":
                    value = _Utils__WEBPACK_IMPORTED_MODULE_2__.getTimeZone(date, false, false, this._root.utc, this._root.timezone ? this._root.timezone.name : undefined).replace(/[+-]+[0-9]+$/, "");
                    break;
                case "zz":
                    value = _Utils__WEBPACK_IMPORTED_MODULE_2__.getTimeZone(date, true, false, this._root.utc, this._root.timezone ? this._root.timezone.name : undefined);
                    break;
                case "zzz":
                    value = _Utils__WEBPACK_IMPORTED_MODULE_2__.getTimeZone(date, false, true, this._root.utc, this._root.timezone ? this._root.timezone.name : undefined).replace(/[+-]+[0-9]+$/, "");
                    break;
                case "zzzz":
                    value = _Utils__WEBPACK_IMPORTED_MODULE_2__.getTimeZone(date, true, true, this._root.utc, this._root.timezone ? this._root.timezone.name : undefined);
                    break;
                case "Z":
                case "ZZ":
                    let timezone = this._root.utc ? "UTC" : this._root.timezone;
                    if (timezone instanceof _Timezone__WEBPACK_IMPORTED_MODULE_3__.Timezone) {
                        timezone = timezone.name;
                    }
                    const offset = timezone ? _Utils__WEBPACK_IMPORTED_MODULE_2__.getTimezoneOffset(timezone) : date.getTimezoneOffset();
                    let tz = Math.abs(offset) / 60;
                    let tzh = Math.floor(tz);
                    let tzm = tz * 60 - tzh * 60;
                    if (this._root.utc) {
                        tzh = 0;
                        tzm = 0;
                    }
                    if (info.parts[i] == "Z") {
                        value = "GMT";
                        value += offset > 0 ? "-" : "+";
                        value += _Utils__WEBPACK_IMPORTED_MODULE_2__.padString(tzh, 2) + ":" + _Utils__WEBPACK_IMPORTED_MODULE_2__.padString(tzm, 2);
                    }
                    else {
                        value = offset > 0 ? "-" : "+";
                        value += _Utils__WEBPACK_IMPORTED_MODULE_2__.padString(tzh, 2) + _Utils__WEBPACK_IMPORTED_MODULE_2__.padString(tzm, 2);
                    }
                    break;
                case "i":
                    value = date.toISOString();
                    break;
                case "I":
                    value = date.toUTCString();
                    break;
            }
            res = res.replace(_Type__WEBPACK_IMPORTED_MODULE_1__.PLACEHOLDER, value);
        }
        return res;
    }
    /**
     * Parses format into structured infromation.
     *
     * @param format Format template
     */
    parseFormat(format) {
        // Check cache
        // TODO: implement caching of the parsed format
        // Init format parse info holder
        let info = {
            "template": "",
            "parts": []
        };
        // Let TextFormatter split into chunks
        let chunks = _TextFormatter__WEBPACK_IMPORTED_MODULE_4__.TextFormatter.chunk(format, true);
        for (let i = 0; i < chunks.length; i++) {
            let chunk = chunks[i];
            if (chunk.type === "value") {
                // Just "Date"?
                if (chunk.text.match(/^date$/i)) {
                    let dateFormat = this.get("dateFormat", "yyyy-MM-dd");
                    if (!_Type__WEBPACK_IMPORTED_MODULE_1__.isString(dateFormat)) {
                        dateFormat = "yyyy-MM-dd";
                    }
                    chunk.text = dateFormat;
                }
                // Find all possible parts
                let matches = chunk.text.match(/G|yyyy|yyy|yy|y|YYYY|YYY|YY|Y|u|q|MMMMM|MMMM|MMM|MM|M|ww|w|W|dd|d|DDD|DD|D|F|g|EEEEE|EEEE|EEE|EE|E|eeeee|eeee|eee|ee|e|aaa|aa|a|hh|h|HH|H|KK|K|kk|k|mm|m|ss|s|SSS|SS|S|A|zzzz|zzz|zz|z|ZZ|Z|t|x|nnn|nn|n|i|I/g);
                // Found?
                if (matches) {
                    // Populate template
                    for (let x = 0; x < matches.length; x++) {
                        info.parts.push(matches[x]);
                        chunk.text = chunk.text.replace(matches[x], _Type__WEBPACK_IMPORTED_MODULE_1__.PLACEHOLDER);
                    }
                }
            }
            // Apply to template
            info.template += chunk.text;
        }
        // Save cache
        // TODO
        return info;
    }
    _months() {
        return ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
    }
    _getMonth(index) {
        return this._months()[index];
    }
    _shortMonths() {
        return ["Jan", "Feb", "Mar", "Apr", "May(short)", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
    }
    _getShortMonth(index) {
        return this._shortMonths()[index];
    }
    _weekdays() {
        return ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];
    }
    _getWeekday(index) {
        return this._weekdays()[index];
    }
    _shortWeekdays() {
        return ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];
    }
    _getShortWeekday(index) {
        return this._shortWeekdays()[index];
    }
    parse(source, format) {
        // Is it already a Date
        if (source instanceof Date) {
            return source;
        }
        // Is it a numeric timestamp
        if (_Type__WEBPACK_IMPORTED_MODULE_1__.isNumber(source)) {
            return new Date(source);
        }
        // Are we parsing a timestamp?
        if (format == "x") {
            return new Date(parseInt(source));
        }
        // No? Let's check if it's string, and try converting to it if nec
        if (!_Type__WEBPACK_IMPORTED_MODULE_1__.isString(source)) {
            source = source.toString();
        }
        // Init return value
        let res;
        // Init RegEx for parsing
        let reg = "";
        // Clean format
        format = _Utils__WEBPACK_IMPORTED_MODULE_2__.cleanFormat(format);
        // Clip format to length of the source string
        format = format.substr(0, source.length);
        // Parse format
        let info = this.parseFormat(format);
        // Init parsed items holder
        let parsedIndexes = {
            "year": -1,
            "year3": -1,
            "year2": -1,
            "year1": -1,
            "month": -1,
            "monthShort": -1,
            "monthLong": -1,
            "weekdayShort": -1,
            "weekdayLong": -1,
            "day": -1,
            "yearDay": -1,
            "week": -1,
            "hourBase0": -1,
            "hour12Base0": -1,
            "hourBase1": -1,
            "hour12Base1": -1,
            "minute": -1,
            "second": -1,
            "millisecond": -1,
            "millisecondDigits": -1,
            "am": -1,
            "zone": -1,
            "timestamp": -1,
            "iso": -1
        };
        // Init values
        let resValues = {
            "year": 1970,
            "month": 0,
            "day": 1,
            "hour": 0,
            "minute": 0,
            "second": 0,
            "millisecond": 0,
            "timestamp": null,
            "offset": 0,
            "utc": this._root.utc
        };
        // Index adjuster
        let indexAdjust = 0;
        let index = 0;
        // Iterate through all of the parts
        for (let i = 0; i < info.parts.length; i++) {
            // Set current match index
            index = i + indexAdjust + 1;
            switch (info.parts[i]) {
                case "yyyy":
                case "YYYY":
                    reg += "([0-9]{4})";
                    parsedIndexes.year = index;
                    break;
                case "yyy":
                case "YYY":
                    reg += "([0-9]{3})";
                    parsedIndexes.year3 = index;
                    break;
                case "yy":
                case "YY":
                    reg += "([0-9]{2})";
                    parsedIndexes.year2 = index;
                    break;
                case "y":
                case "Y":
                    reg += "([0-9]{1})";
                    parsedIndexes.year1 = index;
                    break;
                case "MMMM":
                    reg += "(" + this.getStringList(this._months()).join("|") + ")";
                    parsedIndexes.monthLong = index;
                    break;
                case "MMM":
                    reg += "(" + this.getStringList(this._shortMonths()).join("|") + ")";
                    parsedIndexes.monthShort = index;
                    break;
                case "MM":
                case "M":
                    reg += "([0-9]{2}|[0-9]{1})";
                    parsedIndexes.month = index;
                    break;
                case "ww":
                case "w":
                    reg += "([0-9]{2}|[0-9]{1})";
                    parsedIndexes.week = index;
                    break;
                case "dd":
                case "d":
                    reg += "([0-9]{2}|[0-9]{1})";
                    parsedIndexes.day = index;
                    break;
                case "DDD":
                case "DD":
                case "D":
                    reg += "([0-9]{3}|[0-9]{2}|[0-9]{1})";
                    parsedIndexes.yearDay = index;
                    break;
                case "dddd":
                    reg += "(" + this.getStringList(this._weekdays()).join("|") + ")";
                    parsedIndexes.weekdayLong = index;
                    break;
                case "ddd":
                    reg += "(" + this.getStringList(this._shortWeekdays()).join("|") + ")";
                    parsedIndexes.weekdayShort = index;
                    break;
                case "aaa":
                case "aa":
                case "a":
                    // TODO: fix (escape regex)
                    reg += "(" + this.getStringList(["AM", "PM", "A\.M\.", "P\.M\.", "A", "P"]).join("|") + ")";
                    parsedIndexes.am = index;
                    break;
                case "hh":
                case "h":
                    reg += "([0-9]{2}|[0-9]{1})";
                    parsedIndexes.hour12Base1 = index;
                    break;
                case "HH":
                case "H":
                    reg += "([0-9]{2}|[0-9]{1})";
                    parsedIndexes.hourBase0 = index;
                    break;
                case "KK":
                case "K":
                    reg += "([0-9]{2}|[0-9]{1})";
                    parsedIndexes.hour12Base0 = index;
                    break;
                case "kk":
                case "k":
                    reg += "([0-9]{2}|[0-9]{1})";
                    parsedIndexes.hourBase1 = index;
                    break;
                case "mm":
                case "m":
                    reg += "([0-9]{2}|[0-9]{1})";
                    parsedIndexes.minute = index;
                    break;
                case "ss":
                case "s":
                    reg += "([0-9]{2}|[0-9]{1})";
                    parsedIndexes.second = index;
                    break;
                case "SSS":
                case "SS":
                case "S":
                    reg += "([0-9]{3}|[0-9]{2}|[0-9]{1})";
                    parsedIndexes.millisecond = index;
                    parsedIndexes.millisecondDigits = info.parts[i].length;
                    break;
                case "nnn":
                case "nn":
                case "n":
                    reg += "([0-9]{3}|[0-9]{2}|[0-9]{1})";
                    parsedIndexes.millisecond = index;
                    break;
                case "x":
                    reg += "([0-9]{1,})";
                    parsedIndexes.timestamp = index;
                    break;
                case "Z":
                    reg += "GMT([-+]+[0-9]{2}:[0-9]{2})";
                    parsedIndexes.zone = index;
                    break;
                case "ZZ":
                    reg += "([\\-+]+[0-9]{2}[0-9]{2})";
                    parsedIndexes.zone = index;
                    break;
                case "i":
                    reg += "([0-9]{4})-?([0-9]{2})-?([0-9]{2})T?([0-9]{2}):?([0-9]{2}):?([0-9]{2})\\.?([0-9]{0,3})([zZ]|[+\\-][0-9]{2}:?[0-9]{2}|$)";
                    parsedIndexes.iso = index;
                    indexAdjust += 7;
                    break;
                case "G":
                case "YYYY":
                case "YYY":
                case "YY":
                case "Y":
                case "MMMMM":
                case "W":
                case "EEEEE":
                case "EEEE":
                case "EEE":
                case "EE":
                case "E":
                case "eeeee":
                case "eeee":
                case "eee":
                case "ee":
                case "e":
                case "zzzz":
                case "zzz":
                case "zz":
                case "z":
                case "t":
                    // Ignore
                    indexAdjust--;
                    break;
            }
            reg += "[^0-9]*";
        }
        // Try matching
        let regex = new RegExp(reg);
        let matches = source.match(regex);
        if (matches) {
            // Populate the date object
            // Full year
            if (parsedIndexes.year > -1) {
                resValues.year = parseInt(matches[parsedIndexes.year]);
            }
            // 3-digit year
            if (parsedIndexes.year3 > -1) {
                let val = parseInt(matches[parsedIndexes.year3]);
                val += 1000;
                resValues.year = val;
            }
            // 2-digit year
            if (parsedIndexes.year2 > -1) {
                let val = parseInt(matches[parsedIndexes.year2]);
                if (val > 50) {
                    val += 1000;
                }
                else {
                    val += 2000;
                }
                resValues.year = val;
            }
            // 1-digit year
            if (parsedIndexes.year1 > -1) {
                let val = parseInt(matches[parsedIndexes.year1]);
                val = Math.floor((new Date().getFullYear()) / 10) * 10 + val;
                resValues.year = val;
            }
            // Full month
            if (parsedIndexes.monthLong > -1) {
                resValues.month = this.resolveMonth(matches[parsedIndexes.monthLong]);
            }
            // Short month
            if (parsedIndexes.monthShort > -1) {
                resValues.month = this.resolveShortMonth(matches[parsedIndexes.monthShort]);
            }
            // Numeric month
            if (parsedIndexes.month > -1) {
                resValues.month = parseInt(matches[parsedIndexes.month]) - 1;
            }
            // Weekday
            // @todo
            // Week
            if ((parsedIndexes.week > -1) && (parsedIndexes.day === -1)) {
                // We parse weeks ONLY if day is not explicitly set
                // TODO: this needs work
                // (but maybe later - I can hardly imagine anyone passing their dates in weeks)
                resValues.month = 0;
                resValues.day = _Utils__WEBPACK_IMPORTED_MODULE_2__.getDayFromWeek(parseInt(matches[parsedIndexes.week]), resValues.year, 1, this._root.utc);
            }
            // Day
            if (parsedIndexes.day > -1) {
                resValues.day = parseInt(matches[parsedIndexes.day]);
            }
            // Year day
            if (parsedIndexes.yearDay > -1) {
                resValues.month = 0;
                resValues.day = parseInt(matches[parsedIndexes.yearDay]);
            }
            // 24 Hour (0-23)
            if (parsedIndexes.hourBase0 > -1) {
                resValues.hour = parseInt(matches[parsedIndexes.hourBase0]);
            }
            // 24 Hour (1-24)
            if (parsedIndexes.hourBase1 > -1) {
                resValues.hour = parseInt(matches[parsedIndexes.hourBase1]) - 1;
            }
            // 12 Hour (0-11)
            if (parsedIndexes.hour12Base0 > -1) {
                let val = parseInt(matches[parsedIndexes.hour12Base0]);
                if (val == 11) {
                    val = 0;
                }
                if ((parsedIndexes.am > -1) && !this.isAm(matches[parsedIndexes.am])) {
                    val += 12;
                }
                resValues.hour = val;
            }
            // 12 Hour (1-12)
            if (parsedIndexes.hour12Base1 > -1) {
                let val = parseInt(matches[parsedIndexes.hour12Base1]);
                if (val == 12) {
                    val = 0;
                }
                if ((parsedIndexes.am > -1) && !this.isAm(matches[parsedIndexes.am])) {
                    val += 12;
                }
                resValues.hour = val;
            }
            // Minute
            if (parsedIndexes.minute > -1) {
                resValues.minute = parseInt(matches[parsedIndexes.minute]);
            }
            // Second
            if (parsedIndexes.second > -1) {
                resValues.second = parseInt(matches[parsedIndexes.second]);
            }
            // Millisecond
            if (parsedIndexes.millisecond > -1) {
                let val = parseInt(matches[parsedIndexes.millisecond]);
                if (parsedIndexes.millisecondDigits == 2) {
                    val *= 10;
                }
                else if (parsedIndexes.millisecondDigits == 1) {
                    val *= 100;
                }
                resValues.millisecond = val;
            }
            // Timestamp
            if (parsedIndexes.timestamp > -1) {
                resValues.timestamp = parseInt(matches[parsedIndexes.timestamp]);
                const ts = new Date(resValues.timestamp);
                resValues.year = ts.getUTCFullYear();
                resValues.month = ts.getUTCMonth();
                resValues.day = ts.getUTCDate();
                resValues.hour = ts.getUTCHours();
                resValues.minute = ts.getUTCMinutes();
                resValues.second = ts.getUTCSeconds();
                resValues.millisecond = ts.getUTCMilliseconds();
            }
            // Adjust time zone
            if (parsedIndexes.zone > -1) {
                resValues.offset = this.resolveTimezoneOffset(new Date(resValues.year, resValues.month, resValues.day), matches[parsedIndexes.zone]);
            }
            // ISO
            if (parsedIndexes.iso > -1) {
                resValues.year = _Type__WEBPACK_IMPORTED_MODULE_1__.toNumber(matches[parsedIndexes.iso + 0]);
                resValues.month = _Type__WEBPACK_IMPORTED_MODULE_1__.toNumber(matches[parsedIndexes.iso + 1]) - 1;
                resValues.day = _Type__WEBPACK_IMPORTED_MODULE_1__.toNumber(matches[parsedIndexes.iso + 2]);
                resValues.hour = _Type__WEBPACK_IMPORTED_MODULE_1__.toNumber(matches[parsedIndexes.iso + 3]);
                resValues.minute = _Type__WEBPACK_IMPORTED_MODULE_1__.toNumber(matches[parsedIndexes.iso + 4]);
                resValues.second = _Type__WEBPACK_IMPORTED_MODULE_1__.toNumber(matches[parsedIndexes.iso + 5]);
                resValues.millisecond = _Type__WEBPACK_IMPORTED_MODULE_1__.toNumber(matches[parsedIndexes.iso + 6]);
                if (matches[parsedIndexes.iso + 7] == "Z" || matches[parsedIndexes.iso + 7] == "z") {
                    resValues.utc = true;
                }
                else if (matches[parsedIndexes.iso + 7] != "") {
                    resValues.offset = this.resolveTimezoneOffset(new Date(resValues.year, resValues.month, resValues.day), matches[parsedIndexes.iso + 7]);
                }
            }
            // Create Date object
            if (resValues.utc) {
                res = new Date(Date.UTC(resValues.year, resValues.month, resValues.day, resValues.hour, resValues.minute, resValues.second, resValues.millisecond));
            }
            else {
                res = new Date(resValues.year, resValues.month, resValues.day, resValues.hour, resValues.minute + resValues.offset, resValues.second, resValues.millisecond);
            }
        }
        else {
            // Didn't match anything
            // Let's try dropping it into Date constructor and hope for the best
            res = new Date(source);
        }
        return res;
    }
    resolveTimezoneOffset(date, zone) {
        let value = zone.match(/([+\-]?)([0-9]{2}):?([0-9]{2})/);
        if (value) {
            let match = zone.match(/([+\-]?)([0-9]{2}):?([0-9]{2})/);
            let dir = match[1];
            let hour = match[2];
            let minute = match[3];
            let offset = parseInt(hour) * 60 + parseInt(minute);
            // Adjust offset
            // Making it negative does not seem to make sense, but it's right
            // because of how JavaScript calculates GMT offsets
            if (dir == "+") {
                offset *= -1;
            }
            // Check the difference in offset
            let originalOffset = (date || new Date()).getTimezoneOffset();
            let diff = offset - originalOffset;
            return diff;
        }
        return 0;
    }
    /**
     * Resolves month name (i.e. "December") into a month number (11).
     *
     * @param value  Month name
     * @return Month number
     */
    resolveMonth(value) {
        // Let's try English first
        let month = this._months().indexOf(value);
        if (month > -1) {
            return month;
        }
        // Try the translation
        if (!this._root.language.isDefault()) {
            month = this._root.language.translateAll(this._months()).indexOf(value);
            if (month > -1) {
                return month;
            }
        }
        return 0;
    }
    /**
     * Resolves short month name (i.e. "Dec") into a month number.
     *
     * @param value  Short month name
     * @return Month number
     */
    resolveShortMonth(value) {
        // Let's try English first
        let month = this._shortMonths().indexOf(value);
        if (month > -1) {
            return month;
        }
        // Maybe long month (workaround for May)
        month = this._months().indexOf(value);
        if (month > -1) {
            return month;
        }
        // Try the translation
        if (this._root.language && !this._root.language.isDefault()) {
            month = this._root.language.translateAll(this._shortMonths()).indexOf(value);
            if (month > -1) {
                return month;
            }
        }
        return 0;
    }
    /**
     * Checks if passed in string represents AM/PM notation in many of its
     * versions.
     *
     * @param value  Source string
     * @return Is it AM/PM?
     */
    isAm(value) {
        let list = this.getStringList(["AM", "A.M.", "A"]);
        return list.indexOf(value.toUpperCase()) > -1;
    }
    /**
     * Translates list of strings.
     *
     * @param list  Source strings
     * @return Translated strings
     */
    getStringList(list) {
        let res = [];
        for (let i = 0; i < list.length; i++) {
            // translate?
            if (this._root.language) {
                res.push(_Utils__WEBPACK_IMPORTED_MODULE_2__.escapeForRgex(this._t(list[i])));
            }
            else {
                res.push(_Utils__WEBPACK_IMPORTED_MODULE_2__.escapeForRgex(list[i]));
            }
        }
        return res;
    }
}
//# sourceMappingURL=DateFormatter.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/core/util/Disposer.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/core/util/Disposer.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ArrayDisposer: () => (/* binding */ ArrayDisposer),
/* harmony export */   CounterDisposer: () => (/* binding */ CounterDisposer),
/* harmony export */   Disposer: () => (/* binding */ Disposer),
/* harmony export */   DisposerClass: () => (/* binding */ DisposerClass),
/* harmony export */   MultiDisposer: () => (/* binding */ MultiDisposer),
/* harmony export */   MutableValueDisposer: () => (/* binding */ MutableValueDisposer)
/* harmony export */ });
/* harmony import */ var _Array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Array */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Array.js");
/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */

/**
 * A base class for disposable objects.
 *
 * @ignore Exclude from docs
 */
class DisposerClass {
    /**
     * Constructor.
     */
    constructor() {
        /**
         * Is object disposed?
         */
        Object.defineProperty(this, "_disposed", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this._disposed = false;
    }
    /**
     * Checks if object is disposed.
     *
     * @return Disposed?
     */
    isDisposed() {
        return this._disposed;
    }
    /**
     * Disposes the object.
     */
    dispose() {
        if (!this._disposed) {
            this._disposed = true;
            this._dispose();
        }
    }
}
/**
 * A class for creating an IDisposer.
 *
 * @ignore Exclude from docs
 */
class Disposer {
    /**
     * Constructor.
     *
     * @param dispose  Function that disposes object
     */
    constructor(dispose) {
        /**
         * Is object disposed?
         */
        Object.defineProperty(this, "_disposed", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /**
         * Method that disposes the object.
         */
        Object.defineProperty(this, "_dispose", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this._disposed = false;
        this._dispose = dispose;
    }
    /**
     * Checks if object is disposed.
     *
     * @return Disposed?
     */
    isDisposed() {
        return this._disposed;
    }
    /**
     * Disposes the object.
     */
    dispose() {
        if (!this._disposed) {
            this._disposed = true;
            this._dispose();
        }
    }
}
/**
 * This can be extended by other classes to add a `_disposers` property.
 *
 * @ignore Exclude from docs
 */
class ArrayDisposer extends DisposerClass {
    constructor() {
        super(...arguments);
        Object.defineProperty(this, "_disposers", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
        });
    }
    _dispose() {
        _Array__WEBPACK_IMPORTED_MODULE_0__.each(this._disposers, (x) => {
            x.dispose();
        });
    }
}
/**
 * A collection of related disposers that can be disposed in one go.
 *
 * @ignore Exclude from docs
 */
class MultiDisposer extends DisposerClass {
    constructor(disposers) {
        super();
        Object.defineProperty(this, "_disposers", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this._disposers = disposers;
    }
    _dispose() {
        _Array__WEBPACK_IMPORTED_MODULE_0__.each(this._disposers, (x) => {
            x.dispose();
        });
    }
    get disposers() {
        return this._disposers;
    }
}
/**
 * A special kind of Disposer that has attached value set.
 *
 * If a new value is set using `set()` method, the old disposer value is
 * disposed.
 *
 * @ignore Exclude from docs
 * @todo Description
 */
class MutableValueDisposer extends DisposerClass {
    constructor() {
        super(...arguments);
        /**
         * Current disposer.
         */
        Object.defineProperty(this, "_disposer", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /**
         * Current value.
         */
        Object.defineProperty(this, "_value", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
    }
    _dispose() {
        if (this._disposer != null) {
            this._disposer.dispose();
            this._disposer = undefined;
        }
    }
    /**
     * Returns current value.
     *
     * @return Value
     */
    get() {
        return this._value;
    }
    /**
     * Sets value and disposes previous disposer if it was set.
     *
     * @param value     New value
     * @param disposer  Disposer
     */
    set(value, disposer) {
        if (this._disposer != null) {
            this._disposer.dispose();
        }
        this._disposer = disposer;
        this._value = value;
    }
    /**
     * Resets the disposer value.
     */
    reset() {
        this.set(undefined, undefined);
    }
}
/**
 * @ignore Exclude from docs
 * @todo Description
 */
class CounterDisposer extends Disposer {
    constructor() {
        super(...arguments);
        /**
         * [_counter description]
         *
         * @todo Description
         */
        Object.defineProperty(this, "_counter", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
    }
    /**
     * [increment description]
     *
     * @todo Description
     */
    increment() {
        // TODO throw an error if it is disposed
        ++this._counter;
        // TODO make this more efficient
        return new Disposer(() => {
            --this._counter;
            if (this._counter === 0) {
                this.dispose();
            }
        });
    }
}
//# sourceMappingURL=Disposer.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/core/util/Draw.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/core/util/Draw.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   clear: () => (/* binding */ clear),
/* harmony export */   line: () => (/* binding */ line),
/* harmony export */   moveTo: () => (/* binding */ moveTo),
/* harmony export */   segmentedLine: () => (/* binding */ segmentedLine),
/* harmony export */   smoothedLine: () => (/* binding */ smoothedLine),
/* harmony export */   smoothedSegmentedline: () => (/* binding */ smoothedSegmentedline)
/* harmony export */ });
/* harmony import */ var _Math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Math */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Math.js");
/** @ignore */ /** */

/**
 * @ignore
 */
function segmentedLine(display, segments) {
    for (let s = 0, len = segments.length; s < len; s++) {
        const groups = segments[s];
        if (groups.length > 0) {
            let firstGroup = groups[0];
            if (firstGroup.length > 0) {
                let firstPoint = firstGroup[0];
                display.moveTo(firstPoint.x, firstPoint.y);
                for (let g = 0, len = groups.length; g < len; g++) {
                    line(display, groups[g]);
                }
            }
        }
    }
}
/**
 * @ignore
 */
function line(display, points) {
    for (let p = 0, len = points.length; p < len; p++) {
        const point = points[p];
        display.lineTo(point.x, point.y);
    }
}
/**
 * @ignore
 */
function moveTo(display, point) {
    display.moveTo(point.x, point.y);
}
/**
 * @ignore
 */
function clear(display) {
    display.clear();
}
/**
 * @ignore
 */
function smoothedSegmentedline(display, segments, tensionX, tensionY) {
    for (let s = 0, len = segments.length; s < len; s++) {
        const groups = segments[s];
        if (groups.length > 0) {
            let firstGroup = groups[0];
            if (firstGroup.length > 0) {
                let firstPoint = firstGroup[0];
                display.moveTo(firstPoint.x, firstPoint.y);
                for (let g = 0, len = groups.length; g < len; g++) {
                    const points = groups[g];
                    if (points.length > 0) {
                        display.lineTo(points[0].x, points[0].y);
                    }
                    smoothedLine(display, points, tensionX, tensionY);
                }
            }
        }
    }
}
/**
 * @ignore
 */
function smoothedLine(display, points, tensionX, tensionY) {
    for (let i = points.length - 1; i > 0; i--) {
        let p0 = points[i];
        let p1 = points[i - 1];
        if (Math.abs(p0.x - p1.x) < 0.1 && Math.abs(p0.y - p1.y) < 0.1) {
            points.splice(i - 1, 1);
        }
    }
    if (points.length < 3 || (tensionX >= 1 && tensionY >= 1)) {
        line(display, points);
        return;
    }
    tensionX = 1 - tensionX + 0.00001;
    tensionY = 1 - tensionY + 0.00001;
    let first = points[0];
    let last = points[points.length - 1];
    let closed = false;
    if (_Math__WEBPACK_IMPORTED_MODULE_0__.round(first.x, 3) == _Math__WEBPACK_IMPORTED_MODULE_0__.round(last.x) && _Math__WEBPACK_IMPORTED_MODULE_0__.round(first.y) == _Math__WEBPACK_IMPORTED_MODULE_0__.round(last.y)) {
        closed = true;
    }
    // Can't moveTo here, as it wont be possible to have fill then.
    let path = "";
    for (let i = 0, len = points.length - 1; i < len; i++) {
        let p0 = points[i - 1];
        let p1 = points[i];
        let p2 = points[i + 1];
        let p3 = points[i + 2];
        if (i === 0) {
            if (closed) {
                p0 = points[len - 2];
            }
            else {
                p0 = points[0];
            }
        }
        else if (i == len - 1) {
            if (closed) {
                p3 = points[1];
            }
            else {
                p3 = p2;
            }
        }
        let controlPointA = _Math__WEBPACK_IMPORTED_MODULE_0__.getCubicControlPointA(p0, p1, p2, tensionX, tensionY);
        let controlPointB = _Math__WEBPACK_IMPORTED_MODULE_0__.getCubicControlPointB(p1, p2, p3, tensionX, tensionY);
        display.bezierCurveTo(controlPointA.x, controlPointA.y, controlPointB.x, controlPointB.y, p2.x, p2.y);
    }
    return path;
}
//# sourceMappingURL=Draw.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/core/util/DurationFormatter.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/core/util/DurationFormatter.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DurationFormatter: () => (/* binding */ DurationFormatter)
/* harmony export */ });
/* harmony import */ var _Entity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Entity */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Entity.js");
/* harmony import */ var _TextFormatter__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./TextFormatter */ "./node_modules/@amcharts/amcharts5/.internal/core/util/TextFormatter.js");
/* harmony import */ var _Object__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Object */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Object.js");
/* harmony import */ var _Utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Utils */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Utils.js");
/* harmony import */ var _Type__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Type */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Type.js");





/**
 * A class used to format numberic values as time duration.
 *
 * @see {@link https://www.amcharts.com/docs/v5/concepts/formatters/formatting-durations/} for more info
 */
class DurationFormatter extends _Entity__WEBPACK_IMPORTED_MODULE_0__.Entity {
    constructor() {
        super(...arguments);
        /**
         * Collection of aliases for units.
         */
        Object.defineProperty(this, "_unitAliases", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {
                "Y": "y",
                "D": "d",
                "H": "h",
                "K": "h",
                "k": "h",
                "n": "S"
            }
        });
    }
    _setDefaults() {
        const dmillisecond = "_duration_millisecond";
        const dsecond = "_duration_second";
        const dminute = "_duration_minute";
        const dhour = "_duration_hour";
        const dday = "_duration_day";
        const dweek = "_duration_week";
        const dmonth = "_duration_month";
        const dyear = "_duration_year";
        const asecond = "_second";
        const aminute = "_minute";
        const ahour = "_hour";
        const aday = "_day";
        const aweek = "_week";
        const amonth = "_week";
        const ayear = "_year";
        // Defaults
        this._setDefault("negativeBase", 0);
        this._setDefault("baseUnit", "second");
        this._setDefault("durationFormats", {
            "millisecond": {
                "millisecond": this._t(dmillisecond),
                "second": this._t((dmillisecond + asecond)),
                "minute": this._t((dmillisecond + aminute)),
                "hour": this._t((dmillisecond + ahour)),
                "day": this._t((dmillisecond + aday)),
                "week": this._t((dmillisecond + aweek)),
                "month": this._t((dmillisecond + amonth)),
                "year": this._t((dmillisecond + ayear))
            },
            "second": {
                "second": this._t((dsecond)),
                "minute": this._t((dsecond + aminute)),
                "hour": this._t((dsecond + ahour)),
                "day": this._t((dsecond + aday)),
                "week": this._t((dsecond + aweek)),
                "month": this._t((dsecond + amonth)),
                "year": this._t((dsecond + ayear))
            },
            "minute": {
                "minute": this._t((dminute)),
                "hour": this._t((dminute + ahour)),
                "day": this._t((dminute + aday)),
                "week": this._t((dminute + aweek)),
                "month": this._t((dminute + amonth)),
                "year": this._t((dminute + ayear))
            },
            "hour": {
                "hour": this._t((dhour)),
                "day": this._t((dhour + aday)),
                "week": this._t((dhour + aweek)),
                "month": this._t((dhour + amonth)),
                "year": this._t((dhour + ayear))
            },
            "day": {
                "day": this._t((dday)),
                "week": this._t((dday + aweek)),
                "month": this._t((dday + amonth)),
                "year": this._t((dday + ayear))
            },
            "week": {
                "week": this._t((dweek)),
                "month": this._t((dweek + amonth)),
                "year": this._t((dweek + ayear))
            },
            "month": {
                "month": this._t((dmonth)),
                "year": this._t((dmonth + ayear))
            },
            "year": {
                "year": this._t(dyear)
            }
        });
        super._setDefaults();
    }
    _beforeChanged() {
        super._beforeChanged();
    }
    /**
     * Formats the number as duration.
     *
     * For example `1000` (base unit seconds) would be converted to `16:40` as in
     * 16 minutes and 40 seconds.
     *
     * @param value   Value to format
     * @param format  Format to apply
     * @param base    Override base unit
     * @return Formatted number
     */
    format(value, format, base) {
        // no base unit?
        let baseUnit = base || this.get("baseUnit");
        // no format passed in or empty
        if (typeof format === "undefined" || format === "") {
            if (this.get("durationFormat") != null) {
                format = this.get("durationFormat");
            }
            else {
                format = this.getFormat(_Type__WEBPACK_IMPORTED_MODULE_1__.toNumber(value), undefined, baseUnit);
            }
        }
        // Clean format
        format = _Utils__WEBPACK_IMPORTED_MODULE_2__.cleanFormat(format);
        // get format info (it will also deal with parser caching)
        let info = this.parseFormat(format, baseUnit);
        // cast to number just in case
        // TODO: maybe use better casting
        let source = Number(value);
        // format and replace the number
        let details;
        if (source > this.get("negativeBase")) {
            details = info.positive;
        }
        else if (source < this.get("negativeBase")) {
            details = info.negative;
        }
        else {
            details = info.zero;
        }
        // Format
        let formatted = this.applyFormat(source, details);
        // Apply color?
        if (details.color !== "") {
            formatted = "[" + details.color + "]" + formatted + "[/]";
        }
        return formatted;
    }
    /**
     * Parses supplied format into structured object which can be used to format
     * the number.
     *
     * @param format  Format string, i.e. "#,###.00"
     * @param base    Override base unit
     * @return Parsed information
     */
    parseFormat(format, base) {
        // Check cache
        // TODO
        // let cached = this.getCache(format);
        // if (cached != null) {
        // 	return cached;
        // }
        // no base unit?
        let baseUnit = base || this.get("baseUnit");
        // Initialize duration parsing info
        let info = {
            "positive": {
                "color": "",
                "template": "",
                "parts": [],
                "source": "",
                "baseUnit": baseUnit,
                "parsed": false,
                "absolute": false
            },
            "negative": {
                "color": "",
                "template": "",
                "parts": [],
                "source": "",
                "baseUnit": baseUnit,
                "parsed": false,
                "absolute": false
            },
            "zero": {
                "color": "",
                "template": "",
                "parts": [],
                "source": "",
                "baseUnit": baseUnit,
                "parsed": false,
                "absolute": false
            }
        };
        // Escape double vertical bars (that mean display one vertical bar)
        format = format.replace("||", _Type__WEBPACK_IMPORTED_MODULE_1__.PLACEHOLDER2);
        // Split it up and deal with different formats
        let parts = format.split("|");
        info.positive.source = parts[0];
        if (typeof parts[2] === "undefined") {
            info.zero = info.positive;
        }
        else {
            info.zero.source = parts[2];
        }
        if (typeof parts[1] === "undefined") {
            info.negative = info.positive;
        }
        else {
            info.negative.source = parts[1];
        }
        // Parse each
        _Object__WEBPACK_IMPORTED_MODULE_3__.each(info, (_part, item) => {
            // Already parsed
            if (item.parsed) {
                return;
            }
            // Check cached
            // TODO
            // if (typeof this.getCache(item.source) !== "undefined") {
            // 	info[part] = this.getCache(item.source);
            // 	return;
            // }
            // Begin parsing
            let partFormat = item.source;
            // Check for [] directives
            let dirs = [];
            dirs = item.source.match(/^\[([^\]]*)\]/);
            if (dirs && dirs.length && dirs[0] !== "") {
                partFormat = item.source.substr(dirs[0].length);
                item.color = dirs[1];
            }
            // Let TextFormatter split into chunks
            let chunks = _TextFormatter__WEBPACK_IMPORTED_MODULE_4__.TextFormatter.chunk(partFormat, true);
            for (let i = 0; i < chunks.length; i++) {
                let chunk = chunks[i];
                // replace back double vertical bar
                chunk.text = chunk.text.replace(_Type__WEBPACK_IMPORTED_MODULE_1__.PLACEHOLDER2, "|");
                if (chunk.type === "value") {
                    // Just "Duration"?
                    // if (chunk.text.toLowerCase() === "duration") {
                    // 	chunk.text = durationFormat;
                    // }
                    // Check for "a" (absolute) modifier
                    if (chunk.text.match(/[yYMdDwhHKkmsSn]+a/)) {
                        item.absolute = true;
                        chunk.text = chunk.text.replace(/([yYMdDwhHKkmsSn]+)a/, "$1");
                    }
                    // Find all possible parts
                    let matches = chunk.text.match(/y+|Y+|M+|d+|D+|w+|h+|H+|K+|k+|m+|s+|S+|n+/g);
                    if (matches) {
                        // Populate template
                        for (let x = 0; x < matches.length; x++) {
                            // Is it an alias?
                            if (matches[x] == null) {
                                matches[x] = this._unitAliases[matches[x]];
                            }
                            item.parts.push(matches[x]);
                            chunk.text = chunk.text.replace(matches[x], _Type__WEBPACK_IMPORTED_MODULE_1__.PLACEHOLDER);
                        }
                    }
                }
                // Apply to template
                item.template += chunk.text;
            }
            // Apply style formatting
            //item.template = TextFormatter.format(item.template, this.outputFormat);
            // Save cache
            // TODO
            //this.setCache(item.source, item);
            // Mark this as parsed
            item.parsed = true;
        });
        // Save cache (the whole thing)
        // TODO
        //this.setCache(format, info);
        return info;
    }
    /**
     * Applies parsed format to a numeric value.
     *
     * @param value    Value
     * @param details  Parsed format as returned by {parseFormat}
     * @return Formatted duration
     */
    applyFormat(value, details) {
        // Use absolute values
        let negative = !details.absolute && (value < this.get("negativeBase"));
        value = Math.abs(value);
        // Recalculate to milliseconds
        let tstamp = this.toTimeStamp(value, details.baseUnit);
        // Init return value
        let res = details.template;
        // Iterate through duration parts
        for (let i = 0, len = details.parts.length; i < len; i++) {
            // Gather the part
            let part = details.parts[i];
            let unit = this._toTimeUnit(part.substr(0, 1));
            let digits = part.length;
            // Calculate current unit value
            let ints = Math.floor(tstamp / this._getUnitValue(unit));
            res = res.replace(_Type__WEBPACK_IMPORTED_MODULE_1__.PLACEHOLDER, _Utils__WEBPACK_IMPORTED_MODULE_2__.padString(ints, digits, "0"));
            // Reduce timestamp
            tstamp -= ints * this._getUnitValue(unit);
        }
        // Reapply negative sign
        if (negative) {
            res = "-" + res;
        }
        return res;
    }
    /**
     * Converts numeric value to timestamp in milliseconds.
     *
     * @param value     A source value
     * @param baseUnit  Base unit the source value is in: "q", "s", "i", "h", "d", "w", "m", "y"
     * @return Value representation as a timestamp in milliseconds
     */
    toTimeStamp(value, baseUnit) {
        return value * this._getUnitValue(baseUnit);
    }
    _toTimeUnit(code) {
        switch (code) {
            case "S":
                return "millisecond";
            case "s":
                return "second";
            case "m":
                return "minute";
            case "h":
                return "hour";
            case "d":
                return "day";
            case "w":
                return "week";
            case "M":
                return "month";
            case "y":
                return "year";
        }
        ;
    }
    /**
     * Returns appropriate default format for the value.
     *
     * If `maxValue` is sepcified, it will use that value to determine the time
     * unit for the format.
     *
     * For example if your `baseUnit` is `"second"` and you pass in `10`, you
     * will get `"10"`.
     *
     * However, you might want it to be formatted in the context of bigger scale,
     * say 10 minutes (600 seconds). If you pass in `600` as `maxValue`, all
     * values, including small ones will use format with minutes, e.g.:
     * `00:10`, `00:50`, `12: 30`, etc.
     *
     * @param value     Value to format
     * @param maxValue  Maximum value to be used to determine format
     * @param baseUnit  Base unit of the value
     * @return Format
     */
    getFormat(value, maxValue, baseUnit) {
        // Is format override set?
        if (this.get("durationFormat") != null) {
            return this.get("durationFormat");
        }
        // Get base unit
        if (!baseUnit) {
            baseUnit = this.get("baseUnit");
        }
        if (maxValue != null && value != maxValue) {
            value = Math.abs(value);
            maxValue = Math.abs(maxValue);
            let maxUnit = this.getValueUnit(Math.max(value, maxValue), baseUnit);
            return this.get("durationFormats")[baseUnit][maxUnit];
        }
        else {
            let unit = this.getValueUnit(value, baseUnit);
            return this.get("durationFormats")[baseUnit][unit];
        }
    }
    /**
     * Returns value's closest denominator time unit, e.g 100 seconds is
     * `"minute"`, while 59 seconds would still be `second`.
     *
     * @param value     Source duration value
     * @param baseUnit  Base unit
     * @return Denominator
     */
    getValueUnit(value, baseUnit) {
        // Get base unit
        if (!baseUnit) {
            baseUnit = this.get("baseUnit");
        }
        // Convert to milliseconds
        let currentUnit;
        let ms = this.getMilliseconds(value, baseUnit);
        _Object__WEBPACK_IMPORTED_MODULE_3__.eachContinue(this._getUnitValues(), (key, val) => {
            if (key == baseUnit || currentUnit) {
                let num = ms / val;
                if (num <= 1) {
                    if (!currentUnit) {
                        currentUnit = key;
                    }
                    return false;
                }
                currentUnit = key;
            }
            return true;
        });
        return currentUnit;
    }
    /**
     * Converts value to milliseconds according to `baseUnit`.
     *
     * @param value     Source duration value
     * @param baseUnit  Base unit
     * @return Value in milliseconds
     */
    getMilliseconds(value, baseUnit) {
        // Get base unit
        if (!baseUnit) {
            baseUnit = this.get("baseUnit");
        }
        return value * this._getUnitValue(baseUnit);
    }
    _getUnitValue(timeUnit) {
        return this._getUnitValues()[timeUnit];
    }
    _getUnitValues() {
        return {
            "millisecond": 1,
            "second": 1000,
            "minute": 60000,
            "hour": 3600000,
            "day": 86400000,
            "week": 604800000,
            "month": 2592000000,
            "year": 31536000000,
        };
    }
}
//# sourceMappingURL=DurationFormatter.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/core/util/Ease.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/core/util/Ease.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   bounce: () => (/* binding */ bounce),
/* harmony export */   circle: () => (/* binding */ circle),
/* harmony export */   cubic: () => (/* binding */ cubic),
/* harmony export */   elastic: () => (/* binding */ elastic),
/* harmony export */   exp: () => (/* binding */ exp),
/* harmony export */   inOut: () => (/* binding */ inOut),
/* harmony export */   linear: () => (/* binding */ linear),
/* harmony export */   out: () => (/* binding */ out),
/* harmony export */   pow: () => (/* binding */ pow),
/* harmony export */   quad: () => (/* binding */ quad),
/* harmony export */   sine: () => (/* binding */ sine),
/* harmony export */   yoyo: () => (/* binding */ yoyo)
/* harmony export */ });
/* harmony import */ var _Math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Math */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Math.js");
/**
 * A collection of easing functions
 *
 * Parts of this collection are taken from D3.js library (https://d3js.org/)
 */
/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */

/**
 * The functions below are from D3.js library (https://d3js.org/)
 *
 * ----------------------------------------------------------------------------
 * Copyright 2017 Mike Bostock
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 *	this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *	this list of conditions and the following disclaimer in the documentation
 *	and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the copyright holder nor the names of its
 *	contributors may be used to endorse or promote products derived from this
 *	software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 * ----------------------------------------------------------------------------
 * @hidden
 */
/**
 */
function linear(t) {
    return t;
}
function quad(t) {
    return t * t;
}
function cubic(t) {
    return t * t * t;
}
function pow(t, e) {
    return Math.pow(t, e);
}
function exp(t) {
    return Math.pow(2, 10 * t - 10);
}
function sine(t) {
    return 1 - Math.cos(t * _Math__WEBPACK_IMPORTED_MODULE_0__.HALFPI);
}
function circle(t) {
    return 1 - Math.sqrt(1 - t * t);
}
/**
 * ============================================================================
 * TRANSFORMERS
 * ============================================================================
 * @hidden
 */
/**
 */
function yoyo(ease) {
    return function (t) {
        if (t < 0.5) {
            return ease(t * 2.0);
        }
        else {
            return ease((1.0 - t) * 2.0);
        }
    };
}
function out(ease) {
    return function (t) {
        return 1.0 - ease(1.0 - t);
    };
}
function inOut(ease) {
    return function (t) {
        if (t <= 0.5) {
            return ease(t * 2.0) / 2.0;
        }
        else {
            return 1.0 - (ease((1.0 - t) * 2.0) / 2.0);
        }
    };
}
/**
 * ============================================================================
 * BOUNCE
 * ============================================================================
 * @hidden
 */
let b1 = 4 / 11, b2 = 6 / 11, b3 = 8 / 11, b4 = 3 / 4, b5 = 9 / 11, b6 = 10 / 11, b7 = 15 / 16, b8 = 21 / 22, b9 = 63 / 64, b0 = 1 / b1 / b1;
function bounce(t) {
    return 1 - bounceOut(1 - t);
}
/**
 * @ignore
 */
function bounceOut(t) {
    t = t;
    if (t < b1) {
        return b0 * t * t;
    }
    else if (t < b3) {
        return b0 * (t -= b2) * t + b4;
    }
    else if (t < b6) {
        return b0 * (t -= b5) * t + b7;
    }
    else {
        return b0 * (t -= b8) * t + b9;
    }
}
/**
 * ============================================================================
 * ELASTIC
 * ============================================================================
 * @hidden
 */
/**
 * @ignore
 */
let tau = 2 * Math.PI;
/**
 * @ignore
 */
let amplitude = 1;
/**
 * @ignore
 */
let period = 0.3 / tau;
/**
 * @ignore
 */
let s = Math.asin(1 / amplitude) * period;
function elastic(t) {
    let v = t;
    return amplitude * Math.pow(2, 10 * --v) * Math.sin((s - v) / period);
}
//# sourceMappingURL=Ease.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/core/util/Entity.js":
/*!************************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/core/util/Entity.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Adapters: () => (/* binding */ Adapters),
/* harmony export */   Animation: () => (/* binding */ Animation),
/* harmony export */   Entity: () => (/* binding */ Entity),
/* harmony export */   Settings: () => (/* binding */ Settings)
/* harmony export */ });
/* harmony import */ var _Disposer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Disposer */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Disposer.js");
/* harmony import */ var _EventDispatcher__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./EventDispatcher */ "./node_modules/@amcharts/amcharts5/.internal/core/util/EventDispatcher.js");
/* harmony import */ var _Animation__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Animation */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Animation.js");
/* harmony import */ var _States__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./States */ "./node_modules/@amcharts/amcharts5/.internal/core/util/States.js");
/* harmony import */ var _Registry__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../Registry */ "./node_modules/@amcharts/amcharts5/.internal/core/Registry.js");
/* harmony import */ var _Object__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Object */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Object.js");
/* harmony import */ var _Ease__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Ease */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Ease.js");
/* harmony import */ var _Array__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Array */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Array.js");
/* harmony import */ var _Order__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./Order */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Order.js");









/**
 * Allows to dynamically modify setting value of its target element.
 *
 * @see {@link https://www.amcharts.com/docs/v5/concepts/settings/adapters/} for more info
 */
class Adapters {
    constructor(entity) {
        Object.defineProperty(this, "_entity", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_callbacks", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {}
        });
        Object.defineProperty(this, "_disabled", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {}
        });
        this._entity = entity;
    }
    /**
     * Add a function (`callback`) that will modify value for setting `key`.
     *
     * @see {@link https://www.amcharts.com/docs/v5/concepts/settings/adapters/} for more info
     */
    add(key, callback) {
        let callbacks = this._callbacks[key];
        if (callbacks === undefined) {
            callbacks = this._callbacks[key] = [];
        }
        callbacks.push(callback);
        this._entity._markDirtyKey(key);
        return new _Disposer__WEBPACK_IMPORTED_MODULE_0__.Disposer(() => {
            if (_Array__WEBPACK_IMPORTED_MODULE_1__.removeFirst(callbacks, callback)) {
                this._entity._markDirtyKey(key);
            }
        });
    }
    /**
     * Removes all adapters for the specific key.
     *
     * @since 5.1.0
     */
    remove(key) {
        const callbacks = this._callbacks[key];
        if (callbacks !== undefined) {
            delete this._callbacks[key];
            if (callbacks.length !== 0) {
                this._entity._markDirtyKey(key);
            }
        }
    }
    /**
     * Enables (previously disabled) adapters for specific key.
     *
     * @since 5.1.0
     */
    enable(key) {
        if (this._disabled[key]) {
            delete this._disabled[key];
            this._entity._markDirtyKey(key);
        }
    }
    /**
     * Disables all adapters for specific key.
     *
     * @since 5.1.0
     */
    disable(key) {
        if (!this._disabled[key]) {
            this._disabled[key] = true;
            this._entity._markDirtyKey(key);
        }
    }
    /**
     * @ignore
     */
    fold(key, value) {
        if (!this._disabled[key]) {
            const callbacks = this._callbacks[key];
            if (callbacks !== undefined) {
                for (let i = 0, len = callbacks.length; i < len; ++i) {
                    value = callbacks[i](value, this._entity, key);
                }
            }
        }
        return value;
    }
}
/**
 * Animation object.
 *
 * @see {@link https://www.amcharts.com/docs/v5/concepts/animations/} for more info
 */
class Animation {
    constructor(animation, from, to, duration, easing, loops, startingTime) {
        Object.defineProperty(this, "_animation", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_from", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_to", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_duration", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_easing", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_loops", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_interpolate", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_oldTime", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_time", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        Object.defineProperty(this, "_stopped", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        Object.defineProperty(this, "_playing", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: true
        });
        Object.defineProperty(this, "events", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new _EventDispatcher__WEBPACK_IMPORTED_MODULE_2__.EventDispatcher()
        });
        this._animation = animation;
        this._from = from;
        this._to = to;
        this._duration = duration;
        this._easing = easing;
        this._loops = loops;
        this._interpolate = (0,_Animation__WEBPACK_IMPORTED_MODULE_3__.getInterpolate)(from, to);
        this._oldTime = startingTime;
    }
    get to() {
        return this._to;
    }
    get from() {
        return this._from;
    }
    get playing() {
        return this._playing;
    }
    get stopped() {
        return this._stopped;
    }
    stop() {
        if (!this._stopped) {
            this._stopped = true;
            this._playing = false;
            if (this.events.isEnabled("stopped")) {
                this.events.dispatch("stopped", {
                    type: "stopped",
                    target: this,
                });
            }
        }
    }
    pause() {
        this._playing = false;
        this._oldTime = null;
    }
    play() {
        if (!this._stopped && !this._playing) {
            this._playing = true;
            this._animation._startAnimation();
        }
    }
    get percentage() {
        return this._time / this._duration;
    }
    waitForStop() {
        return new Promise((resolve, _reject) => {
            if (this._stopped) {
                resolve();
            }
            else {
                const listener = () => {
                    stopped.dispose();
                    resolve();
                };
                const stopped = this.events.on("stopped", listener);
            }
        });
    }
    _checkEnded() {
        if (this._loops > 1) {
            --this._loops;
            return false;
        }
        else {
            return true;
        }
    }
    _run(currentTime) {
        if (this._oldTime !== null) {
            this._time += currentTime - this._oldTime;
            if (this._time > this._duration) {
                this._time = this._duration;
            }
        }
        this._oldTime = currentTime;
    }
    _reset(currentTime) {
        this._oldTime = currentTime;
        this._time = 0;
    }
    _value(diff) {
        return this._interpolate(this._easing(diff), this._from, this._to);
    }
}
/**
 * @ignore
 */
let counter = 0;
/**
 * Base class for [[Entity]] objects that support Settings.
 *
 * @see {@link https://www.amcharts.com/docs/v5/concepts/settings/} for more info
 */
class Settings {
    constructor(settings) {
        /**
         * Unique ID.
         */
        Object.defineProperty(this, "uid", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: ++counter
        });
        Object.defineProperty(this, "_settings", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_privateSettings", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {}
        });
        Object.defineProperty(this, "_settingEvents", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {}
        });
        Object.defineProperty(this, "_privateSettingEvents", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {}
        });
        Object.defineProperty(this, "_prevSettings", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {}
        });
        Object.defineProperty(this, "_prevPrivateSettings", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {}
        });
        Object.defineProperty(this, "_animatingSettings", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {}
        });
        Object.defineProperty(this, "_animatingPrivateSettings", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {}
        });
        Object.defineProperty(this, "_playingAnimations", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        Object.defineProperty(this, "_disposed", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        // TODO move this into Entity
        Object.defineProperty(this, "_userProperties", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {}
        });
        this._settings = settings;
    }
    _checkDirty() {
        _Object__WEBPACK_IMPORTED_MODULE_4__.keys(this._settings).forEach((key) => {
            this._userProperties[key] = true;
            this._markDirtyKey(key);
        });
    }
    /**
     * @ignore
     */
    resetUserSettings() {
        this._userProperties = {};
    }
    _runAnimation(currentTime) {
        if (!this.isDisposed()) {
            _Object__WEBPACK_IMPORTED_MODULE_4__.each(this._animatingSettings, (key, animation) => {
                if (animation._stopped) {
                    this._stopAnimation(key);
                }
                else if (animation._playing) {
                    animation._run(currentTime);
                    const diff = animation.percentage;
                    if (diff >= 1) {
                        if (animation._checkEnded()) {
                            this.set(key, animation._value(1));
                        }
                        else {
                            animation._reset(currentTime);
                            this._set(key, animation._value(1));
                        }
                    }
                    else {
                        this._set(key, animation._value(diff));
                    }
                }
            });
            _Object__WEBPACK_IMPORTED_MODULE_4__.each(this._animatingPrivateSettings, (key, animation) => {
                if (animation._stopped) {
                    this._stopAnimationPrivate(key);
                }
                else if (animation._playing) {
                    animation._run(currentTime);
                    const diff = animation.percentage;
                    if (diff >= 1) {
                        if (animation._checkEnded()) {
                            this.setPrivate(key, animation._value(1));
                        }
                        else {
                            animation._reset(currentTime);
                            this._setPrivate(key, animation._value(1));
                        }
                    }
                    else {
                        this._setPrivate(key, animation._value(diff));
                    }
                }
            });
            return this._playingAnimations !== 0;
        }
        else {
            return false;
        }
    }
    _markDirtyKey(_key) {
        this.markDirty();
    }
    _markDirtyPrivateKey(_key) {
        this.markDirty();
    }
    /**
     * Sets a callback function to invoke when specific key of settings changes
     * or is set.
     *
     * @see {@link https://www.amcharts.com/docs/v5/concepts/events/#Settings_value_change} for more info
     * @param   key       Settings key
     * @param   callback  Callback
     * @return            Disposer for event
     */
    on(key, callback) {
        let events = this._settingEvents[key];
        if (events === undefined) {
            events = this._settingEvents[key] = [];
        }
        events.push(callback);
        return new _Disposer__WEBPACK_IMPORTED_MODULE_0__.Disposer(() => {
            _Array__WEBPACK_IMPORTED_MODULE_1__.removeFirst(events, callback);
            if (events.length === 0) {
                delete this._settingEvents[key];
            }
        });
    }
    /**
     * Sets a callback function to invoke when specific key of private settings
     * changes or is set.
     *
     * @see {@link https://www.amcharts.com/docs/v5/concepts/events/#Settings_value_change} for more info
     * @ignore
     * @param   key       Private settings key
     * @param   callback  Callback
     * @return            Disposer for event
     */
    onPrivate(key, callback) {
        let events = this._privateSettingEvents[key];
        if (events === undefined) {
            events = this._privateSettingEvents[key] = [];
        }
        events.push(callback);
        return new _Disposer__WEBPACK_IMPORTED_MODULE_0__.Disposer(() => {
            _Array__WEBPACK_IMPORTED_MODULE_1__.removeFirst(events, callback);
            if (events.length === 0) {
                delete this._privateSettingEvents[key];
            }
        });
    }
    /**
     * @ignore
     */
    getRaw(key, fallback) {
        const value = this._settings[key];
        if (value !== undefined) {
            return value;
        }
        else {
            return fallback;
        }
    }
    get(key, fallback) {
        return this.getRaw(key, fallback);
    }
    _sendKeyEvent(key, value) {
        const events = this._settingEvents[key];
        if (events !== undefined) {
            _Array__WEBPACK_IMPORTED_MODULE_1__.each(events, (callback) => {
                callback(value, this, key);
            });
        }
    }
    _sendPrivateKeyEvent(key, value) {
        const events = this._privateSettingEvents[key];
        if (events !== undefined) {
            _Array__WEBPACK_IMPORTED_MODULE_1__.each(events, (callback) => {
                callback(value, this, key);
            });
        }
    }
    /**
     * @ignore
     */
    _setRaw(key, old, value) {
        this._prevSettings[key] = old;
        this._sendKeyEvent(key, value);
    }
    /**
     * @ignore
     */
    setRaw(key, value) {
        const old = this._settings[key];
        this._settings[key] = value;
        if (old !== value) {
            this._setRaw(key, old, value);
        }
    }
    /**
     * @ignore
     */
    _set(key, value) {
        const old = this._settings[key];
        this._settings[key] = value;
        if (old !== value) {
            this._setRaw(key, old, value);
            this._markDirtyKey(key);
        }
    }
    _stopAnimation(key) {
        const animation = this._animatingSettings[key];
        if (animation) {
            --this._playingAnimations;
            delete this._animatingSettings[key];
            animation.stop();
        }
    }
    /**
     * Sets a setting `value` for the specified `key`, and returns the same `value`.
     *
     * @see {@link https://www.amcharts.com/docs/v5/concepts/settings/} for more info
     * @param   key       Setting key
     * @param   value     Setting value
     * @return            Setting value
     */
    set(key, value) {
        this._set(key, value);
        this._stopAnimation(key);
        return value;
    }
    /**
     * Removes a setting value for the specified `key`;
     *
     * @see {@link https://www.amcharts.com/docs/v5/concepts/settings/} for more info
     * @param   key       Setting key
     */
    remove(key) {
        if (key in this._settings) {
            this._prevSettings[key] = this._settings[key];
            delete this._settings[key];
            this._sendKeyEvent(key, undefined);
            this._markDirtyKey(key);
        }
        this._stopAnimation(key);
    }
    /**
     * Removes all keys;
     *
     * @see {@link https://www.amcharts.com/docs/v5/concepts/settings/} for more info
     */
    removeAll() {
        _Array__WEBPACK_IMPORTED_MODULE_1__.each(_Object__WEBPACK_IMPORTED_MODULE_4__.keys(this._settings), (key) => {
            this.remove(key);
        });
    }
    /**
     * Returns a value of a private setting.
     *
     * @see {@link https://www.amcharts.com/docs/v5/concepts/settings/#Private_settings} for more info
     */
    getPrivate(key, fallback) {
        const value = this._privateSettings[key];
        if (value !== undefined) {
            return value;
        }
        else {
            return fallback;
        }
    }
    /**
     * @ignore
     */
    _setPrivateRaw(key, old, value) {
        this._prevPrivateSettings[key] = old;
        this._sendPrivateKeyEvent(key, value);
    }
    /**
     * @ignore
     */
    setPrivateRaw(key, value) {
        const old = this._privateSettings[key];
        this._privateSettings[key] = value;
        if (old !== value) {
            this._setPrivateRaw(key, old, value);
        }
    }
    /**
     * @ignore
     */
    _setPrivate(key, value) {
        const old = this._privateSettings[key];
        this._privateSettings[key] = value;
        if (old !== value) {
            this._setPrivateRaw(key, old, value);
            this._markDirtyPrivateKey(key);
        }
    }
    _stopAnimationPrivate(key) {
        const animation = this._animatingPrivateSettings[key];
        if (animation) {
            --this._playingAnimations;
            animation.stop();
            delete this._animatingPrivateSettings[key];
        }
    }
    /**
     * @ignore
     */
    setPrivate(key, value) {
        this._setPrivate(key, value);
        this._stopAnimationPrivate(key);
        return value;
    }
    /**
     * @ignore
     */
    removePrivate(key) {
        if (key in this._privateSettings) {
            this._prevPrivateSettings[key] = this._privateSettings[key];
            delete this._privateSettings[key];
            this._markDirtyPrivateKey(key);
        }
        this._stopAnimationPrivate(key);
    }
    /**
     * Sets multiple settings at once.
     *
     * `settings` must be an object with key: value pairs.
     *
     * @see {@link https://www.amcharts.com/docs/v5/concepts/settings/} for more info
     * @param settings Settings
     */
    setAll(settings) {
        _Object__WEBPACK_IMPORTED_MODULE_4__.each(settings, (key, value) => {
            this.set(key, value);
        });
    }
    /**
     * Animates setting values from current/start values to new ones.
     *
     * @see {@link https://www.amcharts.com/docs/v5/concepts/animations/#Animating_settings} for more info
     * @param   options  Animation options
     * @return           Animation object
     */
    animate(options) {
        const key = options.key;
        const to = options.to;
        const duration = options.duration || 0;
        const loops = options.loops || 1;
        const from = (options.from === undefined ? this.get(key) : options.from);
        const easing = (options.easing === undefined ? _Ease__WEBPACK_IMPORTED_MODULE_5__.linear : options.easing);
        if (duration === 0) {
            this.set(key, to);
        }
        else {
            if (from === undefined || from === to) {
                this.set(key, to);
            }
            else {
                this.set(key, from);
                const animation = this._animatingSettings[key] = new Animation(this, from, to, duration, easing, loops, this._animationTime());
                ++this._playingAnimations;
                this._startAnimation();
                return animation;
            }
        }
        const animation = new Animation(this, from, to, duration, easing, loops, null);
        animation.stop();
        return animation;
    }
    /**
     * @ignore
     */
    animatePrivate(options) {
        const key = options.key;
        const to = options.to;
        const duration = options.duration || 0;
        const loops = options.loops || 1;
        const from = (options.from === undefined ? this.getPrivate(key) : options.from);
        const easing = (options.easing === undefined ? _Ease__WEBPACK_IMPORTED_MODULE_5__.linear : options.easing);
        if (duration === 0) {
            this.setPrivate(key, to);
        }
        else {
            if (from === undefined || from === to) {
                this.setPrivate(key, to);
            }
            else {
                this.setPrivate(key, from);
                const animation = this._animatingPrivateSettings[key] = new Animation(this, from, to, duration, easing, loops, this._animationTime());
                ++this._playingAnimations;
                this._startAnimation();
                return animation;
            }
        }
        const animation = new Animation(this, from, to, duration, easing, loops, null);
        animation.stop();
        return animation;
    }
    _dispose() { }
    /**
     * Returns `true` if this element is disposed.
     *
     * @return Disposed
     */
    isDisposed() {
        return this._disposed;
    }
    /**
     * Disposes this object.
     */
    dispose() {
        if (!this._disposed) {
            this._disposed = true;
            this._dispose();
        }
    }
}
/**
 * Base class.
 *
 * @important
 */
class Entity extends Settings {
    /**
     * IMPORTANT! Do not instantiate this class via `new Class()` syntax.
     *
     * Use static method `Class.new()` instead.
     *
     * @see {@link https://www.amcharts.com/docs/v5/getting-started/#New_element_syntax} for more info
     * @ignore
     */
    constructor(root, settings, isReal, templates = []) {
        super(settings);
        Object.defineProperty(this, "_root", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_user_id", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        }); // for testing purposes
        Object.defineProperty(this, "states", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new _States__WEBPACK_IMPORTED_MODULE_6__.States(this)
        });
        Object.defineProperty(this, "adapters", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new Adapters(this)
        });
        Object.defineProperty(this, "events", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: this._createEvents()
        });
        Object.defineProperty(this, "_userPrivateProperties", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {}
        });
        Object.defineProperty(this, "_dirty", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {}
        });
        Object.defineProperty(this, "_dirtyPrivate", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {}
        });
        Object.defineProperty(this, "_template", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        // Templates for the themes
        Object.defineProperty(this, "_templates", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
        });
        // Internal templates which can be overridden by the user's templates
        Object.defineProperty(this, "_internalTemplates", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        // Default themes which can be overridden by the user's themes
        Object.defineProperty(this, "_defaultThemes", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
        });
        // Disposers for all of the templates
        Object.defineProperty(this, "_templateDisposers", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
        });
        Object.defineProperty(this, "_disposers", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
        });
        // Whether the template setup function should be run
        Object.defineProperty(this, "_runSetup", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: true
        });
        Object.defineProperty(this, "_disposerProperties", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {}
        });
        if (!isReal) {
            throw new Error("You cannot use `new Class()`, instead use `Class.new()`");
        }
        this._root = root;
        this._internalTemplates = templates;
        if (settings.id) {
            this._registerId(settings.id);
        }
    }
    /**
     * Use this method to create an instance of this class.
     *
     * @see {@link https://www.amcharts.com/docs/v5/getting-started/#New_element_syntax} for more info
     * @param   root      Root element
     * @param   settings  Settings
     * @param   template  Template
     * @return            Instantiated object
     */
    static new(root, settings, template) {
        const x = (new this(root, settings, true));
        x._template = template;
        x._afterNew();
        return x;
    }
    static _new(root, settings, templates = []) {
        const x = (new this(root, settings, true, templates));
        x._afterNew();
        return x;
    }
    _afterNew() {
        this._checkDirty();
        let shouldApply = false;
        const template = this._template;
        if (template) {
            shouldApply = true;
            template._setObjectTemplate(this);
        }
        _Array__WEBPACK_IMPORTED_MODULE_1__.each(this._internalTemplates, (template) => {
            shouldApply = true;
            template._setObjectTemplate(this);
        });
        if (shouldApply) {
            this._applyTemplates(false);
        }
        this.states.create("default", {});
        this._setDefaults();
    }
    // This is the same as _afterNew, except it also applies the themes.
    // This should only be used for classes which don't have a parent (because they extend from Entity and not Sprite).
    _afterNewApplyThemes() {
        this._checkDirty();
        const template = this._template;
        if (template) {
            template._setObjectTemplate(this);
        }
        _Array__WEBPACK_IMPORTED_MODULE_1__.each(this._internalTemplates, (template) => {
            template._setObjectTemplate(this);
        });
        this.states.create("default", {});
        this._setDefaults();
        this._applyThemes();
    }
    _createEvents() {
        return new _EventDispatcher__WEBPACK_IMPORTED_MODULE_2__.EventDispatcher();
    }
    /**
     * @ignore
     */
    get classNames() {
        return this.constructor.classNames;
    }
    /**
     * @ignore
     */
    get className() {
        return this.constructor.className;
    }
    _setDefaults() {
    }
    _setDefault(key, value) {
        if (!(key in this._settings)) {
            super.set(key, value);
        }
    }
    _setRawDefault(key, value) {
        if (!(key in this._settings)) {
            super.setRaw(key, value);
        }
    }
    _clearDirty() {
        _Object__WEBPACK_IMPORTED_MODULE_4__.keys(this._dirty).forEach((key) => {
            this._dirty[key] = false;
        });
        _Object__WEBPACK_IMPORTED_MODULE_4__.keys(this._dirtyPrivate).forEach((key) => {
            this._dirtyPrivate[key] = false;
        });
    }
    /**
     * @ignore
     */
    isDirty(key) {
        return !!this._dirty[key];
    }
    /**
     * @ignore
     */
    isPrivateDirty(key) {
        return !!this._dirtyPrivate[key];
    }
    _markDirtyKey(key) {
        this._dirty[key] = true;
        super._markDirtyKey(key);
    }
    _markDirtyPrivateKey(key) {
        this._dirtyPrivate[key] = true;
        super._markDirtyKey(key);
    }
    /**
     * Checks if element is of certain class (or inherits one).
     *
     * @param   type  Class name to check
     * @return {boolean} Is of class?
     */
    isType(type) {
        return this.classNames.indexOf(type) !== -1;
    }
    _pushPropertyDisposer(key, disposer) {
        let disposers = this._disposerProperties[key];
        if (disposers === undefined) {
            disposers = this._disposerProperties[key] = [];
        }
        disposers.push(disposer);
        return disposer;
    }
    _disposeProperty(key) {
        const disposers = this._disposerProperties[key];
        if (disposers !== undefined) {
            _Array__WEBPACK_IMPORTED_MODULE_1__.each(disposers, (disposer) => {
                disposer.dispose();
            });
            delete this._disposerProperties[key];
        }
    }
    /**
     * @todo needs description
     * @param  value  Template
     */
    set template(value) {
        const template = this._template;
        if (template !== value) {
            this._template = value;
            if (template) {
                template._removeObjectTemplate(this);
            }
            if (value) {
                value._setObjectTemplate(this);
            }
            this._applyTemplates();
        }
    }
    get template() {
        return this._template;
    }
    /**
     * @ignore
     */
    markDirty() {
        this._root._addDirtyEntity(this);
    }
    _startAnimation() {
        this._root._addAnimation(this);
    }
    _animationTime() {
        return this._root.animationTime;
    }
    _applyState(_name) { }
    _applyStateAnimated(_name, _duration) { }
    get(key, fallback) {
        const value = this.adapters.fold(key, this._settings[key]);
        if (value !== undefined) {
            return value;
        }
        else {
            return fallback;
        }
    }
    /**
     * @ignore
     */
    isUserSetting(key) {
        return this._userProperties[key] || false;
    }
    /**
     * Sets a setting `value` for the specified `key`, and returns the same `value`.
     *
     * @see {@link https://www.amcharts.com/docs/v5/concepts/settings/} for more info
     * @param   key       Setting key
     * @param   value     Setting value
     * @return            Setting value
     */
    set(key, value) {
        this._userProperties[key] = true;
        return super.set(key, value);
    }
    /**
     * @ignore
     */
    setRaw(key, value) {
        this._userProperties[key] = true;
        super.setRaw(key, value);
    }
    /**
     * Sets a setting `value` for the specified `key` only if the value for this key was not set previously using set method, and returns the same `value`.
     *
     * @see {@link https://www.amcharts.com/docs/v5/concepts/settings/} for more info
     * @param   key       Setting key
     * @param   value     Setting value
     * @return            Setting value
     */
    _setSoft(key, value) {
        if (!this._userProperties[key]) {
            return super.set(key, value);
        }
        return value;
    }
    /**
     * Removes a setting value for the specified `key`.
     *
     * @see {@link https://www.amcharts.com/docs/v5/concepts/settings/} for more info
     * @param   key       Setting key
     */
    remove(key) {
        delete this._userProperties[key];
        this._removeTemplateProperty(key);
    }
    /**
     * @ignore
     */
    setPrivate(key, value) {
        this._userPrivateProperties[key] = true;
        return super.setPrivate(key, value);
    }
    /**
     * @ignore
     */
    setPrivateRaw(key, value) {
        this._userPrivateProperties[key] = true;
        super.setPrivateRaw(key, value);
    }
    /**
     * @ignore
     */
    removePrivate(key) {
        delete this._userPrivateProperties[key];
        this._removeTemplatePrivateProperty(key);
    }
    _setTemplateProperty(template, key, value) {
        if (!this._userProperties[key]) {
            const match = this._findTemplateByKey(key);
            if (template === match) {
                super.set(key, value);
            }
        }
    }
    _setTemplatePrivateProperty(template, key, value) {
        if (!this._userPrivateProperties[key]) {
            const match = this._findTemplateByPrivateKey(key);
            if (template === match) {
                super.setPrivate(key, value);
            }
        }
    }
    _removeTemplateProperty(key) {
        if (!this._userProperties[key]) {
            const match = this._findTemplateByKey(key);
            if (match) {
                // TODO don't stop the animation if the property didn't change
                super.set(key, match._settings[key]);
            }
            else {
                super.remove(key);
            }
        }
    }
    _removeTemplatePrivateProperty(key) {
        if (!this._userPrivateProperties[key]) {
            const match = this._findTemplateByPrivateKey(key);
            if (match) {
                // TODO don't stop the animation if the property didn't change
                super.setPrivate(key, match._privateSettings[key]);
            }
            else {
                super.removePrivate(key);
            }
        }
    }
    _walkParents(f) {
        f(this._root._rootContainer);
        f(this);
    }
    // TODO faster version of this method which is specialized to just 1 key
    _applyStateByKey(name) {
        const other = this.states.create(name, {});
        const seen = {};
        this._eachTemplate((template) => {
            const state = template.states.lookup(name);
            if (state) {
                state._apply(other, seen);
            }
        });
        _Object__WEBPACK_IMPORTED_MODULE_4__.each(other._settings, (key) => {
            if (!seen[key] && !other._userSettings[key]) {
                other.remove(key);
            }
        });
    }
    _applyTemplate(template, state) {
        this._templateDisposers.push(template._apply(this, state));
        _Object__WEBPACK_IMPORTED_MODULE_4__.each(template._settings, (key, value) => {
            if (!state.settings[key] && !this._userProperties[key]) {
                state.settings[key] = true;
                super.set(key, value);
            }
        });
        _Object__WEBPACK_IMPORTED_MODULE_4__.each(template._privateSettings, (key, value) => {
            if (!state.privateSettings[key] && !this._userPrivateProperties[key]) {
                state.privateSettings[key] = true;
                super.setPrivate(key, value);
            }
        });
        if (this._runSetup && template.setup) {
            this._runSetup = false;
            template.setup(this);
        }
    }
    /**
     * Calls the closure with each template and returns the first template which is true
     */
    _findStaticTemplate(f) {
        if (this._template) {
            if (f(this._template)) {
                return this._template;
            }
        }
    }
    _eachTemplate(f) {
        this._findStaticTemplate((template) => {
            f(template);
            return false;
        });
        // _internalTemplates is sorted with most specific to the right
        _Array__WEBPACK_IMPORTED_MODULE_1__.eachReverse(this._internalTemplates, f);
        // _templates is sorted with most specific to the left
        _Array__WEBPACK_IMPORTED_MODULE_1__.each(this._templates, f);
    }
    _applyTemplates(remove = true) {
        if (remove) {
            this._disposeTemplates();
        }
        const state = {
            settings: {},
            privateSettings: {},
            states: {},
        };
        this._eachTemplate((template) => {
            this._applyTemplate(template, state);
        });
        if (remove) {
            _Object__WEBPACK_IMPORTED_MODULE_4__.each(this._settings, (key) => {
                if (!this._userProperties[key] && !state.settings[key]) {
                    super.remove(key);
                }
            });
            _Object__WEBPACK_IMPORTED_MODULE_4__.each(this._privateSettings, (key) => {
                if (!this._userPrivateProperties[key] && !state.privateSettings[key]) {
                    super.removePrivate(key);
                }
            });
        }
    }
    _findTemplate(f) {
        const value = this._findStaticTemplate(f);
        if (value === undefined) {
            // _internalTemplates is sorted with most specific to the right
            const value = _Array__WEBPACK_IMPORTED_MODULE_1__.findReverse(this._internalTemplates, f);
            if (value === undefined) {
                // _templates is sorted with most specific to the left
                return _Array__WEBPACK_IMPORTED_MODULE_1__.find(this._templates, f);
            }
            else {
                return value;
            }
        }
        else {
            return value;
        }
    }
    _findTemplateByKey(key) {
        return this._findTemplate((template) => {
            return key in template._settings;
        });
    }
    _findTemplateByPrivateKey(key) {
        return this._findTemplate((template) => {
            return key in template._privateSettings;
        });
    }
    _disposeTemplates() {
        _Array__WEBPACK_IMPORTED_MODULE_1__.each(this._templateDisposers, (disposer) => {
            disposer.dispose();
        });
        this._templateDisposers.length = 0;
    }
    _removeTemplates() {
        _Array__WEBPACK_IMPORTED_MODULE_1__.each(this._templates, (template) => {
            template._removeObjectTemplate(this);
        });
        this._templates.length = 0;
    }
    _applyThemes(force = false) {
        let isConnected = false;
        const defaults = [];
        let themes = [];
        const themeTags = new Set();
        const tags = this.get("themeTagsSelf");
        if (tags) {
            _Array__WEBPACK_IMPORTED_MODULE_1__.each(tags, (tag) => {
                themeTags.add(tag);
            });
        }
        this._walkParents((entity) => {
            if (entity === this._root._rootContainer) {
                isConnected = true;
            }
            if (entity._defaultThemes.length > 0) {
                defaults.push(entity._defaultThemes);
            }
            const theme = entity.get("themes");
            if (theme) {
                themes.push(theme);
            }
            const tags = entity.get("themeTags");
            if (tags) {
                _Array__WEBPACK_IMPORTED_MODULE_1__.each(tags, (tag) => {
                    themeTags.add(tag);
                });
            }
        });
        themes = defaults.concat(themes);
        this._removeTemplates();
        if (isConnected || force) {
            _Array__WEBPACK_IMPORTED_MODULE_1__.eachReverse(this.classNames, (name) => {
                const allRules = [];
                _Array__WEBPACK_IMPORTED_MODULE_1__.each(themes, (themes) => {
                    _Array__WEBPACK_IMPORTED_MODULE_1__.each(themes, (theme) => {
                        const rules = theme._lookupRules(name);
                        if (rules) {
                            _Array__WEBPACK_IMPORTED_MODULE_1__.eachReverse(rules, (rule) => {
                                const matches = rule.tags.every((tag) => {
                                    return themeTags.has(tag);
                                });
                                if (matches) {
                                    const result = _Array__WEBPACK_IMPORTED_MODULE_1__.getFirstSortedIndex(allRules, (x) => {
                                        const order = _Order__WEBPACK_IMPORTED_MODULE_7__.compare(rule.tags.length, x.tags.length);
                                        if (order === 0) {
                                            return _Order__WEBPACK_IMPORTED_MODULE_7__.compareArray(rule.tags, x.tags, _Order__WEBPACK_IMPORTED_MODULE_7__.compare);
                                        }
                                        else {
                                            return order;
                                        }
                                    });
                                    allRules.splice(result.index, 0, rule);
                                }
                            });
                        }
                    });
                });
                _Array__WEBPACK_IMPORTED_MODULE_1__.each(allRules, (rule) => {
                    this._templates.push(rule.template);
                    rule.template._setObjectTemplate(this);
                });
            });
        }
        this._applyTemplates();
        if (isConnected || force) {
            // This causes it to only run the setup function the first time that the themes are applied
            this._runSetup = false;
        }
        return isConnected || force;
    }
    _changed() { }
    _beforeChanged() {
        if (this.isDirty("id")) {
            const id = this.get("id");
            if (id) {
                this._registerId(id);
            }
            const prevId = this._prevSettings.id;
            if (prevId) {
                delete _Registry__WEBPACK_IMPORTED_MODULE_8__.registry.entitiesById[prevId];
            }
        }
    }
    _registerId(id) {
        if (_Registry__WEBPACK_IMPORTED_MODULE_8__.registry.entitiesById[id] && _Registry__WEBPACK_IMPORTED_MODULE_8__.registry.entitiesById[id] !== this) {
            throw new Error("An entity with id \"" + id + "\" already exists.");
        }
        _Registry__WEBPACK_IMPORTED_MODULE_8__.registry.entitiesById[id] = this;
    }
    _afterChanged() { }
    /**
     * @ignore
     */
    addDisposer(disposer) {
        this._disposers.push(disposer);
        return disposer;
    }
    _dispose() {
        super._dispose();
        const template = this._template;
        if (template) {
            template._removeObjectTemplate(this);
        }
        _Array__WEBPACK_IMPORTED_MODULE_1__.each(this._internalTemplates, (template) => {
            template._removeObjectTemplate(this);
        });
        this._removeTemplates();
        this._disposeTemplates();
        this.events.dispose();
        this._disposers.forEach((x) => {
            x.dispose();
        });
        _Object__WEBPACK_IMPORTED_MODULE_4__.each(this._disposerProperties, (_, disposers) => {
            _Array__WEBPACK_IMPORTED_MODULE_1__.each(disposers, (disposer) => {
                disposer.dispose();
            });
        });
        const id = this.get("id");
        if (id) {
            delete _Registry__WEBPACK_IMPORTED_MODULE_8__.registry.entitiesById[id];
        }
    }
    /**
     * Creates and returns a "disposable" timeout.
     *
     * @param   fn     Callback
     * @param   delay  Delay in milliseconds
     * @return         Timeout disposer
     */
    setTimeout(fn, delay) {
        const id = setTimeout(() => {
            this.removeDispose(disposer);
            fn();
        }, delay);
        const disposer = new _Disposer__WEBPACK_IMPORTED_MODULE_0__.Disposer(() => {
            clearTimeout(id);
        });
        this._disposers.push(disposer);
        return disposer;
    }
    /**
     * @ignore
     */
    removeDispose(target) {
        if (!this.isDisposed()) {
            let index = _Array__WEBPACK_IMPORTED_MODULE_1__.indexOf(this._disposers, target);
            if (index > -1) {
                this._disposers.splice(index, 1);
            }
        }
        target.dispose();
    }
    /**
     * @ignore
     */
    hasTag(tag) {
        return _Array__WEBPACK_IMPORTED_MODULE_1__.indexOf(this.get("themeTags", []), tag) !== -1;
    }
    /**
     * @ignore
     */
    addTag(tag) {
        if (!this.hasTag(tag)) {
            const tags = this.get("themeTags", []);
            tags.push(tag);
            this.set("themeTags", tags);
        }
    }
    /**
     * @ignore
     */
    removeTag(tag) {
        if (this.hasTag(tag)) {
            const tags = this.get("themeTags", []);
            _Array__WEBPACK_IMPORTED_MODULE_1__.remove(tags, tag);
            this.set("themeTags", tags);
        }
    }
    _t(text, locale, ...rest) {
        return this._root.language.translate(text, locale, ...rest);
    }
    /**
     * An instance of [[Root]] object.
     *
     * @readonly
     * @since 5.0.6
     * @return Root object
     */
    get root() {
        return this._root;
    }
}
Object.defineProperty(Entity, "className", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: "Entity"
});
Object.defineProperty(Entity, "classNames", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: ["Entity"]
});
//# sourceMappingURL=Entity.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/core/util/EventDispatcher.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/core/util/EventDispatcher.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   EventDispatcher: () => (/* binding */ EventDispatcher),
/* harmony export */   TargetedEventDispatcher: () => (/* binding */ TargetedEventDispatcher)
/* harmony export */ });
/* harmony import */ var _Disposer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Disposer */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Disposer.js");
/* harmony import */ var _Array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Array */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Array.js");
/* harmony import */ var _Type__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Type */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Type.js");
/**
 * Event Dispatcher module is used for registering listeners and dispatching
 * events across amCharts system.
 */
/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */



/**
 * Universal Event Dispatcher.
 *
 * @see {@link https://www.amcharts.com/docs/v5/concepts/events/} for more info
 */
class EventDispatcher {
    /**
     * Constructor
     */
    constructor() {
        Object.defineProperty(this, "_listeners", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_killed", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_disabled", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_iterating", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_enabled", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_disposed", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this._listeners = [];
        this._killed = [];
        this._disabled = {};
        this._iterating = 0;
        this._enabled = true;
        this._disposed = false;
    }
    /**
     * Returns if this object has been already disposed.
     *
     * @return Disposed?
     */
    isDisposed() {
        return this._disposed;
    }
    /**
     * Dispose (destroy) this object.
     */
    dispose() {
        if (!this._disposed) {
            this._disposed = true;
            const a = this._listeners;
            this._iterating = 1;
            this._listeners = null;
            this._disabled = null;
            try {
                _Array__WEBPACK_IMPORTED_MODULE_0__.each(a, (x) => {
                    x.disposer.dispose();
                });
            }
            finally {
                this._killed = null;
                this._iterating = null;
            }
        }
    }
    /**
     * Checks if this particular event dispatcher has any listeners set.
     *
     * @return Has listeners?
     */
    hasListeners() {
        return this._listeners.length !== 0;
    }
    /**
     * Checks if this particular event dispatcher has any particular listeners set.
     *
     * @return Has particular event listeners?
     */
    hasListenersByType(type) {
        return _Array__WEBPACK_IMPORTED_MODULE_0__.any(this._listeners, (x) => (x.type === null || x.type === type) && !x.killed);
    }
    /**
     * Enable dispatching of events if they were previously disabled by
     * `disable()`.
     */
    enable() {
        this._enabled = true;
    }
    /**
     * Disable dispatching of events until re-enabled by `enable()`.
     */
    disable() {
        this._enabled = false;
    }
    /**
     * Enable dispatching particular event, if it was disabled before by
     * `disableType()`.
     *
     * @param type Event type
     */
    enableType(type) {
        delete this._disabled[type];
    }
    /**
     * Disable dispatching of events for a certain event type.
     *
     * Optionally, can set how many dispatches to skip before automatically
     * re-enabling the dispatching.
     *
     * @param type    Event type
     * @param amount  Number of event dispatches to skip
     */
    disableType(type, amount = Infinity) {
        this._disabled[type] = amount;
    }
    /**
     * Removes listener from dispatcher.
     *
     * Will throw an exception if such listener does not exists.
     *
     * @param listener Listener to remove
     */
    _removeListener(listener) {
        if (this._iterating === 0) {
            const index = this._listeners.indexOf(listener);
            if (index === -1) {
                throw new Error("Invalid state: could not remove listener");
            }
            this._listeners.splice(index, 1);
        }
        else {
            this._killed.push(listener);
        }
    }
    /**
     * Removes existing listener by certain parameters.
     *
     * @param once         Listener's once setting
     * @param type         Listener's type
     * @param callback     Callback function
     * @param context      Callback context
     */
    _removeExistingListener(once, type, callback, context) {
        if (this._disposed) {
            throw new Error("EventDispatcher is disposed");
        }
        this._eachListener((info) => {
            if (info.once === once && // TODO is this correct ?
                info.type === type &&
                (callback === undefined || info.callback === callback) &&
                info.context === context) {
                info.disposer.dispose();
            }
        });
    }
    /**
     * Checks if dispatching for particular event type is enabled.
     *
     * @param type  Event type
     * @return Enabled?
     */
    isEnabled(type) {
        if (this._disposed) {
            throw new Error("EventDispatcher is disposed");
        }
        // TODO is this check correct ?
        return this._enabled && this._listeners.length > 0 && this.hasListenersByType(type) && this._disabled[type] === undefined;
    }
    /**
     * Removes all listeners of a particular event type
     *
     * @param type  Listener's type
     */
    removeType(type) {
        if (this._disposed) {
            throw new Error("EventDispatcher is disposed");
        }
        this._eachListener((info) => {
            if (info.type === type) {
                info.disposer.dispose();
            }
        });
    }
    /**
     * Checks if there's already a listener with specific parameters.
     *
     * @param type      Listener's type
     * @param callback  Callback function
     * @param context   Callback context
     * @return Has listener?
     */
    has(type, callback, context) {
        const index = _Array__WEBPACK_IMPORTED_MODULE_0__.findIndex(this._listeners, (info) => {
            return info.once !== true && // Ignoring "once" listeners
                info.type === type &&
                (callback === undefined || info.callback === callback) &&
                info.context === context;
        });
        return index !== -1;
    }
    /**
     * Checks whether event of the particular type should be dispatched.
     *
     * @param type  Event type
     * @return Dispatch?
     */
    _shouldDispatch(type) {
        if (this._disposed) {
            throw new Error("EventDispatcher is disposed");
        }
        const count = this._disabled[type];
        if (!_Type__WEBPACK_IMPORTED_MODULE_1__.isNumber(count)) {
            return this._enabled;
        }
        else {
            if (count <= 1) {
                delete this._disabled[type];
            }
            else {
                --this._disabled[type];
            }
            return false;
        }
    }
    /**
     * [_eachListener description]
     *
     * All of this extra code is needed when a listener is removed while iterating
     *
     * @todo Description
     * @param fn [description]
     */
    _eachListener(fn) {
        ++this._iterating;
        try {
            _Array__WEBPACK_IMPORTED_MODULE_0__.each(this._listeners, fn);
        }
        finally {
            --this._iterating;
            // TODO should this be inside or outside the finally ?
            if (this._iterating === 0 && this._killed.length !== 0) {
                // Remove killed listeners
                _Array__WEBPACK_IMPORTED_MODULE_0__.each(this._killed, (killed) => {
                    this._removeListener(killed);
                });
                this._killed.length = 0;
            }
        }
    }
    /**
     * Dispatches an event immediately without waiting for next cycle.
     *
     * @param type   Event type
     * @param event  Event object
     * @todo automatically add in type and target properties if they are missing
     */
    dispatch(type, event) {
        if (this._shouldDispatch(type)) {
            // TODO check if it's faster to use an object of listeners rather than a single big array
            // TODO if the function throws, maybe it should keep going ?
            this._eachListener((listener) => {
                if (!listener.killed && (listener.type === null || listener.type === type)) {
                    listener.dispatch(type, event);
                }
            });
        }
    }
    /**
     * Shelves the event to be dispatched within next update cycle.
     *
     * @param type   Event type
     * @param event  Event object
     * @todo automatically add in type and target properties if they are missing
     */
    /*public dispatchLater<Key extends keyof T>(type: Key, event: T[Key]): void {
        if (this._shouldDispatch(type)) {
            this._eachListener((listener) => {
                // TODO check if it's faster to use an object of listeners rather than a single big array
                if (!listener.killed && (listener.type === null || listener.type === type)) {
                    // TODO if the function throws, maybe it should keep going ?
                    // TODO dispatch during the update cycle, rather than using whenIdle
                    $async.whenIdle(() => {
                        if (!listener.killed) {
                            listener.dispatch(type, event);
                        }
                    });
                }
            });
        }
    }*/
    /**
     * Creates, catalogs and returns an [[EventListener]].
     *
     * Event listener can be disposed.
     *
     * @param once         Listener's once setting
     * @param type         Listener's type
     * @param callback     Callback function
     * @param context      Callback context
     * @param shouldClone  Whether the listener should be copied when the EventDispatcher is copied
     * @param dispatch
     * @returns An event listener
     */
    _on(once, type, callback, context, shouldClone, dispatch) {
        if (this._disposed) {
            throw new Error("EventDispatcher is disposed");
        }
        this._removeExistingListener(once, type, callback, context);
        const info = {
            type: type,
            callback: callback,
            context: context,
            shouldClone: shouldClone,
            dispatch: dispatch,
            killed: false,
            once: once,
            disposer: new _Disposer__WEBPACK_IMPORTED_MODULE_2__.Disposer(() => {
                info.killed = true;
                this._removeListener(info);
            })
        };
        this._listeners.push(info);
        return info;
    }
    /**
     * Creates an event listener to be invoked on **any** event.
     *
     * @param callback     Callback function
     * @param context      Callback context
     * @param shouldClone  Whether the listener should be copied when the EventDispatcher is copied
     * @returns A disposable event listener
     */
    onAll(callback, context, shouldClone = true) {
        return this._on(false, null, callback, context, shouldClone, (_type, event) => callback.call(context, event)).disposer;
    }
    /**
     * Creates an event listener to be invoked on a specific event type.
     *
     * ```TypeScript
     * button.events.once("click", (ev) => {
     *   console.log("Button clicked");
     * }, this);
     * ```
     * ```JavaScript
     * button.events.once("click", (ev) => {
     *   console.log("Button clicked");
     * }, this);
     * ```
     *
     * The above will invoke our custom event handler whenever series we put
     * event on is hidden.
     *
     * @param type         Listener's type
     * @param callback     Callback function
     * @param context      Callback context
     * @param shouldClone  Whether the listener should be copied when the EventDispatcher is copied
     * @returns A disposable event listener
     */
    on(type, callback, context, shouldClone = true) {
        return this._on(false, type, callback, context, shouldClone, (_type, event) => callback.call(context, event)).disposer;
    }
    /**
     * Creates an event listener to be invoked on a specific event type once.
     *
     * Once the event listener is invoked, it is automatically disposed.
     *
     * ```TypeScript
     * button.events.once("click", (ev) => {
     *   console.log("Button clicked");
     * }, this);
     * ```
     * ```JavaScript
     * button.events.once("click", (ev) => {
     *   console.log("Button clicked");
     * }, this);
     * ```
     *
     * The above will invoke our custom event handler the first time series we
     * put event on is hidden.
     *
     * @param type         Listener's type
     * @param callback     Callback function
     * @param context      Callback context
     * @param shouldClone  Whether the listener should be copied when the EventDispatcher is copied
     * @returns A disposable event listener
     */
    once(type, callback, context, shouldClone = true) {
        const x = this._on(true, type, callback, context, shouldClone, (_type, event) => {
            x.disposer.dispose();
            callback.call(context, event);
        });
        // TODO maybe this should return a different Disposer ?
        return x.disposer;
    }
    /**
     * Removes the event listener with specific parameters.
     *
     * @param type         Listener's type
     * @param callback     Callback function
     * @param context      Callback context
     */
    off(type, callback, context) {
        this._removeExistingListener(false, type, callback, context);
    }
    /**
     * Copies all dispatcher parameters, including listeners, from another event
     * dispatcher.
     *
     * @param source Source event dispatcher
     * @ignore
     */
    copyFrom(source) {
        if (this._disposed) {
            throw new Error("EventDispatcher is disposed");
        }
        if (source === this) {
            throw new Error("Cannot copyFrom the same TargetedEventDispatcher");
        }
        const disposers = [];
        _Array__WEBPACK_IMPORTED_MODULE_0__.each(source._listeners, (x) => {
            // TODO is this correct ?
            if (!x.killed && x.shouldClone) {
                if (x.type === null) {
                    disposers.push(this.onAll(x.callback, x.context));
                }
                else if (x.once) {
                    disposers.push(this.once(x.type, x.callback, x.context));
                }
                else {
                    disposers.push(this.on(x.type, x.callback, x.context));
                }
            }
        });
        return new _Disposer__WEBPACK_IMPORTED_MODULE_2__.MultiDisposer(disposers);
    }
}
/**
 * A version of the [[EventDispatcher]] that dispatches events for a specific
 * target object.
 *
 * @ignore
 */
class TargetedEventDispatcher extends EventDispatcher {
    /**
     * Constructor
     *
     * @param target Event dispatcher target
     */
    constructor(target) {
        super();
        /**
         * A target object which is originating events using this dispatcher.
         */
        Object.defineProperty(this, "target", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.target = target;
    }
    /**
     * Copies all dispatcher parameters, including listeners, from another event
     * dispatcher.
     *
     * @param source Source event dispatcher
     * @ignore
     */
    copyFrom(source) {
        if (this._disposed) {
            throw new Error("EventDispatcher is disposed");
        }
        if (source === this) {
            throw new Error("Cannot copyFrom the same TargetedEventDispatcher");
        }
        const disposers = [];
        _Array__WEBPACK_IMPORTED_MODULE_0__.each(source._listeners, (x) => {
            // TODO very hacky
            if (x.context === source.target) {
                return;
            }
            // TODO is this correct ?
            if (!x.killed && x.shouldClone) {
                if (x.type === null) {
                    disposers.push(this.onAll(x.callback, x.context));
                }
                else if (x.once) {
                    disposers.push(this.once(x.type, x.callback, x.context));
                }
                else {
                    disposers.push(this.on(x.type, x.callback, x.context));
                }
            }
        });
        return new _Disposer__WEBPACK_IMPORTED_MODULE_2__.MultiDisposer(disposers);
    }
}
//# sourceMappingURL=EventDispatcher.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/core/util/InterfaceColors.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/core/util/InterfaceColors.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   InterfaceColors: () => (/* binding */ InterfaceColors)
/* harmony export */ });
/* harmony import */ var _Entity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Entity */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Entity.js");

/**
 * Presets for common UI elements.
 */
class InterfaceColors extends _Entity__WEBPACK_IMPORTED_MODULE_0__.Entity {
}
Object.defineProperty(InterfaceColors, "className", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: "InterfaceColors"
});
Object.defineProperty(InterfaceColors, "classNames", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: _Entity__WEBPACK_IMPORTED_MODULE_0__.Entity.classNames.concat([InterfaceColors.className])
});
//# sourceMappingURL=InterfaceColors.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/core/util/Language.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/core/util/Language.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Language: () => (/* binding */ Language)
/* harmony export */ });
/* harmony import */ var _Entity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Entity */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Entity.js");
/* harmony import */ var _Array__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Array */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Array.js");
/* harmony import */ var _Object__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Object */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Object.js");
/* harmony import */ var _locales_en__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../locales/en */ "./node_modules/@amcharts/amcharts5/locales/en.js");




;
/**
 * Add localization functionality.
 */
class Language extends _Entity__WEBPACK_IMPORTED_MODULE_0__.Entity {
    _setDefaults() {
        this.setPrivate("defaultLocale", _locales_en__WEBPACK_IMPORTED_MODULE_1__["default"]);
        super._setDefaults();
    }
    /**
     * Returns a prompt translation.
     *
     * @param   prompt   Prompt to translate
     * @param   locale   Target locale
     * @param   ...rest  Parameters
     * @return           Translation
     */
    translate(prompt, locale, ...rest) {
        // Get langauge
        if (!locale) {
            locale = this._root.locale || this.getPrivate("defaultLocale");
        }
        // Init translation
        let translation = prompt;
        let value = locale[prompt];
        // Try to look for the translation
        if (value === null) {
            translation = "";
        }
        else if (value != null) {
            // It might be an empty string
            if (value) {
                translation = value;
            }
        }
        else if (locale !== this.getPrivate("defaultLocale")) {
            // Try to look in default language
            return this.translate(prompt, this.getPrivate("defaultLocale"), ...rest);
        }
        // Replace %1, %2, etc params
        if (rest.length) {
            for (let len = rest.length, i = 0; i < len; ++i) {
                translation = translation.split("%" + (i + 1)).join(rest[i]);
            }
        }
        // Return the translation
        return translation;
    }
    /**
     * Returns a prompt translation, including custom prompts.
     *
     * @param   prompt   Prompt to translate
     * @param   locale   Target locale
     * @param   ...rest  Parameters
     * @return           Translation
     */
    translateAny(prompt, locale, ...rest) {
        return this.translate(prompt, locale, ...rest);
    }
    /**
     * Add a custom prompt to locale.
     *
     * @see {@link https://www.amcharts.com/docs/v5/concepts/locales/creating-translations/#Extending_locale_with_custom_prompts}
     * @param  prompt       Source prompt
     * @param  translation  Tanslation
     * @param  locale       Target locale
     */
    setTranslationAny(prompt, translation, locale) {
        const localeTarget = locale || this._root.locale;
        localeTarget[prompt] = translation;
    }
    /**
     * Add a batch of custom prompts.
     *
     * @since 5.3.3
     * @see {@link https://www.amcharts.com/docs/v5/concepts/locales/creating-translations/#Extending_locale_with_custom_prompts}
     * @param  translations  Translations
     * @param  locale        Target locale
     */
    setTranslationsAny(translations, locale) {
        _Object__WEBPACK_IMPORTED_MODULE_2__.each(translations, (key, val) => {
            this.setTranslationAny(key, val, locale);
        });
    }
    translateEmpty(prompt, locale, ...rest) {
        let translation = this.translate(prompt, locale, ...rest);
        return translation == prompt ? "" : translation;
    }
    translateFunc(prompt, locale) {
        if (this._root.locale[prompt]) {
            return this._root.locale[prompt];
        }
        // Try to look in default language
        if (locale !== this.getPrivate("defaultLocale")) {
            return this.translateFunc(prompt, this.getPrivate("defaultLocale"));
        }
        // Fail - return empty function
        return () => {
            return "";
        };
    }
    /**
     * Translates a btach of prompts.
     *
     * @param  list    Array of prompts to translate
     * @param  locale  Target locale
     * @return         Array of translations
     */
    translateAll(list, locale) {
        // Translate all items in the list
        if (!this.isDefault()) {
            return _Array__WEBPACK_IMPORTED_MODULE_3__.map(list, (x) => this.translate(x, locale));
        }
        else {
            return list;
        }
    }
    /**
     * Returns `true` if the currently selected locale is a default locale.
     *
     * @return `true` if locale is default; `false` if it is not.
     */
    isDefault() {
        return this.getPrivate("defaultLocale") === this._root.locale;
    }
}
//# sourceMappingURL=Language.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/core/util/List.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/core/util/List.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   List: () => (/* binding */ List),
/* harmony export */   ListAutoDispose: () => (/* binding */ ListAutoDispose),
/* harmony export */   ListTemplate: () => (/* binding */ ListTemplate)
/* harmony export */ });
/* harmony import */ var _EventDispatcher__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./EventDispatcher */ "./node_modules/@amcharts/amcharts5/.internal/core/util/EventDispatcher.js");
/* harmony import */ var _Array__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Array */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Array.js");


/**
 * Checks if specific index fits into length.
 *
 * @param index  Index
 * @param len    Length
 * @ignore
 */
function checkBounds(index, len) {
    if (!(index >= 0 && index < len)) {
        throw new Error("Index out of bounds: " + index);
    }
}
/**
 * A List class is used to hold a number of indexed items of the same type.
 */
class List {
    /**
     * Constructor
     *
     * @param initial  Inital list of values to add to list
     */
    constructor(initial = []) {
        /**
         * List values.
         */
        Object.defineProperty(this, "_values", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "events", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new _EventDispatcher__WEBPACK_IMPORTED_MODULE_0__.EventDispatcher()
        });
        this._values = initial;
    }
    /**
     * An array of values in the list.
     *
     * Do not use this property to add values. Rather use dedicated methods, like
     * `push()`, `removeIndex()`, etc.
     *
     * @readonly
     * @return List values
     */
    get values() {
        return this._values;
    }
    /**
     * Checks if list contains specific item reference.
     *
     * @param item  Item to search for
     * @return `true` if found, `false` if not found
     */
    contains(value) {
        return this._values.indexOf(value) !== -1;
    }
    /**
     * Removes specific item from the list.
     *
     * @param item An item to remove
     */
    removeValue(value) {
        let i = 0;
        let length = this._values.length;
        while (i < length) {
            // TODO handle NaN
            if (this._values[i] === value) {
                this.removeIndex(i);
                --length;
            }
            else {
                ++i;
            }
        }
    }
    /**
     * Searches the list for specific item and returns its index.
     *
     * @param item  An item to search for
     * @return Index or -1 if not found
     */
    indexOf(value) {
        return _Array__WEBPACK_IMPORTED_MODULE_1__.indexOf(this._values, value);
    }
    /**
     * Number of items in list.
     *
     * @readonly
     * @return Number of items
     */
    get length() {
        return this._values.length;
    }
    /**
     * Checks if there's a value at specific index.
     *
     * @param index  Index
     * @return Value exists?
     */
    hasIndex(index) {
        return index >= 0 && index < this._values.length;
    }
    /**
     * Returns an item at specified index.
     *
     * @param index  Index
     * @return List item
     */
    getIndex(index) {
        return this._values[index];
    }
    _onPush(newValue) {
        if (this.events.isEnabled("push")) {
            this.events.dispatch("push", {
                type: "push",
                target: this,
                newValue
            });
        }
    }
    _onInsertIndex(index, newValue) {
        if (this.events.isEnabled("insertIndex")) {
            this.events.dispatch("insertIndex", {
                type: "insertIndex",
                target: this,
                index,
                newValue
            });
        }
    }
    _onSetIndex(index, oldValue, newValue) {
        if (this.events.isEnabled("setIndex")) {
            this.events.dispatch("setIndex", {
                type: "setIndex",
                target: this,
                index,
                oldValue,
                newValue
            });
        }
    }
    _onRemoveIndex(index, oldValue) {
        if (this.events.isEnabled("removeIndex")) {
            this.events.dispatch("removeIndex", {
                type: "removeIndex",
                target: this,
                index,
                oldValue
            });
        }
    }
    _onMoveIndex(oldIndex, newIndex, value) {
        if (this.events.isEnabled("moveIndex")) {
            this.events.dispatch("moveIndex", {
                type: "moveIndex",
                target: this,
                oldIndex,
                newIndex,
                value,
            });
        }
    }
    _onClear(oldValues) {
        if (this.events.isEnabled("clear")) {
            this.events.dispatch("clear", {
                type: "clear",
                target: this,
                oldValues
            });
        }
    }
    /**
     * Sets value at specific index.
     *
     * If there's already a value at the index, it is overwritten.
     *
     * @param index  Index
     * @param value  New value
     * @return New value
     */
    setIndex(index, value) {
        checkBounds(index, this._values.length);
        const oldValue = this._values[index];
        // Do nothing if the old value and the new value are the same
        if (oldValue !== value) {
            this._values[index] = value;
            this._onSetIndex(index, oldValue, value);
        }
        return oldValue;
    }
    /**
     * Adds an item to the list at a specific index, which pushes all the other
     * items further down the list.
     *
     * @param index Index
     * @param item  An item to add
     */
    insertIndex(index, value) {
        checkBounds(index, this._values.length + 1);
        _Array__WEBPACK_IMPORTED_MODULE_1__.insertIndex(this._values, index, value);
        this._onInsertIndex(index, value);
        return value;
    }
    /**
     * Swaps indexes of two items in the list.
     *
     * @param a  Item 1
     * @param b  Item 2
     */
    swap(a, b) {
        const len = this._values.length;
        checkBounds(a, len);
        checkBounds(b, len);
        if (a !== b) {
            const value_a = this._values[a];
            const value_b = this._values[b];
            this._values[a] = value_b;
            this._onSetIndex(a, value_a, value_b);
            this._values[b] = value_a;
            this._onSetIndex(b, value_b, value_a);
        }
    }
    /**
     * Removes a value at specific index.
     *
     * @param index  Index of value to remove
     * @return Removed value
     */
    removeIndex(index) {
        checkBounds(index, this._values.length);
        const oldValue = this._values[index];
        _Array__WEBPACK_IMPORTED_MODULE_1__.removeIndex(this._values, index);
        this._onRemoveIndex(index, oldValue);
        return oldValue;
    }
    /**
     * Moves an item to a specific index within the list.
     *
     * If the index is not specified it will move the item to the end of the
     * list.
     *
     * @param value  Item to move
     * @param index  Index to place item at
     */
    moveValue(value, toIndex) {
        // TODO don't do anything if the desired index is the same as the current index
        let index = this.indexOf(value);
        // TODO remove all old values rather than only the first ?
        if (index !== -1) {
            _Array__WEBPACK_IMPORTED_MODULE_1__.removeIndex(this._values, index);
            if (toIndex == null) {
                const toIndex = this._values.length;
                this._values.push(value);
                this._onMoveIndex(index, toIndex, value);
            }
            else {
                _Array__WEBPACK_IMPORTED_MODULE_1__.insertIndex(this._values, toIndex, value);
                this._onMoveIndex(index, toIndex, value);
            }
        }
        else if (toIndex == null) {
            this._values.push(value);
            this._onPush(value);
        }
        else {
            _Array__WEBPACK_IMPORTED_MODULE_1__.insertIndex(this._values, toIndex, value);
            this._onInsertIndex(toIndex, value);
        }
        return value;
    }
    /**
     * Adds an item to the end of the list.
     *
     * @param item  An item to add
     */
    push(value) {
        this._values.push(value);
        this._onPush(value);
        return value;
    }
    /**
     * Adds an item as a first item in the list.
     *
     * @param item  An item to add
     */
    unshift(value) {
        this.insertIndex(0, value);
        return value;
    }
    /**
     * Adds multiple items to the list.
     *
     * @param items  An Array of items to add
     */
    pushAll(values) {
        _Array__WEBPACK_IMPORTED_MODULE_1__.each(values, (value) => {
            this.push(value);
        });
    }
    /**
     * Copies and adds items from abother list.
     *
     * @param source  A list top copy items from
     */
    copyFrom(source) {
        this.pushAll(source._values);
    }
    /**
     * Returns the last item from the list, and removes it.
     *
     * @return Item
     */
    pop() {
        let index = this._values.length - 1;
        return index < 0 ? undefined : this.removeIndex(this._values.length - 1);
    }
    /**
     * Returns the first item from the list, and removes it.
     *
     * @return Item
     */
    shift() {
        return this._values.length ? this.removeIndex(0) : undefined;
    }
    /**
     * Sets multiple items to the list.
     *
     * All current items are removed.
     *
     * @param newArray  New items
     */
    setAll(newArray) {
        const old = this._values;
        this._values = [];
        this._onClear(old);
        _Array__WEBPACK_IMPORTED_MODULE_1__.each(newArray, (value) => {
            this._values.push(value);
            this._onPush(value);
        });
    }
    /**
     * Removes all items from the list.
     */
    clear() {
        this.setAll([]);
    }
    /**
     * Returns an ES6 iterator for the list.
     */
    *[Symbol.iterator]() {
        const length = this._values.length;
        for (let i = 0; i < length; ++i) {
            yield this._values[i];
        }
    }
    /**
     * Calls `f` for each element in the list.
     *
     * `f` should have at least one parameter defined which will get a current
     * item, with optional second argument - index.
     */
    each(f) {
        _Array__WEBPACK_IMPORTED_MODULE_1__.each(this._values, f);
    }
    /**
     * Calls `f` for each element in the list, from right to left.
     *
     * `f` should have at least one parameter defined which will get a current
     * item, with optional second argument - index.
     */
    eachReverse(f) {
        _Array__WEBPACK_IMPORTED_MODULE_1__.eachReverse(this._values, f);
    }
}
/**
 * A version of a [[List]] where the elements are disposed automatically when
 * removed from the list, unless `autoDispose` is set to `false`.
 */
class ListAutoDispose extends List {
    constructor() {
        super(...arguments);
        /**
         * Automatically disposes elements that are removed from the list.
         *
         * @default true
         */
        Object.defineProperty(this, "autoDispose", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: true
        });
        Object.defineProperty(this, "_disposed", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
    }
    _onSetIndex(index, oldValue, newValue) {
        if (this.autoDispose) {
            oldValue.dispose();
        }
        super._onSetIndex(index, oldValue, newValue);
    }
    _onRemoveIndex(index, oldValue) {
        if (this.autoDispose) {
            oldValue.dispose();
        }
        super._onRemoveIndex(index, oldValue);
    }
    _onClear(oldValues) {
        if (this.autoDispose) {
            _Array__WEBPACK_IMPORTED_MODULE_1__.each(oldValues, (x) => {
                x.dispose();
            });
        }
        super._onClear(oldValues);
    }
    isDisposed() {
        return this._disposed;
    }
    dispose() {
        if (!this._disposed) {
            this._disposed = true;
            if (this.autoDispose) {
                _Array__WEBPACK_IMPORTED_MODULE_1__.each(this._values, (x) => {
                    x.dispose();
                });
            }
        }
    }
}
/**
 * A version of a [[List]] that is able to create new elements as well as
 * apply additional settings to newly created items.
 *
 * @see {@link https://www.amcharts.com/docs/v5/concepts/settings/list-templates/} for more info
 */
class ListTemplate extends ListAutoDispose {
    constructor(template, make) {
        super();
        Object.defineProperty(this, "template", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "make", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.template = template;
        this.make = make;
    }
}
//# sourceMappingURL=List.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/core/util/Math.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/core/util/Math.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DEGREES: () => (/* binding */ DEGREES),
/* harmony export */   HALFPI: () => (/* binding */ HALFPI),
/* harmony export */   PI: () => (/* binding */ PI),
/* harmony export */   RADIANS: () => (/* binding */ RADIANS),
/* harmony export */   boundsOverlap: () => (/* binding */ boundsOverlap),
/* harmony export */   ceil: () => (/* binding */ ceil),
/* harmony export */   circlesOverlap: () => (/* binding */ circlesOverlap),
/* harmony export */   closest: () => (/* binding */ closest),
/* harmony export */   cos: () => (/* binding */ cos),
/* harmony export */   fitAngleToRange: () => (/* binding */ fitAngleToRange),
/* harmony export */   fitToRange: () => (/* binding */ fitToRange),
/* harmony export */   getAngle: () => (/* binding */ getAngle),
/* harmony export */   getArcBounds: () => (/* binding */ getArcBounds),
/* harmony export */   getArcPoint: () => (/* binding */ getArcPoint),
/* harmony export */   getCubicControlPointA: () => (/* binding */ getCubicControlPointA),
/* harmony export */   getCubicControlPointB: () => (/* binding */ getCubicControlPointB),
/* harmony export */   getPointOnLine: () => (/* binding */ getPointOnLine),
/* harmony export */   getPointOnQuadraticCurve: () => (/* binding */ getPointOnQuadraticCurve),
/* harmony export */   inBounds: () => (/* binding */ inBounds),
/* harmony export */   mergeBounds: () => (/* binding */ mergeBounds),
/* harmony export */   normalizeAngle: () => (/* binding */ normalizeAngle),
/* harmony export */   round: () => (/* binding */ round),
/* harmony export */   sin: () => (/* binding */ sin),
/* harmony export */   spiralPoints: () => (/* binding */ spiralPoints),
/* harmony export */   tan: () => (/* binding */ tan)
/* harmony export */ });
/* harmony import */ var _Type__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Type */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Type.js");

/**
 * ============================================================================
 * CONSTANTS
 * ============================================================================
 * @hidden
 */
const PI = Math.PI;
const HALFPI = PI / 2;
const RADIANS = PI / 180;
const DEGREES = 180 / PI;
/**
 * Rounds the numeric value to whole number or specific precision of set.
 *
 * @param value      Value
 * @param precision  Precision (number of decimal points)
 * @param floor  In case value ends with 0.5 and precision is 0, we might need to floor the value instead of ceiling it.
 * @return Rounded value
 */
function round(value, precision, floor) {
    if (!(0,_Type__WEBPACK_IMPORTED_MODULE_0__.isNumber)(precision) || precision <= 0) {
        let rounded = Math.round(value);
        if (floor) {
            if (rounded - value == 0.5) {
                rounded--;
            }
        }
        return rounded;
    }
    else {
        let d = Math.pow(10, precision);
        return Math.round(value * d) / d;
    }
}
/**
 * Ceils the numeric value to whole number or specific precision of set.
 *
 * @param value      Value
 * @param precision  Precision (number of decimal points)
 * @return Rounded value
 */
function ceil(value, precision) {
    if (!(0,_Type__WEBPACK_IMPORTED_MODULE_0__.isNumber)(precision) || precision <= 0) {
        return Math.ceil(value);
    }
    else {
        let d = Math.pow(10, precision);
        return Math.ceil(value * d) / d;
    }
}
/**
 * [getCubicControlPointA description]
 *
 * @ignore Exclude from docs
 * @todo Description
 * @param p0        [description]
 * @param p1        [description]
 * @param p2        [description]
 * @param p3        [description]
 * @param tensionX  [description]
 * @param tensionY  [description]
 * @return [description]
 */
function getCubicControlPointA(p0, p1, p2, tensionX, tensionY) {
    return { x: ((-p0.x + p1.x / tensionX + p2.x) * tensionX), y: ((-p0.y + p1.y / tensionY + p2.y) * tensionY) };
}
/**
 * [getCubicControlPointB description]
 *
 * @ignore Exclude from docs
 * @todo Description
 * @param p0        [description]
 * @param p1        [description]
 * @param p2        [description]
 * @param p3        [description]
 * @param tensionX  [description]
 * @param tensionY  [description]
 * @return [description]
 */
function getCubicControlPointB(p1, p2, p3, tensionX, tensionY) {
    return { x: ((p1.x + p2.x / tensionX - p3.x) * tensionX), y: ((p1.y + p2.y / tensionY - p3.y) * tensionY) };
}
function fitToRange(value, min, max) {
    return Math.min(Math.max(value, min), max);
}
/**
 * Returns sine of an angle specified in degrees.
 *
 * @param value  Value
 * @return Sine
 */
function sin(angle) {
    return Math.sin(RADIANS * angle);
}
/**
 * Returns tan of an angle specified in degrees.
 *
 * @param value  Value
 * @return Sine
 */
function tan(angle) {
    return Math.tan(RADIANS * angle);
}
/**
 * Returns cosine of an angle specified in degrees.
 *
 * @param value  Value
 * @return Cosine
 */
function cos(angle) {
    return Math.cos(RADIANS * angle);
}
// 0 to 360
function normalizeAngle(value) {
    value = value % 360;
    if (value < 0) {
        value += 360;
    }
    return value;
}
// TODO this doesn't work properly for skewing, and it's probably broken for rotation too
function getArcBounds(cx, cy, startAngle, endAngle, radius) {
    let minX = Number.MAX_VALUE;
    let minY = Number.MAX_VALUE;
    let maxX = -Number.MAX_VALUE;
    let maxY = -Number.MAX_VALUE;
    let bpoints = [];
    bpoints.push(getArcPoint(radius, startAngle));
    bpoints.push(getArcPoint(radius, endAngle));
    let fromAngle = Math.min(Math.floor(startAngle / 90) * 90, Math.floor(endAngle / 90) * 90);
    let toAngle = Math.max(Math.ceil(startAngle / 90) * 90, Math.ceil(endAngle / 90) * 90);
    for (let angle = fromAngle; angle <= toAngle; angle += 90) {
        if (angle >= startAngle && angle <= endAngle) {
            bpoints.push(getArcPoint(radius, angle));
        }
    }
    for (let i = 0; i < bpoints.length; i++) {
        let pt = bpoints[i];
        if (pt.x < minX) {
            minX = pt.x;
        }
        if (pt.y < minY) {
            minY = pt.y;
        }
        if (pt.x > maxX) {
            maxX = pt.x;
        }
        if (pt.y > maxY) {
            maxY = pt.y;
        }
    }
    return ({ left: cx + minX, top: cy + minY, right: cx + maxX, bottom: cy + maxY });
}
/**
 * Returns point on arc
 *
 * @param center point
 * @param radius
 * @param arc
 * @return {boolean}
 */
function getArcPoint(radius, arc) {
    return ({ x: radius * cos(arc), y: radius * sin(arc) });
}
function mergeBounds(bounds) {
    const len = bounds.length;
    if (len > 0) {
        let bound = bounds[0];
        let left = bound.left;
        let top = bound.top;
        let right = bound.right;
        let bottom = bound.bottom;
        if (len > 1) {
            for (let i = 1; i < len; i++) {
                bound = bounds[i];
                left = Math.min(bound.left, left);
                right = Math.max(bound.right, right);
                top = Math.min(bound.top, top);
                bottom = Math.max(bound.bottom, bottom);
            }
        }
        return { left, right, top, bottom };
    }
    return { left: 0, right: 0, top: 0, bottom: 0 };
}
function fitAngleToRange(value, startAngle, endAngle) {
    if (startAngle > endAngle) {
        let temp = startAngle;
        startAngle = endAngle;
        endAngle = temp;
    }
    value = normalizeAngle(value);
    let count = (startAngle - normalizeAngle(startAngle)) / 360;
    if (value < startAngle) {
        value += 360 * (count + 1);
    }
    let maxEnd = startAngle + (endAngle - startAngle) / 2 + 180;
    let maxStart = startAngle + (endAngle - startAngle) / 2 - 180;
    if (value > endAngle) {
        if (value - 360 > startAngle) {
            value -= 360;
        }
        else {
            if (value < maxEnd) {
                value = endAngle;
            }
            else {
                value = startAngle;
            }
        }
    }
    if (value < startAngle) {
        if (value > maxStart) {
            value = startAngle;
        }
        else {
            value = endAngle;
        }
    }
    return value;
}
function inBounds(point, bounds) {
    if (point.x >= bounds.left && point.y >= bounds.top && point.x <= bounds.right && point.y <= bounds.bottom) {
        return true;
    }
    return false;
}
function getAngle(point1, point2) {
    if (!point2) {
        point2 = { x: point1.x * 2, y: point1.y * 2 };
    }
    let diffX = point2.x - point1.x;
    let diffY = point2.y - point1.y;
    let angle = Math.atan2(diffY, diffX) * DEGREES;
    if (angle < 0) {
        angle += 360;
    }
    return normalizeAngle(angle);
}
/**
 * [getPointOnQuadraticCurve description]
 *
 * @ignore Exclude from docs
 * @todo Description
 * @param pointA        [description]
 * @param pointB        [description]
 * @param controlPoint  [description]
 * @param position      [description]
 * @return [description]
 */
function getPointOnQuadraticCurve(pointA, pointB, controlPoint, position) {
    let x = (1 - position) * (1 - position) * pointA.x + 2 * (1 - position) * position * controlPoint.x + position * position * pointB.x;
    let y = (1 - position) * (1 - position) * pointA.y + 2 * (1 - position) * position * controlPoint.y + position * position * pointB.y;
    return { x: x, y: y };
}
function getPointOnLine(pointA, pointB, position) {
    return { x: pointA.x + (pointB.x - pointA.x) * position, y: pointA.y + (pointB.y - pointA.y) * position };
}
/**
 * Returns the closest value from the array of values to the reference value.
 *
 * @param values  Array of values
 * @param value   Reference value
 * @return Closes value from the array
 */
function closest(values, referenceValue) {
    return values.reduce(function (prev, curr) {
        return (Math.abs(curr - referenceValue) < Math.abs(prev - referenceValue) ? curr : prev);
    });
}
/**
 * Returns true if bounds overlap
 * @param bounds1 IBounds
 * @param bounds2 IBounds
 * @returns boolean
 */
function boundsOverlap(bounds1, bounds2) {
    const horizontalOverlap = bounds1.left < bounds2.right && bounds1.right > bounds2.left;
    const verticalOverlap = bounds1.top < bounds2.bottom && bounds1.bottom > bounds2.top;
    return horizontalOverlap && verticalOverlap;
}
/**
 * Generates points of a spiral
 * @param cx
 * @param cy
 * @param radius
 * @param radiusY
 * @param innerRadius
 * @param step
 * @param radiusStep
 * @param startAngle
 * @param endAngle
 * @returns IPoint[]
 */
function spiralPoints(cx, cy, radius, radiusY, innerRadius, step, radiusStep, startAngle, endAngle) {
    let r = innerRadius + 0.01;
    let angle = startAngle * RADIANS;
    let points = [];
    while (r < radius + radiusStep) {
        let stepSize = step;
        if (stepSize / 2 > r) {
            stepSize = 2 * r;
        }
        angle += 2 * Math.asin(stepSize / 2 / r);
        if (angle * DEGREES > endAngle + ((radius - innerRadius) / radiusStep) * 360) {
            break;
        }
        let degrees = angle * DEGREES;
        let point = { x: cx + r * Math.cos(angle), y: cy + r * radiusY / radius * Math.sin(angle) };
        points.push(point);
        r = innerRadius + degrees / 360 * radiusStep;
    }
    points.shift();
    return points;
}
/**
 * Returns true if circles overlap
 * @param circle1
 * @param circle2
 * @returns boolean
 */
function circlesOverlap(circle1, circle2) {
    return Math.hypot(circle1.x - circle2.x, circle1.y - circle2.y) <= circle1.radius + circle2.radius;
}
//# sourceMappingURL=Math.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/core/util/Matrix.js":
/*!************************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/core/util/Matrix.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Matrix: () => (/* binding */ Matrix)
/* harmony export */ });
/**
 * Modified from Pixi:
 *
 * The MIT License
 *
 * Copyright (c) 2013-2017 Mathew Groves, Chad Engler
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/**
 * @ignore
 */
class Matrix {
    constructor(a = 1, b = 0, c = 0, d = 1, tx = 0, ty = 0) {
        Object.defineProperty(this, "a", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "b", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "c", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "d", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "tx", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "ty", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.a = a;
        this.b = b;
        this.c = c;
        this.d = d;
        this.tx = tx;
        this.ty = ty;
    }
    /**
     * Sets the matrix based on all the available properties
     */
    setTransform(x, y, pivotX, pivotY, rotation, scale = 1) {
        this.a = Math.cos(rotation) * scale;
        this.b = Math.sin(rotation) * scale;
        this.c = -Math.sin(rotation) * scale;
        this.d = Math.cos(rotation) * scale;
        this.tx = x - ((pivotX * this.a) + (pivotY * this.c));
        this.ty = y - ((pivotX * this.b) + (pivotY * this.d));
    }
    /**
     * Get a new position with the current transformation applied.
     * Can be used to go from a child's coordinate space to the world coordinate space. (e.g. rendering)
     */
    apply(origin) {
        return {
            x: (this.a * origin.x) + (this.c * origin.y) + this.tx,
            y: (this.b * origin.x) + (this.d * origin.y) + this.ty
        };
    }
    /**
     * Get a new position with the inverse of the current transformation applied.
     * Can be used to go from the world coordinate space to a child's coordinate space. (e.g. input)
     */
    applyInverse(origin) {
        const id = 1 / ((this.a * this.d) + (this.c * -this.b));
        return {
            x: (this.d * id * origin.x) + (-this.c * id * origin.y) + (((this.ty * this.c) - (this.tx * this.d)) * id),
            y: (this.a * id * origin.y) + (-this.b * id * origin.x) + (((-this.ty * this.a) + (this.tx * this.b)) * id)
        };
    }
    /**
     * Appends the given Matrix to this Matrix.
     */
    append(matrix) {
        const a1 = this.a;
        const b1 = this.b;
        const c1 = this.c;
        const d1 = this.d;
        this.a = (matrix.a * a1) + (matrix.b * c1);
        this.b = (matrix.a * b1) + (matrix.b * d1);
        this.c = (matrix.c * a1) + (matrix.d * c1);
        this.d = (matrix.c * b1) + (matrix.d * d1);
        this.tx = (matrix.tx * a1) + (matrix.ty * c1) + this.tx;
        this.ty = (matrix.tx * b1) + (matrix.ty * d1) + this.ty;
    }
    /**
     * Prepends the given Matrix to this Matrix.
     */
    prepend(matrix) {
        const tx1 = this.tx;
        if (matrix.a !== 1 || matrix.b !== 0 || matrix.c !== 0 || matrix.d !== 1) {
            const a1 = this.a;
            const c1 = this.c;
            this.a = (a1 * matrix.a) + (this.b * matrix.c);
            this.b = (a1 * matrix.b) + (this.b * matrix.d);
            this.c = (c1 * matrix.a) + (this.d * matrix.c);
            this.d = (c1 * matrix.b) + (this.d * matrix.d);
        }
        this.tx = (tx1 * matrix.a) + (this.ty * matrix.c) + matrix.tx;
        this.ty = (tx1 * matrix.b) + (this.ty * matrix.d) + matrix.ty;
    }
    /**
     * Copies the other matrix's properties into this matrix
     */
    copyFrom(matrix) {
        this.a = matrix.a;
        this.b = matrix.b;
        this.c = matrix.c;
        this.d = matrix.d;
        this.tx = matrix.tx;
        this.ty = matrix.ty;
    }
}
//# sourceMappingURL=Matrix.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/core/util/NumberFormatter.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/core/util/NumberFormatter.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   NumberFormatter: () => (/* binding */ NumberFormatter)
/* harmony export */ });
/* harmony import */ var _Entity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Entity */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Entity.js");
/* harmony import */ var _TextFormatter__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./TextFormatter */ "./node_modules/@amcharts/amcharts5/.internal/core/util/TextFormatter.js");
/* harmony import */ var _Object__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Object */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Object.js");
/* harmony import */ var _Utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Utils */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Utils.js");
/* harmony import */ var _Type__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Type */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Type.js");





/**
 * Number formatter
 *
 * @see {@link https://www.amcharts.com/docs/v5/concepts/formatters/formatting-numbers/} for more info
 * @important
 */
class NumberFormatter extends _Entity__WEBPACK_IMPORTED_MODULE_0__.Entity {
    _setDefaults() {
        // Defaults
        this._setDefault("negativeBase", 0);
        this._setDefault("numberFormat", "#,###.#####");
        this._setDefault("smallNumberThreshold", 1.00);
        const bns = "_big_number_suffix_";
        const sns = "_small_number_suffix_";
        const bs = "_byte_suffix_";
        this._setDefault("bigNumberPrefixes", [
            { "number": 1e+3, "suffix": this._t(bns + "3") },
            { "number": 1e+6, "suffix": this._t(bns + "6") },
            { "number": 1e+9, "suffix": this._t(bns + "9") },
            { "number": 1e+12, "suffix": this._t(bns + "12") },
            { "number": 1e+15, "suffix": this._t(bns + "15") },
            { "number": 1e+18, "suffix": this._t(bns + "18") },
            { "number": 1e+21, "suffix": this._t(bns + "21") },
            { "number": 1e+24, "suffix": this._t(bns + "24") }
        ]);
        this._setDefault("smallNumberPrefixes", [
            { "number": 1e-24, "suffix": this._t(sns + "24") },
            { "number": 1e-21, "suffix": this._t(sns + "21") },
            { "number": 1e-18, "suffix": this._t(sns + "18") },
            { "number": 1e-15, "suffix": this._t(sns + "15") },
            { "number": 1e-12, "suffix": this._t(sns + "12") },
            { "number": 1e-9, "suffix": this._t(sns + "9") },
            { "number": 1e-6, "suffix": this._t(sns + "6") },
            { "number": 1e-3, "suffix": this._t(sns + "3") }
        ]);
        this._setDefault("bytePrefixes", [
            { "number": 1, suffix: this._t(bs + "B") },
            { "number": 1024, suffix: this._t(bs + "KB") },
            { "number": 1048576, suffix: this._t(bs + "MB") },
            { "number": 1073741824, suffix: this._t(bs + "GB") },
            { "number": 1099511627776, suffix: this._t(bs + "TB") },
            { "number": 1125899906842624, suffix: this._t(bs + "PB") }
        ]);
        super._setDefaults();
    }
    _beforeChanged() {
        super._beforeChanged();
    }
    /**
     * Formats the number according to specific format.
     *
     * @param value   Value to format
     * @param format  Format to apply
     * @return Formatted number
     */
    format(value, format, precision) {
        // no format passed in or "Number"
        if (format == null || (_Type__WEBPACK_IMPORTED_MODULE_1__.isString(format) && format.toLowerCase() === "number")) {
            format = this.get("numberFormat", "");
        }
        // Init return value
        let formatted;
        // Cast to number just in case
        // TODO: maybe use better casting
        let source = Number(value);
        // Is it a built-in format or Intl.NumberFormatOptions
        if (_Type__WEBPACK_IMPORTED_MODULE_1__.isObject(format)) {
            try {
                if (this.get("intlLocales")) {
                    return new Intl.NumberFormat(this.get("intlLocales"), format).format(source);
                }
                else {
                    return new Intl.NumberFormat(undefined, format).format(source);
                }
            }
            catch (e) {
                return "Invalid";
            }
        }
        else {
            // Clean format
            format = _Utils__WEBPACK_IMPORTED_MODULE_2__.cleanFormat(format);
            // Get format info (it will also deal with parser caching)
            let info = this.parseFormat(format, this._root.language);
            // format and replace the number
            let details;
            if (source > this.get("negativeBase")) {
                details = info.positive;
            }
            else if (source < this.get("negativeBase")) {
                details = info.negative;
            }
            else {
                details = info.zero;
            }
            // Adjust precision
            if (precision != null && !details.mod) {
                details = _Object__WEBPACK_IMPORTED_MODULE_3__.copy(details);
                details.decimals.active = source == 0 ? 0 : precision;
            }
            // Format
            formatted = details.template.split(_Type__WEBPACK_IMPORTED_MODULE_1__.PLACEHOLDER).join(this.applyFormat(source, details));
        }
        if (this.get("forceLTR") === true) {
            formatted = "‎" + formatted;
        }
        return formatted;
    }
    /**
     * Parses supplied format into structured object which can be used to format
     * the number.
     *
     * @param format Format string, i.e. "#,###.00"
     * @param language Language
     * @ignore
     */
    parseFormat(format, language) {
        // Check cache
        // TODO
        // let cached = this.getCache(format);
        // if (cached != null) {
        // 	return cached;
        // }
        const thousandSeparator = language.translateEmpty("_thousandSeparator");
        const decimalSeparator = language.translateEmpty("_decimalSeparator");
        // init format parse info holder
        let info = {
            "positive": {
                "thousands": {
                    "active": -1,
                    "passive": -1,
                    "interval": -1,
                    "separator": thousandSeparator
                },
                "decimals": {
                    "active": -1,
                    "passive": -1,
                    "separator": decimalSeparator
                },
                "template": "",
                "source": "",
                "parsed": false
            },
            "negative": {
                "thousands": {
                    "active": -1,
                    "passive": -1,
                    "interval": -1,
                    "separator": thousandSeparator
                },
                "decimals": {
                    "active": -1,
                    "passive": -1,
                    "separator": decimalSeparator
                },
                "template": "",
                "source": "",
                "parsed": false
            },
            "zero": {
                "thousands": {
                    "active": -1,
                    "passive": -1,
                    "interval": -1,
                    "separator": thousandSeparator
                },
                "decimals": {
                    "active": -1,
                    "passive": -1,
                    "separator": decimalSeparator
                },
                "template": "",
                "source": "",
                "parsed": false
            }
        };
        // Escape double vertical bars (that mean display one vertical bar)
        format = format.replace("||", _Type__WEBPACK_IMPORTED_MODULE_1__.PLACEHOLDER2);
        // Split it up and deal with different formats
        let parts = format.split("|");
        info.positive.source = parts[0];
        if (typeof parts[2] === "undefined") {
            info.zero = info.positive;
        }
        else {
            info.zero.source = parts[2];
        }
        if (typeof parts[1] === "undefined") {
            info.negative = info.positive;
        }
        else {
            info.negative.source = parts[1];
        }
        // Parse each
        _Object__WEBPACK_IMPORTED_MODULE_3__.each(info, (_part, item) => {
            // Already parsed
            if (item.parsed) {
                return;
            }
            // Check cached
            // TODO
            // if (typeof this.getCache(item.source) !== "undefined") {
            // 	info[part] = this.getCache(item.source);
            // 	return;
            // }
            // Begin parsing
            let partFormat = item.source;
            // Just "Number"?
            if (partFormat.toLowerCase() === "number") {
                partFormat = this.get("numberFormat", "#,###.#####");
            }
            // Let TextFormatter split into chunks
            let chunks = _TextFormatter__WEBPACK_IMPORTED_MODULE_4__.TextFormatter.chunk(partFormat, true);
            for (let i = 0; i < chunks.length; i++) {
                let chunk = chunks[i];
                // replace back double vertical bar
                chunk.text = chunk.text.replace(_Type__WEBPACK_IMPORTED_MODULE_1__.PLACEHOLDER2, "|");
                if (chunk.type === "value") {
                    // Parse format
                    // Look for codes
                    let matches = chunk.text.match(/[#0.,]+[ ]?[abespABESP%!]?[abespABESP‰!]?/);
                    if (matches) {
                        if (matches === null || matches[0] === "") {
                            // no codes here - assume string
                            // nothing to do here
                            item.template += chunk.text;
                        }
                        else {
                            // look for the format modifiers at the end
                            let mods = matches[0].match(/[abespABESP%‰!]{2}|[abespABESP%‰]{1}$/);
                            if (mods) {
                                item.mod = mods[0].toLowerCase();
                                item.modSpacing = matches[0].match(/[ ]{1}[abespABESP%‰!]{1}$/) ? true : false;
                            }
                            // break the format up
                            let a = matches[0].split(".");
                            // Deal with thousands
                            if (a[0] === "") {
                                // No directives for thousands
                                // Leave default settings (no formatting)
                            }
                            else {
                                // Counts
                                item.thousands.active = (a[0].match(/0/g) || []).length;
                                item.thousands.passive = (a[0].match(/\#/g) || []).length + item.thousands.active;
                                // Separator interval
                                let b = a[0].split(",");
                                if (b.length === 1) {
                                    // No thousands separators
                                    // Do nothing
                                }
                                else {
                                    // Use length fo the last chunk as thousands length
                                    item.thousands.interval = (b.pop() || "").length;
                                    if (item.thousands.interval === 0) {
                                        item.thousands.interval = -1;
                                    }
                                }
                            }
                            // Deal with decimals
                            if (typeof (a[1]) === "undefined") {
                                // No directives for decimals
                                // Leave at defaults (no formatting)
                            }
                            else {
                                // Counts
                                item.decimals.active = (a[1].match(/0/g) || []).length;
                                item.decimals.passive = (a[1].match(/\#/g) || []).length + item.decimals.active;
                            }
                            // Add special code to template
                            item.template += chunk.text.split(matches[0]).join(_Type__WEBPACK_IMPORTED_MODULE_1__.PLACEHOLDER);
                        }
                    }
                }
                else {
                    // Quoted string - take it as it is
                    item.template += chunk.text;
                }
            }
            // Apply style formatting
            //item.template = getTextFormatter().format(item.template, this.outputFormat);
            // Save cache
            // TODO
            //this.setCache(item.source, item);
            // Mark this as parsed
            item.parsed = true;
        });
        // Save cache (the whole thing)
        // TODO
        //this.setCache(format, info);
        return info;
    }
    /**
     * Applies parsed format to a numeric value.
     *
     * @param value    Value
     * @param details  Parsed format as returned by parseFormat()
     * @return Formatted number
     * @ignore
     */
    applyFormat(value, details) {
        // Use absolute values
        let negative = value < 0;
        value = Math.abs(value);
        // Recalculate according to modifier
        let prefix = "", suffix = "";
        let mods = details.mod ? details.mod.split("") : [];
        if (mods.indexOf("b") !== -1) {
            let a = this.applyPrefix(value, this.get("bytePrefixes"), mods.indexOf("!") !== -1);
            value = a[0];
            prefix = a[1];
            suffix = a[2];
            if (details.modSpacing) {
                suffix = " " + suffix;
            }
        }
        else if (mods.indexOf("a") !== -1) {
            let a = this.applyPrefix(value, value < this.get("smallNumberThreshold") ? this.get("smallNumberPrefixes") : this.get("bigNumberPrefixes"), mods.indexOf("!") !== -1);
            value = a[0];
            prefix = a[1];
            suffix = a[2];
            if (details.modSpacing) {
                suffix = " " + suffix;
            }
        }
        else if (mods.indexOf("p") !== -1) {
            let ol = Math.min(value.toString().length + 2, 21);
            //value *= 100;
            value = parseFloat(value.toPrecision(ol));
            prefix = this._root.language.translate("_percentPrefix");
            suffix = this._root.language.translate("_percentSuffix");
            if (prefix == "" && suffix == "") {
                suffix = "%";
            }
        }
        else if (mods.indexOf("%") !== -1) {
            let ol = Math.min(value.toString().length + 2, 21);
            value *= 100;
            value = parseFloat(value.toPrecision(ol));
            suffix = "%";
        }
        else if (mods.indexOf("‰") !== -1) {
            let ol = Math.min(value.toString().length + 3, 21);
            value *= 1000;
            value = parseFloat(value.toPrecision(ol));
            suffix = "‰";
        }
        // Round to passive
        if (mods.indexOf("e") !== -1) {
            // convert the value to exponential
            let exp;
            if (details.decimals.passive >= 0) {
                exp = value.toExponential(details.decimals.passive).split("e");
            }
            else {
                exp = value.toExponential().split("e");
            }
            value = Number(exp[0]);
            suffix = "e" + exp[1];
            if (details.modSpacing) {
                suffix = " " + suffix;
            }
        }
        else if (details.decimals.passive === 0) {
            value = Math.round(value);
        }
        else if (details.decimals.passive > 0) {
            let d = Math.pow(10, details.decimals.passive);
            value = Math.round(value * d) / d;
        }
        // Init return value
        let res = "";
        // Calc integer and decimal parts
        let a = _Type__WEBPACK_IMPORTED_MODULE_1__.numberToString(value).split(".");
        // Format integers
        let ints = a[0];
        // Pad integers to active length
        if (ints.length < details.thousands.active) {
            ints = Array(details.thousands.active - ints.length + 1).join("0") + ints;
        }
        // Insert thousands separators
        if (details.thousands.interval > 0) {
            let ip = [];
            let intsr = ints.split("").reverse().join("");
            for (let i = 0, len = ints.length; i <= len; i += details.thousands.interval) {
                let c = intsr.substr(i, details.thousands.interval).split("").reverse().join("");
                if (c !== "") {
                    ip.unshift(c);
                }
            }
            ints = ip.join(details.thousands.separator);
        }
        // Add integers
        res += ints;
        // Add decimals
        if (a.length === 1) {
            a.push("");
        }
        let decs = a[1];
        // Fill zeros?
        if (decs.length < details.decimals.active) {
            decs += Array(details.decimals.active - decs.length + 1).join("0");
        }
        if (decs !== "") {
            res += details.decimals.separator + decs;
        }
        // Can't have empty return value
        if (res === "") {
            res = "0";
        }
        // Add minus sign back
        if (value !== 0 && negative && (mods.indexOf("s") === -1)) {
            res = "-" + res;
        }
        // Add suffixes/prefixes
        if (prefix) {
            res = prefix + res;
        }
        if (suffix) {
            res += suffix;
        }
        return res;
    }
    applyPrefix(value, prefixes, force = false) {
        let newvalue = value;
        let prefix = "";
        let suffix = "";
        let applied = false;
        let k = 1;
        for (let i = 0, len = prefixes.length; i < len; i++) {
            if (prefixes[i].number <= value) {
                if (prefixes[i].number === 0) {
                    newvalue = 0;
                }
                else {
                    newvalue = value / prefixes[i].number;
                    k = prefixes[i].number;
                }
                prefix = prefixes[i].prefix;
                suffix = prefixes[i].suffix;
                applied = true;
            }
        }
        if (!applied && force && prefixes.length && value != 0) {
            // Prefix was not applied. Use the first prefix.
            newvalue = value / prefixes[0].number;
            prefix = prefixes[0].prefix;
            suffix = prefixes[0].suffix;
            applied = true;
        }
        if (applied) {
            newvalue = parseFloat(newvalue.toPrecision(Math.min(k.toString().length + Math.floor(newvalue).toString().replace(/[^0-9]*/g, "").length, 21)));
        }
        return [newvalue, prefix, suffix];
    }
    /**
     * Replaces brackets with temporary placeholders.
     *
     * @ignore Exclude from docs
     * @param text  Input text
     * @return Escaped text
     */
    escape(text) {
        return text.replace("||", _Type__WEBPACK_IMPORTED_MODULE_1__.PLACEHOLDER2);
    }
    /**
     * Replaces placeholders back to brackets.
     *
     * @ignore Exclude from docs
     * @param text  Escaped text
     * @return Unescaped text
     */
    unescape(text) {
        return text.replace(_Type__WEBPACK_IMPORTED_MODULE_1__.PLACEHOLDER2, "|");
    }
}
//# sourceMappingURL=NumberFormatter.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/core/util/Object.js":
/*!************************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/core/util/Object.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   copy: () => (/* binding */ copy),
/* harmony export */   each: () => (/* binding */ each),
/* harmony export */   eachContinue: () => (/* binding */ eachContinue),
/* harmony export */   eachOrdered: () => (/* binding */ eachOrdered),
/* harmony export */   hasKey: () => (/* binding */ hasKey),
/* harmony export */   keys: () => (/* binding */ keys),
/* harmony export */   keysOrdered: () => (/* binding */ keysOrdered),
/* harmony export */   softCopyProperties: () => (/* binding */ softCopyProperties)
/* harmony export */ });
/* harmony import */ var _Array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Array */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Array.js");

function keys(object) {
    return Object.keys(object);
}
/**
 * Returns an array of object's property names ordered using specific ordering
 * function.
 *
 * @param object  Source object
 * @param order   Ordering function
 * @returns Object property names
 */
function keysOrdered(object, order) {
    return keys(object).sort(order);
}
function copy(object) {
    return Object.assign({}, object);
}
function each(object, f) {
    keys(object).forEach((key) => {
        f(key, object[key]);
    });
}
/**
 * Iterates through all properties of the object calling `fn` for each of them.
 *
 * If return value of the function evaluates to `false` further iteration is
 * cancelled.
 *
 * @param object  Source object
 * @param fn      Callback function
 */
function eachContinue(object, fn) {
    for (let key in object) {
        if (hasKey(object, key)) {
            if (!fn(key, object[key])) {
                break;
            }
        }
    }
}
/**
 * Orders object properties using custom `ord` function and iterates through
 * them calling `fn` for each of them.
 *
 * @param object  Source object
 * @param fn      Callback function
 * @param order   Ordering function
 */
function eachOrdered(object, fn, ord) {
    _Array__WEBPACK_IMPORTED_MODULE_0__.each(keysOrdered(object, ord), (key) => {
        fn(key, object[key]);
    });
}
/**
 * Checks if `object` has a specific `key`.
 *
 * @param object  Source object
 * @param key     Property name
 * @returns Has key?
 */
function hasKey(object, key) {
    return {}.hasOwnProperty.call(object, key);
}
/**
 * Copies all properties of one object to the other, omitting undefined, but only if property in target object doesn't have a value set.
 *
 * @param fromObject  Source object
 * @param toObject    Target object
 * @return Updated target object
 * @todo Maybe consolidate with utils.copy?
 */
function softCopyProperties(source, target) {
    each(source, (key, value) => {
        // only if value is set
        //if ($type.hasValue(value) && !($type.hasValue((<any>target)[key]))) {
        if (value != null && target[key] == null) {
            target[key] = value;
        }
    });
    return target;
}
//# sourceMappingURL=Object.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/core/util/Order.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/core/util/Order.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   compare: () => (/* binding */ compare),
/* harmony export */   compareArray: () => (/* binding */ compareArray),
/* harmony export */   compareNumber: () => (/* binding */ compareNumber),
/* harmony export */   reverse: () => (/* binding */ reverse)
/* harmony export */ });
/**
 * @ignore
 */
function compare(left, right) {
    if (left === right) {
        return 0;
    }
    else if (left < right) {
        return -1;
    }
    else {
        return 1;
    }
}
/**
 * @ignore
 */
function compareArray(left, right, f) {
    const leftLength = left.length;
    const rightLength = right.length;
    const length = Math.min(leftLength, rightLength);
    for (let i = 0; i < length; ++i) {
        const order = f(left[i], right[i]);
        if (order !== 0) {
            return order;
        }
    }
    return compare(leftLength, rightLength);
}
/**
 * @ignore
 */
function reverse(order) {
    if (order < 0) {
        return 1;
    }
    else if (order > 0) {
        return -1;
    }
    else {
        return 0;
    }
}
/**
 * @ignore
 */
function compareNumber(a, b) {
    if (a === b) {
        return 0;
    }
    else if (a < b) {
        return -1;
    }
    else {
        return 1;
    }
}
//# sourceMappingURL=Order.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/core/util/Percent.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/core/util/Percent.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Percent: () => (/* binding */ Percent),
/* harmony export */   isPercent: () => (/* binding */ isPercent),
/* harmony export */   p0: () => (/* binding */ p0),
/* harmony export */   p100: () => (/* binding */ p100),
/* harmony export */   p50: () => (/* binding */ p50),
/* harmony export */   percent: () => (/* binding */ percent)
/* harmony export */ });
/**
 * ============================================================================
 * MAIN CLASS
 * ============================================================================
 * @hidden
 */
/**
 * Represents a relative value (percent).
 *
 * The Percent object, can be instantiated using two ways:
 *
 * * Via `new Percent(X)`.
 * * Via `am5.percent(X)`.
 *
 * You can also use shortcut functions for `0%`, `50%`, and `100%`:
 * * `am5.p0`
 * * `am5.p50`
 * * `am5.p100`
 */
class Percent {
    /**
     * Constructor.
     *
     * @param percent  Percent value
     */
    constructor(percent) {
        /**
         * Value in percent.
         */
        Object.defineProperty(this, "_value", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this._value = percent;
    }
    /**
     * Relative value.
     *
     * E.g. 100% is 1, 50% is 0.5, etc.
     *
     * This is useful to apply transformations to other values. E.g.:
     *
     * ```TypeScript
     * let value = 256;
     * let percent = new am5.p50;
     * console.log(value * percent.value); // outputs 128
     * ```
     * ```JavaScript
     * var value = 256;
     * var percent = new am5.p50;
     * console.log(value * percent.value); // outputs 128
     * ```
     *
     * Alternatively, you can use `am5.percent()` helper function:
     *
     * ```TypeScript
     * let value = 256;
     * let percent = am5.p50;
     * console.log(value * percent.value); // outputs 128
     * ```
     * ```JavaScript
     * var value = 256;
     * var percent = am5.p50;
     * console.log(value * percent.value); // outputs 128
     * ```
     *
     * @readonly
     * @return Relative value
     */
    get value() {
        return this._value / 100;
    }
    /**
     * Value in percent.
     *
     * @readonly
     * @return Percent
     */
    get percent() {
        return this._value;
    }
    toString() {
        return "" + this._value + "%";
    }
    interpolate(min, max) {
        return min + (this.value * (max - min));
    }
    static normalize(percent, min, max) {
        if (percent instanceof Percent) {
            return percent;
        }
        else {
            if (min === max) {
                return new Percent(0);
            }
            else {
                return new Percent(Math.min(Math.max((percent - min) * (1 / (max - min)), 0), 1) * 100);
            }
        }
    }
}
/**
 * Converts numeric percent value to a proper [[Percent]] object.
 *
 * ```TypeScript
 * pieSeries.set("radius", am5.percent(80));
 * ```
 * ```JavaScript
 * pieSeries.set("radius", am5.percent(80));
 * ```
 *
 * @param value  Percent
 * @return Percent object
 */
function percent(value) {
    return new Percent(value);
}
/**
 * A shortcut function to `am5.percent(0)`.
 */
const p0 = percent(0);
/**
 * A shortcut function to `am5.percent(100)`.
 */
const p100 = percent(100);
/**
 * A shortcut function to `am5.percent(50)`.
 */
const p50 = percent(50);
/**
 * Checks if value is a [[Percent]] object.
 *
 * @ignore Exclude from docs
 * @param value  Input value
 * @return Is percent?
 */
function isPercent(value) {
    return value instanceof Percent;
}
//# sourceMappingURL=Percent.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/core/util/PopulateString.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/core/util/PopulateString.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getTagValueFromObject: () => (/* binding */ getTagValueFromObject),
/* harmony export */   populateString: () => (/* binding */ populateString)
/* harmony export */ });
/* harmony import */ var _Type__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Type */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Type.js");
/* harmony import */ var _Utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Utils */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Utils.js");
/* harmony import */ var _render_Sprite__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../render/Sprite */ "./node_modules/@amcharts/amcharts5/.internal/core/render/Sprite.js");
/* harmony import */ var _TextFormatter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./TextFormatter */ "./node_modules/@amcharts/amcharts5/.internal/core/util/TextFormatter.js");
/** @ignore */ /** */




/**
 * @ignore
 */
function populateString(target, string) {
    if (string != null) {
        string = "" + string;
        string = _TextFormatter__WEBPACK_IMPORTED_MODULE_0__.TextFormatter.escape(string);
        let tags = string.match(/\{([^}]+)\}/g);
        let i;
        if (tags) {
            for (i = 0; i < tags.length; i++) {
                let tag = tags[i].replace(/\{([^}]+)\}/, "$1");
                let value = getTagValue(target, tag, "");
                if (value == null) {
                    value = "";
                }
                string = string.split(tags[i]).join(value);
            }
        }
        string = _TextFormatter__WEBPACK_IMPORTED_MODULE_0__.TextFormatter.unescape(string);
    }
    else {
        string = "";
    }
    // TODO: apply adapter?
    return string;
}
/**
 * @ignore
 */
function getTagValue(target, tagName, format) {
    let value;
    const dataItem = target.dataItem;
    // Parse parts
    let parts = [];
    let reg = /(format[a-zA-Z]*)\((.*)\)|([^.]+)/g;
    let matches;
    while (true) {
        matches = reg.exec(tagName);
        if (matches === null) {
            break;
        }
        if (matches[3]) {
            // Simple property
            parts.push({
                prop: matches[3]
            });
            // Check if maybe we should force a formatter on this value
            const dateFields = target.getDateFormatter().get("dateFields", []);
            const numericFields = target.getNumberFormatter().get("numericFields", []);
            const durationFields = target.getDurationFormatter().get("durationFields", []);
            if (dateFields.indexOf(matches[3]) !== -1) {
                parts.push({
                    method: "formatDate",
                    params: []
                });
            }
            else if (numericFields.indexOf(matches[3]) !== -1) {
                parts.push({
                    method: "formatNumber",
                    params: []
                });
            }
            else if (durationFields.indexOf(matches[3]) !== -1) {
                parts.push({
                    method: "formatDuration",
                    params: []
                });
            }
        }
        else {
            // Method
            // Parse parameters
            let params = [];
            if (_Utils__WEBPACK_IMPORTED_MODULE_1__.trim(matches[2]) != "") {
                let reg2 = /'([^']*)'|"([^"]*)"|([0-9\-]+)/g;
                let matches2;
                while (true) {
                    matches2 = reg2.exec(matches[2]);
                    if (matches2 === null) {
                        break;
                    }
                    params.push(matches2[1] || matches2[2] || matches2[3]);
                }
            }
            parts.push({
                method: matches[1],
                params: params
            });
        }
    }
    // Check if we can retrieve the value from data item
    if (dataItem) {
        // Check values
        value = getTagValueFromObject(target, parts, dataItem._settings);
        // Check properties
        if (value == null || _Type__WEBPACK_IMPORTED_MODULE_2__.isObject(value)) { // isObject helps to solve problem with date axis, as for example dateX will get dateX from values object and won't get to the dateX date.
            value = getTagValueFromObject(target, parts, dataItem);
        }
        // Check data context
        let dataContext = dataItem.dataContext;
        if (value == null && dataContext) {
            value = getTagValueFromObject(target, parts, dataContext);
            // Maybe it's a literal dot-separated name of the key in dataContext?
            if (value == null) {
                value = getTagValueFromObject(target, [{
                        prop: tagName
                    }], dataContext);
            }
            // scond data context level sometimes exist (tree map)
            if (value == null && dataContext.dataContext) {
                value = getTagValueFromObject(target, parts, dataContext.dataContext);
            }
        }
        // Check component's data item
        if (value == null && dataItem.component && dataItem.component.dataItem !== dataItem) {
            value = getTagValue(dataItem.component, tagName, format);
        }
    }
    // Check sprite's properties
    if (value == null) {
        value = getTagValueFromObject(target, parts, target);
    }
    // Finally, check the parent
    if (value == null && target.parent) {
        value = getTagValue(target.parent, tagName, format);
    }
    return value;
}
/**
 * @ignore
 */
function getCustomDataValue(target, prop) {
    const customData = target.getPrivate("customData");
    if (_Type__WEBPACK_IMPORTED_MODULE_2__.isObject(customData)) {
        return customData[prop];
    }
}
/**
 * @ignore
 */
function getTagValueFromObject(target, parts, object, format) {
    let current = object;
    let formatApplied = false;
    for (let i = 0, len = parts.length; i < len; i++) {
        let part = parts[i];
        if (part.prop) {
            // Regular property
            if (current instanceof _render_Sprite__WEBPACK_IMPORTED_MODULE_3__.Sprite) {
                let tmp = current.get(part.prop);
                if (tmp == null)
                    tmp = current.getPrivate(part.prop);
                if (tmp == null)
                    tmp = getCustomDataValue(current, part.prop);
                if (tmp == null)
                    tmp = current[part.prop];
                current = tmp;
            }
            else if (current.get) {
                let tmp = current.get(part.prop);
                if (tmp == null)
                    tmp = current[part.prop];
                current = tmp;
            }
            else {
                current = current[part.prop];
            }
            if (current == null) {
                // Not set, return undefined
                return;
            }
        }
        else {
            // Method
            switch (part.method) {
                case "formatNumber":
                    let numberValue = _Type__WEBPACK_IMPORTED_MODULE_2__.toNumber(current);
                    if (numberValue != null) {
                        current = target.getNumberFormatter().format(numberValue, format || part.params[0] || undefined);
                        formatApplied = true;
                    }
                    break;
                case "formatDate":
                    let dateValue = _Type__WEBPACK_IMPORTED_MODULE_2__.toDate(current);
                    if (!_Type__WEBPACK_IMPORTED_MODULE_2__.isDate(dateValue) || _Type__WEBPACK_IMPORTED_MODULE_2__.isNaN(dateValue.getTime())) {
                        // Was not able to get date out of value, quitting and letting
                        // calling method try another value
                        return;
                    }
                    if (dateValue != null) {
                        current = target.getDateFormatter().format(dateValue, format || part.params[0] || undefined);
                        formatApplied = true;
                    }
                    break;
                case "formatDuration":
                    let durationValue = _Type__WEBPACK_IMPORTED_MODULE_2__.toNumber(current);
                    if (durationValue != null) {
                        current = target.getDurationFormatter().format(durationValue, format || part.params[0] || undefined, part.params[1] || undefined);
                        formatApplied = true;
                    }
                    break;
                case "urlEncode":
                case "encodeURIComponent":
                    current = encodeURIComponent(current);
                    break;
                default:
                    if (current[part.method]) {
                        current[part.method].apply(object, part.params);
                    }
                    break;
            }
        }
    }
    // Apply default format if it wasn't applied explicitly
    if (!formatApplied) {
        let formatParts = [{
                method: "",
                params: format
            }];
        if (format == null) {
            // Format is not set
            // Determine from the type of the value
            if (_Type__WEBPACK_IMPORTED_MODULE_2__.isNumber(current)) {
                formatParts[0].method = "formatNumber";
                formatParts[0].params = "";
            }
            else if (_Type__WEBPACK_IMPORTED_MODULE_2__.isDate(current)) {
                formatParts[0].method = "formatDate";
                formatParts[0].params = "";
            }
        }
        else {
            // Format set
            // Try to determine formatter based on the format
            let formatterType = _Utils__WEBPACK_IMPORTED_MODULE_1__.getFormat(format);
            // format
            if (formatterType === "number") {
                formatParts[0].method = "formatNumber";
            }
            else if (formatterType === "date") {
                formatParts[0].method = "formatDate";
            }
            else if (formatterType === "duration") {
                formatParts[0].method = "formatDuration";
            }
        }
        // Apply format
        if (formatParts[0].method) {
            current = getTagValueFromObject(target, formatParts, current);
        }
    }
    return current;
}
//# sourceMappingURL=PopulateString.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/core/util/ResizeSensor.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/core/util/ResizeSensor.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ResizeSensor: () => (/* binding */ ResizeSensor)
/* harmony export */ });
/* harmony import */ var _Array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Array */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Array.js");
/* harmony import */ var _Utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Utils */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Utils.js");
/** @ignore */ /** */


/**
 * @ignore
 */
class Native {
    constructor() {
        Object.defineProperty(this, "_observer", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_targets", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
        });
        this._observer = new ResizeObserver((entries) => {
            _Array__WEBPACK_IMPORTED_MODULE_0__.each(entries, (entry) => {
                _Array__WEBPACK_IMPORTED_MODULE_0__.each(this._targets, (x) => {
                    if (x.target === entry.target) {
                        x.callback();
                    }
                });
            });
        });
    }
    addTarget(target, callback) {
        this._observer.observe(target, { box: "border-box" });
        this._targets.push({ target, callback });
    }
    removeTarget(target) {
        this._observer.unobserve(target);
        _Array__WEBPACK_IMPORTED_MODULE_0__.keepIf(this._targets, (x) => {
            return x.target !== target;
        });
    }
}
/**
 * @ignore
 */
class Raf {
    constructor() {
        Object.defineProperty(this, "_timer", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: null
        });
        Object.defineProperty(this, "_targets", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
        });
    }
    addTarget(target, callback) {
        if (this._timer === null) {
            let lastTime = null;
            const loop = () => {
                const currentTime = Date.now();
                if (lastTime === null || currentTime > (lastTime + Raf.delay)) {
                    lastTime = currentTime;
                    _Array__WEBPACK_IMPORTED_MODULE_0__.each(this._targets, (x) => {
                        let newSize = x.target.getBoundingClientRect();
                        if (newSize.width !== x.size.width || newSize.height !== x.size.height) {
                            x.size = newSize;
                            x.callback();
                        }
                    });
                }
                if (this._targets.length === 0) {
                    this._timer = null;
                }
                else {
                    this._timer = requestAnimationFrame(loop);
                }
            };
            this._timer = requestAnimationFrame(loop);
        }
        // We start off with fake bounds so that sensor always kicks in
        let size = { width: 0, height: 0, left: 0, right: 0, top: 0, bottom: 0, x: 0, y: 0 };
        this._targets.push({ target, callback, size });
    }
    removeTarget(target) {
        _Array__WEBPACK_IMPORTED_MODULE_0__.keepIf(this._targets, (x) => {
            return x.target !== target;
        });
        if (this._targets.length === 0) {
            if (this._timer !== null) {
                cancelAnimationFrame(this._timer);
                this._timer = null;
            }
        }
    }
}
Object.defineProperty(Raf, "delay", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: 200
});
/**
 * @ignore
 */
let observer = null;
/**
 * @ignore
 */
function makeSensor() {
    if (observer === null) {
        if (typeof ResizeObserver !== "undefined") {
            observer = new Native();
        }
        else {
            observer = new Raf();
        }
    }
    return observer;
}
/**
 * @ignore
 */
class ResizeSensor {
    constructor(element, callback) {
        Object.defineProperty(this, "_sensor", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_element", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_listener", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_disposed", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        this._sensor = makeSensor();
        this._element = element;
        // This is needed because we need to know when the window is zoomed
        this._listener = _Utils__WEBPACK_IMPORTED_MODULE_1__.onZoom(callback);
        this._sensor.addTarget(element, callback);
    }
    isDisposed() {
        return this._disposed;
    }
    dispose() {
        if (!this._disposed) {
            this._disposed = true;
            this._sensor.removeTarget(this._element);
            this._listener.dispose();
        }
    }
    get sensor() {
        return this._sensor;
    }
}
//# sourceMappingURL=ResizeSensor.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/core/util/States.js":
/*!************************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/core/util/States.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   State: () => (/* binding */ State),
/* harmony export */   States: () => (/* binding */ States)
/* harmony export */ });
/* harmony import */ var _Object__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Object */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Object.js");
/* harmony import */ var _Ease__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Ease */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Ease.js");


/**
 * An object representing a collection of setting values to apply as required.
 *
 * @see {@link https://www.amcharts.com/docs/v5/concepts/settings/states/} for more info
 */
class State {
    constructor(entity, settings) {
        Object.defineProperty(this, "_entity", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_settings", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_userSettings", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {}
        });
        this._entity = entity;
        this._settings = settings;
        _Object__WEBPACK_IMPORTED_MODULE_0__.each(settings, (key) => {
            this._userSettings[key] = true;
        });
    }
    get(key, fallback) {
        const value = this._settings[key];
        if (value !== undefined) {
            return value;
        }
        else {
            return fallback;
        }
    }
    /**
     * @ignore
     */
    setRaw(key, value) {
        this._settings[key] = value;
    }
    /**
     * Sets a setting `value` for the specified `key` to be set when the state
     * is applied.
     *
     * @param   key       Setting key
     * @param   value     Setting value
     * @return            Setting value
     */
    set(key, value) {
        this._userSettings[key] = true;
        this.setRaw(key, value);
    }
    /**
     * Removes a setting value for the specified `key`.
     *
     * @see {@link https://www.amcharts.com/docs/v5/concepts/settings/} for more info
     * @param   key       Setting key
     */
    remove(key) {
        delete this._userSettings[key];
        delete this._settings[key];
    }
    /**
     * Sets multiple settings at once.
     *
     * `settings` must be an object with key: value pairs.
     *
     * @see {@link https://www.amcharts.com/docs/v5/concepts/settings/} for more info
     * @param settings Settings
     */
    setAll(settings) {
        _Object__WEBPACK_IMPORTED_MODULE_0__.keys(settings).forEach((key) => {
            this.set(key, settings[key]);
        });
    }
    _eachSetting(f) {
        _Object__WEBPACK_IMPORTED_MODULE_0__.each(this._settings, f);
    }
    /**
     * Applies the state to the target element.
     *
     * All setting values are set immediately.
     */
    apply() {
        const seen = {};
        seen["stateAnimationEasing"] = true;
        seen["stateAnimationDuration"] = true;
        const defaultState = this._entity.states.lookup("default");
        this._eachSetting((key, value) => {
            if (!seen[key]) {
                seen[key] = true;
                // save values to default state
                if (this !== defaultState) {
                    if (!(key in defaultState._settings)) {
                        defaultState._settings[key] = this._entity.get(key);
                    }
                }
                this._entity.set(key, value);
            }
        });
    }
    /**
     * Applies the state to the target element.
     *
     * Returns an object representing all [[Animation]] objects created for
     * each setting key transition.
     *
     * @return           Animations
     */
    applyAnimate(duration) {
        if (duration == null) {
            duration = this._settings.stateAnimationDuration;
        }
        if (duration == null) {
            duration = this.get("stateAnimationDuration", this._entity.get("stateAnimationDuration", 0));
        }
        let easing = this._settings.stateAnimationEasing;
        if (easing == null) {
            easing = this.get("stateAnimationEasing", this._entity.get("stateAnimationEasing", _Ease__WEBPACK_IMPORTED_MODULE_1__.cubic));
        }
        const defaultState = this._entity.states.lookup("default");
        const seen = {};
        seen["stateAnimationEasing"] = true;
        seen["stateAnimationDuration"] = true;
        const animations = {};
        this._eachSetting((key, value) => {
            if (!seen[key]) {
                seen[key] = true;
                // save values to default state
                if (this != defaultState) {
                    if (!(key in defaultState._settings)) {
                        defaultState._settings[key] = this._entity.get(key);
                    }
                }
                const animation = this._entity.animate({
                    key: key,
                    to: value,
                    duration: duration,
                    easing: easing
                });
                if (animation) {
                    animations[key] = animation;
                }
            }
        });
        return animations;
    }
}
/**
 * Collection of [[State]] objects for an element.
 *
 * @see {@link https://www.amcharts.com/docs/v5/concepts/settings/states/} for more info
 */
class States {
    constructor(entity) {
        Object.defineProperty(this, "_states", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {}
        });
        Object.defineProperty(this, "_entity", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this._entity = entity;
    }
    /**
     * Checks if a state by `name` exists. Returns it there is one.
     *
     * @param  name  State name
     * @return       State
     */
    lookup(name) {
        return this._states[name];
    }
    /**
     * Sets supplied `settings` on a state by the `name`.
     *
     * If such state does not yet exists, it is created.
     *
     * @param   name      State name
     * @param   settings  Settings
     * @return            New State
     */
    create(name, settings) {
        const state = this._states[name];
        if (state) {
            state.setAll(settings);
            return state;
        }
        else {
            const state = new State(this._entity, settings);
            this._states[name] = state;
            return state;
        }
    }
    /**
     * Removes the state called `name`.
     *
     * @param   name      State name
     */
    remove(name) {
        delete this._states[name];
    }
    /**
     * Applies a named state to the target element.
     *
     * @param  newState  State name
     */
    apply(newState) {
        const state = this._states[newState];
        if (state) {
            state.apply();
        }
        this._entity._applyState(newState);
    }
    /**
     * Applies a named state to the element.
     *
     * Returns an object representing all [[Animation]] objects created for
     * each setting key transition.
     *
     * @param   newState  State name
     * @return            Animations
     */
    applyAnimate(newState, duration) {
        let animations;
        const state = this._states[newState];
        if (state) {
            animations = state.applyAnimate(duration);
        }
        this._entity._applyStateAnimated(newState, duration);
        return animations;
    }
}
//# sourceMappingURL=States.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/core/util/Template.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/core/util/Template.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Template: () => (/* binding */ Template),
/* harmony export */   TemplateAdapters: () => (/* binding */ TemplateAdapters),
/* harmony export */   TemplateState: () => (/* binding */ TemplateState),
/* harmony export */   TemplateStates: () => (/* binding */ TemplateStates)
/* harmony export */ });
/* harmony import */ var _EventDispatcher__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./EventDispatcher */ "./node_modules/@amcharts/amcharts5/.internal/core/util/EventDispatcher.js");
/* harmony import */ var _Disposer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Disposer */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Disposer.js");
/* harmony import */ var _Array__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Array */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Array.js");
/* harmony import */ var _Object__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Object */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Object.js");




class TemplateState {
    constructor(name, template, settings) {
        Object.defineProperty(this, "_settings", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_template", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this._name = name;
        this._template = template;
        this._settings = settings;
    }
    get(key, fallback) {
        const value = this._settings[key];
        if (value !== undefined) {
            return value;
        }
        else {
            return fallback;
        }
    }
    set(key, value) {
        this._settings[key] = value;
        // TODO maybe only do this if the value changed ?
        this._template._stateChanged(this._name);
    }
    remove(key) {
        delete this._settings[key];
        // TODO maybe only do this if the value changed ?
        this._template._stateChanged(this._name);
    }
    setAll(settings) {
        _Object__WEBPACK_IMPORTED_MODULE_0__.keys(settings).forEach((key) => {
            this._settings[key] = settings[key];
        });
        this._template._stateChanged(this._name);
    }
    _apply(other, seen) {
        _Object__WEBPACK_IMPORTED_MODULE_0__.each(this._settings, (key, value) => {
            if (!seen[key] && !other._userSettings[key]) {
                seen[key] = true;
                other.setRaw(key, value);
            }
        });
    }
}
class TemplateStates {
    constructor(template) {
        Object.defineProperty(this, "_template", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_states", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {}
        });
        this._template = template;
    }
    lookup(name) {
        return this._states[name];
    }
    create(name, settings) {
        const state = this._states[name];
        if (state) {
            state.setAll(settings);
            return state;
        }
        else {
            const state = new TemplateState(name, this._template, settings);
            this._states[name] = state;
            this._template._stateChanged(name);
            return state;
        }
    }
    remove(name) {
        delete this._states[name];
        this._template._stateChanged(name);
    }
    _apply(entity, state) {
        _Object__WEBPACK_IMPORTED_MODULE_0__.each(this._states, (key, value) => {
            let seen = state.states[key];
            if (seen == null) {
                seen = state.states[key] = {};
            }
            const other = entity.states.create(key, {});
            value._apply(other, seen);
        });
    }
}
class TemplateAdapters {
    constructor() {
        Object.defineProperty(this, "_callbacks", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {}
        });
    }
    add(key, callback) {
        let callbacks = this._callbacks[key];
        if (callbacks === undefined) {
            callbacks = this._callbacks[key] = [];
        }
        callbacks.push(callback);
        return new _Disposer__WEBPACK_IMPORTED_MODULE_1__.Disposer(() => {
            _Array__WEBPACK_IMPORTED_MODULE_2__.removeFirst(callbacks, callback);
            if (callbacks.length === 0) {
                delete this._callbacks[key];
            }
        });
    }
    remove(key) {
        const callbacks = this._callbacks[key];
        if (callbacks !== undefined) {
            delete this._callbacks[key];
        }
    }
    _apply(entity) {
        const disposers = [];
        _Object__WEBPACK_IMPORTED_MODULE_0__.each(this._callbacks, (key, callbacks) => {
            _Array__WEBPACK_IMPORTED_MODULE_2__.each(callbacks, (callback) => {
                disposers.push(entity.adapters.add(key, callback));
            });
        });
        return new _Disposer__WEBPACK_IMPORTED_MODULE_1__.MultiDisposer(disposers);
    }
}
// TODO maybe extend from Properties ?
class Template {
    constructor(settings, isReal) {
        Object.defineProperty(this, "_settings", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_privateSettings", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {}
        });
        // TODO code duplication with Properties
        Object.defineProperty(this, "_settingEvents", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {}
        });
        Object.defineProperty(this, "_privateSettingEvents", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {}
        });
        Object.defineProperty(this, "_entities", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
        });
        Object.defineProperty(this, "states", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new TemplateStates(this)
        });
        Object.defineProperty(this, "adapters", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new TemplateAdapters()
        });
        Object.defineProperty(this, "events", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new _EventDispatcher__WEBPACK_IMPORTED_MODULE_3__.EventDispatcher()
        });
        Object.defineProperty(this, "setup", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        if (!isReal) {
            throw new Error("You cannot use `new Class()`, instead use `Class.new()`");
        }
        this._settings = settings;
    }
    /**
     * Use this method to create an instance of this class.
     *
     * @see {@link https://www.amcharts.com/docs/v5/getting-started/#New_element_syntax} for more info
     * @param   root      Root element
     * @param   settings  Settings
     * @param   template  Template
     * @return            Instantiated object
     */
    static new(settings) {
        return new Template(settings, true);
    }
    /**
     * Array of all entities using this template.
     */
    get entities() {
        return this._entities;
    }
    get(key, fallback) {
        const value = this._settings[key];
        if (value !== undefined) {
            return value;
        }
        else {
            return fallback;
        }
    }
    setRaw(key, value) {
        this._settings[key] = value;
    }
    set(key, value) {
        if (this._settings[key] !== value) {
            this.setRaw(key, value);
            this._entities.forEach((entity) => {
                entity._setTemplateProperty(this, key, value);
            });
        }
    }
    remove(key) {
        if (key in this._settings) {
            delete this._settings[key];
            this._entities.forEach((entity) => {
                entity._removeTemplateProperty(key);
            });
        }
    }
    removeAll() {
        _Object__WEBPACK_IMPORTED_MODULE_0__.each(this._settings, (key, _value) => {
            this.remove(key);
        });
    }
    getPrivate(key, fallback) {
        const value = this._privateSettings[key];
        if (value !== undefined) {
            return value;
        }
        else {
            return fallback;
        }
    }
    setPrivateRaw(key, value) {
        this._privateSettings[key] = value;
        return value;
    }
    setPrivate(key, value) {
        if (this._privateSettings[key] !== value) {
            this.setPrivateRaw(key, value);
            this._entities.forEach((entity) => {
                entity._setTemplatePrivateProperty(this, key, value);
            });
        }
        return value;
    }
    removePrivate(key) {
        if (key in this._privateSettings) {
            delete this._privateSettings[key];
            this._entities.forEach((entity) => {
                entity._removeTemplatePrivateProperty(key);
            });
        }
    }
    setAll(value) {
        _Object__WEBPACK_IMPORTED_MODULE_0__.each(value, (key, value) => {
            this.set(key, value);
        });
    }
    // TODO code duplication with Properties
    on(key, callback) {
        let events = this._settingEvents[key];
        if (events === undefined) {
            events = this._settingEvents[key] = [];
        }
        events.push(callback);
        return new _Disposer__WEBPACK_IMPORTED_MODULE_1__.Disposer(() => {
            _Array__WEBPACK_IMPORTED_MODULE_2__.removeFirst(events, callback);
            if (events.length === 0) {
                delete this._settingEvents[key];
            }
        });
    }
    // TODO code duplication with Properties
    onPrivate(key, callback) {
        let events = this._privateSettingEvents[key];
        if (events === undefined) {
            events = this._privateSettingEvents[key] = [];
        }
        events.push(callback);
        return new _Disposer__WEBPACK_IMPORTED_MODULE_1__.Disposer(() => {
            _Array__WEBPACK_IMPORTED_MODULE_2__.removeFirst(events, callback);
            if (events.length === 0) {
                delete this._privateSettingEvents[key];
            }
        });
    }
    _apply(entity, state) {
        const disposers = [];
        _Object__WEBPACK_IMPORTED_MODULE_0__.each(this._settingEvents, (key, events) => {
            _Array__WEBPACK_IMPORTED_MODULE_2__.each(events, (event) => {
                disposers.push(entity.on(key, event));
            });
        });
        _Object__WEBPACK_IMPORTED_MODULE_0__.each(this._privateSettingEvents, (key, events) => {
            _Array__WEBPACK_IMPORTED_MODULE_2__.each(events, (event) => {
                disposers.push(entity.onPrivate(key, event));
            });
        });
        this.states._apply(entity, state);
        disposers.push(this.adapters._apply(entity));
        disposers.push(entity.events.copyFrom(this.events));
        return new _Disposer__WEBPACK_IMPORTED_MODULE_1__.MultiDisposer(disposers);
    }
    _setObjectTemplate(entity) {
        this._entities.push(entity);
    }
    _removeObjectTemplate(entity) {
        _Array__WEBPACK_IMPORTED_MODULE_2__.remove(this._entities, entity);
    }
    _stateChanged(name) {
        this._entities.forEach((entity) => {
            entity._applyStateByKey(name);
        });
    }
}
//# sourceMappingURL=Template.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/core/util/TextFormatter.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/core/util/TextFormatter.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   TextFormatter: () => (/* binding */ TextFormatter)
/* harmony export */ });
/* harmony import */ var _Color__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Color */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Color.js");
/* harmony import */ var _Type__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Type */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Type.js");


class TextFormatter {
    /**
     * Replaces brackets with temporary placeholders.
     *
     * @ignore Exclude from docs
     * @param text  Input text
     * @return Escaped text
     */
    static escape(text) {
        return text.
            replace(/\[\[/g, this.prefix + "1").
            replace(/([^\/\]]{1})\]\]/g, "$1" + this.prefix + "2").
            replace(/\]\]/g, this.prefix + "2").
            replace(/\{\{/g, this.prefix + "3").
            replace(/\}\}/g, this.prefix + "4").
            replace(/\'\'/g, this.prefix + "5");
    }
    /**
     * Replaces placeholders back to brackets.
     *
     * @ignore Exclude from docs
     * @param text  Escaped text
     * @return Unescaped text
     */
    static unescape(text) {
        return text.
            replace(new RegExp(this.prefix + "1", "g"), "[[").
            replace(new RegExp(this.prefix + "2", "g"), "]]").
            replace(new RegExp(this.prefix + "3", "g"), "{{").
            replace(new RegExp(this.prefix + "4", "g"), "}}").
            replace(new RegExp(this.prefix + "5", "g"), "''");
    }
    /**
     * Cleans up the text text for leftover double square brackets.
     *
     * @ignore Exclude from docs
     * @param text  Input text
     * @return Cleaned up text
     */
    static cleanUp(text) {
        return text.
            replace(/\[\[/g, "[").
            replace(/\]\]/g, "]").
            replace(/\{\{/g, "{").
            replace(/\}\}/g, "}").
            replace(/\'\'/g, "'");
    }
    /**
     * Splits string into chunks. (style blocks, quoted blocks, regular blocks)
     *
     * If the second parameter `quotedBlocks` is set to `true` this method will
     * also single out text blocks enclosed within single quotes that no
     * formatting should be applied to, and they should be displayed as is.
     *
     * Default for the above is `false`, so that you can use single quote in text
     * without escaping it.
     *
     * If enabled, single quotes can be escaped by doubling it - adding two
     * single quotes, which will be replaced by a one single quote in the final
     * output.
     *
     * @ignore Exclude from docs
     * @param text          Text to chunk
     * @param quotedBlocks  Use quoted blocks
     * @param noFormatting  Formatting blocks will be treated as regular text
     * @return Array of string chunks
     */
    static chunk(text, quotedBlocks = false, noFormatting = false) {
        // Init result
        let res = [];
        // Replace double (escaped) square spaces and quotes with temporary codes
        text = this.escape(text);
        // Deal with style blocks
        let chunks = quotedBlocks ? text.split("'") : [text];
        for (let i = 0; i < chunks.length; i++) {
            let chunk = chunks[i];
            // Empty?
            if (chunk === "") {
                continue;
            }
            if ((i % 2) === 0) {
                // Text outside quotes
                // Parse for style blocks which are "text" chunks, the rest chunks are
                // "value"
                chunk = chunk.replace(/\]\[/g, "]" + _Type__WEBPACK_IMPORTED_MODULE_0__.PLACEHOLDER + "[");
                chunk = chunk.replace(/\[\]/g, "[ ]");
                let chunks2 = chunk.split(/[\[\]]+/);
                for (let i2 = 0; i2 < chunks2.length; i2++) {
                    let chunk2 = this.cleanUp(this.unescape(chunks2[i2]));
                    // Placeholder?
                    if (chunk2 === _Type__WEBPACK_IMPORTED_MODULE_0__.PLACEHOLDER) {
                        continue;
                    }
                    // Empty?
                    if (chunk2 === "") {
                        continue;
                    }
                    // Block or value
                    if ((i2 % 2) === 0) {
                        res.push({
                            "type": "value",
                            "text": chunk2
                        });
                    }
                    else {
                        res.push({
                            "type": noFormatting ? "value" : "format",
                            "text": "[" + chunk2 + "]"
                        });
                    }
                }
            }
            else {
                // A text within doublequotes
                // All chunks are "text"
                let chunks2 = chunk.split(/[\[\]]+/);
                for (let i2 = 0; i2 < chunks2.length; i2++) {
                    let chunk2 = this.cleanUp(this.unescape(chunks2[i2]));
                    // Empty?
                    if (chunk2 === "") {
                        continue;
                    }
                    // Block or text
                    if ((i2 % 2) === 0) {
                        res.push({
                            "type": "text",
                            "text": chunk2
                        });
                    }
                    else if (this.isImage(chunk2)) {
                        res.push({
                            "type": "image",
                            "text": "[" + chunk2 + "]"
                        });
                    }
                    else {
                        res.push({
                            "type": "format",
                            "text": "[" + chunk2 + "]"
                        });
                    }
                }
            }
        }
        return res;
    }
    /**
     * Checks if supplied format contains image information and should be
     * formatted as such.
     * I.e.: `[img: myImage.png]`
     *
     * @ignore
     * @param  text  Format
     * @return true if it is an image
     */
    static isImage(text) {
        return text.match(/img[ ]?:/) ? true : false;
    }
    static getTextStyle(style) {
        // let textStyle: string[] = [];
        // let textFill: string | undefined;
        let format = {};
        if (style == "" || style == "[ ]") {
            return {};
        }
        // Pre-process quoted text
        const q = style.match(/('[^']*')|("[^"]*")/gi);
        if (q) {
            for (let i = 0; i < q.length; i++) {
                style = style.replace(q[i], q[i].replace(/['"]*/g, "").replace(/[ ]+/g, "+"));
            }
        }
        // Get style parts
        let b = style.match(/([\w\-]*:[\s]?[^;\s\]]*)|(\#[\w]{1,6})|([\w\-]+)|(\/)/gi);
        // Empty?
        if (!b) {
            return {};
        }
        // Check each part
        for (let i = 0; i < b.length; i++) {
            if (b[i].match(/^(normal|bold|bolder|lighter|100|200|300|400|500|600|700|800|900)$/i)) {
                format.fontWeight = b[i];
            }
            else if (b[i].match(/^(underline|line-through)$/i)) {
                format.textDecoration = b[i];
            }
            else if (b[i] == "/") {
                // Just closing tag
                // Do nothing
            }
            else if (!b[i].match(/:/)) {
                // Color
                format.fill = _Color__WEBPACK_IMPORTED_MODULE_1__.Color.fromString(b[i]);
            }
            else {
                const p = b[i].replace("+", " ").split(/:[ ]*/);
                format[p[0]] = p[1];
                //textStyle.push(b[i].replace(/^[a-zA-Z]:[ ]*/, ""));
                //b[i] = b[i].replace(/\+/g, " ");
            }
        }
        return format;
    }
}
Object.defineProperty(TextFormatter, "prefix", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: "__amcharts__"
});
//# sourceMappingURL=TextFormatter.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/core/util/Time.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/core/util/Time.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   add: () => (/* binding */ add),
/* harmony export */   checkChange: () => (/* binding */ checkChange),
/* harmony export */   chooseInterval: () => (/* binding */ chooseInterval),
/* harmony export */   copy: () => (/* binding */ copy),
/* harmony export */   getDateIntervalDuration: () => (/* binding */ getDateIntervalDuration),
/* harmony export */   getDuration: () => (/* binding */ getDuration),
/* harmony export */   getIntervalDuration: () => (/* binding */ getIntervalDuration),
/* harmony export */   getNextUnit: () => (/* binding */ getNextUnit),
/* harmony export */   getTime: () => (/* binding */ getTime),
/* harmony export */   getUnitValue: () => (/* binding */ getUnitValue),
/* harmony export */   now: () => (/* binding */ now),
/* harmony export */   round: () => (/* binding */ round),
/* harmony export */   sleep: () => (/* binding */ sleep),
/* harmony export */   timeUnitDurations: () => (/* binding */ timeUnitDurations)
/* harmony export */ });
/* harmony import */ var _Type__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Type */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Type.js");
/* harmony import */ var _Utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Utils */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Utils.js");
/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */


/**
 * Returns a `Promise` which can be used to execute code after number of
 * milliseconds.
 *
 * @param   ms  Sleep duration in ms
 * @return      Promise
 */
function sleep(ms) {
    return new Promise((resolve, _reject) => {
        setTimeout(resolve, ms);
    });
}
/**
 * Maps time period names to their numeric representations in milliseconds.
 *
 * @ignore Exclude from docs
 */
let timeUnitDurations = {
    millisecond: 1,
    second: 1000,
    minute: 60000,
    hour: 3600000,
    day: 86400000,
    week: 604800000,
    month: 365.242 / 12 * 86400000,
    year: 31536000000
};
/**
 * Returns the next time unit that goes after source `unit`.
 *
 * E.g. "hour" is the next unit after "minute", etc.
 *
 * @ignore Exclude from docs
 * @param unit  Source time unit
 * @return Next time unit
 */
function getNextUnit(unit) {
    switch (unit) {
        case "year":
            return;
        case "month":
            return "year";
        case "week":
            return "month";
        case "day":
            return "month"; // not a mistake
        case "hour":
            return "day";
        case "minute":
            return "hour";
        case "second":
            return "minute";
        case "millisecond":
            return "second";
    }
}
/**
 * Returns number of milliseconds in the `count` of time `unit`.
 *
 * Available units: "millisecond", "second", "minute", "hour", "day", "week",
 * "month", and "year".
 *
 * @param unit   Time unit
 * @param count  Number of units
 * @return Milliseconds
 */
function getDuration(unit, count) {
    if (count == null) {
        count = 1;
    }
    return timeUnitDurations[unit] * count;
}
/**
 * @ignore
 */
function getIntervalDuration(interval) {
    if (interval) {
        return timeUnitDurations[interval.timeUnit] * interval.count;
    }
    return 0;
}
function getDateIntervalDuration(interval, date, firstDateOfWeek, utc, timezone) {
    const unit = interval.timeUnit;
    const count = interval.count;
    if (unit == "hour" || unit == "minute" || unit == "second" || unit == "millisecond") {
        return timeUnitDurations[interval.timeUnit] * interval.count;
    }
    else {
        const firstTime = round(new Date(date.getTime()), unit, count, firstDateOfWeek, utc, undefined, timezone).getTime();
        let lastTime = firstTime + count * getDuration(unit) * 1.05;
        lastTime = round(new Date(lastTime), unit, 1, firstDateOfWeek, utc, undefined, timezone).getTime();
        return lastTime - firstTime;
    }
}
/**
 * Returns current `Date` object.
 *
 * @return Current date
 */
function now() {
    return new Date();
}
/**
 * Returns current timestamp.
 *
 * @return Current timestamp
 */
function getTime() {
    return now().getTime();
}
/**
 * Returns a copy of the `Date` object.
 *
 * @param date  Source date
 * @return Copy
 */
function copy(date) {
    return new Date(date.getTime()); // todo: check if this is ok. new Date(date) used to strip milliseconds on FF in v3
}
/**
 * Checks if the `unit` part of two `Date` objects do not match. Two dates
 * represent a "range" of time, rather the same time date.
 *
 * @param timeOne  timestamp
 * @param timeTwo  timestamp
 * @param unit     Time unit to check
 * @return Range?
 */
function checkChange(timeOne, timeTwo, unit, utc, timezone) {
    // quick
    if ((timeTwo - timeOne) > getDuration(unit, 1.2)) {
        return true;
    }
    let dateOne = new Date(timeOne);
    let dateTwo = new Date(timeTwo);
    if (timezone) {
        dateOne = timezone.convertLocal(dateOne);
        dateTwo = timezone.convertLocal(dateTwo);
    }
    let timeZoneOffset1 = 0;
    let timeZoneOffset2 = 0;
    if (!utc && unit != "millisecond") {
        timeZoneOffset1 = dateOne.getTimezoneOffset();
        dateOne.setUTCMinutes(dateOne.getUTCMinutes() - timeZoneOffset1);
        timeZoneOffset2 = dateTwo.getTimezoneOffset();
        dateTwo.setUTCMinutes(dateTwo.getUTCMinutes() - timeZoneOffset2);
    }
    let changed = false;
    switch (unit) {
        case "year":
            if (dateOne.getUTCFullYear() != dateTwo.getUTCFullYear()) {
                changed = true;
            }
            break;
        case "month":
            if (dateOne.getUTCFullYear() != dateTwo.getUTCFullYear()) {
                changed = true;
            }
            else if (dateOne.getUTCMonth() != dateTwo.getUTCMonth()) {
                changed = true;
            }
            break;
        case "day":
            if (dateOne.getUTCMonth() != dateTwo.getUTCMonth()) {
                changed = true;
            }
            else if (dateOne.getUTCDate() != dateTwo.getUTCDate()) {
                changed = true;
            }
            break;
        case "hour":
            if (dateOne.getUTCHours() != dateTwo.getUTCHours()) {
                changed = true;
            }
            break;
        case "minute":
            if (dateOne.getUTCMinutes() != dateTwo.getUTCMinutes()) {
                changed = true;
            }
            break;
        case "second":
            if (dateOne.getUTCSeconds() != dateTwo.getUTCSeconds()) {
                changed = true;
            }
            break;
        case "millisecond":
            if (dateOne.getTime() != dateTwo.getTime()) {
                changed = true;
            }
            break;
    }
    if (changed) {
        return changed;
    }
    let nextUnit = getNextUnit(unit);
    if (nextUnit) {
        return checkChange(timeOne, timeTwo, nextUnit, utc, timezone);
    }
    else {
        return false;
    }
}
/**
 * Adds `count` of time `unit` to the source date. Returns a modified `Date` object.
 *
 * @param date   Source date
 * @param unit   Time unit
 * @param count  Number of units to add
 * @return Modified date
 */
function add(date, unit, count, utc, timezone) {
    let timeZoneOffset = 0;
    if (!utc && unit != "millisecond") {
        timeZoneOffset = date.getTimezoneOffset();
        if (timezone) {
            timeZoneOffset -= timezone.offsetUTC(date);
        }
        date.setUTCMinutes(date.getUTCMinutes() - timeZoneOffset);
    }
    switch (unit) {
        case "day":
            let day = date.getUTCDate();
            date.setUTCDate(day + count);
            break;
        case "second":
            let seconds = date.getUTCSeconds();
            date.setUTCSeconds(seconds + count);
            break;
        case "millisecond":
            let milliseconds = date.getUTCMilliseconds();
            date.setUTCMilliseconds(milliseconds + count);
            break;
        case "hour":
            let hours = date.getUTCHours();
            date.setUTCHours(hours + count);
            break;
        case "minute":
            let minutes = date.getUTCMinutes();
            date.setUTCMinutes(minutes + count);
            break;
        case "year":
            let year = date.getUTCFullYear();
            date.setUTCFullYear(year + count);
            break;
        case "month":
            let month = date.getUTCMonth();
            date.setUTCMonth(month + count);
            break;
        case "week":
            let wday = date.getUTCDate();
            date.setUTCDate(wday + count * 7);
            break;
    }
    if (!utc && unit != "millisecond") {
        date.setUTCMinutes(date.getUTCMinutes() + timeZoneOffset);
        if (unit == "day" || unit == "week" || unit == "month" || unit == "year") {
            let newTimeZoneOffset = date.getTimezoneOffset();
            if (timezone) {
                newTimeZoneOffset += timezone.offsetUTC(date);
            }
            if (newTimeZoneOffset != timeZoneOffset) {
                let diff = newTimeZoneOffset - timeZoneOffset;
                date.setUTCMinutes(date.getUTCMinutes() + diff);
                // solves issues if new time falls back to old time zone
                if (date.getTimezoneOffset() != newTimeZoneOffset) {
                    date.setUTCMinutes(date.getUTCMinutes() - diff);
                }
            }
        }
    }
    return date;
}
/**
 * "Rounds" the date to specific time unit.
 *
 * @param date             Source date
 * @param unit             Time unit
 * @param count            Number of units to round to
 * @param firstDateOfWeek  First day of week
 * @param utc              Use UTC timezone
 * @param firstDate        First date to round to
 * @param roundMinutes     Minutes to round to (some timezones use non-whole hour)
 * @param timezone         Use specific named timezone when rounding
 * @return New date
 */
function round(date, unit, count, firstDateOfWeek, utc, firstDate, timezone) {
    if (!timezone || utc) {
        let timeZoneOffset = 0;
        if (!utc && unit != "millisecond") {
            timeZoneOffset = date.getTimezoneOffset();
            date.setUTCMinutes(date.getUTCMinutes() - timeZoneOffset);
        }
        switch (unit) {
            case "day":
                let day = date.getUTCDate();
                if (count > 1) {
                    //	day = Math.floor(day / count) * count;
                    if (firstDate) {
                        firstDate = round(firstDate, "day", 1);
                        let difference = date.getTime() - firstDate.getTime();
                        let unitCount = Math.floor(difference / getDuration("day") / count);
                        let duration = getDuration("day", unitCount * count);
                        date.setTime(firstDate.getTime() + duration - timeZoneOffset * getDuration("minute"));
                    }
                }
                else {
                    date.setUTCDate(day);
                }
                date.setUTCHours(0, 0, 0, 0);
                break;
            case "second":
                let seconds = date.getUTCSeconds();
                if (count > 1) {
                    seconds = Math.floor(seconds / count) * count;
                }
                date.setUTCSeconds(seconds, 0);
                break;
            case "millisecond":
                if (count == 1) {
                    return date; // much better for perf!
                }
                let milliseconds = date.getUTCMilliseconds();
                milliseconds = Math.floor(milliseconds / count) * count;
                date.setUTCMilliseconds(milliseconds);
                break;
            case "hour":
                let hours = date.getUTCHours();
                if (count > 1) {
                    hours = Math.floor(hours / count) * count;
                }
                date.setUTCHours(hours, 0, 0, 0);
                break;
            case "minute":
                let minutes = date.getUTCMinutes();
                if (count > 1) {
                    minutes = Math.floor(minutes / count) * count;
                }
                date.setUTCMinutes(minutes, 0, 0);
                break;
            case "month":
                let month = date.getUTCMonth();
                if (count > 1) {
                    month = Math.floor(month / count) * count;
                }
                date.setUTCMonth(month, 1);
                date.setUTCHours(0, 0, 0, 0);
                break;
            case "year":
                let year = date.getUTCFullYear();
                if (count > 1) {
                    year = Math.floor(year / count) * count;
                }
                date.setUTCFullYear(year, 0, 1);
                date.setUTCHours(0, 0, 0, 0);
                break;
            case "week":
                let wday = date.getUTCDate();
                let weekDay = date.getUTCDay();
                if (!_Type__WEBPACK_IMPORTED_MODULE_0__.isNumber(firstDateOfWeek)) {
                    firstDateOfWeek = 1;
                }
                if (weekDay >= firstDateOfWeek) {
                    wday = wday - weekDay + firstDateOfWeek;
                }
                else {
                    wday = wday - (7 + weekDay) + firstDateOfWeek;
                }
                date.setUTCDate(wday);
                date.setUTCHours(0, 0, 0, 0);
                break;
        }
        if (!utc && unit != "millisecond") {
            date.setUTCMinutes(date.getUTCMinutes() + timeZoneOffset);
            if (unit == "day" || unit == "week" || unit == "month" || unit == "year") {
                let newTimeZoneOffset = date.getTimezoneOffset();
                if (newTimeZoneOffset != timeZoneOffset) {
                    let diff = newTimeZoneOffset - timeZoneOffset;
                    date.setUTCMinutes(date.getUTCMinutes() + diff);
                }
            }
        }
        return date;
    }
    else {
        if (isNaN(date.getTime())) {
            return date;
        }
        let tzoffset = timezone.offsetUTC(date);
        let timeZoneOffset = date.getTimezoneOffset();
        let parsedDate = timezone.parseDate(date);
        let year = parsedDate.year;
        let month = parsedDate.month;
        let day = parsedDate.day;
        let hour = parsedDate.hour;
        let minute = parsedDate.minute;
        let second = parsedDate.second;
        let millisecond = parsedDate.millisecond;
        let weekday = parsedDate.weekday;
        let offsetDif = tzoffset - timeZoneOffset;
        switch (unit) {
            case "day":
                if (count > 1 && firstDate) {
                    firstDate = round(firstDate, "day", 1, firstDateOfWeek, utc, undefined, timezone);
                    let difference = date.getTime() - firstDate.getTime();
                    let unitCount = Math.floor(difference / getDuration("day") / count);
                    let duration = getDuration("day", unitCount * count);
                    date.setTime(firstDate.getTime() + duration);
                    parsedDate = timezone.parseDate(date);
                    year = parsedDate.year;
                    month = parsedDate.month;
                    day = parsedDate.day;
                }
                hour = 0;
                minute = offsetDif;
                second = 0;
                millisecond = 0;
                break;
            case "second":
                minute += offsetDif;
                if (count > 1) {
                    second = Math.floor(second / count) * count;
                }
                millisecond = 0;
                break;
            case "millisecond":
                minute += offsetDif;
                if (count > 1) {
                    millisecond = Math.floor(millisecond / count) * count;
                }
                break;
            case "hour":
                if (count > 1) {
                    hour = Math.floor(hour / count) * count;
                }
                minute = offsetDif;
                second = 0;
                millisecond = 0;
                break;
            case "minute":
                if (count > 1) {
                    minute = Math.floor(minute / count) * count;
                }
                minute += offsetDif;
                second = 0;
                millisecond = 0;
                break;
            case "month":
                if (count > 1) {
                    month = Math.floor(month / count) * count;
                }
                day = 1;
                hour = 0;
                minute = offsetDif;
                second = 0;
                millisecond = 0;
                break;
            case "year":
                if (count > 1) {
                    year = Math.floor(year / count) * count;
                }
                month = 0;
                day = 1;
                hour = 0;
                minute = offsetDif;
                second = 0;
                millisecond = 0;
                break;
            case "week":
                if (!_Type__WEBPACK_IMPORTED_MODULE_0__.isNumber(firstDateOfWeek)) {
                    firstDateOfWeek = 1;
                }
                if (weekday >= firstDateOfWeek) {
                    day = day - weekday + firstDateOfWeek;
                }
                else {
                    day = day - (7 + weekday) + firstDateOfWeek;
                }
                hour = 0;
                minute = offsetDif;
                second = 0;
                millisecond = 0;
                break;
        }
        date = new Date(year, month, day, hour, minute, second, millisecond);
        let newTimeZoneOffset = date.getTimezoneOffset();
        let newTzoffset = timezone.offsetUTC(date);
        let newDiff = newTzoffset - newTimeZoneOffset;
        if (newDiff != offsetDif) {
            date.setTime(date.getTime() + (newDiff - offsetDif) * 60000);
        }
        return date;
    }
}
/**
 * @ignore
 */
function chooseInterval(index, duration, gridCount, intervals) {
    let gridInterval = intervals[index];
    let intervalDuration = getIntervalDuration(gridInterval);
    let lastIndex = intervals.length - 1;
    if (index >= lastIndex) {
        return Object.assign({}, intervals[lastIndex]);
    }
    let count = Math.ceil(duration / intervalDuration);
    if (duration < intervalDuration && index > 0) {
        return Object.assign({}, intervals[index - 1]);
    }
    if (count <= gridCount) {
        return Object.assign({}, intervals[index]);
    }
    else {
        if (index + 1 < intervals.length) {
            return chooseInterval(index + 1, duration, gridCount, intervals);
        }
        else {
            return Object.assign({}, intervals[index]);
        }
    }
}
/**
 * @ignore
 */
function getUnitValue(date, unit) {
    switch (unit) {
        case "day":
            return date.getDate();
        case "second":
            return date.getSeconds();
        case "millisecond":
            return date.getMilliseconds();
        case "hour":
            return date.getHours();
        case "minute":
            return date.getMinutes();
        case "month":
            return date.getMonth();
        case "year":
            return date.getFullYear();
        case "week":
            return _Utils__WEBPACK_IMPORTED_MODULE_1__.getWeek(date);
    }
}
//# sourceMappingURL=Time.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/core/util/Timezone.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/core/util/Timezone.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Timezone: () => (/* binding */ Timezone)
/* harmony export */ });
function parseDate(timezone, date) {
    let year = 0;
    let month = 0;
    let day = 1;
    let hour = 0;
    let minute = 0;
    let second = 0;
    let millisecond = 0;
    let weekday = 0;
    timezone.formatToParts(date).forEach((x) => {
        switch (x.type) {
            case "year":
                year = +x.value;
                break;
            case "month":
                month = (+x.value) - 1;
                break;
            case "day":
                day = +x.value;
                break;
            case "hour":
                hour = +x.value;
                break;
            case "minute":
                minute = +x.value;
                break;
            case "second":
                second = +x.value;
                break;
            case "fractionalSecond":
                millisecond = +x.value;
                break;
            case "weekday":
                switch (x.value) {
                    case "Sun":
                        weekday = 0;
                        break;
                    case "Mon":
                        weekday = 1;
                        break;
                    case "Tue":
                        weekday = 2;
                        break;
                    case "Wed":
                        weekday = 3;
                        break;
                    case "Thu":
                        weekday = 4;
                        break;
                    case "Fri":
                        weekday = 5;
                        break;
                    case "Sat":
                        weekday = 6;
                        break;
                }
        }
    });
    if (hour === 24) {
        hour = 0;
    }
    return { year, month, day, hour, minute, second, millisecond, weekday };
}
function toUTCDate(timezone, date) {
    const { year, month, day, hour, minute, second, millisecond } = parseDate(timezone, date);
    return Date.UTC(year, month, day, hour, minute, second, millisecond);
}
class Timezone {
    constructor(timezone, isReal) {
        Object.defineProperty(this, "_utc", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_dtf", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        if (!isReal) {
            throw new Error("You cannot use `new Class()`, instead use `Class.new()`");
        }
        this.name = timezone;
        this._utc = new Intl.DateTimeFormat("UTC", {
            hour12: false,
            timeZone: "UTC",
            year: "numeric",
            month: "2-digit",
            day: "2-digit",
            hour: "2-digit",
            minute: "2-digit",
            second: "2-digit",
            weekday: "short",
            fractionalSecondDigits: 3,
        });
        this._dtf = new Intl.DateTimeFormat("UTC", {
            hour12: false,
            timeZone: timezone,
            year: "numeric",
            month: "2-digit",
            day: "2-digit",
            hour: "2-digit",
            minute: "2-digit",
            second: "2-digit",
            weekday: "short",
            fractionalSecondDigits: 3,
        });
    }
    /**
     * Use this method to create an instance of this class.
     *
     * @see {@link https://www.amcharts.com/docs/v5/getting-started/#New_element_syntax} for more info
     * @param   timezone  IANA timezone
     * @return            Instantiated object
     */
    static new(timezone) {
        return (new this(timezone, true));
    }
    convertLocal(date) {
        const offset = this.offsetUTC(date);
        const userOffset = date.getTimezoneOffset();
        const output = new Date(date);
        output.setUTCMinutes(output.getUTCMinutes() - (offset - userOffset));
        const newUserOffset = output.getTimezoneOffset();
        if (userOffset != newUserOffset) {
            output.setUTCMinutes(output.getUTCMinutes() + newUserOffset - userOffset);
        }
        return output;
    }
    offsetUTC(date) {
        const utc = toUTCDate(this._utc, date);
        const dtf = toUTCDate(this._dtf, date);
        return (utc - dtf) / 60000;
    }
    parseDate(date) {
        return parseDate(this._dtf, date);
    }
}
//# sourceMappingURL=Timezone.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/core/util/Type.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/core/util/Type.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PLACEHOLDER: () => (/* binding */ PLACEHOLDER),
/* harmony export */   PLACEHOLDER2: () => (/* binding */ PLACEHOLDER2),
/* harmony export */   assert: () => (/* binding */ assert),
/* harmony export */   getType: () => (/* binding */ getType),
/* harmony export */   isArray: () => (/* binding */ isArray),
/* harmony export */   isDate: () => (/* binding */ isDate),
/* harmony export */   isNaN: () => (/* binding */ isNaN),
/* harmony export */   isNumber: () => (/* binding */ isNumber),
/* harmony export */   isObject: () => (/* binding */ isObject),
/* harmony export */   isString: () => (/* binding */ isString),
/* harmony export */   numberToString: () => (/* binding */ numberToString),
/* harmony export */   repeat: () => (/* binding */ repeat),
/* harmony export */   toDate: () => (/* binding */ toDate),
/* harmony export */   toNumber: () => (/* binding */ toNumber)
/* harmony export */ });
/**
 * A collection of utility functions for various type checks and conversion
 * @hidden
 */
/**
 * ============================================================================
 * TYPE CHECK
 * ============================================================================
 * @hidden
 */
/**
 * Returns `true` if value is not a number (NaN).
 *
 * @param value Input value
 * @return Is NaN?
 */
function isNaN(value) {
    return Number(value) !== value;
}
/**
 * Returns a type of the value.
 *
 * @param value  Input value
 * @return Type of the value
 * @ignore
 */
function getType(value) {
    return ({}).toString.call(value);
}
/**
 * Asserts that the condition is true.
 *
 * @param condition  Condition to check
 * @param message    Message to display in the error
 * @ignore
 */
function assert(condition, message = "Assertion failed") {
    if (!condition) {
        throw new Error(message);
    }
}
/**
 * ============================================================================
 * QUICK CONVERSION
 * ============================================================================
 * @hidden
 */
/**
 * Converts any value into a `number`.
 *
 * @param value  Source value
 * @return Number representation of value
 */
function toNumber(value) {
    if (value != null && !isNumber(value)) {
        let converted = Number(value);
        if (isNaN(converted) && isString(value) && value != "") {
            return toNumber(value.replace(/[^0-9.\-]+/g, ''));
        }
        return converted;
    }
    return value;
}
/**
 * Converts anything to Date object.
 *
 * @param value  A value of any type
 * @return Date object representing a value
 */
function toDate(value) {
    if (isDate(value)) {
        // TODO maybe don't create a new Date ?
        return new Date(value);
    }
    else if (isNumber(value)) {
        return new Date(value);
    }
    else {
        // Try converting to number (assuming timestamp)
        let num = Number(value);
        if (!isNumber(num)) {
            return new Date(value);
        }
        else {
            return new Date(num);
        }
    }
}
/**
 * Converts numeric value into string. Deals with large or small numbers that
 * would otherwise use exponents.
 *
 * @param value  Numeric value
 * @return Numeric value as string
 */
function numberToString(value) {
    // TODO handle Infinity and -Infinity
    if (isNaN(value)) {
        return "NaN";
    }
    if (value === Infinity) {
        return "Infinity";
    }
    if (value === -Infinity) {
        return "-Infinity";
    }
    // Negative 0
    if ((value === 0) && (1 / value === -Infinity)) {
        return "-0";
    }
    // Preserve negative and deal with absoute values
    let negative = value < 0;
    value = Math.abs(value);
    // TODO test this
    let parsed = /^([0-9]+)(?:\.([0-9]+))?(?:e[\+\-]([0-9]+))?$/.exec("" + value);
    let digits = parsed[1];
    let decimals = parsed[2] || "";
    let res;
    // Leave the nummber as it is if it does not use exponents
    if (parsed[3] === undefined) {
        res = (decimals === "" ? digits : digits + "." + decimals);
    }
    else {
        let exponent = +parsed[3];
        // Deal with decimals
        if (value < 1) {
            let zeros = exponent - 1;
            res = "0." + repeat("0", zeros) + digits + decimals;
            // Deal with integers
        }
        else {
            let zeros = exponent - decimals.length;
            if (zeros === 0) {
                res = digits + decimals;
            }
            else if (zeros < 0) {
                res = digits + decimals.slice(0, zeros) + "." + decimals.slice(zeros);
            }
            else {
                res = digits + decimals + repeat("0", zeros);
            }
        }
    }
    return negative ? "-" + res : res;
}
/**
 * Repeats a `string` number of times as set in `amount`.
 *
 * @ignore Exclude from docs
 * @todo Make this faster
 * @param string  Source string
 * @param amount  Number of times to repeat string
 * @return New string
 */
function repeat(string, amount) {
    return new Array(amount + 1).join(string);
}
/**
 * ============================================================================
 * TYPE CHECK
 * ============================================================================
 * @hidden
 */
/**
 * Checks if parameter is `Date`.
 *
 * @param value  Input value
 * @return Is Date?
 */
function isDate(value) {
    return getType(value) === "[object Date]";
}
/**
 * Checks if parameter is `string`.
 *
 * @param value  Input value
 * @return Is string?
 */
function isString(value) {
    return typeof value === "string";
}
/**
 * Checks if parameter is `number`.
 *
 * @param value  Input value
 * @return Is number?
 */
function isNumber(value) {
    return typeof value === "number" && Number(value) == value;
}
/**
 * Checks if parameter is `object`.
 *
 * @param value  Input value
 * @return Is object?
 */
function isObject(value) {
    return typeof value === "object" && value !== null;
}
/**
 * Checks if parameter is `Array`.
 *
 * @param value  Input value
 * @return Is Array?
 */
function isArray(value) {
    return Array.isArray(value);
}
/**
 * ============================================================================
 * STATIC CONSTANTS
 * ============================================================================
 * @hidden
 */
/**
 * @ignore Exclude from docs
 */
const PLACEHOLDER = "__§§§__";
/**
 * @ignore Exclude from docs
 */
const PLACEHOLDER2 = "__§§§§__";
//# sourceMappingURL=Type.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/core/util/Utils.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/core/util/Utils.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   StyleRule: () => (/* binding */ StyleRule),
/* harmony export */   StyleSheet: () => (/* binding */ StyleSheet),
/* harmony export */   addClass: () => (/* binding */ addClass),
/* harmony export */   addEventListener: () => (/* binding */ addEventListener),
/* harmony export */   addSpacing: () => (/* binding */ addSpacing),
/* harmony export */   alternativeColor: () => (/* binding */ alternativeColor),
/* harmony export */   blur: () => (/* binding */ blur),
/* harmony export */   brighten: () => (/* binding */ brighten),
/* harmony export */   capitalizeFirst: () => (/* binding */ capitalizeFirst),
/* harmony export */   cleanFormat: () => (/* binding */ cleanFormat),
/* harmony export */   contains: () => (/* binding */ contains),
/* harmony export */   decimalPlaces: () => (/* binding */ decimalPlaces),
/* harmony export */   escapeForRgex: () => (/* binding */ escapeForRgex),
/* harmony export */   focus: () => (/* binding */ focus),
/* harmony export */   get12Hours: () => (/* binding */ get12Hours),
/* harmony export */   getBrightnessStep: () => (/* binding */ getBrightnessStep),
/* harmony export */   getDayFromWeek: () => (/* binding */ getDayFromWeek),
/* harmony export */   getEventTarget: () => (/* binding */ getEventTarget),
/* harmony export */   getFormat: () => (/* binding */ getFormat),
/* harmony export */   getLightnessStep: () => (/* binding */ getLightnessStep),
/* harmony export */   getMonthWeek: () => (/* binding */ getMonthWeek),
/* harmony export */   getPointerId: () => (/* binding */ getPointerId),
/* harmony export */   getRendererEvent: () => (/* binding */ getRendererEvent),
/* harmony export */   getSafeResolution: () => (/* binding */ getSafeResolution),
/* harmony export */   getShadowRoot: () => (/* binding */ getShadowRoot),
/* harmony export */   getStyle: () => (/* binding */ getStyle),
/* harmony export */   getTimeZone: () => (/* binding */ getTimeZone),
/* harmony export */   getTimezoneOffset: () => (/* binding */ getTimezoneOffset),
/* harmony export */   getWeek: () => (/* binding */ getWeek),
/* harmony export */   getWeekYear: () => (/* binding */ getWeekYear),
/* harmony export */   getYearDay: () => (/* binding */ getYearDay),
/* harmony export */   hslToRgb: () => (/* binding */ hslToRgb),
/* harmony export */   iOS: () => (/* binding */ iOS),
/* harmony export */   isLight: () => (/* binding */ isLight),
/* harmony export */   isLocalEvent: () => (/* binding */ isLocalEvent),
/* harmony export */   isTouchEvent: () => (/* binding */ isTouchEvent),
/* harmony export */   lighten: () => (/* binding */ lighten),
/* harmony export */   mergeTags: () => (/* binding */ mergeTags),
/* harmony export */   onZoom: () => (/* binding */ onZoom),
/* harmony export */   padString: () => (/* binding */ padString),
/* harmony export */   plainText: () => (/* binding */ plainText),
/* harmony export */   ready: () => (/* binding */ ready),
/* harmony export */   relativeToValue: () => (/* binding */ relativeToValue),
/* harmony export */   removeClass: () => (/* binding */ removeClass),
/* harmony export */   removeElement: () => (/* binding */ removeElement),
/* harmony export */   rgbToHsl: () => (/* binding */ rgbToHsl),
/* harmony export */   sameBounds: () => (/* binding */ sameBounds),
/* harmony export */   saturate: () => (/* binding */ saturate),
/* harmony export */   setInteractive: () => (/* binding */ setInteractive),
/* harmony export */   setStyle: () => (/* binding */ setStyle),
/* harmony export */   stripTags: () => (/* binding */ stripTags),
/* harmony export */   supports: () => (/* binding */ supports),
/* harmony export */   trim: () => (/* binding */ trim),
/* harmony export */   trimLeft: () => (/* binding */ trimLeft),
/* harmony export */   trimRight: () => (/* binding */ trimRight)
/* harmony export */ });
/* harmony import */ var _Type__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Type */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Type.js");
/* harmony import */ var _Array__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Array */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Array.js");
/* harmony import */ var _Object__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Object */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Object.js");
/* harmony import */ var _Disposer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Disposer */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Disposer.js");




/**
 * ============================================================================
 * DOM FUNCTIONS
 * ============================================================================
 * @hidden
 */
/**
 * Execute a function when DOM is ready.
 *
 * @since 5.0.2
 * @param  f  Callback
 */
function ready(f) {
    if (document.readyState !== "loading") {
        f();
    }
    else {
        const listener = () => {
            if (document.readyState !== "loading") {
                document.removeEventListener("readystatechange", listener);
                f();
            }
        };
        document.addEventListener("readystatechange", listener);
    }
}
/**
 * Removes a DOM element.
 * @param  el  Target element
 */
function removeElement(el) {
    if (el.parentNode) {
        el.parentNode.removeChild(el);
    }
}
/**
 * Function that adds a disposable event listener directly to a DOM element.
 *
 * @ignore Exclude from docs
 * @param dom       A DOM element to add event to
 * @param type      Event type
 * @param listener  Event listener
 * @returns Disposable event
 */
function addEventListener(dom, type, listener, options) {
    //@todo proper type check for options: EventListenerOptions | boolean (TS for some reason gives error on passive parameter)
    dom.addEventListener(type, listener, options || false);
    return new _Disposer__WEBPACK_IMPORTED_MODULE_0__.Disposer(() => {
        dom.removeEventListener(type, listener, options || false);
    });
}
/**
 * Function that adds an event listener which is triggered when the browser's zoom changes.
 *
 * @param listener  Event listener
 * @returns Disposable event
 */
function onZoom(listener) {
    // TODO use matchMedia instead ?
    return addEventListener(window, "resize", (_ev) => {
        listener();
    });
}
/**
 * @ignore
 */
function supports(cap) {
    switch (cap) {
        case "touchevents":
            //return "ontouchstart" in document.documentElement;
            return window.hasOwnProperty("TouchEvent");
        case "pointerevents":
            return window.hasOwnProperty("PointerEvent");
        case "mouseevents":
            return window.hasOwnProperty("MouseEvent");
        case "wheelevents":
            return window.hasOwnProperty("WheelEvent");
        case "keyboardevents":
            return window.hasOwnProperty("KeyboardEvent");
    }
    return false;
}
/**
 * @ignore
 */
function getPointerId(event) {
    let id = event.pointerId || 0;
    return id;
}
/**
 * Removes focus from any element by shifting focus to body.
 *
 * @ignore
 */
function blur() {
    if (document.activeElement && document.activeElement != document.body) {
        if (document.activeElement.blur) {
            document.activeElement.blur();
        }
        else {
            let input = document.createElement("button");
            input.style.position = "fixed";
            input.style.top = "0px";
            input.style.left = "-10000px";
            document.body.appendChild(input);
            input.focus();
            input.blur();
            document.body.removeChild(input);
        }
    }
}
/**
 * Focuses element.
 *
 * @ignore
 */
function focus(el) {
    if (el) {
        el.focus();
    }
}
/**
 * @ignore
 */
function getRendererEvent(key) {
    if (supports("pointerevents")) {
        return key;
    }
    else if (supports("touchevents")) {
        switch (key) {
            case "pointerover": return "touchstart";
            case "pointerout": return "touchend";
            case "pointerleave": return "touchend";
            case "pointerdown": return "touchstart";
            case "pointermove": return "touchmove";
            case "pointerup": return "touchend";
            case "click": return "click";
            case "dblclick": return "dblclick";
        }
    }
    else if (supports("mouseevents")) {
        switch (key) {
            case "pointerover": return "mouseover";
            case "pointerout": return "mouseout";
            case "pointerleave": return "mouseleave";
            case "pointerdown": return "mousedown";
            case "pointermove": return "mousemove";
            case "pointerup": return "mouseup";
            case "click": return "click";
            case "dblclick": return "dblclick";
        }
    }
    return key;
}
/**
 * Determines if pointer event originated from a touch pointer or mouse.
 *
 * @param ev  Original event
 * @return Touch pointer?
 */
function isTouchEvent(ev) {
    if (typeof Touch !== "undefined" && ev instanceof Touch) {
        return true;
    }
    else if (typeof PointerEvent !== "undefined" && ev instanceof PointerEvent && ev.pointerType != null) {
        switch (ev.pointerType) {
            case "touch":
            case "pen":
            case 2:
                return true;
            case "mouse":
            case 4:
                return false;
            default:
                return !(ev instanceof MouseEvent);
        }
    }
    else if (ev.type != null) {
        if (ev.type.match(/^mouse/)) {
            return false;
        }
    }
    return true;
}
/**
 * Sets style property on DOM element.
 *
 * @ignore Exclude from docs
 */
function setStyle(dom, property, value) {
    dom.style[property] = value;
}
function getStyle(dom, property) {
    return dom.style[property];
}
/**
 * Gets the target of the event, works for shadow DOM too.
 */
function getEventTarget(event) {
    if (event.composedPath) {
        const path = event.composedPath();
        if (path.length === 0) {
            return null;
        }
        else {
            return path[0];
        }
    }
    else {
        return event.target;
    }
}
/**
 * Checks of element `a` contains element `b`.
 *
 * @param a  Aleged ascendant
 * @param b  Aleged descendant
 * @return Contains?
 */
function contains(a, b) {
    let cursor = b;
    while (true) {
        if (a === cursor) {
            return true;
        }
        else if (cursor.parentNode === null) {
            // TODO better ShadowRoot detection
            if (cursor.host == null) {
                return false;
            }
            else {
                cursor = cursor.host;
            }
        }
        else {
            cursor = cursor.parentNode;
        }
    }
}
/**
 * Returns `true` if pointer event originated on an element within Root.
 *
 * @since 5.2.8
 * @param  event   Event
 * @param  target  Target element
 */
function isLocalEvent(event, target) {
    return event.target && contains(target.root.dom, event.target);
}
/**
 * Disables or enables interactivity of a DOM element.
 *
 * @param  target       Target element
 * @param  interactive  Interactive?
 */
function setInteractive(target, interactive) {
    if (interactive) {
        target.style.pointerEvents = "auto";
    }
    else {
        target.style.pointerEvents = "none";
    }
}
/**
 * Returns the shadow root of the element or null
 *
 * @param a  Node
 * @return Root
 */
function getShadowRoot(a) {
    let cursor = a;
    while (true) {
        if (cursor.parentNode === null) {
            // TODO better ShadowRoot detection
            if (cursor.host != null) {
                return cursor;
            }
            else {
                return null;
            }
        }
        else {
            cursor = cursor.parentNode;
        }
    }
}
/**
 * [rootStylesheet description]
 *
 * @ignore Exclude from docs
 * @todo Description
 */
let rootStylesheet;
/**
 * @ignore Exclude from docs
 */
function createStylesheet(element, text, nonce = "") {
    // TODO use createElementNS ?
    const e = document.createElement("style");
    e.type = "text/css";
    if (nonce != "") {
        e.setAttribute("nonce", nonce);
    }
    e.textContent = text;
    if (element === null) {
        document.head.appendChild(e);
    }
    else {
        element.appendChild(e);
    }
    return e;
}
/**
 * [getStylesheet description]
 *
 * @ignore Exclude from docs
 * @todo Description
 * @return [description]
 */
function getStylesheet(element, nonce = "") {
    if (element === null) {
        if (rootStylesheet == null) {
            // TODO use createElementNS ?
            const e = document.createElement("style");
            e.type = "text/css";
            if (nonce != "") {
                e.setAttribute("nonce", nonce);
            }
            document.head.appendChild(e);
            rootStylesheet = e.sheet;
        }
        return rootStylesheet;
    }
    else {
        // TODO use createElementNS ?
        const e = document.createElement("style");
        e.type = "text/css";
        if (nonce != "") {
            e.setAttribute("nonce", nonce);
        }
        element.appendChild(e);
        return e.sheet;
    }
}
/**
 * [makeStylesheet description]
 *
 * @ignore Exclude from docs
 * @todo Description
 * @param selector  [description]
 * @return [description]
 */
function appendStylesheet(root, selector) {
    const index = root.cssRules.length;
    root.insertRule(selector + "{}", index);
    return root.cssRules[index];
}
/**
 * Defines a class for a CSS rule.
 *
 * Can be used to dynamically add CSS to the document.
 */
class StyleRule extends _Disposer__WEBPACK_IMPORTED_MODULE_0__.DisposerClass {
    /**
     * Constructor.
     *
     * @param selector  CSS selector
     * @param styles    An object of style attribute - value pairs
     */
    constructor(element, selector, styles, nonce = "") {
        super();
        Object.defineProperty(this, "_root", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /**
         * CSS rule.
         */
        Object.defineProperty(this, "_rule", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this._root = getStylesheet(element, nonce);
        try {
            this._rule = appendStylesheet(this._root, selector);
            _Object__WEBPACK_IMPORTED_MODULE_1__.each(styles, (key, value) => {
                this.setStyle(key, value);
            });
        }
        catch (err) {
            // Create an empty rule on failed selectors
            this._rule = new CSSStyleRule();
        }
    }
    /**
     * A CSS selector text.
     *
     * E.g.: `.myClass p`
     *
     * @param selector  CSS selector
     */
    set selector(selector) {
        this._rule.selectorText = selector;
    }
    /**
     * @return CSS selector
     */
    get selector() {
        return this._rule.selectorText;
    }
    // TODO test this
    _dispose() {
        // TODO a bit hacky
        const index = _Array__WEBPACK_IMPORTED_MODULE_2__.indexOf(this._root.cssRules, this._rule);
        if (index === -1) {
            throw new Error("Could not dispose StyleRule");
        }
        else {
            // TODO if it's empty remove it from the DOM ?
            this._root.deleteRule(index);
        }
    }
    /**
     * Sets the same style properties with browser-specific prefixes.
     *
     * @param name   Attribute name
     * @param value  Attribute value
     */
    _setVendorPrefixName(name, value) {
        const style = this._rule.style;
        style.setProperty("-webkit-" + name, value, "");
        style.setProperty("-moz-" + name, value, "");
        style.setProperty("-ms-" + name, value, "");
        style.setProperty("-o-" + name, value, "");
        style.setProperty(name, value, "");
    }
    /**
     * Sets a value for specific style attribute.
     *
     * @param name   Attribute
     * @param value  Value
     */
    setStyle(name, value) {
        if (name === "transition") {
            this._setVendorPrefixName(name, value);
        }
        else {
            this._rule.style.setProperty(name, value, "");
        }
    }
}
/**
 * Defines a class for an entire CSS style sheet.
 *
 * Can be used to dynamically add CSS to the document.
 */
class StyleSheet extends _Disposer__WEBPACK_IMPORTED_MODULE_0__.DisposerClass {
    /**
     * Constructor.
     *
     * @param text  CSS stylesheet
     */
    constructor(element, text, nonce = "") {
        super();
        Object.defineProperty(this, "_element", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this._element = createStylesheet(element, text, nonce);
    }
    _dispose() {
        if (this._element.parentNode) {
            this._element.parentNode.removeChild(this._element);
        }
    }
}
/**
 * Adds a class name to an HTML or SVG element.
 *
 * @ignore Exclude from docs
 * @param element    Element
 * @param className  Class name to add
 */
function addClass(element, className) {
    if (!element) {
        return;
    }
    if (element.classList) {
        const classes = className.split(" ");
        _Array__WEBPACK_IMPORTED_MODULE_2__.each(classes, (name) => {
            element.classList.add(name);
        });
    }
    else {
        let currentClassName = element.getAttribute("class");
        if (currentClassName) {
            element.setAttribute("class", currentClassName.split(" ").filter((item) => {
                return item !== className;
            }).join(" ") + " " + className);
        }
        else {
            element.setAttribute("class", className);
        }
    }
}
/**
 * Removes a class name from an HTML or SVG element.
 *
 * @ignore Exclude from docs
 * @param element    Element
 * @param className  Class name to add
 */
function removeClass(element, className) {
    if (!element) {
        return;
    }
    if (element.classList) {
        element.classList.remove(className);
    }
    else {
        let currentClassName = element.getAttribute("class");
        if (currentClassName) {
            element.setAttribute("class", currentClassName.split(" ").filter((item) => {
                return item !== className;
            }).join(" "));
        }
    }
}
// /**
//  * Applies a set of styles to an element. Stores the original styles so they
//  * can be restored later.
//  *
//  * @ignore
//  * @param io      Element
//   */
// export function prepElementForDrag(dom: HTMLElement): void {
// 	// @todo: save current values
// 	// Define possible props
// 	let props = [
// 		"touchAction", "webkitTouchAction", "MozTouchAction", "MSTouchAction", "msTouchAction", "oTouchAction",
// 		"userSelect", "webkitUserSelect", "MozUserSelect", "MSUserSelect", "msUserSelect", "oUserSelect",
// 		"touchSelect", "webkitTouchSelect", "MozTouchSelect", "MSTouchSelect", "msTouchSelect", "oTouchSelect",
// 		"touchCallout", "webkitTouchCallout", "MozTouchCallout", "MSTouchCallout", "msTouchCallout", "oTouchCallout",
// 		"contentZooming", "webkitContentZooming", "MozContentZooming", "MSContentZooming", "msContentZooming", "oContentZooming",
// 		"userDrag", "webkitUserDrag", "MozUserDrag", "MSUserDrag", "msUserDrag", "oUserDrag"
// 	];
// 	for (let i = 0; i < props.length; i++) {
// 		if (props[i] in dom.style) {
// 			setStyle(dom, props[i], "none");
// 		}
// 	}
// 	// Remove iOS-specific selection;
// 	setStyle(dom, "tapHighlightColor", "rgba(0, 0, 0, 0)");
// }
// /**
//  * Restores replaced styles
//  *
//  * @ignore
//  * @param  io  Element
//  */
// export function unprepElementForDrag(dom: HTMLElement): void {
// 	// Define possible props
// 	let props = [
// 		"touchAction", "webkitTouchAction", "MozTouchAction", "MSTouchAction", "msTouchAction", "oTouchAction",
// 		"userSelect", "webkitUserSelect", "MozUserSelect", "MSUserSelect", "msUserSelect", "oUserSelect",
// 		"touchSelect", "webkitTouchSelect", "MozTouchSelect", "MSTouchSelect", "msTouchSelect", "oTouchSelect",
// 		"touchCallout", "webkitTouchCallout", "MozTouchCallout", "MSTouchCallout", "msTouchCallout", "oTouchCallout",
// 		"contentZooming", "webkitContentZooming", "MozContentZooming", "MSContentZooming", "msContentZooming", "oContentZooming",
// 		"userDrag", "webkitUserDrag", "MozUserDrag", "MSUserDrag", "msUserDrag", "oUserDrag"
// 	];
// 	for (let i = 0; i < props.length; i++) {
// 		if (props[i] in dom.style) {
// 			setStyle(dom, props[i], "");
// 		}
// 	}
// 	// Remove iOS-specific selection;
// 	setStyle(dom, "tapHighlightColor", "");
// }
function iOS() {
    return /apple/i.test(navigator.vendor) && "ontouchend" in document;
}
function getSafeResolution() {
    return iOS() ? 1 : undefined;
}
function relativeToValue(percent, full) {
    if (_Type__WEBPACK_IMPORTED_MODULE_3__.isNumber(percent)) {
        return percent;
    }
    else if (percent != null && _Type__WEBPACK_IMPORTED_MODULE_3__.isNumber(percent.value) && _Type__WEBPACK_IMPORTED_MODULE_3__.isNumber(full)) {
        return full * percent.value;
    }
    else {
        return 0;
    }
}
/**
 * Returns number of decimals
 *
 * @ignore Exclude from docs
 * @param number  Input number
 * @return Number of decimals
 */
function decimalPlaces(number) {
    let match = ('' + number).match(/(?:\.(\d+))?(?:[eE]([+-]?\d+))?$/);
    if (!match) {
        return 0;
    }
    return Math.max(0, (match[1] ? match[1].length : 0) - (match[2] ? +match[2] : 0));
}
/**
 * ============================================================================
 * STRING FORMATTING FUNCTIONS
 * ============================================================================
 * @hidden
 */
/**
 * Pads a string with additional characters to certain length.
 *
 * @param value  A numeric value
 * @param len    Result string length in characters
 * @param char   A character to use for padding
 * @return Padded value as string
 */
function padString(value, len = 0, char = "0") {
    if (typeof value !== "string") {
        value = value.toString();
    }
    return len > value.length ? Array(len - value.length + 1).join(char) + value : value;
}
function trimLeft(text) {
    return text.replace(/^[\s]*/, "");
}
function trimRight(text) {
    return text.replace(/[\s]*$/, "");
}
function trim(text) {
    return trimLeft(trimRight(text));
}
/**
 * Tries to determine format type.
 *
 * @ignore Exclude from docs
 * @param format  Format string
 * @return Format type ("string" | "number" | "date" | "duration")
 */
function getFormat(format) {
    // Undefined?
    if (typeof format === "undefined") {
        return "string";
    }
    // Cleanup and lowercase format
    format = format.toLowerCase().replace(/^\[[^\]]*\]/, "");
    // Remove style tags
    format = format.replace(/\[[^\]]+\]/, "");
    // Trim
    format = format.trim();
    // Check for any explicit format hints (i.e. /Date)
    let hints = format.match(/\/(date|number|duration)$/);
    if (hints) {
        return hints[1];
    }
    // Check for explicit hints
    if (format === "number") {
        return "number";
    }
    if (format === "date") {
        return "date";
    }
    if (format === "duration") {
        return "duration";
    }
    // Detect number formatting symbols
    if (format.match(/[#0]/)) {
        return "number";
    }
    // Detect date formatting symbols
    if (format.match(/[ymwdhnsqaxkzgtei]/)) {
        return "date";
    }
    // Nothing? Let's display as string
    return "string";
}
/**
 * Cleans up format:
 * * Strips out formatter hints
 *
 * @ignore Exclude from docs
 * @param format  Format
 * @return Cleaned format
 */
function cleanFormat(format) {
    return format.replace(/\/(date|number|duration)$/i, "");
}
/**
 * Strips all tags from the string.
 *
 * @param text  Source string
 * @return String without tags
 */
function stripTags(text) {
    return text ? text.replace(/<[^>]*>/g, "") : text;
}
/**
 * Removes new lines and tags from a string.
 *
 * @param text  String to conver
 * @return Converted string
 */
function plainText(text) {
    return text ? stripTags(("" + text).replace(/[\n\r]+/g, ". ")) : text;
}
/**
 * Escapes string so it can safely be used in a Regex.
 *
 * @param value  Unsescaped string
 * @return Escaped string
 */
function escapeForRgex(value) {
    return value.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&');
}
/**
 * Adds space before each uppercase letter.
 *
 * @param   str Input string
 * @return      Output string
 */
function addSpacing(str) {
    let result = "";
    for (let i = 0; i < str.length; i++) {
        const char = str.charAt(i);
        if (char.toUpperCase() == char && i != 0) {
            result += " ";
        }
        result += char;
    }
    return result;
}
/**
 * ============================================================================
 * DATE-RELATED FUNCTIONS
 * ============================================================================
 * @hidden
 */
/**
 * Returns a year day.
 *
 * @param date  Date
 * @param utc   Assume UTC dates?
 * @return Year day
 * @todo Account for UTC
 */
function getYearDay(date, utc = false) {
    // TODO: utc needed?
    utc;
    const start = new Date(date.getFullYear(), 0, 0);
    const diff = (date.getTime() - start.getTime()) + ((start.getTimezoneOffset() - date.getTimezoneOffset()) * 60 * 1000);
    const oneDay = 1000 * 60 * 60 * 24;
    return Math.floor(diff / oneDay);
}
/**
 * Returns week number for a given date.
 *
 * @param date  Date
 * @param utc   Assume UTC dates?
 * @return Week number
 * @todo Account for UTC
 */
function getWeek(date, _utc = false) {
    const d = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate()));
    const day = d.getUTCDay() || 7;
    d.setUTCDate(d.getUTCDate() + 4 - day);
    const firstDay = new Date(Date.UTC(d.getUTCFullYear(), 0, 1));
    return Math.ceil((((d.getTime() - firstDay.getTime()) / 86400000) + 1) / 7);
}
/**
 * Returns a "week year" of the given date.
 *
 * @param date  Date
 * @param utc   Assume UTC dates?
 * @return Year of week
 * @since 5.3.0
 * @todo Account for UTC
 */
function getWeekYear(date, _utc = false) {
    const d = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate()));
    const day = d.getUTCDay() || 7;
    d.setUTCDate(d.getUTCDate() + 4 - day);
    const firstDay = new Date(Date.UTC(d.getUTCFullYear(), 0, 1));
    return firstDay.getFullYear();
}
/**
 * Returns a week number in the month.
 *
 * @param date  Source Date
 * @param utc   Assume UTC dates?
 * @return Week number in month
 */
function getMonthWeek(date, utc = false) {
    const firstWeek = getWeek(new Date(date.getFullYear(), date.getMonth(), 1), utc);
    let currentWeek = getWeek(date, utc);
    if (currentWeek == 1) {
        currentWeek = 53;
    }
    return currentWeek - firstWeek + 1;
}
/**
 * Returns a year day out of the given week number.
 *
 * @param week     Week
 * @param year     Year
 * @param weekday  Weekday
 * @param utc      Assume UTC dates
 * @return Day in a year
 */
function getDayFromWeek(week, year, weekday = 1, utc = false) {
    let date = new Date(year, 0, 4, 0, 0, 0, 0);
    if (utc) {
        date.setUTCFullYear(year);
    }
    let day = week * 7 + weekday - ((date.getDay() || 7) + 3);
    return day;
}
/**
 * Returns 12-hour representation out of the 24-hour hours.
 *
 * @param hours  24-hour number
 * @return 12-hour number
 */
function get12Hours(hours, base) {
    if (hours > 12) {
        hours -= 12;
    }
    else if (hours === 0) {
        hours = 12;
    }
    return base != null ? hours + (base - 1) : hours;
}
/**
 * Returns a string name of the time zone.
 *
 * @param date     Date object
 * @param long     Should return long ("Pacific Standard Time") or short abbreviation ("PST")
 * @param savings  Include information if it's in daylight savings mode
 * @param utc      Assume UTC dates
 * @return Time zone name
 */
function getTimeZone(date, long = false, savings = false, utc = false, timezone) {
    if (utc) {
        return long ? "Coordinated Universal Time" : "UTC";
    }
    else if (timezone) {
        const d1 = date.toLocaleString("en-US", { timeZone: timezone });
        const d2 = date.toLocaleString("en-US", { timeZone: timezone, timeZoneName: long ? "long" : "short" });
        return trim(d2.substr(d1.length));
    }
    let wotz = date.toLocaleString("UTC");
    let wtz = date.toLocaleString("UTC", { timeZoneName: long ? "long" : "short" }).substr(wotz.length);
    //wtz = wtz.replace(/[+-]+[0-9]+$/, "");
    if (savings === false) {
        wtz = wtz.replace(/ (standard|daylight|summer|winter) /i, " ");
    }
    return trim(wtz);
}
function getTimezoneOffset(timezone) {
    const date = new Date(Date.UTC(2012, 0, 1, 0, 0, 0, 0));
    const utcDate = new Date(date.toLocaleString("en-US", { timeZone: "UTC" }));
    const tzDate = new Date(date.toLocaleString("en-US", { timeZone: timezone }));
    return (tzDate.getTime() - utcDate.getTime()) / 6e4 * -1;
}
function capitalizeFirst(text) {
    return text.charAt(0).toUpperCase() + text.slice(1);
}
/**
 * The functions below are taken and adapted from Garry Tan's blog post:
 * http://axonflux.com/handy-rgb-to-hsl-and-rgb-to-hsv-color-model-c
 *
 * The further attributions go mjijackson.com, which now seems to be defunct.
 */
/**
 * Converts an HSL color value to RGB. Conversion formula
 * adapted from http://en.wikipedia.org/wiki/HSL_color_space.
 * Assumes h, s, and l are contained in the set [0, 1] and
 * returns r, g, and b in the set [0, 255].
 *
 * Function adapted from:
 * http://axonflux.com/handy-rgb-to-hsl-and-rgb-to-hsv-color-model-c
 *
 * @ignore Exclude from docs
 * @param h       The hue
 * @param s       The saturation
 * @param l       The lightness
 * @return The RGB representation
 */
function hslToRgb(color) {
    let r, g, b;
    let h = color.h;
    let s = color.s;
    let l = color.l;
    if (s == 0) {
        r = g = b = l; // achromatic
    }
    else {
        let hue2rgb = function hue2rgb(p, q, t) {
            if (t < 0) {
                t += 1;
            }
            if (t > 1) {
                t -= 1;
            }
            if (t < 1 / 6) {
                return p + (q - p) * 6 * t;
            }
            if (t < 1 / 2) {
                return q;
            }
            if (t < 2 / 3) {
                return p + (q - p) * (2 / 3 - t) * 6;
            }
            return p;
        };
        let q = l < 0.5 ? l * (1 + s) : l + s - l * s;
        let p = 2 * l - q;
        r = hue2rgb(p, q, h + 1 / 3);
        g = hue2rgb(p, q, h);
        b = hue2rgb(p, q, h - 1 / 3);
    }
    return {
        r: Math.round(r * 255),
        g: Math.round(g * 255),
        b: Math.round(b * 255)
    };
}
/**
 * Converts an RGB color value to HSL. Conversion formula
 * adapted from http://en.wikipedia.org/wiki/HSL_color_space.
 * Assumes r, g, and b are contained in the set [0, 255] and
 * returns h, s, and l in the set [0, 1].
 *
 * Function adapted from:
 * http://axonflux.com/handy-rgb-to-hsl-and-rgb-to-hsv-color-model-c
 *
 * @ignore Exclude from docs
 * @param r       The red color value
 * @param g       The green color value
 * @param b       The blue color value
 * @return The HSL representation
 */
function rgbToHsl(color) {
    let r = color.r / 255;
    let g = color.g / 255;
    let b = color.b / 255;
    let max = Math.max(r, g, b);
    let min = Math.min(r, g, b);
    let h = 0;
    let s = 0;
    let l = (max + min) / 2;
    if (max === min) {
        h = s = 0; // achromatic
    }
    else {
        let d = max - min;
        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
        switch (max) {
            case r:
                h = (g - b) / d + (g < b ? 6 : 0);
                break;
            case g:
                h = (b - r) / d + 2;
                break;
            case b:
                h = (r - g) / d + 4;
                break;
        }
        h /= 6;
    }
    return {
        h: h,
        s: s,
        l: l
    };
}
/**
 * Returns a color that is `percent` brighter than the reference color.
 *
 * @ignore Exclude from docs
 * @param color    Reference color
 * @param percent  Brightness percent
 * @return Hex code of the new color
 */
function lighten(rgb, percent) {
    if (rgb) {
        return {
            r: Math.max(0, Math.min(255, rgb.r + getLightnessStep(rgb.r, percent))),
            g: Math.max(0, Math.min(255, rgb.g + getLightnessStep(rgb.g, percent))),
            b: Math.max(0, Math.min(255, rgb.b + getLightnessStep(rgb.b, percent))),
            a: rgb.a
        };
    }
    else {
        // TODO is this correct ?
        return rgb;
    }
}
;
/**
 * Gets lightness step.
 *
 * @ignore Exclude from docs
 * @param value    Value
 * @param percent  Percent
 * @return Step
 */
function getLightnessStep(value, percent) {
    let base = percent > 0 ? 255 - value : value;
    return Math.round(base * percent);
}
/**
 * Returns a color that is `percent` brighter than the source `color`.
 *
 * @ignore Exclude from docs
 * @param color    Source color
 * @param percent  Brightness percent
 * @return New color
 */
function brighten(rgb, percent) {
    if (rgb) {
        let base = Math.min(Math.max(rgb.r, rgb.g, rgb.b), 230);
        //let base = Math.max(rgb.r, rgb.g, rgb.b);
        let step = getLightnessStep(base, percent);
        return {
            r: Math.max(0, Math.min(255, Math.round(rgb.r + step))),
            g: Math.max(0, Math.min(255, Math.round(rgb.g + step))),
            b: Math.max(0, Math.min(255, Math.round(rgb.b + step))),
            a: rgb.a
        };
    }
    else {
        // TODO is this correct ?
        return rgb;
    }
}
;
/**
 * Returns brightness step.
 *
 * @ignore Exclude from docs
 * @param value    Value
 * @param percent  Percent
 * @return Step
 */
function getBrightnessStep(_value, percent) {
    let base = 255; //percent > 0 ? 255 - value : value;
    return Math.round(base * percent);
}
/**
 * Returns `true` if color is "light". Useful indetermining which contrasting
 * color to use for elements over this color. E.g.: you would want to use
 * black text over light background, and vice versa.
 *
 * @ignore Exclude from docs
 * @param color  Source color
 * @return Light?
 */
function isLight(color) {
    return ((color.r * 299) + (color.g * 587) + (color.b * 114)) / 1000 >= 128;
}
/**
 * Returns a new [[iRGB]] object based on `rgb` parameter with specific
 * saturation applied.
 *
 * `saturation` can be in the range of 0 (fully desaturated) to 1 (fully
 * saturated).
 *
 * @ignore Exclude from docs
 * @param color       Base color
 * @param saturation  Saturation (0-1)
 * @return New color
 */
function saturate(rgb, saturation) {
    if (rgb === undefined || saturation == 1) {
        return rgb;
    }
    let hsl = rgbToHsl(rgb);
    hsl.s = saturation;
    return hslToRgb(hsl);
}
function alternativeColor(color, lightAlternative = { r: 255, g: 255, b: 255 }, darkAlternative = { r: 255, g: 255, b: 255 }) {
    let light = lightAlternative;
    let dark = darkAlternative;
    if (isLight(darkAlternative)) {
        light = darkAlternative;
        dark = lightAlternative;
    }
    return isLight(color) ? dark : light;
}
/**
 * @ignore
 * @deprecated
 */
// export function unshiftThemeClass(settings: any, themeClass: string) {
// 	let themeClasses = settings.themeClasses;
// 	if (!themeClasses) {
// 		themeClasses = [];
// 	}
// 	themeClasses.unshift(themeClass);
// 	settings.themeClasses = themeClasses;
// }
/**
 * @ignore
 * @deprecated
 */
// export function pushThemeClass(settings: any, themeClass: string) {
// 	let themeClasses = settings.themeClasses;
// 	if (!themeClasses) {
// 		themeClasses = [];
// 	}
// 	themeClasses.push(themeClass);
// 	settings.themeClasses = themeClasses;
// }
/**
 * @ignore
 */
function mergeTags(tags1, tags2) {
    if (!tags1) {
        tags1 = [];
    }
    return [...tags1, ...tags2].filter((value, index, self) => {
        return self.indexOf(value) === index;
    });
}
/**
 * @ignore
 */
function sameBounds(a, b) {
    if (!b) {
        return false;
    }
    if (a.left != b.left) {
        return false;
    }
    if (a.right != b.right) {
        return false;
    }
    if (a.top != b.top) {
        return false;
    }
    if (a.bottom != b.bottom) {
        return false;
    }
    return true;
}
//# sourceMappingURL=Utils.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/plugins/exporting/Exporting.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/plugins/exporting/Exporting.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Exporting: () => (/* binding */ Exporting)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.mjs");
/* harmony import */ var _core_util_Entity__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../core/util/Entity */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Entity.js");
/* harmony import */ var _core_util_Color__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../core/util/Color */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Color.js");
/* harmony import */ var _core_Root__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../core/Root */ "./node_modules/@amcharts/amcharts5/.internal/core/Root.js");
/* harmony import */ var _core_util_Utils__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../core/util/Utils */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Utils.js");
/* harmony import */ var _core_util_Array__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../core/util/Array */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Array.js");
/* harmony import */ var _core_util_Object__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../core/util/Object */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Object.js");
/* harmony import */ var _core_util_Type__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../core/util/Type */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Type.js");









/**
 * This is used to cache the pdfmake loading.
 *
 * @ignore
 */
let pdfmakePromise;
/**
 * Loads pdfmake dynamic module
 *
 * This is an asynchronous function. Check the description of `getImage()`
 * for description and example usage.
 *
 * @ignore
 */
function _pdfmake() {
    return (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__awaiter)(this, void 0, void 0, function* () {
        let a = yield Promise.all([
            __webpack_require__.e(/*! import() | pdfmake */ "pdfmake").then(__webpack_require__.t.bind(__webpack_require__, /*! pdfmake/build/pdfmake.js */ "./node_modules/pdfmake/build/pdfmake.js", 23)),
            __webpack_require__.e(/*! import() | pdfmake */ "pdfmake").then(__webpack_require__.bind(__webpack_require__, /*! ./pdfmake/vfs_fonts */ "./node_modules/@amcharts/amcharts5/.internal/plugins/exporting/pdfmake/vfs_fonts.js"))
        ]);
        let pdfmake = a[0].default;
        let vfs_fonts = a[1].default;
        const global = window;
        global.pdfMake = global.pdfMake || {};
        global.pdfMake.vfs = vfs_fonts;
        pdfmake.vfs = vfs_fonts;
        return pdfmake;
    });
}
/**
 * A plugin that can be used to export chart snapshots and data.
 *
 * @see {@link https://www.amcharts.com/docs/v5/concepts/exporting/} for more info
 */
class Exporting extends _core_util_Entity__WEBPACK_IMPORTED_MODULE_1__.Entity {
    //public extraImages: Array<Root | IExportingImageSource> = [];
    //public dataSources: any[] = [];
    _afterNew() {
        super._afterNew();
        this._setRawDefault("filePrefix", "chart");
        this._setRawDefault("charset", "utf-8");
        this._setRawDefault("numericFields", []);
        this._setRawDefault("dateFields", []);
        this._setRawDefault("durationFields", []);
        this._setRawDefault("extraImages", []);
        this._setRawDefault("pngOptions", { quality: 1, maintainPixelRatio: false });
        this._setRawDefault("jpgOptions", { quality: 0.8, maintainPixelRatio: false });
        this._setRawDefault("printOptions", { quality: 1, maintainPixelRatio: false, delay: 500, printMethod: "iframe", imageFormat: "png" });
        this._setRawDefault("jsonOptions", { indent: 2, renameFields: true });
        this._setRawDefault("csvOptions", { separator: ",", addColumnNames: true, emptyAs: "", addBOM: true });
        this._setRawDefault("htmlOptions", { emptyAs: "-", addColumnNames: true });
        this._setRawDefault("xlsxOptions", { emptyAs: "", addColumnNames: true });
        this._setRawDefault("pdfOptions", { fontSize: 14, imageFormat: "png", align: "left", addURL: true });
        this._setRawDefault("pdfdataOptions", { emptyAs: "", addColumnNames: true });
        this._root.addDisposer(this);
    }
    _beforeChanged() {
        super._beforeChanged();
        if (this.isDirty("menu")) {
            const menu = this.get("menu");
            if (menu) {
                menu.set("exporting", this);
                this._disposers.push(menu);
            }
        }
    }
    _getFormatOptions(format, options) {
        const newOptions = _core_util_Object__WEBPACK_IMPORTED_MODULE_2__.copy(this.get(format + "Options", {}));
        if (options) {
            _core_util_Object__WEBPACK_IMPORTED_MODULE_2__.each(options, (key, value) => {
                newOptions[key] = value;
            });
        }
        return newOptions;
    }
    /**
     * Triggers a download of the chart/data in specific format.
     *
     * @param  format         Format
     * @param  customOptions  Format options
     */
    download(format, customOptions) {
        return (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__awaiter)(this, void 0, void 0, function* () {
            const ext = format == "pdfdata" ? "pdf" : format;
            const fileName = this.get("filePrefix", "chart") + "." + ext;
            const options = this._getFormatOptions(format, customOptions);
            this.events.dispatch("downloadstarted", {
                type: "downloadstarted",
                format: format,
                options: options,
                fileName: fileName,
                target: this
            });
            const uri = yield this.export(format, options);
            this.streamFile(uri, fileName, (options && options.addBOM));
        });
    }
    /**
     * Triggers print of the chart.
     *
     * @param  customOptions  Print options
     */
    print(customOptions) {
        return (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__awaiter)(this, void 0, void 0, function* () {
            const options = this._getFormatOptions("print", customOptions);
            this.events.dispatch("printstarted", {
                type: "printstarted",
                format: "print",
                options: options,
                target: this
            });
            const uri = yield this.export(options.imageFormat || "png", options);
            this.initiatePrint(uri, options, this.get("title"));
        });
    }
    /**
     * Returns data uri of the chart/data in specific format.
     *
     * @param          format  Format
     * @param   customOptions  Format options
     * @return                 Promise
     */
    export(format, customOptions) {
        return (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__awaiter)(this, void 0, void 0, function* () {
            const options = this._getFormatOptions(format, customOptions);
            this.events.dispatch("exportstarted", {
                type: "exportstarted",
                format: format,
                options: options,
                target: this
            });
            let promise = "";
            switch (format) {
                case "png":
                case "jpg":
                    this._root._runTickerNow();
                    promise = this.exportImage(format, options);
                    break;
                case "json":
                    promise = this.exportJSON(options);
                    break;
                case "csv":
                    promise = this.exportCSV(options);
                    break;
                case "html":
                    promise = this.exportHTML(options);
                    break;
                case "xlsx":
                    promise = this.exportXLSX(options);
                    break;
                case "pdf":
                    this._root._runTickerNow();
                    promise = this.exportPDF(options);
                    break;
                case "pdfdata":
                    promise = this.exportPDFData(options);
                    break;
            }
            this.events.dispatch("exportfinished", {
                type: "exportfinished",
                format: format,
                options: options,
                target: this
            });
            return promise;
        });
    }
    /**
     * ==========================================================================
     * Images
     * ==========================================================================
     */
    /**
     * Returns chart image as a data:uri.
     *
     * @param   format         Image format
     * @param   customOptions  Format options
     * @return                 Promise
     */
    exportImage(format, customOptions) {
        return (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__awaiter)(this, void 0, void 0, function* () {
            const options = this._getFormatOptions(format, customOptions);
            const canvas = yield this.getCanvas(options);
            const data = canvas.toDataURL(this.getContentType(format), options.quality || 1);
            this.disposeCanvas(canvas);
            return data;
        });
    }
    /**
     * Returns canvas data.
     *
     * @param   customOptions  Image options
     * @return                 Promise
     */
    exportCanvas(customOptions) {
        return (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__awaiter)(this, void 0, void 0, function* () {
            const options = this._getFormatOptions("canvas", customOptions);
            const canvas = yield this.getCanvas(options);
            const data = canvas.toDataURL(this.getContentType("canvas"), options.quality || 1);
            this.disposeCanvas(canvas);
            return data;
        });
    }
    /**
     * Returns a `<canvas>` element with snapshot of the chart.
     *
     * @param   options  Image options
     * @return           Promise
     */
    getCanvas(options) {
        return (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__awaiter)(this, void 0, void 0, function* () {
            const mainCanvas = this._root._renderer.getCanvas(this._root._rootContainer._display, options);
            const extraImages = this.get("extraImages", []);
            // Add other canvases
            let middleLeft = 0;
            let middleTop = 0;
            let middleWidth = mainCanvas.width;
            let middleHeight = mainCanvas.height;
            let extraRight = 0;
            let extraBottom = 0;
            const extras = [];
            _core_util_Array__WEBPACK_IMPORTED_MODULE_3__.each(extraImages, (extraRoot) => {
                // Get that extra
                let extra;
                if (extraRoot instanceof _core_Root__WEBPACK_IMPORTED_MODULE_4__.Root) {
                    extra = {
                        source: extraRoot,
                        position: "bottom"
                    };
                }
                else {
                    extra = extraRoot;
                }
                // Set defaults
                extra.position = extra.position || "bottom";
                extra.marginTop = extra.marginTop || 0;
                extra.marginRight = extra.marginRight || 0;
                extra.marginBottom = extra.marginBottom || 0;
                extra.marginLeft = extra.marginLeft || 0;
                const extraCanvas = extra.source._renderer.getCanvas(extra.source._rootContainer._display, options);
                const extraWidth = extraCanvas.width + extra.marginLeft + extra.marginRight;
                const extraHeight = extraCanvas.height + extra.marginTop + extra.marginBottom;
                if (extra.position == "top") {
                    middleWidth = extra.crop ? middleHeight : Math.max(middleWidth, extraWidth);
                    middleTop += extraHeight;
                }
                else if (extra.position == "right") {
                    middleHeight = extra.crop ? middleHeight : Math.max(middleHeight, extraHeight);
                    extraRight += extraWidth;
                }
                else if (extra.position == "left") {
                    middleHeight = extra.crop ? middleHeight : Math.max(middleHeight, extraHeight);
                    middleLeft += extraWidth;
                }
                else if (extra.position === "bottom") {
                    middleWidth = extra.crop ? middleHeight : Math.max(middleWidth, extraWidth);
                    extraBottom += extraHeight;
                }
                extras.push({
                    canvas: extraCanvas,
                    position: extra.position,
                    left: extra.marginLeft,
                    top: extra.marginTop,
                    width: extraWidth,
                    height: extraHeight
                });
            });
            const newCanvas = this.getDisposableCanvas();
            newCanvas.width = middleLeft + middleWidth + extraRight;
            newCanvas.height = middleTop + middleHeight + extraBottom;
            const ctx = newCanvas.getContext("2d");
            // Get background
            const background = this.get("backgroundColor", this.findBackgroundColor(this._root.dom));
            const backgroundOpacity = this.get("backgroundOpacity", 1);
            if (background) {
                ctx.fillStyle = background.toCSS(backgroundOpacity);
                ctx.fillRect(0, 0, newCanvas.width, newCanvas.height);
            }
            let left = middleLeft;
            let top = middleTop;
            let right = left + middleWidth;
            let bottom = top + middleHeight;
            // Radiates outwards from center
            _core_util_Array__WEBPACK_IMPORTED_MODULE_3__.each(extras, (extra) => {
                if (extra.position == "top") {
                    top -= extra.height;
                    ctx.drawImage(extra.canvas, middleLeft + extra.left, top + extra.top);
                }
                else if (extra.position == "right") {
                    ctx.drawImage(extra.canvas, right + extra.left, middleTop + extra.top);
                    right += extra.width;
                }
                else if (extra.position == "left") {
                    left -= extra.width;
                    ctx.drawImage(extra.canvas, left + extra.left, middleTop + extra.top);
                }
                else if (extra.position === "bottom") {
                    ctx.drawImage(extra.canvas, middleLeft + extra.left, bottom + extra.top);
                    bottom += extra.height;
                }
                //this.disposeCanvas(extra.canvas);
            });
            ctx.drawImage(mainCanvas, middleLeft, middleTop);
            return newCanvas;
        });
    }
    /**
     * ==========================================================================
     * JSON
     * ==========================================================================
     */
    /**
     * Returns a data:uri representation of a JSON file with chart data.
     *
     * @param   customOptions  Format options
     * @return                 Promise
     */
    exportJSON(customOptions) {
        return (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__awaiter)(this, void 0, void 0, function* () {
            return "data:" + this.getContentType("json") + ";" + this.get("charset", "utf-8") + "," + encodeURIComponent(yield this.getJSON(customOptions));
        });
    }
    /**
     * Returns data in JSON format.
     *
     * @param   customOptions  Format options
     * @return                 Promise
     */
    getJSON(customOptions) {
        return (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__awaiter)(this, void 0, void 0, function* () {
            const options = this._getFormatOptions("json", customOptions);
            return JSON.stringify(this.getData("json", customOptions, options.renameFields), (_key, value) => {
                if (_core_util_Type__WEBPACK_IMPORTED_MODULE_5__.isObject(value)) {
                    _core_util_Object__WEBPACK_IMPORTED_MODULE_2__.each(value, (field, item) => {
                        value[field] = this.convertToSpecialFormat(field, item, options);
                    });
                }
                return value;
            }, options.indent);
        });
    }
    /**
     * ==========================================================================
     * CSV
     * ==========================================================================
     */
    /**
     * Returns a data:uri representation of a CSV file with chart data.
     *
     * @param   customOptions  Format options
     * @return                 Promise
     */
    exportCSV(customOptions) {
        return (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__awaiter)(this, void 0, void 0, function* () {
            return "data:" + this.getContentType("csv") + ";" + this.get("charset", "utf-8") + "," + encodeURIComponent(yield this.getCSV(customOptions));
        });
    }
    /**
     * Returns a CSV with export data.
     *
     * @param   customOptions  CSV options
     * @return                 Promise
     */
    getCSV(customOptions) {
        return (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__awaiter)(this, void 0, void 0, function* () {
            const options = this._getFormatOptions("csv", customOptions);
            // Init output
            let csv = "";
            // Add rows
            let br = "";
            const data = this.getData("csv", options);
            // Data fields
            const dataFields = this.getDataFields(data);
            // Vertical or horizontal (default) layout
            if (options.pivot) {
                // Data fields order
                const dataFieldsOrder = this.get("dataFieldsOrder", []);
                _core_util_Object__WEBPACK_IMPORTED_MODULE_2__.eachOrdered(dataFields, (key, val) => {
                    let dataRow = [];
                    if (options.addColumnNames) {
                        dataRow.push(val);
                    }
                    for (let len = data.length, i = 0; i < len; i++) {
                        let dataValue = data[i][key];
                        dataRow.push(this.convertToSpecialFormat(key, dataValue, options, true));
                    }
                    csv += br + this.getCSVRow(dataRow, options, undefined, true);
                    br = "\n";
                }, (a, b) => {
                    let ai = dataFieldsOrder.indexOf(a);
                    let bi = dataFieldsOrder.indexOf(b);
                    if (ai > bi) {
                        return -1;
                    }
                    else if (ai < bi) {
                        return 1;
                    }
                    return 0;
                });
            }
            else {
                for (let len = data.length, i = 0; i < len; i++) {
                    let row = this.getCSVRow(data[i], options, dataFields);
                    if (options.reverse) {
                        csv = row + br + csv;
                    }
                    else {
                        csv += br + row;
                    }
                    br = "\n";
                }
                // Add column names?
                if (options.addColumnNames) {
                    csv = this.getCSVRow(dataFields, options, undefined, true) + br + csv;
                }
            }
            return csv;
        });
    }
    /**
     * @ignore
     */
    getCSVRow(row, options, dataFields, asIs = false) {
        // Init
        let separator = options.separator || ",";
        let items = [];
        // Data fields
        if (!dataFields) {
            dataFields = {};
            _core_util_Object__WEBPACK_IMPORTED_MODULE_2__.each(row, (key, value) => {
                dataFields[key] = value;
            });
        }
        // Data fields order
        const dataFieldsOrder = this.get("dataFieldsOrder", []);
        // Process each row item
        _core_util_Object__WEBPACK_IMPORTED_MODULE_2__.eachOrdered(dataFields, (key, _name) => {
            // Get value
            let value = this.convertEmptyValue(key, row[key], options);
            // Check if we need to skip
            // This is no longer required because we are iterating via dataFields anyway
            /*if (this.dataFields != null && this.dataFields[key] == null) {
                return;
            }*/
            // Convert dates
            let item = asIs ? value : this.convertToSpecialFormat(key, value, options);
            // Cast and escape doublequotes
            item = "" + item;
            item = item.replace(/"/g, '""');
            // Enclose into double quotes
            if (options.forceQuotes || (item.search(new RegExp("\"|\n|" + separator, "g")) >= 0)) {
                item = "\"" + item + "\"";
            }
            // Add to item
            items.push(item);
        }, (a, b) => {
            let ai = dataFieldsOrder.indexOf(a);
            let bi = dataFieldsOrder.indexOf(b);
            if (ai > bi) {
                return 1;
            }
            else if (ai < bi) {
                return -1;
            }
            return 0;
        });
        return items.join(separator);
    }
    /**
     * ==========================================================================
     * HTML
     * ==========================================================================
     */
    /**
     * Returns a data:uri representation of an HTML file with chart data.
     *
     * @param   customOptions  Format options
     * @return                 Promise
     */
    exportHTML(customOptions) {
        return (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__awaiter)(this, void 0, void 0, function* () {
            return "data:" + this.getContentType("html") + ";" + this.get("charset", "utf-8") + "," + encodeURIComponent(yield this.getHTML(customOptions));
        });
    }
    /**
     * Returns an HTML with a table with export data.
     *
     * @param   customOptions  HTML options
     * @return                 Promise
     */
    getHTML(customOptions) {
        return (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__awaiter)(this, void 0, void 0, function* () {
            const options = this._getFormatOptions("html", customOptions);
            // Init output
            let html = "<table>";
            if (options.tableClass) {
                html = "<table class=\"" + options.tableClass + "\">";
            }
            // Get data
            const data = this.getData("html", options);
            const dataFields = this.getDataFields(data);
            // Vertical or horizontal (default) layout
            if (options.pivot) {
                // Data fields order
                const dataFieldsOrder = this.get("dataFieldsOrder", []);
                html += "\n<tbody>";
                _core_util_Object__WEBPACK_IMPORTED_MODULE_2__.eachOrdered(dataFields, (key, val) => {
                    let dataRow = [];
                    if (options.addColumnNames) {
                        dataRow.push(val);
                    }
                    for (let len = data.length, i = 0; i < len; i++) {
                        let dataValue = data[i][key];
                        dataRow.push(this.convertToSpecialFormat(key, dataValue, options, true));
                    }
                    html += "\n" + this.getHTMLRow(dataRow, options, undefined, true);
                }, (a, b) => {
                    let ai = dataFieldsOrder.indexOf(a);
                    let bi = dataFieldsOrder.indexOf(b);
                    if (ai > bi) {
                        return -1;
                    }
                    else if (ai < bi) {
                        return 1;
                    }
                    return 0;
                });
                html += "\n</tbody>";
            }
            else {
                // Add column names?
                if (options.addColumnNames) {
                    html += "\n<thead>\n" + this.getHTMLRow(dataFields, options, undefined, true, true) + "\n</thead>";
                }
                html += "\n<tbody>";
                for (let len = data.length, i = 0; i < len; i++) {
                    html += "\n" + this.getHTMLRow(data[i], options, dataFields);
                }
                html += "\n</tbody>";
            }
            html += "\n</table>";
            return html;
        });
    }
    /**
     * @ignore
     */
    getHTMLRow(row, options, dataFields, asIs = false, headerRow = false) {
        // Init output
        let html = "\t<tr>";
        if (options.rowClass) {
            html = "\t<tr class=\"" + options.rowClass + "\">";
        }
        // Data fields
        if (!dataFields) {
            dataFields = row;
        }
        // Data fields order
        const dataFieldsOrder = this.get("dataFieldsOrder", []);
        // th or dh?
        const tag = headerRow ? "th" : "td";
        // Process each row item
        let first = true;
        _core_util_Object__WEBPACK_IMPORTED_MODULE_2__.eachOrdered(dataFields, (key, _name) => {
            // Get value
            let value = this.convertEmptyValue(key, row[key], options);
            // Convert dates
            let item = asIs ? value : this.convertToSpecialFormat(key, value, options);
            // Escape HTML entities
            item = "" + item;
            item = item.replace(/[\u00A0-\u9999<>\&]/gim, function (i) {
                return "&#" + i.charCodeAt(0) + ";";
            });
            // Which tag to use
            let useTag = tag;
            if (options.pivot && first) {
                useTag = "th";
            }
            // Add cell
            if (options.cellClass) {
                html += "\n\t\t<" + useTag + " class=\"" + options.cellClass + "\">" + item + "</" + useTag + ">";
            }
            else {
                html += "\n\t\t<" + useTag + ">" + item + "</" + useTag + ">";
            }
            first = false;
        }, (a, b) => {
            let ai = dataFieldsOrder.indexOf(a);
            let bi = dataFieldsOrder.indexOf(b);
            if (ai > bi) {
                return 1;
            }
            else if (ai < bi) {
                return -1;
            }
            return 0;
        });
        html += "\n\t</tr>";
        return html;
    }
    /**
     * ==========================================================================
     * XLSX
     * ==========================================================================
     */
    /**
     * Returns a data:uri representation of an XLSX file with chart data.
     *
     * @param   customOptions  Format options
     * @return                 Promise
     */
    exportXLSX(customOptions) {
        return (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__awaiter)(this, void 0, void 0, function* () {
            return "data:" + this.getContentType("xlsx") + ";" + this.get("charset", "utf-8") + "," + encodeURIComponent(yield this.getXLSX(customOptions));
        });
    }
    /**
     * Returns a data:uri of XLSX data.
     *
     * @param  customOptions  Format options
     * @return                Promise
     */
    getXLSX(customOptions) {
        return (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__awaiter)(this, void 0, void 0, function* () {
            const options = this._getFormatOptions("xlsx", customOptions);
            // Load xlsx
            let XLSX = yield this.getXLSXLib();
            // Create workbook options
            let wbOptions = {
                bookType: "xlsx",
                bookSST: false,
                type: "base64",
                //dateNF: 'yyyy-mm-dd'
            };
            // Get sheet name
            let sheetName = this._normalizeExcelSheetName(this.get("title", this._t("Data")));
            // Create a workbook
            let wb = {
                SheetNames: [sheetName],
                Sheets: {}
            };
            // Init worksheet data
            let wsData = [];
            // Get data
            const data = this.getData("html", options);
            const dataFields = this.getDataFields(data);
            // Vertical or horizontal (default) layout
            if (options.pivot) {
                // Data fields order
                const dataFieldsOrder = this.get("dataFieldsOrder", []);
                _core_util_Object__WEBPACK_IMPORTED_MODULE_2__.eachOrdered(dataFields, (key, val) => {
                    let dataRow = [];
                    if (options.addColumnNames) {
                        dataRow.push(val);
                    }
                    for (let len = data.length, i = 0; i < len; i++) {
                        let dataValue = data[i][key];
                        dataRow.push(this.convertToSpecialFormat(key, dataValue, options, true));
                    }
                    wsData.push(this.getXLSXRow(dataRow, options, undefined, true));
                }, (a, b) => {
                    let ai = dataFieldsOrder.indexOf(a);
                    let bi = dataFieldsOrder.indexOf(b);
                    if (ai > bi) {
                        return 1;
                    }
                    else if (ai < bi) {
                        return -1;
                    }
                    return 0;
                });
            }
            else {
                // Add column names?
                if (options.addColumnNames) {
                    wsData.push(this.getXLSXRow(dataFields, options, undefined, true));
                }
                // Add lines
                for (let len = data.length, i = 0; i < len; i++) {
                    wsData.push(this.getXLSXRow(data[i], options, dataFields));
                }
            }
            // Create sheet and add data
            wb.Sheets[sheetName] = XLSX.utils.aoa_to_sheet(wsData);
            this.events.dispatch("workbookready", {
                type: "workbookready",
                format: "xlsx",
                options: options,
                workbook: wb,
                workbookOptions: wbOptions,
                xlsx: XLSX,
                target: this
            });
            return XLSX.write(wb, wbOptions);
        });
    }
    _normalizeExcelSheetName(name) {
        name = name.replace(/([:\\\/?*\[\]]+)/g, " ");
        return name.length > 30 ? name.substr(0, 30) + "..." : name;
    }
    /**
     * @ignore
     */
    getXLSXRow(row, options, dataFields, asIs = false) {
        // Init
        let items = [];
        // Data fields
        if (!dataFields) {
            dataFields = row;
        }
        // Data fields order
        const dataFieldsOrder = this.get("dataFieldsOrder", []);
        // Process each row item
        _core_util_Object__WEBPACK_IMPORTED_MODULE_2__.eachOrdered(dataFields, (key, _name) => {
            // Get value
            let value = this.convertEmptyValue(key, row[key], options);
            // Convert dates
            let item = asIs ? value : this.convertToSpecialFormat(key, value, options, true);
            items.push(item);
        }, (a, b) => {
            let ai = dataFieldsOrder.indexOf(a);
            let bi = dataFieldsOrder.indexOf(b);
            if (ai > bi) {
                return 1;
            }
            else if (ai < bi) {
                return -1;
            }
            return 0;
        });
        return items;
    }
    /**
     * @ignore
     */
    _xlsx() {
        return (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__awaiter)(this, void 0, void 0, function* () {
            return yield __webpack_require__.e(/*! import() | xlsx */ "xlsx").then(__webpack_require__.bind(__webpack_require__, /*! ../../bundled/xlsx */ "./node_modules/@amcharts/amcharts5/.internal/bundled/xlsx/xlsx.mjs"));
        });
    }
    /**
     * @ignore
     */
    getXLSXLib() {
        return this._xlsx();
    }
    /**
     * ==========================================================================
     * PDF
     * ==========================================================================
     */
    /**
     * Returns a data:uri representation of a PDF file with chart image.
     *
     * @param   customOptions  Format options
     * @return                 Promise
     */
    exportPDF(customOptions) {
        return (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__awaiter)(this, void 0, void 0, function* () {
            return "data:" + this.getContentType("pdf") + ";" + this.get("charset", "utf-8") + "," + encodeURIComponent(yield this.getPDF(customOptions, true));
        });
    }
    /**
     * Returns a data:uri representation of a PDF file with chart data.
     *
     * @param   customOptions  Format options
     * @return                 Promise
     */
    exportPDFData(customOptions) {
        return (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__awaiter)(this, void 0, void 0, function* () {
            return "data:" + this.getContentType("pdf") + ";" + this.get("charset", "utf-8") + "," + encodeURIComponent(yield this.getPDF(customOptions, false, true));
        });
    }
    /**
     * Returns Base64-encoded binary data for a PDF file.
     * @param   customOptions  PDF options
     * @param   includeImage   Include chart snapshot
     * @param   includeData    Include data
     * @return                 Promise
     */
    getPDF(customOptions, includeImage = true, includeData = false) {
        return (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__awaiter)(this, void 0, void 0, function* () {
            const options = this._getFormatOptions("pdf", customOptions);
            const dataOptions = this._getFormatOptions("pdfdata", customOptions);
            const orientation = options.pageOrientation || "portrait";
            // Get image
            let image;
            if (includeImage) {
                image = yield this.exportImage(options.imageFormat || "png", options);
            }
            // Load pdfmake
            const pdfmake = yield this.getPdfmake();
            // Defaults
            const defaultMargins = [30, 30, 30, 30];
            // Init content for PDF
            let doc = {
                pageSize: options.pageSize || "A4",
                pageOrientation: orientation,
                pageMargins: options.pageMargins || defaultMargins,
                defaultStyle: {
                    font: options.font ? options.font.name : undefined
                },
                //header: <any>[],
                content: []
            };
            // Should we add title?
            const title = this.get("title");
            let extraMargin = 0;
            if (title) {
                doc.content.push({
                    text: title,
                    fontSize: options.fontSize || 14,
                    bold: true,
                    margin: [0, 0, 0, 15]
                });
                // Add some leftover margin for title
                extraMargin += 50;
            }
            // Add page URL?
            if (options.addURL) {
                doc.content.push({
                    text: this._t("Saved from") + ": " + document.location.href,
                    fontSize: options.fontSize,
                    margin: [0, 0, 0, 15]
                });
                // Add some leftover margin for URL
                extraMargin += 50;
            }
            // Add image
            if (includeImage && image) {
                doc.content.push({
                    image: image,
                    alignment: options.align || "left",
                    fit: this.getPageSizeFit(doc.pageSize, doc.pageMargins, extraMargin, orientation)
                });
            }
            // Add data
            if ((includeData || options.includeData) && this.hasData()) {
                doc.content.push({
                    table: yield this.getPDFData(dataOptions),
                    fontSize: options.fontSize || 14
                });
            }
            let fonts = null;
            let vfs = null;
            function addFont(font) {
                const paths = {};
                paths.normal = font.normal.path;
                vfs[font.normal.path] = font.normal.bytes;
                if (font.bold) {
                    paths.bold = font.bold.path;
                    vfs[font.bold.path] = font.bold.bytes;
                }
                else {
                    paths.bold = font.normal.path;
                }
                if (font.italics) {
                    paths.italics = font.italics.path;
                    vfs[font.italics.path] = font.italics.bytes;
                }
                else {
                    paths.italics = font.normal.path;
                }
                if (font.bolditalics) {
                    paths.bolditalics = font.bolditalics.path;
                    vfs[font.bolditalics.path] = font.bolditalics.bytes;
                }
                else {
                    paths.bolditalics = font.normal.path;
                }
                fonts[font.name] = paths;
            }
            if (options.font) {
                fonts = {};
                vfs = {};
                addFont(options.font);
                if (options.extraFonts) {
                    _core_util_Array__WEBPACK_IMPORTED_MODULE_3__.each(options.extraFonts, addFont);
                }
            }
            this.events.dispatch("pdfdocready", {
                type: "pdfdocready",
                format: "pdf",
                options: options,
                doc: doc,
                target: this
            });
            // Create PDF
            return new Promise((success, _error) => {
                pdfmake.createPdf(doc, null, fonts, vfs).getBase64((uri) => {
                    success(uri);
                });
            });
        });
    }
    /**
     * @ignore
     */
    getPDFData(customOptions) {
        return (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__awaiter)(this, void 0, void 0, function* () {
            const options = this._getFormatOptions("pdfdata", customOptions);
            // Init output
            let content = {
                "body": []
            };
            // Get data
            const data = this.getData("html", options);
            const dataFields = this.getDataFields(data);
            // Vertical or horizontal (default) layout
            if (options.pivot) {
                // Data fields order
                const dataFieldsOrder = this.get("dataFieldsOrder", []);
                _core_util_Object__WEBPACK_IMPORTED_MODULE_2__.eachOrdered(dataFields, (key, val) => {
                    let dataRow = [];
                    if (options.addColumnNames) {
                        dataRow.push(val);
                    }
                    for (let len = data.length, i = 0; i < len; i++) {
                        let dataValue = data[i][key];
                        dataRow.push(this.convertToSpecialFormat(key, dataValue, options, true));
                    }
                    content.body.push(this.getPDFDataRow(dataRow, options, undefined, true));
                }, (a, b) => {
                    let ai = dataFieldsOrder.indexOf(a);
                    let bi = dataFieldsOrder.indexOf(b);
                    if (ai > bi) {
                        return 1;
                    }
                    else if (ai < bi) {
                        return -1;
                    }
                    return 0;
                });
            }
            else {
                // Add column names?
                if (options.addColumnNames) {
                    content.body.push(this.getPDFDataRow(dataFields, options, undefined, true));
                    content.headerRows = 1;
                }
                for (let len = data.length, i = 0; i < len; i++) {
                    content.body.push(this.getPDFDataRow(data[i], options, dataFields));
                }
            }
            return content;
        });
    }
    /**
     * @ignore
     */
    getPDFDataRow(row, options, dataFields, asIs = false) {
        // Init
        let items = [];
        // Data fields
        if (!dataFields) {
            dataFields = row;
        }
        // Data fields order
        const dataFieldsOrder = this.get("dataFieldsOrder", []);
        // Process each row item
        _core_util_Object__WEBPACK_IMPORTED_MODULE_2__.eachOrdered(dataFields, (key, _name) => {
            // Get value
            let value = this.convertEmptyValue(key, row[key], options);
            // Convert dates
            let item = asIs ? value : this.convertToSpecialFormat(key, value, options);
            item = "" + item;
            // Add to item
            items.push(item);
        }, (a, b) => {
            let ai = dataFieldsOrder.indexOf(a);
            let bi = dataFieldsOrder.indexOf(b);
            if (ai > bi) {
                return 1;
            }
            else if (ai < bi) {
                return -1;
            }
            return 0;
        });
        return items;
    }
    /**
     * Returns pdfmake instance.
     *
     * @ignore
     * @return Instance of pdfmake
     */
    getPdfmake() {
        if (pdfmakePromise === undefined) {
            pdfmakePromise = _pdfmake();
        }
        return pdfmakePromise;
    }
    /**
     * @ignore
     */
    getPageSizeFit(pageSize, margins, extraMargin = 0, orientation = "portrait") {
        // Check margins
        let newMargins = [0, 0, 0, 0];
        if (_core_util_Type__WEBPACK_IMPORTED_MODULE_5__.isNumber(margins)) {
            newMargins = [margins, margins, margins, margins];
        }
        else if (margins.length == 2) {
            newMargins = [margins[0], margins[1], margins[0], margins[1]];
        }
        else if (margins.length == 4) {
            newMargins = margins;
        }
        // Define available page sizes
        let sizes = {
            "4A0": [4767.87, 6740.79],
            "2A0": [3370.39, 4767.87],
            A0: [2383.94, 3370.39],
            A1: [1683.78, 2383.94],
            A2: [1190.55, 1683.78],
            A3: [841.89, 1190.55],
            A4: [595.28, 841.89],
            A5: [419.53, 595.28],
            A6: [297.64, 419.53],
            A7: [209.76, 297.64],
            A8: [147.40, 209.76],
            A9: [104.88, 147.40],
            A10: [73.70, 104.88],
            B0: [2834.65, 4008.19],
            B1: [2004.09, 2834.65],
            B2: [1417.32, 2004.09],
            B3: [1000.63, 1417.32],
            B4: [708.66, 1000.63],
            B5: [498.90, 708.66],
            B6: [354.33, 498.90],
            B7: [249.45, 354.33],
            B8: [175.75, 249.45],
            B9: [124.72, 175.75],
            B10: [87.87, 124.72],
            C0: [2599.37, 3676.54],
            C1: [1836.85, 2599.37],
            C2: [1298.27, 1836.85],
            C3: [918.43, 1298.27],
            C4: [649.13, 918.43],
            C5: [459.21, 649.13],
            C6: [323.15, 459.21],
            C7: [229.61, 323.15],
            C8: [161.57, 229.61],
            C9: [113.39, 161.57],
            C10: [79.37, 113.39],
            RA0: [2437.80, 3458.27],
            RA1: [1729.13, 2437.80],
            RA2: [1218.90, 1729.13],
            RA3: [864.57, 1218.90],
            RA4: [609.45, 864.57],
            SRA0: [2551.18, 3628.35],
            SRA1: [1814.17, 2551.18],
            SRA2: [1275.59, 1814.17],
            SRA3: [907.09, 1275.59],
            SRA4: [637.80, 907.09],
            EXECUTIVE: [521.86, 756.00],
            FOLIO: [612.00, 936.00],
            LEGAL: [612.00, 1008.00],
            LETTER: [612.00, 792.00],
            TABLOID: [792.00, 1224.00]
        };
        // Calculate size
        let fitSize = sizes[pageSize];
        if (orientation == "landscape") {
            fitSize.reverse();
        }
        fitSize[0] -= newMargins[0] + newMargins[2];
        fitSize[1] -= newMargins[1] + newMargins[3] + extraMargin;
        return fitSize;
    }
    /**
     * ==========================================================================
     * Data
     * ==========================================================================
     */
    /**
        * Returns `true` if `dataSource` is set, and the contents are proper
        * data (array).
        *
        * @return Has data?
        */
    hasData() {
        const dataSource = this.get("dataSource");
        return _core_util_Type__WEBPACK_IMPORTED_MODULE_5__.isArray(dataSource) && dataSource.length ? true : false;
    }
    /**
     * Returns processed data according to format options.
     *
     * @param   format         Format
     * @param   customOptions  Format options
     * @param   renameFields   Should fields be renamed?
     * @return                 Processed data
     */
    getData(format, customOptions, renameFields = false) {
        const options = this._getFormatOptions(format, customOptions);
        const dataSource = this.get("dataSource", []);
        let data = dataSource;
        // Re-generate the data based on data fields if set
        const dataFields = this.get("dataFields");
        if (dataFields && _core_util_Type__WEBPACK_IMPORTED_MODULE_5__.isArray(dataSource)) {
            data = [];
            _core_util_Array__WEBPACK_IMPORTED_MODULE_3__.each(dataSource, (row) => {
                if (_core_util_Type__WEBPACK_IMPORTED_MODULE_5__.isObject(row)) {
                    const newRow = {};
                    _core_util_Object__WEBPACK_IMPORTED_MODULE_2__.each(dataFields, (field, value) => {
                        if (dataFields[field] != null) {
                            newRow[renameFields ? value : field] = this.convertToSpecialFormat(field, row[field], options);
                        }
                    });
                    data.push(newRow);
                }
            });
        }
        const event = {
            type: "dataprocessed",
            format: format,
            options: options,
            data: data,
            target: this
        };
        this.events.dispatch("dataprocessed", event);
        return event.data;
    }
    /**
     * @ignore
     */
    getDataFields(data) {
        let dataFields = this.get("dataFields");
        if (!dataFields) {
            dataFields = {};
            if (_core_util_Type__WEBPACK_IMPORTED_MODULE_5__.isArray(data) && data.length) {
                _core_util_Array__WEBPACK_IMPORTED_MODULE_3__.each(data, (row) => {
                    _core_util_Object__WEBPACK_IMPORTED_MODULE_2__.each(row, (key, _value) => {
                        if (dataFields[key] == null) {
                            dataFields[key] = key;
                        }
                    });
                });
            }
        }
        return dataFields;
    }
    /**
     * @ignore
     */
    convertEmptyValue(_field, value, options) {
        return value != null ? value : options.emptyAs;
    }
    /**
     * @ignore
     */
    convertToSpecialFormat(field, value, options, keepOriginal) {
        // Is this a timestamp or duration?
        if (typeof value == "number") {
            if (this.isDateField(field)) {
                value = new Date(value);
            }
            else if (this.isNumericField(field) && this.get("numberFormat")) {
                return this._root.numberFormatter.format(value, this.get("numberFormat"));
            }
            else if (this.isDurationField(field)) {
                return this._root.durationFormatter.format(value, this.get("durationFormat"), this.get("durationUnit"));
            }
        }
        if (value instanceof Date) {
            if (options.useTimestamps) {
                value = value.getTime();
            }
            else if (options.useLocale) {
                if (!keepOriginal) {
                    value = value.toLocaleString();
                }
            }
            else {
                value = this._root.dateFormatter.format(value, this.get("dateFormat"));
            }
        }
        return value;
    }
    /**
     * @ignore
     */
    isDateField(field) {
        return this.get("dateFields").indexOf(field) !== -1;
    }
    /**
     * @ignore
     */
    isNumericField(field) {
        return this.get("numericFields").indexOf(field) !== -1;
    }
    /**
     * @ignore
     */
    isDurationField(field) {
        return this.get("durationFields").indexOf(field) !== -1;
    }
    /**
     * @ignore
     */
    getContentType(type) {
        let contentType = "";
        switch (type) {
            case "png":
                contentType = "image/" + type;
                break;
            case "jpg":
                contentType = "image/jpeg";
                break;
            case "csv":
                contentType = "text/csv";
                break;
            case "json":
                contentType = "application/json";
                break;
            case "html":
                contentType = "text/html";
                break;
            case "pdf":
            case "pdfdata":
                contentType = "application/pdf";
                break;
            case "xlsx":
                contentType = "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet";
                break;
            default:
                contentType = "application/octet-stream";
        }
        return contentType;
    }
    getDisposableCanvas() {
        let canvas = document.createElement("canvas");
        canvas.style.position = "fixed";
        canvas.style.top = "-10000px";
        this._root.dom.appendChild(canvas);
        return canvas;
    }
    disposeCanvas(canvas) {
        this._root.dom.removeChild(canvas);
    }
    /**
     * @ignore
     */
    findBackgroundColor(element) {
        // Check if element has styles set
        let opacity = 1;
        let currentColor = getComputedStyle(element, "background-color").getPropertyValue("background-color");
        // Check opacity
        if (currentColor.match(/[^,]*,[^,]*,[^,]*,[ ]?0/) || currentColor == "transparent") {
            opacity = 0;
        }
        if (opacity == 0) {
            let parent = element.parentElement; // || <Element>element.parentNode;
            // Completely transparent. Look for a parent
            if (parent) {
                return this.findBackgroundColor(parent);
            }
            else {
                return _core_util_Color__WEBPACK_IMPORTED_MODULE_6__.Color.fromHex(0xffffff);
            }
        }
        else {
            return _core_util_Color__WEBPACK_IMPORTED_MODULE_6__.Color.fromCSS(currentColor);
        }
    }
    /**
     * Triggers download of the file.
     *
     * @param   uri       data:uri with file content
     * @param   fileName  File name
     * @param   addBOM    Should download include byte order mark?
     * @return            Promise
     */
    streamFile(uri, fileName, addBOM = false) {
        if (this.blobDownloadSupport()) {
            /**
             * Supports Blob object.
             * Use it.
             */
            let link = document.createElement("a");
            link.download = fileName;
            document.body.appendChild(link);
            // Extract content type and get pure data without headers
            let parts = uri.split(";");
            let contentType = parts.shift().replace(/data:/, "");
            uri = decodeURIComponent(parts.join(";").replace(/^[^,]*,/, ""));
            if (["image/svg+xml", "application/json", "text/csv", "text/html"].indexOf(contentType) == -1) {
                try {
                    let decoded = atob(uri);
                    uri = decoded;
                }
                catch (e) {
                    // Error occurred, meaning string was not Base64-encoded. Do nothing.
                    return false;
                }
            }
            else {
                if (addBOM) {
                    uri = "\ufeff" + uri;
                }
                let blob = new Blob([uri], { type: contentType });
                let url = window.URL.createObjectURL(blob);
                link.href = url;
                link.download = fileName;
                link.click();
                setTimeout(() => {
                    document.body.removeChild(link);
                    window.URL.revokeObjectURL(url);
                }, 100);
                return true;
            }
            // Dissect uri into array
            let chars = new Array(uri.length);
            for (let i = 0; i < uri.length; ++i) {
                let charCode = uri.charCodeAt(i);
                chars[i] = charCode;
            }
            if (addBOM) {
                chars = [0xEF, 0xBB, 0xBF].concat(chars);
            }
            let blob = new Blob([new Uint8Array(chars)], { type: contentType });
            let url = window.URL.createObjectURL(blob);
            link.href = url;
            link.download = fileName;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            setTimeout(() => {
                window.URL.revokeObjectURL(url);
            }, 100);
        }
        else if (this.linkDownloadSupport()) {
            /**
             * For regular browsers, we create a link then simulate a click on it
             */
            let link = document.createElement("a");
            link.download = fileName;
            link.href = uri;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }
        else {
            /**
             * Something else - perhaps a mobile.
             * Let's just display it in the same page.
             * (hey we don't like it either)
             */
            window.location.href = uri;
        }
        return true;
    }
    /**
     * @ignore
     */
    downloadSupport() {
        return this.linkDownloadSupport();
    }
    /**
     * @ignore
     */
    linkDownloadSupport() {
        let a = document.createElement("a");
        let res = typeof a.download !== "undefined";
        return res;
    }
    /**
     * @ignore
     */
    blobDownloadSupport() {
        return window.Blob != null;
    }
    /**
     * ==========================================================================
     * Print
     * ==========================================================================
     */
    /**
     * Initiates print of the chart.
     *
     * @param   data     data:uri for the image
     * @param   options  Options
     * @param   title    Optional title to use (uses window's title by default)
     * @return           Promise
     */
    initiatePrint(data, customOptions, title) {
        const options = this._getFormatOptions("print", customOptions);
        if (options.printMethod == "css") {
            this._printViaCSS(data, options, title);
        }
        else {
            this._printViaIframe(data, options, title);
        }
    }
    _printViaCSS(data, customOptions, title) {
        const options = this._getFormatOptions("print", customOptions);
        let delay = options.delay || 500;
        //Save current scroll position
        let scroll = document.documentElement.scrollTop || document.body.scrollTop;
        // Hide all document nodes by applying custom CSS
        let rule = new _core_util_Utils__WEBPACK_IMPORTED_MODULE_7__.StyleRule(_core_util_Utils__WEBPACK_IMPORTED_MODULE_7__.getShadowRoot(this._root.dom), "body > *", {
            "display": "none",
            "position": "fixed",
            "visibility": "hidden",
            "opacity": "0",
            "clipPath": "polygon(0px 0px,0px 0px,0px 0px,0px 0px);"
        }, this._root.nonce);
        let rule2 = new _core_util_Utils__WEBPACK_IMPORTED_MODULE_7__.StyleRule(_core_util_Utils__WEBPACK_IMPORTED_MODULE_7__.getShadowRoot(this._root.dom), "body", {
            "padding": "0",
            "margin": "0"
        }, this._root.nonce);
        // Replace title?
        let originalTitle;
        if (title && document && document.title) {
            originalTitle = document.title;
            document.title = title;
        }
        // Create and add exported image
        let img = new Image();
        img.src = data;
        img.style.maxWidth = "100%";
        img.style.display = "block";
        img.style.position = "relative";
        img.style.visibility = "visible";
        img.style.opacity = "1";
        img.style.clipPath = "none";
        document.body.appendChild(img);
        // Print
        this.setTimeout(() => {
            window.print();
        }, 50);
        // Delay needs to be at least a second for iOS devices
        let isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
        if (isIOS && (delay < 1000)) {
            delay = 1000;
        }
        else if (delay < 100) {
            delay = 100;
        }
        // Delay function that resets back the document the way ot was before
        this.setTimeout(() => {
            // Remove image
            document.body.removeChild(img);
            // Reset back all elements
            rule.dispose();
            rule2.dispose();
            // Restore title
            if (originalTitle) {
                document.title = document.title;
            }
            // Scroll back the document the way it was before
            document.documentElement.scrollTop = document.body.scrollTop = scroll;
        }, delay || 500);
    }
    _printViaIframe(data, customOptions, title) {
        const options = this._getFormatOptions("print", customOptions);
        let delay = options.delay || 500;
        // Create an iframe
        const iframe = document.createElement("iframe");
        iframe.style.visibility = "hidden";
        document.body.appendChild(iframe);
        // This is needed for FireFox
        iframe.contentWindow.document.open();
        iframe.contentWindow.document.close();
        // Create and add exported image
        let img = new Image();
        img.src = data;
        img.style.maxWidth = "100%";
        img.style.height = "auto";
        if (title) {
            iframe.contentWindow.document.title = title;
        }
        iframe.contentWindow.document.body.appendChild(img);
        iframe.load = function () {
            iframe.contentWindow.document.body.appendChild(img);
        };
        // Print
        this.setTimeout(() => {
            try {
                if (!iframe.contentWindow.document.execCommand("print", false, null)) {
                    iframe.contentWindow.print();
                }
            }
            catch (e) {
                iframe.contentWindow.print();
            }
        }, delay || 50);
        // Delay needs to be at least a second for iOS devices
        let isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
        if (isIOS && (delay < 1000)) {
            delay = 1000;
        }
        else if (delay < 100) {
            delay = 100;
        }
        // Delay function that resets back the document the way ot was before
        this.setTimeout(() => {
            // Remove image
            document.body.removeChild(iframe);
        }, delay + 50 || 100);
    }
    /**
     * Returns a list of formats that can be exported in current browser.
     *
     * @return Formats
     */
    supportedFormats() {
        const res = [];
        const hasData = this.hasData();
        const downloadSupport = this.downloadSupport();
        _core_util_Array__WEBPACK_IMPORTED_MODULE_3__.each(["png", "jpg", "canvas", "pdf", "xlsx", "csv", "json", "html", "pdfdata", "print"], (format) => {
            const options = this._getFormatOptions(format);
            if (options.disabled !== true) {
                if (["xlsx", "csv", "json", "html", "pdfdata"].indexOf(format) == -1 || (hasData && downloadSupport)) {
                    res.push(format);
                }
            }
        });
        return res;
    }
    /**
     * Returns a list of supported export types: image or print.
     *
     * @return Supported types
     */
    supportedExportTypes() {
        const res = ["image", "print"];
        if (this.downloadSupport() && this.hasData()) {
            res.push("data");
        }
        return res;
    }
}
Object.defineProperty(Exporting, "className", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: "Exporting"
});
Object.defineProperty(Exporting, "classNames", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: _core_util_Entity__WEBPACK_IMPORTED_MODULE_1__.Entity.classNames.concat([Exporting.className])
});
//# sourceMappingURL=Exporting.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/themes/AnimatedTheme.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/themes/AnimatedTheme.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AnimatedTheme: () => (/* binding */ AnimatedTheme)
/* harmony export */ });
/* harmony import */ var _core_Theme__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Theme */ "./node_modules/@amcharts/amcharts5/.internal/core/Theme.js");

/**
 * @ignore
 */
class AnimatedTheme extends _core_Theme__WEBPACK_IMPORTED_MODULE_0__.Theme {
    setupDefaultRules() {
        super.setupDefaultRules();
        this.rule("Component").setAll({
            interpolationDuration: 600
        });
        this.rule("Hierarchy").set("animationDuration", 600);
        this.rule("Scrollbar").set("animationDuration", 600);
        this.rule("Tooltip").set("animationDuration", 300);
        this.rule("MapChart").set("animationDuration", 1000);
        this.rule("MapChart").set("wheelDuration", 300);
        this.rule("Entity").setAll({
            stateAnimationDuration: 600
        });
        this.rule("Sprite").states.create("default", { stateAnimationDuration: 600 });
        this.rule("Tooltip", ["axis"]).setAll({
            animationDuration: 200
        });
        this.rule("WordCloud").set("animationDuration", 500);
        this.rule("Polygon").set("animationDuration", 600);
        this.rule("ArcDiagram").set("animationDuration", 600);
    }
}
//# sourceMappingURL=AnimatedTheme.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/themes/DarkTheme.js":
/*!************************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/themes/DarkTheme.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DarkTheme: () => (/* binding */ DarkTheme)
/* harmony export */ });
/* harmony import */ var _core_util_Color__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/util/Color */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Color.js");
/* harmony import */ var _core_Theme__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Theme */ "./node_modules/@amcharts/amcharts5/.internal/core/Theme.js");


/**
 * @ignore
 */
class DarkTheme extends _core_Theme__WEBPACK_IMPORTED_MODULE_0__.Theme {
    setupDefaultRules() {
        super.setupDefaultRules();
        this.rule("InterfaceColors").setAll({
            stroke: _core_util_Color__WEBPACK_IMPORTED_MODULE_1__.Color.fromHex(0x000000),
            fill: _core_util_Color__WEBPACK_IMPORTED_MODULE_1__.Color.fromHex(0x2b2b2b),
            primaryButton: _core_util_Color__WEBPACK_IMPORTED_MODULE_1__.Color.lighten(_core_util_Color__WEBPACK_IMPORTED_MODULE_1__.Color.fromHex(0x6794dc), -0.2),
            primaryButtonHover: _core_util_Color__WEBPACK_IMPORTED_MODULE_1__.Color.lighten(_core_util_Color__WEBPACK_IMPORTED_MODULE_1__.Color.fromHex(0x6771dc), -0.2),
            primaryButtonDown: _core_util_Color__WEBPACK_IMPORTED_MODULE_1__.Color.lighten(_core_util_Color__WEBPACK_IMPORTED_MODULE_1__.Color.fromHex(0x68dc75), -0.2),
            primaryButtonActive: _core_util_Color__WEBPACK_IMPORTED_MODULE_1__.Color.lighten(_core_util_Color__WEBPACK_IMPORTED_MODULE_1__.Color.fromHex(0x68dc76), -0.2),
            primaryButtonText: _core_util_Color__WEBPACK_IMPORTED_MODULE_1__.Color.fromHex(0xffffff),
            primaryButtonStroke: _core_util_Color__WEBPACK_IMPORTED_MODULE_1__.Color.lighten(_core_util_Color__WEBPACK_IMPORTED_MODULE_1__.Color.fromHex(0x6794dc), -0.2),
            secondaryButton: _core_util_Color__WEBPACK_IMPORTED_MODULE_1__.Color.fromHex(0x3b3b3b),
            secondaryButtonHover: _core_util_Color__WEBPACK_IMPORTED_MODULE_1__.Color.lighten(_core_util_Color__WEBPACK_IMPORTED_MODULE_1__.Color.fromHex(0x3b3b3b), 0.1),
            secondaryButtonDown: _core_util_Color__WEBPACK_IMPORTED_MODULE_1__.Color.lighten(_core_util_Color__WEBPACK_IMPORTED_MODULE_1__.Color.fromHex(0x3b3b3b), 0.15),
            secondaryButtonActive: _core_util_Color__WEBPACK_IMPORTED_MODULE_1__.Color.lighten(_core_util_Color__WEBPACK_IMPORTED_MODULE_1__.Color.fromHex(0x3b3b3b), 0.2),
            secondaryButtonText: _core_util_Color__WEBPACK_IMPORTED_MODULE_1__.Color.fromHex(0xbbbbbb),
            secondaryButtonStroke: _core_util_Color__WEBPACK_IMPORTED_MODULE_1__.Color.lighten(_core_util_Color__WEBPACK_IMPORTED_MODULE_1__.Color.fromHex(0x3b3b3b), -0.2),
            grid: _core_util_Color__WEBPACK_IMPORTED_MODULE_1__.Color.fromHex(0xbbbbbb),
            background: _core_util_Color__WEBPACK_IMPORTED_MODULE_1__.Color.fromHex(0x000000),
            alternativeBackground: _core_util_Color__WEBPACK_IMPORTED_MODULE_1__.Color.fromHex(0xffffff),
            text: _core_util_Color__WEBPACK_IMPORTED_MODULE_1__.Color.fromHex(0xffffff),
            alternativeText: _core_util_Color__WEBPACK_IMPORTED_MODULE_1__.Color.fromHex(0x000000),
            disabled: _core_util_Color__WEBPACK_IMPORTED_MODULE_1__.Color.fromHex(0xadadad),
            positive: _core_util_Color__WEBPACK_IMPORTED_MODULE_1__.Color.fromHex(0x50b300),
            negative: _core_util_Color__WEBPACK_IMPORTED_MODULE_1__.Color.fromHex(0xb30000)
        });
    }
}
//# sourceMappingURL=DarkTheme.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/themes/DefaultTheme.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/themes/DefaultTheme.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DefaultTheme: () => (/* binding */ DefaultTheme),
/* harmony export */   setColor: () => (/* binding */ setColor)
/* harmony export */ });
/* harmony import */ var _core_Theme__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Theme */ "./node_modules/@amcharts/amcharts5/.internal/core/Theme.js");
/* harmony import */ var _core_util_Percent__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../core/util/Percent */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Percent.js");
/* harmony import */ var _core_util_Color__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/util/Color */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Color.js");
/* harmony import */ var _core_render_GridLayout__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../core/render/GridLayout */ "./node_modules/@amcharts/amcharts5/.internal/core/render/GridLayout.js");
/* harmony import */ var _core_util_Ease__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/util/Ease */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Ease.js");





/**
 * @ignore
 */
function setColor(rule, key, ic, name) {
    // TODO this shouldn't use get, figure out a better way
    rule.set(key, ic.get(name));
    ic.on(name, (value) => {
        rule.set(key, value);
    });
}
/**
 * @ignore
 */
class DefaultTheme extends _core_Theme__WEBPACK_IMPORTED_MODULE_0__.Theme {
    setupDefaultRules() {
        super.setupDefaultRules();
        const language = this._root.language;
        const ic = this._root.interfaceColors;
        const horizontalLayout = this._root.horizontalLayout;
        const verticalLayout = this._root.verticalLayout;
        const r = this.rule.bind(this);
        /**
         * ========================================================================
         * core
         * ========================================================================
         */
        r("InterfaceColors").setAll({
            stroke: _core_util_Color__WEBPACK_IMPORTED_MODULE_1__.Color.fromHex(0xe5e5e5),
            fill: _core_util_Color__WEBPACK_IMPORTED_MODULE_1__.Color.fromHex(0xf3f3f3),
            primaryButton: _core_util_Color__WEBPACK_IMPORTED_MODULE_1__.Color.fromHex(0x6794dc),
            primaryButtonHover: _core_util_Color__WEBPACK_IMPORTED_MODULE_1__.Color.fromHex(0x6771dc),
            primaryButtonDown: _core_util_Color__WEBPACK_IMPORTED_MODULE_1__.Color.fromHex(0x68dc76),
            primaryButtonActive: _core_util_Color__WEBPACK_IMPORTED_MODULE_1__.Color.fromHex(0x68dc76),
            primaryButtonText: _core_util_Color__WEBPACK_IMPORTED_MODULE_1__.Color.fromHex(0xffffff),
            primaryButtonStroke: _core_util_Color__WEBPACK_IMPORTED_MODULE_1__.Color.fromHex(0xffffff),
            secondaryButton: _core_util_Color__WEBPACK_IMPORTED_MODULE_1__.Color.fromHex(0xd9d9d9),
            secondaryButtonHover: _core_util_Color__WEBPACK_IMPORTED_MODULE_1__.Color.fromHex(0xa3a3a3),
            secondaryButtonDown: _core_util_Color__WEBPACK_IMPORTED_MODULE_1__.Color.fromHex(0x8d8d8d),
            secondaryButtonActive: _core_util_Color__WEBPACK_IMPORTED_MODULE_1__.Color.fromHex(0xe6e6e6),
            secondaryButtonText: _core_util_Color__WEBPACK_IMPORTED_MODULE_1__.Color.fromHex(0x000000),
            secondaryButtonStroke: _core_util_Color__WEBPACK_IMPORTED_MODULE_1__.Color.fromHex(0xffffff),
            grid: _core_util_Color__WEBPACK_IMPORTED_MODULE_1__.Color.fromHex(0x000000),
            background: _core_util_Color__WEBPACK_IMPORTED_MODULE_1__.Color.fromHex(0xffffff),
            alternativeBackground: _core_util_Color__WEBPACK_IMPORTED_MODULE_1__.Color.fromHex(0x000000),
            text: _core_util_Color__WEBPACK_IMPORTED_MODULE_1__.Color.fromHex(0x000000),
            alternativeText: _core_util_Color__WEBPACK_IMPORTED_MODULE_1__.Color.fromHex(0xffffff),
            disabled: _core_util_Color__WEBPACK_IMPORTED_MODULE_1__.Color.fromHex(0xadadad),
            positive: _core_util_Color__WEBPACK_IMPORTED_MODULE_1__.Color.fromHex(0x50b300),
            negative: _core_util_Color__WEBPACK_IMPORTED_MODULE_1__.Color.fromHex(0xb30000)
        });
        {
            const rule = r("ColorSet");
            rule.setAll({
                passOptions: {
                    hue: 0.05,
                    saturation: 0,
                    lightness: 0
                },
                colors: [
                    _core_util_Color__WEBPACK_IMPORTED_MODULE_1__.Color.fromHex(0x67b7dc)
                ],
                step: 1,
                //baseColor: Color.fromRGB(103, 183, 220),
                //count: 20,
                reuse: false,
                startIndex: 0
            });
            rule.setPrivate("currentStep", 0);
            rule.setPrivate("currentPass", 0);
        }
        r("Entity").setAll({
            stateAnimationDuration: 0,
            stateAnimationEasing: _core_util_Ease__WEBPACK_IMPORTED_MODULE_2__.out(_core_util_Ease__WEBPACK_IMPORTED_MODULE_2__.cubic)
        });
        r("Component").setAll({
            interpolationDuration: 0,
            interpolationEasing: _core_util_Ease__WEBPACK_IMPORTED_MODULE_2__.out(_core_util_Ease__WEBPACK_IMPORTED_MODULE_2__.cubic)
        });
        r("Sprite").setAll({
            visible: true,
            scale: 1,
            opacity: 1,
            rotation: 0,
            position: "relative",
            tooltipX: _core_util_Percent__WEBPACK_IMPORTED_MODULE_3__.p50,
            tooltipY: _core_util_Percent__WEBPACK_IMPORTED_MODULE_3__.p50,
            tooltipPosition: "fixed",
            isMeasured: true
        });
        r("Sprite").states.create("default", { "visible": true, opacity: 1 });
        r("Container").setAll({
            interactiveChildren: true,
            setStateOnChildren: false
        });
        r("Graphics").setAll({
            strokeWidth: 1
        });
        r("Chart").setAll({
            width: _core_util_Percent__WEBPACK_IMPORTED_MODULE_3__.p100,
            height: _core_util_Percent__WEBPACK_IMPORTED_MODULE_3__.p100,
            interactiveChildren: false
        });
        /**
         * ------------------------------------------------------------------------
         * core: alignment
         * ------------------------------------------------------------------------
         */
        r("Sprite", ["horizontal", "center"]).setAll({
            centerX: _core_util_Percent__WEBPACK_IMPORTED_MODULE_3__.p50,
            x: _core_util_Percent__WEBPACK_IMPORTED_MODULE_3__.p50
        });
        r("Sprite", ["vertical", "center"]).setAll({
            centerY: _core_util_Percent__WEBPACK_IMPORTED_MODULE_3__.p50,
            y: _core_util_Percent__WEBPACK_IMPORTED_MODULE_3__.p50
        });
        r("Container", ["horizontal", "layout"]).setAll({
            layout: horizontalLayout
        });
        r("Container", ["vertical", "layout"]).setAll({
            layout: verticalLayout
        });
        /**
         * ------------------------------------------------------------------------
         * core: patterns
         * ------------------------------------------------------------------------
         */
        r("Pattern").setAll({
            repetition: "repeat",
            width: 50,
            height: 50,
            rotation: 0,
            fillOpacity: 1
        });
        r("LinePattern").setAll({
            gap: 6,
            colorOpacity: 1,
            width: 49,
            height: 49
        });
        r("RectanglePattern").setAll({
            gap: 6,
            checkered: false,
            centered: true,
            maxWidth: 5,
            maxHeight: 5,
            width: 48,
            height: 48,
            strokeWidth: 0
        });
        r("CirclePattern").setAll({
            gap: 5,
            checkered: false,
            centered: false,
            radius: 3,
            strokeWidth: 0,
            width: 45,
            height: 45
        });
        r("GrainPattern").setAll({
            width: 200,
            height: 200,
            colors: [_core_util_Color__WEBPACK_IMPORTED_MODULE_1__.Color.fromHex(0x000000)],
            size: 1,
            horizontalGap: 0,
            verticalGap: 0,
            density: 1,
            minOpacity: 0,
            maxOpacity: 0.2
        });
        /**
         * ------------------------------------------------------------------------
         * core: gradients
         * ------------------------------------------------------------------------
         */
        r("LinearGradient").setAll({
            rotation: 90
        });
        /**
         * ------------------------------------------------------------------------
         * core: Legend
         * ------------------------------------------------------------------------
         */
        r("Legend").setAll({
            fillField: "fill",
            strokeField: "stroke",
            nameField: "name",
            layout: _core_render_GridLayout__WEBPACK_IMPORTED_MODULE_4__.GridLayout.new(this._root, {}),
            layer: 30,
            clickTarget: "itemContainer"
        });
        // Class: Container
        r("Container", ["legend", "item", "itemcontainer"]).setAll({
            paddingLeft: 5,
            paddingRight: 5,
            paddingBottom: 5,
            paddingTop: 5,
            layout: horizontalLayout,
            setStateOnChildren: true,
            interactiveChildren: false,
            ariaChecked: true,
            focusable: true,
            ariaLabel: language.translate("Press ENTER to toggle"),
            role: "checkbox"
        });
        {
            const rule = r("Rectangle", ["legend", "item", "background"]);
            rule.setAll({
                fillOpacity: 0,
            });
            setColor(rule, "fill", ic, "background");
        }
        r("Container", ["legend", "marker"]).setAll({
            setStateOnChildren: true,
            centerY: _core_util_Percent__WEBPACK_IMPORTED_MODULE_3__.p50,
            paddingLeft: 0,
            paddingRight: 0,
            paddingBottom: 0,
            paddingTop: 0,
            width: 18,
            height: 18
        });
        r("RoundedRectangle", ["legend", "marker", "rectangle"]).setAll({
            width: _core_util_Percent__WEBPACK_IMPORTED_MODULE_3__.p100,
            height: _core_util_Percent__WEBPACK_IMPORTED_MODULE_3__.p100,
            cornerRadiusBL: 3,
            cornerRadiusTL: 3,
            cornerRadiusBR: 3,
            cornerRadiusTR: 3
        });
        {
            const rule = r("RoundedRectangle", ["legend", "marker", "rectangle"]).states.create("disabled", {});
            setColor(rule, "fill", ic, "disabled");
            setColor(rule, "stroke", ic, "disabled");
        }
        r("Label", ["legend", "label"]).setAll({
            centerY: _core_util_Percent__WEBPACK_IMPORTED_MODULE_3__.p50,
            marginLeft: 5,
            paddingRight: 0,
            paddingLeft: 0,
            paddingTop: 0,
            paddingBottom: 0,
            populateText: true
        });
        {
            const rule = r("Label", ["legend", "label"]).states.create("disabled", {});
            setColor(rule, "fill", ic, "disabled");
        }
        r("Label", ["legend", "value", "label"]).setAll({
            centerY: _core_util_Percent__WEBPACK_IMPORTED_MODULE_3__.p50,
            marginLeft: 5,
            paddingRight: 0,
            paddingLeft: 0,
            paddingTop: 0,
            paddingBottom: 0,
            width: 50,
            centerX: _core_util_Percent__WEBPACK_IMPORTED_MODULE_3__.p100,
            populateText: true
        });
        {
            const rule = r("Label", ["legend", "value", "label"]).states.create("disabled", {});
            setColor(rule, "fill", ic, "disabled");
        }
        /**
         * ------------------------------------------------------------------------
         * core: HeatLegend
         * ------------------------------------------------------------------------
         */
        r("HeatLegend").setAll({
            stepCount: 1
        });
        r("RoundedRectangle", ["heatlegend", "marker"]).setAll({
            cornerRadiusTR: 0,
            cornerRadiusBR: 0,
            cornerRadiusTL: 0,
            cornerRadiusBL: 0
        });
        r("RoundedRectangle", ["vertical", "heatlegend", "marker"]).setAll({
            height: _core_util_Percent__WEBPACK_IMPORTED_MODULE_3__.p100,
            width: 15
        });
        r("RoundedRectangle", ["horizontal", "heatlegend", "marker"]).setAll({
            width: _core_util_Percent__WEBPACK_IMPORTED_MODULE_3__.p100,
            height: 15
        });
        r("HeatLegend", ["vertical"]).setAll({
            height: _core_util_Percent__WEBPACK_IMPORTED_MODULE_3__.p100
        });
        r("HeatLegend", ["horizontal"]).setAll({
            width: _core_util_Percent__WEBPACK_IMPORTED_MODULE_3__.p100
        });
        r("Label", ["heatlegend", "start"]).setAll({
            paddingLeft: 5,
            paddingRight: 5,
            paddingTop: 5,
            paddingBottom: 5
        });
        r("Label", ["heatlegend", "end"]).setAll({
            paddingLeft: 5,
            paddingRight: 5,
            paddingTop: 5,
            paddingBottom: 5
        });
        /**
         * ------------------------------------------------------------------------
         * core: Labels
         * ------------------------------------------------------------------------
         */
        {
            const rule = r("Label");
            rule.setAll({
                paddingTop: 8,
                paddingBottom: 8,
                paddingLeft: 10,
                paddingRight: 10,
                fontFamily: "-apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, Helvetica, Arial, sans-serif, \"Apple Color Emoji\", \"Segoe UI Emoji\", \"Segoe UI Symbol\"",
                fontSize: "1em",
                populateText: false
            });
            setColor(rule, "fill", ic, "text");
        }
        r("RadialLabel").setAll({
            textType: "regular",
            centerY: _core_util_Percent__WEBPACK_IMPORTED_MODULE_3__.p50,
            centerX: _core_util_Percent__WEBPACK_IMPORTED_MODULE_3__.p50,
            inside: false,
            radius: 0,
            baseRadius: _core_util_Percent__WEBPACK_IMPORTED_MODULE_3__.p100,
            orientation: "auto",
            textAlign: "center"
        });
        /**
         * ------------------------------------------------------------------------
         * core: Elements and shapes
         * ------------------------------------------------------------------------
         */
        r("RoundedRectangle").setAll({
            cornerRadiusTL: 8,
            cornerRadiusBL: 8,
            cornerRadiusTR: 8,
            cornerRadiusBR: 8
        });
        r("PointedRectangle").setAll({
            pointerBaseWidth: 15,
            pointerLength: 10,
            cornerRadius: 8
        });
        r("Slice").setAll({
            shiftRadius: 0,
            dRadius: 0,
            dInnerRadius: 0
        });
        {
            const rule = r("Tick");
            rule.setAll({
                strokeOpacity: .15,
                isMeasured: false,
                length: 4.5,
                position: "absolute",
                crisp: true
            });
            setColor(rule, "stroke", ic, "grid");
        }
        r("Bullet").setAll({
            locationX: 0.5,
            locationY: 0.5
        });
        /**
         * ------------------------------------------------------------------------
         * core: Tooltip
         * ------------------------------------------------------------------------
         */
        r("Tooltip").setAll({
            position: "absolute",
            getFillFromSprite: true,
            getStrokeFromSprite: false,
            autoTextColor: true,
            paddingTop: 9,
            paddingBottom: 8,
            paddingLeft: 10,
            paddingRight: 10,
            marginBottom: 5,
            pointerOrientation: "vertical",
            centerX: _core_util_Percent__WEBPACK_IMPORTED_MODULE_3__.p50,
            centerY: _core_util_Percent__WEBPACK_IMPORTED_MODULE_3__.p50,
            animationEasing: _core_util_Ease__WEBPACK_IMPORTED_MODULE_2__.out(_core_util_Ease__WEBPACK_IMPORTED_MODULE_2__.cubic),
            exportable: false
            //layer: 100
        });
        r("Polygon").setAll({
            animationEasing: _core_util_Ease__WEBPACK_IMPORTED_MODULE_2__.out(_core_util_Ease__WEBPACK_IMPORTED_MODULE_2__.cubic),
        });
        {
            const rule = r("PointedRectangle", ["tooltip", "background"]);
            rule.setAll({
                strokeOpacity: 0.9,
                cornerRadius: 4,
                pointerLength: 4,
                pointerBaseWidth: 8,
                fillOpacity: 0.9,
                stroke: _core_util_Color__WEBPACK_IMPORTED_MODULE_1__.Color.fromHex(0xffffff)
            });
        }
        {
            const rule = r("Label", ["tooltip"]);
            rule.setAll({
                role: "tooltip",
                populateText: true,
                paddingRight: 0,
                paddingTop: 0,
                paddingLeft: 0,
                paddingBottom: 0
            });
            setColor(rule, "fill", ic, "alternativeText");
        }
        /**
         * ------------------------------------------------------------------------
         * core: Button
         * ------------------------------------------------------------------------
         */
        r("Button").setAll({
            paddingTop: 8,
            paddingBottom: 8,
            paddingLeft: 10,
            paddingRight: 10,
            interactive: true,
            layout: horizontalLayout,
            interactiveChildren: false,
            setStateOnChildren: true,
            focusable: true
        });
        r("Button").states.create("hover", {});
        r("Button").states.create("down", { stateAnimationDuration: 0 });
        r("Button").states.create("active", {});
        {
            const rule = r("RoundedRectangle", ["button", "background"]);
            setColor(rule, "fill", ic, "primaryButton");
            setColor(rule, "stroke", ic, "primaryButtonStroke");
        }
        {
            const rule = r("RoundedRectangle", ["button", "background"]).states.create("hover", {});
            setColor(rule, "fill", ic, "primaryButtonHover");
        }
        {
            const rule = r("RoundedRectangle", ["button", "background"]).states.create("down", { stateAnimationDuration: 0 });
            setColor(rule, "fill", ic, "primaryButtonDown");
        }
        {
            const rule = r("RoundedRectangle", ["button", "background"]).states.create("active", {});
            setColor(rule, "fill", ic, "primaryButtonActive");
        }
        {
            const rule = r("Graphics", ["button", "icon"]);
            setColor(rule, "stroke", ic, "primaryButtonText");
        }
        {
            const rule = r("Label", ["button"]);
            setColor(rule, "fill", ic, "primaryButtonText");
        }
        /**
         * ------------------------------------------------------------------------
         * charts/xy: ZoomOutButton
         * ------------------------------------------------------------------------
         */
        r("Button", ["zoom"]).setAll({
            paddingTop: 18,
            paddingBottom: 18,
            paddingLeft: 12,
            paddingRight: 12,
            centerX: 46,
            centerY: -10,
            y: 0,
            x: _core_util_Percent__WEBPACK_IMPORTED_MODULE_3__.p100,
            role: "button",
            ariaLabel: language.translate("Zoom Out"),
            layer: 30
        });
        {
            const rule = r("RoundedRectangle", ["background", "button", "zoom"]);
            rule.setAll({
                cornerRadiusBL: 40,
                cornerRadiusBR: 40,
                cornerRadiusTL: 40,
                cornerRadiusTR: 40
            });
            setColor(rule, "fill", ic, "primaryButton");
        }
        {
            const rule = r("RoundedRectangle", ["background", "button", "zoom"]).states.create("hover", {});
            setColor(rule, "fill", ic, "primaryButtonHover");
        }
        {
            const rule = r("RoundedRectangle", ["background", "button", "zoom"]).states.create("down", { stateAnimationDuration: 0 });
            setColor(rule, "fill", ic, "primaryButtonDown");
        }
        {
            const rule = r("Graphics", ["icon", "button", "zoom"]);
            rule.setAll({
                crisp: true,
                strokeOpacity: 0.7,
                draw: (display) => {
                    display.moveTo(0, 0);
                    display.lineTo(12, 0);
                }
            });
            setColor(rule, "stroke", ic, "primaryButtonText");
        }
        /**
         * ------------------------------------------------------------------------
         * core: ResizeButton
         * ------------------------------------------------------------------------
         */
        r("Button", ["resize"]).setAll({
            paddingTop: 9,
            paddingBottom: 9,
            paddingLeft: 13,
            paddingRight: 13,
            draggable: true,
            centerX: _core_util_Percent__WEBPACK_IMPORTED_MODULE_3__.p50,
            centerY: _core_util_Percent__WEBPACK_IMPORTED_MODULE_3__.p50,
            position: "absolute",
            role: "slider",
            ariaValueMin: "0",
            ariaValueMax: "100",
            ariaLabel: language.translate("Use up and down arrows to move selection")
        });
        {
            const rule = r("RoundedRectangle", ["background", "resize", "button"]);
            rule.setAll({
                cornerRadiusBL: 40,
                cornerRadiusBR: 40,
                cornerRadiusTL: 40,
                cornerRadiusTR: 40
            });
            setColor(rule, "fill", ic, "secondaryButton");
            setColor(rule, "stroke", ic, "secondaryButtonStroke");
        }
        {
            const rule = r("RoundedRectangle", ["background", "resize", "button"]).states.create("hover", {});
            setColor(rule, "fill", ic, "secondaryButtonHover");
        }
        {
            const rule = r("RoundedRectangle", ["background", "resize", "button"]).states.create("down", { stateAnimationDuration: 0 });
            setColor(rule, "fill", ic, "secondaryButtonDown");
        }
        {
            const rule = r("Graphics", ["resize", "button", "icon"]);
            rule.setAll({
                interactive: false,
                crisp: true,
                strokeOpacity: 0.5,
                draw: (display) => {
                    display.moveTo(0, 0.5);
                    display.lineTo(0, 12.5);
                    display.moveTo(4, 0.5);
                    display.lineTo(4, 12.5);
                }
            });
            setColor(rule, "stroke", ic, "secondaryButtonText");
        }
        r("Button", ["resize", "vertical"]).setAll({
            rotation: 90,
            cursorOverStyle: "ns-resize"
        });
        r("Button", ["resize", "horizontal"]).setAll({
            cursorOverStyle: "ew-resize"
        });
        /**
         * ------------------------------------------------------------------------
         * core: PlayButton
         * ------------------------------------------------------------------------
         */
        r("Button", ["play"]).setAll({
            paddingTop: 13,
            paddingBottom: 13,
            paddingLeft: 14,
            paddingRight: 14,
            ariaLabel: language.translate("Play"),
            toggleKey: "active"
        });
        {
            const rule = r("RoundedRectangle", ["play", "background"]);
            rule.setAll({
                strokeOpacity: 0.5,
                cornerRadiusBL: 100,
                cornerRadiusBR: 100,
                cornerRadiusTL: 100,
                cornerRadiusTR: 100
            });
            setColor(rule, "fill", ic, "primaryButton");
        }
        {
            const rule = r("Graphics", ["play", "icon"]);
            rule.setAll({
                stateAnimationDuration: 0,
                dx: 1,
                draw: (display) => {
                    display.moveTo(0, -5);
                    display.lineTo(8, 0);
                    display.lineTo(0, 5);
                    display.lineTo(0, -5);
                }
            });
            setColor(rule, "fill", ic, "primaryButtonText");
        }
        r("Graphics", ["play", "icon"]).states.create("default", {
            stateAnimationDuration: 0
        });
        r("Graphics", ["play", "icon"]).states.create("active", {
            stateAnimationDuration: 0,
            draw: (display) => {
                display.moveTo(-4, -5);
                display.lineTo(-1, -5);
                display.lineTo(-1, 5);
                display.lineTo(-4, 5);
                display.lineTo(-4, -5);
                display.moveTo(4, -5);
                display.lineTo(1, -5);
                display.lineTo(1, 5);
                display.lineTo(4, 5);
                display.lineTo(4, -5);
            }
        });
        /**
         * ------------------------------------------------------------------------
         * core: SwitchButton
         * ------------------------------------------------------------------------
         */
        r("Button", ["switch"]).setAll({
            paddingTop: 4,
            paddingBottom: 4,
            paddingLeft: 4,
            paddingRight: 4,
            ariaLabel: language.translate("Press ENTER to toggle"),
            toggleKey: "active",
            width: 40,
            height: 24,
            layout: null
        });
        {
            const rule = r("RoundedRectangle", ["switch", "background"]);
            rule.setAll({
                strokeOpacity: 0.5,
                cornerRadiusBL: 100,
                cornerRadiusBR: 100,
                cornerRadiusTL: 100,
                cornerRadiusTR: 100
            });
            setColor(rule, "fill", ic, "primaryButton");
        }
        {
            const rule = r("Circle", ["switch", "icon"]);
            rule.setAll({
                radius: 8,
                centerY: 0,
                centerX: 0,
                dx: 0
            });
            setColor(rule, "fill", ic, "primaryButtonText");
        }
        r("Graphics", ["switch", "icon"]).states.create("active", {
            dx: 16
        });
        /**
         * ------------------------------------------------------------------------
         * core: Scrollbar
         * ------------------------------------------------------------------------
         */
        r("Scrollbar").setAll({
            start: 0,
            end: 1,
            layer: 30,
            animationEasing: _core_util_Ease__WEBPACK_IMPORTED_MODULE_2__.out(_core_util_Ease__WEBPACK_IMPORTED_MODULE_2__.cubic)
        });
        r("Scrollbar", ["vertical"]).setAll({
            marginRight: 13,
            marginLeft: 13,
            minWidth: 12,
            height: _core_util_Percent__WEBPACK_IMPORTED_MODULE_3__.p100
        });
        r("Scrollbar", ["horizontal"]).setAll({
            marginTop: 13,
            marginBottom: 13,
            minHeight: 12,
            width: _core_util_Percent__WEBPACK_IMPORTED_MODULE_3__.p100
        });
        this.rule("Button", ["scrollbar"]).setAll({
            exportable: false
        });
        {
            const rule = r("RoundedRectangle", ["scrollbar", "main", "background"]);
            rule.setAll({
                cornerRadiusTL: 8,
                cornerRadiusBL: 8,
                cornerRadiusTR: 8,
                cornerRadiusBR: 8,
                fillOpacity: 0.8,
            });
            setColor(rule, "fill", ic, "fill");
        }
        {
            const rule = r("RoundedRectangle", ["scrollbar", "thumb"]);
            rule.setAll({
                role: "slider",
                ariaLive: "polite",
                position: "absolute",
                draggable: true
            });
            setColor(rule, "fill", ic, "secondaryButton");
        }
        {
            const rule = r("RoundedRectangle", ["scrollbar", "thumb"]).states.create("hover", {});
            setColor(rule, "fill", ic, "secondaryButtonHover");
        }
        {
            const rule = r("RoundedRectangle", ["scrollbar", "thumb"]).states.create("down", { stateAnimationDuration: 0 });
            setColor(rule, "fill", ic, "secondaryButtonDown");
        }
        r("RoundedRectangle", ["scrollbar", "thumb", "vertical"]).setAll({
            x: _core_util_Percent__WEBPACK_IMPORTED_MODULE_3__.p50,
            width: _core_util_Percent__WEBPACK_IMPORTED_MODULE_3__.p100,
            centerX: _core_util_Percent__WEBPACK_IMPORTED_MODULE_3__.p50,
            ariaLabel: language.translate("Use up and down arrows to move selection")
        });
        r("RoundedRectangle", ["scrollbar", "thumb", "horizontal"]).setAll({
            y: _core_util_Percent__WEBPACK_IMPORTED_MODULE_3__.p50,
            centerY: _core_util_Percent__WEBPACK_IMPORTED_MODULE_3__.p50,
            height: _core_util_Percent__WEBPACK_IMPORTED_MODULE_3__.p100,
            ariaLabel: language.translate("Use left and right arrows to move selection")
        });
        // @todo: is this needed? used to be "ContentScrollbar"
        // r("Scrollbar", ["content?"]).setAll({
        // 	marginRight: 0,
        // 	marginLeft: 5,
        // 	layer: 5
        // });
        /**
         * ========================================================================
         * charts/xy
         * ========================================================================
         *
         * This needs to be in DefaultTheme because it's the only theme that is
         * automatically applied to Root, and tooltips different ancestors
         * than actual charts using them.
         */
        {
            const rule = r("PointedRectangle", ["axis", "tooltip", "background"]);
            rule.setAll({
                cornerRadius: 0
            });
            setColor(rule, "fill", ic, "alternativeBackground");
        }
        r("Label", ["axis", "tooltip"]).setAll({
            role: undefined
        });
        r("Label", ["axis", "tooltip", "y"]).setAll({
            textAlign: "right"
        });
        r("Label", ["axis", "tooltip", "y", "opposite"]).setAll({
            textAlign: "left"
        });
        r("Label", ["axis", "tooltip", "x"]).setAll({
            textAlign: "center"
        });
        r("Tooltip", ["categoryaxis"]).setAll({
            labelText: "{category}"
        });
        /**
         * ------------------------------------------------------------------------
         * Shapes
         * ------------------------------------------------------------------------
         */
        // Class: Graphics
        r("Star").setAll({
            spikes: 5,
            innerRadius: 5,
            radius: 10
        });
        // STOCK
        r("Tooltip", ["stock"]).setAll({
            paddingTop: 6,
            paddingBottom: 5,
            paddingLeft: 7,
            paddingRight: 7
        });
        r("PointedRectangle", ["tooltip", "stock", "axis"]).setAll({
            pointerLength: 0,
            pointerBaseWidth: 0,
            cornerRadius: 3
        });
        r("Label", ["tooltip", "stock"]).setAll({
            fontSize: "0.8em"
        });
        // resizer
        r("SpriteResizer").setAll({
            rotationStep: 10
        });
        {
            const rule = r("Container", ["resizer", "grip"]);
            rule.states.create("hover", {});
        }
        {
            const rule = r("RoundedRectangle", ["resizer", "grip"]);
            rule.setAll({
                strokeOpacity: 0.7,
                strokeWidth: 1,
                fillOpacity: 1,
                width: 12,
                height: 12
            });
            setColor(rule, "fill", ic, "background");
            setColor(rule, "stroke", ic, "alternativeBackground");
        }
        {
            const rule = r("RoundedRectangle", ["resizer", "grip", "outline"]);
            rule.setAll({
                strokeOpacity: 0,
                fillOpacity: 0,
                width: 20,
                height: 20
            });
            rule.states.create("hover", {
                fillOpacity: 0.3
            });
            setColor(rule, "fill", ic, "alternativeBackground");
        }
        r("RoundedRectangle", ["resizer", "grip", "left"]).setAll({
            cornerRadiusBL: 0,
            cornerRadiusBR: 0,
            cornerRadiusTL: 0,
            cornerRadiusTR: 0
        });
        r("RoundedRectangle", ["resizer", "grip", "right"]).setAll({
            cornerRadiusBL: 0,
            cornerRadiusBR: 0,
            cornerRadiusTL: 0,
            cornerRadiusTR: 0
        });
        {
            const rule = r("Rectangle", ["resizer", "rectangle"]);
            rule.setAll({
                strokeDasharray: [2, 2],
                strokeOpacity: 0.5,
                strokeWidth: 1
            });
            setColor(rule, "stroke", ic, "alternativeBackground");
        }
    }
}
//# sourceMappingURL=DefaultTheme.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/themes/ResponsiveTheme.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/themes/ResponsiveTheme.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ResponsiveTheme: () => (/* binding */ ResponsiveTheme)
/* harmony export */ });
/* harmony import */ var _core_Theme__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Theme */ "./node_modules/@amcharts/amcharts5/.internal/core/Theme.js");
/* harmony import */ var _core_util_Disposer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/util/Disposer */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Disposer.js");
/* harmony import */ var _core_util_Percent__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../core/util/Percent */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Percent.js");
/* harmony import */ var _core_util_Array__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/util/Array */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Array.js");




/**
 * A configurable theme that dynamically adapts chart settings for best fit
 * in available space.
 *
 * @see {@link https://www.amcharts.com/docs/v5/concepts/responsive/} for more info
 */
class ResponsiveTheme extends _core_Theme__WEBPACK_IMPORTED_MODULE_0__.Theme {
    constructor(root, isReal) {
        super(root, isReal);
        Object.defineProperty(this, "_dp", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /**
         * Currently added rules.
         */
        Object.defineProperty(this, "responsiveRules", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
        });
        this._dp = new _core_util_Disposer__WEBPACK_IMPORTED_MODULE_1__.MultiDisposer([
            this._root._rootContainer.onPrivate("width", (_width) => {
                if (this._isUsed()) {
                    this._maybeApplyRules();
                }
            }),
            this._root._rootContainer.onPrivate("height", (_height) => {
                if (this._isUsed()) {
                    this._maybeApplyRules();
                }
            })
        ]);
    }
    // Breakpoint functions (for use in `relevant` clause of the responsive rules)
    static widthXXS(width, _height) {
        return width <= ResponsiveTheme.XXS;
    }
    static widthXS(width, _height) {
        return width <= ResponsiveTheme.XS;
    }
    static widthS(width, _height) {
        return width <= ResponsiveTheme.S;
    }
    static widthM(width, _height) {
        return width <= ResponsiveTheme.M;
    }
    static widthL(width, _height) {
        return width <= ResponsiveTheme.L;
    }
    static widthXL(width, _height) {
        return width <= ResponsiveTheme.XL;
    }
    static widthXXL(width, _height) {
        return width <= ResponsiveTheme.XXL;
    }
    static heightXXS(_width, height) {
        return height <= ResponsiveTheme.XXS;
    }
    static heightXS(_width, height) {
        return height <= ResponsiveTheme.XS;
    }
    static heightS(_width, height) {
        return height <= ResponsiveTheme.S;
    }
    static heightM(_width, height) {
        return height <= ResponsiveTheme.M;
    }
    static heightL(_width, height) {
        return height <= ResponsiveTheme.L;
    }
    static heightXL(_width, height) {
        return height <= ResponsiveTheme.XL;
    }
    static heightXXL(_width, height) {
        return height <= ResponsiveTheme.XXL;
    }
    static isXXS(width, height) {
        return (width <= ResponsiveTheme.XXS) && (height <= ResponsiveTheme.XXS);
    }
    static isXS(width, height) {
        return (width <= ResponsiveTheme.XS) && (height <= ResponsiveTheme.XS);
    }
    static isS(width, height) {
        return (width <= ResponsiveTheme.S) && (height <= ResponsiveTheme.S);
    }
    static isM(width, height) {
        return (width <= ResponsiveTheme.M) && (height <= ResponsiveTheme.M);
    }
    static isL(width, height) {
        return (width <= ResponsiveTheme.L) && (height <= ResponsiveTheme.L);
    }
    static isXL(width, height) {
        return (width <= ResponsiveTheme.XL) && (height <= ResponsiveTheme.XL);
    }
    static isXXL(width, height) {
        return (width <= ResponsiveTheme.XXL) && (height <= ResponsiveTheme.XXL);
    }
    static maybeXXS(width, height) {
        return (width <= ResponsiveTheme.XXS) || (height <= ResponsiveTheme.XXS);
    }
    static maybeXS(width, height) {
        return (width <= ResponsiveTheme.XS) || (height <= ResponsiveTheme.XS);
    }
    static maybeS(width, height) {
        return (width <= ResponsiveTheme.S) || (height <= ResponsiveTheme.S);
    }
    static maybeM(width, height) {
        return (width <= ResponsiveTheme.M) || (height <= ResponsiveTheme.M);
    }
    static maybeL(width, height) {
        return (width <= ResponsiveTheme.L) || (height <= ResponsiveTheme.L);
    }
    static maybeXL(width, height) {
        return (width <= ResponsiveTheme.XL) || (height <= ResponsiveTheme.XL);
    }
    static maybeXXL(width, height) {
        return (width <= ResponsiveTheme.XXL) || (height <= ResponsiveTheme.XXL);
    }
    /**
     * Instantiates the theme without adding default respomsive rules.
     */
    static newEmpty(root) {
        return (new this(root, true));
    }
    /**
     * Adds a responsive rule as well as retuns it.
     *
     * @see {@link https://www.amcharts.com/docs/v5/concepts/responsive/} for more info
     * @param   rule  Responsive rule
     * @return        Responsive rule
     */
    addRule(rule) {
        if (rule.name && !rule.template) {
            rule.template = this.rule(rule.name, rule.tags);
        }
        this.responsiveRules.push(rule);
        this._maybeApplyRule(rule);
        return rule;
    }
    /**
     * Removes the responsive rule.
     *
     * @param  rule  Responsive rule
     */
    removeRule(rule) {
        _core_util_Array__WEBPACK_IMPORTED_MODULE_2__.remove(this.responsiveRules, rule);
    }
    dispose() {
        if (this._dp) {
            this._dp.dispose();
        }
    }
    _isUsed() {
        return this._root._rootContainer.get("themes").indexOf(this) !== -1;
    }
    _maybeApplyRules() {
        _core_util_Array__WEBPACK_IMPORTED_MODULE_2__.each(this.responsiveRules, (rule) => {
            this._maybeUnapplyRule(rule);
        });
        _core_util_Array__WEBPACK_IMPORTED_MODULE_2__.each(this.responsiveRules, (rule) => {
            this._maybeApplyRule(rule);
        });
    }
    _maybeApplyRule(rule) {
        if (rule.applied)
            return;
        const w = this._root._rootContainer.getPrivate("width");
        const h = this._root._rootContainer.getPrivate("height");
        const relevant = rule.relevant.call(rule, w, h);
        if (relevant) {
            rule.applied = true;
            if (rule.template && rule.settings) {
                rule.template.setAll(rule.settings);
            }
            if (rule.applying) {
                rule.applying.call(rule);
            }
        }
    }
    _maybeUnapplyRule(rule) {
        if (!rule.applied)
            return;
        const w = this._root._rootContainer.getPrivate("width");
        const h = this._root._rootContainer.getPrivate("height");
        const relevant = rule.relevant.call(rule, w, h);
        if (!relevant) {
            rule.applied = false;
            if (rule.template) {
                rule.template.removeAll();
            }
            if (rule.removing) {
                rule.removing.call(rule);
            }
        }
    }
    /**
     * Adds default rules for various chart types and most standard scenarios.
     */
    setupDefaultRules() {
        super.setupDefaultRules();
        const addRule = (rule) => this.addRule(rule);
        /**
         * ========================================================================
         * Universal
         * ========================================================================
         */
        addRule({
            name: "Chart",
            relevant: ResponsiveTheme.widthXXS,
            settings: {
                paddingLeft: 0,
                paddingRight: 0
            }
        });
        addRule({
            name: "Chart",
            relevant: ResponsiveTheme.heightXXS,
            settings: {
                paddingTop: 0,
                paddingBottom: 0
            }
        });
        addRule({
            name: "Bullet",
            relevant: ResponsiveTheme.isXS,
            settings: {
                forceHidden: true
            }
        });
        addRule({
            name: "Legend",
            relevant: ResponsiveTheme.isXS,
            settings: {
                forceHidden: true
            }
        });
        addRule({
            name: "HeatLegend",
            tags: ["vertical"],
            relevant: ResponsiveTheme.widthXS,
            settings: {
                forceHidden: true
            }
        });
        addRule({
            name: "HeatLegend",
            tags: ["horizontal"],
            relevant: ResponsiveTheme.heightXS,
            settings: {
                forceHidden: true
            }
        });
        addRule({
            name: "Label",
            tags: ["heatlegend", "start"],
            relevant: ResponsiveTheme.maybeXS,
            settings: {
                forceHidden: true
            }
        });
        addRule({
            name: "Label",
            tags: ["heatlegend", "end"],
            relevant: ResponsiveTheme.maybeXS,
            settings: {
                forceHidden: true
            }
        });
        addRule({
            name: "Button",
            tags: ["resize"],
            relevant: ResponsiveTheme.maybeXS,
            settings: {
                forceHidden: true
            }
        });
        /**
         * ========================================================================
         * XY
         * ========================================================================
         */
        addRule({
            name: "AxisRendererX",
            relevant: ResponsiveTheme.heightXS,
            settings: {
                inside: true
            }
        });
        addRule({
            name: "AxisRendererY",
            relevant: ResponsiveTheme.widthXS,
            settings: {
                inside: true
            }
        });
        addRule({
            name: "AxisRendererXLabel",
            relevant: ResponsiveTheme.heightXS,
            settings: {
                minPosition: 0.1,
                maxPosition: 0.9
            }
        });
        addRule({
            name: "AxisLabel",
            tags: ["y"],
            relevant: ResponsiveTheme.widthXS,
            settings: {
                centerY: _core_util_Percent__WEBPACK_IMPORTED_MODULE_3__.p100,
                maxPosition: 0.9
            }
        });
        addRule({
            name: "AxisLabel",
            tags: ["x"],
            relevant: ResponsiveTheme.heightXXS,
            settings: {
                forceHidden: true
            }
        });
        addRule({
            name: "AxisLabel",
            tags: ["x", "minor"],
            relevant: ResponsiveTheme.widthXXL,
            settings: {
                forceHidden: true
            }
        });
        addRule({
            name: "AxisLabel",
            tags: ["y"],
            relevant: ResponsiveTheme.widthXXS,
            settings: {
                forceHidden: true
            }
        });
        addRule({
            name: "AxisLabel",
            tags: ["y", "minor"],
            relevant: ResponsiveTheme.heightXXL,
            settings: {
                forceHidden: true
            }
        });
        addRule({
            name: "AxisTick",
            tags: ["x"],
            relevant: ResponsiveTheme.heightXS,
            settings: {
                inside: true,
                minPosition: 0.1,
                maxPosition: 0.9
            }
        });
        addRule({
            name: "AxisTick",
            tags: ["y"],
            relevant: ResponsiveTheme.widthXXS,
            settings: {
                inside: true,
                minPosition: 0.1,
                maxPosition: 0.9
            }
        });
        addRule({
            name: "Grid",
            relevant: ResponsiveTheme.maybeXXS,
            settings: {
                forceHidden: true
            }
        });
        /**
         * ========================================================================
         * Radar
         * ========================================================================
         */
        addRule({
            name: "RadialLabel",
            tags: ["radial"],
            relevant: ResponsiveTheme.maybeXS,
            settings: {
                forceHidden: true
            }
        });
        addRule({
            name: "RadialLabel",
            tags: ["circular"],
            relevant: ResponsiveTheme.maybeS,
            settings: {
                inside: true
            }
        });
        addRule({
            name: "AxisTick",
            relevant: ResponsiveTheme.maybeS,
            settings: {
                inside: true
            }
        });
        addRule({
            name: "RadialLabel",
            tags: ["circular"],
            relevant: ResponsiveTheme.maybeXS,
            settings: {
                forceHidden: true
            }
        });
        addRule({
            name: "AxisTick",
            tags: ["circular"],
            relevant: ResponsiveTheme.maybeXS,
            settings: {
                inside: true
            }
        });
        /**
         * ========================================================================
         * Pie
         * ========================================================================
         */
        addRule({
            name: "PieChart",
            relevant: ResponsiveTheme.maybeXS,
            settings: {
                radius: (0,_core_util_Percent__WEBPACK_IMPORTED_MODULE_3__.percent)(99)
            }
        });
        addRule({
            name: "PieChart",
            relevant: ResponsiveTheme.widthM,
            settings: {
                radius: (0,_core_util_Percent__WEBPACK_IMPORTED_MODULE_3__.percent)(99)
            }
        });
        addRule({
            name: "RadialLabel",
            tags: ["pie"],
            relevant: ResponsiveTheme.maybeXS,
            settings: {
                forceHidden: true
            }
        });
        addRule({
            name: "RadialLabel",
            tags: ["pie"],
            relevant: ResponsiveTheme.widthM,
            settings: {
                forceHidden: true
            }
        });
        addRule({
            name: "Tick",
            tags: ["pie"],
            relevant: ResponsiveTheme.maybeXS,
            settings: {
                forceHidden: true
            }
        });
        addRule({
            name: "Tick",
            tags: ["pie"],
            relevant: ResponsiveTheme.widthM,
            settings: {
                forceHidden: true
            }
        });
        /**
         * ========================================================================
         * Funnel
         * ========================================================================
         */
        addRule({
            name: "FunnelSeries",
            relevant: ResponsiveTheme.widthM,
            settings: {
                alignLabels: false
            }
        });
        addRule({
            name: "Label",
            tags: ["funnel", "vertical"],
            relevant: ResponsiveTheme.widthL,
            settings: {
                forceHidden: true
            }
        });
        addRule({
            name: "Tick",
            tags: ["funnel", "vertical"],
            relevant: ResponsiveTheme.widthL,
            settings: {
                forceHidden: true
            }
        });
        addRule({
            name: "Label",
            tags: ["funnel", "horizontal"],
            relevant: ResponsiveTheme.heightS,
            settings: {
                forceHidden: true
            }
        });
        addRule({
            name: "Tick",
            tags: ["funnel", "horizontal"],
            relevant: ResponsiveTheme.heightS,
            settings: {
                forceHidden: true
            }
        });
        /**
         * ========================================================================
         * Pyramid
         * ========================================================================
         */
        addRule({
            name: "PyramidSeries",
            relevant: ResponsiveTheme.widthM,
            settings: {
                alignLabels: false
            }
        });
        addRule({
            name: "Label",
            tags: ["pyramid", "vertical"],
            relevant: ResponsiveTheme.widthL,
            settings: {
                forceHidden: true
            }
        });
        addRule({
            name: "Tick",
            tags: ["pyramid", "vertical"],
            relevant: ResponsiveTheme.widthL,
            settings: {
                forceHidden: true
            }
        });
        addRule({
            name: "Label",
            tags: ["pyramid", "horizontal"],
            relevant: ResponsiveTheme.heightS,
            settings: {
                forceHidden: true
            }
        });
        addRule({
            name: "Tick",
            tags: ["pyramid", "horizontal"],
            relevant: ResponsiveTheme.heightS,
            settings: {
                forceHidden: true
            }
        });
        /**
         * ========================================================================
         * Pictorial
         * ========================================================================
         */
        addRule({
            name: "PictorialStackedSeries",
            relevant: ResponsiveTheme.widthM,
            settings: {
                alignLabels: false
            }
        });
        addRule({
            name: "Label",
            tags: ["pictorial", "vertical"],
            relevant: ResponsiveTheme.widthL,
            settings: {
                forceHidden: true
            }
        });
        addRule({
            name: "Tick",
            tags: ["pictorial", "vertical"],
            relevant: ResponsiveTheme.widthL,
            settings: {
                forceHidden: true
            }
        });
        addRule({
            name: "Label",
            tags: ["pictorial", "horizontal"],
            relevant: ResponsiveTheme.heightS,
            settings: {
                forceHidden: true
            }
        });
        addRule({
            name: "Tick",
            tags: ["pictorial", "horizontal"],
            relevant: ResponsiveTheme.heightS,
            settings: {
                forceHidden: true
            }
        });
        /**
         * ========================================================================
         * Map
         * ========================================================================
         */
        // Nothing to do here
        /**
         * ========================================================================
         * Flow (Sankey+Chord)
         * ========================================================================
         */
        addRule({
            name: "Label",
            tags: ["flow", "horizontal"],
            relevant: ResponsiveTheme.widthS,
            settings: {
                forceHidden: true
            }
        });
        addRule({
            name: "Label",
            tags: ["flow", "vertical"],
            relevant: ResponsiveTheme.heightS,
            settings: {
                forceHidden: true
            }
        });
        addRule({
            name: "Chord",
            relevant: ResponsiveTheme.maybeXS,
            settings: {
                radius: (0,_core_util_Percent__WEBPACK_IMPORTED_MODULE_3__.percent)(99)
            }
        });
        /**
         * ========================================================================
         * Hierarchy (Treemap, Partition, Sunburst, Pack, ForceDirected)
         * ========================================================================
         */
        addRule({
            name: "Label",
            tags: ["hierarchy", "node"],
            relevant: ResponsiveTheme.maybeXS,
            settings: {
                forceHidden: true
            }
        });
    }
}
// Named pixel breakpoints
Object.defineProperty(ResponsiveTheme, "XXS", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: 100
});
Object.defineProperty(ResponsiveTheme, "XS", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: 200
});
Object.defineProperty(ResponsiveTheme, "S", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: 300
});
Object.defineProperty(ResponsiveTheme, "M", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: 400
});
Object.defineProperty(ResponsiveTheme, "L", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: 600
});
Object.defineProperty(ResponsiveTheme, "XL", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: 800
});
Object.defineProperty(ResponsiveTheme, "XXL", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: 1000
});
//# sourceMappingURL=ResponsiveTheme.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/locales/en.js":
/*!********************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/locales/en.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * amCharts 5 locale
 *
 * Locale: en
 * Language: International English
 * Author: Martynas Majeris
 *
 * Follow instructions in [on this page](https://www.amcharts.com/docs/v5/tutorials/creating-translations/) to make corrections or add new translations.
 *
 * ---
 * Edit but leave the header section above this line. You can remove any
 * subsequent comment sections.
 * ---
 *
 * Use this file as a template to create translations. Leave the key part in
 * English intact. Fill the value with a translation.
 *
 * Empty string means no translation, so default "International English"
 * will be used.
 *
 * If you need the translation to literally be an empty string, use `null`
 * instead.
 *
 * IMPORTANT:
 * When translating make good effort to keep the translation length
 * at least the same chartcount as the English, especially for short prompts.
 *
 * Having significantly longer prompts may distort the actual charts.
 *
 * NOTE:
 * Some prompts - like months or weekdays - come in two versions: full and
 * shortened.
 *
 * If there's no official shortened version of these in your language, and it
 * would not be possible to invent such short versions that don't seem weird
 * to native speakers of that language, fill those with the same as full
 * version.
 *
 * PLACEHOLDERS:
 * Some prompts have placeholders like "%1". Those will be replaced by actual
 * values during translation and should be retained in the translated prompts.
 *
 * Placeholder positions may be changed to better suit structure of the
 * sentence.
 *
 * For example "From %1 to %2", when actually used will replace "%1" with an
 * actual value representing range start, and "%2" will be replaced by end
 * value.
 *
 * E.g. in a Scrollbar for Value axis "From %1 to %2" will become
 * "From 100 to 200". You may translate "From" and "to", as well as re-arrange
 * the order of the prompt itself, but make sure the "%1" and "%2" remain, in
 * places where they will make sense.
 *
 * Save the file as language_LOCALE, i.e. `en_GB.ts`, `fr_FR.ts`, etc.
 */
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    "firstDayOfWeek": 1,
    // Number formatting options.
    // 
    // Please check with the local standards which separator is accepted to be
    // used for separating decimals, and which for thousands.
    "_decimalSeparator": ".",
    "_thousandSeparator": ",",
    // Position of the percent sign in numbers
    "_percentPrefix": null,
    "_percentSuffix": "%",
    // Suffixes for numbers
    // When formatting numbers, big or small numers might be reformatted to
    // shorter version, by applying a suffix.
    // 
    // For example, 1000000 might become "1m".
    // Or 1024 might become "1KB" if we're formatting byte numbers.
    // 
    // This section defines such suffixes for all such cases.
    "_big_number_suffix_3": "k",
    "_big_number_suffix_6": "M",
    "_big_number_suffix_9": "G",
    "_big_number_suffix_12": "T",
    "_big_number_suffix_15": "P",
    "_big_number_suffix_18": "E",
    "_big_number_suffix_21": "Z",
    "_big_number_suffix_24": "Y",
    "_small_number_suffix_3": "m",
    "_small_number_suffix_6": "μ",
    "_small_number_suffix_9": "n",
    "_small_number_suffix_12": "p",
    "_small_number_suffix_15": "f",
    "_small_number_suffix_18": "a",
    "_small_number_suffix_21": "z",
    "_small_number_suffix_24": "y",
    "_byte_suffix_B": "B",
    "_byte_suffix_KB": "KB",
    "_byte_suffix_MB": "MB",
    "_byte_suffix_GB": "GB",
    "_byte_suffix_TB": "TB",
    "_byte_suffix_PB": "PB",
    // Default date formats for various periods.
    // 
    // This should reflect official or de facto formatting universally accepted
    // in the country translation is being made for
    // Available format codes here:
    // https://www.amcharts.com/docs/v5/concepts/formatters/formatting-dates/#Format_codes
    // 
    // This will be used when formatting date/time for particular granularity,
    // e.g. "_date_hour" will be shown whenever we need to show time as hours.
    // 
    // "date" is used as in default date format when showing standalone dates.
    "_date": "yyyy-MM-dd",
    "_date_millisecond": "mm:ss SSS",
    "_date_millisecond_full": "HH:mm:ss SSS",
    "_date_second": "HH:mm:ss",
    "_date_second_full": "HH:mm:ss",
    "_date_minute": "HH:mm",
    "_date_minute_full": "HH:mm - MMM dd, yyyy",
    "_date_hour": "HH:mm",
    "_date_hour_full": "HH:mm - MMM dd, yyyy",
    "_date_day": "MMM dd",
    "_date_day_full": "MMM dd, yyyy",
    "_date_week": "ww",
    "_date_week_full": "MMM dd, yyyy",
    "_date_month": "MMM",
    "_date_month_full": "MMM, yyyy",
    "_date_year": "yyyy",
    // Default duration formats for various base units.
    // 
    // This will be used by DurationFormatter to format numeric values into
    // duration.
    // 
    // Notice how each duration unit comes in several versions. This is to ensure
    // that each base unit is shown correctly.
    // 
    // For example, if we have baseUnit set to "second", meaning our duration is
    // in seconds.
    // 
    // If we pass in `50` to formatter, it will know that we have just 50 seconds
    // (less than a minute) so it will use format in `"_duration_second"` ("ss"),
    // and the formatted result will be in like `"50"`.
    // 
    // If we pass in `70`, which is more than a minute, the formatter will switch
    // to `"_duration_second_minute"` ("mm:ss"), resulting in "01:10" formatted
    // text.
    // 
    // Available codes here:
    // https://www.amcharts.com/docs/v4/concepts/formatters/formatting-duration/#Available_Codes
    "_duration_millisecond": "SSS",
    "_duration_millisecond_second": "ss.SSS",
    "_duration_millisecond_minute": "mm:ss SSS",
    "_duration_millisecond_hour": "hh:mm:ss SSS",
    "_duration_millisecond_day": "d'd' mm:ss SSS",
    "_duration_millisecond_week": "d'd' mm:ss SSS",
    "_duration_millisecond_month": "M'm' dd'd' mm:ss SSS",
    "_duration_millisecond_year": "y'y' MM'm' dd'd' mm:ss SSS",
    "_duration_second": "ss",
    "_duration_second_minute": "mm:ss",
    "_duration_second_hour": "hh:mm:ss",
    "_duration_second_day": "d'd' hh:mm:ss",
    "_duration_second_week": "d'd' hh:mm:ss",
    "_duration_second_month": "M'm' dd'd' hh:mm:ss",
    "_duration_second_year": "y'y' MM'm' dd'd' hh:mm:ss",
    "_duration_minute": "mm",
    "_duration_minute_hour": "hh:mm",
    "_duration_minute_day": "d'd' hh:mm",
    "_duration_minute_week": "d'd' hh:mm",
    "_duration_minute_month": "M'm' dd'd' hh:mm",
    "_duration_minute_year": "y'y' MM'm' dd'd' hh:mm",
    "_duration_hour": "hh'h'",
    "_duration_hour_day": "d'd' hh'h'",
    "_duration_hour_week": "d'd' hh'h'",
    "_duration_hour_month": "M'm' dd'd' hh'h'",
    "_duration_hour_year": "y'y' MM'm' dd'd' hh'h'",
    "_duration_day": "d'd'",
    "_duration_day_week": "d'd'",
    "_duration_day_month": "M'm' dd'd'",
    "_duration_day_year": "y'y' MM'm' dd'd'",
    "_duration_week": "w'w'",
    "_duration_week_month": "w'w'",
    "_duration_week_year": "w'w'",
    "_duration_month": "M'm'",
    "_duration_month_year": "y'y' MM'm'",
    "_duration_year": "y'y'",
    // Era translations
    "_era_ad": "AD",
    "_era_bc": "BC",
    // Day part, used in 12-hour formats, e.g. 5 P.M.
    // Please note that these come in 3 variants:
    // * one letter (e.g. "A")
    // * two letters (e.g. "AM")
    // * two letters with dots (e.g. "A.M.")
    // 
    // All three need to to be translated even if they are all the same. Some
    // users might use one, some the other.
    "A": "",
    "P": "",
    "AM": "",
    "PM": "",
    "A.M.": "",
    "P.M.": "",
    // Date-related stuff.
    // 
    // When translating months, if there's a difference, use the form which is
    // best for a full date, e.g. as you would use it in "2018 January 1".
    // 
    // Note that May is listed twice. This is because in English May is the same
    // in both long and short forms, while in other languages it may not be the
    // case. Translate "May" to full word, while "May(short)" to shortened
    // version.
    // 
    // Should month names and weekdays be capitalized or not?
    // 
    // Rule of thumb is this: if the names should always be capitalized,
    // regardless of name position within date ("January", "21st January 2018",
    // etc.) use capitalized names. Otherwise enter all lowercase.
    // 
    // The date formatter will automatically capitalize names if they are the
    // first (or only) word in resulting date.
    "January": "",
    "February": "",
    "March": "",
    "April": "",
    "May": "",
    "June": "",
    "July": "",
    "August": "",
    "September": "",
    "October": "",
    "November": "",
    "December": "",
    "Jan": "",
    "Feb": "",
    "Mar": "",
    "Apr": "",
    "May(short)": "May",
    "Jun": "",
    "Jul": "",
    "Aug": "",
    "Sep": "",
    "Oct": "",
    "Nov": "",
    "Dec": "",
    // Weekdays.
    "Sunday": "",
    "Monday": "",
    "Tuesday": "",
    "Wednesday": "",
    "Thursday": "",
    "Friday": "",
    "Saturday": "",
    "Sun": "",
    "Mon": "",
    "Tue": "",
    "Wed": "",
    "Thu": "",
    "Fri": "",
    "Sat": "",
    // Date ordinal function.
    // 
    // This is used when adding number ordinal when formatting days in dates.
    // 
    // E.g. "January 1st", "February 2nd".
    // 
    // The function accepts day number, and returns a string to be added to the
    // day, like in default English translation, if we pass in 2, we will receive
    // "nd" back.
    "_dateOrd": function (day) {
        let res = "th";
        if ((day < 11) || (day > 13)) {
            switch (day % 10) {
                case 1:
                    res = "st";
                    break;
                case 2:
                    res = "nd";
                    break;
                case 3:
                    res = "rd";
                    break;
            }
        }
        return res;
    },
    // Various chart controls.
    // Shown as a tooltip on zoom out button.
    "Zoom Out": "",
    // Timeline buttons
    "Play": "",
    "Stop": "",
    // Chart's Legend screen reader title.
    "Legend": "",
    // Legend's item screen reader indicator.
    "Press ENTER to toggle": "",
    // Shown when the chart is busy loading something.
    "Loading": "",
    // Shown as the first button in the breadcrumb navigation, e.g.:
    // Home > First level > ...
    "Home": "",
    // Chart types.
    // Those are used as default screen reader titles for the main chart element
    // unless developer has set some more descriptive title.
    "Chart": "",
    "Serial chart": "",
    "X/Y chart": "",
    "Pie chart": "",
    "Gauge chart": "",
    "Radar chart": "",
    "Sankey diagram": "",
    "Flow diagram": "",
    "Chord diagram": "",
    "TreeMap chart": "",
    "Force directed tree": "",
    "Sliced chart": "",
    // Series types.
    // Used to name series by type for screen readers if they do not have their
    // name set.
    "Series": "",
    "Candlestick Series": "",
    "OHLC Series": "",
    "Column Series": "",
    "Line Series": "",
    "Pie Slice Series": "",
    "Funnel Series": "",
    "Pyramid Series": "",
    "X/Y Series": "",
    // Map-related stuff.
    "Map": "",
    "Press ENTER to zoom in": "",
    "Press ENTER to zoom out": "",
    "Use arrow keys to zoom in and out": "",
    "Use plus and minus keys on your keyboard to zoom in and out": "",
    // Export-related stuff.
    // These prompts are used in Export menu labels.
    // 
    // "Export" is the top-level menu item.
    // 
    // "Image", "Data", "Print" as second-level indicating type of export
    // operation.
    // 
    // Leave actual format untranslated, unless you absolutely know that they
    // would convey more meaning in some other way.
    "Export": "",
    "Image": "",
    "Data": "",
    "Print": "",
    "Press ENTER or use arrow keys to navigate": "",
    "Press ENTER to open": "",
    "Press ENTER to print.": "",
    "Press ENTER to export as %1.": "",
    "(Press ESC to close this message)": "",
    "Image Export Complete": "",
    "Export operation took longer than expected. Something might have gone wrong.": "",
    "Saved from": "",
    "PNG": "",
    "JPG": "",
    "GIF": "",
    "SVG": "",
    "PDF": "",
    "JSON": "",
    "CSV": "",
    "XLSX": "",
    "HTML": "",
    // Scrollbar-related stuff.
    // 
    // Scrollbar is a control which can zoom and pan the axes on the chart.
    // 
    // Each scrollbar has two grips: left or right (for horizontal scrollbar) or
    // upper and lower (for vertical one).
    // 
    // Prompts change in relation to whether Scrollbar is vertical or horizontal.
    // 
    // The final section is used to indicate the current range of selection.
    "Use TAB to select grip buttons or left and right arrows to change selection": "",
    "Use left and right arrows to move selection": "",
    "Use left and right arrows to move left selection": "",
    "Use left and right arrows to move right selection": "",
    "Use TAB select grip buttons or up and down arrows to change selection": "",
    "Use up and down arrows to move selection": "",
    "Use up and down arrows to move lower selection": "",
    "Use up and down arrows to move upper selection": "",
    "From %1 to %2": "",
    "From %1": "",
    "To %1": "",
    // Data loader-related.
    "No parser available for file: %1": "",
    "Error parsing file: %1": "",
    "Unable to load file: %1": "",
    "Invalid date": "",
    // Common actions
    "Close": "",
    "Minimize": ""
});
//# sourceMappingURL=en.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/themes/Animated.js":
/*!*************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/themes/Animated.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _internal_themes_AnimatedTheme__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../.internal/themes/AnimatedTheme */ "./node_modules/@amcharts/amcharts5/.internal/themes/AnimatedTheme.js");

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_internal_themes_AnimatedTheme__WEBPACK_IMPORTED_MODULE_0__.AnimatedTheme);
//# sourceMappingURL=Animated.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/themes/Dark.js":
/*!*********************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/themes/Dark.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _internal_themes_DarkTheme__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../.internal/themes/DarkTheme */ "./node_modules/@amcharts/amcharts5/.internal/themes/DarkTheme.js");

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_internal_themes_DarkTheme__WEBPACK_IMPORTED_MODULE_0__.DarkTheme);
//# sourceMappingURL=Dark.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/themes/Responsive.js":
/*!***************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/themes/Responsive.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _internal_themes_ResponsiveTheme__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../.internal/themes/ResponsiveTheme */ "./node_modules/@amcharts/amcharts5/.internal/themes/ResponsiveTheme.js");

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_internal_themes_ResponsiveTheme__WEBPACK_IMPORTED_MODULE_0__.ResponsiveTheme);
//# sourceMappingURL=Responsive.js.map

/***/ }),

/***/ "./node_modules/svg-arc-to-cubic-bezier/modules/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/svg-arc-to-cubic-bezier/modules/index.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var TAU = Math.PI * 2;

var mapToEllipse = function mapToEllipse(_ref, rx, ry, cosphi, sinphi, centerx, centery) {
  var x = _ref.x,
      y = _ref.y;

  x *= rx;
  y *= ry;

  var xp = cosphi * x - sinphi * y;
  var yp = sinphi * x + cosphi * y;

  return {
    x: xp + centerx,
    y: yp + centery
  };
};

var approxUnitArc = function approxUnitArc(ang1, ang2) {
  // If 90 degree circular arc, use a constant
  // as derived from http://spencermortensen.com/articles/bezier-circle
  var a = ang2 === 1.5707963267948966 ? 0.551915024494 : ang2 === -1.5707963267948966 ? -0.551915024494 : 4 / 3 * Math.tan(ang2 / 4);

  var x1 = Math.cos(ang1);
  var y1 = Math.sin(ang1);
  var x2 = Math.cos(ang1 + ang2);
  var y2 = Math.sin(ang1 + ang2);

  return [{
    x: x1 - y1 * a,
    y: y1 + x1 * a
  }, {
    x: x2 + y2 * a,
    y: y2 - x2 * a
  }, {
    x: x2,
    y: y2
  }];
};

var vectorAngle = function vectorAngle(ux, uy, vx, vy) {
  var sign = ux * vy - uy * vx < 0 ? -1 : 1;

  var dot = ux * vx + uy * vy;

  if (dot > 1) {
    dot = 1;
  }

  if (dot < -1) {
    dot = -1;
  }

  return sign * Math.acos(dot);
};

var getArcCenter = function getArcCenter(px, py, cx, cy, rx, ry, largeArcFlag, sweepFlag, sinphi, cosphi, pxp, pyp) {
  var rxsq = Math.pow(rx, 2);
  var rysq = Math.pow(ry, 2);
  var pxpsq = Math.pow(pxp, 2);
  var pypsq = Math.pow(pyp, 2);

  var radicant = rxsq * rysq - rxsq * pypsq - rysq * pxpsq;

  if (radicant < 0) {
    radicant = 0;
  }

  radicant /= rxsq * pypsq + rysq * pxpsq;
  radicant = Math.sqrt(radicant) * (largeArcFlag === sweepFlag ? -1 : 1);

  var centerxp = radicant * rx / ry * pyp;
  var centeryp = radicant * -ry / rx * pxp;

  var centerx = cosphi * centerxp - sinphi * centeryp + (px + cx) / 2;
  var centery = sinphi * centerxp + cosphi * centeryp + (py + cy) / 2;

  var vx1 = (pxp - centerxp) / rx;
  var vy1 = (pyp - centeryp) / ry;
  var vx2 = (-pxp - centerxp) / rx;
  var vy2 = (-pyp - centeryp) / ry;

  var ang1 = vectorAngle(1, 0, vx1, vy1);
  var ang2 = vectorAngle(vx1, vy1, vx2, vy2);

  if (sweepFlag === 0 && ang2 > 0) {
    ang2 -= TAU;
  }

  if (sweepFlag === 1 && ang2 < 0) {
    ang2 += TAU;
  }

  return [centerx, centery, ang1, ang2];
};

var arcToBezier = function arcToBezier(_ref2) {
  var px = _ref2.px,
      py = _ref2.py,
      cx = _ref2.cx,
      cy = _ref2.cy,
      rx = _ref2.rx,
      ry = _ref2.ry,
      _ref2$xAxisRotation = _ref2.xAxisRotation,
      xAxisRotation = _ref2$xAxisRotation === undefined ? 0 : _ref2$xAxisRotation,
      _ref2$largeArcFlag = _ref2.largeArcFlag,
      largeArcFlag = _ref2$largeArcFlag === undefined ? 0 : _ref2$largeArcFlag,
      _ref2$sweepFlag = _ref2.sweepFlag,
      sweepFlag = _ref2$sweepFlag === undefined ? 0 : _ref2$sweepFlag;

  var curves = [];

  if (rx === 0 || ry === 0) {
    return [];
  }

  var sinphi = Math.sin(xAxisRotation * TAU / 360);
  var cosphi = Math.cos(xAxisRotation * TAU / 360);

  var pxp = cosphi * (px - cx) / 2 + sinphi * (py - cy) / 2;
  var pyp = -sinphi * (px - cx) / 2 + cosphi * (py - cy) / 2;

  if (pxp === 0 && pyp === 0) {
    return [];
  }

  rx = Math.abs(rx);
  ry = Math.abs(ry);

  var lambda = Math.pow(pxp, 2) / Math.pow(rx, 2) + Math.pow(pyp, 2) / Math.pow(ry, 2);

  if (lambda > 1) {
    rx *= Math.sqrt(lambda);
    ry *= Math.sqrt(lambda);
  }

  var _getArcCenter = getArcCenter(px, py, cx, cy, rx, ry, largeArcFlag, sweepFlag, sinphi, cosphi, pxp, pyp),
      _getArcCenter2 = _slicedToArray(_getArcCenter, 4),
      centerx = _getArcCenter2[0],
      centery = _getArcCenter2[1],
      ang1 = _getArcCenter2[2],
      ang2 = _getArcCenter2[3];

  // If 'ang2' == 90.0000000001, then `ratio` will evaluate to
  // 1.0000000001. This causes `segments` to be greater than one, which is an
  // unecessary split, and adds extra points to the bezier curve. To alleviate
  // this issue, we round to 1.0 when the ratio is close to 1.0.


  var ratio = Math.abs(ang2) / (TAU / 4);
  if (Math.abs(1.0 - ratio) < 0.0000001) {
    ratio = 1.0;
  }

  var segments = Math.max(Math.ceil(ratio), 1);

  ang2 /= segments;

  for (var i = 0; i < segments; i++) {
    curves.push(approxUnitArc(ang1, ang2));
    ang1 += ang2;
  }

  return curves.map(function (curve) {
    var _mapToEllipse = mapToEllipse(curve[0], rx, ry, cosphi, sinphi, centerx, centery),
        x1 = _mapToEllipse.x,
        y1 = _mapToEllipse.y;

    var _mapToEllipse2 = mapToEllipse(curve[1], rx, ry, cosphi, sinphi, centerx, centery),
        x2 = _mapToEllipse2.x,
        y2 = _mapToEllipse2.y;

    var _mapToEllipse3 = mapToEllipse(curve[2], rx, ry, cosphi, sinphi, centerx, centery),
        x = _mapToEllipse3.x,
        y = _mapToEllipse3.y;

    return { x1: x1, y1: y1, x2: x2, y2: y2, x: x, y: y };
  });
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (arcToBezier);

/***/ }),

/***/ "./jimu-ui/advanced/lib/chart-engine/index.ts":
/*!****************************************************!*\
  !*** ./jimu-ui/advanced/lib/chart-engine/index.ts ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AnimatedThemeAm5: () => (/* reexport safe */ _amcharts_amcharts5_themes_Animated__WEBPACK_IMPORTED_MODULE_28__["default"]),
/* harmony export */   AxisRendererXAm5: () => (/* reexport safe */ _amcharts_amcharts5_xy__WEBPACK_IMPORTED_MODULE_4__.AxisRendererX),
/* harmony export */   AxisRendererYAm5: () => (/* reexport safe */ _amcharts_amcharts5_xy__WEBPACK_IMPORTED_MODULE_7__.AxisRendererY),
/* harmony export */   BulletAm5: () => (/* reexport safe */ _amcharts_amcharts5__WEBPACK_IMPORTED_MODULE_19__.Bullet),
/* harmony export */   CategoryAxisAm5: () => (/* reexport safe */ _amcharts_amcharts5_xy__WEBPACK_IMPORTED_MODULE_5__.CategoryAxis),
/* harmony export */   CircleAm5: () => (/* reexport safe */ _amcharts_amcharts5__WEBPACK_IMPORTED_MODULE_21__.Circle),
/* harmony export */   ColumnSeries: () => (/* reexport safe */ _amcharts_amcharts5_xy__WEBPACK_IMPORTED_MODULE_8__.ColumnSeries),
/* harmony export */   ColumnSeriesAm5: () => (/* reexport safe */ _amcharts_amcharts5_xy__WEBPACK_IMPORTED_MODULE_8__.ColumnSeries),
/* harmony export */   ContainerAm5: () => (/* reexport safe */ _amcharts_amcharts5__WEBPACK_IMPORTED_MODULE_23__.Container),
/* harmony export */   DarkThemeAm5: () => (/* reexport safe */ _amcharts_amcharts5_themes_Dark__WEBPACK_IMPORTED_MODULE_26__["default"]),
/* harmony export */   Exporting: () => (/* reexport safe */ _amcharts_amcharts5_plugins_exporting__WEBPACK_IMPORTED_MODULE_29__.Exporting),
/* harmony export */   GridLayoutAm5: () => (/* reexport safe */ _amcharts_amcharts5__WEBPACK_IMPORTED_MODULE_18__.GridLayout),
/* harmony export */   LabelAm5: () => (/* reexport safe */ _amcharts_amcharts5__WEBPACK_IMPORTED_MODULE_16__.Label),
/* harmony export */   LegendAm5: () => (/* reexport safe */ _amcharts_amcharts5__WEBPACK_IMPORTED_MODULE_17__.Legend),
/* harmony export */   LineSeriesAm5: () => (/* reexport safe */ _amcharts_amcharts5_xy__WEBPACK_IMPORTED_MODULE_9__.LineSeries),
/* harmony export */   NumberFormatterAm5: () => (/* reexport safe */ _amcharts_amcharts5__WEBPACK_IMPORTED_MODULE_15__.NumberFormatter),
/* harmony export */   PieChartAm5: () => (/* reexport safe */ _amcharts_amcharts5_percent__WEBPACK_IMPORTED_MODULE_11__.PieChart),
/* harmony export */   PieSeriesAm5: () => (/* reexport safe */ _amcharts_amcharts5_percent__WEBPACK_IMPORTED_MODULE_12__.PieSeries),
/* harmony export */   RectangleAm5: () => (/* reexport safe */ _amcharts_amcharts5__WEBPACK_IMPORTED_MODULE_20__.Rectangle),
/* harmony export */   ResponsiveThemeAm5: () => (/* reexport safe */ _amcharts_amcharts5_themes_Responsive__WEBPACK_IMPORTED_MODULE_27__["default"]),
/* harmony export */   ScrollbarAm5: () => (/* reexport safe */ _amcharts_amcharts5__WEBPACK_IMPORTED_MODULE_25__.Scrollbar),
/* harmony export */   TooltipAm5: () => (/* reexport safe */ _amcharts_amcharts5__WEBPACK_IMPORTED_MODULE_14__.Tooltip),
/* harmony export */   TriangleAm5: () => (/* reexport safe */ _amcharts_amcharts5__WEBPACK_IMPORTED_MODULE_22__.Triangle),
/* harmony export */   ValueAxisAm5: () => (/* reexport safe */ _amcharts_amcharts5_xy__WEBPACK_IMPORTED_MODULE_6__.ValueAxis),
/* harmony export */   XYChartAm5: () => (/* reexport safe */ _amcharts_amcharts5_xy__WEBPACK_IMPORTED_MODULE_3__.XYChart),
/* harmony export */   XYCursorAm5: () => (/* reexport safe */ _amcharts_amcharts5_xy__WEBPACK_IMPORTED_MODULE_10__.XYCursor),
/* harmony export */   colorAm5: () => (/* reexport safe */ _amcharts_amcharts5__WEBPACK_IMPORTED_MODULE_13__.color),
/* harmony export */   createRoot: () => (/* binding */ createRoot),
/* harmony export */   p0: () => (/* reexport safe */ _amcharts_amcharts5__WEBPACK_IMPORTED_MODULE_24__.p0),
/* harmony export */   p100: () => (/* reexport safe */ _amcharts_amcharts5__WEBPACK_IMPORTED_MODULE_24__.p100),
/* harmony export */   p50: () => (/* reexport safe */ _amcharts_amcharts5__WEBPACK_IMPORTED_MODULE_24__.p50),
/* harmony export */   percentAm5: () => (/* reexport safe */ _amcharts_amcharts5__WEBPACK_IMPORTED_MODULE_24__.percent)
/* harmony export */ });
/* harmony import */ var _amcharts_amcharts5_index__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @amcharts/amcharts5/index */ "./node_modules/@amcharts/amcharts5/.internal/core/Registry.js");
/* harmony import */ var _amcharts_amcharts5_index__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @amcharts/amcharts5/index */ "./node_modules/@amcharts/amcharts5/.internal/core/Root.js");
/* harmony import */ var esri_intl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! esri/intl */ "esri/intl");
/* harmony import */ var _amcharts_amcharts5_xy__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @amcharts/amcharts5/xy */ "./node_modules/@amcharts/amcharts5/.internal/charts/xy/XYChart.js");
/* harmony import */ var _amcharts_amcharts5_xy__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @amcharts/amcharts5/xy */ "./node_modules/@amcharts/amcharts5/.internal/charts/xy/axes/AxisRendererX.js");
/* harmony import */ var _amcharts_amcharts5_xy__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @amcharts/amcharts5/xy */ "./node_modules/@amcharts/amcharts5/.internal/charts/xy/axes/CategoryAxis.js");
/* harmony import */ var _amcharts_amcharts5_xy__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @amcharts/amcharts5/xy */ "./node_modules/@amcharts/amcharts5/.internal/charts/xy/axes/ValueAxis.js");
/* harmony import */ var _amcharts_amcharts5_xy__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @amcharts/amcharts5/xy */ "./node_modules/@amcharts/amcharts5/.internal/charts/xy/axes/AxisRendererY.js");
/* harmony import */ var _amcharts_amcharts5_xy__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @amcharts/amcharts5/.internal/charts/xy/series/ColumnSeries */ "./node_modules/@amcharts/amcharts5/.internal/charts/xy/series/ColumnSeries.js");
/* harmony import */ var _amcharts_amcharts5_xy__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @amcharts/amcharts5/xy */ "./node_modules/@amcharts/amcharts5/.internal/charts/xy/series/LineSeries.js");
/* harmony import */ var _amcharts_amcharts5_xy__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @amcharts/amcharts5/xy */ "./node_modules/@amcharts/amcharts5/.internal/charts/xy/XYCursor.js");
/* harmony import */ var _amcharts_amcharts5_percent__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @amcharts/amcharts5/percent */ "./node_modules/@amcharts/amcharts5/.internal/charts/pie/PieChart.js");
/* harmony import */ var _amcharts_amcharts5_percent__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @amcharts/amcharts5/percent */ "./node_modules/@amcharts/amcharts5/.internal/charts/pie/PieSeries.js");
/* harmony import */ var _amcharts_amcharts5__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! @amcharts/amcharts5 */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Color.js");
/* harmony import */ var _amcharts_amcharts5__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! @amcharts/amcharts5 */ "./node_modules/@amcharts/amcharts5/.internal/core/render/Tooltip.js");
/* harmony import */ var _amcharts_amcharts5__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! @amcharts/amcharts5 */ "./node_modules/@amcharts/amcharts5/.internal/core/util/NumberFormatter.js");
/* harmony import */ var _amcharts_amcharts5__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! @amcharts/amcharts5 */ "./node_modules/@amcharts/amcharts5/.internal/core/render/Label.js");
/* harmony import */ var _amcharts_amcharts5__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! @amcharts/amcharts5 */ "./node_modules/@amcharts/amcharts5/.internal/core/render/Legend.js");
/* harmony import */ var _amcharts_amcharts5__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! @amcharts/amcharts5 */ "./node_modules/@amcharts/amcharts5/.internal/core/render/GridLayout.js");
/* harmony import */ var _amcharts_amcharts5__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! @amcharts/amcharts5 */ "./node_modules/@amcharts/amcharts5/.internal/core/render/Bullet.js");
/* harmony import */ var _amcharts_amcharts5__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! @amcharts/amcharts5 */ "./node_modules/@amcharts/amcharts5/.internal/core/render/Rectangle.js");
/* harmony import */ var _amcharts_amcharts5__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! @amcharts/amcharts5 */ "./node_modules/@amcharts/amcharts5/.internal/core/render/Circle.js");
/* harmony import */ var _amcharts_amcharts5__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! @amcharts/amcharts5 */ "./node_modules/@amcharts/amcharts5/.internal/core/render/Triangle.js");
/* harmony import */ var _amcharts_amcharts5__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! @amcharts/amcharts5 */ "./node_modules/@amcharts/amcharts5/.internal/core/render/Container.js");
/* harmony import */ var _amcharts_amcharts5__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! @amcharts/amcharts5 */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Percent.js");
/* harmony import */ var _amcharts_amcharts5__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! @amcharts/amcharts5 */ "./node_modules/@amcharts/amcharts5/.internal/core/render/Scrollbar.js");
/* harmony import */ var _amcharts_amcharts5_themes_Dark__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! @amcharts/amcharts5/themes/Dark */ "./node_modules/@amcharts/amcharts5/themes/Dark.js");
/* harmony import */ var _amcharts_amcharts5_themes_Responsive__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! @amcharts/amcharts5/themes/Responsive */ "./node_modules/@amcharts/amcharts5/themes/Responsive.js");
/* harmony import */ var _amcharts_amcharts5_themes_Animated__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! @amcharts/amcharts5/themes/Animated */ "./node_modules/@amcharts/amcharts5/themes/Animated.js");
/* harmony import */ var _amcharts_amcharts5_plugins_exporting__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! @amcharts/amcharts5/plugins/exporting */ "./node_modules/@amcharts/amcharts5/.internal/plugins/exporting/Exporting.js");
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
// @amcharts.amcharts5

// esri

// register license
(0,_amcharts_amcharts5_index__WEBPACK_IMPORTED_MODULE_1__.addLicense)('AM5C241025748');
const DEFAULT_LOCALE = 'en-us';
// supported amCharts locales, sorted by language and then default region
const locales = new Map([
    ['ar', () => __webpack_require__.e(/*! import() */ "vendors-node_modules_amcharts_amcharts5_locales_ar_js").then(__webpack_require__.bind(__webpack_require__, /*! @amcharts/amcharts5/locales/ar */ "./node_modules/@amcharts/amcharts5/locales/ar.js"))],
    ['bg-bg', () => __webpack_require__.e(/*! import() */ "node_modules_amcharts_amcharts5_locales_bg_BG_js").then(__webpack_require__.bind(__webpack_require__, /*! @amcharts/amcharts5/locales/bg_BG */ "./node_modules/@amcharts/amcharts5/locales/bg_BG.js"))],
    ['bs-ba', () => __webpack_require__.e(/*! import() */ "vendors-node_modules_amcharts_amcharts5_locales_bs_BA_js").then(__webpack_require__.bind(__webpack_require__, /*! @amcharts/amcharts5/locales/bs_BA */ "./node_modules/@amcharts/amcharts5/locales/bs_BA.js"))],
    ['ca-es', () => __webpack_require__.e(/*! import() */ "vendors-node_modules_amcharts_amcharts5_locales_ca_ES_js").then(__webpack_require__.bind(__webpack_require__, /*! @amcharts/amcharts5/locales/ca_ES */ "./node_modules/@amcharts/amcharts5/locales/ca_ES.js"))],
    ['cs-cz', () => __webpack_require__.e(/*! import() */ "vendors-node_modules_amcharts_amcharts5_locales_cs_CZ_js").then(__webpack_require__.bind(__webpack_require__, /*! @amcharts/amcharts5/locales/cs_CZ */ "./node_modules/@amcharts/amcharts5/locales/cs_CZ.js"))],
    ['da-dk', () => __webpack_require__.e(/*! import() */ "vendors-node_modules_amcharts_amcharts5_locales_da_DK_js").then(__webpack_require__.bind(__webpack_require__, /*! @amcharts/amcharts5/locales/da_DK */ "./node_modules/@amcharts/amcharts5/locales/da_DK.js"))],
    ['de-de', () => __webpack_require__.e(/*! import() */ "vendors-node_modules_amcharts_amcharts5_locales_de_DE_js").then(__webpack_require__.bind(__webpack_require__, /*! @amcharts/amcharts5/locales/de_DE */ "./node_modules/@amcharts/amcharts5/locales/de_DE.js"))],
    ['de-ch', () => __webpack_require__.e(/*! import() */ "vendors-node_modules_amcharts_amcharts5_locales_de_CH_js").then(__webpack_require__.bind(__webpack_require__, /*! @amcharts/amcharts5/locales/de_CH */ "./node_modules/@amcharts/amcharts5/locales/de_CH.js"))],
    ['el-gr', () => __webpack_require__.e(/*! import() */ "vendors-node_modules_amcharts_amcharts5_locales_el_GR_js").then(__webpack_require__.bind(__webpack_require__, /*! @amcharts/amcharts5/locales/el_GR */ "./node_modules/@amcharts/amcharts5/locales/el_GR.js"))],
    ['en-us', () => __webpack_require__.e(/*! import() */ "node_modules_amcharts_amcharts5_locales_en_US_js").then(__webpack_require__.bind(__webpack_require__, /*! @amcharts/amcharts5/locales/en_US */ "./node_modules/@amcharts/amcharts5/locales/en_US.js"))],
    ['en-ca', () => __webpack_require__.e(/*! import() */ "node_modules_amcharts_amcharts5_locales_en_CA_js").then(__webpack_require__.bind(__webpack_require__, /*! @amcharts/amcharts5/locales/en_CA */ "./node_modules/@amcharts/amcharts5/locales/en_CA.js"))],
    ['es-es', () => __webpack_require__.e(/*! import() */ "node_modules_amcharts_amcharts5_locales_es_ES_js").then(__webpack_require__.bind(__webpack_require__, /*! @amcharts/amcharts5/locales/es_ES */ "./node_modules/@amcharts/amcharts5/locales/es_ES.js"))],
    ['et-ee', () => __webpack_require__.e(/*! import() */ "vendors-node_modules_amcharts_amcharts5_locales_et_EE_js").then(__webpack_require__.bind(__webpack_require__, /*! @amcharts/amcharts5/locales/et_EE */ "./node_modules/@amcharts/amcharts5/locales/et_EE.js"))],
    ['fi-fi', () => __webpack_require__.e(/*! import() */ "vendors-node_modules_amcharts_amcharts5_locales_fi_FI_js").then(__webpack_require__.bind(__webpack_require__, /*! @amcharts/amcharts5/locales/fi_FI */ "./node_modules/@amcharts/amcharts5/locales/fi_FI.js"))],
    ['fr-fr', () => __webpack_require__.e(/*! import() */ "vendors-node_modules_amcharts_amcharts5_locales_fr_FR_js").then(__webpack_require__.bind(__webpack_require__, /*! @amcharts/amcharts5/locales/fr_FR */ "./node_modules/@amcharts/amcharts5/locales/fr_FR.js"))],
    ['he-il', () => __webpack_require__.e(/*! import() */ "vendors-node_modules_amcharts_amcharts5_locales_he_IL_js").then(__webpack_require__.bind(__webpack_require__, /*! @amcharts/amcharts5/locales/he_IL */ "./node_modules/@amcharts/amcharts5/locales/he_IL.js"))],
    ['hr-hr', () => __webpack_require__.e(/*! import() */ "vendors-node_modules_amcharts_amcharts5_locales_hr_HR_js").then(__webpack_require__.bind(__webpack_require__, /*! @amcharts/amcharts5/locales/hr_HR */ "./node_modules/@amcharts/amcharts5/locales/hr_HR.js"))],
    ['hu-hu', () => __webpack_require__.e(/*! import() */ "vendors-node_modules_amcharts_amcharts5_locales_hu_HU_js").then(__webpack_require__.bind(__webpack_require__, /*! @amcharts/amcharts5/locales/hu_HU */ "./node_modules/@amcharts/amcharts5/locales/hu_HU.js"))],
    ['id-id', () => __webpack_require__.e(/*! import() */ "vendors-node_modules_amcharts_amcharts5_locales_id_ID_js").then(__webpack_require__.bind(__webpack_require__, /*! @amcharts/amcharts5/locales/id_ID */ "./node_modules/@amcharts/amcharts5/locales/id_ID.js"))],
    ['it-it', () => __webpack_require__.e(/*! import() */ "vendors-node_modules_amcharts_amcharts5_locales_it_IT_js").then(__webpack_require__.bind(__webpack_require__, /*! @amcharts/amcharts5/locales/it_IT */ "./node_modules/@amcharts/amcharts5/locales/it_IT.js"))],
    ['ja-jp', () => __webpack_require__.e(/*! import() */ "vendors-node_modules_amcharts_amcharts5_locales_ja_JP_js").then(__webpack_require__.bind(__webpack_require__, /*! @amcharts/amcharts5/locales/ja_JP */ "./node_modules/@amcharts/amcharts5/locales/ja_JP.js"))],
    ['ko-kr', () => __webpack_require__.e(/*! import() */ "vendors-node_modules_amcharts_amcharts5_locales_ko_KR_js").then(__webpack_require__.bind(__webpack_require__, /*! @amcharts/amcharts5/locales/ko_KR */ "./node_modules/@amcharts/amcharts5/locales/ko_KR.js"))],
    ['lt-lt', () => __webpack_require__.e(/*! import() */ "node_modules_amcharts_amcharts5_locales_lt_LT_js").then(__webpack_require__.bind(__webpack_require__, /*! @amcharts/amcharts5/locales/lt_LT */ "./node_modules/@amcharts/amcharts5/locales/lt_LT.js"))],
    ['lv-lv', () => __webpack_require__.e(/*! import() */ "vendors-node_modules_amcharts_amcharts5_locales_lv_LV_js").then(__webpack_require__.bind(__webpack_require__, /*! @amcharts/amcharts5/locales/lv_LV */ "./node_modules/@amcharts/amcharts5/locales/lv_LV.js"))],
    ['nb-no', () => __webpack_require__.e(/*! import() */ "vendors-node_modules_amcharts_amcharts5_locales_nb_NO_js").then(__webpack_require__.bind(__webpack_require__, /*! @amcharts/amcharts5/locales/nb_NO */ "./node_modules/@amcharts/amcharts5/locales/nb_NO.js"))],
    ['nl-nl', () => __webpack_require__.e(/*! import() */ "node_modules_amcharts_amcharts5_locales_nl_NL_js").then(__webpack_require__.bind(__webpack_require__, /*! @amcharts/amcharts5/locales/nl_NL */ "./node_modules/@amcharts/amcharts5/locales/nl_NL.js"))],
    ['pl-pl', () => __webpack_require__.e(/*! import() */ "vendors-node_modules_amcharts_amcharts5_locales_pl_PL_js").then(__webpack_require__.bind(__webpack_require__, /*! @amcharts/amcharts5/locales/pl_PL */ "./node_modules/@amcharts/amcharts5/locales/pl_PL.js"))],
    ['pt-br', () => __webpack_require__.e(/*! import() */ "node_modules_amcharts_amcharts5_locales_pt_BR_js").then(__webpack_require__.bind(__webpack_require__, /*! @amcharts/amcharts5/locales/pt_BR */ "./node_modules/@amcharts/amcharts5/locales/pt_BR.js"))],
    ['pt-pt', () => __webpack_require__.e(/*! import() */ "node_modules_amcharts_amcharts5_locales_pt_PT_js").then(__webpack_require__.bind(__webpack_require__, /*! @amcharts/amcharts5/locales/pt_PT */ "./node_modules/@amcharts/amcharts5/locales/pt_PT.js"))],
    ['ro-ro', () => __webpack_require__.e(/*! import() */ "vendors-node_modules_amcharts_amcharts5_locales_ro_RO_js").then(__webpack_require__.bind(__webpack_require__, /*! @amcharts/amcharts5/locales/ro_RO */ "./node_modules/@amcharts/amcharts5/locales/ro_RO.js"))],
    ['ru-ru', () => __webpack_require__.e(/*! import() */ "node_modules_amcharts_amcharts5_locales_ru_RU_js").then(__webpack_require__.bind(__webpack_require__, /*! @amcharts/amcharts5/locales/ru_RU */ "./node_modules/@amcharts/amcharts5/locales/ru_RU.js"))],
    ['sk-sk', () => __webpack_require__.e(/*! import() */ "vendors-node_modules_amcharts_amcharts5_locales_sk_SK_js").then(__webpack_require__.bind(__webpack_require__, /*! @amcharts/amcharts5/locales/sk_SK */ "./node_modules/@amcharts/amcharts5/locales/sk_SK.js"))],
    ['sl-sl', () => __webpack_require__.e(/*! import() */ "vendors-node_modules_amcharts_amcharts5_locales_sl_SL_js").then(__webpack_require__.bind(__webpack_require__, /*! @amcharts/amcharts5/locales/sl_SL */ "./node_modules/@amcharts/amcharts5/locales/sl_SL.js"))],
    ['sr-rs', () => __webpack_require__.e(/*! import() */ "vendors-node_modules_amcharts_amcharts5_locales_sr_RS_js").then(__webpack_require__.bind(__webpack_require__, /*! @amcharts/amcharts5/locales/sr_RS */ "./node_modules/@amcharts/amcharts5/locales/sr_RS.js"))],
    ['sv-se', () => __webpack_require__.e(/*! import() */ "node_modules_amcharts_amcharts5_locales_sv_SE_js").then(__webpack_require__.bind(__webpack_require__, /*! @amcharts/amcharts5/locales/sv_SE */ "./node_modules/@amcharts/amcharts5/locales/sv_SE.js"))],
    ['th-th', () => __webpack_require__.e(/*! import() */ "vendors-node_modules_amcharts_amcharts5_locales_th_TH_js").then(__webpack_require__.bind(__webpack_require__, /*! @amcharts/amcharts5/locales/th_TH */ "./node_modules/@amcharts/amcharts5/locales/th_TH.js"))],
    ['tr-tr', () => __webpack_require__.e(/*! import() */ "vendors-node_modules_amcharts_amcharts5_locales_tr_TR_js").then(__webpack_require__.bind(__webpack_require__, /*! @amcharts/amcharts5/locales/tr_TR */ "./node_modules/@amcharts/amcharts5/locales/tr_TR.js"))],
    ['uk-ua', () => __webpack_require__.e(/*! import() */ "vendors-node_modules_amcharts_amcharts5_locales_uk_UA_js").then(__webpack_require__.bind(__webpack_require__, /*! @amcharts/amcharts5/locales/uk_UA */ "./node_modules/@amcharts/amcharts5/locales/uk_UA.js"))],
    ['vi-vn', () => __webpack_require__.e(/*! import() */ "vendors-node_modules_amcharts_amcharts5_locales_vi_VN_js").then(__webpack_require__.bind(__webpack_require__, /*! @amcharts/amcharts5/locales/vi_VN */ "./node_modules/@amcharts/amcharts5/locales/vi_VN.js"))],
    ['zh-cn', () => __webpack_require__.e(/*! import() */ "vendors-node_modules_amcharts_amcharts5_locales_zh_Hans_js").then(__webpack_require__.bind(__webpack_require__, /*! @amcharts/amcharts5/locales/zh_Hans */ "./node_modules/@amcharts/amcharts5/locales/zh_Hans.js"))],
    ['zh-hk', () => __webpack_require__.e(/*! import() */ "vendors-node_modules_amcharts_amcharts5_locales_zh_Hant_js").then(__webpack_require__.bind(__webpack_require__, /*! @amcharts/amcharts5/locales/zh_Hant */ "./node_modules/@amcharts/amcharts5/locales/zh_Hant.js"))],
    ['zh-tw', () => __webpack_require__.e(/*! import() */ "vendors-node_modules_amcharts_amcharts5_locales_zh_Hant_js").then(__webpack_require__.bind(__webpack_require__, /*! @amcharts/amcharts5/locales/zh_Hant */ "./node_modules/@amcharts/amcharts5/locales/zh_Hant.js"))]
]);
function getLanguageLocale(locale) {
    const splitLocale = locale.split('-');
    const languageCode = splitLocale[0].toLowerCase();
    let match = null;
    for (const key of locales.keys()) {
        if (key.startsWith(languageCode)) {
            match = key;
            break;
        }
    }
    return match;
}
function getChartLocale(locale) {
    if (!locale) {
        return DEFAULT_LOCALE;
    }
    if (locales.has(locale.toLowerCase())) {
        return locale.toLowerCase();
    }
    return getLanguageLocale(locale) || DEFAULT_LOCALE;
}
/**
 * Returns a new `Root` instance with the locale values loaded and set.
 * @param id
 * @param [locale]
 */
function createRoot(id, locale) {
    var _a;
    return __awaiter(this, void 0, void 0, function* () {
        const root = _amcharts_amcharts5_index__WEBPACK_IMPORTED_MODULE_2__.Root.new(id);
        if (!locale) {
            locale = esri_intl__WEBPACK_IMPORTED_MODULE_0__["default"].getLocale();
        }
        root.locale = (yield ((_a = locales.get(getChartLocale(locale))) === null || _a === void 0 ? void 0 : _a())).default;
        return root;
    });
}










/***/ }),

/***/ "esri/intl":
/*!****************************!*\
  !*** external "esri/intl" ***!
  \****************************/
/***/ ((module) => {

"use strict";
module.exports = __WEBPACK_EXTERNAL_MODULE_esri_intl__;

/***/ }),

/***/ "./node_modules/d3-path/src/path.js":
/*!******************************************!*\
  !*** ./node_modules/d3-path/src/path.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Path: () => (/* binding */ Path),
/* harmony export */   path: () => (/* binding */ path),
/* harmony export */   pathRound: () => (/* binding */ pathRound)
/* harmony export */ });
const pi = Math.PI,
    tau = 2 * pi,
    epsilon = 1e-6,
    tauEpsilon = tau - epsilon;

function append(strings) {
  this._ += strings[0];
  for (let i = 1, n = strings.length; i < n; ++i) {
    this._ += arguments[i] + strings[i];
  }
}

function appendRound(digits) {
  let d = Math.floor(digits);
  if (!(d >= 0)) throw new Error(`invalid digits: ${digits}`);
  if (d > 15) return append;
  const k = 10 ** d;
  return function(strings) {
    this._ += strings[0];
    for (let i = 1, n = strings.length; i < n; ++i) {
      this._ += Math.round(arguments[i] * k) / k + strings[i];
    }
  };
}

class Path {
  constructor(digits) {
    this._x0 = this._y0 = // start of current subpath
    this._x1 = this._y1 = null; // end of current subpath
    this._ = "";
    this._append = digits == null ? append : appendRound(digits);
  }
  moveTo(x, y) {
    this._append`M${this._x0 = this._x1 = +x},${this._y0 = this._y1 = +y}`;
  }
  closePath() {
    if (this._x1 !== null) {
      this._x1 = this._x0, this._y1 = this._y0;
      this._append`Z`;
    }
  }
  lineTo(x, y) {
    this._append`L${this._x1 = +x},${this._y1 = +y}`;
  }
  quadraticCurveTo(x1, y1, x, y) {
    this._append`Q${+x1},${+y1},${this._x1 = +x},${this._y1 = +y}`;
  }
  bezierCurveTo(x1, y1, x2, y2, x, y) {
    this._append`C${+x1},${+y1},${+x2},${+y2},${this._x1 = +x},${this._y1 = +y}`;
  }
  arcTo(x1, y1, x2, y2, r) {
    x1 = +x1, y1 = +y1, x2 = +x2, y2 = +y2, r = +r;

    // Is the radius negative? Error.
    if (r < 0) throw new Error(`negative radius: ${r}`);

    let x0 = this._x1,
        y0 = this._y1,
        x21 = x2 - x1,
        y21 = y2 - y1,
        x01 = x0 - x1,
        y01 = y0 - y1,
        l01_2 = x01 * x01 + y01 * y01;

    // Is this path empty? Move to (x1,y1).
    if (this._x1 === null) {
      this._append`M${this._x1 = x1},${this._y1 = y1}`;
    }

    // Or, is (x1,y1) coincident with (x0,y0)? Do nothing.
    else if (!(l01_2 > epsilon));

    // Or, are (x0,y0), (x1,y1) and (x2,y2) collinear?
    // Equivalently, is (x1,y1) coincident with (x2,y2)?
    // Or, is the radius zero? Line to (x1,y1).
    else if (!(Math.abs(y01 * x21 - y21 * x01) > epsilon) || !r) {
      this._append`L${this._x1 = x1},${this._y1 = y1}`;
    }

    // Otherwise, draw an arc!
    else {
      let x20 = x2 - x0,
          y20 = y2 - y0,
          l21_2 = x21 * x21 + y21 * y21,
          l20_2 = x20 * x20 + y20 * y20,
          l21 = Math.sqrt(l21_2),
          l01 = Math.sqrt(l01_2),
          l = r * Math.tan((pi - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2),
          t01 = l / l01,
          t21 = l / l21;

      // If the start tangent is not coincident with (x0,y0), line to.
      if (Math.abs(t01 - 1) > epsilon) {
        this._append`L${x1 + t01 * x01},${y1 + t01 * y01}`;
      }

      this._append`A${r},${r},0,0,${+(y01 * x20 > x01 * y20)},${this._x1 = x1 + t21 * x21},${this._y1 = y1 + t21 * y21}`;
    }
  }
  arc(x, y, r, a0, a1, ccw) {
    x = +x, y = +y, r = +r, ccw = !!ccw;

    // Is the radius negative? Error.
    if (r < 0) throw new Error(`negative radius: ${r}`);

    let dx = r * Math.cos(a0),
        dy = r * Math.sin(a0),
        x0 = x + dx,
        y0 = y + dy,
        cw = 1 ^ ccw,
        da = ccw ? a0 - a1 : a1 - a0;

    // Is this path empty? Move to (x0,y0).
    if (this._x1 === null) {
      this._append`M${x0},${y0}`;
    }

    // Or, is (x0,y0) not coincident with the previous point? Line to (x0,y0).
    else if (Math.abs(this._x1 - x0) > epsilon || Math.abs(this._y1 - y0) > epsilon) {
      this._append`L${x0},${y0}`;
    }

    // Is this arc empty? We’re done.
    if (!r) return;

    // Does the angle go the wrong way? Flip the direction.
    if (da < 0) da = da % tau + tau;

    // Is this a complete circle? Draw two arcs to complete the circle.
    if (da > tauEpsilon) {
      this._append`A${r},${r},0,1,${cw},${x - dx},${y - dy}A${r},${r},0,1,${cw},${this._x1 = x0},${this._y1 = y0}`;
    }

    // Is this arc non-empty? Draw an arc!
    else if (da > epsilon) {
      this._append`A${r},${r},0,${+(da >= pi)},${cw},${this._x1 = x + r * Math.cos(a1)},${this._y1 = y + r * Math.sin(a1)}`;
    }
  }
  rect(x, y, w, h) {
    this._append`M${this._x0 = this._x1 = +x},${this._y0 = this._y1 = +y}h${w = +w}v${+h}h${-w}Z`;
  }
  toString() {
    return this._;
  }
}

function path() {
  return new Path;
}

// Allow instanceof d3.path
path.prototype = Path.prototype;

function pathRound(digits = 3) {
  return new Path(+digits);
}


/***/ }),

/***/ "./node_modules/d3-shape/src/arc.js":
/*!******************************************!*\
  !*** ./node_modules/d3-shape/src/arc.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./constant.js */ "./node_modules/d3-shape/src/constant.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math.js */ "./node_modules/d3-shape/src/math.js");
/* harmony import */ var _path_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./path.js */ "./node_modules/d3-shape/src/path.js");




function arcInnerRadius(d) {
  return d.innerRadius;
}

function arcOuterRadius(d) {
  return d.outerRadius;
}

function arcStartAngle(d) {
  return d.startAngle;
}

function arcEndAngle(d) {
  return d.endAngle;
}

function arcPadAngle(d) {
  return d && d.padAngle; // Note: optional!
}

function intersect(x0, y0, x1, y1, x2, y2, x3, y3) {
  var x10 = x1 - x0, y10 = y1 - y0,
      x32 = x3 - x2, y32 = y3 - y2,
      t = y32 * x10 - x32 * y10;
  if (t * t < _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon) return;
  t = (x32 * (y0 - y2) - y32 * (x0 - x2)) / t;
  return [x0 + t * x10, y0 + t * y10];
}

// Compute perpendicular offset line of length rc.
// http://mathworld.wolfram.com/Circle-LineIntersection.html
function cornerTangents(x0, y0, x1, y1, r1, rc, cw) {
  var x01 = x0 - x1,
      y01 = y0 - y1,
      lo = (cw ? rc : -rc) / (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sqrt)(x01 * x01 + y01 * y01),
      ox = lo * y01,
      oy = -lo * x01,
      x11 = x0 + ox,
      y11 = y0 + oy,
      x10 = x1 + ox,
      y10 = y1 + oy,
      x00 = (x11 + x10) / 2,
      y00 = (y11 + y10) / 2,
      dx = x10 - x11,
      dy = y10 - y11,
      d2 = dx * dx + dy * dy,
      r = r1 - rc,
      D = x11 * y10 - x10 * y11,
      d = (dy < 0 ? -1 : 1) * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sqrt)((0,_math_js__WEBPACK_IMPORTED_MODULE_0__.max)(0, r * r * d2 - D * D)),
      cx0 = (D * dy - dx * d) / d2,
      cy0 = (-D * dx - dy * d) / d2,
      cx1 = (D * dy + dx * d) / d2,
      cy1 = (-D * dx + dy * d) / d2,
      dx0 = cx0 - x00,
      dy0 = cy0 - y00,
      dx1 = cx1 - x00,
      dy1 = cy1 - y00;

  // Pick the closer of the two intersection points.
  // TODO Is there a faster way to determine which intersection to use?
  if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1) cx0 = cx1, cy0 = cy1;

  return {
    cx: cx0,
    cy: cy0,
    x01: -ox,
    y01: -oy,
    x11: cx0 * (r1 / r - 1),
    y11: cy0 * (r1 / r - 1)
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var innerRadius = arcInnerRadius,
      outerRadius = arcOuterRadius,
      cornerRadius = (0,_constant_js__WEBPACK_IMPORTED_MODULE_1__["default"])(0),
      padRadius = null,
      startAngle = arcStartAngle,
      endAngle = arcEndAngle,
      padAngle = arcPadAngle,
      context = null,
      path = (0,_path_js__WEBPACK_IMPORTED_MODULE_2__.withPath)(arc);

  function arc() {
    var buffer,
        r,
        r0 = +innerRadius.apply(this, arguments),
        r1 = +outerRadius.apply(this, arguments),
        a0 = startAngle.apply(this, arguments) - _math_js__WEBPACK_IMPORTED_MODULE_0__.halfPi,
        a1 = endAngle.apply(this, arguments) - _math_js__WEBPACK_IMPORTED_MODULE_0__.halfPi,
        da = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.abs)(a1 - a0),
        cw = a1 > a0;

    if (!context) context = buffer = path();

    // Ensure that the outer radius is always larger than the inner radius.
    if (r1 < r0) r = r1, r1 = r0, r0 = r;

    // Is it a point?
    if (!(r1 > _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon)) context.moveTo(0, 0);

    // Or is it a circle or annulus?
    else if (da > _math_js__WEBPACK_IMPORTED_MODULE_0__.tau - _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon) {
      context.moveTo(r1 * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(a0), r1 * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(a0));
      context.arc(0, 0, r1, a0, a1, !cw);
      if (r0 > _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon) {
        context.moveTo(r0 * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(a1), r0 * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(a1));
        context.arc(0, 0, r0, a1, a0, cw);
      }
    }

    // Or is it a circular or annular sector?
    else {
      var a01 = a0,
          a11 = a1,
          a00 = a0,
          a10 = a1,
          da0 = da,
          da1 = da,
          ap = padAngle.apply(this, arguments) / 2,
          rp = (ap > _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon) && (padRadius ? +padRadius.apply(this, arguments) : (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sqrt)(r0 * r0 + r1 * r1)),
          rc = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.min)((0,_math_js__WEBPACK_IMPORTED_MODULE_0__.abs)(r1 - r0) / 2, +cornerRadius.apply(this, arguments)),
          rc0 = rc,
          rc1 = rc,
          t0,
          t1;

      // Apply padding? Note that since r1 ≥ r0, da1 ≥ da0.
      if (rp > _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon) {
        var p0 = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.asin)(rp / r0 * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(ap)),
            p1 = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.asin)(rp / r1 * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(ap));
        if ((da0 -= p0 * 2) > _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon) p0 *= (cw ? 1 : -1), a00 += p0, a10 -= p0;
        else da0 = 0, a00 = a10 = (a0 + a1) / 2;
        if ((da1 -= p1 * 2) > _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon) p1 *= (cw ? 1 : -1), a01 += p1, a11 -= p1;
        else da1 = 0, a01 = a11 = (a0 + a1) / 2;
      }

      var x01 = r1 * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(a01),
          y01 = r1 * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(a01),
          x10 = r0 * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(a10),
          y10 = r0 * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(a10);

      // Apply rounded corners?
      if (rc > _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon) {
        var x11 = r1 * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(a11),
            y11 = r1 * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(a11),
            x00 = r0 * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(a00),
            y00 = r0 * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(a00),
            oc;

        // Restrict the corner radius according to the sector angle. If this
        // intersection fails, it’s probably because the arc is too small, so
        // disable the corner radius entirely.
        if (da < _math_js__WEBPACK_IMPORTED_MODULE_0__.pi) {
          if (oc = intersect(x01, y01, x00, y00, x11, y11, x10, y10)) {
            var ax = x01 - oc[0],
                ay = y01 - oc[1],
                bx = x11 - oc[0],
                by = y11 - oc[1],
                kc = 1 / (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)((0,_math_js__WEBPACK_IMPORTED_MODULE_0__.acos)((ax * bx + ay * by) / ((0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sqrt)(ax * ax + ay * ay) * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sqrt)(bx * bx + by * by))) / 2),
                lc = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sqrt)(oc[0] * oc[0] + oc[1] * oc[1]);
            rc0 = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.min)(rc, (r0 - lc) / (kc - 1));
            rc1 = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.min)(rc, (r1 - lc) / (kc + 1));
          } else {
            rc0 = rc1 = 0;
          }
        }
      }

      // Is the sector collapsed to a line?
      if (!(da1 > _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon)) context.moveTo(x01, y01);

      // Does the sector’s outer ring have rounded corners?
      else if (rc1 > _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon) {
        t0 = cornerTangents(x00, y00, x01, y01, r1, rc1, cw);
        t1 = cornerTangents(x11, y11, x10, y10, r1, rc1, cw);

        context.moveTo(t0.cx + t0.x01, t0.cy + t0.y01);

        // Have the corners merged?
        if (rc1 < rc) context.arc(t0.cx, t0.cy, rc1, (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan2)(t0.y01, t0.x01), (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan2)(t1.y01, t1.x01), !cw);

        // Otherwise, draw the two corners and the ring.
        else {
          context.arc(t0.cx, t0.cy, rc1, (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan2)(t0.y01, t0.x01), (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan2)(t0.y11, t0.x11), !cw);
          context.arc(0, 0, r1, (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan2)(t0.cy + t0.y11, t0.cx + t0.x11), (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan2)(t1.cy + t1.y11, t1.cx + t1.x11), !cw);
          context.arc(t1.cx, t1.cy, rc1, (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan2)(t1.y11, t1.x11), (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan2)(t1.y01, t1.x01), !cw);
        }
      }

      // Or is the outer ring just a circular arc?
      else context.moveTo(x01, y01), context.arc(0, 0, r1, a01, a11, !cw);

      // Is there no inner ring, and it’s a circular sector?
      // Or perhaps it’s an annular sector collapsed due to padding?
      if (!(r0 > _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon) || !(da0 > _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon)) context.lineTo(x10, y10);

      // Does the sector’s inner ring (or point) have rounded corners?
      else if (rc0 > _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon) {
        t0 = cornerTangents(x10, y10, x11, y11, r0, -rc0, cw);
        t1 = cornerTangents(x01, y01, x00, y00, r0, -rc0, cw);

        context.lineTo(t0.cx + t0.x01, t0.cy + t0.y01);

        // Have the corners merged?
        if (rc0 < rc) context.arc(t0.cx, t0.cy, rc0, (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan2)(t0.y01, t0.x01), (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan2)(t1.y01, t1.x01), !cw);

        // Otherwise, draw the two corners and the ring.
        else {
          context.arc(t0.cx, t0.cy, rc0, (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan2)(t0.y01, t0.x01), (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan2)(t0.y11, t0.x11), !cw);
          context.arc(0, 0, r0, (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan2)(t0.cy + t0.y11, t0.cx + t0.x11), (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan2)(t1.cy + t1.y11, t1.cx + t1.x11), cw);
          context.arc(t1.cx, t1.cy, rc0, (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan2)(t1.y11, t1.x11), (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan2)(t1.y01, t1.x01), !cw);
        }
      }

      // Or is the inner ring just a circular arc?
      else context.arc(0, 0, r0, a10, a00, cw);
    }

    context.closePath();

    if (buffer) return context = null, buffer + "" || null;
  }

  arc.centroid = function() {
    var r = (+innerRadius.apply(this, arguments) + +outerRadius.apply(this, arguments)) / 2,
        a = (+startAngle.apply(this, arguments) + +endAngle.apply(this, arguments)) / 2 - _math_js__WEBPACK_IMPORTED_MODULE_0__.pi / 2;
    return [(0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(a) * r, (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(a) * r];
  };

  arc.innerRadius = function(_) {
    return arguments.length ? (innerRadius = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_1__["default"])(+_), arc) : innerRadius;
  };

  arc.outerRadius = function(_) {
    return arguments.length ? (outerRadius = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_1__["default"])(+_), arc) : outerRadius;
  };

  arc.cornerRadius = function(_) {
    return arguments.length ? (cornerRadius = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_1__["default"])(+_), arc) : cornerRadius;
  };

  arc.padRadius = function(_) {
    return arguments.length ? (padRadius = _ == null ? null : typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_1__["default"])(+_), arc) : padRadius;
  };

  arc.startAngle = function(_) {
    return arguments.length ? (startAngle = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_1__["default"])(+_), arc) : startAngle;
  };

  arc.endAngle = function(_) {
    return arguments.length ? (endAngle = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_1__["default"])(+_), arc) : endAngle;
  };

  arc.padAngle = function(_) {
    return arguments.length ? (padAngle = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_1__["default"])(+_), arc) : padAngle;
  };

  arc.context = function(_) {
    return arguments.length ? ((context = _ == null ? null : _), arc) : context;
  };

  return arc;
}


/***/ }),

/***/ "./node_modules/d3-shape/src/area.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-shape/src/area.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./array.js */ "./node_modules/d3-shape/src/array.js");
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constant.js */ "./node_modules/d3-shape/src/constant.js");
/* harmony import */ var _curve_linear_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./curve/linear.js */ "./node_modules/d3-shape/src/curve/linear.js");
/* harmony import */ var _line_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./line.js */ "./node_modules/d3-shape/src/line.js");
/* harmony import */ var _path_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./path.js */ "./node_modules/d3-shape/src/path.js");
/* harmony import */ var _point_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./point.js */ "./node_modules/d3-shape/src/point.js");







/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x0, y0, y1) {
  var x1 = null,
      defined = (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(true),
      context = null,
      curve = _curve_linear_js__WEBPACK_IMPORTED_MODULE_1__["default"],
      output = null,
      path = (0,_path_js__WEBPACK_IMPORTED_MODULE_2__.withPath)(area);

  x0 = typeof x0 === "function" ? x0 : (x0 === undefined) ? _point_js__WEBPACK_IMPORTED_MODULE_3__.x : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(+x0);
  y0 = typeof y0 === "function" ? y0 : (y0 === undefined) ? (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(0) : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(+y0);
  y1 = typeof y1 === "function" ? y1 : (y1 === undefined) ? _point_js__WEBPACK_IMPORTED_MODULE_3__.y : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(+y1);

  function area(data) {
    var i,
        j,
        k,
        n = (data = (0,_array_js__WEBPACK_IMPORTED_MODULE_4__["default"])(data)).length,
        d,
        defined0 = false,
        buffer,
        x0z = new Array(n),
        y0z = new Array(n);

    if (context == null) output = curve(buffer = path());

    for (i = 0; i <= n; ++i) {
      if (!(i < n && defined(d = data[i], i, data)) === defined0) {
        if (defined0 = !defined0) {
          j = i;
          output.areaStart();
          output.lineStart();
        } else {
          output.lineEnd();
          output.lineStart();
          for (k = i - 1; k >= j; --k) {
            output.point(x0z[k], y0z[k]);
          }
          output.lineEnd();
          output.areaEnd();
        }
      }
      if (defined0) {
        x0z[i] = +x0(d, i, data), y0z[i] = +y0(d, i, data);
        output.point(x1 ? +x1(d, i, data) : x0z[i], y1 ? +y1(d, i, data) : y0z[i]);
      }
    }

    if (buffer) return output = null, buffer + "" || null;
  }

  function arealine() {
    return (0,_line_js__WEBPACK_IMPORTED_MODULE_5__["default"])().defined(defined).curve(curve).context(context);
  }

  area.x = function(_) {
    return arguments.length ? (x0 = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), x1 = null, area) : x0;
  };

  area.x0 = function(_) {
    return arguments.length ? (x0 = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), area) : x0;
  };

  area.x1 = function(_) {
    return arguments.length ? (x1 = _ == null ? null : typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), area) : x1;
  };

  area.y = function(_) {
    return arguments.length ? (y0 = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), y1 = null, area) : y0;
  };

  area.y0 = function(_) {
    return arguments.length ? (y0 = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), area) : y0;
  };

  area.y1 = function(_) {
    return arguments.length ? (y1 = _ == null ? null : typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), area) : y1;
  };

  area.lineX0 =
  area.lineY0 = function() {
    return arealine().x(x0).y(y0);
  };

  area.lineY1 = function() {
    return arealine().x(x0).y(y1);
  };

  area.lineX1 = function() {
    return arealine().x(x1).y(y0);
  };

  area.defined = function(_) {
    return arguments.length ? (defined = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(!!_), area) : defined;
  };

  area.curve = function(_) {
    return arguments.length ? (curve = _, context != null && (output = curve(context)), area) : curve;
  };

  area.context = function(_) {
    return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), area) : context;
  };

  return area;
}


/***/ }),

/***/ "./node_modules/d3-shape/src/array.js":
/*!********************************************!*\
  !*** ./node_modules/d3-shape/src/array.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   slice: () => (/* binding */ slice)
/* harmony export */ });
var slice = Array.prototype.slice;

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x) {
  return typeof x === "object" && "length" in x
    ? x // Array, TypedArray, NodeList, array-like
    : Array.from(x); // Map, Set, iterable, string, or anything else
}


/***/ }),

/***/ "./node_modules/d3-shape/src/constant.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-shape/src/constant.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x) {
  return function constant() {
    return x;
  };
}


/***/ }),

/***/ "./node_modules/d3-shape/src/curve/linear.js":
/*!***************************************************!*\
  !*** ./node_modules/d3-shape/src/curve/linear.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function Linear(context) {
  this._context = context;
}

Linear.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
      case 1: this._point = 2; // falls through
      default: this._context.lineTo(x, y); break;
    }
  }
};

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(context) {
  return new Linear(context);
}


/***/ }),

/***/ "./node_modules/d3-shape/src/line.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-shape/src/line.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./array.js */ "./node_modules/d3-shape/src/array.js");
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constant.js */ "./node_modules/d3-shape/src/constant.js");
/* harmony import */ var _curve_linear_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./curve/linear.js */ "./node_modules/d3-shape/src/curve/linear.js");
/* harmony import */ var _path_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./path.js */ "./node_modules/d3-shape/src/path.js");
/* harmony import */ var _point_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./point.js */ "./node_modules/d3-shape/src/point.js");






/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x, y) {
  var defined = (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(true),
      context = null,
      curve = _curve_linear_js__WEBPACK_IMPORTED_MODULE_1__["default"],
      output = null,
      path = (0,_path_js__WEBPACK_IMPORTED_MODULE_2__.withPath)(line);

  x = typeof x === "function" ? x : (x === undefined) ? _point_js__WEBPACK_IMPORTED_MODULE_3__.x : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(x);
  y = typeof y === "function" ? y : (y === undefined) ? _point_js__WEBPACK_IMPORTED_MODULE_3__.y : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(y);

  function line(data) {
    var i,
        n = (data = (0,_array_js__WEBPACK_IMPORTED_MODULE_4__["default"])(data)).length,
        d,
        defined0 = false,
        buffer;

    if (context == null) output = curve(buffer = path());

    for (i = 0; i <= n; ++i) {
      if (!(i < n && defined(d = data[i], i, data)) === defined0) {
        if (defined0 = !defined0) output.lineStart();
        else output.lineEnd();
      }
      if (defined0) output.point(+x(d, i, data), +y(d, i, data));
    }

    if (buffer) return output = null, buffer + "" || null;
  }

  line.x = function(_) {
    return arguments.length ? (x = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), line) : x;
  };

  line.y = function(_) {
    return arguments.length ? (y = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), line) : y;
  };

  line.defined = function(_) {
    return arguments.length ? (defined = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(!!_), line) : defined;
  };

  line.curve = function(_) {
    return arguments.length ? (curve = _, context != null && (output = curve(context)), line) : curve;
  };

  line.context = function(_) {
    return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), line) : context;
  };

  return line;
}


/***/ }),

/***/ "./node_modules/d3-shape/src/math.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-shape/src/math.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   abs: () => (/* binding */ abs),
/* harmony export */   acos: () => (/* binding */ acos),
/* harmony export */   asin: () => (/* binding */ asin),
/* harmony export */   atan2: () => (/* binding */ atan2),
/* harmony export */   cos: () => (/* binding */ cos),
/* harmony export */   epsilon: () => (/* binding */ epsilon),
/* harmony export */   halfPi: () => (/* binding */ halfPi),
/* harmony export */   max: () => (/* binding */ max),
/* harmony export */   min: () => (/* binding */ min),
/* harmony export */   pi: () => (/* binding */ pi),
/* harmony export */   sin: () => (/* binding */ sin),
/* harmony export */   sqrt: () => (/* binding */ sqrt),
/* harmony export */   tau: () => (/* binding */ tau)
/* harmony export */ });
const abs = Math.abs;
const atan2 = Math.atan2;
const cos = Math.cos;
const max = Math.max;
const min = Math.min;
const sin = Math.sin;
const sqrt = Math.sqrt;

const epsilon = 1e-12;
const pi = Math.PI;
const halfPi = pi / 2;
const tau = 2 * pi;

function acos(x) {
  return x > 1 ? 0 : x < -1 ? pi : Math.acos(x);
}

function asin(x) {
  return x >= 1 ? halfPi : x <= -1 ? -halfPi : Math.asin(x);
}


/***/ }),

/***/ "./node_modules/d3-shape/src/path.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-shape/src/path.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   withPath: () => (/* binding */ withPath)
/* harmony export */ });
/* harmony import */ var d3_path__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-path */ "./node_modules/d3-path/src/path.js");


function withPath(shape) {
  let digits = 3;

  shape.digits = function(_) {
    if (!arguments.length) return digits;
    if (_ == null) {
      digits = null;
    } else {
      const d = Math.floor(_);
      if (!(d >= 0)) throw new RangeError(`invalid digits: ${_}`);
      digits = d;
    }
    return shape;
  };

  return () => new d3_path__WEBPACK_IMPORTED_MODULE_0__.Path(digits);
}


/***/ }),

/***/ "./node_modules/d3-shape/src/point.js":
/*!********************************************!*\
  !*** ./node_modules/d3-shape/src/point.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   x: () => (/* binding */ x),
/* harmony export */   y: () => (/* binding */ y)
/* harmony export */ });
function x(p) {
  return p[0];
}

function y(p) {
  return p[1];
}


/***/ }),

/***/ "./node_modules/tslib/tslib.es6.mjs":
/*!******************************************!*\
  !*** ./node_modules/tslib/tslib.es6.mjs ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   __addDisposableResource: () => (/* binding */ __addDisposableResource),
/* harmony export */   __assign: () => (/* binding */ __assign),
/* harmony export */   __asyncDelegator: () => (/* binding */ __asyncDelegator),
/* harmony export */   __asyncGenerator: () => (/* binding */ __asyncGenerator),
/* harmony export */   __asyncValues: () => (/* binding */ __asyncValues),
/* harmony export */   __await: () => (/* binding */ __await),
/* harmony export */   __awaiter: () => (/* binding */ __awaiter),
/* harmony export */   __classPrivateFieldGet: () => (/* binding */ __classPrivateFieldGet),
/* harmony export */   __classPrivateFieldIn: () => (/* binding */ __classPrivateFieldIn),
/* harmony export */   __classPrivateFieldSet: () => (/* binding */ __classPrivateFieldSet),
/* harmony export */   __createBinding: () => (/* binding */ __createBinding),
/* harmony export */   __decorate: () => (/* binding */ __decorate),
/* harmony export */   __disposeResources: () => (/* binding */ __disposeResources),
/* harmony export */   __esDecorate: () => (/* binding */ __esDecorate),
/* harmony export */   __exportStar: () => (/* binding */ __exportStar),
/* harmony export */   __extends: () => (/* binding */ __extends),
/* harmony export */   __generator: () => (/* binding */ __generator),
/* harmony export */   __importDefault: () => (/* binding */ __importDefault),
/* harmony export */   __importStar: () => (/* binding */ __importStar),
/* harmony export */   __makeTemplateObject: () => (/* binding */ __makeTemplateObject),
/* harmony export */   __metadata: () => (/* binding */ __metadata),
/* harmony export */   __param: () => (/* binding */ __param),
/* harmony export */   __propKey: () => (/* binding */ __propKey),
/* harmony export */   __read: () => (/* binding */ __read),
/* harmony export */   __rest: () => (/* binding */ __rest),
/* harmony export */   __runInitializers: () => (/* binding */ __runInitializers),
/* harmony export */   __setFunctionName: () => (/* binding */ __setFunctionName),
/* harmony export */   __spread: () => (/* binding */ __spread),
/* harmony export */   __spreadArray: () => (/* binding */ __spreadArray),
/* harmony export */   __spreadArrays: () => (/* binding */ __spreadArrays),
/* harmony export */   __values: () => (/* binding */ __values),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise, SuppressedError, Symbol */

var extendStatics = function(d, b) {
  extendStatics = Object.setPrototypeOf ||
      ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
      function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
  return extendStatics(d, b);
};

function __extends(d, b) {
  if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics(d, b);
  function __() { this.constructor = d; }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = function() {
  __assign = Object.assign || function __assign(t) {
      for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
      }
      return t;
  }
  return __assign.apply(this, arguments);
}

function __rest(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
              t[p[i]] = s[p[i]];
      }
  return t;
}

function __decorate(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}

function __param(paramIndex, decorator) {
  return function (target, key) { decorator(target, key, paramIndex); }
}

function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
  function accept(f) { if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected"); return f; }
  var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
  var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
  var _, done = false;
  for (var i = decorators.length - 1; i >= 0; i--) {
      var context = {};
      for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
      for (var p in contextIn.access) context.access[p] = contextIn.access[p];
      context.addInitializer = function (f) { if (done) throw new TypeError("Cannot add initializers after decoration has completed"); extraInitializers.push(accept(f || null)); };
      var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
      if (kind === "accessor") {
          if (result === void 0) continue;
          if (result === null || typeof result !== "object") throw new TypeError("Object expected");
          if (_ = accept(result.get)) descriptor.get = _;
          if (_ = accept(result.set)) descriptor.set = _;
          if (_ = accept(result.init)) initializers.unshift(_);
      }
      else if (_ = accept(result)) {
          if (kind === "field") initializers.unshift(_);
          else descriptor[key] = _;
      }
  }
  if (target) Object.defineProperty(target, contextIn.name, descriptor);
  done = true;
};

function __runInitializers(thisArg, initializers, value) {
  var useValue = arguments.length > 2;
  for (var i = 0; i < initializers.length; i++) {
      value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
  }
  return useValue ? value : void 0;
};

function __propKey(x) {
  return typeof x === "symbol" ? x : "".concat(x);
};

function __setFunctionName(f, name, prefix) {
  if (typeof name === "symbol") name = name.description ? "[".concat(name.description, "]") : "";
  return Object.defineProperty(f, "name", { configurable: true, value: prefix ? "".concat(prefix, " ", name) : name });
};

function __metadata(metadataKey, metadataValue) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}

function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
  return new (P || (P = Promise))(function (resolve, reject) {
      function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
      function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
      function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}

function __generator(thisArg, body) {
  var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
  function verb(n) { return function (v) { return step([n, v]); }; }
  function step(op) {
      if (f) throw new TypeError("Generator is already executing.");
      while (g && (g = 0, op[0] && (_ = 0)), _) try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
          if (y = 0, t) op = [op[0] & 2, t.value];
          switch (op[0]) {
              case 0: case 1: t = op; break;
              case 4: _.label++; return { value: op[1], done: false };
              case 5: _.label++; y = op[1]; op = [0]; continue;
              case 7: op = _.ops.pop(); _.trys.pop(); continue;
              default:
                  if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                  if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                  if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                  if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                  if (t[2]) _.ops.pop();
                  _.trys.pop(); continue;
          }
          op = body.call(thisArg, _);
      } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
      if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
  }
}

var __createBinding = Object.create ? (function(o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m, k);
  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
  }
  Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

function __exportStar(m, o) {
  for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);
}

function __values(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m) return m.call(o);
  if (o && typeof o.length === "number") return {
      next: function () {
          if (o && i >= o.length) o = void 0;
          return { value: o && o[i++], done: !o };
      }
  };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}

function __read(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o), r, ar = [], e;
  try {
      while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
  }
  catch (error) { e = { error: error }; }
  finally {
      try {
          if (r && !r.done && (m = i["return"])) m.call(i);
      }
      finally { if (e) throw e.error; }
  }
  return ar;
}

/** @deprecated */
function __spread() {
  for (var ar = [], i = 0; i < arguments.length; i++)
      ar = ar.concat(__read(arguments[i]));
  return ar;
}

/** @deprecated */
function __spreadArrays() {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
  for (var r = Array(s), k = 0, i = 0; i < il; i++)
      for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
          r[k] = a[j];
  return r;
}

function __spreadArray(to, from, pack) {
  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
      if (ar || !(i in from)) {
          if (!ar) ar = Array.prototype.slice.call(from, 0, i);
          ar[i] = from[i];
      }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
}

function __await(v) {
  return this instanceof __await ? (this.v = v, this) : new __await(v);
}

function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var g = generator.apply(thisArg, _arguments || []), i, q = [];
  return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
  function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
  function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
  function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
  function fulfill(value) { resume("next", value); }
  function reject(value) { resume("throw", value); }
  function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
}

function __asyncDelegator(o) {
  var i, p;
  return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
  function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v; } : f; }
}

function __asyncValues(o) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var m = o[Symbol.asyncIterator], i;
  return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
  function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
  function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
}

function __makeTemplateObject(cooked, raw) {
  if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
  return cooked;
};

var __setModuleDefault = Object.create ? (function(o, v) {
  Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
  o["default"] = v;
};

function __importStar(mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
  __setModuleDefault(result, mod);
  return result;
}

function __importDefault(mod) {
  return (mod && mod.__esModule) ? mod : { default: mod };
}

function __classPrivateFieldGet(receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}

function __classPrivateFieldSet(receiver, state, value, kind, f) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
}

function __classPrivateFieldIn(state, receiver) {
  if (receiver === null || (typeof receiver !== "object" && typeof receiver !== "function")) throw new TypeError("Cannot use 'in' operator on non-object");
  return typeof state === "function" ? receiver === state : state.has(receiver);
}

function __addDisposableResource(env, value, async) {
  if (value !== null && value !== void 0) {
    if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
    var dispose;
    if (async) {
        if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
        dispose = value[Symbol.asyncDispose];
    }
    if (dispose === void 0) {
        if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
        dispose = value[Symbol.dispose];
    }
    if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
    env.stack.push({ value: value, dispose: dispose, async: async });
  }
  else if (async) {
    env.stack.push({ async: true });
  }
  return value;
}

var _SuppressedError = typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
  var e = new Error(message);
  return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};

function __disposeResources(env) {
  function fail(e) {
    env.error = env.hasError ? new _SuppressedError(e, env.error, "An error was suppressed during disposal.") : e;
    env.hasError = true;
  }
  function next() {
    while (env.stack.length) {
      var rec = env.stack.pop();
      try {
        var result = rec.dispose && rec.dispose.call(rec.value);
        if (rec.async) return Promise.resolve(result).then(next, function(e) { fail(e); return next(); });
      }
      catch (e) {
          fail(e);
      }
    }
    if (env.hasError) throw env.error;
  }
  return next();
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  __extends,
  __assign,
  __rest,
  __decorate,
  __param,
  __metadata,
  __awaiter,
  __generator,
  __createBinding,
  __exportStar,
  __values,
  __read,
  __spread,
  __spreadArrays,
  __spreadArray,
  __await,
  __asyncGenerator,
  __asyncDelegator,
  __asyncValues,
  __makeTemplateObject,
  __importStar,
  __importDefault,
  __classPrivateFieldGet,
  __classPrivateFieldSet,
  __classPrivateFieldIn,
  __addDisposableResource,
  __disposeResources,
});


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/create fake namespace object */
/******/ 	(() => {
/******/ 		var getProto = Object.getPrototypeOf ? (obj) => (Object.getPrototypeOf(obj)) : (obj) => (obj.__proto__);
/******/ 		var leafPrototypes;
/******/ 		// create a fake namespace object
/******/ 		// mode & 1: value is a module id, require it
/******/ 		// mode & 2: merge all properties of value into the ns
/******/ 		// mode & 4: return value when already ns object
/******/ 		// mode & 16: return value when it's Promise-like
/******/ 		// mode & 8|1: behave like require
/******/ 		__webpack_require__.t = function(value, mode) {
/******/ 			if(mode & 1) value = this(value);
/******/ 			if(mode & 8) return value;
/******/ 			if(typeof value === 'object' && value) {
/******/ 				if((mode & 4) && value.__esModule) return value;
/******/ 				if((mode & 16) && typeof value.then === 'function') return value;
/******/ 			}
/******/ 			var ns = Object.create(null);
/******/ 			__webpack_require__.r(ns);
/******/ 			var def = {};
/******/ 			leafPrototypes = leafPrototypes || [null, getProto({}), getProto([]), getProto(getProto)];
/******/ 			for(var current = mode & 2 && value; typeof current == 'object' && !~leafPrototypes.indexOf(current); current = getProto(current)) {
/******/ 				Object.getOwnPropertyNames(current).forEach((key) => (def[key] = () => (value[key])));
/******/ 			}
/******/ 			def['default'] = () => (value);
/******/ 			__webpack_require__.d(ns, def);
/******/ 			return ns;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/ensure chunk */
/******/ 	(() => {
/******/ 		__webpack_require__.f = {};
/******/ 		// This file contains only the entry chunk.
/******/ 		// The chunk loading function for additional chunks
/******/ 		__webpack_require__.e = (chunkId) => {
/******/ 			return Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key) => {
/******/ 				__webpack_require__.f[key](chunkId, promises);
/******/ 				return promises;
/******/ 			}, []));
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/get javascript chunk filename */
/******/ 	(() => {
/******/ 		// This function allow to reference async chunks
/******/ 		__webpack_require__.u = (chunkId) => {
/******/ 			// return url for filenames based on template
/******/ 			return "jimu-ui/chunks/" + chunkId + ".js";
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/get mini-css chunk filename */
/******/ 	(() => {
/******/ 		// This function allow to reference async chunks
/******/ 		__webpack_require__.miniCssF = (chunkId) => {
/******/ 			// return url for filenames based on template
/******/ 			return undefined;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/load script */
/******/ 	(() => {
/******/ 		var inProgress = {};
/******/ 		var dataWebpackPrefix = "exb-client:";
/******/ 		// loadScript function to load a script via script tag
/******/ 		__webpack_require__.l = (url, done, key, chunkId) => {
/******/ 			if(inProgress[url]) { inProgress[url].push(done); return; }
/******/ 			var script, needAttach;
/******/ 			if(key !== undefined) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				for(var i = 0; i < scripts.length; i++) {
/******/ 					var s = scripts[i];
/******/ 					if(s.getAttribute("src") == url || s.getAttribute("data-webpack") == dataWebpackPrefix + key) { script = s; break; }
/******/ 				}
/******/ 			}
/******/ 			if(!script) {
/******/ 				needAttach = true;
/******/ 				script = document.createElement('script');
/******/ 		
/******/ 				script.charset = 'utf-8';
/******/ 				script.timeout = 120;
/******/ 				if (__webpack_require__.nc) {
/******/ 					script.setAttribute("nonce", __webpack_require__.nc);
/******/ 				}
/******/ 				script.setAttribute("data-webpack", dataWebpackPrefix + key);
/******/ 		
/******/ 				script.src = url;
/******/ 			}
/******/ 			inProgress[url] = [done];
/******/ 			var onScriptComplete = (prev, event) => {
/******/ 				// avoid mem leaks in IE.
/******/ 				script.onerror = script.onload = null;
/******/ 				clearTimeout(timeout);
/******/ 				var doneFns = inProgress[url];
/******/ 				delete inProgress[url];
/******/ 				script.parentNode && script.parentNode.removeChild(script);
/******/ 				doneFns && doneFns.forEach((fn) => (fn(event)));
/******/ 				if(prev) return prev(event);
/******/ 			}
/******/ 			var timeout = setTimeout(onScriptComplete.bind(null, undefined, { type: 'timeout', target: script }), 120000);
/******/ 			script.onerror = onScriptComplete.bind(null, script.onerror);
/******/ 			script.onload = onScriptComplete.bind(null, script.onload);
/******/ 			needAttach && document.head.appendChild(script);
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	(() => {
/******/ 		__webpack_require__.p = "";
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/jsonp chunk loading */
/******/ 	(() => {
/******/ 		// no baseURI
/******/ 		
/******/ 		// object to store loaded and loading chunks
/******/ 		// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 		// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded
/******/ 		var installedChunks = {
/******/ 			"jimu-ui/advanced/chart-engine": 0
/******/ 		};
/******/ 		
/******/ 		__webpack_require__.f.j = (chunkId, promises) => {
/******/ 				// JSONP chunk loading for javascript
/******/ 				var installedChunkData = __webpack_require__.o(installedChunks, chunkId) ? installedChunks[chunkId] : undefined;
/******/ 				if(installedChunkData !== 0) { // 0 means "already installed".
/******/ 		
/******/ 					// a Promise means "currently loading".
/******/ 					if(installedChunkData) {
/******/ 						promises.push(installedChunkData[2]);
/******/ 					} else {
/******/ 						if(true) { // all chunks have JS
/******/ 							// setup Promise in chunk cache
/******/ 							var promise = new Promise((resolve, reject) => (installedChunkData = installedChunks[chunkId] = [resolve, reject]));
/******/ 							promises.push(installedChunkData[2] = promise);
/******/ 		
/******/ 							// start chunk loading
/******/ 							var url = __webpack_require__.p + __webpack_require__.u(chunkId);
/******/ 							// create error before stack unwound to get useful stacktrace later
/******/ 							var error = new Error();
/******/ 							var loadingEnded = (event) => {
/******/ 								if(__webpack_require__.o(installedChunks, chunkId)) {
/******/ 									installedChunkData = installedChunks[chunkId];
/******/ 									if(installedChunkData !== 0) installedChunks[chunkId] = undefined;
/******/ 									if(installedChunkData) {
/******/ 										var errorType = event && (event.type === 'load' ? 'missing' : event.type);
/******/ 										var realSrc = event && event.target && event.target.src;
/******/ 										error.message = 'Loading chunk ' + chunkId + ' failed.\n(' + errorType + ': ' + realSrc + ')';
/******/ 										error.name = 'ChunkLoadError';
/******/ 										error.type = errorType;
/******/ 										error.request = realSrc;
/******/ 										installedChunkData[1](error);
/******/ 									}
/******/ 								}
/******/ 							};
/******/ 							__webpack_require__.l(url, loadingEnded, "chunk-" + chunkId, chunkId);
/******/ 						}
/******/ 					}
/******/ 				}
/******/ 		};
/******/ 		
/******/ 		// no prefetching
/******/ 		
/******/ 		// no preloaded
/******/ 		
/******/ 		// no HMR
/******/ 		
/******/ 		// no HMR manifest
/******/ 		
/******/ 		// no on chunks loaded
/******/ 		
/******/ 		// install a JSONP callback for chunk loading
/******/ 		var webpackJsonpCallback = (parentChunkLoadingFunction, data) => {
/******/ 			var [chunkIds, moreModules, runtime] = data;
/******/ 			// add "moreModules" to the modules object,
/******/ 			// then flag all "chunkIds" as loaded and fire callback
/******/ 			var moduleId, chunkId, i = 0;
/******/ 			if(chunkIds.some((id) => (installedChunks[id] !== 0))) {
/******/ 				for(moduleId in moreModules) {
/******/ 					if(__webpack_require__.o(moreModules, moduleId)) {
/******/ 						__webpack_require__.m[moduleId] = moreModules[moduleId];
/******/ 					}
/******/ 				}
/******/ 				if(runtime) var result = runtime(__webpack_require__);
/******/ 			}
/******/ 			if(parentChunkLoadingFunction) parentChunkLoadingFunction(data);
/******/ 			for(;i < chunkIds.length; i++) {
/******/ 				chunkId = chunkIds[i];
/******/ 				if(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {
/******/ 					installedChunks[chunkId][0]();
/******/ 				}
/******/ 				installedChunks[chunkId] = 0;
/******/ 			}
/******/ 		
/******/ 		}
/******/ 		
/******/ 		var chunkLoadingGlobal = self["webpackChunkexb_client"] = self["webpackChunkexb_client"] || [];
/******/ 		chunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));
/******/ 		chunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be isolated against other entry modules.
(() => {
/*!******************************************!*\
  !*** ./jimu-core/lib/set-public-path.ts ***!
  \******************************************/
/**
 * Webpack will replace __webpack_public_path__ with __webpack_require__.p to set the public path dynamically.
 * The reason why we can't set the publicPath in webpack config is: we change the publicPath when download.
 * */
// eslint-disable-next-line
// @ts-ignore
__webpack_require__.p = window.jimuConfig.baseUrl;

})();

// This entry need to be wrapped in an IIFE because it need to be in strict mode.
(() => {
"use strict";
/*!*******************************************!*\
  !*** ./jimu-ui/advanced/chart-engine.tsx ***!
  \*******************************************/
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AnimatedThemeAm5: () => (/* reexport safe */ _lib_chart_engine__WEBPACK_IMPORTED_MODULE_0__.AnimatedThemeAm5),
/* harmony export */   AxisRendererXAm5: () => (/* reexport safe */ _lib_chart_engine__WEBPACK_IMPORTED_MODULE_0__.AxisRendererXAm5),
/* harmony export */   AxisRendererYAm5: () => (/* reexport safe */ _lib_chart_engine__WEBPACK_IMPORTED_MODULE_0__.AxisRendererYAm5),
/* harmony export */   BulletAm5: () => (/* reexport safe */ _lib_chart_engine__WEBPACK_IMPORTED_MODULE_0__.BulletAm5),
/* harmony export */   CategoryAxisAm5: () => (/* reexport safe */ _lib_chart_engine__WEBPACK_IMPORTED_MODULE_0__.CategoryAxisAm5),
/* harmony export */   CircleAm5: () => (/* reexport safe */ _lib_chart_engine__WEBPACK_IMPORTED_MODULE_0__.CircleAm5),
/* harmony export */   ColumnSeries: () => (/* reexport safe */ _lib_chart_engine__WEBPACK_IMPORTED_MODULE_0__.ColumnSeries),
/* harmony export */   ColumnSeriesAm5: () => (/* reexport safe */ _lib_chart_engine__WEBPACK_IMPORTED_MODULE_0__.ColumnSeriesAm5),
/* harmony export */   ContainerAm5: () => (/* reexport safe */ _lib_chart_engine__WEBPACK_IMPORTED_MODULE_0__.ContainerAm5),
/* harmony export */   DarkThemeAm5: () => (/* reexport safe */ _lib_chart_engine__WEBPACK_IMPORTED_MODULE_0__.DarkThemeAm5),
/* harmony export */   Exporting: () => (/* reexport safe */ _lib_chart_engine__WEBPACK_IMPORTED_MODULE_0__.Exporting),
/* harmony export */   GridLayoutAm5: () => (/* reexport safe */ _lib_chart_engine__WEBPACK_IMPORTED_MODULE_0__.GridLayoutAm5),
/* harmony export */   LabelAm5: () => (/* reexport safe */ _lib_chart_engine__WEBPACK_IMPORTED_MODULE_0__.LabelAm5),
/* harmony export */   LegendAm5: () => (/* reexport safe */ _lib_chart_engine__WEBPACK_IMPORTED_MODULE_0__.LegendAm5),
/* harmony export */   LineSeriesAm5: () => (/* reexport safe */ _lib_chart_engine__WEBPACK_IMPORTED_MODULE_0__.LineSeriesAm5),
/* harmony export */   NumberFormatterAm5: () => (/* reexport safe */ _lib_chart_engine__WEBPACK_IMPORTED_MODULE_0__.NumberFormatterAm5),
/* harmony export */   PieChartAm5: () => (/* reexport safe */ _lib_chart_engine__WEBPACK_IMPORTED_MODULE_0__.PieChartAm5),
/* harmony export */   PieSeriesAm5: () => (/* reexport safe */ _lib_chart_engine__WEBPACK_IMPORTED_MODULE_0__.PieSeriesAm5),
/* harmony export */   RectangleAm5: () => (/* reexport safe */ _lib_chart_engine__WEBPACK_IMPORTED_MODULE_0__.RectangleAm5),
/* harmony export */   ResponsiveThemeAm5: () => (/* reexport safe */ _lib_chart_engine__WEBPACK_IMPORTED_MODULE_0__.ResponsiveThemeAm5),
/* harmony export */   ScrollbarAm5: () => (/* reexport safe */ _lib_chart_engine__WEBPACK_IMPORTED_MODULE_0__.ScrollbarAm5),
/* harmony export */   TooltipAm5: () => (/* reexport safe */ _lib_chart_engine__WEBPACK_IMPORTED_MODULE_0__.TooltipAm5),
/* harmony export */   TriangleAm5: () => (/* reexport safe */ _lib_chart_engine__WEBPACK_IMPORTED_MODULE_0__.TriangleAm5),
/* harmony export */   ValueAxisAm5: () => (/* reexport safe */ _lib_chart_engine__WEBPACK_IMPORTED_MODULE_0__.ValueAxisAm5),
/* harmony export */   XYChartAm5: () => (/* reexport safe */ _lib_chart_engine__WEBPACK_IMPORTED_MODULE_0__.XYChartAm5),
/* harmony export */   XYCursorAm5: () => (/* reexport safe */ _lib_chart_engine__WEBPACK_IMPORTED_MODULE_0__.XYCursorAm5),
/* harmony export */   colorAm5: () => (/* reexport safe */ _lib_chart_engine__WEBPACK_IMPORTED_MODULE_0__.colorAm5),
/* harmony export */   createRoot: () => (/* reexport safe */ _lib_chart_engine__WEBPACK_IMPORTED_MODULE_0__.createRoot),
/* harmony export */   p0: () => (/* reexport safe */ _lib_chart_engine__WEBPACK_IMPORTED_MODULE_0__.p0),
/* harmony export */   p100: () => (/* reexport safe */ _lib_chart_engine__WEBPACK_IMPORTED_MODULE_0__.p100),
/* harmony export */   p50: () => (/* reexport safe */ _lib_chart_engine__WEBPACK_IMPORTED_MODULE_0__.p50),
/* harmony export */   percentAm5: () => (/* reexport safe */ _lib_chart_engine__WEBPACK_IMPORTED_MODULE_0__.percentAm5)
/* harmony export */ });
/* harmony import */ var _lib_chart_engine__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/chart-engine */ "./jimu-ui/advanced/lib/chart-engine/index.ts");


})();

/******/ 	return __webpack_exports__;
/******/ })()

			);
		}
	};
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isb0RBQVk7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFD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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELFFBQVE7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsWUFBWTtBQUNsRSxzREFBc0QsWUFBWTtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxzREFBYztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsNkRBQTZEO0FBQzdHO0FBQ0E7QUFDQSxnREFBZ0QseURBQXlEO0FBQ3pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUSxrREFBVztBQUNuQjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsdURBQWdCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksa0RBQVc7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVkscURBQWM7QUFDMUIsWUFBWSxrREFBVztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsa0RBQVc7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsMEVBQTBFO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsNkRBQVM7QUFDcEIsQ0FBQztBQUNEOzs7Ozs7Ozs7Ozs7Ozs7O0FDLzVCbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0EsU0FBUyxxRUFBcUU7QUFDOUU7QUFDQTtBQUNPLHdCQUF3QixxREFBSztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcscURBQUs7QUFDaEIsQ0FBQztBQUNEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDOUJ5RDtBQUNGO0FBQ0E7QUFDakI7QUFDUjtBQUNVO0FBQ1c7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsdUVBQXVFO0FBQ2hGO0FBQ08sMkJBQTJCLDJEQUFRO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHlEQUFZLENBQUMseURBQVEsT0FBTyxTQUFTLCtDQUFRO0FBQ3BFLDJCQUEyQix1REFBZ0I7QUFDM0MsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHlEQUFZLENBQUMseURBQVEsT0FBTyxTQUFTLHVDQUFJO0FBQ2hFLDJCQUEyQix1REFBZ0I7QUFDM0MsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHlEQUFZLENBQUMseURBQVEsT0FBTyxTQUFTLDJEQUFRO0FBQ3BFLDJCQUEyQix1REFBZ0I7QUFDM0MsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUNBO0FBQ0EsaUNBQWlDLGNBQWM7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxjQUFjO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEscURBQWM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIscURBQWM7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHFEQUFjO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSx1REFBZ0IsMENBQTBDO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHlFQUFjO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELFNBQVM7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsdUNBQUk7QUFDZixDQUFDO0FBQ0Q7Ozs7Ozs7Ozs7Ozs7Ozs7QUM5ZHlEO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBLFNBQVMsbUVBQW1FO0FBQzVFO0FBQ0E7QUFDTyxtQkFBbUIsMkRBQVE7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxxQkFBcUI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCx5REFBUTtBQUM1RCx5Q0FBeUMseURBQVE7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCx5REFBUTtBQUMxRCx1Q0FBdUMseURBQVE7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxrREFBVztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxrREFBVztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGtEQUFXO0FBQzNCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isa0RBQVc7QUFDM0I7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIseURBQVksQ0FBQyx5REFBUSxPQUFPLFNBQVMsMkRBQVE7QUFDM0UsdUJBQXVCLHVEQUFnQjtBQUN2QyxTQUFTO0FBQ1QsZ0NBQWdDLHlEQUFZLENBQUMseURBQVEsT0FBTyxTQUFTLDJEQUFRO0FBQzdFLHVCQUF1Qix1REFBZ0I7QUFDdkMsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyw2REFBUyxxQkFBcUIsc0JBQXNCLHdEQUFLLFlBQVk7QUFDMUcsc0RBQXNELDJEQUFRO0FBQzlEO0FBQ0EsYUFBYTtBQUNiO0FBQ0Esb0RBQW9ELDJEQUFRO0FBQzVEO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxxREFBcUQsNENBQTRDO0FBQ2pHLG1EQUFtRCw0Q0FBNEM7QUFDL0Y7QUFDQTtBQUNBO0FBQ0EsMEVBQTBFLDZEQUFRLFNBQVMsY0FBYyxJQUFJO0FBQzdHO0FBQ0E7QUFDQSw4Q0FBOEMsMkRBQVE7QUFDdEQsK0RBQStELDRDQUE0QztBQUMzRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLCtDQUErQztBQUMzRjtBQUNBLGdEQUFnRCwrQ0FBK0M7QUFDL0YsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsK0NBQVE7QUFDbkIsQ0FBQztBQUNEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDbm1Ca0M7QUFDd0I7QUFDTDtBQUNOO0FBQ1k7QUFDRjtBQUNSO0FBQ0k7QUFDRjtBQUNBO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxnRUFBZ0U7QUFDekU7QUFDTyx1QkFBdUIsdURBQU07QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLDZEQUFTLG1CQUFtQjtBQUNsRSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLDBFQUEwRTtBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGlEQUFJO0FBQzNCLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Es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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFFBQVEsa0RBQVc7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsUUFBUSxrREFBVztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtEQUFXO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEVBQTRFLHdCQUF3QjtBQUNwRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsSUFBSTtBQUN4QjtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLDBFQUEwRTtBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyx1REFBTTtBQUNqQixDQUFDO0FBQ0Q7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzkvQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUMxRStDO0FBQ1Y7QUFDd0I7QUFDSjtBQUNSO0FBQ047QUFDUTtBQUNNO0FBQ1o7QUFDRTtBQUNKO0FBQ2M7QUFDSjtBQUNRO0FBQ2xCO0FBQ2M7QUFDSDtBQUNXO0FBQ2xCO0FBQ1Y7QUFDa0I7QUFDakI7QUFDQztBQUNBO0FBQ0U7QUFDRjtBQUNGO0FBQ0g7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxzRUFBc0U7QUFDL0U7QUFDTztBQUNQLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIseURBQXlEO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsa0VBQWU7QUFDdEMsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsb0RBQVEsYUFBYTtBQUN4QyxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsbURBQUU7QUFDckIsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGlHQUFpRztBQUNsSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsZ0ZBQWdGO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsa0ZBQWtGO0FBQ25HO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsZ0ZBQWdGO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsa0VBQWUsYUFBYTtBQUMvQyxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLDhFQUE4RTtBQUMvRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDhEQUFhLGFBQWE7QUFDN0MsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiw4RUFBOEU7QUFDL0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixzRUFBaUIsYUFBYTtBQUNqRCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsZ0VBQWdFO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixpR0FBaUc7QUFDbEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGtFQUFjLGFBQWE7QUFDOUMsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHNFQUFnQixhQUFhO0FBQ2hELFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiwwREFBVSxhQUFhO0FBQzFDLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtB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U0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIscURBQVE7QUFDM0IsWUFBWSxxREFBa0I7QUFDOUIsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyx5REFBUztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGtEQUFnQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsdURBQXFCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELGlEQUFTO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHNEQUFtQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQywyQ0FBTTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsb0VBQWM7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGdEQUFjO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08scUJBQXFCLGdEQUFNO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7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QUMxQjtBQUNBO0FBQ0EsWUFBWSxnREFBYztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsbUVBQW1FO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxtRUFBbUU7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLG1FQUFtRTtBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixxREFBbUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZ0RBQU07QUFDakIsQ0FBQztBQUNEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDbDdEa0M7QUFDc0I7QUFDaEI7QUFDSTtBQUM1QztBQUNBO0FBQ0E7QUFDTyxtQkFBbUIsMkNBQU07QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxvREFBUTtBQUNqRDtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsNkNBQVc7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLG9FQUFjO0FB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VDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sa0NBQWtDLHlEQUFhO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixnREFBTTtBQUM3QixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsZ0RBQU07QUFDN0IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsZ0RBQU07QUFDN0IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix1REFBcUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLCtCQUErQjtBQUNqRSxrQ0FBa0MsZ0NBQWdDO0FBQ2xFLGtDQUFrQyxtQ0FBbUM7QUFDckUsa0NBQWtDLGtDQUFrQztBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsb0RBQVEsVUFBVTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDZDQUFXO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksNkNBQVc7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLG9EQUFrQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsNkNBQVc7QUFDbkI7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxnREFBYztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksNkNBQVc7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksNkNBQVc7QUFDdkI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixZQUFZO0FBQ3ZDLDJCQUEyQixZQUFZO0FBQ3ZDLDJCQUEyQixZQUFZO0FBQ3ZDLDJCQUEyQixZQUFZO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixrREFBa0Q7QUFDN0UsMkJBQTJCLGtEQUFrRDtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsb0RBQW9EO0FBQy9FLDJCQUEyQixvREFBb0Q7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG9EQUFrQixxQ0FBcUMsK0NBQWEsa0JBQWtCLCtDQUFhO0FBQzNILDJCQUEyQixxQ0FBcUM7QUFDaEUsMkJBQTJCLHlDQUF5QztBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHNCQUFzQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsc0JBQXNCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDBCQUEwQjtBQUNyRCwyQkFBMkIsNEJBQTRCO0FBQ3ZELDJCQUEyQiwwQkFBMEI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDBCQUEwQjtBQUNyRCwyQkFBMkIsMEJBQTBCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsc0JBQXNCO0FBQ2pELDJCQUEyQiwrQkFBK0I7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsZ0RBQVM7QUFDNUIsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsOENBQUs7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyw4Q0FBSztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxpQkFBaUI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsaUJBQWlCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLGlCQUFpQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxpQkFBaUI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsaUJBQWlCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxpQkFBaUI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLGlCQUFpQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsaUJBQWlCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxpQkFBaUI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxpQkFBaUI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLGlCQUFpQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsaUJBQWlCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsaUJBQWlCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxpQkFBaUI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsaUJBQWlCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLGlCQUFpQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsaUJBQWlCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxtRUFBVztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIsd0JBQXdCLDZDQUFXO0FBQ25DO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLDZDQUFXO0FBQ25CO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDZDQUFXO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDZDQUFXO0FBQ3ZCO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksNkNBQVc7QUFDdkI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsOENBQUs7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxnREFBYyxXQUFXLGdEQUFjO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLGVBQWU7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQix1REFBTztBQUMxQixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFlBQVksaURBQWU7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyw2QkFBNkIseURBQWE7QUFDakQ7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsUUFBUSw2Q0FBVztBQUNuQjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxvREFBb0Qsd0NBQXdDO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsNkNBQVc7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7O0FDcjdJQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsOEJBQThCO0FBQy9COzs7Ozs7Ozs7Ozs7Ozs7O0FDMUIyQztBQUMzQztBQUNBO0FBQ0E7QUFDQSxTQUFTLHlGQUF5RjtBQUNsRztBQUNPLHNCQUFzQixnREFBTTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELDBCQUEwQjtBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELDBDQUEwQztBQUMvRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsMEJBQTBCO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUMvUmdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSxvQkFBb0IsWUFBWTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0Esb0JBQW9CLFlBQVk7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBLG9CQUFvQixZQUFZO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0Esb0JBQW9CLFlBQVk7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSxvQkFBb0IsWUFBWTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLHdCQUF3QixZQUFZO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0Esb0JBQW9CLFlBQVk7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLFNBQVMsMkNBQWM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLDJDQUFjO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsWUFBWTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLHdCQUF3QixTQUFTO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSxvQkFBb0IsWUFBWTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0Esb0JBQW9CLFlBQVk7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN2RWtDO0FBQ2M7QUFDVjtBQUNOO0FBQ0U7QUFDM0IsNEJBQTRCLDJDQUFNO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSwyQ0FBYztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLDJDQUFjO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsRUFBRTtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxTQUFTO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxFQUFFLFVBQVUsRUFBRTtBQUM3RDtBQUNBLG1EQUFtRCxFQUFFLFVBQVUsRUFBRTtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGlCQUFpQjtBQUN6QztBQUNBO0FBQ0EseUJBQXlCLGlEQUFvQjtBQUM3QztBQUNBO0FBQ0EseUJBQXlCLGlEQUFvQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3AzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2tDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxRQUFRLHdDQUFXO0FBQ25CO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxRQUFRLHdDQUFXO0FBQ25CO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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cUQ7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxTQUFTO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qiw4Q0FBaUIsRUFBRSw2Q0FBZ0I7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsaURBQW9CO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNwY0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLCtCQUErQjtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDTztBQUNQLDRCQUE0Qix5Q0FBWTtBQUN4QztBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUM1SnNDO0FBQ2M7QUFDUDtBQUNYO0FBQ0s7QUFDSDtBQUNKO0FBQ0U7QUFDQTtBQUNsQztBQUNBO0FBQ0E7QUFDQSxTQUFTLG9FQUFvRTtBQUM3RTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxvRUFBb0U7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiwrQ0FBUTtBQUMzQixnQkFBZ0IsK0NBQWtCO0FBQ2xDO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxTQUFTO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyw2REFBNkQ7QUFDdEU7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDZEQUFlO0FBQ3RDLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsMERBQWM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLDJEQUEyRDtBQUNwRTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFFBQVEseUNBQVk7QUFDcEI7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHlDQUFZO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFlBQVkseUNBQVk7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLCtFQUErRTtBQUM1RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiwrQ0FBUTtBQUMzQixZQUFZLCtDQUFrQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsK0VBQStFO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsK0NBQVE7QUFDM0IsWUFBWSwrQ0FBa0I7QUFDOUI7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSx3Q0FBVztBQUN2QjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSx3Q0FBVztBQUN2QjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSwyREFBMkQ7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSwyREFBMkQ7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsMkRBQTJEO0FBQ3hFO0FBQ0E7QUFDQSxRQUFRLHdDQUFXLENBQUMseUNBQVk7QUFDaEM7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLDRFQUE0RTtBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsMkRBQTJEO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBLFFBQVEseUNBQVk7QUFDcEI7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGdGQUFnRjtBQUM3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQseUNBQVk7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQseUNBQVk7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLDRFQUE0RTtBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsR0FBRztBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDJDQUFNO0FBQzdCLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLDRFQUE0RTtBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHdDQUFXO0FBQ25CO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSx3Q0FBVztBQUNuQjtBQUNBLFNBQVM7QUFDVCx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsNkRBQWU7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QXlEO0FBQ2xFO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isd0NBQVc7QUFDM0I7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSx1Q0FBVTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsNkNBQWdCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSwyQ0FBYztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSx3Q0FBVztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isd0NBQVc7QUFDM0I7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLGFBQWE7QUFDYjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLCtDQUFRO0FBQ2xDO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsd0NBQVc7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULG1CQUFtQixvREFBYTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLCtDQUFrQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsK0NBQWtCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLCtDQUFrQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsK0NBQWtCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLCtDQUFrQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7OztBQ3BVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3BKa0M7QUFDYztBQUNaO0FBQ0Y7QUFDRjtBQUNoQztBQUNBO0FBQ0E7QUFDQSxTQUFTLGdGQUFnRjtBQUN6RjtBQUNBO0FBQ08sOEJBQThCLDJDQUFNO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsOENBQThDO0FBQzVELGNBQWMsOENBQThDO0FBQzVELGNBQWMsOENBQThDO0FBQzVELGNBQWMsZ0RBQWdEO0FBQzlELGNBQWMsZ0RBQWdEO0FBQzlELGNBQWMsZ0RBQWdEO0FBQzlELGNBQWMsZ0RBQWdEO0FBQzlELGNBQWM7QUFDZDtBQUNBO0FBQ0EsY0FBYyxnREFBZ0Q7QUFDOUQsY0FBYyxnREFBZ0Q7QUFDOUQsY0FBYyxnREFBZ0Q7QUFDOUQsY0FBYyxnREFBZ0Q7QUFDOUQsY0FBYyxnREFBZ0Q7QUFDOUQsY0FBYyw4Q0FBOEM7QUFDNUQsY0FBYyw4Q0FBOEM7QUFDNUQsY0FBYztBQUNkO0FBQ0E7QUFDQSxjQUFjLHdDQUF3QztBQUN0RCxjQUFjLDRDQUE0QztBQUMxRCxjQUFjLCtDQUErQztBQUM3RCxjQUFjLGtEQUFrRDtBQUNoRSxjQUFjLHFEQUFxRDtBQUNuRSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLDJDQUFjO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDJDQUFjO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsK0NBQWtCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQix5Q0FBWTtBQUN0QztBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsOENBQWlCO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsK0NBQWtCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSx5Q0FBWTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHlEQUFhO0FBQ3RDLDRCQUE0QixtQkFBbUI7QUFDL0M7QUFDQTtBQUNBLGdEQUFnRCwrQ0FBa0I7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUVBQXlFLEVBQUUsZ0JBQWdCLEVBQUU7QUFDN0Y7QUFDQTtBQUNBLHdFQUF3RSxFQUFFLGdCQUFnQixFQUFFO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0VBQStFLDhDQUFpQjtBQUNoRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixpREFBb0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsVUFBVTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLFNBQVM7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLCtDQUFrQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsK0NBQWtCO0FBQzlDO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNqZWtDO0FBQzNCO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDTztBQUNQLDJCQUEyQjtBQUMzQjtBQUNPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLElBQUksd0NBQVc7QUFDZjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNsRkE7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFlBQVk7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNB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Q0FBVztBQUMxRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsa0VBQWtFO0FBQzNFO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN0UG9EO0FBQ0M7QUFDbkI7QUFDRTtBQUM3QjtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsMkNBQWM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsMkNBQWM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiwyQ0FBYztBQUNqQztBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7OztBQ3RpQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsWUFBWSxzREFBc0Q7QUFDbEU7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsNEVBQTRFO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ2xKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDTztBQUNQOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDOU5nQztBQUNFO0FBQ0U7QUFDaUI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBLGVBQWUsK0NBQVE7QUFDdkI7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLHdCQUF3QixvREFBYTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFlBQVkseUNBQVk7QUFDeEI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsMkNBQWM7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08seUJBQXlCLG9EQUFhO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHdDQUFXO0FBQ25CO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ087QUFDUCxRQUFRLDJDQUFjO0FBQ3RCO0FBQ0E7QUFDQSxnQ0FBZ0MsMkNBQWMsbUJBQW1CLDJDQUFjO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Qsb0JBQW9CO0FBQ3RFLGtEQUFrRCwyREFBMkQ7QUFDN0c7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLHVDQUF1QztBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EsNERBQTRELGlCQUFpQjtBQUM3RSwyREFBMkQsb0JBQW9CO0FBQy9FO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLHNEQUFzRCx3QkFBd0Isc0JBQXNCLHdCQUF3QjtBQUNuSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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Q0E7QUFDQTtBQUNBLFNBQVMsNkRBQTZEO0FBQ3RFO0FBQ08sOEJBQThCLDhDQUFLO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsdUJBQXVCLDhEQUFhO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsNkRBQTZEO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLG9EQUFhO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxrREFBVztBQUNuQjtBQUNBLFNBQVM7QUFDVCxRQUFRLGtEQUFXO0FBQ25CO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsb0RBQUk7QUFDN0I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QiwyREFBTztBQUMvQjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QiwyREFBTztBQUMvQjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsMkRBQU87QUFDL0I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7Ozs7Ozs7Ozs7Ozs7OztBQzFyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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RTNCLE1BQU0sY0FBYyxHQUFHLE9BQU87QUFFOUIseUVBQXlFO0FBQ3pFLE1BQU0sT0FBTyxHQUFHLElBQUksR0FBRyxDQUE2QjtJQUNsRCxDQUFDLElBQUksRUFBRSxHQUFHLEVBQUUsQ0FBQyw0T0FBd0MsQ0FBQztJQUN0RCxDQUFDLE9BQU8sRUFBRSxHQUFHLEVBQUUsQ0FBQyw2T0FBMkMsQ0FBQztJQUM1RCxDQUFDLE9BQU8sRUFBRSxHQUFHLEVBQUUsQ0FBQyxxUEFBMkMsQ0FBQztJQUM1RCxDQUFDLE9BQU8sRUFBRSxHQUFHLEVBQUUsQ0FBQyxxUEFBMkMsQ0FBQztJQUM1RCxDQUFDLE9BQU8sRUFBRSxHQUFHLEVBQUUsQ0FBQyxxUEFBMkMsQ0FBQztJQUM1RCxDQUFDLE9BQU8sRUFBRSxHQUFHLEVBQUUsQ0FBQyxxUEFBMkMsQ0FBQztJQUM1RCxDQUFDLE9BQU8sRUFBRSxHQUFHLEVBQUUsQ0FBQyxxUEFBMkMsQ0FBQztJQUM1RCxDQUFDLE9BQU8sRUFBRSxHQUFHLEVBQUUsQ0FBQyxxUEFBMkMsQ0FBQztJQUM1RCxDQUFDLE9BQU8sRUFBRSxHQUFHLEVBQUUsQ0FBQyxxUEFBMkMsQ0FBQztJQUM1RCxDQUFDLE9BQU8sRUFBRSxHQUFHLEVBQUUsQ0FBQyw2T0FBMkMsQ0FBQztJQUM1RCxDQUFDLE9BQU8sRUFBRSxHQUFHLEVBQUUsQ0FBQyw2T0FBMkMsQ0FBQztJQUM1RCxDQUFDLE9BQU8sRUFBRSxHQUFHLEVBQUUsQ0FBQyw2T0FBMkMsQ0FBQztJQUM1RCxDQUFDLE9BQU8sRUFBRSxHQUFHLEVBQUUsQ0FBQyxxUEFBMkMsQ0FBQztJQUM1RCxDQUFDLE9BQU8sRUFBRSxHQUFHLEVBQUUsQ0FBQyxxUEFBMkMsQ0FBQztJQUM1RCxDQUFDLE9BQU8sRUFBRSxHQUFHLEVBQUUsQ0FBQyxxUEFBMkMsQ0FBQztJQUM1RCxDQUFDLE9BQU8sRUFBRSxHQUFHLEVBQUUsQ0FBQyxxUEFBMkMsQ0FBQztJQUM1RCxDQUFDLE9BQU8sRUFBRSxHQUFHLEVBQUUsQ0FBQyxxUEFBMkMsQ0FBQztJQUM1RCxDQUFDLE9BQU8sRUFBRSxHQUFHLEVBQUUsQ0FBQyxxUEFBMkMsQ0FBQztJQUM1RCxDQUFDLE9BQU8sRUFBRSxHQUFHLEVBQUUsQ0FBQyxxUEFBMkMsQ0FBQztJQUM1RCxDQUFDLE9BQU8sRUFBRSxHQUFHLEVBQUUsQ0FBQyxxUEFBMkMsQ0FBQztJQUM1RCxDQUFDLE9BQU8sRUFBRSxHQUFHLEVBQUUsQ0FBQyxxUEFBMkMsQ0FBQztJQUM1RCxDQUFDLE9BQU8sRUFBRSxHQUFHLEVBQUUsQ0FBQyxxUEFBMkMsQ0FBQztJQUM1RCxDQUFDLE9BQU8sRUFBRSxHQUFHLEVBQUUsQ0FBQyw2T0FBMkMsQ0FBQztJQUM1RCxDQUFDLE9BQU8sRUFBRSxHQUFHLEVBQUUsQ0FBQyxxUEFBMkMsQ0FBQztJQUM1RCxDQUFDLE9BQU8sRUFBRSxHQUFHLEVBQUUsQ0FBQyxxUEFBMkMsQ0FBQztJQUM1RCxDQUFDLE9BQU8sRUFBRSxHQUFHLEVBQUUsQ0FBQyw2T0FBMkMsQ0FBQztJQUM1RCxDQUFDLE9BQU8sRUFBRSxHQUFHLEVBQUUsQ0FBQyxxUEFBMkMsQ0FBQztJQUM1RCxDQUFDLE9BQU8sRUFBRSxHQUFHLEVBQUUsQ0FBQyw2T0FBMkMsQ0FBQztJQUM1RCxDQUFDLE9BQU8sRUFBRSxHQUFHLEVBQUUsQ0FBQyw2T0FBMkMsQ0FBQztJQUM1RCxDQUFDLE9BQU8sRUFBRSxHQUFHLEVBQUUsQ0FBQyxxUEFBMkMsQ0FBQztJQUM1RCxDQUFDLE9BQU8sRUFBRSxHQUFHLEVBQUUsQ0FBQyw2T0FBMkMsQ0FBQztJQUM1RCxDQUFDLE9BQU8sRUFBRSxHQUFHLEVBQUUsQ0FBQyxxUEFBMkMsQ0FBQztJQUM1RCxDQUFDLE9BQU8sRUFBRSxHQUFHLEVBQUUsQ0FBQyxxUEFBMkMsQ0FBQztJQUM1RCxDQUFDLE9BQU8sRUFBRSxHQUFHLEVBQUUsQ0FBQyxxUEFBMkMsQ0FBQztJQUM1RCxDQUFDLE9BQU8sRUFBRSxHQUFHLEVBQUUsQ0FBQyw2T0FBMkMsQ0FBQztJQUM1RCxDQUFDLE9BQU8sRUFBRSxHQUFHLEVBQUUsQ0FBQyxxUEFBMkMsQ0FB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YWNrOi8vZXhiLWNsaWVudC8uL25vZGVfbW9kdWxlcy9AYW1jaGFydHMvYW1jaGFydHM1Ly5pbnRlcm5hbC9jaGFydHMvcGVyY2VudC9QZXJjZW50Q2hhcnQuanMiLCJ3ZWJwYWNrOi8vZXhiLWNsaWVudC8uL25vZGVfbW9kdWxlcy9AYW1jaGFydHMvYW1jaGFydHM1Ly5pbnRlcm5hbC9jaGFydHMvcGVyY2VudC9QZXJjZW50RGVmYXVsdFRoZW1lLmpzIiwid2VicGFjazovL2V4Yi1jbGllbnQvLi9ub2RlX21vZHVsZXMvQGFtY2hhcnRzL2FtY2hhcnRzNS8uaW50ZXJuYWwvY2hhcnRzL3BlcmNlbnQvUGVyY2VudFNlcmllcy5qcyIsIndlYnBhY2s6Ly9leGItY2xpZW50Ly4vbm9kZV9tb2R1bGVzL0BhbWNoYXJ0cy9hbWNoYXJ0czUvLmludGVybmFsL2NoYXJ0cy9waWUvUGllQ2hhcnQuanMiLCJ3ZWJwYWNrOi8vZXhiLWNsaWVudC8uL25vZGVfbW9kdWxlcy9AYW1jaGFydHMvYW1jaGFydHM1Ly5pbnRlcm5hbC9jaGFydHMvcGllL1BpZVNlcmllcy5qcyIsIndlYnBhY2s6Ly9leGItY2xpZW50Ly4vbm9kZV9tb2R1bGVzL0BhbWNoYXJ0cy9hbWNoYXJ0czUvLmludGVybmFsL2NoYXJ0cy94eS9YWUNoYXJ0LmpzIiwid2VicGFjazovL2V4Yi1jbGllbnQvLi9ub2RlX21vZHVsZXMvQGFtY2hhcnRzL2FtY2hhcnRzNS8uaW50ZXJuYWwvY2hhcnRzL3h5L1hZQ2hhcnREZWZhdWx0VGhlbWUuanMiLCJ3ZWJwYWNrOi8vZXhiLWNsaWVudC8uL25vZGVfbW9kdWxlcy9AYW1jaGFydHMvYW1jaGFydHM1Ly5pbnRlcm5hbC9jaGFydHMveHkvWFlDdXJzb3IuanMiLCJ3ZWJwYWNrOi8vZXhiLWNsaWVudC8uL25vZGVfbW9kdWxlcy9AYW1jaGFydHMvYW1jaGFydHM1Ly5pbnRlcm5hbC9jaGFydHMveHkvYXhlcy9BeGlzLmpzIiwid2VicGFjazovL2V4Yi1jbGllbnQvLi9ub2RlX21vZHVsZXMvQGFtY2hhcnRzL2FtY2hhcnRzNS8uaW50ZXJuYWwvY2hhcnRzL3h5L2F4ZXMvQXhpc0xhYmVsLmpzIiwid2VicGFjazovL2V4Yi1jbGllbnQvLi9ub2RlX21vZHVsZXMvQGFtY2hhcnRzL2FtY2hhcnRzNS8uaW50ZXJuYWwvY2hhcnRzL3h5L2F4ZXMvQXhpc1JlbmRlcmVyLmpzIiwid2VicGFjazovL2V4Yi1jbGllbnQvLi9ub2RlX21vZHVsZXMvQGFtY2hhcnRzL2FtY2hhcnRzNS8uaW50ZXJuYWwvY2hhcnRzL3h5L2F4ZXMvQXhpc1JlbmRlcmVyWC5qcyIsIndlYnBhY2s6Ly9leGItY2xpZW50Ly4vbm9kZV9tb2R1bGVzL0BhbWNoYXJ0cy9hbWNoYXJ0czUvLmludGVybmFsL2NoYXJ0cy94eS9heGVzL0F4aXNSZW5kZXJlclkuanMiLCJ3ZWJwYWNrOi8vZXhiLWNsaWVudC8uL25vZGVfbW9kdWxlcy9AYW1jaGFydHMvYW1jaGFydHM1Ly5pbnRlcm5hbC9jaGFydHMveHkvYXhlcy9BeGlzVGljay5qcyIsIndlYnBhY2s6Ly9leGItY2xpZW50Ly4vbm9kZV9tb2R1bGVzL0BhbWNoYXJ0cy9hbWNoYXJ0czUvLmludGVybmFsL2NoYXJ0cy94eS9heGVzL0NhdGVnb3J5QXhpcy5qcyIsIndlYnBhY2s6Ly9leGItY2xpZW50Ly4vbm9kZV9tb2R1bGVzL0BhbWNoYXJ0cy9hbWNoYXJ0czUvLmludGVybmFsL2NoYXJ0cy94eS9heGVzL0dyaWQuanMiLCJ3ZWJwYWNrOi8vZXhiLWNsaWVudC8uL25vZGVfbW9kdWxlcy9AYW1jaGFydHMvYW1jaGFydHM1Ly5pbnRlcm5hbC9jaGFydHMveHkvYXhlcy9WYWx1ZUF4aXMuanMiLCJ3ZWJwYWNrOi8vZXhiLWNsaWVudC8uL25vZGVfbW9kdWxlcy9AYW1jaGFydHMvYW1jaGFydHM1Ly5pbnRlcm5hbC9jaGFydHMveHkvc2VyaWVzL0Jhc2VDb2x1bW5TZXJpZXMuanMiLCJ3ZWJwYWNrOi8vZXhiLWNsaWVudC8uL25vZGVfbW9kdWxlcy9AYW1jaGFydHMvYW1jaGFydHM1Ly5pbnRlcm5hbC9jaGFydHMveHkvc2VyaWVzL0NvbHVtblNlcmllcy5qcyIsIndlYnBhY2s6Ly9leGItY2xpZW50Ly4vbm9kZV9tb2R1bGVzL0BhbWNoYXJ0cy9hbWNoYXJ0czUvLmludGVybmFsL2NoYXJ0cy94eS9zZXJpZXMvTGluZVNlcmllcy5qcyIsIndlYnBhY2s6Ly9leGItY2xpZW50Ly4vbm9kZV9tb2R1bGVzL0BhbWNoYXJ0cy9hbWNoYXJ0czUvLmludGVybmFsL2NoYXJ0cy94eS9zZXJpZXMvWFlTZXJpZXMuanMiLCJ3ZWJwYWNrOi8vZXhiLWNsaWVudC8uL25vZGVfbW9kdWxlcy9AYW1jaGFydHMvYW1jaGFydHM1Ly5pbnRlcm5hbC9jb3JlL1JlZ2lzdHJ5LmpzIiwid2VicGFjazovL2V4Yi1jbGllbnQvLi9ub2RlX21vZHVsZXMvQGFtY2hhcnRzL2FtY2hhcnRzNS8uaW50ZXJuYWwvY29yZS9Sb290LmpzIiwid2VicGFjazovL2V4Yi1jbGllbnQvLi9ub2RlX21vZHVsZXMvQGFtY2hhcnRzL2FtY2hhcnRzNS8uaW50ZXJuYWwvY29yZS9UaGVtZS5qcyIsIndlYnBhY2s6Ly9leGItY2xpZW50Ly4vbm9kZV9tb2R1bGVzL0BhbWNoYXJ0cy9hbWNoYXJ0czUvLmludGVybmFsL2NvcmUvcmVuZGVyL0J1bGxldC5qcyIsIndlYnBhY2s6Ly9leGItY2xpZW50Ly4vbm9kZV9tb2R1bGVzL0BhbWNoYXJ0cy9hbWNoYXJ0czUvLmludGVybmFsL2NvcmUvcmVuZGVyL0J1dHRvbi5qcyIsIndlYnBhY2s6Ly9leGItY2xpZW50Ly4vbm9kZV9tb2R1bGVzL0BhbWNoYXJ0cy9hbWNoYXJ0czUvLmludGVybmFsL2NvcmUvcmVuZGVyL0NoYXJ0LmpzIiwid2VicGFjazovL2V4Yi1jbGllbnQvLi9ub2RlX21vZHVsZXMvQGFtY2hhcnRzL2FtY2hhcnRzNS8uaW50ZXJuYWwvY29yZS9yZW5kZXIvQ2lyY2xlLmpzIiwid2VicGFjazovL2V4Yi1jbGllbnQvLi9ub2RlX21vZHVsZXMvQGFtY2hhcnRzL2FtY2hhcnRzNS8uaW50ZXJuYWwvY29yZS9yZW5kZXIvQ29tcG9uZW50LmpzIiwid2VicGFjazovL2V4Yi1jbGllbnQvLi9ub2RlX21vZHVsZXMvQGFtY2hhcnRzL2FtY2hhcnRzNS8uaW50ZXJuYWwvY29yZS9yZW5kZXIvQ29udGFpbmVyLmpzIiwid2VicGFjazovL2V4Yi1jbGllbnQvLi9ub2RlX21vZHVsZXMvQGFtY2hhcnRzL2FtY2hhcnRzNS8uaW50ZXJuYWwvY29yZS9yZW5kZXIvR3JhcGhpY3MuanMiLCJ3ZWJwYWNrOi8vZXhiLWNsaWVudC8uL25vZGVfbW9kdWxlcy9AYW1jaGFydHMvYW1jaGFydHM1Ly5pbnRlcm5hbC9jb3JlL3JlbmRlci9HcmlkTGF5b3V0LmpzIiwid2VicGFjazovL2V4Yi1jbGllbnQvLi9ub2RlX21vZHVsZXMvQGFtY2hhcnRzL2FtY2hhcnRzNS8uaW50ZXJuYWwvY29yZS9yZW5kZXIvSG9yaXpvbnRhbExheW91dC5qcyIsIndlYnBhY2s6Ly9leGItY2xpZW50Ly4vbm9kZV9tb2R1bGVzL0BhbWNoYXJ0cy9hbWNoYXJ0czUvLmludGVybmFsL2NvcmUvcmVuZGVyL0xhYmVsLmpzIiwid2VicGFjazovL2V4Yi1jbGllbnQvLi9ub2RlX21vZHVsZXMvQGFtY2hhcnRzL2FtY2hhcnRzNS8uaW50ZXJuYWwvY29yZS9yZW5kZXIvTGF5b3V0LmpzIiwid2VicGFjazovL2V4Yi1jbGllbnQvLi9ub2RlX21vZHVsZXMvQGFtY2hhcnRzL2FtY2hhcnRzNS8uaW50ZXJuYWwvY29yZS9yZW5kZXIvTGVnZW5kLmpzIiwid2VicGFjazovL2V4Yi1jbGllbnQvLi9ub2RlX21vZHVsZXMvQGFtY2hhcnRzL2FtY2hhcnRzNS8uaW50ZXJuYWwvY29yZS9yZW5kZXIvTGluZS5qcyIsIndlYnBhY2s6Ly9leGItY2xpZW50Ly4vbm9kZV9tb2R1bGVzL0BhbWNoYXJ0cy9hbWNoYXJ0czUvLmludGVybmFsL2NvcmUvcmVuZGVyL1BvaW50ZWRSZWN0YW5nbGUuanMiLCJ3ZWJwYWNrOi8vZXhiLWNsaWVudC8uL25vZGVfbW9kdWxlcy9AYW1jaGFydHMvYW1jaGFydHM1Ly5pbnRlcm5hbC9jb3JlL3JlbmRlci9SYWRpYWxMYWJlbC5qcyIsIndlYnBhY2s6Ly9leGItY2xpZW50Ly4vbm9kZV9tb2R1bGVzL0BhbWNoYXJ0cy9hbWNoYXJ0czUvLmludGVybmFsL2NvcmUvcmVuZGVyL1JhZGlhbFRleHQuanMiLCJ3ZWJwYWNrOi8vZXhiLWNsaWVudC8uL25vZGVfbW9kdWxlcy9AYW1jaGFydHMvYW1jaGFydHM1Ly5pbnRlcm5hbC9jb3JlL3JlbmRlci9SZWN0YW5nbGUuanMiLCJ3ZWJwYWNrOi8vZXhiLWNsaWVudC8uL25vZGVfbW9kdWxlcy9AYW1jaGFydHMvYW1jaGFydHM1Ly5pbnRlcm5hbC9jb3JlL3JlbmRlci9Sb3VuZGVkUmVjdGFuZ2xlLmpzIiwid2VicGFjazovL2V4Yi1jbGllbnQvLi9ub2RlX21vZHVsZXMvQGFtY2hhcnRzL2FtY2hhcnRzNS8uaW50ZXJuYWwvY29yZS9yZW5kZXIvU2Nyb2xsYmFyLmpzIiwid2VicGFjazovL2V4Yi1jbGllbnQvLi9ub2RlX21vZHVsZXMvQGFtY2hhcnRzL2FtY2hhcnRzNS8uaW50ZXJuYWwvY29yZS9yZW5kZXIvU2VyaWFsQ2hhcnQuanMiLCJ3ZWJwYWNrOi8vZXhiLWNsaWVudC8uL25vZGVfbW9kdWxlcy9AYW1jaGFydHMvYW1jaGFydHM1Ly5pbnRlcm5hbC9jb3JlL3JlbmRlci9TZXJpZXMuanMiLCJ3ZWJwYWNrOi8vZXhiLWNsaWVudC8uL25vZGVfbW9kdWxlcy9AYW1jaGFydHMvYW1jaGFydHM1Ly5pbnRlcm5hbC9jb3JlL3JlbmRlci9TbGljZS5qcyIsIndlYnBhY2s6Ly9leGItY2xpZW50Ly4vbm9kZV9tb2R1bGVzL0BhbWNoYXJ0cy9hbWNoYXJ0czUvLmludGVybmFsL2NvcmUvcmVuZGVyL1Nwcml0ZS5qcyIsIndlYnBhY2s6Ly9leGItY2xpZW50Ly4vbm9kZV9tb2R1bGVzL0BhbWNoYXJ0cy9hbWNoYXJ0czUvLmludGVybmFsL2NvcmUvcmVuZGVyL1RleHQuanMiLCJ3ZWJwYWNrOi8vZXhiLWNsaWVudC8uL25vZGVfbW9kdWxlcy9AYW1jaGFydHMvYW1jaGFydHM1Ly5pbnRlcm5hbC9jb3JlL3JlbmRlci9UaWNrLmpzIiwid2VicGFjazovL2V4Yi1jbGllbnQvLi9ub2RlX21vZHVsZXMvQGFtY2hhcnRzL2FtY2hhcnRzNS8uaW50ZXJuYWwvY29yZS9yZW5kZXIvVG9vbHRpcC5qcyIsIndlYnBhY2s6Ly9leGItY2xpZW50Ly4vbm9kZV9tb2R1bGVzL0BhbWNoYXJ0cy9hbWNoYXJ0czUvLmludGVybmFsL2NvcmUvcmVuZGVyL1RyaWFuZ2xlLmpzIiwid2VicGFjazovL2V4Yi1jbGllbnQvLi9ub2RlX21vZHVsZXMvQGFtY2hhcnRzL2FtY2hhcnRzNS8uaW50ZXJuYWwvY29yZS9yZW5kZXIvVmVydGljYWxMYXlvdXQuanMiLCJ3ZWJwYWNrOi8vZXhiLWNsaWVudC8uL25vZGVfbW9kdWxlcy9AYW1jaGFydHMvYW1jaGFydHM1Ly5pbnRlcm5hbC9jb3JlL3JlbmRlci9iYWNrZW5kL0NhbnZhc1JlbmRlcmVyLmpzIiwid2VicGFjazovL2V4Yi1jbGllbnQvLi9ub2RlX21vZHVsZXMvQGFtY2hhcnRzL2FtY2hhcnRzNS8uaW50ZXJuYWwvY29yZS9yZW5kZXIvYmFja2VuZC9SZW5kZXJlci5qcyIsIndlYnBhY2s6Ly9leGItY2xpZW50Ly4vbm9kZV9tb2R1bGVzL0BhbWNoYXJ0cy9hbWNoYXJ0czUvLmludGVybmFsL2NvcmUvcmVuZGVyL3BhdHRlcm5zL1BhdHRlcm4uanMiLCJ3ZWJwYWNrOi8vZXhiLWNsaWVudC8uL25vZGVfbW9kdWxlcy9AYW1jaGFydHMvYW1jaGFydHM1Ly5pbnRlcm5hbC9jb3JlL3JlbmRlci9wYXR0ZXJucy9QaWN0dXJlUGF0dGVybi5qcyIsIndlYnBhY2s6Ly9leGItY2xpZW50Ly4vbm9kZV9tb2R1bGVzL0BhbWNoYXJ0cy9hbWNoYXJ0czUvLmludGVybmFsL2NvcmUvdXRpbC9BbmltYXRpb24uanMiLCJ3ZWJwYWNrOi8vZXhiLWNsaWVudC8uL25vZGVfbW9kdWxlcy9AYW1jaGFydHMvYW1jaGFydHM1Ly5pbnRlcm5hbC9jb3JlL3V0aWwvQXJyYXkuanMiLCJ3ZWJwYWNrOi8vZXhiLWNsaWVudC8uL25vZGVfbW9kdWxlcy9AYW1jaGFydHMvYW1jaGFydHM1Ly5pbnRlcm5hbC9jb3JlL3V0aWwvQ2hpbGRyZW4uanMiLCJ3ZWJwYWNrOi8vZXhiLWNsaWVudC8uL25vZGVfbW9kdWxlcy9AYW1jaGFydHMvYW1jaGFydHM1Ly5pbnRlcm5hbC9jb3JlL3V0aWwvQ29sb3IuanMiLCJ3ZWJwYWNrOi8vZXhiLWNsaWVudC8uL25vZGVfbW9kdWxlcy9AYW1jaGFydHMvYW1jaGFydHM1Ly5pbnRlcm5hbC9jb3JlL3V0aWwvQ29sb3JTZXQuanMiLCJ3ZWJwYWNrOi8vZXhiLWNsaWVudC8uL25vZGVfbW9kdWxlcy9AYW1jaGFydHMvYW1jaGFydHM1Ly5pbnRlcm5hbC9jb3JlL3V0aWwvRGF0YS5qcyIsIndlYnBhY2s6Ly9leGItY2xpZW50Ly4vbm9kZV9tb2R1bGVzL0BhbWNoYXJ0cy9hbWNoYXJ0czUvLmludGVybmFsL2NvcmUvdXRpbC9EYXRlRm9ybWF0dGVyLmpzIiwid2VicGFjazovL2V4Yi1jbGllbnQvLi9ub2RlX21vZHVsZXMvQGFtY2hhcnRzL2FtY2hhcnRzNS8uaW50ZXJuYWwvY29yZS91dGlsL0Rpc3Bvc2VyLmpzIiwid2VicGFjazovL2V4Yi1jbGllbnQvLi9ub2RlX21vZHVsZXMvQGFtY2hhcnRzL2FtY2hhcnRzNS8uaW50ZXJuYWwvY29yZS91dGlsL0RyYXcuanMiLCJ3ZWJwYWNrOi8vZXhiLWNsaWVudC8uL25vZGVfbW9kdWxlcy9AYW1jaGFydHMvYW1jaGFydHM1Ly5pbnRlcm5hbC9jb3JlL3V0aWwvRHVyYXRpb25Gb3JtYXR0ZXIuanMiLCJ3ZWJwYWNrOi8vZXhiLWNsaWVudC8uL25vZGVfbW9kdWxlcy9AYW1jaGFydHMvYW1jaGFydHM1Ly5pbnRlcm5hbC9jb3JlL3V0aWwvRWFzZS5qcyIsIndlYnBhY2s6Ly9leGItY2xpZW50Ly4vbm9kZV9tb2R1bGVzL0BhbWNoYXJ0cy9hbWNoYXJ0czUvLmludGVybmFsL2NvcmUvdXRpbC9FbnRpdHkuanMiLCJ3ZWJwYWNrOi8vZXhiLWNsaWVudC8uL25vZGVfbW9kdWxlcy9AYW1jaGFydHMvYW1jaGFydHM1Ly5pbnRlcm5hbC9jb3JlL3V0aWwvRXZlbnREaXNwYXRjaGVyLmpzIiwid2VicGFjazovL2V4Yi1jbGllbnQvLi9ub2RlX21vZHVsZXMvQGFtY2hhcnRzL2FtY2hhcnRzNS8uaW50ZXJuYWwvY29yZS91dGlsL0ludGVyZmFjZUNvbG9ycy5qcyIsIndlYnBhY2s6Ly9leGItY2xpZW50Ly4vbm9kZV9tb2R1bGVzL0BhbWNoYXJ0cy9hbWNoYXJ0czUvLmludGVybmFsL2NvcmUvdXRpbC9MYW5ndWFnZS5qcyIsIndlYnBhY2s6Ly9leGItY2xpZW50Ly4vbm9kZV9tb2R1bGVzL0BhbWNoYXJ0cy9hbWNoYXJ0czUvLmludGVybmFsL2NvcmUvdXRpbC9MaXN0LmpzIiwid2VicGFjazovL2V4Yi1jbGllbnQvLi9ub2RlX21vZHVsZXMvQGFtY2hhcnRzL2FtY2hhcnRzNS8uaW50ZXJuYWwvY29yZS91dGlsL01hdGguanMiLCJ3ZWJwYWNrOi8vZXhiLWNsaWVudC8uL25vZGVfbW9kdWxlcy9AYW1jaGFydHMvYW1jaGFydHM1Ly5pbnRlcm5hbC9jb3JlL3V0aWwvTWF0cml4LmpzIiwid2VicGFjazovL2V4Yi1jbGllbnQvLi9ub2RlX21vZHVsZXMvQGFtY2hhcnRzL2FtY2hhcnRzNS8uaW50ZXJuYWwvY29yZS91dGlsL051bWJlckZvcm1hdHRlci5qcyIsIndlYnBhY2s6Ly9leGItY2xpZW50Ly4vbm9kZV9tb2R1bGVzL0BhbWNoYXJ0cy9hbWNoYXJ0czUvLmludGVybmFsL2NvcmUvdXRpbC9PYmplY3QuanMiLCJ3ZWJwYWNrOi8vZXhiLWNsaWVudC8uL25vZGVfbW9kdWxlcy9AYW1jaGFydHMvYW1jaGFydHM1Ly5pbnRlcm5hbC9jb3JlL3V0aWwvT3JkZXIuanMiLCJ3ZWJwYWNrOi8vZXhiLWNsaWVudC8uL25vZGVfbW9kdWxlcy9AYW1jaGFydHMvYW1jaGFydHM1Ly5pbnRlcm5hbC9jb3JlL3V0aWwvUGVyY2VudC5qcyIsIndlYnBhY2s6Ly9leGItY2xpZW50Ly4vbm9kZV9tb2R1bGVzL0BhbWNoYXJ0cy9hbWNoYXJ0czUvLmludGVybmFsL2NvcmUvdXRpbC9Qb3B1bGF0ZVN0cmluZy5qcyIsIndlYnBhY2s6Ly9leGItY2xpZW50Ly4vbm9kZV9tb2R1bGVzL0BhbWNoYXJ0cy9hbWNoYXJ0czUvLmludGVybmFsL2NvcmUvdXRpbC9SZXNpemVTZW5zb3IuanMiLCJ3ZWJwYWNrOi8vZXhiLWNsaWVudC8uL25vZGVfbW9kdWxlcy9AYW1jaGFydHMvYW1jaGFydHM1Ly5pbnRlcm5hbC9jb3JlL3V0aWwvU3RhdGVzLmpzIiwid2VicGFjazovL2V4Yi1jbGllbnQvLi9ub2RlX21vZHVsZXMvQGFtY2hhcnRzL2FtY2hhcnRzNS8uaW50ZXJuYWwvY29yZS91dGlsL1RlbXBsYXRlLmpzIiwid2VicGFjazovL2V4Yi1jbGllbnQvLi9ub2RlX21vZHVsZXMvQGFtY2hhcnRzL2FtY2hhcnRzNS8uaW50ZXJuYWwvY29yZS91dGlsL1RleHRGb3JtYXR0ZXIuanMiLCJ3ZWJwYWNrOi8vZXhiLWNsaWVudC8uL25vZGVfbW9kdWxlcy9AYW1jaGFydHMvYW1jaGFydHM1Ly5pbnRlcm5hbC9jb3JlL3V0aWwvVGltZS5qcyIsIndlYnBhY2s6Ly9leGItY2xpZW50Ly4vbm9kZV9tb2R1bGVzL0BhbWNoYXJ0cy9hbWNoYXJ0czUvLmludGVybmFsL2NvcmUvdXRpbC9UaW1lem9uZS5qcyIsIndlYnBhY2s6Ly9leGItY2xpZW50Ly4vbm9kZV9tb2R1bGVzL0BhbWNoYXJ0cy9hbWNoYXJ0czUvLmludGVybmFsL2NvcmUvdXRpbC9UeXBlLmpzIiwid2VicGFjazovL2V4Yi1jbGllbnQvLi9ub2RlX21vZHVsZXMvQGFtY2hhcnRzL2FtY2hhcnRzNS8uaW50ZXJuYWwvY29yZS91dGlsL1V0aWxzLmpzIiwid2VicGFjazovL2V4Yi1jbGllbnQvLi9ub2RlX21vZHVsZXMvQGFtY2hhcnRzL2FtY2hhcnRzNS8uaW50ZXJuYWwvcGx1Z2lucy9leHBvcnRpbmcvRXhwb3J0aW5nLmpzIiwid2VicGFjazovL2V4Yi1jbGllbnQvLi9ub2RlX21vZHVsZXMvQGFtY2hhcnRzL2FtY2hhcnRzNS8uaW50ZXJuYWwvdGhlbWVzL0FuaW1hdGVkVGhlbWUuanMiLCJ3ZWJwYWNrOi8vZXhiLWNsaWVudC8uL25vZGVfbW9kdWxlcy9AYW1jaGFydHMvYW1jaGFydHM1Ly5pbnRlcm5hbC90aGVtZXMvRGFya1RoZW1lLmpzIiwid2VicGFjazovL2V4Yi1jbGllbnQvLi9ub2RlX21vZHVsZXMvQGFtY2hhcnRzL2FtY2hhcnRzNS8uaW50ZXJuYWwvdGhlbWVzL0RlZmF1bHRUaGVtZS5qcyIsIndlYnBhY2s6Ly9leGItY2xpZW50Ly4vbm9kZV9tb2R1bGVzL0BhbWNoYXJ0cy9hbWNoYXJ0czUvLmludGVybmFsL3RoZW1lcy9SZXNwb25zaXZlVGhlbWUuanMiLCJ3ZWJwYWNrOi8vZXhiLWNsaWVudC8uL25vZGVfbW9kdWxlcy9AYW1jaGFydHMvYW1jaGFydHM1L2xvY2FsZXMvZW4uanMiLCJ3ZWJwYWNrOi8vZXhiLWNsaWVudC8uL25vZGVfbW9kdWxlcy9AYW1jaGFydHMvYW1jaGFydHM1L3RoZW1lcy9BbmltYXRlZC5qcyIsIndlYnBhY2s6Ly9leGItY2xpZW50Ly4vbm9kZV9tb2R1bGVzL0BhbWNoYXJ0cy9hbWNoYXJ0czUvdGhlbWVzL0RhcmsuanMiLCJ3ZWJwYWNrOi8vZXhiLWNsaWVudC8uL25vZGVfbW9kdWxlcy9AYW1jaGFydHMvYW1jaGFydHM1L3RoZW1lcy9SZXNwb25zaXZlLmpzIiwid2VicGFjazovL2V4Yi1jbGllbnQvLi9ub2RlX21vZHVsZXMvc3ZnLWFyYy10by1jdWJpYy1iZXppZXIvbW9kdWxlcy9pbmRleC5qcyIsIndlYnBhY2s6Ly9leGItY2xpZW50Ly4vamltdS11aS9hZHZhbmNlZC9saWIvY2hhcnQtZW5naW5lL2luZGV4LnRzIiwid2VicGFjazovL2V4Yi1jbGllbnQvZXh0ZXJuYWwgc3lzdGVtIFwiZXNyaS9pbnRsXCIiLCJ3ZWJwYWNrOi8vZXhiLWNsaWVudC8uL25vZGVfbW9kdWxlcy9kMy1wYXRoL3NyYy9wYXRoLmpzIiwid2VicGFjazovL2V4Yi1jbGllbnQvLi9ub2RlX21vZHVsZXMvZDMtc2hhcGUvc3JjL2FyYy5qcyIsIndlYnBhY2s6Ly9leGItY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9hcmVhLmpzIiwid2VicGFjazovL2V4Yi1jbGllbnQvLi9ub2RlX21vZHVsZXMvZDMtc2hhcGUvc3JjL2FycmF5LmpzIiwid2VicGFjazovL2V4Yi1jbGllbnQvLi9ub2RlX21vZHVsZXMvZDMtc2hhcGUvc3JjL2NvbnN0YW50LmpzIiwid2VicGFjazovL2V4Yi1jbGllbnQvLi9ub2RlX21vZHVsZXMvZDMtc2hhcGUvc3JjL2N1cnZlL2xpbmVhci5qcyIsIndlYnBhY2s6Ly9leGItY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9saW5lLmpzIiwid2VicGFjazovL2V4Yi1jbGllbnQvLi9ub2RlX21vZHVsZXMvZDMtc2hhcGUvc3JjL21hdGguanMiLCJ3ZWJwYWNrOi8vZXhiLWNsaWVudC8uL25vZGVfbW9kdWxlcy9kMy1zaGFwZS9zcmMvcGF0aC5qcyIsIndlYnBhY2s6Ly9leGItY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9wb2ludC5qcyIsIndlYnBhY2s6Ly9leGItY2xpZW50Ly4vbm9kZV9tb2R1bGVzL3RzbGliL3RzbGliLmVzNi5tanMiLCJ3ZWJwYWNrOi8vZXhiLWNsaWVudC93ZWJwYWNrL2Jvb3RzdHJhcCIsIndlYnBhY2s6Ly9leGItY2xpZW50L3dlYnBhY2svcnVudGltZS9jcmVhdGUgZmFrZSBuYW1lc3BhY2Ugb2JqZWN0Iiwid2VicGFjazovL2V4Yi1jbGllbnQvd2VicGFjay9ydW50aW1lL2RlZmluZSBwcm9wZXJ0eSBnZXR0ZXJzIiwid2VicGFjazovL2V4Yi1jbGllbnQvd2VicGFjay9ydW50aW1lL2Vuc3VyZSBjaHVuayIsIndlYnBhY2s6Ly9leGItY2xpZW50L3dlYnBhY2svcnVudGltZS9nZXQgamF2YXNjcmlwdCBjaHVuayBmaWxlbmFtZSIsIndlYnBhY2s6Ly9leGItY2xpZW50L3dlYnBhY2svcnVudGltZS9nZXQgbWluaS1jc3MgY2h1bmsgZmlsZW5hbWUiLCJ3ZWJwYWNrOi8vZXhiLWNsaWVudC93ZWJwYWNrL3J1bnRpbWUvaGFzT3duUHJvcGVydHkgc2hvcnRoYW5kIiwid2VicGFjazovL2V4Yi1jbGllbnQvd2VicGFjay9ydW50aW1lL2xvYWQgc2NyaXB0Iiwid2VicGFjazovL2V4Yi1jbGllbnQvd2VicGFjay9ydW50aW1lL21ha2UgbmFtZXNwYWNlIG9iamVjdCIsIndlYnBhY2s6Ly9leGItY2xpZW50L3dlYnBhY2svcnVudGltZS9wdWJsaWNQYXRoIiwid2VicGFjazovL2V4Yi1jbGllbnQvd2VicGFjay9ydW50aW1lL2pzb25wIGNodW5rIGxvYWRpbmciLCJ3ZWJwYWNrOi8vZXhiLWNsaWVudC8uL2ppbXUtY29yZS9saWIvc2V0LXB1YmxpYy1wYXRoLnRzIiwid2VicGFjazovL2V4Yi1jbGllbnQvLi9qaW11LXVpL2FkdmFuY2VkL2NoYXJ0LWVuZ2luZS50c3giXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgU2VyaWFsQ2hhcnQgfSBmcm9tIFwiLi4vLi4vY29yZS9yZW5kZXIvU2VyaWFsQ2hhcnRcIjtcclxuaW1wb3J0IHsgUGVyY2VudERlZmF1bHRUaGVtZSB9IGZyb20gXCIuL1BlcmNlbnREZWZhdWx0VGhlbWVcIjtcclxuLyoqXHJcbiAqIEJhc2UgY2xhc3MgZm9yIFtbUGllQ2hhcnRdXS5cclxuICpcclxuICogQWxzbyB1c2VkIGZvciBwZXJjZW50LWJhc2VkIHNlcmllcywgbGlrZSBbW0Z1bm5lbFNlcmllc11dLCBbW1B5cmFtaWRTZXJpZXNdXSwgZXRjLlxyXG4gKlxyXG4gKiBAaW1wb3J0YW50XHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgUGVyY2VudENoYXJ0IGV4dGVuZHMgU2VyaWFsQ2hhcnQge1xyXG4gICAgX2FmdGVyTmV3KCkge1xyXG4gICAgICAgIHRoaXMuX2RlZmF1bHRUaGVtZXMucHVzaChQZXJjZW50RGVmYXVsdFRoZW1lLm5ldyh0aGlzLl9yb290KSk7XHJcbiAgICAgICAgc3VwZXIuX2FmdGVyTmV3KCk7XHJcbiAgICAgICAgdGhpcy5jaGFydENvbnRhaW5lci5jaGlsZHJlbi5wdXNoKHRoaXMuc2VyaWVzQ29udGFpbmVyKTtcclxuICAgICAgICB0aGlzLnNlcmllc0NvbnRhaW5lci5jaGlsZHJlbi5wdXNoKHRoaXMuYnVsbGV0c0NvbnRhaW5lcik7XHJcbiAgICB9XHJcbiAgICBfcHJvY2Vzc1NlcmllcyhzZXJpZXMpIHtcclxuICAgICAgICBzdXBlci5fcHJvY2Vzc1NlcmllcyhzZXJpZXMpO1xyXG4gICAgICAgIHRoaXMuc2VyaWVzQ29udGFpbmVyLmNoaWxkcmVuLm1vdmVWYWx1ZSh0aGlzLmJ1bGxldHNDb250YWluZXIsIHRoaXMuc2VyaWVzQ29udGFpbmVyLmNoaWxkcmVuLmxlbmd0aCAtIDEpO1xyXG4gICAgfVxyXG59XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShQZXJjZW50Q2hhcnQsIFwiY2xhc3NOYW1lXCIsIHtcclxuICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgIHZhbHVlOiBcIlBlcmNlbnRDaGFydFwiXHJcbn0pO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUGVyY2VudENoYXJ0LCBcImNsYXNzTmFtZXNcIiwge1xyXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgdmFsdWU6IFNlcmlhbENoYXJ0LmNsYXNzTmFtZXMuY29uY2F0KFtQZXJjZW50Q2hhcnQuY2xhc3NOYW1lXSlcclxufSk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVBlcmNlbnRDaGFydC5qcy5tYXAiLCJpbXBvcnQgeyBUaGVtZSB9IGZyb20gXCIuLi8uLi9jb3JlL1RoZW1lXCI7XHJcbmltcG9ydCB7IHBlcmNlbnQsIHA1MCwgcDEwMCB9IGZyb20gXCIuLi8uLi9jb3JlL3V0aWwvUGVyY2VudFwiO1xyXG5pbXBvcnQgeyBDb2xvclNldCB9IGZyb20gXCIuLi8uLi9jb3JlL3V0aWwvQ29sb3JTZXRcIjtcclxuaW1wb3J0IHsgc2V0Q29sb3IgfSBmcm9tIFwiLi4vLi4vdGhlbWVzL0RlZmF1bHRUaGVtZVwiO1xyXG4vKipcclxuICogQGlnbm9yZVxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIFBlcmNlbnREZWZhdWx0VGhlbWUgZXh0ZW5kcyBUaGVtZSB7XHJcbiAgICBzZXR1cERlZmF1bHRSdWxlcygpIHtcclxuICAgICAgICBzdXBlci5zZXR1cERlZmF1bHRSdWxlcygpO1xyXG4gICAgICAgIGNvbnN0IGljID0gdGhpcy5fcm9vdC5pbnRlcmZhY2VDb2xvcnM7XHJcbiAgICAgICAgY29uc3QgciA9IHRoaXMucnVsZS5iaW5kKHRoaXMpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4gICAgICAgICAqIGNoYXJ0cy9wZXJjZW50XHJcbiAgICAgICAgICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgcihcIlBlcmNlbnRTZXJpZXNcIikuc2V0QWxsKHtcclxuICAgICAgICAgICAgbGVnZW5kTGFiZWxUZXh0OiBcIntjYXRlZ29yeX1cIixcclxuICAgICAgICAgICAgbGVnZW5kVmFsdWVUZXh0OiBcInt2YWx1ZVBlcmNlbnRUb3RhbC5mb3JtYXROdW1iZXIoJzAuMDBwJyl9XCIsXHJcbiAgICAgICAgICAgIGNvbG9yczogQ29sb3JTZXQubmV3KHRoaXMuX3Jvb3QsIHt9KSxcclxuICAgICAgICAgICAgd2lkdGg6IHAxMDAsXHJcbiAgICAgICAgICAgIGhlaWdodDogcDEwMFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4gICAgICAgICAqIGNoYXJ0cy9waWVcclxuICAgICAgICAgKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICAgICAgICAgKi9cclxuICAgICAgICByKFwiUGllQ2hhcnRcIikuc2V0QWxsKHtcclxuICAgICAgICAgICAgcmFkaXVzOiBwZXJjZW50KDgwKSxcclxuICAgICAgICAgICAgc3RhcnRBbmdsZTogLTkwLFxyXG4gICAgICAgICAgICBlbmRBbmdsZTogMjcwXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcihcIlBpZVNlcmllc1wiKS5zZXRBbGwoe1xyXG4gICAgICAgICAgICBhbGlnbkxhYmVsczogdHJ1ZSxcclxuICAgICAgICAgICAgc3RhcnRBbmdsZTogLTkwLFxyXG4gICAgICAgICAgICBlbmRBbmdsZTogMjcwXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcihcIlBpZVNlcmllc1wiKS5zdGF0ZXMuY3JlYXRlKFwiaGlkZGVuXCIsIHsgZW5kQW5nbGU6IC05MCwgb3BhY2l0eTogMCB9KTtcclxuICAgICAgICByKFwiU2xpY2VcIiwgW1wicGllXCJdKS5zZXRBbGwoe1xyXG4gICAgICAgICAgICBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLFxyXG4gICAgICAgICAgICBpc01lYXN1cmVkOiBmYWxzZSxcclxuICAgICAgICAgICAgeDogMCxcclxuICAgICAgICAgICAgeTogMCxcclxuICAgICAgICAgICAgdG9nZ2xlS2V5OiBcImFjdGl2ZVwiLFxyXG4gICAgICAgICAgICB0b29sdGlwVGV4dDogXCJ7Y2F0ZWdvcnl9OiB7dmFsdWVQZXJjZW50VG90YWwuZm9ybWF0TnVtYmVyKCcwLjAwcCcpfVwiLFxyXG4gICAgICAgICAgICBzdHJva2VXaWR0aDogMSxcclxuICAgICAgICAgICAgc3Ryb2tlT3BhY2l0eTogMSxcclxuICAgICAgICAgICAgcm9sZTogXCJmaWd1cmVcIixcclxuICAgICAgICAgICAgbGluZUpvaW46IFwicm91bmRcIlxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHIoXCJTbGljZVwiLCBbXCJwaWVcIl0pLnN0YXRlcy5jcmVhdGUoXCJhY3RpdmVcIiwgeyBzaGlmdFJhZGl1czogMjAsIHNjYWxlOiAxIH0pO1xyXG4gICAgICAgIHIoXCJTbGljZVwiLCBbXCJwaWVcIl0pLnN0YXRlcy5jcmVhdGUoXCJob3ZlckFjdGl2ZVwiLCB7IHNjYWxlOiAxLjA0IH0pO1xyXG4gICAgICAgIHIoXCJTbGljZVwiLCBbXCJwaWVcIl0pLnN0YXRlcy5jcmVhdGUoXCJob3ZlclwiLCB7IHNjYWxlOiAxLjA0IH0pO1xyXG4gICAgICAgIHIoXCJSYWRpYWxMYWJlbFwiLCBbXCJwaWVcIl0pLnNldEFsbCh7XHJcbiAgICAgICAgICAgIHRleHRUeXBlOiBcImFsaWduZWRcIixcclxuICAgICAgICAgICAgcmFkaXVzOiAxMCxcclxuICAgICAgICAgICAgdGV4dDogXCJ7Y2F0ZWdvcnl9OiB7dmFsdWVQZXJjZW50VG90YWwuZm9ybWF0TnVtYmVyKCcwLjAwcCcpfVwiLFxyXG4gICAgICAgICAgICBwYWRkaW5nVG9wOiA1LFxyXG4gICAgICAgICAgICBwYWRkaW5nQm90dG9tOiA1LFxyXG4gICAgICAgICAgICBwb3B1bGF0ZVRleHQ6IHRydWVcclxuICAgICAgICB9KTtcclxuICAgICAgICByKFwiVGlja1wiLCBbXCJwaWVcIl0pLnNldEFsbCh7XHJcbiAgICAgICAgICAgIGxvY2F0aW9uOiAxXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAgICAgICAgICogY2hhcnRzL2Z1bm5lbFxyXG4gICAgICAgICAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHIoXCJTbGljZWRDaGFydFwiKS5zZXRBbGwoe1xyXG4gICAgICAgICAgICBwYWRkaW5nTGVmdDogMTAsXHJcbiAgICAgICAgICAgIHBhZGRpbmdSaWdodDogMTAsXHJcbiAgICAgICAgICAgIHBhZGRpbmdUb3A6IDEwLFxyXG4gICAgICAgICAgICBwYWRkaW5nQm90dG9tOiAxMFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgICAgICAqIGNoYXJ0cy9mdW5uZWw6IEZ1bm5lbFxyXG4gICAgICAgICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHIoXCJGdW5uZWxTZXJpZXNcIikuc2V0QWxsKHtcclxuICAgICAgICAgICAgc3RhcnRMb2NhdGlvbjogMCxcclxuICAgICAgICAgICAgZW5kTG9jYXRpb246IDEsXHJcbiAgICAgICAgICAgIG9yaWVudGF0aW9uOiBcInZlcnRpY2FsXCIsXHJcbiAgICAgICAgICAgIGFsaWduTGFiZWxzOiB0cnVlLFxyXG4gICAgICAgICAgICBzZXF1ZW5jZWRJbnRlcnBvbGF0aW9uOiB0cnVlXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcihcIkZ1bm5lbFNsaWNlXCIpLnNldEFsbCh7XHJcbiAgICAgICAgICAgIGludGVyYWN0aXZlOiB0cnVlLFxyXG4gICAgICAgICAgICBleHBhbmREaXN0YW5jZTogMCxcclxuICAgICAgICAgICAgLy90b29sdGlwVGV4dDogXCJ7Y2F0ZWdvcnl9OiB7dmFsdWVQZXJjZW50VG90YWwuZm9ybWF0TnVtYmVyKCcwLjAwcCcpfVwiXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcihcIkZ1bm5lbFNsaWNlXCIpLnN0YXRlcy5jcmVhdGUoXCJob3ZlclwiLCB7IGV4cGFuZERpc3RhbmNlOiAwLjE1IH0pO1xyXG4gICAgICAgIHIoXCJMYWJlbFwiLCBbXCJmdW5uZWxcIl0pLnNldEFsbCh7XHJcbiAgICAgICAgICAgIHBvcHVsYXRlVGV4dDogdHJ1ZSxcclxuICAgICAgICAgICAgdGV4dDogXCJ7Y2F0ZWdvcnl9OiB7dmFsdWVQZXJjZW50VG90YWwuZm9ybWF0TnVtYmVyKCcwLjAwcCcpfVwiLFxyXG4gICAgICAgICAgICBjZW50ZXJZOiBwNTBcclxuICAgICAgICB9KTtcclxuICAgICAgICByKFwiTGFiZWxcIiwgW1wiZnVubmVsXCIsIFwiaG9yaXpvbnRhbFwiXSkuc2V0QWxsKHtcclxuICAgICAgICAgICAgY2VudGVyWDogMCxcclxuICAgICAgICAgICAgY2VudGVyWTogcDUwLFxyXG4gICAgICAgICAgICByb3RhdGlvbjogLTkwXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLy8gQ2xhc3M6IExhYmVsXHJcbiAgICAgICAgcihcIkxhYmVsXCIsIFtcImZ1bm5lbFwiLCBcInZlcnRpY2FsXCJdKS5zZXRBbGwoe1xyXG4gICAgICAgICAgICBjZW50ZXJZOiBwNTAsXHJcbiAgICAgICAgICAgIGNlbnRlclg6IDBcclxuICAgICAgICB9KTtcclxuICAgICAgICByKFwiVGlja1wiLCBbXCJmdW5uZWxcIl0pLnNldEFsbCh7XHJcbiAgICAgICAgICAgIGxvY2F0aW9uOiAxXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcihcIkZ1bm5lbFNsaWNlXCIsIFtcImZ1bm5lbFwiLCBcImxpbmtcIl0pLnNldEFsbCh7XHJcbiAgICAgICAgICAgIGZpbGxPcGFjaXR5OiAwLjUsXHJcbiAgICAgICAgICAgIHN0cm9rZU9wYWNpdHk6IDAsXHJcbiAgICAgICAgICAgIGV4cGFuZERpc3RhbmNlOiAtMC4xXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcihcIkZ1bm5lbFNsaWNlXCIsIFtcImZ1bm5lbFwiLCBcImxpbmtcIiwgXCJ2ZXJ0aWNhbFwiXSkuc2V0QWxsKHtcclxuICAgICAgICAgICAgaGVpZ2h0OiAxMCxcclxuICAgICAgICB9KTtcclxuICAgICAgICByKFwiRnVubmVsU2xpY2VcIiwgW1wiZnVubmVsXCIsIFwibGlua1wiLCBcImhvcml6b250YWxcIl0pLnNldEFsbCh7XHJcbiAgICAgICAgICAgIHdpZHRoOiAxMFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgICAgICAqIGNoYXJ0cy9mdW5uZWw6IFB5cmFtaWRcclxuICAgICAgICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgICAgICAgKi9cclxuICAgICAgICByKFwiUHlyYW1pZFNlcmllc1wiKS5zZXRBbGwoe1xyXG4gICAgICAgICAgICB2YWx1ZUlzOiBcImFyZWFcIlxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHIoXCJGdW5uZWxTbGljZVwiLCBbXCJweXJhbWlkXCIsIFwibGlua1wiXSkuc2V0QWxsKHtcclxuICAgICAgICAgICAgZmlsbE9wYWNpdHk6IDAuNVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHIoXCJGdW5uZWxTbGljZVwiLCBbXCJweXJhbWlkXCIsIFwibGlua1wiLCBcInZlcnRpY2FsXCJdKS5zZXRBbGwoe1xyXG4gICAgICAgICAgICBoZWlnaHQ6IDBcclxuICAgICAgICB9KTtcclxuICAgICAgICByKFwiRnVubmVsU2xpY2VcIiwgW1wicHlyYW1pZFwiLCBcImxpbmtcIiwgXCJob3Jpem9udGFsXCJdKS5zZXRBbGwoe1xyXG4gICAgICAgICAgICB3aWR0aDogMFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHIoXCJGdW5uZWxTbGljZVwiLCBbXCJweXJhbWlkXCJdKS5zZXRBbGwoe1xyXG4gICAgICAgICAgICBpbnRlcmFjdGl2ZTogdHJ1ZSxcclxuICAgICAgICAgICAgZXhwYW5kRGlzdGFuY2U6IDBcclxuICAgICAgICB9KTtcclxuICAgICAgICByKFwiRnVubmVsU2xpY2VcIiwgW1wicHlyYW1pZFwiXSkuc3RhdGVzLmNyZWF0ZShcImhvdmVyXCIsIHsgZXhwYW5kRGlzdGFuY2U6IDAuMTUgfSk7XHJcbiAgICAgICAgcihcIkxhYmVsXCIsIFtcInB5cmFtaWRcIl0pLnNldEFsbCh7XHJcbiAgICAgICAgICAgIHBvcHVsYXRlVGV4dDogdHJ1ZSxcclxuICAgICAgICAgICAgdGV4dDogXCJ7Y2F0ZWdvcnl9OiB7dmFsdWVQZXJjZW50VG90YWwuZm9ybWF0TnVtYmVyKCcwLjAwcCcpfVwiLFxyXG4gICAgICAgICAgICBjZW50ZXJZOiBwNTBcclxuICAgICAgICB9KTtcclxuICAgICAgICByKFwiTGFiZWxcIiwgW1wicHlyYW1pZFwiLCBcImhvcml6b250YWxcIl0pLnNldEFsbCh7XHJcbiAgICAgICAgICAgIGNlbnRlclg6IDAsXHJcbiAgICAgICAgICAgIGNlbnRlclk6IHA1MCxcclxuICAgICAgICAgICAgcm90YXRpb246IC05MFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHIoXCJMYWJlbFwiLCBbXCJweXJhbWlkXCIsIFwidmVydGljYWxcIl0pLnNldEFsbCh7XHJcbiAgICAgICAgICAgIGNlbnRlclk6IHA1MCxcclxuICAgICAgICAgICAgY2VudGVyWDogMFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHIoXCJUaWNrXCIsIFtcInB5cmFtaWRcIl0pLnNldEFsbCh7XHJcbiAgICAgICAgICAgIGxvY2F0aW9uOiAxXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICAgICAgICogY2hhcnRzL2Z1bm5lbDogUGljdG9yaWFsXHJcbiAgICAgICAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgLy8gQ2xhc3M6IEZ1bm5lbFNsaWNlXHJcbiAgICAgICAgcihcIkZ1bm5lbFNsaWNlXCIsIFtcInBpY3RvcmlhbFwiXSkuc2V0QWxsKHtcclxuICAgICAgICAgICAgaW50ZXJhY3RpdmU6IHRydWUsXHJcbiAgICAgICAgICAgIHRvb2x0aXBUZXh0OiBcIntjYXRlZ29yeX06IHt2YWx1ZVBlcmNlbnRUb3RhbC5mb3JtYXROdW1iZXIoJzAuMDBwJyl9XCJcclxuICAgICAgICB9KTtcclxuICAgICAgICByKFwiTGFiZWxcIiwgW1wicGljdG9yaWFsXCJdKS5zZXRBbGwoe1xyXG4gICAgICAgICAgICBwb3B1bGF0ZVRleHQ6IHRydWUsXHJcbiAgICAgICAgICAgIHRleHQ6IFwie2NhdGVnb3J5fToge3ZhbHVlUGVyY2VudFRvdGFsLmZvcm1hdE51bWJlcignMC4wMHAnKX1cIixcclxuICAgICAgICAgICAgY2VudGVyWTogcDUwXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcihcIkxhYmVsXCIsIFtcInBpY3RvcmlhbFwiLCBcImhvcml6b250YWxcIl0pLnNldEFsbCh7XHJcbiAgICAgICAgICAgIGNlbnRlclg6IDAsXHJcbiAgICAgICAgICAgIGNlbnRlclk6IHA1MCxcclxuICAgICAgICAgICAgcm90YXRpb246IC05MFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHIoXCJMYWJlbFwiLCBbXCJwaWN0b3JpYWxcIiwgXCJ2ZXJ0aWNhbFwiXSkuc2V0QWxsKHtcclxuICAgICAgICAgICAgY2VudGVyWTogcDUwLFxyXG4gICAgICAgICAgICBjZW50ZXJYOiAwXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcihcIkZ1bm5lbFNsaWNlXCIsIFtcInBpY3RvcmlhbFwiLCBcImxpbmtcIl0pLnNldEFsbCh7XHJcbiAgICAgICAgICAgIGZpbGxPcGFjaXR5OiAwLjUsXHJcbiAgICAgICAgICAgIHdpZHRoOiAwLFxyXG4gICAgICAgICAgICBoZWlnaHQ6IDBcclxuICAgICAgICB9KTtcclxuICAgICAgICByKFwiVGlja1wiLCBbXCJwaWN0b3JpYWxcIl0pLnNldEFsbCh7XHJcbiAgICAgICAgICAgIGxvY2F0aW9uOiAwLjVcclxuICAgICAgICB9KTtcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGNvbnN0IHJ1bGUgPSByKFwiR3JhcGhpY3NcIiwgW1wicGljdG9yaWFsXCIsIFwiYmFja2dyb3VuZFwiXSk7XHJcbiAgICAgICAgICAgIHJ1bGUuc2V0QWxsKHtcclxuICAgICAgICAgICAgICAgIGZpbGxPcGFjaXR5OiAwLjJcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHNldENvbG9yKHJ1bGUsIFwiZmlsbFwiLCBpYywgXCJhbHRlcm5hdGl2ZUJhY2tncm91bmRcIik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVBlcmNlbnREZWZhdWx0VGhlbWUuanMubWFwIiwiaW1wb3J0IHsgX19hd2FpdGVyIH0gZnJvbSBcInRzbGliXCI7XHJcbmltcG9ydCB7IFNlcmllcyB9IGZyb20gXCIuLi8uLi9jb3JlL3JlbmRlci9TZXJpZXNcIjtcclxuaW1wb3J0IHsgQ29udGFpbmVyIH0gZnJvbSBcIi4uLy4uL2NvcmUvcmVuZGVyL0NvbnRhaW5lclwiO1xyXG5pbXBvcnQgeyB2aXN1YWxTZXR0aW5ncyB9IGZyb20gXCIuLi8uLi9jb3JlL3JlbmRlci9HcmFwaGljc1wiO1xyXG5pbXBvcnQgKiBhcyAkYXJyYXkgZnJvbSBcIi4uLy4uL2NvcmUvdXRpbC9BcnJheVwiO1xyXG5pbXBvcnQgKiBhcyAkdHlwZSBmcm9tIFwiLi4vLi4vY29yZS91dGlsL1R5cGVcIjtcclxuLyoqXHJcbiAqIEEgYmFzZSBjbGFzcyBmb3IgYW55IHBlcmNlbnQgY2hhcnQgc2VyaWVzLlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIFBlcmNlbnRTZXJpZXMgZXh0ZW5kcyBTZXJpZXMge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJzbGljZXNDb250YWluZXJcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogdGhpcy5jaGlsZHJlbi5wdXNoKENvbnRhaW5lci5uZXcodGhpcy5fcm9vdCwgeyBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLCBpc01lYXN1cmVkOiBmYWxzZSB9KSlcclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJsYWJlbHNDb250YWluZXJcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogdGhpcy5jaGlsZHJlbi5wdXNoKENvbnRhaW5lci5uZXcodGhpcy5fcm9vdCwgeyBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLCBpc01lYXN1cmVkOiBmYWxzZSB9KSlcclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ0aWNrc0NvbnRhaW5lclwiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiB0aGlzLmNoaWxkcmVuLnB1c2goQ29udGFpbmVyLm5ldyh0aGlzLl9yb290LCB7IHBvc2l0aW9uOiBcImFic29sdXRlXCIsIGlzTWVhc3VyZWQ6IGZhbHNlIH0pKVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9sTGFiZWxzXCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IFtdXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX3JMYWJlbHNcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogW11cclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfaExhYmVsc1wiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiBbXVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEEgW1tMaXN0VGVtcGxhdGVdXSBvZiBhbGwgc2xpY2VzIGluIHNlcmllcy5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIGBzbGljZXMudGVtcGxhdGVgIGNhbiBhbHNvIGJlIHVzZWQgdG8gY29uZmlndXJlIHNsaWNlcy5cclxuICAgICAgICAgKi9cclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJzbGljZXNcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogdGhpcy5fbWFrZVNsaWNlcygpXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQSBbW0xpc3RUZW1wbGF0ZV1dIG9mIGFsbCBzbGljZSBsYWJlbHMgaW4gc2VyaWVzLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogYGxhYmVscy50ZW1wbGF0ZWAgY2FuIGFsc28gYmUgdXNlZCB0byBjb25maWd1cmUgc2xpY2UgbGFiZWxzLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxhYmVsc1wiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiB0aGlzLl9tYWtlTGFiZWxzKClcclxuICAgICAgICB9KTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBIFtbTGlzdFRlbXBsYXRlXV0gb2YgYWxsIHNsaWNlIHRpY2tzIGluIHNlcmllcy5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIGB0aWNrcy50ZW1wbGF0ZWAgY2FuIGFsc28gYmUgdXNlZCB0byBjb25maWd1cmUgc2xpY2UgdGlja3MuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwidGlja3NcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogdGhpcy5fbWFrZVRpY2tzKClcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQGlnbm9yZVxyXG4gICAgICovXHJcbiAgICBtYWtlU2xpY2UoZGF0YUl0ZW0pIHtcclxuICAgICAgICBjb25zdCBzbGljZSA9IHRoaXMuc2xpY2VzQ29udGFpbmVyLmNoaWxkcmVuLnB1c2godGhpcy5zbGljZXMubWFrZSgpKTtcclxuICAgICAgICBzbGljZS5vbihcImZpbGxcIiwgKCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUxlZ2VuZE1hcmtlcihkYXRhSXRlbSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgc2xpY2Uub24oXCJzdHJva2VcIiwgKCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUxlZ2VuZE1hcmtlcihkYXRhSXRlbSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgc2xpY2UuX3NldERhdGFJdGVtKGRhdGFJdGVtKTtcclxuICAgICAgICBkYXRhSXRlbS5zZXQoXCJzbGljZVwiLCBzbGljZSk7XHJcbiAgICAgICAgdGhpcy5zbGljZXMucHVzaChzbGljZSk7XHJcbiAgICAgICAgcmV0dXJuIHNsaWNlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAaWdub3JlXHJcbiAgICAgKi9cclxuICAgIG1ha2VMYWJlbChkYXRhSXRlbSkge1xyXG4gICAgICAgIGNvbnN0IGxhYmVsID0gdGhpcy5sYWJlbHNDb250YWluZXIuY2hpbGRyZW4ucHVzaCh0aGlzLmxhYmVscy5tYWtlKCkpO1xyXG4gICAgICAgIGxhYmVsLl9zZXREYXRhSXRlbShkYXRhSXRlbSk7XHJcbiAgICAgICAgZGF0YUl0ZW0uc2V0KFwibGFiZWxcIiwgbGFiZWwpO1xyXG4gICAgICAgIHRoaXMubGFiZWxzLnB1c2gobGFiZWwpO1xyXG4gICAgICAgIHJldHVybiBsYWJlbDtcclxuICAgIH1cclxuICAgIF9zaG91bGRNYWtlQnVsbGV0KGRhdGFJdGVtKSB7XHJcbiAgICAgICAgaWYgKGRhdGFJdGVtLmdldChcInZhbHVlXCIpICE9IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQGlnbm9yZVxyXG4gICAgICovXHJcbiAgICBtYWtlVGljayhkYXRhSXRlbSkge1xyXG4gICAgICAgIGNvbnN0IHRpY2sgPSB0aGlzLnRpY2tzQ29udGFpbmVyLmNoaWxkcmVuLnB1c2godGhpcy50aWNrcy5tYWtlKCkpO1xyXG4gICAgICAgIHRpY2suX3NldERhdGFJdGVtKGRhdGFJdGVtKTtcclxuICAgICAgICBkYXRhSXRlbS5zZXQoXCJ0aWNrXCIsIHRpY2spO1xyXG4gICAgICAgIHRoaXMudGlja3MucHVzaCh0aWNrKTtcclxuICAgICAgICByZXR1cm4gdGljaztcclxuICAgIH1cclxuICAgIF9hZnRlck5ldygpIHtcclxuICAgICAgICB0aGlzLmZpZWxkcy5wdXNoKFwiY2F0ZWdvcnlcIiwgXCJmaWxsXCIpO1xyXG4gICAgICAgIHN1cGVyLl9hZnRlck5ldygpO1xyXG4gICAgfVxyXG4gICAgX29uRGF0YUNsZWFyKCkge1xyXG4gICAgICAgIGNvbnN0IGNvbG9ycyA9IHRoaXMuZ2V0KFwiY29sb3JzXCIpO1xyXG4gICAgICAgIGlmIChjb2xvcnMpIHtcclxuICAgICAgICAgICAgY29sb3JzLnJlc2V0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgX3ByZXBhcmVDaGlsZHJlbigpIHtcclxuICAgICAgICBzdXBlci5fcHJlcGFyZUNoaWxkcmVuKCk7XHJcbiAgICAgICAgdGhpcy5fbExhYmVscyA9IFtdO1xyXG4gICAgICAgIHRoaXMuX3JMYWJlbHMgPSBbXTtcclxuICAgICAgICB0aGlzLl9oTGFiZWxzID0gW107XHJcbiAgICAgICAgaWYgKHRoaXMuX3ZhbHVlc0RpcnR5KSB7XHJcbiAgICAgICAgICAgIGxldCBzdW0gPSAwO1xyXG4gICAgICAgICAgICBsZXQgYWJzU3VtID0gMDtcclxuICAgICAgICAgICAgbGV0IHZhbHVlSGlnaCA9IDA7XHJcbiAgICAgICAgICAgIGxldCB2YWx1ZUxvdyA9IEluZmluaXR5O1xyXG4gICAgICAgICAgICBsZXQgY291bnQgPSAwO1xyXG4gICAgICAgICAgICAkYXJyYXkuZWFjaCh0aGlzLl9kYXRhSXRlbXMsIChkYXRhSXRlbSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgbGV0IHZhbHVlV29ya2luZyA9IGRhdGFJdGVtLmdldChcInZhbHVlV29ya2luZ1wiLCAwKTtcclxuICAgICAgICAgICAgICAgIHN1bSArPSB2YWx1ZVdvcmtpbmc7XHJcbiAgICAgICAgICAgICAgICBhYnNTdW0gKz0gTWF0aC5hYnModmFsdWVXb3JraW5nKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICRhcnJheS5lYWNoKHRoaXMuX2RhdGFJdGVtcywgKGRhdGFJdGVtKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBsZXQgdmFsdWUgPSBkYXRhSXRlbS5nZXQoXCJ2YWx1ZVdvcmtpbmdcIiwgMCk7XHJcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPiB2YWx1ZUhpZ2gpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZUhpZ2ggPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA8IHZhbHVlTG93KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVMb3cgPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvdW50Kys7XHJcbiAgICAgICAgICAgICAgICBsZXQgcGVyY2VudFRvdGFsID0gdmFsdWUgLyBhYnNTdW07XHJcbiAgICAgICAgICAgICAgICBpZiAoYWJzU3VtID09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBwZXJjZW50VG90YWwgPSAwO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZGF0YUl0ZW0uc2V0UmF3KFwidmFsdWVQZXJjZW50VG90YWxcIiwgcGVyY2VudFRvdGFsICogMTAwKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0UHJpdmF0ZVJhdyhcInZhbHVlTG93XCIsIHZhbHVlTG93KTtcclxuICAgICAgICAgICAgdGhpcy5zZXRQcml2YXRlUmF3KFwidmFsdWVIaWdoXCIsIHZhbHVlSGlnaCk7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0UHJpdmF0ZVJhdyhcInZhbHVlU3VtXCIsIHN1bSk7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0UHJpdmF0ZVJhdyhcInZhbHVlQXZlcmFnZVwiLCBzdW0gLyBjb3VudCk7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0UHJpdmF0ZVJhdyhcInZhbHVlQWJzb2x1dGVTdW1cIiwgYWJzU3VtKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNob3dzIGhpZGRlbiBzZXJpZXMuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtICAgZHVyYXRpb24gIEFuaW1hdGlvbiBkdXJhdGlvbiBpbiBtaWxsaXNlY29uZHNcclxuICAgICAqIEByZXR1cm4gICAgICAgICAgICBBbmltYXRpb24gcHJvbWlzZVxyXG4gICAgICovXHJcbiAgICBzaG93KGR1cmF0aW9uKSB7XHJcbiAgICAgICAgY29uc3QgX3N1cGVyID0gT2JqZWN0LmNyZWF0ZShudWxsLCB7XHJcbiAgICAgICAgICAgIHNob3c6IHsgZ2V0OiAoKSA9PiBzdXBlci5zaG93IH1cclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICBsZXQgcHJvbWlzZXMgPSBbXTtcclxuICAgICAgICAgICAgcHJvbWlzZXMucHVzaChfc3VwZXIuc2hvdy5jYWxsKHRoaXMsIGR1cmF0aW9uKSk7XHJcbiAgICAgICAgICAgIHByb21pc2VzLnB1c2godGhpcy5fc2VxdWVuY2VkU2hvd0hpZGUodHJ1ZSwgZHVyYXRpb24pKTtcclxuICAgICAgICAgICAgeWllbGQgUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBIaWRlIHdob2xlIHNlcmllcy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gICBkdXJhdGlvbiAgQW5pbWF0aW9uIGR1cmF0aW9uIGluIG1pbGxpc2Vjb25kc1xyXG4gICAgICogQHJldHVybiAgICAgICAgICAgIEFuaW1hdGlvbiBwcm9taXNlXHJcbiAgICAgKi9cclxuICAgIGhpZGUoZHVyYXRpb24pIHtcclxuICAgICAgICBjb25zdCBfc3VwZXIgPSBPYmplY3QuY3JlYXRlKG51bGwsIHtcclxuICAgICAgICAgICAgaGlkZTogeyBnZXQ6ICgpID0+IHN1cGVyLmhpZGUgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIGxldCBwcm9taXNlcyA9IFtdO1xyXG4gICAgICAgICAgICBwcm9taXNlcy5wdXNoKF9zdXBlci5oaWRlLmNhbGwodGhpcywgZHVyYXRpb24pKTtcclxuICAgICAgICAgICAgcHJvbWlzZXMucHVzaCh0aGlzLl9zZXF1ZW5jZWRTaG93SGlkZShmYWxzZSwgZHVyYXRpb24pKTtcclxuICAgICAgICAgICAgeWllbGQgUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAaWdub3JlXHJcbiAgICAgKi9cclxuICAgIF91cGRhdGVDaGlsZHJlbigpIHtcclxuICAgICAgICBzdXBlci5fdXBkYXRlQ2hpbGRyZW4oKTtcclxuICAgICAgICBpZiAodGhpcy5fdmFsdWVzRGlydHkpIHtcclxuICAgICAgICAgICAgJGFycmF5LmVhY2godGhpcy5fZGF0YUl0ZW1zLCAoZGF0YUl0ZW0pID0+IHtcclxuICAgICAgICAgICAgICAgIGRhdGFJdGVtLmdldChcImxhYmVsXCIpLnRleHQubWFya0RpcnR5VGV4dCgpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuaXNEaXJ0eShcImxlZ2VuZExhYmVsVGV4dFwiKSB8fCB0aGlzLmlzRGlydHkoXCJsZWdlbmRWYWx1ZVRleHRcIikpIHtcclxuICAgICAgICAgICAgJGFycmF5LmVhY2godGhpcy5fZGF0YUl0ZW1zLCAoZGF0YUl0ZW0pID0+IHtcclxuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlTGVnZW5kVmFsdWUoZGF0YUl0ZW0pO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fYXJyYW5nZSgpO1xyXG4gICAgfVxyXG4gICAgX2FycmFuZ2UoKSB7XHJcbiAgICAgICAgdGhpcy5fYXJyYW5nZURvd24odGhpcy5fbExhYmVscyk7XHJcbiAgICAgICAgdGhpcy5fYXJyYW5nZVVwKHRoaXMuX2xMYWJlbHMpO1xyXG4gICAgICAgIHRoaXMuX2FycmFuZ2VEb3duKHRoaXMuX3JMYWJlbHMpO1xyXG4gICAgICAgIHRoaXMuX2FycmFuZ2VVcCh0aGlzLl9yTGFiZWxzKTtcclxuICAgICAgICB0aGlzLl9hcnJhbmdlTGVmdCh0aGlzLl9oTGFiZWxzKTtcclxuICAgICAgICB0aGlzLl9hcnJhbmdlUmlnaHQodGhpcy5faExhYmVscyk7XHJcbiAgICAgICAgJGFycmF5LmVhY2godGhpcy5kYXRhSXRlbXMsIChkYXRhSXRlbSkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLl91cGRhdGVUaWNrKGRhdGFJdGVtKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIF9hZnRlckNoYW5nZWQoKSB7XHJcbiAgICAgICAgc3VwZXIuX2FmdGVyQ2hhbmdlZCgpO1xyXG4gICAgICAgIHRoaXMuX2FycmFuZ2UoKTtcclxuICAgIH1cclxuICAgIHByb2Nlc3NEYXRhSXRlbShkYXRhSXRlbSkge1xyXG4gICAgICAgIHN1cGVyLnByb2Nlc3NEYXRhSXRlbShkYXRhSXRlbSk7XHJcbiAgICAgICAgaWYgKGRhdGFJdGVtLmdldChcImZpbGxcIikgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBsZXQgY29sb3JzID0gdGhpcy5nZXQoXCJjb2xvcnNcIik7XHJcbiAgICAgICAgICAgIGlmIChjb2xvcnMpIHtcclxuICAgICAgICAgICAgICAgIGRhdGFJdGVtLnNldFJhdyhcImZpbGxcIiwgY29sb3JzLm5leHQoKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNob3dzIHNlcmllcydzIGRhdGEgaXRlbS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gICBkYXRhSXRlbSAgRGF0YSBpdGVtXHJcbiAgICAgKiBAcGFyYW0gICBkdXJhdGlvbiAgQW5pbWF0aW9uIGR1cmF0aW9uIGluIG1pbGxpc2Vjb25kc1xyXG4gICAgICogQHJldHVybiAgICAgICAgICAgIFByb21pc2VcclxuICAgICAqL1xyXG4gICAgc2hvd0RhdGFJdGVtKGRhdGFJdGVtLCBkdXJhdGlvbikge1xyXG4gICAgICAgIGNvbnN0IF9zdXBlciA9IE9iamVjdC5jcmVhdGUobnVsbCwge1xyXG4gICAgICAgICAgICBzaG93RGF0YUl0ZW06IHsgZ2V0OiAoKSA9PiBzdXBlci5zaG93RGF0YUl0ZW0gfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHByb21pc2VzID0gW19zdXBlci5zaG93RGF0YUl0ZW0uY2FsbCh0aGlzLCBkYXRhSXRlbSwgZHVyYXRpb24pXTtcclxuICAgICAgICAgICAgaWYgKCEkdHlwZS5pc051bWJlcihkdXJhdGlvbikpIHtcclxuICAgICAgICAgICAgICAgIGR1cmF0aW9uID0gdGhpcy5nZXQoXCJzdGF0ZUFuaW1hdGlvbkR1cmF0aW9uXCIsIDApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IGVhc2luZyA9IHRoaXMuZ2V0KFwic3RhdGVBbmltYXRpb25FYXNpbmdcIik7XHJcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IGRhdGFJdGVtLmdldChcInZhbHVlXCIpO1xyXG4gICAgICAgICAgICBjb25zdCBhbmltYXRpb24gPSBkYXRhSXRlbS5hbmltYXRlKHsga2V5OiBcInZhbHVlV29ya2luZ1wiLCB0bzogdmFsdWUsIGR1cmF0aW9uOiBkdXJhdGlvbiwgZWFzaW5nOiBlYXNpbmcgfSk7XHJcbiAgICAgICAgICAgIGlmIChhbmltYXRpb24pIHtcclxuICAgICAgICAgICAgICAgIHByb21pc2VzLnB1c2goYW5pbWF0aW9uLndhaXRGb3JTdG9wKCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IHRpY2sgPSBkYXRhSXRlbS5nZXQoXCJ0aWNrXCIpO1xyXG4gICAgICAgICAgICBpZiAodGljaykge1xyXG4gICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaCh0aWNrLnNob3coZHVyYXRpb24pKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBsYWJlbCA9IGRhdGFJdGVtLmdldChcImxhYmVsXCIpO1xyXG4gICAgICAgICAgICBpZiAobGFiZWwpIHtcclxuICAgICAgICAgICAgICAgIHByb21pc2VzLnB1c2gobGFiZWwuc2hvdyhkdXJhdGlvbikpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IHNsaWNlID0gZGF0YUl0ZW0uZ2V0KFwic2xpY2VcIik7XHJcbiAgICAgICAgICAgIGlmIChzbGljZSkge1xyXG4gICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaChzbGljZS5zaG93KGR1cmF0aW9uKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHNsaWNlLmdldChcImFjdGl2ZVwiKSkge1xyXG4gICAgICAgICAgICAgICAgc2xpY2Uuc3RhdGVzLmFwcGx5QW5pbWF0ZShcImFjdGl2ZVwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB5aWVsZCBQcm9taXNlLmFsbChwcm9taXNlcyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEhpZGVzIHNlcmllcydzIGRhdGEgaXRlbS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gICBkYXRhSXRlbSAgRGF0YSBpdGVtXHJcbiAgICAgKiBAcGFyYW0gICBkdXJhdGlvbiAgQW5pbWF0aW9uIGR1cmF0aW9uIGluIG1pbGxpc2Vjb25kc1xyXG4gICAgICogQHJldHVybiAgICAgICAgICAgIFByb21pc2VcclxuICAgICAqL1xyXG4gICAgaGlkZURhdGFJdGVtKGRhdGFJdGVtLCBkdXJhdGlvbikge1xyXG4gICAgICAgIGNvbnN0IF9zdXBlciA9IE9iamVjdC5jcmVhdGUobnVsbCwge1xyXG4gICAgICAgICAgICBoaWRlRGF0YUl0ZW06IHsgZ2V0OiAoKSA9PiBzdXBlci5oaWRlRGF0YUl0ZW0gfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHByb21pc2VzID0gW19zdXBlci5oaWRlRGF0YUl0ZW0uY2FsbCh0aGlzLCBkYXRhSXRlbSwgZHVyYXRpb24pXTtcclxuICAgICAgICAgICAgY29uc3QgaGlkZGVuU3RhdGUgPSB0aGlzLnN0YXRlcy5jcmVhdGUoXCJoaWRkZW5cIiwge30pO1xyXG4gICAgICAgICAgICBpZiAoISR0eXBlLmlzTnVtYmVyKGR1cmF0aW9uKSkge1xyXG4gICAgICAgICAgICAgICAgZHVyYXRpb24gPSBoaWRkZW5TdGF0ZS5nZXQoXCJzdGF0ZUFuaW1hdGlvbkR1cmF0aW9uXCIsIHRoaXMuZ2V0KFwic3RhdGVBbmltYXRpb25EdXJhdGlvblwiLCAwKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgZWFzaW5nID0gaGlkZGVuU3RhdGUuZ2V0KFwic3RhdGVBbmltYXRpb25FYXNpbmdcIiwgdGhpcy5nZXQoXCJzdGF0ZUFuaW1hdGlvbkVhc2luZ1wiKSk7XHJcbiAgICAgICAgICAgIGNvbnN0IGFuaW1hdGlvbiA9IGRhdGFJdGVtLmFuaW1hdGUoeyBrZXk6IFwidmFsdWVXb3JraW5nXCIsIHRvOiAwLCBkdXJhdGlvbjogZHVyYXRpb24sIGVhc2luZzogZWFzaW5nIH0pO1xyXG4gICAgICAgICAgICBpZiAoYW5pbWF0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKGFuaW1hdGlvbi53YWl0Rm9yU3RvcCgpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCB0aWNrID0gZGF0YUl0ZW0uZ2V0KFwidGlja1wiKTtcclxuICAgICAgICAgICAgaWYgKHRpY2spIHtcclxuICAgICAgICAgICAgICAgIHByb21pc2VzLnB1c2godGljay5oaWRlKGR1cmF0aW9uKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgbGFiZWwgPSBkYXRhSXRlbS5nZXQoXCJsYWJlbFwiKTtcclxuICAgICAgICAgICAgaWYgKGxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKGxhYmVsLmhpZGUoZHVyYXRpb24pKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBzbGljZSA9IGRhdGFJdGVtLmdldChcInNsaWNlXCIpO1xyXG4gICAgICAgICAgICBzbGljZS5oaWRlVG9vbHRpcCgpO1xyXG4gICAgICAgICAgICBpZiAoc2xpY2UpIHtcclxuICAgICAgICAgICAgICAgIHByb21pc2VzLnB1c2goc2xpY2UuaGlkZShkdXJhdGlvbikpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHlpZWxkIFByb21pc2UuYWxsKHByb21pc2VzKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQGlnbm9yZVxyXG4gICAgICovXHJcbiAgICBkaXNwb3NlRGF0YUl0ZW0oZGF0YUl0ZW0pIHtcclxuICAgICAgICBzdXBlci5kaXNwb3NlRGF0YUl0ZW0oZGF0YUl0ZW0pO1xyXG4gICAgICAgIGxldCBsYWJlbCA9IGRhdGFJdGVtLmdldChcImxhYmVsXCIpO1xyXG4gICAgICAgIGlmIChsYWJlbCkge1xyXG4gICAgICAgICAgICB0aGlzLmxhYmVscy5yZW1vdmVWYWx1ZShsYWJlbCk7XHJcbiAgICAgICAgICAgIGxhYmVsLmRpc3Bvc2UoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IHRpY2sgPSBkYXRhSXRlbS5nZXQoXCJ0aWNrXCIpO1xyXG4gICAgICAgIGlmICh0aWNrKSB7XHJcbiAgICAgICAgICAgIHRoaXMudGlja3MucmVtb3ZlVmFsdWUodGljayk7XHJcbiAgICAgICAgICAgIHRpY2suZGlzcG9zZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgc2xpY2UgPSBkYXRhSXRlbS5nZXQoXCJzbGljZVwiKTtcclxuICAgICAgICBpZiAoc2xpY2UpIHtcclxuICAgICAgICAgICAgdGhpcy5zbGljZXMucmVtb3ZlVmFsdWUoc2xpY2UpO1xyXG4gICAgICAgICAgICBzbGljZS5kaXNwb3NlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUcmlnZ2VycyBob3ZlciBvbiBhIHNlcmllcyBkYXRhIGl0ZW0uXHJcbiAgICAgKlxyXG4gICAgICogQHNpbmNlIDUuMC43XHJcbiAgICAgKiBAcGFyYW0gIGRhdGFJdGVtICBUYXJnZXQgZGF0YSBpdGVtXHJcbiAgICAgKi9cclxuICAgIGhvdmVyRGF0YUl0ZW0oZGF0YUl0ZW0pIHtcclxuICAgICAgICBjb25zdCBzbGljZSA9IGRhdGFJdGVtLmdldChcInNsaWNlXCIpO1xyXG4gICAgICAgIGlmIChzbGljZSAmJiAhc2xpY2UuaXNIaWRkZW4oKSkge1xyXG4gICAgICAgICAgICBzbGljZS5ob3ZlcigpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVHJpZ2dlcnMgdW4taG92ZXIgb24gYSBzZXJpZXMgZGF0YSBpdGVtLlxyXG4gICAgICpcclxuICAgICAqIEBzaW5jZSA1LjAuN1xyXG4gICAgICogQHBhcmFtICBkYXRhSXRlbSAgVGFyZ2V0IGRhdGEgaXRlbVxyXG4gICAgICovXHJcbiAgICB1bmhvdmVyRGF0YUl0ZW0oZGF0YUl0ZW0pIHtcclxuICAgICAgICBjb25zdCBzbGljZSA9IGRhdGFJdGVtLmdldChcInNsaWNlXCIpO1xyXG4gICAgICAgIGlmIChzbGljZSkge1xyXG4gICAgICAgICAgICBzbGljZS51bmhvdmVyKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAaWdub3JlXHJcbiAgICAgKi9cclxuICAgIHVwZGF0ZUxlZ2VuZE1hcmtlcihkYXRhSXRlbSkge1xyXG4gICAgICAgIGlmIChkYXRhSXRlbSkge1xyXG4gICAgICAgICAgICBjb25zdCBzbGljZSA9IGRhdGFJdGVtLmdldChcInNsaWNlXCIpO1xyXG4gICAgICAgICAgICBpZiAoc2xpY2UpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGxlZ2VuZERhdGFJdGVtID0gZGF0YUl0ZW0uZ2V0KFwibGVnZW5kRGF0YUl0ZW1cIik7XHJcbiAgICAgICAgICAgICAgICBpZiAobGVnZW5kRGF0YUl0ZW0pIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBtYXJrZXJSZWN0YW5nbGUgPSBsZWdlbmREYXRhSXRlbS5nZXQoXCJtYXJrZXJSZWN0YW5nbGVcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgJGFycmF5LmVhY2godmlzdWFsU2V0dGluZ3MsIChzZXR0aW5nKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzbGljZS5nZXQoc2V0dGluZykgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFya2VyUmVjdGFuZ2xlLnNldChzZXR0aW5nLCBzbGljZS5nZXQoc2V0dGluZykpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBfYXJyYW5nZURvd24obGFiZWxzKSB7XHJcbiAgICAgICAgaWYgKGxhYmVscykge1xyXG4gICAgICAgICAgICBsZXQgbmV4dCA9IHRoaXMuX2dldE5leHREb3duKCk7XHJcbiAgICAgICAgICAgIGxhYmVscy5zb3J0KChhLCBiKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoYS55ID4gYi55KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChhLnkgPCBiLnkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gLTE7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICRhcnJheS5lYWNoKGxhYmVscywgKGwpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGJvdW5kcyA9IGwubGFiZWwuYWRqdXN0ZWRMb2NhbEJvdW5kcygpO1xyXG4gICAgICAgICAgICAgICAgbGV0IGxhYmVsVG9wID0gYm91bmRzLnRvcDtcclxuICAgICAgICAgICAgICAgIGlmIChsLnkgKyBsYWJlbFRvcCA8IG5leHQpIHtcclxuICAgICAgICAgICAgICAgICAgICBsLnkgPSBuZXh0IC0gbGFiZWxUb3A7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBsLmxhYmVsLnNldChcInlcIiwgbC55KTtcclxuICAgICAgICAgICAgICAgIG5leHQgPSBsLnkgKyBib3VuZHMuYm90dG9tO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBfZ2V0TmV4dFVwKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmxhYmVsc0NvbnRhaW5lci5tYXhIZWlnaHQoKTtcclxuICAgIH1cclxuICAgIF9nZXROZXh0RG93bigpIHtcclxuICAgICAgICByZXR1cm4gMDtcclxuICAgIH1cclxuICAgIF9hcnJhbmdlVXAobGFiZWxzKSB7XHJcbiAgICAgICAgaWYgKGxhYmVscykge1xyXG4gICAgICAgICAgICBsZXQgbmV4dCA9IHRoaXMuX2dldE5leHRVcCgpO1xyXG4gICAgICAgICAgICBsYWJlbHMuc29ydCgoYSwgYikgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKGEueSA8IGIueSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAxO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoYS55ID4gYi55KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAkYXJyYXkuZWFjaChsYWJlbHMsIChsKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBib3VuZHMgPSBsLmxhYmVsLmFkanVzdGVkTG9jYWxCb3VuZHMoKTtcclxuICAgICAgICAgICAgICAgIGxldCBsYWJlbEJvdHRvbSA9IGJvdW5kcy5ib3R0b207XHJcbiAgICAgICAgICAgICAgICBpZiAobC55ICsgbGFiZWxCb3R0b20gPiBuZXh0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbC55ID0gbmV4dCAtIGxhYmVsQm90dG9tO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgbC5sYWJlbC5zZXQoXCJ5XCIsIGwueSk7XHJcbiAgICAgICAgICAgICAgICBuZXh0ID0gbC55ICsgYm91bmRzLnRvcDtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgX2FycmFuZ2VSaWdodChsYWJlbHMpIHtcclxuICAgICAgICBpZiAobGFiZWxzKSB7XHJcbiAgICAgICAgICAgIGxldCBuZXh0ID0gMDtcclxuICAgICAgICAgICAgbGFiZWxzLnNvcnQoKGEsIGIpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChhLnkgPiBiLnkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGEueSA8IGIueSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAtMTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgJGFycmF5LmVhY2gobGFiZWxzLCAobCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYm91bmRzID0gbC5sYWJlbC5hZGp1c3RlZExvY2FsQm91bmRzKCk7XHJcbiAgICAgICAgICAgICAgICBsZXQgbGFiZWxMZWZ0ID0gYm91bmRzLmxlZnQ7XHJcbiAgICAgICAgICAgICAgICBpZiAobC55ICsgbGFiZWxMZWZ0IDwgbmV4dCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGwueSA9IG5leHQgLSBsYWJlbExlZnQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBsLmxhYmVsLnNldChcInhcIiwgbC55KTtcclxuICAgICAgICAgICAgICAgIG5leHQgPSBsLnkgKyBib3VuZHMucmlnaHQ7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIF9hcnJhbmdlTGVmdChsYWJlbHMpIHtcclxuICAgICAgICBpZiAobGFiZWxzKSB7XHJcbiAgICAgICAgICAgIGxldCBuZXh0ID0gdGhpcy5sYWJlbHNDb250YWluZXIubWF4V2lkdGgoKTtcclxuICAgICAgICAgICAgbGFiZWxzLnNvcnQoKGEsIGIpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChhLnkgPCBiLnkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGEueSA+IGIueSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAtMTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgJGFycmF5LmVhY2gobGFiZWxzLCAobCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYm91bmRzID0gbC5sYWJlbC5hZGp1c3RlZExvY2FsQm91bmRzKCk7XHJcbiAgICAgICAgICAgICAgICBsZXQgbGFiZWxSaWdodCA9IGJvdW5kcy5yaWdodDtcclxuICAgICAgICAgICAgICAgIGlmIChsLnkgKyBsYWJlbFJpZ2h0ID4gbmV4dCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGwueSA9IG5leHQgLSBsYWJlbFJpZ2h0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgbC5sYWJlbC5zZXQoXCJ4XCIsIGwueSk7XHJcbiAgICAgICAgICAgICAgICBuZXh0ID0gbC55ICsgYm91bmRzLmxlZnQ7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIF91cGRhdGVTaXplKCkge1xyXG4gICAgICAgIHN1cGVyLl91cGRhdGVTaXplKCk7XHJcbiAgICAgICAgdGhpcy5tYXJrRGlydHkoKTtcclxuICAgIH1cclxuICAgIF91cGRhdGVUaWNrKF9kYXRhSXRlbSkge1xyXG4gICAgfVxyXG4gICAgX2Rpc3Bvc2UoKSB7XHJcbiAgICAgICAgc3VwZXIuX2Rpc3Bvc2UoKTtcclxuICAgICAgICBjb25zdCBjaGFydCA9IHRoaXMuY2hhcnQ7XHJcbiAgICAgICAgaWYgKGNoYXJ0KSB7XHJcbiAgICAgICAgICAgIGNoYXJ0LnNlcmllcy5yZW1vdmVWYWx1ZSh0aGlzKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFBlcmNlbnRTZXJpZXMsIFwiY2xhc3NOYW1lXCIsIHtcclxuICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgIHZhbHVlOiBcIlBlcmNlbnRTZXJpZXNcIlxyXG59KTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFBlcmNlbnRTZXJpZXMsIFwiY2xhc3NOYW1lc1wiLCB7XHJcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICB2YWx1ZTogU2VyaWVzLmNsYXNzTmFtZXMuY29uY2F0KFtQZXJjZW50U2VyaWVzLmNsYXNzTmFtZV0pXHJcbn0pO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1QZXJjZW50U2VyaWVzLmpzLm1hcCIsImltcG9ydCB7IFBlcmNlbnQgfSBmcm9tIFwiLi4vLi4vY29yZS91dGlsL1BlcmNlbnRcIjtcclxuaW1wb3J0IHsgUGVyY2VudENoYXJ0IH0gZnJvbSBcIi4uL3BlcmNlbnQvUGVyY2VudENoYXJ0XCI7XHJcbmltcG9ydCB7IHA1MCB9IGZyb20gXCIuLi8uLi9jb3JlL3V0aWwvUGVyY2VudFwiO1xyXG5pbXBvcnQgKiBhcyAkdXRpbHMgZnJvbSBcIi4uLy4uL2NvcmUvdXRpbC9VdGlsc1wiO1xyXG5pbXBvcnQgKiBhcyAkbWF0aCBmcm9tIFwiLi4vLi4vY29yZS91dGlsL01hdGhcIjtcclxuLyoqXHJcbiAqIENyZWF0ZXMgYSBwaWUgY2hhcnQuXHJcbiAqXHJcbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vd3d3LmFtY2hhcnRzLmNvbS9kb2NzL3Y1L2NoYXJ0cy9wZXJjZW50LWNoYXJ0cy9waWUtY2hhcnQvfSBmb3IgbW9yZSBpbmZvXHJcbiAqIEBpbXBvcnRhbnRcclxuICovXHJcbmV4cG9ydCBjbGFzcyBQaWVDaGFydCBleHRlbmRzIFBlcmNlbnRDaGFydCB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9tYXhSYWRpdXNcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogMVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgX2FmdGVyTmV3KCkge1xyXG4gICAgICAgIHN1cGVyLl9hZnRlck5ldygpO1xyXG4gICAgICAgIHRoaXMuc2VyaWVzQ29udGFpbmVyLnNldEFsbCh7IHg6IHA1MCwgeTogcDUwIH0pO1xyXG4gICAgfVxyXG4gICAgX3ByZXBhcmVDaGlsZHJlbigpIHtcclxuICAgICAgICBzdXBlci5fcHJlcGFyZUNoaWxkcmVuKCk7XHJcbiAgICAgICAgY29uc3QgY2hhcnRDb250YWluZXIgPSB0aGlzLmNoYXJ0Q29udGFpbmVyO1xyXG4gICAgICAgIGNvbnN0IHcgPSBjaGFydENvbnRhaW5lci5pbm5lcldpZHRoKCk7XHJcbiAgICAgICAgY29uc3QgaCA9IGNoYXJ0Q29udGFpbmVyLmlubmVySGVpZ2h0KCk7XHJcbiAgICAgICAgY29uc3Qgc3RhcnRBbmdsZSA9IHRoaXMuZ2V0KFwic3RhcnRBbmdsZVwiLCAwKTtcclxuICAgICAgICBjb25zdCBlbmRBbmdsZSA9IHRoaXMuZ2V0KFwiZW5kQW5nbGVcIiwgMCk7XHJcbiAgICAgICAgY29uc3QgaW5uZXJSYWRpdXMgPSB0aGlzLmdldChcImlubmVyUmFkaXVzXCIpO1xyXG4gICAgICAgIGxldCBib3VuZHMgPSAkbWF0aC5nZXRBcmNCb3VuZHMoMCwgMCwgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIDEpO1xyXG4gICAgICAgIGNvbnN0IHdyID0gdyAvIChib3VuZHMucmlnaHQgLSBib3VuZHMubGVmdCk7XHJcbiAgICAgICAgY29uc3QgaHIgPSBoIC8gKGJvdW5kcy5ib3R0b20gLSBib3VuZHMudG9wKTtcclxuICAgICAgICBsZXQgaW5uZXJCb3VuZHMgPSB7IGxlZnQ6IDAsIHJpZ2h0OiAwLCB0b3A6IDAsIGJvdHRvbTogMCB9O1xyXG4gICAgICAgIGlmIChpbm5lclJhZGl1cyBpbnN0YW5jZW9mIFBlcmNlbnQpIHtcclxuICAgICAgICAgICAgbGV0IHZhbHVlID0gaW5uZXJSYWRpdXMudmFsdWU7XHJcbiAgICAgICAgICAgIGxldCBtciA9IE1hdGgubWluKHdyLCBocik7XHJcbiAgICAgICAgICAgIHZhbHVlID0gTWF0aC5tYXgobXIgKiB2YWx1ZSwgbXIgLSBNYXRoLm1pbihoLCB3KSkgLyBtcjtcclxuICAgICAgICAgICAgaW5uZXJCb3VuZHMgPSAkbWF0aC5nZXRBcmNCb3VuZHMoMCwgMCwgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIHZhbHVlKTtcclxuICAgICAgICAgICAgdGhpcy5zZXRQcml2YXRlUmF3KFwiaXJNb2RpZnllclwiLCB2YWx1ZSAvIGlubmVyUmFkaXVzLnZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYm91bmRzID0gJG1hdGgubWVyZ2VCb3VuZHMoW2JvdW5kcywgaW5uZXJCb3VuZHNdKTtcclxuICAgICAgICBjb25zdCBwcmV2UmFkaXVzID0gdGhpcy5fbWF4UmFkaXVzO1xyXG4gICAgICAgIHRoaXMuX21heFJhZGl1cyA9IE1hdGgubWluKHdyLCBocik7XHJcbiAgICAgICAgY29uc3QgcmFkaXVzID0gJHV0aWxzLnJlbGF0aXZlVG9WYWx1ZSh0aGlzLmdldChcInJhZGl1c1wiLCAwKSwgdGhpcy5fbWF4UmFkaXVzKTtcclxuICAgICAgICB0aGlzLnNlcmllc0NvbnRhaW5lci5zZXRBbGwoe1xyXG4gICAgICAgICAgICBkeTogLXJhZGl1cyAqIChib3VuZHMuYm90dG9tICsgYm91bmRzLnRvcCkgLyAyLCBkeDogLXJhZGl1cyAqIChib3VuZHMucmlnaHQgKyBib3VuZHMubGVmdCkgLyAyXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKHRoaXMuaXNEaXJ0eShcInN0YXJ0QW5nbGVcIikgfHwgdGhpcy5pc0RpcnR5KFwiZW5kQW5nbGVcIikgfHwgcHJldlJhZGl1cyAhPSB0aGlzLl9tYXhSYWRpdXMpIHtcclxuICAgICAgICAgICAgdGhpcy5zZXJpZXMuZWFjaCgoc2VyaWVzKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBzZXJpZXMuX21hcmtEaXJ0eUtleShcInN0YXJ0QW5nbGVcIik7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5pc0RpcnR5KFwiaW5uZXJSYWRpdXNcIikgfHwgdGhpcy5pc0RpcnR5KFwicmFkaXVzXCIpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2VyaWVzLmVhY2goKHNlcmllcykgPT4ge1xyXG4gICAgICAgICAgICAgICAgc2VyaWVzLl9tYXJrRGlydHlLZXkoXCJpbm5lclJhZGl1c1wiKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIG91dGVyIHJhZGl1cyBpbiBwaXhlbHMuXHJcbiAgICAgKlxyXG4gICAgICogSWYgb3B0aW9uYWwgc2VyaWVzIHBhcmFtZXRlciBpcyBwYXNzZWQgaW4sIGl0IHdpbGwgcmV0dXJuIG91dGVyIHJhZGl1c1xyXG4gICAgICogb2YgdGhhdCBwYXJ0aWN1bGFyIHNlcmllcy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gICBzZXJpZXMgIFNlcmllc1xyXG4gICAgICogQHJldHVybiAgICAgICAgICBSYWRpdXMgaW4gcGl4ZWxzXHJcbiAgICAgKi9cclxuICAgIHJhZGl1cyhzZXJpZXMpIHtcclxuICAgICAgICBsZXQgcmFkaXVzID0gJHV0aWxzLnJlbGF0aXZlVG9WYWx1ZSh0aGlzLmdldChcInJhZGl1c1wiLCAwKSwgdGhpcy5fbWF4UmFkaXVzKTtcclxuICAgICAgICBsZXQgaW5uZXJSYWRpdXMgPSAkdXRpbHMucmVsYXRpdmVUb1ZhbHVlKHRoaXMuZ2V0KFwiaW5uZXJSYWRpdXNcIiwgMCksIHJhZGl1cyk7XHJcbiAgICAgICAgaWYgKHNlcmllcykge1xyXG4gICAgICAgICAgICBsZXQgaW5kZXggPSB0aGlzLnNlcmllcy5pbmRleE9mKHNlcmllcyk7XHJcbiAgICAgICAgICAgIGxldCBsZW5ndGggPSB0aGlzLnNlcmllcy5sZW5ndGg7XHJcbiAgICAgICAgICAgIGxldCBzZXJpZXNSYWRpdXMgPSBzZXJpZXMuZ2V0KFwicmFkaXVzXCIpO1xyXG4gICAgICAgICAgICBpZiAoc2VyaWVzUmFkaXVzICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBpbm5lclJhZGl1cyArICR1dGlscy5yZWxhdGl2ZVRvVmFsdWUoc2VyaWVzUmFkaXVzLCByYWRpdXMgLSBpbm5lclJhZGl1cyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5uZXJSYWRpdXMgKyAocmFkaXVzIC0gaW5uZXJSYWRpdXMpIC8gbGVuZ3RoICogKGluZGV4ICsgMSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJhZGl1cztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBpbm5lciByYWRpdXMgaW4gcGl4ZWxzLlxyXG4gICAgICpcclxuICAgICAqIElmIG9wdGlvbmFsIHNlcmllcyBwYXJhbWV0ZXIgaXMgcGFzc2VkIGluLCBpdCB3aWxsIHJldHVybiBpbm5lciByYWRpdXNcclxuICAgICAqIG9mIHRoYXQgcGFydGljdWxhciBzZXJpZXMuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtICAgc2VyaWVzICBTZXJpZXNcclxuICAgICAqIEByZXR1cm4gICAgICAgICAgUmFkaXVzIGluIHBpeGVsc1xyXG4gICAgICovXHJcbiAgICBpbm5lclJhZGl1cyhzZXJpZXMpIHtcclxuICAgICAgICBjb25zdCByYWRpdXMgPSB0aGlzLnJhZGl1cygpO1xyXG4gICAgICAgIGxldCBpbm5lclJhZGl1cyA9ICR1dGlscy5yZWxhdGl2ZVRvVmFsdWUodGhpcy5nZXQoXCJpbm5lclJhZGl1c1wiLCAwKSwgcmFkaXVzKTtcclxuICAgICAgICBpZiAoaW5uZXJSYWRpdXMgPCAwKSB7XHJcbiAgICAgICAgICAgIGlubmVyUmFkaXVzID0gcmFkaXVzICsgaW5uZXJSYWRpdXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzZXJpZXMpIHtcclxuICAgICAgICAgICAgbGV0IGluZGV4ID0gdGhpcy5zZXJpZXMuaW5kZXhPZihzZXJpZXMpO1xyXG4gICAgICAgICAgICBsZXQgbGVuZ3RoID0gdGhpcy5zZXJpZXMubGVuZ3RoO1xyXG4gICAgICAgICAgICBsZXQgc2VyaWVzSW5uZXJSYWRpdXMgPSBzZXJpZXMuZ2V0KFwiaW5uZXJSYWRpdXNcIik7XHJcbiAgICAgICAgICAgIGlmIChzZXJpZXNJbm5lclJhZGl1cyAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5uZXJSYWRpdXMgKyAkdXRpbHMucmVsYXRpdmVUb1ZhbHVlKHNlcmllc0lubmVyUmFkaXVzLCByYWRpdXMgLSBpbm5lclJhZGl1cyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5uZXJSYWRpdXMgKyAocmFkaXVzIC0gaW5uZXJSYWRpdXMpIC8gbGVuZ3RoICogaW5kZXg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGlubmVyUmFkaXVzO1xyXG4gICAgfVxyXG59XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShQaWVDaGFydCwgXCJjbGFzc05hbWVcIiwge1xyXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgdmFsdWU6IFwiUGllQ2hhcnRcIlxyXG59KTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFBpZUNoYXJ0LCBcImNsYXNzTmFtZXNcIiwge1xyXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgdmFsdWU6IFBlcmNlbnRDaGFydC5jbGFzc05hbWVzLmNvbmNhdChbUGllQ2hhcnQuY2xhc3NOYW1lXSlcclxufSk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVBpZUNoYXJ0LmpzLm1hcCIsImltcG9ydCB7IFBlcmNlbnRTZXJpZXMgfSBmcm9tIFwiLi4vcGVyY2VudC9QZXJjZW50U2VyaWVzXCI7XHJcbmltcG9ydCB7IFRlbXBsYXRlIH0gZnJvbSBcIi4uLy4uL2NvcmUvdXRpbC9UZW1wbGF0ZVwiO1xyXG5pbXBvcnQgeyBTbGljZSB9IGZyb20gXCIuLi8uLi9jb3JlL3JlbmRlci9TbGljZVwiO1xyXG5pbXBvcnQgeyBUaWNrIH0gZnJvbSBcIi4uLy4uL2NvcmUvcmVuZGVyL1RpY2tcIjtcclxuaW1wb3J0IHsgUmFkaWFsTGFiZWwgfSBmcm9tIFwiLi4vLi4vY29yZS9yZW5kZXIvUmFkaWFsTGFiZWxcIjtcclxuaW1wb3J0IHsgTGlzdFRlbXBsYXRlIH0gZnJvbSBcIi4uLy4uL2NvcmUvdXRpbC9MaXN0XCI7XHJcbmltcG9ydCB7IHAxMDAgfSBmcm9tIFwiLi4vLi4vY29yZS91dGlsL1BlcmNlbnRcIjtcclxuaW1wb3J0ICogYXMgJGFycmF5IGZyb20gXCIuLi8uLi9jb3JlL3V0aWwvQXJyYXlcIjtcclxuaW1wb3J0ICogYXMgJG1hdGggZnJvbSBcIi4uLy4uL2NvcmUvdXRpbC9NYXRoXCI7XHJcbmltcG9ydCAqIGFzICR1dGlscyBmcm9tIFwiLi4vLi4vY29yZS91dGlsL1V0aWxzXCI7XHJcbi8qKlxyXG4gKiBDcmVhdGVzIGEgc2VyaWVzIGZvciBhIFtbUGllQ2hhcnRdXS5cclxuICpcclxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly93d3cuYW1jaGFydHMuY29tL2RvY3MvdjUvY2hhcnRzL3BlcmNlbnQtY2hhcnRzL3BpZS1jaGFydC99IGZvciBtb3JlIGluZm9cclxuICogQGltcG9ydGFudFxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIFBpZVNlcmllcyBleHRlbmRzIFBlcmNlbnRTZXJpZXMge1xyXG4gICAgX21ha2VTbGljZXMoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBMaXN0VGVtcGxhdGUoVGVtcGxhdGUubmV3KHt9KSwgKCkgPT4gU2xpY2UuX25ldyh0aGlzLl9yb290LCB7XHJcbiAgICAgICAgICAgIHRoZW1lVGFnczogJHV0aWxzLm1lcmdlVGFncyh0aGlzLnNsaWNlcy50ZW1wbGF0ZS5nZXQoXCJ0aGVtZVRhZ3NcIiwgW10pLCBbXCJwaWVcIiwgXCJzZXJpZXNcIl0pXHJcbiAgICAgICAgfSwgW3RoaXMuc2xpY2VzLnRlbXBsYXRlXSkpO1xyXG4gICAgfVxyXG4gICAgX21ha2VMYWJlbHMoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBMaXN0VGVtcGxhdGUoVGVtcGxhdGUubmV3KHt9KSwgKCkgPT4gUmFkaWFsTGFiZWwuX25ldyh0aGlzLl9yb290LCB7XHJcbiAgICAgICAgICAgIHRoZW1lVGFnczogJHV0aWxzLm1lcmdlVGFncyh0aGlzLmxhYmVscy50ZW1wbGF0ZS5nZXQoXCJ0aGVtZVRhZ3NcIiwgW10pLCBbXCJwaWVcIiwgXCJzZXJpZXNcIl0pXHJcbiAgICAgICAgfSwgW3RoaXMubGFiZWxzLnRlbXBsYXRlXSkpO1xyXG4gICAgfVxyXG4gICAgX21ha2VUaWNrcygpIHtcclxuICAgICAgICByZXR1cm4gbmV3IExpc3RUZW1wbGF0ZShUZW1wbGF0ZS5uZXcoe30pLCAoKSA9PiBUaWNrLl9uZXcodGhpcy5fcm9vdCwge1xyXG4gICAgICAgICAgICB0aGVtZVRhZ3M6ICR1dGlscy5tZXJnZVRhZ3ModGhpcy50aWNrcy50ZW1wbGF0ZS5nZXQoXCJ0aGVtZVRhZ3NcIiwgW10pLCBbXCJwaWVcIiwgXCJzZXJpZXNcIl0pXHJcbiAgICAgICAgfSwgW3RoaXMudGlja3MudGVtcGxhdGVdKSk7XHJcbiAgICB9XHJcbiAgICBwcm9jZXNzRGF0YUl0ZW0oZGF0YUl0ZW0pIHtcclxuICAgICAgICBzdXBlci5wcm9jZXNzRGF0YUl0ZW0oZGF0YUl0ZW0pO1xyXG4gICAgICAgIGNvbnN0IHNsaWNlID0gdGhpcy5tYWtlU2xpY2UoZGF0YUl0ZW0pO1xyXG4gICAgICAgIHNsaWNlLm9uKFwic2NhbGVcIiwgKCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLl91cGRhdGVUaWNrKGRhdGFJdGVtKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBzbGljZS5vbihcInNoaWZ0UmFkaXVzXCIsICgpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5fdXBkYXRlVGljayhkYXRhSXRlbSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgc2xpY2UuZXZlbnRzLm9uKFwicG9zaXRpb25jaGFuZ2VkXCIsICgpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5fdXBkYXRlVGljayhkYXRhSXRlbSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgY29uc3QgbGFiZWwgPSB0aGlzLm1ha2VMYWJlbChkYXRhSXRlbSk7XHJcbiAgICAgICAgbGFiZWwuZXZlbnRzLm9uKFwicG9zaXRpb25jaGFuZ2VkXCIsICgpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5fdXBkYXRlVGljayhkYXRhSXRlbSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5tYWtlVGljayhkYXRhSXRlbSk7XHJcbiAgICAgICAgc2xpY2UuZXZlbnRzLm9uKFwicG9zaXRpb25jaGFuZ2VkXCIsICgpID0+IHtcclxuICAgICAgICAgICAgbGFiZWwubWFya0RpcnR5KCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBfZ2V0TmV4dFVwKCkge1xyXG4gICAgICAgIGNvbnN0IGNoYXJ0ID0gdGhpcy5jaGFydDtcclxuICAgICAgICBpZiAoY2hhcnQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGNoYXJ0Ll9tYXhSYWRpdXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLmxhYmVsc0NvbnRhaW5lci5tYXhIZWlnaHQoKSAvIDI7XHJcbiAgICB9XHJcbiAgICBfZ2V0TmV4dERvd24oKSB7XHJcbiAgICAgICAgY29uc3QgY2hhcnQgPSB0aGlzLmNoYXJ0O1xyXG4gICAgICAgIGlmIChjaGFydCkge1xyXG4gICAgICAgICAgICByZXR1cm4gLWNoYXJ0Ll9tYXhSYWRpdXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAtdGhpcy5sYWJlbHNDb250YWluZXIubWF4SGVpZ2h0KCkgLyAyO1xyXG4gICAgfVxyXG4gICAgX3ByZXBhcmVDaGlsZHJlbigpIHtcclxuICAgICAgICBzdXBlci5fcHJlcGFyZUNoaWxkcmVuKCk7XHJcbiAgICAgICAgY29uc3QgY2hhcnQgPSB0aGlzLmNoYXJ0O1xyXG4gICAgICAgIGlmIChjaGFydCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5pc0RpcnR5KFwiYWxpZ25MYWJlbHNcIikpIHtcclxuICAgICAgICAgICAgICAgIGxldCBsYWJlbHNUZW1wbGF0ZSA9IHRoaXMubGFiZWxzLnRlbXBsYXRlO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZ2V0KFwiYWxpZ25MYWJlbHNcIikpIHtcclxuICAgICAgICAgICAgICAgICAgICBsYWJlbHNUZW1wbGF0ZS5zZXQoXCJ0ZXh0VHlwZVwiLCBcImFsaWduZWRcIik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgdGV4dFR5cGUgPSBsYWJlbHNUZW1wbGF0ZS5nZXQoXCJ0ZXh0VHlwZVwiKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGV4dFR5cGUgPT0gbnVsbCB8fCB0ZXh0VHlwZSA9PSBcImFsaWduZWRcIikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsYWJlbHNUZW1wbGF0ZS5zZXQoXCJ0ZXh0VHlwZVwiLCBcImFkanVzdGVkXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodGhpcy5fdmFsdWVzRGlydHkgfHwgdGhpcy5pc0RpcnR5KFwicmFkaXVzXCIpIHx8IHRoaXMuaXNEaXJ0eShcImlubmVyUmFkaXVzXCIpIHx8IHRoaXMuaXNEaXJ0eShcInN0YXJ0QW5nbGVcIikgfHwgdGhpcy5pc0RpcnR5KFwiZW5kQW5nbGVcIikgfHwgdGhpcy5pc0RpcnR5KFwiYWxpZ25MYWJlbHNcIikpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubWFya0RpcnR5Qm91bmRzKCk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzdGFydEFuZ2xlID0gdGhpcy5nZXQoXCJzdGFydEFuZ2xlXCIsIGNoYXJ0LmdldChcInN0YXJ0QW5nbGVcIiwgLTkwKSk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBlbmRBbmdsZSA9IHRoaXMuZ2V0KFwiZW5kQW5nbGVcIiwgY2hhcnQuZ2V0KFwiZW5kQW5nbGVcIiwgMjcwKSk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBhcmMgPSBlbmRBbmdsZSAtIHN0YXJ0QW5nbGU7XHJcbiAgICAgICAgICAgICAgICBsZXQgY3VycmVudEFuZ2xlID0gc3RhcnRBbmdsZTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHJhZGl1cyA9IGNoYXJ0LnJhZGl1cyh0aGlzKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2V0UHJpdmF0ZVJhdyhcInJhZGl1c1wiLCByYWRpdXMpO1xyXG4gICAgICAgICAgICAgICAgbGV0IGlubmVyUmFkaXVzID0gY2hhcnQuaW5uZXJSYWRpdXModGhpcykgKiBjaGFydC5nZXRQcml2YXRlKFwiaXJNb2RpZnllclwiLCAxKTtcclxuICAgICAgICAgICAgICAgIGlmIChpbm5lclJhZGl1cyA8IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBpbm5lclJhZGl1cyA9IHJhZGl1cyArIGlubmVyUmFkaXVzO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy9pZiAocmFkaXVzID4gMCkge1xyXG4gICAgICAgICAgICAgICAgJGFycmF5LmVhY2godGhpcy5fZGF0YUl0ZW1zLCAoZGF0YUl0ZW0pID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZUxlZ2VuZFZhbHVlKGRhdGFJdGVtKTtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgY3VycmVudEFyYyA9IGFyYyAqIGRhdGFJdGVtLmdldChcInZhbHVlUGVyY2VudFRvdGFsXCIpIC8gMTAwO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNsaWNlID0gZGF0YUl0ZW0uZ2V0KFwic2xpY2VcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNsaWNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNsaWNlLnNldChcInJhZGl1c1wiLCByYWRpdXMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzbGljZS5zZXQoXCJpbm5lclJhZGl1c1wiLCBpbm5lclJhZGl1cyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNsaWNlLnNldChcInN0YXJ0QW5nbGVcIiwgY3VycmVudEFuZ2xlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2xpY2Uuc2V0KFwiYXJjXCIsIGN1cnJlbnRBcmMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjb2xvciA9IGRhdGFJdGVtLmdldChcImZpbGxcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNsaWNlLl9zZXREZWZhdWx0KFwiZmlsbFwiLCBjb2xvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNsaWNlLl9zZXREZWZhdWx0KFwic3Ryb2tlXCIsIGNvbG9yKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IG1pZGRsZUFuZ2xlID0gJG1hdGgubm9ybWFsaXplQW5nbGUoY3VycmVudEFuZ2xlICsgY3VycmVudEFyYyAvIDIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxhYmVsID0gZGF0YUl0ZW0uZ2V0KFwibGFiZWxcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsLnNldFByaXZhdGUoXCJyYWRpdXNcIiwgcmFkaXVzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWwuc2V0UHJpdmF0ZShcImlubmVyUmFkaXVzXCIsIGlubmVyUmFkaXVzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWwuc2V0KFwibGFiZWxBbmdsZVwiLCBtaWRkbGVBbmdsZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsYWJlbC5nZXQoXCJ0ZXh0VHlwZVwiKSA9PSBcImFsaWduZWRcIikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGxhYmVsUmFkaXVzID0gcmFkaXVzICsgbGFiZWwuZ2V0KFwicmFkaXVzXCIsIDApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHkgPSByYWRpdXMgKiAkbWF0aC5zaW4obWlkZGxlQW5nbGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1pZGRsZUFuZ2xlID4gOTAgJiYgbWlkZGxlQW5nbGUgPD0gMjcwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFsYWJlbC5pc0hpZGRlbigpICYmICFsYWJlbC5pc0hpZGluZygpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2xMYWJlbHMucHVzaCh7IGxhYmVsOiBsYWJlbCwgeTogeSB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWxSYWRpdXMgKj0gLTE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWxSYWRpdXMgLT0gdGhpcy5sYWJlbHNDb250YWluZXIuZ2V0KFwicGFkZGluZ0xlZnRcIiwgMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWwuc2V0KFwiY2VudGVyWFwiLCBwMTAwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYWJlbC5zZXRQcml2YXRlUmF3KFwibGVmdFwiLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbGFiZWwuaXNIaWRkZW4oKSAmJiAhbGFiZWwuaXNIaWRpbmcoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9yTGFiZWxzLnB1c2goeyBsYWJlbDogbGFiZWwsIHk6IHkgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsUmFkaXVzICs9IHRoaXMubGFiZWxzQ29udGFpbmVyLmdldChcInBhZGRpbmdSaWdodFwiLCAwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYWJlbC5zZXQoXCJjZW50ZXJYXCIsIDApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsLnNldFByaXZhdGVSYXcoXCJsZWZ0XCIsIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsLnNldChcInhcIiwgbGFiZWxSYWRpdXMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWwuc2V0KFwieVwiLCByYWRpdXMgKiAkbWF0aC5zaW4obWlkZGxlQW5nbGUpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50QW5nbGUgKz0gY3VycmVudEFyYztcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGVUaWNrKGRhdGFJdGVtKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgLy99XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBfdXBkYXRlVGljayhkYXRhSXRlbSkge1xyXG4gICAgICAgIGNvbnN0IHRpY2sgPSBkYXRhSXRlbS5nZXQoXCJ0aWNrXCIpO1xyXG4gICAgICAgIGNvbnN0IGxhYmVsID0gZGF0YUl0ZW0uZ2V0KFwibGFiZWxcIik7XHJcbiAgICAgICAgY29uc3Qgc2xpY2UgPSBkYXRhSXRlbS5nZXQoXCJzbGljZVwiKTtcclxuICAgICAgICBjb25zdCBsb2NhdGlvbiA9IHRpY2suZ2V0KFwibG9jYXRpb25cIiwgMSk7XHJcbiAgICAgICAgaWYgKHRpY2sgJiYgbGFiZWwgJiYgc2xpY2UpIHtcclxuICAgICAgICAgICAgY29uc3QgcmFkaXVzID0gKHNsaWNlLmdldChcInNoaWZ0UmFkaXVzXCIsIDApICsgc2xpY2UuZ2V0KFwicmFkaXVzXCIsIDApKSAqIHNsaWNlLmdldChcInNjYWxlXCIsIDEpICogbG9jYXRpb247XHJcbiAgICAgICAgICAgIGNvbnN0IGxhYmVsQW5nbGUgPSBsYWJlbC5nZXQoXCJsYWJlbEFuZ2xlXCIsIDApO1xyXG4gICAgICAgICAgICBjb25zdCBjb3MgPSAkbWF0aC5jb3MobGFiZWxBbmdsZSk7XHJcbiAgICAgICAgICAgIGNvbnN0IHNpbiA9ICRtYXRoLnNpbihsYWJlbEFuZ2xlKTtcclxuICAgICAgICAgICAgY29uc3QgbGFiZWxzQ29udGFpbmVyID0gdGhpcy5sYWJlbHNDb250YWluZXI7XHJcbiAgICAgICAgICAgIGNvbnN0IHBsID0gbGFiZWxzQ29udGFpbmVyLmdldChcInBhZGRpbmdMZWZ0XCIsIDApO1xyXG4gICAgICAgICAgICBjb25zdCBwciA9IGxhYmVsc0NvbnRhaW5lci5nZXQoXCJwYWRkaW5nUmlnaHRcIiwgMCk7XHJcbiAgICAgICAgICAgIGxldCB4ID0gMDtcclxuICAgICAgICAgICAgbGV0IHkgPSAwO1xyXG4gICAgICAgICAgICB4ID0gbGFiZWwueCgpO1xyXG4gICAgICAgICAgICB5ID0gbGFiZWwueSgpO1xyXG4gICAgICAgICAgICBsZXQgcG9pbnRzID0gW107XHJcbiAgICAgICAgICAgIGlmICh4ICE9IDAgJiYgeSAhPSAwKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobGFiZWwuZ2V0KFwidGV4dFR5cGVcIikgPT0gXCJjaXJjdWxhclwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbGFiZWxSYWRpdXMgPSBsYWJlbC5yYWRpdXMoKSAtIGxhYmVsLmdldChcInBhZGRpbmdCb3R0b21cIiwgMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbGFiZWxBbmdsZSA9IGxhYmVsLmdldChcImxhYmVsQW5nbGVcIiwgMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgeCA9IGxhYmVsUmFkaXVzICogJG1hdGguY29zKGxhYmVsQW5nbGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHkgPSBsYWJlbFJhZGl1cyAqICRtYXRoLnNpbihsYWJlbEFuZ2xlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGxldCBkeCA9IC1wcjtcclxuICAgICAgICAgICAgICAgIGlmIChsYWJlbC5nZXRQcml2YXRlKFwibGVmdFwiKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGR4ID0gcGw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBwb2ludHMgPSBbeyB4OiBzbGljZS54KCkgKyByYWRpdXMgKiBjb3MsIHk6IHNsaWNlLnkoKSArIHJhZGl1cyAqIHNpbiB9LCB7IHg6IHggKyBkeCwgeTogeSB9LCB7IHg6IHgsIHk6IHkgfV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGljay5zZXQoXCJwb2ludHNcIiwgcG9pbnRzKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBfcG9zaXRpb25CdWxsZXQoYnVsbGV0KSB7XHJcbiAgICAgICAgY29uc3Qgc3ByaXRlID0gYnVsbGV0LmdldChcInNwcml0ZVwiKTtcclxuICAgICAgICBpZiAoc3ByaXRlKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGRhdGFJdGVtID0gc3ByaXRlLmRhdGFJdGVtO1xyXG4gICAgICAgICAgICBjb25zdCBzbGljZSA9IGRhdGFJdGVtLmdldChcInNsaWNlXCIpO1xyXG4gICAgICAgICAgICBpZiAoc2xpY2UpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGlubmVyUmFkaXVzID0gc2xpY2UuZ2V0KFwiaW5uZXJSYWRpdXNcIiwgMCk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCByYWRpdXMgPSBzbGljZS5nZXQoXCJyYWRpdXNcIiwgMCk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzdGFydEFuZ2xlID0gc2xpY2UuZ2V0KFwic3RhcnRBbmdsZVwiLCAwKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGFyYyA9IHNsaWNlLmdldChcImFyY1wiLCAwKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGxvY2F0aW9uWCA9IGJ1bGxldC5nZXQoXCJsb2NhdGlvblhcIiwgMC41KTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGxvY2F0aW9uWSA9IGJ1bGxldC5nZXQoXCJsb2NhdGlvbllcIiwgMC41KTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGFuZ2xlID0gc3RhcnRBbmdsZSArIGFyYyAqIGxvY2F0aW9uWDtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHIgPSBpbm5lclJhZGl1cyArIChyYWRpdXMgLSBpbm5lclJhZGl1cykgKiBsb2NhdGlvblk7XHJcbiAgICAgICAgICAgICAgICBzcHJpdGUuc2V0QWxsKHsgeDogJG1hdGguY29zKGFuZ2xlKSAqIHIsIHk6ICRtYXRoLnNpbihhbmdsZSkgKiByIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShQaWVTZXJpZXMsIFwiY2xhc3NOYW1lXCIsIHtcclxuICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgIHZhbHVlOiBcIlBpZVNlcmllc1wiXHJcbn0pO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUGllU2VyaWVzLCBcImNsYXNzTmFtZXNcIiwge1xyXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgdmFsdWU6IFBlcmNlbnRTZXJpZXMuY2xhc3NOYW1lcy5jb25jYXQoW1BpZVNlcmllcy5jbGFzc05hbWVdKVxyXG59KTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UGllU2VyaWVzLmpzLm1hcCIsIjtcclxuaW1wb3J0IHsgWFlDaGFydERlZmF1bHRUaGVtZSB9IGZyb20gXCIuL1hZQ2hhcnREZWZhdWx0VGhlbWVcIjtcclxuaW1wb3J0IHsgQ29udGFpbmVyIH0gZnJvbSBcIi4uLy4uL2NvcmUvcmVuZGVyL0NvbnRhaW5lclwiO1xyXG5pbXBvcnQgeyBSZWN0YW5nbGUgfSBmcm9tIFwiLi4vLi4vY29yZS9yZW5kZXIvUmVjdGFuZ2xlXCI7XHJcbmltcG9ydCB7IFNlcmlhbENoYXJ0IH0gZnJvbSBcIi4uLy4uL2NvcmUvcmVuZGVyL1NlcmlhbENoYXJ0XCI7XHJcbmltcG9ydCB7IExpc3RBdXRvRGlzcG9zZSB9IGZyb20gXCIuLi8uLi9jb3JlL3V0aWwvTGlzdFwiO1xyXG5pbXBvcnQgeyBwMTAwIH0gZnJvbSBcIi4uLy4uL2NvcmUvdXRpbC9QZXJjZW50XCI7XHJcbmltcG9ydCB7IENvbG9yIH0gZnJvbSBcIi4uLy4uL2NvcmUvdXRpbC9Db2xvclwiO1xyXG5pbXBvcnQgeyBCdXR0b24gfSBmcm9tIFwiLi4vLi4vY29yZS9yZW5kZXIvQnV0dG9uXCI7XHJcbmltcG9ydCB7IEdyYXBoaWNzIH0gZnJvbSBcIi4uLy4uL2NvcmUvcmVuZGVyL0dyYXBoaWNzXCI7XHJcbmltcG9ydCB7IFBlcmNlbnQgfSBmcm9tIFwiLi4vLi4vY29yZS91dGlsL1BlcmNlbnRcIjtcclxuaW1wb3J0ICogYXMgJGFycmF5IGZyb20gXCIuLi8uLi9jb3JlL3V0aWwvQXJyYXlcIjtcclxuaW1wb3J0ICogYXMgJHR5cGUgZnJvbSBcIi4uLy4uL2NvcmUvdXRpbC9UeXBlXCI7XHJcbmltcG9ydCAqIGFzICRvcmRlciBmcm9tIFwiLi4vLi4vY29yZS91dGlsL09yZGVyXCI7XHJcbmltcG9ydCAqIGFzICRvYmplY3QgZnJvbSBcIi4uLy4uL2NvcmUvdXRpbC9PYmplY3RcIjtcclxuaW1wb3J0ICogYXMgJHV0aWxzIGZyb20gXCIuLi8uLi9jb3JlL3V0aWwvVXRpbHNcIjtcclxuLyoqXHJcbiAqIENyZWF0ZXMgYW4gWFkgY2hhcnQuXHJcbiAqXHJcbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vd3d3LmFtY2hhcnRzLmNvbS9kb2NzL3Y1L2NoYXJ0cy94eS1jaGFydC99IGZvciBtb3JlIGluZm9cclxuICogQGltcG9ydGFudFxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIFhZQ2hhcnQgZXh0ZW5kcyBTZXJpYWxDaGFydCB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEEgbGlzdCBvZiBob3Jpem9udGFsIGF4ZXMuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwieEF4ZXNcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogbmV3IExpc3RBdXRvRGlzcG9zZSgpXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQSBsaXN0IG9mIHZlcnRpY2FsIGF4ZXMuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwieUF4ZXNcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogbmV3IExpc3RBdXRvRGlzcG9zZSgpXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQSBbW0NvbnRhaW5lcl1dIGxvY2F0ZWQgb24gdG9wIG9mIHRoZSBjaGFydCwgdXNlZCB0byBzdG9yZSB0b3AgaG9yaXpvbnRhbFxyXG4gICAgICAgICAqIGF4ZXMuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAc2VlIHtAbGluayBodHRwczovL3d3dy5hbWNoYXJ0cy5jb20vZG9jcy92NS9jaGFydHMveHktY2hhcnQveHktY2hhcnQtY29udGFpbmVycy99IGZvciBtb3JlIGluZm9cclxuICAgICAgICAgKiBAZGVmYXVsdCBDb250YWluZXIubmV3KClcclxuICAgICAgICAgKi9cclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ0b3BBeGVzQ29udGFpbmVyXCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IHRoaXMuY2hhcnRDb250YWluZXIuY2hpbGRyZW4ucHVzaChDb250YWluZXIubmV3KHRoaXMuX3Jvb3QsIHsgd2lkdGg6IHAxMDAsIGxheW91dDogdGhpcy5fcm9vdC52ZXJ0aWNhbExheW91dCB9KSlcclxuICAgICAgICB9KTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBIFtbQ29udGFpbmVyXV0gbG9jYXRlZCBpbiB0aGUgbWlkZGxlIHRoZSBjaGFydCwgdXNlZCB0byBzdG9yZSB2ZXJ0aWNhbCBheGVzXHJcbiAgICAgICAgICogYW5kIHBsb3QgYXJlYSBjb250YWluZXIuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAc2VlIHtAbGluayBodHRwczovL3d3dy5hbWNoYXJ0cy5jb20vZG9jcy92NS9jaGFydHMveHktY2hhcnQveHktY2hhcnQtY29udGFpbmVycy99IGZvciBtb3JlIGluZm9cclxuICAgICAgICAgKiBAZGVmYXVsdCBDb250YWluZXIubmV3KClcclxuICAgICAgICAgKi9cclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ5QXhlc0FuZFBsb3RDb250YWluZXJcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogdGhpcy5jaGFydENvbnRhaW5lci5jaGlsZHJlbi5wdXNoKENvbnRhaW5lci5uZXcodGhpcy5fcm9vdCwgeyB3aWR0aDogcDEwMCwgaGVpZ2h0OiBwMTAwLCBsYXlvdXQ6IHRoaXMuX3Jvb3QuaG9yaXpvbnRhbExheW91dCB9KSlcclxuICAgICAgICB9KTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBIFtbQ29udGFpbmVyXV0gbG9jYXRlZCBvbiBib3R0b20gb2YgdGhlIGNoYXJ0LCB1c2VkIHRvIHN0b3JlIGJvdHRvbVxyXG4gICAgICAgICAqIGhvcml6b250YWwgYXhlcy5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vd3d3LmFtY2hhcnRzLmNvbS9kb2NzL3Y1L2NoYXJ0cy94eS1jaGFydC94eS1jaGFydC1jb250YWluZXJzL30gZm9yIG1vcmUgaW5mb1xyXG4gICAgICAgICAqIEBkZWZhdWx0IENvbnRhaW5lci5uZXcoKVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImJvdHRvbUF4ZXNDb250YWluZXJcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogdGhpcy5jaGFydENvbnRhaW5lci5jaGlsZHJlbi5wdXNoKENvbnRhaW5lci5uZXcodGhpcy5fcm9vdCwgeyB3aWR0aDogcDEwMCwgbGF5b3V0OiB0aGlzLl9yb290LnZlcnRpY2FsTGF5b3V0IH0pKVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEEgW1tDb250YWluZXJdXSBsb2NhdGVkIG9uIGxlZnQgb2YgdGhlIGNoYXJ0LCB1c2VkIHRvIHN0b3JlIGxlZnQtaGFuZFxyXG4gICAgICAgICAqIHZlcnRpY2FsIGF4ZXMuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAc2VlIHtAbGluayBodHRwczovL3d3dy5hbWNoYXJ0cy5jb20vZG9jcy92NS9jaGFydHMveHktY2hhcnQveHktY2hhcnQtY29udGFpbmVycy99IGZvciBtb3JlIGluZm9cclxuICAgICAgICAgKiBAZGVmYXVsdCBDb250YWluZXIubmV3KClcclxuICAgICAgICAgKi9cclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJsZWZ0QXhlc0NvbnRhaW5lclwiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiB0aGlzLnlBeGVzQW5kUGxvdENvbnRhaW5lci5jaGlsZHJlbi5wdXNoKENvbnRhaW5lci5uZXcodGhpcy5fcm9vdCwgeyBoZWlnaHQ6IHAxMDAsIGxheW91dDogdGhpcy5fcm9vdC5ob3Jpem9udGFsTGF5b3V0IH0pKVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEEgW1tDb250YWluZXJdXSBsb2NhdGVkIGluIHRoZSBtaWRkbGUgb2YgdGhlIGNoYXJ0LCB1c2VkIHRvIHN0b3JlIHBsb3RDb250YWluZXIgYW5kIHRvcFBsb3RDb250YWluZXJcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vd3d3LmFtY2hhcnRzLmNvbS9kb2NzL3Y1L2NoYXJ0cy94eS1jaGFydC94eS1jaGFydC1jb250YWluZXJzL30gZm9yIG1vcmUgaW5mb1xyXG4gICAgICAgICAqIEBkZWZhdWx0IENvbnRhaW5lci5uZXcoKVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInBsb3RzQ29udGFpbmVyXCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IHRoaXMueUF4ZXNBbmRQbG90Q29udGFpbmVyLmNoaWxkcmVuLnB1c2goQ29udGFpbmVyLm5ldyh0aGlzLl9yb290LCB7IHdpZHRoOiBwMTAwLCBoZWlnaHQ6IHAxMDAsIG1hc2tDb250ZW50OiBmYWxzZSB9KSlcclxuICAgICAgICB9KTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBIFtbQ29udGFpbmVyXV0gbG9jYXRlZCBpbiB0aGUgbWlkZGxlIG9mIHRoZSBjaGFydCwgdXNlZCB0byBzdG9yZSBhY3R1YWxcclxuICAgICAgICAgKiBwbG90cyAoc2VyaWVzKS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIE5PVEU6IGBwbG90Q29udGFpbmVyYCB3aWxsIGF1dG9tYXRpY2FsbHkgaGF2ZSBpdHMgYGJhY2tncm91bmRgIHByZXNldC4gSWZcclxuICAgICAgICAgKiB5b3UgbmVlZCB0byBtb2RpZnkgYmFja2dyb3VuZCBvciBvdXRsaW5lIGZvciBjaGFydCdzIHBsb3QgYXJlYSwgeW91IGNhblxyXG4gICAgICAgICAqIHVzZSBgcGxvdENvbnRhaW5lci5nZXQoXCJiYWNrZ3JvdW5kXCIpYCBmb3IgdGhhdC4qXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAc2VlIHtAbGluayBodHRwczovL3d3dy5hbWNoYXJ0cy5jb20vZG9jcy92NS9jaGFydHMveHktY2hhcnQveHktY2hhcnQtY29udGFpbmVycy99IGZvciBtb3JlIGluZm9cclxuICAgICAgICAgKiBAZGVmYXVsdCBDb250YWluZXIubmV3KClcclxuICAgICAgICAgKi9cclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJwbG90Q29udGFpbmVyXCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IHRoaXMucGxvdHNDb250YWluZXIuY2hpbGRyZW4ucHVzaChDb250YWluZXIubmV3KHRoaXMuX3Jvb3QsIHsgd2lkdGg6IHAxMDAsIGhlaWdodDogcDEwMCB9KSlcclxuICAgICAgICB9KTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBIFtbQ29udGFpbmVyXV0gdXNlZCBmb3IgYW55IGVsZW1lbnRzIHRoYXQgbmVlZCB0byBiZSBkaXNwbGF5ZWQgb3ZlclxyXG4gICAgICAgICAqIHJlZ3VsYXIgYHBsb3RDb250YWluZXJgLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly93d3cuYW1jaGFydHMuY29tL2RvY3MvdjUvY2hhcnRzL3h5LWNoYXJ0L3h5LWNoYXJ0LWNvbnRhaW5lcnMvfSBmb3IgbW9yZSBpbmZvXHJcbiAgICAgICAgICogQGRlZmF1bHQgQ29udGFpbmVyLm5ldygpXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwidG9wUGxvdENvbnRhaW5lclwiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiB0aGlzLnBsb3RzQ29udGFpbmVyLmNoaWxkcmVuLnB1c2goQ29udGFpbmVyLm5ldyh0aGlzLl9yb290LCB7IHdpZHRoOiBwMTAwLCBoZWlnaHQ6IHAxMDAgfSkpXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQSBbW0NvbnRhaW5lcl1dIGF4aXMgZ3JpZCBlbGVtZW50cyBhcmUgc3RvcmVkIGluLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly93d3cuYW1jaGFydHMuY29tL2RvY3MvdjUvY2hhcnRzL3h5LWNoYXJ0L3h5LWNoYXJ0LWNvbnRhaW5lcnMvfSBmb3IgbW9yZSBpbmZvXHJcbiAgICAgICAgICogQGRlZmF1bHQgQ29udGFpbmVyLm5ldygpXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZ3JpZENvbnRhaW5lclwiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiB0aGlzLnBsb3RDb250YWluZXIuY2hpbGRyZW4ucHVzaChDb250YWluZXIubmV3KHRoaXMuX3Jvb3QsIHsgd2lkdGg6IHAxMDAsIGhlaWdodDogcDEwMCwgaXNNZWFzdXJlZDogZmFsc2UgfSkpXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQSBbW0NvbnRhaW5lcl1dIGF4aXMgYmFja2dyb3VuZCBncmlkIGVsZW1lbnRzIGFyZSBzdG9yZWQgaW4uXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAc2VlIHtAbGluayBodHRwczovL3d3dy5hbWNoYXJ0cy5jb20vZG9jcy92NS9jaGFydHMveHktY2hhcnQveHktY2hhcnQtY29udGFpbmVycy99IGZvciBtb3JlIGluZm9cclxuICAgICAgICAgKiBAZGVmYXVsdCBDb250YWluZXIubmV3KClcclxuICAgICAgICAgKi9cclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ0b3BHcmlkQ29udGFpbmVyXCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IENvbnRhaW5lci5uZXcodGhpcy5fcm9vdCwgeyB3aWR0aDogcDEwMCwgaGVpZ2h0OiBwMTAwLCBpc01lYXN1cmVkOiBmYWxzZSB9KVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEEgW1tDb250YWluZXJdXSBsb2NhdGVkIG9uIHJpZ2h0IG9mIHRoZSBjaGFydCwgdXNlZCB0byBzdG9yZSByaWdodC1oYW5kXHJcbiAgICAgICAgICogdmVydGljYWwgYXhlcy5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vd3d3LmFtY2hhcnRzLmNvbS9kb2NzL3Y1L2NoYXJ0cy94eS1jaGFydC94eS1jaGFydC1jb250YWluZXJzL30gZm9yIG1vcmUgaW5mb1xyXG4gICAgICAgICAqIEBkZWZhdWx0IENvbnRhaW5lci5uZXcoKVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInJpZ2h0QXhlc0NvbnRhaW5lclwiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiB0aGlzLnlBeGVzQW5kUGxvdENvbnRhaW5lci5jaGlsZHJlbi5wdXNoKENvbnRhaW5lci5uZXcodGhpcy5fcm9vdCwgeyBoZWlnaHQ6IHAxMDAsIGxheW91dDogdGhpcy5fcm9vdC5ob3Jpem9udGFsTGF5b3V0IH0pKVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEEgW1tDb250YWluZXJdXSBheGlzIGhlYWRlcnMgYXJlIHN0b3JlZCBpbi5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vd3d3LmFtY2hhcnRzLmNvbS9kb2NzL3Y1L2NoYXJ0cy94eS1jaGFydC9heGVzL2F4aXMtaGVhZGVycy99IGZvciBtb3JlIGluZm9cclxuICAgICAgICAgKiBAZGVmYXVsdCBDb250YWluZXIubmV3KClcclxuICAgICAgICAgKi9cclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJheGlzSGVhZGVyc0NvbnRhaW5lclwiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiB0aGlzLnBsb3RDb250YWluZXIuY2hpbGRyZW4ucHVzaChDb250YWluZXIubmV3KHRoaXMuX3Jvb3QsIHt9KSlcclxuICAgICAgICB9KTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBIGJ1dHRvbiB0aGF0IGlzIHNob3duIHdoZW4gY2hhcnQgaXMgbm90IGZ1bGx5IHpvb21lZCBvdXQuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAc2VlIHtAbGluayBodHRwczovL3d3dy5hbWNoYXJ0cy5jb20vZG9jcy92NS9jaGFydHMveHktY2hhcnQvem9vbS1hbmQtcGFuLyNab29tX291dF9idXR0b259IGZvciBtb3JlIGluZm9cclxuICAgICAgICAgKiBAZGVmYXVsdCBCdXR0b24ubmV3KClcclxuICAgICAgICAgKi9cclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ6b29tT3V0QnV0dG9uXCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IHRoaXMudG9wUGxvdENvbnRhaW5lci5jaGlsZHJlbi5wdXNoKEJ1dHRvbi5uZXcodGhpcy5fcm9vdCwge1xyXG4gICAgICAgICAgICAgICAgdGhlbWVUYWdzOiBbXCJ6b29tXCJdLFxyXG4gICAgICAgICAgICAgICAgaWNvbjogR3JhcGhpY3MubmV3KHRoaXMuX3Jvb3QsIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGVtZVRhZ3M6IFtcImJ1dHRvblwiLCBcImljb25cIl1cclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIH0pKVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9tb3ZlUG9pbnRcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogeyB4OiAwLCB5OiAwIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfd2hlZWxEcFwiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfb3RoZXJDaGFydHNcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX21vdmVQb2ludHNcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZToge31cclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfZG93blN0YXJ0WFwiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfZG93bkVuZFhcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX2Rvd25TdGFydFlcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX2Rvd25FbmRZXCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgX2FmdGVyTmV3KCkge1xyXG4gICAgICAgIHRoaXMuX2RlZmF1bHRUaGVtZXMucHVzaChYWUNoYXJ0RGVmYXVsdFRoZW1lLm5ldyh0aGlzLl9yb290KSk7XHJcbiAgICAgICAgc3VwZXIuX2FmdGVyTmV3KCk7XHJcbiAgICAgICAgdGhpcy5fZGlzcG9zZXJzLnB1c2godGhpcy54QXhlcyk7XHJcbiAgICAgICAgdGhpcy5fZGlzcG9zZXJzLnB1c2godGhpcy55QXhlcyk7XHJcbiAgICAgICAgY29uc3Qgcm9vdCA9IHRoaXMuX3Jvb3Q7XHJcbiAgICAgICAgbGV0IHZlcnRpY2FsTGF5b3V0ID0gdGhpcy5fcm9vdC52ZXJ0aWNhbExheW91dDtcclxuICAgICAgICBjb25zdCB6b29tT3V0QnV0dG9uID0gdGhpcy56b29tT3V0QnV0dG9uO1xyXG4gICAgICAgIHpvb21PdXRCdXR0b24uZXZlbnRzLm9uKFwiY2xpY2tcIiwgKCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLnpvb21PdXQoKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB6b29tT3V0QnV0dG9uLmhpZGUoMCk7XHJcbiAgICAgICAgem9vbU91dEJ1dHRvbi5zdGF0ZXMubG9va3VwKFwiZGVmYXVsdFwiKS5zZXQoXCJvcGFjaXR5XCIsIDEpO1xyXG4gICAgICAgIHRoaXMuY2hhcnRDb250YWluZXIuc2V0KFwibGF5b3V0XCIsIHZlcnRpY2FsTGF5b3V0KTtcclxuICAgICAgICBjb25zdCBwbG90Q29udGFpbmVyID0gdGhpcy5wbG90Q29udGFpbmVyO1xyXG4gICAgICAgIHBsb3RDb250YWluZXIuY2hpbGRyZW4ucHVzaCh0aGlzLnNlcmllc0NvbnRhaW5lcik7XHJcbiAgICAgICAgdGhpcy5fZGlzcG9zZXJzLnB1c2godGhpcy5fcHJvY2Vzc0F4aXModGhpcy54QXhlcywgdGhpcy5ib3R0b21BeGVzQ29udGFpbmVyKSk7XHJcbiAgICAgICAgdGhpcy5fZGlzcG9zZXJzLnB1c2godGhpcy5fcHJvY2Vzc0F4aXModGhpcy55QXhlcywgdGhpcy5sZWZ0QXhlc0NvbnRhaW5lcikpO1xyXG4gICAgICAgIHBsb3RDb250YWluZXIuY2hpbGRyZW4ucHVzaCh0aGlzLnRvcEdyaWRDb250YWluZXIpO1xyXG4gICAgICAgIHBsb3RDb250YWluZXIuY2hpbGRyZW4ucHVzaCh0aGlzLmJ1bGxldHNDb250YWluZXIpO1xyXG4gICAgICAgIC8vIFNldHRpbmcgdHJhc25wYXJlbnQgYmFja2dyb3VuZCBzbyB0aGF0IGZ1bGwgYm9keSBvZiB0aGUgcGxvdCBjb250YWluZXJcclxuICAgICAgICAvLyBpcyBpbnRlcmFjdGl2ZVxyXG4gICAgICAgIHBsb3RDb250YWluZXIuc2V0KFwiaW50ZXJhY3RpdmVcIiwgdHJ1ZSk7XHJcbiAgICAgICAgcGxvdENvbnRhaW5lci5zZXQoXCJpbnRlcmFjdGl2ZUNoaWxkcmVuXCIsIGZhbHNlKTtcclxuICAgICAgICBwbG90Q29udGFpbmVyLnNldChcImJhY2tncm91bmRcIiwgUmVjdGFuZ2xlLm5ldyhyb290LCB7XHJcbiAgICAgICAgICAgIHRoZW1lVGFnczogW1wieHlcIiwgXCJiYWNrZ3JvdW5kXCJdLFxyXG4gICAgICAgICAgICBmaWxsOiBDb2xvci5mcm9tSGV4KDB4MDAwMDAwKSxcclxuICAgICAgICAgICAgZmlsbE9wYWNpdHk6IDBcclxuICAgICAgICB9KSk7XHJcbiAgICAgICAgdGhpcy5fZGlzcG9zZXJzLnB1c2gocGxvdENvbnRhaW5lci5ldmVudHMub24oXCJwb2ludGVyZG93blwiLCAoZXZlbnQpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5faGFuZGxlUGxvdERvd24oZXZlbnQpO1xyXG4gICAgICAgIH0pKTtcclxuICAgICAgICB0aGlzLl9kaXNwb3NlcnMucHVzaChwbG90Q29udGFpbmVyLmV2ZW50cy5vbihcImdsb2JhbHBvaW50ZXJ1cFwiLCAoZXZlbnQpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5faGFuZGxlUGxvdFVwKGV2ZW50KTtcclxuICAgICAgICB9KSk7XHJcbiAgICAgICAgdGhpcy5fZGlzcG9zZXJzLnB1c2gocGxvdENvbnRhaW5lci5ldmVudHMub24oXCJnbG9iYWxwb2ludGVybW92ZVwiLCAoZXZlbnQpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5faGFuZGxlUGxvdE1vdmUoZXZlbnQpO1xyXG4gICAgICAgIH0pKTtcclxuICAgICAgICB0aGlzLl9tYXNrR3JpZCgpO1xyXG4gICAgICAgIHRoaXMuX3NldFVwVG91Y2goKTtcclxuICAgIH1cclxuICAgIF9iZWZvcmVDaGFuZ2VkKCkge1xyXG4gICAgICAgIHN1cGVyLl9iZWZvcmVDaGFuZ2VkKCk7XHJcbiAgICAgICAgaWYgKHRoaXMuaXNEaXJ0eShcInBpbmNoWm9vbVhcIikgfHwgdGhpcy5pc0RpcnR5KFwicGluY2hab29tWVwiKSB8fCB0aGlzLmdldChcInBhblhcIikgfHwgdGhpcy5nZXQoXCJwYW5ZXCIpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3NldFVwVG91Y2goKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBfc2V0VXBUb3VjaCgpIHtcclxuICAgICAgICBpZiAoIXRoaXMucGxvdENvbnRhaW5lci5fZGlzcGxheS5jYW5jZWxUb3VjaCkge1xyXG4gICAgICAgICAgICB0aGlzLnBsb3RDb250YWluZXIuX2Rpc3BsYXkuY2FuY2VsVG91Y2ggPSAodGhpcy5nZXQoXCJwaW5jaFpvb21YXCIpIHx8IHRoaXMuZ2V0KFwicGluY2hab29tWVwiKSB8fCB0aGlzLmdldChcInBhblhcIikgfHwgdGhpcy5nZXQoXCJwYW5ZXCIpKSA/IHRydWUgOiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBfbWFza0dyaWQoKSB7XHJcbiAgICAgICAgdGhpcy5ncmlkQ29udGFpbmVyLnNldChcIm1hc2tDb250ZW50XCIsIHRydWUpO1xyXG4gICAgICAgIHRoaXMudG9wR3JpZENvbnRhaW5lci5zZXQoXCJtYXNrQ29udGVudFwiLCB0cnVlKTtcclxuICAgIH1cclxuICAgIF9yZW1vdmVTZXJpZXMoc2VyaWVzKSB7XHJcbiAgICAgICAgc2VyaWVzLl91bnN0YWNrKCk7XHJcbiAgICAgICAgaWYgKHNlcmllcy5fcG9zWERwKSB7XHJcbiAgICAgICAgICAgIHNlcmllcy5fcG9zWERwLmRpc3Bvc2UoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHNlcmllcy5fcG9zWURwKSB7XHJcbiAgICAgICAgICAgIHNlcmllcy5fcG9zWURwLmRpc3Bvc2UoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgc2VyaWVzLnNldChcImJhc2VBeGlzXCIsIHVuZGVmaW5lZCk7XHJcbiAgICAgICAgY29uc3QgeEF4aXMgPSBzZXJpZXMuZ2V0KFwieEF4aXNcIik7XHJcbiAgICAgICAgaWYgKHhBeGlzKSB7XHJcbiAgICAgICAgICAgICRhcnJheS5yZW1vdmUoeEF4aXMuc2VyaWVzLCBzZXJpZXMpO1xyXG4gICAgICAgICAgICB4QXhpcy5tYXJrRGlydHlFeHRyZW1lcygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCB5QXhpcyA9IHNlcmllcy5nZXQoXCJ5QXhpc1wiKTtcclxuICAgICAgICBpZiAoeUF4aXMpIHtcclxuICAgICAgICAgICAgJGFycmF5LnJlbW92ZSh5QXhpcy5zZXJpZXMsIHNlcmllcyk7XHJcbiAgICAgICAgICAgIHlBeGlzLm1hcmtEaXJ0eUV4dHJlbWVzKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGN1cnNvciA9IHRoaXMuZ2V0KFwiY3Vyc29yXCIpO1xyXG4gICAgICAgIGlmIChjdXJzb3IpIHtcclxuICAgICAgICAgICAgY29uc3Qgc25hcFRvU2VyaWVzID0gY3Vyc29yLmdldChcInNuYXBUb1Nlcmllc1wiKTtcclxuICAgICAgICAgICAgaWYgKHNuYXBUb1Nlcmllcykge1xyXG4gICAgICAgICAgICAgICAgJGFycmF5LnJlbW92ZShzbmFwVG9TZXJpZXMsIHNlcmllcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgc3VwZXIuX3JlbW92ZVNlcmllcyhzZXJpZXMpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBpbnZva2VkIHdoZW4gbW91c2Ugd2hlZWwgaXMgdXNlZCBvdmVyIGNoYXJ0J3MgcGxvdFxyXG4gICAgICogY29udGFpbmVyLCBhbmQgaGFuZGxlcyB6b29taW5nL3Bhbi5cclxuICAgICAqXHJcbiAgICAgKiBZb3UgY2FuIGludm9rZSB0aGlzIG1ldGhvZCBtYW51YWxseSwgaWYgeW91IG5lZWQgdG8gbWltaWMgY2hhcnQncyB3aGVlbFxyXG4gICAgICogYmVoYXZpb3Igb3ZlciBvdGhlciBlbGVtZW50cyBvZiB0aGUgY2hhcnQuXHJcbiAgICAgKi9cclxuICAgIGhhbmRsZVdoZWVsKGV2ZW50KSB7XHJcbiAgICAgICAgY29uc3Qgd2hlZWxYID0gdGhpcy5nZXQoXCJ3aGVlbFhcIik7XHJcbiAgICAgICAgY29uc3Qgd2hlZWxZID0gdGhpcy5nZXQoXCJ3aGVlbFlcIik7XHJcbiAgICAgICAgY29uc3QgcGxvdENvbnRhaW5lciA9IHRoaXMucGxvdENvbnRhaW5lcjtcclxuICAgICAgICBjb25zdCB3aGVlbEV2ZW50ID0gZXZlbnQub3JpZ2luYWxFdmVudDtcclxuICAgICAgICAvLyBJZ25vcmUgd2hlZWwgZXZlbnQgaWYgaXQgaXMgaGFwcGVuaW5nIG9uIGEgbm9uLWNoYXJ0IGVsZW1lbnQsIGUuZy4gaWZcclxuICAgICAgICAvLyBzb21lIHBhZ2UgZWxlbWVudCBpcyBvdmVyIHRoZSBjaGFydC5cclxuICAgICAgICBpZiAoJHV0aWxzLmlzTG9jYWxFdmVudCh3aGVlbEV2ZW50LCB0aGlzKSkge1xyXG4gICAgICAgICAgICB3aGVlbEV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHBsb3RQb2ludCA9IHBsb3RDb250YWluZXIudG9Mb2NhbChldmVudC5wb2ludCk7XHJcbiAgICAgICAgY29uc3Qgd2hlZWxTdGVwID0gdGhpcy5nZXQoXCJ3aGVlbFN0ZXBcIiwgMC4yKTtcclxuICAgICAgICBjb25zdCBzaGlmdFkgPSB3aGVlbEV2ZW50LmRlbHRhWSAvIDEwMDtcclxuICAgICAgICBjb25zdCBzaGlmdFggPSB3aGVlbEV2ZW50LmRlbHRhWCAvIDEwMDtcclxuICAgICAgICBjb25zdCB3aGVlbFpvb21Qb3NpdGlvblggPSB0aGlzLmdldChcIndoZWVsWm9vbVBvc2l0aW9uWFwiKTtcclxuICAgICAgICBjb25zdCB3aGVlbFpvb21Qb3NpdGlvblkgPSB0aGlzLmdldChcIndoZWVsWm9vbVBvc2l0aW9uWVwiKTtcclxuICAgICAgICBpZiAoKHdoZWVsWCA9PT0gXCJ6b29tWFwiIHx8IHdoZWVsWCA9PT0gXCJ6b29tWFlcIikgJiYgc2hpZnRYICE9IDApIHtcclxuICAgICAgICAgICAgdGhpcy54QXhlcy5lYWNoKChheGlzKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoYXhpcy5nZXQoXCJ6b29tWFwiKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBzdGFydCA9IGF4aXMuZ2V0KFwic3RhcnRcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGVuZCA9IGF4aXMuZ2V0KFwiZW5kXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBwb3NpdGlvbiA9IGF4aXMuZml4UG9zaXRpb24ocGxvdFBvaW50LnggLyBwbG90Q29udGFpbmVyLndpZHRoKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh3aGVlbFpvb21Qb3NpdGlvblggIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbiA9IHdoZWVsWm9vbVBvc2l0aW9uWDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IG5ld1N0YXJ0ID0gc3RhcnQgLSB3aGVlbFN0ZXAgKiAoZW5kIC0gc3RhcnQpICogc2hpZnRYICogcG9zaXRpb247XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IG5ld0VuZCA9IGVuZCArIHdoZWVsU3RlcCAqIChlbmQgLSBzdGFydCkgKiBzaGlmdFggKiAoMSAtIHBvc2l0aW9uKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoMSAvIChuZXdFbmQgLSBuZXdTdGFydCkgPCBheGlzLmdldFByaXZhdGUoXCJtYXhab29tRmFjdG9yXCIsIEluZmluaXR5KSAvIGF4aXMuZ2V0KFwibWluWm9vbUNvdW50XCIsIDEpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2hhbmRsZVdoZWVsQW5pbWF0aW9uKGF4aXMuem9vbShuZXdTdGFydCwgbmV3RW5kKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCh3aGVlbFkgPT09IFwiem9vbVhcIiB8fCB3aGVlbFkgPT09IFwiem9vbVhZXCIpICYmIHNoaWZ0WSAhPSAwKSB7XHJcbiAgICAgICAgICAgIHRoaXMueEF4ZXMuZWFjaCgoYXhpcykgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKGF4aXMuZ2V0KFwiem9vbVhcIikpIHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgc3RhcnQgPSBheGlzLmdldChcInN0YXJ0XCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBlbmQgPSBheGlzLmdldChcImVuZFwiKTtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgcG9zaXRpb24gPSBheGlzLmZpeFBvc2l0aW9uKHBsb3RQb2ludC54IC8gcGxvdENvbnRhaW5lci53aWR0aCgpKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAod2hlZWxab29tUG9zaXRpb25YICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24gPSB3aGVlbFpvb21Qb3NpdGlvblg7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGxldCBuZXdTdGFydCA9IHN0YXJ0IC0gd2hlZWxTdGVwICogKGVuZCAtIHN0YXJ0KSAqIHNoaWZ0WSAqIHBvc2l0aW9uO1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBuZXdFbmQgPSBlbmQgKyB3aGVlbFN0ZXAgKiAoZW5kIC0gc3RhcnQpICogc2hpZnRZICogKDEgLSBwb3NpdGlvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKDEgLyAobmV3RW5kIC0gbmV3U3RhcnQpIDwgYXhpcy5nZXRQcml2YXRlKFwibWF4Wm9vbUZhY3RvclwiLCBJbmZpbml0eSkgLyBheGlzLmdldChcIm1pblpvb21Db3VudFwiLCAxKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9oYW5kbGVXaGVlbEFuaW1hdGlvbihheGlzLnpvb20obmV3U3RhcnQsIG5ld0VuZCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICgod2hlZWxYID09PSBcInpvb21ZXCIgfHwgd2hlZWxYID09PSBcInpvb21YWVwiKSAmJiBzaGlmdFggIT0gMCkge1xyXG4gICAgICAgICAgICB0aGlzLnlBeGVzLmVhY2goKGF4aXMpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChheGlzLmdldChcInpvb21ZXCIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHN0YXJ0ID0gYXhpcy5nZXQoXCJzdGFydFwiKTtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgZW5kID0gYXhpcy5nZXQoXCJlbmRcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHBvc2l0aW9uID0gYXhpcy5maXhQb3NpdGlvbihwbG90UG9pbnQueSAvIHBsb3RDb250YWluZXIuaGVpZ2h0KCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh3aGVlbFpvb21Qb3NpdGlvblkgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbiA9IHdoZWVsWm9vbVBvc2l0aW9uWTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IG5ld1N0YXJ0ID0gc3RhcnQgLSB3aGVlbFN0ZXAgKiAoZW5kIC0gc3RhcnQpICogc2hpZnRYICogcG9zaXRpb247XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IG5ld0VuZCA9IGVuZCArIHdoZWVsU3RlcCAqIChlbmQgLSBzdGFydCkgKiBzaGlmdFggKiAoMSAtIHBvc2l0aW9uKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoMSAvIChuZXdFbmQgLSBuZXdTdGFydCkgPCBheGlzLmdldFByaXZhdGUoXCJtYXhab29tRmFjdG9yXCIsIEluZmluaXR5KSAvIGF4aXMuZ2V0KFwibWluWm9vbUNvdW50XCIsIDEpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2hhbmRsZVdoZWVsQW5pbWF0aW9uKGF4aXMuem9vbShuZXdTdGFydCwgbmV3RW5kKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCh3aGVlbFkgPT09IFwiem9vbVlcIiB8fCB3aGVlbFkgPT09IFwiem9vbVhZXCIpICYmIHNoaWZ0WSAhPSAwKSB7XHJcbiAgICAgICAgICAgIHRoaXMueUF4ZXMuZWFjaCgoYXhpcykgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKGF4aXMuZ2V0KFwiem9vbVlcIikpIHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgc3RhcnQgPSBheGlzLmdldChcInN0YXJ0XCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBlbmQgPSBheGlzLmdldChcImVuZFwiKTtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgcG9zaXRpb24gPSBheGlzLmZpeFBvc2l0aW9uKHBsb3RQb2ludC55IC8gcGxvdENvbnRhaW5lci5oZWlnaHQoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHdoZWVsWm9vbVBvc2l0aW9uWSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uID0gd2hlZWxab29tUG9zaXRpb25ZO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBsZXQgbmV3U3RhcnQgPSBzdGFydCAtIHdoZWVsU3RlcCAqIChlbmQgLSBzdGFydCkgKiBzaGlmdFkgKiBwb3NpdGlvbjtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgbmV3RW5kID0gZW5kICsgd2hlZWxTdGVwICogKGVuZCAtIHN0YXJ0KSAqIHNoaWZ0WSAqICgxIC0gcG9zaXRpb24pO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICgxIC8gKG5ld0VuZCAtIG5ld1N0YXJ0KSA8IGF4aXMuZ2V0UHJpdmF0ZShcIm1heFpvb21GYWN0b3JcIiwgSW5maW5pdHkpIC8gYXhpcy5nZXQoXCJtaW5ab29tQ291bnRcIiwgMSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5faGFuZGxlV2hlZWxBbmltYXRpb24oYXhpcy56b29tKG5ld1N0YXJ0LCBuZXdFbmQpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoKHdoZWVsWCA9PT0gXCJwYW5YXCIgfHwgd2hlZWxYID09PSBcInBhblhZXCIpICYmIHNoaWZ0WCAhPSAwKSB7XHJcbiAgICAgICAgICAgIHRoaXMueEF4ZXMuZWFjaCgoYXhpcykgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKGF4aXMuZ2V0KFwicGFuWFwiKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBzdGFydCA9IGF4aXMuZ2V0KFwic3RhcnRcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGVuZCA9IGF4aXMuZ2V0KFwiZW5kXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBkZWx0YSA9IHRoaXMuX2dldFdoZWVsU2lnbihheGlzKSAqIHdoZWVsU3RlcCAqIChlbmQgLSBzdGFydCkgKiBzaGlmdFg7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IG5ld1N0YXJ0ID0gc3RhcnQgKyBkZWx0YTtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgbmV3RW5kID0gZW5kICsgZGVsdGE7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHNlID0gdGhpcy5fZml4V2hlZWwobmV3U3RhcnQsIG5ld0VuZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3U3RhcnQgPSBzZVswXTtcclxuICAgICAgICAgICAgICAgICAgICBuZXdFbmQgPSBzZVsxXTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9oYW5kbGVXaGVlbEFuaW1hdGlvbihheGlzLnpvb20obmV3U3RhcnQsIG5ld0VuZCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCh3aGVlbFkgPT09IFwicGFuWFwiIHx8IHdoZWVsWSA9PT0gXCJwYW5YWVwiKSAmJiBzaGlmdFkgIT0gMCkge1xyXG4gICAgICAgICAgICB0aGlzLnhBeGVzLmVhY2goKGF4aXMpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChheGlzLmdldChcInBhblhcIikpIHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgc3RhcnQgPSBheGlzLmdldChcInN0YXJ0XCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBlbmQgPSBheGlzLmdldChcImVuZFwiKTtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgZGVsdGEgPSB0aGlzLl9nZXRXaGVlbFNpZ24oYXhpcykgKiB3aGVlbFN0ZXAgKiAoZW5kIC0gc3RhcnQpICogc2hpZnRZO1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBuZXdTdGFydCA9IHN0YXJ0ICsgZGVsdGE7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IG5ld0VuZCA9IGVuZCArIGRlbHRhO1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBzZSA9IHRoaXMuX2ZpeFdoZWVsKG5ld1N0YXJ0LCBuZXdFbmQpO1xyXG4gICAgICAgICAgICAgICAgICAgIG5ld1N0YXJ0ID0gc2VbMF07XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3RW5kID0gc2VbMV07XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faGFuZGxlV2hlZWxBbmltYXRpb24oYXhpcy56b29tKG5ld1N0YXJ0LCBuZXdFbmQpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICgod2hlZWxYID09PSBcInBhbllcIiB8fCB3aGVlbFggPT09IFwicGFuWFlcIikgJiYgc2hpZnRYICE9IDApIHtcclxuICAgICAgICAgICAgdGhpcy55QXhlcy5lYWNoKChheGlzKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoYXhpcy5nZXQoXCJwYW5ZXCIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHN0YXJ0ID0gYXhpcy5nZXQoXCJzdGFydFwiKTtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgZW5kID0gYXhpcy5nZXQoXCJlbmRcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGRlbHRhID0gdGhpcy5fZ2V0V2hlZWxTaWduKGF4aXMpICogd2hlZWxTdGVwICogKGVuZCAtIHN0YXJ0KSAqIHNoaWZ0WDtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgbmV3U3RhcnQgPSBzdGFydCArIGRlbHRhO1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBuZXdFbmQgPSBlbmQgKyBkZWx0YTtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgc2UgPSB0aGlzLl9maXhXaGVlbChuZXdTdGFydCwgbmV3RW5kKTtcclxuICAgICAgICAgICAgICAgICAgICBuZXdTdGFydCA9IHNlWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgIG5ld0VuZCA9IHNlWzFdO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2hhbmRsZVdoZWVsQW5pbWF0aW9uKGF4aXMuem9vbShuZXdTdGFydCwgbmV3RW5kKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoKHdoZWVsWSA9PT0gXCJwYW5ZXCIgfHwgd2hlZWxZID09PSBcInBhblhZXCIpICYmIHNoaWZ0WSAhPSAwKSB7XHJcbiAgICAgICAgICAgIHRoaXMueUF4ZXMuZWFjaCgoYXhpcykgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKGF4aXMuZ2V0KFwicGFuWVwiKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBzdGFydCA9IGF4aXMuZ2V0KFwic3RhcnRcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGVuZCA9IGF4aXMuZ2V0KFwiZW5kXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBkZWx0YSA9IHRoaXMuX2dldFdoZWVsU2lnbihheGlzKSAqIHdoZWVsU3RlcCAqIChlbmQgLSBzdGFydCkgKiBzaGlmdFk7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IG5ld1N0YXJ0ID0gc3RhcnQgLSBkZWx0YTtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgbmV3RW5kID0gZW5kIC0gZGVsdGE7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHNlID0gdGhpcy5fZml4V2hlZWwobmV3U3RhcnQsIG5ld0VuZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3U3RhcnQgPSBzZVswXTtcclxuICAgICAgICAgICAgICAgICAgICBuZXdFbmQgPSBzZVsxXTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9oYW5kbGVXaGVlbEFuaW1hdGlvbihheGlzLnpvb20obmV3U3RhcnQsIG5ld0VuZCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBfaGFuZGxlU2V0V2hlZWwoKSB7XHJcbiAgICAgICAgY29uc3Qgd2hlZWxYID0gdGhpcy5nZXQoXCJ3aGVlbFhcIik7XHJcbiAgICAgICAgY29uc3Qgd2hlZWxZID0gdGhpcy5nZXQoXCJ3aGVlbFlcIik7XHJcbiAgICAgICAgY29uc3QgcGxvdENvbnRhaW5lciA9IHRoaXMucGxvdENvbnRhaW5lcjtcclxuICAgICAgICBpZiAod2hlZWxYICE9PSBcIm5vbmVcIiB8fCB3aGVlbFkgIT09IFwibm9uZVwiKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3doZWVsRHAgPSBwbG90Q29udGFpbmVyLmV2ZW50cy5vbihcIndoZWVsXCIsIChldmVudCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgd2hlZWxFdmVudCA9IGV2ZW50Lm9yaWdpbmFsRXZlbnQ7XHJcbiAgICAgICAgICAgICAgICBpZiAoKHdoZWVsWCAhPT0gXCJub25lXCIgJiYgTWF0aC5hYnMod2hlZWxFdmVudC5kZWx0YVgpICE9IDApIHx8ICh3aGVlbFkgIT09IFwibm9uZVwiICYmIE1hdGguYWJzKHdoZWVsRXZlbnQuZGVsdGFZKSAhPSAwKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlV2hlZWwoZXZlbnQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgdGhpcy5fZGlzcG9zZXJzLnB1c2godGhpcy5fd2hlZWxEcCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fd2hlZWxEcCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fd2hlZWxEcC5kaXNwb3NlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBfZ2V0V2hlZWxTaWduKGF4aXMpIHtcclxuICAgICAgICBsZXQgc2lnbiA9IDE7XHJcbiAgICAgICAgaWYgKGF4aXMuZ2V0KFwicmVuZGVyZXJcIikuZ2V0KFwiaW52ZXJzZWRcIikpIHtcclxuICAgICAgICAgICAgc2lnbiA9IC0xO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gc2lnbjtcclxuICAgIH1cclxuICAgIF9maXhXaGVlbChzdGFydCwgZW5kKSB7XHJcbiAgICAgICAgY29uc3QgZGlmZiA9IGVuZCAtIHN0YXJ0O1xyXG4gICAgICAgIGlmIChzdGFydCA8IDApIHtcclxuICAgICAgICAgICAgc3RhcnQgPSAwO1xyXG4gICAgICAgICAgICBlbmQgPSBzdGFydCArIGRpZmY7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChlbmQgPiAxKSB7XHJcbiAgICAgICAgICAgIGVuZCA9IDE7XHJcbiAgICAgICAgICAgIHN0YXJ0ID0gZW5kIC0gZGlmZjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFtzdGFydCwgZW5kXTtcclxuICAgIH1cclxuICAgIF9oYW5kbGVQbG90RG93bihldmVudCkge1xyXG4gICAgICAgIGNvbnN0IG9yaWdpbmFsRXZlbnQgPSBldmVudC5vcmlnaW5hbEV2ZW50O1xyXG4gICAgICAgIGlmIChvcmlnaW5hbEV2ZW50LmJ1dHRvbiA9PSAyKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgcGxvdENvbnRhaW5lciA9IHRoaXMucGxvdENvbnRhaW5lcjtcclxuICAgICAgICBsZXQgbG9jYWwgPSBwbG90Q29udGFpbmVyLnRvTG9jYWwoZXZlbnQucG9pbnQpO1xyXG4gICAgICAgIGlmICh0aGlzLmdldChcInBpbmNoWm9vbVhcIikgfHwgdGhpcy5nZXQoXCJwaW5jaFpvb21ZXCIpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHBvaW50ZXJJZCA9IG9yaWdpbmFsRXZlbnQucG9pbnRlcklkO1xyXG4gICAgICAgICAgICBpZiAocG9pbnRlcklkKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoJG9iamVjdC5rZXlzKHBsb3RDb250YWluZXIuX2Rvd25Qb2ludHMpLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB4QXhpcyA9IHRoaXMueEF4ZXMuZ2V0SW5kZXgoMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeUF4aXMgPSB0aGlzLnlBeGVzLmdldEluZGV4KDApO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh4QXhpcykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9kb3duU3RhcnRYID0geEF4aXMuZ2V0KFwic3RhcnRcIiwgMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2Rvd25FbmRYID0geEF4aXMuZ2V0KFwiZW5kXCIsIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoeUF4aXMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZG93blN0YXJ0WSA9IHlBeGlzLmdldChcInN0YXJ0XCIsIDApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9kb3duRW5kWSA9IHlBeGlzLmdldChcImVuZFwiLCAxKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuZ2V0KFwicGFuWFwiKSB8fCB0aGlzLmdldChcInBhbllcIikpIHtcclxuICAgICAgICAgICAgaWYgKGxvY2FsLnggPj0gMCAmJiBsb2NhbC55ID49IDAgJiYgbG9jYWwueCA8PSBwbG90Q29udGFpbmVyLndpZHRoKCkgJiYgbG9jYWwueSA8PSB0aGlzLmhlaWdodCgpKSB7XHJcbiAgICAgICAgICAgICAgICAvL3RoaXMuX2Rvd25Qb2ludCA9IGxvY2FsO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZG93blBvaW50ID0geyB4OiBvcmlnaW5hbEV2ZW50LmNsaWVudFgsIHk6IG9yaWdpbmFsRXZlbnQuY2xpZW50WSB9O1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcGFuWCA9IHRoaXMuZ2V0KFwicGFuWFwiKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHBhblkgPSB0aGlzLmdldChcInBhbllcIik7XHJcbiAgICAgICAgICAgICAgICBpZiAocGFuWCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMueEF4ZXMuZWFjaCgoYXhpcykgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBheGlzLl9wYW5TdGFydCA9IGF4aXMuZ2V0KFwic3RhcnRcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGF4aXMuX3BhbkVuZCA9IGF4aXMuZ2V0KFwiZW5kXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHBhblkpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnlBeGVzLmVhY2goKGF4aXMpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXhpcy5fcGFuU3RhcnQgPSBheGlzLmdldChcInN0YXJ0XCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBheGlzLl9wYW5FbmQgPSBheGlzLmdldChcImVuZFwiKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvbnN0IGV2ZW50VHlwZSA9IFwicGFuc3RhcnRlZFwiO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZXZlbnRzLmlzRW5hYmxlZChldmVudFR5cGUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ldmVudHMuZGlzcGF0Y2goZXZlbnRUeXBlLCB7IHR5cGU6IGV2ZW50VHlwZSwgdGFyZ2V0OiB0aGlzLCBvcmlnaW5hbEV2ZW50OiBldmVudC5vcmlnaW5hbEV2ZW50IH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgX2hhbmRsZVdoZWVsQW5pbWF0aW9uKGFuaW1hdGlvbikge1xyXG4gICAgICAgIGlmIChhbmltYXRpb24pIHtcclxuICAgICAgICAgICAgYW5pbWF0aW9uLmV2ZW50cy5vbihcInN0b3BwZWRcIiwgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZGlzcGF0Y2hXaGVlbEFuaW1hdGlvbigpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2Rpc3BhdGNoV2hlZWxBbmltYXRpb24oKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBfZGlzcGF0Y2hXaGVlbEFuaW1hdGlvbigpIHtcclxuICAgICAgICBjb25zdCBldmVudFR5cGUgPSBcIndoZWVsZW5kZWRcIjtcclxuICAgICAgICBpZiAodGhpcy5ldmVudHMuaXNFbmFibGVkKGV2ZW50VHlwZSkpIHtcclxuICAgICAgICAgICAgdGhpcy5ldmVudHMuZGlzcGF0Y2goZXZlbnRUeXBlLCB7IHR5cGU6IGV2ZW50VHlwZSwgdGFyZ2V0OiB0aGlzIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIF9oYW5kbGVQbG90VXAoZXZlbnQpIHtcclxuICAgICAgICBjb25zdCBkb3duUG9pbnQgPSB0aGlzLl9kb3duUG9pbnQ7XHJcbiAgICAgICAgaWYgKGRvd25Qb2ludCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5nZXQoXCJwYW5YXCIpIHx8IHRoaXMuZ2V0KFwicGFuWVwiKSkge1xyXG4gICAgICAgICAgICAgICAgbGV0IGxvY2FsID0gdGhpcy5wbG90Q29udGFpbmVyLnRvTG9jYWwoZXZlbnQucG9pbnQpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGxvY2FsLnggPT0gZG93blBvaW50LnggJiYgbG9jYWwueSA9PSBkb3duUG9pbnQueSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGV2ZW50VHlwZSA9IFwicGFuY2FuY2VsbGVkXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZXZlbnRzLmlzRW5hYmxlZChldmVudFR5cGUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZXZlbnRzLmRpc3BhdGNoKGV2ZW50VHlwZSwgeyB0eXBlOiBldmVudFR5cGUsIHRhcmdldDogdGhpcywgb3JpZ2luYWxFdmVudDogZXZlbnQub3JpZ2luYWxFdmVudCB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb25zdCBldmVudFR5cGUgPSBcInBhbmVuZGVkXCI7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5ldmVudHMuaXNFbmFibGVkKGV2ZW50VHlwZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmV2ZW50cy5kaXNwYXRjaChldmVudFR5cGUsIHsgdHlwZTogZXZlbnRUeXBlLCB0YXJnZXQ6IHRoaXMsIG9yaWdpbmFsRXZlbnQ6IGV2ZW50Lm9yaWdpbmFsRXZlbnQgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gVE9ETzogaGFuZGxlIG11bHRpdG91Y2hcclxuICAgICAgICB0aGlzLl9kb3duUG9pbnQgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgdGhpcy54QXhlcy5lYWNoKCh4QXhpcykgPT4ge1xyXG4gICAgICAgICAgICB4QXhpcy5faXNQYW5uaW5nID0gZmFsc2U7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy55QXhlcy5lYWNoKCh5QXhpcykgPT4ge1xyXG4gICAgICAgICAgICB5QXhpcy5faXNQYW5uaW5nID0gZmFsc2U7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBfaGFuZGxlUGxvdE1vdmUoZXZlbnQpIHtcclxuICAgICAgICBjb25zdCBwbG90Q29udGFpbmVyID0gdGhpcy5wbG90Q29udGFpbmVyO1xyXG4gICAgICAgIGlmICh0aGlzLmdldChcInBpbmNoWm9vbVhcIikgfHwgdGhpcy5nZXQoXCJwaW5jaFpvb21ZXCIpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHRvdWNoRXZlbnQgPSBldmVudC5vcmlnaW5hbEV2ZW50O1xyXG4gICAgICAgICAgICBjb25zdCBwb2ludGVySWQgPSB0b3VjaEV2ZW50LnBvaW50ZXJJZDtcclxuICAgICAgICAgICAgaWYgKHBvaW50ZXJJZCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbW92ZVBvaW50c1twb2ludGVySWRdID0gZXZlbnQucG9pbnQ7XHJcbiAgICAgICAgICAgICAgICBpZiAoJG9iamVjdC5rZXlzKHBsb3RDb250YWluZXIuX2Rvd25Qb2ludHMpLmxlbmd0aCA+IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9oYW5kbGVQaW5jaCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgZG93blBvaW50ID0gdGhpcy5fZG93blBvaW50O1xyXG4gICAgICAgIGlmIChkb3duUG9pbnQpIHtcclxuICAgICAgICAgICAgZG93blBvaW50ID0gcGxvdENvbnRhaW5lci50b0xvY2FsKHRoaXMuX3Jvb3QuZG9jdW1lbnRQb2ludFRvUm9vdChkb3duUG9pbnQpKTtcclxuICAgICAgICAgICAgbGV0IGxvY2FsID0gcGxvdENvbnRhaW5lci50b0xvY2FsKGV2ZW50LnBvaW50KTtcclxuICAgICAgICAgICAgY29uc3QgcGFuWCA9IHRoaXMuZ2V0KFwicGFuWFwiKTtcclxuICAgICAgICAgICAgY29uc3QgcGFuWSA9IHRoaXMuZ2V0KFwicGFuWVwiKTtcclxuICAgICAgICAgICAgaWYgKHBhblgpIHtcclxuICAgICAgICAgICAgICAgIGxldCBzY3JvbGxiYXJYID0gdGhpcy5nZXQoXCJzY3JvbGxiYXJYXCIpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHNjcm9sbGJhclgpIHtcclxuICAgICAgICAgICAgICAgICAgICBzY3JvbGxiYXJYLmV2ZW50cy5kaXNhYmxlVHlwZShcInJhbmdlY2hhbmdlZFwiKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMueEF4ZXMuZWFjaCgoYXhpcykgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChheGlzLmdldChcInBhblhcIikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXhpcy5faXNQYW5uaW5nID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9jb25zdCBtYXhEZXZpYXRpb24gPSBheGlzLmdldChcIm1heERldmlhdGlvblwiLCAwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHBhblN0YXJ0ID0gYXhpcy5fcGFuU3RhcnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBwYW5FbmQgPSBheGlzLl9wYW5FbmQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBkaWZmZXJlbmNlID0gKHBhbkVuZCAtIHBhblN0YXJ0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGRlbHRhWCA9IGRpZmZlcmVuY2UgKiAoZG93blBvaW50LnggLSBsb2NhbC54KSAvIHBsb3RDb250YWluZXIud2lkdGgoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGF4aXMuZ2V0KFwicmVuZGVyZXJcIikuZ2V0KFwiaW52ZXJzZWRcIikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbHRhWCAqPSAtMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgc3RhcnQgPSBwYW5TdGFydCArIGRlbHRhWDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGVuZCA9IHBhbkVuZCArIGRlbHRhWDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVuZCAtIHN0YXJ0IDwgMSArIGF4aXMuZ2V0KFwibWF4RGV2aWF0aW9uXCIsIDEpICogMikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXhpcy5zZXQoXCJzdGFydFwiLCBzdGFydCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBheGlzLnNldChcImVuZFwiLCBlbmQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoc2Nyb2xsYmFyWCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNjcm9sbGJhclguZXZlbnRzLmVuYWJsZVR5cGUoXCJyYW5nZWNoYW5nZWRcIik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHBhblkpIHtcclxuICAgICAgICAgICAgICAgIGxldCBzY3JvbGxiYXJZID0gdGhpcy5nZXQoXCJzY3JvbGxiYXJZXCIpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHNjcm9sbGJhclkpIHtcclxuICAgICAgICAgICAgICAgICAgICBzY3JvbGxiYXJZLmV2ZW50cy5kaXNhYmxlVHlwZShcInJhbmdlY2hhbmdlZFwiKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMueUF4ZXMuZWFjaCgoYXhpcykgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChheGlzLmdldChcInBhbllcIikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXhpcy5faXNQYW5uaW5nID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9jb25zdCBtYXhEZXZpYXRpb24gPSBheGlzLmdldChcIm1heERldmlhdGlvblwiLCAwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHBhblN0YXJ0ID0gYXhpcy5fcGFuU3RhcnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBwYW5FbmQgPSBheGlzLl9wYW5FbmQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBkaWZmZXJlbmNlID0gKHBhbkVuZCAtIHBhblN0YXJ0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGRlbHRhWSA9IGRpZmZlcmVuY2UgKiAoZG93blBvaW50LnkgLSBsb2NhbC55KSAvIHBsb3RDb250YWluZXIuaGVpZ2h0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChheGlzLmdldChcInJlbmRlcmVyXCIpLmdldChcImludmVyc2VkXCIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWx0YVkgKj0gLTE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHN0YXJ0ID0gcGFuU3RhcnQgLSBkZWx0YVk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBlbmQgPSBwYW5FbmQgLSBkZWx0YVk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbmQgLSBzdGFydCA8IDEgKyBheGlzLmdldChcIm1heERldmlhdGlvblwiLCAxKSAqIDIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF4aXMuc2V0KFwic3RhcnRcIiwgc3RhcnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXhpcy5zZXQoXCJlbmRcIiwgZW5kKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgaWYgKHNjcm9sbGJhclkpIHtcclxuICAgICAgICAgICAgICAgICAgICBzY3JvbGxiYXJZLmV2ZW50cy5lbmFibGVUeXBlKFwicmFuZ2VjaGFuZ2VkXCIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgX2hhbmRsZVBpbmNoKCkge1xyXG4gICAgICAgIGNvbnN0IHBsb3RDb250YWluZXIgPSB0aGlzLnBsb3RDb250YWluZXI7XHJcbiAgICAgICAgbGV0IGkgPSAwO1xyXG4gICAgICAgIGxldCBkb3duUG9pbnRzID0gW107XHJcbiAgICAgICAgbGV0IG1vdmVQb2ludHMgPSBbXTtcclxuICAgICAgICAkb2JqZWN0LmVhY2gocGxvdENvbnRhaW5lci5fZG93blBvaW50cywgKGssIHBvaW50KSA9PiB7XHJcbiAgICAgICAgICAgIGRvd25Qb2ludHNbaV0gPSBwb2ludDtcclxuICAgICAgICAgICAgbGV0IG1vdmVQb2ludCA9IHRoaXMuX21vdmVQb2ludHNba107XHJcbiAgICAgICAgICAgIGlmIChtb3ZlUG9pbnQpIHtcclxuICAgICAgICAgICAgICAgIG1vdmVQb2ludHNbaV0gPSBtb3ZlUG9pbnQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaSsrO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGlmIChkb3duUG9pbnRzLmxlbmd0aCA+IDEgJiYgbW92ZVBvaW50cy5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHcgPSBwbG90Q29udGFpbmVyLndpZHRoKCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGggPSBwbG90Q29udGFpbmVyLmhlaWdodCgpO1xyXG4gICAgICAgICAgICBsZXQgZG93blBvaW50MCA9IGRvd25Qb2ludHNbMF07XHJcbiAgICAgICAgICAgIGxldCBkb3duUG9pbnQxID0gZG93blBvaW50c1sxXTtcclxuICAgICAgICAgICAgbGV0IG1vdmVQb2ludDAgPSBtb3ZlUG9pbnRzWzBdO1xyXG4gICAgICAgICAgICBsZXQgbW92ZVBvaW50MSA9IG1vdmVQb2ludHNbMV07XHJcbiAgICAgICAgICAgIGlmIChkb3duUG9pbnQwICYmIGRvd25Qb2ludDEgJiYgbW92ZVBvaW50MCAmJiBtb3ZlUG9pbnQxKSB7XHJcbiAgICAgICAgICAgICAgICBtb3ZlUG9pbnQwID0gcGxvdENvbnRhaW5lci50b0xvY2FsKG1vdmVQb2ludDApO1xyXG4gICAgICAgICAgICAgICAgbW92ZVBvaW50MSA9IHBsb3RDb250YWluZXIudG9Mb2NhbChtb3ZlUG9pbnQxKTtcclxuICAgICAgICAgICAgICAgIGRvd25Qb2ludDAgPSBwbG90Q29udGFpbmVyLnRvTG9jYWwoZG93blBvaW50MCk7XHJcbiAgICAgICAgICAgICAgICBkb3duUG9pbnQxID0gcGxvdENvbnRhaW5lci50b0xvY2FsKGRvd25Qb2ludDEpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZ2V0KFwicGluY2hab29tWFwiKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRvd25TdGFydFggPSB0aGlzLl9kb3duU3RhcnRYO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRvd25FbmRYID0gdGhpcy5fZG93bkVuZFg7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRvd25TdGFydFggIT0gbnVsbCAmJiBkb3duRW5kWCAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkb3duUG9pbnQwLnggPiBkb3duUG9pbnQxLngpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtkb3duUG9pbnQwLCBkb3duUG9pbnQxXSA9IFtkb3duUG9pbnQxLCBkb3duUG9pbnQwXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFttb3ZlUG9pbnQwLCBtb3ZlUG9pbnQxXSA9IFttb3ZlUG9pbnQxLCBtb3ZlUG9pbnQwXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgZG93blBvczAgPSBkb3duU3RhcnRYICsgKGRvd25Qb2ludDAueCAvIHcpICogKGRvd25FbmRYIC0gZG93blN0YXJ0WCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBkb3duUG9zMSA9IGRvd25TdGFydFggKyAoZG93blBvaW50MS54IC8gdykgKiAoZG93bkVuZFggLSBkb3duU3RhcnRYKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG1vdmVQb3MwID0gZG93blN0YXJ0WCArIChtb3ZlUG9pbnQwLnggLyB3KSAqIChkb3duRW5kWCAtIGRvd25TdGFydFgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgbW92ZVBvczEgPSBkb3duU3RhcnRYICsgKG1vdmVQb2ludDEueCAvIHcpICogKGRvd25FbmRYIC0gZG93blN0YXJ0WCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBpbml0aWFsRGlzdGFuY2UgPSBNYXRoLm1heCgwLjAwMSwgZG93blBvczEgLSBkb3duUG9zMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBjdXJyZW50RGlzdGFuY2UgPSBNYXRoLm1heCgwLjAwMSwgbW92ZVBvczEgLSBtb3ZlUG9zMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBkID0gaW5pdGlhbERpc3RhbmNlIC8gY3VycmVudERpc3RhbmNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgcyA9IGRvd25TdGFydFggKiBkICsgZG93blBvczAgLSBtb3ZlUG9zMCAqIGQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBlID0gZG93bkVuZFggKiBkICsgZG93blBvczEgLSBtb3ZlUG9zMSAqIGQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMueEF4ZXMuZWFjaCgoeEF4aXMpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBzYSA9IHhBeGlzLmZpeFBvc2l0aW9uKHMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGVhID0geEF4aXMuZml4UG9zaXRpb24oZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4QXhpcy56b29tKHNhLCBlYSwgMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmdldChcInBpbmNoWm9vbVlcIikpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBkb3duU3RhcnRZID0gdGhpcy5fZG93blN0YXJ0WTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBkb3duRW5kWSA9IHRoaXMuX2Rvd25FbmRZO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChkb3duU3RhcnRZICE9IG51bGwgJiYgZG93bkVuZFkgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZG93blBvaW50MC55IDwgZG93blBvaW50MS55KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbZG93blBvaW50MCwgZG93blBvaW50MV0gPSBbZG93blBvaW50MSwgZG93blBvaW50MF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbbW92ZVBvaW50MCwgbW92ZVBvaW50MV0gPSBbbW92ZVBvaW50MSwgbW92ZVBvaW50MF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGRvd25Qb3MwID0gZG93blN0YXJ0WSArICgxIC0gZG93blBvaW50MC55IC8gaCkgKiAoZG93bkVuZFkgLSBkb3duU3RhcnRZKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGRvd25Qb3MxID0gZG93blN0YXJ0WSArICgxIC0gZG93blBvaW50MS55IC8gaCkgKiAoZG93bkVuZFkgLSBkb3duU3RhcnRZKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG1vdmVQb3MwID0gZG93blN0YXJ0WSArICgxIC0gbW92ZVBvaW50MC55IC8gaCkgKiAoZG93bkVuZFkgLSBkb3duU3RhcnRZKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG1vdmVQb3MxID0gZG93blN0YXJ0WSArICgxIC0gbW92ZVBvaW50MS55IC8gaCkgKiAoZG93bkVuZFkgLSBkb3duU3RhcnRZKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGluaXRpYWxEaXN0YW5jZSA9IE1hdGgubWF4KDAuMDAxLCBkb3duUG9zMSAtIGRvd25Qb3MwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGN1cnJlbnREaXN0YW5jZSA9IE1hdGgubWF4KDAuMDAxLCBtb3ZlUG9zMSAtIG1vdmVQb3MwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGQgPSBpbml0aWFsRGlzdGFuY2UgLyBjdXJyZW50RGlzdGFuY2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBzID0gZG93blN0YXJ0WSAqIGQgKyBkb3duUG9zMCAtIG1vdmVQb3MwICogZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGUgPSBkb3duRW5kWSAqIGQgKyBkb3duUG9zMSAtIG1vdmVQb3MxICogZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy55QXhlcy5lYWNoKCh5QXhpcykgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHNhID0geUF4aXMuZml4UG9zaXRpb24ocyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgZWEgPSB5QXhpcy5maXhQb3NpdGlvbihlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHlBeGlzLnpvb20oc2EsIGVhLCAwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgX2hhbmRsZUN1cnNvclBvc2l0aW9uKCkge1xyXG4gICAgICAgIGNvbnN0IGN1cnNvciA9IHRoaXMuZ2V0KFwiY3Vyc29yXCIpO1xyXG4gICAgICAgIGlmIChjdXJzb3IpIHtcclxuICAgICAgICAgICAgY29uc3QgY3Vyc29yUG9pbnQgPSBjdXJzb3IuZ2V0UHJpdmF0ZShcInBvaW50XCIpO1xyXG4gICAgICAgICAgICBsZXQgc25hcFRvU2VyaWVzID0gY3Vyc29yLmdldChcInNuYXBUb1Nlcmllc1wiKTtcclxuICAgICAgICAgICAgaWYgKGN1cnNvci5fZG93blBvaW50KSB7XHJcbiAgICAgICAgICAgICAgICBzbmFwVG9TZXJpZXMgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHNuYXBUb1NlcmllcyAmJiBjdXJzb3JQb2ludCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc25hcFRvU2VyaWVzQnkgPSBjdXJzb3IuZ2V0KFwic25hcFRvU2VyaWVzQnlcIik7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBkYXRhSXRlbXMgPSBbXTtcclxuICAgICAgICAgICAgICAgICRhcnJheS5lYWNoKHNuYXBUb1NlcmllcywgKHNlcmllcykgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghc2VyaWVzLmlzSGlkZGVuKCkgJiYgIXNlcmllcy5pc0hpZGluZygpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzbmFwVG9TZXJpZXNCeSAhPSBcInghXCIgJiYgc25hcFRvU2VyaWVzQnkgIT0gXCJ5IVwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzdGFydEluZGV4ID0gc2VyaWVzLnN0YXJ0SW5kZXgoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGVuZEluZGV4ID0gc2VyaWVzLmVuZEluZGV4KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gc3RhcnRJbmRleDsgaSA8IGVuZEluZGV4OyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkYXRhSXRlbSA9IHNlcmllcy5kYXRhSXRlbXNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGFJdGVtICYmICFkYXRhSXRlbS5pc0hpZGRlbigpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFJdGVtcy5wdXNoKGRhdGFJdGVtKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0b29sdGlwRGF0YUl0ZW0gPSBzZXJpZXMuZ2V0KFwidG9vbHRpcERhdGFJdGVtXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRvb2x0aXBEYXRhSXRlbSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFJdGVtcy5wdXNoKHRvb2x0aXBEYXRhSXRlbSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIGxldCBtaW5EaXN0YW5jZSA9IEluZmluaXR5O1xyXG4gICAgICAgICAgICAgICAgbGV0IGNsb3Nlc3RJdGVtO1xyXG4gICAgICAgICAgICAgICAgJGFycmF5LmVhY2goZGF0YUl0ZW1zLCAoZGF0YUl0ZW0pID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBwb2ludCA9IGRhdGFJdGVtLmdldChcInBvaW50XCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChwb2ludCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgZGlzdGFuY2UgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc25hcFRvU2VyaWVzQnkgPT0gXCJ4XCIgfHwgc25hcFRvU2VyaWVzQnkgPT0gXCJ4IVwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXN0YW5jZSA9IE1hdGguYWJzKGN1cnNvclBvaW50LnggLSBwb2ludC54KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChzbmFwVG9TZXJpZXNCeSA9PSBcInlcIiB8fCBzbmFwVG9TZXJpZXNCeSA9PSBcInkhXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc3RhbmNlID0gTWF0aC5hYnMoY3Vyc29yUG9pbnQueSAtIHBvaW50LnkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzdGFuY2UgPSBNYXRoLmh5cG90KGN1cnNvclBvaW50LnggLSBwb2ludC54LCBjdXJzb3JQb2ludC55IC0gcG9pbnQueSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRpc3RhbmNlIDwgbWluRGlzdGFuY2UpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pbkRpc3RhbmNlID0gZGlzdGFuY2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbG9zZXN0SXRlbSA9IGRhdGFJdGVtO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAkYXJyYXkuZWFjaChzbmFwVG9TZXJpZXMsIChzZXJpZXMpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB0b29sdGlwID0gc2VyaWVzLmdldChcInRvb2x0aXBcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRvb2x0aXApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdG9vbHRpcC5fc2V0RGF0YUl0ZW0odW5kZWZpbmVkKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIGlmIChjbG9zZXN0SXRlbSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBzZXJpZXMgPSBjbG9zZXN0SXRlbS5jb21wb25lbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VyaWVzLnNob3dEYXRhSXRlbVRvb2x0aXAoY2xvc2VzdEl0ZW0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBvaW50ID0gY2xvc2VzdEl0ZW0uZ2V0KFwicG9pbnRcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvaW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlbW92aW5nIHggYW5kIHkgdG8gc29sdmUgIzcyMjI1XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnNvci5oYW5kbGVNb3ZlKHNlcmllcy50b0dsb2JhbCh7IHg6IHBvaW50LnggLSBzZXJpZXMueCgpLCB5OiBwb2ludC55IC0gc2VyaWVzLnkoKSB9KSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgX3VwZGF0ZUN1cnNvcigpIHtcclxuICAgICAgICBsZXQgY3Vyc29yID0gdGhpcy5nZXQoXCJjdXJzb3JcIik7XHJcbiAgICAgICAgaWYgKGN1cnNvcikge1xyXG4gICAgICAgICAgICBjdXJzb3IudXBkYXRlQ3Vyc29yKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgX2FkZEN1cnNvcihjdXJzb3IpIHtcclxuICAgICAgICB0aGlzLnBsb3RDb250YWluZXIuY2hpbGRyZW4ucHVzaChjdXJzb3IpO1xyXG4gICAgfVxyXG4gICAgX3ByZXBhcmVDaGlsZHJlbigpIHtcclxuICAgICAgICBzdXBlci5fcHJlcGFyZUNoaWxkcmVuKCk7XHJcbiAgICAgICAgdGhpcy5zZXJpZXMuZWFjaCgoc2VyaWVzKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuX2NvbG9yaXplKHNlcmllcyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKHRoaXMuaXNEaXJ0eShcIndoZWVsWFwiKSB8fCB0aGlzLmlzRGlydHkoXCJ3aGVlbFlcIikpIHtcclxuICAgICAgICAgICAgdGhpcy5faGFuZGxlU2V0V2hlZWwoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuaXNEaXJ0eShcImN1cnNvclwiKSkge1xyXG4gICAgICAgICAgICBjb25zdCBwcmV2aW91cyA9IHRoaXMuX3ByZXZTZXR0aW5ncy5jdXJzb3I7XHJcbiAgICAgICAgICAgIGNvbnN0IGN1cnNvciA9IHRoaXMuZ2V0KFwiY3Vyc29yXCIpO1xyXG4gICAgICAgICAgICBpZiAoY3Vyc29yICE9PSBwcmV2aW91cykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZGlzcG9zZVByb3BlcnR5KFwiY3Vyc29yXCIpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHByZXZpb3VzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJldmlvdXMuZGlzcG9zZSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGN1cnNvcikge1xyXG4gICAgICAgICAgICAgICAgICAgIGN1cnNvci5fc2V0Q2hhcnQodGhpcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYWRkQ3Vyc29yKGN1cnNvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcHVzaFByb3BlcnR5RGlzcG9zZXIoXCJjdXJzb3JcIiwgY3Vyc29yLmV2ZW50cy5vbihcInNlbGVjdGVuZGVkXCIsICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5faGFuZGxlQ3Vyc29yU2VsZWN0RW5kKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy90aGlzLnNldFJhdyhcImN1cnNvclwiLCBjdXJzb3IpIC8vIHRvIHJlc2V0IHByZXZpb3VzIHZhbHVlXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9wcmV2U2V0dGluZ3MuY3Vyc29yID0gY3Vyc29yO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmlzRGlydHkoXCJzY3JvbGxiYXJYXCIpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHByZXZpb3VzID0gdGhpcy5fcHJldlNldHRpbmdzLnNjcm9sbGJhclg7XHJcbiAgICAgICAgICAgIGNvbnN0IHNjcm9sbGJhclggPSB0aGlzLmdldChcInNjcm9sbGJhclhcIik7XHJcbiAgICAgICAgICAgIGlmIChzY3JvbGxiYXJYICE9PSBwcmV2aW91cykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZGlzcG9zZVByb3BlcnR5KFwic2Nyb2xsYmFyWFwiKTtcclxuICAgICAgICAgICAgICAgIGlmIChwcmV2aW91cykge1xyXG4gICAgICAgICAgICAgICAgICAgIHByZXZpb3VzLmRpc3Bvc2UoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChzY3JvbGxiYXJYKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzY3JvbGxiYXJYLnBhcmVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRvcEF4ZXNDb250YWluZXIuY2hpbGRyZW4ucHVzaChzY3JvbGxiYXJYKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcHVzaFByb3BlcnR5RGlzcG9zZXIoXCJzY3JvbGxiYXJYXCIsIHNjcm9sbGJhclguZXZlbnRzLm9uKFwicmFuZ2VjaGFuZ2VkXCIsIChlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2hhbmRsZVNjcm9sbGJhcih0aGlzLnhBeGVzLCBlLnN0YXJ0LCBlLmVuZCwgZS5ncmlwKTtcclxuICAgICAgICAgICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVXNlZCB0byBwb3B1bGF0ZSBgYXJpYUxhYmVsYCB3aXRoIG1lYW5pbmdmdWwgdmFsdWVzXHJcbiAgICAgICAgICAgICAgICAgICAgc2Nyb2xsYmFyWC5zZXRQcml2YXRlKFwicG9zaXRpb25UZXh0RnVuY3Rpb25cIiwgKHBvc2l0aW9uKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGF4aXMgPSB0aGlzLnhBeGVzLmdldEluZGV4KDApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXhpcyA/IGF4aXMuZ2V0VG9vbHRpcFRleHQocG9zaXRpb24sIGZhbHNlKSB8fCBcIlwiIDogXCJcIjtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuX3ByZXZTZXR0aW5ncy5zY3JvbGxiYXJYID0gc2Nyb2xsYmFyWDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5pc0RpcnR5KFwic2Nyb2xsYmFyWVwiKSkge1xyXG4gICAgICAgICAgICBjb25zdCBwcmV2aW91cyA9IHRoaXMuX3ByZXZTZXR0aW5ncy5zY3JvbGxiYXJZO1xyXG4gICAgICAgICAgICBjb25zdCBzY3JvbGxiYXJZID0gdGhpcy5nZXQoXCJzY3JvbGxiYXJZXCIpO1xyXG4gICAgICAgICAgICBpZiAoc2Nyb2xsYmFyWSAhPT0gcHJldmlvdXMpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2Rpc3Bvc2VQcm9wZXJ0eShcInNjcm9sbGJhcllcIik7XHJcbiAgICAgICAgICAgICAgICBpZiAocHJldmlvdXMpIHtcclxuICAgICAgICAgICAgICAgICAgICBwcmV2aW91cy5kaXNwb3NlKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoc2Nyb2xsYmFyWSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghc2Nyb2xsYmFyWS5wYXJlbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yaWdodEF4ZXNDb250YWluZXIuY2hpbGRyZW4ucHVzaChzY3JvbGxiYXJZKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcHVzaFByb3BlcnR5RGlzcG9zZXIoXCJzY3JvbGxiYXJZXCIsIHNjcm9sbGJhclkuZXZlbnRzLm9uKFwicmFuZ2VjaGFuZ2VkXCIsIChlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2hhbmRsZVNjcm9sbGJhcih0aGlzLnlBeGVzLCBlLnN0YXJ0LCBlLmVuZCwgZS5ncmlwKTtcclxuICAgICAgICAgICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVXNlZCB0byBwb3B1bGF0ZSBgYXJpYUxhYmVsYCB3aXRoIG1lYW5pbmdmdWwgdmFsdWVzXHJcbiAgICAgICAgICAgICAgICAgICAgc2Nyb2xsYmFyWS5zZXRQcml2YXRlKFwicG9zaXRpb25UZXh0RnVuY3Rpb25cIiwgKHBvc2l0aW9uKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGF4aXMgPSB0aGlzLnlBeGVzLmdldEluZGV4KDApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXhpcyA/IGF4aXMuZ2V0VG9vbHRpcFRleHQocG9zaXRpb24sIGZhbHNlKSB8fCBcIlwiIDogXCJcIjtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuX3ByZXZTZXR0aW5ncy5zY3JvbGxiYXJZID0gc2Nyb2xsYmFyWTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9oYW5kbGVab29tT3V0KCk7XHJcbiAgICB9XHJcbiAgICBfcHJvY2Vzc1NlcmllcyhzZXJpZXMpIHtcclxuICAgICAgICBzdXBlci5fcHJvY2Vzc1NlcmllcyhzZXJpZXMpO1xyXG4gICAgICAgIGNvbnN0IHhBeGlzID0gc2VyaWVzLmdldChcInhBeGlzXCIpO1xyXG4gICAgICAgIGNvbnN0IHlBeGlzID0gc2VyaWVzLmdldChcInlBeGlzXCIpO1xyXG4gICAgICAgICRhcnJheS5tb3ZlKHhBeGlzLnNlcmllcywgc2VyaWVzKTtcclxuICAgICAgICAkYXJyYXkubW92ZSh5QXhpcy5zZXJpZXMsIHNlcmllcyk7XHJcbiAgICAgICAgc2VyaWVzLl9wb3NYRHAgPSBzZXJpZXMuYWRkRGlzcG9zZXIoeEF4aXMuZXZlbnRzLm9uKFwicG9zaXRpb25jaGFuZ2VkXCIsICgpID0+IHtcclxuICAgICAgICAgICAgc2VyaWVzLl9maXhQb3NpdGlvbigpO1xyXG4gICAgICAgIH0pKTtcclxuICAgICAgICBzZXJpZXMuX3Bvc1hEcCA9IHNlcmllcy5hZGREaXNwb3Nlcih5QXhpcy5ldmVudHMub24oXCJwb3NpdGlvbmNoYW5nZWRcIiwgKCkgPT4ge1xyXG4gICAgICAgICAgICBzZXJpZXMuX2ZpeFBvc2l0aW9uKCk7XHJcbiAgICAgICAgfSkpO1xyXG4gICAgICAgIGlmICghc2VyaWVzLmdldChcImJhc2VBeGlzXCIpKSB7XHJcbiAgICAgICAgICAgIGlmICh5QXhpcy5pc1R5cGUoXCJDYXRlZ29yeUF4aXNcIikgfHwgeUF4aXMuaXNUeXBlKFwiRGF0ZUF4aXNcIikpIHtcclxuICAgICAgICAgICAgICAgIHNlcmllcy5zZXQoXCJiYXNlQXhpc1wiLCB5QXhpcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBzZXJpZXMuc2V0KFwiYmFzZUF4aXNcIiwgeEF4aXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzZXJpZXMuZ2V0KFwic3RhY2tlZFwiKSkge1xyXG4gICAgICAgICAgICBzZXJpZXMuX21hcmtEaXJ0eUtleShcInN0YWNrZWRcIik7XHJcbiAgICAgICAgICAgICRhcnJheS5lYWNoKHNlcmllcy5kYXRhSXRlbXMsIChkYXRhSXRlbSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgZGF0YUl0ZW0uc2V0KFwic3RhY2tUb0l0ZW1ZXCIsIHVuZGVmaW5lZCk7XHJcbiAgICAgICAgICAgICAgICBkYXRhSXRlbS5zZXQoXCJzdGFja1RvSXRlbVhcIiwgdW5kZWZpbmVkKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHNlcmllcy5fbWFya0RpcnR5QXhlcygpO1xyXG4gICAgICAgIHlBeGlzLm1hcmtEaXJ0eUV4dHJlbWVzKCk7XHJcbiAgICAgICAgeEF4aXMubWFya0RpcnR5RXh0cmVtZXMoKTtcclxuICAgICAgICB0aGlzLl9jb2xvcml6ZShzZXJpZXMpO1xyXG4gICAgfVxyXG4gICAgX2NvbG9yaXplKHNlcmllcykge1xyXG4gICAgICAgIGNvbnN0IGNvbG9yU2V0ID0gdGhpcy5nZXQoXCJjb2xvcnNcIik7XHJcbiAgICAgICAgaWYgKGNvbG9yU2V0KSB7XHJcbiAgICAgICAgICAgIGlmIChzZXJpZXMuZ2V0KFwiZmlsbFwiKSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjb2xvciA9IGNvbG9yU2V0Lm5leHQoKTtcclxuICAgICAgICAgICAgICAgIHNlcmllcy5fc2V0U29mdChcInN0cm9rZVwiLCBjb2xvcik7XHJcbiAgICAgICAgICAgICAgICBzZXJpZXMuX3NldFNvZnQoXCJmaWxsXCIsIGNvbG9yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIF9oYW5kbGVDdXJzb3JTZWxlY3RFbmQoKSB7XHJcbiAgICAgICAgY29uc3QgY3Vyc29yID0gdGhpcy5nZXQoXCJjdXJzb3JcIik7XHJcbiAgICAgICAgY29uc3QgYmVoYXZpb3IgPSBjdXJzb3IuZ2V0KFwiYmVoYXZpb3JcIik7XHJcbiAgICAgICAgY29uc3QgZG93blBvc2l0aW9uWCA9IGN1cnNvci5nZXRQcml2YXRlKFwiZG93blBvc2l0aW9uWFwiLCAwKTtcclxuICAgICAgICBjb25zdCBkb3duUG9zaXRpb25ZID0gY3Vyc29yLmdldFByaXZhdGUoXCJkb3duUG9zaXRpb25ZXCIsIDApO1xyXG4gICAgICAgIGNvbnN0IHBvc2l0aW9uWCA9IE1hdGgubWluKDEsIE1hdGgubWF4KDAsIGN1cnNvci5nZXRQcml2YXRlKFwicG9zaXRpb25YXCIsIDAuNSkpKTtcclxuICAgICAgICBjb25zdCBwb3NpdGlvblkgPSBNYXRoLm1pbigxLCBNYXRoLm1heCgwLCBjdXJzb3IuZ2V0UHJpdmF0ZShcInBvc2l0aW9uWVwiLCAwLjUpKSk7XHJcbiAgICAgICAgdGhpcy54QXhlcy5lYWNoKChheGlzKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChiZWhhdmlvciA9PT0gXCJ6b29tWFwiIHx8IGJlaGF2aW9yID09PSBcInpvb21YWVwiKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgcG9zaXRpb24wID0gYXhpcy50b0F4aXNQb3NpdGlvbihkb3duUG9zaXRpb25YKTtcclxuICAgICAgICAgICAgICAgIGxldCBwb3NpdGlvbjEgPSBheGlzLnRvQXhpc1Bvc2l0aW9uKHBvc2l0aW9uWCk7XHJcbiAgICAgICAgICAgICAgICBheGlzLnpvb20ocG9zaXRpb24wLCBwb3NpdGlvbjEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGF4aXMuc2V0UHJpdmF0ZShcInVwZGF0ZVNjcm9sbGJhclwiLCB0cnVlKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLnlBeGVzLmVhY2goKGF4aXMpID0+IHtcclxuICAgICAgICAgICAgaWYgKGJlaGF2aW9yID09PSBcInpvb21ZXCIgfHwgYmVoYXZpb3IgPT09IFwiem9vbVhZXCIpIHtcclxuICAgICAgICAgICAgICAgIGxldCBwb3NpdGlvbjAgPSBheGlzLnRvQXhpc1Bvc2l0aW9uKGRvd25Qb3NpdGlvblkpO1xyXG4gICAgICAgICAgICAgICAgbGV0IHBvc2l0aW9uMSA9IGF4aXMudG9BeGlzUG9zaXRpb24ocG9zaXRpb25ZKTtcclxuICAgICAgICAgICAgICAgIGF4aXMuem9vbShwb3NpdGlvbjAsIHBvc2l0aW9uMSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYXhpcy5zZXRQcml2YXRlKFwidXBkYXRlU2Nyb2xsYmFyXCIsIHRydWUpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgX2hhbmRsZVNjcm9sbGJhcihheGVzLCBzdGFydCwgZW5kLCBwcmlvcml0eSkge1xyXG4gICAgICAgIGF4ZXMuZWFjaCgoYXhpcykgPT4ge1xyXG4gICAgICAgICAgICBsZXQgYXhpc1N0YXJ0ID0gYXhpcy5maXhQb3NpdGlvbihzdGFydCk7XHJcbiAgICAgICAgICAgIGxldCBheGlzRW5kID0gYXhpcy5maXhQb3NpdGlvbihlbmQpO1xyXG4gICAgICAgICAgICBsZXQgem9vbUFuaW1hdGlvbiA9IGF4aXMuem9vbShheGlzU3RhcnQsIGF4aXNFbmQsIHVuZGVmaW5lZCwgcHJpb3JpdHkpO1xyXG4gICAgICAgICAgICBjb25zdCB1cGRhdGVTY3JvbGxiYXIgPSBcInVwZGF0ZVNjcm9sbGJhclwiO1xyXG4gICAgICAgICAgICBheGlzLnNldFByaXZhdGVSYXcodXBkYXRlU2Nyb2xsYmFyLCBmYWxzZSk7XHJcbiAgICAgICAgICAgIGlmICh6b29tQW5pbWF0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICB6b29tQW5pbWF0aW9uLmV2ZW50cy5vbihcInN0b3BwZWRcIiwgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGF4aXMuc2V0UHJpdmF0ZVJhdyh1cGRhdGVTY3JvbGxiYXIsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBheGlzLnNldFByaXZhdGVSYXcodXBkYXRlU2Nyb2xsYmFyLCB0cnVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgX3Byb2Nlc3NBeGlzKGF4ZXMsIGNvbnRhaW5lcikge1xyXG4gICAgICAgIHJldHVybiBheGVzLmV2ZW50cy5vbkFsbCgoY2hhbmdlKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChjaGFuZ2UudHlwZSA9PT0gXCJjbGVhclwiKSB7XHJcbiAgICAgICAgICAgICAgICAkYXJyYXkuZWFjaChjaGFuZ2Uub2xkVmFsdWVzLCAoYXhpcykgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlbW92ZUF4aXMoYXhpcyk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChjaGFuZ2UudHlwZSA9PT0gXCJwdXNoXCIpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRhaW5lci5jaGlsZHJlbi5wdXNoKGNoYW5nZS5uZXdWYWx1ZSk7XHJcbiAgICAgICAgICAgICAgICBjaGFuZ2UubmV3VmFsdWUucHJvY2Vzc0NoYXJ0KHRoaXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGNoYW5nZS50eXBlID09PSBcInNldEluZGV4XCIpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRhaW5lci5jaGlsZHJlbi5zZXRJbmRleChjaGFuZ2UuaW5kZXgsIGNoYW5nZS5uZXdWYWx1ZSk7XHJcbiAgICAgICAgICAgICAgICBjaGFuZ2UubmV3VmFsdWUucHJvY2Vzc0NoYXJ0KHRoaXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGNoYW5nZS50eXBlID09PSBcImluc2VydEluZGV4XCIpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRhaW5lci5jaGlsZHJlbi5pbnNlcnRJbmRleChjaGFuZ2UuaW5kZXgsIGNoYW5nZS5uZXdWYWx1ZSk7XHJcbiAgICAgICAgICAgICAgICBjaGFuZ2UubmV3VmFsdWUucHJvY2Vzc0NoYXJ0KHRoaXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGNoYW5nZS50eXBlID09PSBcInJlbW92ZUluZGV4XCIpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3JlbW92ZUF4aXMoY2hhbmdlLm9sZFZhbHVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChjaGFuZ2UudHlwZSA9PT0gXCJtb3ZlSW5kZXhcIikge1xyXG4gICAgICAgICAgICAgICAgY29udGFpbmVyLmNoaWxkcmVuLm1vdmVWYWx1ZShjaGFuZ2UudmFsdWUsIGNoYW5nZS5uZXdJbmRleCk7XHJcbiAgICAgICAgICAgICAgICBjaGFuZ2UudmFsdWUucHJvY2Vzc0NoYXJ0KHRoaXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBJTGlzdEV2ZW50IHR5cGVcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIF9yZW1vdmVBeGlzKGF4aXMpIHtcclxuICAgICAgICBpZiAoIWF4aXMuaXNEaXNwb3NlZCgpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGF4aXNQYXJlbnQgPSBheGlzLnBhcmVudDtcclxuICAgICAgICAgICAgaWYgKGF4aXNQYXJlbnQpIHtcclxuICAgICAgICAgICAgICAgIGF4aXNQYXJlbnQuY2hpbGRyZW4ucmVtb3ZlVmFsdWUoYXhpcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgZ3JpZENvbnRhaW5lciA9IGF4aXMuZ3JpZENvbnRhaW5lcjtcclxuICAgICAgICAgICAgY29uc3QgZ3JpZFBhcmVudCA9IGdyaWRDb250YWluZXIucGFyZW50O1xyXG4gICAgICAgICAgICBpZiAoZ3JpZFBhcmVudCkge1xyXG4gICAgICAgICAgICAgICAgZ3JpZFBhcmVudC5jaGlsZHJlbi5yZW1vdmVWYWx1ZShncmlkQ29udGFpbmVyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCB0b3BHcmlkQ29udGFpbmVyID0gYXhpcy50b3BHcmlkQ29udGFpbmVyO1xyXG4gICAgICAgICAgICBjb25zdCB0b3BHcmlkUGFyZW50ID0gdG9wR3JpZENvbnRhaW5lci5wYXJlbnQ7XHJcbiAgICAgICAgICAgIGlmICh0b3BHcmlkUGFyZW50KSB7XHJcbiAgICAgICAgICAgICAgICB0b3BHcmlkUGFyZW50LmNoaWxkcmVuLnJlbW92ZVZhbHVlKHRvcEdyaWRDb250YWluZXIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgX3VwZGF0ZUNoYXJ0TGF5b3V0KCkge1xyXG4gICAgICAgIGNvbnN0IGxlZnQgPSB0aGlzLmxlZnRBeGVzQ29udGFpbmVyLndpZHRoKCk7XHJcbiAgICAgICAgY29uc3QgcmlnaHQgPSB0aGlzLnJpZ2h0QXhlc0NvbnRhaW5lci53aWR0aCgpO1xyXG4gICAgICAgIGNvbnN0IGJvdHRvbUF4ZXNDb250YWluZXIgPSB0aGlzLmJvdHRvbUF4ZXNDb250YWluZXI7XHJcbiAgICAgICAgYm90dG9tQXhlc0NvbnRhaW5lci5zZXQoXCJwYWRkaW5nTGVmdFwiLCBsZWZ0KTtcclxuICAgICAgICBib3R0b21BeGVzQ29udGFpbmVyLnNldChcInBhZGRpbmdSaWdodFwiLCByaWdodCk7XHJcbiAgICAgICAgY29uc3QgdG9wQXhlc0NvbnRhaW5lciA9IHRoaXMudG9wQXhlc0NvbnRhaW5lcjtcclxuICAgICAgICB0b3BBeGVzQ29udGFpbmVyLnNldChcInBhZGRpbmdMZWZ0XCIsIGxlZnQpO1xyXG4gICAgICAgIHRvcEF4ZXNDb250YWluZXIuc2V0KFwicGFkZGluZ1JpZ2h0XCIsIHJpZ2h0KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQGlnbm9yZVxyXG4gICAgICovXHJcbiAgICBwcm9jZXNzQXhpcyhheGlzKSB7XHJcbiAgICAgICAgdmFyIGN1cnNvciA9IHRoaXMuZ2V0KFwiY3Vyc29yXCIpO1xyXG4gICAgICAgIGlmIChjdXJzb3IpIHtcclxuICAgICAgICAgICAgdGhpcy5hZGREaXNwb3NlcihheGlzLm9uKFwic3RhcnRcIiwgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRlQ3Vyc29yKCk7XHJcbiAgICAgICAgICAgIH0pKTtcclxuICAgICAgICAgICAgdGhpcy5hZGREaXNwb3NlcihheGlzLm9uKFwiZW5kXCIsICgpID0+IHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3VwZGF0ZUN1cnNvcigpO1xyXG4gICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgX2hhbmRsZUF4aXNTZWxlY3Rpb24oYXhpcywgZm9yY2UpIHtcclxuICAgICAgICBsZXQgc3RhcnQgPSBheGlzLmZpeFBvc2l0aW9uKGF4aXMuZ2V0KFwic3RhcnRcIiwgMCkpO1xyXG4gICAgICAgIGxldCBlbmQgPSBheGlzLmZpeFBvc2l0aW9uKGF4aXMuZ2V0KFwiZW5kXCIsIDEpKTtcclxuICAgICAgICBpZiAoc3RhcnQgPiBlbmQpIHtcclxuICAgICAgICAgICAgW3N0YXJ0LCBlbmRdID0gW2VuZCwgc3RhcnRdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy54QXhlcy5pbmRleE9mKGF4aXMpICE9IC0xKSB7XHJcbiAgICAgICAgICAgIGlmIChmb3JjZSB8fCBheGlzLmdldFByaXZhdGUoXCJ1cGRhdGVTY3JvbGxiYXJcIikpIHtcclxuICAgICAgICAgICAgICAgIGxldCBzY3JvbGxiYXJYID0gdGhpcy5nZXQoXCJzY3JvbGxiYXJYXCIpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHNjcm9sbGJhclggJiYgKCFzY3JvbGxiYXJYLmdldFByaXZhdGUoXCJpc0J1c3lcIikgfHwgZm9yY2UpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2Nyb2xsYmFyWC5zZXRSYXcoXCJzdGFydFwiLCBzdGFydCk7XHJcbiAgICAgICAgICAgICAgICAgICAgc2Nyb2xsYmFyWC5zZXRSYXcoXCJlbmRcIiwgZW5kKTtcclxuICAgICAgICAgICAgICAgICAgICBzY3JvbGxiYXJYLnVwZGF0ZUdyaXBzKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodGhpcy55QXhlcy5pbmRleE9mKGF4aXMpICE9IC0xKSB7XHJcbiAgICAgICAgICAgIGlmIChmb3JjZSB8fCBheGlzLmdldFByaXZhdGUoXCJ1cGRhdGVTY3JvbGxiYXJcIikpIHtcclxuICAgICAgICAgICAgICAgIGxldCBzY3JvbGxiYXJZID0gdGhpcy5nZXQoXCJzY3JvbGxiYXJZXCIpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHNjcm9sbGJhclkgJiYgKCFzY3JvbGxiYXJZLmdldFByaXZhdGUoXCJpc0J1c3lcIikgfHwgZm9yY2UpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2Nyb2xsYmFyWS5zZXRSYXcoXCJzdGFydFwiLCBzdGFydCk7XHJcbiAgICAgICAgICAgICAgICAgICAgc2Nyb2xsYmFyWS5zZXRSYXcoXCJlbmRcIiwgZW5kKTtcclxuICAgICAgICAgICAgICAgICAgICBzY3JvbGxiYXJZLnVwZGF0ZUdyaXBzKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5faGFuZGxlWm9vbU91dCgpO1xyXG4gICAgfVxyXG4gICAgX2hhbmRsZVpvb21PdXQoKSB7XHJcbiAgICAgICAgbGV0IHpvb21PdXRCdXR0b24gPSB0aGlzLnpvb21PdXRCdXR0b247XHJcbiAgICAgICAgaWYgKHpvb21PdXRCdXR0b24gJiYgem9vbU91dEJ1dHRvbi5wYXJlbnQpIHtcclxuICAgICAgICAgICAgbGV0IHZpc2libGUgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy54QXhlcy5lYWNoKChheGlzKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoYXhpcy5nZXQoXCJzdGFydFwiKSAhPSAwIHx8IGF4aXMuZ2V0KFwiZW5kXCIpICE9IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICB2aXNpYmxlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHRoaXMueUF4ZXMuZWFjaCgoYXhpcykgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKGF4aXMuZ2V0KFwic3RhcnRcIikgIT0gMCB8fCBheGlzLmdldChcImVuZFwiKSAhPSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmlzaWJsZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBpZiAodmlzaWJsZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHpvb21PdXRCdXR0b24uaXNIaWRkZW4oKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHpvb21PdXRCdXR0b24uc2hvdygpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgem9vbU91dEJ1dHRvbi5oaWRlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENoZWNrcyBpZiBwb2ludCBpcyB3aXRoaW4gcGxvdCBhcmVhLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSAgIHBvaW50ICBSZWZlcmVuY2UgcG9pbnRcclxuICAgICAqIEByZXR1cm4gICAgICAgICBJcyB3aXRoaW4gcGxvdCBhcmVhP1xyXG4gICAgICovXHJcbiAgICBpblBsb3QocG9pbnQpIHtcclxuICAgICAgICBjb25zdCBwbG90Q29udGFpbmVyID0gdGhpcy5wbG90Q29udGFpbmVyO1xyXG4gICAgICAgIGNvbnN0IG90aGVyQ2hhcnRzID0gdGhpcy5nZXRQcml2YXRlKFwib3RoZXJDaGFydHNcIiwgdGhpcy5fb3RoZXJDaGFydHMpO1xyXG4gICAgICAgIGNvbnN0IGdsb2JhbCA9IHBsb3RDb250YWluZXIudG9HbG9iYWwocG9pbnQpO1xyXG4gICAgICAgIGlmIChwb2ludC54ID49IC0wLjUgJiYgcG9pbnQueSA+PSAtMC41ICYmIHBvaW50LnggPD0gcGxvdENvbnRhaW5lci53aWR0aCgpICsgMC41ICYmIHBvaW50LnkgPD0gcGxvdENvbnRhaW5lci5oZWlnaHQoKSArIDAuNSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG90aGVyQ2hhcnRzKSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSBvdGhlckNoYXJ0cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY2hhcnQgPSBvdGhlckNoYXJ0c1tpXTtcclxuICAgICAgICAgICAgICAgIGlmIChjaGFydCAhPSB0aGlzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2hhcnRQbG90Q29udGFpbmVyID0gY2hhcnQucGxvdENvbnRhaW5lcjtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBkb2N1bWVudFBvaW50ID0gdGhpcy5fcm9vdC5yb290UG9pbnRUb0RvY3VtZW50KGdsb2JhbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2hhcnRSb290ID0gY2hhcnQuX3Jvb3QuZG9jdW1lbnRQb2ludFRvUm9vdChkb2N1bWVudFBvaW50KTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBsb2NhbCA9IGNoYXJ0UGxvdENvbnRhaW5lci50b0xvY2FsKGNoYXJ0Um9vdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxvY2FsLnggPj0gLTAuMSAmJiBsb2NhbC55ID49IC0wLjEgJiYgbG9jYWwueCA8PSBjaGFydFBsb3RDb250YWluZXIud2lkdGgoKSArIDAuMSAmJiBsb2NhbC55IDw9IGNoYXJ0UGxvdENvbnRhaW5lci5oZWlnaHQoKSArIDAuMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAaWdub3JlXHJcbiAgICAgKi9cclxuICAgIGFycmFuZ2VUb29sdGlwcygpIHtcclxuICAgICAgICBjb25zdCBwbG90Q29udGFpbmVyID0gdGhpcy5wbG90Q29udGFpbmVyO1xyXG4gICAgICAgIGNvbnN0IHcgPSBwbG90Q29udGFpbmVyLndpZHRoKCk7XHJcbiAgICAgICAgY29uc3QgaCA9IHBsb3RDb250YWluZXIuaGVpZ2h0KCk7XHJcbiAgICAgICAgY29uc3QgaGggPSB0aGlzLmhlaWdodCgpO1xyXG4gICAgICAgIGxldCBwbG90VCA9IHBsb3RDb250YWluZXIuX2Rpc3BsYXkudG9HbG9iYWwoeyB4OiAwLCB5OiAwIH0pO1xyXG4gICAgICAgIGxldCBwbG90QiA9IHBsb3RDb250YWluZXIuX2Rpc3BsYXkudG9HbG9iYWwoeyB4OiB3LCB5OiBoIH0pO1xyXG4gICAgICAgIGNvbnN0IHRvb2x0aXBzID0gW107XHJcbiAgICAgICAgbGV0IHN1bSA9IDA7XHJcbiAgICAgICAgbGV0IG1pbkRpc3RhbmNlID0gSW5maW5pdHk7XHJcbiAgICAgICAgbGV0IG1vdmVQb2ludCA9IHRoaXMuX21vdmVQb2ludDtcclxuICAgICAgICBsZXQgbWF4VG9vbHRpcERpc3RhbmNlID0gdGhpcy5nZXQoXCJtYXhUb29sdGlwRGlzdGFuY2VcIik7XHJcbiAgICAgICAgbGV0IG1heFRvb2x0aXBEaXN0YW5jZUJ5ID0gdGhpcy5nZXQoXCJtYXhUb29sdGlwRGlzdGFuY2VCeVwiLCBcInh5XCIpO1xyXG4gICAgICAgIGxldCBjbG9zZXN0O1xyXG4gICAgICAgIGxldCBjbG9zZXN0UG9pbnQ7XHJcbiAgICAgICAgaWYgKCR0eXBlLmlzTnVtYmVyKG1heFRvb2x0aXBEaXN0YW5jZSkpIHtcclxuICAgICAgICAgICAgdGhpcy5zZXJpZXMuZWFjaCgoc2VyaWVzKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXNlcmllcy5pc0hpZGRlbigpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdG9vbHRpcCA9IHNlcmllcy5nZXQoXCJ0b29sdGlwXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0b29sdGlwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBwb2ludCA9IHRvb2x0aXAuZ2V0KFwicG9pbnRUb1wiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBvaW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgZGlzdGFuY2UgPSBNYXRoLmh5cG90KG1vdmVQb2ludC54IC0gcG9pbnQueCwgbW92ZVBvaW50LnkgLSBwb2ludC55KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXhUb29sdGlwRGlzdGFuY2VCeSA9PSBcInhcIikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc3RhbmNlID0gTWF0aC5hYnMobW92ZVBvaW50LnggLSBwb2ludC54KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG1heFRvb2x0aXBEaXN0YW5jZUJ5ID09IFwieVwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzdGFuY2UgPSBNYXRoLmFicyhtb3ZlUG9pbnQueSAtIHBvaW50LnkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRpc3RhbmNlIDwgbWluRGlzdGFuY2UpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaW5EaXN0YW5jZSA9IGRpc3RhbmNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsb3Nlc3QgPSBzZXJpZXM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xvc2VzdFBvaW50ID0gcG9pbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCB0b29sdGlwU2VyaWVzID0gW107XHJcbiAgICAgICAgdGhpcy5zZXJpZXMuZWFjaCgoc2VyaWVzKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHRvb2x0aXAgPSBzZXJpZXMuZ2V0KFwidG9vbHRpcFwiKTtcclxuICAgICAgICAgICAgaWYgKHRvb2x0aXAgJiYgIXRvb2x0aXAuZ2V0KFwiZm9yY2VIaWRkZW5cIikpIHtcclxuICAgICAgICAgICAgICAgIGxldCBoaWRkZW4gPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIGxldCBwb2ludCA9IHRvb2x0aXAuZ2V0KFwicG9pbnRUb1wiKTtcclxuICAgICAgICAgICAgICAgIGlmIChwb2ludCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXhUb29sdGlwRGlzdGFuY2UgPj0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgcG9pbnQgPSB0b29sdGlwLmdldChcInBvaW50VG9cIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwb2ludCAmJiBjbG9zZXN0UG9pbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZXJpZXMgIT0gY2xvc2VzdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBkaXN0YW5jZSA9IE1hdGguaHlwb3QoY2xvc2VzdFBvaW50LnggLSBwb2ludC54LCBjbG9zZXN0UG9pbnQueSAtIHBvaW50LnkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXhUb29sdGlwRGlzdGFuY2VCeSA9PSBcInhcIikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXN0YW5jZSA9IE1hdGguYWJzKGNsb3Nlc3RQb2ludC54IC0gcG9pbnQueCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG1heFRvb2x0aXBEaXN0YW5jZUJ5ID09IFwieVwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc3RhbmNlID0gTWF0aC5hYnMoY2xvc2VzdFBvaW50LnkgLSBwb2ludC55KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRpc3RhbmNlID4gbWF4VG9vbHRpcERpc3RhbmNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhpZGRlbiA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG1heFRvb2x0aXBEaXN0YW5jZSA9PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2VyaWVzICE9IGNsb3Nlc3QpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhpZGRlbiA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLmluUGxvdCh0aGlzLl90b29sdGlwVG9Mb2NhbChwb2ludCkpIHx8ICF0b29sdGlwLmRhdGFJdGVtKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhpZGRlbiA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWhpZGRlbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3VtICs9IHBvaW50Lnk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGhpZGRlbiB8fCBzZXJpZXMuaXNIaWRkZW4oKSB8fCBzZXJpZXMuaXNIaWRpbmcoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0b29sdGlwLmhpZGUoMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0b29sdGlwLnNob3coKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdG9vbHRpcHMucHVzaCh0b29sdGlwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdG9vbHRpcFNlcmllcy5wdXNoKHNlcmllcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5zZXRQcml2YXRlKFwidG9vbHRpcFNlcmllc1wiLCB0b29sdGlwU2VyaWVzKTtcclxuICAgICAgICBpZiAodGhpcy5nZXQoXCJhcnJhbmdlVG9vbHRpcHNcIikpIHtcclxuICAgICAgICAgICAgY29uc3QgdG9vbHRpcENvbnRhaW5lciA9IHRoaXMuX3Jvb3QudG9vbHRpcENvbnRhaW5lcjtcclxuICAgICAgICAgICAgY29uc3QgY291bnQgPSB0b29sdGlwcy5sZW5ndGg7XHJcbiAgICAgICAgICAgIGNvbnN0IGF2ZXJhZ2UgPSBzdW0gLyBjb3VudDtcclxuICAgICAgICAgICAgaWYgKGF2ZXJhZ2UgPiBoIC8gMiArIHBsb3RULnkpIHtcclxuICAgICAgICAgICAgICAgIHRvb2x0aXBzLnNvcnQoKGEsIGIpID0+ICRvcmRlci5jb21wYXJlTnVtYmVyKGIuZ2V0KFwicG9pbnRUb1wiKS55LCBhLmdldChcInBvaW50VG9cIikueSkpO1xyXG4gICAgICAgICAgICAgICAgbGV0IHByZXZZID0gcGxvdEIueTtcclxuICAgICAgICAgICAgICAgICRhcnJheS5lYWNoKHRvb2x0aXBzLCAodG9vbHRpcCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBoZWlnaHQgPSB0b29sdGlwLmhlaWdodCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBjZW50ZXJZID0gdG9vbHRpcC5nZXQoXCJjZW50ZXJZXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjZW50ZXJZIGluc3RhbmNlb2YgUGVyY2VudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQgKj0gY2VudGVyWS52YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0ICs9IHRvb2x0aXAuZ2V0KFwibWFyZ2luQm90dG9tXCIsIDApO1xyXG4gICAgICAgICAgICAgICAgICAgIHRvb2x0aXAuc2V0KFwiYm91bmRzXCIsIHsgbGVmdDogcGxvdFQueCwgdG9wOiBwbG90VC55LCByaWdodDogcGxvdEIueCwgYm90dG9tOiBwcmV2WSB9KTtcclxuICAgICAgICAgICAgICAgICAgICB0b29sdGlwLnNldFByaXZhdGUoXCJjdXN0b21EYXRhXCIsIHsgbGVmdDogcGxvdFQueCwgdG9wOiBwbG90VC55LCByaWdodDogcGxvdEIueCwgYm90dG9tOiBwcmV2WSB9KTtcclxuICAgICAgICAgICAgICAgICAgICBwcmV2WSA9IE1hdGgubWluKHByZXZZIC0gaGVpZ2h0LCB0b29sdGlwLl9meSAtIGhlaWdodCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRvb2x0aXAucGFyZW50ID09IHRvb2x0aXBDb250YWluZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdG9vbHRpcENvbnRhaW5lci5jaGlsZHJlbi5tb3ZlVmFsdWUodG9vbHRpcCwgMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBpZiAocHJldlkgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdG9vbHRpcHMucmV2ZXJzZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBwcmV2Qm90dG9tID0gcHJldlk7XHJcbiAgICAgICAgICAgICAgICAgICAgJGFycmF5LmVhY2godG9vbHRpcHMsICh0b29sdGlwKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBib3VuZHMgPSB0b29sdGlwLmdldChcImJvdW5kc1wiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJvdW5kcykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHRvcCA9IGJvdW5kcy50b3AgLSBwcmV2WTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBib3R0b20gPSBib3VuZHMuYm90dG9tIC0gcHJldlk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodG9wIDwgcHJldkJvdHRvbSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvcCA9IHByZXZCb3R0b207XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYm90dG9tID0gdG9wICsgdG9vbHRpcC5oZWlnaHQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvb2x0aXAuc2V0KFwiYm91bmRzXCIsIHsgbGVmdDogYm91bmRzLmxlZnQsIHRvcDogdG9wLCByaWdodDogYm91bmRzLnJpZ2h0LCBib3R0b206IGJvdHRvbSB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZXZCb3R0b20gPSBib3VuZHMuYm90dG9tIC0gcHJldlkgKyB0b29sdGlwLmdldChcIm1hcmdpbkJvdHRvbVwiLCAwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdG9vbHRpcHMucmV2ZXJzZSgpO1xyXG4gICAgICAgICAgICAgICAgdG9vbHRpcHMuc29ydCgoYSwgYikgPT4gJG9yZGVyLmNvbXBhcmVOdW1iZXIoYS5nZXQoXCJwb2ludFRvXCIpLnksIGIuZ2V0KFwicG9pbnRUb1wiKS55KSk7XHJcbiAgICAgICAgICAgICAgICBsZXQgcHJldlkgPSAwO1xyXG4gICAgICAgICAgICAgICAgJGFycmF5LmVhY2godG9vbHRpcHMsICh0b29sdGlwKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGhlaWdodCA9IHRvb2x0aXAuaGVpZ2h0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGNlbnRlclkgPSB0b29sdGlwLmdldChcImNlbnRlcllcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNlbnRlclkgaW5zdGFuY2VvZiBQZXJjZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodCAqPSBjZW50ZXJZLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBoZWlnaHQgKz0gdG9vbHRpcC5nZXQoXCJtYXJnaW5Cb3R0b21cIiwgMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdG9vbHRpcC5zZXQoXCJib3VuZHNcIiwgeyBsZWZ0OiBwbG90VC54LCB0b3A6IHByZXZZLCByaWdodDogcGxvdEIueCwgYm90dG9tOiBNYXRoLm1heChwbG90VC55ICsgaGgsIHByZXZZICsgaGVpZ2h0KSB9KTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodG9vbHRpcC5wYXJlbnQgPT0gdG9vbHRpcENvbnRhaW5lcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0b29sdGlwQ29udGFpbmVyLmNoaWxkcmVuLm1vdmVWYWx1ZSh0b29sdGlwLCAwKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcHJldlkgPSBNYXRoLm1heChwcmV2WSArIGhlaWdodCwgdG9vbHRpcC5fZnkgKyBoZWlnaHQpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBpZiAocHJldlkgPiBoaCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRvb2x0aXBzLnJldmVyc2UoKTtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgcHJldkJvdHRvbSA9IGhoO1xyXG4gICAgICAgICAgICAgICAgICAgICRhcnJheS5lYWNoKHRvb2x0aXBzLCAodG9vbHRpcCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgYm91bmRzID0gdG9vbHRpcC5nZXQoXCJib3VuZHNcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChib3VuZHMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCB0b3AgPSBib3VuZHMudG9wIC0gKGhoIC0gcHJldlkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGJvdHRvbSA9IGJvdW5kcy5ib3R0b20gLSAoaGggLSBwcmV2WSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYm90dG9tID4gcHJldkJvdHRvbSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvdHRvbSA9IHByZXZCb3R0b207XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9wID0gYm90dG9tIC0gdG9vbHRpcC5oZWlnaHQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvb2x0aXAuc2V0KFwiYm91bmRzXCIsIHsgbGVmdDogYm91bmRzLmxlZnQsIHRvcDogdG9wLCByaWdodDogYm91bmRzLnJpZ2h0LCBib3R0b206IGJvdHRvbSB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZXZCb3R0b20gPSBib3R0b20gLSB0b29sdGlwLmhlaWdodCgpIC0gdG9vbHRpcC5nZXQoXCJtYXJnaW5Cb3R0b21cIiwgMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIF90b29sdGlwVG9Mb2NhbChwb2ludCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnBsb3RDb250YWluZXIudG9Mb2NhbChwb2ludCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEZ1bGx5IHpvb21zIG91dCB0aGUgY2hhcnQuXHJcbiAgICAgKi9cclxuICAgIHpvb21PdXQoKSB7XHJcbiAgICAgICAgdGhpcy54QXhlcy5lYWNoKChheGlzKSA9PiB7XHJcbiAgICAgICAgICAgIGF4aXMuc2V0UHJpdmF0ZShcInVwZGF0ZVNjcm9sbGJhclwiLCB0cnVlKTtcclxuICAgICAgICAgICAgYXhpcy56b29tKDAsIDEpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMueUF4ZXMuZWFjaCgoYXhpcykgPT4ge1xyXG4gICAgICAgICAgICBheGlzLnNldFByaXZhdGUoXCJ1cGRhdGVTY3JvbGxiYXJcIiwgdHJ1ZSk7XHJcbiAgICAgICAgICAgIGF4aXMuem9vbSgwLCAxKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxufVxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoWFlDaGFydCwgXCJjbGFzc05hbWVcIiwge1xyXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgdmFsdWU6IFwiWFlDaGFydFwiXHJcbn0pO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoWFlDaGFydCwgXCJjbGFzc05hbWVzXCIsIHtcclxuICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgIHZhbHVlOiBTZXJpYWxDaGFydC5jbGFzc05hbWVzLmNvbmNhdChbWFlDaGFydC5jbGFzc05hbWVdKVxyXG59KTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9WFlDaGFydC5qcy5tYXAiLCJpbXBvcnQgeyBUaGVtZSB9IGZyb20gXCIuLi8uLi9jb3JlL1RoZW1lXCI7XHJcbmltcG9ydCB7IHBlcmNlbnQsIHA1MCwgcDEwMCB9IGZyb20gXCIuLi8uLi9jb3JlL3V0aWwvUGVyY2VudFwiO1xyXG5pbXBvcnQgeyBDb2xvclNldCB9IGZyb20gXCIuLi8uLi9jb3JlL3V0aWwvQ29sb3JTZXRcIjtcclxuaW1wb3J0IHsgc2V0Q29sb3IgfSBmcm9tIFwiLi4vLi4vdGhlbWVzL0RlZmF1bHRUaGVtZVwiO1xyXG5pbXBvcnQgKiBhcyAkdGltZSBmcm9tIFwiLi4vLi4vY29yZS91dGlsL1RpbWVcIjtcclxuaW1wb3J0ICogYXMgJHR5cGUgZnJvbSBcIi4uLy4uL2NvcmUvdXRpbC9UeXBlXCI7XHJcbmltcG9ydCAqIGFzICRtYXRoIGZyb20gXCIuLi8uLi9jb3JlL3V0aWwvTWF0aFwiO1xyXG5pbXBvcnQgKiBhcyAkb2JqZWN0IGZyb20gXCIuLi8uLi9jb3JlL3V0aWwvT2JqZWN0XCI7XHJcbmltcG9ydCAqIGFzICRhcnJheSBmcm9tIFwiLi4vLi4vY29yZS91dGlsL0FycmF5XCI7XHJcbi8qKlxyXG4gKiBAaWdub3JlXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgWFlDaGFydERlZmF1bHRUaGVtZSBleHRlbmRzIFRoZW1lIHtcclxuICAgIHNldHVwRGVmYXVsdFJ1bGVzKCkge1xyXG4gICAgICAgIHN1cGVyLnNldHVwRGVmYXVsdFJ1bGVzKCk7XHJcbiAgICAgICAgY29uc3QgaWMgPSB0aGlzLl9yb290LmludGVyZmFjZUNvbG9ycztcclxuICAgICAgICBjb25zdCBsYW5ndWFnZSA9IHRoaXMuX3Jvb3QubGFuZ3VhZ2U7XHJcbiAgICAgICAgY29uc3QgciA9IHRoaXMucnVsZS5iaW5kKHRoaXMpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4gICAgICAgICAqIGNoYXJ0cy94eVxyXG4gICAgICAgICAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHIoXCJYWUNoYXJ0XCIpLnNldEFsbCh7XHJcbiAgICAgICAgICAgIGNvbG9yczogQ29sb3JTZXQubmV3KHRoaXMuX3Jvb3QsIHt9KSxcclxuICAgICAgICAgICAgcGFkZGluZ0xlZnQ6IDIwLFxyXG4gICAgICAgICAgICBwYWRkaW5nUmlnaHQ6IDIwLFxyXG4gICAgICAgICAgICBwYWRkaW5nVG9wOiAxNixcclxuICAgICAgICAgICAgcGFkZGluZ0JvdHRvbTogMTYsXHJcbiAgICAgICAgICAgIHBhblg6IGZhbHNlLFxyXG4gICAgICAgICAgICBwYW5ZOiBmYWxzZSxcclxuICAgICAgICAgICAgd2hlZWxTdGVwOiAwLjI1LFxyXG4gICAgICAgICAgICBhcnJhbmdlVG9vbHRpcHM6IHRydWUsXHJcbiAgICAgICAgICAgIHBpbmNoWm9vbVg6IGZhbHNlLFxyXG4gICAgICAgICAgICBwaW5jaFpvb21ZOiBmYWxzZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHIoXCJYWVNlcmllc1wiKS5zZXRBbGwoe1xyXG4gICAgICAgICAgICBsZWdlbmRMYWJlbFRleHQ6IFwie25hbWV9XCJcclxuICAgICAgICB9KTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgICAgICAgKiBjaGFydHMveHk6IFhZQ2hhcnRTY3JvbGxiYXJcclxuICAgICAgICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgICAgICAgKi9cclxuICAgICAgICByKFwiWFlDaGFydFwiLCBbXCJzY3JvbGxiYXJcIiwgXCJjaGFydFwiXSkuc2V0QWxsKHtcclxuICAgICAgICAgICAgcGFkZGluZ0JvdHRvbTogMCxcclxuICAgICAgICAgICAgcGFkZGluZ0xlZnQ6IDAsXHJcbiAgICAgICAgICAgIHBhZGRpbmdUb3A6IDAsXHJcbiAgICAgICAgICAgIHBhZGRpbmdSaWdodDogMCxcclxuICAgICAgICAgICAgY29sb3JzOiBDb2xvclNldC5uZXcodGhpcy5fcm9vdCwge1xyXG4gICAgICAgICAgICAgICAgc2F0dXJhdGlvbjogMFxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgY29uc3QgcnVsZSA9IHIoXCJHcmFwaGljc1wiLCBbXCJzY3JvbGxiYXJcIiwgXCJvdmVybGF5XCJdKTtcclxuICAgICAgICAgICAgcnVsZS5zZXRBbGwoe1xyXG4gICAgICAgICAgICAgICAgZmlsbE9wYWNpdHk6IDAuNVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgc2V0Q29sb3IocnVsZSwgXCJmaWxsXCIsIGljLCBcImJhY2tncm91bmRcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIENsYXNzOiBSb3VuZGVkUmVjdGFuZ2xlXHJcbiAgICAgICAgcihcIlJvdW5kZWRSZWN0YW5nbGVcIiwgW1wieHlcIiwgXCJzY3JvbGxiYXJcIiwgXCJ0aHVtYlwiXSkuc2V0QWxsKHtcclxuICAgICAgICAgICAgY29ybmVyUmFkaXVzVFI6IDAsXHJcbiAgICAgICAgICAgIGNvcm5lclJhZGl1c1RMOiAwLFxyXG4gICAgICAgICAgICBjb3JuZXJSYWRpdXNCUjogMCxcclxuICAgICAgICAgICAgY29ybmVyUmFkaXVzQkw6IDAsXHJcbiAgICAgICAgICAgIGZpbGxPcGFjaXR5OiAwLFxyXG4gICAgICAgICAgICBmb2N1c2FibGU6IHRydWVcclxuICAgICAgICB9KTtcclxuICAgICAgICByKFwiUm91bmRlZFJlY3RhbmdsZVwiLCBbXCJ4eVwiLCBcInNjcm9sbGJhclwiLCBcInRodW1iXCJdKS5zdGF0ZXMuY3JlYXRlKFwiaG92ZXJcIiwgeyBmaWxsT3BhY2l0eTogMC40IH0pO1xyXG4gICAgICAgIHIoXCJSb3VuZGVkUmVjdGFuZ2xlXCIsIFtcInh5XCIsIFwic2Nyb2xsYmFyXCIsIFwiY2hhcnRcIiwgXCJiYWNrZ3JvdW5kXCJdKS5zZXRBbGwoe1xyXG4gICAgICAgICAgICBjb3JuZXJSYWRpdXNUTDogMCxcclxuICAgICAgICAgICAgY29ybmVyUmFkaXVzQkw6IDAsXHJcbiAgICAgICAgICAgIGNvcm5lclJhZGl1c1RSOiAwLFxyXG4gICAgICAgICAgICBjb3JuZXJSYWRpdXNCUjogMFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHIoXCJSb3VuZGVkUmVjdGFuZ2xlXCIsIFtcInh5XCIsIFwic2Nyb2xsYmFyXCIsIFwiY2hhcnRcIiwgXCJiYWNrZ3JvdW5kXCIsIFwicmVzaXplXCIsIFwiYnV0dG9uXCJdKS5zZXRBbGwoe1xyXG4gICAgICAgICAgICBjb3JuZXJSYWRpdXNCTDogNDAsXHJcbiAgICAgICAgICAgIGNvcm5lclJhZGl1c0JSOiA0MCxcclxuICAgICAgICAgICAgY29ybmVyUmFkaXVzVEw6IDQwLFxyXG4gICAgICAgICAgICBjb3JuZXJSYWRpdXNUUjogNDBcclxuICAgICAgICB9KTtcclxuICAgICAgICByKFwiQXhpc1JlbmRlcmVyWFwiLCBbXCJ4eVwiLCBcImNoYXJ0XCIsIFwic2Nyb2xsYmFyXCJdKS5zZXRBbGwoe1xyXG4gICAgICAgICAgICBzdHJva2VPcGFjaXR5OiAwLFxyXG4gICAgICAgICAgICBpbnNpZGU6IHRydWVcclxuICAgICAgICB9KTtcclxuICAgICAgICByKFwiQXhpc1JlbmRlcmVyWVwiLCBbXCJ4eVwiLCBcImNoYXJ0XCIsIFwic2Nyb2xsYmFyXCJdKS5zZXRBbGwoe1xyXG4gICAgICAgICAgICBzdHJva2VPcGFjaXR5OiAwLFxyXG4gICAgICAgICAgICBpbnNpZGU6IHRydWUsXHJcbiAgICAgICAgICAgIG1pbkdyaWREaXN0YW5jZTogNVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHIoXCJBeGlzTGFiZWxcIiwgW1wieHlcIiwgXCJzY3JvbGxiYXJcIiwgXCJ4XCJdKS5zZXRBbGwoe1xyXG4gICAgICAgICAgICBvcGFjaXR5OiAwLjUsXHJcbiAgICAgICAgICAgIGNlbnRlclk6IHAxMDAsXHJcbiAgICAgICAgICAgIG1pblBvc2l0aW9uOiAwLjAxLFxyXG4gICAgICAgICAgICBtYXhQb3NpdGlvbjogMC45OSxcclxuICAgICAgICAgICAgZm9udFNpemU6IFwiMC44ZW1cIlxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHIoXCJBeGlzTGFiZWxcIiwgW1wiY2F0ZWdvcnlcIl0pLnNldEFsbCh7XHJcbiAgICAgICAgICAgIHRleHQ6IFwie2NhdGVnb3J5fVwiLFxyXG4gICAgICAgICAgICBwb3B1bGF0ZVRleHQ6IHRydWVcclxuICAgICAgICB9KTtcclxuICAgICAgICByKFwiQXhpc0xhYmVsXCIsIFtcInhcIl0pLnNldEFsbCh7XHJcbiAgICAgICAgICAgIGNlbnRlclk6IDBcclxuICAgICAgICB9KTtcclxuICAgICAgICByKFwiQXhpc0xhYmVsXCIsIFtcInhcIiwgXCJpbnNpZGVcIl0pLnNldEFsbCh7XHJcbiAgICAgICAgICAgIGNlbnRlclk6IHAxMDBcclxuICAgICAgICB9KTtcclxuICAgICAgICByKFwiQXhpc0xhYmVsXCIsIFtcInhcIiwgXCJpbnNpZGVcIiwgXCJvcHBvc2l0ZVwiXSkuc2V0QWxsKHtcclxuICAgICAgICAgICAgY2VudGVyWTogMFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHIoXCJBeGlzTGFiZWxcIiwgW1wieFwiLCBcIm9wcG9zaXRlXCJdKS5zZXRBbGwoe1xyXG4gICAgICAgICAgICBjZW50ZXJZOiBwMTAwXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcihcIkF4aXNMYWJlbFwiLCBbXCJ5XCJdKS5zZXRBbGwoe1xyXG4gICAgICAgICAgICBjZW50ZXJYOiBwMTAwXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcihcIkF4aXNMYWJlbFwiLCBbXCJ5XCIsIFwiaW5zaWRlXCJdKS5zZXRBbGwoe1xyXG4gICAgICAgICAgICBjZW50ZXJYOiAwXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcihcIkF4aXNMYWJlbFwiLCBbXCJ5XCIsIFwiaW5zaWRlXCIsIFwib3Bwb3NpdGVcIl0pLnNldEFsbCh7XHJcbiAgICAgICAgICAgIGNlbnRlclg6IHAxMDBcclxuICAgICAgICB9KTtcclxuICAgICAgICByKFwiQXhpc0xhYmVsXCIsIFtcInlcIiwgXCJvcHBvc2l0ZVwiXSkuc2V0QWxsKHtcclxuICAgICAgICAgICAgY2VudGVyWDogMFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHIoXCJBeGlzTGFiZWxcIiwgW1wibWlub3JcIl0pLnNldEFsbCh7XHJcbiAgICAgICAgICAgIGZvbnRTaXplOiBcIjAuNmVtXCJcclxuICAgICAgICB9KTtcclxuICAgICAgICByKFwiQXhpc0xhYmVsXCIsIFtcInh5XCIsIFwic2Nyb2xsYmFyXCIsIFwieVwiXSkuc2V0QWxsKHtcclxuICAgICAgICAgICAgdmlzaWJsZTogZmFsc2VcclxuICAgICAgICB9KTtcclxuICAgICAgICAvLyBDbGFzczogR3JpZFxyXG4gICAgICAgIHIoXCJHcmlkXCIsIFtcInh5XCIsIFwic2Nyb2xsYmFyXCIsIFwieVwiXSkuc2V0QWxsKHtcclxuICAgICAgICAgICAgdmlzaWJsZTogZmFsc2VcclxuICAgICAgICB9KTtcclxuICAgICAgICAvLyBDbGFzczogR3JpZFxyXG4gICAgICAgIHIoXCJHcmlkXCIsIFtcInh5XCIsIFwic2Nyb2xsYmFyXCIsIFwieFwiXSkuc2V0QWxsKHtcclxuICAgICAgICAgICAgb3BhY2l0eTogMC41XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICAgICAgICogY2hhcnRzL3h5OiBDdXJzb3JcclxuICAgICAgICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgICAgICAgKi9cclxuICAgICAgICByKFwiWFlDdXJzb3JcIikuc2V0QWxsKHtcclxuICAgICAgICAgICAgYmVoYXZpb3I6IFwibm9uZVwiLFxyXG4gICAgICAgICAgICBsYXllcjogMzAsXHJcbiAgICAgICAgICAgIGV4cG9ydGFibGU6IGZhbHNlLFxyXG4gICAgICAgICAgICBzbmFwVG9TZXJpZXNCeTogXCJ4eVwiLFxyXG4gICAgICAgICAgICBtb3ZlVGhyZXNob2xkOiAxXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBjb25zdCBydWxlID0gcihcIkdyaWRcIiwgW1wiY3Vyc29yXCIsIFwieFwiXSk7XHJcbiAgICAgICAgICAgIHJ1bGUuc2V0QWxsKHtcclxuICAgICAgICAgICAgICAgIHN0cm9rZU9wYWNpdHk6IDAuOCxcclxuICAgICAgICAgICAgICAgIHN0cm9rZURhc2hhcnJheTogWzIsIDJdLFxyXG4gICAgICAgICAgICAgICAgYXJpYUxhYmVsOiBsYW5ndWFnZS50cmFuc2xhdGUoXCJVc2UgbGVmdCBhbmQgcmlnaHQgYXJyb3dzIHRvIG1vdmUgc2VsZWN0aW9uXCIpXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBzZXRDb2xvcihydWxlLCBcInN0cm9rZVwiLCBpYywgXCJhbHRlcm5hdGl2ZUJhY2tncm91bmRcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgY29uc3QgcnVsZSA9IHIoXCJHcmlkXCIsIFtcImN1cnNvclwiLCBcInlcIl0pO1xyXG4gICAgICAgICAgICBydWxlLnNldEFsbCh7XHJcbiAgICAgICAgICAgICAgICBzdHJva2VPcGFjaXR5OiAwLjgsXHJcbiAgICAgICAgICAgICAgICBzdHJva2VEYXNoYXJyYXk6IFsyLCAyXSxcclxuICAgICAgICAgICAgICAgIGFyaWFMYWJlbDogbGFuZ3VhZ2UudHJhbnNsYXRlKFwiVXNlIHVwIGFuZCBkb3duIGFycm93cyB0byBtb3ZlIHNlbGVjdGlvblwiKVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgc2V0Q29sb3IocnVsZSwgXCJzdHJva2VcIiwgaWMsIFwiYWx0ZXJuYXRpdmVCYWNrZ3JvdW5kXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGNvbnN0IHJ1bGUgPSByKFwiR3JhcGhpY3NcIiwgW1wiY3Vyc29yXCIsIFwic2VsZWN0aW9uXCJdKTtcclxuICAgICAgICAgICAgcnVsZS5zZXRBbGwoe1xyXG4gICAgICAgICAgICAgICAgZmlsbE9wYWNpdHk6IDAuMTUsXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBzZXRDb2xvcihydWxlLCBcImZpbGxcIiwgaWMsIFwiYWx0ZXJuYXRpdmVCYWNrZ3JvdW5kXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgICAgICAgKiBjaGFydHMveHk6IEF4ZXNcclxuICAgICAgICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgICAgICAgKi9cclxuICAgICAgICByKFwiQXhpc1wiKS5zZXRBbGwoe1xyXG4gICAgICAgICAgICBzdGFydDogMCxcclxuICAgICAgICAgICAgZW5kOiAxLFxyXG4gICAgICAgICAgICBtaW5ab29tQ291bnQ6IDEsXHJcbiAgICAgICAgICAgIG1heFpvb21Db3VudDogSW5maW5pdHksXHJcbiAgICAgICAgICAgIG1heFpvb21GYWN0b3I6IDEwMDAsXHJcbiAgICAgICAgICAgIG1heERldmlhdGlvbjogMC4xLFxyXG4gICAgICAgICAgICBzbmFwVG9vbHRpcDogdHJ1ZSxcclxuICAgICAgICAgICAgdG9vbHRpcExvY2F0aW9uOiAwLjUsXHJcbiAgICAgICAgICAgIHBhblg6IHRydWUsXHJcbiAgICAgICAgICAgIHBhblk6IHRydWUsXHJcbiAgICAgICAgICAgIHpvb21YOiB0cnVlLFxyXG4gICAgICAgICAgICB6b29tWTogdHJ1ZSxcclxuICAgICAgICAgICAgZml4QXhpc1NpemU6IHRydWVcclxuICAgICAgICB9KTtcclxuICAgICAgICByKFwiQXhpc0xhYmVsXCIpLnNldEFsbCh7XHJcbiAgICAgICAgICAgIGxvY2F0aW9uOiAwLjUsXHJcbiAgICAgICAgICAgIG11bHRpTG9jYXRpb246IDAsXHJcbiAgICAgICAgICAgIGNlbnRlclg6IHA1MCxcclxuICAgICAgICAgICAgY2VudGVyWTogcDUwLFxyXG4gICAgICAgICAgICBwYWRkaW5nVG9wOiAzLFxyXG4gICAgICAgICAgICBwYWRkaW5nQm90dG9tOiAzLFxyXG4gICAgICAgICAgICBwYWRkaW5nTGVmdDogNSxcclxuICAgICAgICAgICAgcGFkZGluZ1JpZ2h0OiA1XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLy8gVGhlIGZvbGxvd2luZyBpcyBkZXByZWNhdGVkIGZvbGxvd2luZyB0ZXh0IG1lYXN1cmluZyB1cGRhdGVzIGluIDUuMC41XHJcbiAgICAgICAgLy8gcihcIkF4aXNMYWJlbFwiLCBbXCJ5XCJdKS5zZXRBbGwoe1xyXG4gICAgICAgIC8vIFx0dGV4dEFsaWduOiBcInJpZ2h0XCJcclxuICAgICAgICAvLyB9KTtcclxuICAgICAgICAvLyByKFwiQXhpc0xhYmVsXCIsIFtcInlcIiwgXCJvcHBvc2l0ZVwiXSkuc2V0QWxsKHtcclxuICAgICAgICAvLyBcdHRleHRBbGlnbjogXCJsZWZ0XCJcclxuICAgICAgICAvLyB9KTtcclxuICAgICAgICByKFwiQ29udGFpbmVyXCIsIFtcImF4aXNcIiwgXCJoZWFkZXJcIl0pLnNldEFsbCh7XHJcbiAgICAgICAgICAgIGxheWVyOiAzMFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHIoXCJSZWN0YW5nbGVcIiwgW1wiYXhpc1wiLCBcImhlYWRlclwiLCBcImJhY2tncm91bmRcIl0pLnNldEFsbCh7XHJcbiAgICAgICAgICAgIGNyaXNwOiB0cnVlXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBjb25zdCBydWxlID0gcihcIkF4aXNSZW5kZXJlclwiKTtcclxuICAgICAgICAgICAgcnVsZS5zZXRBbGwoe1xyXG4gICAgICAgICAgICAgICAgY3Jpc3A6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBzdHJva2VPcGFjaXR5OiAwXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBzZXRDb2xvcihydWxlLCBcInN0cm9rZVwiLCBpYywgXCJncmlkXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByKFwiQXhpc1JlbmRlcmVyWFwiKS5zZXRBbGwoe1xyXG4gICAgICAgICAgICBtaW5HcmlkRGlzdGFuY2U6IDEyMCxcclxuICAgICAgICAgICAgb3Bwb3NpdGU6IGZhbHNlLFxyXG4gICAgICAgICAgICBpbnZlcnNlZDogZmFsc2UsXHJcbiAgICAgICAgICAgIGNlbGxTdGFydExvY2F0aW9uOiAwLFxyXG4gICAgICAgICAgICBjZWxsRW5kTG9jYXRpb246IDEsXHJcbiAgICAgICAgICAgIHdpZHRoOiBwMTAwXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcihcIkF4aXNSZW5kZXJlcllcIikuc2V0QWxsKHtcclxuICAgICAgICAgICAgbWluR3JpZERpc3RhbmNlOiA0MCxcclxuICAgICAgICAgICAgb3Bwb3NpdGU6IGZhbHNlLFxyXG4gICAgICAgICAgICBpbnZlcnNlZDogZmFsc2UsXHJcbiAgICAgICAgICAgIGNlbGxTdGFydExvY2F0aW9uOiAwLFxyXG4gICAgICAgICAgICBjZWxsRW5kTG9jYXRpb246IDEsXHJcbiAgICAgICAgICAgIGhlaWdodDogcDEwMFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgY29uc3QgcnVsZSA9IHIoXCJSZWN0YW5nbGVcIiwgW1wiYXhpc1wiLCBcInRodW1iXCJdKTtcclxuICAgICAgICAgICAgcnVsZS5zZXRBbGwoe1xyXG4gICAgICAgICAgICAgICAgZmlsbE9wYWNpdHk6IDBcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHNldENvbG9yKHJ1bGUsIFwiZmlsbFwiLCBpYywgXCJhbHRlcm5hdGl2ZUJhY2tncm91bmRcIik7XHJcbiAgICAgICAgICAgIHJ1bGUuc3RhdGVzLmNyZWF0ZShcImhvdmVyXCIsIHsgZmlsbE9wYWNpdHk6IDAuMSB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcihcIlJlY3RhbmdsZVwiLCBbXCJheGlzXCIsIFwidGh1bWJcIiwgXCJ4XCJdKS5zZXRBbGwoe1xyXG4gICAgICAgICAgICBjdXJzb3JPdmVyU3R5bGU6IFwiZXctcmVzaXplXCJcclxuICAgICAgICB9KTtcclxuICAgICAgICByKFwiUmVjdGFuZ2xlXCIsIFtcImF4aXNcIiwgXCJ0aHVtYlwiLCBcInlcIl0pLnNldEFsbCh7XHJcbiAgICAgICAgICAgIGN1cnNvck92ZXJTdHlsZTogXCJucy1yZXNpemVcIlxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgY29uc3QgcnVsZSA9IHIoXCJHcmlkXCIpO1xyXG4gICAgICAgICAgICBydWxlLnNldEFsbCh7XHJcbiAgICAgICAgICAgICAgICBsb2NhdGlvbjogMCxcclxuICAgICAgICAgICAgICAgIHN0cm9rZU9wYWNpdHk6IDAuMTUsXHJcbiAgICAgICAgICAgICAgICBjcmlzcDogdHJ1ZVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgc2V0Q29sb3IocnVsZSwgXCJzdHJva2VcIiwgaWMsIFwiZ3JpZFwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBjb25zdCBydWxlID0gcihcIkdyaWRcIiwgW1wibWlub3JcIl0pO1xyXG4gICAgICAgICAgICBydWxlLnNldEFsbCh7XHJcbiAgICAgICAgICAgICAgICBsb2NhdGlvbjogMCxcclxuICAgICAgICAgICAgICAgIHN0cm9rZU9wYWNpdHk6IDAuMDcsXHJcbiAgICAgICAgICAgICAgICBjcmlzcDogdHJ1ZVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgc2V0Q29sb3IocnVsZSwgXCJzdHJva2VcIiwgaWMsIFwiZ3JpZFwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcihcIkdyaWRcIiwgW1wiYmFzZVwiXSkuc2V0QWxsKHtcclxuICAgICAgICAgICAgc3Ryb2tlT3BhY2l0eTogMC4zXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBjb25zdCBydWxlID0gcihcIkdyYXBoaWNzXCIsIFtcImF4aXNcIiwgXCJmaWxsXCJdKTtcclxuICAgICAgICAgICAgcnVsZS5zZXRBbGwoe1xyXG4gICAgICAgICAgICAgICAgdmlzaWJsZTogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBpc01lYXN1cmVkOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBcImFic29sdXRlXCIsXHJcbiAgICAgICAgICAgICAgICBmaWxsT3BhY2l0eTogMC4wNSxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHNldENvbG9yKHJ1bGUsIFwiZmlsbFwiLCBpYywgXCJhbHRlcm5hdGl2ZUJhY2tncm91bmRcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHIoXCJHcmFwaGljc1wiLCBbXCJheGlzXCIsIFwiZmlsbFwiLCBcInJhbmdlXCJdKS5zZXRBbGwoe1xyXG4gICAgICAgICAgICBpc01lYXN1cmVkOiB0cnVlXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLy8gaGlkZXMgYWxsIGVsZW1lbnRzIG9mIHNlcmllcyBheGlzIHJhbmdlXHJcbiAgICAgICAgcihcIkdyYXBoaWNzXCIsIFtcInNlcmllc1wiLCBcImZpbGxcIiwgXCJyYW5nZVwiXSkuc2V0QWxsKHtcclxuICAgICAgICAgICAgdmlzaWJsZTogZmFsc2UsXHJcbiAgICAgICAgICAgIGlzTWVhc3VyZWQ6IHRydWVcclxuICAgICAgICB9KTtcclxuICAgICAgICByKFwiR3JpZFwiLCBbXCJzZXJpZXNcIiwgXCJyYW5nZVwiXSkuc2V0QWxsKHtcclxuICAgICAgICAgICAgdmlzaWJsZTogZmFsc2VcclxuICAgICAgICB9KTtcclxuICAgICAgICByKFwiQXhpc1RpY2tcIiwgW1wic2VyaWVzXCIsIFwicmFuZ2VcIl0pLnNldEFsbCh7XHJcbiAgICAgICAgICAgIHZpc2libGU6IGZhbHNlXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcihcIkF4aXNMYWJlbFwiLCBbXCJzZXJpZXNcIiwgXCJyYW5nZVwiXSkuc2V0QWxsKHtcclxuICAgICAgICAgICAgdmlzaWJsZTogZmFsc2VcclxuICAgICAgICB9KTtcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGNvbnN0IHJ1bGUgPSByKFwiQXhpc1RpY2tcIik7XHJcbiAgICAgICAgICAgIHJ1bGUuc2V0QWxsKHtcclxuICAgICAgICAgICAgICAgIGxvY2F0aW9uOiAwLjUsXHJcbiAgICAgICAgICAgICAgICBtdWx0aUxvY2F0aW9uOiAwLFxyXG4gICAgICAgICAgICAgICAgc3Ryb2tlT3BhY2l0eTogMSxcclxuICAgICAgICAgICAgICAgIGlzTWVhc3VyZWQ6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgcG9zaXRpb246IFwiYWJzb2x1dGVcIixcclxuICAgICAgICAgICAgICAgIHZpc2libGU6IGZhbHNlXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBzZXRDb2xvcihydWxlLCBcInN0cm9rZVwiLCBpYywgXCJncmlkXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByKFwiQ2F0ZWdvcnlBeGlzXCIpLnNldEFsbCh7XHJcbiAgICAgICAgICAgIHN0YXJ0TG9jYXRpb246IDAsXHJcbiAgICAgICAgICAgIGVuZExvY2F0aW9uOiAxLFxyXG4gICAgICAgICAgICBmaWxsUnVsZTogKGRhdGFJdGVtLCBpbmRleCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYXhpc0ZpbGwgPSBkYXRhSXRlbS5nZXQoXCJheGlzRmlsbFwiKTtcclxuICAgICAgICAgICAgICAgIGlmIChheGlzRmlsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghJHR5cGUuaXNOdW1iZXIoaW5kZXgpIHx8IGluZGV4ICUgMiA9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGF4aXNGaWxsLnNldFByaXZhdGUoXCJ2aXNpYmxlXCIsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXhpc0ZpbGwuc2V0UHJpdmF0ZShcInZpc2libGVcIiwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGNvbnN0IGdyaWRJbnRlcnZhbHMgPSBbXHJcbiAgICAgICAgICAgIHsgdGltZVVuaXQ6IFwibWlsbGlzZWNvbmRcIiwgY291bnQ6IDEgfSxcclxuICAgICAgICAgICAgeyB0aW1lVW5pdDogXCJtaWxsaXNlY29uZFwiLCBjb3VudDogNSB9LFxyXG4gICAgICAgICAgICB7IHRpbWVVbml0OiBcIm1pbGxpc2Vjb25kXCIsIGNvdW50OiAxMCB9LFxyXG4gICAgICAgICAgICB7IHRpbWVVbml0OiBcIm1pbGxpc2Vjb25kXCIsIGNvdW50OiA1MCB9LFxyXG4gICAgICAgICAgICB7IHRpbWVVbml0OiBcIm1pbGxpc2Vjb25kXCIsIGNvdW50OiAxMDAgfSxcclxuICAgICAgICAgICAgeyB0aW1lVW5pdDogXCJtaWxsaXNlY29uZFwiLCBjb3VudDogNTAwIH0sXHJcbiAgICAgICAgICAgIHsgdGltZVVuaXQ6IFwic2Vjb25kXCIsIGNvdW50OiAxIH0sXHJcbiAgICAgICAgICAgIHsgdGltZVVuaXQ6IFwic2Vjb25kXCIsIGNvdW50OiA1IH0sXHJcbiAgICAgICAgICAgIHsgdGltZVVuaXQ6IFwic2Vjb25kXCIsIGNvdW50OiAxMCB9LFxyXG4gICAgICAgICAgICB7IHRpbWVVbml0OiBcInNlY29uZFwiLCBjb3VudDogMzAgfSxcclxuICAgICAgICAgICAgeyB0aW1lVW5pdDogXCJtaW51dGVcIiwgY291bnQ6IDEgfSxcclxuICAgICAgICAgICAgeyB0aW1lVW5pdDogXCJtaW51dGVcIiwgY291bnQ6IDUgfSxcclxuICAgICAgICAgICAgeyB0aW1lVW5pdDogXCJtaW51dGVcIiwgY291bnQ6IDEwIH0sXHJcbiAgICAgICAgICAgIHsgdGltZVVuaXQ6IFwibWludXRlXCIsIGNvdW50OiAxNSB9LFxyXG4gICAgICAgICAgICB7IHRpbWVVbml0OiBcIm1pbnV0ZVwiLCBjb3VudDogMzAgfSxcclxuICAgICAgICAgICAgeyB0aW1lVW5pdDogXCJob3VyXCIsIGNvdW50OiAxIH0sXHJcbiAgICAgICAgICAgIHsgdGltZVVuaXQ6IFwiaG91clwiLCBjb3VudDogMyB9LFxyXG4gICAgICAgICAgICB7IHRpbWVVbml0OiBcImhvdXJcIiwgY291bnQ6IDYgfSxcclxuICAgICAgICAgICAgeyB0aW1lVW5pdDogXCJob3VyXCIsIGNvdW50OiAxMiB9LFxyXG4gICAgICAgICAgICB7IHRpbWVVbml0OiBcImRheVwiLCBjb3VudDogMSB9LFxyXG4gICAgICAgICAgICB7IHRpbWVVbml0OiBcImRheVwiLCBjb3VudDogMiB9LFxyXG4gICAgICAgICAgICB7IHRpbWVVbml0OiBcImRheVwiLCBjb3VudDogMyB9LFxyXG4gICAgICAgICAgICB7IHRpbWVVbml0OiBcImRheVwiLCBjb3VudDogNCB9LFxyXG4gICAgICAgICAgICB7IHRpbWVVbml0OiBcImRheVwiLCBjb3VudDogNSB9LFxyXG4gICAgICAgICAgICB7IHRpbWVVbml0OiBcIndlZWtcIiwgY291bnQ6IDEgfSxcclxuICAgICAgICAgICAgeyB0aW1lVW5pdDogXCJtb250aFwiLCBjb3VudDogMSB9LFxyXG4gICAgICAgICAgICB7IHRpbWVVbml0OiBcIm1vbnRoXCIsIGNvdW50OiAyIH0sXHJcbiAgICAgICAgICAgIHsgdGltZVVuaXQ6IFwibW9udGhcIiwgY291bnQ6IDMgfSxcclxuICAgICAgICAgICAgeyB0aW1lVW5pdDogXCJtb250aFwiLCBjb3VudDogNiB9LFxyXG4gICAgICAgICAgICB7IHRpbWVVbml0OiBcInllYXJcIiwgY291bnQ6IDEgfSxcclxuICAgICAgICAgICAgeyB0aW1lVW5pdDogXCJ5ZWFyXCIsIGNvdW50OiAyIH0sXHJcbiAgICAgICAgICAgIHsgdGltZVVuaXQ6IFwieWVhclwiLCBjb3VudDogNSB9LFxyXG4gICAgICAgICAgICB7IHRpbWVVbml0OiBcInllYXJcIiwgY291bnQ6IDEwIH0sXHJcbiAgICAgICAgICAgIHsgdGltZVVuaXQ6IFwieWVhclwiLCBjb3VudDogNTAgfSxcclxuICAgICAgICAgICAgeyB0aW1lVW5pdDogXCJ5ZWFyXCIsIGNvdW50OiAxMDAgfSxcclxuICAgICAgICAgICAgeyB0aW1lVW5pdDogXCJ5ZWFyXCIsIGNvdW50OiAyMDAgfSxcclxuICAgICAgICAgICAgeyB0aW1lVW5pdDogXCJ5ZWFyXCIsIGNvdW50OiA1MDAgfSxcclxuICAgICAgICAgICAgeyB0aW1lVW5pdDogXCJ5ZWFyXCIsIGNvdW50OiAxMDAwIH0sXHJcbiAgICAgICAgICAgIHsgdGltZVVuaXQ6IFwieWVhclwiLCBjb3VudDogMjAwMCB9LFxyXG4gICAgICAgICAgICB7IHRpbWVVbml0OiBcInllYXJcIiwgY291bnQ6IDUwMDAgfSxcclxuICAgICAgICAgICAgeyB0aW1lVW5pdDogXCJ5ZWFyXCIsIGNvdW50OiAxMDAwMCB9LFxyXG4gICAgICAgICAgICB7IHRpbWVVbml0OiBcInllYXJcIiwgY291bnQ6IDEwMDAwMCB9XHJcbiAgICAgICAgXTtcclxuICAgICAgICBjb25zdCBkYXRlRm9ybWF0cyA9IHtcclxuICAgICAgICAgICAgXCJtaWxsaXNlY29uZFwiOiBsYW5ndWFnZS50cmFuc2xhdGUoXCJfZGF0ZV9taWxsaXNlY29uZFwiKSxcclxuICAgICAgICAgICAgXCJzZWNvbmRcIjogbGFuZ3VhZ2UudHJhbnNsYXRlKFwiX2RhdGVfc2Vjb25kXCIpLFxyXG4gICAgICAgICAgICBcIm1pbnV0ZVwiOiBsYW5ndWFnZS50cmFuc2xhdGUoXCJfZGF0ZV9taW51dGVcIiksXHJcbiAgICAgICAgICAgIFwiaG91clwiOiBsYW5ndWFnZS50cmFuc2xhdGUoXCJfZGF0ZV9ob3VyXCIpLFxyXG4gICAgICAgICAgICBcImRheVwiOiBsYW5ndWFnZS50cmFuc2xhdGUoXCJfZGF0ZV9kYXlcIiksXHJcbiAgICAgICAgICAgIFwid2Vla1wiOiBsYW5ndWFnZS50cmFuc2xhdGUoXCJfZGF0ZV9kYXlcIiksXHJcbiAgICAgICAgICAgIFwibW9udGhcIjogbGFuZ3VhZ2UudHJhbnNsYXRlKFwiX2RhdGVfbW9udGhcIiksXHJcbiAgICAgICAgICAgIFwieWVhclwiOiBsYW5ndWFnZS50cmFuc2xhdGUoXCJfZGF0ZV95ZWFyXCIpXHJcbiAgICAgICAgfTtcclxuICAgICAgICBjb25zdCBwZXJpb2RDaGFuZ2VEYXRlRm9ybWF0cyA9IHtcclxuICAgICAgICAgICAgXCJtaWxsaXNlY29uZFwiOiBsYW5ndWFnZS50cmFuc2xhdGUoXCJfZGF0ZV9taWxsaXNlY29uZFwiKSxcclxuICAgICAgICAgICAgXCJzZWNvbmRcIjogbGFuZ3VhZ2UudHJhbnNsYXRlKFwiX2RhdGVfc2Vjb25kXCIpLFxyXG4gICAgICAgICAgICBcIm1pbnV0ZVwiOiBsYW5ndWFnZS50cmFuc2xhdGUoXCJfZGF0ZV9taW51dGVcIiksXHJcbiAgICAgICAgICAgIFwiaG91clwiOiBsYW5ndWFnZS50cmFuc2xhdGUoXCJfZGF0ZV9kYXlcIiksXHJcbiAgICAgICAgICAgIFwiZGF5XCI6IGxhbmd1YWdlLnRyYW5zbGF0ZShcIl9kYXRlX2RheVwiKSxcclxuICAgICAgICAgICAgXCJ3ZWVrXCI6IGxhbmd1YWdlLnRyYW5zbGF0ZShcIl9kYXRlX2RheVwiKSxcclxuICAgICAgICAgICAgXCJtb250aFwiOiBsYW5ndWFnZS50cmFuc2xhdGUoXCJfZGF0ZV9tb250aFwiKSArIFwiIFwiICsgbGFuZ3VhZ2UudHJhbnNsYXRlKFwiX2RhdGVfeWVhclwiKSxcclxuICAgICAgICAgICAgXCJ5ZWFyXCI6IGxhbmd1YWdlLnRyYW5zbGF0ZShcIl9kYXRlX3llYXJcIilcclxuICAgICAgICB9O1xyXG4gICAgICAgIGNvbnN0IHRvb2x0aXBEYXRlRm9ybWF0cyA9IHtcclxuICAgICAgICAgICAgXCJtaWxsaXNlY29uZFwiOiBsYW5ndWFnZS50cmFuc2xhdGUoXCJfZGF0ZV9taWxsaXNlY29uZF9mdWxsXCIpLFxyXG4gICAgICAgICAgICBcInNlY29uZFwiOiBsYW5ndWFnZS50cmFuc2xhdGUoXCJfZGF0ZV9zZWNvbmRfZnVsbFwiKSxcclxuICAgICAgICAgICAgXCJtaW51dGVcIjogbGFuZ3VhZ2UudHJhbnNsYXRlKFwiX2RhdGVfbWludXRlX2Z1bGxcIiksXHJcbiAgICAgICAgICAgIFwiaG91clwiOiBsYW5ndWFnZS50cmFuc2xhdGUoXCJfZGF0ZV9ob3VyX2Z1bGxcIiksXHJcbiAgICAgICAgICAgIFwiZGF5XCI6IGxhbmd1YWdlLnRyYW5zbGF0ZShcIl9kYXRlX2RheV9mdWxsXCIpLFxyXG4gICAgICAgICAgICBcIndlZWtcIjogbGFuZ3VhZ2UudHJhbnNsYXRlKFwiX2RhdGVfd2Vla19mdWxsXCIpLFxyXG4gICAgICAgICAgICBcIm1vbnRoXCI6IGxhbmd1YWdlLnRyYW5zbGF0ZShcIl9kYXRlX21vbnRoX2Z1bGxcIiksXHJcbiAgICAgICAgICAgIFwieWVhclwiOiBsYW5ndWFnZS50cmFuc2xhdGUoXCJfZGF0ZV95ZWFyXCIpXHJcbiAgICAgICAgfTtcclxuICAgICAgICByKFwiQ2F0ZWdvcnlEYXRlQXhpc1wiKS5zZXRBbGwoe1xyXG4gICAgICAgICAgICBtYXJrVW5pdENoYW5nZTogdHJ1ZSxcclxuICAgICAgICAgICAgZ3JpZEludGVydmFsczogJGFycmF5LmNvcHkoZ3JpZEludGVydmFscyksXHJcbiAgICAgICAgICAgIGRhdGVGb3JtYXRzOiAkb2JqZWN0LmNvcHkoZGF0ZUZvcm1hdHMpLFxyXG4gICAgICAgICAgICBwZXJpb2RDaGFuZ2VEYXRlRm9ybWF0czogJG9iamVjdC5jb3B5KHBlcmlvZENoYW5nZURhdGVGb3JtYXRzKVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHIoXCJEYXRlQXhpc1wiKS5zZXRBbGwoe1xyXG4gICAgICAgICAgICBtYXhab29tRmFjdG9yOiBudWxsLFxyXG4gICAgICAgICAgICBzdHJpY3RNaW5NYXg6IHRydWUsXHJcbiAgICAgICAgICAgIHN0YXJ0TG9jYXRpb246IDAsXHJcbiAgICAgICAgICAgIGVuZExvY2F0aW9uOiAxLFxyXG4gICAgICAgICAgICBtYXJrVW5pdENoYW5nZTogdHJ1ZSxcclxuICAgICAgICAgICAgZ3JvdXBEYXRhOiBmYWxzZSxcclxuICAgICAgICAgICAgZ3JvdXBDb3VudDogNTAwLFxyXG4gICAgICAgICAgICBncmlkSW50ZXJ2YWxzOiAkYXJyYXkuY29weShncmlkSW50ZXJ2YWxzKSxcclxuICAgICAgICAgICAgZGF0ZUZvcm1hdHM6ICRvYmplY3QuY29weShkYXRlRm9ybWF0cyksXHJcbiAgICAgICAgICAgIHBlcmlvZENoYW5nZURhdGVGb3JtYXRzOiAkb2JqZWN0LmNvcHkocGVyaW9kQ2hhbmdlRGF0ZUZvcm1hdHMpLFxyXG4gICAgICAgICAgICB0b29sdGlwRGF0ZUZvcm1hdHM6IHRvb2x0aXBEYXRlRm9ybWF0cyxcclxuICAgICAgICAgICAgZ3JvdXBJbnRlcnZhbHM6IFtcclxuICAgICAgICAgICAgICAgIHsgdGltZVVuaXQ6IFwibWlsbGlzZWNvbmRcIiwgY291bnQ6IDEgfSxcclxuICAgICAgICAgICAgICAgIHsgdGltZVVuaXQ6IFwibWlsbGlzZWNvbmRcIiwgY291bnQ6IDEwIH0sXHJcbiAgICAgICAgICAgICAgICB7IHRpbWVVbml0OiBcIm1pbGxpc2Vjb25kXCIsIGNvdW50OiAxMDAgfSxcclxuICAgICAgICAgICAgICAgIHsgdGltZVVuaXQ6IFwic2Vjb25kXCIsIGNvdW50OiAxIH0sXHJcbiAgICAgICAgICAgICAgICB7IHRpbWVVbml0OiBcInNlY29uZFwiLCBjb3VudDogMTAgfSxcclxuICAgICAgICAgICAgICAgIHsgdGltZVVuaXQ6IFwibWludXRlXCIsIGNvdW50OiAxIH0sXHJcbiAgICAgICAgICAgICAgICB7IHRpbWVVbml0OiBcIm1pbnV0ZVwiLCBjb3VudDogMTAgfSxcclxuICAgICAgICAgICAgICAgIHsgdGltZVVuaXQ6IFwiaG91clwiLCBjb3VudDogMSB9LFxyXG4gICAgICAgICAgICAgICAgeyB0aW1lVW5pdDogXCJkYXlcIiwgY291bnQ6IDEgfSxcclxuICAgICAgICAgICAgICAgIHsgdGltZVVuaXQ6IFwid2Vla1wiLCBjb3VudDogMSB9LFxyXG4gICAgICAgICAgICAgICAgeyB0aW1lVW5pdDogXCJtb250aFwiLCBjb3VudDogMSB9LFxyXG4gICAgICAgICAgICAgICAgeyB0aW1lVW5pdDogXCJ5ZWFyXCIsIGNvdW50OiAxIH1cclxuICAgICAgICAgICAgXSxcclxuICAgICAgICAgICAgZmlsbFJ1bGU6IChkYXRhSXRlbSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYXhpc0ZpbGwgPSBkYXRhSXRlbS5nZXQoXCJheGlzRmlsbFwiKTtcclxuICAgICAgICAgICAgICAgIGlmIChheGlzRmlsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGF4aXMgPSBkYXRhSXRlbS5jb21wb25lbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBkYXRhSXRlbS5nZXQoXCJ2YWx1ZVwiKTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBlbmRWYWx1ZSA9IGRhdGFJdGVtLmdldChcImVuZFZhbHVlXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGludGVydmFsRHVyYXRpb24gPSBheGlzLmludGVydmFsRHVyYXRpb24oKTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBiYXNlSW50ZXJ2YWwgPSBheGlzLmdldFByaXZhdGUoXCJiYXNlSW50ZXJ2YWxcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZ3JpZEludGVydmFsID0gYXhpcy5nZXRQcml2YXRlKFwiZ3JpZEludGVydmFsXCIsIGJhc2VJbnRlcnZhbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IG1pbiA9IGF4aXMuZ2V0UHJpdmF0ZShcIm1pblwiLCAwKTtcclxuICAgICAgICAgICAgICAgICAgICBtaW4gPSAkdGltZS5yb3VuZChuZXcgRGF0ZShtaW4pLCBncmlkSW50ZXJ2YWwudGltZVVuaXQsIGdyaWRJbnRlcnZhbC5jb3VudCwgdGhpcy5fcm9vdC5sb2NhbGUuZmlyc3REYXlPZldlZWssIHRoaXMuX3Jvb3QudXRjLCB1bmRlZmluZWQsIHRoaXMuX3Jvb3QudGltZXpvbmUpLmdldFRpbWUoKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT0gbnVsbCAmJiBlbmRWYWx1ZSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbCA9IE1hdGgucm91bmQoTWF0aC5yb3VuZCgodmFsdWUgLSBtaW4pIC8gaW50ZXJ2YWxEdXJhdGlvbikpIC8gMjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbCA9PSBNYXRoLnJvdW5kKHZhbCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF4aXNGaWxsLnNldFByaXZhdGUoXCJ2aXNpYmxlXCIsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXhpc0ZpbGwuc2V0UHJpdmF0ZShcInZpc2libGVcIiwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcihcIkdhcGxlc3NEYXRlQXhpc1wiKS5zZXRBbGwoe1xyXG4gICAgICAgICAgICBmaWxsUnVsZTogKGRhdGFJdGVtKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBheGlzRmlsbCA9IGRhdGFJdGVtLmdldChcImF4aXNGaWxsXCIpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGF4aXNGaWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaW5kZXggPSBkYXRhSXRlbS5nZXQoXCJpbmRleFwiKTtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgdmlzaWJsZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghJHR5cGUuaXNOdW1iZXIoaW5kZXgpIHx8IGluZGV4ICUgMiA9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpc2libGUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBheGlzRmlsbC5zZXRQcml2YXRlKFwidmlzaWJsZVwiLCB2aXNpYmxlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHIoXCJWYWx1ZUF4aXNcIikuc2V0QWxsKHtcclxuICAgICAgICAgICAgYmFzZVZhbHVlOiAwLFxyXG4gICAgICAgICAgICBsb2dhcml0aG1pYzogZmFsc2UsXHJcbiAgICAgICAgICAgIHN0cmljdE1pbk1heDogZmFsc2UsXHJcbiAgICAgICAgICAgIGF1dG9ab29tOiB0cnVlLFxyXG4gICAgICAgICAgICBmaWxsUnVsZTogKGRhdGFJdGVtKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBheGlzRmlsbCA9IGRhdGFJdGVtLmdldChcImF4aXNGaWxsXCIpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGF4aXNGaWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYXhpcyA9IGRhdGFJdGVtLmNvbXBvbmVudDtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGRhdGFJdGVtLmdldChcInZhbHVlXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN0ZXAgPSBheGlzLmdldFByaXZhdGUoXCJzdGVwXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICgkdHlwZS5pc051bWJlcih2YWx1ZSkgJiYgJHR5cGUuaXNOdW1iZXIoc3RlcCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCRtYXRoLnJvdW5kKHZhbHVlIC8gc3RlcCAvIDIsIDUpID09IE1hdGgucm91bmQodmFsdWUgLyBzdGVwIC8gMikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF4aXNGaWxsLnNldFByaXZhdGUoXCJ2aXNpYmxlXCIsIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF4aXNGaWxsLnNldFByaXZhdGUoXCJ2aXNpYmxlXCIsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcihcIkR1cmF0aW9uQXhpc1wiKS5zZXRBbGwoe1xyXG4gICAgICAgICAgICBiYXNlVW5pdDogXCJzZWNvbmRcIlxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgICAgICAqIGNoYXJ0cy94eTogU2VyaWVzXHJcbiAgICAgICAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgcihcIlhZU2VyaWVzXCIpLnNldEFsbCh7XHJcbiAgICAgICAgICAgIG1hc2tCdWxsZXRzOiB0cnVlLFxyXG4gICAgICAgICAgICBzdGFja1RvTmVnYXRpdmU6IHRydWUsXHJcbiAgICAgICAgICAgIGxvY2F0aW9uWDogMC41LFxyXG4gICAgICAgICAgICBsb2NhdGlvblk6IDAuNSxcclxuICAgICAgICAgICAgc25hcFRvb2x0aXA6IGZhbHNlLFxyXG4gICAgICAgICAgICBvcGVuVmFsdWVYR3JvdXBlZDogXCJvcGVuXCIsXHJcbiAgICAgICAgICAgIG9wZW5WYWx1ZVlHcm91cGVkOiBcIm9wZW5cIixcclxuICAgICAgICAgICAgdmFsdWVYR3JvdXBlZDogXCJjbG9zZVwiLFxyXG4gICAgICAgICAgICB2YWx1ZVlHcm91cGVkOiBcImNsb3NlXCIsXHJcbiAgICAgICAgICAgIHNlcmllc1Rvb2x0aXBUYXJnZXQ6IFwic2VyaWVzXCJcclxuICAgICAgICB9KTtcclxuICAgICAgICByKFwiQmFzZUNvbHVtblNlcmllc1wiKS5zZXRBbGwoe1xyXG4gICAgICAgICAgICBhZGp1c3RCdWxsZXRQb3NpdGlvbjogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHIoXCJDb2x1bW5TZXJpZXNcIikuc2V0QWxsKHtcclxuICAgICAgICAgICAgY2x1c3RlcmVkOiB0cnVlXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcihcIlJvdW5kZWRSZWN0YW5nbGVcIiwgW1wic2VyaWVzXCIsIFwiY29sdW1uXCJdKS5zZXRBbGwoe1xyXG4gICAgICAgICAgICBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLFxyXG4gICAgICAgICAgICBpc01lYXN1cmVkOiBmYWxzZSxcclxuICAgICAgICAgICAgd2lkdGg6IHBlcmNlbnQoNzApLFxyXG4gICAgICAgICAgICBoZWlnaHQ6IHBlcmNlbnQoNzApLFxyXG4gICAgICAgICAgICBzdHJva2VXaWR0aDogMSxcclxuICAgICAgICAgICAgc3Ryb2tlT3BhY2l0eTogMSxcclxuICAgICAgICAgICAgY29ybmVyUmFkaXVzQkw6IDAsXHJcbiAgICAgICAgICAgIGNvcm5lclJhZGl1c1RMOiAwLFxyXG4gICAgICAgICAgICBjb3JuZXJSYWRpdXNCUjogMCxcclxuICAgICAgICAgICAgY29ybmVyUmFkaXVzVFI6IDAsXHJcbiAgICAgICAgICAgIGZpbGxPcGFjaXR5OiAxLFxyXG4gICAgICAgICAgICByb2xlOiBcImZpZ3VyZVwiXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcihcIkxpbmVTZXJpZXNcIikuc2V0QWxsKHtcclxuICAgICAgICAgICAgY29ubmVjdDogdHJ1ZSxcclxuICAgICAgICAgICAgYXV0b0dhcENvdW50OiAxLjEsXHJcbiAgICAgICAgICAgIHN0YWNrVG9OZWdhdGl2ZTogZmFsc2VcclxuICAgICAgICB9KTtcclxuICAgICAgICByKFwiR3JhcGhpY3NcIiwgW1wic2VyaWVzXCIsIFwic3Ryb2tlXCJdKS5zZXRBbGwoe1xyXG4gICAgICAgICAgICBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLFxyXG4gICAgICAgICAgICBzdHJva2VXaWR0aDogMSxcclxuICAgICAgICAgICAgc3Ryb2tlT3BhY2l0eTogMSxcclxuICAgICAgICAgICAgaXNNZWFzdXJlZDogZmFsc2VcclxuICAgICAgICB9KTtcclxuICAgICAgICByKFwiR3JhcGhpY3NcIiwgW1wic2VyaWVzXCIsIFwiZmlsbFwiXSkuc2V0QWxsKHtcclxuICAgICAgICAgICAgdmlzaWJsZTogZmFsc2UsXHJcbiAgICAgICAgICAgIGZpbGxPcGFjaXR5OiAwLFxyXG4gICAgICAgICAgICBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLFxyXG4gICAgICAgICAgICBzdHJva2VXaWR0aDogMCxcclxuICAgICAgICAgICAgc3Ryb2tlT3BhY2l0eTogMCxcclxuICAgICAgICAgICAgaXNNZWFzdXJlZDogZmFsc2VcclxuICAgICAgICB9KTtcclxuICAgICAgICByKFwiR3JhcGhpY3NcIiwgW1wibGluZVwiLCBcInNlcmllc1wiLCBcImxlZ2VuZFwiLCBcIm1hcmtlclwiLCBcInN0cm9rZVwiXSkuc2V0QWxsKHtcclxuICAgICAgICAgICAgZHJhdzogKGRpc3BsYXksIHNwcml0ZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcGFyZW50ID0gc3ByaXRlLnBhcmVudDtcclxuICAgICAgICAgICAgICAgIGlmIChwYXJlbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBoID0gcGFyZW50LmhlaWdodCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHcgPSBwYXJlbnQud2lkdGgoKTtcclxuICAgICAgICAgICAgICAgICAgICBkaXNwbGF5Lm1vdmVUbygwLCBoIC8gMik7XHJcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheS5saW5lVG8odywgaCAvIDIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBjb25zdCBydWxlID0gcihcIkdyYXBoaWNzXCIsIFtcImxpbmVcIiwgXCJzZXJpZXNcIiwgXCJsZWdlbmRcIiwgXCJtYXJrZXJcIiwgXCJzdHJva2VcIl0pLnN0YXRlcy5jcmVhdGUoXCJkaXNhYmxlZFwiLCB7fSk7XHJcbiAgICAgICAgICAgIHNldENvbG9yKHJ1bGUsIFwic3Ryb2tlXCIsIGljLCBcImRpc2FibGVkXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByKFwiR3JhcGhpY3NcIiwgW1wibGluZVwiLCBcInNlcmllc1wiLCBcImxlZ2VuZFwiLCBcIm1hcmtlclwiLCBcImZpbGxcIl0pLnNldEFsbCh7XHJcbiAgICAgICAgICAgIGRyYXc6IChkaXNwbGF5LCBzcHJpdGUpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHBhcmVudCA9IHNwcml0ZS5wYXJlbnQ7XHJcbiAgICAgICAgICAgICAgICBpZiAocGFyZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaCA9IHBhcmVudC5oZWlnaHQoKTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB3ID0gcGFyZW50LndpZHRoKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheS5tb3ZlVG8oMCwgMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheS5saW5lVG8odywgMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheS5saW5lVG8odywgaCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheS5saW5lVG8oMCwgaCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheS5saW5lVG8oMCwgMCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGNvbnN0IHJ1bGUgPSByKFwiR3JhcGhpY3NcIiwgW1wibGluZVwiLCBcInNlcmllc1wiLCBcImxlZ2VuZFwiLCBcIm1hcmtlclwiLCBcImZpbGxcIl0pLnN0YXRlcy5jcmVhdGUoXCJkaXNhYmxlZFwiLCB7fSk7XHJcbiAgICAgICAgICAgIHNldENvbG9yKHJ1bGUsIFwic3Ryb2tlXCIsIGljLCBcImRpc2FibGVkXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByKFwiU21vb3RoZWRYWUxpbmVTZXJpZXNcIikuc2V0QWxsKHtcclxuICAgICAgICAgICAgdGVuc2lvbjogMC41XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcihcIlNtb290aGVkWExpbmVTZXJpZXNcIikuc2V0QWxsKHtcclxuICAgICAgICAgICAgdGVuc2lvbjogMC41XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcihcIlNtb290aGVkWUxpbmVTZXJpZXNcIikuc2V0QWxsKHtcclxuICAgICAgICAgICAgdGVuc2lvbjogMC41XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcihcIkNhbmRsZXN0aWNrXCIpLnNldEFsbCh7XHJcbiAgICAgICAgICAgIHBvc2l0aW9uOiBcImFic29sdXRlXCIsXHJcbiAgICAgICAgICAgIGlzTWVhc3VyZWQ6IGZhbHNlLFxyXG4gICAgICAgICAgICB3aWR0aDogcGVyY2VudCg1MCksXHJcbiAgICAgICAgICAgIGhlaWdodDogcGVyY2VudCg1MCksXHJcbiAgICAgICAgICAgIHN0cm9rZVdpZHRoOiAxLFxyXG4gICAgICAgICAgICBzdHJva2VPcGFjaXR5OiAxLFxyXG4gICAgICAgICAgICBjb3JuZXJSYWRpdXNCTDogMCxcclxuICAgICAgICAgICAgY29ybmVyUmFkaXVzVEw6IDAsXHJcbiAgICAgICAgICAgIGNvcm5lclJhZGl1c0JSOiAwLFxyXG4gICAgICAgICAgICBjb3JuZXJSYWRpdXNUUjogMCxcclxuICAgICAgICAgICAgZmlsbE9wYWNpdHk6IDEsXHJcbiAgICAgICAgICAgIHJvbGU6IFwiZmlndXJlXCJcclxuICAgICAgICB9KTtcclxuICAgICAgICByKFwiT0hMQ1wiKS5zZXRBbGwoe1xyXG4gICAgICAgICAgICB3aWR0aDogcGVyY2VudCg4MCksXHJcbiAgICAgICAgICAgIGhlaWdodDogcGVyY2VudCg4MClcclxuICAgICAgICB9KTtcclxuICAgICAgICByKFwiQ2FuZGxlc3RpY2tTZXJpZXNcIikuc2V0QWxsKHtcclxuICAgICAgICAgICAgbG93VmFsdWVYR3JvdXBlZDogXCJsb3dcIixcclxuICAgICAgICAgICAgbG93VmFsdWVZR3JvdXBlZDogXCJsb3dcIixcclxuICAgICAgICAgICAgaGlnaFZhbHVlWEdyb3VwZWQ6IFwiaGlnaFwiLFxyXG4gICAgICAgICAgICBoaWdoVmFsdWVZR3JvdXBlZDogXCJoaWdoXCIsXHJcbiAgICAgICAgICAgIG9wZW5WYWx1ZVhHcm91cGVkOiBcIm9wZW5cIixcclxuICAgICAgICAgICAgb3BlblZhbHVlWUdyb3VwZWQ6IFwib3BlblwiLFxyXG4gICAgICAgICAgICB2YWx1ZVhHcm91cGVkOiBcImNsb3NlXCIsXHJcbiAgICAgICAgICAgIHZhbHVlWUdyb3VwZWQ6IFwiY2xvc2VcIlxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8vIFRoZXNlIHJ1bGVzIGNhbiBiZSB1c2VkIGZvciByZWd1bGFyIGNvbHVtbnMsIHRvb1xyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgY29uc3QgcnVsZSA9IHIoXCJSZWN0YW5nbGVcIiwgW1wiY29sdW1uXCIsIFwiYXV0b2NvbG9yXCJdKS5zdGF0ZXMuY3JlYXRlKFwicmlzZUZyb21PcGVuXCIsIHt9KTtcclxuICAgICAgICAgICAgc2V0Q29sb3IocnVsZSwgXCJmaWxsXCIsIGljLCBcInBvc2l0aXZlXCIpO1xyXG4gICAgICAgICAgICBzZXRDb2xvcihydWxlLCBcInN0cm9rZVwiLCBpYywgXCJwb3NpdGl2ZVwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBjb25zdCBydWxlID0gcihcIlJlY3RhbmdsZVwiLCBbXCJjb2x1bW5cIiwgXCJhdXRvY29sb3JcIl0pLnN0YXRlcy5jcmVhdGUoXCJkcm9wRnJvbU9wZW5cIiwge30pO1xyXG4gICAgICAgICAgICBzZXRDb2xvcihydWxlLCBcImZpbGxcIiwgaWMsIFwibmVnYXRpdmVcIik7XHJcbiAgICAgICAgICAgIHNldENvbG9yKHJ1bGUsIFwic3Ryb2tlXCIsIGljLCBcIm5lZ2F0aXZlXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBIb2xsb3dcclxuICAgICAgICByKFwiUmVjdGFuZ2xlXCIsIFtcImNvbHVtblwiLCBcImF1dG9jb2xvclwiLCBcInByb1wiXSkuc3RhdGVzLmNyZWF0ZShcInJpc2VGcm9tT3BlblwiLCB7IGZpbGxPcGFjaXR5OiAwIH0pO1xyXG4gICAgICAgIHIoXCJSZWN0YW5nbGVcIiwgW1wiY29sdW1uXCIsIFwiYXV0b2NvbG9yXCIsIFwicHJvXCJdKS5zdGF0ZXMuY3JlYXRlKFwiZHJvcEZyb21PcGVuXCIsIHsgZmlsbE9wYWNpdHk6IDEgfSk7XHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBjb25zdCBydWxlID0gcihcIlJlY3RhbmdsZVwiLCBbXCJjb2x1bW5cIiwgXCJhdXRvY29sb3JcIiwgXCJwcm9cIl0pLnN0YXRlcy5jcmVhdGUoXCJyaXNlRnJvbVByZXZpb3VzXCIsIHt9KTtcclxuICAgICAgICAgICAgc2V0Q29sb3IocnVsZSwgXCJmaWxsXCIsIGljLCBcInBvc2l0aXZlXCIpO1xyXG4gICAgICAgICAgICBzZXRDb2xvcihydWxlLCBcInN0cm9rZVwiLCBpYywgXCJwb3NpdGl2ZVwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBjb25zdCBydWxlID0gcihcIlJlY3RhbmdsZVwiLCBbXCJjb2x1bW5cIiwgXCJhdXRvY29sb3JcIiwgXCJwcm9cIl0pLnN0YXRlcy5jcmVhdGUoXCJkcm9wRnJvbVByZXZpb3VzXCIsIHt9KTtcclxuICAgICAgICAgICAgc2V0Q29sb3IocnVsZSwgXCJmaWxsXCIsIGljLCBcIm5lZ2F0aXZlXCIpO1xyXG4gICAgICAgICAgICBzZXRDb2xvcihydWxlLCBcInN0cm9rZVwiLCBpYywgXCJuZWdhdGl2ZVwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gQVhJUyBSQU5HRSBHUklQXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBjb25zdCBydWxlID0gcihcIlJvdW5kZWRSZWN0YW5nbGVcIiwgW1wicmFuZ2VncmlwXCJdKTtcclxuICAgICAgICAgICAgcnVsZS5zZXRBbGwoe1xyXG4gICAgICAgICAgICAgICAgc3Ryb2tlT3BhY2l0eTogMCxcclxuICAgICAgICAgICAgICAgIGZpbGxPcGFjaXR5OiAwLFxyXG4gICAgICAgICAgICAgICAgc3Ryb2tlV2lkdGg6IDEsXHJcbiAgICAgICAgICAgICAgICB3aWR0aDogMTIsXHJcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IDEyXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGNvbnN0IHJ1bGUgPSByKFwiR3JhcGhpY3NcIiwgW1wicmFuZ2VncmlwXCIsIFwiYnV0dG9uXCIsIFwiaWNvblwiXSk7XHJcbiAgICAgICAgICAgIHJ1bGUuc2V0QWxsKHtcclxuICAgICAgICAgICAgICAgIGludGVyYWN0aXZlOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIGNyaXNwOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgc3Ryb2tlT3BhY2l0eTogMC41LFxyXG4gICAgICAgICAgICAgICAgZHJhdzogKGRpc3BsYXkpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBkaXNwbGF5Lm1vdmVUbygwLCAwLjUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGRpc3BsYXkubGluZVRvKDAsIDEyLjUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGRpc3BsYXkubW92ZVRvKDIsIDAuNSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheS5saW5lVG8oMiwgMTIuNSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheS5tb3ZlVG8oNCwgMC41KTtcclxuICAgICAgICAgICAgICAgICAgICBkaXNwbGF5LmxpbmVUbyg0LCAxMi41KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHNldENvbG9yKHJ1bGUsIFwic3Ryb2tlXCIsIGljLCBcInNlY29uZGFyeUJ1dHRvblRleHRcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHIoXCJCdXR0b25cIiwgW1wicmFuZ2VncmlwXCJdKS5zZXRBbGwoe1xyXG4gICAgICAgICAgICBkcmFnZ2FibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHBhZGRpbmdUb3A6IDAsXHJcbiAgICAgICAgICAgIHBhZGRpbmdCb3R0b206IDBcclxuICAgICAgICB9KTtcclxuICAgICAgICByKFwiQnV0dG9uXCIsIFtcInJhbmdlZ3JpcFwiLCBcInZlcnRpY2FsXCJdKS5zZXRBbGwoe1xyXG4gICAgICAgICAgICByb3RhdGlvbjogOTAsXHJcbiAgICAgICAgICAgIGN1cnNvck92ZXJTdHlsZTogXCJucy1yZXNpemVcIixcclxuICAgICAgICAgICAgY2VudGVyWDogcDUwXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcihcIkJ1dHRvblwiLCBbXCJyYW5nZWdyaXBcIiwgXCJob3Jpem9udGFsXCJdKS5zZXRBbGwoe1xyXG4gICAgICAgICAgICBjdXJzb3JPdmVyU3R5bGU6IFwiZXctcmVzaXplXCIsXHJcbiAgICAgICAgICAgIGNlbnRlclg6IHA1MFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHIoXCJCdXR0b25cIiwgW1wicmFuZ2VncmlwXCIsIFwidmVydGljYWxcIiwgXCJsZWZ0XCJdKS5zZXRBbGwoe1xyXG4gICAgICAgICAgICBjZW50ZXJZOiBwMTAwXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcihcIkJ1dHRvblwiLCBbXCJyYW5nZWdyaXBcIiwgXCJ2ZXJ0aWNhbFwiLCBcInJpZ2h0XCJdKS5zZXRBbGwoe1xyXG4gICAgICAgICAgICBjZW50ZXJZOiAwXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcihcIkJ1dHRvblwiLCBbXCJyYW5nZWdyaXBcIiwgXCJob3Jpem9udGFsXCIsIFwidG9wXCJdKS5zZXRBbGwoe1xyXG4gICAgICAgICAgICBjZW50ZXJZOiAwXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcihcIkJ1dHRvblwiLCBbXCJyYW5nZWdyaXBcIiwgXCJob3Jpem9udGFsXCIsIFwiYm90dG9tXCJdKS5zZXRBbGwoe1xyXG4gICAgICAgICAgICBjZW50ZXJZOiBwMTAwXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9WFlDaGFydERlZmF1bHRUaGVtZS5qcy5tYXAiLCJpbXBvcnQgeyBDb250YWluZXIgfSBmcm9tIFwiLi4vLi4vY29yZS9yZW5kZXIvQ29udGFpbmVyXCI7XHJcbmltcG9ydCB7IHAxMDAgfSBmcm9tIFwiLi4vLi4vY29yZS91dGlsL1BlcmNlbnRcIjtcclxuaW1wb3J0IHsgR3JhcGhpY3MgfSBmcm9tIFwiLi4vLi4vY29yZS9yZW5kZXIvR3JhcGhpY3NcIjtcclxuaW1wb3J0IHsgR3JpZCB9IGZyb20gXCIuL2F4ZXMvR3JpZFwiO1xyXG4vL2ltcG9ydCB7IEFuaW1hdGlvbnMgfSBmcm9tIFwiLi4vY29yZS91dGlsL0FuaW1hdGlvblwiO1xyXG5pbXBvcnQgKiBhcyAkdHlwZSBmcm9tIFwiLi4vLi4vY29yZS91dGlsL1R5cGVcIjtcclxuaW1wb3J0ICogYXMgJHV0aWxzIGZyb20gXCIuLi8uLi9jb3JlL3V0aWwvVXRpbHNcIjtcclxuaW1wb3J0ICogYXMgJG1hdGggZnJvbSBcIi4uLy4uL2NvcmUvdXRpbC9NYXRoXCI7XHJcbmltcG9ydCAqIGFzICRhcnJheSBmcm9tIFwiLi4vLi4vY29yZS91dGlsL0FycmF5XCI7XHJcbmltcG9ydCAqIGFzICRvYmplY3QgZnJvbSBcIi4uLy4uL2NvcmUvdXRpbC9PYmplY3RcIjtcclxuLyoqXHJcbiAqIENyZWF0ZXMgYSBjaGFydCBjdXJzb3IgZm9yIGFuIFtbWFlDaGFydF1dLlxyXG4gKlxyXG4gKiBAc2VlIHtAbGluayBodHRwczovL3d3dy5hbWNoYXJ0cy5jb20vZG9jcy92NS9jaGFydHMveHktY2hhcnQvY3Vyc29yL30gZm9yIG1vcmUgaW5mb1xyXG4gKiBAaW1wb3J0YW50XHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgWFlDdXJzb3IgZXh0ZW5kcyBDb250YWluZXIge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBIFtbR3JpZF1dIGVsbWVudCB0aGF0IHVzZWQgZm9yIGhvcml6b250YWwgbGluZSBvZiB0aGUgY3Vyc29yIGNyb3NzaGFpci5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBkZWZhdWx0IEdyaWQubmV3KClcclxuICAgICAgICAgKi9cclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJsaW5lWFwiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiB0aGlzLmNoaWxkcmVuLnB1c2goR3JpZC5uZXcodGhpcy5fcm9vdCwge1xyXG4gICAgICAgICAgICAgICAgdGhlbWVUYWdzOiBbXCJ4XCJdXHJcbiAgICAgICAgICAgIH0pKVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEEgW1tHcmlkXV0gZWxtZW50IHRoYXQgdXNlZCBmb3IgaG9yaXpvbnRhbCBsaW5lIG9mIHRoZSBjdXJzb3IgY3Jvc3NoYWlyLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQGRlZmF1bHQgR3JpZC5uZXcoKVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxpbmVZXCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IHRoaXMuY2hpbGRyZW4ucHVzaChHcmlkLm5ldyh0aGlzLl9yb290LCB7XHJcbiAgICAgICAgICAgICAgICB0aGVtZVRhZ3M6IFtcInlcIl1cclxuICAgICAgICAgICAgfSkpXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQW4gZWxlbWVudCB0aGF0IHJlcHJlc2VudHMgY3VycmVudCBzZWxlY3Rpb24uXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAZGVmYXVsdCBHcmFwaGljcy5uZXcoKVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInNlbGVjdGlvblwiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiB0aGlzLmNoaWxkcmVuLnB1c2goR3JhcGhpY3MubmV3KHRoaXMuX3Jvb3QsIHtcclxuICAgICAgICAgICAgICAgIHRoZW1lVGFnczogW1wic2VsZWN0aW9uXCIsIFwiY3Vyc29yXCJdLCBsYXllcjogMzBcclxuICAgICAgICAgICAgfSkpXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX21vdmVQb2ludFwiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfbGFzdFBvaW50XCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IHsgeDogMCwgeTogMCB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX3Rvb2x0aXBYXCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IGZhbHNlXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX3Rvb2x0aXBZXCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IGZhbHNlXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQSBjaGFydCBjdXJzb3IgaXMgYXR0YWNoZWQgdG8uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiY2hhcnRcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX3RvWFwiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfdG9ZXCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgX2FmdGVyTmV3KCkge1xyXG4gICAgICAgIHRoaXMuX3NldHRpbmdzLnRoZW1lVGFncyA9ICR1dGlscy5tZXJnZVRhZ3ModGhpcy5fc2V0dGluZ3MudGhlbWVUYWdzLCBbXCJ4eVwiLCBcImN1cnNvclwiXSk7XHJcbiAgICAgICAgc3VwZXIuX2FmdGVyTmV3KCk7XHJcbiAgICAgICAgdGhpcy5zZXRBbGwoeyBcIndpZHRoXCI6IHAxMDAsIGhlaWdodDogcDEwMCwgaXNNZWFzdXJlZDogdHJ1ZSwgcG9zaXRpb246IFwiYWJzb2x1dGVcIiB9KTtcclxuICAgICAgICB0aGlzLnN0YXRlcy5jcmVhdGUoXCJoaWRkZW5cIiwgeyB2aXNpYmxlOiB0cnVlLCBvcGFjaXR5OiAwIH0pO1xyXG4gICAgICAgIHRoaXMuX2RyYXdMaW5lcygpO1xyXG4gICAgICAgIHRoaXMuc2V0UHJpdmF0ZVJhdyhcInZpc2libGVcIiwgZmFsc2UpO1xyXG4gICAgICAgIHRoaXMuX2Rpc3Bvc2Vycy5wdXNoKHRoaXMuc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0UHJpdmF0ZShcInZpc2libGVcIiwgdHJ1ZSk7XHJcbiAgICAgICAgfSwgNTAwKSk7XHJcbiAgICAgICAgdGhpcy5fZGlzcG9zZXJzLnB1c2godGhpcy5saW5lWC5ldmVudHMub24oXCJwb3NpdGlvbmNoYW5nZWRcIiwgKCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLl9oYW5kbGVYTGluZSgpO1xyXG4gICAgICAgIH0pKTtcclxuICAgICAgICB0aGlzLl9kaXNwb3NlcnMucHVzaCh0aGlzLmxpbmVZLmV2ZW50cy5vbihcInBvc2l0aW9uY2hhbmdlZFwiLCAoKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuX2hhbmRsZVlMaW5lKCk7XHJcbiAgICAgICAgfSkpO1xyXG4gICAgICAgIHRoaXMuX2Rpc3Bvc2Vycy5wdXNoKHRoaXMubGluZVguZXZlbnRzLm9uKFwiZm9jdXNcIiwgKGV2KSA9PiB0aGlzLl9oYW5kbGVMaW5lRm9jdXMoZXYudGFyZ2V0KSkpO1xyXG4gICAgICAgIHRoaXMuX2Rpc3Bvc2Vycy5wdXNoKHRoaXMubGluZVguZXZlbnRzLm9uKFwiYmx1clwiLCAoZXYpID0+IHRoaXMuX2hhbmRsZUxpbmVCbHVyKGV2LnRhcmdldCkpKTtcclxuICAgICAgICB0aGlzLl9kaXNwb3NlcnMucHVzaCh0aGlzLmxpbmVZLmV2ZW50cy5vbihcImZvY3VzXCIsIChldikgPT4gdGhpcy5faGFuZGxlTGluZUZvY3VzKGV2LnRhcmdldCkpKTtcclxuICAgICAgICB0aGlzLl9kaXNwb3NlcnMucHVzaCh0aGlzLmxpbmVZLmV2ZW50cy5vbihcImJsdXJcIiwgKGV2KSA9PiB0aGlzLl9oYW5kbGVMaW5lQmx1cihldi50YXJnZXQpKSk7XHJcbiAgICAgICAgaWYgKCR1dGlscy5zdXBwb3J0cyhcImtleWJvYXJkZXZlbnRzXCIpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2Rpc3Bvc2Vycy5wdXNoKCR1dGlscy5hZGRFdmVudExpc3RlbmVyKGRvY3VtZW50LCBcImtleWRvd25cIiwgKGV2KSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9oYW5kbGVMaW5lTW92ZShldi5rZXlDb2RlKTtcclxuICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIF9zZXRVcFRvdWNoKCkge1xyXG4gICAgICAgIGNvbnN0IGNoYXJ0ID0gdGhpcy5jaGFydDtcclxuICAgICAgICBpZiAoY2hhcnQpIHtcclxuICAgICAgICAgICAgY2hhcnQucGxvdENvbnRhaW5lci5fZGlzcGxheS5jYW5jZWxUb3VjaCA9IHRoaXMuZ2V0KFwiYmVoYXZpb3JcIikgIT0gXCJub25lXCIgPyB0cnVlIDogZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgX2hhbmRsZVhMaW5lKCkge1xyXG4gICAgICAgIGxldCB4ID0gdGhpcy5saW5lWC54KCk7XHJcbiAgICAgICAgbGV0IHZpc2libGUgPSB0cnVlO1xyXG4gICAgICAgIGlmICh4IDwgMCB8fCB4ID4gdGhpcy53aWR0aCgpKSB7XHJcbiAgICAgICAgICAgIHZpc2libGUgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5saW5lWC5zZXRQcml2YXRlKFwidmlzaWJsZVwiLCB2aXNpYmxlKTtcclxuICAgIH1cclxuICAgIF9oYW5kbGVZTGluZSgpIHtcclxuICAgICAgICBsZXQgeSA9IHRoaXMubGluZVkueSgpO1xyXG4gICAgICAgIGxldCB2aXNpYmxlID0gdHJ1ZTtcclxuICAgICAgICBpZiAoeSA8IDAgfHwgeSA+IHRoaXMuaGVpZ2h0KCkpIHtcclxuICAgICAgICAgICAgdmlzaWJsZSA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmxpbmVZLnNldFByaXZhdGUoXCJ2aXNpYmxlXCIsIHZpc2libGUpO1xyXG4gICAgfVxyXG4gICAgX2hhbmRsZUxpbmVNb3ZlKGtleUNvZGUpIHtcclxuICAgICAgICBsZXQgZGlyID0gXCJcIjtcclxuICAgICAgICBsZXQgcG9zaXRpb24gPSAwO1xyXG4gICAgICAgIGxldCBpbmNyZW1lbnQgPSAwLjE7XHJcbiAgICAgICAgY29uc3QgY2hhcnQgPSB0aGlzLmNoYXJ0O1xyXG4gICAgICAgIGlmICh0aGlzLl9yb290LmZvY3VzZWQodGhpcy5saW5lWCkpIHtcclxuICAgICAgICAgICAgaWYgKGNoYXJ0ICYmIGNoYXJ0LnhBeGVzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgaW5jcmVtZW50ID0gY2hhcnQueEF4ZXMuZ2V0SW5kZXgoMCkuZ2V0Q2VsbFdpZHRoUG9zaXRpb24oKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBwb3NpdGlvbiA9IHRoaXMuZ2V0UHJpdmF0ZShcInBvc2l0aW9uWFwiLCAwKTtcclxuICAgICAgICAgICAgZGlyID0gXCJwb3NpdGlvblhcIjtcclxuICAgICAgICAgICAgaWYgKGtleUNvZGUgPT0gMzcpIHtcclxuICAgICAgICAgICAgICAgIHBvc2l0aW9uIC09IGluY3JlbWVudDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChrZXlDb2RlID09IDM5KSB7XHJcbiAgICAgICAgICAgICAgICBwb3NpdGlvbiArPSBpbmNyZW1lbnQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodGhpcy5fcm9vdC5mb2N1c2VkKHRoaXMubGluZVkpKSB7XHJcbiAgICAgICAgICAgIGlmIChjaGFydCAmJiBjaGFydC55QXhlcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIGluY3JlbWVudCA9IGNoYXJ0LnlBeGVzLmdldEluZGV4KDApLmdldENlbGxXaWR0aFBvc2l0aW9uKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcG9zaXRpb24gPSB0aGlzLmdldFByaXZhdGUoXCJwb3NpdGlvbllcIiwgMCk7XHJcbiAgICAgICAgICAgIGRpciA9IFwicG9zaXRpb25ZXCI7XHJcbiAgICAgICAgICAgIGlmIChrZXlDb2RlID09IDM4KSB7XHJcbiAgICAgICAgICAgICAgICBwb3NpdGlvbiAtPSBpbmNyZW1lbnQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5Q29kZSA9PSA0MCkge1xyXG4gICAgICAgICAgICAgICAgcG9zaXRpb24gKz0gaW5jcmVtZW50O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChwb3NpdGlvbiA8IDApIHtcclxuICAgICAgICAgICAgcG9zaXRpb24gPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChwb3NpdGlvbiA+IDEpIHtcclxuICAgICAgICAgICAgcG9zaXRpb24gPSAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZGlyICE9IFwiXCIpIHtcclxuICAgICAgICAgICAgdGhpcy5zZXQoZGlyLCBwb3NpdGlvbik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgX2hhbmRsZUxpbmVGb2N1cyhfbGluZSkge1xyXG4gICAgICAgIHRoaXMuc2V0QWxsKHtcclxuICAgICAgICAgICAgcG9zaXRpb25YOiB0aGlzLmdldFByaXZhdGUoXCJwb3NpdGlvblhcIiksXHJcbiAgICAgICAgICAgIHBvc2l0aW9uWTogdGhpcy5nZXRQcml2YXRlKFwicG9zaXRpb25ZXCIpLFxyXG4gICAgICAgICAgICBhbHdheXNTaG93OiB0cnVlXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBfaGFuZGxlTGluZUJsdXIoX2xpbmUpIHtcclxuICAgICAgICB0aGlzLnNldEFsbCh7XHJcbiAgICAgICAgICAgIHBvc2l0aW9uWDogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICBwb3NpdGlvblk6IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgYWx3YXlzU2hvdzogZmFsc2VcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIF9wcmVwYXJlQ2hpbGRyZW4oKSB7XHJcbiAgICAgICAgc3VwZXIuX3ByZXBhcmVDaGlsZHJlbigpO1xyXG4gICAgICAgIGlmICh0aGlzLmlzRGlydHkoXCJ4QXhpc1wiKSkge1xyXG4gICAgICAgICAgICB0aGlzLl90b29sdGlwWCA9IGZhbHNlO1xyXG4gICAgICAgICAgICBjb25zdCB4QXhpcyA9IHRoaXMuZ2V0KFwieEF4aXNcIik7XHJcbiAgICAgICAgICAgIGlmICh4QXhpcykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdG9vbHRpcCA9IHhBeGlzLmdldChcInRvb2x0aXBcIik7XHJcbiAgICAgICAgICAgICAgICBpZiAodG9vbHRpcCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3Rvb2x0aXBYID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kaXNwb3NlcnMucHVzaCh0b29sdGlwLm9uKFwicG9pbnRUb1wiLCAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3VwZGF0ZVhMaW5lKHRvb2x0aXApO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5pc0RpcnR5KFwieUF4aXNcIikpIHtcclxuICAgICAgICAgICAgdGhpcy5fdG9vbHRpcFkgPSBmYWxzZTtcclxuICAgICAgICAgICAgY29uc3QgeUF4aXMgPSB0aGlzLmdldChcInlBeGlzXCIpO1xyXG4gICAgICAgICAgICBpZiAoeUF4aXMpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHRvb2x0aXAgPSB5QXhpcy5nZXQoXCJ0b29sdGlwXCIpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRvb2x0aXApIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl90b29sdGlwWSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGlzcG9zZXJzLnB1c2godG9vbHRpcC5vbihcInBvaW50VG9cIiwgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGVZTGluZSh0b29sdGlwKTtcclxuICAgICAgICAgICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBfaGFuZGxlU3luY1dpdGgoKSB7XHJcbiAgICAgICAgY29uc3QgY2hhcnQgPSB0aGlzLmNoYXJ0O1xyXG4gICAgICAgIGlmIChjaGFydCkge1xyXG4gICAgICAgICAgICBjb25zdCBzeW5jV2l0aCA9IHRoaXMuZ2V0KFwic3luY1dpdGhcIik7XHJcbiAgICAgICAgICAgIGNvbnN0IG90aGVyQ2hhcnRzID0gW107XHJcbiAgICAgICAgICAgIGlmIChzeW5jV2l0aCkge1xyXG4gICAgICAgICAgICAgICAgJGFycmF5LmVhY2goc3luY1dpdGgsIChjdXJzb3IpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjaGFydCA9IGN1cnNvci5jaGFydDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY2hhcnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb3RoZXJDaGFydHMucHVzaChjaGFydCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2hhcnQuX290aGVyQ2hhcnRzID0gb3RoZXJDaGFydHM7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgX3VwZGF0ZUNoaWxkcmVuKCkge1xyXG4gICAgICAgIHN1cGVyLl91cGRhdGVDaGlsZHJlbigpO1xyXG4gICAgICAgIHRoaXMuX2hhbmRsZVN5bmNXaXRoKCk7XHJcbiAgICAgICAgaWYgKHRoaXMuaXNEaXJ0eShcInBvc2l0aW9uWFwiKSB8fCB0aGlzLmlzRGlydHkoXCJwb3NpdGlvbllcIikpIHtcclxuICAgICAgICAgICAgY29uc3QgcG9zaXRpb25YID0gdGhpcy5nZXQoXCJwb3NpdGlvblhcIik7XHJcbiAgICAgICAgICAgIGNvbnN0IHBvc2l0aW9uWSA9IHRoaXMuZ2V0KFwicG9zaXRpb25ZXCIpO1xyXG4gICAgICAgICAgICBpZiAocG9zaXRpb25YID09IG51bGwgJiYgcG9zaXRpb25ZID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuaGlkZSgwKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX21vdmVQb2ludCA9IHRoaXMudG9HbG9iYWwodGhpcy5fZ2V0UG9pbnQodGhpcy5nZXQoXCJwb3NpdGlvblhcIiwgMCksIHRoaXMuZ2V0KFwicG9zaXRpb25ZXCIsIDApKSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZU1vdmUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIF91cGRhdGVYTGluZSh0b29sdGlwKSB7XHJcbiAgICAgICAgbGV0IHggPSAkbWF0aC5yb3VuZCh0aGlzLl9kaXNwbGF5LnRvTG9jYWwodG9vbHRpcC5nZXQoXCJwb2ludFRvXCIsIHsgeDogMCwgeTogMCB9KSkueCwgMik7XHJcbiAgICAgICAgaWYgKHRoaXMuX3RvWCAhPSB4KSB7XHJcbiAgICAgICAgICAgIHRoaXMubGluZVguYW5pbWF0ZSh7IGtleTogXCJ4XCIsIHRvOiB4LCBkdXJhdGlvbjogdG9vbHRpcC5nZXQoXCJhbmltYXRpb25EdXJhdGlvblwiLCAwKSwgZWFzaW5nOiB0b29sdGlwLmdldChcImFuaW1hdGlvbkVhc2luZ1wiKSB9KTtcclxuICAgICAgICAgICAgdGhpcy5fdG9YID0geDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBfdXBkYXRlWUxpbmUodG9vbHRpcCkge1xyXG4gICAgICAgIGxldCB5ID0gJG1hdGgucm91bmQodGhpcy5fZGlzcGxheS50b0xvY2FsKHRvb2x0aXAuZ2V0KFwicG9pbnRUb1wiLCB7IHg6IDAsIHk6IDAgfSkpLnksIDIpO1xyXG4gICAgICAgIGlmICh0aGlzLl90b1kgIT0geSkge1xyXG4gICAgICAgICAgICB0aGlzLmxpbmVZLmFuaW1hdGUoeyBrZXk6IFwieVwiLCB0bzogeSwgZHVyYXRpb246IHRvb2x0aXAuZ2V0KFwiYW5pbWF0aW9uRHVyYXRpb25cIiwgMCksIGVhc2luZzogdG9vbHRpcC5nZXQoXCJhbmltYXRpb25FYXNpbmdcIikgfSk7XHJcbiAgICAgICAgICAgIHRoaXMuX3RvWSA9IHk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgX2RyYXdMaW5lcygpIHtcclxuICAgICAgICB0aGlzLmxpbmVYLnNldChcImRyYXdcIiwgKGRpc3BsYXkpID0+IHtcclxuICAgICAgICAgICAgZGlzcGxheS5tb3ZlVG8oMCwgMCk7XHJcbiAgICAgICAgICAgIGRpc3BsYXkubGluZVRvKDAsIHRoaXMuaGVpZ2h0KCkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMubGluZVkuc2V0KFwiZHJhd1wiLCAoZGlzcGxheSkgPT4ge1xyXG4gICAgICAgICAgICBkaXNwbGF5Lm1vdmVUbygwLCAwKTtcclxuICAgICAgICAgICAgZGlzcGxheS5saW5lVG8odGhpcy53aWR0aCgpLCAwKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHVwZGF0ZUN1cnNvcigpIHtcclxuICAgICAgICBpZiAodGhpcy5nZXQoXCJhbHdheXNTaG93XCIpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX21vdmVQb2ludCA9IHRoaXMudG9HbG9iYWwodGhpcy5fZ2V0UG9pbnQodGhpcy5nZXQoXCJwb3NpdGlvblhcIiwgMCksIHRoaXMuZ2V0KFwicG9zaXRpb25ZXCIsIDApKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuaGFuZGxlTW92ZSgpO1xyXG4gICAgfVxyXG4gICAgX3NldENoYXJ0KGNoYXJ0KSB7XHJcbiAgICAgICAgdGhpcy5jaGFydCA9IGNoYXJ0O1xyXG4gICAgICAgIHRoaXMuX2hhbmRsZVN5bmNXaXRoKCk7XHJcbiAgICAgICAgY29uc3QgcGxvdENvbnRhaW5lciA9IGNoYXJ0LnBsb3RDb250YWluZXI7XHJcbiAgICAgICAgdGhpcy5ldmVudHMub24oXCJib3VuZHNjaGFuZ2VkXCIsICgpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5fZGlzcG9zZXJzLnB1c2godGhpcy5zZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlQ3Vyc29yKCk7XHJcbiAgICAgICAgICAgIH0sIDUwKSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLy90aGlzLl9kaXNwbGF5LmludGVyYWN0aXZlID0gdHJ1ZTtcclxuICAgICAgICBpZiAoJHV0aWxzLnN1cHBvcnRzKFwidG91Y2hldmVudHNcIikpIHtcclxuICAgICAgICAgICAgdGhpcy5fZGlzcG9zZXJzLnB1c2gocGxvdENvbnRhaW5lci5ldmVudHMub24oXCJjbGlja1wiLCAoZXZlbnQpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmICgkdXRpbHMuaXNUb3VjaEV2ZW50KGV2ZW50Lm9yaWdpbmFsRXZlbnQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faGFuZGxlTW92ZShldmVudCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pKTtcclxuICAgICAgICAgICAgdGhpcy5fc2V0VXBUb3VjaCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9kaXNwb3NlcnMucHVzaChwbG90Q29udGFpbmVyLmV2ZW50cy5vbihcInBvaW50ZXJkb3duXCIsIChldmVudCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLl9oYW5kbGVDdXJzb3JEb3duKGV2ZW50KTtcclxuICAgICAgICB9KSk7XHJcbiAgICAgICAgdGhpcy5fZGlzcG9zZXJzLnB1c2gocGxvdENvbnRhaW5lci5ldmVudHMub24oXCJnbG9iYWxwb2ludGVydXBcIiwgKGV2ZW50KSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuX2hhbmRsZUN1cnNvclVwKGV2ZW50KTtcclxuICAgICAgICAgICAgaWYgKCFldmVudC5uYXRpdmUgJiYgIXRoaXMuaXNIaWRkZW4oKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5faGFuZGxlTW92ZShldmVudCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KSk7XHJcbiAgICAgICAgdGhpcy5fZGlzcG9zZXJzLnB1c2gocGxvdENvbnRhaW5lci5ldmVudHMub24oXCJnbG9iYWxwb2ludGVybW92ZVwiLCAoZXZlbnQpID0+IHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLmdldChcInN5bmNXaXRoXCIpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoJG9iamVjdC5rZXlzKHBsb3RDb250YWluZXIuX2Rvd25Qb2ludHMpLmxlbmd0aCA9PSAwICYmICFldmVudC5uYXRpdmUgJiYgdGhpcy5pc0hpZGRlbigpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gSWdub3JlIG1vdXNlIG1vdmVtZW50IGlmIGl0IG9yaWdpbmF0ZXMgb24gb3V0c2lkZSBlbGVtZW50IGFuZFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHdlJ3JlIG5vdCBkcmFnZ2luZy5cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5faGFuZGxlTW92ZShldmVudCk7XHJcbiAgICAgICAgfSkpO1xyXG4gICAgICAgIGNvbnN0IHBhcmVudCA9IHRoaXMucGFyZW50O1xyXG4gICAgICAgIGlmIChwYXJlbnQpIHtcclxuICAgICAgICAgICAgcGFyZW50LmNoaWxkcmVuLm1vdmVWYWx1ZSh0aGlzLnNlbGVjdGlvbik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgX2luUGxvdChwb2ludCkge1xyXG4gICAgICAgIGNvbnN0IGNoYXJ0ID0gdGhpcy5jaGFydDtcclxuICAgICAgICBpZiAoY2hhcnQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGNoYXJ0LmluUGxvdChwb2ludCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIF9oYW5kbGVDdXJzb3JEb3duKGV2ZW50KSB7XHJcbiAgICAgICAgaWYgKGV2ZW50Lm9yaWdpbmFsRXZlbnQuYnV0dG9uID09IDIpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCByb290UG9pbnQgPSBldmVudC5wb2ludDtcclxuICAgICAgICBsZXQgbG9jYWwgPSB0aGlzLl9kaXNwbGF5LnRvTG9jYWwocm9vdFBvaW50KTtcclxuICAgICAgICBjb25zdCBjaGFydCA9IHRoaXMuY2hhcnQ7XHJcbiAgICAgICAgdGhpcy5zZWxlY3Rpb24uc2V0KFwiZHJhd1wiLCAoKSA9PiB7IH0pO1xyXG4gICAgICAgIGlmIChjaGFydCAmJiB0aGlzLl9pblBsb3QobG9jYWwpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2Rvd25Qb2ludCA9IGxvY2FsO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5nZXQoXCJiZWhhdmlvclwiKSAhPSBcIm5vbmVcIikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb24uc2hvdygpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdHlwZSA9IFwic2VsZWN0c3RhcnRlZFwiO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZXZlbnRzLmlzRW5hYmxlZCh0eXBlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZXZlbnRzLmRpc3BhdGNoKHR5cGUsIHsgdHlwZTogdHlwZSwgdGFyZ2V0OiB0aGlzLCBvcmlnaW5hbEV2ZW50OiBldmVudC5vcmlnaW5hbEV2ZW50IH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGxldCBwb3NpdGlvblggPSB0aGlzLl9nZXRQb3NpdGlvbihsb2NhbCkueDtcclxuICAgICAgICAgICAgbGV0IHBvc2l0aW9uWSA9IHRoaXMuX2dldFBvc2l0aW9uKGxvY2FsKS55O1xyXG4gICAgICAgICAgICB0aGlzLnNldFByaXZhdGUoXCJkb3duUG9zaXRpb25YXCIsIHBvc2l0aW9uWCk7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0UHJpdmF0ZShcImRvd25Qb3NpdGlvbllcIiwgcG9zaXRpb25ZKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBfaGFuZGxlQ3Vyc29yVXAoZXZlbnQpIHtcclxuICAgICAgICAvLyBUT0RPOiBoYW5kbGUgbXVsdGl0b3VjaFxyXG4gICAgICAgIGlmICh0aGlzLl9kb3duUG9pbnQpIHtcclxuICAgICAgICAgICAgY29uc3QgYmVoYXZpb3IgPSB0aGlzLmdldChcImJlaGF2aW9yXCIsIFwibm9uZVwiKTtcclxuICAgICAgICAgICAgaWYgKGJlaGF2aW9yICE9IFwibm9uZVwiKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoYmVoYXZpb3IuY2hhckF0KDApID09PSBcInpcIikge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uLmhpZGUoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvbnN0IHJvb3RQb2ludCA9IGV2ZW50LnBvaW50O1xyXG4gICAgICAgICAgICAgICAgbGV0IGxvY2FsID0gdGhpcy5fZGlzcGxheS50b0xvY2FsKHJvb3RQb2ludCk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBkb3duUG9pbnQgPSB0aGlzLl9kb3duUG9pbnQ7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBtb3ZlVGhyZXNob2xkID0gdGhpcy5nZXQoXCJtb3ZlVGhyZXNob2xkXCIsIDEpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGxvY2FsICYmIGRvd25Qb2ludCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBkaXNwYXRjaCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChiZWhhdmlvciA9PT0gXCJ6b29tWFwiIHx8IGJlaGF2aW9yID09PSBcInpvb21YWVwiIHx8IGJlaGF2aW9yID09PSBcInNlbGVjdFhcIiB8fCBiZWhhdmlvciA9PT0gXCJzZWxlY3RYWVwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChNYXRoLmFicyhsb2NhbC54IC0gZG93blBvaW50LngpID4gbW92ZVRocmVzaG9sZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2ggPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChiZWhhdmlvciA9PT0gXCJ6b29tWVwiIHx8IGJlaGF2aW9yID09PSBcInpvb21YWVwiIHx8IGJlaGF2aW9yID09PSBcInNlbGVjdFlcIiB8fCBiZWhhdmlvciA9PT0gXCJzZWxlY3RYWVwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChNYXRoLmFicyhsb2NhbC55IC0gZG93blBvaW50LnkpID4gbW92ZVRocmVzaG9sZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2ggPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChkaXNwYXRjaCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0eXBlID0gXCJzZWxlY3RlbmRlZFwiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5ldmVudHMuaXNFbmFibGVkKHR5cGUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmV2ZW50cy5kaXNwYXRjaCh0eXBlLCB7IHR5cGU6IHR5cGUsIHRhcmdldDogdGhpcywgb3JpZ2luYWxFdmVudDogZXZlbnQub3JpZ2luYWxFdmVudCB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdHlwZSA9IFwic2VsZWN0Y2FuY2VsbGVkXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmV2ZW50cy5pc0VuYWJsZWQodHlwZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZXZlbnRzLmRpc3BhdGNoKHR5cGUsIHsgdHlwZTogdHlwZSwgdGFyZ2V0OiB0aGlzLCBvcmlnaW5hbEV2ZW50OiBldmVudC5vcmlnaW5hbEV2ZW50IH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2Rvd25Qb2ludCA9IHVuZGVmaW5lZDtcclxuICAgIH1cclxuICAgIF9oYW5kbGVNb3ZlKGV2ZW50KSB7XHJcbiAgICAgICAgaWYgKHRoaXMuZ2V0UHJpdmF0ZShcInZpc2libGVcIikpIHtcclxuICAgICAgICAgICAgY29uc3QgY2hhcnQgPSB0aGlzLmNoYXJ0O1xyXG4gICAgICAgICAgICBpZiAoY2hhcnQgJiYgJG9iamVjdC5rZXlzKGNoYXJ0LnBsb3RDb250YWluZXIuX2Rvd25Qb2ludHMpLmxlbmd0aCA+IDEpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2V0KFwiZm9yY2VIaWRkZW5cIiwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNldChcImZvcmNlSGlkZGVuXCIsIGZhbHNlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBUT0RPOiBoYW5kbGUgbXVsdGl0b3VjaFxyXG4gICAgICAgICAgICBjb25zdCByb290UG9pbnQgPSBldmVudC5wb2ludDtcclxuICAgICAgICAgICAgY29uc3QgbGFzdFBvaW50ID0gdGhpcy5fbGFzdFBvaW50O1xyXG4gICAgICAgICAgICBpZiAoTWF0aC5yb3VuZChsYXN0UG9pbnQueCkgPT09IE1hdGgucm91bmQocm9vdFBvaW50LngpICYmIE1hdGgucm91bmQobGFzdFBvaW50LnkpID09PSBNYXRoLnJvdW5kKHJvb3RQb2ludC55KSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX2xhc3RQb2ludCA9IHJvb3RQb2ludDtcclxuICAgICAgICAgICAgdGhpcy5zZXRQcml2YXRlKFwibGFzdFBvaW50XCIsIHJvb3RQb2ludCk7XHJcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlTW92ZSh7IHg6IHJvb3RQb2ludC54LCB5OiByb290UG9pbnQueSB9LCBmYWxzZSwgZXZlbnQub3JpZ2luYWxFdmVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgX2dldFBvc2l0aW9uKHBvaW50KSB7XHJcbiAgICAgICAgcmV0dXJuIHsgeDogcG9pbnQueCAvIHRoaXMud2lkdGgoKSwgeTogcG9pbnQueSAvIHRoaXMuaGVpZ2h0KCkgfTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogTW92ZXMgdGhlIGN1cnNvciB0byBYL1kgY29vcmRpbmF0ZXMgd2l0aGluIGNoYXJ0IGNvbnRhaW5lciAoYHBvaW50YCkuXHJcbiAgICAgKlxyXG4gICAgICogSWYgYHNraXBFdmVudGAgcGFyYW1ldGVyIGlzIHNldCB0byBgdHJ1ZWAsIHRoZSBtb3ZlIHdpbGwgbm90IGludm9rZVxyXG4gICAgICogdGhlIGBcImN1cnNvcm1vdmVkXCJgIGV2ZW50LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSAgcG9pbnQgICAgICBYL1kgdG8gbW92ZSBjdXJzb3IgdG9cclxuICAgICAqIEBwYXJhbSAgc2tpcEV2ZW50ICBEbyBub3QgZmlyZSBcImN1cnNvcm1vdmVkXCIgZXZlbnRcclxuICAgICAqL1xyXG4gICAgaGFuZGxlTW92ZShwb2ludCwgc2tpcEV2ZW50LCBvcmlnaW5hbEV2ZW50KSB7XHJcbiAgICAgICAgaWYgKCFwb2ludCkge1xyXG4gICAgICAgICAgICBwb2ludCA9IHRoaXMuX21vdmVQb2ludDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgYWx3YXlzU2hvdyA9IHRoaXMuZ2V0KFwiYWx3YXlzU2hvd1wiKTtcclxuICAgICAgICBpZiAoIXBvaW50KSB7XHJcbiAgICAgICAgICAgIHRoaXMuaGlkZSgwKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9tb3ZlUG9pbnQgPSBwb2ludDtcclxuICAgICAgICBsZXQgbG9jYWwgPSB0aGlzLl9kaXNwbGF5LnRvTG9jYWwocG9pbnQpO1xyXG4gICAgICAgIGxldCBjaGFydCA9IHRoaXMuY2hhcnQ7XHJcbiAgICAgICAgaWYgKGNoYXJ0ICYmICh0aGlzLl9pblBsb3QobG9jYWwpIHx8IHRoaXMuX2Rvd25Qb2ludCkpIHtcclxuICAgICAgICAgICAgY2hhcnQuX21vdmVQb2ludCA9IHBvaW50O1xyXG4gICAgICAgICAgICBpZiAodGhpcy5pc0hpZGRlbigpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNob3coKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGJlaGF2aW9yID0gdGhpcy5nZXQoXCJiZWhhdmlvclwiLCBcIlwiKTtcclxuICAgICAgICAgICAgICAgIGlmIChiZWhhdmlvci5jaGFyQXQoMCkgPT0gXCJ6XCIpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGlvbi5zZXQoXCJkcmF3XCIsICgpID0+IHsgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGV0IHggPSBsb2NhbC54O1xyXG4gICAgICAgICAgICBsZXQgeSA9IGxvY2FsLnk7XHJcbiAgICAgICAgICAgIGxldCB4eVBvcyA9IHRoaXMuX2dldFBvc2l0aW9uKGxvY2FsKTtcclxuICAgICAgICAgICAgdGhpcy5zZXRQcml2YXRlKFwicG9pbnRcIiwgbG9jYWwpO1xyXG4gICAgICAgICAgICBsZXQgc25hcFRvU2VyaWVzID0gdGhpcy5nZXQoXCJzbmFwVG9TZXJpZXNcIik7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9kb3duUG9pbnQpIHtcclxuICAgICAgICAgICAgICAgIHNuYXBUb1NlcmllcyA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsZXQgdXNlclBvc2l0aW9uWCA9IHRoaXMuZ2V0KFwicG9zaXRpb25YXCIpO1xyXG4gICAgICAgICAgICBsZXQgcG9zaXRpb25YID0geHlQb3MueDtcclxuICAgICAgICAgICAgaWYgKCR0eXBlLmlzTnVtYmVyKHVzZXJQb3NpdGlvblgpKSB7XHJcbiAgICAgICAgICAgICAgICBwb3NpdGlvblggPSB1c2VyUG9zaXRpb25YO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGxldCB1c2VyUG9zaXRpb25ZID0gdGhpcy5nZXQoXCJwb3NpdGlvbllcIik7XHJcbiAgICAgICAgICAgIGxldCBwb3NpdGlvblkgPSB4eVBvcy55O1xyXG4gICAgICAgICAgICBpZiAoJHR5cGUuaXNOdW1iZXIodXNlclBvc2l0aW9uWSkpIHtcclxuICAgICAgICAgICAgICAgIHBvc2l0aW9uWSA9IHVzZXJQb3NpdGlvblk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5zZXRQcml2YXRlKFwicG9zaXRpb25YXCIsIHBvc2l0aW9uWCk7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0UHJpdmF0ZShcInBvc2l0aW9uWVwiLCBwb3NpdGlvblkpO1xyXG4gICAgICAgICAgICBjb25zdCB4eSA9IHRoaXMuX2dldFBvaW50KHBvc2l0aW9uWCwgcG9zaXRpb25ZKTtcclxuICAgICAgICAgICAgeCA9IHh5Lng7XHJcbiAgICAgICAgICAgIHkgPSB4eS55O1xyXG4gICAgICAgICAgICBjaGFydC54QXhlcy5lYWNoKChheGlzKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBheGlzLl9oYW5kbGVDdXJzb3JQb3NpdGlvbihwb3NpdGlvblgsIHNuYXBUb1Nlcmllcyk7XHJcbiAgICAgICAgICAgICAgICBpZiAoYWx3YXlzU2hvdykge1xyXG4gICAgICAgICAgICAgICAgICAgIGF4aXMuaGFuZGxlQ3Vyc29yU2hvdygpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgY2hhcnQueUF4ZXMuZWFjaCgoYXhpcykgPT4ge1xyXG4gICAgICAgICAgICAgICAgYXhpcy5faGFuZGxlQ3Vyc29yUG9zaXRpb24ocG9zaXRpb25ZLCBzbmFwVG9TZXJpZXMpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGFsd2F5c1Nob3cpIHtcclxuICAgICAgICAgICAgICAgICAgICBheGlzLmhhbmRsZUN1cnNvclNob3coKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGlmICghc2tpcEV2ZW50KSB7XHJcbiAgICAgICAgICAgICAgICBjaGFydC5faGFuZGxlQ3Vyc29yUG9zaXRpb24oKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHR5cGUgPSBcImN1cnNvcm1vdmVkXCI7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5ldmVudHMuaXNFbmFibGVkKHR5cGUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ldmVudHMuZGlzcGF0Y2godHlwZSwgeyB0eXBlOiB0eXBlLCB0YXJnZXQ6IHRoaXMsIHBvaW50OiBwb2ludCwgb3JpZ2luYWxFdmVudDogb3JpZ2luYWxFdmVudCB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl91cGRhdGVMaW5lcyh4LCB5KTtcclxuICAgICAgICAgICAgY2hhcnQuYXJyYW5nZVRvb2x0aXBzKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKCF0aGlzLl9kb3duUG9pbnQpIHtcclxuICAgICAgICAgICAgaWYgKCFhbHdheXNTaG93KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmhpZGUoMCk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB0eXBlID0gXCJjdXJzb3JoaWRkZW5cIjtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmV2ZW50cy5pc0VuYWJsZWQodHlwZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmV2ZW50cy5kaXNwYXRjaCh0eXBlLCB7IHR5cGU6IHR5cGUsIHRhcmdldDogdGhpcyB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5fZG93blBvaW50ICYmIHRoaXMuZ2V0KFwiYmVoYXZpb3JcIikgIT0gXCJub25lXCIpIHtcclxuICAgICAgICAgICAgdGhpcy5fdXBkYXRlU2VsZWN0aW9uKGxvY2FsKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBfZ2V0UG9pbnQocG9zaXRpb25YLCBwb3NpdGlvblkpIHtcclxuICAgICAgICByZXR1cm4geyB4OiB0aGlzLndpZHRoKCkgKiBwb3NpdGlvblgsIHk6IHRoaXMuaGVpZ2h0KCkgKiBwb3NpdGlvblkgfTtcclxuICAgIH1cclxuICAgIF91cGRhdGVMaW5lcyh4LCB5KSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLl90b29sdGlwWCkge1xyXG4gICAgICAgICAgICB0aGlzLmxpbmVYLnNldChcInhcIiwgeCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghdGhpcy5fdG9vbHRpcFkpIHtcclxuICAgICAgICAgICAgdGhpcy5saW5lWS5zZXQoXCJ5XCIsIHkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9kcmF3TGluZXMoKTtcclxuICAgIH1cclxuICAgIF91cGRhdGVTZWxlY3Rpb24ocG9pbnQpIHtcclxuICAgICAgICBjb25zdCBzZWxlY3Rpb24gPSB0aGlzLnNlbGVjdGlvbjtcclxuICAgICAgICBjb25zdCBiZWhhdmlvciA9IHRoaXMuZ2V0KFwiYmVoYXZpb3JcIik7XHJcbiAgICAgICAgY29uc3QgdyA9IHRoaXMud2lkdGgoKTtcclxuICAgICAgICBjb25zdCBoID0gdGhpcy5oZWlnaHQoKTtcclxuICAgICAgICBpZiAocG9pbnQueCA8IDApIHtcclxuICAgICAgICAgICAgcG9pbnQueCA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChwb2ludC54ID4gdykge1xyXG4gICAgICAgICAgICBwb2ludC54ID0gdztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHBvaW50LnkgPCAwKSB7XHJcbiAgICAgICAgICAgIHBvaW50LnkgPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocG9pbnQueSA+IGgpIHtcclxuICAgICAgICAgICAgcG9pbnQueSA9IGg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHNlbGVjdGlvbi5zZXQoXCJkcmF3XCIsIChkaXNwbGF5KSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGRvd25Qb2ludCA9IHRoaXMuX2Rvd25Qb2ludDtcclxuICAgICAgICAgICAgaWYgKGRvd25Qb2ludCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGJlaGF2aW9yID09PSBcInpvb21YWVwiIHx8IGJlaGF2aW9yID09PSBcInNlbGVjdFhZXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICBkaXNwbGF5Lm1vdmVUbyhkb3duUG9pbnQueCwgZG93blBvaW50LnkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGRpc3BsYXkubGluZVRvKGRvd25Qb2ludC54LCBwb2ludC55KTtcclxuICAgICAgICAgICAgICAgICAgICBkaXNwbGF5LmxpbmVUbyhwb2ludC54LCBwb2ludC55KTtcclxuICAgICAgICAgICAgICAgICAgICBkaXNwbGF5LmxpbmVUbyhwb2ludC54LCBkb3duUG9pbnQueSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheS5saW5lVG8oZG93blBvaW50LngsIGRvd25Qb2ludC55KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGJlaGF2aW9yID09PSBcInpvb21YXCIgfHwgYmVoYXZpb3IgPT09IFwic2VsZWN0WFwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheS5tb3ZlVG8oZG93blBvaW50LngsIDApO1xyXG4gICAgICAgICAgICAgICAgICAgIGRpc3BsYXkubGluZVRvKGRvd25Qb2ludC54LCBoKTtcclxuICAgICAgICAgICAgICAgICAgICBkaXNwbGF5LmxpbmVUbyhwb2ludC54LCBoKTtcclxuICAgICAgICAgICAgICAgICAgICBkaXNwbGF5LmxpbmVUbyhwb2ludC54LCAwKTtcclxuICAgICAgICAgICAgICAgICAgICBkaXNwbGF5LmxpbmVUbyhkb3duUG9pbnQueCwgMCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChiZWhhdmlvciA9PT0gXCJ6b29tWVwiIHx8IGJlaGF2aW9yID09PSBcInNlbGVjdFlcIikge1xyXG4gICAgICAgICAgICAgICAgICAgIGRpc3BsYXkubW92ZVRvKDAsIGRvd25Qb2ludC55KTtcclxuICAgICAgICAgICAgICAgICAgICBkaXNwbGF5LmxpbmVUbyh3LCBkb3duUG9pbnQueSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheS5saW5lVG8odywgcG9pbnQueSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheS5saW5lVG8oMCwgcG9pbnQueSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheS5saW5lVG8oMCwgZG93blBvaW50LnkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBfb25IaWRlKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmlzSGlkZGVuKCkpIHtcclxuICAgICAgICAgICAgbGV0IGNoYXJ0ID0gdGhpcy5jaGFydDtcclxuICAgICAgICAgICAgaWYgKGNoYXJ0KSB7XHJcbiAgICAgICAgICAgICAgICBjaGFydC54QXhlcy5lYWNoKChheGlzKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgYXhpcy5oYW5kbGVDdXJzb3JIaWRlKCk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIGNoYXJ0LnlBeGVzLmVhY2goKGF4aXMpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBheGlzLmhhbmRsZUN1cnNvckhpZGUoKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgY2hhcnQuc2VyaWVzLmVhY2goKHNlcmllcykgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHNlcmllcy5oYW5kbGVDdXJzb3JIaWRlKCk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBzdXBlci5fb25IaWRlKCk7XHJcbiAgICB9XHJcbiAgICBfb25TaG93KCkge1xyXG4gICAgICAgIGlmICghdGhpcy5pc0hpZGRlbigpKSB7XHJcbiAgICAgICAgICAgIGxldCBjaGFydCA9IHRoaXMuY2hhcnQ7XHJcbiAgICAgICAgICAgIGlmIChjaGFydCkge1xyXG4gICAgICAgICAgICAgICAgY2hhcnQueEF4ZXMuZWFjaCgoYXhpcykgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGF4aXMuaGFuZGxlQ3Vyc29yU2hvdygpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBjaGFydC55QXhlcy5lYWNoKChheGlzKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgYXhpcy5oYW5kbGVDdXJzb3JTaG93KCk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBzdXBlci5fb25TaG93KCk7XHJcbiAgICB9XHJcbiAgICBfZGlzcG9zZSgpIHtcclxuICAgICAgICBzdXBlci5fZGlzcG9zZSgpO1xyXG4gICAgICAgIHRoaXMuc2VsZWN0aW9uLmRpc3Bvc2UoKTtcclxuICAgIH1cclxufVxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoWFlDdXJzb3IsIFwiY2xhc3NOYW1lXCIsIHtcclxuICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgIHZhbHVlOiBcIlhZQ3Vyc29yXCJcclxufSk7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShYWUN1cnNvciwgXCJjbGFzc05hbWVzXCIsIHtcclxuICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgIHZhbHVlOiBDb250YWluZXIuY2xhc3NOYW1lcy5jb25jYXQoW1hZQ3Vyc29yLmNsYXNzTmFtZV0pXHJcbn0pO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1YWUN1cnNvci5qcy5tYXAiLCJpbXBvcnQgeyBEYXRhSXRlbSB9IGZyb20gXCIuLi8uLi8uLi9jb3JlL3JlbmRlci9Db21wb25lbnRcIjtcclxuaW1wb3J0IHsgQ29tcG9uZW50IH0gZnJvbSBcIi4uLy4uLy4uL2NvcmUvcmVuZGVyL0NvbXBvbmVudFwiO1xyXG5pbXBvcnQgeyBDb250YWluZXIgfSBmcm9tIFwiLi4vLi4vLi4vY29yZS9yZW5kZXIvQ29udGFpbmVyXCI7XHJcbmltcG9ydCB7IHAxMDAgfSBmcm9tIFwiLi4vLi4vLi4vY29yZS91dGlsL1BlcmNlbnRcIjtcclxuaW1wb3J0IHsgTGlzdCB9IGZyb20gXCIuLi8uLi8uLi9jb3JlL3V0aWwvTGlzdFwiO1xyXG5pbXBvcnQgeyBSZWN0YW5nbGUgfSBmcm9tIFwiLi4vLi4vLi4vY29yZS9yZW5kZXIvUmVjdGFuZ2xlXCI7XHJcbmltcG9ydCAqIGFzICRhcnJheSBmcm9tIFwiLi4vLi4vLi4vY29yZS91dGlsL0FycmF5XCI7XHJcbmltcG9ydCAqIGFzICR0eXBlIGZyb20gXCIuLi8uLi8uLi9jb3JlL3V0aWwvVHlwZVwiO1xyXG5pbXBvcnQgKiBhcyAkdXRpbHMgZnJvbSBcIi4uLy4uLy4uL2NvcmUvdXRpbC9VdGlsc1wiO1xyXG4vKipcclxuICogQSBiYXNlIGNsYXNzIGZvciBhbGwgYXhlcy5cclxuICpcclxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly93d3cuYW1jaGFydHMuY29tL2RvY3MvdjUvY2hhcnRzL3h5LWNoYXJ0LyNBZGRpbmdfYXhlc30gZm9yIG1vcmUgaW5mb1xyXG4gKi9cclxuZXhwb3J0IGNsYXNzIEF4aXMgZXh0ZW5kcyBDb21wb25lbnQge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfc2VyaWVzXCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IFtdXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX2lzUGFubmluZ1wiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiBmYWxzZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFycmF5IG9mIG1pbm9yIGRhdGEgaXRlbXMuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibWlub3JEYXRhSXRlbXNcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogW11cclxuICAgICAgICB9KTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBIFtbQ29udGFpbmVyXV0gdGhhdCBob2xkcyBhbGwgdGhlIGF4aXMgbGFiZWwgZWxlbWVudHMuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAZGVmYXVsdCBDb250YWluZXIubmV3KClcclxuICAgICAgICAgKi9cclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJsYWJlbHNDb250YWluZXJcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogdGhpcy5jaGlsZHJlbi5wdXNoKENvbnRhaW5lci5uZXcodGhpcy5fcm9vdCwge30pKVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEEgW1tDb250YWluZXJdXSB0aGF0IGhvbGRzIGFsbCB0aGUgYXhpcyBncmlkIGFuZCBmaWxsIGVsZW1lbnRzLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQGRlZmF1bHQgQ29udGFpbmVyLm5ldygpXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZ3JpZENvbnRhaW5lclwiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiBDb250YWluZXIubmV3KHRoaXMuX3Jvb3QsIHsgd2lkdGg6IHAxMDAsIGhlaWdodDogcDEwMCB9KVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEEgW1tDb250YWluZXJdXSB0aGF0IGhvbGRzIGF4aXMgZ3JpZCBlbGVtZW50cyB3aGljaCBnb2VzIGFib3ZlIHRoZSBzZXJpZXMuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAZGVmYXVsdCBDb250YWluZXIubmV3KClcclxuICAgICAgICAgKi9cclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ0b3BHcmlkQ29udGFpbmVyXCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IENvbnRhaW5lci5uZXcodGhpcy5fcm9vdCwgeyB3aWR0aDogcDEwMCwgaGVpZ2h0OiBwMTAwIH0pXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQSBbW0NvbnRhaW5lcl1dIHRoYXQgaG9sZHMgYWxsIHRoZSBheGlzIGJ1bGxldCBlbGVtZW50cy5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBkZWZhdWx0IG5ldyBDb250YWluZXJcclxuICAgICAgICAgKi9cclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJidWxsZXRzQ29udGFpbmVyXCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IHRoaXMuY2hpbGRyZW4ucHVzaChDb250YWluZXIubmV3KHRoaXMuX3Jvb3QsIHsgaXNNZWFzdXJlZDogZmFsc2UsIHdpZHRoOiBwMTAwLCBoZWlnaHQ6IHAxMDAsIHBvc2l0aW9uOiBcImFic29sdXRlXCIgfSkpXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQSByZWZlcmVuZWNlIHRvIHRoZSB0aGUgY2hhcnQgdGhlIGF4aXMgYmVsb25ncyB0by5cclxuICAgICAgICAgKi9cclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJjaGFydFwiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfcmFuZ2VzRGlydHlcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogZmFsc2VcclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfcGFuU3RhcnRcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogMFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9wYW5FbmRcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogMVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9zQW5pbWF0aW9uXCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9lQW5pbWF0aW9uXCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9za2lwU3luY1wiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiBmYWxzZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEEgbGlzdCBvZiBheGlzIHJhbmdlcy5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vd3d3LmFtY2hhcnRzLmNvbS9kb2NzL3Y1L2NoYXJ0cy94eS1jaGFydC9heGVzL2F4aXMtcmFuZ2VzL30gZm9yIG1vcmUgaW5mb1xyXG4gICAgICAgICAqIEBkZWZhdWx0IG5ldyBMaXN0KClcclxuICAgICAgICAgKi9cclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJheGlzUmFuZ2VzXCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IG5ldyBMaXN0KClcclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfc2VyaWVzQXhpc1Jhbmdlc1wiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiBbXVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEEgY29udHJvbCBsYWJlbCB0aGF0IGlzIGludmlzaWJsZSBidXQgaXMgdXNlZCB0byBrZWVwIHdpZHRoIHRoZSB3aWR0aCBvZlxyXG4gICAgICAgICAqIHRoZSBheGlzIGNvbnN0YW50LlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly93d3cuYW1jaGFydHMuY29tL2RvY3MvdjUvY2hhcnRzL3h5LWNoYXJ0L2F4ZXMvdmFsdWUtYXhpcy8jR2hvc3RfbGFiZWx9IGZvciBtb3JlIGluZm9cclxuICAgICAgICAgKi9cclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJnaG9zdExhYmVsXCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9jdXJzb3JQb3NpdGlvblwiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiAtMVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9zbmFwVG9TZXJpZXNcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX3Nlcmllc1ZhbHVlc0RpcnR5XCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IGZhbHNlXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQSBjb250YWluZXIgYWJvdmUgdGhlIGF4aXMgdGhhdCBjYW4gYmUgdXNlZCB0byBhZGQgYWRkaXRpb25hbCBzdHVmZiBpbnRvXHJcbiAgICAgICAgICogaXQuIEZvciBleGFtcGxlIGEgbGVnZW5kLCBsYWJlbCwgb3IgYW4gaWNvbi5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vd3d3LmFtY2hhcnRzLmNvbS9kb2NzL3Y1L2NoYXJ0cy94eS1jaGFydC9heGVzL2F4aXMtaGVhZGVycy99IGZvciBtb3JlIGluZm9cclxuICAgICAgICAgKiBAZGVmYXVsdCBuZXcgQ29udGFpbmVyXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiYXhpc0hlYWRlclwiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiB0aGlzLmNoaWxkcmVuLnB1c2goQ29udGFpbmVyLm5ldyh0aGlzLl9yb290LCB7XHJcbiAgICAgICAgICAgICAgICB0aGVtZVRhZ3M6IFtcImF4aXNcIiwgXCJoZWFkZXJcIl0sXHJcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLFxyXG4gICAgICAgICAgICAgICAgYmFja2dyb3VuZDogUmVjdGFuZ2xlLm5ldyh0aGlzLl9yb290LCB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhlbWVUYWdzOiBbXCJoZWFkZXJcIiwgXCJiYWNrZ3JvdW5kXCJdLFxyXG4gICAgICAgICAgICAgICAgICAgIGZpbGw6IHRoaXMuX3Jvb3QuaW50ZXJmYWNlQ29sb3JzLmdldChcImJhY2tncm91bmRcIilcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIH0pKVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9idWxsZXRzXCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IHt9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBfZGlzcG9zZSgpIHtcclxuICAgICAgICAvLyB0aGVzZSBjb3VsZCBiZSBpbiBvdGhlciBwYXJlbnRzLCBzbyBkaXNwb3NpbmcganVzdCBpbiBjYXNlXHJcbiAgICAgICAgdGhpcy5ncmlkQ29udGFpbmVyLmRpc3Bvc2UoKTtcclxuICAgICAgICB0aGlzLnRvcEdyaWRDb250YWluZXIuZGlzcG9zZSgpO1xyXG4gICAgICAgIHRoaXMuYnVsbGV0c0NvbnRhaW5lci5kaXNwb3NlKCk7XHJcbiAgICAgICAgdGhpcy5sYWJlbHNDb250YWluZXIuZGlzcG9zZSgpO1xyXG4gICAgICAgIHRoaXMuYXhpc0hlYWRlci5kaXNwb3NlKCk7XHJcbiAgICAgICAgc3VwZXIuX2Rpc3Bvc2UoKTtcclxuICAgIH1cclxuICAgIF9hZnRlck5ldygpIHtcclxuICAgICAgICBzdXBlci5fYWZ0ZXJOZXcoKTtcclxuICAgICAgICB0aGlzLnNldFByaXZhdGUoXCJ1cGRhdGVTY3JvbGxiYXJcIiwgdHJ1ZSk7XHJcbiAgICAgICAgdGhpcy5fZGlzcG9zZXJzLnB1c2godGhpcy5heGlzUmFuZ2VzLmV2ZW50cy5vbkFsbCgoY2hhbmdlKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChjaGFuZ2UudHlwZSA9PT0gXCJjbGVhclwiKSB7XHJcbiAgICAgICAgICAgICAgICAkYXJyYXkuZWFjaChjaGFuZ2Uub2xkVmFsdWVzLCAoZGF0YUl0ZW0pID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc3Bvc2VEYXRhSXRlbShkYXRhSXRlbSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChjaGFuZ2UudHlwZSA9PT0gXCJwdXNoXCIpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3Byb2Nlc3NBeGlzUmFuZ2UoY2hhbmdlLm5ld1ZhbHVlLCBbXCJyYW5nZVwiXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoY2hhbmdlLnR5cGUgPT09IFwic2V0SW5kZXhcIikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcHJvY2Vzc0F4aXNSYW5nZShjaGFuZ2UubmV3VmFsdWUsIFtcInJhbmdlXCJdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChjaGFuZ2UudHlwZSA9PT0gXCJpbnNlcnRJbmRleFwiKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9wcm9jZXNzQXhpc1JhbmdlKGNoYW5nZS5uZXdWYWx1ZSwgW1wicmFuZ2VcIl0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGNoYW5nZS50eXBlID09PSBcInJlbW92ZUluZGV4XCIpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZGlzcG9zZURhdGFJdGVtKGNoYW5nZS5vbGRWYWx1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoY2hhbmdlLnR5cGUgPT09IFwibW92ZUluZGV4XCIpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3Byb2Nlc3NBeGlzUmFuZ2UoY2hhbmdlLnZhbHVlLCBbXCJyYW5nZVwiXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIElTdHJlYW1FdmVudCB0eXBlXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSkpO1xyXG4gICAgICAgIGNvbnN0IHJlbmRlcmVyID0gdGhpcy5nZXQoXCJyZW5kZXJlclwiKTtcclxuICAgICAgICBpZiAocmVuZGVyZXIpIHtcclxuICAgICAgICAgICAgcmVuZGVyZXIuYXhpcyA9IHRoaXM7XHJcbiAgICAgICAgICAgIHJlbmRlcmVyLnByb2Nlc3NBeGlzKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuY2hpbGRyZW4ucHVzaChyZW5kZXJlcik7XHJcbiAgICAgICAgdGhpcy5naG9zdExhYmVsID0gcmVuZGVyZXIubWFrZUxhYmVsKG5ldyBEYXRhSXRlbSh0aGlzLCB1bmRlZmluZWQsIHt9KSwgW10pO1xyXG4gICAgICAgIHRoaXMuZ2hvc3RMYWJlbC5hZGFwdGVycy5kaXNhYmxlKFwidGV4dFwiKTtcclxuICAgICAgICB0aGlzLmdob3N0TGFiZWwuc2V0QWxsKHsgb3BhY2l0eTogMCwgdG9vbHRpcFRleHQ6IHVuZGVmaW5lZCwgdG9vbHRpcEhUTUw6IHVuZGVmaW5lZCwgaW50ZXJhY3RpdmU6IGZhbHNlIH0pO1xyXG4gICAgICAgIHRoaXMuZ2hvc3RMYWJlbC5ldmVudHMuZGlzYWJsZSgpO1xyXG4gICAgfVxyXG4gICAgX3VwZGF0ZUZpbmFscyhfc3RhcnQsIF9lbmQpIHtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogWm9vbXMgdGhlIGF4aXMgdG8gcmVsYXRpdmUgbG9jYXRpb25zLlxyXG4gICAgICpcclxuICAgICAqIEJvdGggYHN0YXJ0YCBhbmQgYGVuZGAgYXJlIHJlbGF0aXZlOiAwIG1lYW5zIHN0YXJ0IG9mIHRoZSBheGlzLCAxIC0gZW5kLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSAgIHN0YXJ0ICAgICBSZWxhdGl2ZSBzdGFydFxyXG4gICAgICogQHBhcmFtICAgZW5kICAgICAgIFJlbGF0aXZlIGVuZFxyXG4gICAgICogQHBhcmFtICAgZHVyYXRpb24gIER1cmF0aW9uIG9mIHRoZSB6b29tIGFuaW1hdGlvbiBpbiBtaWxsaXNlY29uZHNcclxuICAgICAqIEByZXR1cm4gICAgICAgICAgICBab29tIGFuaW1hdGlvblxyXG4gICAgICovXHJcbiAgICB6b29tKHN0YXJ0LCBlbmQsIGR1cmF0aW9uLCBwcmlvcml0eSkge1xyXG4gICAgICAgIHRoaXMuX3VwZGF0ZUZpbmFscyhzdGFydCwgZW5kKTtcclxuICAgICAgICBpZiAodGhpcy5nZXQoXCJzdGFydFwiKSAhPT0gc3RhcnQgfHwgdGhpcy5nZXQoXCJlbmRcIikgIT0gZW5kKSB7XHJcbiAgICAgICAgICAgIGxldCBzQW5pbWF0aW9uID0gdGhpcy5fc0FuaW1hdGlvbjtcclxuICAgICAgICAgICAgbGV0IGVBbmltYXRpb24gPSB0aGlzLl9lQW5pbWF0aW9uO1xyXG4gICAgICAgICAgICBsZXQgbWF4RGV2aWF0aW9uID0gdGhpcy5nZXQoXCJtYXhEZXZpYXRpb25cIiwgMC41KSAqIE1hdGgubWluKDEsIChlbmQgLSBzdGFydCkpO1xyXG4gICAgICAgICAgICBpZiAoc3RhcnQgPCAtbWF4RGV2aWF0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICBzdGFydCA9IC1tYXhEZXZpYXRpb247XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGVuZCA+IDEgKyBtYXhEZXZpYXRpb24pIHtcclxuICAgICAgICAgICAgICAgIGVuZCA9IDEgKyBtYXhEZXZpYXRpb247XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHN0YXJ0ID4gZW5kKSB7XHJcbiAgICAgICAgICAgICAgICBbc3RhcnQsIGVuZF0gPSBbZW5kLCBzdGFydF07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCEkdHlwZS5pc051bWJlcihkdXJhdGlvbikpIHtcclxuICAgICAgICAgICAgICAgIGR1cmF0aW9uID0gdGhpcy5nZXQoXCJpbnRlcnBvbGF0aW9uRHVyYXRpb25cIiwgMCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCFwcmlvcml0eSkge1xyXG4gICAgICAgICAgICAgICAgcHJpb3JpdHkgPSBcImVuZFwiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGxldCBtYXhab29tRmFjdG9yID0gdGhpcy5nZXRQcml2YXRlKFwibWF4Wm9vbUZhY3RvclwiLCB0aGlzLmdldChcIm1heFpvb21GYWN0b3JcIiwgMTAwKSk7XHJcbiAgICAgICAgICAgIGxldCBtYXhab29tRmFjdG9yUmVhbCA9IG1heFpvb21GYWN0b3I7XHJcbiAgICAgICAgICAgIGlmIChlbmQgPT09IDEgJiYgc3RhcnQgIT09IDApIHtcclxuICAgICAgICAgICAgICAgIGlmIChzdGFydCA8IHRoaXMuZ2V0KFwic3RhcnRcIikpIHtcclxuICAgICAgICAgICAgICAgICAgICBwcmlvcml0eSA9IFwic3RhcnRcIjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHByaW9yaXR5ID0gXCJlbmRcIjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoc3RhcnQgPT09IDAgJiYgZW5kICE9PSAxKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZW5kID4gdGhpcy5nZXQoXCJlbmRcIikpIHtcclxuICAgICAgICAgICAgICAgICAgICBwcmlvcml0eSA9IFwiZW5kXCI7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBwcmlvcml0eSA9IFwic3RhcnRcIjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsZXQgbWluWm9vbUNvdW50ID0gdGhpcy5nZXQoXCJtaW5ab29tQ291bnRcIik7XHJcbiAgICAgICAgICAgIGxldCBtYXhab29tQ291bnQgPSB0aGlzLmdldChcIm1heFpvb21Db3VudFwiKTtcclxuICAgICAgICAgICAgaWYgKCR0eXBlLmlzTnVtYmVyKG1pblpvb21Db3VudCkpIHtcclxuICAgICAgICAgICAgICAgIG1heFpvb21GYWN0b3IgPSBtYXhab29tRmFjdG9yUmVhbCAvIG1pblpvb21Db3VudDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsZXQgbWluWm9vbUZhY3RvciA9IDE7XHJcbiAgICAgICAgICAgIGlmICgkdHlwZS5pc051bWJlcihtYXhab29tQ291bnQpKSB7XHJcbiAgICAgICAgICAgICAgICBtaW5ab29tRmFjdG9yID0gbWF4Wm9vbUZhY3RvclJlYWwgLyBtYXhab29tQ291bnQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gbW9zdCBsaWtlbHkgd2UgYXJlIGRyYWdnaW5nIGxlZnQgc2Nyb2xsYmFyIGdyaXAgaGVyZSwgc28gd2UgdGVuZCB0byBtb2RpZnkgZW5kXHJcbiAgICAgICAgICAgIGlmIChwcmlvcml0eSA9PT0gXCJzdGFydFwiKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobWF4Wm9vbUNvdW50ID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGFkZCB0byB0aGUgZW5kXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKDEgLyAoZW5kIC0gc3RhcnQpIDwgbWluWm9vbUZhY3Rvcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmQgPSBzdGFydCArIDEgLyBtaW5ab29tRmFjdG9yO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIGFkZCB0byB0aGUgZW5kXHJcbiAgICAgICAgICAgICAgICBpZiAoMSAvIChlbmQgLSBzdGFydCkgPiBtYXhab29tRmFjdG9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZW5kID0gc3RhcnQgKyAxIC8gbWF4Wm9vbUZhY3RvcjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vdW5sZXNzIGVuZCBpcyA+IDBcclxuICAgICAgICAgICAgICAgIGlmIChlbmQgPiAxICYmIGVuZCAtIHN0YXJ0IDwgMSAvIG1heFpvb21GYWN0b3IpIHtcclxuICAgICAgICAgICAgICAgICAgICAvL2VuZCA9IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQgPSBlbmQgLSAxIC8gbWF4Wm9vbUZhY3RvcjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBtb3N0IGxpa2VseSB3ZSBhcmUgZHJhZ2dpbmcgcmlnaHQsIHNvIHdlIG1vZGlmeSBsZWZ0XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWYgKG1heFpvb21Db3VudCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBhZGQgdG8gdGhlIGVuZFxyXG4gICAgICAgICAgICAgICAgICAgIGlmICgxIC8gKGVuZCAtIHN0YXJ0KSA8IG1pblpvb21GYWN0b3IpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQgPSBlbmQgLSAxIC8gbWluWm9vbUZhY3RvcjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyByZW1vdmUgZnJvbSBzdGFydFxyXG4gICAgICAgICAgICAgICAgaWYgKDEgLyAoZW5kIC0gc3RhcnQpID4gbWF4Wm9vbUZhY3Rvcikge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gZW5kIC0gMSAvIG1heFpvb21GYWN0b3I7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoc3RhcnQgPCAwICYmIGVuZCAtIHN0YXJ0IDwgMSAvIG1heFpvb21GYWN0b3IpIHtcclxuICAgICAgICAgICAgICAgICAgICAvL3N0YXJ0ID0gMDtcclxuICAgICAgICAgICAgICAgICAgICBlbmQgPSBzdGFydCArIDEgLyBtYXhab29tRmFjdG9yO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICgxIC8gKGVuZCAtIHN0YXJ0KSA+IG1heFpvb21GYWN0b3IpIHtcclxuICAgICAgICAgICAgICAgIGVuZCA9IHN0YXJ0ICsgMSAvIG1heFpvb21GYWN0b3I7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKDEgLyAoZW5kIC0gc3RhcnQpID4gbWF4Wm9vbUZhY3Rvcikge1xyXG4gICAgICAgICAgICAgICAgc3RhcnQgPSBlbmQgLSAxIC8gbWF4Wm9vbUZhY3RvcjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAobWF4Wm9vbUNvdW50ICE9IG51bGwgJiYgbWluWm9vbUNvdW50ICE9IG51bGwgJiYgKHN0YXJ0ID09IHRoaXMuZ2V0KFwic3RhcnRcIikgJiYgZW5kID09IHRoaXMuZ2V0KFwiZW5kXCIpKSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY2hhcnQgPSB0aGlzLmNoYXJ0O1xyXG4gICAgICAgICAgICAgICAgaWYgKGNoYXJ0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2hhcnQuX2hhbmRsZUF4aXNTZWxlY3Rpb24odGhpcywgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCgoc0FuaW1hdGlvbiAmJiBzQW5pbWF0aW9uLnBsYXlpbmcgJiYgc0FuaW1hdGlvbi50byA9PSBzdGFydCkgfHwgdGhpcy5nZXQoXCJzdGFydFwiKSA9PSBzdGFydCkgJiYgKChlQW5pbWF0aW9uICYmIGVBbmltYXRpb24ucGxheWluZyAmJiBlQW5pbWF0aW9uLnRvID09IGVuZCkgfHwgdGhpcy5nZXQoXCJlbmRcIikgPT0gZW5kKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChkdXJhdGlvbiA+IDApIHtcclxuICAgICAgICAgICAgICAgIGxldCBlYXNpbmcgPSB0aGlzLmdldChcImludGVycG9sYXRpb25FYXNpbmdcIik7XHJcbiAgICAgICAgICAgICAgICBsZXQgc0FuaW1hdGlvbiwgZUFuaW1hdGlvbjtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmdldChcInN0YXJ0XCIpICE9IHN0YXJ0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc0FuaW1hdGlvbiA9IHRoaXMuYW5pbWF0ZSh7IGtleTogXCJzdGFydFwiLCB0bzogc3RhcnQsIGR1cmF0aW9uOiBkdXJhdGlvbiwgZWFzaW5nOiBlYXNpbmcgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5nZXQoXCJlbmRcIikgIT0gZW5kKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZUFuaW1hdGlvbiA9IHRoaXMuYW5pbWF0ZSh7IGtleTogXCJlbmRcIiwgdG86IGVuZCwgZHVyYXRpb246IGR1cmF0aW9uLCBlYXNpbmc6IGVhc2luZyB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuX3NBbmltYXRpb24gPSBzQW5pbWF0aW9uO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZUFuaW1hdGlvbiA9IGVBbmltYXRpb247XHJcbiAgICAgICAgICAgICAgICBpZiAoc0FuaW1hdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzQW5pbWF0aW9uO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZUFuaW1hdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlQW5pbWF0aW9uO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZXQoXCJzdGFydFwiLCBzdGFydCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNldChcImVuZFwiLCBlbmQpO1xyXG4gICAgICAgICAgICAgICAgLy8gb3RoZXJ3aXNlIGJ1bGxldHMgYW5kIGxpbmUgb3V0IG9mIHN5bmMsIGFzIHNlcmllcyBpcyBub3QgcmVkcmF3blxyXG4gICAgICAgICAgICAgICAgdGhpcy5fcm9vdC5ldmVudHMub25jZShcImZyYW1lZW5kZWRcIiwgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX21hcmtEaXJ0eUtleShcInN0YXJ0XCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3Jvb3QuX21hcmtEaXJ0eSgpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9zQW5pbWF0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zQW5pbWF0aW9uLnN0b3AoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodGhpcy5fZUFuaW1hdGlvbikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZUFuaW1hdGlvbi5zdG9wKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEEgbGlzdCBvZiBzZXJpZXMgdXNpbmcgdGhpcyBheGlzLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm4gU2VyaWVzXHJcbiAgICAgKi9cclxuICAgIGdldCBzZXJpZXMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NlcmllcztcclxuICAgIH1cclxuICAgIF9wcm9jZXNzQXhpc1JhbmdlKGRhdGFJdGVtLCB0aGVtZVRhZ3MpIHtcclxuICAgICAgICBkYXRhSXRlbS5zZXRSYXcoXCJpc1JhbmdlXCIsIHRydWUpO1xyXG4gICAgICAgIHRoaXMuX2NyZWF0ZUFzc2V0cyhkYXRhSXRlbSwgdGhlbWVUYWdzKTtcclxuICAgICAgICB0aGlzLl9yYW5nZXNEaXJ0eSA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5fcHJlcGFyZURhdGFJdGVtKGRhdGFJdGVtKTtcclxuICAgICAgICBjb25zdCBhYm92ZSA9IGRhdGFJdGVtLmdldChcImFib3ZlXCIpO1xyXG4gICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IHRoaXMudG9wR3JpZENvbnRhaW5lcjtcclxuICAgICAgICBjb25zdCBncmlkID0gZGF0YUl0ZW0uZ2V0KFwiZ3JpZFwiKTtcclxuICAgICAgICBpZiAoYWJvdmUgJiYgZ3JpZCkge1xyXG4gICAgICAgICAgICBjb250YWluZXIuY2hpbGRyZW4ubW92ZVZhbHVlKGdyaWQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBmaWxsID0gZGF0YUl0ZW0uZ2V0KFwiYXhpc0ZpbGxcIik7XHJcbiAgICAgICAgaWYgKGFib3ZlICYmIGZpbGwpIHtcclxuICAgICAgICAgICAgY29udGFpbmVyLmNoaWxkcmVuLm1vdmVWYWx1ZShmaWxsKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBfcHJlcGFyZURhdGFJdGVtKF9kYXRhSXRlbSwgX2luZGV4KSB7IH1cclxuICAgIC8qKlxyXG4gICAgICogQGlnbm9yZVxyXG4gICAgICovXHJcbiAgICBtYXJrRGlydHlFeHRyZW1lcygpIHtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQGlnbm9yZVxyXG4gICAgICovXHJcbiAgICBtYXJrRGlydHlTZWxlY3Rpb25FeHRyZW1lcygpIHtcclxuICAgIH1cclxuICAgIF9jYWxjdWxhdGVUb3RhbHMoKSB7XHJcbiAgICB9XHJcbiAgICBfdXBkYXRlQXhpc1JhbmdlcygpIHtcclxuICAgICAgICB0aGlzLl9idWxsZXRzID0ge307XHJcbiAgICAgICAgdGhpcy5heGlzUmFuZ2VzLmVhY2goKGF4aXNSYW5nZSkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLl9wcmVwYXJlRGF0YUl0ZW0oYXhpc1JhbmdlKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICAkYXJyYXkuZWFjaCh0aGlzLl9zZXJpZXNBeGlzUmFuZ2VzLCAoYXhpc1JhbmdlKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuX3ByZXBhcmVEYXRhSXRlbShheGlzUmFuZ2UpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgX3ByZXBhcmVDaGlsZHJlbigpIHtcclxuICAgICAgICBzdXBlci5fcHJlcGFyZUNoaWxkcmVuKCk7XHJcbiAgICAgICAgaWYgKHRoaXMuZ2V0KFwiZml4QXhpc1NpemVcIikpIHtcclxuICAgICAgICAgICAgdGhpcy5naG9zdExhYmVsLnNldChcInZpc2libGVcIiwgdHJ1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLmdob3N0TGFiZWwuc2V0KFwidmlzaWJsZVwiLCBmYWxzZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmlzRGlydHkoXCJzdGFydFwiKSB8fCB0aGlzLmlzRGlydHkoXCJlbmRcIikpIHtcclxuICAgICAgICAgICAgY29uc3QgY2hhcnQgPSB0aGlzLmNoYXJ0O1xyXG4gICAgICAgICAgICBpZiAoY2hhcnQpIHtcclxuICAgICAgICAgICAgICAgIGNoYXJ0Ll91cGRhdGVDdXJzb3IoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsZXQgc3RhcnQgPSB0aGlzLmdldChcInN0YXJ0XCIsIDApO1xyXG4gICAgICAgICAgICBsZXQgZW5kID0gdGhpcy5nZXQoXCJlbmRcIiwgMSk7XHJcbiAgICAgICAgICAgIGxldCBtYXhEZXZpYXRpb24gPSB0aGlzLmdldChcIm1heERldmlhdGlvblwiLCAwLjUpICogTWF0aC5taW4oMSwgKGVuZCAtIHN0YXJ0KSk7XHJcbiAgICAgICAgICAgIGlmIChzdGFydCA8IC1tYXhEZXZpYXRpb24pIHtcclxuICAgICAgICAgICAgICAgIGxldCBkZWx0YSA9IHN0YXJ0ICsgbWF4RGV2aWF0aW9uO1xyXG4gICAgICAgICAgICAgICAgc3RhcnQgPSAtbWF4RGV2aWF0aW9uO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZXRSYXcoXCJzdGFydFwiLCBzdGFydCk7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pc0RpcnR5KFwiZW5kXCIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRSYXcoXCJlbmRcIiwgZW5kIC0gZGVsdGEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChlbmQgPiAxICsgbWF4RGV2aWF0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgZGVsdGEgPSBlbmQgLSAxIC0gbWF4RGV2aWF0aW9uO1xyXG4gICAgICAgICAgICAgICAgZW5kID0gMSArIG1heERldmlhdGlvbjtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2V0UmF3KFwiZW5kXCIsIGVuZCk7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pc0RpcnR5KFwic3RhcnRcIikpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFJhdyhcInN0YXJ0XCIsIHN0YXJ0IC0gZGVsdGEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHJlbmRlcmVyID0gdGhpcy5nZXQoXCJyZW5kZXJlclwiKTtcclxuICAgICAgICByZW5kZXJlci5fc3RhcnQgPSB0aGlzLmdldChcInN0YXJ0XCIpO1xyXG4gICAgICAgIHJlbmRlcmVyLl9lbmQgPSB0aGlzLmdldChcImVuZFwiKTtcclxuICAgICAgICByZW5kZXJlci5faW52ZXJzZWQgPSByZW5kZXJlci5nZXQoXCJpbnZlcnNlZFwiLCBmYWxzZSk7XHJcbiAgICAgICAgcmVuZGVyZXIuX2F4aXNMZW5ndGggPSByZW5kZXJlci5heGlzTGVuZ3RoKCkgLyAocmVuZGVyZXIuX2VuZCAtIHJlbmRlcmVyLl9zdGFydCk7XHJcbiAgICAgICAgcmVuZGVyZXIuX3VwZGF0ZUxDKCk7XHJcbiAgICAgICAgaWYgKHRoaXMuaXNEaXJ0eShcInRvb2x0aXBcIikpIHtcclxuICAgICAgICAgICAgY29uc3QgdG9vbHRpcCA9IHRoaXMuZ2V0KFwidG9vbHRpcFwiKTtcclxuICAgICAgICAgICAgaWYgKHRvb2x0aXApIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHJlbmRlcmVyVGFncyA9IHJlbmRlcmVyLmdldChcInRoZW1lVGFnc1wiKTtcclxuICAgICAgICAgICAgICAgIHRvb2x0aXAuYWRkVGFnKFwiYXhpc1wiKTtcclxuICAgICAgICAgICAgICAgIHRvb2x0aXAuYWRkVGFnKHRoaXMuY2xhc3NOYW1lLnRvTG93ZXJDYXNlKCkpO1xyXG4gICAgICAgICAgICAgICAgdG9vbHRpcC5fYXBwbHlUaGVtZXMoKTtcclxuICAgICAgICAgICAgICAgIGlmIChyZW5kZXJlclRhZ3MpIHtcclxuICAgICAgICAgICAgICAgICAgICB0b29sdGlwLnNldChcInRoZW1lVGFnc1wiLCAkdXRpbHMubWVyZ2VUYWdzKHRvb2x0aXAuZ2V0KFwidGhlbWVUYWdzXCIpLCByZW5kZXJlclRhZ3MpKTtcclxuICAgICAgICAgICAgICAgICAgICB0b29sdGlwLmxhYmVsLl9hcHBseVRoZW1lcygpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgX3VwZGF0ZVRvb2x0aXBCb3VuZHMoKSB7XHJcbiAgICAgICAgY29uc3QgdG9vbHRpcCA9IHRoaXMuZ2V0KFwidG9vbHRpcFwiKTtcclxuICAgICAgICBpZiAodG9vbHRpcCkge1xyXG4gICAgICAgICAgICB0aGlzLmdldChcInJlbmRlcmVyXCIpLnVwZGF0ZVRvb2x0aXBCb3VuZHModG9vbHRpcCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgX3VwZGF0ZUJvdW5kcygpIHtcclxuICAgICAgICBzdXBlci5fdXBkYXRlQm91bmRzKCk7XHJcbiAgICAgICAgdGhpcy5fdXBkYXRlVG9vbHRpcEJvdW5kcygpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAaWdub3JlXHJcbiAgICAgKi9cclxuICAgIHByb2Nlc3NDaGFydChjaGFydCkge1xyXG4gICAgICAgIHRoaXMuY2hhcnQgPSBjaGFydDtcclxuICAgICAgICBjb25zdCByZW5kZXJlciA9IHRoaXMuZ2V0KFwicmVuZGVyZXJcIik7XHJcbiAgICAgICAgcmVuZGVyZXIuY2hhcnQgPSBjaGFydDtcclxuICAgICAgICBjaGFydC5ncmlkQ29udGFpbmVyLmNoaWxkcmVuLnB1c2godGhpcy5ncmlkQ29udGFpbmVyKTtcclxuICAgICAgICBjaGFydC50b3BHcmlkQ29udGFpbmVyLmNoaWxkcmVuLnB1c2godGhpcy50b3BHcmlkQ29udGFpbmVyKTtcclxuICAgICAgICBjaGFydC5heGlzSGVhZGVyc0NvbnRhaW5lci5jaGlsZHJlbi5wdXNoKHRoaXMuYXhpc0hlYWRlcik7XHJcbiAgICAgICAgdGhpcy5vbihcInN0YXJ0XCIsICgpID0+IHtcclxuICAgICAgICAgICAgY2hhcnQuX2hhbmRsZUF4aXNTZWxlY3Rpb24odGhpcyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5vbihcImVuZFwiLCAoKSA9PiB7XHJcbiAgICAgICAgICAgIGNoYXJ0Ll9oYW5kbGVBeGlzU2VsZWN0aW9uKHRoaXMpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGNoYXJ0LnBsb3RDb250YWluZXIub25Qcml2YXRlKFwid2lkdGhcIiwgKCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLm1hcmtEaXJ0eVNpemUoKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBjaGFydC5wbG90Q29udGFpbmVyLm9uUHJpdmF0ZShcImhlaWdodFwiLCAoKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMubWFya0RpcnR5U2l6ZSgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGNoYXJ0LnByb2Nlc3NBeGlzKHRoaXMpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAaWdub3JlXHJcbiAgICAgKi9cclxuICAgIGhpZGVEYXRhSXRlbShkYXRhSXRlbSkge1xyXG4gICAgICAgIHRoaXMuX3RvZ2dsZUZIRGF0YUl0ZW0oZGF0YUl0ZW0sIHRydWUpO1xyXG4gICAgICAgIHJldHVybiBzdXBlci5oaWRlRGF0YUl0ZW0oZGF0YUl0ZW0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAaWdub3JlXHJcbiAgICAgKi9cclxuICAgIHNob3dEYXRhSXRlbShkYXRhSXRlbSkge1xyXG4gICAgICAgIHRoaXMuX3RvZ2dsZUZIRGF0YUl0ZW0oZGF0YUl0ZW0sIGZhbHNlKTtcclxuICAgICAgICByZXR1cm4gc3VwZXIuc2hvd0RhdGFJdGVtKGRhdGFJdGVtKTtcclxuICAgIH1cclxuICAgIF90b2dnbGVGSERhdGFJdGVtKGRhdGFJdGVtLCBmb3JjZUhpZGRlbikge1xyXG4gICAgICAgIGNvbnN0IGZoID0gXCJmb3JjZUhpZGRlblwiO1xyXG4gICAgICAgIGNvbnN0IGxhYmVsID0gZGF0YUl0ZW0uZ2V0KFwibGFiZWxcIik7XHJcbiAgICAgICAgaWYgKGxhYmVsKSB7XHJcbiAgICAgICAgICAgIGxhYmVsLnNldChmaCwgZm9yY2VIaWRkZW4pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBncmlkID0gZGF0YUl0ZW0uZ2V0KFwiZ3JpZFwiKTtcclxuICAgICAgICBpZiAoZ3JpZCkge1xyXG4gICAgICAgICAgICBncmlkLnNldChmaCwgZm9yY2VIaWRkZW4pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCB0aWNrID0gZGF0YUl0ZW0uZ2V0KFwidGlja1wiKTtcclxuICAgICAgICBpZiAodGljaykge1xyXG4gICAgICAgICAgICB0aWNrLnNldChmaCwgZm9yY2VIaWRkZW4pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBheGlzRmlsbCA9IGRhdGFJdGVtLmdldChcImF4aXNGaWxsXCIpO1xyXG4gICAgICAgIGlmIChheGlzRmlsbCkge1xyXG4gICAgICAgICAgICBheGlzRmlsbC5zZXQoZmgsIGZvcmNlSGlkZGVuKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgYnVsbGV0ID0gZGF0YUl0ZW0uZ2V0KFwiYnVsbGV0XCIpO1xyXG4gICAgICAgIGlmIChidWxsZXQpIHtcclxuICAgICAgICAgICAgY29uc3Qgc3ByaXRlID0gYnVsbGV0LmdldChcInNwcml0ZVwiKTtcclxuICAgICAgICAgICAgaWYgKHNwcml0ZSkge1xyXG4gICAgICAgICAgICAgICAgc3ByaXRlLnNldChmaCwgZm9yY2VIaWRkZW4pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgX3RvZ2dsZURhdGFJdGVtKGRhdGFJdGVtLCB2aXNpYmxlKSB7XHJcbiAgICAgICAgY29uc3QgbGFiZWwgPSBkYXRhSXRlbS5nZXQoXCJsYWJlbFwiKTtcclxuICAgICAgICBjb25zdCB2ID0gXCJ2aXNpYmxlXCI7XHJcbiAgICAgICAgaWYgKGxhYmVsKSB7XHJcbiAgICAgICAgICAgIGxhYmVsLnNldFByaXZhdGUodiwgdmlzaWJsZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGdyaWQgPSBkYXRhSXRlbS5nZXQoXCJncmlkXCIpO1xyXG4gICAgICAgIGlmIChncmlkKSB7XHJcbiAgICAgICAgICAgIGdyaWQuc2V0UHJpdmF0ZSh2LCB2aXNpYmxlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgdGljayA9IGRhdGFJdGVtLmdldChcInRpY2tcIik7XHJcbiAgICAgICAgaWYgKHRpY2spIHtcclxuICAgICAgICAgICAgdGljay5zZXRQcml2YXRlKHYsIHZpc2libGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBheGlzRmlsbCA9IGRhdGFJdGVtLmdldChcImF4aXNGaWxsXCIpO1xyXG4gICAgICAgIGlmIChheGlzRmlsbCkge1xyXG4gICAgICAgICAgICBheGlzRmlsbC5zZXRQcml2YXRlKHYsIHZpc2libGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBidWxsZXQgPSBkYXRhSXRlbS5nZXQoXCJidWxsZXRcIik7XHJcbiAgICAgICAgaWYgKGJ1bGxldCkge1xyXG4gICAgICAgICAgICBjb25zdCBzcHJpdGUgPSBidWxsZXQuZ2V0KFwic3ByaXRlXCIpO1xyXG4gICAgICAgICAgICBpZiAoc3ByaXRlKSB7XHJcbiAgICAgICAgICAgICAgICBzcHJpdGUuc2V0UHJpdmF0ZSh2LCB2aXNpYmxlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIF9jcmVhdGVBc3NldHMoZGF0YUl0ZW0sIHRhZ3MsIG1pbm9yKSB7XHJcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XHJcbiAgICAgICAgY29uc3QgcmVuZGVyZXIgPSB0aGlzLmdldChcInJlbmRlcmVyXCIpO1xyXG4gICAgICAgIGxldCBtID0gXCJtaW5vclwiO1xyXG4gICAgICAgIGNvbnN0IGxhYmVsID0gZGF0YUl0ZW0uZ2V0KFwibGFiZWxcIik7XHJcbiAgICAgICAgaWYgKCFsYWJlbCkge1xyXG4gICAgICAgICAgICByZW5kZXJlci5tYWtlTGFiZWwoZGF0YUl0ZW0sIHRhZ3MpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgbGV0IHRoZW1lVGFncyA9IGxhYmVsLmdldChcInRoZW1lVGFnc1wiKTtcclxuICAgICAgICAgICAgbGV0IHJlbW92ZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICBpZiAobWlub3IpIHtcclxuICAgICAgICAgICAgICAgIGlmICgodGhlbWVUYWdzID09PSBudWxsIHx8IHRoZW1lVGFncyA9PT0gdm9pZCAwID8gdm9pZCAwIDogdGhlbWVUYWdzLmluZGV4T2YobSkpID09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlmICgodGhlbWVUYWdzID09PSBudWxsIHx8IHRoZW1lVGFncyA9PT0gdm9pZCAwID8gdm9pZCAwIDogdGhlbWVUYWdzLmluZGV4T2YobSkpICE9IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAocmVtb3ZlKSB7XHJcbiAgICAgICAgICAgICAgICAoX2EgPSBsYWJlbC5wYXJlbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jaGlsZHJlbi5yZW1vdmVWYWx1ZShsYWJlbCk7XHJcbiAgICAgICAgICAgICAgICByZW5kZXJlci5tYWtlTGFiZWwoZGF0YUl0ZW0sIHRhZ3MpO1xyXG4gICAgICAgICAgICAgICAgbGFiZWwuZGlzcG9zZSgpO1xyXG4gICAgICAgICAgICAgICAgcmVuZGVyZXIubGFiZWxzLnJlbW92ZVZhbHVlKGxhYmVsKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBncmlkID0gZGF0YUl0ZW0uZ2V0KFwiZ3JpZFwiKTtcclxuICAgICAgICBpZiAoIWdyaWQpIHtcclxuICAgICAgICAgICAgcmVuZGVyZXIubWFrZUdyaWQoZGF0YUl0ZW0sIHRhZ3MpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgbGV0IHRoZW1lVGFncyA9IGdyaWQuZ2V0KFwidGhlbWVUYWdzXCIpO1xyXG4gICAgICAgICAgICBsZXQgcmVtb3ZlID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGlmIChtaW5vcikge1xyXG4gICAgICAgICAgICAgICAgaWYgKCh0aGVtZVRhZ3MgPT09IG51bGwgfHwgdGhlbWVUYWdzID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0aGVtZVRhZ3MuaW5kZXhPZihtKSkgPT0gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICByZW1vdmUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWYgKCh0aGVtZVRhZ3MgPT09IG51bGwgfHwgdGhlbWVUYWdzID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0aGVtZVRhZ3MuaW5kZXhPZihtKSkgIT0gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICByZW1vdmUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChyZW1vdmUpIHtcclxuICAgICAgICAgICAgICAgIChfYiA9IGdyaWQucGFyZW50KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2hpbGRyZW4ucmVtb3ZlVmFsdWUoZ3JpZCk7XHJcbiAgICAgICAgICAgICAgICByZW5kZXJlci5tYWtlR3JpZChkYXRhSXRlbSwgdGFncyk7XHJcbiAgICAgICAgICAgICAgICBncmlkLmRpc3Bvc2UoKTtcclxuICAgICAgICAgICAgICAgIHJlbmRlcmVyLmdyaWQucmVtb3ZlVmFsdWUoZ3JpZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgdGljayA9IGRhdGFJdGVtLmdldChcInRpY2tcIik7XHJcbiAgICAgICAgaWYgKCF0aWNrKSB7XHJcbiAgICAgICAgICAgIHJlbmRlcmVyLm1ha2VUaWNrKGRhdGFJdGVtLCB0YWdzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGxldCByZW1vdmUgPSBmYWxzZTtcclxuICAgICAgICAgICAgbGV0IHRoZW1lVGFncyA9IHRpY2suZ2V0KFwidGhlbWVUYWdzXCIpO1xyXG4gICAgICAgICAgICBpZiAobWlub3IpIHtcclxuICAgICAgICAgICAgICAgIGlmICgodGhlbWVUYWdzID09PSBudWxsIHx8IHRoZW1lVGFncyA9PT0gdm9pZCAwID8gdm9pZCAwIDogdGhlbWVUYWdzLmluZGV4T2YobSkpID09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlmICgodGhlbWVUYWdzID09PSBudWxsIHx8IHRoZW1lVGFncyA9PT0gdm9pZCAwID8gdm9pZCAwIDogdGhlbWVUYWdzLmluZGV4T2YobSkpICE9IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAocmVtb3ZlKSB7XHJcbiAgICAgICAgICAgICAgICAoX2MgPSB0aWNrLnBhcmVudCkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmNoaWxkcmVuLnJlbW92ZVZhbHVlKHRpY2spO1xyXG4gICAgICAgICAgICAgICAgcmVuZGVyZXIubWFrZVRpY2soZGF0YUl0ZW0sIHRhZ3MpO1xyXG4gICAgICAgICAgICAgICAgdGljay5kaXNwb3NlKCk7XHJcbiAgICAgICAgICAgICAgICByZW5kZXJlci50aWNrcy5yZW1vdmVWYWx1ZSh0aWNrKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIW1pbm9yICYmICFkYXRhSXRlbS5nZXQoXCJheGlzRmlsbFwiKSkge1xyXG4gICAgICAgICAgICByZW5kZXJlci5tYWtlQXhpc0ZpbGwoZGF0YUl0ZW0sIHRhZ3MpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9wcm9jZXNzQnVsbGV0KGRhdGFJdGVtKTtcclxuICAgIH1cclxuICAgIF9wcm9jZXNzQnVsbGV0KGRhdGFJdGVtKSB7XHJcbiAgICAgICAgbGV0IGJ1bGxldCA9IGRhdGFJdGVtLmdldChcImJ1bGxldFwiKTtcclxuICAgICAgICBsZXQgYXhpc0J1bGxldCA9IHRoaXMuZ2V0KFwiYnVsbGV0XCIpO1xyXG4gICAgICAgIGlmICghYnVsbGV0ICYmIGF4aXNCdWxsZXQgJiYgIWRhdGFJdGVtLmdldChcImlzUmFuZ2VcIikpIHtcclxuICAgICAgICAgICAgYnVsbGV0ID0gYXhpc0J1bGxldCh0aGlzLl9yb290LCB0aGlzLCBkYXRhSXRlbSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChidWxsZXQpIHtcclxuICAgICAgICAgICAgYnVsbGV0LmF4aXMgPSB0aGlzO1xyXG4gICAgICAgICAgICBjb25zdCBzcHJpdGUgPSBidWxsZXQuZ2V0KFwic3ByaXRlXCIpO1xyXG4gICAgICAgICAgICBpZiAoc3ByaXRlKSB7XHJcbiAgICAgICAgICAgICAgICBzcHJpdGUuX3NldERhdGFJdGVtKGRhdGFJdGVtKTtcclxuICAgICAgICAgICAgICAgIGRhdGFJdGVtLnNldFJhdyhcImJ1bGxldFwiLCBidWxsZXQpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFzcHJpdGUucGFyZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5idWxsZXRzQ29udGFpbmVyLmNoaWxkcmVuLnB1c2goc3ByaXRlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIF9hZnRlckNoYW5nZWQoKSB7XHJcbiAgICAgICAgc3VwZXIuX2FmdGVyQ2hhbmdlZCgpO1xyXG4gICAgICAgIGNvbnN0IGNoYXJ0ID0gdGhpcy5jaGFydDtcclxuICAgICAgICBpZiAoY2hhcnQpIHtcclxuICAgICAgICAgICAgY2hhcnQuX3VwZGF0ZUNoYXJ0TGF5b3V0KCk7XHJcbiAgICAgICAgICAgIGNoYXJ0LmF4aXNIZWFkZXJzQ29udGFpbmVyLm1hcmtEaXJ0eVNpemUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5nZXQoXCJyZW5kZXJlclwiKS5fdXBkYXRlUG9zaXRpb25zKCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEBpZ25vcmVcclxuICAgICAqL1xyXG4gICAgZGlzcG9zZURhdGFJdGVtKGRhdGFJdGVtKSB7XHJcbiAgICAgICAgc3VwZXIuZGlzcG9zZURhdGFJdGVtKGRhdGFJdGVtKTtcclxuICAgICAgICBjb25zdCByZW5kZXJlciA9IHRoaXMuZ2V0KFwicmVuZGVyZXJcIik7XHJcbiAgICAgICAgY29uc3QgbGFiZWwgPSBkYXRhSXRlbS5nZXQoXCJsYWJlbFwiKTtcclxuICAgICAgICBpZiAobGFiZWwpIHtcclxuICAgICAgICAgICAgcmVuZGVyZXIubGFiZWxzLnJlbW92ZVZhbHVlKGxhYmVsKTtcclxuICAgICAgICAgICAgbGFiZWwuZGlzcG9zZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCB0aWNrID0gZGF0YUl0ZW0uZ2V0KFwidGlja1wiKTtcclxuICAgICAgICBpZiAodGljaykge1xyXG4gICAgICAgICAgICByZW5kZXJlci50aWNrcy5yZW1vdmVWYWx1ZSh0aWNrKTtcclxuICAgICAgICAgICAgdGljay5kaXNwb3NlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGdyaWQgPSBkYXRhSXRlbS5nZXQoXCJncmlkXCIpO1xyXG4gICAgICAgIGlmIChncmlkKSB7XHJcbiAgICAgICAgICAgIHJlbmRlcmVyLmdyaWQucmVtb3ZlVmFsdWUoZ3JpZCk7XHJcbiAgICAgICAgICAgIGdyaWQuZGlzcG9zZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBheGlzRmlsbCA9IGRhdGFJdGVtLmdldChcImF4aXNGaWxsXCIpO1xyXG4gICAgICAgIGlmIChheGlzRmlsbCkge1xyXG4gICAgICAgICAgICByZW5kZXJlci5heGlzRmlsbHMucmVtb3ZlVmFsdWUoYXhpc0ZpbGwpO1xyXG4gICAgICAgICAgICBheGlzRmlsbC5kaXNwb3NlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGJ1bGxldCA9IGRhdGFJdGVtLmdldChcImJ1bGxldFwiKTtcclxuICAgICAgICBpZiAoYnVsbGV0KSB7XHJcbiAgICAgICAgICAgIGJ1bGxldC5kaXNwb3NlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgX3VwZGF0ZUdob3N0KCkge1xyXG4gICAgICAgIHRoaXMuc2V0UHJpdmF0ZShcImNlbGxXaWR0aFwiLCB0aGlzLmdldENlbGxXaWR0aFBvc2l0aW9uKCkgKiB0aGlzLmdldChcInJlbmRlcmVyXCIpLmF4aXNMZW5ndGgoKSk7XHJcbiAgICAgICAgY29uc3QgZ2hvc3RMYWJlbCA9IHRoaXMuZ2hvc3RMYWJlbDtcclxuICAgICAgICBpZiAoIWdob3N0TGFiZWwuaXNIaWRkZW4oKSkge1xyXG4gICAgICAgICAgICBjb25zdCBib3VuZHMgPSBnaG9zdExhYmVsLmxvY2FsQm91bmRzKCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGdXaWR0aCA9IE1hdGguY2VpbChib3VuZHMucmlnaHQgLSBib3VuZHMubGVmdCk7XHJcbiAgICAgICAgICAgIGxldCB0ZXh0ID0gZ2hvc3RMYWJlbC5nZXQoXCJ0ZXh0XCIpO1xyXG4gICAgICAgICAgICAkYXJyYXkuZWFjaCh0aGlzLmRhdGFJdGVtcywgKGRhdGFJdGVtKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBsYWJlbCA9IGRhdGFJdGVtLmdldChcImxhYmVsXCIpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGxhYmVsICYmICFsYWJlbC5pc0hpZGRlbigpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYm91bmRzID0gbGFiZWwubG9jYWxCb3VuZHMoKTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB3ID0gTWF0aC5jZWlsKGJvdW5kcy5yaWdodCAtIGJvdW5kcy5sZWZ0KTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodyA+IGdXaWR0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0ID0gbGFiZWwudGV4dC5fZ2V0VGV4dCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGdob3N0TGFiZWwuc2V0KFwidGV4dFwiLCB0ZXh0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IHN0YXJ0ID0gdGhpcy5nZXQoXCJzdGFydFwiLCAwKTtcclxuICAgICAgICBsZXQgZW5kID0gdGhpcy5nZXQoXCJlbmRcIiwgMSk7XHJcbiAgICAgICAgdGhpcy5nZXQoXCJyZW5kZXJlclwiKS51cGRhdGVMYWJlbChnaG9zdExhYmVsLCBzdGFydCArIChlbmQgLSBzdGFydCkgKiAwLjUpO1xyXG4gICAgfVxyXG4gICAgX2hhbmRsZUN1cnNvclBvc2l0aW9uKHBvc2l0aW9uLCBzbmFwVG9TZXJpZXMpIHtcclxuICAgICAgICBjb25zdCByZW5kZXJlciA9IHRoaXMuZ2V0KFwicmVuZGVyZXJcIik7XHJcbiAgICAgICAgcG9zaXRpb24gPSByZW5kZXJlci50b0F4aXNQb3NpdGlvbihwb3NpdGlvbik7XHJcbiAgICAgICAgdGhpcy5fY3Vyc29yUG9zaXRpb24gPSBwb3NpdGlvbjtcclxuICAgICAgICB0aGlzLl9zbmFwVG9TZXJpZXMgPSBzbmFwVG9TZXJpZXM7XHJcbiAgICAgICAgdGhpcy51cGRhdGVUb29sdGlwKCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENhbiBiZSBjYWxsZWQgd2hlbiBheGlzIHpvb20gY2hhbmdlcyBhbmQgeW91IG5lZWQgdG8gdXBkYXRlIHRvb2x0aXBcclxuICAgICAqIHBvc2l0aW9uLlxyXG4gICAgICovXHJcbiAgICB1cGRhdGVUb29sdGlwKCkge1xyXG4gICAgICAgIGNvbnN0IHNuYXBUb1NlcmllcyA9IHRoaXMuX3NuYXBUb1NlcmllcztcclxuICAgICAgICBsZXQgcG9zaXRpb24gPSB0aGlzLl9jdXJzb3JQb3NpdGlvbjtcclxuICAgICAgICBjb25zdCB0b29sdGlwID0gdGhpcy5nZXQoXCJ0b29sdGlwXCIpO1xyXG4gICAgICAgIGNvbnN0IHJlbmRlcmVyID0gdGhpcy5nZXQoXCJyZW5kZXJlclwiKTtcclxuICAgICAgICBpZiAoJHR5cGUuaXNOdW1iZXIocG9zaXRpb24pKSB7XHJcbiAgICAgICAgICAgICRhcnJheS5lYWNoKHRoaXMuc2VyaWVzLCAoc2VyaWVzKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoc2VyaWVzLmdldChcImJhc2VBeGlzXCIpID09PSB0aGlzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGF0YUl0ZW0gPSB0aGlzLmdldFNlcmllc0l0ZW0oc2VyaWVzLCBwb3NpdGlvbiwgdGhpcy5nZXQoXCJ0b29sdGlwTG9jYXRpb25cIikpO1xyXG4gICAgICAgICAgICAgICAgICAgIHNlcmllcy5zZXRSYXcoXCJ0b29sdGlwRGF0YUl0ZW1cIiwgZGF0YUl0ZW0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzbmFwVG9TZXJpZXMgJiYgc25hcFRvU2VyaWVzLmluZGV4T2Yoc2VyaWVzKSAhPSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXJpZXMudXBkYXRlTGVnZW5kTWFya2VyKGRhdGFJdGVtKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2VyaWVzLnVwZGF0ZUxlZ2VuZFZhbHVlKGRhdGFJdGVtKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlcmllcy5zaG93RGF0YUl0ZW1Ub29sdGlwKGRhdGFJdGVtKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBpZiAodG9vbHRpcCkge1xyXG4gICAgICAgICAgICAgICAgcmVuZGVyZXIudXBkYXRlVG9vbHRpcEJvdW5kcyh0b29sdGlwKTtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmdldChcInNuYXBUb29sdGlwXCIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24gPSB0aGlzLnJvdW5kQXhpc1Bvc2l0aW9uKHBvc2l0aW9uLCB0aGlzLmdldChcInRvb2x0aXBMb2NhdGlvblwiLCAwLjUpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICghJHR5cGUuaXNOYU4ocG9zaXRpb24pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRQcml2YXRlUmF3KFwidG9vbHRpcFBvc2l0aW9uXCIsIHBvc2l0aW9uKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGVUb29sdGlwVGV4dCh0b29sdGlwLCBwb3NpdGlvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyZXIucG9zaXRpb25Ub29sdGlwKHRvb2x0aXAsIHBvc2l0aW9uKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocG9zaXRpb24gPCB0aGlzLmdldChcInN0YXJ0XCIpIHx8IHBvc2l0aW9uID4gdGhpcy5nZXQoXCJlbmRcIikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdG9vbHRpcC5oaWRlKDApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdG9vbHRpcC5zaG93KDApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRvb2x0aXAuaGlkZSgwKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIF91cGRhdGVUb29sdGlwVGV4dCh0b29sdGlwLCBwb3NpdGlvbikge1xyXG4gICAgICAgIHRvb2x0aXAubGFiZWwuc2V0KFwidGV4dFwiLCB0aGlzLmdldFRvb2x0aXBUZXh0KHBvc2l0aW9uKSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEBpZ25vcmVcclxuICAgICAqL1xyXG4gICAgcm91bmRBeGlzUG9zaXRpb24ocG9zaXRpb24sIF9sb2NhdGlvbikge1xyXG4gICAgICAgIHJldHVybiBwb3NpdGlvbjtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQGlnbm9yZVxyXG4gICAgICovXHJcbiAgICBoYW5kbGVDdXJzb3JTaG93KCkge1xyXG4gICAgICAgIGxldCB0b29sdGlwID0gdGhpcy5nZXQoXCJ0b29sdGlwXCIpO1xyXG4gICAgICAgIGlmICh0b29sdGlwKSB7XHJcbiAgICAgICAgICAgIHRvb2x0aXAuc2hvdygpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQGlnbm9yZVxyXG4gICAgICovXHJcbiAgICBoYW5kbGVDdXJzb3JIaWRlKCkge1xyXG4gICAgICAgIGxldCB0b29sdGlwID0gdGhpcy5nZXQoXCJ0b29sdGlwXCIpO1xyXG4gICAgICAgIGlmICh0b29sdGlwKSB7XHJcbiAgICAgICAgICAgIHRvb2x0aXAuaGlkZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQGlnbm9yZVxyXG4gICAgICovXHJcbiAgICBwcm9jZXNzU2VyaWVzRGF0YUl0ZW0oX2RhdGFJdGVtLCBfZmllbGRzKSB7XHJcbiAgICB9XHJcbiAgICBfY2xlYXJEaXJ0eSgpIHtcclxuICAgICAgICBzdXBlci5fY2xlYXJEaXJ0eSgpO1xyXG4gICAgICAgIHRoaXMuX3NpemVEaXJ0eSA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuX3Jhbmdlc0RpcnR5ID0gZmFsc2U7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENvbnZlcnRzIHBpeGVsIGNvb3JkaW5hdGUgdG8gYSByZWxhdGl2ZSBwb3NpdGlvbiBvbiBheGlzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSAgIGNvb3JkaW5hdGUgIENvb3JkaW5hdGVcclxuICAgICAqIEByZXR1cm4gICAgICAgICAgICAgIFJlbGF0aXZlIHBvc2l0aW9uXHJcbiAgICAgKi9cclxuICAgIGNvb3JkaW5hdGVUb1Bvc2l0aW9uKGNvb3JkaW5hdGUpIHtcclxuICAgICAgICBjb25zdCByZW5kZXJlciA9IHRoaXMuZ2V0KFwicmVuZGVyZXJcIik7XHJcbiAgICAgICAgcmV0dXJuIHJlbmRlcmVyLnRvQXhpc1Bvc2l0aW9uKGNvb3JkaW5hdGUgLyByZW5kZXJlci5heGlzTGVuZ3RoKCkpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDb252ZXJ0cyByZWxhdGl2ZSBwb3NpdGlvbiBvZiB0aGUgcGxvdCBhcmVhIHRvIHJlbGF0aXZlIHBvc2l0aW9uIG9mIHRoZVxyXG4gICAgICogYXhpcyB3aXRoIHpvb20gdGFrZW4gaW50byBhY2NvdW50LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBwb3NpdGlvbiBQb3NpdGlvblxyXG4gICAgICogQHJldHVybiBSZWxhdGl2ZSBwb3NpdGlvblxyXG4gICAgICovXHJcbiAgICB0b0F4aXNQb3NpdGlvbihwb3NpdGlvbikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmdldChcInJlbmRlcmVyXCIpLnRvQXhpc1Bvc2l0aW9uKHBvc2l0aW9uKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ29udmVydHMgcmVsYXRpdmUgcG9zaXRpb24gb2YgdGhlIGF4aXMgdG8gYSBnbG9iYWwgcG9zaXRpb24gdGFraW5nIGN1cnJlbnRcclxuICAgICAqIHpvb20gaW50byBhY2NvdW50IChvcHBvc2l0ZSB0byB3aGF0IGB0b0F4aXNQb3NpdGlvbmAgZG9lcykuXHJcbiAgICAgKlxyXG4gICAgICogQHNpbmNlIDUuNC4yXHJcbiAgICAgKiBAcGFyYW0gcG9zaXRpb24gUG9zaXRpb25cclxuICAgICAqIEByZXR1cm4gR2xvYmFsIHBvc2l0aW9uXHJcbiAgICAgKi9cclxuICAgIHRvR2xvYmFsUG9zaXRpb24ocG9zaXRpb24pIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5nZXQoXCJyZW5kZXJlclwiKS50b0dsb2JhbFBvc2l0aW9uKHBvc2l0aW9uKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQWRqdXN0cyBwb3NpdGlvbiB3aXRoIGludmVyc2VkIHRha2VuIGludG8gYWNjb3VudC5cclxuICAgICAqXHJcbiAgICAgKiBAaWdub3JlXHJcbiAgICAgKi9cclxuICAgIGZpeFBvc2l0aW9uKHBvc2l0aW9uKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KFwicmVuZGVyZXJcIikuZml4UG9zaXRpb24ocG9zaXRpb24pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAaWdub3JlXHJcbiAgICAgKi9cclxuICAgIHNob3VsZEdhcChfZGF0YUl0ZW0sIF9uZXh0SXRlbSwgX2F1dG9HYXBDb3VudCwgX2ZpZWxkTmFtZSkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhbmQgcmV0dXJucyBhbiBheGlzIHJhbmdlIG9iamVjdC5cclxuICAgICAqXHJcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL3d3dy5hbWNoYXJ0cy5jb20vZG9jcy92NS9jaGFydHMveHktY2hhcnQvYXhlcy9heGlzLXJhbmdlcy99IGZvciBtb3JlIGluZm9cclxuICAgICAqIEBwYXJhbSAgIGF4aXNEYXRhSXRlbSAgQXhpcyBkYXRhIGl0ZW1cclxuICAgICAqIEByZXR1cm4gICAgICAgICAgICAgICAgQXhpcyByYW5nZVxyXG4gICAgICovXHJcbiAgICBjcmVhdGVBeGlzUmFuZ2UoYXhpc0RhdGFJdGVtKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYXhpc1Jhbmdlcy5wdXNoKGF4aXNEYXRhSXRlbSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEBpZ25vcmVcclxuICAgICAqL1xyXG4gICAgX2dyb3VwU2VyaWVzRGF0YShfc2VyaWVzKSB7IH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyByZWxhdGl2ZSBwb3NpdGlvbiBiZXR3ZWVuIHR3byBncmlkIGxpbmVzIG9mIHRoZSBheGlzLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm4gUG9zaXRpb25cclxuICAgICAqL1xyXG4gICAgZ2V0Q2VsbFdpZHRoUG9zaXRpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIDAuMDU7XHJcbiAgICB9XHJcbn1cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEF4aXMsIFwiY2xhc3NOYW1lXCIsIHtcclxuICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgIHZhbHVlOiBcIkF4aXNcIlxyXG59KTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEF4aXMsIFwiY2xhc3NOYW1lc1wiLCB7XHJcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICB2YWx1ZTogQ29tcG9uZW50LmNsYXNzTmFtZXMuY29uY2F0KFtBeGlzLmNsYXNzTmFtZV0pXHJcbn0pO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1BeGlzLmpzLm1hcCIsImltcG9ydCB7IExhYmVsIH0gZnJvbSBcIi4uLy4uLy4uL2NvcmUvcmVuZGVyL0xhYmVsXCI7XHJcbi8qKlxyXG4gKiBEcmF3cyBhbiBheGlzIGxhYmVsLlxyXG4gKlxyXG4gKiBAc2VlIHtAbGluayBodHRwczovL3d3dy5hbWNoYXJ0cy5jb20vZG9jcy92NS9jaGFydHMveHktY2hhcnQvYXhlcy8jTGFiZWxzfSBmb3IgbW9yZSBpbmZvXHJcbiAqIEBpbXBvcnRhbnRcclxuICovXHJcbmV4cG9ydCBjbGFzcyBBeGlzTGFiZWwgZXh0ZW5kcyBMYWJlbCB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl90aWNrUG9pbnRzXCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IFtdXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn1cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEF4aXNMYWJlbCwgXCJjbGFzc05hbWVcIiwge1xyXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgdmFsdWU6IFwiQXhpc0xhYmVsXCJcclxufSk7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShBeGlzTGFiZWwsIFwiY2xhc3NOYW1lc1wiLCB7XHJcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICB2YWx1ZTogTGFiZWwuY2xhc3NOYW1lcy5jb25jYXQoW0F4aXNMYWJlbC5jbGFzc05hbWVdKVxyXG59KTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QXhpc0xhYmVsLmpzLm1hcCIsImltcG9ydCB7IEdyYXBoaWNzIH0gZnJvbSBcIi4uLy4uLy4uL2NvcmUvcmVuZGVyL0dyYXBoaWNzXCI7XHJcbmltcG9ydCB7IFRlbXBsYXRlIH0gZnJvbSBcIi4uLy4uLy4uL2NvcmUvdXRpbC9UZW1wbGF0ZVwiO1xyXG5pbXBvcnQgeyBMaXN0VGVtcGxhdGUgfSBmcm9tIFwiLi4vLi4vLi4vY29yZS91dGlsL0xpc3RcIjtcclxuaW1wb3J0IHsgQXhpc1RpY2sgfSBmcm9tIFwiLi9BeGlzVGlja1wiO1xyXG5pbXBvcnQgeyBHcmlkIH0gZnJvbSBcIi4vR3JpZFwiO1xyXG5pbXBvcnQgeyBBeGlzTGFiZWwgfSBmcm9tIFwiLi9BeGlzTGFiZWxcIjtcclxuaW1wb3J0ICogYXMgJHV0aWxzIGZyb20gXCIuLi8uLi8uLi9jb3JlL3V0aWwvVXRpbHNcIjtcclxuLyoqXHJcbiAqIEJhc2UgY2xhc3MgZm9yIGFuIGF4aXMgcmVuZGVyZXIuXHJcbiAqXHJcbiAqIFNob3VsZCBub3QgYmUgdXNlZCBvbiBpdHMgb3duLlxyXG4gKlxyXG4gKiBAc2VlIHtAbGluayBodHRwczovL3d3dy5hbWNoYXJ0cy5jb20vZG9jcy92NS9jaGFydHMveHktY2hhcnQvI0F4aXNfcmVuZGVyZXJ9IGZvciBtb3JlIGluZm9cclxuICovXHJcbmV4cG9ydCBjbGFzcyBBeGlzUmVuZGVyZXIgZXh0ZW5kcyBHcmFwaGljcyB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xyXG4gICAgICAgIC8vIHNhdmUgZm9yIHF1aWNrIGFjY2Vzc1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9heGlzTGVuZ3RoXCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IDEwMFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9zdGFydFwiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiAwXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX2VuZFwiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiAxXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX2ludmVyc2VkXCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IGZhbHNlXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX21pblNpemVcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogMFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENoYXJ0IHRoZSByZW5kZXJlciBpcyB1c2VkIGluLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNoYXJ0XCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9sY1wiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiAxXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX2xzXCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IDBcclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfdGh1bWJEb3duUG9pbnRcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX2Rvd25TdGFydFwiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfZG93bkVuZFwiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcclxuICAgICAgICB9KTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBIGxpc3Qgb2YgdGlja3MgaW4gdGhlIGF4aXMuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBgdGlja3MudGVtcGxhdGVgIGNhbiBiZSB1c2VkIHRvIGNvbmZpZ3VyZSB0aWNrcy5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBkZWZhdWx0IG5ldyBMaXN0VGVtcGxhdGU8QXhpc1RpY2s+XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwidGlja3NcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogbmV3IExpc3RUZW1wbGF0ZShUZW1wbGF0ZS5uZXcoe30pLCAoKSA9PiBBeGlzVGljay5fbmV3KHRoaXMuX3Jvb3QsIHtcclxuICAgICAgICAgICAgICAgIHRoZW1lVGFnczogJHV0aWxzLm1lcmdlVGFncyh0aGlzLnRpY2tzLnRlbXBsYXRlLmdldChcInRoZW1lVGFnc1wiLCBbXSksIHRoaXMuZ2V0KFwidGhlbWVUYWdzXCIsIFtdKSlcclxuICAgICAgICAgICAgfSwgW3RoaXMudGlja3MudGVtcGxhdGVdKSlcclxuICAgICAgICB9KTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBIGxpc3Qgb2YgZ3JpZCBlbGVtZW50cyBpbiB0aGUgYXhpcy5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIGBncmlkLnRlbXBsYXRlYCBjYW4gYmUgdXNlZCB0byBjb25maWd1cmUgZ3JpZC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBkZWZhdWx0IG5ldyBMaXN0VGVtcGxhdGU8R3JpZD5cclxuICAgICAgICAgKi9cclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJncmlkXCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IG5ldyBMaXN0VGVtcGxhdGUoVGVtcGxhdGUubmV3KHt9KSwgKCkgPT4gR3JpZC5fbmV3KHRoaXMuX3Jvb3QsIHtcclxuICAgICAgICAgICAgICAgIHRoZW1lVGFnczogJHV0aWxzLm1lcmdlVGFncyh0aGlzLmdyaWQudGVtcGxhdGUuZ2V0KFwidGhlbWVUYWdzXCIsIFtdKSwgdGhpcy5nZXQoXCJ0aGVtZVRhZ3NcIiwgW10pKVxyXG4gICAgICAgICAgICB9LCBbdGhpcy5ncmlkLnRlbXBsYXRlXSkpXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQSBsaXN0IG9mIGZpbGxzIGluIHRoZSBheGlzLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogYGF4aXNGaWxscy50ZW1wbGF0ZWAgY2FuIGJlIHVzZWQgdG8gY29uZmlndXJlIGF4aXMgZmlsbHMuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAZGVmYXVsdCBuZXcgTGlzdFRlbXBsYXRlPEdyYXBoaWNzPlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImF4aXNGaWxsc1wiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiBuZXcgTGlzdFRlbXBsYXRlKFRlbXBsYXRlLm5ldyh7fSksICgpID0+IEdyYXBoaWNzLl9uZXcodGhpcy5fcm9vdCwge1xyXG4gICAgICAgICAgICAgICAgdGhlbWVUYWdzOiAkdXRpbHMubWVyZ2VUYWdzKHRoaXMuYXhpc0ZpbGxzLnRlbXBsYXRlLmdldChcInRoZW1lVGFnc1wiLCBbXCJheGlzXCIsIFwiZmlsbFwiXSksIHRoaXMuZ2V0KFwidGhlbWVUYWdzXCIsIFtdKSlcclxuICAgICAgICAgICAgfSwgW3RoaXMuYXhpc0ZpbGxzLnRlbXBsYXRlXSkpXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQSBsaXN0IG9mIGxhYmVscyBpbiB0aGUgYXhpcy5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIGBsYWJlbHMudGVtcGxhdGVgIGNhbiBiZSB1c2VkIHRvIGNvbmZpZ3VyZSBheGlzIGxhYmVscy5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBkZWZhdWx0IG5ldyBMaXN0VGVtcGxhdGU8QXhpc0xhYmVsPlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxhYmVsc1wiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiBuZXcgTGlzdFRlbXBsYXRlKFRlbXBsYXRlLm5ldyh7fSksICgpID0+IEF4aXNMYWJlbC5fbmV3KHRoaXMuX3Jvb3QsIHtcclxuICAgICAgICAgICAgICAgIHRoZW1lVGFnczogJHV0aWxzLm1lcmdlVGFncyh0aGlzLmxhYmVscy50ZW1wbGF0ZS5nZXQoXCJ0aGVtZVRhZ3NcIiwgW10pLCB0aGlzLmdldChcInRoZW1lVGFnc1wiLCBbXSkpXHJcbiAgICAgICAgICAgIH0sIFt0aGlzLmxhYmVscy50ZW1wbGF0ZV0pKVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFuIFtbQXhpc11dIHJlbmRlcmVyIGlzIGZvci5cclxuICAgICAgICAgKi9cclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJheGlzXCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInRodW1iXCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAaWdub3JlXHJcbiAgICAgKi9cclxuICAgIG1ha2VUaWNrKGRhdGFJdGVtLCB0aGVtZVRhZ3MpIHtcclxuICAgICAgICBjb25zdCB0aWNrID0gdGhpcy50aWNrcy5tYWtlKCk7XHJcbiAgICAgICAgdGljay5fc2V0RGF0YUl0ZW0oZGF0YUl0ZW0pO1xyXG4gICAgICAgIGRhdGFJdGVtLnNldFJhdyhcInRpY2tcIiwgdGljayk7XHJcbiAgICAgICAgdGljay5zZXQoXCJ0aGVtZVRhZ3NcIiwgJHV0aWxzLm1lcmdlVGFncyh0aWNrLmdldChcInRoZW1lVGFnc1wiKSwgdGhlbWVUYWdzKSk7XHJcbiAgICAgICAgdGhpcy5heGlzLmxhYmVsc0NvbnRhaW5lci5jaGlsZHJlbi5wdXNoKHRpY2spO1xyXG4gICAgICAgIHRoaXMudGlja3MucHVzaCh0aWNrKTtcclxuICAgICAgICByZXR1cm4gdGljaztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQGlnbm9yZVxyXG4gICAgICovXHJcbiAgICBtYWtlR3JpZChkYXRhSXRlbSwgdGhlbWVUYWdzKSB7XHJcbiAgICAgICAgY29uc3QgZ3JpZCA9IHRoaXMuZ3JpZC5tYWtlKCk7XHJcbiAgICAgICAgZ3JpZC5fc2V0RGF0YUl0ZW0oZGF0YUl0ZW0pO1xyXG4gICAgICAgIGRhdGFJdGVtLnNldFJhdyhcImdyaWRcIiwgZ3JpZCk7XHJcbiAgICAgICAgZ3JpZC5zZXQoXCJ0aGVtZVRhZ3NcIiwgJHV0aWxzLm1lcmdlVGFncyhncmlkLmdldChcInRoZW1lVGFnc1wiKSwgdGhlbWVUYWdzKSk7XHJcbiAgICAgICAgdGhpcy5heGlzLmdyaWRDb250YWluZXIuY2hpbGRyZW4ucHVzaChncmlkKTtcclxuICAgICAgICB0aGlzLmdyaWQucHVzaChncmlkKTtcclxuICAgICAgICByZXR1cm4gZ3JpZDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQGlnbm9yZVxyXG4gICAgICovXHJcbiAgICBtYWtlQXhpc0ZpbGwoZGF0YUl0ZW0sIHRoZW1lVGFncykge1xyXG4gICAgICAgIGNvbnN0IGF4aXNGaWxsID0gdGhpcy5heGlzRmlsbHMubWFrZSgpO1xyXG4gICAgICAgIGF4aXNGaWxsLl9zZXREYXRhSXRlbShkYXRhSXRlbSk7XHJcbiAgICAgICAgYXhpc0ZpbGwuc2V0KFwidGhlbWVUYWdzXCIsICR1dGlscy5tZXJnZVRhZ3MoYXhpc0ZpbGwuZ2V0KFwidGhlbWVUYWdzXCIpLCB0aGVtZVRhZ3MpKTtcclxuICAgICAgICB0aGlzLmF4aXMuZ3JpZENvbnRhaW5lci5jaGlsZHJlbi5wdXNoKGF4aXNGaWxsKTtcclxuICAgICAgICBkYXRhSXRlbS5zZXRSYXcoXCJheGlzRmlsbFwiLCBheGlzRmlsbCk7XHJcbiAgICAgICAgdGhpcy5heGlzRmlsbHMucHVzaChheGlzRmlsbCk7XHJcbiAgICAgICAgcmV0dXJuIGF4aXNGaWxsO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAaWdub3JlXHJcbiAgICAgKi9cclxuICAgIG1ha2VMYWJlbChkYXRhSXRlbSwgdGhlbWVUYWdzKSB7XHJcbiAgICAgICAgY29uc3QgbGFiZWwgPSB0aGlzLmxhYmVscy5tYWtlKCk7XHJcbiAgICAgICAgbGFiZWwuc2V0KFwidGhlbWVUYWdzXCIsICR1dGlscy5tZXJnZVRhZ3MobGFiZWwuZ2V0KFwidGhlbWVUYWdzXCIpLCB0aGVtZVRhZ3MpKTtcclxuICAgICAgICB0aGlzLmF4aXMubGFiZWxzQ29udGFpbmVyLmNoaWxkcmVuLm1vdmVWYWx1ZShsYWJlbCwgMCk7XHJcbiAgICAgICAgbGFiZWwuX3NldERhdGFJdGVtKGRhdGFJdGVtKTtcclxuICAgICAgICBkYXRhSXRlbS5zZXRSYXcoXCJsYWJlbFwiLCBsYWJlbCk7XHJcbiAgICAgICAgdGhpcy5sYWJlbHMucHVzaChsYWJlbCk7XHJcbiAgICAgICAgcmV0dXJuIGxhYmVsO1xyXG4gICAgfVxyXG4gICAgYXhpc0xlbmd0aCgpIHtcclxuICAgICAgICByZXR1cm4gMDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQGlnbm9yZVxyXG4gICAgICovXHJcbiAgICBncmlkQ291bnQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYXhpc0xlbmd0aCgpIC8gdGhpcy5nZXQoXCJtaW5HcmlkRGlzdGFuY2VcIiwgNTApO1xyXG4gICAgfVxyXG4gICAgX3VwZGF0ZVBvc2l0aW9ucygpIHtcclxuICAgIH1cclxuICAgIF9hZnRlck5ldygpIHtcclxuICAgICAgICBzdXBlci5fYWZ0ZXJOZXcoKTtcclxuICAgICAgICB0aGlzLnNldChcImlzTWVhc3VyZWRcIiwgZmFsc2UpO1xyXG4gICAgICAgIGNvbnN0IHRodW1iID0gdGhpcy50aHVtYjtcclxuICAgICAgICBpZiAodGh1bWIpIHtcclxuICAgICAgICAgICAgdGhpcy5fZGlzcG9zZXJzLnB1c2godGh1bWIuZXZlbnRzLm9uKFwicG9pbnRlcmRvd25cIiwgKGV2ZW50KSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9oYW5kbGVUaHVtYkRvd24oZXZlbnQpO1xyXG4gICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICAgIHRoaXMuX2Rpc3Bvc2Vycy5wdXNoKHRodW1iLmV2ZW50cy5vbihcImdsb2JhbHBvaW50ZXJ1cFwiLCAoZXZlbnQpID0+IHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2hhbmRsZVRodW1iVXAoZXZlbnQpO1xyXG4gICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICAgIHRoaXMuX2Rpc3Bvc2Vycy5wdXNoKHRodW1iLmV2ZW50cy5vbihcImdsb2JhbHBvaW50ZXJtb3ZlXCIsIChldmVudCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5faGFuZGxlVGh1bWJNb3ZlKGV2ZW50KTtcclxuICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIF9iZWZvcmVDaGFuZ2VkKCkge1xyXG4gICAgICAgIHN1cGVyLl9iZWZvcmVDaGFuZ2VkKCk7XHJcbiAgICAgICAgaWYgKHRoaXMuaXNEaXJ0eShcIm1pbkdyaWREaXN0YW5jZVwiKSkge1xyXG4gICAgICAgICAgICB0aGlzLnJvb3QuZXZlbnRzLm9uY2UoXCJmcmFtZWVuZGVkXCIsICgpID0+IHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYXhpcy5tYXJrRGlydHlTaXplKCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIF9jaGFuZ2VkKCkge1xyXG4gICAgICAgIHN1cGVyLl9jaGFuZ2VkKCk7XHJcbiAgICAgICAgaWYgKHRoaXMuaXNEaXJ0eShcInBhblwiKSkge1xyXG4gICAgICAgICAgICBjb25zdCB0aHVtYiA9IHRoaXMudGh1bWI7XHJcbiAgICAgICAgICAgIGlmICh0aHVtYikge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbGFiZWxzQ29udGFpbmVyID0gdGhpcy5heGlzLmxhYmVsc0NvbnRhaW5lcjtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHBhbiA9IHRoaXMuZ2V0KFwicGFuXCIpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHBhbiA9PSBcInpvb21cIikge1xyXG4gICAgICAgICAgICAgICAgICAgIGxhYmVsc0NvbnRhaW5lci5jaGlsZHJlbi5wdXNoKHRodW1iKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHBhbiA9PSBcIm5vbmVcIikge1xyXG4gICAgICAgICAgICAgICAgICAgIGxhYmVsc0NvbnRhaW5lci5jaGlsZHJlbi5yZW1vdmVWYWx1ZSh0aHVtYik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBfaGFuZGxlVGh1bWJEb3duKGV2ZW50KSB7XHJcbiAgICAgICAgdGhpcy5fdGh1bWJEb3duUG9pbnQgPSB0aGlzLnRvTG9jYWwoZXZlbnQucG9pbnQpO1xyXG4gICAgICAgIGNvbnN0IGF4aXMgPSB0aGlzLmF4aXM7XHJcbiAgICAgICAgdGhpcy5fZG93blN0YXJ0ID0gYXhpcy5nZXQoXCJzdGFydFwiKTtcclxuICAgICAgICB0aGlzLl9kb3duRW5kID0gYXhpcy5nZXQoXCJlbmRcIik7XHJcbiAgICB9XHJcbiAgICBfaGFuZGxlVGh1bWJVcChfZXZlbnQpIHtcclxuICAgICAgICB0aGlzLl90aHVtYkRvd25Qb2ludCA9IHVuZGVmaW5lZDtcclxuICAgIH1cclxuICAgIF9oYW5kbGVUaHVtYk1vdmUoZXZlbnQpIHtcclxuICAgICAgICBjb25zdCBkb3duUG9pbnQgPSB0aGlzLl90aHVtYkRvd25Qb2ludDtcclxuICAgICAgICBpZiAoZG93blBvaW50KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHBvaW50ID0gdGhpcy50b0xvY2FsKGV2ZW50LnBvaW50KTtcclxuICAgICAgICAgICAgY29uc3QgZG93blN0YXJ0ID0gdGhpcy5fZG93blN0YXJ0O1xyXG4gICAgICAgICAgICBjb25zdCBkb3duRW5kID0gdGhpcy5fZG93bkVuZDtcclxuICAgICAgICAgICAgY29uc3QgZXh0cmEgPSB0aGlzLl9nZXRQYW4ocG9pbnQsIGRvd25Qb2ludCkgKiBNYXRoLm1pbigxLCAoZG93bkVuZCAtIGRvd25TdGFydCkpIC8gMjtcclxuICAgICAgICAgICAgdGhpcy5heGlzLnpvb20oZG93blN0YXJ0IC0gZXh0cmEsIGRvd25FbmQgKyBleHRyYSwgMCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgX2dldFBhbihfcG9pbnQxLCBfcG9pbnQyKSB7XHJcbiAgICAgICAgcmV0dXJuIDA7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENvbnZlcnRzIHJlbGF0aXZlIHBvc2l0aW9uICgwLTEpIG9uIGF4aXMgdG8gYSBwaXhlbCBjb29yZGluYXRlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBwb3NpdGlvbiAgUG9zaXRpb24gKDAtMSlcclxuICAgICAqIEByZXR1cm4gQ29vcmRpbmF0ZSAocHgpXHJcbiAgICAgKi9cclxuICAgIHBvc2l0aW9uVG9Db29yZGluYXRlKHBvc2l0aW9uKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2ludmVyc2VkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAodGhpcy5fZW5kIC0gcG9zaXRpb24pICogdGhpcy5fYXhpc0xlbmd0aDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiAocG9zaXRpb24gLSB0aGlzLl9zdGFydCkgKiB0aGlzLl9heGlzTGVuZ3RoO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQGlnbm9yZVxyXG4gICAgICovXHJcbiAgICB1cGRhdGVUb29sdGlwQm91bmRzKF90b29sdGlwKSB7IH1cclxuICAgIF91cGRhdGVTaXplKCkge1xyXG4gICAgICAgIHRoaXMubWFya0RpcnR5KCk7XHJcbiAgICAgICAgdGhpcy5fY2xlYXIgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAaWdub3JlXHJcbiAgICAgKi9cclxuICAgIHRvQXhpc1Bvc2l0aW9uKHBvc2l0aW9uKSB7XHJcbiAgICAgICAgY29uc3Qgc3RhcnQgPSB0aGlzLl9zdGFydCB8fCAwO1xyXG4gICAgICAgIGNvbnN0IGVuZCA9IHRoaXMuX2VuZCB8fCAxO1xyXG4gICAgICAgIHBvc2l0aW9uID0gcG9zaXRpb24gKiAoZW5kIC0gc3RhcnQpO1xyXG4gICAgICAgIGlmICghdGhpcy5nZXQoXCJpbnZlcnNlZFwiKSkge1xyXG4gICAgICAgICAgICBwb3NpdGlvbiA9IHN0YXJ0ICsgcG9zaXRpb247XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBwb3NpdGlvbiA9IGVuZCAtIHBvc2l0aW9uO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcG9zaXRpb247XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEBpZ25vcmVcclxuICAgICAqL1xyXG4gICAgdG9HbG9iYWxQb3NpdGlvbihwb3NpdGlvbikge1xyXG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy5fc3RhcnQgfHwgMDtcclxuICAgICAgICBjb25zdCBlbmQgPSB0aGlzLl9lbmQgfHwgMTtcclxuICAgICAgICBpZiAoIXRoaXMuZ2V0KFwiaW52ZXJzZWRcIikpIHtcclxuICAgICAgICAgICAgcG9zaXRpb24gPSBwb3NpdGlvbiAtIHN0YXJ0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcG9zaXRpb24gPSBlbmQgLSBwb3NpdGlvbjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcG9zaXRpb24gPSBwb3NpdGlvbiAvIChlbmQgLSBzdGFydCk7XHJcbiAgICAgICAgcmV0dXJuIHBvc2l0aW9uO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAaWdub3JlXHJcbiAgICAgKi9cclxuICAgIGZpeFBvc2l0aW9uKHBvc2l0aW9uKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuZ2V0KFwiaW52ZXJzZWRcIikpIHtcclxuICAgICAgICAgICAgcmV0dXJuIDEgLSBwb3NpdGlvbjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHBvc2l0aW9uO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAaWdub3JlXHJcbiAgICAgKi9cclxuICAgIF91cGRhdGVMQygpIHtcclxuICAgIH1cclxuICAgIHRvZ2dsZVZpc2liaWxpdHkoc3ByaXRlLCBwb3NpdGlvbiwgbWluUG9zaXRpb24sIG1heFBvc2l0aW9uKSB7XHJcbiAgICAgICAgbGV0IGF4aXMgPSB0aGlzLmF4aXM7XHJcbiAgICAgICAgY29uc3Qgc3RhcnQgPSBheGlzLmdldChcInN0YXJ0XCIsIDApO1xyXG4gICAgICAgIGNvbnN0IGVuZCA9IGF4aXMuZ2V0KFwiZW5kXCIsIDEpO1xyXG4gICAgICAgIGxldCB1cGRhdGVkU3RhcnQgPSBzdGFydCArIChlbmQgLSBzdGFydCkgKiAobWluUG9zaXRpb24gLSAwLjAwMDEpO1xyXG4gICAgICAgIGxldCB1cGRhdGVkRW5kID0gc3RhcnQgKyAoZW5kIC0gc3RhcnQpICogKG1heFBvc2l0aW9uICsgMC4wMDAxKTtcclxuICAgICAgICBpZiAocG9zaXRpb24gPCB1cGRhdGVkU3RhcnQgfHwgcG9zaXRpb24gPiB1cGRhdGVkRW5kKSB7XHJcbiAgICAgICAgICAgIHNwcml0ZS5zZXRQcml2YXRlKFwidmlzaWJsZVwiLCBmYWxzZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBzcHJpdGUuc2V0UHJpdmF0ZShcInZpc2libGVcIiwgdHJ1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgX3Bvc2l0aW9uVG9vbHRpcCh0b29sdGlwLCBwb2ludCkge1xyXG4gICAgICAgIGNvbnN0IGNoYXJ0ID0gdGhpcy5jaGFydDtcclxuICAgICAgICBpZiAoY2hhcnQpIHtcclxuICAgICAgICAgICAgaWYgKGNoYXJ0LmluUGxvdChwb2ludCkpIHtcclxuICAgICAgICAgICAgICAgIHRvb2x0aXAuc2V0KFwicG9pbnRUb1wiLCB0aGlzLl9kaXNwbGF5LnRvR2xvYmFsKHBvaW50KSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0b29sdGlwLmhpZGUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHByb2Nlc3NBeGlzKCkgeyB9XHJcbn1cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEF4aXNSZW5kZXJlciwgXCJjbGFzc05hbWVcIiwge1xyXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgdmFsdWU6IFwiQXhpc1JlbmRlcmVyXCJcclxufSk7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShBeGlzUmVuZGVyZXIsIFwiY2xhc3NOYW1lc1wiLCB7XHJcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICB2YWx1ZTogR3JhcGhpY3MuY2xhc3NOYW1lcy5jb25jYXQoW0F4aXNSZW5kZXJlci5jbGFzc05hbWVdKVxyXG59KTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QXhpc1JlbmRlcmVyLmpzLm1hcCIsImltcG9ydCB7IEF4aXNSZW5kZXJlciB9IGZyb20gXCIuL0F4aXNSZW5kZXJlclwiO1xyXG5pbXBvcnQgeyBwMTAwIH0gZnJvbSBcIi4uLy4uLy4uL2NvcmUvdXRpbC9QZXJjZW50XCI7XHJcbmltcG9ydCAqIGFzICR0eXBlIGZyb20gXCIuLi8uLi8uLi9jb3JlL3V0aWwvVHlwZVwiO1xyXG5pbXBvcnQgKiBhcyAkdXRpbHMgZnJvbSBcIi4uLy4uLy4uL2NvcmUvdXRpbC9VdGlsc1wiO1xyXG5pbXBvcnQgeyBSZWN0YW5nbGUgfSBmcm9tIFwiLi4vLi4vLi4vY29yZS9yZW5kZXIvUmVjdGFuZ2xlXCI7XHJcbi8qKlxyXG4gKiBVc2VkIHRvIHJlbmRlciBob3Jpem9udGFsIGF4aXMuXHJcbiAqXHJcbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vd3d3LmFtY2hhcnRzLmNvbS9kb2NzL3Y1L2NoYXJ0cy94eS1jaGFydC8jQXhpc19yZW5kZXJlcn0gZm9yIG1vcmUgaW5mb1xyXG4gKiBAaW1wb3J0YW50XHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgQXhpc1JlbmRlcmVyWCBleHRlbmRzIEF4aXNSZW5kZXJlciB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInRodW1iXCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IFJlY3RhbmdsZS5uZXcodGhpcy5fcm9vdCwgeyB3aWR0aDogcDEwMCwgaXNNZWFzdXJlZDogZmFsc2UsIHRoZW1lVGFnczogW1wiYXhpc1wiLCBcInhcIiwgXCJ0aHVtYlwiXSB9KVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgX2FmdGVyTmV3KCkge1xyXG4gICAgICAgIHRoaXMuX3NldHRpbmdzLnRoZW1lVGFncyA9ICR1dGlscy5tZXJnZVRhZ3ModGhpcy5fc2V0dGluZ3MudGhlbWVUYWdzLCBbXCJyZW5kZXJlclwiLCBcInhcIl0pO1xyXG4gICAgICAgIHN1cGVyLl9hZnRlck5ldygpO1xyXG4gICAgICAgIHRoaXMuc2V0UHJpdmF0ZVJhdyhcImxldHRlclwiLCBcIlhcIik7XHJcbiAgICAgICAgY29uc3QgZ3JpZFRlbXBsYXRlID0gdGhpcy5ncmlkLnRlbXBsYXRlO1xyXG4gICAgICAgIGdyaWRUZW1wbGF0ZS5zZXQoXCJoZWlnaHRcIiwgcDEwMCk7XHJcbiAgICAgICAgZ3JpZFRlbXBsYXRlLnNldChcIndpZHRoXCIsIDApO1xyXG4gICAgICAgIGdyaWRUZW1wbGF0ZS5zZXQoXCJkcmF3XCIsIChkaXNwbGF5LCBncmFwaGljcykgPT4ge1xyXG4gICAgICAgICAgICBkaXNwbGF5Lm1vdmVUbygwLCAwKTtcclxuICAgICAgICAgICAgZGlzcGxheS5saW5lVG8oMCwgZ3JhcGhpY3MuaGVpZ2h0KCkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuc2V0KFwiZHJhd1wiLCAoZGlzcGxheSwgZ3JhcGhpY3MpID0+IHtcclxuICAgICAgICAgICAgZGlzcGxheS5tb3ZlVG8oMCwgMCk7XHJcbiAgICAgICAgICAgIGRpc3BsYXkubGluZVRvKGdyYXBoaWNzLndpZHRoKCksIDApO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgX2NoYW5nZWQoKSB7XHJcbiAgICAgICAgc3VwZXIuX2NoYW5nZWQoKTtcclxuICAgICAgICBjb25zdCBheGlzID0gdGhpcy5heGlzO1xyXG4gICAgICAgIGF4aXMuZ2hvc3RMYWJlbC5zZXRQcml2YXRlKFwidmlzaWJsZVwiLCAhdGhpcy5nZXQoXCJpbnNpZGVcIikpO1xyXG4gICAgICAgIGF4aXMuZ2hvc3RMYWJlbC5zZXQoXCJ4XCIsIC0xMDAwKTtcclxuICAgICAgICBjb25zdCBvcHBvc2l0ZSA9IFwib3Bwb3NpdGVcIjtcclxuICAgICAgICBjb25zdCBpbnNpZGUgPSBcImluc2lkZVwiO1xyXG4gICAgICAgIGlmICh0aGlzLmlzRGlydHkob3Bwb3NpdGUpIHx8IHRoaXMuaXNEaXJ0eShpbnNpZGUpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNoYXJ0ID0gdGhpcy5jaGFydDtcclxuICAgICAgICAgICAgY29uc3QgYXhpc0NoaWxkcmVuID0gYXhpcy5jaGlsZHJlbjtcclxuICAgICAgICAgICAgaWYgKHRoaXMuZ2V0KGluc2lkZSkpIHtcclxuICAgICAgICAgICAgICAgIGF4aXMuYWRkVGFnKGluc2lkZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBheGlzLnJlbW92ZVRhZyhpbnNpZGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChjaGFydCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZ2V0KG9wcG9zaXRlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkcmVuID0gY2hhcnQudG9wQXhlc0NvbnRhaW5lci5jaGlsZHJlbjtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGRyZW4uaW5kZXhPZihheGlzKSA9PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbi5pbnNlcnRJbmRleCgwLCBheGlzKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgYXhpcy5hZGRUYWcob3Bwb3NpdGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGF4aXNDaGlsZHJlbi5tb3ZlVmFsdWUodGhpcyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjaGlsZHJlbiA9IGNoYXJ0LmJvdHRvbUF4ZXNDb250YWluZXIuY2hpbGRyZW47XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkcmVuLmluZGV4T2YoYXhpcykgPT0gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW4ubW92ZVZhbHVlKGF4aXMpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBheGlzLnJlbW92ZVRhZyhvcHBvc2l0ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYXhpc0NoaWxkcmVuLm1vdmVWYWx1ZSh0aGlzLCAwKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGF4aXMuZ2hvc3RMYWJlbC5fYXBwbHlUaGVtZXMoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMubGFiZWxzLmVhY2goKGxhYmVsKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGFiZWwuX2FwcGx5VGhlbWVzKCk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIHRoaXMucm9vdC5fbWFya0RpcnR5UmVkcmF3KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYXhpcy5tYXJrRGlydHlTaXplKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMudGh1bWIuc2V0UHJpdmF0ZShcImhlaWdodFwiLCBheGlzLmxhYmVsc0NvbnRhaW5lci5oZWlnaHQoKSk7XHJcbiAgICB9XHJcbiAgICBfZ2V0UGFuKHBvaW50MSwgcG9pbnQyKSB7XHJcbiAgICAgICAgcmV0dXJuIChwb2ludDIueCAtIHBvaW50MS54KSAvIHRoaXMud2lkdGgoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQGlnbm9yZVxyXG4gICAgICovXHJcbiAgICB0b0F4aXNQb3NpdGlvbihwb3NpdGlvbikge1xyXG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy5fc3RhcnQgfHwgMDtcclxuICAgICAgICBjb25zdCBlbmQgPSB0aGlzLl9lbmQgfHwgMTtcclxuICAgICAgICBwb3NpdGlvbiAtPSB0aGlzLl9scztcclxuICAgICAgICBwb3NpdGlvbiA9IHBvc2l0aW9uICogKGVuZCAtIHN0YXJ0KSAvIHRoaXMuX2xjO1xyXG4gICAgICAgIGlmICghdGhpcy5nZXQoXCJpbnZlcnNlZFwiKSkge1xyXG4gICAgICAgICAgICBwb3NpdGlvbiA9IHN0YXJ0ICsgcG9zaXRpb247XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBwb3NpdGlvbiA9IGVuZCAtIHBvc2l0aW9uO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcG9zaXRpb247XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEBpZ25vcmVcclxuICAgICAqL1xyXG4gICAgdG9HbG9iYWxQb3NpdGlvbihwb3NpdGlvbikge1xyXG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy5fc3RhcnQgfHwgMDtcclxuICAgICAgICBjb25zdCBlbmQgPSB0aGlzLl9lbmQgfHwgMTtcclxuICAgICAgICBpZiAoIXRoaXMuZ2V0KFwiaW52ZXJzZWRcIikpIHtcclxuICAgICAgICAgICAgcG9zaXRpb24gPSBwb3NpdGlvbiAtIHN0YXJ0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcG9zaXRpb24gPSBlbmQgLSBwb3NpdGlvbjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcG9zaXRpb24gPSBwb3NpdGlvbiAvIChlbmQgLSBzdGFydCkgKiB0aGlzLl9sYztcclxuICAgICAgICBwb3NpdGlvbiArPSB0aGlzLl9scztcclxuICAgICAgICByZXR1cm4gcG9zaXRpb247XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEBpZ25vcmVcclxuICAgICAqL1xyXG4gICAgX3VwZGF0ZUxDKCkge1xyXG4gICAgICAgIGNvbnN0IGF4aXMgPSB0aGlzLmF4aXM7XHJcbiAgICAgICAgY29uc3QgcGFyZW50ID0gYXhpcy5wYXJlbnQ7XHJcbiAgICAgICAgaWYgKHBhcmVudCkge1xyXG4gICAgICAgICAgICBjb25zdCB3ID0gcGFyZW50LmlubmVyV2lkdGgoKTtcclxuICAgICAgICAgICAgdGhpcy5fbGMgPSB0aGlzLmF4aXNMZW5ndGgoKSAvIHc7XHJcbiAgICAgICAgICAgIHRoaXMuX2xzID0gKGF4aXMueCgpIC0gcGFyZW50LmdldChcInBhZGRpbmdMZWZ0XCIsIDApKSAvIHc7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAaWdub3JlXHJcbiAgICAgKi9cclxuICAgIF91cGRhdGVQb3NpdGlvbnMoKSB7XHJcbiAgICAgICAgY29uc3QgYXhpcyA9IHRoaXMuYXhpcztcclxuICAgICAgICBjb25zdCB4ID0gYXhpcy54KCkgLSAkdXRpbHMucmVsYXRpdmVUb1ZhbHVlKGF4aXMuZ2V0KFwiY2VudGVyWFwiLCAwKSwgYXhpcy53aWR0aCgpKSAtIGF4aXMucGFyZW50LmdldChcInBhZGRpbmdMZWZ0XCIsIDApO1xyXG4gICAgICAgIGF4aXMuZ3JpZENvbnRhaW5lci5zZXQoXCJ4XCIsIHgpO1xyXG4gICAgICAgIGF4aXMudG9wR3JpZENvbnRhaW5lci5zZXQoXCJ4XCIsIHgpO1xyXG4gICAgICAgIGF4aXMuYnVsbGV0c0NvbnRhaW5lci5zZXQoXCJ5XCIsIHRoaXMueSgpKTtcclxuICAgICAgICBjb25zdCBjaGFydCA9IGF4aXMuY2hhcnQ7XHJcbiAgICAgICAgaWYgKGNoYXJ0KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHBsb3RDb250YWluZXIgPSBjaGFydC5wbG90Q29udGFpbmVyO1xyXG4gICAgICAgICAgICBjb25zdCBheGlzSGVhZGVyID0gYXhpcy5heGlzSGVhZGVyO1xyXG4gICAgICAgICAgICBsZXQgd2lkdGggPSBheGlzLmdldChcIm1hcmdpbkxlZnRcIiwgMCk7XHJcbiAgICAgICAgICAgIGxldCB4ID0gYXhpcy54KCkgLSB3aWR0aDtcclxuICAgICAgICAgICAgY29uc3QgcGFyZW50ID0gYXhpcy5wYXJlbnQ7XHJcbiAgICAgICAgICAgIGlmIChwYXJlbnQpIHtcclxuICAgICAgICAgICAgICAgIHggLT0gcGFyZW50LmdldChcInBhZGRpbmdMZWZ0XCIsIDApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChheGlzSGVhZGVyLmNoaWxkcmVuLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgIHdpZHRoID0gYXhpcy5heGlzSGVhZGVyLndpZHRoKCk7XHJcbiAgICAgICAgICAgICAgICBheGlzLnNldChcIm1hcmdpbkxlZnRcIiwgd2lkdGggKyAxKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGF4aXNIZWFkZXIuc2V0KFwid2lkdGhcIiwgd2lkdGgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGF4aXNIZWFkZXIuc2V0QWxsKHsgeDogeCwgeTogLTEsIGhlaWdodDogcGxvdENvbnRhaW5lci5oZWlnaHQoKSArIDIgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAaWdub3JlXHJcbiAgICAgKi9cclxuICAgIHByb2Nlc3NBeGlzKCkge1xyXG4gICAgICAgIHN1cGVyLnByb2Nlc3NBeGlzKCk7XHJcbiAgICAgICAgY29uc3QgYXhpcyA9IHRoaXMuYXhpcztcclxuICAgICAgICBheGlzLnNldChcIndpZHRoXCIsIHAxMDApO1xyXG4gICAgICAgIGNvbnN0IHZlcnRpY2FsTGF5b3V0ID0gdGhpcy5fcm9vdC52ZXJ0aWNhbExheW91dDtcclxuICAgICAgICBheGlzLnNldChcImxheW91dFwiLCB2ZXJ0aWNhbExheW91dCk7XHJcbiAgICAgICAgYXhpcy5sYWJlbHNDb250YWluZXIuc2V0KFwid2lkdGhcIiwgcDEwMCk7XHJcbiAgICAgICAgYXhpcy5heGlzSGVhZGVyLnNldEFsbCh7IGxheW91dDogdmVydGljYWxMYXlvdXQgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEBpZ25vcmVcclxuICAgICAqL1xyXG4gICAgYXhpc0xlbmd0aCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5heGlzLndpZHRoKCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENvbnZlcnRzIGF4aXMgcmVsYXRpdmUgcG9zaXRpb24gdG8gYWN0dWFsIGNvb3JkaW5hdGUgaW4gcGl4ZWxzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSAgIHBvc2l0aW9uICBQb3NpdGlvblxyXG4gICAgICogQHJldHVybiAgICAgICAgICAgIFBvaW50XHJcbiAgICAgKi9cclxuICAgIHBvc2l0aW9uVG9Qb2ludChwb3NpdGlvbikge1xyXG4gICAgICAgIHJldHVybiB7IHg6IHRoaXMucG9zaXRpb25Ub0Nvb3JkaW5hdGUocG9zaXRpb24pLCB5OiAwIH07XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEBpZ25vcmVcclxuICAgICAqL1xyXG4gICAgdXBkYXRlVGljayh0aWNrLCBwb3NpdGlvbiwgZW5kUG9zaXRpb24sIGNvdW50KSB7XHJcbiAgICAgICAgaWYgKHRpY2spIHtcclxuICAgICAgICAgICAgaWYgKCEkdHlwZS5pc051bWJlcihwb3NpdGlvbikpIHtcclxuICAgICAgICAgICAgICAgIHBvc2l0aW9uID0gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsZXQgbG9jYXRpb24gPSAwLjU7XHJcbiAgICAgICAgICAgIGlmICgkdHlwZS5pc051bWJlcihjb3VudCkgJiYgY291bnQgPiAxKSB7XHJcbiAgICAgICAgICAgICAgICBsb2NhdGlvbiA9IHRpY2suZ2V0KFwibXVsdGlMb2NhdGlvblwiLCBsb2NhdGlvbik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBsb2NhdGlvbiA9IHRpY2suZ2V0KFwibG9jYXRpb25cIiwgbG9jYXRpb24pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICgkdHlwZS5pc051bWJlcihlbmRQb3NpdGlvbikgJiYgZW5kUG9zaXRpb24gIT0gcG9zaXRpb24pIHtcclxuICAgICAgICAgICAgICAgIHBvc2l0aW9uID0gcG9zaXRpb24gKyAoZW5kUG9zaXRpb24gLSBwb3NpdGlvbikgKiBsb2NhdGlvbjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aWNrLnNldChcInhcIiwgdGhpcy5wb3NpdGlvblRvQ29vcmRpbmF0ZShwb3NpdGlvbikpO1xyXG4gICAgICAgICAgICBsZXQgbGVuZ3RoID0gdGljay5nZXQoXCJsZW5ndGhcIiwgMCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGluc2lkZSA9IHRpY2suZ2V0KFwiaW5zaWRlXCIsIHRoaXMuZ2V0KFwiaW5zaWRlXCIsIGZhbHNlKSk7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmdldChcIm9wcG9zaXRlXCIpKSB7XHJcbiAgICAgICAgICAgICAgICB0aWNrLnNldChcInlcIiwgcDEwMCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWluc2lkZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxlbmd0aCAqPSAtMTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRpY2suc2V0KFwieVwiLCAwKTtcclxuICAgICAgICAgICAgICAgIGlmIChpbnNpZGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBsZW5ndGggKj0gLTE7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGljay5zZXQoXCJkcmF3XCIsIChkaXNwbGF5KSA9PiB7XHJcbiAgICAgICAgICAgICAgICBkaXNwbGF5Lm1vdmVUbygwLCAwKTtcclxuICAgICAgICAgICAgICAgIGRpc3BsYXkubGluZVRvKDAsIGxlbmd0aCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB0aGlzLnRvZ2dsZVZpc2liaWxpdHkodGljaywgcG9zaXRpb24sIHRpY2suZ2V0KFwibWluUG9zaXRpb25cIiwgMCksIHRpY2suZ2V0KFwibWF4UG9zaXRpb25cIiwgMSkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQGlnbm9yZVxyXG4gICAgICovXHJcbiAgICB1cGRhdGVMYWJlbChsYWJlbCwgcG9zaXRpb24sIGVuZFBvc2l0aW9uLCBjb3VudCkge1xyXG4gICAgICAgIGlmIChsYWJlbCkge1xyXG4gICAgICAgICAgICBsZXQgbG9jYXRpb24gPSAwLjU7XHJcbiAgICAgICAgICAgIGlmICgkdHlwZS5pc051bWJlcihjb3VudCkgJiYgY291bnQgPiAxKSB7XHJcbiAgICAgICAgICAgICAgICBsb2NhdGlvbiA9IGxhYmVsLmdldChcIm11bHRpTG9jYXRpb25cIiwgbG9jYXRpb24pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgbG9jYXRpb24gPSBsYWJlbC5nZXQoXCJsb2NhdGlvblwiLCBsb2NhdGlvbik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCEkdHlwZS5pc051bWJlcihwb3NpdGlvbikpIHtcclxuICAgICAgICAgICAgICAgIHBvc2l0aW9uID0gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBpbnNpZGUgPSBsYWJlbC5nZXQoXCJpbnNpZGVcIiwgdGhpcy5nZXQoXCJpbnNpZGVcIiwgZmFsc2UpKTtcclxuICAgICAgICAgICAgY29uc3Qgb3Bwb3NpdGUgPSB0aGlzLmdldChcIm9wcG9zaXRlXCIpO1xyXG4gICAgICAgICAgICBpZiAob3Bwb3NpdGUpIHtcclxuICAgICAgICAgICAgICAgIGlmICghaW5zaWRlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGFiZWwuc2V0KFwicG9zaXRpb25cIiwgXCJyZWxhdGl2ZVwiKTtcclxuICAgICAgICAgICAgICAgICAgICBsYWJlbC5zZXQoXCJ5XCIsIHAxMDApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGFiZWwuc2V0KFwicG9zaXRpb25cIiwgXCJhYnNvbHV0ZVwiKTtcclxuICAgICAgICAgICAgICAgICAgICBsYWJlbC5zZXQoXCJ5XCIsIDApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFpbnNpZGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBsYWJlbC5zZXQoXCJ5XCIsIHVuZGVmaW5lZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgbGFiZWwuc2V0KFwicG9zaXRpb25cIiwgXCJyZWxhdGl2ZVwiKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGxhYmVsLnNldChcInlcIiwgMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgbGFiZWwuc2V0KFwicG9zaXRpb25cIiwgXCJhYnNvbHV0ZVwiKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoJHR5cGUuaXNOdW1iZXIoZW5kUG9zaXRpb24pICYmIGVuZFBvc2l0aW9uICE9IHBvc2l0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICBwb3NpdGlvbiA9IHBvc2l0aW9uICsgKGVuZFBvc2l0aW9uIC0gcG9zaXRpb24pICogbG9jYXRpb247XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGFiZWwuc2V0KFwieFwiLCB0aGlzLnBvc2l0aW9uVG9Db29yZGluYXRlKHBvc2l0aW9uKSk7XHJcbiAgICAgICAgICAgIHRoaXMudG9nZ2xlVmlzaWJpbGl0eShsYWJlbCwgcG9zaXRpb24sIGxhYmVsLmdldChcIm1pblBvc2l0aW9uXCIsIDApLCBsYWJlbC5nZXQoXCJtYXhQb3NpdGlvblwiLCAxKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAaWdub3JlXHJcbiAgICAgKi9cclxuICAgIHVwZGF0ZUdyaWQoZ3JpZCwgcG9zaXRpb24sIGVuZFBvc2l0aW9uKSB7XHJcbiAgICAgICAgaWYgKGdyaWQpIHtcclxuICAgICAgICAgICAgaWYgKCEkdHlwZS5pc051bWJlcihwb3NpdGlvbikpIHtcclxuICAgICAgICAgICAgICAgIHBvc2l0aW9uID0gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsZXQgbG9jYXRpb24gPSBncmlkLmdldChcImxvY2F0aW9uXCIsIDAuNSk7XHJcbiAgICAgICAgICAgIGlmICgkdHlwZS5pc051bWJlcihlbmRQb3NpdGlvbikgJiYgZW5kUG9zaXRpb24gIT0gcG9zaXRpb24pIHtcclxuICAgICAgICAgICAgICAgIHBvc2l0aW9uID0gcG9zaXRpb24gKyAoZW5kUG9zaXRpb24gLSBwb3NpdGlvbikgKiBsb2NhdGlvbjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBncmlkLnNldChcInhcIiwgdGhpcy5wb3NpdGlvblRvQ29vcmRpbmF0ZShwb3NpdGlvbikpO1xyXG4gICAgICAgICAgICB0aGlzLnRvZ2dsZVZpc2liaWxpdHkoZ3JpZCwgcG9zaXRpb24sIDAsIDEpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQGlnbm9yZVxyXG4gICAgICovXHJcbiAgICB1cGRhdGVCdWxsZXQoYnVsbGV0LCBwb3NpdGlvbiwgZW5kUG9zaXRpb24pIHtcclxuICAgICAgICBpZiAoYnVsbGV0KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHNwcml0ZSA9IGJ1bGxldC5nZXQoXCJzcHJpdGVcIik7XHJcbiAgICAgICAgICAgIGlmIChzcHJpdGUpIHtcclxuICAgICAgICAgICAgICAgIGlmICghJHR5cGUuaXNOdW1iZXIocG9zaXRpb24pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24gPSAwO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgbGV0IGxvY2F0aW9uID0gYnVsbGV0LmdldChcImxvY2F0aW9uXCIsIDAuNSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoJHR5cGUuaXNOdW1iZXIoZW5kUG9zaXRpb24pICYmIGVuZFBvc2l0aW9uICE9IHBvc2l0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24gPSBwb3NpdGlvbiArIChlbmRQb3NpdGlvbiAtIHBvc2l0aW9uKSAqIGxvY2F0aW9uO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgbGV0IGJ1bGxldFBvc2l0aW9uID0gdGhpcy5heGlzLnJvdW5kQXhpc1Bvc2l0aW9uKHBvc2l0aW9uLCBsb2NhdGlvbik7XHJcbiAgICAgICAgICAgICAgICBsZXQgcHJldmlvdXNCdWxsZXQgPSB0aGlzLmF4aXMuX2J1bGxldHNbYnVsbGV0UG9zaXRpb25dO1xyXG4gICAgICAgICAgICAgICAgbGV0IGQgPSAtMTtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmdldChcIm9wcG9zaXRlXCIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZCA9IDE7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoYnVsbGV0LmdldChcInN0YWNrZWRcIikpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocHJldmlvdXNCdWxsZXQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHByZXZpb3VzU3ByaXRlID0gcHJldmlvdXNCdWxsZXQuZ2V0KFwic3ByaXRlXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJldmlvdXNTcHJpdGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNwcml0ZS5zZXQoXCJ5XCIsIHByZXZpb3VzU3ByaXRlLnkoKSArIHByZXZpb3VzU3ByaXRlLmhlaWdodCgpICogZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNwcml0ZS5zZXQoXCJ5XCIsIDApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuYXhpcy5fYnVsbGV0c1tidWxsZXRQb3NpdGlvbl0gPSBidWxsZXQ7XHJcbiAgICAgICAgICAgICAgICBzcHJpdGUuc2V0KFwieFwiLCB0aGlzLnBvc2l0aW9uVG9Db29yZGluYXRlKHBvc2l0aW9uKSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRvZ2dsZVZpc2liaWxpdHkoc3ByaXRlLCBwb3NpdGlvbiwgMCwgMSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEBpZ25vcmVcclxuICAgICAqL1xyXG4gICAgdXBkYXRlRmlsbChmaWxsLCBwb3NpdGlvbiwgZW5kUG9zaXRpb24pIHtcclxuICAgICAgICBpZiAoZmlsbCkge1xyXG4gICAgICAgICAgICBpZiAoISR0eXBlLmlzTnVtYmVyKHBvc2l0aW9uKSkge1xyXG4gICAgICAgICAgICAgICAgcG9zaXRpb24gPSAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghJHR5cGUuaXNOdW1iZXIoZW5kUG9zaXRpb24pKSB7XHJcbiAgICAgICAgICAgICAgICBlbmRQb3NpdGlvbiA9IDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGV0IHgwID0gdGhpcy5wb3NpdGlvblRvQ29vcmRpbmF0ZShwb3NpdGlvbik7XHJcbiAgICAgICAgICAgIGxldCB4MSA9IHRoaXMucG9zaXRpb25Ub0Nvb3JkaW5hdGUoZW5kUG9zaXRpb24pO1xyXG4gICAgICAgICAgICB0aGlzLmZpbGxEcmF3TWV0aG9kKGZpbGwsIHgwLCB4MSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZmlsbERyYXdNZXRob2QoZmlsbCwgeDAsIHgxKSB7XHJcbiAgICAgICAgZmlsbC5zZXQoXCJkcmF3XCIsIChkaXNwbGF5KSA9PiB7XHJcbiAgICAgICAgICAgIC8vZGlzcGxheS5kcmF3UmVjdCh4MCwgMCwgeDEgLSB4MCwgdGhpcy5heGlzIS5ncmlkQ29udGFpbmVyLmhlaWdodCgpKTtcclxuICAgICAgICAgICAgLy8gdXNpbmcgZm9yIGhvbGVzLCBzbyBjYW4gbm90IGJlIHJlY3RhbmdsZVxyXG4gICAgICAgICAgICBjb25zdCBoID0gdGhpcy5heGlzLmdyaWRDb250YWluZXIuaGVpZ2h0KCk7XHJcbiAgICAgICAgICAgIGNvbnN0IHcgPSB0aGlzLndpZHRoKCk7XHJcbiAgICAgICAgICAgIGlmICh4MSA8IHgwKSB7XHJcbiAgICAgICAgICAgICAgICBbeDEsIHgwXSA9IFt4MCwgeDFdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh4MCA+IHcgfHwgeDEgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLypcclxuICAgICAgICAgICAgY29uc3QgbGltaXQgPSAxMDAwMDtcclxuXHJcbiAgICAgICAgICAgIHgwID0gTWF0aC5tYXgoLWxpbWl0LCB4MCk7XHJcbiAgICAgICAgICAgIHgxID0gTWF0aC5taW4obGltaXQsIHgxKTtcclxuICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgZGlzcGxheS5tb3ZlVG8oeDAsIDApO1xyXG4gICAgICAgICAgICBkaXNwbGF5LmxpbmVUbyh4MSwgMCk7XHJcbiAgICAgICAgICAgIGRpc3BsYXkubGluZVRvKHgxLCBoKTtcclxuICAgICAgICAgICAgZGlzcGxheS5saW5lVG8oeDAsIGgpO1xyXG4gICAgICAgICAgICBkaXNwbGF5LmxpbmVUbyh4MCwgMCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEBpZ25vcmVcclxuICAgICAqL1xyXG4gICAgcG9zaXRpb25Ub29sdGlwKHRvb2x0aXAsIHBvc2l0aW9uKSB7XHJcbiAgICAgICAgdGhpcy5fcG9zaXRpb25Ub29sdGlwKHRvb2x0aXAsIHsgeDogdGhpcy5wb3NpdGlvblRvQ29vcmRpbmF0ZShwb3NpdGlvbiksIHk6IDAgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEBpZ25vcmVcclxuICAgICAqL1xyXG4gICAgdXBkYXRlVG9vbHRpcEJvdW5kcyh0b29sdGlwKSB7XHJcbiAgICAgICAgY29uc3QgaW5zaWRlID0gdGhpcy5nZXQoXCJpbnNpZGVcIik7XHJcbiAgICAgICAgY29uc3QgbnVtID0gMTAwMDAwO1xyXG4gICAgICAgIGxldCBnbG9iYWwgPSB0aGlzLl9kaXNwbGF5LnRvR2xvYmFsKHsgeDogMCwgeTogMCB9KTtcclxuICAgICAgICBsZXQgeCA9IGdsb2JhbC54O1xyXG4gICAgICAgIGxldCB5ID0gMDtcclxuICAgICAgICBsZXQgdyA9IHRoaXMuYXhpc0xlbmd0aCgpO1xyXG4gICAgICAgIGxldCBoID0gbnVtO1xyXG4gICAgICAgIGxldCBwb2ludGVyT3JpZW50YXRpb24gPSBcInVwXCI7XHJcbiAgICAgICAgaWYgKHRoaXMuZ2V0KFwib3Bwb3NpdGVcIikpIHtcclxuICAgICAgICAgICAgaWYgKGluc2lkZSkge1xyXG4gICAgICAgICAgICAgICAgcG9pbnRlck9yaWVudGF0aW9uID0gXCJ1cFwiO1xyXG4gICAgICAgICAgICAgICAgeSA9IGdsb2JhbC55O1xyXG4gICAgICAgICAgICAgICAgaCA9IG51bTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHBvaW50ZXJPcmllbnRhdGlvbiA9IFwiZG93blwiO1xyXG4gICAgICAgICAgICAgICAgeSA9IGdsb2JhbC55IC0gbnVtO1xyXG4gICAgICAgICAgICAgICAgaCA9IG51bTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKGluc2lkZSkge1xyXG4gICAgICAgICAgICAgICAgcG9pbnRlck9yaWVudGF0aW9uID0gXCJkb3duXCI7XHJcbiAgICAgICAgICAgICAgICB5ID0gZ2xvYmFsLnkgLSBudW07XHJcbiAgICAgICAgICAgICAgICBoID0gbnVtO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcG9pbnRlck9yaWVudGF0aW9uID0gXCJ1cFwiO1xyXG4gICAgICAgICAgICAgICAgeSA9IGdsb2JhbC55O1xyXG4gICAgICAgICAgICAgICAgaCA9IG51bTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBib3VuZHMgPSB7IGxlZnQ6IHgsIHJpZ2h0OiB4ICsgdywgdG9wOiB5LCBib3R0b206IHkgKyBoIH07XHJcbiAgICAgICAgY29uc3Qgb2xkQm91bmRzID0gdG9vbHRpcC5nZXQoXCJib3VuZHNcIik7XHJcbiAgICAgICAgaWYgKCEkdXRpbHMuc2FtZUJvdW5kcyhib3VuZHMsIG9sZEJvdW5kcykpIHtcclxuICAgICAgICAgICAgdG9vbHRpcC5zZXQoXCJib3VuZHNcIiwgYm91bmRzKTtcclxuICAgICAgICAgICAgdG9vbHRpcC5zZXQoXCJwb2ludGVyT3JpZW50YXRpb25cIiwgcG9pbnRlck9yaWVudGF0aW9uKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEF4aXNSZW5kZXJlclgsIFwiY2xhc3NOYW1lXCIsIHtcclxuICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgIHZhbHVlOiBcIkF4aXNSZW5kZXJlclhcIlxyXG59KTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEF4aXNSZW5kZXJlclgsIFwiY2xhc3NOYW1lc1wiLCB7XHJcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICB2YWx1ZTogQXhpc1JlbmRlcmVyLmNsYXNzTmFtZXMuY29uY2F0KFtBeGlzUmVuZGVyZXJYLmNsYXNzTmFtZV0pXHJcbn0pO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1BeGlzUmVuZGVyZXJYLmpzLm1hcCIsImltcG9ydCB7IEF4aXNSZW5kZXJlciB9IGZyb20gXCIuL0F4aXNSZW5kZXJlclwiO1xyXG5pbXBvcnQgeyBwMTAwIH0gZnJvbSBcIi4uLy4uLy4uL2NvcmUvdXRpbC9QZXJjZW50XCI7XHJcbmltcG9ydCAqIGFzICR0eXBlIGZyb20gXCIuLi8uLi8uLi9jb3JlL3V0aWwvVHlwZVwiO1xyXG5pbXBvcnQgKiBhcyAkdXRpbHMgZnJvbSBcIi4uLy4uLy4uL2NvcmUvdXRpbC9VdGlsc1wiO1xyXG5pbXBvcnQgeyBSZWN0YW5nbGUgfSBmcm9tIFwiLi4vLi4vLi4vY29yZS9yZW5kZXIvUmVjdGFuZ2xlXCI7XHJcbi8qKlxyXG4gKiBVc2VkIHRvIHJlbmRlciB2ZXJ0aWNhbCBheGlzLlxyXG4gKlxyXG4gKiBAc2VlIHtAbGluayBodHRwczovL3d3dy5hbWNoYXJ0cy5jb20vZG9jcy92NS9jaGFydHMveHktY2hhcnQvI0F4aXNfcmVuZGVyZXJ9IGZvciBtb3JlIGluZm9cclxuICogQGltcG9ydGFudFxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIEF4aXNSZW5kZXJlclkgZXh0ZW5kcyBBeGlzUmVuZGVyZXIge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfZG93bllcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwidGh1bWJcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogUmVjdGFuZ2xlLm5ldyh0aGlzLl9yb290LCB7IGhlaWdodDogcDEwMCwgaXNNZWFzdXJlZDogZmFsc2UsIHRoZW1lVGFnczogW1wiYXhpc1wiLCBcInlcIiwgXCJ0aHVtYlwiXSB9KVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgX2FmdGVyTmV3KCkge1xyXG4gICAgICAgIHRoaXMuX3NldHRpbmdzLnRoZW1lVGFncyA9ICR1dGlscy5tZXJnZVRhZ3ModGhpcy5fc2V0dGluZ3MudGhlbWVUYWdzLCBbXCJyZW5kZXJlclwiLCBcInlcIl0pO1xyXG4gICAgICAgIGlmICh0aGlzLl9zZXR0aW5ncy5vcHBvc2l0ZSkge1xyXG4gICAgICAgICAgICB0aGlzLl9zZXR0aW5ncy50aGVtZVRhZ3MucHVzaChcIm9wcG9zaXRlXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzdXBlci5fYWZ0ZXJOZXcoKTtcclxuICAgICAgICB0aGlzLnNldFByaXZhdGVSYXcoXCJsZXR0ZXJcIiwgXCJZXCIpO1xyXG4gICAgICAgIGNvbnN0IGdyaWRUZW1wbGF0ZSA9IHRoaXMuZ3JpZC50ZW1wbGF0ZTtcclxuICAgICAgICBncmlkVGVtcGxhdGUuc2V0KFwid2lkdGhcIiwgcDEwMCk7XHJcbiAgICAgICAgZ3JpZFRlbXBsYXRlLnNldChcImhlaWdodFwiLCAwKTtcclxuICAgICAgICBncmlkVGVtcGxhdGUuc2V0KFwiZHJhd1wiLCAoZGlzcGxheSwgZ3JhcGhpY3MpID0+IHtcclxuICAgICAgICAgICAgZGlzcGxheS5tb3ZlVG8oMCwgMCk7XHJcbiAgICAgICAgICAgIGRpc3BsYXkubGluZVRvKGdyYXBoaWNzLndpZHRoKCksIDApO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuc2V0KFwiZHJhd1wiLCAoZGlzcGxheSwgcmVuZGVyZXIpID0+IHtcclxuICAgICAgICAgICAgZGlzcGxheS5tb3ZlVG8oMCwgMCk7XHJcbiAgICAgICAgICAgIGRpc3BsYXkubGluZVRvKDAsIHJlbmRlcmVyLmhlaWdodCgpKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIF9nZXRQYW4ocG9pbnQxLCBwb2ludDIpIHtcclxuICAgICAgICByZXR1cm4gKHBvaW50MS55IC0gcG9pbnQyLnkpIC8gdGhpcy5oZWlnaHQoKTtcclxuICAgIH1cclxuICAgIF9jaGFuZ2VkKCkge1xyXG4gICAgICAgIHN1cGVyLl9jaGFuZ2VkKCk7XHJcbiAgICAgICAgY29uc3QgYXhpcyA9IHRoaXMuYXhpcztcclxuICAgICAgICBheGlzLmdob3N0TGFiZWwuc2V0UHJpdmF0ZShcInZpc2libGVcIiwgIXRoaXMuZ2V0KFwiaW5zaWRlXCIpKTtcclxuICAgICAgICBheGlzLmdob3N0TGFiZWwuc2V0KFwieVwiLCAtMTAwMCk7XHJcbiAgICAgICAgY29uc3QgdGh1bWIgPSB0aGlzLnRodW1iO1xyXG4gICAgICAgIGNvbnN0IG9wcG9zaXRlID0gXCJvcHBvc2l0ZVwiO1xyXG4gICAgICAgIGNvbnN0IGluc2lkZSA9IFwiaW5zaWRlXCI7XHJcbiAgICAgICAgY29uc3QgY2hhcnQgPSB0aGlzLmNoYXJ0O1xyXG4gICAgICAgIGlmICh0aGlzLmlzRGlydHkob3Bwb3NpdGUpIHx8IHRoaXMuaXNEaXJ0eShpbnNpZGUpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGF4aXNDaGlsZHJlbiA9IGF4aXMuY2hpbGRyZW47XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmdldChpbnNpZGUpKSB7XHJcbiAgICAgICAgICAgICAgICBheGlzLmFkZFRhZyhpbnNpZGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgYXhpcy5yZW1vdmVUYWcoaW5zaWRlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoY2hhcnQpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmdldChvcHBvc2l0ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjaGlsZHJlbiA9IGNoYXJ0LnJpZ2h0QXhlc0NvbnRhaW5lci5jaGlsZHJlbjtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGRyZW4uaW5kZXhPZihheGlzKSA9PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbi5tb3ZlVmFsdWUoYXhpcywgMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGF4aXMuYWRkVGFnKG9wcG9zaXRlKTtcclxuICAgICAgICAgICAgICAgICAgICBheGlzQ2hpbGRyZW4ubW92ZVZhbHVlKHRoaXMsIDApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2hpbGRyZW4gPSBjaGFydC5sZWZ0QXhlc0NvbnRhaW5lci5jaGlsZHJlbjtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGRyZW4uaW5kZXhPZihheGlzKSA9PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbi5tb3ZlVmFsdWUoYXhpcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGF4aXMucmVtb3ZlVGFnKG9wcG9zaXRlKTtcclxuICAgICAgICAgICAgICAgICAgICBheGlzQ2hpbGRyZW4ubW92ZVZhbHVlKHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYXhpcy5naG9zdExhYmVsLl9hcHBseVRoZW1lcygpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5sYWJlbHMuZWFjaCgobGFiZWwpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBsYWJlbC5fYXBwbHlUaGVtZXMoKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yb290Ll9tYXJrRGlydHlSZWRyYXcoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBheGlzLm1hcmtEaXJ0eVNpemUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgdyA9IGF4aXMubGFiZWxzQ29udGFpbmVyLndpZHRoKCk7XHJcbiAgICAgICAgaWYgKGNoYXJ0KSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmdldChvcHBvc2l0ZSkpIHtcclxuICAgICAgICAgICAgICAgIHRodW1iLnNldChcImNlbnRlclhcIiwgMCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aHVtYi5zZXQoXCJjZW50ZXJYXCIsIHcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRodW1iLnNldFByaXZhdGUoXCJ3aWR0aFwiLCB3KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQGlnbm9yZVxyXG4gICAgICovXHJcbiAgICBwcm9jZXNzQXhpcygpIHtcclxuICAgICAgICBzdXBlci5wcm9jZXNzQXhpcygpO1xyXG4gICAgICAgIGNvbnN0IGF4aXMgPSB0aGlzLmF4aXM7XHJcbiAgICAgICAgaWYgKGF4aXMuZ2V0KFwiaGVpZ2h0XCIpID09IG51bGwpIHtcclxuICAgICAgICAgICAgYXhpcy5zZXQoXCJoZWlnaHRcIiwgcDEwMCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGhvcml6b250YWxMYXlvdXQgPSB0aGlzLl9yb290Lmhvcml6b250YWxMYXlvdXQ7XHJcbiAgICAgICAgYXhpcy5zZXQoXCJsYXlvdXRcIiwgaG9yaXpvbnRhbExheW91dCk7XHJcbiAgICAgICAgYXhpcy5sYWJlbHNDb250YWluZXIuc2V0KFwiaGVpZ2h0XCIsIHAxMDApO1xyXG4gICAgICAgIGF4aXMuYXhpc0hlYWRlci5zZXQoXCJsYXlvdXRcIiwgaG9yaXpvbnRhbExheW91dCk7XHJcbiAgICB9XHJcbiAgICBfdXBkYXRlUG9zaXRpb25zKCkge1xyXG4gICAgICAgIGNvbnN0IGF4aXMgPSB0aGlzLmF4aXM7XHJcbiAgICAgICAgY29uc3QgeSA9IGF4aXMueSgpIC0gJHV0aWxzLnJlbGF0aXZlVG9WYWx1ZShheGlzLmdldChcImNlbnRlcllcIiwgMCksIGF4aXMuaGVpZ2h0KCkpO1xyXG4gICAgICAgIGF4aXMuZ3JpZENvbnRhaW5lci5zZXQoXCJ5XCIsIHkpO1xyXG4gICAgICAgIGF4aXMudG9wR3JpZENvbnRhaW5lci5zZXQoXCJ5XCIsIHkpO1xyXG4gICAgICAgIGF4aXMuYnVsbGV0c0NvbnRhaW5lci5zZXQoXCJ4XCIsIHRoaXMueCgpKTtcclxuICAgICAgICBjb25zdCBjaGFydCA9IGF4aXMuY2hhcnQ7XHJcbiAgICAgICAgaWYgKGNoYXJ0KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHBsb3RDb250YWluZXIgPSBjaGFydC5wbG90Q29udGFpbmVyO1xyXG4gICAgICAgICAgICBjb25zdCBheGlzSGVhZGVyID0gYXhpcy5heGlzSGVhZGVyO1xyXG4gICAgICAgICAgICBsZXQgaGVpZ2h0ID0gYXhpcy5nZXQoXCJtYXJnaW5Ub3BcIiwgMCk7XHJcbiAgICAgICAgICAgIGlmIChheGlzSGVhZGVyLmNoaWxkcmVuLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgIGhlaWdodCA9IGF4aXMuYXhpc0hlYWRlci5oZWlnaHQoKTtcclxuICAgICAgICAgICAgICAgIGF4aXMuc2V0KFwibWFyZ2luVG9wXCIsIGhlaWdodCArIDEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgYXhpc0hlYWRlci5zZXQoXCJoZWlnaHRcIiwgaGVpZ2h0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBheGlzSGVhZGVyLnNldEFsbCh7IHk6IGF4aXMueSgpIC0gaGVpZ2h0LCB4OiAtMSwgd2lkdGg6IHBsb3RDb250YWluZXIud2lkdGgoKSArIDIgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAaWdub3JlXHJcbiAgICAgKi9cclxuICAgIGF4aXNMZW5ndGgoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYXhpcy5pbm5lckhlaWdodCgpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDb252ZXJ0cyBheGlzIHJlbGF0aXZlIHBvc2l0aW9uIHRvIGFjdHVhbCBjb29yZGluYXRlIGluIHBpeGVscy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gICBwb3NpdGlvbiAgUG9zaXRpb25cclxuICAgICAqIEByZXR1cm4gICAgICAgICAgICBQb2ludFxyXG4gICAgICovXHJcbiAgICBwb3NpdGlvblRvUG9pbnQocG9zaXRpb24pIHtcclxuICAgICAgICByZXR1cm4geyB4OiAwLCB5OiB0aGlzLnBvc2l0aW9uVG9Db29yZGluYXRlKHBvc2l0aW9uKSB9O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAaWdub3JlXHJcbiAgICAgKi9cclxuICAgIHVwZGF0ZUxhYmVsKGxhYmVsLCBwb3NpdGlvbiwgZW5kUG9zaXRpb24sIGNvdW50KSB7XHJcbiAgICAgICAgaWYgKGxhYmVsKSB7XHJcbiAgICAgICAgICAgIGlmICghJHR5cGUuaXNOdW1iZXIocG9zaXRpb24pKSB7XHJcbiAgICAgICAgICAgICAgICBwb3NpdGlvbiA9IDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGV0IGxvY2F0aW9uID0gMC41O1xyXG4gICAgICAgICAgICBpZiAoJHR5cGUuaXNOdW1iZXIoY291bnQpICYmIGNvdW50ID4gMSkge1xyXG4gICAgICAgICAgICAgICAgbG9jYXRpb24gPSBsYWJlbC5nZXQoXCJtdWx0aUxvY2F0aW9uXCIsIGxvY2F0aW9uKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGxvY2F0aW9uID0gbGFiZWwuZ2V0KFwibG9jYXRpb25cIiwgbG9jYXRpb24pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IG9wcG9zaXRlID0gdGhpcy5nZXQoXCJvcHBvc2l0ZVwiKTtcclxuICAgICAgICAgICAgY29uc3QgaW5zaWRlID0gbGFiZWwuZ2V0KFwiaW5zaWRlXCIsIHRoaXMuZ2V0KFwiaW5zaWRlXCIsIGZhbHNlKSk7XHJcbiAgICAgICAgICAgIGlmIChvcHBvc2l0ZSkge1xyXG4gICAgICAgICAgICAgICAgbGFiZWwuc2V0KFwieFwiLCAwKTtcclxuICAgICAgICAgICAgICAgIGlmIChpbnNpZGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBsYWJlbC5zZXQoXCJwb3NpdGlvblwiLCBcImFic29sdXRlXCIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGFiZWwuc2V0KFwicG9zaXRpb25cIiwgXCJyZWxhdGl2ZVwiKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlmIChpbnNpZGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBsYWJlbC5zZXQoXCJ4XCIsIDApO1xyXG4gICAgICAgICAgICAgICAgICAgIGxhYmVsLnNldChcInBvc2l0aW9uXCIsIFwiYWJzb2x1dGVcIik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBsYWJlbC5zZXQoXCJ4XCIsIHVuZGVmaW5lZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgbGFiZWwuc2V0KFwicG9zaXRpb25cIiwgXCJyZWxhdGl2ZVwiKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoJHR5cGUuaXNOdW1iZXIoZW5kUG9zaXRpb24pICYmIGVuZFBvc2l0aW9uICE9IHBvc2l0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICBwb3NpdGlvbiA9IHBvc2l0aW9uICsgKGVuZFBvc2l0aW9uIC0gcG9zaXRpb24pICogbG9jYXRpb247XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGFiZWwuc2V0KFwieVwiLCB0aGlzLnBvc2l0aW9uVG9Db29yZGluYXRlKHBvc2l0aW9uKSk7XHJcbiAgICAgICAgICAgIHRoaXMudG9nZ2xlVmlzaWJpbGl0eShsYWJlbCwgcG9zaXRpb24sIGxhYmVsLmdldChcIm1pblBvc2l0aW9uXCIsIDApLCBsYWJlbC5nZXQoXCJtYXhQb3NpdGlvblwiLCAxKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAaWdub3JlXHJcbiAgICAgKi9cclxuICAgIHVwZGF0ZUdyaWQoZ3JpZCwgcG9zaXRpb24sIGVuZFBvc2l0aW9uKSB7XHJcbiAgICAgICAgaWYgKGdyaWQpIHtcclxuICAgICAgICAgICAgaWYgKCEkdHlwZS5pc051bWJlcihwb3NpdGlvbikpIHtcclxuICAgICAgICAgICAgICAgIHBvc2l0aW9uID0gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsZXQgbG9jYXRpb24gPSBncmlkLmdldChcImxvY2F0aW9uXCIsIDAuNSk7XHJcbiAgICAgICAgICAgIGlmICgkdHlwZS5pc051bWJlcihlbmRQb3NpdGlvbikgJiYgZW5kUG9zaXRpb24gIT0gcG9zaXRpb24pIHtcclxuICAgICAgICAgICAgICAgIHBvc2l0aW9uID0gcG9zaXRpb24gKyAoZW5kUG9zaXRpb24gLSBwb3NpdGlvbikgKiBsb2NhdGlvbjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBncmlkLnNldChcInlcIiwgdGhpcy5wb3NpdGlvblRvQ29vcmRpbmF0ZShwb3NpdGlvbikpO1xyXG4gICAgICAgICAgICB0aGlzLnRvZ2dsZVZpc2liaWxpdHkoZ3JpZCwgcG9zaXRpb24sIDAsIDEpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQGlnbm9yZVxyXG4gICAgICovXHJcbiAgICB1cGRhdGVUaWNrKHRpY2ssIHBvc2l0aW9uLCBlbmRQb3NpdGlvbiwgY291bnQpIHtcclxuICAgICAgICBpZiAodGljaykge1xyXG4gICAgICAgICAgICBpZiAoISR0eXBlLmlzTnVtYmVyKHBvc2l0aW9uKSkge1xyXG4gICAgICAgICAgICAgICAgcG9zaXRpb24gPSAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGxldCBsb2NhdGlvbiA9IDAuNTtcclxuICAgICAgICAgICAgaWYgKCR0eXBlLmlzTnVtYmVyKGNvdW50KSAmJiBjb3VudCA+IDEpIHtcclxuICAgICAgICAgICAgICAgIGxvY2F0aW9uID0gdGljay5nZXQoXCJtdWx0aUxvY2F0aW9uXCIsIGxvY2F0aW9uKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGxvY2F0aW9uID0gdGljay5nZXQoXCJsb2NhdGlvblwiLCBsb2NhdGlvbik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCR0eXBlLmlzTnVtYmVyKGVuZFBvc2l0aW9uKSAmJiBlbmRQb3NpdGlvbiAhPSBwb3NpdGlvbikge1xyXG4gICAgICAgICAgICAgICAgcG9zaXRpb24gPSBwb3NpdGlvbiArIChlbmRQb3NpdGlvbiAtIHBvc2l0aW9uKSAqIGxvY2F0aW9uO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRpY2suc2V0KFwieVwiLCB0aGlzLnBvc2l0aW9uVG9Db29yZGluYXRlKHBvc2l0aW9uKSk7XHJcbiAgICAgICAgICAgIGxldCBsZW5ndGggPSB0aWNrLmdldChcImxlbmd0aFwiLCAwKTtcclxuICAgICAgICAgICAgY29uc3QgaW5zaWRlID0gdGljay5nZXQoXCJpbnNpZGVcIiwgdGhpcy5nZXQoXCJpbnNpZGVcIiwgZmFsc2UpKTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuZ2V0KFwib3Bwb3NpdGVcIikpIHtcclxuICAgICAgICAgICAgICAgIHRpY2suc2V0KFwieFwiLCAwKTtcclxuICAgICAgICAgICAgICAgIGlmIChpbnNpZGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBsZW5ndGggKj0gLTE7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWluc2lkZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxlbmd0aCAqPSAtMTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aWNrLnNldChcImRyYXdcIiwgKGRpc3BsYXkpID0+IHtcclxuICAgICAgICAgICAgICAgIGRpc3BsYXkubW92ZVRvKDAsIDApO1xyXG4gICAgICAgICAgICAgICAgZGlzcGxheS5saW5lVG8obGVuZ3RoLCAwKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHRoaXMudG9nZ2xlVmlzaWJpbGl0eSh0aWNrLCBwb3NpdGlvbiwgdGljay5nZXQoXCJtaW5Qb3NpdGlvblwiLCAwKSwgdGljay5nZXQoXCJtYXhQb3NpdGlvblwiLCAxKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAaWdub3JlXHJcbiAgICAgKi9cclxuICAgIHVwZGF0ZUJ1bGxldChidWxsZXQsIHBvc2l0aW9uLCBlbmRQb3NpdGlvbikge1xyXG4gICAgICAgIGlmIChidWxsZXQpIHtcclxuICAgICAgICAgICAgY29uc3Qgc3ByaXRlID0gYnVsbGV0LmdldChcInNwcml0ZVwiKTtcclxuICAgICAgICAgICAgaWYgKHNwcml0ZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCEkdHlwZS5pc051bWJlcihwb3NpdGlvbikpIHtcclxuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbiA9IDA7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBsZXQgbG9jYXRpb24gPSBidWxsZXQuZ2V0KFwibG9jYXRpb25cIiwgMC41KTtcclxuICAgICAgICAgICAgICAgIGlmICgkdHlwZS5pc051bWJlcihlbmRQb3NpdGlvbikgJiYgZW5kUG9zaXRpb24gIT0gcG9zaXRpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbiA9IHBvc2l0aW9uICsgKGVuZFBvc2l0aW9uIC0gcG9zaXRpb24pICogbG9jYXRpb247XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBsZXQgYnVsbGV0UG9zaXRpb24gPSB0aGlzLmF4aXMucm91bmRBeGlzUG9zaXRpb24ocG9zaXRpb24sIGxvY2F0aW9uKTtcclxuICAgICAgICAgICAgICAgIGxldCBwcmV2aW91c0J1bGxldCA9IHRoaXMuYXhpcy5fYnVsbGV0c1tidWxsZXRQb3NpdGlvbl07XHJcbiAgICAgICAgICAgICAgICBsZXQgZCA9IDE7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5nZXQoXCJvcHBvc2l0ZVwiKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGQgPSAtMTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChidWxsZXQuZ2V0KFwic3RhY2tlZFwiKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChwcmV2aW91c0J1bGxldCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgcHJldmlvdXNTcHJpdGUgPSBwcmV2aW91c0J1bGxldC5nZXQoXCJzcHJpdGVcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcmV2aW91c1Nwcml0ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ByaXRlLnNldChcInhcIiwgcHJldmlvdXNTcHJpdGUueCgpICsgcHJldmlvdXNTcHJpdGUud2lkdGgoKSAqIGQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzcHJpdGUuc2V0KFwieFwiLCAwKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLmF4aXMuX2J1bGxldHNbYnVsbGV0UG9zaXRpb25dID0gYnVsbGV0O1xyXG4gICAgICAgICAgICAgICAgc3ByaXRlLnNldChcInlcIiwgdGhpcy5wb3NpdGlvblRvQ29vcmRpbmF0ZShwb3NpdGlvbikpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy50b2dnbGVWaXNpYmlsaXR5KHNwcml0ZSwgcG9zaXRpb24sIDAsIDEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAaWdub3JlXHJcbiAgICAgKi9cclxuICAgIHVwZGF0ZUZpbGwoZmlsbCwgcG9zaXRpb24sIGVuZFBvc2l0aW9uKSB7XHJcbiAgICAgICAgaWYgKGZpbGwpIHtcclxuICAgICAgICAgICAgaWYgKCEkdHlwZS5pc051bWJlcihwb3NpdGlvbikpIHtcclxuICAgICAgICAgICAgICAgIHBvc2l0aW9uID0gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoISR0eXBlLmlzTnVtYmVyKGVuZFBvc2l0aW9uKSkge1xyXG4gICAgICAgICAgICAgICAgZW5kUG9zaXRpb24gPSAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGxldCB5MCA9IHRoaXMucG9zaXRpb25Ub0Nvb3JkaW5hdGUocG9zaXRpb24pO1xyXG4gICAgICAgICAgICBsZXQgeTEgPSB0aGlzLnBvc2l0aW9uVG9Db29yZGluYXRlKGVuZFBvc2l0aW9uKTtcclxuICAgICAgICAgICAgdGhpcy5maWxsRHJhd01ldGhvZChmaWxsLCB5MCwgeTEpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZpbGxEcmF3TWV0aG9kKGZpbGwsIHkwLCB5MSkge1xyXG4gICAgICAgIGZpbGwuc2V0KFwiZHJhd1wiLCAoZGlzcGxheSkgPT4ge1xyXG4gICAgICAgICAgICAvLyB1c2luZyBmb3IgaG9sZXMsIHNvIGNhbiBub3QgYmUgcmVjdGFuZ2xlXHJcbiAgICAgICAgICAgIGNvbnN0IHcgPSB0aGlzLmF4aXMuZ3JpZENvbnRhaW5lci53aWR0aCgpO1xyXG4gICAgICAgICAgICBjb25zdCBoID0gdGhpcy5oZWlnaHQoKTtcclxuICAgICAgICAgICAgaWYgKHkxIDwgeTApIHtcclxuICAgICAgICAgICAgICAgIFt5MSwgeTBdID0gW3kwLCB5MV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHkwID4gaCB8fCB5MSA8IDApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvL3kwID0gTWF0aC5tYXgoMCwgeTApO1xyXG4gICAgICAgICAgICAvL3kxID0gTWF0aC5taW4oaCwgeTEpO1xyXG4gICAgICAgICAgICBkaXNwbGF5Lm1vdmVUbygwLCB5MCk7XHJcbiAgICAgICAgICAgIGRpc3BsYXkubGluZVRvKHcsIHkwKTtcclxuICAgICAgICAgICAgZGlzcGxheS5saW5lVG8odywgeTEpO1xyXG4gICAgICAgICAgICBkaXNwbGF5LmxpbmVUbygwLCB5MSk7XHJcbiAgICAgICAgICAgIGRpc3BsYXkubGluZVRvKDAsIHkwKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ29udmVydHMgcmVsYXRpdmUgcG9zaXRpb24gKDAtMSkgb24gYXhpcyB0byBhIHBpeGVsIGNvb3JkaW5hdGUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHBvc2l0aW9uICBQb3NpdGlvbiAoMC0xKVxyXG4gICAgICogQHJldHVybiBDb29yZGluYXRlIChweClcclxuICAgICAqL1xyXG4gICAgcG9zaXRpb25Ub0Nvb3JkaW5hdGUocG9zaXRpb24pIHtcclxuICAgICAgICBpZiAoIXRoaXMuX2ludmVyc2VkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAodGhpcy5fZW5kIC0gcG9zaXRpb24pICogdGhpcy5fYXhpc0xlbmd0aDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiAocG9zaXRpb24gLSB0aGlzLl9zdGFydCkgKiB0aGlzLl9heGlzTGVuZ3RoO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQGlnbm9yZVxyXG4gICAgICovXHJcbiAgICBwb3NpdGlvblRvb2x0aXAodG9vbHRpcCwgcG9zaXRpb24pIHtcclxuICAgICAgICB0aGlzLl9wb3NpdGlvblRvb2x0aXAodG9vbHRpcCwgeyB4OiAwLCB5OiB0aGlzLnBvc2l0aW9uVG9Db29yZGluYXRlKHBvc2l0aW9uKSB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQGlnbm9yZVxyXG4gICAgICovXHJcbiAgICB1cGRhdGVUb29sdGlwQm91bmRzKHRvb2x0aXApIHtcclxuICAgICAgICBjb25zdCBpbnNpZGUgPSB0aGlzLmdldChcImluc2lkZVwiKTtcclxuICAgICAgICBjb25zdCBudW0gPSAxMDAwMDA7XHJcbiAgICAgICAgbGV0IGdsb2JhbCA9IHRoaXMuX2Rpc3BsYXkudG9HbG9iYWwoeyB4OiAwLCB5OiAwIH0pO1xyXG4gICAgICAgIGxldCB5ID0gZ2xvYmFsLnk7XHJcbiAgICAgICAgbGV0IHggPSAwO1xyXG4gICAgICAgIGxldCBoID0gdGhpcy5heGlzTGVuZ3RoKCk7XHJcbiAgICAgICAgbGV0IHcgPSBudW07XHJcbiAgICAgICAgbGV0IHBvaW50ZXJPcmllbnRhdGlvbiA9IFwicmlnaHRcIjtcclxuICAgICAgICBpZiAodGhpcy5nZXQoXCJvcHBvc2l0ZVwiKSkge1xyXG4gICAgICAgICAgICBpZiAoaW5zaWRlKSB7XHJcbiAgICAgICAgICAgICAgICBwb2ludGVyT3JpZW50YXRpb24gPSBcInJpZ2h0XCI7XHJcbiAgICAgICAgICAgICAgICB4ID0gZ2xvYmFsLnggLSBudW07XHJcbiAgICAgICAgICAgICAgICB3ID0gbnVtO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcG9pbnRlck9yaWVudGF0aW9uID0gXCJsZWZ0XCI7XHJcbiAgICAgICAgICAgICAgICB4ID0gZ2xvYmFsLng7XHJcbiAgICAgICAgICAgICAgICB3ID0gbnVtO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAoaW5zaWRlKSB7XHJcbiAgICAgICAgICAgICAgICBwb2ludGVyT3JpZW50YXRpb24gPSBcImxlZnRcIjtcclxuICAgICAgICAgICAgICAgIHggPSBnbG9iYWwueDtcclxuICAgICAgICAgICAgICAgIHcgPSBudW07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBwb2ludGVyT3JpZW50YXRpb24gPSBcInJpZ2h0XCI7XHJcbiAgICAgICAgICAgICAgICB4ID0gZ2xvYmFsLnggLSBudW07XHJcbiAgICAgICAgICAgICAgICB3ID0gbnVtO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGJvdW5kcyA9IHsgbGVmdDogeCwgcmlnaHQ6IHggKyB3LCB0b3A6IHksIGJvdHRvbTogeSArIGggfTtcclxuICAgICAgICBjb25zdCBvbGRCb3VuZHMgPSB0b29sdGlwLmdldChcImJvdW5kc1wiKTtcclxuICAgICAgICBpZiAoISR1dGlscy5zYW1lQm91bmRzKGJvdW5kcywgb2xkQm91bmRzKSkge1xyXG4gICAgICAgICAgICB0b29sdGlwLnNldChcImJvdW5kc1wiLCBib3VuZHMpO1xyXG4gICAgICAgICAgICB0b29sdGlwLnNldChcInBvaW50ZXJPcmllbnRhdGlvblwiLCBwb2ludGVyT3JpZW50YXRpb24pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQGlnbm9yZVxyXG4gICAgICovXHJcbiAgICBfdXBkYXRlTEMoKSB7XHJcbiAgICAgICAgY29uc3QgYXhpcyA9IHRoaXMuYXhpcztcclxuICAgICAgICBjb25zdCBwYXJlbnQgPSBheGlzLnBhcmVudDtcclxuICAgICAgICBpZiAocGFyZW50KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGggPSBwYXJlbnQuaW5uZXJIZWlnaHQoKTtcclxuICAgICAgICAgICAgdGhpcy5fbGMgPSB0aGlzLmF4aXNMZW5ndGgoKSAvIGg7XHJcbiAgICAgICAgICAgIHRoaXMuX2xzID0gYXhpcy55KCkgLyBoO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQGlnbm9yZVxyXG4gICAgICovXHJcbiAgICB0b0F4aXNQb3NpdGlvbihwb3NpdGlvbikge1xyXG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy5fc3RhcnQgfHwgMDtcclxuICAgICAgICBjb25zdCBlbmQgPSB0aGlzLl9lbmQgfHwgMTtcclxuICAgICAgICBwb3NpdGlvbiAtPSB0aGlzLl9scztcclxuICAgICAgICBwb3NpdGlvbiA9IHBvc2l0aW9uICogKGVuZCAtIHN0YXJ0KSAvIHRoaXMuX2xjO1xyXG4gICAgICAgIGlmICh0aGlzLmdldChcImludmVyc2VkXCIpKSB7XHJcbiAgICAgICAgICAgIHBvc2l0aW9uID0gc3RhcnQgKyBwb3NpdGlvbjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHBvc2l0aW9uID0gZW5kIC0gcG9zaXRpb247XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBwb3NpdGlvbjtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQGlnbm9yZVxyXG4gICAgICovXHJcbiAgICB0b0dsb2JhbFBvc2l0aW9uKHBvc2l0aW9uKSB7XHJcbiAgICAgICAgY29uc3Qgc3RhcnQgPSB0aGlzLl9zdGFydCB8fCAwO1xyXG4gICAgICAgIGNvbnN0IGVuZCA9IHRoaXMuX2VuZCB8fCAxO1xyXG4gICAgICAgIGlmICh0aGlzLmdldChcImludmVyc2VkXCIpKSB7XHJcbiAgICAgICAgICAgIHBvc2l0aW9uID0gcG9zaXRpb24gLSBzdGFydDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHBvc2l0aW9uID0gZW5kIC0gcG9zaXRpb247XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHBvc2l0aW9uID0gcG9zaXRpb24gLyAoZW5kIC0gc3RhcnQpICogdGhpcy5fbGM7XHJcbiAgICAgICAgcG9zaXRpb24gKz0gdGhpcy5fbHM7XHJcbiAgICAgICAgcmV0dXJuIHBvc2l0aW9uO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAaWdub3JlXHJcbiAgICAgKi9cclxuICAgIGZpeFBvc2l0aW9uKHBvc2l0aW9uKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmdldChcImludmVyc2VkXCIpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAxIC0gcG9zaXRpb247XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBwb3NpdGlvbjtcclxuICAgIH1cclxufVxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQXhpc1JlbmRlcmVyWSwgXCJjbGFzc05hbWVcIiwge1xyXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgdmFsdWU6IFwiQXhpc1JlbmRlcmVyWVwiXHJcbn0pO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQXhpc1JlbmRlcmVyWSwgXCJjbGFzc05hbWVzXCIsIHtcclxuICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgIHZhbHVlOiBBeGlzUmVuZGVyZXIuY2xhc3NOYW1lcy5jb25jYXQoW0F4aXNSZW5kZXJlclkuY2xhc3NOYW1lXSlcclxufSk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUF4aXNSZW5kZXJlclkuanMubWFwIiwiaW1wb3J0IHsgVGljayB9IGZyb20gXCIuLi8uLi8uLi9jb3JlL3JlbmRlci9UaWNrXCI7XHJcbi8qKlxyXG4gKiBEcmF3cyBhbiBheGlzIHRpY2suXHJcbiAqXHJcbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vd3d3LmFtY2hhcnRzLmNvbS9kb2NzL3Y1L2NoYXJ0cy94eS1jaGFydC9heGVzLyNUaWNrc30gZm9yIG1vcmUgaW5mb1xyXG4gKiBAaW1wb3J0YW50XHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgQXhpc1RpY2sgZXh0ZW5kcyBUaWNrIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX3RpY2tQb2ludHNcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogW11cclxuICAgICAgICB9KTtcclxuICAgIH1cclxufVxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQXhpc1RpY2ssIFwiY2xhc3NOYW1lXCIsIHtcclxuICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgIHZhbHVlOiBcIkF4aXNUaWNrXCJcclxufSk7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShBeGlzVGljaywgXCJjbGFzc05hbWVzXCIsIHtcclxuICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgIHZhbHVlOiBUaWNrLmNsYXNzTmFtZXMuY29uY2F0KFtBeGlzVGljay5jbGFzc05hbWVdKVxyXG59KTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QXhpc1RpY2suanMubWFwIiwiaW1wb3J0IHsgQXhpcyB9IGZyb20gXCIuL0F4aXNcIjtcclxuaW1wb3J0ICogYXMgJGFycmF5IGZyb20gXCIuLi8uLi8uLi9jb3JlL3V0aWwvQXJyYXlcIjtcclxuaW1wb3J0ICogYXMgJHR5cGUgZnJvbSBcIi4uLy4uLy4uL2NvcmUvdXRpbC9UeXBlXCI7XHJcbmltcG9ydCAqIGFzICRtYXRoIGZyb20gXCIuLi8uLi8uLi9jb3JlL3V0aWwvTWF0aFwiO1xyXG5pbXBvcnQgKiBhcyAkdXRpbHMgZnJvbSBcIi4uLy4uLy4uL2NvcmUvdXRpbC9VdGlsc1wiO1xyXG5pbXBvcnQgeyBwb3B1bGF0ZVN0cmluZyB9IGZyb20gXCIuLi8uLi8uLi9jb3JlL3V0aWwvUG9wdWxhdGVTdHJpbmdcIjtcclxuLyoqXHJcbiAqIENyZWF0ZXMgYSBjYXRlZ29yeSBheGlzLlxyXG4gKlxyXG4gKiBAc2VlIHtAbGluayBodHRwczovL3d3dy5hbWNoYXJ0cy5jb20vZG9jcy92NS9jaGFydHMveHktY2hhcnQvYXhlcy9jYXRlZ29yeS1heGlzL30gZm9yIG1vcmUgaW5mb1xyXG4gKiBAaW1wb3J0YW50XHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgQ2F0ZWdvcnlBeGlzIGV4dGVuZHMgQXhpcyB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9mcmVxdWVuY3lcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogMVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9pdGVtTWFwXCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IHt9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBfYWZ0ZXJOZXcoKSB7XHJcbiAgICAgICAgdGhpcy5fc2V0dGluZ3MudGhlbWVUYWdzID0gJHV0aWxzLm1lcmdlVGFncyh0aGlzLl9zZXR0aW5ncy50aGVtZVRhZ3MsIFtcImF4aXNcIl0pO1xyXG4gICAgICAgIHRoaXMuZmllbGRzLnB1c2goXCJjYXRlZ29yeVwiKTtcclxuICAgICAgICB0aGlzLnNldFByaXZhdGVSYXcoXCJuYW1lXCIsIFwiY2F0ZWdvcnlcIik7XHJcbiAgICAgICAgdGhpcy5hZGRUYWcoXCJjYXRlZ29yeVwiKTtcclxuICAgICAgICBzdXBlci5fYWZ0ZXJOZXcoKTtcclxuICAgIH1cclxuICAgIF9wcmVwYXJlQ2hpbGRyZW4oKSB7XHJcbiAgICAgICAgc3VwZXIuX3ByZXBhcmVDaGlsZHJlbigpO1xyXG4gICAgICAgIGNvbnN0IGxlbiA9IHRoaXMuZGF0YUl0ZW1zLmxlbmd0aDtcclxuICAgICAgICBsZXQgaSA9IDA7XHJcbiAgICAgICAgaWYgKHRoaXMuX3ZhbHVlc0RpcnR5KSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2l0ZW1NYXAgPSB7fTtcclxuICAgICAgICAgICAgJGFycmF5LmVhY2godGhpcy5kYXRhSXRlbXMsIChkYXRhSXRlbSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgZGF0YUl0ZW0uc2V0UmF3KFwiaW5kZXhcIiwgaSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9pdGVtTWFwW2RhdGFJdGVtLmdldChcImNhdGVnb3J5XCIpXSA9IGRhdGFJdGVtO1xyXG4gICAgICAgICAgICAgICAgaSsrO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgdGhpcy5zZXRQcml2YXRlUmF3KFwibWF4Wm9vbUZhY3RvclwiLCBsZW4pO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnNldFByaXZhdGVSYXcoXCJzdGFydEluZGV4XCIsIE1hdGgubWF4KE1hdGgucm91bmQodGhpcy5nZXQoXCJzdGFydFwiLCAwKSAqIGxlbiksIDApKTtcclxuICAgICAgICB0aGlzLnNldFByaXZhdGVSYXcoXCJlbmRJbmRleFwiLCBNYXRoLm1pbihNYXRoLnJvdW5kKHRoaXMuZ2V0KFwiZW5kXCIsIDEpICogbGVuKSwgbGVuKSk7XHJcbiAgICAgICAgaWYgKHRoaXMuX3NpemVEaXJ0eSB8fCB0aGlzLl92YWx1ZXNEaXJ0eSB8fCAodGhpcy5pc0RpcnR5KFwic3RhcnRcIikgfHwgdGhpcy5pc0RpcnR5KFwiZW5kXCIpIHx8IHRoaXMuaXNQcml2YXRlRGlydHkoXCJlbmRJbmRleFwiKSB8fCB0aGlzLmlzUHJpdmF0ZURpcnR5KFwic3RhcnRJbmRleFwiKSB8fCB0aGlzLmlzUHJpdmF0ZURpcnR5KFwid2lkdGhcIikgfHwgdGhpcy5pc1ByaXZhdGVEaXJ0eShcImhlaWdodFwiKSkpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuZGF0YUl0ZW1zLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2hhbmRsZVJhbmdlQ2hhbmdlKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9wcmVwYXJlQXhpc0l0ZW1zKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGVBeGlzUmFuZ2VzKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBfaGFuZGxlUmFuZ2VDaGFuZ2UoKSB7XHJcbiAgICAgICAgJGFycmF5LmVhY2godGhpcy5zZXJpZXMsIChzZXJpZXMpID0+IHtcclxuICAgICAgICAgICAgbGV0IHN0YXJ0Q2F0ZWdvcnkgPSB0aGlzLmRhdGFJdGVtc1t0aGlzLnN0YXJ0SW5kZXgoKV0uZ2V0KFwiY2F0ZWdvcnlcIik7XHJcbiAgICAgICAgICAgIGxldCBlbmRDYXRlZ29yeSA9IHRoaXMuZGF0YUl0ZW1zW3RoaXMuZW5kSW5kZXgoKSAtIDFdLmdldChcImNhdGVnb3J5XCIpO1xyXG4gICAgICAgICAgICBsZXQgYmFzZUF4aXMgPSBzZXJpZXMuZ2V0KFwiYmFzZUF4aXNcIik7XHJcbiAgICAgICAgICAgIGxldCB4QXhpcyA9IHNlcmllcy5nZXQoXCJ4QXhpc1wiKTtcclxuICAgICAgICAgICAgbGV0IHlBeGlzID0gc2VyaWVzLmdldChcInlBeGlzXCIpO1xyXG4gICAgICAgICAgICBpZiAoeEF4aXMgaW5zdGFuY2VvZiBDYXRlZ29yeUF4aXMgJiYgeUF4aXMgaW5zdGFuY2VvZiBDYXRlZ29yeUF4aXMpIHtcclxuICAgICAgICAgICAgICAgIHNlcmllcy5fbWFya0RpcnR5QXhlcygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGJhc2VBeGlzID09PSB0aGlzKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQga2V5O1xyXG4gICAgICAgICAgICAgICAgbGV0IG9wZW5LZXk7XHJcbiAgICAgICAgICAgICAgICBsZXQgb3RoZXJBeGlzID0geUF4aXM7XHJcbiAgICAgICAgICAgICAgICBpZiAoeEF4aXMgPT09IGJhc2VBeGlzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlcmllcy5nZXQoXCJjYXRlZ29yeVhGaWVsZFwiKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBrZXkgPSBcImNhdGVnb3J5WFwiO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoc2VyaWVzLmdldChcIm9wZW5DYXRlZ29yeVhGaWVsZFwiKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvcGVuS2V5ID0gXCJvcGVuQ2F0ZWdvcnlYXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoeUF4aXMgPT09IGJhc2VBeGlzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlcmllcy5nZXQoXCJjYXRlZ29yeVlGaWVsZFwiKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBrZXkgPSBcImNhdGVnb3J5WVwiO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoc2VyaWVzLmdldChcIm9wZW5DYXRlZ29yeVlGaWVsZFwiKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvcGVuS2V5ID0gXCJvcGVuQ2F0ZWdvcnlZXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIG90aGVyQXhpcyA9IHhBeGlzO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKG90aGVyQXhpcy5jbGFzc05hbWUgPT0gXCJWYWx1ZUF4aXNcIikge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChrZXkgfHwgb3BlbktleSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgc3RhcnREYXRhSXRlbTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGVuZERhdGFJdGVtO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gc2VyaWVzLmRhdGFJdGVtcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGRhdGFJdGVtID0gc2VyaWVzLmRhdGFJdGVtc1tpXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChrZXkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YUl0ZW0uZ2V0KGtleSkgPT09IHN0YXJ0Q2F0ZWdvcnkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnREYXRhSXRlbSA9IGRhdGFJdGVtO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob3BlbktleSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkYXRhSXRlbS5nZXQob3BlbktleSkgPT09IHN0YXJ0Q2F0ZWdvcnkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnREYXRhSXRlbSA9IGRhdGFJdGVtO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IHNlcmllcy5kYXRhSXRlbXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBkYXRhSXRlbSA9IHNlcmllcy5kYXRhSXRlbXNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoa2V5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGFJdGVtLmdldChrZXkpID09PSBlbmRDYXRlZ29yeSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmREYXRhSXRlbSA9IGRhdGFJdGVtO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob3BlbktleSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkYXRhSXRlbS5nZXQob3BlbktleSkgPT09IGVuZENhdGVnb3J5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZERhdGFJdGVtID0gZGF0YUl0ZW07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgc3RhcnRJbmRleCA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBlbmRJbmRleCA9IHNlcmllcy5kYXRhSXRlbXMubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RhcnREYXRhSXRlbSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRJbmRleCA9IHNlcmllcy5kYXRhSXRlbXMuaW5kZXhPZihzdGFydERhdGFJdGVtKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZW5kRGF0YUl0ZW0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZEluZGV4ID0gc2VyaWVzLmRhdGFJdGVtcy5pbmRleE9mKGVuZERhdGFJdGVtKSArIDE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgc2VyaWVzLnNldFByaXZhdGUoXCJzdGFydEluZGV4XCIsIHN0YXJ0SW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXJpZXMuc2V0UHJpdmF0ZShcImVuZEluZGV4XCIsIGVuZEluZGV4KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGhhc1ZhbHVlID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSBzdGFydEluZGV4OyBpIDwgZW5kSW5kZXg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZGF0YUl0ZW0gPSBzZXJpZXMuZGF0YUl0ZW1zW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJGFycmF5LmVhY2goc2VyaWVzLl9fdmFsdWVYU2hvd0ZpZWxkcywgKGtleSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCB2YWx1ZSA9IGRhdGFJdGVtLmdldChrZXkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhc1ZhbHVlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICRhcnJheS5lYWNoKHNlcmllcy5fX3ZhbHVlWVNob3dGaWVsZHMsIChrZXkpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgdmFsdWUgPSBkYXRhSXRlbS5nZXQoa2V5KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYXNWYWx1ZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaGFzVmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXJpZXMuc2V0UHJpdmF0ZShcIm91dE9mU2VsZWN0aW9uXCIsICFoYXNWYWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgc2VyaWVzLl9tYXJrRGlydHlBeGVzKCk7IC8vIG11c3QgYmUgb3V0c2lkZVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBfcHJlcGFyZUF4aXNJdGVtcygpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgY29uc3QgcmVuZGVyZXIgPSB0aGlzLmdldChcInJlbmRlcmVyXCIpO1xyXG4gICAgICAgIGNvbnN0IGxlbiA9IHRoaXMuZGF0YUl0ZW1zLmxlbmd0aDtcclxuICAgICAgICBsZXQgc3RhcnRJbmRleCA9IHRoaXMuc3RhcnRJbmRleCgpO1xyXG4gICAgICAgIGlmIChzdGFydEluZGV4ID4gMCkge1xyXG4gICAgICAgICAgICBzdGFydEluZGV4LS07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBlbmRJbmRleCA9IHRoaXMuZW5kSW5kZXgoKTtcclxuICAgICAgICBpZiAoZW5kSW5kZXggPCBsZW4pIHtcclxuICAgICAgICAgICAgZW5kSW5kZXgrKztcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgbWlub3JMYWJlbHNFbmFibGVkID0gcmVuZGVyZXIuZ2V0KFwibWlub3JMYWJlbHNFbmFibGVkXCIpO1xyXG4gICAgICAgIGNvbnN0IG1pbm9yR3JpZEVuYWJsZWQgPSByZW5kZXJlci5nZXQoXCJtaW5vckdyaWRFbmFibGVkXCIsIG1pbm9yTGFiZWxzRW5hYmxlZCk7XHJcbiAgICAgICAgbGV0IG1heENvdW50ID0gcmVuZGVyZXIuYXhpc0xlbmd0aCgpIC8gTWF0aC5tYXgocmVuZGVyZXIuZ2V0KFwibWluR3JpZERpc3RhbmNlXCIpLCAxKTtcclxuICAgICAgICBsZXQgZnJlcXVlbmN5ID0gTWF0aC5tYXgoMSwgTWF0aC5taW4obGVuLCBNYXRoLmNlaWwoKGVuZEluZGV4IC0gc3RhcnRJbmRleCkgLyBtYXhDb3VudCkpKTtcclxuICAgICAgICBzdGFydEluZGV4ID0gTWF0aC5mbG9vcihzdGFydEluZGV4IC8gZnJlcXVlbmN5KSAqIGZyZXF1ZW5jeTtcclxuICAgICAgICB0aGlzLl9mcmVxdWVuY3kgPSBmcmVxdWVuY3k7XHJcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBsZW47IGorKykge1xyXG4gICAgICAgICAgICB0aGlzLl90b2dnbGVEYXRhSXRlbSh0aGlzLmRhdGFJdGVtc1tqXSwgZmFsc2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgZiA9IHRoaXMuZGF0YUl0ZW1zW3N0YXJ0SW5kZXhdLmdldChcImluZGV4XCIsIDApO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSBzdGFydEluZGV4OyBpIDwgZW5kSW5kZXg7IGkgPSBpICsgZnJlcXVlbmN5KSB7XHJcbiAgICAgICAgICAgIGxldCBkYXRhSXRlbSA9IHRoaXMuZGF0YUl0ZW1zW2ldO1xyXG4gICAgICAgICAgICB0aGlzLl9jcmVhdGVBc3NldHMoZGF0YUl0ZW0sIFtdKTtcclxuICAgICAgICAgICAgdGhpcy5fdG9nZ2xlRGF0YUl0ZW0oZGF0YUl0ZW0sIHRydWUpO1xyXG4gICAgICAgICAgICBsZXQgY291bnQgPSBmcmVxdWVuY3k7XHJcbiAgICAgICAgICAgIGlmIChtaW5vckdyaWRFbmFibGVkKSB7XHJcbiAgICAgICAgICAgICAgICBjb3VudCA9IDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fcHJlcGFyZURhdGFJdGVtKGRhdGFJdGVtLCBmLCBjb3VudCk7XHJcbiAgICAgICAgICAgIGYrKztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHJlbmRlcmVyLmdldChcIm1pbm9yR3JpZEVuYWJsZWRcIikpIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IHN0YXJ0SW5kZXg7IGkgPCBlbmRJbmRleDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgZGF0YUl0ZW0gPSB0aGlzLmRhdGFJdGVtc1tpXTtcclxuICAgICAgICAgICAgICAgIGlmIChpICUgZnJlcXVlbmN5ICE9IDApIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jcmVhdGVBc3NldHMoZGF0YUl0ZW0sIFtcIm1pbm9yXCJdLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl90b2dnbGVEYXRhSXRlbShkYXRhSXRlbSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcHJlcGFyZURhdGFJdGVtKGRhdGFJdGVtLCAwLCAxKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIW1pbm9yTGFiZWxzRW5hYmxlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAoX2EgPSBkYXRhSXRlbS5nZXQoXCJsYWJlbFwiKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNldFByaXZhdGUoXCJ2aXNpYmxlXCIsIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fdXBkYXRlR2hvc3QoKTtcclxuICAgIH1cclxuICAgIF9wcmVwYXJlRGF0YUl0ZW0oZGF0YUl0ZW0sIGZpbGxJbmRleCwgY291bnQpIHtcclxuICAgICAgICBsZXQgcmVuZGVyZXIgPSB0aGlzLmdldChcInJlbmRlcmVyXCIpO1xyXG4gICAgICAgIGxldCBjYXRlZ29yeUxvY2F0aW9uID0gZGF0YUl0ZW0uZ2V0KFwiY2F0ZWdvcnlMb2NhdGlvblwiLCAwKTtcclxuICAgICAgICBsZXQgZW5kQ2F0ZWdvcnlMb2NhdGlvbiA9IGRhdGFJdGVtLmdldChcImVuZENhdGVnb3J5TG9jYXRpb25cIiwgMSk7XHJcbiAgICAgICAgbGV0IGluZGV4ID0gZGF0YUl0ZW0uZ2V0KFwiaW5kZXhcIik7XHJcbiAgICAgICAgaWYgKCEkdHlwZS5pc051bWJlcihpbmRleCkpIHtcclxuICAgICAgICAgICAgaW5kZXggPSB0aGlzLmNhdGVnb3J5VG9JbmRleChkYXRhSXRlbS5nZXQoXCJjYXRlZ29yeVwiKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBwb3NpdGlvbiA9IHRoaXMuaW5kZXhUb1Bvc2l0aW9uKGluZGV4LCBjYXRlZ29yeUxvY2F0aW9uKTtcclxuICAgICAgICBsZXQgZW5kQ2F0ZWdvcnkgPSBkYXRhSXRlbS5nZXQoXCJlbmRDYXRlZ29yeVwiKTtcclxuICAgICAgICBsZXQgZW5kSW5kZXg7XHJcbiAgICAgICAgaWYgKGVuZENhdGVnb3J5KSB7XHJcbiAgICAgICAgICAgIGVuZEluZGV4ID0gdGhpcy5jYXRlZ29yeVRvSW5kZXgoZW5kQ2F0ZWdvcnkpO1xyXG4gICAgICAgICAgICBpZiAoISR0eXBlLmlzTnVtYmVyKGVuZEluZGV4KSkge1xyXG4gICAgICAgICAgICAgICAgZW5kSW5kZXggPSBpbmRleDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZW5kSW5kZXggPSBpbmRleDtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IGVuZFBvc2l0aW9uID0gdGhpcy5pbmRleFRvUG9zaXRpb24oZW5kSW5kZXgsIGVuZENhdGVnb3J5TG9jYXRpb24pO1xyXG4gICAgICAgIGxldCBmaWxsRW5kSW5kZXg7XHJcbiAgICAgICAgbGV0IGZpbGxFbmRQb3NpdGlvbjtcclxuICAgICAgICBpZiAoZGF0YUl0ZW0uZ2V0KFwiaXNSYW5nZVwiKSkge1xyXG4gICAgICAgICAgICBmaWxsRW5kSW5kZXggPSBlbmRJbmRleDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGZpbGxFbmRJbmRleCA9IGluZGV4ICsgdGhpcy5fZnJlcXVlbmN5IC0gMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZmlsbEVuZFBvc2l0aW9uID0gdGhpcy5pbmRleFRvUG9zaXRpb24oZmlsbEVuZEluZGV4LCBlbmRDYXRlZ29yeUxvY2F0aW9uKTtcclxuICAgICAgICByZW5kZXJlci51cGRhdGVMYWJlbChkYXRhSXRlbS5nZXQoXCJsYWJlbFwiKSwgcG9zaXRpb24sIGVuZFBvc2l0aW9uLCBjb3VudCk7XHJcbiAgICAgICAgcmVuZGVyZXIudXBkYXRlR3JpZChkYXRhSXRlbS5nZXQoXCJncmlkXCIpLCBwb3NpdGlvbiwgZW5kUG9zaXRpb24pO1xyXG4gICAgICAgIHJlbmRlcmVyLnVwZGF0ZVRpY2soZGF0YUl0ZW0uZ2V0KFwidGlja1wiKSwgcG9zaXRpb24sIGVuZFBvc2l0aW9uLCBjb3VudCk7XHJcbiAgICAgICAgcmVuZGVyZXIudXBkYXRlRmlsbChkYXRhSXRlbS5nZXQoXCJheGlzRmlsbFwiKSwgcG9zaXRpb24sIGZpbGxFbmRQb3NpdGlvbik7XHJcbiAgICAgICAgdGhpcy5fcHJvY2Vzc0J1bGxldChkYXRhSXRlbSk7XHJcbiAgICAgICAgcmVuZGVyZXIudXBkYXRlQnVsbGV0KGRhdGFJdGVtLmdldChcImJ1bGxldFwiKSwgcG9zaXRpb24sIGVuZFBvc2l0aW9uKTtcclxuICAgICAgICBjb25zdCBmaWxsUnVsZSA9IHRoaXMuZ2V0KFwiZmlsbFJ1bGVcIik7XHJcbiAgICAgICAgaWYgKGZpbGxSdWxlKSB7XHJcbiAgICAgICAgICAgIGZpbGxSdWxlKGRhdGFJdGVtLCBmaWxsSW5kZXgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHN0YXJ0SW5kZXgoKSB7XHJcbiAgICAgICAgbGV0IGxlbiA9IHRoaXMuZGF0YUl0ZW1zLmxlbmd0aDtcclxuICAgICAgICByZXR1cm4gTWF0aC5taW4oTWF0aC5tYXgodGhpcy5nZXRQcml2YXRlKFwic3RhcnRJbmRleFwiLCAwKSwgMCksIGxlbiAtIDEpO1xyXG4gICAgfVxyXG4gICAgZW5kSW5kZXgoKSB7XHJcbiAgICAgICAgbGV0IGxlbiA9IHRoaXMuZGF0YUl0ZW1zLmxlbmd0aDtcclxuICAgICAgICByZXR1cm4gTWF0aC5tYXgoMSwgTWF0aC5taW4odGhpcy5nZXRQcml2YXRlKFwiZW5kSW5kZXhcIiwgbGVuKSwgbGVuKSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEBpZ25vcmVcclxuICAgICAqL1xyXG4gICAgYmFzZVZhbHVlKCkge1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAaWdub3JlXHJcbiAgICAgKi9cclxuICAgIGJhc2VQb3NpdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gMDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBYIGNvb3JkaW5hdGUgaW4gcGl4ZWxzIGNvcnJlc3BvbmRpbmcgdG8gc3BlY2lmaWMgY2F0ZWdvcnkgaW5kZXguXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtICAgdmFsdWUgIEluZGV4XHJcbiAgICAgKiBAcmV0dXJuICAgICAgICAgWCBjb29yZGluYXRlXHJcbiAgICAgKi9cclxuICAgIGdldFgodmFsdWUpIHtcclxuICAgICAgICBsZXQgYXhpc0RhdGFJdGVtID0gdGhpcy5faXRlbU1hcFt2YWx1ZV07XHJcbiAgICAgICAgaWYgKGF4aXNEYXRhSXRlbSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc2V0dGluZ3MucmVuZGVyZXIucG9zaXRpb25Ub0Nvb3JkaW5hdGUodGhpcy5pbmRleFRvUG9zaXRpb24oYXhpc0RhdGFJdGVtLmdldChcImluZGV4XCIsIDApKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBOYU47XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgWSBjb29yZGluYXRlIGluIHBpeGVscyBjb3JyZXNwb25kaW5nIHRvIHNwZWNpZmljIGNhdGVnb3J5IGluZGV4LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSAgIHZhbHVlICBJbmRleFxyXG4gICAgICogQHJldHVybiAgICAgICAgIFkgY29vcmRpbmF0ZVxyXG4gICAgICovXHJcbiAgICBnZXRZKHZhbHVlKSB7XHJcbiAgICAgICAgbGV0IGF4aXNEYXRhSXRlbSA9IHRoaXMuX2l0ZW1NYXBbdmFsdWVdO1xyXG4gICAgICAgIGlmIChheGlzRGF0YUl0ZW0pIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NldHRpbmdzLnJlbmRlcmVyLnBvc2l0aW9uVG9Db29yZGluYXRlKHRoaXMuaW5kZXhUb1Bvc2l0aW9uKGF4aXNEYXRhSXRlbS5nZXQoXCJpbmRleFwiLCAwKSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gTmFOO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAaWdub3JlXHJcbiAgICAgKi9cclxuICAgIGdldERhdGFJdGVtUG9zaXRpb25YKGRhdGFJdGVtLCBmaWVsZCwgY2VsbExvY2F0aW9uLCBfYXhpc0xvY2F0aW9uKSB7XHJcbiAgICAgICAgY29uc3QgY2F0ZWdvcnkgPSBkYXRhSXRlbS5nZXQoZmllbGQpO1xyXG4gICAgICAgIGNvbnN0IGF4aXNEYXRhSXRlbSA9IHRoaXMuX2l0ZW1NYXBbY2F0ZWdvcnldO1xyXG4gICAgICAgIGlmIChheGlzRGF0YUl0ZW0pIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW5kZXhUb1Bvc2l0aW9uKGF4aXNEYXRhSXRlbS5nZXQoXCJpbmRleFwiLCAwKSwgY2VsbExvY2F0aW9uKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIE5hTjtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQGlnbm9yZVxyXG4gICAgICovXHJcbiAgICBnZXREYXRhSXRlbUNvb3JkaW5hdGVYKGRhdGFJdGVtLCBmaWVsZCwgY2VsbExvY2F0aW9uLCBfYXhpc0xvY2F0aW9uKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NldHRpbmdzLnJlbmRlcmVyLnBvc2l0aW9uVG9Db29yZGluYXRlKHRoaXMuZ2V0RGF0YUl0ZW1Qb3NpdGlvblgoZGF0YUl0ZW0sIGZpZWxkLCBjZWxsTG9jYXRpb24sIF9heGlzTG9jYXRpb24pKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQGlnbm9yZVxyXG4gICAgICovXHJcbiAgICBnZXREYXRhSXRlbVBvc2l0aW9uWShkYXRhSXRlbSwgZmllbGQsIGNlbGxMb2NhdGlvbiwgX2F4aXNMb2NhdGlvbikge1xyXG4gICAgICAgIGNvbnN0IGNhdGVnb3J5ID0gZGF0YUl0ZW0uZ2V0KGZpZWxkKTtcclxuICAgICAgICBjb25zdCBheGlzRGF0YUl0ZW0gPSB0aGlzLl9pdGVtTWFwW2NhdGVnb3J5XTtcclxuICAgICAgICBpZiAoYXhpc0RhdGFJdGVtKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmluZGV4VG9Qb3NpdGlvbihheGlzRGF0YUl0ZW0uZ2V0KFwiaW5kZXhcIiwgMCksIGNlbGxMb2NhdGlvbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBOYU47XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEBpZ25vcmVcclxuICAgICAqL1xyXG4gICAgZ2V0RGF0YUl0ZW1Db29yZGluYXRlWShkYXRhSXRlbSwgZmllbGQsIGNlbGxMb2NhdGlvbiwgX2F4aXNMb2NhdGlvbikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9zZXR0aW5ncy5yZW5kZXJlci5wb3NpdGlvblRvQ29vcmRpbmF0ZSh0aGlzLmdldERhdGFJdGVtUG9zaXRpb25ZKGRhdGFJdGVtLCBmaWVsZCwgY2VsbExvY2F0aW9uLCBfYXhpc0xvY2F0aW9uKSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENvbnZlcnRzIGNhdGVnb3J5IGluZGV4IHRvIGEgcmVsYXRpdmUgcG9zaXRpb24uXHJcbiAgICAgKlxyXG4gICAgICogYGxvY2F0aW9uYCBpbmRpY2F0ZXMgcmVsYXRpdmUgcG9zaXRpb24gd2l0aGluIGNhdGVnb3J5OiAwIC0gc3RhcnQsIDEgLSBlbmQuXHJcbiAgICAgKlxyXG4gICAgICogSWYgbm90IHNldCwgd2lsbCB1c2UgbWlkZGxlICgwLjUpIG9mIHRoZSBjYXRlZ29yeS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gICBpbmRleCAgICAgSW5kZXhcclxuICAgICAqIEBwYXJhbSAgIGxvY2F0aW9uICBMb2NhdGlvblxyXG4gICAgICogQHJldHVybiAgICAgICAgICAgIEluZGV4XHJcbiAgICAgKi9cclxuICAgIGluZGV4VG9Qb3NpdGlvbihpbmRleCwgbG9jYXRpb24pIHtcclxuICAgICAgICBpZiAoISR0eXBlLmlzTnVtYmVyKGxvY2F0aW9uKSkge1xyXG4gICAgICAgICAgICBsb2NhdGlvbiA9IDAuNTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IGxlbiA9IHRoaXMuZGF0YUl0ZW1zLmxlbmd0aDtcclxuICAgICAgICBsZXQgc3RhcnRMb2NhdGlvbiA9IHRoaXMuZ2V0KFwic3RhcnRMb2NhdGlvblwiLCAwKTtcclxuICAgICAgICBsZXQgZW5kTG9jYXRpb24gPSB0aGlzLmdldChcImVuZExvY2F0aW9uXCIsIDEpO1xyXG4gICAgICAgIGxlbiAtPSBzdGFydExvY2F0aW9uO1xyXG4gICAgICAgIGxlbiAtPSAoMSAtIGVuZExvY2F0aW9uKTtcclxuICAgICAgICBsZXQgcG9zaXRpb24gPSAoaW5kZXggKyBsb2NhdGlvbiAtIHN0YXJ0TG9jYXRpb24pIC8gbGVuO1xyXG4gICAgICAgIGxldCBkYXRhSXRlbSA9IHRoaXMuZGF0YUl0ZW1zW2luZGV4XTtcclxuICAgICAgICBpZiAoZGF0YUl0ZW0pIHtcclxuICAgICAgICAgICAgcG9zaXRpb24gKz0gZGF0YUl0ZW0uZ2V0KFwiZGVsdGFQb3NpdGlvblwiLCAwKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHBvc2l0aW9uO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGFuIGluZGV4IG9mIGEgY2F0ZWdvcnkuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtICAgY2F0ZWdvcnkgIENhdGVnb3J5IHRvIGxvb2sgdXBcclxuICAgICAqIEByZXR1cm4gICAgICAgICAgICBJbmRleFxyXG4gICAgICovXHJcbiAgICBjYXRlZ29yeVRvSW5kZXgoY2F0ZWdvcnkpIHtcclxuICAgICAgICBsZXQgZGF0YUl0ZW0gPSB0aGlzLl9pdGVtTWFwW2NhdGVnb3J5XTtcclxuICAgICAgICBpZiAoZGF0YUl0ZW0pIHtcclxuICAgICAgICAgICAgcmV0dXJuIGRhdGFJdGVtLmdldChcImluZGV4XCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gTmFOO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAaWdub3JlXHJcbiAgICAgKi9cclxuICAgIGRhdGFJdGVtVG9Qb3NpdGlvbihkYXRhSXRlbSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmluZGV4VG9Qb3NpdGlvbihkYXRhSXRlbS5nZXQoXCJpbmRleFwiKSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEBpZ25vcmVcclxuICAgICAqL1xyXG4gICAgcm91bmRBeGlzUG9zaXRpb24ocG9zaXRpb24sIGxvY2F0aW9uKSB7XHJcbiAgICAgICAgcG9zaXRpb24gKz0gKDAuNSAtIGxvY2F0aW9uKSAvIHRoaXMuZGF0YUl0ZW1zLmxlbmd0aDtcclxuICAgICAgICByZXR1cm4gdGhpcy5pbmRleFRvUG9zaXRpb24odGhpcy5heGlzUG9zaXRpb25Ub0luZGV4KHBvc2l0aW9uKSwgbG9jYXRpb24pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGFuIGluZGV4IG9mIHRoZSBjYXRlZ29yeSB0aGF0IGNvcnJlc3BvbmRzIHRvIHNwZWNpZmljIHBpeGVsXHJcbiAgICAgKiBwb3NpdGlvbiB3aXRoaW4gYXhpcy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gcG9zaXRpb24gIFBvc2l0aW9uIChweClcclxuICAgICAqIEByZXR1cm4gQ2F0ZWdvcnkgaW5kZXhcclxuICAgICAqL1xyXG4gICAgYXhpc1Bvc2l0aW9uVG9JbmRleChwb3NpdGlvbikge1xyXG4gICAgICAgIGxldCBsZW4gPSB0aGlzLmRhdGFJdGVtcy5sZW5ndGg7XHJcbiAgICAgICAgcmV0dXJuICRtYXRoLmZpdFRvUmFuZ2UoTWF0aC5mbG9vcihwb3NpdGlvbiAqIGxlbiksIDAsIGxlbiAtIDEpOyAvLyRtYXRoLmZpdFRvUmFuZ2UoTWF0aC5mbG9vcigoZW5kIC0gc3RhcnQpICogbGVuICogcG9zaXRpb24gKyBsZW4gKiBzdGFydCksIDAsIGxlbiAtIDEpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRleHQgdG8gYmUgdXNlZCBpbiBhbiBheGlzIHRvb2x0aXAgZm9yIHNwZWNpZmljIHJlbGF0aXZlIHBvc2l0aW9uLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSAgIHBvc2l0aW9uICBQb3NpdGlvblxyXG4gICAgICogQHJldHVybiAgICAgICAgICAgIFRvb2x0aXAgdGV4dFxyXG4gICAgICovXHJcbiAgICBnZXRUb29sdGlwVGV4dChwb3NpdGlvbiwgX2FkanVzdFBvc2l0aW9uKSB7XHJcbiAgICAgICAgLy9AdG9kbyBudW1iZXIgZm9ybWF0dGVyICsgdGFnXHJcbiAgICAgICAgY29uc3QgZGF0YUl0ZW0gPSB0aGlzLmRhdGFJdGVtc1t0aGlzLmF4aXNQb3NpdGlvblRvSW5kZXgocG9zaXRpb24pXTtcclxuICAgICAgICBpZiAoZGF0YUl0ZW0pIHtcclxuICAgICAgICAgICAgY29uc3QgbGFiZWwgPSBkYXRhSXRlbS5nZXQoXCJsYWJlbFwiKTtcclxuICAgICAgICAgICAgaWYgKGxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcG9wdWxhdGVTdHJpbmcobGFiZWwsIHRoaXMuZ2V0KFwidG9vbHRpcFRleHRcIiwgXCJcIikpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgX3VwZGF0ZVRvb2x0aXBUZXh0KHRvb2x0aXAsIHBvc2l0aW9uKSB7XHJcbiAgICAgICAgdG9vbHRpcC5fc2V0RGF0YUl0ZW0odGhpcy5kYXRhSXRlbXNbdGhpcy5heGlzUG9zaXRpb25Ub0luZGV4KHBvc2l0aW9uKV0pO1xyXG4gICAgICAgIHRvb2x0aXAubGFiZWwudGV4dC5tYXJrRGlydHlUZXh0KCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBkYXRhIGl0ZW0gZnJvbSBzZXJpZXMgdGhhdCBpcyBjbG9zZXN0IHRvIHRoZSBgcG9zaXRpb25gLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSAgIHNlcmllcyAgICBTZXJpZXNcclxuICAgICAqIEBwYXJhbSAgIHBvc2l0aW9uICBSZWxhdGl2ZSBwb3NpdGlvblxyXG4gICAgICogQHJldHVybiAgICAgICAgICAgIERhdGEgaXRlbVxyXG4gICAgICovXHJcbiAgICBnZXRTZXJpZXNJdGVtKHNlcmllcywgcG9zaXRpb24pIHtcclxuICAgICAgICBpZiAodGhpcy5kYXRhSXRlbXMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICBsZXQgZmllbGROYW1lID0gKHRoaXMuZ2V0UHJpdmF0ZShcIm5hbWVcIikgKyB0aGlzLmdldChcInJlbmRlcmVyXCIpLmdldFByaXZhdGUoXCJsZXR0ZXJcIikpO1xyXG4gICAgICAgICAgICBsZXQgaW5kZXggPSB0aGlzLmF4aXNQb3NpdGlvblRvSW5kZXgocG9zaXRpb24pO1xyXG4gICAgICAgICAgICAvLyB0cnkgc2ltcGxlIGZpcnN0XHJcbiAgICAgICAgICAgIGxldCBzZXJpZXNEYXRhSXRlbSA9IHNlcmllcy5kYXRhSXRlbXNbaW5kZXhdO1xyXG4gICAgICAgICAgICBsZXQgYXhpc0RhdGFJdGVtID0gdGhpcy5kYXRhSXRlbXNbaW5kZXhdO1xyXG4gICAgICAgICAgICBsZXQgY2F0ZWdvcnkgPSBheGlzRGF0YUl0ZW0uZ2V0KFwiY2F0ZWdvcnlcIik7XHJcbiAgICAgICAgICAgIGlmIChzZXJpZXNEYXRhSXRlbSAmJiBheGlzRGF0YUl0ZW0pIHtcclxuICAgICAgICAgICAgICAgIGlmIChzZXJpZXNEYXRhSXRlbS5nZXQoZmllbGROYW1lKSA9PT0gY2F0ZWdvcnkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VyaWVzRGF0YUl0ZW07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gaWYgbm90IGZvdW5kLCB0cnkgbG9va2luZ1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gc2VyaWVzLmRhdGFJdGVtcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgbGV0IGRhdGFJdGVtID0gc2VyaWVzLmRhdGFJdGVtc1tpXTtcclxuICAgICAgICAgICAgICAgIGlmIChkYXRhSXRlbS5nZXQoZmllbGROYW1lKSA9PT0gY2F0ZWdvcnkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGF0YUl0ZW07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFpvb21zIHRoZSBheGlzIHRvIHNwZWNpZmljIGBzdGFydGAgYW5kIGBlbmRgIGluZGV4ZXMuXHJcbiAgICAgKlxyXG4gICAgICogT3B0aW9uYWwgYGR1cmF0aW9uYCBzcGVjaWZpZXMgZHVyYXRpb24gb2Ygem9vbSBhbmltYXRpb24gaW4gbWlsbGlzZWNvbmRzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSAgc3RhcnQgICAgIFN0YXJ0IGluZGV4XHJcbiAgICAgKiBAcGFyYW0gIGVuZCAgICAgICBFbmQgaW5kZXhcclxuICAgICAqIEBwYXJhbSAgZHVyYXRpb24gIER1cmF0aW9uIGluIG1pbGxpc2Vjb25kc1xyXG4gICAgICovXHJcbiAgICB6b29tVG9JbmRleGVzKHN0YXJ0LCBlbmQsIGR1cmF0aW9uKSB7XHJcbiAgICAgICAgbGV0IGxlbiA9IHRoaXMuZGF0YUl0ZW1zLmxlbmd0aDtcclxuICAgICAgICB0aGlzLnpvb20oc3RhcnQgLyBsZW4sIGVuZCAvIGxlbiwgZHVyYXRpb24pO1xyXG4gICAgfVxyXG4gICAgem9vbVRvQ2F0ZWdvcmllcyhzdGFydENhdGVnb3J5LCBlbmRDYXRlZ29yeSwgZHVyYXRpb24pIHtcclxuICAgICAgICB0aGlzLnpvb21Ub0luZGV4ZXModGhpcy5jYXRlZ29yeVRvSW5kZXgoc3RhcnRDYXRlZ29yeSksIHRoaXMuY2F0ZWdvcnlUb0luZGV4KGVuZENhdGVnb3J5KSArIDEsIGR1cmF0aW9uKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBwb3NpdGlvbiBzcGFuIGJldHdlZW4gc3RhcnQgYW5kIGVuZCBvZiBhIHNpbmdsZSBjZWxsIGluIGF4aXMuXHJcbiAgICAgKlxyXG4gICAgICogQHNpbmNlIDUuMi4zMFxyXG4gICAgICogQHJldHVybiBQb3NpdGlvblxyXG4gICAgICovXHJcbiAgICBnZXRDZWxsV2lkdGhQb3NpdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZnJlcXVlbmN5IC8gdGhpcy5kYXRhSXRlbXMubGVuZ3RoIC8gKHRoaXMuZ2V0KFwiZW5kXCIsIDEpIC0gdGhpcy5nZXQoXCJzdGFydFwiLCAwKSk7XHJcbiAgICB9XHJcbn1cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KENhdGVnb3J5QXhpcywgXCJjbGFzc05hbWVcIiwge1xyXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgdmFsdWU6IFwiQ2F0ZWdvcnlBeGlzXCJcclxufSk7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShDYXRlZ29yeUF4aXMsIFwiY2xhc3NOYW1lc1wiLCB7XHJcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICB2YWx1ZTogQXhpcy5jbGFzc05hbWVzLmNvbmNhdChbQ2F0ZWdvcnlBeGlzLmNsYXNzTmFtZV0pXHJcbn0pO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1DYXRlZ29yeUF4aXMuanMubWFwIiwiaW1wb3J0IHsgR3JhcGhpY3MgfSBmcm9tIFwiLi4vLi4vLi4vY29yZS9yZW5kZXIvR3JhcGhpY3NcIjtcclxuLyoqXHJcbiAqIENyZWF0ZXMgYW4gYXhpcyBncmlkIGxpbmUuXHJcbiAqXHJcbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vd3d3LmFtY2hhcnRzLmNvbS9kb2NzL3Y1L2NoYXJ0cy94eS1jaGFydC9heGVzLyNHcmlkfSBmb3IgbW9yZSBpbmZvXHJcbiAqIEBpbXBvcnRhbnRcclxuICovXHJcbmV4cG9ydCBjbGFzcyBHcmlkIGV4dGVuZHMgR3JhcGhpY3Mge1xyXG4gICAgX2JlZm9yZUNoYW5nZWQoKSB7XHJcbiAgICAgICAgc3VwZXIuX2JlZm9yZUNoYW5nZWQoKTtcclxuICAgICAgICBpZiAodGhpcy5pc1ByaXZhdGVEaXJ0eShcIndpZHRoXCIpIHx8IHRoaXMuaXNQcml2YXRlRGlydHkoXCJoZWlnaHRcIikpIHtcclxuICAgICAgICAgICAgdGhpcy5fY2xlYXIgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoR3JpZCwgXCJjbGFzc05hbWVcIiwge1xyXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgdmFsdWU6IFwiR3JpZFwiXHJcbn0pO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoR3JpZCwgXCJjbGFzc05hbWVzXCIsIHtcclxuICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgIHZhbHVlOiBHcmFwaGljcy5jbGFzc05hbWVzLmNvbmNhdChbR3JpZC5jbGFzc05hbWVdKVxyXG59KTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9R3JpZC5qcy5tYXAiLCJpbXBvcnQgeyBEYXRhSXRlbSB9IGZyb20gXCIuLi8uLi8uLi9jb3JlL3JlbmRlci9Db21wb25lbnRcIjtcclxuaW1wb3J0IHsgQXhpcyB9IGZyb20gXCIuL0F4aXNcIjtcclxuaW1wb3J0IHsgTXVsdGlEaXNwb3NlciB9IGZyb20gXCIuLi8uLi8uLi9jb3JlL3V0aWwvRGlzcG9zZXJcIjtcclxuaW1wb3J0ICogYXMgJHR5cGUgZnJvbSBcIi4uLy4uLy4uL2NvcmUvdXRpbC9UeXBlXCI7XHJcbmltcG9ydCAqIGFzICRhcnJheSBmcm9tIFwiLi4vLi4vLi4vY29yZS91dGlsL0FycmF5XCI7XHJcbmltcG9ydCAqIGFzICRtYXRoIGZyb20gXCIuLi8uLi8uLi9jb3JlL3V0aWwvTWF0aFwiO1xyXG5pbXBvcnQgKiBhcyAkdXRpbHMgZnJvbSBcIi4uLy4uLy4uL2NvcmUvdXRpbC9VdGlsc1wiO1xyXG4vKipcclxuICogQ3JlYXRlcyBhIHZhbHVlIGF4aXMuXHJcbiAqXHJcbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vd3d3LmFtY2hhcnRzLmNvbS9kb2NzL3Y1L2NoYXJ0cy94eS1jaGFydC9heGVzL3ZhbHVlLWF4aXMvfSBmb3IgbW9yZSBpbmZvXHJcbiAqIEBpbXBvcnRhbnRcclxuICovXHJcbmV4cG9ydCBjbGFzcyBWYWx1ZUF4aXMgZXh0ZW5kcyBBeGlzIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX2RpcnR5RXh0cmVtZXNcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogZmFsc2VcclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfZGlydHlTZWxlY3Rpb25FeHRyZW1lc1wiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiBmYWxzZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9kZWx0YU1pbk1heFwiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiAxXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX21pblJlYWxcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX21heFJlYWxcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX2Jhc2VWYWx1ZVwiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiAwXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX3N5bmNEcFwiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfbWluTG9nQWRqdXN0ZWRcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogMVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAaWdub3JlXHJcbiAgICAgKi9cclxuICAgIG1hcmtEaXJ0eUV4dHJlbWVzKCkge1xyXG4gICAgICAgIHRoaXMuX2RpcnR5RXh0cmVtZXMgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMubWFya0RpcnR5KCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEBpZ25vcmVcclxuICAgICAqL1xyXG4gICAgbWFya0RpcnR5U2VsZWN0aW9uRXh0cmVtZXMoKSB7XHJcbiAgICAgICAgdGhpcy5fZGlydHlTZWxlY3Rpb25FeHRyZW1lcyA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5tYXJrRGlydHkoKTtcclxuICAgIH1cclxuICAgIF9hZnRlck5ldygpIHtcclxuICAgICAgICB0aGlzLl9zZXR0aW5ncy50aGVtZVRhZ3MgPSAkdXRpbHMubWVyZ2VUYWdzKHRoaXMuX3NldHRpbmdzLnRoZW1lVGFncywgW1wiYXhpc1wiXSk7XHJcbiAgICAgICAgdGhpcy5zZXRQcml2YXRlUmF3KFwibmFtZVwiLCBcInZhbHVlXCIpO1xyXG4gICAgICAgIHRoaXMuYWRkVGFnKFwidmFsdWVcIik7XHJcbiAgICAgICAgc3VwZXIuX2FmdGVyTmV3KCk7XHJcbiAgICB9XHJcbiAgICBfcHJlcGFyZUNoaWxkcmVuKCkge1xyXG4gICAgICAgIHN1cGVyLl9wcmVwYXJlQ2hpbGRyZW4oKTtcclxuICAgICAgICBpZiAodGhpcy5pc0RpcnR5KFwic3luY1dpdGhBeGlzXCIpKSB7XHJcbiAgICAgICAgICAgIGxldCBwcmV2aW91c1ZhbHVlID0gdGhpcy5fcHJldlNldHRpbmdzLnN5bmNXaXRoQXhpcztcclxuICAgICAgICAgICAgaWYgKHByZXZpb3VzVmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9zeW5jRHApIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zeW5jRHAuZGlzcG9zZSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGxldCBzeW5jV2l0aEF4aXMgPSB0aGlzLmdldChcInN5bmNXaXRoQXhpc1wiKTtcclxuICAgICAgICAgICAgaWYgKHN5bmNXaXRoQXhpcykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc3luY0RwID0gbmV3IE11bHRpRGlzcG9zZXIoW1xyXG4gICAgICAgICAgICAgICAgICAgIHN5bmNXaXRoQXhpcy5vblByaXZhdGUoXCJzZWxlY3Rpb25NaW5GaW5hbFwiLCAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2RpcnR5U2VsZWN0aW9uRXh0cmVtZXMgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pLFxyXG4gICAgICAgICAgICAgICAgICAgIHN5bmNXaXRoQXhpcy5vblByaXZhdGUoXCJzZWxlY3Rpb25NYXhGaW5hbFwiLCAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2RpcnR5U2VsZWN0aW9uRXh0cmVtZXMgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICBdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgc29tZURpcnR5ID0gZmFsc2U7XHJcbiAgICAgICAgaWYgKHRoaXMuaXNEaXJ0eShcIm1pblwiKSB8fCB0aGlzLmlzRGlydHkoXCJtYXhcIikgfHwgdGhpcy5pc0RpcnR5KFwibWF4UHJlY2lzaW9uXCIpIHx8IHRoaXMuaXNEaXJ0eShcIm51bWJlckZvcm1hdFwiKSkge1xyXG4gICAgICAgICAgICBzb21lRGlydHkgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLmdob3N0TGFiZWwuc2V0KFwidGV4dFwiLCBcIlwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy9pZiAodGhpcy5fZGlydHlFeHRyZW1lcyB8fCB0aGlzLmlzUHJpdmF0ZURpcnR5KFwid2lkdGhcIikgfHwgdGhpcy5pc1ByaXZhdGVEaXJ0eShcImhlaWdodFwiKSB8fCB0aGlzLmlzRGlydHkoXCJtaW5cIikgfHwgdGhpcy5pc0RpcnR5KFwibWF4XCIpIHx8IHRoaXMuaXNEaXJ0eShcImV4dHJhTWluXCIpIHx8IHRoaXMuaXNEaXJ0eShcImV4dHJhTWF4XCIpIHx8IHRoaXMuaXNEaXJ0eShcImxvZ2FyaXRobWljXCIpIHx8IHRoaXMuaXNEaXJ0eShcInRyZWF0WmVyb0FzXCIpIHx8IHRoaXMuaXNEaXJ0eShcImJhc2VWYWx1ZVwiKSB8fCB0aGlzLmlzRGlydHkoXCJzdHJpY3RNaW5NYXhcIikgfHwgdGhpcy5pc0RpcnR5KFwibWF4UHJlY2lzaW9uXCIpKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX3NpemVEaXJ0eSB8fCB0aGlzLl9kaXJ0eUV4dHJlbWVzIHx8IHRoaXMuX3ZhbHVlc0RpcnR5IHx8IHNvbWVEaXJ0eSB8fCB0aGlzLmlzUHJpdmF0ZURpcnR5KFwid2lkdGhcIikgfHwgdGhpcy5pc1ByaXZhdGVEaXJ0eShcImhlaWdodFwiKSB8fCB0aGlzLmlzRGlydHkoXCJleHRyYU1pblwiKSB8fCB0aGlzLmlzRGlydHkoXCJleHRyYU1heFwiKSB8fCB0aGlzLmlzRGlydHkoXCJsb2dhcml0aG1pY1wiKSB8fCB0aGlzLmlzRGlydHkoXCJ0cmVhdFplcm9Bc1wiKSB8fCB0aGlzLmlzRGlydHkoXCJiYXNlVmFsdWVcIikgfHwgdGhpcy5pc0RpcnR5KFwic3RyaWN0TWluTWF4XCIpIHx8IHRoaXMuaXNEaXJ0eShcInN0cmljdE1pbk1heFNlbGVjdGlvblwiKSkge1xyXG4gICAgICAgICAgICB0aGlzLl9nZXRNaW5NYXgoKTtcclxuICAgICAgICAgICAgdGhpcy5fZGlydHlFeHRyZW1lcyA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5fZGlydHlTZWxlY3Rpb25FeHRyZW1lcyAmJiAhdGhpcy5faXNQYW5uaW5nICYmIHRoaXMuZ2V0KFwiYXV0b1pvb21cIiwgdHJ1ZSkpIHtcclxuICAgICAgICAgICAgdGhpcy5fZ2V0U2VsZWN0aW9uTWluTWF4KCk7XHJcbiAgICAgICAgICAgIHRoaXMuX2RpcnR5U2VsZWN0aW9uRXh0cmVtZXMgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fZ3JvdXBEYXRhKCk7XHJcbiAgICAgICAgaWYgKHRoaXMuX3NpemVEaXJ0eSB8fCB0aGlzLl92YWx1ZXNEaXJ0eSB8fCB0aGlzLmlzRGlydHkoXCJzdGFydFwiKSB8fCB0aGlzLmlzRGlydHkoXCJlbmRcIikgfHwgdGhpcy5pc1ByaXZhdGVEaXJ0eShcIm1pblwiKSB8fCB0aGlzLmlzUHJpdmF0ZURpcnR5KFwic2VsZWN0aW9uTWF4XCIpIHx8IHRoaXMuaXNQcml2YXRlRGlydHkoXCJzZWxlY3Rpb25NaW5cIikgfHwgdGhpcy5pc1ByaXZhdGVEaXJ0eShcIm1heFwiKSB8fCB0aGlzLmlzUHJpdmF0ZURpcnR5KFwic3RlcFwiKSB8fCB0aGlzLmlzUHJpdmF0ZURpcnR5KFwid2lkdGhcIikgfHwgdGhpcy5pc1ByaXZhdGVEaXJ0eShcImhlaWdodFwiKSB8fCB0aGlzLmlzRGlydHkoXCJsb2dhcml0aG1pY1wiKSkge1xyXG4gICAgICAgICAgICB0aGlzLl9oYW5kbGVSYW5nZUNoYW5nZSgpO1xyXG4gICAgICAgICAgICB0aGlzLl9wcmVwYXJlQXhpc0l0ZW1zKCk7XHJcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZUF4aXNSYW5nZXMoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fYmFzZVZhbHVlID0gdGhpcy5iYXNlVmFsdWUoKTtcclxuICAgIH1cclxuICAgIF9ncm91cERhdGEoKSB7XHJcbiAgICB9XHJcbiAgICBfZm9ybWF0VGV4dCh2YWx1ZSkge1xyXG4gICAgICAgIGNvbnN0IG51bWJlckZvcm1hdCA9IHRoaXMuZ2V0KFwibnVtYmVyRm9ybWF0XCIpO1xyXG4gICAgICAgIGNvbnN0IGZvcm1hdHRlciA9IHRoaXMuZ2V0TnVtYmVyRm9ybWF0dGVyKCk7XHJcbiAgICAgICAgbGV0IHRleHQgPSBcIlwiO1xyXG4gICAgICAgIGlmIChudW1iZXJGb3JtYXQpIHtcclxuICAgICAgICAgICAgdGV4dCA9IGZvcm1hdHRlci5mb3JtYXQodmFsdWUsIG51bWJlckZvcm1hdCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0ZXh0ID0gZm9ybWF0dGVyLmZvcm1hdCh2YWx1ZSwgdW5kZWZpbmVkLCB0aGlzLmdldFByaXZhdGUoXCJzdGVwRGVjaW1hbFBsYWNlc1wiKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0ZXh0O1xyXG4gICAgfVxyXG4gICAgX3ByZXBhcmVBeGlzSXRlbXMoKSB7XHJcbiAgICAgICAgY29uc3QgbWluID0gdGhpcy5nZXRQcml2YXRlKFwibWluXCIpO1xyXG4gICAgICAgIGNvbnN0IG1heCA9IHRoaXMuZ2V0UHJpdmF0ZShcIm1heFwiKTtcclxuICAgICAgICBpZiAoJHR5cGUuaXNOdW1iZXIobWluKSAmJiAkdHlwZS5pc051bWJlcihtYXgpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGxvZ2FyaXRobWljID0gdGhpcy5nZXQoXCJsb2dhcml0aG1pY1wiKTtcclxuICAgICAgICAgICAgY29uc3Qgc3RlcCA9IHRoaXMuZ2V0UHJpdmF0ZShcInN0ZXBcIik7XHJcbiAgICAgICAgICAgIGNvbnN0IHNlbGVjdGlvbk1pbiA9IHRoaXMuZ2V0UHJpdmF0ZShcInNlbGVjdGlvbk1pblwiKTtcclxuICAgICAgICAgICAgY29uc3Qgc2VsZWN0aW9uTWF4ID0gdGhpcy5nZXRQcml2YXRlKFwic2VsZWN0aW9uTWF4XCIpICsgc3RlcDtcclxuICAgICAgICAgICAgbGV0IHZhbHVlID0gc2VsZWN0aW9uTWluIC0gc3RlcDtcclxuICAgICAgICAgICAgbGV0IGRpZmZlcmVuY2VQb3dlciA9IDE7XHJcbiAgICAgICAgICAgIGxldCBtaW5Mb2cgPSBtaW47XHJcbiAgICAgICAgICAgIGlmIChsb2dhcml0aG1pYykge1xyXG4gICAgICAgICAgICAgICAgdmFsdWUgPSB0aGlzLl9taW5Mb2dBZGp1c3RlZDtcclxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA8IHNlbGVjdGlvbk1pbikge1xyXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlICh2YWx1ZSA8IHNlbGVjdGlvbk1pbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSArPSBzdGVwO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIG1pbkxvZyA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgaWYgKG1pbkxvZyA8PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWluTG9nID0gMTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc3RlcCA8IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWluTG9nID0gc3RlcDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBkaWZmZXJlbmNlUG93ZXIgPSBNYXRoLmxvZyhzZWxlY3Rpb25NYXggLSBzdGVwKSAqIE1hdGguTE9HMTBFIC0gTWF0aC5sb2cobWluTG9nKSAqIE1hdGguTE9HMTBFO1xyXG4gICAgICAgICAgICAgICAgaWYgKGRpZmZlcmVuY2VQb3dlciA+IDIpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IE1hdGgucG93KDEwLCBNYXRoLmxvZyhtaW5Mb2cpICogTWF0aC5MT0cxMEUgLSA1KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLy8gbWlub3IgZ3JpZFxyXG4gICAgICAgICAgICBjb25zdCByZW5kZXJlciA9IHRoaXMuZ2V0KFwicmVuZGVyZXJcIik7XHJcbiAgICAgICAgICAgIGNvbnN0IG1pbm9yTGFiZWxzRW5hYmxlZCA9IHJlbmRlcmVyLmdldChcIm1pbm9yTGFiZWxzRW5hYmxlZFwiKTtcclxuICAgICAgICAgICAgY29uc3QgbWlub3JHcmlkRW5hYmxlZCA9IHJlbmRlcmVyLmdldChcIm1pbm9yR3JpZEVuYWJsZWRcIiwgbWlub3JMYWJlbHNFbmFibGVkKTtcclxuICAgICAgICAgICAgbGV0IHN0ZXBQb3dlciA9IE1hdGgucG93KDEwLCBNYXRoLmZsb29yKE1hdGgubG9nKE1hdGguYWJzKHN0ZXApKSAqIE1hdGguTE9HMTBFKSk7XHJcbiAgICAgICAgICAgIGNvbnN0IHN0ZXBBZGp1c3RlZCA9IE1hdGgucm91bmQoc3RlcCAvIHN0ZXBQb3dlcik7XHJcbiAgICAgICAgICAgIGxldCBtaW5vckdyaWRDb3VudCA9IDI7XHJcbiAgICAgICAgICAgIGlmICgkbWF0aC5yb3VuZChzdGVwQWRqdXN0ZWQgLyA1LCAxMCkgJSAxID09IDApIHtcclxuICAgICAgICAgICAgICAgIG1pbm9yR3JpZENvdW50ID0gNTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoJG1hdGgucm91bmQoc3RlcEFkanVzdGVkIC8gMTAsIDEwKSAlIDEgPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgbWlub3JHcmlkQ291bnQgPSAxMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsZXQgbWlub3JTdGVwID0gc3RlcCAvIG1pbm9yR3JpZENvdW50O1xyXG4gICAgICAgICAgICAvLyBlbmQgb2YgbWlub3IgZ3JpZFxyXG4gICAgICAgICAgICBsZXQgaSA9IDA7XHJcbiAgICAgICAgICAgIGxldCBtID0gMDtcclxuICAgICAgICAgICAgbGV0IHByZXZpb3VzID0gLUluZmluaXR5O1xyXG4gICAgICAgICAgICB3aGlsZSAodmFsdWUgPCBzZWxlY3Rpb25NYXgpIHtcclxuICAgICAgICAgICAgICAgIGxldCBkYXRhSXRlbTtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmRhdGFJdGVtcy5sZW5ndGggPCBpICsgMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRhdGFJdGVtID0gbmV3IERhdGFJdGVtKHRoaXMsIHVuZGVmaW5lZCwge30pO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RhdGFJdGVtcy5wdXNoKGRhdGFJdGVtKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnByb2Nlc3NEYXRhSXRlbShkYXRhSXRlbSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBkYXRhSXRlbSA9IHRoaXMuZGF0YUl0ZW1zW2ldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5fY3JlYXRlQXNzZXRzKGRhdGFJdGVtLCBbXSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl90b2dnbGVEYXRhSXRlbShkYXRhSXRlbSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICBkYXRhSXRlbS5zZXRSYXcoXCJ2YWx1ZVwiLCB2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBsYWJlbCA9IGRhdGFJdGVtLmdldChcImxhYmVsXCIpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGFiZWwuc2V0KFwidGV4dFwiLCB0aGlzLl9mb3JtYXRUZXh0KHZhbHVlKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9wcmVwYXJlRGF0YUl0ZW0oZGF0YUl0ZW0pO1xyXG4gICAgICAgICAgICAgICAgbGV0IG5leHRWYWx1ZSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFsb2dhcml0aG1pYykge1xyXG4gICAgICAgICAgICAgICAgICAgIG5leHRWYWx1ZSArPSBzdGVwO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRpZmZlcmVuY2VQb3dlciA+IDIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dFZhbHVlID0gTWF0aC5wb3coMTAsIE1hdGgubG9nKG1pbkxvZykgKiBNYXRoLkxPRzEwRSArIGkgLSA1KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHRWYWx1ZSArPSBzdGVwO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIG1pbm9yIGdyaWRcclxuICAgICAgICAgICAgICAgIGlmIChtaW5vckdyaWRFbmFibGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IG1pbm9yVmFsdWUgPSB2YWx1ZSArIG1pbm9yU3RlcDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobG9nYXJpdGhtaWMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRpZmZlcmVuY2VQb3dlciA+IDIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBtaW5vck1pbk1heFN0ZXAgPSB0aGlzLl9hZGp1c3RNaW5NYXgodmFsdWUsIG5leHRWYWx1ZSwgMTApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWlub3JTdGVwID0gbWlub3JNaW5NYXhTdGVwLnN0ZXA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgbWlub3JWYWx1ZSA9IHZhbHVlICsgbWlub3JTdGVwO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAobWlub3JWYWx1ZSA8IG5leHRWYWx1ZSAtIHN0ZXAgKiAwLjAwMDAwMDAwMDAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBtaW5vckRhdGFJdGVtO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5taW5vckRhdGFJdGVtcy5sZW5ndGggPCBtICsgMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWlub3JEYXRhSXRlbSA9IG5ldyBEYXRhSXRlbSh0aGlzLCB1bmRlZmluZWQsIHt9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubWlub3JEYXRhSXRlbXMucHVzaChtaW5vckRhdGFJdGVtKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucHJvY2Vzc0RhdGFJdGVtKG1pbm9yRGF0YUl0ZW0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWlub3JEYXRhSXRlbSA9IHRoaXMubWlub3JEYXRhSXRlbXNbbV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY3JlYXRlQXNzZXRzKG1pbm9yRGF0YUl0ZW0sIFtcIm1pbm9yXCJdLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fdG9nZ2xlRGF0YUl0ZW0obWlub3JEYXRhSXRlbSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pbm9yRGF0YUl0ZW0uc2V0UmF3KFwidmFsdWVcIiwgbWlub3JWYWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG1pbm9yTGFiZWwgPSBtaW5vckRhdGFJdGVtLmdldChcImxhYmVsXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWlub3JMYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1pbm9yTGFiZWxzRW5hYmxlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pbm9yTGFiZWwuc2V0KFwidGV4dFwiLCB0aGlzLl9mb3JtYXRUZXh0KG1pbm9yVmFsdWUpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pbm9yTGFiZWwuc2V0UHJpdmF0ZShcInZpc2libGVcIiwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3ByZXBhcmVEYXRhSXRlbShtaW5vckRhdGFJdGVtKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWlub3JWYWx1ZSArPSBtaW5vclN0ZXA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG0rKztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IG5leHRWYWx1ZTtcclxuICAgICAgICAgICAgICAgIGlmIChwcmV2aW91cyA9PSB2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgbGV0IHN0ZXBQb3dlciA9IE1hdGgucG93KDEwLCBNYXRoLmZsb29yKE1hdGgubG9nKE1hdGguYWJzKHN0ZXApKSAqIE1hdGguTE9HMTBFKSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoc3RlcFBvd2VyIDwgMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGV4cG9uZW50IGlzIGxlc3MgdGhlbiAxIHRvby4gQ291bnQgZGVjaW1hbHMgb2YgZXhwb25lbnRcclxuICAgICAgICAgICAgICAgICAgICBsZXQgZGVjQ291bnQgPSBNYXRoLnJvdW5kKE1hdGguYWJzKE1hdGgubG9nKE1hdGguYWJzKHN0ZXBQb3dlcikpICogTWF0aC5MT0cxMEUpKSArIDI7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gcm91bmQgdmFsdWUgdG8gYXZvaWQgZmxvYXRpbmcgcG9pbnQgaXNzdWVzXHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSAkbWF0aC5yb3VuZCh2YWx1ZSwgZGVjQ291bnQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaSsrO1xyXG4gICAgICAgICAgICAgICAgcHJldmlvdXMgPSB2YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmb3IgKGxldCBqID0gaTsgaiA8IHRoaXMuZGF0YUl0ZW1zLmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl90b2dnbGVEYXRhSXRlbSh0aGlzLmRhdGFJdGVtc1tqXSwgZmFsc2UpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZvciAobGV0IGogPSBtOyBqIDwgdGhpcy5taW5vckRhdGFJdGVtcy5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fdG9nZ2xlRGF0YUl0ZW0odGhpcy5taW5vckRhdGFJdGVtc1tqXSwgZmFsc2UpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICRhcnJheS5lYWNoKHRoaXMuc2VyaWVzLCAoc2VyaWVzKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoc2VyaWVzLmluaXRlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNlcmllcy5fbWFya0RpcnR5QXhlcygpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgdGhpcy5fdXBkYXRlR2hvc3QoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBfcHJlcGFyZURhdGFJdGVtKGRhdGFJdGVtLCBjb3VudCkge1xyXG4gICAgICAgIGxldCByZW5kZXJlciA9IHRoaXMuZ2V0KFwicmVuZGVyZXJcIik7XHJcbiAgICAgICAgbGV0IHZhbHVlID0gZGF0YUl0ZW0uZ2V0KFwidmFsdWVcIik7XHJcbiAgICAgICAgbGV0IGVuZFZhbHVlID0gZGF0YUl0ZW0uZ2V0KFwiZW5kVmFsdWVcIik7XHJcbiAgICAgICAgbGV0IHBvc2l0aW9uID0gdGhpcy52YWx1ZVRvUG9zaXRpb24odmFsdWUpO1xyXG4gICAgICAgIGxldCBlbmRQb3NpdGlvbiA9IHBvc2l0aW9uO1xyXG4gICAgICAgIGxldCBmaWxsRW5kUG9zaXRpb24gPSB0aGlzLnZhbHVlVG9Qb3NpdGlvbih2YWx1ZSArIHRoaXMuZ2V0UHJpdmF0ZShcInN0ZXBcIikpO1xyXG4gICAgICAgIGlmICgkdHlwZS5pc051bWJlcihlbmRWYWx1ZSkpIHtcclxuICAgICAgICAgICAgZW5kUG9zaXRpb24gPSB0aGlzLnZhbHVlVG9Qb3NpdGlvbihlbmRWYWx1ZSk7XHJcbiAgICAgICAgICAgIGZpbGxFbmRQb3NpdGlvbiA9IGVuZFBvc2l0aW9uO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZGF0YUl0ZW0uZ2V0KFwiaXNSYW5nZVwiKSkge1xyXG4gICAgICAgICAgICBpZiAoZW5kVmFsdWUgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgZmlsbEVuZFBvc2l0aW9uID0gcG9zaXRpb247XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IGxhYmVsRW5kUG9zaXRpb24gPSBlbmRQb3NpdGlvbjtcclxuICAgICAgICBsZXQgbGFiZWxFbmRWYWx1ZSA9IGRhdGFJdGVtLmdldChcImxhYmVsRW5kVmFsdWVcIik7XHJcbiAgICAgICAgaWYgKGxhYmVsRW5kVmFsdWUgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICBsYWJlbEVuZFBvc2l0aW9uID0gdGhpcy52YWx1ZVRvUG9zaXRpb24obGFiZWxFbmRWYWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlbmRlcmVyLnVwZGF0ZUxhYmVsKGRhdGFJdGVtLmdldChcImxhYmVsXCIpLCBwb3NpdGlvbiwgbGFiZWxFbmRQb3NpdGlvbiwgY291bnQpO1xyXG4gICAgICAgIGNvbnN0IGdyaWQgPSBkYXRhSXRlbS5nZXQoXCJncmlkXCIpO1xyXG4gICAgICAgIHJlbmRlcmVyLnVwZGF0ZUdyaWQoZ3JpZCwgcG9zaXRpb24sIGVuZFBvc2l0aW9uKTtcclxuICAgICAgICBpZiAoZ3JpZCkge1xyXG4gICAgICAgICAgICBpZiAodmFsdWUgPT0gdGhpcy5nZXQoXCJiYXNlVmFsdWVcIiwgMCkpIHtcclxuICAgICAgICAgICAgICAgIGdyaWQuYWRkVGFnKFwiYmFzZVwiKTtcclxuICAgICAgICAgICAgICAgIGdyaWQuX2FwcGx5VGhlbWVzKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoZ3JpZC5oYXNUYWcoXCJiYXNlXCIpKSB7XHJcbiAgICAgICAgICAgICAgICBncmlkLnJlbW92ZVRhZyhcImJhc2VcIik7XHJcbiAgICAgICAgICAgICAgICBncmlkLl9hcHBseVRoZW1lcygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlbmRlcmVyLnVwZGF0ZVRpY2soZGF0YUl0ZW0uZ2V0KFwidGlja1wiKSwgcG9zaXRpb24sIGxhYmVsRW5kUG9zaXRpb24sIGNvdW50KTtcclxuICAgICAgICByZW5kZXJlci51cGRhdGVGaWxsKGRhdGFJdGVtLmdldChcImF4aXNGaWxsXCIpLCBwb3NpdGlvbiwgZmlsbEVuZFBvc2l0aW9uKTtcclxuICAgICAgICB0aGlzLl9wcm9jZXNzQnVsbGV0KGRhdGFJdGVtKTtcclxuICAgICAgICByZW5kZXJlci51cGRhdGVCdWxsZXQoZGF0YUl0ZW0uZ2V0KFwiYnVsbGV0XCIpLCBwb3NpdGlvbiwgZW5kUG9zaXRpb24pO1xyXG4gICAgICAgIGlmICghZGF0YUl0ZW0uZ2V0KFwiaXNSYW5nZVwiKSkge1xyXG4gICAgICAgICAgICBjb25zdCBmaWxsUnVsZSA9IHRoaXMuZ2V0KFwiZmlsbFJ1bGVcIik7XHJcbiAgICAgICAgICAgIGlmIChmaWxsUnVsZSkge1xyXG4gICAgICAgICAgICAgICAgZmlsbFJ1bGUoZGF0YUl0ZW0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgX2hhbmRsZVJhbmdlQ2hhbmdlKCkge1xyXG4gICAgICAgIGxldCBzZWxlY3Rpb25NaW4gPSB0aGlzLnBvc2l0aW9uVG9WYWx1ZSh0aGlzLmdldChcInN0YXJ0XCIsIDApKTtcclxuICAgICAgICBsZXQgc2VsZWN0aW9uTWF4ID0gdGhpcy5wb3NpdGlvblRvVmFsdWUodGhpcy5nZXQoXCJlbmRcIiwgMSkpO1xyXG4gICAgICAgIGNvbnN0IGdyaWRDb3VudCA9IHRoaXMuZ2V0KFwicmVuZGVyZXJcIikuZ3JpZENvdW50KCk7XHJcbiAgICAgICAgbGV0IG1pbk1heFN0ZXAgPSB0aGlzLl9hZGp1c3RNaW5NYXgoc2VsZWN0aW9uTWluLCBzZWxlY3Rpb25NYXgsIGdyaWRDb3VudCwgdHJ1ZSk7XHJcbiAgICAgICAgbGV0IHN0ZXBEZWNpbWFsUGxhY2VzID0gJHV0aWxzLmRlY2ltYWxQbGFjZXMobWluTWF4U3RlcC5zdGVwKTtcclxuICAgICAgICB0aGlzLnNldFByaXZhdGVSYXcoXCJzdGVwRGVjaW1hbFBsYWNlc1wiLCBzdGVwRGVjaW1hbFBsYWNlcyk7XHJcbiAgICAgICAgc2VsZWN0aW9uTWluID0gJG1hdGgucm91bmQoc2VsZWN0aW9uTWluLCBzdGVwRGVjaW1hbFBsYWNlcyk7XHJcbiAgICAgICAgc2VsZWN0aW9uTWF4ID0gJG1hdGgucm91bmQoc2VsZWN0aW9uTWF4LCBzdGVwRGVjaW1hbFBsYWNlcyk7XHJcbiAgICAgICAgbWluTWF4U3RlcCA9IHRoaXMuX2FkanVzdE1pbk1heChzZWxlY3Rpb25NaW4sIHNlbGVjdGlvbk1heCwgZ3JpZENvdW50LCB0cnVlKTtcclxuICAgICAgICBsZXQgc3RlcCA9IG1pbk1heFN0ZXAuc3RlcDtcclxuICAgICAgICBzZWxlY3Rpb25NaW4gPSBtaW5NYXhTdGVwLm1pbjtcclxuICAgICAgICBzZWxlY3Rpb25NYXggPSBtaW5NYXhTdGVwLm1heDtcclxuICAgICAgICBpZiAodGhpcy5nZXRQcml2YXRlKFwic2VsZWN0aW9uTWluXCIpICE9PSBzZWxlY3Rpb25NaW4gfHwgdGhpcy5nZXRQcml2YXRlKFwic2VsZWN0aW9uTWF4XCIpICE9PSBzZWxlY3Rpb25NYXggfHwgdGhpcy5nZXRQcml2YXRlKFwic3RlcFwiKSAhPT0gc3RlcCkge1xyXG4gICAgICAgICAgICAvLyBkbyBub3QgY2hhbmdlIHRvIHNldFByaXZhdGUsIHdpbGwgY2F1c2UgU09cclxuICAgICAgICAgICAgdGhpcy5zZXRQcml2YXRlUmF3KFwic2VsZWN0aW9uTWluXCIsIHNlbGVjdGlvbk1pbik7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0UHJpdmF0ZVJhdyhcInNlbGVjdGlvbk1heFwiLCBzZWxlY3Rpb25NYXgpO1xyXG4gICAgICAgICAgICB0aGlzLnNldFByaXZhdGVSYXcoXCJzdGVwXCIsIHN0ZXApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ29udmVydHMgYSByZWxhdGl2ZSBwb3NpdGlvbiB0byBhIGNvcnJlc3BvbmRpbmcgbnVtZXJpYyB2YWx1ZSBmcm9tIGF4aXNcclxuICAgICAqIHNjYWxlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSAgIHBvc2l0aW9uICBSZWxhdGl2ZSBwb3NpdGlvblxyXG4gICAgICogQHJldHVybiAgICAgICAgICAgIFZhbHVlXHJcbiAgICAgKi9cclxuICAgIHBvc2l0aW9uVG9WYWx1ZShwb3NpdGlvbikge1xyXG4gICAgICAgIGNvbnN0IG1pbiA9IHRoaXMuZ2V0UHJpdmF0ZShcIm1pblwiKTtcclxuICAgICAgICBjb25zdCBtYXggPSB0aGlzLmdldFByaXZhdGUoXCJtYXhcIik7XHJcbiAgICAgICAgaWYgKCF0aGlzLmdldChcImxvZ2FyaXRobWljXCIpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBwb3NpdGlvbiAqIChtYXggLSBtaW4pICsgbWluO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIE1hdGgucG93KE1hdGguRSwgKHBvc2l0aW9uICogKChNYXRoLmxvZyhtYXgpICogTWF0aC5MT0cxMEUgLSBNYXRoLmxvZyhtaW4pICogTWF0aC5MT0cxMEUpKSArIE1hdGgubG9nKG1pbikgKiBNYXRoLkxPRzEwRSkgLyBNYXRoLkxPRzEwRSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDb252ZXJzIHZhbHVlIHRvIGEgcmVsYXRpdmUgcG9zaXRpb24gb24gYXhpcy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gICB2YWx1ZSAgVmFsdWVcclxuICAgICAqIEByZXR1cm4gICAgICAgICBSZWxhdGl2ZSBwb3NpdGlvblxyXG4gICAgICovXHJcbiAgICB2YWx1ZVRvUG9zaXRpb24odmFsdWUpIHtcclxuICAgICAgICBjb25zdCBtaW4gPSB0aGlzLmdldFByaXZhdGUoXCJtaW5cIik7XHJcbiAgICAgICAgY29uc3QgbWF4ID0gdGhpcy5nZXRQcml2YXRlKFwibWF4XCIpO1xyXG4gICAgICAgIGlmICghdGhpcy5nZXQoXCJsb2dhcml0aG1pY1wiKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gKHZhbHVlIC0gbWluKSAvIChtYXggLSBtaW4pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKHZhbHVlIDw9IDApIHtcclxuICAgICAgICAgICAgICAgIGxldCB0cmVhdFplcm9BcyA9IHRoaXMuZ2V0KFwidHJlYXRaZXJvQXNcIik7XHJcbiAgICAgICAgICAgICAgICBpZiAoJHR5cGUuaXNOdW1iZXIodHJlYXRaZXJvQXMpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB0cmVhdFplcm9BcztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gKE1hdGgubG9nKHZhbHVlKSAqIE1hdGguTE9HMTBFIC0gTWF0aC5sb2cobWluKSAqIE1hdGguTE9HMTBFKSAvICgoTWF0aC5sb2cobWF4KSAqIE1hdGguTE9HMTBFIC0gTWF0aC5sb2cobWluKSAqIE1hdGguTE9HMTBFKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAaWdub3JlXHJcbiAgICAgKi9cclxuICAgIHZhbHVlVG9GaW5hbFBvc2l0aW9uKHZhbHVlKSB7XHJcbiAgICAgICAgY29uc3QgbWluID0gdGhpcy5nZXRQcml2YXRlKFwibWluRmluYWxcIik7XHJcbiAgICAgICAgY29uc3QgbWF4ID0gdGhpcy5nZXRQcml2YXRlKFwibWF4RmluYWxcIik7XHJcbiAgICAgICAgaWYgKCF0aGlzLmdldChcImxvZ2FyaXRobWljXCIpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAodmFsdWUgLSBtaW4pIC8gKG1heCAtIG1pbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAodmFsdWUgPD0gMCkge1xyXG4gICAgICAgICAgICAgICAgbGV0IHRyZWF0WmVyb0FzID0gdGhpcy5nZXQoXCJ0cmVhdFplcm9Bc1wiKTtcclxuICAgICAgICAgICAgICAgIGlmICgkdHlwZS5pc051bWJlcih0cmVhdFplcm9BcykpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHRyZWF0WmVyb0FzO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiAoTWF0aC5sb2codmFsdWUpICogTWF0aC5MT0cxMEUgLSBNYXRoLmxvZyhtaW4pICogTWF0aC5MT0cxMEUpIC8gKChNYXRoLmxvZyhtYXgpICogTWF0aC5MT0cxMEUgLSBNYXRoLmxvZyhtaW4pICogTWF0aC5MT0cxMEUpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgWCBjb29yZGluYXRlIGluIHBpeGVscyBjb3JyZXNwb25kaW5nIHRvIHNwZWNpZmljIHZhbHVlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSAgIHZhbHVlICAgICBOdW1lcmljIHZhbHVlXHJcbiAgICAgKiBAcGFyYW0gICBsb2NhdGlvbiAgTG9jYXRpb25cclxuICAgICAqIEBwYXJhbSAgIGJhc2VWYWx1ZSBCYXNlIHZhbHVlXHJcbiAgICAgKiBAcmV0dXJuICAgICAgICAgICAgWCBjb29yZGluYXRlXHJcbiAgICAgKi9cclxuICAgIGdldFgodmFsdWUsIGxvY2F0aW9uLCBiYXNlVmFsdWUpIHtcclxuICAgICAgICB2YWx1ZSA9IGJhc2VWYWx1ZSArICh2YWx1ZSAtIGJhc2VWYWx1ZSkgKiBsb2NhdGlvbjtcclxuICAgICAgICBjb25zdCBwb3NpdGlvbiA9IHRoaXMudmFsdWVUb1Bvc2l0aW9uKHZhbHVlKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5fc2V0dGluZ3MucmVuZGVyZXIucG9zaXRpb25Ub0Nvb3JkaW5hdGUocG9zaXRpb24pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIFggY29vcmRpbmF0ZSBpbiBwaXhlbHMgY29ycmVzcG9uZGluZyB0byBzcGVjaWZpYyB2YWx1ZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gICB2YWx1ZSAgICAgTnVtZXJpYyB2YWx1ZVxyXG4gICAgICogQHBhcmFtICAgbG9jYXRpb24gIExvY2F0aW9uXHJcbiAgICAgKiBAcGFyYW0gICBiYXNlVmFsdWUgQmFzZSB2YWx1ZVxyXG4gICAgICogQHJldHVybiAgICAgICAgICAgIFggY29vcmRpbmF0ZVxyXG4gICAgICovXHJcbiAgICBnZXRZKHZhbHVlLCBsb2NhdGlvbiwgYmFzZVZhbHVlKSB7XHJcbiAgICAgICAgdmFsdWUgPSBiYXNlVmFsdWUgKyAodmFsdWUgLSBiYXNlVmFsdWUpICogbG9jYXRpb247XHJcbiAgICAgICAgY29uc3QgcG9zaXRpb24gPSB0aGlzLnZhbHVlVG9Qb3NpdGlvbih2YWx1ZSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NldHRpbmdzLnJlbmRlcmVyLnBvc2l0aW9uVG9Db29yZGluYXRlKHBvc2l0aW9uKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQGlnbm9yZVxyXG4gICAgICovXHJcbiAgICBnZXREYXRhSXRlbUNvb3JkaW5hdGVYKGRhdGFJdGVtLCBmaWVsZCwgX2NlbGxMb2NhdGlvbiwgYXhpc0xvY2F0aW9uKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NldHRpbmdzLnJlbmRlcmVyLnBvc2l0aW9uVG9Db29yZGluYXRlKHRoaXMuZ2V0RGF0YUl0ZW1Qb3NpdGlvblgoZGF0YUl0ZW0sIGZpZWxkLCBfY2VsbExvY2F0aW9uLCBheGlzTG9jYXRpb24pKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQGlnbm9yZVxyXG4gICAgICovXHJcbiAgICBnZXREYXRhSXRlbVBvc2l0aW9uWChkYXRhSXRlbSwgZmllbGQsIF9jZWxsTG9jYXRpb24sIGF4aXNMb2NhdGlvbikge1xyXG4gICAgICAgIGxldCB2YWx1ZSA9IGRhdGFJdGVtLmdldChmaWVsZCk7XHJcbiAgICAgICAgY29uc3Qgc3RhY2tUb0l0ZW0gPSBkYXRhSXRlbS5nZXQoXCJzdGFja1RvSXRlbVhcIik7XHJcbiAgICAgICAgaWYgKHN0YWNrVG9JdGVtKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHNlcmllcyA9IGRhdGFJdGVtLmNvbXBvbmVudDtcclxuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZSAqIGF4aXNMb2NhdGlvbiArIHNlcmllcy5nZXRTdGFja2VkWFZhbHVlV29ya2luZyhkYXRhSXRlbSwgZmllbGQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdmFsdWUgPSB0aGlzLl9iYXNlVmFsdWUgKyAodmFsdWUgLSB0aGlzLl9iYXNlVmFsdWUpICogYXhpc0xvY2F0aW9uO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZVRvUG9zaXRpb24odmFsdWUpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAaWdub3JlXHJcbiAgICAgKi9cclxuICAgIGdldERhdGFJdGVtQ29vcmRpbmF0ZVkoZGF0YUl0ZW0sIGZpZWxkLCBfY2VsbExvY2F0aW9uLCBheGlzTG9jYXRpb24pIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fc2V0dGluZ3MucmVuZGVyZXIucG9zaXRpb25Ub0Nvb3JkaW5hdGUodGhpcy5nZXREYXRhSXRlbVBvc2l0aW9uWShkYXRhSXRlbSwgZmllbGQsIF9jZWxsTG9jYXRpb24sIGF4aXNMb2NhdGlvbikpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAaWdub3JlXHJcbiAgICAgKi9cclxuICAgIGdldERhdGFJdGVtUG9zaXRpb25ZKGRhdGFJdGVtLCBmaWVsZCwgX2NlbGxMb2NhdGlvbiwgYXhpc0xvY2F0aW9uKSB7XHJcbiAgICAgICAgbGV0IHZhbHVlID0gZGF0YUl0ZW0uZ2V0KGZpZWxkKTtcclxuICAgICAgICBjb25zdCBzdGFja1RvSXRlbSA9IGRhdGFJdGVtLmdldChcInN0YWNrVG9JdGVtWVwiKTtcclxuICAgICAgICBpZiAoc3RhY2tUb0l0ZW0pIHtcclxuICAgICAgICAgICAgY29uc3Qgc2VyaWVzID0gZGF0YUl0ZW0uY29tcG9uZW50O1xyXG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlICogYXhpc0xvY2F0aW9uICsgc2VyaWVzLmdldFN0YWNrZWRZVmFsdWVXb3JraW5nKGRhdGFJdGVtLCBmaWVsZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB2YWx1ZSA9IHRoaXMuX2Jhc2VWYWx1ZSArICh2YWx1ZSAtIHRoaXMuX2Jhc2VWYWx1ZSkgKiBheGlzTG9jYXRpb247XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlVG9Qb3NpdGlvbih2YWx1ZSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgcmVsYXRpdmUgcG9zaXRpb24gb2YgYXhpcycgYGJhc2VWYWx1ZWAuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybiAgQmFzZSB2YWx1ZSBwb3NpdGlvblxyXG4gICAgICovXHJcbiAgICBiYXNlUG9zaXRpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVUb1Bvc2l0aW9uKHRoaXMuYmFzZVZhbHVlKCkpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBCYXNlIHZhbHVlIG9mIHRoZSBbW1ZhbHVlQXhpc11dLCB3aGljaCBkZXRlcm1pbmVzIHBvc2l0aXZlIGFuZCBuZWdhdGl2ZVxyXG4gICAgICogdmFsdWVzLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm4gQmFzZSB2YWx1ZVxyXG4gICAgICovXHJcbiAgICBiYXNlVmFsdWUoKSB7XHJcbiAgICAgICAgY29uc3QgbWluID0gTWF0aC5taW4odGhpcy5nZXRQcml2YXRlKFwibWluRmluYWxcIiwgLUluZmluaXR5KSwgdGhpcy5nZXRQcml2YXRlKFwic2VsZWN0aW9uTWluXCIsIC1JbmZpbml0eSkpO1xyXG4gICAgICAgIGNvbnN0IG1heCA9IE1hdGgubWF4KHRoaXMuZ2V0UHJpdmF0ZShcIm1heEZpbmFsXCIsIEluZmluaXR5KSwgdGhpcy5nZXRQcml2YXRlKFwic2VsZWN0aW9uTWF4XCIsIEluZmluaXR5KSk7XHJcbiAgICAgICAgbGV0IGJhc2VWYWx1ZSA9IHRoaXMuZ2V0KFwiYmFzZVZhbHVlXCIsIDApO1xyXG4gICAgICAgIGlmIChiYXNlVmFsdWUgPCBtaW4pIHtcclxuICAgICAgICAgICAgYmFzZVZhbHVlID0gbWluO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoYmFzZVZhbHVlID4gbWF4KSB7XHJcbiAgICAgICAgICAgIGJhc2VWYWx1ZSA9IG1heDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGJhc2VWYWx1ZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQGlnbm9yZVxyXG4gICAgICovXHJcbiAgICBjZWxsRW5kVmFsdWUodmFsdWUpIHtcclxuICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICB9XHJcbiAgICBmaXhTbWFsbFN0ZXAoc3RlcCkge1xyXG4gICAgICAgIC8vIGhhcHBlbnMgYmVjYXVzZSBvZiBmbG9hdGluZyBwb2ludCBlcnJvclxyXG4gICAgICAgIGlmICgxICsgc3RlcCA9PT0gMSkge1xyXG4gICAgICAgICAgICBzdGVwICo9IDI7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZpeFNtYWxsU3RlcChzdGVwKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHN0ZXA7XHJcbiAgICB9XHJcbiAgICBfZml4TWluKG1pbikge1xyXG4gICAgICAgIHJldHVybiBtaW47XHJcbiAgICB9XHJcbiAgICBfZml4TWF4KG1heCkge1xyXG4gICAgICAgIHJldHVybiBtYXg7XHJcbiAgICB9XHJcbiAgICBfY2FsY3VsYXRlVG90YWxzKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmdldChcImNhbGN1bGF0ZVRvdGFsc1wiKSkge1xyXG4gICAgICAgICAgICBsZXQgc2VyaWVzID0gdGhpcy5zZXJpZXNbMF07XHJcbiAgICAgICAgICAgIGlmIChzZXJpZXMpIHtcclxuICAgICAgICAgICAgICAgIGxldCBzdGFydEluZGV4ID0gc2VyaWVzLnN0YXJ0SW5kZXgoKTtcclxuICAgICAgICAgICAgICAgIGlmIChzZXJpZXMuZGF0YUl0ZW1zLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhcnRJbmRleCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRJbmRleC0tO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBsZXQgZW5kSW5kZXggPSBzZXJpZXMuZW5kSW5kZXgoKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZW5kSW5kZXggPCBzZXJpZXMuZGF0YUl0ZW1zLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmRJbmRleCsrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBsZXQgZmllbGQ7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHZjO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzZXJpZXMuZ2V0KFwieUF4aXNcIikgPT0gdGhpcykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmaWVsZCA9IFwidmFsdWVZXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZjID0gXCJ2Y3lcIjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoc2VyaWVzLmdldChcInhBeGlzXCIpID09IHRoaXMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmllbGQgPSBcInZhbHVlWFwiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YyA9IFwidmN4XCI7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGxldCBmaWVsZFdvcmtpbmcgPSBmaWVsZCArIFwiV29ya2luZ1wiO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChmaWVsZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gc3RhcnRJbmRleDsgaSA8IGVuZEluZGV4OyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBzdW0gPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHRvdGFsID0gMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICRhcnJheS5lYWNoKHRoaXMuc2VyaWVzLCAoc2VyaWVzKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFzZXJpZXMuZ2V0KFwiZXhjbHVkZUZyb21Ub3RhbFwiKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgZGF0YUl0ZW0gPSBzZXJpZXMuZGF0YUl0ZW1zW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YUl0ZW0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCB2YWx1ZSA9IGRhdGFJdGVtLmdldChmaWVsZFdvcmtpbmcpICogc2VyaWVzLmdldCh2Yyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoISR0eXBlLmlzTmFOKHZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1bSArPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b3RhbCArPSBNYXRoLmFicyh2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICRhcnJheS5lYWNoKHRoaXMuc2VyaWVzLCAoc2VyaWVzKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFzZXJpZXMuZ2V0KFwiZXhjbHVkZUZyb21Ub3RhbFwiKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgZGF0YUl0ZW0gPSBzZXJpZXMuZGF0YUl0ZW1zW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YUl0ZW0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCB2YWx1ZSA9IGRhdGFJdGVtLmdldChmaWVsZFdvcmtpbmcpICogc2VyaWVzLmdldCh2Yyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoISR0eXBlLmlzTmFOKHZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFJdGVtLnNldCgoZmllbGQgKyBcIlRvdGFsXCIpLCB0b3RhbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YUl0ZW0uc2V0KChmaWVsZCArIFwiU3VtXCIpLCBzdW0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFJdGVtLnNldCgoZmllbGQgKyBcIlRvdGFsUGVyY2VudFwiKSwgdmFsdWUgLyB0b3RhbCAqIDEwMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIF9nZXRTZWxlY3Rpb25NaW5NYXgoKSB7XHJcbiAgICAgICAgY29uc3QgbWluID0gdGhpcy5nZXRQcml2YXRlKFwibWluRmluYWxcIik7XHJcbiAgICAgICAgY29uc3QgbWF4ID0gdGhpcy5nZXRQcml2YXRlKFwibWF4RmluYWxcIik7XHJcbiAgICAgICAgY29uc3QgbWluRGVmaW5lZCA9IHRoaXMuZ2V0KFwibWluXCIpO1xyXG4gICAgICAgIGNvbnN0IG1heERlZmluZWQgPSB0aGlzLmdldChcIm1heFwiKTtcclxuICAgICAgICBsZXQgZXh0cmFNaW4gPSB0aGlzLmdldChcImV4dHJhTWluXCIsIDApO1xyXG4gICAgICAgIGxldCBleHRyYU1heCA9IHRoaXMuZ2V0KFwiZXh0cmFNYXhcIiwgMCk7XHJcbiAgICAgICAgaWYgKHRoaXMuZ2V0KFwibG9nYXJpdGhtaWNcIikpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuZ2V0KFwiZXh0cmFNaW5cIikgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgZXh0cmFNaW4gPSAwLjE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRoaXMuZ2V0KFwiZXh0cmFNYXhcIikgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgZXh0cmFNYXggPSAwLjI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgZ3JpZENvdW50ID0gdGhpcy5nZXQoXCJyZW5kZXJlclwiKS5ncmlkQ291bnQoKTtcclxuICAgICAgICBjb25zdCBzZWxlY3Rpb25TdHJpY3RNaW5NYXggPSB0aGlzLmdldChcInN0cmljdE1pbk1heFNlbGVjdGlvblwiKTtcclxuICAgICAgICBjb25zdCBzdHJpY3RNaW5NYXggPSB0aGlzLmdldChcInN0cmljdE1pbk1heFwiKTtcclxuICAgICAgICBpZiAoJHR5cGUuaXNOdW1iZXIobWluKSAmJiAkdHlwZS5pc051bWJlcihtYXgpKSB7XHJcbiAgICAgICAgICAgIGxldCBzZWxlY3Rpb25NaW4gPSBtYXg7XHJcbiAgICAgICAgICAgIGxldCBzZWxlY3Rpb25NYXggPSBtaW47XHJcbiAgICAgICAgICAgICRhcnJheS5lYWNoKHRoaXMuc2VyaWVzLCAoc2VyaWVzKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXNlcmllcy5nZXQoXCJpZ25vcmVNaW5NYXhcIikpIHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgc2VyaWVzTWluO1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBzZXJpZXNNYXg7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgb3V0T2ZTZWxlY3Rpb24gPSBzZXJpZXMuZ2V0UHJpdmF0ZShcIm91dE9mU2VsZWN0aW9uXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzZXJpZXMuZ2V0KFwieEF4aXNcIikgPT09IHRoaXMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFvdXRPZlNlbGVjdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG1pblggPSBzZXJpZXMuZ2V0UHJpdmF0ZShcIm1pblhcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgbWF4WCA9IHNlcmllcy5nZXRQcml2YXRlKFwibWF4WFwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNvbHZlcyAjOTAwODVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZXJpZXMuc3RhcnRJbmRleCgpICE9IDAgfHwgc2VyaWVzLmVuZEluZGV4KCkgIT0gc2VyaWVzLmRhdGFJdGVtcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaW5YID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1heFggPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXJpZXNNaW4gPSBzZXJpZXMuZ2V0UHJpdmF0ZShcInNlbGVjdGlvbk1pblhcIiwgbWluWCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXJpZXNNYXggPSBzZXJpZXMuZ2V0UHJpdmF0ZShcInNlbGVjdGlvbk1heFhcIiwgbWF4WCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoc2VyaWVzLmdldChcInlBeGlzXCIpID09PSB0aGlzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghb3V0T2ZTZWxlY3Rpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBtaW5ZID0gc2VyaWVzLmdldFByaXZhdGUoXCJtaW5ZXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG1heFkgPSBzZXJpZXMuZ2V0UHJpdmF0ZShcIm1heFlcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzb2x2ZXMgIzkwMDg1XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2VyaWVzLnN0YXJ0SW5kZXgoKSAhPSAwIHx8IHNlcmllcy5lbmRJbmRleCgpICE9IHNlcmllcy5kYXRhSXRlbXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWluWSA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXhZID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VyaWVzTWluID0gc2VyaWVzLmdldFByaXZhdGUoXCJzZWxlY3Rpb25NaW5ZXCIsIG1pblkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VyaWVzTWF4ID0gc2VyaWVzLmdldFByaXZhdGUoXCJzZWxlY3Rpb25NYXhZXCIsIG1heFkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghc2VyaWVzLmlzSGlkZGVuKCkgJiYgIXNlcmllcy5pc1Nob3dpbmcoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoJHR5cGUuaXNOdW1iZXIoc2VyaWVzTWluKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0aW9uTWluID0gTWF0aC5taW4oc2VsZWN0aW9uTWluLCBzZXJpZXNNaW4pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgkdHlwZS5pc051bWJlcihzZXJpZXNNYXgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3Rpb25NYXggPSBNYXRoLm1heChzZWxlY3Rpb25NYXgsIHNlcmllc01heCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB0aGlzLmF4aXNSYW5nZXMuZWFjaCgocmFuZ2UpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChyYW5nZS5nZXQoXCJhZmZlY3RzTWluTWF4XCIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHZhbHVlID0gcmFuZ2UuZ2V0KFwidmFsdWVcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0aW9uTWluID0gTWF0aC5taW4oc2VsZWN0aW9uTWluLCB2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGlvbk1heCA9IE1hdGgubWF4KHNlbGVjdGlvbk1heCwgdmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHJhbmdlLmdldChcImVuZFZhbHVlXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGlvbk1pbiA9IE1hdGgubWluKHNlbGVjdGlvbk1pbiwgdmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3Rpb25NYXggPSBNYXRoLm1heChzZWxlY3Rpb25NYXgsIHZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBpZiAoc2VsZWN0aW9uTWluID4gc2VsZWN0aW9uTWF4KSB7XHJcbiAgICAgICAgICAgICAgICBbc2VsZWN0aW9uTWluLCBzZWxlY3Rpb25NYXhdID0gW3NlbGVjdGlvbk1heCwgc2VsZWN0aW9uTWluXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoJHR5cGUuaXNOdW1iZXIobWluRGVmaW5lZCkpIHtcclxuICAgICAgICAgICAgICAgIGlmIChzdHJpY3RNaW5NYXgpIHtcclxuICAgICAgICAgICAgICAgICAgICBzZWxlY3Rpb25NaW4gPSBtaW5EZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0aW9uTWluID0gbWluO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHN0cmljdE1pbk1heCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCR0eXBlLmlzTnVtYmVyKHRoaXMuX21pblJlYWwpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0aW9uTWluID0gdGhpcy5fbWluUmVhbDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoJHR5cGUuaXNOdW1iZXIobWF4RGVmaW5lZCkpIHtcclxuICAgICAgICAgICAgICAgIGlmIChzdHJpY3RNaW5NYXgpIHtcclxuICAgICAgICAgICAgICAgICAgICBzZWxlY3Rpb25NYXggPSBtYXhEZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0aW9uTWF4ID0gbWF4O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHN0cmljdE1pbk1heCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCR0eXBlLmlzTnVtYmVyKHRoaXMuX21heFJlYWwpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0aW9uTWF4ID0gdGhpcy5fbWF4UmVhbDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoc2VsZWN0aW9uTWluID09PSBzZWxlY3Rpb25NYXgpIHtcclxuICAgICAgICAgICAgICAgIHNlbGVjdGlvbk1pbiAtPSB0aGlzLl9kZWx0YU1pbk1heDtcclxuICAgICAgICAgICAgICAgIHNlbGVjdGlvbk1heCArPSB0aGlzLl9kZWx0YU1pbk1heDtcclxuICAgICAgICAgICAgICAgIGxldCBtaW5NYXhTdGVwMiA9IHRoaXMuX2FkanVzdE1pbk1heChzZWxlY3Rpb25NaW4sIHNlbGVjdGlvbk1heCwgZ3JpZENvdW50LCBzdHJpY3RNaW5NYXgpO1xyXG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uTWluID0gbWluTWF4U3RlcDIubWluO1xyXG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uTWF4ID0gbWluTWF4U3RlcDIubWF4O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGxldCBzZWxlY3Rpb25NaW5SZWFsID0gc2VsZWN0aW9uTWluO1xyXG4gICAgICAgICAgICBsZXQgc2VsZWN0aW9uTWF4UmVhbCA9IHNlbGVjdGlvbk1heDtcclxuICAgICAgICAgICAgc2VsZWN0aW9uTWluIC09IChzZWxlY3Rpb25NYXggLSBzZWxlY3Rpb25NaW4pICogZXh0cmFNaW47XHJcbiAgICAgICAgICAgIHNlbGVjdGlvbk1heCArPSAoc2VsZWN0aW9uTWF4IC0gc2VsZWN0aW9uTWluKSAqIGV4dHJhTWF4O1xyXG4gICAgICAgICAgICBsZXQgbWluTWF4U3RlcCA9IHRoaXMuX2FkanVzdE1pbk1heChzZWxlY3Rpb25NaW4sIHNlbGVjdGlvbk1heCwgZ3JpZENvdW50KTtcclxuICAgICAgICAgICAgc2VsZWN0aW9uTWluID0gbWluTWF4U3RlcC5taW47XHJcbiAgICAgICAgICAgIHNlbGVjdGlvbk1heCA9IG1pbk1heFN0ZXAubWF4O1xyXG4gICAgICAgICAgICBzZWxlY3Rpb25NaW4gPSAkbWF0aC5maXRUb1JhbmdlKHNlbGVjdGlvbk1pbiwgbWluLCBtYXgpO1xyXG4gICAgICAgICAgICBzZWxlY3Rpb25NYXggPSAkbWF0aC5maXRUb1JhbmdlKHNlbGVjdGlvbk1heCwgbWluLCBtYXgpO1xyXG4gICAgICAgICAgICAvLyBkbyBpdCBmb3IgdGhlIHNlY29uZCB0aW1lICFpbXBvcnRhbnRcdFx0XHRcclxuICAgICAgICAgICAgbWluTWF4U3RlcCA9IHRoaXMuX2FkanVzdE1pbk1heChzZWxlY3Rpb25NaW4sIHNlbGVjdGlvbk1heCwgZ3JpZENvdW50LCB0cnVlKTtcclxuICAgICAgICAgICAgaWYgKCFzdHJpY3RNaW5NYXgpIHtcclxuICAgICAgICAgICAgICAgIHNlbGVjdGlvbk1pbiA9IG1pbk1heFN0ZXAubWluO1xyXG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uTWF4ID0gbWluTWF4U3RlcC5tYXg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3Qgc3luY1dpdGhBeGlzID0gdGhpcy5nZXQoXCJzeW5jV2l0aEF4aXNcIik7XHJcbiAgICAgICAgICAgIGlmIChzeW5jV2l0aEF4aXMpIHtcclxuICAgICAgICAgICAgICAgIG1pbk1heFN0ZXAgPSB0aGlzLl9zeW5jQXhlcyhzZWxlY3Rpb25NaW4sIHNlbGVjdGlvbk1heCwgbWluTWF4U3RlcC5zdGVwLCBzeW5jV2l0aEF4aXMuZ2V0UHJpdmF0ZShcInNlbGVjdGlvbk1pbkZpbmFsXCIsIHN5bmNXaXRoQXhpcy5nZXRQcml2YXRlKFwibWluRmluYWxcIiwgMCkpLCBzeW5jV2l0aEF4aXMuZ2V0UHJpdmF0ZShcInNlbGVjdGlvbk1heEZpbmFsXCIsIHN5bmNXaXRoQXhpcy5nZXRQcml2YXRlKFwibWF4RmluYWxcIiwgMSkpLCBzeW5jV2l0aEF4aXMuZ2V0UHJpdmF0ZShcInNlbGVjdGlvblN0ZXBGaW5hbFwiLCBzeW5jV2l0aEF4aXMuZ2V0UHJpdmF0ZShcInN0ZXBcIiwgMSkpKTtcclxuICAgICAgICAgICAgICAgIHNlbGVjdGlvbk1pbiA9IG1pbk1heFN0ZXAubWluO1xyXG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uTWF4ID0gbWluTWF4U3RlcC5tYXg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHN0cmljdE1pbk1heCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCR0eXBlLmlzTnVtYmVyKG1pbkRlZmluZWQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0aW9uTWluID0gTWF0aC5tYXgoc2VsZWN0aW9uTWluLCBtaW5EZWZpbmVkKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICgkdHlwZS5pc051bWJlcihtYXhEZWZpbmVkKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdGlvbk1heCA9IE1hdGgubWluKHNlbGVjdGlvbk1heCwgbWF4RGVmaW5lZCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHNlbGVjdGlvblN0cmljdE1pbk1heCkge1xyXG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uTWluID0gc2VsZWN0aW9uTWluUmVhbCAtIChzZWxlY3Rpb25NYXggLSBzZWxlY3Rpb25NaW4pICogZXh0cmFNaW47XHJcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb25NYXggPSBzZWxlY3Rpb25NYXhSZWFsICsgKHNlbGVjdGlvbk1heCAtIHNlbGVjdGlvbk1pbikgKiBleHRyYU1heDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodGhpcy5nZXQoXCJsb2dhcml0aG1pY1wiKSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHNlbGVjdGlvbk1pbiA8PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0aW9uTWluID0gc2VsZWN0aW9uTWluUmVhbCAqICgxIC0gTWF0aC5taW4oZXh0cmFNaW4sIDAuOTkpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChzZWxlY3Rpb25NaW4gPCBtaW4pIHtcclxuICAgICAgICAgICAgICAgICAgICBzZWxlY3Rpb25NaW4gPSBtaW47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoc2VsZWN0aW9uTWF4ID4gbWF4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0aW9uTWF4ID0gbWF4O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGxldCBsZW4gPSBNYXRoLm1pbigyMCwgTWF0aC5jZWlsKE1hdGgubG9nKHRoaXMuZ2V0UHJpdmF0ZShcIm1heFpvb21GYWN0b3JcIiwgMTAwKSArIDEpIC8gTWF0aC5MTjEwKSArIDIpO1xyXG4gICAgICAgICAgICBsZXQgc3RhcnQgPSAkbWF0aC5yb3VuZCh0aGlzLnZhbHVlVG9GaW5hbFBvc2l0aW9uKHNlbGVjdGlvbk1pbiksIGxlbik7XHJcbiAgICAgICAgICAgIGxldCBlbmQgPSAkbWF0aC5yb3VuZCh0aGlzLnZhbHVlVG9GaW5hbFBvc2l0aW9uKHNlbGVjdGlvbk1heCksIGxlbik7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0UHJpdmF0ZVJhdyhcInNlbGVjdGlvbk1pbkZpbmFsXCIsIHNlbGVjdGlvbk1pbik7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0UHJpdmF0ZVJhdyhcInNlbGVjdGlvbk1heEZpbmFsXCIsIHNlbGVjdGlvbk1heCk7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0UHJpdmF0ZVJhdyhcInNlbGVjdGlvblN0ZXBGaW5hbFwiLCBtaW5NYXhTdGVwLnN0ZXApO1xyXG4gICAgICAgICAgICB0aGlzLnpvb20oc3RhcnQsIGVuZCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgX2dldE1pbk1heCgpIHtcclxuICAgICAgICBsZXQgbWluRGVmaW5lZCA9IHRoaXMuZ2V0KFwibWluXCIpO1xyXG4gICAgICAgIGxldCBtYXhEZWZpbmVkID0gdGhpcy5nZXQoXCJtYXhcIik7XHJcbiAgICAgICAgbGV0IG1pbiA9IEluZmluaXR5O1xyXG4gICAgICAgIGxldCBtYXggPSAtSW5maW5pdHk7XHJcbiAgICAgICAgbGV0IGV4dHJhTWluID0gdGhpcy5nZXQoXCJleHRyYU1pblwiLCAwKTtcclxuICAgICAgICBsZXQgZXh0cmFNYXggPSB0aGlzLmdldChcImV4dHJhTWF4XCIsIDApO1xyXG4gICAgICAgIGlmICh0aGlzLmdldChcImxvZ2FyaXRobWljXCIpKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmdldChcImV4dHJhTWluXCIpID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIGV4dHJhTWluID0gMC4xO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmdldChcImV4dHJhTWF4XCIpID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIGV4dHJhTWF4ID0gMC4yO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBtaW5EaWZmID0gSW5maW5pdHk7XHJcbiAgICAgICAgJGFycmF5LmVhY2godGhpcy5zZXJpZXMsIChzZXJpZXMpID0+IHtcclxuICAgICAgICAgICAgaWYgKCFzZXJpZXMuZ2V0KFwiaWdub3JlTWluTWF4XCIpKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgc2VyaWVzTWluO1xyXG4gICAgICAgICAgICAgICAgbGV0IHNlcmllc01heDtcclxuICAgICAgICAgICAgICAgIGlmIChzZXJpZXMuZ2V0KFwieEF4aXNcIikgPT09IHRoaXMpIHtcclxuICAgICAgICAgICAgICAgICAgICBzZXJpZXNNaW4gPSBzZXJpZXMuZ2V0UHJpdmF0ZShcIm1pblhcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VyaWVzTWF4ID0gc2VyaWVzLmdldFByaXZhdGUoXCJtYXhYXCIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc2VyaWVzLmdldChcInlBeGlzXCIpID09PSB0aGlzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VyaWVzTWluID0gc2VyaWVzLmdldFByaXZhdGUoXCJtaW5ZXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHNlcmllc01heCA9IHNlcmllcy5nZXRQcml2YXRlKFwibWF4WVwiKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICgkdHlwZS5pc051bWJlcihzZXJpZXNNaW4pICYmICR0eXBlLmlzTnVtYmVyKHNlcmllc01heCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBtaW4gPSBNYXRoLm1pbihtaW4sIHNlcmllc01pbik7XHJcbiAgICAgICAgICAgICAgICAgICAgbWF4ID0gTWF0aC5tYXgobWF4LCBzZXJpZXNNYXgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBkaWZmID0gc2VyaWVzTWF4IC0gc2VyaWVzTWluO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChkaWZmIDw9IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGlmZiA9IE1hdGguYWJzKHNlcmllc01heCAvIDEwMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChkaWZmIDwgbWluRGlmZikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtaW5EaWZmID0gZGlmZjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLmF4aXNSYW5nZXMuZWFjaCgocmFuZ2UpID0+IHtcclxuICAgICAgICAgICAgaWYgKHJhbmdlLmdldChcImFmZmVjdHNNaW5NYXhcIikpIHtcclxuICAgICAgICAgICAgICAgIGxldCB2YWx1ZSA9IHJhbmdlLmdldChcInZhbHVlXCIpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICBtaW4gPSBNYXRoLm1pbihtaW4sIHZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICBtYXggPSBNYXRoLm1heChtYXgsIHZhbHVlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhbHVlID0gcmFuZ2UuZ2V0KFwiZW5kVmFsdWVcIik7XHJcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG1pbiA9IE1hdGgubWluKG1pbiwgdmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIG1heCA9IE1hdGgubWF4KG1heCwgdmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKHRoaXMuZ2V0KFwibG9nYXJpdGhtaWNcIikpIHtcclxuICAgICAgICAgICAgbGV0IHRyZWF0WmVyb0FzID0gdGhpcy5nZXQoXCJ0cmVhdFplcm9Bc1wiKTtcclxuICAgICAgICAgICAgaWYgKCR0eXBlLmlzTnVtYmVyKHRyZWF0WmVyb0FzKSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKG1pbiA8PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWluID0gdHJlYXRaZXJvQXM7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKG1pbiA8PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBuZXcgRXJyb3IoXCJMb2dhcml0aG1pYyB2YWx1ZSBheGlzIGNhbiBub3QgaGF2ZSB2YWx1ZXMgPD0gMC5cIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG1pbiA9PT0gMCAmJiBtYXggPT09IDApIHtcclxuICAgICAgICAgICAgbWF4ID0gMC45O1xyXG4gICAgICAgICAgICBtaW4gPSAtMC45O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoJHR5cGUuaXNOdW1iZXIobWluRGVmaW5lZCkpIHtcclxuICAgICAgICAgICAgbWluID0gbWluRGVmaW5lZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCR0eXBlLmlzTnVtYmVyKG1heERlZmluZWQpKSB7XHJcbiAgICAgICAgICAgIG1heCA9IG1heERlZmluZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIG1lYW5pbmcgbm8gbWluL21heCBmb3VuZCBvbiBzZXJpZXMvcmFuZ2VzIGFuZCBubyBtaW4vbWF4IHdhcyBkZWZpbmVkXHJcbiAgICAgICAgaWYgKG1pbiA9PT0gSW5maW5pdHkgfHwgbWF4ID09PSAtSW5maW5pdHkpIHtcclxuICAgICAgICAgICAgdGhpcy5zZXRQcml2YXRlKFwibWluRmluYWxcIiwgdW5kZWZpbmVkKTtcclxuICAgICAgICAgICAgdGhpcy5zZXRQcml2YXRlKFwibWF4RmluYWxcIiwgdW5kZWZpbmVkKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBpbml0aWFsTWluID0gbWluO1xyXG4gICAgICAgIGNvbnN0IGluaXRpYWxNYXggPSBtYXg7XHJcbiAgICAgICAgLy8gYWRhcHRlclxyXG4gICAgICAgIGxldCBtaW5BZGFwdGVkID0gdGhpcy5hZGFwdGVycy5mb2xkKFwibWluXCIsIG1pbik7XHJcbiAgICAgICAgbGV0IG1heEFkYXB0ZWQgPSB0aGlzLmFkYXB0ZXJzLmZvbGQoXCJtYXhcIiwgbWF4KTtcclxuICAgICAgICBpZiAoJHR5cGUuaXNOdW1iZXIobWluQWRhcHRlZCkpIHtcclxuICAgICAgICAgICAgbWluID0gbWluQWRhcHRlZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCR0eXBlLmlzTnVtYmVyKG1heEFkYXB0ZWQpKSB7XHJcbiAgICAgICAgICAgIG1heCA9IG1heEFkYXB0ZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIERhdGVBeGlzIGRvZXMgc29tZSBtYWdpYyBoZXJlXHJcbiAgICAgICAgbWluID0gdGhpcy5fZml4TWluKG1pbik7XHJcbiAgICAgICAgbWF4ID0gdGhpcy5fZml4TWF4KG1heCk7XHJcbiAgICAgICAgLy8gdGhpcyBoYXBwZW5zIGlmIHN0YXJMb2NhdGlvbiBhbmQgZW5kTG9jYXRpb24gYXJlIDAuNSBhbmQgRGF0ZUF4aXMgaGFzIG9ubHkgb25lIGRhdGVcdFx0XHJcbiAgICAgICAgaWYgKG1heCAtIG1pbiA8PSAxIC8gTWF0aC5wb3coMTAsIDE1KSkge1xyXG4gICAgICAgICAgICBpZiAobWF4IC0gbWluICE9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9kZWx0YU1pbk1heCA9IChtYXggLSBtaW4pIC8gMjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2dldERlbHRhKG1heCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbWluIC09IHRoaXMuX2RlbHRhTWluTWF4O1xyXG4gICAgICAgICAgICBtYXggKz0gdGhpcy5fZGVsdGFNaW5NYXg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGFkZCBleHRyYXNcclxuICAgICAgICBtaW4gLT0gKG1heCAtIG1pbikgKiBleHRyYU1pbjtcclxuICAgICAgICBtYXggKz0gKG1heCAtIG1pbikgKiBleHRyYU1heDtcclxuICAgICAgICBpZiAodGhpcy5nZXQoXCJsb2dhcml0aG1pY1wiKSkge1xyXG4gICAgICAgICAgICAvLyBkb24ndCBsZXQgbWluIGdvIGJlbG93IDAgaWYgcmVhbCBtaW4gaXMgPj0gMFxyXG4gICAgICAgICAgICBpZiAobWluIDwgMCAmJiBpbml0aWFsTWluID49IDApIHtcclxuICAgICAgICAgICAgICAgIG1pbiA9IDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gZG9uJ3QgbGV0IG1heCBnbyBhYm92ZSAwIGlmIHJlYWwgbWF4IGlzIDw9IDBcclxuICAgICAgICAgICAgaWYgKG1heCA+IDAgJiYgaW5pdGlhbE1heCA8PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBtYXggPSAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX21pblJlYWwgPSBtaW47XHJcbiAgICAgICAgdGhpcy5fbWF4UmVhbCA9IG1heDtcclxuICAgICAgICBsZXQgc3RyaWN0TWluTWF4ID0gdGhpcy5nZXQoXCJzdHJpY3RNaW5NYXhcIik7XHJcbiAgICAgICAgbGV0IHN0cmljdE1pbk1heFNlbGVjdGlvbiA9IHRoaXMuZ2V0KFwic3RyaWN0TWluTWF4U2VsZWN0aW9uXCIsIGZhbHNlKTtcclxuICAgICAgICBpZiAoc3RyaWN0TWluTWF4U2VsZWN0aW9uKSB7XHJcbiAgICAgICAgICAgIHN0cmljdE1pbk1heCA9IHN0cmljdE1pbk1heFNlbGVjdGlvbjtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IHN0cmljdCA9IHN0cmljdE1pbk1heDtcclxuICAgICAgICBpZiAoJHR5cGUuaXNOdW1iZXIobWF4RGVmaW5lZCkpIHtcclxuICAgICAgICAgICAgc3RyaWN0ID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IGdyaWRDb3VudCA9IHRoaXMuZ2V0KFwicmVuZGVyZXJcIikuZ3JpZENvdW50KCk7XHJcbiAgICAgICAgbGV0IG1pbk1heFN0ZXAgPSB0aGlzLl9hZGp1c3RNaW5NYXgobWluLCBtYXgsIGdyaWRDb3VudCwgc3RyaWN0KTtcclxuICAgICAgICBtaW4gPSBtaW5NYXhTdGVwLm1pbjtcclxuICAgICAgICBtYXggPSBtaW5NYXhTdGVwLm1heDtcclxuICAgICAgICAvLyBkbyBpdCBmb3IgdGhlIHNlY29uZCB0aW1lIHdpdGggc3RyaWN0IHRydWUgKGltcG9ydGF0ISlcclxuICAgICAgICBtaW5NYXhTdGVwID0gdGhpcy5fYWRqdXN0TWluTWF4KG1pbiwgbWF4LCBncmlkQ291bnQsIHRydWUpO1xyXG4gICAgICAgIG1pbiA9IG1pbk1heFN0ZXAubWluO1xyXG4gICAgICAgIG1heCA9IG1pbk1heFN0ZXAubWF4O1xyXG4gICAgICAgIC8vIHJldHVybiBtaW4gbWF4IGlmIHN0cmljdFxyXG4gICAgICAgIGlmIChzdHJpY3RNaW5NYXgpIHtcclxuICAgICAgICAgICAgaWYgKCR0eXBlLmlzTnVtYmVyKG1pbkRlZmluZWQpKSB7XHJcbiAgICAgICAgICAgICAgICBtaW4gPSBtaW5EZWZpbmVkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgbWluID0gdGhpcy5fbWluUmVhbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoJHR5cGUuaXNOdW1iZXIobWF4RGVmaW5lZCkpIHtcclxuICAgICAgICAgICAgICAgIG1heCA9IG1heERlZmluZWQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBtYXggPSB0aGlzLl9tYXhSZWFsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChtYXggLSBtaW4gPD0gMC4wMDAwMDAwMSkge1xyXG4gICAgICAgICAgICAgICAgbWluIC09IHRoaXMuX2RlbHRhTWluTWF4O1xyXG4gICAgICAgICAgICAgICAgbWF4ICs9IHRoaXMuX2RlbHRhTWluTWF4O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG1pbiAtPSAobWF4IC0gbWluKSAqIGV4dHJhTWluO1xyXG4gICAgICAgICAgICBtYXggKz0gKG1heCAtIG1pbikgKiBleHRyYU1heDtcclxuICAgICAgICB9XHJcbiAgICAgICAgbWluQWRhcHRlZCA9IHRoaXMuYWRhcHRlcnMuZm9sZChcIm1pblwiLCBtaW4pO1xyXG4gICAgICAgIG1heEFkYXB0ZWQgPSB0aGlzLmFkYXB0ZXJzLmZvbGQoXCJtYXhcIiwgbWF4KTtcclxuICAgICAgICBpZiAoJHR5cGUuaXNOdW1iZXIobWluQWRhcHRlZCkpIHtcclxuICAgICAgICAgICAgbWluID0gbWluQWRhcHRlZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCR0eXBlLmlzTnVtYmVyKG1heEFkYXB0ZWQpKSB7XHJcbiAgICAgICAgICAgIG1heCA9IG1heEFkYXB0ZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChtaW5EaWZmID09IEluZmluaXR5KSB7XHJcbiAgICAgICAgICAgIG1pbkRpZmYgPSAobWF4IC0gbWluKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gdGhpcyBpcyB0byBhdm9pZCBmbG9hdGluZyBwb2ludCBudW1iZXIgZXJyb3JcclxuICAgICAgICBsZXQgZGVjQ291bnQgPSBNYXRoLnJvdW5kKE1hdGguYWJzKE1hdGgubG9nKE1hdGguYWJzKG1heCAtIG1pbikpICogTWF0aC5MT0cxMEUpKSArIDU7XHJcbiAgICAgICAgbWluID0gJG1hdGgucm91bmQobWluLCBkZWNDb3VudCk7XHJcbiAgICAgICAgbWF4ID0gJG1hdGgucm91bmQobWF4LCBkZWNDb3VudCk7XHJcbiAgICAgICAgY29uc3Qgc3luY1dpdGhBeGlzID0gdGhpcy5nZXQoXCJzeW5jV2l0aEF4aXNcIik7XHJcbiAgICAgICAgaWYgKHN5bmNXaXRoQXhpcykge1xyXG4gICAgICAgICAgICBtaW5NYXhTdGVwID0gdGhpcy5fc3luY0F4ZXMobWluLCBtYXgsIG1pbk1heFN0ZXAuc3RlcCwgc3luY1dpdGhBeGlzLmdldFByaXZhdGUoXCJtaW5GaW5hbFwiLCBzeW5jV2l0aEF4aXMuZ2V0UHJpdmF0ZShcIm1pblwiLCAwKSksIHN5bmNXaXRoQXhpcy5nZXRQcml2YXRlKFwibWF4RmluYWxcIiwgc3luY1dpdGhBeGlzLmdldFByaXZhdGUoXCJtYXhcIiwgMSkpLCBzeW5jV2l0aEF4aXMuZ2V0UHJpdmF0ZShcInN0ZXBcIiwgMSkpO1xyXG4gICAgICAgICAgICBtaW4gPSBtaW5NYXhTdGVwLm1pbjtcclxuICAgICAgICAgICAgbWF4ID0gbWluTWF4U3RlcC5tYXg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuc2V0UHJpdmF0ZVJhdyhcIm1heFpvb21GYWN0b3JcIiwgTWF0aC5tYXgoMSwgTWF0aC5jZWlsKChtYXggLSBtaW4pIC8gbWluRGlmZiAqIHRoaXMuZ2V0KFwibWF4Wm9vbUZhY3RvclwiLCAxMDApKSkpO1xyXG4gICAgICAgIHRoaXMuX2ZpeFpvb21GYWN0b3IoKTtcclxuICAgICAgICBpZiAodGhpcy5nZXQoXCJsb2dhcml0aG1pY1wiKSkge1xyXG4gICAgICAgICAgICB0aGlzLl9taW5Mb2dBZGp1c3RlZCA9IG1pbjtcclxuICAgICAgICAgICAgbWluID0gdGhpcy5fbWluUmVhbDtcclxuICAgICAgICAgICAgbWF4ID0gdGhpcy5fbWF4UmVhbDtcclxuICAgICAgICAgICAgaWYgKG1pbiA8PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBtaW4gPSBpbml0aWFsTWluICogKDEgLSBNYXRoLm1pbihleHRyYU1pbiwgMC45OSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICgkdHlwZS5pc051bWJlcihtaW4pICYmICR0eXBlLmlzTnVtYmVyKG1heCkpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuZ2V0UHJpdmF0ZShcIm1pbkZpbmFsXCIpICE9PSBtaW4gfHwgdGhpcy5nZXRQcml2YXRlKFwibWF4RmluYWxcIikgIT09IG1heCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZXRQcml2YXRlKFwibWluRmluYWxcIiwgbWluKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2V0UHJpdmF0ZShcIm1heEZpbmFsXCIsIG1heCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zYXZlTWluTWF4KG1pbiwgbWF4KTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGR1cmF0aW9uID0gdGhpcy5nZXQoXCJpbnRlcnBvbGF0aW9uRHVyYXRpb25cIiwgMCk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBlYXNpbmcgPSB0aGlzLmdldChcImludGVycG9sYXRpb25FYXNpbmdcIik7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFuaW1hdGVQcml2YXRlKHsga2V5OiBcIm1pblwiLCB0bzogbWluLCBkdXJhdGlvbiwgZWFzaW5nIH0pO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hbmltYXRlUHJpdmF0ZSh7IGtleTogXCJtYXhcIiwgdG86IG1heCwgZHVyYXRpb24sIGVhc2luZyB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIF9maXhab29tRmFjdG9yKCkge1xyXG4gICAgfVxyXG4gICAgX2dldERlbHRhKG1heCkge1xyXG4gICAgICAgIC8vIHRoZSBudW1iZXIgYnkgd2hpY2ggd2UgbmVlZCB0byByYWlzZSAxMCB0byBnZXQgZGlmZmVyZW5jZVxyXG4gICAgICAgIGxldCBleHBvbmVudCA9IE1hdGgubG9nKE1hdGguYWJzKG1heCkpICogTWF0aC5MT0cxMEU7XHJcbiAgICAgICAgLy8gaGVyZSB3ZSBmaW5kIGEgbnVtYmVyIHdoaWNoIGlzIHBvd2VyIG9mIDEwIGFuZCBoYXMgdGhlIHNhbWUgY291bnQgb2YgbnVtYmVycyBhcyBkaWZmZXJlbmNlIGhhc1xyXG4gICAgICAgIGxldCBwb3dlciA9IE1hdGgucG93KDEwLCBNYXRoLmZsb29yKGV4cG9uZW50KSk7XHJcbiAgICAgICAgLy8gcmVkdWNlIHRoaXMgbnVtYmVyIGJ5IDEwIHRpbWVzXHJcbiAgICAgICAgcG93ZXIgPSBwb3dlciAvIDEwO1xyXG4gICAgICAgIHRoaXMuX2RlbHRhTWluTWF4ID0gcG93ZXI7XHJcbiAgICB9XHJcbiAgICBfc2F2ZU1pbk1heChfbWluLCBfbWF4KSB7XHJcbiAgICB9XHJcbiAgICBfYWRqdXN0TWluTWF4KG1pbiwgbWF4LCBncmlkQ291bnQsIHN0cmljdE1vZGUpIHtcclxuICAgICAgICAvLyB3aWxsIGZhaWwgaWYgMFxyXG4gICAgICAgIGlmIChncmlkQ291bnQgPD0gMSkge1xyXG4gICAgICAgICAgICBncmlkQ291bnQgPSAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICBncmlkQ291bnQgPSBNYXRoLnJvdW5kKGdyaWRDb3VudCk7XHJcbiAgICAgICAgbGV0IGluaXRpYWxNaW4gPSBtaW47XHJcbiAgICAgICAgbGV0IGluaXRpYWxNYXggPSBtYXg7XHJcbiAgICAgICAgbGV0IGRpZmZlcmVuY2UgPSBtYXggLSBtaW47XHJcbiAgICAgICAgLy8gaW4gY2FzZSBtaW4gYW5kIG1heCBpcyB0aGUgc2FtZSwgdXNlIG1heFxyXG4gICAgICAgIGlmIChkaWZmZXJlbmNlID09PSAwKSB7XHJcbiAgICAgICAgICAgIGRpZmZlcmVuY2UgPSBNYXRoLmFicyhtYXgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyB0aGUgbnVtYmVyIGJ5IHdoaWNoIHdlIG5lZWQgdG8gcmFpc2UgMTAgdG8gZ2V0IGRpZmZlcmVuY2VcclxuICAgICAgICBsZXQgZXhwb25lbnQgPSBNYXRoLmxvZyhNYXRoLmFicyhkaWZmZXJlbmNlKSkgKiBNYXRoLkxPRzEwRTtcclxuICAgICAgICAvLyBoZXJlIHdlIGZpbmQgYSBudW1iZXIgd2hpY2ggaXMgcG93ZXIgb2YgMTAgYW5kIGhhcyB0aGUgc2FtZSBjb3VudCBvZiBudW1iZXJzIGFzIGRpZmZlcmVuY2UgaGFzXHJcbiAgICAgICAgbGV0IHBvd2VyID0gTWF0aC5wb3coMTAsIE1hdGguZmxvb3IoZXhwb25lbnQpKTtcclxuICAgICAgICAvLyByZWR1Y2UgdGhpcyBudW1iZXIgYnkgMTAgdGltZXNcclxuICAgICAgICBwb3dlciA9IHBvd2VyIC8gMTA7XHJcbiAgICAgICAgbGV0IGV4dHJhID0gcG93ZXI7XHJcbiAgICAgICAgaWYgKHN0cmljdE1vZGUpIHtcclxuICAgICAgICAgICAgZXh0cmEgPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyByb3VuZCBkb3duIG1pblxyXG4gICAgICAgIGlmIChzdHJpY3RNb2RlKSB7XHJcbiAgICAgICAgICAgIG1pbiA9IE1hdGguZmxvb3IobWluIC8gcG93ZXIpICogcG93ZXI7XHJcbiAgICAgICAgICAgIC8vIHJvdW5kIHVwIG1heFxyXG4gICAgICAgICAgICBtYXggPSBNYXRoLmNlaWwobWF4IC8gcG93ZXIpICogcG93ZXI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBtaW4gPSBNYXRoLmNlaWwobWluIC8gcG93ZXIpICogcG93ZXIgLSBleHRyYTtcclxuICAgICAgICAgICAgLy8gcm91bmQgdXAgbWF4XHJcbiAgICAgICAgICAgIG1heCA9IE1hdGguZmxvb3IobWF4IC8gcG93ZXIpICogcG93ZXIgKyBleHRyYTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gZG9uJ3QgbGV0IG1pbiBnbyBiZWxvdyAwIGlmIHJlYWwgbWluIGlzID49IDBcclxuICAgICAgICBpZiAobWluIDwgMCAmJiBpbml0aWFsTWluID49IDApIHtcclxuICAgICAgICAgICAgbWluID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gZG9uJ3QgbGV0IG1heCBnbyBhYm92ZSAwIGlmIHJlYWwgbWF4IGlzIDw9IDBcclxuICAgICAgICBpZiAobWF4ID4gMCAmJiBpbml0aWFsTWF4IDw9IDApIHtcclxuICAgICAgICAgICAgbWF4ID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZXhwb25lbnQgPSBNYXRoLmxvZyhNYXRoLmFicyhkaWZmZXJlbmNlKSkgKiBNYXRoLkxPRzEwRTtcclxuICAgICAgICBwb3dlciA9IE1hdGgucG93KDEwLCBNYXRoLmZsb29yKGV4cG9uZW50KSk7XHJcbiAgICAgICAgcG93ZXIgPSBwb3dlciAvIDEwMDsgLy8gdXNlZCB0byBiZSAxMCBpbiB2NCwgYnV0IHRoaXMgY2F1c2VkIGlzc3VlIHRoYXQgdGhlcmUgY291bGQgYmUgbGltaXRlZCBudW1iZXIgb2YgZ3JpZHMgd2l0aCBldmVuIHZlcnkgc21hbGwgbWluR3JpZERpc3RhbmNlXHJcbiAgICAgICAgLy8gYXBwcm94aW1hdGUgZGlmZmVyZW5jZSBiZXR3ZWVuIHR3byBncmlkIGxpbmVzXHJcbiAgICAgICAgbGV0IHN0ZXAgPSBNYXRoLmNlaWwoKGRpZmZlcmVuY2UgLyBncmlkQ291bnQpIC8gcG93ZXIpICogcG93ZXI7XHJcbiAgICAgICAgbGV0IHN0ZXBQb3dlciA9IE1hdGgucG93KDEwLCBNYXRoLmZsb29yKE1hdGgubG9nKE1hdGguYWJzKHN0ZXApKSAqIE1hdGguTE9HMTBFKSk7XHJcbiAgICAgICAgLy8gdGhlIHN0ZXAgc2hvdWxkIGRpdmlkZSBieSAgMiwgNSwgYW5kIDEwLlxyXG4gICAgICAgIGxldCBzdGVwRGl2aXNvciA9IE1hdGguY2VpbChzdGVwIC8gc3RlcFBvd2VyKTsgLy8gbnVtYmVyIDAgLSAxMFxyXG4gICAgICAgIGlmIChzdGVwRGl2aXNvciA+IDUpIHtcclxuICAgICAgICAgICAgc3RlcERpdmlzb3IgPSAxMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoc3RlcERpdmlzb3IgPD0gNSAmJiBzdGVwRGl2aXNvciA+IDIpIHtcclxuICAgICAgICAgICAgc3RlcERpdmlzb3IgPSA1O1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBub3cgZ2V0IHJlYWwgc3RlcFxyXG4gICAgICAgIHN0ZXAgPSBNYXRoLmNlaWwoc3RlcCAvIChzdGVwUG93ZXIgKiBzdGVwRGl2aXNvcikpICogc3RlcFBvd2VyICogc3RlcERpdmlzb3I7XHJcbiAgICAgICAgbGV0IG1heFByZWNpc2lvbiA9IHRoaXMuZ2V0KFwibWF4UHJlY2lzaW9uXCIpO1xyXG4gICAgICAgIGlmICgkdHlwZS5pc051bWJlcihtYXhQcmVjaXNpb24pKSB7XHJcbiAgICAgICAgICAgIGxldCBjZWlsZWRTdGVwID0gJG1hdGguY2VpbChzdGVwLCBtYXhQcmVjaXNpb24pO1xyXG4gICAgICAgICAgICBpZiAobWF4UHJlY2lzaW9uIDwgTnVtYmVyLk1BWF9WQUxVRSAmJiBzdGVwICE9PSBjZWlsZWRTdGVwKSB7XHJcbiAgICAgICAgICAgICAgICBzdGVwID0gY2VpbGVkU3RlcDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgZGVjQ291bnQgPSAwO1xyXG4gICAgICAgIC8vIGluIGNhc2UgbnVtYmVycyBhcmUgc21hbGxlciB0aGFuIDFcclxuICAgICAgICBpZiAoc3RlcFBvd2VyIDwgMSkge1xyXG4gICAgICAgICAgICAvLyBleHBvbmVudCBpcyBsZXNzIHRoZW4gMSB0b28uIENvdW50IGRlY2ltYWxzIG9mIGV4cG9uZW50XHJcbiAgICAgICAgICAgIGRlY0NvdW50ID0gTWF0aC5yb3VuZChNYXRoLmFicyhNYXRoLmxvZyhNYXRoLmFicyhzdGVwUG93ZXIpKSAqIE1hdGguTE9HMTBFKSkgKyAxO1xyXG4gICAgICAgICAgICAvLyByb3VuZCBzdGVwXHJcbiAgICAgICAgICAgIHN0ZXAgPSAkbWF0aC5yb3VuZChzdGVwLCBkZWNDb3VudCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGZpbmFsIG1pbiBhbmQgbWF4XHJcbiAgICAgICAgbGV0IG1pbkNvdW50ID0gTWF0aC5mbG9vcihtaW4gLyBzdGVwKTtcclxuICAgICAgICBtaW4gPSAkbWF0aC5yb3VuZChzdGVwICogbWluQ291bnQsIGRlY0NvdW50KTtcclxuICAgICAgICBsZXQgbWF4Q291bnQ7XHJcbiAgICAgICAgaWYgKCFzdHJpY3RNb2RlKSB7XHJcbiAgICAgICAgICAgIG1heENvdW50ID0gTWF0aC5jZWlsKG1heCAvIHN0ZXApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgbWF4Q291bnQgPSBNYXRoLmZsb29yKG1heCAvIHN0ZXApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobWF4Q291bnQgPT09IG1pbkNvdW50KSB7XHJcbiAgICAgICAgICAgIG1heENvdW50Kys7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG1heCA9ICRtYXRoLnJvdW5kKHN0ZXAgKiBtYXhDb3VudCwgZGVjQ291bnQpO1xyXG4gICAgICAgIGlmIChtYXggPCBpbml0aWFsTWF4KSB7XHJcbiAgICAgICAgICAgIG1heCA9IG1heCArIHN0ZXA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChtaW4gPiBpbml0aWFsTWluKSB7XHJcbiAgICAgICAgICAgIG1pbiA9IG1pbiAtIHN0ZXA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHN0ZXAgPSB0aGlzLmZpeFNtYWxsU3RlcChzdGVwKTtcclxuICAgICAgICByZXR1cm4geyBtaW46IG1pbiwgbWF4OiBtYXgsIHN0ZXA6IHN0ZXAgfTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0ZXh0IHRvIGJlIHVzZWQgaW4gYW4gYXhpcyB0b29sdGlwIGZvciBzcGVjaWZpYyByZWxhdGl2ZSBwb3NpdGlvbi5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gICBwb3NpdGlvbiAgUG9zaXRpb25cclxuICAgICAqIEByZXR1cm4gICAgICAgICAgICBUb29sdGlwIHRleHRcclxuICAgICAqL1xyXG4gICAgZ2V0VG9vbHRpcFRleHQocG9zaXRpb24sIF9hZGp1c3RQb3NpdGlvbikge1xyXG4gICAgICAgIGNvbnN0IG51bWJlckZvcm1hdCA9IHRoaXMuZ2V0KFwidG9vbHRpcE51bWJlckZvcm1hdFwiLCB0aGlzLmdldChcIm51bWJlckZvcm1hdFwiKSk7XHJcbiAgICAgICAgY29uc3QgZm9ybWF0dGVyID0gdGhpcy5nZXROdW1iZXJGb3JtYXR0ZXIoKTtcclxuICAgICAgICBjb25zdCBleHRyYURlY2ltYWxzID0gdGhpcy5nZXQoXCJleHRyYVRvb2x0aXBQcmVjaXNpb25cIiwgMCk7XHJcbiAgICAgICAgY29uc3QgZGVjaW1hbHMgPSB0aGlzLmdldFByaXZhdGUoXCJzdGVwRGVjaW1hbFBsYWNlc1wiLCAwKSArIGV4dHJhRGVjaW1hbHM7XHJcbiAgICAgICAgY29uc3QgdmFsdWUgPSAkbWF0aC5yb3VuZCh0aGlzLnBvc2l0aW9uVG9WYWx1ZShwb3NpdGlvbiksIGRlY2ltYWxzKTtcclxuICAgICAgICBpZiAobnVtYmVyRm9ybWF0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmb3JtYXR0ZXIuZm9ybWF0KHZhbHVlLCBudW1iZXJGb3JtYXQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZvcm1hdHRlci5mb3JtYXQodmFsdWUsIHVuZGVmaW5lZCwgZGVjaW1hbHMpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIGRhdGEgaXRlbSBmcm9tIHNlcmllcyB0aGF0IGlzIGNsb3Nlc3QgdG8gdGhlIGBwb3NpdGlvbmAuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtICAgc2VyaWVzICAgIFNlcmllc1xyXG4gICAgICogQHBhcmFtICAgcG9zaXRpb24gIFJlbGF0aXZlIHBvc2l0aW9uXHJcbiAgICAgKiBAcmV0dXJuICAgICAgICAgICAgRGF0YSBpdGVtXHJcbiAgICAgKi9cclxuICAgIGdldFNlcmllc0l0ZW0oc2VyaWVzLCBwb3NpdGlvbikge1xyXG4gICAgICAgIGxldCBmaWVsZE5hbWUgPSAodGhpcy5nZXRQcml2YXRlKFwibmFtZVwiKSArIHRoaXMuZ2V0KFwicmVuZGVyZXJcIikuZ2V0UHJpdmF0ZShcImxldHRlclwiKSk7XHJcbiAgICAgICAgbGV0IHZhbHVlID0gdGhpcy5wb3NpdGlvblRvVmFsdWUocG9zaXRpb24pO1xyXG4gICAgICAgIGxldCBpbmRleCA9IHVuZGVmaW5lZDtcclxuICAgICAgICBsZXQgb2xkRGlmZjtcclxuICAgICAgICAkYXJyYXkuZWFjaChzZXJpZXMuZGF0YUl0ZW1zLCAoZGF0YUl0ZW0sIGkpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgZGlmZiA9IE1hdGguYWJzKGRhdGFJdGVtLmdldChmaWVsZE5hbWUpIC0gdmFsdWUpO1xyXG4gICAgICAgICAgICBpZiAoaW5kZXggPT09IHVuZGVmaW5lZCB8fCBkaWZmIDwgb2xkRGlmZikge1xyXG4gICAgICAgICAgICAgICAgaW5kZXggPSBpO1xyXG4gICAgICAgICAgICAgICAgb2xkRGlmZiA9IGRpZmY7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICBpZiAoaW5kZXggIT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gc2VyaWVzLmRhdGFJdGVtc1tpbmRleF07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBab29tcyB0aGUgYXhpcyB0byBzcGVjaWZpYyBgc3RhcnRgIGFuZCBgZW5kYCB2YWx1ZXMuXHJcbiAgICAgKlxyXG4gICAgICogT3B0aW9uYWwgYGR1cmF0aW9uYCBzcGVjaWZpZXMgZHVyYXRpb24gb2Ygem9vbSBhbmltYXRpb24gaW4gbWlsbGlzZWNvbmRzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSAgc3RhcnQgICAgIFN0YXJ0IHZhbHVlXHJcbiAgICAgKiBAcGFyYW0gIGVuZCAgICAgICBFbmQgdmFsdWVcclxuICAgICAqIEBwYXJhbSAgZHVyYXRpb24gIER1cmF0aW9uIGluIG1pbGxpc2Vjb25kc1xyXG4gICAgICovXHJcbiAgICB6b29tVG9WYWx1ZXMoc3RhcnQsIGVuZCwgZHVyYXRpb24pIHtcclxuICAgICAgICBjb25zdCBtaW4gPSB0aGlzLmdldFByaXZhdGUoXCJtaW5GaW5hbFwiLCAwKTtcclxuICAgICAgICBjb25zdCBtYXggPSB0aGlzLmdldFByaXZhdGUoXCJtYXhGaW5hbFwiLCAwKTtcclxuICAgICAgICBpZiAodGhpcy5nZXRQcml2YXRlKFwibWluXCIpICE9IG51bGwgJiYgdGhpcy5nZXRQcml2YXRlKFwibWF4XCIpICE9IG51bGwpIHtcclxuICAgICAgICAgICAgdGhpcy56b29tKChzdGFydCAtIG1pbikgLyAobWF4IC0gbWluKSwgKGVuZCAtIG1pbikgLyAobWF4IC0gbWluKSwgZHVyYXRpb24pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU3luY3Mgd2l0aCBhIHRhcmdldCBheGlzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSAgbWluICBNaW5cclxuICAgICAqIEBwYXJhbSAgbWF4ICBNYXhcclxuICAgICAqIEBwYXJhbSAgc3RlcCBTdGVwXHJcbiAgICAgKi9cclxuICAgIF9zeW5jQXhlcyhtaW4sIG1heCwgc3RlcCwgc3luY01pbiwgc3luY01heCwgc3luY1N0ZXApIHtcclxuICAgICAgICBsZXQgYXhpcyA9IHRoaXMuZ2V0KFwic3luY1dpdGhBeGlzXCIpO1xyXG4gICAgICAgIGlmIChheGlzKSB7XHJcbiAgICAgICAgICAgIGxldCBjb3VudCA9IE1hdGgucm91bmQoc3luY01heCAtIHN5bmNNaW4pIC8gc3luY1N0ZXA7XHJcbiAgICAgICAgICAgIGxldCBjdXJyZW50Q291bnQgPSBNYXRoLnJvdW5kKChtYXggLSBtaW4pIC8gc3RlcCk7XHJcbiAgICAgICAgICAgIGxldCBncmlkQ291bnQgPSB0aGlzLmdldChcInJlbmRlcmVyXCIpLmdyaWRDb3VudCgpO1xyXG4gICAgICAgICAgICBpZiAoJHR5cGUuaXNOdW1iZXIoY291bnQpICYmICR0eXBlLmlzTnVtYmVyKGN1cnJlbnRDb3VudCkpIHtcclxuICAgICAgICAgICAgICAgIGxldCBzeW5jZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIGxldCBjID0gMDtcclxuICAgICAgICAgICAgICAgIGxldCBkaWZmID0gKG1heCAtIG1pbikgKiAwLjAxO1xyXG4gICAgICAgICAgICAgICAgbGV0IG9taW4gPSBtaW47XHJcbiAgICAgICAgICAgICAgICBsZXQgb21heCA9IG1heDtcclxuICAgICAgICAgICAgICAgIGxldCBvc3RlcCA9IHN0ZXA7XHJcbiAgICAgICAgICAgICAgICB3aGlsZSAoc3luY2VkICE9IHRydWUpIHtcclxuICAgICAgICAgICAgICAgICAgICBzeW5jZWQgPSB0aGlzLl9jaGVja1N5bmMob21pbiwgb21heCwgb3N0ZXAsIGNvdW50KTtcclxuICAgICAgICAgICAgICAgICAgICBjKys7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGMgPiA1MDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3luY2VkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzeW5jZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGMgLyAzID09IE1hdGgucm91bmQoYyAvIDMpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbWluID0gbWluIC0gZGlmZiAqIGM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobWluID49IDAgJiYgb21pbiA8IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbWluID0gMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9tYXggPSBtYXggKyBkaWZmICogYztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvbWF4IDw9IDAgJiYgb21heCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbWF4ID0gMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgbWluTWF4U3RlcCA9IHRoaXMuX2FkanVzdE1pbk1heChvbWluLCBvbWF4LCBncmlkQ291bnQsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvbWluID0gbWluTWF4U3RlcC5taW47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9tYXggPSBtaW5NYXhTdGVwLm1heDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb3N0ZXAgPSBtaW5NYXhTdGVwLnN0ZXA7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtaW4gPSBvbWluO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXggPSBvbWF4O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGVwID0gb3N0ZXA7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB7IG1pbjogbWluLCBtYXg6IG1heCwgc3RlcDogc3RlcCB9O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGB0cnVlYCBpZiBheGlzIG5lZWRzIHRvIGJlIHJlc3VuY2VkIHdpdGggc29tZSBvdGhlciBheGlzLlxyXG4gICAgICovXHJcbiAgICBfY2hlY2tTeW5jKG1pbiwgbWF4LCBzdGVwLCBjb3VudCkge1xyXG4gICAgICAgIGxldCBjdXJyZW50Q291bnQgPSAobWF4IC0gbWluKSAvIHN0ZXA7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBjb3VudDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmICgkbWF0aC5yb3VuZChjdXJyZW50Q291bnQgLyBpLCAxKSA9PSBjb3VudCB8fCBjdXJyZW50Q291bnQgKiBpID09IGNvdW50KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgcmVsYXRpdmUgcG9zaXRpb24gYmV0d2VlbiB0d28gZ3JpZCBsaW5lcyBvZiB0aGUgYXhpcy5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJuIFBvc2l0aW9uXHJcbiAgICAgKi9cclxuICAgIGdldENlbGxXaWR0aFBvc2l0aW9uKCkge1xyXG4gICAgICAgIGxldCBtYXggPSB0aGlzLmdldFByaXZhdGUoXCJzZWxlY3Rpb25NYXhcIiwgdGhpcy5nZXRQcml2YXRlKFwibWF4XCIpKTtcclxuICAgICAgICBsZXQgbWluID0gdGhpcy5nZXRQcml2YXRlKFwic2VsZWN0aW9uTWluXCIsIHRoaXMuZ2V0UHJpdmF0ZShcIm1pblwiKSk7XHJcbiAgICAgICAgaWYgKCR0eXBlLmlzTnVtYmVyKG1heCkgJiYgJHR5cGUuaXNOdW1iZXIobWluKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRQcml2YXRlKFwic3RlcFwiLCAxKSAvIChtYXggLSBtaW4pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gMC4wNTtcclxuICAgIH1cclxufVxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoVmFsdWVBeGlzLCBcImNsYXNzTmFtZVwiLCB7XHJcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICB2YWx1ZTogXCJWYWx1ZUF4aXNcIlxyXG59KTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFZhbHVlQXhpcywgXCJjbGFzc05hbWVzXCIsIHtcclxuICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgIHZhbHVlOiBBeGlzLmNsYXNzTmFtZXMuY29uY2F0KFtWYWx1ZUF4aXMuY2xhc3NOYW1lXSlcclxufSk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVZhbHVlQXhpcy5qcy5tYXAiLCJpbXBvcnQgeyBfX2F3YWl0ZXIgfSBmcm9tIFwidHNsaWJcIjtcclxuaW1wb3J0IHsgWFlTZXJpZXMgfSBmcm9tIFwiLi9YWVNlcmllc1wiO1xyXG5pbXBvcnQgeyBQZXJjZW50IH0gZnJvbSBcIi4uLy4uLy4uL2NvcmUvdXRpbC9QZXJjZW50XCI7XHJcbmltcG9ydCB7IHZpc3VhbFNldHRpbmdzIH0gZnJvbSBcIi4uLy4uLy4uL2NvcmUvcmVuZGVyL0dyYXBoaWNzXCI7XHJcbmltcG9ydCAqIGFzICRhcnJheSBmcm9tIFwiLi4vLi4vLi4vY29yZS91dGlsL0FycmF5XCI7XHJcbmltcG9ydCAqIGFzICR0eXBlIGZyb20gXCIuLi8uLi8uLi9jb3JlL3V0aWwvVHlwZVwiO1xyXG4vKipcclxuICogQmFzZSBjbGFzcyBmb3IgYWxsIFwiY29sdW1uLWJhc2VkXCIgc2VyaWVzXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgQmFzZUNvbHVtblNlcmllcyBleHRlbmRzIFhZU2VyaWVzIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX3BoXCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IDBcclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfcHdcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogMFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgX21ha2VHcmFwaGljcyhsaXN0VGVtcGxhdGUsIGRhdGFJdGVtKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubWFrZUNvbHVtbihkYXRhSXRlbSwgbGlzdFRlbXBsYXRlKTtcclxuICAgIH1cclxuICAgIF9tYWtlRmllbGROYW1lcygpIHtcclxuICAgICAgICBzdXBlci5fbWFrZUZpZWxkTmFtZXMoKTtcclxuICAgICAgICBjb25zdCB4QXhpcyA9IHRoaXMuZ2V0KFwieEF4aXNcIik7XHJcbiAgICAgICAgY29uc3QgeUF4aXMgPSB0aGlzLmdldChcInlBeGlzXCIpO1xyXG4gICAgICAgIGNvbnN0IGNhdGVnb3J5QXhpcyA9IFwiQ2F0ZWdvcnlBeGlzXCI7XHJcbiAgICAgICAgY29uc3QgdmFsdWVBeGlzID0gXCJWYWx1ZUF4aXNcIjtcclxuICAgICAgICBpZiAoeEF4aXMuaXNUeXBlKGNhdGVnb3J5QXhpcykpIHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLmdldChcIm9wZW5DYXRlZ29yeVhGaWVsZFwiKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5feE9wZW5GaWVsZCA9IHRoaXMuX3hGaWVsZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoeEF4aXMuaXNUeXBlKHZhbHVlQXhpcykpIHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLmdldChcIm9wZW5WYWx1ZVhGaWVsZFwiKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5feE9wZW5GaWVsZCA9IHRoaXMuX3hGaWVsZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoeUF4aXMuaXNUeXBlKGNhdGVnb3J5QXhpcykpIHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLmdldChcIm9wZW5DYXRlZ29yeVlGaWVsZFwiKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5feU9wZW5GaWVsZCA9IHRoaXMuX3lGaWVsZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoeUF4aXMuaXNUeXBlKHZhbHVlQXhpcykpIHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLmdldChcIm9wZW5WYWx1ZVlGaWVsZFwiKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5feU9wZW5GaWVsZCA9IHRoaXMuX3lGaWVsZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIF9wcmVwYXJlQ2hpbGRyZW4oKSB7XHJcbiAgICAgICAgc3VwZXIuX3ByZXBhcmVDaGlsZHJlbigpO1xyXG4gICAgICAgIGNvbnN0IHhBeGlzID0gdGhpcy5nZXQoXCJ4QXhpc1wiKTtcclxuICAgICAgICBjb25zdCB5QXhpcyA9IHRoaXMuZ2V0KFwieUF4aXNcIik7XHJcbiAgICAgICAgY29uc3QgbGVuID0gdGhpcy5kYXRhSXRlbXMubGVuZ3RoO1xyXG4gICAgICAgIGNvbnN0IHN0YXJ0SW5kZXggPSBNYXRoLm1heCgwLCB0aGlzLnN0YXJ0SW5kZXgoKSAtIDIpO1xyXG4gICAgICAgIGNvbnN0IGVuZEluZGV4ID0gTWF0aC5taW4odGhpcy5lbmRJbmRleCgpICsgMiwgbGVuIC0gMSk7XHJcbiAgICAgICAgaWYgKHhBeGlzLmluaXRlZCAmJiB5QXhpcy5pbml0ZWQpIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IHN0YXJ0SW5kZXg7IGkgPD0gZW5kSW5kZXg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgbGV0IGRhdGFJdGVtID0gdGhpcy5kYXRhSXRlbXNbaV07XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9jcmVhdGVHcmFwaGljcyhkYXRhSXRlbSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBfdXBkYXRlQ2hpbGRyZW4oKSB7XHJcbiAgICAgICAgY29uc3QgY2hhcnQgPSB0aGlzLmNoYXJ0O1xyXG4gICAgICAgIGlmIChjaGFydCkge1xyXG4gICAgICAgICAgICB0aGlzLl9waCA9IGNoYXJ0LnBsb3RDb250YWluZXIuaGVpZ2h0KCk7XHJcbiAgICAgICAgICAgIHRoaXMuX3B3ID0gY2hhcnQucGxvdENvbnRhaW5lci53aWR0aCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCB4QXhpcyA9IHRoaXMuZ2V0KFwieEF4aXNcIik7XHJcbiAgICAgICAgY29uc3QgeUF4aXMgPSB0aGlzLmdldChcInlBeGlzXCIpO1xyXG4gICAgICAgIGNvbnN0IGJhc2VBeGlzID0gdGhpcy5nZXQoXCJiYXNlQXhpc1wiKTtcclxuICAgICAgICBjb25zdCBjb2x1bW5zVGVtcGxhdGUgPSB0aGlzLmNvbHVtbnMudGVtcGxhdGU7XHJcbiAgICAgICAgaWYgKHRoaXMuaXNEaXJ0eShcImZpbGxcIikpIHtcclxuICAgICAgICAgICAgaWYgKGNvbHVtbnNUZW1wbGF0ZS5nZXQoXCJmaWxsXCIpID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIGNvbHVtbnNUZW1wbGF0ZS5zZXQoXCJmaWxsXCIsIHRoaXMuZ2V0KFwiZmlsbFwiKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuaXNEaXJ0eShcInN0cm9rZVwiKSkge1xyXG4gICAgICAgICAgICBpZiAoY29sdW1uc1RlbXBsYXRlLmdldChcInN0cm9rZVwiKSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBjb2x1bW5zVGVtcGxhdGUuc2V0KFwic3Ryb2tlXCIsIHRoaXMuZ2V0KFwic3Ryb2tlXCIpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgaW5kZXggPSAwO1xyXG4gICAgICAgIGxldCBjbHVzdGVyQ291bnQgPSAwO1xyXG4gICAgICAgIGxldCBpID0gMDtcclxuICAgICAgICAkYXJyYXkuZWFjaChiYXNlQXhpcy5zZXJpZXMsIChzZXJpZXMpID0+IHtcclxuICAgICAgICAgICAgaWYgKHNlcmllcyBpbnN0YW5jZW9mIEJhc2VDb2x1bW5TZXJpZXMpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHN0YWNrZWQgPSBzZXJpZXMuZ2V0KFwic3RhY2tlZFwiKTtcclxuICAgICAgICAgICAgICAgIGlmIChzdGFja2VkICYmIGkgPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNsdXN0ZXJDb3VudCsrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKCFzdGFja2VkICYmIHNlcmllcy5nZXQoXCJjbHVzdGVyZWRcIikpIHtcclxuICAgICAgICAgICAgICAgICAgICBjbHVzdGVyQ291bnQrKztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoc2VyaWVzID09PSB0aGlzKSB7XHJcbiAgICAgICAgICAgICAgICBpbmRleCA9IGNsdXN0ZXJDb3VudCAtIDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaSsrO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGlmICghdGhpcy5nZXQoXCJjbHVzdGVyZWRcIikpIHtcclxuICAgICAgICAgICAgaW5kZXggPSAwO1xyXG4gICAgICAgICAgICBjbHVzdGVyQ291bnQgPSAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY2x1c3RlckNvdW50ID09PSAwKSB7XHJcbiAgICAgICAgICAgIGNsdXN0ZXJDb3VudCA9IDE7XHJcbiAgICAgICAgICAgIGluZGV4ID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgeFJlbmRlcmVyID0geEF4aXMuZ2V0KFwicmVuZGVyZXJcIik7XHJcbiAgICAgICAgY29uc3QgeVJlbmRlcmVyID0geUF4aXMuZ2V0KFwicmVuZGVyZXJcIik7XHJcbiAgICAgICAgY29uc3QgY2VsbFN0YXJ0TG9jYXRpb24gPSBcImNlbGxTdGFydExvY2F0aW9uXCI7XHJcbiAgICAgICAgY29uc3QgY2VsbEVuZExvY2F0aW9uID0gXCJjZWxsRW5kTG9jYXRpb25cIjtcclxuICAgICAgICBjb25zdCBjZWxsTG9jYXRpb25YMCA9IHhSZW5kZXJlci5nZXQoY2VsbFN0YXJ0TG9jYXRpb24sIDApO1xyXG4gICAgICAgIGNvbnN0IGNlbGxMb2NhdGlvblgxID0geFJlbmRlcmVyLmdldChjZWxsRW5kTG9jYXRpb24sIDEpO1xyXG4gICAgICAgIGNvbnN0IGNlbGxMb2NhdGlvblkwID0geVJlbmRlcmVyLmdldChjZWxsU3RhcnRMb2NhdGlvbiwgMCk7XHJcbiAgICAgICAgY29uc3QgY2VsbExvY2F0aW9uWTEgPSB5UmVuZGVyZXIuZ2V0KGNlbGxFbmRMb2NhdGlvbiwgMSk7XHJcbiAgICAgICAgdGhpcy5fYUxvY2F0aW9uWDAgPSBjZWxsTG9jYXRpb25YMCArIChpbmRleCAvIGNsdXN0ZXJDb3VudCkgKiAoY2VsbExvY2F0aW9uWDEgLSBjZWxsTG9jYXRpb25YMCk7XHJcbiAgICAgICAgdGhpcy5fYUxvY2F0aW9uWDEgPSBjZWxsTG9jYXRpb25YMCArIChpbmRleCArIDEpIC8gY2x1c3RlckNvdW50ICogKGNlbGxMb2NhdGlvblgxIC0gY2VsbExvY2F0aW9uWDApO1xyXG4gICAgICAgIDtcclxuICAgICAgICB0aGlzLl9hTG9jYXRpb25ZMCA9IGNlbGxMb2NhdGlvblkwICsgKGluZGV4IC8gY2x1c3RlckNvdW50KSAqIChjZWxsTG9jYXRpb25ZMSAtIGNlbGxMb2NhdGlvblkwKTtcclxuICAgICAgICB0aGlzLl9hTG9jYXRpb25ZMSA9IGNlbGxMb2NhdGlvblkwICsgKGluZGV4ICsgMSkgLyBjbHVzdGVyQ291bnQgKiAoY2VsbExvY2F0aW9uWTEgLSBjZWxsTG9jYXRpb25ZMCk7XHJcbiAgICAgICAgaWYgKHhBeGlzLmluaXRlZCAmJiB5QXhpcy5pbml0ZWQpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX2F4ZXNEaXJ0eSB8fCB0aGlzLl92YWx1ZXNEaXJ0eSB8fCB0aGlzLl9zdGFja0RpcnR5IHx8IHRoaXMuaXNEaXJ0eShcInZjeFwiKSB8fCB0aGlzLmlzRGlydHkoXCJ2Y3lcIikgfHwgdGhpcy5fc2l6ZURpcnR5KSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBsZW4gPSB0aGlzLmRhdGFJdGVtcy5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICBsZXQgc3RhcnRJbmRleCA9IE1hdGgubWF4KDAsIHRoaXMuc3RhcnRJbmRleCgpIC0gMik7XHJcbiAgICAgICAgICAgICAgICBsZXQgZW5kSW5kZXggPSBNYXRoLm1pbih0aGlzLmVuZEluZGV4KCkgKyAyLCBsZW4gLSAxKTtcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RhcnRJbmRleDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdG9nZ2xlQ29sdW1uKHRoaXMuZGF0YUl0ZW1zW2ldLCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBsZXQgcHJldmlvdXMgPSB0aGlzLmRhdGFJdGVtc1tzdGFydEluZGV4XTtcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSBzdGFydEluZGV4OyBpIDw9IGVuZEluZGV4OyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgZGF0YUl0ZW0gPSB0aGlzLmRhdGFJdGVtc1tpXTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YUl0ZW0uZ2V0KFwidmFsdWVYXCIpICE9IG51bGwgJiYgZGF0YUl0ZW0uZ2V0KFwidmFsdWVZXCIpICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcHJldmlvdXMgPSBkYXRhSXRlbTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGkgPiAwICYmIHN0YXJ0SW5kZXggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gaSAtIDE7IGogPj0gMDsgai0tKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGRhdGFJdGVtID0gdGhpcy5kYXRhSXRlbXNbal07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGFJdGVtLmdldChcInZhbHVlWFwiKSAhPSBudWxsICYmIGRhdGFJdGVtLmdldChcInZhbHVlWVwiKSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZXZpb3VzID0gZGF0YUl0ZW07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3RvZ2dsZUNvbHVtbihkYXRhSXRlbSwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSBzdGFydEluZGV4OyBpIDw9IGVuZEluZGV4OyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgZGF0YUl0ZW0gPSB0aGlzLmRhdGFJdGVtc1tpXTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGVHcmFwaGljcyhkYXRhSXRlbSwgcHJldmlvdXMpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChkYXRhSXRlbS5nZXQoXCJ2YWx1ZVhcIikgIT0gbnVsbCAmJiBkYXRhSXRlbS5nZXQoXCJ2YWx1ZVlcIikgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmV2aW91cyA9IGRhdGFJdGVtO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSBlbmRJbmRleCArIDE7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3RvZ2dsZUNvbHVtbih0aGlzLmRhdGFJdGVtc1tpXSwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLl9za2lwcGVkID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy51cGRhdGVMZWdlbmRNYXJrZXIodGhpcy5nZXQoXCJ0b29sdGlwRGF0YUl0ZW1cIikpO1xyXG4gICAgICAgIHN1cGVyLl91cGRhdGVDaGlsZHJlbigpO1xyXG4gICAgfVxyXG4gICAgX2NyZWF0ZUdyYXBoaWNzKGRhdGFJdGVtKSB7XHJcbiAgICAgICAgbGV0IGdyYXBoaWNzID0gZGF0YUl0ZW0uZ2V0KFwiZ3JhcGhpY3NcIik7XHJcbiAgICAgICAgaWYgKCFncmFwaGljcykge1xyXG4gICAgICAgICAgICBncmFwaGljcyA9IHRoaXMuX21ha2VHcmFwaGljcyh0aGlzLmNvbHVtbnMsIGRhdGFJdGVtKTtcclxuICAgICAgICAgICAgZGF0YUl0ZW0uc2V0KFwiZ3JhcGhpY3NcIiwgZ3JhcGhpY3MpO1xyXG4gICAgICAgICAgICBncmFwaGljcy5fc2V0RGF0YUl0ZW0oZGF0YUl0ZW0pO1xyXG4gICAgICAgICAgICBjb25zdCBsZWdlbmREYXRhSXRlbSA9IGRhdGFJdGVtLmdldChcImxlZ2VuZERhdGFJdGVtXCIpO1xyXG4gICAgICAgICAgICBpZiAobGVnZW5kRGF0YUl0ZW0pIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG1hcmtlclJlY3RhbmdsZSA9IGxlZ2VuZERhdGFJdGVtLmdldChcIm1hcmtlclJlY3RhbmdsZVwiKTtcclxuICAgICAgICAgICAgICAgIGlmIChtYXJrZXJSZWN0YW5nbGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBkcyA9IG1hcmtlclJlY3RhbmdsZS5zdGF0ZXMubG9va3VwKFwiZGVmYXVsdFwiKTtcclxuICAgICAgICAgICAgICAgICAgICAkYXJyYXkuZWFjaCh2aXN1YWxTZXR0aW5ncywgKHNldHRpbmcpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBncmFwaGljcy5nZXQoc2V0dGluZywgdGhpcy5nZXQoc2V0dGluZykpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXJrZXJSZWN0YW5nbGUuc2V0KHNldHRpbmcsIHZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZHMuc2V0KHNldHRpbmcsIHZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsZXQgZ3JhcGhpY3NBcnJheSA9IGRhdGFJdGVtLmdldChcInJhbmdlR3JhcGhpY3NcIik7XHJcbiAgICAgICAgICAgIGlmIChncmFwaGljc0FycmF5KSB7XHJcbiAgICAgICAgICAgICAgICAkYXJyYXkuZWFjaChncmFwaGljc0FycmF5LCAoZ3JhcGhpY3MpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBncmFwaGljcy5kaXNwb3NlKCk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBncmFwaGljc0FycmF5ID0gW107XHJcbiAgICAgICAgICAgIGRhdGFJdGVtLnNldFJhdyhcInJhbmdlR3JhcGhpY3NcIiwgZ3JhcGhpY3NBcnJheSk7XHJcbiAgICAgICAgICAgIHRoaXMuYXhpc1Jhbmdlcy5lYWNoKChheGlzUmFuZ2UpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IGF4aXNSYW5nZS5jb250YWluZXI7XHJcbiAgICAgICAgICAgICAgICBjb25zdCByYW5nZUdyYXBoaWNzID0gdGhpcy5fbWFrZUdyYXBoaWNzKGF4aXNSYW5nZS5jb2x1bW5zLCBkYXRhSXRlbSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoZ3JhcGhpY3NBcnJheSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGdyYXBoaWNzQXJyYXkucHVzaChyYW5nZUdyYXBoaWNzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJhbmdlR3JhcGhpY3Muc2V0UHJpdmF0ZShcImxpc3RcIiwgYXhpc1JhbmdlLmNvbHVtbnMpO1xyXG4gICAgICAgICAgICAgICAgY29udGFpbmVyLmNoaWxkcmVuLnB1c2gocmFuZ2VHcmFwaGljcyk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGNyZWF0ZUF4aXNSYW5nZShheGlzRGF0YUl0ZW0pIHtcclxuICAgICAgICAkYXJyYXkuZWFjaCh0aGlzLmRhdGFJdGVtcywgKGRhdGFJdGVtKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGdyYXBoaWNzID0gZGF0YUl0ZW0uZ2V0KFwiZ3JhcGhpY3NcIik7XHJcbiAgICAgICAgICAgIGlmIChncmFwaGljcykge1xyXG4gICAgICAgICAgICAgICAgZ3JhcGhpY3MuZGlzcG9zZSgpO1xyXG4gICAgICAgICAgICAgICAgZGF0YUl0ZW0uc2V0KFwiZ3JhcGhpY3NcIiwgdW5kZWZpbmVkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBzdXBlci5jcmVhdGVBeGlzUmFuZ2UoYXhpc0RhdGFJdGVtKTtcclxuICAgIH1cclxuICAgIF91cGRhdGVHcmFwaGljcyhkYXRhSXRlbSwgcHJldmlvdXNEYXRhSXRlbSkge1xyXG4gICAgICAgIGxldCBncmFwaGljcyA9IGRhdGFJdGVtLmdldChcImdyYXBoaWNzXCIpO1xyXG4gICAgICAgIC8vaWYgKCFncmFwaGljcykge1xyXG4gICAgICAgIC8vXHR0aGlzLl9jcmVhdGVHcmFwaGljcyhkYXRhSXRlbSk7XHJcbiAgICAgICAgLy9cdGdyYXBoaWNzID0gZGF0YUl0ZW0uZ2V0KFwiZ3JhcGhpY3NcIikhO1xyXG4gICAgICAgIC8vfVxyXG4gICAgICAgIGNvbnN0IHhGaWVsZCA9IHRoaXMuX3hGaWVsZDtcclxuICAgICAgICBjb25zdCB5RmllbGQgPSB0aGlzLl95RmllbGQ7XHJcbiAgICAgICAgY29uc3QgdmFsdWVYID0gZGF0YUl0ZW0uZ2V0KHhGaWVsZCk7XHJcbiAgICAgICAgY29uc3QgdmFsdWVZID0gZGF0YUl0ZW0uZ2V0KHlGaWVsZCk7XHJcbiAgICAgICAgaWYgKHZhbHVlWCAhPSBudWxsICYmIHZhbHVlWSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHhPcGVuRmllbGQgPSB0aGlzLl94T3BlbkZpZWxkO1xyXG4gICAgICAgICAgICBjb25zdCB5T3BlbkZpZWxkID0gdGhpcy5feU9wZW5GaWVsZDtcclxuICAgICAgICAgICAgY29uc3QgbG9jYXRpb25YID0gdGhpcy5nZXQoXCJsb2NhdGlvblhcIiwgZGF0YUl0ZW0uZ2V0KFwibG9jYXRpb25YXCIsIDAuNSkpO1xyXG4gICAgICAgICAgICBjb25zdCBsb2NhdGlvblkgPSB0aGlzLmdldChcImxvY2F0aW9uWVwiLCBkYXRhSXRlbS5nZXQoXCJsb2NhdGlvbllcIiwgMC41KSk7XHJcbiAgICAgICAgICAgIGNvbnN0IG9wZW5Mb2NhdGlvblggPSB0aGlzLmdldChcIm9wZW5Mb2NhdGlvblhcIiwgZGF0YUl0ZW0uZ2V0KFwib3BlbkxvY2F0aW9uWFwiLCBsb2NhdGlvblgpKTtcclxuICAgICAgICAgICAgY29uc3Qgb3BlbkxvY2F0aW9uWSA9IHRoaXMuZ2V0KFwib3BlbkxvY2F0aW9uWVwiLCBkYXRhSXRlbS5nZXQoXCJvcGVuTG9jYXRpb25ZXCIsIGxvY2F0aW9uWSkpO1xyXG4gICAgICAgICAgICBjb25zdCB3aWR0aCA9IGdyYXBoaWNzLmdldChcIndpZHRoXCIpO1xyXG4gICAgICAgICAgICBjb25zdCBoZWlnaHQgPSBncmFwaGljcy5nZXQoXCJoZWlnaHRcIik7XHJcbiAgICAgICAgICAgIGNvbnN0IHN0YWNrZWQgPSB0aGlzLmdldChcInN0YWNrZWRcIik7XHJcbiAgICAgICAgICAgIGNvbnN0IHhBeGlzID0gdGhpcy5nZXQoXCJ4QXhpc1wiKTtcclxuICAgICAgICAgICAgY29uc3QgeUF4aXMgPSB0aGlzLmdldChcInlBeGlzXCIpO1xyXG4gICAgICAgICAgICBjb25zdCBiYXNlQXhpcyA9IHRoaXMuZ2V0KFwiYmFzZUF4aXNcIik7XHJcbiAgICAgICAgICAgIGNvbnN0IHhTdGFydCA9IHhBeGlzLmdldChcInN0YXJ0XCIpO1xyXG4gICAgICAgICAgICBjb25zdCB4RW5kID0geEF4aXMuZ2V0KFwiZW5kXCIpO1xyXG4gICAgICAgICAgICBjb25zdCB5U3RhcnQgPSB5QXhpcy5nZXQoXCJzdGFydFwiKTtcclxuICAgICAgICAgICAgY29uc3QgeUVuZCA9IHlBeGlzLmdldChcImVuZFwiKTtcclxuICAgICAgICAgICAgbGV0IGw7XHJcbiAgICAgICAgICAgIGxldCByO1xyXG4gICAgICAgICAgICBsZXQgdDtcclxuICAgICAgICAgICAgbGV0IGI7XHJcbiAgICAgICAgICAgIGxldCB2Y3kgPSB0aGlzLmdldChcInZjeVwiLCAxKTtcclxuICAgICAgICAgICAgbGV0IHZjeCA9IHRoaXMuZ2V0KFwidmN4XCIsIDEpO1xyXG4gICAgICAgICAgICBsZXQgZml0VyA9IGZhbHNlO1xyXG4gICAgICAgICAgICBsZXQgZml0SCA9IGZhbHNlO1xyXG4gICAgICAgICAgICBpZiAoeUF4aXMuaXNUeXBlKFwiQ2F0ZWdvcnlBeGlzXCIpICYmIHhBeGlzLmlzVHlwZShcIkNhdGVnb3J5QXhpc1wiKSkge1xyXG4gICAgICAgICAgICAgICAgbGV0IHN0YXJ0TG9jYXRpb24gPSB0aGlzLl9hTG9jYXRpb25YMCArIG9wZW5Mb2NhdGlvblggLSAwLjU7XHJcbiAgICAgICAgICAgICAgICBsZXQgZW5kTG9jYXRpb24gPSB0aGlzLl9hTG9jYXRpb25YMSArIGxvY2F0aW9uWCAtIDAuNTtcclxuICAgICAgICAgICAgICAgIGlmICh3aWR0aCBpbnN0YW5jZW9mIFBlcmNlbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgb2Zmc2V0ID0gKGVuZExvY2F0aW9uIC0gc3RhcnRMb2NhdGlvbikgKiAoMSAtIHdpZHRoLnZhbHVlKSAvIDI7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRMb2NhdGlvbiArPSBvZmZzZXQ7XHJcbiAgICAgICAgICAgICAgICAgICAgZW5kTG9jYXRpb24gLT0gb2Zmc2V0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgbCA9IHhBeGlzLmdldERhdGFJdGVtUG9zaXRpb25YKGRhdGFJdGVtLCB4T3BlbkZpZWxkLCBzdGFydExvY2F0aW9uLCB2Y3gpO1xyXG4gICAgICAgICAgICAgICAgciA9IHhBeGlzLmdldERhdGFJdGVtUG9zaXRpb25YKGRhdGFJdGVtLCB4RmllbGQsIGVuZExvY2F0aW9uLCB2Y3gpO1xyXG4gICAgICAgICAgICAgICAgc3RhcnRMb2NhdGlvbiA9IHRoaXMuX2FMb2NhdGlvblkwICsgb3BlbkxvY2F0aW9uWSAtIDAuNTtcclxuICAgICAgICAgICAgICAgIGVuZExvY2F0aW9uID0gdGhpcy5fYUxvY2F0aW9uWTEgKyBsb2NhdGlvblkgLSAwLjU7XHJcbiAgICAgICAgICAgICAgICBpZiAoaGVpZ2h0IGluc3RhbmNlb2YgUGVyY2VudCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBvZmZzZXQgPSAoZW5kTG9jYXRpb24gLSBzdGFydExvY2F0aW9uKSAqICgxIC0gaGVpZ2h0LnZhbHVlKSAvIDI7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRMb2NhdGlvbiArPSBvZmZzZXQ7XHJcbiAgICAgICAgICAgICAgICAgICAgZW5kTG9jYXRpb24gLT0gb2Zmc2V0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdCA9IHlBeGlzLmdldERhdGFJdGVtUG9zaXRpb25ZKGRhdGFJdGVtLCB5T3BlbkZpZWxkLCBzdGFydExvY2F0aW9uLCB2Y3kpO1xyXG4gICAgICAgICAgICAgICAgYiA9IHlBeGlzLmdldERhdGFJdGVtUG9zaXRpb25ZKGRhdGFJdGVtLCB5RmllbGQsIGVuZExvY2F0aW9uLCB2Y3kpO1xyXG4gICAgICAgICAgICAgICAgZGF0YUl0ZW0uc2V0UmF3KFwicG9pbnRcIiwgeyB4OiBsICsgKHIgLSBsKSAvIDIsIHk6IHQgKyAoYiAtIHQpIC8gMiB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh4QXhpcyA9PT0gYmFzZUF4aXMpIHtcclxuICAgICAgICAgICAgICAgIGxldCBzdGFydExvY2F0aW9uID0gdGhpcy5fYUxvY2F0aW9uWDAgKyBvcGVuTG9jYXRpb25YIC0gMC41O1xyXG4gICAgICAgICAgICAgICAgbGV0IGVuZExvY2F0aW9uID0gdGhpcy5fYUxvY2F0aW9uWDEgKyBsb2NhdGlvblggLSAwLjU7XHJcbiAgICAgICAgICAgICAgICBpZiAod2lkdGggaW5zdGFuY2VvZiBQZXJjZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IG9mZnNldCA9IChlbmRMb2NhdGlvbiAtIHN0YXJ0TG9jYXRpb24pICogKDEgLSB3aWR0aC52YWx1ZSkgLyAyO1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0TG9jYXRpb24gKz0gb2Zmc2V0O1xyXG4gICAgICAgICAgICAgICAgICAgIGVuZExvY2F0aW9uIC09IG9mZnNldDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGwgPSB4QXhpcy5nZXREYXRhSXRlbVBvc2l0aW9uWChkYXRhSXRlbSwgeE9wZW5GaWVsZCwgc3RhcnRMb2NhdGlvbiwgdmN4KTtcclxuICAgICAgICAgICAgICAgIHIgPSB4QXhpcy5nZXREYXRhSXRlbVBvc2l0aW9uWChkYXRhSXRlbSwgeEZpZWxkLCBlbmRMb2NhdGlvbiwgdmN4KTtcclxuICAgICAgICAgICAgICAgIHQgPSB5QXhpcy5nZXREYXRhSXRlbVBvc2l0aW9uWShkYXRhSXRlbSwgeUZpZWxkLCBsb2NhdGlvblksIHZjeSk7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5feU9wZW5GaWVsZCAhPT0gdGhpcy5feUZpZWxkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYiA9IHlBeGlzLmdldERhdGFJdGVtUG9zaXRpb25ZKGRhdGFJdGVtLCB5T3BlbkZpZWxkLCBvcGVuTG9jYXRpb25ZLCB2Y3kpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YWNrZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHN0YWNrVG9JdGVtWSA9IGRhdGFJdGVtLmdldChcInN0YWNrVG9JdGVtWVwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0YWNrVG9JdGVtWSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYiA9IHlBeGlzLmdldERhdGFJdGVtUG9zaXRpb25ZKHN0YWNrVG9JdGVtWSwgeUZpZWxkLCBvcGVuTG9jYXRpb25ZLCBzdGFja1RvSXRlbVkuY29tcG9uZW50LmdldChcInZjeVwiKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiID0geUF4aXMuYmFzZVBvc2l0aW9uKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGIgPSB5QXhpcy5iYXNlUG9zaXRpb24oKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBkYXRhSXRlbS5zZXRSYXcoXCJwb2ludFwiLCB7IHg6IGwgKyAociAtIGwpIC8gMiwgeTogdCB9KTtcclxuICAgICAgICAgICAgICAgIGZpdEggPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHlBeGlzID09PSBiYXNlQXhpcykge1xyXG4gICAgICAgICAgICAgICAgbGV0IHN0YXJ0TG9jYXRpb24gPSB0aGlzLl9hTG9jYXRpb25ZMCArIG9wZW5Mb2NhdGlvblkgLSAwLjU7XHJcbiAgICAgICAgICAgICAgICBsZXQgZW5kTG9jYXRpb24gPSB0aGlzLl9hTG9jYXRpb25ZMSArIGxvY2F0aW9uWSAtIDAuNTtcclxuICAgICAgICAgICAgICAgIGlmIChoZWlnaHQgaW5zdGFuY2VvZiBQZXJjZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IG9mZnNldCA9IChlbmRMb2NhdGlvbiAtIHN0YXJ0TG9jYXRpb24pICogKDEgLSBoZWlnaHQudmFsdWUpIC8gMjtcclxuICAgICAgICAgICAgICAgICAgICBzdGFydExvY2F0aW9uICs9IG9mZnNldDtcclxuICAgICAgICAgICAgICAgICAgICBlbmRMb2NhdGlvbiAtPSBvZmZzZXQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0ID0geUF4aXMuZ2V0RGF0YUl0ZW1Qb3NpdGlvblkoZGF0YUl0ZW0sIHlPcGVuRmllbGQsIHN0YXJ0TG9jYXRpb24sIHZjeSk7XHJcbiAgICAgICAgICAgICAgICBiID0geUF4aXMuZ2V0RGF0YUl0ZW1Qb3NpdGlvblkoZGF0YUl0ZW0sIHlGaWVsZCwgZW5kTG9jYXRpb24sIHZjeSk7XHJcbiAgICAgICAgICAgICAgICByID0geEF4aXMuZ2V0RGF0YUl0ZW1Qb3NpdGlvblgoZGF0YUl0ZW0sIHhGaWVsZCwgbG9jYXRpb25YLCB2Y3gpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3hPcGVuRmllbGQgIT09IHRoaXMuX3hGaWVsZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGwgPSB4QXhpcy5nZXREYXRhSXRlbVBvc2l0aW9uWChkYXRhSXRlbSwgeE9wZW5GaWVsZCwgb3BlbkxvY2F0aW9uWCwgdmN4KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGFja2VkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBzdGFja1RvSXRlbVggPSBkYXRhSXRlbS5nZXQoXCJzdGFja1RvSXRlbVhcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdGFja1RvSXRlbVgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGwgPSB4QXhpcy5nZXREYXRhSXRlbVBvc2l0aW9uWChzdGFja1RvSXRlbVgsIHhGaWVsZCwgb3BlbkxvY2F0aW9uWCwgc3RhY2tUb0l0ZW1YLmNvbXBvbmVudC5nZXQoXCJ2Y3hcIikpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbCA9IHhBeGlzLmJhc2VQb3NpdGlvbigpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsID0geEF4aXMuYmFzZVBvc2l0aW9uKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZml0VyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBkYXRhSXRlbS5zZXRSYXcoXCJwb2ludFwiLCB7IHg6IHIsIHk6IHQgKyAoYiAtIHQpIC8gMiB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl91cGRhdGVTZXJpZXNHcmFwaGljcyhkYXRhSXRlbSwgZ3JhcGhpY3MsIGwsIHIsIHQsIGIsIGZpdFcsIGZpdEgpO1xyXG4gICAgICAgICAgICBpZiAoKGwgPCB4U3RhcnQgJiYgciA8IHhTdGFydCkgfHwgKGwgPiB4RW5kICYmIHIgPiB4RW5kKSB8fCAodCA8IHlTdGFydCAmJiBiIDw9IHlTdGFydCkgfHwgKHQgPj0geUVuZCAmJiBiID4geUVuZCkgfHwgJHR5cGUuaXNOYU4obCkgfHwgJHR5cGUuaXNOYU4odCkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3RvZ2dsZUNvbHVtbihkYXRhSXRlbSwgZmFsc2UpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fdG9nZ2xlQ29sdW1uKGRhdGFJdGVtLCB0cnVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsZXQgcmFuZ2VHcmFwaGljcyA9IGRhdGFJdGVtLmdldChcInJhbmdlR3JhcGhpY3NcIik7XHJcbiAgICAgICAgICAgIGlmIChyYW5nZUdyYXBoaWNzKSB7XHJcbiAgICAgICAgICAgICAgICAkYXJyYXkuZWFjaChyYW5nZUdyYXBoaWNzLCAoZ3JhcGhpY3MpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGVTZXJpZXNHcmFwaGljcyhkYXRhSXRlbSwgZ3JhcGhpY3MsIGwsIHIsIHQsIGIsIGZpdFcsIGZpdEgpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fYXBwbHlHcmFwaGljc1N0YXRlcyhkYXRhSXRlbSwgcHJldmlvdXNEYXRhSXRlbSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgX3VwZGF0ZVNlcmllc0dyYXBoaWNzKGRhdGFJdGVtLCBncmFwaGljcywgbCwgciwgdCwgYiwgZml0VywgZml0SCkge1xyXG4gICAgICAgIGNvbnN0IHdpZHRoID0gZ3JhcGhpY3MuZ2V0KFwid2lkdGhcIik7XHJcbiAgICAgICAgY29uc3QgaGVpZ2h0ID0gZ3JhcGhpY3MuZ2V0KFwiaGVpZ2h0XCIpO1xyXG4gICAgICAgIGNvbnN0IG1heFdpZHRoID0gZ3JhcGhpY3MuZ2V0KFwibWF4V2lkdGhcIik7XHJcbiAgICAgICAgY29uc3QgbWF4SGVpZ2h0ID0gZ3JhcGhpY3MuZ2V0KFwibWF4SGVpZ2h0XCIpO1xyXG4gICAgICAgIGNvbnN0IHB0bCA9IHRoaXMuZ2V0UG9pbnQobCwgdCk7XHJcbiAgICAgICAgY29uc3QgcGJyID0gdGhpcy5nZXRQb2ludChyLCBiKTtcclxuICAgICAgICBjb25zdCB0b29sdGlwUG9pbnQgPSBkYXRhSXRlbS5nZXQoXCJwb2ludFwiKTtcclxuICAgICAgICBpZiAodG9vbHRpcFBvaW50KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHBvaW50ID0gdGhpcy5nZXRQb2ludCh0b29sdGlwUG9pbnQueCwgdG9vbHRpcFBvaW50LnkpO1xyXG4gICAgICAgICAgICB0b29sdGlwUG9pbnQueCA9IHBvaW50LnggKyB0aGlzLl94O1xyXG4gICAgICAgICAgICB0b29sdGlwUG9pbnQueSA9IHBvaW50LnkgKyB0aGlzLl95O1xyXG4gICAgICAgIH1cclxuICAgICAgICBsID0gcHRsLng7XHJcbiAgICAgICAgciA9IHBici54O1xyXG4gICAgICAgIHQgPSBwdGwueTtcclxuICAgICAgICBiID0gcGJyLnk7XHJcbiAgICAgICAgaWYgKCR0eXBlLmlzTnVtYmVyKHdpZHRoKSkge1xyXG4gICAgICAgICAgICBjb25zdCBvZmZzZXQgPSAoKHIgLSBsKSAtIHdpZHRoKSAvIDI7XHJcbiAgICAgICAgICAgIGwgKz0gb2Zmc2V0O1xyXG4gICAgICAgICAgICByIC09IG9mZnNldDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCR0eXBlLmlzTnVtYmVyKG1heFdpZHRoKSAmJiBtYXhXaWR0aCA8IE1hdGguYWJzKHIgLSBsKSkge1xyXG4gICAgICAgICAgICBjb25zdCBvZmZzZXQgPSAoKHIgLSBsKSAtIG1heFdpZHRoKSAvIDI7XHJcbiAgICAgICAgICAgIGwgKz0gb2Zmc2V0O1xyXG4gICAgICAgICAgICByIC09IG9mZnNldDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCR0eXBlLmlzTnVtYmVyKGhlaWdodCkpIHtcclxuICAgICAgICAgICAgY29uc3Qgb2Zmc2V0ID0gKChiIC0gdCkgLSBoZWlnaHQpIC8gMjtcclxuICAgICAgICAgICAgdCArPSBvZmZzZXQ7XHJcbiAgICAgICAgICAgIGIgLT0gb2Zmc2V0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoJHR5cGUuaXNOdW1iZXIobWF4SGVpZ2h0KSAmJiBtYXhIZWlnaHQgPCBNYXRoLmFicyhiIC0gdCkpIHtcclxuICAgICAgICAgICAgY29uc3Qgb2Zmc2V0ID0gKChiIC0gdCkgLSBtYXhIZWlnaHQpIC8gMjtcclxuICAgICAgICAgICAgdCArPSBvZmZzZXQ7XHJcbiAgICAgICAgICAgIGIgLT0gb2Zmc2V0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5nZXQoXCJhZGp1c3RCdWxsZXRQb3NpdGlvblwiKSkge1xyXG4gICAgICAgICAgICBpZiAoZml0Vykge1xyXG4gICAgICAgICAgICAgICAgciA9IE1hdGgubWluKE1hdGgubWF4KDAsIHIpLCB0aGlzLl9wdyk7XHJcbiAgICAgICAgICAgICAgICBsID0gTWF0aC5taW4oTWF0aC5tYXgoMCwgbCksIHRoaXMuX3B3KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZml0SCkge1xyXG4gICAgICAgICAgICAgICAgdCA9IE1hdGgubWluKE1hdGgubWF4KDAsIHQpLCB0aGlzLl9waCk7XHJcbiAgICAgICAgICAgICAgICBiID0gTWF0aC5taW4oTWF0aC5tYXgoMCwgYiksIHRoaXMuX3BoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBkYXRhSXRlbS5zZXRSYXcoXCJsZWZ0XCIsIGwpO1xyXG4gICAgICAgIGRhdGFJdGVtLnNldFJhdyhcInJpZ2h0XCIsIHIpO1xyXG4gICAgICAgIGRhdGFJdGVtLnNldFJhdyhcInRvcFwiLCB0KTtcclxuICAgICAgICBkYXRhSXRlbS5zZXRSYXcoXCJib3R0b21cIiwgYik7XHJcbiAgICAgICAgZ3JhcGhpY3Muc2V0UHJpdmF0ZShcIndpZHRoXCIsIHIgLSBsKTtcclxuICAgICAgICBncmFwaGljcy5zZXRQcml2YXRlKFwiaGVpZ2h0XCIsIGIgLSB0KTtcclxuICAgICAgICBncmFwaGljcy5zZXQoXCJ4XCIsIGwpO1xyXG4gICAgICAgIGdyYXBoaWNzLnNldChcInlcIiwgYiAtIChiIC0gdCkpO1xyXG4gICAgfVxyXG4gICAgX2hhbmRsZURhdGFTZXRDaGFuZ2UoKSB7XHJcbiAgICAgICAgc3VwZXIuX2hhbmRsZURhdGFTZXRDaGFuZ2UoKTtcclxuICAgICAgICAkYXJyYXkuZWFjaCh0aGlzLl9kYXRhSXRlbXMsIChkYXRhSXRlbSkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLl90b2dnbGVDb2x1bW4oZGF0YUl0ZW0sIGZhbHNlKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIF9hcHBseUdyYXBoaWNzU3RhdGVzKGRhdGFJdGVtLCBwcmV2aW91c0RhdGFJdGVtKSB7XHJcbiAgICAgICAgY29uc3QgZ3JhcGhpY3MgPSBkYXRhSXRlbS5nZXQoXCJncmFwaGljc1wiKTtcclxuICAgICAgICBjb25zdCBkcm9wRnJvbU9wZW4gPSBncmFwaGljcy5zdGF0ZXMubG9va3VwKFwiZHJvcEZyb21PcGVuXCIpO1xyXG4gICAgICAgIGNvbnN0IHJpc2VGcm9tT3BlbiA9IGdyYXBoaWNzLnN0YXRlcy5sb29rdXAoXCJyaXNlRnJvbU9wZW5cIik7XHJcbiAgICAgICAgY29uc3QgZHJvcEZyb21QcmV2aW91cyA9IGdyYXBoaWNzLnN0YXRlcy5sb29rdXAoXCJkcm9wRnJvbVByZXZpb3VzXCIpO1xyXG4gICAgICAgIGNvbnN0IHJpc2VGcm9tUHJldmlvdXMgPSBncmFwaGljcy5zdGF0ZXMubG9va3VwKFwicmlzZUZyb21QcmV2aW91c1wiKTtcclxuICAgICAgICBpZiAoZHJvcEZyb21PcGVuIHx8IGRyb3BGcm9tUHJldmlvdXMgfHwgcmlzZUZyb21PcGVuIHx8IHJpc2VGcm9tUHJldmlvdXMpIHtcclxuICAgICAgICAgICAgY29uc3QgeEF4aXMgPSB0aGlzLmdldChcInhBeGlzXCIpO1xyXG4gICAgICAgICAgICBjb25zdCB5QXhpcyA9IHRoaXMuZ2V0KFwieUF4aXNcIik7XHJcbiAgICAgICAgICAgIGNvbnN0IGJhc2VBeGlzID0gdGhpcy5nZXQoXCJiYXNlQXhpc1wiKTtcclxuICAgICAgICAgICAgbGV0IG9wZW47XHJcbiAgICAgICAgICAgIGxldCBjbG9zZTtcclxuICAgICAgICAgICAgbGV0IHByZXZpb3VzQ2xvc2U7XHJcbiAgICAgICAgICAgIGlmIChiYXNlQXhpcyA9PT0geEF4aXMgJiYgeUF4aXMuaXNUeXBlKFwiVmFsdWVBeGlzXCIpKSB7XHJcbiAgICAgICAgICAgICAgICBvcGVuID0gZGF0YUl0ZW0uZ2V0KHRoaXMuX3lPcGVuRmllbGQpO1xyXG4gICAgICAgICAgICAgICAgY2xvc2UgPSBkYXRhSXRlbS5nZXQodGhpcy5feUZpZWxkKTtcclxuICAgICAgICAgICAgICAgIHByZXZpb3VzQ2xvc2UgPSBwcmV2aW91c0RhdGFJdGVtLmdldCh0aGlzLl95RmllbGQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGJhc2VBeGlzID09PSB5QXhpcyAmJiB4QXhpcy5pc1R5cGUoXCJWYWx1ZUF4aXNcIikpIHtcclxuICAgICAgICAgICAgICAgIG9wZW4gPSBkYXRhSXRlbS5nZXQodGhpcy5feE9wZW5GaWVsZCk7XHJcbiAgICAgICAgICAgICAgICBjbG9zZSA9IGRhdGFJdGVtLmdldCh0aGlzLl94RmllbGQpO1xyXG4gICAgICAgICAgICAgICAgcHJldmlvdXNDbG9zZSA9IHByZXZpb3VzRGF0YUl0ZW0uZ2V0KHRoaXMuX3hGaWVsZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCR0eXBlLmlzTnVtYmVyKG9wZW4pICYmICR0eXBlLmlzTnVtYmVyKGNsb3NlKSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGNsb3NlIDwgb3Blbikge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChkcm9wRnJvbU9wZW4pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZHJvcEZyb21PcGVuLmFwcGx5KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJpc2VGcm9tT3Blbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByaXNlRnJvbU9wZW4uYXBwbHkoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoJHR5cGUuaXNOdW1iZXIocHJldmlvdXNDbG9zZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY2xvc2UgPCBwcmV2aW91c0Nsb3NlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkcm9wRnJvbVByZXZpb3VzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkcm9wRnJvbVByZXZpb3VzLmFwcGx5KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyaXNlRnJvbVByZXZpb3VzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByaXNlRnJvbVByZXZpb3VzLmFwcGx5KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEBpZ25vcmVcclxuICAgICAqL1xyXG4gICAgZGlzcG9zZURhdGFJdGVtKGRhdGFJdGVtKSB7XHJcbiAgICAgICAgc3VwZXIuZGlzcG9zZURhdGFJdGVtKGRhdGFJdGVtKTtcclxuICAgICAgICBjb25zdCBncmFwaGljcyA9IGRhdGFJdGVtLmdldChcImdyYXBoaWNzXCIpO1xyXG4gICAgICAgIGlmIChncmFwaGljcykge1xyXG4gICAgICAgICAgICB0aGlzLmNvbHVtbnMucmVtb3ZlVmFsdWUoZ3JhcGhpY3MpO1xyXG4gICAgICAgICAgICBncmFwaGljcy5kaXNwb3NlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHJhbmdlR3JhcGhpY3MgPSBkYXRhSXRlbS5nZXQoXCJyYW5nZUdyYXBoaWNzXCIpO1xyXG4gICAgICAgIGlmIChyYW5nZUdyYXBoaWNzKSB7XHJcbiAgICAgICAgICAgICRhcnJheS5lYWNoKHJhbmdlR3JhcGhpY3MsIChncmFwaGljcykgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbGlzdCA9IGdyYXBoaWNzLmdldFByaXZhdGUoXCJsaXN0XCIpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGxpc3QpIHtcclxuICAgICAgICAgICAgICAgICAgICBsaXN0LnJlbW92ZVZhbHVlKGdyYXBoaWNzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGdyYXBoaWNzLmRpc3Bvc2UoKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBIaWRlcyBzZXJpZXMncyBkYXRhIGl0ZW0uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtICAgZGF0YUl0ZW0gIERhdGEgaXRlbVxyXG4gICAgICogQHBhcmFtICAgZHVyYXRpb24gIEFuaW1hdGlvbiBkdXJhdGlvbiBpbiBtaWxsaXNlY29uZHNcclxuICAgICAqIEByZXR1cm4gICAgICAgICAgICBQcm9taXNlXHJcbiAgICAgKi9cclxuICAgIGhpZGVEYXRhSXRlbShkYXRhSXRlbSwgZHVyYXRpb24pIHtcclxuICAgICAgICBjb25zdCBfc3VwZXIgPSBPYmplY3QuY3JlYXRlKG51bGwsIHtcclxuICAgICAgICAgICAgaGlkZURhdGFJdGVtOiB7IGdldDogKCkgPT4gc3VwZXIuaGlkZURhdGFJdGVtIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICBjb25zdCBwcm9taXNlcyA9IFtfc3VwZXIuaGlkZURhdGFJdGVtLmNhbGwodGhpcywgZGF0YUl0ZW0sIGR1cmF0aW9uKV07XHJcbiAgICAgICAgICAgIGNvbnN0IGdyYXBoaWNzID0gZGF0YUl0ZW0uZ2V0KFwiZ3JhcGhpY3NcIik7XHJcbiAgICAgICAgICAgIGlmIChncmFwaGljcykge1xyXG4gICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaChncmFwaGljcy5oaWRlKGR1cmF0aW9uKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgcmFuZ2VHcmFwaGljcyA9IGRhdGFJdGVtLmdldChcInJhbmdlR3JhcGhpY3NcIik7XHJcbiAgICAgICAgICAgIGlmIChyYW5nZUdyYXBoaWNzKSB7XHJcbiAgICAgICAgICAgICAgICAkYXJyYXkuZWFjaChyYW5nZUdyYXBoaWNzLCAoZ3JhcGhpY3MpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKGdyYXBoaWNzLmhpZGUoZHVyYXRpb24pKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHlpZWxkIFByb21pc2UuYWxsKHByb21pc2VzKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIF90b2dnbGVDb2x1bW4oZGF0YUl0ZW0sIHZpc2libGUpIHtcclxuICAgICAgICBjb25zdCBncmFwaGljcyA9IGRhdGFJdGVtLmdldChcImdyYXBoaWNzXCIpO1xyXG4gICAgICAgIGlmIChncmFwaGljcykge1xyXG4gICAgICAgICAgICBncmFwaGljcy5zZXRQcml2YXRlKFwidmlzaWJsZVwiLCB2aXNpYmxlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgcmFuZ2VHcmFwaGljcyA9IGRhdGFJdGVtLmdldChcInJhbmdlR3JhcGhpY3NcIik7XHJcbiAgICAgICAgaWYgKHJhbmdlR3JhcGhpY3MpIHtcclxuICAgICAgICAgICAgJGFycmF5LmVhY2gocmFuZ2VHcmFwaGljcywgKGdyYXBoaWNzKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBncmFwaGljcy5zZXRQcml2YXRlKFwidmlzaWJsZVwiLCB2aXNpYmxlKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGJ1bGxldHMgPSBkYXRhSXRlbS5idWxsZXRzO1xyXG4gICAgICAgIGlmIChidWxsZXRzKSB7XHJcbiAgICAgICAgICAgICRhcnJheS5lYWNoKGJ1bGxldHMsIChidWxsZXQpID0+IHtcclxuICAgICAgICAgICAgICAgIGJ1bGxldC5zZXRQcml2YXRlKFwiaGlkZGVuXCIsICF2aXNpYmxlKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTaG93cyBzZXJpZXMncyBkYXRhIGl0ZW0uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtICAgZGF0YUl0ZW0gIERhdGEgaXRlbVxyXG4gICAgICogQHBhcmFtICAgZHVyYXRpb24gIEFuaW1hdGlvbiBkdXJhdGlvbiBpbiBtaWxsaXNlY29uZHNcclxuICAgICAqIEByZXR1cm4gICAgICAgICAgICBQcm9taXNlXHJcbiAgICAgKi9cclxuICAgIHNob3dEYXRhSXRlbShkYXRhSXRlbSwgZHVyYXRpb24pIHtcclxuICAgICAgICBjb25zdCBfc3VwZXIgPSBPYmplY3QuY3JlYXRlKG51bGwsIHtcclxuICAgICAgICAgICAgc2hvd0RhdGFJdGVtOiB7IGdldDogKCkgPT4gc3VwZXIuc2hvd0RhdGFJdGVtIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICBjb25zdCBwcm9taXNlcyA9IFtfc3VwZXIuc2hvd0RhdGFJdGVtLmNhbGwodGhpcywgZGF0YUl0ZW0sIGR1cmF0aW9uKV07XHJcbiAgICAgICAgICAgIGNvbnN0IGdyYXBoaWNzID0gZGF0YUl0ZW0uZ2V0KFwiZ3JhcGhpY3NcIik7XHJcbiAgICAgICAgICAgIGlmIChncmFwaGljcykge1xyXG4gICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaChncmFwaGljcy5zaG93KGR1cmF0aW9uKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgcmFuZ2VHcmFwaGljcyA9IGRhdGFJdGVtLmdldChcInJhbmdlR3JhcGhpY3NcIik7XHJcbiAgICAgICAgICAgIGlmIChyYW5nZUdyYXBoaWNzKSB7XHJcbiAgICAgICAgICAgICAgICAkYXJyYXkuZWFjaChyYW5nZUdyYXBoaWNzLCAoZ3JhcGhpY3MpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKGdyYXBoaWNzLnNob3coZHVyYXRpb24pKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHlpZWxkIFByb21pc2UuYWxsKHByb21pc2VzKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQGlnbm9yZVxyXG4gICAgICovXHJcbiAgICB1cGRhdGVMZWdlbmRNYXJrZXIoZGF0YUl0ZW0pIHtcclxuICAgICAgICBsZXQgbGVnZW5kRGF0YUl0ZW0gPSB0aGlzLmdldChcImxlZ2VuZERhdGFJdGVtXCIpO1xyXG4gICAgICAgIGlmICh0aGlzLmdldChcInVzZUxhc3RDb2xvckZvckxlZ2VuZE1hcmtlclwiKSkge1xyXG4gICAgICAgICAgICBpZiAoIWRhdGFJdGVtKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBsYXN0RGF0YUl0ZW0gPSB0aGlzLmRhdGFJdGVtc1t0aGlzLmVuZEluZGV4KCkgLSAxXTtcclxuICAgICAgICAgICAgICAgIGlmIChsYXN0RGF0YUl0ZW0pIHtcclxuICAgICAgICAgICAgICAgICAgICBkYXRhSXRlbSA9IGxhc3REYXRhSXRlbTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobGVnZW5kRGF0YUl0ZW0pIHtcclxuICAgICAgICAgICAgbGV0IGdyYXBoaWNzID0gdGhpcy5jb2x1bW5zLnRlbXBsYXRlO1xyXG4gICAgICAgICAgICBpZiAoZGF0YUl0ZW0pIHtcclxuICAgICAgICAgICAgICAgIGxldCBjb2x1bW4gPSBkYXRhSXRlbS5nZXQoXCJncmFwaGljc1wiKTtcclxuICAgICAgICAgICAgICAgIGlmIChjb2x1bW4pIHtcclxuICAgICAgICAgICAgICAgICAgICBncmFwaGljcyA9IGNvbHVtbjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBtYXJrZXJSZWN0YW5nbGUgPSBsZWdlbmREYXRhSXRlbS5nZXQoXCJtYXJrZXJSZWN0YW5nbGVcIik7XHJcbiAgICAgICAgICAgIGlmIChtYXJrZXJSZWN0YW5nbGUpIHtcclxuICAgICAgICAgICAgICAgIGlmICghbGVnZW5kRGF0YUl0ZW0uZ2V0KFwiaXRlbUNvbnRhaW5lclwiKS5nZXQoXCJkaXNhYmxlZFwiKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRzID0gbWFya2VyUmVjdGFuZ2xlLnN0YXRlcy5sb29rdXAoXCJkZWZhdWx0XCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICRhcnJheS5lYWNoKHZpc3VhbFNldHRpbmdzLCAoc2V0dGluZykgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGdyYXBoaWNzLmdldChzZXR0aW5nLCB0aGlzLmdldChzZXR0aW5nKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hcmtlclJlY3RhbmdsZS5zZXQoc2V0dGluZywgdmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkcy5zZXQoc2V0dGluZywgdmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgX2dldFRvb2x0aXBUYXJnZXQoZGF0YUl0ZW0pIHtcclxuICAgICAgICBpZiAodGhpcy5nZXQoXCJzZXJpZXNUb29sdGlwVGFyZ2V0XCIpID09IFwiYnVsbGV0XCIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHN1cGVyLl9nZXRUb29sdGlwVGFyZ2V0KGRhdGFJdGVtKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IGNvbHVtbiA9IGRhdGFJdGVtLmdldChcImdyYXBoaWNzXCIpO1xyXG4gICAgICAgIGlmIChjb2x1bW4pIHtcclxuICAgICAgICAgICAgcmV0dXJuIGNvbHVtbjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbn1cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEJhc2VDb2x1bW5TZXJpZXMsIFwiY2xhc3NOYW1lXCIsIHtcclxuICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgIHZhbHVlOiBcIkJhc2VDb2x1bW5TZXJpZXNcIlxyXG59KTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEJhc2VDb2x1bW5TZXJpZXMsIFwiY2xhc3NOYW1lc1wiLCB7XHJcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICB2YWx1ZTogWFlTZXJpZXMuY2xhc3NOYW1lcy5jb25jYXQoW0Jhc2VDb2x1bW5TZXJpZXMuY2xhc3NOYW1lXSlcclxufSk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUJhc2VDb2x1bW5TZXJpZXMuanMubWFwIiwiaW1wb3J0IHsgQmFzZUNvbHVtblNlcmllcyB9IGZyb20gXCIuL0Jhc2VDb2x1bW5TZXJpZXNcIjtcclxuaW1wb3J0IHsgVGVtcGxhdGUgfSBmcm9tIFwiLi4vLi4vLi4vY29yZS91dGlsL1RlbXBsYXRlXCI7XHJcbmltcG9ydCB7IExpc3RUZW1wbGF0ZSB9IGZyb20gXCIuLi8uLi8uLi9jb3JlL3V0aWwvTGlzdFwiO1xyXG5pbXBvcnQgeyBSb3VuZGVkUmVjdGFuZ2xlIH0gZnJvbSBcIi4uLy4uLy4uL2NvcmUvcmVuZGVyL1JvdW5kZWRSZWN0YW5nbGVcIjtcclxuaW1wb3J0ICogYXMgJHV0aWxzIGZyb20gXCIuLi8uLi8uLi9jb3JlL3V0aWwvVXRpbHNcIjtcclxuZXhwb3J0IGNsYXNzIENvbHVtblNlcmllcyBleHRlbmRzIEJhc2VDb2x1bW5TZXJpZXMge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBIFtbVGVtcGxhdGVMaXN0XV0gb2YgYWxsIGNvbHVtbnMgaW4gc2VyaWVzLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogYGNvbHVtbnMudGVtcGxhdGVgIGNhbiBiZSB1c2VkIHRvIHNldCBkZWZhdWx0IHNldHRpbmdzIGZvciBhbGwgY29sdW1ucyxcclxuICAgICAgICAgKiBvciB0byBjaGFuZ2Ugb24gZXhpc3Rpbmcgb25lcy5cclxuICAgICAgICAgKi9cclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJjb2x1bW5zXCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IG5ldyBMaXN0VGVtcGxhdGUoVGVtcGxhdGUubmV3KHt9KSwgKCkgPT4gUm91bmRlZFJlY3RhbmdsZS5fbmV3KHRoaXMuX3Jvb3QsIHtcclxuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBcImFic29sdXRlXCIsXHJcbiAgICAgICAgICAgICAgICB0aGVtZVRhZ3M6ICR1dGlscy5tZXJnZVRhZ3ModGhpcy5jb2x1bW5zLnRlbXBsYXRlLmdldChcInRoZW1lVGFnc1wiLCBbXSksIFtcInNlcmllc1wiLCBcImNvbHVtblwiXSlcclxuICAgICAgICAgICAgfSwgW3RoaXMuY29sdW1ucy50ZW1wbGF0ZV0pKVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAaWdub3JlXHJcbiAgICAgKi9cclxuICAgIG1ha2VDb2x1bW4oZGF0YUl0ZW0sIGxpc3RUZW1wbGF0ZSkge1xyXG4gICAgICAgIGNvbnN0IGNvbHVtbiA9IHRoaXMubWFpbkNvbnRhaW5lci5jaGlsZHJlbi5wdXNoKGxpc3RUZW1wbGF0ZS5tYWtlKCkpO1xyXG4gICAgICAgIGNvbHVtbi5fc2V0RGF0YUl0ZW0oZGF0YUl0ZW0pO1xyXG4gICAgICAgIGxpc3RUZW1wbGF0ZS5wdXNoKGNvbHVtbik7XHJcbiAgICAgICAgcmV0dXJuIGNvbHVtbjtcclxuICAgIH1cclxuICAgIF9wcm9jZXNzQXhpc1JhbmdlKGF4aXNSYW5nZSkge1xyXG4gICAgICAgIHN1cGVyLl9wcm9jZXNzQXhpc1JhbmdlKGF4aXNSYW5nZSk7XHJcbiAgICAgICAgYXhpc1JhbmdlLmNvbHVtbnMgPSBuZXcgTGlzdFRlbXBsYXRlKFRlbXBsYXRlLm5ldyh7fSksICgpID0+IFJvdW5kZWRSZWN0YW5nbGUuX25ldyh0aGlzLl9yb290LCB7XHJcbiAgICAgICAgICAgIHBvc2l0aW9uOiBcImFic29sdXRlXCIsXHJcbiAgICAgICAgICAgIHRoZW1lVGFnczogJHV0aWxzLm1lcmdlVGFncyhheGlzUmFuZ2UuY29sdW1ucy50ZW1wbGF0ZS5nZXQoXCJ0aGVtZVRhZ3NcIiwgW10pLCBbXCJzZXJpZXNcIiwgXCJjb2x1bW5cIl0pLFxyXG4gICAgICAgIH0sIFt0aGlzLmNvbHVtbnMudGVtcGxhdGUsIGF4aXNSYW5nZS5jb2x1bW5zLnRlbXBsYXRlXSkpO1xyXG4gICAgfVxyXG59XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb2x1bW5TZXJpZXMsIFwiY2xhc3NOYW1lXCIsIHtcclxuICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgIHZhbHVlOiBcIkNvbHVtblNlcmllc1wiXHJcbn0pO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQ29sdW1uU2VyaWVzLCBcImNsYXNzTmFtZXNcIiwge1xyXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgdmFsdWU6IEJhc2VDb2x1bW5TZXJpZXMuY2xhc3NOYW1lcy5jb25jYXQoW0NvbHVtblNlcmllcy5jbGFzc05hbWVdKVxyXG59KTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q29sdW1uU2VyaWVzLmpzLm1hcCIsImltcG9ydCB7IFhZU2VyaWVzIH0gZnJvbSBcIi4vWFlTZXJpZXNcIjtcclxuaW1wb3J0IHsgR3JhcGhpY3MgfSBmcm9tIFwiLi4vLi4vLi4vY29yZS9yZW5kZXIvR3JhcGhpY3NcIjtcclxuaW1wb3J0IHsgbGluZSwgYXJlYSB9IGZyb20gXCJkMy1zaGFwZVwiO1xyXG5pbXBvcnQgeyBUZW1wbGF0ZSB9IGZyb20gXCIuLi8uLi8uLi9jb3JlL3V0aWwvVGVtcGxhdGVcIjtcclxuaW1wb3J0IHsgTGlzdFRlbXBsYXRlIH0gZnJvbSBcIi4uLy4uLy4uL2NvcmUvdXRpbC9MaXN0XCI7XHJcbmltcG9ydCB7IGNvbG9yIH0gZnJvbSBcIi4uLy4uLy4uL2NvcmUvdXRpbC9Db2xvclwiO1xyXG5pbXBvcnQgeyBEYXRhSXRlbSB9IGZyb20gXCIuLi8uLi8uLi9jb3JlL3JlbmRlci9Db21wb25lbnRcIjtcclxuaW1wb3J0IHsgUmVjdGFuZ2xlIH0gZnJvbSBcIi4uLy4uLy4uL2NvcmUvcmVuZGVyL1JlY3RhbmdsZVwiO1xyXG5pbXBvcnQgKiBhcyAkdHlwZSBmcm9tIFwiLi4vLi4vLi4vY29yZS91dGlsL1R5cGVcIjtcclxuaW1wb3J0ICogYXMgJGFycmF5IGZyb20gXCIuLi8uLi8uLi9jb3JlL3V0aWwvQXJyYXlcIjtcclxuaW1wb3J0ICogYXMgJHV0aWxzIGZyb20gXCIuLi8uLi8uLi9jb3JlL3V0aWwvVXRpbHNcIjtcclxuLyoqXHJcbiAqIFVzZWQgdG8gcGxvdCBsaW5lIGFuZC9vciBhcmVhIHNlcmllcy5cclxuICpcclxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly93d3cuYW1jaGFydHMuY29tL2RvY3MvdjUvY2hhcnRzL3h5LWNoYXJ0L3Nlcmllcy9saW5lLXNlcmllcy99IGZvciBtb3JlIGluZm9cclxuICogQGltcG9ydGFudFxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIExpbmVTZXJpZXMgZXh0ZW5kcyBYWVNlcmllcyB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9lbmRJbmRleFwiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfc3Ryb2tlR2VuZXJhdG9yXCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IGxpbmUoKVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9maWxsR2VuZXJhdG9yXCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IGFyZWEoKVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9sZWdlbmRTdHJva2VcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX2xlZ2VuZEZpbGxcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQSBbW1RlbXBsYXRlTGlzdF1dIG9mIGFsbCBsaW5lIHNlZ21lbnRzIGluIHNlcmllcy5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIGBzdHJva2VzLnRlbXBsYXRlYCBjYW4gYmUgdXNlZCB0byBzZXQgZGVmYXVsdCBzZXR0aW5ncyBmb3IgYWxsIGxpbmVcclxuICAgICAgICAgKiBzZWdtZW50cywgb3IgdG8gY2hhbmdlIG9uIGV4aXN0aW5nIG9uZXMuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAZGVmYXVsdCBuZXcgTGlzdFRlbXBsYXRlPEdyYXBoaWNzPlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInN0cm9rZXNcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogbmV3IExpc3RUZW1wbGF0ZShUZW1wbGF0ZS5uZXcoe30pLCAoKSA9PiBHcmFwaGljcy5fbmV3KHRoaXMuX3Jvb3QsIHtcclxuICAgICAgICAgICAgICAgIHRoZW1lVGFnczogJHV0aWxzLm1lcmdlVGFncyh0aGlzLnN0cm9rZXMudGVtcGxhdGUuZ2V0KFwidGhlbWVUYWdzXCIsIFtdKSwgW1wibGluZVwiLCBcInNlcmllc1wiLCBcInN0cm9rZVwiXSlcclxuICAgICAgICAgICAgfSwgW3RoaXMuc3Ryb2tlcy50ZW1wbGF0ZV0pKVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEEgW1tUZW1wbGF0ZUxpc3RdXSBvZiBhbGwgc2VnbWVudCBmaWxscyBpbiBzZXJpZXMuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBgZmlsbHMudGVtcGxhdGVgIGNhbiBiZSB1c2VkIHRvIHNldCBkZWZhdWx0IHNldHRpbmdzIGZvciBhbGwgc2VnbWVudFxyXG4gICAgICAgICAqIGZpbGxzLCBvciB0byBjaGFuZ2Ugb24gZXhpc3Rpbmcgb25lcy5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBkZWZhdWx0IG5ldyBMaXN0VGVtcGxhdGU8R3JhcGhpY3M+XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZmlsbHNcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogbmV3IExpc3RUZW1wbGF0ZShUZW1wbGF0ZS5uZXcoe30pLCAoKSA9PiBHcmFwaGljcy5fbmV3KHRoaXMuX3Jvb3QsIHtcclxuICAgICAgICAgICAgICAgIHRoZW1lVGFnczogJHV0aWxzLm1lcmdlVGFncyh0aGlzLnN0cm9rZXMudGVtcGxhdGUuZ2V0KFwidGhlbWVUYWdzXCIsIFtdKSwgW1wibGluZVwiLCBcInNlcmllc1wiLCBcImZpbGxcIl0pXHJcbiAgICAgICAgICAgIH0sIFt0aGlzLmZpbGxzLnRlbXBsYXRlXSkpXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLy8gY3VzdG9tIHNldCBmcm9tIGRhdGFcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfZmlsbFRlbXBsYXRlXCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9zdHJva2VUZW1wbGF0ZVwiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfcHJldmlvdXNQb2ludFwiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiBbMCwgMCwgMCwgMF1cclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfZGluZGV4XCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IDBcclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfc2luZGV4XCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IDBcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIF9hZnRlck5ldygpIHtcclxuICAgICAgICB0aGlzLl9maWxsR2VuZXJhdG9yLnkwKGZ1bmN0aW9uIChwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBwWzNdO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuX2ZpbGxHZW5lcmF0b3IueDAoZnVuY3Rpb24gKHApIHtcclxuICAgICAgICAgICAgcmV0dXJuIHBbMl07XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5fZmlsbEdlbmVyYXRvci55MShmdW5jdGlvbiAocCkge1xyXG4gICAgICAgICAgICByZXR1cm4gcFsxXTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLl9maWxsR2VuZXJhdG9yLngxKGZ1bmN0aW9uIChwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBwWzBdO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHN1cGVyLl9hZnRlck5ldygpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAaWdub3JlXHJcbiAgICAgKi9cclxuICAgIG1ha2VTdHJva2Uoc3Ryb2tlcykge1xyXG4gICAgICAgIGNvbnN0IHN0cm9rZSA9IHRoaXMubWFpbkNvbnRhaW5lci5jaGlsZHJlbi5wdXNoKHN0cm9rZXMubWFrZSgpKTtcclxuICAgICAgICBzdHJva2VzLnB1c2goc3Ryb2tlKTtcclxuICAgICAgICByZXR1cm4gc3Ryb2tlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAaWdub3JlXHJcbiAgICAgKi9cclxuICAgIG1ha2VGaWxsKGZpbGxzKSB7XHJcbiAgICAgICAgY29uc3QgZmlsbCA9IHRoaXMubWFpbkNvbnRhaW5lci5jaGlsZHJlbi5wdXNoKGZpbGxzLm1ha2UoKSk7XHJcbiAgICAgICAgZmlsbHMucHVzaChmaWxsKTtcclxuICAgICAgICByZXR1cm4gZmlsbDtcclxuICAgIH1cclxuICAgIF91cGRhdGVDaGlsZHJlbigpIHtcclxuICAgICAgICB0aGlzLl9zdHJva2VUZW1wbGF0ZSA9IHVuZGVmaW5lZDtcclxuICAgICAgICB0aGlzLl9maWxsVGVtcGxhdGUgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgbGV0IHhBeGlzID0gdGhpcy5nZXQoXCJ4QXhpc1wiKTtcclxuICAgICAgICBsZXQgeUF4aXMgPSB0aGlzLmdldChcInlBeGlzXCIpO1xyXG4gICAgICAgIGlmICh0aGlzLmlzRGlydHkoXCJzdHJva2VcIikpIHtcclxuICAgICAgICAgICAgY29uc3Qgc3Ryb2tlID0gdGhpcy5nZXQoXCJzdHJva2VcIik7XHJcbiAgICAgICAgICAgIHRoaXMuc3Ryb2tlcy50ZW1wbGF0ZS5zZXQoXCJzdHJva2VcIiwgc3Ryb2tlKTtcclxuICAgICAgICAgICAgY29uc3QgbGVnZW5kU3Ryb2tlID0gdGhpcy5fbGVnZW5kU3Ryb2tlO1xyXG4gICAgICAgICAgICBpZiAobGVnZW5kU3Ryb2tlKSB7XHJcbiAgICAgICAgICAgICAgICBsZWdlbmRTdHJva2Uuc3RhdGVzLmxvb2t1cChcImRlZmF1bHRcIikuc2V0KFwic3Ryb2tlXCIsIHN0cm9rZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuaXNEaXJ0eShcImZpbGxcIikpIHtcclxuICAgICAgICAgICAgY29uc3QgZmlsbCA9IHRoaXMuZ2V0KFwiZmlsbFwiKTtcclxuICAgICAgICAgICAgdGhpcy5maWxscy50ZW1wbGF0ZS5zZXQoXCJmaWxsXCIsIGZpbGwpO1xyXG4gICAgICAgICAgICBjb25zdCBsZWdlbmRGaWxsID0gdGhpcy5fbGVnZW5kRmlsbDtcclxuICAgICAgICAgICAgaWYgKGxlZ2VuZEZpbGwpIHtcclxuICAgICAgICAgICAgICAgIGxlZ2VuZEZpbGwuc3RhdGVzLmxvb2t1cChcImRlZmF1bHRcIikuc2V0KFwiZmlsbFwiLCBmaWxsKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5pc0RpcnR5KFwiY3VydmVGYWN0b3J5XCIpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGN1cnZlRmFjdG9yeSA9IHRoaXMuZ2V0KFwiY3VydmVGYWN0b3J5XCIpO1xyXG4gICAgICAgICAgICBpZiAoY3VydmVGYWN0b3J5KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zdHJva2VHZW5lcmF0b3IuY3VydmUoY3VydmVGYWN0b3J5KTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2ZpbGxHZW5lcmF0b3IuY3VydmUoY3VydmVGYWN0b3J5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoeEF4aXMuaW5pdGVkICYmIHlBeGlzLmluaXRlZCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fYXhlc0RpcnR5IHx8IHRoaXMuX3ZhbHVlc0RpcnR5IHx8IHRoaXMuX3N0YWNrRGlydHkgfHwgdGhpcy5pc0RpcnR5KFwidmN4XCIpIHx8IHRoaXMuaXNEaXJ0eShcInZjeVwiKSB8fCB0aGlzLl9zaXplRGlydHkgfHwgdGhpcy5pc0RpcnR5KFwiY29ubmVjdFwiKSB8fCB0aGlzLmlzRGlydHkoXCJjdXJ2ZUZhY3RvcnlcIikpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZmlsbHMuZWFjaCgoZmlsbCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGZpbGwuc2V0UHJpdmF0ZShcInZpc2libGVcIiwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnN0cm9rZXMuZWFjaCgoZmlsbCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGZpbGwuc2V0UHJpdmF0ZShcInZpc2libGVcIiwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmF4aXNSYW5nZXMuZWFjaCgoYXhpc1JhbmdlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGZpbGxzID0gYXhpc1JhbmdlLmZpbGxzO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChmaWxscykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmaWxscy5lYWNoKChmaWxsKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxsLnNldFByaXZhdGUoXCJ2aXNpYmxlXCIsIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGxldCBzdHJva2VzID0gYXhpc1JhbmdlLnN0cm9rZXM7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0cm9rZXMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3Ryb2tlcy5lYWNoKChzdHJva2UpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZS5zZXRQcml2YXRlKFwidmlzaWJsZVwiLCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgbGV0IHN0YXJ0SW5kZXggPSB0aGlzLnN0YXJ0SW5kZXgoKTtcclxuICAgICAgICAgICAgICAgIGxldCBzdHJva2VUZW1wbGF0ZUZpZWxkID0gdGhpcy5zdHJva2VzLnRlbXBsYXRlLmdldChcInRlbXBsYXRlRmllbGRcIik7XHJcbiAgICAgICAgICAgICAgICBsZXQgZmlsbFRlbXBsYXRlRmllbGQgPSB0aGlzLmZpbGxzLnRlbXBsYXRlLmdldChcInRlbXBsYXRlRmllbGRcIik7XHJcbiAgICAgICAgICAgICAgICBsZXQgc3Ryb2tlVGVtcGxhdGVGb3VuZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBsZXQgZmlsbFRlbXBsYXRlRm91bmQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgaWYgKHN0cm9rZVRlbXBsYXRlRmllbGQpIHtcclxuICAgICAgICAgICAgICAgICAgICBzdHJva2VUZW1wbGF0ZUZvdW5kID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoZmlsbFRlbXBsYXRlRmllbGQpIHtcclxuICAgICAgICAgICAgICAgICAgICBmaWxsVGVtcGxhdGVGb3VuZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IHN0YXJ0SW5kZXggLSAxOyBpID49IDA7IGktLSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBkYXRhSXRlbSA9IHRoaXMuZGF0YUl0ZW1zW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBoYXNWYWx1ZXMgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBkYXRhQ29udGV4dCA9IGRhdGFJdGVtLmRhdGFDb250ZXh0O1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzdHJva2VUZW1wbGF0ZUZpZWxkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkYXRhQ29udGV4dFtzdHJva2VUZW1wbGF0ZUZpZWxkXSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3Ryb2tlVGVtcGxhdGVGb3VuZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpbGxUZW1wbGF0ZUZpZWxkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkYXRhQ29udGV4dFtmaWxsVGVtcGxhdGVGaWVsZF0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbGxUZW1wbGF0ZUZvdW5kID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAkYXJyYXkuZWFjaCh0aGlzLl92YWx1ZUZpZWxkcywgKGZpZWxkKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghJHR5cGUuaXNOdW1iZXIoZGF0YUl0ZW0uZ2V0KGZpZWxkKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhc1ZhbHVlcyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGhhc1ZhbHVlcyAmJiBzdHJva2VUZW1wbGF0ZUZvdW5kICYmIGZpbGxUZW1wbGF0ZUZvdW5kKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0SW5kZXggPSBpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBsZXQgbGVuID0gdGhpcy5kYXRhSXRlbXMubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgbGV0IGVuZEluZGV4ID0gdGhpcy5lbmRJbmRleCgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGVuZEluZGV4IDwgbGVuKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZW5kSW5kZXgrKztcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gZW5kSW5kZXg7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgZGF0YUl0ZW0gPSB0aGlzLmRhdGFJdGVtc1tpXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGhhc1ZhbHVlcyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICRhcnJheS5lYWNoKHRoaXMuX3ZhbHVlRmllbGRzLCAoZmllbGQpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghJHR5cGUuaXNOdW1iZXIoZGF0YUl0ZW0uZ2V0KGZpZWxkKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYXNWYWx1ZXMgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoYXNWYWx1ZXMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZEluZGV4ID0gaSArIDE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChzdGFydEluZGV4ID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0SW5kZXgtLTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuX2VuZEluZGV4ID0gZW5kSW5kZXg7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9jbGVhckdyYXBoaWNzKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zaW5kZXggPSAwO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZGluZGV4ID0gc3RhcnRJbmRleDtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmRhdGFJdGVtcy5sZW5ndGggPT0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0YXJ0U2VnbWVudCgwKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgaXMgZG9uZSB0byBhdm9pZCByZWN1cnNpb24gd2l0aCBhIGxvdCBvZiBzZWdtZW50cyBcclxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAodGhpcy5fZGluZGV4IDwgZW5kSW5kZXggLSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0YXJ0U2VnbWVudCh0aGlzLl9kaW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9zaW5kZXgrKztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3NraXBwZWQgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzdXBlci5fdXBkYXRlQ2hpbGRyZW4oKTtcclxuICAgIH1cclxuICAgIF9jbGVhckdyYXBoaWNzKCkge1xyXG4gICAgICAgIHRoaXMuc3Ryb2tlcy5jbGVhcigpO1xyXG4gICAgICAgIHRoaXMuZmlsbHMuY2xlYXIoKTtcclxuICAgIH1cclxuICAgIF9zdGFydFNlZ21lbnQoZGF0YUl0ZW1JbmRleCkge1xyXG4gICAgICAgIGxldCBlbmRJbmRleCA9IHRoaXMuX2VuZEluZGV4O1xyXG4gICAgICAgIGxldCBjdXJyZW50RW5kSW5kZXggPSBlbmRJbmRleDtcclxuICAgICAgICBjb25zdCBhdXRvR2FwQ291bnQgPSB0aGlzLmdldChcImF1dG9HYXBDb3VudFwiKTtcclxuICAgICAgICBjb25zdCBjb25uZWN0ID0gdGhpcy5nZXQoXCJjb25uZWN0XCIpO1xyXG4gICAgICAgIGNvbnN0IGZpbGwgPSB0aGlzLm1ha2VGaWxsKHRoaXMuZmlsbHMpO1xyXG4gICAgICAgIGNvbnN0IGZpbGxUZW1wbGF0ZSA9IHRoaXMuX2ZpbGxUZW1wbGF0ZTtcclxuICAgICAgICBjb25zdCBvcmlnaW5hbFRlbXBsYXRlID0gdGhpcy5maWxscy50ZW1wbGF0ZTtcclxuICAgICAgICBpZiAoZmlsbFRlbXBsYXRlICYmIGZpbGxUZW1wbGF0ZSAhPSBvcmlnaW5hbFRlbXBsYXRlKSB7XHJcbiAgICAgICAgICAgIGZpbGwudGVtcGxhdGUgPSBmaWxsVGVtcGxhdGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZpbGwuc2V0UHJpdmF0ZShcInZpc2libGVcIiwgdHJ1ZSk7XHJcbiAgICAgICAgY29uc3Qgc3Ryb2tlID0gdGhpcy5tYWtlU3Ryb2tlKHRoaXMuc3Ryb2tlcyk7XHJcbiAgICAgICAgY29uc3Qgc3Ryb2tlVGVtcGxhdGUgPSB0aGlzLl9zdHJva2VUZW1wbGF0ZTtcclxuICAgICAgICBpZiAoc3Ryb2tlVGVtcGxhdGUgJiYgc3Ryb2tlVGVtcGxhdGUgIT0gdGhpcy5zdHJva2VzLnRlbXBsYXRlKSB7XHJcbiAgICAgICAgICAgIHN0cm9rZS50ZW1wbGF0ZSA9IHN0cm9rZVRlbXBsYXRlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzdHJva2Uuc2V0UHJpdmF0ZShcInZpc2libGVcIiwgdHJ1ZSk7XHJcbiAgICAgICAgbGV0IHhBeGlzID0gdGhpcy5nZXQoXCJ4QXhpc1wiKTtcclxuICAgICAgICBsZXQgeUF4aXMgPSB0aGlzLmdldChcInlBeGlzXCIpO1xyXG4gICAgICAgIGxldCBiYXNlQXhpcyA9IHRoaXMuZ2V0KFwiYmFzZUF4aXNcIik7XHJcbiAgICAgICAgbGV0IHZjeCA9IHRoaXMuZ2V0KFwidmN4XCIsIDEpO1xyXG4gICAgICAgIGxldCB2Y3kgPSB0aGlzLmdldChcInZjeVwiLCAxKTtcclxuICAgICAgICBsZXQgeEZpZWxkID0gdGhpcy5feEZpZWxkO1xyXG4gICAgICAgIGxldCB5RmllbGQgPSB0aGlzLl95RmllbGQ7XHJcbiAgICAgICAgbGV0IHhPcGVuRmllbGQgPSB0aGlzLl94T3BlbkZpZWxkO1xyXG4gICAgICAgIGxldCB5T3BlbkZpZWxkID0gdGhpcy5feU9wZW5GaWVsZDtcclxuICAgICAgICBjb25zdCB4T3BlbkZpZWxkVmFsdWUgPSB0aGlzLmdldChcIm9wZW5WYWx1ZVhGaWVsZFwiKTtcclxuICAgICAgICBjb25zdCB5T3BlbkZpZWxkVmFsdWUgPSB0aGlzLmdldChcIm9wZW5WYWx1ZVlGaWVsZFwiKTtcclxuICAgICAgICBpZiAoIXhPcGVuRmllbGRWYWx1ZSkge1xyXG4gICAgICAgICAgICB4T3BlbkZpZWxkID0gdGhpcy5feEZpZWxkO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXlPcGVuRmllbGRWYWx1ZSkge1xyXG4gICAgICAgICAgICB5T3BlbkZpZWxkID0gdGhpcy5feUZpZWxkO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBzdGFja2VkID0gdGhpcy5nZXQoXCJzdGFja2VkXCIpO1xyXG4gICAgICAgIGNvbnN0IGJhc2VQb3NYID0geEF4aXMuYmFzZVBvc2l0aW9uKCk7XHJcbiAgICAgICAgY29uc3QgYmFzZVBvc1kgPSB5QXhpcy5iYXNlUG9zaXRpb24oKTtcclxuICAgICAgICBsZXQgYmFzZUZpZWxkO1xyXG4gICAgICAgIGlmIChiYXNlQXhpcyA9PT0geUF4aXMpIHtcclxuICAgICAgICAgICAgYmFzZUZpZWxkID0gdGhpcy5feUZpZWxkO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgYmFzZUZpZWxkID0gdGhpcy5feEZpZWxkO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBzZWdtZW50cyA9IFtdO1xyXG4gICAgICAgIGxldCBwb2ludHMgPSBbXTtcclxuICAgICAgICBzZWdtZW50cy5wdXNoKHBvaW50cyk7XHJcbiAgICAgICAgY29uc3Qgc3Ryb2tlVGVtcGxhdGVGaWVsZCA9IHRoaXMuc3Ryb2tlcy50ZW1wbGF0ZS5nZXQoXCJ0ZW1wbGF0ZUZpZWxkXCIpO1xyXG4gICAgICAgIGNvbnN0IGZpbGxUZW1wbGF0ZUZpZWxkID0gdGhpcy5maWxscy50ZW1wbGF0ZS5nZXQoXCJ0ZW1wbGF0ZUZpZWxkXCIpO1xyXG4gICAgICAgIGxldCBsb2NhdGlvblggPSB0aGlzLmdldChcImxvY2F0aW9uWFwiLCAwLjUpO1xyXG4gICAgICAgIGxldCBsb2NhdGlvblkgPSB0aGlzLmdldChcImxvY2F0aW9uWVwiLCAwLjUpO1xyXG4gICAgICAgIGxldCBvcGVuTG9jYXRpb25YID0gdGhpcy5nZXQoXCJvcGVuTG9jYXRpb25YXCIsIGxvY2F0aW9uWCk7XHJcbiAgICAgICAgbGV0IG9wZW5Mb2NhdGlvblkgPSB0aGlzLmdldChcIm9wZW5Mb2NhdGlvbllcIiwgbG9jYXRpb25ZKTtcclxuICAgICAgICBjb25zdCBtaW5EaXN0YW5jZSA9IHRoaXMuZ2V0KFwibWluRGlzdGFuY2VcIiwgMCk7XHJcbiAgICAgICAgbGV0IGk7XHJcbiAgICAgICAgbGV0IGZpbGxWaXNpYmxlID0gdGhpcy5maWxscy50ZW1wbGF0ZS5nZXQoXCJ2aXNpYmxlXCIpO1xyXG4gICAgICAgIGlmICh0aGlzLmF4aXNSYW5nZXMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICBmaWxsVmlzaWJsZSA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBnZXRPcGVuID0gZmFsc2U7XHJcbiAgICAgICAgaWYgKHN0YWNrZWQgfHwgeE9wZW5GaWVsZFZhbHVlIHx8IHlPcGVuRmllbGRWYWx1ZSkge1xyXG4gICAgICAgICAgICBnZXRPcGVuID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgbyA9IHtcclxuICAgICAgICAgICAgcG9pbnRzLCBzZWdtZW50cywgc3RhY2tlZCwgZ2V0T3BlbiwgYmFzZVBvc1gsIGJhc2VQb3NZLCBmaWxsVmlzaWJsZSwgeEZpZWxkLCB5RmllbGQsIHhPcGVuRmllbGQsIHlPcGVuRmllbGQsIHZjeCwgdmN5LCBiYXNlQXhpcywgeEF4aXMsIHlBeGlzLCBsb2NhdGlvblgsIGxvY2F0aW9uWSwgb3BlbkxvY2F0aW9uWCwgb3BlbkxvY2F0aW9uWSwgbWluRGlzdGFuY2VcclxuICAgICAgICB9O1xyXG4gICAgICAgIGZvciAoaSA9IGRhdGFJdGVtSW5kZXg7IGkgPCBjdXJyZW50RW5kSW5kZXg7IGkrKykge1xyXG4gICAgICAgICAgICB0aGlzLl9kaW5kZXggPSBpO1xyXG4gICAgICAgICAgICBjb25zdCBkYXRhSXRlbSA9IHRoaXMuX2RhdGFJdGVtc1tpXTtcclxuICAgICAgICAgICAgbGV0IHZhbHVlWCA9IGRhdGFJdGVtLmdldCh4RmllbGQpO1xyXG4gICAgICAgICAgICBsZXQgdmFsdWVZID0gZGF0YUl0ZW0uZ2V0KHlGaWVsZCk7XHJcbiAgICAgICAgICAgIGlmICh2YWx1ZVggPT0gbnVsbCB8fCB2YWx1ZVkgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFjb25uZWN0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRzID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgc2VnbWVudHMucHVzaChwb2ludHMpO1xyXG4gICAgICAgICAgICAgICAgICAgIG8ucG9pbnRzID0gcG9pbnRzO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZ2V0UG9pbnRzKGRhdGFJdGVtLCBvKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoc3Ryb2tlVGVtcGxhdGVGaWVsZCkge1xyXG4gICAgICAgICAgICAgICAgbGV0IHN0cm9rZVRlbXBsYXRlID0gZGF0YUl0ZW0uZGF0YUNvbnRleHRbc3Ryb2tlVGVtcGxhdGVGaWVsZF07XHJcbiAgICAgICAgICAgICAgICBpZiAoc3Ryb2tlVGVtcGxhdGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIShzdHJva2VUZW1wbGF0ZSBpbnN0YW5jZW9mIFRlbXBsYXRlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJva2VUZW1wbGF0ZSA9IFRlbXBsYXRlLm5ldyhzdHJva2VUZW1wbGF0ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0cm9rZVRlbXBsYXRlID0gc3Ryb2tlVGVtcGxhdGU7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgPiBkYXRhSXRlbUluZGV4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRFbmRJbmRleCA9IGk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3Ryb2tlLnRlbXBsYXRlID0gc3Ryb2tlVGVtcGxhdGU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChmaWxsVGVtcGxhdGVGaWVsZCkge1xyXG4gICAgICAgICAgICAgICAgbGV0IGZpbGxUZW1wbGF0ZSA9IGRhdGFJdGVtLmRhdGFDb250ZXh0W2ZpbGxUZW1wbGF0ZUZpZWxkXTtcclxuICAgICAgICAgICAgICAgIGlmIChmaWxsVGVtcGxhdGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIShmaWxsVGVtcGxhdGUgaW5zdGFuY2VvZiBUZW1wbGF0ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmlsbFRlbXBsYXRlID0gVGVtcGxhdGUubmV3KGZpbGxUZW1wbGF0ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2ZpbGxUZW1wbGF0ZSA9IGZpbGxUZW1wbGF0ZTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaSA+IGRhdGFJdGVtSW5kZXgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudEVuZEluZGV4ID0gaTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmaWxsLnRlbXBsYXRlID0gZmlsbFRlbXBsYXRlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIWNvbm5lY3QpIHtcclxuICAgICAgICAgICAgICAgIGxldCBuZXh0SXRlbSA9IHRoaXMuZGF0YUl0ZW1zW2kgKyAxXTtcclxuICAgICAgICAgICAgICAgIGlmIChuZXh0SXRlbSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChiYXNlQXhpcy5zaG91bGRHYXAoZGF0YUl0ZW0sIG5leHRJdGVtLCBhdXRvR2FwQ291bnQsIGJhc2VGaWVsZCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRzID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlZ21lbnRzLnB1c2gocG9pbnRzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgby5wb2ludHMgPSBwb2ludHM7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZpbGwuc2V0UmF3KFwidXNlckRhdGFcIiwgW2RhdGFJdGVtSW5kZXgsIGldKTtcclxuICAgICAgICBzdHJva2Uuc2V0UmF3KFwidXNlckRhdGFcIiwgW2RhdGFJdGVtSW5kZXgsIGldKTtcclxuICAgICAgICBpZiAoaSA9PT0gZW5kSW5kZXgpIHtcclxuICAgICAgICAgICAgdGhpcy5fZW5kTGluZShwb2ludHMsIHNlZ21lbnRzWzBdWzBdKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHN0cm9rZSkge1xyXG4gICAgICAgICAgICB0aGlzLl9kcmF3U3Ryb2tlKHN0cm9rZSwgc2VnbWVudHMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZmlsbCkge1xyXG4gICAgICAgICAgICB0aGlzLl9kcmF3RmlsbChmaWxsLCBzZWdtZW50cyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuYXhpc1Jhbmdlcy5lYWNoKChheGlzUmFuZ2UpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgY29udGFpbmVyID0gYXhpc1JhbmdlLmNvbnRhaW5lcjtcclxuICAgICAgICAgICAgY29uc3QgZmlsbHMgPSBheGlzUmFuZ2UuZmlsbHM7XHJcbiAgICAgICAgICAgIGNvbnN0IGZpbGwgPSB0aGlzLm1ha2VGaWxsKGZpbGxzKTtcclxuICAgICAgICAgICAgaWYgKGNvbnRhaW5lcikge1xyXG4gICAgICAgICAgICAgICAgY29udGFpbmVyLmNoaWxkcmVuLnB1c2goZmlsbCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZmlsbC5zZXRQcml2YXRlKFwidmlzaWJsZVwiLCB0cnVlKTtcclxuICAgICAgICAgICAgdGhpcy5fZHJhd0ZpbGwoZmlsbCwgc2VnbWVudHMpO1xyXG4gICAgICAgICAgICBjb25zdCBzdHJva2VzID0gYXhpc1JhbmdlLnN0cm9rZXM7XHJcbiAgICAgICAgICAgIGNvbnN0IHN0cm9rZSA9IHRoaXMubWFrZVN0cm9rZShzdHJva2VzKTtcclxuICAgICAgICAgICAgaWYgKGNvbnRhaW5lcikge1xyXG4gICAgICAgICAgICAgICAgY29udGFpbmVyLmNoaWxkcmVuLnB1c2goc3Ryb2tlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBzdHJva2Uuc2V0UHJpdmF0ZShcInZpc2libGVcIiwgdHJ1ZSk7XHJcbiAgICAgICAgICAgIHRoaXMuX2RyYXdTdHJva2Uoc3Ryb2tlLCBzZWdtZW50cyk7XHJcbiAgICAgICAgICAgIGZpbGwuc2V0UmF3KFwidXNlckRhdGFcIiwgW2RhdGFJdGVtSW5kZXgsIGldKTtcclxuICAgICAgICAgICAgc3Ryb2tlLnNldFJhdyhcInVzZXJEYXRhXCIsIFtkYXRhSXRlbUluZGV4LCBpXSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBfZ2V0UG9pbnRzKGRhdGFJdGVtLCBvKSB7XHJcbiAgICAgICAgbGV0IHBvaW50cyA9IG8ucG9pbnRzO1xyXG4gICAgICAgIGxldCBpdGVtTG9jYXRpb25YID0gZGF0YUl0ZW0uZ2V0KFwibG9jYXRpb25YXCIsIG8ubG9jYXRpb25YKTtcclxuICAgICAgICBsZXQgaXRlbUxvY2F0aW9uWSA9IGRhdGFJdGVtLmdldChcImxvY2F0aW9uWVwiLCBvLmxvY2F0aW9uWSk7XHJcbiAgICAgICAgbGV0IHhQb3MgPSBvLnhBeGlzLmdldERhdGFJdGVtUG9zaXRpb25YKGRhdGFJdGVtLCBvLnhGaWVsZCwgaXRlbUxvY2F0aW9uWCwgby52Y3gpO1xyXG4gICAgICAgIGxldCB5UG9zID0gby55QXhpcy5nZXREYXRhSXRlbVBvc2l0aW9uWShkYXRhSXRlbSwgby55RmllbGQsIGl0ZW1Mb2NhdGlvblksIG8udmN5KTtcclxuICAgICAgICBpZiAodGhpcy5fc2hvdWxkSW5jbHVkZSh4UG9zKSkge1xyXG4gICAgICAgICAgICBjb25zdCBpUG9pbnQgPSB0aGlzLmdldFBvaW50KHhQb3MsIHlQb3MpO1xyXG4gICAgICAgICAgICBjb25zdCBwb2ludCA9IFtpUG9pbnQueCwgaVBvaW50LnldO1xyXG4gICAgICAgICAgICBpUG9pbnQueCArPSB0aGlzLl94O1xyXG4gICAgICAgICAgICBpUG9pbnQueSArPSB0aGlzLl95O1xyXG4gICAgICAgICAgICBkYXRhSXRlbS5zZXQoXCJwb2ludFwiLCBpUG9pbnQpO1xyXG4gICAgICAgICAgICBpZiAoby5maWxsVmlzaWJsZSkge1xyXG4gICAgICAgICAgICAgICAgbGV0IHhQb3MwID0geFBvcztcclxuICAgICAgICAgICAgICAgIGxldCB5UG9zMCA9IHlQb3M7XHJcbiAgICAgICAgICAgICAgICBpZiAoby5iYXNlQXhpcyA9PT0gby54QXhpcykge1xyXG4gICAgICAgICAgICAgICAgICAgIHlQb3MwID0gby5iYXNlUG9zWTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG8uYmFzZUF4aXMgPT09IG8ueUF4aXMpIHtcclxuICAgICAgICAgICAgICAgICAgICB4UG9zMCA9IG8uYmFzZVBvc1g7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoby5nZXRPcGVuKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHZhbHVlWCA9IGRhdGFJdGVtLmdldChvLnhPcGVuRmllbGQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCB2YWx1ZVkgPSBkYXRhSXRlbS5nZXQoby55T3BlbkZpZWxkKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWVYICE9IG51bGwgJiYgdmFsdWVZICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGl0ZW1Mb2NhdGlvblggPSBkYXRhSXRlbS5nZXQoXCJvcGVuTG9jYXRpb25YXCIsIG8ub3BlbkxvY2F0aW9uWCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBpdGVtTG9jYXRpb25ZID0gZGF0YUl0ZW0uZ2V0KFwib3BlbkxvY2F0aW9uWVwiLCBvLm9wZW5Mb2NhdGlvblkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoby5zdGFja2VkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgc3RhY2tUb0l0ZW1YID0gZGF0YUl0ZW0uZ2V0KFwic3RhY2tUb0l0ZW1YXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHN0YWNrVG9JdGVtWSA9IGRhdGFJdGVtLmdldChcInN0YWNrVG9JdGVtWVwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdGFja1RvSXRlbVgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4UG9zMCA9IG8ueEF4aXMuZ2V0RGF0YUl0ZW1Qb3NpdGlvblgoc3RhY2tUb0l0ZW1YLCBvLnhGaWVsZCwgaXRlbUxvY2F0aW9uWCwgc3RhY2tUb0l0ZW1YLmNvbXBvbmVudC5nZXQoXCJ2Y3hcIikpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgkdHlwZS5pc05hTih4UG9zMCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeFBvczAgPSBvLmJhc2VQb3NYO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvLnlBeGlzID09PSBvLmJhc2VBeGlzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHhQb3MwID0gby5iYXNlUG9zWDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHhQb3MwID0gby54QXhpcy5nZXREYXRhSXRlbVBvc2l0aW9uWChkYXRhSXRlbSwgby54T3BlbkZpZWxkLCBpdGVtTG9jYXRpb25YLCBvLnZjeCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0YWNrVG9JdGVtWSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHlQb3MwID0gby55QXhpcy5nZXREYXRhSXRlbVBvc2l0aW9uWShzdGFja1RvSXRlbVksIG8ueUZpZWxkLCBpdGVtTG9jYXRpb25ZLCBzdGFja1RvSXRlbVkuY29tcG9uZW50LmdldChcInZjeVwiKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCR0eXBlLmlzTmFOKHlQb3MwKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5UG9zMCA9IG8uYmFzZVBvc1k7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG8ueEF4aXMgPT09IG8uYmFzZUF4aXMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeVBvczAgPSBvLmJhc2VQb3NZO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeVBvczAgPSBvLnlBeGlzLmdldERhdGFJdGVtUG9zaXRpb25ZKGRhdGFJdGVtLCBvLnlPcGVuRmllbGQsIGl0ZW1Mb2NhdGlvblksIG8udmN5KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4UG9zMCA9IG8ueEF4aXMuZ2V0RGF0YUl0ZW1Qb3NpdGlvblgoZGF0YUl0ZW0sIG8ueE9wZW5GaWVsZCwgaXRlbUxvY2F0aW9uWCwgby52Y3gpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeVBvczAgPSBvLnlBeGlzLmdldERhdGFJdGVtUG9zaXRpb25ZKGRhdGFJdGVtLCBvLnlPcGVuRmllbGQsIGl0ZW1Mb2NhdGlvblksIG8udmN5KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGxldCBjbG9zZUlQb2ludCA9IHRoaXMuZ2V0UG9pbnQoeFBvczAsIHlQb3MwKTtcclxuICAgICAgICAgICAgICAgIHBvaW50WzJdID0gY2xvc2VJUG9pbnQueDtcclxuICAgICAgICAgICAgICAgIHBvaW50WzNdID0gY2xvc2VJUG9pbnQueTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoby5taW5EaXN0YW5jZSA+IDApIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHAwID0gcG9pbnRbMF07XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwMSA9IHBvaW50WzFdO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcDIgPSBwb2ludFsyXTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHAzID0gcG9pbnRbM107XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwcmV2ID0gdGhpcy5fcHJldmlvdXNQb2ludDtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHBwMCA9IHByZXZbMF07XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwcDEgPSBwcmV2WzFdO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcHAyID0gcHJldlsyXTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHBwMyA9IHByZXZbM107XHJcbiAgICAgICAgICAgICAgICBpZiAoTWF0aC5oeXBvdChwMCAtIHBwMCwgcDEgLSBwcDEpID4gby5taW5EaXN0YW5jZSB8fCAocDIgJiYgcDMgJiYgTWF0aC5oeXBvdChwMiAtIHBwMiwgcDMgLSBwcDMpID4gby5taW5EaXN0YW5jZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBwb2ludHMucHVzaChwb2ludCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcHJldmlvdXNQb2ludCA9IHBvaW50O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcG9pbnRzLnB1c2gocG9pbnQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgX2VuZExpbmUoX3BvaW50cywgX2ZpcnN0UG9pbnQpIHtcclxuICAgIH1cclxuICAgIF9kcmF3U3Ryb2tlKGdyYXBoaWNzLCBzZWdtZW50cykge1xyXG4gICAgICAgIGlmIChncmFwaGljcy5nZXQoXCJ2aXNpYmxlXCIpICYmICFncmFwaGljcy5nZXQoXCJmb3JjZUhpZGRlblwiKSkge1xyXG4gICAgICAgICAgICBncmFwaGljcy5zZXQoXCJkcmF3XCIsIChkaXNwbGF5KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAkYXJyYXkuZWFjaChzZWdtZW50cywgKHNlZ21lbnQpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdHJva2VHZW5lcmF0b3IuY29udGV4dChkaXNwbGF5KTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdHJva2VHZW5lcmF0b3Ioc2VnbWVudCk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgX2RyYXdGaWxsKGdyYXBoaWNzLCBzZWdtZW50cykge1xyXG4gICAgICAgIGlmIChncmFwaGljcy5nZXQoXCJ2aXNpYmxlXCIpICYmICFncmFwaGljcy5nZXQoXCJmb3JjZUhpZGRlblwiKSkge1xyXG4gICAgICAgICAgICBncmFwaGljcy5zZXQoXCJkcmF3XCIsIChkaXNwbGF5KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAkYXJyYXkuZWFjaChzZWdtZW50cywgKHNlZ21lbnQpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9maWxsR2VuZXJhdG9yLmNvbnRleHQoZGlzcGxheSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZmlsbEdlbmVyYXRvcihzZWdtZW50KTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBfcHJvY2Vzc0F4aXNSYW5nZShheGlzUmFuZ2UpIHtcclxuICAgICAgICBzdXBlci5fcHJvY2Vzc0F4aXNSYW5nZShheGlzUmFuZ2UpO1xyXG4gICAgICAgIGF4aXNSYW5nZS5maWxscyA9IG5ldyBMaXN0VGVtcGxhdGUoVGVtcGxhdGUubmV3KHt9KSwgKCkgPT4gR3JhcGhpY3MuX25ldyh0aGlzLl9yb290LCB7XHJcbiAgICAgICAgICAgIHRoZW1lVGFnczogJHV0aWxzLm1lcmdlVGFncyhheGlzUmFuZ2UuZmlsbHMudGVtcGxhdGUuZ2V0KFwidGhlbWVUYWdzXCIsIFtdKSwgW1wibGluZVwiLCBcInNlcmllc1wiLCBcImZpbGxcIl0pLFxyXG4gICAgICAgIH0sIFt0aGlzLmZpbGxzLnRlbXBsYXRlLCBheGlzUmFuZ2UuZmlsbHMudGVtcGxhdGVdKSk7XHJcbiAgICAgICAgYXhpc1JhbmdlLnN0cm9rZXMgPSBuZXcgTGlzdFRlbXBsYXRlKFRlbXBsYXRlLm5ldyh7fSksICgpID0+IEdyYXBoaWNzLl9uZXcodGhpcy5fcm9vdCwge1xyXG4gICAgICAgICAgICB0aGVtZVRhZ3M6ICR1dGlscy5tZXJnZVRhZ3MoYXhpc1JhbmdlLnN0cm9rZXMudGVtcGxhdGUuZ2V0KFwidGhlbWVUYWdzXCIsIFtdKSwgW1wibGluZVwiLCBcInNlcmllc1wiLCBcInN0cm9rZVwiXSksXHJcbiAgICAgICAgfSwgW3RoaXMuc3Ryb2tlcy50ZW1wbGF0ZSwgYXhpc1JhbmdlLnN0cm9rZXMudGVtcGxhdGVdKSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEBpZ25vcmVcclxuICAgICAqL1xyXG4gICAgY3JlYXRlTGVnZW5kTWFya2VyKF9kYXRhSXRlbSkge1xyXG4gICAgICAgIGNvbnN0IGxlZ2VuZERhdGFJdGVtID0gdGhpcy5nZXQoXCJsZWdlbmREYXRhSXRlbVwiKTtcclxuICAgICAgICBpZiAobGVnZW5kRGF0YUl0ZW0pIHtcclxuICAgICAgICAgICAgY29uc3QgbWFya2VyID0gbGVnZW5kRGF0YUl0ZW0uZ2V0KFwibWFya2VyXCIpO1xyXG4gICAgICAgICAgICBjb25zdCBtYXJrZXJSZWN0YW5nbGUgPSBsZWdlbmREYXRhSXRlbS5nZXQoXCJtYXJrZXJSZWN0YW5nbGVcIik7XHJcbiAgICAgICAgICAgIGlmIChtYXJrZXJSZWN0YW5nbGUpIHtcclxuICAgICAgICAgICAgICAgIG1hcmtlclJlY3RhbmdsZS5zZXRQcml2YXRlKFwidmlzaWJsZVwiLCBmYWxzZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbWFya2VyLnNldChcImJhY2tncm91bmRcIiwgUmVjdGFuZ2xlLm5ldyhtYXJrZXIuX3Jvb3QsIHsgZmlsbE9wYWNpdHk6IDAsIGZpbGw6IGNvbG9yKDB4MDAwMDAwKSB9KSk7XHJcbiAgICAgICAgICAgIGNvbnN0IGxlZ2VuZFN0cm9rZSA9IG1hcmtlci5jaGlsZHJlbi5wdXNoKEdyYXBoaWNzLl9uZXcobWFya2VyLl9yb290LCB7XHJcbiAgICAgICAgICAgICAgICB0aGVtZVRhZ3M6IFtcImxpbmVcIiwgXCJzZXJpZXNcIiwgXCJsZWdlbmRcIiwgXCJtYXJrZXJcIiwgXCJzdHJva2VcIl0sIGludGVyYWN0aXZlOiBmYWxzZVxyXG4gICAgICAgICAgICB9LCBbdGhpcy5zdHJva2VzLnRlbXBsYXRlXSkpO1xyXG4gICAgICAgICAgICB0aGlzLl9sZWdlbmRTdHJva2UgPSBsZWdlbmRTdHJva2U7XHJcbiAgICAgICAgICAgIGNvbnN0IGxlZ2VuZEZpbGwgPSBtYXJrZXIuY2hpbGRyZW4ucHVzaChHcmFwaGljcy5fbmV3KG1hcmtlci5fcm9vdCwge1xyXG4gICAgICAgICAgICAgICAgdGhlbWVUYWdzOiBbXCJsaW5lXCIsIFwic2VyaWVzXCIsIFwibGVnZW5kXCIsIFwibWFya2VyXCIsIFwiZmlsbFwiXVxyXG4gICAgICAgICAgICB9LCBbdGhpcy5maWxscy50ZW1wbGF0ZV0pKTtcclxuICAgICAgICAgICAgdGhpcy5fbGVnZW5kRmlsbCA9IGxlZ2VuZEZpbGw7XHJcbiAgICAgICAgICAgIGNvbnN0IGRpc2FibGVkQ29sb3IgPSB0aGlzLl9yb290LmludGVyZmFjZUNvbG9ycy5nZXQoXCJkaXNhYmxlZFwiKTtcclxuICAgICAgICAgICAgbGVnZW5kU3Ryb2tlLnN0YXRlcy5jcmVhdGUoXCJkaXNhYmxlZFwiLCB7IGZpbGw6IGRpc2FibGVkQ29sb3IsIHN0cm9rZTogZGlzYWJsZWRDb2xvciB9KTtcclxuICAgICAgICAgICAgbGVnZW5kRmlsbC5zdGF0ZXMuY3JlYXRlKFwiZGlzYWJsZWRcIiwgeyBmaWxsOiBkaXNhYmxlZENvbG9yLCBzdHJva2U6IGRpc2FibGVkQ29sb3IgfSk7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmJ1bGxldHMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYnVsbGV0RnVuY3Rpb24gPSB0aGlzLmJ1bGxldHMuZ2V0SW5kZXgoMCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoYnVsbGV0RnVuY3Rpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBidWxsZXQgPSBidWxsZXRGdW5jdGlvbihtYXJrZXIuX3Jvb3QsIHRoaXMsIG5ldyBEYXRhSXRlbSh0aGlzLCB7IGxlZ2VuZDogdHJ1ZSB9LCB7fSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChidWxsZXQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3ByaXRlID0gYnVsbGV0LmdldChcInNwcml0ZVwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNwcml0ZSBpbnN0YW5jZW9mIEdyYXBoaWNzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcHJpdGUuc3RhdGVzLmNyZWF0ZShcImRpc2FibGVkXCIsIHsgZmlsbDogZGlzYWJsZWRDb2xvciwgc3Ryb2tlOiBkaXNhYmxlZENvbG9yIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzcHJpdGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNwcml0ZS5zZXQoXCJ0b29sdGlwVGV4dFwiLCB1bmRlZmluZWQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ByaXRlLnNldChcInRvb2x0aXBIVE1MXCIsIHVuZGVmaW5lZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXJrZXIuY2hpbGRyZW4ucHVzaChzcHJpdGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ByaXRlLnNldEFsbCh7IHg6IG1hcmtlci53aWR0aCgpIC8gMiwgeTogbWFya2VyLmhlaWdodCgpIC8gMiB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcmtlci5ldmVudHMub24oXCJib3VuZHNjaGFuZ2VkXCIsICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcHJpdGUuc2V0QWxsKHsgeDogbWFya2VyLndpZHRoKCkgLyAyLCB5OiBtYXJrZXIuaGVpZ2h0KCkgLyAyIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KExpbmVTZXJpZXMsIFwiY2xhc3NOYW1lXCIsIHtcclxuICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgIHZhbHVlOiBcIkxpbmVTZXJpZXNcIlxyXG59KTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KExpbmVTZXJpZXMsIFwiY2xhc3NOYW1lc1wiLCB7XHJcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICB2YWx1ZTogWFlTZXJpZXMuY2xhc3NOYW1lcy5jb25jYXQoW0xpbmVTZXJpZXMuY2xhc3NOYW1lXSlcclxufSk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUxpbmVTZXJpZXMuanMubWFwIiwiaW1wb3J0IHsgX19hd2FpdGVyIH0gZnJvbSBcInRzbGliXCI7XHJcbmltcG9ydCB7IERhdGFJdGVtIH0gZnJvbSBcIi4uLy4uLy4uL2NvcmUvcmVuZGVyL0NvbXBvbmVudFwiO1xyXG5pbXBvcnQgeyBTZXJpZXMgfSBmcm9tIFwiLi4vLi4vLi4vY29yZS9yZW5kZXIvU2VyaWVzXCI7XHJcbmltcG9ydCB7IExpc3QgfSBmcm9tIFwiLi4vLi4vLi4vY29yZS91dGlsL0xpc3RcIjtcclxuaW1wb3J0IHsgQ29udGFpbmVyIH0gZnJvbSBcIi4uLy4uLy4uL2NvcmUvcmVuZGVyL0NvbnRhaW5lclwiO1xyXG5pbXBvcnQgeyBHcmFwaGljcyB9IGZyb20gXCIuLi8uLi8uLi9jb3JlL3JlbmRlci9HcmFwaGljc1wiO1xyXG5pbXBvcnQgKiBhcyAkdHlwZSBmcm9tIFwiLi4vLi4vLi4vY29yZS91dGlsL1R5cGVcIjtcclxuaW1wb3J0ICogYXMgJG9iamVjdCBmcm9tIFwiLi4vLi4vLi4vY29yZS91dGlsL09iamVjdFwiO1xyXG5pbXBvcnQgKiBhcyAkYXJyYXkgZnJvbSBcIi4uLy4uLy4uL2NvcmUvdXRpbC9BcnJheVwiO1xyXG5pbXBvcnQgKiBhcyAkdXRpbHMgZnJvbSBcIi4uLy4uLy4uL2NvcmUvdXRpbC9VdGlsc1wiO1xyXG4vKipcclxuICogQGlnbm9yZVxyXG4gKi9cclxuZnVuY3Rpb24gbWluKGxlZnQsIHJpZ2h0KSB7XHJcbiAgICBpZiAobGVmdCA9PSBudWxsKSB7XHJcbiAgICAgICAgcmV0dXJuIHJpZ2h0O1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAocmlnaHQgPT0gbnVsbCkge1xyXG4gICAgICAgIHJldHVybiBsZWZ0O1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAocmlnaHQgPCBsZWZ0KSB7XHJcbiAgICAgICAgcmV0dXJuIHJpZ2h0O1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIGxlZnQ7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEBpZ25vcmVcclxuICovXHJcbmZ1bmN0aW9uIG1heChsZWZ0LCByaWdodCkge1xyXG4gICAgaWYgKGxlZnQgPT0gbnVsbCkge1xyXG4gICAgICAgIHJldHVybiByaWdodDtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHJpZ2h0ID09IG51bGwpIHtcclxuICAgICAgICByZXR1cm4gbGVmdDtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHJpZ2h0ID4gbGVmdCkge1xyXG4gICAgICAgIHJldHVybiByaWdodDtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBsZWZ0O1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBBIGJhc2UgY2xhc3MgZm9yIGFsbCBYWSBjaGFydCBzZXJpZXMuXHJcbiAqXHJcbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vd3d3LmFtY2hhcnRzLmNvbS9kb2NzL3Y1L2NoYXJ0cy94eS1jaGFydC9zZXJpZXMvfSBmb3IgbW9yZSBpbmZvXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgWFlTZXJpZXMgZXh0ZW5kcyBTZXJpZXMge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfeEZpZWxkXCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl95RmllbGRcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX3hPcGVuRmllbGRcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX3lPcGVuRmllbGRcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX3hMb3dGaWVsZFwiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfeEhpZ2hGaWVsZFwiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfeUxvd0ZpZWxkXCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl95SGlnaEZpZWxkXCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9heGVzRGlydHlcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogZmFsc2VcclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfc3RhY2tEaXJ0eVwiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiBmYWxzZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9zZWxlY3Rpb25Qcm9jZXNzZWRcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogZmFsc2VcclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfZGF0YVNldHNcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZToge31cclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfbWFpbkNvbnRhaW5lck1hc2tcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX3hcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogMFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl95XCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IDBcclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfYnVsbGV0c1wiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiB7fVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEEgW1tDb250YWluZXJdXSB0aGF0IHVzIHVzZWQgdG8gcHV0IHNlcmllcycgZWxlbWVudHMgaW4uXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAZGVmYXVsdCBDb250YWluZXIubmV3KClcclxuICAgICAgICAgKi9cclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJtYWluQ29udGFpbmVyXCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IHRoaXMuY2hpbGRyZW4ucHVzaChDb250YWluZXIubmV3KHRoaXMuX3Jvb3QsIHt9KSlcclxuICAgICAgICB9KTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBIGxpc3Qgb2YgYXhpcyByYW5nZXMgdGhhdCBhZmZlY3QgdGhlIHNlcmllcy5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vd3d3LmFtY2hhcnRzLmNvbS9kb2NzL3Y1L2NoYXJ0cy94eS1jaGFydC9heGVzL2F4aXMtcmFuZ2VzL30gZm9yIG1vcmUgaW5mb1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImF4aXNSYW5nZXNcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogbmV3IExpc3QoKVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9za2lwcGVkXCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IGZhbHNlXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX2NvdWxkU3RhY2tUb1wiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiBbXVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9yZWFsbHlTdGFja2VkVG9cIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZToge31cclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfc3RhY2tlZFNlcmllc1wiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiB7fVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9hTG9jYXRpb25YMFwiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiAwXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX2FMb2NhdGlvblgxXCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IDFcclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfYUxvY2F0aW9uWTBcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogMFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9hTG9jYXRpb25ZMVwiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiAxXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX3Nob3dCdWxsZXRzXCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IHRydWVcclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ2YWx1ZVhGaWVsZHNcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogW1xyXG4gICAgICAgICAgICAgICAgXCJ2YWx1ZVhcIixcclxuICAgICAgICAgICAgICAgIFwib3BlblZhbHVlWFwiLFxyXG4gICAgICAgICAgICAgICAgXCJsb3dWYWx1ZVhcIixcclxuICAgICAgICAgICAgICAgIFwiaGlnaFZhbHVlWFwiXHJcbiAgICAgICAgICAgIF1cclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ2YWx1ZVlGaWVsZHNcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogW1xyXG4gICAgICAgICAgICAgICAgXCJ2YWx1ZVlcIixcclxuICAgICAgICAgICAgICAgIFwib3BlblZhbHVlWVwiLFxyXG4gICAgICAgICAgICAgICAgXCJsb3dWYWx1ZVlcIixcclxuICAgICAgICAgICAgICAgIFwiaGlnaFZhbHVlWVwiXHJcbiAgICAgICAgICAgIF1cclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfdmFsdWVYRmllbGRzXCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl92YWx1ZVlGaWVsZHNcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLy8gdXNlZCBmb3IgZnVsbCBtaW4vbWF4XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX3ZhbHVlWFNob3dGaWVsZHNcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX3ZhbHVlWVNob3dGaWVsZHNcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLy8gdXNlZCBmb3Igc2VsZWN0aW9uICh1c2VzIHdvcmtpbmcpXHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX192YWx1ZVhTaG93RmllbGRzXCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9fdmFsdWVZU2hvd0ZpZWxkc1wiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfZW1wdHlEYXRhSXRlbVwiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiBuZXcgRGF0YUl0ZW0odGhpcywgdW5kZWZpbmVkLCB7fSlcclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfZGF0YVNldElkXCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl90b29sdGlwRmllbGRYXCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl90b29sdGlwRmllbGRZXCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9wb3NYRHBcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX3Bvc1lEcFwiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIF9hZnRlck5ldygpIHtcclxuICAgICAgICB0aGlzLmZpZWxkcy5wdXNoKFwiY2F0ZWdvcnlYXCIsIFwiY2F0ZWdvcnlZXCIsIFwib3BlbkNhdGVnb3J5WFwiLCBcIm9wZW5DYXRlZ29yeVlcIik7XHJcbiAgICAgICAgdGhpcy52YWx1ZUZpZWxkcy5wdXNoKFwidmFsdWVYXCIsIFwidmFsdWVZXCIsIFwib3BlblZhbHVlWFwiLCBcIm9wZW5WYWx1ZVlcIiwgXCJsb3dWYWx1ZVhcIiwgXCJsb3dWYWx1ZVlcIiwgXCJoaWdoVmFsdWVYXCIsIFwiaGlnaFZhbHVlWVwiKTtcclxuICAgICAgICB0aGlzLl9zZXRSYXdEZWZhdWx0KFwidmN4XCIsIDEpO1xyXG4gICAgICAgIHRoaXMuX3NldFJhd0RlZmF1bHQoXCJ2Y3lcIiwgMSk7XHJcbiAgICAgICAgLy8gdGhpcyBjYW4ndCBnbyB0byB0aGVtZXMsIGFzIGRhdGEgbWlnaHQgYmUgcGFyc2VkIGJlZm9yZSB0aGVtZVxyXG4gICAgICAgIHRoaXMuX3NldFJhd0RlZmF1bHQoXCJ2YWx1ZVhTaG93XCIsIFwidmFsdWVYV29ya2luZ1wiKTtcclxuICAgICAgICB0aGlzLl9zZXRSYXdEZWZhdWx0KFwidmFsdWVZU2hvd1wiLCBcInZhbHVlWVdvcmtpbmdcIik7XHJcbiAgICAgICAgdGhpcy5fc2V0UmF3RGVmYXVsdChcIm9wZW5WYWx1ZVhTaG93XCIsIFwib3BlblZhbHVlWFdvcmtpbmdcIik7XHJcbiAgICAgICAgdGhpcy5fc2V0UmF3RGVmYXVsdChcIm9wZW5WYWx1ZVlTaG93XCIsIFwib3BlblZhbHVlWVdvcmtpbmdcIik7XHJcbiAgICAgICAgdGhpcy5fc2V0UmF3RGVmYXVsdChcImxvd1ZhbHVlWFNob3dcIiwgXCJsb3dWYWx1ZVhXb3JraW5nXCIpO1xyXG4gICAgICAgIHRoaXMuX3NldFJhd0RlZmF1bHQoXCJsb3dWYWx1ZVlTaG93XCIsIFwibG93VmFsdWVZV29ya2luZ1wiKTtcclxuICAgICAgICB0aGlzLl9zZXRSYXdEZWZhdWx0KFwiaGlnaFZhbHVlWFNob3dcIiwgXCJoaWdoVmFsdWVYV29ya2luZ1wiKTtcclxuICAgICAgICB0aGlzLl9zZXRSYXdEZWZhdWx0KFwiaGlnaFZhbHVlWVNob3dcIiwgXCJoaWdoVmFsdWVZV29ya2luZ1wiKTtcclxuICAgICAgICB0aGlzLl9zZXRSYXdEZWZhdWx0KFwibG93VmFsdWVYR3JvdXBlZFwiLCBcImxvd1wiKTtcclxuICAgICAgICB0aGlzLl9zZXRSYXdEZWZhdWx0KFwibG93VmFsdWVZR3JvdXBlZFwiLCBcImxvd1wiKTtcclxuICAgICAgICB0aGlzLl9zZXRSYXdEZWZhdWx0KFwiaGlnaFZhbHVlWEdyb3VwZWRcIiwgXCJoaWdoXCIpO1xyXG4gICAgICAgIHRoaXMuX3NldFJhd0RlZmF1bHQoXCJoaWdoVmFsdWVZR3JvdXBlZFwiLCBcImhpZ2hcIik7XHJcbiAgICAgICAgc3VwZXIuX2FmdGVyTmV3KCk7XHJcbiAgICAgICAgdGhpcy5zZXQoXCJtYXNrQ29udGVudFwiLCB0cnVlKTtcclxuICAgICAgICB0aGlzLl9kaXNwb3NlcnMucHVzaCh0aGlzLmF4aXNSYW5nZXMuZXZlbnRzLm9uQWxsKChjaGFuZ2UpID0+IHtcclxuICAgICAgICAgICAgaWYgKGNoYW5nZS50eXBlID09PSBcImNsZWFyXCIpIHtcclxuICAgICAgICAgICAgICAgICRhcnJheS5lYWNoKGNoYW5nZS5vbGRWYWx1ZXMsIChheGlzUmFuZ2UpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZW1vdmVBeGlzUmFuZ2UoYXhpc1JhbmdlKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGNoYW5nZS50eXBlID09PSBcInB1c2hcIikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcHJvY2Vzc0F4aXNSYW5nZShjaGFuZ2UubmV3VmFsdWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGNoYW5nZS50eXBlID09PSBcInNldEluZGV4XCIpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3Byb2Nlc3NBeGlzUmFuZ2UoY2hhbmdlLm5ld1ZhbHVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChjaGFuZ2UudHlwZSA9PT0gXCJpbnNlcnRJbmRleFwiKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9wcm9jZXNzQXhpc1JhbmdlKGNoYW5nZS5uZXdWYWx1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoY2hhbmdlLnR5cGUgPT09IFwicmVtb3ZlSW5kZXhcIikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcmVtb3ZlQXhpc1JhbmdlKGNoYW5nZS5vbGRWYWx1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoY2hhbmdlLnR5cGUgPT09IFwibW92ZUluZGV4XCIpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3Byb2Nlc3NBeGlzUmFuZ2UoY2hhbmdlLnZhbHVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gSVN0cmVhbUV2ZW50IHR5cGVcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KSk7XHJcbiAgICAgICAgdGhpcy5zdGF0ZXMuY3JlYXRlKFwiaGlkZGVuXCIsIHsgb3BhY2l0eTogMSwgdmlzaWJsZTogZmFsc2UgfSk7XHJcbiAgICAgICAgdGhpcy5fbWFrZUZpZWxkTmFtZXMoKTtcclxuICAgIH1cclxuICAgIF9wcm9jZXNzQXhpc1JhbmdlKGF4aXNSYW5nZSkge1xyXG4gICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IENvbnRhaW5lci5uZXcodGhpcy5fcm9vdCwge30pO1xyXG4gICAgICAgIGF4aXNSYW5nZS5jb250YWluZXIgPSBjb250YWluZXI7XHJcbiAgICAgICAgdGhpcy5jaGlsZHJlbi5wdXNoKGNvbnRhaW5lcik7XHJcbiAgICAgICAgYXhpc1JhbmdlLnNlcmllcyA9IHRoaXM7XHJcbiAgICAgICAgY29uc3QgYXhpc0RhdGFJdGVtID0gYXhpc1JhbmdlLmF4aXNEYXRhSXRlbTtcclxuICAgICAgICBheGlzRGF0YUl0ZW0uc2V0UmF3KFwiaXNSYW5nZVwiLCB0cnVlKTtcclxuICAgICAgICBjb25zdCBheGlzID0gYXhpc0RhdGFJdGVtLmNvbXBvbmVudDtcclxuICAgICAgICBpZiAoYXhpcykge1xyXG4gICAgICAgICAgICBheGlzLl9wcm9jZXNzQXhpc1JhbmdlKGF4aXNEYXRhSXRlbSwgW1wicmFuZ2VcIiwgXCJzZXJpZXNcIl0pO1xyXG4gICAgICAgICAgICBjb25zdCBidWxsZXQgPSBheGlzRGF0YUl0ZW0uZ2V0KFwiYnVsbGV0XCIpO1xyXG4gICAgICAgICAgICBpZiAoYnVsbGV0KSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzcHJpdGUgPSBidWxsZXQuZ2V0KFwic3ByaXRlXCIpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHNwcml0ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNwcml0ZS5zZXRQcml2YXRlKFwidmlzaWJsZVwiLCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgYXhpc0ZpbGwgPSBheGlzRGF0YUl0ZW0uZ2V0KFwiYXhpc0ZpbGxcIik7XHJcbiAgICAgICAgICAgIGlmIChheGlzRmlsbCkge1xyXG4gICAgICAgICAgICAgICAgY29udGFpbmVyLnNldChcIm1hc2tcIiwgYXhpc0ZpbGwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGF4aXMuX3Nlcmllc0F4aXNSYW5nZXMucHVzaChheGlzRGF0YUl0ZW0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIF9yZW1vdmVBeGlzUmFuZ2UoYXhpc1JhbmdlKSB7XHJcbiAgICAgICAgY29uc3QgYXhpc0RhdGFJdGVtID0gYXhpc1JhbmdlLmF4aXNEYXRhSXRlbTtcclxuICAgICAgICBjb25zdCBheGlzID0gYXhpc0RhdGFJdGVtLmNvbXBvbmVudDtcclxuICAgICAgICBheGlzLmRpc3Bvc2VEYXRhSXRlbShheGlzRGF0YUl0ZW0pO1xyXG4gICAgICAgICRhcnJheS5yZW1vdmUoYXhpcy5fc2VyaWVzQXhpc1JhbmdlcywgYXhpc0RhdGFJdGVtKTtcclxuICAgICAgICBjb25zdCBjb250YWluZXIgPSBheGlzUmFuZ2UuY29udGFpbmVyO1xyXG4gICAgICAgIGlmIChjb250YWluZXIpIHtcclxuICAgICAgICAgICAgY29udGFpbmVyLmRpc3Bvc2UoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBfdXBkYXRlRmllbGRzKCkge1xyXG4gICAgICAgIHN1cGVyLl91cGRhdGVGaWVsZHMoKTtcclxuICAgICAgICB0aGlzLl92YWx1ZVhGaWVsZHMgPSBbXTtcclxuICAgICAgICB0aGlzLl92YWx1ZVlGaWVsZHMgPSBbXTtcclxuICAgICAgICB0aGlzLl92YWx1ZVhTaG93RmllbGRzID0gW107XHJcbiAgICAgICAgdGhpcy5fdmFsdWVZU2hvd0ZpZWxkcyA9IFtdO1xyXG4gICAgICAgIHRoaXMuX192YWx1ZVhTaG93RmllbGRzID0gW107XHJcbiAgICAgICAgdGhpcy5fX3ZhbHVlWVNob3dGaWVsZHMgPSBbXTtcclxuICAgICAgICBpZiAodGhpcy52YWx1ZVhGaWVsZHMpIHtcclxuICAgICAgICAgICAgJGFycmF5LmVhY2godGhpcy52YWx1ZVhGaWVsZHMsIChrZXkpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGZpZWxkID0gdGhpcy5nZXQoKGtleSArIFwiRmllbGRcIikpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGZpZWxkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdmFsdWVYRmllbGRzLnB1c2goa2V5KTtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgZmllbGQgPSB0aGlzLmdldCgoa2V5ICsgXCJTaG93XCIpKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9fdmFsdWVYU2hvd0ZpZWxkcy5wdXNoKGZpZWxkKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZmllbGQuaW5kZXhPZihcIldvcmtpbmdcIikgIT0gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fdmFsdWVYU2hvd0ZpZWxkcy5wdXNoKGZpZWxkLnNwbGl0KFwiV29ya2luZ1wiKVswXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl92YWx1ZVhTaG93RmllbGRzLnB1c2goZmllbGQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLnZhbHVlWUZpZWxkcykge1xyXG4gICAgICAgICAgICAkYXJyYXkuZWFjaCh0aGlzLnZhbHVlWUZpZWxkcywgKGtleSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZmllbGQgPSB0aGlzLmdldCgoa2V5ICsgXCJGaWVsZFwiKSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoZmllbGQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl92YWx1ZVlGaWVsZHMucHVzaChrZXkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBmaWVsZCA9IHRoaXMuZ2V0KChrZXkgKyBcIlNob3dcIikpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX192YWx1ZVlTaG93RmllbGRzLnB1c2goZmllbGQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChmaWVsZC5pbmRleE9mKFwiV29ya2luZ1wiKSAhPSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl92YWx1ZVlTaG93RmllbGRzLnB1c2goZmllbGQuc3BsaXQoXCJXb3JraW5nXCIpWzBdKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3ZhbHVlWVNob3dGaWVsZHMucHVzaChmaWVsZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBfZGlzcG9zZSgpIHtcclxuICAgICAgICBzdXBlci5fZGlzcG9zZSgpO1xyXG4gICAgICAgIHRoaXMuX2J1bGxldHMgPSB7fTtcclxuICAgICAgICBjb25zdCBjaGFydCA9IHRoaXMuY2hhcnQ7XHJcbiAgICAgICAgaWYgKGNoYXJ0KSB7XHJcbiAgICAgICAgICAgIGNoYXJ0LnNlcmllcy5yZW1vdmVWYWx1ZSh0aGlzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgJGFycmF5LnJlbW92ZUZpcnN0KHRoaXMuZ2V0KFwieEF4aXNcIikuc2VyaWVzLCB0aGlzKTtcclxuICAgICAgICAkYXJyYXkucmVtb3ZlRmlyc3QodGhpcy5nZXQoXCJ5QXhpc1wiKS5zZXJpZXMsIHRoaXMpO1xyXG4gICAgfVxyXG4gICAgLy8gVE9ETyB1c2UgIFNlbGVjdEtleXM8dGhpc1tcIl9wcml2YXRlU2V0dGluZ3NcIl0sIG51bWJlciB8IHVuZGVmaW5lZD5cclxuICAgIF9taW4oa2V5LCB2YWx1ZSkge1xyXG4gICAgICAgIGxldCBuZXdWYWx1ZSA9IG1pbih0aGlzLmdldFByaXZhdGUoa2V5KSwgdmFsdWUpO1xyXG4gICAgICAgIHRoaXMuc2V0UHJpdmF0ZShrZXksIG5ld1ZhbHVlKTtcclxuICAgIH1cclxuICAgIC8vIFRPRE8gdXNlICBTZWxlY3RLZXlzPHRoaXNbXCJfcHJpdmF0ZVNldHRpbmdzXCJdLCBudW1iZXIgfCB1bmRlZmluZWQ+XHJcbiAgICBfbWF4KGtleSwgdmFsdWUpIHtcclxuICAgICAgICBsZXQgbmV3VmFsdWUgPSBtYXgodGhpcy5nZXRQcml2YXRlKGtleSksIHZhbHVlKTtcclxuICAgICAgICB0aGlzLnNldFByaXZhdGUoa2V5LCBuZXdWYWx1ZSk7XHJcbiAgICB9XHJcbiAgICBfc2hvdWxkTWFrZUJ1bGxldChkYXRhSXRlbSkge1xyXG4gICAgICAgIGNvbnN0IHhBeGlzID0gdGhpcy5nZXQoXCJ4QXhpc1wiKTtcclxuICAgICAgICBjb25zdCB5QXhpcyA9IHRoaXMuZ2V0KFwieUF4aXNcIik7XHJcbiAgICAgICAgY29uc3QgYmFzZUF4aXMgPSB0aGlzLmdldChcImJhc2VBeGlzXCIpO1xyXG4gICAgICAgIGlmICgheEF4aXMuaW5pdGVkIHx8ICF5QXhpcy5pbml0ZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBtaW5CdWxsZXREaXN0YW5jZSA9IHRoaXMuZ2V0KFwibWluQnVsbGV0RGlzdGFuY2VcIiwgMCk7XHJcbiAgICAgICAgaWYgKG1pbkJ1bGxldERpc3RhbmNlID4gMCkge1xyXG4gICAgICAgICAgICBsZXQgc3RhcnRJbmRleCA9IHRoaXMuc3RhcnRJbmRleCgpO1xyXG4gICAgICAgICAgICBsZXQgZW5kSW5kZXggPSB0aGlzLmVuZEluZGV4KCk7XHJcbiAgICAgICAgICAgIGxldCBjb3VudCA9IGVuZEluZGV4IC0gc3RhcnRJbmRleDtcclxuICAgICAgICAgICAgaWYgKHhBeGlzID09IGJhc2VBeGlzKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoeEF4aXMuZ2V0KFwicmVuZGVyZXJcIikuYXhpc0xlbmd0aCgpIC8gY291bnQgPCBtaW5CdWxsZXREaXN0YW5jZSAvIDUpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoeUF4aXMgPT0gYmFzZUF4aXMpIHtcclxuICAgICAgICAgICAgICAgIGlmICh5QXhpcy5nZXQoXCJyZW5kZXJlclwiKS5heGlzTGVuZ3RoKCkgLyBjb3VudCA8IG1pbkJ1bGxldERpc3RhbmNlIC8gNSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZGF0YUl0ZW0uZ2V0KHRoaXMuX3hGaWVsZCkgIT0gbnVsbCAmJiBkYXRhSXRlbS5nZXQodGhpcy5feUZpZWxkKSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBfbWFrZUZpZWxkTmFtZXMoKSB7XHJcbiAgICAgICAgY29uc3QgeEF4aXMgPSB0aGlzLmdldChcInhBeGlzXCIpO1xyXG4gICAgICAgIGNvbnN0IHlBeGlzID0gdGhpcy5nZXQoXCJ5QXhpc1wiKTtcclxuICAgICAgICBjb25zdCB4TmFtZSA9IHhBeGlzLmdldFByaXZhdGUoXCJuYW1lXCIpO1xyXG4gICAgICAgIGNvbnN0IHhDYXBOYW1lID0gJHV0aWxzLmNhcGl0YWxpemVGaXJzdCh4TmFtZSk7XHJcbiAgICAgICAgY29uc3QgeU5hbWUgPSB5QXhpcy5nZXRQcml2YXRlKFwibmFtZVwiKTtcclxuICAgICAgICBjb25zdCB5Q2FwTmFtZSA9ICR1dGlscy5jYXBpdGFsaXplRmlyc3QoeU5hbWUpO1xyXG4gICAgICAgIGNvbnN0IHhMZXR0ZXIgPSB4QXhpcy5nZXQoXCJyZW5kZXJlclwiKS5nZXRQcml2YXRlKFwibGV0dGVyXCIpO1xyXG4gICAgICAgIGNvbnN0IHlMZXR0ZXIgPSB5QXhpcy5nZXQoXCJyZW5kZXJlclwiKS5nZXRQcml2YXRlKFwibGV0dGVyXCIpO1xyXG4gICAgICAgIGNvbnN0IG9wZW4gPSBcIm9wZW5cIjtcclxuICAgICAgICBjb25zdCBsb3cgPSBcImxvd1wiO1xyXG4gICAgICAgIGNvbnN0IGhpZ2ggPSBcImhpZ2hcIjtcclxuICAgICAgICBjb25zdCBzaG93ID0gXCJTaG93XCI7XHJcbiAgICAgICAgaWYgKHhBeGlzLmNsYXNzTmFtZSA9PT0gXCJWYWx1ZUF4aXNcIikge1xyXG4gICAgICAgICAgICB0aGlzLl94RmllbGQgPSB0aGlzLmdldCgoeE5hbWUgKyB4TGV0dGVyICsgc2hvdykpO1xyXG4gICAgICAgICAgICB0aGlzLl94T3BlbkZpZWxkID0gdGhpcy5nZXQoKG9wZW4gKyB4Q2FwTmFtZSArIHhMZXR0ZXIgKyBzaG93KSk7XHJcbiAgICAgICAgICAgIHRoaXMuX3hMb3dGaWVsZCA9IHRoaXMuZ2V0KChsb3cgKyB4Q2FwTmFtZSArIHhMZXR0ZXIgKyBzaG93KSk7XHJcbiAgICAgICAgICAgIHRoaXMuX3hIaWdoRmllbGQgPSB0aGlzLmdldCgoaGlnaCArIHhDYXBOYW1lICsgeExldHRlciArIHNob3cpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3hGaWVsZCA9ICh4TmFtZSArIHhMZXR0ZXIpO1xyXG4gICAgICAgICAgICB0aGlzLl94T3BlbkZpZWxkID0gKG9wZW4gKyB4Q2FwTmFtZSArIHhMZXR0ZXIpO1xyXG4gICAgICAgICAgICB0aGlzLl94TG93RmllbGQgPSAobG93ICsgeENhcE5hbWUgKyB4TGV0dGVyKTtcclxuICAgICAgICAgICAgdGhpcy5feEhpZ2hGaWVsZCA9IChoaWdoICsgeENhcE5hbWUgKyB4TGV0dGVyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHlBeGlzLmNsYXNzTmFtZSA9PT0gXCJWYWx1ZUF4aXNcIikge1xyXG4gICAgICAgICAgICB0aGlzLl95RmllbGQgPSB0aGlzLmdldCgoeU5hbWUgKyB5TGV0dGVyICsgc2hvdykpO1xyXG4gICAgICAgICAgICB0aGlzLl95T3BlbkZpZWxkID0gdGhpcy5nZXQoKG9wZW4gKyB5Q2FwTmFtZSArIHlMZXR0ZXIgKyBzaG93KSk7XHJcbiAgICAgICAgICAgIHRoaXMuX3lMb3dGaWVsZCA9IHRoaXMuZ2V0KChsb3cgKyB5Q2FwTmFtZSArIHlMZXR0ZXIgKyBzaG93KSk7XHJcbiAgICAgICAgICAgIHRoaXMuX3lIaWdoRmllbGQgPSB0aGlzLmdldCgoaGlnaCArIHlDYXBOYW1lICsgeUxldHRlciArIHNob3cpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3lGaWVsZCA9ICh5TmFtZSArIHlMZXR0ZXIpO1xyXG4gICAgICAgICAgICB0aGlzLl95T3BlbkZpZWxkID0gKG9wZW4gKyB5Q2FwTmFtZSArIHlMZXR0ZXIpO1xyXG4gICAgICAgICAgICB0aGlzLl95TG93RmllbGQgPSAobG93ICsgeUNhcE5hbWUgKyB5TGV0dGVyKTtcclxuICAgICAgICAgICAgdGhpcy5feUhpZ2hGaWVsZCA9IChoaWdoICsgeUNhcE5hbWUgKyB5TGV0dGVyKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBfZml4VkMoKSB7XHJcbiAgICAgICAgY29uc3QgeEF4aXMgPSB0aGlzLmdldChcInhBeGlzXCIpO1xyXG4gICAgICAgIGNvbnN0IHlBeGlzID0gdGhpcy5nZXQoXCJ5QXhpc1wiKTtcclxuICAgICAgICBjb25zdCBiYXNlQXhpcyA9IHRoaXMuZ2V0KFwiYmFzZUF4aXNcIik7XHJcbiAgICAgICAgY29uc3QgaGlkZGVuU3RhdGUgPSB0aGlzLnN0YXRlcy5sb29rdXAoXCJoaWRkZW5cIik7XHJcbiAgICAgICAgY29uc3Qgc2VxdWVuY2VkSW50ZXJwb2xhdGlvbiA9IHRoaXMuZ2V0KFwic2VxdWVuY2VkSW50ZXJwb2xhdGlvblwiKTtcclxuICAgICAgICBpZiAoaGlkZGVuU3RhdGUpIHtcclxuICAgICAgICAgICAgbGV0IHZhbHVlID0gMDtcclxuICAgICAgICAgICAgaWYgKHNlcXVlbmNlZEludGVycG9sYXRpb24pIHtcclxuICAgICAgICAgICAgICAgIHZhbHVlID0gMC45OTk5OTk5OTk5OTk7IC8vIG1ha2VzIGFuaW1hdGUsIGdvb2QgZm9yIHN0YWNrZWRcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoeEF4aXMgPT09IGJhc2VBeGlzKSB7XHJcbiAgICAgICAgICAgICAgICBoaWRkZW5TdGF0ZS5zZXQoXCJ2Y3lcIiwgdmFsdWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHlBeGlzID09PSBiYXNlQXhpcykge1xyXG4gICAgICAgICAgICAgICAgaGlkZGVuU3RhdGUuc2V0KFwidmN4XCIsIHZhbHVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGhpZGRlblN0YXRlLnNldChcInZjeVwiLCB2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICBoaWRkZW5TdGF0ZS5zZXQoXCJ2Y3hcIiwgdmFsdWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgX2hhbmRsZU1hc2tCdWxsZXRzKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmlzRGlydHkoXCJtYXNrQnVsbGV0c1wiKSkge1xyXG4gICAgICAgICAgICB0aGlzLmJ1bGxldHNDb250YWluZXIuc2V0KFwibWFza0NvbnRlbnRcIiwgdGhpcy5nZXQoXCJtYXNrQnVsbGV0c1wiKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgX2ZpeFBvc2l0aW9uKCkge1xyXG4gICAgICAgIGNvbnN0IHhBeGlzID0gdGhpcy5nZXQoXCJ4QXhpc1wiKTtcclxuICAgICAgICBjb25zdCB5QXhpcyA9IHRoaXMuZ2V0KFwieUF4aXNcIik7XHJcbiAgICAgICAgdGhpcy5zZXQoXCJ4XCIsIHhBeGlzLngoKSAtICR1dGlscy5yZWxhdGl2ZVRvVmFsdWUoeEF4aXMuZ2V0KFwiY2VudGVyWFwiLCAwKSwgeEF4aXMud2lkdGgoKSkgLSB4QXhpcy5wYXJlbnQuZ2V0KFwicGFkZGluZ0xlZnRcIiwgMCkpO1xyXG4gICAgICAgIHRoaXMuc2V0KFwieVwiLCB5QXhpcy55KCkgLSAkdXRpbHMucmVsYXRpdmVUb1ZhbHVlKHlBeGlzLmdldChcImNlbnRlcllcIiwgMCksIHlBeGlzLmhlaWdodCgpKSAtIHlBeGlzLnBhcmVudC5nZXQoXCJwYWRkaW5nVG9wXCIsIDApKTtcclxuICAgICAgICB0aGlzLmJ1bGxldHNDb250YWluZXIuc2V0KFwieVwiLCB0aGlzLnkoKSk7XHJcbiAgICAgICAgdGhpcy5idWxsZXRzQ29udGFpbmVyLnNldChcInhcIiwgdGhpcy54KCkpO1xyXG4gICAgfVxyXG4gICAgX3ByZXBhcmVDaGlsZHJlbigpIHtcclxuICAgICAgICBzdXBlci5fcHJlcGFyZUNoaWxkcmVuKCk7XHJcbiAgICAgICAgdGhpcy5fYnVsbGV0cyA9IHt9O1xyXG4gICAgICAgIGlmICh0aGlzLmlzRGlydHkoXCJ2YWx1ZVlTaG93XCIpIHx8IHRoaXMuaXNEaXJ0eShcInZhbHVlWFNob3dcIikgfHwgdGhpcy5pc0RpcnR5KFwib3BlblZhbHVlWVNob3dcIikgfHwgdGhpcy5pc0RpcnR5KFwib3BlblZhbHVlWFNob3dcIikgfHwgdGhpcy5pc0RpcnR5KFwibG93VmFsdWVZU2hvd1wiKSB8fCB0aGlzLmlzRGlydHkoXCJsb3dWYWx1ZVhTaG93XCIpIHx8IHRoaXMuaXNEaXJ0eShcImhpZ2hWYWx1ZVlTaG93XCIpIHx8IHRoaXMuaXNEaXJ0eShcImhpZ2hWYWx1ZVhTaG93XCIpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZUZpZWxkcygpO1xyXG4gICAgICAgICAgICB0aGlzLl9tYWtlRmllbGROYW1lcygpO1xyXG4gICAgICAgICAgICB0aGlzLl92YWx1ZXNEaXJ0eSA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmlzRGlydHkoXCJ4QXhpc1wiKSB8fCB0aGlzLmlzRGlydHkoXCJ5QXhpc1wiKSkge1xyXG4gICAgICAgICAgICB0aGlzLl92YWx1ZXNEaXJ0eSA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuc2V0KFwid2lkdGhcIiwgdGhpcy5nZXQoXCJ4QXhpc1wiKS53aWR0aCgpKTtcclxuICAgICAgICB0aGlzLnNldChcImhlaWdodFwiLCB0aGlzLmdldChcInlBeGlzXCIpLmhlaWdodCgpKTtcclxuICAgICAgICB0aGlzLl9oYW5kbGVNYXNrQnVsbGV0cygpO1xyXG4gICAgICAgIGNvbnN0IHhBeGlzID0gdGhpcy5nZXQoXCJ4QXhpc1wiKTtcclxuICAgICAgICBjb25zdCB5QXhpcyA9IHRoaXMuZ2V0KFwieUF4aXNcIik7XHJcbiAgICAgICAgY29uc3QgYmFzZUF4aXMgPSB0aGlzLmdldChcImJhc2VBeGlzXCIpO1xyXG4gICAgICAgIGNvbnN0IHRvb2x0aXBQb3NpdGlvblggPSB0aGlzLmdldChcInRvb2x0aXBQb3NpdGlvblhcIik7XHJcbiAgICAgICAgbGV0IHRvb2x0aXBGaWVsZFg7XHJcbiAgICAgICAgc3dpdGNoICh0b29sdGlwUG9zaXRpb25YKSB7XHJcbiAgICAgICAgICAgIGNhc2UgXCJvcGVuXCI6XHJcbiAgICAgICAgICAgICAgICB0b29sdGlwRmllbGRYID0gdGhpcy5feE9wZW5GaWVsZDtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFwibG93XCI6XHJcbiAgICAgICAgICAgICAgICB0b29sdGlwRmllbGRYID0gdGhpcy5feExvd0ZpZWxkO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgXCJoaWdoXCI6XHJcbiAgICAgICAgICAgICAgICB0b29sdGlwRmllbGRYID0gdGhpcy5feEhpZ2hGaWVsZDtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgdG9vbHRpcEZpZWxkWCA9IHRoaXMuX3hGaWVsZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fdG9vbHRpcEZpZWxkWCA9IHRvb2x0aXBGaWVsZFg7XHJcbiAgICAgICAgY29uc3QgdG9vbHRpcFBvc2l0aW9uWSA9IHRoaXMuZ2V0KFwidG9vbHRpcFBvc2l0aW9uWVwiKTtcclxuICAgICAgICBsZXQgdG9vbHRpcEZpZWxkWTtcclxuICAgICAgICBzd2l0Y2ggKHRvb2x0aXBQb3NpdGlvblkpIHtcclxuICAgICAgICAgICAgY2FzZSBcIm9wZW5cIjpcclxuICAgICAgICAgICAgICAgIHRvb2x0aXBGaWVsZFkgPSB0aGlzLl95T3BlbkZpZWxkO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgXCJsb3dcIjpcclxuICAgICAgICAgICAgICAgIHRvb2x0aXBGaWVsZFkgPSB0aGlzLl95TG93RmllbGQ7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBcImhpZ2hcIjpcclxuICAgICAgICAgICAgICAgIHRvb2x0aXBGaWVsZFkgPSB0aGlzLl95SGlnaEZpZWxkO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICB0b29sdGlwRmllbGRZID0gdGhpcy5feUZpZWxkO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl90b29sdGlwRmllbGRZID0gdG9vbHRpcEZpZWxkWTtcclxuICAgICAgICBpZiAodGhpcy5pc0RpcnR5KFwiYmFzZUF4aXNcIikpIHtcclxuICAgICAgICAgICAgdGhpcy5fZml4VkMoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fZml4UG9zaXRpb24oKTtcclxuICAgICAgICBjb25zdCBzdGFja2VkID0gdGhpcy5nZXQoXCJzdGFja2VkXCIpO1xyXG4gICAgICAgIGlmICh0aGlzLmlzRGlydHkoXCJzdGFja2VkXCIpKSB7XHJcbiAgICAgICAgICAgIGlmIChzdGFja2VkKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fdmFsdWVzRGlydHkgJiYgIXRoaXMuX2RhdGFQcm9jZXNzZWQpIHtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0YWNrKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl91bnN0YWNrKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuX3ZhbHVlc0RpcnR5ICYmICF0aGlzLl9kYXRhUHJvY2Vzc2VkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2RhdGFQcm9jZXNzZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICBpZiAoc3RhY2tlZCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc3RhY2soKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAkYXJyYXkuZWFjaCh0aGlzLmRhdGFJdGVtcywgKGRhdGFJdGVtKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAkYXJyYXkuZWFjaCh0aGlzLl92YWx1ZVhTaG93RmllbGRzLCAoa2V5KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHZhbHVlID0gZGF0YUl0ZW0uZ2V0KGtleSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0YWNrZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlICs9IHRoaXMuZ2V0U3RhY2tlZFhWYWx1ZShkYXRhSXRlbSwga2V5KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9taW4oXCJtaW5YXCIsIHZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbWF4KFwibWF4WFwiLCB2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAkYXJyYXkuZWFjaCh0aGlzLl92YWx1ZVlTaG93RmllbGRzLCAoa2V5KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHZhbHVlID0gZGF0YUl0ZW0uZ2V0KGtleSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0YWNrZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlICs9IHRoaXMuZ2V0U3RhY2tlZFlWYWx1ZShkYXRhSXRlbSwga2V5KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9taW4oXCJtaW5ZXCIsIHZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbWF4KFwibWF4WVwiLCB2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB4QXhpcy5wcm9jZXNzU2VyaWVzRGF0YUl0ZW0oZGF0YUl0ZW0sIHRoaXMuX3ZhbHVlWEZpZWxkcyk7XHJcbiAgICAgICAgICAgICAgICB5QXhpcy5wcm9jZXNzU2VyaWVzRGF0YUl0ZW0oZGF0YUl0ZW0sIHRoaXMuX3ZhbHVlWUZpZWxkcyk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB4QXhpcy5fc2VyaWVzVmFsdWVzRGlydHkgPSB0cnVlO1xyXG4gICAgICAgICAgICB5QXhpcy5fc2VyaWVzVmFsdWVzRGlydHkgPSB0cnVlO1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuZ2V0KFwiaWdub3JlTWluTWF4XCIpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pc1ByaXZhdGVEaXJ0eShcIm1pblhcIikgfHwgdGhpcy5pc1ByaXZhdGVEaXJ0eShcIm1heFhcIikpIHtcclxuICAgICAgICAgICAgICAgICAgICB4QXhpcy5tYXJrRGlydHlFeHRyZW1lcygpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNQcml2YXRlRGlydHkoXCJtaW5ZXCIpIHx8IHRoaXMuaXNQcml2YXRlRGlydHkoXCJtYXhZXCIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgeUF4aXMubWFya0RpcnR5RXh0cmVtZXMoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9tYXJrU3Rha2VkRGlydHlTdGFjaygpO1xyXG4gICAgICAgICAgICAvL3RoaXMudXBkYXRlTGVnZW5kTWFya2VyKHVuZGVmaW5lZCk7IC8vIGNhdXNlcyBsZWdlbmQgbWFya2VyIHRvIGNoYW5nZSBjb2xvciBpbnN0YW50bHkgd2hlbiBvblxyXG4gICAgICAgICAgICBpZiAoIXRoaXMuZ2V0KFwidG9vbHRpcERhdGFJdGVtXCIpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZUxlZ2VuZFZhbHVlKHVuZGVmaW5lZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuaXNEaXJ0eShcInZjeFwiKSB8fCB0aGlzLmlzRGlydHkoXCJ2Y3lcIikpIHtcclxuICAgICAgICAgICAgdGhpcy5fbWFya1N0YWtlZERpcnR5U3RhY2soKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCF0aGlzLl9kYXRhR3JvdXBlZCkge1xyXG4gICAgICAgICAgICB4QXhpcy5fZ3JvdXBTZXJpZXNEYXRhKHRoaXMpO1xyXG4gICAgICAgICAgICB5QXhpcy5fZ3JvdXBTZXJpZXNEYXRhKHRoaXMpO1xyXG4gICAgICAgICAgICB0aGlzLl9kYXRhR3JvdXBlZCA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLl92YWx1ZXNEaXJ0eSB8fCB0aGlzLmlzUHJpdmF0ZURpcnR5KFwic3RhcnRJbmRleFwiKSB8fCB0aGlzLmlzUHJpdmF0ZURpcnR5KFwiZW5kSW5kZXhcIikgfHwgdGhpcy5pc0RpcnR5KFwidmN4XCIpIHx8IHRoaXMuaXNEaXJ0eShcInZjeVwiKSB8fCB0aGlzLl9zdGFja0RpcnR5KSB7XHJcbiAgICAgICAgICAgIGxldCBzdGFydEluZGV4ID0gdGhpcy5zdGFydEluZGV4KCk7XHJcbiAgICAgICAgICAgIGxldCBlbmRJbmRleCA9IHRoaXMuZW5kSW5kZXgoKTtcclxuICAgICAgICAgICAgbGV0IG1pbkJ1bGxldERpc3RhbmNlID0gdGhpcy5nZXQoXCJtaW5CdWxsZXREaXN0YW5jZVwiLCAwKTtcclxuICAgICAgICAgICAgaWYgKG1pbkJ1bGxldERpc3RhbmNlID4gMCAmJiBiYXNlQXhpcykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGJhc2VBeGlzLmdldChcInJlbmRlcmVyXCIpLmF4aXNMZW5ndGgoKSAvIChlbmRJbmRleCAtIHN0YXJ0SW5kZXgpID4gbWluQnVsbGV0RGlzdGFuY2UpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zaG93QnVsbGV0cyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zaG93QnVsbGV0cyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICgodGhpcy5fcHNpICE9IHN0YXJ0SW5kZXggfHwgdGhpcy5fcGVpICE9IGVuZEluZGV4IHx8IHRoaXMuaXNEaXJ0eShcInZjeFwiKSB8fCB0aGlzLmlzRGlydHkoXCJ2Y3lcIikgfHwgdGhpcy5fc3RhY2tEaXJ0eSB8fCB0aGlzLl92YWx1ZXNEaXJ0eSkgJiYgIXRoaXMuX3NlbGVjdGlvblByb2Nlc3NlZCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc2VsZWN0aW9uUHJvY2Vzc2VkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHZjeCA9IHRoaXMuZ2V0KFwidmN4XCIsIDEpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdmN5ID0gdGhpcy5nZXQoXCJ2Y3lcIiwgMSk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzdGFja2VkID0gdGhpcy5nZXQoXCJzdGFja2VkXCIsIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG91dE9mU2VsZWN0aW9uID0gdGhpcy5nZXRQcml2YXRlKFwib3V0T2ZTZWxlY3Rpb25cIik7XHJcbiAgICAgICAgICAgICAgICBpZiAoYmFzZUF4aXMgPT09IHhBeGlzIHx8ICFiYXNlQXhpcykge1xyXG4gICAgICAgICAgICAgICAgICAgIHlBeGlzLl9jYWxjdWxhdGVUb3RhbHMoKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFByaXZhdGVSYXcoXCJzZWxlY3Rpb25NaW5ZXCIsIHVuZGVmaW5lZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRQcml2YXRlUmF3KFwic2VsZWN0aW9uTWF4WVwiLCB1bmRlZmluZWQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghb3V0T2ZTZWxlY3Rpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IHN0YXJ0SW5kZXg7IGkgPCBlbmRJbmRleDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnByb2Nlc3NZU2VsZWN0aW9uRGF0YUl0ZW0odGhpcy5kYXRhSXRlbXNbaV0sIHZjeSwgc3RhY2tlZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHlBeGlzLm1hcmtEaXJ0eVNlbGVjdGlvbkV4dHJlbWVzKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGJhc2VBeGlzID09PSB5QXhpcyB8fCAhYmFzZUF4aXMpIHtcclxuICAgICAgICAgICAgICAgICAgICB4QXhpcy5fY2FsY3VsYXRlVG90YWxzKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRQcml2YXRlUmF3KFwic2VsZWN0aW9uTWluWFwiLCB1bmRlZmluZWQpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0UHJpdmF0ZVJhdyhcInNlbGVjdGlvbk1heFhcIiwgdW5kZWZpbmVkKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIW91dE9mU2VsZWN0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSBzdGFydEluZGV4OyBpIDwgZW5kSW5kZXg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wcm9jZXNzWFNlbGVjdGlvbkRhdGFJdGVtKHRoaXMuZGF0YUl0ZW1zW2ldLCB2Y3gsIHN0YWNrZWQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB5QXhpcy5tYXJrRGlydHlTZWxlY3Rpb25FeHRyZW1lcygpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChiYXNlQXhpcyA9PT0geEF4aXMgfHwgIWJhc2VBeGlzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZ2V0KFwidmFsdWVZU2hvd1wiKSAhPT0gXCJ2YWx1ZVlXb3JraW5nXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2VsZWN0aW9uTWluWSA9IHRoaXMuZ2V0UHJpdmF0ZShcInNlbGVjdGlvbk1pbllcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZWxlY3Rpb25NaW5ZICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0UHJpdmF0ZVJhdyhcIm1pbllcIiwgc2VsZWN0aW9uTWluWSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5QXhpcy5tYXJrRGlydHlFeHRyZW1lcygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNlbGVjdGlvbk1heFkgPSB0aGlzLmdldFByaXZhdGUoXCJzZWxlY3Rpb25NYXhZXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZWN0aW9uTWF4WSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFByaXZhdGVSYXcoXCJtYXhZXCIsIHNlbGVjdGlvbk1heFkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeUF4aXMubWFya0RpcnR5RXh0cmVtZXMoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChiYXNlQXhpcyA9PT0geUF4aXMgfHwgIWJhc2VBeGlzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZ2V0KFwidmFsdWVYU2hvd1wiKSAhPT0gXCJ2YWx1ZVhXb3JraW5nXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2VsZWN0aW9uTWluWCA9IHRoaXMuZ2V0UHJpdmF0ZShcInNlbGVjdGlvbk1pblhcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZWxlY3Rpb25NaW5YICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0UHJpdmF0ZVJhdyhcIm1pblhcIiwgc2VsZWN0aW9uTWluWCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5QXhpcy5tYXJrRGlydHlFeHRyZW1lcygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNlbGVjdGlvbk1heFggPSB0aGlzLmdldFByaXZhdGUoXCJzZWxlY3Rpb25NYXhYXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZWN0aW9uTWF4WCAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFByaXZhdGVSYXcoXCJtYXhYXCIsIHNlbGVjdGlvbk1heFgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeEF4aXMubWFya0RpcnR5RXh0cmVtZXMoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzUHJpdmF0ZURpcnR5KFwic2VsZWN0aW9uTWluWFwiKSB8fCB0aGlzLmlzUHJpdmF0ZURpcnR5KFwic2VsZWN0aW9uTWF4WFwiKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHhBeGlzLm1hcmtEaXJ0eVNlbGVjdGlvbkV4dHJlbWVzKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pc1ByaXZhdGVEaXJ0eShcInNlbGVjdGlvbk1pbllcIikgfHwgdGhpcy5pc1ByaXZhdGVEaXJ0eShcInNlbGVjdGlvbk1heFlcIikpIHtcclxuICAgICAgICAgICAgICAgICAgICB5QXhpcy5tYXJrRGlydHlTZWxlY3Rpb25FeHRyZW1lcygpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gdGhpcy51cGRhdGVMZWdlbmRWYWx1ZSh1bmRlZmluZWQpOyBmbGlja2VycyB3aGlsZSBwYW5uaW5nXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBfbWFrZVJhbmdlTWFzaygpIHtcclxuICAgICAgICBpZiAodGhpcy5heGlzUmFuZ2VzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgbGV0IG1haW5Db250YWluZXJNYXNrID0gdGhpcy5fbWFpbkNvbnRhaW5lck1hc2s7XHJcbiAgICAgICAgICAgIGlmIChtYWluQ29udGFpbmVyTWFzayA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBtYWluQ29udGFpbmVyTWFzayA9IHRoaXMuY2hpbGRyZW4ucHVzaChHcmFwaGljcy5uZXcodGhpcy5fcm9vdCwge30pKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX21haW5Db250YWluZXJNYXNrID0gbWFpbkNvbnRhaW5lck1hc2s7XHJcbiAgICAgICAgICAgICAgICBtYWluQ29udGFpbmVyTWFzay5zZXQoXCJkcmF3XCIsIChkaXNwbGF5LCB0YXJnZXQpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXJlbnQgPSB0aGlzLnBhcmVudDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocGFyZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHcgPSB0aGlzLl9yb290LmNvbnRhaW5lci53aWR0aCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBoID0gdGhpcy5fcm9vdC5jb250YWluZXIuaGVpZ2h0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BsYXkubW92ZVRvKC13LCAtaCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BsYXkubGluZVRvKC13LCBoICogMik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BsYXkubGluZVRvKHcgKiAyLCBoICogMik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BsYXkubGluZVRvKHcgKiAyLCAtaCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BsYXkubGluZVRvKC13LCAtaCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYXhpc1Jhbmdlcy5lYWNoKChheGlzUmFuZ2UpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGZpbGwgPSBheGlzUmFuZ2UuYXhpc0RhdGFJdGVtLmdldChcImF4aXNGaWxsXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmaWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBkcmF3ID0gZmlsbC5nZXQoXCJkcmF3XCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZHJhdykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZHJhdyhkaXNwbGF5LCB0YXJnZXQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tYWluQ29udGFpbmVyLl9kaXNwbGF5Lm1hc2sgPSBtYWluQ29udGFpbmVyTWFzay5fZGlzcGxheTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG1haW5Db250YWluZXJNYXNrLm1hcmtEaXJ0eSgpO1xyXG4gICAgICAgICAgICBtYWluQ29udGFpbmVyTWFzay5fbWFya0RpcnR5S2V5KFwiZmlsbFwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMubWFpbkNvbnRhaW5lci5fZGlzcGxheS5tYXNrID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBfdXBkYXRlQ2hpbGRyZW4oKSB7XHJcbiAgICAgICAgc3VwZXIuX3VwZGF0ZUNoaWxkcmVuKCk7XHJcbiAgICAgICAgLy8gc2F2ZSBmb3IgcGVyZm9ybWFuY2VcclxuICAgICAgICB0aGlzLl94ID0gdGhpcy54KCk7XHJcbiAgICAgICAgdGhpcy5feSA9IHRoaXMueSgpO1xyXG4gICAgICAgIHRoaXMuX21ha2VSYW5nZU1hc2soKTtcclxuICAgIH1cclxuICAgIF9zdGFjaygpIHtcclxuICAgICAgICBjb25zdCBjaGFydCA9IHRoaXMuY2hhcnQ7XHJcbiAgICAgICAgaWYgKGNoYXJ0KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHNlcmllc0luZGV4ID0gY2hhcnQuc2VyaWVzLmluZGV4T2YodGhpcyk7XHJcbiAgICAgICAgICAgIHRoaXMuX2NvdWxkU3RhY2tUbyA9IFtdO1xyXG4gICAgICAgICAgICBpZiAoc2VyaWVzSW5kZXggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgc2VyaWVzO1xyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IHNlcmllc0luZGV4IC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgICAgICAgICAgICAgICBzZXJpZXMgPSBjaGFydC5zZXJpZXMuZ2V0SW5kZXgoaSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlcmllcy5nZXQoXCJ4QXhpc1wiKSA9PT0gdGhpcy5nZXQoXCJ4QXhpc1wiKSAmJiBzZXJpZXMuZ2V0KFwieUF4aXNcIikgPT09IHRoaXMuZ2V0KFwieUF4aXNcIikgJiYgc2VyaWVzLmNsYXNzTmFtZSA9PT0gdGhpcy5jbGFzc05hbWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY291bGRTdGFja1RvLnB1c2goc2VyaWVzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFzZXJpZXMuZ2V0KFwic3RhY2tlZFwiKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fc3RhY2tEYXRhSXRlbXMoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBfdW5zdGFjaygpIHtcclxuICAgICAgICAkb2JqZWN0LmVhY2godGhpcy5fcmVhbGx5U3RhY2tlZFRvLCAoX2tleSwgdmFsdWUpID0+IHtcclxuICAgICAgICAgICAgZGVsZXRlICh2YWx1ZS5fc3RhY2tlZFNlcmllc1t0aGlzLnVpZF0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuX3JlYWxseVN0YWNrZWRUbyA9IHt9O1xyXG4gICAgICAgICRhcnJheS5lYWNoKHRoaXMuZGF0YUl0ZW1zLCAoZGF0YUl0ZW0pID0+IHtcclxuICAgICAgICAgICAgZGF0YUl0ZW0uc2V0UmF3KFwic3RhY2tUb0l0ZW1ZXCIsIHVuZGVmaW5lZCk7XHJcbiAgICAgICAgICAgIGRhdGFJdGVtLnNldFJhdyhcInN0YWNrVG9JdGVtWFwiLCB1bmRlZmluZWQpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgX3N0YWNrRGF0YUl0ZW1zKCkge1xyXG4gICAgICAgIC8vIHRoaXMgd29ya3Mgb25seSB3aXRoIHRoZSBzYW1lIG51bWJlciBvZiBkYXRhIEB0b2RvOiBzZWFyY2ggYnkgZGF0ZS9jYXRlZ29yeT9cclxuICAgICAgICBjb25zdCBiYXNlQXhpcyA9IHRoaXMuZ2V0KFwiYmFzZUF4aXNcIik7XHJcbiAgICAgICAgY29uc3QgeEF4aXMgPSB0aGlzLmdldChcInhBeGlzXCIpO1xyXG4gICAgICAgIGNvbnN0IHlBeGlzID0gdGhpcy5nZXQoXCJ5QXhpc1wiKTtcclxuICAgICAgICBsZXQgZmllbGQ7XHJcbiAgICAgICAgbGV0IHN0YWNrVG9JdGVtS2V5O1xyXG4gICAgICAgIGlmIChiYXNlQXhpcyA9PT0geEF4aXMpIHtcclxuICAgICAgICAgICAgZmllbGQgPSBcInZhbHVlWVwiO1xyXG4gICAgICAgICAgICBzdGFja1RvSXRlbUtleSA9IFwic3RhY2tUb0l0ZW1ZXCI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGJhc2VBeGlzID09PSB5QXhpcykge1xyXG4gICAgICAgICAgICBmaWVsZCA9IFwidmFsdWVYXCI7XHJcbiAgICAgICAgICAgIHN0YWNrVG9JdGVtS2V5ID0gXCJzdGFja1RvSXRlbVhcIjtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IGxlbiA9IHRoaXMuX2NvdWxkU3RhY2tUby5sZW5ndGg7XHJcbiAgICAgICAgbGV0IGluZGV4ID0gMDtcclxuICAgICAgICBjb25zdCBzdGFja1RvTmVnYXRpdmUgPSB0aGlzLmdldChcInN0YWNrVG9OZWdhdGl2ZVwiKTtcclxuICAgICAgICB0aGlzLl9yZWFsbHlTdGFja2VkVG8gPSB7fTtcclxuICAgICAgICAkYXJyYXkuZWFjaCh0aGlzLmRhdGFJdGVtcywgKGRhdGFJdGVtKSA9PiB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IHMgPSAwOyBzIDwgbGVuOyBzKyspIHtcclxuICAgICAgICAgICAgICAgIGxldCBzdGFja1RvU2VyaWVzID0gdGhpcy5fY291bGRTdGFja1RvW3NdO1xyXG4gICAgICAgICAgICAgICAgbGV0IHN0YWNrVG9JdGVtID0gc3RhY2tUb1Nlcmllcy5kYXRhSXRlbXNbaW5kZXhdO1xyXG4gICAgICAgICAgICAgICAgbGV0IHZhbHVlID0gZGF0YUl0ZW0uZ2V0KGZpZWxkKTtcclxuICAgICAgICAgICAgICAgIGlmIChzdGFja1RvSXRlbSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBzdGFja1ZhbHVlID0gc3RhY2tUb0l0ZW0uZ2V0KGZpZWxkKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhY2tUb05lZ2F0aXZlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgkdHlwZS5pc051bWJlcih2YWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgkdHlwZS5pc051bWJlcihzdGFja1ZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA+PSAwICYmIHN0YWNrVmFsdWUgPj0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhSXRlbS5zZXRSYXcoc3RhY2tUb0l0ZW1LZXksIHN0YWNrVG9JdGVtKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVhbGx5U3RhY2tlZFRvW3N0YWNrVG9TZXJpZXMudWlkXSA9IHN0YWNrVG9TZXJpZXM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YWNrVG9TZXJpZXMuX3N0YWNrZWRTZXJpZXNbdGhpcy51aWRdID0gdGhpcztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA8IDAgJiYgc3RhY2tWYWx1ZSA8IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YUl0ZW0uc2V0UmF3KHN0YWNrVG9JdGVtS2V5LCBzdGFja1RvSXRlbSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlYWxseVN0YWNrZWRUb1tzdGFja1RvU2VyaWVzLnVpZF0gPSBzdGFja1RvU2VyaWVzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFja1RvU2VyaWVzLl9zdGFja2VkU2VyaWVzW3RoaXMudWlkXSA9IHRoaXM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoJHR5cGUuaXNOdW1iZXIodmFsdWUpICYmICR0eXBlLmlzTnVtYmVyKHN0YWNrVmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhSXRlbS5zZXRSYXcoc3RhY2tUb0l0ZW1LZXksIHN0YWNrVG9JdGVtKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlYWxseVN0YWNrZWRUb1tzdGFja1RvU2VyaWVzLnVpZF0gPSBzdGFja1RvU2VyaWVzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhY2tUb1Nlcmllcy5fc3RhY2tlZFNlcmllc1t0aGlzLnVpZF0gPSB0aGlzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaW5kZXgrKztcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHByb2Nlc3NYU2VsZWN0aW9uRGF0YUl0ZW0oZGF0YUl0ZW0sIHZjeCwgc3RhY2tlZCkge1xyXG4gICAgICAgICRhcnJheS5lYWNoKHRoaXMuX192YWx1ZVhTaG93RmllbGRzLCAoa2V5KSA9PiB7XHJcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IGRhdGFJdGVtLmdldChrZXkpO1xyXG4gICAgICAgICAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHN0YWNrZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSArPSB0aGlzLmdldFN0YWNrZWRYVmFsdWVXb3JraW5nKGRhdGFJdGVtLCBrZXkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5fbWluKFwic2VsZWN0aW9uTWluWFwiLCB2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9tYXgoXCJzZWxlY3Rpb25NYXhYXCIsIHZhbHVlICogdmN4KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgcHJvY2Vzc1lTZWxlY3Rpb25EYXRhSXRlbShkYXRhSXRlbSwgdmN5LCBzdGFja2VkKSB7XHJcbiAgICAgICAgJGFycmF5LmVhY2godGhpcy5fX3ZhbHVlWVNob3dGaWVsZHMsIChrZXkpID0+IHtcclxuICAgICAgICAgICAgbGV0IHZhbHVlID0gZGF0YUl0ZW0uZ2V0KGtleSk7XHJcbiAgICAgICAgICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoc3RhY2tlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlICs9IHRoaXMuZ2V0U3RhY2tlZFlWYWx1ZVdvcmtpbmcoZGF0YUl0ZW0sIGtleSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9taW4oXCJzZWxlY3Rpb25NaW5ZXCIsIHZhbHVlKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX21heChcInNlbGVjdGlvbk1heFlcIiwgdmFsdWUgKiB2Y3kpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEBpZ25vcmVcclxuICAgICAqL1xyXG4gICAgZ2V0U3RhY2tlZFlWYWx1ZVdvcmtpbmcoZGF0YUl0ZW0sIGtleSkge1xyXG4gICAgICAgIGNvbnN0IHN0YWNrVG9JdGVtID0gZGF0YUl0ZW0uZ2V0KFwic3RhY2tUb0l0ZW1ZXCIpO1xyXG4gICAgICAgIGlmIChzdGFja1RvSXRlbSkge1xyXG4gICAgICAgICAgICBjb25zdCBzdGFja2VkVG9TZXJpZXMgPSBzdGFja1RvSXRlbS5jb21wb25lbnQ7XHJcbiAgICAgICAgICAgIHJldHVybiBzdGFja1RvSXRlbS5nZXQoa2V5LCAwKSAqIHN0YWNrZWRUb1Nlcmllcy5nZXQoXCJ2Y3lcIiwgMSkgKyB0aGlzLmdldFN0YWNrZWRZVmFsdWVXb3JraW5nKHN0YWNrVG9JdGVtLCBrZXkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gMDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQGlnbm9yZVxyXG4gICAgICovXHJcbiAgICBnZXRTdGFja2VkWFZhbHVlV29ya2luZyhkYXRhSXRlbSwga2V5KSB7XHJcbiAgICAgICAgY29uc3Qgc3RhY2tUb0l0ZW0gPSBkYXRhSXRlbS5nZXQoXCJzdGFja1RvSXRlbVhcIik7XHJcbiAgICAgICAgaWYgKHN0YWNrVG9JdGVtKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHN0YWNrZWRUb1NlcmllcyA9IHN0YWNrVG9JdGVtLmNvbXBvbmVudDtcclxuICAgICAgICAgICAgcmV0dXJuIHN0YWNrVG9JdGVtLmdldChrZXksIDApICogc3RhY2tlZFRvU2VyaWVzLmdldChcInZjeFwiLCAxKSArIHRoaXMuZ2V0U3RhY2tlZFhWYWx1ZVdvcmtpbmcoc3RhY2tUb0l0ZW0sIGtleSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAwO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAaWdub3JlXHJcbiAgICAgKi9cclxuICAgIGdldFN0YWNrZWRZVmFsdWUoZGF0YUl0ZW0sIGtleSkge1xyXG4gICAgICAgIGNvbnN0IHN0YWNrVG9JdGVtID0gZGF0YUl0ZW0uZ2V0KFwic3RhY2tUb0l0ZW1ZXCIpO1xyXG4gICAgICAgIGlmIChzdGFja1RvSXRlbSkge1xyXG4gICAgICAgICAgICByZXR1cm4gc3RhY2tUb0l0ZW0uZ2V0KGtleSwgMCkgKyB0aGlzLmdldFN0YWNrZWRZVmFsdWUoc3RhY2tUb0l0ZW0sIGtleSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAwO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAaWdub3JlXHJcbiAgICAgKi9cclxuICAgIGdldFN0YWNrZWRYVmFsdWUoZGF0YUl0ZW0sIGtleSkge1xyXG4gICAgICAgIGNvbnN0IHN0YWNrVG9JdGVtID0gZGF0YUl0ZW0uZ2V0KFwic3RhY2tUb0l0ZW1YXCIpO1xyXG4gICAgICAgIGlmIChzdGFja1RvSXRlbSkge1xyXG4gICAgICAgICAgICByZXR1cm4gc3RhY2tUb0l0ZW0uZ2V0KGtleSwgMCkgKyB0aGlzLmdldFN0YWNrZWRYVmFsdWUoc3RhY2tUb0l0ZW0sIGtleSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAwO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAaWdub3JlXHJcbiAgICAgKi9cclxuICAgIGNyZWF0ZUxlZ2VuZE1hcmtlcihfZGF0YUl0ZW0pIHtcclxuICAgICAgICB0aGlzLnVwZGF0ZUxlZ2VuZE1hcmtlcigpO1xyXG4gICAgfVxyXG4gICAgX21hcmtEaXJ0eUF4ZXMoKSB7XHJcbiAgICAgICAgdGhpcy5fYXhlc0RpcnR5ID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLm1hcmtEaXJ0eSgpO1xyXG4gICAgfVxyXG4gICAgX21hcmtEYXRhU2V0RGlydHkoKSB7XHJcbiAgICAgICAgdGhpcy5fYWZ0ZXJEYXRhQ2hhbmdlKCk7XHJcbiAgICAgICAgdGhpcy5fdmFsdWVzRGlydHkgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuX2RhdGFQcm9jZXNzZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl9hZ2dyZWdhdGVzQ2FsY3VsYXRlZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMubWFya0RpcnR5KCk7XHJcbiAgICB9XHJcbiAgICBfY2xlYXJEaXJ0eSgpIHtcclxuICAgICAgICBzdXBlci5fY2xlYXJEaXJ0eSgpO1xyXG4gICAgICAgIHRoaXMuX2F4ZXNEaXJ0eSA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuX3NlbGVjdGlvblByb2Nlc3NlZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuX3N0YWNrRGlydHkgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl9kYXRhUHJvY2Vzc2VkID0gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBfcG9zaXRpb25CdWxsZXQoYnVsbGV0KSB7XHJcbiAgICAgICAgbGV0IHNwcml0ZSA9IGJ1bGxldC5nZXQoXCJzcHJpdGVcIik7XHJcbiAgICAgICAgaWYgKHNwcml0ZSkge1xyXG4gICAgICAgICAgICBsZXQgZGF0YUl0ZW0gPSBzcHJpdGUuZGF0YUl0ZW07XHJcbiAgICAgICAgICAgIGxldCBsb2NhdGlvblggPSBidWxsZXQuZ2V0KFwibG9jYXRpb25YXCIsIGRhdGFJdGVtLmdldChcImxvY2F0aW9uWFwiLCAwLjUpKTtcclxuICAgICAgICAgICAgbGV0IGxvY2F0aW9uWSA9IGJ1bGxldC5nZXQoXCJsb2NhdGlvbllcIiwgZGF0YUl0ZW0uZ2V0KFwibG9jYXRpb25ZXCIsIDAuNSkpO1xyXG4gICAgICAgICAgICBsZXQgeEF4aXMgPSB0aGlzLmdldChcInhBeGlzXCIpO1xyXG4gICAgICAgICAgICBsZXQgeUF4aXMgPSB0aGlzLmdldChcInlBeGlzXCIpO1xyXG4gICAgICAgICAgICBsZXQgcG9zaXRpb25YID0geEF4aXMuZ2V0RGF0YUl0ZW1Qb3NpdGlvblgoZGF0YUl0ZW0sIHRoaXMuX3hGaWVsZCwgbG9jYXRpb25YLCB0aGlzLmdldChcInZjeFwiLCAxKSk7XHJcbiAgICAgICAgICAgIGxldCBwb3NpdGlvblkgPSB5QXhpcy5nZXREYXRhSXRlbVBvc2l0aW9uWShkYXRhSXRlbSwgdGhpcy5feUZpZWxkLCBsb2NhdGlvblksIHRoaXMuZ2V0KFwidmN5XCIsIDEpKTtcclxuICAgICAgICAgICAgbGV0IHBvaW50ID0gdGhpcy5nZXRQb2ludChwb3NpdGlvblgsIHBvc2l0aW9uWSk7XHJcbiAgICAgICAgICAgIGxldCBsZWZ0ID0gZGF0YUl0ZW0uZ2V0KFwibGVmdFwiLCBwb2ludC54KTtcclxuICAgICAgICAgICAgbGV0IHJpZ2h0ID0gZGF0YUl0ZW0uZ2V0KFwicmlnaHRcIiwgcG9pbnQueCk7XHJcbiAgICAgICAgICAgIGxldCB0b3AgPSBkYXRhSXRlbS5nZXQoXCJ0b3BcIiwgcG9pbnQueSk7XHJcbiAgICAgICAgICAgIGxldCBib3R0b20gPSBkYXRhSXRlbS5nZXQoXCJib3R0b21cIiwgcG9pbnQueSk7XHJcbiAgICAgICAgICAgIGxldCB4ID0gMDtcclxuICAgICAgICAgICAgbGV0IHkgPSAwO1xyXG4gICAgICAgICAgICBsZXQgdyA9IHJpZ2h0IC0gbGVmdDtcclxuICAgICAgICAgICAgbGV0IGggPSBib3R0b20gLSB0b3A7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9zaG91bGRTaG93QnVsbGV0KHBvc2l0aW9uWCwgcG9zaXRpb25ZKSkge1xyXG4gICAgICAgICAgICAgICAgc3ByaXRlLnNldFByaXZhdGUoXCJ2aXNpYmxlXCIsICFidWxsZXQuZ2V0UHJpdmF0ZShcImhpZGRlblwiKSk7XHJcbiAgICAgICAgICAgICAgICBsZXQgZmllbGQgPSBidWxsZXQuZ2V0KFwiZmllbGRcIik7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBiYXNlQXhpcyA9IHRoaXMuZ2V0KFwiYmFzZUF4aXNcIik7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB4QXhpcyA9IHRoaXMuZ2V0KFwieEF4aXNcIik7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB5QXhpcyA9IHRoaXMuZ2V0KFwieUF4aXNcIik7XHJcbiAgICAgICAgICAgICAgICBpZiAoZmllbGQgIT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHJlYWxGaWVsZDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYmFzZUF4aXMgPT0geEF4aXMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZpZWxkID09IFwidmFsdWVcIikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVhbEZpZWxkID0gdGhpcy5feUZpZWxkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGZpZWxkID09IFwib3BlblwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWFsRmllbGQgPSB0aGlzLl95T3BlbkZpZWxkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGZpZWxkID09IFwiaGlnaFwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWFsRmllbGQgPSB0aGlzLl95SGlnaEZpZWxkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGZpZWxkID09IFwibG93XCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYWxGaWVsZCA9IHRoaXMuX3lMb3dGaWVsZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVhbEZpZWxkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvblkgPSB5QXhpcy5nZXREYXRhSXRlbVBvc2l0aW9uWShkYXRhSXRlbSwgcmVhbEZpZWxkLCAwLCB0aGlzLmdldChcInZjeVwiLCAxKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb2ludCA9IHlBeGlzLmdldChcInJlbmRlcmVyXCIpLnBvc2l0aW9uVG9Qb2ludChwb3NpdGlvblkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeSA9IHBvaW50Lnk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4ID0gbGVmdCArIHcgKiBsb2NhdGlvblg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmaWVsZCA9PSBcInZhbHVlXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYWxGaWVsZCA9IHRoaXMuX3hGaWVsZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChmaWVsZCA9PSBcIm9wZW5cIikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVhbEZpZWxkID0gdGhpcy5feE9wZW5GaWVsZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChmaWVsZCA9PSBcImhpZ2hcIikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVhbEZpZWxkID0gdGhpcy5feEhpZ2hGaWVsZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChmaWVsZCA9PSBcImxvd1wiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWFsRmllbGQgPSB0aGlzLl94TG93RmllbGQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlYWxGaWVsZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb25YID0geEF4aXMuZ2V0RGF0YUl0ZW1Qb3NpdGlvblgoZGF0YUl0ZW0sIHJlYWxGaWVsZCwgMCwgdGhpcy5nZXQoXCJ2Y3hcIiwgMSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnQgPSB4QXhpcy5nZXQoXCJyZW5kZXJlclwiKS5wb3NpdGlvblRvUG9pbnQocG9zaXRpb25YKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHggPSBwb2ludC54O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeSA9IGJvdHRvbSAtIGggKiBsb2NhdGlvblk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB4ID0gbGVmdCArIHcgKiBsb2NhdGlvblg7XHJcbiAgICAgICAgICAgICAgICAgICAgeSA9IGJvdHRvbSAtIGggKiBsb2NhdGlvblk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzdGFja2VkID0gYnVsbGV0LmdldChcInN0YWNrZWRcIik7XHJcbiAgICAgICAgICAgICAgICBpZiAoc3RhY2tlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNoYXJ0ID0gdGhpcy5jaGFydDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYmFzZUF4aXMgPT0geEF4aXMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHByZXZpb3VzQnVsbGV0ID0gdGhpcy5fYnVsbGV0c1twb3NpdGlvblggKyBcIl9cIiArIHBvc2l0aW9uWV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcmV2aW91c0J1bGxldCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHByZXZpb3VzQm91bmRzID0gcHJldmlvdXNCdWxsZXQuYm91bmRzKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgYm91bmRzID0gc3ByaXRlLmxvY2FsQm91bmRzKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgeW8gPSB5O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeSA9IHByZXZpb3VzQm91bmRzLnRvcDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdGFja2VkID09IFwiZG93blwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeSA9IHByZXZpb3VzQm91bmRzLmJvdHRvbSAtIGJvdW5kcy50b3A7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChzdGFja2VkID09IFwiYXV0b1wiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNoYXJ0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh5byA8IGNoYXJ0LnBsb3RDb250YWluZXIuaGVpZ2h0KCkgLyAyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5ID0gcHJldmlvdXNCb3VuZHMuYm90dG9tIC0gYm91bmRzLnRvcDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHkgKz0gYm91bmRzLmJvdHRvbTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHkgKz0gYm91bmRzLmJvdHRvbTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9idWxsZXRzW3Bvc2l0aW9uWCArIFwiX1wiICsgcG9zaXRpb25ZXSA9IHNwcml0ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBwcmV2aW91c0J1bGxldCA9IHRoaXMuX2J1bGxldHNbcG9zaXRpb25YICsgXCJfXCIgKyBwb3NpdGlvblldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJldmlvdXNCdWxsZXQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBwcmV2aW91c0JvdW5kcyA9IHByZXZpb3VzQnVsbGV0LmJvdW5kcygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGJvdW5kcyA9IHNwcml0ZS5sb2NhbEJvdW5kcygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHhvID0geDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHggPSBwcmV2aW91c0JvdW5kcy5yaWdodDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdGFja2VkID09IFwiZG93blwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeCA9IHByZXZpb3VzQm91bmRzLmxlZnQgLSBib3VuZHMucmlnaHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChzdGFja2VkID09IFwiYXV0b1wiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNoYXJ0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh4byA8IGNoYXJ0LnBsb3RDb250YWluZXIud2lkdGgoKSAvIDIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHggPSBwcmV2aW91c0JvdW5kcy5sZWZ0IC0gYm91bmRzLnJpZ2h0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeCAtPSBib3VuZHMubGVmdDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHggLT0gYm91bmRzLmxlZnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fYnVsbGV0c1twb3NpdGlvblggKyBcIl9cIiArIHBvc2l0aW9uWV0gPSBzcHJpdGU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHNwcml0ZS5pc1R5cGUoXCJMYWJlbFwiKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNwcml0ZS5zZXRQcml2YXRlKFwibWF4V2lkdGhcIiwgTWF0aC5hYnModykpO1xyXG4gICAgICAgICAgICAgICAgICAgIHNwcml0ZS5zZXRQcml2YXRlKFwibWF4SGVpZ2h0XCIsIE1hdGguYWJzKGgpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHNwcml0ZS5zZXRBbGwoeyB4LCB5IH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgc3ByaXRlLnNldFByaXZhdGUoXCJ2aXNpYmxlXCIsIGZhbHNlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIF9zaG91bGRTaG93QnVsbGV0KF9wb3NpdGlvblgsIF9wb3NpdGlvblkpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fc2hvd0J1bGxldHM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEBpZ25vcmVcclxuICAgICAqL1xyXG4gICAgc2V0RGF0YVNldChpZCkge1xyXG4gICAgICAgIGlmICh0aGlzLl9kYXRhU2V0c1tpZF0pIHtcclxuICAgICAgICAgICAgdGhpcy5faGFuZGxlRGF0YVNldENoYW5nZSgpO1xyXG4gICAgICAgICAgICB0aGlzLl9kYXRhSXRlbXMgPSB0aGlzLl9kYXRhU2V0c1tpZF07XHJcbiAgICAgICAgICAgIHRoaXMuX21hcmtEYXRhU2V0RGlydHkoKTtcclxuICAgICAgICAgICAgdGhpcy5fZGF0YVNldElkID0gaWQ7XHJcbiAgICAgICAgICAgIGNvbnN0IHR5cGUgPSBcImRhdGFzZXRjaGFuZ2VkXCI7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmV2ZW50cy5pc0VuYWJsZWQodHlwZSkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZXZlbnRzLmRpc3BhdGNoKHR5cGUsIHsgdHlwZTogdHlwZSwgdGFyZ2V0OiB0aGlzLCBpZDogaWQgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEBpZ25vcmVcclxuICAgICAqL1xyXG4gICAgcmVzZXRHcm91cGluZygpIHtcclxuICAgICAgICAkb2JqZWN0LmVhY2godGhpcy5fZGF0YVNldHMsIChfa2V5LCBkYXRhU2V0KSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChkYXRhU2V0ICE9IHRoaXMuX21haW5EYXRhSXRlbXMpIHtcclxuICAgICAgICAgICAgICAgICRhcnJheS5lYWNoKGRhdGFTZXQsIChkYXRhSXRlbSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzcG9zZURhdGFJdGVtKGRhdGFJdGVtKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5fZGF0YVNldHMgPSB7fTtcclxuICAgICAgICB0aGlzLl9kYXRhSXRlbXMgPSB0aGlzLm1haW5EYXRhSXRlbXM7XHJcbiAgICB9XHJcbiAgICBfaGFuZGxlRGF0YVNldENoYW5nZSgpIHtcclxuICAgICAgICAkYXJyYXkuZWFjaCh0aGlzLl9kYXRhSXRlbXMsIChkYXRhSXRlbSkgPT4ge1xyXG4gICAgICAgICAgICBsZXQgYnVsbGV0cyA9IGRhdGFJdGVtLmJ1bGxldHM7XHJcbiAgICAgICAgICAgIGlmIChidWxsZXRzKSB7XHJcbiAgICAgICAgICAgICAgICAkYXJyYXkuZWFjaChidWxsZXRzLCAoYnVsbGV0KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJ1bGxldCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgc3ByaXRlID0gYnVsbGV0LmdldChcInNwcml0ZVwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNwcml0ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ByaXRlLnNldFByaXZhdGUoXCJ2aXNpYmxlXCIsIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5fc2VsZWN0aW9uUHJvY2Vzc2VkID0gZmFsc2U7IC8vIGZvciB0b3RhbHMgdG8gYmUgY2FsY3VsYXRlZFxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTaG93cyBoaWRkZW4gc2VyaWVzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSAgIGR1cmF0aW9uICBEdXJhdGlvbiBvZiBhbmltYXRpb24gaW4gbWlsbGlzZWNvbmRzXHJcbiAgICAgKiBAcmV0dXJuICAgICAgICAgICAgQW5pbWF0aW9uIHByb21pc2VcclxuICAgICAqL1xyXG4gICAgc2hvdyhkdXJhdGlvbikge1xyXG4gICAgICAgIGNvbnN0IF9zdXBlciA9IE9iamVjdC5jcmVhdGUobnVsbCwge1xyXG4gICAgICAgICAgICBzaG93OiB7IGdldDogKCkgPT4gc3VwZXIuc2hvdyB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgdGhpcy5fZml4VkMoKTtcclxuICAgICAgICAgICAgbGV0IHByb21pc2VzID0gW107XHJcbiAgICAgICAgICAgIHByb21pc2VzLnB1c2goX3N1cGVyLnNob3cuY2FsbCh0aGlzLCBkdXJhdGlvbikudGhlbigoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9pc1Nob3dpbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIGxldCB4QXhpcyA9IHRoaXMuZ2V0KFwieEF4aXNcIik7XHJcbiAgICAgICAgICAgICAgICBsZXQgeUF4aXMgPSB0aGlzLmdldChcInlBeGlzXCIpO1xyXG4gICAgICAgICAgICAgICAgbGV0IGJhc2VBeGlzID0gdGhpcy5nZXQoXCJiYXNlQXhpc1wiKTtcclxuICAgICAgICAgICAgICAgIGlmICh5QXhpcyAhPT0gYmFzZUF4aXMpIHtcclxuICAgICAgICAgICAgICAgICAgICB5QXhpcy5tYXJrRGlydHlTZWxlY3Rpb25FeHRyZW1lcygpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHhBeGlzICE9PSBiYXNlQXhpcykge1xyXG4gICAgICAgICAgICAgICAgICAgIHhBeGlzLm1hcmtEaXJ0eVNlbGVjdGlvbkV4dHJlbWVzKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pKTtcclxuICAgICAgICAgICAgcHJvbWlzZXMucHVzaCh0aGlzLmJ1bGxldHNDb250YWluZXIuc2hvdyhkdXJhdGlvbikpO1xyXG4gICAgICAgICAgICBwcm9taXNlcy5wdXNoKHRoaXMuX3NlcXVlbmNlZFNob3dIaWRlKHRydWUsIGR1cmF0aW9uKSk7XHJcbiAgICAgICAgICAgIHlpZWxkIFByb21pc2UuYWxsKHByb21pc2VzKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogSGlkZXMgc2VyaWVzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSAgIGR1cmF0aW9uICBEdXJhdGlvbiBvZiBhbmltYXRpb24gaW4gbWlsbGlzZWNvbmRzXHJcbiAgICAgKiBAcmV0dXJuICAgICAgICAgICAgQW5pbWF0aW9uIHByb21pc2VcclxuICAgICAqL1xyXG4gICAgaGlkZShkdXJhdGlvbikge1xyXG4gICAgICAgIGNvbnN0IF9zdXBlciA9IE9iamVjdC5jcmVhdGUobnVsbCwge1xyXG4gICAgICAgICAgICBoaWRlOiB7IGdldDogKCkgPT4gc3VwZXIuaGlkZSB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgdGhpcy5fZml4VkMoKTtcclxuICAgICAgICAgICAgbGV0IHByb21pc2VzID0gW107XHJcbiAgICAgICAgICAgIHByb21pc2VzLnB1c2goX3N1cGVyLmhpZGUuY2FsbCh0aGlzLCBkdXJhdGlvbikudGhlbigoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9pc0hpZGluZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICAgIHByb21pc2VzLnB1c2godGhpcy5idWxsZXRzQ29udGFpbmVyLmhpZGUoZHVyYXRpb24pKTtcclxuICAgICAgICAgICAgcHJvbWlzZXMucHVzaCh0aGlzLl9zZXF1ZW5jZWRTaG93SGlkZShmYWxzZSwgZHVyYXRpb24pKTtcclxuICAgICAgICAgICAgeWllbGQgUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTaG93cyBzZXJpZXMncyBkYXRhIGl0ZW0uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtICAgZGF0YUl0ZW0gIERhdGEgaXRlbVxyXG4gICAgICogQHBhcmFtICAgZHVyYXRpb24gIEFuaW1hdGlvbiBkdXJhdGlvbiBpbiBtaWxsaXNlY29uZHNcclxuICAgICAqIEByZXR1cm4gICAgICAgICAgICBQcm9taXNlXHJcbiAgICAgKi9cclxuICAgIHNob3dEYXRhSXRlbShkYXRhSXRlbSwgZHVyYXRpb24pIHtcclxuICAgICAgICBjb25zdCBfc3VwZXIgPSBPYmplY3QuY3JlYXRlKG51bGwsIHtcclxuICAgICAgICAgICAgc2hvd0RhdGFJdGVtOiB7IGdldDogKCkgPT4gc3VwZXIuc2hvd0RhdGFJdGVtIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICBjb25zdCBwcm9taXNlcyA9IFtfc3VwZXIuc2hvd0RhdGFJdGVtLmNhbGwodGhpcywgZGF0YUl0ZW0sIGR1cmF0aW9uKV07XHJcbiAgICAgICAgICAgIGlmICghJHR5cGUuaXNOdW1iZXIoZHVyYXRpb24pKSB7XHJcbiAgICAgICAgICAgICAgICBkdXJhdGlvbiA9IHRoaXMuZ2V0KFwic3RhdGVBbmltYXRpb25EdXJhdGlvblwiLCAwKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBlYXNpbmcgPSB0aGlzLmdldChcInN0YXRlQW5pbWF0aW9uRWFzaW5nXCIpO1xyXG4gICAgICAgICAgICAkYXJyYXkuZWFjaCh0aGlzLl92YWx1ZUZpZWxkcywgKGtleSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaChkYXRhSXRlbS5hbmltYXRlKHsga2V5OiBrZXkgKyBcIldvcmtpbmdcIiwgdG86IGRhdGFJdGVtLmdldChrZXkpLCBkdXJhdGlvbjogZHVyYXRpb24sIGVhc2luZzogZWFzaW5nIH0pLndhaXRGb3JTdG9wKCkpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgeWllbGQgUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBIaWRlcyBzZXJpZXMncyBkYXRhIGl0ZW0uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtICAgZGF0YUl0ZW0gIERhdGEgaXRlbVxyXG4gICAgICogQHBhcmFtICAgZHVyYXRpb24gIEFuaW1hdGlvbiBkdXJhdGlvbiBpbiBtaWxsaXNlY29uZHNcclxuICAgICAqIEByZXR1cm4gICAgICAgICAgICBQcm9taXNlXHJcbiAgICAgKi9cclxuICAgIGhpZGVEYXRhSXRlbShkYXRhSXRlbSwgZHVyYXRpb24pIHtcclxuICAgICAgICBjb25zdCBfc3VwZXIgPSBPYmplY3QuY3JlYXRlKG51bGwsIHtcclxuICAgICAgICAgICAgaGlkZURhdGFJdGVtOiB7IGdldDogKCkgPT4gc3VwZXIuaGlkZURhdGFJdGVtIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICBjb25zdCBwcm9taXNlcyA9IFtfc3VwZXIuaGlkZURhdGFJdGVtLmNhbGwodGhpcywgZGF0YUl0ZW0sIGR1cmF0aW9uKV07XHJcbiAgICAgICAgICAgIGNvbnN0IGhpZGRlblN0YXRlID0gdGhpcy5zdGF0ZXMuY3JlYXRlKFwiaGlkZGVuXCIsIHt9KTtcclxuICAgICAgICAgICAgaWYgKCEkdHlwZS5pc051bWJlcihkdXJhdGlvbikpIHtcclxuICAgICAgICAgICAgICAgIGR1cmF0aW9uID0gaGlkZGVuU3RhdGUuZ2V0KFwic3RhdGVBbmltYXRpb25EdXJhdGlvblwiLCB0aGlzLmdldChcInN0YXRlQW5pbWF0aW9uRHVyYXRpb25cIiwgMCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IGVhc2luZyA9IGhpZGRlblN0YXRlLmdldChcInN0YXRlQW5pbWF0aW9uRWFzaW5nXCIsIHRoaXMuZ2V0KFwic3RhdGVBbmltYXRpb25FYXNpbmdcIikpO1xyXG4gICAgICAgICAgICBjb25zdCB4QXhpcyA9IHRoaXMuZ2V0KFwieEF4aXNcIik7XHJcbiAgICAgICAgICAgIGNvbnN0IHlBeGlzID0gdGhpcy5nZXQoXCJ5QXhpc1wiKTtcclxuICAgICAgICAgICAgY29uc3QgYmFzZUF4aXMgPSB0aGlzLmdldChcImJhc2VBeGlzXCIpO1xyXG4gICAgICAgICAgICBjb25zdCBzdGFja2VkID0gdGhpcy5nZXQoXCJzdGFja2VkXCIpO1xyXG4gICAgICAgICAgICBpZiAoYmFzZUF4aXMgPT09IHhBeGlzIHx8ICFiYXNlQXhpcykge1xyXG4gICAgICAgICAgICAgICAgJGFycmF5LmVhY2godGhpcy5fdmFsdWVZRmllbGRzLCAoa2V5KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IG1pbiA9IHlBeGlzLmdldFByaXZhdGUoXCJtaW5cIik7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGJhc2VWYWx1ZSA9IHlBeGlzLmJhc2VWYWx1ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICgkdHlwZS5pc051bWJlcihtaW4pICYmIG1pbiA+IGJhc2VWYWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBiYXNlVmFsdWUgPSBtaW47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGFja2VkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJhc2VWYWx1ZSA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGxldCB2YWx1ZSA9IGRhdGFJdGVtLmdldChrZXkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2VzLnB1c2goZGF0YUl0ZW0uYW5pbWF0ZSh7IGtleToga2V5ICsgXCJXb3JraW5nXCIsIHRvOiBiYXNlVmFsdWUsIGR1cmF0aW9uOiBkdXJhdGlvbiwgZWFzaW5nOiBlYXNpbmcgfSkud2FpdEZvclN0b3AoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGJhc2VBeGlzID09PSB5QXhpcyB8fCAhYmFzZUF4aXMpIHtcclxuICAgICAgICAgICAgICAgIGxldCBtaW4gPSB4QXhpcy5nZXRQcml2YXRlKFwibWluXCIpO1xyXG4gICAgICAgICAgICAgICAgbGV0IGJhc2VWYWx1ZSA9IHhBeGlzLmJhc2VWYWx1ZSgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCR0eXBlLmlzTnVtYmVyKG1pbikgJiYgbWluID4gYmFzZVZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYmFzZVZhbHVlID0gbWluO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHN0YWNrZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBiYXNlVmFsdWUgPSAwO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgJGFycmF5LmVhY2godGhpcy5fdmFsdWVYRmllbGRzLCAoa2V5KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHZhbHVlID0gZGF0YUl0ZW0uZ2V0KGtleSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaChkYXRhSXRlbS5hbmltYXRlKHsga2V5OiBrZXkgKyBcIldvcmtpbmdcIiwgdG86IGJhc2VWYWx1ZSwgZHVyYXRpb246IGR1cmF0aW9uLCBlYXNpbmc6IGVhc2luZyB9KS53YWl0Rm9yU3RvcCgpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB5aWVsZCBQcm9taXNlLmFsbChwcm9taXNlcyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBfbWFya0RpcnR5U3RhY2soKSB7XHJcbiAgICAgICAgdGhpcy5fc3RhY2tEaXJ0eSA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5tYXJrRGlydHkoKTtcclxuICAgICAgICB0aGlzLl9tYXJrU3Rha2VkRGlydHlTdGFjaygpO1xyXG4gICAgfVxyXG4gICAgX21hcmtTdGFrZWREaXJ0eVN0YWNrKCkge1xyXG4gICAgICAgIGNvbnN0IHN0YWNrZWRTZXJpZXMgPSB0aGlzLl9zdGFja2VkU2VyaWVzO1xyXG4gICAgICAgIGlmIChzdGFja2VkU2VyaWVzKSB7XHJcbiAgICAgICAgICAgICRvYmplY3QuZWFjaChzdGFja2VkU2VyaWVzLCAoX2tleSwgdmFsdWUpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmICghdmFsdWUuX3N0YWNrRGlydHkpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZS5fbWFya0RpcnR5U3RhY2soKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgX2FmdGVyQ2hhbmdlZCgpIHtcclxuICAgICAgICBzdXBlci5fYWZ0ZXJDaGFuZ2VkKCk7XHJcbiAgICAgICAgaWYgKHRoaXMuX3NraXBwZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5fbWFya0RpcnR5QXhlcygpO1xyXG4gICAgICAgICAgICB0aGlzLl9za2lwcGVkID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTaG93cyBhIHRvb2x0aXAgZm9yIHNwZWNpZmljIGRhdGEgaXRlbS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gIGRhdGFJdGVtICBEYXRhIGl0ZW1cclxuICAgICAqL1xyXG4gICAgc2hvd0RhdGFJdGVtVG9vbHRpcChkYXRhSXRlbSkge1xyXG4gICAgICAgIHRoaXMudXBkYXRlTGVnZW5kTWFya2VyKGRhdGFJdGVtKTtcclxuICAgICAgICB0aGlzLnVwZGF0ZUxlZ2VuZFZhbHVlKGRhdGFJdGVtKTtcclxuICAgICAgICBjb25zdCB0b29sdGlwID0gdGhpcy5nZXQoXCJ0b29sdGlwXCIpO1xyXG4gICAgICAgIGlmICh0b29sdGlwKSB7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5pc0hpZGRlbigpKSB7XHJcbiAgICAgICAgICAgICAgICB0b29sdGlwLl9zZXREYXRhSXRlbShkYXRhSXRlbSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoZGF0YUl0ZW0pIHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgbG9jYXRpb25YID0gdGhpcy5nZXQoXCJsb2NhdGlvblhcIiwgMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGxvY2F0aW9uWSA9IHRoaXMuZ2V0KFwibG9jYXRpb25ZXCIsIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBpdGVtTG9jYXRpb25YID0gZGF0YUl0ZW0uZ2V0KFwibG9jYXRpb25YXCIsIGxvY2F0aW9uWCk7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGl0ZW1Mb2NhdGlvblkgPSBkYXRhSXRlbS5nZXQoXCJsb2NhdGlvbllcIiwgbG9jYXRpb25ZKTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB4QXhpcyA9IHRoaXMuZ2V0KFwieEF4aXNcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeUF4aXMgPSB0aGlzLmdldChcInlBeGlzXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHZjeCA9IHRoaXMuZ2V0KFwidmN4XCIsIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHZjeSA9IHRoaXMuZ2V0KFwidmN5XCIsIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHhQb3MgPSB4QXhpcy5nZXREYXRhSXRlbVBvc2l0aW9uWChkYXRhSXRlbSwgdGhpcy5fdG9vbHRpcEZpZWxkWCwgdGhpcy5fYUxvY2F0aW9uWDAgKyAodGhpcy5fYUxvY2F0aW9uWDEgLSB0aGlzLl9hTG9jYXRpb25YMCkgKiBpdGVtTG9jYXRpb25YLCB2Y3gpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHlQb3MgPSB5QXhpcy5nZXREYXRhSXRlbVBvc2l0aW9uWShkYXRhSXRlbSwgdGhpcy5fdG9vbHRpcEZpZWxkWSwgdGhpcy5fYUxvY2F0aW9uWTAgKyAodGhpcy5fYUxvY2F0aW9uWTEgLSB0aGlzLl9hTG9jYXRpb25ZMCkgKiBpdGVtTG9jYXRpb25ZLCB2Y3kpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBvaW50ID0gdGhpcy5nZXRQb2ludCh4UG9zLCB5UG9zKTtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgc2hvdyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgJGFycmF5LmVhY2godGhpcy5fdmFsdWVGaWVsZHMsIChmaWVsZCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YUl0ZW0uZ2V0KGZpZWxkKSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaG93ID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc2hvdykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjaGFydCA9IHRoaXMuY2hhcnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaGFydCAmJiBjaGFydC5pblBsb3QocG9pbnQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b29sdGlwLmxhYmVsLnRleHQubWFya0RpcnR5VGV4dCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9vbHRpcC5zZXQoXCJ0b29sdGlwVGFyZ2V0XCIsIHRoaXMuX2dldFRvb2x0aXBUYXJnZXQoZGF0YUl0ZW0pKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvb2x0aXAuc2V0KFwicG9pbnRUb1wiLCB0aGlzLl9kaXNwbGF5LnRvR2xvYmFsKHsgeDogcG9pbnQueCwgeTogcG9pbnQueSB9KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b29sdGlwLl9zZXREYXRhSXRlbSh1bmRlZmluZWQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0b29sdGlwLl9zZXREYXRhSXRlbSh1bmRlZmluZWQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuaGlkZVRvb2x0aXAoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGhpZGVUb29sdGlwKCkge1xyXG4gICAgICAgIGNvbnN0IHRvb2x0aXAgPSB0aGlzLmdldChcInRvb2x0aXBcIik7XHJcbiAgICAgICAgaWYgKHRvb2x0aXApIHtcclxuICAgICAgICAgICAgdG9vbHRpcC5zZXQoXCJ0b29sdGlwVGFyZ2V0XCIsIHRoaXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gc3VwZXIuaGlkZVRvb2x0aXAoKTtcclxuICAgIH1cclxuICAgIF9nZXRUb29sdGlwVGFyZ2V0KGRhdGFJdGVtKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuZ2V0KFwic2VyaWVzVG9vbHRpcFRhcmdldFwiKSA9PSBcImJ1bGxldFwiKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGJ1bGxldHMgPSBkYXRhSXRlbS5idWxsZXRzO1xyXG4gICAgICAgICAgICBpZiAoYnVsbGV0cyAmJiBidWxsZXRzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGJ1bGxldCA9IGJ1bGxldHNbMF07XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzcHJpdGUgPSBidWxsZXQuZ2V0KFwic3ByaXRlXCIpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHNwcml0ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzcHJpdGU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEBpZ25vcmVcclxuICAgICAqL1xyXG4gICAgdXBkYXRlTGVnZW5kVmFsdWUoZGF0YUl0ZW0pIHtcclxuICAgICAgICBjb25zdCBsZWdlbmREYXRhSXRlbSA9IHRoaXMuZ2V0KFwibGVnZW5kRGF0YUl0ZW1cIik7XHJcbiAgICAgICAgaWYgKGxlZ2VuZERhdGFJdGVtKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGxhYmVsID0gbGVnZW5kRGF0YUl0ZW0uZ2V0KFwibGFiZWxcIik7XHJcbiAgICAgICAgICAgIGlmIChsYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgbGV0IHR4dCA9IFwiXCI7XHJcbiAgICAgICAgICAgICAgICBpZiAoZGF0YUl0ZW0pIHtcclxuICAgICAgICAgICAgICAgICAgICBsYWJlbC5fc2V0RGF0YUl0ZW0oZGF0YUl0ZW0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHR4dCA9IHRoaXMuZ2V0KFwibGVnZW5kTGFiZWxUZXh0XCIsIGxhYmVsLmdldChcInRleHRcIiwgdGhpcy5nZXQoXCJuYW1lXCIsIFwiXCIpKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBsYWJlbC5fc2V0RGF0YUl0ZW0odGhpcy5fZW1wdHlEYXRhSXRlbSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdHh0ID0gdGhpcy5nZXQoXCJsZWdlbmRSYW5nZUxhYmVsVGV4dFwiLCB0aGlzLmdldChcImxlZ2VuZExhYmVsVGV4dFwiLCBsYWJlbC5nZXQoXCJ0ZXh0XCIsIHRoaXMuZ2V0KFwibmFtZVwiLCBcIlwiKSkpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGxhYmVsLnNldChcInRleHRcIiwgdHh0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCB2YWx1ZUxhYmVsID0gbGVnZW5kRGF0YUl0ZW0uZ2V0KFwidmFsdWVMYWJlbFwiKTtcclxuICAgICAgICAgICAgaWYgKHZhbHVlTGFiZWwpIHtcclxuICAgICAgICAgICAgICAgIGxldCB0eHQgPSBcIlwiO1xyXG4gICAgICAgICAgICAgICAgaWYgKGRhdGFJdGVtKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVMYWJlbC5fc2V0RGF0YUl0ZW0oZGF0YUl0ZW0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHR4dCA9IHRoaXMuZ2V0KFwibGVnZW5kVmFsdWVUZXh0XCIsIHZhbHVlTGFiZWwuZ2V0KFwidGV4dFwiLCBcIlwiKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZUxhYmVsLl9zZXREYXRhSXRlbSh0aGlzLl9lbXB0eURhdGFJdGVtKTtcclxuICAgICAgICAgICAgICAgICAgICB0eHQgPSB0aGlzLmdldChcImxlZ2VuZFJhbmdlVmFsdWVUZXh0XCIsIHZhbHVlTGFiZWwuZ2V0KFwidGV4dFwiLCBcIlwiKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YWx1ZUxhYmVsLnNldChcInRleHRcIiwgdHh0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIF9nZXRJdGVtUmVhZGVyTGFiZWwoKSB7XHJcbiAgICAgICAgbGV0IHRleHQgPSBcIlg6IHtcIiArIHRoaXMuX3hGaWVsZDtcclxuICAgICAgICBpZiAodGhpcy5nZXQoXCJ4QXhpc1wiKS5pc1R5cGUoXCJEYXRlQXhpc1wiKSkge1xyXG4gICAgICAgICAgICB0ZXh0ICs9IFwiLmZvcm1hdERhdGUoKVwiO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0ZXh0ICs9IFwifTsgWToge1wiICsgdGhpcy5feUZpZWxkO1xyXG4gICAgICAgIGlmICh0aGlzLmdldChcInlBeGlzXCIpLmlzVHlwZShcIkRhdGVBeGlzXCIpKSB7XHJcbiAgICAgICAgICAgIHRleHQgKz0gXCIuZm9ybWF0RGF0ZSgpXCI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRleHQgKz0gXCJ9XCI7XHJcbiAgICAgICAgcmV0dXJuIHRleHQ7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEBpZ25vcmVcclxuICAgICAqL1xyXG4gICAgZ2V0UG9pbnQocG9zaXRpb25YLCBwb3NpdGlvblkpIHtcclxuICAgICAgICBsZXQgeCA9IHRoaXMuZ2V0KFwieEF4aXNcIikuZ2V0KFwicmVuZGVyZXJcIikucG9zaXRpb25Ub0Nvb3JkaW5hdGUocG9zaXRpb25YKTtcclxuICAgICAgICBsZXQgeSA9IHRoaXMuZ2V0KFwieUF4aXNcIikuZ2V0KFwicmVuZGVyZXJcIikucG9zaXRpb25Ub0Nvb3JkaW5hdGUocG9zaXRpb25ZKTtcclxuICAgICAgICAvLyBpZiBjb29yZGluYXRlIGlzIHN1cGVyIGJpZywgY2FudmFzIGZhaWxzIHRvIGRyYXcgbGluZSwgY2FwcGluZyB0byBzb21lIGJpZyBudW1iZXIgKHdvbid0IG1ha2UgYW55IHZpc3VhbCBkaWZmZXJlbmNlKVxyXG4gICAgICAgIGxldCBtYXggPSA5OTk5OTk5OTk7XHJcbiAgICAgICAgaWYgKHkgPCAtbWF4KSB7XHJcbiAgICAgICAgICAgIHkgPSAtbWF4O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoeSA+IG1heCkge1xyXG4gICAgICAgICAgICB5ID0gbWF4O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoeCA8IC1tYXgpIHtcclxuICAgICAgICAgICAgeCA9IC1tYXg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh4ID4gbWF4KSB7XHJcbiAgICAgICAgICAgIHggPSBtYXg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB7IHg6IHgsIHk6IHkgfTtcclxuICAgIH1cclxuICAgIF9zaG91bGRJbmNsdWRlKF9wb3NpdGlvbikge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAaWdub3JlXHJcbiAgICAgKi9cclxuICAgIGhhbmRsZUN1cnNvckhpZGUoKSB7XHJcbiAgICAgICAgdGhpcy5oaWRlVG9vbHRpcCgpO1xyXG4gICAgICAgIHRoaXMudXBkYXRlTGVnZW5kVmFsdWUodW5kZWZpbmVkKTtcclxuICAgICAgICB0aGlzLnVwZGF0ZUxlZ2VuZE1hcmtlcih1bmRlZmluZWQpO1xyXG4gICAgfVxyXG4gICAgX2FmdGVyRGF0YUNoYW5nZSgpIHtcclxuICAgICAgICBzdXBlci5fYWZ0ZXJEYXRhQ2hhbmdlKCk7XHJcbiAgICAgICAgdGhpcy5nZXQoXCJ4QXhpc1wiKS5fbWFya0RpcnR5S2V5KFwic3RhcnRcIik7XHJcbiAgICAgICAgdGhpcy5nZXQoXCJ5QXhpc1wiKS5fbWFya0RpcnR5S2V5KFwic3RhcnRcIik7XHJcbiAgICAgICAgdGhpcy5yZXNldEV4dHJlbWVzKCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJlc2V0cyBjYWNoZWQgYXhpcyBzY2FsZSB2YWx1ZXMuXHJcbiAgICAgKi9cclxuICAgIHJlc2V0RXh0cmVtZXMoKSB7XHJcbiAgICAgICAgdGhpcy5zZXRQcml2YXRlKFwic2VsZWN0aW9uTWluWFwiLCB1bmRlZmluZWQpO1xyXG4gICAgICAgIHRoaXMuc2V0UHJpdmF0ZShcInNlbGVjdGlvbk1heFhcIiwgdW5kZWZpbmVkKTtcclxuICAgICAgICB0aGlzLnNldFByaXZhdGUoXCJzZWxlY3Rpb25NaW5ZXCIsIHVuZGVmaW5lZCk7XHJcbiAgICAgICAgdGhpcy5zZXRQcml2YXRlKFwic2VsZWN0aW9uTWF4WVwiLCB1bmRlZmluZWQpO1xyXG4gICAgICAgIHRoaXMuc2V0UHJpdmF0ZShcIm1pblhcIiwgdW5kZWZpbmVkKTtcclxuICAgICAgICB0aGlzLnNldFByaXZhdGUoXCJtaW5ZXCIsIHVuZGVmaW5lZCk7XHJcbiAgICAgICAgdGhpcy5zZXRQcml2YXRlKFwibWF4WFwiLCB1bmRlZmluZWQpO1xyXG4gICAgICAgIHRoaXMuc2V0UHJpdmF0ZShcIm1heFlcIiwgdW5kZWZpbmVkKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhbmQgcmV0dXJucyBhbiBheGlzIHJhbmdlIG9iamVjdC5cclxuICAgICAqXHJcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL3d3dy5hbWNoYXJ0cy5jb20vZG9jcy92NS9jaGFydHMveHktY2hhcnQvYXhlcy9heGlzLXJhbmdlcy99IGZvciBtb3JlIGluZm9cclxuICAgICAqIEBwYXJhbSAgIGF4aXNEYXRhSXRlbSAgQXhpcyBkYXRhIGl0ZW1cclxuICAgICAqIEByZXR1cm4gICAgICAgICAgICAgICAgQXhpcyByYW5nZVxyXG4gICAgICovXHJcbiAgICBjcmVhdGVBeGlzUmFuZ2UoYXhpc0RhdGFJdGVtKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYXhpc1Jhbmdlcy5wdXNoKHtcclxuICAgICAgICAgICAgYXhpc0RhdGFJdGVtOiBheGlzRGF0YUl0ZW1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQSBsaXN0IG9mIHNlcmllcydzIG1haW4gKHVuZ3JvdXBlZCkgZGF0YSBpdGVtcy5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJuICBEYXRhIGl0ZW1zXHJcbiAgICAgKi9cclxuICAgIGdldCBtYWluRGF0YUl0ZW1zKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9tYWluRGF0YUl0ZW1zO1xyXG4gICAgfVxyXG59XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShYWVNlcmllcywgXCJjbGFzc05hbWVcIiwge1xyXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgdmFsdWU6IFwiWFlTZXJpZXNcIlxyXG59KTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFhZU2VyaWVzLCBcImNsYXNzTmFtZXNcIiwge1xyXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgdmFsdWU6IFNlcmllcy5jbGFzc05hbWVzLmNvbmNhdChbWFlTZXJpZXMuY2xhc3NOYW1lXSlcclxufSk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVhZU2VyaWVzLmpzLm1hcCIsIi8qKlxyXG4gKiBAaWdub3JlXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgUmVnaXN0cnkge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ3VycmVudGx5IHJ1bm5pbmcgdmVyc2lvbiBvZiBhbUNoYXJ0cy5cclxuICAgICAgICAgKi9cclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ2ZXJzaW9uXCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IFwiNS42LjJcIlxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIExpc3Qgb2YgYXBwbGllZCBsaWNlbnNlcy5cclxuICAgICAgICAgKiBAaWdub3JlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibGljZW5zZXNcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogW11cclxuICAgICAgICB9KTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBFbnRpdGllcyB0aGF0IGhhdmUgdGhlaXIgYGlkYCBzZXR0aW5nIHNldC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJlbnRpdGllc0J5SWRcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZToge31cclxuICAgICAgICB9KTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBbGwgY3JlYXRlZCBbW1Jvb3RdXSBlbGVtZW50cy5cclxuICAgICAgICAgKi9cclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJyb290RWxlbWVudHNcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogW11cclxuICAgICAgICB9KTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICAgICogQGlnbm9yZVxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IHJlZ2lzdHJ5ID0gbmV3IFJlZ2lzdHJ5KCk7XHJcbi8qKlxyXG4gKiBBZGRzIGEgbGljZW5zZSwgZS5nLjpcclxuICpcclxuICogYGBgVHlwZVNjcmlwdFxyXG4gKiBhbTUuYWRkTGljZW5zZShcInh4eHh4eHh4XCIpO1xyXG4gKiBgYGBcclxuICogYGBgSmF2YVNjcmlwdFxyXG4gKiBhbTUuYWRkTGljZW5zZShcInh4eHh4eHh4XCIpO1xyXG4gKiBgYGBcclxuICpcclxuICogTXVsdGlwbGUgbGljZW5zZXMgY2FuIGJlIGFkZGVkIHRvIGNvdmVyIGZvciBtdWx0aXBsZSBwcm9kdWN0cy5cclxuICpcclxuICogQHBhcmFtICBsaWNlbnNlICBMaWNlbnNlIGtleVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGFkZExpY2Vuc2UobGljZW5zZSkge1xyXG4gICAgcmVnaXN0cnkubGljZW5zZXMucHVzaChsaWNlbnNlKTtcclxufVxyXG4vKipcclxuICogRGlzcG9zZXMgYWxsIFtbUm9vdF1dIGVsZW1lbnRzLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGRpc3Bvc2VBbGxSb290RWxlbWVudHMoKSB7XHJcbiAgICBsZXQgcm9vdDtcclxuICAgIHdoaWxlIChyb290ID0gcmVnaXN0cnkucm9vdEVsZW1lbnRzLnBvcCgpKSB7XHJcbiAgICAgICAgcm9vdC5kaXNwb3NlKCk7XHJcbiAgICB9XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UmVnaXN0cnkuanMubWFwIiwiaW1wb3J0IHsgQ29udGFpbmVyIH0gZnJvbSBcIi4vcmVuZGVyL0NvbnRhaW5lclwiO1xyXG5pbXBvcnQgeyBUZXh0IH0gZnJvbSBcIi4vcmVuZGVyL1RleHRcIjtcclxuaW1wb3J0IHsgSG9yaXpvbnRhbExheW91dCB9IGZyb20gXCIuL3JlbmRlci9Ib3Jpem9udGFsTGF5b3V0XCI7XHJcbmltcG9ydCB7IFZlcnRpY2FsTGF5b3V0IH0gZnJvbSBcIi4vcmVuZGVyL1ZlcnRpY2FsTGF5b3V0XCI7XHJcbmltcG9ydCB7IEdyaWRMYXlvdXQgfSBmcm9tIFwiLi9yZW5kZXIvR3JpZExheW91dFwiO1xyXG5pbXBvcnQgeyBEaXNwb3NlciB9IGZyb20gXCIuL3V0aWwvRGlzcG9zZXJcIjtcclxuaW1wb3J0IHsgUmVzaXplU2Vuc29yIH0gZnJvbSBcIi4vdXRpbC9SZXNpemVTZW5zb3JcIjtcclxuaW1wb3J0IHsgSW50ZXJmYWNlQ29sb3JzIH0gZnJvbSBcIi4vdXRpbC9JbnRlcmZhY2VDb2xvcnNcIjtcclxuaW1wb3J0IHsgR3JhcGhpY3MgfSBmcm9tIFwiLi9yZW5kZXIvR3JhcGhpY3NcIjtcclxuaW1wb3J0IHsgUmVjdGFuZ2xlIH0gZnJvbSBcIi4vcmVuZGVyL1JlY3RhbmdsZVwiO1xyXG5pbXBvcnQgeyBUb29sdGlwIH0gZnJvbSBcIi4vcmVuZGVyL1Rvb2x0aXBcIjtcclxuaW1wb3J0IHsgTnVtYmVyRm9ybWF0dGVyIH0gZnJvbSBcIi4vdXRpbC9OdW1iZXJGb3JtYXR0ZXJcIjtcclxuaW1wb3J0IHsgRGF0ZUZvcm1hdHRlciB9IGZyb20gXCIuL3V0aWwvRGF0ZUZvcm1hdHRlclwiO1xyXG5pbXBvcnQgeyBEdXJhdGlvbkZvcm1hdHRlciB9IGZyb20gXCIuL3V0aWwvRHVyYXRpb25Gb3JtYXR0ZXJcIjtcclxuaW1wb3J0IHsgTGFuZ3VhZ2UgfSBmcm9tIFwiLi91dGlsL0xhbmd1YWdlXCI7XHJcbmltcG9ydCB7IEV2ZW50RGlzcGF0Y2hlciB9IGZyb20gXCIuL3V0aWwvRXZlbnREaXNwYXRjaGVyXCI7XHJcbmltcG9ydCB7IERlZmF1bHRUaGVtZSB9IGZyb20gXCIuLi90aGVtZXMvRGVmYXVsdFRoZW1lXCI7XHJcbmltcG9ydCB7IENhbnZhc1JlbmRlcmVyIH0gZnJvbSBcIi4vcmVuZGVyL2JhY2tlbmQvQ2FudmFzUmVuZGVyZXJcIjtcclxuaW1wb3J0IHsgcDEwMCwgcGVyY2VudCB9IGZyb20gXCIuL3V0aWwvUGVyY2VudFwiO1xyXG5pbXBvcnQgeyBjb2xvciB9IGZyb20gXCIuL3V0aWwvQ29sb3JcIjtcclxuaW1wb3J0IHsgcG9wdWxhdGVTdHJpbmcgfSBmcm9tIFwiLi91dGlsL1BvcHVsYXRlU3RyaW5nXCI7XHJcbmltcG9ydCB7IHJlZ2lzdHJ5IH0gZnJvbSBcIi4vUmVnaXN0cnlcIjtcclxuaW1wb3J0ICogYXMgJG9yZGVyIGZyb20gXCIuL3V0aWwvT3JkZXJcIjtcclxuaW1wb3J0ICogYXMgJGFycmF5IGZyb20gXCIuL3V0aWwvQXJyYXlcIjtcclxuaW1wb3J0ICogYXMgJG9iamVjdCBmcm9tIFwiLi91dGlsL09iamVjdFwiO1xyXG5pbXBvcnQgKiBhcyAkdXRpbHMgZnJvbSBcIi4vdXRpbC9VdGlsc1wiO1xyXG5pbXBvcnQgKiBhcyAkdHlwZSBmcm9tIFwiLi91dGlsL1R5cGVcIjtcclxuaW1wb3J0IGVuIGZyb20gXCIuLi8uLi9sb2NhbGVzL2VuXCI7XHJcbmZ1bmN0aW9uIHJBRihmcHMsIGNhbGxiYWNrKSB7XHJcbiAgICBpZiAoZnBzID09IG51bGwpIHtcclxuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoY2FsbGJhY2spO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShjYWxsYmFjayk7XHJcbiAgICAgICAgfSwgMTAwMCAvIGZwcyk7XHJcbiAgICB9XHJcbn1cclxuLy8gVE9ETyBpbXBsZW1lbnQgRGlzcG9zZXJcclxuLyoqXHJcbiAqIFJvb3QgZWxlbWVudCBvZiB0aGUgY2hhcnQuXHJcbiAqXHJcbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vd3d3LmFtY2hhcnRzLmNvbS9kb2NzL3Y1L2dldHRpbmctc3RhcnRlZC8jUm9vdF9lbGVtZW50fSBmb3IgbW9yZSBpbmZvXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgUm9vdCB7XHJcbiAgICBjb25zdHJ1Y3RvcihpZCwgc2V0dGluZ3MgPSB7fSwgaXNSZWFsKSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQSByZWZlcmVuY2UgdG8gb3JpZ2luYWwgY2hhcnQgY29udGFpbmVyIChkaXYgZWxlbWVudCkuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZG9tXCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9pbm5lclwiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfc2V0dGluZ3NcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX2lzRGlydHlcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogZmFsc2VcclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfaXNEaXJ0eVBhcmVudHNcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogZmFsc2VcclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfZGlydHlcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZToge31cclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfZGlydHlQYXJlbnRzXCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IHt9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX2RpcnR5Qm91bmRzXCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IHt9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX2RpcnR5UG9zaXRpb25zXCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IHt9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX3RpY2tlclwiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiBudWxsXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX3RpY2tlcnNcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogW11cclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfdXBkYXRlVGlja1wiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUm9vdCdzIGV2ZW50IGRpc3BhdGNoZXIuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAc2VlIHtAbGluayBodHRwczovL3d3dy5hbWNoYXJ0cy5jb20vZG9jcy92NS9jb25jZXB0cy9ldmVudHMvfSBmb3IgbW9yZSBpbmZvXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZXZlbnRzXCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IG5ldyBFdmVudERpc3BhdGNoZXIoKVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBpZ25vcmVcclxuICAgICAgICAgKiBAdG9kbyBuZWVkcyBkZXNjcmlwdGlvblxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImFuaW1hdGlvblRpbWVcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogbnVsbFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9hbmltYXRpb25zXCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IFtdXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX3JlbmRlcmVyXCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9yb290Q29udGFpbmVyXCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIE1haW4gY29udGVudCBjb250YWluZXIuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiY29udGFpbmVyXCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEEgW1tDb250YWluZXJdXSB1c2VkIHRvIGRpc3BsYXkgdG9vbHRpcHMgaW4uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwidG9vbHRpcENvbnRhaW5lclwiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfdG9vbHRpcENvbnRhaW5lclNldHRpbmdzXCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl90b29sdGlwXCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8vIExvY2FsZS1yZWxhdGVkXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQGlnbm9yZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxhbmd1YWdlXCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IExhbmd1YWdlLm5ldyh0aGlzLCB7fSlcclxuICAgICAgICB9KTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBMb2NhbGUgdXNlZCBieSB0aGUgY2hhcnQuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAc2VlIHtAbGluayBodHRwczovL3d3dy5hbWNoYXJ0cy5jb20vZG9jcy92NS9jb25jZXB0cy9sb2NhbGVzL31cclxuICAgICAgICAgKi9cclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJsb2NhbGVcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogZW5cclxuICAgICAgICB9KTtcclxuICAgICAgICAvLyBEYXRlLXRpbWUgcmVsYXRlZFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFVzZSBVVEMgd2hlbiBmb3JtYXR0aW5nIGRhdGUvdGltZS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vd3d3LmFtY2hhcnRzLmNvbS9kb2NzL3Y1L2NvbmNlcHRzL2Zvcm1hdHRlcnMvZm9ybWF0dGluZy1kYXRlcy8jdXRjLWFuZC10aW1lLXpvbmVzfSBmb3IgbW9yZSBpbmZvXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwidXRjXCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IGZhbHNlXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSWYgc2V0LCB3aWxsIGZvcm1hdCBkYXRlL3RpbWUgaW4gc3BlY2lmaWMgdGltZSB6b25lLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogVGhlIHZhbHVlIHNob3VsZCBiZSBuYW1lZCB0aW1lIHpvbmUsIGUuZy46XHJcbiAgICAgICAgICogYFwiQW1lcmljYS9WYW5jb3V2ZXJcImAsIGBcIkF1c3RyYWxpYS9TeWRuZXlcImAsIGBcIlVUQ1wiYC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIE5PVEU6IFVzaW5nIHRpbWUgem9uZSBmZWF0dXJlIG1heSBub3RpY2VhYmxlIGFmZmVjdCBwZXJmb3JtYW5jZSBvZiB0aGVcclxuICAgICAgICAgKiBjaGFydCwgZXNwZWNpYWxseSB3aXRoIGxhcmdlIGRhdGEgc2V0cywgc2luY2UgZXZlcnkgc2luZ2xlIGRhdGUgd2lsbCBuZWVkXHJcbiAgICAgICAgICogdG8gYmUgcmVjYWxjdWxhdGVkLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly93d3cuYW1jaGFydHMuY29tL2RvY3MvdjUvZ2V0dGluZy1zdGFydGVkL3Jvb3QtZWxlbWVudC8jdGltZS16b25lfSBmb3IgbW9yZSBpbmZvXHJcbiAgICAgICAgICogQHNpbmNlIDUuMS4wXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwidGltZXpvbmVcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIG1heGltdW0gRlBTIHRoYXQgdGhlIFJvb3Qgd2lsbCBydW4gYXQuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBJZiBgdW5kZWZpbmVkYCBpdCB3aWxsIHJ1biBhdCB0aGUgaGlnaGVzdCBGUFMuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAc2VlIHtAbGluayBodHRwczovL3d3dy5hbWNoYXJ0cy5jb20vZG9jcy92NS9nZXR0aW5nLXN0YXJ0ZWQvcm9vdC1lbGVtZW50LyNQZXJmb3JtYW5jZX0gZm9yIG1vcmUgaW5mb1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImZwc1wiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcclxuICAgICAgICB9KTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBOdW1iZXIgZm9ybWF0dGVyLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly93d3cuYW1jaGFydHMuY29tL2RvY3MvdjUvY29uY2VwdHMvZm9ybWF0dGVycy9mb3JtYXR0aW5nLW51bWJlcnMvfSBmb3IgbW9yZSBpbmZvXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibnVtYmVyRm9ybWF0dGVyXCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IE51bWJlckZvcm1hdHRlci5uZXcodGhpcywge30pXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRGF0ZS90aW1lIGZvcm1hdHRlci5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vd3d3LmFtY2hhcnRzLmNvbS9kb2NzL3Y1L2NvbmNlcHRzL2Zvcm1hdHRlcnMvZm9ybWF0dGluZy1kYXRlcy99IGZvciBtb3JlIGluZm9cclxuICAgICAgICAgKi9cclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJkYXRlRm9ybWF0dGVyXCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IERhdGVGb3JtYXR0ZXIubmV3KHRoaXMsIHt9KVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIER1cmF0aW9uIGZvcm1hdHRlci5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vd3d3LmFtY2hhcnRzLmNvbS9kb2NzL3Y1L2NvbmNlcHRzL2Zvcm1hdHRlcnMvZm9ybWF0dGluZy1kYXRlcy99IGZvciBtb3JlIGluZm9cclxuICAgICAgICAgKi9cclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJkdXJhdGlvbkZvcm1hdHRlclwiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiBEdXJhdGlvbkZvcm1hdHRlci5uZXcodGhpcywge30pXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLy8gQWNjZXNzaWJpbGl0eVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdsb2JhbCB0YWIgaW5kZXggZm9yIHVzaW5nIGZvciB0aGUgd2hvbGUgY2hhcnRcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vd3d3LmFtY2hhcnRzLmNvbS9kb2NzL3Y1L2NvbmNlcHRzL2FjY2Vzc2liaWxpdHkvfSBmb3IgbW9yZSBpbmZvXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwidGFiaW5kZXhcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogMFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8vQHRvZG8gbWF5YmUgbWFrZSB0aGlzIGJldHRlclxyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl90YWJpbmRleGVzXCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IFtdXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX2ExMXlEXCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IGZhbHNlXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX2ZvY3VzRWxlbWVudERpcnR5XCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IGZhbHNlXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX2ZvY3VzRWxlbWVudENvbnRhaW5lclwiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfZm9jdXNlZFNwcml0ZVwiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfaXNTaGlmdFwiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfa2V5Ym9hcmREcmFnUG9pbnRcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX3Rvb2x0aXBFbGVtZW50Q29udGFpbmVyXCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9yZWFkZXJBbGVydEVsZW1lbnRcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX2xvZ29cIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX3Rvb2x0aXBEaXZcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVXNlZCBmb3IgZHluYW1pY2FsbHktY3JlYXRlZCBDU1MgYW5kIEphdmFTY3JpcHQgd2l0aCBzdHJpY3Qgc291cmNlIHBvbGljaWVzLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5vbmNlXCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFNwZWNpYWwgY29sb3Igc2V0IHRvIGJlIHVzZWQgZm9yIHZhcmlvdXMgY29udHJvbHMuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAc2VlIHtAbGluayBodHRwczovL3d3dy5hbWNoYXJ0cy5jb20vZG9jcy92NS9jb25jZXB0cy9jb2xvcnMtZ3JhZGllbnRzLWFuZC1wYXR0ZXJucy8jSW50ZXJmYWNlX2NvbG9yc30gZm9yIG1vcmUgaW5mb1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImludGVyZmFjZUNvbG9yc1wiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcclxuICAgICAgICB9KTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBbiBpbnN0YW5jZSBvZiB2ZXJ0aWNhbCBsYXlvdXQgb2JqZWN0IHRoYXQgY2FuIGJlIHVzZWQgdG8gc2V0IGBsYXlvdXRgIHNldHRpbmdcclxuICAgICAgICAgKiBvZiBhIFtbQ29udGFpbmVyXV0uXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAZGVmYXVsdCBWZXJ0aWNhbExheW91dC5uZXcoKVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInZlcnRpY2FsTGF5b3V0XCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IFZlcnRpY2FsTGF5b3V0Lm5ldyh0aGlzLCB7fSlcclxuICAgICAgICB9KTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBbiBpbnN0YW5jZSBvZiBob3Jpem9udGFsIGxheW91dCBvYmplY3QgdGhhdCBjYW4gYmUgdXNlZCB0byBzZXQgYGxheW91dGAgc2V0dGluZ1xyXG4gICAgICAgICAqIG9mIGEgW1tDb250YWluZXJdXS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBkZWZhdWx0IEhvcml6b250YWxMYXlvdXQubmV3KClcclxuICAgICAgICAgKi9cclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJob3Jpem9udGFsTGF5b3V0XCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IEhvcml6b250YWxMYXlvdXQubmV3KHRoaXMsIHt9KVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFuIGluc3RhbmNlIG9mIGdyaWQgbGF5b3V0IG9iamVjdCB0aGF0IGNhbiBiZSB1c2VkIHRvIHNldCBgbGF5b3V0YCBzZXR0aW5nXHJcbiAgICAgICAgICogb2YgYSBbW0NvbnRhaW5lcl1dLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQGRlZmF1bHQgVmVydGljYWxMYXlvdXQubmV3KClcclxuICAgICAgICAgKi9cclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJncmlkTGF5b3V0XCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IEdyaWRMYXlvdXQubmV3KHRoaXMsIHt9KVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9wYXVzZWRcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogZmFsc2VcclxuICAgICAgICB9KTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBJbmRpY2F0ZXMgd2hldGhlciBjaGFydCBzaG91bGQgcmVzaXplZCBhdXRvbWF0aWNhbGx5IHdoZW4gcGFyZW50IGNvbnRhaW5lclxyXG4gICAgICAgICAqIHdpZHRoIGFuZC9vciBoZWlnaHQgY2hhbmdlcy5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIElmIGRpc2FibGVkIChgYXV0b1Jlc2l6ZSA9IGZhbHNlYCkgeW91IGNhbiBtYWtlIHRoZSBjaGFydCByZXNpemUgbWFudWFsbHlcclxuICAgICAgICAgKiBieSBjYWxsaW5nIHJvb3QgZWxlbWVudCdzIGByZXNpemUoKWAgbWV0aG9kLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImF1dG9SZXNpemVcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9mb250SGFzaFwiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiBcIlwiXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX2lzRGlzcG9zZWRcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogZmFsc2VcclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfZGlzcG9zZXJzXCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IFtdXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX3Jlc2l6ZVNlbnNvckRpc3Bvc2VyXCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl90b29sdGlwc1wiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiBbXVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9odG1sRWxlbWVudENvbnRhaW5lclwiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfaHRtbEVuYWJsZWRDb250YWluZXJzXCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IFtdXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKCFpc1JlYWwpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiWW91IGNhbm5vdCB1c2UgYG5ldyBDbGFzcygpYCwgaW5zdGVhZCB1c2UgYENsYXNzLm5ldygpYFwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fc2V0dGluZ3MgPSBzZXR0aW5ncztcclxuICAgICAgICBpZiAoc2V0dGluZ3MuYWNjZXNzaWJsZSA9PSBmYWxzZSkge1xyXG4gICAgICAgICAgICB0aGlzLl9hMTF5RCA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzZXR0aW5ncy51c2VTYWZlUmVzb2x1dGlvbiA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHNldHRpbmdzLnVzZVNhZmVSZXNvbHV0aW9uID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IHJlc29sdXRpb247XHJcbiAgICAgICAgaWYgKHNldHRpbmdzLnVzZVNhZmVSZXNvbHV0aW9uKSB7XHJcbiAgICAgICAgICAgIHJlc29sdXRpb24gPSAkdXRpbHMuZ2V0U2FmZVJlc29sdXRpb24oKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fcmVuZGVyZXIgPSBuZXcgQ2FudmFzUmVuZGVyZXIocmVzb2x1dGlvbik7XHJcbiAgICAgICAgbGV0IGRvbTtcclxuICAgICAgICBpZiAoaWQgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkge1xyXG4gICAgICAgICAgICBkb20gPSBpZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGRvbSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlkKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgJGFycmF5LmVhY2gocmVnaXN0cnkucm9vdEVsZW1lbnRzLCAocm9vdCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAocm9vdC5kb20gPT09IGRvbSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiWW91IGNhbm5vdCBoYXZlIG11bHRpcGxlIFJvb3RzIG9uIHRoZSBzYW1lIERPTSBub2RlXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5pbnRlcmZhY2VDb2xvcnMgPSBJbnRlcmZhY2VDb2xvcnMubmV3KHRoaXMsIHt9KTtcclxuICAgICAgICBpZiAoZG9tID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBmaW5kIEhUTUwgZWxlbWVudCB3aXRoIGlkIGBcIiArIGlkICsgXCJgXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmRvbSA9IGRvbTtcclxuICAgICAgICBsZXQgaW5uZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xyXG4gICAgICAgIGlubmVyLnN0eWxlLnBvc2l0aW9uID0gXCJyZWxhdGl2ZVwiO1xyXG4gICAgICAgIGlubmVyLnN0eWxlLndpZHRoID0gXCIxMDAlXCI7XHJcbiAgICAgICAgaW5uZXIuc3R5bGUuaGVpZ2h0ID0gXCIxMDAlXCI7XHJcbiAgICAgICAgZG9tLmFwcGVuZENoaWxkKGlubmVyKTtcclxuICAgICAgICBjb25zdCB0b29sdGlwQ29udGFpbmVyQm91bmRzID0gc2V0dGluZ3MudG9vbHRpcENvbnRhaW5lckJvdW5kcztcclxuICAgICAgICBpZiAodG9vbHRpcENvbnRhaW5lckJvdW5kcykge1xyXG4gICAgICAgICAgICB0aGlzLl90b29sdGlwQ29udGFpbmVyU2V0dGluZ3MgPSB0b29sdGlwQ29udGFpbmVyQm91bmRzO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9pbm5lciA9IGlubmVyO1xyXG4gICAgICAgIHRoaXMuX3VwZGF0ZUNvbXB1dGVkU3R5bGVzKCk7XHJcbiAgICAgICAgcmVnaXN0cnkucm9vdEVsZW1lbnRzLnB1c2godGhpcyk7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgbmV3KGlkLCBzZXR0aW5ncykge1xyXG4gICAgICAgIGNvbnN0IHJvb3QgPSBuZXcgUm9vdChpZCwgc2V0dGluZ3MsIHRydWUpO1xyXG4gICAgICAgIHJvb3QuX2luaXQoKTtcclxuICAgICAgICByZXR1cm4gcm9vdDtcclxuICAgIH1cclxuICAgIG1vdmVET00oaWQpIHtcclxuICAgICAgICBsZXQgZG9tO1xyXG4gICAgICAgIGlmIChpZCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSB7XHJcbiAgICAgICAgICAgIGRvbSA9IGlkO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZG9tID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaWQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZG9tKSB7XHJcbiAgICAgICAgICAgIHdoaWxlICh0aGlzLmRvbS5jaGlsZE5vZGVzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgIGRvbS5hcHBlbmRDaGlsZCh0aGlzLmRvbS5jaGlsZE5vZGVzWzBdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmRvbSA9IGRvbTtcclxuICAgICAgICAgICAgdGhpcy5faW5pdFJlc2l6ZVNlbnNvcigpO1xyXG4gICAgICAgICAgICB0aGlzLnJlc2l6ZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIF9oYW5kbGVMb2dvKCkge1xyXG4gICAgICAgIGlmICh0aGlzLl9sb2dvKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHcgPSB0aGlzLmRvbS5vZmZzZXRXaWR0aDtcclxuICAgICAgICAgICAgY29uc3QgaCA9IHRoaXMuZG9tLm9mZnNldEhlaWdodDtcclxuICAgICAgICAgICAgaWYgKCh3IDw9IDE1MCkgfHwgKGggPD0gNjApKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9sb2dvLmhpZGUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2xvZ28uc2hvdygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgX3Nob3dCcmFuZGluZygpIHtcclxuICAgICAgICBpZiAoIXRoaXMuX2xvZ28pIHtcclxuICAgICAgICAgICAgY29uc3QgbG9nbyA9IHRoaXMudG9vbHRpcENvbnRhaW5lci5jaGlsZHJlbi5wdXNoKENvbnRhaW5lci5uZXcodGhpcywge1xyXG4gICAgICAgICAgICAgICAgaW50ZXJhY3RpdmU6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBpbnRlcmFjdGl2ZUNoaWxkcmVuOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBcImFic29sdXRlXCIsXHJcbiAgICAgICAgICAgICAgICBzZXRTdGF0ZU9uQ2hpbGRyZW46IHRydWUsXHJcbiAgICAgICAgICAgICAgICBwYWRkaW5nVG9wOiA5LFxyXG4gICAgICAgICAgICAgICAgcGFkZGluZ1JpZ2h0OiA5LFxyXG4gICAgICAgICAgICAgICAgcGFkZGluZ0JvdHRvbTogOSxcclxuICAgICAgICAgICAgICAgIHBhZGRpbmdMZWZ0OiA5LFxyXG4gICAgICAgICAgICAgICAgc2NhbGU6IC42LFxyXG4gICAgICAgICAgICAgICAgeTogcGVyY2VudCgxMDApLFxyXG4gICAgICAgICAgICAgICAgY2VudGVyWTogcDEwMCxcclxuICAgICAgICAgICAgICAgIHRvb2x0aXBUZXh0OiBcIkNyZWF0ZWQgdXNpbmcgYW1DaGFydHMgNVwiLFxyXG4gICAgICAgICAgICAgICAgdG9vbHRpcFg6IHAxMDAsXHJcbiAgICAgICAgICAgICAgICBjdXJzb3JPdmVyU3R5bGU6IFwicG9pbnRlclwiLFxyXG4gICAgICAgICAgICAgICAgYmFja2dyb3VuZDogUmVjdGFuZ2xlLm5ldyh0aGlzLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgZmlsbDogY29sb3IoMHg0NzQ3NTgpLFxyXG4gICAgICAgICAgICAgICAgICAgIGZpbGxPcGFjaXR5OiAwLFxyXG4gICAgICAgICAgICAgICAgICAgIHRvb2x0aXBZOiA1XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICAgIGNvbnN0IHRvb2x0aXAgPSBUb29sdGlwLm5ldyh0aGlzLCB7XHJcbiAgICAgICAgICAgICAgICBwb2ludGVyT3JpZW50YXRpb246IFwiaG9yaXpvbnRhbFwiLFxyXG4gICAgICAgICAgICAgICAgcGFkZGluZ1RvcDogNCxcclxuICAgICAgICAgICAgICAgIHBhZGRpbmdSaWdodDogNyxcclxuICAgICAgICAgICAgICAgIHBhZGRpbmdCb3R0b206IDQsXHJcbiAgICAgICAgICAgICAgICBwYWRkaW5nTGVmdDogN1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgdG9vbHRpcC5sYWJlbC5zZXRBbGwoe1xyXG4gICAgICAgICAgICAgICAgZm9udFNpemU6IDEyXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB0b29sdGlwLmdldChcImJhY2tncm91bmRcIikuc2V0QWxsKHtcclxuICAgICAgICAgICAgICAgIGZpbGw6IHRoaXMuaW50ZXJmYWNlQ29sb3JzLmdldChcImJhY2tncm91bmRcIiksXHJcbiAgICAgICAgICAgICAgICBzdHJva2U6IHRoaXMuaW50ZXJmYWNlQ29sb3JzLmdldChcImdyaWRcIiksXHJcbiAgICAgICAgICAgICAgICBzdHJva2VPcGFjaXR5OiAwLjNcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGxvZ28uc2V0KFwidG9vbHRpcFwiLCB0b29sdGlwKTtcclxuICAgICAgICAgICAgbG9nby5ldmVudHMub24oXCJjbGlja1wiLCAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB3aW5kb3cub3BlbihcImh0dHBzOi8vd3d3LmFtY2hhcnRzLmNvbS9cIiwgXCJfYmxhbmtcIik7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBsb2dvLnN0YXRlcy5jcmVhdGUoXCJob3ZlclwiLCB7fSk7XHJcbiAgICAgICAgICAgIGNvbnN0IG0gPSBsb2dvLmNoaWxkcmVuLnB1c2goR3JhcGhpY3MubmV3KHRoaXMsIHtcclxuICAgICAgICAgICAgICAgIHN0cm9rZTogY29sb3IoMHhjY2NjY2MpLFxyXG4gICAgICAgICAgICAgICAgc3Ryb2tlV2lkdGg6IDMsXHJcbiAgICAgICAgICAgICAgICBzdmdQYXRoOiBcIk01IDI1IEwxMyAyNWgxMy42YzMuNCAwIDYgMCAxMC4zLTQuM3M1LjItMTIgOC42LTEyYzMuNCAwIDQuMyA4LjYgNy43IDguNk04My40IDI1SDc5LjhjLTMuNCAwLTYgMC0xMC4zLTQuM3MtNS4yLTEyLTguNi0xMi00LjMgOC42LTcuNyA4LjZcIlxyXG4gICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICAgIG0uc3RhdGVzLmNyZWF0ZShcImhvdmVyXCIsIHsgc3Ryb2tlOiBjb2xvcigweDNDQUJGRikgfSk7XHJcbiAgICAgICAgICAgIGNvbnN0IGEgPSBsb2dvLmNoaWxkcmVuLnB1c2goR3JhcGhpY3MubmV3KHRoaXMsIHtcclxuICAgICAgICAgICAgICAgIHN0cm9rZTogY29sb3IoMHg4ODg4ODgpLFxyXG4gICAgICAgICAgICAgICAgc3Ryb2tlV2lkdGg6IDMsXHJcbiAgICAgICAgICAgICAgICBzdmdQYXRoOiBcIk04My40IDI1aC0zMUMzNyAyNSAzOS41IDQuNCAyOC40IDQuNFMxOC45IDI0LjIgNC4zIDI1SDBcIlxyXG4gICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICAgIGEuc3RhdGVzLmNyZWF0ZShcImhvdmVyXCIsIHsgc3Ryb2tlOiBjb2xvcigweDQ3NDc1OCkgfSk7XHJcbiAgICAgICAgICAgIC8vbG9nby5zZXQoXCJ0b29sdGlwXCIsIHRoaXMuX3Rvb2x0aXApO1xyXG4gICAgICAgICAgICAvL2xvZ28uc2V0UHJpdmF0ZShcInRvb2x0aXBUYXJnZXRcIiwgbG9nby5nZXQoXCJiYWNrZ3JvdW5kXCIpKTtcclxuICAgICAgICAgICAgdGhpcy5fbG9nbyA9IGxvZ287XHJcbiAgICAgICAgICAgIHRoaXMuX2hhbmRsZUxvZ28oKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBfZ2V0UmVhbFNpemUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZG9tLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG4gICAgfVxyXG4gICAgX2dldENhbGN1bGF0ZWRTaXplKHJlY3QpIHtcclxuICAgICAgICBpZiAodGhpcy5fc2V0dGluZ3MuY2FsY3VsYXRlU2l6ZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc2V0dGluZ3MuY2FsY3VsYXRlU2l6ZShyZWN0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICB3aWR0aDogcmVjdC53aWR0aCxcclxuICAgICAgICAgICAgICAgIGhlaWdodDogcmVjdC5oZWlnaHQsXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgX2luaXQoKSB7XHJcbiAgICAgICAgY29uc3Qgc2V0dGluZ3MgPSB0aGlzLl9zZXR0aW5ncztcclxuICAgICAgICBpZiAoc2V0dGluZ3MuYWNjZXNzaWJsZSAhPT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgaWYgKHNldHRpbmdzLmZvY3VzYWJsZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5faW5uZXIuc2V0QXR0cmlidXRlKFwiZm9jdXNhYmxlXCIsIFwidHJ1ZVwiKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2lubmVyLnNldEF0dHJpYnV0ZShcInRhYmluZGV4XCIsIHRoaXMudGFiaW5kZXggKyBcIlwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoc2V0dGluZ3MuYXJpYUxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9pbm5lci5zZXRBdHRyaWJ1dGUoXCJhcmlhLWxhYmVsXCIsIHNldHRpbmdzLmFyaWFMYWJlbCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHNldHRpbmdzLnJvbGUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2lubmVyLnNldEF0dHJpYnV0ZShcInJvbGVcIiwgc2V0dGluZ3Mucm9sZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgcmVuZGVyZXIgPSB0aGlzLl9yZW5kZXJlcjtcclxuICAgICAgICBjb25zdCByZWN0ID0gdGhpcy5fZ2V0UmVhbFNpemUoKTtcclxuICAgICAgICBjb25zdCBzaXplID0gdGhpcy5fZ2V0Q2FsY3VsYXRlZFNpemUocmVjdCk7XHJcbiAgICAgICAgY29uc3Qgd2lkdGggPSBNYXRoLmZsb29yKHNpemUud2lkdGgpO1xyXG4gICAgICAgIGNvbnN0IGhlaWdodCA9IE1hdGguZmxvb3Ioc2l6ZS5oZWlnaHQpO1xyXG4gICAgICAgIGNvbnN0IHJlYWxXaWR0aCA9IE1hdGguZmxvb3IocmVjdC53aWR0aCk7XHJcbiAgICAgICAgY29uc3QgcmVhbEhlaWdodCA9IE1hdGguZmxvb3IocmVjdC5oZWlnaHQpO1xyXG4gICAgICAgIGNvbnN0IHJvb3RDb250YWluZXIgPSBDb250YWluZXIubmV3KHRoaXMsIHtcclxuICAgICAgICAgICAgdmlzaWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd2lkdGg6IHdpZHRoLFxyXG4gICAgICAgICAgICBoZWlnaHQ6IGhlaWdodCxcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLl9yb290Q29udGFpbmVyID0gcm9vdENvbnRhaW5lcjtcclxuICAgICAgICB0aGlzLl9yb290Q29udGFpbmVyLl9kZWZhdWx0VGhlbWVzLnB1c2goRGVmYXVsdFRoZW1lLm5ldyh0aGlzKSk7XHJcbiAgICAgICAgY29uc3QgY29udGFpbmVyID0gcm9vdENvbnRhaW5lci5jaGlsZHJlbi5wdXNoKENvbnRhaW5lci5uZXcodGhpcywgeyB2aXNpYmxlOiB0cnVlLCB3aWR0aDogcDEwMCwgaGVpZ2h0OiBwMTAwIH0pKTtcclxuICAgICAgICB0aGlzLmNvbnRhaW5lciA9IGNvbnRhaW5lcjtcclxuICAgICAgICByZW5kZXJlci5yZXNpemUocmVhbFdpZHRoLCByZWFsSGVpZ2h0LCB3aWR0aCwgaGVpZ2h0KTtcclxuICAgICAgICAvL0B0b2RvOiBiZXR0ZXIgYXBwZW5kQ2hpbGQgLSByZWZlclxyXG4gICAgICAgIHRoaXMuX2lubmVyLmFwcGVuZENoaWxkKHJlbmRlcmVyLnZpZXcpO1xyXG4gICAgICAgIC8vIFRPRE86IFRNUCBUTVAgVE1QIGZvciB0ZXN0aW5nIG9ubHksIHJlbW92ZVxyXG4gICAgICAgIC8vcmVuZGVyZXIuZGVidWdHaG9zdFZpZXcgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuX2luaXRSZXNpemVTZW5zb3IoKTtcclxuICAgICAgICAvLyBIVE1MIGNvbnRlbnQgaG9sZGVyXHJcbiAgICAgICAgY29uc3QgaHRtbEVsZW1lbnRDb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xyXG4gICAgICAgIHRoaXMuX2h0bWxFbGVtZW50Q29udGFpbmVyID0gaHRtbEVsZW1lbnRDb250YWluZXI7XHJcbiAgICAgICAgaHRtbEVsZW1lbnRDb250YWluZXIuY2xhc3NOYW1lID0gXCJhbTUtaHRtbC1jb250YWluZXJcIjtcclxuICAgICAgICBodG1sRWxlbWVudENvbnRhaW5lci5zdHlsZS5wb3NpdGlvbiA9IFwiYWJzb2x1dGVcIjtcclxuICAgICAgICBodG1sRWxlbWVudENvbnRhaW5lci5zdHlsZS5wb2ludGVyRXZlbnRzID0gXCJub25lXCI7XHJcbiAgICAgICAgaWYgKCF0aGlzLl90b29sdGlwQ29udGFpbmVyU2V0dGluZ3MpIHtcclxuICAgICAgICAgICAgaHRtbEVsZW1lbnRDb250YWluZXIuc3R5bGUub3ZlcmZsb3cgPSBcImhpZGRlblwiO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9pbm5lci5hcHBlbmRDaGlsZChodG1sRWxlbWVudENvbnRhaW5lcik7XHJcbiAgICAgICAgaWYgKHRoaXMuX2ExMXlEICE9PSB0cnVlKSB7XHJcbiAgICAgICAgICAgIC8vIENyZWF0ZSBlbGVtZW50IHdoaWNoIGlzIHVzZWQgdG8gbWFrZSBhbm5vdW5jZW1lbnRzIHRvIHNjcmVlbiByZWFkZXJcclxuICAgICAgICAgICAgY29uc3QgcmVhZGVyQWxlcnRFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcclxuICAgICAgICAgICAgcmVhZGVyQWxlcnRFbGVtZW50LmNsYXNzTmFtZSA9IFwiYW01LXJlYWRlci1jb250YWluZXJcIjtcclxuICAgICAgICAgICAgcmVhZGVyQWxlcnRFbGVtZW50LnNldEF0dHJpYnV0ZShcInJvbGVcIiwgXCJhbGVydFwiKTtcclxuICAgICAgICAgICAgLy8gcmVhZGVyQWxlcnRFbGVtZW50LnN0eWxlLnpJbmRleCA9IFwiLTEwMDAwMFwiO1xyXG4gICAgICAgICAgICAvLyByZWFkZXJBbGVydEVsZW1lbnQuc3R5bGUub3BhY2l0eSA9IFwiMFwiO1xyXG4gICAgICAgICAgICAvLyByZWFkZXJBbGVydEVsZW1lbnQuc3R5bGUudG9wID0gXCIwXCI7XHJcbiAgICAgICAgICAgIHJlYWRlckFsZXJ0RWxlbWVudC5zdHlsZS5wb3NpdGlvbiA9IFwiYWJzb2x1dGVcIjtcclxuICAgICAgICAgICAgcmVhZGVyQWxlcnRFbGVtZW50LnN0eWxlLndpZHRoID0gXCIxcHhcIjtcclxuICAgICAgICAgICAgcmVhZGVyQWxlcnRFbGVtZW50LnN0eWxlLmhlaWdodCA9IFwiMXB4XCI7XHJcbiAgICAgICAgICAgIHJlYWRlckFsZXJ0RWxlbWVudC5zdHlsZS5vdmVyZmxvdyA9IFwiaGlkZGVuXCI7XHJcbiAgICAgICAgICAgIHJlYWRlckFsZXJ0RWxlbWVudC5zdHlsZS5jbGlwID0gXCJyZWN0KDFweCwgMXB4LCAxcHgsIDFweClcIjtcclxuICAgICAgICAgICAgdGhpcy5fcmVhZGVyQWxlcnRFbGVtZW50ID0gcmVhZGVyQWxlcnRFbGVtZW50O1xyXG4gICAgICAgICAgICB0aGlzLl9pbm5lci5hcHBlbmRDaGlsZCh0aGlzLl9yZWFkZXJBbGVydEVsZW1lbnQpO1xyXG4gICAgICAgICAgICBjb25zdCBmb2N1c0VsZW1lbnRDb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xyXG4gICAgICAgICAgICBmb2N1c0VsZW1lbnRDb250YWluZXIuY2xhc3NOYW1lID0gXCJhbTUtZm9jdXMtY29udGFpbmVyXCI7XHJcbiAgICAgICAgICAgIGZvY3VzRWxlbWVudENvbnRhaW5lci5zdHlsZS5wb3NpdGlvbiA9IFwiYWJzb2x1dGVcIjtcclxuICAgICAgICAgICAgZm9jdXNFbGVtZW50Q29udGFpbmVyLnN0eWxlLnBvaW50ZXJFdmVudHMgPSBcIm5vbmVcIjtcclxuICAgICAgICAgICAgZm9jdXNFbGVtZW50Q29udGFpbmVyLnN0eWxlLnRvcCA9IFwiMHB4XCI7XHJcbiAgICAgICAgICAgIGZvY3VzRWxlbWVudENvbnRhaW5lci5zdHlsZS5sZWZ0ID0gXCIwcHhcIjtcclxuICAgICAgICAgICAgZm9jdXNFbGVtZW50Q29udGFpbmVyLnN0eWxlLm92ZXJmbG93ID0gXCJoaWRkZW5cIjtcclxuICAgICAgICAgICAgZm9jdXNFbGVtZW50Q29udGFpbmVyLnN0eWxlLndpZHRoID0gd2lkdGggKyBcInB4XCI7XHJcbiAgICAgICAgICAgIGZvY3VzRWxlbWVudENvbnRhaW5lci5zdHlsZS5oZWlnaHQgPSBoZWlnaHQgKyBcInB4XCI7XHJcbiAgICAgICAgICAgIGZvY3VzRWxlbWVudENvbnRhaW5lci5zZXRBdHRyaWJ1dGUoXCJyb2xlXCIsIFwiZ3JhcGhpY3MtZG9jdW1lbnRcIik7XHJcbiAgICAgICAgICAgICR1dGlscy5zZXRJbnRlcmFjdGl2ZShmb2N1c0VsZW1lbnRDb250YWluZXIsIGZhbHNlKTtcclxuICAgICAgICAgICAgdGhpcy5fZm9jdXNFbGVtZW50Q29udGFpbmVyID0gZm9jdXNFbGVtZW50Q29udGFpbmVyO1xyXG4gICAgICAgICAgICB0aGlzLl9pbm5lci5hcHBlbmRDaGlsZCh0aGlzLl9mb2N1c0VsZW1lbnRDb250YWluZXIpO1xyXG4gICAgICAgICAgICBjb25zdCB0b29sdGlwRWxlbWVudENvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XHJcbiAgICAgICAgICAgIHRoaXMuX3Rvb2x0aXBFbGVtZW50Q29udGFpbmVyID0gdG9vbHRpcEVsZW1lbnRDb250YWluZXI7XHJcbiAgICAgICAgICAgIHRvb2x0aXBFbGVtZW50Q29udGFpbmVyLmNsYXNzTmFtZSA9IFwiYW01LXRvb2x0aXAtY29udGFpbmVyXCI7XHJcbiAgICAgICAgICAgIHRoaXMuX2lubmVyLmFwcGVuZENoaWxkKHRvb2x0aXBFbGVtZW50Q29udGFpbmVyKTtcclxuICAgICAgICAgICAgLy8gQWRkIGtleWJvYXJkIGV2ZW50cyBmb3IgYWNjZXNzaWJpbGl0eSwgZS5nLiBzaW11bGF0aW5nIGRyYWcgd2l0aCBhcnJvd1xyXG4gICAgICAgICAgICAvLyBrZXlzIGFuZCBjbGljayB3aXRoIEVOVEVSXHJcbiAgICAgICAgICAgIGlmICgkdXRpbHMuc3VwcG9ydHMoXCJrZXlib2FyZGV2ZW50c1wiKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZGlzcG9zZXJzLnB1c2goJHV0aWxzLmFkZEV2ZW50TGlzdGVuZXIod2luZG93LCBcImtleWRvd25cIiwgKGV2KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV2LmtleUNvZGUgPT0gMTYpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5faXNTaGlmdCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGV2LmtleUNvZGUgPT0gOSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9pc1NoaWZ0ID0gZXYuc2hpZnRLZXk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZGlzcG9zZXJzLnB1c2goJHV0aWxzLmFkZEV2ZW50TGlzdGVuZXIod2luZG93LCBcImtleXVwXCIsIChldikgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChldi5rZXlDb2RlID09IDE2KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2lzU2hpZnQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9kaXNwb3NlcnMucHVzaCgkdXRpbHMuYWRkRXZlbnRMaXN0ZW5lcihmb2N1c0VsZW1lbnRDb250YWluZXIsIFwiY2xpY2tcIiwgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFNvbWUgc2NyZWVuIHJlYWRlcnMgY29udmVydCBFTlRFUiAoYW5kIHNvbWUgU1BBQ0UpIHByZXNzIHdoaWwgb25cclxuICAgICAgICAgICAgICAgICAgICAvLyBmb2N1c2VkIGVsZW1lbnQgdG8gYSBcImNsaWNrXCIgZXZlbnQsIHByZXZlbnRpbmcgYWN0dWFsIFwia2V5ZG93blwiXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gZXZlbnQgZnJvbSBmaXJpbmcuIFdlJ3JlIHVzaW5nIHRoaXMgXCJjbGlja1wiIGV2ZW50IHRvIHN0aWxsXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gZ2VuZXJhdGUgaW50ZXJuYWwgY2xpY2sgZXZlbnRzLlxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZvY3VzZWRTcHJpdGUgPSB0aGlzLl9mb2N1c2VkU3ByaXRlO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChmb2N1c2VkU3ByaXRlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGRvd25FdmVudCA9IHJlbmRlcmVyLmdldEV2ZW50KG5ldyBNb3VzZUV2ZW50KFwiY2xpY2tcIikpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb2N1c2VkU3ByaXRlLmV2ZW50cy5kaXNwYXRjaChcImNsaWNrXCIsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiY2xpY2tcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IGRvd25FdmVudC5ldmVudCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50OiBkb3duRXZlbnQucG9pbnQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaW11bGF0ZWQ6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQ6IGZvY3VzZWRTcHJpdGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZGlzcG9zZXJzLnB1c2goJHV0aWxzLmFkZEV2ZW50TGlzdGVuZXIoZm9jdXNFbGVtZW50Q29udGFpbmVyLCBcImtleWRvd25cIiwgKGV2KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZm9jdXNlZFNwcml0ZSA9IHRoaXMuX2ZvY3VzZWRTcHJpdGU7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZvY3VzZWRTcHJpdGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV2LmtleUNvZGUgPT0gMjcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEVTQyBwcmVzc2VkIC0gbG9zZSBjdXJyZW50IGZvY3VzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkdXRpbHMuYmx1cigpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZm9jdXNlZFNwcml0ZSA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgZHJhZ09mZnNldFggPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgZHJhZ09mZnNldFkgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBmaWd1cmUgb3V0IGlmIHVzaW5nIGJvZ3VzIE1vdXNlRXZlbnQgaXMgZmluZSwgb3IgaXQgd2lsbFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBmYWlsIG9uIHNvbWUgcGxhdGZvcm1zXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoZXYua2V5Q29kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxMzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGRvd25FdmVudCA9IHJlbmRlcmVyLmdldEV2ZW50KG5ldyBNb3VzZUV2ZW50KFwiY2xpY2tcIikpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvY3VzZWRTcHJpdGUuZXZlbnRzLmRpc3BhdGNoKFwiY2xpY2tcIiwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImNsaWNrXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IGRvd25FdmVudC5ldmVudCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnQ6IGRvd25FdmVudC5wb2ludCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2ltdWxhdGVkOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQ6IGZvY3VzZWRTcHJpdGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDM3OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRyYWdPZmZzZXRYID0gLTY7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDM5OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRyYWdPZmZzZXRYID0gNjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMzg6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZHJhZ09mZnNldFkgPSAtNjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNDA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZHJhZ09mZnNldFkgPSA2O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRyYWdPZmZzZXRYICE9IDAgfHwgZHJhZ09mZnNldFkgIT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXYucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZm9jdXNlZFNwcml0ZS5pc0RyYWdnaW5nKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTdGFydCBkcmFnZ2luZ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2tleWJvYXJkRHJhZ1BvaW50ID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4OiAwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5OiAwXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkb3duRXZlbnQgPSByZW5kZXJlci5nZXRFdmVudChuZXcgTW91c2VFdmVudChcIm1vdXNlZG93blwiLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsaWVudFg6IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsaWVudFk6IDBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZvY3VzZWRTcHJpdGUuZXZlbnRzLmlzRW5hYmxlZChcInBvaW50ZXJkb3duXCIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvY3VzZWRTcHJpdGUuZXZlbnRzLmRpc3BhdGNoKFwicG9pbnRlcmRvd25cIiwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJwb2ludGVyZG93blwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxFdmVudDogZG93bkV2ZW50LmV2ZW50LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnQ6IGRvd25FdmVudC5wb2ludCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpbXVsYXRlZDogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldDogZm9jdXNlZFNwcml0ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBNb3ZlIGZvY3VzIG1hcmtlclxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vdGhpcy5fcG9zaXRpb25Gb2N1c0VsZW1lbnQoZm9jdXNlZFNwcml0ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBNb3ZlIGluY3JlbWVudGFsbHlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGRyYWdQb2ludCA9IHRoaXMuX2tleWJvYXJkRHJhZ1BvaW50O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZHJhZ1BvaW50LnggKz0gZHJhZ09mZnNldFg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkcmFnUG9pbnQueSArPSBkcmFnT2Zmc2V0WTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG1vdmVFdmVudCA9IHJlbmRlcmVyLmdldEV2ZW50KG5ldyBNb3VzZUV2ZW50KFwibW91c2Vtb3ZlXCIsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGllbnRYOiBkcmFnUG9pbnQueCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGllbnRZOiBkcmFnUG9pbnQueVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSksIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmb2N1c2VkU3ByaXRlLmV2ZW50cy5pc0VuYWJsZWQoXCJnbG9iYWxwb2ludGVybW92ZVwiKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvY3VzZWRTcHJpdGUuZXZlbnRzLmRpc3BhdGNoKFwiZ2xvYmFscG9pbnRlcm1vdmVcIiwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImdsb2JhbHBvaW50ZXJtb3ZlXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IG1vdmVFdmVudC5ldmVudCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnQ6IG1vdmVFdmVudC5wb2ludCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2ltdWxhdGVkOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQ6IGZvY3VzZWRTcHJpdGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2Rpc3Bvc2Vycy5wdXNoKCR1dGlscy5hZGRFdmVudExpc3RlbmVyKGZvY3VzRWxlbWVudENvbnRhaW5lciwgXCJrZXl1cFwiLCAoZXYpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fZm9jdXNlZFNwcml0ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBmb2N1c2VkU3ByaXRlID0gdGhpcy5fZm9jdXNlZFNwcml0ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qga2V5Q29kZSA9IGV2LmtleUNvZGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoa2V5Q29kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAzNzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMzk6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDM4OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA0MDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZm9jdXNlZFNwcml0ZS5pc0RyYWdnaW5nKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2ltdWxhdGUgZHJhZyBzdG9wXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGRyYWdQb2ludCA9IHRoaXMuX2tleWJvYXJkRHJhZ1BvaW50O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB1cEV2ZW50ID0gcmVuZGVyZXIuZ2V0RXZlbnQobmV3IE1vdXNlRXZlbnQoXCJtb3VzZXVwXCIsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsaWVudFg6IGRyYWdQb2ludC54LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xpZW50WTogZHJhZ1BvaW50LnlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZm9jdXNlZFNwcml0ZS5ldmVudHMuaXNFbmFibGVkKFwiZ2xvYmFscG9pbnRlcnVwXCIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb2N1c2VkU3ByaXRlLmV2ZW50cy5kaXNwYXRjaChcImdsb2JhbHBvaW50ZXJ1cFwiLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJnbG9iYWxwb2ludGVydXBcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbEV2ZW50OiB1cEV2ZW50LmV2ZW50LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50OiB1cEV2ZW50LnBvaW50LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpbXVsYXRlZDogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQ6IGZvY3VzZWRTcHJpdGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vdGhpcy5fcG9zaXRpb25Gb2N1c0VsZW1lbnQoZm9jdXNlZFNwcml0ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2tleWJvYXJkRHJhZ1BvaW50ID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBAdG9kbyBkaXNwYXRjaCBtb3VzZXVwIGV2ZW50IGluc3RlYWQgb2YgY2FsbGluZyBkcmFnU3RvcD9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhpcy5fZGlzcGF0Y2hFdmVudChcImdsb2JhbHBvaW50ZXJ1cFwiLCB0YXJnZXQsIHVwRXZlbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGZvY3VzZWRTcHJpdGUuZ2V0KFwiZm9jdXNhYmxlR3JvdXBcIikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRmluZCBuZXh0IGl0ZW0gaW4gZm9jdXNhYmxlIGdyb3VwXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGdyb3VwID0gZm9jdXNlZFNwcml0ZS5nZXQoXCJmb2N1c2FibGVHcm91cFwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaXRlbXMgPSB0aGlzLl90YWJpbmRleGVzLmZpbHRlcigoaXRlbSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW0uZ2V0KFwiZm9jdXNhYmxlR3JvdXBcIikgPT0gZ3JvdXAgJiYgaXRlbS5nZXRQcml2YXRlKFwiZm9jdXNhYmxlXCIpICE9PSBmYWxzZSA/IHRydWUgOiBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBpbmRleCA9IGl0ZW1zLmluZGV4T2YoZm9jdXNlZFNwcml0ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGxhc3RJbmRleCA9IGl0ZW1zLmxlbmd0aCAtIDE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4ICs9IChrZXlDb2RlID09IDM5IHx8IGtleUNvZGUgPT0gNDApID8gMSA6IC0xO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggPCAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleCA9IGxhc3RJbmRleDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChpbmRleCA+IGxhc3RJbmRleCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXggPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICR1dGlscy5mb2N1cyhpdGVtc1tpbmRleF0uZ2V0UHJpdmF0ZShcImZvY3VzRWxlbWVudFwiKS5kb20pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9zdGFydFRpY2tlcigpO1xyXG4gICAgICAgIHRoaXMuc2V0VGhlbWVzKFtdKTtcclxuICAgICAgICB0aGlzLl9hZGRUb29sdGlwKCk7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9oYXNMaWNlbnNlKCkpIHtcclxuICAgICAgICAgICAgdGhpcy5fc2hvd0JyYW5kaW5nKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgX2luaXRSZXNpemVTZW5zb3IoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX3Jlc2l6ZVNlbnNvckRpc3Bvc2VyKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3Jlc2l6ZVNlbnNvckRpc3Bvc2VyLmRpc3Bvc2UoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fcmVzaXplU2Vuc29yRGlzcG9zZXIgPSBuZXcgUmVzaXplU2Vuc29yKHRoaXMuZG9tLCAoKSA9PiB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmF1dG9SZXNpemUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVzaXplKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLl9kaXNwb3NlcnMucHVzaCh0aGlzLl9yZXNpemVTZW5zb3JEaXNwb3Nlcik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIElmIGF1dG9tYXRpYyByZXNpemluZyBvZiBjaGFyIGlzIGRpc2FibGVkIChgcm9vdC5hdXRvUmVzaXplID0gZmFsc2VgKSwgaXRcclxuICAgICAqIGNhbiBiZSByZXNpemVkIG1hbnVhbGx5IGJ5IGNhbGxpbmcgdGhpcyBtZXRob2QuXHJcbiAgICAgKi9cclxuICAgIHJlc2l6ZSgpIHtcclxuICAgICAgICBjb25zdCByZWN0ID0gdGhpcy5fZ2V0UmVhbFNpemUoKTtcclxuICAgICAgICBjb25zdCBzaXplID0gdGhpcy5fZ2V0Q2FsY3VsYXRlZFNpemUocmVjdCk7XHJcbiAgICAgICAgY29uc3QgdyA9IE1hdGguZmxvb3Ioc2l6ZS53aWR0aCk7XHJcbiAgICAgICAgY29uc3QgaCA9IE1hdGguZmxvb3Ioc2l6ZS5oZWlnaHQpO1xyXG4gICAgICAgIGlmICh3ID4gMCAmJiBoID4gMCkge1xyXG4gICAgICAgICAgICBjb25zdCByZWFsV2lkdGggPSBNYXRoLmZsb29yKHJlY3Qud2lkdGgpO1xyXG4gICAgICAgICAgICBjb25zdCByZWFsSGVpZ2h0ID0gTWF0aC5mbG9vcihyZWN0LmhlaWdodCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGh0bWxFbGVtZW50Q29udGFpbmVyID0gdGhpcy5faHRtbEVsZW1lbnRDb250YWluZXI7XHJcbiAgICAgICAgICAgIGh0bWxFbGVtZW50Q29udGFpbmVyLnN0eWxlLndpZHRoID0gdyArIFwicHhcIjtcclxuICAgICAgICAgICAgaHRtbEVsZW1lbnRDb250YWluZXIuc3R5bGUuaGVpZ2h0ID0gaCArIFwicHhcIjtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX2ExMXlEICE9PSB0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBmb2N1c0VsZW1lbnRDb250YWluZXIgPSB0aGlzLl9mb2N1c0VsZW1lbnRDb250YWluZXI7XHJcbiAgICAgICAgICAgICAgICBmb2N1c0VsZW1lbnRDb250YWluZXIuc3R5bGUud2lkdGggPSB3ICsgXCJweFwiO1xyXG4gICAgICAgICAgICAgICAgZm9jdXNFbGVtZW50Q29udGFpbmVyLnN0eWxlLmhlaWdodCA9IGggKyBcInB4XCI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIucmVzaXplKHJlYWxXaWR0aCwgcmVhbEhlaWdodCwgdywgaCk7XHJcbiAgICAgICAgICAgIGNvbnN0IHJvb3RDb250YWluZXIgPSB0aGlzLl9yb290Q29udGFpbmVyO1xyXG4gICAgICAgICAgICByb290Q29udGFpbmVyLnNldFByaXZhdGUoXCJ3aWR0aFwiLCB3KTtcclxuICAgICAgICAgICAgcm9vdENvbnRhaW5lci5zZXRQcml2YXRlKFwiaGVpZ2h0XCIsIGgpO1xyXG4gICAgICAgICAgICB0aGlzLl9yZW5kZXIoKTtcclxuICAgICAgICAgICAgdGhpcy5faGFuZGxlTG9nbygpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIF9yZW5kZXIoKSB7XHJcbiAgICAgICAgdGhpcy5fcmVuZGVyZXIucmVuZGVyKHRoaXMuX3Jvb3RDb250YWluZXIuX2Rpc3BsYXkpO1xyXG4gICAgICAgIGlmICh0aGlzLl9mb2N1c0VsZW1lbnREaXJ0eSkge1xyXG4gICAgICAgICAgICB0aGlzLl91cGRhdGVDdXJyZW50Rm9jdXMoKTtcclxuICAgICAgICAgICAgdGhpcy5fZm9jdXNFbGVtZW50RGlydHkgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBfcnVuVGlja2VycyhjdXJyZW50VGltZSkge1xyXG4gICAgICAgICRhcnJheS5lYWNoKHRoaXMuX3RpY2tlcnMsIChmKSA9PiB7XHJcbiAgICAgICAgICAgIGYoY3VycmVudFRpbWUpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgX3J1bkFuaW1hdGlvbnMoY3VycmVudFRpbWUpIHtcclxuICAgICAgICAkYXJyYXkua2VlcElmKHRoaXMuX2FuaW1hdGlvbnMsIChhbmltYXRpb24pID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIGFuaW1hdGlvbi5fcnVuQW5pbWF0aW9uKGN1cnJlbnRUaW1lKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIF9ydW5EaXJ0aWVzKCkge1xyXG4gICAgICAgIC8vY29uc29sZS5sb2coXCJ0aWNrICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXCIpO1xyXG4gICAgICAgIGxldCBhbGxQYXJlbnRzID0ge307XHJcbiAgICAgICAgd2hpbGUgKHRoaXMuX2lzRGlydHlQYXJlbnRzKSB7XHJcbiAgICAgICAgICAgIC8vIFRoaXMgbXVzdCBiZSBiZWZvcmUgY2FsbGluZyBfcHJlcGFyZUNoaWxkcmVuXHJcbiAgICAgICAgICAgIHRoaXMuX2lzRGlydHlQYXJlbnRzID0gZmFsc2U7XHJcbiAgICAgICAgICAgICRvYmplY3Qua2V5cyh0aGlzLl9kaXJ0eVBhcmVudHMpLmZvckVhY2goKGtleSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcGFyZW50ID0gdGhpcy5fZGlydHlQYXJlbnRzW2tleV07XHJcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5fZGlydHlQYXJlbnRzW2tleV07XHJcbiAgICAgICAgICAgICAgICBpZiAoIXBhcmVudC5pc0Rpc3Bvc2VkKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBhbGxQYXJlbnRzW3BhcmVudC51aWRdID0gcGFyZW50O1xyXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudC5fcHJlcGFyZUNoaWxkcmVuKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICAkb2JqZWN0LmtleXMoYWxsUGFyZW50cykuZm9yRWFjaCgoa2V5KSA9PiB7XHJcbiAgICAgICAgICAgIGFsbFBhcmVudHNba2V5XS5fdXBkYXRlQ2hpbGRyZW4oKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBjb25zdCBvYmplY3RzID0gW107XHJcbiAgICAgICAgLy9cdFx0Y29uc29sZS5sb2coXCJfYmVmb3JlQ2hhbmdlZFwiKVxyXG4gICAgICAgICRvYmplY3Qua2V5cyh0aGlzLl9kaXJ0eSkuZm9yRWFjaCgoa2V5KSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGVudGl0eSA9IHRoaXMuX2RpcnR5W2tleV07XHJcbiAgICAgICAgICAgIGlmIChlbnRpdHkuaXNEaXNwb3NlZCgpKSB7XHJcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5fZGlydHlbZW50aXR5LnVpZF07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBvYmplY3RzLnB1c2goZW50aXR5KTtcclxuICAgICAgICAgICAgICAgIGVudGl0eS5fYmVmb3JlQ2hhbmdlZCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLy9cdFx0Y29uc29sZS5sb2coXCJfY2hhbmdlZFwiKVxyXG4gICAgICAgIG9iamVjdHMuZm9yRWFjaCgoZW50aXR5KSA9PiB7XHJcbiAgICAgICAgICAgIGVudGl0eS5fY2hhbmdlZCgpO1xyXG4gICAgICAgICAgICBkZWxldGUgdGhpcy5fZGlydHlbZW50aXR5LnVpZF07XHJcbiAgICAgICAgICAgIGVudGl0eS5fY2xlYXJEaXJ0eSgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuX2lzRGlydHkgPSBmYWxzZTtcclxuICAgICAgICBjb25zdCBkZXB0aHMgPSB7fTtcclxuICAgICAgICBjb25zdCBib3VuZHMgPSBbXTtcclxuICAgICAgICAkb2JqZWN0LmtleXModGhpcy5fZGlydHlCb3VuZHMpLmZvckVhY2goKGtleSkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBlbnRpdHkgPSB0aGlzLl9kaXJ0eUJvdW5kc1trZXldO1xyXG4gICAgICAgICAgICBkZWxldGUgdGhpcy5fZGlydHlCb3VuZHNba2V5XTtcclxuICAgICAgICAgICAgaWYgKCFlbnRpdHkuaXNEaXNwb3NlZCgpKSB7XHJcbiAgICAgICAgICAgICAgICBkZXB0aHNbZW50aXR5LnVpZF0gPSBlbnRpdHkuZGVwdGgoKTtcclxuICAgICAgICAgICAgICAgIGJvdW5kcy5wdXNoKGVudGl0eSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLl9wb3NpdGlvbkhUTUxFbGVtZW50cygpO1xyXG4gICAgICAgIC8vIEhpZ2ggZGVwdGggLT4gbG93IGRlcHRoXHJcbiAgICAgICAgYm91bmRzLnNvcnQoKHgsIHkpID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuICRvcmRlci5jb21wYXJlKGRlcHRoc1t5LnVpZF0sIGRlcHRoc1t4LnVpZF0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8vXHRcdGNvbnNvbGUubG9nKFwiX3VwZGF0ZUJvdW5kc1wiKVxyXG4gICAgICAgIGJvdW5kcy5mb3JFYWNoKChlbnRpdHkpID0+IHtcclxuICAgICAgICAgICAgZW50aXR5Ll91cGRhdGVCb3VuZHMoKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICAvL1x0XHRjb25zb2xlLmxvZyhcIl91cGRhdGVQb3NpdGlvblwiKVxyXG4gICAgICAgIGNvbnN0IGRpcnR5UG9zaXRpb25zID0gdGhpcy5fZGlydHlQb3NpdGlvbnM7XHJcbiAgICAgICAgJG9iamVjdC5rZXlzKGRpcnR5UG9zaXRpb25zKS5mb3JFYWNoKChrZXkpID0+IHtcclxuICAgICAgICAgICAgY29uc3Qgc3ByaXRlID0gZGlydHlQb3NpdGlvbnNba2V5XTtcclxuICAgICAgICAgICAgZGVsZXRlIGRpcnR5UG9zaXRpb25zW2tleV07XHJcbiAgICAgICAgICAgIGlmICghc3ByaXRlLmlzRGlzcG9zZWQoKSkge1xyXG4gICAgICAgICAgICAgICAgc3ByaXRlLl91cGRhdGVQb3NpdGlvbigpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLy9cdFx0Y29uc29sZS5sb2coXCJfYWZ0ZXJDaGFuZ2VkXCIpXHJcbiAgICAgICAgb2JqZWN0cy5mb3JFYWNoKChlbnRpdHkpID0+IHtcclxuICAgICAgICAgICAgZW50aXR5Ll9hZnRlckNoYW5nZWQoKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIF9yZW5kZXJGcmFtZShjdXJyZW50VGltZSkge1xyXG4gICAgICAgIGlmICh0aGlzLl91cGRhdGVUaWNrKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmV2ZW50cy5pc0VuYWJsZWQoXCJmcmFtZXN0YXJ0ZWRcIikpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZXZlbnRzLmRpc3BhdGNoKFwiZnJhbWVzdGFydGVkXCIsIHtcclxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImZyYW1lc3RhcnRlZFwiLFxyXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldDogdGhpcyxcclxuICAgICAgICAgICAgICAgICAgICB0aW1lc3RhbXA6IGN1cnJlbnRUaW1lLFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fY2hlY2tDb21wdXRlZFN0eWxlcygpO1xyXG4gICAgICAgICAgICB0aGlzLl9ydW5UaWNrZXJzKGN1cnJlbnRUaW1lKTtcclxuICAgICAgICAgICAgdGhpcy5fcnVuQW5pbWF0aW9ucyhjdXJyZW50VGltZSk7XHJcbiAgICAgICAgICAgIHRoaXMuX3J1bkRpcnRpZXMoKTtcclxuICAgICAgICAgICAgdGhpcy5fcmVuZGVyKCk7XHJcbiAgICAgICAgICAgIHRoaXMuX3Bvc2l0aW9uSFRNTEVsZW1lbnRzKCk7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmV2ZW50cy5pc0VuYWJsZWQoXCJmcmFtZWVuZGVkXCIpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50cy5kaXNwYXRjaChcImZyYW1lZW5kZWRcIiwge1xyXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiZnJhbWVlbmRlZFwiLFxyXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldDogdGhpcyxcclxuICAgICAgICAgICAgICAgICAgICB0aW1lc3RhbXA6IGN1cnJlbnRUaW1lLFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RpY2tlcnMubGVuZ3RoID09PSAwICYmXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9hbmltYXRpb25zLmxlbmd0aCA9PT0gMCAmJlxyXG4gICAgICAgICAgICAgICAgIXRoaXMuX2lzRGlydHk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBfcnVuVGlja2VyKGN1cnJlbnRUaW1lLCBub3cpIHtcclxuICAgICAgICBpZiAoIXRoaXMuaXNEaXNwb3NlZCgpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYW5pbWF0aW9uVGltZSA9IGN1cnJlbnRUaW1lO1xyXG4gICAgICAgICAgICBjb25zdCBkb25lID0gdGhpcy5fcmVuZGVyRnJhbWUoY3VycmVudFRpbWUpO1xyXG4gICAgICAgICAgICAvLyBObyBtb3JlIHdvcmsgdG8gZG9cclxuICAgICAgICAgICAgaWYgKGRvbmUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3RpY2tlciA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFuaW1hdGlvblRpbWUgPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9wYXVzZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobm93KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3RpY2tlcjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJBRih0aGlzLmZwcywgdGhpcy5fdGlja2VyKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBfcnVuVGlja2VyTm93KHRpbWVvdXQgPSAxMDAwMCkge1xyXG4gICAgICAgIGlmICghdGhpcy5pc0Rpc3Bvc2VkKCkpIHtcclxuICAgICAgICAgICAgY29uc3QgZW5kVGltZSA9IHBlcmZvcm1hbmNlLm5vdygpICsgdGltZW91dDtcclxuICAgICAgICAgICAgZm9yICg7Oykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY3VycmVudFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcclxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50VGltZSA+PSBlbmRUaW1lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hbmltYXRpb25UaW1lID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuYW5pbWF0aW9uVGltZSA9IGN1cnJlbnRUaW1lO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZG9uZSA9IHRoaXMuX3JlbmRlckZyYW1lKGN1cnJlbnRUaW1lKTtcclxuICAgICAgICAgICAgICAgIGlmIChkb25lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hbmltYXRpb25UaW1lID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIF9zdGFydFRpY2tlcigpIHtcclxuICAgICAgICBpZiAodGhpcy5fdGlja2VyID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYW5pbWF0aW9uVGltZSA9IG51bGw7XHJcbiAgICAgICAgICAgIHRoaXMuX3RpY2tlciA9IChjdXJyZW50VGltZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcnVuVGlja2VyKGN1cnJlbnRUaW1lKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgckFGKHRoaXMuZnBzLCB0aGlzLl90aWNrZXIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB3aGV0aGVyIHRoZSByb290IGlzIHVwZGF0aW5nIG9yIG5vdC5cclxuICAgICAqL1xyXG4gICAgZ2V0IHVwZGF0ZVRpY2soKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3VwZGF0ZVRpY2s7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEVuYWJsZXMgb3IgZGlzYWJsZXMgdGhlIHJvb3QgdXBkYXRpbmcuXHJcbiAgICAgKi9cclxuICAgIHNldCB1cGRhdGVUaWNrKHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5fdXBkYXRlVGljayA9IHZhbHVlO1xyXG4gICAgICAgIGlmICh2YWx1ZSkge1xyXG4gICAgICAgICAgICB0aGlzLl9zdGFydFRpY2tlcigpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIF9hZGREaXJ0eUVudGl0eShlbnRpdHkpIHtcclxuICAgICAgICBpZiAodGhpcy5fZGlydHlbZW50aXR5LnVpZF0gPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB0aGlzLl9pc0RpcnR5ID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy5fZGlydHlbZW50aXR5LnVpZF0gPSBlbnRpdHk7XHJcbiAgICAgICAgICAgIHRoaXMuX3N0YXJ0VGlja2VyKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgX2FkZERpcnR5UGFyZW50KHBhcmVudCkge1xyXG4gICAgICAgIGlmICh0aGlzLl9kaXJ0eVBhcmVudHNbcGFyZW50LnVpZF0gPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB0aGlzLl9pc0RpcnR5ID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy5faXNEaXJ0eVBhcmVudHMgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLl9kaXJ0eVBhcmVudHNbcGFyZW50LnVpZF0gPSBwYXJlbnQ7XHJcbiAgICAgICAgICAgIHRoaXMuX3N0YXJ0VGlja2VyKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgX2FkZERpcnR5Qm91bmRzKGVudGl0eSkge1xyXG4gICAgICAgIGlmICh0aGlzLl9kaXJ0eUJvdW5kc1tlbnRpdHkudWlkXSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2lzRGlydHkgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLl9kaXJ0eUJvdW5kc1tlbnRpdHkudWlkXSA9IGVudGl0eTtcclxuICAgICAgICAgICAgdGhpcy5fc3RhcnRUaWNrZXIoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBfYWRkRGlydHlQb3NpdGlvbihzcHJpdGUpIHtcclxuICAgICAgICBpZiAodGhpcy5fZGlydHlQb3NpdGlvbnNbc3ByaXRlLnVpZF0gPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB0aGlzLl9pc0RpcnR5ID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy5fZGlydHlQb3NpdGlvbnNbc3ByaXRlLnVpZF0gPSBzcHJpdGU7XHJcbiAgICAgICAgICAgIHRoaXMuX3N0YXJ0VGlja2VyKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgX2FkZEFuaW1hdGlvbihhbmltYXRpb24pIHtcclxuICAgICAgICAvLyBUT0RPIHVzZSBudW1lcmljIGlkIGluc3RlYWRcclxuICAgICAgICBpZiAodGhpcy5fYW5pbWF0aW9ucy5pbmRleE9mKGFuaW1hdGlvbikgPT09IC0xKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2FuaW1hdGlvbnMucHVzaChhbmltYXRpb24pO1xyXG4gICAgICAgICAgICB0aGlzLl9zdGFydFRpY2tlcigpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIF9tYXJrRGlydHkoKSB7XHJcbiAgICAgICAgdGhpcy5faXNEaXJ0eSA9IHRydWU7XHJcbiAgICB9XHJcbiAgICBfbWFya0RpcnR5UmVkcmF3KCkge1xyXG4gICAgICAgIHRoaXMuZXZlbnRzLm9uY2UoXCJmcmFtZWVuZGVkXCIsICgpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5faXNEaXJ0eSA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMuX3N0YXJ0VGlja2VyKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBlYWNoRnJhbWUoZikge1xyXG4gICAgICAgIHRoaXMuX3RpY2tlcnMucHVzaChmKTtcclxuICAgICAgICB0aGlzLl9zdGFydFRpY2tlcigpO1xyXG4gICAgICAgIHJldHVybiBuZXcgRGlzcG9zZXIoKCkgPT4ge1xyXG4gICAgICAgICAgICAkYXJyYXkucmVtb3ZlRmlyc3QodGhpcy5fdGlja2VycywgZik7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBtYXJrRGlydHlHbG9iYWwoY29udGFpbmVyKSB7XHJcbiAgICAgICAgaWYgKCFjb250YWluZXIpIHtcclxuICAgICAgICAgICAgY29udGFpbmVyID0gdGhpcy5jb250YWluZXI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnRhaW5lci53YWxrQ2hpbGRyZW4oKGNoaWxkKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChjaGlsZCBpbnN0YW5jZW9mIENvbnRhaW5lcikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5tYXJrRGlydHlHbG9iYWwoY2hpbGQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNoaWxkLm1hcmtEaXJ0eSgpO1xyXG4gICAgICAgICAgICBjaGlsZC5tYXJrRGlydHlCb3VuZHMoKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB3aWR0aCBvZiB0aGUgdGFyZ2V0IGNvbnRhaW5lciwgaW4gcGl4ZWxzLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm4gV2lkdGhcclxuICAgICAqL1xyXG4gICAgd2lkdGgoKSB7XHJcbiAgICAgICAgLy8gVE9ETyBtYWtlIHRoaXMgbW9yZSBlZmZpY2llbnQsIG1heWJlIGp1c3QgcmV0dXJuIHRoZSByZW5kZXJlcidzIHdpZHRoID9cclxuICAgICAgICByZXR1cm4gTWF0aC5mbG9vcih0aGlzLl9nZXRDYWxjdWxhdGVkU2l6ZSh0aGlzLl9nZXRSZWFsU2l6ZSgpKS53aWR0aCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgaGVpZ2h0IG9mIHRoZSB0YXJnZXQgY29udGFpbmVyLCBpbiBwaXhlbHMuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybiBIZWlnaHRcclxuICAgICAqL1xyXG4gICAgaGVpZ2h0KCkge1xyXG4gICAgICAgIC8vIFRPRE8gbWFrZSB0aGlzIG1vcmUgZWZmaWNpZW50LCBtYXliZSBqdXN0IHJldHVybiB0aGUgcmVuZGVyZXIncyBoZWlnaHQgP1xyXG4gICAgICAgIHJldHVybiBNYXRoLmZsb29yKHRoaXMuX2dldENhbGN1bGF0ZWRTaXplKHRoaXMuX2dldFJlYWxTaXplKCkpLmhlaWdodCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIERpc3Bvc2VzIHJvb3QgYW5kIGFsbCB0aGUgY29udGVudCBpbiBpdC5cclxuICAgICAqL1xyXG4gICAgZGlzcG9zZSgpIHtcclxuICAgICAgICBpZiAoIXRoaXMuX2lzRGlzcG9zZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5faXNEaXNwb3NlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMuX3Jvb3RDb250YWluZXIuZGlzcG9zZSgpO1xyXG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5kaXNwb3NlKCk7XHJcbiAgICAgICAgICAgIHRoaXMuaG9yaXpvbnRhbExheW91dC5kaXNwb3NlKCk7XHJcbiAgICAgICAgICAgIHRoaXMudmVydGljYWxMYXlvdXQuZGlzcG9zZSgpO1xyXG4gICAgICAgICAgICB0aGlzLmludGVyZmFjZUNvbG9ycy5kaXNwb3NlKCk7XHJcbiAgICAgICAgICAgICRhcnJheS5lYWNoKHRoaXMuX2Rpc3Bvc2VycywgKHgpID0+IHtcclxuICAgICAgICAgICAgICAgIHguZGlzcG9zZSgpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX2lubmVyKSB7XHJcbiAgICAgICAgICAgICAgICAkdXRpbHMucmVtb3ZlRWxlbWVudCh0aGlzLl9pbm5lcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgJGFycmF5LnJlbW92ZShyZWdpc3RyeS5yb290RWxlbWVudHMsIHRoaXMpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBgdHJ1ZWAgaWYgcm9vdCBlbGVtZW50IGlzIGRpc3Bvc2VkLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm4gRGlzcG9zZWQ/XHJcbiAgICAgKi9cclxuICAgIGlzRGlzcG9zZWQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzRGlzcG9zZWQ7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRyaWdnZXJzIHNjcmVlbiByZWFkZXIgcmVhZCBvdXQgYSBtZXNzYWdlLlxyXG4gICAgICpcclxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vd3d3LmFtY2hhcnRzLmNvbS9kb2NzL3Y1L2NvbmNlcHRzL2FjY2Vzc2liaWxpdHkvfSBmb3IgbW9yZSBpbmZvXHJcbiAgICAgKiBAcGFyYW0gIHRleHQgIEFsZXJ0IHRleHRcclxuICAgICAqL1xyXG4gICAgcmVhZGVyQWxlcnQodGV4dCkge1xyXG4gICAgICAgIGlmICh0aGlzLl9hMTF5RCAhPT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICB0aGlzLl9yZWFkZXJBbGVydEVsZW1lbnQuaW5uZXJIVE1MID0gJHV0aWxzLnN0cmlwVGFncyh0ZXh0KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlbWVzIHRvIGJlIHVzZWQgZm9yIHRoZSBjaGFydC5cclxuICAgICAqXHJcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL3d3dy5hbWNoYXJ0cy5jb20vZG9jcy92NS9jb25jZXB0cy90aGVtZXMvfSBmb3IgbW9yZSBpbmZvXHJcbiAgICAgKiBAcGFyYW0gIHRoZW1lcyAgQSBsaXN0IG9mIHRoZW1lc1xyXG4gICAgICovXHJcbiAgICBzZXRUaGVtZXModGhlbWVzKSB7XHJcbiAgICAgICAgdGhpcy5fcm9vdENvbnRhaW5lci5zZXQoXCJ0aGVtZXNcIiwgdGhlbWVzKTtcclxuICAgICAgICAvLyBvdGhlcndpc2UgbmV3IHRoZW1lcyBhcmUgbm90IGFwcGxpZWRcclxuICAgICAgICBjb25zdCB0b29sdGlwQ29udGFpbmVyID0gdGhpcy50b29sdGlwQ29udGFpbmVyO1xyXG4gICAgICAgIGlmICh0b29sdGlwQ29udGFpbmVyKSB7XHJcbiAgICAgICAgICAgIHRvb2x0aXBDb250YWluZXIuX2FwcGx5VGhlbWVzKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIEB0b2RvIHJldmlldyB0aGlzXHJcbiAgICAgICAgY29uc3QgaW50ZXJmYWNlQ29sb3JzID0gdGhpcy5pbnRlcmZhY2VDb2xvcnM7XHJcbiAgICAgICAgaWYgKGludGVyZmFjZUNvbG9ycykge1xyXG4gICAgICAgICAgICBpbnRlcmZhY2VDb2xvcnMuX2FwcGx5VGhlbWVzKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgX2FkZFRvb2x0aXAoKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLnRvb2x0aXBDb250YWluZXIpIHtcclxuICAgICAgICAgICAgY29uc3QgdG9vbHRpcENvbnRhaW5lclNldHRpbmdzID0gdGhpcy5fdG9vbHRpcENvbnRhaW5lclNldHRpbmdzO1xyXG4gICAgICAgICAgICBjb25zdCB0b29sdGlwQ29udGFpbmVyID0gdGhpcy5fcm9vdENvbnRhaW5lci5jaGlsZHJlbi5wdXNoKENvbnRhaW5lci5uZXcodGhpcywge1xyXG4gICAgICAgICAgICAgICAgcG9zaXRpb246IFwiYWJzb2x1dGVcIixcclxuICAgICAgICAgICAgICAgIGlzTWVhc3VyZWQ6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgd2lkdGg6IHAxMDAsXHJcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IHAxMDAsXHJcbiAgICAgICAgICAgICAgICBsYXllcjogdG9vbHRpcENvbnRhaW5lclNldHRpbmdzID8gMzUgOiAzMCxcclxuICAgICAgICAgICAgICAgIGxheWVyTWFyZ2luOiB0b29sdGlwQ29udGFpbmVyU2V0dGluZ3MgPyB0b29sdGlwQ29udGFpbmVyU2V0dGluZ3MgOiB1bmRlZmluZWRcclxuICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgICB0aGlzLnRvb2x0aXBDb250YWluZXIgPSB0b29sdGlwQ29udGFpbmVyO1xyXG4gICAgICAgICAgICBjb25zdCB0b29sdGlwID0gVG9vbHRpcC5uZXcodGhpcywge30pO1xyXG4gICAgICAgICAgICB0aGlzLmNvbnRhaW5lci5zZXQoXCJ0b29sdGlwXCIsIHRvb2x0aXApO1xyXG4gICAgICAgICAgICB0b29sdGlwLmhpZGUoMCk7XHJcbiAgICAgICAgICAgIHRoaXMuX3Rvb2x0aXAgPSB0b29sdGlwO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQWNjZXNpYmlsaXR5XHJcbiAgICAgKi9cclxuICAgIF9yZWdpc3RlclRhYmluZGV4T3JkZXIodGFyZ2V0KSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2ExMXlEID09IHRydWUpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGFyZ2V0LmdldChcImZvY3VzYWJsZVwiKSkge1xyXG4gICAgICAgICAgICAkYXJyYXkucHVzaE9uZSh0aGlzLl90YWJpbmRleGVzLCB0YXJnZXQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgJGFycmF5LnJlbW92ZSh0aGlzLl90YWJpbmRleGVzLCB0YXJnZXQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9pbnZhbGlkYXRlVGFiaW5kZXhlcygpO1xyXG4gICAgfVxyXG4gICAgX3VucmVnaXN0ZXJUYWJpbmRleE9yZGVyKHRhcmdldCkge1xyXG4gICAgICAgIGlmICh0aGlzLl9hMTF5RCA9PSB0cnVlKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgJGFycmF5LnJlbW92ZSh0aGlzLl90YWJpbmRleGVzLCB0YXJnZXQpO1xyXG4gICAgICAgIHRoaXMuX2ludmFsaWRhdGVUYWJpbmRleGVzKCk7XHJcbiAgICB9XHJcbiAgICBfaW52YWxpZGF0ZVRhYmluZGV4ZXMoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2ExMXlEID09IHRydWUpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl90YWJpbmRleGVzLnNvcnQoKGEsIGIpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgYWluZGV4ID0gYS5nZXQoXCJ0YWJpbmRleE9yZGVyXCIsIDApO1xyXG4gICAgICAgICAgICBjb25zdCBiaW5kZXggPSBiLmdldChcInRhYmluZGV4T3JkZXJcIiwgMCk7XHJcbiAgICAgICAgICAgIGlmIChhaW5kZXggPT0gYmluZGV4KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChhaW5kZXggPiBiaW5kZXgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgY29uc3QgZ3JvdXBzID0gW107XHJcbiAgICAgICAgJGFycmF5LmVhY2godGhpcy5fdGFiaW5kZXhlcywgKGl0ZW0sIGluZGV4KSA9PiB7XHJcbiAgICAgICAgICAgIGlmICghaXRlbS5nZXRQcml2YXRlKFwiZm9jdXNFbGVtZW50XCIpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9tYWtlRm9jdXNFbGVtZW50KGluZGV4LCBpdGVtKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX21vdmVGb2N1c0VsZW1lbnQoaW5kZXgsIGl0ZW0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IGdyb3VwID0gaXRlbS5nZXQoXCJmb2N1c2FibGVHcm91cFwiKTtcclxuICAgICAgICAgICAgaWYgKGdyb3VwICYmIGl0ZW0uZ2V0UHJpdmF0ZShcImZvY3VzYWJsZVwiKSAhPT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgICAgIGlmIChncm91cHMuaW5kZXhPZihncm91cCkgIT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gTm9uLWZpcnN0IGVsZW1lbnQgaW4gdGhlIGdyb3VwLCBtYWtlIGl0IG5vdCBkaXJlY3RseSBmb2N1c2FibGVcclxuICAgICAgICAgICAgICAgICAgICBpdGVtLmdldFByaXZhdGUoXCJmb2N1c0VsZW1lbnRcIikuZG9tLnNldEF0dHJpYnV0ZShcInRhYmluZGV4XCIsIFwiLTFcIik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBncm91cHMucHVzaChncm91cCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIF91cGRhdGVDdXJyZW50Rm9jdXMoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2ExMXlEID09IHRydWUpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5fZm9jdXNlZFNwcml0ZSkge1xyXG4gICAgICAgICAgICB0aGlzLl9kZWNvcmF0ZUZvY3VzRWxlbWVudCh0aGlzLl9mb2N1c2VkU3ByaXRlKTtcclxuICAgICAgICAgICAgdGhpcy5fcG9zaXRpb25Gb2N1c0VsZW1lbnQodGhpcy5fZm9jdXNlZFNwcml0ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgX2RlY29yYXRlRm9jdXNFbGVtZW50KHRhcmdldCwgZm9jdXNFbGVtZW50KSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2ExMXlEID09IHRydWUpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBEZWNvcmF0ZSB3aXRoIHByb3BlciBhY2Nlc3NpYmlsaXR5IGF0dHJpYnV0ZXNcclxuICAgICAgICBpZiAoIWZvY3VzRWxlbWVudCkge1xyXG4gICAgICAgICAgICBmb2N1c0VsZW1lbnQgPSB0YXJnZXQuZ2V0UHJpdmF0ZShcImZvY3VzRWxlbWVudFwiKS5kb207XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghZm9jdXNFbGVtZW50KSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3Qgcm9sZSA9IHRhcmdldC5nZXQoXCJyb2xlXCIpO1xyXG4gICAgICAgIGlmIChyb2xlKSB7XHJcbiAgICAgICAgICAgIGZvY3VzRWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJyb2xlXCIsIHJvbGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZm9jdXNFbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShcInJvbGVcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGFyaWFMYWJlbCA9IHRhcmdldC5nZXQoXCJhcmlhTGFiZWxcIik7XHJcbiAgICAgICAgaWYgKGFyaWFMYWJlbCkge1xyXG4gICAgICAgICAgICBjb25zdCBsYWJlbCA9IHBvcHVsYXRlU3RyaW5nKHRhcmdldCwgYXJpYUxhYmVsKTtcclxuICAgICAgICAgICAgZm9jdXNFbGVtZW50LnNldEF0dHJpYnV0ZShcImFyaWEtbGFiZWxcIiwgbGFiZWwpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZm9jdXNFbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShcImFyaWEtbGFiZWxcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGFyaWFMaXZlID0gdGFyZ2V0LmdldChcImFyaWFMaXZlXCIpO1xyXG4gICAgICAgIGlmIChhcmlhTGl2ZSkge1xyXG4gICAgICAgICAgICBmb2N1c0VsZW1lbnQuc2V0QXR0cmlidXRlKFwiYXJpYS1saXZlXCIsIGFyaWFMaXZlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGZvY3VzRWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoXCJhcmlhLWxpdmVcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGFyaWFDaGVja2VkID0gdGFyZ2V0LmdldChcImFyaWFDaGVja2VkXCIpO1xyXG4gICAgICAgIGlmIChhcmlhQ2hlY2tlZCAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIGZvY3VzRWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJhcmlhLWNoZWNrZWRcIiwgYXJpYUNoZWNrZWQgPyBcInRydWVcIiA6IFwiZmFsc2VcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBmb2N1c0VsZW1lbnQucmVtb3ZlQXR0cmlidXRlKFwiYXJpYS1jaGVja2VkXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGFyZ2V0LmdldChcImFyaWFIaWRkZW5cIikpIHtcclxuICAgICAgICAgICAgZm9jdXNFbGVtZW50LnNldEF0dHJpYnV0ZShcImFyaWEtaGlkZGVuXCIsIFwidHJ1ZVwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGZvY3VzRWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoXCJhcmlhLWhpZGRlblwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgYXJpYU9yaWVudGF0aW9uID0gdGFyZ2V0LmdldChcImFyaWFPcmllbnRhdGlvblwiKTtcclxuICAgICAgICBpZiAoYXJpYU9yaWVudGF0aW9uKSB7XHJcbiAgICAgICAgICAgIGZvY3VzRWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJhcmlhLW9yaWVudGF0aW9uXCIsIGFyaWFPcmllbnRhdGlvbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBmb2N1c0VsZW1lbnQucmVtb3ZlQXR0cmlidXRlKFwiYXJpYS1vcmllbnRhdGlvblwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgYXJpYVZhbHVlTm93ID0gdGFyZ2V0LmdldChcImFyaWFWYWx1ZU5vd1wiKTtcclxuICAgICAgICBpZiAoYXJpYVZhbHVlTm93KSB7XHJcbiAgICAgICAgICAgIGZvY3VzRWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJhcmlhLXZhbHVlbm93XCIsIGFyaWFWYWx1ZU5vdyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBmb2N1c0VsZW1lbnQucmVtb3ZlQXR0cmlidXRlKFwiYXJpYS12YWx1ZW5vd1wiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgYXJpYVZhbHVlTWluID0gdGFyZ2V0LmdldChcImFyaWFWYWx1ZU1pblwiKTtcclxuICAgICAgICBpZiAoYXJpYVZhbHVlTWluKSB7XHJcbiAgICAgICAgICAgIGZvY3VzRWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJhcmlhLXZhbHVlbWluXCIsIGFyaWFWYWx1ZU1pbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBmb2N1c0VsZW1lbnQucmVtb3ZlQXR0cmlidXRlKFwiYXJpYS12YWx1ZW1pblwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgYXJpYVZhbHVlTWF4ID0gdGFyZ2V0LmdldChcImFyaWFWYWx1ZU1heFwiKTtcclxuICAgICAgICBpZiAoYXJpYVZhbHVlTWF4KSB7XHJcbiAgICAgICAgICAgIGZvY3VzRWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJhcmlhLXZhbHVlbWF4XCIsIGFyaWFWYWx1ZU1heCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBmb2N1c0VsZW1lbnQucmVtb3ZlQXR0cmlidXRlKFwiYXJpYS12YWx1ZW1heFwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgYXJpYVZhbHVlVGV4dCA9IHRhcmdldC5nZXQoXCJhcmlhVmFsdWVUZXh0XCIpO1xyXG4gICAgICAgIGlmIChhcmlhVmFsdWVUZXh0KSB7XHJcbiAgICAgICAgICAgIGZvY3VzRWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJhcmlhLXZhbHVldGV4dFwiLCBhcmlhVmFsdWVUZXh0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGZvY3VzRWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoXCJhcmlhLXZhbHVldGV4dFwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgYXJpYUNvbnRyb2xzID0gdGFyZ2V0LmdldChcImFyaWFDb250cm9sc1wiKTtcclxuICAgICAgICBpZiAoYXJpYUNvbnRyb2xzKSB7XHJcbiAgICAgICAgICAgIGZvY3VzRWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJhcmlhLWNvbnRyb2xzXCIsIGFyaWFDb250cm9scyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBmb2N1c0VsZW1lbnQucmVtb3ZlQXR0cmlidXRlKFwiYXJpYS1jb250cm9sc1wiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRhcmdldC5nZXQoXCJ2aXNpYmxlXCIpICYmIHRhcmdldC5nZXQoXCJvcGFjaXR5XCIpICE9PSAwICYmIHRhcmdldC5nZXQoXCJyb2xlXCIpICE9IFwidG9vbHRpcFwiICYmICF0YXJnZXQuaXNIaWRkZW4oKSAmJiB0YXJnZXQuZ2V0UHJpdmF0ZShcImZvY3VzYWJsZVwiKSAhPT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgaWYgKGZvY3VzRWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJ0YWJpbmRleFwiKSAhPSBcIi0xXCIpIHtcclxuICAgICAgICAgICAgICAgIGZvY3VzRWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJ0YWJpbmRleFwiLCBcIlwiICsgdGhpcy50YWJpbmRleCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZm9jdXNFbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShcImFyaWEtaGlkZGVuXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZm9jdXNFbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShcInRhYmluZGV4XCIpO1xyXG4gICAgICAgICAgICBmb2N1c0VsZW1lbnQuc2V0QXR0cmlidXRlKFwiYXJpYS1oaWRkZW5cIiwgXCJ0cnVlXCIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIF9tYWtlRm9jdXNFbGVtZW50KGluZGV4LCB0YXJnZXQpIHtcclxuICAgICAgICBpZiAodGFyZ2V0LmdldFByaXZhdGUoXCJmb2N1c0VsZW1lbnRcIikgfHwgdGhpcy5fYTExeUQgPT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIEluaXRcclxuICAgICAgICBjb25zdCBmb2N1c0VsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xyXG4gICAgICAgIGlmICh0YXJnZXQuZ2V0KFwicm9sZVwiKSAhPSBcInRvb2x0aXBcIikge1xyXG4gICAgICAgICAgICBmb2N1c0VsZW1lbnQudGFiSW5kZXggPSB0aGlzLnRhYmluZGV4O1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb2N1c0VsZW1lbnQuc3R5bGUucG9zaXRpb24gPSBcImFic29sdXRlXCI7XHJcbiAgICAgICAgJHV0aWxzLnNldEludGVyYWN0aXZlKGZvY3VzRWxlbWVudCwgZmFsc2UpO1xyXG4gICAgICAgIGNvbnN0IGRpc3Bvc2VycyA9IFtdO1xyXG4gICAgICAgIHRhcmdldC5zZXRQcml2YXRlKFwiZm9jdXNFbGVtZW50XCIsIHtcclxuICAgICAgICAgICAgZG9tOiBmb2N1c0VsZW1lbnQsXHJcbiAgICAgICAgICAgIGRpc3Bvc2VycyxcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLl9kZWNvcmF0ZUZvY3VzRWxlbWVudCh0YXJnZXQpO1xyXG4gICAgICAgIGRpc3Bvc2Vycy5wdXNoKCR1dGlscy5hZGRFdmVudExpc3RlbmVyKGZvY3VzRWxlbWVudCwgXCJmb2N1c1wiLCAoZXYpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5faGFuZGxlRm9jdXMoZXYsIGluZGV4KTtcclxuICAgICAgICB9KSk7XHJcbiAgICAgICAgZGlzcG9zZXJzLnB1c2goJHV0aWxzLmFkZEV2ZW50TGlzdGVuZXIoZm9jdXNFbGVtZW50LCBcImJsdXJcIiwgKGV2KSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuX2hhbmRsZUJsdXIoZXYsIGluZGV4KTtcclxuICAgICAgICB9KSk7XHJcbiAgICAgICAgdGhpcy5fbW92ZUZvY3VzRWxlbWVudChpbmRleCwgdGFyZ2V0KTtcclxuICAgIH1cclxuICAgIF9yZW1vdmVGb2N1c0VsZW1lbnQodGFyZ2V0KSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2ExMXlEID09IHRydWUpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICAkYXJyYXkucmVtb3ZlKHRoaXMuX3RhYmluZGV4ZXMsIHRhcmdldCk7XHJcbiAgICAgICAgY29uc3QgZm9jdXNFbGVtZW50ID0gdGFyZ2V0LmdldFByaXZhdGUoXCJmb2N1c0VsZW1lbnRcIik7XHJcbiAgICAgICAgaWYgKGZvY3VzRWxlbWVudCkge1xyXG4gICAgICAgICAgICBjb25zdCBjb250YWluZXIgPSB0aGlzLl9mb2N1c0VsZW1lbnRDb250YWluZXI7XHJcbiAgICAgICAgICAgIGNvbnRhaW5lci5yZW1vdmVDaGlsZChmb2N1c0VsZW1lbnQuZG9tKTtcclxuICAgICAgICAgICAgJGFycmF5LmVhY2goZm9jdXNFbGVtZW50LmRpc3Bvc2VycywgKHgpID0+IHtcclxuICAgICAgICAgICAgICAgIHguZGlzcG9zZSgpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBfaGlkZUZvY3VzRWxlbWVudCh0YXJnZXQpIHtcclxuICAgICAgICBpZiAodGhpcy5fYTExeUQgPT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGZvY3VzRWxlbWVudCA9IHRhcmdldC5nZXRQcml2YXRlKFwiZm9jdXNFbGVtZW50XCIpO1xyXG4gICAgICAgIGZvY3VzRWxlbWVudC5kb20uc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xyXG4gICAgfVxyXG4gICAgX21vdmVGb2N1c0VsZW1lbnQoaW5kZXgsIHRhcmdldCkge1xyXG4gICAgICAgIGlmICh0aGlzLl9hMTF5RCA9PSB0cnVlKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gR2V0IGNvbnRhaW5lclxyXG4gICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IHRoaXMuX2ZvY3VzRWxlbWVudENvbnRhaW5lcjtcclxuICAgICAgICBjb25zdCBmb2N1c0VsZW1lbnQgPSB0YXJnZXQuZ2V0UHJpdmF0ZShcImZvY3VzRWxlbWVudFwiKS5kb207XHJcbiAgICAgICAgaWYgKGZvY3VzRWxlbWVudCA9PT0gdGhpcy5fZm9jdXNFbGVtZW50Q29udGFpbmVyLmNoaWxkcmVuW2luZGV4XSkge1xyXG4gICAgICAgICAgICAvLyBOb3RoaW5nIHRvIGRvXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgbmV4dCA9IHRoaXMuX2ZvY3VzRWxlbWVudENvbnRhaW5lci5jaGlsZHJlbltpbmRleCArIDFdO1xyXG4gICAgICAgIGlmIChuZXh0KSB7XHJcbiAgICAgICAgICAgIGNvbnRhaW5lci5pbnNlcnRCZWZvcmUoZm9jdXNFbGVtZW50LCBuZXh0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnRhaW5lci5hcHBlbmQoZm9jdXNFbGVtZW50KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBfcG9zaXRpb25Gb2N1c0VsZW1lbnQodGFyZ2V0KSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2ExMXlEID09IHRydWUgfHwgdGFyZ2V0ID09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGJvdW5kcyA9IHRhcmdldC5nbG9iYWxCb3VuZHMoKTtcclxuICAgICAgICBsZXQgd2lkdGggPSBib3VuZHMucmlnaHQgPT0gYm91bmRzLmxlZnQgPyB0YXJnZXQud2lkdGgoKSA6IGJvdW5kcy5yaWdodCAtIGJvdW5kcy5sZWZ0O1xyXG4gICAgICAgIGxldCBoZWlnaHQgPSBib3VuZHMudG9wID09IGJvdW5kcy5ib3R0b20gPyB0YXJnZXQuaGVpZ2h0KCkgOiBib3VuZHMuYm90dG9tIC0gYm91bmRzLnRvcDtcclxuICAgICAgICBjb25zdCBwYWRkaW5nID0gdGhpcy5fc2V0dGluZ3MuZm9jdXNQYWRkaW5nICE9PSB1bmRlZmluZWQgPyB0aGlzLl9zZXR0aW5ncy5mb2N1c1BhZGRpbmcgOiAyO1xyXG4gICAgICAgIGxldCB4ID0gYm91bmRzLmxlZnQgLSBwYWRkaW5nO1xyXG4gICAgICAgIGxldCB5ID0gYm91bmRzLnRvcCAtIHBhZGRpbmc7XHJcbiAgICAgICAgaWYgKHdpZHRoIDwgMCkge1xyXG4gICAgICAgICAgICB4ICs9IHdpZHRoO1xyXG4gICAgICAgICAgICB3aWR0aCA9IE1hdGguYWJzKHdpZHRoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGhlaWdodCA8IDApIHtcclxuICAgICAgICAgICAgeSArPSBoZWlnaHQ7XHJcbiAgICAgICAgICAgIGhlaWdodCA9IE1hdGguYWJzKGhlaWdodCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGZvY3VzRWxlbWVudCA9IHRhcmdldC5nZXRQcml2YXRlKFwiZm9jdXNFbGVtZW50XCIpLmRvbTtcclxuICAgICAgICBmb2N1c0VsZW1lbnQuc3R5bGUudG9wID0geSArIFwicHhcIjtcclxuICAgICAgICBmb2N1c0VsZW1lbnQuc3R5bGUubGVmdCA9IHggKyBcInB4XCI7XHJcbiAgICAgICAgZm9jdXNFbGVtZW50LnN0eWxlLndpZHRoID0gKHdpZHRoICsgcGFkZGluZyAqIDIpICsgXCJweFwiO1xyXG4gICAgICAgIGZvY3VzRWxlbWVudC5zdHlsZS5oZWlnaHQgPSAoaGVpZ2h0ICsgcGFkZGluZyAqIDIpICsgXCJweFwiO1xyXG4gICAgfVxyXG4gICAgX2hhbmRsZUZvY3VzKGV2LCBpbmRleCkge1xyXG4gICAgICAgIGlmICh0aGlzLl9hMTF5RCA9PSB0cnVlKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gR2V0IGVsZW1lbnRcclxuICAgICAgICBjb25zdCBmb2N1c2VkID0gdGhpcy5fdGFiaW5kZXhlc1tpbmRleF07XHJcbiAgICAgICAgLy8gSnVtcCBvdmVyIGhpZGRlbiBlbGVtZW50c1xyXG4gICAgICAgIGlmICghZm9jdXNlZC5pc1Zpc2libGVEZWVwKCkpIHtcclxuICAgICAgICAgICAgdGhpcy5fZm9jdXNOZXh0KGV2LnRhcmdldCwgdGhpcy5faXNTaGlmdCA/IC0xIDogMSk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gU2l6ZSBhbmQgcG9zaXRpb25cclxuICAgICAgICB0aGlzLl9wb3NpdGlvbkZvY3VzRWxlbWVudChmb2N1c2VkKTtcclxuICAgICAgICAvL3RoaXMuX2RlY29yYXRlRm9jdXNFbGVtZW50KGZvY3VzZWQpO1xyXG4gICAgICAgIHRoaXMuX2ZvY3VzZWRTcHJpdGUgPSBmb2N1c2VkO1xyXG4gICAgICAgIGlmIChmb2N1c2VkLmV2ZW50cy5pc0VuYWJsZWQoXCJmb2N1c1wiKSkge1xyXG4gICAgICAgICAgICBmb2N1c2VkLmV2ZW50cy5kaXNwYXRjaChcImZvY3VzXCIsIHtcclxuICAgICAgICAgICAgICAgIHR5cGU6IFwiZm9jdXNcIixcclxuICAgICAgICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IGV2LFxyXG4gICAgICAgICAgICAgICAgdGFyZ2V0OiBmb2N1c2VkXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIF9mb2N1c05leHQoZWwsIGRpcmVjdGlvbikge1xyXG4gICAgICAgIGlmICh0aGlzLl9hMTF5RCA9PSB0cnVlKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgZm9jdXNhYmxlRWxlbWVudHMgPSBBcnJheS5mcm9tKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoW1xyXG4gICAgICAgICAgICAnYVtocmVmXScsXHJcbiAgICAgICAgICAgICdhcmVhW2hyZWZdJyxcclxuICAgICAgICAgICAgJ2J1dHRvbjpub3QoW2Rpc2FibGVkXSknLFxyXG4gICAgICAgICAgICAnZGV0YWlscycsXHJcbiAgICAgICAgICAgICdpbnB1dDpub3QoW2Rpc2FibGVkXSknLFxyXG4gICAgICAgICAgICAnaWZyYW1lOm5vdChbZGlzYWJsZWRdKScsXHJcbiAgICAgICAgICAgICdzZWxlY3Q6bm90KFtkaXNhYmxlZF0pJyxcclxuICAgICAgICAgICAgJ3RleHRhcmVhOm5vdChbZGlzYWJsZWRdKScsXHJcbiAgICAgICAgICAgICdbY29udGVudEVkaXRhYmxlPVwiXCJdJyxcclxuICAgICAgICAgICAgJ1tjb250ZW50RWRpdGFibGU9XCJ0cnVlXCJdJyxcclxuICAgICAgICAgICAgJ1tjb250ZW50RWRpdGFibGU9XCJUUlVFXCJdJyxcclxuICAgICAgICAgICAgJ1t0YWJpbmRleF06bm90KFt0YWJpbmRleF49XCItXCJdKScsXHJcbiAgICAgICAgICAgIC8vJzpub3QoW2Rpc2FibGVkXSknXHJcbiAgICAgICAgXS5qb2luKCcsJykpKTtcclxuICAgICAgICBsZXQgaW5kZXggPSBmb2N1c2FibGVFbGVtZW50cy5pbmRleE9mKGVsKSArIGRpcmVjdGlvbjtcclxuICAgICAgICBpZiAoaW5kZXggPCAwKSB7XHJcbiAgICAgICAgICAgIGluZGV4ID0gZm9jdXNhYmxlRWxlbWVudHMubGVuZ3RoIC0gMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoaW5kZXggPj0gZm9jdXNhYmxlRWxlbWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGluZGV4ID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9jdXNhYmxlRWxlbWVudHNbaW5kZXhdLmZvY3VzKCk7XHJcbiAgICB9XHJcbiAgICBfaGFuZGxlQmx1cihldiwgX2luZGV4KSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2ExMXlEID09IHRydWUpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBmb2N1c2VkID0gdGhpcy5fZm9jdXNlZFNwcml0ZTtcclxuICAgICAgICBpZiAoZm9jdXNlZCAmJiAhZm9jdXNlZC5pc0Rpc3Bvc2VkKCkgJiYgZm9jdXNlZC5ldmVudHMuaXNFbmFibGVkKFwiYmx1clwiKSkge1xyXG4gICAgICAgICAgICBmb2N1c2VkLmV2ZW50cy5kaXNwYXRjaChcImJsdXJcIiwge1xyXG4gICAgICAgICAgICAgICAgdHlwZTogXCJibHVyXCIsXHJcbiAgICAgICAgICAgICAgICBvcmlnaW5hbEV2ZW50OiBldixcclxuICAgICAgICAgICAgICAgIHRhcmdldDogZm9jdXNlZFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fZm9jdXNlZFNwcml0ZSA9IHVuZGVmaW5lZDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQGlnbm9yZVxyXG4gICAgICovXHJcbiAgICB1cGRhdGVUb29sdGlwKHRhcmdldCkge1xyXG4gICAgICAgIGlmICh0aGlzLl9hMTF5RCA9PSB0cnVlKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgdGV4dCA9ICR1dGlscy5zdHJpcFRhZ3ModGFyZ2V0Ll9nZXRUZXh0KCkpO1xyXG4gICAgICAgIGxldCB0b29sdGlwRWxlbWVudCA9IHRhcmdldC5nZXRQcml2YXRlKFwidG9vbHRpcEVsZW1lbnRcIik7XHJcbiAgICAgICAgaWYgKHRhcmdldC5nZXQoXCJyb2xlXCIpID09IFwidG9vbHRpcFwiICYmIHRleHQgIT0gXCJcIikge1xyXG4gICAgICAgICAgICBpZiAoIXRvb2x0aXBFbGVtZW50KSB7XHJcbiAgICAgICAgICAgICAgICB0b29sdGlwRWxlbWVudCA9IHRoaXMuX21ha2VUb29sdGlwRWxlbWVudCh0YXJnZXQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0b29sdGlwRWxlbWVudC5pbm5lckhUTUwgIT0gdGV4dCkge1xyXG4gICAgICAgICAgICAgICAgdG9vbHRpcEVsZW1lbnQuaW5uZXJIVE1MID0gdGV4dDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0b29sdGlwRWxlbWVudCkge1xyXG4gICAgICAgICAgICB0b29sdGlwRWxlbWVudC5yZW1vdmUoKTtcclxuICAgICAgICAgICAgdGFyZ2V0LnJlbW92ZVByaXZhdGUoXCJ0b29sdGlwRWxlbWVudFwiKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBfbWFrZVRvb2x0aXBFbGVtZW50KHRhcmdldCkge1xyXG4gICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IHRoaXMuX3Rvb2x0aXBFbGVtZW50Q29udGFpbmVyO1xyXG4gICAgICAgIGNvbnN0IHRvb2x0aXBFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcclxuICAgICAgICB0b29sdGlwRWxlbWVudC5zdHlsZS5wb3NpdGlvbiA9IFwiYWJzb2x1dGVcIjtcclxuICAgICAgICB0b29sdGlwRWxlbWVudC5zdHlsZS53aWR0aCA9IFwiMXB4XCI7XHJcbiAgICAgICAgdG9vbHRpcEVsZW1lbnQuc3R5bGUuaGVpZ2h0ID0gXCIxcHhcIjtcclxuICAgICAgICB0b29sdGlwRWxlbWVudC5zdHlsZS5vdmVyZmxvdyA9IFwiaGlkZGVuXCI7XHJcbiAgICAgICAgdG9vbHRpcEVsZW1lbnQuc3R5bGUuY2xpcCA9IFwicmVjdCgxcHgsIDFweCwgMXB4LCAxcHgpXCI7XHJcbiAgICAgICAgJHV0aWxzLnNldEludGVyYWN0aXZlKHRvb2x0aXBFbGVtZW50LCBmYWxzZSk7XHJcbiAgICAgICAgdGhpcy5fZGVjb3JhdGVGb2N1c0VsZW1lbnQodGFyZ2V0LCB0b29sdGlwRWxlbWVudCk7XHJcbiAgICAgICAgY29udGFpbmVyLmFwcGVuZCh0b29sdGlwRWxlbWVudCk7XHJcbiAgICAgICAgdGFyZ2V0LnNldFByaXZhdGUoXCJ0b29sdGlwRWxlbWVudFwiLCB0b29sdGlwRWxlbWVudCk7XHJcbiAgICAgICAgcmV0dXJuIHRvb2x0aXBFbGVtZW50O1xyXG4gICAgfVxyXG4gICAgX3JlbW92ZVRvb2x0aXBFbGVtZW50KHRhcmdldCkge1xyXG4gICAgICAgIGlmICh0aGlzLl9hMTF5RCA9PSB0cnVlKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgdG9vbHRpcEVsZW1lbnQgPSB0YXJnZXQuZ2V0UHJpdmF0ZShcInRvb2x0aXBFbGVtZW50XCIpO1xyXG4gICAgICAgIGlmICh0b29sdGlwRWxlbWVudCkge1xyXG4gICAgICAgICAgICBjb25zdCBwYXJlbnQgPSB0b29sdGlwRWxlbWVudC5wYXJlbnRFbGVtZW50O1xyXG4gICAgICAgICAgICBpZiAocGFyZW50KSB7XHJcbiAgICAgICAgICAgICAgICBwYXJlbnQucmVtb3ZlQ2hpbGQodG9vbHRpcEVsZW1lbnQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgX2ludmFsaWRhdGVBY2Nlc3NpYmlsaXR5KHRhcmdldCkge1xyXG4gICAgICAgIGlmICh0aGlzLl9hMTF5RCA9PSB0cnVlKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fZm9jdXNFbGVtZW50RGlydHkgPSB0cnVlO1xyXG4gICAgICAgIGNvbnN0IGZvY3VzRWxlbWVudCA9IHRhcmdldC5nZXRQcml2YXRlKFwiZm9jdXNFbGVtZW50XCIpO1xyXG4gICAgICAgIGlmICh0YXJnZXQuZ2V0KFwiZm9jdXNhYmxlXCIpKSB7XHJcbiAgICAgICAgICAgIGlmIChmb2N1c0VsZW1lbnQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2RlY29yYXRlRm9jdXNFbGVtZW50KHRhcmdldCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9wb3NpdGlvbkZvY3VzRWxlbWVudCh0YXJnZXQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBcdHRoaXMuX3JlbmRlcmVyLl9tYWtlRm9jdXNFbGVtZW50KDAsIHRoaXMpO1xyXG4gICAgICAgICAgICAvLyB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGZvY3VzRWxlbWVudCkge1xyXG4gICAgICAgICAgICB0aGlzLl9yZW1vdmVGb2N1c0VsZW1lbnQodGFyZ2V0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy90aGlzLnVwZGF0ZUN1cnJlbnRGb2N1cygpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGB0cnVlYCBpZiBgdGFyZ2V0YCBpcyBjdXJyZW50bHkgZm9jdXNlZC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gICB0YXJnZXQgIFRhcmdldFxyXG4gICAgICogQHJldHVybiAgICAgICAgICBGb2N1c2VkP1xyXG4gICAgICovXHJcbiAgICBmb2N1c2VkKHRhcmdldCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9mb2N1c2VkU3ByaXRlID09PSB0YXJnZXQ7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENvbnZlcnRzIGRvY3VtZW50IGNvb3JkaW5hdGVzIHRvIGNvb3JkaW5hdGVzIHdpdGhpbmcgcm9vdCBlbGVtZW50LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSAgIHBvaW50ICBEb2N1bWVudCBwb2ludFxyXG4gICAgICogQHJldHVybiAgICAgICAgIFJvb3QgcG9pbnRcclxuICAgICAqL1xyXG4gICAgZG9jdW1lbnRQb2ludFRvUm9vdChwb2ludCkge1xyXG4gICAgICAgIGNvbnN0IHJlY3QgPSB0aGlzLl9nZXRSZWFsU2l6ZSgpO1xyXG4gICAgICAgIGNvbnN0IHNpemUgPSB0aGlzLl9nZXRDYWxjdWxhdGVkU2l6ZShyZWN0KTtcclxuICAgICAgICBjb25zdCBzY2FsZVdpZHRoID0gc2l6ZS53aWR0aCAvIHJlY3Qud2lkdGg7XHJcbiAgICAgICAgY29uc3Qgc2NhbGVIZWlnaHQgPSBzaXplLmhlaWdodCAvIHJlY3QuaGVpZ2h0O1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHg6IChwb2ludC54IC0gcmVjdC5sZWZ0KSAqIHNjYWxlV2lkdGgsXHJcbiAgICAgICAgICAgIHk6IChwb2ludC55IC0gcmVjdC50b3ApICogc2NhbGVIZWlnaHQsXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ29udmVydHMgcm9vdCBjb29yZGluYXRlcyB0byBkb2N1bWVudFxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSAgIHBvaW50ICBEb2N1bWVudCBwb2ludFxyXG4gICAgICogQHJldHVybiAgICAgICAgIFJvb3QgcG9pbnRcclxuICAgICAqL1xyXG4gICAgcm9vdFBvaW50VG9Eb2N1bWVudChwb2ludCkge1xyXG4gICAgICAgIGNvbnN0IHJlY3QgPSB0aGlzLl9nZXRSZWFsU2l6ZSgpO1xyXG4gICAgICAgIGNvbnN0IHNpemUgPSB0aGlzLl9nZXRDYWxjdWxhdGVkU2l6ZShyZWN0KTtcclxuICAgICAgICBjb25zdCBzY2FsZVdpZHRoID0gc2l6ZS53aWR0aCAvIHJlY3Qud2lkdGg7XHJcbiAgICAgICAgY29uc3Qgc2NhbGVIZWlnaHQgPSBzaXplLmhlaWdodCAvIHJlY3QuaGVpZ2h0O1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHg6IChwb2ludC54IC8gc2NhbGVXaWR0aCkgKyByZWN0LmxlZnQsXHJcbiAgICAgICAgICAgIHk6IChwb2ludC55IC8gc2NhbGVIZWlnaHQpICsgcmVjdC50b3BcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAaWdub3JlXHJcbiAgICAgKi9cclxuICAgIGFkZERpc3Bvc2VyKGRpc3Bvc2VyKSB7XHJcbiAgICAgICAgdGhpcy5fZGlzcG9zZXJzLnB1c2goZGlzcG9zZXIpO1xyXG4gICAgICAgIHJldHVybiBkaXNwb3NlcjtcclxuICAgIH1cclxuICAgIF91cGRhdGVDb21wdXRlZFN0eWxlcygpIHtcclxuICAgICAgICBjb25zdCBzdHlsZXMgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLmRvbSk7XHJcbiAgICAgICAgbGV0IGZvbnRIYXNoID0gXCJcIjtcclxuICAgICAgICAkb2JqZWN0LmVhY2goc3R5bGVzLCAoa2V5LCB2YWwpID0+IHtcclxuICAgICAgICAgICAgaWYgKCR0eXBlLmlzU3RyaW5nKGtleSkgJiYga2V5Lm1hdGNoKC9eZm9udC8pKSB7XHJcbiAgICAgICAgICAgICAgICBmb250SGFzaCArPSB2YWw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICBjb25zdCBjaGFuZ2VkID0gZm9udEhhc2ggIT0gdGhpcy5fZm9udEhhc2g7XHJcbiAgICAgICAgaWYgKGNoYW5nZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5fZm9udEhhc2ggPSBmb250SGFzaDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGNoYW5nZWQ7XHJcbiAgICB9XHJcbiAgICBfY2hlY2tDb21wdXRlZFN0eWxlcygpIHtcclxuICAgICAgICBpZiAodGhpcy5fdXBkYXRlQ29tcHV0ZWRTdHlsZXMoKSkge1xyXG4gICAgICAgICAgICB0aGlzLl9pbnZhbGlkYXRlTGFiZWxCb3VuZHModGhpcy5jb250YWluZXIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIF9pbnZhbGlkYXRlTGFiZWxCb3VuZHModGFyZ2V0KSB7XHJcbiAgICAgICAgaWYgKHRhcmdldCBpbnN0YW5jZW9mIENvbnRhaW5lcikge1xyXG4gICAgICAgICAgICB0YXJnZXQuY2hpbGRyZW4uZWFjaCgoY2hpbGQpID0+IHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2ludmFsaWRhdGVMYWJlbEJvdW5kcyhjaGlsZCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0YXJnZXQgaW5zdGFuY2VvZiBUZXh0KSB7XHJcbiAgICAgICAgICAgIHRhcmdldC5tYXJrRGlydHlCb3VuZHMoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRvIGFsbCB0aGUgY2xldmVyIGhlYWRzIG91dCB0aGVyZS4gWWVzLCB3ZSBkaWQgbm90IG1ha2UgYW55IGF0dGVtcHRzIHRvXHJcbiAgICAgKiBzY3JhbWJsZSB0aGlzLlxyXG4gICAgICpcclxuICAgICAqIFRoaXMgaXMgYSBwYXJ0IG9mIGEgdG9vbCBtZWFudCBmb3Igb3VyIHVzZXJzIHRvIG1hbmFnZSB0aGVpciBjb21tZXJjaWFsXHJcbiAgICAgKiBsaWNlbnNlcyBmb3IgcmVtb3ZhbCBvZiBhbUNoYXJ0cyBicmFuZGluZyBmcm9tIGNoYXJ0cy5cclxuICAgICAqXHJcbiAgICAgKiBUaGUgb25seSBsZWdpdCB3YXkgdG8gZG8gc28gaXMgdG8gcHVyY2hhc2UgYSBjb21tZXJjaWFsIGxpY2Vuc2UgZm9yIGFtQ2hhcnRzOlxyXG4gICAgICogaHR0cHM6Ly93d3cuYW1jaGFydHMuY29tL29ubGluZS1zdG9yZS9cclxuICAgICAqXHJcbiAgICAgKiBSZW1vdmluZyBvciBhbHRlcmluZyB0aGlzIGNvZGUsIG9yIGRpc2FibGluZyBhbUNoYXJ0cyBicmFuZGluZyBpbiBhbnkgb3RoZXJcclxuICAgICAqIHdheSBpcyBhZ2FpbnN0IHRoZSBsaWNlbnNlIGFuZCB0aHVzIGlsbGVnYWwuXHJcbiAgICAgKi9cclxuICAgIF9oYXNMaWNlbnNlKCkge1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVnaXN0cnkubGljZW5zZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKHJlZ2lzdHJ5LmxpY2Vuc2VzW2ldLm1hdGNoKC9eQU01Qy57NSx9L2kpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBfbGljZW5zZUFwcGxpZWQoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2xvZ28pIHtcclxuICAgICAgICAgICAgdGhpcy5fbG9nby5zZXQoXCJmb3JjZUhpZGRlblwiLCB0cnVlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEBpZ25vcmVcclxuICAgICAqL1xyXG4gICAgZ2V0IGRlYnVnR2hvc3RWaWV3KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9yZW5kZXJlci5kZWJ1Z0dob3N0VmlldztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQGlnbm9yZVxyXG4gICAgICovXHJcbiAgICBzZXQgZGVidWdHaG9zdFZpZXcodmFsdWUpIHtcclxuICAgICAgICB0aGlzLl9yZW5kZXJlci5kZWJ1Z0dob3N0VmlldyA9IHZhbHVlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgdGhpcyB0byBgdHJ1ZWAgaWYgeW91IG5lZWQgY2hhcnQgdG8gcmVxdWlyZSBmaXJzdCBhIHRhcCBvbnRvIGl0IGJlZm9yZVxyXG4gICAgICogdG91Y2ggZ2VzdHVyZSByZWxhdGVkIGZ1bmN0aW9uYWxpdHkgbGlrZSB6b29tL3BhbiBpcyB0dXJuZWQgb24uXHJcbiAgICAgKlxyXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly93d3cuYW1jaGFydHMuY29tL2RvY3MvdjUvZ2V0dGluZy1zdGFydGVkL3Jvb3QtZWxlbWVudC8jVG91Y2hfcmVsYXRlZF9vcHRpb25zfSBmb3IgbW9yZSBpbmZvXHJcbiAgICAgKiBAZGVmYXVsdCBmYWxzZVxyXG4gICAgICogQHNpbmNlIDUuMi45XHJcbiAgICAgKiBAcGFyYW0gIHZhbHVlICBOZWVkcyBhIHRhcCB0byBhY3RpdmF0ZSB0b3VjaCBmdW5jdGlvbnNcclxuICAgICAqL1xyXG4gICAgc2V0IHRhcFRvQWN0aXZhdGUodmFsdWUpIHtcclxuICAgICAgICB0aGlzLl9yZW5kZXJlci50YXBUb0FjdGl2YXRlID0gdmFsdWU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm4gTmVlZHMgYSB0YXAgdG8gYWN0aXZhdGUgdG91Y2ggZnVuY3Rpb25zXHJcbiAgICAgKi9cclxuICAgIGdldCB0YXBUb0FjdGl2YXRlKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9yZW5kZXJlci50YXBUb0FjdGl2YXRlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBJZiBgdGFwVG9BY3RpdmF0ZWAgaXMgc2V0IHRvIGB0cnVlYCwgdGhpcyBzZXR0aW5nIHdpbGwgZGV0ZXJtaW5lIG51bWJlclxyXG4gICAgICogb2YgbWlsbGlzZWNvbmRzIHRoZSBjaGFydCB3aWxsIHN0YXkgXCJhY3RpdmVcIiwgYmVmb3JlIHJlbGVhc2luZyB0aGVcclxuICAgICAqIGNvbnRyb2xzIGJhY2sgdG8gdGhlIHBhZ2UuXHJcbiAgICAgKlxyXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly93d3cuYW1jaGFydHMuY29tL2RvY3MvdjUvZ2V0dGluZy1zdGFydGVkL3Jvb3QtZWxlbWVudC8jVG91Y2hfcmVsYXRlZF9vcHRpb25zfSBmb3IgbW9yZSBpbmZvXHJcbiAgICAgKiBAZGVmYXVsdCAzMDAwXHJcbiAgICAgKiBAc2luY2UgNS4yLjlcclxuICAgICAqIEBwYXJhbSAgdmFsdWUgIFRpbWVvdXRcclxuICAgICAqL1xyXG4gICAgc2V0IHRhcFRvQWN0aXZhdGVUaW1lb3V0KHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5fcmVuZGVyZXIudGFwVG9BY3RpdmF0ZVRpbWVvdXQgPSB2YWx1ZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybiBUaW1lb3V0XHJcbiAgICAgKi9cclxuICAgIGdldCB0YXBUb0FjdGl2YXRlVGltZW91dCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fcmVuZGVyZXIudGFwVG9BY3RpdmF0ZVRpbWVvdXQ7XHJcbiAgICB9XHJcbiAgICBfbWFrZUhUTUxFbGVtZW50KHRhcmdldCkge1xyXG4gICAgICAgIC8vIEdldCBjb250YWluZXJcclxuICAgICAgICBjb25zdCBjb250YWluZXIgPSB0aGlzLl9odG1sRWxlbWVudENvbnRhaW5lcjtcclxuICAgICAgICAvLyBJbml0XHJcbiAgICAgICAgY29uc3QgaHRtbEVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xyXG4gICAgICAgIHRhcmdldC5zZXRQcml2YXRlKFwiaHRtbEVsZW1lbnRcIiwgaHRtbEVsZW1lbnQpO1xyXG4gICAgICAgIC8vaHRtbEVsZW1lbnQudGFiSW5kZXggPSB0aGlzLnRhYmluZGV4O1xyXG4gICAgICAgIGh0bWxFbGVtZW50LnN0eWxlLnBvc2l0aW9uID0gXCJhYnNvbHV0ZVwiO1xyXG4gICAgICAgIGh0bWxFbGVtZW50LnN0eWxlLm92ZXJmbG93ID0gXCJhdXRvXCI7XHJcbiAgICAgICAgaHRtbEVsZW1lbnQuc3R5bGUuYm94U2l6aW5nID0gXCJib3JkZXItYm94XCI7XHJcbiAgICAgICAgJHV0aWxzLnNldEludGVyYWN0aXZlKGh0bWxFbGVtZW50LCB0YXJnZXQuZ2V0KFwiaW50ZXJhY3RpdmVcIiwgZmFsc2UpKTtcclxuICAgICAgICAvLyBUcmFuc2xhdGUgZXZlbnRzXHJcbiAgICAgICAgaWYgKHRhcmdldC5ldmVudHMuaXNFbmFibGVkKFwiY2xpY2tcIikpIHtcclxuICAgICAgICAgICAgJHV0aWxzLnNldEludGVyYWN0aXZlKGh0bWxFbGVtZW50LCB0cnVlKTtcclxuICAgICAgICAgICAgdGhpcy5fZGlzcG9zZXJzLnB1c2goJHV0aWxzLmFkZEV2ZW50TGlzdGVuZXIoaHRtbEVsZW1lbnQsIFwiY2xpY2tcIiwgKGV2KSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBkb3duRXZlbnQgPSB0aGlzLl9yZW5kZXJlci5nZXRFdmVudChldik7XHJcbiAgICAgICAgICAgICAgICB0YXJnZXQuZXZlbnRzLmRpc3BhdGNoKFwiY2xpY2tcIiwge1xyXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiY2xpY2tcIixcclxuICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbEV2ZW50OiBkb3duRXZlbnQuZXZlbnQsXHJcbiAgICAgICAgICAgICAgICAgICAgcG9pbnQ6IGRvd25FdmVudC5wb2ludCxcclxuICAgICAgICAgICAgICAgICAgICBzaW11bGF0ZWQ6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldDogdGFyZ2V0XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9wb3NpdGlvbkhUTUxFbGVtZW50KHRhcmdldCk7XHJcbiAgICAgICAgY29udGFpbmVyLmFwcGVuZChodG1sRWxlbWVudCk7XHJcbiAgICAgICAgJGFycmF5LnB1c2hPbmUodGhpcy5faHRtbEVuYWJsZWRDb250YWluZXJzLCB0YXJnZXQpO1xyXG4gICAgICAgIHJldHVybiBodG1sRWxlbWVudDtcclxuICAgIH1cclxuICAgIF9wb3NpdGlvbkhUTUxFbGVtZW50cygpIHtcclxuICAgICAgICAkYXJyYXkuZWFjaCh0aGlzLl9odG1sRW5hYmxlZENvbnRhaW5lcnMsICh0YXJnZXQpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5fcG9zaXRpb25IVE1MRWxlbWVudCh0YXJnZXQpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgX3Bvc2l0aW9uSFRNTEVsZW1lbnQodGFyZ2V0KSB7XHJcbiAgICAgICAgY29uc3QgaHRtbEVsZW1lbnQgPSB0YXJnZXQuZ2V0UHJpdmF0ZShcImh0bWxFbGVtZW50XCIpO1xyXG4gICAgICAgIGlmIChodG1sRWxlbWVudCkge1xyXG4gICAgICAgICAgICAvLyBUcmFuc2xhdGUgc2V0dGluZ3NcclxuICAgICAgICAgICAgY29uc3QgdmlzdWFsU2V0dGluZ3MgPSBbXCJwYWRkaW5nVG9wXCIsIFwicGFkZGluZ1JpZ2h0XCIsIFwicGFkZGluZ0JvdHRvbVwiLCBcInBhZGRpbmdMZWZ0XCIsIFwibWluV2lkdGhcIiwgXCJtaW5IZWlnaHRcIiwgXCJtYXhXaWR0aFwiLCBcIm1heEhlaWdodFwiXTtcclxuICAgICAgICAgICAgJGFycmF5LmVhY2godmlzdWFsU2V0dGluZ3MsIChzZXR0aW5nKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHRhcmdldC5nZXQoc2V0dGluZyk7XHJcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICBodG1sRWxlbWVudC5zdHlsZVtzZXR0aW5nXSA9IHZhbHVlICsgXCJweFwiO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaHRtbEVsZW1lbnQuc3R5bGVbc2V0dGluZ10gPSBcIlwiO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgLy8gRGVhbCB3aXRoIG9wYWNpdHlcclxuICAgICAgICAgICAgY29uc3Qgb3BhY2l0eSA9IHRhcmdldC5jb21wb3NpdGVPcGFjaXR5KCk7XHJcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaHRtbEVsZW1lbnQuc3R5bGUub3BhY2l0eSA9IG9wYWNpdHkgKyBcIlwiO1xyXG4gICAgICAgICAgICB9LCAxMCk7XHJcbiAgICAgICAgICAgIGNvbnN0IHZpc2libGUgPSB0YXJnZXQuaXNWaXNpYmxlRGVlcCgpO1xyXG4gICAgICAgICAgICBpZiAodmlzaWJsZSkge1xyXG4gICAgICAgICAgICAgICAgaHRtbEVsZW1lbnQuc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBEZWFsIHdpdGggcG9zaXRpb25cclxuICAgICAgICAgICAgY29uc3QgYm91bmRzID0gdGFyZ2V0Lmdsb2JhbEJvdW5kcygpO1xyXG4gICAgICAgICAgICBodG1sRWxlbWVudC5zdHlsZS50b3AgPSAoYm91bmRzLnRvcCkgKyBcInB4XCI7XHJcbiAgICAgICAgICAgIGh0bWxFbGVtZW50LnN0eWxlLmxlZnQgPSAoYm91bmRzLmxlZnQpICsgXCJweFwiO1xyXG4gICAgICAgICAgICAvLyBVc2Ugd2lkdGgvaGVpZ2h0IGlmIHRob3NlIGFyZSBzZXRcclxuICAgICAgICAgICAgY29uc3Qgd2lkdGggPSB0YXJnZXQuZ2V0KFwid2lkdGhcIik7XHJcbiAgICAgICAgICAgIGNvbnN0IGhlaWdodCA9IHRhcmdldC5nZXQoXCJoZWlnaHRcIik7XHJcbiAgICAgICAgICAgIGxldCB3ID0gMDtcclxuICAgICAgICAgICAgbGV0IGggPSAwO1xyXG4gICAgICAgICAgICBpZiAod2lkdGgpIHtcclxuICAgICAgICAgICAgICAgIHcgPSB0YXJnZXQud2lkdGgoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoaGVpZ2h0KSB7XHJcbiAgICAgICAgICAgICAgICBoID0gdGFyZ2V0LmhlaWdodCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghd2lkdGggfHwgIWhlaWdodCkge1xyXG4gICAgICAgICAgICAgICAgaHRtbEVsZW1lbnQuc3R5bGUucG9zaXRpb24gPSBcImZpeGVkXCI7XHJcbiAgICAgICAgICAgICAgICBodG1sRWxlbWVudC5zdHlsZS53aWR0aCA9IFwiXCI7XHJcbiAgICAgICAgICAgICAgICBodG1sRWxlbWVudC5zdHlsZS5oZWlnaHQgPSBcIlwiO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYmJveCA9IGh0bWxFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG4gICAgICAgICAgICAgICAgaHRtbEVsZW1lbnQuc3R5bGUucG9zaXRpb24gPSBcImFic29sdXRlXCI7XHJcbiAgICAgICAgICAgICAgICB3ID0gYmJveC53aWR0aDtcclxuICAgICAgICAgICAgICAgIGggPSBiYm94LmhlaWdodDtcclxuICAgICAgICAgICAgICAgIHRhcmdldC5fYWRqdXN0ZWRMb2NhbEJvdW5kcyA9IHsgbGVmdDogMCwgcmlnaHQ6IDAsIHRvcDogMCwgYm90dG9tOiAwIH07XHJcbiAgICAgICAgICAgICAgICB0YXJnZXQuc2V0UHJpdmF0ZShcIm1pbldpZHRoXCIsIHcpO1xyXG4gICAgICAgICAgICAgICAgdGFyZ2V0LnNldFByaXZhdGUoXCJtaW5IZWlnaHRcIiwgaCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0YXJnZXQucmVtb3ZlUHJpdmF0ZShcIm1pbldpZHRoXCIpO1xyXG4gICAgICAgICAgICAgICAgdGFyZ2V0LnJlbW92ZVByaXZhdGUoXCJtaW5IZWlnaHRcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHcgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICBodG1sRWxlbWVudC5zdHlsZS5taW5XaWR0aCA9ICh3KSArIFwicHhcIjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoaCA+IDApIHtcclxuICAgICAgICAgICAgICAgIGh0bWxFbGVtZW50LnN0eWxlLm1pbkhlaWdodCA9IChoKSArIFwicHhcIjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBIaWRlIG9yIHNob3dcclxuICAgICAgICAgICAgaWYgKCF2aXNpYmxlIHx8IG9wYWNpdHkgPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgaHRtbEVsZW1lbnQuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgX3NldEhUTUxDb250ZW50KHRhcmdldCwgaHRtbCkge1xyXG4gICAgICAgIGxldCBodG1sRWxlbWVudCA9IHRhcmdldC5nZXRQcml2YXRlKFwiaHRtbEVsZW1lbnRcIik7XHJcbiAgICAgICAgaWYgKCFodG1sRWxlbWVudCkge1xyXG4gICAgICAgICAgICBodG1sRWxlbWVudCA9IHRoaXMuX21ha2VIVE1MRWxlbWVudCh0YXJnZXQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaHRtbEVsZW1lbnQuaW5uZXJIVE1MICE9IGh0bWwpIHtcclxuICAgICAgICAgICAgaHRtbEVsZW1lbnQuaW5uZXJIVE1MID0gaHRtbDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBfcmVtb3ZlSFRNTENvbnRlbnQodGFyZ2V0KSB7XHJcbiAgICAgICAgbGV0IGh0bWxFbGVtZW50ID0gdGFyZ2V0LmdldFByaXZhdGUoXCJodG1sRWxlbWVudFwiKTtcclxuICAgICAgICBpZiAoaHRtbEVsZW1lbnQpIHtcclxuICAgICAgICAgICAgdGhpcy5faHRtbEVsZW1lbnRDb250YWluZXIucmVtb3ZlQ2hpbGQoaHRtbEVsZW1lbnQpO1xyXG4gICAgICAgICAgICB0YXJnZXQucmVtb3ZlUHJpdmF0ZShcImh0bWxFbGVtZW50XCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAkYXJyYXkucmVtb3ZlKHRoaXMuX2h0bWxFbmFibGVkQ29udGFpbmVycywgdGFyZ2V0KTtcclxuICAgIH1cclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1Sb290LmpzLm1hcCIsImltcG9ydCB7IFRlbXBsYXRlIH0gZnJvbSBcIi4vdXRpbC9UZW1wbGF0ZVwiO1xyXG5pbXBvcnQgKiBhcyAkb3JkZXIgZnJvbSBcIi4vdXRpbC9PcmRlclwiO1xyXG5pbXBvcnQgKiBhcyAkYXJyYXkgZnJvbSBcIi4vdXRpbC9BcnJheVwiO1xyXG4vKipcclxuICogQSBiYXNlIGNsYXNzIGZvciBhbiBhbUNoYXJ0cyB0aGVtZS5cclxuICpcclxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly93d3cuYW1jaGFydHMuY29tL2RvY3MvdjUvY29uY2VwdHMvdGhlbWVzL30gZm9yIG1vcmUgaW5mb1xyXG4gKiBAaW1wb3J0YW50XHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgVGhlbWUge1xyXG4gICAgY29uc3RydWN0b3Iocm9vdCwgaXNSZWFsKSB7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX3Jvb3RcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX3J1bGVzXCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IHt9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5fcm9vdCA9IHJvb3Q7XHJcbiAgICAgICAgaWYgKCFpc1JlYWwpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiWW91IGNhbm5vdCB1c2UgYG5ldyBDbGFzcygpYCwgaW5zdGVhZCB1c2UgYENsYXNzLm5ldygpYFwiKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFVzZSB0aGlzIG1ldGhvZCB0byBjcmVhdGUgYW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcy5cclxuICAgICAqXHJcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL3d3dy5hbWNoYXJ0cy5jb20vZG9jcy92NS9nZXR0aW5nLXN0YXJ0ZWQvI05ld19lbGVtZW50X3N5bnRheH0gZm9yIG1vcmUgaW5mb1xyXG4gICAgICogQHBhcmFtICAgcm9vdCAgICAgIFJvb3QgZWxlbWVudFxyXG4gICAgICogQHBhcmFtICAgc2V0dGluZ3MgIFNldHRpbmdzXHJcbiAgICAgKiBAcGFyYW0gICB0ZW1wbGF0ZSAgVGVtcGxhdGVcclxuICAgICAqIEByZXR1cm4gICAgICAgICAgICBJbnN0YW50aWF0ZWQgb2JqZWN0XHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBuZXcocm9vdCkge1xyXG4gICAgICAgIGNvbnN0IHggPSAobmV3IHRoaXMocm9vdCwgdHJ1ZSkpO1xyXG4gICAgICAgIHguc2V0dXBEZWZhdWx0UnVsZXMoKTtcclxuICAgICAgICByZXR1cm4geDtcclxuICAgIH1cclxuICAgIHNldHVwRGVmYXVsdFJ1bGVzKCkgeyB9XHJcbiAgICAvKipcclxuICAgICAqIExvb2tzIHVwIHRoZSBydWxlcyBmb3IgYSBzcGVjaWZpYyB0aGVtZSBjbGFzcy5cclxuICAgICAqXHJcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL3d3dy5hbWNoYXJ0cy5jb20vZG9jcy92NS90aGVtZXMvfSBmb3IgbW9yZSBpbmZvXHJcbiAgICAgKiBAcGFyYW0gICB0aGVtZUNsYXNzIFRoZW1lIGNsYXNzXHJcbiAgICAgKiBAcmV0dXJuICAgICAgICAgICAgIEFycmF5PElSdWxlPEE+PlxyXG4gICAgICovXHJcbiAgICBfbG9va3VwUnVsZXModGhlbWVDbGFzcykge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9ydWxlc1t0aGVtZUNsYXNzXTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIFtbVGVtcGxhdGVdXSBmb3Igc3BlY2lmaWMgdGhlbWUgY2xhc3MgYW5kIHRhZ3MuXHJcbiAgICAgKlxyXG4gICAgICogTk9URTogdGhlIGRpZmZlcmVuY2UgZnJvbSBgcnVsZSgpYCBpcyB0aGF0IGBydWxlUmF3KClgIGRvZXMgbm90IGRvIGFueVxyXG4gICAgICogdHlwZSBjaGVja3MuXHJcbiAgICAgKlxyXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly93d3cuYW1jaGFydHMuY29tL2RvY3MvdjUvdGhlbWVzL30gZm9yIG1vcmUgaW5mb1xyXG4gICAgICogQHBhcmFtICAgdGhlbWVDbGFzcyBUaGVtZSBjbGFzc1xyXG4gICAgICogQHBhcmFtICAgdGhlbWVUYWdzICBUaGVtZSB0YWdzXHJcbiAgICAgKiBAcmV0dXJuICAgICAgICAgICAgIFRlbXBsYXRlXHJcbiAgICAgKi9cclxuICAgIHJ1bGVSYXcodGhlbWVDbGFzcywgdGhlbWVUYWdzID0gW10pIHtcclxuICAgICAgICBsZXQgcnVsZXMgPSB0aGlzLl9ydWxlc1t0aGVtZUNsYXNzXTtcclxuICAgICAgICBpZiAoIXJ1bGVzKSB7XHJcbiAgICAgICAgICAgIHJ1bGVzID0gdGhpcy5fcnVsZXNbdGhlbWVDbGFzc10gPSBbXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhlbWVUYWdzLnNvcnQoJG9yZGVyLmNvbXBhcmUpO1xyXG4gICAgICAgIGNvbnN0IHsgaW5kZXgsIGZvdW5kIH0gPSAkYXJyYXkuZ2V0U29ydGVkSW5kZXgocnVsZXMsICh4KSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IG9yZGVyID0gJG9yZGVyLmNvbXBhcmUoeC50YWdzLmxlbmd0aCwgdGhlbWVUYWdzLmxlbmd0aCk7XHJcbiAgICAgICAgICAgIGlmIChvcmRlciA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICRvcmRlci5jb21wYXJlQXJyYXkoeC50YWdzLCB0aGVtZVRhZ3MsICRvcmRlci5jb21wYXJlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBvcmRlcjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGlmIChmb3VuZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gcnVsZXNbaW5kZXhdLnRlbXBsYXRlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3QgdGVtcGxhdGUgPSBUZW1wbGF0ZS5uZXcoe30pO1xyXG4gICAgICAgICAgICBydWxlcy5zcGxpY2UoaW5kZXgsIDAsIHtcclxuICAgICAgICAgICAgICAgIHRhZ3M6IHRoZW1lVGFncyxcclxuICAgICAgICAgICAgICAgIHRlbXBsYXRlLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIHRlbXBsYXRlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIFtbVGVtcGxhdGVdXSBmb3Igc3BlY2lmaWMgdGhlbWUgY2xhc3MgYW5kIHRhZ3MuXHJcbiAgICAgKlxyXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly93d3cuYW1jaGFydHMuY29tL2RvY3MvdjUvdGhlbWVzL30gZm9yIG1vcmUgaW5mb1xyXG4gICAgICogQHBhcmFtICAgdGhlbWVDbGFzcyBUaGVtZSBjbGFzc1xyXG4gICAgICogQHBhcmFtICAgdGhlbWVUYWdzICBUaGVtZSB0YWdzXHJcbiAgICAgKiBAcmV0dXJuICAgICAgICAgICAgIFRlbXBsYXRlXHJcbiAgICAgKi9cclxuICAgIHJ1bGUodGhlbWVDbGFzcywgdGhlbWVUYWdzID0gW10pIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5ydWxlUmF3KHRoZW1lQ2xhc3MsIHRoZW1lVGFncyk7XHJcbiAgICB9XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VGhlbWUuanMubWFwIiwiaW1wb3J0IHsgRW50aXR5IH0gZnJvbSBcIi4uLy4uL2NvcmUvdXRpbC9FbnRpdHlcIjtcclxuLyoqXHJcbiAqIEEgdW5pdmVyc2FsIHBsYWNlaG9sZGVyIGZvciBidWxsZXQgZWxlbWVudHMuXHJcbiAqXHJcbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vd3d3LmFtY2hhcnRzLmNvbS9kb2NzL3Y1L2NvbmNlcHRzL2NvbW1vbi1lbGVtZW50cy9idWxsZXRzL30gZm9yIG1vcmUgaW5mb1xyXG4gKi9cclxuZXhwb3J0IGNsYXNzIEJ1bGxldCBleHRlbmRzIEVudGl0eSB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xyXG4gICAgICAgIC8vIHVzZWQgYnkgTWFwUG9seWdvbnMgd2hlcmUgb25lIGRhdGEgaXRlbSBjYW4gaGF2ZSBtdWx0aXBsZSBidWxsZXRzIG9mIHRoZSBzYW1lIGtpbmRcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfaW5kZXhcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGFyZ2V0IHNlcmllcyBvYmplY3QgaWYgaXQncyBhIGJ1bGxldCBmb3Igc2VyaWVzLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInNlcmllc1wiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIF9hZnRlck5ldygpIHtcclxuICAgICAgICAvLyBBcHBseWluZyB0aGVtZXMgYmVjYXVzZSBidWxsZXQgd2lsbCBub3QgaGF2ZSBwYXJlbnRcclxuICAgICAgICBzdXBlci5fYWZ0ZXJOZXdBcHBseVRoZW1lcygpO1xyXG4gICAgfVxyXG4gICAgX2JlZm9yZUNoYW5nZWQoKSB7XHJcbiAgICAgICAgc3VwZXIuX2JlZm9yZUNoYW5nZWQoKTtcclxuICAgICAgICBpZiAodGhpcy5pc0RpcnR5KFwic3ByaXRlXCIpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHNwcml0ZSA9IHRoaXMuZ2V0KFwic3ByaXRlXCIpO1xyXG4gICAgICAgICAgICBpZiAoc3ByaXRlKSB7XHJcbiAgICAgICAgICAgICAgICBzcHJpdGUuc2V0QWxsKHsgcG9zaXRpb246IFwiYWJzb2x1dGVcIiwgcm9sZTogXCJmaWd1cmVcIiB9KTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2Rpc3Bvc2Vycy5wdXNoKHNwcml0ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuaXNEaXJ0eShcImxvY2F0aW9uWFwiKSB8fCB0aGlzLmlzRGlydHkoXCJsb2NhdGlvbllcIikpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuc2VyaWVzKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNlcmllcy5fcG9zaXRpb25CdWxsZXQodGhpcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEJ1bGxldCwgXCJjbGFzc05hbWVcIiwge1xyXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgdmFsdWU6IFwiQnVsbGV0XCJcclxufSk7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShCdWxsZXQsIFwiY2xhc3NOYW1lc1wiLCB7XHJcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICB2YWx1ZTogRW50aXR5LmNsYXNzTmFtZXMuY29uY2F0KFtCdWxsZXQuY2xhc3NOYW1lXSlcclxufSk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUJ1bGxldC5qcy5tYXAiLCJpbXBvcnQgeyBSb3VuZGVkUmVjdGFuZ2xlIH0gZnJvbSBcIi4uL3JlbmRlci9Sb3VuZGVkUmVjdGFuZ2xlXCI7XHJcbmltcG9ydCB7IENvbnRhaW5lciB9IGZyb20gXCIuL0NvbnRhaW5lclwiO1xyXG5pbXBvcnQgKiBhcyAkdXRpbHMgZnJvbSBcIi4uLy4uL2NvcmUvdXRpbC9VdGlsc1wiO1xyXG4vKipcclxuICogRHJhd3MgYW4gaW50ZXJhY3RpdmUgYnV0dG9uLlxyXG4gKlxyXG4gKiBAc2VlIHtAbGluayBodHRwczovL3d3dy5hbWNoYXJ0cy5jb20vZG9jcy92NS9jb25jZXB0cy9jb21tb24tZWxlbWVudHMvYnV0dG9ucy99IGZvciBtb3JlIGluZm9cclxuICogQGltcG9ydGFudFxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIEJ1dHRvbiBleHRlbmRzIENvbnRhaW5lciB7XHJcbiAgICBfYWZ0ZXJOZXcoKSB7XHJcbiAgICAgICAgdGhpcy5fc2V0dGluZ3MudGhlbWVUYWdzID0gJHV0aWxzLm1lcmdlVGFncyh0aGlzLl9zZXR0aW5ncy50aGVtZVRhZ3MsIFtcImJ1dHRvblwiXSk7XHJcbiAgICAgICAgc3VwZXIuX2FmdGVyTmV3KCk7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9zZXR0aW5ncy5iYWNrZ3JvdW5kKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0KFwiYmFja2dyb3VuZFwiLCBSb3VuZGVkUmVjdGFuZ2xlLm5ldyh0aGlzLl9yb290LCB7XHJcbiAgICAgICAgICAgICAgICB0aGVtZVRhZ3M6ICR1dGlscy5tZXJnZVRhZ3ModGhpcy5fc2V0dGluZ3MudGhlbWVUYWdzLCBbXCJiYWNrZ3JvdW5kXCJdKVxyXG4gICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuc2V0UHJpdmF0ZShcInRydXN0Qm91bmRzXCIsIHRydWUpO1xyXG4gICAgfVxyXG4gICAgX3ByZXBhcmVDaGlsZHJlbigpIHtcclxuICAgICAgICBzdXBlci5fcHJlcGFyZUNoaWxkcmVuKCk7XHJcbiAgICAgICAgaWYgKHRoaXMuaXNEaXJ0eShcImljb25cIikpIHtcclxuICAgICAgICAgICAgY29uc3QgcHJldmlvdXMgPSB0aGlzLl9wcmV2U2V0dGluZ3MuaWNvbjtcclxuICAgICAgICAgICAgY29uc3QgaWNvbiA9IHRoaXMuZ2V0KFwiaWNvblwiKTtcclxuICAgICAgICAgICAgaWYgKGljb24gIT09IHByZXZpb3VzKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9kaXNwb3NlUHJvcGVydHkoXCJpY29uXCIpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHByZXZpb3VzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJldmlvdXMuZGlzcG9zZSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGljb24pIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNoaWxkcmVuLnB1c2goaWNvbik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9wcmV2U2V0dGluZ3MuaWNvbiA9IGljb247XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuaXNEaXJ0eShcImxhYmVsXCIpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHByZXZpb3VzID0gdGhpcy5fcHJldlNldHRpbmdzLmxhYmVsO1xyXG4gICAgICAgICAgICBjb25zdCBsYWJlbCA9IHRoaXMuZ2V0KFwibGFiZWxcIik7XHJcbiAgICAgICAgICAgIGlmIChsYWJlbCAhPT0gcHJldmlvdXMpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2Rpc3Bvc2VQcm9wZXJ0eShcImxhYmVsXCIpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHByZXZpb3VzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJldmlvdXMuZGlzcG9zZSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGlsZHJlbi5wdXNoKGxhYmVsKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuX3ByZXZTZXR0aW5ncy5sYWJlbCA9IGxhYmVsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShCdXR0b24sIFwiY2xhc3NOYW1lXCIsIHtcclxuICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgIHZhbHVlOiBcIkJ1dHRvblwiXHJcbn0pO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQnV0dG9uLCBcImNsYXNzTmFtZXNcIiwge1xyXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgdmFsdWU6IENvbnRhaW5lci5jbGFzc05hbWVzLmNvbmNhdChbQnV0dG9uLmNsYXNzTmFtZV0pXHJcbn0pO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1CdXR0b24uanMubWFwIiwiaW1wb3J0IHsgQ29udGFpbmVyIH0gZnJvbSBcIi4uLy4uL2NvcmUvcmVuZGVyL0NvbnRhaW5lclwiO1xyXG5pbXBvcnQgeyBwMTAwIH0gZnJvbSBcIi4uLy4uL2NvcmUvdXRpbC9QZXJjZW50XCI7XHJcbi8qKlxyXG4gKiBBIGJhc2UgY2xhc3MgZm9yIGFsbCBjaGFydHMuXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgQ2hhcnQgZXh0ZW5kcyBDb250YWluZXIge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBIFtbQ29udGFpbmVyXV0gY2hhcnQgcGxhY2VzIGl0cyBlbGVtZW50cyBpbi5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBkZWZhdWx0IENvbnRhaW5lci5uZXcoKVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNoYXJ0Q29udGFpbmVyXCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IHRoaXMuY2hpbGRyZW4ucHVzaChDb250YWluZXIubmV3KHRoaXMuX3Jvb3QsIHsgd2lkdGg6IHAxMDAsIGhlaWdodDogcDEwMCwgaW50ZXJhY3RpdmVDaGlsZHJlbjogZmFsc2UgfSkpXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQSBbW0NvbnRhaW5lcl1dIGNoYXJ0IHBsYWNlcyBpdHMgYnVsbGV0cyBpbi5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBkZWZhdWx0IENvbnRhaW5lci5uZXcoKVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImJ1bGxldHNDb250YWluZXJcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogQ29udGFpbmVyLm5ldyh0aGlzLl9yb290LCB7IGludGVyYWN0aXZlQ2hpbGRyZW46IGZhbHNlLCBpc01lYXN1cmVkOiBmYWxzZSwgcG9zaXRpb246IFwiYWJzb2x1dGVcIiwgd2lkdGg6IHAxMDAsIGhlaWdodDogcDEwMCB9KVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShDaGFydCwgXCJjbGFzc05hbWVcIiwge1xyXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgdmFsdWU6IFwiQ2hhcnRcIlxyXG59KTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KENoYXJ0LCBcImNsYXNzTmFtZXNcIiwge1xyXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgdmFsdWU6IENvbnRhaW5lci5jbGFzc05hbWVzLmNvbmNhdChbQ2hhcnQuY2xhc3NOYW1lXSlcclxufSk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNoYXJ0LmpzLm1hcCIsImltcG9ydCB7IEdyYXBoaWNzIH0gZnJvbSBcIi4vR3JhcGhpY3NcIjtcclxuLyoqXHJcbiAqIERyYXdzIGEgY2lyY2xlLlxyXG4gKlxyXG4gKiBAc2VlIHtAbGluayBodHRwczovL3d3dy5hbWNoYXJ0cy5jb20vZG9jcy92NS9jb25jZXB0cy9jb21tb24tZWxlbWVudHMvZ3JhcGhpY3MvfSBmb3IgbW9yZSBpbmZvXHJcbiAqIEBpbXBvcnRhbnRcclxuICovXHJcbmV4cG9ydCBjbGFzcyBDaXJjbGUgZXh0ZW5kcyBHcmFwaGljcyB7XHJcbiAgICBfYWZ0ZXJOZXcoKSB7XHJcbiAgICAgICAgc3VwZXIuX2FmdGVyTmV3KCk7XHJcbiAgICAgICAgdGhpcy5fZGlzcGxheS5pc01lYXN1cmVkID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLnNldFByaXZhdGVSYXcoXCJ0cnVzdEJvdW5kc1wiLCB0cnVlKTtcclxuICAgIH1cclxuICAgIF9iZWZvcmVDaGFuZ2VkKCkge1xyXG4gICAgICAgIHN1cGVyLl9iZWZvcmVDaGFuZ2VkKCk7XHJcbiAgICAgICAgaWYgKHRoaXMuaXNEaXJ0eShcInJhZGl1c1wiKSkge1xyXG4gICAgICAgICAgICB0aGlzLl9jbGVhciA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgX2NoYW5nZWQoKSB7XHJcbiAgICAgICAgc3VwZXIuX2NoYW5nZWQoKTtcclxuICAgICAgICBpZiAodGhpcy5fY2xlYXIpIHtcclxuICAgICAgICAgICAgdGhpcy5fZGlzcGxheS5kcmF3Q2lyY2xlKDAsIDAsIHRoaXMuZ2V0KFwicmFkaXVzXCIsIDEwKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShDaXJjbGUsIFwiY2xhc3NOYW1lXCIsIHtcclxuICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgIHZhbHVlOiBcIkNpcmNsZVwiXHJcbn0pO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQ2lyY2xlLCBcImNsYXNzTmFtZXNcIiwge1xyXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgdmFsdWU6IEdyYXBoaWNzLmNsYXNzTmFtZXMuY29uY2F0KFtDaXJjbGUuY2xhc3NOYW1lXSlcclxufSk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNpcmNsZS5qcy5tYXAiLCJpbXBvcnQgeyBfX2F3YWl0ZXIgfSBmcm9tIFwidHNsaWJcIjtcclxuaW1wb3J0IHsgU2V0dGluZ3MgfSBmcm9tIFwiLi4vdXRpbC9FbnRpdHlcIjtcclxuaW1wb3J0IHsgQ29udGFpbmVyIH0gZnJvbSBcIi4vQ29udGFpbmVyXCI7XHJcbmltcG9ydCB7IExpc3REYXRhIH0gZnJvbSBcIi4uL3V0aWwvRGF0YVwiO1xyXG5pbXBvcnQgKiBhcyAkYXJyYXkgZnJvbSBcIi4uL3V0aWwvQXJyYXlcIjtcclxuaW1wb3J0ICogYXMgJG9iamVjdCBmcm9tIFwiLi4vdXRpbC9PYmplY3RcIjtcclxuLyoqXHJcbiAqIEEgYmFzZSBlbGVtZW50IHRoYXQgaG9sZHMgZGF0YSBiaXQgKGRhdGEgaXRlbSkgZm9yIGFueSBbW0NvbXBvbmVudF1dLlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIERhdGFJdGVtIGV4dGVuZHMgU2V0dGluZ3Mge1xyXG4gICAgY29uc3RydWN0b3IoY29tcG9uZW50LCBkYXRhQ29udGV4dCwgc2V0dGluZ3MpIHtcclxuICAgICAgICBzdXBlcihzZXR0aW5ncyk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQSBkYXRhIGl0ZW0ncyBvd2VuZXIgW1tDb21wb25lbnRdXS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJjb21wb25lbnRcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQSByZWZlcmVuY2UgdG8gYWN0dWFsIGl0ZW0gaW4gc291cmNlIGRhdGEgdGhpcyBpdGVtIGlzIGJhc2VkIG9uLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImRhdGFDb250ZXh0XCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEB0b2RvIHJlcXVpcmVzIGRlc2NyaXB0aW9uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiYnVsbGV0c1wiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcclxuICAgICAgICB9KTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBIHNldCBvZiBcIm9wZW5cIiB2YWx1ZXMuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwib3BlblwiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcclxuICAgICAgICB9KTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBIHNldCBvZiBcImNsb3NlXCIgdmFsdWVzLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNsb3NlXCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuZGF0YUNvbnRleHQgPSBkYXRhQ29udGV4dDtcclxuICAgICAgICB0aGlzLmNvbXBvbmVudCA9IGNvbXBvbmVudDtcclxuICAgICAgICB0aGlzLl9zZXR0aW5ncy52aXNpYmxlID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLl9jaGVja0RpcnR5KCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEBpZ25vcmVcclxuICAgICAqL1xyXG4gICAgbWFya0RpcnR5KCkge1xyXG4gICAgICAgIHRoaXMuY29tcG9uZW50Lm1hcmtEaXJ0eVZhbHVlcyh0aGlzKTtcclxuICAgIH1cclxuICAgIF9zdGFydEFuaW1hdGlvbigpIHtcclxuICAgICAgICB0aGlzLmNvbXBvbmVudC5fcm9vdC5fYWRkQW5pbWF0aW9uKHRoaXMpO1xyXG4gICAgfVxyXG4gICAgX2FuaW1hdGlvblRpbWUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcG9uZW50Ll9yb290LmFuaW1hdGlvblRpbWU7XHJcbiAgICB9XHJcbiAgICBfZGlzcG9zZSgpIHtcclxuICAgICAgICBpZiAodGhpcy5jb21wb25lbnQpIHtcclxuICAgICAgICAgICAgdGhpcy5jb21wb25lbnQuZGlzcG9zZURhdGFJdGVtKHRoaXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzdXBlci5fZGlzcG9zZSgpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTaG93cyBhIGRhdGEgaXRlbSB0aGF0J3MgY3VycmVudGx5IGhpZGRlbi5cclxuICAgICAqL1xyXG4gICAgc2hvdyhkdXJhdGlvbikge1xyXG4gICAgICAgIHRoaXMuc2V0UmF3KFwidmlzaWJsZVwiLCB0cnVlKTtcclxuICAgICAgICBpZiAodGhpcy5jb21wb25lbnQpIHtcclxuICAgICAgICAgICAgdGhpcy5jb21wb25lbnQuc2hvd0RhdGFJdGVtKHRoaXMsIGR1cmF0aW9uKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEhpZGVzIGEgZGF0YSBpdGVtIHRoYXQncyBjdXJyZW50bHkgdmlzaWJsZS5cclxuICAgICAqL1xyXG4gICAgaGlkZShkdXJhdGlvbikge1xyXG4gICAgICAgIHRoaXMuc2V0UmF3KFwidmlzaWJsZVwiLCBmYWxzZSk7XHJcbiAgICAgICAgaWYgKHRoaXMuY29tcG9uZW50KSB7XHJcbiAgICAgICAgICAgIHRoaXMuY29tcG9uZW50LmhpZGVEYXRhSXRlbSh0aGlzLCBkdXJhdGlvbik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaXNIaWRkZW4oKSB7XHJcbiAgICAgICAgcmV0dXJuICF0aGlzLmdldChcInZpc2libGVcIik7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEEgYmFzZSBjbGFzcyBmb3IgZWxlbWVudHMgdGhhdCBtYWtlIHVzZSBvZiBkYXRhLlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIENvbXBvbmVudCBleHRlbmRzIENvbnRhaW5lciB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9kYXRhXCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IG5ldyBMaXN0RGF0YSgpXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX2RhdGFJdGVtc1wiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiBbXVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9tYWluRGF0YUl0ZW1zXCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IHRoaXMuX2RhdGFJdGVtc1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInZhbHVlRmllbGRzXCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IFtdXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZmllbGRzXCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IFtcImlkXCJdXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX3ZhbHVlRmllbGRzXCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl92YWx1ZUZpZWxkc0ZcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX2ZpZWxkc1wiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfZmllbGRzRlwiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfdmFsdWVzRGlydHlcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogZmFsc2VcclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfZGF0YUNoYW5nZWRcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogZmFsc2VcclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfZGF0YUdyb3VwZWRcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogZmFsc2VcclxuICAgICAgICB9KTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBJbmRpY2F0ZXMgaWYgdGhlIGNvbXBvbmVudCBoYXMgYWxyZWFkeSBiZWVuIGluaXRpYWxpemVkLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImluaXRlZFwiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiBmYWxzZVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDb21wb25lbnQncyBkYXRhLlxyXG4gICAgICpcclxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vd3d3LmFtY2hhcnRzLmNvbS9kb2NzL3Y1L2NvbmNlcHRzL2RhdGEvfSBmb3IgbW9yZSBpbmZvXHJcbiAgICAgKi9cclxuICAgIHNldCBkYXRhKGRhdGEpIHtcclxuICAgICAgICBkYXRhLmluY3JlbWVudFJlZigpO1xyXG4gICAgICAgIHRoaXMuX2RhdGEuZGVjcmVtZW50UmVmKCk7XHJcbiAgICAgICAgdGhpcy5fZGF0YSA9IGRhdGE7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm4gIERhdGFcclxuICAgICAqL1xyXG4gICAgZ2V0IGRhdGEoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGE7XHJcbiAgICB9XHJcbiAgICBfZGlzcG9zZSgpIHtcclxuICAgICAgICBzdXBlci5fZGlzcG9zZSgpO1xyXG4gICAgICAgIHRoaXMuX2RhdGEuZGVjcmVtZW50UmVmKCk7XHJcbiAgICB9XHJcbiAgICBfb25EYXRhQ2xlYXIoKSB7XHJcbiAgICB9XHJcbiAgICBfYWZ0ZXJOZXcoKSB7XHJcbiAgICAgICAgc3VwZXIuX2FmdGVyTmV3KCk7XHJcbiAgICAgICAgdGhpcy5fZGF0YS5pbmNyZW1lbnRSZWYoKTtcclxuICAgICAgICB0aGlzLl91cGRhdGVGaWVsZHMoKTtcclxuICAgICAgICB0aGlzLl9kaXNwb3NlcnMucHVzaCh0aGlzLmRhdGEuZXZlbnRzLm9uQWxsKChjaGFuZ2UpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgZGF0YUl0ZW1zID0gdGhpcy5fbWFpbkRhdGFJdGVtcztcclxuICAgICAgICAgICAgdGhpcy5tYXJrRGlydHlWYWx1ZXMoKTtcclxuICAgICAgICAgICAgdGhpcy5fbWFya0RpcnR5R3JvdXAoKTtcclxuICAgICAgICAgICAgdGhpcy5fZGF0YUNoYW5nZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICBpZiAoY2hhbmdlLnR5cGUgPT09IFwiY2xlYXJcIikge1xyXG4gICAgICAgICAgICAgICAgJGFycmF5LmVhY2goZGF0YUl0ZW1zLCAoZGF0YUl0ZW0pID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBkYXRhSXRlbS5kaXNwb3NlKCk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIGRhdGFJdGVtcy5sZW5ndGggPSAwO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fb25EYXRhQ2xlYXIoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChjaGFuZ2UudHlwZSA9PT0gXCJwdXNoXCIpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGFJdGVtID0gbmV3IERhdGFJdGVtKHRoaXMsIGNoYW5nZS5uZXdWYWx1ZSwgdGhpcy5fbWFrZURhdGFJdGVtKGNoYW5nZS5uZXdWYWx1ZSkpO1xyXG4gICAgICAgICAgICAgICAgZGF0YUl0ZW1zLnB1c2goZGF0YUl0ZW0pO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wcm9jZXNzRGF0YUl0ZW0oZGF0YUl0ZW0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGNoYW5nZS50eXBlID09PSBcInNldEluZGV4XCIpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGFJdGVtID0gZGF0YUl0ZW1zW2NoYW5nZS5pbmRleF07XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwcm9wZXJ0aWVzID0gdGhpcy5fbWFrZURhdGFJdGVtKGNoYW5nZS5uZXdWYWx1ZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoZGF0YUl0ZW0uYnVsbGV0cyAmJiBkYXRhSXRlbS5idWxsZXRzLmxlbmd0aCA9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YUl0ZW0uYnVsbGV0cyA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICRvYmplY3Qua2V5cyhwcm9wZXJ0aWVzKS5mb3JFYWNoKChrZXkpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBkYXRhSXRlbS5hbmltYXRlKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAga2V5OiBrZXksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvOiBwcm9wZXJ0aWVzW2tleV0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmdldChcImludGVycG9sYXRpb25EdXJhdGlvblwiLCAwKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWFzaW5nOiB0aGlzLmdldChcImludGVycG9sYXRpb25FYXNpbmdcIiksXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIGRhdGFJdGVtLmRhdGFDb250ZXh0ID0gY2hhbmdlLm5ld1ZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGNoYW5nZS50eXBlID09PSBcImluc2VydEluZGV4XCIpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGFJdGVtID0gbmV3IERhdGFJdGVtKHRoaXMsIGNoYW5nZS5uZXdWYWx1ZSwgdGhpcy5fbWFrZURhdGFJdGVtKGNoYW5nZS5uZXdWYWx1ZSkpO1xyXG4gICAgICAgICAgICAgICAgZGF0YUl0ZW1zLnNwbGljZShjaGFuZ2UuaW5kZXgsIDAsIGRhdGFJdGVtKTtcclxuICAgICAgICAgICAgICAgIHRoaXMucHJvY2Vzc0RhdGFJdGVtKGRhdGFJdGVtKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChjaGFuZ2UudHlwZSA9PT0gXCJyZW1vdmVJbmRleFwiKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBkYXRhSXRlbSA9IGRhdGFJdGVtc1tjaGFuZ2UuaW5kZXhdO1xyXG4gICAgICAgICAgICAgICAgZGF0YUl0ZW0uZGlzcG9zZSgpO1xyXG4gICAgICAgICAgICAgICAgZGF0YUl0ZW1zLnNwbGljZShjaGFuZ2UuaW5kZXgsIDEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGNoYW5nZS50eXBlID09PSBcIm1vdmVJbmRleFwiKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBkYXRhSXRlbSA9IGRhdGFJdGVtc1tjaGFuZ2Uub2xkSW5kZXhdO1xyXG4gICAgICAgICAgICAgICAgZGF0YUl0ZW1zLnNwbGljZShjaGFuZ2Uub2xkSW5kZXgsIDEpO1xyXG4gICAgICAgICAgICAgICAgZGF0YUl0ZW1zLnNwbGljZShjaGFuZ2UubmV3SW5kZXgsIDAsIGRhdGFJdGVtKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gSVN0cmVhbUV2ZW50IHR5cGVcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fYWZ0ZXJEYXRhQ2hhbmdlKCk7XHJcbiAgICAgICAgfSkpO1xyXG4gICAgfVxyXG4gICAgX3VwZGF0ZUZpZWxkcygpIHtcclxuICAgICAgICBpZiAodGhpcy52YWx1ZUZpZWxkcykge1xyXG4gICAgICAgICAgICB0aGlzLl92YWx1ZUZpZWxkcyA9IFtdO1xyXG4gICAgICAgICAgICB0aGlzLl92YWx1ZUZpZWxkc0YgPSB7fTtcclxuICAgICAgICAgICAgJGFycmF5LmVhY2godGhpcy52YWx1ZUZpZWxkcywgKGtleSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZmllbGQgPSB0aGlzLmdldCgoa2V5ICsgXCJGaWVsZFwiKSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoZmllbGQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl92YWx1ZUZpZWxkcy5wdXNoKGtleSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdmFsdWVGaWVsZHNGW2tleV0gPSB7IGZpZWxkS2V5OiBrZXkgKyBcIkZpZWxkXCIsIHdvcmtpbmdLZXk6IGtleSArIFwiV29ya2luZ1wiIH07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5maWVsZHMpIHtcclxuICAgICAgICAgICAgdGhpcy5fZmllbGRzID0gW107XHJcbiAgICAgICAgICAgIHRoaXMuX2ZpZWxkc0YgPSB7fTtcclxuICAgICAgICAgICAgJGFycmF5LmVhY2godGhpcy5maWVsZHMsIChrZXkpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGZpZWxkID0gdGhpcy5nZXQoKGtleSArIFwiRmllbGRcIikpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGZpZWxkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZmllbGRzLnB1c2goa2V5KTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9maWVsZHNGW2tleV0gPSBrZXkgKyBcIkZpZWxkXCI7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQSBsaXN0IG9mIGNvbXBvbmVudCdzIGRhdGEgaXRlbXMuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybiAgRGF0YSBpdGVtc1xyXG4gICAgICovXHJcbiAgICBnZXQgZGF0YUl0ZW1zKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9kYXRhSXRlbXM7XHJcbiAgICB9XHJcbiAgICBwcm9jZXNzRGF0YUl0ZW0oX2RhdGFJdGVtKSB7IH1cclxuICAgIF9tYWtlRGF0YUl0ZW0oZGF0YSkge1xyXG4gICAgICAgIC8vY29uc3Qgb3V0cHV0OiB0aGlzW1wiX2RhdGFJdGVtU2V0dGluZ3NcIl0gPSB7fTtcclxuICAgICAgICBjb25zdCBvdXRwdXQgPSB7fTsgLy8gdGVtcG9yYXJ5IHRvIHNvbHZlIGVycm9yXHJcbiAgICAgICAgaWYgKHRoaXMuX3ZhbHVlRmllbGRzKSB7XHJcbiAgICAgICAgICAgICRhcnJheS5lYWNoKHRoaXMuX3ZhbHVlRmllbGRzLCAoa2V5KSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBmaWVsZCA9IHRoaXMuZ2V0KCh0aGlzLl92YWx1ZUZpZWxkc0Zba2V5XS5maWVsZEtleSkpO1xyXG4gICAgICAgICAgICAgICAgb3V0cHV0W2tleV0gPSBkYXRhW2ZpZWxkXTtcclxuICAgICAgICAgICAgICAgIG91dHB1dFt0aGlzLl92YWx1ZUZpZWxkc0Zba2V5XS53b3JraW5nS2V5XSA9IG91dHB1dFtrZXldO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuX2ZpZWxkcykge1xyXG4gICAgICAgICAgICAkYXJyYXkuZWFjaCh0aGlzLl9maWVsZHMsIChrZXkpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGZpZWxkID0gdGhpcy5nZXQoKHRoaXMuX2ZpZWxkc0Zba2V5XSkpO1xyXG4gICAgICAgICAgICAgICAgb3V0cHV0W2tleV0gPSBkYXRhW2ZpZWxkXTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBvdXRwdXQ7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEBpZ25vcmVcclxuICAgICAqL1xyXG4gICAgbWFrZURhdGFJdGVtKGRhdGEpIHtcclxuICAgICAgICBsZXQgZGF0YUl0ZW0gPSBuZXcgRGF0YUl0ZW0odGhpcywgdW5kZWZpbmVkLCBkYXRhKTtcclxuICAgICAgICB0aGlzLnByb2Nlc3NEYXRhSXRlbShkYXRhSXRlbSk7XHJcbiAgICAgICAgcmV0dXJuIGRhdGFJdGVtO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAaWdub3JlXHJcbiAgICAgKi9cclxuICAgIHB1c2hEYXRhSXRlbShkYXRhKSB7XHJcbiAgICAgICAgY29uc3QgZGF0YUl0ZW0gPSB0aGlzLm1ha2VEYXRhSXRlbShkYXRhKTtcclxuICAgICAgICB0aGlzLl9tYWluRGF0YUl0ZW1zLnB1c2goZGF0YUl0ZW0pO1xyXG4gICAgICAgIHJldHVybiBkYXRhSXRlbTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQGlnbm9yZVxyXG4gICAgICovXHJcbiAgICBkaXNwb3NlRGF0YUl0ZW0oX2RhdGFJdGVtKSB7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNob3dzIGNvbXBvbmVudCdzIGRhdGEgaXRlbS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gICBkYXRhSXRlbSAgIERhdGEgaXRlbVxyXG4gICAgICogQHBhcmFtICAgX2R1cmF0aW9uICBBbmltYXRpb24gZHVyYXRpb24gaW4gbWlsbGlzZWNvbmRzXHJcbiAgICAgKiBAcmV0dXJuICAgICAgICAgICAgIFByb21pc2VcclxuICAgICAqL1xyXG4gICAgc2hvd0RhdGFJdGVtKGRhdGFJdGVtLCBfZHVyYXRpb24pIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICBkYXRhSXRlbS5zZXQoXCJ2aXNpYmxlXCIsIHRydWUpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBIaWRlcyBjb21wb25lbnQncyBkYXRhIGl0ZW0uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtICAgZGF0YUl0ZW0gICBEYXRhIGl0ZW1cclxuICAgICAqIEBwYXJhbSAgIF9kdXJhdGlvbiAgQW5pbWF0aW9uIGR1cmF0aW9uIGluIG1pbGxpc2Vjb25kc1xyXG4gICAgICogQHJldHVybiAgICAgICAgICAgICBQcm9taXNlXHJcbiAgICAgKi9cclxuICAgIGhpZGVEYXRhSXRlbShkYXRhSXRlbSwgX2R1cmF0aW9uKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgZGF0YUl0ZW0uc2V0KFwidmlzaWJsZVwiLCBmYWxzZSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBfY2xlYXJEaXJ0eSgpIHtcclxuICAgICAgICBzdXBlci5fY2xlYXJEaXJ0eSgpO1xyXG4gICAgICAgIHRoaXMuX3ZhbHVlc0RpcnR5ID0gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBfYWZ0ZXJEYXRhQ2hhbmdlKCkge1xyXG4gICAgfVxyXG4gICAgX2FmdGVyQ2hhbmdlZCgpIHtcclxuICAgICAgICBzdXBlci5fYWZ0ZXJDaGFuZ2VkKCk7XHJcbiAgICAgICAgaWYgKHRoaXMuX2RhdGFDaGFuZ2VkKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHR5cGUgPSBcImRhdGF2YWxpZGF0ZWRcIjtcclxuICAgICAgICAgICAgaWYgKHRoaXMuZXZlbnRzLmlzRW5hYmxlZCh0eXBlKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ldmVudHMuZGlzcGF0Y2godHlwZSwgeyB0eXBlOiB0eXBlLCB0YXJnZXQ6IHRoaXMgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fZGF0YUNoYW5nZWQgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5pbml0ZWQgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBGb3JjZXMgYSByZXBhaW50IG9mIHRoZSBlbGVtZW50IHdoaWNoIHJlbGllcyBvbiBkYXRhLlxyXG4gICAgICpcclxuICAgICAqIEBzaW5jZSA1LjAuMjFcclxuICAgICAqL1xyXG4gICAgbWFya0RpcnR5VmFsdWVzKF9kYXRhSXRlbSkge1xyXG4gICAgICAgIHRoaXMubWFya0RpcnR5KCk7XHJcbiAgICAgICAgdGhpcy5fdmFsdWVzRGlydHkgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgX21hcmtEaXJ0eUdyb3VwKCkge1xyXG4gICAgICAgIHRoaXMuX2RhdGFHcm91cGVkID0gZmFsc2U7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEBpZ25vcmVcclxuICAgICAqL1xyXG4gICAgbWFya0RpcnR5U2l6ZSgpIHtcclxuICAgICAgICB0aGlzLl9zaXplRGlydHkgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMubWFya0RpcnR5KCk7XHJcbiAgICB9XHJcbn1cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbXBvbmVudCwgXCJjbGFzc05hbWVcIiwge1xyXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgdmFsdWU6IFwiQ29tcG9uZW50XCJcclxufSk7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb21wb25lbnQsIFwiY2xhc3NOYW1lc1wiLCB7XHJcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICB2YWx1ZTogQ29udGFpbmVyLmNsYXNzTmFtZXMuY29uY2F0KFtDb21wb25lbnQuY2xhc3NOYW1lXSlcclxufSk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNvbXBvbmVudC5qcy5tYXAiLCJpbXBvcnQgeyBDaGlsZHJlbiB9IGZyb20gXCIuLi91dGlsL0NoaWxkcmVuXCI7XHJcbmltcG9ydCB7IFBlcmNlbnQgfSBmcm9tIFwiLi4vdXRpbC9QZXJjZW50XCI7XHJcbmltcG9ydCB7IFNwcml0ZSB9IGZyb20gXCIuL1Nwcml0ZVwiO1xyXG5pbXBvcnQgeyBSZWN0YW5nbGUgfSBmcm9tIFwiLi9SZWN0YW5nbGVcIjtcclxuaW1wb3J0IHsgSG9yaXpvbnRhbExheW91dCB9IGZyb20gXCIuL0hvcml6b250YWxMYXlvdXRcIjtcclxuaW1wb3J0IHsgVmVydGljYWxMYXlvdXQgfSBmcm9tIFwiLi9WZXJ0aWNhbExheW91dFwiO1xyXG5pbXBvcnQgeyBHcmlkTGF5b3V0IH0gZnJvbSBcIi4vR3JpZExheW91dFwiO1xyXG5pbXBvcnQgeyBwb3B1bGF0ZVN0cmluZyB9IGZyb20gXCIuLi91dGlsL1BvcHVsYXRlU3RyaW5nXCI7XHJcbmltcG9ydCAqIGFzICRhcnJheSBmcm9tIFwiLi4vdXRpbC9BcnJheVwiO1xyXG5pbXBvcnQgKiBhcyAkdHlwZSBmcm9tIFwiLi4vdXRpbC9UeXBlXCI7XHJcbmltcG9ydCAqIGFzICR1dGlscyBmcm9tIFwiLi4vdXRpbC9VdGlsc1wiO1xyXG4vKipcclxuICogQSBiYXNpYyBlbGVtZW50IHRoYXQgY2FuIGhhdmUgY2hpbGQgZWxlbWVudHMsIG1haW50YWluIHRoZWlyIGxheW91dCwgYW5kXHJcbiAqIGhhdmUgYSBiYWNrZ3JvdW5kLlxyXG4gKlxyXG4gKiBJdCBjYW4gaGF2ZSBhbnkgW1tTcHJpdGVdXSBlbGVtZW50IGFzIGEgY2hpbGQsIGZyb20gdmVyeSBiYXNpYyBzaGFwZXMsIHRvXHJcbiAqIGZ1bGwtZmxlZGdlZCBjaGFydHMuXHJcbiAqXHJcbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vd3d3LmFtY2hhcnRzLmNvbS9kb2NzL3Y1L2NvbmNlcHRzL2NvbW1vbi1lbGVtZW50cy9jb250YWluZXJzL30gZm9yIG1vcmUgaW5mb1xyXG4gKiBAaW1wb3J0YW50XHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgQ29udGFpbmVyIGV4dGVuZHMgU3ByaXRlIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX2Rpc3BsYXlcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogdGhpcy5fcm9vdC5fcmVuZGVyZXIubWFrZUNvbnRhaW5lcigpXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX2NoaWxkcmVuRGlzcGxheVwiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiB0aGlzLl9yb290Ll9yZW5kZXJlci5tYWtlQ29udGFpbmVyKClcclxuICAgICAgICB9KTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBMaXN0IG9mIENvbnRhaW5lcidzIGNoaWxkIGVsZW1lbnRzLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNoaWxkcmVuXCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IG5ldyBDaGlsZHJlbih0aGlzKVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9wZXJjZW50YWdlU2l6ZUNoaWxkcmVuXCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IFtdXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX3BlcmNlbnRhZ2VQb3NpdGlvbkNoaWxkcmVuXCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IFtdXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX3ByZXZXaWR0aFwiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiAwXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX3ByZXZIZWlnaHRcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogMFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9jb250ZW50V2lkdGhcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogMFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9jb250ZW50SGVpZ2h0XCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IDBcclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfY29udGVudE1hc2tcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX3ZzYmQwXCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl92c2JkMVwiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIF9hZnRlck5ldygpIHtcclxuICAgICAgICBzdXBlci5fYWZ0ZXJOZXcoKTtcclxuICAgICAgICB0aGlzLl9kaXNwbGF5LmFkZENoaWxkKHRoaXMuX2NoaWxkcmVuRGlzcGxheSk7XHJcbiAgICB9XHJcbiAgICBfZGlzcG9zZSgpIHtcclxuICAgICAgICAkYXJyYXkuZWFjaFJldmVyc2UodGhpcy5hbGxDaGlsZHJlbigpLCAoY2hpbGQpID0+IHtcclxuICAgICAgICAgICAgY2hpbGQuZGlzcG9zZSgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGlmICh0aGlzLmdldFByaXZhdGUoXCJodG1sRWxlbWVudFwiKSkge1xyXG4gICAgICAgICAgICB0aGlzLl9yb290Ll9yZW1vdmVIVE1MQ29udGVudCh0aGlzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgc3VwZXIuX2Rpc3Bvc2UoKTtcclxuICAgIH1cclxuICAgIF9jaGFuZ2VkKCkge1xyXG4gICAgICAgIHN1cGVyLl9jaGFuZ2VkKCk7XHJcbiAgICAgICAgaWYgKHRoaXMuaXNEaXJ0eShcImludGVyYWN0aXZlQ2hpbGRyZW5cIikpIHtcclxuICAgICAgICAgICAgdGhpcy5fZGlzcGxheS5pbnRlcmFjdGl2ZUNoaWxkcmVuID0gdGhpcy5nZXQoXCJpbnRlcmFjdGl2ZUNoaWxkcmVuXCIsIGZhbHNlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuaXNEaXJ0eShcImxheW91dFwiKSkge1xyXG4gICAgICAgICAgICB0aGlzLl9wcmV2V2lkdGggPSAwO1xyXG4gICAgICAgICAgICB0aGlzLl9wcmV2SGVpZ2h0ID0gMDtcclxuICAgICAgICAgICAgdGhpcy5tYXJrRGlydHlCb3VuZHMoKTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX3ByZXZTZXR0aW5ncy5sYXlvdXQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY2hpbGRyZW4uZWFjaCgoY2hpbGQpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBjaGlsZC5yZW1vdmVQcml2YXRlKFwieFwiKTtcclxuICAgICAgICAgICAgICAgICAgICBjaGlsZC5yZW1vdmVQcml2YXRlKFwieVwiKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmlzRGlydHkoXCJwYWRkaW5nVG9wXCIpIHx8IHRoaXMuaXNEaXJ0eShcInBhZGRpbmdCb3R0b21cIikgfHwgdGhpcy5pc0RpcnR5KFwicGFkZGluZ0xlZnRcIikgfHwgdGhpcy5pc0RpcnR5KFwicGFkZGluZ1JpZ2h0XCIpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY2hpbGRyZW4uZWFjaCgoY2hpbGQpID0+IHtcclxuICAgICAgICAgICAgICAgIGNoaWxkLm1hcmtEaXJ0eVBvc2l0aW9uKCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5pc0RpcnR5KFwibWFza0NvbnRlbnRcIikpIHtcclxuICAgICAgICAgICAgY29uc3QgY2hpbGRyZW5EaXNwbGF5ID0gdGhpcy5fY2hpbGRyZW5EaXNwbGF5O1xyXG4gICAgICAgICAgICBsZXQgY29udGVudE1hc2sgPSB0aGlzLl9jb250ZW50TWFzaztcclxuICAgICAgICAgICAgaWYgKHRoaXMuZ2V0KFwibWFza0NvbnRlbnRcIikpIHtcclxuICAgICAgICAgICAgICAgIGlmICghY29udGVudE1hc2spIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250ZW50TWFzayA9IFJlY3RhbmdsZS5uZXcodGhpcy5fcm9vdCwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB4OiAtLjUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHk6IC0uNSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IHRoaXMud2lkdGgoKSArIDEsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogdGhpcy5oZWlnaHQoKSArIDFcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jb250ZW50TWFzayA9IGNvbnRlbnRNYXNrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuRGlzcGxheS5hZGRDaGlsZEF0KGNvbnRlbnRNYXNrLl9kaXNwbGF5LCAwKTtcclxuICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbkRpc3BsYXkubWFzayA9IGNvbnRlbnRNYXNrLl9kaXNwbGF5O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWYgKGNvbnRlbnRNYXNrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW5EaXNwbGF5LnJlbW92ZUNoaWxkKGNvbnRlbnRNYXNrLl9kaXNwbGF5KTtcclxuICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbkRpc3BsYXkubWFzayA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGVudE1hc2suZGlzcG9zZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NvbnRlbnRNYXNrID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgX3VwZGF0ZVNpemUoKSB7XHJcbiAgICAgICAgc3VwZXIuX3VwZGF0ZVNpemUoKTtcclxuICAgICAgICAkYXJyYXkuZWFjaCh0aGlzLl9wZXJjZW50YWdlU2l6ZUNoaWxkcmVuLCAoY2hpbGQpID0+IHtcclxuICAgICAgICAgICAgY2hpbGQuX3VwZGF0ZVNpemUoKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICAkYXJyYXkuZWFjaCh0aGlzLl9wZXJjZW50YWdlUG9zaXRpb25DaGlsZHJlbiwgKGNoaWxkKSA9PiB7XHJcbiAgICAgICAgICAgIGNoaWxkLm1hcmtEaXJ0eVBvc2l0aW9uKCk7XHJcbiAgICAgICAgICAgIGNoaWxkLl91cGRhdGVTaXplKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy51cGRhdGVCYWNrZ3JvdW5kKCk7XHJcbiAgICB9XHJcbiAgICB1cGRhdGVCYWNrZ3JvdW5kKCkge1xyXG4gICAgICAgIGNvbnN0IGJhY2tncm91bmQgPSB0aGlzLmdldChcImJhY2tncm91bmRcIik7XHJcbiAgICAgICAgbGV0IGJvdW5kcyA9IHRoaXMuX2xvY2FsQm91bmRzO1xyXG4gICAgICAgIGlmIChib3VuZHMgJiYgIXRoaXMuaXNIaWRkZW4oKSkge1xyXG4gICAgICAgICAgICBsZXQgeCA9IGJvdW5kcy5sZWZ0O1xyXG4gICAgICAgICAgICBsZXQgeSA9IGJvdW5kcy50b3A7XHJcbiAgICAgICAgICAgIGxldCB3ID0gYm91bmRzLnJpZ2h0IC0geDtcclxuICAgICAgICAgICAgbGV0IGggPSBib3VuZHMuYm90dG9tIC0geTtcclxuICAgICAgICAgICAgbGV0IG1heFdpZHRoID0gdGhpcy5nZXQoXCJtYXhXaWR0aFwiKTtcclxuICAgICAgICAgICAgbGV0IG1heEhlaWdodCA9IHRoaXMuZ2V0KFwibWF4SGVpZ2h0XCIpO1xyXG4gICAgICAgICAgICBpZiAobWF4SGVpZ2h0KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaCA+IG1heEhlaWdodCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGggPSBtYXhIZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKG1heFdpZHRoKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodyA+IG1heFdpZHRoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdyA9IG1heFdpZHRoO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGxldCB3aWR0aCA9IHRoaXMud2lkdGgoKTtcclxuICAgICAgICAgICAgbGV0IGhlaWdodCA9IHRoaXMuaGVpZ2h0KCk7XHJcbiAgICAgICAgICAgIGlmIChiYWNrZ3JvdW5kKSB7XHJcbiAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kLnNldEFsbCh7IHdpZHRoOiB3LCBoZWlnaHQ6IGgsIHg6IHgsIHk6IHkgfSk7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fZGlzcGxheS5pbnRlcmFjdGl2ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGJhY2tncm91bmQuX2Rpc3BsYXkuaW50ZXJhY3RpdmUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IGNvbnRlbnRNYXNrID0gdGhpcy5fY29udGVudE1hc2s7XHJcbiAgICAgICAgICAgIGlmIChjb250ZW50TWFzaykge1xyXG4gICAgICAgICAgICAgICAgY29udGVudE1hc2suc2V0QWxsKHsgd2lkdGg6IHdpZHRoICsgMSwgaGVpZ2h0OiBoZWlnaHQgKyAxIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IHZlcnRpY2FsU2Nyb2xsYmFyID0gdGhpcy5nZXQoXCJ2ZXJ0aWNhbFNjcm9sbGJhclwiKTtcclxuICAgICAgICAgICAgaWYgKHZlcnRpY2FsU2Nyb2xsYmFyKSB7XHJcbiAgICAgICAgICAgICAgICB2ZXJ0aWNhbFNjcm9sbGJhci5zZXQoXCJoZWlnaHRcIiwgaGVpZ2h0KTtcclxuICAgICAgICAgICAgICAgIHZlcnRpY2FsU2Nyb2xsYmFyLnNldChcInhcIiwgd2lkdGggLSB2ZXJ0aWNhbFNjcm9sbGJhci53aWR0aCgpIC0gdmVydGljYWxTY3JvbGxiYXIuZ2V0KFwibWFyZ2luUmlnaHRcIiwgMCkpO1xyXG4gICAgICAgICAgICAgICAgdmVydGljYWxTY3JvbGxiYXIuc2V0KFwiZW5kXCIsIHZlcnRpY2FsU2Nyb2xsYmFyLmdldChcInN0YXJ0XCIsIDApICsgaGVpZ2h0IC8gdGhpcy5fY29udGVudEhlaWdodCk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBiZyA9IHZlcnRpY2FsU2Nyb2xsYmFyLmdldChcImJhY2tncm91bmRcIik7XHJcbiAgICAgICAgICAgICAgICBpZiAoYmcpIHtcclxuICAgICAgICAgICAgICAgICAgICBiZy5zZXRBbGwoeyB3aWR0aDogdmVydGljYWxTY3JvbGxiYXIud2lkdGgoKSwgaGVpZ2h0OiBoZWlnaHQgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBsZXQgdmlzaWJsZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fY29udGVudEhlaWdodCA8PSBoZWlnaHQpIHtcclxuICAgICAgICAgICAgICAgICAgICB2aXNpYmxlID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2ZXJ0aWNhbFNjcm9sbGJhci5zZXRQcml2YXRlKFwidmlzaWJsZVwiLCB2aXNpYmxlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIF9hcHBseVRoZW1lcyhmb3JjZSA9IGZhbHNlKSB7XHJcbiAgICAgICAgaWYgKHN1cGVyLl9hcHBseVRoZW1lcyhmb3JjZSkpIHtcclxuICAgICAgICAgICAgdGhpcy5lYWNoQ2hpbGRyZW4oKGNoaWxkKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjaGlsZC5fYXBwbHlUaGVtZXMoZm9yY2UpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgX2FwcGx5U3RhdGUobmFtZSkge1xyXG4gICAgICAgIHN1cGVyLl9hcHBseVN0YXRlKG5hbWUpO1xyXG4gICAgICAgIGlmICh0aGlzLmdldChcInNldFN0YXRlT25DaGlsZHJlblwiKSkge1xyXG4gICAgICAgICAgICB0aGlzLmVhY2hDaGlsZHJlbigoY2hpbGQpID0+IHtcclxuICAgICAgICAgICAgICAgIGNoaWxkLnN0YXRlcy5hcHBseShuYW1lKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgX2FwcGx5U3RhdGVBbmltYXRlZChuYW1lLCBkdXJhdGlvbikge1xyXG4gICAgICAgIHN1cGVyLl9hcHBseVN0YXRlQW5pbWF0ZWQobmFtZSwgZHVyYXRpb24pO1xyXG4gICAgICAgIGlmICh0aGlzLmdldChcInNldFN0YXRlT25DaGlsZHJlblwiKSkge1xyXG4gICAgICAgICAgICB0aGlzLmVhY2hDaGlsZHJlbigoY2hpbGQpID0+IHtcclxuICAgICAgICAgICAgICAgIGNoaWxkLnN0YXRlcy5hcHBseUFuaW1hdGUobmFtZSwgZHVyYXRpb24pO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgY29udGFpbmVyJ3MgaW5uZXIgd2lkdGggKHdpZHRoIHdpdGhvdXQgcGFkZGluZykgaW4gcGl4ZWxzLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm4gSW5uZXIgd2lkdGggKHB4KVxyXG4gICAgICovXHJcbiAgICBpbm5lcldpZHRoKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLndpZHRoKCkgLSB0aGlzLmdldChcInBhZGRpbmdSaWdodFwiLCAwKSAtIHRoaXMuZ2V0KFwicGFkZGluZ0xlZnRcIiwgMCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgY29udGFpbmVyJ3MgaW5uZXIgaGVpZ2h0IChoZWlnaHQgd2l0aG91dCBwYWRkaW5nKSBpbiBwaXhlbHMuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybiBJbm5lciBoZWlnaHQgKHB4KVxyXG4gICAgICovXHJcbiAgICBpbm5lckhlaWdodCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5oZWlnaHQoKSAtIHRoaXMuZ2V0KFwicGFkZGluZ1RvcFwiLCAwKSAtIHRoaXMuZ2V0KFwicGFkZGluZ0JvdHRvbVwiLCAwKTtcclxuICAgIH1cclxuICAgIF9nZXRCb3VuZHMoKSB7XHJcbiAgICAgICAgbGV0IHdpZHRoID0gdGhpcy5nZXQoXCJ3aWR0aFwiKTtcclxuICAgICAgICBsZXQgaGVpZ2h0ID0gdGhpcy5nZXQoXCJoZWlnaHRcIik7XHJcbiAgICAgICAgbGV0IHBXaWR0aCA9IHRoaXMuZ2V0UHJpdmF0ZShcIndpZHRoXCIpO1xyXG4gICAgICAgIGxldCBwSGVpZ2h0ID0gdGhpcy5nZXRQcml2YXRlKFwiaGVpZ2h0XCIpO1xyXG4gICAgICAgIGxldCBib3VuZHMgPSB7XHJcbiAgICAgICAgICAgIGxlZnQ6IDAsXHJcbiAgICAgICAgICAgIHRvcDogMCxcclxuICAgICAgICAgICAgcmlnaHQ6IHRoaXMud2lkdGgoKSxcclxuICAgICAgICAgICAgYm90dG9tOiB0aGlzLmhlaWdodCgpLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgbGV0IGxheW91dCA9IHRoaXMuZ2V0KFwibGF5b3V0XCIpO1xyXG4gICAgICAgIGxldCBob3Jpem9udGFsID0gZmFsc2U7XHJcbiAgICAgICAgbGV0IHZlcnRpY2FsID0gZmFsc2U7XHJcbiAgICAgICAgaWYgKGxheW91dCBpbnN0YW5jZW9mIEhvcml6b250YWxMYXlvdXQgfHwgbGF5b3V0IGluc3RhbmNlb2YgR3JpZExheW91dCkge1xyXG4gICAgICAgICAgICBob3Jpem9udGFsID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGxheW91dCBpbnN0YW5jZW9mIFZlcnRpY2FsTGF5b3V0KSB7XHJcbiAgICAgICAgICAgIHZlcnRpY2FsID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCh3aWR0aCAhPSBudWxsIHx8IHBXaWR0aCAhPSBudWxsKSAmJiAoaGVpZ2h0ICE9IG51bGwgfHwgcEhlaWdodCAhPSBudWxsKSAmJiAhdGhpcy5nZXQoXCJ2ZXJ0aWNhbFNjcm9sbGJhclwiKSkge1xyXG4gICAgICAgICAgICAvLyB2b2lkXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBsZXQgbSA9IE51bWJlci5NQVhfVkFMVUU7XHJcbiAgICAgICAgICAgIGxldCBsID0gbTtcclxuICAgICAgICAgICAgbGV0IHIgPSAtbTtcclxuICAgICAgICAgICAgbGV0IHQgPSBtO1xyXG4gICAgICAgICAgICBsZXQgYiA9IC1tO1xyXG4gICAgICAgICAgICBjb25zdCBwYWRkaW5nTGVmdCA9IHRoaXMuZ2V0KFwicGFkZGluZ0xlZnRcIiwgMCk7XHJcbiAgICAgICAgICAgIGNvbnN0IHBhZGRpbmdUb3AgPSB0aGlzLmdldChcInBhZGRpbmdUb3BcIiwgMCk7XHJcbiAgICAgICAgICAgIGNvbnN0IHBhZGRpbmdSaWdodCA9IHRoaXMuZ2V0KFwicGFkZGluZ1JpZ2h0XCIsIDApO1xyXG4gICAgICAgICAgICBjb25zdCBwYWRkaW5nQm90dG9tID0gdGhpcy5nZXQoXCJwYWRkaW5nQm90dG9tXCIsIDApO1xyXG4gICAgICAgICAgICB0aGlzLmNoaWxkcmVuLmVhY2goKGNoaWxkKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQuZ2V0KFwicG9zaXRpb25cIikgIT0gXCJhYnNvbHV0ZVwiICYmIGNoaWxkLmdldChcImlzTWVhc3VyZWRcIikpIHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgY2hpbGRCb3VuZHMgPSBjaGlsZC5hZGp1c3RlZExvY2FsQm91bmRzKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGNoaWxkWCA9IGNoaWxkLngoKTtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgY2hpbGRZID0gY2hpbGQueSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBjbCA9IGNoaWxkWCArIGNoaWxkQm91bmRzLmxlZnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGNyID0gY2hpbGRYICsgY2hpbGRCb3VuZHMucmlnaHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGN0ID0gY2hpbGRZICsgY2hpbGRCb3VuZHMudG9wO1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBjYiA9IGNoaWxkWSArIGNoaWxkQm91bmRzLmJvdHRvbTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaG9yaXpvbnRhbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjbCAtPSBjaGlsZC5nZXQoXCJtYXJnaW5MZWZ0XCIsIDApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjciArPSBjaGlsZC5nZXQoXCJtYXJnaW5SaWdodFwiLCAwKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZlcnRpY2FsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0IC09IGNoaWxkLmdldChcIm1hcmdpblRvcFwiLCAwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2IgKz0gY2hpbGQuZ2V0KFwibWFyZ2luQm90dG9tXCIsIDApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoY2wgPCBsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGwgPSBjbDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNyID4gcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByID0gY3I7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjdCA8IHQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdCA9IGN0O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoY2IgPiBiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGIgPSBjYjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBpZiAobCA9PSBtKSB7XHJcbiAgICAgICAgICAgICAgICBsID0gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAociA9PSAtbSkge1xyXG4gICAgICAgICAgICAgICAgciA9IDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHQgPT0gbSkge1xyXG4gICAgICAgICAgICAgICAgdCA9IDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGIgPT0gLW0pIHtcclxuICAgICAgICAgICAgICAgIGIgPSAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGJvdW5kcy5sZWZ0ID0gbCAtIHBhZGRpbmdMZWZ0O1xyXG4gICAgICAgICAgICBib3VuZHMudG9wID0gdCAtIHBhZGRpbmdUb3A7XHJcbiAgICAgICAgICAgIGJvdW5kcy5yaWdodCA9IHIgKyBwYWRkaW5nUmlnaHQ7XHJcbiAgICAgICAgICAgIGJvdW5kcy5ib3R0b20gPSBiICsgcGFkZGluZ0JvdHRvbTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fY29udGVudFdpZHRoID0gYm91bmRzLnJpZ2h0IC0gYm91bmRzLmxlZnQ7XHJcbiAgICAgICAgdGhpcy5fY29udGVudEhlaWdodCA9IGJvdW5kcy5ib3R0b20gLSBib3VuZHMudG9wO1xyXG4gICAgICAgIGlmICgkdHlwZS5pc051bWJlcih3aWR0aCkpIHtcclxuICAgICAgICAgICAgYm91bmRzLmxlZnQgPSAwO1xyXG4gICAgICAgICAgICBib3VuZHMucmlnaHQgPSB3aWR0aDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCR0eXBlLmlzTnVtYmVyKHBXaWR0aCkpIHtcclxuICAgICAgICAgICAgYm91bmRzLmxlZnQgPSAwO1xyXG4gICAgICAgICAgICBib3VuZHMucmlnaHQgPSBwV2lkdGg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICgkdHlwZS5pc051bWJlcihoZWlnaHQpKSB7XHJcbiAgICAgICAgICAgIGJvdW5kcy50b3AgPSAwO1xyXG4gICAgICAgICAgICBib3VuZHMuYm90dG9tID0gaGVpZ2h0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoJHR5cGUuaXNOdW1iZXIocEhlaWdodCkpIHtcclxuICAgICAgICAgICAgYm91bmRzLnRvcCA9IDA7XHJcbiAgICAgICAgICAgIGJvdW5kcy5ib3R0b20gPSBwSGVpZ2h0O1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9sb2NhbEJvdW5kcyA9IGJvdW5kcztcclxuICAgIH1cclxuICAgIF91cGRhdGVCb3VuZHMoKSB7XHJcbiAgICAgICAgY29uc3QgbGF5b3V0ID0gdGhpcy5nZXQoXCJsYXlvdXRcIik7XHJcbiAgICAgICAgaWYgKGxheW91dCkge1xyXG4gICAgICAgICAgICBsYXlvdXQudXBkYXRlQ29udGFpbmVyKHRoaXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzdXBlci5fdXBkYXRlQm91bmRzKCk7XHJcbiAgICAgICAgdGhpcy51cGRhdGVCYWNrZ3JvdW5kKCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEBpZ25vcmVcclxuICAgICAqL1xyXG4gICAgbWFya0RpcnR5KCkge1xyXG4gICAgICAgIHN1cGVyLm1hcmtEaXJ0eSgpO1xyXG4gICAgICAgIHRoaXMuX3Jvb3QuX2FkZERpcnR5UGFyZW50KHRoaXMpO1xyXG4gICAgfVxyXG4gICAgX3ByZXBhcmVDaGlsZHJlbigpIHtcclxuICAgICAgICBjb25zdCBpbm5lcldpZHRoID0gdGhpcy5pbm5lcldpZHRoKCk7XHJcbiAgICAgICAgY29uc3QgaW5uZXJIZWlnaHQgPSB0aGlzLmlubmVySGVpZ2h0KCk7XHJcbiAgICAgICAgaWYgKGlubmVyV2lkdGggIT0gdGhpcy5fcHJldldpZHRoIHx8IGlubmVySGVpZ2h0ICE9IHRoaXMuX3ByZXZIZWlnaHQpIHtcclxuICAgICAgICAgICAgbGV0IGxheW91dCA9IHRoaXMuZ2V0KFwibGF5b3V0XCIpO1xyXG4gICAgICAgICAgICBsZXQgaG9yaXpvbnRhbCA9IGZhbHNlO1xyXG4gICAgICAgICAgICBsZXQgdmVydGljYWwgPSBmYWxzZTtcclxuICAgICAgICAgICAgaWYgKGxheW91dCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGxheW91dCBpbnN0YW5jZW9mIEhvcml6b250YWxMYXlvdXQgfHwgbGF5b3V0IGluc3RhbmNlb2YgR3JpZExheW91dCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGhvcml6b250YWwgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGxheW91dCBpbnN0YW5jZW9mIFZlcnRpY2FsTGF5b3V0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmVydGljYWwgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICRhcnJheS5lYWNoKHRoaXMuX3BlcmNlbnRhZ2VTaXplQ2hpbGRyZW4sIChjaGlsZCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFob3Jpem9udGFsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHdpZHRoID0gY2hpbGQuZ2V0KFwid2lkdGhcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHdpZHRoIGluc3RhbmNlb2YgUGVyY2VudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZC5zZXRQcml2YXRlKFwid2lkdGhcIiwgd2lkdGgudmFsdWUgKiBpbm5lcldpZHRoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoIXZlcnRpY2FsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGhlaWdodCA9IGNoaWxkLmdldChcImhlaWdodFwiKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaGVpZ2h0IGluc3RhbmNlb2YgUGVyY2VudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZC5zZXRQcml2YXRlKFwiaGVpZ2h0XCIsIGhlaWdodC52YWx1ZSAqIGlubmVySGVpZ2h0KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAkYXJyYXkuZWFjaCh0aGlzLl9wZXJjZW50YWdlUG9zaXRpb25DaGlsZHJlbiwgKGNoaWxkKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjaGlsZC5tYXJrRGlydHlQb3NpdGlvbigpO1xyXG4gICAgICAgICAgICAgICAgY2hpbGQubWFya0RpcnR5Qm91bmRzKCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB0aGlzLl9wcmV2V2lkdGggPSBpbm5lcldpZHRoO1xyXG4gICAgICAgICAgICB0aGlzLl9wcmV2SGVpZ2h0ID0gaW5uZXJIZWlnaHQ7XHJcbiAgICAgICAgICAgIHRoaXMuX3NpemVEaXJ0eSA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlQmFja2dyb3VuZCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9oYW5kbGVTdGF0ZXMoKTtcclxuICAgIH1cclxuICAgIF91cGRhdGVDaGlsZHJlbigpIHtcclxuICAgICAgICBpZiAodGhpcy5pc0RpcnR5KFwiaHRtbFwiKSkge1xyXG4gICAgICAgICAgICBjb25zdCBodG1sID0gdGhpcy5nZXQoXCJodG1sXCIpO1xyXG4gICAgICAgICAgICBpZiAoaHRtbCAmJiBodG1sICE9PSBcIlwiKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9yb290Ll9zZXRIVE1MQ29udGVudCh0aGlzLCBwb3B1bGF0ZVN0cmluZyh0aGlzLCB0aGlzLmdldChcImh0bWxcIiwgXCJcIikpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3Jvb3QuX3JlbW92ZUhUTUxDb250ZW50KHRoaXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX3Jvb3QuX3Bvc2l0aW9uSFRNTEVsZW1lbnQodGhpcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmlzRGlydHkoXCJ2ZXJ0aWNhbFNjcm9sbGJhclwiKSkge1xyXG4gICAgICAgICAgICBjb25zdCB2ZXJ0aWNhbFNjcm9sbGJhciA9IHRoaXMuZ2V0KFwidmVydGljYWxTY3JvbGxiYXJcIik7XHJcbiAgICAgICAgICAgIGlmICh2ZXJ0aWNhbFNjcm9sbGJhcikge1xyXG4gICAgICAgICAgICAgICAgdmVydGljYWxTY3JvbGxiYXIuX3NldFBhcmVudCh0aGlzKTtcclxuICAgICAgICAgICAgICAgIHZlcnRpY2FsU2Nyb2xsYmFyLnN0YXJ0R3JpcC5zZXRQcml2YXRlKFwidmlzaWJsZVwiLCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICB2ZXJ0aWNhbFNjcm9sbGJhci5lbmRHcmlwLnNldFByaXZhdGUoXCJ2aXNpYmxlXCIsIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2V0KFwibWFza0NvbnRlbnRcIiwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNldChcInBhZGRpbmdSaWdodFwiLCB2ZXJ0aWNhbFNjcm9sbGJhci53aWR0aCgpICsgdmVydGljYWxTY3JvbGxiYXIuZ2V0KFwibWFyZ2luUmlnaHRcIiwgMCkgKyB2ZXJ0aWNhbFNjcm9sbGJhci5nZXQoXCJtYXJnaW5MZWZ0XCIsIDApKTtcclxuICAgICAgICAgICAgICAgIGxldCBiYWNrZ3JvdW5kID0gdGhpcy5nZXQoXCJiYWNrZ3JvdW5kXCIpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFiYWNrZ3JvdW5kKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYmFja2dyb3VuZCA9IHRoaXMuc2V0KFwiYmFja2dyb3VuZFwiLCBSZWN0YW5nbGUubmV3KHRoaXMuX3Jvb3QsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhlbWVUYWdzOiBbXCJiYWNrZ3JvdW5kXCJdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmaWxsT3BhY2l0eTogMCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmlsbDogdGhpcy5fcm9vdC5pbnRlcmZhY2VDb2xvcnMuZ2V0KFwiYWx0ZXJuYXRpdmVCYWNrZ3JvdW5kXCIpXHJcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5fdnNiZDAgPSB0aGlzLmV2ZW50cy5vbihcIndoZWVsXCIsIChldmVudCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHdoZWVsRXZlbnQgPSBldmVudC5vcmlnaW5hbEV2ZW50O1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIElnbm9yZSB3aGVlbCBldmVudCBpZiBpdCBpcyBoYXBwZW5pbmcgb24gYSBub24tY2hhcnQgZWxlbWVudCwgZS5nLiBpZlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHNvbWUgcGFnZSBlbGVtZW50IGlzIG92ZXIgdGhlIGNoYXJ0LlxyXG4gICAgICAgICAgICAgICAgICAgIGlmICgkdXRpbHMuaXNMb2NhbEV2ZW50KHdoZWVsRXZlbnQsIHRoaXMpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoZWVsRXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHNoaWZ0WSA9IHdoZWVsRXZlbnQuZGVsdGFZIC8gNTAwMDtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBzdGFydCA9IHZlcnRpY2FsU2Nyb2xsYmFyLmdldChcInN0YXJ0XCIsIDApO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVuZCA9IHZlcnRpY2FsU2Nyb2xsYmFyLmdldChcImVuZFwiLCAxKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhcnQgKyBzaGlmdFkgPD0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzaGlmdFkgPSAtc3RhcnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChlbmQgKyBzaGlmdFkgPj0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzaGlmdFkgPSAxIC0gZW5kO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhcnQgKyBzaGlmdFkgPj0gMCAmJiBlbmQgKyBzaGlmdFkgPD0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2ZXJ0aWNhbFNjcm9sbGJhci5zZXQoXCJzdGFydFwiLCBzdGFydCArIHNoaWZ0WSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZlcnRpY2FsU2Nyb2xsYmFyLnNldChcImVuZFwiLCBlbmQgKyBzaGlmdFkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZGlzcG9zZXJzLnB1c2godGhpcy5fdnNiZDApO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fdnNiZDEgPSB2ZXJ0aWNhbFNjcm9sbGJhci5ldmVudHMub24oXCJyYW5nZWNoYW5nZWRcIiwgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBoID0gdGhpcy5fY29udGVudEhlaWdodDtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjaGlsZHJlbkRpc3BsYXkgPSB0aGlzLl9jaGlsZHJlbkRpc3BsYXk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY29udGVudE1hc2sgPSB0aGlzLl9jb250ZW50TWFzaztcclxuICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbkRpc3BsYXkueSA9IC12ZXJ0aWNhbFNjcm9sbGJhci5nZXQoXCJzdGFydFwiKSAqIGg7XHJcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW5EaXNwbGF5Lm1hcmtEaXJ0eUxheWVyKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRlbnRNYXNrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnRNYXNrLl9kaXNwbGF5LnkgPSAtY2hpbGRyZW5EaXNwbGF5Lnk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuRGlzcGxheS5tYXNrID0gY29udGVudE1hc2suX2Rpc3BsYXk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9kaXNwb3NlcnMucHVzaCh0aGlzLl92c2JkMSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9kaXNwbGF5LmFkZENoaWxkKHZlcnRpY2FsU2Nyb2xsYmFyLl9kaXNwbGF5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHByZXZpb3VzID0gdGhpcy5fcHJldlNldHRpbmdzLnZlcnRpY2FsU2Nyb2xsYmFyO1xyXG4gICAgICAgICAgICAgICAgaWYgKHByZXZpb3VzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGlzcGxheS5yZW1vdmVDaGlsZChwcmV2aW91cy5fZGlzcGxheSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX3ZzYmQwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3ZzYmQwLmRpc3Bvc2UoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX3ZzYmQxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3ZzYmQxLmRpc3Bvc2UoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2hpbGRyZW5EaXNwbGF5ID0gdGhpcy5fY2hpbGRyZW5EaXNwbGF5O1xyXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuRGlzcGxheS55ID0gMDtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFByaXZhdGUoXCJoZWlnaHRcIiwgdW5kZWZpbmVkKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldChcIm1hc2tDb250ZW50XCIsIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldChcInBhZGRpbmdSaWdodFwiLCB1bmRlZmluZWQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmlzRGlydHkoXCJiYWNrZ3JvdW5kXCIpKSB7XHJcbiAgICAgICAgICAgIC8vIFRPRE8gbWF5YmUgdGhpcyBzaG91bGQgZGlzcG9zZSA/XHJcbiAgICAgICAgICAgIGNvbnN0IHByZXZpb3VzID0gdGhpcy5fcHJldlNldHRpbmdzW1wiYmFja2dyb3VuZFwiXTtcclxuICAgICAgICAgICAgaWYgKHByZXZpb3VzKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9kaXNwbGF5LnJlbW92ZUNoaWxkKHByZXZpb3VzLl9kaXNwbGF5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBiYWNrZ3JvdW5kID0gdGhpcy5nZXQoXCJiYWNrZ3JvdW5kXCIpO1xyXG4gICAgICAgICAgICBpZiAoYmFja2dyb3VuZCBpbnN0YW5jZW9mIFNwcml0ZSkge1xyXG4gICAgICAgICAgICAgICAgYmFja2dyb3VuZC5zZXQoXCJpc01lYXN1cmVkXCIsIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgIGJhY2tncm91bmQuX3NldFBhcmVudCh0aGlzKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2Rpc3BsYXkuYWRkQ2hpbGRBdChiYWNrZ3JvdW5kLl9kaXNwbGF5LCAwKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5pc0RpcnR5KFwibWFza1wiKSkge1xyXG4gICAgICAgICAgICBjb25zdCBtYXNrID0gdGhpcy5nZXQoXCJtYXNrXCIpO1xyXG4gICAgICAgICAgICBjb25zdCBwcmV2aW91cyA9IHRoaXMuX3ByZXZTZXR0aW5nc1tcIm1hc2tcIl07XHJcbiAgICAgICAgICAgIGlmIChwcmV2aW91cykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZGlzcGxheS5yZW1vdmVDaGlsZChwcmV2aW91cy5fZGlzcGxheSk7XHJcbiAgICAgICAgICAgICAgICBpZiAocHJldmlvdXMgIT0gbWFzaykge1xyXG4gICAgICAgICAgICAgICAgICAgIHByZXZpb3VzLmRpc3Bvc2UoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAobWFzaykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcGFyZW50ID0gbWFzay5wYXJlbnQ7XHJcbiAgICAgICAgICAgICAgICBpZiAocGFyZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50LmNoaWxkcmVuLnJlbW92ZVZhbHVlKG1hc2spO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgbWFzay5fc2V0UGFyZW50KHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZGlzcGxheS5hZGRDaGlsZEF0KG1hc2suX2Rpc3BsYXksIDApO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fY2hpbGRyZW5EaXNwbGF5Lm1hc2sgPSBtYXNrLl9kaXNwbGF5O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgX3Byb2Nlc3NUZW1wbGF0ZUZpZWxkKCkge1xyXG4gICAgICAgIHN1cGVyLl9wcm9jZXNzVGVtcGxhdGVGaWVsZCgpO1xyXG4gICAgICAgIHRoaXMuY2hpbGRyZW4uZWFjaCgoY2hpbGQpID0+IHtcclxuICAgICAgICAgICAgY2hpbGQuX3Byb2Nlc3NUZW1wbGF0ZUZpZWxkKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEBpZ25vcmVcclxuICAgICAqL1xyXG4gICAgd2Fsa0NoaWxkcmVuKGYpIHtcclxuICAgICAgICB0aGlzLmNoaWxkcmVuLmVhY2goKGNoaWxkKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChjaGlsZCBpbnN0YW5jZW9mIENvbnRhaW5lcikge1xyXG4gICAgICAgICAgICAgICAgY2hpbGQud2Fsa0NoaWxkcmVuKGYpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGYoY2hpbGQpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgZWFjaENoaWxkcmVuKGYpIHtcclxuICAgICAgICBjb25zdCBiYWNrZ3JvdW5kID0gdGhpcy5nZXQoXCJiYWNrZ3JvdW5kXCIpO1xyXG4gICAgICAgIGlmIChiYWNrZ3JvdW5kKSB7XHJcbiAgICAgICAgICAgIGYoYmFja2dyb3VuZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHZlcnRpY2FsU2Nyb2xsYmFyID0gdGhpcy5nZXQoXCJ2ZXJ0aWNhbFNjcm9sbGJhclwiKTtcclxuICAgICAgICBpZiAodmVydGljYWxTY3JvbGxiYXIpIHtcclxuICAgICAgICAgICAgZih2ZXJ0aWNhbFNjcm9sbGJhcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IG1hc2sgPSB0aGlzLmdldChcIm1hc2tcIik7XHJcbiAgICAgICAgaWYgKG1hc2spIHtcclxuICAgICAgICAgICAgZihtYXNrKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5jaGlsZHJlbi52YWx1ZXMuZm9yRWFjaCgoY2hpbGQpID0+IHtcclxuICAgICAgICAgICAgZihjaGlsZCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBhbGxDaGlsZHJlbigpIHtcclxuICAgICAgICBjb25zdCBvdXRwdXQgPSBbXTtcclxuICAgICAgICB0aGlzLmVhY2hDaGlsZHJlbigoeCkgPT4ge1xyXG4gICAgICAgICAgICBvdXRwdXQucHVzaCh4KTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gb3V0cHV0O1xyXG4gICAgfVxyXG4gICAgX3NldERhdGFJdGVtKGRhdGFJdGVtKSB7XHJcbiAgICAgICAgY29uc3QgdXBkYXRlZCA9IChkYXRhSXRlbSAhPT0gdGhpcy5fZGF0YUl0ZW0pO1xyXG4gICAgICAgIHN1cGVyLl9zZXREYXRhSXRlbShkYXRhSXRlbSk7XHJcbiAgICAgICAgY29uc3QgaHRtbCA9IHRoaXMuZ2V0KFwiaHRtbFwiLCBcIlwiKTtcclxuICAgICAgICBpZiAoaHRtbCAmJiBodG1sICE9PSBcIlwiICYmIHVwZGF0ZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5fcm9vdC5fc2V0SFRNTENvbnRlbnQodGhpcywgcG9wdWxhdGVTdHJpbmcodGhpcywgaHRtbCkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQ29udGFpbmVyLCBcImNsYXNzTmFtZVwiLCB7XHJcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICB2YWx1ZTogXCJDb250YWluZXJcIlxyXG59KTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbnRhaW5lciwgXCJjbGFzc05hbWVzXCIsIHtcclxuICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgIHZhbHVlOiBTcHJpdGUuY2xhc3NOYW1lcy5jb25jYXQoW0NvbnRhaW5lci5jbGFzc05hbWVdKVxyXG59KTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q29udGFpbmVyLmpzLm1hcCIsImltcG9ydCB7IFBpY3R1cmVQYXR0ZXJuIH0gZnJvbSBcIi4uL3JlbmRlci9wYXR0ZXJucy9QaWN0dXJlUGF0dGVyblwiO1xyXG5pbXBvcnQgeyBTcHJpdGUgfSBmcm9tIFwiLi9TcHJpdGVcIjtcclxuaW1wb3J0IHsgQmxlbmRNb2RlIH0gZnJvbSBcIi4vYmFja2VuZC9SZW5kZXJlclwiO1xyXG5pbXBvcnQgKiBhcyAkdHlwZSBmcm9tIFwiLi4vdXRpbC9UeXBlXCI7XHJcbmltcG9ydCAqIGFzICRhcnJheSBmcm9tIFwiLi4vdXRpbC9BcnJheVwiO1xyXG5leHBvcnQgY29uc3QgdmlzdWFsU2V0dGluZ3MgPSBbXCJmaWxsXCIsIFwiZmlsbE9wYWNpdHlcIiwgXCJzdHJva2VcIiwgXCJzdHJva2VXaWR0aFwiLCBcInN0cm9rZU9wYWNpdHlcIiwgXCJmaWxsUGF0dGVyblwiLCBcInN0cm9rZVBhdHRlcm5cIiwgXCJmaWxsR3JhZGllbnRcIiwgXCJzdHJva2VHcmFkaWVudFwiLCBcInN0cm9rZURhc2hhcnJheVwiLCBcInN0cm9rZURhc2hvZmZzZXRcIiwgXCJzaGFkb3dCbHVyXCIsIFwic2hhZG93Q29sb3JcIiwgXCJzaGFkb3dPcGFjaXR5XCIsIFwic2hhZG93T2Zmc2V0WFwiLCBcInNoYWRvd09mZnNldFlcIiwgXCJibHVyXCIsIFwic2VwaWFcIiwgXCJpbnZlcnRcIiwgXCJicmlnaHRuZXNzXCIsIFwiaHVlXCIsIFwiY29udHJhc3RcIiwgXCJzYXR1cmF0ZVwiXTtcclxuLyoqXHJcbiAqIEJhc2UgY2xhc3MgdXNlZCBmb3IgZHJhd2luZyBzaGFwZXMuXHJcbiAqXHJcbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vd3d3LmFtY2hhcnRzLmNvbS9kb2NzL3Y1L2NvbmNlcHRzL2NvbW1vbi1lbGVtZW50cy9ncmFwaGljcy99IGZvciBtb3JlIGluZm9cclxuICogQGltcG9ydGFudFxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIEdyYXBoaWNzIGV4dGVuZHMgU3ByaXRlIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX2Rpc3BsYXlcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogdGhpcy5fcm9vdC5fcmVuZGVyZXIubWFrZUdyYXBoaWNzKClcclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfY2xlYXJcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogZmFsc2VcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIF9iZWZvcmVDaGFuZ2VkKCkge1xyXG4gICAgICAgIHN1cGVyLl9iZWZvcmVDaGFuZ2VkKCk7XHJcbiAgICAgICAgaWYgKHRoaXMuaXNEaXJ0eShcImRyYXdcIikgfHwgdGhpcy5pc0RpcnR5KFwic3ZnUGF0aFwiKSkge1xyXG4gICAgICAgICAgICB0aGlzLm1hcmtEaXJ0eUJvdW5kcygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5pc0RpcnR5KFwiZmlsbFwiKSB8fCB0aGlzLmlzRGlydHkoXCJzdHJva2VcIikgfHwgdGhpcy5pc0RpcnR5KFwidmlzaWJsZVwiKSB8fCB0aGlzLmlzRGlydHkoXCJmb3JjZUhpZGRlblwiKSB8fCB0aGlzLmlzRGlydHkoXCJzY2FsZVwiKSB8fCB0aGlzLmlzRGlydHkoXCJmaWxsR3JhZGllbnRcIikgfHwgdGhpcy5pc0RpcnR5KFwic3Ryb2tlR3JhZGllbnRcIikgfHwgdGhpcy5pc0RpcnR5KFwiZmlsbFBhdHRlcm5cIikgfHwgdGhpcy5pc0RpcnR5KFwic3Ryb2tlUGF0dGVyblwiKSB8fCB0aGlzLmlzRGlydHkoXCJmaWxsT3BhY2l0eVwiKSB8fCB0aGlzLmlzRGlydHkoXCJzdHJva2VPcGFjaXR5XCIpIHx8IHRoaXMuaXNEaXJ0eShcInN0cm9rZVdpZHRoXCIpIHx8IHRoaXMuaXNEaXJ0eShcImRyYXdcIikgfHwgdGhpcy5pc0RpcnR5KFwiYmxlbmRNb2RlXCIpIHx8IHRoaXMuaXNEaXJ0eShcInN0cm9rZURhc2hhcnJheVwiKSB8fCB0aGlzLmlzRGlydHkoXCJzdHJva2VEYXNob2Zmc2V0XCIpIHx8IHRoaXMuaXNEaXJ0eShcInN2Z1BhdGhcIikgfHwgdGhpcy5pc0RpcnR5KFwibGluZUpvaW5cIikgfHwgdGhpcy5pc0RpcnR5KFwic2hhZG93Q29sb3JcIikgfHwgdGhpcy5pc0RpcnR5KFwic2hhZG93Qmx1clwiKSB8fCB0aGlzLmlzRGlydHkoXCJzaGFkb3dPZmZzZXRYXCIpIHx8IHRoaXMuaXNEaXJ0eShcInNoYWRvd09mZnNldFlcIikpIHtcclxuICAgICAgICAgICAgdGhpcy5fY2xlYXIgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9kaXNwbGF5LmNyaXNwID0gdGhpcy5nZXQoXCJjcmlzcFwiLCBmYWxzZSk7XHJcbiAgICAgICAgaWYgKHRoaXMuaXNEaXJ0eShcImZpbGxHcmFkaWVudFwiKSkge1xyXG4gICAgICAgICAgICBjb25zdCBncmFkaWVudCA9IHRoaXMuZ2V0KFwiZmlsbEdyYWRpZW50XCIpO1xyXG4gICAgICAgICAgICBpZiAoZ3JhZGllbnQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2Rpc3BsYXkuaXNNZWFzdXJlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBncmFkaWVudFRhcmdldCA9IGdyYWRpZW50LmdldChcInRhcmdldFwiKTtcclxuICAgICAgICAgICAgICAgIGlmIChncmFkaWVudFRhcmdldCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2Rpc3Bvc2Vycy5wdXNoKGdyYWRpZW50VGFyZ2V0LmV2ZW50cy5vbihcImJvdW5kc2NoYW5nZWRcIiwgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9tYXJrRGlydHlLZXkoXCJmaWxsXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kaXNwb3NlcnMucHVzaChncmFkaWVudFRhcmdldC5ldmVudHMub24oXCJwb3NpdGlvbmNoYW5nZWRcIiwgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9tYXJrRGlydHlLZXkoXCJmaWxsXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5pc0RpcnR5KFwic3Ryb2tlR3JhZGllbnRcIikpIHtcclxuICAgICAgICAgICAgY29uc3QgZ3JhZGllbnQgPSB0aGlzLmdldChcInN0cm9rZUdyYWRpZW50XCIpO1xyXG4gICAgICAgICAgICBpZiAoZ3JhZGllbnQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2Rpc3BsYXkuaXNNZWFzdXJlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBncmFkaWVudFRhcmdldCA9IGdyYWRpZW50LmdldChcInRhcmdldFwiKTtcclxuICAgICAgICAgICAgICAgIGlmIChncmFkaWVudFRhcmdldCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2Rpc3Bvc2Vycy5wdXNoKGdyYWRpZW50VGFyZ2V0LmV2ZW50cy5vbihcImJvdW5kc2NoYW5nZWRcIiwgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9tYXJrRGlydHlLZXkoXCJzdHJva2VcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2Rpc3Bvc2Vycy5wdXNoKGdyYWRpZW50VGFyZ2V0LmV2ZW50cy5vbihcInBvc2l0aW9uY2hhbmdlZFwiLCAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX21hcmtEaXJ0eUtleShcInN0cm9rZVwiKTtcclxuICAgICAgICAgICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBfY2hhbmdlZCgpIHtcclxuICAgICAgICBzdXBlci5fY2hhbmdlZCgpO1xyXG4gICAgICAgIGlmICh0aGlzLl9jbGVhcikge1xyXG4gICAgICAgICAgICB0aGlzLm1hcmtEaXJ0eUJvdW5kcygpO1xyXG4gICAgICAgICAgICB0aGlzLm1hcmtEaXJ0eUxheWVyKCk7XHJcbiAgICAgICAgICAgIHRoaXMuX2Rpc3BsYXkuY2xlYXIoKTtcclxuICAgICAgICAgICAgbGV0IHN0cm9rZURhc2hhcnJheSA9IHRoaXMuZ2V0KFwic3Ryb2tlRGFzaGFycmF5XCIpO1xyXG4gICAgICAgICAgICBpZiAoJHR5cGUuaXNOdW1iZXIoc3Ryb2tlRGFzaGFycmF5KSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHN0cm9rZURhc2hhcnJheSA8IDAuNSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0cm9rZURhc2hhcnJheSA9IFswXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0cm9rZURhc2hhcnJheSA9IFtzdHJva2VEYXNoYXJyYXldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX2Rpc3BsYXkuc2V0TGluZURhc2goc3Ryb2tlRGFzaGFycmF5KTtcclxuICAgICAgICAgICAgY29uc3Qgc3Ryb2tlRGFzaG9mZnNldCA9IHRoaXMuZ2V0KFwic3Ryb2tlRGFzaG9mZnNldFwiKTtcclxuICAgICAgICAgICAgaWYgKHN0cm9rZURhc2hvZmZzZXQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2Rpc3BsYXkuc2V0TGluZURhc2hPZmZzZXQoc3Ryb2tlRGFzaG9mZnNldCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgYmxlbmRNb2RlID0gdGhpcy5nZXQoXCJibGVuZE1vZGVcIiwgQmxlbmRNb2RlLk5PUk1BTCk7XHJcbiAgICAgICAgICAgIHRoaXMuX2Rpc3BsYXkuYmxlbmRNb2RlID0gYmxlbmRNb2RlO1xyXG4gICAgICAgICAgICBjb25zdCBkcmF3ID0gdGhpcy5nZXQoXCJkcmF3XCIpO1xyXG4gICAgICAgICAgICBpZiAoZHJhdykge1xyXG4gICAgICAgICAgICAgICAgZHJhdyh0aGlzLl9kaXNwbGF5LCB0aGlzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBzdmdQYXRoID0gdGhpcy5nZXQoXCJzdmdQYXRoXCIpO1xyXG4gICAgICAgICAgICBpZiAoc3ZnUGF0aCAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9kaXNwbGF5LnN2Z1BhdGgoc3ZnUGF0aCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBfYWZ0ZXJDaGFuZ2VkKCkge1xyXG4gICAgICAgIHN1cGVyLl9hZnRlckNoYW5nZWQoKTtcclxuICAgICAgICBpZiAodGhpcy5fY2xlYXIpIHtcclxuICAgICAgICAgICAgY29uc3QgZmlsbCA9IHRoaXMuZ2V0KFwiZmlsbFwiKTtcclxuICAgICAgICAgICAgY29uc3QgZmlsbEdyYWRpZW50ID0gdGhpcy5nZXQoXCJmaWxsR3JhZGllbnRcIik7XHJcbiAgICAgICAgICAgIGNvbnN0IGZpbGxQYXR0ZXJuID0gdGhpcy5nZXQoXCJmaWxsUGF0dGVyblwiKTtcclxuICAgICAgICAgICAgY29uc3QgZmlsbE9wYWNpdHkgPSB0aGlzLmdldChcImZpbGxPcGFjaXR5XCIpO1xyXG4gICAgICAgICAgICBjb25zdCBzdHJva2UgPSB0aGlzLmdldChcInN0cm9rZVwiKTtcclxuICAgICAgICAgICAgY29uc3Qgc3Ryb2tlR3JhZGllbnQgPSB0aGlzLmdldChcInN0cm9rZUdyYWRpZW50XCIpO1xyXG4gICAgICAgICAgICBjb25zdCBzdHJva2VQYXR0ZXJuID0gdGhpcy5nZXQoXCJzdHJva2VQYXR0ZXJuXCIpO1xyXG4gICAgICAgICAgICBjb25zdCBzaGFkb3dDb2xvciA9IHRoaXMuZ2V0KFwic2hhZG93Q29sb3JcIik7XHJcbiAgICAgICAgICAgIGNvbnN0IHNoYWRvd0JsdXIgPSB0aGlzLmdldChcInNoYWRvd0JsdXJcIik7XHJcbiAgICAgICAgICAgIGNvbnN0IHNoYWRvd09mZnNldFggPSB0aGlzLmdldChcInNoYWRvd09mZnNldFhcIik7XHJcbiAgICAgICAgICAgIGNvbnN0IHNoYWRvd09mZnNldFkgPSB0aGlzLmdldChcInNoYWRvd09mZnNldFlcIik7XHJcbiAgICAgICAgICAgIGNvbnN0IHNoYWRvd09wYWNpdHkgPSB0aGlzLmdldChcInNoYWRvd09wYWNpdHlcIik7XHJcbiAgICAgICAgICAgIC8vY29uc3QgYm91bmRzID0gdGhpcy5fZGlzcGxheS5nZXRMb2NhbEJvdW5kcygpO1xyXG4gICAgICAgICAgICBpZiAoc2hhZG93Q29sb3IgJiYgKHNoYWRvd0JsdXIgfHwgc2hhZG93T2Zmc2V0WCB8fCBzaGFkb3dPZmZzZXRZKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZGlzcGxheS5zaGFkb3coc2hhZG93Q29sb3IsIHNoYWRvd0JsdXIsIHNoYWRvd09mZnNldFgsIHNoYWRvd09mZnNldFksIHNoYWRvd09wYWNpdHkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChmaWxsICYmICFmaWxsR3JhZGllbnQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2Rpc3BsYXkuYmVnaW5GaWxsKGZpbGwsIGZpbGxPcGFjaXR5KTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2Rpc3BsYXkuZW5kRmlsbCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChmaWxsR3JhZGllbnQpIHtcclxuICAgICAgICAgICAgICAgIGlmIChmaWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3RvcHMgPSBmaWxsR3JhZGllbnQuZ2V0KFwic3RvcHNcIiwgW10pO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzdG9wcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgJGFycmF5LmVhY2goc3RvcHMsIChzdG9wKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKCFzdG9wLmNvbG9yIHx8IHN0b3AuY29sb3JJbmhlcml0ZWQpICYmIGZpbGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdG9wLmNvbG9yID0gZmlsbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdG9wLmNvbG9ySW5oZXJpdGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdG9wLm9wYWNpdHkgPT0gbnVsbCB8fCBzdG9wLm9wYWNpdHlJbmhlcml0ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdG9wLm9wYWNpdHkgPSBmaWxsT3BhY2l0eTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdG9wLm9wYWNpdHlJbmhlcml0ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb25zdCBncmFkaWVudCA9IGZpbGxHcmFkaWVudC5nZXRGaWxsKHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGdyYWRpZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGlzcGxheS5iZWdpbkZpbGwoZ3JhZGllbnQsIGZpbGxPcGFjaXR5KTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kaXNwbGF5LmVuZEZpbGwoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZmlsbFBhdHRlcm4pIHtcclxuICAgICAgICAgICAgICAgIC8qXHJcbiAgICAgICAgICAgICAgICBsZXQgY2hhbmdlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgaWYgKGZpbGwgJiYgKCFmaWxsUGF0dGVybi5nZXQoXCJmaWxsXCIpIHx8IGZpbGxQYXR0ZXJuLmdldChcImZpbGxJbmhlcml0ZWRcIikpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZmlsbFBhdHRlcm4uc2V0KFwiZmlsbFwiLCBmaWxsKTtcclxuICAgICAgICAgICAgICAgICAgICBmaWxsUGF0dGVybi5zZXQoXCJmaWxsSW5oZXJpdGVkXCIsIHRydWUpXHJcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoc3Ryb2tlICYmICghZmlsbFBhdHRlcm4uZ2V0KFwiY29sb3JcIikgfHwgZmlsbFBhdHRlcm4uZ2V0KFwiY29sb3JJbmhlcml0ZWRcIikpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZmlsbFBhdHRlcm4uc2V0KFwiY29sb3JcIiwgc3Ryb2tlKTtcclxuICAgICAgICAgICAgICAgICAgICBmaWxsUGF0dGVybi5zZXQoXCJjb2xvckluaGVyaXRlZFwiLCB0cnVlKVxyXG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGNoYW5nZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBAdG9kbzogaXMgdGhpcyBPSz9cclxuICAgICAgICAgICAgICAgICAgICBmaWxsUGF0dGVybi5fY2hhbmdlZCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIGNvbnN0IHBhdHRlcm4gPSBmaWxsUGF0dGVybi5wYXR0ZXJuO1xyXG4gICAgICAgICAgICAgICAgaWYgKHBhdHRlcm4pIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kaXNwbGF5LmJlZ2luRmlsbChwYXR0ZXJuLCBmaWxsT3BhY2l0eSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGlzcGxheS5lbmRGaWxsKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpbGxQYXR0ZXJuIGluc3RhbmNlb2YgUGljdHVyZVBhdHRlcm4pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmlsbFBhdHRlcm4uZXZlbnRzLm9uY2UoXCJsb2FkZWRcIiwgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2xlYXIgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXJrRGlydHkoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChzdHJva2UgfHwgc3Ryb2tlR3JhZGllbnQgfHwgc3Ryb2tlUGF0dGVybikge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc3Ryb2tlT3BhY2l0eSA9IHRoaXMuZ2V0KFwic3Ryb2tlT3BhY2l0eVwiKTtcclxuICAgICAgICAgICAgICAgIGxldCBzdHJva2VXaWR0aCA9IHRoaXMuZ2V0KFwic3Ryb2tlV2lkdGhcIiwgMSk7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5nZXQoXCJub25TY2FsaW5nU3Ryb2tlXCIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3Ryb2tlV2lkdGggPSBzdHJva2VXaWR0aCAvIHRoaXMuZ2V0KFwic2NhbGVcIiwgMSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5nZXQoXCJjcmlzcFwiKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0cm9rZVdpZHRoIC89IHRoaXMuX3Jvb3QuX3JlbmRlcmVyLnJlc29sdXRpb247XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb25zdCBsaW5lSm9pbiA9IHRoaXMuZ2V0KFwibGluZUpvaW5cIik7XHJcbiAgICAgICAgICAgICAgICBpZiAoc3Ryb2tlICYmICFzdHJva2VHcmFkaWVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2Rpc3BsYXkubGluZVN0eWxlKHN0cm9rZVdpZHRoLCBzdHJva2UsIHN0cm9rZU9wYWNpdHksIGxpbmVKb2luKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kaXNwbGF5LmVuZFN0cm9rZSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHN0cm9rZUdyYWRpZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3RvcHMgPSBzdHJva2VHcmFkaWVudC5nZXQoXCJzdG9wc1wiLCBbXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0b3BzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAkYXJyYXkuZWFjaChzdG9wcywgKHN0b3ApID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoIXN0b3AuY29sb3IgfHwgc3RvcC5jb2xvckluaGVyaXRlZCkgJiYgc3Ryb2tlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RvcC5jb2xvciA9IHN0cm9rZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdG9wLmNvbG9ySW5oZXJpdGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdG9wLm9wYWNpdHkgPT0gbnVsbCB8fCBzdG9wLm9wYWNpdHlJbmhlcml0ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdG9wLm9wYWNpdHkgPSBzdHJva2VPcGFjaXR5O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0b3Aub3BhY2l0eUluaGVyaXRlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBncmFkaWVudCA9IHN0cm9rZUdyYWRpZW50LmdldEZpbGwodGhpcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGdyYWRpZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2Rpc3BsYXkubGluZVN0eWxlKHN0cm9rZVdpZHRoLCBncmFkaWVudCwgc3Ryb2tlT3BhY2l0eSwgbGluZUpvaW4pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9kaXNwbGF5LmVuZFN0cm9rZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChzdHJva2VQYXR0ZXJuKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLypcclxuICAgICAgICAgICAgICAgICAgICBsZXQgY2hhbmdlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzdHJva2UgJiYgKCFzdHJva2VQYXR0ZXJuLmdldChcImNvbG9yXCIpIHx8IHN0cm9rZVBhdHRlcm4uZ2V0KFwiY29sb3JJbmhlcml0ZWRcIikpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZVBhdHRlcm4uc2V0KFwiY29sb3JcIiwgc3Ryb2tlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3Ryb2tlUGF0dGVybi5zZXQoXCJjb2xvckluaGVyaXRlZFwiLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2hhbmdlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGFuZ2VkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEB0b2RvOiBpcyB0aGlzIE9LP1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJva2VQYXR0ZXJuLl9jaGFuZ2VkKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHBhdHRlcm4gPSBzdHJva2VQYXR0ZXJuLnBhdHRlcm47XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhdHRlcm4pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGlzcGxheS5saW5lU3R5bGUoc3Ryb2tlV2lkdGgsIHBhdHRlcm4sIHN0cm9rZU9wYWNpdHksIGxpbmVKb2luKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGlzcGxheS5lbmRTdHJva2UoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0cm9rZVBhdHRlcm4gaW5zdGFuY2VvZiBQaWN0dXJlUGF0dGVybikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3Ryb2tlUGF0dGVybi5ldmVudHMub25jZShcImxvYWRlZFwiLCAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2xlYXIgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubWFya0RpcnR5KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodGhpcy5nZXRQcml2YXRlKFwic2hvd2luZ1Rvb2x0aXBcIikpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2hvd1Rvb2x0aXAoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9jbGVhciA9IGZhbHNlO1xyXG4gICAgfVxyXG59XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShHcmFwaGljcywgXCJjbGFzc05hbWVcIiwge1xyXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgdmFsdWU6IFwiR3JhcGhpY3NcIlxyXG59KTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEdyYXBoaWNzLCBcImNsYXNzTmFtZXNcIiwge1xyXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgdmFsdWU6IFNwcml0ZS5jbGFzc05hbWVzLmNvbmNhdChbR3JhcGhpY3MuY2xhc3NOYW1lXSlcclxufSk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUdyYXBoaWNzLmpzLm1hcCIsImltcG9ydCB7IExheW91dCwgZWFjaENoaWxkcmVuIH0gZnJvbSBcIi4vTGF5b3V0XCI7XHJcbmltcG9ydCAqIGFzICRhcnJheSBmcm9tIFwiLi4vdXRpbC9BcnJheVwiO1xyXG5pbXBvcnQgKiBhcyAkbWF0aCBmcm9tIFwiLi4vdXRpbC9NYXRoXCI7XHJcbi8qKlxyXG4gKiBBIGdyaWQgY2hpbGRyZW4gbGF5b3V0IGZvciBbW0NvbnRhaW5lcl1dLlxyXG4gKlxyXG4gKiBAc2VlIHtAbGluayBodHRwczovL3d3dy5hbWNoYXJ0cy5jb20vZG9jcy92NS9jb25jZXB0cy9jb21tb24tZWxlbWVudHMvY29udGFpbmVycy8jTGF5b3V0fSBmb3IgbW9yZSBpbmZvXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgR3JpZExheW91dCBleHRlbmRzIExheW91dCB7XHJcbiAgICBfYWZ0ZXJOZXcoKSB7XHJcbiAgICAgICAgdGhpcy5fc2V0UmF3RGVmYXVsdChcIm1heENvbHVtbnNcIiwgTnVtYmVyLk1BWF9WQUxVRSk7XHJcbiAgICAgICAgc3VwZXIuX2FmdGVyTmV3KCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEBpZ25vcmVcclxuICAgICAqL1xyXG4gICAgdXBkYXRlQ29udGFpbmVyKGNvbnRhaW5lcikge1xyXG4gICAgICAgIGxldCBwYWRkaW5nTGVmdCA9IGNvbnRhaW5lci5nZXQoXCJwYWRkaW5nTGVmdFwiLCAwKTtcclxuICAgICAgICBsZXQgcGFkZGluZ1JpZ2h0ID0gY29udGFpbmVyLmdldChcInBhZGRpbmdSaWdodFwiLCAwKTtcclxuICAgICAgICBsZXQgcGFkZGluZ1RvcCA9IGNvbnRhaW5lci5nZXQoXCJwYWRkaW5nVG9wXCIsIDApO1xyXG4gICAgICAgIGxldCBhdmFpbGFibGVXaWR0aCA9IGNvbnRhaW5lci5tYXhXaWR0aCgpIC0gcGFkZGluZ0xlZnQgLSBwYWRkaW5nUmlnaHQ7XHJcbiAgICAgICAgbGV0IG1pbkNlbGxXaWR0aCA9IGF2YWlsYWJsZVdpZHRoO1xyXG4gICAgICAgIGxldCBtYXhDZWxsV2lkdGggPSAxO1xyXG4gICAgICAgIGVhY2hDaGlsZHJlbihjb250YWluZXIsIChjaGlsZCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoY2hpbGQuZ2V0KFwidmlzaWJsZVwiKSAmJiBjaGlsZC5nZXRQcml2YXRlKFwidmlzaWJsZVwiKSAmJiAhY2hpbGQuZ2V0KFwiZm9yY2VIaWRkZW5cIikpIHtcclxuICAgICAgICAgICAgICAgIGlmIChjaGlsZC5nZXQoXCJwb3NpdGlvblwiKSAhPSBcImFic29sdXRlXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgY2hpbGRXaWR0aCA9IGNoaWxkLndpZHRoKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkV2lkdGggPCBtaW5DZWxsV2lkdGgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWluQ2VsbFdpZHRoID0gY2hpbGRXaWR0aDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkV2lkdGggPiBtYXhDZWxsV2lkdGgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWF4Q2VsbFdpZHRoID0gY2hpbGRXaWR0aDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICBtaW5DZWxsV2lkdGggPSAkbWF0aC5maXRUb1JhbmdlKG1pbkNlbGxXaWR0aCwgMSwgYXZhaWxhYmxlV2lkdGgpO1xyXG4gICAgICAgIG1heENlbGxXaWR0aCA9ICRtYXRoLmZpdFRvUmFuZ2UobWF4Q2VsbFdpZHRoLCAxLCBhdmFpbGFibGVXaWR0aCk7XHJcbiAgICAgICAgbGV0IGNvbHVtbkNvdW50ID0gMTtcclxuICAgICAgICBpZiAodGhpcy5nZXQoXCJmaXhlZFdpZHRoR3JpZFwiKSkge1xyXG4gICAgICAgICAgICBjb2x1bW5Db3VudCA9IGF2YWlsYWJsZVdpZHRoIC8gbWF4Q2VsbFdpZHRoO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29sdW1uQ291bnQgPSBhdmFpbGFibGVXaWR0aCAvIG1pbkNlbGxXaWR0aDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29sdW1uQ291bnQgPSBNYXRoLm1heCgxLCBNYXRoLmZsb29yKGNvbHVtbkNvdW50KSk7XHJcbiAgICAgICAgY29sdW1uQ291bnQgPSBNYXRoLm1pbih0aGlzLmdldChcIm1heENvbHVtbnNcIiwgTnVtYmVyLk1BWF9WQUxVRSksIGNvbHVtbkNvdW50KTtcclxuICAgICAgICBsZXQgY29sdW1uV2lkdGhzID0gdGhpcy5nZXRDb2x1bW5XaWR0aHMoY29udGFpbmVyLCBjb2x1bW5Db3VudCwgbWF4Q2VsbFdpZHRoLCBhdmFpbGFibGVXaWR0aCk7XHJcbiAgICAgICAgbGV0IHByZXZZID0gcGFkZGluZ1RvcDtcclxuICAgICAgICBsZXQgY29sdW1uID0gMDtcclxuICAgICAgICBsZXQgbWF4Q29sdW1uSGVpZ2h0ID0gMDtcclxuICAgICAgICBjb2x1bW5Db3VudCA9IGNvbHVtbldpZHRocy5sZW5ndGg7XHJcbiAgICAgICAgbGV0IHByZXZYID0gcGFkZGluZ0xlZnQ7XHJcbiAgICAgICAgZWFjaENoaWxkcmVuKGNvbnRhaW5lciwgKGNoaWxkKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChjaGlsZC5nZXQoXCJwb3NpdGlvblwiKSA9PSBcInJlbGF0aXZlXCIgJiYgY2hpbGQuaXNWaXNpYmxlKCkpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG1hcmdpblRvcCA9IGNoaWxkLmdldChcIm1hcmdpblRvcFwiLCAwKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG1hcmdpbkJvdHRvbSA9IGNoaWxkLmdldChcIm1hcmdpbkJvdHRvbVwiLCAwKTtcclxuICAgICAgICAgICAgICAgIGxldCBib3VuZHMgPSBjaGlsZC5hZGp1c3RlZExvY2FsQm91bmRzKCk7XHJcbiAgICAgICAgICAgICAgICBsZXQgbWFyZ2luTGVmdCA9IGNoaWxkLmdldChcIm1hcmdpbkxlZnRcIiwgMCk7XHJcbiAgICAgICAgICAgICAgICBsZXQgbWFyZ2luUmlnaHQgPSBjaGlsZC5nZXQoXCJtYXJnaW5SaWdodFwiLCAwKTtcclxuICAgICAgICAgICAgICAgIGxldCB4ID0gcHJldlggKyBtYXJnaW5MZWZ0IC0gYm91bmRzLmxlZnQ7XHJcbiAgICAgICAgICAgICAgICBsZXQgeSA9IHByZXZZICsgbWFyZ2luVG9wIC0gYm91bmRzLnRvcDtcclxuICAgICAgICAgICAgICAgIGNoaWxkLnNldFByaXZhdGUoXCJ4XCIsIHgpO1xyXG4gICAgICAgICAgICAgICAgY2hpbGQuc2V0UHJpdmF0ZShcInlcIiwgeSk7XHJcbiAgICAgICAgICAgICAgICBwcmV2WCArPSBjb2x1bW5XaWR0aHNbY29sdW1uXSArIG1hcmdpblJpZ2h0O1xyXG4gICAgICAgICAgICAgICAgbWF4Q29sdW1uSGVpZ2h0ID0gTWF0aC5tYXgobWF4Q29sdW1uSGVpZ2h0LCBjaGlsZC5oZWlnaHQoKSArIG1hcmdpblRvcCArIG1hcmdpbkJvdHRvbSk7XHJcbiAgICAgICAgICAgICAgICBjb2x1bW4rKztcclxuICAgICAgICAgICAgICAgIGlmIChjb2x1bW4gPj0gY29sdW1uQ291bnQpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb2x1bW4gPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIHByZXZYID0gcGFkZGluZ0xlZnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJldlkgKz0gbWF4Q29sdW1uSGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEBpZ25vcmVcclxuICAgICAqL1xyXG4gICAgZ2V0Q29sdW1uV2lkdGhzKGNvbnRhaW5lciwgY29sdW1uQ291bnQsIG1heENlbGxXaWR0aCwgYXZhaWxhYmxlV2lkdGgpIHtcclxuICAgICAgICBsZXQgdG90YWxXaWR0aCA9IDA7XHJcbiAgICAgICAgbGV0IGNvbHVtbldpZHRocyA9IFtdO1xyXG4gICAgICAgIGxldCBjb2x1bW4gPSAwO1xyXG4gICAgICAgIGVhY2hDaGlsZHJlbihjb250YWluZXIsIChjaGlsZCkgPT4ge1xyXG4gICAgICAgICAgICBsZXQgYm91bmRzID0gY2hpbGQuYWRqdXN0ZWRMb2NhbEJvdW5kcygpO1xyXG4gICAgICAgICAgICBpZiAoY2hpbGQuZ2V0KFwicG9zaXRpb25cIikgIT0gXCJhYnNvbHV0ZVwiICYmIGNoaWxkLmlzVmlzaWJsZSgpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5nZXQoXCJmaXhlZFdpZHRoR3JpZFwiKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbHVtbldpZHRoc1tjb2x1bW5dID0gbWF4Q2VsbFdpZHRoO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uV2lkdGhzW2NvbHVtbl0gPSBNYXRoLm1heChjb2x1bW5XaWR0aHNbY29sdW1uXSB8IDAsIGJvdW5kcy5yaWdodCAtIGJvdW5kcy5sZWZ0ICsgY2hpbGQuZ2V0KFwibWFyZ2luTGVmdFwiLCAwKSArIGNoaWxkLmdldChcIm1hcmdpblJpZ2h0XCIsIDApKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChjb2x1bW4gPCBjb250YWluZXIuY2hpbGRyZW4ubGVuZ3RoIC0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbHVtbisrO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjb2x1bW4gPT0gY29sdW1uQ291bnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uID0gMDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICAkYXJyYXkuZWFjaChjb2x1bW5XaWR0aHMsICh3KSA9PiB7XHJcbiAgICAgICAgICAgIHRvdGFsV2lkdGggKz0gdztcclxuICAgICAgICB9KTtcclxuICAgICAgICBpZiAodG90YWxXaWR0aCA+IGF2YWlsYWJsZVdpZHRoKSB7XHJcbiAgICAgICAgICAgIGlmIChjb2x1bW5Db3VudCA+IDIpIHtcclxuICAgICAgICAgICAgICAgIGNvbHVtbkNvdW50IC09IDE7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRDb2x1bW5XaWR0aHMoY29udGFpbmVyLCBjb2x1bW5Db3VudCwgbWF4Q2VsbFdpZHRoLCBhdmFpbGFibGVXaWR0aCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gW2F2YWlsYWJsZVdpZHRoXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gY29sdW1uV2lkdGhzO1xyXG4gICAgfVxyXG59XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShHcmlkTGF5b3V0LCBcImNsYXNzTmFtZVwiLCB7XHJcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICB2YWx1ZTogXCJHcmlkTGF5b3V0XCJcclxufSk7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShHcmlkTGF5b3V0LCBcImNsYXNzTmFtZXNcIiwge1xyXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgdmFsdWU6IExheW91dC5jbGFzc05hbWVzLmNvbmNhdChbR3JpZExheW91dC5jbGFzc05hbWVdKVxyXG59KTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9R3JpZExheW91dC5qcy5tYXAiLCJpbXBvcnQgeyBMYXlvdXQsIGVhY2hDaGlsZHJlbiB9IGZyb20gXCIuL0xheW91dFwiO1xyXG5pbXBvcnQgKiBhcyAkdHlwZSBmcm9tIFwiLi4vdXRpbC9UeXBlXCI7XHJcbmltcG9ydCB7IFBlcmNlbnQgfSBmcm9tIFwiLi4vdXRpbC9QZXJjZW50XCI7XHJcbi8qKlxyXG4gKiBBIGhvcml6b250YWwgY2hpbGRyZW4gbGF5b3V0IGZvciBbW0NvbnRhaW5lcl1dLlxyXG4gKlxyXG4gKiBAc2VlIHtAbGluayBodHRwczovL3d3dy5hbWNoYXJ0cy5jb20vZG9jcy92NS9jb25jZXB0cy9jb21tb24tZWxlbWVudHMvY29udGFpbmVycy8jTGF5b3V0fSBmb3IgbW9yZSBpbmZvXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgSG9yaXpvbnRhbExheW91dCBleHRlbmRzIExheW91dCB7XHJcbiAgICAvKipcclxuICAgICAqIEBpZ25vcmVcclxuICAgICAqL1xyXG4gICAgdXBkYXRlQ29udGFpbmVyKGNvbnRhaW5lcikge1xyXG4gICAgICAgIGxldCBwYWRkaW5nTGVmdCA9IGNvbnRhaW5lci5nZXQoXCJwYWRkaW5nTGVmdFwiLCAwKTtcclxuICAgICAgICBsZXQgYXZhaWxhYmxlV2lkdGggPSBjb250YWluZXIuaW5uZXJXaWR0aCgpO1xyXG4gICAgICAgIGxldCB0b3RhbFBlcmNlbnQgPSAwO1xyXG4gICAgICAgIGVhY2hDaGlsZHJlbihjb250YWluZXIsIChjaGlsZCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoY2hpbGQuaXNWaXNpYmxlKCkpIHtcclxuICAgICAgICAgICAgICAgIGlmIChjaGlsZC5nZXQoXCJwb3NpdGlvblwiKSA9PSBcInJlbGF0aXZlXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgY2hpbGRXaWR0aCA9IGNoaWxkLmdldChcIndpZHRoXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZFdpZHRoIGluc3RhbmNlb2YgUGVyY2VudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0b3RhbFBlcmNlbnQgKz0gY2hpbGRXaWR0aC52YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHcgPSBhdmFpbGFibGVXaWR0aCAqIGNoaWxkV2lkdGgudmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBtaW5XaWR0aCA9IGNoaWxkLmdldChcIm1pbldpZHRoXCIsIGNoaWxkLmdldFByaXZhdGUoXCJtaW5XaWR0aFwiLCAtSW5maW5pdHkpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1pbldpZHRoID4gdykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXZhaWxhYmxlV2lkdGggLT0gbWluV2lkdGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b3RhbFBlcmNlbnQgLT0gY2hpbGRXaWR0aC52YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgbWF4V2lkdGggPSBjaGlsZC5nZXQoXCJtYXhXaWR0aFwiLCBjaGlsZC5nZXRQcml2YXRlKFwibWF4V2lkdGhcIiwgSW5maW5pdHkpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHcgPiBtYXhXaWR0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXZhaWxhYmxlV2lkdGggLT0gbWF4V2lkdGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b3RhbFBlcmNlbnQgLT0gY2hpbGRXaWR0aC52YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEkdHlwZS5pc051bWJlcihjaGlsZFdpZHRoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRXaWR0aCA9IGNoaWxkLndpZHRoKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgYXZhaWxhYmxlV2lkdGggLT0gY2hpbGRXaWR0aCArIGNoaWxkLmdldChcIm1hcmdpbkxlZnRcIiwgMCkgKyBjaGlsZC5nZXQoXCJtYXJnaW5SaWdodFwiLCAwKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICBpZiAoYXZhaWxhYmxlV2lkdGggPD0gMCB8fCBhdmFpbGFibGVXaWR0aCA9PSBJbmZpbml0eSkge1xyXG4gICAgICAgICAgICBhdmFpbGFibGVXaWR0aCA9IC4xO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvL2lmIChhdmFpbGFibGVXaWR0aCA+IDApIHtcclxuICAgICAgICBlYWNoQ2hpbGRyZW4oY29udGFpbmVyLCAoY2hpbGQpID0+IHtcclxuICAgICAgICAgICAgaWYgKGNoaWxkLmlzVmlzaWJsZSgpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQuZ2V0KFwicG9zaXRpb25cIikgPT0gXCJyZWxhdGl2ZVwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGNoaWxkV2lkdGggPSBjaGlsZC5nZXQoXCJ3aWR0aFwiKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGRXaWR0aCBpbnN0YW5jZW9mIFBlcmNlbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHByaXZhdGVXaWR0aCA9IGF2YWlsYWJsZVdpZHRoICogY2hpbGRXaWR0aC52YWx1ZSAvIHRvdGFsUGVyY2VudCAtIGNoaWxkLmdldChcIm1hcmdpbkxlZnRcIiwgMCkgLSBjaGlsZC5nZXQoXCJtYXJnaW5SaWdodFwiLCAwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG1pbldpZHRoID0gY2hpbGQuZ2V0KFwibWluV2lkdGhcIiwgY2hpbGQuZ2V0UHJpdmF0ZShcIm1pbldpZHRoXCIsIC1JbmZpbml0eSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgbWF4V2lkdGggPSBjaGlsZC5nZXQoXCJtYXhXaWR0aFwiLCBjaGlsZC5nZXRQcml2YXRlKFwibWF4V2lkdGhcIiwgSW5maW5pdHkpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcHJpdmF0ZVdpZHRoID0gTWF0aC5taW4oTWF0aC5tYXgobWluV2lkdGgsIHByaXZhdGVXaWR0aCksIG1heFdpZHRoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGQuc2V0UHJpdmF0ZShcIndpZHRoXCIsIHByaXZhdGVXaWR0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGQuX3ByZXZTZXR0aW5ncy53aWR0aCBpbnN0YW5jZW9mIFBlcmNlbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkLnNldFByaXZhdGUoXCJ3aWR0aFwiLCB1bmRlZmluZWQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLy99XHJcbiAgICAgICAgbGV0IHByZXZYID0gcGFkZGluZ0xlZnQ7XHJcbiAgICAgICAgZWFjaENoaWxkcmVuKGNvbnRhaW5lciwgKGNoaWxkKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChjaGlsZC5nZXQoXCJwb3NpdGlvblwiKSA9PSBcInJlbGF0aXZlXCIpIHtcclxuICAgICAgICAgICAgICAgIGlmIChjaGlsZC5pc1Zpc2libGUoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBib3VuZHMgPSBjaGlsZC5hZGp1c3RlZExvY2FsQm91bmRzKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IG1hcmdpbkxlZnQgPSBjaGlsZC5nZXQoXCJtYXJnaW5MZWZ0XCIsIDApO1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBtYXJnaW5SaWdodCA9IGNoaWxkLmdldChcIm1hcmdpblJpZ2h0XCIsIDApO1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBtYXhXaWR0aCA9IGNoaWxkLmdldChcIm1heFdpZHRoXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBsZWZ0ID0gYm91bmRzLmxlZnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHJpZ2h0ID0gYm91bmRzLnJpZ2h0O1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXhXaWR0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmlnaHQgLSBsZWZ0ID4gbWF4V2lkdGgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0ID0gbGVmdCArIG1heFdpZHRoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGxldCB4ID0gcHJldlggKyBtYXJnaW5MZWZ0IC0gbGVmdDtcclxuICAgICAgICAgICAgICAgICAgICBjaGlsZC5zZXRQcml2YXRlKFwieFwiLCB4KTtcclxuICAgICAgICAgICAgICAgICAgICBwcmV2WCA9IHggKyByaWdodCArIG1hcmdpblJpZ2h0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2hpbGQuc2V0UHJpdmF0ZShcInhcIiwgdW5kZWZpbmVkKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShIb3Jpem9udGFsTGF5b3V0LCBcImNsYXNzTmFtZVwiLCB7XHJcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICB2YWx1ZTogXCJIb3Jpem9udGFsTGF5b3V0XCJcclxufSk7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShIb3Jpem9udGFsTGF5b3V0LCBcImNsYXNzTmFtZXNcIiwge1xyXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgdmFsdWU6IExheW91dC5jbGFzc05hbWVzLmNvbmNhdChbSG9yaXpvbnRhbExheW91dC5jbGFzc05hbWVdKVxyXG59KTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9SG9yaXpvbnRhbExheW91dC5qcy5tYXAiLCJpbXBvcnQgeyBUZXh0IH0gZnJvbSBcIi4uL3JlbmRlci9UZXh0XCI7XHJcbmltcG9ydCB7IHA1MCwgcDEwMCB9IGZyb20gXCIuLi91dGlsL1BlcmNlbnRcIjtcclxuaW1wb3J0IHsgQ29udGFpbmVyIH0gZnJvbSBcIi4vQ29udGFpbmVyXCI7XHJcbmltcG9ydCAqIGFzICRhcnJheSBmcm9tIFwiLi4vLi4vY29yZS91dGlsL0FycmF5XCI7XHJcbmltcG9ydCAqIGFzICR0eXBlIGZyb20gXCIuLi8uLi9jb3JlL3V0aWwvVHlwZVwiO1xyXG4vKipcclxuICogQ3JlYXRlcyBhIGxhYmVsIHdpdGggc3VwcG9ydCBmb3IgaW4tbGluZSBzdHlsaW5nIGFuZCBkYXRhIGJpbmRpbmdzLlxyXG4gKlxyXG4gKiBAc2VlIHtAbGluayBodHRwczovL3d3dy5hbWNoYXJ0cy5jb20vZG9jcy92NS9jb25jZXB0cy9jb21tb24tZWxlbWVudHMvbGFiZWxzL30gZm9yIG1vcmUgaW5mb1xyXG4gKi9cclxuZXhwb3J0IGNsYXNzIExhYmVsIGV4dGVuZHMgQ29udGFpbmVyIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX3RleHRcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX3RleHRLZXlzXCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IFtcclxuICAgICAgICAgICAgICAgIFwidGV4dFwiLFxyXG4gICAgICAgICAgICAgICAgXCJmaWxsXCIsXHJcbiAgICAgICAgICAgICAgICBcImZpbGxPcGFjaXR5XCIsXHJcbiAgICAgICAgICAgICAgICBcInRleHRBbGlnblwiLFxyXG4gICAgICAgICAgICAgICAgXCJmb250RmFtaWx5XCIsXHJcbiAgICAgICAgICAgICAgICBcImZvbnRTaXplXCIsXHJcbiAgICAgICAgICAgICAgICBcImZvbnRTdHlsZVwiLFxyXG4gICAgICAgICAgICAgICAgXCJmb250V2VpZ2h0XCIsXHJcbiAgICAgICAgICAgICAgICBcImZvbnRTdHlsZVwiLFxyXG4gICAgICAgICAgICAgICAgXCJmb250VmFyaWFudFwiLFxyXG4gICAgICAgICAgICAgICAgXCJ0ZXh0RGVjb3JhdGlvblwiLFxyXG4gICAgICAgICAgICAgICAgXCJzaGFkb3dDb2xvclwiLFxyXG4gICAgICAgICAgICAgICAgXCJzaGFkb3dCbHVyXCIsXHJcbiAgICAgICAgICAgICAgICBcInNoYWRvd09mZnNldFhcIixcclxuICAgICAgICAgICAgICAgIFwic2hhZG93T2Zmc2V0WVwiLFxyXG4gICAgICAgICAgICAgICAgXCJzaGFkb3dPcGFjaXR5XCIsXHJcbiAgICAgICAgICAgICAgICAvLyBcImxlYWRpbmdcIixcclxuICAgICAgICAgICAgICAgIC8vIFwibGV0dGVyU3BhY2luZ1wiLFxyXG4gICAgICAgICAgICAgICAgXCJsaW5lSGVpZ2h0XCIsXHJcbiAgICAgICAgICAgICAgICBcImJhc2VsaW5lUmF0aW9cIixcclxuICAgICAgICAgICAgICAgIC8vXCJwYWRkaW5nXCIsXHJcbiAgICAgICAgICAgICAgICAvLyBcInN0cm9rZVwiLFxyXG4gICAgICAgICAgICAgICAgLy8gXCJzdHJva2VUaGlja25lc3NcIixcclxuICAgICAgICAgICAgICAgIC8vIFwidHJpbVwiLFxyXG4gICAgICAgICAgICAgICAgLy8gXCJ3b3JkV3JhcFwiLFxyXG4gICAgICAgICAgICAgICAgXCJkaXJlY3Rpb25cIixcclxuICAgICAgICAgICAgICAgIFwidGV4dEJhc2VsaW5lXCIsXHJcbiAgICAgICAgICAgICAgICBcIm92ZXJzaXplZEJlaGF2aW9yXCIsXHJcbiAgICAgICAgICAgICAgICBcImJyZWFrV29yZHNcIixcclxuICAgICAgICAgICAgICAgIFwiZWxsaXBzaXNcIixcclxuICAgICAgICAgICAgICAgIFwibWluU2NhbGVcIixcclxuICAgICAgICAgICAgICAgIFwicG9wdWxhdGVUZXh0XCIsXHJcbiAgICAgICAgICAgICAgICBcInJvbGVcIixcclxuICAgICAgICAgICAgICAgIFwiaWdub3JlRm9ybWF0dGluZ1wiXHJcbiAgICAgICAgICAgIF1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQGlnbm9yZSBUZXh0IGlzIG5vdCB0byBiZSB1c2VkIGRpcmVjdGx5XHJcbiAgICAgKi9cclxuICAgIGdldCB0ZXh0KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl90ZXh0O1xyXG4gICAgfVxyXG4gICAgX2FmdGVyTmV3KCkge1xyXG4gICAgICAgIHN1cGVyLl9hZnRlck5ldygpO1xyXG4gICAgICAgIHRoaXMuX21ha2VUZXh0KCk7XHJcbiAgICAgICAgJGFycmF5LmVhY2godGhpcy5fdGV4dEtleXMsIChwcm9wZXJ0eSkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBwcm9wVmFsdWUgPSB0aGlzLmdldChwcm9wZXJ0eSk7XHJcbiAgICAgICAgICAgIGlmIChwcm9wVmFsdWUgIT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl90ZXh0LnNldChwcm9wZXJ0eSwgcHJvcFZhbHVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGlmICh0aGlzLmdldChcImh0bWxcIiwgXCJcIikgIT09IFwiXCIpIHtcclxuICAgICAgICAgICAgdGhpcy5fdGV4dC5zZXQoXCJ0ZXh0XCIsIFwiXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLm9uUHJpdmF0ZShcIm1heFdpZHRoXCIsICgpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5fc2V0TWF4RGltZW50aW9ucygpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMub25Qcml2YXRlKFwibWF4SGVpZ2h0XCIsICgpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5fc2V0TWF4RGltZW50aW9ucygpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgX21ha2VUZXh0KCkge1xyXG4gICAgICAgIHRoaXMuX3RleHQgPSB0aGlzLmNoaWxkcmVuLnB1c2goVGV4dC5uZXcodGhpcy5fcm9vdCwge30pKTtcclxuICAgIH1cclxuICAgIF91cGRhdGVDaGlsZHJlbigpIHtcclxuICAgICAgICBzdXBlci5fdXBkYXRlQ2hpbGRyZW4oKTtcclxuICAgICAgICAkYXJyYXkuZWFjaCh0aGlzLl90ZXh0S2V5cywgKHByb3BlcnR5KSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuX3RleHQuc2V0KHByb3BlcnR5LCB0aGlzLmdldChwcm9wZXJ0eSkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGlmICh0aGlzLmlzRGlydHkoXCJtYXhXaWR0aFwiKSkge1xyXG4gICAgICAgICAgICB0aGlzLl9zZXRNYXhEaW1lbnRpb25zKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmlzRGlydHkoXCJtYXhIZWlnaHRcIikpIHtcclxuICAgICAgICAgICAgdGhpcy5fc2V0TWF4RGltZW50aW9ucygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5pc0RpcnR5KFwicm90YXRpb25cIikpIHtcclxuICAgICAgICAgICAgdGhpcy5fc2V0TWF4RGltZW50aW9ucygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBEbyBub3Qgc2hvdyByZWd1bGFyIHRleHQgaWYgSFRNTCBpcyB1c2VkXHJcbiAgICAgICAgaWYgKHRoaXMuZ2V0KFwiaHRtbFwiLCBcIlwiKSAhPT0gXCJcIikge1xyXG4gICAgICAgICAgICB0aGlzLl90ZXh0LnNldChcInRleHRcIiwgXCJcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLl90ZXh0LnNldChcInRleHRcIiwgdGhpcy5nZXQoXCJ0ZXh0XCIpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuaXNEaXJ0eShcInRleHRBbGlnblwiKSB8fCB0aGlzLmlzRGlydHkoXCJ3aWR0aFwiKSkge1xyXG4gICAgICAgICAgICBjb25zdCB0ZXh0QWxpZ24gPSB0aGlzLmdldChcInRleHRBbGlnblwiKTtcclxuICAgICAgICAgICAgbGV0IHg7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmdldChcIndpZHRoXCIpICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0ZXh0QWxpZ24gPT0gXCJyaWdodFwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgeCA9IHAxMDA7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0ZXh0QWxpZ24gPT0gXCJjZW50ZXJcIikge1xyXG4gICAgICAgICAgICAgICAgICAgIHggPSBwNTA7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB4ID0gMDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlmICh0ZXh0QWxpZ24gPT0gXCJsZWZ0XCIgfHwgdGV4dEFsaWduID09IFwic3RhcnRcIikge1xyXG4gICAgICAgICAgICAgICAgICAgIHggPSB0aGlzLmdldChcInBhZGRpbmdMZWZ0XCIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodGV4dEFsaWduID09IFwicmlnaHRcIiB8fCB0ZXh0QWxpZ24gPT0gXCJlbmRcIikge1xyXG4gICAgICAgICAgICAgICAgICAgIHggPSAtdGhpcy5nZXQoXCJwYWRkaW5nUmlnaHRcIik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy50ZXh0LnNldChcInhcIiwgeCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgX3NldE1heERpbWVudGlvbnMoKSB7XHJcbiAgICAgICAgY29uc3Qgcm90YXRpb24gPSB0aGlzLmdldChcInJvdGF0aW9uXCIpO1xyXG4gICAgICAgIGNvbnN0IHZlcnRpY2FsID0gcm90YXRpb24gPT0gOTAgfHwgcm90YXRpb24gPT0gMjcwIHx8IHJvdGF0aW9uID09IC05MDtcclxuICAgICAgICBjb25zdCBtYXhXaWR0aCA9IHRoaXMuZ2V0KFwibWF4V2lkdGhcIiwgdGhpcy5nZXRQcml2YXRlKFwibWF4V2lkdGhcIiwgSW5maW5pdHkpKTtcclxuICAgICAgICBpZiAoJHR5cGUuaXNOdW1iZXIobWF4V2lkdGgpKSB7XHJcbiAgICAgICAgICAgIHRoaXMudGV4dC5zZXQodmVydGljYWwgPyBcIm1heEhlaWdodFwiIDogXCJtYXhXaWR0aFwiLCBtYXhXaWR0aCAtIHRoaXMuZ2V0KFwicGFkZGluZ0xlZnRcIiwgMCkgLSB0aGlzLmdldChcInBhZGRpbmdSaWdodFwiLCAwKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLnRleHQuc2V0KHZlcnRpY2FsID8gXCJtYXhIZWlnaHRcIiA6IFwibWF4V2lkdGhcIiwgdW5kZWZpbmVkKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgbWF4SGVpZ2h0ID0gdGhpcy5nZXQoXCJtYXhIZWlnaHRcIiwgdGhpcy5nZXRQcml2YXRlKFwibWF4SGVpZ2h0XCIsIEluZmluaXR5KSk7XHJcbiAgICAgICAgaWYgKCR0eXBlLmlzTnVtYmVyKG1heEhlaWdodCkpIHtcclxuICAgICAgICAgICAgdGhpcy50ZXh0LnNldCh2ZXJ0aWNhbCA/IFwibWF4V2lkdGhcIiA6IFwibWF4SGVpZ2h0XCIsIG1heEhlaWdodCAtIHRoaXMuZ2V0KFwicGFkZGluZ1RvcFwiLCAwKSAtIHRoaXMuZ2V0KFwicGFkZGluZ0JvdHRvbVwiLCAwKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLnRleHQuc2V0KHZlcnRpY2FsID8gXCJtYXhXaWR0aFwiIDogXCJtYXhIZWlnaHRcIiwgdW5kZWZpbmVkKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBfc2V0RGF0YUl0ZW0oZGF0YUl0ZW0pIHtcclxuICAgICAgICBzdXBlci5fc2V0RGF0YUl0ZW0oZGF0YUl0ZW0pO1xyXG4gICAgICAgIHRoaXMuX21hcmtEaXJ0eUtleShcInRleHRcIik7XHJcbiAgICAgICAgaWYgKHRoaXMudGV4dC5nZXQoXCJwb3B1bGF0ZVRleHRcIikpIHtcclxuICAgICAgICAgICAgdGhpcy50ZXh0Lm1hcmtEaXJ0eVRleHQoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGV4dCB3aXRoIHBvcHVsYXRlZCBwbGFjZWhvbGRlcnMgYW5kIGZvcm1hdHRpbmcgaWYgYHBvcHVsYXRlVGV4dGAgaXNcclxuICAgICAqIHNldCB0byBgdHJ1ZWAuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybiBQb3B1bGF0ZWQgdGV4dFxyXG4gICAgICovXHJcbiAgICBnZXRUZXh0KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl90ZXh0Ll9nZXRUZXh0KCk7XHJcbiAgICB9XHJcbn1cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KExhYmVsLCBcImNsYXNzTmFtZVwiLCB7XHJcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICB2YWx1ZTogXCJMYWJlbFwiXHJcbn0pO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoTGFiZWwsIFwiY2xhc3NOYW1lc1wiLCB7XHJcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICB2YWx1ZTogQ29udGFpbmVyLmNsYXNzTmFtZXMuY29uY2F0KFtMYWJlbC5jbGFzc05hbWVdKVxyXG59KTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TGFiZWwuanMubWFwIiwiaW1wb3J0IHsgRW50aXR5IH0gZnJvbSBcIi4uL3V0aWwvRW50aXR5XCI7XHJcbmV4cG9ydCBmdW5jdGlvbiBlYWNoQ2hpbGRyZW4oY29udGFpbmVyLCBmKSB7XHJcbiAgICBpZiAoY29udGFpbmVyLmdldChcInJldmVyc2VDaGlsZHJlblwiLCBmYWxzZSkpIHtcclxuICAgICAgICBjb250YWluZXIuY2hpbGRyZW4uZWFjaFJldmVyc2UoZik7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBjb250YWluZXIuY2hpbGRyZW4uZWFjaChmKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQmFzZSBjbGFzcyBmb3IgW1tDb250YWluZXJdXSBsYXlvdXRzLlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIExheW91dCBleHRlbmRzIEVudGl0eSB7XHJcbn1cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KExheW91dCwgXCJjbGFzc05hbWVcIiwge1xyXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgdmFsdWU6IFwiTGF5b3V0XCJcclxufSk7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShMYXlvdXQsIFwiY2xhc3NOYW1lc1wiLCB7XHJcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICB2YWx1ZTogRW50aXR5LmNsYXNzTmFtZXMuY29uY2F0KFtMYXlvdXQuY2xhc3NOYW1lXSlcclxufSk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUxheW91dC5qcy5tYXAiLCJpbXBvcnQgeyBTZXJpZXMgfSBmcm9tIFwiLi9TZXJpZXNcIjtcclxuaW1wb3J0IHsgQ29udGFpbmVyIH0gZnJvbSBcIi4uLy4uL2NvcmUvcmVuZGVyL0NvbnRhaW5lclwiO1xyXG5pbXBvcnQgeyBMYWJlbCB9IGZyb20gXCIuLi8uLi9jb3JlL3JlbmRlci9MYWJlbFwiO1xyXG5pbXBvcnQgeyBSb3VuZGVkUmVjdGFuZ2xlIH0gZnJvbSBcIi4uLy4uL2NvcmUvcmVuZGVyL1JvdW5kZWRSZWN0YW5nbGVcIjtcclxuaW1wb3J0IHsgVGVtcGxhdGUgfSBmcm9tIFwiLi4vLi4vY29yZS91dGlsL1RlbXBsYXRlXCI7XHJcbmltcG9ydCB7IExpc3RUZW1wbGF0ZSB9IGZyb20gXCIuLi8uLi9jb3JlL3V0aWwvTGlzdFwiO1xyXG5pbXBvcnQgKiBhcyAkdXRpbHMgZnJvbSBcIi4uLy4uL2NvcmUvdXRpbC9VdGlsc1wiO1xyXG4vKipcclxuICogQSB1bml2ZXJzYWwgbGVnZW5kIGNvbnRyb2wuXHJcbiAqXHJcbiAqIEBpbXBvcnRhbnRcclxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly93d3cuYW1jaGFydHMuY29tL2RvY3MvdjUvY29uY2VwdHMvbGVnZW5kL30gZm9yIG1vcmUgaW5mb1xyXG4gKi9cclxuZXhwb3J0IGNsYXNzIExlZ2VuZCBleHRlbmRzIFNlcmllcyB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIExpc3Qgb2YgYWxsIFtbQ29udGFpbmVyXV0gZWxlbWVudHMgZm9yIGxlZ2VuZCBpdGVtcy5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBkZWZhdWx0IG5ldyBMaXN0VGVtcGxhdGU8Q29udGFpbmVyPlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIml0ZW1Db250YWluZXJzXCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IG5ldyBMaXN0VGVtcGxhdGUoVGVtcGxhdGUubmV3KHt9KSwgKCkgPT4gQ29udGFpbmVyLl9uZXcodGhpcy5fcm9vdCwge1xyXG4gICAgICAgICAgICAgICAgdGhlbWVUYWdzOiAkdXRpbHMubWVyZ2VUYWdzKHRoaXMuaXRlbUNvbnRhaW5lcnMudGVtcGxhdGUuZ2V0KFwidGhlbWVUYWdzXCIsIFtdKSwgW1wibGVnZW5kXCIsIFwiaXRlbVwiXSksXHJcbiAgICAgICAgICAgICAgICB0aGVtZVRhZ3NTZWxmOiAkdXRpbHMubWVyZ2VUYWdzKHRoaXMuaXRlbUNvbnRhaW5lcnMudGVtcGxhdGUuZ2V0KFwidGhlbWVUYWdzU2VsZlwiLCBbXSksIFtcIml0ZW1jb250YWluZXJcIl0pLFxyXG4gICAgICAgICAgICAgICAgYmFja2dyb3VuZDogUm91bmRlZFJlY3RhbmdsZS5uZXcodGhpcy5fcm9vdCwge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoZW1lVGFnczogJHV0aWxzLm1lcmdlVGFncyh0aGlzLml0ZW1Db250YWluZXJzLnRlbXBsYXRlLmdldChcInRoZW1lVGFnc1wiLCBbXSksIFtcImxlZ2VuZFwiLCBcIml0ZW1cIiwgXCJiYWNrZ3JvdW5kXCJdKSxcclxuICAgICAgICAgICAgICAgICAgICB0aGVtZVRhZ3NTZWxmOiAkdXRpbHMubWVyZ2VUYWdzKHRoaXMuaXRlbUNvbnRhaW5lcnMudGVtcGxhdGUuZ2V0KFwidGhlbWVUYWdzU2VsZlwiLCBbXSksIFtcIml0ZW1jb250YWluZXJcIl0pXHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICB9LCBbdGhpcy5pdGVtQ29udGFpbmVycy50ZW1wbGF0ZV0pKVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIExpc3Qgb2YgbGVnZW5kIG1hcmtlciBlbGVtZW50cy5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBkZWZhdWx0IG5ldyBMaXN0VGVtcGxhdGU8Q29udGFpbmVyPlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm1hcmtlcnNcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogbmV3IExpc3RUZW1wbGF0ZShUZW1wbGF0ZS5uZXcoe30pLCAoKSA9PiBDb250YWluZXIuX25ldyh0aGlzLl9yb290LCB7XHJcbiAgICAgICAgICAgICAgICB0aGVtZVRhZ3M6ICR1dGlscy5tZXJnZVRhZ3ModGhpcy5tYXJrZXJzLnRlbXBsYXRlLmdldChcInRoZW1lVGFnc1wiLCBbXSksIFtcImxlZ2VuZFwiLCBcIm1hcmtlclwiXSlcclxuICAgICAgICAgICAgfSwgW3RoaXMubWFya2Vycy50ZW1wbGF0ZV0pKVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIExpc3Qgb2YgbGVnZW5kIGxhYmVsIGVsZW1lbnRzLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQGRlZmF1bHQgbmV3IExpc3RUZW1wbGF0ZTxMYWJlbD5cclxuICAgICAgICAgKi9cclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJsYWJlbHNcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogbmV3IExpc3RUZW1wbGF0ZShUZW1wbGF0ZS5uZXcoe30pLCAoKSA9PiBMYWJlbC5fbmV3KHRoaXMuX3Jvb3QsIHtcclxuICAgICAgICAgICAgICAgIHRoZW1lVGFnczogJHV0aWxzLm1lcmdlVGFncyh0aGlzLmxhYmVscy50ZW1wbGF0ZS5nZXQoXCJ0aGVtZVRhZ3NcIiwgW10pLCBbXCJsZWdlbmRcIiwgXCJsYWJlbFwiXSlcclxuICAgICAgICAgICAgfSwgW3RoaXMubGFiZWxzLnRlbXBsYXRlXSkpXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogTGlzdCBvZiBsZWdlbmQgdmFsdWUgbGFiZWwgZWxlbWVudHMuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAZGVmYXVsdCBuZXcgTGlzdFRlbXBsYXRlPGxhYmVsPlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInZhbHVlTGFiZWxzXCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IG5ldyBMaXN0VGVtcGxhdGUoVGVtcGxhdGUubmV3KHt9KSwgKCkgPT4gTGFiZWwuX25ldyh0aGlzLl9yb290LCB7XHJcbiAgICAgICAgICAgICAgICB0aGVtZVRhZ3M6ICR1dGlscy5tZXJnZVRhZ3ModGhpcy52YWx1ZUxhYmVscy50ZW1wbGF0ZS5nZXQoXCJ0aGVtZVRhZ3NcIiwgW10pLCBbXCJsZWdlbmRcIiwgXCJsYWJlbFwiLCBcInZhbHVlXCJdKVxyXG4gICAgICAgICAgICB9LCBbdGhpcy52YWx1ZUxhYmVscy50ZW1wbGF0ZV0pKVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIExpc3Qgb2YgcmVjdGFuZ2xlIGVsZW1lbnRzIHVzZWQgZm9yIGRlZmF1bHQgbGVnZW5kIG1hcmtlcnMuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAZGVmYXVsdCBuZXcgTGlzdFRlbXBsYXRlPFJvdW5kZWRSZWN0YW5nbGU+XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibWFya2VyUmVjdGFuZ2xlc1wiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiBuZXcgTGlzdFRlbXBsYXRlKFRlbXBsYXRlLm5ldyh7fSksICgpID0+IFJvdW5kZWRSZWN0YW5nbGUuX25ldyh0aGlzLl9yb290LCB7XHJcbiAgICAgICAgICAgICAgICB0aGVtZVRhZ3M6ICR1dGlscy5tZXJnZVRhZ3ModGhpcy5tYXJrZXJSZWN0YW5nbGVzLnRlbXBsYXRlLmdldChcInRoZW1lVGFnc1wiLCBbXSksIFtcImxlZ2VuZFwiLCBcIm1hcmtlclwiLCBcInJlY3RhbmdsZVwiXSlcclxuICAgICAgICAgICAgfSwgW3RoaXMubWFya2VyUmVjdGFuZ2xlcy50ZW1wbGF0ZV0pKVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgX2FmdGVyTmV3KCkge1xyXG4gICAgICAgIHRoaXMuX3NldHRpbmdzLnRoZW1lVGFncyA9ICR1dGlscy5tZXJnZVRhZ3ModGhpcy5fc2V0dGluZ3MudGhlbWVUYWdzLCBbXCJsZWdlbmRcIl0pO1xyXG4gICAgICAgIHRoaXMuZmllbGRzLnB1c2goXCJuYW1lXCIsIFwic3Ryb2tlXCIsIFwiZmlsbFwiKTtcclxuICAgICAgICBzdXBlci5fYWZ0ZXJOZXcoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQGlnbm9yZVxyXG4gICAgICovXHJcbiAgICBtYWtlSXRlbUNvbnRhaW5lcihkYXRhSXRlbSkge1xyXG4gICAgICAgIGNvbnN0IGl0ZW1Db250YWluZXIgPSB0aGlzLmNoaWxkcmVuLnB1c2godGhpcy5pdGVtQ29udGFpbmVycy5tYWtlKCkpO1xyXG4gICAgICAgIGl0ZW1Db250YWluZXIuX3NldERhdGFJdGVtKGRhdGFJdGVtKTtcclxuICAgICAgICB0aGlzLml0ZW1Db250YWluZXJzLnB1c2goaXRlbUNvbnRhaW5lcik7XHJcbiAgICAgICAgaXRlbUNvbnRhaW5lci5zdGF0ZXMuY3JlYXRlKFwiZGlzYWJsZWRcIiwge30pO1xyXG4gICAgICAgIHJldHVybiBpdGVtQ29udGFpbmVyO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAaWdub3JlXHJcbiAgICAgKi9cclxuICAgIG1ha2VNYXJrZXIoKSB7XHJcbiAgICAgICAgY29uc3QgbWFya2VyID0gdGhpcy5tYXJrZXJzLm1ha2UoKTtcclxuICAgICAgICB0aGlzLm1hcmtlcnMucHVzaChtYXJrZXIpO1xyXG4gICAgICAgIG1hcmtlci5zdGF0ZXMuY3JlYXRlKFwiZGlzYWJsZWRcIiwge30pO1xyXG4gICAgICAgIHJldHVybiBtYXJrZXI7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEBpZ25vcmVcclxuICAgICAqL1xyXG4gICAgbWFrZUxhYmVsKCkge1xyXG4gICAgICAgIGNvbnN0IGxhYmVsID0gdGhpcy5sYWJlbHMubWFrZSgpO1xyXG4gICAgICAgIGxhYmVsLnN0YXRlcy5jcmVhdGUoXCJkaXNhYmxlZFwiLCB7fSk7XHJcbiAgICAgICAgcmV0dXJuIGxhYmVsO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAaWdub3JlXHJcbiAgICAgKi9cclxuICAgIG1ha2VWYWx1ZUxhYmVsKCkge1xyXG4gICAgICAgIGNvbnN0IHZhbHVlTGFiZWwgPSB0aGlzLnZhbHVlTGFiZWxzLm1ha2UoKTtcclxuICAgICAgICB2YWx1ZUxhYmVsLnN0YXRlcy5jcmVhdGUoXCJkaXNhYmxlZFwiLCB7fSk7XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlTGFiZWw7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEBpZ25vcmVcclxuICAgICAqL1xyXG4gICAgbWFrZU1hcmtlclJlY3RhbmdsZSgpIHtcclxuICAgICAgICBjb25zdCBtYXJrZXJSZWN0YW5nbGUgPSB0aGlzLm1hcmtlclJlY3RhbmdsZXMubWFrZSgpO1xyXG4gICAgICAgIG1hcmtlclJlY3RhbmdsZS5zdGF0ZXMuY3JlYXRlKFwiZGlzYWJsZWRcIiwge30pO1xyXG4gICAgICAgIHJldHVybiBtYXJrZXJSZWN0YW5nbGU7XHJcbiAgICB9XHJcbiAgICBwcm9jZXNzRGF0YUl0ZW0oZGF0YUl0ZW0pIHtcclxuICAgICAgICBzdXBlci5wcm9jZXNzRGF0YUl0ZW0oZGF0YUl0ZW0pO1xyXG4gICAgICAgIGNvbnN0IGl0ZW1Db250YWluZXIgPSB0aGlzLm1ha2VJdGVtQ29udGFpbmVyKGRhdGFJdGVtKTtcclxuICAgICAgICBjb25zdCBuYW1lRmllbGQgPSB0aGlzLmdldChcIm5hbWVGaWVsZFwiKTtcclxuICAgICAgICBjb25zdCBmaWxsRmllbGQgPSB0aGlzLmdldChcImZpbGxGaWVsZFwiKTtcclxuICAgICAgICBjb25zdCBzdHJva2VGaWVsZCA9IHRoaXMuZ2V0KFwic3Ryb2tlRmllbGRcIik7XHJcbiAgICAgICAgaWYgKGl0ZW1Db250YWluZXIpIHtcclxuICAgICAgICAgICAgY29uc3QgY2xpY2tUYXJnZXQgPSB0aGlzLmdldChcImNsaWNrVGFyZ2V0XCIsIFwiaXRlbUNvbnRhaW5lclwiKTtcclxuICAgICAgICAgICAgY29uc3QgaXRlbSA9IGRhdGFJdGVtLmRhdGFDb250ZXh0O1xyXG4gICAgICAgICAgICBpZiAoaXRlbSAmJiBpdGVtLnNldCkge1xyXG4gICAgICAgICAgICAgICAgaXRlbS5zZXQoXCJsZWdlbmREYXRhSXRlbVwiLCBkYXRhSXRlbSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaXRlbUNvbnRhaW5lci5fc2V0RGF0YUl0ZW0oZGF0YUl0ZW0pO1xyXG4gICAgICAgICAgICBkYXRhSXRlbS5zZXQoXCJpdGVtQ29udGFpbmVyXCIsIGl0ZW1Db250YWluZXIpO1xyXG4gICAgICAgICAgICBjb25zdCBtYXJrZXIgPSB0aGlzLm1ha2VNYXJrZXIoKTtcclxuICAgICAgICAgICAgaWYgKG1hcmtlcikge1xyXG4gICAgICAgICAgICAgICAgaXRlbUNvbnRhaW5lci5jaGlsZHJlbi5wdXNoKG1hcmtlcik7XHJcbiAgICAgICAgICAgICAgICBtYXJrZXIuX3NldERhdGFJdGVtKGRhdGFJdGVtKTtcclxuICAgICAgICAgICAgICAgIGRhdGFJdGVtLnNldChcIm1hcmtlclwiLCBtYXJrZXIpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdXNlRGVmYXVsdE1hcmtlciA9IHRoaXMuZ2V0KFwidXNlRGVmYXVsdE1hcmtlclwiKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG1hcmtlclJlY3RhbmdsZSA9IG1hcmtlci5jaGlsZHJlbi5wdXNoKHRoaXMubWFrZU1hcmtlclJlY3RhbmdsZSgpKTtcclxuICAgICAgICAgICAgICAgIGxldCBmaWxsID0gZGF0YUl0ZW0uZ2V0KFwiZmlsbFwiKTtcclxuICAgICAgICAgICAgICAgIGxldCBzdHJva2UgPSBkYXRhSXRlbS5nZXQoXCJzdHJva2VcIik7XHJcbiAgICAgICAgICAgICAgICBkYXRhSXRlbS5zZXQoXCJtYXJrZXJSZWN0YW5nbGVcIiwgbWFya2VyUmVjdGFuZ2xlKTtcclxuICAgICAgICAgICAgICAgIGlmIChpdGVtICYmIGl0ZW0uZ2V0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZmlsbCA9IGl0ZW0uZ2V0KGZpbGxGaWVsZCwgZmlsbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgc3Ryb2tlID0gaXRlbS5nZXQoc3Ryb2tlRmllbGQsIHN0cm9rZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoIXN0cm9rZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0cm9rZSA9IGZpbGw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoIXVzZURlZmF1bHRNYXJrZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbSAmJiBpdGVtLmNyZWF0ZUxlZ2VuZE1hcmtlcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtLmNyZWF0ZUxlZ2VuZE1hcmtlcigpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpdGVtLm9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0ub24oZmlsbEZpZWxkLCAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXJrZXJSZWN0YW5nbGUuc2V0KFwiZmlsbFwiLCBpdGVtLmdldChmaWxsRmllbGQpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0ub24oc3Ryb2tlRmllbGQsICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcmtlclJlY3RhbmdsZS5zZXQoXCJzdHJva2VcIiwgaXRlbS5nZXQoc3Ryb2tlRmllbGQpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgbWFya2VyUmVjdGFuZ2xlLnNldEFsbCh7IGZpbGwsIHN0cm9rZSB9KTtcclxuICAgICAgICAgICAgICAgIC8vIHRoaXMgc29sdmVzIGlmIHRlbXBsYXRlIGZpZWxkIGlzIHNldCBvbiBzbGljZVxyXG4gICAgICAgICAgICAgICAgY29uc3QgY29tcG9uZW50ID0gaXRlbS5jb21wb25lbnQ7XHJcbiAgICAgICAgICAgICAgICBpZiAoY29tcG9uZW50ICYmIGNvbXBvbmVudC51cGRhdGVMZWdlbmRNYXJrZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQudXBkYXRlTGVnZW5kTWFya2VyKGl0ZW0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IGxhYmVsID0gdGhpcy5tYWtlTGFiZWwoKTtcclxuICAgICAgICAgICAgaWYgKGxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICBpdGVtQ29udGFpbmVyLmNoaWxkcmVuLnB1c2gobGFiZWwpO1xyXG4gICAgICAgICAgICAgICAgbGFiZWwuX3NldERhdGFJdGVtKGRhdGFJdGVtKTtcclxuICAgICAgICAgICAgICAgIGRhdGFJdGVtLnNldChcImxhYmVsXCIsIGxhYmVsKTtcclxuICAgICAgICAgICAgICAgIGxhYmVsLnRleHQub24oXCJ0ZXh0XCIsICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBpdGVtQ29udGFpbmVyLnNldFJhdyhcImFyaWFMYWJlbFwiLCBsYWJlbC50ZXh0Ll9nZXRUZXh0KCkgKyAodGhpcy5nZXQoXCJjbGlja1RhcmdldFwiKSAhPT0gXCJub25lXCIgPyBcIjsgXCIgKyB0aGlzLl90KFwiUHJlc3MgRU5URVIgdG8gdG9nZ2xlXCIpIDogXCJcIikpO1xyXG4gICAgICAgICAgICAgICAgICAgIGl0ZW1Db250YWluZXIubWFya0RpcnR5QWNjZXNzaWJpbGl0eSgpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXRlbSAmJiBpdGVtLmdldCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRhdGFJdGVtLnNldChcIm5hbWVcIiwgaXRlbS5nZXQobmFtZUZpZWxkKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBsZXQgbmFtZSA9IGRhdGFJdGVtLmdldChcIm5hbWVcIik7XHJcbiAgICAgICAgICAgICAgICBpZiAobmFtZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxhYmVsLnNldChcInRleHRcIiwgbmFtZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgdmFsdWVMYWJlbCA9IHRoaXMubWFrZVZhbHVlTGFiZWwoKTtcclxuICAgICAgICAgICAgaWYgKHZhbHVlTGFiZWwpIHtcclxuICAgICAgICAgICAgICAgIGl0ZW1Db250YWluZXIuY2hpbGRyZW4ucHVzaCh2YWx1ZUxhYmVsKTtcclxuICAgICAgICAgICAgICAgIHZhbHVlTGFiZWwuX3NldERhdGFJdGVtKGRhdGFJdGVtKTtcclxuICAgICAgICAgICAgICAgIGRhdGFJdGVtLnNldChcInZhbHVlTGFiZWxcIiwgdmFsdWVMYWJlbCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGl0ZW0gJiYgaXRlbS5zaG93KSB7XHJcbiAgICAgICAgICAgICAgICBpdGVtLm9uKFwidmlzaWJsZVwiLCAodmlzaWJsZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGl0ZW1Db250YWluZXIuc2V0KFwiZGlzYWJsZWRcIiwgIXZpc2libGUpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWl0ZW0uZ2V0KFwidmlzaWJsZVwiKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGl0ZW1Db250YWluZXIuc2V0KFwiZGlzYWJsZWRcIiwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoY2xpY2tUYXJnZXQgIT0gXCJub25lXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgY2xpY2tDb250YWluZXIgPSBpdGVtQ29udGFpbmVyO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjbGlja1RhcmdldCA9PSBcIm1hcmtlclwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsaWNrQ29udGFpbmVyID0gbWFya2VyO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9hZGRDbGlja0V2ZW50cyhjbGlja0NvbnRhaW5lciwgaXRlbSwgZGF0YUl0ZW0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIFNvcnQgY2hpbGRyZW5cclxuICAgICAgICAgICAgdGhpcy5jaGlsZHJlbi52YWx1ZXMuc29ydCgoYSwgYikgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdGFyZ2V0QSA9IGEuZGF0YUl0ZW0uZGF0YUNvbnRleHQ7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB0YXJnZXRCID0gYi5kYXRhSXRlbS5kYXRhQ29udGV4dDtcclxuICAgICAgICAgICAgICAgIGlmICh0YXJnZXRBICYmIHRhcmdldEIpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBpbmRleEEgPSB0aGlzLmRhdGEuaW5kZXhPZih0YXJnZXRBKTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBpbmRleEIgPSB0aGlzLmRhdGEuaW5kZXhPZih0YXJnZXRCKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXhBID4gaW5kZXhCKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAxO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChpbmRleEEgPCBpbmRleEIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgaWYgKGl0ZW0gJiYgaXRlbS51cGRhdGVMZWdlbmRWYWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgaXRlbS51cGRhdGVMZWdlbmRWYWx1ZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgX2FkZENsaWNrRXZlbnRzKGNvbnRhaW5lciwgaXRlbSwgZGF0YUl0ZW0pIHtcclxuICAgICAgICBjb250YWluZXIuc2V0KFwiY3Vyc29yT3ZlclN0eWxlXCIsIFwicG9pbnRlclwiKTtcclxuICAgICAgICBjb250YWluZXIuZXZlbnRzLm9uKFwicG9pbnRlcm92ZXJcIiwgKCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBjb21wb25lbnQgPSBpdGVtLmNvbXBvbmVudDtcclxuICAgICAgICAgICAgaWYgKGNvbXBvbmVudCAmJiBjb21wb25lbnQuaG92ZXJEYXRhSXRlbSkge1xyXG4gICAgICAgICAgICAgICAgY29tcG9uZW50LmhvdmVyRGF0YUl0ZW0oaXRlbSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICBjb250YWluZXIuZXZlbnRzLm9uKFwicG9pbnRlcm91dFwiLCAoKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNvbXBvbmVudCA9IGl0ZW0uY29tcG9uZW50O1xyXG4gICAgICAgICAgICBpZiAoY29tcG9uZW50ICYmIGNvbXBvbmVudC5ob3ZlckRhdGFJdGVtKSB7XHJcbiAgICAgICAgICAgICAgICBjb21wb25lbnQudW5ob3ZlckRhdGFJdGVtKGl0ZW0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgY29udGFpbmVyLmV2ZW50cy5vbihcImNsaWNrXCIsICgpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgbGFiZWxUZXh0ID0gZGF0YUl0ZW0uZ2V0KFwibGFiZWxcIikudGV4dC5fZ2V0VGV4dCgpO1xyXG4gICAgICAgICAgICBpZiAoaXRlbS5zaG93ICYmIGl0ZW0uaXNIaWRkZW4gJiYgKGl0ZW0uaXNIaWRkZW4oKSB8fCBpdGVtLmdldChcInZpc2libGVcIikgPT09IGZhbHNlKSkge1xyXG4gICAgICAgICAgICAgICAgaXRlbS5zaG93KCk7XHJcbiAgICAgICAgICAgICAgICBjb250YWluZXIuc2V0KFwiZGlzYWJsZWRcIiwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcm9vdC5yZWFkZXJBbGVydCh0aGlzLl90KFwiJTEgc2hvd25cIiwgdGhpcy5fcm9vdC5sb2NhbGUsIGxhYmVsVGV4dCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGl0ZW0uaGlkZSkge1xyXG4gICAgICAgICAgICAgICAgaXRlbS5oaWRlKCk7XHJcbiAgICAgICAgICAgICAgICBjb250YWluZXIuc2V0KFwiZGlzYWJsZWRcIiwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9yb290LnJlYWRlckFsZXJ0KHRoaXMuX3QoXCIlMSBoaWRkZW5cIiwgdGhpcy5fcm9vdC5sb2NhbGUsIGxhYmVsVGV4dCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEBpZ25vcmVcclxuICAgICAqL1xyXG4gICAgZGlzcG9zZURhdGFJdGVtKGRhdGFJdGVtKSB7XHJcbiAgICAgICAgc3VwZXIuZGlzcG9zZURhdGFJdGVtKGRhdGFJdGVtKTtcclxuICAgICAgICBjb25zdCBkYXRhQ29udGV4dCA9IGRhdGFJdGVtLmRhdGFDb250ZXh0O1xyXG4gICAgICAgIGlmIChkYXRhQ29udGV4dCAmJiBkYXRhQ29udGV4dC5nZXQpIHtcclxuICAgICAgICAgICAgY29uc3QgZGkgPSBkYXRhQ29udGV4dC5nZXQoXCJsZWdlbmREYXRhSXRlbVwiKTtcclxuICAgICAgICAgICAgaWYgKGRpID09IGRhdGFJdGVtKSB7XHJcbiAgICAgICAgICAgICAgICBkYXRhQ29udGV4dC5zZXQoXCJsZWdlbmREYXRhSXRlbVwiLCB1bmRlZmluZWQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBpdGVtQ29udGFpbmVyID0gZGF0YUl0ZW0uZ2V0KFwiaXRlbUNvbnRhaW5lclwiKTtcclxuICAgICAgICBpZiAoaXRlbUNvbnRhaW5lcikge1xyXG4gICAgICAgICAgICB0aGlzLml0ZW1Db250YWluZXJzLnJlbW92ZVZhbHVlKGl0ZW1Db250YWluZXIpO1xyXG4gICAgICAgICAgICBpdGVtQ29udGFpbmVyLmRpc3Bvc2UoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IG1hcmtlciA9IGRhdGFJdGVtLmdldChcIm1hcmtlclwiKTtcclxuICAgICAgICBpZiAobWFya2VyKSB7XHJcbiAgICAgICAgICAgIHRoaXMubWFya2Vycy5yZW1vdmVWYWx1ZShtYXJrZXIpO1xyXG4gICAgICAgICAgICBtYXJrZXIuZGlzcG9zZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgbWFya2VyUmVjdGFuZ2xlID0gZGF0YUl0ZW0uZ2V0KFwibWFya2VyUmVjdGFuZ2xlXCIpO1xyXG4gICAgICAgIGlmIChtYXJrZXJSZWN0YW5nbGUpIHtcclxuICAgICAgICAgICAgdGhpcy5tYXJrZXJSZWN0YW5nbGVzLnJlbW92ZVZhbHVlKG1hcmtlclJlY3RhbmdsZSk7XHJcbiAgICAgICAgICAgIG1hcmtlclJlY3RhbmdsZS5kaXNwb3NlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBsYWJlbCA9IGRhdGFJdGVtLmdldChcImxhYmVsXCIpO1xyXG4gICAgICAgIGlmIChsYWJlbCkge1xyXG4gICAgICAgICAgICB0aGlzLmxhYmVscy5yZW1vdmVWYWx1ZShsYWJlbCk7XHJcbiAgICAgICAgICAgIGxhYmVsLmRpc3Bvc2UoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IHZhbHVlTGFiZWwgPSBkYXRhSXRlbS5nZXQoXCJ2YWx1ZUxhYmVsXCIpO1xyXG4gICAgICAgIGlmICh2YWx1ZUxhYmVsKSB7XHJcbiAgICAgICAgICAgIHRoaXMudmFsdWVMYWJlbHMucmVtb3ZlVmFsdWUodmFsdWVMYWJlbCk7XHJcbiAgICAgICAgICAgIHZhbHVlTGFiZWwuZGlzcG9zZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoTGVnZW5kLCBcImNsYXNzTmFtZVwiLCB7XHJcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICB2YWx1ZTogXCJMZWdlbmRcIlxyXG59KTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KExlZ2VuZCwgXCJjbGFzc05hbWVzXCIsIHtcclxuICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgIHZhbHVlOiBTZXJpZXMuY2xhc3NOYW1lcy5jb25jYXQoW0xlZ2VuZC5jbGFzc05hbWVdKVxyXG59KTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TGVnZW5kLmpzLm1hcCIsImltcG9ydCB7IEdyYXBoaWNzIH0gZnJvbSBcIi4vR3JhcGhpY3NcIjtcclxuaW1wb3J0ICogYXMgJGRyYXcgZnJvbSBcIi4uL3V0aWwvRHJhd1wiO1xyXG4vKipcclxuICogRHJhd3MgYSBsaW5lLlxyXG4gKlxyXG4gKiBAc2VlIHtAbGluayBodHRwczovL3d3dy5hbWNoYXJ0cy5jb20vZG9jcy92NS9jb25jZXB0cy9jb21tb24tZWxlbWVudHMvZ3JhcGhpY3MvfSBmb3IgbW9yZSBpbmZvXHJcbiAqIEBpbXBvcnRhbnRcclxuICovXHJcbmV4cG9ydCBjbGFzcyBMaW5lIGV4dGVuZHMgR3JhcGhpY3Mge1xyXG4gICAgX2JlZm9yZUNoYW5nZWQoKSB7XHJcbiAgICAgICAgc3VwZXIuX2JlZm9yZUNoYW5nZWQoKTtcclxuICAgICAgICBpZiAodGhpcy5pc0RpcnR5KFwicG9pbnRzXCIpIHx8IHRoaXMuaXNEaXJ0eShcInNlZ21lbnRzXCIpIHx8IHRoaXMuX3NpemVEaXJ0eSB8fCB0aGlzLmlzUHJpdmF0ZURpcnR5KFwid2lkdGhcIikgfHwgdGhpcy5pc1ByaXZhdGVEaXJ0eShcImhlaWdodFwiKSkge1xyXG4gICAgICAgICAgICB0aGlzLl9jbGVhciA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgX2NoYW5nZWQoKSB7XHJcbiAgICAgICAgc3VwZXIuX2NoYW5nZWQoKTtcclxuICAgICAgICBpZiAodGhpcy5fY2xlYXIpIHtcclxuICAgICAgICAgICAgY29uc3QgcG9pbnRzID0gdGhpcy5nZXQoXCJwb2ludHNcIik7XHJcbiAgICAgICAgICAgIGNvbnN0IHNlZ21lbnRzID0gdGhpcy5nZXQoXCJzZWdtZW50c1wiKTtcclxuICAgICAgICAgICAgaWYgKHBvaW50cyAmJiBwb2ludHMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgbGV0IHBvaW50ID0gcG9pbnRzWzBdO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZGlzcGxheS5tb3ZlVG8ocG9pbnQueCwgcG9pbnQueSk7XHJcbiAgICAgICAgICAgICAgICAkZHJhdy5zZWdtZW50ZWRMaW5lKHRoaXMuX2Rpc3BsYXksIFtbcG9pbnRzXV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHNlZ21lbnRzKSB7XHJcbiAgICAgICAgICAgICAgICAkZHJhdy5zZWdtZW50ZWRMaW5lKHRoaXMuX2Rpc3BsYXksIHNlZ21lbnRzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICghdGhpcy5nZXQoXCJkcmF3XCIpKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgdyA9IHRoaXMud2lkdGgoKTtcclxuICAgICAgICAgICAgICAgIGxldCBoID0gdGhpcy5oZWlnaHQoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2Rpc3BsYXkubW92ZVRvKDAsIDApO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZGlzcGxheS5saW5lVG8odywgaCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KExpbmUsIFwiY2xhc3NOYW1lXCIsIHtcclxuICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgIHZhbHVlOiBcIkxpbmVcIlxyXG59KTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KExpbmUsIFwiY2xhc3NOYW1lc1wiLCB7XHJcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICB2YWx1ZTogR3JhcGhpY3MuY2xhc3NOYW1lcy5jb25jYXQoW0xpbmUuY2xhc3NOYW1lXSlcclxufSk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUxpbmUuanMubWFwIiwiaW1wb3J0IHsgR3JhcGhpY3MgfSBmcm9tIFwiLi9HcmFwaGljc1wiO1xyXG5pbXBvcnQgKiBhcyAkbWF0aCBmcm9tIFwiLi4vdXRpbC9NYXRoXCI7XHJcbi8qKlxyXG4gKiBEcmF3cyBhIHJlY3RhbmdsZSB3aXRoIGEgcG9pbnRlci5cclxuICpcclxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly93d3cuYW1jaGFydHMuY29tL2RvY3MvdjUvY29uY2VwdHMvY29tbW9uLWVsZW1lbnRzL2dyYXBoaWNzL30gZm9yIG1vcmUgaW5mb1xyXG4gKiBAaW1wb3J0YW50XHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgUG9pbnRlZFJlY3RhbmdsZSBleHRlbmRzIEdyYXBoaWNzIHtcclxuICAgIF9iZWZvcmVDaGFuZ2VkKCkge1xyXG4gICAgICAgIHN1cGVyLl9iZWZvcmVDaGFuZ2VkKCk7XHJcbiAgICAgICAgaWYgKHRoaXMuaXNEaXJ0eShcInBvaW50ZXJCYXNlV2lkdGhcIikgfHwgdGhpcy5pc0RpcnR5KFwiY29ybmVyUmFkaXVzXCIpIHx8IHRoaXMuaXNEaXJ0eShcInBvaW50ZXJMZW5ndGhcIikgfHwgdGhpcy5pc0RpcnR5KFwicG9pbnRlclhcIikgfHwgdGhpcy5pc0RpcnR5KFwicG9pbnRlcllcIikgfHwgdGhpcy5pc0RpcnR5KFwid2lkdGhcIikgfHwgdGhpcy5pc0RpcnR5KFwiaGVpZ2h0XCIpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2NsZWFyID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBfY2hhbmdlZCgpIHtcclxuICAgICAgICBzdXBlci5fY2hhbmdlZCgpO1xyXG4gICAgICAgIGlmICh0aGlzLl9jbGVhcikge1xyXG4gICAgICAgICAgICB0aGlzLm1hcmtEaXJ0eUJvdW5kcygpO1xyXG4gICAgICAgICAgICBsZXQgdyA9IHRoaXMud2lkdGgoKTtcclxuICAgICAgICAgICAgbGV0IGggPSB0aGlzLmhlaWdodCgpO1xyXG4gICAgICAgICAgICBpZiAodyA+IDAgJiYgaCA+IDApIHtcclxuICAgICAgICAgICAgICAgIGxldCBjciA9IHRoaXMuZ2V0KFwiY29ybmVyUmFkaXVzXCIsIDgpO1xyXG4gICAgICAgICAgICAgICAgY3IgPSAkbWF0aC5maXRUb1JhbmdlKGNyLCAwLCBNYXRoLm1pbih3IC8gMiwgaCAvIDIpKTtcclxuICAgICAgICAgICAgICAgIGxldCB4ID0gdGhpcy5nZXQoXCJwb2ludGVyWFwiLCAwKTtcclxuICAgICAgICAgICAgICAgIGxldCB5ID0gdGhpcy5nZXQoXCJwb2ludGVyWVwiLCAwKTtcclxuICAgICAgICAgICAgICAgIGxldCBid2ggPSB0aGlzLmdldChcInBvaW50ZXJCYXNlV2lkdGhcIiwgMTUpIC8gMjtcclxuICAgICAgICAgICAgICAgIC8vIGNvcm5lciBjb29yZGluYXRlc1xyXG4gICAgICAgICAgICAgICAgLy8gdG9wIGxlZnRcclxuICAgICAgICAgICAgICAgIGxldCB4dGwgPSAwO1xyXG4gICAgICAgICAgICAgICAgbGV0IHl0bCA9IDA7XHJcbiAgICAgICAgICAgICAgICAvLyB0b3AgcmlnaHRcclxuICAgICAgICAgICAgICAgIGxldCB4dHIgPSB3O1xyXG4gICAgICAgICAgICAgICAgbGV0IHl0ciA9IDA7XHJcbiAgICAgICAgICAgICAgICAvLyBib3R0b20gcmlnaHRcclxuICAgICAgICAgICAgICAgIGxldCB4YnIgPSB3O1xyXG4gICAgICAgICAgICAgICAgbGV0IHliciA9IGg7XHJcbiAgICAgICAgICAgICAgICAvLyBib3R0b20gbGVmdFxyXG4gICAgICAgICAgICAgICAgbGV0IHhibCA9IDA7XHJcbiAgICAgICAgICAgICAgICBsZXQgeWJsID0gaDtcclxuICAgICAgICAgICAgICAgIC8vIGZpbmQgc3RlbSBiYXNlIHNpZGU6IGh0dHA6Ly8kbWF0aC5zdGFja2V4Y2hhbmdlLmNvbS9xdWVzdGlvbnMvMjc0NzEyL2NhbGN1bGF0ZS1vbi13aGljaC1zaWRlLW9mLXN0cmFpZ24tbGluZS1pcy1kb3QtbG9jYXRlZFxyXG4gICAgICAgICAgICAgICAgLy8gZD0oeOKIkngxKSh5MuKIknkxKeKIkih54oiSeTEpKHgy4oiSeDEpXHJcbiAgICAgICAgICAgICAgICBsZXQgZDEgPSAoeCAtIHh0bCkgKiAoeWJyIC0geXRsKSAtICh5IC0geXRsKSAqICh4YnIgLSB4dGwpO1xyXG4gICAgICAgICAgICAgICAgbGV0IGQyID0gKHggLSB4YmwpICogKHl0ciAtIHlibCkgLSAoeSAtIHlibCkgKiAoeHRyIC0geGJsKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGRpc3BsYXkgPSB0aGlzLl9kaXNwbGF5O1xyXG4gICAgICAgICAgICAgICAgLy8gdG9wXHJcbiAgICAgICAgICAgICAgICBkaXNwbGF5Lm1vdmVUbyhjciwgMCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoZDEgPiAwICYmIGQyID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBzdGVtWCA9IE1hdGgucm91bmQoJG1hdGguZml0VG9SYW5nZSh4LCBjciArIGJ3aCwgdyAtIGJ3aCAtIGNyKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgeSA9ICRtYXRoLmZpdFRvUmFuZ2UoeSwgLUluZmluaXR5LCAwKTtcclxuICAgICAgICAgICAgICAgICAgICBkaXNwbGF5LmxpbmVUbyhzdGVtWCAtIGJ3aCwgMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheS5saW5lVG8oeCwgeSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheS5saW5lVG8oc3RlbVggKyBid2gsIDApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZGlzcGxheS5saW5lVG8odyAtIGNyLCAwKTtcclxuICAgICAgICAgICAgICAgIGRpc3BsYXkuYXJjVG8odywgMCwgdywgY3IsIGNyKTtcclxuICAgICAgICAgICAgICAgIC8vIHJpZ2h0XHJcbiAgICAgICAgICAgICAgICBpZiAoZDEgPiAwICYmIGQyIDwgMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBzdGVtWSA9IE1hdGgucm91bmQoJG1hdGguZml0VG9SYW5nZSh5LCBjciArIGJ3aCwgaCAtIGJ3aCAtIGNyKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgeCA9ICRtYXRoLmZpdFRvUmFuZ2UoeCwgdywgSW5maW5pdHkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGRpc3BsYXkubGluZVRvKHcsIGNyKTtcclxuICAgICAgICAgICAgICAgICAgICBkaXNwbGF5LmxpbmVUbyh3LCBNYXRoLm1heChzdGVtWSAtIGJ3aCwgY3IpKTtcclxuICAgICAgICAgICAgICAgICAgICBkaXNwbGF5LmxpbmVUbyh4LCB5KTtcclxuICAgICAgICAgICAgICAgICAgICBkaXNwbGF5LmxpbmVUbyh3LCBzdGVtWSArIGJ3aCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBkaXNwbGF5LmxpbmVUbyh3LCBoIC0gY3IpO1xyXG4gICAgICAgICAgICAgICAgZGlzcGxheS5hcmNUbyh3LCBoLCB3IC0gY3IsIGgsIGNyKTtcclxuICAgICAgICAgICAgICAgIC8vIGJvdHRvbVxyXG4gICAgICAgICAgICAgICAgaWYgKGQxIDwgMCAmJiBkMiA8IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgc3RlbVggPSBNYXRoLnJvdW5kKCRtYXRoLmZpdFRvUmFuZ2UoeCwgY3IgKyBid2gsIHcgLSBid2ggLSBjcikpO1xyXG4gICAgICAgICAgICAgICAgICAgIHkgPSAkbWF0aC5maXRUb1JhbmdlKHksIGgsIEluZmluaXR5KTtcclxuICAgICAgICAgICAgICAgICAgICBkaXNwbGF5LmxpbmVUbyh3IC0gY3IsIGgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGRpc3BsYXkubGluZVRvKHN0ZW1YICsgYndoLCBoKTtcclxuICAgICAgICAgICAgICAgICAgICBkaXNwbGF5LmxpbmVUbyh4LCB5KTtcclxuICAgICAgICAgICAgICAgICAgICBkaXNwbGF5LmxpbmVUbyhzdGVtWCAtIGJ3aCwgaCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBkaXNwbGF5LmxpbmVUbyhjciwgaCk7XHJcbiAgICAgICAgICAgICAgICBkaXNwbGF5LmFyY1RvKDAsIGgsIDAsIGggLSBjciwgY3IpO1xyXG4gICAgICAgICAgICAgICAgLy8gbGVmdFxyXG4gICAgICAgICAgICAgICAgaWYgKGQxIDwgMCAmJiBkMiA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgc3RlbVkgPSBNYXRoLnJvdW5kKCRtYXRoLmZpdFRvUmFuZ2UoeSwgY3IgKyBid2gsIGggLSBjciAtIGJ3aCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIHggPSAkbWF0aC5maXRUb1JhbmdlKHgsIC1JbmZpbml0eSwgMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheS5saW5lVG8oMCwgaCAtIGNyKTtcclxuICAgICAgICAgICAgICAgICAgICBkaXNwbGF5LmxpbmVUbygwLCBzdGVtWSArIGJ3aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheS5saW5lVG8oeCwgeSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheS5saW5lVG8oMCwgTWF0aC5tYXgoc3RlbVkgLSBid2gsIGNyKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBkaXNwbGF5LmxpbmVUbygwLCBjcik7XHJcbiAgICAgICAgICAgICAgICBkaXNwbGF5LmFyY1RvKDAsIDAsIGNyLCAwLCBjcik7XHJcbiAgICAgICAgICAgICAgICBkaXNwbGF5LmNsb3NlUGF0aCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShQb2ludGVkUmVjdGFuZ2xlLCBcImNsYXNzTmFtZVwiLCB7XHJcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICB2YWx1ZTogXCJQb2ludGVkUmVjdGFuZ2xlXCJcclxufSk7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShQb2ludGVkUmVjdGFuZ2xlLCBcImNsYXNzTmFtZXNcIiwge1xyXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgdmFsdWU6IEdyYXBoaWNzLmNsYXNzTmFtZXMuY29uY2F0KFtQb2ludGVkUmVjdGFuZ2xlLmNsYXNzTmFtZV0pXHJcbn0pO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1Qb2ludGVkUmVjdGFuZ2xlLmpzLm1hcCIsIi8vIGltcG9ydCAqIGFzICRvYmplY3QgZnJvbSBcIi4uL3V0aWwvT2JqZWN0XCI7XHJcbmltcG9ydCB7IHA1MCwgUGVyY2VudCB9IGZyb20gXCIuLi91dGlsL1BlcmNlbnRcIjtcclxuaW1wb3J0IHsgTGFiZWwgfSBmcm9tIFwiLi9MYWJlbFwiO1xyXG5pbXBvcnQgeyBSYWRpYWxUZXh0IH0gZnJvbSBcIi4vUmFkaWFsVGV4dFwiO1xyXG5pbXBvcnQgKiBhcyAkbWF0aCBmcm9tIFwiLi4vdXRpbC9NYXRoXCI7XHJcbmltcG9ydCAqIGFzICR1dGlscyBmcm9tIFwiLi4vdXRpbC9VdGlsc1wiO1xyXG5leHBvcnQgY2xhc3MgUmFkaWFsTGFiZWwgZXh0ZW5kcyBMYWJlbCB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9mbGlwcGVkXCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IGZhbHNlXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBfYWZ0ZXJOZXcoKSB7XHJcbiAgICAgICAgdGhpcy5fdGV4dEtleXMucHVzaChcInRleHRUeXBlXCIsIFwia2VybmluZ1wiKTtcclxuICAgICAgICBzdXBlci5fYWZ0ZXJOZXcoKTtcclxuICAgIH1cclxuICAgIF9tYWtlVGV4dCgpIHtcclxuICAgICAgICB0aGlzLl90ZXh0ID0gdGhpcy5jaGlsZHJlbi5wdXNoKFJhZGlhbFRleHQubmV3KHRoaXMuX3Jvb3QsIHt9KSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYmFzZSByYWRpdXMgaW4gcGl4ZWxzLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm4gQmFzZSByYWRpdXNcclxuICAgICAqL1xyXG4gICAgYmFzZVJhZGl1cygpIHtcclxuICAgICAgICBjb25zdCByYWRpdXNQcml2YXRlID0gdGhpcy5nZXRQcml2YXRlKFwicmFkaXVzXCIsIDApO1xyXG4gICAgICAgIGNvbnN0IGlubmVyUmFkaXVzUHJpdmF0ZSA9IHRoaXMuZ2V0UHJpdmF0ZShcImlubmVyUmFkaXVzXCIsIDApO1xyXG4gICAgICAgIGNvbnN0IGJhc2VSYWRpdXMgPSB0aGlzLmdldChcImJhc2VSYWRpdXNcIiwgMCk7XHJcbiAgICAgICAgcmV0dXJuIGlubmVyUmFkaXVzUHJpdmF0ZSArICR1dGlscy5yZWxhdGl2ZVRvVmFsdWUoYmFzZVJhZGl1cywgcmFkaXVzUHJpdmF0ZSAtIGlubmVyUmFkaXVzUHJpdmF0ZSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgcmFkaXVzIGFkanVzdG1lbnQgaW4gcGl4ZWxzLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm4gUmFkaXVzXHJcbiAgICAgKi9cclxuICAgIHJhZGl1cygpIHtcclxuICAgICAgICBjb25zdCBpbnNpZGUgPSB0aGlzLmdldChcImluc2lkZVwiLCBmYWxzZSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYmFzZVJhZGl1cygpICsgdGhpcy5nZXQoXCJyYWRpdXNcIiwgMCkgKiAoaW5zaWRlID8gLTEgOiAxKTtcclxuICAgIH1cclxuICAgIF91cGRhdGVDaGlsZHJlbigpIHtcclxuICAgICAgICBzdXBlci5fdXBkYXRlQ2hpbGRyZW4oKTtcclxuICAgICAgICBpZiAodGhpcy5pc0RpcnR5KFwiYmFzZVJhZGl1c1wiKSB8fCB0aGlzLmlzUHJpdmF0ZURpcnR5KFwicmFkaXVzXCIpIHx8IHRoaXMuaXNQcml2YXRlRGlydHkoXCJpbm5lclJhZGl1c1wiKSB8fCB0aGlzLmlzRGlydHkoXCJsYWJlbEFuZ2xlXCIpIHx8IHRoaXMuaXNEaXJ0eShcInJhZGl1c1wiKSB8fCB0aGlzLmlzRGlydHkoXCJpbnNpZGVcIikgfHwgdGhpcy5pc0RpcnR5KFwib3JpZW50YXRpb25cIikgfHwgdGhpcy5pc0RpcnR5KFwidGV4dFR5cGVcIikpIHtcclxuICAgICAgICAgICAgY29uc3QgdGV4dFR5cGUgPSB0aGlzLmdldChcInRleHRUeXBlXCIsIFwiYWRqdXN0ZWRcIik7XHJcbiAgICAgICAgICAgIGNvbnN0IGluc2lkZSA9IHRoaXMuZ2V0KFwiaW5zaWRlXCIsIGZhbHNlKTtcclxuICAgICAgICAgICAgY29uc3Qgb3JpZW50YXRpb24gPSB0aGlzLmdldChcIm9yaWVudGF0aW9uXCIpO1xyXG4gICAgICAgICAgICBsZXQgbGFiZWxBbmdsZSA9ICRtYXRoLm5vcm1hbGl6ZUFuZ2xlKHRoaXMuZ2V0KFwibGFiZWxBbmdsZVwiLCAwKSk7XHJcbiAgICAgICAgICAgIHRoaXMuX3RleHQuc2V0KFwic3RhcnRBbmdsZVwiLCB0aGlzLmdldChcImxhYmVsQW5nbGVcIiwgMCkpO1xyXG4gICAgICAgICAgICB0aGlzLl90ZXh0LnNldChcImluc2lkZVwiLCBpbnNpZGUpO1xyXG4gICAgICAgICAgICBjb25zdCBzaW4gPSAkbWF0aC5zaW4obGFiZWxBbmdsZSk7XHJcbiAgICAgICAgICAgIGNvbnN0IGNvcyA9ICRtYXRoLmNvcyhsYWJlbEFuZ2xlKTtcclxuICAgICAgICAgICAgbGV0IGJhc2VSYWRpdXMgPSB0aGlzLmJhc2VSYWRpdXMoKTtcclxuICAgICAgICAgICAgbGV0IHJhZGl1cyA9IHRoaXMucmFkaXVzKCk7XHJcbiAgICAgICAgICAgIHRoaXMuX2Rpc3BsYXkuYW5nbGUgPSAwO1xyXG4gICAgICAgICAgICBpZiAodGV4dFR5cGUgPT0gXCJjaXJjdWxhclwiKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNldEFsbCh7XHJcbiAgICAgICAgICAgICAgICAgICAgcGFkZGluZ1RvcDogMCxcclxuICAgICAgICAgICAgICAgICAgICBwYWRkaW5nQm90dG9tOiAwLFxyXG4gICAgICAgICAgICAgICAgICAgIHBhZGRpbmdMZWZ0OiAwLFxyXG4gICAgICAgICAgICAgICAgICAgIHBhZGRpbmdSaWdodDogMFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAvLyBDaXJjdWxhciBsYWJlbHMgYXJlIGhhbmRsZWQgYW5kIHBvc2l0aW9uZWQgZGlmZmVyZW50bHlcclxuICAgICAgICAgICAgICAgIHRoaXMuX3RleHQuc2V0KFwib3JpZW50YXRpb25cIiwgb3JpZW50YXRpb24pO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fdGV4dC5zZXQoXCJyYWRpdXNcIiwgcmFkaXVzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlmIChiYXNlUmFkaXVzID09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBsYWJlbEFuZ2xlID0gMDtcclxuICAgICAgICAgICAgICAgICAgICByYWRpdXMgPSAwO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gUG9zaXRpb25pbmcgb2YgcmFkaWFsL3JlZ3VsYXIgbGFiZWxzIGFyZSB0ZWggc2FtZVxyXG4gICAgICAgICAgICAgICAgbGV0IHggPSByYWRpdXMgKiBjb3M7XHJcbiAgICAgICAgICAgICAgICBsZXQgeSA9IHJhZGl1cyAqIHNpbjtcclxuICAgICAgICAgICAgICAgIGlmICh0ZXh0VHlwZSA9PSBcInJhZGlhbFwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRSYXcoXCJ4XCIsIHgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0UmF3KFwieVwiLCB5KTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoKGxhYmVsQW5nbGUgPCA5MCkgfHwgKGxhYmVsQW5nbGUgPiAyNzApIHx8IG9yaWVudGF0aW9uICE9IFwiYXV0b1wiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2Rpc3BsYXkuYW5nbGUgPSBsYWJlbEFuZ2xlOyAvLyArIDkwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9mbGlwcGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9kaXNwbGF5LmFuZ2xlID0gbGFiZWxBbmdsZSArIDE4MDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZmxpcHBlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RpcnR5LnJvdGF0aW9uID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0ZXh0VHlwZSA9PSBcImFkanVzdGVkXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFJhdyhcImNlbnRlclhcIiwgcDUwKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFJhdyhcImNlbnRlcllcIiwgcDUwKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFJhdyhcInhcIiwgeCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRSYXcoXCJ5XCIsIHkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodGV4dFR5cGUgPT0gXCJyZWd1bGFyXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFJhdyhcInhcIiwgeCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRSYXcoXCJ5XCIsIHkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMubWFya0RpcnR5UG9zaXRpb24oKTtcclxuICAgICAgICAgICAgdGhpcy5tYXJrRGlydHlCb3VuZHMoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBfdXBkYXRlUG9zaXRpb24oKSB7XHJcbiAgICAgICAgY29uc3QgdGV4dFR5cGUgPSB0aGlzLmdldChcInRleHRUeXBlXCIsIFwicmVndWxhclwiKTtcclxuICAgICAgICBjb25zdCBpbnNpZGUgPSB0aGlzLmdldChcImluc2lkZVwiLCBmYWxzZSk7XHJcbiAgICAgICAgbGV0IGR4ID0gMDtcclxuICAgICAgICBsZXQgZHkgPSAwO1xyXG4gICAgICAgIGxldCBsYWJlbEFuZ2xlID0gdGhpcy5nZXQoXCJsYWJlbEFuZ2xlXCIsIDApO1xyXG4gICAgICAgIGxldCBib3VuZHMgPSB0aGlzLmxvY2FsQm91bmRzKCk7XHJcbiAgICAgICAgbGV0IHcgPSBib3VuZHMucmlnaHQgLSBib3VuZHMubGVmdDtcclxuICAgICAgICBsZXQgaCA9IGJvdW5kcy5ib3R0b20gLSBib3VuZHMudG9wO1xyXG4gICAgICAgIGlmICh0ZXh0VHlwZSA9PSBcInJhZGlhbFwiKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9mbGlwcGVkKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgY2VudGVyWCA9IHRoaXMuZ2V0KFwiY2VudGVyWFwiKTtcclxuICAgICAgICAgICAgICAgIGlmIChjZW50ZXJYIGluc3RhbmNlb2YgUGVyY2VudCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHcgPSB3ICogKDEgLSBjZW50ZXJYLnZhbHVlICogMik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBkeCA9IHcgKiAkbWF0aC5jb3MobGFiZWxBbmdsZSk7XHJcbiAgICAgICAgICAgICAgICBkeSA9IHcgKiAkbWF0aC5zaW4obGFiZWxBbmdsZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoIWluc2lkZSAmJiB0ZXh0VHlwZSA9PSBcImFkanVzdGVkXCIpIHtcclxuICAgICAgICAgICAgZHggPSB3IC8gMiAqICRtYXRoLmNvcyhsYWJlbEFuZ2xlKTtcclxuICAgICAgICAgICAgZHkgPSBoIC8gMiAqICRtYXRoLnNpbihsYWJlbEFuZ2xlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5zZXRSYXcoXCJkeFwiLCBkeCk7XHJcbiAgICAgICAgdGhpcy5zZXRSYXcoXCJkeVwiLCBkeSk7XHJcbiAgICAgICAgc3VwZXIuX3VwZGF0ZVBvc2l0aW9uKCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEBpZ25vcmVcclxuICAgICAqL1xyXG4gICAgZ2V0IHRleHQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RleHQ7XHJcbiAgICB9XHJcbn1cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFJhZGlhbExhYmVsLCBcImNsYXNzTmFtZVwiLCB7XHJcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICB2YWx1ZTogXCJSYWRpYWxMYWJlbFwiXHJcbn0pO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUmFkaWFsTGFiZWwsIFwiY2xhc3NOYW1lc1wiLCB7XHJcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICB2YWx1ZTogTGFiZWwuY2xhc3NOYW1lcy5jb25jYXQoW1JhZGlhbExhYmVsLmNsYXNzTmFtZV0pXHJcbn0pO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1SYWRpYWxMYWJlbC5qcy5tYXAiLCJpbXBvcnQgeyBUZXh0IH0gZnJvbSBcIi4vVGV4dFwiO1xyXG5pbXBvcnQgKiBhcyAkbWF0aCBmcm9tIFwiLi4vdXRpbC9NYXRoXCI7XHJcbi8qKlxyXG4gKiBAaWdub3JlXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgUmFkaWFsVGV4dCBleHRlbmRzIFRleHQge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfZGlzcGxheVwiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiB0aGlzLl9yb290Ll9yZW5kZXJlci5tYWtlUmFkaWFsVGV4dChcIlwiLCB0aGlzLnRleHRTdHlsZSlcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIF9hZnRlck5ldygpIHtcclxuICAgICAgICBzdXBlci5fYWZ0ZXJOZXcoKTtcclxuICAgIH1cclxuICAgIF9iZWZvcmVDaGFuZ2VkKCkge1xyXG4gICAgICAgIHN1cGVyLl9iZWZvcmVDaGFuZ2VkKCk7XHJcbiAgICAgICAgdGhpcy5fZGlzcGxheS5jbGVhcigpO1xyXG4gICAgICAgIGlmICh0aGlzLmlzRGlydHkoXCJ0ZXh0VHlwZVwiKSkge1xyXG4gICAgICAgICAgICB0aGlzLl9kaXNwbGF5LnRleHRUeXBlID0gdGhpcy5nZXQoXCJ0ZXh0VHlwZVwiKTtcclxuICAgICAgICAgICAgdGhpcy5tYXJrRGlydHlCb3VuZHMoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuaXNEaXJ0eShcInJhZGl1c1wiKSkge1xyXG4gICAgICAgICAgICB0aGlzLl9kaXNwbGF5LnJhZGl1cyA9IHRoaXMuZ2V0KFwicmFkaXVzXCIpO1xyXG4gICAgICAgICAgICB0aGlzLm1hcmtEaXJ0eUJvdW5kcygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5pc0RpcnR5KFwic3RhcnRBbmdsZVwiKSkge1xyXG4gICAgICAgICAgICB0aGlzLl9kaXNwbGF5LnN0YXJ0QW5nbGUgPSAodGhpcy5nZXQoXCJzdGFydEFuZ2xlXCIsIDApICsgOTApICogJG1hdGguUkFESUFOUztcclxuICAgICAgICAgICAgdGhpcy5tYXJrRGlydHlCb3VuZHMoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuaXNEaXJ0eShcImluc2lkZVwiKSkge1xyXG4gICAgICAgICAgICB0aGlzLl9kaXNwbGF5Lmluc2lkZSA9IHRoaXMuZ2V0KFwiaW5zaWRlXCIpO1xyXG4gICAgICAgICAgICB0aGlzLm1hcmtEaXJ0eUJvdW5kcygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5pc0RpcnR5KFwib3JpZW50YXRpb25cIikpIHtcclxuICAgICAgICAgICAgdGhpcy5fZGlzcGxheS5vcmllbnRhdGlvbiA9IHRoaXMuZ2V0KFwib3JpZW50YXRpb25cIik7XHJcbiAgICAgICAgICAgIHRoaXMubWFya0RpcnR5Qm91bmRzKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmlzRGlydHkoXCJrZXJuaW5nXCIpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2Rpc3BsYXkua2VybmluZyA9IHRoaXMuZ2V0KFwia2VybmluZ1wiKTtcclxuICAgICAgICAgICAgdGhpcy5tYXJrRGlydHlCb3VuZHMoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFJhZGlhbFRleHQsIFwiY2xhc3NOYW1lXCIsIHtcclxuICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgIHZhbHVlOiBcIlJhZGlhbFRleHRcIlxyXG59KTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFJhZGlhbFRleHQsIFwiY2xhc3NOYW1lc1wiLCB7XHJcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICB2YWx1ZTogVGV4dC5jbGFzc05hbWVzLmNvbmNhdChbUmFkaWFsVGV4dC5jbGFzc05hbWVdKVxyXG59KTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UmFkaWFsVGV4dC5qcy5tYXAiLCJpbXBvcnQgeyBHcmFwaGljcyB9IGZyb20gXCIuL0dyYXBoaWNzXCI7XHJcbi8qKlxyXG4gKiBEcmF3cyBhIHJlY3RhbmdsZS5cclxuICpcclxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly93d3cuYW1jaGFydHMuY29tL2RvY3MvdjUvY29uY2VwdHMvY29tbW9uLWVsZW1lbnRzL2dyYXBoaWNzL30gZm9yIG1vcmUgaW5mb1xyXG4gKiBAaW1wb3J0YW50XHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgUmVjdGFuZ2xlIGV4dGVuZHMgR3JhcGhpY3Mge1xyXG4gICAgX2FmdGVyTmV3KCkge1xyXG4gICAgICAgIHN1cGVyLl9hZnRlck5ldygpO1xyXG4gICAgICAgIHRoaXMuX2Rpc3BsYXkuaXNNZWFzdXJlZCA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5zZXRQcml2YXRlUmF3KFwidHJ1c3RCb3VuZHNcIiwgdHJ1ZSk7XHJcbiAgICB9XHJcbiAgICBfYmVmb3JlQ2hhbmdlZCgpIHtcclxuICAgICAgICBzdXBlci5fYmVmb3JlQ2hhbmdlZCgpO1xyXG4gICAgICAgIGlmICh0aGlzLmlzRGlydHkoXCJ3aWR0aFwiKSB8fCB0aGlzLmlzRGlydHkoXCJoZWlnaHRcIikgfHwgdGhpcy5pc1ByaXZhdGVEaXJ0eShcIndpZHRoXCIpIHx8IHRoaXMuaXNQcml2YXRlRGlydHkoXCJoZWlnaHRcIikpIHtcclxuICAgICAgICAgICAgdGhpcy5fY2xlYXIgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIF9jaGFuZ2VkKCkge1xyXG4gICAgICAgIHN1cGVyLl9jaGFuZ2VkKCk7XHJcbiAgICAgICAgaWYgKHRoaXMuX2NsZWFyICYmICF0aGlzLmdldChcImRyYXdcIikpIHtcclxuICAgICAgICAgICAgdGhpcy5fZHJhdygpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIF9kcmF3KCkge1xyXG4gICAgICAgIHRoaXMuX2Rpc3BsYXkuZHJhd1JlY3QoMCwgMCwgdGhpcy53aWR0aCgpLCB0aGlzLmhlaWdodCgpKTtcclxuICAgIH1cclxuICAgIF91cGRhdGVTaXplKCkge1xyXG4gICAgICAgIHRoaXMubWFya0RpcnR5KCk7XHJcbiAgICAgICAgdGhpcy5fY2xlYXIgPSB0cnVlO1xyXG4gICAgfVxyXG59XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWN0YW5nbGUsIFwiY2xhc3NOYW1lXCIsIHtcclxuICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgIHZhbHVlOiBcIlJlY3RhbmdsZVwiXHJcbn0pO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUmVjdGFuZ2xlLCBcImNsYXNzTmFtZXNcIiwge1xyXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgdmFsdWU6IEdyYXBoaWNzLmNsYXNzTmFtZXMuY29uY2F0KFtSZWN0YW5nbGUuY2xhc3NOYW1lXSlcclxufSk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVJlY3RhbmdsZS5qcy5tYXAiLCJpbXBvcnQgKiBhcyAkdHlwZSBmcm9tIFwiLi4vdXRpbC9UeXBlXCI7XHJcbmltcG9ydCAqIGFzICRtYXRoIGZyb20gXCIuLi91dGlsL01hdGhcIjtcclxuaW1wb3J0ICogYXMgJHV0aWxzIGZyb20gXCIuLi91dGlsL1V0aWxzXCI7XHJcbmltcG9ydCB7IFJlY3RhbmdsZSB9IGZyb20gXCIuL1JlY3RhbmdsZVwiO1xyXG4vKipcclxuICogRHJhd3MgYSByZWN0YW5nbGUgd2l0aCByb3VuZGVkIGNvcm5lcnMuXHJcbiAqXHJcbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vd3d3LmFtY2hhcnRzLmNvbS9kb2NzL3Y1L2NvbmNlcHRzL2NvbW1vbi1lbGVtZW50cy9ncmFwaGljcy99IGZvciBtb3JlIGluZm9cclxuICogQGltcG9ydGFudFxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIFJvdW5kZWRSZWN0YW5nbGUgZXh0ZW5kcyBSZWN0YW5nbGUge1xyXG4gICAgX2JlZm9yZUNoYW5nZWQoKSB7XHJcbiAgICAgICAgc3VwZXIuX2JlZm9yZUNoYW5nZWQoKTtcclxuICAgICAgICBpZiAodGhpcy5pc0RpcnR5KFwiY29ybmVyUmFkaXVzVExcIikgfHwgdGhpcy5pc0RpcnR5KFwiY29ybmVyUmFkaXVzVFJcIikgfHwgdGhpcy5pc0RpcnR5KFwiY29ybmVyUmFkaXVzQlJcIikgfHwgdGhpcy5pc0RpcnR5KFwiY29ybmVyUmFkaXVzQkxcIikpIHtcclxuICAgICAgICAgICAgdGhpcy5fY2xlYXIgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIF9kcmF3KCkge1xyXG4gICAgICAgIGxldCB3aWR0aCA9IHRoaXMud2lkdGgoKTtcclxuICAgICAgICBsZXQgaGVpZ2h0ID0gdGhpcy5oZWlnaHQoKTtcclxuICAgICAgICBsZXQgdyA9IHdpZHRoO1xyXG4gICAgICAgIGxldCBoID0gaGVpZ2h0O1xyXG4gICAgICAgIGxldCB3U2lnbiA9IHcgLyBNYXRoLmFicyh3aWR0aCk7XHJcbiAgICAgICAgbGV0IGhTaWduID0gaCAvIE1hdGguYWJzKGhlaWdodCk7XHJcbiAgICAgICAgaWYgKCR0eXBlLmlzTnVtYmVyKHcpICYmICR0eXBlLmlzTnVtYmVyKGgpKSB7XHJcbiAgICAgICAgICAgIGxldCBtaW5TaWRlID0gTWF0aC5taW4odywgaCkgLyAyO1xyXG4gICAgICAgICAgICBsZXQgY3J0bCA9ICR1dGlscy5yZWxhdGl2ZVRvVmFsdWUodGhpcy5nZXQoXCJjb3JuZXJSYWRpdXNUTFwiLCA4KSwgbWluU2lkZSk7XHJcbiAgICAgICAgICAgIGxldCBjcnRyID0gJHV0aWxzLnJlbGF0aXZlVG9WYWx1ZSh0aGlzLmdldChcImNvcm5lclJhZGl1c1RSXCIsIDgpLCBtaW5TaWRlKTtcclxuICAgICAgICAgICAgbGV0IGNyYnIgPSAkdXRpbHMucmVsYXRpdmVUb1ZhbHVlKHRoaXMuZ2V0KFwiY29ybmVyUmFkaXVzQlJcIiwgOCksIG1pblNpZGUpO1xyXG4gICAgICAgICAgICBsZXQgY3JibCA9ICR1dGlscy5yZWxhdGl2ZVRvVmFsdWUodGhpcy5nZXQoXCJjb3JuZXJSYWRpdXNCTFwiLCA4KSwgbWluU2lkZSk7XHJcbiAgICAgICAgICAgIGxldCBtYXhjciA9IE1hdGgubWluKE1hdGguYWJzKHcgLyAyKSwgTWF0aC5hYnMoaCAvIDIpKTtcclxuICAgICAgICAgICAgY3J0bCA9ICRtYXRoLmZpdFRvUmFuZ2UoY3J0bCwgMCwgbWF4Y3IpO1xyXG4gICAgICAgICAgICBjcnRyID0gJG1hdGguZml0VG9SYW5nZShjcnRyLCAwLCBtYXhjcik7XHJcbiAgICAgICAgICAgIGNyYnIgPSAkbWF0aC5maXRUb1JhbmdlKGNyYnIsIDAsIG1heGNyKTtcclxuICAgICAgICAgICAgY3JibCA9ICRtYXRoLmZpdFRvUmFuZ2UoY3JibCwgMCwgbWF4Y3IpO1xyXG4gICAgICAgICAgICBjb25zdCBkaXNwbGF5ID0gdGhpcy5fZGlzcGxheTtcclxuICAgICAgICAgICAgZGlzcGxheS5tb3ZlVG8oY3J0bCAqIHdTaWduLCAwKTtcclxuICAgICAgICAgICAgZGlzcGxheS5saW5lVG8odyAtIGNydHIgKiB3U2lnbiwgMCk7XHJcbiAgICAgICAgICAgIGlmIChjcnRyID4gMCkge1xyXG4gICAgICAgICAgICAgICAgZGlzcGxheS5hcmNUbyh3LCAwLCB3LCBjcnRyICogaFNpZ24sIGNydHIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGRpc3BsYXkubGluZVRvKHcsIGggLSBjcmJyICogaFNpZ24pO1xyXG4gICAgICAgICAgICBpZiAoY3JiciA+IDApIHtcclxuICAgICAgICAgICAgICAgIGRpc3BsYXkuYXJjVG8odywgaCwgdyAtIGNyYnIgKiB3U2lnbiwgaCwgY3Jicik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZGlzcGxheS5saW5lVG8oY3JibCAqIHdTaWduLCBoKTtcclxuICAgICAgICAgICAgaWYgKGNyYmwgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICBkaXNwbGF5LmFyY1RvKDAsIGgsIDAsIGggLSBjcmJsICogaFNpZ24sIGNyYmwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGRpc3BsYXkubGluZVRvKDAsIGNydGwgKiBoU2lnbik7XHJcbiAgICAgICAgICAgIGlmIChjcnRsID4gMCkge1xyXG4gICAgICAgICAgICAgICAgZGlzcGxheS5hcmNUbygwLCAwLCBjcnRsICogd1NpZ24sIDAsIGNydGwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGRpc3BsYXkuY2xvc2VQYXRoKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShSb3VuZGVkUmVjdGFuZ2xlLCBcImNsYXNzTmFtZVwiLCB7XHJcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICB2YWx1ZTogXCJSb3VuZGVkUmVjdGFuZ2xlXCJcclxufSk7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShSb3VuZGVkUmVjdGFuZ2xlLCBcImNsYXNzTmFtZXNcIiwge1xyXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgdmFsdWU6IFJlY3RhbmdsZS5jbGFzc05hbWVzLmNvbmNhdChbUm91bmRlZFJlY3RhbmdsZS5jbGFzc05hbWVdKVxyXG59KTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Um91bmRlZFJlY3RhbmdsZS5qcy5tYXAiLCJpbXBvcnQgeyBSb3VuZGVkUmVjdGFuZ2xlIH0gZnJvbSBcIi4uL3JlbmRlci9Sb3VuZGVkUmVjdGFuZ2xlXCI7XHJcbmltcG9ydCB7IENvbnRhaW5lciB9IGZyb20gXCIuL0NvbnRhaW5lclwiO1xyXG5pbXBvcnQgeyBHcmFwaGljcyB9IGZyb20gXCIuL0dyYXBoaWNzXCI7XHJcbmltcG9ydCB7IEJ1dHRvbiB9IGZyb20gXCIuL0J1dHRvblwiO1xyXG5pbXBvcnQgKiBhcyAkdHlwZSBmcm9tIFwiLi4vdXRpbC9UeXBlXCI7XHJcbmltcG9ydCAqIGFzICR1dGlscyBmcm9tIFwiLi4vdXRpbC9VdGlsc1wiO1xyXG4vKipcclxuICogQSBjb250cm9sIHRoYXQgYWxsb3dzIHpvb21pbmcgY2hhcnQncyBheGVzLCBvciBvdGhlciB1c2VzIHJlcXVpcmluZyByYW5nZVxyXG4gKiBzZWxlY3Rpb24uXHJcbiAqXHJcbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vd3d3LmFtY2hhcnRzLmNvbS9kb2NzL3Y1L2NoYXJ0cy94eS1jaGFydC9zY3JvbGxiYXJzL30gZm9yIG1vcmUgaW5mb1xyXG4gKi9cclxuZXhwb3J0IGNsYXNzIFNjcm9sbGJhciBleHRlbmRzIENvbnRhaW5lciB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEEgdGh1bWIgZWxtZW50IC0gYSBkcmFnZ2FibGUgc3F1YXJlIGJldHdlZW4gdGhlIGdyaXBzLCB1c2VkIGZvciBwYW5uaW5nXHJcbiAgICAgICAgICogdGhlIHNlbGVjdGlvbi5cclxuICAgICAgICAgKi9cclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ0aHVtYlwiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiB0aGlzLl9tYWtlVGh1bWIoKVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFN0YXJ0IGdyaXAgYnV0dG9uLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInN0YXJ0R3JpcFwiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiB0aGlzLl9tYWtlQnV0dG9uKClcclxuICAgICAgICB9KTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBFbmQgZ3JpcCBidXR0b24uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZW5kR3JpcFwiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiB0aGlzLl9tYWtlQnV0dG9uKClcclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfdGh1bWJCdXN5XCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IGZhbHNlXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX3N0YXJ0RG93blwiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiBmYWxzZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9lbmREb3duXCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IGZhbHNlXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX3RodW1iRG93blwiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiBmYWxzZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9ncmlwRG93blwiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIF9hZGRPcmllbnRhdGlvbkNsYXNzKCkge1xyXG4gICAgICAgIHRoaXMuX3NldHRpbmdzLnRoZW1lVGFncyA9ICR1dGlscy5tZXJnZVRhZ3ModGhpcy5fc2V0dGluZ3MudGhlbWVUYWdzLCBbXCJzY3JvbGxiYXJcIiwgdGhpcy5fc2V0dGluZ3Mub3JpZW50YXRpb25dKTtcclxuICAgICAgICBpZiAoIXRoaXMuX3NldHRpbmdzLmJhY2tncm91bmQpIHtcclxuICAgICAgICAgICAgdGhpcy5fc2V0dGluZ3MuYmFja2dyb3VuZCA9IFJvdW5kZWRSZWN0YW5nbGUubmV3KHRoaXMuX3Jvb3QsIHtcclxuICAgICAgICAgICAgICAgIHRoZW1lVGFnczogJHV0aWxzLm1lcmdlVGFncyh0aGlzLl9zZXR0aW5ncy50aGVtZVRhZ3MsIFtcIm1haW5cIiwgXCJiYWNrZ3JvdW5kXCJdKVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBfbWFrZUJ1dHRvbigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jaGlsZHJlbi5wdXNoKEJ1dHRvbi5uZXcodGhpcy5fcm9vdCwge1xyXG4gICAgICAgICAgICB0aGVtZVRhZ3M6IFtcInJlc2l6ZVwiLCBcImJ1dHRvblwiLCB0aGlzLmdldChcIm9yaWVudGF0aW9uXCIpXSwgaWNvbjogR3JhcGhpY3MubmV3KHRoaXMuX3Jvb3QsIHtcclxuICAgICAgICAgICAgICAgIHRoZW1lVGFnczogW1wiaWNvblwiXVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgIH0pKTtcclxuICAgIH1cclxuICAgIF9tYWtlVGh1bWIoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGRyZW4ucHVzaChSb3VuZGVkUmVjdGFuZ2xlLm5ldyh0aGlzLl9yb290LCB7XHJcbiAgICAgICAgICAgIHRoZW1lVGFnczogW1widGh1bWJcIiwgdGhpcy5nZXQoXCJvcmllbnRhdGlvblwiKV1cclxuICAgICAgICB9KSk7XHJcbiAgICB9XHJcbiAgICBfaGFuZGxlQW5pbWF0aW9uKGFuaW1hdGlvbikge1xyXG4gICAgICAgIGlmIChhbmltYXRpb24pIHtcclxuICAgICAgICAgICAgdGhpcy5fZGlzcG9zZXJzLnB1c2goYW5pbWF0aW9uLmV2ZW50cy5vbihcInN0b3BwZWRcIiwgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZXRQcml2YXRlUmF3KFwiaXNCdXN5XCIsIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3RodW1iQnVzeSA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgX2FmdGVyTmV3KCkge1xyXG4gICAgICAgIHRoaXMuX2FkZE9yaWVudGF0aW9uQ2xhc3MoKTtcclxuICAgICAgICBzdXBlci5fYWZ0ZXJOZXcoKTtcclxuICAgICAgICBjb25zdCBzdGFydEdyaXAgPSB0aGlzLnN0YXJ0R3JpcDtcclxuICAgICAgICBjb25zdCBlbmRHcmlwID0gdGhpcy5lbmRHcmlwO1xyXG4gICAgICAgIGNvbnN0IHRodW1iID0gdGhpcy50aHVtYjtcclxuICAgICAgICBjb25zdCBiYWNrZ3JvdW5kID0gdGhpcy5nZXQoXCJiYWNrZ3JvdW5kXCIpO1xyXG4gICAgICAgIGlmIChiYWNrZ3JvdW5kKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2Rpc3Bvc2Vycy5wdXNoKGJhY2tncm91bmQuZXZlbnRzLm9uKFwiY2xpY2tcIiwgKGV2ZW50KSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNldFByaXZhdGVSYXcoXCJpc0J1c3lcIiwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwb2ludCA9IHRoaXMuX2Rpc3BsYXkudG9Mb2NhbChldmVudC5wb2ludCk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB3ID0gdGhpcy53aWR0aCgpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgaCA9IHRoaXMuaGVpZ2h0KCk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBvcmllbnRhdGlvbiA9IHRoaXMuZ2V0KFwib3JpZW50YXRpb25cIik7XHJcbiAgICAgICAgICAgICAgICBsZXQgbmV3TWlkZGxlO1xyXG4gICAgICAgICAgICAgICAgaWYgKG9yaWVudGF0aW9uID09IFwidmVydGljYWxcIikge1xyXG4gICAgICAgICAgICAgICAgICAgIG5ld01pZGRsZSA9IChwb2ludC55IC0gdGh1bWIuaGVpZ2h0KCkgLyAyKSAvIGg7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBuZXdNaWRkbGUgPSAocG9pbnQueCAtIHRodW1iLndpZHRoKCkgLyAyKSAvIHc7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBsZXQgbmV3Q29vcmRpbmF0ZTtcclxuICAgICAgICAgICAgICAgIGxldCBrZXk7XHJcbiAgICAgICAgICAgICAgICBpZiAob3JpZW50YXRpb24gPT0gXCJ2ZXJ0aWNhbFwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3Q29vcmRpbmF0ZSA9IG5ld01pZGRsZSAqIGg7XHJcbiAgICAgICAgICAgICAgICAgICAga2V5ID0gXCJ5XCI7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBuZXdDb29yZGluYXRlID0gbmV3TWlkZGxlICogdztcclxuICAgICAgICAgICAgICAgICAgICBrZXkgPSBcInhcIjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvbnN0IGR1cmF0aW9uID0gdGhpcy5nZXQoXCJhbmltYXRpb25EdXJhdGlvblwiLCAwKTtcclxuICAgICAgICAgICAgICAgIGlmIChkdXJhdGlvbiA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl90aHVtYkJ1c3kgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2hhbmRsZUFuaW1hdGlvbih0aGlzLnRodW1iLmFuaW1hdGUoeyBrZXk6IGtleSwgdG86IG5ld0Nvb3JkaW5hdGUsIGR1cmF0aW9uOiBkdXJhdGlvbiwgZWFzaW5nOiB0aGlzLmdldChcImFuaW1hdGlvbkVhc2luZ1wiKSB9KSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnRodW1iLnNldChrZXksIG5ld0Nvb3JkaW5hdGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3Jvb3QuZXZlbnRzLm9uY2UoXCJmcmFtZWVuZGVkXCIsICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRQcml2YXRlUmF3KFwiaXNCdXN5XCIsIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9kaXNwb3NlcnMucHVzaCh0aHVtYi5ldmVudHMub24oXCJkYmxjbGlja1wiLCAoZXZlbnQpID0+IHtcclxuICAgICAgICAgICAgaWYgKCEkdXRpbHMuaXNMb2NhbEV2ZW50KGV2ZW50Lm9yaWdpbmFsRXZlbnQsIHRoaXMpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgZHVyYXRpb24gPSB0aGlzLmdldChcImFuaW1hdGlvbkR1cmF0aW9uXCIsIDApO1xyXG4gICAgICAgICAgICBjb25zdCBlYXNpbmcgPSB0aGlzLmdldChcImFuaW1hdGlvbkVhc2luZ1wiKTtcclxuICAgICAgICAgICAgdGhpcy5hbmltYXRlKHsga2V5OiBcInN0YXJ0XCIsIHRvOiAwLCBkdXJhdGlvbjogZHVyYXRpb24sIGVhc2luZzogZWFzaW5nIH0pO1xyXG4gICAgICAgICAgICB0aGlzLmFuaW1hdGUoeyBrZXk6IFwiZW5kXCIsIHRvOiAxLCBkdXJhdGlvbjogZHVyYXRpb24sIGVhc2luZzogZWFzaW5nIH0pO1xyXG4gICAgICAgIH0pKTtcclxuICAgICAgICB0aGlzLl9kaXNwb3NlcnMucHVzaChzdGFydEdyaXAuZXZlbnRzLm9uKFwicG9pbnRlcmRvd25cIiwgKCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLnNldFByaXZhdGVSYXcoXCJpc0J1c3lcIiwgdHJ1ZSk7XHJcbiAgICAgICAgICAgIHRoaXMuX3N0YXJ0RG93biA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMuX2dyaXBEb3duID0gXCJzdGFydFwiO1xyXG4gICAgICAgIH0pKTtcclxuICAgICAgICB0aGlzLl9kaXNwb3NlcnMucHVzaChlbmRHcmlwLmV2ZW50cy5vbihcInBvaW50ZXJkb3duXCIsICgpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5zZXRQcml2YXRlUmF3KFwiaXNCdXN5XCIsIHRydWUpO1xyXG4gICAgICAgICAgICB0aGlzLl9lbmREb3duID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy5fZ3JpcERvd24gPSBcImVuZFwiO1xyXG4gICAgICAgIH0pKTtcclxuICAgICAgICB0aGlzLl9kaXNwb3NlcnMucHVzaCh0aHVtYi5ldmVudHMub24oXCJwb2ludGVyZG93blwiLCAoKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0UHJpdmF0ZVJhdyhcImlzQnVzeVwiLCB0cnVlKTtcclxuICAgICAgICAgICAgdGhpcy5fdGh1bWJEb3duID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy5fZ3JpcERvd24gPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgfSkpO1xyXG4gICAgICAgIHRoaXMuX2Rpc3Bvc2Vycy5wdXNoKHN0YXJ0R3JpcC5ldmVudHMub24oXCJnbG9iYWxwb2ludGVydXBcIiwgKCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fc3RhcnREb3duKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNldFByaXZhdGVSYXcoXCJpc0J1c3lcIiwgZmFsc2UpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX3N0YXJ0RG93biA9IGZhbHNlO1xyXG4gICAgICAgIH0pKTtcclxuICAgICAgICB0aGlzLl9kaXNwb3NlcnMucHVzaChlbmRHcmlwLmV2ZW50cy5vbihcImdsb2JhbHBvaW50ZXJ1cFwiLCAoKSA9PiB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9lbmREb3duKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNldFByaXZhdGVSYXcoXCJpc0J1c3lcIiwgZmFsc2UpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX2VuZERvd24gPSBmYWxzZTtcclxuICAgICAgICB9KSk7XHJcbiAgICAgICAgdGhpcy5fZGlzcG9zZXJzLnB1c2godGh1bWIuZXZlbnRzLm9uKFwiZ2xvYmFscG9pbnRlcnVwXCIsICgpID0+IHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX3RodW1iRG93bikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZXRQcml2YXRlUmF3KFwiaXNCdXN5XCIsIGZhbHNlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl90aHVtYkRvd24gPSBmYWxzZTtcclxuICAgICAgICB9KSk7XHJcbiAgICAgICAgdGhpcy5fZGlzcG9zZXJzLnB1c2goc3RhcnRHcmlwLm9uKFwieFwiLCAoKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZVRodW1iKCk7XHJcbiAgICAgICAgfSkpO1xyXG4gICAgICAgIHRoaXMuX2Rpc3Bvc2Vycy5wdXNoKGVuZEdyaXAub24oXCJ4XCIsICgpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5fdXBkYXRlVGh1bWIoKTtcclxuICAgICAgICB9KSk7XHJcbiAgICAgICAgdGhpcy5fZGlzcG9zZXJzLnB1c2goc3RhcnRHcmlwLm9uKFwieVwiLCAoKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZVRodW1iKCk7XHJcbiAgICAgICAgfSkpO1xyXG4gICAgICAgIHRoaXMuX2Rpc3Bvc2Vycy5wdXNoKGVuZEdyaXAub24oXCJ5XCIsICgpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5fdXBkYXRlVGh1bWIoKTtcclxuICAgICAgICB9KSk7XHJcbiAgICAgICAgdGhpcy5fZGlzcG9zZXJzLnB1c2godGh1bWIuZXZlbnRzLm9uKFwicG9zaXRpb25jaGFuZ2VkXCIsICgpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5fdXBkYXRlR3JpcHNCeVRodW1iKCk7XHJcbiAgICAgICAgfSkpO1xyXG4gICAgICAgIGlmICh0aGlzLmdldChcIm9yaWVudGF0aW9uXCIpID09IFwidmVydGljYWxcIikge1xyXG4gICAgICAgICAgICBzdGFydEdyaXAuc2V0KFwieFwiLCAwKTtcclxuICAgICAgICAgICAgZW5kR3JpcC5zZXQoXCJ4XCIsIDApO1xyXG4gICAgICAgICAgICB0aGlzLl9kaXNwb3NlcnMucHVzaCh0aHVtYi5hZGFwdGVycy5hZGQoXCJ5XCIsICh2YWx1ZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIE1hdGgubWF4KE1hdGgubWluKE51bWJlcih2YWx1ZSksIHRoaXMuaGVpZ2h0KCkgLSB0aHVtYi5oZWlnaHQoKSksIDApO1xyXG4gICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICAgIHRoaXMuX2Rpc3Bvc2Vycy5wdXNoKHRodW1iLmFkYXB0ZXJzLmFkZChcInhcIiwgKF92YWx1ZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMud2lkdGgoKSAvIDI7XHJcbiAgICAgICAgICAgIH0pKTtcclxuICAgICAgICAgICAgdGhpcy5fZGlzcG9zZXJzLnB1c2goc3RhcnRHcmlwLmFkYXB0ZXJzLmFkZChcInhcIiwgKF92YWx1ZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMud2lkdGgoKSAvIDI7XHJcbiAgICAgICAgICAgIH0pKTtcclxuICAgICAgICAgICAgdGhpcy5fZGlzcG9zZXJzLnB1c2goZW5kR3JpcC5hZGFwdGVycy5hZGQoXCJ4XCIsIChfdmFsdWUpID0+IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLndpZHRoKCkgLyAyO1xyXG4gICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICAgIHRoaXMuX2Rpc3Bvc2Vycy5wdXNoKHN0YXJ0R3JpcC5hZGFwdGVycy5hZGQoXCJ5XCIsICh2YWx1ZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIE1hdGgubWF4KE1hdGgubWluKE51bWJlcih2YWx1ZSksIHRoaXMuaGVpZ2h0KCkpLCAwKTtcclxuICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgICB0aGlzLl9kaXNwb3NlcnMucHVzaChlbmRHcmlwLmFkYXB0ZXJzLmFkZChcInlcIiwgKHZhbHVlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gTWF0aC5tYXgoTWF0aC5taW4oTnVtYmVyKHZhbHVlKSwgdGhpcy5oZWlnaHQoKSksIDApO1xyXG4gICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBzdGFydEdyaXAuc2V0KFwieVwiLCAwKTtcclxuICAgICAgICAgICAgZW5kR3JpcC5zZXQoXCJ5XCIsIDApO1xyXG4gICAgICAgICAgICB0aGlzLl9kaXNwb3NlcnMucHVzaCh0aHVtYi5hZGFwdGVycy5hZGQoXCJ4XCIsICh2YWx1ZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIE1hdGgubWF4KE1hdGgubWluKE51bWJlcih2YWx1ZSksIHRoaXMud2lkdGgoKSAtIHRodW1iLndpZHRoKCkpLCAwKTtcclxuICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgICB0aGlzLl9kaXNwb3NlcnMucHVzaCh0aHVtYi5hZGFwdGVycy5hZGQoXCJ5XCIsIChfdmFsdWUpID0+IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmhlaWdodCgpIC8gMjtcclxuICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgICB0aGlzLl9kaXNwb3NlcnMucHVzaChzdGFydEdyaXAuYWRhcHRlcnMuYWRkKFwieVwiLCAoX3ZhbHVlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5oZWlnaHQoKSAvIDI7XHJcbiAgICAgICAgICAgIH0pKTtcclxuICAgICAgICAgICAgdGhpcy5fZGlzcG9zZXJzLnB1c2goZW5kR3JpcC5hZGFwdGVycy5hZGQoXCJ5XCIsIChfdmFsdWUpID0+IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmhlaWdodCgpIC8gMjtcclxuICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgICB0aGlzLl9kaXNwb3NlcnMucHVzaChzdGFydEdyaXAuYWRhcHRlcnMuYWRkKFwieFwiLCAodmFsdWUpID0+IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBNYXRoLm1heChNYXRoLm1pbihOdW1iZXIodmFsdWUpLCB0aGlzLndpZHRoKCkpLCAwKTtcclxuICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgICB0aGlzLl9kaXNwb3NlcnMucHVzaChlbmRHcmlwLmFkYXB0ZXJzLmFkZChcInhcIiwgKHZhbHVlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gTWF0aC5tYXgoTWF0aC5taW4oTnVtYmVyKHZhbHVlKSwgdGhpcy53aWR0aCgpKSwgMCk7XHJcbiAgICAgICAgICAgIH0pKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBfdXBkYXRlQ2hpbGRyZW4oKSB7XHJcbiAgICAgICAgc3VwZXIuX3VwZGF0ZUNoaWxkcmVuKCk7XHJcbiAgICAgICAgaWYgKHRoaXMuaXNEaXJ0eShcImVuZFwiKSB8fCB0aGlzLmlzRGlydHkoXCJzdGFydFwiKSB8fCB0aGlzLl9zaXplRGlydHkpIHtcclxuICAgICAgICAgICAgdGhpcy51cGRhdGVHcmlwcygpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIF9jaGFuZ2VkKCkge1xyXG4gICAgICAgIHN1cGVyLl9jaGFuZ2VkKCk7XHJcbiAgICAgICAgaWYgKHRoaXMuaXNEaXJ0eShcInN0YXJ0XCIpIHx8IHRoaXMuaXNEaXJ0eShcImVuZFwiKSkge1xyXG4gICAgICAgICAgICBjb25zdCBldmVudFR5cGUgPSBcInJhbmdlY2hhbmdlZFwiO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5ldmVudHMuaXNFbmFibGVkKGV2ZW50VHlwZSkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZXZlbnRzLmRpc3BhdGNoKGV2ZW50VHlwZSwgeyB0eXBlOiBldmVudFR5cGUsIHRhcmdldDogdGhpcywgc3RhcnQ6IHRoaXMuZ2V0KFwic3RhcnRcIiwgMCksIGVuZDogdGhpcy5nZXQoXCJlbmRcIiwgMSksIGdyaXA6IHRoaXMuX2dyaXBEb3duIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAaWdub3JlXHJcbiAgICAgKi9cclxuICAgIHVwZGF0ZUdyaXBzKCkge1xyXG4gICAgICAgIGNvbnN0IHN0YXJ0R3JpcCA9IHRoaXMuc3RhcnRHcmlwO1xyXG4gICAgICAgIGNvbnN0IGVuZEdyaXAgPSB0aGlzLmVuZEdyaXA7XHJcbiAgICAgICAgY29uc3Qgb3JpZW50YXRpb24gPSB0aGlzLmdldChcIm9yaWVudGF0aW9uXCIpO1xyXG4gICAgICAgIGNvbnN0IGhlaWdodCA9IHRoaXMuaGVpZ2h0KCk7XHJcbiAgICAgICAgY29uc3Qgd2lkdGggPSB0aGlzLndpZHRoKCk7XHJcbiAgICAgICAgaWYgKG9yaWVudGF0aW9uID09IFwidmVydGljYWxcIikge1xyXG4gICAgICAgICAgICBzdGFydEdyaXAuc2V0KFwieVwiLCBoZWlnaHQgKiB0aGlzLmdldChcInN0YXJ0XCIsIDApKTtcclxuICAgICAgICAgICAgZW5kR3JpcC5zZXQoXCJ5XCIsIGhlaWdodCAqIHRoaXMuZ2V0KFwiZW5kXCIsIDEpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHN0YXJ0R3JpcC5zZXQoXCJ4XCIsIHdpZHRoICogdGhpcy5nZXQoXCJzdGFydFwiLCAwKSk7XHJcbiAgICAgICAgICAgIGVuZEdyaXAuc2V0KFwieFwiLCB3aWR0aCAqIHRoaXMuZ2V0KFwiZW5kXCIsIDEpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgdmFsdWVGdW5jdGlvbiA9IHRoaXMuZ2V0UHJpdmF0ZShcInBvc2l0aW9uVGV4dEZ1bmN0aW9uXCIpO1xyXG4gICAgICAgIGNvbnN0IGZyb20gPSBNYXRoLnJvdW5kKHRoaXMuZ2V0KFwic3RhcnRcIiwgMCkgKiAxMDApO1xyXG4gICAgICAgIGNvbnN0IHRvID0gTWF0aC5yb3VuZCh0aGlzLmdldChcImVuZFwiLCAwKSAqIDEwMCk7XHJcbiAgICAgICAgbGV0IGZyb21WYWx1ZTtcclxuICAgICAgICBsZXQgdG9WYWx1ZTtcclxuICAgICAgICBpZiAodmFsdWVGdW5jdGlvbikge1xyXG4gICAgICAgICAgICBmcm9tVmFsdWUgPSB2YWx1ZUZ1bmN0aW9uLmNhbGwodGhpcywgdGhpcy5nZXQoXCJzdGFydFwiLCAwKSk7XHJcbiAgICAgICAgICAgIHRvVmFsdWUgPSB2YWx1ZUZ1bmN0aW9uLmNhbGwodGhpcywgdGhpcy5nZXQoXCJlbmRcIiwgMCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZnJvbVZhbHVlID0gZnJvbSArIFwiJVwiO1xyXG4gICAgICAgICAgICB0b1ZhbHVlID0gdG8gKyBcIiVcIjtcclxuICAgICAgICB9XHJcbiAgICAgICAgc3RhcnRHcmlwLnNldChcImFyaWFMYWJlbFwiLCB0aGlzLl90KFwiRnJvbSAlMVwiLCB1bmRlZmluZWQsIGZyb21WYWx1ZSkpO1xyXG4gICAgICAgIHN0YXJ0R3JpcC5zZXQoXCJhcmlhVmFsdWVOb3dcIiwgXCJcIiArIGZyb20pO1xyXG4gICAgICAgIHN0YXJ0R3JpcC5zZXQoXCJhcmlhVmFsdWVUZXh0XCIsIGZyb20gKyBcIiVcIik7XHJcbiAgICAgICAgc3RhcnRHcmlwLnNldChcImFyaWFWYWx1ZU1pblwiLCBcIjBcIik7XHJcbiAgICAgICAgc3RhcnRHcmlwLnNldChcImFyaWFWYWx1ZU1heFwiLCBcIjEwMFwiKTtcclxuICAgICAgICBlbmRHcmlwLnNldChcImFyaWFMYWJlbFwiLCB0aGlzLl90KFwiVG8gJTFcIiwgdW5kZWZpbmVkLCB0b1ZhbHVlKSk7XHJcbiAgICAgICAgZW5kR3JpcC5zZXQoXCJhcmlhVmFsdWVOb3dcIiwgXCJcIiArIHRvKTtcclxuICAgICAgICBlbmRHcmlwLnNldChcImFyaWFWYWx1ZVRleHRcIiwgdG8gKyBcIiVcIik7XHJcbiAgICAgICAgZW5kR3JpcC5zZXQoXCJhcmlhVmFsdWVNaW5cIiwgXCIwXCIpO1xyXG4gICAgICAgIGVuZEdyaXAuc2V0KFwiYXJpYVZhbHVlTWF4XCIsIFwiMTAwXCIpO1xyXG4gICAgfVxyXG4gICAgX3VwZGF0ZVRodW1iKCkge1xyXG4gICAgICAgIGNvbnN0IHRodW1iID0gdGhpcy50aHVtYjtcclxuICAgICAgICBjb25zdCBzdGFydEdyaXAgPSB0aGlzLnN0YXJ0R3JpcDtcclxuICAgICAgICBjb25zdCBlbmRHcmlwID0gdGhpcy5lbmRHcmlwO1xyXG4gICAgICAgIGNvbnN0IGhlaWdodCA9IHRoaXMuaGVpZ2h0KCk7XHJcbiAgICAgICAgY29uc3Qgd2lkdGggPSB0aGlzLndpZHRoKCk7XHJcbiAgICAgICAgbGV0IHgwID0gc3RhcnRHcmlwLngoKTtcclxuICAgICAgICBsZXQgeDEgPSBlbmRHcmlwLngoKTtcclxuICAgICAgICBsZXQgeTAgPSBzdGFydEdyaXAueSgpO1xyXG4gICAgICAgIGxldCB5MSA9IGVuZEdyaXAueSgpO1xyXG4gICAgICAgIGxldCBzdGFydCA9IDA7XHJcbiAgICAgICAgbGV0IGVuZCA9IDE7XHJcbiAgICAgICAgaWYgKHRoaXMuZ2V0KFwib3JpZW50YXRpb25cIikgPT0gXCJ2ZXJ0aWNhbFwiKSB7XHJcbiAgICAgICAgICAgIGlmICgkdHlwZS5pc051bWJlcih5MCkgJiYgJHR5cGUuaXNOdW1iZXIoeTEpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX3RodW1iQnVzeSAmJiAhdGh1bWIuaXNEcmFnZ2luZygpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGh1bWIuc2V0KFwiaGVpZ2h0XCIsIHkxIC0geTApO1xyXG4gICAgICAgICAgICAgICAgICAgIHRodW1iLnNldChcInlcIiwgeTApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgc3RhcnQgPSB5MCAvIGhlaWdodDtcclxuICAgICAgICAgICAgICAgIGVuZCA9IHkxIC8gaGVpZ2h0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAoJHR5cGUuaXNOdW1iZXIoeDApICYmICR0eXBlLmlzTnVtYmVyKHgxKSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLl90aHVtYkJ1c3kgJiYgIXRodW1iLmlzRHJhZ2dpbmcoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRodW1iLnNldChcIndpZHRoXCIsIHgxIC0geDApO1xyXG4gICAgICAgICAgICAgICAgICAgIHRodW1iLnNldChcInhcIiwgeDApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgc3RhcnQgPSB4MCAvIHdpZHRoO1xyXG4gICAgICAgICAgICAgICAgZW5kID0geDEgLyB3aWR0aDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5nZXRQcml2YXRlKFwiaXNCdXN5XCIpICYmICh0aGlzLmdldChcInN0YXJ0XCIpICE9IHN0YXJ0IHx8IHRoaXMuZ2V0KFwiZW5kXCIpICE9IGVuZCkpIHtcclxuICAgICAgICAgICAgdGhpcy5zZXQoXCJzdGFydFwiLCBzdGFydCk7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0KFwiZW5kXCIsIGVuZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHZhbHVlRnVuY3Rpb24gPSB0aGlzLmdldFByaXZhdGUoXCJwb3NpdGlvblRleHRGdW5jdGlvblwiKTtcclxuICAgICAgICBjb25zdCBmcm9tID0gTWF0aC5yb3VuZCh0aGlzLmdldChcInN0YXJ0XCIsIDApICogMTAwKTtcclxuICAgICAgICBjb25zdCB0byA9IE1hdGgucm91bmQodGhpcy5nZXQoXCJlbmRcIiwgMCkgKiAxMDApO1xyXG4gICAgICAgIGxldCBmcm9tVmFsdWU7XHJcbiAgICAgICAgbGV0IHRvVmFsdWU7XHJcbiAgICAgICAgaWYgKHZhbHVlRnVuY3Rpb24pIHtcclxuICAgICAgICAgICAgZnJvbVZhbHVlID0gdmFsdWVGdW5jdGlvbi5jYWxsKHRoaXMsIHRoaXMuZ2V0KFwic3RhcnRcIiwgMCkpO1xyXG4gICAgICAgICAgICB0b1ZhbHVlID0gdmFsdWVGdW5jdGlvbi5jYWxsKHRoaXMsIHRoaXMuZ2V0KFwiZW5kXCIsIDApKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGZyb21WYWx1ZSA9IGZyb20gKyBcIiVcIjtcclxuICAgICAgICAgICAgdG9WYWx1ZSA9IHRvICsgXCIlXCI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRodW1iLnNldChcImFyaWFMYWJlbFwiLCB0aGlzLl90KFwiRnJvbSAlMSB0byAlMlwiLCB1bmRlZmluZWQsIGZyb21WYWx1ZSwgdG9WYWx1ZSkpO1xyXG4gICAgICAgIHRodW1iLnNldChcImFyaWFWYWx1ZU5vd1wiLCBcIlwiICsgZnJvbSk7XHJcbiAgICAgICAgdGh1bWIuc2V0KFwiYXJpYVZhbHVlVGV4dFwiLCBmcm9tICsgXCIlXCIpO1xyXG4gICAgfVxyXG4gICAgX3VwZGF0ZUdyaXBzQnlUaHVtYigpIHtcclxuICAgICAgICBjb25zdCB0aHVtYiA9IHRoaXMudGh1bWI7XHJcbiAgICAgICAgY29uc3Qgc3RhcnRHcmlwID0gdGhpcy5zdGFydEdyaXA7XHJcbiAgICAgICAgY29uc3QgZW5kR3JpcCA9IHRoaXMuZW5kR3JpcDtcclxuICAgICAgICBpZiAodGhpcy5nZXQoXCJvcmllbnRhdGlvblwiKSA9PSBcInZlcnRpY2FsXCIpIHtcclxuICAgICAgICAgICAgY29uc3QgdGh1bWJTaXplID0gdGh1bWIuaGVpZ2h0KCk7XHJcbiAgICAgICAgICAgIHN0YXJ0R3JpcC5zZXQoXCJ5XCIsIHRodW1iLnkoKSk7XHJcbiAgICAgICAgICAgIGVuZEdyaXAuc2V0KFwieVwiLCB0aHVtYi55KCkgKyB0aHVtYlNpemUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3QgdGh1bWJTaXplID0gdGh1bWIud2lkdGgoKTtcclxuICAgICAgICAgICAgc3RhcnRHcmlwLnNldChcInhcIiwgdGh1bWIueCgpKTtcclxuICAgICAgICAgICAgZW5kR3JpcC5zZXQoXCJ4XCIsIHRodW1iLngoKSArIHRodW1iU2l6ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShTY3JvbGxiYXIsIFwiY2xhc3NOYW1lXCIsIHtcclxuICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgIHZhbHVlOiBcIlNjcm9sbGJhclwiXHJcbn0pO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoU2Nyb2xsYmFyLCBcImNsYXNzTmFtZXNcIiwge1xyXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgdmFsdWU6IENvbnRhaW5lci5jbGFzc05hbWVzLmNvbmNhdChbU2Nyb2xsYmFyLmNsYXNzTmFtZV0pXHJcbn0pO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1TY3JvbGxiYXIuanMubWFwIiwiaW1wb3J0IHsgQ2hhcnQgfSBmcm9tIFwiLi9DaGFydFwiO1xyXG5pbXBvcnQgeyBDb250YWluZXIgfSBmcm9tIFwiLi4vLi4vY29yZS9yZW5kZXIvQ29udGFpbmVyXCI7XHJcbmltcG9ydCB7IExpc3RBdXRvRGlzcG9zZSB9IGZyb20gXCIuLi8uLi9jb3JlL3V0aWwvTGlzdFwiO1xyXG5pbXBvcnQgeyBwMTAwIH0gZnJvbSBcIi4uLy4uL2NvcmUvdXRpbC9QZXJjZW50XCI7XHJcbmltcG9ydCAqIGFzICRhcnJheSBmcm9tIFwiLi4vLi4vY29yZS91dGlsL0FycmF5XCI7XHJcbi8qKlxyXG4gKiBBIGJhc2UgY2xhc3MgZm9yIGFsbCBzZXJpZXMtYmFzZWQgY2hhcnRzLlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIFNlcmlhbENoYXJ0IGV4dGVuZHMgQ2hhcnQge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBIFtbQ29udGFpbmVyXV0gd2hlcmUgY2hhcnQgd2lsbCBzdG9yZSBhbGwgc2VyaWVzLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQGRlZmF1bHQgQ29udGFpbmVyLm5ldygpXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwic2VyaWVzQ29udGFpbmVyXCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IENvbnRhaW5lci5uZXcodGhpcy5fcm9vdCwgeyB3aWR0aDogcDEwMCwgaGVpZ2h0OiBwMTAwLCBpc01lYXN1cmVkOiBmYWxzZSB9KVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEEgbGlzdCBvZiBjaGFydCdzIHNlcmllcy5cclxuICAgICAgICAgKi9cclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJzZXJpZXNcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogbmV3IExpc3RBdXRvRGlzcG9zZSgpXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBfYWZ0ZXJOZXcoKSB7XHJcbiAgICAgICAgc3VwZXIuX2FmdGVyTmV3KCk7XHJcbiAgICAgICAgdGhpcy5fZGlzcG9zZXJzLnB1c2godGhpcy5zZXJpZXMpO1xyXG4gICAgICAgIGNvbnN0IGNoaWxkcmVuID0gdGhpcy5zZXJpZXNDb250YWluZXIuY2hpbGRyZW47XHJcbiAgICAgICAgdGhpcy5fZGlzcG9zZXJzLnB1c2godGhpcy5zZXJpZXMuZXZlbnRzLm9uQWxsKChjaGFuZ2UpID0+IHtcclxuICAgICAgICAgICAgaWYgKGNoYW5nZS50eXBlID09PSBcImNsZWFyXCIpIHtcclxuICAgICAgICAgICAgICAgICRhcnJheS5lYWNoKGNoYW5nZS5vbGRWYWx1ZXMsIChzZXJpZXMpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZW1vdmVTZXJpZXMoc2VyaWVzKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY29sb3JzID0gdGhpcy5nZXQoXCJjb2xvcnNcIik7XHJcbiAgICAgICAgICAgICAgICBpZiAoY29sb3JzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29sb3JzLnJlc2V0KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoY2hhbmdlLnR5cGUgPT09IFwicHVzaFwiKSB7XHJcbiAgICAgICAgICAgICAgICBjaGlsZHJlbi5tb3ZlVmFsdWUoY2hhbmdlLm5ld1ZhbHVlKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3Byb2Nlc3NTZXJpZXMoY2hhbmdlLm5ld1ZhbHVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChjaGFuZ2UudHlwZSA9PT0gXCJzZXRJbmRleFwiKSB7XHJcbiAgICAgICAgICAgICAgICBjaGlsZHJlbi5zZXRJbmRleChjaGFuZ2UuaW5kZXgsIGNoYW5nZS5uZXdWYWx1ZSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9wcm9jZXNzU2VyaWVzKGNoYW5nZS5uZXdWYWx1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoY2hhbmdlLnR5cGUgPT09IFwiaW5zZXJ0SW5kZXhcIikge1xyXG4gICAgICAgICAgICAgICAgY2hpbGRyZW4uaW5zZXJ0SW5kZXgoY2hhbmdlLmluZGV4LCBjaGFuZ2UubmV3VmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcHJvY2Vzc1NlcmllcyhjaGFuZ2UubmV3VmFsdWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGNoYW5nZS50eXBlID09PSBcInJlbW92ZUluZGV4XCIpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3JlbW92ZVNlcmllcyhjaGFuZ2Uub2xkVmFsdWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGNoYW5nZS50eXBlID09PSBcIm1vdmVJbmRleFwiKSB7XHJcbiAgICAgICAgICAgICAgICBjaGlsZHJlbi5tb3ZlVmFsdWUoY2hhbmdlLnZhbHVlLCBjaGFuZ2UubmV3SW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcHJvY2Vzc1NlcmllcyhjaGFuZ2UudmFsdWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBJTGlzdEV2ZW50IHR5cGVcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KSk7XHJcbiAgICB9XHJcbiAgICBfcHJvY2Vzc1NlcmllcyhzZXJpZXMpIHtcclxuICAgICAgICBzZXJpZXMuY2hhcnQgPSB0aGlzO1xyXG4gICAgICAgIHNlcmllcy5fcGxhY2VCdWxsZXRzQ29udGFpbmVyKHRoaXMpO1xyXG4gICAgfVxyXG4gICAgX3JlbW92ZVNlcmllcyhzZXJpZXMpIHtcclxuICAgICAgICBpZiAoIXNlcmllcy5pc0Rpc3Bvc2VkKCkpIHtcclxuICAgICAgICAgICAgdGhpcy5zZXJpZXNDb250YWluZXIuY2hpbGRyZW4ucmVtb3ZlVmFsdWUoc2VyaWVzKTtcclxuICAgICAgICAgICAgc2VyaWVzLl9yZW1vdmVCdWxsZXRzQ29udGFpbmVyKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShTZXJpYWxDaGFydCwgXCJjbGFzc05hbWVcIiwge1xyXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgdmFsdWU6IFwiU2VyaWFsQ2hhcnRcIlxyXG59KTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFNlcmlhbENoYXJ0LCBcImNsYXNzTmFtZXNcIiwge1xyXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgdmFsdWU6IENoYXJ0LmNsYXNzTmFtZXMuY29uY2F0KFtTZXJpYWxDaGFydC5jbGFzc05hbWVdKVxyXG59KTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U2VyaWFsQ2hhcnQuanMubWFwIiwiaW1wb3J0IHsgX19hd2FpdGVyIH0gZnJvbSBcInRzbGliXCI7XHJcbmltcG9ydCB7IENvbXBvbmVudCB9IGZyb20gXCIuLi8uLi9jb3JlL3JlbmRlci9Db21wb25lbnRcIjtcclxuaW1wb3J0IHsgTGlzdCB9IGZyb20gXCIuLi8uLi9jb3JlL3V0aWwvTGlzdFwiO1xyXG5pbXBvcnQgeyBDb2xvciB9IGZyb20gXCIuLi8uLi9jb3JlL3V0aWwvQ29sb3JcIjtcclxuaW1wb3J0IHsgcGVyY2VudEludGVycG9sYXRlIH0gZnJvbSBcIi4uLy4uL2NvcmUvdXRpbC9BbmltYXRpb25cIjtcclxuaW1wb3J0IHsgUGVyY2VudCB9IGZyb20gXCIuLi8uLi9jb3JlL3V0aWwvUGVyY2VudFwiO1xyXG5pbXBvcnQgKiBhcyAkYXJyYXkgZnJvbSBcIi4uLy4uL2NvcmUvdXRpbC9BcnJheVwiO1xyXG5pbXBvcnQgKiBhcyAkdHlwZSBmcm9tIFwiLi4vLi4vY29yZS91dGlsL1R5cGVcIjtcclxuaW1wb3J0ICogYXMgJHRpbWUgZnJvbSBcIi4uLy4uL2NvcmUvdXRpbC9UaW1lXCI7XHJcbmltcG9ydCB7IHAxMDAgfSBmcm9tIFwiLi4vLi4vY29yZS91dGlsL1BlcmNlbnRcIjtcclxuaW1wb3J0IHsgQ29udGFpbmVyIH0gZnJvbSBcIi4uLy4uL2NvcmUvcmVuZGVyL0NvbnRhaW5lclwiO1xyXG5pbXBvcnQgeyBMYWJlbCB9IGZyb20gXCIuLi8uLi9jb3JlL3JlbmRlci9MYWJlbFwiO1xyXG4vKipcclxuICogQSBiYXNlIGNsYXNzIGZvciBhbGwgc2VyaWVzLlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIFNlcmllcyBleHRlbmRzIENvbXBvbmVudCB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9hZ2dyZWdhdGVzQ2FsY3VsYXRlZFwiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiBmYWxzZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9zZWxlY3Rpb25BZ2dyZWdhdGVzQ2FsY3VsYXRlZFwiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiBmYWxzZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9kYXRhUHJvY2Vzc2VkXCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IGZhbHNlXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX3BzaVwiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfcGVpXCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEEgY2hhcnQgc2VyaWVzIGJlbG9uZ3MgdG8uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiY2hhcnRcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogTGlzdCBvZiBidWxsZXRzIHRvIHVzZSBmb3IgdGhlIHNlcmllcy5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vd3d3LmFtY2hhcnRzLmNvbS9kb2NzL3Y1L2NvbmNlcHRzL2NvbW1vbi1lbGVtZW50cy9idWxsZXRzL30gZm9yIG1vcmUgaW5mb1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImJ1bGxldHNcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogbmV3IExpc3QoKVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEEgW1tDb250YWluZXJdXSBzZXJpZXMnIGJ1bGxldHMgYXJlIHN0b3JlZCBpbi5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBkZWZhdWx0IENvbnRhaW5lci5uZXcoKVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImJ1bGxldHNDb250YWluZXJcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogQ29udGFpbmVyLm5ldyh0aGlzLl9yb290LCB7IHdpZHRoOiBwMTAwLCBoZWlnaHQ6IHAxMDAsIHBvc2l0aW9uOiBcImFic29sdXRlXCIgfSlcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIF9hZnRlck5ldygpIHtcclxuICAgICAgICB0aGlzLnZhbHVlRmllbGRzLnB1c2goXCJ2YWx1ZVwiLCBcImN1c3RvbVZhbHVlXCIpO1xyXG4gICAgICAgIHN1cGVyLl9hZnRlck5ldygpO1xyXG4gICAgICAgIHRoaXMuc2V0UHJpdmF0ZShcImN1c3RvbURhdGFcIiwge30pO1xyXG4gICAgICAgIHRoaXMuX2Rpc3Bvc2Vycy5wdXNoKHRoaXMuYnVsbGV0cy5ldmVudHMub25BbGwoKGNoYW5nZSkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoY2hhbmdlLnR5cGUgPT09IFwiY2xlYXJcIikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5faGFuZGxlQnVsbGV0cyh0aGlzLmRhdGFJdGVtcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoY2hhbmdlLnR5cGUgPT09IFwicHVzaFwiKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9oYW5kbGVCdWxsZXRzKHRoaXMuZGF0YUl0ZW1zKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChjaGFuZ2UudHlwZSA9PT0gXCJzZXRJbmRleFwiKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9oYW5kbGVCdWxsZXRzKHRoaXMuZGF0YUl0ZW1zKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChjaGFuZ2UudHlwZSA9PT0gXCJpbnNlcnRJbmRleFwiKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9oYW5kbGVCdWxsZXRzKHRoaXMuZGF0YUl0ZW1zKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChjaGFuZ2UudHlwZSA9PT0gXCJyZW1vdmVJbmRleFwiKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9oYW5kbGVCdWxsZXRzKHRoaXMuZGF0YUl0ZW1zKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChjaGFuZ2UudHlwZSA9PT0gXCJtb3ZlSW5kZXhcIikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5faGFuZGxlQnVsbGV0cyh0aGlzLmRhdGFJdGVtcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIElMaXN0RXZlbnQgdHlwZVwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pKTtcclxuICAgIH1cclxuICAgIF9kaXNwb3NlKCkge1xyXG4gICAgICAgIHRoaXMuYnVsbGV0c0NvbnRhaW5lci5kaXNwb3NlKCk7IC8vIGNhbiBiZSBpbiBhIGRpZmZlcmVudCBwYXJlbnRcclxuICAgICAgICBzdXBlci5fZGlzcG9zZSgpO1xyXG4gICAgfVxyXG4gICAgc3RhcnRJbmRleCgpIHtcclxuICAgICAgICBsZXQgbGVuID0gdGhpcy5kYXRhSXRlbXMubGVuZ3RoO1xyXG4gICAgICAgIHJldHVybiBNYXRoLm1pbih0aGlzLmdldFByaXZhdGUoXCJzdGFydEluZGV4XCIsIDApLCBsZW4pO1xyXG4gICAgfVxyXG4gICAgZW5kSW5kZXgoKSB7XHJcbiAgICAgICAgbGV0IGxlbiA9IHRoaXMuZGF0YUl0ZW1zLmxlbmd0aDtcclxuICAgICAgICByZXR1cm4gTWF0aC5taW4odGhpcy5nZXRQcml2YXRlKFwiZW5kSW5kZXhcIiwgbGVuKSwgbGVuKTtcclxuICAgIH1cclxuICAgIF9oYW5kbGVCdWxsZXRzKGRhdGFJdGVtcykge1xyXG4gICAgICAgICRhcnJheS5lYWNoKGRhdGFJdGVtcywgKGRhdGFJdGVtKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGJ1bGxldHMgPSBkYXRhSXRlbS5idWxsZXRzO1xyXG4gICAgICAgICAgICBpZiAoYnVsbGV0cykge1xyXG4gICAgICAgICAgICAgICAgJGFycmF5LmVhY2goYnVsbGV0cywgKGJ1bGxldCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGJ1bGxldC5kaXNwb3NlKCk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIGRhdGFJdGVtLmJ1bGxldHMgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLm1hcmtEaXJ0eVZhbHVlcygpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBMb29rcyB1cCBhbmQgcmV0dXJucyBhIGRhdGEgaXRlbSBieSBpdHMgSUQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtICAgaWQgIElEXHJcbiAgICAgKiBAcmV0dXJuICAgICAgRGF0YSBpdGVtXHJcbiAgICAgKi9cclxuICAgIGdldERhdGFJdGVtQnlJZChpZCkge1xyXG4gICAgICAgIHJldHVybiAkYXJyYXkuZmluZCh0aGlzLmRhdGFJdGVtcywgKGRhdGFJdGVtKSA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiBkYXRhSXRlbS5nZXQoXCJpZFwiKSA9PSBpZDtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIF9tYWtlQnVsbGV0cyhkYXRhSXRlbSkge1xyXG4gICAgICAgIGlmICh0aGlzLl9zaG91bGRNYWtlQnVsbGV0KGRhdGFJdGVtKSkge1xyXG4gICAgICAgICAgICBkYXRhSXRlbS5idWxsZXRzID0gW107XHJcbiAgICAgICAgICAgIHRoaXMuYnVsbGV0cy5lYWNoKChidWxsZXRGdW5jdGlvbikgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbWFrZUJ1bGxldChkYXRhSXRlbSwgYnVsbGV0RnVuY3Rpb24pO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBfc2hvdWxkTWFrZUJ1bGxldChfZGF0YUl0ZW0pIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIF9tYWtlQnVsbGV0KGRhdGFJdGVtLCBidWxsZXRGdW5jdGlvbiwgaW5kZXgpIHtcclxuICAgICAgICBjb25zdCBidWxsZXQgPSBidWxsZXRGdW5jdGlvbih0aGlzLl9yb290LCB0aGlzLCBkYXRhSXRlbSk7XHJcbiAgICAgICAgaWYgKGJ1bGxldCkge1xyXG4gICAgICAgICAgICBidWxsZXQuX2luZGV4ID0gaW5kZXg7XHJcbiAgICAgICAgICAgIHRoaXMuX21ha2VCdWxsZXRSZWFsKGRhdGFJdGVtLCBidWxsZXQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYnVsbGV0O1xyXG4gICAgfVxyXG4gICAgX21ha2VCdWxsZXRSZWFsKGRhdGFJdGVtLCBidWxsZXQpIHtcclxuICAgICAgICBsZXQgc3ByaXRlID0gYnVsbGV0LmdldChcInNwcml0ZVwiKTtcclxuICAgICAgICBpZiAoc3ByaXRlKSB7XHJcbiAgICAgICAgICAgIHNwcml0ZS5fc2V0RGF0YUl0ZW0oZGF0YUl0ZW0pO1xyXG4gICAgICAgICAgICBzcHJpdGUuc2V0UmF3KFwicG9zaXRpb25cIiwgXCJhYnNvbHV0ZVwiKTtcclxuICAgICAgICAgICAgdGhpcy5idWxsZXRzQ29udGFpbmVyLmNoaWxkcmVuLnB1c2goc3ByaXRlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYnVsbGV0LnNlcmllcyA9IHRoaXM7XHJcbiAgICAgICAgZGF0YUl0ZW0uYnVsbGV0cy5wdXNoKGJ1bGxldCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgYnVsbGV0IGRpcmVjdGx5IHRvIGEgZGF0YSBpdGVtLlxyXG4gICAgICpcclxuICAgICAqIFBsZWFzZSBub3RlOiBtZXRob2QgYWNjZXB0cyBbW0J1bGxldF1dIGluc3RhbmNlIGFzIGEgcGFyYW10ZXIsIG5vdCBhXHJcbiAgICAgKiByZWZlcmVuY2UgdG8gYSBmdW5jdGlvbi5cclxuICAgICAqXHJcbiAgICAgKiBZb3Ugc2hvdWxkIGFkZCBCdWxsZXQgaW5zdGFuY2UsIG5vdCBhIG1ldGhvZCBsaWtlIHlvdSBkbyBpdCBvbiBzZXJpZXMuXHJcbiAgICAgKlxyXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly93d3cuYW1jaGFydHMuY29tL2RvY3MvdjUvY29uY2VwdHMvY29tbW9uLWVsZW1lbnRzL2J1bGxldHMvI0FkZGluZ19kaXJlY3RseV90b19kYXRhX2l0ZW19IGZvciBtb3JlIGluZm9cclxuICAgICAqIEBzaW5jZSA1LjYuMFxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSAgZGF0YUl0ZW0gIFRhcmdldCBkYXRhIGl0ZW1cclxuICAgICAqIEBwYXJhbSAgYnVsbGV0ICAgIEJ1bGxldCBpbnN0YW5jZVxyXG4gICAgICovXHJcbiAgICBhZGRCdWxsZXQoZGF0YUl0ZW0sIGJ1bGxldCkge1xyXG4gICAgICAgIGlmICghZGF0YUl0ZW0uYnVsbGV0cykge1xyXG4gICAgICAgICAgICBkYXRhSXRlbS5idWxsZXRzID0gW107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChidWxsZXQpIHtcclxuICAgICAgICAgICAgdGhpcy5fbWFrZUJ1bGxldFJlYWwoZGF0YUl0ZW0sIGJ1bGxldCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgX2NsZWFyRGlydHkoKSB7XHJcbiAgICAgICAgc3VwZXIuX2NsZWFyRGlydHkoKTtcclxuICAgICAgICB0aGlzLl9hZ2dyZWdhdGVzQ2FsY3VsYXRlZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuX3NlbGVjdGlvbkFnZ3JlZ2F0ZXNDYWxjdWxhdGVkID0gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBfcHJlcGFyZUNoaWxkcmVuKCkge1xyXG4gICAgICAgIHN1cGVyLl9wcmVwYXJlQ2hpbGRyZW4oKTtcclxuICAgICAgICBsZXQgc3RhcnRJbmRleCA9IHRoaXMuc3RhcnRJbmRleCgpO1xyXG4gICAgICAgIGxldCBlbmRJbmRleCA9IHRoaXMuZW5kSW5kZXgoKTtcclxuICAgICAgICBpZiAodGhpcy5pc0RpcnR5KFwibmFtZVwiKSkge1xyXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUxlZ2VuZFZhbHVlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmlzRGlydHkoXCJoZWF0UnVsZXNcIikpIHtcclxuICAgICAgICAgICAgdGhpcy5fdmFsdWVzRGlydHkgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5pc1ByaXZhdGVEaXJ0eShcImJhc2VWYWx1ZVNlcmllc1wiKSkge1xyXG4gICAgICAgICAgICBjb25zdCBiYXNlVmFsdWVTZXJpZXMgPSB0aGlzLmdldFByaXZhdGUoXCJiYXNlVmFsdWVTZXJpZXNcIik7XHJcbiAgICAgICAgICAgIGlmIChiYXNlVmFsdWVTZXJpZXMpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2Rpc3Bvc2Vycy5wdXNoKGJhc2VWYWx1ZVNlcmllcy5vblByaXZhdGUoXCJzdGFydEluZGV4XCIsICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm1hcmtEaXJ0eVZhbHVlcygpO1xyXG4gICAgICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGNhbGN1bGF0ZUFnZ3JlZ2F0ZXMgPSB0aGlzLmdldChcImNhbGN1bGF0ZUFnZ3JlZ2F0ZXNcIik7XHJcbiAgICAgICAgaWYgKGNhbGN1bGF0ZUFnZ3JlZ2F0ZXMpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX3ZhbHVlc0RpcnR5ICYmICF0aGlzLl9kYXRhUHJvY2Vzc2VkKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX2FnZ3JlZ2F0ZXNDYWxjdWxhdGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2FsY3VsYXRlQWdncmVnYXRlcygwLCB0aGlzLmRhdGFJdGVtcy5sZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2FnZ3JlZ2F0ZXNDYWxjdWxhdGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoKHRoaXMuX3BzaSAhPSBzdGFydEluZGV4IHx8IHRoaXMuX3BlaSAhPSBlbmRJbmRleCkgJiYgIXRoaXMuX3NlbGVjdGlvbkFnZ3JlZ2F0ZXNDYWxjdWxhdGVkKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoc3RhcnRJbmRleCA9PT0gMCAmJiBlbmRJbmRleCA9PT0gdGhpcy5kYXRhSXRlbXMubGVuZ3RoICYmIHRoaXMuX2FnZ3JlZ2F0ZXNDYWxjdWxhdGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gdm9pZFxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2FsY3VsYXRlQWdncmVnYXRlcyhzdGFydEluZGV4LCBlbmRJbmRleCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zZWxlY3Rpb25BZ2dyZWdhdGVzQ2FsY3VsYXRlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuaXNEaXJ0eShcInRvb2x0aXBcIikpIHtcclxuICAgICAgICAgICAgbGV0IHRvb2x0aXAgPSB0aGlzLmdldChcInRvb2x0aXBcIik7XHJcbiAgICAgICAgICAgIGlmICh0b29sdGlwKSB7XHJcbiAgICAgICAgICAgICAgICB0b29sdGlwLmhpZGUoMCk7XHJcbiAgICAgICAgICAgICAgICB0b29sdGlwLnNldChcInRvb2x0aXBUYXJnZXRcIiwgdGhpcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuaXNEaXJ0eShcImZpbGxcIikgfHwgdGhpcy5pc0RpcnR5KFwic3Ryb2tlXCIpKSB7XHJcbiAgICAgICAgICAgIGxldCBtYXJrZXJSZWN0YW5nbGU7XHJcbiAgICAgICAgICAgIGNvbnN0IGxlZ2VuZERhdGFJdGVtID0gdGhpcy5nZXQoXCJsZWdlbmREYXRhSXRlbVwiKTtcclxuICAgICAgICAgICAgaWYgKGxlZ2VuZERhdGFJdGVtKSB7XHJcbiAgICAgICAgICAgICAgICBtYXJrZXJSZWN0YW5nbGUgPSBsZWdlbmREYXRhSXRlbS5nZXQoXCJtYXJrZXJSZWN0YW5nbGVcIik7XHJcbiAgICAgICAgICAgICAgICBpZiAobWFya2VyUmVjdGFuZ2xlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNWaXNpYmxlKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNEaXJ0eShcInN0cm9rZVwiKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHN0cm9rZSA9IHRoaXMuZ2V0KFwic3Ryb2tlXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFya2VyUmVjdGFuZ2xlLnNldChcInN0cm9rZVwiLCBzdHJva2UpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzRGlydHkoXCJmaWxsXCIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgZmlsbCA9IHRoaXMuZ2V0KFwiZmlsbFwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcmtlclJlY3RhbmdsZS5zZXQoXCJmaWxsXCIsIGZpbGwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlTGVnZW5kTWFya2VyKHVuZGVmaW5lZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmJ1bGxldHMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICBsZXQgc3RhcnRJbmRleCA9IHRoaXMuc3RhcnRJbmRleCgpO1xyXG4gICAgICAgICAgICBsZXQgZW5kSW5kZXggPSB0aGlzLmVuZEluZGV4KCk7XHJcbiAgICAgICAgICAgIGlmIChlbmRJbmRleCA8IHRoaXMuZGF0YUl0ZW1zLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgZW5kSW5kZXgrKztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gc3RhcnRJbmRleDsgaSA8IGVuZEluZGV4OyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGxldCBkYXRhSXRlbSA9IHRoaXMuZGF0YUl0ZW1zW2ldO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFkYXRhSXRlbS5idWxsZXRzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbWFrZUJ1bGxldHMoZGF0YUl0ZW0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgX2NhbGN1bGF0ZUFnZ3JlZ2F0ZXMoc3RhcnRJbmRleCwgZW5kSW5kZXgpIHtcclxuICAgICAgICBsZXQgZmllbGRzID0gdGhpcy5fdmFsdWVGaWVsZHM7XHJcbiAgICAgICAgaWYgKCFmaWVsZHMpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gdmFsdWUgZmllbGRzIGFyZSBzZXQgZm9yIHRoZSBzZXJpZXMuXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBzdW0gPSB7fTtcclxuICAgICAgICBjb25zdCBhYnNTdW0gPSB7fTtcclxuICAgICAgICBjb25zdCBjb3VudCA9IHt9O1xyXG4gICAgICAgIGNvbnN0IGxvdyA9IHt9O1xyXG4gICAgICAgIGNvbnN0IGhpZ2ggPSB7fTtcclxuICAgICAgICBjb25zdCBvcGVuID0ge307XHJcbiAgICAgICAgY29uc3QgY2xvc2UgPSB7fTtcclxuICAgICAgICBjb25zdCBhdmVyYWdlID0ge307XHJcbiAgICAgICAgY29uc3QgcHJldmlvdXMgPSB7fTtcclxuICAgICAgICAkYXJyYXkuZWFjaChmaWVsZHMsIChrZXkpID0+IHtcclxuICAgICAgICAgICAgc3VtW2tleV0gPSAwO1xyXG4gICAgICAgICAgICBhYnNTdW1ba2V5XSA9IDA7XHJcbiAgICAgICAgICAgIGNvdW50W2tleV0gPSAwO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgICRhcnJheS5lYWNoKGZpZWxkcywgKGtleSkgPT4ge1xyXG4gICAgICAgICAgICBsZXQgY2hhbmdlID0ga2V5ICsgXCJDaGFuZ2VcIjtcclxuICAgICAgICAgICAgbGV0IGNoYW5nZVBlcmNlbnQgPSBrZXkgKyBcIkNoYW5nZVBlcmNlbnRcIjtcclxuICAgICAgICAgICAgbGV0IGNoYW5nZVByZXZpb3VzID0ga2V5ICsgXCJDaGFuZ2VQcmV2aW91c1wiO1xyXG4gICAgICAgICAgICBsZXQgY2hhbmdlUHJldmlvdXNQZXJjZW50ID0ga2V5ICsgXCJDaGFuZ2VQcmV2aW91c1BlcmNlbnRcIjtcclxuICAgICAgICAgICAgbGV0IGNoYW5nZVNlbGVjdGlvbiA9IGtleSArIFwiQ2hhbmdlU2VsZWN0aW9uXCI7XHJcbiAgICAgICAgICAgIGxldCBjaGFuZ2VTZWxlY3Rpb25QZXJjZW50ID0ga2V5ICsgXCJDaGFuZ2VTZWxlY3Rpb25QZXJjZW50XCI7XHJcbiAgICAgICAgICAgIGxldCBvcGVuS2V5ID0gXCJ2YWx1ZVlcIjtcclxuICAgICAgICAgICAgaWYgKGtleSA9PSBcInZhbHVlWFwiIHx8IGtleSA9PSBcIm9wZW5WYWx1ZVhcIiB8fCBrZXkgPT0gXCJsb3dWYWx1ZVhcIiB8fCBrZXkgPT0gXCJoaWdoVmFsdWVYXCIpIHtcclxuICAgICAgICAgICAgICAgIG9wZW5LZXkgPSBcInZhbHVlWFwiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IGJhc2VWYWx1ZVNlcmllcyA9IHRoaXMuZ2V0UHJpdmF0ZShcImJhc2VWYWx1ZVNlcmllc1wiKTtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IHN0YXJ0SW5kZXg7IGkgPCBlbmRJbmRleDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBkYXRhSXRlbSA9IHRoaXMuZGF0YUl0ZW1zW2ldO1xyXG4gICAgICAgICAgICAgICAgbGV0IHZhbHVlID0gZGF0YUl0ZW0uZ2V0KGtleSk7XHJcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvdW50W2tleV0rKztcclxuICAgICAgICAgICAgICAgICAgICBzdW1ba2V5XSArPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICBhYnNTdW1ba2V5XSArPSBNYXRoLmFicyh2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYXZlcmFnZVtrZXldID0gc3VtW2tleV0gLyBjb3VudFtrZXldO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChsb3dba2V5XSA+IHZhbHVlIHx8IGxvd1trZXldID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbG93W2tleV0gPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGhpZ2hba2V5XSA8IHZhbHVlIHx8IGhpZ2hba2V5XSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhpZ2hba2V5XSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjbG9zZVtrZXldID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wZW5ba2V5XSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wZW5ba2V5XSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmV2aW91c1trZXldID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChiYXNlVmFsdWVTZXJpZXMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wZW5bb3BlbktleV0gPSBiYXNlVmFsdWVTZXJpZXMuX2dldEJhc2Uob3BlbktleSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXJ0SW5kZXggPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YUl0ZW0uc2V0UmF3KChjaGFuZ2UpLCB2YWx1ZSAtIG9wZW5bb3BlbktleV0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhSXRlbS5zZXRSYXcoKGNoYW5nZVBlcmNlbnQpLCAodmFsdWUgLSBvcGVuW29wZW5LZXldKSAvIG9wZW5bb3BlbktleV0gKiAxMDApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBkYXRhSXRlbS5zZXRSYXcoKGNoYW5nZVByZXZpb3VzKSwgdmFsdWUgLSBwcmV2aW91c1tvcGVuS2V5XSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YUl0ZW0uc2V0UmF3KChjaGFuZ2VQcmV2aW91c1BlcmNlbnQpLCAodmFsdWUgLSBwcmV2aW91c1tvcGVuS2V5XSkgLyBwcmV2aW91c1tvcGVuS2V5XSAqIDEwMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YUl0ZW0uc2V0UmF3KChjaGFuZ2VTZWxlY3Rpb24pLCB2YWx1ZSAtIG9wZW5bb3BlbktleV0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGRhdGFJdGVtLnNldFJhdygoY2hhbmdlU2VsZWN0aW9uUGVyY2VudCksICh2YWx1ZSAtIG9wZW5bb3BlbktleV0pIC8gb3BlbltvcGVuS2V5XSAqIDEwMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJldmlvdXNba2V5XSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgJGFycmF5LmVhY2goZmllbGRzLCAoa2V5KSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0UHJpdmF0ZSgoa2V5ICsgXCJBdmVyYWdlU2VsZWN0aW9uXCIpLCBhdmVyYWdlW2tleV0pO1xyXG4gICAgICAgICAgICB0aGlzLnNldFByaXZhdGUoKGtleSArIFwiQ291bnRTZWxlY3Rpb25cIiksIGNvdW50W2tleV0pO1xyXG4gICAgICAgICAgICB0aGlzLnNldFByaXZhdGUoKGtleSArIFwiU3VtU2VsZWN0aW9uXCIpLCBzdW1ba2V5XSk7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0UHJpdmF0ZSgoa2V5ICsgXCJBYnNvbHV0ZVN1bVNlbGVjdGlvblwiKSwgYWJzU3VtW2tleV0pO1xyXG4gICAgICAgICAgICB0aGlzLnNldFByaXZhdGUoKGtleSArIFwiTG93U2VsZWN0aW9uXCIpLCBsb3dba2V5XSk7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0UHJpdmF0ZSgoa2V5ICsgXCJIaWdoU2VsZWN0aW9uXCIpLCBoaWdoW2tleV0pO1xyXG4gICAgICAgICAgICB0aGlzLnNldFByaXZhdGUoKGtleSArIFwiT3BlblNlbGVjdGlvblwiKSwgb3BlbltrZXldKTtcclxuICAgICAgICAgICAgdGhpcy5zZXRQcml2YXRlKChrZXkgKyBcIkNsb3NlU2VsZWN0aW9uXCIpLCBjbG9zZVtrZXldKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBpZiAoc3RhcnRJbmRleCA9PT0gMCAmJiBlbmRJbmRleCA9PT0gdGhpcy5kYXRhSXRlbXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICRhcnJheS5lYWNoKGZpZWxkcywgKGtleSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZXRQcml2YXRlKChrZXkgKyBcIkF2ZXJhZ2VcIiksIGF2ZXJhZ2Vba2V5XSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNldFByaXZhdGUoKGtleSArIFwiQ291bnRcIiksIGNvdW50W2tleV0pO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZXRQcml2YXRlKChrZXkgKyBcIlN1bVwiKSwgc3VtW2tleV0pO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZXRQcml2YXRlKChrZXkgKyBcIkFic29sdXRlU3VtXCIpLCBhYnNTdW1ba2V5XSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNldFByaXZhdGUoKGtleSArIFwiTG93XCIpLCBsb3dba2V5XSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNldFByaXZhdGUoKGtleSArIFwiSGlnaFwiKSwgaGlnaFtrZXldKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2V0UHJpdmF0ZSgoa2V5ICsgXCJPcGVuXCIpLCBvcGVuW2tleV0pO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZXRQcml2YXRlKChrZXkgKyBcIkNsb3NlXCIpLCBjbG9zZVtrZXldKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgX3VwZGF0ZUNoaWxkcmVuKCkge1xyXG4gICAgICAgIHN1cGVyLl91cGRhdGVDaGlsZHJlbigpO1xyXG4gICAgICAgIHRoaXMuX3BzaSA9IHRoaXMuc3RhcnRJbmRleCgpO1xyXG4gICAgICAgIHRoaXMuX3BlaSA9IHRoaXMuZW5kSW5kZXgoKTtcclxuICAgICAgICBpZiAodGhpcy5pc0RpcnR5KFwidmlzaWJsZVwiKSkge1xyXG4gICAgICAgICAgICB0aGlzLmJ1bGxldHNDb250YWluZXIuc2V0KFwidmlzaWJsZVwiLCB0aGlzLmdldChcInZpc2libGVcIikpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBBcHBseSBoZWF0IHJ1bGVzXHJcbiAgICAgICAgY29uc3QgcnVsZXMgPSB0aGlzLmdldChcImhlYXRSdWxlc1wiKTtcclxuICAgICAgICBpZiAodGhpcy5fdmFsdWVzRGlydHkgJiYgcnVsZXMgJiYgcnVsZXMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAkYXJyYXkuZWFjaChydWxlcywgKHJ1bGUpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG1pblZhbHVlID0gcnVsZS5taW5WYWx1ZSB8fCB0aGlzLmdldFByaXZhdGUoKHJ1bGUuZGF0YUZpZWxkICsgXCJMb3dcIikpIHx8IDA7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBtYXhWYWx1ZSA9IHJ1bGUubWF4VmFsdWUgfHwgdGhpcy5nZXRQcml2YXRlKChydWxlLmRhdGFGaWVsZCArIFwiSGlnaFwiKSkgfHwgMDtcclxuICAgICAgICAgICAgICAgICRhcnJheS5lYWNoKHJ1bGUudGFyZ2V0Ll9lbnRpdGllcywgKHRhcmdldCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gdGFyZ2V0LmRhdGFJdGVtLmdldChydWxlLmRhdGFGaWVsZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEkdHlwZS5pc051bWJlcih2YWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJ1bGUubmV1dHJhbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LnNldChydWxlLmtleSwgcnVsZS5uZXV0cmFsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChydWxlLmN1c3RvbUZ1bmN0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bGUuY3VzdG9tRnVuY3Rpb24uY2FsbCh0aGlzLCB0YXJnZXQsIG1pblZhbHVlLCBtYXhWYWx1ZSwgdmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHBlcmNlbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChydWxlLmxvZ2FyaXRobWljKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwZXJjZW50ID0gKE1hdGgubG9nKHZhbHVlKSAqIE1hdGguTE9HMTBFIC0gTWF0aC5sb2cobWluVmFsdWUpICogTWF0aC5MT0cxMEUpIC8gKChNYXRoLmxvZyhtYXhWYWx1ZSkgKiBNYXRoLkxPRzEwRSAtIE1hdGgubG9nKG1pblZhbHVlKSAqIE1hdGguTE9HMTBFKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwZXJjZW50ID0gKHZhbHVlIC0gbWluVmFsdWUpIC8gKG1heFZhbHVlIC0gbWluVmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgkdHlwZS5pc051bWJlcih2YWx1ZSkgJiYgKCEkdHlwZS5pc051bWJlcihwZXJjZW50KSB8fCBNYXRoLmFicyhwZXJjZW50KSA9PSBJbmZpbml0eSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBlcmNlbnQgPSAwLjU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZml4ZXMgcHJvYmxlbXMgaWYgYWxsIHZhbHVlcyBhcmUgdGhlIHNhbWVcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHByb3BlcnR5VmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgkdHlwZS5pc051bWJlcihydWxlLm1pbikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3BlcnR5VmFsdWUgPSBydWxlLm1pbiArIChydWxlLm1heCAtIHJ1bGUubWluKSAqIHBlcmNlbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocnVsZS5taW4gaW5zdGFuY2VvZiBDb2xvcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvcGVydHlWYWx1ZSA9IENvbG9yLmludGVycG9sYXRlKHBlcmNlbnQsIHJ1bGUubWluLCBydWxlLm1heCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocnVsZS5taW4gaW5zdGFuY2VvZiBQZXJjZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eVZhbHVlID0gcGVyY2VudEludGVycG9sYXRlKHBlcmNlbnQsIHJ1bGUubWluLCBydWxlLm1heCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LnNldChydWxlLmtleSwgcHJvcGVydHlWYWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5nZXQoXCJ2aXNpYmxlXCIpKSB7XHJcbiAgICAgICAgICAgIC8vaWYgKHRoaXMuYnVsbGV0cy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIGxldCBjb3VudCA9IHRoaXMuZGF0YUl0ZW1zLmxlbmd0aDtcclxuICAgICAgICAgICAgbGV0IHN0YXJ0SW5kZXggPSB0aGlzLnN0YXJ0SW5kZXgoKTtcclxuICAgICAgICAgICAgbGV0IGVuZEluZGV4ID0gdGhpcy5lbmRJbmRleCgpO1xyXG4gICAgICAgICAgICBpZiAoZW5kSW5kZXggPCBjb3VudCkge1xyXG4gICAgICAgICAgICAgICAgZW5kSW5kZXgrKztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoc3RhcnRJbmRleCA+IDApIHtcclxuICAgICAgICAgICAgICAgIHN0YXJ0SW5kZXgtLTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0YXJ0SW5kZXg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5faGlkZUJ1bGxldHModGhpcy5kYXRhSXRlbXNbaV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSBzdGFydEluZGV4OyBpIDwgZW5kSW5kZXg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcG9zaXRpb25CdWxsZXRzKHRoaXMuZGF0YUl0ZW1zW2ldKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gZW5kSW5kZXg7IGkgPCBjb3VudDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9oaWRlQnVsbGV0cyh0aGlzLmRhdGFJdGVtc1tpXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy99XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgX3Bvc2l0aW9uQnVsbGV0cyhkYXRhSXRlbSkge1xyXG4gICAgICAgIGlmIChkYXRhSXRlbS5idWxsZXRzKSB7XHJcbiAgICAgICAgICAgICRhcnJheS5lYWNoKGRhdGFJdGVtLmJ1bGxldHMsIChidWxsZXQpID0+IHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3Bvc2l0aW9uQnVsbGV0KGJ1bGxldCk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzcHJpdGUgPSBidWxsZXQuZ2V0KFwic3ByaXRlXCIpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGJ1bGxldC5nZXQoXCJkeW5hbWljXCIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNwcml0ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzcHJpdGUuX21hcmtEaXJ0eUtleShcImZpbGxcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNwcml0ZS5tYXJrRGlydHlTaXplKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzcHJpdGUgaW5zdGFuY2VvZiBDb250YWluZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3ByaXRlLndhbGtDaGlsZHJlbigoY2hpbGQpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkLl9tYXJrRGlydHlLZXkoXCJmaWxsXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGQubWFya0RpcnR5U2l6ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkIGluc3RhbmNlb2YgTGFiZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZC50ZXh0Lm1hcmtEaXJ0eVRleHQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHNwcml0ZSBpbnN0YW5jZW9mIExhYmVsICYmIHNwcml0ZS5nZXQoXCJwb3B1bGF0ZVRleHRcIikpIHtcclxuICAgICAgICAgICAgICAgICAgICBzcHJpdGUudGV4dC5tYXJrRGlydHlUZXh0KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIF9oaWRlQnVsbGV0cyhkYXRhSXRlbSkge1xyXG4gICAgICAgIGlmIChkYXRhSXRlbS5idWxsZXRzKSB7XHJcbiAgICAgICAgICAgICRhcnJheS5lYWNoKGRhdGFJdGVtLmJ1bGxldHMsIChidWxsZXQpID0+IHtcclxuICAgICAgICAgICAgICAgIGxldCBzcHJpdGUgPSBidWxsZXQuZ2V0KFwic3ByaXRlXCIpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHNwcml0ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNwcml0ZS5zZXRQcml2YXRlKFwidmlzaWJsZVwiLCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIF9wb3NpdGlvbkJ1bGxldChfYnVsbGV0KSB7XHJcbiAgICB9XHJcbiAgICBfcGxhY2VCdWxsZXRzQ29udGFpbmVyKGNoYXJ0KSB7XHJcbiAgICAgICAgY2hhcnQuYnVsbGV0c0NvbnRhaW5lci5jaGlsZHJlbi5tb3ZlVmFsdWUodGhpcy5idWxsZXRzQ29udGFpbmVyKTtcclxuICAgIH1cclxuICAgIF9yZW1vdmVCdWxsZXRzQ29udGFpbmVyKCkge1xyXG4gICAgICAgIGNvbnN0IGJ1bGxldHNDb250YWluZXIgPSB0aGlzLmJ1bGxldHNDb250YWluZXI7XHJcbiAgICAgICAgaWYgKGJ1bGxldHNDb250YWluZXIucGFyZW50KSB7XHJcbiAgICAgICAgICAgIGJ1bGxldHNDb250YWluZXIucGFyZW50LmNoaWxkcmVuLnJlbW92ZVZhbHVlKGJ1bGxldHNDb250YWluZXIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQGlnbm9yZVxyXG4gICAgICovXHJcbiAgICBkaXNwb3NlRGF0YUl0ZW0oZGF0YUl0ZW0pIHtcclxuICAgICAgICAvL3N1cGVyLmRpc3Bvc2VEYXRhSXRlbShkYXRhSXRlbSk7IC8vIGRvZXMgbm90aGluZ1xyXG4gICAgICAgIGNvbnN0IGJ1bGxldHMgPSBkYXRhSXRlbS5idWxsZXRzO1xyXG4gICAgICAgIGlmIChidWxsZXRzKSB7XHJcbiAgICAgICAgICAgICRhcnJheS5lYWNoKGJ1bGxldHMsIChidWxsZXQpID0+IHtcclxuICAgICAgICAgICAgICAgIGJ1bGxldC5kaXNwb3NlKCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIF9nZXRJdGVtUmVhZGVyTGFiZWwoKSB7XHJcbiAgICAgICAgcmV0dXJuIFwiXCI7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNob3dzIHNlcmllcydzIGRhdGEgaXRlbS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gICBkYXRhSXRlbSAgRGF0YSBpdGVtXHJcbiAgICAgKiBAcGFyYW0gICBkdXJhdGlvbiAgQW5pbWF0aW9uIGR1cmF0aW9uIGluIG1pbGxpc2Vjb25kc1xyXG4gICAgICogQHJldHVybiAgICAgICAgICAgIFByb21pc2VcclxuICAgICAqL1xyXG4gICAgc2hvd0RhdGFJdGVtKGRhdGFJdGVtLCBkdXJhdGlvbikge1xyXG4gICAgICAgIGNvbnN0IF9zdXBlciA9IE9iamVjdC5jcmVhdGUobnVsbCwge1xyXG4gICAgICAgICAgICBzaG93RGF0YUl0ZW06IHsgZ2V0OiAoKSA9PiBzdXBlci5zaG93RGF0YUl0ZW0gfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHByb21pc2VzID0gW19zdXBlci5zaG93RGF0YUl0ZW0uY2FsbCh0aGlzLCBkYXRhSXRlbSwgZHVyYXRpb24pXTtcclxuICAgICAgICAgICAgY29uc3QgYnVsbGV0cyA9IGRhdGFJdGVtLmJ1bGxldHM7XHJcbiAgICAgICAgICAgIGlmIChidWxsZXRzKSB7XHJcbiAgICAgICAgICAgICAgICAkYXJyYXkuZWFjaChidWxsZXRzLCAoYnVsbGV0KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3ByaXRlID0gYnVsbGV0LmdldChcInNwcml0ZVwiKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc3ByaXRlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2VzLnB1c2goc3ByaXRlLnNob3coZHVyYXRpb24pKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB5aWVsZCBQcm9taXNlLmFsbChwcm9taXNlcyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEhpZGVzIHNlcmllcydzIGRhdGEgaXRlbS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gICBkYXRhSXRlbSAgRGF0YSBpdGVtXHJcbiAgICAgKiBAcGFyYW0gICBkdXJhdGlvbiAgQW5pbWF0aW9uIGR1cmF0aW9uIGluIG1pbGxpc2Vjb25kc1xyXG4gICAgICogQHJldHVybiAgICAgICAgICAgIFByb21pc2VcclxuICAgICAqL1xyXG4gICAgaGlkZURhdGFJdGVtKGRhdGFJdGVtLCBkdXJhdGlvbikge1xyXG4gICAgICAgIGNvbnN0IF9zdXBlciA9IE9iamVjdC5jcmVhdGUobnVsbCwge1xyXG4gICAgICAgICAgICBoaWRlRGF0YUl0ZW06IHsgZ2V0OiAoKSA9PiBzdXBlci5oaWRlRGF0YUl0ZW0gfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHByb21pc2VzID0gW19zdXBlci5oaWRlRGF0YUl0ZW0uY2FsbCh0aGlzLCBkYXRhSXRlbSwgZHVyYXRpb24pXTtcclxuICAgICAgICAgICAgY29uc3QgYnVsbGV0cyA9IGRhdGFJdGVtLmJ1bGxldHM7XHJcbiAgICAgICAgICAgIGlmIChidWxsZXRzKSB7XHJcbiAgICAgICAgICAgICAgICAkYXJyYXkuZWFjaChidWxsZXRzLCAoYnVsbGV0KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3ByaXRlID0gYnVsbGV0LmdldChcInNwcml0ZVwiKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc3ByaXRlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2VzLnB1c2goc3ByaXRlLmhpZGUoZHVyYXRpb24pKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB5aWVsZCBQcm9taXNlLmFsbChwcm9taXNlcyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBfc2VxdWVuY2VkU2hvd0hpZGUoc2hvdywgZHVyYXRpb24pIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5nZXQoXCJzZXF1ZW5jZWRJbnRlcnBvbGF0aW9uXCIpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoISR0eXBlLmlzTnVtYmVyKGR1cmF0aW9uKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGR1cmF0aW9uID0gdGhpcy5nZXQoXCJpbnRlcnBvbGF0aW9uRHVyYXRpb25cIiwgMCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoZHVyYXRpb24gPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3RhcnRJbmRleCA9IHRoaXMuc3RhcnRJbmRleCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVuZEluZGV4ID0gdGhpcy5lbmRJbmRleCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIFByb21pc2UuYWxsKCRhcnJheS5tYXAodGhpcy5kYXRhSXRlbXMsIChkYXRhSXRlbSwgaSkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgcmVhbER1cmF0aW9uID0gZHVyYXRpb24gfHwgMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGkgPCBzdGFydEluZGV4IC0gMTAgfHwgaSA+IGVuZEluZGV4ICsgMTApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYWxEdXJhdGlvbiA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9sZXQgZGVsYXkgPSB0aGlzLmdldChcInNlcXVlbmNlZERlbGF5XCIsIDApICogaSArIHJlYWxEdXJhdGlvbiAqIChpIC0gc3RhcnRJbmRleCkgLyAoZW5kSW5kZXggLSBzdGFydEluZGV4KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGRlbGF5ID0gdGhpcy5nZXQoXCJzZXF1ZW5jZWREZWxheVwiLCAwKSArIHJlYWxEdXJhdGlvbiAvIChlbmRJbmRleCAtIHN0YXJ0SW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB5aWVsZCAkdGltZS5zbGVlcChkZWxheSAqIChpIC0gc3RhcnRJbmRleCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2hvdykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeWllbGQgdGhpcy5zaG93RGF0YUl0ZW0oZGF0YUl0ZW0sIHJlYWxEdXJhdGlvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5aWVsZCB0aGlzLmhpZGVEYXRhSXRlbShkYXRhSXRlbSwgcmVhbER1cmF0aW9uKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0pKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB5aWVsZCBQcm9taXNlLmFsbCgkYXJyYXkubWFwKHRoaXMuZGF0YUl0ZW1zLCAoZGF0YUl0ZW0pID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNob3cpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNob3dEYXRhSXRlbShkYXRhSXRlbSwgMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5oaWRlRGF0YUl0ZW0oZGF0YUl0ZW0sIDApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEBpZ25vcmVcclxuICAgICAqL1xyXG4gICAgdXBkYXRlTGVnZW5kVmFsdWUoZGF0YUl0ZW0pIHtcclxuICAgICAgICBpZiAoZGF0YUl0ZW0pIHtcclxuICAgICAgICAgICAgY29uc3QgbGVnZW5kRGF0YUl0ZW0gPSBkYXRhSXRlbS5nZXQoXCJsZWdlbmREYXRhSXRlbVwiKTtcclxuICAgICAgICAgICAgaWYgKGxlZ2VuZERhdGFJdGVtKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZUxhYmVsID0gbGVnZW5kRGF0YUl0ZW0uZ2V0KFwidmFsdWVMYWJlbFwiKTtcclxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZUxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdGV4dCA9IHZhbHVlTGFiZWwudGV4dDtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgdHh0ID0gXCJcIjtcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZUxhYmVsLl9zZXREYXRhSXRlbShkYXRhSXRlbSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdHh0ID0gdGhpcy5nZXQoXCJsZWdlbmRWYWx1ZVRleHRcIiwgdGV4dC5nZXQoXCJ0ZXh0XCIsIFwiXCIpKTtcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZUxhYmVsLnNldChcInRleHRcIiwgdHh0KTtcclxuICAgICAgICAgICAgICAgICAgICB0ZXh0Lm1hcmtEaXJ0eVRleHQoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvbnN0IGxhYmVsID0gbGVnZW5kRGF0YUl0ZW0uZ2V0KFwibGFiZWxcIik7XHJcbiAgICAgICAgICAgICAgICBpZiAobGFiZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB0ZXh0ID0gbGFiZWwudGV4dDtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgdHh0ID0gXCJcIjtcclxuICAgICAgICAgICAgICAgICAgICBsYWJlbC5fc2V0RGF0YUl0ZW0oZGF0YUl0ZW0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHR4dCA9IHRoaXMuZ2V0KFwibGVnZW5kTGFiZWxUZXh0XCIsIHRleHQuZ2V0KFwidGV4dFwiLCBcIlwiKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgbGFiZWwuc2V0KFwidGV4dFwiLCB0eHQpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRleHQubWFya0RpcnR5VGV4dCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAaWdub3JlXHJcbiAgICAgKi9cclxuICAgIHVwZGF0ZUxlZ2VuZE1hcmtlcihfZGF0YUl0ZW0pIHtcclxuICAgIH1cclxuICAgIF9vbkhpZGUoKSB7XHJcbiAgICAgICAgc3VwZXIuX29uSGlkZSgpO1xyXG4gICAgICAgIGNvbnN0IHRvb2x0aXAgPSB0aGlzLmdldFRvb2x0aXAoKTtcclxuICAgICAgICBpZiAodG9vbHRpcCkge1xyXG4gICAgICAgICAgICB0b29sdGlwLmhpZGUoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEBpZ25vcmVcclxuICAgICAqL1xyXG4gICAgaG92ZXJEYXRhSXRlbShfZGF0YUl0ZW0pIHsgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAaWdub3JlXHJcbiAgICAgKi9cclxuICAgIHVuaG92ZXJEYXRhSXRlbShfZGF0YUl0ZW0pIHsgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAaWdub3JlXHJcbiAgICAgKi9cclxuICAgIF9nZXRCYXNlKGtleSkge1xyXG4gICAgICAgIGNvbnN0IGRhdGFJdGVtID0gdGhpcy5kYXRhSXRlbXNbdGhpcy5zdGFydEluZGV4KCldO1xyXG4gICAgICAgIGlmIChkYXRhSXRlbSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZGF0YUl0ZW0uZ2V0KGtleSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAwO1xyXG4gICAgfVxyXG59XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShTZXJpZXMsIFwiY2xhc3NOYW1lXCIsIHtcclxuICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgIHZhbHVlOiBcIlNlcmllc1wiXHJcbn0pO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoU2VyaWVzLCBcImNsYXNzTmFtZXNcIiwge1xyXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgdmFsdWU6IENvbXBvbmVudC5jbGFzc05hbWVzLmNvbmNhdChbU2VyaWVzLmNsYXNzTmFtZV0pXHJcbn0pO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1TZXJpZXMuanMubWFwIiwiaW1wb3J0IHsgR3JhcGhpY3MgfSBmcm9tIFwiLi9HcmFwaGljc1wiO1xyXG5pbXBvcnQgKiBhcyAkdHlwZSBmcm9tIFwiLi4vdXRpbC9UeXBlXCI7XHJcbmltcG9ydCB7IFBlcmNlbnQgfSBmcm9tIFwiLi4vdXRpbC9QZXJjZW50XCI7XHJcbmltcG9ydCB7IGFyYyB9IGZyb20gXCJkMy1zaGFwZVwiO1xyXG5pbXBvcnQgKiBhcyAkbWF0aCBmcm9tIFwiLi4vdXRpbC9NYXRoXCI7XHJcbi8qKlxyXG4gKiBEcmF3cyBhIHNsaWNlIHNoYXBlLlxyXG4gKlxyXG4gKiBAc2VlIHtAbGluayBodHRwczovL3d3dy5hbWNoYXJ0cy5jb20vZG9jcy92NS9jb25jZXB0cy9jb21tb24tZWxlbWVudHMvZ3JhcGhpY3MvfSBmb3IgbW9yZSBpbmZvXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgU2xpY2UgZXh0ZW5kcyBHcmFwaGljcyB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBpZ25vcmVcclxuICAgICAgICAgKi9cclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJpeFwiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiAwXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQGlnbm9yZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIml5XCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IDBcclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfZ2VuZXJhdG9yXCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IGFyYygpXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBfZ2V0VG9vbHRpcFBvaW50KCkge1xyXG4gICAgICAgIGxldCB0b29sdGlwWCA9IHRoaXMuZ2V0KFwidG9vbHRpcFhcIik7XHJcbiAgICAgICAgbGV0IHRvb2x0aXBZID0gdGhpcy5nZXQoXCJ0b29sdGlwWVwiKTtcclxuICAgICAgICBsZXQgeCA9IDA7XHJcbiAgICAgICAgbGV0IHkgPSAwO1xyXG4gICAgICAgIGlmICgkdHlwZS5pc051bWJlcih0b29sdGlwWCkpIHtcclxuICAgICAgICAgICAgeCA9IHRvb2x0aXBYO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoJHR5cGUuaXNOdW1iZXIodG9vbHRpcFkpKSB7XHJcbiAgICAgICAgICAgIHkgPSB0b29sdGlwWTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IHJhZGl1cyA9IHRoaXMuZ2V0KFwicmFkaXVzXCIsIDApO1xyXG4gICAgICAgIGxldCBpbm5lclJhZGl1cyA9IHRoaXMuZ2V0KFwiaW5uZXJSYWRpdXNcIiwgMCk7XHJcbiAgICAgICAgbGV0IGRSYWRpdXMgPSB0aGlzLmdldChcImRSYWRpdXNcIiwgMCk7XHJcbiAgICAgICAgbGV0IGRJbm5lclJhZGl1cyA9IHRoaXMuZ2V0KFwiZElubmVyUmFkaXVzXCIsIDApO1xyXG4gICAgICAgIHJhZGl1cyArPSBkUmFkaXVzO1xyXG4gICAgICAgIGlubmVyUmFkaXVzICs9IGRJbm5lclJhZGl1cztcclxuICAgICAgICBpZiAoaW5uZXJSYWRpdXMgPCAwKSB7XHJcbiAgICAgICAgICAgIGlubmVyUmFkaXVzID0gcmFkaXVzICsgaW5uZXJSYWRpdXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0b29sdGlwWCBpbnN0YW5jZW9mIFBlcmNlbnQpIHtcclxuICAgICAgICAgICAgeCA9IHRoaXMuaXggKiAoaW5uZXJSYWRpdXMgKyAocmFkaXVzIC0gaW5uZXJSYWRpdXMpICogdG9vbHRpcFgudmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodG9vbHRpcFkgaW5zdGFuY2VvZiBQZXJjZW50KSB7XHJcbiAgICAgICAgICAgIHkgPSB0aGlzLml5ICogKGlubmVyUmFkaXVzICsgKHJhZGl1cyAtIGlubmVyUmFkaXVzKSAqIHRvb2x0aXBZLnZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuZ2V0KFwiYXJjXCIpID49IDM2MCAmJiBpbm5lclJhZGl1cyA9PSAwKSB7XHJcbiAgICAgICAgICAgIHggPSAwO1xyXG4gICAgICAgICAgICB5ID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHsgeCwgeSB9O1xyXG4gICAgfVxyXG4gICAgX2JlZm9yZUNoYW5nZWQoKSB7XHJcbiAgICAgICAgc3VwZXIuX2JlZm9yZUNoYW5nZWQoKTtcclxuICAgICAgICBpZiAodGhpcy5pc0RpcnR5KFwicmFkaXVzXCIpIHx8IHRoaXMuaXNEaXJ0eShcImFyY1wiKSB8fCB0aGlzLmlzRGlydHkoXCJpbm5lclJhZGl1c1wiKSB8fCB0aGlzLmlzRGlydHkoXCJzdGFydEFuZ2xlXCIpIHx8IHRoaXMuaXNEaXJ0eShcImRSYWRpdXNcIikgfHwgdGhpcy5pc0RpcnR5KFwiZElubmVyUmFkaXVzXCIpIHx8IHRoaXMuaXNEaXJ0eShcImNvcm5lclJhZGl1c1wiKSB8fCB0aGlzLmlzRGlydHkoXCJzaGlmdFJhZGl1c1wiKSkge1xyXG4gICAgICAgICAgICB0aGlzLl9jbGVhciA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgX2NoYW5nZWQoKSB7XHJcbiAgICAgICAgc3VwZXIuX2NoYW5nZWQoKTtcclxuICAgICAgICBpZiAodGhpcy5fY2xlYXIpIHtcclxuICAgICAgICAgICAgbGV0IHN0YXJ0QW5nbGUgPSB0aGlzLmdldChcInN0YXJ0QW5nbGVcIiwgMCk7XHJcbiAgICAgICAgICAgIGxldCBhcmMgPSB0aGlzLmdldChcImFyY1wiLCAwKTtcclxuICAgICAgICAgICAgY29uc3QgZ2VuZXJhdG9yID0gdGhpcy5fZ2VuZXJhdG9yO1xyXG4gICAgICAgICAgICBpZiAoYXJjIDwgMCkge1xyXG4gICAgICAgICAgICAgICAgc3RhcnRBbmdsZSA9IHN0YXJ0QW5nbGUgKyBhcmM7XHJcbiAgICAgICAgICAgICAgICBhcmMgPSBhcmMgKiAtMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoYXJjID4gMC4xKSB7IC8vIHRoaXMgZml4ZXMgYnVnIHdpdGggZnVsbCBjaXJjbGUgd2hlbiBhcmMgaXMgdmVyeSBzbWFsbFxyXG4gICAgICAgICAgICAgICAgZ2VuZXJhdG9yLmNvcm5lclJhZGl1cyh0aGlzLmdldChcImNvcm5lclJhZGl1c1wiLCAwKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZ2VuZXJhdG9yLmNvbnRleHQodGhpcy5fZGlzcGxheSk7XHJcbiAgICAgICAgICAgIGxldCByYWRpdXMgPSB0aGlzLmdldChcInJhZGl1c1wiLCAwKTtcclxuICAgICAgICAgICAgbGV0IGlubmVyUmFkaXVzID0gdGhpcy5nZXQoXCJpbm5lclJhZGl1c1wiLCAwKTtcclxuICAgICAgICAgICAgbGV0IGRSYWRpdXMgPSB0aGlzLmdldChcImRSYWRpdXNcIiwgMCk7XHJcbiAgICAgICAgICAgIGxldCBkSW5uZXJSYWRpdXMgPSB0aGlzLmdldChcImRJbm5lclJhZGl1c1wiLCAwKTtcclxuICAgICAgICAgICAgcmFkaXVzICs9IGRSYWRpdXM7XHJcbiAgICAgICAgICAgIGlubmVyUmFkaXVzICs9IGRJbm5lclJhZGl1cztcclxuICAgICAgICAgICAgaWYgKGlubmVyUmFkaXVzIDwgMCkge1xyXG4gICAgICAgICAgICAgICAgaW5uZXJSYWRpdXMgPSByYWRpdXMgKyBpbm5lclJhZGl1cztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBnZW5lcmF0b3IoeyBpbm5lclJhZGl1czogaW5uZXJSYWRpdXMsIG91dGVyUmFkaXVzOiByYWRpdXMsIHN0YXJ0QW5nbGU6IChzdGFydEFuZ2xlICsgOTApICogJG1hdGguUkFESUFOUywgZW5kQW5nbGU6IChzdGFydEFuZ2xlICsgYXJjICsgOTApICogJG1hdGguUkFESUFOUyB9KTtcclxuICAgICAgICAgICAgbGV0IG1pZGRsZUFuZ2xlID0gc3RhcnRBbmdsZSArIGFyYyAvIDI7XHJcbiAgICAgICAgICAgIHRoaXMuaXggPSAkbWF0aC5jb3MobWlkZGxlQW5nbGUpO1xyXG4gICAgICAgICAgICB0aGlzLml5ID0gJG1hdGguc2luKG1pZGRsZUFuZ2xlKTtcclxuICAgICAgICAgICAgY29uc3Qgc2hpZnRSYWRpdXMgPSB0aGlzLmdldChcInNoaWZ0UmFkaXVzXCIsIDApO1xyXG4gICAgICAgICAgICB0aGlzLnNldFJhdyhcImR4XCIsIHRoaXMuaXggKiBzaGlmdFJhZGl1cyk7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0UmF3KFwiZHlcIiwgdGhpcy5peSAqIHNoaWZ0UmFkaXVzKTtcclxuICAgICAgICAgICAgdGhpcy5tYXJrRGlydHlQb3NpdGlvbigpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoU2xpY2UsIFwiY2xhc3NOYW1lXCIsIHtcclxuICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgIHZhbHVlOiBcIlNsaWNlXCJcclxufSk7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShTbGljZSwgXCJjbGFzc05hbWVzXCIsIHtcclxuICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgIHZhbHVlOiBHcmFwaGljcy5jbGFzc05hbWVzLmNvbmNhdChbU2xpY2UuY2xhc3NOYW1lXSlcclxufSk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVNsaWNlLmpzLm1hcCIsImltcG9ydCB7IF9fYXdhaXRlciB9IGZyb20gXCJ0c2xpYlwiO1xyXG5pbXBvcnQgeyBFbnRpdHkgfSBmcm9tIFwiLi4vdXRpbC9FbnRpdHlcIjtcclxuaW1wb3J0IHsgVGVtcGxhdGUgfSBmcm9tIFwiLi4vdXRpbC9UZW1wbGF0ZVwiO1xyXG5pbXBvcnQgeyBQZXJjZW50IH0gZnJvbSBcIi4uL3V0aWwvUGVyY2VudFwiO1xyXG5pbXBvcnQgeyBFdmVudERpc3BhdGNoZXIgfSBmcm9tIFwiLi4vdXRpbC9FdmVudERpc3BhdGNoZXJcIjtcclxuaW1wb3J0IHsgTXVsdGlEaXNwb3NlciwgQ291bnRlckRpc3Bvc2VyIH0gZnJvbSBcIi4uL3V0aWwvRGlzcG9zZXJcIjtcclxuaW1wb3J0IHsgd2FpdEZvckFuaW1hdGlvbnMgfSBmcm9tIFwiLi4vdXRpbC9BbmltYXRpb25cIjtcclxuaW1wb3J0ICogYXMgJHV0aWxzIGZyb20gXCIuLi91dGlsL1V0aWxzXCI7XHJcbmltcG9ydCAqIGFzICRhcnJheSBmcm9tIFwiLi4vdXRpbC9BcnJheVwiO1xyXG5pbXBvcnQgKiBhcyAkdHlwZSBmcm9tIFwiLi4vdXRpbC9UeXBlXCI7XHJcbmltcG9ydCAqIGFzICRvYmplY3QgZnJvbSBcIi4uL3V0aWwvT2JqZWN0XCI7XHJcbmltcG9ydCAqIGFzICRtYXRoIGZyb20gXCIuLi91dGlsL01hdGhcIjtcclxuLy9pbXBvcnQgeyBwb3B1bGF0ZVN0cmluZyB9IGZyb20gXCIuLi91dGlsL1BvcHVsYXRlU3RyaW5nXCI7XHJcbi8qKlxyXG4gKiBBbiBbW0V2ZW50RGlzcGF0Y2hlcl1dIGZvciBbW1Nwcml0ZV1dLlxyXG4gKlxyXG4gKiBAc2VlIHtAbGluayBodHRwczovL3d3dy5hbWNoYXJ0cy5jb20vZG9jcy92NS9jb25jZXB0cy9ldmVudHMvfSBmb3IgbW9yZSBpbmZvXHJcbiAqL1xyXG5jbGFzcyBTcHJpdGVFdmVudERpc3BhdGNoZXIgZXh0ZW5kcyBFdmVudERpc3BhdGNoZXIge1xyXG4gICAgY29uc3RydWN0b3Ioc3ByaXRlKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfc3ByaXRlXCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9yZW5kZXJlckRpc3Bvc2Vyc1wiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiB7fVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9kaXNwYXRjaFBhcmVudHNcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuX3Nwcml0ZSA9IHNwcml0ZTtcclxuICAgIH1cclxuICAgIF9tYWtlUG9pbnRlckV2ZW50KGtleSwgZXZlbnQpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB0eXBlOiBrZXksXHJcbiAgICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IGV2ZW50LmV2ZW50LFxyXG4gICAgICAgICAgICBwb2ludDogZXZlbnQucG9pbnQsXHJcbiAgICAgICAgICAgIHNpbXVsYXRlZDogZXZlbnQuc2ltdWxhdGVkLFxyXG4gICAgICAgICAgICBuYXRpdmU6IGV2ZW50Lm5hdGl2ZSxcclxuICAgICAgICAgICAgdGFyZ2V0OiB0aGlzLl9zcHJpdGVcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgX29uUmVuZGVyZXIoa2V5LCBkaXNwYXRjaCkge1xyXG4gICAgICAgIC8vIFRPRE86IGlzIHRoaXMgT0s/IGl0J2QgYmUgZ29vZCBub3QgdG8gcmVxdWlyZSB0byBzZXQgdGhpcyBvbiBlYWNoIGluZGl2aWR1YWwgZWxlbWVudFxyXG4gICAgICAgIHRoaXMuX3Nwcml0ZS5zZXQoXCJpbnRlcmFjdGl2ZVwiLCB0cnVlKTtcclxuICAgICAgICB0aGlzLl9zcHJpdGUuX2Rpc3BsYXkuaW50ZXJhY3RpdmUgPSB0cnVlO1xyXG4gICAgICAgIGxldCBldmVudHMgPSB0aGlzLl9yZW5kZXJlckRpc3Bvc2Vyc1trZXldO1xyXG4gICAgICAgIGlmIChldmVudHMgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBjb25zdCBkaXNwb3NlciA9IHRoaXMuX3Nwcml0ZS5fZGlzcGxheS5vbihrZXksIChlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBkaXNwYXRjaC5jYWxsKHRoaXMsIGUpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgZXZlbnRzID0gdGhpcy5fcmVuZGVyZXJEaXNwb3NlcnNba2V5XSA9IG5ldyBDb3VudGVyRGlzcG9zZXIoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuX3JlbmRlcmVyRGlzcG9zZXJzW2tleV07XHJcbiAgICAgICAgICAgICAgICBkaXNwb3Nlci5kaXNwb3NlKCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZXZlbnRzLmluY3JlbWVudCgpO1xyXG4gICAgfVxyXG4gICAgX29uKG9uY2UsIHR5cGUsIGNhbGxiYWNrLCBjb250ZXh0LCBzaG91bGRDbG9uZSwgZGlzcGF0Y2gpIHtcclxuICAgICAgICBjb25zdCBpbmZvID0gc3VwZXIuX29uKG9uY2UsIHR5cGUsIGNhbGxiYWNrLCBjb250ZXh0LCBzaG91bGRDbG9uZSwgZGlzcGF0Y2gpO1xyXG4gICAgICAgIGNvbnN0IHJlbmRlcmVyRXZlbnQgPSBTcHJpdGVFdmVudERpc3BhdGNoZXIuUkVOREVSRVJfRVZFTlRTW3R5cGVdO1xyXG4gICAgICAgIGlmIChyZW5kZXJlckV2ZW50ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgaW5mby5kaXNwb3NlciA9IG5ldyBNdWx0aURpc3Bvc2VyKFtcclxuICAgICAgICAgICAgICAgIGluZm8uZGlzcG9zZXIsXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9vblJlbmRlcmVyKHR5cGUsIHJlbmRlcmVyRXZlbnQpLFxyXG4gICAgICAgICAgICBdKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGluZm87XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFdpbGwgc3RvcCBhbnkgYnViYmxpbmcgdXAgb2YgdGhlIGV2ZW50IHRvIGVsZW1lbnQncyBwYXJlbnRzLlxyXG4gICAgICpcclxuICAgICAqIFNob3VsZCBiZSBjYWxsZWQgaW4gYW4gZXZlbnQgaGFuZGxlciwgZS5nLjpcclxuICAgICAqXHJcbiAgICAgKiBgYGBUeXBlU2NyaXB0XHJcbiAgICAgKiBlbGVtZW50LmV2ZW50cy5vbihcInBvaW50ZXJkb3duXCIsIGZ1bmN0aW9uKGV2KSB7XHJcbiAgICAgKiAgIC8vIERvIHNvbWV0aGluZyBoZXJlIGFuZCBwcmV2ZW50IGZyb20gXCJwb2ludGVyZG93blwiIGJ1YmJsaW5nIHVwXHJcbiAgICAgKiAgIC8vIC4uLlxyXG4gICAgICogICBldi50YXJnZXQuZXZlbnRzLnN0b3BQYXJlbnREaXNwYXRjaCgpO1xyXG4gICAgICogfSk7XHJcbiAgICAgKiBgYGBcclxuICAgICAqIGBgYEphdmFTY3JpcHRcclxuICAgICAqIGVsZW1lbnQuZXZlbnRzLm9uKFwicG9pbnRlcmRvd25cIiwgZnVuY3Rpb24oZXYpIHtcclxuICAgICAqICAgLy8gRG8gc29tZXRoaW5nIGhlcmUgYW5kIHByZXZlbnQgZnJvbSBcInBvaW50ZXJkb3duXCIgYnViYmxpbmcgdXBcclxuICAgICAqICAgLy8gLi4uXHJcbiAgICAgKiAgIGV2LnRhcmdldC5ldmVudHMuc3RvcFBhcmVudERpc3BhdGNoKCk7XHJcbiAgICAgKiB9KTtcclxuICAgICAqIGBgYFxyXG4gICAgICovXHJcbiAgICBzdG9wUGFyZW50RGlzcGF0Y2goKSB7XHJcbiAgICAgICAgdGhpcy5fZGlzcGF0Y2hQYXJlbnRzID0gZmFsc2U7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEBpZ25vcmVcclxuICAgICAqL1xyXG4gICAgZGlzcGF0Y2hQYXJlbnRzKHR5cGUsIGV2ZW50KSB7XHJcbiAgICAgICAgY29uc3Qgb2xkID0gdGhpcy5fZGlzcGF0Y2hQYXJlbnRzO1xyXG4gICAgICAgIHRoaXMuX2Rpc3BhdGNoUGFyZW50cyA9IHRydWU7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaCh0eXBlLCBldmVudCk7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9kaXNwYXRjaFBhcmVudHMgJiYgdGhpcy5fc3ByaXRlLnBhcmVudCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc3ByaXRlLnBhcmVudC5ldmVudHMuZGlzcGF0Y2hQYXJlbnRzKHR5cGUsIGV2ZW50KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBmaW5hbGx5IHtcclxuICAgICAgICAgICAgdGhpcy5fZGlzcGF0Y2hQYXJlbnRzID0gb2xkO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoU3ByaXRlRXZlbnREaXNwYXRjaGVyLCBcIlJFTkRFUkVSX0VWRU5UU1wiLCB7XHJcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICB2YWx1ZToge1xyXG4gICAgICAgIFwiY2xpY2tcIjogZnVuY3Rpb24gKGV2ZW50KSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmlzRW5hYmxlZChcImNsaWNrXCIpICYmICF0aGlzLl9zcHJpdGUuaXNEcmFnZ2luZygpICYmIHRoaXMuX3Nwcml0ZS5faGFzRG93bigpICYmICF0aGlzLl9zcHJpdGUuX2hhc01vdmVkKHRoaXMuX21ha2VQb2ludGVyRXZlbnQoXCJjbGlja1wiLCBldmVudCkpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoKFwiY2xpY2tcIiwgdGhpcy5fbWFrZVBvaW50ZXJFdmVudChcImNsaWNrXCIsIGV2ZW50KSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIFwicmlnaHRjbGlja1wiOiBmdW5jdGlvbiAoZXZlbnQpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuaXNFbmFibGVkKFwicmlnaHRjbGlja1wiKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaChcInJpZ2h0Y2xpY2tcIiwgdGhpcy5fbWFrZVBvaW50ZXJFdmVudChcInJpZ2h0Y2xpY2tcIiwgZXZlbnQpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXCJtaWRkbGVjbGlja1wiOiBmdW5jdGlvbiAoZXZlbnQpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuaXNFbmFibGVkKFwibWlkZGxlY2xpY2tcIikpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2goXCJtaWRkbGVjbGlja1wiLCB0aGlzLl9tYWtlUG9pbnRlckV2ZW50KFwibWlkZGxlY2xpY2tcIiwgZXZlbnQpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXCJkYmxjbGlja1wiOiBmdW5jdGlvbiAoZXZlbnQpIHtcclxuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaFBhcmVudHMoXCJkYmxjbGlja1wiLCB0aGlzLl9tYWtlUG9pbnRlckV2ZW50KFwiZGJsY2xpY2tcIiwgZXZlbnQpKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIFwicG9pbnRlcm92ZXJcIjogZnVuY3Rpb24gKGV2ZW50KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHNwcml0ZSA9IHRoaXMuX3Nwcml0ZTtcclxuICAgICAgICAgICAgbGV0IGRpc3BhdGNoID0gdHJ1ZTtcclxuICAgICAgICAgICAgaWYgKHNwcml0ZS5nZXRQcml2YXRlKFwidHJ1c3RCb3VuZHNcIikpIHtcclxuICAgICAgICAgICAgICAgIHNwcml0ZS5fZ2V0Qm91bmRzKCk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBib3VuZHMgPSBzcHJpdGUuZ2xvYmFsQm91bmRzKCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoISRtYXRoLmluQm91bmRzKGV2ZW50LnBvaW50LCBib3VuZHMpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2ggPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICBzcHJpdGUuX3Jvb3QuX3JlbmRlcmVyLnJlbW92ZUhvdmVyaW5nKHNwcml0ZS5fZGlzcGxheSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGRpc3BhdGNoICYmIHRoaXMuaXNFbmFibGVkKFwicG9pbnRlcm92ZXJcIikpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2goXCJwb2ludGVyb3ZlclwiLCB0aGlzLl9tYWtlUG9pbnRlckV2ZW50KFwicG9pbnRlcm92ZXJcIiwgZXZlbnQpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXCJwb2ludGVyb3V0XCI6IGZ1bmN0aW9uIChldmVudCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5pc0VuYWJsZWQoXCJwb2ludGVyb3V0XCIpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoKFwicG9pbnRlcm91dFwiLCB0aGlzLl9tYWtlUG9pbnRlckV2ZW50KFwicG9pbnRlcm91dFwiLCBldmVudCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBcInBvaW50ZXJkb3duXCI6IGZ1bmN0aW9uIChldmVudCkge1xyXG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoUGFyZW50cyhcInBvaW50ZXJkb3duXCIsIHRoaXMuX21ha2VQb2ludGVyRXZlbnQoXCJwb2ludGVyZG93blwiLCBldmVudCkpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXCJwb2ludGVydXBcIjogZnVuY3Rpb24gKGV2ZW50KSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmlzRW5hYmxlZChcInBvaW50ZXJ1cFwiKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaChcInBvaW50ZXJ1cFwiLCB0aGlzLl9tYWtlUG9pbnRlckV2ZW50KFwicG9pbnRlcnVwXCIsIGV2ZW50KSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIFwiZ2xvYmFscG9pbnRlcnVwXCI6IGZ1bmN0aW9uIChldmVudCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5pc0VuYWJsZWQoXCJnbG9iYWxwb2ludGVydXBcIikpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2goXCJnbG9iYWxwb2ludGVydXBcIiwgdGhpcy5fbWFrZVBvaW50ZXJFdmVudChcImdsb2JhbHBvaW50ZXJ1cFwiLCBldmVudCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBcImdsb2JhbHBvaW50ZXJtb3ZlXCI6IGZ1bmN0aW9uIChldmVudCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5pc0VuYWJsZWQoXCJnbG9iYWxwb2ludGVybW92ZVwiKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaChcImdsb2JhbHBvaW50ZXJtb3ZlXCIsIHRoaXMuX21ha2VQb2ludGVyRXZlbnQoXCJnbG9iYWxwb2ludGVybW92ZVwiLCBldmVudCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBcIndoZWVsXCI6IGZ1bmN0aW9uIChldmVudCkge1xyXG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoUGFyZW50cyhcIndoZWVsXCIsIHtcclxuICAgICAgICAgICAgICAgIHR5cGU6IFwid2hlZWxcIixcclxuICAgICAgICAgICAgICAgIHRhcmdldDogdGhpcy5fc3ByaXRlLFxyXG4gICAgICAgICAgICAgICAgb3JpZ2luYWxFdmVudDogZXZlbnQuZXZlbnQsXHJcbiAgICAgICAgICAgICAgICBwb2ludDogZXZlbnQucG9pbnQsXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0sXHJcbiAgICB9XHJcbn0pO1xyXG4vKipcclxuICogQSBiYXNlIGNsYXNzIGZvciBhbGwgdmlzdWFsIGVsZW1lbnRzLlxyXG4gKlxyXG4gKiBAaW1wb3J0YW50XHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgU3ByaXRlIGV4dGVuZHMgRW50aXR5IHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX2FkanVzdGVkTG9jYWxCb3VuZHNcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogeyBsZWZ0OiAwLCByaWdodDogMCwgdG9wOiAwLCBib3R0b206IDAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9sb2NhbEJvdW5kc1wiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiB7IGxlZnQ6IDAsIHJpZ2h0OiAwLCB0b3A6IDAsIGJvdHRvbTogMCB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX3BhcmVudFwiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfZGF0YUl0ZW1cIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX3RlbXBsYXRlRmllbGRcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX3NpemVEaXJ0eVwiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiBmYWxzZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8vIFdpbGwgYmUgdHJ1ZSBvbmx5IHdoZW4gZHJhZ2dpbmdcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfaXNEcmFnZ2luZ1wiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiBmYWxzZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8vIFRoZSBldmVudCB3aGVuIHRoZSBkcmFnZ2luZyBzdGFydHNcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfZHJhZ0V2ZW50XCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8vIFRoZSBwb3NpdGlvbiB3aGVuIGRyYWdnaW5nIHN0YXJ0c1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9kcmFnUG9pbnRcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX2lzSGlkZGVuXCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IGZhbHNlXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX2lzU2hvd2luZ1wiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiBmYWxzZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9pc0hpZGluZ1wiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiBmYWxzZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9pc0Rvd25cIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogZmFsc2VcclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfZG93blBvaW50XCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9kb3duUG9pbnRzXCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IHt9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX3RvZ2dsZURwXCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9kcmFnRHBcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX3Rvb2x0aXBEcFwiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfaG92ZXJEcFwiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfZm9jdXNEcFwiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfdG9vbHRpcE1vdmVEcFwiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfdG9vbHRpcFBvaW50ZXJEcFwiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfc3RhdGVzSGFuZGxlZFwiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiBmYWxzZVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgX2FmdGVyTmV3KCkge1xyXG4gICAgICAgIHRoaXMuc2V0UHJpdmF0ZVJhdyhcInZpc2libGVcIiwgdHJ1ZSk7XHJcbiAgICAgICAgc3VwZXIuX2FmdGVyTmV3KCk7XHJcbiAgICB9XHJcbiAgICBfbWFya0RpcnR5S2V5KGtleSkge1xyXG4gICAgICAgIHN1cGVyLl9tYXJrRGlydHlLZXkoa2V5KTtcclxuICAgICAgICBpZiAoa2V5ID09IFwieFwiIHx8IGtleSA9PSBcInlcIiB8fCBrZXkgPT0gXCJkeFwiIHx8IGtleSA9PSBcImR5XCIpIHtcclxuICAgICAgICAgICAgdGhpcy5tYXJrRGlydHlCb3VuZHMoKTtcclxuICAgICAgICAgICAgdGhpcy5fYWRkUGVyY2VudGFnZVBvc2l0aW9uQ2hpbGRyZW4oKTtcclxuICAgICAgICAgICAgdGhpcy5tYXJrRGlydHlQb3NpdGlvbigpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIF9tYXJrRGlydHlQcml2YXRlS2V5KGtleSkge1xyXG4gICAgICAgIHN1cGVyLl9tYXJrRGlydHlQcml2YXRlS2V5KGtleSk7XHJcbiAgICAgICAgaWYgKGtleSA9PSBcInhcIiB8fCBrZXkgPT0gXCJ5XCIpIHtcclxuICAgICAgICAgICAgdGhpcy5tYXJrRGlydHlQb3NpdGlvbigpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIF9yZW1vdmVUZW1wbGF0ZUZpZWxkKCkge1xyXG4gICAgICAgIGlmICh0aGlzLl90ZW1wbGF0ZUZpZWxkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3RlbXBsYXRlRmllbGQuX3JlbW92ZU9iamVjdFRlbXBsYXRlKHRoaXMpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIF9jcmVhdGVFdmVudHMoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBTcHJpdGVFdmVudERpc3BhdGNoZXIodGhpcyk7XHJcbiAgICB9XHJcbiAgICBfcHJvY2Vzc1RlbXBsYXRlRmllbGQoKSB7XHJcbiAgICAgICAgbGV0IHRlbXBsYXRlO1xyXG4gICAgICAgIGNvbnN0IGZpZWxkID0gdGhpcy5nZXQoXCJ0ZW1wbGF0ZUZpZWxkXCIpO1xyXG4gICAgICAgIGlmIChmaWVsZCkge1xyXG4gICAgICAgICAgICBjb25zdCBkYXRhSXRlbSA9IHRoaXMuZGF0YUl0ZW07XHJcbiAgICAgICAgICAgIGlmIChkYXRhSXRlbSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY29udGV4dCA9IGRhdGFJdGVtLmRhdGFDb250ZXh0O1xyXG4gICAgICAgICAgICAgICAgaWYgKGNvbnRleHQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZSA9IGNvbnRleHRbZmllbGRdO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghKHRlbXBsYXRlIGluc3RhbmNlb2YgVGVtcGxhdGUpICYmIHRlbXBsYXRlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlID0gVGVtcGxhdGUubmV3KHRlbXBsYXRlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuX3RlbXBsYXRlRmllbGQgIT09IHRlbXBsYXRlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3JlbW92ZVRlbXBsYXRlRmllbGQoKTtcclxuICAgICAgICAgICAgdGhpcy5fdGVtcGxhdGVGaWVsZCA9IHRlbXBsYXRlO1xyXG4gICAgICAgICAgICBpZiAodGVtcGxhdGUpIHtcclxuICAgICAgICAgICAgICAgIHRlbXBsYXRlLl9zZXRPYmplY3RUZW1wbGF0ZSh0aGlzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9hcHBseVRlbXBsYXRlcygpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIFRPRE8gY2hhbmdlIHRoaXMgdG8gcnVuIGJlZm9yZSB0aGUgZWxlbWVudCBpcyBhZGRlZCB0byB0aGUgcGFyZW50LCBzbyB0aGF0IHdheVxyXG4gICAgLy8gICAgICBpdCBkb2Vzbid0IG5lZWQgdG8gYXBwbHkgdGhlIHRoZW1lcyB0d2ljZVxyXG4gICAgX3NldERhdGFJdGVtKGRhdGFJdGVtKSB7XHJcbiAgICAgICAgY29uc3Qgb2xkRGF0YUl0ZW0gPSB0aGlzLl9kYXRhSXRlbTtcclxuICAgICAgICB0aGlzLl9kYXRhSXRlbSA9IGRhdGFJdGVtO1xyXG4gICAgICAgIHRoaXMuX3Byb2Nlc3NUZW1wbGF0ZUZpZWxkKCk7XHJcbiAgICAgICAgY29uc3QgZXZlbnRUeXBlID0gXCJkYXRhaXRlbWNoYW5nZWRcIjtcclxuICAgICAgICBpZiAoZGF0YUl0ZW0gIT0gb2xkRGF0YUl0ZW0pIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuZXZlbnRzLmlzRW5hYmxlZChldmVudFR5cGUpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50cy5kaXNwYXRjaChldmVudFR5cGUsIHtcclxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBldmVudFR5cGUsXHJcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0OiB0aGlzLFxyXG4gICAgICAgICAgICAgICAgICAgIG9sZERhdGFJdGVtOiBvbGREYXRhSXRlbSxcclxuICAgICAgICAgICAgICAgICAgICBuZXdEYXRhSXRlbTogZGF0YUl0ZW1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBIFtbRGF0YUl0ZW1dXSB1c2VkIGZvciB0aGlzIGVsZW1lbnQuXHJcbiAgICAgKlxyXG4gICAgICogTk9URTogZGF0YSBpdGVtIGlzIGJlaW5nIGFzc2lnbmVkIGF1dG9tYXRpY2FsbHkgaW4gbW9zdCBjYXNlcyB3aGVyZSBpdFxyXG4gICAgICogbWF0dGVycy4gVXNlIHRoaXMgYWNjZXNzb3IgdG8gc2V0IGRhdGEgaXRlbSBvbmx5IGlmIHlvdSBrbm93IHdoYXQgeW91J3JlXHJcbiAgICAgKiBkb2luZy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gIHZhbHVlICBEYXRhIGl0ZW1cclxuICAgICAqL1xyXG4gICAgc2V0IGRhdGFJdGVtKHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5fc2V0RGF0YUl0ZW0odmFsdWUpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJuIERhdGFJdGVtXHJcbiAgICAgKi9cclxuICAgIGdldCBkYXRhSXRlbSgpIHtcclxuICAgICAgICBpZiAodGhpcy5fZGF0YUl0ZW0pIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGFJdGVtO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgbGV0IHBhcmVudCA9IHRoaXMuX3BhcmVudDtcclxuICAgICAgICAgICAgd2hpbGUgKHBhcmVudCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHBhcmVudC5fZGF0YUl0ZW0pIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFyZW50Ll9kYXRhSXRlbTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudCA9IHBhcmVudC5fcGFyZW50O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgX2FkZFBlcmNlbnRhZ2VTaXplQ2hpbGRyZW4oKSB7XHJcbiAgICAgICAgbGV0IHBhcmVudCA9IHRoaXMucGFyZW50O1xyXG4gICAgICAgIGlmIChwYXJlbnQpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuZ2V0KFwid2lkdGhcIikgaW5zdGFuY2VvZiBQZXJjZW50IHx8IHRoaXMuZ2V0KFwiaGVpZ2h0XCIpIGluc3RhbmNlb2YgUGVyY2VudCkge1xyXG4gICAgICAgICAgICAgICAgJGFycmF5LnB1c2hPbmUocGFyZW50Ll9wZXJjZW50YWdlU2l6ZUNoaWxkcmVuLCB0aGlzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICRhcnJheS5yZW1vdmVGaXJzdChwYXJlbnQuX3BlcmNlbnRhZ2VTaXplQ2hpbGRyZW4sIHRoaXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgX2FkZFBlcmNlbnRhZ2VQb3NpdGlvbkNoaWxkcmVuKCkge1xyXG4gICAgICAgIGxldCBwYXJlbnQgPSB0aGlzLnBhcmVudDtcclxuICAgICAgICBpZiAocGFyZW50KSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmdldChcInhcIikgaW5zdGFuY2VvZiBQZXJjZW50IHx8IHRoaXMuZ2V0KFwieVwiKSBpbnN0YW5jZW9mIFBlcmNlbnQpIHtcclxuICAgICAgICAgICAgICAgICRhcnJheS5wdXNoT25lKHBhcmVudC5fcGVyY2VudGFnZVBvc2l0aW9uQ2hpbGRyZW4sIHRoaXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgJGFycmF5LnJlbW92ZUZpcnN0KHBhcmVudC5fcGVyY2VudGFnZVBvc2l0aW9uQ2hpbGRyZW4sIHRoaXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAaWdub3JlXHJcbiAgICAgKi9cclxuICAgIG1hcmtEaXJ0eVBvc2l0aW9uKCkge1xyXG4gICAgICAgIHRoaXMuX3Jvb3QuX2FkZERpcnR5UG9zaXRpb24odGhpcyk7XHJcbiAgICB9XHJcbiAgICB1cGRhdGVQaXZvdFBvaW50KCkge1xyXG4gICAgICAgIGNvbnN0IGJvdW5kcyA9IHRoaXMuX2xvY2FsQm91bmRzO1xyXG4gICAgICAgIGlmIChib3VuZHMpIHtcclxuICAgICAgICAgICAgY29uc3QgY2VudGVyWCA9IHRoaXMuZ2V0KFwiY2VudGVyWFwiKTtcclxuICAgICAgICAgICAgaWYgKGNlbnRlclggIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZGlzcGxheS5waXZvdC54ID0gYm91bmRzLmxlZnQgKyAkdXRpbHMucmVsYXRpdmVUb1ZhbHVlKGNlbnRlclgsIGJvdW5kcy5yaWdodCAtIGJvdW5kcy5sZWZ0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBjZW50ZXJZID0gdGhpcy5nZXQoXCJjZW50ZXJZXCIpO1xyXG4gICAgICAgICAgICBpZiAoY2VudGVyWSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9kaXNwbGF5LnBpdm90LnkgPSBib3VuZHMudG9wICsgJHV0aWxzLnJlbGF0aXZlVG9WYWx1ZShjZW50ZXJZLCBib3VuZHMuYm90dG9tIC0gYm91bmRzLnRvcCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBfYmVmb3JlQ2hhbmdlZCgpIHtcclxuICAgICAgICBzdXBlci5fYmVmb3JlQ2hhbmdlZCgpO1xyXG4gICAgICAgIC8vIGhhbmRsaW5nIHN0YXRlcyBpbiBiZWZvcmVDaGFuZ2VkLCBvdGhlcndpc2Ugc3RhdGVzIGlzIG5vdCBhcHBsaWVkIHdpdGhvdXQgYW5pbWF0ZWQgdGhlbWVcclxuICAgICAgICB0aGlzLl9oYW5kbGVTdGF0ZXMoKTtcclxuICAgICAgICBpZiAodGhpcy5pc0RpcnR5KFwidG9vbHRpcFwiKSkge1xyXG4gICAgICAgICAgICBjb25zdCBwcmV2aW91cyA9IHRoaXMuX3ByZXZTZXR0aW5ncy50b29sdGlwO1xyXG4gICAgICAgICAgICBpZiAocHJldmlvdXMpIHtcclxuICAgICAgICAgICAgICAgIHByZXZpb3VzLmRpc3Bvc2UoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5pc0RpcnR5KFwibGF5ZXJcIikgfHwgdGhpcy5pc0RpcnR5KFwibGF5ZXJNYXJnaW5cIikpIHtcclxuICAgICAgICAgICAgdGhpcy5fZGlzcGxheS5zZXRMYXllcih0aGlzLmdldChcImxheWVyXCIpLCB0aGlzLmdldChcImxheWVyTWFyZ2luXCIpKTtcclxuICAgICAgICAgICAgdGhpcy5tYXJrRGlydHlMYXllcigpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5pc0RpcnR5KFwidG9vbHRpcFBvc2l0aW9uXCIpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHRvb2x0aXBNb3ZlRHAgPSB0aGlzLl90b29sdGlwTW92ZURwO1xyXG4gICAgICAgICAgICBpZiAodG9vbHRpcE1vdmVEcCkge1xyXG4gICAgICAgICAgICAgICAgdG9vbHRpcE1vdmVEcC5kaXNwb3NlKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl90b29sdGlwTW92ZURwID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IHRvb2x0aXBQb2ludGVyRHAgPSB0aGlzLl90b29sdGlwUG9pbnRlckRwO1xyXG4gICAgICAgICAgICBpZiAodG9vbHRpcFBvaW50ZXJEcCkge1xyXG4gICAgICAgICAgICAgICAgdG9vbHRpcFBvaW50ZXJEcC5kaXNwb3NlKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl90b29sdGlwUG9pbnRlckRwID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmdldChcInRvb2x0aXBQb3NpdGlvblwiKSA9PSBcInBvaW50ZXJcIikge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNIb3ZlcigpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdG9vbHRpcE1vdmVEcCA9IHRoaXMuZXZlbnRzLm9uKFwiZ2xvYmFscG9pbnRlcm1vdmVcIiwgKGUpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zaG93VG9vbHRpcChlLnBvaW50KTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuX3Rvb2x0aXBQb2ludGVyRHAgPSBuZXcgTXVsdGlEaXNwb3NlcihbXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ldmVudHMub24oXCJwb2ludGVyb3ZlclwiLCAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3Rvb2x0aXBNb3ZlRHAgPSB0aGlzLmV2ZW50cy5vbihcImdsb2JhbHBvaW50ZXJtb3ZlXCIsIChlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNob3dUb29sdGlwKGUucG9pbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9KSxcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmV2ZW50cy5vbihcInBvaW50ZXJvdXRcIiwgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0b29sdGlwTW92ZURwID0gdGhpcy5fdG9vbHRpcE1vdmVEcDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRvb2x0aXBNb3ZlRHApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvb2x0aXBNb3ZlRHAuZGlzcG9zZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fdG9vbHRpcE1vdmVEcCA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICBdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIF9oYW5kbGVTdGF0ZXMoKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9zdGF0ZXNIYW5kbGVkKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmlzRGlydHkoXCJhY3RpdmVcIikpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmdldChcImFjdGl2ZVwiKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGVzLmFwcGx5QW5pbWF0ZShcImFjdGl2ZVwiKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldChcImFyaWFDaGVja2VkXCIsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLmlzSGlkZGVuKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZXMuYXBwbHlBbmltYXRlKFwiZGVmYXVsdFwiKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXQoXCJhcmlhQ2hlY2tlZFwiLCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLm1hcmtEaXJ0eUFjY2Vzc2liaWxpdHkoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodGhpcy5pc0RpcnR5KFwiZGlzYWJsZWRcIikpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmdldChcImRpc2FibGVkXCIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZXMuYXBwbHlBbmltYXRlKFwiZGlzYWJsZWRcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXQoXCJhcmlhQ2hlY2tlZFwiLCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuaXNIaWRkZW4oKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlcy5hcHBseUFuaW1hdGUoXCJkZWZhdWx0XCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldChcImFyaWFDaGVja2VkXCIsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5tYXJrRGlydHlBY2Nlc3NpYmlsaXR5KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fc3RhdGVzSGFuZGxlZCA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgX2NoYW5nZWQoKSB7XHJcbiAgICAgICAgc3VwZXIuX2NoYW5nZWQoKTtcclxuICAgICAgICBjb25zdCBkaXNwbGF5ID0gdGhpcy5fZGlzcGxheTtcclxuICAgICAgICBjb25zdCBldmVudHMgPSB0aGlzLmV2ZW50cztcclxuICAgICAgICBpZiAodGhpcy5pc0RpcnR5KFwiZHJhZ2dhYmxlXCIpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGRyYWdnYWJsZSA9IHRoaXMuZ2V0KFwiZHJhZ2dhYmxlXCIpO1xyXG4gICAgICAgICAgICBpZiAoZHJhZ2dhYmxlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNldChcImludGVyYWN0aXZlXCIsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZHJhZ0RwID0gbmV3IE11bHRpRGlzcG9zZXIoW1xyXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50cy5vbihcInBvaW50ZXJkb3duXCIsIChldikgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYWdTdGFydChldik7XHJcbiAgICAgICAgICAgICAgICAgICAgfSksXHJcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRzLm9uKFwiZ2xvYmFscG9pbnRlcm1vdmVcIiwgKGV2KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhZ01vdmUoZXYpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pLFxyXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50cy5vbihcImdsb2JhbHBvaW50ZXJ1cFwiLCAoZXYpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmFnU3RvcChldik7XHJcbiAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIF0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2RyYWdEcCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RyYWdEcC5kaXNwb3NlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZHJhZ0RwID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGRpc3BsYXkuY2FuY2VsVG91Y2ggPSBkcmFnZ2FibGUgPyB0cnVlIDogZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmlzRGlydHkoXCJ0b29sdGlwVGV4dFwiKSB8fCB0aGlzLmlzRGlydHkoXCJ0b29sdGlwSFRNTFwiKSB8fCB0aGlzLmlzRGlydHkoXCJzaG93VG9vbHRpcE9uXCIpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHRvb2x0aXBUZXh0ID0gdGhpcy5nZXQoXCJ0b29sdGlwVGV4dFwiKTtcclxuICAgICAgICAgICAgY29uc3QgdG9vbHRpcEhUTUwgPSB0aGlzLmdldChcInRvb2x0aXBIVE1MXCIpO1xyXG4gICAgICAgICAgICBjb25zdCBzaG93VG9vbHRpcE9uID0gdGhpcy5nZXQoXCJzaG93VG9vbHRpcE9uXCIsIFwiaG92ZXJcIik7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl90b29sdGlwRHApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3Rvb2x0aXBEcC5kaXNwb3NlKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl90b29sdGlwRHAgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRvb2x0aXBUZXh0IHx8IHRvb2x0aXBIVE1MKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoc2hvd1Rvb2x0aXBPbiA9PSBcImNsaWNrXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl90b29sdGlwRHAgPSBuZXcgTXVsdGlEaXNwb3NlcihbXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50cy5vbihcImNsaWNrXCIsICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0VGltZW91dCgoKSA9PiB0aGlzLnNob3dUb29sdGlwKCksIDEwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICR1dGlscy5hZGRFdmVudExpc3RlbmVyKGRvY3VtZW50LCBcImNsaWNrXCIsIChfZXYpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaGlkZVRvb2x0aXAoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICBdKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kaXNwb3NlcnMucHVzaCh0aGlzLl90b29sdGlwRHApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc2hvd1Rvb2x0aXBPbiA9PSBcImFsd2F5c1wiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gbm90aGluZ1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdG9vbHRpcERwID0gbmV3IE11bHRpRGlzcG9zZXIoW1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudHMub24oXCJwb2ludGVyb3ZlclwiLCAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNob3dUb29sdGlwKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudHMub24oXCJwb2ludGVyb3V0XCIsICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaGlkZVRvb2x0aXAoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICBdKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kaXNwb3NlcnMucHVzaCh0aGlzLl90b29sdGlwRHApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmlzRGlydHkoXCJ0b2dnbGVLZXlcIikpIHtcclxuICAgICAgICAgICAgbGV0IHRvZ2dsZUtleSA9IHRoaXMuZ2V0KFwidG9nZ2xlS2V5XCIpO1xyXG4gICAgICAgICAgICBpZiAodG9nZ2xlS2V5ICYmIHRvZ2dsZUtleSAhPSBcIm5vbmVcIikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fdG9nZ2xlRHAgPSBldmVudHMub24oXCJjbGlja1wiLCAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9pc0RyYWdnaW5nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0KHRvZ2dsZUtleSwgIXRoaXMuZ2V0KHRvZ2dsZUtleSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3RvZ2dsZURwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdG9nZ2xlRHAuZGlzcG9zZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3RvZ2dsZURwID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmlzRGlydHkoXCJvcGFjaXR5XCIpKSB7XHJcbiAgICAgICAgICAgIGRpc3BsYXkuYWxwaGEgPSBNYXRoLm1heCgwLCB0aGlzLmdldChcIm9wYWNpdHlcIiwgMSkpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5nZXQoXCJmb2N1c2FibGVcIikpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubWFya0RpcnR5QWNjZXNzaWJpbGl0eSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmlzRGlydHkoXCJyb3RhdGlvblwiKSkge1xyXG4gICAgICAgICAgICB0aGlzLm1hcmtEaXJ0eUJvdW5kcygpO1xyXG4gICAgICAgICAgICBkaXNwbGF5LmFuZ2xlID0gdGhpcy5nZXQoXCJyb3RhdGlvblwiLCAwKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuaXNEaXJ0eShcInNjYWxlXCIpKSB7XHJcbiAgICAgICAgICAgIHRoaXMubWFya0RpcnR5Qm91bmRzKCk7XHJcbiAgICAgICAgICAgIGRpc3BsYXkuc2NhbGUgPSB0aGlzLmdldChcInNjYWxlXCIsIDApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5pc0RpcnR5KFwiY2VudGVyWFwiKSB8fCB0aGlzLmlzRGlydHkoXCJjZW50ZXJZXCIpKSB7XHJcbiAgICAgICAgICAgIHRoaXMubWFya0RpcnR5Qm91bmRzKCk7XHJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlUGl2b3RQb2ludCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5pc0RpcnR5KFwidmlzaWJsZVwiKSB8fCB0aGlzLmlzUHJpdmF0ZURpcnR5KFwidmlzaWJsZVwiKSB8fCB0aGlzLmlzRGlydHkoXCJmb3JjZUhpZGRlblwiKSkge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuZ2V0KFwidmlzaWJsZVwiKSB8fCAhdGhpcy5nZXRQcml2YXRlKFwidmlzaWJsZVwiKSB8fCB0aGlzLmdldChcImZvcmNlSGlkZGVuXCIpKSB7XHJcbiAgICAgICAgICAgICAgICBkaXNwbGF5LnZpc2libGUgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIHRoaXMuaGlkZVRvb2x0aXAoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGRpc3BsYXkudmlzaWJsZSA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5tYXJrRGlydHlCb3VuZHMoKTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuZ2V0KFwiZm9jdXNhYmxlXCIpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm1hcmtEaXJ0eUFjY2Vzc2liaWxpdHkoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5pc0RpcnR5KFwid2lkdGhcIikgfHwgdGhpcy5pc0RpcnR5KFwiaGVpZ2h0XCIpKSB7XHJcbiAgICAgICAgICAgIHRoaXMubWFya0RpcnR5Qm91bmRzKCk7XHJcbiAgICAgICAgICAgIHRoaXMuX2FkZFBlcmNlbnRhZ2VTaXplQ2hpbGRyZW4oKTtcclxuICAgICAgICAgICAgY29uc3QgcGFyZW50ID0gdGhpcy5wYXJlbnQ7XHJcbiAgICAgICAgICAgIGlmIChwYXJlbnQpIHtcclxuICAgICAgICAgICAgICAgIGlmICgodGhpcy5pc0RpcnR5KFwid2lkdGhcIikgJiYgdGhpcy5nZXQoXCJ3aWR0aFwiKSBpbnN0YW5jZW9mIFBlcmNlbnQpIHx8ICh0aGlzLmlzRGlydHkoXCJoZWlnaHRcIikgJiYgdGhpcy5nZXQoXCJoZWlnaHRcIikgaW5zdGFuY2VvZiBQZXJjZW50KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudC5tYXJrRGlydHkoKTtcclxuICAgICAgICAgICAgICAgICAgICBwYXJlbnQuX3ByZXZXaWR0aCA9IDA7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fc2l6ZURpcnR5ID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuaXNEaXJ0eShcIm1heFdpZHRoXCIpIHx8IHRoaXMuaXNEaXJ0eShcIm1heEhlaWdodFwiKSB8fCB0aGlzLmlzUHJpdmF0ZURpcnR5KFwid2lkdGhcIikgfHwgdGhpcy5pc1ByaXZhdGVEaXJ0eShcImhlaWdodFwiKSB8fCB0aGlzLmlzRGlydHkoXCJtaW5XaWR0aFwiKSB8fCB0aGlzLmlzRGlydHkoXCJtaW5IZWlnaHRcIikgfHwgdGhpcy5pc1ByaXZhdGVEaXJ0eShcIm1heFdpZHRoXCIpIHx8IHRoaXMuaXNQcml2YXRlRGlydHkoXCJtYXhIZWlnaHRcIikgfHwgdGhpcy5pc1ByaXZhdGVEaXJ0eShcIm1pbldpZHRoXCIpIHx8IHRoaXMuaXNQcml2YXRlRGlydHkoXCJtaW5IZWlnaHRcIikpIHtcclxuICAgICAgICAgICAgdGhpcy5tYXJrRGlydHlCb3VuZHMoKTtcclxuICAgICAgICAgICAgdGhpcy5fc2l6ZURpcnR5ID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuX3NpemVEaXJ0eSkge1xyXG4gICAgICAgICAgICB0aGlzLl91cGRhdGVTaXplKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmlzRGlydHkoXCJ3aGVlbGFibGVcIikpIHtcclxuICAgICAgICAgICAgY29uc3Qgd2hlZWxhYmxlID0gdGhpcy5nZXQoXCJ3aGVlbGFibGVcIik7XHJcbiAgICAgICAgICAgIGlmICh3aGVlbGFibGUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2V0KFwiaW50ZXJhY3RpdmVcIiwgdHJ1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZGlzcGxheS53aGVlbGFibGUgPSB3aGVlbGFibGUgPyB0cnVlIDogZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIEFjY2Vzc2liaWxpdHlcclxuICAgICAgICBpZiAodGhpcy5pc0RpcnR5KFwidGFiaW5kZXhPcmRlclwiKSB8fCB0aGlzLmlzRGlydHkoXCJmb2N1c2FibGVHcm91cFwiKSkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5nZXQoXCJmb2N1c2FibGVcIikpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3Jvb3QuX3JlZ2lzdGVyVGFiaW5kZXhPcmRlcih0aGlzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3Jvb3QuX3VucmVnaXN0ZXJUYWJpbmRleE9yZGVyKHRoaXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmlzRGlydHkoXCJmaWx0ZXJcIikpIHtcclxuICAgICAgICAgICAgLy90aGlzLm1hcmtEaXJ0eUJvdW5kcygpO1xyXG4gICAgICAgICAgICBkaXNwbGF5LmZpbHRlciA9IHRoaXMuZ2V0KFwiZmlsdGVyXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgZmlsdGVyID0gdGhpcy5nZXQoXCJmaWx0ZXJcIiwgXCJcIik7XHJcbiAgICAgICAgaWYgKHRoaXMuaXNEaXJ0eShcImJsdXJcIikpIHtcclxuICAgICAgICAgICAgY29uc3QgYmx1ciA9IHRoaXMuZ2V0KFwiYmx1clwiLCAwKTtcclxuICAgICAgICAgICAgaWYgKGJsdXIgIT0gMCkge1xyXG4gICAgICAgICAgICAgICAgZmlsdGVyICs9IFwiIGJsdXIoXCIgKyBibHVyICsgXCJweClcIjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5pc0RpcnR5KFwic2F0dXJhdGVcIikpIHtcclxuICAgICAgICAgICAgY29uc3Qgc2F0dXJhdGUgPSB0aGlzLmdldChcInNhdHVyYXRlXCIsIDEpO1xyXG4gICAgICAgICAgICBpZiAoc2F0dXJhdGUgIT0gMSkge1xyXG4gICAgICAgICAgICAgICAgZmlsdGVyICs9IFwiIHNhdHVyYXRlKFwiICsgc2F0dXJhdGUgKyBcIilcIjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5pc0RpcnR5KFwiYnJpZ2h0bmVzc1wiKSkge1xyXG4gICAgICAgICAgICBjb25zdCBicmlnaHRuZXNzID0gdGhpcy5nZXQoXCJicmlnaHRuZXNzXCIsIDEpO1xyXG4gICAgICAgICAgICBpZiAoYnJpZ2h0bmVzcyAhPSAxKSB7XHJcbiAgICAgICAgICAgICAgICBmaWx0ZXIgKz0gXCIgYnJpZ2h0bmVzcyhcIiArIGJyaWdodG5lc3MgKyBcIilcIjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5pc0RpcnR5KFwiY29udHJhc3RcIikpIHtcclxuICAgICAgICAgICAgY29uc3QgY29udHJhc3QgPSB0aGlzLmdldChcImNvbnRyYXN0XCIsIDEpO1xyXG4gICAgICAgICAgICBpZiAoY29udHJhc3QgIT0gMSkge1xyXG4gICAgICAgICAgICAgICAgZmlsdGVyICs9IFwiIGNvbnRyYXN0KFwiICsgY29udHJhc3QgKyBcIilcIjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5pc0RpcnR5KFwic2VwaWFcIikpIHtcclxuICAgICAgICAgICAgY29uc3Qgc2VwaWEgPSB0aGlzLmdldChcInNlcGlhXCIsIDApO1xyXG4gICAgICAgICAgICBpZiAoc2VwaWEgIT0gMCkge1xyXG4gICAgICAgICAgICAgICAgZmlsdGVyICs9IFwiIHNlcGlhKFwiICsgc2VwaWEgKyBcIilcIjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5pc0RpcnR5KFwiaHVlXCIpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGh1ZSA9IHRoaXMuZ2V0KFwiaHVlXCIsIDApO1xyXG4gICAgICAgICAgICBpZiAoaHVlICE9IDApIHtcclxuICAgICAgICAgICAgICAgIGZpbHRlciArPSBcIiBodWUtcm90YXRlKFwiICsgaHVlICsgXCJkZWcpXCI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuaXNEaXJ0eShcImludmVydFwiKSkge1xyXG4gICAgICAgICAgICBjb25zdCBpbnZlcnQgPSB0aGlzLmdldChcImludmVydFwiLCAwKTtcclxuICAgICAgICAgICAgaWYgKGludmVydCAhPSAwKSB7XHJcbiAgICAgICAgICAgICAgICBmaWx0ZXIgKz0gXCIgaW52ZXJ0KFwiICsgaW52ZXJ0ICsgXCIpXCI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGZpbHRlcikge1xyXG4gICAgICAgICAgICBkaXNwbGF5LmZpbHRlciA9IGZpbHRlcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuaXNEaXJ0eShcImN1cnNvck92ZXJTdHlsZVwiKSkge1xyXG4gICAgICAgICAgICBkaXNwbGF5LmN1cnNvck92ZXJTdHlsZSA9IHRoaXMuZ2V0KFwiY3Vyc29yT3ZlclN0eWxlXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5pc0RpcnR5KFwiaG92ZXJPbkZvY3VzXCIpKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmdldChcImhvdmVyT25Gb2N1c1wiKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZm9jdXNEcCA9IG5ldyBNdWx0aURpc3Bvc2VyKFtcclxuICAgICAgICAgICAgICAgICAgICBldmVudHMub24oXCJmb2N1c1wiLCAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IHByb3BlciBob3Zlciwgbm90IGp1c3QgdG9vbHRpcFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNob3dUb29sdGlwKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSksXHJcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRzLm9uKFwiYmx1clwiLCAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IHByb3BlciBob3Zlciwgbm90IGp1c3QgdG9vbHRpcFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmhpZGVUb29sdGlwKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIF0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2ZvY3VzRHApIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9mb2N1c0RwLmRpc3Bvc2UoKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9mb2N1c0RwID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmlzRGlydHkoXCJmb2N1c2FibGVcIikpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuZ2V0KFwiZm9jdXNhYmxlXCIpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9yb290Ll9yZWdpc3RlclRhYmluZGV4T3JkZXIodGhpcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9yb290Ll91bnJlZ2lzdGVyVGFiaW5kZXhPcmRlcih0aGlzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLm1hcmtEaXJ0eUFjY2Vzc2liaWxpdHkoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuaXNQcml2YXRlRGlydHkoXCJmb2N1c2FibGVcIikpIHtcclxuICAgICAgICAgICAgdGhpcy5tYXJrRGlydHlBY2Nlc3NpYmlsaXR5KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmlzRGlydHkoXCJyb2xlXCIpIHx8IHRoaXMuaXNEaXJ0eShcImFyaWFMaXZlXCIpIHx8IHRoaXMuaXNEaXJ0eShcImFyaWFDaGVja2VkXCIpIHx8IHRoaXMuaXNEaXJ0eShcImFyaWFIaWRkZW5cIikgfHwgdGhpcy5pc0RpcnR5KFwiYXJpYU9yaWVudGF0aW9uXCIpIHx8IHRoaXMuaXNEaXJ0eShcImFyaWFWYWx1ZU5vd1wiKSB8fCB0aGlzLmlzRGlydHkoXCJhcmlhVmFsdWVNaW5cIikgfHwgdGhpcy5pc0RpcnR5KFwiYXJpYVZhbHVlTWF4XCIpIHx8IHRoaXMuaXNEaXJ0eShcImFyaWFWYWx1ZVRleHRcIikgfHwgdGhpcy5pc0RpcnR5KFwiYXJpYUxhYmVsXCIpIHx8IHRoaXMuaXNEaXJ0eShcImFyaWFDb250cm9sc1wiKSkge1xyXG4gICAgICAgICAgICAvLyBkaXNwbGF5LmFjY2Vzc2liaWxpdHkuYXJpYUxhYmVsID0gcG9wdWxhdGVTdHJpbmcodGhpcywgdGhpcy5nZXQoXCJhcmlhTGFiZWxcIiwgXCJcIikpO1xyXG4gICAgICAgICAgICAvLyBAdG9kbyBtYWtlIHN1cmUgYXJpYUxhYmVsIGdldHMgcG9wdWxhdGVkIGluIFJvb3RcclxuICAgICAgICAgICAgdGhpcy5tYXJrRGlydHlBY2Nlc3NpYmlsaXR5KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmlzRGlydHkoXCJleHBvcnRhYmxlXCIpKSB7XHJcbiAgICAgICAgICAgIGRpc3BsYXkuZXhwb3J0YWJsZSA9IHRoaXMuZ2V0KFwiZXhwb3J0YWJsZVwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuaXNEaXJ0eShcImludGVyYWN0aXZlXCIpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGV2ZW50cyA9IHRoaXMuZXZlbnRzO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5nZXQoXCJpbnRlcmFjdGl2ZVwiKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5faG92ZXJEcCA9IG5ldyBNdWx0aURpc3Bvc2VyKFtcclxuICAgICAgICAgICAgICAgICAgICBldmVudHMub24oXCJjbGlja1wiLCAoZXYpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCR1dGlscy5pc1RvdWNoRXZlbnQoZXYub3JpZ2luYWxFdmVudCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5nZXRQcml2YXRlKFwidG91Y2hIb3ZlcmluZ1wiKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2hhbmRsZU92ZXIoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZ2V0KFwidG9vbHRpcFRleHRcIikgfHwgdGhpcy5nZXQoXCJ0b29sdGlwSFRNTFwiKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zaG93VG9vbHRpcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0UHJpdmF0ZVJhdyhcInRvdWNoSG92ZXJpbmdcIiwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZXZlbnRzLmRpc3BhdGNoKFwicG9pbnRlcm92ZXJcIiwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJwb2ludGVyb3ZlclwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0OiBldi50YXJnZXQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbEV2ZW50OiBldi5vcmlnaW5hbEV2ZW50LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnQ6IGV2LnBvaW50LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2ltdWxhdGVkOiBldi5zaW11bGF0ZWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgMTApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSksXHJcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRzLm9uKFwiZ2xvYmFscG9pbnRlcnVwXCIsIChldikgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoJHV0aWxzLmlzVG91Y2hFdmVudChldi5vcmlnaW5hbEV2ZW50KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZ2V0UHJpdmF0ZShcInRvdWNoSG92ZXJpbmdcIikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9oYW5kbGVPdXQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5nZXQoXCJ0b29sdGlwVGV4dFwiKSB8fCB0aGlzLmdldChcInRvb2x0aXBIVE1MXCIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaGlkZVRvb2x0aXAoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRQcml2YXRlUmF3KFwidG91Y2hIb3ZlcmluZ1wiLCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5ldmVudHMuZGlzcGF0Y2goXCJwb2ludGVyb3V0XCIsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJwb2ludGVyb3V0XCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldDogZXYudGFyZ2V0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbEV2ZW50OiBldi5vcmlnaW5hbEV2ZW50LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb2ludDogZXYucG9pbnQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpbXVsYXRlZDogZXYuc2ltdWxhdGVkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2lzRG93bikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5faGFuZGxlVXAoZXYpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vdGhpcy5faXNEb3duID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgfSksXHJcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRzLm9uKFwicG9pbnRlcm92ZXJcIiwgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9oYW5kbGVPdmVyKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSksXHJcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRzLm9uKFwicG9pbnRlcm91dFwiLCAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2hhbmRsZU91dCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pLFxyXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50cy5vbihcInBvaW50ZXJkb3duXCIsIChlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2hhbmRsZURvd24oZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIF0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZGlzcGxheS5pbnRlcmFjdGl2ZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2hvdmVyRHApIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9ob3ZlckRwLmRpc3Bvc2UoKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9ob3ZlckRwID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmlzRGlydHkoXCJmb3JjZUluYWN0aXZlXCIpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2Rpc3BsYXkuaW5hY3RpdmUgPSB0aGlzLmdldChcImZvcmNlSW5hY3RpdmVcIiwgbnVsbCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmdldChcInNob3dUb29sdGlwT25cIikgPT0gXCJhbHdheXNcIiAmJiB0aGlzLl9kaXNwbGF5LnZpc2libGUpIHtcclxuICAgICAgICAgICAgdGhpcy5zaG93VG9vbHRpcCgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQGlnbm9yZVxyXG4gICAgICogQHRvZG8gc2hvdWxkIHRoaXMgYmUgdXNlci1hY2Nlc3NpYmxlP1xyXG4gICAgICovXHJcbiAgICBkcmFnU3RhcnQoZSkge1xyXG4gICAgICAgIHRoaXMuX2RyYWdFdmVudCA9IGU7XHJcbiAgICAgICAgdGhpcy5ldmVudHMuc3RvcFBhcmVudERpc3BhdGNoKCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEBpZ25vcmVcclxuICAgICAqIEB0b2RvIHNob3VsZCB0aGlzIGJlIHVzZXItYWNjZXNzaWJsZT9cclxuICAgICAqL1xyXG4gICAgZHJhZ1N0b3AoZSkge1xyXG4gICAgICAgIHRoaXMuX2RyYWdFdmVudCA9IHVuZGVmaW5lZDtcclxuICAgICAgICB0aGlzLl9kcmFnUG9pbnQgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgdGhpcy5ldmVudHMuc3RvcFBhcmVudERpc3BhdGNoKCk7XHJcbiAgICAgICAgaWYgKHRoaXMuX2lzRHJhZ2dpbmcpIHtcclxuICAgICAgICAgICAgdGhpcy5faXNEcmFnZ2luZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICBjb25zdCB0eXBlID0gXCJkcmFnc3RvcFwiO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5ldmVudHMuaXNFbmFibGVkKHR5cGUpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50cy5kaXNwYXRjaCh0eXBlLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogdHlwZSxcclxuICAgICAgICAgICAgICAgICAgICB0YXJnZXQ6IHRoaXMsXHJcbiAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxFdmVudDogZS5vcmlnaW5hbEV2ZW50LFxyXG4gICAgICAgICAgICAgICAgICAgIHBvaW50OiBlLnBvaW50LFxyXG4gICAgICAgICAgICAgICAgICAgIHNpbXVsYXRlZDogZS5zaW11bGF0ZWQsXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIF9oYW5kbGVPdmVyKCkge1xyXG4gICAgICAgIGlmICghdGhpcy5pc0hpZGRlbigpKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmdldChcImFjdGl2ZVwiKSAmJiB0aGlzLnN0YXRlcy5sb29rdXAoXCJob3ZlckFjdGl2ZVwiKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZXMuYXBwbHlBbmltYXRlKFwiaG92ZXJBY3RpdmVcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5nZXQoXCJkaXNhYmxlZFwiKSAmJiB0aGlzLnN0YXRlcy5sb29rdXAoXCJob3ZlckRpc2FibGVkXCIpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlcy5hcHBseUFuaW1hdGUoXCJob3ZlckRpc2FibGVkXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZXMuYXBwbHlBbmltYXRlKFwiaG92ZXJcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRoaXMuZ2V0KFwiZHJhZ2dhYmxlXCIpICYmIHRoaXMuX2lzRG93biAmJiB0aGlzLnN0YXRlcy5sb29rdXAoXCJkb3duXCIpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlcy5hcHBseUFuaW1hdGUoXCJkb3duXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgX2hhbmRsZU91dCgpIHtcclxuICAgICAgICBpZiAoIXRoaXMuaXNIaWRkZW4oKSkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5nZXQoXCJhY3RpdmVcIikgJiYgdGhpcy5zdGF0ZXMubG9va3VwKFwiYWN0aXZlXCIpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlcy5hcHBseUFuaW1hdGUoXCJhY3RpdmVcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5nZXQoXCJkaXNhYmxlZFwiKSAmJiB0aGlzLnN0YXRlcy5sb29rdXAoXCJkaXNhYmxlZFwiKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZXMuYXBwbHlBbmltYXRlKFwiZGlzYWJsZWRcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zdGF0ZXMubG9va3VwKFwiaG92ZXJcIikgfHwgdGhpcy5zdGF0ZXMubG9va3VwKFwiaG92ZXJBY3RpdmVcIikpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlcy5hcHBseUFuaW1hdGUoXCJkZWZhdWx0XCIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmdldChcImRyYWdnYWJsZVwiKSAmJiB0aGlzLl9pc0Rvd24gJiYgdGhpcy5zdGF0ZXMubG9va3VwKFwiZG93blwiKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZXMuYXBwbHlBbmltYXRlKFwiZG93blwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIF9oYW5kbGVVcChlKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmlzSGlkZGVuKCkpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuZ2V0KFwiYWN0aXZlXCIpICYmIHRoaXMuc3RhdGVzLmxvb2t1cChcImFjdGl2ZVwiKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZXMuYXBwbHlBbmltYXRlKFwiYWN0aXZlXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuZ2V0KFwiZGlzYWJsZWRcIikgJiYgdGhpcy5zdGF0ZXMubG9va3VwKFwiZGlzYWJsZWRcIikpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGVzLmFwcGx5QW5pbWF0ZShcImRpc2FibGVkXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuc3RhdGVzLmxvb2t1cChcImRvd25cIikpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzSG92ZXIoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGVzLmFwcGx5QW5pbWF0ZShcImhvdmVyXCIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZXMuYXBwbHlBbmltYXRlKFwiZGVmYXVsdFwiKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBAdG9kbyByZW1vdmUgdGhpcyBvbmNlIG1pZ3JhdGVkIHRvIF9kb3duUG9pbnRzXHJcbiAgICAgICAgICAgIHRoaXMuX2Rvd25Qb2ludCA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgY29uc3QgcG9pbnRlcklkID0gJHV0aWxzLmdldFBvaW50ZXJJZChlLm9yaWdpbmFsRXZlbnQpO1xyXG4gICAgICAgICAgICBkZWxldGUgdGhpcy5fZG93blBvaW50c1twb2ludGVySWRdO1xyXG4gICAgICAgICAgICBpZiAoJG9iamVjdC5rZXlzKHRoaXMuX2Rvd25Qb2ludHMpLmxlbmd0aCA9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9pc0Rvd24gPSBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIF9oYXNNb3ZlZChlKSB7XHJcbiAgICAgICAgLy8gQHRvZG8gcmVtb3ZlIHRoaXMgb25jZSBtaWdyYXRlZCB0byBfZG93blBvaW50c1xyXG4gICAgICAgIC8vIGlmICh0aGlzLl9kb3duUG9pbnQpIHtcclxuICAgICAgICAvLyBcdGNvbnN0IHggPSBNYXRoLmFicyh0aGlzLl9kb3duUG9pbnQueCAtIGUucG9pbnQueCk7XHJcbiAgICAgICAgLy8gXHRjb25zdCB5ID0gTWF0aC5hYnModGhpcy5fZG93blBvaW50LnkgLSBlLnBvaW50LnkpO1xyXG4gICAgICAgIC8vIFx0cmV0dXJuICh4ID4gNSkgfHwgKHkgPiA1KTtcclxuICAgICAgICAvLyB9XHJcbiAgICAgICAgY29uc3QgcG9pbnRlcklkID0gJHV0aWxzLmdldFBvaW50ZXJJZChlLm9yaWdpbmFsRXZlbnQpO1xyXG4gICAgICAgIGNvbnN0IGRvd25Qb2ludCA9IHRoaXMuX2Rvd25Qb2ludHNbcG9pbnRlcklkXTtcclxuICAgICAgICBpZiAoZG93blBvaW50KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHggPSBNYXRoLmFicyhkb3duUG9pbnQueCAtIGUucG9pbnQueCk7XHJcbiAgICAgICAgICAgIGNvbnN0IHkgPSBNYXRoLmFicyhkb3duUG9pbnQueSAtIGUucG9pbnQueSk7XHJcbiAgICAgICAgICAgIHJldHVybiAoeCA+IDUpIHx8ICh5ID4gNSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIF9oYXNEb3duKCkge1xyXG4gICAgICAgIHJldHVybiAkb2JqZWN0LmtleXModGhpcy5fZG93blBvaW50cykubGVuZ3RoID4gMDtcclxuICAgIH1cclxuICAgIF9oYW5kbGVEb3duKGUpIHtcclxuICAgICAgICBjb25zdCBwYXJlbnQgPSB0aGlzLnBhcmVudDtcclxuICAgICAgICBpZiAocGFyZW50ICYmICF0aGlzLmdldChcImRyYWdnYWJsZVwiKSkge1xyXG4gICAgICAgICAgICBwYXJlbnQuX2hhbmRsZURvd24oZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmdldChcImludGVyYWN0aXZlXCIpICYmICF0aGlzLmlzSGlkZGVuKCkpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGVzLmxvb2t1cChcImRvd25cIikpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGVzLmFwcGx5QW5pbWF0ZShcImRvd25cIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fZG93blBvaW50ID0ge1xyXG4gICAgICAgICAgICAgICAgeDogZS5wb2ludC54LFxyXG4gICAgICAgICAgICAgICAgeTogZS5wb2ludC55XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8vIEB0b2RvIHJlbW92ZSB0aGlzIG9uY2UgbWlncmF0ZWQgdG8gX2Rvd25Qb2ludHNcclxuICAgICAgICAgICAgdGhpcy5faXNEb3duID0gdHJ1ZTtcclxuICAgICAgICAgICAgY29uc3QgcG9pbnRlcklkID0gJHV0aWxzLmdldFBvaW50ZXJJZChlLm9yaWdpbmFsRXZlbnQpO1xyXG4gICAgICAgICAgICB0aGlzLl9kb3duUG9pbnRzW3BvaW50ZXJJZF0gPSB7XHJcbiAgICAgICAgICAgICAgICB4OiBlLnBvaW50LngsXHJcbiAgICAgICAgICAgICAgICB5OiBlLnBvaW50LnlcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEBpZ25vcmVcclxuICAgICAqIEB0b2RvIHNob3VsZCB0aGlzIGJlIHVzZXItYWNjZXNzaWJsZT9cclxuICAgICAqL1xyXG4gICAgZHJhZ01vdmUoZSkge1xyXG4gICAgICAgIGxldCBkcmFnRXZlbnQgPSB0aGlzLl9kcmFnRXZlbnQ7XHJcbiAgICAgICAgaWYgKGRyYWdFdmVudCkge1xyXG4gICAgICAgICAgICBpZiAoZHJhZ0V2ZW50LnNpbXVsYXRlZCAmJiAhZS5zaW11bGF0ZWQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGxldCBhbmdsZSA9IDA7XHJcbiAgICAgICAgICAgIGxldCBwYXJlbnQgPSB0aGlzLnBhcmVudDtcclxuICAgICAgICAgICAgd2hpbGUgKHBhcmVudCAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBhbmdsZSArPSBwYXJlbnQuZ2V0KFwicm90YXRpb25cIiwgMCk7XHJcbiAgICAgICAgICAgICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGxldCB4ID0gZS5wb2ludC54IC0gZHJhZ0V2ZW50LnBvaW50Lng7XHJcbiAgICAgICAgICAgIGxldCB5ID0gZS5wb2ludC55IC0gZHJhZ0V2ZW50LnBvaW50Lnk7XHJcbiAgICAgICAgICAgIGNvbnN0IGV2ZW50cyA9IHRoaXMuZXZlbnRzO1xyXG4gICAgICAgICAgICBpZiAoZHJhZ0V2ZW50LnNpbXVsYXRlZCAmJiAhdGhpcy5faXNEcmFnZ2luZykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5faXNEcmFnZ2luZyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9kcmFnRXZlbnQgPSBlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZHJhZ1BvaW50ID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIHg6IHRoaXMueCgpLFxyXG4gICAgICAgICAgICAgICAgICAgIHk6IHRoaXMueSgpXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdHlwZSA9IFwiZHJhZ3N0YXJ0XCI7XHJcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnRzLmlzRW5hYmxlZCh0eXBlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50cy5kaXNwYXRjaCh0eXBlLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IHR5cGUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldDogdGhpcyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxFdmVudDogZS5vcmlnaW5hbEV2ZW50LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludDogZS5wb2ludCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2ltdWxhdGVkOiBlLnNpbXVsYXRlZCxcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodGhpcy5faXNEcmFnZ2luZykge1xyXG4gICAgICAgICAgICAgICAgbGV0IGRyYWdQb2ludCA9IHRoaXMuX2RyYWdQb2ludDtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2V0KFwieFwiLCBkcmFnUG9pbnQueCArIHggKiAkbWF0aC5jb3MoYW5nbGUpICsgeSAqICRtYXRoLnNpbihhbmdsZSkpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZXQoXCJ5XCIsIGRyYWdQb2ludC55ICsgeSAqICRtYXRoLmNvcyhhbmdsZSkgLSB4ICogJG1hdGguc2luKGFuZ2xlKSk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB0eXBlID0gXCJkcmFnZ2VkXCI7XHJcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnRzLmlzRW5hYmxlZCh0eXBlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50cy5kaXNwYXRjaCh0eXBlLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IHR5cGUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldDogdGhpcyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxFdmVudDogZS5vcmlnaW5hbEV2ZW50LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludDogZS5wb2ludCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2ltdWxhdGVkOiBlLnNpbXVsYXRlZCxcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlmIChNYXRoLmh5cG90KHgsIHkpID4gNSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2lzRHJhZ2dpbmcgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RyYWdFdmVudCA9IGU7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZHJhZ1BvaW50ID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB4OiB0aGlzLngoKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgeTogdGhpcy55KClcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHR5cGUgPSBcImRyYWdzdGFydFwiO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChldmVudHMuaXNFbmFibGVkKHR5cGUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50cy5kaXNwYXRjaCh0eXBlLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiB0eXBlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0OiB0aGlzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxFdmVudDogZS5vcmlnaW5hbEV2ZW50LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnQ6IGUucG9pbnQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaW11bGF0ZWQ6IGUuc2ltdWxhdGVkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIF91cGRhdGVTaXplKCkge1xyXG4gICAgfVxyXG4gICAgX2dldEJvdW5kcygpIHtcclxuICAgICAgICB0aGlzLl9sb2NhbEJvdW5kcyA9IHRoaXMuX2Rpc3BsYXkuZ2V0TG9jYWxCb3VuZHMoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBkZXB0aCAoaG93IGRlZXAgaW4gdGhlIGhpZXJhY2h5IG9mIHRoZSBjb250ZW50IHRyZWUpIG9mIHRoaXNcclxuICAgICAqIGVsZW1lbnQuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybiBEZXB0aFxyXG4gICAgICovXHJcbiAgICBkZXB0aCgpIHtcclxuICAgICAgICBsZXQgc2VsZiA9IHRoaXMucGFyZW50O1xyXG4gICAgICAgIGxldCBkZXB0aCA9IDA7XHJcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcclxuICAgICAgICAgICAgaWYgKHNlbGYpIHtcclxuICAgICAgICAgICAgICAgICsrZGVwdGg7XHJcbiAgICAgICAgICAgICAgICBzZWxmID0gc2VsZi5wYXJlbnQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVwdGg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEBpZ25vcmVcclxuICAgICAqL1xyXG4gICAgbWFya0RpcnR5U2l6ZSgpIHtcclxuICAgICAgICB0aGlzLl9zaXplRGlydHkgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMubWFya0RpcnR5KCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEBpZ25vcmVcclxuICAgICAqL1xyXG4gICAgbWFya0RpcnR5Qm91bmRzKCkge1xyXG4gICAgICAgIGNvbnN0IGRpc3BsYXkgPSB0aGlzLl9kaXNwbGF5O1xyXG4gICAgICAgIGlmICh0aGlzLmdldChcImlzTWVhc3VyZWRcIikpIHtcclxuICAgICAgICAgICAgdGhpcy5fcm9vdC5fYWRkRGlydHlCb3VuZHModGhpcyk7XHJcbiAgICAgICAgICAgIGRpc3BsYXkuaXNNZWFzdXJlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIGRpc3BsYXkuaW52YWxpZGF0ZUJvdW5kcygpO1xyXG4gICAgICAgICAgICBjb25zdCBwYXJlbnQgPSB0aGlzLnBhcmVudDtcclxuICAgICAgICAgICAgaWYgKHBhcmVudCAmJiB0aGlzLmdldChcInBvc2l0aW9uXCIpICE9IFwiYWJzb2x1dGVcIikge1xyXG4gICAgICAgICAgICAgICAgaWYgKHBhcmVudC5nZXQoXCJ3aWR0aFwiKSA9PSBudWxsIHx8IHBhcmVudC5nZXQoXCJoZWlnaHRcIikgPT0gbnVsbCB8fCBwYXJlbnQuZ2V0KFwibGF5b3V0XCIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50Lm1hcmtEaXJ0eUJvdW5kcygpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmdldChcImZvY3VzYWJsZVwiKSAmJiB0aGlzLmlzRm9jdXMoKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5tYXJrRGlydHlBY2Nlc3NpYmlsaXR5KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEBpZ25vcmVcclxuICAgICAqL1xyXG4gICAgbWFya0RpcnR5QWNjZXNzaWJpbGl0eSgpIHtcclxuICAgICAgICAvL2lmICh0aGlzLl9yb290LmZvY3VzZWQodGhpcykpIHtcclxuICAgICAgICB0aGlzLl9yb290Ll9pbnZhbGlkYXRlQWNjZXNzaWJpbGl0eSh0aGlzKTtcclxuICAgICAgICAvL31cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQGlnbm9yZVxyXG4gICAgICovXHJcbiAgICBtYXJrRGlydHlMYXllcigpIHtcclxuICAgICAgICAvL3RoaXMuX2Rpc3BsYXkubWFya0RpcnR5TGF5ZXIodGhpcy5pc0RpcnR5KFwib3BhY2l0eVwiKSB8fCB0aGlzLmlzRGlydHkoXCJ2aXNpYmxlXCIpKTsgaHR0cHM6Ly9jb2RlcGVuLmlvL3RlYW0vYW1jaGFydHMvcGVuL2dPV1pQbVAgPC0gcHJvYmxlbXNcclxuICAgICAgICB0aGlzLl9kaXNwbGF5Lm1hcmtEaXJ0eUxheWVyKHRydWUpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAaWdub3JlXHJcbiAgICAgKi9cclxuICAgIG1hcmtEaXJ0eSgpIHtcclxuICAgICAgICBzdXBlci5tYXJrRGlydHkoKTtcclxuICAgICAgICB0aGlzLm1hcmtEaXJ0eUxheWVyKCk7XHJcbiAgICB9XHJcbiAgICBfdXBkYXRlQm91bmRzKCkge1xyXG4gICAgICAgIGNvbnN0IG9sZEJvdW5kcyA9IHRoaXMuX2FkanVzdGVkTG9jYWxCb3VuZHM7XHJcbiAgICAgICAgbGV0IG5ld0JvdW5kcztcclxuICAgICAgICAvLyBpZiBkaXNwbGF5LnZpc2libGUgPT0gZmFsc2UsIGl0IHN0aWxsIHJldHVybnMgYm91bmRzXHJcbiAgICAgICAgaWYgKCF0aGlzLmdldChcInZpc2libGVcIikgfHwgIXRoaXMuZ2V0UHJpdmF0ZShcInZpc2libGVcIikgfHwgdGhpcy5nZXQoXCJmb3JjZUhpZGRlblwiKSkge1xyXG4gICAgICAgICAgICBuZXdCb3VuZHMgPSB7XHJcbiAgICAgICAgICAgICAgICBsZWZ0OiAwLFxyXG4gICAgICAgICAgICAgICAgcmlnaHQ6IDAsXHJcbiAgICAgICAgICAgICAgICB0b3A6IDAsXHJcbiAgICAgICAgICAgICAgICBib3R0b206IDBcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgdGhpcy5fbG9jYWxCb3VuZHMgPSBuZXdCb3VuZHM7XHJcbiAgICAgICAgICAgIHRoaXMuX2FkanVzdGVkTG9jYWxCb3VuZHMgPSBuZXdCb3VuZHM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLl9nZXRCb3VuZHMoKTtcclxuICAgICAgICAgICAgdGhpcy5fZml4TWluQm91bmRzKHRoaXMuX2xvY2FsQm91bmRzKTtcclxuICAgICAgICAgICAgdGhpcy51cGRhdGVQaXZvdFBvaW50KCk7XHJcbiAgICAgICAgICAgIHRoaXMuX2FkanVzdGVkTG9jYWxCb3VuZHMgPSB0aGlzLl9kaXNwbGF5LmdldEFkanVzdGVkQm91bmRzKHRoaXMuX2xvY2FsQm91bmRzKTtcclxuICAgICAgICAgICAgbmV3Qm91bmRzID0gdGhpcy5fYWRqdXN0ZWRMb2NhbEJvdW5kcztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFvbGRCb3VuZHMgfHwgKG9sZEJvdW5kcy5sZWZ0ICE9PSBuZXdCb3VuZHMubGVmdCB8fCBvbGRCb3VuZHMudG9wICE9PSBuZXdCb3VuZHMudG9wIHx8IG9sZEJvdW5kcy5yaWdodCAhPT0gbmV3Qm91bmRzLnJpZ2h0IHx8IG9sZEJvdW5kcy5ib3R0b20gIT09IG5ld0JvdW5kcy5ib3R0b20pKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGV2ZW50VHlwZSA9IFwiYm91bmRzY2hhbmdlZFwiO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5ldmVudHMuaXNFbmFibGVkKGV2ZW50VHlwZSkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZXZlbnRzLmRpc3BhdGNoKGV2ZW50VHlwZSwgeyB0eXBlOiBldmVudFR5cGUsIHRhcmdldDogdGhpcyB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodGhpcy5wYXJlbnQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucGFyZW50Lm1hcmtEaXJ0eSgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wYXJlbnQubWFya0RpcnR5Qm91bmRzKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBfZml4TWluQm91bmRzKGJvdW5kcykge1xyXG4gICAgICAgIGxldCBtaW5XaWR0aCA9IHRoaXMuZ2V0KFwibWluV2lkdGhcIiwgdGhpcy5nZXRQcml2YXRlKFwibWluV2lkdGhcIikpO1xyXG4gICAgICAgIGxldCBtaW5IZWlnaHQgPSB0aGlzLmdldChcIm1pbkhlaWdodFwiLCB0aGlzLmdldFByaXZhdGUoXCJtaW5IZWlnaHRcIikpO1xyXG4gICAgICAgIGlmICgkdHlwZS5pc051bWJlcihtaW5XaWR0aCkpIHtcclxuICAgICAgICAgICAgaWYgKGJvdW5kcy5yaWdodCAtIGJvdW5kcy5sZWZ0IDwgbWluV2lkdGgpIHtcclxuICAgICAgICAgICAgICAgIGJvdW5kcy5yaWdodCA9IGJvdW5kcy5sZWZ0ICsgbWluV2lkdGg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCR0eXBlLmlzTnVtYmVyKG1pbkhlaWdodCkpIHtcclxuICAgICAgICAgICAgaWYgKGJvdW5kcy5ib3R0b20gLSBib3VuZHMudG9wIDwgbWluSGVpZ2h0KSB7XHJcbiAgICAgICAgICAgICAgICBib3VuZHMuYm90dG9tID0gYm91bmRzLnRvcCArIG1pbkhlaWdodDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgcHJpdmF0ZVdpZHRoID0gdGhpcy5nZXRQcml2YXRlKFwid2lkdGhcIik7XHJcbiAgICAgICAgbGV0IHByaXZhdGVIZWlnaHQgPSB0aGlzLmdldFByaXZhdGUoXCJoZWlnaHRcIik7XHJcbiAgICAgICAgaWYgKCR0eXBlLmlzTnVtYmVyKHByaXZhdGVXaWR0aCkpIHtcclxuICAgICAgICAgICAgaWYgKHByaXZhdGVXaWR0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgIGJvdW5kcy5yaWdodCA9IGJvdW5kcy5sZWZ0ICsgcHJpdmF0ZVdpZHRoO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgYm91bmRzLmxlZnQgPSBib3VuZHMucmlnaHQgKyBwcml2YXRlV2lkdGg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCR0eXBlLmlzTnVtYmVyKHByaXZhdGVIZWlnaHQpKSB7XHJcbiAgICAgICAgICAgIGlmIChwcml2YXRlSGVpZ2h0ID4gMCkge1xyXG4gICAgICAgICAgICAgICAgYm91bmRzLmJvdHRvbSA9IGJvdW5kcy50b3AgKyBwcml2YXRlSGVpZ2h0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgYm91bmRzLnRvcCA9IGJvdW5kcy5ib3R0b20gKyBwcml2YXRlSGVpZ2h0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgX3JlbW92ZVBhcmVudChwYXJlbnQpIHtcclxuICAgICAgICBpZiAocGFyZW50KSB7XHJcbiAgICAgICAgICAgIHBhcmVudC5jaGlsZHJlbi5yZW1vdmVWYWx1ZSh0aGlzKTtcclxuICAgICAgICAgICAgJGFycmF5LnJlbW92ZUZpcnN0KHBhcmVudC5fcGVyY2VudGFnZVNpemVDaGlsZHJlbiwgdGhpcyk7XHJcbiAgICAgICAgICAgICRhcnJheS5yZW1vdmVGaXJzdChwYXJlbnQuX3BlcmNlbnRhZ2VQb3NpdGlvbkNoaWxkcmVuLCB0aGlzKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBfY2xlYXJEaXJ0eSgpIHtcclxuICAgICAgICBzdXBlci5fY2xlYXJEaXJ0eSgpO1xyXG4gICAgICAgIHRoaXMuX3NpemVEaXJ0eSA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuX3N0YXRlc0hhbmRsZWQgPSBmYWxzZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2ltdWxhdGUgaG92ZXIgb3ZlciBlbGVtZW50LlxyXG4gICAgICovXHJcbiAgICBob3ZlcigpIHtcclxuICAgICAgICB0aGlzLnNob3dUb29sdGlwKCk7XHJcbiAgICAgICAgdGhpcy5faGFuZGxlT3ZlcigpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTaW11bGF0ZSB1bmhvdmVyIG92ZXIgZWxlbWVudC5cclxuICAgICAqL1xyXG4gICAgdW5ob3ZlcigpIHtcclxuICAgICAgICB0aGlzLmhpZGVUb29sdGlwKCk7XHJcbiAgICAgICAgdGhpcy5faGFuZGxlT3V0KCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNob3dzIGVsZW1lbnQncyBbW1Rvb2x0aXBdXS5cclxuICAgICAqL1xyXG4gICAgc2hvd1Rvb2x0aXAocG9pbnQpIHtcclxuICAgICAgICBjb25zdCB0b29sdGlwID0gdGhpcy5nZXRUb29sdGlwKCk7XHJcbiAgICAgICAgY29uc3QgdG9vbHRpcFRleHQgPSB0aGlzLmdldChcInRvb2x0aXBUZXh0XCIpO1xyXG4gICAgICAgIGNvbnN0IHRvb2x0aXBIVE1MID0gdGhpcy5nZXQoXCJ0b29sdGlwSFRNTFwiKTtcclxuICAgICAgICBpZiAoKHRvb2x0aXBUZXh0IHx8IHRvb2x0aXBIVE1MKSAmJiB0b29sdGlwKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHRvb2x0aXBQb3NpdGlvbiA9IHRoaXMuZ2V0KFwidG9vbHRpcFBvc2l0aW9uXCIpO1xyXG4gICAgICAgICAgICBjb25zdCB0b29sdGlwVGFyZ2V0ID0gdGhpcy5nZXRQcml2YXRlKFwidG9vbHRpcFRhcmdldFwiLCB0aGlzKTtcclxuICAgICAgICAgICAgaWYgKHRvb2x0aXBQb3NpdGlvbiA9PSBcImZpeGVkXCIgfHwgIXBvaW50KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9kaXNwbGF5Ll9zZXRNYXRyaXgoKTtcclxuICAgICAgICAgICAgICAgIHBvaW50ID0gdGhpcy50b0dsb2JhbCh0b29sdGlwVGFyZ2V0Ll9nZXRUb29sdGlwUG9pbnQoKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdG9vbHRpcC5zZXQoXCJwb2ludFRvXCIsIHBvaW50KTtcclxuICAgICAgICAgICAgdG9vbHRpcC5zZXQoXCJ0b29sdGlwVGFyZ2V0XCIsIHRvb2x0aXBUYXJnZXQpO1xyXG4gICAgICAgICAgICBpZiAoIXRvb2x0aXAuZ2V0KFwieFwiKSkge1xyXG4gICAgICAgICAgICAgICAgdG9vbHRpcC5zZXQoXCJ4XCIsIHBvaW50LngpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghdG9vbHRpcC5nZXQoXCJ5XCIpKSB7XHJcbiAgICAgICAgICAgICAgICB0b29sdGlwLnNldChcInlcIiwgcG9pbnQueSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRvb2x0aXBUZXh0KSB7XHJcbiAgICAgICAgICAgICAgICB0b29sdGlwLmxhYmVsLnNldChcInRleHRcIiwgdG9vbHRpcFRleHQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0b29sdGlwSFRNTCkge1xyXG4gICAgICAgICAgICAgICAgdG9vbHRpcC5sYWJlbC5zZXQoXCJodG1sXCIsIHRvb2x0aXBIVE1MKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBkYXRhSXRlbSA9IHRoaXMuZGF0YUl0ZW07XHJcbiAgICAgICAgICAgIGlmIChkYXRhSXRlbSkge1xyXG4gICAgICAgICAgICAgICAgdG9vbHRpcC5sYWJlbC5fc2V0RGF0YUl0ZW0oZGF0YUl0ZW0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmdldChcInNob3dUb29sdGlwT25cIikgPT0gXCJhbHdheXNcIiAmJiAocG9pbnQueCA8IDAgfHwgcG9pbnQueCA+IHRoaXMuX3Jvb3Qud2lkdGgoKSB8fCBwb2ludC55IDwgMCB8fCBwb2ludC55ID4gdGhpcy5fcm9vdC5oZWlnaHQoKSkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuaGlkZVRvb2x0aXAoKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0b29sdGlwLmxhYmVsLnRleHQubWFya0RpcnR5VGV4dCgpO1xyXG4gICAgICAgICAgICBjb25zdCBwcm9taXNlID0gdG9vbHRpcC5zaG93KCk7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0UHJpdmF0ZVJhdyhcInNob3dpbmdUb29sdGlwXCIsIHRydWUpO1xyXG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEhpZGVzIGVsZW1lbnQncyBbW1Rvb2x0aXBdXS5cclxuICAgICAqL1xyXG4gICAgaGlkZVRvb2x0aXAoKSB7XHJcbiAgICAgICAgY29uc3QgdG9vbHRpcCA9IHRoaXMuZ2V0VG9vbHRpcCgpO1xyXG4gICAgICAgIGlmICh0b29sdGlwKSB7XHJcbiAgICAgICAgICAgIGlmICh0b29sdGlwLmdldChcInRvb2x0aXBUYXJnZXRcIikgPT0gdGhpcy5nZXRQcml2YXRlKFwidG9vbHRpcFRhcmdldFwiLCB0aGlzKSB8fCB0aGlzLmdldChcInRvb2x0aXBcIikgPT0gdG9vbHRpcCkge1xyXG4gICAgICAgICAgICAgICAgbGV0IHRpbWVvdXQgPSB0b29sdGlwLmdldChcImtlZXBUYXJnZXRIb3ZlclwiKSAmJiB0b29sdGlwLmdldChcInN0YXRlQW5pbWF0aW9uRHVyYXRpb25cIiwgMCkgPT0gMCA/IDQwMCA6IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHByb21pc2UgPSB0b29sdGlwLmhpZGUodGltZW91dCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNldFByaXZhdGVSYXcoXCJzaG93aW5nVG9vbHRpcFwiLCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIF9nZXRUb29sdGlwUG9pbnQoKSB7XHJcbiAgICAgICAgY29uc3QgYm91bmRzID0gdGhpcy5fbG9jYWxCb3VuZHM7XHJcbiAgICAgICAgaWYgKGJvdW5kcykge1xyXG4gICAgICAgICAgICBsZXQgeCA9IDA7XHJcbiAgICAgICAgICAgIGxldCB5ID0gMDtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLmdldChcImlzTWVhc3VyZWRcIikpIHtcclxuICAgICAgICAgICAgICAgIHggPSAkdXRpbHMucmVsYXRpdmVUb1ZhbHVlKHRoaXMuZ2V0KFwidG9vbHRpcFhcIiwgMCksIHRoaXMud2lkdGgoKSk7XHJcbiAgICAgICAgICAgICAgICB5ID0gJHV0aWxzLnJlbGF0aXZlVG9WYWx1ZSh0aGlzLmdldChcInRvb2x0aXBZXCIsIDApLCB0aGlzLmhlaWdodCgpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHggPSBib3VuZHMubGVmdCArICR1dGlscy5yZWxhdGl2ZVRvVmFsdWUodGhpcy5nZXQoXCJ0b29sdGlwWFwiLCAwKSwgYm91bmRzLnJpZ2h0IC0gYm91bmRzLmxlZnQpO1xyXG4gICAgICAgICAgICAgICAgeSA9IGJvdW5kcy50b3AgKyAkdXRpbHMucmVsYXRpdmVUb1ZhbHVlKHRoaXMuZ2V0KFwidG9vbHRpcFlcIiwgMCksIGJvdW5kcy5ib3R0b20gLSBib3VuZHMudG9wKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4geyB4LCB5IH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB7IHg6IDAsIHk6IDAgfTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBbW1Rvb2x0aXBdXSB1c2VkIGZvciB0aGlzIGVsZW1lbnQuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybiBUb29sdGlwXHJcbiAgICAgKi9cclxuICAgIGdldFRvb2x0aXAoKSB7XHJcbiAgICAgICAgbGV0IHRvb2x0aXAgPSB0aGlzLmdldChcInRvb2x0aXBcIik7XHJcbiAgICAgICAgaWYgKCF0b29sdGlwKSB7XHJcbiAgICAgICAgICAgIGxldCBwYXJlbnQgPSB0aGlzLnBhcmVudDtcclxuICAgICAgICAgICAgaWYgKHBhcmVudCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcmVudC5nZXRUb29sdGlwKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0b29sdGlwO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIF91cGRhdGVQb3NpdGlvbigpIHtcclxuICAgICAgICBjb25zdCBwYXJlbnQgPSB0aGlzLnBhcmVudDtcclxuICAgICAgICBsZXQgZHggPSB0aGlzLmdldChcImR4XCIsIDApO1xyXG4gICAgICAgIGxldCBkeSA9IHRoaXMuZ2V0KFwiZHlcIiwgMCk7XHJcbiAgICAgICAgbGV0IHggPSB0aGlzLmdldChcInhcIik7XHJcbiAgICAgICAgbGV0IF94ID0gdGhpcy5nZXRQcml2YXRlKFwieFwiKTtcclxuICAgICAgICBsZXQgeHggPSAwO1xyXG4gICAgICAgIGxldCB5eSA9IDA7XHJcbiAgICAgICAgY29uc3QgcG9zaXRpb24gPSB0aGlzLmdldChcInBvc2l0aW9uXCIpO1xyXG4gICAgICAgIGlmICh4IGluc3RhbmNlb2YgUGVyY2VudCkge1xyXG4gICAgICAgICAgICBpZiAocGFyZW50KSB7XHJcbiAgICAgICAgICAgICAgICB4ID0gcGFyZW50LmlubmVyV2lkdGgoKSAqIHgudmFsdWUgKyBwYXJlbnQuZ2V0KFwicGFkZGluZ0xlZnRcIiwgMCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB4ID0gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoJHR5cGUuaXNOdW1iZXIoeCkpIHtcclxuICAgICAgICAgICAgeHggPSB4ICsgZHg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAoX3ggIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgeHggPSBfeDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChwYXJlbnQpIHtcclxuICAgICAgICAgICAgICAgIGlmIChwb3NpdGlvbiA9PSBcInJlbGF0aXZlXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICB4eCA9IHBhcmVudC5nZXQoXCJwYWRkaW5nTGVmdFwiLCAwKSArIGR4O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCB5ID0gdGhpcy5nZXQoXCJ5XCIpO1xyXG4gICAgICAgIGxldCBfeSA9IHRoaXMuZ2V0UHJpdmF0ZShcInlcIik7XHJcbiAgICAgICAgaWYgKHkgaW5zdGFuY2VvZiBQZXJjZW50KSB7XHJcbiAgICAgICAgICAgIGlmIChwYXJlbnQpIHtcclxuICAgICAgICAgICAgICAgIHkgPSBwYXJlbnQuaW5uZXJIZWlnaHQoKSAqIHkudmFsdWUgKyBwYXJlbnQuZ2V0KFwicGFkZGluZ1RvcFwiLCAwKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHkgPSAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICgkdHlwZS5pc051bWJlcih5KSkge1xyXG4gICAgICAgICAgICB5eSA9IHkgKyBkeTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmIChfeSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICB5eSA9IF95O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHBhcmVudCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHBvc2l0aW9uID09IFwicmVsYXRpdmVcIikge1xyXG4gICAgICAgICAgICAgICAgICAgIHl5ID0gcGFyZW50LmdldChcInBhZGRpbmdUb3BcIiwgMCkgKyBkeTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBkaXNwbGF5ID0gdGhpcy5fZGlzcGxheTtcclxuICAgICAgICBpZiAoZGlzcGxheS54ICE9IHh4IHx8IGRpc3BsYXkueSAhPSB5eSkge1xyXG4gICAgICAgICAgICBkaXNwbGF5LmludmFsaWRhdGVCb3VuZHMoKTtcclxuICAgICAgICAgICAgZGlzcGxheS54ID0geHg7XHJcbiAgICAgICAgICAgIGRpc3BsYXkueSA9IHl5O1xyXG4gICAgICAgICAgICBjb25zdCBldmVudFR5cGUgPSBcInBvc2l0aW9uY2hhbmdlZFwiO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5ldmVudHMuaXNFbmFibGVkKGV2ZW50VHlwZSkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZXZlbnRzLmRpc3BhdGNoKGV2ZW50VHlwZSwgeyB0eXBlOiBldmVudFR5cGUsIHRhcmdldDogdGhpcyB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBVcGRhdGUgdG9vbHRpcCBwb3NpdGlvbiB0b2dldGhlciB3aXRoIHRoZSBTcHJpdGVcclxuICAgICAgICBpZiAodGhpcy5nZXRQcml2YXRlKFwic2hvd2luZ1Rvb2x0aXBcIikpIHtcclxuICAgICAgICAgICAgdGhpcy5zaG93VG9vbHRpcCgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBlbGVtZW50J3MgYWN0dWFsIFggcG9zaXRpb24gaW4gcGl4ZWxzLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm4gWCAocHgpXHJcbiAgICAgKi9cclxuICAgIHgoKSB7XHJcbiAgICAgICAgbGV0IHggPSB0aGlzLmdldChcInhcIik7XHJcbiAgICAgICAgbGV0IF94ID0gdGhpcy5nZXRQcml2YXRlKFwieFwiKTtcclxuICAgICAgICBjb25zdCBwYXJlbnQgPSB0aGlzLnBhcmVudDtcclxuICAgICAgICBpZiAocGFyZW50KSB7XHJcbiAgICAgICAgICAgIGlmICh4IGluc3RhbmNlb2YgUGVyY2VudCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICR1dGlscy5yZWxhdGl2ZVRvVmFsdWUoeCwgcGFyZW50LmlubmVyV2lkdGgoKSkgKyBwYXJlbnQuZ2V0KFwicGFkZGluZ0xlZnRcIiwgMCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoISR0eXBlLmlzTnVtYmVyKHgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKF94ICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF94O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhcmVudC5nZXQoXCJwYWRkaW5nTGVmdFwiLCB0aGlzLl9kaXNwbGF5LngpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB4O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLl9kaXNwbGF5Lng7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgZWxlbWVudCdzIGFjdHVhbCBZIHBvc2l0aW9uIGluIHBpeGVscy5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJuIFkgKHB4KVxyXG4gICAgICovXHJcbiAgICB5KCkge1xyXG4gICAgICAgIGxldCBfeSA9IHRoaXMuZ2V0UHJpdmF0ZShcInlcIik7XHJcbiAgICAgICAgaWYgKF95ICE9IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIF95O1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgeSA9IHRoaXMuZ2V0KFwieVwiKTtcclxuICAgICAgICBjb25zdCBwYXJlbnQgPSB0aGlzLnBhcmVudDtcclxuICAgICAgICBpZiAocGFyZW50KSB7XHJcbiAgICAgICAgICAgIGlmICh5IGluc3RhbmNlb2YgUGVyY2VudCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICR1dGlscy5yZWxhdGl2ZVRvVmFsdWUoeSwgcGFyZW50LmlubmVySGVpZ2h0KCkpICsgcGFyZW50LmdldChcInBhZGRpbmdUb3BcIiwgMCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoISR0eXBlLmlzTnVtYmVyKHkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKF95ICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF95O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhcmVudC5nZXQoXCJwYWRkaW5nVG9wXCIsIHRoaXMuX2Rpc3BsYXkueSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Rpc3BsYXkueTtcclxuICAgIH1cclxuICAgIF9kaXNwb3NlKCkge1xyXG4gICAgICAgIHN1cGVyLl9kaXNwb3NlKCk7XHJcbiAgICAgICAgdGhpcy5fZGlzcGxheS5kaXNwb3NlKCk7XHJcbiAgICAgICAgdGhpcy5fcmVtb3ZlVGVtcGxhdGVGaWVsZCgpO1xyXG4gICAgICAgIHRoaXMuX3JlbW92ZVBhcmVudCh0aGlzLnBhcmVudCk7XHJcbiAgICAgICAgdGhpcy5fcm9vdC5fcmVtb3ZlRm9jdXNFbGVtZW50KHRoaXMpO1xyXG4gICAgICAgIGNvbnN0IHRvb2x0aXAgPSB0aGlzLmdldChcInRvb2x0aXBcIik7XHJcbiAgICAgICAgaWYgKHRvb2x0aXApIHtcclxuICAgICAgICAgICAgdG9vbHRpcC5kaXNwb3NlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMubWFya0RpcnR5KCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEBpZ25vcmVcclxuICAgICAqL1xyXG4gICAgYWRqdXN0ZWRMb2NhbEJvdW5kcygpIHtcclxuICAgICAgICB0aGlzLl9maXhNaW5Cb3VuZHModGhpcy5fYWRqdXN0ZWRMb2NhbEJvdW5kcyk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkanVzdGVkTG9jYWxCb3VuZHM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgbG9jYWwgY29vcmRpbmF0ZXMgb2YgdGhlIGVsZW1lbnQncyBib3VuZHMuXHJcbiAgICAgKlxyXG4gICAgICogQGlnbm9yZVxyXG4gICAgICogQHJldHVybiBHbG9iYWwgYm91bmRzXHJcbiAgICAgKi9cclxuICAgIGxvY2FsQm91bmRzKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9sb2NhbEJvdW5kcztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhZGp1c3RlZCBsb2NhbCBjb29yZGluYXRlcyBvZiB0aGUgZWxlbWVudCdzIGJvdW5kcy5cclxuICAgICAqXHJcbiAgICAgKiBAaWdub3JlXHJcbiAgICAgKiBAcmV0dXJuIEdsb2JhbCBib3VuZHNcclxuICAgICAqL1xyXG4gICAgYm91bmRzKCkge1xyXG4gICAgICAgIGNvbnN0IGJvdW5kcyA9IHRoaXMuX2FkanVzdGVkTG9jYWxCb3VuZHM7XHJcbiAgICAgICAgY29uc3QgeCA9IHRoaXMueCgpO1xyXG4gICAgICAgIGNvbnN0IHkgPSB0aGlzLnkoKTtcclxuICAgICAgICByZXR1cm4geyBsZWZ0OiBib3VuZHMubGVmdCArIHgsIHJpZ2h0OiBib3VuZHMucmlnaHQgKyB4LCB0b3A6IGJvdW5kcy50b3AgKyB5LCBib3R0b206IGJvdW5kcy5ib3R0b20gKyB5IH07XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgZ2xvYmFsIGNvb3JkaW5hdGVzIG9mIHRoZSBlbGVtZW50J3MgYm91bmRzLlxyXG4gICAgICpcclxuICAgICAqIEBpZ25vcmVcclxuICAgICAqIEByZXR1cm4gR2xvYmFsIGJvdW5kc1xyXG4gICAgICovXHJcbiAgICBnbG9iYWxCb3VuZHMoKSB7XHJcbiAgICAgICAgY29uc3QgYm91bmRzID0gdGhpcy5sb2NhbEJvdW5kcygpO1xyXG4gICAgICAgIGNvbnN0IHAwID0gdGhpcy50b0dsb2JhbCh7IHg6IGJvdW5kcy5sZWZ0LCB5OiBib3VuZHMudG9wIH0pO1xyXG4gICAgICAgIGNvbnN0IHAxID0gdGhpcy50b0dsb2JhbCh7IHg6IGJvdW5kcy5yaWdodCwgeTogYm91bmRzLnRvcCB9KTtcclxuICAgICAgICBjb25zdCBwMiA9IHRoaXMudG9HbG9iYWwoeyB4OiBib3VuZHMucmlnaHQsIHk6IGJvdW5kcy5ib3R0b20gfSk7XHJcbiAgICAgICAgY29uc3QgcDMgPSB0aGlzLnRvR2xvYmFsKHsgeDogYm91bmRzLmxlZnQsIHk6IGJvdW5kcy5ib3R0b20gfSk7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgbGVmdDogTWF0aC5taW4ocDAueCwgcDEueCwgcDIueCwgcDMueCksXHJcbiAgICAgICAgICAgIHRvcDogTWF0aC5taW4ocDAueSwgcDEueSwgcDIueSwgcDMueSksXHJcbiAgICAgICAgICAgIHJpZ2h0OiBNYXRoLm1heChwMC54LCBwMS54LCBwMi54LCBwMy54KSxcclxuICAgICAgICAgICAgYm90dG9tOiBNYXRoLm1heChwMC55LCBwMS55LCBwMi55LCBwMy55KVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBfb25TaG93KF9kdXJhdGlvbikge1xyXG4gICAgfVxyXG4gICAgX29uSGlkZShfZHVyYXRpb24pIHtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUGxheXMgaW5pdGlhbCByZXZlYWwgYW5pbWF0aW9uIHJlZ2FyZGxlc3MgaWYgZWxlbWVudCBpcyBjdXJyZW50bHkgaGlkZGVuXHJcbiAgICAgKiBvciB2aXNpYmxlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSAgIGR1cmF0aW9uICBEdXJhdGlvbiBvZiB0aGUgYW5pbWF0aW9uIGluIG1pbGxpc2Vjb25kc1xyXG4gICAgICogQHBhcmFtICAgZGVsYXkgICAgIERlbGF5IHNob3dpbmcgb2YgdGhlIGVsZW1lbnQgYnkgWCBtaWxsaXNlY29uZHNcclxuICAgICAqIEByZXR1cm4gICAgICAgICAgICBQcm9taXNlXHJcbiAgICAgKi9cclxuICAgIGFwcGVhcihkdXJhdGlvbiwgZGVsYXkpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICB5aWVsZCB0aGlzLmhpZGUoMCk7XHJcbiAgICAgICAgICAgIGlmIChkZWxheSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChzdWNjZXNzLCBfZXJyb3IpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdWNjZXNzKHRoaXMuc2hvdyhkdXJhdGlvbikpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0sIGRlbGF5KTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2hvdyhkdXJhdGlvbik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2hvd3MgY3VycmVudGx5IGhpZGRlbiBlbGVtZW50IGFuZCByZXR1cm5zIGEgYFByb21pc2VgIHdoaWNoIGNvbXBsZXRlc1xyXG4gICAgICogd2hlbiBhbGwgc2hvd2luZyBhbmltYXRpb25zIGFyZSBmaW5pc2hlZC5cclxuICAgICAqXHJcbiAgICAgKiBgYGBUeXBlU2NyaXB0XHJcbiAgICAgKiBzZXJpZXMuc2hvdygpLnRoZW4oZnVuY3Rpb24oZXYpIHtcclxuICAgICAqICAgY29uc29sZS5sb2coXCJTZXJpZXMgaXMgbm93IGZ1bGx5IHZpc2libGVcIik7XHJcbiAgICAgKiB9KVxyXG4gICAgICogYGBgXHJcbiAgICAgKiBgYGBKYXZhU2NyaXB0XHJcbiAgICAgKiBzZXJpZXMuc2hvdygpLnRoZW4oZnVuY3Rpb24oZXYpIHtcclxuICAgICAqICAgY29uc29sZS5sb2coXCJTZXJpZXMgaXMgbm93IGZ1bGx5IHZpc2libGVcIik7XHJcbiAgICAgKiB9KVxyXG4gICAgICogYGBgXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybiBQcm9taXNlXHJcbiAgICAgKi9cclxuICAgIHNob3coZHVyYXRpb24pIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuX2lzU2hvd2luZykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5faXNIaWRkZW4gPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2lzU2hvd2luZyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9pc0hpZGluZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGVzLmxvb2t1cChcImRlZmF1bHRcIikuZ2V0KFwidmlzaWJsZVwiKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0KFwidmlzaWJsZVwiLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuX29uU2hvdyhkdXJhdGlvbik7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBhbmltYXRpb25zID0gdGhpcy5zdGF0ZXMuYXBwbHlBbmltYXRlKFwiZGVmYXVsdFwiLCBkdXJhdGlvbik7XHJcbiAgICAgICAgICAgICAgICB5aWVsZCB3YWl0Rm9yQW5pbWF0aW9ucyhhbmltYXRpb25zKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2lzU2hvd2luZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEhpZGVzIHRoZSBlbGVtZW50IGFuZCByZXR1cm5zIGEgYFByb21pc2VgIHdoaWNoIGNvbXBsZXRlcyB3aGVuIGFsbCBoaWRpbmdcclxuICAgICAqIGFuaW1hdGlvbnMgYXJlIGZpbmlzaGVkLlxyXG4gICAgICpcclxuICAgICAqIGBgYFR5cGVTY3JpcHRcclxuICAgICAqIHNlcmllcy5oaWRlKCkudGhlbihmdW5jdGlvbihldikge1xyXG4gICAgICogICBjb25zb2xlLmxvZyhcIlNlcmllcyBmaW5pc2hlZCBoaWRpbmdcIik7XHJcbiAgICAgKiB9KVxyXG4gICAgICogYGBgXHJcbiAgICAgKiBgYGBKYXZhU2NyaXB0XHJcbiAgICAgKiBzZXJpZXMuaGlkZSgpLnRoZW4oZnVuY3Rpb24oZXYpIHtcclxuICAgICAqICAgY29uc29sZS5sb2coXCJTZXJpZXMgZmluaXNoZWQgaGlkaW5nXCIpO1xyXG4gICAgICogfSlcclxuICAgICAqIGBgYFxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm4gUHJvbWlzZVxyXG4gICAgICovXHJcbiAgICBoaWRlKGR1cmF0aW9uKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLl9pc0hpZGluZyAmJiAhdGhpcy5faXNIaWRkZW4pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2lzSGlkaW5nID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2lzU2hvd2luZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgbGV0IHN0YXRlID0gdGhpcy5zdGF0ZXMubG9va3VwKFwiaGlkZGVuXCIpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFzdGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlID0gdGhpcy5zdGF0ZXMuY3JlYXRlKFwiaGlkZGVuXCIsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgXCJvcGFjaXR5XCI6IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFwidmlzaWJsZVwiOiBmYWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5faXNIaWRkZW4gPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fb25IaWRlKGR1cmF0aW9uKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGFuaW1hdGlvbnMgPSB0aGlzLnN0YXRlcy5hcHBseUFuaW1hdGUoXCJoaWRkZW5cIiwgZHVyYXRpb24pO1xyXG4gICAgICAgICAgICAgICAgeWllbGQgd2FpdEZvckFuaW1hdGlvbnMoYW5pbWF0aW9ucyk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9pc0hpZGluZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYHRydWVgIGlmIHRoaXMgZWxlbWVudCBpcyBjdXJyZW50bHkgaGlkZGVuLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm4gSXMgaGlkZGVuP1xyXG4gICAgICovXHJcbiAgICBpc0hpZGRlbigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5faXNIaWRkZW47XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYHRydWVgIGlmIHRoaXMgZWxlbWVudCBpcyBjdXJyZW50bHkgYW5pbWF0aW5nIHRvIGEgZGVmYXVsdCBzdGF0ZS5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJuIElzIHNob3dpbmc/XHJcbiAgICAgKi9cclxuICAgIGlzU2hvd2luZygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5faXNTaG93aW5nO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGB0cnVlYCBpZiB0aGlzIGVsZW1lbnQgaXMgY3VycmVudGx5IGFuaW1hdGluZyB0byBhIGhpZGRlbiBzdGF0ZS5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJuIElzIGhpZGluZz9cclxuICAgICAqL1xyXG4gICAgaXNIaWRpbmcoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzSGlkaW5nO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGB0cnVlYCBpZiB0aGlzIGVsZW1lbnQgaXMgY3VycmVudGx5IGhvdmVyZWQgYnkgYSBwb2ludGVyLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm4gSXMgaG92ZXJlZD9cclxuICAgICAqL1xyXG4gICAgaXNIb3ZlcigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZGlzcGxheS5ob3ZlcmluZygpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGB0cnVlYCBpZiB0aGlzIGVsZW1lbnQgZG9lcyBjdXJyZW50bHkgaGF2ZSBmb2N1cy5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJuIElzIGZvY3VzZWQ/XHJcbiAgICAgKi9cclxuICAgIGlzRm9jdXMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Jvb3QuZm9jdXNlZCh0aGlzKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBgdHJ1ZWAgaWYgdGhpcyBlbGVtZW50IGlzIGN1cnJlbnRseSBiZWluZyBkcmFnZ2VkLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm4gSXMgZHJhZ2dlZD9cclxuICAgICAqL1xyXG4gICAgaXNEcmFnZ2luZygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5faXNEcmFnZ2luZztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBgZmFsc2VgIGlmIGlmIGVpdGhlciBwdWJsaWMgb3IgcHJpdmF0ZSBzZXR0aW5nIGB2aXNpYmxlYCBpcyBzZXRcclxuICAgICAqIHRvIGBmYWxzZWAsIG9yIGBmb3JjZUhpZGRlbmAgaXMgc2V0IHRvIGB0cnVlYC5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJuIFZpc2libGU/XHJcbiAgICAgKi9cclxuICAgIGlzVmlzaWJsZSgpIHtcclxuICAgICAgICBpZiAodGhpcy5nZXQoXCJ2aXNpYmxlXCIpICYmIHRoaXMuZ2V0UHJpdmF0ZShcInZpc2libGVcIikgJiYgIXRoaXMuZ2V0KFwiZm9yY2VIaWRkZW5cIikpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2FtZSBhcyBgaXNWaXNpYmxlKClgLCBleGNlcHQgaXQgY2hlY2tzIGFsbCBhc2NlbmRhbnRzLCB0b28uXHJcbiAgICAgKlxyXG4gICAgICogQHNpbmNlIDUuMi43XHJcbiAgICAgKiBAcmV0dXJuIFZpc2libGU/XHJcbiAgICAgKi9cclxuICAgIGlzVmlzaWJsZURlZXAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhcmVudCA/ICh0aGlzLl9wYXJlbnQuaXNWaXNpYmxlRGVlcCgpICYmIHRoaXMuaXNWaXNpYmxlKCkpIDogdGhpcy5pc1Zpc2libGUoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhbiBhY3R1YWwgb3BhY2l0eSBvZiB0aGUgZWxlbWVudCwgdGFraW5nIGludG8gYWNjb3VudCBhbGwgcGFyZW50cy5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJuIE9wYWNpdHlcclxuICAgICAqIEBzaW5jZSA1LjIuMTFcclxuICAgICAqL1xyXG4gICAgY29tcG9zaXRlT3BhY2l0eSgpIHtcclxuICAgICAgICBjb25zdCBvcGFjaXR5ID0gdGhpcy5nZXQoXCJvcGFjaXR5XCIsIDEpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9wYXJlbnQgPyAodGhpcy5fcGFyZW50LmNvbXBvc2l0ZU9wYWNpdHkoKSAqIG9wYWNpdHkpIDogb3BhY2l0eTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB3aWR0aCBvZiB0aGlzIGVsZW1lbnQgaW4gcGl4ZWxzLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm4gV2lkdGggKHB4KVxyXG4gICAgICovXHJcbiAgICB3aWR0aCgpIHtcclxuICAgICAgICBsZXQgd2lkdGggPSB0aGlzLmdldChcIndpZHRoXCIpO1xyXG4gICAgICAgIGxldCBtYXhXaWR0aCA9IHRoaXMuZ2V0KFwibWF4V2lkdGhcIiwgdGhpcy5nZXRQcml2YXRlKFwibWF4V2lkdGhcIikpO1xyXG4gICAgICAgIGxldCBtaW5XaWR0aCA9IHRoaXMuZ2V0KFwibWluV2lkdGhcIiwgdGhpcy5nZXRQcml2YXRlKFwibWluV2lkdGhcIikpO1xyXG4gICAgICAgIGxldCBwcml2YXRlV2lkdGggPSB0aGlzLmdldFByaXZhdGUoXCJ3aWR0aFwiKTtcclxuICAgICAgICBsZXQgdyA9IDA7XHJcbiAgICAgICAgaWYgKCR0eXBlLmlzTnVtYmVyKHByaXZhdGVXaWR0aCkpIHtcclxuICAgICAgICAgICAgdyA9IHByaXZhdGVXaWR0aDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmICh3aWR0aCA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fYWRqdXN0ZWRMb2NhbEJvdW5kcykge1xyXG4gICAgICAgICAgICAgICAgICAgIHcgPSB0aGlzLl9hZGp1c3RlZExvY2FsQm91bmRzLnJpZ2h0IC0gdGhpcy5fYWRqdXN0ZWRMb2NhbEJvdW5kcy5sZWZ0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWYgKHdpZHRoIGluc3RhbmNlb2YgUGVyY2VudCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhcmVudCA9IHRoaXMucGFyZW50O1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJlbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdyA9IHBhcmVudC5pbm5lcldpZHRoKCkgKiB3aWR0aC52YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHcgPSB0aGlzLl9yb290LndpZHRoKCkgKiB3aWR0aC52YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICgkdHlwZS5pc051bWJlcih3aWR0aCkpIHtcclxuICAgICAgICAgICAgICAgICAgICB3ID0gd2lkdGg7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCR0eXBlLmlzTnVtYmVyKG1pbldpZHRoKSkge1xyXG4gICAgICAgICAgICB3ID0gTWF0aC5tYXgobWluV2lkdGgsIHcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoJHR5cGUuaXNOdW1iZXIobWF4V2lkdGgpKSB7XHJcbiAgICAgICAgICAgIHcgPSBNYXRoLm1pbihtYXhXaWR0aCwgdyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB3O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIG1heGltdW0gYWxsb3dlZCB3aWR0aCBvZiB0aGlzIGVsZW1lbnQgaW4gcGl4ZWxzLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm4gTWF4aW11bSB3aWR0aCAocHgpXHJcbiAgICAgKi9cclxuICAgIG1heFdpZHRoKCkge1xyXG4gICAgICAgIGxldCBtYXhXaWR0aCA9IHRoaXMuZ2V0KFwibWF4V2lkdGhcIiwgdGhpcy5nZXRQcml2YXRlKFwibWF4V2lkdGhcIikpO1xyXG4gICAgICAgIGlmICgkdHlwZS5pc051bWJlcihtYXhXaWR0aCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG1heFdpZHRoO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgbGV0IHdpZHRoID0gdGhpcy5nZXQoXCJ3aWR0aFwiKTtcclxuICAgICAgICAgICAgaWYgKCR0eXBlLmlzTnVtYmVyKHdpZHRoKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHdpZHRoO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHBhcmVudCA9IHRoaXMucGFyZW50O1xyXG4gICAgICAgIGlmIChwYXJlbnQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHBhcmVudC5pbm5lcldpZHRoKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLl9yb290LndpZHRoKCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgbWF4aW11bSBhbGxvd2VkIGhlaWdodCBvZiB0aGlzIGVsZW1lbnQgaW4gcGl4ZWxzLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm4gTWF4aW11bSBoZWlnaHQgKHB4KVxyXG4gICAgICovXHJcbiAgICBtYXhIZWlnaHQoKSB7XHJcbiAgICAgICAgbGV0IG1heEhlaWdodCA9IHRoaXMuZ2V0KFwibWF4SGVpZ2h0XCIsIHRoaXMuZ2V0UHJpdmF0ZShcIm1heEhlaWdodFwiKSk7XHJcbiAgICAgICAgaWYgKCR0eXBlLmlzTnVtYmVyKG1heEhlaWdodCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG1heEhlaWdodDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGxldCBoZWlnaHQgPSB0aGlzLmdldChcImhlaWdodFwiKTtcclxuICAgICAgICAgICAgaWYgKCR0eXBlLmlzTnVtYmVyKGhlaWdodCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBoZWlnaHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgcGFyZW50ID0gdGhpcy5wYXJlbnQ7XHJcbiAgICAgICAgaWYgKHBhcmVudCkge1xyXG4gICAgICAgICAgICByZXR1cm4gcGFyZW50LmlubmVySGVpZ2h0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLl9yb290LmhlaWdodCgpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGhlaWdodCBvZiB0aGlzIGVsZW1lbnQgaW4gcGl4ZWxzLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm4gSGVpZ2h0IChweClcclxuICAgICAqL1xyXG4gICAgaGVpZ2h0KCkge1xyXG4gICAgICAgIGxldCBoZWlnaHQgPSB0aGlzLmdldChcImhlaWdodFwiKTtcclxuICAgICAgICBsZXQgbWF4SGVpZ2h0ID0gdGhpcy5nZXQoXCJtYXhIZWlnaHRcIiwgdGhpcy5nZXRQcml2YXRlKFwibWF4SGVpZ2h0XCIpKTtcclxuICAgICAgICBsZXQgbWluSGVpZ2h0ID0gdGhpcy5nZXQoXCJtaW5IZWlnaHRcIiwgdGhpcy5nZXRQcml2YXRlKFwibWluSGVpZ2h0XCIpKTtcclxuICAgICAgICBsZXQgcHJpdmF0ZUhlaWdodCA9IHRoaXMuZ2V0UHJpdmF0ZShcImhlaWdodFwiKTtcclxuICAgICAgICBsZXQgaCA9IDA7XHJcbiAgICAgICAgaWYgKCR0eXBlLmlzTnVtYmVyKHByaXZhdGVIZWlnaHQpKSB7XHJcbiAgICAgICAgICAgIGggPSBwcml2YXRlSGVpZ2h0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKGhlaWdodCA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fYWRqdXN0ZWRMb2NhbEJvdW5kcykge1xyXG4gICAgICAgICAgICAgICAgICAgIGggPSB0aGlzLl9hZGp1c3RlZExvY2FsQm91bmRzLmJvdHRvbSAtIHRoaXMuX2FkanVzdGVkTG9jYWxCb3VuZHMudG9wO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWYgKGhlaWdodCBpbnN0YW5jZW9mIFBlcmNlbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXJlbnQgPSB0aGlzLnBhcmVudDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocGFyZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGggPSBwYXJlbnQuaW5uZXJIZWlnaHQoKSAqIGhlaWdodC52YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGggPSB0aGlzLl9yb290LmhlaWdodCgpICogaGVpZ2h0LnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCR0eXBlLmlzTnVtYmVyKGhlaWdodCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBoID0gaGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICgkdHlwZS5pc051bWJlcihtaW5IZWlnaHQpKSB7XHJcbiAgICAgICAgICAgIGggPSBNYXRoLm1heChtaW5IZWlnaHQsIGgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoJHR5cGUuaXNOdW1iZXIobWF4SGVpZ2h0KSkge1xyXG4gICAgICAgICAgICBoID0gTWF0aC5taW4obWF4SGVpZ2h0LCBoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGg7XHJcbiAgICB9XHJcbiAgICBfZmluZFN0YXRpY1RlbXBsYXRlKGYpIHtcclxuICAgICAgICAvLyB0ZW1wbGF0ZUZpZWxkIG92ZXJyaWRlcyB0ZW1wbGF0ZVxyXG4gICAgICAgIGlmICh0aGlzLl90ZW1wbGF0ZUZpZWxkICYmIGYodGhpcy5fdGVtcGxhdGVGaWVsZCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RlbXBsYXRlRmllbGQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzdXBlci5fZmluZFN0YXRpY1RlbXBsYXRlKGYpO1xyXG4gICAgfVxyXG4gICAgX3dhbGtQYXJlbnRzKGYpIHtcclxuICAgICAgICBpZiAodGhpcy5fcGFyZW50KSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3dhbGtQYXJlbnQoZik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgX3dhbGtQYXJlbnQoZikge1xyXG4gICAgICAgIGlmICh0aGlzLl9wYXJlbnQpIHtcclxuICAgICAgICAgICAgdGhpcy5fcGFyZW50Ll93YWxrUGFyZW50KGYpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmKHRoaXMpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBQYXJlbnQgW1tDb250YWluZXJdXSBvZiB0aGlzIGVsZW1lbnQuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybiBQYXJlbnQgY29udGFpbmVyXHJcbiAgICAgKi9cclxuICAgIGdldCBwYXJlbnQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhcmVudDtcclxuICAgIH1cclxuICAgIF9zZXRQYXJlbnQocGFyZW50LCB1cGRhdGVDaGlsZHJlbiA9IGZhbHNlKSB7XHJcbiAgICAgICAgY29uc3QgcHJldlBhcmVudCA9IHRoaXMuX3BhcmVudDtcclxuICAgICAgICBpZiAocGFyZW50ICE9PSBwcmV2UGFyZW50KSB7XHJcbiAgICAgICAgICAgIHRoaXMubWFya0RpcnR5Qm91bmRzKCk7XHJcbiAgICAgICAgICAgIHBhcmVudC5tYXJrRGlydHkoKTtcclxuICAgICAgICAgICAgdGhpcy5fcGFyZW50ID0gcGFyZW50O1xyXG4gICAgICAgICAgICBpZiAodXBkYXRlQ2hpbGRyZW4pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3JlbW92ZVBhcmVudChwcmV2UGFyZW50KTtcclxuICAgICAgICAgICAgICAgIGlmIChwYXJlbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9hZGRQZXJjZW50YWdlU2l6ZUNoaWxkcmVuKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYWRkUGVyY2VudGFnZVBvc2l0aW9uQ2hpbGRyZW4oKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLm1hcmtEaXJ0eVBvc2l0aW9uKCk7XHJcbiAgICAgICAgICAgIHRoaXMuX2FwcGx5VGhlbWVzKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGFuIGluc3RhbmNlIG9mIFtbTnVtYmVyRm9ybWF0dGVyXV0gdXNlZCBpbiB0aGlzIGVsZW1lbnQuXHJcbiAgICAgKlxyXG4gICAgICogSWYgdGhpcyBlbGVtZW50IGRvZXMgbm90IGhhdmUgaXQgc2V0LCBnbG9iYWwgb25lIGZvcm0gW1tSb290XV0gaXMgdXNlZC5cclxuICAgICAqXHJcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL3d3dy5hbWNoYXJ0cy5jb20vZG9jcy92NS9jb25jZXB0cy91c2luZy1mb3JtYXR0ZXJzL30gZm9yIG1vcmUgaW5mb1xyXG4gICAgICogQHJldHVybiBOdW1iZXJGb3JtYXR0ZXIgaW5zdGFjZVxyXG4gICAgICovXHJcbiAgICBnZXROdW1iZXJGb3JtYXR0ZXIoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KFwibnVtYmVyRm9ybWF0dGVyXCIsIHRoaXMuX3Jvb3QubnVtYmVyRm9ybWF0dGVyKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhbiBpbnN0YW5jZSBvZiBbW0RhdGVGb3JtYXR0ZXJdXSB1c2VkIGluIHRoaXMgZWxlbWVudC5cclxuICAgICAqXHJcbiAgICAgKiBJZiB0aGlzIGVsZW1lbnQgZG9lcyBub3QgaGF2ZSBpdCBzZXQsIGdsb2JhbCBvbmUgZm9ybSBbW1Jvb3RdXSBpcyB1c2VkLlxyXG4gICAgICpcclxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vd3d3LmFtY2hhcnRzLmNvbS9kb2NzL3Y1L2NvbmNlcHRzL3VzaW5nLWZvcm1hdHRlcnMvfSBmb3IgbW9yZSBpbmZvXHJcbiAgICAgKiBAcmV0dXJuIERhdGVGb3JtYXR0ZXIgaW5zdGFjZVxyXG4gICAgICovXHJcbiAgICBnZXREYXRlRm9ybWF0dGVyKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmdldChcImRhdGVGb3JtYXR0ZXJcIiwgdGhpcy5fcm9vdC5kYXRlRm9ybWF0dGVyKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhbiBpbnN0YW5jZSBvZiBbW0R1cmF0aW9uRm9ybWF0dGVyXV0gdXNlZCBpbiB0aGlzIGVsZW1lbnQuXHJcbiAgICAgKlxyXG4gICAgICogSWYgdGhpcyBlbGVtZW50IGRvZXMgbm90IGhhdmUgaXQgc2V0LCBnbG9iYWwgb25lIGZvcm0gW1tSb290XV0gaXMgdXNlZC5cclxuICAgICAqXHJcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL3d3dy5hbWNoYXJ0cy5jb20vZG9jcy92NS9jb25jZXB0cy91c2luZy1mb3JtYXR0ZXJzL30gZm9yIG1vcmUgaW5mb1xyXG4gICAgICogQHJldHVybiBEdXJhdGlvbkZvcm1hdHRlciBpbnN0YWNlXHJcbiAgICAgKi9cclxuICAgIGdldER1cmF0aW9uRm9ybWF0dGVyKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmdldChcImR1cmF0aW9uRm9ybWF0dGVyXCIsIHRoaXMuX3Jvb3QuZHVyYXRpb25Gb3JtYXR0ZXIpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDb252ZXJ0cyBYL1kgY29vcmRpbmF0ZSB3aXRoaW4gdGhpcyBlbGVtZW50IHRvIGEgZ2xvYmFsIGNvb3JkaW5hdGUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtICBwb2ludCAgTG9jYWwgY29vcmRpbmF0ZVxyXG4gICAgICogQHJldHVybiAgICAgICAgR2xvYmFsIGNvb3JkaW5hdGVcclxuICAgICAqL1xyXG4gICAgdG9HbG9iYWwocG9pbnQpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZGlzcGxheS50b0dsb2JhbChwb2ludCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENvbnZlcnRzIGdsb2JhbCBYL1kgY29vcmRpbmF0ZSB0byBhIGNvb3JkaW5hdGUgd2l0aGluIHRoaXMgZWxlbWVudC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gIHBvaW50ICBHbG9iYWwgY29vcmRpbmF0ZVxyXG4gICAgICogQHJldHVybiAgICAgICAgTG9jYWwgY29vcmRpbmF0ZVxyXG4gICAgICovXHJcbiAgICB0b0xvY2FsKHBvaW50KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Rpc3BsYXkudG9Mb2NhbChwb2ludCk7XHJcbiAgICB9XHJcbiAgICBfZ2V0RG93blBvaW50KCkge1xyXG4gICAgICAgIGNvbnN0IGlkID0gdGhpcy5fZ2V0RG93blBvaW50SWQoKTtcclxuICAgICAgICBpZiAoaWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2Rvd25Qb2ludHNbaWRdO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIF9nZXREb3duUG9pbnRJZCgpIHtcclxuICAgICAgICBpZiAodGhpcy5fZG93blBvaW50cykge1xyXG4gICAgICAgICAgICByZXR1cm4gJG9iamVjdC5rZXlzT3JkZXJlZCh0aGlzLl9kb3duUG9pbnRzLCAoYSwgYikgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKGEgPiBiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoYSA8IGIpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gLTE7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICAgICAgfSlbMF07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBNb3ZlcyBzcHJpdGUgdG8gdGhlIGVuZCBvZiB0aGUgcGFyZW50J3MgY2hpbGRyZW4gYXJyYXkuXHJcbiAgICAgKlxyXG4gICAgICogRGVwZW5kaW5nIG9uIGBsYXlvdXRgIHNldHRpbmcgb2YgdGhlIHBhcnRlbiBjb250YWluZXIsIGl0IG1heSBlZmZlY3QgdGhlXHJcbiAgICAgKiBwb3NpdGlvbmluZyBvciBvdmVybGFwcGluZyBvcmRlciBvZiB0aGUgZWxlbWVudHMuXHJcbiAgICAgKi9cclxuICAgIHRvRnJvbnQoKSB7XHJcbiAgICAgICAgY29uc3QgcGFyZW50ID0gdGhpcy5wYXJlbnQ7XHJcbiAgICAgICAgaWYgKHBhcmVudCkge1xyXG4gICAgICAgICAgICBwYXJlbnQuY2hpbGRyZW4ubW92ZVZhbHVlKHRoaXMsIHBhcmVudC5jaGlsZHJlbi5sZW5ndGggLSAxKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIE1vdmVzIHNwcml0ZSB0byB0aGUgYmVnaW5uaW5nIG9mIHRoZSBwYXJlbnQncyBjaGlsZHJlbiBhcnJheS5cclxuICAgICAqXHJcbiAgICAgKiBEZXBlbmRpbmcgb24gYGxheW91dGAgc2V0dGluZyBvZiB0aGUgcGFydGVuIGNvbnRhaW5lciwgaXQgbWF5IGVmZmVjdCB0aGVcclxuICAgICAqIHBvc2l0aW9uaW5nIG9yIG92ZXJsYXBwaW5nIG9yZGVyIG9mIHRoZSBlbGVtZW50cy5cclxuICAgICAqL1xyXG4gICAgdG9CYWNrKCkge1xyXG4gICAgICAgIGNvbnN0IHBhcmVudCA9IHRoaXMucGFyZW50O1xyXG4gICAgICAgIGlmIChwYXJlbnQpIHtcclxuICAgICAgICAgICAgcGFyZW50LmNoaWxkcmVuLm1vdmVWYWx1ZSh0aGlzLCAwKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFNwcml0ZSwgXCJjbGFzc05hbWVcIiwge1xyXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgdmFsdWU6IFwiU3ByaXRlXCJcclxufSk7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShTcHJpdGUsIFwiY2xhc3NOYW1lc1wiLCB7XHJcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICB2YWx1ZTogRW50aXR5LmNsYXNzTmFtZXMuY29uY2F0KFtTcHJpdGUuY2xhc3NOYW1lXSlcclxufSk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVNwcml0ZS5qcy5tYXAiLCJpbXBvcnQgeyBTcHJpdGUgfSBmcm9tIFwiLi9TcHJpdGVcIjtcclxuaW1wb3J0IHsgcG9wdWxhdGVTdHJpbmcgfSBmcm9tIFwiLi4vdXRpbC9Qb3B1bGF0ZVN0cmluZ1wiO1xyXG5pbXBvcnQgKiBhcyAkYXJyYXkgZnJvbSBcIi4uL3V0aWwvQXJyYXlcIjtcclxuaW1wb3J0IHsgRGlzcG9zZXIgfSBmcm9tIFwiLi4vdXRpbC9EaXNwb3NlclwiO1xyXG4vKipcclxuICogQGlnbm9yZSBUZXh0IGlzIGFuIGludGVybmFsIGNsYXNzLiBVc2UgTGFiZWwgaW5zdGVhZC5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBUZXh0IGV4dGVuZHMgU3ByaXRlIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwidGV4dFN0eWxlXCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IHRoaXMuX3Jvb3QuX3JlbmRlcmVyLm1ha2VUZXh0U3R5bGUoKVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9kaXNwbGF5XCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IHRoaXMuX3Jvb3QuX3JlbmRlcmVyLm1ha2VUZXh0KFwiXCIsIHRoaXMudGV4dFN0eWxlKVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl90ZXh0U3R5bGVzXCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IFtcclxuICAgICAgICAgICAgICAgIFwidGV4dEFsaWduXCIsXHJcbiAgICAgICAgICAgICAgICBcImZvbnRGYW1pbHlcIixcclxuICAgICAgICAgICAgICAgIFwiZm9udFNpemVcIixcclxuICAgICAgICAgICAgICAgIFwiZm9udFN0eWxlXCIsXHJcbiAgICAgICAgICAgICAgICBcImZvbnRXZWlnaHRcIixcclxuICAgICAgICAgICAgICAgIFwiZm9udFN0eWxlXCIsXHJcbiAgICAgICAgICAgICAgICBcImZvbnRWYXJpYW50XCIsXHJcbiAgICAgICAgICAgICAgICBcInRleHREZWNvcmF0aW9uXCIsXHJcbiAgICAgICAgICAgICAgICBcInNoYWRvd0NvbG9yXCIsXHJcbiAgICAgICAgICAgICAgICBcInNoYWRvd0JsdXJcIixcclxuICAgICAgICAgICAgICAgIFwic2hhZG93T2Zmc2V0WFwiLFxyXG4gICAgICAgICAgICAgICAgXCJzaGFkb3dPZmZzZXRZXCIsXHJcbiAgICAgICAgICAgICAgICBcInNoYWRvd09wYWNpdHlcIixcclxuICAgICAgICAgICAgICAgIC8vIFwibGVhZGluZ1wiLFxyXG4gICAgICAgICAgICAgICAgLy8gXCJsZXR0ZXJTcGFjaW5nXCIsXHJcbiAgICAgICAgICAgICAgICBcImxpbmVIZWlnaHRcIixcclxuICAgICAgICAgICAgICAgIFwiYmFzZWxpbmVSYXRpb1wiLFxyXG4gICAgICAgICAgICAgICAgLy9cInBhZGRpbmdcIixcclxuICAgICAgICAgICAgICAgIC8vIFwic3Ryb2tlXCIsXHJcbiAgICAgICAgICAgICAgICAvLyBcInN0cm9rZVRoaWNrbmVzc1wiLFxyXG4gICAgICAgICAgICAgICAgLy8gXCJ0cmltXCIsXHJcbiAgICAgICAgICAgICAgICAvLyBcIndvcmRXcmFwXCIsXHJcbiAgICAgICAgICAgICAgICBcImRpcmVjdGlvblwiLFxyXG4gICAgICAgICAgICAgICAgXCJ0ZXh0QmFzZWxpbmVcIixcclxuICAgICAgICAgICAgICAgIFwib3ZlcnNpemVkQmVoYXZpb3JcIixcclxuICAgICAgICAgICAgICAgIFwiYnJlYWtXb3Jkc1wiLFxyXG4gICAgICAgICAgICAgICAgXCJlbGxpcHNpc1wiLFxyXG4gICAgICAgICAgICAgICAgXCJtaW5TY2FsZVwiXHJcbiAgICAgICAgICAgIF1cclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfb3JpZ2luYWxTY2FsZVwiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIF91cGRhdGVCb3VuZHMoKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmdldChcInRleHRcIikpIHtcclxuICAgICAgICAgICAgbGV0IG5ld0JvdW5kcyA9IHtcclxuICAgICAgICAgICAgICAgIGxlZnQ6IDAsXHJcbiAgICAgICAgICAgICAgICByaWdodDogMCxcclxuICAgICAgICAgICAgICAgIHRvcDogMCxcclxuICAgICAgICAgICAgICAgIGJvdHRvbTogMCxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgdGhpcy5fYWRqdXN0ZWRMb2NhbEJvdW5kcyA9IG5ld0JvdW5kcztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHN1cGVyLl91cGRhdGVCb3VuZHMoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBfY2hhbmdlZCgpIHtcclxuICAgICAgICBzdXBlci5fY2hhbmdlZCgpO1xyXG4gICAgICAgIHRoaXMuX2Rpc3BsYXkuY2xlYXIoKTtcclxuICAgICAgICBsZXQgdGV4dFN0eWxlID0gdGhpcy50ZXh0U3R5bGU7XHJcbiAgICAgICAgaWYgKHRoaXMuaXNEaXJ0eShcIm9wYWNpdHlcIikpIHtcclxuICAgICAgICAgICAgbGV0IG9wYWNpdHkgPSB0aGlzLmdldChcIm9wYWNpdHlcIiwgMSk7XHJcbiAgICAgICAgICAgIHRoaXMuX2Rpc3BsYXkuYWxwaGEgPSBvcGFjaXR5O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5pc0RpcnR5KFwidGV4dFwiKSB8fCB0aGlzLmlzRGlydHkoXCJwb3B1bGF0ZVRleHRcIikpIHtcclxuICAgICAgICAgICAgdGhpcy5fZGlzcGxheS50ZXh0ID0gdGhpcy5fZ2V0VGV4dCgpO1xyXG4gICAgICAgICAgICB0aGlzLm1hcmtEaXJ0eUJvdW5kcygpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5nZXQoXCJyb2xlXCIpID09IFwidG9vbHRpcFwiKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9yb290LnVwZGF0ZVRvb2x0aXAodGhpcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuaXNQcml2YXRlRGlydHkoXCJ0b29sdGlwRWxlbWVudFwiKSkge1xyXG4gICAgICAgICAgICBjb25zdCB0b29sdGlwRWxlbWVudCA9IHRoaXMuZ2V0UHJpdmF0ZShcInRvb2x0aXBFbGVtZW50XCIpO1xyXG4gICAgICAgICAgICBpZiAodG9vbHRpcEVsZW1lbnQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2Rpc3Bvc2Vycy5wdXNoKG5ldyBEaXNwb3NlcigoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcm9vdC5fcmVtb3ZlVG9vbHRpcEVsZW1lbnQodGhpcyk7XHJcbiAgICAgICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuaXNEaXJ0eShcIndpZHRoXCIpKSB7XHJcbiAgICAgICAgICAgIHRleHRTdHlsZS53b3JkV3JhcFdpZHRoID0gdGhpcy53aWR0aCgpO1xyXG4gICAgICAgICAgICB0aGlzLm1hcmtEaXJ0eUJvdW5kcygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5pc0RpcnR5KFwib3ZlcnNpemVkQmVoYXZpb3JcIikpIHtcclxuICAgICAgICAgICAgdGV4dFN0eWxlLm92ZXJzaXplZEJlaGF2aW9yID0gdGhpcy5nZXQoXCJvdmVyc2l6ZWRCZWhhdmlvclwiLCBcIm5vbmVcIik7XHJcbiAgICAgICAgICAgIHRoaXMubWFya0RpcnR5Qm91bmRzKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmlzRGlydHkoXCJicmVha1dvcmRzXCIpKSB7XHJcbiAgICAgICAgICAgIHRleHRTdHlsZS5icmVha1dvcmRzID0gdGhpcy5nZXQoXCJicmVha1dvcmRzXCIsIGZhbHNlKTtcclxuICAgICAgICAgICAgdGhpcy5tYXJrRGlydHlCb3VuZHMoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuaXNEaXJ0eShcImVsbGlwc2lzXCIpKSB7XHJcbiAgICAgICAgICAgIHRleHRTdHlsZS5lbGxpcHNpcyA9IHRoaXMuZ2V0KFwiZWxsaXBzaXNcIik7XHJcbiAgICAgICAgICAgIHRoaXMubWFya0RpcnR5Qm91bmRzKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmlzRGlydHkoXCJpZ25vcmVGb3JtYXR0aW5nXCIpKSB7XHJcbiAgICAgICAgICAgIHRleHRTdHlsZS5pZ25vcmVGb3JtYXR0aW5nID0gdGhpcy5nZXQoXCJpZ25vcmVGb3JtYXR0aW5nXCIsIGZhbHNlKTtcclxuICAgICAgICAgICAgdGhpcy5tYXJrRGlydHlCb3VuZHMoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuaXNEaXJ0eShcIm1pblNjYWxlXCIpKSB7XHJcbiAgICAgICAgICAgIHRleHRTdHlsZS5taW5TY2FsZSA9IHRoaXMuZ2V0KFwibWluU2NhbGVcIiwgMCk7XHJcbiAgICAgICAgICAgIHRoaXMubWFya0RpcnR5Qm91bmRzKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmlzRGlydHkoXCJmaWxsXCIpKSB7XHJcbiAgICAgICAgICAgIGxldCBmaWxsID0gdGhpcy5nZXQoXCJmaWxsXCIpO1xyXG4gICAgICAgICAgICBpZiAoZmlsbCkge1xyXG4gICAgICAgICAgICAgICAgdGV4dFN0eWxlLmZpbGwgPSBmaWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmlzRGlydHkoXCJmaWxsT3BhY2l0eVwiKSkge1xyXG4gICAgICAgICAgICBsZXQgZmlsbE9wYWNpdHkgPSB0aGlzLmdldChcImZpbGxPcGFjaXR5XCIsIDEpO1xyXG4gICAgICAgICAgICBpZiAoZmlsbE9wYWNpdHkpIHtcclxuICAgICAgICAgICAgICAgIHRleHRTdHlsZS5maWxsT3BhY2l0eSA9IGZpbGxPcGFjaXR5O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmlzRGlydHkoXCJtYXhXaWR0aFwiKSB8fCB0aGlzLmlzUHJpdmF0ZURpcnR5KFwibWF4V2lkdGhcIikpIHtcclxuICAgICAgICAgICAgdGV4dFN0eWxlLm1heFdpZHRoID0gdGhpcy5nZXQoXCJtYXhXaWR0aFwiLCB0aGlzLmdldFByaXZhdGUoXCJtYXhXaWR0aFwiKSk7XHJcbiAgICAgICAgICAgIHRoaXMubWFya0RpcnR5Qm91bmRzKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmlzRGlydHkoXCJtYXhIZWlnaHRcIikgfHwgdGhpcy5pc1ByaXZhdGVEaXJ0eShcIm1heEhlaWdodFwiKSkge1xyXG4gICAgICAgICAgICB0ZXh0U3R5bGUubWF4SGVpZ2h0ID0gdGhpcy5nZXQoXCJtYXhIZWlnaHRcIiwgdGhpcy5nZXRQcml2YXRlKFwibWF4SGVpZ2h0XCIpKTtcclxuICAgICAgICAgICAgdGhpcy5tYXJrRGlydHlCb3VuZHMoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgJGFycmF5LmVhY2godGhpcy5fdGV4dFN0eWxlcywgKHN0eWxlTmFtZSkgPT4ge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fZGlydHlbc3R5bGVOYW1lXSkge1xyXG4gICAgICAgICAgICAgICAgdGV4dFN0eWxlW3N0eWxlTmFtZV0gPSB0aGlzLmdldChzdHlsZU5hbWUpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5tYXJrRGlydHlCb3VuZHMoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRleHRTdHlsZVtcImZvbnRTaXplXCJdID0gdGhpcy5nZXQoXCJmb250U2l6ZVwiKTtcclxuICAgICAgICB0ZXh0U3R5bGVbXCJmb250RmFtaWx5XCJdID0gdGhpcy5nZXQoXCJmb250RmFtaWx5XCIpO1xyXG4gICAgICAgIHRoaXMuX2Rpc3BsYXkuc3R5bGUgPSB0ZXh0U3R5bGU7XHJcbiAgICAgICAgaWYgKHRoaXMuaXNEaXJ0eShcInJvbGVcIikgJiYgdGhpcy5nZXQoXCJyb2xlXCIpID09IFwidG9vbHRpcFwiKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3Jvb3QudXBkYXRlVG9vbHRpcCh0aGlzKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBfZ2V0VGV4dCgpIHtcclxuICAgICAgICBjb25zdCB0ZXh0ID0gdGhpcy5nZXQoXCJ0ZXh0XCIsIFwiXCIpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmdldChcInBvcHVsYXRlVGV4dFwiKSA/IHBvcHVsYXRlU3RyaW5nKHRoaXMsIHRleHQpIDogdGV4dDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRm9yY2VzIHRoZSB0ZXh0IHRvIGJlIHJlLWV2YWx1YXRlZCBhbmQgcmUtcG9wdWxhdGVkLlxyXG4gICAgICovXHJcbiAgICBtYXJrRGlydHlUZXh0KCkge1xyXG4gICAgICAgIHRoaXMuX2Rpc3BsYXkudGV4dCA9IHRoaXMuX2dldFRleHQoKTtcclxuICAgICAgICBpZiAodGhpcy5nZXQoXCJyb2xlXCIpID09IFwidG9vbHRpcFwiKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3Jvb3QudXBkYXRlVG9vbHRpcCh0aGlzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5tYXJrRGlydHlCb3VuZHMoKTtcclxuICAgICAgICB0aGlzLm1hcmtEaXJ0eSgpO1xyXG4gICAgfVxyXG4gICAgX3NldERhdGFJdGVtKGRhdGFJdGVtKSB7XHJcbiAgICAgICAgc3VwZXIuX3NldERhdGFJdGVtKGRhdGFJdGVtKTtcclxuICAgICAgICBpZiAodGhpcy5nZXQoXCJwb3B1bGF0ZVRleHRcIikpIHtcclxuICAgICAgICAgICAgdGhpcy5tYXJrRGlydHlUZXh0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZ2V0TnVtYmVyRm9ybWF0dGVyKCkge1xyXG4gICAgICAgIGlmICh0aGlzLnBhcmVudCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQuZ2V0TnVtYmVyRm9ybWF0dGVyKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gc3VwZXIuZ2V0TnVtYmVyRm9ybWF0dGVyKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZ2V0RGF0ZUZvcm1hdHRlcigpIHtcclxuICAgICAgICBpZiAodGhpcy5wYXJlbnQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50LmdldERhdGVGb3JtYXR0ZXIoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzdXBlci5nZXREYXRlRm9ybWF0dGVyKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZ2V0RHVyYXRpb25Gb3JtYXR0ZXIoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMucGFyZW50KSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcmVudC5nZXREdXJhdGlvbkZvcm1hdHRlcigpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHN1cGVyLmdldER1cmF0aW9uRm9ybWF0dGVyKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShUZXh0LCBcImNsYXNzTmFtZVwiLCB7XHJcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICB2YWx1ZTogXCJUZXh0XCJcclxufSk7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShUZXh0LCBcImNsYXNzTmFtZXNcIiwge1xyXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgdmFsdWU6IFNwcml0ZS5jbGFzc05hbWVzLmNvbmNhdChbVGV4dC5jbGFzc05hbWVdKVxyXG59KTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VGV4dC5qcy5tYXAiLCJpbXBvcnQgeyBMaW5lIH0gZnJvbSBcIi4vTGluZVwiO1xyXG4vKipcclxuICogRHJhd3MgYSB0aWNrIGVsZW1lbnQgKG1vc3RseSB1c2VkIG9uIGF4ZXMpLlxyXG4gKlxyXG4gKiBAc2VlIHtAbGluayBodHRwczovL3d3dy5hbWNoYXJ0cy5jb20vZG9jcy92NS9jb25jZXB0cy9jb21tb24tZWxlbWVudHMvZ3JhcGhpY3MvfSBmb3IgbW9yZSBpbmZvXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgVGljayBleHRlbmRzIExpbmUge1xyXG59XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShUaWNrLCBcImNsYXNzTmFtZVwiLCB7XHJcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICB2YWx1ZTogXCJUaWNrXCJcclxufSk7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShUaWNrLCBcImNsYXNzTmFtZXNcIiwge1xyXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgdmFsdWU6IExpbmUuY2xhc3NOYW1lcy5jb25jYXQoW1RpY2suY2xhc3NOYW1lXSlcclxufSk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVRpY2suanMubWFwIiwiaW1wb3J0IHsgTXVsdGlEaXNwb3NlciB9IGZyb20gXCIuLi91dGlsL0Rpc3Bvc2VyXCI7XHJcbmltcG9ydCB7IExhYmVsIH0gZnJvbSBcIi4uL3JlbmRlci9MYWJlbFwiO1xyXG5pbXBvcnQgeyBQb2ludGVkUmVjdGFuZ2xlIH0gZnJvbSBcIi4uL3JlbmRlci9Qb2ludGVkUmVjdGFuZ2xlXCI7XHJcbmltcG9ydCB7IENvbnRhaW5lciB9IGZyb20gXCIuL0NvbnRhaW5lclwiO1xyXG5pbXBvcnQgeyBQZXJjZW50IH0gZnJvbSBcIi4uL3V0aWwvUGVyY2VudFwiO1xyXG5pbXBvcnQgeyBDb2xvciB9IGZyb20gXCIuLi91dGlsL0NvbG9yXCI7XHJcbmltcG9ydCAqIGFzICRtYXRoIGZyb20gXCIuLi91dGlsL01hdGhcIjtcclxuaW1wb3J0ICogYXMgJGFycmF5IGZyb20gXCIuLi91dGlsL0FycmF5XCI7XHJcbmltcG9ydCAqIGFzICR1dGlscyBmcm9tIFwiLi4vdXRpbC9VdGlsc1wiO1xyXG4vKipcclxuICogQ3JlYXRlcyBhIHRvb2x0aXAuXHJcbiAqXHJcbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vd3d3LmFtY2hhcnRzLmNvbS9kb2NzL3Y1L2NvbmNlcHRzL2NvbW1vbi1lbGVtZW50cy90b29sdGlwcy99IGZvciBtb3JlIGluZm9cclxuICogQGltcG9ydGFudFxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIFRvb2x0aXAgZXh0ZW5kcyBDb250YWluZXIge1xyXG4gICAgY29uc3RydWN0b3Iocm9vdCwgc2V0dGluZ3MsIGlzUmVhbCwgdGVtcGxhdGVzID0gW10pIHtcclxuICAgICAgICBzdXBlcihyb290LCBzZXR0aW5ncywgaXNSZWFsLCB0ZW1wbGF0ZXMpO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9meFwiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiAwXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX2Z5XCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IDBcclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfbGFiZWxcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX2ZpbGxEcFwiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfc3Ryb2tlRHBcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX2xhYmVsRHBcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX3dcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogMFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9oXCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IDBcclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfa2VlcEhvdmVyRHBcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX2h0bWxDb250ZW50SG92ZXJlZFwiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiBmYWxzZVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgX2FmdGVyTmV3KCkge1xyXG4gICAgICAgIHRoaXMuX3NldHRpbmdzLnRoZW1lVGFncyA9ICR1dGlscy5tZXJnZVRhZ3ModGhpcy5fc2V0dGluZ3MudGhlbWVUYWdzLCBbXCJ0b29sdGlwXCJdKTtcclxuICAgICAgICBzdXBlci5fYWZ0ZXJOZXcoKTtcclxuICAgICAgICB0aGlzLnNldChcImJhY2tncm91bmRcIiwgUG9pbnRlZFJlY3RhbmdsZS5uZXcodGhpcy5fcm9vdCwge1xyXG4gICAgICAgICAgICB0aGVtZVRhZ3M6IFtcInRvb2x0aXBcIiwgXCJiYWNrZ3JvdW5kXCJdXHJcbiAgICAgICAgfSkpO1xyXG4gICAgICAgIHRoaXMuX2xhYmVsID0gdGhpcy5jaGlsZHJlbi5wdXNoKExhYmVsLm5ldyh0aGlzLl9yb290LCB7fSkpO1xyXG4gICAgICAgIHRoaXMuX2Rpc3Bvc2Vycy5wdXNoKHRoaXMuX2xhYmVsLmV2ZW50cy5vbihcImJvdW5kc2NoYW5nZWRcIiwgKCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLl91cGRhdGVCYWNrZ3JvdW5kKCk7XHJcbiAgICAgICAgfSkpO1xyXG4gICAgICAgIHRoaXMuX2Rpc3Bvc2Vycy5wdXNoKHRoaXMub24oXCJib3VuZHNcIiwgKCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLl91cGRhdGVCYWNrZ3JvdW5kKCk7XHJcbiAgICAgICAgfSkpO1xyXG4gICAgICAgIHRoaXMuX3VwZGF0ZVRleHRDb2xvcigpO1xyXG4gICAgICAgIHRoaXMuX3Jvb3QudG9vbHRpcENvbnRhaW5lci5jaGlsZHJlbi5wdXNoKHRoaXMpO1xyXG4gICAgICAgIHRoaXMuaGlkZSgwKTtcclxuICAgICAgICB0aGlzLl9kaXNwb3NlcnMucHVzaCh0aGlzLmxhYmVsLm9uUHJpdmF0ZShcImh0bWxFbGVtZW50XCIsIChodG1sRWxlbWVudCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoaHRtbEVsZW1lbnQpIHtcclxuICAgICAgICAgICAgICAgICR1dGlscy5hZGRFdmVudExpc3RlbmVyKGh0bWxFbGVtZW50LCBcInBvaW50ZXJvdmVyXCIsIChfZXYpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9odG1sQ29udGVudEhvdmVyZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAkdXRpbHMuYWRkRXZlbnRMaXN0ZW5lcihodG1sRWxlbWVudCwgXCJwb2ludGVyb3V0XCIsIChfZXYpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9odG1sQ29udGVudEhvdmVyZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSkpO1xyXG4gICAgICAgIHRoaXMuX3Jvb3QuX3Rvb2x0aXBzLnB1c2godGhpcyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEEgW1tMYWJlbF1dIGVsZW1lbnQgZm9yIHRoZSB0b29sdGlwLlxyXG4gICAgICpcclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICogQHJldHVybiBMYWJlbFxyXG4gICAgICovXHJcbiAgICBnZXQgbGFiZWwoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xhYmVsO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBQZXJtYW5lbnRseSBkaXNwb3NlcyB0aGUgdG9vbHRpcC5cclxuICAgICAqL1xyXG4gICAgZGlzcG9zZSgpIHtcclxuICAgICAgICBzdXBlci5kaXNwb3NlKCk7XHJcbiAgICAgICAgJGFycmF5LnJlbW92ZSh0aGlzLl9yb290Ll90b29sdGlwcywgdGhpcyk7XHJcbiAgICB9XHJcbiAgICBfdXBkYXRlQ2hpbGRyZW4oKSB7XHJcbiAgICAgICAgc3VwZXIuX3VwZGF0ZUNoaWxkcmVuKCk7XHJcbiAgICAgICAgaWYgKHRoaXMuaXNEaXJ0eShcInBvaW50ZXJPcmllbnRhdGlvblwiKSB8fCB0aGlzLmlzUHJpdmF0ZURpcnR5KFwibWluV2lkdGhcIikgfHwgdGhpcy5pc1ByaXZhdGVEaXJ0eShcIm1pbkhlaWdodFwiKSkge1xyXG4gICAgICAgICAgICB0aGlzLmdldChcImJhY2tncm91bmRcIikuX21hcmtEaXJ0eUtleShcIndpZHRoXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBsYWJlbFRleHQgPSB0aGlzLmdldChcImxhYmVsVGV4dFwiKTtcclxuICAgICAgICBpZiAobGFiZWxUZXh0ICE9IG51bGwpIHtcclxuICAgICAgICAgICAgdGhpcy5sYWJlbC5zZXQoXCJ0ZXh0XCIsIHRoaXMuZ2V0KFwibGFiZWxUZXh0XCIpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgbGFiZWxIVE1MID0gdGhpcy5nZXQoXCJsYWJlbEhUTUxcIik7XHJcbiAgICAgICAgaWYgKGxhYmVsSFRNTCAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMubGFiZWwuc2V0KFwiaHRtbFwiLCB0aGlzLmdldChcImxhYmVsSFRNTFwiKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgX2NoYW5nZWQoKSB7XHJcbiAgICAgICAgc3VwZXIuX2NoYW5nZWQoKTtcclxuICAgICAgICBpZiAodGhpcy5pc0RpcnR5KFwicG9pbnRUb1wiKSB8fCB0aGlzLmlzRGlydHkoXCJwb2ludGVyT3JpZW50YXRpb25cIikpIHtcclxuICAgICAgICAgICAgLy8gY2FuJ3QgY29tcGFyZSB0byBwcmV2aW91cywgYXMgc29tZXRpbWVzIHBvaW50VG8gaXMgc2V0IHR3aWNlICh3aGVuIHBvaW50ZXIgbW92ZXMsIHNvIHRoZSBwb3NpdGlvbiB3b24ndCBiZSB1ZHBhdGVkKVxyXG4gICAgICAgICAgICB0aGlzLl91cGRhdGVCYWNrZ3JvdW5kKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmlzRGlydHkoXCJ0b29sdGlwVGFyZ2V0XCIpKSB7XHJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlQmFja2dyb3VuZENvbG9yKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmlzRGlydHkoXCJrZWVwVGFyZ2V0SG92ZXJcIikpIHtcclxuICAgICAgICAgICAgY29uc3Qga2VlcGhvdmVyID0gdGhpcy5nZXQoXCJrZWVwVGFyZ2V0SG92ZXJcIik7XHJcbiAgICAgICAgICAgIGlmIChrZWVwaG92ZXIpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGJnID0gdGhpcy5nZXQoXCJiYWNrZ3JvdW5kXCIpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fa2VlcEhvdmVyRHAgPSBuZXcgTXVsdGlEaXNwb3NlcihbXHJcbiAgICAgICAgICAgICAgICAgICAgYmcuZXZlbnRzLm9uKFwicG9pbnRlcm92ZXJcIiwgKF9ldikgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgdGFyZ2V0ID0gdGhpcy5nZXQoXCJ0b29sdGlwVGFyZ2V0XCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGFyZ2V0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGFyZ2V0LnBhcmVudCAmJiB0YXJnZXQucGFyZW50LmdldFByaXZhdGUoXCJ0b29sdGlwVGFyZ2V0XCIpID09IHRhcmdldCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldCA9IHRhcmdldC5wYXJlbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQuaG92ZXIoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0pLFxyXG4gICAgICAgICAgICAgICAgICAgIGJnLmV2ZW50cy5vbihcInBvaW50ZXJvdXRcIiwgKF9ldikgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgdGFyZ2V0ID0gdGhpcy5nZXQoXCJ0b29sdGlwVGFyZ2V0XCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGFyZ2V0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGFyZ2V0LnBhcmVudCAmJiB0YXJnZXQucGFyZW50LmdldFByaXZhdGUoXCJ0b29sdGlwVGFyZ2V0XCIpID09IHRhcmdldCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldCA9IHRhcmdldC5wYXJlbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX2h0bWxDb250ZW50SG92ZXJlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldC51bmhvdmVyKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgXSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxhYmVsLm9uUHJpdmF0ZShcImh0bWxFbGVtZW50XCIsIChodG1sRWxlbWVudCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9rZWVwSG92ZXJEcCAmJiBodG1sRWxlbWVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9rZWVwSG92ZXJEcC5kaXNwb3NlcnMucHVzaCgkdXRpbHMuYWRkRXZlbnRMaXN0ZW5lcihodG1sRWxlbWVudCwgXCJwb2ludGVybGVhdmVcIiwgKGV2KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBvdXRFdmVudCA9IHRoaXMucm9vdC5fcmVuZGVyZXIuZ2V0RXZlbnQoZXYpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmcuZXZlbnRzLmRpc3BhdGNoKFwicG9pbnRlcm91dFwiLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJwb2ludGVyb3V0XCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxFdmVudDogb3V0RXZlbnQuZXZlbnQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnQ6IG91dEV2ZW50LnBvaW50LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpbXVsYXRlZDogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0OiBiZ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9rZWVwSG92ZXJEcCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2tlZXBIb3ZlckRwLmRpc3Bvc2UoKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9rZWVwSG92ZXJEcCA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIF9vblNob3coKSB7XHJcbiAgICAgICAgc3VwZXIuX29uU2hvdygpO1xyXG4gICAgICAgIHRoaXMudXBkYXRlQmFja2dyb3VuZENvbG9yKCk7XHJcbiAgICB9XHJcbiAgICB1cGRhdGVCYWNrZ3JvdW5kQ29sb3IoKSB7XHJcbiAgICAgICAgbGV0IHRvb2x0aXBUYXJnZXQgPSB0aGlzLmdldChcInRvb2x0aXBUYXJnZXRcIik7XHJcbiAgICAgICAgY29uc3QgYmFja2dyb3VuZCA9IHRoaXMuZ2V0KFwiYmFja2dyb3VuZFwiKTtcclxuICAgICAgICBsZXQgZmlsbDtcclxuICAgICAgICBsZXQgc3Ryb2tlO1xyXG4gICAgICAgIGlmICh0b29sdGlwVGFyZ2V0ICYmIGJhY2tncm91bmQpIHtcclxuICAgICAgICAgICAgZmlsbCA9IHRvb2x0aXBUYXJnZXQuZ2V0KFwiZmlsbFwiKTtcclxuICAgICAgICAgICAgc3Ryb2tlID0gdG9vbHRpcFRhcmdldC5nZXQoXCJzdHJva2VcIik7XHJcbiAgICAgICAgICAgIGlmIChmaWxsID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIGZpbGwgPSBzdHJva2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRoaXMuZ2V0KFwiZ2V0RmlsbEZyb21TcHJpdGVcIikpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9maWxsRHApIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9maWxsRHAuZGlzcG9zZSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGZpbGwgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGJhY2tncm91bmQuc2V0KFwiZmlsbFwiLCBmaWxsKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuX2ZpbGxEcCA9IHRvb2x0aXBUYXJnZXQub24oXCJmaWxsXCIsIChmaWxsKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpbGwgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kLnNldChcImZpbGxcIiwgZmlsbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3VwZGF0ZVRleHRDb2xvcihmaWxsKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2Rpc3Bvc2Vycy5wdXNoKHRoaXMuX2ZpbGxEcCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRoaXMuZ2V0KFwiZ2V0U3Ryb2tlRnJvbVNwcml0ZVwiKSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3N0cm9rZURwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3Ryb2tlRHAuZGlzcG9zZSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGZpbGwgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGJhY2tncm91bmQuc2V0KFwic3Ryb2tlXCIsIGZpbGwpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5fc3Ryb2tlRHAgPSB0b29sdGlwVGFyZ2V0Lm9uKFwiZmlsbFwiLCAoZmlsbCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChmaWxsICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYmFja2dyb3VuZC5zZXQoXCJzdHJva2VcIiwgZmlsbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9kaXNwb3NlcnMucHVzaCh0aGlzLl9zdHJva2VEcCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRoaXMuZ2V0KFwiZ2V0TGFiZWxGaWxsRnJvbVNwcml0ZVwiKSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2xhYmVsRHApIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9sYWJlbERwLmRpc3Bvc2UoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChmaWxsICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmxhYmVsLnNldChcImZpbGxcIiwgZmlsbCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9sYWJlbERwID0gdG9vbHRpcFRhcmdldC5vbihcImZpbGxcIiwgKGZpbGwpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZmlsbCAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubGFiZWwuc2V0KFwiZmlsbFwiLCBmaWxsKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2Rpc3Bvc2Vycy5wdXNoKHRoaXMuX2xhYmVsRHApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX3VwZGF0ZVRleHRDb2xvcihmaWxsKTtcclxuICAgIH1cclxuICAgIF91cGRhdGVUZXh0Q29sb3IoZmlsbCkge1xyXG4gICAgICAgIGlmICh0aGlzLmdldChcImF1dG9UZXh0Q29sb3JcIikpIHtcclxuICAgICAgICAgICAgaWYgKGZpbGwgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgZmlsbCA9IHRoaXMuZ2V0KFwiYmFja2dyb3VuZFwiKS5nZXQoXCJmaWxsXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChmaWxsID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIGZpbGwgPSB0aGlzLl9yb290LmludGVyZmFjZUNvbG9ycy5nZXQoXCJiYWNrZ3JvdW5kXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChmaWxsIGluc3RhbmNlb2YgQ29sb3IpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubGFiZWwuc2V0KFwiZmlsbFwiLCBDb2xvci5hbHRlcm5hdGl2ZShmaWxsLCB0aGlzLl9yb290LmludGVyZmFjZUNvbG9ycy5nZXQoXCJhbHRlcm5hdGl2ZVRleHRcIiksIHRoaXMuX3Jvb3QuaW50ZXJmYWNlQ29sb3JzLmdldChcInRleHRcIikpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIF9zZXREYXRhSXRlbShkYXRhSXRlbSkge1xyXG4gICAgICAgIHN1cGVyLl9zZXREYXRhSXRlbShkYXRhSXRlbSk7XHJcbiAgICAgICAgdGhpcy5sYWJlbC5fc2V0RGF0YUl0ZW0oZGF0YUl0ZW0pO1xyXG4gICAgfVxyXG4gICAgX3VwZGF0ZUJhY2tncm91bmQoKSB7XHJcbiAgICAgICAgc3VwZXIudXBkYXRlQmFja2dyb3VuZCgpO1xyXG4gICAgICAgIGNvbnN0IHBhcmVudCA9IHRoaXMuX3Jvb3QuY29udGFpbmVyO1xyXG4gICAgICAgIGlmIChwYXJlbnQpIHtcclxuICAgICAgICAgICAgbGV0IGN3ID0gMC41O1xyXG4gICAgICAgICAgICBsZXQgY2ggPSAwLjU7XHJcbiAgICAgICAgICAgIGxldCBjZW50ZXJYID0gdGhpcy5nZXQoXCJjZW50ZXJYXCIpO1xyXG4gICAgICAgICAgICBpZiAoY2VudGVyWCBpbnN0YW5jZW9mIFBlcmNlbnQpIHtcclxuICAgICAgICAgICAgICAgIGN3ID0gY2VudGVyWC52YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsZXQgY2VudGVyWSA9IHRoaXMuZ2V0KFwiY2VudGVyWVwiKTtcclxuICAgICAgICAgICAgaWYgKGNlbnRlclkgaW5zdGFuY2VvZiBQZXJjZW50KSB7XHJcbiAgICAgICAgICAgICAgICBjaCA9IGNlbnRlclkudmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGV0IHBhcmVudFcgPSBwYXJlbnQud2lkdGgoKTtcclxuICAgICAgICAgICAgbGV0IHBhcmVudEggPSBwYXJlbnQuaGVpZ2h0KCk7XHJcbiAgICAgICAgICAgIGxldCB0b29sdGlwQ29udGFpbmVyID0gdGhpcy5wYXJlbnQ7XHJcbiAgICAgICAgICAgIGxldCB4eCA9IDA7XHJcbiAgICAgICAgICAgIGxldCB5eSA9IDA7XHJcbiAgICAgICAgICAgIGlmICh0b29sdGlwQ29udGFpbmVyKSB7XHJcbiAgICAgICAgICAgICAgICB4eCA9IHRvb2x0aXBDb250YWluZXIueCgpO1xyXG4gICAgICAgICAgICAgICAgeXkgPSB0b29sdGlwQ29udGFpbmVyLnkoKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGxheWVyTWFyZ2luID0gdG9vbHRpcENvbnRhaW5lci5nZXQoXCJsYXllck1hcmdpblwiKTtcclxuICAgICAgICAgICAgICAgIGlmIChsYXllck1hcmdpbikge1xyXG4gICAgICAgICAgICAgICAgICAgIHh4ICs9IGxheWVyTWFyZ2luLmxlZnQgfHwgMDtcclxuICAgICAgICAgICAgICAgICAgICB5eSArPSBsYXllck1hcmdpbi50b3AgfHwgMDtcclxuICAgICAgICAgICAgICAgICAgICBwYXJlbnRXICs9IChsYXllck1hcmdpbi5sZWZ0IHx8IDApICsgKGxheWVyTWFyZ2luLnJpZ2h0IHx8IDApO1xyXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudEggKz0gKGxheWVyTWFyZ2luLnRvcCB8fCAwKSArIChsYXllck1hcmdpbi5ib3R0b20gfHwgMCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgYm91bmRzID0gdGhpcy5nZXQoXCJib3VuZHNcIiwgeyBsZWZ0OiAteHgsIHRvcDogLXl5LCByaWdodDogcGFyZW50VyAtIHh4LCBib3R0b206IHBhcmVudEggLSB5eSB9KTtcclxuICAgICAgICAgICAgdGhpcy5fdXBkYXRlQm91bmRzKCk7XHJcbiAgICAgICAgICAgIGxldCB3ID0gdGhpcy53aWR0aCgpO1xyXG4gICAgICAgICAgICBsZXQgaCA9IHRoaXMuaGVpZ2h0KCk7XHJcbiAgICAgICAgICAgIC8vIHVzZSBvbGQgdyBhbmQgaCxhcyB3aGVuIHRvb2x0aXAgaXMgaGlkZGVuLCB0aGVzZSBhcmUgMCBhbmQgdW5uZWVkZWQgYW5pbWF0aW9uIGhhcHBlbnNcclxuICAgICAgICAgICAgaWYgKHcgPT09IDApIHtcclxuICAgICAgICAgICAgICAgIHcgPSB0aGlzLl93O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChoID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBoID0gdGhpcy5faDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsZXQgcG9pbnRUbyA9IHRoaXMuZ2V0KFwicG9pbnRUb1wiLCB7IHg6IHBhcmVudFcgLyAyLCB5OiBwYXJlbnRIIC8gMiB9KTtcclxuICAgICAgICAgICAgbGV0IHggPSBwb2ludFRvLng7XHJcbiAgICAgICAgICAgIGxldCB5ID0gcG9pbnRUby55O1xyXG4gICAgICAgICAgICBsZXQgcG9pbnRlck9yaWVudGF0aW9uID0gdGhpcy5nZXQoXCJwb2ludGVyT3JpZW50YXRpb25cIik7XHJcbiAgICAgICAgICAgIGxldCBiYWNrZ3JvdW5kID0gdGhpcy5nZXQoXCJiYWNrZ3JvdW5kXCIpO1xyXG4gICAgICAgICAgICBsZXQgcG9pbnRlckxlbmd0aCA9IDA7XHJcbiAgICAgICAgICAgIGxldCBiZ1N0cm9rZVNpemVZID0gMDtcclxuICAgICAgICAgICAgbGV0IGJnU3Ryb2tlU2l6ZVggPSAwO1xyXG4gICAgICAgICAgICBpZiAoYmFja2dyb3VuZCBpbnN0YW5jZW9mIFBvaW50ZWRSZWN0YW5nbGUpIHtcclxuICAgICAgICAgICAgICAgIHBvaW50ZXJMZW5ndGggPSBiYWNrZ3JvdW5kLmdldChcInBvaW50ZXJMZW5ndGhcIiwgMCk7XHJcbiAgICAgICAgICAgICAgICBiZ1N0cm9rZVNpemVZID0gYmFja2dyb3VuZC5nZXQoXCJzdHJva2VXaWR0aFwiLCAwKSAvIDI7XHJcbiAgICAgICAgICAgICAgICBiZ1N0cm9rZVNpemVYID0gYmdTdHJva2VTaXplWTtcclxuICAgICAgICAgICAgICAgIGJhY2tncm91bmQuc2V0KFwid2lkdGhcIiwgdyk7XHJcbiAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kLnNldChcImhlaWdodFwiLCBoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsZXQgcG9pbnRlclggPSAwO1xyXG4gICAgICAgICAgICBsZXQgcG9pbnRlclkgPSAwO1xyXG4gICAgICAgICAgICBsZXQgYm91bmRzVyA9IGJvdW5kcy5yaWdodCAtIGJvdW5kcy5sZWZ0O1xyXG4gICAgICAgICAgICBsZXQgYm91bmRzSCA9IGJvdW5kcy5ib3R0b20gLSBib3VuZHMudG9wO1xyXG4gICAgICAgICAgICAvLyBob3Jpem9udGFsXHJcbiAgICAgICAgICAgIGlmIChwb2ludGVyT3JpZW50YXRpb24gPT0gXCJob3Jpem9udGFsXCIgfHwgcG9pbnRlck9yaWVudGF0aW9uID09IFwibGVmdFwiIHx8IHBvaW50ZXJPcmllbnRhdGlvbiA9PSBcInJpZ2h0XCIpIHtcclxuICAgICAgICAgICAgICAgIGJnU3Ryb2tlU2l6ZVkgPSAwO1xyXG4gICAgICAgICAgICAgICAgaWYgKHBvaW50ZXJPcmllbnRhdGlvbiA9PSBcImhvcml6b250YWxcIikge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh4ID4gYm91bmRzLmxlZnQgKyBib3VuZHNXIC8gMikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB4IC09ICh3ICogKDEgLSBjdykgKyBwb2ludGVyTGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYmdTdHJva2VTaXplWCAqPSAtMTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHggKz0gKHcgKiBjdyArIHBvaW50ZXJMZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHBvaW50ZXJPcmllbnRhdGlvbiA9PSBcImxlZnRcIikge1xyXG4gICAgICAgICAgICAgICAgICAgIHggKz0gKHcgKiAoMSAtIGN3KSArIHBvaW50ZXJMZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgeCAtPSAodyAqIGN3ICsgcG9pbnRlckxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYmdTdHJva2VTaXplWCAqPSAtMTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyB2ZXJ0aWNhbCBwb2ludGVyXHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgYmdTdHJva2VTaXplWCA9IDA7XHJcbiAgICAgICAgICAgICAgICBpZiAocG9pbnRlck9yaWVudGF0aW9uID09IFwidmVydGljYWxcIikge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh5ID4gYm91bmRzLnRvcCArIGggLyAyICsgcG9pbnRlckxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB5IC09IChoICogKDEgLSBjaCkgKyBwb2ludGVyTGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHkgKz0gKGggKiBjaCArIHBvaW50ZXJMZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBiZ1N0cm9rZVNpemVZICo9IC0xO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHBvaW50ZXJPcmllbnRhdGlvbiA9PSBcImRvd25cIikge1xyXG4gICAgICAgICAgICAgICAgICAgIHkgLT0gKGggKiAoMSAtIGNoKSArIHBvaW50ZXJMZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgeSArPSAoaCAqIGNoICsgcG9pbnRlckxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYmdTdHJva2VTaXplWSAqPSAtMTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB4ID0gJG1hdGguZml0VG9SYW5nZSh4LCBib3VuZHMubGVmdCArIHcgKiBjdywgYm91bmRzLmxlZnQgKyBib3VuZHNXIC0gdyAqICgxIC0gY3cpKSArIGJnU3Ryb2tlU2l6ZVg7XHJcbiAgICAgICAgICAgIHkgPSAkbWF0aC5maXRUb1JhbmdlKHksIGJvdW5kcy50b3AgKyBoICogY2gsIGJvdW5kcy50b3AgKyBib3VuZHNIIC0gaCAqICgxIC0gY2gpKSAtIGJnU3Ryb2tlU2l6ZVk7XHJcbiAgICAgICAgICAgIHBvaW50ZXJYID0gcG9pbnRUby54IC0geCArIHcgKiBjdyArIGJnU3Ryb2tlU2l6ZVg7XHJcbiAgICAgICAgICAgIHBvaW50ZXJZID0gcG9pbnRUby55IC0geSArIGggKiBjaCAtIGJnU3Ryb2tlU2l6ZVk7XHJcbiAgICAgICAgICAgIHRoaXMuX2Z4ID0geDtcclxuICAgICAgICAgICAgdGhpcy5fZnkgPSB5O1xyXG4gICAgICAgICAgICBjb25zdCBhbmltYXRpb25EdXJhdGlvbiA9IHRoaXMuZ2V0KFwiYW5pbWF0aW9uRHVyYXRpb25cIiwgMCk7XHJcbiAgICAgICAgICAgIGlmIChhbmltYXRpb25EdXJhdGlvbiA+IDAgJiYgdGhpcy5nZXQoXCJ2aXNpYmxlXCIpICYmIHRoaXMuZ2V0KFwib3BhY2l0eVwiKSA+IDAuMSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYW5pbWF0aW9uRWFzaW5nID0gdGhpcy5nZXQoXCJhbmltYXRpb25FYXNpbmdcIik7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFuaW1hdGUoeyBrZXk6IFwieFwiLCB0bzogeCwgZHVyYXRpb246IGFuaW1hdGlvbkR1cmF0aW9uLCBlYXNpbmc6IGFuaW1hdGlvbkVhc2luZyB9KTtcclxuICAgICAgICAgICAgICAgIHRoaXMuYW5pbWF0ZSh7IGtleTogXCJ5XCIsIHRvOiB5LCBkdXJhdGlvbjogYW5pbWF0aW9uRHVyYXRpb24sIGVhc2luZzogYW5pbWF0aW9uRWFzaW5nIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZXQoXCJ4XCIsIHgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZXQoXCJ5XCIsIHkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChiYWNrZ3JvdW5kIGluc3RhbmNlb2YgUG9pbnRlZFJlY3RhbmdsZSkge1xyXG4gICAgICAgICAgICAgICAgYmFja2dyb3VuZC5zZXQoXCJwb2ludGVyWFwiLCBwb2ludGVyWCk7XHJcbiAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kLnNldChcInBvaW50ZXJZXCIsIHBvaW50ZXJZKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodyA+IDApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3cgPSB3O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5faCA9IGg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvb2x0aXAsIFwiY2xhc3NOYW1lXCIsIHtcclxuICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgIHZhbHVlOiBcIlRvb2x0aXBcIlxyXG59KTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvb2x0aXAsIFwiY2xhc3NOYW1lc1wiLCB7XHJcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICB2YWx1ZTogQ29udGFpbmVyLmNsYXNzTmFtZXMuY29uY2F0KFtUb29sdGlwLmNsYXNzTmFtZV0pXHJcbn0pO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1Ub29sdGlwLmpzLm1hcCIsImltcG9ydCB7IEdyYXBoaWNzIH0gZnJvbSBcIi4vR3JhcGhpY3NcIjtcclxuLyoqXHJcbiAqIERyYXdzIGEgdHJpYW5nbGUuXHJcbiAqXHJcbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vd3d3LmFtY2hhcnRzLmNvbS9kb2NzL3Y1L2NvbmNlcHRzL2NvbW1vbi1lbGVtZW50cy9ncmFwaGljcy99IGZvciBtb3JlIGluZm9cclxuICogQGltcG9ydGFudFxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIFRyaWFuZ2xlIGV4dGVuZHMgR3JhcGhpY3Mge1xyXG4gICAgX2JlZm9yZUNoYW5nZWQoKSB7XHJcbiAgICAgICAgc3VwZXIuX2JlZm9yZUNoYW5nZWQoKTtcclxuICAgICAgICBpZiAodGhpcy5pc0RpcnR5KFwid2lkdGhcIikgfHwgdGhpcy5pc0RpcnR5KFwiaGVpZ2h0XCIpIHx8IHRoaXMuaXNQcml2YXRlRGlydHkoXCJ3aWR0aFwiKSB8fCB0aGlzLmlzUHJpdmF0ZURpcnR5KFwiaGVpZ2h0XCIpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2NsZWFyID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBfY2hhbmdlZCgpIHtcclxuICAgICAgICBzdXBlci5fY2hhbmdlZCgpO1xyXG4gICAgICAgIGlmICh0aGlzLl9jbGVhciAmJiAhdGhpcy5nZXQoXCJkcmF3XCIpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2RyYXcoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBfZHJhdygpIHtcclxuICAgICAgICBjb25zdCB3ID0gdGhpcy53aWR0aCgpO1xyXG4gICAgICAgIGNvbnN0IGggPSB0aGlzLmhlaWdodCgpO1xyXG4gICAgICAgIGNvbnN0IGRpc3BsYXkgPSB0aGlzLl9kaXNwbGF5O1xyXG4gICAgICAgIGRpc3BsYXkubW92ZVRvKC13IC8gMiwgaCAvIDIpO1xyXG4gICAgICAgIGRpc3BsYXkubGluZVRvKDAsIC1oIC8gMik7XHJcbiAgICAgICAgZGlzcGxheS5saW5lVG8odyAvIDIsIGggLyAyKTtcclxuICAgICAgICBkaXNwbGF5LmxpbmVUbygtdyAvIDIsIGggLyAyKTtcclxuICAgICAgICBkaXNwbGF5LmNsb3NlUGF0aCgpO1xyXG4gICAgfVxyXG4gICAgX3VwZGF0ZVNpemUoKSB7XHJcbiAgICAgICAgdGhpcy5tYXJrRGlydHkoKTtcclxuICAgICAgICB0aGlzLl9jbGVhciA9IHRydWU7XHJcbiAgICB9XHJcbn1cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFRyaWFuZ2xlLCBcImNsYXNzTmFtZVwiLCB7XHJcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICB2YWx1ZTogXCJUcmlhbmdsZVwiXHJcbn0pO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoVHJpYW5nbGUsIFwiY2xhc3NOYW1lc1wiLCB7XHJcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICB2YWx1ZTogR3JhcGhpY3MuY2xhc3NOYW1lcy5jb25jYXQoW1RyaWFuZ2xlLmNsYXNzTmFtZV0pXHJcbn0pO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1UcmlhbmdsZS5qcy5tYXAiLCJpbXBvcnQgeyBMYXlvdXQsIGVhY2hDaGlsZHJlbiB9IGZyb20gXCIuL0xheW91dFwiO1xyXG5pbXBvcnQgKiBhcyAkdHlwZSBmcm9tIFwiLi4vdXRpbC9UeXBlXCI7XHJcbmltcG9ydCB7IFBlcmNlbnQgfSBmcm9tIFwiLi4vdXRpbC9QZXJjZW50XCI7XHJcbi8qKlxyXG4gKiBBIHZlcnRpY2FsIGNoaWxkcmVuIGxheW91dCBmb3IgW1tDb250YWluZXJdXS5cclxuICpcclxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly93d3cuYW1jaGFydHMuY29tL2RvY3MvdjUvY29uY2VwdHMvY29tbW9uLWVsZW1lbnRzL2NvbnRhaW5lcnMvI0xheW91dH0gZm9yIG1vcmUgaW5mb1xyXG4gKi9cclxuZXhwb3J0IGNsYXNzIFZlcnRpY2FsTGF5b3V0IGV4dGVuZHMgTGF5b3V0IHtcclxuICAgIC8qKlxyXG4gICAgICogQGlnbm9yZVxyXG4gICAgICovXHJcbiAgICB1cGRhdGVDb250YWluZXIoY29udGFpbmVyKSB7XHJcbiAgICAgICAgbGV0IHBhZGRpbmdUb3AgPSBjb250YWluZXIuZ2V0KFwicGFkZGluZ1RvcFwiLCAwKTtcclxuICAgICAgICBsZXQgYXZhaWxhYmxlSGVpZ2h0ID0gY29udGFpbmVyLmlubmVySGVpZ2h0KCk7XHJcbiAgICAgICAgbGV0IHRvdGFsUGVyY2VudCA9IDA7XHJcbiAgICAgICAgZWFjaENoaWxkcmVuKGNvbnRhaW5lciwgKGNoaWxkKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChjaGlsZC5pc1Zpc2libGUoKSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkLmdldChcInBvc2l0aW9uXCIpID09IFwicmVsYXRpdmVcIikge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBjaGlsZEhlaWdodCA9IGNoaWxkLmdldChcImhlaWdodFwiKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGRIZWlnaHQgaW5zdGFuY2VvZiBQZXJjZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvdGFsUGVyY2VudCArPSBjaGlsZEhlaWdodC52YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGggPSBhdmFpbGFibGVIZWlnaHQgKiBjaGlsZEhlaWdodC52YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG1pbkhlaWdodCA9IGNoaWxkLmdldChcIm1pbkhlaWdodFwiLCBjaGlsZC5nZXRQcml2YXRlKFwibWluSGVpZ2h0XCIsIC1JbmZpbml0eSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWluSGVpZ2h0ID4gaCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXZhaWxhYmxlSGVpZ2h0IC09IG1pbkhlaWdodDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvdGFsUGVyY2VudCAtPSBjaGlsZEhlaWdodC52YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgbWF4SGVpZ2h0ID0gY2hpbGQuZ2V0KFwibWF4SGVpZ2h0XCIsIGNoaWxkLmdldFByaXZhdGUoXCJtYXhIZWlnaHRcIiwgSW5maW5pdHkpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGggPiBtYXhIZWlnaHQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF2YWlsYWJsZUhlaWdodCAtPSBtYXhIZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b3RhbFBlcmNlbnQgLT0gY2hpbGRIZWlnaHQudmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghJHR5cGUuaXNOdW1iZXIoY2hpbGRIZWlnaHQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZEhlaWdodCA9IGNoaWxkLmhlaWdodCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGF2YWlsYWJsZUhlaWdodCAtPSBjaGlsZEhlaWdodCArIGNoaWxkLmdldChcIm1hcmdpblRvcFwiLCAwKSArIGNoaWxkLmdldChcIm1hcmdpbkJvdHRvbVwiLCAwKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICBpZiAoYXZhaWxhYmxlSGVpZ2h0IDw9IDAgfHwgYXZhaWxhYmxlSGVpZ2h0ID09IEluZmluaXR5KSB7XHJcbiAgICAgICAgICAgIGF2YWlsYWJsZUhlaWdodCA9IC4xO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvL2lmIChhdmFpbGFibGVIZWlnaHQgPiAwKSB7XHJcbiAgICAgICAgZWFjaENoaWxkcmVuKGNvbnRhaW5lciwgKGNoaWxkKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChjaGlsZC5pc1Zpc2libGUoKSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkLmdldChcInBvc2l0aW9uXCIpID09IFwicmVsYXRpdmVcIikge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBjaGlsZEhlaWdodCA9IGNoaWxkLmdldChcImhlaWdodFwiKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGRIZWlnaHQgaW5zdGFuY2VvZiBQZXJjZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBwcml2YXRlSGVpZ2h0ID0gYXZhaWxhYmxlSGVpZ2h0ICogY2hpbGRIZWlnaHQudmFsdWUgLyB0b3RhbFBlcmNlbnQgLSBjaGlsZC5nZXQoXCJtYXJnaW5Ub3BcIiwgMCkgLSBjaGlsZC5nZXQoXCJtYXJnaW5Cb3R0b21cIiwgMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBtaW5IZWlnaHQgPSBjaGlsZC5nZXQoXCJtaW5IZWlnaHRcIiwgY2hpbGQuZ2V0UHJpdmF0ZShcIm1pbkhlaWdodFwiLCAtSW5maW5pdHkpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG1heEhlaWdodCA9IGNoaWxkLmdldChcIm1heEhlaWdodFwiLCBjaGlsZC5nZXRQcml2YXRlKFwibWF4SGVpZ2h0XCIsIEluZmluaXR5KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHByaXZhdGVIZWlnaHQgPSBNYXRoLm1pbihNYXRoLm1heChtaW5IZWlnaHQsIHByaXZhdGVIZWlnaHQpLCBtYXhIZWlnaHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZC5zZXRQcml2YXRlKFwiaGVpZ2h0XCIsIHByaXZhdGVIZWlnaHQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkLl9wcmV2U2V0dGluZ3MuaGVpZ2h0IGluc3RhbmNlb2YgUGVyY2VudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGQuc2V0UHJpdmF0ZShcImhlaWdodFwiLCB1bmRlZmluZWQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLy99XHJcbiAgICAgICAgbGV0IHByZXZZID0gcGFkZGluZ1RvcDtcclxuICAgICAgICBlYWNoQ2hpbGRyZW4oY29udGFpbmVyLCAoY2hpbGQpID0+IHtcclxuICAgICAgICAgICAgaWYgKGNoaWxkLmdldChcInBvc2l0aW9uXCIpID09IFwicmVsYXRpdmVcIikge1xyXG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkLmlzVmlzaWJsZSgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGJvdW5kcyA9IGNoaWxkLmFkanVzdGVkTG9jYWxCb3VuZHMoKTtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgbWFyZ2luVG9wID0gY2hpbGQuZ2V0KFwibWFyZ2luVG9wXCIsIDApO1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCB0b3AgPSBib3VuZHMudG9wO1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBib3R0b20gPSBib3VuZHMuYm90dG9tO1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBtYXhIZWlnaHQgPSBjaGlsZC5nZXQoXCJtYXhIZWlnaHRcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1heEhlaWdodCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYm90dG9tIC0gdG9wID4gbWF4SGVpZ2h0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBib3R0b20gPSB0b3AgKyBtYXhIZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IG1hcmdpbkJvdHRvbSA9IGNoaWxkLmdldChcIm1hcmdpbkJvdHRvbVwiLCAwKTtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgeSA9IHByZXZZICsgbWFyZ2luVG9wIC0gdG9wO1xyXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkLnNldFByaXZhdGUoXCJ5XCIsIHkpO1xyXG4gICAgICAgICAgICAgICAgICAgIHByZXZZID0geSArIGJvdHRvbSArIG1hcmdpbkJvdHRvbTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkLnNldFByaXZhdGUoXCJ5XCIsIHVuZGVmaW5lZCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxufVxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoVmVydGljYWxMYXlvdXQsIFwiY2xhc3NOYW1lXCIsIHtcclxuICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgIHZhbHVlOiBcIlZlcnRpY2FsTGF5b3V0XCJcclxufSk7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShWZXJ0aWNhbExheW91dCwgXCJjbGFzc05hbWVzXCIsIHtcclxuICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgIHZhbHVlOiBMYXlvdXQuY2xhc3NOYW1lcy5jb25jYXQoW1ZlcnRpY2FsTGF5b3V0LmNsYXNzTmFtZV0pXHJcbn0pO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1WZXJ0aWNhbExheW91dC5qcy5tYXAiLCIvKiogQGlnbm9yZSAqLyAvKiogKi9cclxuaW1wb3J0IHsgQmxlbmRNb2RlIH0gZnJvbSBcIi4vUmVuZGVyZXJcIjtcclxuaW1wb3J0IHsgQ29sb3IgfSBmcm9tIFwiLi4vLi4vdXRpbC9Db2xvclwiO1xyXG5pbXBvcnQgeyBNYXRyaXggfSBmcm9tIFwiLi4vLi4vdXRpbC9NYXRyaXhcIjtcclxuaW1wb3J0IHsgUGVyY2VudCwgcGVyY2VudCB9IGZyb20gXCIuLi8uLi91dGlsL1BlcmNlbnRcIjtcclxuLy9pbXBvcnQgeyBUaHJvdHRsZXIgfSBmcm9tIFwiLi4vLi4vdXRpbC9UaHJvdHRsZXJcIjtcclxuaW1wb3J0IHsgQXJyYXlEaXNwb3NlciwgRGlzcG9zZXIsIERpc3Bvc2VyQ2xhc3MsIENvdW50ZXJEaXNwb3NlciwgTXVsdGlEaXNwb3NlciB9IGZyb20gXCIuLi8uLi91dGlsL0Rpc3Bvc2VyXCI7XHJcbmltcG9ydCB7IFRleHRGb3JtYXR0ZXIgfSBmcm9tIFwiLi4vLi4vdXRpbC9UZXh0Rm9ybWF0dGVyXCI7XHJcbmltcG9ydCAqIGFzICR1dGlscyBmcm9tIFwiLi4vLi4vdXRpbC9VdGlsc1wiO1xyXG5pbXBvcnQgKiBhcyAkYXJyYXkgZnJvbSBcIi4uLy4uL3V0aWwvQXJyYXlcIjtcclxuaW1wb3J0ICogYXMgJG9iamVjdCBmcm9tIFwiLi4vLi4vdXRpbC9PYmplY3RcIjtcclxuaW1wb3J0ICogYXMgJHR5cGUgZnJvbSBcIi4uLy4uL3V0aWwvVHlwZVwiO1xyXG5pbXBvcnQgKiBhcyAkbWF0aCBmcm9tIFwiLi4vLi4vdXRpbC9NYXRoXCI7XHJcbmltcG9ydCBhcmNUb0JlemllciBmcm9tICdzdmctYXJjLXRvLWN1YmljLWJlemllcic7XHJcbi8qKlxyXG4gKiBAaWdub3JlXHJcbiAqL1xyXG5mdW5jdGlvbiBjaGVja0FyZ3MobmFtZSwgYWN0dWFsLCBleHBlY3RlZCkge1xyXG4gICAgaWYgKGFjdHVhbCAhPT0gZXhwZWN0ZWQpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSZXF1aXJlZCBcIiArIGV4cGVjdGVkICsgXCIgYXJndW1lbnRzIGZvciBcIiArIG5hbWUgKyBcIiBidXQgZ290IFwiICsgYWN0dWFsKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQGlnbm9yZVxyXG4gKi9cclxuZnVuY3Rpb24gY2hlY2tNaW5BcmdzKG5hbWUsIGFjdHVhbCwgZXhwZWN0ZWQpIHtcclxuICAgIGlmIChhY3R1YWwgPCBleHBlY3RlZCkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlJlcXVpcmVkIGF0IGxlYXN0IFwiICsgZXhwZWN0ZWQgKyBcIiBhcmd1bWVudHMgZm9yIFwiICsgbmFtZSArIFwiIGJ1dCBnb3QgXCIgKyBhY3R1YWwpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBAaWdub3JlXHJcbiAqL1xyXG5mdW5jdGlvbiBjaGVja0V2ZW5BcmdzKG5hbWUsIGFjdHVhbCwgZXhwZWN0ZWQpIHtcclxuICAgIGNoZWNrTWluQXJncyhuYW1lLCBhY3R1YWwsIGV4cGVjdGVkKTtcclxuICAgIGlmICgoYWN0dWFsICUgZXhwZWN0ZWQpICE9PSAwKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQXJndW1lbnRzIGZvciBcIiArIG5hbWUgKyBcIiBtdXN0IGJlIGluIHBhaXJzIG9mIFwiICsgZXhwZWN0ZWQpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBAaWdub3JlXHJcbiAqIFRoaXMgc3BsaXRzIHRoZSBmbGFnIHNvIHRoYXQgd2F5IDAwMTcgd2lsbCBiZSBwcm9jZXNzZWQgYXMgMCAwIDE3XHJcbiAqXHJcbiAqIFRoaXMgaXMgaW1wb3J0YW50IGZvciB3ZWlyZCBwYXRocyBsaWtlIGBNMTcgNUExIDEgMCAwMDE3IDMwIDEgMSAwIDAwMTcgNWBcclxuICovXHJcbmZ1bmN0aW9uIHNwbGl0QXJjRmxhZ3MoYXJncykge1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSArPSA3KSB7XHJcbiAgICAgICAgbGV0IGluZGV4ID0gaSArIDM7XHJcbiAgICAgICAgbGV0IGZsYWcgPSBhcmdzW2luZGV4XTtcclxuICAgICAgICBpZiAoZmxhZy5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGEgPSAvXihbMDFdKShbMDFdKSguKikkLy5leGVjKGZsYWcpO1xyXG4gICAgICAgICAgICBpZiAoYSAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgYXJncy5zcGxpY2UoaW5kZXgsIDAsIGFbMV0pO1xyXG4gICAgICAgICAgICAgICAgKytpbmRleDtcclxuICAgICAgICAgICAgICAgIGFyZ3Muc3BsaWNlKGluZGV4LCAwLCBhWzJdKTtcclxuICAgICAgICAgICAgICAgICsraW5kZXg7XHJcbiAgICAgICAgICAgICAgICBpZiAoYVszXS5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYXJnc1tpbmRleF0gPSBhWzNdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYXJncy5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgICsraW5kZXg7XHJcbiAgICAgICAgZmxhZyA9IGFyZ3NbaW5kZXhdO1xyXG4gICAgICAgIGlmIChmbGFnLmxlbmd0aCA+IDEpIHtcclxuICAgICAgICAgICAgY29uc3QgYSA9IC9eKFswMV0pKC4rKSQvLmV4ZWMoZmxhZyk7XHJcbiAgICAgICAgICAgIGlmIChhICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBhcmdzLnNwbGljZShpbmRleCwgMCwgYVsxXSk7XHJcbiAgICAgICAgICAgICAgICArK2luZGV4O1xyXG4gICAgICAgICAgICAgICAgYXJnc1tpbmRleF0gPSBhWzJdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBAaWdub3JlXHJcbiAqL1xyXG5mdW5jdGlvbiBhc3NlcnRCaW5hcnkodmFsdWUpIHtcclxuICAgIGlmICh2YWx1ZSA9PT0gMCB8fCB2YWx1ZSA9PT0gMSkge1xyXG4gICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZsYWcgbXVzdCBiZSAwIG9yIDFcIik7XHJcbiAgICB9XHJcbn1cclxuLy8gIDEgLT4gMHhmZmZmZmYgKiAoMiAvIDIpXHJcbi8vICAyIC0+IDB4ZmZmZmZmICogKDEgLyAyKVxyXG4vL1xyXG4vLyAgMyAtPiAweGZmZmZmZiAqICgzIC8gNClcclxuLy8gIDQgLT4gMHhmZmZmZmYgKiAoMSAvIDQpXHJcbi8vXHJcbi8vICA1IC0+IDB4ZmZmZmZmICogKDcgLyA4KVxyXG4vLyAgNiAtPiAweGZmZmZmZiAqICg1IC8gOClcclxuLy8gIDcgLT4gMHhmZmZmZmYgKiAoMyAvIDgpXHJcbi8vICA4IC0+IDB4ZmZmZmZmICogKDEgLyA4KVxyXG4vL1xyXG4vLyAgOSAtPiAweGZmZmZmZiAqICgxNSAvIDE2KVxyXG4vLyAxMCAtPiAweGZmZmZmZiAqICgxMyAvIDE2KVxyXG4vLyAxMSAtPiAweGZmZmZmZiAqICgxMSAvIDE2KVxyXG4vLyAxMiAtPiAweGZmZmZmZiAqICAoOSAvIDE2KVxyXG4vLyAxMyAtPiAweGZmZmZmZiAqICAoNyAvIDE2KVxyXG4vLyAxNCAtPiAweGZmZmZmZiAqICAoNSAvIDE2KVxyXG4vLyAxNSAtPiAweGZmZmZmZiAqICAoMyAvIDE2KVxyXG4vLyAxNiAtPiAweGZmZmZmZiAqICAoMSAvIDE2KVxyXG4vLyBAdG9kbyByZW1vdmUgdGhpcyBvbGQgY29sb3IgZGlzdHJpYnV0aW9uIGFsZ28gaWYgdGhlIG5ldyBvbmUgcGFucyBvdXRcclxuLypmdW5jdGlvbiBkaXN0cmlidXRlSWQoaWQ6IG51bWJlcik6IG51bWJlciB7XHJcbiAgICBpZiAoaWQgPT09IDEpIHtcclxuICAgICAgICByZXR1cm4gMHgwMDAwMDE7XHJcblxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICAvLyBGaW5kcyB0aGUgY2xvc2VzdCBwb3dlciBvZiAyXHJcbiAgICAgICAgY29uc3QgYmFzZSA9IE1hdGgucG93KDIsIE1hdGguY2VpbChNYXRoLmxvZyhpZCkgLyBNYXRoLmxvZygyKSkpO1xyXG5cclxuICAgICAgICAvLyBUcmFuc2xhdGVzIHRoZSBpZCBpbnRvIGFuIG9kZCBmcmFjdGlvbiBpbmRleFxyXG4gICAgICAgIGNvbnN0IGluZGV4ID0gKChiYXNlIC0gaWQpICogMikgKyAxO1xyXG5cclxuICAgICAgICAvLyBUT0RPIGlzIE1hdGgucm91bmQgY29ycmVjdCA/XHJcbiAgICAgICAgcmV0dXJuIE1hdGgucm91bmQoMHhmZmZmZmYgKiAoaW5kZXggLyBiYXNlKSk7XHJcbiAgICB9XHJcbn0qL1xyXG4vKipcclxuICogRnVuY3Rpb24gYnkgc21lYW5zOlxyXG4gKiBodHRwczovL2xvd2NvZGUubGlmZS9nZW5lcmF0aW5nLXVuaXF1ZS1jb250cmFzdGluZy1jb2xvcnMtaW4tamF2YXNjcmlwdC9cclxuICogQGlnbm9yZVxyXG4gKi9cclxuZnVuY3Rpb24gZGlzdHJpYnV0ZUlkKGlkKSB7XHJcbiAgICBjb25zdCByZ2IgPSBbMCwgMCwgMF07XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDI0OyBpKyspIHtcclxuICAgICAgICByZ2JbaSAlIDNdIDw8PSAxO1xyXG4gICAgICAgIHJnYltpICUgM10gfD0gaWQgJiAweDAxO1xyXG4gICAgICAgIGlkID4+PSAxO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIChyZ2JbMF0gfCAwKSArIChyZ2JbMV0gPDwgOCkgKyAocmdiWzJdIDw8IDE2KTtcclxufVxyXG4vKipcclxuICogQGlnbm9yZVxyXG4gKi9cclxuZnVuY3Rpb24gZWFjaFRhcmdldHMoaGl0VGFyZ2V0LCBmKSB7XHJcbiAgICBmb3IgKDs7KSB7XHJcbiAgICAgICAgaWYgKGhpdFRhcmdldC5pbnRlcmFjdGl2ZSkge1xyXG4gICAgICAgICAgICBpZiAoIWYoaGl0VGFyZ2V0KSkge1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGhpdFRhcmdldC5fcGFyZW50KSB7XHJcbiAgICAgICAgICAgIGhpdFRhcmdldCA9IGhpdFRhcmdldC5fcGFyZW50O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbi8vIFRPRE8gZmVhdHVyZSBkZXRlY3Rpb24gZm9yIG1vdXNlL3RvdWNoL3BvaW50ZXJcclxuLyoqXHJcbiAqIEBpZ25vcmVcclxuICovXHJcbmZ1bmN0aW9uIG9uUG9pbnRlckV2ZW50KGVsZW1lbnQsIG5hbWUsIGYpIHtcclxuICAgIHJldHVybiAkdXRpbHMuYWRkRXZlbnRMaXN0ZW5lcihlbGVtZW50LCAkdXRpbHMuZ2V0UmVuZGVyZXJFdmVudChuYW1lKSwgKGV2ZW50KSA9PiB7XHJcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gJHV0aWxzLmdldEV2ZW50VGFyZ2V0KGV2ZW50KTtcclxuICAgICAgICBsZXQgdG91Y2hlcyA9IGV2ZW50LnRvdWNoZXM7XHJcbiAgICAgICAgaWYgKHRvdWNoZXMpIHtcclxuICAgICAgICAgICAgaWYgKHRvdWNoZXMubGVuZ3RoID09IDApIHtcclxuICAgICAgICAgICAgICAgIHRvdWNoZXMgPSBldmVudC5jaGFuZ2VkVG91Y2hlcztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmKCRhcnJheS5jb3B5KHRvdWNoZXMpLCB0YXJnZXQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZihbZXZlbnRdLCB0YXJnZXQpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG59XHJcbi8qKlxyXG4gKiBAaWdub3JlXHJcbiAqL1xyXG5mdW5jdGlvbiBpc1RhaW50ZWQoaW1hZ2UpIHtcclxuICAgIGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XHJcbiAgICBjYW52YXMud2lkdGggPSAxO1xyXG4gICAgY2FudmFzLmhlaWdodCA9IDE7XHJcbiAgICBjb25zdCBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiLCB7IHdpbGxSZWFkRnJlcXVlbnRseTogdHJ1ZSB9KTtcclxuICAgIGNvbnRleHQuZHJhd0ltYWdlKGltYWdlLCAwLCAwLCAxLCAxKTtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgY29udGV4dC5nZXRJbWFnZURhdGEoMCwgMCwgMSwgMSk7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGVycikge1xyXG4gICAgICAgIGNvbnNvbGUud2FybihcIkltYWdlIFxcXCJcIiArIGltYWdlLnNyYyArIFwiXFxcIiBpcyBsb2FkZWQgZnJvbSBkaWZmZXJlbnQgaG9zdCBhbmQgaXMgbm90IGNvdmVyZWQgYnkgQ09SUyBwb2xpY3kuIEZvciBtb3JlIGluZm9ybWF0aW9uIGFib3V0IHRoZSBpbXBsaWNhdGlvbnMgcmVhZCBoZXJlOiBodHRwczovL3d3dy5hbWNoYXJ0cy5jb20vZG9jcy92NS9jb25jZXB0cy9jb3JzXCIpO1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBUaGlzIGlzIG5lZWRlZCB0byB3b3JrYXJvdW5kIGEgYnVnIGluIGlPUyB3aGljaCBjYXVzZXMgaXQgdG8gbm90IEdDIGNhbnZhcyBlbGVtZW50cy5cclxuICpcclxuICogQGlnbm9yZVxyXG4gKi9cclxuZnVuY3Rpb24gY2xlYXJDYW52YXModmlldykge1xyXG4gICAgdmlldy53aWR0aCA9IDA7XHJcbiAgICB2aWV3LmhlaWdodCA9IDA7XHJcbiAgICB2aWV3LnN0eWxlLndpZHRoID0gXCIwcHhcIjtcclxuICAgIHZpZXcuc3R5bGUuaGVpZ2h0ID0gXCIwcHhcIjtcclxufVxyXG4vKipcclxuICogQWxpZ25zIHRoZSBjb29yZGluYXRlIHRvIHRoZSBwaXhlbCwgc28gaXQgcmVuZGVycyBjcmlzcFxyXG4gKlxyXG4gKiBAaWdub3JlXHJcbiAqL1xyXG5mdW5jdGlvbiBjcmlzcCh4KSB7XHJcbiAgICByZXR1cm4gTWF0aC5mbG9vcih4KSArIC41O1xyXG59XHJcbi8qKlxyXG4gKiBAaWdub3JlXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgQ2FudmFzUGl2b3Qge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX3hcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogMFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl95XCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IDBcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGdldCB4KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl94O1xyXG4gICAgfVxyXG4gICAgZ2V0IHkoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3k7XHJcbiAgICB9XHJcbiAgICBzZXQgeCh2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMuX3ggPSB2YWx1ZTtcclxuICAgIH1cclxuICAgIHNldCB5KHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5feSA9IHZhbHVlO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBAaWdub3JlXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgQ2FudmFzRGlzcGxheU9iamVjdCBleHRlbmRzIERpc3Bvc2VyQ2xhc3Mge1xyXG4gICAgY29uc3RydWN0b3IocmVuZGVyZXIpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9sYXllclwiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJtYXNrXCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IG51bGxcclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ2aXNpYmxlXCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IHRydWVcclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJleHBvcnRhYmxlXCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IHRydWVcclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJpbnRlcmFjdGl2ZVwiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiBmYWxzZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImluYWN0aXZlXCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IG51bGxcclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ3aGVlbGFibGVcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogZmFsc2VcclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJjYW5jZWxUb3VjaFwiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiBmYWxzZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImlzTWVhc3VyZWRcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogZmFsc2VcclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJidXR0b25Nb2RlXCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IGZhbHNlXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiYWxwaGFcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogMVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNvbXBvdW5kQWxwaGFcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogMVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImFuZ2xlXCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IDBcclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJzY2FsZVwiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiAxXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwieFwiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiAwXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwieVwiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiAwXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiY3Jpc3BcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogZmFsc2VcclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJwaXZvdFwiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiBuZXcgQ2FudmFzUGl2b3QoKVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImZpbHRlclwiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJjdXJzb3JPdmVyU3R5bGVcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX3JlcGxhY2VkQ3Vyc29yU3R5bGVcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX2xvY2FsTWF0cml4XCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IG5ldyBNYXRyaXgoKVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9tYXRyaXhcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogbmV3IE1hdHJpeCgpXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLy8gVE9ETyBjYW4gdGhpcyBiZSByZXBsYWNlZCB3aXRoIF9sb2NhbE1hdHJpeCA/XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX3VNYXRyaXhcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogbmV3IE1hdHJpeCgpXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX3JlbmRlcmVyXCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9wYXJlbnRcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX2xvY2FsQm91bmRzXCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9ib3VuZHNcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX2NvbG9ySWRcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5fcmVuZGVyZXIgPSByZW5kZXJlcjtcclxuICAgIH1cclxuICAgIHN1YlN0YXR1cyhzdGF0dXMpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBpbmFjdGl2ZTogKHRoaXMuaW5hY3RpdmUgPT0gbnVsbCA/IHN0YXR1cy5pbmFjdGl2ZSA6IHRoaXMuaW5hY3RpdmUpLFxyXG4gICAgICAgICAgICBsYXllcjogdGhpcy5fbGF5ZXIgfHwgc3RhdHVzLmxheWVyLFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBfZGlzcG9zZSgpIHtcclxuICAgICAgICB0aGlzLl9yZW5kZXJlci5fcmVtb3ZlT2JqZWN0KHRoaXMpO1xyXG4gICAgICAgIHRoaXMuZ2V0TGF5ZXIoKS5kaXJ0eSA9IHRydWU7XHJcbiAgICB9XHJcbiAgICBnZXRDYW52YXMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TGF5ZXIoKS52aWV3O1xyXG4gICAgfVxyXG4gICAgZ2V0TGF5ZXIoKSB7XHJcbiAgICAgICAgbGV0IHNlbGYgPSB0aGlzO1xyXG4gICAgICAgIGZvciAoOzspIHtcclxuICAgICAgICAgICAgaWYgKHNlbGYuX2xheWVyKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5fbGF5ZXI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoc2VsZi5fcGFyZW50KSB7XHJcbiAgICAgICAgICAgICAgICBzZWxmID0gc2VsZi5fcGFyZW50O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JlbmRlcmVyLmRlZmF1bHRMYXllcjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHNldExheWVyKG9yZGVyLCBtYXJnaW4pIHtcclxuICAgICAgICBpZiAob3JkZXIgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aGlzLl9sYXllciA9IHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHZpc2libGUgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLl9sYXllciA9IHRoaXMuX3JlbmRlcmVyLmdldExheWVyKG9yZGVyLCB2aXNpYmxlKTtcclxuICAgICAgICAgICAgdGhpcy5fbGF5ZXIudmlzaWJsZSA9IHZpc2libGU7XHJcbiAgICAgICAgICAgIHRoaXMuX2xheWVyLm1hcmdpbiA9IG1hcmdpbjtcclxuICAgICAgICAgICAgaWYgKG1hcmdpbikge1xyXG4gICAgICAgICAgICAgICAgJHV0aWxzLnNldEludGVyYWN0aXZlKHRoaXMuX2xheWVyLnZpZXcsIGZhbHNlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5fZ2hvc3RMYXllci5zZXRNYXJnaW4odGhpcy5fcmVuZGVyZXIubGF5ZXJzKTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX3BhcmVudCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcGFyZW50LnJlZ2lzdGVyQ2hpbGRMYXllcih0aGlzLl9sYXllcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fbGF5ZXIuZGlydHkgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5yZXNpemVMYXllcih0aGlzLl9sYXllcik7XHJcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLnJlc2l6ZUdob3N0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgbWFya0RpcnR5TGF5ZXIoKSB7XHJcbiAgICAgICAgdGhpcy5nZXRMYXllcigpLmRpcnR5ID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIGNsZWFyKCkge1xyXG4gICAgICAgIHRoaXMuaW52YWxpZGF0ZUJvdW5kcygpO1xyXG4gICAgfVxyXG4gICAgaW52YWxpZGF0ZUJvdW5kcygpIHtcclxuICAgICAgICB0aGlzLl9sb2NhbEJvdW5kcyA9IHVuZGVmaW5lZDtcclxuICAgIH1cclxuICAgIF9hZGRCb3VuZHMoX2JvdW5kcykgeyB9XHJcbiAgICBfZ2V0Q29sb3JJZCgpIHtcclxuICAgICAgICBpZiAodGhpcy5fY29sb3JJZCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2NvbG9ySWQgPSB0aGlzLl9yZW5kZXJlci5wYWludElkKHRoaXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5fY29sb3JJZDtcclxuICAgIH1cclxuICAgIF9pc0ludGVyYWN0aXZlKHN0YXR1cykge1xyXG4gICAgICAgIHJldHVybiAhc3RhdHVzLmluYWN0aXZlICYmICh0aGlzLmludGVyYWN0aXZlIHx8IHRoaXMuX3JlbmRlcmVyLl9mb3JjZUludGVyYWN0aXZlID4gMCk7XHJcbiAgICB9XHJcbiAgICBfaXNJbnRlcmFjdGl2ZU1hc2soc3RhdHVzKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzSW50ZXJhY3RpdmUoc3RhdHVzKTtcclxuICAgIH1cclxuICAgIGNvbnRhaW5zKGNoaWxkKSB7XHJcbiAgICAgICAgZm9yICg7Oykge1xyXG4gICAgICAgICAgICBpZiAoY2hpbGQgPT09IHRoaXMpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGNoaWxkLl9wYXJlbnQpIHtcclxuICAgICAgICAgICAgICAgIGNoaWxkID0gY2hpbGQuX3BhcmVudDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHRvR2xvYmFsKHBvaW50KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX21hdHJpeC5hcHBseShwb2ludCk7XHJcbiAgICB9XHJcbiAgICB0b0xvY2FsKHBvaW50KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX21hdHJpeC5hcHBseUludmVyc2UocG9pbnQpO1xyXG4gICAgfVxyXG4gICAgZ2V0TG9jYWxNYXRyaXgoKSB7XHJcbiAgICAgICAgdGhpcy5fdU1hdHJpeC5zZXRUcmFuc2Zvcm0oMCwgMCwgdGhpcy5waXZvdC54LCB0aGlzLnBpdm90LnksIHRoaXMuYW5nbGUgKiBNYXRoLlBJIC8gMTgwLCB0aGlzLnNjYWxlKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5fdU1hdHJpeDtcclxuICAgIH1cclxuICAgIGdldExvY2FsQm91bmRzKCkge1xyXG4gICAgICAgIGlmICghdGhpcy5fbG9jYWxCb3VuZHMpIHtcclxuICAgICAgICAgICAgY29uc3QgYm4gPSAxMDAwMDAwMDtcclxuICAgICAgICAgICAgdGhpcy5fbG9jYWxCb3VuZHMgPSB7XHJcbiAgICAgICAgICAgICAgICBsZWZ0OiBibixcclxuICAgICAgICAgICAgICAgIHRvcDogYm4sXHJcbiAgICAgICAgICAgICAgICByaWdodDogLWJuLFxyXG4gICAgICAgICAgICAgICAgYm90dG9tOiAtYm5cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgdGhpcy5fYWRkQm91bmRzKHRoaXMuX2xvY2FsQm91bmRzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xvY2FsQm91bmRzO1xyXG4gICAgfVxyXG4gICAgZ2V0QWRqdXN0ZWRCb3VuZHMoYm91bmRzKSB7XHJcbiAgICAgICAgdGhpcy5fc2V0TWF0cml4KCk7XHJcbiAgICAgICAgY29uc3QgbWF0cml4ID0gdGhpcy5nZXRMb2NhbE1hdHJpeCgpO1xyXG4gICAgICAgIGNvbnN0IHAwID0gbWF0cml4LmFwcGx5KHsgeDogYm91bmRzLmxlZnQsIHk6IGJvdW5kcy50b3AgfSk7XHJcbiAgICAgICAgY29uc3QgcDEgPSBtYXRyaXguYXBwbHkoeyB4OiBib3VuZHMucmlnaHQsIHk6IGJvdW5kcy50b3AgfSk7XHJcbiAgICAgICAgY29uc3QgcDIgPSBtYXRyaXguYXBwbHkoeyB4OiBib3VuZHMucmlnaHQsIHk6IGJvdW5kcy5ib3R0b20gfSk7XHJcbiAgICAgICAgY29uc3QgcDMgPSBtYXRyaXguYXBwbHkoeyB4OiBib3VuZHMubGVmdCwgeTogYm91bmRzLmJvdHRvbSB9KTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBsZWZ0OiBNYXRoLm1pbihwMC54LCBwMS54LCBwMi54LCBwMy54KSxcclxuICAgICAgICAgICAgdG9wOiBNYXRoLm1pbihwMC55LCBwMS55LCBwMi55LCBwMy55KSxcclxuICAgICAgICAgICAgcmlnaHQ6IE1hdGgubWF4KHAwLngsIHAxLngsIHAyLngsIHAzLngpLFxyXG4gICAgICAgICAgICBib3R0b206IE1hdGgubWF4KHAwLnksIHAxLnksIHAyLnksIHAzLnkpXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIG9uKGtleSwgY2FsbGJhY2ssIGNvbnRleHQpIHtcclxuICAgICAgICBpZiAodGhpcy5pbnRlcmFjdGl2ZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVuZGVyZXIuX2FkZEV2ZW50KHRoaXMsIGtleSwgY2FsbGJhY2ssIGNvbnRleHQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBEaXNwb3NlcigoKSA9PiB7IH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIF9zZXRNYXRyaXgoKSB7XHJcbiAgICAgICAgLy8gVE9ETyBvbmx5IGNhbGN1bGF0ZSB0aGlzIGlmIGl0IGhhcyBhY3R1YWxseSBjaGFuZ2VkXHJcbiAgICAgICAgdGhpcy5fbG9jYWxNYXRyaXguc2V0VHJhbnNmb3JtKHRoaXMueCwgdGhpcy55LCB0aGlzLnBpdm90LngsIHRoaXMucGl2b3QueSwgXHJcbiAgICAgICAgLy8gQ29udmVydHMgZGVncmVlcyB0byByYWRpYW5zXHJcbiAgICAgICAgdGhpcy5hbmdsZSAqIE1hdGguUEkgLyAxODAsIHRoaXMuc2NhbGUpO1xyXG4gICAgICAgIHRoaXMuX21hdHJpeC5jb3B5RnJvbSh0aGlzLl9sb2NhbE1hdHJpeCk7XHJcbiAgICAgICAgaWYgKHRoaXMuX3BhcmVudCkge1xyXG4gICAgICAgICAgICAvLyBUT0RPIG9ubHkgY2FsY3VsYXRlIHRoaXMgaWYgaXQgaGFzIGFjdHVhbGx5IGNoYW5nZWRcclxuICAgICAgICAgICAgdGhpcy5fbWF0cml4LnByZXBlbmQodGhpcy5fcGFyZW50Ll9tYXRyaXgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIF90cmFuc2Zvcm0oY29udGV4dCwgcmVzb2x1dGlvbikge1xyXG4gICAgICAgIGNvbnN0IG0gPSB0aGlzLl9tYXRyaXg7XHJcbiAgICAgICAgbGV0IHR4ID0gbS50eCAqIHJlc29sdXRpb247XHJcbiAgICAgICAgbGV0IHR5ID0gbS50eSAqIHJlc29sdXRpb247XHJcbiAgICAgICAgaWYgKHRoaXMuY3Jpc3ApIHtcclxuICAgICAgICAgICAgdHggPSBjcmlzcCh0eCk7XHJcbiAgICAgICAgICAgIHR5ID0gY3Jpc3AodHkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb250ZXh0LnNldFRyYW5zZm9ybShtLmEgKiByZXNvbHV0aW9uLCBtLmIgKiByZXNvbHV0aW9uLCBtLmMgKiByZXNvbHV0aW9uLCBtLmQgKiByZXNvbHV0aW9uLCB0eCwgdHkpO1xyXG4gICAgfVxyXG4gICAgX3RyYW5zZm9ybU1hcmdpbihjb250ZXh0LCByZXNvbHV0aW9uLCBtYXJnaW4pIHtcclxuICAgICAgICBjb25zdCBtID0gdGhpcy5fbWF0cml4O1xyXG4gICAgICAgIGNvbnRleHQuc2V0VHJhbnNmb3JtKG0uYSAqIHJlc29sdXRpb24sIG0uYiAqIHJlc29sdXRpb24sIG0uYyAqIHJlc29sdXRpb24sIG0uZCAqIHJlc29sdXRpb24sIChtLnR4ICsgbWFyZ2luLmxlZnQpICogcmVzb2x1dGlvbiwgKG0udHkgKyBtYXJnaW4udG9wKSAqIHJlc29sdXRpb24pO1xyXG4gICAgfVxyXG4gICAgX3RyYW5zZm9ybUxheWVyKGNvbnRleHQsIHJlc29sdXRpb24sIGxheWVyKSB7XHJcbiAgICAgICAgaWYgKGxheWVyLm1hcmdpbikge1xyXG4gICAgICAgICAgICB0aGlzLl90cmFuc2Zvcm1NYXJnaW4oY29udGV4dCwgbGF5ZXIuc2NhbGUgfHwgcmVzb2x1dGlvbiwgbGF5ZXIubWFyZ2luKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3RyYW5zZm9ybShjb250ZXh0LCBsYXllci5zY2FsZSB8fCByZXNvbHV0aW9uKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZW5kZXIoc3RhdHVzKSB7XHJcbiAgICAgICAgaWYgKHRoaXMudmlzaWJsZSAmJiAodGhpcy5leHBvcnRhYmxlICE9PSBmYWxzZSB8fCAhdGhpcy5fcmVuZGVyZXIuX29taXRUYWludGVkKSkge1xyXG4gICAgICAgICAgICB0aGlzLl9zZXRNYXRyaXgoKTtcclxuICAgICAgICAgICAgY29uc3Qgc3ViU3RhdHVzID0gdGhpcy5zdWJTdGF0dXMoc3RhdHVzKTtcclxuICAgICAgICAgICAgY29uc3QgcmVzb2x1dGlvbiA9IHRoaXMuX3JlbmRlcmVyLnJlc29sdXRpb247XHJcbiAgICAgICAgICAgIGNvbnN0IGxheWVycyA9IHRoaXMuX3JlbmRlcmVyLmxheWVycztcclxuICAgICAgICAgICAgY29uc3QgZ2hvc3RMYXllciA9IHRoaXMuX3JlbmRlcmVyLl9naG9zdExheWVyO1xyXG4gICAgICAgICAgICBjb25zdCBnaG9zdENvbnRleHQgPSBnaG9zdExheWVyLmNvbnRleHQ7XHJcbiAgICAgICAgICAgIGNvbnN0IG1hc2sgPSB0aGlzLm1hc2s7XHJcbiAgICAgICAgICAgIGlmIChtYXNrKSB7XHJcbiAgICAgICAgICAgICAgICBtYXNrLl9zZXRNYXRyaXgoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBUT0RPIGltcHJvdmUgdGhpc1xyXG4gICAgICAgICAgICAkYXJyYXkuZWFjaChsYXllcnMsIChsYXllcikgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKGxheWVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY29udGV4dCA9IGxheWVyLmNvbnRleHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5zYXZlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgbXVzdCBhcHBseSB0aGUgbWFzayBiZWZvcmUgd2UgdHJhbnNmb3JtIHRoZSBlbGVtZW50XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hc2spIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWFzay5fdHJhbnNmb3JtTGF5ZXIoY29udGV4dCwgcmVzb2x1dGlvbiwgbGF5ZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXNrLl9ydW5QYXRoKGNvbnRleHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmNsaXAoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5nbG9iYWxBbHBoYSA9IHRoaXMuY29tcG91bmRBbHBoYSAqIHRoaXMuYWxwaGE7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdHJhbnNmb3JtTGF5ZXIoY29udGV4dCwgcmVzb2x1dGlvbiwgbGF5ZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmZpbHRlcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmZpbHRlciA9IHRoaXMuZmlsdGVyO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGdob3N0Q29udGV4dC5zYXZlKCk7XHJcbiAgICAgICAgICAgIC8vIFdlIG11c3QgYXBwbHkgdGhlIG1hc2sgYmVmb3JlIHdlIHRyYW5zZm9ybSB0aGUgZWxlbWVudFxyXG4gICAgICAgICAgICBpZiAobWFzayAmJiB0aGlzLl9pc0ludGVyYWN0aXZlTWFzayhzdWJTdGF0dXMpKSB7XHJcbiAgICAgICAgICAgICAgICBtYXNrLl90cmFuc2Zvcm1NYXJnaW4oZ2hvc3RDb250ZXh0LCByZXNvbHV0aW9uLCBnaG9zdExheWVyLm1hcmdpbik7XHJcbiAgICAgICAgICAgICAgICBtYXNrLl9ydW5QYXRoKGdob3N0Q29udGV4dCk7XHJcbiAgICAgICAgICAgICAgICBnaG9zdENvbnRleHQuY2xpcCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX3RyYW5zZm9ybU1hcmdpbihnaG9zdENvbnRleHQsIHJlc29sdXRpb24sIGdob3N0TGF5ZXIubWFyZ2luKTtcclxuICAgICAgICAgICAgdGhpcy5fcmVuZGVyKHN1YlN0YXR1cyk7XHJcbiAgICAgICAgICAgIGdob3N0Q29udGV4dC5yZXN0b3JlKCk7XHJcbiAgICAgICAgICAgICRhcnJheS5lYWNoKGxheWVycywgKGxheWVyKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAobGF5ZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICBsYXllci5jb250ZXh0LnJlc3RvcmUoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgX3JlbmRlcihzdGF0dXMpIHtcclxuICAgICAgICBpZiAodGhpcy5leHBvcnRhYmxlID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICBzdGF0dXMubGF5ZXIudGFpbnRlZCA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaG92ZXJpbmcoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlbmRlcmVyLl9ob3ZlcmluZy5oYXModGhpcyk7XHJcbiAgICB9XHJcbiAgICBkcmFnZ2luZygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fcmVuZGVyZXIuX2RyYWdnaW5nLnNvbWUoKHgpID0+IHgudmFsdWUgPT09IHRoaXMpO1xyXG4gICAgfVxyXG4gICAgc2hvdWxkQ2FuY2VsVG91Y2goKSB7XHJcbiAgICAgICAgY29uc3QgcmVuZGVyZXIgPSB0aGlzLl9yZW5kZXJlcjtcclxuICAgICAgICBpZiAocmVuZGVyZXIudGFwVG9BY3RpdmF0ZSAmJiAhcmVuZGVyZXIuX3RvdWNoQWN0aXZlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuY2FuY2VsVG91Y2gpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHRoaXMuX3BhcmVudCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcGFyZW50LnNob3VsZENhbmNlbFRvdWNoKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQGlnbm9yZVxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIENhbnZhc0NvbnRhaW5lciBleHRlbmRzIENhbnZhc0Rpc3BsYXlPYmplY3Qge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJpbnRlcmFjdGl2ZUNoaWxkcmVuXCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IHRydWVcclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfY2hpbGRMYXllcnNcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX2NoaWxkcmVuXCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IFtdXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBfaXNJbnRlcmFjdGl2ZU1hc2soc3RhdHVzKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaW50ZXJhY3RpdmVDaGlsZHJlbiB8fCBzdXBlci5faXNJbnRlcmFjdGl2ZU1hc2soc3RhdHVzKTtcclxuICAgIH1cclxuICAgIGFkZENoaWxkKGNoaWxkKSB7XHJcbiAgICAgICAgY2hpbGQuX3BhcmVudCA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy5fY2hpbGRyZW4ucHVzaChjaGlsZCk7XHJcbiAgICAgICAgaWYgKGNoaWxkLl9sYXllcikge1xyXG4gICAgICAgICAgICB0aGlzLnJlZ2lzdGVyQ2hpbGRMYXllcihjaGlsZC5fbGF5ZXIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGFkZENoaWxkQXQoY2hpbGQsIGluZGV4KSB7XHJcbiAgICAgICAgY2hpbGQuX3BhcmVudCA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy5fY2hpbGRyZW4uc3BsaWNlKGluZGV4LCAwLCBjaGlsZCk7XHJcbiAgICAgICAgaWYgKGNoaWxkLl9sYXllcikge1xyXG4gICAgICAgICAgICB0aGlzLnJlZ2lzdGVyQ2hpbGRMYXllcihjaGlsZC5fbGF5ZXIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJlbW92ZUNoaWxkKGNoaWxkKSB7XHJcbiAgICAgICAgY2hpbGQuX3BhcmVudCA9IHVuZGVmaW5lZDtcclxuICAgICAgICAkYXJyYXkucmVtb3ZlRmlyc3QodGhpcy5fY2hpbGRyZW4sIGNoaWxkKTtcclxuICAgIH1cclxuICAgIF9yZW5kZXIoc3RhdHVzKSB7XHJcbiAgICAgICAgc3VwZXIuX3JlbmRlcihzdGF0dXMpO1xyXG4gICAgICAgIGNvbnN0IHJlbmRlcmVyID0gdGhpcy5fcmVuZGVyZXI7XHJcbiAgICAgICAgaWYgKHRoaXMuaW50ZXJhY3RpdmUgJiYgdGhpcy5pbnRlcmFjdGl2ZUNoaWxkcmVuKSB7XHJcbiAgICAgICAgICAgICsrcmVuZGVyZXIuX2ZvcmNlSW50ZXJhY3RpdmU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgICRhcnJheS5lYWNoKHRoaXMuX2NoaWxkcmVuLCAoY2hpbGQpID0+IHtcclxuICAgICAgICAgICAgY2hpbGQuY29tcG91bmRBbHBoYSA9IHRoaXMuY29tcG91bmRBbHBoYSAqIHRoaXMuYWxwaGE7XHJcbiAgICAgICAgICAgIGNoaWxkLnJlbmRlcihzdGF0dXMpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGlmICh0aGlzLmludGVyYWN0aXZlICYmIHRoaXMuaW50ZXJhY3RpdmVDaGlsZHJlbikge1xyXG4gICAgICAgICAgICAtLXJlbmRlcmVyLl9mb3JjZUludGVyYWN0aXZlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJlZ2lzdGVyQ2hpbGRMYXllcihsYXllcikge1xyXG4gICAgICAgIGlmICghdGhpcy5fY2hpbGRMYXllcnMpIHtcclxuICAgICAgICAgICAgdGhpcy5fY2hpbGRMYXllcnMgPSBbXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgJGFycmF5LnB1c2hPbmUodGhpcy5fY2hpbGRMYXllcnMsIGxheWVyKTtcclxuICAgICAgICBpZiAodGhpcy5fcGFyZW50KSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3BhcmVudC5yZWdpc3RlckNoaWxkTGF5ZXIobGF5ZXIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIG1hcmtEaXJ0eUxheWVyKGRlZXAgPSBmYWxzZSkge1xyXG4gICAgICAgIHN1cGVyLm1hcmtEaXJ0eUxheWVyKCk7XHJcbiAgICAgICAgaWYgKGRlZXAgJiYgdGhpcy5fY2hpbGRMYXllcnMpIHtcclxuICAgICAgICAgICAgJGFycmF5LmVhY2godGhpcy5fY2hpbGRMYXllcnMsIChsYXllcikgPT4gbGF5ZXIuZGlydHkgPSB0cnVlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBfZGlzcG9zZSgpIHtcclxuICAgICAgICBzdXBlci5fZGlzcG9zZSgpO1xyXG4gICAgICAgIGlmICh0aGlzLl9jaGlsZExheWVycykge1xyXG4gICAgICAgICAgICAkYXJyYXkuZWFjaCh0aGlzLl9jaGlsZExheWVycywgKGxheWVyKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBsYXllci5kaXJ0eSA9IHRydWU7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4vKipcclxuICogQGlnbm9yZVxyXG4gKi9cclxuZnVuY3Rpb24gc2V0UG9pbnQoYm91bmRzLCBwb2ludCkge1xyXG4gICAgYm91bmRzLmxlZnQgPSBNYXRoLm1pbihib3VuZHMubGVmdCwgcG9pbnQueCk7XHJcbiAgICBib3VuZHMudG9wID0gTWF0aC5taW4oYm91bmRzLnRvcCwgcG9pbnQueSk7XHJcbiAgICBib3VuZHMucmlnaHQgPSBNYXRoLm1heChib3VuZHMucmlnaHQsIHBvaW50LngpO1xyXG4gICAgYm91bmRzLmJvdHRvbSA9IE1hdGgubWF4KGJvdW5kcy5ib3R0b20sIHBvaW50LnkpO1xyXG59XHJcbi8qKlxyXG4gKiBAaWdub3JlXHJcbiAqL1xyXG5jbGFzcyBPcCB7XHJcbiAgICBjb2xvcml6ZShfY29udGV4dCwgX2ZvcmNlQ29sb3IpIHsgfVxyXG4gICAgcGF0aChfY29udGV4dCkgeyB9XHJcbiAgICBhZGRCb3VuZHMoX2JvdW5kcykgeyB9XHJcbn1cclxuLyoqXHJcbiAqIEBpZ25vcmVcclxuICovXHJcbmNsYXNzIEJlZ2luUGF0aCBleHRlbmRzIE9wIHtcclxuICAgIGNvbG9yaXplKGNvbnRleHQsIF9mb3JjZUNvbG9yKSB7XHJcbiAgICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQGlnbm9yZVxyXG4gKi9cclxuY2xhc3MgQmVnaW5GaWxsIGV4dGVuZHMgT3Age1xyXG4gICAgY29uc3RydWN0b3IoY29sb3IpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNvbG9yXCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IGNvbG9yXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBjb2xvcml6ZShjb250ZXh0LCBmb3JjZUNvbG9yKSB7XHJcbiAgICAgICAgaWYgKGZvcmNlQ29sb3IgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBjb250ZXh0LmZpbGxTdHlsZSA9IGZvcmNlQ29sb3I7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb250ZXh0LmZpbGxTdHlsZSA9IHRoaXMuY29sb3I7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBAaWdub3JlXHJcbiAqL1xyXG5jbGFzcyBFbmRGaWxsIGV4dGVuZHMgT3Age1xyXG4gICAgY29uc3RydWN0b3IoY2xlYXJTaGFkb3cpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNsZWFyU2hhZG93XCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IGNsZWFyU2hhZG93XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBjb2xvcml6ZShjb250ZXh0LCBfZm9yY2VDb2xvcikge1xyXG4gICAgICAgIGNvbnRleHQuZmlsbCgpO1xyXG4gICAgICAgIGlmICh0aGlzLmNsZWFyU2hhZG93KSB7XHJcbiAgICAgICAgICAgIGNvbnRleHQuc2hhZG93Q29sb3IgPSBcIlwiO1xyXG4gICAgICAgICAgICBjb250ZXh0LnNoYWRvd0JsdXIgPSAwO1xyXG4gICAgICAgICAgICBjb250ZXh0LnNoYWRvd09mZnNldFggPSAwO1xyXG4gICAgICAgICAgICBjb250ZXh0LnNoYWRvd09mZnNldFkgPSAwO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4vKipcclxuICogQGlnbm9yZVxyXG4gKi9cclxuY2xhc3MgRW5kU3Ryb2tlIGV4dGVuZHMgT3Age1xyXG4gICAgY29sb3JpemUoY29udGV4dCwgX2ZvcmNlQ29sb3IpIHtcclxuICAgICAgICBjb250ZXh0LnN0cm9rZSgpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBAaWdub3JlXHJcbiAqL1xyXG5jbGFzcyBMaW5lU3R5bGUgZXh0ZW5kcyBPcCB7XHJcbiAgICBjb25zdHJ1Y3Rvcih3aWR0aCwgY29sb3IsIGxpbmVKb2luKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ3aWR0aFwiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiB3aWR0aFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNvbG9yXCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IGNvbG9yXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibGluZUpvaW5cIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogbGluZUpvaW5cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGNvbG9yaXplKGNvbnRleHQsIGZvcmNlQ29sb3IpIHtcclxuICAgICAgICBpZiAoZm9yY2VDb2xvciAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSBmb3JjZUNvbG9yO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29udGV4dC5zdHJva2VTdHlsZSA9IHRoaXMuY29sb3I7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnRleHQubGluZVdpZHRoID0gdGhpcy53aWR0aDtcclxuICAgICAgICBpZiAodGhpcy5saW5lSm9pbikge1xyXG4gICAgICAgICAgICBjb250ZXh0LmxpbmVKb2luID0gdGhpcy5saW5lSm9pbjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEBpZ25vcmVcclxuICovXHJcbmNsYXNzIExpbmVEYXNoIGV4dGVuZHMgT3Age1xyXG4gICAgY29uc3RydWN0b3IoZGFzaCkge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZGFzaFwiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiBkYXNoXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBjb2xvcml6ZShjb250ZXh0LCBfZm9yY2VDb2xvcikge1xyXG4gICAgICAgIGNvbnRleHQuc2V0TGluZURhc2godGhpcy5kYXNoKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQGlnbm9yZVxyXG4gKi9cclxuY2xhc3MgTGluZURhc2hPZmZzZXQgZXh0ZW5kcyBPcCB7XHJcbiAgICBjb25zdHJ1Y3RvcihkYXNoT2Zmc2V0KSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJkYXNoT2Zmc2V0XCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IGRhc2hPZmZzZXRcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGNvbG9yaXplKGNvbnRleHQsIF9mb3JjZUNvbG9yKSB7XHJcbiAgICAgICAgY29udGV4dC5saW5lRGFzaE9mZnNldCA9IHRoaXMuZGFzaE9mZnNldDtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQGlnbm9yZVxyXG4gKi9cclxuY2xhc3MgRHJhd1JlY3QgZXh0ZW5kcyBPcCB7XHJcbiAgICBjb25zdHJ1Y3Rvcih4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ4XCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IHhcclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ5XCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IHlcclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ3aWR0aFwiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiB3aWR0aFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImhlaWdodFwiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiBoZWlnaHRcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHBhdGgoY29udGV4dCkge1xyXG4gICAgICAgIGNvbnRleHQucmVjdCh0aGlzLngsIHRoaXMueSwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xyXG4gICAgfVxyXG4gICAgYWRkQm91bmRzKGJvdW5kcykge1xyXG4gICAgICAgIGNvbnN0IGwgPSB0aGlzLng7XHJcbiAgICAgICAgY29uc3QgdCA9IHRoaXMueTtcclxuICAgICAgICBjb25zdCByID0gbCArIHRoaXMud2lkdGg7XHJcbiAgICAgICAgY29uc3QgYiA9IHQgKyB0aGlzLmhlaWdodDtcclxuICAgICAgICBzZXRQb2ludChib3VuZHMsIHsgeDogbCwgeTogdCB9KTtcclxuICAgICAgICBzZXRQb2ludChib3VuZHMsIHsgeDogciwgeTogdCB9KTtcclxuICAgICAgICBzZXRQb2ludChib3VuZHMsIHsgeDogbCwgeTogYiB9KTtcclxuICAgICAgICBzZXRQb2ludChib3VuZHMsIHsgeDogciwgeTogYiB9KTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQGlnbm9yZVxyXG4gKi9cclxuY2xhc3MgRHJhd0NpcmNsZSBleHRlbmRzIE9wIHtcclxuICAgIGNvbnN0cnVjdG9yKHgsIHksIHJhZGl1cykge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwieFwiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiB4XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwieVwiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiB5XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwicmFkaXVzXCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IHJhZGl1c1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgcGF0aChjb250ZXh0KSB7XHJcbiAgICAgICAgY29udGV4dC5tb3ZlVG8odGhpcy54ICsgdGhpcy5yYWRpdXMsIHRoaXMueSk7XHJcbiAgICAgICAgY29udGV4dC5hcmModGhpcy54LCB0aGlzLnksIHRoaXMucmFkaXVzLCAwLCAyICogTWF0aC5QSSk7XHJcbiAgICB9XHJcbiAgICAvLyBUT0RPIGhhbmRsZSBza2V3aW5nIGFuZCByb3RhdGlvblxyXG4gICAgYWRkQm91bmRzKGJvdW5kcykge1xyXG4gICAgICAgIHNldFBvaW50KGJvdW5kcywgeyB4OiB0aGlzLnggLSB0aGlzLnJhZGl1cywgeTogdGhpcy55IC0gdGhpcy5yYWRpdXMgfSk7XHJcbiAgICAgICAgc2V0UG9pbnQoYm91bmRzLCB7IHg6IHRoaXMueCArIHRoaXMucmFkaXVzLCB5OiB0aGlzLnkgKyB0aGlzLnJhZGl1cyB9KTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQGlnbm9yZVxyXG4gKi9cclxuY2xhc3MgRHJhd0VsbGlwc2UgZXh0ZW5kcyBPcCB7XHJcbiAgICBjb25zdHJ1Y3Rvcih4LCB5LCByYWRpdXNYLCByYWRpdXNZKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ4XCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IHhcclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ5XCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IHlcclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJyYWRpdXNYXCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IHJhZGl1c1hcclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJyYWRpdXNZXCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IHJhZGl1c1lcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHBhdGgoY29udGV4dCkge1xyXG4gICAgICAgIGNvbnRleHQuZWxsaXBzZSgwLCAwLCB0aGlzLnJhZGl1c1gsIHRoaXMucmFkaXVzWSwgMCwgMCwgTWF0aC5QSSAqIDIpO1xyXG4gICAgfVxyXG4gICAgLy8gVE9ETyBoYW5kbGUgc2tld2luZyBhbmQgcm90YXRpb25cclxuICAgIGFkZEJvdW5kcyhib3VuZHMpIHtcclxuICAgICAgICBzZXRQb2ludChib3VuZHMsIHsgeDogdGhpcy54IC0gdGhpcy5yYWRpdXNYLCB5OiB0aGlzLnkgLSB0aGlzLnJhZGl1c1kgfSk7XHJcbiAgICAgICAgc2V0UG9pbnQoYm91bmRzLCB7IHg6IHRoaXMueCArIHRoaXMucmFkaXVzWCwgeTogdGhpcy55ICsgdGhpcy5yYWRpdXNZIH0pO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBAaWdub3JlXHJcbiAqL1xyXG5jbGFzcyBBcmMgZXh0ZW5kcyBPcCB7XHJcbiAgICBjb25zdHJ1Y3RvcihjeCwgY3ksIHJhZGl1cywgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIGFudGljbG9ja3dpc2UpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImN4XCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IGN4XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiY3lcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogY3lcclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJyYWRpdXNcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogcmFkaXVzXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwic3RhcnRBbmdsZVwiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiBzdGFydEFuZ2xlXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZW5kQW5nbGVcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogZW5kQW5nbGVcclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJhbnRpY2xvY2t3aXNlXCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IGFudGljbG9ja3dpc2VcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHBhdGgoY29udGV4dCkge1xyXG4gICAgICAgIGlmICh0aGlzLnJhZGl1cyA+IDApIHtcclxuICAgICAgICAgICAgY29udGV4dC5hcmModGhpcy5jeCwgdGhpcy5jeSwgdGhpcy5yYWRpdXMsIHRoaXMuc3RhcnRBbmdsZSwgdGhpcy5lbmRBbmdsZSwgdGhpcy5hbnRpY2xvY2t3aXNlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBhZGRCb3VuZHMoYm91bmRzKSB7XHJcbiAgICAgICAgbGV0IGFyY0JvdW5kcyA9ICRtYXRoLmdldEFyY0JvdW5kcyh0aGlzLmN4LCB0aGlzLmN5LCB0aGlzLnN0YXJ0QW5nbGUgKiAkbWF0aC5ERUdSRUVTLCB0aGlzLmVuZEFuZ2xlICogJG1hdGguREVHUkVFUywgdGhpcy5yYWRpdXMpO1xyXG4gICAgICAgIHNldFBvaW50KGJvdW5kcywgeyB4OiBhcmNCb3VuZHMubGVmdCwgeTogYXJjQm91bmRzLnRvcCB9KTtcclxuICAgICAgICBzZXRQb2ludChib3VuZHMsIHsgeDogYXJjQm91bmRzLnJpZ2h0LCB5OiBhcmNCb3VuZHMuYm90dG9tIH0pO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBAaWdub3JlXHJcbiAqL1xyXG5jbGFzcyBBcmNUbyBleHRlbmRzIE9wIHtcclxuICAgIGNvbnN0cnVjdG9yKHgxLCB5MSwgeDIsIHkyLCByYWRpdXMpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIngxXCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IHgxXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwieTFcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogeTFcclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ4MlwiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiB4MlxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInkyXCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IHkyXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwicmFkaXVzXCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IHJhZGl1c1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgcGF0aChjb250ZXh0KSB7XHJcbiAgICAgICAgaWYgKHRoaXMucmFkaXVzID4gMCkge1xyXG4gICAgICAgICAgICBjb250ZXh0LmFyY1RvKHRoaXMueDEsIHRoaXMueTEsIHRoaXMueDIsIHRoaXMueTIsIHRoaXMucmFkaXVzKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBUT0RPOiBhZGQgcG9pbnRzXHJcbiAgICBhZGRCb3VuZHMoX2JvdW5kcykge1xyXG4gICAgICAgIC8qXHJcbiAgICAgICAgLy8gbm90IGZpbmlzaGVkXHJcbiAgICAgICAgaHR0cHM6Ly9tYXRoLnN0YWNrZXhjaGFuZ2UuY29tL3F1ZXN0aW9ucy8xNzgxNDM4L2ZpbmRpbmctdGhlLWNlbnRlci1vZi1hLWNpcmNsZS1naXZlbi10d28tcG9pbnRzLWFuZC1hLXJhZGl1cy1hbGdlYnJhaWNhbGx5XHJcblxyXG4gICAgICAgIGlmIChwcmV2UG9pbnQpIHtcclxuICAgICAgICAgICAgbGV0IHgxID0gcHJldlBvaW50Lng7XHJcbiAgICAgICAgICAgIGxldCB5MSA9IHByZXZQb2ludC55O1xyXG4gICAgICAgICAgICBsZXQgeDIgPSB0aGlzLngyO1xyXG4gICAgICAgICAgICBsZXQgeTIgPSB0aGlzLnkyO1xyXG4gICAgICAgICAgICBsZXQgciA9IHRoaXMucmFkaXVzO1xyXG5cclxuICAgICAgICAgICAgbGV0IHhhID0gKHgyIC0geDEpIC8gMjtcclxuICAgICAgICAgICAgbGV0IHlhID0gKHkyIC0geTEpIC8gMjtcclxuXHJcbiAgICAgICAgICAgIGxldCB4MCA9IHgxICsgeGE7XHJcbiAgICAgICAgICAgIGxldCB5MCA9IHkxICsgeWE7XHJcblxyXG4gICAgICAgICAgICBsZXQgYSA9IE1hdGguaHlwb3QoeGEsIHlhKTtcclxuICAgICAgICAgICAgbGV0IGIgPSBNYXRoLnNxcnQociAqIHIgLSBhICogYSk7XHJcblxyXG4gICAgICAgICAgICBsZXQgY3ggPSB4MCArIGIgKiB5YSAvIGE7XHJcbiAgICAgICAgICAgIGxldCBjeSA9IHkwIC0gYiAqIHhhIC8gYTtcclxuXHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGN4LCBjeSk7XHJcbiAgICAgICAgfSovXHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEBpZ25vcmVcclxuICovXHJcbmNsYXNzIExpbmVUbyBleHRlbmRzIE9wIHtcclxuICAgIGNvbnN0cnVjdG9yKHgsIHkpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInhcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogeFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInlcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogeVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgcGF0aChjb250ZXh0KSB7XHJcbiAgICAgICAgY29udGV4dC5saW5lVG8odGhpcy54LCB0aGlzLnkpO1xyXG4gICAgfVxyXG4gICAgYWRkQm91bmRzKGJvdW5kcykge1xyXG4gICAgICAgIHNldFBvaW50KGJvdW5kcywgeyB4OiB0aGlzLngsIHk6IHRoaXMueSB9KTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQGlnbm9yZVxyXG4gKi9cclxuY2xhc3MgTW92ZVRvIGV4dGVuZHMgT3Age1xyXG4gICAgY29uc3RydWN0b3IoeCwgeSkge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwieFwiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiB4XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwieVwiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiB5XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBwYXRoKGNvbnRleHQpIHtcclxuICAgICAgICBjb250ZXh0Lm1vdmVUbyh0aGlzLngsIHRoaXMueSk7XHJcbiAgICB9XHJcbiAgICBhZGRCb3VuZHMoYm91bmRzKSB7XHJcbiAgICAgICAgc2V0UG9pbnQoYm91bmRzLCB7IHg6IHRoaXMueCwgeTogdGhpcy55IH0pO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBAaWdub3JlXHJcbiAqL1xyXG5jbGFzcyBDbG9zZVBhdGggZXh0ZW5kcyBPcCB7XHJcbiAgICBwYXRoKGNvbnRleHQpIHtcclxuICAgICAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBAaWdub3JlXHJcbiAqL1xyXG5jbGFzcyBCZXppZXJDdXJ2ZVRvIGV4dGVuZHMgT3Age1xyXG4gICAgY29uc3RydWN0b3IoY3BYLCBjcFksIGNwWDIsIGNwWTIsIHRvWCwgdG9ZKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJjcFhcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogY3BYXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiY3BZXCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IGNwWVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNwWDJcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogY3BYMlxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNwWTJcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogY3BZMlxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInRvWFwiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiB0b1hcclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ0b1lcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogdG9ZXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBwYXRoKGNvbnRleHQpIHtcclxuICAgICAgICBjb250ZXh0LmJlemllckN1cnZlVG8odGhpcy5jcFgsIHRoaXMuY3BZLCB0aGlzLmNwWDIsIHRoaXMuY3BZMiwgdGhpcy50b1gsIHRoaXMudG9ZKTtcclxuICAgIH1cclxuICAgIC8vIFRPRE86IE9LP1xyXG4gICAgYWRkQm91bmRzKGJvdW5kcykge1xyXG4gICAgICAgIHNldFBvaW50KGJvdW5kcywgeyB4OiB0aGlzLmNwWCwgeTogdGhpcy5jcFkgfSk7XHJcbiAgICAgICAgc2V0UG9pbnQoYm91bmRzLCB7IHg6IHRoaXMuY3BYMiwgeTogdGhpcy5jcFkyIH0pO1xyXG4gICAgICAgIHNldFBvaW50KGJvdW5kcywgeyB4OiB0aGlzLnRvWCwgeTogdGhpcy50b1kgfSk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEBpZ25vcmVcclxuICovXHJcbmNsYXNzIFF1YWRyYXRpY0N1cnZlVG8gZXh0ZW5kcyBPcCB7XHJcbiAgICBjb25zdHJ1Y3RvcihjcFgsIGNwWSwgdG9YLCB0b1kpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNwWFwiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiBjcFhcclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJjcFlcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogY3BZXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwidG9YXCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IHRvWFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInRvWVwiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiB0b1lcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHBhdGgoY29udGV4dCkge1xyXG4gICAgICAgIGNvbnRleHQucXVhZHJhdGljQ3VydmVUbyh0aGlzLmNwWCwgdGhpcy5jcFksIHRoaXMudG9YLCB0aGlzLnRvWSk7XHJcbiAgICB9XHJcbiAgICAvLyBUT0RPOiBPSz9cclxuICAgIGFkZEJvdW5kcyhib3VuZHMpIHtcclxuICAgICAgICBzZXRQb2ludChib3VuZHMsIHsgeDogdGhpcy5jcFgsIHk6IHRoaXMuY3BZIH0pO1xyXG4gICAgICAgIHNldFBvaW50KGJvdW5kcywgeyB4OiB0aGlzLnRvWCwgeTogdGhpcy50b1kgfSk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEBpZ25vcmVcclxuICovXHJcbmNsYXNzIFNoYWRvdyBleHRlbmRzIE9wIHtcclxuICAgIGNvbnN0cnVjdG9yKGNvbG9yLCBibHVyLCBvZmZzZXRYLCBvZmZzZXRZLCBvcGFjaXR5KSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJjb2xvclwiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiBjb2xvclxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImJsdXJcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogYmx1clxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm9mZnNldFhcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogb2Zmc2V0WFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm9mZnNldFlcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogb2Zmc2V0WVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm9wYWNpdHlcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogb3BhY2l0eVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgY29sb3JpemUoY29udGV4dCwgX2ZvcmNlQ29sb3IpIHtcclxuICAgICAgICBpZiAodGhpcy5vcGFjaXR5KSB7XHJcbiAgICAgICAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gdGhpcy5jb2xvcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29udGV4dC5zaGFkb3dDb2xvciA9IHRoaXMuY29sb3I7XHJcbiAgICAgICAgY29udGV4dC5zaGFkb3dCbHVyID0gdGhpcy5ibHVyO1xyXG4gICAgICAgIGNvbnRleHQuc2hhZG93T2Zmc2V0WCA9IHRoaXMub2Zmc2V0WDtcclxuICAgICAgICBjb250ZXh0LnNoYWRvd09mZnNldFkgPSB0aGlzLm9mZnNldFk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEBpZ25vcmVcclxuICovXHJcbmNsYXNzIEdyYXBoaWNzSW1hZ2UgZXh0ZW5kcyBPcCB7XHJcbiAgICBjb25zdHJ1Y3RvcihpbWFnZSwgd2lkdGgsIGhlaWdodCwgeCwgeSkge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiaW1hZ2VcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogaW1hZ2VcclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ3aWR0aFwiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiB3aWR0aFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImhlaWdodFwiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiBoZWlnaHRcclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ4XCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IHhcclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ5XCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IHlcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHBhdGgoY29udGV4dCkge1xyXG4gICAgICAgIGNvbnRleHQuZHJhd0ltYWdlKHRoaXMuaW1hZ2UsIHRoaXMueCwgdGhpcy55LCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XHJcbiAgICB9XHJcbiAgICAvLyBUT0RPOiBPSz9cclxuICAgIGFkZEJvdW5kcyhib3VuZHMpIHtcclxuICAgICAgICBzZXRQb2ludChib3VuZHMsIHsgeDogdGhpcy54LCB5OiB0aGlzLnkgfSk7XHJcbiAgICAgICAgc2V0UG9pbnQoYm91bmRzLCB7IHg6IHRoaXMud2lkdGgsIHk6IHRoaXMuaGVpZ2h0IH0pO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBAaWdub3JlXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgQ2FudmFzR3JhcGhpY3MgZXh0ZW5kcyBDYW52YXNEaXNwbGF5T2JqZWN0IHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX29wZXJhdGlvbnNcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogW11cclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJibGVuZE1vZGVcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogQmxlbmRNb2RlLk5PUk1BTFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9oYXNTaGFkb3dzXCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IGZhbHNlXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX2ZpbGxBbHBoYVwiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfc3Ryb2tlQWxwaGFcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBjbGVhcigpIHtcclxuICAgICAgICBzdXBlci5jbGVhcigpO1xyXG4gICAgICAgIHRoaXMuX29wZXJhdGlvbnMubGVuZ3RoID0gMDtcclxuICAgIH1cclxuICAgIF9wdXNoT3Aob3ApIHtcclxuICAgICAgICB0aGlzLl9vcGVyYXRpb25zLnB1c2gob3ApO1xyXG4gICAgfVxyXG4gICAgYmVnaW5GaWxsKGNvbG9yLCBhbHBoYSA9IDEpIHtcclxuICAgICAgICB0aGlzLl9maWxsQWxwaGEgPSBhbHBoYTtcclxuICAgICAgICBpZiAoY29sb3IpIHtcclxuICAgICAgICAgICAgaWYgKGNvbG9yIGluc3RhbmNlb2YgQ29sb3IpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3B1c2hPcChuZXcgQmVnaW5GaWxsKGNvbG9yLnRvQ1NTKGFscGhhKSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pc01lYXN1cmVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3B1c2hPcChuZXcgQmVnaW5GaWxsKGNvbG9yKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3B1c2hPcChuZXcgQmVnaW5GaWxsKFwicmdiYSgwLCAwLCAwLCBcIiArIGFscGhhICsgXCIpXCIpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbmRGaWxsKCkge1xyXG4gICAgICAgIHRoaXMuX3B1c2hPcChuZXcgRW5kRmlsbCh0aGlzLl9oYXNTaGFkb3dzKSk7XHJcbiAgICB9XHJcbiAgICBlbmRTdHJva2UoKSB7XHJcbiAgICAgICAgdGhpcy5fcHVzaE9wKG5ldyBFbmRTdHJva2UoKSk7XHJcbiAgICB9XHJcbiAgICBiZWdpblBhdGgoKSB7XHJcbiAgICAgICAgdGhpcy5fcHVzaE9wKG5ldyBCZWdpblBhdGgoKSk7XHJcbiAgICB9XHJcbiAgICBsaW5lU3R5bGUod2lkdGggPSAwLCBjb2xvciwgYWxwaGEgPSAxLCBsaW5lSm9pbikge1xyXG4gICAgICAgIHRoaXMuX3N0cm9rZUFscGhhID0gYWxwaGE7XHJcbiAgICAgICAgaWYgKGNvbG9yKSB7XHJcbiAgICAgICAgICAgIGlmIChjb2xvciBpbnN0YW5jZW9mIENvbG9yKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9wdXNoT3AobmV3IExpbmVTdHlsZSh3aWR0aCwgY29sb3IudG9DU1MoYWxwaGEpLCBsaW5lSm9pbikpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcHVzaE9wKG5ldyBMaW5lU3R5bGUod2lkdGgsIGNvbG9yLCBsaW5lSm9pbikpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLl9wdXNoT3AobmV3IExpbmVTdHlsZSh3aWR0aCwgXCJyZ2JhKDAsIDAsIDAsIFwiICsgYWxwaGEgKyBcIilcIiwgbGluZUpvaW4pKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBzZXRMaW5lRGFzaChkYXNoKSB7XHJcbiAgICAgICAgdGhpcy5fcHVzaE9wKG5ldyBMaW5lRGFzaChkYXNoID8gZGFzaCA6IFtdKSk7XHJcbiAgICB9XHJcbiAgICBzZXRMaW5lRGFzaE9mZnNldChkYXNoT2Zmc2V0ID0gMCkge1xyXG4gICAgICAgIHRoaXMuX3B1c2hPcChuZXcgTGluZURhc2hPZmZzZXQoZGFzaE9mZnNldCkpO1xyXG4gICAgfVxyXG4gICAgZHJhd1JlY3QoeCwgeSwgd2lkdGgsIGhlaWdodCkge1xyXG4gICAgICAgIHRoaXMuX3B1c2hPcChuZXcgRHJhd1JlY3QoeCwgeSwgd2lkdGgsIGhlaWdodCkpO1xyXG4gICAgfVxyXG4gICAgZHJhd0NpcmNsZSh4LCB5LCByYWRpdXMpIHtcclxuICAgICAgICB0aGlzLl9wdXNoT3AobmV3IERyYXdDaXJjbGUoeCwgeSwgcmFkaXVzKSk7XHJcbiAgICB9XHJcbiAgICBkcmF3RWxsaXBzZSh4LCB5LCByYWRpdXNYLCByYWRpdXNZKSB7XHJcbiAgICAgICAgdGhpcy5fcHVzaE9wKG5ldyBEcmF3RWxsaXBzZSh4LCB5LCByYWRpdXNYLCByYWRpdXNZKSk7XHJcbiAgICB9XHJcbiAgICBhcmMoY3gsIGN5LCByYWRpdXMsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCBhbnRpY2xvY2t3aXNlID0gZmFsc2UpIHtcclxuICAgICAgICB0aGlzLl9wdXNoT3AobmV3IEFyYyhjeCwgY3ksIHJhZGl1cywgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIGFudGljbG9ja3dpc2UpKTtcclxuICAgIH1cclxuICAgIGFyY1RvKHgxLCB5MSwgeDIsIHkyLCByYWRpdXMpIHtcclxuICAgICAgICB0aGlzLl9wdXNoT3AobmV3IEFyY1RvKHgxLCB5MSwgeDIsIHkyLCByYWRpdXMpKTtcclxuICAgIH1cclxuICAgIGxpbmVUbyh4LCB5KSB7XHJcbiAgICAgICAgdGhpcy5fcHVzaE9wKG5ldyBMaW5lVG8oeCwgeSkpO1xyXG4gICAgfVxyXG4gICAgbW92ZVRvKHgsIHkpIHtcclxuICAgICAgICB0aGlzLl9wdXNoT3AobmV3IE1vdmVUbyh4LCB5KSk7XHJcbiAgICB9XHJcbiAgICBiZXppZXJDdXJ2ZVRvKGNwWCwgY3BZLCBjcFgyLCBjcFkyLCB0b1gsIHRvWSkge1xyXG4gICAgICAgIHRoaXMuX3B1c2hPcChuZXcgQmV6aWVyQ3VydmVUbyhjcFgsIGNwWSwgY3BYMiwgY3BZMiwgdG9YLCB0b1kpKTtcclxuICAgIH1cclxuICAgIHF1YWRyYXRpY0N1cnZlVG8oY3BYLCBjcFksIHRvWCwgdG9ZKSB7XHJcbiAgICAgICAgdGhpcy5fcHVzaE9wKG5ldyBRdWFkcmF0aWNDdXJ2ZVRvKGNwWCwgY3BZLCB0b1gsIHRvWSkpO1xyXG4gICAgfVxyXG4gICAgY2xvc2VQYXRoKCkge1xyXG4gICAgICAgIHRoaXMuX3B1c2hPcChuZXcgQ2xvc2VQYXRoKCkpO1xyXG4gICAgfVxyXG4gICAgc2hhZG93KGNvbG9yLCBibHVyID0gMCwgb2Zmc2V0WCA9IDAsIG9mZnNldFkgPSAwLCBvcGFjaXR5KSB7XHJcbiAgICAgICAgdGhpcy5faGFzU2hhZG93cyA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5fcHVzaE9wKG5ldyBTaGFkb3cob3BhY2l0eSA/IGNvbG9yLnRvQ1NTKG9wYWNpdHkpIDogY29sb3IudG9DU1ModGhpcy5fZmlsbEFscGhhIHx8IHRoaXMuX3N0cm9rZUFscGhhKSwgYmx1ciwgb2Zmc2V0WCwgb2Zmc2V0WSkpO1xyXG4gICAgfVxyXG4gICAgaW1hZ2UoaW1hZ2UsIHdpZHRoLCBoZWlnaHQsIHgsIHkpIHtcclxuICAgICAgICB0aGlzLl9wdXNoT3AobmV3IEdyYXBoaWNzSW1hZ2UoaW1hZ2UsIHdpZHRoLCBoZWlnaHQsIHgsIHkpKTtcclxuICAgIH1cclxuICAgIC8vIGh0dHBzOi8vc3Znd2cub3JnL3N2ZzItZHJhZnQvcGF0aHMuaHRtbCNEUHJvcGVydHlcclxuICAgIC8vIFRPRE8gYmV0dGVyIGVycm9yIGNoZWNraW5nXHJcbiAgICBzdmdQYXRoKHBhdGgpIHtcclxuICAgICAgICBsZXQgeCA9IDA7XHJcbiAgICAgICAgbGV0IHkgPSAwO1xyXG4gICAgICAgIGxldCBjcHggPSBudWxsO1xyXG4gICAgICAgIGxldCBjcHkgPSBudWxsO1xyXG4gICAgICAgIGxldCBxY3B4ID0gbnVsbDtcclxuICAgICAgICBsZXQgcWNweSA9IG51bGw7XHJcbiAgICAgICAgY29uc3QgU0VHTUVOVFNfUkVHRVhQID0gLyhbTW1aekxsSGhWdkNjU3NRcVR0QWFdKShbXk1tWnpMbEhoVnZDY1NzUXFUdEFhXSopL2c7XHJcbiAgICAgICAgY29uc3QgQVJHU19SRUdFWFAgPSAvW1xcdTAwMDlcXHUwMDIwXFx1MDAwQVxcdTAwMENcXHUwMDBEXSooW1xcK1xcLV0/WzAtOV0qXFwuP1swLTldKyg/OltlRV1bXFwrXFwtXT9bMC05XSspPylbXFx1MDAwOVxcdTAwMjBcXHUwMDBBXFx1MDAwQ1xcdTAwMERdKiw/L2c7XHJcbiAgICAgICAgbGV0IG1hdGNoO1xyXG4gICAgICAgIHdoaWxlICgobWF0Y2ggPSBTRUdNRU5UU19SRUdFWFAuZXhlYyhwYXRoKSkgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgY29uc3QgbmFtZSA9IG1hdGNoWzFdO1xyXG4gICAgICAgICAgICBjb25zdCByZXN0ID0gbWF0Y2hbMl07XHJcbiAgICAgICAgICAgIGNvbnN0IGFyZ3MgPSBbXTtcclxuICAgICAgICAgICAgd2hpbGUgKChtYXRjaCA9IEFSR1NfUkVHRVhQLmV4ZWMocmVzdCkpICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBhcmdzLnB1c2gobWF0Y2hbMV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIFJlc2V0IGNvbnRyb2wgcG9pbnRcclxuICAgICAgICAgICAgaWYgKG5hbWUgIT09IFwiU1wiICYmIG5hbWUgIT09IFwic1wiICYmIG5hbWUgIT09IFwiQ1wiICYmIG5hbWUgIT09IFwiY1wiKSB7XHJcbiAgICAgICAgICAgICAgICBjcHggPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgY3B5ID0gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBSZXNldCBjb250cm9sIHBvaW50XHJcbiAgICAgICAgICAgIGlmIChuYW1lICE9PSBcIlFcIiAmJiBuYW1lICE9PSBcInFcIiAmJiBuYW1lICE9PSBcIlRcIiAmJiBuYW1lICE9PSBcInRcIikge1xyXG4gICAgICAgICAgICAgICAgcWNweCA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICBxY3B5ID0gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBzd2l0Y2ggKG5hbWUpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJNXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgY2hlY2tFdmVuQXJncyhuYW1lLCBhcmdzLmxlbmd0aCwgMik7XHJcbiAgICAgICAgICAgICAgICAgICAgeCA9ICthcmdzWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgIHkgPSArYXJnc1sxXTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm1vdmVUbyh4LCB5KTtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMjsgaSA8IGFyZ3MubGVuZ3RoOyBpICs9IDIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgeCA9ICthcmdzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB5ID0gK2FyZ3NbaSArIDFdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxpbmVUbyh4LCB5KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwibVwiOlxyXG4gICAgICAgICAgICAgICAgICAgIGNoZWNrRXZlbkFyZ3MobmFtZSwgYXJncy5sZW5ndGgsIDIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHggKz0gK2FyZ3NbMF07XHJcbiAgICAgICAgICAgICAgICAgICAgeSArPSArYXJnc1sxXTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm1vdmVUbyh4LCB5KTtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMjsgaSA8IGFyZ3MubGVuZ3RoOyBpICs9IDIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgeCArPSArYXJnc1tpXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgeSArPSArYXJnc1tpICsgMV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubGluZVRvKHgsIHkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJMXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgY2hlY2tFdmVuQXJncyhuYW1lLCBhcmdzLmxlbmd0aCwgMik7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSArPSAyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHggPSArYXJnc1tpXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgeSA9ICthcmdzW2kgKyAxXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5saW5lVG8oeCwgeSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBcImxcIjpcclxuICAgICAgICAgICAgICAgICAgICBjaGVja0V2ZW5BcmdzKG5hbWUsIGFyZ3MubGVuZ3RoLCAyKTtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpICs9IDIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgeCArPSArYXJnc1tpXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgeSArPSArYXJnc1tpICsgMV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubGluZVRvKHgsIHkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJIXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgY2hlY2tNaW5BcmdzKG5hbWUsIGFyZ3MubGVuZ3RoLCAxKTtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgeCA9ICthcmdzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxpbmVUbyh4LCB5KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwiaFwiOlxyXG4gICAgICAgICAgICAgICAgICAgIGNoZWNrTWluQXJncyhuYW1lLCBhcmdzLmxlbmd0aCwgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHggKz0gK2FyZ3NbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubGluZVRvKHgsIHkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJWXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgY2hlY2tNaW5BcmdzKG5hbWUsIGFyZ3MubGVuZ3RoLCAxKTtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgeSA9ICthcmdzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxpbmVUbyh4LCB5KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwidlwiOlxyXG4gICAgICAgICAgICAgICAgICAgIGNoZWNrTWluQXJncyhuYW1lLCBhcmdzLmxlbmd0aCwgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHkgKz0gK2FyZ3NbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubGluZVRvKHgsIHkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJDXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgY2hlY2tFdmVuQXJncyhuYW1lLCBhcmdzLmxlbmd0aCwgNik7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSArPSA2KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHgxID0gK2FyZ3NbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHkxID0gK2FyZ3NbaSArIDFdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjcHggPSArYXJnc1tpICsgMl07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweSA9ICthcmdzW2kgKyAzXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgeCA9ICthcmdzW2kgKyA0XTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgeSA9ICthcmdzW2kgKyA1XTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5iZXppZXJDdXJ2ZVRvKHgxLCB5MSwgY3B4LCBjcHksIHgsIHkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJjXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgY2hlY2tFdmVuQXJncyhuYW1lLCBhcmdzLmxlbmd0aCwgNik7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSArPSA2KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHgxID0gK2FyZ3NbaV0gKyB4O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB5MSA9ICthcmdzW2kgKyAxXSArIHk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweCA9ICthcmdzW2kgKyAyXSArIHg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweSA9ICthcmdzW2kgKyAzXSArIHk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHggKz0gK2FyZ3NbaSArIDRdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB5ICs9ICthcmdzW2kgKyA1XTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5iZXppZXJDdXJ2ZVRvKHgxLCB5MSwgY3B4LCBjcHksIHgsIHkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJTXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgY2hlY2tFdmVuQXJncyhuYW1lLCBhcmdzLmxlbmd0aCwgNCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNweCA9PT0gbnVsbCB8fCBjcHkgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3B4ID0geDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3B5ID0geTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSArPSA0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHgxID0gMiAqIHggLSBjcHg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHkxID0gMiAqIHkgLSBjcHk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweCA9ICthcmdzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjcHkgPSArYXJnc1tpICsgMV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHggPSArYXJnc1tpICsgMl07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHkgPSArYXJnc1tpICsgM107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYmV6aWVyQ3VydmVUbyh4MSwgeTEsIGNweCwgY3B5LCB4LCB5KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwic1wiOlxyXG4gICAgICAgICAgICAgICAgICAgIGNoZWNrRXZlbkFyZ3MobmFtZSwgYXJncy5sZW5ndGgsIDQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjcHggPT09IG51bGwgfHwgY3B5ID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweCA9IHg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweSA9IHk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkgKz0gNCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB4MSA9IDIgKiB4IC0gY3B4O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB5MSA9IDIgKiB5IC0gY3B5O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjcHggPSArYXJnc1tpXSArIHg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweSA9ICthcmdzW2kgKyAxXSArIHk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHggKz0gK2FyZ3NbaSArIDJdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB5ICs9ICthcmdzW2kgKyAzXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5iZXppZXJDdXJ2ZVRvKHgxLCB5MSwgY3B4LCBjcHksIHgsIHkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJRXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgY2hlY2tFdmVuQXJncyhuYW1lLCBhcmdzLmxlbmd0aCwgNCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSArPSA0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHFjcHggPSArYXJnc1tpXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcWNweSA9ICthcmdzW2kgKyAxXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgeCA9ICthcmdzW2kgKyAyXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgeSA9ICthcmdzW2kgKyAzXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5xdWFkcmF0aWNDdXJ2ZVRvKHFjcHgsIHFjcHksIHgsIHkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJxXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgY2hlY2tFdmVuQXJncyhuYW1lLCBhcmdzLmxlbmd0aCwgNCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSArPSA0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHFjcHggPSArYXJnc1tpXSArIHg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHFjcHkgPSArYXJnc1tpICsgMV0gKyB5O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB4ICs9ICthcmdzW2kgKyAyXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgeSArPSArYXJnc1tpICsgM107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucXVhZHJhdGljQ3VydmVUbyhxY3B4LCBxY3B5LCB4LCB5KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwiVFwiOlxyXG4gICAgICAgICAgICAgICAgICAgIGNoZWNrRXZlbkFyZ3MobmFtZSwgYXJncy5sZW5ndGgsIDIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChxY3B4ID09PSBudWxsIHx8IHFjcHkgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcWNweCA9IHg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHFjcHkgPSB5O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpICs9IDIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcWNweCA9IDIgKiB4IC0gcWNweDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcWNweSA9IDIgKiB5IC0gcWNweTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgeCA9ICthcmdzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB5ID0gK2FyZ3NbaSArIDFdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnF1YWRyYXRpY0N1cnZlVG8ocWNweCwgcWNweSwgeCwgeSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBcInRcIjpcclxuICAgICAgICAgICAgICAgICAgICBjaGVja0V2ZW5BcmdzKG5hbWUsIGFyZ3MubGVuZ3RoLCAyKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocWNweCA9PT0gbnVsbCB8fCBxY3B5ID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHFjcHggPSB4O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBxY3B5ID0geTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSArPSAyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHFjcHggPSAyICogeCAtIHFjcHg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHFjcHkgPSAyICogeSAtIHFjcHk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHggKz0gK2FyZ3NbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHkgKz0gK2FyZ3NbaSArIDFdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnF1YWRyYXRpY0N1cnZlVG8ocWNweCwgcWNweSwgeCwgeSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBcIkFcIjpcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJhXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVsYXRpdmUgPSAobmFtZSA9PT0gXCJhXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHNwbGl0QXJjRmxhZ3MoYXJncyk7XHJcbiAgICAgICAgICAgICAgICAgICAgY2hlY2tFdmVuQXJncyhuYW1lLCBhcmdzLmxlbmd0aCwgNyk7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSArPSA3KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBjeCA9ICthcmdzW2kgKyA1XTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGN5ID0gK2FyZ3NbaSArIDZdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVsYXRpdmUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN4ICs9IHg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjeSArPSB5O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGJzID0gYXJjVG9CZXppZXIoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHg6IHgsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBweTogeSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJ4OiArYXJnc1tpXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJ5OiArYXJnc1tpICsgMV0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4QXhpc1JvdGF0aW9uOiArYXJnc1tpICsgMl0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXJnZUFyY0ZsYWc6IGFzc2VydEJpbmFyeSgrYXJnc1tpICsgM10pLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dlZXBGbGFnOiBhc3NlcnRCaW5hcnkoK2FyZ3NbaSArIDRdKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN4LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3ksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAkYXJyYXkuZWFjaChicywgKGIpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYmV6aWVyQ3VydmVUbyhiLngxLCBiLnkxLCBiLngyLCBiLnkyLCBiLngsIGIueSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4ID0gYi54O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeSA9IGIueTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBcIlpcIjpcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJ6XCI6XHJcbiAgICAgICAgICAgICAgICAgICAgY2hlY2tBcmdzKG5hbWUsIGFyZ3MubGVuZ3RoLCAwKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNsb3NlUGF0aCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgX3J1blBhdGgoY29udGV4dCkge1xyXG4gICAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XHJcbiAgICAgICAgJGFycmF5LmVhY2godGhpcy5fb3BlcmF0aW9ucywgKG9wKSA9PiB7XHJcbiAgICAgICAgICAgIG9wLnBhdGgoY29udGV4dCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBfcmVuZGVyKHN0YXR1cykge1xyXG4gICAgICAgIHN1cGVyLl9yZW5kZXIoc3RhdHVzKTtcclxuICAgICAgICBjb25zdCBsYXllckRpcnR5ID0gc3RhdHVzLmxheWVyLmRpcnR5O1xyXG4gICAgICAgIGNvbnN0IGludGVyYWN0aXZlID0gdGhpcy5faXNJbnRlcmFjdGl2ZShzdGF0dXMpO1xyXG4gICAgICAgIGlmIChsYXllckRpcnR5IHx8IGludGVyYWN0aXZlKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNvbnRleHQgPSBzdGF0dXMubGF5ZXIuY29udGV4dDtcclxuICAgICAgICAgICAgY29uc3QgZ2hvc3RDb250ZXh0ID0gdGhpcy5fcmVuZGVyZXIuX2dob3N0TGF5ZXIuY29udGV4dDtcclxuICAgICAgICAgICAgaWYgKGxheWVyRGlydHkpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRleHQuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gdGhpcy5ibGVuZE1vZGU7XHJcbiAgICAgICAgICAgICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGxldCBjb2xvcjtcclxuICAgICAgICAgICAgaWYgKGludGVyYWN0aXZlKSB7XHJcbiAgICAgICAgICAgICAgICBnaG9zdENvbnRleHQuYmVnaW5QYXRoKCk7XHJcbiAgICAgICAgICAgICAgICBjb2xvciA9IHRoaXMuX2dldENvbG9ySWQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAkYXJyYXkuZWFjaCh0aGlzLl9vcGVyYXRpb25zLCAob3ApID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChsYXllckRpcnR5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb3AucGF0aChjb250ZXh0KTtcclxuICAgICAgICAgICAgICAgICAgICBvcC5jb2xvcml6ZShjb250ZXh0LCB1bmRlZmluZWQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGludGVyYWN0aXZlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb3AucGF0aChnaG9zdENvbnRleHQpO1xyXG4gICAgICAgICAgICAgICAgICAgIG9wLmNvbG9yaXplKGdob3N0Q29udGV4dCwgY29sb3IpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZW5kZXJEZXRhY2hlZChjb250ZXh0KSB7XHJcbiAgICAgICAgaWYgKHRoaXMudmlzaWJsZSkge1xyXG4gICAgICAgICAgICB0aGlzLl9zZXRNYXRyaXgoKTtcclxuICAgICAgICAgICAgY29udGV4dC5zYXZlKCk7XHJcbiAgICAgICAgICAgIC8vIFdlIG11c3QgYXBwbHkgdGhlIG1hc2sgYmVmb3JlIHdlIHRyYW5zZm9ybSB0aGUgZWxlbWVudFxyXG4gICAgICAgICAgICBjb25zdCBtYXNrID0gdGhpcy5tYXNrO1xyXG4gICAgICAgICAgICBpZiAobWFzaykge1xyXG4gICAgICAgICAgICAgICAgbWFzay5fc2V0TWF0cml4KCk7XHJcbiAgICAgICAgICAgICAgICBtYXNrLl90cmFuc2Zvcm0oY29udGV4dCwgMSk7XHJcbiAgICAgICAgICAgICAgICBtYXNrLl9ydW5QYXRoKGNvbnRleHQpO1xyXG4gICAgICAgICAgICAgICAgY29udGV4dC5jbGlwKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gVE9ETyBoYW5kbGUgY29tcG91bmRBbHBoYSBzb21laG93ID9cclxuICAgICAgICAgICAgY29udGV4dC5nbG9iYWxBbHBoYSA9IHRoaXMuY29tcG91bmRBbHBoYSAqIHRoaXMuYWxwaGE7XHJcbiAgICAgICAgICAgIHRoaXMuX3RyYW5zZm9ybShjb250ZXh0LCAxKTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuZmlsdGVyKSB7XHJcbiAgICAgICAgICAgICAgICBjb250ZXh0LmZpbHRlciA9IHRoaXMuZmlsdGVyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnRleHQuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gdGhpcy5ibGVuZE1vZGU7XHJcbiAgICAgICAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XHJcbiAgICAgICAgICAgICRhcnJheS5lYWNoKHRoaXMuX29wZXJhdGlvbnMsIChvcCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgb3AucGF0aChjb250ZXh0KTtcclxuICAgICAgICAgICAgICAgIG9wLmNvbG9yaXplKGNvbnRleHQsIHVuZGVmaW5lZCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBjb250ZXh0LnJlc3RvcmUoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBfYWRkQm91bmRzKGJvdW5kcykge1xyXG4gICAgICAgIGlmICh0aGlzLnZpc2libGUgJiYgdGhpcy5pc01lYXN1cmVkKSB7XHJcbiAgICAgICAgICAgICRhcnJheS5lYWNoKHRoaXMuX29wZXJhdGlvbnMsIChvcCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgb3AuYWRkQm91bmRzKGJvdW5kcyk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4vKipcclxuICogQGlnbm9yZVxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIENhbnZhc1RleHQgZXh0ZW5kcyBDYW52YXNEaXNwbGF5T2JqZWN0IHtcclxuICAgIGNvbnN0cnVjdG9yKHJlbmRlcmVyLCB0ZXh0LCBzdHlsZSkge1xyXG4gICAgICAgIHN1cGVyKHJlbmRlcmVyKTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ0ZXh0XCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInN0eWxlXCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInJlc29sdXRpb25cIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogMVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInRleHRWaXNpYmxlXCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IHRydWVcclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfdGV4dEluZm9cIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX29yaWdpbmFsU2NhbGVcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogMVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMudGV4dCA9IHRleHQ7XHJcbiAgICAgICAgdGhpcy5zdHlsZSA9IHN0eWxlO1xyXG4gICAgfVxyXG4gICAgaW52YWxpZGF0ZUJvdW5kcygpIHtcclxuICAgICAgICBzdXBlci5pbnZhbGlkYXRlQm91bmRzKCk7XHJcbiAgICAgICAgdGhpcy5fdGV4dEluZm8gPSB1bmRlZmluZWQ7XHJcbiAgICB9XHJcbiAgICBfc2hhcmVkKGNvbnRleHQpIHtcclxuICAgICAgICBpZiAodGhpcy5zdHlsZS50ZXh0QWxpZ24pIHtcclxuICAgICAgICAgICAgY29udGV4dC50ZXh0QWxpZ24gPSB0aGlzLnN0eWxlLnRleHRBbGlnbjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuc3R5bGUuZGlyZWN0aW9uKSB7XHJcbiAgICAgICAgICAgIGNvbnRleHQuZGlyZWN0aW9uID0gdGhpcy5zdHlsZS5kaXJlY3Rpb247XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLnN0eWxlLnRleHRCYXNlbGluZSkge1xyXG4gICAgICAgICAgICBjb250ZXh0LnRleHRCYXNlbGluZSA9IHRoaXMuc3R5bGUudGV4dEJhc2VsaW5lO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIF9wcmVyZW5kZXIoc3RhdHVzLCBpZ25vcmVHaG9zdCA9IGZhbHNlLCBpZ25vcmVGb250V2VpZ2h0ID0gZmFsc2UpIHtcclxuICAgICAgICBzdXBlci5fcmVuZGVyKHN0YXR1cyk7XHJcbiAgICAgICAgY29uc3QgY29udGV4dCA9IHN0YXR1cy5sYXllci5jb250ZXh0O1xyXG4gICAgICAgIGNvbnN0IGdob3N0Q29udGV4dCA9IHRoaXMuX3JlbmRlcmVyLl9naG9zdExheWVyLmNvbnRleHQ7XHJcbiAgICAgICAgLy8gRm9udCBzdHlsZVxyXG4gICAgICAgIGNvbnN0IHN0eWxlID0gdGhpcy5zdHlsZTtcclxuICAgICAgICBsZXQgZm9udFN0eWxlID0gdGhpcy5fZ2V0Rm9udFN0eWxlKHVuZGVmaW5lZCwgaWdub3JlRm9udFdlaWdodCk7XHJcbiAgICAgICAgY29udGV4dC5mb250ID0gZm9udFN0eWxlO1xyXG4gICAgICAgIGlmICh0aGlzLl9pc0ludGVyYWN0aXZlKHN0YXR1cykgJiYgIWlnbm9yZUdob3N0KSB7XHJcbiAgICAgICAgICAgIGdob3N0Q29udGV4dC5mb250ID0gZm9udFN0eWxlO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBPdGhlciBwYXJhbWV0ZXJzXHJcbiAgICAgICAgaWYgKHN0eWxlLmZpbGwpIHtcclxuICAgICAgICAgICAgaWYgKHN0eWxlLmZpbGwgaW5zdGFuY2VvZiBDb2xvcikge1xyXG4gICAgICAgICAgICAgICAgY29udGV4dC5maWxsU3R5bGUgPSBzdHlsZS5maWxsLnRvQ1NTKHN0eWxlLmZpbGxPcGFjaXR5ICE9IHVuZGVmaW5lZCA/IHN0eWxlLmZpbGxPcGFjaXR5IDogMSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb250ZXh0LmZpbGxTdHlsZSA9IHN0eWxlLmZpbGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHN0eWxlLnNoYWRvd0NvbG9yKSB7XHJcbiAgICAgICAgICAgIHN0YXR1cy5sYXllci5jb250ZXh0LnNoYWRvd0NvbG9yID0gc3R5bGUuc2hhZG93Q29sb3IudG9DU1Moc3R5bGUuc2hhZG93T3BhY2l0eSB8fCAxKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHN0eWxlLnNoYWRvd0JsdXIpIHtcclxuICAgICAgICAgICAgc3RhdHVzLmxheWVyLmNvbnRleHQuc2hhZG93Qmx1ciA9IHN0eWxlLnNoYWRvd0JsdXI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzdHlsZS5zaGFkb3dPZmZzZXRYKSB7XHJcbiAgICAgICAgICAgIHN0YXR1cy5sYXllci5jb250ZXh0LnNoYWRvd09mZnNldFggPSBzdHlsZS5zaGFkb3dPZmZzZXRYO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc3R5bGUuc2hhZG93T2Zmc2V0WSkge1xyXG4gICAgICAgICAgICBzdGF0dXMubGF5ZXIuY29udGV4dC5zaGFkb3dPZmZzZXRZID0gc3R5bGUuc2hhZG93T2Zmc2V0WTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fc2hhcmVkKGNvbnRleHQpO1xyXG4gICAgICAgIGlmICh0aGlzLl9pc0ludGVyYWN0aXZlKHN0YXR1cykgJiYgIWlnbm9yZUdob3N0KSB7XHJcbiAgICAgICAgICAgIGdob3N0Q29udGV4dC5maWxsU3R5bGUgPSB0aGlzLl9nZXRDb2xvcklkKCk7XHJcbiAgICAgICAgICAgIHRoaXMuX3NoYXJlZChnaG9zdENvbnRleHQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIF9nZXRGb250U3R5bGUoc3R5bGUyLCBpZ25vcmVGb250V2VpZ2h0ID0gZmFsc2UpIHtcclxuICAgICAgICAvLyBQcm9jZXNzIGRlZmF1bHRzXHJcbiAgICAgICAgY29uc3Qgc3R5bGUgPSB0aGlzLnN0eWxlO1xyXG4gICAgICAgIGxldCBmb250U3R5bGUgPSBbXTtcclxuICAgICAgICBpZiAoc3R5bGUyICYmIHN0eWxlMi5mb250VmFyaWFudCkge1xyXG4gICAgICAgICAgICBmb250U3R5bGUucHVzaChzdHlsZTIuZm9udFZhcmlhbnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChzdHlsZS5mb250VmFyaWFudCkge1xyXG4gICAgICAgICAgICBmb250U3R5bGUucHVzaChzdHlsZS5mb250VmFyaWFudCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghaWdub3JlRm9udFdlaWdodCkge1xyXG4gICAgICAgICAgICBpZiAoc3R5bGUyICYmIHN0eWxlMi5mb250V2VpZ2h0KSB7XHJcbiAgICAgICAgICAgICAgICBmb250U3R5bGUucHVzaChzdHlsZTIuZm9udFdlaWdodCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoc3R5bGUuZm9udFdlaWdodCkge1xyXG4gICAgICAgICAgICAgICAgZm9udFN0eWxlLnB1c2goc3R5bGUuZm9udFdlaWdodCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHN0eWxlMiAmJiBzdHlsZTIuZm9udFN0eWxlKSB7XHJcbiAgICAgICAgICAgIGZvbnRTdHlsZS5wdXNoKHN0eWxlMi5mb250U3R5bGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChzdHlsZS5mb250U3R5bGUpIHtcclxuICAgICAgICAgICAgZm9udFN0eWxlLnB1c2goc3R5bGUuZm9udFN0eWxlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHN0eWxlMiAmJiBzdHlsZTIuZm9udFNpemUpIHtcclxuICAgICAgICAgICAgaWYgKCR0eXBlLmlzTnVtYmVyKHN0eWxlMi5mb250U2l6ZSkpIHtcclxuICAgICAgICAgICAgICAgIHN0eWxlMi5mb250U2l6ZSA9IHN0eWxlMi5mb250U2l6ZSArIFwicHhcIjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmb250U3R5bGUucHVzaChzdHlsZTIuZm9udFNpemUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChzdHlsZS5mb250U2l6ZSkge1xyXG4gICAgICAgICAgICBpZiAoJHR5cGUuaXNOdW1iZXIoc3R5bGUuZm9udFNpemUpKSB7XHJcbiAgICAgICAgICAgICAgICBzdHlsZS5mb250U2l6ZSA9IHN0eWxlLmZvbnRTaXplICsgXCJweFwiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZvbnRTdHlsZS5wdXNoKHN0eWxlLmZvbnRTaXplKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHN0eWxlMiAmJiBzdHlsZTIuZm9udEZhbWlseSkge1xyXG4gICAgICAgICAgICBmb250U3R5bGUucHVzaChzdHlsZTIuZm9udEZhbWlseSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHN0eWxlLmZvbnRGYW1pbHkpIHtcclxuICAgICAgICAgICAgZm9udFN0eWxlLnB1c2goc3R5bGUuZm9udEZhbWlseSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGZvbnRTdHlsZS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgZm9udFN0eWxlLnB1c2goXCJBcmlhbFwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZvbnRTdHlsZS5qb2luKFwiIFwiKTtcclxuICAgIH1cclxuICAgIF9yZW5kZXIoc3RhdHVzKSB7XHJcbiAgICAgICAgLy8gV2UgbmVlZCBtZWFzdXJlbWVudHMgaW4gb3JkZXIgdG8gcHJvcGVybHkgcG9zaXRpb24gdGV4dCBmb3IgYWxpZ25tZW50XHJcbiAgICAgICAgaWYgKCF0aGlzLl90ZXh0SW5mbykge1xyXG4gICAgICAgICAgICB0aGlzLl9tZWFzdXJlKHN0YXR1cyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLnRleHRWaXNpYmxlKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGludGVyYWN0aXZlID0gdGhpcy5faXNJbnRlcmFjdGl2ZShzdGF0dXMpO1xyXG4gICAgICAgICAgICBjb25zdCBjb250ZXh0ID0gc3RhdHVzLmxheWVyLmNvbnRleHQ7XHJcbiAgICAgICAgICAgIGNvbnN0IGxheWVyRGlydHkgPSBzdGF0dXMubGF5ZXIuZGlydHk7XHJcbiAgICAgICAgICAgIGNvbnN0IGdob3N0Q29udGV4dCA9IHRoaXMuX3JlbmRlcmVyLl9naG9zdExheWVyLmNvbnRleHQ7XHJcbiAgICAgICAgICAgIGNvbnRleHQuc2F2ZSgpO1xyXG4gICAgICAgICAgICBnaG9zdENvbnRleHQuc2F2ZSgpO1xyXG4gICAgICAgICAgICB0aGlzLl9wcmVyZW5kZXIoc3RhdHVzKTtcclxuICAgICAgICAgICAgLy8gY29uc3QgbGluZXMgPSB0aGlzLnRleHQudG9TdHJpbmcoKS5yZXBsYWNlKC9cXHIvZywgXCJcIikuc3BsaXQoL1xcbi8pO1xyXG4gICAgICAgICAgICAvLyBjb25zdCB4ID0gdGhpcy5fbG9jYWxCb3VuZHMgJiYgKHRoaXMuX2xvY2FsQm91bmRzLmxlZnQgPCAwKSA/IE1hdGguYWJzKHRoaXMuX2xvY2FsQm91bmRzLmxlZnQpIDogMDtcclxuICAgICAgICAgICAgLy8gUHJvY2VzcyB0ZXh0IGluZm8gcHJvZHVjZWQgYnkgX21lYXN1cmUoKVxyXG4gICAgICAgICAgICAkYXJyYXkuZWFjaCh0aGlzLl90ZXh0SW5mbywgKGxpbmUsIF9pbmRleCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgJGFycmF5LmVhY2gobGluZS50ZXh0Q2h1bmtzLCAoY2h1bmssIF9pbmRleCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFNldCBzdHlsZVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjaHVuay5zdHlsZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LnNhdmUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZ2hvc3RDb250ZXh0LnNhdmUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5mb250ID0gY2h1bmsuc3R5bGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9pc0ludGVyYWN0aXZlKHN0YXR1cykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdob3N0Q29udGV4dC5mb250ID0gY2h1bmsuc3R5bGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNodW5rLmZpbGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5zYXZlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gY2h1bmsuZmlsbC50b0NTUygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDb2xvciBkb2VzIG5vdCBhZmZlY3QgZ2hvc3RDb250ZXh0IHNvIHdlIG5vdCBzZXQgaXRcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gRHJhdyB0ZXh0XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxheWVyRGlydHkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5maWxsVGV4dChjaHVuay50ZXh0LCBjaHVuay5vZmZzZXRYLCBsaW5lLm9mZnNldFkgKyBjaHVuay5vZmZzZXRZKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gRHJhdyB1bmRlcmxpbmVcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY2h1bmsudGV4dERlY29yYXRpb24gPT0gXCJ1bmRlcmxpbmVcIiB8fCBjaHVuay50ZXh0RGVjb3JhdGlvbiA9PSBcImxpbmUtdGhyb3VnaFwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCB0aGlja25lc3MgPSAxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgb2Zmc2V0ID0gMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGZvbnRTaXplID0gY2h1bmsuaGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgb2Zmc2V0WCA9IGNodW5rLm9mZnNldFg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAodGhpcy5zdHlsZS50ZXh0QWxpZ24pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJyaWdodFwiOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldFggLT0gY2h1bmsud2lkdGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiY2VudGVyXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0WCAtPSBjaHVuay53aWR0aCAvIDI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNodW5rLnN0eWxlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBmb3JtYXQgPSBUZXh0Rm9ybWF0dGVyLmdldFRleHRTdHlsZShjaHVuay5zdHlsZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGZvcm1hdC5mb250V2VpZ2h0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImJvbGRlclwiOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJib2xkXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIjcwMFwiOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCI4MDBcIjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiOTAwXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaWNrbmVzcyA9IDI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmb250U2l6ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ID0gZm9udFNpemUgLyAyMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgeTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNodW5rLnRleHREZWNvcmF0aW9uID09IFwibGluZS10aHJvdWdoXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHkgPSB0aGlja25lc3MgKyBsaW5lLm9mZnNldFkgKyBjaHVuay5vZmZzZXRZIC0gY2h1bmsuaGVpZ2h0IC8gMjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHkgPSB0aGlja25lc3MgKyBvZmZzZXQgKiAxLjUgKyBsaW5lLm9mZnNldFkgKyBjaHVuay5vZmZzZXRZO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQuc2F2ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2h1bmsuZmlsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5zdHJva2VTdHlsZSA9IGNodW5rLmZpbGwudG9DU1MoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLnN0eWxlLmZpbGwgJiYgdGhpcy5zdHlsZS5maWxsIGluc3RhbmNlb2YgQ29sb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSB0aGlzLnN0eWxlLmZpbGwudG9DU1MoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmxpbmVXaWR0aCA9IHRoaWNrbmVzcyAqIG9mZnNldDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5tb3ZlVG8ob2Zmc2V0WCwgeSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQubGluZVRvKG9mZnNldFggKyBjaHVuay53aWR0aCwgeSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQuc3Ryb2tlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQucmVzdG9yZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoaW50ZXJhY3RpdmUgJiYgdGhpcy5pbnRlcmFjdGl2ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBEcmF3IHRleHQgaW4gZ2hvc3QgY2FudmFzIE9OTFkgaWYgaXQgaXMgc2V0IGFzIGludGVyYWN0aXZlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGV4cGxpY2l0bHkuIFRoaXMgd2F5IHdlIGF2b2lkIGhpdCB0ZXN0IGFub21hbGllcyBjYXVzZWQgYnkgYW50aVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhbGlhc2luZyBvZiB0ZXh0LlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBnaG9zdENvbnRleHQuZmlsbFRleHQoY2h1bmsudGV4dCwgY2h1bmsub2Zmc2V0WCwgbGluZS5vZmZzZXRZICsgY2h1bmsub2Zmc2V0WSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjaHVuay5maWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQucmVzdG9yZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDb2xvciBkb2VzIG5vdCBhZmZlY3QgZ2hvc3RDb250ZXh0IHNvIHdlIG5vdCBzZXQgaXRcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gUmVzZXQgc3R5bGVcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY2h1bmsuc3R5bGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5yZXN0b3JlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGdob3N0Q29udGV4dC5yZXN0b3JlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBjb250ZXh0LnJlc3RvcmUoKTtcclxuICAgICAgICAgICAgZ2hvc3RDb250ZXh0LnJlc3RvcmUoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBfYWRkQm91bmRzKGJvdW5kcykge1xyXG4gICAgICAgIGlmICh0aGlzLnZpc2libGUgJiYgdGhpcy5pc01lYXN1cmVkKSB7XHJcbiAgICAgICAgICAgIC8vaWYgKHRoaXMuX3RleHRWaXNpYmxlKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHggPSB0aGlzLl9tZWFzdXJlKHtcclxuICAgICAgICAgICAgICAgIGluYWN0aXZlOiB0aGlzLmluYWN0aXZlLFxyXG4gICAgICAgICAgICAgICAgbGF5ZXI6IHRoaXMuZ2V0TGF5ZXIoKSxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHNldFBvaW50KGJvdW5kcywgeyB4OiB4LmxlZnQsIHk6IHgudG9wIH0pO1xyXG4gICAgICAgICAgICBzZXRQb2ludChib3VuZHMsIHsgeDogeC5yaWdodCwgeTogeC5ib3R0b20gfSk7XHJcbiAgICAgICAgICAgIC8vfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIF9pZ25vcmVGb250V2VpZ2h0KCkge1xyXG4gICAgICAgIHJldHVybiAvYXBwbGUvaS50ZXN0KG5hdmlnYXRvci52ZW5kb3IpO1xyXG4gICAgfVxyXG4gICAgX21lYXN1cmUoc3RhdHVzKSB7XHJcbiAgICAgICAgY29uc3QgY29udGV4dCA9IHN0YXR1cy5sYXllci5jb250ZXh0O1xyXG4gICAgICAgIGNvbnN0IGdob3N0Q29udGV4dCA9IHRoaXMuX3JlbmRlcmVyLl9naG9zdExheWVyLmNvbnRleHQ7XHJcbiAgICAgICAgY29uc3QgcnRsID0gdGhpcy5zdHlsZS5kaXJlY3Rpb24gPT0gXCJydGxcIjtcclxuICAgICAgICAvLyBSZXNldCB0ZXh0IGluZm9cclxuICAgICAgICB0aGlzLl90ZXh0SW5mbyA9IFtdO1xyXG4gICAgICAgIC8vIEluaXRcclxuICAgICAgICBjb25zdCBvdmVyc2l6ZWRCZWhhdmlvciA9IHRoaXMuc3R5bGUub3ZlcnNpemVkQmVoYXZpb3I7XHJcbiAgICAgICAgY29uc3QgbWF4V2lkdGggPSB0aGlzLnN0eWxlLm1heFdpZHRoO1xyXG4gICAgICAgIGNvbnN0IHRydW5jYXRlID0gJHR5cGUuaXNOdW1iZXIobWF4V2lkdGgpICYmIG92ZXJzaXplZEJlaGF2aW9yID09IFwidHJ1bmNhdGVcIjtcclxuICAgICAgICBjb25zdCB3cmFwID0gJHR5cGUuaXNOdW1iZXIobWF4V2lkdGgpICYmIChvdmVyc2l6ZWRCZWhhdmlvciA9PSBcIndyYXBcIiB8fCBvdmVyc2l6ZWRCZWhhdmlvciA9PSBcIndyYXAtbm8tYnJlYWtcIik7XHJcbiAgICAgICAgLy8gUHJlLXJlbmRlclxyXG4gICAgICAgIGNvbnRleHQuc2F2ZSgpO1xyXG4gICAgICAgIGdob3N0Q29udGV4dC5zYXZlKCk7XHJcbiAgICAgICAgdGhpcy5fcHJlcmVuZGVyKHN0YXR1cywgdHJ1ZSwgdGhpcy5faWdub3JlRm9udFdlaWdodCgpKTtcclxuICAgICAgICAvLyBHZXQgZGVmYXVsdCBmb250IG1ldHJpeFxyXG4gICAgICAgIGNvbnN0IHJlZlRleHQgPSBcImFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVowMTIzNDU2Nzg5IFwiO1xyXG4gICAgICAgIC8vIFNwbGl0IHVwIHRleHQgaW50byBsaW5lc1xyXG4gICAgICAgIGNvbnN0IGxpbmVzID0gdGhpcy50ZXh0LnRvU3RyaW5nKCkucmVwbGFjZSgvXFxyL2csIFwiXCIpLnNwbGl0KC9cXG4vKTtcclxuICAgICAgICBsZXQgc3R5bGVSZXN0b3JlZCA9IHRydWU7XHJcbiAgICAgICAgbGV0IG1pblggPSAwO1xyXG4gICAgICAgIGxldCBtYXhYID0gMDtcclxuICAgICAgICAvLyBJdGVyYXRlIHRocm91Z2ggdGhlIGxpbmVzXHJcbiAgICAgICAgbGV0IG9mZnNldFkgPSAwO1xyXG4gICAgICAgIGxldCBjdXJyZW50U3R5bGU7XHJcbiAgICAgICAgJGFycmF5LmVhY2gobGluZXMsIChsaW5lLCBfaW5kZXgpID0+IHtcclxuICAgICAgICAgICAgLy8gU3BsaXQgdXAgbGluZSBpbnRvIGZvcm1hdC92YWx1ZSBjaHVua3NcclxuICAgICAgICAgICAgbGV0IGNodW5rcztcclxuICAgICAgICAgICAgaWYgKGxpbmUgPT0gXCJcIikge1xyXG4gICAgICAgICAgICAgICAgY2h1bmtzID0gW3tcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJ2YWx1ZVwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiBcIlwiXHJcbiAgICAgICAgICAgICAgICAgICAgfV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjaHVua3MgPSBUZXh0Rm9ybWF0dGVyLmNodW5rKGxpbmUsIGZhbHNlLCB0aGlzLnN0eWxlLmlnbm9yZUZvcm1hdHRpbmcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHdoaWxlIChjaHVua3MubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgLy8gSW5pdCBsaW5lIG9iamVjdFxyXG4gICAgICAgICAgICAgICAgbGV0IGxpbmVJbmZvID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIG9mZnNldFk6IG9mZnNldFksXHJcbiAgICAgICAgICAgICAgICAgICAgYXNjZW50OiAwLFxyXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiAwLFxyXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogMCxcclxuICAgICAgICAgICAgICAgICAgICBsZWZ0OiAwLFxyXG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0OiAwLFxyXG4gICAgICAgICAgICAgICAgICAgIHRleHRDaHVua3M6IFtdXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgLy8gTWVhc3VyZSByZWZlcmVuY2UgdGV4dFxyXG4gICAgICAgICAgICAgICAgY29uc3QgbWV0cmljcyA9IHRoaXMuX21lYXN1cmVUZXh0KHJlZlRleHQsIGNvbnRleHQpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgaGVpZ2h0ID0gbWV0cmljcy5hY3R1YWxCb3VuZGluZ0JveEFzY2VudCArIG1ldHJpY3MuYWN0dWFsQm91bmRpbmdCb3hEZXNjZW50O1xyXG4gICAgICAgICAgICAgICAgbGluZUluZm8uaGVpZ2h0ID0gaGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgbGluZUluZm8uYXNjZW50ID0gbWV0cmljcy5hY3R1YWxCb3VuZGluZ0JveEFzY2VudDtcclxuICAgICAgICAgICAgICAgIGxldCBjdXJyZW50Rm9ybWF0O1xyXG4gICAgICAgICAgICAgICAgbGV0IGN1cnJlbnREZWNvcmF0aW9uID0gdGhpcy5zdHlsZS50ZXh0RGVjb3JhdGlvbjtcclxuICAgICAgICAgICAgICAgIGxldCBjdXJyZW50RmlsbDtcclxuICAgICAgICAgICAgICAgIGxldCBjdXJyZW50Q2h1bmtXaWR0aDtcclxuICAgICAgICAgICAgICAgIGxldCBza2lwRnVydGhlclRleHQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIGxldCBmaXJzdFRleHRDaHVuayA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBsZXQgbGVmdG92ZXJDaHVua3MgPSBbXTtcclxuICAgICAgICAgICAgICAgIGxldCBjdXJyZW50VmVydGljYWxBbGlnbjtcclxuICAgICAgICAgICAgICAgIC8vbGV0IG9mZnNldFggPSAwO1xyXG4gICAgICAgICAgICAgICAgLy9sZXQgY2h1bms7XHJcbiAgICAgICAgICAgICAgICAvL3doaWxlKGNodW5rID0gY2h1bmtzLnNoaWZ0KCkpIHtcclxuICAgICAgICAgICAgICAgICRhcnJheS5lYWNoQ29udGludWUoY2h1bmtzLCAoY2h1bmssIGluZGV4KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gRm9ybWF0IGNodW5rXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNodW5rLnR5cGUgPT0gXCJmb3JtYXRcIikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2h1bmsudGV4dCA9PSBcIlsvXVwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXN0eWxlUmVzdG9yZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LnJlc3RvcmUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnaG9zdENvbnRleHQucmVzdG9yZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlUmVzdG9yZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudEZpbGwgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50U3R5bGUgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50Q2h1bmtXaWR0aCA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnREZWNvcmF0aW9uID0gdGhpcy5zdHlsZS50ZXh0RGVjb3JhdGlvbjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRWZXJ0aWNhbEFsaWduID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudEZvcm1hdCA9IGNodW5rLnRleHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXN0eWxlUmVzdG9yZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LnJlc3RvcmUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnaG9zdENvbnRleHQucmVzdG9yZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGZvcm1hdCA9IFRleHRGb3JtYXR0ZXIuZ2V0VGV4dFN0eWxlKGNodW5rLnRleHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZm9udFN0eWxlID0gdGhpcy5fZ2V0Rm9udFN0eWxlKGZvcm1hdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LnNhdmUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdob3N0Q29udGV4dC5zYXZlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmZvbnQgPSBmb250U3R5bGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50U3R5bGUgPSBmb250U3R5bGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50Rm9ybWF0ID0gY2h1bmsudGV4dDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmb3JtYXQudGV4dERlY29yYXRpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50RGVjb3JhdGlvbiA9IGZvcm1hdC50ZXh0RGVjb3JhdGlvbjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmb3JtYXQuZmlsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRGaWxsID0gZm9ybWF0LmZpbGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZm9ybWF0LndpZHRoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudENodW5rV2lkdGggPSAkdHlwZS50b051bWJlcihmb3JtYXQud2lkdGgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZvcm1hdC52ZXJ0aWNhbEFsaWduKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFZlcnRpY2FsQWxpZ24gPSBmb3JtYXQudmVydGljYWxBbGlnbjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlUmVzdG9yZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1lYXN1cmUgcmVmZXJlbmNlIHRleHQgYWZ0ZXIgY2hhbmdlIG9mIGZvcm1hdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbWV0cmljcyA9IHRoaXMuX21lYXN1cmVUZXh0KHJlZlRleHQsIGNvbnRleHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaGVpZ2h0ID0gbWV0cmljcy5hY3R1YWxCb3VuZGluZ0JveEFzY2VudCArIG1ldHJpY3MuYWN0dWFsQm91bmRpbmdCb3hEZXNjZW50O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhlaWdodCA+IGxpbmVJbmZvLmhlaWdodCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVJbmZvLmhlaWdodCA9IGhlaWdodDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtZXRyaWNzLmFjdHVhbEJvdW5kaW5nQm94QXNjZW50ID4gbGluZUluZm8uYXNjZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZUluZm8uYXNjZW50ID0gbWV0cmljcy5hY3R1YWxCb3VuZGluZ0JveEFzY2VudDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAvLyBUZXh0IGNodW5rXHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoY2h1bmsudHlwZSA9PSBcInZhbHVlXCIgJiYgIXNraXBGdXJ0aGVyVGV4dCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBNZWFzdXJlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG1ldHJpY3MgPSB0aGlzLl9tZWFzdXJlVGV4dChjaHVuay50ZXh0LCBjb250ZXh0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGNodW5rV2lkdGggPSBtZXRyaWNzLmFjdHVhbEJvdW5kaW5nQm94TGVmdCArIG1ldHJpY3MuYWN0dWFsQm91bmRpbmdCb3hSaWdodDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIGZpdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHJ1bmNhdGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEJyZWFrIHdvcmRzP1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGJyZWFrV29yZHMgPSBmaXJzdFRleHRDaHVuayB8fCB0aGlzLnN0eWxlLmJyZWFrV29yZHMgfHwgZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBNZWFzdXJlIGVsbGlwc2lzIGFuZCBjaGVjayBpZiBpdCBmaXRzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlbGxpcHNpcyA9IHRoaXMuc3R5bGUuZWxsaXBzaXMgfHwgXCJcIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGVsbGlwc2lzTWV0cmljcyA9IHRoaXMuX21lYXN1cmVUZXh0KGVsbGlwc2lzLCBjb250ZXh0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGVsbGlwc2lzV2lkdGggPSBlbGxpcHNpc01ldHJpY3MuYWN0dWFsQm91bmRpbmdCb3hMZWZ0ICsgZWxsaXBzaXNNZXRyaWNzLmFjdHVhbEJvdW5kaW5nQm94UmlnaHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBmaXRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgobGluZUluZm8ud2lkdGggKyBjaHVua1dpZHRoKSA+IG1heFdpZHRoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXhjZXNzV2lkdGggPSBtYXhXaWR0aCAtIGxpbmVJbmZvLndpZHRoIC0gZWxsaXBzaXNXaWR0aDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaHVuay50ZXh0ID0gdGhpcy5fdHJ1bmNhdGVUZXh0KGNvbnRleHQsIGNodW5rLnRleHQsIGV4Y2Vzc1dpZHRoLCBicmVha1dvcmRzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaHVuay50ZXh0ICs9IGVsbGlwc2lzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNraXBGdXJ0aGVyVGV4dCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAod3JhcCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgZml0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKGxpbmVJbmZvLndpZHRoICsgY2h1bmtXaWR0aCkgPiBtYXhXaWR0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGV4Y2Vzc1dpZHRoID0gbWF4V2lkdGggLSBsaW5lSW5mby53aWR0aDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0bXBUZXh0ID0gdGhpcy5fdHJ1bmNhdGVUZXh0KGNvbnRleHQsIGNodW5rLnRleHQsIGV4Y2Vzc1dpZHRoLCBmYWxzZSwgKGZpcnN0VGV4dENodW5rICYmIHRoaXMuc3R5bGUub3ZlcnNpemVkQmVoYXZpb3IgIT0gXCJ3cmFwLW5vLWJyZWFrXCIpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodG1wVGV4dCA9PSBcIlwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVuYWJsZSB0byBmaXQgYSBzaW5nbGUgbGV0dGVyIC0gaGlkZSB0aGUgd2hvbGUgbGFiZWxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50ZXh0VmlzaWJsZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9za2lwRnVydGhlclRleHQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vQWRkIHJlbWFpbmluZyBjaHVua3MgZm9yIHRoZSBuZXh0IGxpbmVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZWZ0b3ZlckNodW5rcyA9IGNodW5rcy5zbGljZShpbmRleCArIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vQWRkIHJlbWFpbmluZyB0ZXh0IG9mIGN1cnJlbnQgY2h1bmsgaWYgaXQgd2FzIGZvcmNlZC1jdXRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoJHV0aWxzLnRyaW0odG1wVGV4dCkgIT0gJHV0aWxzLnRyaW0oY2h1bmsudGV4dCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVmdG92ZXJDaHVua3MudW5zaGlmdCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInZhbHVlXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiBjaHVuay50ZXh0LnN1YnN0cih0bXBUZXh0Lmxlbmd0aClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50Rm9ybWF0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZWZ0b3ZlckNodW5rcy51bnNoaWZ0KHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImZvcm1hdFwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IGN1cnJlbnRGb3JtYXRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNldCBjdXJyZW50IGNodW5rICh0cnVuY2F0ZWQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2h1bmsudGV4dCA9ICR1dGlscy50cmltKHRtcFRleHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNodW5rcyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNraXBGdXJ0aGVyVGV4dCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2h1bmsgd2lkdGg/XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBsZWZ0Qm91bmRNb2QgPSAxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgcmlnaHRCb3VuZE1vZCA9IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50U3R5bGUgJiYgY3VycmVudENodW5rV2lkdGggJiYgKGN1cnJlbnRDaHVua1dpZHRoID4gY2h1bmtXaWR0aCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGluY3JlYXNlIGhvcml6b250YWwgYm91bmRpbmcgYm94ZXMgYWNjb3JkaW5nbHlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGJvdW5kc01vZCA9IGNodW5rV2lkdGggLyBjdXJyZW50Q2h1bmtXaWR0aDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAodGhpcy5zdHlsZS50ZXh0QWxpZ24pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwicmlnaHRcIjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlZnRCb3VuZE1vZCA9IGJvdW5kc01vZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImNlbnRlclwiOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZWZ0Qm91bmRNb2QgPSBib3VuZHNNb2Q7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0Qm91bmRNb2QgPSBib3VuZHNNb2Q7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0Qm91bmRNb2QgPSBib3VuZHNNb2Q7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaHVua1dpZHRoID0gY3VycmVudENodW5rV2lkdGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY2h1bmtIZWlnaHQgPSBtZXRyaWNzLmFjdHVhbEJvdW5kaW5nQm94QXNjZW50ICsgbWV0cmljcy5hY3R1YWxCb3VuZGluZ0JveERlc2NlbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaHVua0hlaWdodCA+IGxpbmVJbmZvLmhlaWdodCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZUluZm8uaGVpZ2h0ID0gY2h1bmtIZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1ldHJpY3MuYWN0dWFsQm91bmRpbmdCb3hBc2NlbnQgPiBsaW5lSW5mby5hc2NlbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVJbmZvLmFzY2VudCA9IG1ldHJpY3MuYWN0dWFsQm91bmRpbmdCb3hBc2NlbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgbGluZUluZm8ud2lkdGggKz0gY2h1bmtXaWR0aDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGluZUluZm8ubGVmdCArPSBtZXRyaWNzLmFjdHVhbEJvdW5kaW5nQm94TGVmdCAvIGxlZnRCb3VuZE1vZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGluZUluZm8ucmlnaHQgKz0gbWV0cmljcy5hY3R1YWxCb3VuZGluZ0JveFJpZ2h0IC8gcmlnaHRCb3VuZE1vZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGluZUluZm8udGV4dENodW5rcy5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiBjdXJyZW50U3R5bGUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxsOiBjdXJyZW50RmlsbCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IGNodW5rLnRleHQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogY2h1bmtXaWR0aCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogY2h1bmtIZWlnaHQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZWZ0OiBtZXRyaWNzLmFjdHVhbEJvdW5kaW5nQm94TGVmdCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0OiBtZXRyaWNzLmFjdHVhbEJvdW5kaW5nQm94UmlnaHQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc2NlbnQ6IG1ldHJpY3MuYWN0dWFsQm91bmRpbmdCb3hBc2NlbnQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXRYOiAwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0WTogMCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHREZWNvcmF0aW9uOiBjdXJyZW50RGVjb3JhdGlvbixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlcnRpY2FsQWxpZ246IGN1cnJlbnRWZXJ0aWNhbEFsaWduXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL29mZnNldFggKz0gY2h1bmtXaWR0aDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmlyc3RUZXh0Q2h1bmsgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxlZnRvdmVyQ2h1bmtzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAvL31cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc3R5bGUubGluZUhlaWdodCBpbnN0YW5jZW9mIFBlcmNlbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICBsaW5lSW5mby5oZWlnaHQgKj0gdGhpcy5zdHlsZS5saW5lSGVpZ2h0LnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGxpbmVJbmZvLmFzY2VudCAqPSB0aGlzLnN0eWxlLmxpbmVIZWlnaHQudmFsdWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBsaW5lSW5mby5oZWlnaHQgKj0gdGhpcy5zdHlsZS5saW5lSGVpZ2h0IHx8IDEuMjtcclxuICAgICAgICAgICAgICAgICAgICBsaW5lSW5mby5hc2NlbnQgKj0gdGhpcy5zdHlsZS5saW5lSGVpZ2h0IHx8IDEuMjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChtaW5YIDwgbGluZUluZm8ubGVmdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG1pblggPSBsaW5lSW5mby5sZWZ0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKG1heFggPCBsaW5lSW5mby5yaWdodCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG1heFggPSBsaW5lSW5mby5yaWdodDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuX3RleHRJbmZvLnB1c2gobGluZUluZm8pO1xyXG4gICAgICAgICAgICAgICAgLy9saW5lSW5mby5vZmZzZXRZICs9IGxpbmVJbmZvLmFzY2VudDtcclxuICAgICAgICAgICAgICAgIG9mZnNldFkgKz0gbGluZUluZm8uaGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgLy8gUmVzZXQgY2h1bmtzIHNvIHRoYXQgaXQgY2FuIHByb2NlZWQgdG8gdGhlIG5leHQgbGluZVxyXG4gICAgICAgICAgICAgICAgY2h1bmtzID0gbGVmdG92ZXJDaHVua3MgfHwgW107XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICBpZiAoIXN0eWxlUmVzdG9yZWQpIHtcclxuICAgICAgICAgICAgY29udGV4dC5yZXN0b3JlKCk7XHJcbiAgICAgICAgICAgIGdob3N0Q29udGV4dC5yZXN0b3JlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIEFkanVzdCBjaHVuayBpbnRlcm5hbCBvZmZzZXRzXHJcbiAgICAgICAgJGFycmF5LmVhY2godGhpcy5fdGV4dEluZm8sIChsaW5lSW5mbywgX2luZGV4KSA9PiB7XHJcbiAgICAgICAgICAgIGxldCBjdXJyZW50Q2h1bmtPZmZzZXQgPSAwO1xyXG4gICAgICAgICAgICAkYXJyYXkuZWFjaChsaW5lSW5mby50ZXh0Q2h1bmtzLCAoY2h1bmspID0+IHtcclxuICAgICAgICAgICAgICAgIGNodW5rLm9mZnNldFggPSBjdXJyZW50Q2h1bmtPZmZzZXQgKyBjaHVuay5sZWZ0IC0gbGluZUluZm8ubGVmdDtcclxuICAgICAgICAgICAgICAgIGNodW5rLm9mZnNldFkgKz0gbGluZUluZm8uaGVpZ2h0IC0gbGluZUluZm8uaGVpZ2h0ICogKHRoaXMuc3R5bGUuYmFzZWxpbmVSYXRpbyB8fCAwLjE5KTtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRDaHVua09mZnNldCArPSBjaHVuay53aWR0aDtcclxuICAgICAgICAgICAgICAgIGlmIChjaHVuay52ZXJ0aWNhbEFsaWduKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChjaHVuay52ZXJ0aWNhbEFsaWduKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJzdXBlclwiOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2h1bmsub2Zmc2V0WSAtPSBsaW5lSW5mby5oZWlnaHQgLyAyIC0gY2h1bmsuaGVpZ2h0IC8gMjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwic3ViXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaHVuay5vZmZzZXRZICs9IGNodW5rLmhlaWdodCAvIDI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGNvbnN0IGJvdW5kcyA9IHtcclxuICAgICAgICAgICAgbGVmdDogcnRsID8gLW1heFggOiAtbWluWCxcclxuICAgICAgICAgICAgdG9wOiAwLFxyXG4gICAgICAgICAgICByaWdodDogcnRsID8gbWluWCA6IG1heFgsXHJcbiAgICAgICAgICAgIGJvdHRvbTogb2Zmc2V0WSxcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8vIFdlIG5lZWQgdG8gZml0P1xyXG4gICAgICAgIGlmIChvdmVyc2l6ZWRCZWhhdmlvciAhPT0gXCJub25lXCIpIHtcclxuICAgICAgICAgICAgY29uc3QgcmF0aW8gPSB0aGlzLl9maXRSYXRpbyhib3VuZHMpO1xyXG4gICAgICAgICAgICBpZiAocmF0aW8gPCAxKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAob3ZlcnNpemVkQmVoYXZpb3IgPT0gXCJmaXRcIikge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICgkdHlwZS5pc051bWJlcih0aGlzLnN0eWxlLm1pblNjYWxlKSAmJiAocmF0aW8gPCB0aGlzLnN0eWxlLm1pblNjYWxlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRleHRWaXNpYmxlID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvdW5kcy5sZWZ0ID0gMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYm91bmRzLnRvcCA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvdW5kcy5yaWdodCA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvdW5kcy5ib3R0b20gPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9vcmlnaW5hbFNjYWxlIHx8IHRoaXMuX29yaWdpbmFsU2NhbGUgPT0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fb3JpZ2luYWxTY2FsZSA9IHRoaXMuc2NhbGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zY2FsZSA9IHJhdGlvO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRleHRWaXNpYmxlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChvdmVyc2l6ZWRCZWhhdmlvciA9PSBcImhpZGVcIikge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudGV4dFZpc2libGUgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICBib3VuZHMubGVmdCA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgYm91bmRzLnRvcCA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgYm91bmRzLnJpZ2h0ID0gMDtcclxuICAgICAgICAgICAgICAgICAgICBib3VuZHMuYm90dG9tID0gMDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAodGhpcy5zdHlsZS50ZXh0QWxpZ24pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcInJpZ2h0XCI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvdW5kcy5sZWZ0ID0gLW1heFdpZHRoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYm91bmRzLnJpZ2h0ID0gMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiY2VudGVyXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBib3VuZHMubGVmdCA9IC1tYXhXaWR0aCAvIDI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBib3VuZHMucmlnaHQgPSBtYXhXaWR0aCAvIDI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvdW5kcy5sZWZ0ID0gMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvdW5kcy5yaWdodCA9IG1heFdpZHRoO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNjYWxlID0gdGhpcy5fb3JpZ2luYWxTY2FsZSB8fCAxO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX29yaWdpbmFsU2NhbGUgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50ZXh0VmlzaWJsZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNjYWxlID0gdGhpcy5fb3JpZ2luYWxTY2FsZSB8fCAxO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fb3JpZ2luYWxTY2FsZSA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgIHRoaXMudGV4dFZpc2libGUgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnRleHQucmVzdG9yZSgpO1xyXG4gICAgICAgIGdob3N0Q29udGV4dC5yZXN0b3JlKCk7XHJcbiAgICAgICAgcmV0dXJuIGJvdW5kcztcclxuICAgIH1cclxuICAgIF9maXRSYXRpbyhib3VuZHMpIHtcclxuICAgICAgICBjb25zdCBtYXhXID0gdGhpcy5zdHlsZS5tYXhXaWR0aDtcclxuICAgICAgICBjb25zdCBtYXhIID0gdGhpcy5zdHlsZS5tYXhIZWlnaHQ7XHJcbiAgICAgICAgaWYgKCEkdHlwZS5pc051bWJlcihtYXhXKSAmJiAhJHR5cGUuaXNOdW1iZXIobWF4SCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHcgPSBib3VuZHMucmlnaHQgLSBib3VuZHMubGVmdDtcclxuICAgICAgICBjb25zdCBoID0gYm91bmRzLmJvdHRvbSAtIGJvdW5kcy50b3A7XHJcbiAgICAgICAgcmV0dXJuIE1hdGgubWluKG1heFcgLyB3IHx8IDEsIG1heEggLyBoIHx8IDEpO1xyXG4gICAgfVxyXG4gICAgX3RydW5jYXRlVGV4dChjb250ZXh0LCB0ZXh0LCBtYXhXaWR0aCwgYnJlYWtXb3JkcyA9IGZhbHNlLCBmYWxsYmFja0JyZWFrV29yZHMgPSB0cnVlKSB7XHJcbiAgICAgICAgbGV0IHdpZHRoO1xyXG4gICAgICAgIGRvIHtcclxuICAgICAgICAgICAgaWYgKGJyZWFrV29yZHMpIHtcclxuICAgICAgICAgICAgICAgIHRleHQgPSB0ZXh0LnNsaWNlKDAsIC0xKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGxldCB0bXAgPSB0ZXh0LnJlcGxhY2UoL1teLDs6IT9cXFxcXFwvXFxz4oCLXStbLDs6IT9cXFxcXFwvXFxz4oCLXSokL2csIFwiXCIpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCh0bXAgPT0gXCJcIiB8fCB0bXAgPT09IHRleHQpICYmIGZhbGxiYWNrQnJlYWtXb3Jkcykge1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrV29yZHMgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodG1wID09IFwiXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGV4dDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRleHQgPSB0bXA7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgbWV0cmljcyA9IHRoaXMuX21lYXN1cmVUZXh0KHRleHQsIGNvbnRleHQpO1xyXG4gICAgICAgICAgICB3aWR0aCA9IG1ldHJpY3MuYWN0dWFsQm91bmRpbmdCb3hMZWZ0ICsgbWV0cmljcy5hY3R1YWxCb3VuZGluZ0JveFJpZ2h0O1xyXG4gICAgICAgIH0gd2hpbGUgKCh3aWR0aCA+IG1heFdpZHRoKSAmJiB0ZXh0ICE9IFwiXCIpO1xyXG4gICAgICAgIHJldHVybiB0ZXh0O1xyXG4gICAgfVxyXG4gICAgX21lYXN1cmVUZXh0KHRleHQsIGNvbnRleHQpIHtcclxuICAgICAgICBsZXQgbWV0cmljcyA9IGNvbnRleHQubWVhc3VyZVRleHQodGV4dCk7XHJcbiAgICAgICAgbGV0IGZha2VNZXRyaWNzID0ge307XHJcbiAgICAgICAgaWYgKG1ldHJpY3MuYWN0dWFsQm91bmRpbmdCb3hBc2NlbnQgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBjb25zdCBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xyXG4gICAgICAgICAgICBkaXYuaW5uZXJUZXh0ID0gdGV4dDtcclxuICAgICAgICAgICAgZGl2LnN0eWxlLnZpc2liaWxpdHkgPSBcImhpZGRlblwiO1xyXG4gICAgICAgICAgICBkaXYuc3R5bGUucG9zaXRpb24gPSBcImFic29sdXRlXCI7XHJcbiAgICAgICAgICAgIGRpdi5zdHlsZS50b3AgPSBcIi0xMDAwMDAwcHg7XCI7XHJcbiAgICAgICAgICAgIGRpdi5zdHlsZS5mb250RmFtaWx5ID0gdGhpcy5zdHlsZS5mb250RmFtaWx5IHx8IFwiXCI7XHJcbiAgICAgICAgICAgIGRpdi5zdHlsZS5mb250U2l6ZSA9IHRoaXMuc3R5bGUuZm9udFNpemUgKyBcIlwiO1xyXG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGRpdik7XHJcbiAgICAgICAgICAgIGNvbnN0IGJib3ggPSBkaXYuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoZGl2KTtcclxuICAgICAgICAgICAgY29uc3QgaCA9IGJib3guaGVpZ2h0O1xyXG4gICAgICAgICAgICBjb25zdCB3ID0gbWV0cmljcy53aWR0aDtcclxuICAgICAgICAgICAgbGV0IGxlZnQgPSAwO1xyXG4gICAgICAgICAgICBsZXQgcmlnaHQgPSB3O1xyXG4gICAgICAgICAgICBmYWtlTWV0cmljcyA9IHtcclxuICAgICAgICAgICAgICAgIGFjdHVhbEJvdW5kaW5nQm94QXNjZW50OiBoLFxyXG4gICAgICAgICAgICAgICAgYWN0dWFsQm91bmRpbmdCb3hEZXNjZW50OiAwLFxyXG4gICAgICAgICAgICAgICAgYWN0dWFsQm91bmRpbmdCb3hMZWZ0OiBsZWZ0LFxyXG4gICAgICAgICAgICAgICAgYWN0dWFsQm91bmRpbmdCb3hSaWdodDogcmlnaHQsXHJcbiAgICAgICAgICAgICAgICBmb250Qm91bmRpbmdCb3hBc2NlbnQ6IGgsXHJcbiAgICAgICAgICAgICAgICBmb250Qm91bmRpbmdCb3hEZXNjZW50OiAwLFxyXG4gICAgICAgICAgICAgICAgd2lkdGg6IHdcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLy9yZXR1cm4gZmFrZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGZha2VNZXRyaWNzID0ge1xyXG4gICAgICAgICAgICAgICAgYWN0dWFsQm91bmRpbmdCb3hBc2NlbnQ6IG1ldHJpY3MuYWN0dWFsQm91bmRpbmdCb3hBc2NlbnQsXHJcbiAgICAgICAgICAgICAgICBhY3R1YWxCb3VuZGluZ0JveERlc2NlbnQ6IG1ldHJpY3MuYWN0dWFsQm91bmRpbmdCb3hEZXNjZW50LFxyXG4gICAgICAgICAgICAgICAgYWN0dWFsQm91bmRpbmdCb3hMZWZ0OiBtZXRyaWNzLmFjdHVhbEJvdW5kaW5nQm94TGVmdCxcclxuICAgICAgICAgICAgICAgIGFjdHVhbEJvdW5kaW5nQm94UmlnaHQ6IG1ldHJpY3MuYWN0dWFsQm91bmRpbmdCb3hSaWdodCxcclxuICAgICAgICAgICAgICAgIGZvbnRCb3VuZGluZ0JveEFzY2VudDogbWV0cmljcy5hY3R1YWxCb3VuZGluZ0JveEFzY2VudCxcclxuICAgICAgICAgICAgICAgIGZvbnRCb3VuZGluZ0JveERlc2NlbnQ6IG1ldHJpY3MuYWN0dWFsQm91bmRpbmdCb3hEZXNjZW50LFxyXG4gICAgICAgICAgICAgICAgd2lkdGg6IG1ldHJpY3Mud2lkdGhcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgdyA9IG1ldHJpY3Mud2lkdGg7XHJcbiAgICAgICAgc3dpdGNoICh0aGlzLnN0eWxlLnRleHRBbGlnbikge1xyXG4gICAgICAgICAgICBjYXNlIFwicmlnaHRcIjpcclxuICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxyXG4gICAgICAgICAgICAgICAgZmFrZU1ldHJpY3MuYWN0dWFsQm91bmRpbmdCb3hMZWZ0ID0gdztcclxuICAgICAgICAgICAgICAgIGZha2VNZXRyaWNzLmFjdHVhbEJvdW5kaW5nQm94UmlnaHQgPSAwO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgXCJjZW50ZXJcIjpcclxuICAgICAgICAgICAgICAgIGZha2VNZXRyaWNzLmFjdHVhbEJvdW5kaW5nQm94TGVmdCA9IHcgLyAyO1xyXG4gICAgICAgICAgICAgICAgZmFrZU1ldHJpY3MuYWN0dWFsQm91bmRpbmdCb3hSaWdodCA9IHcgLyAyO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICBmYWtlTWV0cmljcy5hY3R1YWxCb3VuZGluZ0JveExlZnQgPSAwO1xyXG4gICAgICAgICAgICAgICAgZmFrZU1ldHJpY3MuYWN0dWFsQm91bmRpbmdCb3hSaWdodCA9IHc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmYWtlTWV0cmljcztcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQGlnbm9yZVxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIENhbnZhc1RleHRTdHlsZSB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICAvL3B1YmxpYyB3b3JkV3JhcFdpZHRoOiBudW1iZXIgPSAxMDA7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZmlsbFwiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJmaWxsT3BhY2l0eVwiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ0ZXh0QWxpZ25cIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZm9udEZhbWlseVwiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJmb250U2l6ZVwiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJmb250V2VpZ2h0XCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImZvbnRTdHlsZVwiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJmb250VmFyaWFudFwiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ0ZXh0RGVjb3JhdGlvblwiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJzaGFkb3dDb2xvclwiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJzaGFkb3dCbHVyXCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInNoYWRvd09mZnNldFhcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwic2hhZG93T2Zmc2V0WVwiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJzaGFkb3dPcGFjaXR5XCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8vIGxlYWRpbmc/OiBudW1iZXI7XHJcbiAgICAgICAgLy8gbGV0dGVyU3BhY2luZz86IG51bWJlcjtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJsaW5lSGVpZ2h0XCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IHBlcmNlbnQoMTIwKVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImJhc2VsaW5lUmF0aW9cIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogMC4xOVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8vIHBhZGRpbmc/OiBudW1iZXI7XHJcbiAgICAgICAgLy8gc3Ryb2tlPzogbnVtYmVyO1xyXG4gICAgICAgIC8vIHN0cm9rZVRoaWNrbmVzcz86IG51bWJlcjtcclxuICAgICAgICAvLyB0cmltPzogbnVtYmVyO1xyXG4gICAgICAgIC8vIHdvcmRXcmFwPzogYm9vbGVhbjtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJkaXJlY3Rpb25cIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwidGV4dEJhc2VsaW5lXCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm92ZXJzaXplZEJlaGF2aW9yXCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IFwibm9uZVwiXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiYnJlYWtXb3Jkc1wiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiBmYWxzZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImVsbGlwc2lzXCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IFwi4oCmXCJcclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJtYXhXaWR0aFwiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJtYXhIZWlnaHRcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibWluU2NhbGVcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiaWdub3JlRm9ybWF0dGluZ1wiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiBmYWxzZVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBAaWdub3JlXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgQ2FudmFzUmFkaWFsVGV4dCBleHRlbmRzIENhbnZhc1RleHQge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ0ZXh0VHlwZVwiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiBcImNpcmN1bGFyXCJcclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJyYWRpdXNcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwic3RhcnRBbmdsZVwiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJpbnNpZGVcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogZmFsc2VcclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJvcmllbnRhdGlvblwiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiBcImF1dG9cIlxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImtlcm5pbmdcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogMFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl90ZXh0UmV2ZXJzZWRcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogZmFsc2VcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIF9yZW5kZXIoc3RhdHVzKSB7XHJcbiAgICAgICAgc3dpdGNoICh0aGlzLnRleHRUeXBlKSB7XHJcbiAgICAgICAgICAgIGNhc2UgXCJjaXJjdWxhclwiOlxyXG4gICAgICAgICAgICAgICAgdGhpcy5fcmVuZGVyQ2lyY3VsYXIoc3RhdHVzKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgc3VwZXIuX3JlbmRlcihzdGF0dXMpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgX3JlbmRlckNpcmN1bGFyKHN0YXR1cykge1xyXG4gICAgICAgIGlmICh0aGlzLnRleHRWaXNpYmxlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3ByZXJlbmRlcihzdGF0dXMpO1xyXG4gICAgICAgICAgICBjb25zdCBpbnRlcmFjdGl2ZSA9IHRoaXMuX2lzSW50ZXJhY3RpdmUoc3RhdHVzKTtcclxuICAgICAgICAgICAgY29uc3QgY29udGV4dCA9IHN0YXR1cy5sYXllci5jb250ZXh0O1xyXG4gICAgICAgICAgICBjb25zdCBsYXllckRpcnR5ID0gc3RhdHVzLmxheWVyLmRpcnR5O1xyXG4gICAgICAgICAgICBjb25zdCBnaG9zdENvbnRleHQgPSB0aGlzLl9yZW5kZXJlci5fZ2hvc3RMYXllci5jb250ZXh0O1xyXG4gICAgICAgICAgICAvLyBTYXZlcG9pbnRcclxuICAgICAgICAgICAgY29udGV4dC5zYXZlKCk7XHJcbiAgICAgICAgICAgIGlmIChpbnRlcmFjdGl2ZSkge1xyXG4gICAgICAgICAgICAgICAgZ2hvc3RDb250ZXh0LnNhdmUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBXZSBuZWVkIG1lYXN1cmVtZW50cyBpbiBvcmRlciB0byBwcm9wZXJseSBwb3NpdGlvbiB0ZXh0IGZvciBhbGlnbm1lbnRcclxuICAgICAgICAgICAgaWYgKCF0aGlzLl90ZXh0SW5mbykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbWVhc3VyZShzdGF0dXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIEluaXRcclxuICAgICAgICAgICAgbGV0IHJhZGl1cyA9ICh0aGlzLnJhZGl1cyB8fCAwKTtcclxuICAgICAgICAgICAgbGV0IHN0YXJ0QW5nbGUgPSAodGhpcy5zdGFydEFuZ2xlIHx8IDApO1xyXG4gICAgICAgICAgICBsZXQgZGVsdGFBbmdsZSA9IDA7XHJcbiAgICAgICAgICAgIGxldCBvcmllbnRhdGlvbiA9IHRoaXMub3JpZW50YXRpb247XHJcbiAgICAgICAgICAgIGxldCBpbndhcmQgPSBvcmllbnRhdGlvbiA9PSBcImF1dG9cIiA/IFwiYXV0b1wiIDogb3JpZW50YXRpb24gPT0gXCJpbndhcmRcIjtcclxuICAgICAgICAgICAgY29uc3QgaW5zaWRlID0gdGhpcy5pbnNpZGU7XHJcbiAgICAgICAgICAgIGNvbnN0IGFsaWduID0gdGhpcy5zdHlsZS50ZXh0QWxpZ24gfHwgXCJsZWZ0XCI7XHJcbiAgICAgICAgICAgIGNvbnN0IGtlcm5pbmcgPSB0aGlzLmtlcm5pbmcgfHwgMDtcclxuICAgICAgICAgICAgbGV0IGNsb2Nrd2lzZSA9IGFsaWduID09IFwibGVmdFwiID8gMSA6IC0xO1xyXG4gICAgICAgICAgICBjb25zdCBzaG91bGRSZXZlcnNlID0gIXRoaXMuX3RleHRSZXZlcnNlZDtcclxuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgd2UgbmVlZCB0byBpbnZlcnQgdGhlIHdob2xlIHN0dWZmXHJcbiAgICAgICAgICAgIGlmIChpbndhcmQgPT0gXCJhdXRvXCIpIHtcclxuICAgICAgICAgICAgICAgIC8vIENhbGMgbWF4IGFuZ2xlIHNvIHdlIGtub3cgd2hldGhlciB3ZSBuZWVkIHRvIGZsaXAgaXRcclxuICAgICAgICAgICAgICAgIGxldCBtYXhBbmdsZSA9IDA7XHJcbiAgICAgICAgICAgICAgICBsZXQgbWlkQW5nbGUgPSAwO1xyXG4gICAgICAgICAgICAgICAgJGFycmF5LmVhY2godGhpcy5fdGV4dEluZm8sIChsaW5lLCBfaW5kZXgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBkZWx0YUFuZ2xlID0gc3RhcnRBbmdsZSArIChsaW5lLndpZHRoIC8gKHJhZGl1cyAtIGxpbmUuaGVpZ2h0KSkgLyAyICogLWNsb2Nrd2lzZTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZGVsdGFBbmdsZSA+IG1heEFuZ2xlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heEFuZ2xlID0gZGVsdGFBbmdsZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIGlmIChhbGlnbiA9PSBcImxlZnRcIikge1xyXG4gICAgICAgICAgICAgICAgICAgIG1pZEFuZ2xlID0gKG1heEFuZ2xlICsgZGVsdGFBbmdsZSAvIDIpICogJG1hdGguREVHUkVFUztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGFsaWduID09IFwicmlnaHRcIikge1xyXG4gICAgICAgICAgICAgICAgICAgIG1pZEFuZ2xlID0gKG1heEFuZ2xlIC0gZGVsdGFBbmdsZSAvIDIpICogJG1hdGguREVHUkVFUztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIG1pZEFuZ2xlID0gc3RhcnRBbmdsZSAqICRtYXRoLkRFR1JFRVM7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBtaWRBbmdsZSA9ICRtYXRoLm5vcm1hbGl6ZUFuZ2xlKG1pZEFuZ2xlKTtcclxuICAgICAgICAgICAgICAgIGlud2FyZCA9IChtaWRBbmdsZSA+PSAyNzApIHx8IChtaWRBbmdsZSA8PSA5MCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGlud2FyZCA9PSB0cnVlICYmIHNob3VsZFJldmVyc2UpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3RleHRJbmZvLnJldmVyc2UoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3RleHRSZXZlcnNlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gaWYgKChpbndhcmQgPT0gZmFsc2UgJiYgYWxpZ24gPT0gXCJsZWZ0XCIpIHx8IChpbndhcmQgPT0gdHJ1ZSAmJiBhbGlnbiA9PSBcInJpZ2h0XCIpKSB7XHJcbiAgICAgICAgICAgIC8vIFx0Y2xvY2t3aXNlICo9IC0xO1xyXG4gICAgICAgICAgICAvLyB9XHJcbiAgICAgICAgICAgIC8vIFByb2Nlc3MgdGV4dCBpbmZvIHByb2R1Y2VkIGJ5IF9tZWFzdXJlKClcclxuICAgICAgICAgICAgJGFycmF5LmVhY2godGhpcy5fdGV4dEluZm8sIChsaW5lLCBfaW5kZXgpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHRleHRIZWlnaHQgPSBsaW5lLmhlaWdodDtcclxuICAgICAgICAgICAgICAgIC8vIEFkanVzdCByYWRpdXMgKGZvciBgaW5zaWRlID0gZmFsc2VgKVxyXG4gICAgICAgICAgICAgICAgLy8gUmFkaXVzIGFkanVzdG1lbnQgZm9yIGBpbnNpZGUgPSBmYWxzZWAgaXMgYmVsb3cgdGhlIGxpbmUgY2FsY3VsYXRpb25cclxuICAgICAgICAgICAgICAgIGlmICghaW5zaWRlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmFkaXVzICs9IHRleHRIZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBSZXZlcnNlIGxldHRlcnMgaWYgd2UncmUgcGFpbnRpbmcgdGhlbSBjb3VudGVyLWNsb2Nrd2lzZVxyXG4gICAgICAgICAgICAgICAgaWYgKCgoY2xvY2t3aXNlID09IC0xICYmIGlud2FyZCkgfHwgKGNsb2Nrd2lzZSA9PSAxICYmICFpbndhcmQpKSAmJiBzaG91bGRSZXZlcnNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGluZS50ZXh0Q2h1bmtzLnJldmVyc2UoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIEluaXQgYW5nbGVzXHJcbiAgICAgICAgICAgICAgICBsZXQgbGluZVN0YXJ0QW5nbGUgPSBzdGFydEFuZ2xlO1xyXG4gICAgICAgICAgICAgICAgZGVsdGFBbmdsZSA9IDA7XHJcbiAgICAgICAgICAgICAgICAvLyBBZGp1c3QgZm9yIGNlbnRlci1hbGlnblxyXG4gICAgICAgICAgICAgICAgaWYgKGFsaWduID09IFwiY2VudGVyXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICBsaW5lU3RhcnRBbmdsZSArPSAobGluZS53aWR0aCAvIChyYWRpdXMgLSB0ZXh0SGVpZ2h0KSkgLyAyICogLWNsb2Nrd2lzZTtcclxuICAgICAgICAgICAgICAgICAgICBkZWx0YUFuZ2xlID0gbGluZVN0YXJ0QW5nbGUgLSBzdGFydEFuZ2xlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gaWYgKGlud2FyZCA9PSBcImF1dG9cIikge1xyXG4gICAgICAgICAgICAgICAgLy8gXHRsZXQgbWlkQW5nbGU7XHJcbiAgICAgICAgICAgICAgICAvLyBcdGlmIChhbGlnbiA9PSBcImxlZnRcIikge1xyXG4gICAgICAgICAgICAgICAgLy8gXHRcdG1pZEFuZ2xlID0gKGxpbmVTdGFydEFuZ2xlICsgZGVsdGFBbmdsZSAvIDIpICogJG1hdGguREVHUkVFUztcclxuICAgICAgICAgICAgICAgIC8vIFx0fVxyXG4gICAgICAgICAgICAgICAgLy8gXHRlbHNlIGlmICgpIHtcclxuICAgICAgICAgICAgICAgIC8vIFx0XHRtaWRBbmdsZSA9IChsaW5lU3RhcnRBbmdsZSAtIGRlbHRhQW5nbGUgLyAyKSAqICRtYXRoLkRFR1JFRVM7XHJcbiAgICAgICAgICAgICAgICAvLyBcdH1cclxuICAgICAgICAgICAgICAgIC8vIFx0aW53YXJkID0gKG1pZEFuZ2xlID49IDI3MCkgfHwgKG1pZEFuZ2xlIDw9IDkwKTtcclxuICAgICAgICAgICAgICAgIC8vIH1cclxuICAgICAgICAgICAgICAgIC8vIFJvdGF0ZSBsZXR0ZXJzIGlmIHRoZXkgYXJlIGZhY2luZyBvdXR3YXJkXHJcbiAgICAgICAgICAgICAgICBsaW5lU3RhcnRBbmdsZSArPSAoTWF0aC5QSSAqIChpbndhcmQgPyAwIDogMSkpOyAvLyBSb3RhdGUgMTgwIGlmIG91dHdhcmRcclxuICAgICAgICAgICAgICAgIC8vIFNhdmVwb2ludFxyXG4gICAgICAgICAgICAgICAgY29udGV4dC5zYXZlKCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoaW50ZXJhY3RpdmUpIHtcclxuICAgICAgICAgICAgICAgICAgICBnaG9zdENvbnRleHQuc2F2ZSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gQXNzdW1lIHN0YXJ0aW5nIGFuZ2xlXHJcbiAgICAgICAgICAgICAgICBjb250ZXh0LnJvdGF0ZShsaW5lU3RhcnRBbmdsZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoaW50ZXJhY3RpdmUpIHtcclxuICAgICAgICAgICAgICAgICAgICBnaG9zdENvbnRleHQucm90YXRlKGxpbmVTdGFydEFuZ2xlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGxldCBhbmdsZVNoaWZ0ID0gMDtcclxuICAgICAgICAgICAgICAgICRhcnJheS5lYWNoKGxpbmUudGV4dENodW5rcywgKGNodW5rLCBfaW5kZXgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBEcmF3IHRoZSBsZXR0ZXJcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjaGFyID0gY2h1bmsudGV4dDtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjaGFyV2lkdGggPSBjaHVuay53aWR0aDtcclxuICAgICAgICAgICAgICAgICAgICAvLyBSb3RhdGUgaGFsZiBhIGxldHRlclxyXG4gICAgICAgICAgICAgICAgICAgIGFuZ2xlU2hpZnQgPSAoY2hhcldpZHRoIC8gMikgLyAocmFkaXVzIC0gdGV4dEhlaWdodCkgKiBjbG9ja3dpc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5yb3RhdGUoYW5nbGVTaGlmdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGludGVyYWN0aXZlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGdob3N0Q29udGV4dC5yb3RhdGUoYW5nbGVTaGlmdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFNldCBzdHlsZVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjaHVuay5zdHlsZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LnNhdmUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZ2hvc3RDb250ZXh0LnNhdmUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5mb250ID0gY2h1bmsuc3R5bGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbnRlcmFjdGl2ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2hvc3RDb250ZXh0LmZvbnQgPSBjaHVuay5zdHlsZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoY2h1bmsuZmlsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LnNhdmUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5maWxsU3R5bGUgPSBjaHVuay5maWxsLnRvQ1NTKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENvbG9yIGRvZXMgbm90IGFmZmVjdCBnaG9zdENvbnRleHQgc28gd2Ugbm90IHNldCBpdFxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAvLyBDZW50ZXIgbGV0dGVyc1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQudGV4dEJhc2VsaW5lID0gXCJtaWRkbGVcIjtcclxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LnRleHRBbGlnbiA9IFwiY2VudGVyXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGludGVyYWN0aXZlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGdob3N0Q29udGV4dC50ZXh0QmFzZWxpbmUgPSBcIm1pZGRsZVwiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBnaG9zdENvbnRleHQudGV4dEFsaWduID0gXCJjZW50ZXJcIjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gUGxvcCB0aGUgbGV0dGVyXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxheWVyRGlydHkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5maWxsVGV4dChjaGFyLCAwLCAoaW53YXJkID8gMSA6IC0xKSAqICgwIC0gcmFkaXVzICsgdGV4dEhlaWdodCAvIDIpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGludGVyYWN0aXZlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGdob3N0Q29udGV4dC5maWxsVGV4dChjaGFyLCAwLCAoaW53YXJkID8gMSA6IC0xKSAqICgwIC0gcmFkaXVzICsgdGV4dEhlaWdodCAvIDIpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNodW5rLmZpbGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5yZXN0b3JlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENvbG9yIGRvZXMgbm90IGFmZmVjdCBnaG9zdENvbnRleHQgc28gd2Ugbm90IHNldCBpdFxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAvLyBSZXNldCBzdHlsZVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjaHVuay5zdHlsZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LnJlc3RvcmUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZ2hvc3RDb250ZXh0LnJlc3RvcmUoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gUm90YXRlIGhhbGYgYSBsZXR0ZXIgYW5kIGFkZCBzcGFjaW5nXHJcbiAgICAgICAgICAgICAgICAgICAgYW5nbGVTaGlmdCA9IChjaGFyV2lkdGggLyAyICsga2VybmluZykgLyAocmFkaXVzIC0gdGV4dEhlaWdodCkgKiBjbG9ja3dpc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5yb3RhdGUoYW5nbGVTaGlmdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGludGVyYWN0aXZlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGdob3N0Q29udGV4dC5yb3RhdGUoYW5nbGVTaGlmdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAvLyBSZXN0b3JlIGFuZ2xlXHJcbiAgICAgICAgICAgICAgICBjb250ZXh0LnJlc3RvcmUoKTtcclxuICAgICAgICAgICAgICAgIGlmIChpbnRlcmFjdGl2ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGdob3N0Q29udGV4dC5yZXN0b3JlKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBBZGp1c3QgcmFkaXVzIChmb3IgYGluc2lkZSA9IHRydWVgKVxyXG4gICAgICAgICAgICAgICAgaWYgKGluc2lkZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJhZGl1cyAtPSB0ZXh0SGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgLy8gUmVzdG9yZVxyXG4gICAgICAgICAgICBjb250ZXh0LnJlc3RvcmUoKTtcclxuICAgICAgICAgICAgaWYgKGludGVyYWN0aXZlKSB7XHJcbiAgICAgICAgICAgICAgICBnaG9zdENvbnRleHQucmVzdG9yZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgX21lYXN1cmUoc3RhdHVzKSB7XHJcbiAgICAgICAgc3dpdGNoICh0aGlzLnRleHRUeXBlKSB7XHJcbiAgICAgICAgICAgIGNhc2UgXCJjaXJjdWxhclwiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21lYXN1cmVDaXJjdWxhcihzdGF0dXMpO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHN1cGVyLl9tZWFzdXJlKHN0YXR1cyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgX21lYXN1cmVDaXJjdWxhcihzdGF0dXMpIHtcclxuICAgICAgICBjb25zdCBjb250ZXh0ID0gc3RhdHVzLmxheWVyLmNvbnRleHQ7XHJcbiAgICAgICAgY29uc3QgZ2hvc3RDb250ZXh0ID0gdGhpcy5fcmVuZGVyZXIuX2dob3N0TGF5ZXIuY29udGV4dDtcclxuICAgICAgICBjb25zdCBydGwgPSB0aGlzLnN0eWxlLmRpcmVjdGlvbiA9PSBcInJ0bFwiO1xyXG4gICAgICAgIGNvbnN0IG92ZXJzaXplZEJlaGF2aW9yID0gdGhpcy5zdHlsZS5vdmVyc2l6ZWRCZWhhdmlvcjtcclxuICAgICAgICBjb25zdCBtYXhXaWR0aCA9IHRoaXMuc3R5bGUubWF4V2lkdGg7XHJcbiAgICAgICAgY29uc3QgdHJ1bmNhdGUgPSAkdHlwZS5pc051bWJlcihtYXhXaWR0aCkgJiYgb3ZlcnNpemVkQmVoYXZpb3IgPT0gXCJ0cnVuY2F0ZVwiO1xyXG4gICAgICAgIGNvbnN0IGVsbGlwc2lzID0gdGhpcy5zdHlsZS5lbGxpcHNpcyB8fCBcIlwiO1xyXG4gICAgICAgIGxldCBlbGxpcHNpc01ldHJpY3M7XHJcbiAgICAgICAgLy9jb25zdCB3cmFwID0gJHR5cGUuaXNOdW1iZXIobWF4V2lkdGgpICYmIChvdmVyc2l6ZWRCZWhhdmlvciA9PSBcIndyYXBcIiB8fCBvdmVyc2l6ZWRCZWhhdmlvciA9PSBcIndyYXAtbm8tYnJlYWtcIik7XHJcbiAgICAgICAgLy8gUmVzZXQgdGV4dCBpbmZvXHJcbiAgICAgICAgdGhpcy50ZXh0VmlzaWJsZSA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5fdGV4dEluZm8gPSBbXTtcclxuICAgICAgICB0aGlzLl90ZXh0UmV2ZXJzZWQgPSBmYWxzZTtcclxuICAgICAgICAvLyBQcmUtcmVuZGVyXHJcbiAgICAgICAgY29udGV4dC5zYXZlKCk7XHJcbiAgICAgICAgZ2hvc3RDb250ZXh0LnNhdmUoKTtcclxuICAgICAgICB0aGlzLl9wcmVyZW5kZXIoc3RhdHVzLCB0cnVlKTtcclxuICAgICAgICAvLyBTcGxpdCB1cCB0ZXh0IGludG8gbGluZXNcclxuICAgICAgICBjb25zdCBsaW5lcyA9IHRoaXMudGV4dC50b1N0cmluZygpLnJlcGxhY2UoL1xcci9nLCBcIlwiKS5zcGxpdCgvXFxuLyk7XHJcbiAgICAgICAgbGV0IHN0eWxlUmVzdG9yZWQgPSB0cnVlO1xyXG4gICAgICAgIGxldCB0b3RhbFdpZHRoID0gMDtcclxuICAgICAgICAvLyBJdGVyYXRlIHRocm91Z2ggdGhlIGxpbmVzXHJcbiAgICAgICAgbGV0IG9mZnNldFkgPSAwO1xyXG4gICAgICAgICRhcnJheS5lYWNoKGxpbmVzLCAobGluZSwgX2luZGV4KSA9PiB7XHJcbiAgICAgICAgICAgIC8vIFNwbGl0IHVwIGxpbmUgaW50byBmb3JtYXQvdmFsdWUgY2h1bmtzXHJcbiAgICAgICAgICAgIGxldCBjaHVua3MgPSBUZXh0Rm9ybWF0dGVyLmNodW5rKGxpbmUsIGZhbHNlLCB0aGlzLnN0eWxlLmlnbm9yZUZvcm1hdHRpbmcpO1xyXG4gICAgICAgICAgICAvLyBJbml0IGxpbmUgb2JqZWN0XHJcbiAgICAgICAgICAgIGxldCBsaW5lSW5mbyA9IHtcclxuICAgICAgICAgICAgICAgIG9mZnNldFk6IG9mZnNldFksXHJcbiAgICAgICAgICAgICAgICBhc2NlbnQ6IDAsXHJcbiAgICAgICAgICAgICAgICB3aWR0aDogMCxcclxuICAgICAgICAgICAgICAgIGhlaWdodDogMCxcclxuICAgICAgICAgICAgICAgIGxlZnQ6IDAsXHJcbiAgICAgICAgICAgICAgICByaWdodDogMCxcclxuICAgICAgICAgICAgICAgIHRleHRDaHVua3M6IFtdXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGxldCBjdXJyZW50U3R5bGU7XHJcbiAgICAgICAgICAgIGxldCBjdXJyZW50RmlsbDtcclxuICAgICAgICAgICAgbGV0IGN1cnJlbnRDaHVua1dpZHRoO1xyXG4gICAgICAgICAgICAvL3doaWxlKGNodW5rID0gY2h1bmtzLnNoaWZ0KCkpIHtcclxuICAgICAgICAgICAgJGFycmF5LmVhY2goY2h1bmtzLCAoY2h1bmssIF9pbmRleCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgLy8gRm9ybWF0IGNodW5rXHJcbiAgICAgICAgICAgICAgICBpZiAoY2h1bmsudHlwZSA9PSBcImZvcm1hdFwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNodW5rLnRleHQgPT0gXCJbL11cIikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXN0eWxlUmVzdG9yZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQucmVzdG9yZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2hvc3RDb250ZXh0LnJlc3RvcmUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlUmVzdG9yZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRGaWxsID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50U3R5bGUgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRDaHVua1dpZHRoID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGZvcm1hdCA9IFRleHRGb3JtYXR0ZXIuZ2V0VGV4dFN0eWxlKGNodW5rLnRleHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBmb250U3R5bGUgPSB0aGlzLl9nZXRGb250U3R5bGUoZm9ybWF0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5zYXZlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGdob3N0Q29udGV4dC5zYXZlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQuZm9udCA9IGZvbnRTdHlsZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFN0eWxlID0gZm9udFN0eWxlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZm9ybWF0LmZpbGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRGaWxsID0gZm9ybWF0LmZpbGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZvcm1hdC53aWR0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudENodW5rV2lkdGggPSAkdHlwZS50b051bWJlcihmb3JtYXQud2lkdGgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlUmVzdG9yZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRydW5jYXRlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsbGlwc2lzTWV0cmljcyA9IHRoaXMuX21lYXN1cmVUZXh0KGVsbGlwc2lzLCBjb250ZXh0KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBUZXh0IGZvcm1hdFxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY2h1bmsudHlwZSA9PSBcInZhbHVlXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBNZWFzdXJlIGVhY2ggbGV0dGVyXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2hhcnMgPSBjaHVuay50ZXh0Lm1hdGNoKC8uL3VnKSB8fCBbXTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocnRsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYXJzLnJldmVyc2UoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGFycy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjaGFyID0gY2hhcnNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1lYXN1cmVcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbWV0cmljcyA9IHRoaXMuX21lYXN1cmVUZXh0KGNoYXIsIGNvbnRleHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgY2h1bmtXaWR0aCA9IG1ldHJpY3Mud2lkdGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENodW5rIHdpZHRoP1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudFN0eWxlICYmIGN1cnJlbnRDaHVua1dpZHRoICYmIChjdXJyZW50Q2h1bmtXaWR0aCA+IGNodW5rV2lkdGgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaHVua1dpZHRoID0gY3VycmVudENodW5rV2lkdGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY2h1bmtIZWlnaHQgPSBtZXRyaWNzLmFjdHVhbEJvdW5kaW5nQm94QXNjZW50ICsgbWV0cmljcy5hY3R1YWxCb3VuZGluZ0JveERlc2NlbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaHVua0hlaWdodCA+IGxpbmVJbmZvLmhlaWdodCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZUluZm8uaGVpZ2h0ID0gY2h1bmtIZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1ldHJpY3MuYWN0dWFsQm91bmRpbmdCb3hBc2NlbnQgPiBsaW5lSW5mby5hc2NlbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVJbmZvLmFzY2VudCA9IG1ldHJpY3MuYWN0dWFsQm91bmRpbmdCb3hBc2NlbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgdG90YWxXaWR0aCArPSBjaHVua1dpZHRoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBIYW5kbGUgb3ZlcnNpemVkIGJlaGF2aW9yXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0cnVuY2F0ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTWVhc3VyZSBlbGxpcHNpcyBhbmQgY2hlY2sgaWYgaXQgZml0c1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFlbGxpcHNpc01ldHJpY3MpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGxpcHNpc01ldHJpY3MgPSB0aGlzLl9tZWFzdXJlVGV4dChlbGxpcHNpcywgY29udGV4dCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlbGxpcHNpc1dpZHRoID0gZWxsaXBzaXNNZXRyaWNzLmFjdHVhbEJvdW5kaW5nQm94TGVmdCArIGVsbGlwc2lzTWV0cmljcy5hY3R1YWxCb3VuZGluZ0JveFJpZ2h0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy90b3RhbFdpZHRoICs9IGVsbGlwc2lzV2lkdGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKHRvdGFsV2lkdGggKyBlbGxpcHNpc1dpZHRoKSA+IG1heFdpZHRoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxpbmVJbmZvLnRleHRDaHVua3MubGVuZ3RoID09IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50ZXh0VmlzaWJsZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZUluZm8ud2lkdGggKz0gZWxsaXBzaXNXaWR0aDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZUluZm8ubGVmdCArPSBlbGxpcHNpc01ldHJpY3MuYWN0dWFsQm91bmRpbmdCb3hMZWZ0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lSW5mby5yaWdodCArPSBlbGxpcHNpc01ldHJpY3MuYWN0dWFsQm91bmRpbmdCb3hSaWdodDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZUluZm8udGV4dENodW5rcy5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiBjdXJyZW50U3R5bGUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxsOiBjdXJyZW50RmlsbCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IGVsbGlwc2lzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IGVsbGlwc2lzV2lkdGgsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IGNodW5rSGVpZ2h0ICsgZWxsaXBzaXNNZXRyaWNzLmFjdHVhbEJvdW5kaW5nQm94RGVzY2VudCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQ6IGVsbGlwc2lzTWV0cmljcy5hY3R1YWxCb3VuZGluZ0JveExlZnQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByaWdodDogZWxsaXBzaXNNZXRyaWNzLmFjdHVhbEJvdW5kaW5nQm94UmlnaHQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc2NlbnQ6IGVsbGlwc2lzTWV0cmljcy5hY3R1YWxCb3VuZGluZ0JveEFzY2VudCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldFg6IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXRZOiBjaHVua0hlaWdodCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHREZWNvcmF0aW9uOiB1bmRlZmluZWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVJbmZvLndpZHRoICs9IGNodW5rV2lkdGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVJbmZvLmxlZnQgKz0gbWV0cmljcy5hY3R1YWxCb3VuZGluZ0JveExlZnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVJbmZvLnJpZ2h0ICs9IG1ldHJpY3MuYWN0dWFsQm91bmRpbmdCb3hSaWdodDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGluZUluZm8udGV4dENodW5rcy5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiBjdXJyZW50U3R5bGUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxsOiBjdXJyZW50RmlsbCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IGNoYXIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogY2h1bmtXaWR0aCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogY2h1bmtIZWlnaHQgKyBtZXRyaWNzLmFjdHVhbEJvdW5kaW5nQm94RGVzY2VudCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQ6IG1ldHJpY3MuYWN0dWFsQm91bmRpbmdCb3hMZWZ0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHQ6IG1ldHJpY3MuYWN0dWFsQm91bmRpbmdCb3hSaWdodCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzY2VudDogbWV0cmljcy5hY3R1YWxCb3VuZGluZ0JveEFzY2VudCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldFg6IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXRZOiBjaHVua0hlaWdodCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHREZWNvcmF0aW9uOiB1bmRlZmluZWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChydGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuc3R5bGUubGluZUhlaWdodCBpbnN0YW5jZW9mIFBlcmNlbnQpIHtcclxuICAgICAgICAgICAgICAgIGxpbmVJbmZvLmhlaWdodCAqPSB0aGlzLnN0eWxlLmxpbmVIZWlnaHQudmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBsaW5lSW5mby5oZWlnaHQgKj0gdGhpcy5zdHlsZS5saW5lSGVpZ2h0IHx8IDEuMjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl90ZXh0SW5mby5wdXNoKGxpbmVJbmZvKTtcclxuICAgICAgICAgICAgLy9saW5lSW5mby5vZmZzZXRZICs9IGxpbmVJbmZvLmFzY2VudDtcclxuICAgICAgICAgICAgb2Zmc2V0WSArPSBsaW5lSW5mby5oZWlnaHQ7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKCFzdHlsZVJlc3RvcmVkKSB7XHJcbiAgICAgICAgICAgIGNvbnRleHQucmVzdG9yZSgpO1xyXG4gICAgICAgICAgICBnaG9zdENvbnRleHQucmVzdG9yZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAob3ZlcnNpemVkQmVoYXZpb3IgPT0gXCJoaWRlXCIgJiYgKHRvdGFsV2lkdGggPiBtYXhXaWR0aCkpIHtcclxuICAgICAgICAgICAgdGhpcy50ZXh0VmlzaWJsZSA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBBZGp1c3QgY2h1bmsgaW50ZXJuYWwgb2Zmc2V0c1xyXG4gICAgICAgICRhcnJheS5lYWNoKHRoaXMuX3RleHRJbmZvLCAobGluZUluZm8pID0+IHtcclxuICAgICAgICAgICAgJGFycmF5LmVhY2gobGluZUluZm8udGV4dENodW5rcywgKGNodW5rKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjaHVuay5vZmZzZXRZICs9IE1hdGgucm91bmQoKGxpbmVJbmZvLmhlaWdodCAtIGNodW5rLmhlaWdodCArIChsaW5lSW5mby5hc2NlbnQgLSBjaHVuay5hc2NlbnQpKSAvIDIpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBjb250ZXh0LnJlc3RvcmUoKTtcclxuICAgICAgICBnaG9zdENvbnRleHQucmVzdG9yZSgpO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGxlZnQ6IDAsXHJcbiAgICAgICAgICAgIHRvcDogMCxcclxuICAgICAgICAgICAgcmlnaHQ6IDAsXHJcbiAgICAgICAgICAgIGJvdHRvbTogMCxcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBAaWdub3JlXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgQ2FudmFzSW1hZ2UgZXh0ZW5kcyBDYW52YXNEaXNwbGF5T2JqZWN0IHtcclxuICAgIGNvbnN0cnVjdG9yKHJlbmRlcmVyLCBpbWFnZSkge1xyXG4gICAgICAgIHN1cGVyKHJlbmRlcmVyKTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ3aWR0aFwiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJoZWlnaHRcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiaW1hZ2VcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwidGFpbnRlZFwiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJzaGFkb3dDb2xvclwiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJzaGFkb3dCbHVyXCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInNoYWRvd09mZnNldFhcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwic2hhZG93T2Zmc2V0WVwiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJzaGFkb3dPcGFjaXR5XCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9pbWFnZU1hc2tcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5pbWFnZSA9IGltYWdlO1xyXG4gICAgfVxyXG4gICAgX2Rpc3Bvc2UoKSB7XHJcbiAgICAgICAgc3VwZXIuX2Rpc3Bvc2UoKTtcclxuICAgICAgICBpZiAodGhpcy5faW1hZ2VNYXNrKSB7XHJcbiAgICAgICAgICAgIGNsZWFyQ2FudmFzKHRoaXMuX2ltYWdlTWFzayk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZ2V0TG9jYWxCb3VuZHMoKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9sb2NhbEJvdW5kcykge1xyXG4gICAgICAgICAgICBsZXQgdyA9IDA7XHJcbiAgICAgICAgICAgIGxldCBoID0gMDtcclxuICAgICAgICAgICAgaWYgKHRoaXMud2lkdGgpIHtcclxuICAgICAgICAgICAgICAgIHcgPSB0aGlzLndpZHRoO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmhlaWdodCkge1xyXG4gICAgICAgICAgICAgICAgaCA9IHRoaXMuaGVpZ2h0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX2xvY2FsQm91bmRzID0ge1xyXG4gICAgICAgICAgICAgICAgbGVmdDogMCxcclxuICAgICAgICAgICAgICAgIHRvcDogMCxcclxuICAgICAgICAgICAgICAgIHJpZ2h0OiB3LFxyXG4gICAgICAgICAgICAgICAgYm90dG9tOiBoXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHRoaXMuX2FkZEJvdW5kcyh0aGlzLl9sb2NhbEJvdW5kcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLl9sb2NhbEJvdW5kcztcclxuICAgIH1cclxuICAgIF9yZW5kZXIoc3RhdHVzKSB7XHJcbiAgICAgICAgc3VwZXIuX3JlbmRlcihzdGF0dXMpO1xyXG4gICAgICAgIGlmICh0aGlzLmltYWdlKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnRhaW50ZWQgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy50YWludGVkID0gaXNUYWludGVkKHRoaXMuaW1hZ2UpO1xyXG4gICAgICAgICAgICAgICAgc3RhdHVzLmxheWVyLnRhaW50ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnRhaW50ZWQgJiYgdGhpcy5fcmVuZGVyZXIuX29taXRUYWludGVkKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHN0YXR1cy5sYXllci5kaXJ0eSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc2hhZG93Q29sb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICBzdGF0dXMubGF5ZXIuY29udGV4dC5zaGFkb3dDb2xvciA9IHRoaXMuc2hhZG93Q29sb3IudG9DU1ModGhpcy5zaGFkb3dPcGFjaXR5IHx8IDEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc2hhZG93Qmx1cikge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5sYXllci5jb250ZXh0LnNoYWRvd0JsdXIgPSB0aGlzLnNoYWRvd0JsdXI7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zaGFkb3dPZmZzZXRYKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmxheWVyLmNvbnRleHQuc2hhZG93T2Zmc2V0WCA9IHRoaXMuc2hhZG93T2Zmc2V0WDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnNoYWRvd09mZnNldFkpIHtcclxuICAgICAgICAgICAgICAgICAgICBzdGF0dXMubGF5ZXIuY29udGV4dC5zaGFkb3dPZmZzZXRZID0gdGhpcy5zaGFkb3dPZmZzZXRZO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gVE9ETyBzaG91bGQgdGhpcyByb3VuZCA/XHJcbiAgICAgICAgICAgICAgICBjb25zdCB3aWR0aCA9IHRoaXMud2lkdGggfHwgdGhpcy5pbWFnZS5uYXR1cmFsV2lkdGg7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBoZWlnaHQgPSB0aGlzLmhlaWdodCB8fCB0aGlzLmltYWdlLm5hdHVyYWxIZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICBzdGF0dXMubGF5ZXIuY29udGV4dC5kcmF3SW1hZ2UodGhpcy5pbWFnZSwgMCwgMCwgd2lkdGgsIGhlaWdodCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRoaXMuaW50ZXJhY3RpdmUgJiYgdGhpcy5faXNJbnRlcmFjdGl2ZShzdGF0dXMpKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBtYXNrID0gdGhpcy5fZ2V0TWFzayh0aGlzLmltYWdlKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLl9naG9zdExheWVyLmNvbnRleHQuZHJhd0ltYWdlKG1hc2ssIDAsIDApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY2xlYXIoKSB7XHJcbiAgICAgICAgc3VwZXIuY2xlYXIoKTtcclxuICAgICAgICB0aGlzLmltYWdlID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHRoaXMuX2ltYWdlTWFzayA9IHVuZGVmaW5lZDtcclxuICAgIH1cclxuICAgIF9nZXRNYXNrKGltYWdlKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2ltYWdlTWFzayA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIC8vIFRPRE8gc2hvdWxkIHRoaXMgcm91bmQgP1xyXG4gICAgICAgICAgICBjb25zdCB3aWR0aCA9IHRoaXMud2lkdGggfHwgaW1hZ2UubmF0dXJhbFdpZHRoO1xyXG4gICAgICAgICAgICBjb25zdCBoZWlnaHQgPSB0aGlzLmhlaWdodCB8fCBpbWFnZS5uYXR1cmFsSGVpZ2h0O1xyXG4gICAgICAgICAgICAvLyBXZSBuZWVkIHRvIGNyZWF0ZSBhIHNlY29uZCBjYW52YXMgYmVjYXVzZSBkZXN0aW5hdGlvbi1pbiBjbGVhcnMgb3V0IHRoZSBlbnRpcmUgY2FudmFzXHJcbiAgICAgICAgICAgIGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XHJcbiAgICAgICAgICAgIGNhbnZhcy53aWR0aCA9IHdpZHRoO1xyXG4gICAgICAgICAgICBjYW52YXMuaGVpZ2h0ID0gaGVpZ2h0O1xyXG4gICAgICAgICAgICBjb25zdCBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcclxuICAgICAgICAgICAgY29udGV4dC5pbWFnZVNtb290aGluZ0VuYWJsZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgY29udGV4dC5maWxsU3R5bGUgPSB0aGlzLl9nZXRDb2xvcklkKCk7XHJcbiAgICAgICAgICAgIGNvbnRleHQuZmlsbFJlY3QoMCwgMCwgd2lkdGgsIGhlaWdodCk7XHJcbiAgICAgICAgICAgIGlmICghaXNUYWludGVkKGltYWdlKSkge1xyXG4gICAgICAgICAgICAgICAgY29udGV4dC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSBcImRlc3RpbmF0aW9uLWluXCI7XHJcbiAgICAgICAgICAgICAgICBjb250ZXh0LmRyYXdJbWFnZShpbWFnZSwgMCwgMCwgd2lkdGgsIGhlaWdodCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5faW1hZ2VNYXNrID0gY2FudmFzO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5faW1hZ2VNYXNrO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBAaWdub3JlXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgQ2FudmFzUmVuZGVyZXJFdmVudCB7XHJcbiAgICBjb25zdHJ1Y3RvcihldmVudCwgb3JpZ2luYWxQb2ludCwgcG9pbnQsIGJib3gpIHtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJldmVudFwiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiBldmVudFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm9yaWdpbmFsUG9pbnRcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogb3JpZ2luYWxQb2ludFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInBvaW50XCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IHBvaW50XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiYmJveFwiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiBiYm94XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiaWRcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwic2ltdWxhdGVkXCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IGZhbHNlXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmF0aXZlXCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IHRydWVcclxuICAgICAgICB9KTtcclxuICAgICAgICBpZiAoJHV0aWxzLnN1cHBvcnRzKFwidG91Y2hldmVudHNcIikgJiYgZXZlbnQgaW5zdGFuY2VvZiBUb3VjaCkge1xyXG4gICAgICAgICAgICB0aGlzLmlkID0gZXZlbnQuaWRlbnRpZmllcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuaWQgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4vKipcclxuICogQGlnbm9yZVxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIENhbnZhc1JlbmRlcmVyIGV4dGVuZHMgQXJyYXlEaXNwb3NlciB7XHJcbiAgICAvKnByb3RlY3RlZCBfbW91c2VNb3ZlVGhyb3R0bGVyOiBUaHJvdHRsZXIgPSBuZXcgVGhyb3R0bGVyKCgpID0+IHtcclxuICAgICAgICB0aGlzLl9kaXNwYXRjaEdsb2JhbE1vdXNlbW92ZSh0aGlzLl9sYXN0UG9pbnRlck1vdmVFdmVudC5ldmVudCwgdGhpcy5fbGFzdFBvaW50ZXJNb3ZlRXZlbnQubmF0aXZlKTtcclxuICAgIH0pO1xyXG4gICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKHJlc29sdXRpb24pIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInZpZXdcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9sYXllckRvbVwiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibGF5ZXJzXCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IFtdXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX2RpcnR5TGF5ZXJzXCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IFtdXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZGVmYXVsdExheWVyXCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IHRoaXMuZ2V0TGF5ZXIoMClcclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfZ2hvc3RMYXllclwiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiBuZXcgR2hvc3RMYXllcigpXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX3BhdHRlcm5DYW52YXNcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9wYXR0ZXJuQ29udGV4dFwiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiB0aGlzLl9wYXR0ZXJuQ2FudmFzLmdldENvbnRleHQoXCIyZFwiKVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9yZWFsV2lkdGhcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogMFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9yZWFsSGVpZ2h0XCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IDBcclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfY2FsY3VsYXRlZFdpZHRoXCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IDBcclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfY2FsY3VsYXRlZEhlaWdodFwiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiAwXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwicmVzb2x1dGlvblwiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJpbnRlcmFjdGlvbnNFbmFibGVkXCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IHRydWVcclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfbGlzdGVuZXJzXCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IHt9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX2V2ZW50c1wiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiB7fVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9jb2xvcklkXCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IDBcclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfY29sb3JNYXBcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZToge31cclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfZm9yY2VJbnRlcmFjdGl2ZVwiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiAwXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX29taXRUYWludGVkXCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IGZhbHNlXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLy8gVE9ETyB0aGlzIHNob3VsZCBzdG9yZSB0aGUgSWQgYXMgd2VsbFxyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9ob3ZlcmluZ1wiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiBuZXcgU2V0KClcclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfZHJhZ2dpbmdcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogW11cclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfbW91c2Vkb3duXCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IFtdXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX2xhc3RQb2ludGVyTW92ZUV2ZW50XCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInRhcFRvQWN0aXZhdGVcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogZmFsc2VcclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ0YXBUb0FjdGl2YXRlVGltZW91dFwiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiAzMDAwXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX3RvdWNoQWN0aXZlXCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IGZhbHNlXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX3RvdWNoQWN0aXZlVGltZW91dFwiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcclxuICAgICAgICB9KTtcclxuICAgICAgICBpZiAocmVzb2x1dGlvbiA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVzb2x1dGlvbiA9IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5yZXNvbHV0aW9uID0gcmVzb2x1dGlvbjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy52aWV3LnN0eWxlLnBvc2l0aW9uID0gXCJhYnNvbHV0ZVwiO1xyXG4gICAgICAgIHRoaXMudmlldy5zZXRBdHRyaWJ1dGUoXCJhcmlhLWhpZGRlblwiLCBcInRydWVcIik7XHJcbiAgICAgICAgdGhpcy52aWV3LmFwcGVuZENoaWxkKHRoaXMuX2xheWVyRG9tKTtcclxuICAgICAgICB0aGlzLl9kaXNwb3NlcnMucHVzaChuZXcgRGlzcG9zZXIoKCkgPT4ge1xyXG4gICAgICAgICAgICAkb2JqZWN0LmVhY2godGhpcy5fZXZlbnRzLCAoX2tleSwgZXZlbnRzKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBldmVudHMuZGlzcG9zZXIuZGlzcG9zZSgpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgJGFycmF5LmVhY2godGhpcy5sYXllcnMsIChsYXllcikgPT4ge1xyXG4gICAgICAgICAgICAgICAgY2xlYXJDYW52YXMobGF5ZXIudmlldyk7XHJcbiAgICAgICAgICAgICAgICBpZiAobGF5ZXIuZXhwb3J0YWJsZVZpZXcpIHtcclxuICAgICAgICAgICAgICAgICAgICBjbGVhckNhbnZhcyhsYXllci5leHBvcnRhYmxlVmlldyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBjbGVhckNhbnZhcyh0aGlzLl9naG9zdExheWVyLnZpZXcpO1xyXG4gICAgICAgICAgICBjbGVhckNhbnZhcyh0aGlzLl9wYXR0ZXJuQ2FudmFzKTtcclxuICAgICAgICB9KSk7XHJcbiAgICAgICAgLypcclxuICAgICAgICB0aGlzLl9kaXNwb3NlcnMucHVzaCgkdXRpbHMuYWRkRXZlbnRMaXN0ZW5lcih0aGlzLl9naG9zdExheWVyLnZpZXcsIFwiY2xpY2tcIiwgKG9yaWdpbmFsRXZlbnQ6IE1vdXNlRXZlbnQpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgZXZlbnQgPSB0aGlzLmdldEV2ZW50KG9yaWdpbmFsRXZlbnQpO1xyXG4gICAgICAgICAgICBjb25zdCB0YXJnZXQgPSB0aGlzLl9nZXRIaXRUYXJnZXQoZXZlbnQub3JpZ2luYWxQb2ludCwgZXZlbnQuYmJveCk7XHJcbiAgICAgICAgICAgIGNvbnNvbGUuZGVidWcodGFyZ2V0KTtcclxuICAgICAgICB9KSk7XHJcbiAgICAgICAgKi9cclxuICAgICAgICAvLyBNb25pdG9yIGZvciBwb3NzaWJsZSBwaXhlbCByYXRpbyBjaGFuZ2VzICh3aGVuIHBhZ2UgaXMgem9vbWVkKVxyXG4gICAgICAgIHRoaXMuX2Rpc3Bvc2Vycy5wdXNoKCR1dGlscy5vblpvb20oKCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAocmVzb2x1dGlvbiA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlc29sdXRpb24gPSB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pKTtcclxuICAgICAgICAvLyBXZSBuZWVkIHRoaXMgaW4gb3JkZXIgdG9wIHByZXZlbnQgZGVmYXVsdCB0b3VjaCBnZXN0dXJlcyB3aGVuIGRyYWdnaW5nXHJcbiAgICAgICAgLy8gZHJhZ2dhYmxlIGVsZW1lbnRzXHJcbiAgICAgICAgaWYgKCR1dGlscy5zdXBwb3J0cyhcInRvdWNoZXZlbnRzXCIpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGxpc3RlbmVyID0gKGV2KSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fZHJhZ2dpbmcubGVuZ3RoICE9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgJGFycmF5LmVhY2hDb250aW51ZSh0aGlzLl9kcmFnZ2luZywgKGl0ZW0pID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW0udmFsdWUuc2hvdWxkQ2FuY2VsVG91Y2goKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXYucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIElmIHRvdWNoIGRvd24gaGFwcGVuZHMsIGRlbGF5IHRvdWNoIG91dFxyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3RvdWNoQWN0aXZlVGltZW91dCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RlbGF5VG91Y2hEZWFjdGl2YXRlKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHRoaXMuX2Rpc3Bvc2Vycy5wdXNoKCR1dGlscy5hZGRFdmVudExpc3RlbmVyKHdpbmRvdywgXCJ0b3VjaHN0YXJ0XCIsIGxpc3RlbmVyLCB7IHBhc3NpdmU6IGZhbHNlIH0pKTtcclxuICAgICAgICAgICAgdGhpcy5fZGlzcG9zZXJzLnB1c2goJHV0aWxzLmFkZEV2ZW50TGlzdGVuZXIodGhpcy52aWV3LCBcInRvdWNoc3RhcnRcIiwgbGlzdGVuZXIsIHsgcGFzc2l2ZTogZmFsc2UgfSkpO1xyXG4gICAgICAgICAgICB0aGlzLl9kaXNwb3NlcnMucHVzaCgkdXRpbHMuYWRkRXZlbnRMaXN0ZW5lcih0aGlzLnZpZXcsIFwidG91Y2htb3ZlXCIsICgpID0+IHtcclxuICAgICAgICAgICAgICAgIC8vIElmIHRvdWNoIGlzIG1vdmluZywgZGVsYXkgdG91Y2ggb3V0XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fdG91Y2hBY3RpdmVUaW1lb3V0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGVsYXlUb3VjaERlYWN0aXZhdGUoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSwgeyBwYXNzaXZlOiB0cnVlIH0pKTtcclxuICAgICAgICAgICAgdGhpcy5fZGlzcG9zZXJzLnB1c2goJHV0aWxzLmFkZEV2ZW50TGlzdGVuZXIod2luZG93LCBcImNsaWNrXCIsIChfZXYpID0+IHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3RvdWNoQWN0aXZlID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH0sIHsgcGFzc2l2ZTogdHJ1ZSB9KSk7XHJcbiAgICAgICAgICAgIHRoaXMuX2Rpc3Bvc2Vycy5wdXNoKCR1dGlscy5hZGRFdmVudExpc3RlbmVyKHRoaXMudmlldywgXCJjbGlja1wiLCAoX2V2KSA9PiB7XHJcbiAgICAgICAgICAgICAgICB3aW5kb3cuc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdG91Y2hBY3RpdmUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RlbGF5VG91Y2hEZWFjdGl2YXRlKCk7XHJcbiAgICAgICAgICAgICAgICB9LCAxMDApO1xyXG4gICAgICAgICAgICB9LCB7IHBhc3NpdmU6IHRydWUgfSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBQcmV2ZW50IHNjcm9sbGluZyBvZiB0aGUgd2luZG93IHdoZW4gaG92ZXJpbmcgb24gXCJ3aGVlbGFibGVcIiBvYmplY3RcclxuICAgICAgICBpZiAoJHV0aWxzLnN1cHBvcnRzKFwid2hlZWxldmVudHNcIikpIHtcclxuICAgICAgICAgICAgdGhpcy5fZGlzcG9zZXJzLnB1c2goJHV0aWxzLmFkZEV2ZW50TGlzdGVuZXIodGhpcy52aWV3LCBcIndoZWVsXCIsIChldikgPT4ge1xyXG4gICAgICAgICAgICAgICAgbGV0IHByZXZlbnQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2hvdmVyaW5nLmZvckVhY2goKG9iaikgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvYmoud2hlZWxhYmxlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZXZlbnQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBpZiAocHJldmVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sIHsgcGFzc2l2ZTogZmFsc2UgfSkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIF9kZWxheVRvdWNoRGVhY3RpdmF0ZSgpIHtcclxuICAgICAgICBpZiAodGhpcy5fdG91Y2hBY3RpdmVUaW1lb3V0KSB7XHJcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLl90b3VjaEFjdGl2ZVRpbWVvdXQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy50YXBUb0FjdGl2YXRlVGltZW91dCA+IDApIHtcclxuICAgICAgICAgICAgdGhpcy5fdG91Y2hBY3RpdmVUaW1lb3V0ID0gd2luZG93LnNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fdG91Y2hBY3RpdmUgPSBmYWxzZTtcclxuICAgICAgICAgICAgfSwgdGhpcy50YXBUb0FjdGl2YXRlVGltZW91dCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZ2V0IGRlYnVnR2hvc3RWaWV3KCkge1xyXG4gICAgICAgIHJldHVybiAhIXRoaXMuX2dob3N0TGF5ZXIudmlldy5wYXJlbnROb2RlO1xyXG4gICAgfVxyXG4gICAgc2V0IGRlYnVnR2hvc3RWaWV3KHZhbHVlKSB7XHJcbiAgICAgICAgaWYgKHZhbHVlKSB7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5fZ2hvc3RMYXllci52aWV3LnBhcmVudE5vZGUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudmlldy5hcHBlbmRDaGlsZCh0aGlzLl9naG9zdExheWVyLnZpZXcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fZ2hvc3RMYXllci52aWV3LnBhcmVudE5vZGUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2dob3N0TGF5ZXIudmlldy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuX2dob3N0TGF5ZXIudmlldyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjcmVhdGVMaW5lYXJHcmFkaWVudCh4MSwgeTEsIHgyLCB5Mikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmRlZmF1bHRMYXllci5jb250ZXh0LmNyZWF0ZUxpbmVhckdyYWRpZW50KHgxLCB5MSwgeDIsIHkyKTtcclxuICAgIH1cclxuICAgIGNyZWF0ZVJhZGlhbEdyYWRpZW50KHgxLCB5MSwgcmFkaXVzMSwgeDIsIHkyLCByYWRpdXMyKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVmYXVsdExheWVyLmNvbnRleHQuY3JlYXRlUmFkaWFsR3JhZGllbnQoeDEsIHkxLCByYWRpdXMxLCB4MiwgeTIsIHJhZGl1czIpO1xyXG4gICAgfVxyXG4gICAgY3JlYXRlUGF0dGVybihncmFwaGljcywgYmFja2dyb3VuZCwgcmVwZXRpdGlvbiwgd2lkdGgsIGhlaWdodCkge1xyXG4gICAgICAgIC8vIGNvbnN0IHBhdHRlcm5DYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xyXG4gICAgICAgIC8vIGNvbnN0IHBhdHRlcm5Db250ZXh0ID0gcGF0dGVybkNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIikhO1xyXG4gICAgICAgIC8vIHBhdHRlcm5DYW52YXMud2lkdGggPSB3aWR0aDtcclxuICAgICAgICAvLyBwYXR0ZXJuQ2FudmFzLmhlaWdodCA9IGhlaWdodDtcclxuICAgICAgICAvLyBpZiAoZmlsbCkge1xyXG4gICAgICAgIC8vIFx0cGF0dGVybkNvbnRleHQuZmlsbFN0eWxlID0gZmlsbC50b0NTUygpO1xyXG4gICAgICAgIC8vIFx0cGF0dGVybkNvbnRleHQuZmlsbFJlY3QoMCwgMCwgcGF0dGVybkNhbnZhcy53aWR0aCwgcGF0dGVybkNhbnZhcy5oZWlnaHQpO1xyXG4gICAgICAgIC8vIH1cclxuICAgICAgICAvLyBjb25zdCBsYXllciA9IHtcclxuICAgICAgICAvLyBcdHZpZXc6IHBhdHRlcm5DYW52YXMsXHJcbiAgICAgICAgLy8gXHRjb250ZXh0OiBwYXR0ZXJuQ29udGV4dCxcclxuICAgICAgICAvLyBcdHZpc2libGU6IHRydWUsXHJcbiAgICAgICAgLy8gXHRvcmRlcjogMCxcclxuICAgICAgICAvLyBcdHdpZHRoOiB3aWR0aCxcclxuICAgICAgICAvLyBcdGhlaWdodDogaGVpZ2h0LFxyXG4gICAgICAgIC8vIFx0ZGlydHk6IHRydWVcclxuICAgICAgICAvLyB9O1xyXG4gICAgICAgIC8vIC8vIHBhdHRlcm5Db250ZXh0LmFyYygwLCAwLCA1MCwgMCwgLjUgKiBNYXRoLlBJKTtcclxuICAgICAgICAvLyAvLyBwYXR0ZXJuQ29udGV4dC5zdHJva2UoKTtcclxuICAgICAgICAvLyBpbWFnZS50YXJnZXRMYXllciA9IGxheWVyO1xyXG4gICAgICAgIC8vIGltYWdlLnJlbmRlcihsYXllcik7XHJcbiAgICAgICAgLy90aGlzLl9sYXllckRvbS5hcHBlbmRDaGlsZChwYXR0ZXJuQ2FudmFzKTtcclxuICAgICAgICB0aGlzLl9wYXR0ZXJuQ2FudmFzLndpZHRoID0gd2lkdGg7XHJcbiAgICAgICAgdGhpcy5fcGF0dGVybkNhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XHJcbiAgICAgICAgdGhpcy5fcGF0dGVybkNvbnRleHQuY2xlYXJSZWN0KDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xyXG4gICAgICAgIC8vIHBhdHRlcm5DYW52YXMuc3R5bGUud2lkdGggPSB3aWR0aCAqIHRoaXMucmVzb2x1dGlvbiArIFwicHhcIjtcclxuICAgICAgICAvLyBwYXR0ZXJuQ2FudmFzLnN0eWxlLmhlaWdodCA9IGhlaWdodCAqIHRoaXMucmVzb2x1dGlvbiArIFwicHhcIjtcclxuICAgICAgICBiYWNrZ3JvdW5kLnJlbmRlckRldGFjaGVkKHRoaXMuX3BhdHRlcm5Db250ZXh0KTtcclxuICAgICAgICBncmFwaGljcy5yZW5kZXJEZXRhY2hlZCh0aGlzLl9wYXR0ZXJuQ29udGV4dCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhdHRlcm5Db250ZXh0LmNyZWF0ZVBhdHRlcm4odGhpcy5fcGF0dGVybkNhbnZhcywgcmVwZXRpdGlvbik7XHJcbiAgICB9XHJcbiAgICBtYWtlQ29udGFpbmVyKCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgQ2FudmFzQ29udGFpbmVyKHRoaXMpO1xyXG4gICAgfVxyXG4gICAgbWFrZUdyYXBoaWNzKCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgQ2FudmFzR3JhcGhpY3ModGhpcyk7XHJcbiAgICB9XHJcbiAgICBtYWtlVGV4dCh0ZXh0LCBzdHlsZSkge1xyXG4gICAgICAgIHJldHVybiBuZXcgQ2FudmFzVGV4dCh0aGlzLCB0ZXh0LCBzdHlsZSk7XHJcbiAgICB9XHJcbiAgICBtYWtlVGV4dFN0eWxlKCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgQ2FudmFzVGV4dFN0eWxlKCk7XHJcbiAgICB9XHJcbiAgICBtYWtlUmFkaWFsVGV4dCh0ZXh0LCBzdHlsZSkge1xyXG4gICAgICAgIHJldHVybiBuZXcgQ2FudmFzUmFkaWFsVGV4dCh0aGlzLCB0ZXh0LCBzdHlsZSk7XHJcbiAgICB9XHJcbiAgICBtYWtlUGljdHVyZShpbWFnZSkge1xyXG4gICAgICAgIHJldHVybiBuZXcgQ2FudmFzSW1hZ2UodGhpcywgaW1hZ2UpO1xyXG4gICAgfVxyXG4gICAgcmVzaXplTGF5ZXIobGF5ZXIpIHtcclxuICAgICAgICBsYXllci5yZXNpemUodGhpcy5fY2FsY3VsYXRlZFdpZHRoLCB0aGlzLl9jYWxjdWxhdGVkSGVpZ2h0LCB0aGlzLl9jYWxjdWxhdGVkV2lkdGgsIHRoaXMuX2NhbGN1bGF0ZWRIZWlnaHQsIHRoaXMucmVzb2x1dGlvbik7XHJcbiAgICB9XHJcbiAgICByZXNpemVHaG9zdCgpIHtcclxuICAgICAgICB0aGlzLl9naG9zdExheWVyLnJlc2l6ZSh0aGlzLl9jYWxjdWxhdGVkV2lkdGgsIHRoaXMuX2NhbGN1bGF0ZWRIZWlnaHQsIHRoaXMuX2NhbGN1bGF0ZWRXaWR0aCwgdGhpcy5fY2FsY3VsYXRlZEhlaWdodCwgdGhpcy5yZXNvbHV0aW9uKTtcclxuICAgIH1cclxuICAgIHJlc2l6ZShyZWFsV2lkdGgsIHJlYWxIZWlnaHQsIGNhbGN1bGF0ZWRXaWR0aCwgY2FsY3VsYXRlZEhlaWdodCkge1xyXG4gICAgICAgIHRoaXMuX3JlYWxXaWR0aCA9IHJlYWxXaWR0aDtcclxuICAgICAgICB0aGlzLl9yZWFsSGVpZ2h0ID0gcmVhbEhlaWdodDtcclxuICAgICAgICB0aGlzLl9jYWxjdWxhdGVkV2lkdGggPSBjYWxjdWxhdGVkV2lkdGg7XHJcbiAgICAgICAgdGhpcy5fY2FsY3VsYXRlZEhlaWdodCA9IGNhbGN1bGF0ZWRIZWlnaHQ7XHJcbiAgICAgICAgJGFycmF5LmVhY2godGhpcy5sYXllcnMsIChsYXllcikgPT4ge1xyXG4gICAgICAgICAgICBpZiAobGF5ZXIpIHtcclxuICAgICAgICAgICAgICAgIGxheWVyLmRpcnR5ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVzaXplTGF5ZXIobGF5ZXIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5yZXNpemVHaG9zdCgpO1xyXG4gICAgICAgIHRoaXMudmlldy5zdHlsZS53aWR0aCA9IGNhbGN1bGF0ZWRXaWR0aCArIFwicHhcIjtcclxuICAgICAgICB0aGlzLnZpZXcuc3R5bGUuaGVpZ2h0ID0gY2FsY3VsYXRlZEhlaWdodCArIFwicHhcIjtcclxuICAgIH1cclxuICAgIGNyZWF0ZURldGFjaGVkTGF5ZXIod2lsbFJlYWRGcmVxdWVudGx5ID0gZmFsc2UpIHtcclxuICAgICAgICBjb25zdCB2aWV3ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcclxuICAgICAgICBjb25zdCBjb250ZXh0ID0gdmlldy5nZXRDb250ZXh0KFwiMmRcIiwgeyB3aWxsUmVhZEZyZXF1ZW50bHk6IHdpbGxSZWFkRnJlcXVlbnRseSB9KTtcclxuICAgICAgICBjb25zdCBsYXllciA9IG5ldyBDYW52YXNMYXllcih2aWV3LCBjb250ZXh0KTtcclxuICAgICAgICB2aWV3LnN0eWxlLnBvc2l0aW9uID0gXCJhYnNvbHV0ZVwiO1xyXG4gICAgICAgIHZpZXcuc3R5bGUudG9wID0gXCIwcHhcIjtcclxuICAgICAgICB2aWV3LnN0eWxlLmxlZnQgPSBcIjBweFwiO1xyXG4gICAgICAgIHJldHVybiBsYXllcjtcclxuICAgIH1cclxuICAgIGdldExheWVyQnlPcmRlcihvcmRlcikge1xyXG4gICAgICAgIGNvbnN0IGxheWVycyA9IHRoaXMubGF5ZXJzO1xyXG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IGxheWVycy5sZW5ndGg7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBjb25zdCBsYXllciA9IGxheWVyc1tpXTtcclxuICAgICAgICAgICAgaWYgKGxheWVyLm9yZGVyID09IG9yZGVyKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbGF5ZXI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBnZXRMYXllcihvcmRlciwgdmlzaWJsZSA9IHRydWUpIHtcclxuICAgICAgICBsZXQgZXhpc3RpbmdMYXllciA9IHRoaXMuZ2V0TGF5ZXJCeU9yZGVyKG9yZGVyKTtcclxuICAgICAgICBpZiAoZXhpc3RpbmdMYXllcikge1xyXG4gICAgICAgICAgICByZXR1cm4gZXhpc3RpbmdMYXllcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgbGF5ZXIgPSB0aGlzLmNyZWF0ZURldGFjaGVkTGF5ZXIob3JkZXIgPT0gOTkpO1xyXG4gICAgICAgIGxheWVyLm9yZGVyID0gb3JkZXI7XHJcbiAgICAgICAgbGF5ZXIudmlzaWJsZSA9IHZpc2libGU7XHJcbiAgICAgICAgbGF5ZXIudmlldy5jbGFzc05hbWUgPSBcImFtNS1sYXllci1cIiArIG9yZGVyO1xyXG4gICAgICAgIGlmIChsYXllci52aXNpYmxlKSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVzaXplTGF5ZXIobGF5ZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBsYXllcnMgPSB0aGlzLmxheWVycztcclxuICAgICAgICBsYXllcnMucHVzaChsYXllcik7XHJcbiAgICAgICAgbGF5ZXJzLnNvcnQoKGEsIGIpID0+IHtcclxuICAgICAgICAgICAgaWYgKGEub3JkZXIgPiBiLm9yZGVyKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChhLm9yZGVyIDwgYi5vcmRlcikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICBjb25zdCBsZW5ndGggPSBsYXllcnMubGVuZ3RoO1xyXG4gICAgICAgIGNvbnN0IGxheWVySW5kZXggPSAkYXJyYXkuaW5kZXhPZihsYXllcnMsIGxheWVyKTtcclxuICAgICAgICBsZXQgbmV4dDtcclxuICAgICAgICBmb3IgKGxldCBpID0gbGF5ZXJJbmRleCArIDE7IGkgPCBsZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAobGF5ZXJzW2ldLnZpc2libGUpIHtcclxuICAgICAgICAgICAgICAgIG5leHQgPSBsYXllcnNbaV07XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobGF5ZXIudmlzaWJsZSkge1xyXG4gICAgICAgICAgICBpZiAobmV4dCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9sYXllckRvbS5hcHBlbmRDaGlsZChsYXllci52aWV3KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2xheWVyRG9tLmluc2VydEJlZm9yZShsYXllci52aWV3LCBuZXh0LnZpZXcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBsYXllcjtcclxuICAgIH1cclxuICAgIHJlbmRlcihyb290KSB7XHJcbiAgICAgICAgdGhpcy5fZGlydHlMYXllcnMubGVuZ3RoID0gMDtcclxuICAgICAgICAkYXJyYXkuZWFjaCh0aGlzLmxheWVycywgKGxheWVyKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChsYXllcikge1xyXG4gICAgICAgICAgICAgICAgaWYgKGxheWVyLmRpcnR5ICYmIGxheWVyLnZpc2libGUpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kaXJ0eUxheWVycy5wdXNoKGxheWVyKTtcclxuICAgICAgICAgICAgICAgICAgICBsYXllci5jbGVhcigpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5fZ2hvc3RMYXllci5jbGVhcigpO1xyXG4gICAgICAgIHJvb3QucmVuZGVyKHtcclxuICAgICAgICAgICAgaW5hY3RpdmU6IG51bGwsXHJcbiAgICAgICAgICAgIGxheWVyOiB0aGlzLmRlZmF1bHRMYXllcixcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLl9naG9zdExheWVyLmNvbnRleHQucmVzdG9yZSgpO1xyXG4gICAgICAgIC8vc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgLy8gUmVtb3ZlIHRoaXMgYWZ0ZXIgdGhlIENocm9tZSBidWcgaXMgZml4ZWQ6XHJcbiAgICAgICAgLy8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9MTI3OTM5NFxyXG4gICAgICAgICRhcnJheS5lYWNoKHRoaXMubGF5ZXJzLCAobGF5ZXIpID0+IHtcclxuICAgICAgICAgICAgaWYgKGxheWVyKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjb250ZXh0ID0gbGF5ZXIuY29udGV4dDtcclxuICAgICAgICAgICAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XHJcbiAgICAgICAgICAgICAgICBjb250ZXh0Lm1vdmVUbygwLCAwKTtcclxuICAgICAgICAgICAgICAgIGNvbnRleHQuc3Ryb2tlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICAkYXJyYXkuZWFjaCh0aGlzLl9kaXJ0eUxheWVycywgKGxheWVyKSA9PiB7XHJcbiAgICAgICAgICAgIGxheWVyLmNvbnRleHQucmVzdG9yZSgpO1xyXG4gICAgICAgICAgICBsYXllci5kaXJ0eSA9IGZhbHNlO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8vfSwgMTAwKVxyXG4gICAgICAgIGlmICh0aGlzLl9ob3ZlcmluZy5zaXplICYmIHRoaXMuX2xhc3RQb2ludGVyTW92ZUV2ZW50KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgZXZlbnRzLCB0YXJnZXQsIG5hdGl2ZSB9ID0gdGhpcy5fbGFzdFBvaW50ZXJNb3ZlRXZlbnQ7XHJcbiAgICAgICAgICAgIC8vdGhpcy5fbW91c2VNb3ZlVGhyb3R0bGVyLnJ1bigpO1xyXG4gICAgICAgICAgICAkYXJyYXkuZWFjaChldmVudHMsIChldmVudCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZGlzcGF0Y2hHbG9iYWxNb3VzZW1vdmUoZXZlbnQsIHRhcmdldCwgbmF0aXZlKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcGFpbnRJZChvYmopIHtcclxuICAgICAgICBjb25zdCBpZCA9IGRpc3RyaWJ1dGVJZCgrK3RoaXMuX2NvbG9ySWQpO1xyXG4gICAgICAgIGNvbnN0IGNvbG9yID0gQ29sb3IuZnJvbUhleChpZCkudG9DU1MoKTtcclxuICAgICAgICB0aGlzLl9jb2xvck1hcFtjb2xvcl0gPSBvYmo7XHJcbiAgICAgICAgcmV0dXJuIGNvbG9yO1xyXG4gICAgfVxyXG4gICAgX3JlbW92ZU9iamVjdChvYmopIHtcclxuICAgICAgICBpZiAob2JqLl9jb2xvcklkICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2NvbG9yTWFwW29iai5fY29sb3JJZF07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gcHJvdGVjdGVkIF9pZGVudGlmeU9iamVjdEJ5Q29sb3IoY29sb3JJZDogbnVtYmVyKTogQ2FudmFzRGlzcGxheU9iamVjdCB8IHVuZGVmaW5lZCB7XHJcbiAgICAvLyBcdHJldHVybiB0aGlzLl9jb2xvck1hcFtjb2xvcklkXTtcclxuICAgIC8vIH1cclxuICAgIF9hZGp1c3RCb3VuZGluZ0JveChiYm94KSB7XHJcbiAgICAgICAgY29uc3QgbWFyZ2luID0gdGhpcy5fZ2hvc3RMYXllci5tYXJnaW47XHJcbiAgICAgICAgcmV0dXJuIG5ldyBET01SZWN0KC1tYXJnaW4ubGVmdCwgLW1hcmdpbi50b3AsIGJib3gud2lkdGggKyBtYXJnaW4ubGVmdCArIG1hcmdpbi5yaWdodCwgYmJveC5oZWlnaHQgKyBtYXJnaW4udG9wICsgbWFyZ2luLmJvdHRvbSk7XHJcbiAgICB9XHJcbiAgICBnZXRFdmVudChvcmlnaW5hbEV2ZW50LCBhZGp1c3RQb2ludCA9IHRydWUpIHtcclxuICAgICAgICBjb25zdCBiYm94ID0gdGhpcy52aWV3LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG4gICAgICAgIGNvbnN0IHggPSBvcmlnaW5hbEV2ZW50LmNsaWVudFggfHwgMDtcclxuICAgICAgICBjb25zdCB5ID0gb3JpZ2luYWxFdmVudC5jbGllbnRZIHx8IDA7XHJcbiAgICAgICAgY29uc3Qgd2lkdGhTY2FsZSA9IHRoaXMuX2NhbGN1bGF0ZWRXaWR0aCAvIHRoaXMuX3JlYWxXaWR0aDtcclxuICAgICAgICBjb25zdCBoZWlnaHRTY2FsZSA9IHRoaXMuX2NhbGN1bGF0ZWRIZWlnaHQgLyB0aGlzLl9yZWFsSGVpZ2h0O1xyXG4gICAgICAgIGNvbnN0IG9yaWdpbmFsUG9pbnQgPSB7XHJcbiAgICAgICAgICAgIHg6IHggLSBiYm94LmxlZnQsXHJcbiAgICAgICAgICAgIHk6IHkgLSBiYm94LnRvcCxcclxuICAgICAgICB9O1xyXG4gICAgICAgIGNvbnN0IHBvaW50ID0ge1xyXG4gICAgICAgICAgICB4OiAoeCAtIChhZGp1c3RQb2ludCA/IGJib3gubGVmdCA6IDApKSAqIHdpZHRoU2NhbGUsXHJcbiAgICAgICAgICAgIHk6ICh5IC0gKGFkanVzdFBvaW50ID8gYmJveC50b3AgOiAwKSkgKiBoZWlnaHRTY2FsZSxcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBuZXcgQ2FudmFzUmVuZGVyZXJFdmVudChvcmlnaW5hbEV2ZW50LCBvcmlnaW5hbFBvaW50LCBwb2ludCwgdGhpcy5fYWRqdXN0Qm91bmRpbmdCb3goYmJveCkpO1xyXG4gICAgfVxyXG4gICAgX2dldEhpdFRhcmdldChwb2ludCwgYmJveCwgdGFyZ2V0KSB7XHJcbiAgICAgICAgaWYgKGJib3gud2lkdGggPT09IDAgfHwgYmJveC5oZWlnaHQgPT09IDAgfHwgcG9pbnQueCA8IGJib3gubGVmdCB8fCBwb2ludC54ID4gYmJveC5yaWdodCB8fCBwb2ludC55IDwgYmJveC50b3AgfHwgcG9pbnQueSA+IGJib3guYm90dG9tKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCF0YXJnZXQgfHwgIXRoaXMuX2xheWVyRG9tLmNvbnRhaW5zKHRhcmdldCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBwaXhlbCA9IHRoaXMuX2dob3N0TGF5ZXIuZ2V0SW1hZ2VEYXRhKHBvaW50LCBiYm94KTtcclxuICAgICAgICBpZiAocGl4ZWwuZGF0YVswXSA9PT0gMCAmJiBwaXhlbC5kYXRhWzFdID09PSAwICYmIHBpeGVsLmRhdGFbMl0gPT09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBjb2xvcklkID0gQ29sb3IuZnJvbVJHQihwaXhlbC5kYXRhWzBdLCBwaXhlbC5kYXRhWzFdLCBwaXhlbC5kYXRhWzJdKS50b0NTUygpO1xyXG4gICAgICAgIGNvbnN0IGhpdCA9IHRoaXMuX2NvbG9yTWFwW2NvbG9ySWRdO1xyXG4gICAgICAgIHJldHVybiBoaXQ7XHJcbiAgICB9XHJcbiAgICBfd2l0aEV2ZW50cyhrZXksIGYpIHtcclxuICAgICAgICBjb25zdCBldmVudHMgPSB0aGlzLl9ldmVudHNba2V5XTtcclxuICAgICAgICBpZiAoZXZlbnRzICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgZXZlbnRzLmRpc3BhdGNoaW5nID0gdHJ1ZTtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGYoZXZlbnRzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmaW5hbGx5IHtcclxuICAgICAgICAgICAgICAgIGV2ZW50cy5kaXNwYXRjaGluZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50cy5jbGVhbnVwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRzLmNsZWFudXAgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAkYXJyYXkua2VlcElmKGV2ZW50cy5jYWxsYmFja3MsIChjYWxsYmFjaykgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gIWNhbGxiYWNrLmRpc3Bvc2VkO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChldmVudHMuY2FsbGJhY2tzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudHMuZGlzcG9zZXIuZGlzcG9zZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5fZXZlbnRzW2tleV07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgX2Rpc3BhdGNoRXZlbnRBbGwoa2V5LCBldmVudCkge1xyXG4gICAgICAgIGlmICghdGhpcy5pbnRlcmFjdGlvbnNFbmFibGVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fd2l0aEV2ZW50cyhrZXksIChldmVudHMpID0+IHtcclxuICAgICAgICAgICAgJGFycmF5LmVhY2goZXZlbnRzLmNhbGxiYWNrcywgKGNhbGxiYWNrKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWNhbGxiYWNrLmRpc3Bvc2VkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2suY2FsbGJhY2suY2FsbChjYWxsYmFjay5jb250ZXh0LCBldmVudCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgX2Rpc3BhdGNoRXZlbnQoa2V5LCB0YXJnZXQsIGV2ZW50KSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmludGVyYWN0aW9uc0VuYWJsZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgZGlzcGF0Y2hlZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuX3dpdGhFdmVudHMoa2V5LCAoZXZlbnRzKSA9PiB7XHJcbiAgICAgICAgICAgICRhcnJheS5lYWNoKGV2ZW50cy5jYWxsYmFja3MsIChjYWxsYmFjaykgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFjYWxsYmFjay5kaXNwb3NlZCAmJiBjYWxsYmFjay5vYmplY3QgPT09IHRhcmdldCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrLmNhbGxiYWNrLmNhbGwoY2FsbGJhY2suY29udGV4dCwgZXZlbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gZGlzcGF0Y2hlZDtcclxuICAgIH1cclxuICAgIF9kaXNwYXRjaE1vdXNlZG93bihvcmlnaW5hbEV2ZW50LCBvcmlnaW5hbFRhcmdldCkge1xyXG4gICAgICAgIGNvbnN0IGJ1dHRvbiA9IG9yaWdpbmFsRXZlbnQuYnV0dG9uO1xyXG4gICAgICAgIGlmIChidXR0b24gIT0gMCAmJiBidXR0b24gIT0gMiAmJiBidXR0b24gIT0gMSAmJiBidXR0b24gIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAvLyBJZ25vcmUgbm9uLXByaW1hcnkgbW91c2UgYnV0dG9uc1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGV2ZW50ID0gdGhpcy5nZXRFdmVudChvcmlnaW5hbEV2ZW50KTtcclxuICAgICAgICBjb25zdCB0YXJnZXQgPSB0aGlzLl9nZXRIaXRUYXJnZXQoZXZlbnQub3JpZ2luYWxQb2ludCwgZXZlbnQuYmJveCwgb3JpZ2luYWxUYXJnZXQpO1xyXG4gICAgICAgIGlmICh0YXJnZXQpIHtcclxuICAgICAgICAgICAgY29uc3QgaWQgPSBldmVudC5pZDtcclxuICAgICAgICAgICAgbGV0IGRyYWdnZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgZWFjaFRhcmdldHModGFyZ2V0LCAob2JqKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBpbmZvID0geyBpZDogaWQsIHZhbHVlOiBvYmogfTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX21vdXNlZG93bi5wdXNoKGluZm8pO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFkcmFnZ2VkICYmIHRoaXMuX2Rpc3BhdGNoRXZlbnQoXCJwb2ludGVyZG93blwiLCBvYmosIGV2ZW50KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIE9ubHkgZGlzcGF0Y2ggdGhlIGZpcnN0IGVsZW1lbnQgd2hpY2ggbWF0Y2hlc1xyXG4gICAgICAgICAgICAgICAgICAgIGRyYWdnZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGhhcyA9IHRoaXMuX2RyYWdnaW5nLnNvbWUoKHgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHgudmFsdWUgPT09IG9iaiAmJiB4LmlkID09PSBpZDtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWhhcykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9kcmFnZ2luZy5wdXNoKGluZm8pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBfZGlzcGF0Y2hHbG9iYWxNb3VzZW1vdmUob3JpZ2luYWxFdmVudCwgb3JpZ2luYWxUYXJnZXQsIG5hdGl2ZSkge1xyXG4gICAgICAgIGNvbnN0IGV2ZW50ID0gdGhpcy5nZXRFdmVudChvcmlnaW5hbEV2ZW50KTtcclxuICAgICAgICBjb25zdCB0YXJnZXQgPSB0aGlzLl9nZXRIaXRUYXJnZXQoZXZlbnQub3JpZ2luYWxQb2ludCwgZXZlbnQuYmJveCwgb3JpZ2luYWxUYXJnZXQpO1xyXG4gICAgICAgIGV2ZW50Lm5hdGl2ZSA9IG5hdGl2ZTtcclxuICAgICAgICBpZiAodGFyZ2V0KSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2hvdmVyaW5nLmZvckVhY2goKG9iaikgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFvYmouY29udGFpbnModGFyZ2V0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2hvdmVyaW5nLmRlbGV0ZShvYmopO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvYmouY3Vyc29yT3ZlclN0eWxlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICR1dGlscy5zZXRTdHlsZShkb2N1bWVudC5ib2R5LCBcImN1cnNvclwiLCBvYmouX3JlcGxhY2VkQ3Vyc29yU3R5bGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kaXNwYXRjaEV2ZW50KFwicG9pbnRlcm91dFwiLCBvYmosIGV2ZW50KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGlmIChldmVudC5uYXRpdmUpIHtcclxuICAgICAgICAgICAgICAgIGVhY2hUYXJnZXRzKHRhcmdldCwgKG9iaikgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5faG92ZXJpbmcuaGFzKG9iaikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5faG92ZXJpbmcuYWRkKG9iaik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvYmouY3Vyc29yT3ZlclN0eWxlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmouX3JlcGxhY2VkQ3Vyc29yU3R5bGUgPSAkdXRpbHMuZ2V0U3R5bGUoZG9jdW1lbnQuYm9keSwgXCJjdXJzb3JcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkdXRpbHMuc2V0U3R5bGUoZG9jdW1lbnQuYm9keSwgXCJjdXJzb3JcIiwgb2JqLmN1cnNvck92ZXJTdHlsZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGlzcGF0Y2hFdmVudChcInBvaW50ZXJvdmVyXCIsIG9iaiwgZXZlbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vfSBlbHNlIGlmICh0YXJnZXQgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLl9ob3ZlcmluZy5mb3JFYWNoKChvYmopID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChvYmouY3Vyc29yT3ZlclN0eWxlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgJHV0aWxzLnNldFN0eWxlKGRvY3VtZW50LmJvZHksIFwiY3Vyc29yXCIsIG9iai5fcmVwbGFjZWRDdXJzb3JTdHlsZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9kaXNwYXRjaEV2ZW50KFwicG9pbnRlcm91dFwiLCBvYmosIGV2ZW50KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHRoaXMuX2hvdmVyaW5nLmNsZWFyKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2Rpc3BhdGNoRXZlbnRBbGwoXCJnbG9iYWxwb2ludGVybW92ZVwiLCBldmVudCk7XHJcbiAgICB9XHJcbiAgICByZW1vdmVIb3ZlcmluZyhncmFwaGljcykge1xyXG4gICAgICAgIHRoaXMuX2hvdmVyaW5nLmRlbGV0ZShncmFwaGljcyk7XHJcbiAgICAgICAgaWYgKGdyYXBoaWNzLmN1cnNvck92ZXJTdHlsZSkge1xyXG4gICAgICAgICAgICAkdXRpbHMuc2V0U3R5bGUoZG9jdW1lbnQuYm9keSwgXCJjdXJzb3JcIiwgZ3JhcGhpY3MuX3JlcGxhY2VkQ3Vyc29yU3R5bGUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIF9kaXNwYXRjaEdsb2JhbE1vdXNldXAob3JpZ2luYWxFdmVudCwgbmF0aXZlKSB7XHJcbiAgICAgICAgY29uc3QgZXZlbnQgPSB0aGlzLmdldEV2ZW50KG9yaWdpbmFsRXZlbnQpO1xyXG4gICAgICAgIGV2ZW50Lm5hdGl2ZSA9IG5hdGl2ZTtcclxuICAgICAgICAvL2NvbnN0IHRhcmdldCA9IHRoaXMuX2dldEhpdFRhcmdldChldmVudC5vcmlnaW5hbFBvaW50KTtcclxuICAgICAgICB0aGlzLl9kaXNwYXRjaEV2ZW50QWxsKFwiZ2xvYmFscG9pbnRlcnVwXCIsIGV2ZW50KTtcclxuICAgIH1cclxuICAgIF9kaXNwYXRjaERyYWdNb3ZlKG9yaWdpbmFsRXZlbnQpIHtcclxuICAgICAgICBpZiAodGhpcy5fZHJhZ2dpbmcubGVuZ3RoICE9PSAwKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGV2ZW50ID0gdGhpcy5nZXRFdmVudChvcmlnaW5hbEV2ZW50KTtcclxuICAgICAgICAgICAgY29uc3QgaWQgPSBldmVudC5pZDtcclxuICAgICAgICAgICAgdGhpcy5fZHJhZ2dpbmcuZm9yRWFjaCgob2JqKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAob2JqLmlkID09PSBpZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2Rpc3BhdGNoRXZlbnQoXCJwb2ludGVybW92ZVwiLCBvYmoudmFsdWUsIGV2ZW50KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgX2Rpc3BhdGNoRHJhZ0VuZChvcmlnaW5hbEV2ZW50LCBvcmlnaW5hbFRhcmdldCkge1xyXG4gICAgICAgIGNvbnN0IGJ1dHRvbiA9IG9yaWdpbmFsRXZlbnQuYnV0dG9uO1xyXG4gICAgICAgIGxldCBjbGlja2V2ZW50O1xyXG4gICAgICAgIGlmIChidXR0b24gPT0gMCB8fCBidXR0b24gPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBjbGlja2V2ZW50ID0gXCJjbGlja1wiO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChidXR0b24gPT0gMikge1xyXG4gICAgICAgICAgICBjbGlja2V2ZW50ID0gXCJyaWdodGNsaWNrXCI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGJ1dHRvbiA9PSAxKSB7XHJcbiAgICAgICAgICAgIGNsaWNrZXZlbnQgPSBcIm1pZGRsZWNsaWNrXCI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBJZ25vcmUgbm9uLXByaW1hcnkgbW91c2UgYnV0dG9uc1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGV2ZW50ID0gdGhpcy5nZXRFdmVudChvcmlnaW5hbEV2ZW50KTtcclxuICAgICAgICBjb25zdCBpZCA9IGV2ZW50LmlkO1xyXG4gICAgICAgIGlmICh0aGlzLl9tb3VzZWRvd24ubGVuZ3RoICE9PSAwKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldCA9IHRoaXMuX2dldEhpdFRhcmdldChldmVudC5vcmlnaW5hbFBvaW50LCBldmVudC5iYm94LCBvcmlnaW5hbFRhcmdldCk7XHJcbiAgICAgICAgICAgIGlmICh0YXJnZXQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX21vdXNlZG93bi5mb3JFYWNoKChvYmopID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAob2JqLmlkID09PSBpZCAmJiBvYmoudmFsdWUuY29udGFpbnModGFyZ2V0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9kaXNwYXRjaEV2ZW50KGNsaWNrZXZlbnQsIG9iai52YWx1ZSwgZXZlbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX21vdXNlZG93bi5sZW5ndGggPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5fZHJhZ2dpbmcubGVuZ3RoICE9PSAwKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2RyYWdnaW5nLmZvckVhY2goKG9iaikgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKG9iai5pZCA9PT0gaWQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kaXNwYXRjaEV2ZW50KFwicG9pbnRlcnVwXCIsIG9iai52YWx1ZSwgZXZlbnQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgdGhpcy5fZHJhZ2dpbmcubGVuZ3RoID0gMDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBfZGlzcGF0Y2hEb3VibGVDbGljayhvcmlnaW5hbEV2ZW50LCBvcmlnaW5hbFRhcmdldCkge1xyXG4gICAgICAgIGNvbnN0IGV2ZW50ID0gdGhpcy5nZXRFdmVudChvcmlnaW5hbEV2ZW50KTtcclxuICAgICAgICBjb25zdCB0YXJnZXQgPSB0aGlzLl9nZXRIaXRUYXJnZXQoZXZlbnQub3JpZ2luYWxQb2ludCwgZXZlbnQuYmJveCwgb3JpZ2luYWxUYXJnZXQpO1xyXG4gICAgICAgIGlmICh0YXJnZXQpIHtcclxuICAgICAgICAgICAgZWFjaFRhcmdldHModGFyZ2V0LCAob2JqKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fZGlzcGF0Y2hFdmVudChcImRibGNsaWNrXCIsIG9iaiwgZXZlbnQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIF9kaXNwYXRjaFdoZWVsKG9yaWdpbmFsRXZlbnQsIG9yaWdpbmFsVGFyZ2V0KSB7XHJcbiAgICAgICAgY29uc3QgZXZlbnQgPSB0aGlzLmdldEV2ZW50KG9yaWdpbmFsRXZlbnQpO1xyXG4gICAgICAgIGNvbnN0IHRhcmdldCA9IHRoaXMuX2dldEhpdFRhcmdldChldmVudC5vcmlnaW5hbFBvaW50LCBldmVudC5iYm94LCBvcmlnaW5hbFRhcmdldCk7XHJcbiAgICAgICAgaWYgKHRhcmdldCkge1xyXG4gICAgICAgICAgICBlYWNoVGFyZ2V0cyh0YXJnZXQsIChvYmopID0+IHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9kaXNwYXRjaEV2ZW50KFwid2hlZWxcIiwgb2JqLCBldmVudCkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgX21ha2VTaGFyZWRFdmVudChrZXksIGYpIHtcclxuICAgICAgICBpZiAodGhpcy5fbGlzdGVuZXJzW2tleV0gPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBjb25zdCBsaXN0ZW5lciA9IGYoKTtcclxuICAgICAgICAgICAgdGhpcy5fbGlzdGVuZXJzW2tleV0gPSBuZXcgQ291bnRlckRpc3Bvc2VyKCgpID0+IHtcclxuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9saXN0ZW5lcnNba2V5XTtcclxuICAgICAgICAgICAgICAgIGxpc3RlbmVyLmRpc3Bvc2UoKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLl9saXN0ZW5lcnNba2V5XS5pbmNyZW1lbnQoKTtcclxuICAgIH1cclxuICAgIF9vblBvaW50ZXJFdmVudChuYW1lLCBmKSB7XHJcbiAgICAgICAgbGV0IG5hdGl2ZSA9IGZhbHNlO1xyXG4gICAgICAgIGxldCB0aW1lciA9IG51bGw7XHJcbiAgICAgICAgZnVuY3Rpb24gY2xlYXIoKSB7XHJcbiAgICAgICAgICAgIHRpbWVyID0gbnVsbDtcclxuICAgICAgICAgICAgbmF0aXZlID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgTXVsdGlEaXNwb3NlcihbXHJcbiAgICAgICAgICAgIG5ldyBEaXNwb3NlcigoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGltZXIgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2xlYXIoKTtcclxuICAgICAgICAgICAgfSksXHJcbiAgICAgICAgICAgICR1dGlscy5hZGRFdmVudExpc3RlbmVyKHRoaXMudmlldywgJHV0aWxzLmdldFJlbmRlcmVyRXZlbnQobmFtZSksIChfKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBuYXRpdmUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRpbWVyICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRpbWVyID0gd2luZG93LnNldFRpbWVvdXQoY2xlYXIsIDApO1xyXG4gICAgICAgICAgICB9KSxcclxuICAgICAgICAgICAgb25Qb2ludGVyRXZlbnQod2luZG93LCBuYW1lLCAoZXYsIHRhcmdldCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRpbWVyICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcclxuICAgICAgICAgICAgICAgICAgICB0aW1lciA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBmKGV2LCB0YXJnZXQsIG5hdGl2ZSk7XHJcbiAgICAgICAgICAgICAgICBuYXRpdmUgPSBmYWxzZTtcclxuICAgICAgICAgICAgfSksXHJcbiAgICAgICAgXSk7XHJcbiAgICB9XHJcbiAgICAvLyBUaGlzIGVuc3VyZXMgdGhhdCBvbmx5IGEgc2luZ2xlIERPTSBldmVudCBpcyBhZGRlZCAoZS5nLiBvbmx5IGEgc2luZ2xlIG1vdXNlbW92ZSBldmVudCBsaXN0ZW5lcilcclxuICAgIF9pbml0RXZlbnQoa2V5KSB7XHJcbiAgICAgICAgc3dpdGNoIChrZXkpIHtcclxuICAgICAgICAgICAgY2FzZSBcImdsb2JhbHBvaW50ZXJtb3ZlXCI6XHJcbiAgICAgICAgICAgIGNhc2UgXCJwb2ludGVyb3ZlclwiOlxyXG4gICAgICAgICAgICBjYXNlIFwicG9pbnRlcm91dFwiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21ha2VTaGFyZWRFdmVudChcInBvaW50ZXJtb3ZlXCIsICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBsaXN0ZW5lciA9IChldmVudHMsIHRhcmdldCwgbmF0aXZlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2xhc3RQb2ludGVyTW92ZUV2ZW50ID0geyBldmVudHMsIHRhcmdldCwgbmF0aXZlIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICRhcnJheS5lYWNoKGV2ZW50cywgKGV2ZW50KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9kaXNwYXRjaEdsb2JhbE1vdXNlbW92ZShldmVudCwgdGFyZ2V0LCBuYXRpdmUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgTXVsdGlEaXNwb3NlcihbXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX29uUG9pbnRlckV2ZW50KFwicG9pbnRlcmRvd25cIiwgbGlzdGVuZXIpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9vblBvaW50ZXJFdmVudChcInBvaW50ZXJtb3ZlXCIsIGxpc3RlbmVyKSxcclxuICAgICAgICAgICAgICAgICAgICBdKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBjYXNlIFwiZ2xvYmFscG9pbnRlcnVwXCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fbWFrZVNoYXJlZEV2ZW50KFwicG9pbnRlcnVwXCIsICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBtb3VzZXVwID0gdGhpcy5fb25Qb2ludGVyRXZlbnQoXCJwb2ludGVydXBcIiwgKGV2ZW50cywgdGFyZ2V0LCBuYXRpdmUpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgJGFycmF5LmVhY2goZXZlbnRzLCAoZXZlbnQpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2Rpc3BhdGNoR2xvYmFsTW91c2V1cChldmVudCwgbmF0aXZlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2xhc3RQb2ludGVyTW92ZUV2ZW50ID0geyBldmVudHMsIHRhcmdldCwgbmF0aXZlIH07XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcG9pbnRlcmNhbmNlbCA9IHRoaXMuX29uUG9pbnRlckV2ZW50KFwicG9pbnRlcmNhbmNlbFwiLCAoZXZlbnRzLCB0YXJnZXQsIG5hdGl2ZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAkYXJyYXkuZWFjaChldmVudHMsIChldmVudCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGlzcGF0Y2hHbG9iYWxNb3VzZXVwKGV2ZW50LCBuYXRpdmUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbGFzdFBvaW50ZXJNb3ZlRXZlbnQgPSB7IGV2ZW50cywgdGFyZ2V0LCBuYXRpdmUgfTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IERpc3Bvc2VyKCgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbW91c2V1cC5kaXNwb3NlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50ZXJjYW5jZWwuZGlzcG9zZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGNhc2UgXCJjbGlja1wiOlxyXG4gICAgICAgICAgICBjYXNlIFwicmlnaHRjbGlja1wiOlxyXG4gICAgICAgICAgICBjYXNlIFwibWlkZGxlY2xpY2tcIjpcclxuICAgICAgICAgICAgY2FzZSBcInBvaW50ZXJkb3duXCI6XHJcbiAgICAgICAgICAgIC8qXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fbWFrZVNoYXJlZEV2ZW50KFwicG9pbnRlcmRvd25cIiwgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9vblBvaW50ZXJFdmVudChcInBvaW50ZXJkb3duXCIsIChldmVudCwgdGFyZ2V0LCBuYXRpdmUpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbGFzdFBvaW50ZXJNb3ZlRXZlbnQgPSB7IGV2ZW50LCB0YXJnZXQsIG5hdGl2ZSB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9kaXNwYXRjaE1vdXNlZG93bihldmVudClcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBjYXNlIFwicG9pbnRlcm1vdmVcIjpcclxuICAgICAgICAgICAgY2FzZSBcInBvaW50ZXJ1cFwiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21ha2VTaGFyZWRFdmVudChcInBvaW50ZXJkb3duXCIsICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAvL2NvbnN0IHRocm90dGxlciA9IG5ldyBUaHJvdHRsZXIoKTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBtb3VzZWRvd24gPSB0aGlzLl9vblBvaW50ZXJFdmVudChcInBvaW50ZXJkb3duXCIsIChldmVudHMsIHRhcmdldCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAkYXJyYXkuZWFjaChldmVudHMsIChldikgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGlzcGF0Y2hNb3VzZWRvd24oZXYsIHRhcmdldCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE8gaGFuZGxlIHRocm90dGxpbmcgcHJvcGVybHkgZm9yIG11bHRpdG91Y2hcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBtb3VzZW1vdmUgPSB0aGlzLl9vblBvaW50ZXJFdmVudChcInBvaW50ZXJtb3ZlXCIsIChldikgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL3Rocm90dGxlci50aHJvdHRsZSgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICRhcnJheS5lYWNoKGV2LCAoZXYpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2Rpc3BhdGNoRHJhZ01vdmUoZXYpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy99KTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBtb3VzZXVwID0gdGhpcy5fb25Qb2ludGVyRXZlbnQoXCJwb2ludGVydXBcIiwgKGV2LCB0YXJnZXQpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgJGFycmF5LmVhY2goZXYsIChldikgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGlzcGF0Y2hEcmFnRW5kKGV2LCB0YXJnZXQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBwb2ludGVyY2FuY2VsID0gdGhpcy5fb25Qb2ludGVyRXZlbnQoXCJwb2ludGVyY2FuY2VsXCIsIChldiwgdGFyZ2V0KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICRhcnJheS5lYWNoKGV2LCAoZXYpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2Rpc3BhdGNoRHJhZ0VuZChldiwgdGFyZ2V0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBEaXNwb3NlcigoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vdXNlZG93bi5kaXNwb3NlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vdXNlbW92ZS5kaXNwb3NlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vdXNldXAuZGlzcG9zZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludGVyY2FuY2VsLmRpc3Bvc2UoKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBjYXNlIFwiZGJsY2xpY2tcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9tYWtlU2hhcmVkRXZlbnQoXCJkYmxjbGlja1wiLCAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX29uUG9pbnRlckV2ZW50KFwiZGJsY2xpY2tcIiwgKGV2LCB0YXJnZXQpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgJGFycmF5LmVhY2goZXYsIChldikgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGlzcGF0Y2hEb3VibGVDbGljayhldiwgdGFyZ2V0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgY2FzZSBcIndoZWVsXCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fbWFrZVNoYXJlZEV2ZW50KFwid2hlZWxcIiwgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAkdXRpbHMuYWRkRXZlbnRMaXN0ZW5lcih3aW5kb3csICR1dGlscy5nZXRSZW5kZXJlckV2ZW50KFwid2hlZWxcIiksIChldmVudCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9kaXNwYXRjaFdoZWVsKGV2ZW50LCAkdXRpbHMuZ2V0RXZlbnRUYXJnZXQoZXZlbnQpKTtcclxuICAgICAgICAgICAgICAgICAgICB9LCB7IHBhc3NpdmU6IGZhbHNlIH0pO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgX2FkZEV2ZW50KG9iamVjdCwga2V5LCBjYWxsYmFjaywgY29udGV4dCkge1xyXG4gICAgICAgIGxldCBldmVudHMgPSB0aGlzLl9ldmVudHNba2V5XTtcclxuICAgICAgICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgZXZlbnRzID0gdGhpcy5fZXZlbnRzW2tleV0gPSB7XHJcbiAgICAgICAgICAgICAgICBkaXNwb3NlcjogdGhpcy5faW5pdEV2ZW50KGtleSksXHJcbiAgICAgICAgICAgICAgICBjYWxsYmFja3M6IFtdLFxyXG4gICAgICAgICAgICAgICAgZGlzcGF0Y2hpbmc6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgY2xlYW51cDogZmFsc2UsXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGxpc3RlbmVyID0geyBvYmplY3QsIGNvbnRleHQsIGNhbGxiYWNrLCBkaXNwb3NlZDogZmFsc2UgfTtcclxuICAgICAgICBldmVudHMuY2FsbGJhY2tzLnB1c2gobGlzdGVuZXIpO1xyXG4gICAgICAgIHJldHVybiBuZXcgRGlzcG9zZXIoKCkgPT4ge1xyXG4gICAgICAgICAgICBsaXN0ZW5lci5kaXNwb3NlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIGlmIChldmVudHMuZGlzcGF0Y2hpbmcpIHtcclxuICAgICAgICAgICAgICAgIGV2ZW50cy5jbGVhbnVwID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICRhcnJheS5yZW1vdmVGaXJzdChldmVudHMuY2FsbGJhY2tzLCBsaXN0ZW5lcik7XHJcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnRzLmNhbGxiYWNrcy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBldmVudHMuZGlzcG9zZXIuZGlzcG9zZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNba2V5XTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgZ2V0Q2FudmFzKHJvb3QsIG9wdGlvbnMpIHtcclxuICAgICAgICAvLyBNYWtlIHN1cmUgZXZlcnl0aGluZyBpcyByZW5kZXJlZFxyXG4gICAgICAgIHRoaXMucmVuZGVyKHJvb3QpO1xyXG4gICAgICAgIGlmICghb3B0aW9ucykge1xyXG4gICAgICAgICAgICBvcHRpb25zID0ge307XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBzY2FsZSA9IHRoaXMucmVzb2x1dGlvbjtcclxuICAgICAgICBsZXQgY2FudmFzV2lkdGggPSBNYXRoLmZsb29yKHRoaXMuX2NhbGN1bGF0ZWRXaWR0aCAqIHRoaXMucmVzb2x1dGlvbik7XHJcbiAgICAgICAgbGV0IGNhbnZhc0hlaWdodCA9IE1hdGguZmxvb3IodGhpcy5fY2FsY3VsYXRlZEhlaWdodCAqIHRoaXMucmVzb2x1dGlvbik7XHJcbiAgICAgICAgLy8gQ2hlY2sgaWYgd2UgbmVlZCB0byBzY2FsZVxyXG4gICAgICAgIGlmIChvcHRpb25zLm1pbldpZHRoICYmIChvcHRpb25zLm1pbldpZHRoID4gY2FudmFzV2lkdGgpKSB7XHJcbiAgICAgICAgICAgIGxldCBtaW5TY2FsZSA9IG9wdGlvbnMubWluV2lkdGggLyBjYW52YXNXaWR0aDtcclxuICAgICAgICAgICAgaWYgKG1pblNjYWxlID4gc2NhbGUpIHtcclxuICAgICAgICAgICAgICAgIHNjYWxlID0gbWluU2NhbGUgKiB0aGlzLnJlc29sdXRpb247XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG9wdGlvbnMubWluSGVpZ2h0ICYmIChvcHRpb25zLm1pbkhlaWdodCA+IGNhbnZhc0hlaWdodCkpIHtcclxuICAgICAgICAgICAgbGV0IG1pblNjYWxlID0gb3B0aW9ucy5taW5IZWlnaHQgLyBjYW52YXNIZWlnaHQ7XHJcbiAgICAgICAgICAgIGlmIChtaW5TY2FsZSA+IHNjYWxlKSB7XHJcbiAgICAgICAgICAgICAgICBzY2FsZSA9IG1pblNjYWxlICogdGhpcy5yZXNvbHV0aW9uO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChvcHRpb25zLm1heFdpZHRoICYmIChvcHRpb25zLm1heFdpZHRoIDwgY2FudmFzV2lkdGgpKSB7XHJcbiAgICAgICAgICAgIGxldCBtYXhTY2FsZSA9IG9wdGlvbnMubWF4V2lkdGggLyBjYW52YXNXaWR0aDtcclxuICAgICAgICAgICAgaWYgKG1heFNjYWxlIDwgc2NhbGUpIHtcclxuICAgICAgICAgICAgICAgIHNjYWxlID0gbWF4U2NhbGUgKiB0aGlzLnJlc29sdXRpb247XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG9wdGlvbnMubWF4SGVpZ2h0ICYmIChvcHRpb25zLm1heEhlaWdodCA+IGNhbnZhc0hlaWdodCkpIHtcclxuICAgICAgICAgICAgbGV0IG1heFNjYWxlID0gb3B0aW9ucy5tYXhIZWlnaHQgLyBjYW52YXNIZWlnaHQ7XHJcbiAgICAgICAgICAgIGlmIChtYXhTY2FsZSA8IHNjYWxlKSB7XHJcbiAgICAgICAgICAgICAgICBzY2FsZSA9IG1heFNjYWxlICogdGhpcy5yZXNvbHV0aW9uO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIENoZWNrIGlmIHdlIG5lZWQgdG8gY29tcGVuc2F0ZSBmb3IgcGl4ZWwgcmF0aW9cclxuICAgICAgICBpZiAob3B0aW9ucy5tYWludGFpblBpeGVsUmF0aW8pIHtcclxuICAgICAgICAgICAgc2NhbGUgLz0gdGhpcy5yZXNvbHV0aW9uO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBJbml0IGxpc3QgY2FudmFzZXMgdG8gcmVtb3ZlIGZyb20gRE9NIGFmdGVyIGV4cG9ydFxyXG4gICAgICAgIGNvbnN0IGNhbnZhc2VzID0gW107XHJcbiAgICAgICAgLy8gU2V0IHVwIG5ldyBjYW52YXMgZm9yIGV4cG9ydFxyXG4gICAgICAgIGxldCBmb3JjZVJlbmRlciA9IGZhbHNlO1xyXG4gICAgICAgIGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XHJcbiAgICAgICAgaWYgKHNjYWxlICE9IHRoaXMucmVzb2x1dGlvbikge1xyXG4gICAgICAgICAgICBmb3JjZVJlbmRlciA9IHRydWU7XHJcbiAgICAgICAgICAgIGNhbnZhc1dpZHRoID0gY2FudmFzV2lkdGggKiBzY2FsZSAvIHRoaXMucmVzb2x1dGlvbjtcclxuICAgICAgICAgICAgY2FudmFzSGVpZ2h0ID0gY2FudmFzSGVpZ2h0ICogc2NhbGUgLyB0aGlzLnJlc29sdXRpb247XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhbnZhcy53aWR0aCA9IGNhbnZhc1dpZHRoO1xyXG4gICAgICAgIGNhbnZhcy5oZWlnaHQgPSBjYW52YXNIZWlnaHQ7XHJcbiAgICAgICAgLy8gQWRkIHRvIERPTSBzbyBpdCBpbmhlcml0cyBDU1NcclxuICAgICAgICBjYW52YXMuc3R5bGUucG9zaXRpb24gPSBcImZpeGVkXCI7XHJcbiAgICAgICAgY2FudmFzLnN0eWxlLnRvcCA9IFwiLTEwMDAwcHhcIjtcclxuICAgICAgICB0aGlzLnZpZXcuYXBwZW5kQ2hpbGQoY2FudmFzKTtcclxuICAgICAgICBjYW52YXNlcy5wdXNoKGNhbnZhcyk7XHJcbiAgICAgICAgLy8gQ29udGV4dFxyXG4gICAgICAgIGNvbnN0IGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xyXG4gICAgICAgIGxldCB3aWR0aCA9IDA7XHJcbiAgICAgICAgbGV0IGhlaWdodCA9IDA7XHJcbiAgICAgICAgbGV0IG5lZWRSZXJlbmRlciA9IGZhbHNlO1xyXG4gICAgICAgICRhcnJheS5lYWNoKHRoaXMubGF5ZXJzLCAobGF5ZXIpID0+IHtcclxuICAgICAgICAgICAgaWYgKGxheWVyICYmIGxheWVyLnZpc2libGUpIHtcclxuICAgICAgICAgICAgICAgIGlmIChsYXllci50YWludGVkIHx8IGZvcmNlUmVuZGVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmVlZFJlcmVuZGVyID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICBsYXllci5leHBvcnRhYmxlVmlldyA9IGxheWVyLnZpZXc7XHJcbiAgICAgICAgICAgICAgICAgICAgbGF5ZXIuZXhwb3J0YWJsZUNvbnRleHQgPSBsYXllci5jb250ZXh0O1xyXG4gICAgICAgICAgICAgICAgICAgIGxheWVyLnZpZXcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIEFkZCB0byBET00gc28gaXQgaW5oZXJpdHMgQ1NTXHJcbiAgICAgICAgICAgICAgICAgICAgbGF5ZXIudmlldy5zdHlsZS5wb3NpdGlvbiA9IFwiZml4ZWRcIjtcclxuICAgICAgICAgICAgICAgICAgICBsYXllci52aWV3LnN0eWxlLnRvcCA9IFwiLTEwMDAwcHhcIjtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnZpZXcuYXBwZW5kQ2hpbGQobGF5ZXIudmlldyk7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FudmFzZXMucHVzaChsYXllci52aWV3KTtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgZXh0cmFYID0gMDtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgZXh0cmFZID0gMDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobGF5ZXIubWFyZ2luKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4dHJhWCArPSBsYXllci5tYXJnaW4ubGVmdCB8fCAwICsgbGF5ZXIubWFyZ2luLnJpZ2h0IHx8IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4dHJhWSArPSBsYXllci5tYXJnaW4udG9wIHx8IDAgKyBsYXllci5tYXJnaW4uYm90dG9tIHx8IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGxheWVyLnZpZXcud2lkdGggPSBjYW52YXNXaWR0aCArIGV4dHJhWDtcclxuICAgICAgICAgICAgICAgICAgICBsYXllci52aWV3LmhlaWdodCA9IGNhbnZhc0hlaWdodCArIGV4dHJhWTtcclxuICAgICAgICAgICAgICAgICAgICBsYXllci5jb250ZXh0ID0gbGF5ZXIudmlldy5nZXRDb250ZXh0KFwiMmRcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgbGF5ZXIuZGlydHkgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGxheWVyLnNjYWxlID0gc2NhbGU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICBpZiAobmVlZFJlcmVuZGVyKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX29taXRUYWludGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy5yZW5kZXIocm9vdCk7XHJcbiAgICAgICAgICAgIHRoaXMuX29taXRUYWludGVkID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgICRhcnJheS5lYWNoKHRoaXMubGF5ZXJzLCAobGF5ZXIpID0+IHtcclxuICAgICAgICAgICAgaWYgKGxheWVyICYmIGxheWVyLnZpc2libGUpIHtcclxuICAgICAgICAgICAgICAgIC8vIExheWVyIGlzIGZpbmUuIEp1c3QgcGxvcCBpdCBpbnRvIG91ciB0YXJnZXQgY2FudmFzXHJcbiAgICAgICAgICAgICAgICBsZXQgeCA9IDA7XHJcbiAgICAgICAgICAgICAgICBsZXQgeSA9IDA7XHJcbiAgICAgICAgICAgICAgICBpZiAobGF5ZXIubWFyZ2luKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgeCA9IC0obGF5ZXIubWFyZ2luLmxlZnQgfHwgMCkgKiB0aGlzLnJlc29sdXRpb247XHJcbiAgICAgICAgICAgICAgICAgICAgeSA9IC0obGF5ZXIubWFyZ2luLnRvcCB8fCAwKSAqIHRoaXMucmVzb2x1dGlvbjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvbnRleHQuZHJhd0ltYWdlKGxheWVyLnZpZXcsIHgsIHkpO1xyXG4gICAgICAgICAgICAgICAgLy8gUmVzdG9yZSBsYXllciBvcmlnaW5hbCBjYW52YXNcclxuICAgICAgICAgICAgICAgIGlmIChsYXllci5leHBvcnRhYmxlVmlldykge1xyXG4gICAgICAgICAgICAgICAgICAgIGxheWVyLnZpZXcgPSBsYXllci5leHBvcnRhYmxlVmlldztcclxuICAgICAgICAgICAgICAgICAgICBsYXllci5leHBvcnRhYmxlVmlldyA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChsYXllci5leHBvcnRhYmxlQ29udGV4dCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxheWVyLmNvbnRleHQgPSBsYXllci5leHBvcnRhYmxlQ29udGV4dDtcclxuICAgICAgICAgICAgICAgICAgICBsYXllci5leHBvcnRhYmxlQ29udGV4dCA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICh3aWR0aCA8IGxheWVyLnZpZXcuY2xpZW50V2lkdGgpIHtcclxuICAgICAgICAgICAgICAgICAgICB3aWR0aCA9IGxheWVyLnZpZXcuY2xpZW50V2lkdGg7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoaGVpZ2h0IDwgbGF5ZXIudmlldy5jbGllbnRIZWlnaHQpIHtcclxuICAgICAgICAgICAgICAgICAgICBoZWlnaHQgPSBsYXllci52aWV3LmNsaWVudEhlaWdodDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGxheWVyLnNjYWxlID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgY2FudmFzLnN0eWxlLndpZHRoID0gd2lkdGggKyBcInB4XCI7XHJcbiAgICAgICAgY2FudmFzLnN0eWxlLmhlaWdodCA9IGhlaWdodCArIFwicHhcIjtcclxuICAgICAgICAkYXJyYXkuZWFjaChjYW52YXNlcywgKGNhbnZhcykgPT4ge1xyXG4gICAgICAgICAgICBjYW52YXMuc3R5bGUucG9zaXRpb24gPSBcIlwiO1xyXG4gICAgICAgICAgICBjYW52YXMuc3R5bGUudG9wID0gXCJcIjtcclxuICAgICAgICAgICAgdGhpcy52aWV3LnJlbW92ZUNoaWxkKGNhbnZhcyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIGNhbnZhcztcclxuICAgIH1cclxufVxyXG5jbGFzcyBHaG9zdExheWVyIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInZpZXdcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiY29udGV4dFwiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJtYXJnaW5cIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZToge1xyXG4gICAgICAgICAgICAgICAgbGVmdDogMCxcclxuICAgICAgICAgICAgICAgIHJpZ2h0OiAwLFxyXG4gICAgICAgICAgICAgICAgdG9wOiAwLFxyXG4gICAgICAgICAgICAgICAgYm90dG9tOiAwLFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX3dpZHRoXCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IDBcclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfaGVpZ2h0XCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IDBcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLnZpZXcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xyXG4gICAgICAgIHRoaXMuY29udGV4dCA9IHRoaXMudmlldy5nZXRDb250ZXh0KFwiMmRcIiwgeyBhbHBoYTogZmFsc2UsIHdpbGxSZWFkRnJlcXVlbnRseTogdHJ1ZSB9KTtcclxuICAgICAgICB0aGlzLmNvbnRleHQuaW1hZ2VTbW9vdGhpbmdFbmFibGVkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy52aWV3LnN0eWxlLnBvc2l0aW9uID0gXCJhYnNvbHV0ZVwiO1xyXG4gICAgICAgIHRoaXMudmlldy5zdHlsZS50b3AgPSBcIjBweFwiO1xyXG4gICAgICAgIHRoaXMudmlldy5zdHlsZS5sZWZ0ID0gXCIwcHhcIjtcclxuICAgIH1cclxuICAgIHJlc2l6ZShjYW52YXNXaWR0aCwgY2FudmFzSGVpZ2h0LCBkb21XaWR0aCwgZG9tSGVpZ2h0LCByZXNvbHV0aW9uKSB7XHJcbiAgICAgICAgY2FudmFzV2lkdGggKz0gKHRoaXMubWFyZ2luLmxlZnQgKyB0aGlzLm1hcmdpbi5yaWdodCk7XHJcbiAgICAgICAgY2FudmFzSGVpZ2h0ICs9ICh0aGlzLm1hcmdpbi50b3AgKyB0aGlzLm1hcmdpbi5ib3R0b20pO1xyXG4gICAgICAgIC8vIFRPRE8gdGhpcyBzaG91bGQgdGFrZSBpbnRvIGFjY291bnQgY2FsY3VsYXRlU2l6ZVxyXG4gICAgICAgIGRvbVdpZHRoICs9ICh0aGlzLm1hcmdpbi5sZWZ0ICsgdGhpcy5tYXJnaW4ucmlnaHQpO1xyXG4gICAgICAgIGRvbUhlaWdodCArPSAodGhpcy5tYXJnaW4udG9wICsgdGhpcy5tYXJnaW4uYm90dG9tKTtcclxuICAgICAgICB0aGlzLnZpZXcuc3R5bGUubGVmdCA9IC10aGlzLm1hcmdpbi5sZWZ0ICsgXCJweFwiO1xyXG4gICAgICAgIHRoaXMudmlldy5zdHlsZS50b3AgPSAtdGhpcy5tYXJnaW4udG9wICsgXCJweFwiO1xyXG4gICAgICAgIHRoaXMuX3dpZHRoID0gTWF0aC5mbG9vcihjYW52YXNXaWR0aCAqIHJlc29sdXRpb24pO1xyXG4gICAgICAgIHRoaXMuX2hlaWdodCA9IE1hdGguZmxvb3IoY2FudmFzSGVpZ2h0ICogcmVzb2x1dGlvbik7XHJcbiAgICAgICAgdGhpcy52aWV3LndpZHRoID0gdGhpcy5fd2lkdGg7XHJcbiAgICAgICAgdGhpcy52aWV3LnN0eWxlLndpZHRoID0gZG9tV2lkdGggKyBcInB4XCI7XHJcbiAgICAgICAgdGhpcy52aWV3LmhlaWdodCA9IHRoaXMuX2hlaWdodDtcclxuICAgICAgICB0aGlzLnZpZXcuc3R5bGUuaGVpZ2h0ID0gZG9tSGVpZ2h0ICsgXCJweFwiO1xyXG4gICAgfVxyXG4gICAgZ2V0SW1hZ2VEYXRhKHBvaW50LCBiYm94KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGV4dC5nZXRJbWFnZURhdGEoXHJcbiAgICAgICAgLy8gVE9ETyBzaG91bGQgdGhpcyByb3VuZCA/XHJcbiAgICAgICAgTWF0aC5yb3VuZCgoKHBvaW50LnggLSBiYm94LmxlZnQpIC8gYmJveC53aWR0aCkgKiB0aGlzLl93aWR0aCksIE1hdGgucm91bmQoKChwb2ludC55IC0gYmJveC50b3ApIC8gYmJveC5oZWlnaHQpICogdGhpcy5faGVpZ2h0KSwgMSwgMSk7XHJcbiAgICB9XHJcbiAgICBzZXRNYXJnaW4obGF5ZXJzKSB7XHJcbiAgICAgICAgdGhpcy5tYXJnaW4ubGVmdCA9IDA7XHJcbiAgICAgICAgdGhpcy5tYXJnaW4ucmlnaHQgPSAwO1xyXG4gICAgICAgIHRoaXMubWFyZ2luLnRvcCA9IDA7XHJcbiAgICAgICAgdGhpcy5tYXJnaW4uYm90dG9tID0gMDtcclxuICAgICAgICAkYXJyYXkuZWFjaChsYXllcnMsIChsYXllcikgPT4ge1xyXG4gICAgICAgICAgICBpZiAobGF5ZXIubWFyZ2luKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm1hcmdpbi5sZWZ0ID0gTWF0aC5tYXgodGhpcy5tYXJnaW4ubGVmdCwgbGF5ZXIubWFyZ2luLmxlZnQpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5tYXJnaW4ucmlnaHQgPSBNYXRoLm1heCh0aGlzLm1hcmdpbi5yaWdodCwgbGF5ZXIubWFyZ2luLnJpZ2h0KTtcclxuICAgICAgICAgICAgICAgIHRoaXMubWFyZ2luLnRvcCA9IE1hdGgubWF4KHRoaXMubWFyZ2luLnRvcCwgbGF5ZXIubWFyZ2luLnRvcCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm1hcmdpbi5ib3R0b20gPSBNYXRoLm1heCh0aGlzLm1hcmdpbi5ib3R0b20sIGxheWVyLm1hcmdpbi5ib3R0b20pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBjbGVhcigpIHtcclxuICAgICAgICB0aGlzLmNvbnRleHQuc2F2ZSgpO1xyXG4gICAgICAgIHRoaXMuY29udGV4dC5maWxsU3R5bGUgPSAnIzAwMCc7XHJcbiAgICAgICAgdGhpcy5jb250ZXh0LmZpbGxSZWN0KDAsIDAsIHRoaXMuX3dpZHRoLCB0aGlzLl9oZWlnaHQpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBAaWdub3JlXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgQ2FudmFzTGF5ZXIge1xyXG4gICAgY29uc3RydWN0b3IodmlldywgY29udGV4dCkge1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInZpZXdcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiY29udGV4dFwiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ0YWludGVkXCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IHRydWVcclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJtYXJnaW5cIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwib3JkZXJcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogMFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInZpc2libGVcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIndpZHRoXCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImhlaWdodFwiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJzY2FsZVwiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJkaXJ0eVwiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZXhwb3J0YWJsZVZpZXdcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZXhwb3J0YWJsZUNvbnRleHRcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX3dpZHRoXCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IDBcclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfaGVpZ2h0XCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IDBcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xyXG4gICAgICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XHJcbiAgICB9XHJcbiAgICByZXNpemUoY2FudmFzV2lkdGgsIGNhbnZhc0hlaWdodCwgZG9tV2lkdGgsIGRvbUhlaWdodCwgcmVzb2x1dGlvbikge1xyXG4gICAgICAgIC8vIFRPRE8gc2hvdWxkIHRoaXMgdGFrZSBpbnRvIGFjY291bnQgY2FsY3VsYXRlU2l6ZSA/XHJcbiAgICAgICAgaWYgKHRoaXMud2lkdGggIT0gbnVsbCkge1xyXG4gICAgICAgICAgICBjYW52YXNXaWR0aCA9IHRoaXMud2lkdGg7XHJcbiAgICAgICAgICAgIGRvbVdpZHRoID0gdGhpcy53aWR0aDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gVE9ETyBzaG91bGQgdGhpcyB0YWtlIGludG8gYWNjb3VudCBjYWxjdWxhdGVTaXplID9cclxuICAgICAgICBpZiAodGhpcy5oZWlnaHQgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICBjYW52YXNIZWlnaHQgPSB0aGlzLmhlaWdodDtcclxuICAgICAgICAgICAgZG9tSGVpZ2h0ID0gdGhpcy5oZWlnaHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLm1hcmdpbikge1xyXG4gICAgICAgICAgICBjYW52YXNXaWR0aCArPSAodGhpcy5tYXJnaW4ubGVmdCArIHRoaXMubWFyZ2luLnJpZ2h0KTtcclxuICAgICAgICAgICAgY2FudmFzSGVpZ2h0ICs9ICh0aGlzLm1hcmdpbi50b3AgKyB0aGlzLm1hcmdpbi5ib3R0b20pO1xyXG4gICAgICAgICAgICAvLyBUT0RPIHRoaXMgc2hvdWxkIHRha2UgaW50byBhY2NvdW50IGNhbGN1bGF0ZVNpemVcclxuICAgICAgICAgICAgZG9tV2lkdGggKz0gKHRoaXMubWFyZ2luLmxlZnQgKyB0aGlzLm1hcmdpbi5yaWdodCk7XHJcbiAgICAgICAgICAgIGRvbUhlaWdodCArPSAodGhpcy5tYXJnaW4udG9wICsgdGhpcy5tYXJnaW4uYm90dG9tKTtcclxuICAgICAgICAgICAgdGhpcy52aWV3LnN0eWxlLmxlZnQgPSAtdGhpcy5tYXJnaW4ubGVmdCArIFwicHhcIjtcclxuICAgICAgICAgICAgdGhpcy52aWV3LnN0eWxlLnRvcCA9IC10aGlzLm1hcmdpbi50b3AgKyBcInB4XCI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLnZpZXcuc3R5bGUubGVmdCA9IFwiMHB4XCI7XHJcbiAgICAgICAgICAgIHRoaXMudmlldy5zdHlsZS50b3AgPSBcIjBweFwiO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl93aWR0aCA9IE1hdGguZmxvb3IoY2FudmFzV2lkdGggKiByZXNvbHV0aW9uKTtcclxuICAgICAgICB0aGlzLl9oZWlnaHQgPSBNYXRoLmZsb29yKGNhbnZhc0hlaWdodCAqIHJlc29sdXRpb24pO1xyXG4gICAgICAgIHRoaXMudmlldy53aWR0aCA9IHRoaXMuX3dpZHRoO1xyXG4gICAgICAgIHRoaXMudmlldy5zdHlsZS53aWR0aCA9IGRvbVdpZHRoICsgXCJweFwiO1xyXG4gICAgICAgIHRoaXMudmlldy5oZWlnaHQgPSB0aGlzLl9oZWlnaHQ7XHJcbiAgICAgICAgdGhpcy52aWV3LnN0eWxlLmhlaWdodCA9IGRvbUhlaWdodCArIFwicHhcIjtcclxuICAgIH1cclxuICAgIGNsZWFyKCkge1xyXG4gICAgICAgIHRoaXMuY29udGV4dC5zYXZlKCk7XHJcbiAgICAgICAgdGhpcy5jb250ZXh0LmNsZWFyUmVjdCgwLCAwLCB0aGlzLl93aWR0aCwgdGhpcy5faGVpZ2h0KTtcclxuICAgIH1cclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1DYW52YXNSZW5kZXJlci5qcy5tYXAiLCIvKipcclxuICogRnJvbSBodHRwczovL2dpdGh1Yi5jb20vcGl4aWpzL3BpeGkuanMvYmxvYi8zZGQwZmY5YTkzNWYwYmMxM2EwOWFlZmZmOWViMjg3MmYwMmM1MWI5L3BhY2thZ2VzL2NhbnZhcy9jYW52YXMtcmVuZGVyZXIvc3JjL3V0aWxzL21hcENhbnZhc0JsZW5kTW9kZXNUb1BpeGkudHMjTDEzXHJcbiAqL1xyXG5leHBvcnQgdmFyIEJsZW5kTW9kZTtcclxuKGZ1bmN0aW9uIChCbGVuZE1vZGUpIHtcclxuICAgIEJsZW5kTW9kZVtcIkFERFwiXSA9IFwibGlnaHRlclwiO1xyXG4gICAgQmxlbmRNb2RlW1wiQ09MT1JcIl0gPSBcImNvbG9yXCI7XHJcbiAgICBCbGVuZE1vZGVbXCJDT0xPUl9CVVJOXCJdID0gXCJjb2xvci1idXJuXCI7XHJcbiAgICBCbGVuZE1vZGVbXCJDT0xPUl9ET0RHRVwiXSA9IFwiY29sb3ItZG9kZ2VcIjtcclxuICAgIEJsZW5kTW9kZVtcIkRBUktFTlwiXSA9IFwiZGFya2VuXCI7XHJcbiAgICBCbGVuZE1vZGVbXCJESUZGRVJFTkNFXCJdID0gXCJkaWZmZXJlbmNlXCI7XHJcbiAgICBCbGVuZE1vZGVbXCJEU1RfT1ZFUlwiXSA9IFwiZGVzdGluYXRpb24tb3ZlclwiO1xyXG4gICAgQmxlbmRNb2RlW1wiRVhDTFVTSU9OXCJdID0gXCJleGNsdXNpb25cIjtcclxuICAgIEJsZW5kTW9kZVtcIkhBUkRfTElHSFRcIl0gPSBcImhhcmQtbGlnaHRcIjtcclxuICAgIEJsZW5kTW9kZVtcIkhVRVwiXSA9IFwiaHVlXCI7XHJcbiAgICBCbGVuZE1vZGVbXCJMSUdIVEVOXCJdID0gXCJsaWdodGVuXCI7XHJcbiAgICBCbGVuZE1vZGVbXCJMVU1JTk9TSVRZXCJdID0gXCJsdW1pbm9zaXR5XCI7XHJcbiAgICBCbGVuZE1vZGVbXCJNVUxUSVBMWVwiXSA9IFwibXVsdGlwbHlcIjtcclxuICAgIEJsZW5kTW9kZVtcIk5PUk1BTFwiXSA9IFwic291cmNlLW92ZXJcIjtcclxuICAgIEJsZW5kTW9kZVtcIk9WRVJMQVlcIl0gPSBcIm92ZXJsYXlcIjtcclxuICAgIEJsZW5kTW9kZVtcIlNBVFVSQVRJT05cIl0gPSBcInNhdHVyYXRpb25cIjtcclxuICAgIEJsZW5kTW9kZVtcIlNDUkVFTlwiXSA9IFwic2NyZWVuXCI7XHJcbiAgICBCbGVuZE1vZGVbXCJTT0ZUX0xJR0hUXCJdID0gXCJzb2Z0LWxpZ2h0XCI7XHJcbiAgICBCbGVuZE1vZGVbXCJTUkNfQVRPUFwiXSA9IFwic291cmNlLWF0b3BcIjtcclxuICAgIEJsZW5kTW9kZVtcIlhPUlwiXSA9IFwieG9yXCI7XHJcbn0pKEJsZW5kTW9kZSB8fCAoQmxlbmRNb2RlID0ge30pKTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UmVuZGVyZXIuanMubWFwIiwiaW1wb3J0IHsgRW50aXR5IH0gZnJvbSBcIi4uLy4uL3V0aWwvRW50aXR5XCI7XHJcbi8qKlxyXG4gKiBCYXNlIGNsYXNzIGZvciBwYXR0ZXJucy5cclxuICpcclxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly93d3cuYW1jaGFydHMuY29tL2RvY3MvdjUvY29uY2VwdHMvY29sb3JzLWdyYWRpZW50cy1hbmQtcGF0dGVybnMvcGF0dGVybnMvfSBmb3IgbW9yZSBpbmZvXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgUGF0dGVybiBleHRlbmRzIEVudGl0eSB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9kaXNwbGF5XCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IHRoaXMuX3Jvb3QuX3JlbmRlcmVyLm1ha2VHcmFwaGljcygpXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX2JhY2tncm91bmREaXNwbGF5XCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IHRoaXMuX3Jvb3QuX3JlbmRlcmVyLm1ha2VHcmFwaGljcygpXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX2NsZWFyXCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IGZhbHNlXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX3BhdHRlcm5cIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBfYWZ0ZXJOZXcoKSB7XHJcbiAgICAgICAgLy8gQXBwbHlpbmcgdGhlbWVzIGJlY2F1c2UgcGF0dGVybiB3aWxsIG5vdCBoYXZlIHBhcmVudFxyXG4gICAgICAgIHN1cGVyLl9hZnRlck5ld0FwcGx5VGhlbWVzKCk7XHJcbiAgICB9XHJcbiAgICBnZXQgcGF0dGVybigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fcGF0dGVybjtcclxuICAgIH1cclxuICAgIF9kcmF3KCkgeyB9XHJcbiAgICBfYmVmb3JlQ2hhbmdlZCgpIHtcclxuICAgICAgICBzdXBlci5fYmVmb3JlQ2hhbmdlZCgpO1xyXG4gICAgICAgIGlmICh0aGlzLmlzRGlydHkoXCJyZXBldGl0aW9uXCIpIHx8IHRoaXMuaXNEaXJ0eShcIndpZHRoXCIpIHx8IHRoaXMuaXNEaXJ0eShcImhlaWdodFwiKSB8fCB0aGlzLmlzRGlydHkoXCJyb3RhdGlvblwiKSB8fCB0aGlzLmlzRGlydHkoXCJzdHJva2VXaWR0aFwiKSB8fCB0aGlzLmlzRGlydHkoXCJzdHJva2VEYXNoYXJyYXlcIikgfHwgdGhpcy5pc0RpcnR5KFwic3Ryb2tlRGFzaG9mZnNldFwiKSB8fCB0aGlzLmlzRGlydHkoXCJjb2xvck9wYWNpdHlcIikgfHwgdGhpcy5pc0RpcnR5KFwiZmlsbE9wYWNpdHlcIikpIHtcclxuICAgICAgICAgICAgdGhpcy5fY2xlYXIgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9jaGVja0RpcnR5RmlsbCgpO1xyXG4gICAgfVxyXG4gICAgX2NoZWNrRGlydHlGaWxsKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmlzRGlydHkoXCJjb2xvclwiKSB8fCB0aGlzLmlzRGlydHkoXCJmaWxsXCIpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2NsZWFyID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBfY2hhbmdlZCgpIHtcclxuICAgICAgICBzdXBlci5fY2hhbmdlZCgpO1xyXG4gICAgICAgIGlmICh0aGlzLl9jbGVhcikge1xyXG4gICAgICAgICAgICBjb25zdCByZXBldGl0aW9uID0gdGhpcy5nZXQoXCJyZXBldGl0aW9uXCIsIFwiXCIpO1xyXG4gICAgICAgICAgICBjb25zdCB3aWR0aCA9IHRoaXMuZ2V0KFwid2lkdGhcIiwgMTAwKTtcclxuICAgICAgICAgICAgY29uc3QgaGVpZ2h0ID0gdGhpcy5nZXQoXCJoZWlnaHRcIiwgMTAwKTtcclxuICAgICAgICAgICAgY29uc3QgZmlsbCA9IHRoaXMuZ2V0KFwiZmlsbFwiKTtcclxuICAgICAgICAgICAgY29uc3QgZmlsbE9wYWNpdHkgPSB0aGlzLmdldChcImZpbGxPcGFjaXR5XCIsIDEpO1xyXG4gICAgICAgICAgICBjb25zdCBiYWNrZ3JvdW5kRGlzcGxheSA9IHRoaXMuX2JhY2tncm91bmREaXNwbGF5O1xyXG4gICAgICAgICAgICBjb25zdCBkaXNwbGF5ID0gdGhpcy5fZGlzcGxheTtcclxuICAgICAgICAgICAgZGlzcGxheS5jbGVhcigpO1xyXG4gICAgICAgICAgICBiYWNrZ3JvdW5kRGlzcGxheS5jbGVhcigpO1xyXG4gICAgICAgICAgICBpZiAoZmlsbCAmJiAoZmlsbE9wYWNpdHkgPiAwKSkge1xyXG4gICAgICAgICAgICAgICAgYmFja2dyb3VuZERpc3BsYXkuYmVnaW5GaWxsKGZpbGwsIGZpbGxPcGFjaXR5KTtcclxuICAgICAgICAgICAgICAgIGJhY2tncm91bmREaXNwbGF5LmRyYXdSZWN0KDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xyXG4gICAgICAgICAgICAgICAgYmFja2dyb3VuZERpc3BsYXkuZW5kRmlsbCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGRpc3BsYXkuYW5nbGUgPSB0aGlzLmdldChcInJvdGF0aW9uXCIsIDApO1xyXG4gICAgICAgICAgICAvL2Rpc3BsYXkucGl2b3QgPSB7IHg6IHdpZHRoIC8gMiwgeTogaGVpZ2h0IC8gMiB9O1xyXG4gICAgICAgICAgICB0aGlzLl9kcmF3KCk7XHJcbiAgICAgICAgICAgIHRoaXMuX3BhdHRlcm4gPSB0aGlzLl9yb290Ll9yZW5kZXJlci5jcmVhdGVQYXR0ZXJuKGRpc3BsYXksIGJhY2tncm91bmREaXNwbGF5LCByZXBldGl0aW9uLCB3aWR0aCwgaGVpZ2h0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fY2xlYXIgPSBmYWxzZTtcclxuICAgIH1cclxufVxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUGF0dGVybiwgXCJjbGFzc05hbWVcIiwge1xyXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgdmFsdWU6IFwiUGF0dGVyblwiXHJcbn0pO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUGF0dGVybiwgXCJjbGFzc05hbWVzXCIsIHtcclxuICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgIHZhbHVlOiBFbnRpdHkuY2xhc3NOYW1lcy5jb25jYXQoW1BhdHRlcm4uY2xhc3NOYW1lXSlcclxufSk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVBhdHRlcm4uanMubWFwIiwiaW1wb3J0IHsgUGF0dGVybiB9IGZyb20gXCIuL1BhdHRlcm5cIjtcclxuLyoqXHJcbiAqIFBpY3R1cmUgcGF0dGVybi5cclxuICpcclxuICogQHNpbmNlIDUuMi4xNVxyXG4gKlxyXG4gKiBAc2VlIHtAbGluayBodHRwczovL3d3dy5hbWNoYXJ0cy5jb20vZG9jcy92NS9jb25jZXB0cy9jb2xvcnMtZ3JhZGllbnRzLWFuZC1wYXR0ZXJucy9wYXR0ZXJucy99IGZvciBtb3JlIGluZm9cclxuICovXHJcbmV4cG9ydCBjbGFzcyBQaWN0dXJlUGF0dGVybiBleHRlbmRzIFBhdHRlcm4ge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfaW1hZ2VcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBfYmVmb3JlQ2hhbmdlZCgpIHtcclxuICAgICAgICBzdXBlci5fYmVmb3JlQ2hhbmdlZCgpO1xyXG4gICAgICAgIHRoaXMuX2NsZWFyID0gdHJ1ZTtcclxuICAgICAgICBpZiAodGhpcy5pc0RpcnR5KFwic3JjXCIpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2xvYWQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgY2FudmFzID0gdGhpcy5nZXQoXCJjYW52YXNcIik7XHJcbiAgICAgICAgaWYgKGNhbnZhcykge1xyXG4gICAgICAgICAgICB0aGlzLnNldChcIndpZHRoXCIsIGNhbnZhcy53aWR0aCk7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0KFwiaGVpZ2h0XCIsIGNhbnZhcy5oZWlnaHQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIF9kcmF3KCkge1xyXG4gICAgICAgIHN1cGVyLl9kcmF3KCk7XHJcbiAgICAgICAgY29uc3QgaW1hZ2UgPSB0aGlzLl9pbWFnZTtcclxuICAgICAgICBpZiAoaW1hZ2UpIHtcclxuICAgICAgICAgICAgY29uc3QgcGF0dGVybldpZHRoID0gdGhpcy5nZXQoXCJ3aWR0aFwiLCAxMDApO1xyXG4gICAgICAgICAgICBjb25zdCBwYXR0ZXJuSGVpZ2h0ID0gdGhpcy5nZXQoXCJoZWlnaHRcIiwgMTAwKTtcclxuICAgICAgICAgICAgLy8gRml0XHJcbiAgICAgICAgICAgIGNvbnN0IGZpdCA9IHRoaXMuZ2V0KFwiZml0XCIsIFwiaW1hZ2VcIik7XHJcbiAgICAgICAgICAgIGxldCB3aWR0aCA9IDA7XHJcbiAgICAgICAgICAgIGxldCBoZWlnaHQgPSAwO1xyXG4gICAgICAgICAgICBpZiAoZml0ID09IFwicGF0dGVyblwiKSB7XHJcbiAgICAgICAgICAgICAgICB3aWR0aCA9IHBhdHRlcm5XaWR0aDtcclxuICAgICAgICAgICAgICAgIGhlaWdodCA9IHBhdHRlcm5IZWlnaHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB3aWR0aCA9IGltYWdlLndpZHRoO1xyXG4gICAgICAgICAgICAgICAgaGVpZ2h0ID0gaW1hZ2UuaGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgaWYgKGZpdCA9PSBcImltYWdlXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldChcIndpZHRoXCIsIHdpZHRoKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldChcImhlaWdodFwiLCBoZWlnaHQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIFBvc2l0aW9uXHJcbiAgICAgICAgICAgIGNvbnN0IGNlbnRlcmVkID0gdGhpcy5nZXQoXCJjZW50ZXJlZFwiLCB0cnVlKTtcclxuICAgICAgICAgICAgbGV0IHggPSAwO1xyXG4gICAgICAgICAgICBsZXQgeSA9IDA7XHJcbiAgICAgICAgICAgIGlmIChjZW50ZXJlZCkge1xyXG4gICAgICAgICAgICAgICAgeCA9IHBhdHRlcm5XaWR0aCAvIDIgLSB3aWR0aCAvIDI7XHJcbiAgICAgICAgICAgICAgICB5ID0gcGF0dGVybkhlaWdodCAvIDIgLSBoZWlnaHQgLyAyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX2Rpc3BsYXkuaW1hZ2UoaW1hZ2UsIHdpZHRoLCBoZWlnaHQsIHgsIHkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBjYW52YXMgPSB0aGlzLmdldChcImNhbnZhc1wiKTtcclxuICAgICAgICBpZiAoY2FudmFzKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2Rpc3BsYXkuaW1hZ2UoY2FudmFzLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQsIDAsIDApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIF9sb2FkKCkge1xyXG4gICAgICAgIGNvbnN0IHNyYyA9IHRoaXMuZ2V0KFwic3JjXCIpO1xyXG4gICAgICAgIGlmIChzcmMpIHtcclxuICAgICAgICAgICAgY29uc3QgaW1hZ2UgPSBuZXcgSW1hZ2UoKTtcclxuICAgICAgICAgICAgLy9pbWFnZS5jcm9zc09yaWdpbiA9IFwiQW5vbnltb3VzXCI7XHJcbiAgICAgICAgICAgIGltYWdlLnNyYyA9IHNyYztcclxuICAgICAgICAgICAgaW1hZ2UuZGVjb2RlKCkudGhlbigoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9pbWFnZSA9IGltYWdlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZHJhdygpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZXZlbnRzLmlzRW5hYmxlZChcImxvYWRlZFwiKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZXZlbnRzLmRpc3BhdGNoKFwibG9hZGVkXCIsIHsgdHlwZTogXCJsb2FkZWRcIiwgdGFyZ2V0OiB0aGlzIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KS5jYXRjaCgoX2Vycm9yKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBtYXliZSByYWlzZSBlcnJvcj9cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShQaWN0dXJlUGF0dGVybiwgXCJjbGFzc05hbWVcIiwge1xyXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgdmFsdWU6IFwiUGljdHVyZVBhdHRlcm5cIlxyXG59KTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFBpY3R1cmVQYXR0ZXJuLCBcImNsYXNzTmFtZXNcIiwge1xyXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgdmFsdWU6IFBhdHRlcm4uY2xhc3NOYW1lcy5jb25jYXQoW1BpY3R1cmVQYXR0ZXJuLmNsYXNzTmFtZV0pXHJcbn0pO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1QaWN0dXJlUGF0dGVybi5qcy5tYXAiLCJpbXBvcnQgeyBfX2F3YWl0ZXIgfSBmcm9tIFwidHNsaWJcIjtcclxuaW1wb3J0IHsgUGVyY2VudCB9IGZyb20gXCIuL1BlcmNlbnRcIjtcclxuaW1wb3J0IHsgQ29sb3IgfSBmcm9tIFwiLi9Db2xvclwiO1xyXG5pbXBvcnQgeyBFdmVudERpc3BhdGNoZXIgfSBmcm9tIFwiLi9FdmVudERpc3BhdGNoZXJcIjtcclxuaW1wb3J0ICogYXMgJG9iamVjdCBmcm9tIFwiLi9PYmplY3RcIjtcclxuLyoqXHJcbiAqIEBpZ25vcmVcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiB3YWl0Rm9yQW5pbWF0aW9ucyhhbmltYXRpb25zKSB7XHJcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgIGlmIChhbmltYXRpb25zICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgY29uc3QgcHJvbWlzZXMgPSBbXTtcclxuICAgICAgICAgICAgJG9iamVjdC5lYWNoKGFuaW1hdGlvbnMsIChfLCBhbmltYXRpb24pID0+IHtcclxuICAgICAgICAgICAgICAgIHByb21pc2VzLnB1c2goYW5pbWF0aW9uLndhaXRGb3JTdG9wKCkpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgeWllbGQgUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG59XHJcbi8qKlxyXG4gKiBAaWdub3JlXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gbm9ybWFsaXplKHZhbHVlLCBtaW4sIG1heCkge1xyXG4gICAgaWYgKG1pbiA9PT0gbWF4KSB7XHJcbiAgICAgICAgcmV0dXJuIDA7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gTWF0aC5taW4oTWF0aC5tYXgoKHZhbHVlIC0gbWluKSAqICgxIC8gKG1heCAtIG1pbikpLCAwKSwgMSk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEBpZ25vcmVcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiByYW5nZShkaWZmLCBmcm9tLCB0bykge1xyXG4gICAgcmV0dXJuIGZyb20gKyAoZGlmZiAqICh0byAtIGZyb20pKTtcclxufVxyXG4vKipcclxuICogQGlnbm9yZVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGRlZmF1bHRJbnRlcnBvbGF0ZShkaWZmLCBmcm9tLCB0bykge1xyXG4gICAgaWYgKGRpZmYgPj0gMSkge1xyXG4gICAgICAgIHJldHVybiB0bztcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBmcm9tO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBAaWdub3JlXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gcGVyY2VudEludGVycG9sYXRlKGRpZmYsIGZyb20sIHRvKSB7XHJcbiAgICByZXR1cm4gbmV3IFBlcmNlbnQocmFuZ2UoZGlmZiwgZnJvbS5wZXJjZW50LCB0by5wZXJjZW50KSk7XHJcbn1cclxuLyoqXHJcbiAqIEBpZ25vcmVcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBjb2xvckludGVycG9sYXRlKGRpZmYsIGZyb20sIHRvKSB7XHJcbiAgICByZXR1cm4gQ29sb3IuaW50ZXJwb2xhdGUoZGlmZiwgZnJvbSwgdG8pO1xyXG59XHJcbi8qKlxyXG4gKiBAaWdub3JlXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ2V0SW50ZXJwb2xhdGUoZnJvbSwgdG8pIHtcclxuICAgIGlmICh0eXBlb2YgZnJvbSA9PT0gXCJudW1iZXJcIiAmJiB0eXBlb2YgdG8gPT09IFwibnVtYmVyXCIpIHtcclxuICAgICAgICByZXR1cm4gcmFuZ2U7XHJcbiAgICB9XHJcbiAgICBpZiAoZnJvbSBpbnN0YW5jZW9mIFBlcmNlbnQgJiYgdG8gaW5zdGFuY2VvZiBQZXJjZW50KSB7XHJcbiAgICAgICAgcmV0dXJuIHBlcmNlbnRJbnRlcnBvbGF0ZTtcclxuICAgIH1cclxuICAgIGlmIChmcm9tIGluc3RhbmNlb2YgQ29sb3IgJiYgdG8gaW5zdGFuY2VvZiBDb2xvcikge1xyXG4gICAgICAgIHJldHVybiBjb2xvckludGVycG9sYXRlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGRlZmF1bHRJbnRlcnBvbGF0ZTtcclxufVxyXG4vKipcclxuICogQGlnbm9yZVxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIEFuaW1hdGlvblRpbWUge1xyXG4gICAgY29uc3RydWN0b3IoZW50aXR5LCBkdXJhdGlvbikge1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9lbnRpdHlcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX2R1cmF0aW9uXCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9wbGF5aW5nRHVyYXRpb25cIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogbnVsbFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9zdGFydGluZ1RpbWVcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogbnVsbFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9jdXJyZW50XCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IDBcclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfZnJvbVwiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiAwXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX3RvXCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IDBcclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJldmVudHNcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogbmV3IEV2ZW50RGlzcGF0Y2hlcigpXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZWFzaW5nXCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuX2VudGl0eSA9IGVudGl0eTtcclxuICAgICAgICB0aGlzLl9kdXJhdGlvbiA9IGR1cmF0aW9uO1xyXG4gICAgfVxyXG4gICAgX3N0b3BFdmVudCgpIHtcclxuICAgICAgICBjb25zdCB0eXBlID0gXCJzdG9wcGVkXCI7XHJcbiAgICAgICAgaWYgKHRoaXMuZXZlbnRzLmlzRW5hYmxlZCh0eXBlKSkge1xyXG4gICAgICAgICAgICB0aGlzLmV2ZW50cy5kaXNwYXRjaCh0eXBlLCB7IHR5cGU6IHR5cGUsIHRhcmdldDogdGhpcyB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBfcnVuQW5pbWF0aW9uKGN1cnJlbnRUaW1lKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX3BsYXlpbmdEdXJhdGlvbiAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fc3RhcnRpbmdUaW1lID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zdGFydGluZ1RpbWUgPSBjdXJyZW50VGltZTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZGlmZiA9IChjdXJyZW50VGltZSAtIHRoaXMuX3N0YXJ0aW5nVGltZSkgLyB0aGlzLl9wbGF5aW5nRHVyYXRpb247XHJcbiAgICAgICAgICAgICAgICBpZiAoZGlmZiA+PSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcGxheWluZ0R1cmF0aW9uID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdGFydGluZ1RpbWUgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2Zyb20gPSB0aGlzLl90bztcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jdXJyZW50ID0gdGhpcy5fdG87XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZW50aXR5Lm1hcmtEaXJ0eSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0b3BFdmVudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHR5cGUgPSBcImVuZGVkXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZXZlbnRzLmlzRW5hYmxlZCh0eXBlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmV2ZW50cy5kaXNwYXRjaCh0eXBlLCB7IHR5cGU6IHR5cGUsIHRhcmdldDogdGhpcyB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY3VycmVudCA9IHJhbmdlKGRpZmYsIHRoaXMuX2Zyb20sIHRoaXMuX3RvKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9lbnRpdHkubWFya0RpcnR5KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdHlwZSA9IFwicHJvZ3Jlc3NcIjtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5ldmVudHMuaXNFbmFibGVkKHR5cGUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZXZlbnRzLmRpc3BhdGNoKHR5cGUsIHsgdHlwZTogdHlwZSwgdGFyZ2V0OiB0aGlzLCBwcm9ncmVzczogZGlmZiB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBfcGxheSgpIHtcclxuICAgICAgICB0aGlzLl9mcm9tID0gdGhpcy5fY3VycmVudDtcclxuICAgICAgICBpZiAodGhpcy5fcGxheWluZ0R1cmF0aW9uID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2VudGl0eS5fcm9vdC5fYWRkQW5pbWF0aW9uKHRoaXMpO1xyXG4gICAgICAgICAgICBjb25zdCB0eXBlID0gXCJzdGFydGVkXCI7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmV2ZW50cy5pc0VuYWJsZWQodHlwZSkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZXZlbnRzLmRpc3BhdGNoKHR5cGUsIHsgdHlwZTogdHlwZSwgdGFyZ2V0OiB0aGlzIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLl9zdGFydGluZ1RpbWUgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9wbGF5aW5nRHVyYXRpb24gPSBNYXRoLmFicyh0aGlzLl90byAtIHRoaXMuX2Zyb20pICogdGhpcy5fZHVyYXRpb247XHJcbiAgICB9XHJcbiAgICBnZXQgZHVyYXRpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2R1cmF0aW9uO1xyXG4gICAgfVxyXG4gICAgc2V0IGR1cmF0aW9uKHZhbHVlKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2R1cmF0aW9uICE9PSB2YWx1ZSkge1xyXG4gICAgICAgICAgICB0aGlzLl9kdXJhdGlvbiA9IHZhbHVlO1xyXG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IDApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuanVtcFRvKHRoaXMuX3RvKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLl9jdXJyZW50ICE9PSB0aGlzLl90bykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcGxheSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZ2V0IGN1cnJlbnQoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuZWFzaW5nKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVhc2luZyh0aGlzLl9jdXJyZW50KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jdXJyZW50O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHN0b3AoKSB7XHJcbiAgICAgICAgdGhpcy5qdW1wVG8odGhpcy5fY3VycmVudCk7XHJcbiAgICB9XHJcbiAgICBqdW1wVG8odmFsdWUpIHtcclxuICAgICAgICBpZiAodGhpcy5fY3VycmVudCAhPT0gdmFsdWUpIHtcclxuICAgICAgICAgICAgdGhpcy5fZW50aXR5Lm1hcmtEaXJ0eSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5fcGxheWluZ0R1cmF0aW9uICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3N0b3BFdmVudCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9wbGF5aW5nRHVyYXRpb24gPSBudWxsO1xyXG4gICAgICAgIHRoaXMuX3N0YXJ0aW5nVGltZSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5fY3VycmVudCA9IHZhbHVlO1xyXG4gICAgICAgIHRoaXMuX2Zyb20gPSB2YWx1ZTtcclxuICAgICAgICB0aGlzLl90byA9IHZhbHVlO1xyXG4gICAgfVxyXG4gICAgdHdlZW5Ubyh2YWx1ZSkge1xyXG4gICAgICAgIGlmICh0aGlzLl9jdXJyZW50ID09PSB2YWx1ZSB8fCB0aGlzLl9kdXJhdGlvbiA9PT0gMCkge1xyXG4gICAgICAgICAgICB0aGlzLmp1bXBUbyh2YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fdG8gIT09IHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl90byA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcGxheSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbi8qZXhwb3J0IGNsYXNzIEFuaW1hdGlvblZhbHVlIGV4dGVuZHMgQW5pbWF0aW9uVGltZSB7XHJcbiAgICBwdWJsaWMgX21pbjogbnVtYmVyO1xyXG4gICAgcHVibGljIF9tYXg6IG51bWJlcjtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihlbnRpdHk6IEVudGl0eSwgZHVyYXRpb246IG51bWJlciwgbWluOiBudW1iZXIsIG1heDogbnVtYmVyKSB7XHJcbiAgICAgICAgc3VwZXIoZW50aXR5LCBkdXJhdGlvbik7XHJcbiAgICAgICAgdGhpcy5fbWluID0gbWluO1xyXG4gICAgICAgIHRoaXMuX21heCA9IG1heDtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0IG1pbigpOiBudW1iZXIge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9taW47XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHNldCBtaW4odmFsdWU6IG51bWJlcikge1xyXG4gICAgICAgIGlmICh0aGlzLl9taW4gIT09IHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX21pbiA9IHZhbHVlO1xyXG4gICAgICAgICAgICB0aGlzLl9lbnRpdHkubWFya0RpcnR5KCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXQgbWF4KCk6IG51bWJlciB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX21heDtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc2V0IG1heCh2YWx1ZTogbnVtYmVyKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX21heCAhPT0gdmFsdWUpIHtcclxuICAgICAgICAgICAgdGhpcy5fbWF4ID0gdmFsdWU7XHJcbiAgICAgICAgICAgIHRoaXMuX2VudGl0eS5tYXJrRGlydHkoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGN1cnJlbnRWYWx1ZSgpOiBudW1iZXIge1xyXG4gICAgICAgIHJldHVybiByYW5nZShzdXBlci5jdXJyZW50VGltZSgpLCB0aGlzLl9taW4sIHRoaXMuX21heCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGp1bXBUb1ZhbHVlKHZhbHVlOiBudW1iZXIpIHtcclxuICAgICAgICBzdXBlci5qdW1wVG9UaW1lKG5vcm1hbGl6ZSh2YWx1ZSwgdGhpcy5fbWluLCB0aGlzLl9tYXgpKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgdHdlZW5Ub1ZhbHVlKHZhbHVlOiBudW1iZXIpIHtcclxuICAgICAgICBzdXBlci50d2VlblRvVGltZShub3JtYWxpemUodmFsdWUsIHRoaXMuX21pbiwgdGhpcy5fbWF4KSk7XHJcbiAgICB9XHJcbn1cclxuKi9cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QW5pbWF0aW9uLmpzLm1hcCIsImltcG9ydCAqIGFzICR0eXBlIGZyb20gXCIuL1R5cGVcIjtcclxuLyoqXHJcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICogVVRJTElUWSBGVU5DVElPTlNcclxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4gKiBAaGlkZGVuXHJcbiAqL1xyXG4vKipcclxuICogU2VhcmNoZXMgYGFycmF5YCBmb3IgYHZhbHVlYC5cclxuICpcclxuICogUmV0dXJucyAtMSBpZiBub3QgZm91bmQuXHJcbiAqXHJcbiAqIEBwYXJhbSBhcnJheSAgU291cmNlIGFycmF5XHJcbiAqIEBwYXJhbSB2YWx1ZSAgVmFsdWUgdG8gc2VhcmNoXHJcbiAqIEByZXR1cm5zIEluZGV4XHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gaW5kZXhPZihhcnJheSwgdmFsdWUpIHtcclxuICAgIGNvbnN0IGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAvLyBUT0RPIGhhbmRsZSBOYU5cclxuICAgICAgICBpZiAoYXJyYXlbaV0gPT09IHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiAtMTtcclxufVxyXG4vKipcclxuICogQ2FsbHMgYHRlc3RgIGZvciBlYWNoIGVsZW1lbnQgaW4gYGFycmF5YC5cclxuICpcclxuICogSWYgYHRlc3RgIHJldHVybnMgYHRydWVgIHRoZW4gaXQgaW1tZWRpYXRlbHkgcmV0dXJucyBgdHJ1ZWAuXHJcbiAqXHJcbiAqIElmIGB0ZXN0YCByZXR1cm5zIGBmYWxzZWAgZm9yIGFsbCBvZiB0aGUgZWxlbWVudHMgaW4gYGFycmF5YCB0aGVuIGl0IHJldHVybnMgYGZhbHNlYC5cclxuICpcclxuICogQHBhcmFtIGFycmF5ICBTb3VyY2UgYXJyYXlcclxuICogQHBhcmFtIHRlc3QgICBGdW5jdGlvbiB3aGljaCBpcyBjYWxsZWQgb24gZWFjaCBlbGVtZW50XHJcbiAqIEByZXR1cm5zIFdoZXRoZXIgYHRlc3RgIHJldHVybmVkIHRydWUgb3Igbm90XHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gYW55KGFycmF5LCB0ZXN0KSB7XHJcbiAgICBjb25zdCBsZW5ndGggPSBhcnJheS5sZW5ndGg7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgaWYgKHRlc3QoYXJyYXlbaV0pKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBmYWxzZTtcclxufVxyXG4vKipcclxuICogQ2FsbHMgYGZuYCBmdW5jdGlvbiBmb3IgZXZlcnkgbWVtYmVyIG9mIGFycmF5IGFuZCByZXR1cm5zIGEgbmV3IGFycmF5IG91dFxyXG4gKiBvZiBhbGwgb3V0cHV0cy5cclxuICpcclxuICogQHBhcmFtIGFycmF5ICBTb3VyY2UgYXJyYXlcclxuICogQHBhcmFtIGZuICAgICBDYWxsYmFjayBmdW5jdGlvblxyXG4gKiBAcmV0dXJucyBOZXcgYXJyYXlcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBtYXAoYXJyYXksIGZuKSB7XHJcbiAgICBjb25zdCBsZW5ndGggPSBhcnJheS5sZW5ndGg7XHJcbiAgICBjb25zdCBvdXRwdXQgPSBuZXcgQXJyYXkobGVuZ3RoKTtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcclxuICAgICAgICBvdXRwdXRbaV0gPSBmbihhcnJheVtpXSwgaSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gb3V0cHV0O1xyXG59XHJcbi8qKlxyXG4gKiBJdGVyYXRlcyB0aHJvdWdoIGFsbCBpdGVtcyBpbiBhcnJheSBhbmQgY2FsbHMgYGZuYCBmdW5jdGlvbiBmb3IgZWFjaCBvZlxyXG4gKiB0aGVtLlxyXG4gKlxyXG4gKiBAcGFyYW0gYXJyYXkgIFNvdXJjZSBhcnJheVxyXG4gKiBAcGFyYW0gZm4gICAgIENhbGxiYWNrIGZ1bmN0aW9uXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZWFjaChhcnJheSwgZm4pIHtcclxuICAgIGNvbnN0IGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcclxuICAgICAgICBmbihhcnJheVtpXSwgaSk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEl0ZXJhdGVzIHRocm91Z2ggYWxsIGl0ZW1zIGluIGFycmF5IGluIHJldmVyc2Ugb3JkZXIgYW5kIGNhbGxzIGBmbmAgZnVuY3Rpb24gZm9yIGVhY2ggb2ZcclxuICogdGhlbS5cclxuICpcclxuICogQHBhcmFtIGFycmF5ICBTb3VyY2UgYXJyYXlcclxuICogQHBhcmFtIGZuICAgICBDYWxsYmFjayBmdW5jdGlvblxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGVhY2hSZXZlcnNlKGFycmF5LCBmbikge1xyXG4gICAgbGV0IGkgPSBhcnJheS5sZW5ndGg7XHJcbiAgICB3aGlsZSAoaSA+IDApIHtcclxuICAgICAgICAtLWk7XHJcbiAgICAgICAgZm4oYXJyYXlbaV0sIGkpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBJdGVyYXRlcyB0aHJvdWdoIGFsbCBpdGVtcyBpbiBhcnJheSBhbmQgY2FsbHMgYGZuYCBmdW5jdGlvbiBmb3IgZWFjaCBvZlxyXG4gKiB0aGVtLlxyXG4gKlxyXG4gKiBJZiBgZm5gIGNhbGwgZXZhbHVhdGVzIHRvIGBmYWxzZWAsIGZ1cnRoZXIgaXRlcmF0aW9uIGlzIGNhbmNlbGxlZC5cclxuICpcclxuICogQHBhcmFtIGFycmF5ICBTb3VyY2UgYXJyYXlcclxuICogQHBhcmFtIGZuICAgICBDYWxsYmFjayBmdW5jdGlvblxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGVhY2hDb250aW51ZShhcnJheSwgZm4pIHtcclxuICAgIGNvbnN0IGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcclxuICAgICAgICBpZiAoIWZuKGFycmF5W2ldLCBpKSkge1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFNoaWZ0cyBhbiBpdGVtIGF0IGBpbmRleGAgdG93YXJkcyBiZWdpbm5pbmcgb2YgdGhlIGFycmF5LlxyXG4gKlxyXG4gKiBAcGFyYW0gYXJyYXkgIFNvdXJjZSBhcnJheVxyXG4gKiBAcGFyYW0gaW5kZXggIFRhcmdldCBlbGVtZW50IGluZGV4XHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gc2hpZnRMZWZ0KGFycmF5LCBpbmRleCkge1xyXG4gICAgY29uc3QgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xyXG4gICAgZm9yIChsZXQgaSA9IGluZGV4OyBpIDwgbGVuZ3RoOyArK2kpIHtcclxuICAgICAgICBhcnJheVtpIC0gaW5kZXhdID0gYXJyYXlbaV07XHJcbiAgICB9XHJcbiAgICBhcnJheS5sZW5ndGggPSBsZW5ndGggLSBpbmRleDtcclxufVxyXG4vKipcclxuICogUmV0dXJucyB0aGUgbGFzdCBpdGVtIG9mIHRoZSBhcnJheS5cclxuICpcclxuICogQHBhcmFtIGFycmF5ICBTb3VyY2UgYXJyYXlcclxuICogQHJldHVybnMgTGFzdCBpdGVtXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gbGFzdChhcnJheSkge1xyXG4gICAgY29uc3QgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xyXG4gICAgcmV0dXJuIGxlbmd0aCA/IGFycmF5W2xlbmd0aCAtIDFdIDogdW5kZWZpbmVkO1xyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBmaXJzdCBpdGVtIG9mIHRoZSBhcnJheS5cclxuICpcclxuICogQHBhcmFtIGFycmF5ICBTb3VyY2UgYXJyYXlcclxuICogQHJldHVybnMgTGFzdCBpdGVtXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZmlyc3QoYXJyYXkpIHtcclxuICAgIHJldHVybiBhcnJheVswXTtcclxufVxyXG4vKipcclxuICogSW5zZXJ0cyBgZWxlbWVudGAgaW50byBgYXJyYXlgIGF0IGBpbmRleGAuXHJcbiAqXHJcbiAqIENhcHMgYGluZGV4YCB0byBiZSBiZXR3ZWVuIGAwYCBhbmQgYGFycmF5Lmxlbmd0aGBcclxuICpcclxuICogQHBhcmFtIGFycmF5ICAgIFNvdXJjZSBhcnJheVxyXG4gKiBAcGFyYW0gZWxlbWVudCAgSXRlbSB0byBpbnNlcnRcclxuICogQHBhcmFtIGFycmF5ICAgIEluZGV4IHRvIGluc2VydCBpdGVtIGF0XHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gaW5zZXJ0KGFycmF5LCBlbGVtZW50LCBpbmRleCkge1xyXG4gICAgLy9pZiAoYXJyYXkpIHtcclxuICAgIGluZGV4ID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oaW5kZXgsIGFycmF5Lmxlbmd0aCkpO1xyXG4gICAgYXJyYXkuc3BsaWNlKGluZGV4LCAwLCBlbGVtZW50KTtcclxuICAgIC8vfVxyXG59XHJcbi8qKlxyXG4gKiBSZW1vdmVzIGFsbCBjb3BpZXMgb2YgYGVsZW1lbnRgIGZyb20gYGFycmF5YCAoaWYgdGhleSBleGlzdCkgYW5kIHRoZW5cclxuICogaW5zZXJ0cyBgZWxlbWVudGAgYXQgYGluZGV4YC5cclxuICpcclxuICogQHBhcmFtIGFycmF5ICAgIFNvdXJjZSBhcnJheVxyXG4gKiBAcGFyYW0gZWxlbWVudCAgSXRlbVxyXG4gKiBAcGFyYW0gYXJyYXkgICAgSW5kZXggdG8gbW92ZSBpdGVtIHRvXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gc2V0SW5kZXgoYXJyYXksIGVsZW1lbnQsIGluZGV4KSB7XHJcbiAgICByZW1vdmUoYXJyYXksIGVsZW1lbnQpO1xyXG4gICAgaW5zZXJ0KGFycmF5LCBlbGVtZW50LCBpbmRleCk7XHJcbn1cclxuLyoqXHJcbiAqIFB1c2hlcyBhbGwgb2YgdGhlIGVsZW1lbnRzIGZyb20gYGlucHV0YCBpbnRvIGBhcnJheWAuXHJcbiAqXHJcbiAqIEBwYXJhbSBhcnJheSAgT3V0cHV0IGFycmF5XHJcbiAqIEBwYXJhbSBpbnB1dCAgSW5wdXQgYXJyYXlcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBwdXNoQWxsKGFycmF5LCBpbnB1dCkge1xyXG4gICAgY29uc3QgbGVuZ3RoID0gaW5wdXQubGVuZ3RoO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xyXG4gICAgICAgIGFycmF5LnB1c2goaW5wdXRbaV0pO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBSZW1vdmVzIGBlbGVtZW50YCBmcm9tIGBhcnJheWAuXHJcbiAqXHJcbiAqIElmIHRoZXJlIGFyZSBtdWx0aXBsZSBjb3BpZXMgb2YgYGVsZW1lbnRgLCB0aGV5IGFyZSBhbGwgcmVtb3ZlZC5cclxuICpcclxuICogQHBhcmFtIGFycmF5ICAgIFNvdXJjZSBhcnJheVxyXG4gKiBAcGFyYW0gZWxlbWVudCAgSXRlbSB0byByZW1vdmVcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiByZW1vdmUoYXJyYXksIGVsZW1lbnQpIHtcclxuICAgIGxldCBmb3VuZCA9IGZhbHNlO1xyXG4gICAgbGV0IGluZGV4ID0gMDtcclxuICAgIGZvciAoOzspIHtcclxuICAgICAgICBpbmRleCA9IGFycmF5LmluZGV4T2YoZWxlbWVudCwgaW5kZXgpO1xyXG4gICAgICAgIGlmIChpbmRleCA9PT0gLTEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZvdW5kO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZm91bmQgPSB0cnVlO1xyXG4gICAgICAgICAgICBhcnJheS5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlRmlyc3QoYXJyYXksIGVsZW1lbnQpIHtcclxuICAgIGxldCBpbmRleCA9IGFycmF5LmluZGV4T2YoZWxlbWVudCk7XHJcbiAgICBpZiAoaW5kZXggIT09IC0xKSB7XHJcbiAgICAgICAgYXJyYXkuc3BsaWNlKGluZGV4LCAxKTtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQWRkcyBhbiBgZWxlbWVudGAgdG8gYGFycmF5YC5cclxuICpcclxuICogSWYgYXJyYXkgYWxyZWFkeSBjb250YWlucyBhbmQgaXRlbSBsaWtlIHRoaXMsIGl0IGlzIHJlbW92ZWQgYmVmb3JlIGFkZGluZ1xyXG4gKiBpdCBhZ2Fpbi5cclxuICpcclxuICogT3B0aW9uYWxseSBgdG9JbmRleGAgY2FuIGJlIHNwZWNpZmllZCB0byBhZGQgZWxlbWVudCBhdCBzcGVjaWZpYyBpbmRleC5cclxuICpcclxuICogQHBhcmFtIGFycmF5ICAgIFNvdXJjZSBhcnJheVxyXG4gKiBAcGFyYW0gZWxlbWVudCAgSXRlbSB0byBhZGRcclxuICogQHBhcmFtIGFycmF5ICAgIEluZGV4IHRvIG1vdmUgaXRlbSB0b1xyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIG1vdmUoYXJyYXksIGVsZW1lbnQsIHRvSW5kZXgpIHtcclxuICAgIC8vIEB0b2RvIHRoaXMgaW1wbGVtZW50YXRpb24gbXVzdCBiZSB0aGUgc2FtZSBhcyB0aGUgTGlzdC5tb3ZlVmFsdWUgbWV0aG9kXHJcbiAgICAvLyBAdG9kbyBkb24ndCBkbyBhbnl0aGluZyBpZiB0aGUgZGVzaXJlZCBpbmRleCBpcyB0aGUgc2FtZSBhcyB0aGUgY3VycmVudCBpbmRleFxyXG4gICAgbGV0IGluZGV4ID0gaW5kZXhPZihhcnJheSwgZWxlbWVudCk7XHJcbiAgICAvLyBAdG9kbyByZW1vdmUgYWxsIG9sZCB2YWx1ZXMgcmF0aGVyIHRoYW4gb25seSB0aGUgZmlyc3QgP1xyXG4gICAgaWYgKGluZGV4ICE9PSAtMSkge1xyXG4gICAgICAgIHJlbW92ZUluZGV4KGFycmF5LCBpbmRleCk7XHJcbiAgICB9XHJcbiAgICBpZiAodG9JbmRleCA9PSBudWxsKSB7XHJcbiAgICAgICAgYXJyYXkucHVzaChlbGVtZW50KTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGluc2VydEluZGV4KGFycmF5LCB0b0luZGV4LCBlbGVtZW50KTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogSW5zZXJ0cyBgZWxlbWVudGAgaW50byBgYXJyYXlgIGF0IGBpbmRleGAuXHJcbiAqXHJcbiAqIElmIGBpbmRleGAgaXMgbm90IHByb3ZpZGVkLCBpdCB3aWxsIGluc2VydCBgZWxlbWVudGAgYXQgdGhlIGVuZCBvZiBgYXJyYXlgLlxyXG4gKlxyXG4gKiBAcGFyYW0gYXJyYXkgICAgU291cmNlIGFycmF5XHJcbiAqIEBwYXJhbSBlbGVtZW50ICBJdGVtIHRvIGFkZFxyXG4gKiBAcGFyYW0gYXJyYXkgICAgSW5kZXggdG8gYWRkIGl0ZW0gYXRcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBhZGQoYXJyYXksIGVsZW1lbnQsIGluZGV4KSB7XHJcbiAgICAvLyBBcHBlbmQgdG8gdGhlIGVuZCBpZiBpbmRleCBpcyBub3Qgc2V0XHJcbiAgICBpZiAoISR0eXBlLmlzTnVtYmVyKGluZGV4KSkge1xyXG4gICAgICAgIGFycmF5LnB1c2goZWxlbWVudCk7XHJcbiAgICB9XHJcbiAgICAvLyBBZGQgdG8gdGhlIGJlZ2lubmluZyBvZiBhcnJheSBpZiBpbmRleCBpcyAwXHJcbiAgICBlbHNlIGlmIChpbmRleCA9PT0gMCkge1xyXG4gICAgICAgIGFycmF5LnVuc2hpZnQoZWxlbWVudCk7XHJcbiAgICB9XHJcbiAgICAvLyBBZGQgdG8gaW5kaWNhdGVkIHBsYWNlIGlmIGluZGV4IGlzIHNldFxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgYXJyYXkuc3BsaWNlKGluZGV4LCAwLCBlbGVtZW50KTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogUHVzaGVzIGBlbGVtZW50YCBpbnRvIGBhcnJheWAgaWYgaXQgZG9lc24ndCBhbHJlYWR5IGV4aXN0LlxyXG4gKlxyXG4gKiBAcGFyYW0gYXJyYXkgICAgU291cmNlIGFycmF5XHJcbiAqIEBwYXJhbSBlbGVtZW50ICBJdGVtIHRvIGFkZFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHB1c2hPbmUoYXJyYXksIGVsZW1lbnQpIHtcclxuICAgIGlmIChhcnJheS5pbmRleE9mKGVsZW1lbnQpID09PSAtMSkge1xyXG4gICAgICAgIGFycmF5LnB1c2goZWxlbWVudCk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFJlbW92ZXMgYGVsZW1lbnRgIGZyb20gYGFycmF5YCAoaWYgaXQgZXhpc3RzKSBhbmQgdGhlbiBpbnNlcnRzIGBlbGVtZW50YCBhdFxyXG4gKiBgaW5kZXhgLlxyXG4gKlxyXG4gKiBJZiBgaW5kZXhgIGlzIG5vdCBwcm92aWRlZCwgaXQgd2lsbCBpbnNlcnQgYGVsZW1lbnRgIGF0IHRoZSBlbmQgb2YgYGFycmF5YC5cclxuICpcclxuICogQHBhcmFtIGFycmF5ICAgIFNvdXJjZSBhcnJheVxyXG4gKiBAcGFyYW0gZWxlbWVudCAgSXRlbSB0byByZW1vdmVcclxuICogQHBhcmFtIGFycmF5ICAgIEluZGV4IHRvIG1vdmUgaXRlbSB0b1xyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHJlcGxhY2UoYXJyYXksIGVsZW1lbnQsIGluZGV4KSB7XHJcbiAgICAvLyBjaGVjayBpZiBleGlzdHNcclxuICAgIGxldCBpbmQgPSBhcnJheS5pbmRleE9mKGVsZW1lbnQpO1xyXG4gICAgLy8gcmVtb3ZlIGlmIGV4aXN0c1xyXG4gICAgaWYgKGluZCAhPT0gLTEpIHtcclxuICAgICAgICBhcnJheS5zcGxpY2UoaW5kLCAxKTtcclxuICAgIH1cclxuICAgIC8vIGFkZCB0byBlbmQgaWYgaW5kZXggaXMgbm90IHNldFxyXG4gICAgaWYgKCEkdHlwZS5pc051bWJlcihpbmRleCkpIHtcclxuICAgICAgICBhcnJheS5wdXNoKGVsZW1lbnQpO1xyXG4gICAgfVxyXG4gICAgLy8gYWRkIHRvIGluZGljYXRlZCBwbGFjZSBpZiBpbmRleCBpcyBzZXRcclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGFycmF5LnNwbGljZShpbmRleCwgMCwgZWxlbWVudCk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFdyYXBzIGBpbnB1dGAgaW4gYW4gYXJyYXksIGlmIGl0IGlzbid0IGFscmVhZHkgYW4gYXJyYXkuXHJcbiAqXHJcbiAqIEBwYXJhbSBpbnB1dCAgU291cmNlIHZhbHVlXHJcbiAqIEByZXR1cm4gQW4gYXJyYXlcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiB0b0FycmF5KGlucHV0KSB7XHJcbiAgICBpZiAoQXJyYXkuaXNBcnJheShpbnB1dCkpIHtcclxuICAgICAgICByZXR1cm4gaW5wdXQ7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gW2lucHV0XTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogUmV0dXJucyBgdHJ1ZWAgaWYgYGVsZW1lbnRgIGV4aXN0cyBpbiBgYXJyYXlgLlxyXG4gKlxyXG4gKiBAcGFyYW0gYXJyYXkgICAgU291cmNlIGFycmF5XHJcbiAqIEBwYXJhbSBlbGVtZW50ICBJdGVtIHRvIHNlYXJjaCBmb3JcclxuICogQHJldHVybnMgSXRlbSBpbiBhcnJheT9cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBoYXMoYXJyYXksIGVsZW1lbnQpIHtcclxuICAgIHJldHVybiBpbmRleE9mKGFycmF5LCBlbGVtZW50KSAhPT0gLTE7XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybnMgYSBzaGFsbG93IGNvcHkgb2YgYGFycmF5YC5cclxuICpcclxuICogQHBhcmFtIGFycmF5ICBTb3VyY2UgYXJyYXlcclxuICogQHJldHVybnMgQ29weSBvZiB0aGUgYXJyYXlcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBjb3B5KGFycmF5KSB7XHJcbiAgICBjb25zdCBsZW5ndGggPSBhcnJheS5sZW5ndGg7XHJcbiAgICAvLyBJdCdzIGZhc3RlciB0byBjcmVhdGUgdGhlIGFycmF5IHdpdGggYSBwcmUtZGVmaW5lZCBsZW5ndGhcclxuICAgIGNvbnN0IG91dHB1dCA9IG5ldyBBcnJheShsZW5ndGgpO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xyXG4gICAgICAgIC8vIEJlY2F1c2UgdGhlIGFycmF5IGhhcyBhIHByZS1kZWZpbmVkIGxlbmd0aCwgd2UgaGF2ZSB0byBhc3NpZ24gcmF0aGVyIHRoYW4gcHVzaFxyXG4gICAgICAgIC8vIFRoaXMgaXMgYWxzbyBmYXN0ZXIgdGhhbiBwdXNoaW5nXHJcbiAgICAgICAgb3V0cHV0W2ldID0gYXJyYXlbaV07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gb3V0cHV0O1xyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm5zIGEgY29weSBvZiBgYXJyYXlgIHdoaWNoIGNvbnRhaW5zIGFsbCB0aGUgZWxlbWVudHMgYmV0d2VlbiBgc3RhcnRgXHJcbiAqIGFuZCBgZW5kYC4gKGluY2x1ZGluZyBgc3RhcnRgIGFuZCBleGNsdWRpbmcgYGVuZGApXHJcbiAqXHJcbiAqIElmIGBlbmRgIGlzIG5vdCBwcm92aWRlZCwgaXQgZGVmYXVsdHMgdG8gYGFycmF5Lmxlbmd0aGAuXHJcbiAqXHJcbiAqIEBwYXJhbSBhcnJheSAgU291cmNlIGFycmF5XHJcbiAqIEBwYXJhbSBzdGFydCAgU3RhcnQgaW5kZXhcclxuICogQHBhcmFtIGVuZCAgICBFbmQgaW5kZXhcclxuICogQHJldHVybnMgUGFydCBvZiB0aGUgYXJyYXlcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBzbGljZShhcnJheSwgc3RhcnQsIGVuZCA9IGFycmF5Lmxlbmd0aCkge1xyXG4gICAgY29uc3Qgb3V0cHV0ID0gbmV3IEFycmF5KGVuZCAtIHN0YXJ0KTtcclxuICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XHJcbiAgICAgICAgb3V0cHV0W2kgLSBzdGFydF0gPSBhcnJheVtpXTtcclxuICAgIH1cclxuICAgIHJldHVybiBvdXRwdXQ7XHJcbn1cclxuLyoqXHJcbiAqIEluc2VydHMgYSB2YWx1ZSBpbnRvIGFycmF5IGF0IHNwZWNpZmljIGluZGV4LlxyXG4gKlxyXG4gKiBAcGFyYW0gYXJyYXkgIFNvdXJjZSBhcnJheVxyXG4gKiBAcGFyYW0gaW5kZXggIEluZGV4XHJcbiAqIEBwYXJhbSB2YWx1ZSAgVmFsdWUgdG8gaW5zZXJ0XHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gaW5zZXJ0SW5kZXgoYXJyYXksIGluZGV4LCB2YWx1ZSkge1xyXG4gICAgYXJyYXkuc3BsaWNlKGluZGV4LCAwLCB2YWx1ZSk7XHJcbn1cclxuLyoqXHJcbiAqIFJlbW92ZXMgYSB2YWx1ZSBmcm9tIGFycmF5IGF0IHNwZWNpZmljIGluZGV4LlxyXG4gKlxyXG4gKiBAcGFyYW0gYXJyYXkgIFNvdXJjZSBhcnJheVxyXG4gKiBAcGFyYW0gaW5kZXggIEluZGV4XHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlSW5kZXgoYXJyYXksIGluZGV4KSB7XHJcbiAgICBhcnJheS5zcGxpY2UoaW5kZXgsIDEpO1xyXG59XHJcbi8qKlxyXG4gKiBTZWFyY2hlcyB0aGUgYXJyYXkgdXNpbmcgY3VzdG9tIGZ1bmN0aW9uIGFuZCByZXR1cm5zIGluZGV4IG9mIHRoZSBpdGVtIGlmXHJcbiAqIGZvdW5kLlxyXG4gKlxyXG4gKiBXaWxsIGNhbGwgYG1hdGNoZXNgIGZ1bmN0aW9uIG9uIGFsbCBpdGVtcyBvZiB0aGUgYXJyYXkuIElmIHJldHVybiB2YWx1ZVxyXG4gKiBldmFsdWF0ZXMgdG8gYHRydWVgLCBpbmRleCBpcyByZXR1cm5lZC5cclxuICpcclxuICogT3RoZXJ3aXNlIHJldHVybnMgLTEuXHJcbiAqXHJcbiAqIEBwYXJhbSBhcnJheSAgICBTb3VyY2UgYXJyYXlcclxuICogQHBhcmFtIG1hdGNoZXMgIFNlYXJjaCBmdW5jdGlvblxyXG4gKiBAcmV0dXJucyBJbmRleCBvZiB0aGUgaXRlbSBpZiBmb3VuZFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGZpbmRJbmRleChhcnJheSwgbWF0Y2hlcykge1xyXG4gICAgY29uc3QgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xyXG4gICAgICAgIGlmIChtYXRjaGVzKGFycmF5W2ldLCBpKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gaTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gLTE7XHJcbn1cclxuLyoqXHJcbiAqIFRoaXMgaXMgdGhlIHNhbWUgYXMgYGZpbmRJbmRleGAgZXhjZXB0IGl0IHNlYXJjaGVzIGZyb20gcmlnaHQgdG8gbGVmdC5cclxuICpcclxuICogQHBhcmFtIGFycmF5ICAgIFNvdXJjZSBhcnJheVxyXG4gKiBAcGFyYW0gbWF0Y2hlcyAgU2VhcmNoIGZ1bmN0aW9uXHJcbiAqIEByZXR1cm5zIEluZGV4IG9mIHRoZSBpdGVtIGlmIGZvdW5kXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZmluZEluZGV4UmV2ZXJzZShhcnJheSwgbWF0Y2hlcykge1xyXG4gICAgbGV0IGkgPSBhcnJheS5sZW5ndGg7XHJcbiAgICB3aGlsZSAoaSA+IDApIHtcclxuICAgICAgICAtLWk7XHJcbiAgICAgICAgaWYgKG1hdGNoZXMoYXJyYXlbaV0sIGkpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiAtMTtcclxufVxyXG4vKipcclxuICogU2VhcmNoZXMgdGhlIGFycmF5IHVzaW5nIGN1c3RvbSBmdW5jdGlvbiBhbmQgcmV0dXJucyBpdGVtIGlmIGZvdW5kLlxyXG4gKlxyXG4gKiBXaWxsIGNhbGwgYG1hdGNoZXNgIGZ1bmN0aW9uIG9uIGFsbCBpdGVtcyBvZiB0aGUgYXJyYXkuIElmIHJldHVybiB2YWx1ZVxyXG4gKiBldmFsdWF0ZXMgdG8gYHRydWVgLCBpbmRleCBpcyByZXR1cm5lZC5cclxuICpcclxuICogT3RoZXJ3aXNlIHJldHVybnMgYHVuZGVmaW5lZGAuXHJcbiAqXHJcbiAqIEBwYXJhbSBhcnJheSAgICBTb3VyY2UgYXJyYXlcclxuICogQHBhcmFtIG1hdGNoZXMgIFNlYXJjaCBmdW5jdGlvblxyXG4gKiBAcmV0dXJucyBJdGVtIGlmIGZvdW5kXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZmluZChhcnJheSwgbWF0Y2hlcykge1xyXG4gICAgY29uc3QgaW5kZXggPSBmaW5kSW5kZXgoYXJyYXksIG1hdGNoZXMpO1xyXG4gICAgaWYgKGluZGV4ICE9PSAtMSkge1xyXG4gICAgICAgIHJldHVybiBhcnJheVtpbmRleF07XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFRoaXMgaXMgdGhlIHNhbWUgYXMgYGZpbmRgIGV4Y2VwdCBpdCBzZWFyY2hlcyBmcm9tIHJpZ2h0IHRvIGxlZnQuXHJcbiAqXHJcbiAqIEBwYXJhbSBhcnJheSAgICBTb3VyY2UgYXJyYXlcclxuICogQHBhcmFtIG1hdGNoZXMgIFNlYXJjaCBmdW5jdGlvblxyXG4gKiBAcmV0dXJucyBJdGVtIGlmIGZvdW5kXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZmluZFJldmVyc2UoYXJyYXksIG1hdGNoZXMpIHtcclxuICAgIGNvbnN0IGluZGV4ID0gZmluZEluZGV4UmV2ZXJzZShhcnJheSwgbWF0Y2hlcyk7XHJcbiAgICBpZiAoaW5kZXggIT09IC0xKSB7XHJcbiAgICAgICAgcmV0dXJuIGFycmF5W2luZGV4XTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogU2VhcmNoZXMgdGhlIGFycmF5IHVzaW5nIGN1c3RvbSBmdW5jdGlvbiBhbmQgcmV0dXJucyBpdGVtIGlmIGZvdW5kLlxyXG4gKlxyXG4gKiBXaWxsIGNhbGwgYG1hdGNoZXNgIGZ1bmN0aW9uIG9uIGFsbCBpdGVtcyBvZiB0aGUgYXJyYXkuIElmIHZhbHVlXHJcbiAqIGlzIG5vdCBgdW5kZWZpbmVkYCwgaXQgcmV0dXJucyBpdC5cclxuICpcclxuICogT3RoZXJ3aXNlIHJldHVybnMgYHVuZGVmaW5lZGAuXHJcbiAqXHJcbiAqIEBwYXJhbSBhcnJheSAgICBTb3VyY2UgYXJyYXlcclxuICogQHBhcmFtIG1hdGNoZXMgIFNlYXJjaCBmdW5jdGlvblxyXG4gKiBAcmV0dXJucyBJdGVtIGlmIGZvdW5kXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZmluZE1hcChhcnJheSwgbWF0Y2hlcykge1xyXG4gICAgY29uc3QgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xyXG4gICAgICAgIGNvbnN0IHZhbHVlID0gbWF0Y2hlcyhhcnJheVtpXSwgaSk7XHJcbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4vKipcclxuICogSXRlcmF0ZXMgdGhyb3VnaCBhbGwgaXRlbXMgaW4gYXJyYXkgYW5kIGNhbGxzIGBmbmAgZnVuY3Rpb24gZm9yIGVhY2ggb2ZcclxuICogdGhlbS5cclxuICpcclxuICogQHBhcmFtIGFycmF5ICBTb3VyY2UgYXJyYXlcclxuICogQHBhcmFtIGZuICAgICBDYWxsYmFjayBmdW5jdGlvblxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHNodWZmbGUoYXJyYXkpIHtcclxuICAgIC8vIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yNDUwOTc2LzQ0OTQ3N1xyXG4gICAgbGV0IGN1cnJlbnRJbmRleCA9IGFycmF5Lmxlbmd0aCwgdGVtcG9yYXJ5VmFsdWUsIHJhbmRvbUluZGV4O1xyXG4gICAgLy8gV2hpbGUgdGhlcmUgcmVtYWluIGVsZW1lbnRzIHRvIHNodWZmbGUuLi5cclxuICAgIHdoaWxlICgwICE9PSBjdXJyZW50SW5kZXgpIHtcclxuICAgICAgICAvLyBQaWNrIGEgcmVtYWluaW5nIGVsZW1lbnQuLi5cclxuICAgICAgICByYW5kb21JbmRleCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGN1cnJlbnRJbmRleCk7XHJcbiAgICAgICAgY3VycmVudEluZGV4IC09IDE7XHJcbiAgICAgICAgLy8gQW5kIHN3YXAgaXQgd2l0aCB0aGUgY3VycmVudCBlbGVtZW50LlxyXG4gICAgICAgIHRlbXBvcmFyeVZhbHVlID0gYXJyYXlbY3VycmVudEluZGV4XTtcclxuICAgICAgICBhcnJheVtjdXJyZW50SW5kZXhdID0gYXJyYXlbcmFuZG9tSW5kZXhdO1xyXG4gICAgICAgIGFycmF5W3JhbmRvbUluZGV4XSA9IHRlbXBvcmFyeVZhbHVlO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBPcmRlcnMgYW4gYXJyYXkgdXNpbmcgc3BlY2lmaWMgYG9yZGVyaW5nYCBmdW5jdGlvbiBhbmQgcmV0dXJucyByaWdodC1tb3N0IGluZGV4IG9mXHJcbiAqIHRoZSBgdmFsdWVgLlxyXG4gKlxyXG4gKiBAaWdub3JlIEV4Y2x1ZGUgZnJvbSBkb2NzXHJcbiAqIEBwYXJhbSBhcnJheSAgICAgU291cmNlIGFycmF5XHJcbiAqIEBwYXJhbSBvcmRlcmluZyAgQW4gb3JkZXJpbmcgZnVuY3Rpb25cclxuICogQHJldHVybnMgUmVzdWx0IG9mIHRoZSBzZWFyY2hcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRTb3J0ZWRJbmRleChhcnJheSwgb3JkZXJpbmcpIHtcclxuICAgIGxldCBzdGFydCA9IDA7XHJcbiAgICBsZXQgZW5kID0gYXJyYXkubGVuZ3RoO1xyXG4gICAgbGV0IGZvdW5kID0gZmFsc2U7XHJcbiAgICB3aGlsZSAoc3RhcnQgPCBlbmQpIHtcclxuICAgICAgICAvLyBUT0RPIGlzIHRoaXMgZmFzdGVyL3Nsb3dlciB0aGFuIHVzaW5nIE1hdGguZmxvb3IgP1xyXG4gICAgICAgIGNvbnN0IHBpdm90ID0gKHN0YXJ0ICsgZW5kKSA+PiAxO1xyXG4gICAgICAgIGNvbnN0IG9yZGVyID0gb3JkZXJpbmcoYXJyYXlbcGl2b3RdKTtcclxuICAgICAgICAvLyBsZXNzXHJcbiAgICAgICAgaWYgKG9yZGVyIDwgMCkge1xyXG4gICAgICAgICAgICBzdGFydCA9IHBpdm90ICsgMTtcclxuICAgICAgICAgICAgLy8gZXF1YWxcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAob3JkZXIgPT09IDApIHtcclxuICAgICAgICAgICAgZm91bmQgPSB0cnVlO1xyXG4gICAgICAgICAgICBzdGFydCA9IHBpdm90ICsgMTtcclxuICAgICAgICAgICAgLy8gbW9yZVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZW5kID0gcGl2b3Q7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBmb3VuZDogZm91bmQsXHJcbiAgICAgICAgaW5kZXg6IChmb3VuZCA/IHN0YXJ0IC0gMSA6IHN0YXJ0KVxyXG4gICAgfTtcclxufVxyXG4vKipcclxuICogT3JkZXJzIGFuIGFycmF5IHVzaW5nIHNwZWNpZmljIGBvcmRlcmluZ2AgZnVuY3Rpb24gYW5kIHJldHVybnMgbGVmdC1tb3N0IGluZGV4IG9mXHJcbiAqIHRoZSBgdmFsdWVgLlxyXG4gKlxyXG4gKiBAaWdub3JlIEV4Y2x1ZGUgZnJvbSBkb2NzXHJcbiAqIEBwYXJhbSBhcnJheSAgICAgU291cmNlIGFycmF5XHJcbiAqIEBwYXJhbSBvcmRlcmluZyAgQW4gb3JkZXJpbmcgZnVuY3Rpb25cclxuICogQHJldHVybnMgUmVzdWx0IG9mIHRoZSBzZWFyY2hcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRGaXJzdFNvcnRlZEluZGV4KGFycmF5LCBvcmRlcmluZykge1xyXG4gICAgbGV0IHN0YXJ0ID0gMDtcclxuICAgIGxldCBlbmQgPSBhcnJheS5sZW5ndGg7XHJcbiAgICBsZXQgZm91bmQgPSBmYWxzZTtcclxuICAgIHdoaWxlIChzdGFydCA8IGVuZCkge1xyXG4gICAgICAgIC8vIFRPRE8gaXMgdGhpcyBmYXN0ZXIvc2xvd2VyIHRoYW4gdXNpbmcgTWF0aC5mbG9vciA/XHJcbiAgICAgICAgY29uc3QgcGl2b3QgPSAoc3RhcnQgKyBlbmQpID4+IDE7XHJcbiAgICAgICAgY29uc3Qgb3JkZXIgPSBvcmRlcmluZyhhcnJheVtwaXZvdF0pO1xyXG4gICAgICAgIC8vIGxlc3NcclxuICAgICAgICBpZiAob3JkZXIgPCAwKSB7XHJcbiAgICAgICAgICAgIHN0YXJ0ID0gcGl2b3QgKyAxO1xyXG4gICAgICAgICAgICAvLyBlcXVhbFxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChvcmRlciA9PT0gMCkge1xyXG4gICAgICAgICAgICBmb3VuZCA9IHRydWU7XHJcbiAgICAgICAgICAgIGVuZCA9IHBpdm90O1xyXG4gICAgICAgICAgICAvLyBtb3JlXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBlbmQgPSBwaXZvdDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGZvdW5kOiBmb3VuZCxcclxuICAgICAgICBpbmRleDogc3RhcnRcclxuICAgIH07XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIGtlZXBJZihhcnJheSwga2VlcCkge1xyXG4gICAgbGV0IGkgPSBhcnJheS5sZW5ndGg7XHJcbiAgICB3aGlsZSAoaSA+IDApIHtcclxuICAgICAgICAtLWk7XHJcbiAgICAgICAgaWYgKCFrZWVwKGFycmF5W2ldKSkge1xyXG4gICAgICAgICAgICBhcnJheS5zcGxpY2UoaSwgMSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUFycmF5LmpzLm1hcCIsImltcG9ydCB7IExpc3QgfSBmcm9tIFwiLi9MaXN0XCI7XHJcbmltcG9ydCAqIGFzICRhcnJheSBmcm9tIFwiLi9BcnJheVwiO1xyXG4vKipcclxuICogQSB2ZXJzaW9uIG9mIFtbTGlzdF1dIHRvIGhvbGQgY2hpbGRyZW4gb2YgdGhlIFtbQ29udGFpbmVyXV0uXHJcbiAqXHJcbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vd3d3LmFtY2hhcnRzLmNvbS9kb2NzL3Y1L2NvbmNlcHRzL2NvbW1vbi1lbGVtZW50cy9jb250YWluZXJzL30gZm9yIG1vcmUgaW5mb1xyXG4gKi9cclxuZXhwb3J0IGNsYXNzIENoaWxkcmVuIGV4dGVuZHMgTGlzdCB7XHJcbiAgICBjb25zdHJ1Y3Rvcihjb250YWluZXIpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9kaXNwb3NlZFwiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiBmYWxzZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9jb250YWluZXJcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX2V2ZW50c1wiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLl9jb250YWluZXIgPSBjb250YWluZXI7XHJcbiAgICAgICAgdGhpcy5fZXZlbnRzID0gdGhpcy5ldmVudHMub25BbGwoKGNoYW5nZSkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoY2hhbmdlLnR5cGUgPT09IFwiY2xlYXJcIikge1xyXG4gICAgICAgICAgICAgICAgJGFycmF5LmVhY2goY2hhbmdlLm9sZFZhbHVlcywgKHgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9vblJlbW92ZWQoeCk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChjaGFuZ2UudHlwZSA9PT0gXCJwdXNoXCIpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX29uSW5zZXJ0ZWQoY2hhbmdlLm5ld1ZhbHVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChjaGFuZ2UudHlwZSA9PT0gXCJzZXRJbmRleFwiKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9vblJlbW92ZWQoY2hhbmdlLm9sZFZhbHVlKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX29uSW5zZXJ0ZWQoY2hhbmdlLm5ld1ZhbHVlLCBjaGFuZ2UuaW5kZXgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGNoYW5nZS50eXBlID09PSBcImluc2VydEluZGV4XCIpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX29uSW5zZXJ0ZWQoY2hhbmdlLm5ld1ZhbHVlLCBjaGFuZ2UuaW5kZXgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGNoYW5nZS50eXBlID09PSBcInJlbW92ZUluZGV4XCIpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX29uUmVtb3ZlZChjaGFuZ2Uub2xkVmFsdWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGNoYW5nZS50eXBlID09PSBcIm1vdmVJbmRleFwiKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9vblJlbW92ZWQoY2hhbmdlLnZhbHVlKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX29uSW5zZXJ0ZWQoY2hhbmdlLnZhbHVlLCBjaGFuZ2UubmV3SW5kZXgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBJTGlzdEV2ZW50IHR5cGVcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIF9vbkluc2VydGVkKGNoaWxkLCBpbmRleCkge1xyXG4gICAgICAgIGNoaWxkLl9zZXRQYXJlbnQodGhpcy5fY29udGFpbmVyLCB0cnVlKTtcclxuICAgICAgICBjb25zdCBjaGlsZHJlbkRpc3BsYXkgPSB0aGlzLl9jb250YWluZXIuX2NoaWxkcmVuRGlzcGxheTtcclxuICAgICAgICBpZiAoaW5kZXggPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBjaGlsZHJlbkRpc3BsYXkuYWRkQ2hpbGQoY2hpbGQuX2Rpc3BsYXkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY2hpbGRyZW5EaXNwbGF5LmFkZENoaWxkQXQoY2hpbGQuX2Rpc3BsYXksIGluZGV4KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBfb25SZW1vdmVkKGNoaWxkKSB7XHJcbiAgICAgICAgdGhpcy5fY29udGFpbmVyLl9jaGlsZHJlbkRpc3BsYXkucmVtb3ZlQ2hpbGQoY2hpbGQuX2Rpc3BsYXkpO1xyXG4gICAgICAgIHRoaXMuX2NvbnRhaW5lci5tYXJrRGlydHlCb3VuZHMoKTtcclxuICAgICAgICB0aGlzLl9jb250YWluZXIubWFya0RpcnR5KCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYHRydWVgIGlmIG9iZWpjdCBpcyBkaXNwb3NlZC5cclxuICAgICAqL1xyXG4gICAgaXNEaXNwb3NlZCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZGlzcG9zZWQ7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFBlcm1hbmVudGx5IGRpc3Bvc2UgdGhpcyBvYmplY3QuXHJcbiAgICAgKi9cclxuICAgIGRpc3Bvc2UoKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9kaXNwb3NlZCkge1xyXG4gICAgICAgICAgICB0aGlzLl9kaXNwb3NlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMuX2V2ZW50cy5kaXNwb3NlKCk7XHJcbiAgICAgICAgICAgICRhcnJheS5lYWNoKHRoaXMudmFsdWVzLCAoY2hpbGQpID0+IHtcclxuICAgICAgICAgICAgICAgIGNoaWxkLmRpc3Bvc2UoKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNoaWxkcmVuLmpzLm1hcCIsImltcG9ydCB7IHJhbmdlIH0gZnJvbSBcIi4vQW5pbWF0aW9uXCI7XHJcbmltcG9ydCAqIGFzICR1dGlscyBmcm9tIFwiLi9VdGlsc1wiO1xyXG5pbXBvcnQgKiBhcyAkdHlwZSBmcm9tIFwiLi9UeXBlXCI7XHJcbi8qKlxyXG4gKiBAaWdub3JlXHJcbiAqL1xyXG5mdW5jdGlvbiBzdHJpbmcyaGV4KHN0cmluZykge1xyXG4gICAgLy9zdHJpbmcgPSBjc3NDb2xvck5hbWVzW3N0cmluZy50b0xvd2VyQ2FzZSgpXSB8fCBzdHJpbmc7XHJcbiAgICBpZiAoc3RyaW5nWzBdID09PSBcIiNcIikge1xyXG4gICAgICAgIHN0cmluZyA9IHN0cmluZy5zdWJzdHIoMSk7XHJcbiAgICB9XHJcbiAgICBpZiAoc3RyaW5nLmxlbmd0aCA9PSAzKSB7XHJcbiAgICAgICAgc3RyaW5nID0gc3RyaW5nWzBdLnJlcGVhdCgyKSArIHN0cmluZ1sxXS5yZXBlYXQoMikgKyBzdHJpbmdbMl0ucmVwZWF0KDIpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHBhcnNlSW50KHN0cmluZywgMTYpO1xyXG59XHJcbi8qKlxyXG4gKiBAaWdub3JlXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gcmdiYTJoZXgoY29sb3IpIHtcclxuICAgIGNvbG9yID0gY29sb3IucmVwbGFjZSgvWyBdL2csIFwiXCIpO1xyXG4gICAgLy8gSW5pdFxyXG4gICAgbGV0IG1hdGNoZXMgPSBjb2xvci5tYXRjaCgvXnJnYlxcKChbMC05XSopLChbMC05XSopLChbMC05XSopXFwpL2kpO1xyXG4gICAgLy8gVHJ5IHJnYigpIGZvcm1hdFxyXG4gICAgaWYgKG1hdGNoZXMpIHtcclxuICAgICAgICBtYXRjaGVzLnB1c2goXCIxXCIpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgbWF0Y2hlcyA9IGNvbG9yLm1hdGNoKC9ecmdiYVxcKChbMC05XSopLChbMC05XSopLChbMC05XSopLChbLjAtOV0qKVxcKS9pKTtcclxuICAgICAgICBpZiAoIW1hdGNoZXMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIDB4MDAwMDAwO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGxldCBoZXggPSBcIlwiO1xyXG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPD0gMzsgaSsrKSB7XHJcbiAgICAgICAgbGV0IHZhbCA9IHBhcnNlSW50KG1hdGNoZXNbaV0pLnRvU3RyaW5nKDE2KTtcclxuICAgICAgICBpZiAodmFsLmxlbmd0aCA9PSAxKSB7XHJcbiAgICAgICAgICAgIHZhbCA9IFwiMFwiICsgdmFsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBoZXggKz0gdmFsO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHN0cmluZzJoZXgoaGV4KTtcclxufVxyXG4vKipcclxuICogUmV0dXJucyBhIG5ldyBbW0NvbG9yXV0gb2JqZWN0IGJhc2Ugb24gaW5wdXQuXHJcbiAqXHJcbiAqIEFjY2VwdHMgcGFyYW1ldGVycyBpbiBDU1MgaGV4IG9yIHJnYi9ydGJhIHN0cmluZ3MsIG9yIGhleCBudW1iZXJzLlxyXG4gKlxyXG4gKiAqIGBcIiNmMDBcImBcclxuICogKiBgXCIjZmYwMDAwXCJgXHJcbiAqICogYFwicmdiKDI1NSwgMCwgMClcImBcclxuICogKiBgXCJyZ2JhKDI1NSwgMCwgMCwgMSlcImBcclxuICogKiBgMHhmZjAwMDBgXHJcbiAqXHJcbiAqIEBwYXJhbSAgIGlucHV0ICBJbnB1dCBjb2xvclxyXG4gKiBAcmV0dXJuICAgICAgICAgQ29sb3JcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBjb2xvcihpbnB1dCkge1xyXG4gICAgcmV0dXJuIENvbG9yLmZyb21BbnkoaW5wdXQpO1xyXG59XHJcbi8qKlxyXG4gKiBXaGVyZXZlciBjb2xvciBuZWVkcyB0byBiZSBzcGVjaWZpZWQgaW4gYW1DaGFydHMgNSwgYENvbG9yYCBvYmplY3QgbmVlZHMgdG9cclxuICogYmUgdXNlZC5cclxuICpcclxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly93d3cuYW1jaGFydHMuY29tL2RvY3MvdjUvY29uY2VwdHMvY29sb3JzLWdyYWRpZW50cy1hbmQtcGF0dGVybnMvfSBmb3IgbW9yZSBpbmZvXHJcbiAqIEBpbXBvcnRhbnRcclxuICovXHJcbmV4cG9ydCBjbGFzcyBDb2xvciB7XHJcbiAgICBjb25zdHJ1Y3RvcihoZXgpIHtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfaGV4XCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuX2hleCA9IGhleCB8IDA7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENvbG9yIG51bWVyaWMgdmFsdWUuXHJcbiAgICAgKi9cclxuICAgIGdldCBoZXgoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hleDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVmFsdWUgb2YgY29sb3IncyBSIGNoYW5uZWwuXHJcbiAgICAgKiBAcmV0dXJuIFIgdmFsdWVcclxuICAgICAqL1xyXG4gICAgZ2V0IHIoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hleCA+Pj4gMTY7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFZhbHVlIG9mIGNvbG9yJ3MgRyBjaGFubmVsLlxyXG4gICAgICogQHJldHVybiBHIHZhbHVlXHJcbiAgICAgKi9cclxuICAgIGdldCBnKCkge1xyXG4gICAgICAgIHJldHVybiAodGhpcy5faGV4ID4+IDgpICYgMHhGRjtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVmFsdWUgb2YgY29sb3IncyBCIGNoYW5uZWwuXHJcbiAgICAgKiBAcmV0dXJuIEIgdmFsdWVcclxuICAgICAqL1xyXG4gICAgZ2V0IGIoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hleCAmIDB4RkY7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgY29sb3IgQ1NTIHJlcHJlc2VudGF0aW9uIGluIGZvcm0gb2YgYHJnYmEociwgZywgYiwgYSlgIHN0cmluZy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gICBhbHBoYSAgT3BhY2l0eVxyXG4gICAgICogQHJldHVybiAgICAgICAgIENTUyBzdHJpbmdcclxuICAgICAqL1xyXG4gICAgdG9DU1MoYWxwaGEgPSAxKSB7XHJcbiAgICAgICAgcmV0dXJuIFwicmdiYShcIiArIHRoaXMuciArIFwiLCBcIiArIHRoaXMuZyArIFwiLCBcIiArIHRoaXMuYiArIFwiLCBcIiArIGFscGhhICsgXCIpXCI7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgY29sb3IgQ1NTIHJlcHJlc2VudGF0aW9uIGluIGZvcm0gb2YgYCNyZ2JgIHN0cmluZy5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJuICAgICAgICAgQ1NTIHN0cmluZ1xyXG4gICAgICovXHJcbiAgICB0b0NTU0hleCgpIHtcclxuICAgICAgICByZXR1cm4gXCIjXCIgKyAkdXRpbHMucGFkU3RyaW5nKHRoaXMuci50b1N0cmluZygxNiksIDIpICsgJHV0aWxzLnBhZFN0cmluZyh0aGlzLmcudG9TdHJpbmcoMTYpLCAyKSArICR1dGlscy5wYWRTdHJpbmcodGhpcy5iLnRvU3RyaW5nKDE2KSwgMik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgY29sb3IncyBIU0wgaW5mby5cclxuICAgICAqIEBwYXJhbSAgIGFscGhhIE9wYWNpdHlcclxuICAgICAqIEByZXR1cm4gICAgICAgIEhTTCBpbmZvXHJcbiAgICAgKi9cclxuICAgIHRvSFNMKGFscGhhID0gMSkge1xyXG4gICAgICAgIHJldHVybiAkdXRpbHMucmdiVG9Ic2woe1xyXG4gICAgICAgICAgICByOiB0aGlzLnIsXHJcbiAgICAgICAgICAgIGc6IHRoaXMuZyxcclxuICAgICAgICAgICAgYjogdGhpcy5iLFxyXG4gICAgICAgICAgICBhOiBhbHBoYVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDb252ZXJ0cyBIU0wgdmFsdWVzIGludG8gYSBuZXcgW1tDb2xvcl1dIG9iamVjdC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gICBoIEggdmFsdWVcclxuICAgICAqIEBwYXJhbSAgIHMgUyB2YWx1ZVxyXG4gICAgICogQHBhcmFtICAgbCBMIHZhbHVlXHJcbiAgICAgKiBAcmV0dXJuICAgIENvbG9yIG9iamVjdFxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZnJvbUhTTChoLCBzLCBsKSB7XHJcbiAgICAgICAgY29uc3QgcmdiID0gJHV0aWxzLmhzbFRvUmdiKHtcclxuICAgICAgICAgICAgaDogaCxcclxuICAgICAgICAgICAgczogcyxcclxuICAgICAgICAgICAgbDogbFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmZyb21SR0IocmdiLnIsIHJnYi5nLCByZ2IuYik7XHJcbiAgICB9XHJcbiAgICB0b1N0cmluZygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy50b0NTU0hleCgpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDb252ZXJ0cyBoZXggbnVtYmVyIGludG8gYSBuZXcgW1tDb2xvcl1dIG9iamVjdC5cclxuICAgICAqXHJcbiAgICAgKiBgYGBUeXBlU2NyaXB0XHJcbiAgICAgKiBDb2xvci5mcm9tSGV4KDB4ZmYwMDAwKSAvLyByZWRcclxuICAgICAqIGBgYFxyXG4gICAgICogYGBgSmF2YVNjcmlwdFxyXG4gICAgICogQ29sb3IuZnJvbUhleCgweGZmMDAwMCkgLy8gcmVkXHJcbiAgICAgKiBgYGBcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gICBoZXggIEhleCBjb2xvclxyXG4gICAgICogQHJldHVybiAgICAgICBDb2xvclxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZnJvbUhleChoZXgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IENvbG9yKGhleCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENvbnZlcnRzIFJHQiB2YWx1ZXMgdG8gYSBuZXcgW1tDb2xvcl1dIG9iamVjdC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gICByICBSIHZhbHVlXHJcbiAgICAgKiBAcGFyYW0gICBnICBHIHZhbHVlXHJcbiAgICAgKiBAcGFyYW0gICBiICBCIHZhbHVlXHJcbiAgICAgKiBAcmV0dXJuICAgICBDb2xvclxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZnJvbVJHQihyLCBnLCBiKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBDb2xvcigoYiB8IDApICsgKGcgPDwgOCkgKyAociA8PCAxNikpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDb252ZXJ0cyBSR0Igc3RyaW5nIHRvIGEgbmV3IFtbQ29sb3JdXSBvYmplY3QuXHJcbiAgICAgKlxyXG4gICAgICogYGBgVHlwZVNjcmlwdFxyXG4gICAgICogQ29sb3IuZnJvbVN0cmluZyhcIiNmZjAwMDBcIikgLy8gcmVkXHJcbiAgICAgKiBgYGBcclxuICAgICAqIGBgYEphdmFTY3JpcHRcclxuICAgICAqIENvbG9yLmZyb21TdHJpbmcoXCIjZmYwMDAwXCIpIC8vIHJlZFxyXG4gICAgICogYGBgXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtICAgcyAgUkdCIHN0cmluZ1xyXG4gICAgICogQHJldHVybiAgICAgQ29sb3JcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGZyb21TdHJpbmcocykge1xyXG4gICAgICAgIHJldHVybiBuZXcgQ29sb3Ioc3RyaW5nMmhleChzKSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENvbnZlcnRzIENTUyByZ2JhKCkgc3ludGF4IHRvIGEgbmV3IFtbQ29sb3JdXSBvYmplY3QuXHJcbiAgICAgKlxyXG4gICAgICogYGBgVHlwZVNjcmlwdFxyXG4gICAgICogQ29sb3IuZnJvbUNTUyhcInJnYmEoMjU1LCAwLCAwLCAxKVwiKSAvLyByZWRcclxuICAgICAqIGBgYFxyXG4gICAgICogYGBgSmF2YVNjcmlwdFxyXG4gICAgICogQ29sb3IuZnJvbUNTUyhcInJnYmEoMjU1LCAwLCAwLCAxKVwiKSAvLyByZWRcclxuICAgICAqIGBgYFxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSAge3N0cmluZ30gcyBbZGVzY3JpcHRpb25dXHJcbiAgICAgKiBAcmV0dXJuIHtDb2xvcn0gICAgW2Rlc2NyaXB0aW9uXVxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZnJvbUNTUyhzKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBDb2xvcihyZ2JhMmhleChzKSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENvbnZlcnQgdG8gY29sb3IgZnJvbSB2aXJ0dWFsbHkgYW55dGhpbmcuXHJcbiAgICAgKlxyXG4gICAgICogV2lsbCB0aHJvdyBhbiBleGNlcHRpb24gaWYgdW5hYmxlIHRvIHJlc29sdmUgdGhlIGNvbG9yLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSAgIHMgIFNvdXJjZVxyXG4gICAgICogQHJldHVybiAgICAgQ29sb3JcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGZyb21Bbnkocykge1xyXG4gICAgICAgIGlmICgkdHlwZS5pc1N0cmluZyhzKSkge1xyXG4gICAgICAgICAgICBpZiAoc1swXSA9PSBcIiNcIikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIENvbG9yLmZyb21TdHJpbmcocyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAocy5zdWJzdHIoMCwgMykgPT0gXCJyZ2JcIikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIENvbG9yLmZyb21DU1Mocyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoJHR5cGUuaXNOdW1iZXIocykpIHtcclxuICAgICAgICAgICAgcmV0dXJuIENvbG9yLmZyb21IZXgocyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHMgaW5zdGFuY2VvZiBDb2xvcikge1xyXG4gICAgICAgICAgICByZXR1cm4gQ29sb3IuZnJvbUhleChzLmhleCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gY29sb3Igc3ludGF4OiBcIiArIHMpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgbmV3IFtbQ29sb3JdXSBvYmplY3QgYmFzZWQgb24gZWl0aGVyIGBsaWdodEFsdGVybmF0aXZlYCBvclxyXG4gICAgICogYGRhcmtBbHRlcm5hdGl2ZWAgZGVwZW5kaW5nIG9uIHdoaWNoIG9uZSBpcyBtb3JlIGNvbnRyYXN0aW5nIHdpdGhcclxuICAgICAqIHRoZSBgY29sb3JgLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSAgIGNvbG9yICAgICAgICAgICAgIFJlZmVyZW5jZSBjb2xvclxyXG4gICAgICogQHBhcmFtICAgbGlnaHRBbHRlcm5hdGl2ZSAgTGlnaHQgY29sb3JcclxuICAgICAqIEBwYXJhbSAgIGRhcmtBbHRlcm5hdGl2ZSAgIERhcmsgY29sb3JcclxuICAgICAqIEByZXR1cm4gICAgICAgICAgICAgICAgICAgIEFsdGVybmF0aXZlIGNvbG9yXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBhbHRlcm5hdGl2ZShjb2xvciwgbGlnaHRBbHRlcm5hdGl2ZSwgZGFya0FsdGVybmF0aXZlKSB7XHJcbiAgICAgICAgY29uc3QgcmdiID0gJHV0aWxzLmFsdGVybmF0aXZlQ29sb3IoeyByOiBjb2xvci5yLCBnOiBjb2xvci5nLCBiOiBjb2xvci5iIH0sIGxpZ2h0QWx0ZXJuYXRpdmUgPyB7IHI6IGxpZ2h0QWx0ZXJuYXRpdmUuciwgZzogbGlnaHRBbHRlcm5hdGl2ZS5nLCBiOiBsaWdodEFsdGVybmF0aXZlLmIgfSA6IHVuZGVmaW5lZCwgZGFya0FsdGVybmF0aXZlID8geyByOiBkYXJrQWx0ZXJuYXRpdmUuciwgZzogZGFya0FsdGVybmF0aXZlLmcsIGI6IGRhcmtBbHRlcm5hdGl2ZS5iIH0gOiB1bmRlZmluZWQpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmZyb21SR0IocmdiLnIsIHJnYi5nLCByZ2IuYik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYW4gaW50ZXJtZWRpYXRlIENvbG9yIGJldHdlZW4gdHdvIHJlZmVyZW5jZSBjb2xvcnMgZGVwZW5kaW5nIG9uXHJcbiAgICAgKiB0aGUgcHJvZ3Jlc3MgKGBkaWZmYCkgYmV0d2VlbiB0aGUgdHdvLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSAgIGRpZmYgIFByb2dyZXNzXHJcbiAgICAgKiBAcGFyYW0gICBmcm9tICBTb3VyY2UgY29sb3JcclxuICAgICAqIEBwYXJhbSAgIHRvICAgIFRhcmdldCBjb2xvclxyXG4gICAgICogQHBhcmFtICAgbW9kZSAgSW50ZXJwb2xhdGlvbiBtb2RlXHJcbiAgICAgKiBAcmV0dXJuICAgICAgICBDb2xvclxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgaW50ZXJwb2xhdGUoZGlmZiwgZnJvbSwgdG8sIG1vZGUgPSBcInJnYlwiKSB7XHJcbiAgICAgICAgaWYgKG1vZGUgPT0gXCJoc2xcIikge1xyXG4gICAgICAgICAgICBjb25zdCBmcm9tSFNMID0gZnJvbS50b0hTTCgpO1xyXG4gICAgICAgICAgICBjb25zdCB0b0hTTCA9IHRvLnRvSFNMKCk7XHJcbiAgICAgICAgICAgIHJldHVybiBDb2xvci5mcm9tSFNMKHJhbmdlKGRpZmYsIGZyb21IU0wuaCwgdG9IU0wuaCksIHJhbmdlKGRpZmYsIGZyb21IU0wucywgdG9IU0wucyksIHJhbmdlKGRpZmYsIGZyb21IU0wubCwgdG9IU0wubCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIENvbG9yLmZyb21SR0IocmFuZ2UoZGlmZiwgZnJvbS5yLCB0by5yKSwgcmFuZ2UoZGlmZiwgZnJvbS5nLCB0by5nKSwgcmFuZ2UoZGlmZiwgZnJvbS5iLCB0by5iKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgbmV3IFtbQ29sb3JdXSBsaWdodGVuZWQgYnkgYHBlcmNlbnRgIHZhbHVlLlxyXG4gICAgICpcclxuICAgICAqIFVzZSBuZWdhdGl2ZSB2YWx1ZSB0byBkYXJrZW4gdGhlIGNvbG9yLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSAgIGNvbG9yICAgIFNvdXJjZSBjb2xvclxyXG4gICAgICogQHBhcmFtICAgcGVyY2VudCAgUGVyY2VudFxyXG4gICAgICogQHJldHVybiAgICAgICAgICAgTmV3IGNvbG9yXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBsaWdodGVuKGNvbG9yLCBwZXJjZW50KSB7XHJcbiAgICAgICAgY29uc3QgcmdiID0gJHV0aWxzLmxpZ2h0ZW4oeyByOiBjb2xvci5yLCBnOiBjb2xvci5nLCBiOiBjb2xvci5iIH0sIHBlcmNlbnQpO1xyXG4gICAgICAgIHJldHVybiBDb2xvci5mcm9tUkdCKHJnYi5yLCByZ2IuZywgcmdiLmIpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgbmV3IFtbQ29sb3JdXSBicmlnaHRlbmVkIGJ5IGBwZXJjZW50YCB2YWx1ZS5cclxuICAgICAqXHJcbiAgICAgKiBVc2UgbmVnYXRpdmUgdmFsdWUgdG8gZGltIHRoZSBjb2xvci5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gICBjb2xvciAgICBTb3VyY2UgY29sb3JcclxuICAgICAqIEBwYXJhbSAgIHBlcmNlbnQgIFBlcmNlbnRcclxuICAgICAqIEByZXR1cm4gICAgICAgICAgIE5ldyBjb2xvclxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgYnJpZ2h0ZW4oY29sb3IsIHBlcmNlbnQpIHtcclxuICAgICAgICBjb25zdCByZ2IgPSAkdXRpbHMuYnJpZ2h0ZW4oeyByOiBjb2xvci5yLCBnOiBjb2xvci5nLCBiOiBjb2xvci5iIH0sIHBlcmNlbnQpO1xyXG4gICAgICAgIHJldHVybiBDb2xvci5mcm9tUkdCKHJnYi5yLCByZ2IuZywgcmdiLmIpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgbmV3IFtbQ29sb3JdXSBzYXR1cmF0ZWQgYnkgYHBlcmNlbnRgIHZhbHVlLlxyXG4gICAgICpcclxuICAgICAqIFZhbHVlIHJhbmdlIGlzIGJldHdlZW4gYDBgIChmdWxseSBkZXNhdHVyYXRlZCksIHRvIGAxYCAoZnVsbCBjb2xvcikuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtICAgY29sb3IgICAgU291cmNlIGNvbG9yXHJcbiAgICAgKiBAcGFyYW0gICBwZXJjZW50ICBQZXJjZW50XHJcbiAgICAgKiBAcmV0dXJuICAgICAgICAgICBOZXcgY29sb3JcclxuICAgICAqL1xyXG4gICAgc3RhdGljIHNhdHVyYXRlKGNvbG9yLCBwZXJjZW50KSB7XHJcbiAgICAgICAgY29uc3QgcmdiID0gJHV0aWxzLnNhdHVyYXRlKHsgcjogY29sb3IuciwgZzogY29sb3IuZywgYjogY29sb3IuYiB9LCBwZXJjZW50KTtcclxuICAgICAgICByZXR1cm4gQ29sb3IuZnJvbVJHQihyZ2IuciwgcmdiLmcsIHJnYi5iKTtcclxuICAgIH1cclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1Db2xvci5qcy5tYXAiLCJpbXBvcnQgeyBFbnRpdHkgfSBmcm9tIFwiLi9FbnRpdHlcIjtcclxuaW1wb3J0IHsgQ29sb3IgfSBmcm9tIFwiLi9Db2xvclwiO1xyXG4vKipcclxuICogQW4gb2JqZWN0IHdoaWNoIGhvbGRzIGxpc3Qgb2YgY29sb3JzIGFuZCBjYW4gZ2VuZXJhdGUgbmV3IG9uZXMuXHJcbiAqXHJcbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vd3d3LmFtY2hhcnRzLmNvbS9kb2NzL3Y1L2NvbmNlcHRzL2NvbG9ycy1ncmFkaWVudHMtYW5kLXBhdHRlcm5zLyNDb2xvcl9zZXRzfSBmb3IgbW9yZSBpbmZvXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgQ29sb3JTZXQgZXh0ZW5kcyBFbnRpdHkge1xyXG4gICAgLy9wcm90ZWN0ZWQgX2N1cnJlbnRQYXNzOiBudW1iZXIgPSAwO1xyXG4gICAgX2FmdGVyTmV3KCkge1xyXG4gICAgICAgIC8vIEFwcGx5aW5nIHRoZW1lcyBiZWNhdXNlIGNvbG9yIHNldCB3aWxsIG5vdCBoYXZlIHBhcmVudFxyXG4gICAgICAgIHN1cGVyLl9hZnRlck5ld0FwcGx5VGhlbWVzKCk7XHJcbiAgICAgICAgdGhpcy5fZGlydHlbXCJjb2xvcnNcIl0gPSBmYWxzZTtcclxuICAgIH1cclxuICAgIF9iZWZvcmVDaGFuZ2VkKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmlzRGlydHkoXCJjb2xvcnNcIikpIHtcclxuICAgICAgICAgICAgdGhpcy5yZXNldCgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQGlnbm9yZVxyXG4gICAgICovXHJcbiAgICBnZW5lcmF0ZUNvbG9ycygpIHtcclxuICAgICAgICB0aGlzLnNldFByaXZhdGUoXCJjdXJyZW50UGFzc1wiLCB0aGlzLmdldFByaXZhdGUoXCJjdXJyZW50UGFzc1wiLCAwKSArIDEpO1xyXG4gICAgICAgIGNvbnN0IHBhc3MgPSB0aGlzLmdldFByaXZhdGUoXCJjdXJyZW50UGFzc1wiKTtcclxuICAgICAgICBjb25zdCBjb2xvcnMgPSB0aGlzLmdldChcImNvbG9yc1wiLCBbdGhpcy5nZXQoXCJiYXNlQ29sb3JcIiwgQ29sb3IuZnJvbUhleCgweGZmMDAwMCkpXSk7XHJcbiAgICAgICAgaWYgKCF0aGlzLmdldFByaXZhdGUoXCJudW1Db2xvcnNcIikpIHtcclxuICAgICAgICAgICAgdGhpcy5zZXRQcml2YXRlKFwibnVtQ29sb3JzXCIsIGNvbG9ycy5sZW5ndGgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvL2NvbnN0IGxlbiA9IGNvbG9ycy5sZW5ndGg7XHJcbiAgICAgICAgY29uc3QgbGVuID0gdGhpcy5nZXRQcml2YXRlKFwibnVtQ29sb3JzXCIpO1xyXG4gICAgICAgIC8vY29uc3Qgc3RhcnQgPSBsZW4gLSB0aGlzLmdldFByaXZhdGUoXCJudW1Db2xvcnNcIikhO1xyXG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gMDtcclxuICAgICAgICBjb25zdCBwYXNzT3B0aW9ucyA9IHRoaXMuZ2V0KFwicGFzc09wdGlvbnNcIik7XHJcbiAgICAgICAgY29uc3QgcmV1c2UgPSB0aGlzLmdldChcInJldXNlXCIpO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChyZXVzZSkge1xyXG4gICAgICAgICAgICAgICAgY29sb3JzLnB1c2goY29sb3JzW2ldKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGhzbCA9IGNvbG9yc1tpXS50b0hTTCgpO1xyXG4gICAgICAgICAgICAgICAgbGV0IGggPSBoc2wuaCArIChwYXNzT3B0aW9ucy5odWUgfHwgMCkgKiBwYXNzO1xyXG4gICAgICAgICAgICAgICAgd2hpbGUgKGggPiAxKVxyXG4gICAgICAgICAgICAgICAgICAgIGggLT0gMTtcclxuICAgICAgICAgICAgICAgIGxldCBzID0gaHNsLnMgKyAocGFzc09wdGlvbnMuc2F0dXJhdGlvbiB8fCAwKSAqIHBhc3M7XHJcbiAgICAgICAgICAgICAgICAvL2lmIChzID4gMSkgcyAtPSBNYXRoLmZsb29yKHMpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHMgPiAxKVxyXG4gICAgICAgICAgICAgICAgICAgIHMgPSAxO1xyXG4gICAgICAgICAgICAgICAgaWYgKHMgPCAwKVxyXG4gICAgICAgICAgICAgICAgICAgIHMgPSAwO1xyXG4gICAgICAgICAgICAgICAgbGV0IGwgPSBoc2wubCArIChwYXNzT3B0aW9ucy5saWdodG5lc3MgfHwgMCkgKiBwYXNzO1xyXG4gICAgICAgICAgICAgICAgLy9pZiAobCA+IDEpIGwgLT0gTWF0aC5mbG9vcihsKTtcclxuICAgICAgICAgICAgICAgIHdoaWxlIChsID4gMSlcclxuICAgICAgICAgICAgICAgICAgICBsIC09IDE7XHJcbiAgICAgICAgICAgICAgICBjb2xvcnMucHVzaChDb2xvci5mcm9tSFNMKGgsIHMsIGwpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIFtbQ29sb3JdXSBhdCBzcGVjaWZpYyBpbmRleC5cclxuICAgICAqXHJcbiAgICAgKiBJZiB0aGVyZSdzIG5vIGNvbG9yIGF0IHRoaXMgaW5kZXgsIGEgbmV3IGNvbG9yIGlzIGdlbmVyYXRlZC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gICBpbmRleCAgSW5kZXhcclxuICAgICAqIEByZXR1cm4gICAgICAgICBDb2xvclxyXG4gICAgICovXHJcbiAgICBnZXRJbmRleChpbmRleCkge1xyXG4gICAgICAgIGNvbnN0IGNvbG9ycyA9IHRoaXMuZ2V0KFwiY29sb3JzXCIsIFtdKTtcclxuICAgICAgICBjb25zdCBzYXR1cmF0aW9uID0gdGhpcy5nZXQoXCJzYXR1cmF0aW9uXCIpO1xyXG4gICAgICAgIGlmIChpbmRleCA+PSBjb2xvcnMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZ2VuZXJhdGVDb2xvcnMoKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0SW5kZXgoaW5kZXgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gc2F0dXJhdGlvbiAhPSBudWxsID8gQ29sb3Iuc2F0dXJhdGUoY29sb3JzW2luZGV4XSwgc2F0dXJhdGlvbikgOiBjb2xvcnNbaW5kZXhdO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIG5leHQgW1tDb2xvcl1dIGluIHRoZSBsaXN0LlxyXG4gICAgICpcclxuICAgICAqIElmIHRoZSBsaXN0IGlzIG91dCBvZiBjb2xvcnMsIG5ldyBvbmVzIGFyZSBnZW5lcmF0ZWQgZHluYW1pY2FsbHkuXHJcbiAgICAgKi9cclxuICAgIG5leHQoKSB7XHJcbiAgICAgICAgbGV0IGN1cnJlbnRTdGVwID0gdGhpcy5nZXRQcml2YXRlKFwiY3VycmVudFN0ZXBcIiwgdGhpcy5nZXQoXCJzdGFydEluZGV4XCIsIDApKTtcclxuICAgICAgICB0aGlzLnNldFByaXZhdGUoXCJjdXJyZW50U3RlcFwiLCBjdXJyZW50U3RlcCArIHRoaXMuZ2V0KFwic3RlcFwiLCAxKSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0SW5kZXgoY3VycmVudFN0ZXApO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXNldHMgY291bnRlciB0byB0aGUgc3RhcnQgb2YgdGhlIGxpc3QsIHNvIHRoZSBuZXh0IGNhbGwgZm9yIGBuZXh0KClgIHdpbGxcclxuICAgICAqIHJldHVybiB0aGUgZmlyc3QgY29sb3IuXHJcbiAgICAgKi9cclxuICAgIHJlc2V0KCkge1xyXG4gICAgICAgIHRoaXMuc2V0UHJpdmF0ZShcImN1cnJlbnRTdGVwXCIsIHRoaXMuZ2V0KFwic3RhcnRJbmRleFwiLCAwKSk7XHJcbiAgICAgICAgdGhpcy5zZXRQcml2YXRlKFwiY3VycmVudFBhc3NcIiwgMCk7XHJcbiAgICB9XHJcbn1cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbG9yU2V0LCBcImNsYXNzTmFtZVwiLCB7XHJcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICB2YWx1ZTogXCJDb2xvclNldFwiXHJcbn0pO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQ29sb3JTZXQsIFwiY2xhc3NOYW1lc1wiLCB7XHJcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICB2YWx1ZTogRW50aXR5LmNsYXNzTmFtZXMuY29uY2F0KFtDb2xvclNldC5jbGFzc05hbWVdKVxyXG59KTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q29sb3JTZXQuanMubWFwIiwiaW1wb3J0IHsgTGlzdCB9IGZyb20gXCIuL0xpc3RcIjtcclxuLyoqXHJcbiAqIEEgW1tMaXN0XV0gdGhhdCBob2xkcyBjb21wb25lbnRzIGRhdGEuXHJcbiAqXHJcbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vd3d3LmFtY2hhcnRzLmNvbS9kb2NzL3Y1L2NvbmNlcHRzL2RhdGEvfSBmb3IgbW9yZSBpbmZvXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgTGlzdERhdGEgZXh0ZW5kcyBMaXN0IHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQW4gb3B0aW9uYWwgcHJvY2Vzc29yIGZvciBkYXRhLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly93d3cuYW1jaGFydHMuY29tL2RvY3MvdjUvY29uY2VwdHMvZGF0YS8jUHJlX3Byb2Nlc3NpbmdfZGF0YX0gZm9yIG1vcmUgaW5mb1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInByb2Nlc3NvclwiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQGlnbm9yZVxyXG4gICAgICovXHJcbiAgICBpbmNyZW1lbnRSZWYoKSB7IH1cclxuICAgIC8qKlxyXG4gICAgICogQGlnbm9yZVxyXG4gICAgICovXHJcbiAgICBkZWNyZW1lbnRSZWYoKSB7IH1cclxuICAgIF9vblB1c2gobmV3VmFsdWUpIHtcclxuICAgICAgICBpZiAodGhpcy5wcm9jZXNzb3IpIHtcclxuICAgICAgICAgICAgdGhpcy5wcm9jZXNzb3IucHJvY2Vzc1JvdyhuZXdWYWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHN1cGVyLl9vblB1c2gobmV3VmFsdWUpO1xyXG4gICAgfVxyXG4gICAgX29uSW5zZXJ0SW5kZXgoaW5kZXgsIG5ld1ZhbHVlKSB7XHJcbiAgICAgICAgaWYgKHRoaXMucHJvY2Vzc29yKSB7XHJcbiAgICAgICAgICAgIHRoaXMucHJvY2Vzc29yLnByb2Nlc3NSb3cobmV3VmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzdXBlci5fb25JbnNlcnRJbmRleChpbmRleCwgbmV3VmFsdWUpO1xyXG4gICAgfVxyXG4gICAgX29uU2V0SW5kZXgoaW5kZXgsIG9sZFZhbHVlLCBuZXdWYWx1ZSkge1xyXG4gICAgICAgIGlmICh0aGlzLnByb2Nlc3Nvcikge1xyXG4gICAgICAgICAgICB0aGlzLnByb2Nlc3Nvci5wcm9jZXNzUm93KG5ld1ZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgc3VwZXIuX29uU2V0SW5kZXgoaW5kZXgsIG9sZFZhbHVlLCBuZXdWYWx1ZSk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEBkZXByZWNhdGVkXHJcbiAqIEB0b2RvIHJlbW92ZVxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIEpzb25EYXRhIHtcclxuICAgIGNvbnN0cnVjdG9yKHZhbHVlKSB7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwicHJvY2Vzc29yXCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl92YWx1ZVwiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLl92YWx1ZSA9IHZhbHVlO1xyXG4gICAgfVxyXG4gICAgaW5jcmVtZW50UmVmKCkgeyB9XHJcbiAgICBkZWNyZW1lbnRSZWYoKSB7IH1cclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1EYXRhLmpzLm1hcCIsImltcG9ydCB7IEVudGl0eSB9IGZyb20gXCIuL0VudGl0eVwiO1xyXG5pbXBvcnQgeyBUZXh0Rm9ybWF0dGVyIH0gZnJvbSBcIi4vVGV4dEZvcm1hdHRlclwiO1xyXG5pbXBvcnQgeyBUaW1lem9uZSB9IGZyb20gXCIuL1RpbWV6b25lXCI7XHJcbmltcG9ydCAqIGFzICR0eXBlIGZyb20gXCIuL1R5cGVcIjtcclxuaW1wb3J0ICogYXMgJHV0aWxzIGZyb20gXCIuL1V0aWxzXCI7XHJcbmV4cG9ydCBjbGFzcyBEYXRlRm9ybWF0dGVyIGV4dGVuZHMgRW50aXR5IHtcclxuICAgIF9zZXREZWZhdWx0cygpIHtcclxuICAgICAgICAvLyBEZWZhdWx0c1xyXG4gICAgICAgIHRoaXMuX3NldERlZmF1bHQoXCJjYXBpdGFsaXplXCIsIHRydWUpO1xyXG4gICAgICAgIHRoaXMuX3NldERlZmF1bHQoXCJkYXRlRm9ybWF0XCIsIFwieXl5eS1NTS1kZFwiKTtcclxuICAgICAgICBzdXBlci5fc2V0RGVmYXVsdHMoKTtcclxuICAgIH1cclxuICAgIF9iZWZvcmVDaGFuZ2VkKCkge1xyXG4gICAgICAgIHN1cGVyLl9iZWZvcmVDaGFuZ2VkKCk7XHJcbiAgICB9XHJcbiAgICBmb3JtYXQoc291cmNlLCBmb3JtYXQpIHtcclxuICAgICAgICAvLyBMb2NhbGU/XHJcbiAgICAgICAgLy8gVE9ET1xyXG4gICAgICAgIC8vIE5vIGZvcm1hdCBwYXNzZWQgaW4gb3IgaXQncyBlbXB0eVxyXG4gICAgICAgIGlmICh0eXBlb2YgZm9ybWF0ID09PSBcInVuZGVmaW5lZFwiIHx8IGZvcm1hdCA9PT0gXCJcIikge1xyXG4gICAgICAgICAgICBmb3JtYXQgPSB0aGlzLmdldChcImRhdGVGb3JtYXRcIiwgXCJ5eXl5LU1NLWRkXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBJbml0IHJldHVybiB2YWx1ZVxyXG4gICAgICAgIGxldCBmb3JtYXR0ZWQ7XHJcbiAgICAgICAgLy8gQ2FzdD9cclxuICAgICAgICAvLyBUT0RPOiBkZWNpZGUgaWYgd2UgbmVlZCB0byBjYXN0XHJcbiAgICAgICAgbGV0IGRhdGUgPSBzb3VyY2U7XHJcbiAgICAgICAgLy8gSXMgaXQgYSBidWlsdC1pbiBmb3JtYXQgb3IgSW50bC5EYXRlVGltZUZvcm1hdFxyXG4gICAgICAgIGlmICgkdHlwZS5pc09iamVjdChmb3JtYXQpKSB7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBsb2NhbGVzID0gdGhpcy5nZXQoXCJpbnRsTG9jYWxlc1wiKTtcclxuICAgICAgICAgICAgICAgIGlmIChsb2NhbGVzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KGxvY2FsZXMsIGZvcm1hdCkuZm9ybWF0KGRhdGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KHVuZGVmaW5lZCwgZm9ybWF0KS5mb3JtYXQoZGF0ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBcIkludmFsaWRcIjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBnZXQgZm9ybWF0IGluZm8gKGl0IHdpbGwgYWxzbyBkZWFsIHdpdGggcGFyc2VyIGNhY2hpbmcpXHJcbiAgICAgICAgbGV0IGluZm8gPSB0aGlzLnBhcnNlRm9ybWF0KGZvcm1hdCk7XHJcbiAgICAgICAgLy8gU2hvdWxkIHdlIGFwcGx5IGN1c3RvbSB0aW1lIHpvbmU/XHJcbiAgICAgICAgY29uc3QgdGltZXpvbmUgPSB0aGlzLl9yb290LnRpbWV6b25lO1xyXG4gICAgICAgIGlmICh0aW1lem9uZSAmJiAhdGhpcy5fcm9vdC51dGMpIHtcclxuICAgICAgICAgICAgZGF0ZSA9IHRpbWV6b25lLmNvbnZlcnRMb2NhbChkYXRlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gQ2hlY2sgaWYgaXQncyBhIHZhbGlkIGRhdGVcclxuICAgICAgICBpZiAoISR0eXBlLmlzTnVtYmVyKGRhdGUuZ2V0VGltZSgpKSkge1xyXG4gICAgICAgICAgICAvLyBUT0RPIHRyYW5zbGF0aW9uXHJcbiAgICAgICAgICAgIC8vcmV0dXJuIHRoaXMuX3QoXCJJbnZhbGlkIGRhdGVcIik7XHJcbiAgICAgICAgICAgIHJldHVybiBcIkludmFsaWQgZGF0ZVwiO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBBcHBseSBmb3JtYXRcclxuICAgICAgICBmb3JtYXR0ZWQgPSB0aGlzLmFwcGx5Rm9ybWF0KGRhdGUsIGluZm8pO1xyXG4gICAgICAgIC8vIENhcGl0YWxpemVcclxuICAgICAgICBpZiAodGhpcy5nZXQoXCJjYXBpdGFsaXplXCIpKSB7XHJcbiAgICAgICAgICAgIGZvcm1hdHRlZCA9IGZvcm1hdHRlZC5yZXBsYWNlKC9eLnsxfS8sIGZvcm1hdHRlZC5zdWJzdHIoMCwgMSkudG9VcHBlckNhc2UoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFdlJ3JlIGRvbmVcclxuICAgICAgICByZXR1cm4gZm9ybWF0dGVkO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBcHBsaWVzIGZvcm1hdCB0byBEYXRlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBkYXRlICAgICAgRGF0ZSBvYmplY3RcclxuICAgICAqIEBwYXJhbSBpbmZvICAgICAgUGFyc2VkIGZvcm1hdCBpbmZvcm1hdGlvblxyXG4gICAgICogQHJldHVybiBGb3JtYXR0ZWQgZGF0ZSBzdHJpbmdcclxuICAgICAqL1xyXG4gICAgYXBwbHlGb3JtYXQoZGF0ZSwgaW5mbykge1xyXG4gICAgICAgIC8vIEluaXQgcmV0dXJuIHZhbHVlXHJcbiAgICAgICAgbGV0IHJlcyA9IGluZm8udGVtcGxhdGU7XHJcbiAgICAgICAgLy8gR2V0IHZhbHVlc1xyXG4gICAgICAgIGxldCBmdWxsWWVhciwgbW9udGgsIHdlZWtkYXksIGRheSwgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMsIG1pbGxpc2Vjb25kcywgdGltZXN0YW1wID0gZGF0ZS5nZXRUaW1lKCk7XHJcbiAgICAgICAgaWYgKHRoaXMuX3Jvb3QudXRjKSB7XHJcbiAgICAgICAgICAgIGZ1bGxZZWFyID0gZGF0ZS5nZXRVVENGdWxsWWVhcigpO1xyXG4gICAgICAgICAgICBtb250aCA9IGRhdGUuZ2V0VVRDTW9udGgoKTtcclxuICAgICAgICAgICAgd2Vla2RheSA9IGRhdGUuZ2V0VVRDRGF5KCk7XHJcbiAgICAgICAgICAgIGRheSA9IGRhdGUuZ2V0VVRDRGF0ZSgpO1xyXG4gICAgICAgICAgICBob3VycyA9IGRhdGUuZ2V0VVRDSG91cnMoKTtcclxuICAgICAgICAgICAgbWludXRlcyA9IGRhdGUuZ2V0VVRDTWludXRlcygpO1xyXG4gICAgICAgICAgICBzZWNvbmRzID0gZGF0ZS5nZXRVVENTZWNvbmRzKCk7XHJcbiAgICAgICAgICAgIG1pbGxpc2Vjb25kcyA9IGRhdGUuZ2V0VVRDTWlsbGlzZWNvbmRzKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBmdWxsWWVhciA9IGRhdGUuZ2V0RnVsbFllYXIoKTtcclxuICAgICAgICAgICAgbW9udGggPSBkYXRlLmdldE1vbnRoKCk7XHJcbiAgICAgICAgICAgIHdlZWtkYXkgPSBkYXRlLmdldERheSgpO1xyXG4gICAgICAgICAgICBkYXkgPSBkYXRlLmdldERhdGUoKTtcclxuICAgICAgICAgICAgaG91cnMgPSBkYXRlLmdldEhvdXJzKCk7XHJcbiAgICAgICAgICAgIG1pbnV0ZXMgPSBkYXRlLmdldE1pbnV0ZXMoKTtcclxuICAgICAgICAgICAgc2Vjb25kcyA9IGRhdGUuZ2V0U2Vjb25kcygpO1xyXG4gICAgICAgICAgICBtaWxsaXNlY29uZHMgPSBkYXRlLmdldE1pbGxpc2Vjb25kcygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBHbyB0aHJvdWdoIGVhY2ggcGFydCBhbmQgZm9ybWF0L3JlcGxhY2UgaXQgaW4gdGVtcGxhdGVcclxuICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gaW5mby5wYXJ0cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICBsZXQgdmFsdWUgPSBcIlwiO1xyXG4gICAgICAgICAgICBzd2l0Y2ggKGluZm8ucGFydHNbaV0pIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJHXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB0aGlzLl90KGZ1bGxZZWFyIDwgMFxyXG4gICAgICAgICAgICAgICAgICAgICAgICA/IFwiX2VyYV9iY1wiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogXCJfZXJhX2FkXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBcInl5eXlcIjpcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IE1hdGguYWJzKGZ1bGxZZWFyKS50b1N0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChmdWxsWWVhciA8IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgKz0gdGhpcy5fdChcIl9lcmFfYmNcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBcInl5eVwiOlxyXG4gICAgICAgICAgICAgICAgY2FzZSBcInl5XCI6XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwieVwiOlxyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gTWF0aC5hYnMoZnVsbFllYXIpLnRvU3RyaW5nKCkuc3Vic3RyKC1pbmZvLnBhcnRzW2ldLmxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZ1bGxZZWFyIDwgMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSArPSB0aGlzLl90KFwiX2VyYV9iY1wiKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwiWVlZWVwiOlxyXG4gICAgICAgICAgICAgICAgY2FzZSBcIllZWVwiOlxyXG4gICAgICAgICAgICAgICAgY2FzZSBcIllZXCI6XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwiWVwiOlxyXG4gICAgICAgICAgICAgICAgICAgIGxldCB5ZWFyID0gJHV0aWxzLmdldFdlZWtZZWFyKGRhdGUsIHRoaXMuX3Jvb3QudXRjKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaW5mby5wYXJ0c1tpXSA9PSBcIllZWVlcIikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IE1hdGguYWJzKHllYXIpLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IE1hdGguYWJzKHllYXIpLnRvU3RyaW5nKCkuc3Vic3RyKC1pbmZvLnBhcnRzW2ldLmxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh5ZWFyIDwgMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSArPSB0aGlzLl90KFwiX2VyYV9iY1wiKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwidVwiOlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIEB0b2RvXHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwicVwiOlxyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gXCJcIiArIE1hdGguY2VpbCgoZGF0ZS5nZXRNb250aCgpICsgMSkgLyAzKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJNTU1NTVwiOlxyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdGhpcy5fdCh0aGlzLl9nZXRNb250aChtb250aCkpLnN1YnN0cigwLCAxKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJNTU1NXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB0aGlzLl90KHRoaXMuX2dldE1vbnRoKG1vbnRoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwiTU1NXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB0aGlzLl90KHRoaXMuX2dldFNob3J0TW9udGgobW9udGgpKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJNTVwiOlxyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gJHV0aWxzLnBhZFN0cmluZyhtb250aCArIDEsIDIsIFwiMFwiKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJNXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSAobW9udGggKyAxKS50b1N0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBcInd3XCI6XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSAkdXRpbHMucGFkU3RyaW5nKCR1dGlscy5nZXRXZWVrKGRhdGUsIHRoaXMuX3Jvb3QudXRjKSwgMiwgXCIwXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBcIndcIjpcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9ICR1dGlscy5nZXRXZWVrKGRhdGUsIHRoaXMuX3Jvb3QudXRjKS50b1N0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBcIldcIjpcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9ICR1dGlscy5nZXRNb250aFdlZWsoZGF0ZSwgdGhpcy5fcm9vdC51dGMpLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwiZGRcIjpcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9ICR1dGlscy5wYWRTdHJpbmcoZGF5LCAyLCBcIjBcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwiZFwiOlxyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gZGF5LnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwiRERcIjpcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJERERcIjpcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9ICR1dGlscy5wYWRTdHJpbmcoJHV0aWxzLmdldFllYXJEYXkoZGF0ZSwgdGhpcy5fcm9vdC51dGMpLnRvU3RyaW5nKCksIGluZm8ucGFydHNbaV0ubGVuZ3RoLCBcIjBcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwiRFwiOlxyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gJHV0aWxzLmdldFllYXJEYXkoZGF0ZSwgdGhpcy5fcm9vdC51dGMpLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwiRlwiOlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIEB0b2RvXHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwiZ1wiOlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIEB0b2RvXHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwidFwiOlxyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdGhpcy5fcm9vdC5sYW5ndWFnZS50cmFuc2xhdGVGdW5jKFwiX2RhdGVPcmRcIikuY2FsbCh0aGlzLCBkYXkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBcIkVcIjpcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9ICh3ZWVrZGF5IHx8IDcpLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwiRUVcIjpcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9ICR1dGlscy5wYWRTdHJpbmcoKHdlZWtkYXkgfHwgNykudG9TdHJpbmcoKSwgMiwgXCIwXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBcIkVFRVwiOlxyXG4gICAgICAgICAgICAgICAgY2FzZSBcImVlZVwiOlxyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdGhpcy5fdCh0aGlzLl9nZXRTaG9ydFdlZWtkYXkod2Vla2RheSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBcIkVFRUVcIjpcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJlZWVlXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB0aGlzLl90KHRoaXMuX2dldFdlZWtkYXkod2Vla2RheSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBcIkVFRUVFXCI6XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwiZWVlZWVcIjpcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHRoaXMuX3QodGhpcy5fZ2V0U2hvcnRXZWVrZGF5KHdlZWtkYXkpKS5zdWJzdHIoMCwgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwiZVwiOlxyXG4gICAgICAgICAgICAgICAgY2FzZSBcImVlXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSAod2Vla2RheSAtICh0aGlzLl9yb290LmxvY2FsZS5maXJzdERheU9mV2VlayB8fCAxKSArIDEpLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluZm8ucGFydHNbaV0gPT0gXCJlZVwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gJHV0aWxzLnBhZFN0cmluZyh2YWx1ZSwgMiwgXCIwXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJhXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGhvdXJzID49IDEyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdGhpcy5fdChcIlBNXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB0aGlzLl90KFwiQU1cIik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBcImFhXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGhvdXJzID49IDEyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdGhpcy5fdChcIlAuTS5cIik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHRoaXMuX3QoXCJBLk0uXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJhYWFcIjpcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaG91cnMgPj0gMTIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB0aGlzLl90KFwiUFwiKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdGhpcy5fdChcIkFcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBcImhcIjpcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9ICR1dGlscy5nZXQxMkhvdXJzKGhvdXJzKS50b1N0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBcImhoXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSAkdXRpbHMucGFkU3RyaW5nKCR1dGlscy5nZXQxMkhvdXJzKGhvdXJzKSwgMiwgXCIwXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBcIkhcIjpcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGhvdXJzLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwiSEhcIjpcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9ICR1dGlscy5wYWRTdHJpbmcoaG91cnMsIDIsIFwiMFwiKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJLXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSAkdXRpbHMuZ2V0MTJIb3Vycyhob3VycywgMCkudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJLS1wiOlxyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gJHV0aWxzLnBhZFN0cmluZygkdXRpbHMuZ2V0MTJIb3Vycyhob3VycywgMCksIDIsIFwiMFwiKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJrXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSAoaG91cnMgKyAxKS50b1N0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBcImtrXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSAkdXRpbHMucGFkU3RyaW5nKGhvdXJzICsgMSwgMiwgXCIwXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBcIm1cIjpcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IG1pbnV0ZXMudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJtbVwiOlxyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gJHV0aWxzLnBhZFN0cmluZyhtaW51dGVzLCAyLCBcIjBcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwic1wiOlxyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gc2Vjb25kcy50b1N0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBcInNzXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSAkdXRpbHMucGFkU3RyaW5nKHNlY29uZHMsIDIsIFwiMFwiKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJTXCI6XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwiU1NcIjpcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJTU1NcIjpcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IE1hdGgucm91bmQoKG1pbGxpc2Vjb25kcyAvIDEwMDApICogTWF0aC5wb3coMTAsIGluZm8ucGFydHNbaV0ubGVuZ3RoKSkudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJ4XCI6XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB0aW1lc3RhbXAudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJuXCI6XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwibm5cIjpcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJubm5cIjpcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9ICR1dGlscy5wYWRTdHJpbmcobWlsbGlzZWNvbmRzLCBpbmZvLnBhcnRzW2ldLmxlbmd0aCwgXCIwXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBcInpcIjpcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9ICR1dGlscy5nZXRUaW1lWm9uZShkYXRlLCBmYWxzZSwgZmFsc2UsIHRoaXMuX3Jvb3QudXRjLCB0aGlzLl9yb290LnRpbWV6b25lID8gdGhpcy5fcm9vdC50aW1lem9uZS5uYW1lIDogdW5kZWZpbmVkKS5yZXBsYWNlKC9bKy1dK1swLTldKyQvLCBcIlwiKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJ6elwiOlxyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gJHV0aWxzLmdldFRpbWVab25lKGRhdGUsIHRydWUsIGZhbHNlLCB0aGlzLl9yb290LnV0YywgdGhpcy5fcm9vdC50aW1lem9uZSA/IHRoaXMuX3Jvb3QudGltZXpvbmUubmFtZSA6IHVuZGVmaW5lZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwienp6XCI6XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSAkdXRpbHMuZ2V0VGltZVpvbmUoZGF0ZSwgZmFsc2UsIHRydWUsIHRoaXMuX3Jvb3QudXRjLCB0aGlzLl9yb290LnRpbWV6b25lID8gdGhpcy5fcm9vdC50aW1lem9uZS5uYW1lIDogdW5kZWZpbmVkKS5yZXBsYWNlKC9bKy1dK1swLTldKyQvLCBcIlwiKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJ6enp6XCI6XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSAkdXRpbHMuZ2V0VGltZVpvbmUoZGF0ZSwgdHJ1ZSwgdHJ1ZSwgdGhpcy5fcm9vdC51dGMsIHRoaXMuX3Jvb3QudGltZXpvbmUgPyB0aGlzLl9yb290LnRpbWV6b25lLm5hbWUgOiB1bmRlZmluZWQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBcIlpcIjpcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJaWlwiOlxyXG4gICAgICAgICAgICAgICAgICAgIGxldCB0aW1lem9uZSA9IHRoaXMuX3Jvb3QudXRjID8gXCJVVENcIiA6IHRoaXMuX3Jvb3QudGltZXpvbmU7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRpbWV6b25lIGluc3RhbmNlb2YgVGltZXpvbmUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGltZXpvbmUgPSB0aW1lem9uZS5uYW1lO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBvZmZzZXQgPSB0aW1lem9uZSA/ICR1dGlscy5nZXRUaW1lem9uZU9mZnNldCh0aW1lem9uZSkgOiBkYXRlLmdldFRpbWV6b25lT2Zmc2V0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHR6ID0gTWF0aC5hYnMob2Zmc2V0KSAvIDYwO1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCB0emggPSBNYXRoLmZsb29yKHR6KTtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgdHptID0gdHogKiA2MCAtIHR6aCAqIDYwO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9yb290LnV0Yykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0emggPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0em0gPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoaW5mby5wYXJ0c1tpXSA9PSBcIlpcIikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IFwiR01UXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlICs9IG9mZnNldCA+IDAgPyBcIi1cIiA6IFwiK1wiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSArPSAkdXRpbHMucGFkU3RyaW5nKHR6aCwgMikgKyBcIjpcIiArICR1dGlscy5wYWRTdHJpbmcodHptLCAyKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gb2Zmc2V0ID4gMCA/IFwiLVwiIDogXCIrXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlICs9ICR1dGlscy5wYWRTdHJpbmcodHpoLCAyKSArICR1dGlscy5wYWRTdHJpbmcodHptLCAyKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwiaVwiOlxyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gZGF0ZS50b0lTT1N0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBcIklcIjpcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGRhdGUudG9VVENTdHJpbmcoKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXMgPSByZXMucmVwbGFjZSgkdHlwZS5QTEFDRUhPTERFUiwgdmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBQYXJzZXMgZm9ybWF0IGludG8gc3RydWN0dXJlZCBpbmZyb21hdGlvbi5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gZm9ybWF0IEZvcm1hdCB0ZW1wbGF0ZVxyXG4gICAgICovXHJcbiAgICBwYXJzZUZvcm1hdChmb3JtYXQpIHtcclxuICAgICAgICAvLyBDaGVjayBjYWNoZVxyXG4gICAgICAgIC8vIFRPRE86IGltcGxlbWVudCBjYWNoaW5nIG9mIHRoZSBwYXJzZWQgZm9ybWF0XHJcbiAgICAgICAgLy8gSW5pdCBmb3JtYXQgcGFyc2UgaW5mbyBob2xkZXJcclxuICAgICAgICBsZXQgaW5mbyA9IHtcclxuICAgICAgICAgICAgXCJ0ZW1wbGF0ZVwiOiBcIlwiLFxyXG4gICAgICAgICAgICBcInBhcnRzXCI6IFtdXHJcbiAgICAgICAgfTtcclxuICAgICAgICAvLyBMZXQgVGV4dEZvcm1hdHRlciBzcGxpdCBpbnRvIGNodW5rc1xyXG4gICAgICAgIGxldCBjaHVua3MgPSBUZXh0Rm9ybWF0dGVyLmNodW5rKGZvcm1hdCwgdHJ1ZSk7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaHVua3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgbGV0IGNodW5rID0gY2h1bmtzW2ldO1xyXG4gICAgICAgICAgICBpZiAoY2h1bmsudHlwZSA9PT0gXCJ2YWx1ZVwiKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBKdXN0IFwiRGF0ZVwiP1xyXG4gICAgICAgICAgICAgICAgaWYgKGNodW5rLnRleHQubWF0Y2goL15kYXRlJC9pKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBkYXRlRm9ybWF0ID0gdGhpcy5nZXQoXCJkYXRlRm9ybWF0XCIsIFwieXl5eS1NTS1kZFwiKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoISR0eXBlLmlzU3RyaW5nKGRhdGVGb3JtYXQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGVGb3JtYXQgPSBcInl5eXktTU0tZGRcIjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY2h1bmsudGV4dCA9IGRhdGVGb3JtYXQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBGaW5kIGFsbCBwb3NzaWJsZSBwYXJ0c1xyXG4gICAgICAgICAgICAgICAgbGV0IG1hdGNoZXMgPSBjaHVuay50ZXh0Lm1hdGNoKC9HfHl5eXl8eXl5fHl5fHl8WVlZWXxZWVl8WVl8WXx1fHF8TU1NTU18TU1NTXxNTU18TU18TXx3d3x3fFd8ZGR8ZHxERER8RER8RHxGfGd8RUVFRUV8RUVFRXxFRUV8RUV8RXxlZWVlZXxlZWVlfGVlZXxlZXxlfGFhYXxhYXxhfGhofGh8SEh8SHxLS3xLfGtrfGt8bW18bXxzc3xzfFNTU3xTU3xTfEF8enp6enx6enp8enp8enxaWnxafHR8eHxubm58bm58bnxpfEkvZyk7XHJcbiAgICAgICAgICAgICAgICAvLyBGb3VuZD9cclxuICAgICAgICAgICAgICAgIGlmIChtYXRjaGVzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gUG9wdWxhdGUgdGVtcGxhdGVcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IG1hdGNoZXMubGVuZ3RoOyB4KyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5mby5wYXJ0cy5wdXNoKG1hdGNoZXNbeF0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjaHVuay50ZXh0ID0gY2h1bmsudGV4dC5yZXBsYWNlKG1hdGNoZXNbeF0sICR0eXBlLlBMQUNFSE9MREVSKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gQXBwbHkgdG8gdGVtcGxhdGVcclxuICAgICAgICAgICAgaW5mby50ZW1wbGF0ZSArPSBjaHVuay50ZXh0O1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBTYXZlIGNhY2hlXHJcbiAgICAgICAgLy8gVE9ET1xyXG4gICAgICAgIHJldHVybiBpbmZvO1xyXG4gICAgfVxyXG4gICAgX21vbnRocygpIHtcclxuICAgICAgICByZXR1cm4gW1wiSmFudWFyeVwiLCBcIkZlYnJ1YXJ5XCIsIFwiTWFyY2hcIiwgXCJBcHJpbFwiLCBcIk1heVwiLCBcIkp1bmVcIiwgXCJKdWx5XCIsIFwiQXVndXN0XCIsIFwiU2VwdGVtYmVyXCIsIFwiT2N0b2JlclwiLCBcIk5vdmVtYmVyXCIsIFwiRGVjZW1iZXJcIl07XHJcbiAgICB9XHJcbiAgICBfZ2V0TW9udGgoaW5kZXgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fbW9udGhzKClbaW5kZXhdO1xyXG4gICAgfVxyXG4gICAgX3Nob3J0TW9udGhzKCkge1xyXG4gICAgICAgIHJldHVybiBbXCJKYW5cIiwgXCJGZWJcIiwgXCJNYXJcIiwgXCJBcHJcIiwgXCJNYXkoc2hvcnQpXCIsIFwiSnVuXCIsIFwiSnVsXCIsIFwiQXVnXCIsIFwiU2VwXCIsIFwiT2N0XCIsIFwiTm92XCIsIFwiRGVjXCJdO1xyXG4gICAgfVxyXG4gICAgX2dldFNob3J0TW9udGgoaW5kZXgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fc2hvcnRNb250aHMoKVtpbmRleF07XHJcbiAgICB9XHJcbiAgICBfd2Vla2RheXMoKSB7XHJcbiAgICAgICAgcmV0dXJuIFtcIlN1bmRheVwiLCBcIk1vbmRheVwiLCBcIlR1ZXNkYXlcIiwgXCJXZWRuZXNkYXlcIiwgXCJUaHVyc2RheVwiLCBcIkZyaWRheVwiLCBcIlNhdHVyZGF5XCJdO1xyXG4gICAgfVxyXG4gICAgX2dldFdlZWtkYXkoaW5kZXgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXMoKVtpbmRleF07XHJcbiAgICB9XHJcbiAgICBfc2hvcnRXZWVrZGF5cygpIHtcclxuICAgICAgICByZXR1cm4gW1wiU3VuXCIsIFwiTW9uXCIsIFwiVHVlXCIsIFwiV2VkXCIsIFwiVGh1XCIsIFwiRnJpXCIsIFwiU2F0XCJdO1xyXG4gICAgfVxyXG4gICAgX2dldFNob3J0V2Vla2RheShpbmRleCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9zaG9ydFdlZWtkYXlzKClbaW5kZXhdO1xyXG4gICAgfVxyXG4gICAgcGFyc2Uoc291cmNlLCBmb3JtYXQpIHtcclxuICAgICAgICAvLyBJcyBpdCBhbHJlYWR5IGEgRGF0ZVxyXG4gICAgICAgIGlmIChzb3VyY2UgaW5zdGFuY2VvZiBEYXRlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzb3VyY2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIElzIGl0IGEgbnVtZXJpYyB0aW1lc3RhbXBcclxuICAgICAgICBpZiAoJHR5cGUuaXNOdW1iZXIoc291cmNlKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IERhdGUoc291cmNlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gQXJlIHdlIHBhcnNpbmcgYSB0aW1lc3RhbXA/XHJcbiAgICAgICAgaWYgKGZvcm1hdCA9PSBcInhcIikge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IERhdGUocGFyc2VJbnQoc291cmNlKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIE5vPyBMZXQncyBjaGVjayBpZiBpdCdzIHN0cmluZywgYW5kIHRyeSBjb252ZXJ0aW5nIHRvIGl0IGlmIG5lY1xyXG4gICAgICAgIGlmICghJHR5cGUuaXNTdHJpbmcoc291cmNlKSkge1xyXG4gICAgICAgICAgICBzb3VyY2UgPSBzb3VyY2UudG9TdHJpbmcoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gSW5pdCByZXR1cm4gdmFsdWVcclxuICAgICAgICBsZXQgcmVzO1xyXG4gICAgICAgIC8vIEluaXQgUmVnRXggZm9yIHBhcnNpbmdcclxuICAgICAgICBsZXQgcmVnID0gXCJcIjtcclxuICAgICAgICAvLyBDbGVhbiBmb3JtYXRcclxuICAgICAgICBmb3JtYXQgPSAkdXRpbHMuY2xlYW5Gb3JtYXQoZm9ybWF0KTtcclxuICAgICAgICAvLyBDbGlwIGZvcm1hdCB0byBsZW5ndGggb2YgdGhlIHNvdXJjZSBzdHJpbmdcclxuICAgICAgICBmb3JtYXQgPSBmb3JtYXQuc3Vic3RyKDAsIHNvdXJjZS5sZW5ndGgpO1xyXG4gICAgICAgIC8vIFBhcnNlIGZvcm1hdFxyXG4gICAgICAgIGxldCBpbmZvID0gdGhpcy5wYXJzZUZvcm1hdChmb3JtYXQpO1xyXG4gICAgICAgIC8vIEluaXQgcGFyc2VkIGl0ZW1zIGhvbGRlclxyXG4gICAgICAgIGxldCBwYXJzZWRJbmRleGVzID0ge1xyXG4gICAgICAgICAgICBcInllYXJcIjogLTEsXHJcbiAgICAgICAgICAgIFwieWVhcjNcIjogLTEsXHJcbiAgICAgICAgICAgIFwieWVhcjJcIjogLTEsXHJcbiAgICAgICAgICAgIFwieWVhcjFcIjogLTEsXHJcbiAgICAgICAgICAgIFwibW9udGhcIjogLTEsXHJcbiAgICAgICAgICAgIFwibW9udGhTaG9ydFwiOiAtMSxcclxuICAgICAgICAgICAgXCJtb250aExvbmdcIjogLTEsXHJcbiAgICAgICAgICAgIFwid2Vla2RheVNob3J0XCI6IC0xLFxyXG4gICAgICAgICAgICBcIndlZWtkYXlMb25nXCI6IC0xLFxyXG4gICAgICAgICAgICBcImRheVwiOiAtMSxcclxuICAgICAgICAgICAgXCJ5ZWFyRGF5XCI6IC0xLFxyXG4gICAgICAgICAgICBcIndlZWtcIjogLTEsXHJcbiAgICAgICAgICAgIFwiaG91ckJhc2UwXCI6IC0xLFxyXG4gICAgICAgICAgICBcImhvdXIxMkJhc2UwXCI6IC0xLFxyXG4gICAgICAgICAgICBcImhvdXJCYXNlMVwiOiAtMSxcclxuICAgICAgICAgICAgXCJob3VyMTJCYXNlMVwiOiAtMSxcclxuICAgICAgICAgICAgXCJtaW51dGVcIjogLTEsXHJcbiAgICAgICAgICAgIFwic2Vjb25kXCI6IC0xLFxyXG4gICAgICAgICAgICBcIm1pbGxpc2Vjb25kXCI6IC0xLFxyXG4gICAgICAgICAgICBcIm1pbGxpc2Vjb25kRGlnaXRzXCI6IC0xLFxyXG4gICAgICAgICAgICBcImFtXCI6IC0xLFxyXG4gICAgICAgICAgICBcInpvbmVcIjogLTEsXHJcbiAgICAgICAgICAgIFwidGltZXN0YW1wXCI6IC0xLFxyXG4gICAgICAgICAgICBcImlzb1wiOiAtMVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLy8gSW5pdCB2YWx1ZXNcclxuICAgICAgICBsZXQgcmVzVmFsdWVzID0ge1xyXG4gICAgICAgICAgICBcInllYXJcIjogMTk3MCxcclxuICAgICAgICAgICAgXCJtb250aFwiOiAwLFxyXG4gICAgICAgICAgICBcImRheVwiOiAxLFxyXG4gICAgICAgICAgICBcImhvdXJcIjogMCxcclxuICAgICAgICAgICAgXCJtaW51dGVcIjogMCxcclxuICAgICAgICAgICAgXCJzZWNvbmRcIjogMCxcclxuICAgICAgICAgICAgXCJtaWxsaXNlY29uZFwiOiAwLFxyXG4gICAgICAgICAgICBcInRpbWVzdGFtcFwiOiBudWxsLFxyXG4gICAgICAgICAgICBcIm9mZnNldFwiOiAwLFxyXG4gICAgICAgICAgICBcInV0Y1wiOiB0aGlzLl9yb290LnV0Y1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLy8gSW5kZXggYWRqdXN0ZXJcclxuICAgICAgICBsZXQgaW5kZXhBZGp1c3QgPSAwO1xyXG4gICAgICAgIGxldCBpbmRleCA9IDA7XHJcbiAgICAgICAgLy8gSXRlcmF0ZSB0aHJvdWdoIGFsbCBvZiB0aGUgcGFydHNcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGluZm8ucGFydHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgLy8gU2V0IGN1cnJlbnQgbWF0Y2ggaW5kZXhcclxuICAgICAgICAgICAgaW5kZXggPSBpICsgaW5kZXhBZGp1c3QgKyAxO1xyXG4gICAgICAgICAgICBzd2l0Y2ggKGluZm8ucGFydHNbaV0pIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJ5eXl5XCI6XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwiWVlZWVwiOlxyXG4gICAgICAgICAgICAgICAgICAgIHJlZyArPSBcIihbMC05XXs0fSlcIjtcclxuICAgICAgICAgICAgICAgICAgICBwYXJzZWRJbmRleGVzLnllYXIgPSBpbmRleDtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJ5eXlcIjpcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJZWVlcIjpcclxuICAgICAgICAgICAgICAgICAgICByZWcgKz0gXCIoWzAtOV17M30pXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VkSW5kZXhlcy55ZWFyMyA9IGluZGV4O1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBcInl5XCI6XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwiWVlcIjpcclxuICAgICAgICAgICAgICAgICAgICByZWcgKz0gXCIoWzAtOV17Mn0pXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VkSW5kZXhlcy55ZWFyMiA9IGluZGV4O1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBcInlcIjpcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJZXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgcmVnICs9IFwiKFswLTldezF9KVwiO1xyXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlZEluZGV4ZXMueWVhcjEgPSBpbmRleDtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJNTU1NXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgcmVnICs9IFwiKFwiICsgdGhpcy5nZXRTdHJpbmdMaXN0KHRoaXMuX21vbnRocygpKS5qb2luKFwifFwiKSArIFwiKVwiO1xyXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlZEluZGV4ZXMubW9udGhMb25nID0gaW5kZXg7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwiTU1NXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgcmVnICs9IFwiKFwiICsgdGhpcy5nZXRTdHJpbmdMaXN0KHRoaXMuX3Nob3J0TW9udGhzKCkpLmpvaW4oXCJ8XCIpICsgXCIpXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VkSW5kZXhlcy5tb250aFNob3J0ID0gaW5kZXg7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwiTU1cIjpcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJNXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgcmVnICs9IFwiKFswLTldezJ9fFswLTldezF9KVwiO1xyXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlZEluZGV4ZXMubW9udGggPSBpbmRleDtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJ3d1wiOlxyXG4gICAgICAgICAgICAgICAgY2FzZSBcIndcIjpcclxuICAgICAgICAgICAgICAgICAgICByZWcgKz0gXCIoWzAtOV17Mn18WzAtOV17MX0pXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VkSW5kZXhlcy53ZWVrID0gaW5kZXg7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwiZGRcIjpcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJkXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgcmVnICs9IFwiKFswLTldezJ9fFswLTldezF9KVwiO1xyXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlZEluZGV4ZXMuZGF5ID0gaW5kZXg7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwiREREXCI6XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwiRERcIjpcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJEXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgcmVnICs9IFwiKFswLTldezN9fFswLTldezJ9fFswLTldezF9KVwiO1xyXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlZEluZGV4ZXMueWVhckRheSA9IGluZGV4O1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBcImRkZGRcIjpcclxuICAgICAgICAgICAgICAgICAgICByZWcgKz0gXCIoXCIgKyB0aGlzLmdldFN0cmluZ0xpc3QodGhpcy5fd2Vla2RheXMoKSkuam9pbihcInxcIikgKyBcIilcIjtcclxuICAgICAgICAgICAgICAgICAgICBwYXJzZWRJbmRleGVzLndlZWtkYXlMb25nID0gaW5kZXg7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwiZGRkXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgcmVnICs9IFwiKFwiICsgdGhpcy5nZXRTdHJpbmdMaXN0KHRoaXMuX3Nob3J0V2Vla2RheXMoKSkuam9pbihcInxcIikgKyBcIilcIjtcclxuICAgICAgICAgICAgICAgICAgICBwYXJzZWRJbmRleGVzLndlZWtkYXlTaG9ydCA9IGluZGV4O1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBcImFhYVwiOlxyXG4gICAgICAgICAgICAgICAgY2FzZSBcImFhXCI6XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwiYVwiOlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IGZpeCAoZXNjYXBlIHJlZ2V4KVxyXG4gICAgICAgICAgICAgICAgICAgIHJlZyArPSBcIihcIiArIHRoaXMuZ2V0U3RyaW5nTGlzdChbXCJBTVwiLCBcIlBNXCIsIFwiQVxcLk1cXC5cIiwgXCJQXFwuTVxcLlwiLCBcIkFcIiwgXCJQXCJdKS5qb2luKFwifFwiKSArIFwiKVwiO1xyXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlZEluZGV4ZXMuYW0gPSBpbmRleDtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJoaFwiOlxyXG4gICAgICAgICAgICAgICAgY2FzZSBcImhcIjpcclxuICAgICAgICAgICAgICAgICAgICByZWcgKz0gXCIoWzAtOV17Mn18WzAtOV17MX0pXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VkSW5kZXhlcy5ob3VyMTJCYXNlMSA9IGluZGV4O1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBcIkhIXCI6XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwiSFwiOlxyXG4gICAgICAgICAgICAgICAgICAgIHJlZyArPSBcIihbMC05XXsyfXxbMC05XXsxfSlcIjtcclxuICAgICAgICAgICAgICAgICAgICBwYXJzZWRJbmRleGVzLmhvdXJCYXNlMCA9IGluZGV4O1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBcIktLXCI6XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwiS1wiOlxyXG4gICAgICAgICAgICAgICAgICAgIHJlZyArPSBcIihbMC05XXsyfXxbMC05XXsxfSlcIjtcclxuICAgICAgICAgICAgICAgICAgICBwYXJzZWRJbmRleGVzLmhvdXIxMkJhc2UwID0gaW5kZXg7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwia2tcIjpcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJrXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgcmVnICs9IFwiKFswLTldezJ9fFswLTldezF9KVwiO1xyXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlZEluZGV4ZXMuaG91ckJhc2UxID0gaW5kZXg7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwibW1cIjpcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJtXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgcmVnICs9IFwiKFswLTldezJ9fFswLTldezF9KVwiO1xyXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlZEluZGV4ZXMubWludXRlID0gaW5kZXg7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwic3NcIjpcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJzXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgcmVnICs9IFwiKFswLTldezJ9fFswLTldezF9KVwiO1xyXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlZEluZGV4ZXMuc2Vjb25kID0gaW5kZXg7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwiU1NTXCI6XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwiU1NcIjpcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJTXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgcmVnICs9IFwiKFswLTldezN9fFswLTldezJ9fFswLTldezF9KVwiO1xyXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlZEluZGV4ZXMubWlsbGlzZWNvbmQgPSBpbmRleDtcclxuICAgICAgICAgICAgICAgICAgICBwYXJzZWRJbmRleGVzLm1pbGxpc2Vjb25kRGlnaXRzID0gaW5mby5wYXJ0c1tpXS5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwibm5uXCI6XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwibm5cIjpcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJuXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgcmVnICs9IFwiKFswLTldezN9fFswLTldezJ9fFswLTldezF9KVwiO1xyXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlZEluZGV4ZXMubWlsbGlzZWNvbmQgPSBpbmRleDtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJ4XCI6XHJcbiAgICAgICAgICAgICAgICAgICAgcmVnICs9IFwiKFswLTldezEsfSlcIjtcclxuICAgICAgICAgICAgICAgICAgICBwYXJzZWRJbmRleGVzLnRpbWVzdGFtcCA9IGluZGV4O1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBcIlpcIjpcclxuICAgICAgICAgICAgICAgICAgICByZWcgKz0gXCJHTVQoWy0rXStbMC05XXsyfTpbMC05XXsyfSlcIjtcclxuICAgICAgICAgICAgICAgICAgICBwYXJzZWRJbmRleGVzLnpvbmUgPSBpbmRleDtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJaWlwiOlxyXG4gICAgICAgICAgICAgICAgICAgIHJlZyArPSBcIihbXFxcXC0rXStbMC05XXsyfVswLTldezJ9KVwiO1xyXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlZEluZGV4ZXMuem9uZSA9IGluZGV4O1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBcImlcIjpcclxuICAgICAgICAgICAgICAgICAgICByZWcgKz0gXCIoWzAtOV17NH0pLT8oWzAtOV17Mn0pLT8oWzAtOV17Mn0pVD8oWzAtOV17Mn0pOj8oWzAtOV17Mn0pOj8oWzAtOV17Mn0pXFxcXC4/KFswLTldezAsM30pKFt6Wl18WytcXFxcLV1bMC05XXsyfTo/WzAtOV17Mn18JClcIjtcclxuICAgICAgICAgICAgICAgICAgICBwYXJzZWRJbmRleGVzLmlzbyA9IGluZGV4O1xyXG4gICAgICAgICAgICAgICAgICAgIGluZGV4QWRqdXN0ICs9IDc7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwiR1wiOlxyXG4gICAgICAgICAgICAgICAgY2FzZSBcIllZWVlcIjpcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJZWVlcIjpcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJZWVwiOlxyXG4gICAgICAgICAgICAgICAgY2FzZSBcIllcIjpcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJNTU1NTVwiOlxyXG4gICAgICAgICAgICAgICAgY2FzZSBcIldcIjpcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJFRUVFRVwiOlxyXG4gICAgICAgICAgICAgICAgY2FzZSBcIkVFRUVcIjpcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJFRUVcIjpcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJFRVwiOlxyXG4gICAgICAgICAgICAgICAgY2FzZSBcIkVcIjpcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJlZWVlZVwiOlxyXG4gICAgICAgICAgICAgICAgY2FzZSBcImVlZWVcIjpcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJlZWVcIjpcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJlZVwiOlxyXG4gICAgICAgICAgICAgICAgY2FzZSBcImVcIjpcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJ6enp6XCI6XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwienp6XCI6XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwienpcIjpcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJ6XCI6XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwidFwiOlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIElnbm9yZVxyXG4gICAgICAgICAgICAgICAgICAgIGluZGV4QWRqdXN0LS07XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmVnICs9IFwiW14wLTldKlwiO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBUcnkgbWF0Y2hpbmdcclxuICAgICAgICBsZXQgcmVnZXggPSBuZXcgUmVnRXhwKHJlZyk7XHJcbiAgICAgICAgbGV0IG1hdGNoZXMgPSBzb3VyY2UubWF0Y2gocmVnZXgpO1xyXG4gICAgICAgIGlmIChtYXRjaGVzKSB7XHJcbiAgICAgICAgICAgIC8vIFBvcHVsYXRlIHRoZSBkYXRlIG9iamVjdFxyXG4gICAgICAgICAgICAvLyBGdWxsIHllYXJcclxuICAgICAgICAgICAgaWYgKHBhcnNlZEluZGV4ZXMueWVhciA+IC0xKSB7XHJcbiAgICAgICAgICAgICAgICByZXNWYWx1ZXMueWVhciA9IHBhcnNlSW50KG1hdGNoZXNbcGFyc2VkSW5kZXhlcy55ZWFyXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gMy1kaWdpdCB5ZWFyXHJcbiAgICAgICAgICAgIGlmIChwYXJzZWRJbmRleGVzLnllYXIzID4gLTEpIHtcclxuICAgICAgICAgICAgICAgIGxldCB2YWwgPSBwYXJzZUludChtYXRjaGVzW3BhcnNlZEluZGV4ZXMueWVhcjNdKTtcclxuICAgICAgICAgICAgICAgIHZhbCArPSAxMDAwO1xyXG4gICAgICAgICAgICAgICAgcmVzVmFsdWVzLnllYXIgPSB2YWw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gMi1kaWdpdCB5ZWFyXHJcbiAgICAgICAgICAgIGlmIChwYXJzZWRJbmRleGVzLnllYXIyID4gLTEpIHtcclxuICAgICAgICAgICAgICAgIGxldCB2YWwgPSBwYXJzZUludChtYXRjaGVzW3BhcnNlZEluZGV4ZXMueWVhcjJdKTtcclxuICAgICAgICAgICAgICAgIGlmICh2YWwgPiA1MCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhbCArPSAxMDAwO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsICs9IDIwMDA7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXNWYWx1ZXMueWVhciA9IHZhbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyAxLWRpZ2l0IHllYXJcclxuICAgICAgICAgICAgaWYgKHBhcnNlZEluZGV4ZXMueWVhcjEgPiAtMSkge1xyXG4gICAgICAgICAgICAgICAgbGV0IHZhbCA9IHBhcnNlSW50KG1hdGNoZXNbcGFyc2VkSW5kZXhlcy55ZWFyMV0pO1xyXG4gICAgICAgICAgICAgICAgdmFsID0gTWF0aC5mbG9vcigobmV3IERhdGUoKS5nZXRGdWxsWWVhcigpKSAvIDEwKSAqIDEwICsgdmFsO1xyXG4gICAgICAgICAgICAgICAgcmVzVmFsdWVzLnllYXIgPSB2YWw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gRnVsbCBtb250aFxyXG4gICAgICAgICAgICBpZiAocGFyc2VkSW5kZXhlcy5tb250aExvbmcgPiAtMSkge1xyXG4gICAgICAgICAgICAgICAgcmVzVmFsdWVzLm1vbnRoID0gdGhpcy5yZXNvbHZlTW9udGgobWF0Y2hlc1twYXJzZWRJbmRleGVzLm1vbnRoTG9uZ10pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIFNob3J0IG1vbnRoXHJcbiAgICAgICAgICAgIGlmIChwYXJzZWRJbmRleGVzLm1vbnRoU2hvcnQgPiAtMSkge1xyXG4gICAgICAgICAgICAgICAgcmVzVmFsdWVzLm1vbnRoID0gdGhpcy5yZXNvbHZlU2hvcnRNb250aChtYXRjaGVzW3BhcnNlZEluZGV4ZXMubW9udGhTaG9ydF0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIE51bWVyaWMgbW9udGhcclxuICAgICAgICAgICAgaWYgKHBhcnNlZEluZGV4ZXMubW9udGggPiAtMSkge1xyXG4gICAgICAgICAgICAgICAgcmVzVmFsdWVzLm1vbnRoID0gcGFyc2VJbnQobWF0Y2hlc1twYXJzZWRJbmRleGVzLm1vbnRoXSkgLSAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIFdlZWtkYXlcclxuICAgICAgICAgICAgLy8gQHRvZG9cclxuICAgICAgICAgICAgLy8gV2Vla1xyXG4gICAgICAgICAgICBpZiAoKHBhcnNlZEluZGV4ZXMud2VlayA+IC0xKSAmJiAocGFyc2VkSW5kZXhlcy5kYXkgPT09IC0xKSkge1xyXG4gICAgICAgICAgICAgICAgLy8gV2UgcGFyc2Ugd2Vla3MgT05MWSBpZiBkYXkgaXMgbm90IGV4cGxpY2l0bHkgc2V0XHJcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiB0aGlzIG5lZWRzIHdvcmtcclxuICAgICAgICAgICAgICAgIC8vIChidXQgbWF5YmUgbGF0ZXIgLSBJIGNhbiBoYXJkbHkgaW1hZ2luZSBhbnlvbmUgcGFzc2luZyB0aGVpciBkYXRlcyBpbiB3ZWVrcylcclxuICAgICAgICAgICAgICAgIHJlc1ZhbHVlcy5tb250aCA9IDA7XHJcbiAgICAgICAgICAgICAgICByZXNWYWx1ZXMuZGF5ID0gJHV0aWxzLmdldERheUZyb21XZWVrKHBhcnNlSW50KG1hdGNoZXNbcGFyc2VkSW5kZXhlcy53ZWVrXSksIHJlc1ZhbHVlcy55ZWFyLCAxLCB0aGlzLl9yb290LnV0Yyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gRGF5XHJcbiAgICAgICAgICAgIGlmIChwYXJzZWRJbmRleGVzLmRheSA+IC0xKSB7XHJcbiAgICAgICAgICAgICAgICByZXNWYWx1ZXMuZGF5ID0gcGFyc2VJbnQobWF0Y2hlc1twYXJzZWRJbmRleGVzLmRheV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIFllYXIgZGF5XHJcbiAgICAgICAgICAgIGlmIChwYXJzZWRJbmRleGVzLnllYXJEYXkgPiAtMSkge1xyXG4gICAgICAgICAgICAgICAgcmVzVmFsdWVzLm1vbnRoID0gMDtcclxuICAgICAgICAgICAgICAgIHJlc1ZhbHVlcy5kYXkgPSBwYXJzZUludChtYXRjaGVzW3BhcnNlZEluZGV4ZXMueWVhckRheV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIDI0IEhvdXIgKDAtMjMpXHJcbiAgICAgICAgICAgIGlmIChwYXJzZWRJbmRleGVzLmhvdXJCYXNlMCA+IC0xKSB7XHJcbiAgICAgICAgICAgICAgICByZXNWYWx1ZXMuaG91ciA9IHBhcnNlSW50KG1hdGNoZXNbcGFyc2VkSW5kZXhlcy5ob3VyQmFzZTBdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyAyNCBIb3VyICgxLTI0KVxyXG4gICAgICAgICAgICBpZiAocGFyc2VkSW5kZXhlcy5ob3VyQmFzZTEgPiAtMSkge1xyXG4gICAgICAgICAgICAgICAgcmVzVmFsdWVzLmhvdXIgPSBwYXJzZUludChtYXRjaGVzW3BhcnNlZEluZGV4ZXMuaG91ckJhc2UxXSkgLSAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIDEyIEhvdXIgKDAtMTEpXHJcbiAgICAgICAgICAgIGlmIChwYXJzZWRJbmRleGVzLmhvdXIxMkJhc2UwID4gLTEpIHtcclxuICAgICAgICAgICAgICAgIGxldCB2YWwgPSBwYXJzZUludChtYXRjaGVzW3BhcnNlZEluZGV4ZXMuaG91cjEyQmFzZTBdKTtcclxuICAgICAgICAgICAgICAgIGlmICh2YWwgPT0gMTEpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YWwgPSAwO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKChwYXJzZWRJbmRleGVzLmFtID4gLTEpICYmICF0aGlzLmlzQW0obWF0Y2hlc1twYXJzZWRJbmRleGVzLmFtXSkpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YWwgKz0gMTI7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXNWYWx1ZXMuaG91ciA9IHZhbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyAxMiBIb3VyICgxLTEyKVxyXG4gICAgICAgICAgICBpZiAocGFyc2VkSW5kZXhlcy5ob3VyMTJCYXNlMSA+IC0xKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgdmFsID0gcGFyc2VJbnQobWF0Y2hlc1twYXJzZWRJbmRleGVzLmhvdXIxMkJhc2UxXSk7XHJcbiAgICAgICAgICAgICAgICBpZiAodmFsID09IDEyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsID0gMDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICgocGFyc2VkSW5kZXhlcy5hbSA+IC0xKSAmJiAhdGhpcy5pc0FtKG1hdGNoZXNbcGFyc2VkSW5kZXhlcy5hbV0pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsICs9IDEyO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmVzVmFsdWVzLmhvdXIgPSB2YWw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gTWludXRlXHJcbiAgICAgICAgICAgIGlmIChwYXJzZWRJbmRleGVzLm1pbnV0ZSA+IC0xKSB7XHJcbiAgICAgICAgICAgICAgICByZXNWYWx1ZXMubWludXRlID0gcGFyc2VJbnQobWF0Y2hlc1twYXJzZWRJbmRleGVzLm1pbnV0ZV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIFNlY29uZFxyXG4gICAgICAgICAgICBpZiAocGFyc2VkSW5kZXhlcy5zZWNvbmQgPiAtMSkge1xyXG4gICAgICAgICAgICAgICAgcmVzVmFsdWVzLnNlY29uZCA9IHBhcnNlSW50KG1hdGNoZXNbcGFyc2VkSW5kZXhlcy5zZWNvbmRdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBNaWxsaXNlY29uZFxyXG4gICAgICAgICAgICBpZiAocGFyc2VkSW5kZXhlcy5taWxsaXNlY29uZCA+IC0xKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgdmFsID0gcGFyc2VJbnQobWF0Y2hlc1twYXJzZWRJbmRleGVzLm1pbGxpc2Vjb25kXSk7XHJcbiAgICAgICAgICAgICAgICBpZiAocGFyc2VkSW5kZXhlcy5taWxsaXNlY29uZERpZ2l0cyA9PSAyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsICo9IDEwO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocGFyc2VkSW5kZXhlcy5taWxsaXNlY29uZERpZ2l0cyA9PSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsICo9IDEwMDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJlc1ZhbHVlcy5taWxsaXNlY29uZCA9IHZhbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBUaW1lc3RhbXBcclxuICAgICAgICAgICAgaWYgKHBhcnNlZEluZGV4ZXMudGltZXN0YW1wID4gLTEpIHtcclxuICAgICAgICAgICAgICAgIHJlc1ZhbHVlcy50aW1lc3RhbXAgPSBwYXJzZUludChtYXRjaGVzW3BhcnNlZEluZGV4ZXMudGltZXN0YW1wXSk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB0cyA9IG5ldyBEYXRlKHJlc1ZhbHVlcy50aW1lc3RhbXApO1xyXG4gICAgICAgICAgICAgICAgcmVzVmFsdWVzLnllYXIgPSB0cy5nZXRVVENGdWxsWWVhcigpO1xyXG4gICAgICAgICAgICAgICAgcmVzVmFsdWVzLm1vbnRoID0gdHMuZ2V0VVRDTW9udGgoKTtcclxuICAgICAgICAgICAgICAgIHJlc1ZhbHVlcy5kYXkgPSB0cy5nZXRVVENEYXRlKCk7XHJcbiAgICAgICAgICAgICAgICByZXNWYWx1ZXMuaG91ciA9IHRzLmdldFVUQ0hvdXJzKCk7XHJcbiAgICAgICAgICAgICAgICByZXNWYWx1ZXMubWludXRlID0gdHMuZ2V0VVRDTWludXRlcygpO1xyXG4gICAgICAgICAgICAgICAgcmVzVmFsdWVzLnNlY29uZCA9IHRzLmdldFVUQ1NlY29uZHMoKTtcclxuICAgICAgICAgICAgICAgIHJlc1ZhbHVlcy5taWxsaXNlY29uZCA9IHRzLmdldFVUQ01pbGxpc2Vjb25kcygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIEFkanVzdCB0aW1lIHpvbmVcclxuICAgICAgICAgICAgaWYgKHBhcnNlZEluZGV4ZXMuem9uZSA+IC0xKSB7XHJcbiAgICAgICAgICAgICAgICByZXNWYWx1ZXMub2Zmc2V0ID0gdGhpcy5yZXNvbHZlVGltZXpvbmVPZmZzZXQobmV3IERhdGUocmVzVmFsdWVzLnllYXIsIHJlc1ZhbHVlcy5tb250aCwgcmVzVmFsdWVzLmRheSksIG1hdGNoZXNbcGFyc2VkSW5kZXhlcy56b25lXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gSVNPXHJcbiAgICAgICAgICAgIGlmIChwYXJzZWRJbmRleGVzLmlzbyA+IC0xKSB7XHJcbiAgICAgICAgICAgICAgICByZXNWYWx1ZXMueWVhciA9ICR0eXBlLnRvTnVtYmVyKG1hdGNoZXNbcGFyc2VkSW5kZXhlcy5pc28gKyAwXSk7XHJcbiAgICAgICAgICAgICAgICByZXNWYWx1ZXMubW9udGggPSAkdHlwZS50b051bWJlcihtYXRjaGVzW3BhcnNlZEluZGV4ZXMuaXNvICsgMV0pIC0gMTtcclxuICAgICAgICAgICAgICAgIHJlc1ZhbHVlcy5kYXkgPSAkdHlwZS50b051bWJlcihtYXRjaGVzW3BhcnNlZEluZGV4ZXMuaXNvICsgMl0pO1xyXG4gICAgICAgICAgICAgICAgcmVzVmFsdWVzLmhvdXIgPSAkdHlwZS50b051bWJlcihtYXRjaGVzW3BhcnNlZEluZGV4ZXMuaXNvICsgM10pO1xyXG4gICAgICAgICAgICAgICAgcmVzVmFsdWVzLm1pbnV0ZSA9ICR0eXBlLnRvTnVtYmVyKG1hdGNoZXNbcGFyc2VkSW5kZXhlcy5pc28gKyA0XSk7XHJcbiAgICAgICAgICAgICAgICByZXNWYWx1ZXMuc2Vjb25kID0gJHR5cGUudG9OdW1iZXIobWF0Y2hlc1twYXJzZWRJbmRleGVzLmlzbyArIDVdKTtcclxuICAgICAgICAgICAgICAgIHJlc1ZhbHVlcy5taWxsaXNlY29uZCA9ICR0eXBlLnRvTnVtYmVyKG1hdGNoZXNbcGFyc2VkSW5kZXhlcy5pc28gKyA2XSk7XHJcbiAgICAgICAgICAgICAgICBpZiAobWF0Y2hlc1twYXJzZWRJbmRleGVzLmlzbyArIDddID09IFwiWlwiIHx8IG1hdGNoZXNbcGFyc2VkSW5kZXhlcy5pc28gKyA3XSA9PSBcInpcIikge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc1ZhbHVlcy51dGMgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobWF0Y2hlc1twYXJzZWRJbmRleGVzLmlzbyArIDddICE9IFwiXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXNWYWx1ZXMub2Zmc2V0ID0gdGhpcy5yZXNvbHZlVGltZXpvbmVPZmZzZXQobmV3IERhdGUocmVzVmFsdWVzLnllYXIsIHJlc1ZhbHVlcy5tb250aCwgcmVzVmFsdWVzLmRheSksIG1hdGNoZXNbcGFyc2VkSW5kZXhlcy5pc28gKyA3XSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gQ3JlYXRlIERhdGUgb2JqZWN0XHJcbiAgICAgICAgICAgIGlmIChyZXNWYWx1ZXMudXRjKSB7XHJcbiAgICAgICAgICAgICAgICByZXMgPSBuZXcgRGF0ZShEYXRlLlVUQyhyZXNWYWx1ZXMueWVhciwgcmVzVmFsdWVzLm1vbnRoLCByZXNWYWx1ZXMuZGF5LCByZXNWYWx1ZXMuaG91ciwgcmVzVmFsdWVzLm1pbnV0ZSwgcmVzVmFsdWVzLnNlY29uZCwgcmVzVmFsdWVzLm1pbGxpc2Vjb25kKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXMgPSBuZXcgRGF0ZShyZXNWYWx1ZXMueWVhciwgcmVzVmFsdWVzLm1vbnRoLCByZXNWYWx1ZXMuZGF5LCByZXNWYWx1ZXMuaG91ciwgcmVzVmFsdWVzLm1pbnV0ZSArIHJlc1ZhbHVlcy5vZmZzZXQsIHJlc1ZhbHVlcy5zZWNvbmQsIHJlc1ZhbHVlcy5taWxsaXNlY29uZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIERpZG4ndCBtYXRjaCBhbnl0aGluZ1xyXG4gICAgICAgICAgICAvLyBMZXQncyB0cnkgZHJvcHBpbmcgaXQgaW50byBEYXRlIGNvbnN0cnVjdG9yIGFuZCBob3BlIGZvciB0aGUgYmVzdFxyXG4gICAgICAgICAgICByZXMgPSBuZXcgRGF0ZShzb3VyY2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgfVxyXG4gICAgcmVzb2x2ZVRpbWV6b25lT2Zmc2V0KGRhdGUsIHpvbmUpIHtcclxuICAgICAgICBsZXQgdmFsdWUgPSB6b25lLm1hdGNoKC8oWytcXC1dPykoWzAtOV17Mn0pOj8oWzAtOV17Mn0pLyk7XHJcbiAgICAgICAgaWYgKHZhbHVlKSB7XHJcbiAgICAgICAgICAgIGxldCBtYXRjaCA9IHpvbmUubWF0Y2goLyhbK1xcLV0/KShbMC05XXsyfSk6PyhbMC05XXsyfSkvKTtcclxuICAgICAgICAgICAgbGV0IGRpciA9IG1hdGNoWzFdO1xyXG4gICAgICAgICAgICBsZXQgaG91ciA9IG1hdGNoWzJdO1xyXG4gICAgICAgICAgICBsZXQgbWludXRlID0gbWF0Y2hbM107XHJcbiAgICAgICAgICAgIGxldCBvZmZzZXQgPSBwYXJzZUludChob3VyKSAqIDYwICsgcGFyc2VJbnQobWludXRlKTtcclxuICAgICAgICAgICAgLy8gQWRqdXN0IG9mZnNldFxyXG4gICAgICAgICAgICAvLyBNYWtpbmcgaXQgbmVnYXRpdmUgZG9lcyBub3Qgc2VlbSB0byBtYWtlIHNlbnNlLCBidXQgaXQncyByaWdodFxyXG4gICAgICAgICAgICAvLyBiZWNhdXNlIG9mIGhvdyBKYXZhU2NyaXB0IGNhbGN1bGF0ZXMgR01UIG9mZnNldHNcclxuICAgICAgICAgICAgaWYgKGRpciA9PSBcIitcIikge1xyXG4gICAgICAgICAgICAgICAgb2Zmc2V0ICo9IC0xO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIENoZWNrIHRoZSBkaWZmZXJlbmNlIGluIG9mZnNldFxyXG4gICAgICAgICAgICBsZXQgb3JpZ2luYWxPZmZzZXQgPSAoZGF0ZSB8fCBuZXcgRGF0ZSgpKS5nZXRUaW1lem9uZU9mZnNldCgpO1xyXG4gICAgICAgICAgICBsZXQgZGlmZiA9IG9mZnNldCAtIG9yaWdpbmFsT2Zmc2V0O1xyXG4gICAgICAgICAgICByZXR1cm4gZGlmZjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIDA7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJlc29sdmVzIG1vbnRoIG5hbWUgKGkuZS4gXCJEZWNlbWJlclwiKSBpbnRvIGEgbW9udGggbnVtYmVyICgxMSkuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHZhbHVlICBNb250aCBuYW1lXHJcbiAgICAgKiBAcmV0dXJuIE1vbnRoIG51bWJlclxyXG4gICAgICovXHJcbiAgICByZXNvbHZlTW9udGgodmFsdWUpIHtcclxuICAgICAgICAvLyBMZXQncyB0cnkgRW5nbGlzaCBmaXJzdFxyXG4gICAgICAgIGxldCBtb250aCA9IHRoaXMuX21vbnRocygpLmluZGV4T2YodmFsdWUpO1xyXG4gICAgICAgIGlmIChtb250aCA+IC0xKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBtb250aDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gVHJ5IHRoZSB0cmFuc2xhdGlvblxyXG4gICAgICAgIGlmICghdGhpcy5fcm9vdC5sYW5ndWFnZS5pc0RlZmF1bHQoKSkge1xyXG4gICAgICAgICAgICBtb250aCA9IHRoaXMuX3Jvb3QubGFuZ3VhZ2UudHJhbnNsYXRlQWxsKHRoaXMuX21vbnRocygpKS5pbmRleE9mKHZhbHVlKTtcclxuICAgICAgICAgICAgaWYgKG1vbnRoID4gLTEpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBtb250aDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gMDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmVzb2x2ZXMgc2hvcnQgbW9udGggbmFtZSAoaS5lLiBcIkRlY1wiKSBpbnRvIGEgbW9udGggbnVtYmVyLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB2YWx1ZSAgU2hvcnQgbW9udGggbmFtZVxyXG4gICAgICogQHJldHVybiBNb250aCBudW1iZXJcclxuICAgICAqL1xyXG4gICAgcmVzb2x2ZVNob3J0TW9udGgodmFsdWUpIHtcclxuICAgICAgICAvLyBMZXQncyB0cnkgRW5nbGlzaCBmaXJzdFxyXG4gICAgICAgIGxldCBtb250aCA9IHRoaXMuX3Nob3J0TW9udGhzKCkuaW5kZXhPZih2YWx1ZSk7XHJcbiAgICAgICAgaWYgKG1vbnRoID4gLTEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG1vbnRoO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBNYXliZSBsb25nIG1vbnRoICh3b3JrYXJvdW5kIGZvciBNYXkpXHJcbiAgICAgICAgbW9udGggPSB0aGlzLl9tb250aHMoKS5pbmRleE9mKHZhbHVlKTtcclxuICAgICAgICBpZiAobW9udGggPiAtMSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbW9udGg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFRyeSB0aGUgdHJhbnNsYXRpb25cclxuICAgICAgICBpZiAodGhpcy5fcm9vdC5sYW5ndWFnZSAmJiAhdGhpcy5fcm9vdC5sYW5ndWFnZS5pc0RlZmF1bHQoKSkge1xyXG4gICAgICAgICAgICBtb250aCA9IHRoaXMuX3Jvb3QubGFuZ3VhZ2UudHJhbnNsYXRlQWxsKHRoaXMuX3Nob3J0TW9udGhzKCkpLmluZGV4T2YodmFsdWUpO1xyXG4gICAgICAgICAgICBpZiAobW9udGggPiAtMSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG1vbnRoO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAwO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDaGVja3MgaWYgcGFzc2VkIGluIHN0cmluZyByZXByZXNlbnRzIEFNL1BNIG5vdGF0aW9uIGluIG1hbnkgb2YgaXRzXHJcbiAgICAgKiB2ZXJzaW9ucy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gdmFsdWUgIFNvdXJjZSBzdHJpbmdcclxuICAgICAqIEByZXR1cm4gSXMgaXQgQU0vUE0/XHJcbiAgICAgKi9cclxuICAgIGlzQW0odmFsdWUpIHtcclxuICAgICAgICBsZXQgbGlzdCA9IHRoaXMuZ2V0U3RyaW5nTGlzdChbXCJBTVwiLCBcIkEuTS5cIiwgXCJBXCJdKTtcclxuICAgICAgICByZXR1cm4gbGlzdC5pbmRleE9mKHZhbHVlLnRvVXBwZXJDYXNlKCkpID4gLTE7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRyYW5zbGF0ZXMgbGlzdCBvZiBzdHJpbmdzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBsaXN0ICBTb3VyY2Ugc3RyaW5nc1xyXG4gICAgICogQHJldHVybiBUcmFuc2xhdGVkIHN0cmluZ3NcclxuICAgICAqL1xyXG4gICAgZ2V0U3RyaW5nTGlzdChsaXN0KSB7XHJcbiAgICAgICAgbGV0IHJlcyA9IFtdO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAvLyB0cmFuc2xhdGU/XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9yb290Lmxhbmd1YWdlKSB7XHJcbiAgICAgICAgICAgICAgICByZXMucHVzaCgkdXRpbHMuZXNjYXBlRm9yUmdleCh0aGlzLl90KGxpc3RbaV0pKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXMucHVzaCgkdXRpbHMuZXNjYXBlRm9yUmdleChsaXN0W2ldKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlcztcclxuICAgIH1cclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1EYXRlRm9ybWF0dGVyLmpzLm1hcCIsIi8qKlxyXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAqIElNUE9SVFNcclxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4gKiBAaGlkZGVuXHJcbiAqL1xyXG5pbXBvcnQgKiBhcyAkYXJyYXkgZnJvbSBcIi4vQXJyYXlcIjtcclxuLyoqXHJcbiAqIEEgYmFzZSBjbGFzcyBmb3IgZGlzcG9zYWJsZSBvYmplY3RzLlxyXG4gKlxyXG4gKiBAaWdub3JlIEV4Y2x1ZGUgZnJvbSBkb2NzXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgRGlzcG9zZXJDbGFzcyB7XHJcbiAgICAvKipcclxuICAgICAqIENvbnN0cnVjdG9yLlxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBJcyBvYmplY3QgZGlzcG9zZWQ/XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX2Rpc3Bvc2VkXCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuX2Rpc3Bvc2VkID0gZmFsc2U7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENoZWNrcyBpZiBvYmplY3QgaXMgZGlzcG9zZWQuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybiBEaXNwb3NlZD9cclxuICAgICAqL1xyXG4gICAgaXNEaXNwb3NlZCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZGlzcG9zZWQ7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIERpc3Bvc2VzIHRoZSBvYmplY3QuXHJcbiAgICAgKi9cclxuICAgIGRpc3Bvc2UoKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9kaXNwb3NlZCkge1xyXG4gICAgICAgICAgICB0aGlzLl9kaXNwb3NlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMuX2Rpc3Bvc2UoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEEgY2xhc3MgZm9yIGNyZWF0aW5nIGFuIElEaXNwb3Nlci5cclxuICpcclxuICogQGlnbm9yZSBFeGNsdWRlIGZyb20gZG9jc1xyXG4gKi9cclxuZXhwb3J0IGNsYXNzIERpc3Bvc2VyIHtcclxuICAgIC8qKlxyXG4gICAgICogQ29uc3RydWN0b3IuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGRpc3Bvc2UgIEZ1bmN0aW9uIHRoYXQgZGlzcG9zZXMgb2JqZWN0XHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKGRpc3Bvc2UpIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBJcyBvYmplY3QgZGlzcG9zZWQ/XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX2Rpc3Bvc2VkXCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIE1ldGhvZCB0aGF0IGRpc3Bvc2VzIHRoZSBvYmplY3QuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX2Rpc3Bvc2VcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5fZGlzcG9zZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl9kaXNwb3NlID0gZGlzcG9zZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ2hlY2tzIGlmIG9iamVjdCBpcyBkaXNwb3NlZC5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJuIERpc3Bvc2VkP1xyXG4gICAgICovXHJcbiAgICBpc0Rpc3Bvc2VkKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9kaXNwb3NlZDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRGlzcG9zZXMgdGhlIG9iamVjdC5cclxuICAgICAqL1xyXG4gICAgZGlzcG9zZSgpIHtcclxuICAgICAgICBpZiAoIXRoaXMuX2Rpc3Bvc2VkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2Rpc3Bvc2VkID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy5fZGlzcG9zZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4vKipcclxuICogVGhpcyBjYW4gYmUgZXh0ZW5kZWQgYnkgb3RoZXIgY2xhc3NlcyB0byBhZGQgYSBgX2Rpc3Bvc2Vyc2AgcHJvcGVydHkuXHJcbiAqXHJcbiAqIEBpZ25vcmUgRXhjbHVkZSBmcm9tIGRvY3NcclxuICovXHJcbmV4cG9ydCBjbGFzcyBBcnJheURpc3Bvc2VyIGV4dGVuZHMgRGlzcG9zZXJDbGFzcyB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9kaXNwb3NlcnNcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogW11cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIF9kaXNwb3NlKCkge1xyXG4gICAgICAgICRhcnJheS5lYWNoKHRoaXMuX2Rpc3Bvc2VycywgKHgpID0+IHtcclxuICAgICAgICAgICAgeC5kaXNwb3NlKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEEgY29sbGVjdGlvbiBvZiByZWxhdGVkIGRpc3Bvc2VycyB0aGF0IGNhbiBiZSBkaXNwb3NlZCBpbiBvbmUgZ28uXHJcbiAqXHJcbiAqIEBpZ25vcmUgRXhjbHVkZSBmcm9tIGRvY3NcclxuICovXHJcbmV4cG9ydCBjbGFzcyBNdWx0aURpc3Bvc2VyIGV4dGVuZHMgRGlzcG9zZXJDbGFzcyB7XHJcbiAgICBjb25zdHJ1Y3RvcihkaXNwb3NlcnMpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9kaXNwb3NlcnNcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5fZGlzcG9zZXJzID0gZGlzcG9zZXJzO1xyXG4gICAgfVxyXG4gICAgX2Rpc3Bvc2UoKSB7XHJcbiAgICAgICAgJGFycmF5LmVhY2godGhpcy5fZGlzcG9zZXJzLCAoeCkgPT4ge1xyXG4gICAgICAgICAgICB4LmRpc3Bvc2UoKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGdldCBkaXNwb3NlcnMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Rpc3Bvc2VycztcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQSBzcGVjaWFsIGtpbmQgb2YgRGlzcG9zZXIgdGhhdCBoYXMgYXR0YWNoZWQgdmFsdWUgc2V0LlxyXG4gKlxyXG4gKiBJZiBhIG5ldyB2YWx1ZSBpcyBzZXQgdXNpbmcgYHNldCgpYCBtZXRob2QsIHRoZSBvbGQgZGlzcG9zZXIgdmFsdWUgaXNcclxuICogZGlzcG9zZWQuXHJcbiAqXHJcbiAqIEBpZ25vcmUgRXhjbHVkZSBmcm9tIGRvY3NcclxuICogQHRvZG8gRGVzY3JpcHRpb25cclxuICovXHJcbmV4cG9ydCBjbGFzcyBNdXRhYmxlVmFsdWVEaXNwb3NlciBleHRlbmRzIERpc3Bvc2VyQ2xhc3Mge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDdXJyZW50IGRpc3Bvc2VyLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9kaXNwb3NlclwiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcclxuICAgICAgICB9KTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDdXJyZW50IHZhbHVlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl92YWx1ZVwiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIF9kaXNwb3NlKCkge1xyXG4gICAgICAgIGlmICh0aGlzLl9kaXNwb3NlciAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2Rpc3Bvc2VyLmRpc3Bvc2UoKTtcclxuICAgICAgICAgICAgdGhpcy5fZGlzcG9zZXIgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGN1cnJlbnQgdmFsdWUuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybiBWYWx1ZVxyXG4gICAgICovXHJcbiAgICBnZXQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ZhbHVlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHZhbHVlIGFuZCBkaXNwb3NlcyBwcmV2aW91cyBkaXNwb3NlciBpZiBpdCB3YXMgc2V0LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB2YWx1ZSAgICAgTmV3IHZhbHVlXHJcbiAgICAgKiBAcGFyYW0gZGlzcG9zZXIgIERpc3Bvc2VyXHJcbiAgICAgKi9cclxuICAgIHNldCh2YWx1ZSwgZGlzcG9zZXIpIHtcclxuICAgICAgICBpZiAodGhpcy5fZGlzcG9zZXIgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aGlzLl9kaXNwb3Nlci5kaXNwb3NlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2Rpc3Bvc2VyID0gZGlzcG9zZXI7XHJcbiAgICAgICAgdGhpcy5fdmFsdWUgPSB2YWx1ZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmVzZXRzIHRoZSBkaXNwb3NlciB2YWx1ZS5cclxuICAgICAqL1xyXG4gICAgcmVzZXQoKSB7XHJcbiAgICAgICAgdGhpcy5zZXQodW5kZWZpbmVkLCB1bmRlZmluZWQpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBAaWdub3JlIEV4Y2x1ZGUgZnJvbSBkb2NzXHJcbiAqIEB0b2RvIERlc2NyaXB0aW9uXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgQ291bnRlckRpc3Bvc2VyIGV4dGVuZHMgRGlzcG9zZXIge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBbX2NvdW50ZXIgZGVzY3JpcHRpb25dXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAdG9kbyBEZXNjcmlwdGlvblxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9jb3VudGVyXCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IDBcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogW2luY3JlbWVudCBkZXNjcmlwdGlvbl1cclxuICAgICAqXHJcbiAgICAgKiBAdG9kbyBEZXNjcmlwdGlvblxyXG4gICAgICovXHJcbiAgICBpbmNyZW1lbnQoKSB7XHJcbiAgICAgICAgLy8gVE9ETyB0aHJvdyBhbiBlcnJvciBpZiBpdCBpcyBkaXNwb3NlZFxyXG4gICAgICAgICsrdGhpcy5fY291bnRlcjtcclxuICAgICAgICAvLyBUT0RPIG1ha2UgdGhpcyBtb3JlIGVmZmljaWVudFxyXG4gICAgICAgIHJldHVybiBuZXcgRGlzcG9zZXIoKCkgPT4ge1xyXG4gICAgICAgICAgICAtLXRoaXMuX2NvdW50ZXI7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9jb3VudGVyID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3Bvc2UoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPURpc3Bvc2VyLmpzLm1hcCIsIi8qKiBAaWdub3JlICovIC8qKiAqL1xyXG5pbXBvcnQgKiBhcyAkbWF0aCBmcm9tIFwiLi9NYXRoXCI7XHJcbi8qKlxyXG4gKiBAaWdub3JlXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gc2VnbWVudGVkTGluZShkaXNwbGF5LCBzZWdtZW50cykge1xyXG4gICAgZm9yIChsZXQgcyA9IDAsIGxlbiA9IHNlZ21lbnRzLmxlbmd0aDsgcyA8IGxlbjsgcysrKSB7XHJcbiAgICAgICAgY29uc3QgZ3JvdXBzID0gc2VnbWVudHNbc107XHJcbiAgICAgICAgaWYgKGdyb3Vwcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIGxldCBmaXJzdEdyb3VwID0gZ3JvdXBzWzBdO1xyXG4gICAgICAgICAgICBpZiAoZmlyc3RHcm91cC5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgZmlyc3RQb2ludCA9IGZpcnN0R3JvdXBbMF07XHJcbiAgICAgICAgICAgICAgICBkaXNwbGF5Lm1vdmVUbyhmaXJzdFBvaW50LngsIGZpcnN0UG9pbnQueSk7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBnID0gMCwgbGVuID0gZ3JvdXBzLmxlbmd0aDsgZyA8IGxlbjsgZysrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGluZShkaXNwbGF5LCBncm91cHNbZ10pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBAaWdub3JlXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gbGluZShkaXNwbGF5LCBwb2ludHMpIHtcclxuICAgIGZvciAobGV0IHAgPSAwLCBsZW4gPSBwb2ludHMubGVuZ3RoOyBwIDwgbGVuOyBwKyspIHtcclxuICAgICAgICBjb25zdCBwb2ludCA9IHBvaW50c1twXTtcclxuICAgICAgICBkaXNwbGF5LmxpbmVUbyhwb2ludC54LCBwb2ludC55KTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQGlnbm9yZVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIG1vdmVUbyhkaXNwbGF5LCBwb2ludCkge1xyXG4gICAgZGlzcGxheS5tb3ZlVG8ocG9pbnQueCwgcG9pbnQueSk7XHJcbn1cclxuLyoqXHJcbiAqIEBpZ25vcmVcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBjbGVhcihkaXNwbGF5KSB7XHJcbiAgICBkaXNwbGF5LmNsZWFyKCk7XHJcbn1cclxuLyoqXHJcbiAqIEBpZ25vcmVcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBzbW9vdGhlZFNlZ21lbnRlZGxpbmUoZGlzcGxheSwgc2VnbWVudHMsIHRlbnNpb25YLCB0ZW5zaW9uWSkge1xyXG4gICAgZm9yIChsZXQgcyA9IDAsIGxlbiA9IHNlZ21lbnRzLmxlbmd0aDsgcyA8IGxlbjsgcysrKSB7XHJcbiAgICAgICAgY29uc3QgZ3JvdXBzID0gc2VnbWVudHNbc107XHJcbiAgICAgICAgaWYgKGdyb3Vwcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIGxldCBmaXJzdEdyb3VwID0gZ3JvdXBzWzBdO1xyXG4gICAgICAgICAgICBpZiAoZmlyc3RHcm91cC5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgZmlyc3RQb2ludCA9IGZpcnN0R3JvdXBbMF07XHJcbiAgICAgICAgICAgICAgICBkaXNwbGF5Lm1vdmVUbyhmaXJzdFBvaW50LngsIGZpcnN0UG9pbnQueSk7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBnID0gMCwgbGVuID0gZ3JvdXBzLmxlbmd0aDsgZyA8IGxlbjsgZysrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcG9pbnRzID0gZ3JvdXBzW2ddO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChwb2ludHMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNwbGF5LmxpbmVUbyhwb2ludHNbMF0ueCwgcG9pbnRzWzBdLnkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBzbW9vdGhlZExpbmUoZGlzcGxheSwgcG9pbnRzLCB0ZW5zaW9uWCwgdGVuc2lvblkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBAaWdub3JlXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gc21vb3RoZWRMaW5lKGRpc3BsYXksIHBvaW50cywgdGVuc2lvblgsIHRlbnNpb25ZKSB7XHJcbiAgICBmb3IgKGxldCBpID0gcG9pbnRzLmxlbmd0aCAtIDE7IGkgPiAwOyBpLS0pIHtcclxuICAgICAgICBsZXQgcDAgPSBwb2ludHNbaV07XHJcbiAgICAgICAgbGV0IHAxID0gcG9pbnRzW2kgLSAxXTtcclxuICAgICAgICBpZiAoTWF0aC5hYnMocDAueCAtIHAxLngpIDwgMC4xICYmIE1hdGguYWJzKHAwLnkgLSBwMS55KSA8IDAuMSkge1xyXG4gICAgICAgICAgICBwb2ludHMuc3BsaWNlKGkgLSAxLCAxKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAocG9pbnRzLmxlbmd0aCA8IDMgfHwgKHRlbnNpb25YID49IDEgJiYgdGVuc2lvblkgPj0gMSkpIHtcclxuICAgICAgICBsaW5lKGRpc3BsYXksIHBvaW50cyk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgdGVuc2lvblggPSAxIC0gdGVuc2lvblggKyAwLjAwMDAxO1xyXG4gICAgdGVuc2lvblkgPSAxIC0gdGVuc2lvblkgKyAwLjAwMDAxO1xyXG4gICAgbGV0IGZpcnN0ID0gcG9pbnRzWzBdO1xyXG4gICAgbGV0IGxhc3QgPSBwb2ludHNbcG9pbnRzLmxlbmd0aCAtIDFdO1xyXG4gICAgbGV0IGNsb3NlZCA9IGZhbHNlO1xyXG4gICAgaWYgKCRtYXRoLnJvdW5kKGZpcnN0LngsIDMpID09ICRtYXRoLnJvdW5kKGxhc3QueCkgJiYgJG1hdGgucm91bmQoZmlyc3QueSkgPT0gJG1hdGgucm91bmQobGFzdC55KSkge1xyXG4gICAgICAgIGNsb3NlZCA9IHRydWU7XHJcbiAgICB9XHJcbiAgICAvLyBDYW4ndCBtb3ZlVG8gaGVyZSwgYXMgaXQgd29udCBiZSBwb3NzaWJsZSB0byBoYXZlIGZpbGwgdGhlbi5cclxuICAgIGxldCBwYXRoID0gXCJcIjtcclxuICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBwb2ludHMubGVuZ3RoIC0gMTsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgbGV0IHAwID0gcG9pbnRzW2kgLSAxXTtcclxuICAgICAgICBsZXQgcDEgPSBwb2ludHNbaV07XHJcbiAgICAgICAgbGV0IHAyID0gcG9pbnRzW2kgKyAxXTtcclxuICAgICAgICBsZXQgcDMgPSBwb2ludHNbaSArIDJdO1xyXG4gICAgICAgIGlmIChpID09PSAwKSB7XHJcbiAgICAgICAgICAgIGlmIChjbG9zZWQpIHtcclxuICAgICAgICAgICAgICAgIHAwID0gcG9pbnRzW2xlbiAtIDJdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcDAgPSBwb2ludHNbMF07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoaSA9PSBsZW4gLSAxKSB7XHJcbiAgICAgICAgICAgIGlmIChjbG9zZWQpIHtcclxuICAgICAgICAgICAgICAgIHAzID0gcG9pbnRzWzFdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcDMgPSBwMjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgY29udHJvbFBvaW50QSA9ICRtYXRoLmdldEN1YmljQ29udHJvbFBvaW50QShwMCwgcDEsIHAyLCB0ZW5zaW9uWCwgdGVuc2lvblkpO1xyXG4gICAgICAgIGxldCBjb250cm9sUG9pbnRCID0gJG1hdGguZ2V0Q3ViaWNDb250cm9sUG9pbnRCKHAxLCBwMiwgcDMsIHRlbnNpb25YLCB0ZW5zaW9uWSk7XHJcbiAgICAgICAgZGlzcGxheS5iZXppZXJDdXJ2ZVRvKGNvbnRyb2xQb2ludEEueCwgY29udHJvbFBvaW50QS55LCBjb250cm9sUG9pbnRCLngsIGNvbnRyb2xQb2ludEIueSwgcDIueCwgcDIueSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcGF0aDtcclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1EcmF3LmpzLm1hcCIsImltcG9ydCB7IEVudGl0eSB9IGZyb20gXCIuL0VudGl0eVwiO1xyXG5pbXBvcnQgeyBUZXh0Rm9ybWF0dGVyIH0gZnJvbSBcIi4vVGV4dEZvcm1hdHRlclwiO1xyXG5pbXBvcnQgKiBhcyAkb2JqZWN0IGZyb20gXCIuL09iamVjdFwiO1xyXG5pbXBvcnQgKiBhcyAkdXRpbHMgZnJvbSBcIi4vVXRpbHNcIjtcclxuaW1wb3J0ICogYXMgJHR5cGUgZnJvbSBcIi4vVHlwZVwiO1xyXG4vKipcclxuICogQSBjbGFzcyB1c2VkIHRvIGZvcm1hdCBudW1iZXJpYyB2YWx1ZXMgYXMgdGltZSBkdXJhdGlvbi5cclxuICpcclxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly93d3cuYW1jaGFydHMuY29tL2RvY3MvdjUvY29uY2VwdHMvZm9ybWF0dGVycy9mb3JtYXR0aW5nLWR1cmF0aW9ucy99IGZvciBtb3JlIGluZm9cclxuICovXHJcbmV4cG9ydCBjbGFzcyBEdXJhdGlvbkZvcm1hdHRlciBleHRlbmRzIEVudGl0eSB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENvbGxlY3Rpb24gb2YgYWxpYXNlcyBmb3IgdW5pdHMuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX3VuaXRBbGlhc2VzXCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IHtcclxuICAgICAgICAgICAgICAgIFwiWVwiOiBcInlcIixcclxuICAgICAgICAgICAgICAgIFwiRFwiOiBcImRcIixcclxuICAgICAgICAgICAgICAgIFwiSFwiOiBcImhcIixcclxuICAgICAgICAgICAgICAgIFwiS1wiOiBcImhcIixcclxuICAgICAgICAgICAgICAgIFwia1wiOiBcImhcIixcclxuICAgICAgICAgICAgICAgIFwiblwiOiBcIlNcIlxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBfc2V0RGVmYXVsdHMoKSB7XHJcbiAgICAgICAgY29uc3QgZG1pbGxpc2Vjb25kID0gXCJfZHVyYXRpb25fbWlsbGlzZWNvbmRcIjtcclxuICAgICAgICBjb25zdCBkc2Vjb25kID0gXCJfZHVyYXRpb25fc2Vjb25kXCI7XHJcbiAgICAgICAgY29uc3QgZG1pbnV0ZSA9IFwiX2R1cmF0aW9uX21pbnV0ZVwiO1xyXG4gICAgICAgIGNvbnN0IGRob3VyID0gXCJfZHVyYXRpb25faG91clwiO1xyXG4gICAgICAgIGNvbnN0IGRkYXkgPSBcIl9kdXJhdGlvbl9kYXlcIjtcclxuICAgICAgICBjb25zdCBkd2VlayA9IFwiX2R1cmF0aW9uX3dlZWtcIjtcclxuICAgICAgICBjb25zdCBkbW9udGggPSBcIl9kdXJhdGlvbl9tb250aFwiO1xyXG4gICAgICAgIGNvbnN0IGR5ZWFyID0gXCJfZHVyYXRpb25feWVhclwiO1xyXG4gICAgICAgIGNvbnN0IGFzZWNvbmQgPSBcIl9zZWNvbmRcIjtcclxuICAgICAgICBjb25zdCBhbWludXRlID0gXCJfbWludXRlXCI7XHJcbiAgICAgICAgY29uc3QgYWhvdXIgPSBcIl9ob3VyXCI7XHJcbiAgICAgICAgY29uc3QgYWRheSA9IFwiX2RheVwiO1xyXG4gICAgICAgIGNvbnN0IGF3ZWVrID0gXCJfd2Vla1wiO1xyXG4gICAgICAgIGNvbnN0IGFtb250aCA9IFwiX3dlZWtcIjtcclxuICAgICAgICBjb25zdCBheWVhciA9IFwiX3llYXJcIjtcclxuICAgICAgICAvLyBEZWZhdWx0c1xyXG4gICAgICAgIHRoaXMuX3NldERlZmF1bHQoXCJuZWdhdGl2ZUJhc2VcIiwgMCk7XHJcbiAgICAgICAgdGhpcy5fc2V0RGVmYXVsdChcImJhc2VVbml0XCIsIFwic2Vjb25kXCIpO1xyXG4gICAgICAgIHRoaXMuX3NldERlZmF1bHQoXCJkdXJhdGlvbkZvcm1hdHNcIiwge1xyXG4gICAgICAgICAgICBcIm1pbGxpc2Vjb25kXCI6IHtcclxuICAgICAgICAgICAgICAgIFwibWlsbGlzZWNvbmRcIjogdGhpcy5fdChkbWlsbGlzZWNvbmQpLFxyXG4gICAgICAgICAgICAgICAgXCJzZWNvbmRcIjogdGhpcy5fdCgoZG1pbGxpc2Vjb25kICsgYXNlY29uZCkpLFxyXG4gICAgICAgICAgICAgICAgXCJtaW51dGVcIjogdGhpcy5fdCgoZG1pbGxpc2Vjb25kICsgYW1pbnV0ZSkpLFxyXG4gICAgICAgICAgICAgICAgXCJob3VyXCI6IHRoaXMuX3QoKGRtaWxsaXNlY29uZCArIGFob3VyKSksXHJcbiAgICAgICAgICAgICAgICBcImRheVwiOiB0aGlzLl90KChkbWlsbGlzZWNvbmQgKyBhZGF5KSksXHJcbiAgICAgICAgICAgICAgICBcIndlZWtcIjogdGhpcy5fdCgoZG1pbGxpc2Vjb25kICsgYXdlZWspKSxcclxuICAgICAgICAgICAgICAgIFwibW9udGhcIjogdGhpcy5fdCgoZG1pbGxpc2Vjb25kICsgYW1vbnRoKSksXHJcbiAgICAgICAgICAgICAgICBcInllYXJcIjogdGhpcy5fdCgoZG1pbGxpc2Vjb25kICsgYXllYXIpKVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBcInNlY29uZFwiOiB7XHJcbiAgICAgICAgICAgICAgICBcInNlY29uZFwiOiB0aGlzLl90KChkc2Vjb25kKSksXHJcbiAgICAgICAgICAgICAgICBcIm1pbnV0ZVwiOiB0aGlzLl90KChkc2Vjb25kICsgYW1pbnV0ZSkpLFxyXG4gICAgICAgICAgICAgICAgXCJob3VyXCI6IHRoaXMuX3QoKGRzZWNvbmQgKyBhaG91cikpLFxyXG4gICAgICAgICAgICAgICAgXCJkYXlcIjogdGhpcy5fdCgoZHNlY29uZCArIGFkYXkpKSxcclxuICAgICAgICAgICAgICAgIFwid2Vla1wiOiB0aGlzLl90KChkc2Vjb25kICsgYXdlZWspKSxcclxuICAgICAgICAgICAgICAgIFwibW9udGhcIjogdGhpcy5fdCgoZHNlY29uZCArIGFtb250aCkpLFxyXG4gICAgICAgICAgICAgICAgXCJ5ZWFyXCI6IHRoaXMuX3QoKGRzZWNvbmQgKyBheWVhcikpXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIFwibWludXRlXCI6IHtcclxuICAgICAgICAgICAgICAgIFwibWludXRlXCI6IHRoaXMuX3QoKGRtaW51dGUpKSxcclxuICAgICAgICAgICAgICAgIFwiaG91clwiOiB0aGlzLl90KChkbWludXRlICsgYWhvdXIpKSxcclxuICAgICAgICAgICAgICAgIFwiZGF5XCI6IHRoaXMuX3QoKGRtaW51dGUgKyBhZGF5KSksXHJcbiAgICAgICAgICAgICAgICBcIndlZWtcIjogdGhpcy5fdCgoZG1pbnV0ZSArIGF3ZWVrKSksXHJcbiAgICAgICAgICAgICAgICBcIm1vbnRoXCI6IHRoaXMuX3QoKGRtaW51dGUgKyBhbW9udGgpKSxcclxuICAgICAgICAgICAgICAgIFwieWVhclwiOiB0aGlzLl90KChkbWludXRlICsgYXllYXIpKVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBcImhvdXJcIjoge1xyXG4gICAgICAgICAgICAgICAgXCJob3VyXCI6IHRoaXMuX3QoKGRob3VyKSksXHJcbiAgICAgICAgICAgICAgICBcImRheVwiOiB0aGlzLl90KChkaG91ciArIGFkYXkpKSxcclxuICAgICAgICAgICAgICAgIFwid2Vla1wiOiB0aGlzLl90KChkaG91ciArIGF3ZWVrKSksXHJcbiAgICAgICAgICAgICAgICBcIm1vbnRoXCI6IHRoaXMuX3QoKGRob3VyICsgYW1vbnRoKSksXHJcbiAgICAgICAgICAgICAgICBcInllYXJcIjogdGhpcy5fdCgoZGhvdXIgKyBheWVhcikpXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIFwiZGF5XCI6IHtcclxuICAgICAgICAgICAgICAgIFwiZGF5XCI6IHRoaXMuX3QoKGRkYXkpKSxcclxuICAgICAgICAgICAgICAgIFwid2Vla1wiOiB0aGlzLl90KChkZGF5ICsgYXdlZWspKSxcclxuICAgICAgICAgICAgICAgIFwibW9udGhcIjogdGhpcy5fdCgoZGRheSArIGFtb250aCkpLFxyXG4gICAgICAgICAgICAgICAgXCJ5ZWFyXCI6IHRoaXMuX3QoKGRkYXkgKyBheWVhcikpXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIFwid2Vla1wiOiB7XHJcbiAgICAgICAgICAgICAgICBcIndlZWtcIjogdGhpcy5fdCgoZHdlZWspKSxcclxuICAgICAgICAgICAgICAgIFwibW9udGhcIjogdGhpcy5fdCgoZHdlZWsgKyBhbW9udGgpKSxcclxuICAgICAgICAgICAgICAgIFwieWVhclwiOiB0aGlzLl90KChkd2VlayArIGF5ZWFyKSlcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgXCJtb250aFwiOiB7XHJcbiAgICAgICAgICAgICAgICBcIm1vbnRoXCI6IHRoaXMuX3QoKGRtb250aCkpLFxyXG4gICAgICAgICAgICAgICAgXCJ5ZWFyXCI6IHRoaXMuX3QoKGRtb250aCArIGF5ZWFyKSlcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgXCJ5ZWFyXCI6IHtcclxuICAgICAgICAgICAgICAgIFwieWVhclwiOiB0aGlzLl90KGR5ZWFyKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgc3VwZXIuX3NldERlZmF1bHRzKCk7XHJcbiAgICB9XHJcbiAgICBfYmVmb3JlQ2hhbmdlZCgpIHtcclxuICAgICAgICBzdXBlci5fYmVmb3JlQ2hhbmdlZCgpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBGb3JtYXRzIHRoZSBudW1iZXIgYXMgZHVyYXRpb24uXHJcbiAgICAgKlxyXG4gICAgICogRm9yIGV4YW1wbGUgYDEwMDBgIChiYXNlIHVuaXQgc2Vjb25kcykgd291bGQgYmUgY29udmVydGVkIHRvIGAxNjo0MGAgYXMgaW5cclxuICAgICAqIDE2IG1pbnV0ZXMgYW5kIDQwIHNlY29uZHMuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHZhbHVlICAgVmFsdWUgdG8gZm9ybWF0XHJcbiAgICAgKiBAcGFyYW0gZm9ybWF0ICBGb3JtYXQgdG8gYXBwbHlcclxuICAgICAqIEBwYXJhbSBiYXNlICAgIE92ZXJyaWRlIGJhc2UgdW5pdFxyXG4gICAgICogQHJldHVybiBGb3JtYXR0ZWQgbnVtYmVyXHJcbiAgICAgKi9cclxuICAgIGZvcm1hdCh2YWx1ZSwgZm9ybWF0LCBiYXNlKSB7XHJcbiAgICAgICAgLy8gbm8gYmFzZSB1bml0P1xyXG4gICAgICAgIGxldCBiYXNlVW5pdCA9IGJhc2UgfHwgdGhpcy5nZXQoXCJiYXNlVW5pdFwiKTtcclxuICAgICAgICAvLyBubyBmb3JtYXQgcGFzc2VkIGluIG9yIGVtcHR5XHJcbiAgICAgICAgaWYgKHR5cGVvZiBmb3JtYXQgPT09IFwidW5kZWZpbmVkXCIgfHwgZm9ybWF0ID09PSBcIlwiKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmdldChcImR1cmF0aW9uRm9ybWF0XCIpICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIGZvcm1hdCA9IHRoaXMuZ2V0KFwiZHVyYXRpb25Gb3JtYXRcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBmb3JtYXQgPSB0aGlzLmdldEZvcm1hdCgkdHlwZS50b051bWJlcih2YWx1ZSksIHVuZGVmaW5lZCwgYmFzZVVuaXQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIENsZWFuIGZvcm1hdFxyXG4gICAgICAgIGZvcm1hdCA9ICR1dGlscy5jbGVhbkZvcm1hdChmb3JtYXQpO1xyXG4gICAgICAgIC8vIGdldCBmb3JtYXQgaW5mbyAoaXQgd2lsbCBhbHNvIGRlYWwgd2l0aCBwYXJzZXIgY2FjaGluZylcclxuICAgICAgICBsZXQgaW5mbyA9IHRoaXMucGFyc2VGb3JtYXQoZm9ybWF0LCBiYXNlVW5pdCk7XHJcbiAgICAgICAgLy8gY2FzdCB0byBudW1iZXIganVzdCBpbiBjYXNlXHJcbiAgICAgICAgLy8gVE9ETzogbWF5YmUgdXNlIGJldHRlciBjYXN0aW5nXHJcbiAgICAgICAgbGV0IHNvdXJjZSA9IE51bWJlcih2YWx1ZSk7XHJcbiAgICAgICAgLy8gZm9ybWF0IGFuZCByZXBsYWNlIHRoZSBudW1iZXJcclxuICAgICAgICBsZXQgZGV0YWlscztcclxuICAgICAgICBpZiAoc291cmNlID4gdGhpcy5nZXQoXCJuZWdhdGl2ZUJhc2VcIikpIHtcclxuICAgICAgICAgICAgZGV0YWlscyA9IGluZm8ucG9zaXRpdmU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHNvdXJjZSA8IHRoaXMuZ2V0KFwibmVnYXRpdmVCYXNlXCIpKSB7XHJcbiAgICAgICAgICAgIGRldGFpbHMgPSBpbmZvLm5lZ2F0aXZlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZGV0YWlscyA9IGluZm8uemVybztcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gRm9ybWF0XHJcbiAgICAgICAgbGV0IGZvcm1hdHRlZCA9IHRoaXMuYXBwbHlGb3JtYXQoc291cmNlLCBkZXRhaWxzKTtcclxuICAgICAgICAvLyBBcHBseSBjb2xvcj9cclxuICAgICAgICBpZiAoZGV0YWlscy5jb2xvciAhPT0gXCJcIikge1xyXG4gICAgICAgICAgICBmb3JtYXR0ZWQgPSBcIltcIiArIGRldGFpbHMuY29sb3IgKyBcIl1cIiArIGZvcm1hdHRlZCArIFwiWy9dXCI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmb3JtYXR0ZWQ7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFBhcnNlcyBzdXBwbGllZCBmb3JtYXQgaW50byBzdHJ1Y3R1cmVkIG9iamVjdCB3aGljaCBjYW4gYmUgdXNlZCB0byBmb3JtYXRcclxuICAgICAqIHRoZSBudW1iZXIuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGZvcm1hdCAgRm9ybWF0IHN0cmluZywgaS5lLiBcIiMsIyMjLjAwXCJcclxuICAgICAqIEBwYXJhbSBiYXNlICAgIE92ZXJyaWRlIGJhc2UgdW5pdFxyXG4gICAgICogQHJldHVybiBQYXJzZWQgaW5mb3JtYXRpb25cclxuICAgICAqL1xyXG4gICAgcGFyc2VGb3JtYXQoZm9ybWF0LCBiYXNlKSB7XHJcbiAgICAgICAgLy8gQ2hlY2sgY2FjaGVcclxuICAgICAgICAvLyBUT0RPXHJcbiAgICAgICAgLy8gbGV0IGNhY2hlZCA9IHRoaXMuZ2V0Q2FjaGUoZm9ybWF0KTtcclxuICAgICAgICAvLyBpZiAoY2FjaGVkICE9IG51bGwpIHtcclxuICAgICAgICAvLyBcdHJldHVybiBjYWNoZWQ7XHJcbiAgICAgICAgLy8gfVxyXG4gICAgICAgIC8vIG5vIGJhc2UgdW5pdD9cclxuICAgICAgICBsZXQgYmFzZVVuaXQgPSBiYXNlIHx8IHRoaXMuZ2V0KFwiYmFzZVVuaXRcIik7XHJcbiAgICAgICAgLy8gSW5pdGlhbGl6ZSBkdXJhdGlvbiBwYXJzaW5nIGluZm9cclxuICAgICAgICBsZXQgaW5mbyA9IHtcclxuICAgICAgICAgICAgXCJwb3NpdGl2ZVwiOiB7XHJcbiAgICAgICAgICAgICAgICBcImNvbG9yXCI6IFwiXCIsXHJcbiAgICAgICAgICAgICAgICBcInRlbXBsYXRlXCI6IFwiXCIsXHJcbiAgICAgICAgICAgICAgICBcInBhcnRzXCI6IFtdLFxyXG4gICAgICAgICAgICAgICAgXCJzb3VyY2VcIjogXCJcIixcclxuICAgICAgICAgICAgICAgIFwiYmFzZVVuaXRcIjogYmFzZVVuaXQsXHJcbiAgICAgICAgICAgICAgICBcInBhcnNlZFwiOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIFwiYWJzb2x1dGVcIjogZmFsc2VcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgXCJuZWdhdGl2ZVwiOiB7XHJcbiAgICAgICAgICAgICAgICBcImNvbG9yXCI6IFwiXCIsXHJcbiAgICAgICAgICAgICAgICBcInRlbXBsYXRlXCI6IFwiXCIsXHJcbiAgICAgICAgICAgICAgICBcInBhcnRzXCI6IFtdLFxyXG4gICAgICAgICAgICAgICAgXCJzb3VyY2VcIjogXCJcIixcclxuICAgICAgICAgICAgICAgIFwiYmFzZVVuaXRcIjogYmFzZVVuaXQsXHJcbiAgICAgICAgICAgICAgICBcInBhcnNlZFwiOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIFwiYWJzb2x1dGVcIjogZmFsc2VcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgXCJ6ZXJvXCI6IHtcclxuICAgICAgICAgICAgICAgIFwiY29sb3JcIjogXCJcIixcclxuICAgICAgICAgICAgICAgIFwidGVtcGxhdGVcIjogXCJcIixcclxuICAgICAgICAgICAgICAgIFwicGFydHNcIjogW10sXHJcbiAgICAgICAgICAgICAgICBcInNvdXJjZVwiOiBcIlwiLFxyXG4gICAgICAgICAgICAgICAgXCJiYXNlVW5pdFwiOiBiYXNlVW5pdCxcclxuICAgICAgICAgICAgICAgIFwicGFyc2VkXCI6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgXCJhYnNvbHV0ZVwiOiBmYWxzZVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvLyBFc2NhcGUgZG91YmxlIHZlcnRpY2FsIGJhcnMgKHRoYXQgbWVhbiBkaXNwbGF5IG9uZSB2ZXJ0aWNhbCBiYXIpXHJcbiAgICAgICAgZm9ybWF0ID0gZm9ybWF0LnJlcGxhY2UoXCJ8fFwiLCAkdHlwZS5QTEFDRUhPTERFUjIpO1xyXG4gICAgICAgIC8vIFNwbGl0IGl0IHVwIGFuZCBkZWFsIHdpdGggZGlmZmVyZW50IGZvcm1hdHNcclxuICAgICAgICBsZXQgcGFydHMgPSBmb3JtYXQuc3BsaXQoXCJ8XCIpO1xyXG4gICAgICAgIGluZm8ucG9zaXRpdmUuc291cmNlID0gcGFydHNbMF07XHJcbiAgICAgICAgaWYgKHR5cGVvZiBwYXJ0c1syXSA9PT0gXCJ1bmRlZmluZWRcIikge1xyXG4gICAgICAgICAgICBpbmZvLnplcm8gPSBpbmZvLnBvc2l0aXZlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaW5mby56ZXJvLnNvdXJjZSA9IHBhcnRzWzJdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHlwZW9mIHBhcnRzWzFdID09PSBcInVuZGVmaW5lZFwiKSB7XHJcbiAgICAgICAgICAgIGluZm8ubmVnYXRpdmUgPSBpbmZvLnBvc2l0aXZlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaW5mby5uZWdhdGl2ZS5zb3VyY2UgPSBwYXJ0c1sxXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gUGFyc2UgZWFjaFxyXG4gICAgICAgICRvYmplY3QuZWFjaChpbmZvLCAoX3BhcnQsIGl0ZW0pID0+IHtcclxuICAgICAgICAgICAgLy8gQWxyZWFkeSBwYXJzZWRcclxuICAgICAgICAgICAgaWYgKGl0ZW0ucGFyc2VkKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gQ2hlY2sgY2FjaGVkXHJcbiAgICAgICAgICAgIC8vIFRPRE9cclxuICAgICAgICAgICAgLy8gaWYgKHR5cGVvZiB0aGlzLmdldENhY2hlKGl0ZW0uc291cmNlKSAhPT0gXCJ1bmRlZmluZWRcIikge1xyXG4gICAgICAgICAgICAvLyBcdGluZm9bcGFydF0gPSB0aGlzLmdldENhY2hlKGl0ZW0uc291cmNlKTtcclxuICAgICAgICAgICAgLy8gXHRyZXR1cm47XHJcbiAgICAgICAgICAgIC8vIH1cclxuICAgICAgICAgICAgLy8gQmVnaW4gcGFyc2luZ1xyXG4gICAgICAgICAgICBsZXQgcGFydEZvcm1hdCA9IGl0ZW0uc291cmNlO1xyXG4gICAgICAgICAgICAvLyBDaGVjayBmb3IgW10gZGlyZWN0aXZlc1xyXG4gICAgICAgICAgICBsZXQgZGlycyA9IFtdO1xyXG4gICAgICAgICAgICBkaXJzID0gaXRlbS5zb3VyY2UubWF0Y2goL15cXFsoW15cXF1dKilcXF0vKTtcclxuICAgICAgICAgICAgaWYgKGRpcnMgJiYgZGlycy5sZW5ndGggJiYgZGlyc1swXSAhPT0gXCJcIikge1xyXG4gICAgICAgICAgICAgICAgcGFydEZvcm1hdCA9IGl0ZW0uc291cmNlLnN1YnN0cihkaXJzWzBdLmxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICBpdGVtLmNvbG9yID0gZGlyc1sxXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBMZXQgVGV4dEZvcm1hdHRlciBzcGxpdCBpbnRvIGNodW5rc1xyXG4gICAgICAgICAgICBsZXQgY2h1bmtzID0gVGV4dEZvcm1hdHRlci5jaHVuayhwYXJ0Rm9ybWF0LCB0cnVlKTtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaHVua3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGxldCBjaHVuayA9IGNodW5rc1tpXTtcclxuICAgICAgICAgICAgICAgIC8vIHJlcGxhY2UgYmFjayBkb3VibGUgdmVydGljYWwgYmFyXHJcbiAgICAgICAgICAgICAgICBjaHVuay50ZXh0ID0gY2h1bmsudGV4dC5yZXBsYWNlKCR0eXBlLlBMQUNFSE9MREVSMiwgXCJ8XCIpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGNodW5rLnR5cGUgPT09IFwidmFsdWVcIikge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIEp1c3QgXCJEdXJhdGlvblwiP1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIChjaHVuay50ZXh0LnRvTG93ZXJDYXNlKCkgPT09IFwiZHVyYXRpb25cIikge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFx0Y2h1bmsudGV4dCA9IGR1cmF0aW9uRm9ybWF0O1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIH1cclxuICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBmb3IgXCJhXCIgKGFic29sdXRlKSBtb2RpZmllclxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjaHVuay50ZXh0Lm1hdGNoKC9beVlNZER3aEhLa21zU25dK2EvKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtLmFic29sdXRlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2h1bmsudGV4dCA9IGNodW5rLnRleHQucmVwbGFjZSgvKFt5WU1kRHdoSEtrbXNTbl0rKWEvLCBcIiQxXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAvLyBGaW5kIGFsbCBwb3NzaWJsZSBwYXJ0c1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBtYXRjaGVzID0gY2h1bmsudGV4dC5tYXRjaCgveSt8WSt8TSt8ZCt8RCt8dyt8aCt8SCt8Syt8ayt8bSt8cyt8Uyt8bisvZyk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoZXMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUG9wdWxhdGUgdGVtcGxhdGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCBtYXRjaGVzLmxlbmd0aDsgeCsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJcyBpdCBhbiBhbGlhcz9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaGVzW3hdID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGVzW3hdID0gdGhpcy5fdW5pdEFsaWFzZXNbbWF0Y2hlc1t4XV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtLnBhcnRzLnB1c2gobWF0Y2hlc1t4XSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaHVuay50ZXh0ID0gY2h1bmsudGV4dC5yZXBsYWNlKG1hdGNoZXNbeF0sICR0eXBlLlBMQUNFSE9MREVSKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIEFwcGx5IHRvIHRlbXBsYXRlXHJcbiAgICAgICAgICAgICAgICBpdGVtLnRlbXBsYXRlICs9IGNodW5rLnRleHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gQXBwbHkgc3R5bGUgZm9ybWF0dGluZ1xyXG4gICAgICAgICAgICAvL2l0ZW0udGVtcGxhdGUgPSBUZXh0Rm9ybWF0dGVyLmZvcm1hdChpdGVtLnRlbXBsYXRlLCB0aGlzLm91dHB1dEZvcm1hdCk7XHJcbiAgICAgICAgICAgIC8vIFNhdmUgY2FjaGVcclxuICAgICAgICAgICAgLy8gVE9ET1xyXG4gICAgICAgICAgICAvL3RoaXMuc2V0Q2FjaGUoaXRlbS5zb3VyY2UsIGl0ZW0pO1xyXG4gICAgICAgICAgICAvLyBNYXJrIHRoaXMgYXMgcGFyc2VkXHJcbiAgICAgICAgICAgIGl0ZW0ucGFyc2VkID0gdHJ1ZTtcclxuICAgICAgICB9KTtcclxuICAgICAgICAvLyBTYXZlIGNhY2hlICh0aGUgd2hvbGUgdGhpbmcpXHJcbiAgICAgICAgLy8gVE9ET1xyXG4gICAgICAgIC8vdGhpcy5zZXRDYWNoZShmb3JtYXQsIGluZm8pO1xyXG4gICAgICAgIHJldHVybiBpbmZvO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBcHBsaWVzIHBhcnNlZCBmb3JtYXQgdG8gYSBudW1lcmljIHZhbHVlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB2YWx1ZSAgICBWYWx1ZVxyXG4gICAgICogQHBhcmFtIGRldGFpbHMgIFBhcnNlZCBmb3JtYXQgYXMgcmV0dXJuZWQgYnkge3BhcnNlRm9ybWF0fVxyXG4gICAgICogQHJldHVybiBGb3JtYXR0ZWQgZHVyYXRpb25cclxuICAgICAqL1xyXG4gICAgYXBwbHlGb3JtYXQodmFsdWUsIGRldGFpbHMpIHtcclxuICAgICAgICAvLyBVc2UgYWJzb2x1dGUgdmFsdWVzXHJcbiAgICAgICAgbGV0IG5lZ2F0aXZlID0gIWRldGFpbHMuYWJzb2x1dGUgJiYgKHZhbHVlIDwgdGhpcy5nZXQoXCJuZWdhdGl2ZUJhc2VcIikpO1xyXG4gICAgICAgIHZhbHVlID0gTWF0aC5hYnModmFsdWUpO1xyXG4gICAgICAgIC8vIFJlY2FsY3VsYXRlIHRvIG1pbGxpc2Vjb25kc1xyXG4gICAgICAgIGxldCB0c3RhbXAgPSB0aGlzLnRvVGltZVN0YW1wKHZhbHVlLCBkZXRhaWxzLmJhc2VVbml0KTtcclxuICAgICAgICAvLyBJbml0IHJldHVybiB2YWx1ZVxyXG4gICAgICAgIGxldCByZXMgPSBkZXRhaWxzLnRlbXBsYXRlO1xyXG4gICAgICAgIC8vIEl0ZXJhdGUgdGhyb3VnaCBkdXJhdGlvbiBwYXJ0c1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBkZXRhaWxzLnBhcnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIC8vIEdhdGhlciB0aGUgcGFydFxyXG4gICAgICAgICAgICBsZXQgcGFydCA9IGRldGFpbHMucGFydHNbaV07XHJcbiAgICAgICAgICAgIGxldCB1bml0ID0gdGhpcy5fdG9UaW1lVW5pdChwYXJ0LnN1YnN0cigwLCAxKSk7XHJcbiAgICAgICAgICAgIGxldCBkaWdpdHMgPSBwYXJ0Lmxlbmd0aDtcclxuICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIGN1cnJlbnQgdW5pdCB2YWx1ZVxyXG4gICAgICAgICAgICBsZXQgaW50cyA9IE1hdGguZmxvb3IodHN0YW1wIC8gdGhpcy5fZ2V0VW5pdFZhbHVlKHVuaXQpKTtcclxuICAgICAgICAgICAgcmVzID0gcmVzLnJlcGxhY2UoJHR5cGUuUExBQ0VIT0xERVIsICR1dGlscy5wYWRTdHJpbmcoaW50cywgZGlnaXRzLCBcIjBcIikpO1xyXG4gICAgICAgICAgICAvLyBSZWR1Y2UgdGltZXN0YW1wXHJcbiAgICAgICAgICAgIHRzdGFtcCAtPSBpbnRzICogdGhpcy5fZ2V0VW5pdFZhbHVlKHVuaXQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBSZWFwcGx5IG5lZ2F0aXZlIHNpZ25cclxuICAgICAgICBpZiAobmVnYXRpdmUpIHtcclxuICAgICAgICAgICAgcmVzID0gXCItXCIgKyByZXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENvbnZlcnRzIG51bWVyaWMgdmFsdWUgdG8gdGltZXN0YW1wIGluIG1pbGxpc2Vjb25kcy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gdmFsdWUgICAgIEEgc291cmNlIHZhbHVlXHJcbiAgICAgKiBAcGFyYW0gYmFzZVVuaXQgIEJhc2UgdW5pdCB0aGUgc291cmNlIHZhbHVlIGlzIGluOiBcInFcIiwgXCJzXCIsIFwiaVwiLCBcImhcIiwgXCJkXCIsIFwid1wiLCBcIm1cIiwgXCJ5XCJcclxuICAgICAqIEByZXR1cm4gVmFsdWUgcmVwcmVzZW50YXRpb24gYXMgYSB0aW1lc3RhbXAgaW4gbWlsbGlzZWNvbmRzXHJcbiAgICAgKi9cclxuICAgIHRvVGltZVN0YW1wKHZhbHVlLCBiYXNlVW5pdCkge1xyXG4gICAgICAgIHJldHVybiB2YWx1ZSAqIHRoaXMuX2dldFVuaXRWYWx1ZShiYXNlVW5pdCk7XHJcbiAgICB9XHJcbiAgICBfdG9UaW1lVW5pdChjb2RlKSB7XHJcbiAgICAgICAgc3dpdGNoIChjb2RlKSB7XHJcbiAgICAgICAgICAgIGNhc2UgXCJTXCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJtaWxsaXNlY29uZFwiO1xyXG4gICAgICAgICAgICBjYXNlIFwic1wiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwic2Vjb25kXCI7XHJcbiAgICAgICAgICAgIGNhc2UgXCJtXCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJtaW51dGVcIjtcclxuICAgICAgICAgICAgY2FzZSBcImhcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiBcImhvdXJcIjtcclxuICAgICAgICAgICAgY2FzZSBcImRcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiBcImRheVwiO1xyXG4gICAgICAgICAgICBjYXNlIFwid1wiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwid2Vla1wiO1xyXG4gICAgICAgICAgICBjYXNlIFwiTVwiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwibW9udGhcIjtcclxuICAgICAgICAgICAgY2FzZSBcInlcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiBcInllYXJcIjtcclxuICAgICAgICB9XHJcbiAgICAgICAgO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGFwcHJvcHJpYXRlIGRlZmF1bHQgZm9ybWF0IGZvciB0aGUgdmFsdWUuXHJcbiAgICAgKlxyXG4gICAgICogSWYgYG1heFZhbHVlYCBpcyBzZXBjaWZpZWQsIGl0IHdpbGwgdXNlIHRoYXQgdmFsdWUgdG8gZGV0ZXJtaW5lIHRoZSB0aW1lXHJcbiAgICAgKiB1bml0IGZvciB0aGUgZm9ybWF0LlxyXG4gICAgICpcclxuICAgICAqIEZvciBleGFtcGxlIGlmIHlvdXIgYGJhc2VVbml0YCBpcyBgXCJzZWNvbmRcImAgYW5kIHlvdSBwYXNzIGluIGAxMGAsIHlvdVxyXG4gICAgICogd2lsbCBnZXQgYFwiMTBcImAuXHJcbiAgICAgKlxyXG4gICAgICogSG93ZXZlciwgeW91IG1pZ2h0IHdhbnQgaXQgdG8gYmUgZm9ybWF0dGVkIGluIHRoZSBjb250ZXh0IG9mIGJpZ2dlciBzY2FsZSxcclxuICAgICAqIHNheSAxMCBtaW51dGVzICg2MDAgc2Vjb25kcykuIElmIHlvdSBwYXNzIGluIGA2MDBgIGFzIGBtYXhWYWx1ZWAsIGFsbFxyXG4gICAgICogdmFsdWVzLCBpbmNsdWRpbmcgc21hbGwgb25lcyB3aWxsIHVzZSBmb3JtYXQgd2l0aCBtaW51dGVzLCBlLmcuOlxyXG4gICAgICogYDAwOjEwYCwgYDAwOjUwYCwgYDEyOiAzMGAsIGV0Yy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gdmFsdWUgICAgIFZhbHVlIHRvIGZvcm1hdFxyXG4gICAgICogQHBhcmFtIG1heFZhbHVlICBNYXhpbXVtIHZhbHVlIHRvIGJlIHVzZWQgdG8gZGV0ZXJtaW5lIGZvcm1hdFxyXG4gICAgICogQHBhcmFtIGJhc2VVbml0ICBCYXNlIHVuaXQgb2YgdGhlIHZhbHVlXHJcbiAgICAgKiBAcmV0dXJuIEZvcm1hdFxyXG4gICAgICovXHJcbiAgICBnZXRGb3JtYXQodmFsdWUsIG1heFZhbHVlLCBiYXNlVW5pdCkge1xyXG4gICAgICAgIC8vIElzIGZvcm1hdCBvdmVycmlkZSBzZXQ/XHJcbiAgICAgICAgaWYgKHRoaXMuZ2V0KFwiZHVyYXRpb25Gb3JtYXRcIikgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXQoXCJkdXJhdGlvbkZvcm1hdFwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gR2V0IGJhc2UgdW5pdFxyXG4gICAgICAgIGlmICghYmFzZVVuaXQpIHtcclxuICAgICAgICAgICAgYmFzZVVuaXQgPSB0aGlzLmdldChcImJhc2VVbml0XCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobWF4VmFsdWUgIT0gbnVsbCAmJiB2YWx1ZSAhPSBtYXhWYWx1ZSkge1xyXG4gICAgICAgICAgICB2YWx1ZSA9IE1hdGguYWJzKHZhbHVlKTtcclxuICAgICAgICAgICAgbWF4VmFsdWUgPSBNYXRoLmFicyhtYXhWYWx1ZSk7XHJcbiAgICAgICAgICAgIGxldCBtYXhVbml0ID0gdGhpcy5nZXRWYWx1ZVVuaXQoTWF0aC5tYXgodmFsdWUsIG1heFZhbHVlKSwgYmFzZVVuaXQpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXQoXCJkdXJhdGlvbkZvcm1hdHNcIilbYmFzZVVuaXRdW21heFVuaXRdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgbGV0IHVuaXQgPSB0aGlzLmdldFZhbHVlVW5pdCh2YWx1ZSwgYmFzZVVuaXQpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXQoXCJkdXJhdGlvbkZvcm1hdHNcIilbYmFzZVVuaXRdW3VuaXRdO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB2YWx1ZSdzIGNsb3Nlc3QgZGVub21pbmF0b3IgdGltZSB1bml0LCBlLmcgMTAwIHNlY29uZHMgaXNcclxuICAgICAqIGBcIm1pbnV0ZVwiYCwgd2hpbGUgNTkgc2Vjb25kcyB3b3VsZCBzdGlsbCBiZSBgc2Vjb25kYC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gdmFsdWUgICAgIFNvdXJjZSBkdXJhdGlvbiB2YWx1ZVxyXG4gICAgICogQHBhcmFtIGJhc2VVbml0ICBCYXNlIHVuaXRcclxuICAgICAqIEByZXR1cm4gRGVub21pbmF0b3JcclxuICAgICAqL1xyXG4gICAgZ2V0VmFsdWVVbml0KHZhbHVlLCBiYXNlVW5pdCkge1xyXG4gICAgICAgIC8vIEdldCBiYXNlIHVuaXRcclxuICAgICAgICBpZiAoIWJhc2VVbml0KSB7XHJcbiAgICAgICAgICAgIGJhc2VVbml0ID0gdGhpcy5nZXQoXCJiYXNlVW5pdFwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gQ29udmVydCB0byBtaWxsaXNlY29uZHNcclxuICAgICAgICBsZXQgY3VycmVudFVuaXQ7XHJcbiAgICAgICAgbGV0IG1zID0gdGhpcy5nZXRNaWxsaXNlY29uZHModmFsdWUsIGJhc2VVbml0KTtcclxuICAgICAgICAkb2JqZWN0LmVhY2hDb250aW51ZSh0aGlzLl9nZXRVbml0VmFsdWVzKCksIChrZXksIHZhbCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoa2V5ID09IGJhc2VVbml0IHx8IGN1cnJlbnRVbml0KSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgbnVtID0gbXMgLyB2YWw7XHJcbiAgICAgICAgICAgICAgICBpZiAobnVtIDw9IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWN1cnJlbnRVbml0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRVbml0ID0ga2V5O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50VW5pdCA9IGtleTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gY3VycmVudFVuaXQ7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENvbnZlcnRzIHZhbHVlIHRvIG1pbGxpc2Vjb25kcyBhY2NvcmRpbmcgdG8gYGJhc2VVbml0YC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gdmFsdWUgICAgIFNvdXJjZSBkdXJhdGlvbiB2YWx1ZVxyXG4gICAgICogQHBhcmFtIGJhc2VVbml0ICBCYXNlIHVuaXRcclxuICAgICAqIEByZXR1cm4gVmFsdWUgaW4gbWlsbGlzZWNvbmRzXHJcbiAgICAgKi9cclxuICAgIGdldE1pbGxpc2Vjb25kcyh2YWx1ZSwgYmFzZVVuaXQpIHtcclxuICAgICAgICAvLyBHZXQgYmFzZSB1bml0XHJcbiAgICAgICAgaWYgKCFiYXNlVW5pdCkge1xyXG4gICAgICAgICAgICBiYXNlVW5pdCA9IHRoaXMuZ2V0KFwiYmFzZVVuaXRcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB2YWx1ZSAqIHRoaXMuX2dldFVuaXRWYWx1ZShiYXNlVW5pdCk7XHJcbiAgICB9XHJcbiAgICBfZ2V0VW5pdFZhbHVlKHRpbWVVbml0KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldFVuaXRWYWx1ZXMoKVt0aW1lVW5pdF07XHJcbiAgICB9XHJcbiAgICBfZ2V0VW5pdFZhbHVlcygpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBcIm1pbGxpc2Vjb25kXCI6IDEsXHJcbiAgICAgICAgICAgIFwic2Vjb25kXCI6IDEwMDAsXHJcbiAgICAgICAgICAgIFwibWludXRlXCI6IDYwMDAwLFxyXG4gICAgICAgICAgICBcImhvdXJcIjogMzYwMDAwMCxcclxuICAgICAgICAgICAgXCJkYXlcIjogODY0MDAwMDAsXHJcbiAgICAgICAgICAgIFwid2Vla1wiOiA2MDQ4MDAwMDAsXHJcbiAgICAgICAgICAgIFwibW9udGhcIjogMjU5MjAwMDAwMCxcclxuICAgICAgICAgICAgXCJ5ZWFyXCI6IDMxNTM2MDAwMDAwLFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RHVyYXRpb25Gb3JtYXR0ZXIuanMubWFwIiwiLyoqXHJcbiAqIEEgY29sbGVjdGlvbiBvZiBlYXNpbmcgZnVuY3Rpb25zXHJcbiAqXHJcbiAqIFBhcnRzIG9mIHRoaXMgY29sbGVjdGlvbiBhcmUgdGFrZW4gZnJvbSBEMy5qcyBsaWJyYXJ5IChodHRwczovL2QzanMub3JnLylcclxuICovXHJcbi8qKlxyXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAqIElNUE9SVFNcclxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4gKiBAaGlkZGVuXHJcbiAqL1xyXG5pbXBvcnQgKiBhcyAkbWF0aCBmcm9tIFwiLi9NYXRoXCI7XHJcbi8qKlxyXG4gKiBUaGUgZnVuY3Rpb25zIGJlbG93IGFyZSBmcm9tIEQzLmpzIGxpYnJhcnkgKGh0dHBzOi8vZDNqcy5vcmcvKVxyXG4gKlxyXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAqIENvcHlyaWdodCAyMDE3IE1pa2UgQm9zdG9ja1xyXG4gKlxyXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcclxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBtZXQ6XHJcbiAqXHJcbiAqIDEuIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSxcclxuICpcdHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXHJcbiAqXHJcbiAqIDIuIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSxcclxuICpcdHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlIGRvY3VtZW50YXRpb25cclxuICpcdGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxyXG4gKlxyXG4gKiAzLiBOZWl0aGVyIHRoZSBuYW1lIG9mIHRoZSBjb3B5cmlnaHQgaG9sZGVyIG5vciB0aGUgbmFtZXMgb2YgaXRzXHJcbiAqXHRjb250cmlidXRvcnMgbWF5IGJlIHVzZWQgdG8gZW5kb3JzZSBvciBwcm9tb3RlIHByb2R1Y3RzIGRlcml2ZWQgZnJvbSB0aGlzXHJcbiAqXHRzb2Z0d2FyZSB3aXRob3V0IHNwZWNpZmljIHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbi5cclxuICpcclxuICogVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SUyBcIkFTIElTXCJcclxuICogQU5EIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRVxyXG4gKiBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRVxyXG4gKiBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVCBIT0xERVIgT1IgQ09OVFJJQlVUT1JTIEJFXHJcbiAqIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1JcclxuICogQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0ZcclxuICogU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTXHJcbiAqIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWSBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOXHJcbiAqIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpXHJcbiAqIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRiBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFXHJcbiAqIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxyXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAqIEBoaWRkZW5cclxuICovXHJcbi8qKlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGxpbmVhcih0KSB7XHJcbiAgICByZXR1cm4gdDtcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gcXVhZCh0KSB7XHJcbiAgICByZXR1cm4gdCAqIHQ7XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIGN1YmljKHQpIHtcclxuICAgIHJldHVybiB0ICogdCAqIHQ7XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIHBvdyh0LCBlKSB7XHJcbiAgICByZXR1cm4gTWF0aC5wb3codCwgZSk7XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIGV4cCh0KSB7XHJcbiAgICByZXR1cm4gTWF0aC5wb3coMiwgMTAgKiB0IC0gMTApO1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiBzaW5lKHQpIHtcclxuICAgIHJldHVybiAxIC0gTWF0aC5jb3ModCAqICRtYXRoLkhBTEZQSSk7XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIGNpcmNsZSh0KSB7XHJcbiAgICByZXR1cm4gMSAtIE1hdGguc3FydCgxIC0gdCAqIHQpO1xyXG59XHJcbi8qKlxyXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAqIFRSQU5TRk9STUVSU1xyXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAqIEBoaWRkZW5cclxuICovXHJcbi8qKlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHlveW8oZWFzZSkge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0KSB7XHJcbiAgICAgICAgaWYgKHQgPCAwLjUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGVhc2UodCAqIDIuMCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gZWFzZSgoMS4wIC0gdCkgKiAyLjApO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIG91dChlYXNlKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKHQpIHtcclxuICAgICAgICByZXR1cm4gMS4wIC0gZWFzZSgxLjAgLSB0KTtcclxuICAgIH07XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIGluT3V0KGVhc2UpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiAodCkge1xyXG4gICAgICAgIGlmICh0IDw9IDAuNSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZWFzZSh0ICogMi4wKSAvIDIuMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiAxLjAgLSAoZWFzZSgoMS4wIC0gdCkgKiAyLjApIC8gMi4wKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59XHJcbi8qKlxyXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAqIEJPVU5DRVxyXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAqIEBoaWRkZW5cclxuICovXHJcbmxldCBiMSA9IDQgLyAxMSwgYjIgPSA2IC8gMTEsIGIzID0gOCAvIDExLCBiNCA9IDMgLyA0LCBiNSA9IDkgLyAxMSwgYjYgPSAxMCAvIDExLCBiNyA9IDE1IC8gMTYsIGI4ID0gMjEgLyAyMiwgYjkgPSA2MyAvIDY0LCBiMCA9IDEgLyBiMSAvIGIxO1xyXG5leHBvcnQgZnVuY3Rpb24gYm91bmNlKHQpIHtcclxuICAgIHJldHVybiAxIC0gYm91bmNlT3V0KDEgLSB0KTtcclxufVxyXG4vKipcclxuICogQGlnbm9yZVxyXG4gKi9cclxuZnVuY3Rpb24gYm91bmNlT3V0KHQpIHtcclxuICAgIHQgPSB0O1xyXG4gICAgaWYgKHQgPCBiMSkge1xyXG4gICAgICAgIHJldHVybiBiMCAqIHQgKiB0O1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodCA8IGIzKSB7XHJcbiAgICAgICAgcmV0dXJuIGIwICogKHQgLT0gYjIpICogdCArIGI0O1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodCA8IGI2KSB7XHJcbiAgICAgICAgcmV0dXJuIGIwICogKHQgLT0gYjUpICogdCArIGI3O1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIGIwICogKHQgLT0gYjgpICogdCArIGI5O1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAqIEVMQVNUSUNcclxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4gKiBAaGlkZGVuXHJcbiAqL1xyXG4vKipcclxuICogQGlnbm9yZVxyXG4gKi9cclxubGV0IHRhdSA9IDIgKiBNYXRoLlBJO1xyXG4vKipcclxuICogQGlnbm9yZVxyXG4gKi9cclxubGV0IGFtcGxpdHVkZSA9IDE7XHJcbi8qKlxyXG4gKiBAaWdub3JlXHJcbiAqL1xyXG5sZXQgcGVyaW9kID0gMC4zIC8gdGF1O1xyXG4vKipcclxuICogQGlnbm9yZVxyXG4gKi9cclxubGV0IHMgPSBNYXRoLmFzaW4oMSAvIGFtcGxpdHVkZSkgKiBwZXJpb2Q7XHJcbmV4cG9ydCBmdW5jdGlvbiBlbGFzdGljKHQpIHtcclxuICAgIGxldCB2ID0gdDtcclxuICAgIHJldHVybiBhbXBsaXR1ZGUgKiBNYXRoLnBvdygyLCAxMCAqIC0tdikgKiBNYXRoLnNpbigocyAtIHYpIC8gcGVyaW9kKTtcclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1FYXNlLmpzLm1hcCIsImltcG9ydCB7IERpc3Bvc2VyIH0gZnJvbSBcIi4vRGlzcG9zZXJcIjtcclxuaW1wb3J0IHsgRXZlbnREaXNwYXRjaGVyIH0gZnJvbSBcIi4vRXZlbnREaXNwYXRjaGVyXCI7XHJcbmltcG9ydCB7IGdldEludGVycG9sYXRlIH0gZnJvbSBcIi4vQW5pbWF0aW9uXCI7XHJcbmltcG9ydCB7IFN0YXRlcyB9IGZyb20gXCIuL1N0YXRlc1wiO1xyXG5pbXBvcnQgeyByZWdpc3RyeSB9IGZyb20gXCIuLi9SZWdpc3RyeVwiO1xyXG5pbXBvcnQgKiBhcyAkb2JqZWN0IGZyb20gXCIuL09iamVjdFwiO1xyXG5pbXBvcnQgKiBhcyAkZWFzZSBmcm9tIFwiLi9FYXNlXCI7XHJcbmltcG9ydCAqIGFzICRhcnJheSBmcm9tIFwiLi9BcnJheVwiO1xyXG5pbXBvcnQgKiBhcyAkb3JkZXIgZnJvbSBcIi4vT3JkZXJcIjtcclxuLyoqXHJcbiAqIEFsbG93cyB0byBkeW5hbWljYWxseSBtb2RpZnkgc2V0dGluZyB2YWx1ZSBvZiBpdHMgdGFyZ2V0IGVsZW1lbnQuXHJcbiAqXHJcbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vd3d3LmFtY2hhcnRzLmNvbS9kb2NzL3Y1L2NvbmNlcHRzL3NldHRpbmdzL2FkYXB0ZXJzL30gZm9yIG1vcmUgaW5mb1xyXG4gKi9cclxuZXhwb3J0IGNsYXNzIEFkYXB0ZXJzIHtcclxuICAgIGNvbnN0cnVjdG9yKGVudGl0eSkge1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9lbnRpdHlcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX2NhbGxiYWNrc1wiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiB7fVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9kaXNhYmxlZFwiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiB7fVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuX2VudGl0eSA9IGVudGl0eTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQWRkIGEgZnVuY3Rpb24gKGBjYWxsYmFja2ApIHRoYXQgd2lsbCBtb2RpZnkgdmFsdWUgZm9yIHNldHRpbmcgYGtleWAuXHJcbiAgICAgKlxyXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly93d3cuYW1jaGFydHMuY29tL2RvY3MvdjUvY29uY2VwdHMvc2V0dGluZ3MvYWRhcHRlcnMvfSBmb3IgbW9yZSBpbmZvXHJcbiAgICAgKi9cclxuICAgIGFkZChrZXksIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgbGV0IGNhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrc1trZXldO1xyXG4gICAgICAgIGlmIChjYWxsYmFja3MgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBjYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3Nba2V5XSA9IFtdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYWxsYmFja3MucHVzaChjYWxsYmFjayk7XHJcbiAgICAgICAgdGhpcy5fZW50aXR5Ll9tYXJrRGlydHlLZXkoa2V5KTtcclxuICAgICAgICByZXR1cm4gbmV3IERpc3Bvc2VyKCgpID0+IHtcclxuICAgICAgICAgICAgaWYgKCRhcnJheS5yZW1vdmVGaXJzdChjYWxsYmFja3MsIGNhbGxiYWNrKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZW50aXR5Ll9tYXJrRGlydHlLZXkoa2V5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmVzIGFsbCBhZGFwdGVycyBmb3IgdGhlIHNwZWNpZmljIGtleS5cclxuICAgICAqXHJcbiAgICAgKiBAc2luY2UgNS4xLjBcclxuICAgICAqL1xyXG4gICAgcmVtb3ZlKGtleSkge1xyXG4gICAgICAgIGNvbnN0IGNhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrc1trZXldO1xyXG4gICAgICAgIGlmIChjYWxsYmFja3MgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBkZWxldGUgdGhpcy5fY2FsbGJhY2tzW2tleV07XHJcbiAgICAgICAgICAgIGlmIChjYWxsYmFja3MubGVuZ3RoICE9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9lbnRpdHkuX21hcmtEaXJ0eUtleShrZXkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBFbmFibGVzIChwcmV2aW91c2x5IGRpc2FibGVkKSBhZGFwdGVycyBmb3Igc3BlY2lmaWMga2V5LlxyXG4gICAgICpcclxuICAgICAqIEBzaW5jZSA1LjEuMFxyXG4gICAgICovXHJcbiAgICBlbmFibGUoa2V5KSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2Rpc2FibGVkW2tleV0pIHtcclxuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2Rpc2FibGVkW2tleV07XHJcbiAgICAgICAgICAgIHRoaXMuX2VudGl0eS5fbWFya0RpcnR5S2V5KGtleSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBEaXNhYmxlcyBhbGwgYWRhcHRlcnMgZm9yIHNwZWNpZmljIGtleS5cclxuICAgICAqXHJcbiAgICAgKiBAc2luY2UgNS4xLjBcclxuICAgICAqL1xyXG4gICAgZGlzYWJsZShrZXkpIHtcclxuICAgICAgICBpZiAoIXRoaXMuX2Rpc2FibGVkW2tleV0pIHtcclxuICAgICAgICAgICAgdGhpcy5fZGlzYWJsZWRba2V5XSA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMuX2VudGl0eS5fbWFya0RpcnR5S2V5KGtleSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAaWdub3JlXHJcbiAgICAgKi9cclxuICAgIGZvbGQoa2V5LCB2YWx1ZSkge1xyXG4gICAgICAgIGlmICghdGhpcy5fZGlzYWJsZWRba2V5XSkge1xyXG4gICAgICAgICAgICBjb25zdCBjYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3Nba2V5XTtcclxuICAgICAgICAgICAgaWYgKGNhbGxiYWNrcyAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gY2FsbGJhY2tzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBjYWxsYmFja3NbaV0odmFsdWUsIHRoaXMuX2VudGl0eSwga2V5KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEFuaW1hdGlvbiBvYmplY3QuXHJcbiAqXHJcbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vd3d3LmFtY2hhcnRzLmNvbS9kb2NzL3Y1L2NvbmNlcHRzL2FuaW1hdGlvbnMvfSBmb3IgbW9yZSBpbmZvXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgQW5pbWF0aW9uIHtcclxuICAgIGNvbnN0cnVjdG9yKGFuaW1hdGlvbiwgZnJvbSwgdG8sIGR1cmF0aW9uLCBlYXNpbmcsIGxvb3BzLCBzdGFydGluZ1RpbWUpIHtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfYW5pbWF0aW9uXCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9mcm9tXCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl90b1wiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfZHVyYXRpb25cIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX2Vhc2luZ1wiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfbG9vcHNcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX2ludGVycG9sYXRlXCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9vbGRUaW1lXCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl90aW1lXCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IDBcclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfc3RvcHBlZFwiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiBmYWxzZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9wbGF5aW5nXCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IHRydWVcclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJldmVudHNcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogbmV3IEV2ZW50RGlzcGF0Y2hlcigpXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5fYW5pbWF0aW9uID0gYW5pbWF0aW9uO1xyXG4gICAgICAgIHRoaXMuX2Zyb20gPSBmcm9tO1xyXG4gICAgICAgIHRoaXMuX3RvID0gdG87XHJcbiAgICAgICAgdGhpcy5fZHVyYXRpb24gPSBkdXJhdGlvbjtcclxuICAgICAgICB0aGlzLl9lYXNpbmcgPSBlYXNpbmc7XHJcbiAgICAgICAgdGhpcy5fbG9vcHMgPSBsb29wcztcclxuICAgICAgICB0aGlzLl9pbnRlcnBvbGF0ZSA9IGdldEludGVycG9sYXRlKGZyb20sIHRvKTtcclxuICAgICAgICB0aGlzLl9vbGRUaW1lID0gc3RhcnRpbmdUaW1lO1xyXG4gICAgfVxyXG4gICAgZ2V0IHRvKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl90bztcclxuICAgIH1cclxuICAgIGdldCBmcm9tKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9mcm9tO1xyXG4gICAgfVxyXG4gICAgZ2V0IHBsYXlpbmcoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BsYXlpbmc7XHJcbiAgICB9XHJcbiAgICBnZXQgc3RvcHBlZCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fc3RvcHBlZDtcclxuICAgIH1cclxuICAgIHN0b3AoKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9zdG9wcGVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3N0b3BwZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLl9wbGF5aW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmV2ZW50cy5pc0VuYWJsZWQoXCJzdG9wcGVkXCIpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50cy5kaXNwYXRjaChcInN0b3BwZWRcIiwge1xyXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwic3RvcHBlZFwiLFxyXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldDogdGhpcyxcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcGF1c2UoKSB7XHJcbiAgICAgICAgdGhpcy5fcGxheWluZyA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuX29sZFRpbWUgPSBudWxsO1xyXG4gICAgfVxyXG4gICAgcGxheSgpIHtcclxuICAgICAgICBpZiAoIXRoaXMuX3N0b3BwZWQgJiYgIXRoaXMuX3BsYXlpbmcpIHtcclxuICAgICAgICAgICAgdGhpcy5fcGxheWluZyA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMuX2FuaW1hdGlvbi5fc3RhcnRBbmltYXRpb24oKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBnZXQgcGVyY2VudGFnZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fdGltZSAvIHRoaXMuX2R1cmF0aW9uO1xyXG4gICAgfVxyXG4gICAgd2FpdEZvclN0b3AoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCBfcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9zdG9wcGVkKSB7XHJcbiAgICAgICAgICAgICAgICByZXNvbHZlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBsaXN0ZW5lciA9ICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBzdG9wcGVkLmRpc3Bvc2UoKTtcclxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc3RvcHBlZCA9IHRoaXMuZXZlbnRzLm9uKFwic3RvcHBlZFwiLCBsaXN0ZW5lcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIF9jaGVja0VuZGVkKCkge1xyXG4gICAgICAgIGlmICh0aGlzLl9sb29wcyA+IDEpIHtcclxuICAgICAgICAgICAgLS10aGlzLl9sb29wcztcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgX3J1bihjdXJyZW50VGltZSkge1xyXG4gICAgICAgIGlmICh0aGlzLl9vbGRUaW1lICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3RpbWUgKz0gY3VycmVudFRpbWUgLSB0aGlzLl9vbGRUaW1lO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fdGltZSA+IHRoaXMuX2R1cmF0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl90aW1lID0gdGhpcy5fZHVyYXRpb247XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fb2xkVGltZSA9IGN1cnJlbnRUaW1lO1xyXG4gICAgfVxyXG4gICAgX3Jlc2V0KGN1cnJlbnRUaW1lKSB7XHJcbiAgICAgICAgdGhpcy5fb2xkVGltZSA9IGN1cnJlbnRUaW1lO1xyXG4gICAgICAgIHRoaXMuX3RpbWUgPSAwO1xyXG4gICAgfVxyXG4gICAgX3ZhbHVlKGRpZmYpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5faW50ZXJwb2xhdGUodGhpcy5fZWFzaW5nKGRpZmYpLCB0aGlzLl9mcm9tLCB0aGlzLl90byk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEBpZ25vcmVcclxuICovXHJcbmxldCBjb3VudGVyID0gMDtcclxuLyoqXHJcbiAqIEJhc2UgY2xhc3MgZm9yIFtbRW50aXR5XV0gb2JqZWN0cyB0aGF0IHN1cHBvcnQgU2V0dGluZ3MuXHJcbiAqXHJcbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vd3d3LmFtY2hhcnRzLmNvbS9kb2NzL3Y1L2NvbmNlcHRzL3NldHRpbmdzL30gZm9yIG1vcmUgaW5mb1xyXG4gKi9cclxuZXhwb3J0IGNsYXNzIFNldHRpbmdzIHtcclxuICAgIGNvbnN0cnVjdG9yKHNldHRpbmdzKSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVW5pcXVlIElELlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInVpZFwiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiArK2NvdW50ZXJcclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfc2V0dGluZ3NcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX3ByaXZhdGVTZXR0aW5nc1wiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiB7fVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9zZXR0aW5nRXZlbnRzXCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IHt9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX3ByaXZhdGVTZXR0aW5nRXZlbnRzXCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IHt9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX3ByZXZTZXR0aW5nc1wiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiB7fVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9wcmV2UHJpdmF0ZVNldHRpbmdzXCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IHt9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX2FuaW1hdGluZ1NldHRpbmdzXCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IHt9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX2FuaW1hdGluZ1ByaXZhdGVTZXR0aW5nc1wiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiB7fVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9wbGF5aW5nQW5pbWF0aW9uc1wiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiAwXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX2Rpc3Bvc2VkXCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IGZhbHNlXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLy8gVE9ETyBtb3ZlIHRoaXMgaW50byBFbnRpdHlcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfdXNlclByb3BlcnRpZXNcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZToge31cclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLl9zZXR0aW5ncyA9IHNldHRpbmdzO1xyXG4gICAgfVxyXG4gICAgX2NoZWNrRGlydHkoKSB7XHJcbiAgICAgICAgJG9iamVjdC5rZXlzKHRoaXMuX3NldHRpbmdzKS5mb3JFYWNoKChrZXkpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5fdXNlclByb3BlcnRpZXNba2V5XSA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMuX21hcmtEaXJ0eUtleShrZXkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAaWdub3JlXHJcbiAgICAgKi9cclxuICAgIHJlc2V0VXNlclNldHRpbmdzKCkge1xyXG4gICAgICAgIHRoaXMuX3VzZXJQcm9wZXJ0aWVzID0ge307XHJcbiAgICB9XHJcbiAgICBfcnVuQW5pbWF0aW9uKGN1cnJlbnRUaW1lKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmlzRGlzcG9zZWQoKSkge1xyXG4gICAgICAgICAgICAkb2JqZWN0LmVhY2godGhpcy5fYW5pbWF0aW5nU2V0dGluZ3MsIChrZXksIGFuaW1hdGlvbikgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKGFuaW1hdGlvbi5fc3RvcHBlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0b3BBbmltYXRpb24oa2V5KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGFuaW1hdGlvbi5fcGxheWluZykge1xyXG4gICAgICAgICAgICAgICAgICAgIGFuaW1hdGlvbi5fcnVuKGN1cnJlbnRUaW1lKTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBkaWZmID0gYW5pbWF0aW9uLnBlcmNlbnRhZ2U7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRpZmYgPj0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYW5pbWF0aW9uLl9jaGVja0VuZGVkKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0KGtleSwgYW5pbWF0aW9uLl92YWx1ZSgxKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbmltYXRpb24uX3Jlc2V0KGN1cnJlbnRUaW1lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3NldChrZXksIGFuaW1hdGlvbi5fdmFsdWUoMSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9zZXQoa2V5LCBhbmltYXRpb24uX3ZhbHVlKGRpZmYpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAkb2JqZWN0LmVhY2godGhpcy5fYW5pbWF0aW5nUHJpdmF0ZVNldHRpbmdzLCAoa2V5LCBhbmltYXRpb24pID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChhbmltYXRpb24uX3N0b3BwZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdG9wQW5pbWF0aW9uUHJpdmF0ZShrZXkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoYW5pbWF0aW9uLl9wbGF5aW5nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYW5pbWF0aW9uLl9ydW4oY3VycmVudFRpbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRpZmYgPSBhbmltYXRpb24ucGVyY2VudGFnZTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZGlmZiA+PSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhbmltYXRpb24uX2NoZWNrRW5kZWQoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRQcml2YXRlKGtleSwgYW5pbWF0aW9uLl92YWx1ZSgxKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbmltYXRpb24uX3Jlc2V0KGN1cnJlbnRUaW1lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3NldFByaXZhdGUoa2V5LCBhbmltYXRpb24uX3ZhbHVlKDEpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2V0UHJpdmF0ZShrZXksIGFuaW1hdGlvbi5fdmFsdWUoZGlmZikpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9wbGF5aW5nQW5pbWF0aW9ucyAhPT0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBfbWFya0RpcnR5S2V5KF9rZXkpIHtcclxuICAgICAgICB0aGlzLm1hcmtEaXJ0eSgpO1xyXG4gICAgfVxyXG4gICAgX21hcmtEaXJ0eVByaXZhdGVLZXkoX2tleSkge1xyXG4gICAgICAgIHRoaXMubWFya0RpcnR5KCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNldHMgYSBjYWxsYmFjayBmdW5jdGlvbiB0byBpbnZva2Ugd2hlbiBzcGVjaWZpYyBrZXkgb2Ygc2V0dGluZ3MgY2hhbmdlc1xyXG4gICAgICogb3IgaXMgc2V0LlxyXG4gICAgICpcclxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vd3d3LmFtY2hhcnRzLmNvbS9kb2NzL3Y1L2NvbmNlcHRzL2V2ZW50cy8jU2V0dGluZ3NfdmFsdWVfY2hhbmdlfSBmb3IgbW9yZSBpbmZvXHJcbiAgICAgKiBAcGFyYW0gICBrZXkgICAgICAgU2V0dGluZ3Mga2V5XHJcbiAgICAgKiBAcGFyYW0gICBjYWxsYmFjayAgQ2FsbGJhY2tcclxuICAgICAqIEByZXR1cm4gICAgICAgICAgICBEaXNwb3NlciBmb3IgZXZlbnRcclxuICAgICAqL1xyXG4gICAgb24oa2V5LCBjYWxsYmFjaykge1xyXG4gICAgICAgIGxldCBldmVudHMgPSB0aGlzLl9zZXR0aW5nRXZlbnRzW2tleV07XHJcbiAgICAgICAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIGV2ZW50cyA9IHRoaXMuX3NldHRpbmdFdmVudHNba2V5XSA9IFtdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBldmVudHMucHVzaChjYWxsYmFjayk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBEaXNwb3NlcigoKSA9PiB7XHJcbiAgICAgICAgICAgICRhcnJheS5yZW1vdmVGaXJzdChldmVudHMsIGNhbGxiYWNrKTtcclxuICAgICAgICAgICAgaWYgKGV2ZW50cy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9zZXR0aW5nRXZlbnRzW2tleV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyBhIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGludm9rZSB3aGVuIHNwZWNpZmljIGtleSBvZiBwcml2YXRlIHNldHRpbmdzXHJcbiAgICAgKiBjaGFuZ2VzIG9yIGlzIHNldC5cclxuICAgICAqXHJcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL3d3dy5hbWNoYXJ0cy5jb20vZG9jcy92NS9jb25jZXB0cy9ldmVudHMvI1NldHRpbmdzX3ZhbHVlX2NoYW5nZX0gZm9yIG1vcmUgaW5mb1xyXG4gICAgICogQGlnbm9yZVxyXG4gICAgICogQHBhcmFtICAga2V5ICAgICAgIFByaXZhdGUgc2V0dGluZ3Mga2V5XHJcbiAgICAgKiBAcGFyYW0gICBjYWxsYmFjayAgQ2FsbGJhY2tcclxuICAgICAqIEByZXR1cm4gICAgICAgICAgICBEaXNwb3NlciBmb3IgZXZlbnRcclxuICAgICAqL1xyXG4gICAgb25Qcml2YXRlKGtleSwgY2FsbGJhY2spIHtcclxuICAgICAgICBsZXQgZXZlbnRzID0gdGhpcy5fcHJpdmF0ZVNldHRpbmdFdmVudHNba2V5XTtcclxuICAgICAgICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgZXZlbnRzID0gdGhpcy5fcHJpdmF0ZVNldHRpbmdFdmVudHNba2V5XSA9IFtdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBldmVudHMucHVzaChjYWxsYmFjayk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBEaXNwb3NlcigoKSA9PiB7XHJcbiAgICAgICAgICAgICRhcnJheS5yZW1vdmVGaXJzdChldmVudHMsIGNhbGxiYWNrKTtcclxuICAgICAgICAgICAgaWYgKGV2ZW50cy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9wcml2YXRlU2V0dGluZ0V2ZW50c1trZXldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEBpZ25vcmVcclxuICAgICAqL1xyXG4gICAgZ2V0UmF3KGtleSwgZmFsbGJhY2spIHtcclxuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuX3NldHRpbmdzW2tleV07XHJcbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbGxiYWNrO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGdldChrZXksIGZhbGxiYWNrKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0UmF3KGtleSwgZmFsbGJhY2spO1xyXG4gICAgfVxyXG4gICAgX3NlbmRLZXlFdmVudChrZXksIHZhbHVlKSB7XHJcbiAgICAgICAgY29uc3QgZXZlbnRzID0gdGhpcy5fc2V0dGluZ0V2ZW50c1trZXldO1xyXG4gICAgICAgIGlmIChldmVudHMgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAkYXJyYXkuZWFjaChldmVudHMsIChjYWxsYmFjaykgPT4ge1xyXG4gICAgICAgICAgICAgICAgY2FsbGJhY2sodmFsdWUsIHRoaXMsIGtleSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIF9zZW5kUHJpdmF0ZUtleUV2ZW50KGtleSwgdmFsdWUpIHtcclxuICAgICAgICBjb25zdCBldmVudHMgPSB0aGlzLl9wcml2YXRlU2V0dGluZ0V2ZW50c1trZXldO1xyXG4gICAgICAgIGlmIChldmVudHMgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAkYXJyYXkuZWFjaChldmVudHMsIChjYWxsYmFjaykgPT4ge1xyXG4gICAgICAgICAgICAgICAgY2FsbGJhY2sodmFsdWUsIHRoaXMsIGtleSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQGlnbm9yZVxyXG4gICAgICovXHJcbiAgICBfc2V0UmF3KGtleSwgb2xkLCB2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMuX3ByZXZTZXR0aW5nc1trZXldID0gb2xkO1xyXG4gICAgICAgIHRoaXMuX3NlbmRLZXlFdmVudChrZXksIHZhbHVlKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQGlnbm9yZVxyXG4gICAgICovXHJcbiAgICBzZXRSYXcoa2V5LCB2YWx1ZSkge1xyXG4gICAgICAgIGNvbnN0IG9sZCA9IHRoaXMuX3NldHRpbmdzW2tleV07XHJcbiAgICAgICAgdGhpcy5fc2V0dGluZ3Nba2V5XSA9IHZhbHVlO1xyXG4gICAgICAgIGlmIChvbGQgIT09IHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3NldFJhdyhrZXksIG9sZCwgdmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQGlnbm9yZVxyXG4gICAgICovXHJcbiAgICBfc2V0KGtleSwgdmFsdWUpIHtcclxuICAgICAgICBjb25zdCBvbGQgPSB0aGlzLl9zZXR0aW5nc1trZXldO1xyXG4gICAgICAgIHRoaXMuX3NldHRpbmdzW2tleV0gPSB2YWx1ZTtcclxuICAgICAgICBpZiAob2xkICE9PSB2YWx1ZSkge1xyXG4gICAgICAgICAgICB0aGlzLl9zZXRSYXcoa2V5LCBvbGQsIHZhbHVlKTtcclxuICAgICAgICAgICAgdGhpcy5fbWFya0RpcnR5S2V5KGtleSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgX3N0b3BBbmltYXRpb24oa2V5KSB7XHJcbiAgICAgICAgY29uc3QgYW5pbWF0aW9uID0gdGhpcy5fYW5pbWF0aW5nU2V0dGluZ3Nba2V5XTtcclxuICAgICAgICBpZiAoYW5pbWF0aW9uKSB7XHJcbiAgICAgICAgICAgIC0tdGhpcy5fcGxheWluZ0FuaW1hdGlvbnM7XHJcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9hbmltYXRpbmdTZXR0aW5nc1trZXldO1xyXG4gICAgICAgICAgICBhbmltYXRpb24uc3RvcCgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyBhIHNldHRpbmcgYHZhbHVlYCBmb3IgdGhlIHNwZWNpZmllZCBga2V5YCwgYW5kIHJldHVybnMgdGhlIHNhbWUgYHZhbHVlYC5cclxuICAgICAqXHJcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL3d3dy5hbWNoYXJ0cy5jb20vZG9jcy92NS9jb25jZXB0cy9zZXR0aW5ncy99IGZvciBtb3JlIGluZm9cclxuICAgICAqIEBwYXJhbSAgIGtleSAgICAgICBTZXR0aW5nIGtleVxyXG4gICAgICogQHBhcmFtICAgdmFsdWUgICAgIFNldHRpbmcgdmFsdWVcclxuICAgICAqIEByZXR1cm4gICAgICAgICAgICBTZXR0aW5nIHZhbHVlXHJcbiAgICAgKi9cclxuICAgIHNldChrZXksIHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5fc2V0KGtleSwgdmFsdWUpO1xyXG4gICAgICAgIHRoaXMuX3N0b3BBbmltYXRpb24oa2V5KTtcclxuICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZXMgYSBzZXR0aW5nIHZhbHVlIGZvciB0aGUgc3BlY2lmaWVkIGBrZXlgO1xyXG4gICAgICpcclxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vd3d3LmFtY2hhcnRzLmNvbS9kb2NzL3Y1L2NvbmNlcHRzL3NldHRpbmdzL30gZm9yIG1vcmUgaW5mb1xyXG4gICAgICogQHBhcmFtICAga2V5ICAgICAgIFNldHRpbmcga2V5XHJcbiAgICAgKi9cclxuICAgIHJlbW92ZShrZXkpIHtcclxuICAgICAgICBpZiAoa2V5IGluIHRoaXMuX3NldHRpbmdzKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3ByZXZTZXR0aW5nc1trZXldID0gdGhpcy5fc2V0dGluZ3Nba2V5XTtcclxuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX3NldHRpbmdzW2tleV07XHJcbiAgICAgICAgICAgIHRoaXMuX3NlbmRLZXlFdmVudChrZXksIHVuZGVmaW5lZCk7XHJcbiAgICAgICAgICAgIHRoaXMuX21hcmtEaXJ0eUtleShrZXkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9zdG9wQW5pbWF0aW9uKGtleSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZXMgYWxsIGtleXM7XHJcbiAgICAgKlxyXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly93d3cuYW1jaGFydHMuY29tL2RvY3MvdjUvY29uY2VwdHMvc2V0dGluZ3MvfSBmb3IgbW9yZSBpbmZvXHJcbiAgICAgKi9cclxuICAgIHJlbW92ZUFsbCgpIHtcclxuICAgICAgICAkYXJyYXkuZWFjaCgkb2JqZWN0LmtleXModGhpcy5fc2V0dGluZ3MpLCAoa2V5KSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlKGtleSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSB2YWx1ZSBvZiBhIHByaXZhdGUgc2V0dGluZy5cclxuICAgICAqXHJcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL3d3dy5hbWNoYXJ0cy5jb20vZG9jcy92NS9jb25jZXB0cy9zZXR0aW5ncy8jUHJpdmF0ZV9zZXR0aW5nc30gZm9yIG1vcmUgaW5mb1xyXG4gICAgICovXHJcbiAgICBnZXRQcml2YXRlKGtleSwgZmFsbGJhY2spIHtcclxuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuX3ByaXZhdGVTZXR0aW5nc1trZXldO1xyXG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxsYmFjaztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEBpZ25vcmVcclxuICAgICAqL1xyXG4gICAgX3NldFByaXZhdGVSYXcoa2V5LCBvbGQsIHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5fcHJldlByaXZhdGVTZXR0aW5nc1trZXldID0gb2xkO1xyXG4gICAgICAgIHRoaXMuX3NlbmRQcml2YXRlS2V5RXZlbnQoa2V5LCB2YWx1ZSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEBpZ25vcmVcclxuICAgICAqL1xyXG4gICAgc2V0UHJpdmF0ZVJhdyhrZXksIHZhbHVlKSB7XHJcbiAgICAgICAgY29uc3Qgb2xkID0gdGhpcy5fcHJpdmF0ZVNldHRpbmdzW2tleV07XHJcbiAgICAgICAgdGhpcy5fcHJpdmF0ZVNldHRpbmdzW2tleV0gPSB2YWx1ZTtcclxuICAgICAgICBpZiAob2xkICE9PSB2YWx1ZSkge1xyXG4gICAgICAgICAgICB0aGlzLl9zZXRQcml2YXRlUmF3KGtleSwgb2xkLCB2YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAaWdub3JlXHJcbiAgICAgKi9cclxuICAgIF9zZXRQcml2YXRlKGtleSwgdmFsdWUpIHtcclxuICAgICAgICBjb25zdCBvbGQgPSB0aGlzLl9wcml2YXRlU2V0dGluZ3Nba2V5XTtcclxuICAgICAgICB0aGlzLl9wcml2YXRlU2V0dGluZ3Nba2V5XSA9IHZhbHVlO1xyXG4gICAgICAgIGlmIChvbGQgIT09IHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3NldFByaXZhdGVSYXcoa2V5LCBvbGQsIHZhbHVlKTtcclxuICAgICAgICAgICAgdGhpcy5fbWFya0RpcnR5UHJpdmF0ZUtleShrZXkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIF9zdG9wQW5pbWF0aW9uUHJpdmF0ZShrZXkpIHtcclxuICAgICAgICBjb25zdCBhbmltYXRpb24gPSB0aGlzLl9hbmltYXRpbmdQcml2YXRlU2V0dGluZ3Nba2V5XTtcclxuICAgICAgICBpZiAoYW5pbWF0aW9uKSB7XHJcbiAgICAgICAgICAgIC0tdGhpcy5fcGxheWluZ0FuaW1hdGlvbnM7XHJcbiAgICAgICAgICAgIGFuaW1hdGlvbi5zdG9wKCk7XHJcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9hbmltYXRpbmdQcml2YXRlU2V0dGluZ3Nba2V5XTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEBpZ25vcmVcclxuICAgICAqL1xyXG4gICAgc2V0UHJpdmF0ZShrZXksIHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5fc2V0UHJpdmF0ZShrZXksIHZhbHVlKTtcclxuICAgICAgICB0aGlzLl9zdG9wQW5pbWF0aW9uUHJpdmF0ZShrZXkpO1xyXG4gICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQGlnbm9yZVxyXG4gICAgICovXHJcbiAgICByZW1vdmVQcml2YXRlKGtleSkge1xyXG4gICAgICAgIGlmIChrZXkgaW4gdGhpcy5fcHJpdmF0ZVNldHRpbmdzKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3ByZXZQcml2YXRlU2V0dGluZ3Nba2V5XSA9IHRoaXMuX3ByaXZhdGVTZXR0aW5nc1trZXldO1xyXG4gICAgICAgICAgICBkZWxldGUgdGhpcy5fcHJpdmF0ZVNldHRpbmdzW2tleV07XHJcbiAgICAgICAgICAgIHRoaXMuX21hcmtEaXJ0eVByaXZhdGVLZXkoa2V5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fc3RvcEFuaW1hdGlvblByaXZhdGUoa2V5KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyBtdWx0aXBsZSBzZXR0aW5ncyBhdCBvbmNlLlxyXG4gICAgICpcclxuICAgICAqIGBzZXR0aW5nc2AgbXVzdCBiZSBhbiBvYmplY3Qgd2l0aCBrZXk6IHZhbHVlIHBhaXJzLlxyXG4gICAgICpcclxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vd3d3LmFtY2hhcnRzLmNvbS9kb2NzL3Y1L2NvbmNlcHRzL3NldHRpbmdzL30gZm9yIG1vcmUgaW5mb1xyXG4gICAgICogQHBhcmFtIHNldHRpbmdzIFNldHRpbmdzXHJcbiAgICAgKi9cclxuICAgIHNldEFsbChzZXR0aW5ncykge1xyXG4gICAgICAgICRvYmplY3QuZWFjaChzZXR0aW5ncywgKGtleSwgdmFsdWUpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5zZXQoa2V5LCB2YWx1ZSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEFuaW1hdGVzIHNldHRpbmcgdmFsdWVzIGZyb20gY3VycmVudC9zdGFydCB2YWx1ZXMgdG8gbmV3IG9uZXMuXHJcbiAgICAgKlxyXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly93d3cuYW1jaGFydHMuY29tL2RvY3MvdjUvY29uY2VwdHMvYW5pbWF0aW9ucy8jQW5pbWF0aW5nX3NldHRpbmdzfSBmb3IgbW9yZSBpbmZvXHJcbiAgICAgKiBAcGFyYW0gICBvcHRpb25zICBBbmltYXRpb24gb3B0aW9uc1xyXG4gICAgICogQHJldHVybiAgICAgICAgICAgQW5pbWF0aW9uIG9iamVjdFxyXG4gICAgICovXHJcbiAgICBhbmltYXRlKG9wdGlvbnMpIHtcclxuICAgICAgICBjb25zdCBrZXkgPSBvcHRpb25zLmtleTtcclxuICAgICAgICBjb25zdCB0byA9IG9wdGlvbnMudG87XHJcbiAgICAgICAgY29uc3QgZHVyYXRpb24gPSBvcHRpb25zLmR1cmF0aW9uIHx8IDA7XHJcbiAgICAgICAgY29uc3QgbG9vcHMgPSBvcHRpb25zLmxvb3BzIHx8IDE7XHJcbiAgICAgICAgY29uc3QgZnJvbSA9IChvcHRpb25zLmZyb20gPT09IHVuZGVmaW5lZCA/IHRoaXMuZ2V0KGtleSkgOiBvcHRpb25zLmZyb20pO1xyXG4gICAgICAgIGNvbnN0IGVhc2luZyA9IChvcHRpb25zLmVhc2luZyA9PT0gdW5kZWZpbmVkID8gJGVhc2UubGluZWFyIDogb3B0aW9ucy5lYXNpbmcpO1xyXG4gICAgICAgIGlmIChkdXJhdGlvbiA9PT0gMCkge1xyXG4gICAgICAgICAgICB0aGlzLnNldChrZXksIHRvKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmIChmcm9tID09PSB1bmRlZmluZWQgfHwgZnJvbSA9PT0gdG8pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2V0KGtleSwgdG8pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZXQoa2V5LCBmcm9tKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGFuaW1hdGlvbiA9IHRoaXMuX2FuaW1hdGluZ1NldHRpbmdzW2tleV0gPSBuZXcgQW5pbWF0aW9uKHRoaXMsIGZyb20sIHRvLCBkdXJhdGlvbiwgZWFzaW5nLCBsb29wcywgdGhpcy5fYW5pbWF0aW9uVGltZSgpKTtcclxuICAgICAgICAgICAgICAgICsrdGhpcy5fcGxheWluZ0FuaW1hdGlvbnM7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zdGFydEFuaW1hdGlvbigpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFuaW1hdGlvbjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBhbmltYXRpb24gPSBuZXcgQW5pbWF0aW9uKHRoaXMsIGZyb20sIHRvLCBkdXJhdGlvbiwgZWFzaW5nLCBsb29wcywgbnVsbCk7XHJcbiAgICAgICAgYW5pbWF0aW9uLnN0b3AoKTtcclxuICAgICAgICByZXR1cm4gYW5pbWF0aW9uO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAaWdub3JlXHJcbiAgICAgKi9cclxuICAgIGFuaW1hdGVQcml2YXRlKG9wdGlvbnMpIHtcclxuICAgICAgICBjb25zdCBrZXkgPSBvcHRpb25zLmtleTtcclxuICAgICAgICBjb25zdCB0byA9IG9wdGlvbnMudG87XHJcbiAgICAgICAgY29uc3QgZHVyYXRpb24gPSBvcHRpb25zLmR1cmF0aW9uIHx8IDA7XHJcbiAgICAgICAgY29uc3QgbG9vcHMgPSBvcHRpb25zLmxvb3BzIHx8IDE7XHJcbiAgICAgICAgY29uc3QgZnJvbSA9IChvcHRpb25zLmZyb20gPT09IHVuZGVmaW5lZCA/IHRoaXMuZ2V0UHJpdmF0ZShrZXkpIDogb3B0aW9ucy5mcm9tKTtcclxuICAgICAgICBjb25zdCBlYXNpbmcgPSAob3B0aW9ucy5lYXNpbmcgPT09IHVuZGVmaW5lZCA/ICRlYXNlLmxpbmVhciA6IG9wdGlvbnMuZWFzaW5nKTtcclxuICAgICAgICBpZiAoZHVyYXRpb24gPT09IDApIHtcclxuICAgICAgICAgICAgdGhpcy5zZXRQcml2YXRlKGtleSwgdG8pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKGZyb20gPT09IHVuZGVmaW5lZCB8fCBmcm9tID09PSB0bykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZXRQcml2YXRlKGtleSwgdG8pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZXRQcml2YXRlKGtleSwgZnJvbSk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBhbmltYXRpb24gPSB0aGlzLl9hbmltYXRpbmdQcml2YXRlU2V0dGluZ3Nba2V5XSA9IG5ldyBBbmltYXRpb24odGhpcywgZnJvbSwgdG8sIGR1cmF0aW9uLCBlYXNpbmcsIGxvb3BzLCB0aGlzLl9hbmltYXRpb25UaW1lKCkpO1xyXG4gICAgICAgICAgICAgICAgKyt0aGlzLl9wbGF5aW5nQW5pbWF0aW9ucztcclxuICAgICAgICAgICAgICAgIHRoaXMuX3N0YXJ0QW5pbWF0aW9uKCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYW5pbWF0aW9uO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGFuaW1hdGlvbiA9IG5ldyBBbmltYXRpb24odGhpcywgZnJvbSwgdG8sIGR1cmF0aW9uLCBlYXNpbmcsIGxvb3BzLCBudWxsKTtcclxuICAgICAgICBhbmltYXRpb24uc3RvcCgpO1xyXG4gICAgICAgIHJldHVybiBhbmltYXRpb247XHJcbiAgICB9XHJcbiAgICBfZGlzcG9zZSgpIHsgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGB0cnVlYCBpZiB0aGlzIGVsZW1lbnQgaXMgZGlzcG9zZWQuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybiBEaXNwb3NlZFxyXG4gICAgICovXHJcbiAgICBpc0Rpc3Bvc2VkKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9kaXNwb3NlZDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRGlzcG9zZXMgdGhpcyBvYmplY3QuXHJcbiAgICAgKi9cclxuICAgIGRpc3Bvc2UoKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9kaXNwb3NlZCkge1xyXG4gICAgICAgICAgICB0aGlzLl9kaXNwb3NlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMuX2Rpc3Bvc2UoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEJhc2UgY2xhc3MuXHJcbiAqXHJcbiAqIEBpbXBvcnRhbnRcclxuICovXHJcbmV4cG9ydCBjbGFzcyBFbnRpdHkgZXh0ZW5kcyBTZXR0aW5ncyB7XHJcbiAgICAvKipcclxuICAgICAqIElNUE9SVEFOVCEgRG8gbm90IGluc3RhbnRpYXRlIHRoaXMgY2xhc3MgdmlhIGBuZXcgQ2xhc3MoKWAgc3ludGF4LlxyXG4gICAgICpcclxuICAgICAqIFVzZSBzdGF0aWMgbWV0aG9kIGBDbGFzcy5uZXcoKWAgaW5zdGVhZC5cclxuICAgICAqXHJcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL3d3dy5hbWNoYXJ0cy5jb20vZG9jcy92NS9nZXR0aW5nLXN0YXJ0ZWQvI05ld19lbGVtZW50X3N5bnRheH0gZm9yIG1vcmUgaW5mb1xyXG4gICAgICogQGlnbm9yZVxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3Rvcihyb290LCBzZXR0aW5ncywgaXNSZWFsLCB0ZW1wbGF0ZXMgPSBbXSkge1xyXG4gICAgICAgIHN1cGVyKHNldHRpbmdzKTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfcm9vdFwiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfdXNlcl9pZFwiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcclxuICAgICAgICB9KTsgLy8gZm9yIHRlc3RpbmcgcHVycG9zZXNcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJzdGF0ZXNcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogbmV3IFN0YXRlcyh0aGlzKVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImFkYXB0ZXJzXCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IG5ldyBBZGFwdGVycyh0aGlzKVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImV2ZW50c1wiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiB0aGlzLl9jcmVhdGVFdmVudHMoKVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl91c2VyUHJpdmF0ZVByb3BlcnRpZXNcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZToge31cclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfZGlydHlcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZToge31cclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfZGlydHlQcml2YXRlXCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IHt9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX3RlbXBsYXRlXCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8vIFRlbXBsYXRlcyBmb3IgdGhlIHRoZW1lc1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl90ZW1wbGF0ZXNcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogW11cclxuICAgICAgICB9KTtcclxuICAgICAgICAvLyBJbnRlcm5hbCB0ZW1wbGF0ZXMgd2hpY2ggY2FuIGJlIG92ZXJyaWRkZW4gYnkgdGhlIHVzZXIncyB0ZW1wbGF0ZXNcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfaW50ZXJuYWxUZW1wbGF0ZXNcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLy8gRGVmYXVsdCB0aGVtZXMgd2hpY2ggY2FuIGJlIG92ZXJyaWRkZW4gYnkgdGhlIHVzZXIncyB0aGVtZXNcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfZGVmYXVsdFRoZW1lc1wiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiBbXVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8vIERpc3Bvc2VycyBmb3IgYWxsIG9mIHRoZSB0ZW1wbGF0ZXNcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfdGVtcGxhdGVEaXNwb3NlcnNcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogW11cclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfZGlzcG9zZXJzXCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IFtdXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLy8gV2hldGhlciB0aGUgdGVtcGxhdGUgc2V0dXAgZnVuY3Rpb24gc2hvdWxkIGJlIHJ1blxyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9ydW5TZXR1cFwiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX2Rpc3Bvc2VyUHJvcGVydGllc1wiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiB7fVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGlmICghaXNSZWFsKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIllvdSBjYW5ub3QgdXNlIGBuZXcgQ2xhc3MoKWAsIGluc3RlYWQgdXNlIGBDbGFzcy5uZXcoKWBcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX3Jvb3QgPSByb290O1xyXG4gICAgICAgIHRoaXMuX2ludGVybmFsVGVtcGxhdGVzID0gdGVtcGxhdGVzO1xyXG4gICAgICAgIGlmIChzZXR0aW5ncy5pZCkge1xyXG4gICAgICAgICAgICB0aGlzLl9yZWdpc3RlcklkKHNldHRpbmdzLmlkKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFVzZSB0aGlzIG1ldGhvZCB0byBjcmVhdGUgYW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcy5cclxuICAgICAqXHJcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL3d3dy5hbWNoYXJ0cy5jb20vZG9jcy92NS9nZXR0aW5nLXN0YXJ0ZWQvI05ld19lbGVtZW50X3N5bnRheH0gZm9yIG1vcmUgaW5mb1xyXG4gICAgICogQHBhcmFtICAgcm9vdCAgICAgIFJvb3QgZWxlbWVudFxyXG4gICAgICogQHBhcmFtICAgc2V0dGluZ3MgIFNldHRpbmdzXHJcbiAgICAgKiBAcGFyYW0gICB0ZW1wbGF0ZSAgVGVtcGxhdGVcclxuICAgICAqIEByZXR1cm4gICAgICAgICAgICBJbnN0YW50aWF0ZWQgb2JqZWN0XHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBuZXcocm9vdCwgc2V0dGluZ3MsIHRlbXBsYXRlKSB7XHJcbiAgICAgICAgY29uc3QgeCA9IChuZXcgdGhpcyhyb290LCBzZXR0aW5ncywgdHJ1ZSkpO1xyXG4gICAgICAgIHguX3RlbXBsYXRlID0gdGVtcGxhdGU7XHJcbiAgICAgICAgeC5fYWZ0ZXJOZXcoKTtcclxuICAgICAgICByZXR1cm4geDtcclxuICAgIH1cclxuICAgIHN0YXRpYyBfbmV3KHJvb3QsIHNldHRpbmdzLCB0ZW1wbGF0ZXMgPSBbXSkge1xyXG4gICAgICAgIGNvbnN0IHggPSAobmV3IHRoaXMocm9vdCwgc2V0dGluZ3MsIHRydWUsIHRlbXBsYXRlcykpO1xyXG4gICAgICAgIHguX2FmdGVyTmV3KCk7XHJcbiAgICAgICAgcmV0dXJuIHg7XHJcbiAgICB9XHJcbiAgICBfYWZ0ZXJOZXcoKSB7XHJcbiAgICAgICAgdGhpcy5fY2hlY2tEaXJ0eSgpO1xyXG4gICAgICAgIGxldCBzaG91bGRBcHBseSA9IGZhbHNlO1xyXG4gICAgICAgIGNvbnN0IHRlbXBsYXRlID0gdGhpcy5fdGVtcGxhdGU7XHJcbiAgICAgICAgaWYgKHRlbXBsYXRlKSB7XHJcbiAgICAgICAgICAgIHNob3VsZEFwcGx5ID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGVtcGxhdGUuX3NldE9iamVjdFRlbXBsYXRlKHRoaXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAkYXJyYXkuZWFjaCh0aGlzLl9pbnRlcm5hbFRlbXBsYXRlcywgKHRlbXBsYXRlKSA9PiB7XHJcbiAgICAgICAgICAgIHNob3VsZEFwcGx5ID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGVtcGxhdGUuX3NldE9iamVjdFRlbXBsYXRlKHRoaXMpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGlmIChzaG91bGRBcHBseSkge1xyXG4gICAgICAgICAgICB0aGlzLl9hcHBseVRlbXBsYXRlcyhmYWxzZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuc3RhdGVzLmNyZWF0ZShcImRlZmF1bHRcIiwge30pO1xyXG4gICAgICAgIHRoaXMuX3NldERlZmF1bHRzKCk7XHJcbiAgICB9XHJcbiAgICAvLyBUaGlzIGlzIHRoZSBzYW1lIGFzIF9hZnRlck5ldywgZXhjZXB0IGl0IGFsc28gYXBwbGllcyB0aGUgdGhlbWVzLlxyXG4gICAgLy8gVGhpcyBzaG91bGQgb25seSBiZSB1c2VkIGZvciBjbGFzc2VzIHdoaWNoIGRvbid0IGhhdmUgYSBwYXJlbnQgKGJlY2F1c2UgdGhleSBleHRlbmQgZnJvbSBFbnRpdHkgYW5kIG5vdCBTcHJpdGUpLlxyXG4gICAgX2FmdGVyTmV3QXBwbHlUaGVtZXMoKSB7XHJcbiAgICAgICAgdGhpcy5fY2hlY2tEaXJ0eSgpO1xyXG4gICAgICAgIGNvbnN0IHRlbXBsYXRlID0gdGhpcy5fdGVtcGxhdGU7XHJcbiAgICAgICAgaWYgKHRlbXBsYXRlKSB7XHJcbiAgICAgICAgICAgIHRlbXBsYXRlLl9zZXRPYmplY3RUZW1wbGF0ZSh0aGlzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgJGFycmF5LmVhY2godGhpcy5faW50ZXJuYWxUZW1wbGF0ZXMsICh0ZW1wbGF0ZSkgPT4ge1xyXG4gICAgICAgICAgICB0ZW1wbGF0ZS5fc2V0T2JqZWN0VGVtcGxhdGUodGhpcyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5zdGF0ZXMuY3JlYXRlKFwiZGVmYXVsdFwiLCB7fSk7XHJcbiAgICAgICAgdGhpcy5fc2V0RGVmYXVsdHMoKTtcclxuICAgICAgICB0aGlzLl9hcHBseVRoZW1lcygpO1xyXG4gICAgfVxyXG4gICAgX2NyZWF0ZUV2ZW50cygpIHtcclxuICAgICAgICByZXR1cm4gbmV3IEV2ZW50RGlzcGF0Y2hlcigpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAaWdub3JlXHJcbiAgICAgKi9cclxuICAgIGdldCBjbGFzc05hbWVzKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLmNsYXNzTmFtZXM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEBpZ25vcmVcclxuICAgICAqL1xyXG4gICAgZ2V0IGNsYXNzTmFtZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci5jbGFzc05hbWU7XHJcbiAgICB9XHJcbiAgICBfc2V0RGVmYXVsdHMoKSB7XHJcbiAgICB9XHJcbiAgICBfc2V0RGVmYXVsdChrZXksIHZhbHVlKSB7XHJcbiAgICAgICAgaWYgKCEoa2V5IGluIHRoaXMuX3NldHRpbmdzKSkge1xyXG4gICAgICAgICAgICBzdXBlci5zZXQoa2V5LCB2YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgX3NldFJhd0RlZmF1bHQoa2V5LCB2YWx1ZSkge1xyXG4gICAgICAgIGlmICghKGtleSBpbiB0aGlzLl9zZXR0aW5ncykpIHtcclxuICAgICAgICAgICAgc3VwZXIuc2V0UmF3KGtleSwgdmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIF9jbGVhckRpcnR5KCkge1xyXG4gICAgICAgICRvYmplY3Qua2V5cyh0aGlzLl9kaXJ0eSkuZm9yRWFjaCgoa2V5KSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuX2RpcnR5W2tleV0gPSBmYWxzZTtcclxuICAgICAgICB9KTtcclxuICAgICAgICAkb2JqZWN0LmtleXModGhpcy5fZGlydHlQcml2YXRlKS5mb3JFYWNoKChrZXkpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5fZGlydHlQcml2YXRlW2tleV0gPSBmYWxzZTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQGlnbm9yZVxyXG4gICAgICovXHJcbiAgICBpc0RpcnR5KGtleSkge1xyXG4gICAgICAgIHJldHVybiAhIXRoaXMuX2RpcnR5W2tleV07XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEBpZ25vcmVcclxuICAgICAqL1xyXG4gICAgaXNQcml2YXRlRGlydHkoa2V5KSB7XHJcbiAgICAgICAgcmV0dXJuICEhdGhpcy5fZGlydHlQcml2YXRlW2tleV07XHJcbiAgICB9XHJcbiAgICBfbWFya0RpcnR5S2V5KGtleSkge1xyXG4gICAgICAgIHRoaXMuX2RpcnR5W2tleV0gPSB0cnVlO1xyXG4gICAgICAgIHN1cGVyLl9tYXJrRGlydHlLZXkoa2V5KTtcclxuICAgIH1cclxuICAgIF9tYXJrRGlydHlQcml2YXRlS2V5KGtleSkge1xyXG4gICAgICAgIHRoaXMuX2RpcnR5UHJpdmF0ZVtrZXldID0gdHJ1ZTtcclxuICAgICAgICBzdXBlci5fbWFya0RpcnR5S2V5KGtleSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENoZWNrcyBpZiBlbGVtZW50IGlzIG9mIGNlcnRhaW4gY2xhc3MgKG9yIGluaGVyaXRzIG9uZSkuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtICAgdHlwZSAgQ2xhc3MgbmFtZSB0byBjaGVja1xyXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gSXMgb2YgY2xhc3M/XHJcbiAgICAgKi9cclxuICAgIGlzVHlwZSh0eXBlKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xhc3NOYW1lcy5pbmRleE9mKHR5cGUpICE9PSAtMTtcclxuICAgIH1cclxuICAgIF9wdXNoUHJvcGVydHlEaXNwb3NlcihrZXksIGRpc3Bvc2VyKSB7XHJcbiAgICAgICAgbGV0IGRpc3Bvc2VycyA9IHRoaXMuX2Rpc3Bvc2VyUHJvcGVydGllc1trZXldO1xyXG4gICAgICAgIGlmIChkaXNwb3NlcnMgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBkaXNwb3NlcnMgPSB0aGlzLl9kaXNwb3NlclByb3BlcnRpZXNba2V5XSA9IFtdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBkaXNwb3NlcnMucHVzaChkaXNwb3Nlcik7XHJcbiAgICAgICAgcmV0dXJuIGRpc3Bvc2VyO1xyXG4gICAgfVxyXG4gICAgX2Rpc3Bvc2VQcm9wZXJ0eShrZXkpIHtcclxuICAgICAgICBjb25zdCBkaXNwb3NlcnMgPSB0aGlzLl9kaXNwb3NlclByb3BlcnRpZXNba2V5XTtcclxuICAgICAgICBpZiAoZGlzcG9zZXJzICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgJGFycmF5LmVhY2goZGlzcG9zZXJzLCAoZGlzcG9zZXIpID0+IHtcclxuICAgICAgICAgICAgICAgIGRpc3Bvc2VyLmRpc3Bvc2UoKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9kaXNwb3NlclByb3BlcnRpZXNba2V5XTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEB0b2RvIG5lZWRzIGRlc2NyaXB0aW9uXHJcbiAgICAgKiBAcGFyYW0gIHZhbHVlICBUZW1wbGF0ZVxyXG4gICAgICovXHJcbiAgICBzZXQgdGVtcGxhdGUodmFsdWUpIHtcclxuICAgICAgICBjb25zdCB0ZW1wbGF0ZSA9IHRoaXMuX3RlbXBsYXRlO1xyXG4gICAgICAgIGlmICh0ZW1wbGF0ZSAhPT0gdmFsdWUpIHtcclxuICAgICAgICAgICAgdGhpcy5fdGVtcGxhdGUgPSB2YWx1ZTtcclxuICAgICAgICAgICAgaWYgKHRlbXBsYXRlKSB7XHJcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZS5fcmVtb3ZlT2JqZWN0VGVtcGxhdGUodGhpcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZS5fc2V0T2JqZWN0VGVtcGxhdGUodGhpcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fYXBwbHlUZW1wbGF0ZXMoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBnZXQgdGVtcGxhdGUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RlbXBsYXRlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAaWdub3JlXHJcbiAgICAgKi9cclxuICAgIG1hcmtEaXJ0eSgpIHtcclxuICAgICAgICB0aGlzLl9yb290Ll9hZGREaXJ0eUVudGl0eSh0aGlzKTtcclxuICAgIH1cclxuICAgIF9zdGFydEFuaW1hdGlvbigpIHtcclxuICAgICAgICB0aGlzLl9yb290Ll9hZGRBbmltYXRpb24odGhpcyk7XHJcbiAgICB9XHJcbiAgICBfYW5pbWF0aW9uVGltZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fcm9vdC5hbmltYXRpb25UaW1lO1xyXG4gICAgfVxyXG4gICAgX2FwcGx5U3RhdGUoX25hbWUpIHsgfVxyXG4gICAgX2FwcGx5U3RhdGVBbmltYXRlZChfbmFtZSwgX2R1cmF0aW9uKSB7IH1cclxuICAgIGdldChrZXksIGZhbGxiYWNrKSB7XHJcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLmFkYXB0ZXJzLmZvbGQoa2V5LCB0aGlzLl9zZXR0aW5nc1trZXldKTtcclxuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsbGJhY2s7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAaWdub3JlXHJcbiAgICAgKi9cclxuICAgIGlzVXNlclNldHRpbmcoa2V5KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3VzZXJQcm9wZXJ0aWVzW2tleV0gfHwgZmFsc2U7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNldHMgYSBzZXR0aW5nIGB2YWx1ZWAgZm9yIHRoZSBzcGVjaWZpZWQgYGtleWAsIGFuZCByZXR1cm5zIHRoZSBzYW1lIGB2YWx1ZWAuXHJcbiAgICAgKlxyXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly93d3cuYW1jaGFydHMuY29tL2RvY3MvdjUvY29uY2VwdHMvc2V0dGluZ3MvfSBmb3IgbW9yZSBpbmZvXHJcbiAgICAgKiBAcGFyYW0gICBrZXkgICAgICAgU2V0dGluZyBrZXlcclxuICAgICAqIEBwYXJhbSAgIHZhbHVlICAgICBTZXR0aW5nIHZhbHVlXHJcbiAgICAgKiBAcmV0dXJuICAgICAgICAgICAgU2V0dGluZyB2YWx1ZVxyXG4gICAgICovXHJcbiAgICBzZXQoa2V5LCB2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMuX3VzZXJQcm9wZXJ0aWVzW2tleV0gPSB0cnVlO1xyXG4gICAgICAgIHJldHVybiBzdXBlci5zZXQoa2V5LCB2YWx1ZSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEBpZ25vcmVcclxuICAgICAqL1xyXG4gICAgc2V0UmF3KGtleSwgdmFsdWUpIHtcclxuICAgICAgICB0aGlzLl91c2VyUHJvcGVydGllc1trZXldID0gdHJ1ZTtcclxuICAgICAgICBzdXBlci5zZXRSYXcoa2V5LCB2YWx1ZSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNldHMgYSBzZXR0aW5nIGB2YWx1ZWAgZm9yIHRoZSBzcGVjaWZpZWQgYGtleWAgb25seSBpZiB0aGUgdmFsdWUgZm9yIHRoaXMga2V5IHdhcyBub3Qgc2V0IHByZXZpb3VzbHkgdXNpbmcgc2V0IG1ldGhvZCwgYW5kIHJldHVybnMgdGhlIHNhbWUgYHZhbHVlYC5cclxuICAgICAqXHJcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL3d3dy5hbWNoYXJ0cy5jb20vZG9jcy92NS9jb25jZXB0cy9zZXR0aW5ncy99IGZvciBtb3JlIGluZm9cclxuICAgICAqIEBwYXJhbSAgIGtleSAgICAgICBTZXR0aW5nIGtleVxyXG4gICAgICogQHBhcmFtICAgdmFsdWUgICAgIFNldHRpbmcgdmFsdWVcclxuICAgICAqIEByZXR1cm4gICAgICAgICAgICBTZXR0aW5nIHZhbHVlXHJcbiAgICAgKi9cclxuICAgIF9zZXRTb2Z0KGtleSwgdmFsdWUpIHtcclxuICAgICAgICBpZiAoIXRoaXMuX3VzZXJQcm9wZXJ0aWVzW2tleV0pIHtcclxuICAgICAgICAgICAgcmV0dXJuIHN1cGVyLnNldChrZXksIHZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmVzIGEgc2V0dGluZyB2YWx1ZSBmb3IgdGhlIHNwZWNpZmllZCBga2V5YC5cclxuICAgICAqXHJcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL3d3dy5hbWNoYXJ0cy5jb20vZG9jcy92NS9jb25jZXB0cy9zZXR0aW5ncy99IGZvciBtb3JlIGluZm9cclxuICAgICAqIEBwYXJhbSAgIGtleSAgICAgICBTZXR0aW5nIGtleVxyXG4gICAgICovXHJcbiAgICByZW1vdmUoa2V5KSB7XHJcbiAgICAgICAgZGVsZXRlIHRoaXMuX3VzZXJQcm9wZXJ0aWVzW2tleV07XHJcbiAgICAgICAgdGhpcy5fcmVtb3ZlVGVtcGxhdGVQcm9wZXJ0eShrZXkpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAaWdub3JlXHJcbiAgICAgKi9cclxuICAgIHNldFByaXZhdGUoa2V5LCB2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMuX3VzZXJQcml2YXRlUHJvcGVydGllc1trZXldID0gdHJ1ZTtcclxuICAgICAgICByZXR1cm4gc3VwZXIuc2V0UHJpdmF0ZShrZXksIHZhbHVlKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQGlnbm9yZVxyXG4gICAgICovXHJcbiAgICBzZXRQcml2YXRlUmF3KGtleSwgdmFsdWUpIHtcclxuICAgICAgICB0aGlzLl91c2VyUHJpdmF0ZVByb3BlcnRpZXNba2V5XSA9IHRydWU7XHJcbiAgICAgICAgc3VwZXIuc2V0UHJpdmF0ZVJhdyhrZXksIHZhbHVlKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQGlnbm9yZVxyXG4gICAgICovXHJcbiAgICByZW1vdmVQcml2YXRlKGtleSkge1xyXG4gICAgICAgIGRlbGV0ZSB0aGlzLl91c2VyUHJpdmF0ZVByb3BlcnRpZXNba2V5XTtcclxuICAgICAgICB0aGlzLl9yZW1vdmVUZW1wbGF0ZVByaXZhdGVQcm9wZXJ0eShrZXkpO1xyXG4gICAgfVxyXG4gICAgX3NldFRlbXBsYXRlUHJvcGVydHkodGVtcGxhdGUsIGtleSwgdmFsdWUpIHtcclxuICAgICAgICBpZiAoIXRoaXMuX3VzZXJQcm9wZXJ0aWVzW2tleV0pIHtcclxuICAgICAgICAgICAgY29uc3QgbWF0Y2ggPSB0aGlzLl9maW5kVGVtcGxhdGVCeUtleShrZXkpO1xyXG4gICAgICAgICAgICBpZiAodGVtcGxhdGUgPT09IG1hdGNoKSB7XHJcbiAgICAgICAgICAgICAgICBzdXBlci5zZXQoa2V5LCB2YWx1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBfc2V0VGVtcGxhdGVQcml2YXRlUHJvcGVydHkodGVtcGxhdGUsIGtleSwgdmFsdWUpIHtcclxuICAgICAgICBpZiAoIXRoaXMuX3VzZXJQcml2YXRlUHJvcGVydGllc1trZXldKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG1hdGNoID0gdGhpcy5fZmluZFRlbXBsYXRlQnlQcml2YXRlS2V5KGtleSk7XHJcbiAgICAgICAgICAgIGlmICh0ZW1wbGF0ZSA9PT0gbWF0Y2gpIHtcclxuICAgICAgICAgICAgICAgIHN1cGVyLnNldFByaXZhdGUoa2V5LCB2YWx1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBfcmVtb3ZlVGVtcGxhdGVQcm9wZXJ0eShrZXkpIHtcclxuICAgICAgICBpZiAoIXRoaXMuX3VzZXJQcm9wZXJ0aWVzW2tleV0pIHtcclxuICAgICAgICAgICAgY29uc3QgbWF0Y2ggPSB0aGlzLl9maW5kVGVtcGxhdGVCeUtleShrZXkpO1xyXG4gICAgICAgICAgICBpZiAobWF0Y2gpIHtcclxuICAgICAgICAgICAgICAgIC8vIFRPRE8gZG9uJ3Qgc3RvcCB0aGUgYW5pbWF0aW9uIGlmIHRoZSBwcm9wZXJ0eSBkaWRuJ3QgY2hhbmdlXHJcbiAgICAgICAgICAgICAgICBzdXBlci5zZXQoa2V5LCBtYXRjaC5fc2V0dGluZ3Nba2V5XSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBzdXBlci5yZW1vdmUoa2V5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIF9yZW1vdmVUZW1wbGF0ZVByaXZhdGVQcm9wZXJ0eShrZXkpIHtcclxuICAgICAgICBpZiAoIXRoaXMuX3VzZXJQcml2YXRlUHJvcGVydGllc1trZXldKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG1hdGNoID0gdGhpcy5fZmluZFRlbXBsYXRlQnlQcml2YXRlS2V5KGtleSk7XHJcbiAgICAgICAgICAgIGlmIChtYXRjaCkge1xyXG4gICAgICAgICAgICAgICAgLy8gVE9ETyBkb24ndCBzdG9wIHRoZSBhbmltYXRpb24gaWYgdGhlIHByb3BlcnR5IGRpZG4ndCBjaGFuZ2VcclxuICAgICAgICAgICAgICAgIHN1cGVyLnNldFByaXZhdGUoa2V5LCBtYXRjaC5fcHJpdmF0ZVNldHRpbmdzW2tleV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgc3VwZXIucmVtb3ZlUHJpdmF0ZShrZXkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgX3dhbGtQYXJlbnRzKGYpIHtcclxuICAgICAgICBmKHRoaXMuX3Jvb3QuX3Jvb3RDb250YWluZXIpO1xyXG4gICAgICAgIGYodGhpcyk7XHJcbiAgICB9XHJcbiAgICAvLyBUT0RPIGZhc3RlciB2ZXJzaW9uIG9mIHRoaXMgbWV0aG9kIHdoaWNoIGlzIHNwZWNpYWxpemVkIHRvIGp1c3QgMSBrZXlcclxuICAgIF9hcHBseVN0YXRlQnlLZXkobmFtZSkge1xyXG4gICAgICAgIGNvbnN0IG90aGVyID0gdGhpcy5zdGF0ZXMuY3JlYXRlKG5hbWUsIHt9KTtcclxuICAgICAgICBjb25zdCBzZWVuID0ge307XHJcbiAgICAgICAgdGhpcy5fZWFjaFRlbXBsYXRlKCh0ZW1wbGF0ZSkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBzdGF0ZSA9IHRlbXBsYXRlLnN0YXRlcy5sb29rdXAobmFtZSk7XHJcbiAgICAgICAgICAgIGlmIChzdGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgc3RhdGUuX2FwcGx5KG90aGVyLCBzZWVuKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgICRvYmplY3QuZWFjaChvdGhlci5fc2V0dGluZ3MsIChrZXkpID0+IHtcclxuICAgICAgICAgICAgaWYgKCFzZWVuW2tleV0gJiYgIW90aGVyLl91c2VyU2V0dGluZ3Nba2V5XSkge1xyXG4gICAgICAgICAgICAgICAgb3RoZXIucmVtb3ZlKGtleSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIF9hcHBseVRlbXBsYXRlKHRlbXBsYXRlLCBzdGF0ZSkge1xyXG4gICAgICAgIHRoaXMuX3RlbXBsYXRlRGlzcG9zZXJzLnB1c2godGVtcGxhdGUuX2FwcGx5KHRoaXMsIHN0YXRlKSk7XHJcbiAgICAgICAgJG9iamVjdC5lYWNoKHRlbXBsYXRlLl9zZXR0aW5ncywgKGtleSwgdmFsdWUpID0+IHtcclxuICAgICAgICAgICAgaWYgKCFzdGF0ZS5zZXR0aW5nc1trZXldICYmICF0aGlzLl91c2VyUHJvcGVydGllc1trZXldKSB7XHJcbiAgICAgICAgICAgICAgICBzdGF0ZS5zZXR0aW5nc1trZXldID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHN1cGVyLnNldChrZXksIHZhbHVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgICRvYmplY3QuZWFjaCh0ZW1wbGF0ZS5fcHJpdmF0ZVNldHRpbmdzLCAoa2V5LCB2YWx1ZSkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoIXN0YXRlLnByaXZhdGVTZXR0aW5nc1trZXldICYmICF0aGlzLl91c2VyUHJpdmF0ZVByb3BlcnRpZXNba2V5XSkge1xyXG4gICAgICAgICAgICAgICAgc3RhdGUucHJpdmF0ZVNldHRpbmdzW2tleV0gPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgc3VwZXIuc2V0UHJpdmF0ZShrZXksIHZhbHVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGlmICh0aGlzLl9ydW5TZXR1cCAmJiB0ZW1wbGF0ZS5zZXR1cCkge1xyXG4gICAgICAgICAgICB0aGlzLl9ydW5TZXR1cCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0ZW1wbGF0ZS5zZXR1cCh0aGlzKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENhbGxzIHRoZSBjbG9zdXJlIHdpdGggZWFjaCB0ZW1wbGF0ZSBhbmQgcmV0dXJucyB0aGUgZmlyc3QgdGVtcGxhdGUgd2hpY2ggaXMgdHJ1ZVxyXG4gICAgICovXHJcbiAgICBfZmluZFN0YXRpY1RlbXBsYXRlKGYpIHtcclxuICAgICAgICBpZiAodGhpcy5fdGVtcGxhdGUpIHtcclxuICAgICAgICAgICAgaWYgKGYodGhpcy5fdGVtcGxhdGUpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fdGVtcGxhdGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBfZWFjaFRlbXBsYXRlKGYpIHtcclxuICAgICAgICB0aGlzLl9maW5kU3RhdGljVGVtcGxhdGUoKHRlbXBsYXRlKSA9PiB7XHJcbiAgICAgICAgICAgIGYodGVtcGxhdGUpO1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLy8gX2ludGVybmFsVGVtcGxhdGVzIGlzIHNvcnRlZCB3aXRoIG1vc3Qgc3BlY2lmaWMgdG8gdGhlIHJpZ2h0XHJcbiAgICAgICAgJGFycmF5LmVhY2hSZXZlcnNlKHRoaXMuX2ludGVybmFsVGVtcGxhdGVzLCBmKTtcclxuICAgICAgICAvLyBfdGVtcGxhdGVzIGlzIHNvcnRlZCB3aXRoIG1vc3Qgc3BlY2lmaWMgdG8gdGhlIGxlZnRcclxuICAgICAgICAkYXJyYXkuZWFjaCh0aGlzLl90ZW1wbGF0ZXMsIGYpO1xyXG4gICAgfVxyXG4gICAgX2FwcGx5VGVtcGxhdGVzKHJlbW92ZSA9IHRydWUpIHtcclxuICAgICAgICBpZiAocmVtb3ZlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2Rpc3Bvc2VUZW1wbGF0ZXMoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3Qgc3RhdGUgPSB7XHJcbiAgICAgICAgICAgIHNldHRpbmdzOiB7fSxcclxuICAgICAgICAgICAgcHJpdmF0ZVNldHRpbmdzOiB7fSxcclxuICAgICAgICAgICAgc3RhdGVzOiB7fSxcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMuX2VhY2hUZW1wbGF0ZSgodGVtcGxhdGUpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5fYXBwbHlUZW1wbGF0ZSh0ZW1wbGF0ZSwgc3RhdGUpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGlmIChyZW1vdmUpIHtcclxuICAgICAgICAgICAgJG9iamVjdC5lYWNoKHRoaXMuX3NldHRpbmdzLCAoa2V5KSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX3VzZXJQcm9wZXJ0aWVzW2tleV0gJiYgIXN0YXRlLnNldHRpbmdzW2tleV0pIHtcclxuICAgICAgICAgICAgICAgICAgICBzdXBlci5yZW1vdmUoa2V5KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICRvYmplY3QuZWFjaCh0aGlzLl9wcml2YXRlU2V0dGluZ3MsIChrZXkpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5fdXNlclByaXZhdGVQcm9wZXJ0aWVzW2tleV0gJiYgIXN0YXRlLnByaXZhdGVTZXR0aW5nc1trZXldKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3VwZXIucmVtb3ZlUHJpdmF0ZShrZXkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBfZmluZFRlbXBsYXRlKGYpIHtcclxuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuX2ZpbmRTdGF0aWNUZW1wbGF0ZShmKTtcclxuICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAvLyBfaW50ZXJuYWxUZW1wbGF0ZXMgaXMgc29ydGVkIHdpdGggbW9zdCBzcGVjaWZpYyB0byB0aGUgcmlnaHRcclxuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSAkYXJyYXkuZmluZFJldmVyc2UodGhpcy5faW50ZXJuYWxUZW1wbGF0ZXMsIGYpO1xyXG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgLy8gX3RlbXBsYXRlcyBpcyBzb3J0ZWQgd2l0aCBtb3N0IHNwZWNpZmljIHRvIHRoZSBsZWZ0XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJGFycmF5LmZpbmQodGhpcy5fdGVtcGxhdGVzLCBmKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIF9maW5kVGVtcGxhdGVCeUtleShrZXkpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZmluZFRlbXBsYXRlKCh0ZW1wbGF0ZSkgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4ga2V5IGluIHRlbXBsYXRlLl9zZXR0aW5ncztcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIF9maW5kVGVtcGxhdGVCeVByaXZhdGVLZXkoa2V5KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZpbmRUZW1wbGF0ZSgodGVtcGxhdGUpID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIGtleSBpbiB0ZW1wbGF0ZS5fcHJpdmF0ZVNldHRpbmdzO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgX2Rpc3Bvc2VUZW1wbGF0ZXMoKSB7XHJcbiAgICAgICAgJGFycmF5LmVhY2godGhpcy5fdGVtcGxhdGVEaXNwb3NlcnMsIChkaXNwb3NlcikgPT4ge1xyXG4gICAgICAgICAgICBkaXNwb3Nlci5kaXNwb3NlKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5fdGVtcGxhdGVEaXNwb3NlcnMubGVuZ3RoID0gMDtcclxuICAgIH1cclxuICAgIF9yZW1vdmVUZW1wbGF0ZXMoKSB7XHJcbiAgICAgICAgJGFycmF5LmVhY2godGhpcy5fdGVtcGxhdGVzLCAodGVtcGxhdGUpID0+IHtcclxuICAgICAgICAgICAgdGVtcGxhdGUuX3JlbW92ZU9iamVjdFRlbXBsYXRlKHRoaXMpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuX3RlbXBsYXRlcy5sZW5ndGggPSAwO1xyXG4gICAgfVxyXG4gICAgX2FwcGx5VGhlbWVzKGZvcmNlID0gZmFsc2UpIHtcclxuICAgICAgICBsZXQgaXNDb25uZWN0ZWQgPSBmYWxzZTtcclxuICAgICAgICBjb25zdCBkZWZhdWx0cyA9IFtdO1xyXG4gICAgICAgIGxldCB0aGVtZXMgPSBbXTtcclxuICAgICAgICBjb25zdCB0aGVtZVRhZ3MgPSBuZXcgU2V0KCk7XHJcbiAgICAgICAgY29uc3QgdGFncyA9IHRoaXMuZ2V0KFwidGhlbWVUYWdzU2VsZlwiKTtcclxuICAgICAgICBpZiAodGFncykge1xyXG4gICAgICAgICAgICAkYXJyYXkuZWFjaCh0YWdzLCAodGFnKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGVtZVRhZ3MuYWRkKHRhZyk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl93YWxrUGFyZW50cygoZW50aXR5KSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChlbnRpdHkgPT09IHRoaXMuX3Jvb3QuX3Jvb3RDb250YWluZXIpIHtcclxuICAgICAgICAgICAgICAgIGlzQ29ubmVjdGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZW50aXR5Ll9kZWZhdWx0VGhlbWVzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgIGRlZmF1bHRzLnB1c2goZW50aXR5Ll9kZWZhdWx0VGhlbWVzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCB0aGVtZSA9IGVudGl0eS5nZXQoXCJ0aGVtZXNcIik7XHJcbiAgICAgICAgICAgIGlmICh0aGVtZSkge1xyXG4gICAgICAgICAgICAgICAgdGhlbWVzLnB1c2godGhlbWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IHRhZ3MgPSBlbnRpdHkuZ2V0KFwidGhlbWVUYWdzXCIpO1xyXG4gICAgICAgICAgICBpZiAodGFncykge1xyXG4gICAgICAgICAgICAgICAgJGFycmF5LmVhY2godGFncywgKHRhZykgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoZW1lVGFncy5hZGQodGFnKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhlbWVzID0gZGVmYXVsdHMuY29uY2F0KHRoZW1lcyk7XHJcbiAgICAgICAgdGhpcy5fcmVtb3ZlVGVtcGxhdGVzKCk7XHJcbiAgICAgICAgaWYgKGlzQ29ubmVjdGVkIHx8IGZvcmNlKSB7XHJcbiAgICAgICAgICAgICRhcnJheS5lYWNoUmV2ZXJzZSh0aGlzLmNsYXNzTmFtZXMsIChuYW1lKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBhbGxSdWxlcyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgJGFycmF5LmVhY2godGhlbWVzLCAodGhlbWVzKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgJGFycmF5LmVhY2godGhlbWVzLCAodGhlbWUpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcnVsZXMgPSB0aGVtZS5fbG9va3VwUnVsZXMobmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChydWxlcykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJGFycmF5LmVhY2hSZXZlcnNlKHJ1bGVzLCAocnVsZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG1hdGNoZXMgPSBydWxlLnRhZ3MuZXZlcnkoKHRhZykgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhlbWVUYWdzLmhhcyh0YWcpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaGVzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9ICRhcnJheS5nZXRGaXJzdFNvcnRlZEluZGV4KGFsbFJ1bGVzLCAoeCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgb3JkZXIgPSAkb3JkZXIuY29tcGFyZShydWxlLnRhZ3MubGVuZ3RoLCB4LnRhZ3MubGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcmRlciA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAkb3JkZXIuY29tcGFyZUFycmF5KHJ1bGUudGFncywgeC50YWdzLCAkb3JkZXIuY29tcGFyZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3JkZXI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbGxSdWxlcy5zcGxpY2UocmVzdWx0LmluZGV4LCAwLCBydWxlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAkYXJyYXkuZWFjaChhbGxSdWxlcywgKHJ1bGUpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl90ZW1wbGF0ZXMucHVzaChydWxlLnRlbXBsYXRlKTtcclxuICAgICAgICAgICAgICAgICAgICBydWxlLnRlbXBsYXRlLl9zZXRPYmplY3RUZW1wbGF0ZSh0aGlzKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fYXBwbHlUZW1wbGF0ZXMoKTtcclxuICAgICAgICBpZiAoaXNDb25uZWN0ZWQgfHwgZm9yY2UpIHtcclxuICAgICAgICAgICAgLy8gVGhpcyBjYXVzZXMgaXQgdG8gb25seSBydW4gdGhlIHNldHVwIGZ1bmN0aW9uIHRoZSBmaXJzdCB0aW1lIHRoYXQgdGhlIHRoZW1lcyBhcmUgYXBwbGllZFxyXG4gICAgICAgICAgICB0aGlzLl9ydW5TZXR1cCA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gaXNDb25uZWN0ZWQgfHwgZm9yY2U7XHJcbiAgICB9XHJcbiAgICBfY2hhbmdlZCgpIHsgfVxyXG4gICAgX2JlZm9yZUNoYW5nZWQoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuaXNEaXJ0eShcImlkXCIpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGlkID0gdGhpcy5nZXQoXCJpZFwiKTtcclxuICAgICAgICAgICAgaWYgKGlkKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9yZWdpc3RlcklkKGlkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBwcmV2SWQgPSB0aGlzLl9wcmV2U2V0dGluZ3MuaWQ7XHJcbiAgICAgICAgICAgIGlmIChwcmV2SWQpIHtcclxuICAgICAgICAgICAgICAgIGRlbGV0ZSByZWdpc3RyeS5lbnRpdGllc0J5SWRbcHJldklkXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIF9yZWdpc3RlcklkKGlkKSB7XHJcbiAgICAgICAgaWYgKHJlZ2lzdHJ5LmVudGl0aWVzQnlJZFtpZF0gJiYgcmVnaXN0cnkuZW50aXRpZXNCeUlkW2lkXSAhPT0gdGhpcykge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBbiBlbnRpdHkgd2l0aCBpZCBcXFwiXCIgKyBpZCArIFwiXFxcIiBhbHJlYWR5IGV4aXN0cy5cIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlZ2lzdHJ5LmVudGl0aWVzQnlJZFtpZF0gPSB0aGlzO1xyXG4gICAgfVxyXG4gICAgX2FmdGVyQ2hhbmdlZCgpIHsgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAaWdub3JlXHJcbiAgICAgKi9cclxuICAgIGFkZERpc3Bvc2VyKGRpc3Bvc2VyKSB7XHJcbiAgICAgICAgdGhpcy5fZGlzcG9zZXJzLnB1c2goZGlzcG9zZXIpO1xyXG4gICAgICAgIHJldHVybiBkaXNwb3NlcjtcclxuICAgIH1cclxuICAgIF9kaXNwb3NlKCkge1xyXG4gICAgICAgIHN1cGVyLl9kaXNwb3NlKCk7XHJcbiAgICAgICAgY29uc3QgdGVtcGxhdGUgPSB0aGlzLl90ZW1wbGF0ZTtcclxuICAgICAgICBpZiAodGVtcGxhdGUpIHtcclxuICAgICAgICAgICAgdGVtcGxhdGUuX3JlbW92ZU9iamVjdFRlbXBsYXRlKHRoaXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAkYXJyYXkuZWFjaCh0aGlzLl9pbnRlcm5hbFRlbXBsYXRlcywgKHRlbXBsYXRlKSA9PiB7XHJcbiAgICAgICAgICAgIHRlbXBsYXRlLl9yZW1vdmVPYmplY3RUZW1wbGF0ZSh0aGlzKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLl9yZW1vdmVUZW1wbGF0ZXMoKTtcclxuICAgICAgICB0aGlzLl9kaXNwb3NlVGVtcGxhdGVzKCk7XHJcbiAgICAgICAgdGhpcy5ldmVudHMuZGlzcG9zZSgpO1xyXG4gICAgICAgIHRoaXMuX2Rpc3Bvc2Vycy5mb3JFYWNoKCh4KSA9PiB7XHJcbiAgICAgICAgICAgIHguZGlzcG9zZSgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgICRvYmplY3QuZWFjaCh0aGlzLl9kaXNwb3NlclByb3BlcnRpZXMsIChfLCBkaXNwb3NlcnMpID0+IHtcclxuICAgICAgICAgICAgJGFycmF5LmVhY2goZGlzcG9zZXJzLCAoZGlzcG9zZXIpID0+IHtcclxuICAgICAgICAgICAgICAgIGRpc3Bvc2VyLmRpc3Bvc2UoKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgY29uc3QgaWQgPSB0aGlzLmdldChcImlkXCIpO1xyXG4gICAgICAgIGlmIChpZCkge1xyXG4gICAgICAgICAgICBkZWxldGUgcmVnaXN0cnkuZW50aXRpZXNCeUlkW2lkXTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYW5kIHJldHVybnMgYSBcImRpc3Bvc2FibGVcIiB0aW1lb3V0LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSAgIGZuICAgICBDYWxsYmFja1xyXG4gICAgICogQHBhcmFtICAgZGVsYXkgIERlbGF5IGluIG1pbGxpc2Vjb25kc1xyXG4gICAgICogQHJldHVybiAgICAgICAgIFRpbWVvdXQgZGlzcG9zZXJcclxuICAgICAqL1xyXG4gICAgc2V0VGltZW91dChmbiwgZGVsYXkpIHtcclxuICAgICAgICBjb25zdCBpZCA9IHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLnJlbW92ZURpc3Bvc2UoZGlzcG9zZXIpO1xyXG4gICAgICAgICAgICBmbigpO1xyXG4gICAgICAgIH0sIGRlbGF5KTtcclxuICAgICAgICBjb25zdCBkaXNwb3NlciA9IG5ldyBEaXNwb3NlcigoKSA9PiB7XHJcbiAgICAgICAgICAgIGNsZWFyVGltZW91dChpZCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5fZGlzcG9zZXJzLnB1c2goZGlzcG9zZXIpO1xyXG4gICAgICAgIHJldHVybiBkaXNwb3NlcjtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQGlnbm9yZVxyXG4gICAgICovXHJcbiAgICByZW1vdmVEaXNwb3NlKHRhcmdldCkge1xyXG4gICAgICAgIGlmICghdGhpcy5pc0Rpc3Bvc2VkKCkpIHtcclxuICAgICAgICAgICAgbGV0IGluZGV4ID0gJGFycmF5LmluZGV4T2YodGhpcy5fZGlzcG9zZXJzLCB0YXJnZXQpO1xyXG4gICAgICAgICAgICBpZiAoaW5kZXggPiAtMSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZGlzcG9zZXJzLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGFyZ2V0LmRpc3Bvc2UoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQGlnbm9yZVxyXG4gICAgICovXHJcbiAgICBoYXNUYWcodGFnKSB7XHJcbiAgICAgICAgcmV0dXJuICRhcnJheS5pbmRleE9mKHRoaXMuZ2V0KFwidGhlbWVUYWdzXCIsIFtdKSwgdGFnKSAhPT0gLTE7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEBpZ25vcmVcclxuICAgICAqL1xyXG4gICAgYWRkVGFnKHRhZykge1xyXG4gICAgICAgIGlmICghdGhpcy5oYXNUYWcodGFnKSkge1xyXG4gICAgICAgICAgICBjb25zdCB0YWdzID0gdGhpcy5nZXQoXCJ0aGVtZVRhZ3NcIiwgW10pO1xyXG4gICAgICAgICAgICB0YWdzLnB1c2godGFnKTtcclxuICAgICAgICAgICAgdGhpcy5zZXQoXCJ0aGVtZVRhZ3NcIiwgdGFncyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAaWdub3JlXHJcbiAgICAgKi9cclxuICAgIHJlbW92ZVRhZyh0YWcpIHtcclxuICAgICAgICBpZiAodGhpcy5oYXNUYWcodGFnKSkge1xyXG4gICAgICAgICAgICBjb25zdCB0YWdzID0gdGhpcy5nZXQoXCJ0aGVtZVRhZ3NcIiwgW10pO1xyXG4gICAgICAgICAgICAkYXJyYXkucmVtb3ZlKHRhZ3MsIHRhZyk7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0KFwidGhlbWVUYWdzXCIsIHRhZ3MpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIF90KHRleHQsIGxvY2FsZSwgLi4ucmVzdCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9yb290Lmxhbmd1YWdlLnRyYW5zbGF0ZSh0ZXh0LCBsb2NhbGUsIC4uLnJlc3QpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBbiBpbnN0YW5jZSBvZiBbW1Jvb3RdXSBvYmplY3QuXHJcbiAgICAgKlxyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKiBAc2luY2UgNS4wLjZcclxuICAgICAqIEByZXR1cm4gUm9vdCBvYmplY3RcclxuICAgICAqL1xyXG4gICAgZ2V0IHJvb3QoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Jvb3Q7XHJcbiAgICB9XHJcbn1cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEVudGl0eSwgXCJjbGFzc05hbWVcIiwge1xyXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgdmFsdWU6IFwiRW50aXR5XCJcclxufSk7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShFbnRpdHksIFwiY2xhc3NOYW1lc1wiLCB7XHJcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICB2YWx1ZTogW1wiRW50aXR5XCJdXHJcbn0pO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1FbnRpdHkuanMubWFwIiwiLyoqXHJcbiAqIEV2ZW50IERpc3BhdGNoZXIgbW9kdWxlIGlzIHVzZWQgZm9yIHJlZ2lzdGVyaW5nIGxpc3RlbmVycyBhbmQgZGlzcGF0Y2hpbmdcclxuICogZXZlbnRzIGFjcm9zcyBhbUNoYXJ0cyBzeXN0ZW0uXHJcbiAqL1xyXG4vKipcclxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4gKiBJTVBPUlRTXHJcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICogQGhpZGRlblxyXG4gKi9cclxuaW1wb3J0IHsgRGlzcG9zZXIsIE11bHRpRGlzcG9zZXIgfSBmcm9tIFwiLi9EaXNwb3NlclwiO1xyXG5pbXBvcnQgKiBhcyAkYXJyYXkgZnJvbSBcIi4vQXJyYXlcIjtcclxuaW1wb3J0ICogYXMgJHR5cGUgZnJvbSBcIi4vVHlwZVwiO1xyXG4vKipcclxuICogVW5pdmVyc2FsIEV2ZW50IERpc3BhdGNoZXIuXHJcbiAqXHJcbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vd3d3LmFtY2hhcnRzLmNvbS9kb2NzL3Y1L2NvbmNlcHRzL2V2ZW50cy99IGZvciBtb3JlIGluZm9cclxuICovXHJcbmV4cG9ydCBjbGFzcyBFdmVudERpc3BhdGNoZXIge1xyXG4gICAgLyoqXHJcbiAgICAgKiBDb25zdHJ1Y3RvclxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfbGlzdGVuZXJzXCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9raWxsZWRcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX2Rpc2FibGVkXCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9pdGVyYXRpbmdcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX2VuYWJsZWRcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX2Rpc3Bvc2VkXCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuX2xpc3RlbmVycyA9IFtdO1xyXG4gICAgICAgIHRoaXMuX2tpbGxlZCA9IFtdO1xyXG4gICAgICAgIHRoaXMuX2Rpc2FibGVkID0ge307XHJcbiAgICAgICAgdGhpcy5faXRlcmF0aW5nID0gMDtcclxuICAgICAgICB0aGlzLl9lbmFibGVkID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLl9kaXNwb3NlZCA9IGZhbHNlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGlmIHRoaXMgb2JqZWN0IGhhcyBiZWVuIGFscmVhZHkgZGlzcG9zZWQuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybiBEaXNwb3NlZD9cclxuICAgICAqL1xyXG4gICAgaXNEaXNwb3NlZCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZGlzcG9zZWQ7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIERpc3Bvc2UgKGRlc3Ryb3kpIHRoaXMgb2JqZWN0LlxyXG4gICAgICovXHJcbiAgICBkaXNwb3NlKCkge1xyXG4gICAgICAgIGlmICghdGhpcy5fZGlzcG9zZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5fZGlzcG9zZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICBjb25zdCBhID0gdGhpcy5fbGlzdGVuZXJzO1xyXG4gICAgICAgICAgICB0aGlzLl9pdGVyYXRpbmcgPSAxO1xyXG4gICAgICAgICAgICB0aGlzLl9saXN0ZW5lcnMgPSBudWxsO1xyXG4gICAgICAgICAgICB0aGlzLl9kaXNhYmxlZCA9IG51bGw7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAkYXJyYXkuZWFjaChhLCAoeCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHguZGlzcG9zZXIuZGlzcG9zZSgpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZmluYWxseSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9raWxsZWQgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5faXRlcmF0aW5nID0gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ2hlY2tzIGlmIHRoaXMgcGFydGljdWxhciBldmVudCBkaXNwYXRjaGVyIGhhcyBhbnkgbGlzdGVuZXJzIHNldC5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJuIEhhcyBsaXN0ZW5lcnM/XHJcbiAgICAgKi9cclxuICAgIGhhc0xpc3RlbmVycygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fbGlzdGVuZXJzLmxlbmd0aCAhPT0gMDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ2hlY2tzIGlmIHRoaXMgcGFydGljdWxhciBldmVudCBkaXNwYXRjaGVyIGhhcyBhbnkgcGFydGljdWxhciBsaXN0ZW5lcnMgc2V0LlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm4gSGFzIHBhcnRpY3VsYXIgZXZlbnQgbGlzdGVuZXJzP1xyXG4gICAgICovXHJcbiAgICBoYXNMaXN0ZW5lcnNCeVR5cGUodHlwZSkge1xyXG4gICAgICAgIHJldHVybiAkYXJyYXkuYW55KHRoaXMuX2xpc3RlbmVycywgKHgpID0+ICh4LnR5cGUgPT09IG51bGwgfHwgeC50eXBlID09PSB0eXBlKSAmJiAheC5raWxsZWQpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBFbmFibGUgZGlzcGF0Y2hpbmcgb2YgZXZlbnRzIGlmIHRoZXkgd2VyZSBwcmV2aW91c2x5IGRpc2FibGVkIGJ5XHJcbiAgICAgKiBgZGlzYWJsZSgpYC5cclxuICAgICAqL1xyXG4gICAgZW5hYmxlKCkge1xyXG4gICAgICAgIHRoaXMuX2VuYWJsZWQgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBEaXNhYmxlIGRpc3BhdGNoaW5nIG9mIGV2ZW50cyB1bnRpbCByZS1lbmFibGVkIGJ5IGBlbmFibGUoKWAuXHJcbiAgICAgKi9cclxuICAgIGRpc2FibGUoKSB7XHJcbiAgICAgICAgdGhpcy5fZW5hYmxlZCA9IGZhbHNlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBFbmFibGUgZGlzcGF0Y2hpbmcgcGFydGljdWxhciBldmVudCwgaWYgaXQgd2FzIGRpc2FibGVkIGJlZm9yZSBieVxyXG4gICAgICogYGRpc2FibGVUeXBlKClgLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB0eXBlIEV2ZW50IHR5cGVcclxuICAgICAqL1xyXG4gICAgZW5hYmxlVHlwZSh0eXBlKSB7XHJcbiAgICAgICAgZGVsZXRlIHRoaXMuX2Rpc2FibGVkW3R5cGVdO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBEaXNhYmxlIGRpc3BhdGNoaW5nIG9mIGV2ZW50cyBmb3IgYSBjZXJ0YWluIGV2ZW50IHR5cGUuXHJcbiAgICAgKlxyXG4gICAgICogT3B0aW9uYWxseSwgY2FuIHNldCBob3cgbWFueSBkaXNwYXRjaGVzIHRvIHNraXAgYmVmb3JlIGF1dG9tYXRpY2FsbHlcclxuICAgICAqIHJlLWVuYWJsaW5nIHRoZSBkaXNwYXRjaGluZy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gdHlwZSAgICBFdmVudCB0eXBlXHJcbiAgICAgKiBAcGFyYW0gYW1vdW50ICBOdW1iZXIgb2YgZXZlbnQgZGlzcGF0Y2hlcyB0byBza2lwXHJcbiAgICAgKi9cclxuICAgIGRpc2FibGVUeXBlKHR5cGUsIGFtb3VudCA9IEluZmluaXR5KSB7XHJcbiAgICAgICAgdGhpcy5fZGlzYWJsZWRbdHlwZV0gPSBhbW91bnQ7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZXMgbGlzdGVuZXIgZnJvbSBkaXNwYXRjaGVyLlxyXG4gICAgICpcclxuICAgICAqIFdpbGwgdGhyb3cgYW4gZXhjZXB0aW9uIGlmIHN1Y2ggbGlzdGVuZXIgZG9lcyBub3QgZXhpc3RzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBsaXN0ZW5lciBMaXN0ZW5lciB0byByZW1vdmVcclxuICAgICAqL1xyXG4gICAgX3JlbW92ZUxpc3RlbmVyKGxpc3RlbmVyKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2l0ZXJhdGluZyA9PT0gMCkge1xyXG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMuX2xpc3RlbmVycy5pbmRleE9mKGxpc3RlbmVyKTtcclxuICAgICAgICAgICAgaWYgKGluZGV4ID09PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzdGF0ZTogY291bGQgbm90IHJlbW92ZSBsaXN0ZW5lclwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9saXN0ZW5lcnMuc3BsaWNlKGluZGV4LCAxKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2tpbGxlZC5wdXNoKGxpc3RlbmVyKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZXMgZXhpc3RpbmcgbGlzdGVuZXIgYnkgY2VydGFpbiBwYXJhbWV0ZXJzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBvbmNlICAgICAgICAgTGlzdGVuZXIncyBvbmNlIHNldHRpbmdcclxuICAgICAqIEBwYXJhbSB0eXBlICAgICAgICAgTGlzdGVuZXIncyB0eXBlXHJcbiAgICAgKiBAcGFyYW0gY2FsbGJhY2sgICAgIENhbGxiYWNrIGZ1bmN0aW9uXHJcbiAgICAgKiBAcGFyYW0gY29udGV4dCAgICAgIENhbGxiYWNrIGNvbnRleHRcclxuICAgICAqL1xyXG4gICAgX3JlbW92ZUV4aXN0aW5nTGlzdGVuZXIob25jZSwgdHlwZSwgY2FsbGJhY2ssIGNvbnRleHQpIHtcclxuICAgICAgICBpZiAodGhpcy5fZGlzcG9zZWQpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXZlbnREaXNwYXRjaGVyIGlzIGRpc3Bvc2VkXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9lYWNoTGlzdGVuZXIoKGluZm8pID0+IHtcclxuICAgICAgICAgICAgaWYgKGluZm8ub25jZSA9PT0gb25jZSAmJiAvLyBUT0RPIGlzIHRoaXMgY29ycmVjdCA/XHJcbiAgICAgICAgICAgICAgICBpbmZvLnR5cGUgPT09IHR5cGUgJiZcclxuICAgICAgICAgICAgICAgIChjYWxsYmFjayA9PT0gdW5kZWZpbmVkIHx8IGluZm8uY2FsbGJhY2sgPT09IGNhbGxiYWNrKSAmJlxyXG4gICAgICAgICAgICAgICAgaW5mby5jb250ZXh0ID09PSBjb250ZXh0KSB7XHJcbiAgICAgICAgICAgICAgICBpbmZvLmRpc3Bvc2VyLmRpc3Bvc2UoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDaGVja3MgaWYgZGlzcGF0Y2hpbmcgZm9yIHBhcnRpY3VsYXIgZXZlbnQgdHlwZSBpcyBlbmFibGVkLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB0eXBlICBFdmVudCB0eXBlXHJcbiAgICAgKiBAcmV0dXJuIEVuYWJsZWQ/XHJcbiAgICAgKi9cclxuICAgIGlzRW5hYmxlZCh0eXBlKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2Rpc3Bvc2VkKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkV2ZW50RGlzcGF0Y2hlciBpcyBkaXNwb3NlZFwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gVE9ETyBpcyB0aGlzIGNoZWNrIGNvcnJlY3QgP1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9lbmFibGVkICYmIHRoaXMuX2xpc3RlbmVycy5sZW5ndGggPiAwICYmIHRoaXMuaGFzTGlzdGVuZXJzQnlUeXBlKHR5cGUpICYmIHRoaXMuX2Rpc2FibGVkW3R5cGVdID09PSB1bmRlZmluZWQ7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZXMgYWxsIGxpc3RlbmVycyBvZiBhIHBhcnRpY3VsYXIgZXZlbnQgdHlwZVxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB0eXBlICBMaXN0ZW5lcidzIHR5cGVcclxuICAgICAqL1xyXG4gICAgcmVtb3ZlVHlwZSh0eXBlKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2Rpc3Bvc2VkKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkV2ZW50RGlzcGF0Y2hlciBpcyBkaXNwb3NlZFwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fZWFjaExpc3RlbmVyKChpbmZvKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChpbmZvLnR5cGUgPT09IHR5cGUpIHtcclxuICAgICAgICAgICAgICAgIGluZm8uZGlzcG9zZXIuZGlzcG9zZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENoZWNrcyBpZiB0aGVyZSdzIGFscmVhZHkgYSBsaXN0ZW5lciB3aXRoIHNwZWNpZmljIHBhcmFtZXRlcnMuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHR5cGUgICAgICBMaXN0ZW5lcidzIHR5cGVcclxuICAgICAqIEBwYXJhbSBjYWxsYmFjayAgQ2FsbGJhY2sgZnVuY3Rpb25cclxuICAgICAqIEBwYXJhbSBjb250ZXh0ICAgQ2FsbGJhY2sgY29udGV4dFxyXG4gICAgICogQHJldHVybiBIYXMgbGlzdGVuZXI/XHJcbiAgICAgKi9cclxuICAgIGhhcyh0eXBlLCBjYWxsYmFjaywgY29udGV4dCkge1xyXG4gICAgICAgIGNvbnN0IGluZGV4ID0gJGFycmF5LmZpbmRJbmRleCh0aGlzLl9saXN0ZW5lcnMsIChpbmZvKSA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiBpbmZvLm9uY2UgIT09IHRydWUgJiYgLy8gSWdub3JpbmcgXCJvbmNlXCIgbGlzdGVuZXJzXHJcbiAgICAgICAgICAgICAgICBpbmZvLnR5cGUgPT09IHR5cGUgJiZcclxuICAgICAgICAgICAgICAgIChjYWxsYmFjayA9PT0gdW5kZWZpbmVkIHx8IGluZm8uY2FsbGJhY2sgPT09IGNhbGxiYWNrKSAmJlxyXG4gICAgICAgICAgICAgICAgaW5mby5jb250ZXh0ID09PSBjb250ZXh0O1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBpbmRleCAhPT0gLTE7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENoZWNrcyB3aGV0aGVyIGV2ZW50IG9mIHRoZSBwYXJ0aWN1bGFyIHR5cGUgc2hvdWxkIGJlIGRpc3BhdGNoZWQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHR5cGUgIEV2ZW50IHR5cGVcclxuICAgICAqIEByZXR1cm4gRGlzcGF0Y2g/XHJcbiAgICAgKi9cclxuICAgIF9zaG91bGREaXNwYXRjaCh0eXBlKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2Rpc3Bvc2VkKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkV2ZW50RGlzcGF0Y2hlciBpcyBkaXNwb3NlZFwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgY291bnQgPSB0aGlzLl9kaXNhYmxlZFt0eXBlXTtcclxuICAgICAgICBpZiAoISR0eXBlLmlzTnVtYmVyKGNvdW50KSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZW5hYmxlZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmIChjb3VudCA8PSAxKSB7XHJcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5fZGlzYWJsZWRbdHlwZV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAtLXRoaXMuX2Rpc2FibGVkW3R5cGVdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFtfZWFjaExpc3RlbmVyIGRlc2NyaXB0aW9uXVxyXG4gICAgICpcclxuICAgICAqIEFsbCBvZiB0aGlzIGV4dHJhIGNvZGUgaXMgbmVlZGVkIHdoZW4gYSBsaXN0ZW5lciBpcyByZW1vdmVkIHdoaWxlIGl0ZXJhdGluZ1xyXG4gICAgICpcclxuICAgICAqIEB0b2RvIERlc2NyaXB0aW9uXHJcbiAgICAgKiBAcGFyYW0gZm4gW2Rlc2NyaXB0aW9uXVxyXG4gICAgICovXHJcbiAgICBfZWFjaExpc3RlbmVyKGZuKSB7XHJcbiAgICAgICAgKyt0aGlzLl9pdGVyYXRpbmc7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgJGFycmF5LmVhY2godGhpcy5fbGlzdGVuZXJzLCBmbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZpbmFsbHkge1xyXG4gICAgICAgICAgICAtLXRoaXMuX2l0ZXJhdGluZztcclxuICAgICAgICAgICAgLy8gVE9ETyBzaG91bGQgdGhpcyBiZSBpbnNpZGUgb3Igb3V0c2lkZSB0aGUgZmluYWxseSA/XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9pdGVyYXRpbmcgPT09IDAgJiYgdGhpcy5fa2lsbGVkLmxlbmd0aCAhPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlIGtpbGxlZCBsaXN0ZW5lcnNcclxuICAgICAgICAgICAgICAgICRhcnJheS5lYWNoKHRoaXMuX2tpbGxlZCwgKGtpbGxlZCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlbW92ZUxpc3RlbmVyKGtpbGxlZCk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2tpbGxlZC5sZW5ndGggPSAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBEaXNwYXRjaGVzIGFuIGV2ZW50IGltbWVkaWF0ZWx5IHdpdGhvdXQgd2FpdGluZyBmb3IgbmV4dCBjeWNsZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gdHlwZSAgIEV2ZW50IHR5cGVcclxuICAgICAqIEBwYXJhbSBldmVudCAgRXZlbnQgb2JqZWN0XHJcbiAgICAgKiBAdG9kbyBhdXRvbWF0aWNhbGx5IGFkZCBpbiB0eXBlIGFuZCB0YXJnZXQgcHJvcGVydGllcyBpZiB0aGV5IGFyZSBtaXNzaW5nXHJcbiAgICAgKi9cclxuICAgIGRpc3BhdGNoKHR5cGUsIGV2ZW50KSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX3Nob3VsZERpc3BhdGNoKHR5cGUpKSB7XHJcbiAgICAgICAgICAgIC8vIFRPRE8gY2hlY2sgaWYgaXQncyBmYXN0ZXIgdG8gdXNlIGFuIG9iamVjdCBvZiBsaXN0ZW5lcnMgcmF0aGVyIHRoYW4gYSBzaW5nbGUgYmlnIGFycmF5XHJcbiAgICAgICAgICAgIC8vIFRPRE8gaWYgdGhlIGZ1bmN0aW9uIHRocm93cywgbWF5YmUgaXQgc2hvdWxkIGtlZXAgZ29pbmcgP1xyXG4gICAgICAgICAgICB0aGlzLl9lYWNoTGlzdGVuZXIoKGxpc3RlbmVyKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWxpc3RlbmVyLmtpbGxlZCAmJiAobGlzdGVuZXIudHlwZSA9PT0gbnVsbCB8fCBsaXN0ZW5lci50eXBlID09PSB0eXBlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbmVyLmRpc3BhdGNoKHR5cGUsIGV2ZW50KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTaGVsdmVzIHRoZSBldmVudCB0byBiZSBkaXNwYXRjaGVkIHdpdGhpbiBuZXh0IHVwZGF0ZSBjeWNsZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gdHlwZSAgIEV2ZW50IHR5cGVcclxuICAgICAqIEBwYXJhbSBldmVudCAgRXZlbnQgb2JqZWN0XHJcbiAgICAgKiBAdG9kbyBhdXRvbWF0aWNhbGx5IGFkZCBpbiB0eXBlIGFuZCB0YXJnZXQgcHJvcGVydGllcyBpZiB0aGV5IGFyZSBtaXNzaW5nXHJcbiAgICAgKi9cclxuICAgIC8qcHVibGljIGRpc3BhdGNoTGF0ZXI8S2V5IGV4dGVuZHMga2V5b2YgVD4odHlwZTogS2V5LCBldmVudDogVFtLZXldKTogdm9pZCB7XHJcbiAgICAgICAgaWYgKHRoaXMuX3Nob3VsZERpc3BhdGNoKHR5cGUpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2VhY2hMaXN0ZW5lcigobGlzdGVuZXIpID0+IHtcclxuICAgICAgICAgICAgICAgIC8vIFRPRE8gY2hlY2sgaWYgaXQncyBmYXN0ZXIgdG8gdXNlIGFuIG9iamVjdCBvZiBsaXN0ZW5lcnMgcmF0aGVyIHRoYW4gYSBzaW5nbGUgYmlnIGFycmF5XHJcbiAgICAgICAgICAgICAgICBpZiAoIWxpc3RlbmVyLmtpbGxlZCAmJiAobGlzdGVuZXIudHlwZSA9PT0gbnVsbCB8fCBsaXN0ZW5lci50eXBlID09PSB0eXBlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE8gaWYgdGhlIGZ1bmN0aW9uIHRocm93cywgbWF5YmUgaXQgc2hvdWxkIGtlZXAgZ29pbmcgP1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE8gZGlzcGF0Y2ggZHVyaW5nIHRoZSB1cGRhdGUgY3ljbGUsIHJhdGhlciB0aGFuIHVzaW5nIHdoZW5JZGxlXHJcbiAgICAgICAgICAgICAgICAgICAgJGFzeW5jLndoZW5JZGxlKCgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFsaXN0ZW5lci5raWxsZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpc3RlbmVyLmRpc3BhdGNoKHR5cGUsIGV2ZW50KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9Ki9cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcywgY2F0YWxvZ3MgYW5kIHJldHVybnMgYW4gW1tFdmVudExpc3RlbmVyXV0uXHJcbiAgICAgKlxyXG4gICAgICogRXZlbnQgbGlzdGVuZXIgY2FuIGJlIGRpc3Bvc2VkLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBvbmNlICAgICAgICAgTGlzdGVuZXIncyBvbmNlIHNldHRpbmdcclxuICAgICAqIEBwYXJhbSB0eXBlICAgICAgICAgTGlzdGVuZXIncyB0eXBlXHJcbiAgICAgKiBAcGFyYW0gY2FsbGJhY2sgICAgIENhbGxiYWNrIGZ1bmN0aW9uXHJcbiAgICAgKiBAcGFyYW0gY29udGV4dCAgICAgIENhbGxiYWNrIGNvbnRleHRcclxuICAgICAqIEBwYXJhbSBzaG91bGRDbG9uZSAgV2hldGhlciB0aGUgbGlzdGVuZXIgc2hvdWxkIGJlIGNvcGllZCB3aGVuIHRoZSBFdmVudERpc3BhdGNoZXIgaXMgY29waWVkXHJcbiAgICAgKiBAcGFyYW0gZGlzcGF0Y2hcclxuICAgICAqIEByZXR1cm5zIEFuIGV2ZW50IGxpc3RlbmVyXHJcbiAgICAgKi9cclxuICAgIF9vbihvbmNlLCB0eXBlLCBjYWxsYmFjaywgY29udGV4dCwgc2hvdWxkQ2xvbmUsIGRpc3BhdGNoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2Rpc3Bvc2VkKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkV2ZW50RGlzcGF0Y2hlciBpcyBkaXNwb3NlZFwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fcmVtb3ZlRXhpc3RpbmdMaXN0ZW5lcihvbmNlLCB0eXBlLCBjYWxsYmFjaywgY29udGV4dCk7XHJcbiAgICAgICAgY29uc3QgaW5mbyA9IHtcclxuICAgICAgICAgICAgdHlwZTogdHlwZSxcclxuICAgICAgICAgICAgY2FsbGJhY2s6IGNhbGxiYWNrLFxyXG4gICAgICAgICAgICBjb250ZXh0OiBjb250ZXh0LFxyXG4gICAgICAgICAgICBzaG91bGRDbG9uZTogc2hvdWxkQ2xvbmUsXHJcbiAgICAgICAgICAgIGRpc3BhdGNoOiBkaXNwYXRjaCxcclxuICAgICAgICAgICAga2lsbGVkOiBmYWxzZSxcclxuICAgICAgICAgICAgb25jZTogb25jZSxcclxuICAgICAgICAgICAgZGlzcG9zZXI6IG5ldyBEaXNwb3NlcigoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpbmZvLmtpbGxlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9yZW1vdmVMaXN0ZW5lcihpbmZvKTtcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMuX2xpc3RlbmVycy5wdXNoKGluZm8pO1xyXG4gICAgICAgIHJldHVybiBpbmZvO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGFuIGV2ZW50IGxpc3RlbmVyIHRvIGJlIGludm9rZWQgb24gKiphbnkqKiBldmVudC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gY2FsbGJhY2sgICAgIENhbGxiYWNrIGZ1bmN0aW9uXHJcbiAgICAgKiBAcGFyYW0gY29udGV4dCAgICAgIENhbGxiYWNrIGNvbnRleHRcclxuICAgICAqIEBwYXJhbSBzaG91bGRDbG9uZSAgV2hldGhlciB0aGUgbGlzdGVuZXIgc2hvdWxkIGJlIGNvcGllZCB3aGVuIHRoZSBFdmVudERpc3BhdGNoZXIgaXMgY29waWVkXHJcbiAgICAgKiBAcmV0dXJucyBBIGRpc3Bvc2FibGUgZXZlbnQgbGlzdGVuZXJcclxuICAgICAqL1xyXG4gICAgb25BbGwoY2FsbGJhY2ssIGNvbnRleHQsIHNob3VsZENsb25lID0gdHJ1ZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9vbihmYWxzZSwgbnVsbCwgY2FsbGJhY2ssIGNvbnRleHQsIHNob3VsZENsb25lLCAoX3R5cGUsIGV2ZW50KSA9PiBjYWxsYmFjay5jYWxsKGNvbnRleHQsIGV2ZW50KSkuZGlzcG9zZXI7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYW4gZXZlbnQgbGlzdGVuZXIgdG8gYmUgaW52b2tlZCBvbiBhIHNwZWNpZmljIGV2ZW50IHR5cGUuXHJcbiAgICAgKlxyXG4gICAgICogYGBgVHlwZVNjcmlwdFxyXG4gICAgICogYnV0dG9uLmV2ZW50cy5vbmNlKFwiY2xpY2tcIiwgKGV2KSA9PiB7XHJcbiAgICAgKiAgIGNvbnNvbGUubG9nKFwiQnV0dG9uIGNsaWNrZWRcIik7XHJcbiAgICAgKiB9LCB0aGlzKTtcclxuICAgICAqIGBgYFxyXG4gICAgICogYGBgSmF2YVNjcmlwdFxyXG4gICAgICogYnV0dG9uLmV2ZW50cy5vbmNlKFwiY2xpY2tcIiwgKGV2KSA9PiB7XHJcbiAgICAgKiAgIGNvbnNvbGUubG9nKFwiQnV0dG9uIGNsaWNrZWRcIik7XHJcbiAgICAgKiB9LCB0aGlzKTtcclxuICAgICAqIGBgYFxyXG4gICAgICpcclxuICAgICAqIFRoZSBhYm92ZSB3aWxsIGludm9rZSBvdXIgY3VzdG9tIGV2ZW50IGhhbmRsZXIgd2hlbmV2ZXIgc2VyaWVzIHdlIHB1dFxyXG4gICAgICogZXZlbnQgb24gaXMgaGlkZGVuLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB0eXBlICAgICAgICAgTGlzdGVuZXIncyB0eXBlXHJcbiAgICAgKiBAcGFyYW0gY2FsbGJhY2sgICAgIENhbGxiYWNrIGZ1bmN0aW9uXHJcbiAgICAgKiBAcGFyYW0gY29udGV4dCAgICAgIENhbGxiYWNrIGNvbnRleHRcclxuICAgICAqIEBwYXJhbSBzaG91bGRDbG9uZSAgV2hldGhlciB0aGUgbGlzdGVuZXIgc2hvdWxkIGJlIGNvcGllZCB3aGVuIHRoZSBFdmVudERpc3BhdGNoZXIgaXMgY29waWVkXHJcbiAgICAgKiBAcmV0dXJucyBBIGRpc3Bvc2FibGUgZXZlbnQgbGlzdGVuZXJcclxuICAgICAqL1xyXG4gICAgb24odHlwZSwgY2FsbGJhY2ssIGNvbnRleHQsIHNob3VsZENsb25lID0gdHJ1ZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9vbihmYWxzZSwgdHlwZSwgY2FsbGJhY2ssIGNvbnRleHQsIHNob3VsZENsb25lLCAoX3R5cGUsIGV2ZW50KSA9PiBjYWxsYmFjay5jYWxsKGNvbnRleHQsIGV2ZW50KSkuZGlzcG9zZXI7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYW4gZXZlbnQgbGlzdGVuZXIgdG8gYmUgaW52b2tlZCBvbiBhIHNwZWNpZmljIGV2ZW50IHR5cGUgb25jZS5cclxuICAgICAqXHJcbiAgICAgKiBPbmNlIHRoZSBldmVudCBsaXN0ZW5lciBpcyBpbnZva2VkLCBpdCBpcyBhdXRvbWF0aWNhbGx5IGRpc3Bvc2VkLlxyXG4gICAgICpcclxuICAgICAqIGBgYFR5cGVTY3JpcHRcclxuICAgICAqIGJ1dHRvbi5ldmVudHMub25jZShcImNsaWNrXCIsIChldikgPT4ge1xyXG4gICAgICogICBjb25zb2xlLmxvZyhcIkJ1dHRvbiBjbGlja2VkXCIpO1xyXG4gICAgICogfSwgdGhpcyk7XHJcbiAgICAgKiBgYGBcclxuICAgICAqIGBgYEphdmFTY3JpcHRcclxuICAgICAqIGJ1dHRvbi5ldmVudHMub25jZShcImNsaWNrXCIsIChldikgPT4ge1xyXG4gICAgICogICBjb25zb2xlLmxvZyhcIkJ1dHRvbiBjbGlja2VkXCIpO1xyXG4gICAgICogfSwgdGhpcyk7XHJcbiAgICAgKiBgYGBcclxuICAgICAqXHJcbiAgICAgKiBUaGUgYWJvdmUgd2lsbCBpbnZva2Ugb3VyIGN1c3RvbSBldmVudCBoYW5kbGVyIHRoZSBmaXJzdCB0aW1lIHNlcmllcyB3ZVxyXG4gICAgICogcHV0IGV2ZW50IG9uIGlzIGhpZGRlbi5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gdHlwZSAgICAgICAgIExpc3RlbmVyJ3MgdHlwZVxyXG4gICAgICogQHBhcmFtIGNhbGxiYWNrICAgICBDYWxsYmFjayBmdW5jdGlvblxyXG4gICAgICogQHBhcmFtIGNvbnRleHQgICAgICBDYWxsYmFjayBjb250ZXh0XHJcbiAgICAgKiBAcGFyYW0gc2hvdWxkQ2xvbmUgIFdoZXRoZXIgdGhlIGxpc3RlbmVyIHNob3VsZCBiZSBjb3BpZWQgd2hlbiB0aGUgRXZlbnREaXNwYXRjaGVyIGlzIGNvcGllZFxyXG4gICAgICogQHJldHVybnMgQSBkaXNwb3NhYmxlIGV2ZW50IGxpc3RlbmVyXHJcbiAgICAgKi9cclxuICAgIG9uY2UodHlwZSwgY2FsbGJhY2ssIGNvbnRleHQsIHNob3VsZENsb25lID0gdHJ1ZSkge1xyXG4gICAgICAgIGNvbnN0IHggPSB0aGlzLl9vbih0cnVlLCB0eXBlLCBjYWxsYmFjaywgY29udGV4dCwgc2hvdWxkQ2xvbmUsIChfdHlwZSwgZXZlbnQpID0+IHtcclxuICAgICAgICAgICAgeC5kaXNwb3Nlci5kaXNwb3NlKCk7XHJcbiAgICAgICAgICAgIGNhbGxiYWNrLmNhbGwoY29udGV4dCwgZXZlbnQpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8vIFRPRE8gbWF5YmUgdGhpcyBzaG91bGQgcmV0dXJuIGEgZGlmZmVyZW50IERpc3Bvc2VyID9cclxuICAgICAgICByZXR1cm4geC5kaXNwb3NlcjtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlcyB0aGUgZXZlbnQgbGlzdGVuZXIgd2l0aCBzcGVjaWZpYyBwYXJhbWV0ZXJzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB0eXBlICAgICAgICAgTGlzdGVuZXIncyB0eXBlXHJcbiAgICAgKiBAcGFyYW0gY2FsbGJhY2sgICAgIENhbGxiYWNrIGZ1bmN0aW9uXHJcbiAgICAgKiBAcGFyYW0gY29udGV4dCAgICAgIENhbGxiYWNrIGNvbnRleHRcclxuICAgICAqL1xyXG4gICAgb2ZmKHR5cGUsIGNhbGxiYWNrLCBjb250ZXh0KSB7XHJcbiAgICAgICAgdGhpcy5fcmVtb3ZlRXhpc3RpbmdMaXN0ZW5lcihmYWxzZSwgdHlwZSwgY2FsbGJhY2ssIGNvbnRleHQpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDb3BpZXMgYWxsIGRpc3BhdGNoZXIgcGFyYW1ldGVycywgaW5jbHVkaW5nIGxpc3RlbmVycywgZnJvbSBhbm90aGVyIGV2ZW50XHJcbiAgICAgKiBkaXNwYXRjaGVyLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBzb3VyY2UgU291cmNlIGV2ZW50IGRpc3BhdGNoZXJcclxuICAgICAqIEBpZ25vcmVcclxuICAgICAqL1xyXG4gICAgY29weUZyb20oc291cmNlKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2Rpc3Bvc2VkKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkV2ZW50RGlzcGF0Y2hlciBpcyBkaXNwb3NlZFwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHNvdXJjZSA9PT0gdGhpcykge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgY29weUZyb20gdGhlIHNhbWUgVGFyZ2V0ZWRFdmVudERpc3BhdGNoZXJcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGRpc3Bvc2VycyA9IFtdO1xyXG4gICAgICAgICRhcnJheS5lYWNoKHNvdXJjZS5fbGlzdGVuZXJzLCAoeCkgPT4ge1xyXG4gICAgICAgICAgICAvLyBUT0RPIGlzIHRoaXMgY29ycmVjdCA/XHJcbiAgICAgICAgICAgIGlmICgheC5raWxsZWQgJiYgeC5zaG91bGRDbG9uZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHgudHlwZSA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRpc3Bvc2Vycy5wdXNoKHRoaXMub25BbGwoeC5jYWxsYmFjaywgeC5jb250ZXh0KSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh4Lm9uY2UpIHtcclxuICAgICAgICAgICAgICAgICAgICBkaXNwb3NlcnMucHVzaCh0aGlzLm9uY2UoeC50eXBlLCB4LmNhbGxiYWNrLCB4LmNvbnRleHQpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGRpc3Bvc2Vycy5wdXNoKHRoaXMub24oeC50eXBlLCB4LmNhbGxiYWNrLCB4LmNvbnRleHQpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBuZXcgTXVsdGlEaXNwb3NlcihkaXNwb3NlcnMpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBBIHZlcnNpb24gb2YgdGhlIFtbRXZlbnREaXNwYXRjaGVyXV0gdGhhdCBkaXNwYXRjaGVzIGV2ZW50cyBmb3IgYSBzcGVjaWZpY1xyXG4gKiB0YXJnZXQgb2JqZWN0LlxyXG4gKlxyXG4gKiBAaWdub3JlXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgVGFyZ2V0ZWRFdmVudERpc3BhdGNoZXIgZXh0ZW5kcyBFdmVudERpc3BhdGNoZXIge1xyXG4gICAgLyoqXHJcbiAgICAgKiBDb25zdHJ1Y3RvclxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB0YXJnZXQgRXZlbnQgZGlzcGF0Y2hlciB0YXJnZXRcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IodGFyZ2V0KSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBIHRhcmdldCBvYmplY3Qgd2hpY2ggaXMgb3JpZ2luYXRpbmcgZXZlbnRzIHVzaW5nIHRoaXMgZGlzcGF0Y2hlci5cclxuICAgICAgICAgKi9cclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ0YXJnZXRcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENvcGllcyBhbGwgZGlzcGF0Y2hlciBwYXJhbWV0ZXJzLCBpbmNsdWRpbmcgbGlzdGVuZXJzLCBmcm9tIGFub3RoZXIgZXZlbnRcclxuICAgICAqIGRpc3BhdGNoZXIuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHNvdXJjZSBTb3VyY2UgZXZlbnQgZGlzcGF0Y2hlclxyXG4gICAgICogQGlnbm9yZVxyXG4gICAgICovXHJcbiAgICBjb3B5RnJvbShzb3VyY2UpIHtcclxuICAgICAgICBpZiAodGhpcy5fZGlzcG9zZWQpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXZlbnREaXNwYXRjaGVyIGlzIGRpc3Bvc2VkXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc291cmNlID09PSB0aGlzKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBjb3B5RnJvbSB0aGUgc2FtZSBUYXJnZXRlZEV2ZW50RGlzcGF0Y2hlclwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgZGlzcG9zZXJzID0gW107XHJcbiAgICAgICAgJGFycmF5LmVhY2goc291cmNlLl9saXN0ZW5lcnMsICh4KSA9PiB7XHJcbiAgICAgICAgICAgIC8vIFRPRE8gdmVyeSBoYWNreVxyXG4gICAgICAgICAgICBpZiAoeC5jb250ZXh0ID09PSBzb3VyY2UudGFyZ2V0KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gVE9ETyBpcyB0aGlzIGNvcnJlY3QgP1xyXG4gICAgICAgICAgICBpZiAoIXgua2lsbGVkICYmIHguc2hvdWxkQ2xvbmUpIHtcclxuICAgICAgICAgICAgICAgIGlmICh4LnR5cGUgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICBkaXNwb3NlcnMucHVzaCh0aGlzLm9uQWxsKHguY2FsbGJhY2ssIHguY29udGV4dCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoeC5vbmNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGlzcG9zZXJzLnB1c2godGhpcy5vbmNlKHgudHlwZSwgeC5jYWxsYmFjaywgeC5jb250ZXh0KSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBkaXNwb3NlcnMucHVzaCh0aGlzLm9uKHgudHlwZSwgeC5jYWxsYmFjaywgeC5jb250ZXh0KSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gbmV3IE11bHRpRGlzcG9zZXIoZGlzcG9zZXJzKTtcclxuICAgIH1cclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1FdmVudERpc3BhdGNoZXIuanMubWFwIiwiaW1wb3J0IHsgRW50aXR5IH0gZnJvbSBcIi4vRW50aXR5XCI7XHJcbi8qKlxyXG4gKiBQcmVzZXRzIGZvciBjb21tb24gVUkgZWxlbWVudHMuXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgSW50ZXJmYWNlQ29sb3JzIGV4dGVuZHMgRW50aXR5IHtcclxufVxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoSW50ZXJmYWNlQ29sb3JzLCBcImNsYXNzTmFtZVwiLCB7XHJcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICB2YWx1ZTogXCJJbnRlcmZhY2VDb2xvcnNcIlxyXG59KTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEludGVyZmFjZUNvbG9ycywgXCJjbGFzc05hbWVzXCIsIHtcclxuICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgIHZhbHVlOiBFbnRpdHkuY2xhc3NOYW1lcy5jb25jYXQoW0ludGVyZmFjZUNvbG9ycy5jbGFzc05hbWVdKVxyXG59KTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9SW50ZXJmYWNlQ29sb3JzLmpzLm1hcCIsImltcG9ydCB7IEVudGl0eSB9IGZyb20gXCIuL0VudGl0eVwiO1xyXG5pbXBvcnQgKiBhcyAkYXJyYXkgZnJvbSBcIi4vQXJyYXlcIjtcclxuaW1wb3J0ICogYXMgJG9iamVjdCBmcm9tIFwiLi9PYmplY3RcIjtcclxuaW1wb3J0IGVuIGZyb20gXCIuLi8uLi8uLi9sb2NhbGVzL2VuXCI7XHJcbjtcclxuLyoqXHJcbiAqIEFkZCBsb2NhbGl6YXRpb24gZnVuY3Rpb25hbGl0eS5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBMYW5ndWFnZSBleHRlbmRzIEVudGl0eSB7XHJcbiAgICBfc2V0RGVmYXVsdHMoKSB7XHJcbiAgICAgICAgdGhpcy5zZXRQcml2YXRlKFwiZGVmYXVsdExvY2FsZVwiLCBlbik7XHJcbiAgICAgICAgc3VwZXIuX3NldERlZmF1bHRzKCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBwcm9tcHQgdHJhbnNsYXRpb24uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtICAgcHJvbXB0ICAgUHJvbXB0IHRvIHRyYW5zbGF0ZVxyXG4gICAgICogQHBhcmFtICAgbG9jYWxlICAgVGFyZ2V0IGxvY2FsZVxyXG4gICAgICogQHBhcmFtICAgLi4ucmVzdCAgUGFyYW1ldGVyc1xyXG4gICAgICogQHJldHVybiAgICAgICAgICAgVHJhbnNsYXRpb25cclxuICAgICAqL1xyXG4gICAgdHJhbnNsYXRlKHByb21wdCwgbG9jYWxlLCAuLi5yZXN0KSB7XHJcbiAgICAgICAgLy8gR2V0IGxhbmdhdWdlXHJcbiAgICAgICAgaWYgKCFsb2NhbGUpIHtcclxuICAgICAgICAgICAgbG9jYWxlID0gdGhpcy5fcm9vdC5sb2NhbGUgfHwgdGhpcy5nZXRQcml2YXRlKFwiZGVmYXVsdExvY2FsZVwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gSW5pdCB0cmFuc2xhdGlvblxyXG4gICAgICAgIGxldCB0cmFuc2xhdGlvbiA9IHByb21wdDtcclxuICAgICAgICBsZXQgdmFsdWUgPSBsb2NhbGVbcHJvbXB0XTtcclxuICAgICAgICAvLyBUcnkgdG8gbG9vayBmb3IgdGhlIHRyYW5zbGF0aW9uXHJcbiAgICAgICAgaWYgKHZhbHVlID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRyYW5zbGF0aW9uID0gXCJcIjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodmFsdWUgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAvLyBJdCBtaWdodCBiZSBhbiBlbXB0eSBzdHJpbmdcclxuICAgICAgICAgICAgaWYgKHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICB0cmFuc2xhdGlvbiA9IHZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGxvY2FsZSAhPT0gdGhpcy5nZXRQcml2YXRlKFwiZGVmYXVsdExvY2FsZVwiKSkge1xyXG4gICAgICAgICAgICAvLyBUcnkgdG8gbG9vayBpbiBkZWZhdWx0IGxhbmd1YWdlXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRyYW5zbGF0ZShwcm9tcHQsIHRoaXMuZ2V0UHJpdmF0ZShcImRlZmF1bHRMb2NhbGVcIiksIC4uLnJlc3QpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBSZXBsYWNlICUxLCAlMiwgZXRjIHBhcmFtc1xyXG4gICAgICAgIGlmIChyZXN0Lmxlbmd0aCkge1xyXG4gICAgICAgICAgICBmb3IgKGxldCBsZW4gPSByZXN0Lmxlbmd0aCwgaSA9IDA7IGkgPCBsZW47ICsraSkge1xyXG4gICAgICAgICAgICAgICAgdHJhbnNsYXRpb24gPSB0cmFuc2xhdGlvbi5zcGxpdChcIiVcIiArIChpICsgMSkpLmpvaW4ocmVzdFtpXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gUmV0dXJuIHRoZSB0cmFuc2xhdGlvblxyXG4gICAgICAgIHJldHVybiB0cmFuc2xhdGlvbjtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIHByb21wdCB0cmFuc2xhdGlvbiwgaW5jbHVkaW5nIGN1c3RvbSBwcm9tcHRzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSAgIHByb21wdCAgIFByb21wdCB0byB0cmFuc2xhdGVcclxuICAgICAqIEBwYXJhbSAgIGxvY2FsZSAgIFRhcmdldCBsb2NhbGVcclxuICAgICAqIEBwYXJhbSAgIC4uLnJlc3QgIFBhcmFtZXRlcnNcclxuICAgICAqIEByZXR1cm4gICAgICAgICAgIFRyYW5zbGF0aW9uXHJcbiAgICAgKi9cclxuICAgIHRyYW5zbGF0ZUFueShwcm9tcHQsIGxvY2FsZSwgLi4ucmVzdCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zbGF0ZShwcm9tcHQsIGxvY2FsZSwgLi4ucmVzdCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEFkZCBhIGN1c3RvbSBwcm9tcHQgdG8gbG9jYWxlLlxyXG4gICAgICpcclxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vd3d3LmFtY2hhcnRzLmNvbS9kb2NzL3Y1L2NvbmNlcHRzL2xvY2FsZXMvY3JlYXRpbmctdHJhbnNsYXRpb25zLyNFeHRlbmRpbmdfbG9jYWxlX3dpdGhfY3VzdG9tX3Byb21wdHN9XHJcbiAgICAgKiBAcGFyYW0gIHByb21wdCAgICAgICBTb3VyY2UgcHJvbXB0XHJcbiAgICAgKiBAcGFyYW0gIHRyYW5zbGF0aW9uICBUYW5zbGF0aW9uXHJcbiAgICAgKiBAcGFyYW0gIGxvY2FsZSAgICAgICBUYXJnZXQgbG9jYWxlXHJcbiAgICAgKi9cclxuICAgIHNldFRyYW5zbGF0aW9uQW55KHByb21wdCwgdHJhbnNsYXRpb24sIGxvY2FsZSkge1xyXG4gICAgICAgIGNvbnN0IGxvY2FsZVRhcmdldCA9IGxvY2FsZSB8fCB0aGlzLl9yb290LmxvY2FsZTtcclxuICAgICAgICBsb2NhbGVUYXJnZXRbcHJvbXB0XSA9IHRyYW5zbGF0aW9uO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGQgYSBiYXRjaCBvZiBjdXN0b20gcHJvbXB0cy5cclxuICAgICAqXHJcbiAgICAgKiBAc2luY2UgNS4zLjNcclxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vd3d3LmFtY2hhcnRzLmNvbS9kb2NzL3Y1L2NvbmNlcHRzL2xvY2FsZXMvY3JlYXRpbmctdHJhbnNsYXRpb25zLyNFeHRlbmRpbmdfbG9jYWxlX3dpdGhfY3VzdG9tX3Byb21wdHN9XHJcbiAgICAgKiBAcGFyYW0gIHRyYW5zbGF0aW9ucyAgVHJhbnNsYXRpb25zXHJcbiAgICAgKiBAcGFyYW0gIGxvY2FsZSAgICAgICAgVGFyZ2V0IGxvY2FsZVxyXG4gICAgICovXHJcbiAgICBzZXRUcmFuc2xhdGlvbnNBbnkodHJhbnNsYXRpb25zLCBsb2NhbGUpIHtcclxuICAgICAgICAkb2JqZWN0LmVhY2godHJhbnNsYXRpb25zLCAoa2V5LCB2YWwpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5zZXRUcmFuc2xhdGlvbkFueShrZXksIHZhbCwgbG9jYWxlKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHRyYW5zbGF0ZUVtcHR5KHByb21wdCwgbG9jYWxlLCAuLi5yZXN0KSB7XHJcbiAgICAgICAgbGV0IHRyYW5zbGF0aW9uID0gdGhpcy50cmFuc2xhdGUocHJvbXB0LCBsb2NhbGUsIC4uLnJlc3QpO1xyXG4gICAgICAgIHJldHVybiB0cmFuc2xhdGlvbiA9PSBwcm9tcHQgPyBcIlwiIDogdHJhbnNsYXRpb247XHJcbiAgICB9XHJcbiAgICB0cmFuc2xhdGVGdW5jKHByb21wdCwgbG9jYWxlKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX3Jvb3QubG9jYWxlW3Byb21wdF0pIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Jvb3QubG9jYWxlW3Byb21wdF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFRyeSB0byBsb29rIGluIGRlZmF1bHQgbGFuZ3VhZ2VcclxuICAgICAgICBpZiAobG9jYWxlICE9PSB0aGlzLmdldFByaXZhdGUoXCJkZWZhdWx0TG9jYWxlXCIpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRyYW5zbGF0ZUZ1bmMocHJvbXB0LCB0aGlzLmdldFByaXZhdGUoXCJkZWZhdWx0TG9jYWxlXCIpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gRmFpbCAtIHJldHVybiBlbXB0eSBmdW5jdGlvblxyXG4gICAgICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiBcIlwiO1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRyYW5zbGF0ZXMgYSBidGFjaCBvZiBwcm9tcHRzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSAgbGlzdCAgICBBcnJheSBvZiBwcm9tcHRzIHRvIHRyYW5zbGF0ZVxyXG4gICAgICogQHBhcmFtICBsb2NhbGUgIFRhcmdldCBsb2NhbGVcclxuICAgICAqIEByZXR1cm4gICAgICAgICBBcnJheSBvZiB0cmFuc2xhdGlvbnNcclxuICAgICAqL1xyXG4gICAgdHJhbnNsYXRlQWxsKGxpc3QsIGxvY2FsZSkge1xyXG4gICAgICAgIC8vIFRyYW5zbGF0ZSBhbGwgaXRlbXMgaW4gdGhlIGxpc3RcclxuICAgICAgICBpZiAoIXRoaXMuaXNEZWZhdWx0KCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuICRhcnJheS5tYXAobGlzdCwgKHgpID0+IHRoaXMudHJhbnNsYXRlKHgsIGxvY2FsZSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIGxpc3Q7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgY3VycmVudGx5IHNlbGVjdGVkIGxvY2FsZSBpcyBhIGRlZmF1bHQgbG9jYWxlLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm4gYHRydWVgIGlmIGxvY2FsZSBpcyBkZWZhdWx0OyBgZmFsc2VgIGlmIGl0IGlzIG5vdC5cclxuICAgICAqL1xyXG4gICAgaXNEZWZhdWx0KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmdldFByaXZhdGUoXCJkZWZhdWx0TG9jYWxlXCIpID09PSB0aGlzLl9yb290LmxvY2FsZTtcclxuICAgIH1cclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1MYW5ndWFnZS5qcy5tYXAiLCJpbXBvcnQgeyBFdmVudERpc3BhdGNoZXIgfSBmcm9tIFwiLi9FdmVudERpc3BhdGNoZXJcIjtcclxuaW1wb3J0ICogYXMgJGFycmF5IGZyb20gXCIuL0FycmF5XCI7XHJcbi8qKlxyXG4gKiBDaGVja3MgaWYgc3BlY2lmaWMgaW5kZXggZml0cyBpbnRvIGxlbmd0aC5cclxuICpcclxuICogQHBhcmFtIGluZGV4ICBJbmRleFxyXG4gKiBAcGFyYW0gbGVuICAgIExlbmd0aFxyXG4gKiBAaWdub3JlXHJcbiAqL1xyXG5mdW5jdGlvbiBjaGVja0JvdW5kcyhpbmRleCwgbGVuKSB7XHJcbiAgICBpZiAoIShpbmRleCA+PSAwICYmIGluZGV4IDwgbGVuKSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkluZGV4IG91dCBvZiBib3VuZHM6IFwiICsgaW5kZXgpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBBIExpc3QgY2xhc3MgaXMgdXNlZCB0byBob2xkIGEgbnVtYmVyIG9mIGluZGV4ZWQgaXRlbXMgb2YgdGhlIHNhbWUgdHlwZS5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBMaXN0IHtcclxuICAgIC8qKlxyXG4gICAgICogQ29uc3RydWN0b3JcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gaW5pdGlhbCAgSW5pdGFsIGxpc3Qgb2YgdmFsdWVzIHRvIGFkZCB0byBsaXN0XHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKGluaXRpYWwgPSBbXSkge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIExpc3QgdmFsdWVzLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl92YWx1ZXNcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZXZlbnRzXCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IG5ldyBFdmVudERpc3BhdGNoZXIoKVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuX3ZhbHVlcyA9IGluaXRpYWw7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEFuIGFycmF5IG9mIHZhbHVlcyBpbiB0aGUgbGlzdC5cclxuICAgICAqXHJcbiAgICAgKiBEbyBub3QgdXNlIHRoaXMgcHJvcGVydHkgdG8gYWRkIHZhbHVlcy4gUmF0aGVyIHVzZSBkZWRpY2F0ZWQgbWV0aG9kcywgbGlrZVxyXG4gICAgICogYHB1c2goKWAsIGByZW1vdmVJbmRleCgpYCwgZXRjLlxyXG4gICAgICpcclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICogQHJldHVybiBMaXN0IHZhbHVlc1xyXG4gICAgICovXHJcbiAgICBnZXQgdmFsdWVzKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl92YWx1ZXM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENoZWNrcyBpZiBsaXN0IGNvbnRhaW5zIHNwZWNpZmljIGl0ZW0gcmVmZXJlbmNlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBpdGVtICBJdGVtIHRvIHNlYXJjaCBmb3JcclxuICAgICAqIEByZXR1cm4gYHRydWVgIGlmIGZvdW5kLCBgZmFsc2VgIGlmIG5vdCBmb3VuZFxyXG4gICAgICovXHJcbiAgICBjb250YWlucyh2YWx1ZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl92YWx1ZXMuaW5kZXhPZih2YWx1ZSkgIT09IC0xO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmVzIHNwZWNpZmljIGl0ZW0gZnJvbSB0aGUgbGlzdC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gaXRlbSBBbiBpdGVtIHRvIHJlbW92ZVxyXG4gICAgICovXHJcbiAgICByZW1vdmVWYWx1ZSh2YWx1ZSkge1xyXG4gICAgICAgIGxldCBpID0gMDtcclxuICAgICAgICBsZXQgbGVuZ3RoID0gdGhpcy5fdmFsdWVzLmxlbmd0aDtcclxuICAgICAgICB3aGlsZSAoaSA8IGxlbmd0aCkge1xyXG4gICAgICAgICAgICAvLyBUT0RPIGhhbmRsZSBOYU5cclxuICAgICAgICAgICAgaWYgKHRoaXMuX3ZhbHVlc1tpXSA9PT0gdmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlSW5kZXgoaSk7XHJcbiAgICAgICAgICAgICAgICAtLWxlbmd0aDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICsraTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2VhcmNoZXMgdGhlIGxpc3QgZm9yIHNwZWNpZmljIGl0ZW0gYW5kIHJldHVybnMgaXRzIGluZGV4LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBpdGVtICBBbiBpdGVtIHRvIHNlYXJjaCBmb3JcclxuICAgICAqIEByZXR1cm4gSW5kZXggb3IgLTEgaWYgbm90IGZvdW5kXHJcbiAgICAgKi9cclxuICAgIGluZGV4T2YodmFsdWUpIHtcclxuICAgICAgICByZXR1cm4gJGFycmF5LmluZGV4T2YodGhpcy5fdmFsdWVzLCB2YWx1ZSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIE51bWJlciBvZiBpdGVtcyBpbiBsaXN0LlxyXG4gICAgICpcclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICogQHJldHVybiBOdW1iZXIgb2YgaXRlbXNcclxuICAgICAqL1xyXG4gICAgZ2V0IGxlbmd0aCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fdmFsdWVzLmxlbmd0aDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ2hlY2tzIGlmIHRoZXJlJ3MgYSB2YWx1ZSBhdCBzcGVjaWZpYyBpbmRleC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gaW5kZXggIEluZGV4XHJcbiAgICAgKiBAcmV0dXJuIFZhbHVlIGV4aXN0cz9cclxuICAgICAqL1xyXG4gICAgaGFzSW5kZXgoaW5kZXgpIHtcclxuICAgICAgICByZXR1cm4gaW5kZXggPj0gMCAmJiBpbmRleCA8IHRoaXMuX3ZhbHVlcy5sZW5ndGg7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYW4gaXRlbSBhdCBzcGVjaWZpZWQgaW5kZXguXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGluZGV4ICBJbmRleFxyXG4gICAgICogQHJldHVybiBMaXN0IGl0ZW1cclxuICAgICAqL1xyXG4gICAgZ2V0SW5kZXgoaW5kZXgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fdmFsdWVzW2luZGV4XTtcclxuICAgIH1cclxuICAgIF9vblB1c2gobmV3VmFsdWUpIHtcclxuICAgICAgICBpZiAodGhpcy5ldmVudHMuaXNFbmFibGVkKFwicHVzaFwiKSkge1xyXG4gICAgICAgICAgICB0aGlzLmV2ZW50cy5kaXNwYXRjaChcInB1c2hcIiwge1xyXG4gICAgICAgICAgICAgICAgdHlwZTogXCJwdXNoXCIsXHJcbiAgICAgICAgICAgICAgICB0YXJnZXQ6IHRoaXMsXHJcbiAgICAgICAgICAgICAgICBuZXdWYWx1ZVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBfb25JbnNlcnRJbmRleChpbmRleCwgbmV3VmFsdWUpIHtcclxuICAgICAgICBpZiAodGhpcy5ldmVudHMuaXNFbmFibGVkKFwiaW5zZXJ0SW5kZXhcIikpIHtcclxuICAgICAgICAgICAgdGhpcy5ldmVudHMuZGlzcGF0Y2goXCJpbnNlcnRJbmRleFwiLCB7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiBcImluc2VydEluZGV4XCIsXHJcbiAgICAgICAgICAgICAgICB0YXJnZXQ6IHRoaXMsXHJcbiAgICAgICAgICAgICAgICBpbmRleCxcclxuICAgICAgICAgICAgICAgIG5ld1ZhbHVlXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIF9vblNldEluZGV4KGluZGV4LCBvbGRWYWx1ZSwgbmV3VmFsdWUpIHtcclxuICAgICAgICBpZiAodGhpcy5ldmVudHMuaXNFbmFibGVkKFwic2V0SW5kZXhcIikpIHtcclxuICAgICAgICAgICAgdGhpcy5ldmVudHMuZGlzcGF0Y2goXCJzZXRJbmRleFwiLCB7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiBcInNldEluZGV4XCIsXHJcbiAgICAgICAgICAgICAgICB0YXJnZXQ6IHRoaXMsXHJcbiAgICAgICAgICAgICAgICBpbmRleCxcclxuICAgICAgICAgICAgICAgIG9sZFZhbHVlLFxyXG4gICAgICAgICAgICAgICAgbmV3VmFsdWVcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgX29uUmVtb3ZlSW5kZXgoaW5kZXgsIG9sZFZhbHVlKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuZXZlbnRzLmlzRW5hYmxlZChcInJlbW92ZUluZGV4XCIpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZXZlbnRzLmRpc3BhdGNoKFwicmVtb3ZlSW5kZXhcIiwge1xyXG4gICAgICAgICAgICAgICAgdHlwZTogXCJyZW1vdmVJbmRleFwiLFxyXG4gICAgICAgICAgICAgICAgdGFyZ2V0OiB0aGlzLFxyXG4gICAgICAgICAgICAgICAgaW5kZXgsXHJcbiAgICAgICAgICAgICAgICBvbGRWYWx1ZVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBfb25Nb3ZlSW5kZXgob2xkSW5kZXgsIG5ld0luZGV4LCB2YWx1ZSkge1xyXG4gICAgICAgIGlmICh0aGlzLmV2ZW50cy5pc0VuYWJsZWQoXCJtb3ZlSW5kZXhcIikpIHtcclxuICAgICAgICAgICAgdGhpcy5ldmVudHMuZGlzcGF0Y2goXCJtb3ZlSW5kZXhcIiwge1xyXG4gICAgICAgICAgICAgICAgdHlwZTogXCJtb3ZlSW5kZXhcIixcclxuICAgICAgICAgICAgICAgIHRhcmdldDogdGhpcyxcclxuICAgICAgICAgICAgICAgIG9sZEluZGV4LFxyXG4gICAgICAgICAgICAgICAgbmV3SW5kZXgsXHJcbiAgICAgICAgICAgICAgICB2YWx1ZSxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgX29uQ2xlYXIob2xkVmFsdWVzKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuZXZlbnRzLmlzRW5hYmxlZChcImNsZWFyXCIpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZXZlbnRzLmRpc3BhdGNoKFwiY2xlYXJcIiwge1xyXG4gICAgICAgICAgICAgICAgdHlwZTogXCJjbGVhclwiLFxyXG4gICAgICAgICAgICAgICAgdGFyZ2V0OiB0aGlzLFxyXG4gICAgICAgICAgICAgICAgb2xkVmFsdWVzXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB2YWx1ZSBhdCBzcGVjaWZpYyBpbmRleC5cclxuICAgICAqXHJcbiAgICAgKiBJZiB0aGVyZSdzIGFscmVhZHkgYSB2YWx1ZSBhdCB0aGUgaW5kZXgsIGl0IGlzIG92ZXJ3cml0dGVuLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBpbmRleCAgSW5kZXhcclxuICAgICAqIEBwYXJhbSB2YWx1ZSAgTmV3IHZhbHVlXHJcbiAgICAgKiBAcmV0dXJuIE5ldyB2YWx1ZVxyXG4gICAgICovXHJcbiAgICBzZXRJbmRleChpbmRleCwgdmFsdWUpIHtcclxuICAgICAgICBjaGVja0JvdW5kcyhpbmRleCwgdGhpcy5fdmFsdWVzLmxlbmd0aCk7XHJcbiAgICAgICAgY29uc3Qgb2xkVmFsdWUgPSB0aGlzLl92YWx1ZXNbaW5kZXhdO1xyXG4gICAgICAgIC8vIERvIG5vdGhpbmcgaWYgdGhlIG9sZCB2YWx1ZSBhbmQgdGhlIG5ldyB2YWx1ZSBhcmUgdGhlIHNhbWVcclxuICAgICAgICBpZiAob2xkVmFsdWUgIT09IHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3ZhbHVlc1tpbmRleF0gPSB2YWx1ZTtcclxuICAgICAgICAgICAgdGhpcy5fb25TZXRJbmRleChpbmRleCwgb2xkVmFsdWUsIHZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG9sZFZhbHVlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIGFuIGl0ZW0gdG8gdGhlIGxpc3QgYXQgYSBzcGVjaWZpYyBpbmRleCwgd2hpY2ggcHVzaGVzIGFsbCB0aGUgb3RoZXJcclxuICAgICAqIGl0ZW1zIGZ1cnRoZXIgZG93biB0aGUgbGlzdC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gaW5kZXggSW5kZXhcclxuICAgICAqIEBwYXJhbSBpdGVtICBBbiBpdGVtIHRvIGFkZFxyXG4gICAgICovXHJcbiAgICBpbnNlcnRJbmRleChpbmRleCwgdmFsdWUpIHtcclxuICAgICAgICBjaGVja0JvdW5kcyhpbmRleCwgdGhpcy5fdmFsdWVzLmxlbmd0aCArIDEpO1xyXG4gICAgICAgICRhcnJheS5pbnNlcnRJbmRleCh0aGlzLl92YWx1ZXMsIGluZGV4LCB2YWx1ZSk7XHJcbiAgICAgICAgdGhpcy5fb25JbnNlcnRJbmRleChpbmRleCwgdmFsdWUpO1xyXG4gICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU3dhcHMgaW5kZXhlcyBvZiB0d28gaXRlbXMgaW4gdGhlIGxpc3QuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGEgIEl0ZW0gMVxyXG4gICAgICogQHBhcmFtIGIgIEl0ZW0gMlxyXG4gICAgICovXHJcbiAgICBzd2FwKGEsIGIpIHtcclxuICAgICAgICBjb25zdCBsZW4gPSB0aGlzLl92YWx1ZXMubGVuZ3RoO1xyXG4gICAgICAgIGNoZWNrQm91bmRzKGEsIGxlbik7XHJcbiAgICAgICAgY2hlY2tCb3VuZHMoYiwgbGVuKTtcclxuICAgICAgICBpZiAoYSAhPT0gYikge1xyXG4gICAgICAgICAgICBjb25zdCB2YWx1ZV9hID0gdGhpcy5fdmFsdWVzW2FdO1xyXG4gICAgICAgICAgICBjb25zdCB2YWx1ZV9iID0gdGhpcy5fdmFsdWVzW2JdO1xyXG4gICAgICAgICAgICB0aGlzLl92YWx1ZXNbYV0gPSB2YWx1ZV9iO1xyXG4gICAgICAgICAgICB0aGlzLl9vblNldEluZGV4KGEsIHZhbHVlX2EsIHZhbHVlX2IpO1xyXG4gICAgICAgICAgICB0aGlzLl92YWx1ZXNbYl0gPSB2YWx1ZV9hO1xyXG4gICAgICAgICAgICB0aGlzLl9vblNldEluZGV4KGIsIHZhbHVlX2IsIHZhbHVlX2EpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlcyBhIHZhbHVlIGF0IHNwZWNpZmljIGluZGV4LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBpbmRleCAgSW5kZXggb2YgdmFsdWUgdG8gcmVtb3ZlXHJcbiAgICAgKiBAcmV0dXJuIFJlbW92ZWQgdmFsdWVcclxuICAgICAqL1xyXG4gICAgcmVtb3ZlSW5kZXgoaW5kZXgpIHtcclxuICAgICAgICBjaGVja0JvdW5kcyhpbmRleCwgdGhpcy5fdmFsdWVzLmxlbmd0aCk7XHJcbiAgICAgICAgY29uc3Qgb2xkVmFsdWUgPSB0aGlzLl92YWx1ZXNbaW5kZXhdO1xyXG4gICAgICAgICRhcnJheS5yZW1vdmVJbmRleCh0aGlzLl92YWx1ZXMsIGluZGV4KTtcclxuICAgICAgICB0aGlzLl9vblJlbW92ZUluZGV4KGluZGV4LCBvbGRWYWx1ZSk7XHJcbiAgICAgICAgcmV0dXJuIG9sZFZhbHVlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBNb3ZlcyBhbiBpdGVtIHRvIGEgc3BlY2lmaWMgaW5kZXggd2l0aGluIHRoZSBsaXN0LlxyXG4gICAgICpcclxuICAgICAqIElmIHRoZSBpbmRleCBpcyBub3Qgc3BlY2lmaWVkIGl0IHdpbGwgbW92ZSB0aGUgaXRlbSB0byB0aGUgZW5kIG9mIHRoZVxyXG4gICAgICogbGlzdC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gdmFsdWUgIEl0ZW0gdG8gbW92ZVxyXG4gICAgICogQHBhcmFtIGluZGV4ICBJbmRleCB0byBwbGFjZSBpdGVtIGF0XHJcbiAgICAgKi9cclxuICAgIG1vdmVWYWx1ZSh2YWx1ZSwgdG9JbmRleCkge1xyXG4gICAgICAgIC8vIFRPRE8gZG9uJ3QgZG8gYW55dGhpbmcgaWYgdGhlIGRlc2lyZWQgaW5kZXggaXMgdGhlIHNhbWUgYXMgdGhlIGN1cnJlbnQgaW5kZXhcclxuICAgICAgICBsZXQgaW5kZXggPSB0aGlzLmluZGV4T2YodmFsdWUpO1xyXG4gICAgICAgIC8vIFRPRE8gcmVtb3ZlIGFsbCBvbGQgdmFsdWVzIHJhdGhlciB0aGFuIG9ubHkgdGhlIGZpcnN0ID9cclxuICAgICAgICBpZiAoaW5kZXggIT09IC0xKSB7XHJcbiAgICAgICAgICAgICRhcnJheS5yZW1vdmVJbmRleCh0aGlzLl92YWx1ZXMsIGluZGV4KTtcclxuICAgICAgICAgICAgaWYgKHRvSW5kZXggPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdG9JbmRleCA9IHRoaXMuX3ZhbHVlcy5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl92YWx1ZXMucHVzaCh2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9vbk1vdmVJbmRleChpbmRleCwgdG9JbmRleCwgdmFsdWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgJGFycmF5Lmluc2VydEluZGV4KHRoaXMuX3ZhbHVlcywgdG9JbmRleCwgdmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fb25Nb3ZlSW5kZXgoaW5kZXgsIHRvSW5kZXgsIHZhbHVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0b0luZGV4ID09IG51bGwpIHtcclxuICAgICAgICAgICAgdGhpcy5fdmFsdWVzLnB1c2godmFsdWUpO1xyXG4gICAgICAgICAgICB0aGlzLl9vblB1c2godmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgJGFycmF5Lmluc2VydEluZGV4KHRoaXMuX3ZhbHVlcywgdG9JbmRleCwgdmFsdWUpO1xyXG4gICAgICAgICAgICB0aGlzLl9vbkluc2VydEluZGV4KHRvSW5kZXgsIHZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIGFuIGl0ZW0gdG8gdGhlIGVuZCBvZiB0aGUgbGlzdC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gaXRlbSAgQW4gaXRlbSB0byBhZGRcclxuICAgICAqL1xyXG4gICAgcHVzaCh2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMuX3ZhbHVlcy5wdXNoKHZhbHVlKTtcclxuICAgICAgICB0aGlzLl9vblB1c2godmFsdWUpO1xyXG4gICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBhbiBpdGVtIGFzIGEgZmlyc3QgaXRlbSBpbiB0aGUgbGlzdC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gaXRlbSAgQW4gaXRlbSB0byBhZGRcclxuICAgICAqL1xyXG4gICAgdW5zaGlmdCh2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMuaW5zZXJ0SW5kZXgoMCwgdmFsdWUpO1xyXG4gICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBtdWx0aXBsZSBpdGVtcyB0byB0aGUgbGlzdC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gaXRlbXMgIEFuIEFycmF5IG9mIGl0ZW1zIHRvIGFkZFxyXG4gICAgICovXHJcbiAgICBwdXNoQWxsKHZhbHVlcykge1xyXG4gICAgICAgICRhcnJheS5lYWNoKHZhbHVlcywgKHZhbHVlKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMucHVzaCh2YWx1ZSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENvcGllcyBhbmQgYWRkcyBpdGVtcyBmcm9tIGFib3RoZXIgbGlzdC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gc291cmNlICBBIGxpc3QgdG9wIGNvcHkgaXRlbXMgZnJvbVxyXG4gICAgICovXHJcbiAgICBjb3B5RnJvbShzb3VyY2UpIHtcclxuICAgICAgICB0aGlzLnB1c2hBbGwoc291cmNlLl92YWx1ZXMpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBsYXN0IGl0ZW0gZnJvbSB0aGUgbGlzdCwgYW5kIHJlbW92ZXMgaXQuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybiBJdGVtXHJcbiAgICAgKi9cclxuICAgIHBvcCgpIHtcclxuICAgICAgICBsZXQgaW5kZXggPSB0aGlzLl92YWx1ZXMubGVuZ3RoIC0gMTtcclxuICAgICAgICByZXR1cm4gaW5kZXggPCAwID8gdW5kZWZpbmVkIDogdGhpcy5yZW1vdmVJbmRleCh0aGlzLl92YWx1ZXMubGVuZ3RoIC0gMSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGZpcnN0IGl0ZW0gZnJvbSB0aGUgbGlzdCwgYW5kIHJlbW92ZXMgaXQuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybiBJdGVtXHJcbiAgICAgKi9cclxuICAgIHNoaWZ0KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl92YWx1ZXMubGVuZ3RoID8gdGhpcy5yZW1vdmVJbmRleCgwKSA6IHVuZGVmaW5lZDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyBtdWx0aXBsZSBpdGVtcyB0byB0aGUgbGlzdC5cclxuICAgICAqXHJcbiAgICAgKiBBbGwgY3VycmVudCBpdGVtcyBhcmUgcmVtb3ZlZC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gbmV3QXJyYXkgIE5ldyBpdGVtc1xyXG4gICAgICovXHJcbiAgICBzZXRBbGwobmV3QXJyYXkpIHtcclxuICAgICAgICBjb25zdCBvbGQgPSB0aGlzLl92YWx1ZXM7XHJcbiAgICAgICAgdGhpcy5fdmFsdWVzID0gW107XHJcbiAgICAgICAgdGhpcy5fb25DbGVhcihvbGQpO1xyXG4gICAgICAgICRhcnJheS5lYWNoKG5ld0FycmF5LCAodmFsdWUpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5fdmFsdWVzLnB1c2godmFsdWUpO1xyXG4gICAgICAgICAgICB0aGlzLl9vblB1c2godmFsdWUpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmVzIGFsbCBpdGVtcyBmcm9tIHRoZSBsaXN0LlxyXG4gICAgICovXHJcbiAgICBjbGVhcigpIHtcclxuICAgICAgICB0aGlzLnNldEFsbChbXSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYW4gRVM2IGl0ZXJhdG9yIGZvciB0aGUgbGlzdC5cclxuICAgICAqL1xyXG4gICAgKltTeW1ib2wuaXRlcmF0b3JdKCkge1xyXG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IHRoaXMuX3ZhbHVlcy5sZW5ndGg7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICB5aWVsZCB0aGlzLl92YWx1ZXNbaV07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxscyBgZmAgZm9yIGVhY2ggZWxlbWVudCBpbiB0aGUgbGlzdC5cclxuICAgICAqXHJcbiAgICAgKiBgZmAgc2hvdWxkIGhhdmUgYXQgbGVhc3Qgb25lIHBhcmFtZXRlciBkZWZpbmVkIHdoaWNoIHdpbGwgZ2V0IGEgY3VycmVudFxyXG4gICAgICogaXRlbSwgd2l0aCBvcHRpb25hbCBzZWNvbmQgYXJndW1lbnQgLSBpbmRleC5cclxuICAgICAqL1xyXG4gICAgZWFjaChmKSB7XHJcbiAgICAgICAgJGFycmF5LmVhY2godGhpcy5fdmFsdWVzLCBmKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ2FsbHMgYGZgIGZvciBlYWNoIGVsZW1lbnQgaW4gdGhlIGxpc3QsIGZyb20gcmlnaHQgdG8gbGVmdC5cclxuICAgICAqXHJcbiAgICAgKiBgZmAgc2hvdWxkIGhhdmUgYXQgbGVhc3Qgb25lIHBhcmFtZXRlciBkZWZpbmVkIHdoaWNoIHdpbGwgZ2V0IGEgY3VycmVudFxyXG4gICAgICogaXRlbSwgd2l0aCBvcHRpb25hbCBzZWNvbmQgYXJndW1lbnQgLSBpbmRleC5cclxuICAgICAqL1xyXG4gICAgZWFjaFJldmVyc2UoZikge1xyXG4gICAgICAgICRhcnJheS5lYWNoUmV2ZXJzZSh0aGlzLl92YWx1ZXMsIGYpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBBIHZlcnNpb24gb2YgYSBbW0xpc3RdXSB3aGVyZSB0aGUgZWxlbWVudHMgYXJlIGRpc3Bvc2VkIGF1dG9tYXRpY2FsbHkgd2hlblxyXG4gKiByZW1vdmVkIGZyb20gdGhlIGxpc3QsIHVubGVzcyBgYXV0b0Rpc3Bvc2VgIGlzIHNldCB0byBgZmFsc2VgLlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIExpc3RBdXRvRGlzcG9zZSBleHRlbmRzIExpc3Qge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBdXRvbWF0aWNhbGx5IGRpc3Bvc2VzIGVsZW1lbnRzIHRoYXQgYXJlIHJlbW92ZWQgZnJvbSB0aGUgbGlzdC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBkZWZhdWx0IHRydWVcclxuICAgICAgICAgKi9cclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJhdXRvRGlzcG9zZVwiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX2Rpc3Bvc2VkXCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IGZhbHNlXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBfb25TZXRJbmRleChpbmRleCwgb2xkVmFsdWUsIG5ld1ZhbHVlKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuYXV0b0Rpc3Bvc2UpIHtcclxuICAgICAgICAgICAgb2xkVmFsdWUuZGlzcG9zZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzdXBlci5fb25TZXRJbmRleChpbmRleCwgb2xkVmFsdWUsIG5ld1ZhbHVlKTtcclxuICAgIH1cclxuICAgIF9vblJlbW92ZUluZGV4KGluZGV4LCBvbGRWYWx1ZSkge1xyXG4gICAgICAgIGlmICh0aGlzLmF1dG9EaXNwb3NlKSB7XHJcbiAgICAgICAgICAgIG9sZFZhbHVlLmRpc3Bvc2UoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgc3VwZXIuX29uUmVtb3ZlSW5kZXgoaW5kZXgsIG9sZFZhbHVlKTtcclxuICAgIH1cclxuICAgIF9vbkNsZWFyKG9sZFZhbHVlcykge1xyXG4gICAgICAgIGlmICh0aGlzLmF1dG9EaXNwb3NlKSB7XHJcbiAgICAgICAgICAgICRhcnJheS5lYWNoKG9sZFZhbHVlcywgKHgpID0+IHtcclxuICAgICAgICAgICAgICAgIHguZGlzcG9zZSgpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgc3VwZXIuX29uQ2xlYXIob2xkVmFsdWVzKTtcclxuICAgIH1cclxuICAgIGlzRGlzcG9zZWQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Rpc3Bvc2VkO1xyXG4gICAgfVxyXG4gICAgZGlzcG9zZSgpIHtcclxuICAgICAgICBpZiAoIXRoaXMuX2Rpc3Bvc2VkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2Rpc3Bvc2VkID0gdHJ1ZTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuYXV0b0Rpc3Bvc2UpIHtcclxuICAgICAgICAgICAgICAgICRhcnJheS5lYWNoKHRoaXMuX3ZhbHVlcywgKHgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB4LmRpc3Bvc2UoKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBBIHZlcnNpb24gb2YgYSBbW0xpc3RdXSB0aGF0IGlzIGFibGUgdG8gY3JlYXRlIG5ldyBlbGVtZW50cyBhcyB3ZWxsIGFzXHJcbiAqIGFwcGx5IGFkZGl0aW9uYWwgc2V0dGluZ3MgdG8gbmV3bHkgY3JlYXRlZCBpdGVtcy5cclxuICpcclxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly93d3cuYW1jaGFydHMuY29tL2RvY3MvdjUvY29uY2VwdHMvc2V0dGluZ3MvbGlzdC10ZW1wbGF0ZXMvfSBmb3IgbW9yZSBpbmZvXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgTGlzdFRlbXBsYXRlIGV4dGVuZHMgTGlzdEF1dG9EaXNwb3NlIHtcclxuICAgIGNvbnN0cnVjdG9yKHRlbXBsYXRlLCBtYWtlKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ0ZW1wbGF0ZVwiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJtYWtlXCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMudGVtcGxhdGUgPSB0ZW1wbGF0ZTtcclxuICAgICAgICB0aGlzLm1ha2UgPSBtYWtlO1xyXG4gICAgfVxyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUxpc3QuanMubWFwIiwiaW1wb3J0IHsgaXNOdW1iZXIgfSBmcm9tIFwiLi9UeXBlXCI7XHJcbi8qKlxyXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAqIENPTlNUQU5UU1xyXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAqIEBoaWRkZW5cclxuICovXHJcbmV4cG9ydCBjb25zdCBQSSA9IE1hdGguUEk7XHJcbmV4cG9ydCBjb25zdCBIQUxGUEkgPSBQSSAvIDI7XHJcbmV4cG9ydCBjb25zdCBSQURJQU5TID0gUEkgLyAxODA7XHJcbmV4cG9ydCBjb25zdCBERUdSRUVTID0gMTgwIC8gUEk7XHJcbi8qKlxyXG4gKiBSb3VuZHMgdGhlIG51bWVyaWMgdmFsdWUgdG8gd2hvbGUgbnVtYmVyIG9yIHNwZWNpZmljIHByZWNpc2lvbiBvZiBzZXQuXHJcbiAqXHJcbiAqIEBwYXJhbSB2YWx1ZSAgICAgIFZhbHVlXHJcbiAqIEBwYXJhbSBwcmVjaXNpb24gIFByZWNpc2lvbiAobnVtYmVyIG9mIGRlY2ltYWwgcG9pbnRzKVxyXG4gKiBAcGFyYW0gZmxvb3IgIEluIGNhc2UgdmFsdWUgZW5kcyB3aXRoIDAuNSBhbmQgcHJlY2lzaW9uIGlzIDAsIHdlIG1pZ2h0IG5lZWQgdG8gZmxvb3IgdGhlIHZhbHVlIGluc3RlYWQgb2YgY2VpbGluZyBpdC5cclxuICogQHJldHVybiBSb3VuZGVkIHZhbHVlXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gcm91bmQodmFsdWUsIHByZWNpc2lvbiwgZmxvb3IpIHtcclxuICAgIGlmICghaXNOdW1iZXIocHJlY2lzaW9uKSB8fCBwcmVjaXNpb24gPD0gMCkge1xyXG4gICAgICAgIGxldCByb3VuZGVkID0gTWF0aC5yb3VuZCh2YWx1ZSk7XHJcbiAgICAgICAgaWYgKGZsb29yKSB7XHJcbiAgICAgICAgICAgIGlmIChyb3VuZGVkIC0gdmFsdWUgPT0gMC41KSB7XHJcbiAgICAgICAgICAgICAgICByb3VuZGVkLS07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJvdW5kZWQ7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBsZXQgZCA9IE1hdGgucG93KDEwLCBwcmVjaXNpb24pO1xyXG4gICAgICAgIHJldHVybiBNYXRoLnJvdW5kKHZhbHVlICogZCkgLyBkO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBDZWlscyB0aGUgbnVtZXJpYyB2YWx1ZSB0byB3aG9sZSBudW1iZXIgb3Igc3BlY2lmaWMgcHJlY2lzaW9uIG9mIHNldC5cclxuICpcclxuICogQHBhcmFtIHZhbHVlICAgICAgVmFsdWVcclxuICogQHBhcmFtIHByZWNpc2lvbiAgUHJlY2lzaW9uIChudW1iZXIgb2YgZGVjaW1hbCBwb2ludHMpXHJcbiAqIEByZXR1cm4gUm91bmRlZCB2YWx1ZVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGNlaWwodmFsdWUsIHByZWNpc2lvbikge1xyXG4gICAgaWYgKCFpc051bWJlcihwcmVjaXNpb24pIHx8IHByZWNpc2lvbiA8PSAwKSB7XHJcbiAgICAgICAgcmV0dXJuIE1hdGguY2VpbCh2YWx1ZSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBsZXQgZCA9IE1hdGgucG93KDEwLCBwcmVjaXNpb24pO1xyXG4gICAgICAgIHJldHVybiBNYXRoLmNlaWwodmFsdWUgKiBkKSAvIGQ7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFtnZXRDdWJpY0NvbnRyb2xQb2ludEEgZGVzY3JpcHRpb25dXHJcbiAqXHJcbiAqIEBpZ25vcmUgRXhjbHVkZSBmcm9tIGRvY3NcclxuICogQHRvZG8gRGVzY3JpcHRpb25cclxuICogQHBhcmFtIHAwICAgICAgICBbZGVzY3JpcHRpb25dXHJcbiAqIEBwYXJhbSBwMSAgICAgICAgW2Rlc2NyaXB0aW9uXVxyXG4gKiBAcGFyYW0gcDIgICAgICAgIFtkZXNjcmlwdGlvbl1cclxuICogQHBhcmFtIHAzICAgICAgICBbZGVzY3JpcHRpb25dXHJcbiAqIEBwYXJhbSB0ZW5zaW9uWCAgW2Rlc2NyaXB0aW9uXVxyXG4gKiBAcGFyYW0gdGVuc2lvblkgIFtkZXNjcmlwdGlvbl1cclxuICogQHJldHVybiBbZGVzY3JpcHRpb25dXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q3ViaWNDb250cm9sUG9pbnRBKHAwLCBwMSwgcDIsIHRlbnNpb25YLCB0ZW5zaW9uWSkge1xyXG4gICAgcmV0dXJuIHsgeDogKCgtcDAueCArIHAxLnggLyB0ZW5zaW9uWCArIHAyLngpICogdGVuc2lvblgpLCB5OiAoKC1wMC55ICsgcDEueSAvIHRlbnNpb25ZICsgcDIueSkgKiB0ZW5zaW9uWSkgfTtcclxufVxyXG4vKipcclxuICogW2dldEN1YmljQ29udHJvbFBvaW50QiBkZXNjcmlwdGlvbl1cclxuICpcclxuICogQGlnbm9yZSBFeGNsdWRlIGZyb20gZG9jc1xyXG4gKiBAdG9kbyBEZXNjcmlwdGlvblxyXG4gKiBAcGFyYW0gcDAgICAgICAgIFtkZXNjcmlwdGlvbl1cclxuICogQHBhcmFtIHAxICAgICAgICBbZGVzY3JpcHRpb25dXHJcbiAqIEBwYXJhbSBwMiAgICAgICAgW2Rlc2NyaXB0aW9uXVxyXG4gKiBAcGFyYW0gcDMgICAgICAgIFtkZXNjcmlwdGlvbl1cclxuICogQHBhcmFtIHRlbnNpb25YICBbZGVzY3JpcHRpb25dXHJcbiAqIEBwYXJhbSB0ZW5zaW9uWSAgW2Rlc2NyaXB0aW9uXVxyXG4gKiBAcmV0dXJuIFtkZXNjcmlwdGlvbl1cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRDdWJpY0NvbnRyb2xQb2ludEIocDEsIHAyLCBwMywgdGVuc2lvblgsIHRlbnNpb25ZKSB7XHJcbiAgICByZXR1cm4geyB4OiAoKHAxLnggKyBwMi54IC8gdGVuc2lvblggLSBwMy54KSAqIHRlbnNpb25YKSwgeTogKChwMS55ICsgcDIueSAvIHRlbnNpb25ZIC0gcDMueSkgKiB0ZW5zaW9uWSkgfTtcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gZml0VG9SYW5nZSh2YWx1ZSwgbWluLCBtYXgpIHtcclxuICAgIHJldHVybiBNYXRoLm1pbihNYXRoLm1heCh2YWx1ZSwgbWluKSwgbWF4KTtcclxufVxyXG4vKipcclxuICogUmV0dXJucyBzaW5lIG9mIGFuIGFuZ2xlIHNwZWNpZmllZCBpbiBkZWdyZWVzLlxyXG4gKlxyXG4gKiBAcGFyYW0gdmFsdWUgIFZhbHVlXHJcbiAqIEByZXR1cm4gU2luZVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHNpbihhbmdsZSkge1xyXG4gICAgcmV0dXJuIE1hdGguc2luKFJBRElBTlMgKiBhbmdsZSk7XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybnMgdGFuIG9mIGFuIGFuZ2xlIHNwZWNpZmllZCBpbiBkZWdyZWVzLlxyXG4gKlxyXG4gKiBAcGFyYW0gdmFsdWUgIFZhbHVlXHJcbiAqIEByZXR1cm4gU2luZVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHRhbihhbmdsZSkge1xyXG4gICAgcmV0dXJuIE1hdGgudGFuKFJBRElBTlMgKiBhbmdsZSk7XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybnMgY29zaW5lIG9mIGFuIGFuZ2xlIHNwZWNpZmllZCBpbiBkZWdyZWVzLlxyXG4gKlxyXG4gKiBAcGFyYW0gdmFsdWUgIFZhbHVlXHJcbiAqIEByZXR1cm4gQ29zaW5lXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gY29zKGFuZ2xlKSB7XHJcbiAgICByZXR1cm4gTWF0aC5jb3MoUkFESUFOUyAqIGFuZ2xlKTtcclxufVxyXG4vLyAwIHRvIDM2MFxyXG5leHBvcnQgZnVuY3Rpb24gbm9ybWFsaXplQW5nbGUodmFsdWUpIHtcclxuICAgIHZhbHVlID0gdmFsdWUgJSAzNjA7XHJcbiAgICBpZiAodmFsdWUgPCAwKSB7XHJcbiAgICAgICAgdmFsdWUgKz0gMzYwO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHZhbHVlO1xyXG59XHJcbi8vIFRPRE8gdGhpcyBkb2Vzbid0IHdvcmsgcHJvcGVybHkgZm9yIHNrZXdpbmcsIGFuZCBpdCdzIHByb2JhYmx5IGJyb2tlbiBmb3Igcm90YXRpb24gdG9vXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRBcmNCb3VuZHMoY3gsIGN5LCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgcmFkaXVzKSB7XHJcbiAgICBsZXQgbWluWCA9IE51bWJlci5NQVhfVkFMVUU7XHJcbiAgICBsZXQgbWluWSA9IE51bWJlci5NQVhfVkFMVUU7XHJcbiAgICBsZXQgbWF4WCA9IC1OdW1iZXIuTUFYX1ZBTFVFO1xyXG4gICAgbGV0IG1heFkgPSAtTnVtYmVyLk1BWF9WQUxVRTtcclxuICAgIGxldCBicG9pbnRzID0gW107XHJcbiAgICBicG9pbnRzLnB1c2goZ2V0QXJjUG9pbnQocmFkaXVzLCBzdGFydEFuZ2xlKSk7XHJcbiAgICBicG9pbnRzLnB1c2goZ2V0QXJjUG9pbnQocmFkaXVzLCBlbmRBbmdsZSkpO1xyXG4gICAgbGV0IGZyb21BbmdsZSA9IE1hdGgubWluKE1hdGguZmxvb3Ioc3RhcnRBbmdsZSAvIDkwKSAqIDkwLCBNYXRoLmZsb29yKGVuZEFuZ2xlIC8gOTApICogOTApO1xyXG4gICAgbGV0IHRvQW5nbGUgPSBNYXRoLm1heChNYXRoLmNlaWwoc3RhcnRBbmdsZSAvIDkwKSAqIDkwLCBNYXRoLmNlaWwoZW5kQW5nbGUgLyA5MCkgKiA5MCk7XHJcbiAgICBmb3IgKGxldCBhbmdsZSA9IGZyb21BbmdsZTsgYW5nbGUgPD0gdG9BbmdsZTsgYW5nbGUgKz0gOTApIHtcclxuICAgICAgICBpZiAoYW5nbGUgPj0gc3RhcnRBbmdsZSAmJiBhbmdsZSA8PSBlbmRBbmdsZSkge1xyXG4gICAgICAgICAgICBicG9pbnRzLnB1c2goZ2V0QXJjUG9pbnQocmFkaXVzLCBhbmdsZSkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnBvaW50cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGxldCBwdCA9IGJwb2ludHNbaV07XHJcbiAgICAgICAgaWYgKHB0LnggPCBtaW5YKSB7XHJcbiAgICAgICAgICAgIG1pblggPSBwdC54O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocHQueSA8IG1pblkpIHtcclxuICAgICAgICAgICAgbWluWSA9IHB0Lnk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChwdC54ID4gbWF4WCkge1xyXG4gICAgICAgICAgICBtYXhYID0gcHQueDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHB0LnkgPiBtYXhZKSB7XHJcbiAgICAgICAgICAgIG1heFkgPSBwdC55O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiAoeyBsZWZ0OiBjeCArIG1pblgsIHRvcDogY3kgKyBtaW5ZLCByaWdodDogY3ggKyBtYXhYLCBib3R0b206IGN5ICsgbWF4WSB9KTtcclxufVxyXG4vKipcclxuICogUmV0dXJucyBwb2ludCBvbiBhcmNcclxuICpcclxuICogQHBhcmFtIGNlbnRlciBwb2ludFxyXG4gKiBAcGFyYW0gcmFkaXVzXHJcbiAqIEBwYXJhbSBhcmNcclxuICogQHJldHVybiB7Ym9vbGVhbn1cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRBcmNQb2ludChyYWRpdXMsIGFyYykge1xyXG4gICAgcmV0dXJuICh7IHg6IHJhZGl1cyAqIGNvcyhhcmMpLCB5OiByYWRpdXMgKiBzaW4oYXJjKSB9KTtcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gbWVyZ2VCb3VuZHMoYm91bmRzKSB7XHJcbiAgICBjb25zdCBsZW4gPSBib3VuZHMubGVuZ3RoO1xyXG4gICAgaWYgKGxlbiA+IDApIHtcclxuICAgICAgICBsZXQgYm91bmQgPSBib3VuZHNbMF07XHJcbiAgICAgICAgbGV0IGxlZnQgPSBib3VuZC5sZWZ0O1xyXG4gICAgICAgIGxldCB0b3AgPSBib3VuZC50b3A7XHJcbiAgICAgICAgbGV0IHJpZ2h0ID0gYm91bmQucmlnaHQ7XHJcbiAgICAgICAgbGV0IGJvdHRvbSA9IGJvdW5kLmJvdHRvbTtcclxuICAgICAgICBpZiAobGVuID4gMSkge1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBib3VuZCA9IGJvdW5kc1tpXTtcclxuICAgICAgICAgICAgICAgIGxlZnQgPSBNYXRoLm1pbihib3VuZC5sZWZ0LCBsZWZ0KTtcclxuICAgICAgICAgICAgICAgIHJpZ2h0ID0gTWF0aC5tYXgoYm91bmQucmlnaHQsIHJpZ2h0KTtcclxuICAgICAgICAgICAgICAgIHRvcCA9IE1hdGgubWluKGJvdW5kLnRvcCwgdG9wKTtcclxuICAgICAgICAgICAgICAgIGJvdHRvbSA9IE1hdGgubWF4KGJvdW5kLmJvdHRvbSwgYm90dG9tKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4geyBsZWZ0LCByaWdodCwgdG9wLCBib3R0b20gfTtcclxuICAgIH1cclxuICAgIHJldHVybiB7IGxlZnQ6IDAsIHJpZ2h0OiAwLCB0b3A6IDAsIGJvdHRvbTogMCB9O1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiBmaXRBbmdsZVRvUmFuZ2UodmFsdWUsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlKSB7XHJcbiAgICBpZiAoc3RhcnRBbmdsZSA+IGVuZEFuZ2xlKSB7XHJcbiAgICAgICAgbGV0IHRlbXAgPSBzdGFydEFuZ2xlO1xyXG4gICAgICAgIHN0YXJ0QW5nbGUgPSBlbmRBbmdsZTtcclxuICAgICAgICBlbmRBbmdsZSA9IHRlbXA7XHJcbiAgICB9XHJcbiAgICB2YWx1ZSA9IG5vcm1hbGl6ZUFuZ2xlKHZhbHVlKTtcclxuICAgIGxldCBjb3VudCA9IChzdGFydEFuZ2xlIC0gbm9ybWFsaXplQW5nbGUoc3RhcnRBbmdsZSkpIC8gMzYwO1xyXG4gICAgaWYgKHZhbHVlIDwgc3RhcnRBbmdsZSkge1xyXG4gICAgICAgIHZhbHVlICs9IDM2MCAqIChjb3VudCArIDEpO1xyXG4gICAgfVxyXG4gICAgbGV0IG1heEVuZCA9IHN0YXJ0QW5nbGUgKyAoZW5kQW5nbGUgLSBzdGFydEFuZ2xlKSAvIDIgKyAxODA7XHJcbiAgICBsZXQgbWF4U3RhcnQgPSBzdGFydEFuZ2xlICsgKGVuZEFuZ2xlIC0gc3RhcnRBbmdsZSkgLyAyIC0gMTgwO1xyXG4gICAgaWYgKHZhbHVlID4gZW5kQW5nbGUpIHtcclxuICAgICAgICBpZiAodmFsdWUgLSAzNjAgPiBzdGFydEFuZ2xlKSB7XHJcbiAgICAgICAgICAgIHZhbHVlIC09IDM2MDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmICh2YWx1ZSA8IG1heEVuZCkge1xyXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBlbmRBbmdsZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHZhbHVlID0gc3RhcnRBbmdsZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmICh2YWx1ZSA8IHN0YXJ0QW5nbGUpIHtcclxuICAgICAgICBpZiAodmFsdWUgPiBtYXhTdGFydCkge1xyXG4gICAgICAgICAgICB2YWx1ZSA9IHN0YXJ0QW5nbGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB2YWx1ZSA9IGVuZEFuZ2xlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB2YWx1ZTtcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gaW5Cb3VuZHMocG9pbnQsIGJvdW5kcykge1xyXG4gICAgaWYgKHBvaW50LnggPj0gYm91bmRzLmxlZnQgJiYgcG9pbnQueSA+PSBib3VuZHMudG9wICYmIHBvaW50LnggPD0gYm91bmRzLnJpZ2h0ICYmIHBvaW50LnkgPD0gYm91bmRzLmJvdHRvbSkge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRBbmdsZShwb2ludDEsIHBvaW50Mikge1xyXG4gICAgaWYgKCFwb2ludDIpIHtcclxuICAgICAgICBwb2ludDIgPSB7IHg6IHBvaW50MS54ICogMiwgeTogcG9pbnQxLnkgKiAyIH07XHJcbiAgICB9XHJcbiAgICBsZXQgZGlmZlggPSBwb2ludDIueCAtIHBvaW50MS54O1xyXG4gICAgbGV0IGRpZmZZID0gcG9pbnQyLnkgLSBwb2ludDEueTtcclxuICAgIGxldCBhbmdsZSA9IE1hdGguYXRhbjIoZGlmZlksIGRpZmZYKSAqIERFR1JFRVM7XHJcbiAgICBpZiAoYW5nbGUgPCAwKSB7XHJcbiAgICAgICAgYW5nbGUgKz0gMzYwO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG5vcm1hbGl6ZUFuZ2xlKGFuZ2xlKTtcclxufVxyXG4vKipcclxuICogW2dldFBvaW50T25RdWFkcmF0aWNDdXJ2ZSBkZXNjcmlwdGlvbl1cclxuICpcclxuICogQGlnbm9yZSBFeGNsdWRlIGZyb20gZG9jc1xyXG4gKiBAdG9kbyBEZXNjcmlwdGlvblxyXG4gKiBAcGFyYW0gcG9pbnRBICAgICAgICBbZGVzY3JpcHRpb25dXHJcbiAqIEBwYXJhbSBwb2ludEIgICAgICAgIFtkZXNjcmlwdGlvbl1cclxuICogQHBhcmFtIGNvbnRyb2xQb2ludCAgW2Rlc2NyaXB0aW9uXVxyXG4gKiBAcGFyYW0gcG9zaXRpb24gICAgICBbZGVzY3JpcHRpb25dXHJcbiAqIEByZXR1cm4gW2Rlc2NyaXB0aW9uXVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGdldFBvaW50T25RdWFkcmF0aWNDdXJ2ZShwb2ludEEsIHBvaW50QiwgY29udHJvbFBvaW50LCBwb3NpdGlvbikge1xyXG4gICAgbGV0IHggPSAoMSAtIHBvc2l0aW9uKSAqICgxIC0gcG9zaXRpb24pICogcG9pbnRBLnggKyAyICogKDEgLSBwb3NpdGlvbikgKiBwb3NpdGlvbiAqIGNvbnRyb2xQb2ludC54ICsgcG9zaXRpb24gKiBwb3NpdGlvbiAqIHBvaW50Qi54O1xyXG4gICAgbGV0IHkgPSAoMSAtIHBvc2l0aW9uKSAqICgxIC0gcG9zaXRpb24pICogcG9pbnRBLnkgKyAyICogKDEgLSBwb3NpdGlvbikgKiBwb3NpdGlvbiAqIGNvbnRyb2xQb2ludC55ICsgcG9zaXRpb24gKiBwb3NpdGlvbiAqIHBvaW50Qi55O1xyXG4gICAgcmV0dXJuIHsgeDogeCwgeTogeSB9O1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRQb2ludE9uTGluZShwb2ludEEsIHBvaW50QiwgcG9zaXRpb24pIHtcclxuICAgIHJldHVybiB7IHg6IHBvaW50QS54ICsgKHBvaW50Qi54IC0gcG9pbnRBLngpICogcG9zaXRpb24sIHk6IHBvaW50QS55ICsgKHBvaW50Qi55IC0gcG9pbnRBLnkpICogcG9zaXRpb24gfTtcclxufVxyXG4vKipcclxuICogUmV0dXJucyB0aGUgY2xvc2VzdCB2YWx1ZSBmcm9tIHRoZSBhcnJheSBvZiB2YWx1ZXMgdG8gdGhlIHJlZmVyZW5jZSB2YWx1ZS5cclxuICpcclxuICogQHBhcmFtIHZhbHVlcyAgQXJyYXkgb2YgdmFsdWVzXHJcbiAqIEBwYXJhbSB2YWx1ZSAgIFJlZmVyZW5jZSB2YWx1ZVxyXG4gKiBAcmV0dXJuIENsb3NlcyB2YWx1ZSBmcm9tIHRoZSBhcnJheVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGNsb3Nlc3QodmFsdWVzLCByZWZlcmVuY2VWYWx1ZSkge1xyXG4gICAgcmV0dXJuIHZhbHVlcy5yZWR1Y2UoZnVuY3Rpb24gKHByZXYsIGN1cnIpIHtcclxuICAgICAgICByZXR1cm4gKE1hdGguYWJzKGN1cnIgLSByZWZlcmVuY2VWYWx1ZSkgPCBNYXRoLmFicyhwcmV2IC0gcmVmZXJlbmNlVmFsdWUpID8gY3VyciA6IHByZXYpO1xyXG4gICAgfSk7XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybnMgdHJ1ZSBpZiBib3VuZHMgb3ZlcmxhcFxyXG4gKiBAcGFyYW0gYm91bmRzMSBJQm91bmRzXHJcbiAqIEBwYXJhbSBib3VuZHMyIElCb3VuZHNcclxuICogQHJldHVybnMgYm9vbGVhblxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGJvdW5kc092ZXJsYXAoYm91bmRzMSwgYm91bmRzMikge1xyXG4gICAgY29uc3QgaG9yaXpvbnRhbE92ZXJsYXAgPSBib3VuZHMxLmxlZnQgPCBib3VuZHMyLnJpZ2h0ICYmIGJvdW5kczEucmlnaHQgPiBib3VuZHMyLmxlZnQ7XHJcbiAgICBjb25zdCB2ZXJ0aWNhbE92ZXJsYXAgPSBib3VuZHMxLnRvcCA8IGJvdW5kczIuYm90dG9tICYmIGJvdW5kczEuYm90dG9tID4gYm91bmRzMi50b3A7XHJcbiAgICByZXR1cm4gaG9yaXpvbnRhbE92ZXJsYXAgJiYgdmVydGljYWxPdmVybGFwO1xyXG59XHJcbi8qKlxyXG4gKiBHZW5lcmF0ZXMgcG9pbnRzIG9mIGEgc3BpcmFsXHJcbiAqIEBwYXJhbSBjeFxyXG4gKiBAcGFyYW0gY3lcclxuICogQHBhcmFtIHJhZGl1c1xyXG4gKiBAcGFyYW0gcmFkaXVzWVxyXG4gKiBAcGFyYW0gaW5uZXJSYWRpdXNcclxuICogQHBhcmFtIHN0ZXBcclxuICogQHBhcmFtIHJhZGl1c1N0ZXBcclxuICogQHBhcmFtIHN0YXJ0QW5nbGVcclxuICogQHBhcmFtIGVuZEFuZ2xlXHJcbiAqIEByZXR1cm5zIElQb2ludFtdXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gc3BpcmFsUG9pbnRzKGN4LCBjeSwgcmFkaXVzLCByYWRpdXNZLCBpbm5lclJhZGl1cywgc3RlcCwgcmFkaXVzU3RlcCwgc3RhcnRBbmdsZSwgZW5kQW5nbGUpIHtcclxuICAgIGxldCByID0gaW5uZXJSYWRpdXMgKyAwLjAxO1xyXG4gICAgbGV0IGFuZ2xlID0gc3RhcnRBbmdsZSAqIFJBRElBTlM7XHJcbiAgICBsZXQgcG9pbnRzID0gW107XHJcbiAgICB3aGlsZSAociA8IHJhZGl1cyArIHJhZGl1c1N0ZXApIHtcclxuICAgICAgICBsZXQgc3RlcFNpemUgPSBzdGVwO1xyXG4gICAgICAgIGlmIChzdGVwU2l6ZSAvIDIgPiByKSB7XHJcbiAgICAgICAgICAgIHN0ZXBTaXplID0gMiAqIHI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGFuZ2xlICs9IDIgKiBNYXRoLmFzaW4oc3RlcFNpemUgLyAyIC8gcik7XHJcbiAgICAgICAgaWYgKGFuZ2xlICogREVHUkVFUyA+IGVuZEFuZ2xlICsgKChyYWRpdXMgLSBpbm5lclJhZGl1cykgLyByYWRpdXNTdGVwKSAqIDM2MCkge1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IGRlZ3JlZXMgPSBhbmdsZSAqIERFR1JFRVM7XHJcbiAgICAgICAgbGV0IHBvaW50ID0geyB4OiBjeCArIHIgKiBNYXRoLmNvcyhhbmdsZSksIHk6IGN5ICsgciAqIHJhZGl1c1kgLyByYWRpdXMgKiBNYXRoLnNpbihhbmdsZSkgfTtcclxuICAgICAgICBwb2ludHMucHVzaChwb2ludCk7XHJcbiAgICAgICAgciA9IGlubmVyUmFkaXVzICsgZGVncmVlcyAvIDM2MCAqIHJhZGl1c1N0ZXA7XHJcbiAgICB9XHJcbiAgICBwb2ludHMuc2hpZnQoKTtcclxuICAgIHJldHVybiBwb2ludHM7XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybnMgdHJ1ZSBpZiBjaXJjbGVzIG92ZXJsYXBcclxuICogQHBhcmFtIGNpcmNsZTFcclxuICogQHBhcmFtIGNpcmNsZTJcclxuICogQHJldHVybnMgYm9vbGVhblxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGNpcmNsZXNPdmVybGFwKGNpcmNsZTEsIGNpcmNsZTIpIHtcclxuICAgIHJldHVybiBNYXRoLmh5cG90KGNpcmNsZTEueCAtIGNpcmNsZTIueCwgY2lyY2xlMS55IC0gY2lyY2xlMi55KSA8PSBjaXJjbGUxLnJhZGl1cyArIGNpcmNsZTIucmFkaXVzO1xyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU1hdGguanMubWFwIiwiLyoqXHJcbiAqIE1vZGlmaWVkIGZyb20gUGl4aTpcclxuICpcclxuICogVGhlIE1JVCBMaWNlbnNlXHJcbiAqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxMy0yMDE3IE1hdGhldyBHcm92ZXMsIENoYWQgRW5nbGVyXHJcbiAqXHJcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcclxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxyXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXHJcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcclxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXHJcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XHJcbiAqXHJcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXHJcbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxyXG4gKlxyXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXHJcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxyXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcclxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxyXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxyXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXHJcbiAqIFRIRSBTT0ZUV0FSRS5cclxuICovXHJcbi8qKlxyXG4gKiBAaWdub3JlXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgTWF0cml4IHtcclxuICAgIGNvbnN0cnVjdG9yKGEgPSAxLCBiID0gMCwgYyA9IDAsIGQgPSAxLCB0eCA9IDAsIHR5ID0gMCkge1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImFcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiYlwiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJjXCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImRcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwidHhcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwidHlcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5hID0gYTtcclxuICAgICAgICB0aGlzLmIgPSBiO1xyXG4gICAgICAgIHRoaXMuYyA9IGM7XHJcbiAgICAgICAgdGhpcy5kID0gZDtcclxuICAgICAgICB0aGlzLnR4ID0gdHg7XHJcbiAgICAgICAgdGhpcy50eSA9IHR5O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSBtYXRyaXggYmFzZWQgb24gYWxsIHRoZSBhdmFpbGFibGUgcHJvcGVydGllc1xyXG4gICAgICovXHJcbiAgICBzZXRUcmFuc2Zvcm0oeCwgeSwgcGl2b3RYLCBwaXZvdFksIHJvdGF0aW9uLCBzY2FsZSA9IDEpIHtcclxuICAgICAgICB0aGlzLmEgPSBNYXRoLmNvcyhyb3RhdGlvbikgKiBzY2FsZTtcclxuICAgICAgICB0aGlzLmIgPSBNYXRoLnNpbihyb3RhdGlvbikgKiBzY2FsZTtcclxuICAgICAgICB0aGlzLmMgPSAtTWF0aC5zaW4ocm90YXRpb24pICogc2NhbGU7XHJcbiAgICAgICAgdGhpcy5kID0gTWF0aC5jb3Mocm90YXRpb24pICogc2NhbGU7XHJcbiAgICAgICAgdGhpcy50eCA9IHggLSAoKHBpdm90WCAqIHRoaXMuYSkgKyAocGl2b3RZICogdGhpcy5jKSk7XHJcbiAgICAgICAgdGhpcy50eSA9IHkgLSAoKHBpdm90WCAqIHRoaXMuYikgKyAocGl2b3RZICogdGhpcy5kKSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldCBhIG5ldyBwb3NpdGlvbiB3aXRoIHRoZSBjdXJyZW50IHRyYW5zZm9ybWF0aW9uIGFwcGxpZWQuXHJcbiAgICAgKiBDYW4gYmUgdXNlZCB0byBnbyBmcm9tIGEgY2hpbGQncyBjb29yZGluYXRlIHNwYWNlIHRvIHRoZSB3b3JsZCBjb29yZGluYXRlIHNwYWNlLiAoZS5nLiByZW5kZXJpbmcpXHJcbiAgICAgKi9cclxuICAgIGFwcGx5KG9yaWdpbikge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHg6ICh0aGlzLmEgKiBvcmlnaW4ueCkgKyAodGhpcy5jICogb3JpZ2luLnkpICsgdGhpcy50eCxcclxuICAgICAgICAgICAgeTogKHRoaXMuYiAqIG9yaWdpbi54KSArICh0aGlzLmQgKiBvcmlnaW4ueSkgKyB0aGlzLnR5XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0IGEgbmV3IHBvc2l0aW9uIHdpdGggdGhlIGludmVyc2Ugb2YgdGhlIGN1cnJlbnQgdHJhbnNmb3JtYXRpb24gYXBwbGllZC5cclxuICAgICAqIENhbiBiZSB1c2VkIHRvIGdvIGZyb20gdGhlIHdvcmxkIGNvb3JkaW5hdGUgc3BhY2UgdG8gYSBjaGlsZCdzIGNvb3JkaW5hdGUgc3BhY2UuIChlLmcuIGlucHV0KVxyXG4gICAgICovXHJcbiAgICBhcHBseUludmVyc2Uob3JpZ2luKSB7XHJcbiAgICAgICAgY29uc3QgaWQgPSAxIC8gKCh0aGlzLmEgKiB0aGlzLmQpICsgKHRoaXMuYyAqIC10aGlzLmIpKTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB4OiAodGhpcy5kICogaWQgKiBvcmlnaW4ueCkgKyAoLXRoaXMuYyAqIGlkICogb3JpZ2luLnkpICsgKCgodGhpcy50eSAqIHRoaXMuYykgLSAodGhpcy50eCAqIHRoaXMuZCkpICogaWQpLFxyXG4gICAgICAgICAgICB5OiAodGhpcy5hICogaWQgKiBvcmlnaW4ueSkgKyAoLXRoaXMuYiAqIGlkICogb3JpZ2luLngpICsgKCgoLXRoaXMudHkgKiB0aGlzLmEpICsgKHRoaXMudHggKiB0aGlzLmIpKSAqIGlkKVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEFwcGVuZHMgdGhlIGdpdmVuIE1hdHJpeCB0byB0aGlzIE1hdHJpeC5cclxuICAgICAqL1xyXG4gICAgYXBwZW5kKG1hdHJpeCkge1xyXG4gICAgICAgIGNvbnN0IGExID0gdGhpcy5hO1xyXG4gICAgICAgIGNvbnN0IGIxID0gdGhpcy5iO1xyXG4gICAgICAgIGNvbnN0IGMxID0gdGhpcy5jO1xyXG4gICAgICAgIGNvbnN0IGQxID0gdGhpcy5kO1xyXG4gICAgICAgIHRoaXMuYSA9IChtYXRyaXguYSAqIGExKSArIChtYXRyaXguYiAqIGMxKTtcclxuICAgICAgICB0aGlzLmIgPSAobWF0cml4LmEgKiBiMSkgKyAobWF0cml4LmIgKiBkMSk7XHJcbiAgICAgICAgdGhpcy5jID0gKG1hdHJpeC5jICogYTEpICsgKG1hdHJpeC5kICogYzEpO1xyXG4gICAgICAgIHRoaXMuZCA9IChtYXRyaXguYyAqIGIxKSArIChtYXRyaXguZCAqIGQxKTtcclxuICAgICAgICB0aGlzLnR4ID0gKG1hdHJpeC50eCAqIGExKSArIChtYXRyaXgudHkgKiBjMSkgKyB0aGlzLnR4O1xyXG4gICAgICAgIHRoaXMudHkgPSAobWF0cml4LnR4ICogYjEpICsgKG1hdHJpeC50eSAqIGQxKSArIHRoaXMudHk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFByZXBlbmRzIHRoZSBnaXZlbiBNYXRyaXggdG8gdGhpcyBNYXRyaXguXHJcbiAgICAgKi9cclxuICAgIHByZXBlbmQobWF0cml4KSB7XHJcbiAgICAgICAgY29uc3QgdHgxID0gdGhpcy50eDtcclxuICAgICAgICBpZiAobWF0cml4LmEgIT09IDEgfHwgbWF0cml4LmIgIT09IDAgfHwgbWF0cml4LmMgIT09IDAgfHwgbWF0cml4LmQgIT09IDEpIHtcclxuICAgICAgICAgICAgY29uc3QgYTEgPSB0aGlzLmE7XHJcbiAgICAgICAgICAgIGNvbnN0IGMxID0gdGhpcy5jO1xyXG4gICAgICAgICAgICB0aGlzLmEgPSAoYTEgKiBtYXRyaXguYSkgKyAodGhpcy5iICogbWF0cml4LmMpO1xyXG4gICAgICAgICAgICB0aGlzLmIgPSAoYTEgKiBtYXRyaXguYikgKyAodGhpcy5iICogbWF0cml4LmQpO1xyXG4gICAgICAgICAgICB0aGlzLmMgPSAoYzEgKiBtYXRyaXguYSkgKyAodGhpcy5kICogbWF0cml4LmMpO1xyXG4gICAgICAgICAgICB0aGlzLmQgPSAoYzEgKiBtYXRyaXguYikgKyAodGhpcy5kICogbWF0cml4LmQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnR4ID0gKHR4MSAqIG1hdHJpeC5hKSArICh0aGlzLnR5ICogbWF0cml4LmMpICsgbWF0cml4LnR4O1xyXG4gICAgICAgIHRoaXMudHkgPSAodHgxICogbWF0cml4LmIpICsgKHRoaXMudHkgKiBtYXRyaXguZCkgKyBtYXRyaXgudHk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENvcGllcyB0aGUgb3RoZXIgbWF0cml4J3MgcHJvcGVydGllcyBpbnRvIHRoaXMgbWF0cml4XHJcbiAgICAgKi9cclxuICAgIGNvcHlGcm9tKG1hdHJpeCkge1xyXG4gICAgICAgIHRoaXMuYSA9IG1hdHJpeC5hO1xyXG4gICAgICAgIHRoaXMuYiA9IG1hdHJpeC5iO1xyXG4gICAgICAgIHRoaXMuYyA9IG1hdHJpeC5jO1xyXG4gICAgICAgIHRoaXMuZCA9IG1hdHJpeC5kO1xyXG4gICAgICAgIHRoaXMudHggPSBtYXRyaXgudHg7XHJcbiAgICAgICAgdGhpcy50eSA9IG1hdHJpeC50eTtcclxuICAgIH1cclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1NYXRyaXguanMubWFwIiwiaW1wb3J0IHsgRW50aXR5IH0gZnJvbSBcIi4vRW50aXR5XCI7XHJcbmltcG9ydCB7IFRleHRGb3JtYXR0ZXIgfSBmcm9tIFwiLi9UZXh0Rm9ybWF0dGVyXCI7XHJcbmltcG9ydCAqIGFzICRvYmplY3QgZnJvbSBcIi4vT2JqZWN0XCI7XHJcbmltcG9ydCAqIGFzICR1dGlscyBmcm9tIFwiLi9VdGlsc1wiO1xyXG5pbXBvcnQgKiBhcyAkdHlwZSBmcm9tIFwiLi9UeXBlXCI7XHJcbi8qKlxyXG4gKiBOdW1iZXIgZm9ybWF0dGVyXHJcbiAqXHJcbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vd3d3LmFtY2hhcnRzLmNvbS9kb2NzL3Y1L2NvbmNlcHRzL2Zvcm1hdHRlcnMvZm9ybWF0dGluZy1udW1iZXJzL30gZm9yIG1vcmUgaW5mb1xyXG4gKiBAaW1wb3J0YW50XHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgTnVtYmVyRm9ybWF0dGVyIGV4dGVuZHMgRW50aXR5IHtcclxuICAgIF9zZXREZWZhdWx0cygpIHtcclxuICAgICAgICAvLyBEZWZhdWx0c1xyXG4gICAgICAgIHRoaXMuX3NldERlZmF1bHQoXCJuZWdhdGl2ZUJhc2VcIiwgMCk7XHJcbiAgICAgICAgdGhpcy5fc2V0RGVmYXVsdChcIm51bWJlckZvcm1hdFwiLCBcIiMsIyMjLiMjIyMjXCIpO1xyXG4gICAgICAgIHRoaXMuX3NldERlZmF1bHQoXCJzbWFsbE51bWJlclRocmVzaG9sZFwiLCAxLjAwKTtcclxuICAgICAgICBjb25zdCBibnMgPSBcIl9iaWdfbnVtYmVyX3N1ZmZpeF9cIjtcclxuICAgICAgICBjb25zdCBzbnMgPSBcIl9zbWFsbF9udW1iZXJfc3VmZml4X1wiO1xyXG4gICAgICAgIGNvbnN0IGJzID0gXCJfYnl0ZV9zdWZmaXhfXCI7XHJcbiAgICAgICAgdGhpcy5fc2V0RGVmYXVsdChcImJpZ051bWJlclByZWZpeGVzXCIsIFtcclxuICAgICAgICAgICAgeyBcIm51bWJlclwiOiAxZSszLCBcInN1ZmZpeFwiOiB0aGlzLl90KGJucyArIFwiM1wiKSB9LFxyXG4gICAgICAgICAgICB7IFwibnVtYmVyXCI6IDFlKzYsIFwic3VmZml4XCI6IHRoaXMuX3QoYm5zICsgXCI2XCIpIH0sXHJcbiAgICAgICAgICAgIHsgXCJudW1iZXJcIjogMWUrOSwgXCJzdWZmaXhcIjogdGhpcy5fdChibnMgKyBcIjlcIikgfSxcclxuICAgICAgICAgICAgeyBcIm51bWJlclwiOiAxZSsxMiwgXCJzdWZmaXhcIjogdGhpcy5fdChibnMgKyBcIjEyXCIpIH0sXHJcbiAgICAgICAgICAgIHsgXCJudW1iZXJcIjogMWUrMTUsIFwic3VmZml4XCI6IHRoaXMuX3QoYm5zICsgXCIxNVwiKSB9LFxyXG4gICAgICAgICAgICB7IFwibnVtYmVyXCI6IDFlKzE4LCBcInN1ZmZpeFwiOiB0aGlzLl90KGJucyArIFwiMThcIikgfSxcclxuICAgICAgICAgICAgeyBcIm51bWJlclwiOiAxZSsyMSwgXCJzdWZmaXhcIjogdGhpcy5fdChibnMgKyBcIjIxXCIpIH0sXHJcbiAgICAgICAgICAgIHsgXCJudW1iZXJcIjogMWUrMjQsIFwic3VmZml4XCI6IHRoaXMuX3QoYm5zICsgXCIyNFwiKSB9XHJcbiAgICAgICAgXSk7XHJcbiAgICAgICAgdGhpcy5fc2V0RGVmYXVsdChcInNtYWxsTnVtYmVyUHJlZml4ZXNcIiwgW1xyXG4gICAgICAgICAgICB7IFwibnVtYmVyXCI6IDFlLTI0LCBcInN1ZmZpeFwiOiB0aGlzLl90KHNucyArIFwiMjRcIikgfSxcclxuICAgICAgICAgICAgeyBcIm51bWJlclwiOiAxZS0yMSwgXCJzdWZmaXhcIjogdGhpcy5fdChzbnMgKyBcIjIxXCIpIH0sXHJcbiAgICAgICAgICAgIHsgXCJudW1iZXJcIjogMWUtMTgsIFwic3VmZml4XCI6IHRoaXMuX3Qoc25zICsgXCIxOFwiKSB9LFxyXG4gICAgICAgICAgICB7IFwibnVtYmVyXCI6IDFlLTE1LCBcInN1ZmZpeFwiOiB0aGlzLl90KHNucyArIFwiMTVcIikgfSxcclxuICAgICAgICAgICAgeyBcIm51bWJlclwiOiAxZS0xMiwgXCJzdWZmaXhcIjogdGhpcy5fdChzbnMgKyBcIjEyXCIpIH0sXHJcbiAgICAgICAgICAgIHsgXCJudW1iZXJcIjogMWUtOSwgXCJzdWZmaXhcIjogdGhpcy5fdChzbnMgKyBcIjlcIikgfSxcclxuICAgICAgICAgICAgeyBcIm51bWJlclwiOiAxZS02LCBcInN1ZmZpeFwiOiB0aGlzLl90KHNucyArIFwiNlwiKSB9LFxyXG4gICAgICAgICAgICB7IFwibnVtYmVyXCI6IDFlLTMsIFwic3VmZml4XCI6IHRoaXMuX3Qoc25zICsgXCIzXCIpIH1cclxuICAgICAgICBdKTtcclxuICAgICAgICB0aGlzLl9zZXREZWZhdWx0KFwiYnl0ZVByZWZpeGVzXCIsIFtcclxuICAgICAgICAgICAgeyBcIm51bWJlclwiOiAxLCBzdWZmaXg6IHRoaXMuX3QoYnMgKyBcIkJcIikgfSxcclxuICAgICAgICAgICAgeyBcIm51bWJlclwiOiAxMDI0LCBzdWZmaXg6IHRoaXMuX3QoYnMgKyBcIktCXCIpIH0sXHJcbiAgICAgICAgICAgIHsgXCJudW1iZXJcIjogMTA0ODU3Niwgc3VmZml4OiB0aGlzLl90KGJzICsgXCJNQlwiKSB9LFxyXG4gICAgICAgICAgICB7IFwibnVtYmVyXCI6IDEwNzM3NDE4MjQsIHN1ZmZpeDogdGhpcy5fdChicyArIFwiR0JcIikgfSxcclxuICAgICAgICAgICAgeyBcIm51bWJlclwiOiAxMDk5NTExNjI3Nzc2LCBzdWZmaXg6IHRoaXMuX3QoYnMgKyBcIlRCXCIpIH0sXHJcbiAgICAgICAgICAgIHsgXCJudW1iZXJcIjogMTEyNTg5OTkwNjg0MjYyNCwgc3VmZml4OiB0aGlzLl90KGJzICsgXCJQQlwiKSB9XHJcbiAgICAgICAgXSk7XHJcbiAgICAgICAgc3VwZXIuX3NldERlZmF1bHRzKCk7XHJcbiAgICB9XHJcbiAgICBfYmVmb3JlQ2hhbmdlZCgpIHtcclxuICAgICAgICBzdXBlci5fYmVmb3JlQ2hhbmdlZCgpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBGb3JtYXRzIHRoZSBudW1iZXIgYWNjb3JkaW5nIHRvIHNwZWNpZmljIGZvcm1hdC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gdmFsdWUgICBWYWx1ZSB0byBmb3JtYXRcclxuICAgICAqIEBwYXJhbSBmb3JtYXQgIEZvcm1hdCB0byBhcHBseVxyXG4gICAgICogQHJldHVybiBGb3JtYXR0ZWQgbnVtYmVyXHJcbiAgICAgKi9cclxuICAgIGZvcm1hdCh2YWx1ZSwgZm9ybWF0LCBwcmVjaXNpb24pIHtcclxuICAgICAgICAvLyBubyBmb3JtYXQgcGFzc2VkIGluIG9yIFwiTnVtYmVyXCJcclxuICAgICAgICBpZiAoZm9ybWF0ID09IG51bGwgfHwgKCR0eXBlLmlzU3RyaW5nKGZvcm1hdCkgJiYgZm9ybWF0LnRvTG93ZXJDYXNlKCkgPT09IFwibnVtYmVyXCIpKSB7XHJcbiAgICAgICAgICAgIGZvcm1hdCA9IHRoaXMuZ2V0KFwibnVtYmVyRm9ybWF0XCIsIFwiXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBJbml0IHJldHVybiB2YWx1ZVxyXG4gICAgICAgIGxldCBmb3JtYXR0ZWQ7XHJcbiAgICAgICAgLy8gQ2FzdCB0byBudW1iZXIganVzdCBpbiBjYXNlXHJcbiAgICAgICAgLy8gVE9ETzogbWF5YmUgdXNlIGJldHRlciBjYXN0aW5nXHJcbiAgICAgICAgbGV0IHNvdXJjZSA9IE51bWJlcih2YWx1ZSk7XHJcbiAgICAgICAgLy8gSXMgaXQgYSBidWlsdC1pbiBmb3JtYXQgb3IgSW50bC5OdW1iZXJGb3JtYXRPcHRpb25zXHJcbiAgICAgICAgaWYgKCR0eXBlLmlzT2JqZWN0KGZvcm1hdCkpIHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmdldChcImludGxMb2NhbGVzXCIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBJbnRsLk51bWJlckZvcm1hdCh0aGlzLmdldChcImludGxMb2NhbGVzXCIpLCBmb3JtYXQpLmZvcm1hdChzb3VyY2UpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBJbnRsLk51bWJlckZvcm1hdCh1bmRlZmluZWQsIGZvcm1hdCkuZm9ybWF0KHNvdXJjZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBcIkludmFsaWRcIjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gQ2xlYW4gZm9ybWF0XHJcbiAgICAgICAgICAgIGZvcm1hdCA9ICR1dGlscy5jbGVhbkZvcm1hdChmb3JtYXQpO1xyXG4gICAgICAgICAgICAvLyBHZXQgZm9ybWF0IGluZm8gKGl0IHdpbGwgYWxzbyBkZWFsIHdpdGggcGFyc2VyIGNhY2hpbmcpXHJcbiAgICAgICAgICAgIGxldCBpbmZvID0gdGhpcy5wYXJzZUZvcm1hdChmb3JtYXQsIHRoaXMuX3Jvb3QubGFuZ3VhZ2UpO1xyXG4gICAgICAgICAgICAvLyBmb3JtYXQgYW5kIHJlcGxhY2UgdGhlIG51bWJlclxyXG4gICAgICAgICAgICBsZXQgZGV0YWlscztcclxuICAgICAgICAgICAgaWYgKHNvdXJjZSA+IHRoaXMuZ2V0KFwibmVnYXRpdmVCYXNlXCIpKSB7XHJcbiAgICAgICAgICAgICAgICBkZXRhaWxzID0gaW5mby5wb3NpdGl2ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChzb3VyY2UgPCB0aGlzLmdldChcIm5lZ2F0aXZlQmFzZVwiKSkge1xyXG4gICAgICAgICAgICAgICAgZGV0YWlscyA9IGluZm8ubmVnYXRpdmU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBkZXRhaWxzID0gaW5mby56ZXJvO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIEFkanVzdCBwcmVjaXNpb25cclxuICAgICAgICAgICAgaWYgKHByZWNpc2lvbiAhPSBudWxsICYmICFkZXRhaWxzLm1vZCkge1xyXG4gICAgICAgICAgICAgICAgZGV0YWlscyA9ICRvYmplY3QuY29weShkZXRhaWxzKTtcclxuICAgICAgICAgICAgICAgIGRldGFpbHMuZGVjaW1hbHMuYWN0aXZlID0gc291cmNlID09IDAgPyAwIDogcHJlY2lzaW9uO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIEZvcm1hdFxyXG4gICAgICAgICAgICBmb3JtYXR0ZWQgPSBkZXRhaWxzLnRlbXBsYXRlLnNwbGl0KCR0eXBlLlBMQUNFSE9MREVSKS5qb2luKHRoaXMuYXBwbHlGb3JtYXQoc291cmNlLCBkZXRhaWxzKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmdldChcImZvcmNlTFRSXCIpID09PSB0cnVlKSB7XHJcbiAgICAgICAgICAgIGZvcm1hdHRlZCA9IFwi4oCOXCIgKyBmb3JtYXR0ZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmb3JtYXR0ZWQ7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFBhcnNlcyBzdXBwbGllZCBmb3JtYXQgaW50byBzdHJ1Y3R1cmVkIG9iamVjdCB3aGljaCBjYW4gYmUgdXNlZCB0byBmb3JtYXRcclxuICAgICAqIHRoZSBudW1iZXIuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGZvcm1hdCBGb3JtYXQgc3RyaW5nLCBpLmUuIFwiIywjIyMuMDBcIlxyXG4gICAgICogQHBhcmFtIGxhbmd1YWdlIExhbmd1YWdlXHJcbiAgICAgKiBAaWdub3JlXHJcbiAgICAgKi9cclxuICAgIHBhcnNlRm9ybWF0KGZvcm1hdCwgbGFuZ3VhZ2UpIHtcclxuICAgICAgICAvLyBDaGVjayBjYWNoZVxyXG4gICAgICAgIC8vIFRPRE9cclxuICAgICAgICAvLyBsZXQgY2FjaGVkID0gdGhpcy5nZXRDYWNoZShmb3JtYXQpO1xyXG4gICAgICAgIC8vIGlmIChjYWNoZWQgIT0gbnVsbCkge1xyXG4gICAgICAgIC8vIFx0cmV0dXJuIGNhY2hlZDtcclxuICAgICAgICAvLyB9XHJcbiAgICAgICAgY29uc3QgdGhvdXNhbmRTZXBhcmF0b3IgPSBsYW5ndWFnZS50cmFuc2xhdGVFbXB0eShcIl90aG91c2FuZFNlcGFyYXRvclwiKTtcclxuICAgICAgICBjb25zdCBkZWNpbWFsU2VwYXJhdG9yID0gbGFuZ3VhZ2UudHJhbnNsYXRlRW1wdHkoXCJfZGVjaW1hbFNlcGFyYXRvclwiKTtcclxuICAgICAgICAvLyBpbml0IGZvcm1hdCBwYXJzZSBpbmZvIGhvbGRlclxyXG4gICAgICAgIGxldCBpbmZvID0ge1xyXG4gICAgICAgICAgICBcInBvc2l0aXZlXCI6IHtcclxuICAgICAgICAgICAgICAgIFwidGhvdXNhbmRzXCI6IHtcclxuICAgICAgICAgICAgICAgICAgICBcImFjdGl2ZVwiOiAtMSxcclxuICAgICAgICAgICAgICAgICAgICBcInBhc3NpdmVcIjogLTEsXHJcbiAgICAgICAgICAgICAgICAgICAgXCJpbnRlcnZhbFwiOiAtMSxcclxuICAgICAgICAgICAgICAgICAgICBcInNlcGFyYXRvclwiOiB0aG91c2FuZFNlcGFyYXRvclxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIFwiZGVjaW1hbHNcIjoge1xyXG4gICAgICAgICAgICAgICAgICAgIFwiYWN0aXZlXCI6IC0xLFxyXG4gICAgICAgICAgICAgICAgICAgIFwicGFzc2l2ZVwiOiAtMSxcclxuICAgICAgICAgICAgICAgICAgICBcInNlcGFyYXRvclwiOiBkZWNpbWFsU2VwYXJhdG9yXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgXCJ0ZW1wbGF0ZVwiOiBcIlwiLFxyXG4gICAgICAgICAgICAgICAgXCJzb3VyY2VcIjogXCJcIixcclxuICAgICAgICAgICAgICAgIFwicGFyc2VkXCI6IGZhbHNlXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIFwibmVnYXRpdmVcIjoge1xyXG4gICAgICAgICAgICAgICAgXCJ0aG91c2FuZHNcIjoge1xyXG4gICAgICAgICAgICAgICAgICAgIFwiYWN0aXZlXCI6IC0xLFxyXG4gICAgICAgICAgICAgICAgICAgIFwicGFzc2l2ZVwiOiAtMSxcclxuICAgICAgICAgICAgICAgICAgICBcImludGVydmFsXCI6IC0xLFxyXG4gICAgICAgICAgICAgICAgICAgIFwic2VwYXJhdG9yXCI6IHRob3VzYW5kU2VwYXJhdG9yXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgXCJkZWNpbWFsc1wiOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgXCJhY3RpdmVcIjogLTEsXHJcbiAgICAgICAgICAgICAgICAgICAgXCJwYXNzaXZlXCI6IC0xLFxyXG4gICAgICAgICAgICAgICAgICAgIFwic2VwYXJhdG9yXCI6IGRlY2ltYWxTZXBhcmF0b3JcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBcInRlbXBsYXRlXCI6IFwiXCIsXHJcbiAgICAgICAgICAgICAgICBcInNvdXJjZVwiOiBcIlwiLFxyXG4gICAgICAgICAgICAgICAgXCJwYXJzZWRcIjogZmFsc2VcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgXCJ6ZXJvXCI6IHtcclxuICAgICAgICAgICAgICAgIFwidGhvdXNhbmRzXCI6IHtcclxuICAgICAgICAgICAgICAgICAgICBcImFjdGl2ZVwiOiAtMSxcclxuICAgICAgICAgICAgICAgICAgICBcInBhc3NpdmVcIjogLTEsXHJcbiAgICAgICAgICAgICAgICAgICAgXCJpbnRlcnZhbFwiOiAtMSxcclxuICAgICAgICAgICAgICAgICAgICBcInNlcGFyYXRvclwiOiB0aG91c2FuZFNlcGFyYXRvclxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIFwiZGVjaW1hbHNcIjoge1xyXG4gICAgICAgICAgICAgICAgICAgIFwiYWN0aXZlXCI6IC0xLFxyXG4gICAgICAgICAgICAgICAgICAgIFwicGFzc2l2ZVwiOiAtMSxcclxuICAgICAgICAgICAgICAgICAgICBcInNlcGFyYXRvclwiOiBkZWNpbWFsU2VwYXJhdG9yXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgXCJ0ZW1wbGF0ZVwiOiBcIlwiLFxyXG4gICAgICAgICAgICAgICAgXCJzb3VyY2VcIjogXCJcIixcclxuICAgICAgICAgICAgICAgIFwicGFyc2VkXCI6IGZhbHNlXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8vIEVzY2FwZSBkb3VibGUgdmVydGljYWwgYmFycyAodGhhdCBtZWFuIGRpc3BsYXkgb25lIHZlcnRpY2FsIGJhcilcclxuICAgICAgICBmb3JtYXQgPSBmb3JtYXQucmVwbGFjZShcInx8XCIsICR0eXBlLlBMQUNFSE9MREVSMik7XHJcbiAgICAgICAgLy8gU3BsaXQgaXQgdXAgYW5kIGRlYWwgd2l0aCBkaWZmZXJlbnQgZm9ybWF0c1xyXG4gICAgICAgIGxldCBwYXJ0cyA9IGZvcm1hdC5zcGxpdChcInxcIik7XHJcbiAgICAgICAgaW5mby5wb3NpdGl2ZS5zb3VyY2UgPSBwYXJ0c1swXTtcclxuICAgICAgICBpZiAodHlwZW9mIHBhcnRzWzJdID09PSBcInVuZGVmaW5lZFwiKSB7XHJcbiAgICAgICAgICAgIGluZm8uemVybyA9IGluZm8ucG9zaXRpdmU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpbmZvLnplcm8uc291cmNlID0gcGFydHNbMl07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0eXBlb2YgcGFydHNbMV0gPT09IFwidW5kZWZpbmVkXCIpIHtcclxuICAgICAgICAgICAgaW5mby5uZWdhdGl2ZSA9IGluZm8ucG9zaXRpdmU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpbmZvLm5lZ2F0aXZlLnNvdXJjZSA9IHBhcnRzWzFdO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBQYXJzZSBlYWNoXHJcbiAgICAgICAgJG9iamVjdC5lYWNoKGluZm8sIChfcGFydCwgaXRlbSkgPT4ge1xyXG4gICAgICAgICAgICAvLyBBbHJlYWR5IHBhcnNlZFxyXG4gICAgICAgICAgICBpZiAoaXRlbS5wYXJzZWQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBDaGVjayBjYWNoZWRcclxuICAgICAgICAgICAgLy8gVE9ET1xyXG4gICAgICAgICAgICAvLyBpZiAodHlwZW9mIHRoaXMuZ2V0Q2FjaGUoaXRlbS5zb3VyY2UpICE9PSBcInVuZGVmaW5lZFwiKSB7XHJcbiAgICAgICAgICAgIC8vIFx0aW5mb1twYXJ0XSA9IHRoaXMuZ2V0Q2FjaGUoaXRlbS5zb3VyY2UpO1xyXG4gICAgICAgICAgICAvLyBcdHJldHVybjtcclxuICAgICAgICAgICAgLy8gfVxyXG4gICAgICAgICAgICAvLyBCZWdpbiBwYXJzaW5nXHJcbiAgICAgICAgICAgIGxldCBwYXJ0Rm9ybWF0ID0gaXRlbS5zb3VyY2U7XHJcbiAgICAgICAgICAgIC8vIEp1c3QgXCJOdW1iZXJcIj9cclxuICAgICAgICAgICAgaWYgKHBhcnRGb3JtYXQudG9Mb3dlckNhc2UoKSA9PT0gXCJudW1iZXJcIikge1xyXG4gICAgICAgICAgICAgICAgcGFydEZvcm1hdCA9IHRoaXMuZ2V0KFwibnVtYmVyRm9ybWF0XCIsIFwiIywjIyMuIyMjIyNcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gTGV0IFRleHRGb3JtYXR0ZXIgc3BsaXQgaW50byBjaHVua3NcclxuICAgICAgICAgICAgbGV0IGNodW5rcyA9IFRleHRGb3JtYXR0ZXIuY2h1bmsocGFydEZvcm1hdCwgdHJ1ZSk7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2h1bmtzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgY2h1bmsgPSBjaHVua3NbaV07XHJcbiAgICAgICAgICAgICAgICAvLyByZXBsYWNlIGJhY2sgZG91YmxlIHZlcnRpY2FsIGJhclxyXG4gICAgICAgICAgICAgICAgY2h1bmsudGV4dCA9IGNodW5rLnRleHQucmVwbGFjZSgkdHlwZS5QTEFDRUhPTERFUjIsIFwifFwiKTtcclxuICAgICAgICAgICAgICAgIGlmIChjaHVuay50eXBlID09PSBcInZhbHVlXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBQYXJzZSBmb3JtYXRcclxuICAgICAgICAgICAgICAgICAgICAvLyBMb29rIGZvciBjb2Rlc1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBtYXRjaGVzID0gY2h1bmsudGV4dC5tYXRjaCgvWyMwLixdK1sgXT9bYWJlc3BBQkVTUCUhXT9bYWJlc3BBQkVTUOKAsCFdPy8pO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaGVzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaGVzID09PSBudWxsIHx8IG1hdGNoZXNbMF0gPT09IFwiXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5vIGNvZGVzIGhlcmUgLSBhc3N1bWUgc3RyaW5nXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBub3RoaW5nIHRvIGRvIGhlcmVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0udGVtcGxhdGUgKz0gY2h1bmsudGV4dDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGxvb2sgZm9yIHRoZSBmb3JtYXQgbW9kaWZpZXJzIGF0IHRoZSBlbmRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBtb2RzID0gbWF0Y2hlc1swXS5tYXRjaCgvW2FiZXNwQUJFU1Al4oCwIV17Mn18W2FiZXNwQUJFU1Al4oCwXXsxfSQvKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtb2RzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5tb2QgPSBtb2RzWzBdLnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5tb2RTcGFjaW5nID0gbWF0Y2hlc1swXS5tYXRjaCgvWyBdezF9W2FiZXNwQUJFU1Al4oCwIV17MX0kLykgPyB0cnVlIDogZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBicmVhayB0aGUgZm9ybWF0IHVwXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgYSA9IG1hdGNoZXNbMF0uc3BsaXQoXCIuXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRGVhbCB3aXRoIHRob3VzYW5kc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFbMF0gPT09IFwiXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBObyBkaXJlY3RpdmVzIGZvciB0aG91c2FuZHNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBMZWF2ZSBkZWZhdWx0IHNldHRpbmdzIChubyBmb3JtYXR0aW5nKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ291bnRzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS50aG91c2FuZHMuYWN0aXZlID0gKGFbMF0ubWF0Y2goLzAvZykgfHwgW10pLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtLnRob3VzYW5kcy5wYXNzaXZlID0gKGFbMF0ubWF0Y2goL1xcIy9nKSB8fCBbXSkubGVuZ3RoICsgaXRlbS50aG91c2FuZHMuYWN0aXZlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNlcGFyYXRvciBpbnRlcnZhbFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBiID0gYVswXS5zcGxpdChcIixcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGIubGVuZ3RoID09PSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5vIHRob3VzYW5kcyBzZXBhcmF0b3JzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIERvIG5vdGhpbmdcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVzZSBsZW5ndGggZm8gdGhlIGxhc3QgY2h1bmsgYXMgdGhvdXNhbmRzIGxlbmd0aFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtLnRob3VzYW5kcy5pbnRlcnZhbCA9IChiLnBvcCgpIHx8IFwiXCIpLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW0udGhvdXNhbmRzLmludGVydmFsID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtLnRob3VzYW5kcy5pbnRlcnZhbCA9IC0xO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRGVhbCB3aXRoIGRlY2ltYWxzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIChhWzFdKSA9PT0gXCJ1bmRlZmluZWRcIikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5vIGRpcmVjdGl2ZXMgZm9yIGRlY2ltYWxzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTGVhdmUgYXQgZGVmYXVsdHMgKG5vIGZvcm1hdHRpbmcpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDb3VudHNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtLmRlY2ltYWxzLmFjdGl2ZSA9IChhWzFdLm1hdGNoKC8wL2cpIHx8IFtdKS5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5kZWNpbWFscy5wYXNzaXZlID0gKGFbMV0ubWF0Y2goL1xcIy9nKSB8fCBbXSkubGVuZ3RoICsgaXRlbS5kZWNpbWFscy5hY3RpdmU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBZGQgc3BlY2lhbCBjb2RlIHRvIHRlbXBsYXRlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtLnRlbXBsYXRlICs9IGNodW5rLnRleHQuc3BsaXQobWF0Y2hlc1swXSkuam9pbigkdHlwZS5QTEFDRUhPTERFUik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBRdW90ZWQgc3RyaW5nIC0gdGFrZSBpdCBhcyBpdCBpc1xyXG4gICAgICAgICAgICAgICAgICAgIGl0ZW0udGVtcGxhdGUgKz0gY2h1bmsudGV4dDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBBcHBseSBzdHlsZSBmb3JtYXR0aW5nXHJcbiAgICAgICAgICAgIC8vaXRlbS50ZW1wbGF0ZSA9IGdldFRleHRGb3JtYXR0ZXIoKS5mb3JtYXQoaXRlbS50ZW1wbGF0ZSwgdGhpcy5vdXRwdXRGb3JtYXQpO1xyXG4gICAgICAgICAgICAvLyBTYXZlIGNhY2hlXHJcbiAgICAgICAgICAgIC8vIFRPRE9cclxuICAgICAgICAgICAgLy90aGlzLnNldENhY2hlKGl0ZW0uc291cmNlLCBpdGVtKTtcclxuICAgICAgICAgICAgLy8gTWFyayB0aGlzIGFzIHBhcnNlZFxyXG4gICAgICAgICAgICBpdGVtLnBhcnNlZCA9IHRydWU7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLy8gU2F2ZSBjYWNoZSAodGhlIHdob2xlIHRoaW5nKVxyXG4gICAgICAgIC8vIFRPRE9cclxuICAgICAgICAvL3RoaXMuc2V0Q2FjaGUoZm9ybWF0LCBpbmZvKTtcclxuICAgICAgICByZXR1cm4gaW5mbztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQXBwbGllcyBwYXJzZWQgZm9ybWF0IHRvIGEgbnVtZXJpYyB2YWx1ZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gdmFsdWUgICAgVmFsdWVcclxuICAgICAqIEBwYXJhbSBkZXRhaWxzICBQYXJzZWQgZm9ybWF0IGFzIHJldHVybmVkIGJ5IHBhcnNlRm9ybWF0KClcclxuICAgICAqIEByZXR1cm4gRm9ybWF0dGVkIG51bWJlclxyXG4gICAgICogQGlnbm9yZVxyXG4gICAgICovXHJcbiAgICBhcHBseUZvcm1hdCh2YWx1ZSwgZGV0YWlscykge1xyXG4gICAgICAgIC8vIFVzZSBhYnNvbHV0ZSB2YWx1ZXNcclxuICAgICAgICBsZXQgbmVnYXRpdmUgPSB2YWx1ZSA8IDA7XHJcbiAgICAgICAgdmFsdWUgPSBNYXRoLmFicyh2YWx1ZSk7XHJcbiAgICAgICAgLy8gUmVjYWxjdWxhdGUgYWNjb3JkaW5nIHRvIG1vZGlmaWVyXHJcbiAgICAgICAgbGV0IHByZWZpeCA9IFwiXCIsIHN1ZmZpeCA9IFwiXCI7XHJcbiAgICAgICAgbGV0IG1vZHMgPSBkZXRhaWxzLm1vZCA/IGRldGFpbHMubW9kLnNwbGl0KFwiXCIpIDogW107XHJcbiAgICAgICAgaWYgKG1vZHMuaW5kZXhPZihcImJcIikgIT09IC0xKSB7XHJcbiAgICAgICAgICAgIGxldCBhID0gdGhpcy5hcHBseVByZWZpeCh2YWx1ZSwgdGhpcy5nZXQoXCJieXRlUHJlZml4ZXNcIiksIG1vZHMuaW5kZXhPZihcIiFcIikgIT09IC0xKTtcclxuICAgICAgICAgICAgdmFsdWUgPSBhWzBdO1xyXG4gICAgICAgICAgICBwcmVmaXggPSBhWzFdO1xyXG4gICAgICAgICAgICBzdWZmaXggPSBhWzJdO1xyXG4gICAgICAgICAgICBpZiAoZGV0YWlscy5tb2RTcGFjaW5nKSB7XHJcbiAgICAgICAgICAgICAgICBzdWZmaXggPSBcIiBcIiArIHN1ZmZpeDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChtb2RzLmluZGV4T2YoXCJhXCIpICE9PSAtMSkge1xyXG4gICAgICAgICAgICBsZXQgYSA9IHRoaXMuYXBwbHlQcmVmaXgodmFsdWUsIHZhbHVlIDwgdGhpcy5nZXQoXCJzbWFsbE51bWJlclRocmVzaG9sZFwiKSA/IHRoaXMuZ2V0KFwic21hbGxOdW1iZXJQcmVmaXhlc1wiKSA6IHRoaXMuZ2V0KFwiYmlnTnVtYmVyUHJlZml4ZXNcIiksIG1vZHMuaW5kZXhPZihcIiFcIikgIT09IC0xKTtcclxuICAgICAgICAgICAgdmFsdWUgPSBhWzBdO1xyXG4gICAgICAgICAgICBwcmVmaXggPSBhWzFdO1xyXG4gICAgICAgICAgICBzdWZmaXggPSBhWzJdO1xyXG4gICAgICAgICAgICBpZiAoZGV0YWlscy5tb2RTcGFjaW5nKSB7XHJcbiAgICAgICAgICAgICAgICBzdWZmaXggPSBcIiBcIiArIHN1ZmZpeDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChtb2RzLmluZGV4T2YoXCJwXCIpICE9PSAtMSkge1xyXG4gICAgICAgICAgICBsZXQgb2wgPSBNYXRoLm1pbih2YWx1ZS50b1N0cmluZygpLmxlbmd0aCArIDIsIDIxKTtcclxuICAgICAgICAgICAgLy92YWx1ZSAqPSAxMDA7XHJcbiAgICAgICAgICAgIHZhbHVlID0gcGFyc2VGbG9hdCh2YWx1ZS50b1ByZWNpc2lvbihvbCkpO1xyXG4gICAgICAgICAgICBwcmVmaXggPSB0aGlzLl9yb290Lmxhbmd1YWdlLnRyYW5zbGF0ZShcIl9wZXJjZW50UHJlZml4XCIpO1xyXG4gICAgICAgICAgICBzdWZmaXggPSB0aGlzLl9yb290Lmxhbmd1YWdlLnRyYW5zbGF0ZShcIl9wZXJjZW50U3VmZml4XCIpO1xyXG4gICAgICAgICAgICBpZiAocHJlZml4ID09IFwiXCIgJiYgc3VmZml4ID09IFwiXCIpIHtcclxuICAgICAgICAgICAgICAgIHN1ZmZpeCA9IFwiJVwiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKG1vZHMuaW5kZXhPZihcIiVcIikgIT09IC0xKSB7XHJcbiAgICAgICAgICAgIGxldCBvbCA9IE1hdGgubWluKHZhbHVlLnRvU3RyaW5nKCkubGVuZ3RoICsgMiwgMjEpO1xyXG4gICAgICAgICAgICB2YWx1ZSAqPSAxMDA7XHJcbiAgICAgICAgICAgIHZhbHVlID0gcGFyc2VGbG9hdCh2YWx1ZS50b1ByZWNpc2lvbihvbCkpO1xyXG4gICAgICAgICAgICBzdWZmaXggPSBcIiVcIjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAobW9kcy5pbmRleE9mKFwi4oCwXCIpICE9PSAtMSkge1xyXG4gICAgICAgICAgICBsZXQgb2wgPSBNYXRoLm1pbih2YWx1ZS50b1N0cmluZygpLmxlbmd0aCArIDMsIDIxKTtcclxuICAgICAgICAgICAgdmFsdWUgKj0gMTAwMDtcclxuICAgICAgICAgICAgdmFsdWUgPSBwYXJzZUZsb2F0KHZhbHVlLnRvUHJlY2lzaW9uKG9sKSk7XHJcbiAgICAgICAgICAgIHN1ZmZpeCA9IFwi4oCwXCI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFJvdW5kIHRvIHBhc3NpdmVcclxuICAgICAgICBpZiAobW9kcy5pbmRleE9mKFwiZVwiKSAhPT0gLTEpIHtcclxuICAgICAgICAgICAgLy8gY29udmVydCB0aGUgdmFsdWUgdG8gZXhwb25lbnRpYWxcclxuICAgICAgICAgICAgbGV0IGV4cDtcclxuICAgICAgICAgICAgaWYgKGRldGFpbHMuZGVjaW1hbHMucGFzc2l2ZSA+PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBleHAgPSB2YWx1ZS50b0V4cG9uZW50aWFsKGRldGFpbHMuZGVjaW1hbHMucGFzc2l2ZSkuc3BsaXQoXCJlXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZXhwID0gdmFsdWUudG9FeHBvbmVudGlhbCgpLnNwbGl0KFwiZVwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YWx1ZSA9IE51bWJlcihleHBbMF0pO1xyXG4gICAgICAgICAgICBzdWZmaXggPSBcImVcIiArIGV4cFsxXTtcclxuICAgICAgICAgICAgaWYgKGRldGFpbHMubW9kU3BhY2luZykge1xyXG4gICAgICAgICAgICAgICAgc3VmZml4ID0gXCIgXCIgKyBzdWZmaXg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoZGV0YWlscy5kZWNpbWFscy5wYXNzaXZlID09PSAwKSB7XHJcbiAgICAgICAgICAgIHZhbHVlID0gTWF0aC5yb3VuZCh2YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGRldGFpbHMuZGVjaW1hbHMucGFzc2l2ZSA+IDApIHtcclxuICAgICAgICAgICAgbGV0IGQgPSBNYXRoLnBvdygxMCwgZGV0YWlscy5kZWNpbWFscy5wYXNzaXZlKTtcclxuICAgICAgICAgICAgdmFsdWUgPSBNYXRoLnJvdW5kKHZhbHVlICogZCkgLyBkO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBJbml0IHJldHVybiB2YWx1ZVxyXG4gICAgICAgIGxldCByZXMgPSBcIlwiO1xyXG4gICAgICAgIC8vIENhbGMgaW50ZWdlciBhbmQgZGVjaW1hbCBwYXJ0c1xyXG4gICAgICAgIGxldCBhID0gJHR5cGUubnVtYmVyVG9TdHJpbmcodmFsdWUpLnNwbGl0KFwiLlwiKTtcclxuICAgICAgICAvLyBGb3JtYXQgaW50ZWdlcnNcclxuICAgICAgICBsZXQgaW50cyA9IGFbMF07XHJcbiAgICAgICAgLy8gUGFkIGludGVnZXJzIHRvIGFjdGl2ZSBsZW5ndGhcclxuICAgICAgICBpZiAoaW50cy5sZW5ndGggPCBkZXRhaWxzLnRob3VzYW5kcy5hY3RpdmUpIHtcclxuICAgICAgICAgICAgaW50cyA9IEFycmF5KGRldGFpbHMudGhvdXNhbmRzLmFjdGl2ZSAtIGludHMubGVuZ3RoICsgMSkuam9pbihcIjBcIikgKyBpbnRzO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBJbnNlcnQgdGhvdXNhbmRzIHNlcGFyYXRvcnNcclxuICAgICAgICBpZiAoZGV0YWlscy50aG91c2FuZHMuaW50ZXJ2YWwgPiAwKSB7XHJcbiAgICAgICAgICAgIGxldCBpcCA9IFtdO1xyXG4gICAgICAgICAgICBsZXQgaW50c3IgPSBpbnRzLnNwbGl0KFwiXCIpLnJldmVyc2UoKS5qb2luKFwiXCIpO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gaW50cy5sZW5ndGg7IGkgPD0gbGVuOyBpICs9IGRldGFpbHMudGhvdXNhbmRzLmludGVydmFsKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgYyA9IGludHNyLnN1YnN0cihpLCBkZXRhaWxzLnRob3VzYW5kcy5pbnRlcnZhbCkuc3BsaXQoXCJcIikucmV2ZXJzZSgpLmpvaW4oXCJcIik7XHJcbiAgICAgICAgICAgICAgICBpZiAoYyAhPT0gXCJcIikge1xyXG4gICAgICAgICAgICAgICAgICAgIGlwLnVuc2hpZnQoYyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaW50cyA9IGlwLmpvaW4oZGV0YWlscy50aG91c2FuZHMuc2VwYXJhdG9yKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gQWRkIGludGVnZXJzXHJcbiAgICAgICAgcmVzICs9IGludHM7XHJcbiAgICAgICAgLy8gQWRkIGRlY2ltYWxzXHJcbiAgICAgICAgaWYgKGEubGVuZ3RoID09PSAxKSB7XHJcbiAgICAgICAgICAgIGEucHVzaChcIlwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IGRlY3MgPSBhWzFdO1xyXG4gICAgICAgIC8vIEZpbGwgemVyb3M/XHJcbiAgICAgICAgaWYgKGRlY3MubGVuZ3RoIDwgZGV0YWlscy5kZWNpbWFscy5hY3RpdmUpIHtcclxuICAgICAgICAgICAgZGVjcyArPSBBcnJheShkZXRhaWxzLmRlY2ltYWxzLmFjdGl2ZSAtIGRlY3MubGVuZ3RoICsgMSkuam9pbihcIjBcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChkZWNzICE9PSBcIlwiKSB7XHJcbiAgICAgICAgICAgIHJlcyArPSBkZXRhaWxzLmRlY2ltYWxzLnNlcGFyYXRvciArIGRlY3M7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIENhbid0IGhhdmUgZW1wdHkgcmV0dXJuIHZhbHVlXHJcbiAgICAgICAgaWYgKHJlcyA9PT0gXCJcIikge1xyXG4gICAgICAgICAgICByZXMgPSBcIjBcIjtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gQWRkIG1pbnVzIHNpZ24gYmFja1xyXG4gICAgICAgIGlmICh2YWx1ZSAhPT0gMCAmJiBuZWdhdGl2ZSAmJiAobW9kcy5pbmRleE9mKFwic1wiKSA9PT0gLTEpKSB7XHJcbiAgICAgICAgICAgIHJlcyA9IFwiLVwiICsgcmVzO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBBZGQgc3VmZml4ZXMvcHJlZml4ZXNcclxuICAgICAgICBpZiAocHJlZml4KSB7XHJcbiAgICAgICAgICAgIHJlcyA9IHByZWZpeCArIHJlcztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHN1ZmZpeCkge1xyXG4gICAgICAgICAgICByZXMgKz0gc3VmZml4O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgfVxyXG4gICAgYXBwbHlQcmVmaXgodmFsdWUsIHByZWZpeGVzLCBmb3JjZSA9IGZhbHNlKSB7XHJcbiAgICAgICAgbGV0IG5ld3ZhbHVlID0gdmFsdWU7XHJcbiAgICAgICAgbGV0IHByZWZpeCA9IFwiXCI7XHJcbiAgICAgICAgbGV0IHN1ZmZpeCA9IFwiXCI7XHJcbiAgICAgICAgbGV0IGFwcGxpZWQgPSBmYWxzZTtcclxuICAgICAgICBsZXQgayA9IDE7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHByZWZpeGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChwcmVmaXhlc1tpXS5udW1iZXIgPD0gdmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIGlmIChwcmVmaXhlc1tpXS5udW1iZXIgPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBuZXd2YWx1ZSA9IDA7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBuZXd2YWx1ZSA9IHZhbHVlIC8gcHJlZml4ZXNbaV0ubnVtYmVyO1xyXG4gICAgICAgICAgICAgICAgICAgIGsgPSBwcmVmaXhlc1tpXS5udW1iZXI7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBwcmVmaXggPSBwcmVmaXhlc1tpXS5wcmVmaXg7XHJcbiAgICAgICAgICAgICAgICBzdWZmaXggPSBwcmVmaXhlc1tpXS5zdWZmaXg7XHJcbiAgICAgICAgICAgICAgICBhcHBsaWVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIWFwcGxpZWQgJiYgZm9yY2UgJiYgcHJlZml4ZXMubGVuZ3RoICYmIHZhbHVlICE9IDApIHtcclxuICAgICAgICAgICAgLy8gUHJlZml4IHdhcyBub3QgYXBwbGllZC4gVXNlIHRoZSBmaXJzdCBwcmVmaXguXHJcbiAgICAgICAgICAgIG5ld3ZhbHVlID0gdmFsdWUgLyBwcmVmaXhlc1swXS5udW1iZXI7XHJcbiAgICAgICAgICAgIHByZWZpeCA9IHByZWZpeGVzWzBdLnByZWZpeDtcclxuICAgICAgICAgICAgc3VmZml4ID0gcHJlZml4ZXNbMF0uc3VmZml4O1xyXG4gICAgICAgICAgICBhcHBsaWVkID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGFwcGxpZWQpIHtcclxuICAgICAgICAgICAgbmV3dmFsdWUgPSBwYXJzZUZsb2F0KG5ld3ZhbHVlLnRvUHJlY2lzaW9uKE1hdGgubWluKGsudG9TdHJpbmcoKS5sZW5ndGggKyBNYXRoLmZsb29yKG5ld3ZhbHVlKS50b1N0cmluZygpLnJlcGxhY2UoL1teMC05XSovZywgXCJcIikubGVuZ3RoLCAyMSkpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFtuZXd2YWx1ZSwgcHJlZml4LCBzdWZmaXhdO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXBsYWNlcyBicmFja2V0cyB3aXRoIHRlbXBvcmFyeSBwbGFjZWhvbGRlcnMuXHJcbiAgICAgKlxyXG4gICAgICogQGlnbm9yZSBFeGNsdWRlIGZyb20gZG9jc1xyXG4gICAgICogQHBhcmFtIHRleHQgIElucHV0IHRleHRcclxuICAgICAqIEByZXR1cm4gRXNjYXBlZCB0ZXh0XHJcbiAgICAgKi9cclxuICAgIGVzY2FwZSh0ZXh0KSB7XHJcbiAgICAgICAgcmV0dXJuIHRleHQucmVwbGFjZShcInx8XCIsICR0eXBlLlBMQUNFSE9MREVSMik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJlcGxhY2VzIHBsYWNlaG9sZGVycyBiYWNrIHRvIGJyYWNrZXRzLlxyXG4gICAgICpcclxuICAgICAqIEBpZ25vcmUgRXhjbHVkZSBmcm9tIGRvY3NcclxuICAgICAqIEBwYXJhbSB0ZXh0ICBFc2NhcGVkIHRleHRcclxuICAgICAqIEByZXR1cm4gVW5lc2NhcGVkIHRleHRcclxuICAgICAqL1xyXG4gICAgdW5lc2NhcGUodGV4dCkge1xyXG4gICAgICAgIHJldHVybiB0ZXh0LnJlcGxhY2UoJHR5cGUuUExBQ0VIT0xERVIyLCBcInxcIik7XHJcbiAgICB9XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TnVtYmVyRm9ybWF0dGVyLmpzLm1hcCIsImltcG9ydCAqIGFzICRhcnJheSBmcm9tIFwiLi9BcnJheVwiO1xyXG5leHBvcnQgZnVuY3Rpb24ga2V5cyhvYmplY3QpIHtcclxuICAgIHJldHVybiBPYmplY3Qua2V5cyhvYmplY3QpO1xyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm5zIGFuIGFycmF5IG9mIG9iamVjdCdzIHByb3BlcnR5IG5hbWVzIG9yZGVyZWQgdXNpbmcgc3BlY2lmaWMgb3JkZXJpbmdcclxuICogZnVuY3Rpb24uXHJcbiAqXHJcbiAqIEBwYXJhbSBvYmplY3QgIFNvdXJjZSBvYmplY3RcclxuICogQHBhcmFtIG9yZGVyICAgT3JkZXJpbmcgZnVuY3Rpb25cclxuICogQHJldHVybnMgT2JqZWN0IHByb3BlcnR5IG5hbWVzXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24ga2V5c09yZGVyZWQob2JqZWN0LCBvcmRlcikge1xyXG4gICAgcmV0dXJuIGtleXMob2JqZWN0KS5zb3J0KG9yZGVyKTtcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gY29weShvYmplY3QpIHtcclxuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBvYmplY3QpO1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiBlYWNoKG9iamVjdCwgZikge1xyXG4gICAga2V5cyhvYmplY3QpLmZvckVhY2goKGtleSkgPT4ge1xyXG4gICAgICAgIGYoa2V5LCBvYmplY3Rba2V5XSk7XHJcbiAgICB9KTtcclxufVxyXG4vKipcclxuICogSXRlcmF0ZXMgdGhyb3VnaCBhbGwgcHJvcGVydGllcyBvZiB0aGUgb2JqZWN0IGNhbGxpbmcgYGZuYCBmb3IgZWFjaCBvZiB0aGVtLlxyXG4gKlxyXG4gKiBJZiByZXR1cm4gdmFsdWUgb2YgdGhlIGZ1bmN0aW9uIGV2YWx1YXRlcyB0byBgZmFsc2VgIGZ1cnRoZXIgaXRlcmF0aW9uIGlzXHJcbiAqIGNhbmNlbGxlZC5cclxuICpcclxuICogQHBhcmFtIG9iamVjdCAgU291cmNlIG9iamVjdFxyXG4gKiBAcGFyYW0gZm4gICAgICBDYWxsYmFjayBmdW5jdGlvblxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGVhY2hDb250aW51ZShvYmplY3QsIGZuKSB7XHJcbiAgICBmb3IgKGxldCBrZXkgaW4gb2JqZWN0KSB7XHJcbiAgICAgICAgaWYgKGhhc0tleShvYmplY3QsIGtleSkpIHtcclxuICAgICAgICAgICAgaWYgKCFmbihrZXksIG9iamVjdFtrZXldKSkge1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIE9yZGVycyBvYmplY3QgcHJvcGVydGllcyB1c2luZyBjdXN0b20gYG9yZGAgZnVuY3Rpb24gYW5kIGl0ZXJhdGVzIHRocm91Z2hcclxuICogdGhlbSBjYWxsaW5nIGBmbmAgZm9yIGVhY2ggb2YgdGhlbS5cclxuICpcclxuICogQHBhcmFtIG9iamVjdCAgU291cmNlIG9iamVjdFxyXG4gKiBAcGFyYW0gZm4gICAgICBDYWxsYmFjayBmdW5jdGlvblxyXG4gKiBAcGFyYW0gb3JkZXIgICBPcmRlcmluZyBmdW5jdGlvblxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGVhY2hPcmRlcmVkKG9iamVjdCwgZm4sIG9yZCkge1xyXG4gICAgJGFycmF5LmVhY2goa2V5c09yZGVyZWQob2JqZWN0LCBvcmQpLCAoa2V5KSA9PiB7XHJcbiAgICAgICAgZm4oa2V5LCBvYmplY3Rba2V5XSk7XHJcbiAgICB9KTtcclxufVxyXG4vKipcclxuICogQ2hlY2tzIGlmIGBvYmplY3RgIGhhcyBhIHNwZWNpZmljIGBrZXlgLlxyXG4gKlxyXG4gKiBAcGFyYW0gb2JqZWN0ICBTb3VyY2Ugb2JqZWN0XHJcbiAqIEBwYXJhbSBrZXkgICAgIFByb3BlcnR5IG5hbWVcclxuICogQHJldHVybnMgSGFzIGtleT9cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBoYXNLZXkob2JqZWN0LCBrZXkpIHtcclxuICAgIHJldHVybiB7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KTtcclxufVxyXG4vKipcclxuICogQ29waWVzIGFsbCBwcm9wZXJ0aWVzIG9mIG9uZSBvYmplY3QgdG8gdGhlIG90aGVyLCBvbWl0dGluZyB1bmRlZmluZWQsIGJ1dCBvbmx5IGlmIHByb3BlcnR5IGluIHRhcmdldCBvYmplY3QgZG9lc24ndCBoYXZlIGEgdmFsdWUgc2V0LlxyXG4gKlxyXG4gKiBAcGFyYW0gZnJvbU9iamVjdCAgU291cmNlIG9iamVjdFxyXG4gKiBAcGFyYW0gdG9PYmplY3QgICAgVGFyZ2V0IG9iamVjdFxyXG4gKiBAcmV0dXJuIFVwZGF0ZWQgdGFyZ2V0IG9iamVjdFxyXG4gKiBAdG9kbyBNYXliZSBjb25zb2xpZGF0ZSB3aXRoIHV0aWxzLmNvcHk/XHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gc29mdENvcHlQcm9wZXJ0aWVzKHNvdXJjZSwgdGFyZ2V0KSB7XHJcbiAgICBlYWNoKHNvdXJjZSwgKGtleSwgdmFsdWUpID0+IHtcclxuICAgICAgICAvLyBvbmx5IGlmIHZhbHVlIGlzIHNldFxyXG4gICAgICAgIC8vaWYgKCR0eXBlLmhhc1ZhbHVlKHZhbHVlKSAmJiAhKCR0eXBlLmhhc1ZhbHVlKCg8YW55PnRhcmdldClba2V5XSkpKSB7XHJcbiAgICAgICAgaWYgKHZhbHVlICE9IG51bGwgJiYgdGFyZ2V0W2tleV0gPT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0YXJnZXRba2V5XSA9IHZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHRhcmdldDtcclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1PYmplY3QuanMubWFwIiwiLyoqXHJcbiAqIEBpZ25vcmVcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBjb21wYXJlKGxlZnQsIHJpZ2h0KSB7XHJcbiAgICBpZiAobGVmdCA9PT0gcmlnaHQpIHtcclxuICAgICAgICByZXR1cm4gMDtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGxlZnQgPCByaWdodCkge1xyXG4gICAgICAgIHJldHVybiAtMTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiAxO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBAaWdub3JlXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gY29tcGFyZUFycmF5KGxlZnQsIHJpZ2h0LCBmKSB7XHJcbiAgICBjb25zdCBsZWZ0TGVuZ3RoID0gbGVmdC5sZW5ndGg7XHJcbiAgICBjb25zdCByaWdodExlbmd0aCA9IHJpZ2h0Lmxlbmd0aDtcclxuICAgIGNvbnN0IGxlbmd0aCA9IE1hdGgubWluKGxlZnRMZW5ndGgsIHJpZ2h0TGVuZ3RoKTtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcclxuICAgICAgICBjb25zdCBvcmRlciA9IGYobGVmdFtpXSwgcmlnaHRbaV0pO1xyXG4gICAgICAgIGlmIChvcmRlciAhPT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gb3JkZXI7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGNvbXBhcmUobGVmdExlbmd0aCwgcmlnaHRMZW5ndGgpO1xyXG59XHJcbi8qKlxyXG4gKiBAaWdub3JlXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gcmV2ZXJzZShvcmRlcikge1xyXG4gICAgaWYgKG9yZGVyIDwgMCkge1xyXG4gICAgICAgIHJldHVybiAxO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAob3JkZXIgPiAwKSB7XHJcbiAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIDA7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEBpZ25vcmVcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBjb21wYXJlTnVtYmVyKGEsIGIpIHtcclxuICAgIGlmIChhID09PSBiKSB7XHJcbiAgICAgICAgcmV0dXJuIDA7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChhIDwgYikge1xyXG4gICAgICAgIHJldHVybiAtMTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiAxO1xyXG4gICAgfVxyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU9yZGVyLmpzLm1hcCIsIi8qKlxyXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAqIE1BSU4gQ0xBU1NcclxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4gKiBAaGlkZGVuXHJcbiAqL1xyXG4vKipcclxuICogUmVwcmVzZW50cyBhIHJlbGF0aXZlIHZhbHVlIChwZXJjZW50KS5cclxuICpcclxuICogVGhlIFBlcmNlbnQgb2JqZWN0LCBjYW4gYmUgaW5zdGFudGlhdGVkIHVzaW5nIHR3byB3YXlzOlxyXG4gKlxyXG4gKiAqIFZpYSBgbmV3IFBlcmNlbnQoWClgLlxyXG4gKiAqIFZpYSBgYW01LnBlcmNlbnQoWClgLlxyXG4gKlxyXG4gKiBZb3UgY2FuIGFsc28gdXNlIHNob3J0Y3V0IGZ1bmN0aW9ucyBmb3IgYDAlYCwgYDUwJWAsIGFuZCBgMTAwJWA6XHJcbiAqICogYGFtNS5wMGBcclxuICogKiBgYW01LnA1MGBcclxuICogKiBgYW01LnAxMDBgXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgUGVyY2VudCB7XHJcbiAgICAvKipcclxuICAgICAqIENvbnN0cnVjdG9yLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBwZXJjZW50ICBQZXJjZW50IHZhbHVlXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKHBlcmNlbnQpIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBWYWx1ZSBpbiBwZXJjZW50LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl92YWx1ZVwiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLl92YWx1ZSA9IHBlcmNlbnQ7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJlbGF0aXZlIHZhbHVlLlxyXG4gICAgICpcclxuICAgICAqIEUuZy4gMTAwJSBpcyAxLCA1MCUgaXMgMC41LCBldGMuXHJcbiAgICAgKlxyXG4gICAgICogVGhpcyBpcyB1c2VmdWwgdG8gYXBwbHkgdHJhbnNmb3JtYXRpb25zIHRvIG90aGVyIHZhbHVlcy4gRS5nLjpcclxuICAgICAqXHJcbiAgICAgKiBgYGBUeXBlU2NyaXB0XHJcbiAgICAgKiBsZXQgdmFsdWUgPSAyNTY7XHJcbiAgICAgKiBsZXQgcGVyY2VudCA9IG5ldyBhbTUucDUwO1xyXG4gICAgICogY29uc29sZS5sb2codmFsdWUgKiBwZXJjZW50LnZhbHVlKTsgLy8gb3V0cHV0cyAxMjhcclxuICAgICAqIGBgYFxyXG4gICAgICogYGBgSmF2YVNjcmlwdFxyXG4gICAgICogdmFyIHZhbHVlID0gMjU2O1xyXG4gICAgICogdmFyIHBlcmNlbnQgPSBuZXcgYW01LnA1MDtcclxuICAgICAqIGNvbnNvbGUubG9nKHZhbHVlICogcGVyY2VudC52YWx1ZSk7IC8vIG91dHB1dHMgMTI4XHJcbiAgICAgKiBgYGBcclxuICAgICAqXHJcbiAgICAgKiBBbHRlcm5hdGl2ZWx5LCB5b3UgY2FuIHVzZSBgYW01LnBlcmNlbnQoKWAgaGVscGVyIGZ1bmN0aW9uOlxyXG4gICAgICpcclxuICAgICAqIGBgYFR5cGVTY3JpcHRcclxuICAgICAqIGxldCB2YWx1ZSA9IDI1NjtcclxuICAgICAqIGxldCBwZXJjZW50ID0gYW01LnA1MDtcclxuICAgICAqIGNvbnNvbGUubG9nKHZhbHVlICogcGVyY2VudC52YWx1ZSk7IC8vIG91dHB1dHMgMTI4XHJcbiAgICAgKiBgYGBcclxuICAgICAqIGBgYEphdmFTY3JpcHRcclxuICAgICAqIHZhciB2YWx1ZSA9IDI1NjtcclxuICAgICAqIHZhciBwZXJjZW50ID0gYW01LnA1MDtcclxuICAgICAqIGNvbnNvbGUubG9nKHZhbHVlICogcGVyY2VudC52YWx1ZSk7IC8vIG91dHB1dHMgMTI4XHJcbiAgICAgKiBgYGBcclxuICAgICAqXHJcbiAgICAgKiBAcmVhZG9ubHlcclxuICAgICAqIEByZXR1cm4gUmVsYXRpdmUgdmFsdWVcclxuICAgICAqL1xyXG4gICAgZ2V0IHZhbHVlKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl92YWx1ZSAvIDEwMDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVmFsdWUgaW4gcGVyY2VudC5cclxuICAgICAqXHJcbiAgICAgKiBAcmVhZG9ubHlcclxuICAgICAqIEByZXR1cm4gUGVyY2VudFxyXG4gICAgICovXHJcbiAgICBnZXQgcGVyY2VudCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fdmFsdWU7XHJcbiAgICB9XHJcbiAgICB0b1N0cmluZygpIHtcclxuICAgICAgICByZXR1cm4gXCJcIiArIHRoaXMuX3ZhbHVlICsgXCIlXCI7XHJcbiAgICB9XHJcbiAgICBpbnRlcnBvbGF0ZShtaW4sIG1heCkge1xyXG4gICAgICAgIHJldHVybiBtaW4gKyAodGhpcy52YWx1ZSAqIChtYXggLSBtaW4pKTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBub3JtYWxpemUocGVyY2VudCwgbWluLCBtYXgpIHtcclxuICAgICAgICBpZiAocGVyY2VudCBpbnN0YW5jZW9mIFBlcmNlbnQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHBlcmNlbnQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAobWluID09PSBtYXgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUGVyY2VudCgwKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUGVyY2VudChNYXRoLm1pbihNYXRoLm1heCgocGVyY2VudCAtIG1pbikgKiAoMSAvIChtYXggLSBtaW4pKSwgMCksIDEpICogMTAwKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4vKipcclxuICogQ29udmVydHMgbnVtZXJpYyBwZXJjZW50IHZhbHVlIHRvIGEgcHJvcGVyIFtbUGVyY2VudF1dIG9iamVjdC5cclxuICpcclxuICogYGBgVHlwZVNjcmlwdFxyXG4gKiBwaWVTZXJpZXMuc2V0KFwicmFkaXVzXCIsIGFtNS5wZXJjZW50KDgwKSk7XHJcbiAqIGBgYFxyXG4gKiBgYGBKYXZhU2NyaXB0XHJcbiAqIHBpZVNlcmllcy5zZXQoXCJyYWRpdXNcIiwgYW01LnBlcmNlbnQoODApKTtcclxuICogYGBgXHJcbiAqXHJcbiAqIEBwYXJhbSB2YWx1ZSAgUGVyY2VudFxyXG4gKiBAcmV0dXJuIFBlcmNlbnQgb2JqZWN0XHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gcGVyY2VudCh2YWx1ZSkge1xyXG4gICAgcmV0dXJuIG5ldyBQZXJjZW50KHZhbHVlKTtcclxufVxyXG4vKipcclxuICogQSBzaG9ydGN1dCBmdW5jdGlvbiB0byBgYW01LnBlcmNlbnQoMClgLlxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IHAwID0gcGVyY2VudCgwKTtcclxuLyoqXHJcbiAqIEEgc2hvcnRjdXQgZnVuY3Rpb24gdG8gYGFtNS5wZXJjZW50KDEwMClgLlxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IHAxMDAgPSBwZXJjZW50KDEwMCk7XHJcbi8qKlxyXG4gKiBBIHNob3J0Y3V0IGZ1bmN0aW9uIHRvIGBhbTUucGVyY2VudCg1MClgLlxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IHA1MCA9IHBlcmNlbnQoNTApO1xyXG4vKipcclxuICogQ2hlY2tzIGlmIHZhbHVlIGlzIGEgW1tQZXJjZW50XV0gb2JqZWN0LlxyXG4gKlxyXG4gKiBAaWdub3JlIEV4Y2x1ZGUgZnJvbSBkb2NzXHJcbiAqIEBwYXJhbSB2YWx1ZSAgSW5wdXQgdmFsdWVcclxuICogQHJldHVybiBJcyBwZXJjZW50P1xyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGlzUGVyY2VudCh2YWx1ZSkge1xyXG4gICAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUGVyY2VudDtcclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1QZXJjZW50LmpzLm1hcCIsIi8qKiBAaWdub3JlICovIC8qKiAqL1xyXG5pbXBvcnQgKiBhcyAkdHlwZSBmcm9tIFwiLi9UeXBlXCI7XHJcbmltcG9ydCAqIGFzICR1dGlscyBmcm9tIFwiLi9VdGlsc1wiO1xyXG5pbXBvcnQgeyBTcHJpdGUgfSBmcm9tIFwiLi4vcmVuZGVyL1Nwcml0ZVwiO1xyXG5pbXBvcnQgeyBUZXh0Rm9ybWF0dGVyIH0gZnJvbSBcIi4vVGV4dEZvcm1hdHRlclwiO1xyXG4vKipcclxuICogQGlnbm9yZVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHBvcHVsYXRlU3RyaW5nKHRhcmdldCwgc3RyaW5nKSB7XHJcbiAgICBpZiAoc3RyaW5nICE9IG51bGwpIHtcclxuICAgICAgICBzdHJpbmcgPSBcIlwiICsgc3RyaW5nO1xyXG4gICAgICAgIHN0cmluZyA9IFRleHRGb3JtYXR0ZXIuZXNjYXBlKHN0cmluZyk7XHJcbiAgICAgICAgbGV0IHRhZ3MgPSBzdHJpbmcubWF0Y2goL1xceyhbXn1dKylcXH0vZyk7XHJcbiAgICAgICAgbGV0IGk7XHJcbiAgICAgICAgaWYgKHRhZ3MpIHtcclxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHRhZ3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGxldCB0YWcgPSB0YWdzW2ldLnJlcGxhY2UoL1xceyhbXn1dKylcXH0vLCBcIiQxXCIpO1xyXG4gICAgICAgICAgICAgICAgbGV0IHZhbHVlID0gZ2V0VGFnVmFsdWUodGFyZ2V0LCB0YWcsIFwiXCIpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IFwiXCI7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBzdHJpbmcgPSBzdHJpbmcuc3BsaXQodGFnc1tpXSkuam9pbih2YWx1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgc3RyaW5nID0gVGV4dEZvcm1hdHRlci51bmVzY2FwZShzdHJpbmcpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgc3RyaW5nID0gXCJcIjtcclxuICAgIH1cclxuICAgIC8vIFRPRE86IGFwcGx5IGFkYXB0ZXI/XHJcbiAgICByZXR1cm4gc3RyaW5nO1xyXG59XHJcbi8qKlxyXG4gKiBAaWdub3JlXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRUYWdWYWx1ZSh0YXJnZXQsIHRhZ05hbWUsIGZvcm1hdCkge1xyXG4gICAgbGV0IHZhbHVlO1xyXG4gICAgY29uc3QgZGF0YUl0ZW0gPSB0YXJnZXQuZGF0YUl0ZW07XHJcbiAgICAvLyBQYXJzZSBwYXJ0c1xyXG4gICAgbGV0IHBhcnRzID0gW107XHJcbiAgICBsZXQgcmVnID0gLyhmb3JtYXRbYS16QS1aXSopXFwoKC4qKVxcKXwoW14uXSspL2c7XHJcbiAgICBsZXQgbWF0Y2hlcztcclxuICAgIHdoaWxlICh0cnVlKSB7XHJcbiAgICAgICAgbWF0Y2hlcyA9IHJlZy5leGVjKHRhZ05hbWUpO1xyXG4gICAgICAgIGlmIChtYXRjaGVzID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobWF0Y2hlc1szXSkge1xyXG4gICAgICAgICAgICAvLyBTaW1wbGUgcHJvcGVydHlcclxuICAgICAgICAgICAgcGFydHMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICBwcm9wOiBtYXRjaGVzWzNdXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAvLyBDaGVjayBpZiBtYXliZSB3ZSBzaG91bGQgZm9yY2UgYSBmb3JtYXR0ZXIgb24gdGhpcyB2YWx1ZVxyXG4gICAgICAgICAgICBjb25zdCBkYXRlRmllbGRzID0gdGFyZ2V0LmdldERhdGVGb3JtYXR0ZXIoKS5nZXQoXCJkYXRlRmllbGRzXCIsIFtdKTtcclxuICAgICAgICAgICAgY29uc3QgbnVtZXJpY0ZpZWxkcyA9IHRhcmdldC5nZXROdW1iZXJGb3JtYXR0ZXIoKS5nZXQoXCJudW1lcmljRmllbGRzXCIsIFtdKTtcclxuICAgICAgICAgICAgY29uc3QgZHVyYXRpb25GaWVsZHMgPSB0YXJnZXQuZ2V0RHVyYXRpb25Gb3JtYXR0ZXIoKS5nZXQoXCJkdXJhdGlvbkZpZWxkc1wiLCBbXSk7XHJcbiAgICAgICAgICAgIGlmIChkYXRlRmllbGRzLmluZGV4T2YobWF0Y2hlc1szXSkgIT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICBwYXJ0cy5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IFwiZm9ybWF0RGF0ZVwiLFxyXG4gICAgICAgICAgICAgICAgICAgIHBhcmFtczogW11cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKG51bWVyaWNGaWVsZHMuaW5kZXhPZihtYXRjaGVzWzNdKSAhPT0gLTEpIHtcclxuICAgICAgICAgICAgICAgIHBhcnRzLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZDogXCJmb3JtYXROdW1iZXJcIixcclxuICAgICAgICAgICAgICAgICAgICBwYXJhbXM6IFtdXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChkdXJhdGlvbkZpZWxkcy5pbmRleE9mKG1hdGNoZXNbM10pICE9PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgcGFydHMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBcImZvcm1hdER1cmF0aW9uXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zOiBbXVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIE1ldGhvZFxyXG4gICAgICAgICAgICAvLyBQYXJzZSBwYXJhbWV0ZXJzXHJcbiAgICAgICAgICAgIGxldCBwYXJhbXMgPSBbXTtcclxuICAgICAgICAgICAgaWYgKCR1dGlscy50cmltKG1hdGNoZXNbMl0pICE9IFwiXCIpIHtcclxuICAgICAgICAgICAgICAgIGxldCByZWcyID0gLycoW14nXSopJ3xcIihbXlwiXSopXCJ8KFswLTlcXC1dKykvZztcclxuICAgICAgICAgICAgICAgIGxldCBtYXRjaGVzMjtcclxuICAgICAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hlczIgPSByZWcyLmV4ZWMobWF0Y2hlc1syXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoZXMyID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBwYXJhbXMucHVzaChtYXRjaGVzMlsxXSB8fCBtYXRjaGVzMlsyXSB8fCBtYXRjaGVzMlszXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcGFydHMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICBtZXRob2Q6IG1hdGNoZXNbMV0sXHJcbiAgICAgICAgICAgICAgICBwYXJhbXM6IHBhcmFtc1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBDaGVjayBpZiB3ZSBjYW4gcmV0cmlldmUgdGhlIHZhbHVlIGZyb20gZGF0YSBpdGVtXHJcbiAgICBpZiAoZGF0YUl0ZW0pIHtcclxuICAgICAgICAvLyBDaGVjayB2YWx1ZXNcclxuICAgICAgICB2YWx1ZSA9IGdldFRhZ1ZhbHVlRnJvbU9iamVjdCh0YXJnZXQsIHBhcnRzLCBkYXRhSXRlbS5fc2V0dGluZ3MpO1xyXG4gICAgICAgIC8vIENoZWNrIHByb3BlcnRpZXNcclxuICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCB8fCAkdHlwZS5pc09iamVjdCh2YWx1ZSkpIHsgLy8gaXNPYmplY3QgaGVscHMgdG8gc29sdmUgcHJvYmxlbSB3aXRoIGRhdGUgYXhpcywgYXMgZm9yIGV4YW1wbGUgZGF0ZVggd2lsbCBnZXQgZGF0ZVggZnJvbSB2YWx1ZXMgb2JqZWN0IGFuZCB3b24ndCBnZXQgdG8gdGhlIGRhdGVYIGRhdGUuXHJcbiAgICAgICAgICAgIHZhbHVlID0gZ2V0VGFnVmFsdWVGcm9tT2JqZWN0KHRhcmdldCwgcGFydHMsIGRhdGFJdGVtKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gQ2hlY2sgZGF0YSBjb250ZXh0XHJcbiAgICAgICAgbGV0IGRhdGFDb250ZXh0ID0gZGF0YUl0ZW0uZGF0YUNvbnRleHQ7XHJcbiAgICAgICAgaWYgKHZhbHVlID09IG51bGwgJiYgZGF0YUNvbnRleHQpIHtcclxuICAgICAgICAgICAgdmFsdWUgPSBnZXRUYWdWYWx1ZUZyb21PYmplY3QodGFyZ2V0LCBwYXJ0cywgZGF0YUNvbnRleHQpO1xyXG4gICAgICAgICAgICAvLyBNYXliZSBpdCdzIGEgbGl0ZXJhbCBkb3Qtc2VwYXJhdGVkIG5hbWUgb2YgdGhlIGtleSBpbiBkYXRhQ29udGV4dD9cclxuICAgICAgICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHZhbHVlID0gZ2V0VGFnVmFsdWVGcm9tT2JqZWN0KHRhcmdldCwgW3tcclxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcDogdGFnTmFtZVxyXG4gICAgICAgICAgICAgICAgICAgIH1dLCBkYXRhQ29udGV4dCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gc2NvbmQgZGF0YSBjb250ZXh0IGxldmVsIHNvbWV0aW1lcyBleGlzdCAodHJlZSBtYXApXHJcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBudWxsICYmIGRhdGFDb250ZXh0LmRhdGFDb250ZXh0KSB7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGdldFRhZ1ZhbHVlRnJvbU9iamVjdCh0YXJnZXQsIHBhcnRzLCBkYXRhQ29udGV4dC5kYXRhQ29udGV4dCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gQ2hlY2sgY29tcG9uZW50J3MgZGF0YSBpdGVtXHJcbiAgICAgICAgaWYgKHZhbHVlID09IG51bGwgJiYgZGF0YUl0ZW0uY29tcG9uZW50ICYmIGRhdGFJdGVtLmNvbXBvbmVudC5kYXRhSXRlbSAhPT0gZGF0YUl0ZW0pIHtcclxuICAgICAgICAgICAgdmFsdWUgPSBnZXRUYWdWYWx1ZShkYXRhSXRlbS5jb21wb25lbnQsIHRhZ05hbWUsIGZvcm1hdCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gQ2hlY2sgc3ByaXRlJ3MgcHJvcGVydGllc1xyXG4gICAgaWYgKHZhbHVlID09IG51bGwpIHtcclxuICAgICAgICB2YWx1ZSA9IGdldFRhZ1ZhbHVlRnJvbU9iamVjdCh0YXJnZXQsIHBhcnRzLCB0YXJnZXQpO1xyXG4gICAgfVxyXG4gICAgLy8gRmluYWxseSwgY2hlY2sgdGhlIHBhcmVudFxyXG4gICAgaWYgKHZhbHVlID09IG51bGwgJiYgdGFyZ2V0LnBhcmVudCkge1xyXG4gICAgICAgIHZhbHVlID0gZ2V0VGFnVmFsdWUodGFyZ2V0LnBhcmVudCwgdGFnTmFtZSwgZm9ybWF0KTtcclxuICAgIH1cclxuICAgIHJldHVybiB2YWx1ZTtcclxufVxyXG4vKipcclxuICogQGlnbm9yZVxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0Q3VzdG9tRGF0YVZhbHVlKHRhcmdldCwgcHJvcCkge1xyXG4gICAgY29uc3QgY3VzdG9tRGF0YSA9IHRhcmdldC5nZXRQcml2YXRlKFwiY3VzdG9tRGF0YVwiKTtcclxuICAgIGlmICgkdHlwZS5pc09iamVjdChjdXN0b21EYXRhKSkge1xyXG4gICAgICAgIHJldHVybiBjdXN0b21EYXRhW3Byb3BdO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBAaWdub3JlXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ2V0VGFnVmFsdWVGcm9tT2JqZWN0KHRhcmdldCwgcGFydHMsIG9iamVjdCwgZm9ybWF0KSB7XHJcbiAgICBsZXQgY3VycmVudCA9IG9iamVjdDtcclxuICAgIGxldCBmb3JtYXRBcHBsaWVkID0gZmFsc2U7XHJcbiAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gcGFydHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICBsZXQgcGFydCA9IHBhcnRzW2ldO1xyXG4gICAgICAgIGlmIChwYXJ0LnByb3ApIHtcclxuICAgICAgICAgICAgLy8gUmVndWxhciBwcm9wZXJ0eVxyXG4gICAgICAgICAgICBpZiAoY3VycmVudCBpbnN0YW5jZW9mIFNwcml0ZSkge1xyXG4gICAgICAgICAgICAgICAgbGV0IHRtcCA9IGN1cnJlbnQuZ2V0KHBhcnQucHJvcCk7XHJcbiAgICAgICAgICAgICAgICBpZiAodG1wID09IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgdG1wID0gY3VycmVudC5nZXRQcml2YXRlKHBhcnQucHJvcCk7XHJcbiAgICAgICAgICAgICAgICBpZiAodG1wID09IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgdG1wID0gZ2V0Q3VzdG9tRGF0YVZhbHVlKGN1cnJlbnQsIHBhcnQucHJvcCk7XHJcbiAgICAgICAgICAgICAgICBpZiAodG1wID09IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgdG1wID0gY3VycmVudFtwYXJ0LnByb3BdO1xyXG4gICAgICAgICAgICAgICAgY3VycmVudCA9IHRtcDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChjdXJyZW50LmdldCkge1xyXG4gICAgICAgICAgICAgICAgbGV0IHRtcCA9IGN1cnJlbnQuZ2V0KHBhcnQucHJvcCk7XHJcbiAgICAgICAgICAgICAgICBpZiAodG1wID09IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgdG1wID0gY3VycmVudFtwYXJ0LnByb3BdO1xyXG4gICAgICAgICAgICAgICAgY3VycmVudCA9IHRtcDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50W3BhcnQucHJvcF07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGN1cnJlbnQgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgLy8gTm90IHNldCwgcmV0dXJuIHVuZGVmaW5lZFxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBNZXRob2RcclxuICAgICAgICAgICAgc3dpdGNoIChwYXJ0Lm1ldGhvZCkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSBcImZvcm1hdE51bWJlclwiOlxyXG4gICAgICAgICAgICAgICAgICAgIGxldCBudW1iZXJWYWx1ZSA9ICR0eXBlLnRvTnVtYmVyKGN1cnJlbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChudW1iZXJWYWx1ZSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnQgPSB0YXJnZXQuZ2V0TnVtYmVyRm9ybWF0dGVyKCkuZm9ybWF0KG51bWJlclZhbHVlLCBmb3JtYXQgfHwgcGFydC5wYXJhbXNbMF0gfHwgdW5kZWZpbmVkKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9ybWF0QXBwbGllZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBcImZvcm1hdERhdGVcIjpcclxuICAgICAgICAgICAgICAgICAgICBsZXQgZGF0ZVZhbHVlID0gJHR5cGUudG9EYXRlKGN1cnJlbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghJHR5cGUuaXNEYXRlKGRhdGVWYWx1ZSkgfHwgJHR5cGUuaXNOYU4oZGF0ZVZhbHVlLmdldFRpbWUoKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2FzIG5vdCBhYmxlIHRvIGdldCBkYXRlIG91dCBvZiB2YWx1ZSwgcXVpdHRpbmcgYW5kIGxldHRpbmdcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FsbGluZyBtZXRob2QgdHJ5IGFub3RoZXIgdmFsdWVcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoZGF0ZVZhbHVlICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudCA9IHRhcmdldC5nZXREYXRlRm9ybWF0dGVyKCkuZm9ybWF0KGRhdGVWYWx1ZSwgZm9ybWF0IHx8IHBhcnQucGFyYW1zWzBdIHx8IHVuZGVmaW5lZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcm1hdEFwcGxpZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJmb3JtYXREdXJhdGlvblwiOlxyXG4gICAgICAgICAgICAgICAgICAgIGxldCBkdXJhdGlvblZhbHVlID0gJHR5cGUudG9OdW1iZXIoY3VycmVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGR1cmF0aW9uVmFsdWUgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50ID0gdGFyZ2V0LmdldER1cmF0aW9uRm9ybWF0dGVyKCkuZm9ybWF0KGR1cmF0aW9uVmFsdWUsIGZvcm1hdCB8fCBwYXJ0LnBhcmFtc1swXSB8fCB1bmRlZmluZWQsIHBhcnQucGFyYW1zWzFdIHx8IHVuZGVmaW5lZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcm1hdEFwcGxpZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJ1cmxFbmNvZGVcIjpcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJlbmNvZGVVUklDb21wb25lbnRcIjpcclxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50ID0gZW5jb2RlVVJJQ29tcG9uZW50KGN1cnJlbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudFtwYXJ0Lm1ldGhvZF0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFtwYXJ0Lm1ldGhvZF0uYXBwbHkob2JqZWN0LCBwYXJ0LnBhcmFtcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gQXBwbHkgZGVmYXVsdCBmb3JtYXQgaWYgaXQgd2Fzbid0IGFwcGxpZWQgZXhwbGljaXRseVxyXG4gICAgaWYgKCFmb3JtYXRBcHBsaWVkKSB7XHJcbiAgICAgICAgbGV0IGZvcm1hdFBhcnRzID0gW3tcclxuICAgICAgICAgICAgICAgIG1ldGhvZDogXCJcIixcclxuICAgICAgICAgICAgICAgIHBhcmFtczogZm9ybWF0XHJcbiAgICAgICAgICAgIH1dO1xyXG4gICAgICAgIGlmIChmb3JtYXQgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAvLyBGb3JtYXQgaXMgbm90IHNldFxyXG4gICAgICAgICAgICAvLyBEZXRlcm1pbmUgZnJvbSB0aGUgdHlwZSBvZiB0aGUgdmFsdWVcclxuICAgICAgICAgICAgaWYgKCR0eXBlLmlzTnVtYmVyKGN1cnJlbnQpKSB7XHJcbiAgICAgICAgICAgICAgICBmb3JtYXRQYXJ0c1swXS5tZXRob2QgPSBcImZvcm1hdE51bWJlclwiO1xyXG4gICAgICAgICAgICAgICAgZm9ybWF0UGFydHNbMF0ucGFyYW1zID0gXCJcIjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICgkdHlwZS5pc0RhdGUoY3VycmVudCkpIHtcclxuICAgICAgICAgICAgICAgIGZvcm1hdFBhcnRzWzBdLm1ldGhvZCA9IFwiZm9ybWF0RGF0ZVwiO1xyXG4gICAgICAgICAgICAgICAgZm9ybWF0UGFydHNbMF0ucGFyYW1zID0gXCJcIjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gRm9ybWF0IHNldFxyXG4gICAgICAgICAgICAvLyBUcnkgdG8gZGV0ZXJtaW5lIGZvcm1hdHRlciBiYXNlZCBvbiB0aGUgZm9ybWF0XHJcbiAgICAgICAgICAgIGxldCBmb3JtYXR0ZXJUeXBlID0gJHV0aWxzLmdldEZvcm1hdChmb3JtYXQpO1xyXG4gICAgICAgICAgICAvLyBmb3JtYXRcclxuICAgICAgICAgICAgaWYgKGZvcm1hdHRlclR5cGUgPT09IFwibnVtYmVyXCIpIHtcclxuICAgICAgICAgICAgICAgIGZvcm1hdFBhcnRzWzBdLm1ldGhvZCA9IFwiZm9ybWF0TnVtYmVyXCI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoZm9ybWF0dGVyVHlwZSA9PT0gXCJkYXRlXCIpIHtcclxuICAgICAgICAgICAgICAgIGZvcm1hdFBhcnRzWzBdLm1ldGhvZCA9IFwiZm9ybWF0RGF0ZVwiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGZvcm1hdHRlclR5cGUgPT09IFwiZHVyYXRpb25cIikge1xyXG4gICAgICAgICAgICAgICAgZm9ybWF0UGFydHNbMF0ubWV0aG9kID0gXCJmb3JtYXREdXJhdGlvblwiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIEFwcGx5IGZvcm1hdFxyXG4gICAgICAgIGlmIChmb3JtYXRQYXJ0c1swXS5tZXRob2QpIHtcclxuICAgICAgICAgICAgY3VycmVudCA9IGdldFRhZ1ZhbHVlRnJvbU9iamVjdCh0YXJnZXQsIGZvcm1hdFBhcnRzLCBjdXJyZW50KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gY3VycmVudDtcclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1Qb3B1bGF0ZVN0cmluZy5qcy5tYXAiLCIvKiogQGlnbm9yZSAqLyAvKiogKi9cclxuaW1wb3J0ICogYXMgJGFycmF5IGZyb20gXCIuL0FycmF5XCI7XHJcbmltcG9ydCAqIGFzICR1dGlscyBmcm9tIFwiLi9VdGlsc1wiO1xyXG4vKipcclxuICogQGlnbm9yZVxyXG4gKi9cclxuY2xhc3MgTmF0aXZlIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9vYnNlcnZlclwiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfdGFyZ2V0c1wiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiBbXVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuX29ic2VydmVyID0gbmV3IFJlc2l6ZU9ic2VydmVyKChlbnRyaWVzKSA9PiB7XHJcbiAgICAgICAgICAgICRhcnJheS5lYWNoKGVudHJpZXMsIChlbnRyeSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgJGFycmF5LmVhY2godGhpcy5fdGFyZ2V0cywgKHgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoeC50YXJnZXQgPT09IGVudHJ5LnRhcmdldCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB4LmNhbGxiYWNrKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgYWRkVGFyZ2V0KHRhcmdldCwgY2FsbGJhY2spIHtcclxuICAgICAgICB0aGlzLl9vYnNlcnZlci5vYnNlcnZlKHRhcmdldCwgeyBib3g6IFwiYm9yZGVyLWJveFwiIH0pO1xyXG4gICAgICAgIHRoaXMuX3RhcmdldHMucHVzaCh7IHRhcmdldCwgY2FsbGJhY2sgfSk7XHJcbiAgICB9XHJcbiAgICByZW1vdmVUYXJnZXQodGFyZ2V0KSB7XHJcbiAgICAgICAgdGhpcy5fb2JzZXJ2ZXIudW5vYnNlcnZlKHRhcmdldCk7XHJcbiAgICAgICAgJGFycmF5LmtlZXBJZih0aGlzLl90YXJnZXRzLCAoeCkgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4geC50YXJnZXQgIT09IHRhcmdldDtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQGlnbm9yZVxyXG4gKi9cclxuY2xhc3MgUmFmIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl90aW1lclwiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiBudWxsXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX3RhcmdldHNcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogW11cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGFkZFRhcmdldCh0YXJnZXQsIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX3RpbWVyID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGxldCBsYXN0VGltZSA9IG51bGw7XHJcbiAgICAgICAgICAgIGNvbnN0IGxvb3AgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50VGltZSA9IERhdGUubm93KCk7XHJcbiAgICAgICAgICAgICAgICBpZiAobGFzdFRpbWUgPT09IG51bGwgfHwgY3VycmVudFRpbWUgPiAobGFzdFRpbWUgKyBSYWYuZGVsYXkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGFzdFRpbWUgPSBjdXJyZW50VGltZTtcclxuICAgICAgICAgICAgICAgICAgICAkYXJyYXkuZWFjaCh0aGlzLl90YXJnZXRzLCAoeCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgbmV3U2l6ZSA9IHgudGFyZ2V0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobmV3U2l6ZS53aWR0aCAhPT0geC5zaXplLndpZHRoIHx8IG5ld1NpemUuaGVpZ2h0ICE9PSB4LnNpemUuaGVpZ2h0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4LnNpemUgPSBuZXdTaXplO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeC5jYWxsYmFjaygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fdGFyZ2V0cy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl90aW1lciA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl90aW1lciA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShsb29wKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgdGhpcy5fdGltZXIgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUobG9vcCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFdlIHN0YXJ0IG9mZiB3aXRoIGZha2UgYm91bmRzIHNvIHRoYXQgc2Vuc29yIGFsd2F5cyBraWNrcyBpblxyXG4gICAgICAgIGxldCBzaXplID0geyB3aWR0aDogMCwgaGVpZ2h0OiAwLCBsZWZ0OiAwLCByaWdodDogMCwgdG9wOiAwLCBib3R0b206IDAsIHg6IDAsIHk6IDAgfTtcclxuICAgICAgICB0aGlzLl90YXJnZXRzLnB1c2goeyB0YXJnZXQsIGNhbGxiYWNrLCBzaXplIH0pO1xyXG4gICAgfVxyXG4gICAgcmVtb3ZlVGFyZ2V0KHRhcmdldCkge1xyXG4gICAgICAgICRhcnJheS5rZWVwSWYodGhpcy5fdGFyZ2V0cywgKHgpID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIHgudGFyZ2V0ICE9PSB0YXJnZXQ7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKHRoaXMuX3RhcmdldHMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl90aW1lciAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5fdGltZXIpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fdGltZXIgPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShSYWYsIFwiZGVsYXlcIiwge1xyXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgdmFsdWU6IDIwMFxyXG59KTtcclxuLyoqXHJcbiAqIEBpZ25vcmVcclxuICovXHJcbmxldCBvYnNlcnZlciA9IG51bGw7XHJcbi8qKlxyXG4gKiBAaWdub3JlXHJcbiAqL1xyXG5mdW5jdGlvbiBtYWtlU2Vuc29yKCkge1xyXG4gICAgaWYgKG9ic2VydmVyID09PSBudWxsKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBSZXNpemVPYnNlcnZlciAhPT0gXCJ1bmRlZmluZWRcIikge1xyXG4gICAgICAgICAgICBvYnNlcnZlciA9IG5ldyBOYXRpdmUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIG9ic2VydmVyID0gbmV3IFJhZigpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBvYnNlcnZlcjtcclxufVxyXG4vKipcclxuICogQGlnbm9yZVxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIFJlc2l6ZVNlbnNvciB7XHJcbiAgICBjb25zdHJ1Y3RvcihlbGVtZW50LCBjYWxsYmFjaykge1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9zZW5zb3JcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX2VsZW1lbnRcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX2xpc3RlbmVyXCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9kaXNwb3NlZFwiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiBmYWxzZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuX3NlbnNvciA9IG1ha2VTZW5zb3IoKTtcclxuICAgICAgICB0aGlzLl9lbGVtZW50ID0gZWxlbWVudDtcclxuICAgICAgICAvLyBUaGlzIGlzIG5lZWRlZCBiZWNhdXNlIHdlIG5lZWQgdG8ga25vdyB3aGVuIHRoZSB3aW5kb3cgaXMgem9vbWVkXHJcbiAgICAgICAgdGhpcy5fbGlzdGVuZXIgPSAkdXRpbHMub25ab29tKGNhbGxiYWNrKTtcclxuICAgICAgICB0aGlzLl9zZW5zb3IuYWRkVGFyZ2V0KGVsZW1lbnQsIGNhbGxiYWNrKTtcclxuICAgIH1cclxuICAgIGlzRGlzcG9zZWQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Rpc3Bvc2VkO1xyXG4gICAgfVxyXG4gICAgZGlzcG9zZSgpIHtcclxuICAgICAgICBpZiAoIXRoaXMuX2Rpc3Bvc2VkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2Rpc3Bvc2VkID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy5fc2Vuc29yLnJlbW92ZVRhcmdldCh0aGlzLl9lbGVtZW50KTtcclxuICAgICAgICAgICAgdGhpcy5fbGlzdGVuZXIuZGlzcG9zZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGdldCBzZW5zb3IoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NlbnNvcjtcclxuICAgIH1cclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1SZXNpemVTZW5zb3IuanMubWFwIiwiaW1wb3J0ICogYXMgJG9iamVjdCBmcm9tIFwiLi9PYmplY3RcIjtcclxuaW1wb3J0ICogYXMgJGVhc2UgZnJvbSBcIi4vRWFzZVwiO1xyXG4vKipcclxuICogQW4gb2JqZWN0IHJlcHJlc2VudGluZyBhIGNvbGxlY3Rpb24gb2Ygc2V0dGluZyB2YWx1ZXMgdG8gYXBwbHkgYXMgcmVxdWlyZWQuXHJcbiAqXHJcbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vd3d3LmFtY2hhcnRzLmNvbS9kb2NzL3Y1L2NvbmNlcHRzL3NldHRpbmdzL3N0YXRlcy99IGZvciBtb3JlIGluZm9cclxuICovXHJcbmV4cG9ydCBjbGFzcyBTdGF0ZSB7XHJcbiAgICBjb25zdHJ1Y3RvcihlbnRpdHksIHNldHRpbmdzKSB7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX2VudGl0eVwiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfc2V0dGluZ3NcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX3VzZXJTZXR0aW5nc1wiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiB7fVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuX2VudGl0eSA9IGVudGl0eTtcclxuICAgICAgICB0aGlzLl9zZXR0aW5ncyA9IHNldHRpbmdzO1xyXG4gICAgICAgICRvYmplY3QuZWFjaChzZXR0aW5ncywgKGtleSkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLl91c2VyU2V0dGluZ3Nba2V5XSA9IHRydWU7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBnZXQoa2V5LCBmYWxsYmFjaykge1xyXG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5fc2V0dGluZ3Nba2V5XTtcclxuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsbGJhY2s7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAaWdub3JlXHJcbiAgICAgKi9cclxuICAgIHNldFJhdyhrZXksIHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5fc2V0dGluZ3Nba2V5XSA9IHZhbHVlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIGEgc2V0dGluZyBgdmFsdWVgIGZvciB0aGUgc3BlY2lmaWVkIGBrZXlgIHRvIGJlIHNldCB3aGVuIHRoZSBzdGF0ZVxyXG4gICAgICogaXMgYXBwbGllZC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gICBrZXkgICAgICAgU2V0dGluZyBrZXlcclxuICAgICAqIEBwYXJhbSAgIHZhbHVlICAgICBTZXR0aW5nIHZhbHVlXHJcbiAgICAgKiBAcmV0dXJuICAgICAgICAgICAgU2V0dGluZyB2YWx1ZVxyXG4gICAgICovXHJcbiAgICBzZXQoa2V5LCB2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMuX3VzZXJTZXR0aW5nc1trZXldID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLnNldFJhdyhrZXksIHZhbHVlKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlcyBhIHNldHRpbmcgdmFsdWUgZm9yIHRoZSBzcGVjaWZpZWQgYGtleWAuXHJcbiAgICAgKlxyXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly93d3cuYW1jaGFydHMuY29tL2RvY3MvdjUvY29uY2VwdHMvc2V0dGluZ3MvfSBmb3IgbW9yZSBpbmZvXHJcbiAgICAgKiBAcGFyYW0gICBrZXkgICAgICAgU2V0dGluZyBrZXlcclxuICAgICAqL1xyXG4gICAgcmVtb3ZlKGtleSkge1xyXG4gICAgICAgIGRlbGV0ZSB0aGlzLl91c2VyU2V0dGluZ3Nba2V5XTtcclxuICAgICAgICBkZWxldGUgdGhpcy5fc2V0dGluZ3Nba2V5XTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyBtdWx0aXBsZSBzZXR0aW5ncyBhdCBvbmNlLlxyXG4gICAgICpcclxuICAgICAqIGBzZXR0aW5nc2AgbXVzdCBiZSBhbiBvYmplY3Qgd2l0aCBrZXk6IHZhbHVlIHBhaXJzLlxyXG4gICAgICpcclxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vd3d3LmFtY2hhcnRzLmNvbS9kb2NzL3Y1L2NvbmNlcHRzL3NldHRpbmdzL30gZm9yIG1vcmUgaW5mb1xyXG4gICAgICogQHBhcmFtIHNldHRpbmdzIFNldHRpbmdzXHJcbiAgICAgKi9cclxuICAgIHNldEFsbChzZXR0aW5ncykge1xyXG4gICAgICAgICRvYmplY3Qua2V5cyhzZXR0aW5ncykuZm9yRWFjaCgoa2V5KSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0KGtleSwgc2V0dGluZ3Nba2V5XSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBfZWFjaFNldHRpbmcoZikge1xyXG4gICAgICAgICRvYmplY3QuZWFjaCh0aGlzLl9zZXR0aW5ncywgZik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEFwcGxpZXMgdGhlIHN0YXRlIHRvIHRoZSB0YXJnZXQgZWxlbWVudC5cclxuICAgICAqXHJcbiAgICAgKiBBbGwgc2V0dGluZyB2YWx1ZXMgYXJlIHNldCBpbW1lZGlhdGVseS5cclxuICAgICAqL1xyXG4gICAgYXBwbHkoKSB7XHJcbiAgICAgICAgY29uc3Qgc2VlbiA9IHt9O1xyXG4gICAgICAgIHNlZW5bXCJzdGF0ZUFuaW1hdGlvbkVhc2luZ1wiXSA9IHRydWU7XHJcbiAgICAgICAgc2VlbltcInN0YXRlQW5pbWF0aW9uRHVyYXRpb25cIl0gPSB0cnVlO1xyXG4gICAgICAgIGNvbnN0IGRlZmF1bHRTdGF0ZSA9IHRoaXMuX2VudGl0eS5zdGF0ZXMubG9va3VwKFwiZGVmYXVsdFwiKTtcclxuICAgICAgICB0aGlzLl9lYWNoU2V0dGluZygoa2V5LCB2YWx1ZSkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoIXNlZW5ba2V5XSkge1xyXG4gICAgICAgICAgICAgICAgc2VlbltrZXldID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIC8vIHNhdmUgdmFsdWVzIHRvIGRlZmF1bHQgc3RhdGVcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzICE9PSBkZWZhdWx0U3RhdGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIShrZXkgaW4gZGVmYXVsdFN0YXRlLl9zZXR0aW5ncykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdFN0YXRlLl9zZXR0aW5nc1trZXldID0gdGhpcy5fZW50aXR5LmdldChrZXkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuX2VudGl0eS5zZXQoa2V5LCB2YWx1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQXBwbGllcyB0aGUgc3RhdGUgdG8gdGhlIHRhcmdldCBlbGVtZW50LlxyXG4gICAgICpcclxuICAgICAqIFJldHVybnMgYW4gb2JqZWN0IHJlcHJlc2VudGluZyBhbGwgW1tBbmltYXRpb25dXSBvYmplY3RzIGNyZWF0ZWQgZm9yXHJcbiAgICAgKiBlYWNoIHNldHRpbmcga2V5IHRyYW5zaXRpb24uXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybiAgICAgICAgICAgQW5pbWF0aW9uc1xyXG4gICAgICovXHJcbiAgICBhcHBseUFuaW1hdGUoZHVyYXRpb24pIHtcclxuICAgICAgICBpZiAoZHVyYXRpb24gPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBkdXJhdGlvbiA9IHRoaXMuX3NldHRpbmdzLnN0YXRlQW5pbWF0aW9uRHVyYXRpb247XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChkdXJhdGlvbiA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGR1cmF0aW9uID0gdGhpcy5nZXQoXCJzdGF0ZUFuaW1hdGlvbkR1cmF0aW9uXCIsIHRoaXMuX2VudGl0eS5nZXQoXCJzdGF0ZUFuaW1hdGlvbkR1cmF0aW9uXCIsIDApKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IGVhc2luZyA9IHRoaXMuX3NldHRpbmdzLnN0YXRlQW5pbWF0aW9uRWFzaW5nO1xyXG4gICAgICAgIGlmIChlYXNpbmcgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBlYXNpbmcgPSB0aGlzLmdldChcInN0YXRlQW5pbWF0aW9uRWFzaW5nXCIsIHRoaXMuX2VudGl0eS5nZXQoXCJzdGF0ZUFuaW1hdGlvbkVhc2luZ1wiLCAkZWFzZS5jdWJpYykpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBkZWZhdWx0U3RhdGUgPSB0aGlzLl9lbnRpdHkuc3RhdGVzLmxvb2t1cChcImRlZmF1bHRcIik7XHJcbiAgICAgICAgY29uc3Qgc2VlbiA9IHt9O1xyXG4gICAgICAgIHNlZW5bXCJzdGF0ZUFuaW1hdGlvbkVhc2luZ1wiXSA9IHRydWU7XHJcbiAgICAgICAgc2VlbltcInN0YXRlQW5pbWF0aW9uRHVyYXRpb25cIl0gPSB0cnVlO1xyXG4gICAgICAgIGNvbnN0IGFuaW1hdGlvbnMgPSB7fTtcclxuICAgICAgICB0aGlzLl9lYWNoU2V0dGluZygoa2V5LCB2YWx1ZSkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoIXNlZW5ba2V5XSkge1xyXG4gICAgICAgICAgICAgICAgc2VlbltrZXldID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIC8vIHNhdmUgdmFsdWVzIHRvIGRlZmF1bHQgc3RhdGVcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzICE9IGRlZmF1bHRTdGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghKGtleSBpbiBkZWZhdWx0U3RhdGUuX3NldHRpbmdzKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0U3RhdGUuX3NldHRpbmdzW2tleV0gPSB0aGlzLl9lbnRpdHkuZ2V0KGtleSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY29uc3QgYW5pbWF0aW9uID0gdGhpcy5fZW50aXR5LmFuaW1hdGUoe1xyXG4gICAgICAgICAgICAgICAgICAgIGtleToga2V5LFxyXG4gICAgICAgICAgICAgICAgICAgIHRvOiB2YWx1ZSxcclxuICAgICAgICAgICAgICAgICAgICBkdXJhdGlvbjogZHVyYXRpb24sXHJcbiAgICAgICAgICAgICAgICAgICAgZWFzaW5nOiBlYXNpbmdcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgaWYgKGFuaW1hdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgIGFuaW1hdGlvbnNba2V5XSA9IGFuaW1hdGlvbjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBhbmltYXRpb25zO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBDb2xsZWN0aW9uIG9mIFtbU3RhdGVdXSBvYmplY3RzIGZvciBhbiBlbGVtZW50LlxyXG4gKlxyXG4gKiBAc2VlIHtAbGluayBodHRwczovL3d3dy5hbWNoYXJ0cy5jb20vZG9jcy92NS9jb25jZXB0cy9zZXR0aW5ncy9zdGF0ZXMvfSBmb3IgbW9yZSBpbmZvXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgU3RhdGVzIHtcclxuICAgIGNvbnN0cnVjdG9yKGVudGl0eSkge1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9zdGF0ZXNcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZToge31cclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfZW50aXR5XCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuX2VudGl0eSA9IGVudGl0eTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ2hlY2tzIGlmIGEgc3RhdGUgYnkgYG5hbWVgIGV4aXN0cy4gUmV0dXJucyBpdCB0aGVyZSBpcyBvbmUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtICBuYW1lICBTdGF0ZSBuYW1lXHJcbiAgICAgKiBAcmV0dXJuICAgICAgIFN0YXRlXHJcbiAgICAgKi9cclxuICAgIGxvb2t1cChuYW1lKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0YXRlc1tuYW1lXTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyBzdXBwbGllZCBgc2V0dGluZ3NgIG9uIGEgc3RhdGUgYnkgdGhlIGBuYW1lYC5cclxuICAgICAqXHJcbiAgICAgKiBJZiBzdWNoIHN0YXRlIGRvZXMgbm90IHlldCBleGlzdHMsIGl0IGlzIGNyZWF0ZWQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtICAgbmFtZSAgICAgIFN0YXRlIG5hbWVcclxuICAgICAqIEBwYXJhbSAgIHNldHRpbmdzICBTZXR0aW5nc1xyXG4gICAgICogQHJldHVybiAgICAgICAgICAgIE5ldyBTdGF0ZVxyXG4gICAgICovXHJcbiAgICBjcmVhdGUobmFtZSwgc2V0dGluZ3MpIHtcclxuICAgICAgICBjb25zdCBzdGF0ZSA9IHRoaXMuX3N0YXRlc1tuYW1lXTtcclxuICAgICAgICBpZiAoc3RhdGUpIHtcclxuICAgICAgICAgICAgc3RhdGUuc2V0QWxsKHNldHRpbmdzKTtcclxuICAgICAgICAgICAgcmV0dXJuIHN0YXRlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3Qgc3RhdGUgPSBuZXcgU3RhdGUodGhpcy5fZW50aXR5LCBzZXR0aW5ncyk7XHJcbiAgICAgICAgICAgIHRoaXMuX3N0YXRlc1tuYW1lXSA9IHN0YXRlO1xyXG4gICAgICAgICAgICByZXR1cm4gc3RhdGU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmVzIHRoZSBzdGF0ZSBjYWxsZWQgYG5hbWVgLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSAgIG5hbWUgICAgICBTdGF0ZSBuYW1lXHJcbiAgICAgKi9cclxuICAgIHJlbW92ZShuYW1lKSB7XHJcbiAgICAgICAgZGVsZXRlIHRoaXMuX3N0YXRlc1tuYW1lXTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQXBwbGllcyBhIG5hbWVkIHN0YXRlIHRvIHRoZSB0YXJnZXQgZWxlbWVudC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gIG5ld1N0YXRlICBTdGF0ZSBuYW1lXHJcbiAgICAgKi9cclxuICAgIGFwcGx5KG5ld1N0YXRlKSB7XHJcbiAgICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzLl9zdGF0ZXNbbmV3U3RhdGVdO1xyXG4gICAgICAgIGlmIChzdGF0ZSkge1xyXG4gICAgICAgICAgICBzdGF0ZS5hcHBseSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9lbnRpdHkuX2FwcGx5U3RhdGUobmV3U3RhdGUpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBcHBsaWVzIGEgbmFtZWQgc3RhdGUgdG8gdGhlIGVsZW1lbnQuXHJcbiAgICAgKlxyXG4gICAgICogUmV0dXJucyBhbiBvYmplY3QgcmVwcmVzZW50aW5nIGFsbCBbW0FuaW1hdGlvbl1dIG9iamVjdHMgY3JlYXRlZCBmb3JcclxuICAgICAqIGVhY2ggc2V0dGluZyBrZXkgdHJhbnNpdGlvbi5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gICBuZXdTdGF0ZSAgU3RhdGUgbmFtZVxyXG4gICAgICogQHJldHVybiAgICAgICAgICAgIEFuaW1hdGlvbnNcclxuICAgICAqL1xyXG4gICAgYXBwbHlBbmltYXRlKG5ld1N0YXRlLCBkdXJhdGlvbikge1xyXG4gICAgICAgIGxldCBhbmltYXRpb25zO1xyXG4gICAgICAgIGNvbnN0IHN0YXRlID0gdGhpcy5fc3RhdGVzW25ld1N0YXRlXTtcclxuICAgICAgICBpZiAoc3RhdGUpIHtcclxuICAgICAgICAgICAgYW5pbWF0aW9ucyA9IHN0YXRlLmFwcGx5QW5pbWF0ZShkdXJhdGlvbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2VudGl0eS5fYXBwbHlTdGF0ZUFuaW1hdGVkKG5ld1N0YXRlLCBkdXJhdGlvbik7XHJcbiAgICAgICAgcmV0dXJuIGFuaW1hdGlvbnM7XHJcbiAgICB9XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U3RhdGVzLmpzLm1hcCIsImltcG9ydCB7IEV2ZW50RGlzcGF0Y2hlciB9IGZyb20gXCIuL0V2ZW50RGlzcGF0Y2hlclwiO1xyXG5pbXBvcnQgeyBEaXNwb3NlciwgTXVsdGlEaXNwb3NlciB9IGZyb20gXCIuL0Rpc3Bvc2VyXCI7XHJcbmltcG9ydCAqIGFzICRhcnJheSBmcm9tIFwiLi9BcnJheVwiO1xyXG5pbXBvcnQgKiBhcyAkb2JqZWN0IGZyb20gXCIuL09iamVjdFwiO1xyXG5leHBvcnQgY2xhc3MgVGVtcGxhdGVTdGF0ZSB7XHJcbiAgICBjb25zdHJ1Y3RvcihuYW1lLCB0ZW1wbGF0ZSwgc2V0dGluZ3MpIHtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfc2V0dGluZ3NcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX25hbWVcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX3RlbXBsYXRlXCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuX25hbWUgPSBuYW1lO1xyXG4gICAgICAgIHRoaXMuX3RlbXBsYXRlID0gdGVtcGxhdGU7XHJcbiAgICAgICAgdGhpcy5fc2V0dGluZ3MgPSBzZXR0aW5ncztcclxuICAgIH1cclxuICAgIGdldChrZXksIGZhbGxiYWNrKSB7XHJcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLl9zZXR0aW5nc1trZXldO1xyXG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxsYmFjaztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBzZXQoa2V5LCB2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMuX3NldHRpbmdzW2tleV0gPSB2YWx1ZTtcclxuICAgICAgICAvLyBUT0RPIG1heWJlIG9ubHkgZG8gdGhpcyBpZiB0aGUgdmFsdWUgY2hhbmdlZCA/XHJcbiAgICAgICAgdGhpcy5fdGVtcGxhdGUuX3N0YXRlQ2hhbmdlZCh0aGlzLl9uYW1lKTtcclxuICAgIH1cclxuICAgIHJlbW92ZShrZXkpIHtcclxuICAgICAgICBkZWxldGUgdGhpcy5fc2V0dGluZ3Nba2V5XTtcclxuICAgICAgICAvLyBUT0RPIG1heWJlIG9ubHkgZG8gdGhpcyBpZiB0aGUgdmFsdWUgY2hhbmdlZCA/XHJcbiAgICAgICAgdGhpcy5fdGVtcGxhdGUuX3N0YXRlQ2hhbmdlZCh0aGlzLl9uYW1lKTtcclxuICAgIH1cclxuICAgIHNldEFsbChzZXR0aW5ncykge1xyXG4gICAgICAgICRvYmplY3Qua2V5cyhzZXR0aW5ncykuZm9yRWFjaCgoa2V5KSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuX3NldHRpbmdzW2tleV0gPSBzZXR0aW5nc1trZXldO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuX3RlbXBsYXRlLl9zdGF0ZUNoYW5nZWQodGhpcy5fbmFtZSk7XHJcbiAgICB9XHJcbiAgICBfYXBwbHkob3RoZXIsIHNlZW4pIHtcclxuICAgICAgICAkb2JqZWN0LmVhY2godGhpcy5fc2V0dGluZ3MsIChrZXksIHZhbHVlKSA9PiB7XHJcbiAgICAgICAgICAgIGlmICghc2VlbltrZXldICYmICFvdGhlci5fdXNlclNldHRpbmdzW2tleV0pIHtcclxuICAgICAgICAgICAgICAgIHNlZW5ba2V5XSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBvdGhlci5zZXRSYXcoa2V5LCB2YWx1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxufVxyXG5leHBvcnQgY2xhc3MgVGVtcGxhdGVTdGF0ZXMge1xyXG4gICAgY29uc3RydWN0b3IodGVtcGxhdGUpIHtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfdGVtcGxhdGVcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX3N0YXRlc1wiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiB7fVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuX3RlbXBsYXRlID0gdGVtcGxhdGU7XHJcbiAgICB9XHJcbiAgICBsb29rdXAobmFtZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9zdGF0ZXNbbmFtZV07XHJcbiAgICB9XHJcbiAgICBjcmVhdGUobmFtZSwgc2V0dGluZ3MpIHtcclxuICAgICAgICBjb25zdCBzdGF0ZSA9IHRoaXMuX3N0YXRlc1tuYW1lXTtcclxuICAgICAgICBpZiAoc3RhdGUpIHtcclxuICAgICAgICAgICAgc3RhdGUuc2V0QWxsKHNldHRpbmdzKTtcclxuICAgICAgICAgICAgcmV0dXJuIHN0YXRlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3Qgc3RhdGUgPSBuZXcgVGVtcGxhdGVTdGF0ZShuYW1lLCB0aGlzLl90ZW1wbGF0ZSwgc2V0dGluZ3MpO1xyXG4gICAgICAgICAgICB0aGlzLl9zdGF0ZXNbbmFtZV0gPSBzdGF0ZTtcclxuICAgICAgICAgICAgdGhpcy5fdGVtcGxhdGUuX3N0YXRlQ2hhbmdlZChuYW1lKTtcclxuICAgICAgICAgICAgcmV0dXJuIHN0YXRlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJlbW92ZShuYW1lKSB7XHJcbiAgICAgICAgZGVsZXRlIHRoaXMuX3N0YXRlc1tuYW1lXTtcclxuICAgICAgICB0aGlzLl90ZW1wbGF0ZS5fc3RhdGVDaGFuZ2VkKG5hbWUpO1xyXG4gICAgfVxyXG4gICAgX2FwcGx5KGVudGl0eSwgc3RhdGUpIHtcclxuICAgICAgICAkb2JqZWN0LmVhY2godGhpcy5fc3RhdGVzLCAoa2V5LCB2YWx1ZSkgPT4ge1xyXG4gICAgICAgICAgICBsZXQgc2VlbiA9IHN0YXRlLnN0YXRlc1trZXldO1xyXG4gICAgICAgICAgICBpZiAoc2VlbiA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBzZWVuID0gc3RhdGUuc3RhdGVzW2tleV0gPSB7fTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBvdGhlciA9IGVudGl0eS5zdGF0ZXMuY3JlYXRlKGtleSwge30pO1xyXG4gICAgICAgICAgICB2YWx1ZS5fYXBwbHkob3RoZXIsIHNlZW4pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydCBjbGFzcyBUZW1wbGF0ZUFkYXB0ZXJzIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9jYWxsYmFja3NcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZToge31cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGFkZChrZXksIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgbGV0IGNhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrc1trZXldO1xyXG4gICAgICAgIGlmIChjYWxsYmFja3MgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBjYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3Nba2V5XSA9IFtdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYWxsYmFja3MucHVzaChjYWxsYmFjayk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBEaXNwb3NlcigoKSA9PiB7XHJcbiAgICAgICAgICAgICRhcnJheS5yZW1vdmVGaXJzdChjYWxsYmFja3MsIGNhbGxiYWNrKTtcclxuICAgICAgICAgICAgaWYgKGNhbGxiYWNrcy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9jYWxsYmFja3Nba2V5XTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgcmVtb3ZlKGtleSkge1xyXG4gICAgICAgIGNvbnN0IGNhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrc1trZXldO1xyXG4gICAgICAgIGlmIChjYWxsYmFja3MgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBkZWxldGUgdGhpcy5fY2FsbGJhY2tzW2tleV07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgX2FwcGx5KGVudGl0eSkge1xyXG4gICAgICAgIGNvbnN0IGRpc3Bvc2VycyA9IFtdO1xyXG4gICAgICAgICRvYmplY3QuZWFjaCh0aGlzLl9jYWxsYmFja3MsIChrZXksIGNhbGxiYWNrcykgPT4ge1xyXG4gICAgICAgICAgICAkYXJyYXkuZWFjaChjYWxsYmFja3MsIChjYWxsYmFjaykgPT4ge1xyXG4gICAgICAgICAgICAgICAgZGlzcG9zZXJzLnB1c2goZW50aXR5LmFkYXB0ZXJzLmFkZChrZXksIGNhbGxiYWNrKSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBuZXcgTXVsdGlEaXNwb3NlcihkaXNwb3NlcnMpO1xyXG4gICAgfVxyXG59XHJcbi8vIFRPRE8gbWF5YmUgZXh0ZW5kIGZyb20gUHJvcGVydGllcyA/XHJcbmV4cG9ydCBjbGFzcyBUZW1wbGF0ZSB7XHJcbiAgICBjb25zdHJ1Y3RvcihzZXR0aW5ncywgaXNSZWFsKSB7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX3NldHRpbmdzXCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9wcml2YXRlU2V0dGluZ3NcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZToge31cclxuICAgICAgICB9KTtcclxuICAgICAgICAvLyBUT0RPIGNvZGUgZHVwbGljYXRpb24gd2l0aCBQcm9wZXJ0aWVzXHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX3NldHRpbmdFdmVudHNcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZToge31cclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfcHJpdmF0ZVNldHRpbmdFdmVudHNcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZToge31cclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfZW50aXRpZXNcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogW11cclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJzdGF0ZXNcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogbmV3IFRlbXBsYXRlU3RhdGVzKHRoaXMpXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiYWRhcHRlcnNcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogbmV3IFRlbXBsYXRlQWRhcHRlcnMoKVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImV2ZW50c1wiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiBuZXcgRXZlbnREaXNwYXRjaGVyKClcclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJzZXR1cFwiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcclxuICAgICAgICB9KTtcclxuICAgICAgICBpZiAoIWlzUmVhbCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJZb3UgY2Fubm90IHVzZSBgbmV3IENsYXNzKClgLCBpbnN0ZWFkIHVzZSBgQ2xhc3MubmV3KClgXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9zZXR0aW5ncyA9IHNldHRpbmdzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBVc2UgdGhpcyBtZXRob2QgdG8gY3JlYXRlIGFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MuXHJcbiAgICAgKlxyXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly93d3cuYW1jaGFydHMuY29tL2RvY3MvdjUvZ2V0dGluZy1zdGFydGVkLyNOZXdfZWxlbWVudF9zeW50YXh9IGZvciBtb3JlIGluZm9cclxuICAgICAqIEBwYXJhbSAgIHJvb3QgICAgICBSb290IGVsZW1lbnRcclxuICAgICAqIEBwYXJhbSAgIHNldHRpbmdzICBTZXR0aW5nc1xyXG4gICAgICogQHBhcmFtICAgdGVtcGxhdGUgIFRlbXBsYXRlXHJcbiAgICAgKiBAcmV0dXJuICAgICAgICAgICAgSW5zdGFudGlhdGVkIG9iamVjdFxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgbmV3KHNldHRpbmdzKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBUZW1wbGF0ZShzZXR0aW5ncywgdHJ1ZSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEFycmF5IG9mIGFsbCBlbnRpdGllcyB1c2luZyB0aGlzIHRlbXBsYXRlLlxyXG4gICAgICovXHJcbiAgICBnZXQgZW50aXRpZXMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2VudGl0aWVzO1xyXG4gICAgfVxyXG4gICAgZ2V0KGtleSwgZmFsbGJhY2spIHtcclxuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuX3NldHRpbmdzW2tleV07XHJcbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbGxiYWNrO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHNldFJhdyhrZXksIHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5fc2V0dGluZ3Nba2V5XSA9IHZhbHVlO1xyXG4gICAgfVxyXG4gICAgc2V0KGtleSwgdmFsdWUpIHtcclxuICAgICAgICBpZiAodGhpcy5fc2V0dGluZ3Nba2V5XSAhPT0gdmFsdWUpIHtcclxuICAgICAgICAgICAgdGhpcy5zZXRSYXcoa2V5LCB2YWx1ZSk7XHJcbiAgICAgICAgICAgIHRoaXMuX2VudGl0aWVzLmZvckVhY2goKGVudGl0eSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgZW50aXR5Ll9zZXRUZW1wbGF0ZVByb3BlcnR5KHRoaXMsIGtleSwgdmFsdWUpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZW1vdmUoa2V5KSB7XHJcbiAgICAgICAgaWYgKGtleSBpbiB0aGlzLl9zZXR0aW5ncykge1xyXG4gICAgICAgICAgICBkZWxldGUgdGhpcy5fc2V0dGluZ3Nba2V5XTtcclxuICAgICAgICAgICAgdGhpcy5fZW50aXRpZXMuZm9yRWFjaCgoZW50aXR5KSA9PiB7XHJcbiAgICAgICAgICAgICAgICBlbnRpdHkuX3JlbW92ZVRlbXBsYXRlUHJvcGVydHkoa2V5KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmVtb3ZlQWxsKCkge1xyXG4gICAgICAgICRvYmplY3QuZWFjaCh0aGlzLl9zZXR0aW5ncywgKGtleSwgX3ZhbHVlKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlKGtleSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBnZXRQcml2YXRlKGtleSwgZmFsbGJhY2spIHtcclxuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuX3ByaXZhdGVTZXR0aW5nc1trZXldO1xyXG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxsYmFjaztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBzZXRQcml2YXRlUmF3KGtleSwgdmFsdWUpIHtcclxuICAgICAgICB0aGlzLl9wcml2YXRlU2V0dGluZ3Nba2V5XSA9IHZhbHVlO1xyXG4gICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgIH1cclxuICAgIHNldFByaXZhdGUoa2V5LCB2YWx1ZSkge1xyXG4gICAgICAgIGlmICh0aGlzLl9wcml2YXRlU2V0dGluZ3Nba2V5XSAhPT0gdmFsdWUpIHtcclxuICAgICAgICAgICAgdGhpcy5zZXRQcml2YXRlUmF3KGtleSwgdmFsdWUpO1xyXG4gICAgICAgICAgICB0aGlzLl9lbnRpdGllcy5mb3JFYWNoKChlbnRpdHkpID0+IHtcclxuICAgICAgICAgICAgICAgIGVudGl0eS5fc2V0VGVtcGxhdGVQcml2YXRlUHJvcGVydHkodGhpcywga2V5LCB2YWx1ZSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICB9XHJcbiAgICByZW1vdmVQcml2YXRlKGtleSkge1xyXG4gICAgICAgIGlmIChrZXkgaW4gdGhpcy5fcHJpdmF0ZVNldHRpbmdzKSB7XHJcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9wcml2YXRlU2V0dGluZ3Nba2V5XTtcclxuICAgICAgICAgICAgdGhpcy5fZW50aXRpZXMuZm9yRWFjaCgoZW50aXR5KSA9PiB7XHJcbiAgICAgICAgICAgICAgICBlbnRpdHkuX3JlbW92ZVRlbXBsYXRlUHJpdmF0ZVByb3BlcnR5KGtleSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHNldEFsbCh2YWx1ZSkge1xyXG4gICAgICAgICRvYmplY3QuZWFjaCh2YWx1ZSwgKGtleSwgdmFsdWUpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5zZXQoa2V5LCB2YWx1ZSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvLyBUT0RPIGNvZGUgZHVwbGljYXRpb24gd2l0aCBQcm9wZXJ0aWVzXHJcbiAgICBvbihrZXksIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgbGV0IGV2ZW50cyA9IHRoaXMuX3NldHRpbmdFdmVudHNba2V5XTtcclxuICAgICAgICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgZXZlbnRzID0gdGhpcy5fc2V0dGluZ0V2ZW50c1trZXldID0gW107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGV2ZW50cy5wdXNoKGNhbGxiYWNrKTtcclxuICAgICAgICByZXR1cm4gbmV3IERpc3Bvc2VyKCgpID0+IHtcclxuICAgICAgICAgICAgJGFycmF5LnJlbW92ZUZpcnN0KGV2ZW50cywgY2FsbGJhY2spO1xyXG4gICAgICAgICAgICBpZiAoZXZlbnRzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuX3NldHRpbmdFdmVudHNba2V5XTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLy8gVE9ETyBjb2RlIGR1cGxpY2F0aW9uIHdpdGggUHJvcGVydGllc1xyXG4gICAgb25Qcml2YXRlKGtleSwgY2FsbGJhY2spIHtcclxuICAgICAgICBsZXQgZXZlbnRzID0gdGhpcy5fcHJpdmF0ZVNldHRpbmdFdmVudHNba2V5XTtcclxuICAgICAgICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgZXZlbnRzID0gdGhpcy5fcHJpdmF0ZVNldHRpbmdFdmVudHNba2V5XSA9IFtdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBldmVudHMucHVzaChjYWxsYmFjayk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBEaXNwb3NlcigoKSA9PiB7XHJcbiAgICAgICAgICAgICRhcnJheS5yZW1vdmVGaXJzdChldmVudHMsIGNhbGxiYWNrKTtcclxuICAgICAgICAgICAgaWYgKGV2ZW50cy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9wcml2YXRlU2V0dGluZ0V2ZW50c1trZXldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBfYXBwbHkoZW50aXR5LCBzdGF0ZSkge1xyXG4gICAgICAgIGNvbnN0IGRpc3Bvc2VycyA9IFtdO1xyXG4gICAgICAgICRvYmplY3QuZWFjaCh0aGlzLl9zZXR0aW5nRXZlbnRzLCAoa2V5LCBldmVudHMpID0+IHtcclxuICAgICAgICAgICAgJGFycmF5LmVhY2goZXZlbnRzLCAoZXZlbnQpID0+IHtcclxuICAgICAgICAgICAgICAgIGRpc3Bvc2Vycy5wdXNoKGVudGl0eS5vbihrZXksIGV2ZW50KSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgICRvYmplY3QuZWFjaCh0aGlzLl9wcml2YXRlU2V0dGluZ0V2ZW50cywgKGtleSwgZXZlbnRzKSA9PiB7XHJcbiAgICAgICAgICAgICRhcnJheS5lYWNoKGV2ZW50cywgKGV2ZW50KSA9PiB7XHJcbiAgICAgICAgICAgICAgICBkaXNwb3NlcnMucHVzaChlbnRpdHkub25Qcml2YXRlKGtleSwgZXZlbnQpKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5zdGF0ZXMuX2FwcGx5KGVudGl0eSwgc3RhdGUpO1xyXG4gICAgICAgIGRpc3Bvc2Vycy5wdXNoKHRoaXMuYWRhcHRlcnMuX2FwcGx5KGVudGl0eSkpO1xyXG4gICAgICAgIGRpc3Bvc2Vycy5wdXNoKGVudGl0eS5ldmVudHMuY29weUZyb20odGhpcy5ldmVudHMpKTtcclxuICAgICAgICByZXR1cm4gbmV3IE11bHRpRGlzcG9zZXIoZGlzcG9zZXJzKTtcclxuICAgIH1cclxuICAgIF9zZXRPYmplY3RUZW1wbGF0ZShlbnRpdHkpIHtcclxuICAgICAgICB0aGlzLl9lbnRpdGllcy5wdXNoKGVudGl0eSk7XHJcbiAgICB9XHJcbiAgICBfcmVtb3ZlT2JqZWN0VGVtcGxhdGUoZW50aXR5KSB7XHJcbiAgICAgICAgJGFycmF5LnJlbW92ZSh0aGlzLl9lbnRpdGllcywgZW50aXR5KTtcclxuICAgIH1cclxuICAgIF9zdGF0ZUNoYW5nZWQobmFtZSkge1xyXG4gICAgICAgIHRoaXMuX2VudGl0aWVzLmZvckVhY2goKGVudGl0eSkgPT4ge1xyXG4gICAgICAgICAgICBlbnRpdHkuX2FwcGx5U3RhdGVCeUtleShuYW1lKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1UZW1wbGF0ZS5qcy5tYXAiLCJpbXBvcnQgeyBDb2xvciB9IGZyb20gXCIuL0NvbG9yXCI7XHJcbmltcG9ydCAqIGFzICR0eXBlIGZyb20gXCIuL1R5cGVcIjtcclxuZXhwb3J0IGNsYXNzIFRleHRGb3JtYXR0ZXIge1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZXBsYWNlcyBicmFja2V0cyB3aXRoIHRlbXBvcmFyeSBwbGFjZWhvbGRlcnMuXHJcbiAgICAgKlxyXG4gICAgICogQGlnbm9yZSBFeGNsdWRlIGZyb20gZG9jc1xyXG4gICAgICogQHBhcmFtIHRleHQgIElucHV0IHRleHRcclxuICAgICAqIEByZXR1cm4gRXNjYXBlZCB0ZXh0XHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBlc2NhcGUodGV4dCkge1xyXG4gICAgICAgIHJldHVybiB0ZXh0LlxyXG4gICAgICAgICAgICByZXBsYWNlKC9cXFtcXFsvZywgdGhpcy5wcmVmaXggKyBcIjFcIikuXHJcbiAgICAgICAgICAgIHJlcGxhY2UoLyhbXlxcL1xcXV17MX0pXFxdXFxdL2csIFwiJDFcIiArIHRoaXMucHJlZml4ICsgXCIyXCIpLlxyXG4gICAgICAgICAgICByZXBsYWNlKC9cXF1cXF0vZywgdGhpcy5wcmVmaXggKyBcIjJcIikuXHJcbiAgICAgICAgICAgIHJlcGxhY2UoL1xce1xcey9nLCB0aGlzLnByZWZpeCArIFwiM1wiKS5cclxuICAgICAgICAgICAgcmVwbGFjZSgvXFx9XFx9L2csIHRoaXMucHJlZml4ICsgXCI0XCIpLlxyXG4gICAgICAgICAgICByZXBsYWNlKC9cXCdcXCcvZywgdGhpcy5wcmVmaXggKyBcIjVcIik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJlcGxhY2VzIHBsYWNlaG9sZGVycyBiYWNrIHRvIGJyYWNrZXRzLlxyXG4gICAgICpcclxuICAgICAqIEBpZ25vcmUgRXhjbHVkZSBmcm9tIGRvY3NcclxuICAgICAqIEBwYXJhbSB0ZXh0ICBFc2NhcGVkIHRleHRcclxuICAgICAqIEByZXR1cm4gVW5lc2NhcGVkIHRleHRcclxuICAgICAqL1xyXG4gICAgc3RhdGljIHVuZXNjYXBlKHRleHQpIHtcclxuICAgICAgICByZXR1cm4gdGV4dC5cclxuICAgICAgICAgICAgcmVwbGFjZShuZXcgUmVnRXhwKHRoaXMucHJlZml4ICsgXCIxXCIsIFwiZ1wiKSwgXCJbW1wiKS5cclxuICAgICAgICAgICAgcmVwbGFjZShuZXcgUmVnRXhwKHRoaXMucHJlZml4ICsgXCIyXCIsIFwiZ1wiKSwgXCJdXVwiKS5cclxuICAgICAgICAgICAgcmVwbGFjZShuZXcgUmVnRXhwKHRoaXMucHJlZml4ICsgXCIzXCIsIFwiZ1wiKSwgXCJ7e1wiKS5cclxuICAgICAgICAgICAgcmVwbGFjZShuZXcgUmVnRXhwKHRoaXMucHJlZml4ICsgXCI0XCIsIFwiZ1wiKSwgXCJ9fVwiKS5cclxuICAgICAgICAgICAgcmVwbGFjZShuZXcgUmVnRXhwKHRoaXMucHJlZml4ICsgXCI1XCIsIFwiZ1wiKSwgXCInJ1wiKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ2xlYW5zIHVwIHRoZSB0ZXh0IHRleHQgZm9yIGxlZnRvdmVyIGRvdWJsZSBzcXVhcmUgYnJhY2tldHMuXHJcbiAgICAgKlxyXG4gICAgICogQGlnbm9yZSBFeGNsdWRlIGZyb20gZG9jc1xyXG4gICAgICogQHBhcmFtIHRleHQgIElucHV0IHRleHRcclxuICAgICAqIEByZXR1cm4gQ2xlYW5lZCB1cCB0ZXh0XHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBjbGVhblVwKHRleHQpIHtcclxuICAgICAgICByZXR1cm4gdGV4dC5cclxuICAgICAgICAgICAgcmVwbGFjZSgvXFxbXFxbL2csIFwiW1wiKS5cclxuICAgICAgICAgICAgcmVwbGFjZSgvXFxdXFxdL2csIFwiXVwiKS5cclxuICAgICAgICAgICAgcmVwbGFjZSgvXFx7XFx7L2csIFwie1wiKS5cclxuICAgICAgICAgICAgcmVwbGFjZSgvXFx9XFx9L2csIFwifVwiKS5cclxuICAgICAgICAgICAgcmVwbGFjZSgvXFwnXFwnL2csIFwiJ1wiKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU3BsaXRzIHN0cmluZyBpbnRvIGNodW5rcy4gKHN0eWxlIGJsb2NrcywgcXVvdGVkIGJsb2NrcywgcmVndWxhciBibG9ja3MpXHJcbiAgICAgKlxyXG4gICAgICogSWYgdGhlIHNlY29uZCBwYXJhbWV0ZXIgYHF1b3RlZEJsb2Nrc2AgaXMgc2V0IHRvIGB0cnVlYCB0aGlzIG1ldGhvZCB3aWxsXHJcbiAgICAgKiBhbHNvIHNpbmdsZSBvdXQgdGV4dCBibG9ja3MgZW5jbG9zZWQgd2l0aGluIHNpbmdsZSBxdW90ZXMgdGhhdCBub1xyXG4gICAgICogZm9ybWF0dGluZyBzaG91bGQgYmUgYXBwbGllZCB0bywgYW5kIHRoZXkgc2hvdWxkIGJlIGRpc3BsYXllZCBhcyBpcy5cclxuICAgICAqXHJcbiAgICAgKiBEZWZhdWx0IGZvciB0aGUgYWJvdmUgaXMgYGZhbHNlYCwgc28gdGhhdCB5b3UgY2FuIHVzZSBzaW5nbGUgcXVvdGUgaW4gdGV4dFxyXG4gICAgICogd2l0aG91dCBlc2NhcGluZyBpdC5cclxuICAgICAqXHJcbiAgICAgKiBJZiBlbmFibGVkLCBzaW5nbGUgcXVvdGVzIGNhbiBiZSBlc2NhcGVkIGJ5IGRvdWJsaW5nIGl0IC0gYWRkaW5nIHR3b1xyXG4gICAgICogc2luZ2xlIHF1b3Rlcywgd2hpY2ggd2lsbCBiZSByZXBsYWNlZCBieSBhIG9uZSBzaW5nbGUgcXVvdGUgaW4gdGhlIGZpbmFsXHJcbiAgICAgKiBvdXRwdXQuXHJcbiAgICAgKlxyXG4gICAgICogQGlnbm9yZSBFeGNsdWRlIGZyb20gZG9jc1xyXG4gICAgICogQHBhcmFtIHRleHQgICAgICAgICAgVGV4dCB0byBjaHVua1xyXG4gICAgICogQHBhcmFtIHF1b3RlZEJsb2NrcyAgVXNlIHF1b3RlZCBibG9ja3NcclxuICAgICAqIEBwYXJhbSBub0Zvcm1hdHRpbmcgIEZvcm1hdHRpbmcgYmxvY2tzIHdpbGwgYmUgdHJlYXRlZCBhcyByZWd1bGFyIHRleHRcclxuICAgICAqIEByZXR1cm4gQXJyYXkgb2Ygc3RyaW5nIGNodW5rc1xyXG4gICAgICovXHJcbiAgICBzdGF0aWMgY2h1bmsodGV4dCwgcXVvdGVkQmxvY2tzID0gZmFsc2UsIG5vRm9ybWF0dGluZyA9IGZhbHNlKSB7XHJcbiAgICAgICAgLy8gSW5pdCByZXN1bHRcclxuICAgICAgICBsZXQgcmVzID0gW107XHJcbiAgICAgICAgLy8gUmVwbGFjZSBkb3VibGUgKGVzY2FwZWQpIHNxdWFyZSBzcGFjZXMgYW5kIHF1b3RlcyB3aXRoIHRlbXBvcmFyeSBjb2Rlc1xyXG4gICAgICAgIHRleHQgPSB0aGlzLmVzY2FwZSh0ZXh0KTtcclxuICAgICAgICAvLyBEZWFsIHdpdGggc3R5bGUgYmxvY2tzXHJcbiAgICAgICAgbGV0IGNodW5rcyA9IHF1b3RlZEJsb2NrcyA/IHRleHQuc3BsaXQoXCInXCIpIDogW3RleHRdO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2h1bmtzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGxldCBjaHVuayA9IGNodW5rc1tpXTtcclxuICAgICAgICAgICAgLy8gRW1wdHk/XHJcbiAgICAgICAgICAgIGlmIChjaHVuayA9PT0gXCJcIikge1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKChpICUgMikgPT09IDApIHtcclxuICAgICAgICAgICAgICAgIC8vIFRleHQgb3V0c2lkZSBxdW90ZXNcclxuICAgICAgICAgICAgICAgIC8vIFBhcnNlIGZvciBzdHlsZSBibG9ja3Mgd2hpY2ggYXJlIFwidGV4dFwiIGNodW5rcywgdGhlIHJlc3QgY2h1bmtzIGFyZVxyXG4gICAgICAgICAgICAgICAgLy8gXCJ2YWx1ZVwiXHJcbiAgICAgICAgICAgICAgICBjaHVuayA9IGNodW5rLnJlcGxhY2UoL1xcXVxcWy9nLCBcIl1cIiArICR0eXBlLlBMQUNFSE9MREVSICsgXCJbXCIpO1xyXG4gICAgICAgICAgICAgICAgY2h1bmsgPSBjaHVuay5yZXBsYWNlKC9cXFtcXF0vZywgXCJbIF1cIik7XHJcbiAgICAgICAgICAgICAgICBsZXQgY2h1bmtzMiA9IGNodW5rLnNwbGl0KC9bXFxbXFxdXSsvKTtcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkyID0gMDsgaTIgPCBjaHVua3MyLmxlbmd0aDsgaTIrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBjaHVuazIgPSB0aGlzLmNsZWFuVXAodGhpcy51bmVzY2FwZShjaHVua3MyW2kyXSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFBsYWNlaG9sZGVyP1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjaHVuazIgPT09ICR0eXBlLlBMQUNFSE9MREVSKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAvLyBFbXB0eT9cclxuICAgICAgICAgICAgICAgICAgICBpZiAoY2h1bmsyID09PSBcIlwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAvLyBCbG9jayBvciB2YWx1ZVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICgoaTIgJSAyKSA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJ2YWx1ZVwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJ0ZXh0XCI6IGNodW5rMlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcy5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwidHlwZVwiOiBub0Zvcm1hdHRpbmcgPyBcInZhbHVlXCIgOiBcImZvcm1hdFwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJ0ZXh0XCI6IFwiW1wiICsgY2h1bmsyICsgXCJdXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gQSB0ZXh0IHdpdGhpbiBkb3VibGVxdW90ZXNcclxuICAgICAgICAgICAgICAgIC8vIEFsbCBjaHVua3MgYXJlIFwidGV4dFwiXHJcbiAgICAgICAgICAgICAgICBsZXQgY2h1bmtzMiA9IGNodW5rLnNwbGl0KC9bXFxbXFxdXSsvKTtcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkyID0gMDsgaTIgPCBjaHVua3MyLmxlbmd0aDsgaTIrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBjaHVuazIgPSB0aGlzLmNsZWFuVXAodGhpcy51bmVzY2FwZShjaHVua3MyW2kyXSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIEVtcHR5P1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjaHVuazIgPT09IFwiXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIEJsb2NrIG9yIHRleHRcclxuICAgICAgICAgICAgICAgICAgICBpZiAoKGkyICUgMikgPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwidGV4dFwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJ0ZXh0XCI6IGNodW5rMlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5pc0ltYWdlKGNodW5rMikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiaW1hZ2VcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwidGV4dFwiOiBcIltcIiArIGNodW5rMiArIFwiXVwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiZm9ybWF0XCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInRleHRcIjogXCJbXCIgKyBjaHVuazIgKyBcIl1cIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlcztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ2hlY2tzIGlmIHN1cHBsaWVkIGZvcm1hdCBjb250YWlucyBpbWFnZSBpbmZvcm1hdGlvbiBhbmQgc2hvdWxkIGJlXHJcbiAgICAgKiBmb3JtYXR0ZWQgYXMgc3VjaC5cclxuICAgICAqIEkuZS46IGBbaW1nOiBteUltYWdlLnBuZ11gXHJcbiAgICAgKlxyXG4gICAgICogQGlnbm9yZVxyXG4gICAgICogQHBhcmFtICB0ZXh0ICBGb3JtYXRcclxuICAgICAqIEByZXR1cm4gdHJ1ZSBpZiBpdCBpcyBhbiBpbWFnZVxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgaXNJbWFnZSh0ZXh0KSB7XHJcbiAgICAgICAgcmV0dXJuIHRleHQubWF0Y2goL2ltZ1sgXT86LykgPyB0cnVlIDogZmFsc2U7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgZ2V0VGV4dFN0eWxlKHN0eWxlKSB7XHJcbiAgICAgICAgLy8gbGV0IHRleHRTdHlsZTogc3RyaW5nW10gPSBbXTtcclxuICAgICAgICAvLyBsZXQgdGV4dEZpbGw6IHN0cmluZyB8IHVuZGVmaW5lZDtcclxuICAgICAgICBsZXQgZm9ybWF0ID0ge307XHJcbiAgICAgICAgaWYgKHN0eWxlID09IFwiXCIgfHwgc3R5bGUgPT0gXCJbIF1cIikge1xyXG4gICAgICAgICAgICByZXR1cm4ge307XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFByZS1wcm9jZXNzIHF1b3RlZCB0ZXh0XHJcbiAgICAgICAgY29uc3QgcSA9IHN0eWxlLm1hdGNoKC8oJ1teJ10qJyl8KFwiW15cIl0qXCIpL2dpKTtcclxuICAgICAgICBpZiAocSkge1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHEubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHN0eWxlID0gc3R5bGUucmVwbGFjZShxW2ldLCBxW2ldLnJlcGxhY2UoL1snXCJdKi9nLCBcIlwiKS5yZXBsYWNlKC9bIF0rL2csIFwiK1wiKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gR2V0IHN0eWxlIHBhcnRzXHJcbiAgICAgICAgbGV0IGIgPSBzdHlsZS5tYXRjaCgvKFtcXHdcXC1dKjpbXFxzXT9bXjtcXHNcXF1dKil8KFxcI1tcXHddezEsNn0pfChbXFx3XFwtXSspfChcXC8pL2dpKTtcclxuICAgICAgICAvLyBFbXB0eT9cclxuICAgICAgICBpZiAoIWIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHt9O1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBDaGVjayBlYWNoIHBhcnRcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGIubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKGJbaV0ubWF0Y2goL14obm9ybWFsfGJvbGR8Ym9sZGVyfGxpZ2h0ZXJ8MTAwfDIwMHwzMDB8NDAwfDUwMHw2MDB8NzAwfDgwMHw5MDApJC9pKSkge1xyXG4gICAgICAgICAgICAgICAgZm9ybWF0LmZvbnRXZWlnaHQgPSBiW2ldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGJbaV0ubWF0Y2goL14odW5kZXJsaW5lfGxpbmUtdGhyb3VnaCkkL2kpKSB7XHJcbiAgICAgICAgICAgICAgICBmb3JtYXQudGV4dERlY29yYXRpb24gPSBiW2ldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGJbaV0gPT0gXCIvXCIpIHtcclxuICAgICAgICAgICAgICAgIC8vIEp1c3QgY2xvc2luZyB0YWdcclxuICAgICAgICAgICAgICAgIC8vIERvIG5vdGhpbmdcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICghYltpXS5tYXRjaCgvOi8pKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBDb2xvclxyXG4gICAgICAgICAgICAgICAgZm9ybWF0LmZpbGwgPSBDb2xvci5mcm9tU3RyaW5nKGJbaV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcCA9IGJbaV0ucmVwbGFjZShcIitcIiwgXCIgXCIpLnNwbGl0KC86WyBdKi8pO1xyXG4gICAgICAgICAgICAgICAgZm9ybWF0W3BbMF1dID0gcFsxXTtcclxuICAgICAgICAgICAgICAgIC8vdGV4dFN0eWxlLnB1c2goYltpXS5yZXBsYWNlKC9eW2EtekEtWl06WyBdKi8sIFwiXCIpKTtcclxuICAgICAgICAgICAgICAgIC8vYltpXSA9IGJbaV0ucmVwbGFjZSgvXFwrL2csIFwiIFwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZm9ybWF0O1xyXG4gICAgfVxyXG59XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShUZXh0Rm9ybWF0dGVyLCBcInByZWZpeFwiLCB7XHJcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICB2YWx1ZTogXCJfX2FtY2hhcnRzX19cIlxyXG59KTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VGV4dEZvcm1hdHRlci5qcy5tYXAiLCIvKipcclxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4gKiBJTVBPUlRTXHJcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICogQGhpZGRlblxyXG4gKi9cclxuaW1wb3J0ICogYXMgJHR5cGUgZnJvbSBcIi4vVHlwZVwiO1xyXG5pbXBvcnQgKiBhcyAkdXRpbHMgZnJvbSBcIi4vVXRpbHNcIjtcclxuLyoqXHJcbiAqIFJldHVybnMgYSBgUHJvbWlzZWAgd2hpY2ggY2FuIGJlIHVzZWQgdG8gZXhlY3V0ZSBjb2RlIGFmdGVyIG51bWJlciBvZlxyXG4gKiBtaWxsaXNlY29uZHMuXHJcbiAqXHJcbiAqIEBwYXJhbSAgIG1zICBTbGVlcCBkdXJhdGlvbiBpbiBtc1xyXG4gKiBAcmV0dXJuICAgICAgUHJvbWlzZVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHNsZWVwKG1zKSB7XHJcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIF9yZWplY3QpID0+IHtcclxuICAgICAgICBzZXRUaW1lb3V0KHJlc29sdmUsIG1zKTtcclxuICAgIH0pO1xyXG59XHJcbi8qKlxyXG4gKiBNYXBzIHRpbWUgcGVyaW9kIG5hbWVzIHRvIHRoZWlyIG51bWVyaWMgcmVwcmVzZW50YXRpb25zIGluIG1pbGxpc2Vjb25kcy5cclxuICpcclxuICogQGlnbm9yZSBFeGNsdWRlIGZyb20gZG9jc1xyXG4gKi9cclxuZXhwb3J0IGxldCB0aW1lVW5pdER1cmF0aW9ucyA9IHtcclxuICAgIG1pbGxpc2Vjb25kOiAxLFxyXG4gICAgc2Vjb25kOiAxMDAwLFxyXG4gICAgbWludXRlOiA2MDAwMCxcclxuICAgIGhvdXI6IDM2MDAwMDAsXHJcbiAgICBkYXk6IDg2NDAwMDAwLFxyXG4gICAgd2VlazogNjA0ODAwMDAwLFxyXG4gICAgbW9udGg6IDM2NS4yNDIgLyAxMiAqIDg2NDAwMDAwLFxyXG4gICAgeWVhcjogMzE1MzYwMDAwMDBcclxufTtcclxuLyoqXHJcbiAqIFJldHVybnMgdGhlIG5leHQgdGltZSB1bml0IHRoYXQgZ29lcyBhZnRlciBzb3VyY2UgYHVuaXRgLlxyXG4gKlxyXG4gKiBFLmcuIFwiaG91clwiIGlzIHRoZSBuZXh0IHVuaXQgYWZ0ZXIgXCJtaW51dGVcIiwgZXRjLlxyXG4gKlxyXG4gKiBAaWdub3JlIEV4Y2x1ZGUgZnJvbSBkb2NzXHJcbiAqIEBwYXJhbSB1bml0ICBTb3VyY2UgdGltZSB1bml0XHJcbiAqIEByZXR1cm4gTmV4dCB0aW1lIHVuaXRcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXROZXh0VW5pdCh1bml0KSB7XHJcbiAgICBzd2l0Y2ggKHVuaXQpIHtcclxuICAgICAgICBjYXNlIFwieWVhclwiOlxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgY2FzZSBcIm1vbnRoXCI6XHJcbiAgICAgICAgICAgIHJldHVybiBcInllYXJcIjtcclxuICAgICAgICBjYXNlIFwid2Vla1wiOlxyXG4gICAgICAgICAgICByZXR1cm4gXCJtb250aFwiO1xyXG4gICAgICAgIGNhc2UgXCJkYXlcIjpcclxuICAgICAgICAgICAgcmV0dXJuIFwibW9udGhcIjsgLy8gbm90IGEgbWlzdGFrZVxyXG4gICAgICAgIGNhc2UgXCJob3VyXCI6XHJcbiAgICAgICAgICAgIHJldHVybiBcImRheVwiO1xyXG4gICAgICAgIGNhc2UgXCJtaW51dGVcIjpcclxuICAgICAgICAgICAgcmV0dXJuIFwiaG91clwiO1xyXG4gICAgICAgIGNhc2UgXCJzZWNvbmRcIjpcclxuICAgICAgICAgICAgcmV0dXJuIFwibWludXRlXCI7XHJcbiAgICAgICAgY2FzZSBcIm1pbGxpc2Vjb25kXCI6XHJcbiAgICAgICAgICAgIHJldHVybiBcInNlY29uZFwiO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm5zIG51bWJlciBvZiBtaWxsaXNlY29uZHMgaW4gdGhlIGBjb3VudGAgb2YgdGltZSBgdW5pdGAuXHJcbiAqXHJcbiAqIEF2YWlsYWJsZSB1bml0czogXCJtaWxsaXNlY29uZFwiLCBcInNlY29uZFwiLCBcIm1pbnV0ZVwiLCBcImhvdXJcIiwgXCJkYXlcIiwgXCJ3ZWVrXCIsXHJcbiAqIFwibW9udGhcIiwgYW5kIFwieWVhclwiLlxyXG4gKlxyXG4gKiBAcGFyYW0gdW5pdCAgIFRpbWUgdW5pdFxyXG4gKiBAcGFyYW0gY291bnQgIE51bWJlciBvZiB1bml0c1xyXG4gKiBAcmV0dXJuIE1pbGxpc2Vjb25kc1xyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGdldER1cmF0aW9uKHVuaXQsIGNvdW50KSB7XHJcbiAgICBpZiAoY291bnQgPT0gbnVsbCkge1xyXG4gICAgICAgIGNvdW50ID0gMTtcclxuICAgIH1cclxuICAgIHJldHVybiB0aW1lVW5pdER1cmF0aW9uc1t1bml0XSAqIGNvdW50O1xyXG59XHJcbi8qKlxyXG4gKiBAaWdub3JlXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ2V0SW50ZXJ2YWxEdXJhdGlvbihpbnRlcnZhbCkge1xyXG4gICAgaWYgKGludGVydmFsKSB7XHJcbiAgICAgICAgcmV0dXJuIHRpbWVVbml0RHVyYXRpb25zW2ludGVydmFsLnRpbWVVbml0XSAqIGludGVydmFsLmNvdW50O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIDA7XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIGdldERhdGVJbnRlcnZhbER1cmF0aW9uKGludGVydmFsLCBkYXRlLCBmaXJzdERhdGVPZldlZWssIHV0YywgdGltZXpvbmUpIHtcclxuICAgIGNvbnN0IHVuaXQgPSBpbnRlcnZhbC50aW1lVW5pdDtcclxuICAgIGNvbnN0IGNvdW50ID0gaW50ZXJ2YWwuY291bnQ7XHJcbiAgICBpZiAodW5pdCA9PSBcImhvdXJcIiB8fCB1bml0ID09IFwibWludXRlXCIgfHwgdW5pdCA9PSBcInNlY29uZFwiIHx8IHVuaXQgPT0gXCJtaWxsaXNlY29uZFwiKSB7XHJcbiAgICAgICAgcmV0dXJuIHRpbWVVbml0RHVyYXRpb25zW2ludGVydmFsLnRpbWVVbml0XSAqIGludGVydmFsLmNvdW50O1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgY29uc3QgZmlyc3RUaW1lID0gcm91bmQobmV3IERhdGUoZGF0ZS5nZXRUaW1lKCkpLCB1bml0LCBjb3VudCwgZmlyc3REYXRlT2ZXZWVrLCB1dGMsIHVuZGVmaW5lZCwgdGltZXpvbmUpLmdldFRpbWUoKTtcclxuICAgICAgICBsZXQgbGFzdFRpbWUgPSBmaXJzdFRpbWUgKyBjb3VudCAqIGdldER1cmF0aW9uKHVuaXQpICogMS4wNTtcclxuICAgICAgICBsYXN0VGltZSA9IHJvdW5kKG5ldyBEYXRlKGxhc3RUaW1lKSwgdW5pdCwgMSwgZmlyc3REYXRlT2ZXZWVrLCB1dGMsIHVuZGVmaW5lZCwgdGltZXpvbmUpLmdldFRpbWUoKTtcclxuICAgICAgICByZXR1cm4gbGFzdFRpbWUgLSBmaXJzdFRpbWU7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybnMgY3VycmVudCBgRGF0ZWAgb2JqZWN0LlxyXG4gKlxyXG4gKiBAcmV0dXJuIEN1cnJlbnQgZGF0ZVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIG5vdygpIHtcclxuICAgIHJldHVybiBuZXcgRGF0ZSgpO1xyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm5zIGN1cnJlbnQgdGltZXN0YW1wLlxyXG4gKlxyXG4gKiBAcmV0dXJuIEN1cnJlbnQgdGltZXN0YW1wXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ2V0VGltZSgpIHtcclxuICAgIHJldHVybiBub3coKS5nZXRUaW1lKCk7XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybnMgYSBjb3B5IG9mIHRoZSBgRGF0ZWAgb2JqZWN0LlxyXG4gKlxyXG4gKiBAcGFyYW0gZGF0ZSAgU291cmNlIGRhdGVcclxuICogQHJldHVybiBDb3B5XHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gY29weShkYXRlKSB7XHJcbiAgICByZXR1cm4gbmV3IERhdGUoZGF0ZS5nZXRUaW1lKCkpOyAvLyB0b2RvOiBjaGVjayBpZiB0aGlzIGlzIG9rLiBuZXcgRGF0ZShkYXRlKSB1c2VkIHRvIHN0cmlwIG1pbGxpc2Vjb25kcyBvbiBGRiBpbiB2M1xyXG59XHJcbi8qKlxyXG4gKiBDaGVja3MgaWYgdGhlIGB1bml0YCBwYXJ0IG9mIHR3byBgRGF0ZWAgb2JqZWN0cyBkbyBub3QgbWF0Y2guIFR3byBkYXRlc1xyXG4gKiByZXByZXNlbnQgYSBcInJhbmdlXCIgb2YgdGltZSwgcmF0aGVyIHRoZSBzYW1lIHRpbWUgZGF0ZS5cclxuICpcclxuICogQHBhcmFtIHRpbWVPbmUgIHRpbWVzdGFtcFxyXG4gKiBAcGFyYW0gdGltZVR3byAgdGltZXN0YW1wXHJcbiAqIEBwYXJhbSB1bml0ICAgICBUaW1lIHVuaXQgdG8gY2hlY2tcclxuICogQHJldHVybiBSYW5nZT9cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBjaGVja0NoYW5nZSh0aW1lT25lLCB0aW1lVHdvLCB1bml0LCB1dGMsIHRpbWV6b25lKSB7XHJcbiAgICAvLyBxdWlja1xyXG4gICAgaWYgKCh0aW1lVHdvIC0gdGltZU9uZSkgPiBnZXREdXJhdGlvbih1bml0LCAxLjIpKSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICBsZXQgZGF0ZU9uZSA9IG5ldyBEYXRlKHRpbWVPbmUpO1xyXG4gICAgbGV0IGRhdGVUd28gPSBuZXcgRGF0ZSh0aW1lVHdvKTtcclxuICAgIGlmICh0aW1lem9uZSkge1xyXG4gICAgICAgIGRhdGVPbmUgPSB0aW1lem9uZS5jb252ZXJ0TG9jYWwoZGF0ZU9uZSk7XHJcbiAgICAgICAgZGF0ZVR3byA9IHRpbWV6b25lLmNvbnZlcnRMb2NhbChkYXRlVHdvKTtcclxuICAgIH1cclxuICAgIGxldCB0aW1lWm9uZU9mZnNldDEgPSAwO1xyXG4gICAgbGV0IHRpbWVab25lT2Zmc2V0MiA9IDA7XHJcbiAgICBpZiAoIXV0YyAmJiB1bml0ICE9IFwibWlsbGlzZWNvbmRcIikge1xyXG4gICAgICAgIHRpbWVab25lT2Zmc2V0MSA9IGRhdGVPbmUuZ2V0VGltZXpvbmVPZmZzZXQoKTtcclxuICAgICAgICBkYXRlT25lLnNldFVUQ01pbnV0ZXMoZGF0ZU9uZS5nZXRVVENNaW51dGVzKCkgLSB0aW1lWm9uZU9mZnNldDEpO1xyXG4gICAgICAgIHRpbWVab25lT2Zmc2V0MiA9IGRhdGVUd28uZ2V0VGltZXpvbmVPZmZzZXQoKTtcclxuICAgICAgICBkYXRlVHdvLnNldFVUQ01pbnV0ZXMoZGF0ZVR3by5nZXRVVENNaW51dGVzKCkgLSB0aW1lWm9uZU9mZnNldDIpO1xyXG4gICAgfVxyXG4gICAgbGV0IGNoYW5nZWQgPSBmYWxzZTtcclxuICAgIHN3aXRjaCAodW5pdCkge1xyXG4gICAgICAgIGNhc2UgXCJ5ZWFyXCI6XHJcbiAgICAgICAgICAgIGlmIChkYXRlT25lLmdldFVUQ0Z1bGxZZWFyKCkgIT0gZGF0ZVR3by5nZXRVVENGdWxsWWVhcigpKSB7XHJcbiAgICAgICAgICAgICAgICBjaGFuZ2VkID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIFwibW9udGhcIjpcclxuICAgICAgICAgICAgaWYgKGRhdGVPbmUuZ2V0VVRDRnVsbFllYXIoKSAhPSBkYXRlVHdvLmdldFVUQ0Z1bGxZZWFyKCkpIHtcclxuICAgICAgICAgICAgICAgIGNoYW5nZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGRhdGVPbmUuZ2V0VVRDTW9udGgoKSAhPSBkYXRlVHdvLmdldFVUQ01vbnRoKCkpIHtcclxuICAgICAgICAgICAgICAgIGNoYW5nZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgXCJkYXlcIjpcclxuICAgICAgICAgICAgaWYgKGRhdGVPbmUuZ2V0VVRDTW9udGgoKSAhPSBkYXRlVHdvLmdldFVUQ01vbnRoKCkpIHtcclxuICAgICAgICAgICAgICAgIGNoYW5nZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGRhdGVPbmUuZ2V0VVRDRGF0ZSgpICE9IGRhdGVUd28uZ2V0VVRDRGF0ZSgpKSB7XHJcbiAgICAgICAgICAgICAgICBjaGFuZ2VkID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIFwiaG91clwiOlxyXG4gICAgICAgICAgICBpZiAoZGF0ZU9uZS5nZXRVVENIb3VycygpICE9IGRhdGVUd28uZ2V0VVRDSG91cnMoKSkge1xyXG4gICAgICAgICAgICAgICAgY2hhbmdlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBcIm1pbnV0ZVwiOlxyXG4gICAgICAgICAgICBpZiAoZGF0ZU9uZS5nZXRVVENNaW51dGVzKCkgIT0gZGF0ZVR3by5nZXRVVENNaW51dGVzKCkpIHtcclxuICAgICAgICAgICAgICAgIGNoYW5nZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgXCJzZWNvbmRcIjpcclxuICAgICAgICAgICAgaWYgKGRhdGVPbmUuZ2V0VVRDU2Vjb25kcygpICE9IGRhdGVUd28uZ2V0VVRDU2Vjb25kcygpKSB7XHJcbiAgICAgICAgICAgICAgICBjaGFuZ2VkID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIFwibWlsbGlzZWNvbmRcIjpcclxuICAgICAgICAgICAgaWYgKGRhdGVPbmUuZ2V0VGltZSgpICE9IGRhdGVUd28uZ2V0VGltZSgpKSB7XHJcbiAgICAgICAgICAgICAgICBjaGFuZ2VkID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBicmVhaztcclxuICAgIH1cclxuICAgIGlmIChjaGFuZ2VkKSB7XHJcbiAgICAgICAgcmV0dXJuIGNoYW5nZWQ7XHJcbiAgICB9XHJcbiAgICBsZXQgbmV4dFVuaXQgPSBnZXROZXh0VW5pdCh1bml0KTtcclxuICAgIGlmIChuZXh0VW5pdCkge1xyXG4gICAgICAgIHJldHVybiBjaGVja0NoYW5nZSh0aW1lT25lLCB0aW1lVHdvLCBuZXh0VW5pdCwgdXRjLCB0aW1lem9uZSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEFkZHMgYGNvdW50YCBvZiB0aW1lIGB1bml0YCB0byB0aGUgc291cmNlIGRhdGUuIFJldHVybnMgYSBtb2RpZmllZCBgRGF0ZWAgb2JqZWN0LlxyXG4gKlxyXG4gKiBAcGFyYW0gZGF0ZSAgIFNvdXJjZSBkYXRlXHJcbiAqIEBwYXJhbSB1bml0ICAgVGltZSB1bml0XHJcbiAqIEBwYXJhbSBjb3VudCAgTnVtYmVyIG9mIHVuaXRzIHRvIGFkZFxyXG4gKiBAcmV0dXJuIE1vZGlmaWVkIGRhdGVcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBhZGQoZGF0ZSwgdW5pdCwgY291bnQsIHV0YywgdGltZXpvbmUpIHtcclxuICAgIGxldCB0aW1lWm9uZU9mZnNldCA9IDA7XHJcbiAgICBpZiAoIXV0YyAmJiB1bml0ICE9IFwibWlsbGlzZWNvbmRcIikge1xyXG4gICAgICAgIHRpbWVab25lT2Zmc2V0ID0gZGF0ZS5nZXRUaW1lem9uZU9mZnNldCgpO1xyXG4gICAgICAgIGlmICh0aW1lem9uZSkge1xyXG4gICAgICAgICAgICB0aW1lWm9uZU9mZnNldCAtPSB0aW1lem9uZS5vZmZzZXRVVEMoZGF0ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGRhdGUuc2V0VVRDTWludXRlcyhkYXRlLmdldFVUQ01pbnV0ZXMoKSAtIHRpbWVab25lT2Zmc2V0KTtcclxuICAgIH1cclxuICAgIHN3aXRjaCAodW5pdCkge1xyXG4gICAgICAgIGNhc2UgXCJkYXlcIjpcclxuICAgICAgICAgICAgbGV0IGRheSA9IGRhdGUuZ2V0VVRDRGF0ZSgpO1xyXG4gICAgICAgICAgICBkYXRlLnNldFVUQ0RhdGUoZGF5ICsgY291bnQpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIFwic2Vjb25kXCI6XHJcbiAgICAgICAgICAgIGxldCBzZWNvbmRzID0gZGF0ZS5nZXRVVENTZWNvbmRzKCk7XHJcbiAgICAgICAgICAgIGRhdGUuc2V0VVRDU2Vjb25kcyhzZWNvbmRzICsgY291bnQpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIFwibWlsbGlzZWNvbmRcIjpcclxuICAgICAgICAgICAgbGV0IG1pbGxpc2Vjb25kcyA9IGRhdGUuZ2V0VVRDTWlsbGlzZWNvbmRzKCk7XHJcbiAgICAgICAgICAgIGRhdGUuc2V0VVRDTWlsbGlzZWNvbmRzKG1pbGxpc2Vjb25kcyArIGNvdW50KTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBcImhvdXJcIjpcclxuICAgICAgICAgICAgbGV0IGhvdXJzID0gZGF0ZS5nZXRVVENIb3VycygpO1xyXG4gICAgICAgICAgICBkYXRlLnNldFVUQ0hvdXJzKGhvdXJzICsgY291bnQpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIFwibWludXRlXCI6XHJcbiAgICAgICAgICAgIGxldCBtaW51dGVzID0gZGF0ZS5nZXRVVENNaW51dGVzKCk7XHJcbiAgICAgICAgICAgIGRhdGUuc2V0VVRDTWludXRlcyhtaW51dGVzICsgY291bnQpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIFwieWVhclwiOlxyXG4gICAgICAgICAgICBsZXQgeWVhciA9IGRhdGUuZ2V0VVRDRnVsbFllYXIoKTtcclxuICAgICAgICAgICAgZGF0ZS5zZXRVVENGdWxsWWVhcih5ZWFyICsgY291bnQpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIFwibW9udGhcIjpcclxuICAgICAgICAgICAgbGV0IG1vbnRoID0gZGF0ZS5nZXRVVENNb250aCgpO1xyXG4gICAgICAgICAgICBkYXRlLnNldFVUQ01vbnRoKG1vbnRoICsgY291bnQpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIFwid2Vla1wiOlxyXG4gICAgICAgICAgICBsZXQgd2RheSA9IGRhdGUuZ2V0VVRDRGF0ZSgpO1xyXG4gICAgICAgICAgICBkYXRlLnNldFVUQ0RhdGUod2RheSArIGNvdW50ICogNyk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG4gICAgaWYgKCF1dGMgJiYgdW5pdCAhPSBcIm1pbGxpc2Vjb25kXCIpIHtcclxuICAgICAgICBkYXRlLnNldFVUQ01pbnV0ZXMoZGF0ZS5nZXRVVENNaW51dGVzKCkgKyB0aW1lWm9uZU9mZnNldCk7XHJcbiAgICAgICAgaWYgKHVuaXQgPT0gXCJkYXlcIiB8fCB1bml0ID09IFwid2Vla1wiIHx8IHVuaXQgPT0gXCJtb250aFwiIHx8IHVuaXQgPT0gXCJ5ZWFyXCIpIHtcclxuICAgICAgICAgICAgbGV0IG5ld1RpbWVab25lT2Zmc2V0ID0gZGF0ZS5nZXRUaW1lem9uZU9mZnNldCgpO1xyXG4gICAgICAgICAgICBpZiAodGltZXpvbmUpIHtcclxuICAgICAgICAgICAgICAgIG5ld1RpbWVab25lT2Zmc2V0ICs9IHRpbWV6b25lLm9mZnNldFVUQyhkYXRlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAobmV3VGltZVpvbmVPZmZzZXQgIT0gdGltZVpvbmVPZmZzZXQpIHtcclxuICAgICAgICAgICAgICAgIGxldCBkaWZmID0gbmV3VGltZVpvbmVPZmZzZXQgLSB0aW1lWm9uZU9mZnNldDtcclxuICAgICAgICAgICAgICAgIGRhdGUuc2V0VVRDTWludXRlcyhkYXRlLmdldFVUQ01pbnV0ZXMoKSArIGRpZmYpO1xyXG4gICAgICAgICAgICAgICAgLy8gc29sdmVzIGlzc3VlcyBpZiBuZXcgdGltZSBmYWxscyBiYWNrIHRvIG9sZCB0aW1lIHpvbmVcclxuICAgICAgICAgICAgICAgIGlmIChkYXRlLmdldFRpbWV6b25lT2Zmc2V0KCkgIT0gbmV3VGltZVpvbmVPZmZzZXQpIHtcclxuICAgICAgICAgICAgICAgICAgICBkYXRlLnNldFVUQ01pbnV0ZXMoZGF0ZS5nZXRVVENNaW51dGVzKCkgLSBkaWZmKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBkYXRlO1xyXG59XHJcbi8qKlxyXG4gKiBcIlJvdW5kc1wiIHRoZSBkYXRlIHRvIHNwZWNpZmljIHRpbWUgdW5pdC5cclxuICpcclxuICogQHBhcmFtIGRhdGUgICAgICAgICAgICAgU291cmNlIGRhdGVcclxuICogQHBhcmFtIHVuaXQgICAgICAgICAgICAgVGltZSB1bml0XHJcbiAqIEBwYXJhbSBjb3VudCAgICAgICAgICAgIE51bWJlciBvZiB1bml0cyB0byByb3VuZCB0b1xyXG4gKiBAcGFyYW0gZmlyc3REYXRlT2ZXZWVrICBGaXJzdCBkYXkgb2Ygd2Vla1xyXG4gKiBAcGFyYW0gdXRjICAgICAgICAgICAgICBVc2UgVVRDIHRpbWV6b25lXHJcbiAqIEBwYXJhbSBmaXJzdERhdGUgICAgICAgIEZpcnN0IGRhdGUgdG8gcm91bmQgdG9cclxuICogQHBhcmFtIHJvdW5kTWludXRlcyAgICAgTWludXRlcyB0byByb3VuZCB0byAoc29tZSB0aW1lem9uZXMgdXNlIG5vbi13aG9sZSBob3VyKVxyXG4gKiBAcGFyYW0gdGltZXpvbmUgICAgICAgICBVc2Ugc3BlY2lmaWMgbmFtZWQgdGltZXpvbmUgd2hlbiByb3VuZGluZ1xyXG4gKiBAcmV0dXJuIE5ldyBkYXRlXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gcm91bmQoZGF0ZSwgdW5pdCwgY291bnQsIGZpcnN0RGF0ZU9mV2VlaywgdXRjLCBmaXJzdERhdGUsIHRpbWV6b25lKSB7XHJcbiAgICBpZiAoIXRpbWV6b25lIHx8IHV0Yykge1xyXG4gICAgICAgIGxldCB0aW1lWm9uZU9mZnNldCA9IDA7XHJcbiAgICAgICAgaWYgKCF1dGMgJiYgdW5pdCAhPSBcIm1pbGxpc2Vjb25kXCIpIHtcclxuICAgICAgICAgICAgdGltZVpvbmVPZmZzZXQgPSBkYXRlLmdldFRpbWV6b25lT2Zmc2V0KCk7XHJcbiAgICAgICAgICAgIGRhdGUuc2V0VVRDTWludXRlcyhkYXRlLmdldFVUQ01pbnV0ZXMoKSAtIHRpbWVab25lT2Zmc2V0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgc3dpdGNoICh1bml0KSB7XHJcbiAgICAgICAgICAgIGNhc2UgXCJkYXlcIjpcclxuICAgICAgICAgICAgICAgIGxldCBkYXkgPSBkYXRlLmdldFVUQ0RhdGUoKTtcclxuICAgICAgICAgICAgICAgIGlmIChjb3VudCA+IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICAvL1x0ZGF5ID0gTWF0aC5mbG9vcihkYXkgLyBjb3VudCkgKiBjb3VudDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZmlyc3REYXRlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpcnN0RGF0ZSA9IHJvdW5kKGZpcnN0RGF0ZSwgXCJkYXlcIiwgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBkaWZmZXJlbmNlID0gZGF0ZS5nZXRUaW1lKCkgLSBmaXJzdERhdGUuZ2V0VGltZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgdW5pdENvdW50ID0gTWF0aC5mbG9vcihkaWZmZXJlbmNlIC8gZ2V0RHVyYXRpb24oXCJkYXlcIikgLyBjb3VudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBkdXJhdGlvbiA9IGdldER1cmF0aW9uKFwiZGF5XCIsIHVuaXRDb3VudCAqIGNvdW50KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0ZS5zZXRUaW1lKGZpcnN0RGF0ZS5nZXRUaW1lKCkgKyBkdXJhdGlvbiAtIHRpbWVab25lT2Zmc2V0ICogZ2V0RHVyYXRpb24oXCJtaW51dGVcIikpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGRhdGUuc2V0VVRDRGF0ZShkYXkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZGF0ZS5zZXRVVENIb3VycygwLCAwLCAwLCAwKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFwic2Vjb25kXCI6XHJcbiAgICAgICAgICAgICAgICBsZXQgc2Vjb25kcyA9IGRhdGUuZ2V0VVRDU2Vjb25kcygpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGNvdW50ID4gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNlY29uZHMgPSBNYXRoLmZsb29yKHNlY29uZHMgLyBjb3VudCkgKiBjb3VudDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGRhdGUuc2V0VVRDU2Vjb25kcyhzZWNvbmRzLCAwKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFwibWlsbGlzZWNvbmRcIjpcclxuICAgICAgICAgICAgICAgIGlmIChjb3VudCA9PSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRhdGU7IC8vIG11Y2ggYmV0dGVyIGZvciBwZXJmIVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgbGV0IG1pbGxpc2Vjb25kcyA9IGRhdGUuZ2V0VVRDTWlsbGlzZWNvbmRzKCk7XHJcbiAgICAgICAgICAgICAgICBtaWxsaXNlY29uZHMgPSBNYXRoLmZsb29yKG1pbGxpc2Vjb25kcyAvIGNvdW50KSAqIGNvdW50O1xyXG4gICAgICAgICAgICAgICAgZGF0ZS5zZXRVVENNaWxsaXNlY29uZHMobWlsbGlzZWNvbmRzKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFwiaG91clwiOlxyXG4gICAgICAgICAgICAgICAgbGV0IGhvdXJzID0gZGF0ZS5nZXRVVENIb3VycygpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGNvdW50ID4gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGhvdXJzID0gTWF0aC5mbG9vcihob3VycyAvIGNvdW50KSAqIGNvdW50O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZGF0ZS5zZXRVVENIb3Vycyhob3VycywgMCwgMCwgMCk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBcIm1pbnV0ZVwiOlxyXG4gICAgICAgICAgICAgICAgbGV0IG1pbnV0ZXMgPSBkYXRlLmdldFVUQ01pbnV0ZXMoKTtcclxuICAgICAgICAgICAgICAgIGlmIChjb3VudCA+IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICBtaW51dGVzID0gTWF0aC5mbG9vcihtaW51dGVzIC8gY291bnQpICogY291bnQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBkYXRlLnNldFVUQ01pbnV0ZXMobWludXRlcywgMCwgMCk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBcIm1vbnRoXCI6XHJcbiAgICAgICAgICAgICAgICBsZXQgbW9udGggPSBkYXRlLmdldFVUQ01vbnRoKCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoY291bnQgPiAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbW9udGggPSBNYXRoLmZsb29yKG1vbnRoIC8gY291bnQpICogY291bnQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBkYXRlLnNldFVUQ01vbnRoKG1vbnRoLCAxKTtcclxuICAgICAgICAgICAgICAgIGRhdGUuc2V0VVRDSG91cnMoMCwgMCwgMCwgMCk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBcInllYXJcIjpcclxuICAgICAgICAgICAgICAgIGxldCB5ZWFyID0gZGF0ZS5nZXRVVENGdWxsWWVhcigpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGNvdW50ID4gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHllYXIgPSBNYXRoLmZsb29yKHllYXIgLyBjb3VudCkgKiBjb3VudDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGRhdGUuc2V0VVRDRnVsbFllYXIoeWVhciwgMCwgMSk7XHJcbiAgICAgICAgICAgICAgICBkYXRlLnNldFVUQ0hvdXJzKDAsIDAsIDAsIDApO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgXCJ3ZWVrXCI6XHJcbiAgICAgICAgICAgICAgICBsZXQgd2RheSA9IGRhdGUuZ2V0VVRDRGF0ZSgpO1xyXG4gICAgICAgICAgICAgICAgbGV0IHdlZWtEYXkgPSBkYXRlLmdldFVUQ0RheSgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCEkdHlwZS5pc051bWJlcihmaXJzdERhdGVPZldlZWspKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZmlyc3REYXRlT2ZXZWVrID0gMTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICh3ZWVrRGF5ID49IGZpcnN0RGF0ZU9mV2Vlaykge1xyXG4gICAgICAgICAgICAgICAgICAgIHdkYXkgPSB3ZGF5IC0gd2Vla0RheSArIGZpcnN0RGF0ZU9mV2VlaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHdkYXkgPSB3ZGF5IC0gKDcgKyB3ZWVrRGF5KSArIGZpcnN0RGF0ZU9mV2VlaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGRhdGUuc2V0VVRDRGF0ZSh3ZGF5KTtcclxuICAgICAgICAgICAgICAgIGRhdGUuc2V0VVRDSG91cnMoMCwgMCwgMCwgMCk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCF1dGMgJiYgdW5pdCAhPSBcIm1pbGxpc2Vjb25kXCIpIHtcclxuICAgICAgICAgICAgZGF0ZS5zZXRVVENNaW51dGVzKGRhdGUuZ2V0VVRDTWludXRlcygpICsgdGltZVpvbmVPZmZzZXQpO1xyXG4gICAgICAgICAgICBpZiAodW5pdCA9PSBcImRheVwiIHx8IHVuaXQgPT0gXCJ3ZWVrXCIgfHwgdW5pdCA9PSBcIm1vbnRoXCIgfHwgdW5pdCA9PSBcInllYXJcIikge1xyXG4gICAgICAgICAgICAgICAgbGV0IG5ld1RpbWVab25lT2Zmc2V0ID0gZGF0ZS5nZXRUaW1lem9uZU9mZnNldCgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKG5ld1RpbWVab25lT2Zmc2V0ICE9IHRpbWVab25lT2Zmc2V0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGRpZmYgPSBuZXdUaW1lWm9uZU9mZnNldCAtIHRpbWVab25lT2Zmc2V0O1xyXG4gICAgICAgICAgICAgICAgICAgIGRhdGUuc2V0VVRDTWludXRlcyhkYXRlLmdldFVUQ01pbnV0ZXMoKSArIGRpZmYpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBkYXRlO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgaWYgKGlzTmFOKGRhdGUuZ2V0VGltZSgpKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZGF0ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IHR6b2Zmc2V0ID0gdGltZXpvbmUub2Zmc2V0VVRDKGRhdGUpO1xyXG4gICAgICAgIGxldCB0aW1lWm9uZU9mZnNldCA9IGRhdGUuZ2V0VGltZXpvbmVPZmZzZXQoKTtcclxuICAgICAgICBsZXQgcGFyc2VkRGF0ZSA9IHRpbWV6b25lLnBhcnNlRGF0ZShkYXRlKTtcclxuICAgICAgICBsZXQgeWVhciA9IHBhcnNlZERhdGUueWVhcjtcclxuICAgICAgICBsZXQgbW9udGggPSBwYXJzZWREYXRlLm1vbnRoO1xyXG4gICAgICAgIGxldCBkYXkgPSBwYXJzZWREYXRlLmRheTtcclxuICAgICAgICBsZXQgaG91ciA9IHBhcnNlZERhdGUuaG91cjtcclxuICAgICAgICBsZXQgbWludXRlID0gcGFyc2VkRGF0ZS5taW51dGU7XHJcbiAgICAgICAgbGV0IHNlY29uZCA9IHBhcnNlZERhdGUuc2Vjb25kO1xyXG4gICAgICAgIGxldCBtaWxsaXNlY29uZCA9IHBhcnNlZERhdGUubWlsbGlzZWNvbmQ7XHJcbiAgICAgICAgbGV0IHdlZWtkYXkgPSBwYXJzZWREYXRlLndlZWtkYXk7XHJcbiAgICAgICAgbGV0IG9mZnNldERpZiA9IHR6b2Zmc2V0IC0gdGltZVpvbmVPZmZzZXQ7XHJcbiAgICAgICAgc3dpdGNoICh1bml0KSB7XHJcbiAgICAgICAgICAgIGNhc2UgXCJkYXlcIjpcclxuICAgICAgICAgICAgICAgIGlmIChjb3VudCA+IDEgJiYgZmlyc3REYXRlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZmlyc3REYXRlID0gcm91bmQoZmlyc3REYXRlLCBcImRheVwiLCAxLCBmaXJzdERhdGVPZldlZWssIHV0YywgdW5kZWZpbmVkLCB0aW1lem9uZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGRpZmZlcmVuY2UgPSBkYXRlLmdldFRpbWUoKSAtIGZpcnN0RGF0ZS5nZXRUaW1lKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHVuaXRDb3VudCA9IE1hdGguZmxvb3IoZGlmZmVyZW5jZSAvIGdldER1cmF0aW9uKFwiZGF5XCIpIC8gY291bnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBkdXJhdGlvbiA9IGdldER1cmF0aW9uKFwiZGF5XCIsIHVuaXRDb3VudCAqIGNvdW50KTtcclxuICAgICAgICAgICAgICAgICAgICBkYXRlLnNldFRpbWUoZmlyc3REYXRlLmdldFRpbWUoKSArIGR1cmF0aW9uKTtcclxuICAgICAgICAgICAgICAgICAgICBwYXJzZWREYXRlID0gdGltZXpvbmUucGFyc2VEYXRlKGRhdGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHllYXIgPSBwYXJzZWREYXRlLnllYXI7XHJcbiAgICAgICAgICAgICAgICAgICAgbW9udGggPSBwYXJzZWREYXRlLm1vbnRoO1xyXG4gICAgICAgICAgICAgICAgICAgIGRheSA9IHBhcnNlZERhdGUuZGF5O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaG91ciA9IDA7XHJcbiAgICAgICAgICAgICAgICBtaW51dGUgPSBvZmZzZXREaWY7XHJcbiAgICAgICAgICAgICAgICBzZWNvbmQgPSAwO1xyXG4gICAgICAgICAgICAgICAgbWlsbGlzZWNvbmQgPSAwO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgXCJzZWNvbmRcIjpcclxuICAgICAgICAgICAgICAgIG1pbnV0ZSArPSBvZmZzZXREaWY7XHJcbiAgICAgICAgICAgICAgICBpZiAoY291bnQgPiAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2Vjb25kID0gTWF0aC5mbG9vcihzZWNvbmQgLyBjb3VudCkgKiBjb3VudDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIG1pbGxpc2Vjb25kID0gMDtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFwibWlsbGlzZWNvbmRcIjpcclxuICAgICAgICAgICAgICAgIG1pbnV0ZSArPSBvZmZzZXREaWY7XHJcbiAgICAgICAgICAgICAgICBpZiAoY291bnQgPiAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWlsbGlzZWNvbmQgPSBNYXRoLmZsb29yKG1pbGxpc2Vjb25kIC8gY291bnQpICogY291bnQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBcImhvdXJcIjpcclxuICAgICAgICAgICAgICAgIGlmIChjb3VudCA+IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICBob3VyID0gTWF0aC5mbG9vcihob3VyIC8gY291bnQpICogY291bnQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBtaW51dGUgPSBvZmZzZXREaWY7XHJcbiAgICAgICAgICAgICAgICBzZWNvbmQgPSAwO1xyXG4gICAgICAgICAgICAgICAgbWlsbGlzZWNvbmQgPSAwO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgXCJtaW51dGVcIjpcclxuICAgICAgICAgICAgICAgIGlmIChjb3VudCA+IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICBtaW51dGUgPSBNYXRoLmZsb29yKG1pbnV0ZSAvIGNvdW50KSAqIGNvdW50O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgbWludXRlICs9IG9mZnNldERpZjtcclxuICAgICAgICAgICAgICAgIHNlY29uZCA9IDA7XHJcbiAgICAgICAgICAgICAgICBtaWxsaXNlY29uZCA9IDA7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBcIm1vbnRoXCI6XHJcbiAgICAgICAgICAgICAgICBpZiAoY291bnQgPiAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbW9udGggPSBNYXRoLmZsb29yKG1vbnRoIC8gY291bnQpICogY291bnQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBkYXkgPSAxO1xyXG4gICAgICAgICAgICAgICAgaG91ciA9IDA7XHJcbiAgICAgICAgICAgICAgICBtaW51dGUgPSBvZmZzZXREaWY7XHJcbiAgICAgICAgICAgICAgICBzZWNvbmQgPSAwO1xyXG4gICAgICAgICAgICAgICAgbWlsbGlzZWNvbmQgPSAwO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgXCJ5ZWFyXCI6XHJcbiAgICAgICAgICAgICAgICBpZiAoY291bnQgPiAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgeWVhciA9IE1hdGguZmxvb3IoeWVhciAvIGNvdW50KSAqIGNvdW50O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgbW9udGggPSAwO1xyXG4gICAgICAgICAgICAgICAgZGF5ID0gMTtcclxuICAgICAgICAgICAgICAgIGhvdXIgPSAwO1xyXG4gICAgICAgICAgICAgICAgbWludXRlID0gb2Zmc2V0RGlmO1xyXG4gICAgICAgICAgICAgICAgc2Vjb25kID0gMDtcclxuICAgICAgICAgICAgICAgIG1pbGxpc2Vjb25kID0gMDtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFwid2Vla1wiOlxyXG4gICAgICAgICAgICAgICAgaWYgKCEkdHlwZS5pc051bWJlcihmaXJzdERhdGVPZldlZWspKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZmlyc3REYXRlT2ZXZWVrID0gMTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICh3ZWVrZGF5ID49IGZpcnN0RGF0ZU9mV2Vlaykge1xyXG4gICAgICAgICAgICAgICAgICAgIGRheSA9IGRheSAtIHdlZWtkYXkgKyBmaXJzdERhdGVPZldlZWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBkYXkgPSBkYXkgLSAoNyArIHdlZWtkYXkpICsgZmlyc3REYXRlT2ZXZWVrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaG91ciA9IDA7XHJcbiAgICAgICAgICAgICAgICBtaW51dGUgPSBvZmZzZXREaWY7XHJcbiAgICAgICAgICAgICAgICBzZWNvbmQgPSAwO1xyXG4gICAgICAgICAgICAgICAgbWlsbGlzZWNvbmQgPSAwO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGRhdGUgPSBuZXcgRGF0ZSh5ZWFyLCBtb250aCwgZGF5LCBob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmQpO1xyXG4gICAgICAgIGxldCBuZXdUaW1lWm9uZU9mZnNldCA9IGRhdGUuZ2V0VGltZXpvbmVPZmZzZXQoKTtcclxuICAgICAgICBsZXQgbmV3VHpvZmZzZXQgPSB0aW1lem9uZS5vZmZzZXRVVEMoZGF0ZSk7XHJcbiAgICAgICAgbGV0IG5ld0RpZmYgPSBuZXdUem9mZnNldCAtIG5ld1RpbWVab25lT2Zmc2V0O1xyXG4gICAgICAgIGlmIChuZXdEaWZmICE9IG9mZnNldERpZikge1xyXG4gICAgICAgICAgICBkYXRlLnNldFRpbWUoZGF0ZS5nZXRUaW1lKCkgKyAobmV3RGlmZiAtIG9mZnNldERpZikgKiA2MDAwMCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBkYXRlO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBAaWdub3JlXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gY2hvb3NlSW50ZXJ2YWwoaW5kZXgsIGR1cmF0aW9uLCBncmlkQ291bnQsIGludGVydmFscykge1xyXG4gICAgbGV0IGdyaWRJbnRlcnZhbCA9IGludGVydmFsc1tpbmRleF07XHJcbiAgICBsZXQgaW50ZXJ2YWxEdXJhdGlvbiA9IGdldEludGVydmFsRHVyYXRpb24oZ3JpZEludGVydmFsKTtcclxuICAgIGxldCBsYXN0SW5kZXggPSBpbnRlcnZhbHMubGVuZ3RoIC0gMTtcclxuICAgIGlmIChpbmRleCA+PSBsYXN0SW5kZXgpIHtcclxuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgaW50ZXJ2YWxzW2xhc3RJbmRleF0pO1xyXG4gICAgfVxyXG4gICAgbGV0IGNvdW50ID0gTWF0aC5jZWlsKGR1cmF0aW9uIC8gaW50ZXJ2YWxEdXJhdGlvbik7XHJcbiAgICBpZiAoZHVyYXRpb24gPCBpbnRlcnZhbER1cmF0aW9uICYmIGluZGV4ID4gMCkge1xyXG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBpbnRlcnZhbHNbaW5kZXggLSAxXSk7XHJcbiAgICB9XHJcbiAgICBpZiAoY291bnQgPD0gZ3JpZENvdW50KSB7XHJcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIGludGVydmFsc1tpbmRleF0pO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgaWYgKGluZGV4ICsgMSA8IGludGVydmFscy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGNob29zZUludGVydmFsKGluZGV4ICsgMSwgZHVyYXRpb24sIGdyaWRDb3VudCwgaW50ZXJ2YWxzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBpbnRlcnZhbHNbaW5kZXhdKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEBpZ25vcmVcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRVbml0VmFsdWUoZGF0ZSwgdW5pdCkge1xyXG4gICAgc3dpdGNoICh1bml0KSB7XHJcbiAgICAgICAgY2FzZSBcImRheVwiOlxyXG4gICAgICAgICAgICByZXR1cm4gZGF0ZS5nZXREYXRlKCk7XHJcbiAgICAgICAgY2FzZSBcInNlY29uZFwiOlxyXG4gICAgICAgICAgICByZXR1cm4gZGF0ZS5nZXRTZWNvbmRzKCk7XHJcbiAgICAgICAgY2FzZSBcIm1pbGxpc2Vjb25kXCI6XHJcbiAgICAgICAgICAgIHJldHVybiBkYXRlLmdldE1pbGxpc2Vjb25kcygpO1xyXG4gICAgICAgIGNhc2UgXCJob3VyXCI6XHJcbiAgICAgICAgICAgIHJldHVybiBkYXRlLmdldEhvdXJzKCk7XHJcbiAgICAgICAgY2FzZSBcIm1pbnV0ZVwiOlxyXG4gICAgICAgICAgICByZXR1cm4gZGF0ZS5nZXRNaW51dGVzKCk7XHJcbiAgICAgICAgY2FzZSBcIm1vbnRoXCI6XHJcbiAgICAgICAgICAgIHJldHVybiBkYXRlLmdldE1vbnRoKCk7XHJcbiAgICAgICAgY2FzZSBcInllYXJcIjpcclxuICAgICAgICAgICAgcmV0dXJuIGRhdGUuZ2V0RnVsbFllYXIoKTtcclxuICAgICAgICBjYXNlIFwid2Vla1wiOlxyXG4gICAgICAgICAgICByZXR1cm4gJHV0aWxzLmdldFdlZWsoZGF0ZSk7XHJcbiAgICB9XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VGltZS5qcy5tYXAiLCJmdW5jdGlvbiBwYXJzZURhdGUodGltZXpvbmUsIGRhdGUpIHtcclxuICAgIGxldCB5ZWFyID0gMDtcclxuICAgIGxldCBtb250aCA9IDA7XHJcbiAgICBsZXQgZGF5ID0gMTtcclxuICAgIGxldCBob3VyID0gMDtcclxuICAgIGxldCBtaW51dGUgPSAwO1xyXG4gICAgbGV0IHNlY29uZCA9IDA7XHJcbiAgICBsZXQgbWlsbGlzZWNvbmQgPSAwO1xyXG4gICAgbGV0IHdlZWtkYXkgPSAwO1xyXG4gICAgdGltZXpvbmUuZm9ybWF0VG9QYXJ0cyhkYXRlKS5mb3JFYWNoKCh4KSA9PiB7XHJcbiAgICAgICAgc3dpdGNoICh4LnR5cGUpIHtcclxuICAgICAgICAgICAgY2FzZSBcInllYXJcIjpcclxuICAgICAgICAgICAgICAgIHllYXIgPSAreC52YWx1ZTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFwibW9udGhcIjpcclxuICAgICAgICAgICAgICAgIG1vbnRoID0gKCt4LnZhbHVlKSAtIDE7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBcImRheVwiOlxyXG4gICAgICAgICAgICAgICAgZGF5ID0gK3gudmFsdWU7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBcImhvdXJcIjpcclxuICAgICAgICAgICAgICAgIGhvdXIgPSAreC52YWx1ZTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFwibWludXRlXCI6XHJcbiAgICAgICAgICAgICAgICBtaW51dGUgPSAreC52YWx1ZTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFwic2Vjb25kXCI6XHJcbiAgICAgICAgICAgICAgICBzZWNvbmQgPSAreC52YWx1ZTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFwiZnJhY3Rpb25hbFNlY29uZFwiOlxyXG4gICAgICAgICAgICAgICAgbWlsbGlzZWNvbmQgPSAreC52YWx1ZTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFwid2Vla2RheVwiOlxyXG4gICAgICAgICAgICAgICAgc3dpdGNoICh4LnZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIlN1blwiOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB3ZWVrZGF5ID0gMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIk1vblwiOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB3ZWVrZGF5ID0gMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIlR1ZVwiOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB3ZWVrZGF5ID0gMjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIldlZFwiOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB3ZWVrZGF5ID0gMztcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIlRodVwiOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB3ZWVrZGF5ID0gNDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIkZyaVwiOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB3ZWVrZGF5ID0gNTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIlNhdFwiOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB3ZWVrZGF5ID0gNjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICBpZiAoaG91ciA9PT0gMjQpIHtcclxuICAgICAgICBob3VyID0gMDtcclxuICAgIH1cclxuICAgIHJldHVybiB7IHllYXIsIG1vbnRoLCBkYXksIGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBtaWxsaXNlY29uZCwgd2Vla2RheSB9O1xyXG59XHJcbmZ1bmN0aW9uIHRvVVRDRGF0ZSh0aW1lem9uZSwgZGF0ZSkge1xyXG4gICAgY29uc3QgeyB5ZWFyLCBtb250aCwgZGF5LCBob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmQgfSA9IHBhcnNlRGF0ZSh0aW1lem9uZSwgZGF0ZSk7XHJcbiAgICByZXR1cm4gRGF0ZS5VVEMoeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kKTtcclxufVxyXG5leHBvcnQgY2xhc3MgVGltZXpvbmUge1xyXG4gICAgY29uc3RydWN0b3IodGltZXpvbmUsIGlzUmVhbCkge1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl91dGNcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX2R0ZlwiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGlmICghaXNSZWFsKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIllvdSBjYW5ub3QgdXNlIGBuZXcgQ2xhc3MoKWAsIGluc3RlYWQgdXNlIGBDbGFzcy5uZXcoKWBcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMubmFtZSA9IHRpbWV6b25lO1xyXG4gICAgICAgIHRoaXMuX3V0YyA9IG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KFwiVVRDXCIsIHtcclxuICAgICAgICAgICAgaG91cjEyOiBmYWxzZSxcclxuICAgICAgICAgICAgdGltZVpvbmU6IFwiVVRDXCIsXHJcbiAgICAgICAgICAgIHllYXI6IFwibnVtZXJpY1wiLFxyXG4gICAgICAgICAgICBtb250aDogXCIyLWRpZ2l0XCIsXHJcbiAgICAgICAgICAgIGRheTogXCIyLWRpZ2l0XCIsXHJcbiAgICAgICAgICAgIGhvdXI6IFwiMi1kaWdpdFwiLFxyXG4gICAgICAgICAgICBtaW51dGU6IFwiMi1kaWdpdFwiLFxyXG4gICAgICAgICAgICBzZWNvbmQ6IFwiMi1kaWdpdFwiLFxyXG4gICAgICAgICAgICB3ZWVrZGF5OiBcInNob3J0XCIsXHJcbiAgICAgICAgICAgIGZyYWN0aW9uYWxTZWNvbmREaWdpdHM6IDMsXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5fZHRmID0gbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQoXCJVVENcIiwge1xyXG4gICAgICAgICAgICBob3VyMTI6IGZhbHNlLFxyXG4gICAgICAgICAgICB0aW1lWm9uZTogdGltZXpvbmUsXHJcbiAgICAgICAgICAgIHllYXI6IFwibnVtZXJpY1wiLFxyXG4gICAgICAgICAgICBtb250aDogXCIyLWRpZ2l0XCIsXHJcbiAgICAgICAgICAgIGRheTogXCIyLWRpZ2l0XCIsXHJcbiAgICAgICAgICAgIGhvdXI6IFwiMi1kaWdpdFwiLFxyXG4gICAgICAgICAgICBtaW51dGU6IFwiMi1kaWdpdFwiLFxyXG4gICAgICAgICAgICBzZWNvbmQ6IFwiMi1kaWdpdFwiLFxyXG4gICAgICAgICAgICB3ZWVrZGF5OiBcInNob3J0XCIsXHJcbiAgICAgICAgICAgIGZyYWN0aW9uYWxTZWNvbmREaWdpdHM6IDMsXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFVzZSB0aGlzIG1ldGhvZCB0byBjcmVhdGUgYW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcy5cclxuICAgICAqXHJcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL3d3dy5hbWNoYXJ0cy5jb20vZG9jcy92NS9nZXR0aW5nLXN0YXJ0ZWQvI05ld19lbGVtZW50X3N5bnRheH0gZm9yIG1vcmUgaW5mb1xyXG4gICAgICogQHBhcmFtICAgdGltZXpvbmUgIElBTkEgdGltZXpvbmVcclxuICAgICAqIEByZXR1cm4gICAgICAgICAgICBJbnN0YW50aWF0ZWQgb2JqZWN0XHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBuZXcodGltZXpvbmUpIHtcclxuICAgICAgICByZXR1cm4gKG5ldyB0aGlzKHRpbWV6b25lLCB0cnVlKSk7XHJcbiAgICB9XHJcbiAgICBjb252ZXJ0TG9jYWwoZGF0ZSkge1xyXG4gICAgICAgIGNvbnN0IG9mZnNldCA9IHRoaXMub2Zmc2V0VVRDKGRhdGUpO1xyXG4gICAgICAgIGNvbnN0IHVzZXJPZmZzZXQgPSBkYXRlLmdldFRpbWV6b25lT2Zmc2V0KCk7XHJcbiAgICAgICAgY29uc3Qgb3V0cHV0ID0gbmV3IERhdGUoZGF0ZSk7XHJcbiAgICAgICAgb3V0cHV0LnNldFVUQ01pbnV0ZXMob3V0cHV0LmdldFVUQ01pbnV0ZXMoKSAtIChvZmZzZXQgLSB1c2VyT2Zmc2V0KSk7XHJcbiAgICAgICAgY29uc3QgbmV3VXNlck9mZnNldCA9IG91dHB1dC5nZXRUaW1lem9uZU9mZnNldCgpO1xyXG4gICAgICAgIGlmICh1c2VyT2Zmc2V0ICE9IG5ld1VzZXJPZmZzZXQpIHtcclxuICAgICAgICAgICAgb3V0cHV0LnNldFVUQ01pbnV0ZXMob3V0cHV0LmdldFVUQ01pbnV0ZXMoKSArIG5ld1VzZXJPZmZzZXQgLSB1c2VyT2Zmc2V0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG91dHB1dDtcclxuICAgIH1cclxuICAgIG9mZnNldFVUQyhkYXRlKSB7XHJcbiAgICAgICAgY29uc3QgdXRjID0gdG9VVENEYXRlKHRoaXMuX3V0YywgZGF0ZSk7XHJcbiAgICAgICAgY29uc3QgZHRmID0gdG9VVENEYXRlKHRoaXMuX2R0ZiwgZGF0ZSk7XHJcbiAgICAgICAgcmV0dXJuICh1dGMgLSBkdGYpIC8gNjAwMDA7XHJcbiAgICB9XHJcbiAgICBwYXJzZURhdGUoZGF0ZSkge1xyXG4gICAgICAgIHJldHVybiBwYXJzZURhdGUodGhpcy5fZHRmLCBkYXRlKTtcclxuICAgIH1cclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1UaW1lem9uZS5qcy5tYXAiLCIvKipcclxuICogQSBjb2xsZWN0aW9uIG9mIHV0aWxpdHkgZnVuY3Rpb25zIGZvciB2YXJpb3VzIHR5cGUgY2hlY2tzIGFuZCBjb252ZXJzaW9uXHJcbiAqIEBoaWRkZW5cclxuICovXHJcbi8qKlxyXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAqIFRZUEUgQ0hFQ0tcclxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4gKiBAaGlkZGVuXHJcbiAqL1xyXG4vKipcclxuICogUmV0dXJucyBgdHJ1ZWAgaWYgdmFsdWUgaXMgbm90IGEgbnVtYmVyIChOYU4pLlxyXG4gKlxyXG4gKiBAcGFyYW0gdmFsdWUgSW5wdXQgdmFsdWVcclxuICogQHJldHVybiBJcyBOYU4/XHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gaXNOYU4odmFsdWUpIHtcclxuICAgIHJldHVybiBOdW1iZXIodmFsdWUpICE9PSB2YWx1ZTtcclxufVxyXG4vKipcclxuICogUmV0dXJucyBhIHR5cGUgb2YgdGhlIHZhbHVlLlxyXG4gKlxyXG4gKiBAcGFyYW0gdmFsdWUgIElucHV0IHZhbHVlXHJcbiAqIEByZXR1cm4gVHlwZSBvZiB0aGUgdmFsdWVcclxuICogQGlnbm9yZVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGdldFR5cGUodmFsdWUpIHtcclxuICAgIHJldHVybiAoe30pLnRvU3RyaW5nLmNhbGwodmFsdWUpO1xyXG59XHJcbi8qKlxyXG4gKiBBc3NlcnRzIHRoYXQgdGhlIGNvbmRpdGlvbiBpcyB0cnVlLlxyXG4gKlxyXG4gKiBAcGFyYW0gY29uZGl0aW9uICBDb25kaXRpb24gdG8gY2hlY2tcclxuICogQHBhcmFtIG1lc3NhZ2UgICAgTWVzc2FnZSB0byBkaXNwbGF5IGluIHRoZSBlcnJvclxyXG4gKiBAaWdub3JlXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0KGNvbmRpdGlvbiwgbWVzc2FnZSA9IFwiQXNzZXJ0aW9uIGZhaWxlZFwiKSB7XHJcbiAgICBpZiAoIWNvbmRpdGlvbikge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4gKiBRVUlDSyBDT05WRVJTSU9OXHJcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICogQGhpZGRlblxyXG4gKi9cclxuLyoqXHJcbiAqIENvbnZlcnRzIGFueSB2YWx1ZSBpbnRvIGEgYG51bWJlcmAuXHJcbiAqXHJcbiAqIEBwYXJhbSB2YWx1ZSAgU291cmNlIHZhbHVlXHJcbiAqIEByZXR1cm4gTnVtYmVyIHJlcHJlc2VudGF0aW9uIG9mIHZhbHVlXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gdG9OdW1iZXIodmFsdWUpIHtcclxuICAgIGlmICh2YWx1ZSAhPSBudWxsICYmICFpc051bWJlcih2YWx1ZSkpIHtcclxuICAgICAgICBsZXQgY29udmVydGVkID0gTnVtYmVyKHZhbHVlKTtcclxuICAgICAgICBpZiAoaXNOYU4oY29udmVydGVkKSAmJiBpc1N0cmluZyh2YWx1ZSkgJiYgdmFsdWUgIT0gXCJcIikge1xyXG4gICAgICAgICAgICByZXR1cm4gdG9OdW1iZXIodmFsdWUucmVwbGFjZSgvW14wLTkuXFwtXSsvZywgJycpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGNvbnZlcnRlZDtcclxuICAgIH1cclxuICAgIHJldHVybiB2YWx1ZTtcclxufVxyXG4vKipcclxuICogQ29udmVydHMgYW55dGhpbmcgdG8gRGF0ZSBvYmplY3QuXHJcbiAqXHJcbiAqIEBwYXJhbSB2YWx1ZSAgQSB2YWx1ZSBvZiBhbnkgdHlwZVxyXG4gKiBAcmV0dXJuIERhdGUgb2JqZWN0IHJlcHJlc2VudGluZyBhIHZhbHVlXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gdG9EYXRlKHZhbHVlKSB7XHJcbiAgICBpZiAoaXNEYXRlKHZhbHVlKSkge1xyXG4gICAgICAgIC8vIFRPRE8gbWF5YmUgZG9uJ3QgY3JlYXRlIGEgbmV3IERhdGUgP1xyXG4gICAgICAgIHJldHVybiBuZXcgRGF0ZSh2YWx1ZSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChpc051bWJlcih2YWx1ZSkpIHtcclxuICAgICAgICByZXR1cm4gbmV3IERhdGUodmFsdWUpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgLy8gVHJ5IGNvbnZlcnRpbmcgdG8gbnVtYmVyIChhc3N1bWluZyB0aW1lc3RhbXApXHJcbiAgICAgICAgbGV0IG51bSA9IE51bWJlcih2YWx1ZSk7XHJcbiAgICAgICAgaWYgKCFpc051bWJlcihudW0pKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGF0ZSh2YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IERhdGUobnVtKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIENvbnZlcnRzIG51bWVyaWMgdmFsdWUgaW50byBzdHJpbmcuIERlYWxzIHdpdGggbGFyZ2Ugb3Igc21hbGwgbnVtYmVycyB0aGF0XHJcbiAqIHdvdWxkIG90aGVyd2lzZSB1c2UgZXhwb25lbnRzLlxyXG4gKlxyXG4gKiBAcGFyYW0gdmFsdWUgIE51bWVyaWMgdmFsdWVcclxuICogQHJldHVybiBOdW1lcmljIHZhbHVlIGFzIHN0cmluZ1xyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIG51bWJlclRvU3RyaW5nKHZhbHVlKSB7XHJcbiAgICAvLyBUT0RPIGhhbmRsZSBJbmZpbml0eSBhbmQgLUluZmluaXR5XHJcbiAgICBpZiAoaXNOYU4odmFsdWUpKSB7XHJcbiAgICAgICAgcmV0dXJuIFwiTmFOXCI7XHJcbiAgICB9XHJcbiAgICBpZiAodmFsdWUgPT09IEluZmluaXR5KSB7XHJcbiAgICAgICAgcmV0dXJuIFwiSW5maW5pdHlcIjtcclxuICAgIH1cclxuICAgIGlmICh2YWx1ZSA9PT0gLUluZmluaXR5KSB7XHJcbiAgICAgICAgcmV0dXJuIFwiLUluZmluaXR5XCI7XHJcbiAgICB9XHJcbiAgICAvLyBOZWdhdGl2ZSAwXHJcbiAgICBpZiAoKHZhbHVlID09PSAwKSAmJiAoMSAvIHZhbHVlID09PSAtSW5maW5pdHkpKSB7XHJcbiAgICAgICAgcmV0dXJuIFwiLTBcIjtcclxuICAgIH1cclxuICAgIC8vIFByZXNlcnZlIG5lZ2F0aXZlIGFuZCBkZWFsIHdpdGggYWJzb3V0ZSB2YWx1ZXNcclxuICAgIGxldCBuZWdhdGl2ZSA9IHZhbHVlIDwgMDtcclxuICAgIHZhbHVlID0gTWF0aC5hYnModmFsdWUpO1xyXG4gICAgLy8gVE9ETyB0ZXN0IHRoaXNcclxuICAgIGxldCBwYXJzZWQgPSAvXihbMC05XSspKD86XFwuKFswLTldKykpPyg/OmVbXFwrXFwtXShbMC05XSspKT8kLy5leGVjKFwiXCIgKyB2YWx1ZSk7XHJcbiAgICBsZXQgZGlnaXRzID0gcGFyc2VkWzFdO1xyXG4gICAgbGV0IGRlY2ltYWxzID0gcGFyc2VkWzJdIHx8IFwiXCI7XHJcbiAgICBsZXQgcmVzO1xyXG4gICAgLy8gTGVhdmUgdGhlIG51bW1iZXIgYXMgaXQgaXMgaWYgaXQgZG9lcyBub3QgdXNlIGV4cG9uZW50c1xyXG4gICAgaWYgKHBhcnNlZFszXSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgcmVzID0gKGRlY2ltYWxzID09PSBcIlwiID8gZGlnaXRzIDogZGlnaXRzICsgXCIuXCIgKyBkZWNpbWFscyk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBsZXQgZXhwb25lbnQgPSArcGFyc2VkWzNdO1xyXG4gICAgICAgIC8vIERlYWwgd2l0aCBkZWNpbWFsc1xyXG4gICAgICAgIGlmICh2YWx1ZSA8IDEpIHtcclxuICAgICAgICAgICAgbGV0IHplcm9zID0gZXhwb25lbnQgLSAxO1xyXG4gICAgICAgICAgICByZXMgPSBcIjAuXCIgKyByZXBlYXQoXCIwXCIsIHplcm9zKSArIGRpZ2l0cyArIGRlY2ltYWxzO1xyXG4gICAgICAgICAgICAvLyBEZWFsIHdpdGggaW50ZWdlcnNcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGxldCB6ZXJvcyA9IGV4cG9uZW50IC0gZGVjaW1hbHMubGVuZ3RoO1xyXG4gICAgICAgICAgICBpZiAoemVyb3MgPT09IDApIHtcclxuICAgICAgICAgICAgICAgIHJlcyA9IGRpZ2l0cyArIGRlY2ltYWxzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHplcm9zIDwgMCkge1xyXG4gICAgICAgICAgICAgICAgcmVzID0gZGlnaXRzICsgZGVjaW1hbHMuc2xpY2UoMCwgemVyb3MpICsgXCIuXCIgKyBkZWNpbWFscy5zbGljZSh6ZXJvcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXMgPSBkaWdpdHMgKyBkZWNpbWFscyArIHJlcGVhdChcIjBcIiwgemVyb3MpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIG5lZ2F0aXZlID8gXCItXCIgKyByZXMgOiByZXM7XHJcbn1cclxuLyoqXHJcbiAqIFJlcGVhdHMgYSBgc3RyaW5nYCBudW1iZXIgb2YgdGltZXMgYXMgc2V0IGluIGBhbW91bnRgLlxyXG4gKlxyXG4gKiBAaWdub3JlIEV4Y2x1ZGUgZnJvbSBkb2NzXHJcbiAqIEB0b2RvIE1ha2UgdGhpcyBmYXN0ZXJcclxuICogQHBhcmFtIHN0cmluZyAgU291cmNlIHN0cmluZ1xyXG4gKiBAcGFyYW0gYW1vdW50ICBOdW1iZXIgb2YgdGltZXMgdG8gcmVwZWF0IHN0cmluZ1xyXG4gKiBAcmV0dXJuIE5ldyBzdHJpbmdcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiByZXBlYXQoc3RyaW5nLCBhbW91bnQpIHtcclxuICAgIHJldHVybiBuZXcgQXJyYXkoYW1vdW50ICsgMSkuam9pbihzdHJpbmcpO1xyXG59XHJcbi8qKlxyXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAqIFRZUEUgQ0hFQ0tcclxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4gKiBAaGlkZGVuXHJcbiAqL1xyXG4vKipcclxuICogQ2hlY2tzIGlmIHBhcmFtZXRlciBpcyBgRGF0ZWAuXHJcbiAqXHJcbiAqIEBwYXJhbSB2YWx1ZSAgSW5wdXQgdmFsdWVcclxuICogQHJldHVybiBJcyBEYXRlP1xyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGlzRGF0ZSh2YWx1ZSkge1xyXG4gICAgcmV0dXJuIGdldFR5cGUodmFsdWUpID09PSBcIltvYmplY3QgRGF0ZV1cIjtcclxufVxyXG4vKipcclxuICogQ2hlY2tzIGlmIHBhcmFtZXRlciBpcyBgc3RyaW5nYC5cclxuICpcclxuICogQHBhcmFtIHZhbHVlICBJbnB1dCB2YWx1ZVxyXG4gKiBAcmV0dXJuIElzIHN0cmluZz9cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBpc1N0cmluZyh2YWx1ZSkge1xyXG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIjtcclxufVxyXG4vKipcclxuICogQ2hlY2tzIGlmIHBhcmFtZXRlciBpcyBgbnVtYmVyYC5cclxuICpcclxuICogQHBhcmFtIHZhbHVlICBJbnB1dCB2YWx1ZVxyXG4gKiBAcmV0dXJuIElzIG51bWJlcj9cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBpc051bWJlcih2YWx1ZSkge1xyXG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIiAmJiBOdW1iZXIodmFsdWUpID09IHZhbHVlO1xyXG59XHJcbi8qKlxyXG4gKiBDaGVja3MgaWYgcGFyYW1ldGVyIGlzIGBvYmplY3RgLlxyXG4gKlxyXG4gKiBAcGFyYW0gdmFsdWUgIElucHV0IHZhbHVlXHJcbiAqIEByZXR1cm4gSXMgb2JqZWN0P1xyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XHJcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmIHZhbHVlICE9PSBudWxsO1xyXG59XHJcbi8qKlxyXG4gKiBDaGVja3MgaWYgcGFyYW1ldGVyIGlzIGBBcnJheWAuXHJcbiAqXHJcbiAqIEBwYXJhbSB2YWx1ZSAgSW5wdXQgdmFsdWVcclxuICogQHJldHVybiBJcyBBcnJheT9cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBpc0FycmF5KHZhbHVlKSB7XHJcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh2YWx1ZSk7XHJcbn1cclxuLyoqXHJcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICogU1RBVElDIENPTlNUQU5UU1xyXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAqIEBoaWRkZW5cclxuICovXHJcbi8qKlxyXG4gKiBAaWdub3JlIEV4Y2x1ZGUgZnJvbSBkb2NzXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgUExBQ0VIT0xERVIgPSBcIl9fwqfCp8KnX19cIjtcclxuLyoqXHJcbiAqIEBpZ25vcmUgRXhjbHVkZSBmcm9tIGRvY3NcclxuICovXHJcbmV4cG9ydCBjb25zdCBQTEFDRUhPTERFUjIgPSBcIl9fwqfCp8KnwqdfX1wiO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1UeXBlLmpzLm1hcCIsImltcG9ydCAqIGFzICR0eXBlIGZyb20gXCIuL1R5cGVcIjtcclxuaW1wb3J0ICogYXMgJGFycmF5IGZyb20gXCIuL0FycmF5XCI7XHJcbmltcG9ydCAqIGFzICRvYmplY3QgZnJvbSBcIi4vT2JqZWN0XCI7XHJcbmltcG9ydCB7IERpc3Bvc2VyLCBEaXNwb3NlckNsYXNzIH0gZnJvbSBcIi4vRGlzcG9zZXJcIjtcclxuLyoqXHJcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICogRE9NIEZVTkNUSU9OU1xyXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAqIEBoaWRkZW5cclxuICovXHJcbi8qKlxyXG4gKiBFeGVjdXRlIGEgZnVuY3Rpb24gd2hlbiBET00gaXMgcmVhZHkuXHJcbiAqXHJcbiAqIEBzaW5jZSA1LjAuMlxyXG4gKiBAcGFyYW0gIGYgIENhbGxiYWNrXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gcmVhZHkoZikge1xyXG4gICAgaWYgKGRvY3VtZW50LnJlYWR5U3RhdGUgIT09IFwibG9hZGluZ1wiKSB7XHJcbiAgICAgICAgZigpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgY29uc3QgbGlzdGVuZXIgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChkb2N1bWVudC5yZWFkeVN0YXRlICE9PSBcImxvYWRpbmdcIikge1xyXG4gICAgICAgICAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInJlYWR5c3RhdGVjaGFuZ2VcIiwgbGlzdGVuZXIpO1xyXG4gICAgICAgICAgICAgICAgZigpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwicmVhZHlzdGF0ZWNoYW5nZVwiLCBsaXN0ZW5lcik7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFJlbW92ZXMgYSBET00gZWxlbWVudC5cclxuICogQHBhcmFtICBlbCAgVGFyZ2V0IGVsZW1lbnRcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVFbGVtZW50KGVsKSB7XHJcbiAgICBpZiAoZWwucGFyZW50Tm9kZSkge1xyXG4gICAgICAgIGVsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZWwpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBGdW5jdGlvbiB0aGF0IGFkZHMgYSBkaXNwb3NhYmxlIGV2ZW50IGxpc3RlbmVyIGRpcmVjdGx5IHRvIGEgRE9NIGVsZW1lbnQuXHJcbiAqXHJcbiAqIEBpZ25vcmUgRXhjbHVkZSBmcm9tIGRvY3NcclxuICogQHBhcmFtIGRvbSAgICAgICBBIERPTSBlbGVtZW50IHRvIGFkZCBldmVudCB0b1xyXG4gKiBAcGFyYW0gdHlwZSAgICAgIEV2ZW50IHR5cGVcclxuICogQHBhcmFtIGxpc3RlbmVyICBFdmVudCBsaXN0ZW5lclxyXG4gKiBAcmV0dXJucyBEaXNwb3NhYmxlIGV2ZW50XHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gYWRkRXZlbnRMaXN0ZW5lcihkb20sIHR5cGUsIGxpc3RlbmVyLCBvcHRpb25zKSB7XHJcbiAgICAvL0B0b2RvIHByb3BlciB0eXBlIGNoZWNrIGZvciBvcHRpb25zOiBFdmVudExpc3RlbmVyT3B0aW9ucyB8IGJvb2xlYW4gKFRTIGZvciBzb21lIHJlYXNvbiBnaXZlcyBlcnJvciBvbiBwYXNzaXZlIHBhcmFtZXRlcilcclxuICAgIGRvbS5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyLCBvcHRpb25zIHx8IGZhbHNlKTtcclxuICAgIHJldHVybiBuZXcgRGlzcG9zZXIoKCkgPT4ge1xyXG4gICAgICAgIGRvbS5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyLCBvcHRpb25zIHx8IGZhbHNlKTtcclxuICAgIH0pO1xyXG59XHJcbi8qKlxyXG4gKiBGdW5jdGlvbiB0aGF0IGFkZHMgYW4gZXZlbnQgbGlzdGVuZXIgd2hpY2ggaXMgdHJpZ2dlcmVkIHdoZW4gdGhlIGJyb3dzZXIncyB6b29tIGNoYW5nZXMuXHJcbiAqXHJcbiAqIEBwYXJhbSBsaXN0ZW5lciAgRXZlbnQgbGlzdGVuZXJcclxuICogQHJldHVybnMgRGlzcG9zYWJsZSBldmVudFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIG9uWm9vbShsaXN0ZW5lcikge1xyXG4gICAgLy8gVE9ETyB1c2UgbWF0Y2hNZWRpYSBpbnN0ZWFkID9cclxuICAgIHJldHVybiBhZGRFdmVudExpc3RlbmVyKHdpbmRvdywgXCJyZXNpemVcIiwgKF9ldikgPT4ge1xyXG4gICAgICAgIGxpc3RlbmVyKCk7XHJcbiAgICB9KTtcclxufVxyXG4vKipcclxuICogQGlnbm9yZVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHN1cHBvcnRzKGNhcCkge1xyXG4gICAgc3dpdGNoIChjYXApIHtcclxuICAgICAgICBjYXNlIFwidG91Y2hldmVudHNcIjpcclxuICAgICAgICAgICAgLy9yZXR1cm4gXCJvbnRvdWNoc3RhcnRcIiBpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XHJcbiAgICAgICAgICAgIHJldHVybiB3aW5kb3cuaGFzT3duUHJvcGVydHkoXCJUb3VjaEV2ZW50XCIpO1xyXG4gICAgICAgIGNhc2UgXCJwb2ludGVyZXZlbnRzXCI6XHJcbiAgICAgICAgICAgIHJldHVybiB3aW5kb3cuaGFzT3duUHJvcGVydHkoXCJQb2ludGVyRXZlbnRcIik7XHJcbiAgICAgICAgY2FzZSBcIm1vdXNlZXZlbnRzXCI6XHJcbiAgICAgICAgICAgIHJldHVybiB3aW5kb3cuaGFzT3duUHJvcGVydHkoXCJNb3VzZUV2ZW50XCIpO1xyXG4gICAgICAgIGNhc2UgXCJ3aGVlbGV2ZW50c1wiOlxyXG4gICAgICAgICAgICByZXR1cm4gd2luZG93Lmhhc093blByb3BlcnR5KFwiV2hlZWxFdmVudFwiKTtcclxuICAgICAgICBjYXNlIFwia2V5Ym9hcmRldmVudHNcIjpcclxuICAgICAgICAgICAgcmV0dXJuIHdpbmRvdy5oYXNPd25Qcm9wZXJ0eShcIktleWJvYXJkRXZlbnRcIik7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbn1cclxuLyoqXHJcbiAqIEBpZ25vcmVcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRQb2ludGVySWQoZXZlbnQpIHtcclxuICAgIGxldCBpZCA9IGV2ZW50LnBvaW50ZXJJZCB8fCAwO1xyXG4gICAgcmV0dXJuIGlkO1xyXG59XHJcbi8qKlxyXG4gKiBSZW1vdmVzIGZvY3VzIGZyb20gYW55IGVsZW1lbnQgYnkgc2hpZnRpbmcgZm9jdXMgdG8gYm9keS5cclxuICpcclxuICogQGlnbm9yZVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGJsdXIoKSB7XHJcbiAgICBpZiAoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCAmJiBkb2N1bWVudC5hY3RpdmVFbGVtZW50ICE9IGRvY3VtZW50LmJvZHkpIHtcclxuICAgICAgICBpZiAoZG9jdW1lbnQuYWN0aXZlRWxlbWVudC5ibHVyKSB7XHJcbiAgICAgICAgICAgIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQuYmx1cigpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgbGV0IGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiKTtcclxuICAgICAgICAgICAgaW5wdXQuc3R5bGUucG9zaXRpb24gPSBcImZpeGVkXCI7XHJcbiAgICAgICAgICAgIGlucHV0LnN0eWxlLnRvcCA9IFwiMHB4XCI7XHJcbiAgICAgICAgICAgIGlucHV0LnN0eWxlLmxlZnQgPSBcIi0xMDAwMHB4XCI7XHJcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoaW5wdXQpO1xyXG4gICAgICAgICAgICBpbnB1dC5mb2N1cygpO1xyXG4gICAgICAgICAgICBpbnB1dC5ibHVyKCk7XHJcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoaW5wdXQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4vKipcclxuICogRm9jdXNlcyBlbGVtZW50LlxyXG4gKlxyXG4gKiBAaWdub3JlXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZm9jdXMoZWwpIHtcclxuICAgIGlmIChlbCkge1xyXG4gICAgICAgIGVsLmZvY3VzKCk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEBpZ25vcmVcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRSZW5kZXJlckV2ZW50KGtleSkge1xyXG4gICAgaWYgKHN1cHBvcnRzKFwicG9pbnRlcmV2ZW50c1wiKSkge1xyXG4gICAgICAgIHJldHVybiBrZXk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChzdXBwb3J0cyhcInRvdWNoZXZlbnRzXCIpKSB7XHJcbiAgICAgICAgc3dpdGNoIChrZXkpIHtcclxuICAgICAgICAgICAgY2FzZSBcInBvaW50ZXJvdmVyXCI6IHJldHVybiBcInRvdWNoc3RhcnRcIjtcclxuICAgICAgICAgICAgY2FzZSBcInBvaW50ZXJvdXRcIjogcmV0dXJuIFwidG91Y2hlbmRcIjtcclxuICAgICAgICAgICAgY2FzZSBcInBvaW50ZXJsZWF2ZVwiOiByZXR1cm4gXCJ0b3VjaGVuZFwiO1xyXG4gICAgICAgICAgICBjYXNlIFwicG9pbnRlcmRvd25cIjogcmV0dXJuIFwidG91Y2hzdGFydFwiO1xyXG4gICAgICAgICAgICBjYXNlIFwicG9pbnRlcm1vdmVcIjogcmV0dXJuIFwidG91Y2htb3ZlXCI7XHJcbiAgICAgICAgICAgIGNhc2UgXCJwb2ludGVydXBcIjogcmV0dXJuIFwidG91Y2hlbmRcIjtcclxuICAgICAgICAgICAgY2FzZSBcImNsaWNrXCI6IHJldHVybiBcImNsaWNrXCI7XHJcbiAgICAgICAgICAgIGNhc2UgXCJkYmxjbGlja1wiOiByZXR1cm4gXCJkYmxjbGlja1wiO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHN1cHBvcnRzKFwibW91c2VldmVudHNcIikpIHtcclxuICAgICAgICBzd2l0Y2ggKGtleSkge1xyXG4gICAgICAgICAgICBjYXNlIFwicG9pbnRlcm92ZXJcIjogcmV0dXJuIFwibW91c2VvdmVyXCI7XHJcbiAgICAgICAgICAgIGNhc2UgXCJwb2ludGVyb3V0XCI6IHJldHVybiBcIm1vdXNlb3V0XCI7XHJcbiAgICAgICAgICAgIGNhc2UgXCJwb2ludGVybGVhdmVcIjogcmV0dXJuIFwibW91c2VsZWF2ZVwiO1xyXG4gICAgICAgICAgICBjYXNlIFwicG9pbnRlcmRvd25cIjogcmV0dXJuIFwibW91c2Vkb3duXCI7XHJcbiAgICAgICAgICAgIGNhc2UgXCJwb2ludGVybW92ZVwiOiByZXR1cm4gXCJtb3VzZW1vdmVcIjtcclxuICAgICAgICAgICAgY2FzZSBcInBvaW50ZXJ1cFwiOiByZXR1cm4gXCJtb3VzZXVwXCI7XHJcbiAgICAgICAgICAgIGNhc2UgXCJjbGlja1wiOiByZXR1cm4gXCJjbGlja1wiO1xyXG4gICAgICAgICAgICBjYXNlIFwiZGJsY2xpY2tcIjogcmV0dXJuIFwiZGJsY2xpY2tcIjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4ga2V5O1xyXG59XHJcbi8qKlxyXG4gKiBEZXRlcm1pbmVzIGlmIHBvaW50ZXIgZXZlbnQgb3JpZ2luYXRlZCBmcm9tIGEgdG91Y2ggcG9pbnRlciBvciBtb3VzZS5cclxuICpcclxuICogQHBhcmFtIGV2ICBPcmlnaW5hbCBldmVudFxyXG4gKiBAcmV0dXJuIFRvdWNoIHBvaW50ZXI/XHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gaXNUb3VjaEV2ZW50KGV2KSB7XHJcbiAgICBpZiAodHlwZW9mIFRvdWNoICE9PSBcInVuZGVmaW5lZFwiICYmIGV2IGluc3RhbmNlb2YgVG91Y2gpIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHR5cGVvZiBQb2ludGVyRXZlbnQgIT09IFwidW5kZWZpbmVkXCIgJiYgZXYgaW5zdGFuY2VvZiBQb2ludGVyRXZlbnQgJiYgZXYucG9pbnRlclR5cGUgIT0gbnVsbCkge1xyXG4gICAgICAgIHN3aXRjaCAoZXYucG9pbnRlclR5cGUpIHtcclxuICAgICAgICAgICAgY2FzZSBcInRvdWNoXCI6XHJcbiAgICAgICAgICAgIGNhc2UgXCJwZW5cIjpcclxuICAgICAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIGNhc2UgXCJtb3VzZVwiOlxyXG4gICAgICAgICAgICBjYXNlIDQ6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gIShldiBpbnN0YW5jZW9mIE1vdXNlRXZlbnQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGV2LnR5cGUgIT0gbnVsbCkge1xyXG4gICAgICAgIGlmIChldi50eXBlLm1hdGNoKC9ebW91c2UvKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRydWU7XHJcbn1cclxuLyoqXHJcbiAqIFNldHMgc3R5bGUgcHJvcGVydHkgb24gRE9NIGVsZW1lbnQuXHJcbiAqXHJcbiAqIEBpZ25vcmUgRXhjbHVkZSBmcm9tIGRvY3NcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBzZXRTdHlsZShkb20sIHByb3BlcnR5LCB2YWx1ZSkge1xyXG4gICAgZG9tLnN0eWxlW3Byb3BlcnR5XSA9IHZhbHVlO1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRTdHlsZShkb20sIHByb3BlcnR5KSB7XHJcbiAgICByZXR1cm4gZG9tLnN0eWxlW3Byb3BlcnR5XTtcclxufVxyXG4vKipcclxuICogR2V0cyB0aGUgdGFyZ2V0IG9mIHRoZSBldmVudCwgd29ya3MgZm9yIHNoYWRvdyBET00gdG9vLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGdldEV2ZW50VGFyZ2V0KGV2ZW50KSB7XHJcbiAgICBpZiAoZXZlbnQuY29tcG9zZWRQYXRoKSB7XHJcbiAgICAgICAgY29uc3QgcGF0aCA9IGV2ZW50LmNvbXBvc2VkUGF0aCgpO1xyXG4gICAgICAgIGlmIChwYXRoLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBwYXRoWzBdO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBldmVudC50YXJnZXQ7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIENoZWNrcyBvZiBlbGVtZW50IGBhYCBjb250YWlucyBlbGVtZW50IGBiYC5cclxuICpcclxuICogQHBhcmFtIGEgIEFsZWdlZCBhc2NlbmRhbnRcclxuICogQHBhcmFtIGIgIEFsZWdlZCBkZXNjZW5kYW50XHJcbiAqIEByZXR1cm4gQ29udGFpbnM/XHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gY29udGFpbnMoYSwgYikge1xyXG4gICAgbGV0IGN1cnNvciA9IGI7XHJcbiAgICB3aGlsZSAodHJ1ZSkge1xyXG4gICAgICAgIGlmIChhID09PSBjdXJzb3IpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGN1cnNvci5wYXJlbnROb2RlID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIC8vIFRPRE8gYmV0dGVyIFNoYWRvd1Jvb3QgZGV0ZWN0aW9uXHJcbiAgICAgICAgICAgIGlmIChjdXJzb3IuaG9zdCA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjdXJzb3IgPSBjdXJzb3IuaG9zdDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY3Vyc29yID0gY3Vyc29yLnBhcmVudE5vZGU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm5zIGB0cnVlYCBpZiBwb2ludGVyIGV2ZW50IG9yaWdpbmF0ZWQgb24gYW4gZWxlbWVudCB3aXRoaW4gUm9vdC5cclxuICpcclxuICogQHNpbmNlIDUuMi44XHJcbiAqIEBwYXJhbSAgZXZlbnQgICBFdmVudFxyXG4gKiBAcGFyYW0gIHRhcmdldCAgVGFyZ2V0IGVsZW1lbnRcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBpc0xvY2FsRXZlbnQoZXZlbnQsIHRhcmdldCkge1xyXG4gICAgcmV0dXJuIGV2ZW50LnRhcmdldCAmJiBjb250YWlucyh0YXJnZXQucm9vdC5kb20sIGV2ZW50LnRhcmdldCk7XHJcbn1cclxuLyoqXHJcbiAqIERpc2FibGVzIG9yIGVuYWJsZXMgaW50ZXJhY3Rpdml0eSBvZiBhIERPTSBlbGVtZW50LlxyXG4gKlxyXG4gKiBAcGFyYW0gIHRhcmdldCAgICAgICBUYXJnZXQgZWxlbWVudFxyXG4gKiBAcGFyYW0gIGludGVyYWN0aXZlICBJbnRlcmFjdGl2ZT9cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBzZXRJbnRlcmFjdGl2ZSh0YXJnZXQsIGludGVyYWN0aXZlKSB7XHJcbiAgICBpZiAoaW50ZXJhY3RpdmUpIHtcclxuICAgICAgICB0YXJnZXQuc3R5bGUucG9pbnRlckV2ZW50cyA9IFwiYXV0b1wiO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgdGFyZ2V0LnN0eWxlLnBvaW50ZXJFdmVudHMgPSBcIm5vbmVcIjtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogUmV0dXJucyB0aGUgc2hhZG93IHJvb3Qgb2YgdGhlIGVsZW1lbnQgb3IgbnVsbFxyXG4gKlxyXG4gKiBAcGFyYW0gYSAgTm9kZVxyXG4gKiBAcmV0dXJuIFJvb3RcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRTaGFkb3dSb290KGEpIHtcclxuICAgIGxldCBjdXJzb3IgPSBhO1xyXG4gICAgd2hpbGUgKHRydWUpIHtcclxuICAgICAgICBpZiAoY3Vyc29yLnBhcmVudE5vZGUgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgLy8gVE9ETyBiZXR0ZXIgU2hhZG93Um9vdCBkZXRlY3Rpb25cclxuICAgICAgICAgICAgaWYgKGN1cnNvci5ob3N0ICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjdXJzb3I7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY3Vyc29yID0gY3Vyc29yLnBhcmVudE5vZGU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBbcm9vdFN0eWxlc2hlZXQgZGVzY3JpcHRpb25dXHJcbiAqXHJcbiAqIEBpZ25vcmUgRXhjbHVkZSBmcm9tIGRvY3NcclxuICogQHRvZG8gRGVzY3JpcHRpb25cclxuICovXHJcbmxldCByb290U3R5bGVzaGVldDtcclxuLyoqXHJcbiAqIEBpZ25vcmUgRXhjbHVkZSBmcm9tIGRvY3NcclxuICovXHJcbmZ1bmN0aW9uIGNyZWF0ZVN0eWxlc2hlZXQoZWxlbWVudCwgdGV4dCwgbm9uY2UgPSBcIlwiKSB7XHJcbiAgICAvLyBUT0RPIHVzZSBjcmVhdGVFbGVtZW50TlMgP1xyXG4gICAgY29uc3QgZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKTtcclxuICAgIGUudHlwZSA9IFwidGV4dC9jc3NcIjtcclxuICAgIGlmIChub25jZSAhPSBcIlwiKSB7XHJcbiAgICAgICAgZS5zZXRBdHRyaWJ1dGUoXCJub25jZVwiLCBub25jZSk7XHJcbiAgICB9XHJcbiAgICBlLnRleHRDb250ZW50ID0gdGV4dDtcclxuICAgIGlmIChlbGVtZW50ID09PSBudWxsKSB7XHJcbiAgICAgICAgZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChlKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGVsZW1lbnQuYXBwZW5kQ2hpbGQoZSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZTtcclxufVxyXG4vKipcclxuICogW2dldFN0eWxlc2hlZXQgZGVzY3JpcHRpb25dXHJcbiAqXHJcbiAqIEBpZ25vcmUgRXhjbHVkZSBmcm9tIGRvY3NcclxuICogQHRvZG8gRGVzY3JpcHRpb25cclxuICogQHJldHVybiBbZGVzY3JpcHRpb25dXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRTdHlsZXNoZWV0KGVsZW1lbnQsIG5vbmNlID0gXCJcIikge1xyXG4gICAgaWYgKGVsZW1lbnQgPT09IG51bGwpIHtcclxuICAgICAgICBpZiAocm9vdFN0eWxlc2hlZXQgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAvLyBUT0RPIHVzZSBjcmVhdGVFbGVtZW50TlMgP1xyXG4gICAgICAgICAgICBjb25zdCBlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO1xyXG4gICAgICAgICAgICBlLnR5cGUgPSBcInRleHQvY3NzXCI7XHJcbiAgICAgICAgICAgIGlmIChub25jZSAhPSBcIlwiKSB7XHJcbiAgICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShcIm5vbmNlXCIsIG5vbmNlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKGUpO1xyXG4gICAgICAgICAgICByb290U3R5bGVzaGVldCA9IGUuc2hlZXQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByb290U3R5bGVzaGVldDtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIC8vIFRPRE8gdXNlIGNyZWF0ZUVsZW1lbnROUyA/XHJcbiAgICAgICAgY29uc3QgZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKTtcclxuICAgICAgICBlLnR5cGUgPSBcInRleHQvY3NzXCI7XHJcbiAgICAgICAgaWYgKG5vbmNlICE9IFwiXCIpIHtcclxuICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoXCJub25jZVwiLCBub25jZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsZW1lbnQuYXBwZW5kQ2hpbGQoZSk7XHJcbiAgICAgICAgcmV0dXJuIGUuc2hlZXQ7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFttYWtlU3R5bGVzaGVldCBkZXNjcmlwdGlvbl1cclxuICpcclxuICogQGlnbm9yZSBFeGNsdWRlIGZyb20gZG9jc1xyXG4gKiBAdG9kbyBEZXNjcmlwdGlvblxyXG4gKiBAcGFyYW0gc2VsZWN0b3IgIFtkZXNjcmlwdGlvbl1cclxuICogQHJldHVybiBbZGVzY3JpcHRpb25dXHJcbiAqL1xyXG5mdW5jdGlvbiBhcHBlbmRTdHlsZXNoZWV0KHJvb3QsIHNlbGVjdG9yKSB7XHJcbiAgICBjb25zdCBpbmRleCA9IHJvb3QuY3NzUnVsZXMubGVuZ3RoO1xyXG4gICAgcm9vdC5pbnNlcnRSdWxlKHNlbGVjdG9yICsgXCJ7fVwiLCBpbmRleCk7XHJcbiAgICByZXR1cm4gcm9vdC5jc3NSdWxlc1tpbmRleF07XHJcbn1cclxuLyoqXHJcbiAqIERlZmluZXMgYSBjbGFzcyBmb3IgYSBDU1MgcnVsZS5cclxuICpcclxuICogQ2FuIGJlIHVzZWQgdG8gZHluYW1pY2FsbHkgYWRkIENTUyB0byB0aGUgZG9jdW1lbnQuXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgU3R5bGVSdWxlIGV4dGVuZHMgRGlzcG9zZXJDbGFzcyB7XHJcbiAgICAvKipcclxuICAgICAqIENvbnN0cnVjdG9yLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBzZWxlY3RvciAgQ1NTIHNlbGVjdG9yXHJcbiAgICAgKiBAcGFyYW0gc3R5bGVzICAgIEFuIG9iamVjdCBvZiBzdHlsZSBhdHRyaWJ1dGUgLSB2YWx1ZSBwYWlyc1xyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihlbGVtZW50LCBzZWxlY3Rvciwgc3R5bGVzLCBub25jZSA9IFwiXCIpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9yb290XCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENTUyBydWxlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9ydWxlXCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuX3Jvb3QgPSBnZXRTdHlsZXNoZWV0KGVsZW1lbnQsIG5vbmNlKTtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICB0aGlzLl9ydWxlID0gYXBwZW5kU3R5bGVzaGVldCh0aGlzLl9yb290LCBzZWxlY3Rvcik7XHJcbiAgICAgICAgICAgICRvYmplY3QuZWFjaChzdHlsZXMsIChrZXksIHZhbHVlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNldFN0eWxlKGtleSwgdmFsdWUpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGVycikge1xyXG4gICAgICAgICAgICAvLyBDcmVhdGUgYW4gZW1wdHkgcnVsZSBvbiBmYWlsZWQgc2VsZWN0b3JzXHJcbiAgICAgICAgICAgIHRoaXMuX3J1bGUgPSBuZXcgQ1NTU3R5bGVSdWxlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBIENTUyBzZWxlY3RvciB0ZXh0LlxyXG4gICAgICpcclxuICAgICAqIEUuZy46IGAubXlDbGFzcyBwYFxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBzZWxlY3RvciAgQ1NTIHNlbGVjdG9yXHJcbiAgICAgKi9cclxuICAgIHNldCBzZWxlY3RvcihzZWxlY3Rvcikge1xyXG4gICAgICAgIHRoaXMuX3J1bGUuc2VsZWN0b3JUZXh0ID0gc2VsZWN0b3I7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm4gQ1NTIHNlbGVjdG9yXHJcbiAgICAgKi9cclxuICAgIGdldCBzZWxlY3RvcigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fcnVsZS5zZWxlY3RvclRleHQ7XHJcbiAgICB9XHJcbiAgICAvLyBUT0RPIHRlc3QgdGhpc1xyXG4gICAgX2Rpc3Bvc2UoKSB7XHJcbiAgICAgICAgLy8gVE9ETyBhIGJpdCBoYWNreVxyXG4gICAgICAgIGNvbnN0IGluZGV4ID0gJGFycmF5LmluZGV4T2YodGhpcy5fcm9vdC5jc3NSdWxlcywgdGhpcy5fcnVsZSk7XHJcbiAgICAgICAgaWYgKGluZGV4ID09PSAtMSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgZGlzcG9zZSBTdHlsZVJ1bGVcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBUT0RPIGlmIGl0J3MgZW1wdHkgcmVtb3ZlIGl0IGZyb20gdGhlIERPTSA/XHJcbiAgICAgICAgICAgIHRoaXMuX3Jvb3QuZGVsZXRlUnVsZShpbmRleCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSBzYW1lIHN0eWxlIHByb3BlcnRpZXMgd2l0aCBicm93c2VyLXNwZWNpZmljIHByZWZpeGVzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBuYW1lICAgQXR0cmlidXRlIG5hbWVcclxuICAgICAqIEBwYXJhbSB2YWx1ZSAgQXR0cmlidXRlIHZhbHVlXHJcbiAgICAgKi9cclxuICAgIF9zZXRWZW5kb3JQcmVmaXhOYW1lKG5hbWUsIHZhbHVlKSB7XHJcbiAgICAgICAgY29uc3Qgc3R5bGUgPSB0aGlzLl9ydWxlLnN0eWxlO1xyXG4gICAgICAgIHN0eWxlLnNldFByb3BlcnR5KFwiLXdlYmtpdC1cIiArIG5hbWUsIHZhbHVlLCBcIlwiKTtcclxuICAgICAgICBzdHlsZS5zZXRQcm9wZXJ0eShcIi1tb3otXCIgKyBuYW1lLCB2YWx1ZSwgXCJcIik7XHJcbiAgICAgICAgc3R5bGUuc2V0UHJvcGVydHkoXCItbXMtXCIgKyBuYW1lLCB2YWx1ZSwgXCJcIik7XHJcbiAgICAgICAgc3R5bGUuc2V0UHJvcGVydHkoXCItby1cIiArIG5hbWUsIHZhbHVlLCBcIlwiKTtcclxuICAgICAgICBzdHlsZS5zZXRQcm9wZXJ0eShuYW1lLCB2YWx1ZSwgXCJcIik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNldHMgYSB2YWx1ZSBmb3Igc3BlY2lmaWMgc3R5bGUgYXR0cmlidXRlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBuYW1lICAgQXR0cmlidXRlXHJcbiAgICAgKiBAcGFyYW0gdmFsdWUgIFZhbHVlXHJcbiAgICAgKi9cclxuICAgIHNldFN0eWxlKG5hbWUsIHZhbHVlKSB7XHJcbiAgICAgICAgaWYgKG5hbWUgPT09IFwidHJhbnNpdGlvblwiKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3NldFZlbmRvclByZWZpeE5hbWUobmFtZSwgdmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5fcnVsZS5zdHlsZS5zZXRQcm9wZXJ0eShuYW1lLCB2YWx1ZSwgXCJcIik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBEZWZpbmVzIGEgY2xhc3MgZm9yIGFuIGVudGlyZSBDU1Mgc3R5bGUgc2hlZXQuXHJcbiAqXHJcbiAqIENhbiBiZSB1c2VkIHRvIGR5bmFtaWNhbGx5IGFkZCBDU1MgdG8gdGhlIGRvY3VtZW50LlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIFN0eWxlU2hlZXQgZXh0ZW5kcyBEaXNwb3NlckNsYXNzIHtcclxuICAgIC8qKlxyXG4gICAgICogQ29uc3RydWN0b3IuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHRleHQgIENTUyBzdHlsZXNoZWV0XHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKGVsZW1lbnQsIHRleHQsIG5vbmNlID0gXCJcIikge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX2VsZW1lbnRcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5fZWxlbWVudCA9IGNyZWF0ZVN0eWxlc2hlZXQoZWxlbWVudCwgdGV4dCwgbm9uY2UpO1xyXG4gICAgfVxyXG4gICAgX2Rpc3Bvc2UoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2VsZW1lbnQucGFyZW50Tm9kZSkge1xyXG4gICAgICAgICAgICB0aGlzLl9lbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5fZWxlbWVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBBZGRzIGEgY2xhc3MgbmFtZSB0byBhbiBIVE1MIG9yIFNWRyBlbGVtZW50LlxyXG4gKlxyXG4gKiBAaWdub3JlIEV4Y2x1ZGUgZnJvbSBkb2NzXHJcbiAqIEBwYXJhbSBlbGVtZW50ICAgIEVsZW1lbnRcclxuICogQHBhcmFtIGNsYXNzTmFtZSAgQ2xhc3MgbmFtZSB0byBhZGRcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBhZGRDbGFzcyhlbGVtZW50LCBjbGFzc05hbWUpIHtcclxuICAgIGlmICghZWxlbWVudCkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGlmIChlbGVtZW50LmNsYXNzTGlzdCkge1xyXG4gICAgICAgIGNvbnN0IGNsYXNzZXMgPSBjbGFzc05hbWUuc3BsaXQoXCIgXCIpO1xyXG4gICAgICAgICRhcnJheS5lYWNoKGNsYXNzZXMsIChuYW1lKSA9PiB7XHJcbiAgICAgICAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LmFkZChuYW1lKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGxldCBjdXJyZW50Q2xhc3NOYW1lID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJjbGFzc1wiKTtcclxuICAgICAgICBpZiAoY3VycmVudENsYXNzTmFtZSkge1xyXG4gICAgICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShcImNsYXNzXCIsIGN1cnJlbnRDbGFzc05hbWUuc3BsaXQoXCIgXCIpLmZpbHRlcigoaXRlbSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW0gIT09IGNsYXNzTmFtZTtcclxuICAgICAgICAgICAgfSkuam9pbihcIiBcIikgKyBcIiBcIiArIGNsYXNzTmFtZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShcImNsYXNzXCIsIGNsYXNzTmFtZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBSZW1vdmVzIGEgY2xhc3MgbmFtZSBmcm9tIGFuIEhUTUwgb3IgU1ZHIGVsZW1lbnQuXHJcbiAqXHJcbiAqIEBpZ25vcmUgRXhjbHVkZSBmcm9tIGRvY3NcclxuICogQHBhcmFtIGVsZW1lbnQgICAgRWxlbWVudFxyXG4gKiBAcGFyYW0gY2xhc3NOYW1lICBDbGFzcyBuYW1lIHRvIGFkZFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZUNsYXNzKGVsZW1lbnQsIGNsYXNzTmFtZSkge1xyXG4gICAgaWYgKCFlbGVtZW50KSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgaWYgKGVsZW1lbnQuY2xhc3NMaXN0KSB7XHJcbiAgICAgICAgZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKGNsYXNzTmFtZSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBsZXQgY3VycmVudENsYXNzTmFtZSA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKFwiY2xhc3NcIik7XHJcbiAgICAgICAgaWYgKGN1cnJlbnRDbGFzc05hbWUpIHtcclxuICAgICAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCBjdXJyZW50Q2xhc3NOYW1lLnNwbGl0KFwiIFwiKS5maWx0ZXIoKGl0ZW0pID0+IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtICE9PSBjbGFzc05hbWU7XHJcbiAgICAgICAgICAgIH0pLmpvaW4oXCIgXCIpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuLy8gLyoqXHJcbi8vICAqIEFwcGxpZXMgYSBzZXQgb2Ygc3R5bGVzIHRvIGFuIGVsZW1lbnQuIFN0b3JlcyB0aGUgb3JpZ2luYWwgc3R5bGVzIHNvIHRoZXlcclxuLy8gICogY2FuIGJlIHJlc3RvcmVkIGxhdGVyLlxyXG4vLyAgKlxyXG4vLyAgKiBAaWdub3JlXHJcbi8vICAqIEBwYXJhbSBpbyAgICAgIEVsZW1lbnRcclxuLy8gICAqL1xyXG4vLyBleHBvcnQgZnVuY3Rpb24gcHJlcEVsZW1lbnRGb3JEcmFnKGRvbTogSFRNTEVsZW1lbnQpOiB2b2lkIHtcclxuLy8gXHQvLyBAdG9kbzogc2F2ZSBjdXJyZW50IHZhbHVlc1xyXG4vLyBcdC8vIERlZmluZSBwb3NzaWJsZSBwcm9wc1xyXG4vLyBcdGxldCBwcm9wcyA9IFtcclxuLy8gXHRcdFwidG91Y2hBY3Rpb25cIiwgXCJ3ZWJraXRUb3VjaEFjdGlvblwiLCBcIk1velRvdWNoQWN0aW9uXCIsIFwiTVNUb3VjaEFjdGlvblwiLCBcIm1zVG91Y2hBY3Rpb25cIiwgXCJvVG91Y2hBY3Rpb25cIixcclxuLy8gXHRcdFwidXNlclNlbGVjdFwiLCBcIndlYmtpdFVzZXJTZWxlY3RcIiwgXCJNb3pVc2VyU2VsZWN0XCIsIFwiTVNVc2VyU2VsZWN0XCIsIFwibXNVc2VyU2VsZWN0XCIsIFwib1VzZXJTZWxlY3RcIixcclxuLy8gXHRcdFwidG91Y2hTZWxlY3RcIiwgXCJ3ZWJraXRUb3VjaFNlbGVjdFwiLCBcIk1velRvdWNoU2VsZWN0XCIsIFwiTVNUb3VjaFNlbGVjdFwiLCBcIm1zVG91Y2hTZWxlY3RcIiwgXCJvVG91Y2hTZWxlY3RcIixcclxuLy8gXHRcdFwidG91Y2hDYWxsb3V0XCIsIFwid2Via2l0VG91Y2hDYWxsb3V0XCIsIFwiTW96VG91Y2hDYWxsb3V0XCIsIFwiTVNUb3VjaENhbGxvdXRcIiwgXCJtc1RvdWNoQ2FsbG91dFwiLCBcIm9Ub3VjaENhbGxvdXRcIixcclxuLy8gXHRcdFwiY29udGVudFpvb21pbmdcIiwgXCJ3ZWJraXRDb250ZW50Wm9vbWluZ1wiLCBcIk1vekNvbnRlbnRab29taW5nXCIsIFwiTVNDb250ZW50Wm9vbWluZ1wiLCBcIm1zQ29udGVudFpvb21pbmdcIiwgXCJvQ29udGVudFpvb21pbmdcIixcclxuLy8gXHRcdFwidXNlckRyYWdcIiwgXCJ3ZWJraXRVc2VyRHJhZ1wiLCBcIk1velVzZXJEcmFnXCIsIFwiTVNVc2VyRHJhZ1wiLCBcIm1zVXNlckRyYWdcIiwgXCJvVXNlckRyYWdcIlxyXG4vLyBcdF07XHJcbi8vIFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xyXG4vLyBcdFx0aWYgKHByb3BzW2ldIGluIGRvbS5zdHlsZSkge1xyXG4vLyBcdFx0XHRzZXRTdHlsZShkb20sIHByb3BzW2ldLCBcIm5vbmVcIik7XHJcbi8vIFx0XHR9XHJcbi8vIFx0fVxyXG4vLyBcdC8vIFJlbW92ZSBpT1Mtc3BlY2lmaWMgc2VsZWN0aW9uO1xyXG4vLyBcdHNldFN0eWxlKGRvbSwgXCJ0YXBIaWdobGlnaHRDb2xvclwiLCBcInJnYmEoMCwgMCwgMCwgMClcIik7XHJcbi8vIH1cclxuLy8gLyoqXHJcbi8vICAqIFJlc3RvcmVzIHJlcGxhY2VkIHN0eWxlc1xyXG4vLyAgKlxyXG4vLyAgKiBAaWdub3JlXHJcbi8vICAqIEBwYXJhbSAgaW8gIEVsZW1lbnRcclxuLy8gICovXHJcbi8vIGV4cG9ydCBmdW5jdGlvbiB1bnByZXBFbGVtZW50Rm9yRHJhZyhkb206IEhUTUxFbGVtZW50KTogdm9pZCB7XHJcbi8vIFx0Ly8gRGVmaW5lIHBvc3NpYmxlIHByb3BzXHJcbi8vIFx0bGV0IHByb3BzID0gW1xyXG4vLyBcdFx0XCJ0b3VjaEFjdGlvblwiLCBcIndlYmtpdFRvdWNoQWN0aW9uXCIsIFwiTW96VG91Y2hBY3Rpb25cIiwgXCJNU1RvdWNoQWN0aW9uXCIsIFwibXNUb3VjaEFjdGlvblwiLCBcIm9Ub3VjaEFjdGlvblwiLFxyXG4vLyBcdFx0XCJ1c2VyU2VsZWN0XCIsIFwid2Via2l0VXNlclNlbGVjdFwiLCBcIk1velVzZXJTZWxlY3RcIiwgXCJNU1VzZXJTZWxlY3RcIiwgXCJtc1VzZXJTZWxlY3RcIiwgXCJvVXNlclNlbGVjdFwiLFxyXG4vLyBcdFx0XCJ0b3VjaFNlbGVjdFwiLCBcIndlYmtpdFRvdWNoU2VsZWN0XCIsIFwiTW96VG91Y2hTZWxlY3RcIiwgXCJNU1RvdWNoU2VsZWN0XCIsIFwibXNUb3VjaFNlbGVjdFwiLCBcIm9Ub3VjaFNlbGVjdFwiLFxyXG4vLyBcdFx0XCJ0b3VjaENhbGxvdXRcIiwgXCJ3ZWJraXRUb3VjaENhbGxvdXRcIiwgXCJNb3pUb3VjaENhbGxvdXRcIiwgXCJNU1RvdWNoQ2FsbG91dFwiLCBcIm1zVG91Y2hDYWxsb3V0XCIsIFwib1RvdWNoQ2FsbG91dFwiLFxyXG4vLyBcdFx0XCJjb250ZW50Wm9vbWluZ1wiLCBcIndlYmtpdENvbnRlbnRab29taW5nXCIsIFwiTW96Q29udGVudFpvb21pbmdcIiwgXCJNU0NvbnRlbnRab29taW5nXCIsIFwibXNDb250ZW50Wm9vbWluZ1wiLCBcIm9Db250ZW50Wm9vbWluZ1wiLFxyXG4vLyBcdFx0XCJ1c2VyRHJhZ1wiLCBcIndlYmtpdFVzZXJEcmFnXCIsIFwiTW96VXNlckRyYWdcIiwgXCJNU1VzZXJEcmFnXCIsIFwibXNVc2VyRHJhZ1wiLCBcIm9Vc2VyRHJhZ1wiXHJcbi8vIFx0XTtcclxuLy8gXHRmb3IgKGxldCBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XHJcbi8vIFx0XHRpZiAocHJvcHNbaV0gaW4gZG9tLnN0eWxlKSB7XHJcbi8vIFx0XHRcdHNldFN0eWxlKGRvbSwgcHJvcHNbaV0sIFwiXCIpO1xyXG4vLyBcdFx0fVxyXG4vLyBcdH1cclxuLy8gXHQvLyBSZW1vdmUgaU9TLXNwZWNpZmljIHNlbGVjdGlvbjtcclxuLy8gXHRzZXRTdHlsZShkb20sIFwidGFwSGlnaGxpZ2h0Q29sb3JcIiwgXCJcIik7XHJcbi8vIH1cclxuZXhwb3J0IGZ1bmN0aW9uIGlPUygpIHtcclxuICAgIHJldHVybiAvYXBwbGUvaS50ZXN0KG5hdmlnYXRvci52ZW5kb3IpICYmIFwib250b3VjaGVuZFwiIGluIGRvY3VtZW50O1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRTYWZlUmVzb2x1dGlvbigpIHtcclxuICAgIHJldHVybiBpT1MoKSA/IDEgOiB1bmRlZmluZWQ7XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIHJlbGF0aXZlVG9WYWx1ZShwZXJjZW50LCBmdWxsKSB7XHJcbiAgICBpZiAoJHR5cGUuaXNOdW1iZXIocGVyY2VudCkpIHtcclxuICAgICAgICByZXR1cm4gcGVyY2VudDtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHBlcmNlbnQgIT0gbnVsbCAmJiAkdHlwZS5pc051bWJlcihwZXJjZW50LnZhbHVlKSAmJiAkdHlwZS5pc051bWJlcihmdWxsKSkge1xyXG4gICAgICAgIHJldHVybiBmdWxsICogcGVyY2VudC52YWx1ZTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiAwO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm5zIG51bWJlciBvZiBkZWNpbWFsc1xyXG4gKlxyXG4gKiBAaWdub3JlIEV4Y2x1ZGUgZnJvbSBkb2NzXHJcbiAqIEBwYXJhbSBudW1iZXIgIElucHV0IG51bWJlclxyXG4gKiBAcmV0dXJuIE51bWJlciBvZiBkZWNpbWFsc1xyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGRlY2ltYWxQbGFjZXMobnVtYmVyKSB7XHJcbiAgICBsZXQgbWF0Y2ggPSAoJycgKyBudW1iZXIpLm1hdGNoKC8oPzpcXC4oXFxkKykpPyg/OltlRV0oWystXT9cXGQrKSk/JC8pO1xyXG4gICAgaWYgKCFtYXRjaCkge1xyXG4gICAgICAgIHJldHVybiAwO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIE1hdGgubWF4KDAsIChtYXRjaFsxXSA/IG1hdGNoWzFdLmxlbmd0aCA6IDApIC0gKG1hdGNoWzJdID8gK21hdGNoWzJdIDogMCkpO1xyXG59XHJcbi8qKlxyXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAqIFNUUklORyBGT1JNQVRUSU5HIEZVTkNUSU9OU1xyXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAqIEBoaWRkZW5cclxuICovXHJcbi8qKlxyXG4gKiBQYWRzIGEgc3RyaW5nIHdpdGggYWRkaXRpb25hbCBjaGFyYWN0ZXJzIHRvIGNlcnRhaW4gbGVuZ3RoLlxyXG4gKlxyXG4gKiBAcGFyYW0gdmFsdWUgIEEgbnVtZXJpYyB2YWx1ZVxyXG4gKiBAcGFyYW0gbGVuICAgIFJlc3VsdCBzdHJpbmcgbGVuZ3RoIGluIGNoYXJhY3RlcnNcclxuICogQHBhcmFtIGNoYXIgICBBIGNoYXJhY3RlciB0byB1c2UgZm9yIHBhZGRpbmdcclxuICogQHJldHVybiBQYWRkZWQgdmFsdWUgYXMgc3RyaW5nXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gcGFkU3RyaW5nKHZhbHVlLCBsZW4gPSAwLCBjaGFyID0gXCIwXCIpIHtcclxuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09IFwic3RyaW5nXCIpIHtcclxuICAgICAgICB2YWx1ZSA9IHZhbHVlLnRvU3RyaW5nKCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbGVuID4gdmFsdWUubGVuZ3RoID8gQXJyYXkobGVuIC0gdmFsdWUubGVuZ3RoICsgMSkuam9pbihjaGFyKSArIHZhbHVlIDogdmFsdWU7XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIHRyaW1MZWZ0KHRleHQpIHtcclxuICAgIHJldHVybiB0ZXh0LnJlcGxhY2UoL15bXFxzXSovLCBcIlwiKTtcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gdHJpbVJpZ2h0KHRleHQpIHtcclxuICAgIHJldHVybiB0ZXh0LnJlcGxhY2UoL1tcXHNdKiQvLCBcIlwiKTtcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gdHJpbSh0ZXh0KSB7XHJcbiAgICByZXR1cm4gdHJpbUxlZnQodHJpbVJpZ2h0KHRleHQpKTtcclxufVxyXG4vKipcclxuICogVHJpZXMgdG8gZGV0ZXJtaW5lIGZvcm1hdCB0eXBlLlxyXG4gKlxyXG4gKiBAaWdub3JlIEV4Y2x1ZGUgZnJvbSBkb2NzXHJcbiAqIEBwYXJhbSBmb3JtYXQgIEZvcm1hdCBzdHJpbmdcclxuICogQHJldHVybiBGb3JtYXQgdHlwZSAoXCJzdHJpbmdcIiB8IFwibnVtYmVyXCIgfCBcImRhdGVcIiB8IFwiZHVyYXRpb25cIilcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRGb3JtYXQoZm9ybWF0KSB7XHJcbiAgICAvLyBVbmRlZmluZWQ/XHJcbiAgICBpZiAodHlwZW9mIGZvcm1hdCA9PT0gXCJ1bmRlZmluZWRcIikge1xyXG4gICAgICAgIHJldHVybiBcInN0cmluZ1wiO1xyXG4gICAgfVxyXG4gICAgLy8gQ2xlYW51cCBhbmQgbG93ZXJjYXNlIGZvcm1hdFxyXG4gICAgZm9ybWF0ID0gZm9ybWF0LnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvXlxcW1teXFxdXSpcXF0vLCBcIlwiKTtcclxuICAgIC8vIFJlbW92ZSBzdHlsZSB0YWdzXHJcbiAgICBmb3JtYXQgPSBmb3JtYXQucmVwbGFjZSgvXFxbW15cXF1dK1xcXS8sIFwiXCIpO1xyXG4gICAgLy8gVHJpbVxyXG4gICAgZm9ybWF0ID0gZm9ybWF0LnRyaW0oKTtcclxuICAgIC8vIENoZWNrIGZvciBhbnkgZXhwbGljaXQgZm9ybWF0IGhpbnRzIChpLmUuIC9EYXRlKVxyXG4gICAgbGV0IGhpbnRzID0gZm9ybWF0Lm1hdGNoKC9cXC8oZGF0ZXxudW1iZXJ8ZHVyYXRpb24pJC8pO1xyXG4gICAgaWYgKGhpbnRzKSB7XHJcbiAgICAgICAgcmV0dXJuIGhpbnRzWzFdO1xyXG4gICAgfVxyXG4gICAgLy8gQ2hlY2sgZm9yIGV4cGxpY2l0IGhpbnRzXHJcbiAgICBpZiAoZm9ybWF0ID09PSBcIm51bWJlclwiKSB7XHJcbiAgICAgICAgcmV0dXJuIFwibnVtYmVyXCI7XHJcbiAgICB9XHJcbiAgICBpZiAoZm9ybWF0ID09PSBcImRhdGVcIikge1xyXG4gICAgICAgIHJldHVybiBcImRhdGVcIjtcclxuICAgIH1cclxuICAgIGlmIChmb3JtYXQgPT09IFwiZHVyYXRpb25cIikge1xyXG4gICAgICAgIHJldHVybiBcImR1cmF0aW9uXCI7XHJcbiAgICB9XHJcbiAgICAvLyBEZXRlY3QgbnVtYmVyIGZvcm1hdHRpbmcgc3ltYm9sc1xyXG4gICAgaWYgKGZvcm1hdC5tYXRjaCgvWyMwXS8pKSB7XHJcbiAgICAgICAgcmV0dXJuIFwibnVtYmVyXCI7XHJcbiAgICB9XHJcbiAgICAvLyBEZXRlY3QgZGF0ZSBmb3JtYXR0aW5nIHN5bWJvbHNcclxuICAgIGlmIChmb3JtYXQubWF0Y2goL1t5bXdkaG5zcWF4a3pndGVpXS8pKSB7XHJcbiAgICAgICAgcmV0dXJuIFwiZGF0ZVwiO1xyXG4gICAgfVxyXG4gICAgLy8gTm90aGluZz8gTGV0J3MgZGlzcGxheSBhcyBzdHJpbmdcclxuICAgIHJldHVybiBcInN0cmluZ1wiO1xyXG59XHJcbi8qKlxyXG4gKiBDbGVhbnMgdXAgZm9ybWF0OlxyXG4gKiAqIFN0cmlwcyBvdXQgZm9ybWF0dGVyIGhpbnRzXHJcbiAqXHJcbiAqIEBpZ25vcmUgRXhjbHVkZSBmcm9tIGRvY3NcclxuICogQHBhcmFtIGZvcm1hdCAgRm9ybWF0XHJcbiAqIEByZXR1cm4gQ2xlYW5lZCBmb3JtYXRcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBjbGVhbkZvcm1hdChmb3JtYXQpIHtcclxuICAgIHJldHVybiBmb3JtYXQucmVwbGFjZSgvXFwvKGRhdGV8bnVtYmVyfGR1cmF0aW9uKSQvaSwgXCJcIik7XHJcbn1cclxuLyoqXHJcbiAqIFN0cmlwcyBhbGwgdGFncyBmcm9tIHRoZSBzdHJpbmcuXHJcbiAqXHJcbiAqIEBwYXJhbSB0ZXh0ICBTb3VyY2Ugc3RyaW5nXHJcbiAqIEByZXR1cm4gU3RyaW5nIHdpdGhvdXQgdGFnc1xyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHN0cmlwVGFncyh0ZXh0KSB7XHJcbiAgICByZXR1cm4gdGV4dCA/IHRleHQucmVwbGFjZSgvPFtePl0qPi9nLCBcIlwiKSA6IHRleHQ7XHJcbn1cclxuLyoqXHJcbiAqIFJlbW92ZXMgbmV3IGxpbmVzIGFuZCB0YWdzIGZyb20gYSBzdHJpbmcuXHJcbiAqXHJcbiAqIEBwYXJhbSB0ZXh0ICBTdHJpbmcgdG8gY29udmVyXHJcbiAqIEByZXR1cm4gQ29udmVydGVkIHN0cmluZ1xyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHBsYWluVGV4dCh0ZXh0KSB7XHJcbiAgICByZXR1cm4gdGV4dCA/IHN0cmlwVGFncygoXCJcIiArIHRleHQpLnJlcGxhY2UoL1tcXG5cXHJdKy9nLCBcIi4gXCIpKSA6IHRleHQ7XHJcbn1cclxuLyoqXHJcbiAqIEVzY2FwZXMgc3RyaW5nIHNvIGl0IGNhbiBzYWZlbHkgYmUgdXNlZCBpbiBhIFJlZ2V4LlxyXG4gKlxyXG4gKiBAcGFyYW0gdmFsdWUgIFVuc2VzY2FwZWQgc3RyaW5nXHJcbiAqIEByZXR1cm4gRXNjYXBlZCBzdHJpbmdcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBlc2NhcGVGb3JSZ2V4KHZhbHVlKSB7XHJcbiAgICByZXR1cm4gdmFsdWUucmVwbGFjZSgvWy1bXFxde30oKSorPy4sXFxcXF4kfCNcXHNdL2csICdcXFxcJCYnKTtcclxufVxyXG4vKipcclxuICogQWRkcyBzcGFjZSBiZWZvcmUgZWFjaCB1cHBlcmNhc2UgbGV0dGVyLlxyXG4gKlxyXG4gKiBAcGFyYW0gICBzdHIgSW5wdXQgc3RyaW5nXHJcbiAqIEByZXR1cm4gICAgICBPdXRwdXQgc3RyaW5nXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gYWRkU3BhY2luZyhzdHIpIHtcclxuICAgIGxldCByZXN1bHQgPSBcIlwiO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjb25zdCBjaGFyID0gc3RyLmNoYXJBdChpKTtcclxuICAgICAgICBpZiAoY2hhci50b1VwcGVyQ2FzZSgpID09IGNoYXIgJiYgaSAhPSAwKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdCArPSBcIiBcIjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmVzdWx0ICs9IGNoYXI7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcbi8qKlxyXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAqIERBVEUtUkVMQVRFRCBGVU5DVElPTlNcclxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4gKiBAaGlkZGVuXHJcbiAqL1xyXG4vKipcclxuICogUmV0dXJucyBhIHllYXIgZGF5LlxyXG4gKlxyXG4gKiBAcGFyYW0gZGF0ZSAgRGF0ZVxyXG4gKiBAcGFyYW0gdXRjICAgQXNzdW1lIFVUQyBkYXRlcz9cclxuICogQHJldHVybiBZZWFyIGRheVxyXG4gKiBAdG9kbyBBY2NvdW50IGZvciBVVENcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRZZWFyRGF5KGRhdGUsIHV0YyA9IGZhbHNlKSB7XHJcbiAgICAvLyBUT0RPOiB1dGMgbmVlZGVkP1xyXG4gICAgdXRjO1xyXG4gICAgY29uc3Qgc3RhcnQgPSBuZXcgRGF0ZShkYXRlLmdldEZ1bGxZZWFyKCksIDAsIDApO1xyXG4gICAgY29uc3QgZGlmZiA9IChkYXRlLmdldFRpbWUoKSAtIHN0YXJ0LmdldFRpbWUoKSkgKyAoKHN0YXJ0LmdldFRpbWV6b25lT2Zmc2V0KCkgLSBkYXRlLmdldFRpbWV6b25lT2Zmc2V0KCkpICogNjAgKiAxMDAwKTtcclxuICAgIGNvbnN0IG9uZURheSA9IDEwMDAgKiA2MCAqIDYwICogMjQ7XHJcbiAgICByZXR1cm4gTWF0aC5mbG9vcihkaWZmIC8gb25lRGF5KTtcclxufVxyXG4vKipcclxuICogUmV0dXJucyB3ZWVrIG51bWJlciBmb3IgYSBnaXZlbiBkYXRlLlxyXG4gKlxyXG4gKiBAcGFyYW0gZGF0ZSAgRGF0ZVxyXG4gKiBAcGFyYW0gdXRjICAgQXNzdW1lIFVUQyBkYXRlcz9cclxuICogQHJldHVybiBXZWVrIG51bWJlclxyXG4gKiBAdG9kbyBBY2NvdW50IGZvciBVVENcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRXZWVrKGRhdGUsIF91dGMgPSBmYWxzZSkge1xyXG4gICAgY29uc3QgZCA9IG5ldyBEYXRlKERhdGUuVVRDKGRhdGUuZ2V0RnVsbFllYXIoKSwgZGF0ZS5nZXRNb250aCgpLCBkYXRlLmdldERhdGUoKSkpO1xyXG4gICAgY29uc3QgZGF5ID0gZC5nZXRVVENEYXkoKSB8fCA3O1xyXG4gICAgZC5zZXRVVENEYXRlKGQuZ2V0VVRDRGF0ZSgpICsgNCAtIGRheSk7XHJcbiAgICBjb25zdCBmaXJzdERheSA9IG5ldyBEYXRlKERhdGUuVVRDKGQuZ2V0VVRDRnVsbFllYXIoKSwgMCwgMSkpO1xyXG4gICAgcmV0dXJuIE1hdGguY2VpbCgoKChkLmdldFRpbWUoKSAtIGZpcnN0RGF5LmdldFRpbWUoKSkgLyA4NjQwMDAwMCkgKyAxKSAvIDcpO1xyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm5zIGEgXCJ3ZWVrIHllYXJcIiBvZiB0aGUgZ2l2ZW4gZGF0ZS5cclxuICpcclxuICogQHBhcmFtIGRhdGUgIERhdGVcclxuICogQHBhcmFtIHV0YyAgIEFzc3VtZSBVVEMgZGF0ZXM/XHJcbiAqIEByZXR1cm4gWWVhciBvZiB3ZWVrXHJcbiAqIEBzaW5jZSA1LjMuMFxyXG4gKiBAdG9kbyBBY2NvdW50IGZvciBVVENcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRXZWVrWWVhcihkYXRlLCBfdXRjID0gZmFsc2UpIHtcclxuICAgIGNvbnN0IGQgPSBuZXcgRGF0ZShEYXRlLlVUQyhkYXRlLmdldEZ1bGxZZWFyKCksIGRhdGUuZ2V0TW9udGgoKSwgZGF0ZS5nZXREYXRlKCkpKTtcclxuICAgIGNvbnN0IGRheSA9IGQuZ2V0VVRDRGF5KCkgfHwgNztcclxuICAgIGQuc2V0VVRDRGF0ZShkLmdldFVUQ0RhdGUoKSArIDQgLSBkYXkpO1xyXG4gICAgY29uc3QgZmlyc3REYXkgPSBuZXcgRGF0ZShEYXRlLlVUQyhkLmdldFVUQ0Z1bGxZZWFyKCksIDAsIDEpKTtcclxuICAgIHJldHVybiBmaXJzdERheS5nZXRGdWxsWWVhcigpO1xyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm5zIGEgd2VlayBudW1iZXIgaW4gdGhlIG1vbnRoLlxyXG4gKlxyXG4gKiBAcGFyYW0gZGF0ZSAgU291cmNlIERhdGVcclxuICogQHBhcmFtIHV0YyAgIEFzc3VtZSBVVEMgZGF0ZXM/XHJcbiAqIEByZXR1cm4gV2VlayBudW1iZXIgaW4gbW9udGhcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRNb250aFdlZWsoZGF0ZSwgdXRjID0gZmFsc2UpIHtcclxuICAgIGNvbnN0IGZpcnN0V2VlayA9IGdldFdlZWsobmV3IERhdGUoZGF0ZS5nZXRGdWxsWWVhcigpLCBkYXRlLmdldE1vbnRoKCksIDEpLCB1dGMpO1xyXG4gICAgbGV0IGN1cnJlbnRXZWVrID0gZ2V0V2VlayhkYXRlLCB1dGMpO1xyXG4gICAgaWYgKGN1cnJlbnRXZWVrID09IDEpIHtcclxuICAgICAgICBjdXJyZW50V2VlayA9IDUzO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGN1cnJlbnRXZWVrIC0gZmlyc3RXZWVrICsgMTtcclxufVxyXG4vKipcclxuICogUmV0dXJucyBhIHllYXIgZGF5IG91dCBvZiB0aGUgZ2l2ZW4gd2VlayBudW1iZXIuXHJcbiAqXHJcbiAqIEBwYXJhbSB3ZWVrICAgICBXZWVrXHJcbiAqIEBwYXJhbSB5ZWFyICAgICBZZWFyXHJcbiAqIEBwYXJhbSB3ZWVrZGF5ICBXZWVrZGF5XHJcbiAqIEBwYXJhbSB1dGMgICAgICBBc3N1bWUgVVRDIGRhdGVzXHJcbiAqIEByZXR1cm4gRGF5IGluIGEgeWVhclxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGdldERheUZyb21XZWVrKHdlZWssIHllYXIsIHdlZWtkYXkgPSAxLCB1dGMgPSBmYWxzZSkge1xyXG4gICAgbGV0IGRhdGUgPSBuZXcgRGF0ZSh5ZWFyLCAwLCA0LCAwLCAwLCAwLCAwKTtcclxuICAgIGlmICh1dGMpIHtcclxuICAgICAgICBkYXRlLnNldFVUQ0Z1bGxZZWFyKHllYXIpO1xyXG4gICAgfVxyXG4gICAgbGV0IGRheSA9IHdlZWsgKiA3ICsgd2Vla2RheSAtICgoZGF0ZS5nZXREYXkoKSB8fCA3KSArIDMpO1xyXG4gICAgcmV0dXJuIGRheTtcclxufVxyXG4vKipcclxuICogUmV0dXJucyAxMi1ob3VyIHJlcHJlc2VudGF0aW9uIG91dCBvZiB0aGUgMjQtaG91ciBob3Vycy5cclxuICpcclxuICogQHBhcmFtIGhvdXJzICAyNC1ob3VyIG51bWJlclxyXG4gKiBAcmV0dXJuIDEyLWhvdXIgbnVtYmVyXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ2V0MTJIb3Vycyhob3VycywgYmFzZSkge1xyXG4gICAgaWYgKGhvdXJzID4gMTIpIHtcclxuICAgICAgICBob3VycyAtPSAxMjtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGhvdXJzID09PSAwKSB7XHJcbiAgICAgICAgaG91cnMgPSAxMjtcclxuICAgIH1cclxuICAgIHJldHVybiBiYXNlICE9IG51bGwgPyBob3VycyArIChiYXNlIC0gMSkgOiBob3VycztcclxufVxyXG4vKipcclxuICogUmV0dXJucyBhIHN0cmluZyBuYW1lIG9mIHRoZSB0aW1lIHpvbmUuXHJcbiAqXHJcbiAqIEBwYXJhbSBkYXRlICAgICBEYXRlIG9iamVjdFxyXG4gKiBAcGFyYW0gbG9uZyAgICAgU2hvdWxkIHJldHVybiBsb25nIChcIlBhY2lmaWMgU3RhbmRhcmQgVGltZVwiKSBvciBzaG9ydCBhYmJyZXZpYXRpb24gKFwiUFNUXCIpXHJcbiAqIEBwYXJhbSBzYXZpbmdzICBJbmNsdWRlIGluZm9ybWF0aW9uIGlmIGl0J3MgaW4gZGF5bGlnaHQgc2F2aW5ncyBtb2RlXHJcbiAqIEBwYXJhbSB1dGMgICAgICBBc3N1bWUgVVRDIGRhdGVzXHJcbiAqIEByZXR1cm4gVGltZSB6b25lIG5hbWVcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRUaW1lWm9uZShkYXRlLCBsb25nID0gZmFsc2UsIHNhdmluZ3MgPSBmYWxzZSwgdXRjID0gZmFsc2UsIHRpbWV6b25lKSB7XHJcbiAgICBpZiAodXRjKSB7XHJcbiAgICAgICAgcmV0dXJuIGxvbmcgPyBcIkNvb3JkaW5hdGVkIFVuaXZlcnNhbCBUaW1lXCIgOiBcIlVUQ1wiO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodGltZXpvbmUpIHtcclxuICAgICAgICBjb25zdCBkMSA9IGRhdGUudG9Mb2NhbGVTdHJpbmcoXCJlbi1VU1wiLCB7IHRpbWVab25lOiB0aW1lem9uZSB9KTtcclxuICAgICAgICBjb25zdCBkMiA9IGRhdGUudG9Mb2NhbGVTdHJpbmcoXCJlbi1VU1wiLCB7IHRpbWVab25lOiB0aW1lem9uZSwgdGltZVpvbmVOYW1lOiBsb25nID8gXCJsb25nXCIgOiBcInNob3J0XCIgfSk7XHJcbiAgICAgICAgcmV0dXJuIHRyaW0oZDIuc3Vic3RyKGQxLmxlbmd0aCkpO1xyXG4gICAgfVxyXG4gICAgbGV0IHdvdHogPSBkYXRlLnRvTG9jYWxlU3RyaW5nKFwiVVRDXCIpO1xyXG4gICAgbGV0IHd0eiA9IGRhdGUudG9Mb2NhbGVTdHJpbmcoXCJVVENcIiwgeyB0aW1lWm9uZU5hbWU6IGxvbmcgPyBcImxvbmdcIiA6IFwic2hvcnRcIiB9KS5zdWJzdHIod290ei5sZW5ndGgpO1xyXG4gICAgLy93dHogPSB3dHoucmVwbGFjZSgvWystXStbMC05XSskLywgXCJcIik7XHJcbiAgICBpZiAoc2F2aW5ncyA9PT0gZmFsc2UpIHtcclxuICAgICAgICB3dHogPSB3dHoucmVwbGFjZSgvIChzdGFuZGFyZHxkYXlsaWdodHxzdW1tZXJ8d2ludGVyKSAvaSwgXCIgXCIpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRyaW0od3R6KTtcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0VGltZXpvbmVPZmZzZXQodGltZXpvbmUpIHtcclxuICAgIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZShEYXRlLlVUQygyMDEyLCAwLCAxLCAwLCAwLCAwLCAwKSk7XHJcbiAgICBjb25zdCB1dGNEYXRlID0gbmV3IERhdGUoZGF0ZS50b0xvY2FsZVN0cmluZyhcImVuLVVTXCIsIHsgdGltZVpvbmU6IFwiVVRDXCIgfSkpO1xyXG4gICAgY29uc3QgdHpEYXRlID0gbmV3IERhdGUoZGF0ZS50b0xvY2FsZVN0cmluZyhcImVuLVVTXCIsIHsgdGltZVpvbmU6IHRpbWV6b25lIH0pKTtcclxuICAgIHJldHVybiAodHpEYXRlLmdldFRpbWUoKSAtIHV0Y0RhdGUuZ2V0VGltZSgpKSAvIDZlNCAqIC0xO1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiBjYXBpdGFsaXplRmlyc3QodGV4dCkge1xyXG4gICAgcmV0dXJuIHRleHQuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyB0ZXh0LnNsaWNlKDEpO1xyXG59XHJcbi8qKlxyXG4gKiBUaGUgZnVuY3Rpb25zIGJlbG93IGFyZSB0YWtlbiBhbmQgYWRhcHRlZCBmcm9tIEdhcnJ5IFRhbidzIGJsb2cgcG9zdDpcclxuICogaHR0cDovL2F4b25mbHV4LmNvbS9oYW5keS1yZ2ItdG8taHNsLWFuZC1yZ2ItdG8taHN2LWNvbG9yLW1vZGVsLWNcclxuICpcclxuICogVGhlIGZ1cnRoZXIgYXR0cmlidXRpb25zIGdvIG1qaWphY2tzb24uY29tLCB3aGljaCBub3cgc2VlbXMgdG8gYmUgZGVmdW5jdC5cclxuICovXHJcbi8qKlxyXG4gKiBDb252ZXJ0cyBhbiBIU0wgY29sb3IgdmFsdWUgdG8gUkdCLiBDb252ZXJzaW9uIGZvcm11bGFcclxuICogYWRhcHRlZCBmcm9tIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSFNMX2NvbG9yX3NwYWNlLlxyXG4gKiBBc3N1bWVzIGgsIHMsIGFuZCBsIGFyZSBjb250YWluZWQgaW4gdGhlIHNldCBbMCwgMV0gYW5kXHJcbiAqIHJldHVybnMgciwgZywgYW5kIGIgaW4gdGhlIHNldCBbMCwgMjU1XS5cclxuICpcclxuICogRnVuY3Rpb24gYWRhcHRlZCBmcm9tOlxyXG4gKiBodHRwOi8vYXhvbmZsdXguY29tL2hhbmR5LXJnYi10by1oc2wtYW5kLXJnYi10by1oc3YtY29sb3ItbW9kZWwtY1xyXG4gKlxyXG4gKiBAaWdub3JlIEV4Y2x1ZGUgZnJvbSBkb2NzXHJcbiAqIEBwYXJhbSBoICAgICAgIFRoZSBodWVcclxuICogQHBhcmFtIHMgICAgICAgVGhlIHNhdHVyYXRpb25cclxuICogQHBhcmFtIGwgICAgICAgVGhlIGxpZ2h0bmVzc1xyXG4gKiBAcmV0dXJuIFRoZSBSR0IgcmVwcmVzZW50YXRpb25cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBoc2xUb1JnYihjb2xvcikge1xyXG4gICAgbGV0IHIsIGcsIGI7XHJcbiAgICBsZXQgaCA9IGNvbG9yLmg7XHJcbiAgICBsZXQgcyA9IGNvbG9yLnM7XHJcbiAgICBsZXQgbCA9IGNvbG9yLmw7XHJcbiAgICBpZiAocyA9PSAwKSB7XHJcbiAgICAgICAgciA9IGcgPSBiID0gbDsgLy8gYWNocm9tYXRpY1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgbGV0IGh1ZTJyZ2IgPSBmdW5jdGlvbiBodWUycmdiKHAsIHEsIHQpIHtcclxuICAgICAgICAgICAgaWYgKHQgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICB0ICs9IDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHQgPiAxKSB7XHJcbiAgICAgICAgICAgICAgICB0IC09IDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHQgPCAxIC8gNikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHAgKyAocSAtIHApICogNiAqIHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHQgPCAxIC8gMikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHQgPCAyIC8gMykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHAgKyAocSAtIHApICogKDIgLyAzIC0gdCkgKiA2O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBwO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgbGV0IHEgPSBsIDwgMC41ID8gbCAqICgxICsgcykgOiBsICsgcyAtIGwgKiBzO1xyXG4gICAgICAgIGxldCBwID0gMiAqIGwgLSBxO1xyXG4gICAgICAgIHIgPSBodWUycmdiKHAsIHEsIGggKyAxIC8gMyk7XHJcbiAgICAgICAgZyA9IGh1ZTJyZ2IocCwgcSwgaCk7XHJcbiAgICAgICAgYiA9IGh1ZTJyZ2IocCwgcSwgaCAtIDEgLyAzKTtcclxuICAgIH1cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgcjogTWF0aC5yb3VuZChyICogMjU1KSxcclxuICAgICAgICBnOiBNYXRoLnJvdW5kKGcgKiAyNTUpLFxyXG4gICAgICAgIGI6IE1hdGgucm91bmQoYiAqIDI1NSlcclxuICAgIH07XHJcbn1cclxuLyoqXHJcbiAqIENvbnZlcnRzIGFuIFJHQiBjb2xvciB2YWx1ZSB0byBIU0wuIENvbnZlcnNpb24gZm9ybXVsYVxyXG4gKiBhZGFwdGVkIGZyb20gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9IU0xfY29sb3Jfc3BhY2UuXHJcbiAqIEFzc3VtZXMgciwgZywgYW5kIGIgYXJlIGNvbnRhaW5lZCBpbiB0aGUgc2V0IFswLCAyNTVdIGFuZFxyXG4gKiByZXR1cm5zIGgsIHMsIGFuZCBsIGluIHRoZSBzZXQgWzAsIDFdLlxyXG4gKlxyXG4gKiBGdW5jdGlvbiBhZGFwdGVkIGZyb206XHJcbiAqIGh0dHA6Ly9heG9uZmx1eC5jb20vaGFuZHktcmdiLXRvLWhzbC1hbmQtcmdiLXRvLWhzdi1jb2xvci1tb2RlbC1jXHJcbiAqXHJcbiAqIEBpZ25vcmUgRXhjbHVkZSBmcm9tIGRvY3NcclxuICogQHBhcmFtIHIgICAgICAgVGhlIHJlZCBjb2xvciB2YWx1ZVxyXG4gKiBAcGFyYW0gZyAgICAgICBUaGUgZ3JlZW4gY29sb3IgdmFsdWVcclxuICogQHBhcmFtIGIgICAgICAgVGhlIGJsdWUgY29sb3IgdmFsdWVcclxuICogQHJldHVybiBUaGUgSFNMIHJlcHJlc2VudGF0aW9uXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gcmdiVG9Ic2woY29sb3IpIHtcclxuICAgIGxldCByID0gY29sb3IuciAvIDI1NTtcclxuICAgIGxldCBnID0gY29sb3IuZyAvIDI1NTtcclxuICAgIGxldCBiID0gY29sb3IuYiAvIDI1NTtcclxuICAgIGxldCBtYXggPSBNYXRoLm1heChyLCBnLCBiKTtcclxuICAgIGxldCBtaW4gPSBNYXRoLm1pbihyLCBnLCBiKTtcclxuICAgIGxldCBoID0gMDtcclxuICAgIGxldCBzID0gMDtcclxuICAgIGxldCBsID0gKG1heCArIG1pbikgLyAyO1xyXG4gICAgaWYgKG1heCA9PT0gbWluKSB7XHJcbiAgICAgICAgaCA9IHMgPSAwOyAvLyBhY2hyb21hdGljXHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBsZXQgZCA9IG1heCAtIG1pbjtcclxuICAgICAgICBzID0gbCA+IDAuNSA/IGQgLyAoMiAtIG1heCAtIG1pbikgOiBkIC8gKG1heCArIG1pbik7XHJcbiAgICAgICAgc3dpdGNoIChtYXgpIHtcclxuICAgICAgICAgICAgY2FzZSByOlxyXG4gICAgICAgICAgICAgICAgaCA9IChnIC0gYikgLyBkICsgKGcgPCBiID8gNiA6IDApO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgZzpcclxuICAgICAgICAgICAgICAgIGggPSAoYiAtIHIpIC8gZCArIDI7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBiOlxyXG4gICAgICAgICAgICAgICAgaCA9IChyIC0gZykgLyBkICsgNDtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBoIC89IDY7XHJcbiAgICB9XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGg6IGgsXHJcbiAgICAgICAgczogcyxcclxuICAgICAgICBsOiBsXHJcbiAgICB9O1xyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm5zIGEgY29sb3IgdGhhdCBpcyBgcGVyY2VudGAgYnJpZ2h0ZXIgdGhhbiB0aGUgcmVmZXJlbmNlIGNvbG9yLlxyXG4gKlxyXG4gKiBAaWdub3JlIEV4Y2x1ZGUgZnJvbSBkb2NzXHJcbiAqIEBwYXJhbSBjb2xvciAgICBSZWZlcmVuY2UgY29sb3JcclxuICogQHBhcmFtIHBlcmNlbnQgIEJyaWdodG5lc3MgcGVyY2VudFxyXG4gKiBAcmV0dXJuIEhleCBjb2RlIG9mIHRoZSBuZXcgY29sb3JcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBsaWdodGVuKHJnYiwgcGVyY2VudCkge1xyXG4gICAgaWYgKHJnYikge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHI6IE1hdGgubWF4KDAsIE1hdGgubWluKDI1NSwgcmdiLnIgKyBnZXRMaWdodG5lc3NTdGVwKHJnYi5yLCBwZXJjZW50KSkpLFxyXG4gICAgICAgICAgICBnOiBNYXRoLm1heCgwLCBNYXRoLm1pbigyNTUsIHJnYi5nICsgZ2V0TGlnaHRuZXNzU3RlcChyZ2IuZywgcGVyY2VudCkpKSxcclxuICAgICAgICAgICAgYjogTWF0aC5tYXgoMCwgTWF0aC5taW4oMjU1LCByZ2IuYiArIGdldExpZ2h0bmVzc1N0ZXAocmdiLmIsIHBlcmNlbnQpKSksXHJcbiAgICAgICAgICAgIGE6IHJnYi5hXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIC8vIFRPRE8gaXMgdGhpcyBjb3JyZWN0ID9cclxuICAgICAgICByZXR1cm4gcmdiO1xyXG4gICAgfVxyXG59XHJcbjtcclxuLyoqXHJcbiAqIEdldHMgbGlnaHRuZXNzIHN0ZXAuXHJcbiAqXHJcbiAqIEBpZ25vcmUgRXhjbHVkZSBmcm9tIGRvY3NcclxuICogQHBhcmFtIHZhbHVlICAgIFZhbHVlXHJcbiAqIEBwYXJhbSBwZXJjZW50ICBQZXJjZW50XHJcbiAqIEByZXR1cm4gU3RlcFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGdldExpZ2h0bmVzc1N0ZXAodmFsdWUsIHBlcmNlbnQpIHtcclxuICAgIGxldCBiYXNlID0gcGVyY2VudCA+IDAgPyAyNTUgLSB2YWx1ZSA6IHZhbHVlO1xyXG4gICAgcmV0dXJuIE1hdGgucm91bmQoYmFzZSAqIHBlcmNlbnQpO1xyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm5zIGEgY29sb3IgdGhhdCBpcyBgcGVyY2VudGAgYnJpZ2h0ZXIgdGhhbiB0aGUgc291cmNlIGBjb2xvcmAuXHJcbiAqXHJcbiAqIEBpZ25vcmUgRXhjbHVkZSBmcm9tIGRvY3NcclxuICogQHBhcmFtIGNvbG9yICAgIFNvdXJjZSBjb2xvclxyXG4gKiBAcGFyYW0gcGVyY2VudCAgQnJpZ2h0bmVzcyBwZXJjZW50XHJcbiAqIEByZXR1cm4gTmV3IGNvbG9yXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gYnJpZ2h0ZW4ocmdiLCBwZXJjZW50KSB7XHJcbiAgICBpZiAocmdiKSB7XHJcbiAgICAgICAgbGV0IGJhc2UgPSBNYXRoLm1pbihNYXRoLm1heChyZ2IuciwgcmdiLmcsIHJnYi5iKSwgMjMwKTtcclxuICAgICAgICAvL2xldCBiYXNlID0gTWF0aC5tYXgocmdiLnIsIHJnYi5nLCByZ2IuYik7XHJcbiAgICAgICAgbGV0IHN0ZXAgPSBnZXRMaWdodG5lc3NTdGVwKGJhc2UsIHBlcmNlbnQpO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHI6IE1hdGgubWF4KDAsIE1hdGgubWluKDI1NSwgTWF0aC5yb3VuZChyZ2IuciArIHN0ZXApKSksXHJcbiAgICAgICAgICAgIGc6IE1hdGgubWF4KDAsIE1hdGgubWluKDI1NSwgTWF0aC5yb3VuZChyZ2IuZyArIHN0ZXApKSksXHJcbiAgICAgICAgICAgIGI6IE1hdGgubWF4KDAsIE1hdGgubWluKDI1NSwgTWF0aC5yb3VuZChyZ2IuYiArIHN0ZXApKSksXHJcbiAgICAgICAgICAgIGE6IHJnYi5hXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIC8vIFRPRE8gaXMgdGhpcyBjb3JyZWN0ID9cclxuICAgICAgICByZXR1cm4gcmdiO1xyXG4gICAgfVxyXG59XHJcbjtcclxuLyoqXHJcbiAqIFJldHVybnMgYnJpZ2h0bmVzcyBzdGVwLlxyXG4gKlxyXG4gKiBAaWdub3JlIEV4Y2x1ZGUgZnJvbSBkb2NzXHJcbiAqIEBwYXJhbSB2YWx1ZSAgICBWYWx1ZVxyXG4gKiBAcGFyYW0gcGVyY2VudCAgUGVyY2VudFxyXG4gKiBAcmV0dXJuIFN0ZXBcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRCcmlnaHRuZXNzU3RlcChfdmFsdWUsIHBlcmNlbnQpIHtcclxuICAgIGxldCBiYXNlID0gMjU1OyAvL3BlcmNlbnQgPiAwID8gMjU1IC0gdmFsdWUgOiB2YWx1ZTtcclxuICAgIHJldHVybiBNYXRoLnJvdW5kKGJhc2UgKiBwZXJjZW50KTtcclxufVxyXG4vKipcclxuICogUmV0dXJucyBgdHJ1ZWAgaWYgY29sb3IgaXMgXCJsaWdodFwiLiBVc2VmdWwgaW5kZXRlcm1pbmluZyB3aGljaCBjb250cmFzdGluZ1xyXG4gKiBjb2xvciB0byB1c2UgZm9yIGVsZW1lbnRzIG92ZXIgdGhpcyBjb2xvci4gRS5nLjogeW91IHdvdWxkIHdhbnQgdG8gdXNlXHJcbiAqIGJsYWNrIHRleHQgb3ZlciBsaWdodCBiYWNrZ3JvdW5kLCBhbmQgdmljZSB2ZXJzYS5cclxuICpcclxuICogQGlnbm9yZSBFeGNsdWRlIGZyb20gZG9jc1xyXG4gKiBAcGFyYW0gY29sb3IgIFNvdXJjZSBjb2xvclxyXG4gKiBAcmV0dXJuIExpZ2h0P1xyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGlzTGlnaHQoY29sb3IpIHtcclxuICAgIHJldHVybiAoKGNvbG9yLnIgKiAyOTkpICsgKGNvbG9yLmcgKiA1ODcpICsgKGNvbG9yLmIgKiAxMTQpKSAvIDEwMDAgPj0gMTI4O1xyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm5zIGEgbmV3IFtbaVJHQl1dIG9iamVjdCBiYXNlZCBvbiBgcmdiYCBwYXJhbWV0ZXIgd2l0aCBzcGVjaWZpY1xyXG4gKiBzYXR1cmF0aW9uIGFwcGxpZWQuXHJcbiAqXHJcbiAqIGBzYXR1cmF0aW9uYCBjYW4gYmUgaW4gdGhlIHJhbmdlIG9mIDAgKGZ1bGx5IGRlc2F0dXJhdGVkKSB0byAxIChmdWxseVxyXG4gKiBzYXR1cmF0ZWQpLlxyXG4gKlxyXG4gKiBAaWdub3JlIEV4Y2x1ZGUgZnJvbSBkb2NzXHJcbiAqIEBwYXJhbSBjb2xvciAgICAgICBCYXNlIGNvbG9yXHJcbiAqIEBwYXJhbSBzYXR1cmF0aW9uICBTYXR1cmF0aW9uICgwLTEpXHJcbiAqIEByZXR1cm4gTmV3IGNvbG9yXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gc2F0dXJhdGUocmdiLCBzYXR1cmF0aW9uKSB7XHJcbiAgICBpZiAocmdiID09PSB1bmRlZmluZWQgfHwgc2F0dXJhdGlvbiA9PSAxKSB7XHJcbiAgICAgICAgcmV0dXJuIHJnYjtcclxuICAgIH1cclxuICAgIGxldCBoc2wgPSByZ2JUb0hzbChyZ2IpO1xyXG4gICAgaHNsLnMgPSBzYXR1cmF0aW9uO1xyXG4gICAgcmV0dXJuIGhzbFRvUmdiKGhzbCk7XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIGFsdGVybmF0aXZlQ29sb3IoY29sb3IsIGxpZ2h0QWx0ZXJuYXRpdmUgPSB7IHI6IDI1NSwgZzogMjU1LCBiOiAyNTUgfSwgZGFya0FsdGVybmF0aXZlID0geyByOiAyNTUsIGc6IDI1NSwgYjogMjU1IH0pIHtcclxuICAgIGxldCBsaWdodCA9IGxpZ2h0QWx0ZXJuYXRpdmU7XHJcbiAgICBsZXQgZGFyayA9IGRhcmtBbHRlcm5hdGl2ZTtcclxuICAgIGlmIChpc0xpZ2h0KGRhcmtBbHRlcm5hdGl2ZSkpIHtcclxuICAgICAgICBsaWdodCA9IGRhcmtBbHRlcm5hdGl2ZTtcclxuICAgICAgICBkYXJrID0gbGlnaHRBbHRlcm5hdGl2ZTtcclxuICAgIH1cclxuICAgIHJldHVybiBpc0xpZ2h0KGNvbG9yKSA/IGRhcmsgOiBsaWdodDtcclxufVxyXG4vKipcclxuICogQGlnbm9yZVxyXG4gKiBAZGVwcmVjYXRlZFxyXG4gKi9cclxuLy8gZXhwb3J0IGZ1bmN0aW9uIHVuc2hpZnRUaGVtZUNsYXNzKHNldHRpbmdzOiBhbnksIHRoZW1lQ2xhc3M6IHN0cmluZykge1xyXG4vLyBcdGxldCB0aGVtZUNsYXNzZXMgPSBzZXR0aW5ncy50aGVtZUNsYXNzZXM7XHJcbi8vIFx0aWYgKCF0aGVtZUNsYXNzZXMpIHtcclxuLy8gXHRcdHRoZW1lQ2xhc3NlcyA9IFtdO1xyXG4vLyBcdH1cclxuLy8gXHR0aGVtZUNsYXNzZXMudW5zaGlmdCh0aGVtZUNsYXNzKTtcclxuLy8gXHRzZXR0aW5ncy50aGVtZUNsYXNzZXMgPSB0aGVtZUNsYXNzZXM7XHJcbi8vIH1cclxuLyoqXHJcbiAqIEBpZ25vcmVcclxuICogQGRlcHJlY2F0ZWRcclxuICovXHJcbi8vIGV4cG9ydCBmdW5jdGlvbiBwdXNoVGhlbWVDbGFzcyhzZXR0aW5nczogYW55LCB0aGVtZUNsYXNzOiBzdHJpbmcpIHtcclxuLy8gXHRsZXQgdGhlbWVDbGFzc2VzID0gc2V0dGluZ3MudGhlbWVDbGFzc2VzO1xyXG4vLyBcdGlmICghdGhlbWVDbGFzc2VzKSB7XHJcbi8vIFx0XHR0aGVtZUNsYXNzZXMgPSBbXTtcclxuLy8gXHR9XHJcbi8vIFx0dGhlbWVDbGFzc2VzLnB1c2godGhlbWVDbGFzcyk7XHJcbi8vIFx0c2V0dGluZ3MudGhlbWVDbGFzc2VzID0gdGhlbWVDbGFzc2VzO1xyXG4vLyB9XHJcbi8qKlxyXG4gKiBAaWdub3JlXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gbWVyZ2VUYWdzKHRhZ3MxLCB0YWdzMikge1xyXG4gICAgaWYgKCF0YWdzMSkge1xyXG4gICAgICAgIHRhZ3MxID0gW107XHJcbiAgICB9XHJcbiAgICByZXR1cm4gWy4uLnRhZ3MxLCAuLi50YWdzMl0uZmlsdGVyKCh2YWx1ZSwgaW5kZXgsIHNlbGYpID0+IHtcclxuICAgICAgICByZXR1cm4gc2VsZi5pbmRleE9mKHZhbHVlKSA9PT0gaW5kZXg7XHJcbiAgICB9KTtcclxufVxyXG4vKipcclxuICogQGlnbm9yZVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHNhbWVCb3VuZHMoYSwgYikge1xyXG4gICAgaWYgKCFiKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgaWYgKGEubGVmdCAhPSBiLmxlZnQpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBpZiAoYS5yaWdodCAhPSBiLnJpZ2h0KSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgaWYgKGEudG9wICE9IGIudG9wKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgaWYgKGEuYm90dG9tICE9IGIuYm90dG9tKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRydWU7XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VXRpbHMuanMubWFwIiwiaW1wb3J0IHsgX19hd2FpdGVyIH0gZnJvbSBcInRzbGliXCI7XHJcbmltcG9ydCB7IEVudGl0eSB9IGZyb20gXCIuLi8uLi9jb3JlL3V0aWwvRW50aXR5XCI7XHJcbmltcG9ydCB7IENvbG9yIH0gZnJvbSBcIi4uLy4uL2NvcmUvdXRpbC9Db2xvclwiO1xyXG5pbXBvcnQgeyBSb290IH0gZnJvbSBcIi4uLy4uL2NvcmUvUm9vdFwiO1xyXG5pbXBvcnQgeyBTdHlsZVJ1bGUgfSBmcm9tIFwiLi4vLi4vY29yZS91dGlsL1V0aWxzXCI7XHJcbmltcG9ydCAqIGFzICRhcnJheSBmcm9tIFwiLi4vLi4vY29yZS91dGlsL0FycmF5XCI7XHJcbmltcG9ydCAqIGFzICRvYmplY3QgZnJvbSBcIi4uLy4uL2NvcmUvdXRpbC9PYmplY3RcIjtcclxuaW1wb3J0ICogYXMgJHR5cGUgZnJvbSBcIi4uLy4uL2NvcmUvdXRpbC9UeXBlXCI7XHJcbmltcG9ydCAqIGFzICR1dGlscyBmcm9tIFwiLi4vLi4vY29yZS91dGlsL1V0aWxzXCI7XHJcbi8qKlxyXG4gKiBUaGlzIGlzIHVzZWQgdG8gY2FjaGUgdGhlIHBkZm1ha2UgbG9hZGluZy5cclxuICpcclxuICogQGlnbm9yZVxyXG4gKi9cclxubGV0IHBkZm1ha2VQcm9taXNlO1xyXG4vKipcclxuICogTG9hZHMgcGRmbWFrZSBkeW5hbWljIG1vZHVsZVxyXG4gKlxyXG4gKiBUaGlzIGlzIGFuIGFzeW5jaHJvbm91cyBmdW5jdGlvbi4gQ2hlY2sgdGhlIGRlc2NyaXB0aW9uIG9mIGBnZXRJbWFnZSgpYFxyXG4gKiBmb3IgZGVzY3JpcHRpb24gYW5kIGV4YW1wbGUgdXNhZ2UuXHJcbiAqXHJcbiAqIEBpZ25vcmVcclxuICovXHJcbmZ1bmN0aW9uIF9wZGZtYWtlKCkge1xyXG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICBsZXQgYSA9IHlpZWxkIFByb21pc2UuYWxsKFtcclxuICAgICAgICAgICAgaW1wb3J0KC8qIHdlYnBhY2tDaHVua05hbWU6IFwicGRmbWFrZVwiICovIFwicGRmbWFrZS9idWlsZC9wZGZtYWtlLmpzXCIpLFxyXG4gICAgICAgICAgICBpbXBvcnQoLyogd2VicGFja0NodW5rTmFtZTogXCJwZGZtYWtlXCIgKi8gXCIuL3BkZm1ha2UvdmZzX2ZvbnRzXCIpXHJcbiAgICAgICAgXSk7XHJcbiAgICAgICAgbGV0IHBkZm1ha2UgPSBhWzBdLmRlZmF1bHQ7XHJcbiAgICAgICAgbGV0IHZmc19mb250cyA9IGFbMV0uZGVmYXVsdDtcclxuICAgICAgICBjb25zdCBnbG9iYWwgPSB3aW5kb3c7XHJcbiAgICAgICAgZ2xvYmFsLnBkZk1ha2UgPSBnbG9iYWwucGRmTWFrZSB8fCB7fTtcclxuICAgICAgICBnbG9iYWwucGRmTWFrZS52ZnMgPSB2ZnNfZm9udHM7XHJcbiAgICAgICAgcGRmbWFrZS52ZnMgPSB2ZnNfZm9udHM7XHJcbiAgICAgICAgcmV0dXJuIHBkZm1ha2U7XHJcbiAgICB9KTtcclxufVxyXG4vKipcclxuICogQSBwbHVnaW4gdGhhdCBjYW4gYmUgdXNlZCB0byBleHBvcnQgY2hhcnQgc25hcHNob3RzIGFuZCBkYXRhLlxyXG4gKlxyXG4gKiBAc2VlIHtAbGluayBodHRwczovL3d3dy5hbWNoYXJ0cy5jb20vZG9jcy92NS9jb25jZXB0cy9leHBvcnRpbmcvfSBmb3IgbW9yZSBpbmZvXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgRXhwb3J0aW5nIGV4dGVuZHMgRW50aXR5IHtcclxuICAgIC8vcHVibGljIGV4dHJhSW1hZ2VzOiBBcnJheTxSb290IHwgSUV4cG9ydGluZ0ltYWdlU291cmNlPiA9IFtdO1xyXG4gICAgLy9wdWJsaWMgZGF0YVNvdXJjZXM6IGFueVtdID0gW107XHJcbiAgICBfYWZ0ZXJOZXcoKSB7XHJcbiAgICAgICAgc3VwZXIuX2FmdGVyTmV3KCk7XHJcbiAgICAgICAgdGhpcy5fc2V0UmF3RGVmYXVsdChcImZpbGVQcmVmaXhcIiwgXCJjaGFydFwiKTtcclxuICAgICAgICB0aGlzLl9zZXRSYXdEZWZhdWx0KFwiY2hhcnNldFwiLCBcInV0Zi04XCIpO1xyXG4gICAgICAgIHRoaXMuX3NldFJhd0RlZmF1bHQoXCJudW1lcmljRmllbGRzXCIsIFtdKTtcclxuICAgICAgICB0aGlzLl9zZXRSYXdEZWZhdWx0KFwiZGF0ZUZpZWxkc1wiLCBbXSk7XHJcbiAgICAgICAgdGhpcy5fc2V0UmF3RGVmYXVsdChcImR1cmF0aW9uRmllbGRzXCIsIFtdKTtcclxuICAgICAgICB0aGlzLl9zZXRSYXdEZWZhdWx0KFwiZXh0cmFJbWFnZXNcIiwgW10pO1xyXG4gICAgICAgIHRoaXMuX3NldFJhd0RlZmF1bHQoXCJwbmdPcHRpb25zXCIsIHsgcXVhbGl0eTogMSwgbWFpbnRhaW5QaXhlbFJhdGlvOiBmYWxzZSB9KTtcclxuICAgICAgICB0aGlzLl9zZXRSYXdEZWZhdWx0KFwianBnT3B0aW9uc1wiLCB7IHF1YWxpdHk6IDAuOCwgbWFpbnRhaW5QaXhlbFJhdGlvOiBmYWxzZSB9KTtcclxuICAgICAgICB0aGlzLl9zZXRSYXdEZWZhdWx0KFwicHJpbnRPcHRpb25zXCIsIHsgcXVhbGl0eTogMSwgbWFpbnRhaW5QaXhlbFJhdGlvOiBmYWxzZSwgZGVsYXk6IDUwMCwgcHJpbnRNZXRob2Q6IFwiaWZyYW1lXCIsIGltYWdlRm9ybWF0OiBcInBuZ1wiIH0pO1xyXG4gICAgICAgIHRoaXMuX3NldFJhd0RlZmF1bHQoXCJqc29uT3B0aW9uc1wiLCB7IGluZGVudDogMiwgcmVuYW1lRmllbGRzOiB0cnVlIH0pO1xyXG4gICAgICAgIHRoaXMuX3NldFJhd0RlZmF1bHQoXCJjc3ZPcHRpb25zXCIsIHsgc2VwYXJhdG9yOiBcIixcIiwgYWRkQ29sdW1uTmFtZXM6IHRydWUsIGVtcHR5QXM6IFwiXCIsIGFkZEJPTTogdHJ1ZSB9KTtcclxuICAgICAgICB0aGlzLl9zZXRSYXdEZWZhdWx0KFwiaHRtbE9wdGlvbnNcIiwgeyBlbXB0eUFzOiBcIi1cIiwgYWRkQ29sdW1uTmFtZXM6IHRydWUgfSk7XHJcbiAgICAgICAgdGhpcy5fc2V0UmF3RGVmYXVsdChcInhsc3hPcHRpb25zXCIsIHsgZW1wdHlBczogXCJcIiwgYWRkQ29sdW1uTmFtZXM6IHRydWUgfSk7XHJcbiAgICAgICAgdGhpcy5fc2V0UmF3RGVmYXVsdChcInBkZk9wdGlvbnNcIiwgeyBmb250U2l6ZTogMTQsIGltYWdlRm9ybWF0OiBcInBuZ1wiLCBhbGlnbjogXCJsZWZ0XCIsIGFkZFVSTDogdHJ1ZSB9KTtcclxuICAgICAgICB0aGlzLl9zZXRSYXdEZWZhdWx0KFwicGRmZGF0YU9wdGlvbnNcIiwgeyBlbXB0eUFzOiBcIlwiLCBhZGRDb2x1bW5OYW1lczogdHJ1ZSB9KTtcclxuICAgICAgICB0aGlzLl9yb290LmFkZERpc3Bvc2VyKHRoaXMpO1xyXG4gICAgfVxyXG4gICAgX2JlZm9yZUNoYW5nZWQoKSB7XHJcbiAgICAgICAgc3VwZXIuX2JlZm9yZUNoYW5nZWQoKTtcclxuICAgICAgICBpZiAodGhpcy5pc0RpcnR5KFwibWVudVwiKSkge1xyXG4gICAgICAgICAgICBjb25zdCBtZW51ID0gdGhpcy5nZXQoXCJtZW51XCIpO1xyXG4gICAgICAgICAgICBpZiAobWVudSkge1xyXG4gICAgICAgICAgICAgICAgbWVudS5zZXQoXCJleHBvcnRpbmdcIiwgdGhpcyk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9kaXNwb3NlcnMucHVzaChtZW51KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIF9nZXRGb3JtYXRPcHRpb25zKGZvcm1hdCwgb3B0aW9ucykge1xyXG4gICAgICAgIGNvbnN0IG5ld09wdGlvbnMgPSAkb2JqZWN0LmNvcHkodGhpcy5nZXQoZm9ybWF0ICsgXCJPcHRpb25zXCIsIHt9KSk7XHJcbiAgICAgICAgaWYgKG9wdGlvbnMpIHtcclxuICAgICAgICAgICAgJG9iamVjdC5lYWNoKG9wdGlvbnMsIChrZXksIHZhbHVlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBuZXdPcHRpb25zW2tleV0gPSB2YWx1ZTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXdPcHRpb25zO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUcmlnZ2VycyBhIGRvd25sb2FkIG9mIHRoZSBjaGFydC9kYXRhIGluIHNwZWNpZmljIGZvcm1hdC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gIGZvcm1hdCAgICAgICAgIEZvcm1hdFxyXG4gICAgICogQHBhcmFtICBjdXN0b21PcHRpb25zICBGb3JtYXQgb3B0aW9uc1xyXG4gICAgICovXHJcbiAgICBkb3dubG9hZChmb3JtYXQsIGN1c3RvbU9wdGlvbnMpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICBjb25zdCBleHQgPSBmb3JtYXQgPT0gXCJwZGZkYXRhXCIgPyBcInBkZlwiIDogZm9ybWF0O1xyXG4gICAgICAgICAgICBjb25zdCBmaWxlTmFtZSA9IHRoaXMuZ2V0KFwiZmlsZVByZWZpeFwiLCBcImNoYXJ0XCIpICsgXCIuXCIgKyBleHQ7XHJcbiAgICAgICAgICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLl9nZXRGb3JtYXRPcHRpb25zKGZvcm1hdCwgY3VzdG9tT3B0aW9ucyk7XHJcbiAgICAgICAgICAgIHRoaXMuZXZlbnRzLmRpc3BhdGNoKFwiZG93bmxvYWRzdGFydGVkXCIsIHtcclxuICAgICAgICAgICAgICAgIHR5cGU6IFwiZG93bmxvYWRzdGFydGVkXCIsXHJcbiAgICAgICAgICAgICAgICBmb3JtYXQ6IGZvcm1hdCxcclxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IG9wdGlvbnMsXHJcbiAgICAgICAgICAgICAgICBmaWxlTmFtZTogZmlsZU5hbWUsXHJcbiAgICAgICAgICAgICAgICB0YXJnZXQ6IHRoaXNcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGNvbnN0IHVyaSA9IHlpZWxkIHRoaXMuZXhwb3J0KGZvcm1hdCwgb3B0aW9ucyk7XHJcbiAgICAgICAgICAgIHRoaXMuc3RyZWFtRmlsZSh1cmksIGZpbGVOYW1lLCAob3B0aW9ucyAmJiBvcHRpb25zLmFkZEJPTSkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUcmlnZ2VycyBwcmludCBvZiB0aGUgY2hhcnQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtICBjdXN0b21PcHRpb25zICBQcmludCBvcHRpb25zXHJcbiAgICAgKi9cclxuICAgIHByaW50KGN1c3RvbU9wdGlvbnMpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICBjb25zdCBvcHRpb25zID0gdGhpcy5fZ2V0Rm9ybWF0T3B0aW9ucyhcInByaW50XCIsIGN1c3RvbU9wdGlvbnMpO1xyXG4gICAgICAgICAgICB0aGlzLmV2ZW50cy5kaXNwYXRjaChcInByaW50c3RhcnRlZFwiLCB7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiBcInByaW50c3RhcnRlZFwiLFxyXG4gICAgICAgICAgICAgICAgZm9ybWF0OiBcInByaW50XCIsXHJcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBvcHRpb25zLFxyXG4gICAgICAgICAgICAgICAgdGFyZ2V0OiB0aGlzXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBjb25zdCB1cmkgPSB5aWVsZCB0aGlzLmV4cG9ydChvcHRpb25zLmltYWdlRm9ybWF0IHx8IFwicG5nXCIsIG9wdGlvbnMpO1xyXG4gICAgICAgICAgICB0aGlzLmluaXRpYXRlUHJpbnQodXJpLCBvcHRpb25zLCB0aGlzLmdldChcInRpdGxlXCIpKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBkYXRhIHVyaSBvZiB0aGUgY2hhcnQvZGF0YSBpbiBzcGVjaWZpYyBmb3JtYXQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtICAgICAgICAgIGZvcm1hdCAgRm9ybWF0XHJcbiAgICAgKiBAcGFyYW0gICBjdXN0b21PcHRpb25zICBGb3JtYXQgb3B0aW9uc1xyXG4gICAgICogQHJldHVybiAgICAgICAgICAgICAgICAgUHJvbWlzZVxyXG4gICAgICovXHJcbiAgICBleHBvcnQoZm9ybWF0LCBjdXN0b21PcHRpb25zKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMuX2dldEZvcm1hdE9wdGlvbnMoZm9ybWF0LCBjdXN0b21PcHRpb25zKTtcclxuICAgICAgICAgICAgdGhpcy5ldmVudHMuZGlzcGF0Y2goXCJleHBvcnRzdGFydGVkXCIsIHtcclxuICAgICAgICAgICAgICAgIHR5cGU6IFwiZXhwb3J0c3RhcnRlZFwiLFxyXG4gICAgICAgICAgICAgICAgZm9ybWF0OiBmb3JtYXQsXHJcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBvcHRpb25zLFxyXG4gICAgICAgICAgICAgICAgdGFyZ2V0OiB0aGlzXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBsZXQgcHJvbWlzZSA9IFwiXCI7XHJcbiAgICAgICAgICAgIHN3aXRjaCAoZm9ybWF0KSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwicG5nXCI6XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwianBnXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcm9vdC5fcnVuVGlja2VyTm93KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJvbWlzZSA9IHRoaXMuZXhwb3J0SW1hZ2UoZm9ybWF0LCBvcHRpb25zKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJqc29uXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgcHJvbWlzZSA9IHRoaXMuZXhwb3J0SlNPTihvcHRpb25zKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJjc3ZcIjpcclxuICAgICAgICAgICAgICAgICAgICBwcm9taXNlID0gdGhpcy5leHBvcnRDU1Yob3B0aW9ucyk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwiaHRtbFwiOlxyXG4gICAgICAgICAgICAgICAgICAgIHByb21pc2UgPSB0aGlzLmV4cG9ydEhUTUwob3B0aW9ucyk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwieGxzeFwiOlxyXG4gICAgICAgICAgICAgICAgICAgIHByb21pc2UgPSB0aGlzLmV4cG9ydFhMU1gob3B0aW9ucyk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwicGRmXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcm9vdC5fcnVuVGlja2VyTm93KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJvbWlzZSA9IHRoaXMuZXhwb3J0UERGKG9wdGlvbnMpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBcInBkZmRhdGFcIjpcclxuICAgICAgICAgICAgICAgICAgICBwcm9taXNlID0gdGhpcy5leHBvcnRQREZEYXRhKG9wdGlvbnMpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuZXZlbnRzLmRpc3BhdGNoKFwiZXhwb3J0ZmluaXNoZWRcIiwge1xyXG4gICAgICAgICAgICAgICAgdHlwZTogXCJleHBvcnRmaW5pc2hlZFwiLFxyXG4gICAgICAgICAgICAgICAgZm9ybWF0OiBmb3JtYXQsXHJcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBvcHRpb25zLFxyXG4gICAgICAgICAgICAgICAgdGFyZ2V0OiB0aGlzXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzZTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICAgICAqIEltYWdlc1xyXG4gICAgICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICAgICAqL1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGNoYXJ0IGltYWdlIGFzIGEgZGF0YTp1cmkuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtICAgZm9ybWF0ICAgICAgICAgSW1hZ2UgZm9ybWF0XHJcbiAgICAgKiBAcGFyYW0gICBjdXN0b21PcHRpb25zICBGb3JtYXQgb3B0aW9uc1xyXG4gICAgICogQHJldHVybiAgICAgICAgICAgICAgICAgUHJvbWlzZVxyXG4gICAgICovXHJcbiAgICBleHBvcnRJbWFnZShmb3JtYXQsIGN1c3RvbU9wdGlvbnMpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICBjb25zdCBvcHRpb25zID0gdGhpcy5fZ2V0Rm9ybWF0T3B0aW9ucyhmb3JtYXQsIGN1c3RvbU9wdGlvbnMpO1xyXG4gICAgICAgICAgICBjb25zdCBjYW52YXMgPSB5aWVsZCB0aGlzLmdldENhbnZhcyhvcHRpb25zKTtcclxuICAgICAgICAgICAgY29uc3QgZGF0YSA9IGNhbnZhcy50b0RhdGFVUkwodGhpcy5nZXRDb250ZW50VHlwZShmb3JtYXQpLCBvcHRpb25zLnF1YWxpdHkgfHwgMSk7XHJcbiAgICAgICAgICAgIHRoaXMuZGlzcG9zZUNhbnZhcyhjYW52YXMpO1xyXG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBjYW52YXMgZGF0YS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gICBjdXN0b21PcHRpb25zICBJbWFnZSBvcHRpb25zXHJcbiAgICAgKiBAcmV0dXJuICAgICAgICAgICAgICAgICBQcm9taXNlXHJcbiAgICAgKi9cclxuICAgIGV4cG9ydENhbnZhcyhjdXN0b21PcHRpb25zKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMuX2dldEZvcm1hdE9wdGlvbnMoXCJjYW52YXNcIiwgY3VzdG9tT3B0aW9ucyk7XHJcbiAgICAgICAgICAgIGNvbnN0IGNhbnZhcyA9IHlpZWxkIHRoaXMuZ2V0Q2FudmFzKG9wdGlvbnMpO1xyXG4gICAgICAgICAgICBjb25zdCBkYXRhID0gY2FudmFzLnRvRGF0YVVSTCh0aGlzLmdldENvbnRlbnRUeXBlKFwiY2FudmFzXCIpLCBvcHRpb25zLnF1YWxpdHkgfHwgMSk7XHJcbiAgICAgICAgICAgIHRoaXMuZGlzcG9zZUNhbnZhcyhjYW52YXMpO1xyXG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIGA8Y2FudmFzPmAgZWxlbWVudCB3aXRoIHNuYXBzaG90IG9mIHRoZSBjaGFydC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gICBvcHRpb25zICBJbWFnZSBvcHRpb25zXHJcbiAgICAgKiBAcmV0dXJuICAgICAgICAgICBQcm9taXNlXHJcbiAgICAgKi9cclxuICAgIGdldENhbnZhcyhvcHRpb25zKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgY29uc3QgbWFpbkNhbnZhcyA9IHRoaXMuX3Jvb3QuX3JlbmRlcmVyLmdldENhbnZhcyh0aGlzLl9yb290Ll9yb290Q29udGFpbmVyLl9kaXNwbGF5LCBvcHRpb25zKTtcclxuICAgICAgICAgICAgY29uc3QgZXh0cmFJbWFnZXMgPSB0aGlzLmdldChcImV4dHJhSW1hZ2VzXCIsIFtdKTtcclxuICAgICAgICAgICAgLy8gQWRkIG90aGVyIGNhbnZhc2VzXHJcbiAgICAgICAgICAgIGxldCBtaWRkbGVMZWZ0ID0gMDtcclxuICAgICAgICAgICAgbGV0IG1pZGRsZVRvcCA9IDA7XHJcbiAgICAgICAgICAgIGxldCBtaWRkbGVXaWR0aCA9IG1haW5DYW52YXMud2lkdGg7XHJcbiAgICAgICAgICAgIGxldCBtaWRkbGVIZWlnaHQgPSBtYWluQ2FudmFzLmhlaWdodDtcclxuICAgICAgICAgICAgbGV0IGV4dHJhUmlnaHQgPSAwO1xyXG4gICAgICAgICAgICBsZXQgZXh0cmFCb3R0b20gPSAwO1xyXG4gICAgICAgICAgICBjb25zdCBleHRyYXMgPSBbXTtcclxuICAgICAgICAgICAgJGFycmF5LmVhY2goZXh0cmFJbWFnZXMsIChleHRyYVJvb3QpID0+IHtcclxuICAgICAgICAgICAgICAgIC8vIEdldCB0aGF0IGV4dHJhXHJcbiAgICAgICAgICAgICAgICBsZXQgZXh0cmE7XHJcbiAgICAgICAgICAgICAgICBpZiAoZXh0cmFSb290IGluc3RhbmNlb2YgUm9vdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGV4dHJhID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2U6IGV4dHJhUm9vdCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IFwiYm90dG9tXCJcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXh0cmEgPSBleHRyYVJvb3Q7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBTZXQgZGVmYXVsdHNcclxuICAgICAgICAgICAgICAgIGV4dHJhLnBvc2l0aW9uID0gZXh0cmEucG9zaXRpb24gfHwgXCJib3R0b21cIjtcclxuICAgICAgICAgICAgICAgIGV4dHJhLm1hcmdpblRvcCA9IGV4dHJhLm1hcmdpblRvcCB8fCAwO1xyXG4gICAgICAgICAgICAgICAgZXh0cmEubWFyZ2luUmlnaHQgPSBleHRyYS5tYXJnaW5SaWdodCB8fCAwO1xyXG4gICAgICAgICAgICAgICAgZXh0cmEubWFyZ2luQm90dG9tID0gZXh0cmEubWFyZ2luQm90dG9tIHx8IDA7XHJcbiAgICAgICAgICAgICAgICBleHRyYS5tYXJnaW5MZWZ0ID0gZXh0cmEubWFyZ2luTGVmdCB8fCAwO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZXh0cmFDYW52YXMgPSBleHRyYS5zb3VyY2UuX3JlbmRlcmVyLmdldENhbnZhcyhleHRyYS5zb3VyY2UuX3Jvb3RDb250YWluZXIuX2Rpc3BsYXksIG9wdGlvbnMpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZXh0cmFXaWR0aCA9IGV4dHJhQ2FudmFzLndpZHRoICsgZXh0cmEubWFyZ2luTGVmdCArIGV4dHJhLm1hcmdpblJpZ2h0O1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZXh0cmFIZWlnaHQgPSBleHRyYUNhbnZhcy5oZWlnaHQgKyBleHRyYS5tYXJnaW5Ub3AgKyBleHRyYS5tYXJnaW5Cb3R0b207XHJcbiAgICAgICAgICAgICAgICBpZiAoZXh0cmEucG9zaXRpb24gPT0gXCJ0b3BcIikge1xyXG4gICAgICAgICAgICAgICAgICAgIG1pZGRsZVdpZHRoID0gZXh0cmEuY3JvcCA/IG1pZGRsZUhlaWdodCA6IE1hdGgubWF4KG1pZGRsZVdpZHRoLCBleHRyYVdpZHRoKTtcclxuICAgICAgICAgICAgICAgICAgICBtaWRkbGVUb3AgKz0gZXh0cmFIZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChleHRyYS5wb3NpdGlvbiA9PSBcInJpZ2h0XCIpIHtcclxuICAgICAgICAgICAgICAgICAgICBtaWRkbGVIZWlnaHQgPSBleHRyYS5jcm9wID8gbWlkZGxlSGVpZ2h0IDogTWF0aC5tYXgobWlkZGxlSGVpZ2h0LCBleHRyYUhlaWdodCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZXh0cmFSaWdodCArPSBleHRyYVdpZHRoO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZXh0cmEucG9zaXRpb24gPT0gXCJsZWZ0XCIpIHtcclxuICAgICAgICAgICAgICAgICAgICBtaWRkbGVIZWlnaHQgPSBleHRyYS5jcm9wID8gbWlkZGxlSGVpZ2h0IDogTWF0aC5tYXgobWlkZGxlSGVpZ2h0LCBleHRyYUhlaWdodCk7XHJcbiAgICAgICAgICAgICAgICAgICAgbWlkZGxlTGVmdCArPSBleHRyYVdpZHRoO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZXh0cmEucG9zaXRpb24gPT09IFwiYm90dG9tXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICBtaWRkbGVXaWR0aCA9IGV4dHJhLmNyb3AgPyBtaWRkbGVIZWlnaHQgOiBNYXRoLm1heChtaWRkbGVXaWR0aCwgZXh0cmFXaWR0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZXh0cmFCb3R0b20gKz0gZXh0cmFIZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBleHRyYXMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FudmFzOiBleHRyYUNhbnZhcyxcclxuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogZXh0cmEucG9zaXRpb24sXHJcbiAgICAgICAgICAgICAgICAgICAgbGVmdDogZXh0cmEubWFyZ2luTGVmdCxcclxuICAgICAgICAgICAgICAgICAgICB0b3A6IGV4dHJhLm1hcmdpblRvcCxcclxuICAgICAgICAgICAgICAgICAgICB3aWR0aDogZXh0cmFXaWR0aCxcclxuICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IGV4dHJhSGVpZ2h0XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGNvbnN0IG5ld0NhbnZhcyA9IHRoaXMuZ2V0RGlzcG9zYWJsZUNhbnZhcygpO1xyXG4gICAgICAgICAgICBuZXdDYW52YXMud2lkdGggPSBtaWRkbGVMZWZ0ICsgbWlkZGxlV2lkdGggKyBleHRyYVJpZ2h0O1xyXG4gICAgICAgICAgICBuZXdDYW52YXMuaGVpZ2h0ID0gbWlkZGxlVG9wICsgbWlkZGxlSGVpZ2h0ICsgZXh0cmFCb3R0b207XHJcbiAgICAgICAgICAgIGNvbnN0IGN0eCA9IG5ld0NhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XHJcbiAgICAgICAgICAgIC8vIEdldCBiYWNrZ3JvdW5kXHJcbiAgICAgICAgICAgIGNvbnN0IGJhY2tncm91bmQgPSB0aGlzLmdldChcImJhY2tncm91bmRDb2xvclwiLCB0aGlzLmZpbmRCYWNrZ3JvdW5kQ29sb3IodGhpcy5fcm9vdC5kb20pKTtcclxuICAgICAgICAgICAgY29uc3QgYmFja2dyb3VuZE9wYWNpdHkgPSB0aGlzLmdldChcImJhY2tncm91bmRPcGFjaXR5XCIsIDEpO1xyXG4gICAgICAgICAgICBpZiAoYmFja2dyb3VuZCkge1xyXG4gICAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGJhY2tncm91bmQudG9DU1MoYmFja2dyb3VuZE9wYWNpdHkpO1xyXG4gICAgICAgICAgICAgICAgY3R4LmZpbGxSZWN0KDAsIDAsIG5ld0NhbnZhcy53aWR0aCwgbmV3Q2FudmFzLmhlaWdodCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGV0IGxlZnQgPSBtaWRkbGVMZWZ0O1xyXG4gICAgICAgICAgICBsZXQgdG9wID0gbWlkZGxlVG9wO1xyXG4gICAgICAgICAgICBsZXQgcmlnaHQgPSBsZWZ0ICsgbWlkZGxlV2lkdGg7XHJcbiAgICAgICAgICAgIGxldCBib3R0b20gPSB0b3AgKyBtaWRkbGVIZWlnaHQ7XHJcbiAgICAgICAgICAgIC8vIFJhZGlhdGVzIG91dHdhcmRzIGZyb20gY2VudGVyXHJcbiAgICAgICAgICAgICRhcnJheS5lYWNoKGV4dHJhcywgKGV4dHJhKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZXh0cmEucG9zaXRpb24gPT0gXCJ0b3BcIikge1xyXG4gICAgICAgICAgICAgICAgICAgIHRvcCAtPSBleHRyYS5oZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgY3R4LmRyYXdJbWFnZShleHRyYS5jYW52YXMsIG1pZGRsZUxlZnQgKyBleHRyYS5sZWZ0LCB0b3AgKyBleHRyYS50b3ApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZXh0cmEucG9zaXRpb24gPT0gXCJyaWdodFwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY3R4LmRyYXdJbWFnZShleHRyYS5jYW52YXMsIHJpZ2h0ICsgZXh0cmEubGVmdCwgbWlkZGxlVG9wICsgZXh0cmEudG9wKTtcclxuICAgICAgICAgICAgICAgICAgICByaWdodCArPSBleHRyYS53aWR0aDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGV4dHJhLnBvc2l0aW9uID09IFwibGVmdFwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGVmdCAtPSBleHRyYS53aWR0aDtcclxuICAgICAgICAgICAgICAgICAgICBjdHguZHJhd0ltYWdlKGV4dHJhLmNhbnZhcywgbGVmdCArIGV4dHJhLmxlZnQsIG1pZGRsZVRvcCArIGV4dHJhLnRvcCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChleHRyYS5wb3NpdGlvbiA9PT0gXCJib3R0b21cIikge1xyXG4gICAgICAgICAgICAgICAgICAgIGN0eC5kcmF3SW1hZ2UoZXh0cmEuY2FudmFzLCBtaWRkbGVMZWZ0ICsgZXh0cmEubGVmdCwgYm90dG9tICsgZXh0cmEudG9wKTtcclxuICAgICAgICAgICAgICAgICAgICBib3R0b20gKz0gZXh0cmEuaGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy90aGlzLmRpc3Bvc2VDYW52YXMoZXh0cmEuY2FudmFzKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGN0eC5kcmF3SW1hZ2UobWFpbkNhbnZhcywgbWlkZGxlTGVmdCwgbWlkZGxlVG9wKTtcclxuICAgICAgICAgICAgcmV0dXJuIG5ld0NhbnZhcztcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICAgICAqIEpTT05cclxuICAgICAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAgICAgKi9cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIGRhdGE6dXJpIHJlcHJlc2VudGF0aW9uIG9mIGEgSlNPTiBmaWxlIHdpdGggY2hhcnQgZGF0YS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gICBjdXN0b21PcHRpb25zICBGb3JtYXQgb3B0aW9uc1xyXG4gICAgICogQHJldHVybiAgICAgICAgICAgICAgICAgUHJvbWlzZVxyXG4gICAgICovXHJcbiAgICBleHBvcnRKU09OKGN1c3RvbU9wdGlvbnMpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gXCJkYXRhOlwiICsgdGhpcy5nZXRDb250ZW50VHlwZShcImpzb25cIikgKyBcIjtcIiArIHRoaXMuZ2V0KFwiY2hhcnNldFwiLCBcInV0Zi04XCIpICsgXCIsXCIgKyBlbmNvZGVVUklDb21wb25lbnQoeWllbGQgdGhpcy5nZXRKU09OKGN1c3RvbU9wdGlvbnMpKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBkYXRhIGluIEpTT04gZm9ybWF0LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSAgIGN1c3RvbU9wdGlvbnMgIEZvcm1hdCBvcHRpb25zXHJcbiAgICAgKiBAcmV0dXJuICAgICAgICAgICAgICAgICBQcm9taXNlXHJcbiAgICAgKi9cclxuICAgIGdldEpTT04oY3VzdG9tT3B0aW9ucykge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLl9nZXRGb3JtYXRPcHRpb25zKFwianNvblwiLCBjdXN0b21PcHRpb25zKTtcclxuICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHRoaXMuZ2V0RGF0YShcImpzb25cIiwgY3VzdG9tT3B0aW9ucywgb3B0aW9ucy5yZW5hbWVGaWVsZHMpLCAoX2tleSwgdmFsdWUpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmICgkdHlwZS5pc09iamVjdCh2YWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAkb2JqZWN0LmVhY2godmFsdWUsIChmaWVsZCwgaXRlbSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZVtmaWVsZF0gPSB0aGlzLmNvbnZlcnRUb1NwZWNpYWxGb3JtYXQoZmllbGQsIGl0ZW0sIG9wdGlvbnMpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgICAgICAgICB9LCBvcHRpb25zLmluZGVudCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAgICAgKiBDU1ZcclxuICAgICAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAgICAgKi9cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIGRhdGE6dXJpIHJlcHJlc2VudGF0aW9uIG9mIGEgQ1NWIGZpbGUgd2l0aCBjaGFydCBkYXRhLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSAgIGN1c3RvbU9wdGlvbnMgIEZvcm1hdCBvcHRpb25zXHJcbiAgICAgKiBAcmV0dXJuICAgICAgICAgICAgICAgICBQcm9taXNlXHJcbiAgICAgKi9cclxuICAgIGV4cG9ydENTVihjdXN0b21PcHRpb25zKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFwiZGF0YTpcIiArIHRoaXMuZ2V0Q29udGVudFR5cGUoXCJjc3ZcIikgKyBcIjtcIiArIHRoaXMuZ2V0KFwiY2hhcnNldFwiLCBcInV0Zi04XCIpICsgXCIsXCIgKyBlbmNvZGVVUklDb21wb25lbnQoeWllbGQgdGhpcy5nZXRDU1YoY3VzdG9tT3B0aW9ucykpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgQ1NWIHdpdGggZXhwb3J0IGRhdGEuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtICAgY3VzdG9tT3B0aW9ucyAgQ1NWIG9wdGlvbnNcclxuICAgICAqIEByZXR1cm4gICAgICAgICAgICAgICAgIFByb21pc2VcclxuICAgICAqL1xyXG4gICAgZ2V0Q1NWKGN1c3RvbU9wdGlvbnMpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICBjb25zdCBvcHRpb25zID0gdGhpcy5fZ2V0Rm9ybWF0T3B0aW9ucyhcImNzdlwiLCBjdXN0b21PcHRpb25zKTtcclxuICAgICAgICAgICAgLy8gSW5pdCBvdXRwdXRcclxuICAgICAgICAgICAgbGV0IGNzdiA9IFwiXCI7XHJcbiAgICAgICAgICAgIC8vIEFkZCByb3dzXHJcbiAgICAgICAgICAgIGxldCBiciA9IFwiXCI7XHJcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSB0aGlzLmdldERhdGEoXCJjc3ZcIiwgb3B0aW9ucyk7XHJcbiAgICAgICAgICAgIC8vIERhdGEgZmllbGRzXHJcbiAgICAgICAgICAgIGNvbnN0IGRhdGFGaWVsZHMgPSB0aGlzLmdldERhdGFGaWVsZHMoZGF0YSk7XHJcbiAgICAgICAgICAgIC8vIFZlcnRpY2FsIG9yIGhvcml6b250YWwgKGRlZmF1bHQpIGxheW91dFxyXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5waXZvdCkge1xyXG4gICAgICAgICAgICAgICAgLy8gRGF0YSBmaWVsZHMgb3JkZXJcclxuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGFGaWVsZHNPcmRlciA9IHRoaXMuZ2V0KFwiZGF0YUZpZWxkc09yZGVyXCIsIFtdKTtcclxuICAgICAgICAgICAgICAgICRvYmplY3QuZWFjaE9yZGVyZWQoZGF0YUZpZWxkcywgKGtleSwgdmFsKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGRhdGFSb3cgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5hZGRDb2x1bW5OYW1lcykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhUm93LnB1c2godmFsKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgbGVuID0gZGF0YS5sZW5ndGgsIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGRhdGFWYWx1ZSA9IGRhdGFbaV1ba2V5XTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVJvdy5wdXNoKHRoaXMuY29udmVydFRvU3BlY2lhbEZvcm1hdChrZXksIGRhdGFWYWx1ZSwgb3B0aW9ucywgdHJ1ZSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjc3YgKz0gYnIgKyB0aGlzLmdldENTVlJvdyhkYXRhUm93LCBvcHRpb25zLCB1bmRlZmluZWQsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyID0gXCJcXG5cIjtcclxuICAgICAgICAgICAgICAgIH0sIChhLCBiKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGFpID0gZGF0YUZpZWxkc09yZGVyLmluZGV4T2YoYSk7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGJpID0gZGF0YUZpZWxkc09yZGVyLmluZGV4T2YoYik7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFpID4gYmkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChhaSA8IGJpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAxO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgbGVuID0gZGF0YS5sZW5ndGgsIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgcm93ID0gdGhpcy5nZXRDU1ZSb3coZGF0YVtpXSwgb3B0aW9ucywgZGF0YUZpZWxkcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMucmV2ZXJzZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjc3YgPSByb3cgKyBiciArIGNzdjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNzdiArPSBiciArIHJvdztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgYnIgPSBcIlxcblwiO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gQWRkIGNvbHVtbiBuYW1lcz9cclxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmFkZENvbHVtbk5hbWVzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY3N2ID0gdGhpcy5nZXRDU1ZSb3coZGF0YUZpZWxkcywgb3B0aW9ucywgdW5kZWZpbmVkLCB0cnVlKSArIGJyICsgY3N2O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBjc3Y7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEBpZ25vcmVcclxuICAgICAqL1xyXG4gICAgZ2V0Q1NWUm93KHJvdywgb3B0aW9ucywgZGF0YUZpZWxkcywgYXNJcyA9IGZhbHNlKSB7XHJcbiAgICAgICAgLy8gSW5pdFxyXG4gICAgICAgIGxldCBzZXBhcmF0b3IgPSBvcHRpb25zLnNlcGFyYXRvciB8fCBcIixcIjtcclxuICAgICAgICBsZXQgaXRlbXMgPSBbXTtcclxuICAgICAgICAvLyBEYXRhIGZpZWxkc1xyXG4gICAgICAgIGlmICghZGF0YUZpZWxkcykge1xyXG4gICAgICAgICAgICBkYXRhRmllbGRzID0ge307XHJcbiAgICAgICAgICAgICRvYmplY3QuZWFjaChyb3csIChrZXksIHZhbHVlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBkYXRhRmllbGRzW2tleV0gPSB2YWx1ZTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIERhdGEgZmllbGRzIG9yZGVyXHJcbiAgICAgICAgY29uc3QgZGF0YUZpZWxkc09yZGVyID0gdGhpcy5nZXQoXCJkYXRhRmllbGRzT3JkZXJcIiwgW10pO1xyXG4gICAgICAgIC8vIFByb2Nlc3MgZWFjaCByb3cgaXRlbVxyXG4gICAgICAgICRvYmplY3QuZWFjaE9yZGVyZWQoZGF0YUZpZWxkcywgKGtleSwgX25hbWUpID0+IHtcclxuICAgICAgICAgICAgLy8gR2V0IHZhbHVlXHJcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IHRoaXMuY29udmVydEVtcHR5VmFsdWUoa2V5LCByb3dba2V5XSwgb3B0aW9ucyk7XHJcbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHdlIG5lZWQgdG8gc2tpcFxyXG4gICAgICAgICAgICAvLyBUaGlzIGlzIG5vIGxvbmdlciByZXF1aXJlZCBiZWNhdXNlIHdlIGFyZSBpdGVyYXRpbmcgdmlhIGRhdGFGaWVsZHMgYW55d2F5XHJcbiAgICAgICAgICAgIC8qaWYgKHRoaXMuZGF0YUZpZWxkcyAhPSBudWxsICYmIHRoaXMuZGF0YUZpZWxkc1trZXldID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfSovXHJcbiAgICAgICAgICAgIC8vIENvbnZlcnQgZGF0ZXNcclxuICAgICAgICAgICAgbGV0IGl0ZW0gPSBhc0lzID8gdmFsdWUgOiB0aGlzLmNvbnZlcnRUb1NwZWNpYWxGb3JtYXQoa2V5LCB2YWx1ZSwgb3B0aW9ucyk7XHJcbiAgICAgICAgICAgIC8vIENhc3QgYW5kIGVzY2FwZSBkb3VibGVxdW90ZXNcclxuICAgICAgICAgICAgaXRlbSA9IFwiXCIgKyBpdGVtO1xyXG4gICAgICAgICAgICBpdGVtID0gaXRlbS5yZXBsYWNlKC9cIi9nLCAnXCJcIicpO1xyXG4gICAgICAgICAgICAvLyBFbmNsb3NlIGludG8gZG91YmxlIHF1b3Rlc1xyXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5mb3JjZVF1b3RlcyB8fCAoaXRlbS5zZWFyY2gobmV3IFJlZ0V4cChcIlxcXCJ8XFxufFwiICsgc2VwYXJhdG9yLCBcImdcIikpID49IDApKSB7XHJcbiAgICAgICAgICAgICAgICBpdGVtID0gXCJcXFwiXCIgKyBpdGVtICsgXCJcXFwiXCI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gQWRkIHRvIGl0ZW1cclxuICAgICAgICAgICAgaXRlbXMucHVzaChpdGVtKTtcclxuICAgICAgICB9LCAoYSwgYikgPT4ge1xyXG4gICAgICAgICAgICBsZXQgYWkgPSBkYXRhRmllbGRzT3JkZXIuaW5kZXhPZihhKTtcclxuICAgICAgICAgICAgbGV0IGJpID0gZGF0YUZpZWxkc09yZGVyLmluZGV4T2YoYik7XHJcbiAgICAgICAgICAgIGlmIChhaSA+IGJpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChhaSA8IGJpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gLTE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIGl0ZW1zLmpvaW4oc2VwYXJhdG9yKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICAgICAqIEhUTUxcclxuICAgICAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAgICAgKi9cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIGRhdGE6dXJpIHJlcHJlc2VudGF0aW9uIG9mIGFuIEhUTUwgZmlsZSB3aXRoIGNoYXJ0IGRhdGEuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtICAgY3VzdG9tT3B0aW9ucyAgRm9ybWF0IG9wdGlvbnNcclxuICAgICAqIEByZXR1cm4gICAgICAgICAgICAgICAgIFByb21pc2VcclxuICAgICAqL1xyXG4gICAgZXhwb3J0SFRNTChjdXN0b21PcHRpb25zKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFwiZGF0YTpcIiArIHRoaXMuZ2V0Q29udGVudFR5cGUoXCJodG1sXCIpICsgXCI7XCIgKyB0aGlzLmdldChcImNoYXJzZXRcIiwgXCJ1dGYtOFwiKSArIFwiLFwiICsgZW5jb2RlVVJJQ29tcG9uZW50KHlpZWxkIHRoaXMuZ2V0SFRNTChjdXN0b21PcHRpb25zKSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYW4gSFRNTCB3aXRoIGEgdGFibGUgd2l0aCBleHBvcnQgZGF0YS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gICBjdXN0b21PcHRpb25zICBIVE1MIG9wdGlvbnNcclxuICAgICAqIEByZXR1cm4gICAgICAgICAgICAgICAgIFByb21pc2VcclxuICAgICAqL1xyXG4gICAgZ2V0SFRNTChjdXN0b21PcHRpb25zKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMuX2dldEZvcm1hdE9wdGlvbnMoXCJodG1sXCIsIGN1c3RvbU9wdGlvbnMpO1xyXG4gICAgICAgICAgICAvLyBJbml0IG91dHB1dFxyXG4gICAgICAgICAgICBsZXQgaHRtbCA9IFwiPHRhYmxlPlwiO1xyXG4gICAgICAgICAgICBpZiAob3B0aW9ucy50YWJsZUNsYXNzKSB7XHJcbiAgICAgICAgICAgICAgICBodG1sID0gXCI8dGFibGUgY2xhc3M9XFxcIlwiICsgb3B0aW9ucy50YWJsZUNsYXNzICsgXCJcXFwiPlwiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIEdldCBkYXRhXHJcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSB0aGlzLmdldERhdGEoXCJodG1sXCIsIG9wdGlvbnMpO1xyXG4gICAgICAgICAgICBjb25zdCBkYXRhRmllbGRzID0gdGhpcy5nZXREYXRhRmllbGRzKGRhdGEpO1xyXG4gICAgICAgICAgICAvLyBWZXJ0aWNhbCBvciBob3Jpem9udGFsIChkZWZhdWx0KSBsYXlvdXRcclxuICAgICAgICAgICAgaWYgKG9wdGlvbnMucGl2b3QpIHtcclxuICAgICAgICAgICAgICAgIC8vIERhdGEgZmllbGRzIG9yZGVyXHJcbiAgICAgICAgICAgICAgICBjb25zdCBkYXRhRmllbGRzT3JkZXIgPSB0aGlzLmdldChcImRhdGFGaWVsZHNPcmRlclwiLCBbXSk7XHJcbiAgICAgICAgICAgICAgICBodG1sICs9IFwiXFxuPHRib2R5PlwiO1xyXG4gICAgICAgICAgICAgICAgJG9iamVjdC5lYWNoT3JkZXJlZChkYXRhRmllbGRzLCAoa2V5LCB2YWwpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgZGF0YVJvdyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmFkZENvbHVtbk5hbWVzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFSb3cucHVzaCh2YWwpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBsZW4gPSBkYXRhLmxlbmd0aCwgaSA9IDA7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgZGF0YVZhbHVlID0gZGF0YVtpXVtrZXldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhUm93LnB1c2godGhpcy5jb252ZXJ0VG9TcGVjaWFsRm9ybWF0KGtleSwgZGF0YVZhbHVlLCBvcHRpb25zLCB0cnVlKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGh0bWwgKz0gXCJcXG5cIiArIHRoaXMuZ2V0SFRNTFJvdyhkYXRhUm93LCBvcHRpb25zLCB1bmRlZmluZWQsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgfSwgKGEsIGIpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgYWkgPSBkYXRhRmllbGRzT3JkZXIuaW5kZXhPZihhKTtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgYmkgPSBkYXRhRmllbGRzT3JkZXIuaW5kZXhPZihiKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYWkgPiBiaSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gLTE7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGFpIDwgYmkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBodG1sICs9IFwiXFxuPC90Ym9keT5cIjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIEFkZCBjb2x1bW4gbmFtZXM/XHJcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5hZGRDb2x1bW5OYW1lcykge1xyXG4gICAgICAgICAgICAgICAgICAgIGh0bWwgKz0gXCJcXG48dGhlYWQ+XFxuXCIgKyB0aGlzLmdldEhUTUxSb3coZGF0YUZpZWxkcywgb3B0aW9ucywgdW5kZWZpbmVkLCB0cnVlLCB0cnVlKSArIFwiXFxuPC90aGVhZD5cIjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGh0bWwgKz0gXCJcXG48dGJvZHk+XCI7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBsZW4gPSBkYXRhLmxlbmd0aCwgaSA9IDA7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGh0bWwgKz0gXCJcXG5cIiArIHRoaXMuZ2V0SFRNTFJvdyhkYXRhW2ldLCBvcHRpb25zLCBkYXRhRmllbGRzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGh0bWwgKz0gXCJcXG48L3Rib2R5PlwiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGh0bWwgKz0gXCJcXG48L3RhYmxlPlwiO1xyXG4gICAgICAgICAgICByZXR1cm4gaHRtbDtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQGlnbm9yZVxyXG4gICAgICovXHJcbiAgICBnZXRIVE1MUm93KHJvdywgb3B0aW9ucywgZGF0YUZpZWxkcywgYXNJcyA9IGZhbHNlLCBoZWFkZXJSb3cgPSBmYWxzZSkge1xyXG4gICAgICAgIC8vIEluaXQgb3V0cHV0XHJcbiAgICAgICAgbGV0IGh0bWwgPSBcIlxcdDx0cj5cIjtcclxuICAgICAgICBpZiAob3B0aW9ucy5yb3dDbGFzcykge1xyXG4gICAgICAgICAgICBodG1sID0gXCJcXHQ8dHIgY2xhc3M9XFxcIlwiICsgb3B0aW9ucy5yb3dDbGFzcyArIFwiXFxcIj5cIjtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gRGF0YSBmaWVsZHNcclxuICAgICAgICBpZiAoIWRhdGFGaWVsZHMpIHtcclxuICAgICAgICAgICAgZGF0YUZpZWxkcyA9IHJvdztcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gRGF0YSBmaWVsZHMgb3JkZXJcclxuICAgICAgICBjb25zdCBkYXRhRmllbGRzT3JkZXIgPSB0aGlzLmdldChcImRhdGFGaWVsZHNPcmRlclwiLCBbXSk7XHJcbiAgICAgICAgLy8gdGggb3IgZGg/XHJcbiAgICAgICAgY29uc3QgdGFnID0gaGVhZGVyUm93ID8gXCJ0aFwiIDogXCJ0ZFwiO1xyXG4gICAgICAgIC8vIFByb2Nlc3MgZWFjaCByb3cgaXRlbVxyXG4gICAgICAgIGxldCBmaXJzdCA9IHRydWU7XHJcbiAgICAgICAgJG9iamVjdC5lYWNoT3JkZXJlZChkYXRhRmllbGRzLCAoa2V5LCBfbmFtZSkgPT4ge1xyXG4gICAgICAgICAgICAvLyBHZXQgdmFsdWVcclxuICAgICAgICAgICAgbGV0IHZhbHVlID0gdGhpcy5jb252ZXJ0RW1wdHlWYWx1ZShrZXksIHJvd1trZXldLCBvcHRpb25zKTtcclxuICAgICAgICAgICAgLy8gQ29udmVydCBkYXRlc1xyXG4gICAgICAgICAgICBsZXQgaXRlbSA9IGFzSXMgPyB2YWx1ZSA6IHRoaXMuY29udmVydFRvU3BlY2lhbEZvcm1hdChrZXksIHZhbHVlLCBvcHRpb25zKTtcclxuICAgICAgICAgICAgLy8gRXNjYXBlIEhUTUwgZW50aXRpZXNcclxuICAgICAgICAgICAgaXRlbSA9IFwiXCIgKyBpdGVtO1xyXG4gICAgICAgICAgICBpdGVtID0gaXRlbS5yZXBsYWNlKC9bXFx1MDBBMC1cXHU5OTk5PD5cXCZdL2dpbSwgZnVuY3Rpb24gKGkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBcIiYjXCIgKyBpLmNoYXJDb2RlQXQoMCkgKyBcIjtcIjtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIC8vIFdoaWNoIHRhZyB0byB1c2VcclxuICAgICAgICAgICAgbGV0IHVzZVRhZyA9IHRhZztcclxuICAgICAgICAgICAgaWYgKG9wdGlvbnMucGl2b3QgJiYgZmlyc3QpIHtcclxuICAgICAgICAgICAgICAgIHVzZVRhZyA9IFwidGhcIjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBBZGQgY2VsbFxyXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5jZWxsQ2xhc3MpIHtcclxuICAgICAgICAgICAgICAgIGh0bWwgKz0gXCJcXG5cXHRcXHQ8XCIgKyB1c2VUYWcgKyBcIiBjbGFzcz1cXFwiXCIgKyBvcHRpb25zLmNlbGxDbGFzcyArIFwiXFxcIj5cIiArIGl0ZW0gKyBcIjwvXCIgKyB1c2VUYWcgKyBcIj5cIjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGh0bWwgKz0gXCJcXG5cXHRcXHQ8XCIgKyB1c2VUYWcgKyBcIj5cIiArIGl0ZW0gKyBcIjwvXCIgKyB1c2VUYWcgKyBcIj5cIjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmaXJzdCA9IGZhbHNlO1xyXG4gICAgICAgIH0sIChhLCBiKSA9PiB7XHJcbiAgICAgICAgICAgIGxldCBhaSA9IGRhdGFGaWVsZHNPcmRlci5pbmRleE9mKGEpO1xyXG4gICAgICAgICAgICBsZXQgYmkgPSBkYXRhRmllbGRzT3JkZXIuaW5kZXhPZihiKTtcclxuICAgICAgICAgICAgaWYgKGFpID4gYmkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGFpIDwgYmkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICB9KTtcclxuICAgICAgICBodG1sICs9IFwiXFxuXFx0PC90cj5cIjtcclxuICAgICAgICByZXR1cm4gaHRtbDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICAgICAqIFhMU1hcclxuICAgICAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAgICAgKi9cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIGRhdGE6dXJpIHJlcHJlc2VudGF0aW9uIG9mIGFuIFhMU1ggZmlsZSB3aXRoIGNoYXJ0IGRhdGEuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtICAgY3VzdG9tT3B0aW9ucyAgRm9ybWF0IG9wdGlvbnNcclxuICAgICAqIEByZXR1cm4gICAgICAgICAgICAgICAgIFByb21pc2VcclxuICAgICAqL1xyXG4gICAgZXhwb3J0WExTWChjdXN0b21PcHRpb25zKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFwiZGF0YTpcIiArIHRoaXMuZ2V0Q29udGVudFR5cGUoXCJ4bHN4XCIpICsgXCI7XCIgKyB0aGlzLmdldChcImNoYXJzZXRcIiwgXCJ1dGYtOFwiKSArIFwiLFwiICsgZW5jb2RlVVJJQ29tcG9uZW50KHlpZWxkIHRoaXMuZ2V0WExTWChjdXN0b21PcHRpb25zKSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBkYXRhOnVyaSBvZiBYTFNYIGRhdGEuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtICBjdXN0b21PcHRpb25zICBGb3JtYXQgb3B0aW9uc1xyXG4gICAgICogQHJldHVybiAgICAgICAgICAgICAgICBQcm9taXNlXHJcbiAgICAgKi9cclxuICAgIGdldFhMU1goY3VzdG9tT3B0aW9ucykge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLl9nZXRGb3JtYXRPcHRpb25zKFwieGxzeFwiLCBjdXN0b21PcHRpb25zKTtcclxuICAgICAgICAgICAgLy8gTG9hZCB4bHN4XHJcbiAgICAgICAgICAgIGxldCBYTFNYID0geWllbGQgdGhpcy5nZXRYTFNYTGliKCk7XHJcbiAgICAgICAgICAgIC8vIENyZWF0ZSB3b3JrYm9vayBvcHRpb25zXHJcbiAgICAgICAgICAgIGxldCB3Yk9wdGlvbnMgPSB7XHJcbiAgICAgICAgICAgICAgICBib29rVHlwZTogXCJ4bHN4XCIsXHJcbiAgICAgICAgICAgICAgICBib29rU1NUOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIHR5cGU6IFwiYmFzZTY0XCIsXHJcbiAgICAgICAgICAgICAgICAvL2RhdGVORjogJ3l5eXktbW0tZGQnXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8vIEdldCBzaGVldCBuYW1lXHJcbiAgICAgICAgICAgIGxldCBzaGVldE5hbWUgPSB0aGlzLl9ub3JtYWxpemVFeGNlbFNoZWV0TmFtZSh0aGlzLmdldChcInRpdGxlXCIsIHRoaXMuX3QoXCJEYXRhXCIpKSk7XHJcbiAgICAgICAgICAgIC8vIENyZWF0ZSBhIHdvcmtib29rXHJcbiAgICAgICAgICAgIGxldCB3YiA9IHtcclxuICAgICAgICAgICAgICAgIFNoZWV0TmFtZXM6IFtzaGVldE5hbWVdLFxyXG4gICAgICAgICAgICAgICAgU2hlZXRzOiB7fVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvLyBJbml0IHdvcmtzaGVldCBkYXRhXHJcbiAgICAgICAgICAgIGxldCB3c0RhdGEgPSBbXTtcclxuICAgICAgICAgICAgLy8gR2V0IGRhdGFcclxuICAgICAgICAgICAgY29uc3QgZGF0YSA9IHRoaXMuZ2V0RGF0YShcImh0bWxcIiwgb3B0aW9ucyk7XHJcbiAgICAgICAgICAgIGNvbnN0IGRhdGFGaWVsZHMgPSB0aGlzLmdldERhdGFGaWVsZHMoZGF0YSk7XHJcbiAgICAgICAgICAgIC8vIFZlcnRpY2FsIG9yIGhvcml6b250YWwgKGRlZmF1bHQpIGxheW91dFxyXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5waXZvdCkge1xyXG4gICAgICAgICAgICAgICAgLy8gRGF0YSBmaWVsZHMgb3JkZXJcclxuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGFGaWVsZHNPcmRlciA9IHRoaXMuZ2V0KFwiZGF0YUZpZWxkc09yZGVyXCIsIFtdKTtcclxuICAgICAgICAgICAgICAgICRvYmplY3QuZWFjaE9yZGVyZWQoZGF0YUZpZWxkcywgKGtleSwgdmFsKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGRhdGFSb3cgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5hZGRDb2x1bW5OYW1lcykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhUm93LnB1c2godmFsKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgbGVuID0gZGF0YS5sZW5ndGgsIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGRhdGFWYWx1ZSA9IGRhdGFbaV1ba2V5XTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVJvdy5wdXNoKHRoaXMuY29udmVydFRvU3BlY2lhbEZvcm1hdChrZXksIGRhdGFWYWx1ZSwgb3B0aW9ucywgdHJ1ZSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB3c0RhdGEucHVzaCh0aGlzLmdldFhMU1hSb3coZGF0YVJvdywgb3B0aW9ucywgdW5kZWZpbmVkLCB0cnVlKSk7XHJcbiAgICAgICAgICAgICAgICB9LCAoYSwgYikgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBhaSA9IGRhdGFGaWVsZHNPcmRlci5pbmRleE9mKGEpO1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBiaSA9IGRhdGFGaWVsZHNPcmRlci5pbmRleE9mKGIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChhaSA+IGJpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAxO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChhaSA8IGJpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAtMTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIEFkZCBjb2x1bW4gbmFtZXM/XHJcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5hZGRDb2x1bW5OYW1lcykge1xyXG4gICAgICAgICAgICAgICAgICAgIHdzRGF0YS5wdXNoKHRoaXMuZ2V0WExTWFJvdyhkYXRhRmllbGRzLCBvcHRpb25zLCB1bmRlZmluZWQsIHRydWUpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIEFkZCBsaW5lc1xyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgbGVuID0gZGF0YS5sZW5ndGgsIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB3c0RhdGEucHVzaCh0aGlzLmdldFhMU1hSb3coZGF0YVtpXSwgb3B0aW9ucywgZGF0YUZpZWxkcykpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIENyZWF0ZSBzaGVldCBhbmQgYWRkIGRhdGFcclxuICAgICAgICAgICAgd2IuU2hlZXRzW3NoZWV0TmFtZV0gPSBYTFNYLnV0aWxzLmFvYV90b19zaGVldCh3c0RhdGEpO1xyXG4gICAgICAgICAgICB0aGlzLmV2ZW50cy5kaXNwYXRjaChcIndvcmtib29rcmVhZHlcIiwge1xyXG4gICAgICAgICAgICAgICAgdHlwZTogXCJ3b3JrYm9va3JlYWR5XCIsXHJcbiAgICAgICAgICAgICAgICBmb3JtYXQ6IFwieGxzeFwiLFxyXG4gICAgICAgICAgICAgICAgb3B0aW9uczogb3B0aW9ucyxcclxuICAgICAgICAgICAgICAgIHdvcmtib29rOiB3YixcclxuICAgICAgICAgICAgICAgIHdvcmtib29rT3B0aW9uczogd2JPcHRpb25zLFxyXG4gICAgICAgICAgICAgICAgeGxzeDogWExTWCxcclxuICAgICAgICAgICAgICAgIHRhcmdldDogdGhpc1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIFhMU1gud3JpdGUod2IsIHdiT3B0aW9ucyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBfbm9ybWFsaXplRXhjZWxTaGVldE5hbWUobmFtZSkge1xyXG4gICAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UoLyhbOlxcXFxcXC8/KlxcW1xcXV0rKS9nLCBcIiBcIik7XHJcbiAgICAgICAgcmV0dXJuIG5hbWUubGVuZ3RoID4gMzAgPyBuYW1lLnN1YnN0cigwLCAzMCkgKyBcIi4uLlwiIDogbmFtZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQGlnbm9yZVxyXG4gICAgICovXHJcbiAgICBnZXRYTFNYUm93KHJvdywgb3B0aW9ucywgZGF0YUZpZWxkcywgYXNJcyA9IGZhbHNlKSB7XHJcbiAgICAgICAgLy8gSW5pdFxyXG4gICAgICAgIGxldCBpdGVtcyA9IFtdO1xyXG4gICAgICAgIC8vIERhdGEgZmllbGRzXHJcbiAgICAgICAgaWYgKCFkYXRhRmllbGRzKSB7XHJcbiAgICAgICAgICAgIGRhdGFGaWVsZHMgPSByb3c7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIERhdGEgZmllbGRzIG9yZGVyXHJcbiAgICAgICAgY29uc3QgZGF0YUZpZWxkc09yZGVyID0gdGhpcy5nZXQoXCJkYXRhRmllbGRzT3JkZXJcIiwgW10pO1xyXG4gICAgICAgIC8vIFByb2Nlc3MgZWFjaCByb3cgaXRlbVxyXG4gICAgICAgICRvYmplY3QuZWFjaE9yZGVyZWQoZGF0YUZpZWxkcywgKGtleSwgX25hbWUpID0+IHtcclxuICAgICAgICAgICAgLy8gR2V0IHZhbHVlXHJcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IHRoaXMuY29udmVydEVtcHR5VmFsdWUoa2V5LCByb3dba2V5XSwgb3B0aW9ucyk7XHJcbiAgICAgICAgICAgIC8vIENvbnZlcnQgZGF0ZXNcclxuICAgICAgICAgICAgbGV0IGl0ZW0gPSBhc0lzID8gdmFsdWUgOiB0aGlzLmNvbnZlcnRUb1NwZWNpYWxGb3JtYXQoa2V5LCB2YWx1ZSwgb3B0aW9ucywgdHJ1ZSk7XHJcbiAgICAgICAgICAgIGl0ZW1zLnB1c2goaXRlbSk7XHJcbiAgICAgICAgfSwgKGEsIGIpID0+IHtcclxuICAgICAgICAgICAgbGV0IGFpID0gZGF0YUZpZWxkc09yZGVyLmluZGV4T2YoYSk7XHJcbiAgICAgICAgICAgIGxldCBiaSA9IGRhdGFGaWVsZHNPcmRlci5pbmRleE9mKGIpO1xyXG4gICAgICAgICAgICBpZiAoYWkgPiBiaSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoYWkgPCBiaSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBpdGVtcztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQGlnbm9yZVxyXG4gICAgICovXHJcbiAgICBfeGxzeCgpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICByZXR1cm4geWllbGQgaW1wb3J0KC8qIHdlYnBhY2tDaHVua05hbWU6IFwieGxzeFwiICovIFwiLi4vLi4vYnVuZGxlZC94bHN4XCIpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAaWdub3JlXHJcbiAgICAgKi9cclxuICAgIGdldFhMU1hMaWIoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3hsc3goKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICAgICAqIFBERlxyXG4gICAgICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICAgICAqL1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgZGF0YTp1cmkgcmVwcmVzZW50YXRpb24gb2YgYSBQREYgZmlsZSB3aXRoIGNoYXJ0IGltYWdlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSAgIGN1c3RvbU9wdGlvbnMgIEZvcm1hdCBvcHRpb25zXHJcbiAgICAgKiBAcmV0dXJuICAgICAgICAgICAgICAgICBQcm9taXNlXHJcbiAgICAgKi9cclxuICAgIGV4cG9ydFBERihjdXN0b21PcHRpb25zKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFwiZGF0YTpcIiArIHRoaXMuZ2V0Q29udGVudFR5cGUoXCJwZGZcIikgKyBcIjtcIiArIHRoaXMuZ2V0KFwiY2hhcnNldFwiLCBcInV0Zi04XCIpICsgXCIsXCIgKyBlbmNvZGVVUklDb21wb25lbnQoeWllbGQgdGhpcy5nZXRQREYoY3VzdG9tT3B0aW9ucywgdHJ1ZSkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgZGF0YTp1cmkgcmVwcmVzZW50YXRpb24gb2YgYSBQREYgZmlsZSB3aXRoIGNoYXJ0IGRhdGEuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtICAgY3VzdG9tT3B0aW9ucyAgRm9ybWF0IG9wdGlvbnNcclxuICAgICAqIEByZXR1cm4gICAgICAgICAgICAgICAgIFByb21pc2VcclxuICAgICAqL1xyXG4gICAgZXhwb3J0UERGRGF0YShjdXN0b21PcHRpb25zKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFwiZGF0YTpcIiArIHRoaXMuZ2V0Q29udGVudFR5cGUoXCJwZGZcIikgKyBcIjtcIiArIHRoaXMuZ2V0KFwiY2hhcnNldFwiLCBcInV0Zi04XCIpICsgXCIsXCIgKyBlbmNvZGVVUklDb21wb25lbnQoeWllbGQgdGhpcy5nZXRQREYoY3VzdG9tT3B0aW9ucywgZmFsc2UsIHRydWUpKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBCYXNlNjQtZW5jb2RlZCBiaW5hcnkgZGF0YSBmb3IgYSBQREYgZmlsZS5cclxuICAgICAqIEBwYXJhbSAgIGN1c3RvbU9wdGlvbnMgIFBERiBvcHRpb25zXHJcbiAgICAgKiBAcGFyYW0gICBpbmNsdWRlSW1hZ2UgICBJbmNsdWRlIGNoYXJ0IHNuYXBzaG90XHJcbiAgICAgKiBAcGFyYW0gICBpbmNsdWRlRGF0YSAgICBJbmNsdWRlIGRhdGFcclxuICAgICAqIEByZXR1cm4gICAgICAgICAgICAgICAgIFByb21pc2VcclxuICAgICAqL1xyXG4gICAgZ2V0UERGKGN1c3RvbU9wdGlvbnMsIGluY2x1ZGVJbWFnZSA9IHRydWUsIGluY2x1ZGVEYXRhID0gZmFsc2UpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICBjb25zdCBvcHRpb25zID0gdGhpcy5fZ2V0Rm9ybWF0T3B0aW9ucyhcInBkZlwiLCBjdXN0b21PcHRpb25zKTtcclxuICAgICAgICAgICAgY29uc3QgZGF0YU9wdGlvbnMgPSB0aGlzLl9nZXRGb3JtYXRPcHRpb25zKFwicGRmZGF0YVwiLCBjdXN0b21PcHRpb25zKTtcclxuICAgICAgICAgICAgY29uc3Qgb3JpZW50YXRpb24gPSBvcHRpb25zLnBhZ2VPcmllbnRhdGlvbiB8fCBcInBvcnRyYWl0XCI7XHJcbiAgICAgICAgICAgIC8vIEdldCBpbWFnZVxyXG4gICAgICAgICAgICBsZXQgaW1hZ2U7XHJcbiAgICAgICAgICAgIGlmIChpbmNsdWRlSW1hZ2UpIHtcclxuICAgICAgICAgICAgICAgIGltYWdlID0geWllbGQgdGhpcy5leHBvcnRJbWFnZShvcHRpb25zLmltYWdlRm9ybWF0IHx8IFwicG5nXCIsIG9wdGlvbnMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIExvYWQgcGRmbWFrZVxyXG4gICAgICAgICAgICBjb25zdCBwZGZtYWtlID0geWllbGQgdGhpcy5nZXRQZGZtYWtlKCk7XHJcbiAgICAgICAgICAgIC8vIERlZmF1bHRzXHJcbiAgICAgICAgICAgIGNvbnN0IGRlZmF1bHRNYXJnaW5zID0gWzMwLCAzMCwgMzAsIDMwXTtcclxuICAgICAgICAgICAgLy8gSW5pdCBjb250ZW50IGZvciBQREZcclxuICAgICAgICAgICAgbGV0IGRvYyA9IHtcclxuICAgICAgICAgICAgICAgIHBhZ2VTaXplOiBvcHRpb25zLnBhZ2VTaXplIHx8IFwiQTRcIixcclxuICAgICAgICAgICAgICAgIHBhZ2VPcmllbnRhdGlvbjogb3JpZW50YXRpb24sXHJcbiAgICAgICAgICAgICAgICBwYWdlTWFyZ2luczogb3B0aW9ucy5wYWdlTWFyZ2lucyB8fCBkZWZhdWx0TWFyZ2lucyxcclxuICAgICAgICAgICAgICAgIGRlZmF1bHRTdHlsZToge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvbnQ6IG9wdGlvbnMuZm9udCA/IG9wdGlvbnMuZm9udC5uYW1lIDogdW5kZWZpbmVkXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgLy9oZWFkZXI6IDxhbnk+W10sXHJcbiAgICAgICAgICAgICAgICBjb250ZW50OiBbXVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvLyBTaG91bGQgd2UgYWRkIHRpdGxlP1xyXG4gICAgICAgICAgICBjb25zdCB0aXRsZSA9IHRoaXMuZ2V0KFwidGl0bGVcIik7XHJcbiAgICAgICAgICAgIGxldCBleHRyYU1hcmdpbiA9IDA7XHJcbiAgICAgICAgICAgIGlmICh0aXRsZSkge1xyXG4gICAgICAgICAgICAgICAgZG9jLmNvbnRlbnQucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgdGV4dDogdGl0bGUsXHJcbiAgICAgICAgICAgICAgICAgICAgZm9udFNpemU6IG9wdGlvbnMuZm9udFNpemUgfHwgMTQsXHJcbiAgICAgICAgICAgICAgICAgICAgYm9sZDogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICBtYXJnaW46IFswLCAwLCAwLCAxNV1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgLy8gQWRkIHNvbWUgbGVmdG92ZXIgbWFyZ2luIGZvciB0aXRsZVxyXG4gICAgICAgICAgICAgICAgZXh0cmFNYXJnaW4gKz0gNTA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gQWRkIHBhZ2UgVVJMP1xyXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5hZGRVUkwpIHtcclxuICAgICAgICAgICAgICAgIGRvYy5jb250ZW50LnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICAgIHRleHQ6IHRoaXMuX3QoXCJTYXZlZCBmcm9tXCIpICsgXCI6IFwiICsgZG9jdW1lbnQubG9jYXRpb24uaHJlZixcclxuICAgICAgICAgICAgICAgICAgICBmb250U2l6ZTogb3B0aW9ucy5mb250U2l6ZSxcclxuICAgICAgICAgICAgICAgICAgICBtYXJnaW46IFswLCAwLCAwLCAxNV1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgLy8gQWRkIHNvbWUgbGVmdG92ZXIgbWFyZ2luIGZvciBVUkxcclxuICAgICAgICAgICAgICAgIGV4dHJhTWFyZ2luICs9IDUwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIEFkZCBpbWFnZVxyXG4gICAgICAgICAgICBpZiAoaW5jbHVkZUltYWdlICYmIGltYWdlKSB7XHJcbiAgICAgICAgICAgICAgICBkb2MuY29udGVudC5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICBpbWFnZTogaW1hZ2UsXHJcbiAgICAgICAgICAgICAgICAgICAgYWxpZ25tZW50OiBvcHRpb25zLmFsaWduIHx8IFwibGVmdFwiLFxyXG4gICAgICAgICAgICAgICAgICAgIGZpdDogdGhpcy5nZXRQYWdlU2l6ZUZpdChkb2MucGFnZVNpemUsIGRvYy5wYWdlTWFyZ2lucywgZXh0cmFNYXJnaW4sIG9yaWVudGF0aW9uKVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gQWRkIGRhdGFcclxuICAgICAgICAgICAgaWYgKChpbmNsdWRlRGF0YSB8fCBvcHRpb25zLmluY2x1ZGVEYXRhKSAmJiB0aGlzLmhhc0RhdGEoKSkge1xyXG4gICAgICAgICAgICAgICAgZG9jLmNvbnRlbnQucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgdGFibGU6IHlpZWxkIHRoaXMuZ2V0UERGRGF0YShkYXRhT3B0aW9ucyksXHJcbiAgICAgICAgICAgICAgICAgICAgZm9udFNpemU6IG9wdGlvbnMuZm9udFNpemUgfHwgMTRcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGxldCBmb250cyA9IG51bGw7XHJcbiAgICAgICAgICAgIGxldCB2ZnMgPSBudWxsO1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBhZGRGb250KGZvbnQpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHBhdGhzID0ge307XHJcbiAgICAgICAgICAgICAgICBwYXRocy5ub3JtYWwgPSBmb250Lm5vcm1hbC5wYXRoO1xyXG4gICAgICAgICAgICAgICAgdmZzW2ZvbnQubm9ybWFsLnBhdGhdID0gZm9udC5ub3JtYWwuYnl0ZXM7XHJcbiAgICAgICAgICAgICAgICBpZiAoZm9udC5ib2xkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcGF0aHMuYm9sZCA9IGZvbnQuYm9sZC5wYXRoO1xyXG4gICAgICAgICAgICAgICAgICAgIHZmc1tmb250LmJvbGQucGF0aF0gPSBmb250LmJvbGQuYnl0ZXM7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBwYXRocy5ib2xkID0gZm9udC5ub3JtYWwucGF0aDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChmb250Lml0YWxpY3MpIHtcclxuICAgICAgICAgICAgICAgICAgICBwYXRocy5pdGFsaWNzID0gZm9udC5pdGFsaWNzLnBhdGg7XHJcbiAgICAgICAgICAgICAgICAgICAgdmZzW2ZvbnQuaXRhbGljcy5wYXRoXSA9IGZvbnQuaXRhbGljcy5ieXRlcztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHBhdGhzLml0YWxpY3MgPSBmb250Lm5vcm1hbC5wYXRoO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGZvbnQuYm9sZGl0YWxpY3MpIHtcclxuICAgICAgICAgICAgICAgICAgICBwYXRocy5ib2xkaXRhbGljcyA9IGZvbnQuYm9sZGl0YWxpY3MucGF0aDtcclxuICAgICAgICAgICAgICAgICAgICB2ZnNbZm9udC5ib2xkaXRhbGljcy5wYXRoXSA9IGZvbnQuYm9sZGl0YWxpY3MuYnl0ZXM7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBwYXRocy5ib2xkaXRhbGljcyA9IGZvbnQubm9ybWFsLnBhdGg7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBmb250c1tmb250Lm5hbWVdID0gcGF0aHM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuZm9udCkge1xyXG4gICAgICAgICAgICAgICAgZm9udHMgPSB7fTtcclxuICAgICAgICAgICAgICAgIHZmcyA9IHt9O1xyXG4gICAgICAgICAgICAgICAgYWRkRm9udChvcHRpb25zLmZvbnQpO1xyXG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuZXh0cmFGb250cykge1xyXG4gICAgICAgICAgICAgICAgICAgICRhcnJheS5lYWNoKG9wdGlvbnMuZXh0cmFGb250cywgYWRkRm9udCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5ldmVudHMuZGlzcGF0Y2goXCJwZGZkb2NyZWFkeVwiLCB7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiBcInBkZmRvY3JlYWR5XCIsXHJcbiAgICAgICAgICAgICAgICBmb3JtYXQ6IFwicGRmXCIsXHJcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBvcHRpb25zLFxyXG4gICAgICAgICAgICAgICAgZG9jOiBkb2MsXHJcbiAgICAgICAgICAgICAgICB0YXJnZXQ6IHRoaXNcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIC8vIENyZWF0ZSBQREZcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChzdWNjZXNzLCBfZXJyb3IpID0+IHtcclxuICAgICAgICAgICAgICAgIHBkZm1ha2UuY3JlYXRlUGRmKGRvYywgbnVsbCwgZm9udHMsIHZmcykuZ2V0QmFzZTY0KCh1cmkpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBzdWNjZXNzKHVyaSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEBpZ25vcmVcclxuICAgICAqL1xyXG4gICAgZ2V0UERGRGF0YShjdXN0b21PcHRpb25zKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMuX2dldEZvcm1hdE9wdGlvbnMoXCJwZGZkYXRhXCIsIGN1c3RvbU9wdGlvbnMpO1xyXG4gICAgICAgICAgICAvLyBJbml0IG91dHB1dFxyXG4gICAgICAgICAgICBsZXQgY29udGVudCA9IHtcclxuICAgICAgICAgICAgICAgIFwiYm9keVwiOiBbXVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvLyBHZXQgZGF0YVxyXG4gICAgICAgICAgICBjb25zdCBkYXRhID0gdGhpcy5nZXREYXRhKFwiaHRtbFwiLCBvcHRpb25zKTtcclxuICAgICAgICAgICAgY29uc3QgZGF0YUZpZWxkcyA9IHRoaXMuZ2V0RGF0YUZpZWxkcyhkYXRhKTtcclxuICAgICAgICAgICAgLy8gVmVydGljYWwgb3IgaG9yaXpvbnRhbCAoZGVmYXVsdCkgbGF5b3V0XHJcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnBpdm90KSB7XHJcbiAgICAgICAgICAgICAgICAvLyBEYXRhIGZpZWxkcyBvcmRlclxyXG4gICAgICAgICAgICAgICAgY29uc3QgZGF0YUZpZWxkc09yZGVyID0gdGhpcy5nZXQoXCJkYXRhRmllbGRzT3JkZXJcIiwgW10pO1xyXG4gICAgICAgICAgICAgICAgJG9iamVjdC5lYWNoT3JkZXJlZChkYXRhRmllbGRzLCAoa2V5LCB2YWwpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgZGF0YVJvdyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmFkZENvbHVtbk5hbWVzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFSb3cucHVzaCh2YWwpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBsZW4gPSBkYXRhLmxlbmd0aCwgaSA9IDA7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgZGF0YVZhbHVlID0gZGF0YVtpXVtrZXldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhUm93LnB1c2godGhpcy5jb252ZXJ0VG9TcGVjaWFsRm9ybWF0KGtleSwgZGF0YVZhbHVlLCBvcHRpb25zLCB0cnVlKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnQuYm9keS5wdXNoKHRoaXMuZ2V0UERGRGF0YVJvdyhkYXRhUm93LCBvcHRpb25zLCB1bmRlZmluZWQsIHRydWUpKTtcclxuICAgICAgICAgICAgICAgIH0sIChhLCBiKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGFpID0gZGF0YUZpZWxkc09yZGVyLmluZGV4T2YoYSk7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGJpID0gZGF0YUZpZWxkc09yZGVyLmluZGV4T2YoYik7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFpID4gYmkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGFpIDwgYmkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gQWRkIGNvbHVtbiBuYW1lcz9cclxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmFkZENvbHVtbk5hbWVzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGVudC5ib2R5LnB1c2godGhpcy5nZXRQREZEYXRhUm93KGRhdGFGaWVsZHMsIG9wdGlvbnMsIHVuZGVmaW5lZCwgdHJ1ZSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnQuaGVhZGVyUm93cyA9IDE7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBsZW4gPSBkYXRhLmxlbmd0aCwgaSA9IDA7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnQuYm9keS5wdXNoKHRoaXMuZ2V0UERGRGF0YVJvdyhkYXRhW2ldLCBvcHRpb25zLCBkYXRhRmllbGRzKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGNvbnRlbnQ7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEBpZ25vcmVcclxuICAgICAqL1xyXG4gICAgZ2V0UERGRGF0YVJvdyhyb3csIG9wdGlvbnMsIGRhdGFGaWVsZHMsIGFzSXMgPSBmYWxzZSkge1xyXG4gICAgICAgIC8vIEluaXRcclxuICAgICAgICBsZXQgaXRlbXMgPSBbXTtcclxuICAgICAgICAvLyBEYXRhIGZpZWxkc1xyXG4gICAgICAgIGlmICghZGF0YUZpZWxkcykge1xyXG4gICAgICAgICAgICBkYXRhRmllbGRzID0gcm93O1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBEYXRhIGZpZWxkcyBvcmRlclxyXG4gICAgICAgIGNvbnN0IGRhdGFGaWVsZHNPcmRlciA9IHRoaXMuZ2V0KFwiZGF0YUZpZWxkc09yZGVyXCIsIFtdKTtcclxuICAgICAgICAvLyBQcm9jZXNzIGVhY2ggcm93IGl0ZW1cclxuICAgICAgICAkb2JqZWN0LmVhY2hPcmRlcmVkKGRhdGFGaWVsZHMsIChrZXksIF9uYW1lKSA9PiB7XHJcbiAgICAgICAgICAgIC8vIEdldCB2YWx1ZVxyXG4gICAgICAgICAgICBsZXQgdmFsdWUgPSB0aGlzLmNvbnZlcnRFbXB0eVZhbHVlKGtleSwgcm93W2tleV0sIG9wdGlvbnMpO1xyXG4gICAgICAgICAgICAvLyBDb252ZXJ0IGRhdGVzXHJcbiAgICAgICAgICAgIGxldCBpdGVtID0gYXNJcyA/IHZhbHVlIDogdGhpcy5jb252ZXJ0VG9TcGVjaWFsRm9ybWF0KGtleSwgdmFsdWUsIG9wdGlvbnMpO1xyXG4gICAgICAgICAgICBpdGVtID0gXCJcIiArIGl0ZW07XHJcbiAgICAgICAgICAgIC8vIEFkZCB0byBpdGVtXHJcbiAgICAgICAgICAgIGl0ZW1zLnB1c2goaXRlbSk7XHJcbiAgICAgICAgfSwgKGEsIGIpID0+IHtcclxuICAgICAgICAgICAgbGV0IGFpID0gZGF0YUZpZWxkc09yZGVyLmluZGV4T2YoYSk7XHJcbiAgICAgICAgICAgIGxldCBiaSA9IGRhdGFGaWVsZHNPcmRlci5pbmRleE9mKGIpO1xyXG4gICAgICAgICAgICBpZiAoYWkgPiBiaSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoYWkgPCBiaSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBpdGVtcztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBwZGZtYWtlIGluc3RhbmNlLlxyXG4gICAgICpcclxuICAgICAqIEBpZ25vcmVcclxuICAgICAqIEByZXR1cm4gSW5zdGFuY2Ugb2YgcGRmbWFrZVxyXG4gICAgICovXHJcbiAgICBnZXRQZGZtYWtlKCkge1xyXG4gICAgICAgIGlmIChwZGZtYWtlUHJvbWlzZSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHBkZm1ha2VQcm9taXNlID0gX3BkZm1ha2UoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHBkZm1ha2VQcm9taXNlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAaWdub3JlXHJcbiAgICAgKi9cclxuICAgIGdldFBhZ2VTaXplRml0KHBhZ2VTaXplLCBtYXJnaW5zLCBleHRyYU1hcmdpbiA9IDAsIG9yaWVudGF0aW9uID0gXCJwb3J0cmFpdFwiKSB7XHJcbiAgICAgICAgLy8gQ2hlY2sgbWFyZ2luc1xyXG4gICAgICAgIGxldCBuZXdNYXJnaW5zID0gWzAsIDAsIDAsIDBdO1xyXG4gICAgICAgIGlmICgkdHlwZS5pc051bWJlcihtYXJnaW5zKSkge1xyXG4gICAgICAgICAgICBuZXdNYXJnaW5zID0gW21hcmdpbnMsIG1hcmdpbnMsIG1hcmdpbnMsIG1hcmdpbnNdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChtYXJnaW5zLmxlbmd0aCA9PSAyKSB7XHJcbiAgICAgICAgICAgIG5ld01hcmdpbnMgPSBbbWFyZ2luc1swXSwgbWFyZ2luc1sxXSwgbWFyZ2luc1swXSwgbWFyZ2luc1sxXV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKG1hcmdpbnMubGVuZ3RoID09IDQpIHtcclxuICAgICAgICAgICAgbmV3TWFyZ2lucyA9IG1hcmdpbnM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIERlZmluZSBhdmFpbGFibGUgcGFnZSBzaXplc1xyXG4gICAgICAgIGxldCBzaXplcyA9IHtcclxuICAgICAgICAgICAgXCI0QTBcIjogWzQ3NjcuODcsIDY3NDAuNzldLFxyXG4gICAgICAgICAgICBcIjJBMFwiOiBbMzM3MC4zOSwgNDc2Ny44N10sXHJcbiAgICAgICAgICAgIEEwOiBbMjM4My45NCwgMzM3MC4zOV0sXHJcbiAgICAgICAgICAgIEExOiBbMTY4My43OCwgMjM4My45NF0sXHJcbiAgICAgICAgICAgIEEyOiBbMTE5MC41NSwgMTY4My43OF0sXHJcbiAgICAgICAgICAgIEEzOiBbODQxLjg5LCAxMTkwLjU1XSxcclxuICAgICAgICAgICAgQTQ6IFs1OTUuMjgsIDg0MS44OV0sXHJcbiAgICAgICAgICAgIEE1OiBbNDE5LjUzLCA1OTUuMjhdLFxyXG4gICAgICAgICAgICBBNjogWzI5Ny42NCwgNDE5LjUzXSxcclxuICAgICAgICAgICAgQTc6IFsyMDkuNzYsIDI5Ny42NF0sXHJcbiAgICAgICAgICAgIEE4OiBbMTQ3LjQwLCAyMDkuNzZdLFxyXG4gICAgICAgICAgICBBOTogWzEwNC44OCwgMTQ3LjQwXSxcclxuICAgICAgICAgICAgQTEwOiBbNzMuNzAsIDEwNC44OF0sXHJcbiAgICAgICAgICAgIEIwOiBbMjgzNC42NSwgNDAwOC4xOV0sXHJcbiAgICAgICAgICAgIEIxOiBbMjAwNC4wOSwgMjgzNC42NV0sXHJcbiAgICAgICAgICAgIEIyOiBbMTQxNy4zMiwgMjAwNC4wOV0sXHJcbiAgICAgICAgICAgIEIzOiBbMTAwMC42MywgMTQxNy4zMl0sXHJcbiAgICAgICAgICAgIEI0OiBbNzA4LjY2LCAxMDAwLjYzXSxcclxuICAgICAgICAgICAgQjU6IFs0OTguOTAsIDcwOC42Nl0sXHJcbiAgICAgICAgICAgIEI2OiBbMzU0LjMzLCA0OTguOTBdLFxyXG4gICAgICAgICAgICBCNzogWzI0OS40NSwgMzU0LjMzXSxcclxuICAgICAgICAgICAgQjg6IFsxNzUuNzUsIDI0OS40NV0sXHJcbiAgICAgICAgICAgIEI5OiBbMTI0LjcyLCAxNzUuNzVdLFxyXG4gICAgICAgICAgICBCMTA6IFs4Ny44NywgMTI0LjcyXSxcclxuICAgICAgICAgICAgQzA6IFsyNTk5LjM3LCAzNjc2LjU0XSxcclxuICAgICAgICAgICAgQzE6IFsxODM2Ljg1LCAyNTk5LjM3XSxcclxuICAgICAgICAgICAgQzI6IFsxMjk4LjI3LCAxODM2Ljg1XSxcclxuICAgICAgICAgICAgQzM6IFs5MTguNDMsIDEyOTguMjddLFxyXG4gICAgICAgICAgICBDNDogWzY0OS4xMywgOTE4LjQzXSxcclxuICAgICAgICAgICAgQzU6IFs0NTkuMjEsIDY0OS4xM10sXHJcbiAgICAgICAgICAgIEM2OiBbMzIzLjE1LCA0NTkuMjFdLFxyXG4gICAgICAgICAgICBDNzogWzIyOS42MSwgMzIzLjE1XSxcclxuICAgICAgICAgICAgQzg6IFsxNjEuNTcsIDIyOS42MV0sXHJcbiAgICAgICAgICAgIEM5OiBbMTEzLjM5LCAxNjEuNTddLFxyXG4gICAgICAgICAgICBDMTA6IFs3OS4zNywgMTEzLjM5XSxcclxuICAgICAgICAgICAgUkEwOiBbMjQzNy44MCwgMzQ1OC4yN10sXHJcbiAgICAgICAgICAgIFJBMTogWzE3MjkuMTMsIDI0MzcuODBdLFxyXG4gICAgICAgICAgICBSQTI6IFsxMjE4LjkwLCAxNzI5LjEzXSxcclxuICAgICAgICAgICAgUkEzOiBbODY0LjU3LCAxMjE4LjkwXSxcclxuICAgICAgICAgICAgUkE0OiBbNjA5LjQ1LCA4NjQuNTddLFxyXG4gICAgICAgICAgICBTUkEwOiBbMjU1MS4xOCwgMzYyOC4zNV0sXHJcbiAgICAgICAgICAgIFNSQTE6IFsxODE0LjE3LCAyNTUxLjE4XSxcclxuICAgICAgICAgICAgU1JBMjogWzEyNzUuNTksIDE4MTQuMTddLFxyXG4gICAgICAgICAgICBTUkEzOiBbOTA3LjA5LCAxMjc1LjU5XSxcclxuICAgICAgICAgICAgU1JBNDogWzYzNy44MCwgOTA3LjA5XSxcclxuICAgICAgICAgICAgRVhFQ1VUSVZFOiBbNTIxLjg2LCA3NTYuMDBdLFxyXG4gICAgICAgICAgICBGT0xJTzogWzYxMi4wMCwgOTM2LjAwXSxcclxuICAgICAgICAgICAgTEVHQUw6IFs2MTIuMDAsIDEwMDguMDBdLFxyXG4gICAgICAgICAgICBMRVRURVI6IFs2MTIuMDAsIDc5Mi4wMF0sXHJcbiAgICAgICAgICAgIFRBQkxPSUQ6IFs3OTIuMDAsIDEyMjQuMDBdXHJcbiAgICAgICAgfTtcclxuICAgICAgICAvLyBDYWxjdWxhdGUgc2l6ZVxyXG4gICAgICAgIGxldCBmaXRTaXplID0gc2l6ZXNbcGFnZVNpemVdO1xyXG4gICAgICAgIGlmIChvcmllbnRhdGlvbiA9PSBcImxhbmRzY2FwZVwiKSB7XHJcbiAgICAgICAgICAgIGZpdFNpemUucmV2ZXJzZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmaXRTaXplWzBdIC09IG5ld01hcmdpbnNbMF0gKyBuZXdNYXJnaW5zWzJdO1xyXG4gICAgICAgIGZpdFNpemVbMV0gLT0gbmV3TWFyZ2luc1sxXSArIG5ld01hcmdpbnNbM10gKyBleHRyYU1hcmdpbjtcclxuICAgICAgICByZXR1cm4gZml0U2l6ZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICAgICAqIERhdGFcclxuICAgICAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAgICAgKi9cclxuICAgIC8qKlxyXG4gICAgICAgICogUmV0dXJucyBgdHJ1ZWAgaWYgYGRhdGFTb3VyY2VgIGlzIHNldCwgYW5kIHRoZSBjb250ZW50cyBhcmUgcHJvcGVyXHJcbiAgICAgICAgKiBkYXRhIChhcnJheSkuXHJcbiAgICAgICAgKlxyXG4gICAgICAgICogQHJldHVybiBIYXMgZGF0YT9cclxuICAgICAgICAqL1xyXG4gICAgaGFzRGF0YSgpIHtcclxuICAgICAgICBjb25zdCBkYXRhU291cmNlID0gdGhpcy5nZXQoXCJkYXRhU291cmNlXCIpO1xyXG4gICAgICAgIHJldHVybiAkdHlwZS5pc0FycmF5KGRhdGFTb3VyY2UpICYmIGRhdGFTb3VyY2UubGVuZ3RoID8gdHJ1ZSA6IGZhbHNlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHByb2Nlc3NlZCBkYXRhIGFjY29yZGluZyB0byBmb3JtYXQgb3B0aW9ucy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gICBmb3JtYXQgICAgICAgICBGb3JtYXRcclxuICAgICAqIEBwYXJhbSAgIGN1c3RvbU9wdGlvbnMgIEZvcm1hdCBvcHRpb25zXHJcbiAgICAgKiBAcGFyYW0gICByZW5hbWVGaWVsZHMgICBTaG91bGQgZmllbGRzIGJlIHJlbmFtZWQ/XHJcbiAgICAgKiBAcmV0dXJuICAgICAgICAgICAgICAgICBQcm9jZXNzZWQgZGF0YVxyXG4gICAgICovXHJcbiAgICBnZXREYXRhKGZvcm1hdCwgY3VzdG9tT3B0aW9ucywgcmVuYW1lRmllbGRzID0gZmFsc2UpIHtcclxuICAgICAgICBjb25zdCBvcHRpb25zID0gdGhpcy5fZ2V0Rm9ybWF0T3B0aW9ucyhmb3JtYXQsIGN1c3RvbU9wdGlvbnMpO1xyXG4gICAgICAgIGNvbnN0IGRhdGFTb3VyY2UgPSB0aGlzLmdldChcImRhdGFTb3VyY2VcIiwgW10pO1xyXG4gICAgICAgIGxldCBkYXRhID0gZGF0YVNvdXJjZTtcclxuICAgICAgICAvLyBSZS1nZW5lcmF0ZSB0aGUgZGF0YSBiYXNlZCBvbiBkYXRhIGZpZWxkcyBpZiBzZXRcclxuICAgICAgICBjb25zdCBkYXRhRmllbGRzID0gdGhpcy5nZXQoXCJkYXRhRmllbGRzXCIpO1xyXG4gICAgICAgIGlmIChkYXRhRmllbGRzICYmICR0eXBlLmlzQXJyYXkoZGF0YVNvdXJjZSkpIHtcclxuICAgICAgICAgICAgZGF0YSA9IFtdO1xyXG4gICAgICAgICAgICAkYXJyYXkuZWFjaChkYXRhU291cmNlLCAocm93KSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoJHR5cGUuaXNPYmplY3Qocm93KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld1JvdyA9IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgICRvYmplY3QuZWFjaChkYXRhRmllbGRzLCAoZmllbGQsIHZhbHVlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkYXRhRmllbGRzW2ZpZWxkXSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdSb3dbcmVuYW1lRmllbGRzID8gdmFsdWUgOiBmaWVsZF0gPSB0aGlzLmNvbnZlcnRUb1NwZWNpYWxGb3JtYXQoZmllbGQsIHJvd1tmaWVsZF0sIG9wdGlvbnMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5wdXNoKG5ld1Jvdyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBldmVudCA9IHtcclxuICAgICAgICAgICAgdHlwZTogXCJkYXRhcHJvY2Vzc2VkXCIsXHJcbiAgICAgICAgICAgIGZvcm1hdDogZm9ybWF0LFxyXG4gICAgICAgICAgICBvcHRpb25zOiBvcHRpb25zLFxyXG4gICAgICAgICAgICBkYXRhOiBkYXRhLFxyXG4gICAgICAgICAgICB0YXJnZXQ6IHRoaXNcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMuZXZlbnRzLmRpc3BhdGNoKFwiZGF0YXByb2Nlc3NlZFwiLCBldmVudCk7XHJcbiAgICAgICAgcmV0dXJuIGV2ZW50LmRhdGE7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEBpZ25vcmVcclxuICAgICAqL1xyXG4gICAgZ2V0RGF0YUZpZWxkcyhkYXRhKSB7XHJcbiAgICAgICAgbGV0IGRhdGFGaWVsZHMgPSB0aGlzLmdldChcImRhdGFGaWVsZHNcIik7XHJcbiAgICAgICAgaWYgKCFkYXRhRmllbGRzKSB7XHJcbiAgICAgICAgICAgIGRhdGFGaWVsZHMgPSB7fTtcclxuICAgICAgICAgICAgaWYgKCR0eXBlLmlzQXJyYXkoZGF0YSkgJiYgZGF0YS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICRhcnJheS5lYWNoKGRhdGEsIChyb3cpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAkb2JqZWN0LmVhY2gocm93LCAoa2V5LCBfdmFsdWUpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGFGaWVsZHNba2V5XSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhRmllbGRzW2tleV0gPSBrZXk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBkYXRhRmllbGRzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAaWdub3JlXHJcbiAgICAgKi9cclxuICAgIGNvbnZlcnRFbXB0eVZhbHVlKF9maWVsZCwgdmFsdWUsIG9wdGlvbnMpIHtcclxuICAgICAgICByZXR1cm4gdmFsdWUgIT0gbnVsbCA/IHZhbHVlIDogb3B0aW9ucy5lbXB0eUFzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAaWdub3JlXHJcbiAgICAgKi9cclxuICAgIGNvbnZlcnRUb1NwZWNpYWxGb3JtYXQoZmllbGQsIHZhbHVlLCBvcHRpb25zLCBrZWVwT3JpZ2luYWwpIHtcclxuICAgICAgICAvLyBJcyB0aGlzIGEgdGltZXN0YW1wIG9yIGR1cmF0aW9uP1xyXG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gXCJudW1iZXJcIikge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5pc0RhdGVGaWVsZChmaWVsZCkpIHtcclxuICAgICAgICAgICAgICAgIHZhbHVlID0gbmV3IERhdGUodmFsdWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuaXNOdW1lcmljRmllbGQoZmllbGQpICYmIHRoaXMuZ2V0KFwibnVtYmVyRm9ybWF0XCIpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcm9vdC5udW1iZXJGb3JtYXR0ZXIuZm9ybWF0KHZhbHVlLCB0aGlzLmdldChcIm51bWJlckZvcm1hdFwiKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5pc0R1cmF0aW9uRmllbGQoZmllbGQpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcm9vdC5kdXJhdGlvbkZvcm1hdHRlci5mb3JtYXQodmFsdWUsIHRoaXMuZ2V0KFwiZHVyYXRpb25Gb3JtYXRcIiksIHRoaXMuZ2V0KFwiZHVyYXRpb25Vbml0XCIpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBEYXRlKSB7XHJcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnVzZVRpbWVzdGFtcHMpIHtcclxuICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUuZ2V0VGltZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKG9wdGlvbnMudXNlTG9jYWxlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWtlZXBPcmlnaW5hbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUudG9Mb2NhbGVTdHJpbmcoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHZhbHVlID0gdGhpcy5fcm9vdC5kYXRlRm9ybWF0dGVyLmZvcm1hdCh2YWx1ZSwgdGhpcy5nZXQoXCJkYXRlRm9ybWF0XCIpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEBpZ25vcmVcclxuICAgICAqL1xyXG4gICAgaXNEYXRlRmllbGQoZmllbGQpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5nZXQoXCJkYXRlRmllbGRzXCIpLmluZGV4T2YoZmllbGQpICE9PSAtMTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQGlnbm9yZVxyXG4gICAgICovXHJcbiAgICBpc051bWVyaWNGaWVsZChmaWVsZCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmdldChcIm51bWVyaWNGaWVsZHNcIikuaW5kZXhPZihmaWVsZCkgIT09IC0xO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAaWdub3JlXHJcbiAgICAgKi9cclxuICAgIGlzRHVyYXRpb25GaWVsZChmaWVsZCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmdldChcImR1cmF0aW9uRmllbGRzXCIpLmluZGV4T2YoZmllbGQpICE9PSAtMTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQGlnbm9yZVxyXG4gICAgICovXHJcbiAgICBnZXRDb250ZW50VHlwZSh0eXBlKSB7XHJcbiAgICAgICAgbGV0IGNvbnRlbnRUeXBlID0gXCJcIjtcclxuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcclxuICAgICAgICAgICAgY2FzZSBcInBuZ1wiOlxyXG4gICAgICAgICAgICAgICAgY29udGVudFR5cGUgPSBcImltYWdlL1wiICsgdHlwZTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFwianBnXCI6XHJcbiAgICAgICAgICAgICAgICBjb250ZW50VHlwZSA9IFwiaW1hZ2UvanBlZ1wiO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgXCJjc3ZcIjpcclxuICAgICAgICAgICAgICAgIGNvbnRlbnRUeXBlID0gXCJ0ZXh0L2NzdlwiO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgXCJqc29uXCI6XHJcbiAgICAgICAgICAgICAgICBjb250ZW50VHlwZSA9IFwiYXBwbGljYXRpb24vanNvblwiO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgXCJodG1sXCI6XHJcbiAgICAgICAgICAgICAgICBjb250ZW50VHlwZSA9IFwidGV4dC9odG1sXCI7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBcInBkZlwiOlxyXG4gICAgICAgICAgICBjYXNlIFwicGRmZGF0YVwiOlxyXG4gICAgICAgICAgICAgICAgY29udGVudFR5cGUgPSBcImFwcGxpY2F0aW9uL3BkZlwiO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgXCJ4bHN4XCI6XHJcbiAgICAgICAgICAgICAgICBjb250ZW50VHlwZSA9IFwiYXBwbGljYXRpb24vdm5kLm9wZW54bWxmb3JtYXRzLW9mZmljZWRvY3VtZW50LnNwcmVhZHNoZWV0bWwuc2hlZXRcIjtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgY29udGVudFR5cGUgPSBcImFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbVwiO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gY29udGVudFR5cGU7XHJcbiAgICB9XHJcbiAgICBnZXREaXNwb3NhYmxlQ2FudmFzKCkge1xyXG4gICAgICAgIGxldCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xyXG4gICAgICAgIGNhbnZhcy5zdHlsZS5wb3NpdGlvbiA9IFwiZml4ZWRcIjtcclxuICAgICAgICBjYW52YXMuc3R5bGUudG9wID0gXCItMTAwMDBweFwiO1xyXG4gICAgICAgIHRoaXMuX3Jvb3QuZG9tLmFwcGVuZENoaWxkKGNhbnZhcyk7XHJcbiAgICAgICAgcmV0dXJuIGNhbnZhcztcclxuICAgIH1cclxuICAgIGRpc3Bvc2VDYW52YXMoY2FudmFzKSB7XHJcbiAgICAgICAgdGhpcy5fcm9vdC5kb20ucmVtb3ZlQ2hpbGQoY2FudmFzKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQGlnbm9yZVxyXG4gICAgICovXHJcbiAgICBmaW5kQmFja2dyb3VuZENvbG9yKGVsZW1lbnQpIHtcclxuICAgICAgICAvLyBDaGVjayBpZiBlbGVtZW50IGhhcyBzdHlsZXMgc2V0XHJcbiAgICAgICAgbGV0IG9wYWNpdHkgPSAxO1xyXG4gICAgICAgIGxldCBjdXJyZW50Q29sb3IgPSBnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQsIFwiYmFja2dyb3VuZC1jb2xvclwiKS5nZXRQcm9wZXJ0eVZhbHVlKFwiYmFja2dyb3VuZC1jb2xvclwiKTtcclxuICAgICAgICAvLyBDaGVjayBvcGFjaXR5XHJcbiAgICAgICAgaWYgKGN1cnJlbnRDb2xvci5tYXRjaCgvW14sXSosW14sXSosW14sXSosWyBdPzAvKSB8fCBjdXJyZW50Q29sb3IgPT0gXCJ0cmFuc3BhcmVudFwiKSB7XHJcbiAgICAgICAgICAgIG9wYWNpdHkgPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAob3BhY2l0eSA9PSAwKSB7XHJcbiAgICAgICAgICAgIGxldCBwYXJlbnQgPSBlbGVtZW50LnBhcmVudEVsZW1lbnQ7IC8vIHx8IDxFbGVtZW50PmVsZW1lbnQucGFyZW50Tm9kZTtcclxuICAgICAgICAgICAgLy8gQ29tcGxldGVseSB0cmFuc3BhcmVudC4gTG9vayBmb3IgYSBwYXJlbnRcclxuICAgICAgICAgICAgaWYgKHBhcmVudCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmluZEJhY2tncm91bmRDb2xvcihwYXJlbnQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIENvbG9yLmZyb21IZXgoMHhmZmZmZmYpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gQ29sb3IuZnJvbUNTUyhjdXJyZW50Q29sb3IpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVHJpZ2dlcnMgZG93bmxvYWQgb2YgdGhlIGZpbGUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtICAgdXJpICAgICAgIGRhdGE6dXJpIHdpdGggZmlsZSBjb250ZW50XHJcbiAgICAgKiBAcGFyYW0gICBmaWxlTmFtZSAgRmlsZSBuYW1lXHJcbiAgICAgKiBAcGFyYW0gICBhZGRCT00gICAgU2hvdWxkIGRvd25sb2FkIGluY2x1ZGUgYnl0ZSBvcmRlciBtYXJrP1xyXG4gICAgICogQHJldHVybiAgICAgICAgICAgIFByb21pc2VcclxuICAgICAqL1xyXG4gICAgc3RyZWFtRmlsZSh1cmksIGZpbGVOYW1lLCBhZGRCT00gPSBmYWxzZSkge1xyXG4gICAgICAgIGlmICh0aGlzLmJsb2JEb3dubG9hZFN1cHBvcnQoKSkge1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogU3VwcG9ydHMgQmxvYiBvYmplY3QuXHJcbiAgICAgICAgICAgICAqIFVzZSBpdC5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIGxldCBsaW5rID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImFcIik7XHJcbiAgICAgICAgICAgIGxpbmsuZG93bmxvYWQgPSBmaWxlTmFtZTtcclxuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChsaW5rKTtcclxuICAgICAgICAgICAgLy8gRXh0cmFjdCBjb250ZW50IHR5cGUgYW5kIGdldCBwdXJlIGRhdGEgd2l0aG91dCBoZWFkZXJzXHJcbiAgICAgICAgICAgIGxldCBwYXJ0cyA9IHVyaS5zcGxpdChcIjtcIik7XHJcbiAgICAgICAgICAgIGxldCBjb250ZW50VHlwZSA9IHBhcnRzLnNoaWZ0KCkucmVwbGFjZSgvZGF0YTovLCBcIlwiKTtcclxuICAgICAgICAgICAgdXJpID0gZGVjb2RlVVJJQ29tcG9uZW50KHBhcnRzLmpvaW4oXCI7XCIpLnJlcGxhY2UoL15bXixdKiwvLCBcIlwiKSk7XHJcbiAgICAgICAgICAgIGlmIChbXCJpbWFnZS9zdmcreG1sXCIsIFwiYXBwbGljYXRpb24vanNvblwiLCBcInRleHQvY3N2XCIsIFwidGV4dC9odG1sXCJdLmluZGV4T2YoY29udGVudFR5cGUpID09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBkZWNvZGVkID0gYXRvYih1cmkpO1xyXG4gICAgICAgICAgICAgICAgICAgIHVyaSA9IGRlY29kZWQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIEVycm9yIG9jY3VycmVkLCBtZWFuaW5nIHN0cmluZyB3YXMgbm90IEJhc2U2NC1lbmNvZGVkLiBEbyBub3RoaW5nLlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlmIChhZGRCT00pIHtcclxuICAgICAgICAgICAgICAgICAgICB1cmkgPSBcIlxcdWZlZmZcIiArIHVyaTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGxldCBibG9iID0gbmV3IEJsb2IoW3VyaV0sIHsgdHlwZTogY29udGVudFR5cGUgfSk7XHJcbiAgICAgICAgICAgICAgICBsZXQgdXJsID0gd2luZG93LlVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XHJcbiAgICAgICAgICAgICAgICBsaW5rLmhyZWYgPSB1cmw7XHJcbiAgICAgICAgICAgICAgICBsaW5rLmRvd25sb2FkID0gZmlsZU5hbWU7XHJcbiAgICAgICAgICAgICAgICBsaW5rLmNsaWNrKCk7XHJcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGxpbmspO1xyXG4gICAgICAgICAgICAgICAgICAgIHdpbmRvdy5VUkwucmV2b2tlT2JqZWN0VVJMKHVybCk7XHJcbiAgICAgICAgICAgICAgICB9LCAxMDApO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gRGlzc2VjdCB1cmkgaW50byBhcnJheVxyXG4gICAgICAgICAgICBsZXQgY2hhcnMgPSBuZXcgQXJyYXkodXJpLmxlbmd0aCk7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdXJpLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgY2hhckNvZGUgPSB1cmkuY2hhckNvZGVBdChpKTtcclxuICAgICAgICAgICAgICAgIGNoYXJzW2ldID0gY2hhckNvZGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGFkZEJPTSkge1xyXG4gICAgICAgICAgICAgICAgY2hhcnMgPSBbMHhFRiwgMHhCQiwgMHhCRl0uY29uY2F0KGNoYXJzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsZXQgYmxvYiA9IG5ldyBCbG9iKFtuZXcgVWludDhBcnJheShjaGFycyldLCB7IHR5cGU6IGNvbnRlbnRUeXBlIH0pO1xyXG4gICAgICAgICAgICBsZXQgdXJsID0gd2luZG93LlVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XHJcbiAgICAgICAgICAgIGxpbmsuaHJlZiA9IHVybDtcclxuICAgICAgICAgICAgbGluay5kb3dubG9hZCA9IGZpbGVOYW1lO1xyXG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGxpbmspO1xyXG4gICAgICAgICAgICBsaW5rLmNsaWNrKCk7XHJcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQobGluayk7XHJcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgd2luZG93LlVSTC5yZXZva2VPYmplY3RVUkwodXJsKTtcclxuICAgICAgICAgICAgfSwgMTAwKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodGhpcy5saW5rRG93bmxvYWRTdXBwb3J0KCkpIHtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEZvciByZWd1bGFyIGJyb3dzZXJzLCB3ZSBjcmVhdGUgYSBsaW5rIHRoZW4gc2ltdWxhdGUgYSBjbGljayBvbiBpdFxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgbGV0IGxpbmsgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYVwiKTtcclxuICAgICAgICAgICAgbGluay5kb3dubG9hZCA9IGZpbGVOYW1lO1xyXG4gICAgICAgICAgICBsaW5rLmhyZWYgPSB1cmk7XHJcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQobGluayk7XHJcbiAgICAgICAgICAgIGxpbmsuY2xpY2soKTtcclxuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChsaW5rKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBTb21ldGhpbmcgZWxzZSAtIHBlcmhhcHMgYSBtb2JpbGUuXHJcbiAgICAgICAgICAgICAqIExldCdzIGp1c3QgZGlzcGxheSBpdCBpbiB0aGUgc2FtZSBwYWdlLlxyXG4gICAgICAgICAgICAgKiAoaGV5IHdlIGRvbid0IGxpa2UgaXQgZWl0aGVyKVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgd2luZG93LmxvY2F0aW9uLmhyZWYgPSB1cmk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAaWdub3JlXHJcbiAgICAgKi9cclxuICAgIGRvd25sb2FkU3VwcG9ydCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5saW5rRG93bmxvYWRTdXBwb3J0KCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEBpZ25vcmVcclxuICAgICAqL1xyXG4gICAgbGlua0Rvd25sb2FkU3VwcG9ydCgpIHtcclxuICAgICAgICBsZXQgYSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJhXCIpO1xyXG4gICAgICAgIGxldCByZXMgPSB0eXBlb2YgYS5kb3dubG9hZCAhPT0gXCJ1bmRlZmluZWRcIjtcclxuICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAaWdub3JlXHJcbiAgICAgKi9cclxuICAgIGJsb2JEb3dubG9hZFN1cHBvcnQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHdpbmRvdy5CbG9iICE9IG51bGw7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAgICAgKiBQcmludFxyXG4gICAgICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICAgICAqL1xyXG4gICAgLyoqXHJcbiAgICAgKiBJbml0aWF0ZXMgcHJpbnQgb2YgdGhlIGNoYXJ0LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSAgIGRhdGEgICAgIGRhdGE6dXJpIGZvciB0aGUgaW1hZ2VcclxuICAgICAqIEBwYXJhbSAgIG9wdGlvbnMgIE9wdGlvbnNcclxuICAgICAqIEBwYXJhbSAgIHRpdGxlICAgIE9wdGlvbmFsIHRpdGxlIHRvIHVzZSAodXNlcyB3aW5kb3cncyB0aXRsZSBieSBkZWZhdWx0KVxyXG4gICAgICogQHJldHVybiAgICAgICAgICAgUHJvbWlzZVxyXG4gICAgICovXHJcbiAgICBpbml0aWF0ZVByaW50KGRhdGEsIGN1c3RvbU9wdGlvbnMsIHRpdGxlKSB7XHJcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMuX2dldEZvcm1hdE9wdGlvbnMoXCJwcmludFwiLCBjdXN0b21PcHRpb25zKTtcclxuICAgICAgICBpZiAob3B0aW9ucy5wcmludE1ldGhvZCA9PSBcImNzc1wiKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3ByaW50VmlhQ1NTKGRhdGEsIG9wdGlvbnMsIHRpdGxlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3ByaW50VmlhSWZyYW1lKGRhdGEsIG9wdGlvbnMsIHRpdGxlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBfcHJpbnRWaWFDU1MoZGF0YSwgY3VzdG9tT3B0aW9ucywgdGl0bGUpIHtcclxuICAgICAgICBjb25zdCBvcHRpb25zID0gdGhpcy5fZ2V0Rm9ybWF0T3B0aW9ucyhcInByaW50XCIsIGN1c3RvbU9wdGlvbnMpO1xyXG4gICAgICAgIGxldCBkZWxheSA9IG9wdGlvbnMuZGVsYXkgfHwgNTAwO1xyXG4gICAgICAgIC8vU2F2ZSBjdXJyZW50IHNjcm9sbCBwb3NpdGlvblxyXG4gICAgICAgIGxldCBzY3JvbGwgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsVG9wIHx8IGRvY3VtZW50LmJvZHkuc2Nyb2xsVG9wO1xyXG4gICAgICAgIC8vIEhpZGUgYWxsIGRvY3VtZW50IG5vZGVzIGJ5IGFwcGx5aW5nIGN1c3RvbSBDU1NcclxuICAgICAgICBsZXQgcnVsZSA9IG5ldyBTdHlsZVJ1bGUoJHV0aWxzLmdldFNoYWRvd1Jvb3QodGhpcy5fcm9vdC5kb20pLCBcImJvZHkgPiAqXCIsIHtcclxuICAgICAgICAgICAgXCJkaXNwbGF5XCI6IFwibm9uZVwiLFxyXG4gICAgICAgICAgICBcInBvc2l0aW9uXCI6IFwiZml4ZWRcIixcclxuICAgICAgICAgICAgXCJ2aXNpYmlsaXR5XCI6IFwiaGlkZGVuXCIsXHJcbiAgICAgICAgICAgIFwib3BhY2l0eVwiOiBcIjBcIixcclxuICAgICAgICAgICAgXCJjbGlwUGF0aFwiOiBcInBvbHlnb24oMHB4IDBweCwwcHggMHB4LDBweCAwcHgsMHB4IDBweCk7XCJcclxuICAgICAgICB9LCB0aGlzLl9yb290Lm5vbmNlKTtcclxuICAgICAgICBsZXQgcnVsZTIgPSBuZXcgU3R5bGVSdWxlKCR1dGlscy5nZXRTaGFkb3dSb290KHRoaXMuX3Jvb3QuZG9tKSwgXCJib2R5XCIsIHtcclxuICAgICAgICAgICAgXCJwYWRkaW5nXCI6IFwiMFwiLFxyXG4gICAgICAgICAgICBcIm1hcmdpblwiOiBcIjBcIlxyXG4gICAgICAgIH0sIHRoaXMuX3Jvb3Qubm9uY2UpO1xyXG4gICAgICAgIC8vIFJlcGxhY2UgdGl0bGU/XHJcbiAgICAgICAgbGV0IG9yaWdpbmFsVGl0bGU7XHJcbiAgICAgICAgaWYgKHRpdGxlICYmIGRvY3VtZW50ICYmIGRvY3VtZW50LnRpdGxlKSB7XHJcbiAgICAgICAgICAgIG9yaWdpbmFsVGl0bGUgPSBkb2N1bWVudC50aXRsZTtcclxuICAgICAgICAgICAgZG9jdW1lbnQudGl0bGUgPSB0aXRsZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gQ3JlYXRlIGFuZCBhZGQgZXhwb3J0ZWQgaW1hZ2VcclxuICAgICAgICBsZXQgaW1nID0gbmV3IEltYWdlKCk7XHJcbiAgICAgICAgaW1nLnNyYyA9IGRhdGE7XHJcbiAgICAgICAgaW1nLnN0eWxlLm1heFdpZHRoID0gXCIxMDAlXCI7XHJcbiAgICAgICAgaW1nLnN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCI7XHJcbiAgICAgICAgaW1nLnN0eWxlLnBvc2l0aW9uID0gXCJyZWxhdGl2ZVwiO1xyXG4gICAgICAgIGltZy5zdHlsZS52aXNpYmlsaXR5ID0gXCJ2aXNpYmxlXCI7XHJcbiAgICAgICAgaW1nLnN0eWxlLm9wYWNpdHkgPSBcIjFcIjtcclxuICAgICAgICBpbWcuc3R5bGUuY2xpcFBhdGggPSBcIm5vbmVcIjtcclxuICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGltZyk7XHJcbiAgICAgICAgLy8gUHJpbnRcclxuICAgICAgICB0aGlzLnNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICB3aW5kb3cucHJpbnQoKTtcclxuICAgICAgICB9LCA1MCk7XHJcbiAgICAgICAgLy8gRGVsYXkgbmVlZHMgdG8gYmUgYXQgbGVhc3QgYSBzZWNvbmQgZm9yIGlPUyBkZXZpY2VzXHJcbiAgICAgICAgbGV0IGlzSU9TID0gL2lQYWR8aVBob25lfGlQb2QvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkgJiYgIXdpbmRvdy5NU1N0cmVhbTtcclxuICAgICAgICBpZiAoaXNJT1MgJiYgKGRlbGF5IDwgMTAwMCkpIHtcclxuICAgICAgICAgICAgZGVsYXkgPSAxMDAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChkZWxheSA8IDEwMCkge1xyXG4gICAgICAgICAgICBkZWxheSA9IDEwMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gRGVsYXkgZnVuY3Rpb24gdGhhdCByZXNldHMgYmFjayB0aGUgZG9jdW1lbnQgdGhlIHdheSBvdCB3YXMgYmVmb3JlXHJcbiAgICAgICAgdGhpcy5zZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgICAgLy8gUmVtb3ZlIGltYWdlXHJcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoaW1nKTtcclxuICAgICAgICAgICAgLy8gUmVzZXQgYmFjayBhbGwgZWxlbWVudHNcclxuICAgICAgICAgICAgcnVsZS5kaXNwb3NlKCk7XHJcbiAgICAgICAgICAgIHJ1bGUyLmRpc3Bvc2UoKTtcclxuICAgICAgICAgICAgLy8gUmVzdG9yZSB0aXRsZVxyXG4gICAgICAgICAgICBpZiAob3JpZ2luYWxUaXRsZSkge1xyXG4gICAgICAgICAgICAgICAgZG9jdW1lbnQudGl0bGUgPSBkb2N1bWVudC50aXRsZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBTY3JvbGwgYmFjayB0aGUgZG9jdW1lbnQgdGhlIHdheSBpdCB3YXMgYmVmb3JlXHJcbiAgICAgICAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3AgPSBkb2N1bWVudC5ib2R5LnNjcm9sbFRvcCA9IHNjcm9sbDtcclxuICAgICAgICB9LCBkZWxheSB8fCA1MDApO1xyXG4gICAgfVxyXG4gICAgX3ByaW50VmlhSWZyYW1lKGRhdGEsIGN1c3RvbU9wdGlvbnMsIHRpdGxlKSB7XHJcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMuX2dldEZvcm1hdE9wdGlvbnMoXCJwcmludFwiLCBjdXN0b21PcHRpb25zKTtcclxuICAgICAgICBsZXQgZGVsYXkgPSBvcHRpb25zLmRlbGF5IHx8IDUwMDtcclxuICAgICAgICAvLyBDcmVhdGUgYW4gaWZyYW1lXHJcbiAgICAgICAgY29uc3QgaWZyYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlmcmFtZVwiKTtcclxuICAgICAgICBpZnJhbWUuc3R5bGUudmlzaWJpbGl0eSA9IFwiaGlkZGVuXCI7XHJcbiAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChpZnJhbWUpO1xyXG4gICAgICAgIC8vIFRoaXMgaXMgbmVlZGVkIGZvciBGaXJlRm94XHJcbiAgICAgICAgaWZyYW1lLmNvbnRlbnRXaW5kb3cuZG9jdW1lbnQub3BlbigpO1xyXG4gICAgICAgIGlmcmFtZS5jb250ZW50V2luZG93LmRvY3VtZW50LmNsb3NlKCk7XHJcbiAgICAgICAgLy8gQ3JlYXRlIGFuZCBhZGQgZXhwb3J0ZWQgaW1hZ2VcclxuICAgICAgICBsZXQgaW1nID0gbmV3IEltYWdlKCk7XHJcbiAgICAgICAgaW1nLnNyYyA9IGRhdGE7XHJcbiAgICAgICAgaW1nLnN0eWxlLm1heFdpZHRoID0gXCIxMDAlXCI7XHJcbiAgICAgICAgaW1nLnN0eWxlLmhlaWdodCA9IFwiYXV0b1wiO1xyXG4gICAgICAgIGlmICh0aXRsZSkge1xyXG4gICAgICAgICAgICBpZnJhbWUuY29udGVudFdpbmRvdy5kb2N1bWVudC50aXRsZSA9IHRpdGxlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZnJhbWUuY29udGVudFdpbmRvdy5kb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGltZyk7XHJcbiAgICAgICAgaWZyYW1lLmxvYWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmcmFtZS5jb250ZW50V2luZG93LmRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoaW1nKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8vIFByaW50XHJcbiAgICAgICAgdGhpcy5zZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGlmICghaWZyYW1lLmNvbnRlbnRXaW5kb3cuZG9jdW1lbnQuZXhlY0NvbW1hbmQoXCJwcmludFwiLCBmYWxzZSwgbnVsbCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZnJhbWUuY29udGVudFdpbmRvdy5wcmludCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICBpZnJhbWUuY29udGVudFdpbmRvdy5wcmludCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSwgZGVsYXkgfHwgNTApO1xyXG4gICAgICAgIC8vIERlbGF5IG5lZWRzIHRvIGJlIGF0IGxlYXN0IGEgc2Vjb25kIGZvciBpT1MgZGV2aWNlc1xyXG4gICAgICAgIGxldCBpc0lPUyA9IC9pUGFkfGlQaG9uZXxpUG9kLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpICYmICF3aW5kb3cuTVNTdHJlYW07XHJcbiAgICAgICAgaWYgKGlzSU9TICYmIChkZWxheSA8IDEwMDApKSB7XHJcbiAgICAgICAgICAgIGRlbGF5ID0gMTAwMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoZGVsYXkgPCAxMDApIHtcclxuICAgICAgICAgICAgZGVsYXkgPSAxMDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIERlbGF5IGZ1bmN0aW9uIHRoYXQgcmVzZXRzIGJhY2sgdGhlIGRvY3VtZW50IHRoZSB3YXkgb3Qgd2FzIGJlZm9yZVxyXG4gICAgICAgIHRoaXMuc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgIC8vIFJlbW92ZSBpbWFnZVxyXG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGlmcmFtZSk7XHJcbiAgICAgICAgfSwgZGVsYXkgKyA1MCB8fCAxMDApO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgbGlzdCBvZiBmb3JtYXRzIHRoYXQgY2FuIGJlIGV4cG9ydGVkIGluIGN1cnJlbnQgYnJvd3Nlci5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJuIEZvcm1hdHNcclxuICAgICAqL1xyXG4gICAgc3VwcG9ydGVkRm9ybWF0cygpIHtcclxuICAgICAgICBjb25zdCByZXMgPSBbXTtcclxuICAgICAgICBjb25zdCBoYXNEYXRhID0gdGhpcy5oYXNEYXRhKCk7XHJcbiAgICAgICAgY29uc3QgZG93bmxvYWRTdXBwb3J0ID0gdGhpcy5kb3dubG9hZFN1cHBvcnQoKTtcclxuICAgICAgICAkYXJyYXkuZWFjaChbXCJwbmdcIiwgXCJqcGdcIiwgXCJjYW52YXNcIiwgXCJwZGZcIiwgXCJ4bHN4XCIsIFwiY3N2XCIsIFwianNvblwiLCBcImh0bWxcIiwgXCJwZGZkYXRhXCIsIFwicHJpbnRcIl0sIChmb3JtYXQpID0+IHtcclxuICAgICAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMuX2dldEZvcm1hdE9wdGlvbnMoZm9ybWF0KTtcclxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuZGlzYWJsZWQgIT09IHRydWUpIHtcclxuICAgICAgICAgICAgICAgIGlmIChbXCJ4bHN4XCIsIFwiY3N2XCIsIFwianNvblwiLCBcImh0bWxcIiwgXCJwZGZkYXRhXCJdLmluZGV4T2YoZm9ybWF0KSA9PSAtMSB8fCAoaGFzRGF0YSAmJiBkb3dubG9hZFN1cHBvcnQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzLnB1c2goZm9ybWF0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiByZXM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBsaXN0IG9mIHN1cHBvcnRlZCBleHBvcnQgdHlwZXM6IGltYWdlIG9yIHByaW50LlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm4gU3VwcG9ydGVkIHR5cGVzXHJcbiAgICAgKi9cclxuICAgIHN1cHBvcnRlZEV4cG9ydFR5cGVzKCkge1xyXG4gICAgICAgIGNvbnN0IHJlcyA9IFtcImltYWdlXCIsIFwicHJpbnRcIl07XHJcbiAgICAgICAgaWYgKHRoaXMuZG93bmxvYWRTdXBwb3J0KCkgJiYgdGhpcy5oYXNEYXRhKCkpIHtcclxuICAgICAgICAgICAgcmVzLnB1c2goXCJkYXRhXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgfVxyXG59XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShFeHBvcnRpbmcsIFwiY2xhc3NOYW1lXCIsIHtcclxuICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgIHZhbHVlOiBcIkV4cG9ydGluZ1wiXHJcbn0pO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRXhwb3J0aW5nLCBcImNsYXNzTmFtZXNcIiwge1xyXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgdmFsdWU6IEVudGl0eS5jbGFzc05hbWVzLmNvbmNhdChbRXhwb3J0aW5nLmNsYXNzTmFtZV0pXHJcbn0pO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1FeHBvcnRpbmcuanMubWFwIiwiaW1wb3J0IHsgVGhlbWUgfSBmcm9tIFwiLi4vY29yZS9UaGVtZVwiO1xyXG4vKipcclxuICogQGlnbm9yZVxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIEFuaW1hdGVkVGhlbWUgZXh0ZW5kcyBUaGVtZSB7XHJcbiAgICBzZXR1cERlZmF1bHRSdWxlcygpIHtcclxuICAgICAgICBzdXBlci5zZXR1cERlZmF1bHRSdWxlcygpO1xyXG4gICAgICAgIHRoaXMucnVsZShcIkNvbXBvbmVudFwiKS5zZXRBbGwoe1xyXG4gICAgICAgICAgICBpbnRlcnBvbGF0aW9uRHVyYXRpb246IDYwMFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMucnVsZShcIkhpZXJhcmNoeVwiKS5zZXQoXCJhbmltYXRpb25EdXJhdGlvblwiLCA2MDApO1xyXG4gICAgICAgIHRoaXMucnVsZShcIlNjcm9sbGJhclwiKS5zZXQoXCJhbmltYXRpb25EdXJhdGlvblwiLCA2MDApO1xyXG4gICAgICAgIHRoaXMucnVsZShcIlRvb2x0aXBcIikuc2V0KFwiYW5pbWF0aW9uRHVyYXRpb25cIiwgMzAwKTtcclxuICAgICAgICB0aGlzLnJ1bGUoXCJNYXBDaGFydFwiKS5zZXQoXCJhbmltYXRpb25EdXJhdGlvblwiLCAxMDAwKTtcclxuICAgICAgICB0aGlzLnJ1bGUoXCJNYXBDaGFydFwiKS5zZXQoXCJ3aGVlbER1cmF0aW9uXCIsIDMwMCk7XHJcbiAgICAgICAgdGhpcy5ydWxlKFwiRW50aXR5XCIpLnNldEFsbCh7XHJcbiAgICAgICAgICAgIHN0YXRlQW5pbWF0aW9uRHVyYXRpb246IDYwMFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMucnVsZShcIlNwcml0ZVwiKS5zdGF0ZXMuY3JlYXRlKFwiZGVmYXVsdFwiLCB7IHN0YXRlQW5pbWF0aW9uRHVyYXRpb246IDYwMCB9KTtcclxuICAgICAgICB0aGlzLnJ1bGUoXCJUb29sdGlwXCIsIFtcImF4aXNcIl0pLnNldEFsbCh7XHJcbiAgICAgICAgICAgIGFuaW1hdGlvbkR1cmF0aW9uOiAyMDBcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLnJ1bGUoXCJXb3JkQ2xvdWRcIikuc2V0KFwiYW5pbWF0aW9uRHVyYXRpb25cIiwgNTAwKTtcclxuICAgICAgICB0aGlzLnJ1bGUoXCJQb2x5Z29uXCIpLnNldChcImFuaW1hdGlvbkR1cmF0aW9uXCIsIDYwMCk7XHJcbiAgICAgICAgdGhpcy5ydWxlKFwiQXJjRGlhZ3JhbVwiKS5zZXQoXCJhbmltYXRpb25EdXJhdGlvblwiLCA2MDApO1xyXG4gICAgfVxyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUFuaW1hdGVkVGhlbWUuanMubWFwIiwiaW1wb3J0IHsgQ29sb3IgfSBmcm9tIFwiLi4vY29yZS91dGlsL0NvbG9yXCI7XHJcbmltcG9ydCB7IFRoZW1lIH0gZnJvbSBcIi4uL2NvcmUvVGhlbWVcIjtcclxuLyoqXHJcbiAqIEBpZ25vcmVcclxuICovXHJcbmV4cG9ydCBjbGFzcyBEYXJrVGhlbWUgZXh0ZW5kcyBUaGVtZSB7XHJcbiAgICBzZXR1cERlZmF1bHRSdWxlcygpIHtcclxuICAgICAgICBzdXBlci5zZXR1cERlZmF1bHRSdWxlcygpO1xyXG4gICAgICAgIHRoaXMucnVsZShcIkludGVyZmFjZUNvbG9yc1wiKS5zZXRBbGwoe1xyXG4gICAgICAgICAgICBzdHJva2U6IENvbG9yLmZyb21IZXgoMHgwMDAwMDApLFxyXG4gICAgICAgICAgICBmaWxsOiBDb2xvci5mcm9tSGV4KDB4MmIyYjJiKSxcclxuICAgICAgICAgICAgcHJpbWFyeUJ1dHRvbjogQ29sb3IubGlnaHRlbihDb2xvci5mcm9tSGV4KDB4Njc5NGRjKSwgLTAuMiksXHJcbiAgICAgICAgICAgIHByaW1hcnlCdXR0b25Ib3ZlcjogQ29sb3IubGlnaHRlbihDb2xvci5mcm9tSGV4KDB4Njc3MWRjKSwgLTAuMiksXHJcbiAgICAgICAgICAgIHByaW1hcnlCdXR0b25Eb3duOiBDb2xvci5saWdodGVuKENvbG9yLmZyb21IZXgoMHg2OGRjNzUpLCAtMC4yKSxcclxuICAgICAgICAgICAgcHJpbWFyeUJ1dHRvbkFjdGl2ZTogQ29sb3IubGlnaHRlbihDb2xvci5mcm9tSGV4KDB4NjhkYzc2KSwgLTAuMiksXHJcbiAgICAgICAgICAgIHByaW1hcnlCdXR0b25UZXh0OiBDb2xvci5mcm9tSGV4KDB4ZmZmZmZmKSxcclxuICAgICAgICAgICAgcHJpbWFyeUJ1dHRvblN0cm9rZTogQ29sb3IubGlnaHRlbihDb2xvci5mcm9tSGV4KDB4Njc5NGRjKSwgLTAuMiksXHJcbiAgICAgICAgICAgIHNlY29uZGFyeUJ1dHRvbjogQ29sb3IuZnJvbUhleCgweDNiM2IzYiksXHJcbiAgICAgICAgICAgIHNlY29uZGFyeUJ1dHRvbkhvdmVyOiBDb2xvci5saWdodGVuKENvbG9yLmZyb21IZXgoMHgzYjNiM2IpLCAwLjEpLFxyXG4gICAgICAgICAgICBzZWNvbmRhcnlCdXR0b25Eb3duOiBDb2xvci5saWdodGVuKENvbG9yLmZyb21IZXgoMHgzYjNiM2IpLCAwLjE1KSxcclxuICAgICAgICAgICAgc2Vjb25kYXJ5QnV0dG9uQWN0aXZlOiBDb2xvci5saWdodGVuKENvbG9yLmZyb21IZXgoMHgzYjNiM2IpLCAwLjIpLFxyXG4gICAgICAgICAgICBzZWNvbmRhcnlCdXR0b25UZXh0OiBDb2xvci5mcm9tSGV4KDB4YmJiYmJiKSxcclxuICAgICAgICAgICAgc2Vjb25kYXJ5QnV0dG9uU3Ryb2tlOiBDb2xvci5saWdodGVuKENvbG9yLmZyb21IZXgoMHgzYjNiM2IpLCAtMC4yKSxcclxuICAgICAgICAgICAgZ3JpZDogQ29sb3IuZnJvbUhleCgweGJiYmJiYiksXHJcbiAgICAgICAgICAgIGJhY2tncm91bmQ6IENvbG9yLmZyb21IZXgoMHgwMDAwMDApLFxyXG4gICAgICAgICAgICBhbHRlcm5hdGl2ZUJhY2tncm91bmQ6IENvbG9yLmZyb21IZXgoMHhmZmZmZmYpLFxyXG4gICAgICAgICAgICB0ZXh0OiBDb2xvci5mcm9tSGV4KDB4ZmZmZmZmKSxcclxuICAgICAgICAgICAgYWx0ZXJuYXRpdmVUZXh0OiBDb2xvci5mcm9tSGV4KDB4MDAwMDAwKSxcclxuICAgICAgICAgICAgZGlzYWJsZWQ6IENvbG9yLmZyb21IZXgoMHhhZGFkYWQpLFxyXG4gICAgICAgICAgICBwb3NpdGl2ZTogQ29sb3IuZnJvbUhleCgweDUwYjMwMCksXHJcbiAgICAgICAgICAgIG5lZ2F0aXZlOiBDb2xvci5mcm9tSGV4KDB4YjMwMDAwKVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPURhcmtUaGVtZS5qcy5tYXAiLCJpbXBvcnQgeyBUaGVtZSB9IGZyb20gXCIuLi9jb3JlL1RoZW1lXCI7XHJcbmltcG9ydCB7IHAxMDAsIHA1MCB9IGZyb20gXCIuLi9jb3JlL3V0aWwvUGVyY2VudFwiO1xyXG5pbXBvcnQgeyBDb2xvciB9IGZyb20gXCIuLi9jb3JlL3V0aWwvQ29sb3JcIjtcclxuaW1wb3J0IHsgR3JpZExheW91dCB9IGZyb20gXCIuLi9jb3JlL3JlbmRlci9HcmlkTGF5b3V0XCI7XHJcbmltcG9ydCAqIGFzICRlYXNlIGZyb20gXCIuLi9jb3JlL3V0aWwvRWFzZVwiO1xyXG4vKipcclxuICogQGlnbm9yZVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHNldENvbG9yKHJ1bGUsIGtleSwgaWMsIG5hbWUpIHtcclxuICAgIC8vIFRPRE8gdGhpcyBzaG91bGRuJ3QgdXNlIGdldCwgZmlndXJlIG91dCBhIGJldHRlciB3YXlcclxuICAgIHJ1bGUuc2V0KGtleSwgaWMuZ2V0KG5hbWUpKTtcclxuICAgIGljLm9uKG5hbWUsICh2YWx1ZSkgPT4ge1xyXG4gICAgICAgIHJ1bGUuc2V0KGtleSwgdmFsdWUpO1xyXG4gICAgfSk7XHJcbn1cclxuLyoqXHJcbiAqIEBpZ25vcmVcclxuICovXHJcbmV4cG9ydCBjbGFzcyBEZWZhdWx0VGhlbWUgZXh0ZW5kcyBUaGVtZSB7XHJcbiAgICBzZXR1cERlZmF1bHRSdWxlcygpIHtcclxuICAgICAgICBzdXBlci5zZXR1cERlZmF1bHRSdWxlcygpO1xyXG4gICAgICAgIGNvbnN0IGxhbmd1YWdlID0gdGhpcy5fcm9vdC5sYW5ndWFnZTtcclxuICAgICAgICBjb25zdCBpYyA9IHRoaXMuX3Jvb3QuaW50ZXJmYWNlQ29sb3JzO1xyXG4gICAgICAgIGNvbnN0IGhvcml6b250YWxMYXlvdXQgPSB0aGlzLl9yb290Lmhvcml6b250YWxMYXlvdXQ7XHJcbiAgICAgICAgY29uc3QgdmVydGljYWxMYXlvdXQgPSB0aGlzLl9yb290LnZlcnRpY2FsTGF5b3V0O1xyXG4gICAgICAgIGNvbnN0IHIgPSB0aGlzLnJ1bGUuYmluZCh0aGlzKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICAgICAgICAgKiBjb3JlXHJcbiAgICAgICAgICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgcihcIkludGVyZmFjZUNvbG9yc1wiKS5zZXRBbGwoe1xyXG4gICAgICAgICAgICBzdHJva2U6IENvbG9yLmZyb21IZXgoMHhlNWU1ZTUpLFxyXG4gICAgICAgICAgICBmaWxsOiBDb2xvci5mcm9tSGV4KDB4ZjNmM2YzKSxcclxuICAgICAgICAgICAgcHJpbWFyeUJ1dHRvbjogQ29sb3IuZnJvbUhleCgweDY3OTRkYyksXHJcbiAgICAgICAgICAgIHByaW1hcnlCdXR0b25Ib3ZlcjogQ29sb3IuZnJvbUhleCgweDY3NzFkYyksXHJcbiAgICAgICAgICAgIHByaW1hcnlCdXR0b25Eb3duOiBDb2xvci5mcm9tSGV4KDB4NjhkYzc2KSxcclxuICAgICAgICAgICAgcHJpbWFyeUJ1dHRvbkFjdGl2ZTogQ29sb3IuZnJvbUhleCgweDY4ZGM3NiksXHJcbiAgICAgICAgICAgIHByaW1hcnlCdXR0b25UZXh0OiBDb2xvci5mcm9tSGV4KDB4ZmZmZmZmKSxcclxuICAgICAgICAgICAgcHJpbWFyeUJ1dHRvblN0cm9rZTogQ29sb3IuZnJvbUhleCgweGZmZmZmZiksXHJcbiAgICAgICAgICAgIHNlY29uZGFyeUJ1dHRvbjogQ29sb3IuZnJvbUhleCgweGQ5ZDlkOSksXHJcbiAgICAgICAgICAgIHNlY29uZGFyeUJ1dHRvbkhvdmVyOiBDb2xvci5mcm9tSGV4KDB4YTNhM2EzKSxcclxuICAgICAgICAgICAgc2Vjb25kYXJ5QnV0dG9uRG93bjogQ29sb3IuZnJvbUhleCgweDhkOGQ4ZCksXHJcbiAgICAgICAgICAgIHNlY29uZGFyeUJ1dHRvbkFjdGl2ZTogQ29sb3IuZnJvbUhleCgweGU2ZTZlNiksXHJcbiAgICAgICAgICAgIHNlY29uZGFyeUJ1dHRvblRleHQ6IENvbG9yLmZyb21IZXgoMHgwMDAwMDApLFxyXG4gICAgICAgICAgICBzZWNvbmRhcnlCdXR0b25TdHJva2U6IENvbG9yLmZyb21IZXgoMHhmZmZmZmYpLFxyXG4gICAgICAgICAgICBncmlkOiBDb2xvci5mcm9tSGV4KDB4MDAwMDAwKSxcclxuICAgICAgICAgICAgYmFja2dyb3VuZDogQ29sb3IuZnJvbUhleCgweGZmZmZmZiksXHJcbiAgICAgICAgICAgIGFsdGVybmF0aXZlQmFja2dyb3VuZDogQ29sb3IuZnJvbUhleCgweDAwMDAwMCksXHJcbiAgICAgICAgICAgIHRleHQ6IENvbG9yLmZyb21IZXgoMHgwMDAwMDApLFxyXG4gICAgICAgICAgICBhbHRlcm5hdGl2ZVRleHQ6IENvbG9yLmZyb21IZXgoMHhmZmZmZmYpLFxyXG4gICAgICAgICAgICBkaXNhYmxlZDogQ29sb3IuZnJvbUhleCgweGFkYWRhZCksXHJcbiAgICAgICAgICAgIHBvc2l0aXZlOiBDb2xvci5mcm9tSGV4KDB4NTBiMzAwKSxcclxuICAgICAgICAgICAgbmVnYXRpdmU6IENvbG9yLmZyb21IZXgoMHhiMzAwMDApXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBjb25zdCBydWxlID0gcihcIkNvbG9yU2V0XCIpO1xyXG4gICAgICAgICAgICBydWxlLnNldEFsbCh7XHJcbiAgICAgICAgICAgICAgICBwYXNzT3B0aW9uczoge1xyXG4gICAgICAgICAgICAgICAgICAgIGh1ZTogMC4wNSxcclxuICAgICAgICAgICAgICAgICAgICBzYXR1cmF0aW9uOiAwLFxyXG4gICAgICAgICAgICAgICAgICAgIGxpZ2h0bmVzczogMFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGNvbG9yczogW1xyXG4gICAgICAgICAgICAgICAgICAgIENvbG9yLmZyb21IZXgoMHg2N2I3ZGMpXHJcbiAgICAgICAgICAgICAgICBdLFxyXG4gICAgICAgICAgICAgICAgc3RlcDogMSxcclxuICAgICAgICAgICAgICAgIC8vYmFzZUNvbG9yOiBDb2xvci5mcm9tUkdCKDEwMywgMTgzLCAyMjApLFxyXG4gICAgICAgICAgICAgICAgLy9jb3VudDogMjAsXHJcbiAgICAgICAgICAgICAgICByZXVzZTogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBzdGFydEluZGV4OiAwXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBydWxlLnNldFByaXZhdGUoXCJjdXJyZW50U3RlcFwiLCAwKTtcclxuICAgICAgICAgICAgcnVsZS5zZXRQcml2YXRlKFwiY3VycmVudFBhc3NcIiwgMCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHIoXCJFbnRpdHlcIikuc2V0QWxsKHtcclxuICAgICAgICAgICAgc3RhdGVBbmltYXRpb25EdXJhdGlvbjogMCxcclxuICAgICAgICAgICAgc3RhdGVBbmltYXRpb25FYXNpbmc6ICRlYXNlLm91dCgkZWFzZS5jdWJpYylcclxuICAgICAgICB9KTtcclxuICAgICAgICByKFwiQ29tcG9uZW50XCIpLnNldEFsbCh7XHJcbiAgICAgICAgICAgIGludGVycG9sYXRpb25EdXJhdGlvbjogMCxcclxuICAgICAgICAgICAgaW50ZXJwb2xhdGlvbkVhc2luZzogJGVhc2Uub3V0KCRlYXNlLmN1YmljKVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHIoXCJTcHJpdGVcIikuc2V0QWxsKHtcclxuICAgICAgICAgICAgdmlzaWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgc2NhbGU6IDEsXHJcbiAgICAgICAgICAgIG9wYWNpdHk6IDEsXHJcbiAgICAgICAgICAgIHJvdGF0aW9uOiAwLFxyXG4gICAgICAgICAgICBwb3NpdGlvbjogXCJyZWxhdGl2ZVwiLFxyXG4gICAgICAgICAgICB0b29sdGlwWDogcDUwLFxyXG4gICAgICAgICAgICB0b29sdGlwWTogcDUwLFxyXG4gICAgICAgICAgICB0b29sdGlwUG9zaXRpb246IFwiZml4ZWRcIixcclxuICAgICAgICAgICAgaXNNZWFzdXJlZDogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHIoXCJTcHJpdGVcIikuc3RhdGVzLmNyZWF0ZShcImRlZmF1bHRcIiwgeyBcInZpc2libGVcIjogdHJ1ZSwgb3BhY2l0eTogMSB9KTtcclxuICAgICAgICByKFwiQ29udGFpbmVyXCIpLnNldEFsbCh7XHJcbiAgICAgICAgICAgIGludGVyYWN0aXZlQ2hpbGRyZW46IHRydWUsXHJcbiAgICAgICAgICAgIHNldFN0YXRlT25DaGlsZHJlbjogZmFsc2VcclxuICAgICAgICB9KTtcclxuICAgICAgICByKFwiR3JhcGhpY3NcIikuc2V0QWxsKHtcclxuICAgICAgICAgICAgc3Ryb2tlV2lkdGg6IDFcclxuICAgICAgICB9KTtcclxuICAgICAgICByKFwiQ2hhcnRcIikuc2V0QWxsKHtcclxuICAgICAgICAgICAgd2lkdGg6IHAxMDAsXHJcbiAgICAgICAgICAgIGhlaWdodDogcDEwMCxcclxuICAgICAgICAgICAgaW50ZXJhY3RpdmVDaGlsZHJlbjogZmFsc2VcclxuICAgICAgICB9KTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgICAgICAgKiBjb3JlOiBhbGlnbm1lbnRcclxuICAgICAgICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgICAgICAgKi9cclxuICAgICAgICByKFwiU3ByaXRlXCIsIFtcImhvcml6b250YWxcIiwgXCJjZW50ZXJcIl0pLnNldEFsbCh7XHJcbiAgICAgICAgICAgIGNlbnRlclg6IHA1MCxcclxuICAgICAgICAgICAgeDogcDUwXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcihcIlNwcml0ZVwiLCBbXCJ2ZXJ0aWNhbFwiLCBcImNlbnRlclwiXSkuc2V0QWxsKHtcclxuICAgICAgICAgICAgY2VudGVyWTogcDUwLFxyXG4gICAgICAgICAgICB5OiBwNTBcclxuICAgICAgICB9KTtcclxuICAgICAgICByKFwiQ29udGFpbmVyXCIsIFtcImhvcml6b250YWxcIiwgXCJsYXlvdXRcIl0pLnNldEFsbCh7XHJcbiAgICAgICAgICAgIGxheW91dDogaG9yaXpvbnRhbExheW91dFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHIoXCJDb250YWluZXJcIiwgW1widmVydGljYWxcIiwgXCJsYXlvdXRcIl0pLnNldEFsbCh7XHJcbiAgICAgICAgICAgIGxheW91dDogdmVydGljYWxMYXlvdXRcclxuICAgICAgICB9KTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgICAgICAgKiBjb3JlOiBwYXR0ZXJuc1xyXG4gICAgICAgICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHIoXCJQYXR0ZXJuXCIpLnNldEFsbCh7XHJcbiAgICAgICAgICAgIHJlcGV0aXRpb246IFwicmVwZWF0XCIsXHJcbiAgICAgICAgICAgIHdpZHRoOiA1MCxcclxuICAgICAgICAgICAgaGVpZ2h0OiA1MCxcclxuICAgICAgICAgICAgcm90YXRpb246IDAsXHJcbiAgICAgICAgICAgIGZpbGxPcGFjaXR5OiAxXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcihcIkxpbmVQYXR0ZXJuXCIpLnNldEFsbCh7XHJcbiAgICAgICAgICAgIGdhcDogNixcclxuICAgICAgICAgICAgY29sb3JPcGFjaXR5OiAxLFxyXG4gICAgICAgICAgICB3aWR0aDogNDksXHJcbiAgICAgICAgICAgIGhlaWdodDogNDlcclxuICAgICAgICB9KTtcclxuICAgICAgICByKFwiUmVjdGFuZ2xlUGF0dGVyblwiKS5zZXRBbGwoe1xyXG4gICAgICAgICAgICBnYXA6IDYsXHJcbiAgICAgICAgICAgIGNoZWNrZXJlZDogZmFsc2UsXHJcbiAgICAgICAgICAgIGNlbnRlcmVkOiB0cnVlLFxyXG4gICAgICAgICAgICBtYXhXaWR0aDogNSxcclxuICAgICAgICAgICAgbWF4SGVpZ2h0OiA1LFxyXG4gICAgICAgICAgICB3aWR0aDogNDgsXHJcbiAgICAgICAgICAgIGhlaWdodDogNDgsXHJcbiAgICAgICAgICAgIHN0cm9rZVdpZHRoOiAwXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcihcIkNpcmNsZVBhdHRlcm5cIikuc2V0QWxsKHtcclxuICAgICAgICAgICAgZ2FwOiA1LFxyXG4gICAgICAgICAgICBjaGVja2VyZWQ6IGZhbHNlLFxyXG4gICAgICAgICAgICBjZW50ZXJlZDogZmFsc2UsXHJcbiAgICAgICAgICAgIHJhZGl1czogMyxcclxuICAgICAgICAgICAgc3Ryb2tlV2lkdGg6IDAsXHJcbiAgICAgICAgICAgIHdpZHRoOiA0NSxcclxuICAgICAgICAgICAgaGVpZ2h0OiA0NVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHIoXCJHcmFpblBhdHRlcm5cIikuc2V0QWxsKHtcclxuICAgICAgICAgICAgd2lkdGg6IDIwMCxcclxuICAgICAgICAgICAgaGVpZ2h0OiAyMDAsXHJcbiAgICAgICAgICAgIGNvbG9yczogW0NvbG9yLmZyb21IZXgoMHgwMDAwMDApXSxcclxuICAgICAgICAgICAgc2l6ZTogMSxcclxuICAgICAgICAgICAgaG9yaXpvbnRhbEdhcDogMCxcclxuICAgICAgICAgICAgdmVydGljYWxHYXA6IDAsXHJcbiAgICAgICAgICAgIGRlbnNpdHk6IDEsXHJcbiAgICAgICAgICAgIG1pbk9wYWNpdHk6IDAsXHJcbiAgICAgICAgICAgIG1heE9wYWNpdHk6IDAuMlxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgICAgICAqIGNvcmU6IGdyYWRpZW50c1xyXG4gICAgICAgICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHIoXCJMaW5lYXJHcmFkaWVudFwiKS5zZXRBbGwoe1xyXG4gICAgICAgICAgICByb3RhdGlvbjogOTBcclxuICAgICAgICB9KTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgICAgICAgKiBjb3JlOiBMZWdlbmRcclxuICAgICAgICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgICAgICAgKi9cclxuICAgICAgICByKFwiTGVnZW5kXCIpLnNldEFsbCh7XHJcbiAgICAgICAgICAgIGZpbGxGaWVsZDogXCJmaWxsXCIsXHJcbiAgICAgICAgICAgIHN0cm9rZUZpZWxkOiBcInN0cm9rZVwiLFxyXG4gICAgICAgICAgICBuYW1lRmllbGQ6IFwibmFtZVwiLFxyXG4gICAgICAgICAgICBsYXlvdXQ6IEdyaWRMYXlvdXQubmV3KHRoaXMuX3Jvb3QsIHt9KSxcclxuICAgICAgICAgICAgbGF5ZXI6IDMwLFxyXG4gICAgICAgICAgICBjbGlja1RhcmdldDogXCJpdGVtQ29udGFpbmVyXCJcclxuICAgICAgICB9KTtcclxuICAgICAgICAvLyBDbGFzczogQ29udGFpbmVyXHJcbiAgICAgICAgcihcIkNvbnRhaW5lclwiLCBbXCJsZWdlbmRcIiwgXCJpdGVtXCIsIFwiaXRlbWNvbnRhaW5lclwiXSkuc2V0QWxsKHtcclxuICAgICAgICAgICAgcGFkZGluZ0xlZnQ6IDUsXHJcbiAgICAgICAgICAgIHBhZGRpbmdSaWdodDogNSxcclxuICAgICAgICAgICAgcGFkZGluZ0JvdHRvbTogNSxcclxuICAgICAgICAgICAgcGFkZGluZ1RvcDogNSxcclxuICAgICAgICAgICAgbGF5b3V0OiBob3Jpem9udGFsTGF5b3V0LFxyXG4gICAgICAgICAgICBzZXRTdGF0ZU9uQ2hpbGRyZW46IHRydWUsXHJcbiAgICAgICAgICAgIGludGVyYWN0aXZlQ2hpbGRyZW46IGZhbHNlLFxyXG4gICAgICAgICAgICBhcmlhQ2hlY2tlZDogdHJ1ZSxcclxuICAgICAgICAgICAgZm9jdXNhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBhcmlhTGFiZWw6IGxhbmd1YWdlLnRyYW5zbGF0ZShcIlByZXNzIEVOVEVSIHRvIHRvZ2dsZVwiKSxcclxuICAgICAgICAgICAgcm9sZTogXCJjaGVja2JveFwiXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBjb25zdCBydWxlID0gcihcIlJlY3RhbmdsZVwiLCBbXCJsZWdlbmRcIiwgXCJpdGVtXCIsIFwiYmFja2dyb3VuZFwiXSk7XHJcbiAgICAgICAgICAgIHJ1bGUuc2V0QWxsKHtcclxuICAgICAgICAgICAgICAgIGZpbGxPcGFjaXR5OiAwLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgc2V0Q29sb3IocnVsZSwgXCJmaWxsXCIsIGljLCBcImJhY2tncm91bmRcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHIoXCJDb250YWluZXJcIiwgW1wibGVnZW5kXCIsIFwibWFya2VyXCJdKS5zZXRBbGwoe1xyXG4gICAgICAgICAgICBzZXRTdGF0ZU9uQ2hpbGRyZW46IHRydWUsXHJcbiAgICAgICAgICAgIGNlbnRlclk6IHA1MCxcclxuICAgICAgICAgICAgcGFkZGluZ0xlZnQ6IDAsXHJcbiAgICAgICAgICAgIHBhZGRpbmdSaWdodDogMCxcclxuICAgICAgICAgICAgcGFkZGluZ0JvdHRvbTogMCxcclxuICAgICAgICAgICAgcGFkZGluZ1RvcDogMCxcclxuICAgICAgICAgICAgd2lkdGg6IDE4LFxyXG4gICAgICAgICAgICBoZWlnaHQ6IDE4XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcihcIlJvdW5kZWRSZWN0YW5nbGVcIiwgW1wibGVnZW5kXCIsIFwibWFya2VyXCIsIFwicmVjdGFuZ2xlXCJdKS5zZXRBbGwoe1xyXG4gICAgICAgICAgICB3aWR0aDogcDEwMCxcclxuICAgICAgICAgICAgaGVpZ2h0OiBwMTAwLFxyXG4gICAgICAgICAgICBjb3JuZXJSYWRpdXNCTDogMyxcclxuICAgICAgICAgICAgY29ybmVyUmFkaXVzVEw6IDMsXHJcbiAgICAgICAgICAgIGNvcm5lclJhZGl1c0JSOiAzLFxyXG4gICAgICAgICAgICBjb3JuZXJSYWRpdXNUUjogM1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgY29uc3QgcnVsZSA9IHIoXCJSb3VuZGVkUmVjdGFuZ2xlXCIsIFtcImxlZ2VuZFwiLCBcIm1hcmtlclwiLCBcInJlY3RhbmdsZVwiXSkuc3RhdGVzLmNyZWF0ZShcImRpc2FibGVkXCIsIHt9KTtcclxuICAgICAgICAgICAgc2V0Q29sb3IocnVsZSwgXCJmaWxsXCIsIGljLCBcImRpc2FibGVkXCIpO1xyXG4gICAgICAgICAgICBzZXRDb2xvcihydWxlLCBcInN0cm9rZVwiLCBpYywgXCJkaXNhYmxlZFwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcihcIkxhYmVsXCIsIFtcImxlZ2VuZFwiLCBcImxhYmVsXCJdKS5zZXRBbGwoe1xyXG4gICAgICAgICAgICBjZW50ZXJZOiBwNTAsXHJcbiAgICAgICAgICAgIG1hcmdpbkxlZnQ6IDUsXHJcbiAgICAgICAgICAgIHBhZGRpbmdSaWdodDogMCxcclxuICAgICAgICAgICAgcGFkZGluZ0xlZnQ6IDAsXHJcbiAgICAgICAgICAgIHBhZGRpbmdUb3A6IDAsXHJcbiAgICAgICAgICAgIHBhZGRpbmdCb3R0b206IDAsXHJcbiAgICAgICAgICAgIHBvcHVsYXRlVGV4dDogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgY29uc3QgcnVsZSA9IHIoXCJMYWJlbFwiLCBbXCJsZWdlbmRcIiwgXCJsYWJlbFwiXSkuc3RhdGVzLmNyZWF0ZShcImRpc2FibGVkXCIsIHt9KTtcclxuICAgICAgICAgICAgc2V0Q29sb3IocnVsZSwgXCJmaWxsXCIsIGljLCBcImRpc2FibGVkXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByKFwiTGFiZWxcIiwgW1wibGVnZW5kXCIsIFwidmFsdWVcIiwgXCJsYWJlbFwiXSkuc2V0QWxsKHtcclxuICAgICAgICAgICAgY2VudGVyWTogcDUwLFxyXG4gICAgICAgICAgICBtYXJnaW5MZWZ0OiA1LFxyXG4gICAgICAgICAgICBwYWRkaW5nUmlnaHQ6IDAsXHJcbiAgICAgICAgICAgIHBhZGRpbmdMZWZ0OiAwLFxyXG4gICAgICAgICAgICBwYWRkaW5nVG9wOiAwLFxyXG4gICAgICAgICAgICBwYWRkaW5nQm90dG9tOiAwLFxyXG4gICAgICAgICAgICB3aWR0aDogNTAsXHJcbiAgICAgICAgICAgIGNlbnRlclg6IHAxMDAsXHJcbiAgICAgICAgICAgIHBvcHVsYXRlVGV4dDogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgY29uc3QgcnVsZSA9IHIoXCJMYWJlbFwiLCBbXCJsZWdlbmRcIiwgXCJ2YWx1ZVwiLCBcImxhYmVsXCJdKS5zdGF0ZXMuY3JlYXRlKFwiZGlzYWJsZWRcIiwge30pO1xyXG4gICAgICAgICAgICBzZXRDb2xvcihydWxlLCBcImZpbGxcIiwgaWMsIFwiZGlzYWJsZWRcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgICAgICAqIGNvcmU6IEhlYXRMZWdlbmRcclxuICAgICAgICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgICAgICAgKi9cclxuICAgICAgICByKFwiSGVhdExlZ2VuZFwiKS5zZXRBbGwoe1xyXG4gICAgICAgICAgICBzdGVwQ291bnQ6IDFcclxuICAgICAgICB9KTtcclxuICAgICAgICByKFwiUm91bmRlZFJlY3RhbmdsZVwiLCBbXCJoZWF0bGVnZW5kXCIsIFwibWFya2VyXCJdKS5zZXRBbGwoe1xyXG4gICAgICAgICAgICBjb3JuZXJSYWRpdXNUUjogMCxcclxuICAgICAgICAgICAgY29ybmVyUmFkaXVzQlI6IDAsXHJcbiAgICAgICAgICAgIGNvcm5lclJhZGl1c1RMOiAwLFxyXG4gICAgICAgICAgICBjb3JuZXJSYWRpdXNCTDogMFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHIoXCJSb3VuZGVkUmVjdGFuZ2xlXCIsIFtcInZlcnRpY2FsXCIsIFwiaGVhdGxlZ2VuZFwiLCBcIm1hcmtlclwiXSkuc2V0QWxsKHtcclxuICAgICAgICAgICAgaGVpZ2h0OiBwMTAwLFxyXG4gICAgICAgICAgICB3aWR0aDogMTVcclxuICAgICAgICB9KTtcclxuICAgICAgICByKFwiUm91bmRlZFJlY3RhbmdsZVwiLCBbXCJob3Jpem9udGFsXCIsIFwiaGVhdGxlZ2VuZFwiLCBcIm1hcmtlclwiXSkuc2V0QWxsKHtcclxuICAgICAgICAgICAgd2lkdGg6IHAxMDAsXHJcbiAgICAgICAgICAgIGhlaWdodDogMTVcclxuICAgICAgICB9KTtcclxuICAgICAgICByKFwiSGVhdExlZ2VuZFwiLCBbXCJ2ZXJ0aWNhbFwiXSkuc2V0QWxsKHtcclxuICAgICAgICAgICAgaGVpZ2h0OiBwMTAwXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcihcIkhlYXRMZWdlbmRcIiwgW1wiaG9yaXpvbnRhbFwiXSkuc2V0QWxsKHtcclxuICAgICAgICAgICAgd2lkdGg6IHAxMDBcclxuICAgICAgICB9KTtcclxuICAgICAgICByKFwiTGFiZWxcIiwgW1wiaGVhdGxlZ2VuZFwiLCBcInN0YXJ0XCJdKS5zZXRBbGwoe1xyXG4gICAgICAgICAgICBwYWRkaW5nTGVmdDogNSxcclxuICAgICAgICAgICAgcGFkZGluZ1JpZ2h0OiA1LFxyXG4gICAgICAgICAgICBwYWRkaW5nVG9wOiA1LFxyXG4gICAgICAgICAgICBwYWRkaW5nQm90dG9tOiA1XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcihcIkxhYmVsXCIsIFtcImhlYXRsZWdlbmRcIiwgXCJlbmRcIl0pLnNldEFsbCh7XHJcbiAgICAgICAgICAgIHBhZGRpbmdMZWZ0OiA1LFxyXG4gICAgICAgICAgICBwYWRkaW5nUmlnaHQ6IDUsXHJcbiAgICAgICAgICAgIHBhZGRpbmdUb3A6IDUsXHJcbiAgICAgICAgICAgIHBhZGRpbmdCb3R0b206IDVcclxuICAgICAgICB9KTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgICAgICAgKiBjb3JlOiBMYWJlbHNcclxuICAgICAgICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgICAgICAgKi9cclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGNvbnN0IHJ1bGUgPSByKFwiTGFiZWxcIik7XHJcbiAgICAgICAgICAgIHJ1bGUuc2V0QWxsKHtcclxuICAgICAgICAgICAgICAgIHBhZGRpbmdUb3A6IDgsXHJcbiAgICAgICAgICAgICAgICBwYWRkaW5nQm90dG9tOiA4LFxyXG4gICAgICAgICAgICAgICAgcGFkZGluZ0xlZnQ6IDEwLFxyXG4gICAgICAgICAgICAgICAgcGFkZGluZ1JpZ2h0OiAxMCxcclxuICAgICAgICAgICAgICAgIGZvbnRGYW1pbHk6IFwiLWFwcGxlLXN5c3RlbSwgQmxpbmtNYWNTeXN0ZW1Gb250LCBcXFwiU2Vnb2UgVUlcXFwiLCBSb2JvdG8sIEhlbHZldGljYSwgQXJpYWwsIHNhbnMtc2VyaWYsIFxcXCJBcHBsZSBDb2xvciBFbW9qaVxcXCIsIFxcXCJTZWdvZSBVSSBFbW9qaVxcXCIsIFxcXCJTZWdvZSBVSSBTeW1ib2xcXFwiXCIsXHJcbiAgICAgICAgICAgICAgICBmb250U2l6ZTogXCIxZW1cIixcclxuICAgICAgICAgICAgICAgIHBvcHVsYXRlVGV4dDogZmFsc2VcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHNldENvbG9yKHJ1bGUsIFwiZmlsbFwiLCBpYywgXCJ0ZXh0XCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByKFwiUmFkaWFsTGFiZWxcIikuc2V0QWxsKHtcclxuICAgICAgICAgICAgdGV4dFR5cGU6IFwicmVndWxhclwiLFxyXG4gICAgICAgICAgICBjZW50ZXJZOiBwNTAsXHJcbiAgICAgICAgICAgIGNlbnRlclg6IHA1MCxcclxuICAgICAgICAgICAgaW5zaWRlOiBmYWxzZSxcclxuICAgICAgICAgICAgcmFkaXVzOiAwLFxyXG4gICAgICAgICAgICBiYXNlUmFkaXVzOiBwMTAwLFxyXG4gICAgICAgICAgICBvcmllbnRhdGlvbjogXCJhdXRvXCIsXHJcbiAgICAgICAgICAgIHRleHRBbGlnbjogXCJjZW50ZXJcIlxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgICAgICAqIGNvcmU6IEVsZW1lbnRzIGFuZCBzaGFwZXNcclxuICAgICAgICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgICAgICAgKi9cclxuICAgICAgICByKFwiUm91bmRlZFJlY3RhbmdsZVwiKS5zZXRBbGwoe1xyXG4gICAgICAgICAgICBjb3JuZXJSYWRpdXNUTDogOCxcclxuICAgICAgICAgICAgY29ybmVyUmFkaXVzQkw6IDgsXHJcbiAgICAgICAgICAgIGNvcm5lclJhZGl1c1RSOiA4LFxyXG4gICAgICAgICAgICBjb3JuZXJSYWRpdXNCUjogOFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHIoXCJQb2ludGVkUmVjdGFuZ2xlXCIpLnNldEFsbCh7XHJcbiAgICAgICAgICAgIHBvaW50ZXJCYXNlV2lkdGg6IDE1LFxyXG4gICAgICAgICAgICBwb2ludGVyTGVuZ3RoOiAxMCxcclxuICAgICAgICAgICAgY29ybmVyUmFkaXVzOiA4XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcihcIlNsaWNlXCIpLnNldEFsbCh7XHJcbiAgICAgICAgICAgIHNoaWZ0UmFkaXVzOiAwLFxyXG4gICAgICAgICAgICBkUmFkaXVzOiAwLFxyXG4gICAgICAgICAgICBkSW5uZXJSYWRpdXM6IDBcclxuICAgICAgICB9KTtcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGNvbnN0IHJ1bGUgPSByKFwiVGlja1wiKTtcclxuICAgICAgICAgICAgcnVsZS5zZXRBbGwoe1xyXG4gICAgICAgICAgICAgICAgc3Ryb2tlT3BhY2l0eTogLjE1LFxyXG4gICAgICAgICAgICAgICAgaXNNZWFzdXJlZDogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBsZW5ndGg6IDQuNSxcclxuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBcImFic29sdXRlXCIsXHJcbiAgICAgICAgICAgICAgICBjcmlzcDogdHJ1ZVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgc2V0Q29sb3IocnVsZSwgXCJzdHJva2VcIiwgaWMsIFwiZ3JpZFwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcihcIkJ1bGxldFwiKS5zZXRBbGwoe1xyXG4gICAgICAgICAgICBsb2NhdGlvblg6IDAuNSxcclxuICAgICAgICAgICAgbG9jYXRpb25ZOiAwLjVcclxuICAgICAgICB9KTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgICAgICAgKiBjb3JlOiBUb29sdGlwXHJcbiAgICAgICAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgcihcIlRvb2x0aXBcIikuc2V0QWxsKHtcclxuICAgICAgICAgICAgcG9zaXRpb246IFwiYWJzb2x1dGVcIixcclxuICAgICAgICAgICAgZ2V0RmlsbEZyb21TcHJpdGU6IHRydWUsXHJcbiAgICAgICAgICAgIGdldFN0cm9rZUZyb21TcHJpdGU6IGZhbHNlLFxyXG4gICAgICAgICAgICBhdXRvVGV4dENvbG9yOiB0cnVlLFxyXG4gICAgICAgICAgICBwYWRkaW5nVG9wOiA5LFxyXG4gICAgICAgICAgICBwYWRkaW5nQm90dG9tOiA4LFxyXG4gICAgICAgICAgICBwYWRkaW5nTGVmdDogMTAsXHJcbiAgICAgICAgICAgIHBhZGRpbmdSaWdodDogMTAsXHJcbiAgICAgICAgICAgIG1hcmdpbkJvdHRvbTogNSxcclxuICAgICAgICAgICAgcG9pbnRlck9yaWVudGF0aW9uOiBcInZlcnRpY2FsXCIsXHJcbiAgICAgICAgICAgIGNlbnRlclg6IHA1MCxcclxuICAgICAgICAgICAgY2VudGVyWTogcDUwLFxyXG4gICAgICAgICAgICBhbmltYXRpb25FYXNpbmc6ICRlYXNlLm91dCgkZWFzZS5jdWJpYyksXHJcbiAgICAgICAgICAgIGV4cG9ydGFibGU6IGZhbHNlXHJcbiAgICAgICAgICAgIC8vbGF5ZXI6IDEwMFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHIoXCJQb2x5Z29uXCIpLnNldEFsbCh7XHJcbiAgICAgICAgICAgIGFuaW1hdGlvbkVhc2luZzogJGVhc2Uub3V0KCRlYXNlLmN1YmljKSxcclxuICAgICAgICB9KTtcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGNvbnN0IHJ1bGUgPSByKFwiUG9pbnRlZFJlY3RhbmdsZVwiLCBbXCJ0b29sdGlwXCIsIFwiYmFja2dyb3VuZFwiXSk7XHJcbiAgICAgICAgICAgIHJ1bGUuc2V0QWxsKHtcclxuICAgICAgICAgICAgICAgIHN0cm9rZU9wYWNpdHk6IDAuOSxcclxuICAgICAgICAgICAgICAgIGNvcm5lclJhZGl1czogNCxcclxuICAgICAgICAgICAgICAgIHBvaW50ZXJMZW5ndGg6IDQsXHJcbiAgICAgICAgICAgICAgICBwb2ludGVyQmFzZVdpZHRoOiA4LFxyXG4gICAgICAgICAgICAgICAgZmlsbE9wYWNpdHk6IDAuOSxcclxuICAgICAgICAgICAgICAgIHN0cm9rZTogQ29sb3IuZnJvbUhleCgweGZmZmZmZilcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgY29uc3QgcnVsZSA9IHIoXCJMYWJlbFwiLCBbXCJ0b29sdGlwXCJdKTtcclxuICAgICAgICAgICAgcnVsZS5zZXRBbGwoe1xyXG4gICAgICAgICAgICAgICAgcm9sZTogXCJ0b29sdGlwXCIsXHJcbiAgICAgICAgICAgICAgICBwb3B1bGF0ZVRleHQ6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBwYWRkaW5nUmlnaHQ6IDAsXHJcbiAgICAgICAgICAgICAgICBwYWRkaW5nVG9wOiAwLFxyXG4gICAgICAgICAgICAgICAgcGFkZGluZ0xlZnQ6IDAsXHJcbiAgICAgICAgICAgICAgICBwYWRkaW5nQm90dG9tOiAwXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBzZXRDb2xvcihydWxlLCBcImZpbGxcIiwgaWMsIFwiYWx0ZXJuYXRpdmVUZXh0XCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgICAgICAgKiBjb3JlOiBCdXR0b25cclxuICAgICAgICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgICAgICAgKi9cclxuICAgICAgICByKFwiQnV0dG9uXCIpLnNldEFsbCh7XHJcbiAgICAgICAgICAgIHBhZGRpbmdUb3A6IDgsXHJcbiAgICAgICAgICAgIHBhZGRpbmdCb3R0b206IDgsXHJcbiAgICAgICAgICAgIHBhZGRpbmdMZWZ0OiAxMCxcclxuICAgICAgICAgICAgcGFkZGluZ1JpZ2h0OiAxMCxcclxuICAgICAgICAgICAgaW50ZXJhY3RpdmU6IHRydWUsXHJcbiAgICAgICAgICAgIGxheW91dDogaG9yaXpvbnRhbExheW91dCxcclxuICAgICAgICAgICAgaW50ZXJhY3RpdmVDaGlsZHJlbjogZmFsc2UsXHJcbiAgICAgICAgICAgIHNldFN0YXRlT25DaGlsZHJlbjogdHJ1ZSxcclxuICAgICAgICAgICAgZm9jdXNhYmxlOiB0cnVlXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcihcIkJ1dHRvblwiKS5zdGF0ZXMuY3JlYXRlKFwiaG92ZXJcIiwge30pO1xyXG4gICAgICAgIHIoXCJCdXR0b25cIikuc3RhdGVzLmNyZWF0ZShcImRvd25cIiwgeyBzdGF0ZUFuaW1hdGlvbkR1cmF0aW9uOiAwIH0pO1xyXG4gICAgICAgIHIoXCJCdXR0b25cIikuc3RhdGVzLmNyZWF0ZShcImFjdGl2ZVwiLCB7fSk7XHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBjb25zdCBydWxlID0gcihcIlJvdW5kZWRSZWN0YW5nbGVcIiwgW1wiYnV0dG9uXCIsIFwiYmFja2dyb3VuZFwiXSk7XHJcbiAgICAgICAgICAgIHNldENvbG9yKHJ1bGUsIFwiZmlsbFwiLCBpYywgXCJwcmltYXJ5QnV0dG9uXCIpO1xyXG4gICAgICAgICAgICBzZXRDb2xvcihydWxlLCBcInN0cm9rZVwiLCBpYywgXCJwcmltYXJ5QnV0dG9uU3Ryb2tlXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGNvbnN0IHJ1bGUgPSByKFwiUm91bmRlZFJlY3RhbmdsZVwiLCBbXCJidXR0b25cIiwgXCJiYWNrZ3JvdW5kXCJdKS5zdGF0ZXMuY3JlYXRlKFwiaG92ZXJcIiwge30pO1xyXG4gICAgICAgICAgICBzZXRDb2xvcihydWxlLCBcImZpbGxcIiwgaWMsIFwicHJpbWFyeUJ1dHRvbkhvdmVyXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGNvbnN0IHJ1bGUgPSByKFwiUm91bmRlZFJlY3RhbmdsZVwiLCBbXCJidXR0b25cIiwgXCJiYWNrZ3JvdW5kXCJdKS5zdGF0ZXMuY3JlYXRlKFwiZG93blwiLCB7IHN0YXRlQW5pbWF0aW9uRHVyYXRpb246IDAgfSk7XHJcbiAgICAgICAgICAgIHNldENvbG9yKHJ1bGUsIFwiZmlsbFwiLCBpYywgXCJwcmltYXJ5QnV0dG9uRG93blwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBjb25zdCBydWxlID0gcihcIlJvdW5kZWRSZWN0YW5nbGVcIiwgW1wiYnV0dG9uXCIsIFwiYmFja2dyb3VuZFwiXSkuc3RhdGVzLmNyZWF0ZShcImFjdGl2ZVwiLCB7fSk7XHJcbiAgICAgICAgICAgIHNldENvbG9yKHJ1bGUsIFwiZmlsbFwiLCBpYywgXCJwcmltYXJ5QnV0dG9uQWN0aXZlXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGNvbnN0IHJ1bGUgPSByKFwiR3JhcGhpY3NcIiwgW1wiYnV0dG9uXCIsIFwiaWNvblwiXSk7XHJcbiAgICAgICAgICAgIHNldENvbG9yKHJ1bGUsIFwic3Ryb2tlXCIsIGljLCBcInByaW1hcnlCdXR0b25UZXh0XCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGNvbnN0IHJ1bGUgPSByKFwiTGFiZWxcIiwgW1wiYnV0dG9uXCJdKTtcclxuICAgICAgICAgICAgc2V0Q29sb3IocnVsZSwgXCJmaWxsXCIsIGljLCBcInByaW1hcnlCdXR0b25UZXh0XCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgICAgICAgKiBjaGFydHMveHk6IFpvb21PdXRCdXR0b25cclxuICAgICAgICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgICAgICAgKi9cclxuICAgICAgICByKFwiQnV0dG9uXCIsIFtcInpvb21cIl0pLnNldEFsbCh7XHJcbiAgICAgICAgICAgIHBhZGRpbmdUb3A6IDE4LFxyXG4gICAgICAgICAgICBwYWRkaW5nQm90dG9tOiAxOCxcclxuICAgICAgICAgICAgcGFkZGluZ0xlZnQ6IDEyLFxyXG4gICAgICAgICAgICBwYWRkaW5nUmlnaHQ6IDEyLFxyXG4gICAgICAgICAgICBjZW50ZXJYOiA0NixcclxuICAgICAgICAgICAgY2VudGVyWTogLTEwLFxyXG4gICAgICAgICAgICB5OiAwLFxyXG4gICAgICAgICAgICB4OiBwMTAwLFxyXG4gICAgICAgICAgICByb2xlOiBcImJ1dHRvblwiLFxyXG4gICAgICAgICAgICBhcmlhTGFiZWw6IGxhbmd1YWdlLnRyYW5zbGF0ZShcIlpvb20gT3V0XCIpLFxyXG4gICAgICAgICAgICBsYXllcjogMzBcclxuICAgICAgICB9KTtcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGNvbnN0IHJ1bGUgPSByKFwiUm91bmRlZFJlY3RhbmdsZVwiLCBbXCJiYWNrZ3JvdW5kXCIsIFwiYnV0dG9uXCIsIFwiem9vbVwiXSk7XHJcbiAgICAgICAgICAgIHJ1bGUuc2V0QWxsKHtcclxuICAgICAgICAgICAgICAgIGNvcm5lclJhZGl1c0JMOiA0MCxcclxuICAgICAgICAgICAgICAgIGNvcm5lclJhZGl1c0JSOiA0MCxcclxuICAgICAgICAgICAgICAgIGNvcm5lclJhZGl1c1RMOiA0MCxcclxuICAgICAgICAgICAgICAgIGNvcm5lclJhZGl1c1RSOiA0MFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgc2V0Q29sb3IocnVsZSwgXCJmaWxsXCIsIGljLCBcInByaW1hcnlCdXR0b25cIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgY29uc3QgcnVsZSA9IHIoXCJSb3VuZGVkUmVjdGFuZ2xlXCIsIFtcImJhY2tncm91bmRcIiwgXCJidXR0b25cIiwgXCJ6b29tXCJdKS5zdGF0ZXMuY3JlYXRlKFwiaG92ZXJcIiwge30pO1xyXG4gICAgICAgICAgICBzZXRDb2xvcihydWxlLCBcImZpbGxcIiwgaWMsIFwicHJpbWFyeUJ1dHRvbkhvdmVyXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGNvbnN0IHJ1bGUgPSByKFwiUm91bmRlZFJlY3RhbmdsZVwiLCBbXCJiYWNrZ3JvdW5kXCIsIFwiYnV0dG9uXCIsIFwiem9vbVwiXSkuc3RhdGVzLmNyZWF0ZShcImRvd25cIiwgeyBzdGF0ZUFuaW1hdGlvbkR1cmF0aW9uOiAwIH0pO1xyXG4gICAgICAgICAgICBzZXRDb2xvcihydWxlLCBcImZpbGxcIiwgaWMsIFwicHJpbWFyeUJ1dHRvbkRvd25cIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgY29uc3QgcnVsZSA9IHIoXCJHcmFwaGljc1wiLCBbXCJpY29uXCIsIFwiYnV0dG9uXCIsIFwiem9vbVwiXSk7XHJcbiAgICAgICAgICAgIHJ1bGUuc2V0QWxsKHtcclxuICAgICAgICAgICAgICAgIGNyaXNwOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgc3Ryb2tlT3BhY2l0eTogMC43LFxyXG4gICAgICAgICAgICAgICAgZHJhdzogKGRpc3BsYXkpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBkaXNwbGF5Lm1vdmVUbygwLCAwKTtcclxuICAgICAgICAgICAgICAgICAgICBkaXNwbGF5LmxpbmVUbygxMiwgMCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBzZXRDb2xvcihydWxlLCBcInN0cm9rZVwiLCBpYywgXCJwcmltYXJ5QnV0dG9uVGV4dFwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICAgICAgICogY29yZTogUmVzaXplQnV0dG9uXHJcbiAgICAgICAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgcihcIkJ1dHRvblwiLCBbXCJyZXNpemVcIl0pLnNldEFsbCh7XHJcbiAgICAgICAgICAgIHBhZGRpbmdUb3A6IDksXHJcbiAgICAgICAgICAgIHBhZGRpbmdCb3R0b206IDksXHJcbiAgICAgICAgICAgIHBhZGRpbmdMZWZ0OiAxMyxcclxuICAgICAgICAgICAgcGFkZGluZ1JpZ2h0OiAxMyxcclxuICAgICAgICAgICAgZHJhZ2dhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjZW50ZXJYOiBwNTAsXHJcbiAgICAgICAgICAgIGNlbnRlclk6IHA1MCxcclxuICAgICAgICAgICAgcG9zaXRpb246IFwiYWJzb2x1dGVcIixcclxuICAgICAgICAgICAgcm9sZTogXCJzbGlkZXJcIixcclxuICAgICAgICAgICAgYXJpYVZhbHVlTWluOiBcIjBcIixcclxuICAgICAgICAgICAgYXJpYVZhbHVlTWF4OiBcIjEwMFwiLFxyXG4gICAgICAgICAgICBhcmlhTGFiZWw6IGxhbmd1YWdlLnRyYW5zbGF0ZShcIlVzZSB1cCBhbmQgZG93biBhcnJvd3MgdG8gbW92ZSBzZWxlY3Rpb25cIilcclxuICAgICAgICB9KTtcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGNvbnN0IHJ1bGUgPSByKFwiUm91bmRlZFJlY3RhbmdsZVwiLCBbXCJiYWNrZ3JvdW5kXCIsIFwicmVzaXplXCIsIFwiYnV0dG9uXCJdKTtcclxuICAgICAgICAgICAgcnVsZS5zZXRBbGwoe1xyXG4gICAgICAgICAgICAgICAgY29ybmVyUmFkaXVzQkw6IDQwLFxyXG4gICAgICAgICAgICAgICAgY29ybmVyUmFkaXVzQlI6IDQwLFxyXG4gICAgICAgICAgICAgICAgY29ybmVyUmFkaXVzVEw6IDQwLFxyXG4gICAgICAgICAgICAgICAgY29ybmVyUmFkaXVzVFI6IDQwXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBzZXRDb2xvcihydWxlLCBcImZpbGxcIiwgaWMsIFwic2Vjb25kYXJ5QnV0dG9uXCIpO1xyXG4gICAgICAgICAgICBzZXRDb2xvcihydWxlLCBcInN0cm9rZVwiLCBpYywgXCJzZWNvbmRhcnlCdXR0b25TdHJva2VcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgY29uc3QgcnVsZSA9IHIoXCJSb3VuZGVkUmVjdGFuZ2xlXCIsIFtcImJhY2tncm91bmRcIiwgXCJyZXNpemVcIiwgXCJidXR0b25cIl0pLnN0YXRlcy5jcmVhdGUoXCJob3ZlclwiLCB7fSk7XHJcbiAgICAgICAgICAgIHNldENvbG9yKHJ1bGUsIFwiZmlsbFwiLCBpYywgXCJzZWNvbmRhcnlCdXR0b25Ib3ZlclwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBjb25zdCBydWxlID0gcihcIlJvdW5kZWRSZWN0YW5nbGVcIiwgW1wiYmFja2dyb3VuZFwiLCBcInJlc2l6ZVwiLCBcImJ1dHRvblwiXSkuc3RhdGVzLmNyZWF0ZShcImRvd25cIiwgeyBzdGF0ZUFuaW1hdGlvbkR1cmF0aW9uOiAwIH0pO1xyXG4gICAgICAgICAgICBzZXRDb2xvcihydWxlLCBcImZpbGxcIiwgaWMsIFwic2Vjb25kYXJ5QnV0dG9uRG93blwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBjb25zdCBydWxlID0gcihcIkdyYXBoaWNzXCIsIFtcInJlc2l6ZVwiLCBcImJ1dHRvblwiLCBcImljb25cIl0pO1xyXG4gICAgICAgICAgICBydWxlLnNldEFsbCh7XHJcbiAgICAgICAgICAgICAgICBpbnRlcmFjdGl2ZTogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBjcmlzcDogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIHN0cm9rZU9wYWNpdHk6IDAuNSxcclxuICAgICAgICAgICAgICAgIGRyYXc6IChkaXNwbGF5KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheS5tb3ZlVG8oMCwgMC41KTtcclxuICAgICAgICAgICAgICAgICAgICBkaXNwbGF5LmxpbmVUbygwLCAxMi41KTtcclxuICAgICAgICAgICAgICAgICAgICBkaXNwbGF5Lm1vdmVUbyg0LCAwLjUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGRpc3BsYXkubGluZVRvKDQsIDEyLjUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgc2V0Q29sb3IocnVsZSwgXCJzdHJva2VcIiwgaWMsIFwic2Vjb25kYXJ5QnV0dG9uVGV4dFwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcihcIkJ1dHRvblwiLCBbXCJyZXNpemVcIiwgXCJ2ZXJ0aWNhbFwiXSkuc2V0QWxsKHtcclxuICAgICAgICAgICAgcm90YXRpb246IDkwLFxyXG4gICAgICAgICAgICBjdXJzb3JPdmVyU3R5bGU6IFwibnMtcmVzaXplXCJcclxuICAgICAgICB9KTtcclxuICAgICAgICByKFwiQnV0dG9uXCIsIFtcInJlc2l6ZVwiLCBcImhvcml6b250YWxcIl0pLnNldEFsbCh7XHJcbiAgICAgICAgICAgIGN1cnNvck92ZXJTdHlsZTogXCJldy1yZXNpemVcIlxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgICAgICAqIGNvcmU6IFBsYXlCdXR0b25cclxuICAgICAgICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgICAgICAgKi9cclxuICAgICAgICByKFwiQnV0dG9uXCIsIFtcInBsYXlcIl0pLnNldEFsbCh7XHJcbiAgICAgICAgICAgIHBhZGRpbmdUb3A6IDEzLFxyXG4gICAgICAgICAgICBwYWRkaW5nQm90dG9tOiAxMyxcclxuICAgICAgICAgICAgcGFkZGluZ0xlZnQ6IDE0LFxyXG4gICAgICAgICAgICBwYWRkaW5nUmlnaHQ6IDE0LFxyXG4gICAgICAgICAgICBhcmlhTGFiZWw6IGxhbmd1YWdlLnRyYW5zbGF0ZShcIlBsYXlcIiksXHJcbiAgICAgICAgICAgIHRvZ2dsZUtleTogXCJhY3RpdmVcIlxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgY29uc3QgcnVsZSA9IHIoXCJSb3VuZGVkUmVjdGFuZ2xlXCIsIFtcInBsYXlcIiwgXCJiYWNrZ3JvdW5kXCJdKTtcclxuICAgICAgICAgICAgcnVsZS5zZXRBbGwoe1xyXG4gICAgICAgICAgICAgICAgc3Ryb2tlT3BhY2l0eTogMC41LFxyXG4gICAgICAgICAgICAgICAgY29ybmVyUmFkaXVzQkw6IDEwMCxcclxuICAgICAgICAgICAgICAgIGNvcm5lclJhZGl1c0JSOiAxMDAsXHJcbiAgICAgICAgICAgICAgICBjb3JuZXJSYWRpdXNUTDogMTAwLFxyXG4gICAgICAgICAgICAgICAgY29ybmVyUmFkaXVzVFI6IDEwMFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgc2V0Q29sb3IocnVsZSwgXCJmaWxsXCIsIGljLCBcInByaW1hcnlCdXR0b25cIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgY29uc3QgcnVsZSA9IHIoXCJHcmFwaGljc1wiLCBbXCJwbGF5XCIsIFwiaWNvblwiXSk7XHJcbiAgICAgICAgICAgIHJ1bGUuc2V0QWxsKHtcclxuICAgICAgICAgICAgICAgIHN0YXRlQW5pbWF0aW9uRHVyYXRpb246IDAsXHJcbiAgICAgICAgICAgICAgICBkeDogMSxcclxuICAgICAgICAgICAgICAgIGRyYXc6IChkaXNwbGF5KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheS5tb3ZlVG8oMCwgLTUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGRpc3BsYXkubGluZVRvKDgsIDApO1xyXG4gICAgICAgICAgICAgICAgICAgIGRpc3BsYXkubGluZVRvKDAsIDUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGRpc3BsYXkubGluZVRvKDAsIC01KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHNldENvbG9yKHJ1bGUsIFwiZmlsbFwiLCBpYywgXCJwcmltYXJ5QnV0dG9uVGV4dFwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcihcIkdyYXBoaWNzXCIsIFtcInBsYXlcIiwgXCJpY29uXCJdKS5zdGF0ZXMuY3JlYXRlKFwiZGVmYXVsdFwiLCB7XHJcbiAgICAgICAgICAgIHN0YXRlQW5pbWF0aW9uRHVyYXRpb246IDBcclxuICAgICAgICB9KTtcclxuICAgICAgICByKFwiR3JhcGhpY3NcIiwgW1wicGxheVwiLCBcImljb25cIl0pLnN0YXRlcy5jcmVhdGUoXCJhY3RpdmVcIiwge1xyXG4gICAgICAgICAgICBzdGF0ZUFuaW1hdGlvbkR1cmF0aW9uOiAwLFxyXG4gICAgICAgICAgICBkcmF3OiAoZGlzcGxheSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgZGlzcGxheS5tb3ZlVG8oLTQsIC01KTtcclxuICAgICAgICAgICAgICAgIGRpc3BsYXkubGluZVRvKC0xLCAtNSk7XHJcbiAgICAgICAgICAgICAgICBkaXNwbGF5LmxpbmVUbygtMSwgNSk7XHJcbiAgICAgICAgICAgICAgICBkaXNwbGF5LmxpbmVUbygtNCwgNSk7XHJcbiAgICAgICAgICAgICAgICBkaXNwbGF5LmxpbmVUbygtNCwgLTUpO1xyXG4gICAgICAgICAgICAgICAgZGlzcGxheS5tb3ZlVG8oNCwgLTUpO1xyXG4gICAgICAgICAgICAgICAgZGlzcGxheS5saW5lVG8oMSwgLTUpO1xyXG4gICAgICAgICAgICAgICAgZGlzcGxheS5saW5lVG8oMSwgNSk7XHJcbiAgICAgICAgICAgICAgICBkaXNwbGF5LmxpbmVUbyg0LCA1KTtcclxuICAgICAgICAgICAgICAgIGRpc3BsYXkubGluZVRvKDQsIC01KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgICAgICAqIGNvcmU6IFN3aXRjaEJ1dHRvblxyXG4gICAgICAgICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHIoXCJCdXR0b25cIiwgW1wic3dpdGNoXCJdKS5zZXRBbGwoe1xyXG4gICAgICAgICAgICBwYWRkaW5nVG9wOiA0LFxyXG4gICAgICAgICAgICBwYWRkaW5nQm90dG9tOiA0LFxyXG4gICAgICAgICAgICBwYWRkaW5nTGVmdDogNCxcclxuICAgICAgICAgICAgcGFkZGluZ1JpZ2h0OiA0LFxyXG4gICAgICAgICAgICBhcmlhTGFiZWw6IGxhbmd1YWdlLnRyYW5zbGF0ZShcIlByZXNzIEVOVEVSIHRvIHRvZ2dsZVwiKSxcclxuICAgICAgICAgICAgdG9nZ2xlS2V5OiBcImFjdGl2ZVwiLFxyXG4gICAgICAgICAgICB3aWR0aDogNDAsXHJcbiAgICAgICAgICAgIGhlaWdodDogMjQsXHJcbiAgICAgICAgICAgIGxheW91dDogbnVsbFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgY29uc3QgcnVsZSA9IHIoXCJSb3VuZGVkUmVjdGFuZ2xlXCIsIFtcInN3aXRjaFwiLCBcImJhY2tncm91bmRcIl0pO1xyXG4gICAgICAgICAgICBydWxlLnNldEFsbCh7XHJcbiAgICAgICAgICAgICAgICBzdHJva2VPcGFjaXR5OiAwLjUsXHJcbiAgICAgICAgICAgICAgICBjb3JuZXJSYWRpdXNCTDogMTAwLFxyXG4gICAgICAgICAgICAgICAgY29ybmVyUmFkaXVzQlI6IDEwMCxcclxuICAgICAgICAgICAgICAgIGNvcm5lclJhZGl1c1RMOiAxMDAsXHJcbiAgICAgICAgICAgICAgICBjb3JuZXJSYWRpdXNUUjogMTAwXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBzZXRDb2xvcihydWxlLCBcImZpbGxcIiwgaWMsIFwicHJpbWFyeUJ1dHRvblwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBjb25zdCBydWxlID0gcihcIkNpcmNsZVwiLCBbXCJzd2l0Y2hcIiwgXCJpY29uXCJdKTtcclxuICAgICAgICAgICAgcnVsZS5zZXRBbGwoe1xyXG4gICAgICAgICAgICAgICAgcmFkaXVzOiA4LFxyXG4gICAgICAgICAgICAgICAgY2VudGVyWTogMCxcclxuICAgICAgICAgICAgICAgIGNlbnRlclg6IDAsXHJcbiAgICAgICAgICAgICAgICBkeDogMFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgc2V0Q29sb3IocnVsZSwgXCJmaWxsXCIsIGljLCBcInByaW1hcnlCdXR0b25UZXh0XCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByKFwiR3JhcGhpY3NcIiwgW1wic3dpdGNoXCIsIFwiaWNvblwiXSkuc3RhdGVzLmNyZWF0ZShcImFjdGl2ZVwiLCB7XHJcbiAgICAgICAgICAgIGR4OiAxNlxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgICAgICAqIGNvcmU6IFNjcm9sbGJhclxyXG4gICAgICAgICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHIoXCJTY3JvbGxiYXJcIikuc2V0QWxsKHtcclxuICAgICAgICAgICAgc3RhcnQ6IDAsXHJcbiAgICAgICAgICAgIGVuZDogMSxcclxuICAgICAgICAgICAgbGF5ZXI6IDMwLFxyXG4gICAgICAgICAgICBhbmltYXRpb25FYXNpbmc6ICRlYXNlLm91dCgkZWFzZS5jdWJpYylcclxuICAgICAgICB9KTtcclxuICAgICAgICByKFwiU2Nyb2xsYmFyXCIsIFtcInZlcnRpY2FsXCJdKS5zZXRBbGwoe1xyXG4gICAgICAgICAgICBtYXJnaW5SaWdodDogMTMsXHJcbiAgICAgICAgICAgIG1hcmdpbkxlZnQ6IDEzLFxyXG4gICAgICAgICAgICBtaW5XaWR0aDogMTIsXHJcbiAgICAgICAgICAgIGhlaWdodDogcDEwMFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHIoXCJTY3JvbGxiYXJcIiwgW1wiaG9yaXpvbnRhbFwiXSkuc2V0QWxsKHtcclxuICAgICAgICAgICAgbWFyZ2luVG9wOiAxMyxcclxuICAgICAgICAgICAgbWFyZ2luQm90dG9tOiAxMyxcclxuICAgICAgICAgICAgbWluSGVpZ2h0OiAxMixcclxuICAgICAgICAgICAgd2lkdGg6IHAxMDBcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLnJ1bGUoXCJCdXR0b25cIiwgW1wic2Nyb2xsYmFyXCJdKS5zZXRBbGwoe1xyXG4gICAgICAgICAgICBleHBvcnRhYmxlOiBmYWxzZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgY29uc3QgcnVsZSA9IHIoXCJSb3VuZGVkUmVjdGFuZ2xlXCIsIFtcInNjcm9sbGJhclwiLCBcIm1haW5cIiwgXCJiYWNrZ3JvdW5kXCJdKTtcclxuICAgICAgICAgICAgcnVsZS5zZXRBbGwoe1xyXG4gICAgICAgICAgICAgICAgY29ybmVyUmFkaXVzVEw6IDgsXHJcbiAgICAgICAgICAgICAgICBjb3JuZXJSYWRpdXNCTDogOCxcclxuICAgICAgICAgICAgICAgIGNvcm5lclJhZGl1c1RSOiA4LFxyXG4gICAgICAgICAgICAgICAgY29ybmVyUmFkaXVzQlI6IDgsXHJcbiAgICAgICAgICAgICAgICBmaWxsT3BhY2l0eTogMC44LFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgc2V0Q29sb3IocnVsZSwgXCJmaWxsXCIsIGljLCBcImZpbGxcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgY29uc3QgcnVsZSA9IHIoXCJSb3VuZGVkUmVjdGFuZ2xlXCIsIFtcInNjcm9sbGJhclwiLCBcInRodW1iXCJdKTtcclxuICAgICAgICAgICAgcnVsZS5zZXRBbGwoe1xyXG4gICAgICAgICAgICAgICAgcm9sZTogXCJzbGlkZXJcIixcclxuICAgICAgICAgICAgICAgIGFyaWFMaXZlOiBcInBvbGl0ZVwiLFxyXG4gICAgICAgICAgICAgICAgcG9zaXRpb246IFwiYWJzb2x1dGVcIixcclxuICAgICAgICAgICAgICAgIGRyYWdnYWJsZTogdHJ1ZVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgc2V0Q29sb3IocnVsZSwgXCJmaWxsXCIsIGljLCBcInNlY29uZGFyeUJ1dHRvblwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBjb25zdCBydWxlID0gcihcIlJvdW5kZWRSZWN0YW5nbGVcIiwgW1wic2Nyb2xsYmFyXCIsIFwidGh1bWJcIl0pLnN0YXRlcy5jcmVhdGUoXCJob3ZlclwiLCB7fSk7XHJcbiAgICAgICAgICAgIHNldENvbG9yKHJ1bGUsIFwiZmlsbFwiLCBpYywgXCJzZWNvbmRhcnlCdXR0b25Ib3ZlclwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBjb25zdCBydWxlID0gcihcIlJvdW5kZWRSZWN0YW5nbGVcIiwgW1wic2Nyb2xsYmFyXCIsIFwidGh1bWJcIl0pLnN0YXRlcy5jcmVhdGUoXCJkb3duXCIsIHsgc3RhdGVBbmltYXRpb25EdXJhdGlvbjogMCB9KTtcclxuICAgICAgICAgICAgc2V0Q29sb3IocnVsZSwgXCJmaWxsXCIsIGljLCBcInNlY29uZGFyeUJ1dHRvbkRvd25cIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHIoXCJSb3VuZGVkUmVjdGFuZ2xlXCIsIFtcInNjcm9sbGJhclwiLCBcInRodW1iXCIsIFwidmVydGljYWxcIl0pLnNldEFsbCh7XHJcbiAgICAgICAgICAgIHg6IHA1MCxcclxuICAgICAgICAgICAgd2lkdGg6IHAxMDAsXHJcbiAgICAgICAgICAgIGNlbnRlclg6IHA1MCxcclxuICAgICAgICAgICAgYXJpYUxhYmVsOiBsYW5ndWFnZS50cmFuc2xhdGUoXCJVc2UgdXAgYW5kIGRvd24gYXJyb3dzIHRvIG1vdmUgc2VsZWN0aW9uXCIpXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcihcIlJvdW5kZWRSZWN0YW5nbGVcIiwgW1wic2Nyb2xsYmFyXCIsIFwidGh1bWJcIiwgXCJob3Jpem9udGFsXCJdKS5zZXRBbGwoe1xyXG4gICAgICAgICAgICB5OiBwNTAsXHJcbiAgICAgICAgICAgIGNlbnRlclk6IHA1MCxcclxuICAgICAgICAgICAgaGVpZ2h0OiBwMTAwLFxyXG4gICAgICAgICAgICBhcmlhTGFiZWw6IGxhbmd1YWdlLnRyYW5zbGF0ZShcIlVzZSBsZWZ0IGFuZCByaWdodCBhcnJvd3MgdG8gbW92ZSBzZWxlY3Rpb25cIilcclxuICAgICAgICB9KTtcclxuICAgICAgICAvLyBAdG9kbzogaXMgdGhpcyBuZWVkZWQ/IHVzZWQgdG8gYmUgXCJDb250ZW50U2Nyb2xsYmFyXCJcclxuICAgICAgICAvLyByKFwiU2Nyb2xsYmFyXCIsIFtcImNvbnRlbnQ/XCJdKS5zZXRBbGwoe1xyXG4gICAgICAgIC8vIFx0bWFyZ2luUmlnaHQ6IDAsXHJcbiAgICAgICAgLy8gXHRtYXJnaW5MZWZ0OiA1LFxyXG4gICAgICAgIC8vIFx0bGF5ZXI6IDVcclxuICAgICAgICAvLyB9KTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICAgICAgICAgKiBjaGFydHMveHlcclxuICAgICAgICAgKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIFRoaXMgbmVlZHMgdG8gYmUgaW4gRGVmYXVsdFRoZW1lIGJlY2F1c2UgaXQncyB0aGUgb25seSB0aGVtZSB0aGF0IGlzXHJcbiAgICAgICAgICogYXV0b21hdGljYWxseSBhcHBsaWVkIHRvIFJvb3QsIGFuZCB0b29sdGlwcyBkaWZmZXJlbnQgYW5jZXN0b3JzXHJcbiAgICAgICAgICogdGhhbiBhY3R1YWwgY2hhcnRzIHVzaW5nIHRoZW0uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBjb25zdCBydWxlID0gcihcIlBvaW50ZWRSZWN0YW5nbGVcIiwgW1wiYXhpc1wiLCBcInRvb2x0aXBcIiwgXCJiYWNrZ3JvdW5kXCJdKTtcclxuICAgICAgICAgICAgcnVsZS5zZXRBbGwoe1xyXG4gICAgICAgICAgICAgICAgY29ybmVyUmFkaXVzOiAwXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBzZXRDb2xvcihydWxlLCBcImZpbGxcIiwgaWMsIFwiYWx0ZXJuYXRpdmVCYWNrZ3JvdW5kXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByKFwiTGFiZWxcIiwgW1wiYXhpc1wiLCBcInRvb2x0aXBcIl0pLnNldEFsbCh7XHJcbiAgICAgICAgICAgIHJvbGU6IHVuZGVmaW5lZFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHIoXCJMYWJlbFwiLCBbXCJheGlzXCIsIFwidG9vbHRpcFwiLCBcInlcIl0pLnNldEFsbCh7XHJcbiAgICAgICAgICAgIHRleHRBbGlnbjogXCJyaWdodFwiXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcihcIkxhYmVsXCIsIFtcImF4aXNcIiwgXCJ0b29sdGlwXCIsIFwieVwiLCBcIm9wcG9zaXRlXCJdKS5zZXRBbGwoe1xyXG4gICAgICAgICAgICB0ZXh0QWxpZ246IFwibGVmdFwiXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcihcIkxhYmVsXCIsIFtcImF4aXNcIiwgXCJ0b29sdGlwXCIsIFwieFwiXSkuc2V0QWxsKHtcclxuICAgICAgICAgICAgdGV4dEFsaWduOiBcImNlbnRlclwiXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcihcIlRvb2x0aXBcIiwgW1wiY2F0ZWdvcnlheGlzXCJdKS5zZXRBbGwoe1xyXG4gICAgICAgICAgICBsYWJlbFRleHQ6IFwie2NhdGVnb3J5fVwiXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICAgICAgICogU2hhcGVzXHJcbiAgICAgICAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgLy8gQ2xhc3M6IEdyYXBoaWNzXHJcbiAgICAgICAgcihcIlN0YXJcIikuc2V0QWxsKHtcclxuICAgICAgICAgICAgc3Bpa2VzOiA1LFxyXG4gICAgICAgICAgICBpbm5lclJhZGl1czogNSxcclxuICAgICAgICAgICAgcmFkaXVzOiAxMFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8vIFNUT0NLXHJcbiAgICAgICAgcihcIlRvb2x0aXBcIiwgW1wic3RvY2tcIl0pLnNldEFsbCh7XHJcbiAgICAgICAgICAgIHBhZGRpbmdUb3A6IDYsXHJcbiAgICAgICAgICAgIHBhZGRpbmdCb3R0b206IDUsXHJcbiAgICAgICAgICAgIHBhZGRpbmdMZWZ0OiA3LFxyXG4gICAgICAgICAgICBwYWRkaW5nUmlnaHQ6IDdcclxuICAgICAgICB9KTtcclxuICAgICAgICByKFwiUG9pbnRlZFJlY3RhbmdsZVwiLCBbXCJ0b29sdGlwXCIsIFwic3RvY2tcIiwgXCJheGlzXCJdKS5zZXRBbGwoe1xyXG4gICAgICAgICAgICBwb2ludGVyTGVuZ3RoOiAwLFxyXG4gICAgICAgICAgICBwb2ludGVyQmFzZVdpZHRoOiAwLFxyXG4gICAgICAgICAgICBjb3JuZXJSYWRpdXM6IDNcclxuICAgICAgICB9KTtcclxuICAgICAgICByKFwiTGFiZWxcIiwgW1widG9vbHRpcFwiLCBcInN0b2NrXCJdKS5zZXRBbGwoe1xyXG4gICAgICAgICAgICBmb250U2l6ZTogXCIwLjhlbVwiXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLy8gcmVzaXplclxyXG4gICAgICAgIHIoXCJTcHJpdGVSZXNpemVyXCIpLnNldEFsbCh7XHJcbiAgICAgICAgICAgIHJvdGF0aW9uU3RlcDogMTBcclxuICAgICAgICB9KTtcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGNvbnN0IHJ1bGUgPSByKFwiQ29udGFpbmVyXCIsIFtcInJlc2l6ZXJcIiwgXCJncmlwXCJdKTtcclxuICAgICAgICAgICAgcnVsZS5zdGF0ZXMuY3JlYXRlKFwiaG92ZXJcIiwge30pO1xyXG4gICAgICAgIH1cclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGNvbnN0IHJ1bGUgPSByKFwiUm91bmRlZFJlY3RhbmdsZVwiLCBbXCJyZXNpemVyXCIsIFwiZ3JpcFwiXSk7XHJcbiAgICAgICAgICAgIHJ1bGUuc2V0QWxsKHtcclxuICAgICAgICAgICAgICAgIHN0cm9rZU9wYWNpdHk6IDAuNyxcclxuICAgICAgICAgICAgICAgIHN0cm9rZVdpZHRoOiAxLFxyXG4gICAgICAgICAgICAgICAgZmlsbE9wYWNpdHk6IDEsXHJcbiAgICAgICAgICAgICAgICB3aWR0aDogMTIsXHJcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IDEyXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBzZXRDb2xvcihydWxlLCBcImZpbGxcIiwgaWMsIFwiYmFja2dyb3VuZFwiKTtcclxuICAgICAgICAgICAgc2V0Q29sb3IocnVsZSwgXCJzdHJva2VcIiwgaWMsIFwiYWx0ZXJuYXRpdmVCYWNrZ3JvdW5kXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGNvbnN0IHJ1bGUgPSByKFwiUm91bmRlZFJlY3RhbmdsZVwiLCBbXCJyZXNpemVyXCIsIFwiZ3JpcFwiLCBcIm91dGxpbmVcIl0pO1xyXG4gICAgICAgICAgICBydWxlLnNldEFsbCh7XHJcbiAgICAgICAgICAgICAgICBzdHJva2VPcGFjaXR5OiAwLFxyXG4gICAgICAgICAgICAgICAgZmlsbE9wYWNpdHk6IDAsXHJcbiAgICAgICAgICAgICAgICB3aWR0aDogMjAsXHJcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IDIwXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBydWxlLnN0YXRlcy5jcmVhdGUoXCJob3ZlclwiLCB7XHJcbiAgICAgICAgICAgICAgICBmaWxsT3BhY2l0eTogMC4zXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBzZXRDb2xvcihydWxlLCBcImZpbGxcIiwgaWMsIFwiYWx0ZXJuYXRpdmVCYWNrZ3JvdW5kXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByKFwiUm91bmRlZFJlY3RhbmdsZVwiLCBbXCJyZXNpemVyXCIsIFwiZ3JpcFwiLCBcImxlZnRcIl0pLnNldEFsbCh7XHJcbiAgICAgICAgICAgIGNvcm5lclJhZGl1c0JMOiAwLFxyXG4gICAgICAgICAgICBjb3JuZXJSYWRpdXNCUjogMCxcclxuICAgICAgICAgICAgY29ybmVyUmFkaXVzVEw6IDAsXHJcbiAgICAgICAgICAgIGNvcm5lclJhZGl1c1RSOiAwXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcihcIlJvdW5kZWRSZWN0YW5nbGVcIiwgW1wicmVzaXplclwiLCBcImdyaXBcIiwgXCJyaWdodFwiXSkuc2V0QWxsKHtcclxuICAgICAgICAgICAgY29ybmVyUmFkaXVzQkw6IDAsXHJcbiAgICAgICAgICAgIGNvcm5lclJhZGl1c0JSOiAwLFxyXG4gICAgICAgICAgICBjb3JuZXJSYWRpdXNUTDogMCxcclxuICAgICAgICAgICAgY29ybmVyUmFkaXVzVFI6IDBcclxuICAgICAgICB9KTtcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGNvbnN0IHJ1bGUgPSByKFwiUmVjdGFuZ2xlXCIsIFtcInJlc2l6ZXJcIiwgXCJyZWN0YW5nbGVcIl0pO1xyXG4gICAgICAgICAgICBydWxlLnNldEFsbCh7XHJcbiAgICAgICAgICAgICAgICBzdHJva2VEYXNoYXJyYXk6IFsyLCAyXSxcclxuICAgICAgICAgICAgICAgIHN0cm9rZU9wYWNpdHk6IDAuNSxcclxuICAgICAgICAgICAgICAgIHN0cm9rZVdpZHRoOiAxXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBzZXRDb2xvcihydWxlLCBcInN0cm9rZVwiLCBpYywgXCJhbHRlcm5hdGl2ZUJhY2tncm91bmRcIik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPURlZmF1bHRUaGVtZS5qcy5tYXAiLCJpbXBvcnQgeyBUaGVtZSB9IGZyb20gXCIuLi9jb3JlL1RoZW1lXCI7XHJcbmltcG9ydCB7IE11bHRpRGlzcG9zZXIgfSBmcm9tIFwiLi4vY29yZS91dGlsL0Rpc3Bvc2VyXCI7XHJcbmltcG9ydCB7IHAxMDAsIHBlcmNlbnQgfSBmcm9tIFwiLi4vY29yZS91dGlsL1BlcmNlbnRcIjtcclxuaW1wb3J0ICogYXMgJGFycmF5IGZyb20gXCIuLi9jb3JlL3V0aWwvQXJyYXlcIjtcclxuLyoqXHJcbiAqIEEgY29uZmlndXJhYmxlIHRoZW1lIHRoYXQgZHluYW1pY2FsbHkgYWRhcHRzIGNoYXJ0IHNldHRpbmdzIGZvciBiZXN0IGZpdFxyXG4gKiBpbiBhdmFpbGFibGUgc3BhY2UuXHJcbiAqXHJcbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vd3d3LmFtY2hhcnRzLmNvbS9kb2NzL3Y1L2NvbmNlcHRzL3Jlc3BvbnNpdmUvfSBmb3IgbW9yZSBpbmZvXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgUmVzcG9uc2l2ZVRoZW1lIGV4dGVuZHMgVGhlbWUge1xyXG4gICAgY29uc3RydWN0b3Iocm9vdCwgaXNSZWFsKSB7XHJcbiAgICAgICAgc3VwZXIocm9vdCwgaXNSZWFsKTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfZHBcIiwge1xyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ3VycmVudGx5IGFkZGVkIHJ1bGVzLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInJlc3BvbnNpdmVSdWxlc1wiLCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiBbXVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuX2RwID0gbmV3IE11bHRpRGlzcG9zZXIoW1xyXG4gICAgICAgICAgICB0aGlzLl9yb290Ll9yb290Q29udGFpbmVyLm9uUHJpdmF0ZShcIndpZHRoXCIsIChfd2lkdGgpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9pc1VzZWQoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX21heWJlQXBwbHlSdWxlcygpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KSxcclxuICAgICAgICAgICAgdGhpcy5fcm9vdC5fcm9vdENvbnRhaW5lci5vblByaXZhdGUoXCJoZWlnaHRcIiwgKF9oZWlnaHQpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9pc1VzZWQoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX21heWJlQXBwbHlSdWxlcygpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgIF0pO1xyXG4gICAgfVxyXG4gICAgLy8gQnJlYWtwb2ludCBmdW5jdGlvbnMgKGZvciB1c2UgaW4gYHJlbGV2YW50YCBjbGF1c2Ugb2YgdGhlIHJlc3BvbnNpdmUgcnVsZXMpXHJcbiAgICBzdGF0aWMgd2lkdGhYWFMod2lkdGgsIF9oZWlnaHQpIHtcclxuICAgICAgICByZXR1cm4gd2lkdGggPD0gUmVzcG9uc2l2ZVRoZW1lLlhYUztcclxuICAgIH1cclxuICAgIHN0YXRpYyB3aWR0aFhTKHdpZHRoLCBfaGVpZ2h0KSB7XHJcbiAgICAgICAgcmV0dXJuIHdpZHRoIDw9IFJlc3BvbnNpdmVUaGVtZS5YUztcclxuICAgIH1cclxuICAgIHN0YXRpYyB3aWR0aFMod2lkdGgsIF9oZWlnaHQpIHtcclxuICAgICAgICByZXR1cm4gd2lkdGggPD0gUmVzcG9uc2l2ZVRoZW1lLlM7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgd2lkdGhNKHdpZHRoLCBfaGVpZ2h0KSB7XHJcbiAgICAgICAgcmV0dXJuIHdpZHRoIDw9IFJlc3BvbnNpdmVUaGVtZS5NO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIHdpZHRoTCh3aWR0aCwgX2hlaWdodCkge1xyXG4gICAgICAgIHJldHVybiB3aWR0aCA8PSBSZXNwb25zaXZlVGhlbWUuTDtcclxuICAgIH1cclxuICAgIHN0YXRpYyB3aWR0aFhMKHdpZHRoLCBfaGVpZ2h0KSB7XHJcbiAgICAgICAgcmV0dXJuIHdpZHRoIDw9IFJlc3BvbnNpdmVUaGVtZS5YTDtcclxuICAgIH1cclxuICAgIHN0YXRpYyB3aWR0aFhYTCh3aWR0aCwgX2hlaWdodCkge1xyXG4gICAgICAgIHJldHVybiB3aWR0aCA8PSBSZXNwb25zaXZlVGhlbWUuWFhMO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGhlaWdodFhYUyhfd2lkdGgsIGhlaWdodCkge1xyXG4gICAgICAgIHJldHVybiBoZWlnaHQgPD0gUmVzcG9uc2l2ZVRoZW1lLlhYUztcclxuICAgIH1cclxuICAgIHN0YXRpYyBoZWlnaHRYUyhfd2lkdGgsIGhlaWdodCkge1xyXG4gICAgICAgIHJldHVybiBoZWlnaHQgPD0gUmVzcG9uc2l2ZVRoZW1lLlhTO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGhlaWdodFMoX3dpZHRoLCBoZWlnaHQpIHtcclxuICAgICAgICByZXR1cm4gaGVpZ2h0IDw9IFJlc3BvbnNpdmVUaGVtZS5TO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGhlaWdodE0oX3dpZHRoLCBoZWlnaHQpIHtcclxuICAgICAgICByZXR1cm4gaGVpZ2h0IDw9IFJlc3BvbnNpdmVUaGVtZS5NO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGhlaWdodEwoX3dpZHRoLCBoZWlnaHQpIHtcclxuICAgICAgICByZXR1cm4gaGVpZ2h0IDw9IFJlc3BvbnNpdmVUaGVtZS5MO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGhlaWdodFhMKF93aWR0aCwgaGVpZ2h0KSB7XHJcbiAgICAgICAgcmV0dXJuIGhlaWdodCA8PSBSZXNwb25zaXZlVGhlbWUuWEw7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgaGVpZ2h0WFhMKF93aWR0aCwgaGVpZ2h0KSB7XHJcbiAgICAgICAgcmV0dXJuIGhlaWdodCA8PSBSZXNwb25zaXZlVGhlbWUuWFhMO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGlzWFhTKHdpZHRoLCBoZWlnaHQpIHtcclxuICAgICAgICByZXR1cm4gKHdpZHRoIDw9IFJlc3BvbnNpdmVUaGVtZS5YWFMpICYmIChoZWlnaHQgPD0gUmVzcG9uc2l2ZVRoZW1lLlhYUyk7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgaXNYUyh3aWR0aCwgaGVpZ2h0KSB7XHJcbiAgICAgICAgcmV0dXJuICh3aWR0aCA8PSBSZXNwb25zaXZlVGhlbWUuWFMpICYmIChoZWlnaHQgPD0gUmVzcG9uc2l2ZVRoZW1lLlhTKTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBpc1Mod2lkdGgsIGhlaWdodCkge1xyXG4gICAgICAgIHJldHVybiAod2lkdGggPD0gUmVzcG9uc2l2ZVRoZW1lLlMpICYmIChoZWlnaHQgPD0gUmVzcG9uc2l2ZVRoZW1lLlMpO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGlzTSh3aWR0aCwgaGVpZ2h0KSB7XHJcbiAgICAgICAgcmV0dXJuICh3aWR0aCA8PSBSZXNwb25zaXZlVGhlbWUuTSkgJiYgKGhlaWdodCA8PSBSZXNwb25zaXZlVGhlbWUuTSk7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgaXNMKHdpZHRoLCBoZWlnaHQpIHtcclxuICAgICAgICByZXR1cm4gKHdpZHRoIDw9IFJlc3BvbnNpdmVUaGVtZS5MKSAmJiAoaGVpZ2h0IDw9IFJlc3BvbnNpdmVUaGVtZS5MKTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBpc1hMKHdpZHRoLCBoZWlnaHQpIHtcclxuICAgICAgICByZXR1cm4gKHdpZHRoIDw9IFJlc3BvbnNpdmVUaGVtZS5YTCkgJiYgKGhlaWdodCA8PSBSZXNwb25zaXZlVGhlbWUuWEwpO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGlzWFhMKHdpZHRoLCBoZWlnaHQpIHtcclxuICAgICAgICByZXR1cm4gKHdpZHRoIDw9IFJlc3BvbnNpdmVUaGVtZS5YWEwpICYmIChoZWlnaHQgPD0gUmVzcG9uc2l2ZVRoZW1lLlhYTCk7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgbWF5YmVYWFMod2lkdGgsIGhlaWdodCkge1xyXG4gICAgICAgIHJldHVybiAod2lkdGggPD0gUmVzcG9uc2l2ZVRoZW1lLlhYUykgfHwgKGhlaWdodCA8PSBSZXNwb25zaXZlVGhlbWUuWFhTKTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBtYXliZVhTKHdpZHRoLCBoZWlnaHQpIHtcclxuICAgICAgICByZXR1cm4gKHdpZHRoIDw9IFJlc3BvbnNpdmVUaGVtZS5YUykgfHwgKGhlaWdodCA8PSBSZXNwb25zaXZlVGhlbWUuWFMpO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIG1heWJlUyh3aWR0aCwgaGVpZ2h0KSB7XHJcbiAgICAgICAgcmV0dXJuICh3aWR0aCA8PSBSZXNwb25zaXZlVGhlbWUuUykgfHwgKGhlaWdodCA8PSBSZXNwb25zaXZlVGhlbWUuUyk7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgbWF5YmVNKHdpZHRoLCBoZWlnaHQpIHtcclxuICAgICAgICByZXR1cm4gKHdpZHRoIDw9IFJlc3BvbnNpdmVUaGVtZS5NKSB8fCAoaGVpZ2h0IDw9IFJlc3BvbnNpdmVUaGVtZS5NKTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBtYXliZUwod2lkdGgsIGhlaWdodCkge1xyXG4gICAgICAgIHJldHVybiAod2lkdGggPD0gUmVzcG9uc2l2ZVRoZW1lLkwpIHx8IChoZWlnaHQgPD0gUmVzcG9uc2l2ZVRoZW1lLkwpO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIG1heWJlWEwod2lkdGgsIGhlaWdodCkge1xyXG4gICAgICAgIHJldHVybiAod2lkdGggPD0gUmVzcG9uc2l2ZVRoZW1lLlhMKSB8fCAoaGVpZ2h0IDw9IFJlc3BvbnNpdmVUaGVtZS5YTCk7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgbWF5YmVYWEwod2lkdGgsIGhlaWdodCkge1xyXG4gICAgICAgIHJldHVybiAod2lkdGggPD0gUmVzcG9uc2l2ZVRoZW1lLlhYTCkgfHwgKGhlaWdodCA8PSBSZXNwb25zaXZlVGhlbWUuWFhMKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogSW5zdGFudGlhdGVzIHRoZSB0aGVtZSB3aXRob3V0IGFkZGluZyBkZWZhdWx0IHJlc3BvbXNpdmUgcnVsZXMuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBuZXdFbXB0eShyb290KSB7XHJcbiAgICAgICAgcmV0dXJuIChuZXcgdGhpcyhyb290LCB0cnVlKSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgYSByZXNwb25zaXZlIHJ1bGUgYXMgd2VsbCBhcyByZXR1bnMgaXQuXHJcbiAgICAgKlxyXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly93d3cuYW1jaGFydHMuY29tL2RvY3MvdjUvY29uY2VwdHMvcmVzcG9uc2l2ZS99IGZvciBtb3JlIGluZm9cclxuICAgICAqIEBwYXJhbSAgIHJ1bGUgIFJlc3BvbnNpdmUgcnVsZVxyXG4gICAgICogQHJldHVybiAgICAgICAgUmVzcG9uc2l2ZSBydWxlXHJcbiAgICAgKi9cclxuICAgIGFkZFJ1bGUocnVsZSkge1xyXG4gICAgICAgIGlmIChydWxlLm5hbWUgJiYgIXJ1bGUudGVtcGxhdGUpIHtcclxuICAgICAgICAgICAgcnVsZS50ZW1wbGF0ZSA9IHRoaXMucnVsZShydWxlLm5hbWUsIHJ1bGUudGFncyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMucmVzcG9uc2l2ZVJ1bGVzLnB1c2gocnVsZSk7XHJcbiAgICAgICAgdGhpcy5fbWF5YmVBcHBseVJ1bGUocnVsZSk7XHJcbiAgICAgICAgcmV0dXJuIHJ1bGU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZXMgdGhlIHJlc3BvbnNpdmUgcnVsZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gIHJ1bGUgIFJlc3BvbnNpdmUgcnVsZVxyXG4gICAgICovXHJcbiAgICByZW1vdmVSdWxlKHJ1bGUpIHtcclxuICAgICAgICAkYXJyYXkucmVtb3ZlKHRoaXMucmVzcG9uc2l2ZVJ1bGVzLCBydWxlKTtcclxuICAgIH1cclxuICAgIGRpc3Bvc2UoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2RwKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2RwLmRpc3Bvc2UoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBfaXNVc2VkKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9yb290Ll9yb290Q29udGFpbmVyLmdldChcInRoZW1lc1wiKS5pbmRleE9mKHRoaXMpICE9PSAtMTtcclxuICAgIH1cclxuICAgIF9tYXliZUFwcGx5UnVsZXMoKSB7XHJcbiAgICAgICAgJGFycmF5LmVhY2godGhpcy5yZXNwb25zaXZlUnVsZXMsIChydWxlKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuX21heWJlVW5hcHBseVJ1bGUocnVsZSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgJGFycmF5LmVhY2godGhpcy5yZXNwb25zaXZlUnVsZXMsIChydWxlKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuX21heWJlQXBwbHlSdWxlKHJ1bGUpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgX21heWJlQXBwbHlSdWxlKHJ1bGUpIHtcclxuICAgICAgICBpZiAocnVsZS5hcHBsaWVkKVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgY29uc3QgdyA9IHRoaXMuX3Jvb3QuX3Jvb3RDb250YWluZXIuZ2V0UHJpdmF0ZShcIndpZHRoXCIpO1xyXG4gICAgICAgIGNvbnN0IGggPSB0aGlzLl9yb290Ll9yb290Q29udGFpbmVyLmdldFByaXZhdGUoXCJoZWlnaHRcIik7XHJcbiAgICAgICAgY29uc3QgcmVsZXZhbnQgPSBydWxlLnJlbGV2YW50LmNhbGwocnVsZSwgdywgaCk7XHJcbiAgICAgICAgaWYgKHJlbGV2YW50KSB7XHJcbiAgICAgICAgICAgIHJ1bGUuYXBwbGllZCA9IHRydWU7XHJcbiAgICAgICAgICAgIGlmIChydWxlLnRlbXBsYXRlICYmIHJ1bGUuc2V0dGluZ3MpIHtcclxuICAgICAgICAgICAgICAgIHJ1bGUudGVtcGxhdGUuc2V0QWxsKHJ1bGUuc2V0dGluZ3MpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChydWxlLmFwcGx5aW5nKSB7XHJcbiAgICAgICAgICAgICAgICBydWxlLmFwcGx5aW5nLmNhbGwocnVsZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBfbWF5YmVVbmFwcGx5UnVsZShydWxlKSB7XHJcbiAgICAgICAgaWYgKCFydWxlLmFwcGxpZWQpXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICBjb25zdCB3ID0gdGhpcy5fcm9vdC5fcm9vdENvbnRhaW5lci5nZXRQcml2YXRlKFwid2lkdGhcIik7XHJcbiAgICAgICAgY29uc3QgaCA9IHRoaXMuX3Jvb3QuX3Jvb3RDb250YWluZXIuZ2V0UHJpdmF0ZShcImhlaWdodFwiKTtcclxuICAgICAgICBjb25zdCByZWxldmFudCA9IHJ1bGUucmVsZXZhbnQuY2FsbChydWxlLCB3LCBoKTtcclxuICAgICAgICBpZiAoIXJlbGV2YW50KSB7XHJcbiAgICAgICAgICAgIHJ1bGUuYXBwbGllZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICBpZiAocnVsZS50ZW1wbGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgcnVsZS50ZW1wbGF0ZS5yZW1vdmVBbGwoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAocnVsZS5yZW1vdmluZykge1xyXG4gICAgICAgICAgICAgICAgcnVsZS5yZW1vdmluZy5jYWxsKHJ1bGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIGRlZmF1bHQgcnVsZXMgZm9yIHZhcmlvdXMgY2hhcnQgdHlwZXMgYW5kIG1vc3Qgc3RhbmRhcmQgc2NlbmFyaW9zLlxyXG4gICAgICovXHJcbiAgICBzZXR1cERlZmF1bHRSdWxlcygpIHtcclxuICAgICAgICBzdXBlci5zZXR1cERlZmF1bHRSdWxlcygpO1xyXG4gICAgICAgIGNvbnN0IGFkZFJ1bGUgPSAocnVsZSkgPT4gdGhpcy5hZGRSdWxlKHJ1bGUpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4gICAgICAgICAqIFVuaXZlcnNhbFxyXG4gICAgICAgICAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGFkZFJ1bGUoe1xyXG4gICAgICAgICAgICBuYW1lOiBcIkNoYXJ0XCIsXHJcbiAgICAgICAgICAgIHJlbGV2YW50OiBSZXNwb25zaXZlVGhlbWUud2lkdGhYWFMsXHJcbiAgICAgICAgICAgIHNldHRpbmdzOiB7XHJcbiAgICAgICAgICAgICAgICBwYWRkaW5nTGVmdDogMCxcclxuICAgICAgICAgICAgICAgIHBhZGRpbmdSaWdodDogMFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgYWRkUnVsZSh7XHJcbiAgICAgICAgICAgIG5hbWU6IFwiQ2hhcnRcIixcclxuICAgICAgICAgICAgcmVsZXZhbnQ6IFJlc3BvbnNpdmVUaGVtZS5oZWlnaHRYWFMsXHJcbiAgICAgICAgICAgIHNldHRpbmdzOiB7XHJcbiAgICAgICAgICAgICAgICBwYWRkaW5nVG9wOiAwLFxyXG4gICAgICAgICAgICAgICAgcGFkZGluZ0JvdHRvbTogMFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgYWRkUnVsZSh7XHJcbiAgICAgICAgICAgIG5hbWU6IFwiQnVsbGV0XCIsXHJcbiAgICAgICAgICAgIHJlbGV2YW50OiBSZXNwb25zaXZlVGhlbWUuaXNYUyxcclxuICAgICAgICAgICAgc2V0dGluZ3M6IHtcclxuICAgICAgICAgICAgICAgIGZvcmNlSGlkZGVuOiB0cnVlXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICBhZGRSdWxlKHtcclxuICAgICAgICAgICAgbmFtZTogXCJMZWdlbmRcIixcclxuICAgICAgICAgICAgcmVsZXZhbnQ6IFJlc3BvbnNpdmVUaGVtZS5pc1hTLFxyXG4gICAgICAgICAgICBzZXR0aW5nczoge1xyXG4gICAgICAgICAgICAgICAgZm9yY2VIaWRkZW46IHRydWVcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGFkZFJ1bGUoe1xyXG4gICAgICAgICAgICBuYW1lOiBcIkhlYXRMZWdlbmRcIixcclxuICAgICAgICAgICAgdGFnczogW1widmVydGljYWxcIl0sXHJcbiAgICAgICAgICAgIHJlbGV2YW50OiBSZXNwb25zaXZlVGhlbWUud2lkdGhYUyxcclxuICAgICAgICAgICAgc2V0dGluZ3M6IHtcclxuICAgICAgICAgICAgICAgIGZvcmNlSGlkZGVuOiB0cnVlXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICBhZGRSdWxlKHtcclxuICAgICAgICAgICAgbmFtZTogXCJIZWF0TGVnZW5kXCIsXHJcbiAgICAgICAgICAgIHRhZ3M6IFtcImhvcml6b250YWxcIl0sXHJcbiAgICAgICAgICAgIHJlbGV2YW50OiBSZXNwb25zaXZlVGhlbWUuaGVpZ2h0WFMsXHJcbiAgICAgICAgICAgIHNldHRpbmdzOiB7XHJcbiAgICAgICAgICAgICAgICBmb3JjZUhpZGRlbjogdHJ1ZVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgYWRkUnVsZSh7XHJcbiAgICAgICAgICAgIG5hbWU6IFwiTGFiZWxcIixcclxuICAgICAgICAgICAgdGFnczogW1wiaGVhdGxlZ2VuZFwiLCBcInN0YXJ0XCJdLFxyXG4gICAgICAgICAgICByZWxldmFudDogUmVzcG9uc2l2ZVRoZW1lLm1heWJlWFMsXHJcbiAgICAgICAgICAgIHNldHRpbmdzOiB7XHJcbiAgICAgICAgICAgICAgICBmb3JjZUhpZGRlbjogdHJ1ZVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgYWRkUnVsZSh7XHJcbiAgICAgICAgICAgIG5hbWU6IFwiTGFiZWxcIixcclxuICAgICAgICAgICAgdGFnczogW1wiaGVhdGxlZ2VuZFwiLCBcImVuZFwiXSxcclxuICAgICAgICAgICAgcmVsZXZhbnQ6IFJlc3BvbnNpdmVUaGVtZS5tYXliZVhTLFxyXG4gICAgICAgICAgICBzZXR0aW5nczoge1xyXG4gICAgICAgICAgICAgICAgZm9yY2VIaWRkZW46IHRydWVcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGFkZFJ1bGUoe1xyXG4gICAgICAgICAgICBuYW1lOiBcIkJ1dHRvblwiLFxyXG4gICAgICAgICAgICB0YWdzOiBbXCJyZXNpemVcIl0sXHJcbiAgICAgICAgICAgIHJlbGV2YW50OiBSZXNwb25zaXZlVGhlbWUubWF5YmVYUyxcclxuICAgICAgICAgICAgc2V0dGluZ3M6IHtcclxuICAgICAgICAgICAgICAgIGZvcmNlSGlkZGVuOiB0cnVlXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICAgICAgICAgKiBYWVxyXG4gICAgICAgICAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGFkZFJ1bGUoe1xyXG4gICAgICAgICAgICBuYW1lOiBcIkF4aXNSZW5kZXJlclhcIixcclxuICAgICAgICAgICAgcmVsZXZhbnQ6IFJlc3BvbnNpdmVUaGVtZS5oZWlnaHRYUyxcclxuICAgICAgICAgICAgc2V0dGluZ3M6IHtcclxuICAgICAgICAgICAgICAgIGluc2lkZTogdHJ1ZVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgYWRkUnVsZSh7XHJcbiAgICAgICAgICAgIG5hbWU6IFwiQXhpc1JlbmRlcmVyWVwiLFxyXG4gICAgICAgICAgICByZWxldmFudDogUmVzcG9uc2l2ZVRoZW1lLndpZHRoWFMsXHJcbiAgICAgICAgICAgIHNldHRpbmdzOiB7XHJcbiAgICAgICAgICAgICAgICBpbnNpZGU6IHRydWVcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGFkZFJ1bGUoe1xyXG4gICAgICAgICAgICBuYW1lOiBcIkF4aXNSZW5kZXJlclhMYWJlbFwiLFxyXG4gICAgICAgICAgICByZWxldmFudDogUmVzcG9uc2l2ZVRoZW1lLmhlaWdodFhTLFxyXG4gICAgICAgICAgICBzZXR0aW5nczoge1xyXG4gICAgICAgICAgICAgICAgbWluUG9zaXRpb246IDAuMSxcclxuICAgICAgICAgICAgICAgIG1heFBvc2l0aW9uOiAwLjlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGFkZFJ1bGUoe1xyXG4gICAgICAgICAgICBuYW1lOiBcIkF4aXNMYWJlbFwiLFxyXG4gICAgICAgICAgICB0YWdzOiBbXCJ5XCJdLFxyXG4gICAgICAgICAgICByZWxldmFudDogUmVzcG9uc2l2ZVRoZW1lLndpZHRoWFMsXHJcbiAgICAgICAgICAgIHNldHRpbmdzOiB7XHJcbiAgICAgICAgICAgICAgICBjZW50ZXJZOiBwMTAwLFxyXG4gICAgICAgICAgICAgICAgbWF4UG9zaXRpb246IDAuOVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgYWRkUnVsZSh7XHJcbiAgICAgICAgICAgIG5hbWU6IFwiQXhpc0xhYmVsXCIsXHJcbiAgICAgICAgICAgIHRhZ3M6IFtcInhcIl0sXHJcbiAgICAgICAgICAgIHJlbGV2YW50OiBSZXNwb25zaXZlVGhlbWUuaGVpZ2h0WFhTLFxyXG4gICAgICAgICAgICBzZXR0aW5nczoge1xyXG4gICAgICAgICAgICAgICAgZm9yY2VIaWRkZW46IHRydWVcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGFkZFJ1bGUoe1xyXG4gICAgICAgICAgICBuYW1lOiBcIkF4aXNMYWJlbFwiLFxyXG4gICAgICAgICAgICB0YWdzOiBbXCJ4XCIsIFwibWlub3JcIl0sXHJcbiAgICAgICAgICAgIHJlbGV2YW50OiBSZXNwb25zaXZlVGhlbWUud2lkdGhYWEwsXHJcbiAgICAgICAgICAgIHNldHRpbmdzOiB7XHJcbiAgICAgICAgICAgICAgICBmb3JjZUhpZGRlbjogdHJ1ZVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgYWRkUnVsZSh7XHJcbiAgICAgICAgICAgIG5hbWU6IFwiQXhpc0xhYmVsXCIsXHJcbiAgICAgICAgICAgIHRhZ3M6IFtcInlcIl0sXHJcbiAgICAgICAgICAgIHJlbGV2YW50OiBSZXNwb25zaXZlVGhlbWUud2lkdGhYWFMsXHJcbiAgICAgICAgICAgIHNldHRpbmdzOiB7XHJcbiAgICAgICAgICAgICAgICBmb3JjZUhpZGRlbjogdHJ1ZVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgYWRkUnVsZSh7XHJcbiAgICAgICAgICAgIG5hbWU6IFwiQXhpc0xhYmVsXCIsXHJcbiAgICAgICAgICAgIHRhZ3M6IFtcInlcIiwgXCJtaW5vclwiXSxcclxuICAgICAgICAgICAgcmVsZXZhbnQ6IFJlc3BvbnNpdmVUaGVtZS5oZWlnaHRYWEwsXHJcbiAgICAgICAgICAgIHNldHRpbmdzOiB7XHJcbiAgICAgICAgICAgICAgICBmb3JjZUhpZGRlbjogdHJ1ZVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgYWRkUnVsZSh7XHJcbiAgICAgICAgICAgIG5hbWU6IFwiQXhpc1RpY2tcIixcclxuICAgICAgICAgICAgdGFnczogW1wieFwiXSxcclxuICAgICAgICAgICAgcmVsZXZhbnQ6IFJlc3BvbnNpdmVUaGVtZS5oZWlnaHRYUyxcclxuICAgICAgICAgICAgc2V0dGluZ3M6IHtcclxuICAgICAgICAgICAgICAgIGluc2lkZTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIG1pblBvc2l0aW9uOiAwLjEsXHJcbiAgICAgICAgICAgICAgICBtYXhQb3NpdGlvbjogMC45XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICBhZGRSdWxlKHtcclxuICAgICAgICAgICAgbmFtZTogXCJBeGlzVGlja1wiLFxyXG4gICAgICAgICAgICB0YWdzOiBbXCJ5XCJdLFxyXG4gICAgICAgICAgICByZWxldmFudDogUmVzcG9uc2l2ZVRoZW1lLndpZHRoWFhTLFxyXG4gICAgICAgICAgICBzZXR0aW5nczoge1xyXG4gICAgICAgICAgICAgICAgaW5zaWRlOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgbWluUG9zaXRpb246IDAuMSxcclxuICAgICAgICAgICAgICAgIG1heFBvc2l0aW9uOiAwLjlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGFkZFJ1bGUoe1xyXG4gICAgICAgICAgICBuYW1lOiBcIkdyaWRcIixcclxuICAgICAgICAgICAgcmVsZXZhbnQ6IFJlc3BvbnNpdmVUaGVtZS5tYXliZVhYUyxcclxuICAgICAgICAgICAgc2V0dGluZ3M6IHtcclxuICAgICAgICAgICAgICAgIGZvcmNlSGlkZGVuOiB0cnVlXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICAgICAgICAgKiBSYWRhclxyXG4gICAgICAgICAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGFkZFJ1bGUoe1xyXG4gICAgICAgICAgICBuYW1lOiBcIlJhZGlhbExhYmVsXCIsXHJcbiAgICAgICAgICAgIHRhZ3M6IFtcInJhZGlhbFwiXSxcclxuICAgICAgICAgICAgcmVsZXZhbnQ6IFJlc3BvbnNpdmVUaGVtZS5tYXliZVhTLFxyXG4gICAgICAgICAgICBzZXR0aW5nczoge1xyXG4gICAgICAgICAgICAgICAgZm9yY2VIaWRkZW46IHRydWVcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGFkZFJ1bGUoe1xyXG4gICAgICAgICAgICBuYW1lOiBcIlJhZGlhbExhYmVsXCIsXHJcbiAgICAgICAgICAgIHRhZ3M6IFtcImNpcmN1bGFyXCJdLFxyXG4gICAgICAgICAgICByZWxldmFudDogUmVzcG9uc2l2ZVRoZW1lLm1heWJlUyxcclxuICAgICAgICAgICAgc2V0dGluZ3M6IHtcclxuICAgICAgICAgICAgICAgIGluc2lkZTogdHJ1ZVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgYWRkUnVsZSh7XHJcbiAgICAgICAgICAgIG5hbWU6IFwiQXhpc1RpY2tcIixcclxuICAgICAgICAgICAgcmVsZXZhbnQ6IFJlc3BvbnNpdmVUaGVtZS5tYXliZVMsXHJcbiAgICAgICAgICAgIHNldHRpbmdzOiB7XHJcbiAgICAgICAgICAgICAgICBpbnNpZGU6IHRydWVcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGFkZFJ1bGUoe1xyXG4gICAgICAgICAgICBuYW1lOiBcIlJhZGlhbExhYmVsXCIsXHJcbiAgICAgICAgICAgIHRhZ3M6IFtcImNpcmN1bGFyXCJdLFxyXG4gICAgICAgICAgICByZWxldmFudDogUmVzcG9uc2l2ZVRoZW1lLm1heWJlWFMsXHJcbiAgICAgICAgICAgIHNldHRpbmdzOiB7XHJcbiAgICAgICAgICAgICAgICBmb3JjZUhpZGRlbjogdHJ1ZVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgYWRkUnVsZSh7XHJcbiAgICAgICAgICAgIG5hbWU6IFwiQXhpc1RpY2tcIixcclxuICAgICAgICAgICAgdGFnczogW1wiY2lyY3VsYXJcIl0sXHJcbiAgICAgICAgICAgIHJlbGV2YW50OiBSZXNwb25zaXZlVGhlbWUubWF5YmVYUyxcclxuICAgICAgICAgICAgc2V0dGluZ3M6IHtcclxuICAgICAgICAgICAgICAgIGluc2lkZTogdHJ1ZVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAgICAgICAgICogUGllXHJcbiAgICAgICAgICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgYWRkUnVsZSh7XHJcbiAgICAgICAgICAgIG5hbWU6IFwiUGllQ2hhcnRcIixcclxuICAgICAgICAgICAgcmVsZXZhbnQ6IFJlc3BvbnNpdmVUaGVtZS5tYXliZVhTLFxyXG4gICAgICAgICAgICBzZXR0aW5nczoge1xyXG4gICAgICAgICAgICAgICAgcmFkaXVzOiBwZXJjZW50KDk5KVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgYWRkUnVsZSh7XHJcbiAgICAgICAgICAgIG5hbWU6IFwiUGllQ2hhcnRcIixcclxuICAgICAgICAgICAgcmVsZXZhbnQ6IFJlc3BvbnNpdmVUaGVtZS53aWR0aE0sXHJcbiAgICAgICAgICAgIHNldHRpbmdzOiB7XHJcbiAgICAgICAgICAgICAgICByYWRpdXM6IHBlcmNlbnQoOTkpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICBhZGRSdWxlKHtcclxuICAgICAgICAgICAgbmFtZTogXCJSYWRpYWxMYWJlbFwiLFxyXG4gICAgICAgICAgICB0YWdzOiBbXCJwaWVcIl0sXHJcbiAgICAgICAgICAgIHJlbGV2YW50OiBSZXNwb25zaXZlVGhlbWUubWF5YmVYUyxcclxuICAgICAgICAgICAgc2V0dGluZ3M6IHtcclxuICAgICAgICAgICAgICAgIGZvcmNlSGlkZGVuOiB0cnVlXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICBhZGRSdWxlKHtcclxuICAgICAgICAgICAgbmFtZTogXCJSYWRpYWxMYWJlbFwiLFxyXG4gICAgICAgICAgICB0YWdzOiBbXCJwaWVcIl0sXHJcbiAgICAgICAgICAgIHJlbGV2YW50OiBSZXNwb25zaXZlVGhlbWUud2lkdGhNLFxyXG4gICAgICAgICAgICBzZXR0aW5nczoge1xyXG4gICAgICAgICAgICAgICAgZm9yY2VIaWRkZW46IHRydWVcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGFkZFJ1bGUoe1xyXG4gICAgICAgICAgICBuYW1lOiBcIlRpY2tcIixcclxuICAgICAgICAgICAgdGFnczogW1wicGllXCJdLFxyXG4gICAgICAgICAgICByZWxldmFudDogUmVzcG9uc2l2ZVRoZW1lLm1heWJlWFMsXHJcbiAgICAgICAgICAgIHNldHRpbmdzOiB7XHJcbiAgICAgICAgICAgICAgICBmb3JjZUhpZGRlbjogdHJ1ZVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgYWRkUnVsZSh7XHJcbiAgICAgICAgICAgIG5hbWU6IFwiVGlja1wiLFxyXG4gICAgICAgICAgICB0YWdzOiBbXCJwaWVcIl0sXHJcbiAgICAgICAgICAgIHJlbGV2YW50OiBSZXNwb25zaXZlVGhlbWUud2lkdGhNLFxyXG4gICAgICAgICAgICBzZXR0aW5nczoge1xyXG4gICAgICAgICAgICAgICAgZm9yY2VIaWRkZW46IHRydWVcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4gICAgICAgICAqIEZ1bm5lbFxyXG4gICAgICAgICAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGFkZFJ1bGUoe1xyXG4gICAgICAgICAgICBuYW1lOiBcIkZ1bm5lbFNlcmllc1wiLFxyXG4gICAgICAgICAgICByZWxldmFudDogUmVzcG9uc2l2ZVRoZW1lLndpZHRoTSxcclxuICAgICAgICAgICAgc2V0dGluZ3M6IHtcclxuICAgICAgICAgICAgICAgIGFsaWduTGFiZWxzOiBmYWxzZVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgYWRkUnVsZSh7XHJcbiAgICAgICAgICAgIG5hbWU6IFwiTGFiZWxcIixcclxuICAgICAgICAgICAgdGFnczogW1wiZnVubmVsXCIsIFwidmVydGljYWxcIl0sXHJcbiAgICAgICAgICAgIHJlbGV2YW50OiBSZXNwb25zaXZlVGhlbWUud2lkdGhMLFxyXG4gICAgICAgICAgICBzZXR0aW5nczoge1xyXG4gICAgICAgICAgICAgICAgZm9yY2VIaWRkZW46IHRydWVcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGFkZFJ1bGUoe1xyXG4gICAgICAgICAgICBuYW1lOiBcIlRpY2tcIixcclxuICAgICAgICAgICAgdGFnczogW1wiZnVubmVsXCIsIFwidmVydGljYWxcIl0sXHJcbiAgICAgICAgICAgIHJlbGV2YW50OiBSZXNwb25zaXZlVGhlbWUud2lkdGhMLFxyXG4gICAgICAgICAgICBzZXR0aW5nczoge1xyXG4gICAgICAgICAgICAgICAgZm9yY2VIaWRkZW46IHRydWVcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGFkZFJ1bGUoe1xyXG4gICAgICAgICAgICBuYW1lOiBcIkxhYmVsXCIsXHJcbiAgICAgICAgICAgIHRhZ3M6IFtcImZ1bm5lbFwiLCBcImhvcml6b250YWxcIl0sXHJcbiAgICAgICAgICAgIHJlbGV2YW50OiBSZXNwb25zaXZlVGhlbWUuaGVpZ2h0UyxcclxuICAgICAgICAgICAgc2V0dGluZ3M6IHtcclxuICAgICAgICAgICAgICAgIGZvcmNlSGlkZGVuOiB0cnVlXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICBhZGRSdWxlKHtcclxuICAgICAgICAgICAgbmFtZTogXCJUaWNrXCIsXHJcbiAgICAgICAgICAgIHRhZ3M6IFtcImZ1bm5lbFwiLCBcImhvcml6b250YWxcIl0sXHJcbiAgICAgICAgICAgIHJlbGV2YW50OiBSZXNwb25zaXZlVGhlbWUuaGVpZ2h0UyxcclxuICAgICAgICAgICAgc2V0dGluZ3M6IHtcclxuICAgICAgICAgICAgICAgIGZvcmNlSGlkZGVuOiB0cnVlXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICAgICAgICAgKiBQeXJhbWlkXHJcbiAgICAgICAgICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgYWRkUnVsZSh7XHJcbiAgICAgICAgICAgIG5hbWU6IFwiUHlyYW1pZFNlcmllc1wiLFxyXG4gICAgICAgICAgICByZWxldmFudDogUmVzcG9uc2l2ZVRoZW1lLndpZHRoTSxcclxuICAgICAgICAgICAgc2V0dGluZ3M6IHtcclxuICAgICAgICAgICAgICAgIGFsaWduTGFiZWxzOiBmYWxzZVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgYWRkUnVsZSh7XHJcbiAgICAgICAgICAgIG5hbWU6IFwiTGFiZWxcIixcclxuICAgICAgICAgICAgdGFnczogW1wicHlyYW1pZFwiLCBcInZlcnRpY2FsXCJdLFxyXG4gICAgICAgICAgICByZWxldmFudDogUmVzcG9uc2l2ZVRoZW1lLndpZHRoTCxcclxuICAgICAgICAgICAgc2V0dGluZ3M6IHtcclxuICAgICAgICAgICAgICAgIGZvcmNlSGlkZGVuOiB0cnVlXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICBhZGRSdWxlKHtcclxuICAgICAgICAgICAgbmFtZTogXCJUaWNrXCIsXHJcbiAgICAgICAgICAgIHRhZ3M6IFtcInB5cmFtaWRcIiwgXCJ2ZXJ0aWNhbFwiXSxcclxuICAgICAgICAgICAgcmVsZXZhbnQ6IFJlc3BvbnNpdmVUaGVtZS53aWR0aEwsXHJcbiAgICAgICAgICAgIHNldHRpbmdzOiB7XHJcbiAgICAgICAgICAgICAgICBmb3JjZUhpZGRlbjogdHJ1ZVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgYWRkUnVsZSh7XHJcbiAgICAgICAgICAgIG5hbWU6IFwiTGFiZWxcIixcclxuICAgICAgICAgICAgdGFnczogW1wicHlyYW1pZFwiLCBcImhvcml6b250YWxcIl0sXHJcbiAgICAgICAgICAgIHJlbGV2YW50OiBSZXNwb25zaXZlVGhlbWUuaGVpZ2h0UyxcclxuICAgICAgICAgICAgc2V0dGluZ3M6IHtcclxuICAgICAgICAgICAgICAgIGZvcmNlSGlkZGVuOiB0cnVlXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICBhZGRSdWxlKHtcclxuICAgICAgICAgICAgbmFtZTogXCJUaWNrXCIsXHJcbiAgICAgICAgICAgIHRhZ3M6IFtcInB5cmFtaWRcIiwgXCJob3Jpem9udGFsXCJdLFxyXG4gICAgICAgICAgICByZWxldmFudDogUmVzcG9uc2l2ZVRoZW1lLmhlaWdodFMsXHJcbiAgICAgICAgICAgIHNldHRpbmdzOiB7XHJcbiAgICAgICAgICAgICAgICBmb3JjZUhpZGRlbjogdHJ1ZVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAgICAgICAgICogUGljdG9yaWFsXHJcbiAgICAgICAgICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgYWRkUnVsZSh7XHJcbiAgICAgICAgICAgIG5hbWU6IFwiUGljdG9yaWFsU3RhY2tlZFNlcmllc1wiLFxyXG4gICAgICAgICAgICByZWxldmFudDogUmVzcG9uc2l2ZVRoZW1lLndpZHRoTSxcclxuICAgICAgICAgICAgc2V0dGluZ3M6IHtcclxuICAgICAgICAgICAgICAgIGFsaWduTGFiZWxzOiBmYWxzZVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgYWRkUnVsZSh7XHJcbiAgICAgICAgICAgIG5hbWU6IFwiTGFiZWxcIixcclxuICAgICAgICAgICAgdGFnczogW1wicGljdG9yaWFsXCIsIFwidmVydGljYWxcIl0sXHJcbiAgICAgICAgICAgIHJlbGV2YW50OiBSZXNwb25zaXZlVGhlbWUud2lkdGhMLFxyXG4gICAgICAgICAgICBzZXR0aW5nczoge1xyXG4gICAgICAgICAgICAgICAgZm9yY2VIaWRkZW46IHRydWVcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGFkZFJ1bGUoe1xyXG4gICAgICAgICAgICBuYW1lOiBcIlRpY2tcIixcclxuICAgICAgICAgICAgdGFnczogW1wicGljdG9yaWFsXCIsIFwidmVydGljYWxcIl0sXHJcbiAgICAgICAgICAgIHJlbGV2YW50OiBSZXNwb25zaXZlVGhlbWUud2lkdGhMLFxyXG4gICAgICAgICAgICBzZXR0aW5nczoge1xyXG4gICAgICAgICAgICAgICAgZm9yY2VIaWRkZW46IHRydWVcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGFkZFJ1bGUoe1xyXG4gICAgICAgICAgICBuYW1lOiBcIkxhYmVsXCIsXHJcbiAgICAgICAgICAgIHRhZ3M6IFtcInBpY3RvcmlhbFwiLCBcImhvcml6b250YWxcIl0sXHJcbiAgICAgICAgICAgIHJlbGV2YW50OiBSZXNwb25zaXZlVGhlbWUuaGVpZ2h0UyxcclxuICAgICAgICAgICAgc2V0dGluZ3M6IHtcclxuICAgICAgICAgICAgICAgIGZvcmNlSGlkZGVuOiB0cnVlXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICBhZGRSdWxlKHtcclxuICAgICAgICAgICAgbmFtZTogXCJUaWNrXCIsXHJcbiAgICAgICAgICAgIHRhZ3M6IFtcInBpY3RvcmlhbFwiLCBcImhvcml6b250YWxcIl0sXHJcbiAgICAgICAgICAgIHJlbGV2YW50OiBSZXNwb25zaXZlVGhlbWUuaGVpZ2h0UyxcclxuICAgICAgICAgICAgc2V0dGluZ3M6IHtcclxuICAgICAgICAgICAgICAgIGZvcmNlSGlkZGVuOiB0cnVlXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICAgICAgICAgKiBNYXBcclxuICAgICAgICAgKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICAgICAgICAgKi9cclxuICAgICAgICAvLyBOb3RoaW5nIHRvIGRvIGhlcmVcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICAgICAgICAgKiBGbG93IChTYW5rZXkrQ2hvcmQpXHJcbiAgICAgICAgICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgYWRkUnVsZSh7XHJcbiAgICAgICAgICAgIG5hbWU6IFwiTGFiZWxcIixcclxuICAgICAgICAgICAgdGFnczogW1wiZmxvd1wiLCBcImhvcml6b250YWxcIl0sXHJcbiAgICAgICAgICAgIHJlbGV2YW50OiBSZXNwb25zaXZlVGhlbWUud2lkdGhTLFxyXG4gICAgICAgICAgICBzZXR0aW5nczoge1xyXG4gICAgICAgICAgICAgICAgZm9yY2VIaWRkZW46IHRydWVcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGFkZFJ1bGUoe1xyXG4gICAgICAgICAgICBuYW1lOiBcIkxhYmVsXCIsXHJcbiAgICAgICAgICAgIHRhZ3M6IFtcImZsb3dcIiwgXCJ2ZXJ0aWNhbFwiXSxcclxuICAgICAgICAgICAgcmVsZXZhbnQ6IFJlc3BvbnNpdmVUaGVtZS5oZWlnaHRTLFxyXG4gICAgICAgICAgICBzZXR0aW5nczoge1xyXG4gICAgICAgICAgICAgICAgZm9yY2VIaWRkZW46IHRydWVcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGFkZFJ1bGUoe1xyXG4gICAgICAgICAgICBuYW1lOiBcIkNob3JkXCIsXHJcbiAgICAgICAgICAgIHJlbGV2YW50OiBSZXNwb25zaXZlVGhlbWUubWF5YmVYUyxcclxuICAgICAgICAgICAgc2V0dGluZ3M6IHtcclxuICAgICAgICAgICAgICAgIHJhZGl1czogcGVyY2VudCg5OSlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4gICAgICAgICAqIEhpZXJhcmNoeSAoVHJlZW1hcCwgUGFydGl0aW9uLCBTdW5idXJzdCwgUGFjaywgRm9yY2VEaXJlY3RlZClcclxuICAgICAgICAgKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICAgICAgICAgKi9cclxuICAgICAgICBhZGRSdWxlKHtcclxuICAgICAgICAgICAgbmFtZTogXCJMYWJlbFwiLFxyXG4gICAgICAgICAgICB0YWdzOiBbXCJoaWVyYXJjaHlcIiwgXCJub2RlXCJdLFxyXG4gICAgICAgICAgICByZWxldmFudDogUmVzcG9uc2l2ZVRoZW1lLm1heWJlWFMsXHJcbiAgICAgICAgICAgIHNldHRpbmdzOiB7XHJcbiAgICAgICAgICAgICAgICBmb3JjZUhpZGRlbjogdHJ1ZVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn1cclxuLy8gTmFtZWQgcGl4ZWwgYnJlYWtwb2ludHNcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlc3BvbnNpdmVUaGVtZSwgXCJYWFNcIiwge1xyXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgdmFsdWU6IDEwMFxyXG59KTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlc3BvbnNpdmVUaGVtZSwgXCJYU1wiLCB7XHJcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICB2YWx1ZTogMjAwXHJcbn0pO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUmVzcG9uc2l2ZVRoZW1lLCBcIlNcIiwge1xyXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgdmFsdWU6IDMwMFxyXG59KTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlc3BvbnNpdmVUaGVtZSwgXCJNXCIsIHtcclxuICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgIHZhbHVlOiA0MDBcclxufSk7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZXNwb25zaXZlVGhlbWUsIFwiTFwiLCB7XHJcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICB2YWx1ZTogNjAwXHJcbn0pO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUmVzcG9uc2l2ZVRoZW1lLCBcIlhMXCIsIHtcclxuICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgIHZhbHVlOiA4MDBcclxufSk7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZXNwb25zaXZlVGhlbWUsIFwiWFhMXCIsIHtcclxuICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgIHZhbHVlOiAxMDAwXHJcbn0pO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1SZXNwb25zaXZlVGhlbWUuanMubWFwIiwiLyoqXHJcbiAqIGFtQ2hhcnRzIDUgbG9jYWxlXHJcbiAqXHJcbiAqIExvY2FsZTogZW5cclxuICogTGFuZ3VhZ2U6IEludGVybmF0aW9uYWwgRW5nbGlzaFxyXG4gKiBBdXRob3I6IE1hcnR5bmFzIE1hamVyaXNcclxuICpcclxuICogRm9sbG93IGluc3RydWN0aW9ucyBpbiBbb24gdGhpcyBwYWdlXShodHRwczovL3d3dy5hbWNoYXJ0cy5jb20vZG9jcy92NS90dXRvcmlhbHMvY3JlYXRpbmctdHJhbnNsYXRpb25zLykgdG8gbWFrZSBjb3JyZWN0aW9ucyBvciBhZGQgbmV3IHRyYW5zbGF0aW9ucy5cclxuICpcclxuICogLS0tXHJcbiAqIEVkaXQgYnV0IGxlYXZlIHRoZSBoZWFkZXIgc2VjdGlvbiBhYm92ZSB0aGlzIGxpbmUuIFlvdSBjYW4gcmVtb3ZlIGFueVxyXG4gKiBzdWJzZXF1ZW50IGNvbW1lbnQgc2VjdGlvbnMuXHJcbiAqIC0tLVxyXG4gKlxyXG4gKiBVc2UgdGhpcyBmaWxlIGFzIGEgdGVtcGxhdGUgdG8gY3JlYXRlIHRyYW5zbGF0aW9ucy4gTGVhdmUgdGhlIGtleSBwYXJ0IGluXHJcbiAqIEVuZ2xpc2ggaW50YWN0LiBGaWxsIHRoZSB2YWx1ZSB3aXRoIGEgdHJhbnNsYXRpb24uXHJcbiAqXHJcbiAqIEVtcHR5IHN0cmluZyBtZWFucyBubyB0cmFuc2xhdGlvbiwgc28gZGVmYXVsdCBcIkludGVybmF0aW9uYWwgRW5nbGlzaFwiXHJcbiAqIHdpbGwgYmUgdXNlZC5cclxuICpcclxuICogSWYgeW91IG5lZWQgdGhlIHRyYW5zbGF0aW9uIHRvIGxpdGVyYWxseSBiZSBhbiBlbXB0eSBzdHJpbmcsIHVzZSBgbnVsbGBcclxuICogaW5zdGVhZC5cclxuICpcclxuICogSU1QT1JUQU5UOlxyXG4gKiBXaGVuIHRyYW5zbGF0aW5nIG1ha2UgZ29vZCBlZmZvcnQgdG8ga2VlcCB0aGUgdHJhbnNsYXRpb24gbGVuZ3RoXHJcbiAqIGF0IGxlYXN0IHRoZSBzYW1lIGNoYXJ0Y291bnQgYXMgdGhlIEVuZ2xpc2gsIGVzcGVjaWFsbHkgZm9yIHNob3J0IHByb21wdHMuXHJcbiAqXHJcbiAqIEhhdmluZyBzaWduaWZpY2FudGx5IGxvbmdlciBwcm9tcHRzIG1heSBkaXN0b3J0IHRoZSBhY3R1YWwgY2hhcnRzLlxyXG4gKlxyXG4gKiBOT1RFOlxyXG4gKiBTb21lIHByb21wdHMgLSBsaWtlIG1vbnRocyBvciB3ZWVrZGF5cyAtIGNvbWUgaW4gdHdvIHZlcnNpb25zOiBmdWxsIGFuZFxyXG4gKiBzaG9ydGVuZWQuXHJcbiAqXHJcbiAqIElmIHRoZXJlJ3Mgbm8gb2ZmaWNpYWwgc2hvcnRlbmVkIHZlcnNpb24gb2YgdGhlc2UgaW4geW91ciBsYW5ndWFnZSwgYW5kIGl0XHJcbiAqIHdvdWxkIG5vdCBiZSBwb3NzaWJsZSB0byBpbnZlbnQgc3VjaCBzaG9ydCB2ZXJzaW9ucyB0aGF0IGRvbid0IHNlZW0gd2VpcmRcclxuICogdG8gbmF0aXZlIHNwZWFrZXJzIG9mIHRoYXQgbGFuZ3VhZ2UsIGZpbGwgdGhvc2Ugd2l0aCB0aGUgc2FtZSBhcyBmdWxsXHJcbiAqIHZlcnNpb24uXHJcbiAqXHJcbiAqIFBMQUNFSE9MREVSUzpcclxuICogU29tZSBwcm9tcHRzIGhhdmUgcGxhY2Vob2xkZXJzIGxpa2UgXCIlMVwiLiBUaG9zZSB3aWxsIGJlIHJlcGxhY2VkIGJ5IGFjdHVhbFxyXG4gKiB2YWx1ZXMgZHVyaW5nIHRyYW5zbGF0aW9uIGFuZCBzaG91bGQgYmUgcmV0YWluZWQgaW4gdGhlIHRyYW5zbGF0ZWQgcHJvbXB0cy5cclxuICpcclxuICogUGxhY2Vob2xkZXIgcG9zaXRpb25zIG1heSBiZSBjaGFuZ2VkIHRvIGJldHRlciBzdWl0IHN0cnVjdHVyZSBvZiB0aGVcclxuICogc2VudGVuY2UuXHJcbiAqXHJcbiAqIEZvciBleGFtcGxlIFwiRnJvbSAlMSB0byAlMlwiLCB3aGVuIGFjdHVhbGx5IHVzZWQgd2lsbCByZXBsYWNlIFwiJTFcIiB3aXRoIGFuXHJcbiAqIGFjdHVhbCB2YWx1ZSByZXByZXNlbnRpbmcgcmFuZ2Ugc3RhcnQsIGFuZCBcIiUyXCIgd2lsbCBiZSByZXBsYWNlZCBieSBlbmRcclxuICogdmFsdWUuXHJcbiAqXHJcbiAqIEUuZy4gaW4gYSBTY3JvbGxiYXIgZm9yIFZhbHVlIGF4aXMgXCJGcm9tICUxIHRvICUyXCIgd2lsbCBiZWNvbWVcclxuICogXCJGcm9tIDEwMCB0byAyMDBcIi4gWW91IG1heSB0cmFuc2xhdGUgXCJGcm9tXCIgYW5kIFwidG9cIiwgYXMgd2VsbCBhcyByZS1hcnJhbmdlXHJcbiAqIHRoZSBvcmRlciBvZiB0aGUgcHJvbXB0IGl0c2VsZiwgYnV0IG1ha2Ugc3VyZSB0aGUgXCIlMVwiIGFuZCBcIiUyXCIgcmVtYWluLCBpblxyXG4gKiBwbGFjZXMgd2hlcmUgdGhleSB3aWxsIG1ha2Ugc2Vuc2UuXHJcbiAqXHJcbiAqIFNhdmUgdGhlIGZpbGUgYXMgbGFuZ3VhZ2VfTE9DQUxFLCBpLmUuIGBlbl9HQi50c2AsIGBmcl9GUi50c2AsIGV0Yy5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICAgIFwiZmlyc3REYXlPZldlZWtcIjogMSxcclxuICAgIC8vIE51bWJlciBmb3JtYXR0aW5nIG9wdGlvbnMuXHJcbiAgICAvLyBcclxuICAgIC8vIFBsZWFzZSBjaGVjayB3aXRoIHRoZSBsb2NhbCBzdGFuZGFyZHMgd2hpY2ggc2VwYXJhdG9yIGlzIGFjY2VwdGVkIHRvIGJlXHJcbiAgICAvLyB1c2VkIGZvciBzZXBhcmF0aW5nIGRlY2ltYWxzLCBhbmQgd2hpY2ggZm9yIHRob3VzYW5kcy5cclxuICAgIFwiX2RlY2ltYWxTZXBhcmF0b3JcIjogXCIuXCIsXHJcbiAgICBcIl90aG91c2FuZFNlcGFyYXRvclwiOiBcIixcIixcclxuICAgIC8vIFBvc2l0aW9uIG9mIHRoZSBwZXJjZW50IHNpZ24gaW4gbnVtYmVyc1xyXG4gICAgXCJfcGVyY2VudFByZWZpeFwiOiBudWxsLFxyXG4gICAgXCJfcGVyY2VudFN1ZmZpeFwiOiBcIiVcIixcclxuICAgIC8vIFN1ZmZpeGVzIGZvciBudW1iZXJzXHJcbiAgICAvLyBXaGVuIGZvcm1hdHRpbmcgbnVtYmVycywgYmlnIG9yIHNtYWxsIG51bWVycyBtaWdodCBiZSByZWZvcm1hdHRlZCB0b1xyXG4gICAgLy8gc2hvcnRlciB2ZXJzaW9uLCBieSBhcHBseWluZyBhIHN1ZmZpeC5cclxuICAgIC8vIFxyXG4gICAgLy8gRm9yIGV4YW1wbGUsIDEwMDAwMDAgbWlnaHQgYmVjb21lIFwiMW1cIi5cclxuICAgIC8vIE9yIDEwMjQgbWlnaHQgYmVjb21lIFwiMUtCXCIgaWYgd2UncmUgZm9ybWF0dGluZyBieXRlIG51bWJlcnMuXHJcbiAgICAvLyBcclxuICAgIC8vIFRoaXMgc2VjdGlvbiBkZWZpbmVzIHN1Y2ggc3VmZml4ZXMgZm9yIGFsbCBzdWNoIGNhc2VzLlxyXG4gICAgXCJfYmlnX251bWJlcl9zdWZmaXhfM1wiOiBcImtcIixcclxuICAgIFwiX2JpZ19udW1iZXJfc3VmZml4XzZcIjogXCJNXCIsXHJcbiAgICBcIl9iaWdfbnVtYmVyX3N1ZmZpeF85XCI6IFwiR1wiLFxyXG4gICAgXCJfYmlnX251bWJlcl9zdWZmaXhfMTJcIjogXCJUXCIsXHJcbiAgICBcIl9iaWdfbnVtYmVyX3N1ZmZpeF8xNVwiOiBcIlBcIixcclxuICAgIFwiX2JpZ19udW1iZXJfc3VmZml4XzE4XCI6IFwiRVwiLFxyXG4gICAgXCJfYmlnX251bWJlcl9zdWZmaXhfMjFcIjogXCJaXCIsXHJcbiAgICBcIl9iaWdfbnVtYmVyX3N1ZmZpeF8yNFwiOiBcIllcIixcclxuICAgIFwiX3NtYWxsX251bWJlcl9zdWZmaXhfM1wiOiBcIm1cIixcclxuICAgIFwiX3NtYWxsX251bWJlcl9zdWZmaXhfNlwiOiBcIs68XCIsXHJcbiAgICBcIl9zbWFsbF9udW1iZXJfc3VmZml4XzlcIjogXCJuXCIsXHJcbiAgICBcIl9zbWFsbF9udW1iZXJfc3VmZml4XzEyXCI6IFwicFwiLFxyXG4gICAgXCJfc21hbGxfbnVtYmVyX3N1ZmZpeF8xNVwiOiBcImZcIixcclxuICAgIFwiX3NtYWxsX251bWJlcl9zdWZmaXhfMThcIjogXCJhXCIsXHJcbiAgICBcIl9zbWFsbF9udW1iZXJfc3VmZml4XzIxXCI6IFwielwiLFxyXG4gICAgXCJfc21hbGxfbnVtYmVyX3N1ZmZpeF8yNFwiOiBcInlcIixcclxuICAgIFwiX2J5dGVfc3VmZml4X0JcIjogXCJCXCIsXHJcbiAgICBcIl9ieXRlX3N1ZmZpeF9LQlwiOiBcIktCXCIsXHJcbiAgICBcIl9ieXRlX3N1ZmZpeF9NQlwiOiBcIk1CXCIsXHJcbiAgICBcIl9ieXRlX3N1ZmZpeF9HQlwiOiBcIkdCXCIsXHJcbiAgICBcIl9ieXRlX3N1ZmZpeF9UQlwiOiBcIlRCXCIsXHJcbiAgICBcIl9ieXRlX3N1ZmZpeF9QQlwiOiBcIlBCXCIsXHJcbiAgICAvLyBEZWZhdWx0IGRhdGUgZm9ybWF0cyBmb3IgdmFyaW91cyBwZXJpb2RzLlxyXG4gICAgLy8gXHJcbiAgICAvLyBUaGlzIHNob3VsZCByZWZsZWN0IG9mZmljaWFsIG9yIGRlIGZhY3RvIGZvcm1hdHRpbmcgdW5pdmVyc2FsbHkgYWNjZXB0ZWRcclxuICAgIC8vIGluIHRoZSBjb3VudHJ5IHRyYW5zbGF0aW9uIGlzIGJlaW5nIG1hZGUgZm9yXHJcbiAgICAvLyBBdmFpbGFibGUgZm9ybWF0IGNvZGVzIGhlcmU6XHJcbiAgICAvLyBodHRwczovL3d3dy5hbWNoYXJ0cy5jb20vZG9jcy92NS9jb25jZXB0cy9mb3JtYXR0ZXJzL2Zvcm1hdHRpbmctZGF0ZXMvI0Zvcm1hdF9jb2Rlc1xyXG4gICAgLy8gXHJcbiAgICAvLyBUaGlzIHdpbGwgYmUgdXNlZCB3aGVuIGZvcm1hdHRpbmcgZGF0ZS90aW1lIGZvciBwYXJ0aWN1bGFyIGdyYW51bGFyaXR5LFxyXG4gICAgLy8gZS5nLiBcIl9kYXRlX2hvdXJcIiB3aWxsIGJlIHNob3duIHdoZW5ldmVyIHdlIG5lZWQgdG8gc2hvdyB0aW1lIGFzIGhvdXJzLlxyXG4gICAgLy8gXHJcbiAgICAvLyBcImRhdGVcIiBpcyB1c2VkIGFzIGluIGRlZmF1bHQgZGF0ZSBmb3JtYXQgd2hlbiBzaG93aW5nIHN0YW5kYWxvbmUgZGF0ZXMuXHJcbiAgICBcIl9kYXRlXCI6IFwieXl5eS1NTS1kZFwiLFxyXG4gICAgXCJfZGF0ZV9taWxsaXNlY29uZFwiOiBcIm1tOnNzIFNTU1wiLFxyXG4gICAgXCJfZGF0ZV9taWxsaXNlY29uZF9mdWxsXCI6IFwiSEg6bW06c3MgU1NTXCIsXHJcbiAgICBcIl9kYXRlX3NlY29uZFwiOiBcIkhIOm1tOnNzXCIsXHJcbiAgICBcIl9kYXRlX3NlY29uZF9mdWxsXCI6IFwiSEg6bW06c3NcIixcclxuICAgIFwiX2RhdGVfbWludXRlXCI6IFwiSEg6bW1cIixcclxuICAgIFwiX2RhdGVfbWludXRlX2Z1bGxcIjogXCJISDptbSAtIE1NTSBkZCwgeXl5eVwiLFxyXG4gICAgXCJfZGF0ZV9ob3VyXCI6IFwiSEg6bW1cIixcclxuICAgIFwiX2RhdGVfaG91cl9mdWxsXCI6IFwiSEg6bW0gLSBNTU0gZGQsIHl5eXlcIixcclxuICAgIFwiX2RhdGVfZGF5XCI6IFwiTU1NIGRkXCIsXHJcbiAgICBcIl9kYXRlX2RheV9mdWxsXCI6IFwiTU1NIGRkLCB5eXl5XCIsXHJcbiAgICBcIl9kYXRlX3dlZWtcIjogXCJ3d1wiLFxyXG4gICAgXCJfZGF0ZV93ZWVrX2Z1bGxcIjogXCJNTU0gZGQsIHl5eXlcIixcclxuICAgIFwiX2RhdGVfbW9udGhcIjogXCJNTU1cIixcclxuICAgIFwiX2RhdGVfbW9udGhfZnVsbFwiOiBcIk1NTSwgeXl5eVwiLFxyXG4gICAgXCJfZGF0ZV95ZWFyXCI6IFwieXl5eVwiLFxyXG4gICAgLy8gRGVmYXVsdCBkdXJhdGlvbiBmb3JtYXRzIGZvciB2YXJpb3VzIGJhc2UgdW5pdHMuXHJcbiAgICAvLyBcclxuICAgIC8vIFRoaXMgd2lsbCBiZSB1c2VkIGJ5IER1cmF0aW9uRm9ybWF0dGVyIHRvIGZvcm1hdCBudW1lcmljIHZhbHVlcyBpbnRvXHJcbiAgICAvLyBkdXJhdGlvbi5cclxuICAgIC8vIFxyXG4gICAgLy8gTm90aWNlIGhvdyBlYWNoIGR1cmF0aW9uIHVuaXQgY29tZXMgaW4gc2V2ZXJhbCB2ZXJzaW9ucy4gVGhpcyBpcyB0byBlbnN1cmVcclxuICAgIC8vIHRoYXQgZWFjaCBiYXNlIHVuaXQgaXMgc2hvd24gY29ycmVjdGx5LlxyXG4gICAgLy8gXHJcbiAgICAvLyBGb3IgZXhhbXBsZSwgaWYgd2UgaGF2ZSBiYXNlVW5pdCBzZXQgdG8gXCJzZWNvbmRcIiwgbWVhbmluZyBvdXIgZHVyYXRpb24gaXNcclxuICAgIC8vIGluIHNlY29uZHMuXHJcbiAgICAvLyBcclxuICAgIC8vIElmIHdlIHBhc3MgaW4gYDUwYCB0byBmb3JtYXR0ZXIsIGl0IHdpbGwga25vdyB0aGF0IHdlIGhhdmUganVzdCA1MCBzZWNvbmRzXHJcbiAgICAvLyAobGVzcyB0aGFuIGEgbWludXRlKSBzbyBpdCB3aWxsIHVzZSBmb3JtYXQgaW4gYFwiX2R1cmF0aW9uX3NlY29uZFwiYCAoXCJzc1wiKSxcclxuICAgIC8vIGFuZCB0aGUgZm9ybWF0dGVkIHJlc3VsdCB3aWxsIGJlIGluIGxpa2UgYFwiNTBcImAuXHJcbiAgICAvLyBcclxuICAgIC8vIElmIHdlIHBhc3MgaW4gYDcwYCwgd2hpY2ggaXMgbW9yZSB0aGFuIGEgbWludXRlLCB0aGUgZm9ybWF0dGVyIHdpbGwgc3dpdGNoXHJcbiAgICAvLyB0byBgXCJfZHVyYXRpb25fc2Vjb25kX21pbnV0ZVwiYCAoXCJtbTpzc1wiKSwgcmVzdWx0aW5nIGluIFwiMDE6MTBcIiBmb3JtYXR0ZWRcclxuICAgIC8vIHRleHQuXHJcbiAgICAvLyBcclxuICAgIC8vIEF2YWlsYWJsZSBjb2RlcyBoZXJlOlxyXG4gICAgLy8gaHR0cHM6Ly93d3cuYW1jaGFydHMuY29tL2RvY3MvdjQvY29uY2VwdHMvZm9ybWF0dGVycy9mb3JtYXR0aW5nLWR1cmF0aW9uLyNBdmFpbGFibGVfQ29kZXNcclxuICAgIFwiX2R1cmF0aW9uX21pbGxpc2Vjb25kXCI6IFwiU1NTXCIsXHJcbiAgICBcIl9kdXJhdGlvbl9taWxsaXNlY29uZF9zZWNvbmRcIjogXCJzcy5TU1NcIixcclxuICAgIFwiX2R1cmF0aW9uX21pbGxpc2Vjb25kX21pbnV0ZVwiOiBcIm1tOnNzIFNTU1wiLFxyXG4gICAgXCJfZHVyYXRpb25fbWlsbGlzZWNvbmRfaG91clwiOiBcImhoOm1tOnNzIFNTU1wiLFxyXG4gICAgXCJfZHVyYXRpb25fbWlsbGlzZWNvbmRfZGF5XCI6IFwiZCdkJyBtbTpzcyBTU1NcIixcclxuICAgIFwiX2R1cmF0aW9uX21pbGxpc2Vjb25kX3dlZWtcIjogXCJkJ2QnIG1tOnNzIFNTU1wiLFxyXG4gICAgXCJfZHVyYXRpb25fbWlsbGlzZWNvbmRfbW9udGhcIjogXCJNJ20nIGRkJ2QnIG1tOnNzIFNTU1wiLFxyXG4gICAgXCJfZHVyYXRpb25fbWlsbGlzZWNvbmRfeWVhclwiOiBcInkneScgTU0nbScgZGQnZCcgbW06c3MgU1NTXCIsXHJcbiAgICBcIl9kdXJhdGlvbl9zZWNvbmRcIjogXCJzc1wiLFxyXG4gICAgXCJfZHVyYXRpb25fc2Vjb25kX21pbnV0ZVwiOiBcIm1tOnNzXCIsXHJcbiAgICBcIl9kdXJhdGlvbl9zZWNvbmRfaG91clwiOiBcImhoOm1tOnNzXCIsXHJcbiAgICBcIl9kdXJhdGlvbl9zZWNvbmRfZGF5XCI6IFwiZCdkJyBoaDptbTpzc1wiLFxyXG4gICAgXCJfZHVyYXRpb25fc2Vjb25kX3dlZWtcIjogXCJkJ2QnIGhoOm1tOnNzXCIsXHJcbiAgICBcIl9kdXJhdGlvbl9zZWNvbmRfbW9udGhcIjogXCJNJ20nIGRkJ2QnIGhoOm1tOnNzXCIsXHJcbiAgICBcIl9kdXJhdGlvbl9zZWNvbmRfeWVhclwiOiBcInkneScgTU0nbScgZGQnZCcgaGg6bW06c3NcIixcclxuICAgIFwiX2R1cmF0aW9uX21pbnV0ZVwiOiBcIm1tXCIsXHJcbiAgICBcIl9kdXJhdGlvbl9taW51dGVfaG91clwiOiBcImhoOm1tXCIsXHJcbiAgICBcIl9kdXJhdGlvbl9taW51dGVfZGF5XCI6IFwiZCdkJyBoaDptbVwiLFxyXG4gICAgXCJfZHVyYXRpb25fbWludXRlX3dlZWtcIjogXCJkJ2QnIGhoOm1tXCIsXHJcbiAgICBcIl9kdXJhdGlvbl9taW51dGVfbW9udGhcIjogXCJNJ20nIGRkJ2QnIGhoOm1tXCIsXHJcbiAgICBcIl9kdXJhdGlvbl9taW51dGVfeWVhclwiOiBcInkneScgTU0nbScgZGQnZCcgaGg6bW1cIixcclxuICAgIFwiX2R1cmF0aW9uX2hvdXJcIjogXCJoaCdoJ1wiLFxyXG4gICAgXCJfZHVyYXRpb25faG91cl9kYXlcIjogXCJkJ2QnIGhoJ2gnXCIsXHJcbiAgICBcIl9kdXJhdGlvbl9ob3VyX3dlZWtcIjogXCJkJ2QnIGhoJ2gnXCIsXHJcbiAgICBcIl9kdXJhdGlvbl9ob3VyX21vbnRoXCI6IFwiTSdtJyBkZCdkJyBoaCdoJ1wiLFxyXG4gICAgXCJfZHVyYXRpb25faG91cl95ZWFyXCI6IFwieSd5JyBNTSdtJyBkZCdkJyBoaCdoJ1wiLFxyXG4gICAgXCJfZHVyYXRpb25fZGF5XCI6IFwiZCdkJ1wiLFxyXG4gICAgXCJfZHVyYXRpb25fZGF5X3dlZWtcIjogXCJkJ2QnXCIsXHJcbiAgICBcIl9kdXJhdGlvbl9kYXlfbW9udGhcIjogXCJNJ20nIGRkJ2QnXCIsXHJcbiAgICBcIl9kdXJhdGlvbl9kYXlfeWVhclwiOiBcInkneScgTU0nbScgZGQnZCdcIixcclxuICAgIFwiX2R1cmF0aW9uX3dlZWtcIjogXCJ3J3cnXCIsXHJcbiAgICBcIl9kdXJhdGlvbl93ZWVrX21vbnRoXCI6IFwidyd3J1wiLFxyXG4gICAgXCJfZHVyYXRpb25fd2Vla195ZWFyXCI6IFwidyd3J1wiLFxyXG4gICAgXCJfZHVyYXRpb25fbW9udGhcIjogXCJNJ20nXCIsXHJcbiAgICBcIl9kdXJhdGlvbl9tb250aF95ZWFyXCI6IFwieSd5JyBNTSdtJ1wiLFxyXG4gICAgXCJfZHVyYXRpb25feWVhclwiOiBcInkneSdcIixcclxuICAgIC8vIEVyYSB0cmFuc2xhdGlvbnNcclxuICAgIFwiX2VyYV9hZFwiOiBcIkFEXCIsXHJcbiAgICBcIl9lcmFfYmNcIjogXCJCQ1wiLFxyXG4gICAgLy8gRGF5IHBhcnQsIHVzZWQgaW4gMTItaG91ciBmb3JtYXRzLCBlLmcuIDUgUC5NLlxyXG4gICAgLy8gUGxlYXNlIG5vdGUgdGhhdCB0aGVzZSBjb21lIGluIDMgdmFyaWFudHM6XHJcbiAgICAvLyAqIG9uZSBsZXR0ZXIgKGUuZy4gXCJBXCIpXHJcbiAgICAvLyAqIHR3byBsZXR0ZXJzIChlLmcuIFwiQU1cIilcclxuICAgIC8vICogdHdvIGxldHRlcnMgd2l0aCBkb3RzIChlLmcuIFwiQS5NLlwiKVxyXG4gICAgLy8gXHJcbiAgICAvLyBBbGwgdGhyZWUgbmVlZCB0byB0byBiZSB0cmFuc2xhdGVkIGV2ZW4gaWYgdGhleSBhcmUgYWxsIHRoZSBzYW1lLiBTb21lXHJcbiAgICAvLyB1c2VycyBtaWdodCB1c2Ugb25lLCBzb21lIHRoZSBvdGhlci5cclxuICAgIFwiQVwiOiBcIlwiLFxyXG4gICAgXCJQXCI6IFwiXCIsXHJcbiAgICBcIkFNXCI6IFwiXCIsXHJcbiAgICBcIlBNXCI6IFwiXCIsXHJcbiAgICBcIkEuTS5cIjogXCJcIixcclxuICAgIFwiUC5NLlwiOiBcIlwiLFxyXG4gICAgLy8gRGF0ZS1yZWxhdGVkIHN0dWZmLlxyXG4gICAgLy8gXHJcbiAgICAvLyBXaGVuIHRyYW5zbGF0aW5nIG1vbnRocywgaWYgdGhlcmUncyBhIGRpZmZlcmVuY2UsIHVzZSB0aGUgZm9ybSB3aGljaCBpc1xyXG4gICAgLy8gYmVzdCBmb3IgYSBmdWxsIGRhdGUsIGUuZy4gYXMgeW91IHdvdWxkIHVzZSBpdCBpbiBcIjIwMTggSmFudWFyeSAxXCIuXHJcbiAgICAvLyBcclxuICAgIC8vIE5vdGUgdGhhdCBNYXkgaXMgbGlzdGVkIHR3aWNlLiBUaGlzIGlzIGJlY2F1c2UgaW4gRW5nbGlzaCBNYXkgaXMgdGhlIHNhbWVcclxuICAgIC8vIGluIGJvdGggbG9uZyBhbmQgc2hvcnQgZm9ybXMsIHdoaWxlIGluIG90aGVyIGxhbmd1YWdlcyBpdCBtYXkgbm90IGJlIHRoZVxyXG4gICAgLy8gY2FzZS4gVHJhbnNsYXRlIFwiTWF5XCIgdG8gZnVsbCB3b3JkLCB3aGlsZSBcIk1heShzaG9ydClcIiB0byBzaG9ydGVuZWRcclxuICAgIC8vIHZlcnNpb24uXHJcbiAgICAvLyBcclxuICAgIC8vIFNob3VsZCBtb250aCBuYW1lcyBhbmQgd2Vla2RheXMgYmUgY2FwaXRhbGl6ZWQgb3Igbm90P1xyXG4gICAgLy8gXHJcbiAgICAvLyBSdWxlIG9mIHRodW1iIGlzIHRoaXM6IGlmIHRoZSBuYW1lcyBzaG91bGQgYWx3YXlzIGJlIGNhcGl0YWxpemVkLFxyXG4gICAgLy8gcmVnYXJkbGVzcyBvZiBuYW1lIHBvc2l0aW9uIHdpdGhpbiBkYXRlIChcIkphbnVhcnlcIiwgXCIyMXN0IEphbnVhcnkgMjAxOFwiLFxyXG4gICAgLy8gZXRjLikgdXNlIGNhcGl0YWxpemVkIG5hbWVzLiBPdGhlcndpc2UgZW50ZXIgYWxsIGxvd2VyY2FzZS5cclxuICAgIC8vIFxyXG4gICAgLy8gVGhlIGRhdGUgZm9ybWF0dGVyIHdpbGwgYXV0b21hdGljYWxseSBjYXBpdGFsaXplIG5hbWVzIGlmIHRoZXkgYXJlIHRoZVxyXG4gICAgLy8gZmlyc3QgKG9yIG9ubHkpIHdvcmQgaW4gcmVzdWx0aW5nIGRhdGUuXHJcbiAgICBcIkphbnVhcnlcIjogXCJcIixcclxuICAgIFwiRmVicnVhcnlcIjogXCJcIixcclxuICAgIFwiTWFyY2hcIjogXCJcIixcclxuICAgIFwiQXByaWxcIjogXCJcIixcclxuICAgIFwiTWF5XCI6IFwiXCIsXHJcbiAgICBcIkp1bmVcIjogXCJcIixcclxuICAgIFwiSnVseVwiOiBcIlwiLFxyXG4gICAgXCJBdWd1c3RcIjogXCJcIixcclxuICAgIFwiU2VwdGVtYmVyXCI6IFwiXCIsXHJcbiAgICBcIk9jdG9iZXJcIjogXCJcIixcclxuICAgIFwiTm92ZW1iZXJcIjogXCJcIixcclxuICAgIFwiRGVjZW1iZXJcIjogXCJcIixcclxuICAgIFwiSmFuXCI6IFwiXCIsXHJcbiAgICBcIkZlYlwiOiBcIlwiLFxyXG4gICAgXCJNYXJcIjogXCJcIixcclxuICAgIFwiQXByXCI6IFwiXCIsXHJcbiAgICBcIk1heShzaG9ydClcIjogXCJNYXlcIixcclxuICAgIFwiSnVuXCI6IFwiXCIsXHJcbiAgICBcIkp1bFwiOiBcIlwiLFxyXG4gICAgXCJBdWdcIjogXCJcIixcclxuICAgIFwiU2VwXCI6IFwiXCIsXHJcbiAgICBcIk9jdFwiOiBcIlwiLFxyXG4gICAgXCJOb3ZcIjogXCJcIixcclxuICAgIFwiRGVjXCI6IFwiXCIsXHJcbiAgICAvLyBXZWVrZGF5cy5cclxuICAgIFwiU3VuZGF5XCI6IFwiXCIsXHJcbiAgICBcIk1vbmRheVwiOiBcIlwiLFxyXG4gICAgXCJUdWVzZGF5XCI6IFwiXCIsXHJcbiAgICBcIldlZG5lc2RheVwiOiBcIlwiLFxyXG4gICAgXCJUaHVyc2RheVwiOiBcIlwiLFxyXG4gICAgXCJGcmlkYXlcIjogXCJcIixcclxuICAgIFwiU2F0dXJkYXlcIjogXCJcIixcclxuICAgIFwiU3VuXCI6IFwiXCIsXHJcbiAgICBcIk1vblwiOiBcIlwiLFxyXG4gICAgXCJUdWVcIjogXCJcIixcclxuICAgIFwiV2VkXCI6IFwiXCIsXHJcbiAgICBcIlRodVwiOiBcIlwiLFxyXG4gICAgXCJGcmlcIjogXCJcIixcclxuICAgIFwiU2F0XCI6IFwiXCIsXHJcbiAgICAvLyBEYXRlIG9yZGluYWwgZnVuY3Rpb24uXHJcbiAgICAvLyBcclxuICAgIC8vIFRoaXMgaXMgdXNlZCB3aGVuIGFkZGluZyBudW1iZXIgb3JkaW5hbCB3aGVuIGZvcm1hdHRpbmcgZGF5cyBpbiBkYXRlcy5cclxuICAgIC8vIFxyXG4gICAgLy8gRS5nLiBcIkphbnVhcnkgMXN0XCIsIFwiRmVicnVhcnkgMm5kXCIuXHJcbiAgICAvLyBcclxuICAgIC8vIFRoZSBmdW5jdGlvbiBhY2NlcHRzIGRheSBudW1iZXIsIGFuZCByZXR1cm5zIGEgc3RyaW5nIHRvIGJlIGFkZGVkIHRvIHRoZVxyXG4gICAgLy8gZGF5LCBsaWtlIGluIGRlZmF1bHQgRW5nbGlzaCB0cmFuc2xhdGlvbiwgaWYgd2UgcGFzcyBpbiAyLCB3ZSB3aWxsIHJlY2VpdmVcclxuICAgIC8vIFwibmRcIiBiYWNrLlxyXG4gICAgXCJfZGF0ZU9yZFwiOiBmdW5jdGlvbiAoZGF5KSB7XHJcbiAgICAgICAgbGV0IHJlcyA9IFwidGhcIjtcclxuICAgICAgICBpZiAoKGRheSA8IDExKSB8fCAoZGF5ID4gMTMpKSB7XHJcbiAgICAgICAgICAgIHN3aXRjaCAoZGF5ICUgMTApIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgICAgICByZXMgPSBcInN0XCI7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzID0gXCJuZFwiO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAzOlxyXG4gICAgICAgICAgICAgICAgICAgIHJlcyA9IFwicmRcIjtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgfSxcclxuICAgIC8vIFZhcmlvdXMgY2hhcnQgY29udHJvbHMuXHJcbiAgICAvLyBTaG93biBhcyBhIHRvb2x0aXAgb24gem9vbSBvdXQgYnV0dG9uLlxyXG4gICAgXCJab29tIE91dFwiOiBcIlwiLFxyXG4gICAgLy8gVGltZWxpbmUgYnV0dG9uc1xyXG4gICAgXCJQbGF5XCI6IFwiXCIsXHJcbiAgICBcIlN0b3BcIjogXCJcIixcclxuICAgIC8vIENoYXJ0J3MgTGVnZW5kIHNjcmVlbiByZWFkZXIgdGl0bGUuXHJcbiAgICBcIkxlZ2VuZFwiOiBcIlwiLFxyXG4gICAgLy8gTGVnZW5kJ3MgaXRlbSBzY3JlZW4gcmVhZGVyIGluZGljYXRvci5cclxuICAgIFwiUHJlc3MgRU5URVIgdG8gdG9nZ2xlXCI6IFwiXCIsXHJcbiAgICAvLyBTaG93biB3aGVuIHRoZSBjaGFydCBpcyBidXN5IGxvYWRpbmcgc29tZXRoaW5nLlxyXG4gICAgXCJMb2FkaW5nXCI6IFwiXCIsXHJcbiAgICAvLyBTaG93biBhcyB0aGUgZmlyc3QgYnV0dG9uIGluIHRoZSBicmVhZGNydW1iIG5hdmlnYXRpb24sIGUuZy46XHJcbiAgICAvLyBIb21lID4gRmlyc3QgbGV2ZWwgPiAuLi5cclxuICAgIFwiSG9tZVwiOiBcIlwiLFxyXG4gICAgLy8gQ2hhcnQgdHlwZXMuXHJcbiAgICAvLyBUaG9zZSBhcmUgdXNlZCBhcyBkZWZhdWx0IHNjcmVlbiByZWFkZXIgdGl0bGVzIGZvciB0aGUgbWFpbiBjaGFydCBlbGVtZW50XHJcbiAgICAvLyB1bmxlc3MgZGV2ZWxvcGVyIGhhcyBzZXQgc29tZSBtb3JlIGRlc2NyaXB0aXZlIHRpdGxlLlxyXG4gICAgXCJDaGFydFwiOiBcIlwiLFxyXG4gICAgXCJTZXJpYWwgY2hhcnRcIjogXCJcIixcclxuICAgIFwiWC9ZIGNoYXJ0XCI6IFwiXCIsXHJcbiAgICBcIlBpZSBjaGFydFwiOiBcIlwiLFxyXG4gICAgXCJHYXVnZSBjaGFydFwiOiBcIlwiLFxyXG4gICAgXCJSYWRhciBjaGFydFwiOiBcIlwiLFxyXG4gICAgXCJTYW5rZXkgZGlhZ3JhbVwiOiBcIlwiLFxyXG4gICAgXCJGbG93IGRpYWdyYW1cIjogXCJcIixcclxuICAgIFwiQ2hvcmQgZGlhZ3JhbVwiOiBcIlwiLFxyXG4gICAgXCJUcmVlTWFwIGNoYXJ0XCI6IFwiXCIsXHJcbiAgICBcIkZvcmNlIGRpcmVjdGVkIHRyZWVcIjogXCJcIixcclxuICAgIFwiU2xpY2VkIGNoYXJ0XCI6IFwiXCIsXHJcbiAgICAvLyBTZXJpZXMgdHlwZXMuXHJcbiAgICAvLyBVc2VkIHRvIG5hbWUgc2VyaWVzIGJ5IHR5cGUgZm9yIHNjcmVlbiByZWFkZXJzIGlmIHRoZXkgZG8gbm90IGhhdmUgdGhlaXJcclxuICAgIC8vIG5hbWUgc2V0LlxyXG4gICAgXCJTZXJpZXNcIjogXCJcIixcclxuICAgIFwiQ2FuZGxlc3RpY2sgU2VyaWVzXCI6IFwiXCIsXHJcbiAgICBcIk9ITEMgU2VyaWVzXCI6IFwiXCIsXHJcbiAgICBcIkNvbHVtbiBTZXJpZXNcIjogXCJcIixcclxuICAgIFwiTGluZSBTZXJpZXNcIjogXCJcIixcclxuICAgIFwiUGllIFNsaWNlIFNlcmllc1wiOiBcIlwiLFxyXG4gICAgXCJGdW5uZWwgU2VyaWVzXCI6IFwiXCIsXHJcbiAgICBcIlB5cmFtaWQgU2VyaWVzXCI6IFwiXCIsXHJcbiAgICBcIlgvWSBTZXJpZXNcIjogXCJcIixcclxuICAgIC8vIE1hcC1yZWxhdGVkIHN0dWZmLlxyXG4gICAgXCJNYXBcIjogXCJcIixcclxuICAgIFwiUHJlc3MgRU5URVIgdG8gem9vbSBpblwiOiBcIlwiLFxyXG4gICAgXCJQcmVzcyBFTlRFUiB0byB6b29tIG91dFwiOiBcIlwiLFxyXG4gICAgXCJVc2UgYXJyb3cga2V5cyB0byB6b29tIGluIGFuZCBvdXRcIjogXCJcIixcclxuICAgIFwiVXNlIHBsdXMgYW5kIG1pbnVzIGtleXMgb24geW91ciBrZXlib2FyZCB0byB6b29tIGluIGFuZCBvdXRcIjogXCJcIixcclxuICAgIC8vIEV4cG9ydC1yZWxhdGVkIHN0dWZmLlxyXG4gICAgLy8gVGhlc2UgcHJvbXB0cyBhcmUgdXNlZCBpbiBFeHBvcnQgbWVudSBsYWJlbHMuXHJcbiAgICAvLyBcclxuICAgIC8vIFwiRXhwb3J0XCIgaXMgdGhlIHRvcC1sZXZlbCBtZW51IGl0ZW0uXHJcbiAgICAvLyBcclxuICAgIC8vIFwiSW1hZ2VcIiwgXCJEYXRhXCIsIFwiUHJpbnRcIiBhcyBzZWNvbmQtbGV2ZWwgaW5kaWNhdGluZyB0eXBlIG9mIGV4cG9ydFxyXG4gICAgLy8gb3BlcmF0aW9uLlxyXG4gICAgLy8gXHJcbiAgICAvLyBMZWF2ZSBhY3R1YWwgZm9ybWF0IHVudHJhbnNsYXRlZCwgdW5sZXNzIHlvdSBhYnNvbHV0ZWx5IGtub3cgdGhhdCB0aGV5XHJcbiAgICAvLyB3b3VsZCBjb252ZXkgbW9yZSBtZWFuaW5nIGluIHNvbWUgb3RoZXIgd2F5LlxyXG4gICAgXCJFeHBvcnRcIjogXCJcIixcclxuICAgIFwiSW1hZ2VcIjogXCJcIixcclxuICAgIFwiRGF0YVwiOiBcIlwiLFxyXG4gICAgXCJQcmludFwiOiBcIlwiLFxyXG4gICAgXCJQcmVzcyBFTlRFUiBvciB1c2UgYXJyb3cga2V5cyB0byBuYXZpZ2F0ZVwiOiBcIlwiLFxyXG4gICAgXCJQcmVzcyBFTlRFUiB0byBvcGVuXCI6IFwiXCIsXHJcbiAgICBcIlByZXNzIEVOVEVSIHRvIHByaW50LlwiOiBcIlwiLFxyXG4gICAgXCJQcmVzcyBFTlRFUiB0byBleHBvcnQgYXMgJTEuXCI6IFwiXCIsXHJcbiAgICBcIihQcmVzcyBFU0MgdG8gY2xvc2UgdGhpcyBtZXNzYWdlKVwiOiBcIlwiLFxyXG4gICAgXCJJbWFnZSBFeHBvcnQgQ29tcGxldGVcIjogXCJcIixcclxuICAgIFwiRXhwb3J0IG9wZXJhdGlvbiB0b29rIGxvbmdlciB0aGFuIGV4cGVjdGVkLiBTb21ldGhpbmcgbWlnaHQgaGF2ZSBnb25lIHdyb25nLlwiOiBcIlwiLFxyXG4gICAgXCJTYXZlZCBmcm9tXCI6IFwiXCIsXHJcbiAgICBcIlBOR1wiOiBcIlwiLFxyXG4gICAgXCJKUEdcIjogXCJcIixcclxuICAgIFwiR0lGXCI6IFwiXCIsXHJcbiAgICBcIlNWR1wiOiBcIlwiLFxyXG4gICAgXCJQREZcIjogXCJcIixcclxuICAgIFwiSlNPTlwiOiBcIlwiLFxyXG4gICAgXCJDU1ZcIjogXCJcIixcclxuICAgIFwiWExTWFwiOiBcIlwiLFxyXG4gICAgXCJIVE1MXCI6IFwiXCIsXHJcbiAgICAvLyBTY3JvbGxiYXItcmVsYXRlZCBzdHVmZi5cclxuICAgIC8vIFxyXG4gICAgLy8gU2Nyb2xsYmFyIGlzIGEgY29udHJvbCB3aGljaCBjYW4gem9vbSBhbmQgcGFuIHRoZSBheGVzIG9uIHRoZSBjaGFydC5cclxuICAgIC8vIFxyXG4gICAgLy8gRWFjaCBzY3JvbGxiYXIgaGFzIHR3byBncmlwczogbGVmdCBvciByaWdodCAoZm9yIGhvcml6b250YWwgc2Nyb2xsYmFyKSBvclxyXG4gICAgLy8gdXBwZXIgYW5kIGxvd2VyIChmb3IgdmVydGljYWwgb25lKS5cclxuICAgIC8vIFxyXG4gICAgLy8gUHJvbXB0cyBjaGFuZ2UgaW4gcmVsYXRpb24gdG8gd2hldGhlciBTY3JvbGxiYXIgaXMgdmVydGljYWwgb3IgaG9yaXpvbnRhbC5cclxuICAgIC8vIFxyXG4gICAgLy8gVGhlIGZpbmFsIHNlY3Rpb24gaXMgdXNlZCB0byBpbmRpY2F0ZSB0aGUgY3VycmVudCByYW5nZSBvZiBzZWxlY3Rpb24uXHJcbiAgICBcIlVzZSBUQUIgdG8gc2VsZWN0IGdyaXAgYnV0dG9ucyBvciBsZWZ0IGFuZCByaWdodCBhcnJvd3MgdG8gY2hhbmdlIHNlbGVjdGlvblwiOiBcIlwiLFxyXG4gICAgXCJVc2UgbGVmdCBhbmQgcmlnaHQgYXJyb3dzIHRvIG1vdmUgc2VsZWN0aW9uXCI6IFwiXCIsXHJcbiAgICBcIlVzZSBsZWZ0IGFuZCByaWdodCBhcnJvd3MgdG8gbW92ZSBsZWZ0IHNlbGVjdGlvblwiOiBcIlwiLFxyXG4gICAgXCJVc2UgbGVmdCBhbmQgcmlnaHQgYXJyb3dzIHRvIG1vdmUgcmlnaHQgc2VsZWN0aW9uXCI6IFwiXCIsXHJcbiAgICBcIlVzZSBUQUIgc2VsZWN0IGdyaXAgYnV0dG9ucyBvciB1cCBhbmQgZG93biBhcnJvd3MgdG8gY2hhbmdlIHNlbGVjdGlvblwiOiBcIlwiLFxyXG4gICAgXCJVc2UgdXAgYW5kIGRvd24gYXJyb3dzIHRvIG1vdmUgc2VsZWN0aW9uXCI6IFwiXCIsXHJcbiAgICBcIlVzZSB1cCBhbmQgZG93biBhcnJvd3MgdG8gbW92ZSBsb3dlciBzZWxlY3Rpb25cIjogXCJcIixcclxuICAgIFwiVXNlIHVwIGFuZCBkb3duIGFycm93cyB0byBtb3ZlIHVwcGVyIHNlbGVjdGlvblwiOiBcIlwiLFxyXG4gICAgXCJGcm9tICUxIHRvICUyXCI6IFwiXCIsXHJcbiAgICBcIkZyb20gJTFcIjogXCJcIixcclxuICAgIFwiVG8gJTFcIjogXCJcIixcclxuICAgIC8vIERhdGEgbG9hZGVyLXJlbGF0ZWQuXHJcbiAgICBcIk5vIHBhcnNlciBhdmFpbGFibGUgZm9yIGZpbGU6ICUxXCI6IFwiXCIsXHJcbiAgICBcIkVycm9yIHBhcnNpbmcgZmlsZTogJTFcIjogXCJcIixcclxuICAgIFwiVW5hYmxlIHRvIGxvYWQgZmlsZTogJTFcIjogXCJcIixcclxuICAgIFwiSW52YWxpZCBkYXRlXCI6IFwiXCIsXHJcbiAgICAvLyBDb21tb24gYWN0aW9uc1xyXG4gICAgXCJDbG9zZVwiOiBcIlwiLFxyXG4gICAgXCJNaW5pbWl6ZVwiOiBcIlwiXHJcbn07XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVuLmpzLm1hcCIsImltcG9ydCB7IEFuaW1hdGVkVGhlbWUgfSBmcm9tIFwiLi4vLmludGVybmFsL3RoZW1lcy9BbmltYXRlZFRoZW1lXCI7XHJcbmV4cG9ydCBkZWZhdWx0IEFuaW1hdGVkVGhlbWU7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUFuaW1hdGVkLmpzLm1hcCIsImltcG9ydCB7IERhcmtUaGVtZSB9IGZyb20gXCIuLi8uaW50ZXJuYWwvdGhlbWVzL0RhcmtUaGVtZVwiO1xyXG5leHBvcnQgZGVmYXVsdCBEYXJrVGhlbWU7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPURhcmsuanMubWFwIiwiaW1wb3J0IHsgUmVzcG9uc2l2ZVRoZW1lIH0gZnJvbSBcIi4uLy5pbnRlcm5hbC90aGVtZXMvUmVzcG9uc2l2ZVRoZW1lXCI7XHJcbmV4cG9ydCBkZWZhdWx0IFJlc3BvbnNpdmVUaGVtZTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UmVzcG9uc2l2ZS5qcy5tYXAiLCJ2YXIgX3NsaWNlZFRvQXJyYXkgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIHNsaWNlSXRlcmF0b3IoYXJyLCBpKSB7IHZhciBfYXJyID0gW107IHZhciBfbiA9IHRydWU7IHZhciBfZCA9IGZhbHNlOyB2YXIgX2UgPSB1bmRlZmluZWQ7IHRyeSB7IGZvciAodmFyIF9pID0gYXJyW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3M7ICEoX24gPSAoX3MgPSBfaS5uZXh0KCkpLmRvbmUpOyBfbiA9IHRydWUpIHsgX2Fyci5wdXNoKF9zLnZhbHVlKTsgaWYgKGkgJiYgX2Fyci5sZW5ndGggPT09IGkpIGJyZWFrOyB9IH0gY2F0Y2ggKGVycikgeyBfZCA9IHRydWU7IF9lID0gZXJyOyB9IGZpbmFsbHkgeyB0cnkgeyBpZiAoIV9uICYmIF9pW1wicmV0dXJuXCJdKSBfaVtcInJldHVyblwiXSgpOyB9IGZpbmFsbHkgeyBpZiAoX2QpIHRocm93IF9lOyB9IH0gcmV0dXJuIF9hcnI7IH0gcmV0dXJuIGZ1bmN0aW9uIChhcnIsIGkpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgeyByZXR1cm4gYXJyOyB9IGVsc2UgaWYgKFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoYXJyKSkgeyByZXR1cm4gc2xpY2VJdGVyYXRvcihhcnIsIGkpOyB9IGVsc2UgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZVwiKTsgfSB9OyB9KCk7XG5cbnZhciBUQVUgPSBNYXRoLlBJICogMjtcblxudmFyIG1hcFRvRWxsaXBzZSA9IGZ1bmN0aW9uIG1hcFRvRWxsaXBzZShfcmVmLCByeCwgcnksIGNvc3BoaSwgc2lucGhpLCBjZW50ZXJ4LCBjZW50ZXJ5KSB7XG4gIHZhciB4ID0gX3JlZi54LFxuICAgICAgeSA9IF9yZWYueTtcblxuICB4ICo9IHJ4O1xuICB5ICo9IHJ5O1xuXG4gIHZhciB4cCA9IGNvc3BoaSAqIHggLSBzaW5waGkgKiB5O1xuICB2YXIgeXAgPSBzaW5waGkgKiB4ICsgY29zcGhpICogeTtcblxuICByZXR1cm4ge1xuICAgIHg6IHhwICsgY2VudGVyeCxcbiAgICB5OiB5cCArIGNlbnRlcnlcbiAgfTtcbn07XG5cbnZhciBhcHByb3hVbml0QXJjID0gZnVuY3Rpb24gYXBwcm94VW5pdEFyYyhhbmcxLCBhbmcyKSB7XG4gIC8vIElmIDkwIGRlZ3JlZSBjaXJjdWxhciBhcmMsIHVzZSBhIGNvbnN0YW50XG4gIC8vIGFzIGRlcml2ZWQgZnJvbSBodHRwOi8vc3BlbmNlcm1vcnRlbnNlbi5jb20vYXJ0aWNsZXMvYmV6aWVyLWNpcmNsZVxuICB2YXIgYSA9IGFuZzIgPT09IDEuNTcwNzk2MzI2Nzk0ODk2NiA/IDAuNTUxOTE1MDI0NDk0IDogYW5nMiA9PT0gLTEuNTcwNzk2MzI2Nzk0ODk2NiA/IC0wLjU1MTkxNTAyNDQ5NCA6IDQgLyAzICogTWF0aC50YW4oYW5nMiAvIDQpO1xuXG4gIHZhciB4MSA9IE1hdGguY29zKGFuZzEpO1xuICB2YXIgeTEgPSBNYXRoLnNpbihhbmcxKTtcbiAgdmFyIHgyID0gTWF0aC5jb3MoYW5nMSArIGFuZzIpO1xuICB2YXIgeTIgPSBNYXRoLnNpbihhbmcxICsgYW5nMik7XG5cbiAgcmV0dXJuIFt7XG4gICAgeDogeDEgLSB5MSAqIGEsXG4gICAgeTogeTEgKyB4MSAqIGFcbiAgfSwge1xuICAgIHg6IHgyICsgeTIgKiBhLFxuICAgIHk6IHkyIC0geDIgKiBhXG4gIH0sIHtcbiAgICB4OiB4MixcbiAgICB5OiB5MlxuICB9XTtcbn07XG5cbnZhciB2ZWN0b3JBbmdsZSA9IGZ1bmN0aW9uIHZlY3RvckFuZ2xlKHV4LCB1eSwgdngsIHZ5KSB7XG4gIHZhciBzaWduID0gdXggKiB2eSAtIHV5ICogdnggPCAwID8gLTEgOiAxO1xuXG4gIHZhciBkb3QgPSB1eCAqIHZ4ICsgdXkgKiB2eTtcblxuICBpZiAoZG90ID4gMSkge1xuICAgIGRvdCA9IDE7XG4gIH1cblxuICBpZiAoZG90IDwgLTEpIHtcbiAgICBkb3QgPSAtMTtcbiAgfVxuXG4gIHJldHVybiBzaWduICogTWF0aC5hY29zKGRvdCk7XG59O1xuXG52YXIgZ2V0QXJjQ2VudGVyID0gZnVuY3Rpb24gZ2V0QXJjQ2VudGVyKHB4LCBweSwgY3gsIGN5LCByeCwgcnksIGxhcmdlQXJjRmxhZywgc3dlZXBGbGFnLCBzaW5waGksIGNvc3BoaSwgcHhwLCBweXApIHtcbiAgdmFyIHJ4c3EgPSBNYXRoLnBvdyhyeCwgMik7XG4gIHZhciByeXNxID0gTWF0aC5wb3cocnksIDIpO1xuICB2YXIgcHhwc3EgPSBNYXRoLnBvdyhweHAsIDIpO1xuICB2YXIgcHlwc3EgPSBNYXRoLnBvdyhweXAsIDIpO1xuXG4gIHZhciByYWRpY2FudCA9IHJ4c3EgKiByeXNxIC0gcnhzcSAqIHB5cHNxIC0gcnlzcSAqIHB4cHNxO1xuXG4gIGlmIChyYWRpY2FudCA8IDApIHtcbiAgICByYWRpY2FudCA9IDA7XG4gIH1cblxuICByYWRpY2FudCAvPSByeHNxICogcHlwc3EgKyByeXNxICogcHhwc3E7XG4gIHJhZGljYW50ID0gTWF0aC5zcXJ0KHJhZGljYW50KSAqIChsYXJnZUFyY0ZsYWcgPT09IHN3ZWVwRmxhZyA/IC0xIDogMSk7XG5cbiAgdmFyIGNlbnRlcnhwID0gcmFkaWNhbnQgKiByeCAvIHJ5ICogcHlwO1xuICB2YXIgY2VudGVyeXAgPSByYWRpY2FudCAqIC1yeSAvIHJ4ICogcHhwO1xuXG4gIHZhciBjZW50ZXJ4ID0gY29zcGhpICogY2VudGVyeHAgLSBzaW5waGkgKiBjZW50ZXJ5cCArIChweCArIGN4KSAvIDI7XG4gIHZhciBjZW50ZXJ5ID0gc2lucGhpICogY2VudGVyeHAgKyBjb3NwaGkgKiBjZW50ZXJ5cCArIChweSArIGN5KSAvIDI7XG5cbiAgdmFyIHZ4MSA9IChweHAgLSBjZW50ZXJ4cCkgLyByeDtcbiAgdmFyIHZ5MSA9IChweXAgLSBjZW50ZXJ5cCkgLyByeTtcbiAgdmFyIHZ4MiA9ICgtcHhwIC0gY2VudGVyeHApIC8gcng7XG4gIHZhciB2eTIgPSAoLXB5cCAtIGNlbnRlcnlwKSAvIHJ5O1xuXG4gIHZhciBhbmcxID0gdmVjdG9yQW5nbGUoMSwgMCwgdngxLCB2eTEpO1xuICB2YXIgYW5nMiA9IHZlY3RvckFuZ2xlKHZ4MSwgdnkxLCB2eDIsIHZ5Mik7XG5cbiAgaWYgKHN3ZWVwRmxhZyA9PT0gMCAmJiBhbmcyID4gMCkge1xuICAgIGFuZzIgLT0gVEFVO1xuICB9XG5cbiAgaWYgKHN3ZWVwRmxhZyA9PT0gMSAmJiBhbmcyIDwgMCkge1xuICAgIGFuZzIgKz0gVEFVO1xuICB9XG5cbiAgcmV0dXJuIFtjZW50ZXJ4LCBjZW50ZXJ5LCBhbmcxLCBhbmcyXTtcbn07XG5cbnZhciBhcmNUb0JlemllciA9IGZ1bmN0aW9uIGFyY1RvQmV6aWVyKF9yZWYyKSB7XG4gIHZhciBweCA9IF9yZWYyLnB4LFxuICAgICAgcHkgPSBfcmVmMi5weSxcbiAgICAgIGN4ID0gX3JlZjIuY3gsXG4gICAgICBjeSA9IF9yZWYyLmN5LFxuICAgICAgcnggPSBfcmVmMi5yeCxcbiAgICAgIHJ5ID0gX3JlZjIucnksXG4gICAgICBfcmVmMiR4QXhpc1JvdGF0aW9uID0gX3JlZjIueEF4aXNSb3RhdGlvbixcbiAgICAgIHhBeGlzUm90YXRpb24gPSBfcmVmMiR4QXhpc1JvdGF0aW9uID09PSB1bmRlZmluZWQgPyAwIDogX3JlZjIkeEF4aXNSb3RhdGlvbixcbiAgICAgIF9yZWYyJGxhcmdlQXJjRmxhZyA9IF9yZWYyLmxhcmdlQXJjRmxhZyxcbiAgICAgIGxhcmdlQXJjRmxhZyA9IF9yZWYyJGxhcmdlQXJjRmxhZyA9PT0gdW5kZWZpbmVkID8gMCA6IF9yZWYyJGxhcmdlQXJjRmxhZyxcbiAgICAgIF9yZWYyJHN3ZWVwRmxhZyA9IF9yZWYyLnN3ZWVwRmxhZyxcbiAgICAgIHN3ZWVwRmxhZyA9IF9yZWYyJHN3ZWVwRmxhZyA9PT0gdW5kZWZpbmVkID8gMCA6IF9yZWYyJHN3ZWVwRmxhZztcblxuICB2YXIgY3VydmVzID0gW107XG5cbiAgaWYgKHJ4ID09PSAwIHx8IHJ5ID09PSAwKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgdmFyIHNpbnBoaSA9IE1hdGguc2luKHhBeGlzUm90YXRpb24gKiBUQVUgLyAzNjApO1xuICB2YXIgY29zcGhpID0gTWF0aC5jb3MoeEF4aXNSb3RhdGlvbiAqIFRBVSAvIDM2MCk7XG5cbiAgdmFyIHB4cCA9IGNvc3BoaSAqIChweCAtIGN4KSAvIDIgKyBzaW5waGkgKiAocHkgLSBjeSkgLyAyO1xuICB2YXIgcHlwID0gLXNpbnBoaSAqIChweCAtIGN4KSAvIDIgKyBjb3NwaGkgKiAocHkgLSBjeSkgLyAyO1xuXG4gIGlmIChweHAgPT09IDAgJiYgcHlwID09PSAwKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgcnggPSBNYXRoLmFicyhyeCk7XG4gIHJ5ID0gTWF0aC5hYnMocnkpO1xuXG4gIHZhciBsYW1iZGEgPSBNYXRoLnBvdyhweHAsIDIpIC8gTWF0aC5wb3cocngsIDIpICsgTWF0aC5wb3cocHlwLCAyKSAvIE1hdGgucG93KHJ5LCAyKTtcblxuICBpZiAobGFtYmRhID4gMSkge1xuICAgIHJ4ICo9IE1hdGguc3FydChsYW1iZGEpO1xuICAgIHJ5ICo9IE1hdGguc3FydChsYW1iZGEpO1xuICB9XG5cbiAgdmFyIF9nZXRBcmNDZW50ZXIgPSBnZXRBcmNDZW50ZXIocHgsIHB5LCBjeCwgY3ksIHJ4LCByeSwgbGFyZ2VBcmNGbGFnLCBzd2VlcEZsYWcsIHNpbnBoaSwgY29zcGhpLCBweHAsIHB5cCksXG4gICAgICBfZ2V0QXJjQ2VudGVyMiA9IF9zbGljZWRUb0FycmF5KF9nZXRBcmNDZW50ZXIsIDQpLFxuICAgICAgY2VudGVyeCA9IF9nZXRBcmNDZW50ZXIyWzBdLFxuICAgICAgY2VudGVyeSA9IF9nZXRBcmNDZW50ZXIyWzFdLFxuICAgICAgYW5nMSA9IF9nZXRBcmNDZW50ZXIyWzJdLFxuICAgICAgYW5nMiA9IF9nZXRBcmNDZW50ZXIyWzNdO1xuXG4gIC8vIElmICdhbmcyJyA9PSA5MC4wMDAwMDAwMDAxLCB0aGVuIGByYXRpb2Agd2lsbCBldmFsdWF0ZSB0b1xuICAvLyAxLjAwMDAwMDAwMDEuIFRoaXMgY2F1c2VzIGBzZWdtZW50c2AgdG8gYmUgZ3JlYXRlciB0aGFuIG9uZSwgd2hpY2ggaXMgYW5cbiAgLy8gdW5lY2Vzc2FyeSBzcGxpdCwgYW5kIGFkZHMgZXh0cmEgcG9pbnRzIHRvIHRoZSBiZXppZXIgY3VydmUuIFRvIGFsbGV2aWF0ZVxuICAvLyB0aGlzIGlzc3VlLCB3ZSByb3VuZCB0byAxLjAgd2hlbiB0aGUgcmF0aW8gaXMgY2xvc2UgdG8gMS4wLlxuXG5cbiAgdmFyIHJhdGlvID0gTWF0aC5hYnMoYW5nMikgLyAoVEFVIC8gNCk7XG4gIGlmIChNYXRoLmFicygxLjAgLSByYXRpbykgPCAwLjAwMDAwMDEpIHtcbiAgICByYXRpbyA9IDEuMDtcbiAgfVxuXG4gIHZhciBzZWdtZW50cyA9IE1hdGgubWF4KE1hdGguY2VpbChyYXRpbyksIDEpO1xuXG4gIGFuZzIgLz0gc2VnbWVudHM7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWdtZW50czsgaSsrKSB7XG4gICAgY3VydmVzLnB1c2goYXBwcm94VW5pdEFyYyhhbmcxLCBhbmcyKSk7XG4gICAgYW5nMSArPSBhbmcyO1xuICB9XG5cbiAgcmV0dXJuIGN1cnZlcy5tYXAoZnVuY3Rpb24gKGN1cnZlKSB7XG4gICAgdmFyIF9tYXBUb0VsbGlwc2UgPSBtYXBUb0VsbGlwc2UoY3VydmVbMF0sIHJ4LCByeSwgY29zcGhpLCBzaW5waGksIGNlbnRlcngsIGNlbnRlcnkpLFxuICAgICAgICB4MSA9IF9tYXBUb0VsbGlwc2UueCxcbiAgICAgICAgeTEgPSBfbWFwVG9FbGxpcHNlLnk7XG5cbiAgICB2YXIgX21hcFRvRWxsaXBzZTIgPSBtYXBUb0VsbGlwc2UoY3VydmVbMV0sIHJ4LCByeSwgY29zcGhpLCBzaW5waGksIGNlbnRlcngsIGNlbnRlcnkpLFxuICAgICAgICB4MiA9IF9tYXBUb0VsbGlwc2UyLngsXG4gICAgICAgIHkyID0gX21hcFRvRWxsaXBzZTIueTtcblxuICAgIHZhciBfbWFwVG9FbGxpcHNlMyA9IG1hcFRvRWxsaXBzZShjdXJ2ZVsyXSwgcngsIHJ5LCBjb3NwaGksIHNpbnBoaSwgY2VudGVyeCwgY2VudGVyeSksXG4gICAgICAgIHggPSBfbWFwVG9FbGxpcHNlMy54LFxuICAgICAgICB5ID0gX21hcFRvRWxsaXBzZTMueTtcblxuICAgIHJldHVybiB7IHgxOiB4MSwgeTE6IHkxLCB4MjogeDIsIHkyOiB5MiwgeDogeCwgeTogeSB9O1xuICB9KTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGFyY1RvQmV6aWVyOyIsIi8vIEBhbWNoYXJ0cy5hbWNoYXJ0czVcbmltcG9ydCB7IFJvb3QsIGFkZExpY2Vuc2UgfSBmcm9tICdAYW1jaGFydHMvYW1jaGFydHM1L2luZGV4J1xuXG4vLyBlc3JpXG5pbXBvcnQgaW50bCBmcm9tICdlc3JpL2ludGwnXG5cbi8vIHJlZ2lzdGVyIGxpY2Vuc2VcbmFkZExpY2Vuc2UoJ0FNNUMyNDEwMjU3NDgnKVxuXG5jb25zdCBERUZBVUxUX0xPQ0FMRSA9ICdlbi11cydcblxuLy8gc3VwcG9ydGVkIGFtQ2hhcnRzIGxvY2FsZXMsIHNvcnRlZCBieSBsYW5ndWFnZSBhbmQgdGhlbiBkZWZhdWx0IHJlZ2lvblxuY29uc3QgbG9jYWxlcyA9IG5ldyBNYXA8c3RyaW5nLCAoKSA9PiBQcm9taXNlPGFueT4+KFtcbiAgWydhcicsICgpID0+IGltcG9ydCgnQGFtY2hhcnRzL2FtY2hhcnRzNS9sb2NhbGVzL2FyJyldLFxuICBbJ2JnLWJnJywgKCkgPT4gaW1wb3J0KCdAYW1jaGFydHMvYW1jaGFydHM1L2xvY2FsZXMvYmdfQkcnKV0sXG4gIFsnYnMtYmEnLCAoKSA9PiBpbXBvcnQoJ0BhbWNoYXJ0cy9hbWNoYXJ0czUvbG9jYWxlcy9ic19CQScpXSxcbiAgWydjYS1lcycsICgpID0+IGltcG9ydCgnQGFtY2hhcnRzL2FtY2hhcnRzNS9sb2NhbGVzL2NhX0VTJyldLFxuICBbJ2NzLWN6JywgKCkgPT4gaW1wb3J0KCdAYW1jaGFydHMvYW1jaGFydHM1L2xvY2FsZXMvY3NfQ1onKV0sXG4gIFsnZGEtZGsnLCAoKSA9PiBpbXBvcnQoJ0BhbWNoYXJ0cy9hbWNoYXJ0czUvbG9jYWxlcy9kYV9ESycpXSxcbiAgWydkZS1kZScsICgpID0+IGltcG9ydCgnQGFtY2hhcnRzL2FtY2hhcnRzNS9sb2NhbGVzL2RlX0RFJyldLFxuICBbJ2RlLWNoJywgKCkgPT4gaW1wb3J0KCdAYW1jaGFydHMvYW1jaGFydHM1L2xvY2FsZXMvZGVfQ0gnKV0sXG4gIFsnZWwtZ3InLCAoKSA9PiBpbXBvcnQoJ0BhbWNoYXJ0cy9hbWNoYXJ0czUvbG9jYWxlcy9lbF9HUicpXSxcbiAgWydlbi11cycsICgpID0+IGltcG9ydCgnQGFtY2hhcnRzL2FtY2hhcnRzNS9sb2NhbGVzL2VuX1VTJyldLFxuICBbJ2VuLWNhJywgKCkgPT4gaW1wb3J0KCdAYW1jaGFydHMvYW1jaGFydHM1L2xvY2FsZXMvZW5fQ0EnKV0sXG4gIFsnZXMtZXMnLCAoKSA9PiBpbXBvcnQoJ0BhbWNoYXJ0cy9hbWNoYXJ0czUvbG9jYWxlcy9lc19FUycpXSxcbiAgWydldC1lZScsICgpID0+IGltcG9ydCgnQGFtY2hhcnRzL2FtY2hhcnRzNS9sb2NhbGVzL2V0X0VFJyldLFxuICBbJ2ZpLWZpJywgKCkgPT4gaW1wb3J0KCdAYW1jaGFydHMvYW1jaGFydHM1L2xvY2FsZXMvZmlfRkknKV0sXG4gIFsnZnItZnInLCAoKSA9PiBpbXBvcnQoJ0BhbWNoYXJ0cy9hbWNoYXJ0czUvbG9jYWxlcy9mcl9GUicpXSxcbiAgWydoZS1pbCcsICgpID0+IGltcG9ydCgnQGFtY2hhcnRzL2FtY2hhcnRzNS9sb2NhbGVzL2hlX0lMJyldLFxuICBbJ2hyLWhyJywgKCkgPT4gaW1wb3J0KCdAYW1jaGFydHMvYW1jaGFydHM1L2xvY2FsZXMvaHJfSFInKV0sXG4gIFsnaHUtaHUnLCAoKSA9PiBpbXBvcnQoJ0BhbWNoYXJ0cy9hbWNoYXJ0czUvbG9jYWxlcy9odV9IVScpXSxcbiAgWydpZC1pZCcsICgpID0+IGltcG9ydCgnQGFtY2hhcnRzL2FtY2hhcnRzNS9sb2NhbGVzL2lkX0lEJyldLFxuICBbJ2l0LWl0JywgKCkgPT4gaW1wb3J0KCdAYW1jaGFydHMvYW1jaGFydHM1L2xvY2FsZXMvaXRfSVQnKV0sXG4gIFsnamEtanAnLCAoKSA9PiBpbXBvcnQoJ0BhbWNoYXJ0cy9hbWNoYXJ0czUvbG9jYWxlcy9qYV9KUCcpXSxcbiAgWydrby1rcicsICgpID0+IGltcG9ydCgnQGFtY2hhcnRzL2FtY2hhcnRzNS9sb2NhbGVzL2tvX0tSJyldLFxuICBbJ2x0LWx0JywgKCkgPT4gaW1wb3J0KCdAYW1jaGFydHMvYW1jaGFydHM1L2xvY2FsZXMvbHRfTFQnKV0sXG4gIFsnbHYtbHYnLCAoKSA9PiBpbXBvcnQoJ0BhbWNoYXJ0cy9hbWNoYXJ0czUvbG9jYWxlcy9sdl9MVicpXSxcbiAgWyduYi1ubycsICgpID0+IGltcG9ydCgnQGFtY2hhcnRzL2FtY2hhcnRzNS9sb2NhbGVzL25iX05PJyldLFxuICBbJ25sLW5sJywgKCkgPT4gaW1wb3J0KCdAYW1jaGFydHMvYW1jaGFydHM1L2xvY2FsZXMvbmxfTkwnKV0sXG4gIFsncGwtcGwnLCAoKSA9PiBpbXBvcnQoJ0BhbWNoYXJ0cy9hbWNoYXJ0czUvbG9jYWxlcy9wbF9QTCcpXSxcbiAgWydwdC1icicsICgpID0+IGltcG9ydCgnQGFtY2hhcnRzL2FtY2hhcnRzNS9sb2NhbGVzL3B0X0JSJyldLFxuICBbJ3B0LXB0JywgKCkgPT4gaW1wb3J0KCdAYW1jaGFydHMvYW1jaGFydHM1L2xvY2FsZXMvcHRfUFQnKV0sXG4gIFsncm8tcm8nLCAoKSA9PiBpbXBvcnQoJ0BhbWNoYXJ0cy9hbWNoYXJ0czUvbG9jYWxlcy9yb19STycpXSxcbiAgWydydS1ydScsICgpID0+IGltcG9ydCgnQGFtY2hhcnRzL2FtY2hhcnRzNS9sb2NhbGVzL3J1X1JVJyldLFxuICBbJ3NrLXNrJywgKCkgPT4gaW1wb3J0KCdAYW1jaGFydHMvYW1jaGFydHM1L2xvY2FsZXMvc2tfU0snKV0sXG4gIFsnc2wtc2wnLCAoKSA9PiBpbXBvcnQoJ0BhbWNoYXJ0cy9hbWNoYXJ0czUvbG9jYWxlcy9zbF9TTCcpXSxcbiAgWydzci1ycycsICgpID0+IGltcG9ydCgnQGFtY2hhcnRzL2FtY2hhcnRzNS9sb2NhbGVzL3NyX1JTJyldLFxuICBbJ3N2LXNlJywgKCkgPT4gaW1wb3J0KCdAYW1jaGFydHMvYW1jaGFydHM1L2xvY2FsZXMvc3ZfU0UnKV0sXG4gIFsndGgtdGgnLCAoKSA9PiBpbXBvcnQoJ0BhbWNoYXJ0cy9hbWNoYXJ0czUvbG9jYWxlcy90aF9USCcpXSxcbiAgWyd0ci10cicsICgpID0+IGltcG9ydCgnQGFtY2hhcnRzL2FtY2hhcnRzNS9sb2NhbGVzL3RyX1RSJyldLFxuICBbJ3VrLXVhJywgKCkgPT4gaW1wb3J0KCdAYW1jaGFydHMvYW1jaGFydHM1L2xvY2FsZXMvdWtfVUEnKV0sXG4gIFsndmktdm4nLCAoKSA9PiBpbXBvcnQoJ0BhbWNoYXJ0cy9hbWNoYXJ0czUvbG9jYWxlcy92aV9WTicpXSxcbiAgWyd6aC1jbicsICgpID0+IGltcG9ydCgnQGFtY2hhcnRzL2FtY2hhcnRzNS9sb2NhbGVzL3poX0hhbnMnKV0sXG4gIFsnemgtaGsnLCAoKSA9PiBpbXBvcnQoJ0BhbWNoYXJ0cy9hbWNoYXJ0czUvbG9jYWxlcy96aF9IYW50JyldLFxuICBbJ3poLXR3JywgKCkgPT4gaW1wb3J0KCdAYW1jaGFydHMvYW1jaGFydHM1L2xvY2FsZXMvemhfSGFudCcpXVxuXSlcblxuZnVuY3Rpb24gZ2V0TGFuZ3VhZ2VMb2NhbGUgKGxvY2FsZTogc3RyaW5nKTogc3RyaW5nIHwgbnVsbCB7XG4gIGNvbnN0IHNwbGl0TG9jYWxlID0gbG9jYWxlLnNwbGl0KCctJylcbiAgY29uc3QgbGFuZ3VhZ2VDb2RlID0gc3BsaXRMb2NhbGVbMF0udG9Mb3dlckNhc2UoKVxuXG4gIGxldCBtYXRjaDogc3RyaW5nIHwgbnVsbCA9IG51bGxcblxuICBmb3IgKGNvbnN0IGtleSBvZiBsb2NhbGVzLmtleXMoKSkge1xuICAgIGlmIChrZXkuc3RhcnRzV2l0aChsYW5ndWFnZUNvZGUpKSB7XG4gICAgICBtYXRjaCA9IGtleVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbWF0Y2hcbn1cblxuZnVuY3Rpb24gZ2V0Q2hhcnRMb2NhbGUgKGxvY2FsZTogc3RyaW5nKTogc3RyaW5nIHtcbiAgaWYgKCFsb2NhbGUpIHtcbiAgICByZXR1cm4gREVGQVVMVF9MT0NBTEVcbiAgfVxuICBpZiAobG9jYWxlcy5oYXMobG9jYWxlLnRvTG93ZXJDYXNlKCkpKSB7XG4gICAgcmV0dXJuIGxvY2FsZS50b0xvd2VyQ2FzZSgpXG4gIH1cbiAgcmV0dXJuIGdldExhbmd1YWdlTG9jYWxlKGxvY2FsZSkgfHwgREVGQVVMVF9MT0NBTEVcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgbmV3IGBSb290YCBpbnN0YW5jZSB3aXRoIHRoZSBsb2NhbGUgdmFsdWVzIGxvYWRlZCBhbmQgc2V0LlxuICogQHBhcmFtIGlkXG4gKiBAcGFyYW0gW2xvY2FsZV1cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNyZWF0ZVJvb3QgKGlkOiBzdHJpbmcgfCBIVE1MRWxlbWVudCwgbG9jYWxlOiBzdHJpbmcpOiBQcm9taXNlPFJvb3Q+IHtcbiAgY29uc3Qgcm9vdCA9IFJvb3QubmV3KGlkKVxuICBpZiAoIWxvY2FsZSkge1xuICAgIGxvY2FsZSA9IGludGwuZ2V0TG9jYWxlKClcbiAgfVxuICByb290LmxvY2FsZSA9IChhd2FpdCBsb2NhbGVzLmdldChnZXRDaGFydExvY2FsZShsb2NhbGUpKT8uKCkpLmRlZmF1bHRcbiAgcmV0dXJuIHJvb3Rcbn1cblxuZXhwb3J0IHtcbiAgWFlDaGFydCBhcyBYWUNoYXJ0QW01LFxuICBBeGlzUmVuZGVyZXJYIGFzIEF4aXNSZW5kZXJlclhBbTUsXG4gIENhdGVnb3J5QXhpcyBhcyBDYXRlZ29yeUF4aXNBbTUsXG4gIFZhbHVlQXhpcyBhcyBWYWx1ZUF4aXNBbTUsXG4gIEF4aXNSZW5kZXJlclkgYXMgQXhpc1JlbmRlcmVyWUFtNSxcbiAgQ29sdW1uU2VyaWVzIGFzIENvbHVtblNlcmllc0FtNSxcbiAgTGluZVNlcmllcyBhcyBMaW5lU2VyaWVzQW01LFxuICBYWUN1cnNvciBhcyBYWUN1cnNvckFtNVxufSBmcm9tICdAYW1jaGFydHMvYW1jaGFydHM1L3h5J1xuXG5leHBvcnQge1xuICBQaWVDaGFydCBhcyBQaWVDaGFydEFtNSxcbiAgUGllU2VyaWVzIGFzIFBpZVNlcmllc0FtNVxufSBmcm9tICdAYW1jaGFydHMvYW1jaGFydHM1L3BlcmNlbnQnXG5cbmV4cG9ydCB7XG4gIGNvbG9yIGFzIGNvbG9yQW01LFxuICBUb29sdGlwIGFzIFRvb2x0aXBBbTUsXG4gIE51bWJlckZvcm1hdHRlciBhcyBOdW1iZXJGb3JtYXR0ZXJBbTUsXG4gIExhYmVsIGFzIExhYmVsQW01LFxuICBMZWdlbmQgYXMgTGVnZW5kQW01LFxuICBHcmlkTGF5b3V0IGFzIEdyaWRMYXlvdXRBbTUsXG4gIEJ1bGxldCBhcyBCdWxsZXRBbTUsXG4gIFJlY3RhbmdsZSBhcyBSZWN0YW5nbGVBbTUsXG4gIENpcmNsZSBhcyBDaXJjbGVBbTUsXG4gIFRyaWFuZ2xlIGFzIFRyaWFuZ2xlQW01LFxuICBDb250YWluZXIgYXMgQ29udGFpbmVyQW01LFxuICBwMCwgcDUwLCBwMTAwLFxuICBTY3JvbGxiYXIgYXMgU2Nyb2xsYmFyQW01LFxuICBwZXJjZW50IGFzIHBlcmNlbnRBbTVcbn0gZnJvbSAnQGFtY2hhcnRzL2FtY2hhcnRzNSdcblxuZXhwb3J0IHsgZGVmYXVsdCBhcyBEYXJrVGhlbWVBbTUgfSBmcm9tICdAYW1jaGFydHMvYW1jaGFydHM1L3RoZW1lcy9EYXJrJ1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBSZXNwb25zaXZlVGhlbWVBbTUgfSBmcm9tICdAYW1jaGFydHMvYW1jaGFydHM1L3RoZW1lcy9SZXNwb25zaXZlJ1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBBbmltYXRlZFRoZW1lQW01IH0gZnJvbSAnQGFtY2hhcnRzL2FtY2hhcnRzNS90aGVtZXMvQW5pbWF0ZWQnXG5leHBvcnQgeyBFeHBvcnRpbmcgfSBmcm9tICdAYW1jaGFydHMvYW1jaGFydHM1L3BsdWdpbnMvZXhwb3J0aW5nJ1xuZXhwb3J0IHsgQ29sdW1uU2VyaWVzIH0gZnJvbSAnQGFtY2hhcnRzL2FtY2hhcnRzNS8uaW50ZXJuYWwvY2hhcnRzL3h5L3Nlcmllcy9Db2x1bW5TZXJpZXMnXG4iLCJtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfZXNyaV9pbnRsX187IiwiY29uc3QgcGkgPSBNYXRoLlBJLFxuICAgIHRhdSA9IDIgKiBwaSxcbiAgICBlcHNpbG9uID0gMWUtNixcbiAgICB0YXVFcHNpbG9uID0gdGF1IC0gZXBzaWxvbjtcblxuZnVuY3Rpb24gYXBwZW5kKHN0cmluZ3MpIHtcbiAgdGhpcy5fICs9IHN0cmluZ3NbMF07XG4gIGZvciAobGV0IGkgPSAxLCBuID0gc3RyaW5ncy5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICB0aGlzLl8gKz0gYXJndW1lbnRzW2ldICsgc3RyaW5nc1tpXTtcbiAgfVxufVxuXG5mdW5jdGlvbiBhcHBlbmRSb3VuZChkaWdpdHMpIHtcbiAgbGV0IGQgPSBNYXRoLmZsb29yKGRpZ2l0cyk7XG4gIGlmICghKGQgPj0gMCkpIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBkaWdpdHM6ICR7ZGlnaXRzfWApO1xuICBpZiAoZCA+IDE1KSByZXR1cm4gYXBwZW5kO1xuICBjb25zdCBrID0gMTAgKiogZDtcbiAgcmV0dXJuIGZ1bmN0aW9uKHN0cmluZ3MpIHtcbiAgICB0aGlzLl8gKz0gc3RyaW5nc1swXTtcbiAgICBmb3IgKGxldCBpID0gMSwgbiA9IHN0cmluZ3MubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgICB0aGlzLl8gKz0gTWF0aC5yb3VuZChhcmd1bWVudHNbaV0gKiBrKSAvIGsgKyBzdHJpbmdzW2ldO1xuICAgIH1cbiAgfTtcbn1cblxuZXhwb3J0IGNsYXNzIFBhdGgge1xuICBjb25zdHJ1Y3RvcihkaWdpdHMpIHtcbiAgICB0aGlzLl94MCA9IHRoaXMuX3kwID0gLy8gc3RhcnQgb2YgY3VycmVudCBzdWJwYXRoXG4gICAgdGhpcy5feDEgPSB0aGlzLl95MSA9IG51bGw7IC8vIGVuZCBvZiBjdXJyZW50IHN1YnBhdGhcbiAgICB0aGlzLl8gPSBcIlwiO1xuICAgIHRoaXMuX2FwcGVuZCA9IGRpZ2l0cyA9PSBudWxsID8gYXBwZW5kIDogYXBwZW5kUm91bmQoZGlnaXRzKTtcbiAgfVxuICBtb3ZlVG8oeCwgeSkge1xuICAgIHRoaXMuX2FwcGVuZGBNJHt0aGlzLl94MCA9IHRoaXMuX3gxID0gK3h9LCR7dGhpcy5feTAgPSB0aGlzLl95MSA9ICt5fWA7XG4gIH1cbiAgY2xvc2VQYXRoKCkge1xuICAgIGlmICh0aGlzLl94MSAhPT0gbnVsbCkge1xuICAgICAgdGhpcy5feDEgPSB0aGlzLl94MCwgdGhpcy5feTEgPSB0aGlzLl95MDtcbiAgICAgIHRoaXMuX2FwcGVuZGBaYDtcbiAgICB9XG4gIH1cbiAgbGluZVRvKHgsIHkpIHtcbiAgICB0aGlzLl9hcHBlbmRgTCR7dGhpcy5feDEgPSAreH0sJHt0aGlzLl95MSA9ICt5fWA7XG4gIH1cbiAgcXVhZHJhdGljQ3VydmVUbyh4MSwgeTEsIHgsIHkpIHtcbiAgICB0aGlzLl9hcHBlbmRgUSR7K3gxfSwkeyt5MX0sJHt0aGlzLl94MSA9ICt4fSwke3RoaXMuX3kxID0gK3l9YDtcbiAgfVxuICBiZXppZXJDdXJ2ZVRvKHgxLCB5MSwgeDIsIHkyLCB4LCB5KSB7XG4gICAgdGhpcy5fYXBwZW5kYEMkeyt4MX0sJHsreTF9LCR7K3gyfSwkeyt5Mn0sJHt0aGlzLl94MSA9ICt4fSwke3RoaXMuX3kxID0gK3l9YDtcbiAgfVxuICBhcmNUbyh4MSwgeTEsIHgyLCB5Miwgcikge1xuICAgIHgxID0gK3gxLCB5MSA9ICt5MSwgeDIgPSAreDIsIHkyID0gK3kyLCByID0gK3I7XG5cbiAgICAvLyBJcyB0aGUgcmFkaXVzIG5lZ2F0aXZlPyBFcnJvci5cbiAgICBpZiAociA8IDApIHRocm93IG5ldyBFcnJvcihgbmVnYXRpdmUgcmFkaXVzOiAke3J9YCk7XG5cbiAgICBsZXQgeDAgPSB0aGlzLl94MSxcbiAgICAgICAgeTAgPSB0aGlzLl95MSxcbiAgICAgICAgeDIxID0geDIgLSB4MSxcbiAgICAgICAgeTIxID0geTIgLSB5MSxcbiAgICAgICAgeDAxID0geDAgLSB4MSxcbiAgICAgICAgeTAxID0geTAgLSB5MSxcbiAgICAgICAgbDAxXzIgPSB4MDEgKiB4MDEgKyB5MDEgKiB5MDE7XG5cbiAgICAvLyBJcyB0aGlzIHBhdGggZW1wdHk/IE1vdmUgdG8gKHgxLHkxKS5cbiAgICBpZiAodGhpcy5feDEgPT09IG51bGwpIHtcbiAgICAgIHRoaXMuX2FwcGVuZGBNJHt0aGlzLl94MSA9IHgxfSwke3RoaXMuX3kxID0geTF9YDtcbiAgICB9XG5cbiAgICAvLyBPciwgaXMgKHgxLHkxKSBjb2luY2lkZW50IHdpdGggKHgwLHkwKT8gRG8gbm90aGluZy5cbiAgICBlbHNlIGlmICghKGwwMV8yID4gZXBzaWxvbikpO1xuXG4gICAgLy8gT3IsIGFyZSAoeDAseTApLCAoeDEseTEpIGFuZCAoeDIseTIpIGNvbGxpbmVhcj9cbiAgICAvLyBFcXVpdmFsZW50bHksIGlzICh4MSx5MSkgY29pbmNpZGVudCB3aXRoICh4Mix5Mik/XG4gICAgLy8gT3IsIGlzIHRoZSByYWRpdXMgemVybz8gTGluZSB0byAoeDEseTEpLlxuICAgIGVsc2UgaWYgKCEoTWF0aC5hYnMoeTAxICogeDIxIC0geTIxICogeDAxKSA+IGVwc2lsb24pIHx8ICFyKSB7XG4gICAgICB0aGlzLl9hcHBlbmRgTCR7dGhpcy5feDEgPSB4MX0sJHt0aGlzLl95MSA9IHkxfWA7XG4gICAgfVxuXG4gICAgLy8gT3RoZXJ3aXNlLCBkcmF3IGFuIGFyYyFcbiAgICBlbHNlIHtcbiAgICAgIGxldCB4MjAgPSB4MiAtIHgwLFxuICAgICAgICAgIHkyMCA9IHkyIC0geTAsXG4gICAgICAgICAgbDIxXzIgPSB4MjEgKiB4MjEgKyB5MjEgKiB5MjEsXG4gICAgICAgICAgbDIwXzIgPSB4MjAgKiB4MjAgKyB5MjAgKiB5MjAsXG4gICAgICAgICAgbDIxID0gTWF0aC5zcXJ0KGwyMV8yKSxcbiAgICAgICAgICBsMDEgPSBNYXRoLnNxcnQobDAxXzIpLFxuICAgICAgICAgIGwgPSByICogTWF0aC50YW4oKHBpIC0gTWF0aC5hY29zKChsMjFfMiArIGwwMV8yIC0gbDIwXzIpIC8gKDIgKiBsMjEgKiBsMDEpKSkgLyAyKSxcbiAgICAgICAgICB0MDEgPSBsIC8gbDAxLFxuICAgICAgICAgIHQyMSA9IGwgLyBsMjE7XG5cbiAgICAgIC8vIElmIHRoZSBzdGFydCB0YW5nZW50IGlzIG5vdCBjb2luY2lkZW50IHdpdGggKHgwLHkwKSwgbGluZSB0by5cbiAgICAgIGlmIChNYXRoLmFicyh0MDEgLSAxKSA+IGVwc2lsb24pIHtcbiAgICAgICAgdGhpcy5fYXBwZW5kYEwke3gxICsgdDAxICogeDAxfSwke3kxICsgdDAxICogeTAxfWA7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2FwcGVuZGBBJHtyfSwke3J9LDAsMCwkeysoeTAxICogeDIwID4geDAxICogeTIwKX0sJHt0aGlzLl94MSA9IHgxICsgdDIxICogeDIxfSwke3RoaXMuX3kxID0geTEgKyB0MjEgKiB5MjF9YDtcbiAgICB9XG4gIH1cbiAgYXJjKHgsIHksIHIsIGEwLCBhMSwgY2N3KSB7XG4gICAgeCA9ICt4LCB5ID0gK3ksIHIgPSArciwgY2N3ID0gISFjY3c7XG5cbiAgICAvLyBJcyB0aGUgcmFkaXVzIG5lZ2F0aXZlPyBFcnJvci5cbiAgICBpZiAociA8IDApIHRocm93IG5ldyBFcnJvcihgbmVnYXRpdmUgcmFkaXVzOiAke3J9YCk7XG5cbiAgICBsZXQgZHggPSByICogTWF0aC5jb3MoYTApLFxuICAgICAgICBkeSA9IHIgKiBNYXRoLnNpbihhMCksXG4gICAgICAgIHgwID0geCArIGR4LFxuICAgICAgICB5MCA9IHkgKyBkeSxcbiAgICAgICAgY3cgPSAxIF4gY2N3LFxuICAgICAgICBkYSA9IGNjdyA/IGEwIC0gYTEgOiBhMSAtIGEwO1xuXG4gICAgLy8gSXMgdGhpcyBwYXRoIGVtcHR5PyBNb3ZlIHRvICh4MCx5MCkuXG4gICAgaWYgKHRoaXMuX3gxID09PSBudWxsKSB7XG4gICAgICB0aGlzLl9hcHBlbmRgTSR7eDB9LCR7eTB9YDtcbiAgICB9XG5cbiAgICAvLyBPciwgaXMgKHgwLHkwKSBub3QgY29pbmNpZGVudCB3aXRoIHRoZSBwcmV2aW91cyBwb2ludD8gTGluZSB0byAoeDAseTApLlxuICAgIGVsc2UgaWYgKE1hdGguYWJzKHRoaXMuX3gxIC0geDApID4gZXBzaWxvbiB8fCBNYXRoLmFicyh0aGlzLl95MSAtIHkwKSA+IGVwc2lsb24pIHtcbiAgICAgIHRoaXMuX2FwcGVuZGBMJHt4MH0sJHt5MH1gO1xuICAgIH1cblxuICAgIC8vIElzIHRoaXMgYXJjIGVtcHR5PyBXZeKAmXJlIGRvbmUuXG4gICAgaWYgKCFyKSByZXR1cm47XG5cbiAgICAvLyBEb2VzIHRoZSBhbmdsZSBnbyB0aGUgd3Jvbmcgd2F5PyBGbGlwIHRoZSBkaXJlY3Rpb24uXG4gICAgaWYgKGRhIDwgMCkgZGEgPSBkYSAlIHRhdSArIHRhdTtcblxuICAgIC8vIElzIHRoaXMgYSBjb21wbGV0ZSBjaXJjbGU/IERyYXcgdHdvIGFyY3MgdG8gY29tcGxldGUgdGhlIGNpcmNsZS5cbiAgICBpZiAoZGEgPiB0YXVFcHNpbG9uKSB7XG4gICAgICB0aGlzLl9hcHBlbmRgQSR7cn0sJHtyfSwwLDEsJHtjd30sJHt4IC0gZHh9LCR7eSAtIGR5fUEke3J9LCR7cn0sMCwxLCR7Y3d9LCR7dGhpcy5feDEgPSB4MH0sJHt0aGlzLl95MSA9IHkwfWA7XG4gICAgfVxuXG4gICAgLy8gSXMgdGhpcyBhcmMgbm9uLWVtcHR5PyBEcmF3IGFuIGFyYyFcbiAgICBlbHNlIGlmIChkYSA+IGVwc2lsb24pIHtcbiAgICAgIHRoaXMuX2FwcGVuZGBBJHtyfSwke3J9LDAsJHsrKGRhID49IHBpKX0sJHtjd30sJHt0aGlzLl94MSA9IHggKyByICogTWF0aC5jb3MoYTEpfSwke3RoaXMuX3kxID0geSArIHIgKiBNYXRoLnNpbihhMSl9YDtcbiAgICB9XG4gIH1cbiAgcmVjdCh4LCB5LCB3LCBoKSB7XG4gICAgdGhpcy5fYXBwZW5kYE0ke3RoaXMuX3gwID0gdGhpcy5feDEgPSAreH0sJHt0aGlzLl95MCA9IHRoaXMuX3kxID0gK3l9aCR7dyA9ICt3fXYkeytofWgkey13fVpgO1xuICB9XG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLl87XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBhdGgoKSB7XG4gIHJldHVybiBuZXcgUGF0aDtcbn1cblxuLy8gQWxsb3cgaW5zdGFuY2VvZiBkMy5wYXRoXG5wYXRoLnByb3RvdHlwZSA9IFBhdGgucHJvdG90eXBlO1xuXG5leHBvcnQgZnVuY3Rpb24gcGF0aFJvdW5kKGRpZ2l0cyA9IDMpIHtcbiAgcmV0dXJuIG5ldyBQYXRoKCtkaWdpdHMpO1xufVxuIiwiaW1wb3J0IGNvbnN0YW50IGZyb20gXCIuL2NvbnN0YW50LmpzXCI7XG5pbXBvcnQge2FicywgYWNvcywgYXNpbiwgYXRhbjIsIGNvcywgZXBzaWxvbiwgaGFsZlBpLCBtYXgsIG1pbiwgcGksIHNpbiwgc3FydCwgdGF1fSBmcm9tIFwiLi9tYXRoLmpzXCI7XG5pbXBvcnQge3dpdGhQYXRofSBmcm9tIFwiLi9wYXRoLmpzXCI7XG5cbmZ1bmN0aW9uIGFyY0lubmVyUmFkaXVzKGQpIHtcbiAgcmV0dXJuIGQuaW5uZXJSYWRpdXM7XG59XG5cbmZ1bmN0aW9uIGFyY091dGVyUmFkaXVzKGQpIHtcbiAgcmV0dXJuIGQub3V0ZXJSYWRpdXM7XG59XG5cbmZ1bmN0aW9uIGFyY1N0YXJ0QW5nbGUoZCkge1xuICByZXR1cm4gZC5zdGFydEFuZ2xlO1xufVxuXG5mdW5jdGlvbiBhcmNFbmRBbmdsZShkKSB7XG4gIHJldHVybiBkLmVuZEFuZ2xlO1xufVxuXG5mdW5jdGlvbiBhcmNQYWRBbmdsZShkKSB7XG4gIHJldHVybiBkICYmIGQucGFkQW5nbGU7IC8vIE5vdGU6IG9wdGlvbmFsIVxufVxuXG5mdW5jdGlvbiBpbnRlcnNlY3QoeDAsIHkwLCB4MSwgeTEsIHgyLCB5MiwgeDMsIHkzKSB7XG4gIHZhciB4MTAgPSB4MSAtIHgwLCB5MTAgPSB5MSAtIHkwLFxuICAgICAgeDMyID0geDMgLSB4MiwgeTMyID0geTMgLSB5MixcbiAgICAgIHQgPSB5MzIgKiB4MTAgLSB4MzIgKiB5MTA7XG4gIGlmICh0ICogdCA8IGVwc2lsb24pIHJldHVybjtcbiAgdCA9ICh4MzIgKiAoeTAgLSB5MikgLSB5MzIgKiAoeDAgLSB4MikpIC8gdDtcbiAgcmV0dXJuIFt4MCArIHQgKiB4MTAsIHkwICsgdCAqIHkxMF07XG59XG5cbi8vIENvbXB1dGUgcGVycGVuZGljdWxhciBvZmZzZXQgbGluZSBvZiBsZW5ndGggcmMuXG4vLyBodHRwOi8vbWF0aHdvcmxkLndvbGZyYW0uY29tL0NpcmNsZS1MaW5lSW50ZXJzZWN0aW9uLmh0bWxcbmZ1bmN0aW9uIGNvcm5lclRhbmdlbnRzKHgwLCB5MCwgeDEsIHkxLCByMSwgcmMsIGN3KSB7XG4gIHZhciB4MDEgPSB4MCAtIHgxLFxuICAgICAgeTAxID0geTAgLSB5MSxcbiAgICAgIGxvID0gKGN3ID8gcmMgOiAtcmMpIC8gc3FydCh4MDEgKiB4MDEgKyB5MDEgKiB5MDEpLFxuICAgICAgb3ggPSBsbyAqIHkwMSxcbiAgICAgIG95ID0gLWxvICogeDAxLFxuICAgICAgeDExID0geDAgKyBveCxcbiAgICAgIHkxMSA9IHkwICsgb3ksXG4gICAgICB4MTAgPSB4MSArIG94LFxuICAgICAgeTEwID0geTEgKyBveSxcbiAgICAgIHgwMCA9ICh4MTEgKyB4MTApIC8gMixcbiAgICAgIHkwMCA9ICh5MTEgKyB5MTApIC8gMixcbiAgICAgIGR4ID0geDEwIC0geDExLFxuICAgICAgZHkgPSB5MTAgLSB5MTEsXG4gICAgICBkMiA9IGR4ICogZHggKyBkeSAqIGR5LFxuICAgICAgciA9IHIxIC0gcmMsXG4gICAgICBEID0geDExICogeTEwIC0geDEwICogeTExLFxuICAgICAgZCA9IChkeSA8IDAgPyAtMSA6IDEpICogc3FydChtYXgoMCwgciAqIHIgKiBkMiAtIEQgKiBEKSksXG4gICAgICBjeDAgPSAoRCAqIGR5IC0gZHggKiBkKSAvIGQyLFxuICAgICAgY3kwID0gKC1EICogZHggLSBkeSAqIGQpIC8gZDIsXG4gICAgICBjeDEgPSAoRCAqIGR5ICsgZHggKiBkKSAvIGQyLFxuICAgICAgY3kxID0gKC1EICogZHggKyBkeSAqIGQpIC8gZDIsXG4gICAgICBkeDAgPSBjeDAgLSB4MDAsXG4gICAgICBkeTAgPSBjeTAgLSB5MDAsXG4gICAgICBkeDEgPSBjeDEgLSB4MDAsXG4gICAgICBkeTEgPSBjeTEgLSB5MDA7XG5cbiAgLy8gUGljayB0aGUgY2xvc2VyIG9mIHRoZSB0d28gaW50ZXJzZWN0aW9uIHBvaW50cy5cbiAgLy8gVE9ETyBJcyB0aGVyZSBhIGZhc3RlciB3YXkgdG8gZGV0ZXJtaW5lIHdoaWNoIGludGVyc2VjdGlvbiB0byB1c2U/XG4gIGlmIChkeDAgKiBkeDAgKyBkeTAgKiBkeTAgPiBkeDEgKiBkeDEgKyBkeTEgKiBkeTEpIGN4MCA9IGN4MSwgY3kwID0gY3kxO1xuXG4gIHJldHVybiB7XG4gICAgY3g6IGN4MCxcbiAgICBjeTogY3kwLFxuICAgIHgwMTogLW94LFxuICAgIHkwMTogLW95LFxuICAgIHgxMTogY3gwICogKHIxIC8gciAtIDEpLFxuICAgIHkxMTogY3kwICogKHIxIC8gciAtIDEpXG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKCkge1xuICB2YXIgaW5uZXJSYWRpdXMgPSBhcmNJbm5lclJhZGl1cyxcbiAgICAgIG91dGVyUmFkaXVzID0gYXJjT3V0ZXJSYWRpdXMsXG4gICAgICBjb3JuZXJSYWRpdXMgPSBjb25zdGFudCgwKSxcbiAgICAgIHBhZFJhZGl1cyA9IG51bGwsXG4gICAgICBzdGFydEFuZ2xlID0gYXJjU3RhcnRBbmdsZSxcbiAgICAgIGVuZEFuZ2xlID0gYXJjRW5kQW5nbGUsXG4gICAgICBwYWRBbmdsZSA9IGFyY1BhZEFuZ2xlLFxuICAgICAgY29udGV4dCA9IG51bGwsXG4gICAgICBwYXRoID0gd2l0aFBhdGgoYXJjKTtcblxuICBmdW5jdGlvbiBhcmMoKSB7XG4gICAgdmFyIGJ1ZmZlcixcbiAgICAgICAgcixcbiAgICAgICAgcjAgPSAraW5uZXJSYWRpdXMuYXBwbHkodGhpcywgYXJndW1lbnRzKSxcbiAgICAgICAgcjEgPSArb3V0ZXJSYWRpdXMuYXBwbHkodGhpcywgYXJndW1lbnRzKSxcbiAgICAgICAgYTAgPSBzdGFydEFuZ2xlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgLSBoYWxmUGksXG4gICAgICAgIGExID0gZW5kQW5nbGUuYXBwbHkodGhpcywgYXJndW1lbnRzKSAtIGhhbGZQaSxcbiAgICAgICAgZGEgPSBhYnMoYTEgLSBhMCksXG4gICAgICAgIGN3ID0gYTEgPiBhMDtcblxuICAgIGlmICghY29udGV4dCkgY29udGV4dCA9IGJ1ZmZlciA9IHBhdGgoKTtcblxuICAgIC8vIEVuc3VyZSB0aGF0IHRoZSBvdXRlciByYWRpdXMgaXMgYWx3YXlzIGxhcmdlciB0aGFuIHRoZSBpbm5lciByYWRpdXMuXG4gICAgaWYgKHIxIDwgcjApIHIgPSByMSwgcjEgPSByMCwgcjAgPSByO1xuXG4gICAgLy8gSXMgaXQgYSBwb2ludD9cbiAgICBpZiAoIShyMSA+IGVwc2lsb24pKSBjb250ZXh0Lm1vdmVUbygwLCAwKTtcblxuICAgIC8vIE9yIGlzIGl0IGEgY2lyY2xlIG9yIGFubnVsdXM/XG4gICAgZWxzZSBpZiAoZGEgPiB0YXUgLSBlcHNpbG9uKSB7XG4gICAgICBjb250ZXh0Lm1vdmVUbyhyMSAqIGNvcyhhMCksIHIxICogc2luKGEwKSk7XG4gICAgICBjb250ZXh0LmFyYygwLCAwLCByMSwgYTAsIGExLCAhY3cpO1xuICAgICAgaWYgKHIwID4gZXBzaWxvbikge1xuICAgICAgICBjb250ZXh0Lm1vdmVUbyhyMCAqIGNvcyhhMSksIHIwICogc2luKGExKSk7XG4gICAgICAgIGNvbnRleHQuYXJjKDAsIDAsIHIwLCBhMSwgYTAsIGN3KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBPciBpcyBpdCBhIGNpcmN1bGFyIG9yIGFubnVsYXIgc2VjdG9yP1xuICAgIGVsc2Uge1xuICAgICAgdmFyIGEwMSA9IGEwLFxuICAgICAgICAgIGExMSA9IGExLFxuICAgICAgICAgIGEwMCA9IGEwLFxuICAgICAgICAgIGExMCA9IGExLFxuICAgICAgICAgIGRhMCA9IGRhLFxuICAgICAgICAgIGRhMSA9IGRhLFxuICAgICAgICAgIGFwID0gcGFkQW5nbGUuYXBwbHkodGhpcywgYXJndW1lbnRzKSAvIDIsXG4gICAgICAgICAgcnAgPSAoYXAgPiBlcHNpbG9uKSAmJiAocGFkUmFkaXVzID8gK3BhZFJhZGl1cy5hcHBseSh0aGlzLCBhcmd1bWVudHMpIDogc3FydChyMCAqIHIwICsgcjEgKiByMSkpLFxuICAgICAgICAgIHJjID0gbWluKGFicyhyMSAtIHIwKSAvIDIsICtjb3JuZXJSYWRpdXMuYXBwbHkodGhpcywgYXJndW1lbnRzKSksXG4gICAgICAgICAgcmMwID0gcmMsXG4gICAgICAgICAgcmMxID0gcmMsXG4gICAgICAgICAgdDAsXG4gICAgICAgICAgdDE7XG5cbiAgICAgIC8vIEFwcGx5IHBhZGRpbmc/IE5vdGUgdGhhdCBzaW5jZSByMSDiiaUgcjAsIGRhMSDiiaUgZGEwLlxuICAgICAgaWYgKHJwID4gZXBzaWxvbikge1xuICAgICAgICB2YXIgcDAgPSBhc2luKHJwIC8gcjAgKiBzaW4oYXApKSxcbiAgICAgICAgICAgIHAxID0gYXNpbihycCAvIHIxICogc2luKGFwKSk7XG4gICAgICAgIGlmICgoZGEwIC09IHAwICogMikgPiBlcHNpbG9uKSBwMCAqPSAoY3cgPyAxIDogLTEpLCBhMDAgKz0gcDAsIGExMCAtPSBwMDtcbiAgICAgICAgZWxzZSBkYTAgPSAwLCBhMDAgPSBhMTAgPSAoYTAgKyBhMSkgLyAyO1xuICAgICAgICBpZiAoKGRhMSAtPSBwMSAqIDIpID4gZXBzaWxvbikgcDEgKj0gKGN3ID8gMSA6IC0xKSwgYTAxICs9IHAxLCBhMTEgLT0gcDE7XG4gICAgICAgIGVsc2UgZGExID0gMCwgYTAxID0gYTExID0gKGEwICsgYTEpIC8gMjtcbiAgICAgIH1cblxuICAgICAgdmFyIHgwMSA9IHIxICogY29zKGEwMSksXG4gICAgICAgICAgeTAxID0gcjEgKiBzaW4oYTAxKSxcbiAgICAgICAgICB4MTAgPSByMCAqIGNvcyhhMTApLFxuICAgICAgICAgIHkxMCA9IHIwICogc2luKGExMCk7XG5cbiAgICAgIC8vIEFwcGx5IHJvdW5kZWQgY29ybmVycz9cbiAgICAgIGlmIChyYyA+IGVwc2lsb24pIHtcbiAgICAgICAgdmFyIHgxMSA9IHIxICogY29zKGExMSksXG4gICAgICAgICAgICB5MTEgPSByMSAqIHNpbihhMTEpLFxuICAgICAgICAgICAgeDAwID0gcjAgKiBjb3MoYTAwKSxcbiAgICAgICAgICAgIHkwMCA9IHIwICogc2luKGEwMCksXG4gICAgICAgICAgICBvYztcblxuICAgICAgICAvLyBSZXN0cmljdCB0aGUgY29ybmVyIHJhZGl1cyBhY2NvcmRpbmcgdG8gdGhlIHNlY3RvciBhbmdsZS4gSWYgdGhpc1xuICAgICAgICAvLyBpbnRlcnNlY3Rpb24gZmFpbHMsIGl04oCZcyBwcm9iYWJseSBiZWNhdXNlIHRoZSBhcmMgaXMgdG9vIHNtYWxsLCBzb1xuICAgICAgICAvLyBkaXNhYmxlIHRoZSBjb3JuZXIgcmFkaXVzIGVudGlyZWx5LlxuICAgICAgICBpZiAoZGEgPCBwaSkge1xuICAgICAgICAgIGlmIChvYyA9IGludGVyc2VjdCh4MDEsIHkwMSwgeDAwLCB5MDAsIHgxMSwgeTExLCB4MTAsIHkxMCkpIHtcbiAgICAgICAgICAgIHZhciBheCA9IHgwMSAtIG9jWzBdLFxuICAgICAgICAgICAgICAgIGF5ID0geTAxIC0gb2NbMV0sXG4gICAgICAgICAgICAgICAgYnggPSB4MTEgLSBvY1swXSxcbiAgICAgICAgICAgICAgICBieSA9IHkxMSAtIG9jWzFdLFxuICAgICAgICAgICAgICAgIGtjID0gMSAvIHNpbihhY29zKChheCAqIGJ4ICsgYXkgKiBieSkgLyAoc3FydChheCAqIGF4ICsgYXkgKiBheSkgKiBzcXJ0KGJ4ICogYnggKyBieSAqIGJ5KSkpIC8gMiksXG4gICAgICAgICAgICAgICAgbGMgPSBzcXJ0KG9jWzBdICogb2NbMF0gKyBvY1sxXSAqIG9jWzFdKTtcbiAgICAgICAgICAgIHJjMCA9IG1pbihyYywgKHIwIC0gbGMpIC8gKGtjIC0gMSkpO1xuICAgICAgICAgICAgcmMxID0gbWluKHJjLCAocjEgLSBsYykgLyAoa2MgKyAxKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJjMCA9IHJjMSA9IDA7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIElzIHRoZSBzZWN0b3IgY29sbGFwc2VkIHRvIGEgbGluZT9cbiAgICAgIGlmICghKGRhMSA+IGVwc2lsb24pKSBjb250ZXh0Lm1vdmVUbyh4MDEsIHkwMSk7XG5cbiAgICAgIC8vIERvZXMgdGhlIHNlY3RvcuKAmXMgb3V0ZXIgcmluZyBoYXZlIHJvdW5kZWQgY29ybmVycz9cbiAgICAgIGVsc2UgaWYgKHJjMSA+IGVwc2lsb24pIHtcbiAgICAgICAgdDAgPSBjb3JuZXJUYW5nZW50cyh4MDAsIHkwMCwgeDAxLCB5MDEsIHIxLCByYzEsIGN3KTtcbiAgICAgICAgdDEgPSBjb3JuZXJUYW5nZW50cyh4MTEsIHkxMSwgeDEwLCB5MTAsIHIxLCByYzEsIGN3KTtcblxuICAgICAgICBjb250ZXh0Lm1vdmVUbyh0MC5jeCArIHQwLngwMSwgdDAuY3kgKyB0MC55MDEpO1xuXG4gICAgICAgIC8vIEhhdmUgdGhlIGNvcm5lcnMgbWVyZ2VkP1xuICAgICAgICBpZiAocmMxIDwgcmMpIGNvbnRleHQuYXJjKHQwLmN4LCB0MC5jeSwgcmMxLCBhdGFuMih0MC55MDEsIHQwLngwMSksIGF0YW4yKHQxLnkwMSwgdDEueDAxKSwgIWN3KTtcblxuICAgICAgICAvLyBPdGhlcndpc2UsIGRyYXcgdGhlIHR3byBjb3JuZXJzIGFuZCB0aGUgcmluZy5cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgY29udGV4dC5hcmModDAuY3gsIHQwLmN5LCByYzEsIGF0YW4yKHQwLnkwMSwgdDAueDAxKSwgYXRhbjIodDAueTExLCB0MC54MTEpLCAhY3cpO1xuICAgICAgICAgIGNvbnRleHQuYXJjKDAsIDAsIHIxLCBhdGFuMih0MC5jeSArIHQwLnkxMSwgdDAuY3ggKyB0MC54MTEpLCBhdGFuMih0MS5jeSArIHQxLnkxMSwgdDEuY3ggKyB0MS54MTEpLCAhY3cpO1xuICAgICAgICAgIGNvbnRleHQuYXJjKHQxLmN4LCB0MS5jeSwgcmMxLCBhdGFuMih0MS55MTEsIHQxLngxMSksIGF0YW4yKHQxLnkwMSwgdDEueDAxKSwgIWN3KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBPciBpcyB0aGUgb3V0ZXIgcmluZyBqdXN0IGEgY2lyY3VsYXIgYXJjP1xuICAgICAgZWxzZSBjb250ZXh0Lm1vdmVUbyh4MDEsIHkwMSksIGNvbnRleHQuYXJjKDAsIDAsIHIxLCBhMDEsIGExMSwgIWN3KTtcblxuICAgICAgLy8gSXMgdGhlcmUgbm8gaW5uZXIgcmluZywgYW5kIGl04oCZcyBhIGNpcmN1bGFyIHNlY3Rvcj9cbiAgICAgIC8vIE9yIHBlcmhhcHMgaXTigJlzIGFuIGFubnVsYXIgc2VjdG9yIGNvbGxhcHNlZCBkdWUgdG8gcGFkZGluZz9cbiAgICAgIGlmICghKHIwID4gZXBzaWxvbikgfHwgIShkYTAgPiBlcHNpbG9uKSkgY29udGV4dC5saW5lVG8oeDEwLCB5MTApO1xuXG4gICAgICAvLyBEb2VzIHRoZSBzZWN0b3LigJlzIGlubmVyIHJpbmcgKG9yIHBvaW50KSBoYXZlIHJvdW5kZWQgY29ybmVycz9cbiAgICAgIGVsc2UgaWYgKHJjMCA+IGVwc2lsb24pIHtcbiAgICAgICAgdDAgPSBjb3JuZXJUYW5nZW50cyh4MTAsIHkxMCwgeDExLCB5MTEsIHIwLCAtcmMwLCBjdyk7XG4gICAgICAgIHQxID0gY29ybmVyVGFuZ2VudHMoeDAxLCB5MDEsIHgwMCwgeTAwLCByMCwgLXJjMCwgY3cpO1xuXG4gICAgICAgIGNvbnRleHQubGluZVRvKHQwLmN4ICsgdDAueDAxLCB0MC5jeSArIHQwLnkwMSk7XG5cbiAgICAgICAgLy8gSGF2ZSB0aGUgY29ybmVycyBtZXJnZWQ/XG4gICAgICAgIGlmIChyYzAgPCByYykgY29udGV4dC5hcmModDAuY3gsIHQwLmN5LCByYzAsIGF0YW4yKHQwLnkwMSwgdDAueDAxKSwgYXRhbjIodDEueTAxLCB0MS54MDEpLCAhY3cpO1xuXG4gICAgICAgIC8vIE90aGVyd2lzZSwgZHJhdyB0aGUgdHdvIGNvcm5lcnMgYW5kIHRoZSByaW5nLlxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBjb250ZXh0LmFyYyh0MC5jeCwgdDAuY3ksIHJjMCwgYXRhbjIodDAueTAxLCB0MC54MDEpLCBhdGFuMih0MC55MTEsIHQwLngxMSksICFjdyk7XG4gICAgICAgICAgY29udGV4dC5hcmMoMCwgMCwgcjAsIGF0YW4yKHQwLmN5ICsgdDAueTExLCB0MC5jeCArIHQwLngxMSksIGF0YW4yKHQxLmN5ICsgdDEueTExLCB0MS5jeCArIHQxLngxMSksIGN3KTtcbiAgICAgICAgICBjb250ZXh0LmFyYyh0MS5jeCwgdDEuY3ksIHJjMCwgYXRhbjIodDEueTExLCB0MS54MTEpLCBhdGFuMih0MS55MDEsIHQxLngwMSksICFjdyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gT3IgaXMgdGhlIGlubmVyIHJpbmcganVzdCBhIGNpcmN1bGFyIGFyYz9cbiAgICAgIGVsc2UgY29udGV4dC5hcmMoMCwgMCwgcjAsIGExMCwgYTAwLCBjdyk7XG4gICAgfVxuXG4gICAgY29udGV4dC5jbG9zZVBhdGgoKTtcblxuICAgIGlmIChidWZmZXIpIHJldHVybiBjb250ZXh0ID0gbnVsbCwgYnVmZmVyICsgXCJcIiB8fCBudWxsO1xuICB9XG5cbiAgYXJjLmNlbnRyb2lkID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHIgPSAoK2lubmVyUmFkaXVzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgKyArb3V0ZXJSYWRpdXMuYXBwbHkodGhpcywgYXJndW1lbnRzKSkgLyAyLFxuICAgICAgICBhID0gKCtzdGFydEFuZ2xlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgKyArZW5kQW5nbGUuYXBwbHkodGhpcywgYXJndW1lbnRzKSkgLyAyIC0gcGkgLyAyO1xuICAgIHJldHVybiBbY29zKGEpICogciwgc2luKGEpICogcl07XG4gIH07XG5cbiAgYXJjLmlubmVyUmFkaXVzID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGlubmVyUmFkaXVzID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIGFyYykgOiBpbm5lclJhZGl1cztcbiAgfTtcblxuICBhcmMub3V0ZXJSYWRpdXMgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAob3V0ZXJSYWRpdXMgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgYXJjKSA6IG91dGVyUmFkaXVzO1xuICB9O1xuXG4gIGFyYy5jb3JuZXJSYWRpdXMgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoY29ybmVyUmFkaXVzID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIGFyYykgOiBjb3JuZXJSYWRpdXM7XG4gIH07XG5cbiAgYXJjLnBhZFJhZGl1cyA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChwYWRSYWRpdXMgPSBfID09IG51bGwgPyBudWxsIDogdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIGFyYykgOiBwYWRSYWRpdXM7XG4gIH07XG5cbiAgYXJjLnN0YXJ0QW5nbGUgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoc3RhcnRBbmdsZSA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCBhcmMpIDogc3RhcnRBbmdsZTtcbiAgfTtcblxuICBhcmMuZW5kQW5nbGUgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoZW5kQW5nbGUgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgYXJjKSA6IGVuZEFuZ2xlO1xuICB9O1xuXG4gIGFyYy5wYWRBbmdsZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChwYWRBbmdsZSA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCBhcmMpIDogcGFkQW5nbGU7XG4gIH07XG5cbiAgYXJjLmNvbnRleHQgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoKGNvbnRleHQgPSBfID09IG51bGwgPyBudWxsIDogXyksIGFyYykgOiBjb250ZXh0O1xuICB9O1xuXG4gIHJldHVybiBhcmM7XG59XG4iLCJpbXBvcnQgYXJyYXkgZnJvbSBcIi4vYXJyYXkuanNcIjtcbmltcG9ydCBjb25zdGFudCBmcm9tIFwiLi9jb25zdGFudC5qc1wiO1xuaW1wb3J0IGN1cnZlTGluZWFyIGZyb20gXCIuL2N1cnZlL2xpbmVhci5qc1wiO1xuaW1wb3J0IGxpbmUgZnJvbSBcIi4vbGluZS5qc1wiO1xuaW1wb3J0IHt3aXRoUGF0aH0gZnJvbSBcIi4vcGF0aC5qc1wiO1xuaW1wb3J0IHt4IGFzIHBvaW50WCwgeSBhcyBwb2ludFl9IGZyb20gXCIuL3BvaW50LmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHgwLCB5MCwgeTEpIHtcbiAgdmFyIHgxID0gbnVsbCxcbiAgICAgIGRlZmluZWQgPSBjb25zdGFudCh0cnVlKSxcbiAgICAgIGNvbnRleHQgPSBudWxsLFxuICAgICAgY3VydmUgPSBjdXJ2ZUxpbmVhcixcbiAgICAgIG91dHB1dCA9IG51bGwsXG4gICAgICBwYXRoID0gd2l0aFBhdGgoYXJlYSk7XG5cbiAgeDAgPSB0eXBlb2YgeDAgPT09IFwiZnVuY3Rpb25cIiA/IHgwIDogKHgwID09PSB1bmRlZmluZWQpID8gcG9pbnRYIDogY29uc3RhbnQoK3gwKTtcbiAgeTAgPSB0eXBlb2YgeTAgPT09IFwiZnVuY3Rpb25cIiA/IHkwIDogKHkwID09PSB1bmRlZmluZWQpID8gY29uc3RhbnQoMCkgOiBjb25zdGFudCgreTApO1xuICB5MSA9IHR5cGVvZiB5MSA9PT0gXCJmdW5jdGlvblwiID8geTEgOiAoeTEgPT09IHVuZGVmaW5lZCkgPyBwb2ludFkgOiBjb25zdGFudCgreTEpO1xuXG4gIGZ1bmN0aW9uIGFyZWEoZGF0YSkge1xuICAgIHZhciBpLFxuICAgICAgICBqLFxuICAgICAgICBrLFxuICAgICAgICBuID0gKGRhdGEgPSBhcnJheShkYXRhKSkubGVuZ3RoLFxuICAgICAgICBkLFxuICAgICAgICBkZWZpbmVkMCA9IGZhbHNlLFxuICAgICAgICBidWZmZXIsXG4gICAgICAgIHgweiA9IG5ldyBBcnJheShuKSxcbiAgICAgICAgeTB6ID0gbmV3IEFycmF5KG4pO1xuXG4gICAgaWYgKGNvbnRleHQgPT0gbnVsbCkgb3V0cHV0ID0gY3VydmUoYnVmZmVyID0gcGF0aCgpKTtcblxuICAgIGZvciAoaSA9IDA7IGkgPD0gbjsgKytpKSB7XG4gICAgICBpZiAoIShpIDwgbiAmJiBkZWZpbmVkKGQgPSBkYXRhW2ldLCBpLCBkYXRhKSkgPT09IGRlZmluZWQwKSB7XG4gICAgICAgIGlmIChkZWZpbmVkMCA9ICFkZWZpbmVkMCkge1xuICAgICAgICAgIGogPSBpO1xuICAgICAgICAgIG91dHB1dC5hcmVhU3RhcnQoKTtcbiAgICAgICAgICBvdXRwdXQubGluZVN0YXJ0KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3V0cHV0LmxpbmVFbmQoKTtcbiAgICAgICAgICBvdXRwdXQubGluZVN0YXJ0KCk7XG4gICAgICAgICAgZm9yIChrID0gaSAtIDE7IGsgPj0gajsgLS1rKSB7XG4gICAgICAgICAgICBvdXRwdXQucG9pbnQoeDB6W2tdLCB5MHpba10pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBvdXRwdXQubGluZUVuZCgpO1xuICAgICAgICAgIG91dHB1dC5hcmVhRW5kKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChkZWZpbmVkMCkge1xuICAgICAgICB4MHpbaV0gPSAreDAoZCwgaSwgZGF0YSksIHkweltpXSA9ICt5MChkLCBpLCBkYXRhKTtcbiAgICAgICAgb3V0cHV0LnBvaW50KHgxID8gK3gxKGQsIGksIGRhdGEpIDogeDB6W2ldLCB5MSA/ICt5MShkLCBpLCBkYXRhKSA6IHkweltpXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGJ1ZmZlcikgcmV0dXJuIG91dHB1dCA9IG51bGwsIGJ1ZmZlciArIFwiXCIgfHwgbnVsbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFyZWFsaW5lKCkge1xuICAgIHJldHVybiBsaW5lKCkuZGVmaW5lZChkZWZpbmVkKS5jdXJ2ZShjdXJ2ZSkuY29udGV4dChjb250ZXh0KTtcbiAgfVxuXG4gIGFyZWEueCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh4MCA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCB4MSA9IG51bGwsIGFyZWEpIDogeDA7XG4gIH07XG5cbiAgYXJlYS54MCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh4MCA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCBhcmVhKSA6IHgwO1xuICB9O1xuXG4gIGFyZWEueDEgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoeDEgPSBfID09IG51bGwgPyBudWxsIDogdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIGFyZWEpIDogeDE7XG4gIH07XG5cbiAgYXJlYS55ID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHkwID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIHkxID0gbnVsbCwgYXJlYSkgOiB5MDtcbiAgfTtcblxuICBhcmVhLnkwID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHkwID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIGFyZWEpIDogeTA7XG4gIH07XG5cbiAgYXJlYS55MSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh5MSA9IF8gPT0gbnVsbCA/IG51bGwgOiB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgYXJlYSkgOiB5MTtcbiAgfTtcblxuICBhcmVhLmxpbmVYMCA9XG4gIGFyZWEubGluZVkwID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGFyZWFsaW5lKCkueCh4MCkueSh5MCk7XG4gIH07XG5cbiAgYXJlYS5saW5lWTEgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gYXJlYWxpbmUoKS54KHgwKS55KHkxKTtcbiAgfTtcblxuICBhcmVhLmxpbmVYMSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBhcmVhbGluZSgpLngoeDEpLnkoeTApO1xuICB9O1xuXG4gIGFyZWEuZGVmaW5lZCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChkZWZpbmVkID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCghIV8pLCBhcmVhKSA6IGRlZmluZWQ7XG4gIH07XG5cbiAgYXJlYS5jdXJ2ZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChjdXJ2ZSA9IF8sIGNvbnRleHQgIT0gbnVsbCAmJiAob3V0cHV0ID0gY3VydmUoY29udGV4dCkpLCBhcmVhKSA6IGN1cnZlO1xuICB9O1xuXG4gIGFyZWEuY29udGV4dCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChfID09IG51bGwgPyBjb250ZXh0ID0gb3V0cHV0ID0gbnVsbCA6IG91dHB1dCA9IGN1cnZlKGNvbnRleHQgPSBfKSwgYXJlYSkgOiBjb250ZXh0O1xuICB9O1xuXG4gIHJldHVybiBhcmVhO1xufVxuIiwiZXhwb3J0IHZhciBzbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oeCkge1xuICByZXR1cm4gdHlwZW9mIHggPT09IFwib2JqZWN0XCIgJiYgXCJsZW5ndGhcIiBpbiB4XG4gICAgPyB4IC8vIEFycmF5LCBUeXBlZEFycmF5LCBOb2RlTGlzdCwgYXJyYXktbGlrZVxuICAgIDogQXJyYXkuZnJvbSh4KTsgLy8gTWFwLCBTZXQsIGl0ZXJhYmxlLCBzdHJpbmcsIG9yIGFueXRoaW5nIGVsc2Vcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHgpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGNvbnN0YW50KCkge1xuICAgIHJldHVybiB4O1xuICB9O1xufVxuIiwiZnVuY3Rpb24gTGluZWFyKGNvbnRleHQpIHtcbiAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XG59XG5cbkxpbmVhci5wcm90b3R5cGUgPSB7XG4gIGFyZWFTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fbGluZSA9IDA7XG4gIH0sXG4gIGFyZWFFbmQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2xpbmUgPSBOYU47XG4gIH0sXG4gIGxpbmVTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fcG9pbnQgPSAwO1xuICB9LFxuICBsaW5lRW5kOiBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5fbGluZSB8fCAodGhpcy5fbGluZSAhPT0gMCAmJiB0aGlzLl9wb2ludCA9PT0gMSkpIHRoaXMuX2NvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgdGhpcy5fbGluZSA9IDEgLSB0aGlzLl9saW5lO1xuICB9LFxuICBwb2ludDogZnVuY3Rpb24oeCwgeSkge1xuICAgIHggPSAreCwgeSA9ICt5O1xuICAgIHN3aXRjaCAodGhpcy5fcG9pbnQpIHtcbiAgICAgIGNhc2UgMDogdGhpcy5fcG9pbnQgPSAxOyB0aGlzLl9saW5lID8gdGhpcy5fY29udGV4dC5saW5lVG8oeCwgeSkgOiB0aGlzLl9jb250ZXh0Lm1vdmVUbyh4LCB5KTsgYnJlYWs7XG4gICAgICBjYXNlIDE6IHRoaXMuX3BvaW50ID0gMjsgLy8gZmFsbHMgdGhyb3VnaFxuICAgICAgZGVmYXVsdDogdGhpcy5fY29udGV4dC5saW5lVG8oeCwgeSk7IGJyZWFrO1xuICAgIH1cbiAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oY29udGV4dCkge1xuICByZXR1cm4gbmV3IExpbmVhcihjb250ZXh0KTtcbn1cbiIsImltcG9ydCBhcnJheSBmcm9tIFwiLi9hcnJheS5qc1wiO1xuaW1wb3J0IGNvbnN0YW50IGZyb20gXCIuL2NvbnN0YW50LmpzXCI7XG5pbXBvcnQgY3VydmVMaW5lYXIgZnJvbSBcIi4vY3VydmUvbGluZWFyLmpzXCI7XG5pbXBvcnQge3dpdGhQYXRofSBmcm9tIFwiLi9wYXRoLmpzXCI7XG5pbXBvcnQge3ggYXMgcG9pbnRYLCB5IGFzIHBvaW50WX0gZnJvbSBcIi4vcG9pbnQuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oeCwgeSkge1xuICB2YXIgZGVmaW5lZCA9IGNvbnN0YW50KHRydWUpLFxuICAgICAgY29udGV4dCA9IG51bGwsXG4gICAgICBjdXJ2ZSA9IGN1cnZlTGluZWFyLFxuICAgICAgb3V0cHV0ID0gbnVsbCxcbiAgICAgIHBhdGggPSB3aXRoUGF0aChsaW5lKTtcblxuICB4ID0gdHlwZW9mIHggPT09IFwiZnVuY3Rpb25cIiA/IHggOiAoeCA9PT0gdW5kZWZpbmVkKSA/IHBvaW50WCA6IGNvbnN0YW50KHgpO1xuICB5ID0gdHlwZW9mIHkgPT09IFwiZnVuY3Rpb25cIiA/IHkgOiAoeSA9PT0gdW5kZWZpbmVkKSA/IHBvaW50WSA6IGNvbnN0YW50KHkpO1xuXG4gIGZ1bmN0aW9uIGxpbmUoZGF0YSkge1xuICAgIHZhciBpLFxuICAgICAgICBuID0gKGRhdGEgPSBhcnJheShkYXRhKSkubGVuZ3RoLFxuICAgICAgICBkLFxuICAgICAgICBkZWZpbmVkMCA9IGZhbHNlLFxuICAgICAgICBidWZmZXI7XG5cbiAgICBpZiAoY29udGV4dCA9PSBudWxsKSBvdXRwdXQgPSBjdXJ2ZShidWZmZXIgPSBwYXRoKCkpO1xuXG4gICAgZm9yIChpID0gMDsgaSA8PSBuOyArK2kpIHtcbiAgICAgIGlmICghKGkgPCBuICYmIGRlZmluZWQoZCA9IGRhdGFbaV0sIGksIGRhdGEpKSA9PT0gZGVmaW5lZDApIHtcbiAgICAgICAgaWYgKGRlZmluZWQwID0gIWRlZmluZWQwKSBvdXRwdXQubGluZVN0YXJ0KCk7XG4gICAgICAgIGVsc2Ugb3V0cHV0LmxpbmVFbmQoKTtcbiAgICAgIH1cbiAgICAgIGlmIChkZWZpbmVkMCkgb3V0cHV0LnBvaW50KCt4KGQsIGksIGRhdGEpLCAreShkLCBpLCBkYXRhKSk7XG4gICAgfVxuXG4gICAgaWYgKGJ1ZmZlcikgcmV0dXJuIG91dHB1dCA9IG51bGwsIGJ1ZmZlciArIFwiXCIgfHwgbnVsbDtcbiAgfVxuXG4gIGxpbmUueCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh4ID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIGxpbmUpIDogeDtcbiAgfTtcblxuICBsaW5lLnkgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoeSA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCBsaW5lKSA6IHk7XG4gIH07XG5cbiAgbGluZS5kZWZpbmVkID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGRlZmluZWQgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCEhXyksIGxpbmUpIDogZGVmaW5lZDtcbiAgfTtcblxuICBsaW5lLmN1cnZlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGN1cnZlID0gXywgY29udGV4dCAhPSBudWxsICYmIChvdXRwdXQgPSBjdXJ2ZShjb250ZXh0KSksIGxpbmUpIDogY3VydmU7XG4gIH07XG5cbiAgbGluZS5jb250ZXh0ID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKF8gPT0gbnVsbCA/IGNvbnRleHQgPSBvdXRwdXQgPSBudWxsIDogb3V0cHV0ID0gY3VydmUoY29udGV4dCA9IF8pLCBsaW5lKSA6IGNvbnRleHQ7XG4gIH07XG5cbiAgcmV0dXJuIGxpbmU7XG59XG4iLCJleHBvcnQgY29uc3QgYWJzID0gTWF0aC5hYnM7XG5leHBvcnQgY29uc3QgYXRhbjIgPSBNYXRoLmF0YW4yO1xuZXhwb3J0IGNvbnN0IGNvcyA9IE1hdGguY29zO1xuZXhwb3J0IGNvbnN0IG1heCA9IE1hdGgubWF4O1xuZXhwb3J0IGNvbnN0IG1pbiA9IE1hdGgubWluO1xuZXhwb3J0IGNvbnN0IHNpbiA9IE1hdGguc2luO1xuZXhwb3J0IGNvbnN0IHNxcnQgPSBNYXRoLnNxcnQ7XG5cbmV4cG9ydCBjb25zdCBlcHNpbG9uID0gMWUtMTI7XG5leHBvcnQgY29uc3QgcGkgPSBNYXRoLlBJO1xuZXhwb3J0IGNvbnN0IGhhbGZQaSA9IHBpIC8gMjtcbmV4cG9ydCBjb25zdCB0YXUgPSAyICogcGk7XG5cbmV4cG9ydCBmdW5jdGlvbiBhY29zKHgpIHtcbiAgcmV0dXJuIHggPiAxID8gMCA6IHggPCAtMSA/IHBpIDogTWF0aC5hY29zKHgpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYXNpbih4KSB7XG4gIHJldHVybiB4ID49IDEgPyBoYWxmUGkgOiB4IDw9IC0xID8gLWhhbGZQaSA6IE1hdGguYXNpbih4KTtcbn1cbiIsImltcG9ydCB7UGF0aH0gZnJvbSBcImQzLXBhdGhcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIHdpdGhQYXRoKHNoYXBlKSB7XG4gIGxldCBkaWdpdHMgPSAzO1xuXG4gIHNoYXBlLmRpZ2l0cyA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBkaWdpdHM7XG4gICAgaWYgKF8gPT0gbnVsbCkge1xuICAgICAgZGlnaXRzID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgZCA9IE1hdGguZmxvb3IoXyk7XG4gICAgICBpZiAoIShkID49IDApKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgaW52YWxpZCBkaWdpdHM6ICR7X31gKTtcbiAgICAgIGRpZ2l0cyA9IGQ7XG4gICAgfVxuICAgIHJldHVybiBzaGFwZTtcbiAgfTtcblxuICByZXR1cm4gKCkgPT4gbmV3IFBhdGgoZGlnaXRzKTtcbn1cbiIsImV4cG9ydCBmdW5jdGlvbiB4KHApIHtcbiAgcmV0dXJuIHBbMF07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB5KHApIHtcbiAgcmV0dXJuIHBbMV07XG59XG4iLCIvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cblxuUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XG5wdXJwb3NlIHdpdGggb3Igd2l0aG91dCBmZWUgaXMgaGVyZWJ5IGdyYW50ZWQuXG5cblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTIFdJVEhcblJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWVxuQU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUiBBTlkgU1BFQ0lBTCwgRElSRUNULFxuSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFUyBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NXG5MT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUlxuT1RIRVIgVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUlxuUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXG4vKiBnbG9iYWwgUmVmbGVjdCwgUHJvbWlzZSwgU3VwcHJlc3NlZEVycm9yLCBTeW1ib2wgKi9cblxudmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbihkLCBiKSB7XG4gIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XG4gIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIF9fZXh0ZW5kcyhkLCBiKSB7XG4gIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59XG5cbmV4cG9ydCB2YXIgX19hc3NpZ24gPSBmdW5jdGlvbigpIHtcbiAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uIF9fYXNzaWduKHQpIHtcbiAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKSB0W3BdID0gc1twXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0O1xuICB9XG4gIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX19yZXN0KHMsIGUpIHtcbiAgdmFyIHQgPSB7fTtcbiAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApICYmIGUuaW5kZXhPZihwKSA8IDApXG4gICAgICB0W3BdID0gc1twXTtcbiAgaWYgKHMgIT0gbnVsbCAmJiB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gXCJmdW5jdGlvblwiKVxuICAgICAgZm9yICh2YXIgaSA9IDAsIHAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHMpOyBpIDwgcC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmIChlLmluZGV4T2YocFtpXSkgPCAwICYmIE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzLCBwW2ldKSlcbiAgICAgICAgICAgICAgdFtwW2ldXSA9IHNbcFtpXV07XG4gICAgICB9XG4gIHJldHVybiB0O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX19kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX19wYXJhbShwYXJhbUluZGV4LCBkZWNvcmF0b3IpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQsIGtleSkgeyBkZWNvcmF0b3IodGFyZ2V0LCBrZXksIHBhcmFtSW5kZXgpOyB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfX2VzRGVjb3JhdGUoY3RvciwgZGVzY3JpcHRvckluLCBkZWNvcmF0b3JzLCBjb250ZXh0SW4sIGluaXRpYWxpemVycywgZXh0cmFJbml0aWFsaXplcnMpIHtcbiAgZnVuY3Rpb24gYWNjZXB0KGYpIHsgaWYgKGYgIT09IHZvaWQgMCAmJiB0eXBlb2YgZiAhPT0gXCJmdW5jdGlvblwiKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRnVuY3Rpb24gZXhwZWN0ZWRcIik7IHJldHVybiBmOyB9XG4gIHZhciBraW5kID0gY29udGV4dEluLmtpbmQsIGtleSA9IGtpbmQgPT09IFwiZ2V0dGVyXCIgPyBcImdldFwiIDoga2luZCA9PT0gXCJzZXR0ZXJcIiA/IFwic2V0XCIgOiBcInZhbHVlXCI7XG4gIHZhciB0YXJnZXQgPSAhZGVzY3JpcHRvckluICYmIGN0b3IgPyBjb250ZXh0SW5bXCJzdGF0aWNcIl0gPyBjdG9yIDogY3Rvci5wcm90b3R5cGUgOiBudWxsO1xuICB2YXIgZGVzY3JpcHRvciA9IGRlc2NyaXB0b3JJbiB8fCAodGFyZ2V0ID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGNvbnRleHRJbi5uYW1lKSA6IHt9KTtcbiAgdmFyIF8sIGRvbmUgPSBmYWxzZTtcbiAgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHZhciBjb250ZXh0ID0ge307XG4gICAgICBmb3IgKHZhciBwIGluIGNvbnRleHRJbikgY29udGV4dFtwXSA9IHAgPT09IFwiYWNjZXNzXCIgPyB7fSA6IGNvbnRleHRJbltwXTtcbiAgICAgIGZvciAodmFyIHAgaW4gY29udGV4dEluLmFjY2VzcykgY29udGV4dC5hY2Nlc3NbcF0gPSBjb250ZXh0SW4uYWNjZXNzW3BdO1xuICAgICAgY29udGV4dC5hZGRJbml0aWFsaXplciA9IGZ1bmN0aW9uIChmKSB7IGlmIChkb25lKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGFkZCBpbml0aWFsaXplcnMgYWZ0ZXIgZGVjb3JhdGlvbiBoYXMgY29tcGxldGVkXCIpOyBleHRyYUluaXRpYWxpemVycy5wdXNoKGFjY2VwdChmIHx8IG51bGwpKTsgfTtcbiAgICAgIHZhciByZXN1bHQgPSAoMCwgZGVjb3JhdG9yc1tpXSkoa2luZCA9PT0gXCJhY2Nlc3NvclwiID8geyBnZXQ6IGRlc2NyaXB0b3IuZ2V0LCBzZXQ6IGRlc2NyaXB0b3Iuc2V0IH0gOiBkZXNjcmlwdG9yW2tleV0sIGNvbnRleHQpO1xuICAgICAgaWYgKGtpbmQgPT09IFwiYWNjZXNzb3JcIikge1xuICAgICAgICAgIGlmIChyZXN1bHQgPT09IHZvaWQgMCkgY29udGludWU7XG4gICAgICAgICAgaWYgKHJlc3VsdCA9PT0gbnVsbCB8fCB0eXBlb2YgcmVzdWx0ICE9PSBcIm9iamVjdFwiKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiT2JqZWN0IGV4cGVjdGVkXCIpO1xuICAgICAgICAgIGlmIChfID0gYWNjZXB0KHJlc3VsdC5nZXQpKSBkZXNjcmlwdG9yLmdldCA9IF87XG4gICAgICAgICAgaWYgKF8gPSBhY2NlcHQocmVzdWx0LnNldCkpIGRlc2NyaXB0b3Iuc2V0ID0gXztcbiAgICAgICAgICBpZiAoXyA9IGFjY2VwdChyZXN1bHQuaW5pdCkpIGluaXRpYWxpemVycy51bnNoaWZ0KF8pO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoXyA9IGFjY2VwdChyZXN1bHQpKSB7XG4gICAgICAgICAgaWYgKGtpbmQgPT09IFwiZmllbGRcIikgaW5pdGlhbGl6ZXJzLnVuc2hpZnQoXyk7XG4gICAgICAgICAgZWxzZSBkZXNjcmlwdG9yW2tleV0gPSBfO1xuICAgICAgfVxuICB9XG4gIGlmICh0YXJnZXQpIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGNvbnRleHRJbi5uYW1lLCBkZXNjcmlwdG9yKTtcbiAgZG9uZSA9IHRydWU7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gX19ydW5Jbml0aWFsaXplcnModGhpc0FyZywgaW5pdGlhbGl6ZXJzLCB2YWx1ZSkge1xuICB2YXIgdXNlVmFsdWUgPSBhcmd1bWVudHMubGVuZ3RoID4gMjtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbml0aWFsaXplcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhbHVlID0gdXNlVmFsdWUgPyBpbml0aWFsaXplcnNbaV0uY2FsbCh0aGlzQXJnLCB2YWx1ZSkgOiBpbml0aWFsaXplcnNbaV0uY2FsbCh0aGlzQXJnKTtcbiAgfVxuICByZXR1cm4gdXNlVmFsdWUgPyB2YWx1ZSA6IHZvaWQgMDtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBfX3Byb3BLZXkoeCkge1xuICByZXR1cm4gdHlwZW9mIHggPT09IFwic3ltYm9sXCIgPyB4IDogXCJcIi5jb25jYXQoeCk7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gX19zZXRGdW5jdGlvbk5hbWUoZiwgbmFtZSwgcHJlZml4KSB7XG4gIGlmICh0eXBlb2YgbmFtZSA9PT0gXCJzeW1ib2xcIikgbmFtZSA9IG5hbWUuZGVzY3JpcHRpb24gPyBcIltcIi5jb25jYXQobmFtZS5kZXNjcmlwdGlvbiwgXCJdXCIpIDogXCJcIjtcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShmLCBcIm5hbWVcIiwgeyBjb25maWd1cmFibGU6IHRydWUsIHZhbHVlOiBwcmVmaXggPyBcIlwiLmNvbmNhdChwcmVmaXgsIFwiIFwiLCBuYW1lKSA6IG5hbWUgfSk7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gX19tZXRhZGF0YShtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSkge1xuICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX19hd2FpdGVyKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX19nZW5lcmF0b3IodGhpc0FyZywgYm9keSkge1xuICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xuICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcbiAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XG4gIGZ1bmN0aW9uIHN0ZXAob3ApIHtcbiAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcbiAgICAgIHdoaWxlIChnICYmIChnID0gMCwgb3BbMF0gJiYgKF8gPSAwKSksIF8pIHRyeSB7XG4gICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xuICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcbiAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XG4gICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XG4gICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxuICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XG4gICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XG4gICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcbiAgfVxufVxuXG5leHBvcnQgdmFyIF9fY3JlYXRlQmluZGluZyA9IE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgfVxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgb1trMl0gPSBtW2tdO1xufSk7XG5cbmV4cG9ydCBmdW5jdGlvbiBfX2V4cG9ydFN0YXIobSwgbykge1xuICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG8sIHApKSBfX2NyZWF0ZUJpbmRpbmcobywgbSwgcCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfX3ZhbHVlcyhvKSB7XG4gIHZhciBzID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIFN5bWJvbC5pdGVyYXRvciwgbSA9IHMgJiYgb1tzXSwgaSA9IDA7XG4gIGlmIChtKSByZXR1cm4gbS5jYWxsKG8pO1xuICBpZiAobyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHJldHVybiB7XG4gICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKG8gJiYgaSA+PSBvLmxlbmd0aCkgbyA9IHZvaWQgMDtcbiAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbyAmJiBvW2krK10sIGRvbmU6ICFvIH07XG4gICAgICB9XG4gIH07XG4gIHRocm93IG5ldyBUeXBlRXJyb3IocyA/IFwiT2JqZWN0IGlzIG5vdCBpdGVyYWJsZS5cIiA6IFwiU3ltYm9sLml0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9fcmVhZChvLCBuKSB7XG4gIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXTtcbiAgaWYgKCFtKSByZXR1cm4gbztcbiAgdmFyIGkgPSBtLmNhbGwobyksIHIsIGFyID0gW10sIGU7XG4gIHRyeSB7XG4gICAgICB3aGlsZSAoKG4gPT09IHZvaWQgMCB8fCBuLS0gPiAwKSAmJiAhKHIgPSBpLm5leHQoKSkuZG9uZSkgYXIucHVzaChyLnZhbHVlKTtcbiAgfVxuICBjYXRjaCAoZXJyb3IpIHsgZSA9IHsgZXJyb3I6IGVycm9yIH07IH1cbiAgZmluYWxseSB7XG4gICAgICB0cnkge1xuICAgICAgICAgIGlmIChyICYmICFyLmRvbmUgJiYgKG0gPSBpW1wicmV0dXJuXCJdKSkgbS5jYWxsKGkpO1xuICAgICAgfVxuICAgICAgZmluYWxseSB7IGlmIChlKSB0aHJvdyBlLmVycm9yOyB9XG4gIH1cbiAgcmV0dXJuIGFyO1xufVxuXG4vKiogQGRlcHJlY2F0ZWQgKi9cbmV4cG9ydCBmdW5jdGlvbiBfX3NwcmVhZCgpIHtcbiAgZm9yICh2YXIgYXIgPSBbXSwgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspXG4gICAgICBhciA9IGFyLmNvbmNhdChfX3JlYWQoYXJndW1lbnRzW2ldKSk7XG4gIHJldHVybiBhcjtcbn1cblxuLyoqIEBkZXByZWNhdGVkICovXG5leHBvcnQgZnVuY3Rpb24gX19zcHJlYWRBcnJheXMoKSB7XG4gIGZvciAodmFyIHMgPSAwLCBpID0gMCwgaWwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgaWw7IGkrKykgcyArPSBhcmd1bWVudHNbaV0ubGVuZ3RoO1xuICBmb3IgKHZhciByID0gQXJyYXkocyksIGsgPSAwLCBpID0gMDsgaSA8IGlsOyBpKyspXG4gICAgICBmb3IgKHZhciBhID0gYXJndW1lbnRzW2ldLCBqID0gMCwgamwgPSBhLmxlbmd0aDsgaiA8IGpsOyBqKyssIGsrKylcbiAgICAgICAgICByW2tdID0gYVtqXTtcbiAgcmV0dXJuIHI7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfX3NwcmVhZEFycmF5KHRvLCBmcm9tLCBwYWNrKSB7XG4gIGlmIChwYWNrIHx8IGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIGZvciAodmFyIGkgPSAwLCBsID0gZnJvbS5sZW5ndGgsIGFyOyBpIDwgbDsgaSsrKSB7XG4gICAgICBpZiAoYXIgfHwgIShpIGluIGZyb20pKSB7XG4gICAgICAgICAgaWYgKCFhcikgYXIgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tLCAwLCBpKTtcbiAgICAgICAgICBhcltpXSA9IGZyb21baV07XG4gICAgICB9XG4gIH1cbiAgcmV0dXJuIHRvLmNvbmNhdChhciB8fCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tKSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfX2F3YWl0KHYpIHtcbiAgcmV0dXJuIHRoaXMgaW5zdGFuY2VvZiBfX2F3YWl0ID8gKHRoaXMudiA9IHYsIHRoaXMpIDogbmV3IF9fYXdhaXQodik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfX2FzeW5jR2VuZXJhdG9yKHRoaXNBcmcsIF9hcmd1bWVudHMsIGdlbmVyYXRvcikge1xuICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xuICB2YXIgZyA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSwgaSwgcSA9IFtdO1xuICByZXR1cm4gaSA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIpLCB2ZXJiKFwicmV0dXJuXCIpLCBpW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGk7XG4gIGZ1bmN0aW9uIHZlcmIobikgeyBpZiAoZ1tuXSkgaVtuXSA9IGZ1bmN0aW9uICh2KSB7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAoYSwgYikgeyBxLnB1c2goW24sIHYsIGEsIGJdKSA+IDEgfHwgcmVzdW1lKG4sIHYpOyB9KTsgfTsgfVxuICBmdW5jdGlvbiByZXN1bWUobiwgdikgeyB0cnkgeyBzdGVwKGdbbl0odikpOyB9IGNhdGNoIChlKSB7IHNldHRsZShxWzBdWzNdLCBlKTsgfSB9XG4gIGZ1bmN0aW9uIHN0ZXAocikgeyByLnZhbHVlIGluc3RhbmNlb2YgX19hd2FpdCA/IFByb21pc2UucmVzb2x2ZShyLnZhbHVlLnYpLnRoZW4oZnVsZmlsbCwgcmVqZWN0KSA6IHNldHRsZShxWzBdWzJdLCByKTsgfVxuICBmdW5jdGlvbiBmdWxmaWxsKHZhbHVlKSB7IHJlc3VtZShcIm5leHRcIiwgdmFsdWUpOyB9XG4gIGZ1bmN0aW9uIHJlamVjdCh2YWx1ZSkgeyByZXN1bWUoXCJ0aHJvd1wiLCB2YWx1ZSk7IH1cbiAgZnVuY3Rpb24gc2V0dGxlKGYsIHYpIHsgaWYgKGYodiksIHEuc2hpZnQoKSwgcS5sZW5ndGgpIHJlc3VtZShxWzBdWzBdLCBxWzBdWzFdKTsgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gX19hc3luY0RlbGVnYXRvcihvKSB7XG4gIHZhciBpLCBwO1xuICByZXR1cm4gaSA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIsIGZ1bmN0aW9uIChlKSB7IHRocm93IGU7IH0pLCB2ZXJiKFwicmV0dXJuXCIpLCBpW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpO1xuICBmdW5jdGlvbiB2ZXJiKG4sIGYpIHsgaVtuXSA9IG9bbl0gPyBmdW5jdGlvbiAodikgeyByZXR1cm4gKHAgPSAhcCkgPyB7IHZhbHVlOiBfX2F3YWl0KG9bbl0odikpLCBkb25lOiBmYWxzZSB9IDogZiA/IGYodikgOiB2OyB9IDogZjsgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gX19hc3luY1ZhbHVlcyhvKSB7XG4gIGlmICghU3ltYm9sLmFzeW5jSXRlcmF0b3IpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuYXN5bmNJdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XG4gIHZhciBtID0gb1tTeW1ib2wuYXN5bmNJdGVyYXRvcl0sIGk7XG4gIHJldHVybiBtID8gbS5jYWxsKG8pIDogKG8gPSB0eXBlb2YgX192YWx1ZXMgPT09IFwiZnVuY3Rpb25cIiA/IF9fdmFsdWVzKG8pIDogb1tTeW1ib2wuaXRlcmF0b3JdKCksIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiKSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpKTtcbiAgZnVuY3Rpb24gdmVyYihuKSB7IGlbbl0gPSBvW25dICYmIGZ1bmN0aW9uICh2KSB7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7IHYgPSBvW25dKHYpLCBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCB2LmRvbmUsIHYudmFsdWUpOyB9KTsgfTsgfVxuICBmdW5jdGlvbiBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCBkLCB2KSB7IFByb21pc2UucmVzb2x2ZSh2KS50aGVuKGZ1bmN0aW9uKHYpIHsgcmVzb2x2ZSh7IHZhbHVlOiB2LCBkb25lOiBkIH0pOyB9LCByZWplY3QpOyB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfX21ha2VUZW1wbGF0ZU9iamVjdChjb29rZWQsIHJhdykge1xuICBpZiAoT2JqZWN0LmRlZmluZVByb3BlcnR5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjb29rZWQsIFwicmF3XCIsIHsgdmFsdWU6IHJhdyB9KTsgfSBlbHNlIHsgY29va2VkLnJhdyA9IHJhdzsgfVxuICByZXR1cm4gY29va2VkO1xufTtcblxudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9IE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgb1tcImRlZmF1bHRcIl0gPSB2O1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIF9faW1wb3J0U3Rhcihtb2QpIHtcbiAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgdmFyIHJlc3VsdCA9IHt9O1xuICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfX2ltcG9ydERlZmF1bHQobW9kKSB7XG4gIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgZGVmYXVsdDogbW9kIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHJlY2VpdmVyLCBzdGF0ZSwga2luZCwgZikge1xuICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBnZXR0ZXJcIik7XG4gIGlmICh0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyICE9PSBzdGF0ZSB8fCAhZiA6ICFzdGF0ZS5oYXMocmVjZWl2ZXIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHJlYWQgcHJpdmF0ZSBtZW1iZXIgZnJvbSBhbiBvYmplY3Qgd2hvc2UgY2xhc3MgZGlkIG5vdCBkZWNsYXJlIGl0XCIpO1xuICByZXR1cm4ga2luZCA9PT0gXCJtXCIgPyBmIDoga2luZCA9PT0gXCJhXCIgPyBmLmNhbGwocmVjZWl2ZXIpIDogZiA/IGYudmFsdWUgOiBzdGF0ZS5nZXQocmVjZWl2ZXIpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX19jbGFzc1ByaXZhdGVGaWVsZFNldChyZWNlaXZlciwgc3RhdGUsIHZhbHVlLCBraW5kLCBmKSB7XG4gIGlmIChraW5kID09PSBcIm1cIikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgbWV0aG9kIGlzIG5vdCB3cml0YWJsZVwiKTtcbiAgaWYgKGtpbmQgPT09IFwiYVwiICYmICFmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBhY2Nlc3NvciB3YXMgZGVmaW5lZCB3aXRob3V0IGEgc2V0dGVyXCIpO1xuICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCB3cml0ZSBwcml2YXRlIG1lbWJlciB0byBhbiBvYmplY3Qgd2hvc2UgY2xhc3MgZGlkIG5vdCBkZWNsYXJlIGl0XCIpO1xuICByZXR1cm4gKGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyLCB2YWx1ZSkgOiBmID8gZi52YWx1ZSA9IHZhbHVlIDogc3RhdGUuc2V0KHJlY2VpdmVyLCB2YWx1ZSkpLCB2YWx1ZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9fY2xhc3NQcml2YXRlRmllbGRJbihzdGF0ZSwgcmVjZWl2ZXIpIHtcbiAgaWYgKHJlY2VpdmVyID09PSBudWxsIHx8ICh0eXBlb2YgcmVjZWl2ZXIgIT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIHJlY2VpdmVyICE9PSBcImZ1bmN0aW9uXCIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHVzZSAnaW4nIG9wZXJhdG9yIG9uIG5vbi1vYmplY3RcIik7XG4gIHJldHVybiB0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyID09PSBzdGF0ZSA6IHN0YXRlLmhhcyhyZWNlaXZlcik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfX2FkZERpc3Bvc2FibGVSZXNvdXJjZShlbnYsIHZhbHVlLCBhc3luYykge1xuICBpZiAodmFsdWUgIT09IG51bGwgJiYgdmFsdWUgIT09IHZvaWQgMCkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIHZhbHVlICE9PSBcImZ1bmN0aW9uXCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJPYmplY3QgZXhwZWN0ZWQuXCIpO1xuICAgIHZhciBkaXNwb3NlO1xuICAgIGlmIChhc3luYykge1xuICAgICAgICBpZiAoIVN5bWJvbC5hc3luY0Rpc3Bvc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuYXN5bmNEaXNwb3NlIGlzIG5vdCBkZWZpbmVkLlwiKTtcbiAgICAgICAgZGlzcG9zZSA9IHZhbHVlW1N5bWJvbC5hc3luY0Rpc3Bvc2VdO1xuICAgIH1cbiAgICBpZiAoZGlzcG9zZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGlmICghU3ltYm9sLmRpc3Bvc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuZGlzcG9zZSBpcyBub3QgZGVmaW5lZC5cIik7XG4gICAgICAgIGRpc3Bvc2UgPSB2YWx1ZVtTeW1ib2wuZGlzcG9zZV07XG4gICAgfVxuICAgIGlmICh0eXBlb2YgZGlzcG9zZSAhPT0gXCJmdW5jdGlvblwiKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiT2JqZWN0IG5vdCBkaXNwb3NhYmxlLlwiKTtcbiAgICBlbnYuc3RhY2sucHVzaCh7IHZhbHVlOiB2YWx1ZSwgZGlzcG9zZTogZGlzcG9zZSwgYXN5bmM6IGFzeW5jIH0pO1xuICB9XG4gIGVsc2UgaWYgKGFzeW5jKSB7XG4gICAgZW52LnN0YWNrLnB1c2goeyBhc3luYzogdHJ1ZSB9KTtcbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG5cbnZhciBfU3VwcHJlc3NlZEVycm9yID0gdHlwZW9mIFN1cHByZXNzZWRFcnJvciA9PT0gXCJmdW5jdGlvblwiID8gU3VwcHJlc3NlZEVycm9yIDogZnVuY3Rpb24gKGVycm9yLCBzdXBwcmVzc2VkLCBtZXNzYWdlKSB7XG4gIHZhciBlID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xuICByZXR1cm4gZS5uYW1lID0gXCJTdXBwcmVzc2VkRXJyb3JcIiwgZS5lcnJvciA9IGVycm9yLCBlLnN1cHByZXNzZWQgPSBzdXBwcmVzc2VkLCBlO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIF9fZGlzcG9zZVJlc291cmNlcyhlbnYpIHtcbiAgZnVuY3Rpb24gZmFpbChlKSB7XG4gICAgZW52LmVycm9yID0gZW52Lmhhc0Vycm9yID8gbmV3IF9TdXBwcmVzc2VkRXJyb3IoZSwgZW52LmVycm9yLCBcIkFuIGVycm9yIHdhcyBzdXBwcmVzc2VkIGR1cmluZyBkaXNwb3NhbC5cIikgOiBlO1xuICAgIGVudi5oYXNFcnJvciA9IHRydWU7XG4gIH1cbiAgZnVuY3Rpb24gbmV4dCgpIHtcbiAgICB3aGlsZSAoZW52LnN0YWNrLmxlbmd0aCkge1xuICAgICAgdmFyIHJlYyA9IGVudi5zdGFjay5wb3AoKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciByZXN1bHQgPSByZWMuZGlzcG9zZSAmJiByZWMuZGlzcG9zZS5jYWxsKHJlYy52YWx1ZSk7XG4gICAgICAgIGlmIChyZWMuYXN5bmMpIHJldHVybiBQcm9taXNlLnJlc29sdmUocmVzdWx0KS50aGVuKG5leHQsIGZ1bmN0aW9uKGUpIHsgZmFpbChlKTsgcmV0dXJuIG5leHQoKTsgfSk7XG4gICAgICB9XG4gICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgIGZhaWwoZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChlbnYuaGFzRXJyb3IpIHRocm93IGVudi5lcnJvcjtcbiAgfVxuICByZXR1cm4gbmV4dCgpO1xufVxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIF9fZXh0ZW5kcyxcbiAgX19hc3NpZ24sXG4gIF9fcmVzdCxcbiAgX19kZWNvcmF0ZSxcbiAgX19wYXJhbSxcbiAgX19tZXRhZGF0YSxcbiAgX19hd2FpdGVyLFxuICBfX2dlbmVyYXRvcixcbiAgX19jcmVhdGVCaW5kaW5nLFxuICBfX2V4cG9ydFN0YXIsXG4gIF9fdmFsdWVzLFxuICBfX3JlYWQsXG4gIF9fc3ByZWFkLFxuICBfX3NwcmVhZEFycmF5cyxcbiAgX19zcHJlYWRBcnJheSxcbiAgX19hd2FpdCxcbiAgX19hc3luY0dlbmVyYXRvcixcbiAgX19hc3luY0RlbGVnYXRvcixcbiAgX19hc3luY1ZhbHVlcyxcbiAgX19tYWtlVGVtcGxhdGVPYmplY3QsXG4gIF9faW1wb3J0U3RhcixcbiAgX19pbXBvcnREZWZhdWx0LFxuICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0LFxuICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0LFxuICBfX2NsYXNzUHJpdmF0ZUZpZWxkSW4sXG4gIF9fYWRkRGlzcG9zYWJsZVJlc291cmNlLFxuICBfX2Rpc3Bvc2VSZXNvdXJjZXMsXG59O1xuIiwiLy8gVGhlIG1vZHVsZSBjYWNoZVxudmFyIF9fd2VicGFja19tb2R1bGVfY2FjaGVfXyA9IHt9O1xuXG4vLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcblx0dmFyIGNhY2hlZE1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF07XG5cdGlmIChjYWNoZWRNb2R1bGUgIT09IHVuZGVmaW5lZCkge1xuXHRcdHJldHVybiBjYWNoZWRNb2R1bGUuZXhwb3J0cztcblx0fVxuXHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuXHR2YXIgbW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXSA9IHtcblx0XHQvLyBubyBtb2R1bGUuaWQgbmVlZGVkXG5cdFx0Ly8gbm8gbW9kdWxlLmxvYWRlZCBuZWVkZWRcblx0XHRleHBvcnRzOiB7fVxuXHR9O1xuXG5cdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuXHRfX3dlYnBhY2tfbW9kdWxlc19fW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuXHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuXHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG59XG5cbi8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG5fX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBfX3dlYnBhY2tfbW9kdWxlc19fO1xuXG4iLCJ2YXIgZ2V0UHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YgPyAob2JqKSA9PiAoT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iaikpIDogKG9iaikgPT4gKG9iai5fX3Byb3RvX18pO1xudmFyIGxlYWZQcm90b3R5cGVzO1xuLy8gY3JlYXRlIGEgZmFrZSBuYW1lc3BhY2Ugb2JqZWN0XG4vLyBtb2RlICYgMTogdmFsdWUgaXMgYSBtb2R1bGUgaWQsIHJlcXVpcmUgaXRcbi8vIG1vZGUgJiAyOiBtZXJnZSBhbGwgcHJvcGVydGllcyBvZiB2YWx1ZSBpbnRvIHRoZSBuc1xuLy8gbW9kZSAmIDQ6IHJldHVybiB2YWx1ZSB3aGVuIGFscmVhZHkgbnMgb2JqZWN0XG4vLyBtb2RlICYgMTY6IHJldHVybiB2YWx1ZSB3aGVuIGl0J3MgUHJvbWlzZS1saWtlXG4vLyBtb2RlICYgOHwxOiBiZWhhdmUgbGlrZSByZXF1aXJlXG5fX3dlYnBhY2tfcmVxdWlyZV9fLnQgPSBmdW5jdGlvbih2YWx1ZSwgbW9kZSkge1xuXHRpZihtb2RlICYgMSkgdmFsdWUgPSB0aGlzKHZhbHVlKTtcblx0aWYobW9kZSAmIDgpIHJldHVybiB2YWx1ZTtcblx0aWYodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSkge1xuXHRcdGlmKChtb2RlICYgNCkgJiYgdmFsdWUuX19lc01vZHVsZSkgcmV0dXJuIHZhbHVlO1xuXHRcdGlmKChtb2RlICYgMTYpICYmIHR5cGVvZiB2YWx1ZS50aGVuID09PSAnZnVuY3Rpb24nKSByZXR1cm4gdmFsdWU7XG5cdH1cblx0dmFyIG5zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblx0X193ZWJwYWNrX3JlcXVpcmVfXy5yKG5zKTtcblx0dmFyIGRlZiA9IHt9O1xuXHRsZWFmUHJvdG90eXBlcyA9IGxlYWZQcm90b3R5cGVzIHx8IFtudWxsLCBnZXRQcm90byh7fSksIGdldFByb3RvKFtdKSwgZ2V0UHJvdG8oZ2V0UHJvdG8pXTtcblx0Zm9yKHZhciBjdXJyZW50ID0gbW9kZSAmIDIgJiYgdmFsdWU7IHR5cGVvZiBjdXJyZW50ID09ICdvYmplY3QnICYmICF+bGVhZlByb3RvdHlwZXMuaW5kZXhPZihjdXJyZW50KTsgY3VycmVudCA9IGdldFByb3RvKGN1cnJlbnQpKSB7XG5cdFx0T2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoY3VycmVudCkuZm9yRWFjaCgoa2V5KSA9PiAoZGVmW2tleV0gPSAoKSA9PiAodmFsdWVba2V5XSkpKTtcblx0fVxuXHRkZWZbJ2RlZmF1bHQnXSA9ICgpID0+ICh2YWx1ZSk7XG5cdF9fd2VicGFja19yZXF1aXJlX18uZChucywgZGVmKTtcblx0cmV0dXJuIG5zO1xufTsiLCIvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9ucyBmb3IgaGFybW9ueSBleHBvcnRzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSAoZXhwb3J0cywgZGVmaW5pdGlvbikgPT4ge1xuXHRmb3IodmFyIGtleSBpbiBkZWZpbml0aW9uKSB7XG5cdFx0aWYoX193ZWJwYWNrX3JlcXVpcmVfXy5vKGRlZmluaXRpb24sIGtleSkgJiYgIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBrZXkpKSB7XG5cdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZGVmaW5pdGlvbltrZXldIH0pO1xuXHRcdH1cblx0fVxufTsiLCJfX3dlYnBhY2tfcmVxdWlyZV9fLmYgPSB7fTtcbi8vIFRoaXMgZmlsZSBjb250YWlucyBvbmx5IHRoZSBlbnRyeSBjaHVuay5cbi8vIFRoZSBjaHVuayBsb2FkaW5nIGZ1bmN0aW9uIGZvciBhZGRpdGlvbmFsIGNodW5rc1xuX193ZWJwYWNrX3JlcXVpcmVfXy5lID0gKGNodW5rSWQpID0+IHtcblx0cmV0dXJuIFByb21pc2UuYWxsKE9iamVjdC5rZXlzKF9fd2VicGFja19yZXF1aXJlX18uZikucmVkdWNlKChwcm9taXNlcywga2V5KSA9PiB7XG5cdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5mW2tleV0oY2h1bmtJZCwgcHJvbWlzZXMpO1xuXHRcdHJldHVybiBwcm9taXNlcztcblx0fSwgW10pKTtcbn07IiwiLy8gVGhpcyBmdW5jdGlvbiBhbGxvdyB0byByZWZlcmVuY2UgYXN5bmMgY2h1bmtzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLnUgPSAoY2h1bmtJZCkgPT4ge1xuXHQvLyByZXR1cm4gdXJsIGZvciBmaWxlbmFtZXMgYmFzZWQgb24gdGVtcGxhdGVcblx0cmV0dXJuIFwiamltdS11aS9jaHVua3MvXCIgKyBjaHVua0lkICsgXCIuanNcIjtcbn07IiwiLy8gVGhpcyBmdW5jdGlvbiBhbGxvdyB0byByZWZlcmVuY2UgYXN5bmMgY2h1bmtzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLm1pbmlDc3NGID0gKGNodW5rSWQpID0+IHtcblx0Ly8gcmV0dXJuIHVybCBmb3IgZmlsZW5hbWVzIGJhc2VkIG9uIHRlbXBsYXRlXG5cdHJldHVybiB1bmRlZmluZWQ7XG59OyIsIl9fd2VicGFja19yZXF1aXJlX18ubyA9IChvYmosIHByb3ApID0+IChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKSkiLCJ2YXIgaW5Qcm9ncmVzcyA9IHt9O1xudmFyIGRhdGFXZWJwYWNrUHJlZml4ID0gXCJleGItY2xpZW50OlwiO1xuLy8gbG9hZFNjcmlwdCBmdW5jdGlvbiB0byBsb2FkIGEgc2NyaXB0IHZpYSBzY3JpcHQgdGFnXG5fX3dlYnBhY2tfcmVxdWlyZV9fLmwgPSAodXJsLCBkb25lLCBrZXksIGNodW5rSWQpID0+IHtcblx0aWYoaW5Qcm9ncmVzc1t1cmxdKSB7IGluUHJvZ3Jlc3NbdXJsXS5wdXNoKGRvbmUpOyByZXR1cm47IH1cblx0dmFyIHNjcmlwdCwgbmVlZEF0dGFjaDtcblx0aWYoa2V5ICE9PSB1bmRlZmluZWQpIHtcblx0XHR2YXIgc2NyaXB0cyA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwic2NyaXB0XCIpO1xuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCBzY3JpcHRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgcyA9IHNjcmlwdHNbaV07XG5cdFx0XHRpZihzLmdldEF0dHJpYnV0ZShcInNyY1wiKSA9PSB1cmwgfHwgcy5nZXRBdHRyaWJ1dGUoXCJkYXRhLXdlYnBhY2tcIikgPT0gZGF0YVdlYnBhY2tQcmVmaXggKyBrZXkpIHsgc2NyaXB0ID0gczsgYnJlYWs7IH1cblx0XHR9XG5cdH1cblx0aWYoIXNjcmlwdCkge1xuXHRcdG5lZWRBdHRhY2ggPSB0cnVlO1xuXHRcdHNjcmlwdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuXG5cdFx0c2NyaXB0LmNoYXJzZXQgPSAndXRmLTgnO1xuXHRcdHNjcmlwdC50aW1lb3V0ID0gMTIwO1xuXHRcdGlmIChfX3dlYnBhY2tfcmVxdWlyZV9fLm5jKSB7XG5cdFx0XHRzY3JpcHQuc2V0QXR0cmlidXRlKFwibm9uY2VcIiwgX193ZWJwYWNrX3JlcXVpcmVfXy5uYyk7XG5cdFx0fVxuXHRcdHNjcmlwdC5zZXRBdHRyaWJ1dGUoXCJkYXRhLXdlYnBhY2tcIiwgZGF0YVdlYnBhY2tQcmVmaXggKyBrZXkpO1xuXG5cdFx0c2NyaXB0LnNyYyA9IHVybDtcblx0fVxuXHRpblByb2dyZXNzW3VybF0gPSBbZG9uZV07XG5cdHZhciBvblNjcmlwdENvbXBsZXRlID0gKHByZXYsIGV2ZW50KSA9PiB7XG5cdFx0Ly8gYXZvaWQgbWVtIGxlYWtzIGluIElFLlxuXHRcdHNjcmlwdC5vbmVycm9yID0gc2NyaXB0Lm9ubG9hZCA9IG51bGw7XG5cdFx0Y2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuXHRcdHZhciBkb25lRm5zID0gaW5Qcm9ncmVzc1t1cmxdO1xuXHRcdGRlbGV0ZSBpblByb2dyZXNzW3VybF07XG5cdFx0c2NyaXB0LnBhcmVudE5vZGUgJiYgc2NyaXB0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc2NyaXB0KTtcblx0XHRkb25lRm5zICYmIGRvbmVGbnMuZm9yRWFjaCgoZm4pID0+IChmbihldmVudCkpKTtcblx0XHRpZihwcmV2KSByZXR1cm4gcHJldihldmVudCk7XG5cdH1cblx0dmFyIHRpbWVvdXQgPSBzZXRUaW1lb3V0KG9uU2NyaXB0Q29tcGxldGUuYmluZChudWxsLCB1bmRlZmluZWQsIHsgdHlwZTogJ3RpbWVvdXQnLCB0YXJnZXQ6IHNjcmlwdCB9KSwgMTIwMDAwKTtcblx0c2NyaXB0Lm9uZXJyb3IgPSBvblNjcmlwdENvbXBsZXRlLmJpbmQobnVsbCwgc2NyaXB0Lm9uZXJyb3IpO1xuXHRzY3JpcHQub25sb2FkID0gb25TY3JpcHRDb21wbGV0ZS5iaW5kKG51bGwsIHNjcmlwdC5vbmxvYWQpO1xuXHRuZWVkQXR0YWNoICYmIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcbn07IiwiLy8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yID0gKGV4cG9ydHMpID0+IHtcblx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG5cdH1cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbn07IiwiX193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjsiLCIvLyBubyBiYXNlVVJJXG5cbi8vIG9iamVjdCB0byBzdG9yZSBsb2FkZWQgYW5kIGxvYWRpbmcgY2h1bmtzXG4vLyB1bmRlZmluZWQgPSBjaHVuayBub3QgbG9hZGVkLCBudWxsID0gY2h1bmsgcHJlbG9hZGVkL3ByZWZldGNoZWRcbi8vIFtyZXNvbHZlLCByZWplY3QsIFByb21pc2VdID0gY2h1bmsgbG9hZGluZywgMCA9IGNodW5rIGxvYWRlZFxudmFyIGluc3RhbGxlZENodW5rcyA9IHtcblx0XCJqaW11LXVpL2FkdmFuY2VkL2NoYXJ0LWVuZ2luZVwiOiAwXG59O1xuXG5fX3dlYnBhY2tfcmVxdWlyZV9fLmYuaiA9IChjaHVua0lkLCBwcm9taXNlcykgPT4ge1xuXHRcdC8vIEpTT05QIGNodW5rIGxvYWRpbmcgZm9yIGphdmFzY3JpcHRcblx0XHR2YXIgaW5zdGFsbGVkQ2h1bmtEYXRhID0gX193ZWJwYWNrX3JlcXVpcmVfXy5vKGluc3RhbGxlZENodW5rcywgY2h1bmtJZCkgPyBpbnN0YWxsZWRDaHVua3NbY2h1bmtJZF0gOiB1bmRlZmluZWQ7XG5cdFx0aWYoaW5zdGFsbGVkQ2h1bmtEYXRhICE9PSAwKSB7IC8vIDAgbWVhbnMgXCJhbHJlYWR5IGluc3RhbGxlZFwiLlxuXG5cdFx0XHQvLyBhIFByb21pc2UgbWVhbnMgXCJjdXJyZW50bHkgbG9hZGluZ1wiLlxuXHRcdFx0aWYoaW5zdGFsbGVkQ2h1bmtEYXRhKSB7XG5cdFx0XHRcdHByb21pc2VzLnB1c2goaW5zdGFsbGVkQ2h1bmtEYXRhWzJdKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlmKHRydWUpIHsgLy8gYWxsIGNodW5rcyBoYXZlIEpTXG5cdFx0XHRcdFx0Ly8gc2V0dXAgUHJvbWlzZSBpbiBjaHVuayBjYWNoZVxuXHRcdFx0XHRcdHZhciBwcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4gKGluc3RhbGxlZENodW5rRGF0YSA9IGluc3RhbGxlZENodW5rc1tjaHVua0lkXSA9IFtyZXNvbHZlLCByZWplY3RdKSk7XG5cdFx0XHRcdFx0cHJvbWlzZXMucHVzaChpbnN0YWxsZWRDaHVua0RhdGFbMl0gPSBwcm9taXNlKTtcblxuXHRcdFx0XHRcdC8vIHN0YXJ0IGNodW5rIGxvYWRpbmdcblx0XHRcdFx0XHR2YXIgdXJsID0gX193ZWJwYWNrX3JlcXVpcmVfXy5wICsgX193ZWJwYWNrX3JlcXVpcmVfXy51KGNodW5rSWQpO1xuXHRcdFx0XHRcdC8vIGNyZWF0ZSBlcnJvciBiZWZvcmUgc3RhY2sgdW53b3VuZCB0byBnZXQgdXNlZnVsIHN0YWNrdHJhY2UgbGF0ZXJcblx0XHRcdFx0XHR2YXIgZXJyb3IgPSBuZXcgRXJyb3IoKTtcblx0XHRcdFx0XHR2YXIgbG9hZGluZ0VuZGVkID0gKGV2ZW50KSA9PiB7XG5cdFx0XHRcdFx0XHRpZihfX3dlYnBhY2tfcmVxdWlyZV9fLm8oaW5zdGFsbGVkQ2h1bmtzLCBjaHVua0lkKSkge1xuXHRcdFx0XHRcdFx0XHRpbnN0YWxsZWRDaHVua0RhdGEgPSBpbnN0YWxsZWRDaHVua3NbY2h1bmtJZF07XG5cdFx0XHRcdFx0XHRcdGlmKGluc3RhbGxlZENodW5rRGF0YSAhPT0gMCkgaW5zdGFsbGVkQ2h1bmtzW2NodW5rSWRdID0gdW5kZWZpbmVkO1xuXHRcdFx0XHRcdFx0XHRpZihpbnN0YWxsZWRDaHVua0RhdGEpIHtcblx0XHRcdFx0XHRcdFx0XHR2YXIgZXJyb3JUeXBlID0gZXZlbnQgJiYgKGV2ZW50LnR5cGUgPT09ICdsb2FkJyA/ICdtaXNzaW5nJyA6IGV2ZW50LnR5cGUpO1xuXHRcdFx0XHRcdFx0XHRcdHZhciByZWFsU3JjID0gZXZlbnQgJiYgZXZlbnQudGFyZ2V0ICYmIGV2ZW50LnRhcmdldC5zcmM7XG5cdFx0XHRcdFx0XHRcdFx0ZXJyb3IubWVzc2FnZSA9ICdMb2FkaW5nIGNodW5rICcgKyBjaHVua0lkICsgJyBmYWlsZWQuXFxuKCcgKyBlcnJvclR5cGUgKyAnOiAnICsgcmVhbFNyYyArICcpJztcblx0XHRcdFx0XHRcdFx0XHRlcnJvci5uYW1lID0gJ0NodW5rTG9hZEVycm9yJztcblx0XHRcdFx0XHRcdFx0XHRlcnJvci50eXBlID0gZXJyb3JUeXBlO1xuXHRcdFx0XHRcdFx0XHRcdGVycm9yLnJlcXVlc3QgPSByZWFsU3JjO1xuXHRcdFx0XHRcdFx0XHRcdGluc3RhbGxlZENodW5rRGF0YVsxXShlcnJvcik7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdF9fd2VicGFja19yZXF1aXJlX18ubCh1cmwsIGxvYWRpbmdFbmRlZCwgXCJjaHVuay1cIiArIGNodW5rSWQsIGNodW5rSWQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxufTtcblxuLy8gbm8gcHJlZmV0Y2hpbmdcblxuLy8gbm8gcHJlbG9hZGVkXG5cbi8vIG5vIEhNUlxuXG4vLyBubyBITVIgbWFuaWZlc3RcblxuLy8gbm8gb24gY2h1bmtzIGxvYWRlZFxuXG4vLyBpbnN0YWxsIGEgSlNPTlAgY2FsbGJhY2sgZm9yIGNodW5rIGxvYWRpbmdcbnZhciB3ZWJwYWNrSnNvbnBDYWxsYmFjayA9IChwYXJlbnRDaHVua0xvYWRpbmdGdW5jdGlvbiwgZGF0YSkgPT4ge1xuXHR2YXIgW2NodW5rSWRzLCBtb3JlTW9kdWxlcywgcnVudGltZV0gPSBkYXRhO1xuXHQvLyBhZGQgXCJtb3JlTW9kdWxlc1wiIHRvIHRoZSBtb2R1bGVzIG9iamVjdCxcblx0Ly8gdGhlbiBmbGFnIGFsbCBcImNodW5rSWRzXCIgYXMgbG9hZGVkIGFuZCBmaXJlIGNhbGxiYWNrXG5cdHZhciBtb2R1bGVJZCwgY2h1bmtJZCwgaSA9IDA7XG5cdGlmKGNodW5rSWRzLnNvbWUoKGlkKSA9PiAoaW5zdGFsbGVkQ2h1bmtzW2lkXSAhPT0gMCkpKSB7XG5cdFx0Zm9yKG1vZHVsZUlkIGluIG1vcmVNb2R1bGVzKSB7XG5cdFx0XHRpZihfX3dlYnBhY2tfcmVxdWlyZV9fLm8obW9yZU1vZHVsZXMsIG1vZHVsZUlkKSkge1xuXHRcdFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLm1bbW9kdWxlSWRdID0gbW9yZU1vZHVsZXNbbW9kdWxlSWRdO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRpZihydW50aW1lKSB2YXIgcmVzdWx0ID0gcnVudGltZShfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblx0fVxuXHRpZihwYXJlbnRDaHVua0xvYWRpbmdGdW5jdGlvbikgcGFyZW50Q2h1bmtMb2FkaW5nRnVuY3Rpb24oZGF0YSk7XG5cdGZvcig7aSA8IGNodW5rSWRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0Y2h1bmtJZCA9IGNodW5rSWRzW2ldO1xuXHRcdGlmKF9fd2VicGFja19yZXF1aXJlX18ubyhpbnN0YWxsZWRDaHVua3MsIGNodW5rSWQpICYmIGluc3RhbGxlZENodW5rc1tjaHVua0lkXSkge1xuXHRcdFx0aW5zdGFsbGVkQ2h1bmtzW2NodW5rSWRdWzBdKCk7XG5cdFx0fVxuXHRcdGluc3RhbGxlZENodW5rc1tjaHVua0lkXSA9IDA7XG5cdH1cblxufVxuXG52YXIgY2h1bmtMb2FkaW5nR2xvYmFsID0gc2VsZltcIndlYnBhY2tDaHVua2V4Yl9jbGllbnRcIl0gPSBzZWxmW1wid2VicGFja0NodW5rZXhiX2NsaWVudFwiXSB8fCBbXTtcbmNodW5rTG9hZGluZ0dsb2JhbC5mb3JFYWNoKHdlYnBhY2tKc29ucENhbGxiYWNrLmJpbmQobnVsbCwgMCkpO1xuY2h1bmtMb2FkaW5nR2xvYmFsLnB1c2ggPSB3ZWJwYWNrSnNvbnBDYWxsYmFjay5iaW5kKG51bGwsIGNodW5rTG9hZGluZ0dsb2JhbC5wdXNoLmJpbmQoY2h1bmtMb2FkaW5nR2xvYmFsKSk7IiwiLyoqXG4gKiBXZWJwYWNrIHdpbGwgcmVwbGFjZSBfX3dlYnBhY2tfcHVibGljX3BhdGhfXyB3aXRoIF9fd2VicGFja19yZXF1aXJlX18ucCB0byBzZXQgdGhlIHB1YmxpYyBwYXRoIGR5bmFtaWNhbGx5LlxuICogVGhlIHJlYXNvbiB3aHkgd2UgY2FuJ3Qgc2V0IHRoZSBwdWJsaWNQYXRoIGluIHdlYnBhY2sgY29uZmlnIGlzOiB3ZSBjaGFuZ2UgdGhlIHB1YmxpY1BhdGggd2hlbiBkb3dubG9hZC5cbiAqICovXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbi8vIEB0cy1pZ25vcmVcbl9fd2VicGFja19wdWJsaWNfcGF0aF9fID0gd2luZG93LmppbXVDb25maWcuYmFzZVVybFxuIiwiZXhwb3J0ICogZnJvbSAnLi9saWIvY2hhcnQtZW5naW5lJ1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9