"use strict";
(self["webpackChunkexb_client"] = self["webpackChunkexb_client"] || []).push([["node_modules_esri_calcite-components_dist_esm_index-04fe9839_js"],{

/***/ "./node_modules/@esri/calcite-components/dist/esm/index-04fe9839.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@esri/calcite-components/dist/esm/index-04fe9839.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   groupTimeZones: () => (/* binding */ groupTimeZones)
/* harmony export */ });
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * See https://github.com/Esri/calcite-design-system/blob/main/LICENSE.md for details.
 * v2.0.0
 */
const supportedTimeZones = (() => {
    const platformTimeZones = Intl.supportedValuesOf('timeZone');
    // not all browsers include these time zones, so we add them to ensure consistent groups
    const etcTimeZones = [
        "Etc/GMT+1",
        "Etc/GMT+10",
        "Etc/GMT+11",
        "Etc/GMT+12",
        "Etc/GMT+2",
        "Etc/GMT+3",
        "Etc/GMT+4",
        "Etc/GMT+5",
        "Etc/GMT+6",
        "Etc/GMT+7",
        "Etc/GMT+8",
        "Etc/GMT+9",
        "Etc/GMT-1",
        "Etc/GMT-10",
        "Etc/GMT-11",
        "Etc/GMT-12",
        "Etc/GMT-13",
        "Etc/GMT-14",
        "Etc/GMT-2",
        "Etc/GMT-3",
        "Etc/GMT-4",
        "Etc/GMT-5",
        "Etc/GMT-6",
        "Etc/GMT-7",
        "Etc/GMT-8",
        "Etc/GMT-9"
    ];
    return [...new Set([...platformTimeZones, ...etcTimeZones])];
})();

const now = new Date();
const startDate = now.toISOString();
const daysInYear = 365;
const groupDateRange = daysInYear;
const defaultGroupingOptions = {
    startDate,
    groupDateRange,
    debug: false,
};

const continentAllowList = new Set([
    'Europe',
    'Asia',
    'America',
    'America/Argentina',
    'Africa',
    'Australia',
    'Pacific',
    'Atlantic',
    'Antarctica',
    'Arctic',
    'Indian',
]);
const _getDates = (startDate, numberDays, dateEngine) => {
    const dateArray = [];
    let date = dateEngine.create(startDate);
    for (let i = 0; i <= numberDays; i++) {
        date = dateEngine.increase(date);
        dateArray.push(dateEngine.formatToIsoDateString(date));
    }
    return dateArray;
};
const _extractContinent = (label) => {
    if (label.includes('Istanbul')) {
        return 'Europe';
    }
    const lastIndex = label.lastIndexOf('/');
    return lastIndex === -1 ? label : label.slice(0, lastIndex);
};
const _isRegularContinent = (continent) => continentAllowList.has(continent);
const generateTimeZoneMetadata = (timeZoneItems, startDate, numberDays, dateEngine, debug = false) => {
    const processedDates = new Map();
    if (debug) {
        console.log(`Initializing data starting ${startDate} with ${numberDays} days in the future, comparing ${timeZoneItems.length} timezones`);
    }
    const theDates = _getDates(startDate, numberDays, dateEngine);
    return timeZoneItems.map((tzItem) => {
        const label = tzItem.label;
        const continent = _extractContinent(label);
        const dates = theDates.map((date) => {
            const key = `${date}-${label}`;
            let utc = processedDates.get(key);
            if (utc) {
                return utc;
            }
            utc = dateEngine.isoToTimeZone(date, label);
            processedDates.set(key, utc);
            return utc;
        });
        return {
            ...tzItem,
            continent,
            isRegularContinent: _isRegularContinent(continent),
            dates,
        };
    });
};
const compareDateArrs = (array1, array2, dateEngine) => array1.length === array2.length &&
    array1.every((value, index) => dateEngine.same(value, array2[index]));
const getGroupLabelTimeZoneIndices = (rawTZs, max = 5) => {
    const shrinkedTzs = rawTZs.filter(({ label }) => _isRegularContinent(_extractContinent(label)));
    if (shrinkedTzs.length === 0) {
        return [0];
    }
    const validLabels = shrinkedTzs.map((tz) => rawTZs.indexOf(tz));
    return equallyDistributedSampling(validLabels, max);
};
function equallyDistributedSampling(items, maxItems = 5) {
    const totalItems = items.length;
    if (totalItems <= maxItems) {
        return items;
    }
    const numberItemsToSelect = Math.min(totalItems - 2, maxItems - 2);
    const stepSize = (totalItems - 1) / (numberItemsToSelect + 1);
    return [
        items[0],
        ...Array.from({ length: numberItemsToSelect }, (_, i) => items[Math.round((i + 1) * stepSize)]),
        items[totalItems - 1],
    ];
}

async function groupTimeZones(options) {
    const { debug, groupDateRange, hooks, startDate, dateEngine } = {
        ...defaultGroupingOptions,
        ...options,
    };
    const grouping = [];
    if (!dateEngine) {
        throw new Error('dateEngine is required');
    }
    const timeZoneItems = supportedTimeZones.map((tz) => ({ label: tz }));
    hooks?.onBeforeTimeZoneMetadataCreate?.(timeZoneItems);
    const timeZoneMetadata = generateTimeZoneMetadata(timeZoneItems, startDate, groupDateRange, dateEngine, debug);
    hooks?.onTimeZoneMetadataCreate?.(timeZoneMetadata);
    // We traverse the mappedDB and see if we find matches by comparing each set
    // of transformed date for that specific TZ.
    for (const tzMetadatumI of timeZoneMetadata) {
        const { label, continent, dates } = tzMetadatumI;
        // ignore if we visited this element already
        if (tzMetadatumI.visited) {
            continue;
        }
        // Mark element as already visited
        tzMetadatumI.visited = true;
        // The grouped timezone that we want as a result
        const newGroup = {
            labelTzIndices: undefined,
            tzs: [{ label }],
        };
        hooks?.onGroupCreate?.(newGroup, tzMetadatumI);
        for (const tzMetadatumJ of timeZoneMetadata.filter((_) => !_.visited)) {
            const { label: labelJ, continent: continentJ, isRegularContinent: isRegularContinentJ, dates: datesJ, } = tzMetadatumJ;
            // We define a matching TZ by:
            // 1) if both continents match (avoid grouping Antarctica with anything else)
            // 2) if the transformed dates match in both TZs
            if ((continent === continentJ || !isRegularContinentJ) &&
                compareDateArrs(dates, datesJ, dateEngine)) {
                const tzItem = { label: labelJ };
                newGroup.tzs.push(tzItem);
                hooks?.onGroupTimeZoneAdd?.(newGroup, tzItem, tzMetadatumJ);
                // Mark element as already visited
                tzMetadatumJ.visited = true;
            }
        }
        grouping.push(newGroup);
        hooks?.onGroupAdd?.(newGroup);
    }
    // Now that we have a group, we want an easy way to find a fitting label for the group
    // which is defined as the list of the most-common 7 cities, shown in alphabetical order
    const finalGrouping = grouping
        .map((group) => {
        hooks?.onBeforeFinalGroupCreate?.(group);
        group.tzs = group.tzs.sort((a, b) => a.label.localeCompare(b.label));
        const finalGrouping = {
            labelTzIndices: getGroupLabelTimeZoneIndices(group.tzs, 7),
            tzs: group.tzs.map((_) => _.label),
        };
        hooks?.onFinalGroupCreate?.(finalGrouping, group);
        return finalGrouping;
    })
        .sort((a, b) => b.tzs.length - a.tzs.length);
    if (debug) {
        const missingTzs = supportedTimeZones
            .map((tz) => (finalGrouping.some((y) => y.tzs.includes(tz)) ? null : tz))
            .filter(Boolean);
        if (missingTzs.length > 0) {
            throw new Error(`There are ${missingTzs.length} missing timezones: ${missingTzs.toString()}`);
        }
    }
    return hooks?.onFinalGroupingCreate
        ? hooks.onFinalGroupingCreate(finalGrouping)
        : finalGrouping;
}



//# sourceMappingURL=index-04fe9839.js.map

/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2FsY2l0ZS1jb21wb25lbnRzL2NodW5rcy9ub2RlX21vZHVsZXNfZXNyaV9jYWxjaXRlLWNvbXBvbmVudHNfZGlzdF9lc21faW5kZXgtMDRmZTk4MzlfanMuYnVuZGxlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxXQUFXLE9BQU8sWUFBWSxnQ0FBZ0Msc0JBQXNCO0FBQ3RJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixLQUFLLEdBQUcsTUFBTTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsT0FBTztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsNkJBQTZCO0FBQ3JEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVksc0RBQXNEO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELFdBQVc7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDBCQUEwQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZ0dBQWdHO0FBQ3BIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxtQkFBbUIscUJBQXFCLHNCQUFzQjtBQUN2RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRTBCOztBQUUxQiIsInNvdXJjZXMiOlsid2VicGFjazovL2V4Yi1jbGllbnQvLi9ub2RlX21vZHVsZXMvQGVzcmkvY2FsY2l0ZS1jb21wb25lbnRzL2Rpc3QvZXNtL2luZGV4LTA0ZmU5ODM5LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogQWxsIG1hdGVyaWFsIGNvcHlyaWdodCBFU1JJLCBBbGwgUmlnaHRzIFJlc2VydmVkLCB1bmxlc3Mgb3RoZXJ3aXNlIHNwZWNpZmllZC5cbiAqIFNlZSBodHRwczovL2dpdGh1Yi5jb20vRXNyaS9jYWxjaXRlLWRlc2lnbi1zeXN0ZW0vYmxvYi9tYWluL0xJQ0VOU0UubWQgZm9yIGRldGFpbHMuXG4gKiB2Mi4wLjBcbiAqL1xuY29uc3Qgc3VwcG9ydGVkVGltZVpvbmVzID0gKCgpID0+IHtcbiAgICBjb25zdCBwbGF0Zm9ybVRpbWVab25lcyA9IEludGwuc3VwcG9ydGVkVmFsdWVzT2YoJ3RpbWVab25lJyk7XG4gICAgLy8gbm90IGFsbCBicm93c2VycyBpbmNsdWRlIHRoZXNlIHRpbWUgem9uZXMsIHNvIHdlIGFkZCB0aGVtIHRvIGVuc3VyZSBjb25zaXN0ZW50IGdyb3Vwc1xuICAgIGNvbnN0IGV0Y1RpbWVab25lcyA9IFtcbiAgICAgICAgXCJFdGMvR01UKzFcIixcbiAgICAgICAgXCJFdGMvR01UKzEwXCIsXG4gICAgICAgIFwiRXRjL0dNVCsxMVwiLFxuICAgICAgICBcIkV0Yy9HTVQrMTJcIixcbiAgICAgICAgXCJFdGMvR01UKzJcIixcbiAgICAgICAgXCJFdGMvR01UKzNcIixcbiAgICAgICAgXCJFdGMvR01UKzRcIixcbiAgICAgICAgXCJFdGMvR01UKzVcIixcbiAgICAgICAgXCJFdGMvR01UKzZcIixcbiAgICAgICAgXCJFdGMvR01UKzdcIixcbiAgICAgICAgXCJFdGMvR01UKzhcIixcbiAgICAgICAgXCJFdGMvR01UKzlcIixcbiAgICAgICAgXCJFdGMvR01ULTFcIixcbiAgICAgICAgXCJFdGMvR01ULTEwXCIsXG4gICAgICAgIFwiRXRjL0dNVC0xMVwiLFxuICAgICAgICBcIkV0Yy9HTVQtMTJcIixcbiAgICAgICAgXCJFdGMvR01ULTEzXCIsXG4gICAgICAgIFwiRXRjL0dNVC0xNFwiLFxuICAgICAgICBcIkV0Yy9HTVQtMlwiLFxuICAgICAgICBcIkV0Yy9HTVQtM1wiLFxuICAgICAgICBcIkV0Yy9HTVQtNFwiLFxuICAgICAgICBcIkV0Yy9HTVQtNVwiLFxuICAgICAgICBcIkV0Yy9HTVQtNlwiLFxuICAgICAgICBcIkV0Yy9HTVQtN1wiLFxuICAgICAgICBcIkV0Yy9HTVQtOFwiLFxuICAgICAgICBcIkV0Yy9HTVQtOVwiXG4gICAgXTtcbiAgICByZXR1cm4gWy4uLm5ldyBTZXQoWy4uLnBsYXRmb3JtVGltZVpvbmVzLCAuLi5ldGNUaW1lWm9uZXNdKV07XG59KSgpO1xuXG5jb25zdCBub3cgPSBuZXcgRGF0ZSgpO1xuY29uc3Qgc3RhcnREYXRlID0gbm93LnRvSVNPU3RyaW5nKCk7XG5jb25zdCBkYXlzSW5ZZWFyID0gMzY1O1xuY29uc3QgZ3JvdXBEYXRlUmFuZ2UgPSBkYXlzSW5ZZWFyO1xuY29uc3QgZGVmYXVsdEdyb3VwaW5nT3B0aW9ucyA9IHtcbiAgICBzdGFydERhdGUsXG4gICAgZ3JvdXBEYXRlUmFuZ2UsXG4gICAgZGVidWc6IGZhbHNlLFxufTtcblxuY29uc3QgY29udGluZW50QWxsb3dMaXN0ID0gbmV3IFNldChbXG4gICAgJ0V1cm9wZScsXG4gICAgJ0FzaWEnLFxuICAgICdBbWVyaWNhJyxcbiAgICAnQW1lcmljYS9BcmdlbnRpbmEnLFxuICAgICdBZnJpY2EnLFxuICAgICdBdXN0cmFsaWEnLFxuICAgICdQYWNpZmljJyxcbiAgICAnQXRsYW50aWMnLFxuICAgICdBbnRhcmN0aWNhJyxcbiAgICAnQXJjdGljJyxcbiAgICAnSW5kaWFuJyxcbl0pO1xuY29uc3QgX2dldERhdGVzID0gKHN0YXJ0RGF0ZSwgbnVtYmVyRGF5cywgZGF0ZUVuZ2luZSkgPT4ge1xuICAgIGNvbnN0IGRhdGVBcnJheSA9IFtdO1xuICAgIGxldCBkYXRlID0gZGF0ZUVuZ2luZS5jcmVhdGUoc3RhcnREYXRlKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8PSBudW1iZXJEYXlzOyBpKyspIHtcbiAgICAgICAgZGF0ZSA9IGRhdGVFbmdpbmUuaW5jcmVhc2UoZGF0ZSk7XG4gICAgICAgIGRhdGVBcnJheS5wdXNoKGRhdGVFbmdpbmUuZm9ybWF0VG9Jc29EYXRlU3RyaW5nKGRhdGUpKTtcbiAgICB9XG4gICAgcmV0dXJuIGRhdGVBcnJheTtcbn07XG5jb25zdCBfZXh0cmFjdENvbnRpbmVudCA9IChsYWJlbCkgPT4ge1xuICAgIGlmIChsYWJlbC5pbmNsdWRlcygnSXN0YW5idWwnKSkge1xuICAgICAgICByZXR1cm4gJ0V1cm9wZSc7XG4gICAgfVxuICAgIGNvbnN0IGxhc3RJbmRleCA9IGxhYmVsLmxhc3RJbmRleE9mKCcvJyk7XG4gICAgcmV0dXJuIGxhc3RJbmRleCA9PT0gLTEgPyBsYWJlbCA6IGxhYmVsLnNsaWNlKDAsIGxhc3RJbmRleCk7XG59O1xuY29uc3QgX2lzUmVndWxhckNvbnRpbmVudCA9IChjb250aW5lbnQpID0+IGNvbnRpbmVudEFsbG93TGlzdC5oYXMoY29udGluZW50KTtcbmNvbnN0IGdlbmVyYXRlVGltZVpvbmVNZXRhZGF0YSA9ICh0aW1lWm9uZUl0ZW1zLCBzdGFydERhdGUsIG51bWJlckRheXMsIGRhdGVFbmdpbmUsIGRlYnVnID0gZmFsc2UpID0+IHtcbiAgICBjb25zdCBwcm9jZXNzZWREYXRlcyA9IG5ldyBNYXAoKTtcbiAgICBpZiAoZGVidWcpIHtcbiAgICAgICAgY29uc29sZS5sb2coYEluaXRpYWxpemluZyBkYXRhIHN0YXJ0aW5nICR7c3RhcnREYXRlfSB3aXRoICR7bnVtYmVyRGF5c30gZGF5cyBpbiB0aGUgZnV0dXJlLCBjb21wYXJpbmcgJHt0aW1lWm9uZUl0ZW1zLmxlbmd0aH0gdGltZXpvbmVzYCk7XG4gICAgfVxuICAgIGNvbnN0IHRoZURhdGVzID0gX2dldERhdGVzKHN0YXJ0RGF0ZSwgbnVtYmVyRGF5cywgZGF0ZUVuZ2luZSk7XG4gICAgcmV0dXJuIHRpbWVab25lSXRlbXMubWFwKCh0ekl0ZW0pID0+IHtcbiAgICAgICAgY29uc3QgbGFiZWwgPSB0ekl0ZW0ubGFiZWw7XG4gICAgICAgIGNvbnN0IGNvbnRpbmVudCA9IF9leHRyYWN0Q29udGluZW50KGxhYmVsKTtcbiAgICAgICAgY29uc3QgZGF0ZXMgPSB0aGVEYXRlcy5tYXAoKGRhdGUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IGAke2RhdGV9LSR7bGFiZWx9YDtcbiAgICAgICAgICAgIGxldCB1dGMgPSBwcm9jZXNzZWREYXRlcy5nZXQoa2V5KTtcbiAgICAgICAgICAgIGlmICh1dGMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdXRjO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdXRjID0gZGF0ZUVuZ2luZS5pc29Ub1RpbWVab25lKGRhdGUsIGxhYmVsKTtcbiAgICAgICAgICAgIHByb2Nlc3NlZERhdGVzLnNldChrZXksIHV0Yyk7XG4gICAgICAgICAgICByZXR1cm4gdXRjO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLnR6SXRlbSxcbiAgICAgICAgICAgIGNvbnRpbmVudCxcbiAgICAgICAgICAgIGlzUmVndWxhckNvbnRpbmVudDogX2lzUmVndWxhckNvbnRpbmVudChjb250aW5lbnQpLFxuICAgICAgICAgICAgZGF0ZXMsXG4gICAgICAgIH07XG4gICAgfSk7XG59O1xuY29uc3QgY29tcGFyZURhdGVBcnJzID0gKGFycmF5MSwgYXJyYXkyLCBkYXRlRW5naW5lKSA9PiBhcnJheTEubGVuZ3RoID09PSBhcnJheTIubGVuZ3RoICYmXG4gICAgYXJyYXkxLmV2ZXJ5KCh2YWx1ZSwgaW5kZXgpID0+IGRhdGVFbmdpbmUuc2FtZSh2YWx1ZSwgYXJyYXkyW2luZGV4XSkpO1xuY29uc3QgZ2V0R3JvdXBMYWJlbFRpbWVab25lSW5kaWNlcyA9IChyYXdUWnMsIG1heCA9IDUpID0+IHtcbiAgICBjb25zdCBzaHJpbmtlZFR6cyA9IHJhd1Racy5maWx0ZXIoKHsgbGFiZWwgfSkgPT4gX2lzUmVndWxhckNvbnRpbmVudChfZXh0cmFjdENvbnRpbmVudChsYWJlbCkpKTtcbiAgICBpZiAoc2hyaW5rZWRUenMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBbMF07XG4gICAgfVxuICAgIGNvbnN0IHZhbGlkTGFiZWxzID0gc2hyaW5rZWRUenMubWFwKCh0eikgPT4gcmF3VFpzLmluZGV4T2YodHopKTtcbiAgICByZXR1cm4gZXF1YWxseURpc3RyaWJ1dGVkU2FtcGxpbmcodmFsaWRMYWJlbHMsIG1heCk7XG59O1xuZnVuY3Rpb24gZXF1YWxseURpc3RyaWJ1dGVkU2FtcGxpbmcoaXRlbXMsIG1heEl0ZW1zID0gNSkge1xuICAgIGNvbnN0IHRvdGFsSXRlbXMgPSBpdGVtcy5sZW5ndGg7XG4gICAgaWYgKHRvdGFsSXRlbXMgPD0gbWF4SXRlbXMpIHtcbiAgICAgICAgcmV0dXJuIGl0ZW1zO1xuICAgIH1cbiAgICBjb25zdCBudW1iZXJJdGVtc1RvU2VsZWN0ID0gTWF0aC5taW4odG90YWxJdGVtcyAtIDIsIG1heEl0ZW1zIC0gMik7XG4gICAgY29uc3Qgc3RlcFNpemUgPSAodG90YWxJdGVtcyAtIDEpIC8gKG51bWJlckl0ZW1zVG9TZWxlY3QgKyAxKTtcbiAgICByZXR1cm4gW1xuICAgICAgICBpdGVtc1swXSxcbiAgICAgICAgLi4uQXJyYXkuZnJvbSh7IGxlbmd0aDogbnVtYmVySXRlbXNUb1NlbGVjdCB9LCAoXywgaSkgPT4gaXRlbXNbTWF0aC5yb3VuZCgoaSArIDEpICogc3RlcFNpemUpXSksXG4gICAgICAgIGl0ZW1zW3RvdGFsSXRlbXMgLSAxXSxcbiAgICBdO1xufVxuXG5hc3luYyBmdW5jdGlvbiBncm91cFRpbWVab25lcyhvcHRpb25zKSB7XG4gICAgY29uc3QgeyBkZWJ1ZywgZ3JvdXBEYXRlUmFuZ2UsIGhvb2tzLCBzdGFydERhdGUsIGRhdGVFbmdpbmUgfSA9IHtcbiAgICAgICAgLi4uZGVmYXVsdEdyb3VwaW5nT3B0aW9ucyxcbiAgICAgICAgLi4ub3B0aW9ucyxcbiAgICB9O1xuICAgIGNvbnN0IGdyb3VwaW5nID0gW107XG4gICAgaWYgKCFkYXRlRW5naW5lKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZGF0ZUVuZ2luZSBpcyByZXF1aXJlZCcpO1xuICAgIH1cbiAgICBjb25zdCB0aW1lWm9uZUl0ZW1zID0gc3VwcG9ydGVkVGltZVpvbmVzLm1hcCgodHopID0+ICh7IGxhYmVsOiB0eiB9KSk7XG4gICAgaG9va3M/Lm9uQmVmb3JlVGltZVpvbmVNZXRhZGF0YUNyZWF0ZT8uKHRpbWVab25lSXRlbXMpO1xuICAgIGNvbnN0IHRpbWVab25lTWV0YWRhdGEgPSBnZW5lcmF0ZVRpbWVab25lTWV0YWRhdGEodGltZVpvbmVJdGVtcywgc3RhcnREYXRlLCBncm91cERhdGVSYW5nZSwgZGF0ZUVuZ2luZSwgZGVidWcpO1xuICAgIGhvb2tzPy5vblRpbWVab25lTWV0YWRhdGFDcmVhdGU/Lih0aW1lWm9uZU1ldGFkYXRhKTtcbiAgICAvLyBXZSB0cmF2ZXJzZSB0aGUgbWFwcGVkREIgYW5kIHNlZSBpZiB3ZSBmaW5kIG1hdGNoZXMgYnkgY29tcGFyaW5nIGVhY2ggc2V0XG4gICAgLy8gb2YgdHJhbnNmb3JtZWQgZGF0ZSBmb3IgdGhhdCBzcGVjaWZpYyBUWi5cbiAgICBmb3IgKGNvbnN0IHR6TWV0YWRhdHVtSSBvZiB0aW1lWm9uZU1ldGFkYXRhKSB7XG4gICAgICAgIGNvbnN0IHsgbGFiZWwsIGNvbnRpbmVudCwgZGF0ZXMgfSA9IHR6TWV0YWRhdHVtSTtcbiAgICAgICAgLy8gaWdub3JlIGlmIHdlIHZpc2l0ZWQgdGhpcyBlbGVtZW50IGFscmVhZHlcbiAgICAgICAgaWYgKHR6TWV0YWRhdHVtSS52aXNpdGVkKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBNYXJrIGVsZW1lbnQgYXMgYWxyZWFkeSB2aXNpdGVkXG4gICAgICAgIHR6TWV0YWRhdHVtSS52aXNpdGVkID0gdHJ1ZTtcbiAgICAgICAgLy8gVGhlIGdyb3VwZWQgdGltZXpvbmUgdGhhdCB3ZSB3YW50IGFzIGEgcmVzdWx0XG4gICAgICAgIGNvbnN0IG5ld0dyb3VwID0ge1xuICAgICAgICAgICAgbGFiZWxUekluZGljZXM6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHR6czogW3sgbGFiZWwgfV0sXG4gICAgICAgIH07XG4gICAgICAgIGhvb2tzPy5vbkdyb3VwQ3JlYXRlPy4obmV3R3JvdXAsIHR6TWV0YWRhdHVtSSk7XG4gICAgICAgIGZvciAoY29uc3QgdHpNZXRhZGF0dW1KIG9mIHRpbWVab25lTWV0YWRhdGEuZmlsdGVyKChfKSA9PiAhXy52aXNpdGVkKSkge1xuICAgICAgICAgICAgY29uc3QgeyBsYWJlbDogbGFiZWxKLCBjb250aW5lbnQ6IGNvbnRpbmVudEosIGlzUmVndWxhckNvbnRpbmVudDogaXNSZWd1bGFyQ29udGluZW50SiwgZGF0ZXM6IGRhdGVzSiwgfSA9IHR6TWV0YWRhdHVtSjtcbiAgICAgICAgICAgIC8vIFdlIGRlZmluZSBhIG1hdGNoaW5nIFRaIGJ5OlxuICAgICAgICAgICAgLy8gMSkgaWYgYm90aCBjb250aW5lbnRzIG1hdGNoIChhdm9pZCBncm91cGluZyBBbnRhcmN0aWNhIHdpdGggYW55dGhpbmcgZWxzZSlcbiAgICAgICAgICAgIC8vIDIpIGlmIHRoZSB0cmFuc2Zvcm1lZCBkYXRlcyBtYXRjaCBpbiBib3RoIFRac1xuICAgICAgICAgICAgaWYgKChjb250aW5lbnQgPT09IGNvbnRpbmVudEogfHwgIWlzUmVndWxhckNvbnRpbmVudEopICYmXG4gICAgICAgICAgICAgICAgY29tcGFyZURhdGVBcnJzKGRhdGVzLCBkYXRlc0osIGRhdGVFbmdpbmUpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdHpJdGVtID0geyBsYWJlbDogbGFiZWxKIH07XG4gICAgICAgICAgICAgICAgbmV3R3JvdXAudHpzLnB1c2godHpJdGVtKTtcbiAgICAgICAgICAgICAgICBob29rcz8ub25Hcm91cFRpbWVab25lQWRkPy4obmV3R3JvdXAsIHR6SXRlbSwgdHpNZXRhZGF0dW1KKTtcbiAgICAgICAgICAgICAgICAvLyBNYXJrIGVsZW1lbnQgYXMgYWxyZWFkeSB2aXNpdGVkXG4gICAgICAgICAgICAgICAgdHpNZXRhZGF0dW1KLnZpc2l0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGdyb3VwaW5nLnB1c2gobmV3R3JvdXApO1xuICAgICAgICBob29rcz8ub25Hcm91cEFkZD8uKG5ld0dyb3VwKTtcbiAgICB9XG4gICAgLy8gTm93IHRoYXQgd2UgaGF2ZSBhIGdyb3VwLCB3ZSB3YW50IGFuIGVhc3kgd2F5IHRvIGZpbmQgYSBmaXR0aW5nIGxhYmVsIGZvciB0aGUgZ3JvdXBcbiAgICAvLyB3aGljaCBpcyBkZWZpbmVkIGFzIHRoZSBsaXN0IG9mIHRoZSBtb3N0LWNvbW1vbiA3IGNpdGllcywgc2hvd24gaW4gYWxwaGFiZXRpY2FsIG9yZGVyXG4gICAgY29uc3QgZmluYWxHcm91cGluZyA9IGdyb3VwaW5nXG4gICAgICAgIC5tYXAoKGdyb3VwKSA9PiB7XG4gICAgICAgIGhvb2tzPy5vbkJlZm9yZUZpbmFsR3JvdXBDcmVhdGU/Lihncm91cCk7XG4gICAgICAgIGdyb3VwLnR6cyA9IGdyb3VwLnR6cy5zb3J0KChhLCBiKSA9PiBhLmxhYmVsLmxvY2FsZUNvbXBhcmUoYi5sYWJlbCkpO1xuICAgICAgICBjb25zdCBmaW5hbEdyb3VwaW5nID0ge1xuICAgICAgICAgICAgbGFiZWxUekluZGljZXM6IGdldEdyb3VwTGFiZWxUaW1lWm9uZUluZGljZXMoZ3JvdXAudHpzLCA3KSxcbiAgICAgICAgICAgIHR6czogZ3JvdXAudHpzLm1hcCgoXykgPT4gXy5sYWJlbCksXG4gICAgICAgIH07XG4gICAgICAgIGhvb2tzPy5vbkZpbmFsR3JvdXBDcmVhdGU/LihmaW5hbEdyb3VwaW5nLCBncm91cCk7XG4gICAgICAgIHJldHVybiBmaW5hbEdyb3VwaW5nO1xuICAgIH0pXG4gICAgICAgIC5zb3J0KChhLCBiKSA9PiBiLnR6cy5sZW5ndGggLSBhLnR6cy5sZW5ndGgpO1xuICAgIGlmIChkZWJ1Zykge1xuICAgICAgICBjb25zdCBtaXNzaW5nVHpzID0gc3VwcG9ydGVkVGltZVpvbmVzXG4gICAgICAgICAgICAubWFwKCh0eikgPT4gKGZpbmFsR3JvdXBpbmcuc29tZSgoeSkgPT4geS50enMuaW5jbHVkZXModHopKSA/IG51bGwgOiB0eikpXG4gICAgICAgICAgICAuZmlsdGVyKEJvb2xlYW4pO1xuICAgICAgICBpZiAobWlzc2luZ1R6cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZXJlIGFyZSAke21pc3NpbmdUenMubGVuZ3RofSBtaXNzaW5nIHRpbWV6b25lczogJHttaXNzaW5nVHpzLnRvU3RyaW5nKCl9YCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGhvb2tzPy5vbkZpbmFsR3JvdXBpbmdDcmVhdGVcbiAgICAgICAgPyBob29rcy5vbkZpbmFsR3JvdXBpbmdDcmVhdGUoZmluYWxHcm91cGluZylcbiAgICAgICAgOiBmaW5hbEdyb3VwaW5nO1xufVxuXG5leHBvcnQgeyBncm91cFRpbWVab25lcyB9O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC0wNGZlOTgzOS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=