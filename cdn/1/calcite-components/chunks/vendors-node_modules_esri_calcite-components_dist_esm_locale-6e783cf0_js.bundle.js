"use strict";
(self["webpackChunkexb_client"] = self["webpackChunkexb_client"] || []).push([["vendors-node_modules_esri_calcite-components_dist_esm_locale-6e783cf0_js"],{

/***/ "./node_modules/@esri/calcite-components/dist/esm/key-61f82ddb.js":
/*!************************************************************************!*\
  !*** ./node_modules/@esri/calcite-components/dist/esm/key-61f82ddb.js ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   i: () => (/* binding */ isActivationKey),
/* harmony export */   n: () => (/* binding */ numberKeys)
/* harmony export */ });
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * See https://github.com/Esri/calcite-design-system/blob/main/LICENSE.md for details.
 * v2.0.0
 */
function isActivationKey(key) {
  return key === "Enter" || key === " ";
}
const numberKeys = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9"];



//# sourceMappingURL=key-61f82ddb.js.map

/***/ }),

/***/ "./node_modules/@esri/calcite-components/dist/esm/locale-6e783cf0.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@esri/calcite-components/dist/esm/locale-6e783cf0.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   B: () => (/* binding */ BigDecimal),
/* harmony export */   a: () => (/* binding */ addLocalizedTrailingDecimalZeros),
/* harmony export */   b: () => (/* binding */ defaultNumberingSystem),
/* harmony export */   c: () => (/* binding */ connectLocalized),
/* harmony export */   d: () => (/* binding */ disconnectLocalized),
/* harmony export */   e: () => (/* binding */ getDateTimeFormat),
/* harmony export */   f: () => (/* binding */ getSupportedNumberingSystem),
/* harmony export */   g: () => (/* binding */ getSupportedLocale),
/* harmony export */   i: () => (/* binding */ isValidNumber),
/* harmony export */   n: () => (/* binding */ numberStringFormatter),
/* harmony export */   p: () => (/* binding */ parseNumberString),
/* harmony export */   s: () => (/* binding */ sanitizeNumberString)
/* harmony export */ });
/* harmony import */ var _dom_ed00a585_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dom-ed00a585.js */ "./node_modules/@esri/calcite-components/dist/esm/dom-ed00a585.js");
/* harmony import */ var _key_61f82ddb_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./key-61f82ddb.js */ "./node_modules/@esri/calcite-components/dist/esm/key-61f82ddb.js");
/* harmony import */ var _observers_71d332db_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./observers-71d332db.js */ "./node_modules/@esri/calcite-components/dist/esm/observers-71d332db.js");
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * See https://github.com/Esri/calcite-design-system/blob/main/LICENSE.md for details.
 * v2.0.0
 */




const unnecessaryDecimal = new RegExp(`\\${"."}(0+)?$`);
const trailingZeros = new RegExp("0+$");
// adopted from https://stackoverflow.com/a/66939244
class BigDecimal {
  constructor(input) {
    if (input instanceof BigDecimal) {
      return input;
    }
    const [integers, decimals] = expandExponentialNumberString(input).split(".").concat("");
    this.value =
      BigInt(integers + decimals.padEnd(BigDecimal.DECIMALS, "0").slice(0, BigDecimal.DECIMALS)) +
        BigInt(BigDecimal.ROUNDED && decimals[BigDecimal.DECIMALS] >= "5");
    this.isNegative = input.charAt(0) === "-";
  }
  getIntegersAndDecimals() {
    const s = this.value
      .toString()
      .replace("-", "")
      .padStart(BigDecimal.DECIMALS + 1, "0");
    const integers = s.slice(0, -BigDecimal.DECIMALS);
    const decimals = s.slice(-BigDecimal.DECIMALS).replace(trailingZeros, "");
    return { integers, decimals };
  }
  toString() {
    const { integers, decimals } = this.getIntegersAndDecimals();
    return `${this.isNegative ? "-" : ""}${integers}${decimals.length ? "." + decimals : ""}`;
  }
  formatToParts(formatter) {
    const { integers, decimals } = this.getIntegersAndDecimals();
    const parts = formatter.numberFormatter.formatToParts(BigInt(integers));
    this.isNegative && parts.unshift({ type: "minusSign", value: formatter.minusSign });
    if (decimals.length) {
      parts.push({ type: "decimal", value: formatter.decimal });
      decimals.split("").forEach((char) => parts.push({ type: "fraction", value: char }));
    }
    return parts;
  }
  format(formatter) {
    const { integers, decimals } = this.getIntegersAndDecimals();
    const integersFormatted = `${this.isNegative ? formatter.minusSign : ""}${formatter.numberFormatter.format(BigInt(integers))}`;
    const decimalsFormatted = decimals.length
      ? `${formatter.decimal}${decimals
        .split("")
        .map((char) => formatter.numberFormatter.format(Number(char)))
        .join("")}`
      : "";
    return `${integersFormatted}${decimalsFormatted}`;
  }
  add(n) {
    return BigDecimal.fromBigInt(this.value + new BigDecimal(n).value);
  }
  subtract(n) {
    return BigDecimal.fromBigInt(this.value - new BigDecimal(n).value);
  }
  multiply(n) {
    return BigDecimal._divRound(this.value * new BigDecimal(n).value, BigDecimal.SHIFT);
  }
  divide(n) {
    return BigDecimal._divRound(this.value * BigDecimal.SHIFT, new BigDecimal(n).value);
  }
}
// Configuration: constants
BigDecimal.DECIMALS = 100; // number of decimals on all instances
BigDecimal.ROUNDED = true; // numbers are truncated (false) or rounded (true)
BigDecimal.SHIFT = BigInt("1" + "0".repeat(BigDecimal.DECIMALS)); // derived constant
BigDecimal._divRound = (dividend, divisor) => BigDecimal.fromBigInt(dividend / divisor + (BigDecimal.ROUNDED ? ((dividend * BigInt(2)) / divisor) % BigInt(2) : BigInt(0)));
BigDecimal.fromBigInt = (bigint) => Object.assign(Object.create(BigDecimal.prototype), { value: bigint, isNegative: bigint < BigInt(0) });
function isValidNumber(numberString) {
  return !(!numberString || isNaN(Number(numberString)));
}
function parseNumberString(numberString) {
  if (!numberString || !stringContainsNumbers(numberString)) {
    return "";
  }
  return sanitizeExponentialNumberString(numberString, (nonExpoNumString) => {
    let containsDecimal = false;
    const result = nonExpoNumString
      .split("")
      .filter((value, i) => {
      if (value.match(/\./g) && !containsDecimal) {
        containsDecimal = true;
        return true;
      }
      if (value.match(/\-/g) && i === 0) {
        return true;
      }
      return _key_61f82ddb_js__WEBPACK_IMPORTED_MODULE_1__.n.includes(value);
    })
      .join("");
    return isValidNumber(result) ? new BigDecimal(result).toString() : "";
  });
}
// regex for number sanitization
const allLeadingZerosOptionallyNegative = /^([-0])0+(?=\d)/;
const decimalOnlyAtEndOfString = /(?!^\.)\.$/;
const allHyphensExceptTheStart = /(?!^-)-/g;
const isNegativeDecimalOnlyZeros = /^-\b0\b\.?0*$/;
const hasTrailingDecimalZeros = /0*$/;
const sanitizeNumberString = (numberString) => sanitizeExponentialNumberString(numberString, (nonExpoNumString) => {
  const sanitizedValue = nonExpoNumString
    .replace(allHyphensExceptTheStart, "")
    .replace(decimalOnlyAtEndOfString, "")
    .replace(allLeadingZerosOptionallyNegative, "$1");
  return isValidNumber(sanitizedValue)
    ? isNegativeDecimalOnlyZeros.test(sanitizedValue)
      ? sanitizedValue
      : getBigDecimalAsString(sanitizedValue)
    : nonExpoNumString;
});
function getBigDecimalAsString(sanitizedValue) {
  const sanitizedValueDecimals = sanitizedValue.split(".")[1];
  const value = new BigDecimal(sanitizedValue).toString();
  const [bigDecimalValueInteger, bigDecimalValueDecimals] = value.split(".");
  return sanitizedValueDecimals && bigDecimalValueDecimals !== sanitizedValueDecimals
    ? `${bigDecimalValueInteger}.${sanitizedValueDecimals}`
    : value;
}
function sanitizeExponentialNumberString(numberString, func) {
  if (!numberString) {
    return numberString;
  }
  const firstE = numberString.toLowerCase().indexOf("e") + 1;
  if (!firstE) {
    return func(numberString);
  }
  return numberString
    .replace(/[eE]*$/g, "")
    .substring(0, firstE)
    .concat(numberString.slice(firstE).replace(/[eE]/g, ""))
    .split(/[eE]/)
    .map((section, i) => (i === 1 ? func(section.replace(/\./g, "")) : func(section)))
    .join("e")
    .replace(/^e/, "1e");
}
/**
 * Converts an exponential notation numberString into decimal notation.
 * BigInt doesn't support exponential notation, so this is required to maintain precision
 *
 * @param {string} numberString - pre-validated exponential or decimal number
 * @returns {string} numberString in decimal notation
 */
function expandExponentialNumberString(numberString) {
  const exponentialParts = numberString.split(/[eE]/);
  if (exponentialParts.length === 1) {
    return numberString;
  }
  const number = +numberString;
  if (Number.isSafeInteger(number)) {
    return `${number}`;
  }
  const isNegative = numberString.charAt(0) === "-";
  const magnitude = +exponentialParts[1];
  const decimalParts = exponentialParts[0].split(".");
  const integers = (isNegative ? decimalParts[0].substring(1) : decimalParts[0]) || "";
  const decimals = decimalParts[1] || "";
  const shiftDecimalLeft = (integers, magnitude) => {
    const magnitudeDelta = Math.abs(magnitude) - integers.length;
    const leftPaddedZeros = magnitudeDelta > 0 ? `${"0".repeat(magnitudeDelta)}${integers}` : integers;
    const shiftedDecimal = `${leftPaddedZeros.slice(0, magnitude)}${"."}${leftPaddedZeros.slice(magnitude)}`;
    return shiftedDecimal;
  };
  const shiftDecimalRight = (decimals, magnitude) => {
    const rightPaddedZeros = magnitude > decimals.length ? `${decimals}${"0".repeat(magnitude - decimals.length)}` : decimals;
    const shiftedDecimal = `${rightPaddedZeros.slice(0, magnitude)}${"."}${rightPaddedZeros.slice(magnitude)}`;
    return shiftedDecimal;
  };
  const expandedNumberString = magnitude > 0
    ? `${integers}${shiftDecimalRight(decimals, magnitude)}`
    : `${shiftDecimalLeft(integers, magnitude)}${decimals}`;
  return `${isNegative ? "-" : ""}${expandedNumberString.charAt(0) === "." ? "0" : ""}${expandedNumberString
    .replace(unnecessaryDecimal, "")
    .replace(allLeadingZerosOptionallyNegative, "")}`;
}
function stringContainsNumbers(string) {
  return _key_61f82ddb_js__WEBPACK_IMPORTED_MODULE_1__.n.some((number) => string.includes(number));
}
/**
 * Adds localized trailing decimals zero values to the number string.
 * BigInt conversion to string removes the trailing decimal zero values (Ex: 1.000 is returned as 1). This method helps adding them back.
 *
 * @param {string} localizedValue - localized number string value
 * @param {string} value - current value in the input field
 * @param {NumberStringFormat} formatter - numberStringFormatter instance to localize the number value
 * @returns {string} localized number string value
 */
function addLocalizedTrailingDecimalZeros(localizedValue, value, formatter) {
  const decimals = value.split(".")[1];
  if (decimals) {
    const trailingDecimalZeros = decimals.match(hasTrailingDecimalZeros)[0];
    if (trailingDecimalZeros &&
      formatter.delocalize(localizedValue).length !== value.length &&
      decimals.indexOf("e") === -1) {
      const decimalSeparator = formatter.decimal;
      localizedValue = !localizedValue.includes(decimalSeparator)
        ? `${localizedValue}${decimalSeparator}`
        : localizedValue;
      return localizedValue.padEnd(localizedValue.length + trailingDecimalZeros.length, formatter.localize("0"));
    }
  }
  return localizedValue;
}

const defaultLocale = "en";
const t9nLocales = [
  "ar",
  "bg",
  "bs",
  "ca",
  "cs",
  "da",
  "de",
  "el",
  defaultLocale,
  "es",
  "et",
  "fi",
  "fr",
  "he",
  "hr",
  "hu",
  "id",
  "it",
  "ja",
  "ko",
  "lt",
  "lv",
  "no",
  "nl",
  "pl",
  "pt-BR",
  "pt-PT",
  "ro",
  "ru",
  "sk",
  "sl",
  "sr",
  "sv",
  "th",
  "tr",
  "uk",
  "vi",
  "zh-CN",
  "zh-HK",
  "zh-TW",
];
const locales = [
  "ar",
  "bg",
  "bs",
  "ca",
  "cs",
  "da",
  "de",
  "de-AT",
  "de-CH",
  "el",
  defaultLocale,
  "en-AU",
  "en-CA",
  "en-GB",
  "es",
  "es-MX",
  "et",
  "fi",
  "fr",
  "fr-CH",
  "he",
  "hi",
  "hr",
  "hu",
  "id",
  "it",
  "it-CH",
  "ja",
  "ko",
  "lt",
  "lv",
  "mk",
  "no",
  "nl",
  "pl",
  "pt",
  "pt-PT",
  "ro",
  "ru",
  "sk",
  "sl",
  "sr",
  "sv",
  "th",
  "tr",
  "uk",
  "vi",
  "zh-CN",
  "zh-HK",
  "zh-TW",
];
const numberingSystems = ["arab", "arabext", "latn"];
const isNumberingSystemSupported = (numberingSystem) => numberingSystems.includes(numberingSystem);
const browserNumberingSystem = new Intl.NumberFormat().resolvedOptions().numberingSystem;
// for consistent browser behavior, we normalize numberingSystem to prevent the browser-inferred value
// see https://github.com/Esri/calcite-design-system/issues/3079#issuecomment-1168964195 for more info
const defaultNumberingSystem = browserNumberingSystem === "arab" || !isNumberingSystemSupported(browserNumberingSystem)
  ? "latn"
  : browserNumberingSystem;
const getSupportedNumberingSystem = (numberingSystem) => isNumberingSystemSupported(numberingSystem) ? numberingSystem : defaultNumberingSystem;
/**
 * Gets the locale that best matches the context.
 *
 * @param locale – the BCP 47 locale code
 * @param context - specifies whether the locale code should match in the context of CLDR or T9N (translation)
 */
function getSupportedLocale(locale, context = "cldr") {
  const contextualLocales = context === "cldr" ? locales : t9nLocales;
  if (!locale) {
    return defaultLocale;
  }
  if (contextualLocales.includes(locale)) {
    return locale;
  }
  locale = locale.toLowerCase();
  // we support both 'nb' and 'no' (BCP 47) for Norwegian but only `no` has corresponding bundle
  if (locale === "nb") {
    return "no";
  }
  // we use `pt-BR` as it will have the same translations as `pt`, which has no corresponding bundle
  if (context === "t9n" && locale === "pt") {
    return "pt-BR";
  }
  if (locale.includes("-")) {
    locale = locale.replace(/(\w+)-(\w+)/, (_match, language, region) => `${language}-${region.toUpperCase()}`);
    if (!contextualLocales.includes(locale)) {
      locale = locale.split("-")[0];
    }
  }
  // we can `zh-CN` as base translation for chinese locales which has no corresponding bundle.
  if (locale === "zh") {
    return "zh-CN";
  }
  if (!contextualLocales.includes(locale)) {
    console.warn(`Translations for the "${locale}" locale are not available and will fall back to the default, English (en).`);
    return defaultLocale;
  }
  return locale;
}
const connectedComponents = new Set();
/**
 * This utility sets up internals for messages support.
 *
 * It needs to be called in `connectedCallback` before any logic that depends on locale
 *
 * @param component
 */
function connectLocalized(component) {
  updateEffectiveLocale(component);
  if (connectedComponents.size === 0) {
    mutationObserver?.observe(document.documentElement, {
      attributes: true,
      attributeFilter: ["lang"],
      subtree: true,
    });
  }
  connectedComponents.add(component);
}
/**
 * This is only exported for components that implemented the now deprecated `locale` prop.
 *
 * Do not use this utils for new components.
 *
 * @param component
 */
function updateEffectiveLocale(component) {
  component.effectiveLocale = getLocale(component);
}
/**
 * This utility tears down internals for messages support.
 *
 * It needs to be called in `disconnectedCallback`
 *
 * @param component
 */
function disconnectLocalized(component) {
  connectedComponents.delete(component);
  if (connectedComponents.size === 0) {
    mutationObserver.disconnect();
  }
}
const mutationObserver = (0,_observers_71d332db_js__WEBPACK_IMPORTED_MODULE_2__.c)("mutation", (records) => {
  records.forEach((record) => {
    const el = record.target;
    connectedComponents.forEach((component) => {
      const inUnrelatedSubtree = !(0,_dom_ed00a585_js__WEBPACK_IMPORTED_MODULE_0__.a)(el, component.el);
      if (inUnrelatedSubtree) {
        return;
      }
      const closestLangEl = (0,_dom_ed00a585_js__WEBPACK_IMPORTED_MODULE_0__.c)(component.el, "[lang]");
      if (!closestLangEl) {
        component.effectiveLocale = defaultLocale;
        return;
      }
      const closestLang = closestLangEl.lang;
      component.effectiveLocale =
        // user set lang="" means unknown language, so we use default
        closestLangEl.hasAttribute("lang") && closestLang === "" ? defaultLocale : closestLang;
    });
  });
});
/**
 * This util helps resolve a component's locale.
 * It will also fall back on the deprecated `locale` if a component implemented this previously.
 *
 * @param component
 */
function getLocale(component) {
  return (component.el.lang ||
    (0,_dom_ed00a585_js__WEBPACK_IMPORTED_MODULE_0__.c)(component.el, "[lang]")?.lang ||
    document.documentElement.lang ||
    defaultLocale);
}
/**
 * This util formats and parses numbers for localization
 */
class NumberStringFormat {
  constructor() {
    this.delocalize = (numberString) => 
    // For performance, (de)localization is skipped if the formatter isn't initialized.
    // In order to localize/delocalize, e.g. when lang/numberingSystem props are not default values,
    // `numberFormatOptions` must be set in a component to create and cache the formatter.
    this._numberFormatOptions
      ? sanitizeExponentialNumberString(numberString, (nonExpoNumString) => nonExpoNumString
        .replace(new RegExp(`[${this._minusSign}]`, "g"), "-")
        .replace(new RegExp(`[${this._group}]`, "g"), "")
        .replace(new RegExp(`[${this._decimal}]`, "g"), ".")
        .replace(new RegExp(`[${this._digits.join("")}]`, "g"), this._getDigitIndex))
      : numberString;
    this.localize = (numberString) => this._numberFormatOptions
      ? sanitizeExponentialNumberString(numberString, (nonExpoNumString) => isValidNumber(nonExpoNumString.trim())
        ? new BigDecimal(nonExpoNumString.trim())
          .format(this)
          .replace(new RegExp(`[${this._actualGroup}]`, "g"), this._group)
        : nonExpoNumString)
      : numberString;
  }
  get group() {
    return this._group;
  }
  get decimal() {
    return this._decimal;
  }
  get minusSign() {
    return this._minusSign;
  }
  get digits() {
    return this._digits;
  }
  get numberFormatter() {
    return this._numberFormatter;
  }
  get numberFormatOptions() {
    return this._numberFormatOptions;
  }
  /**
   * numberFormatOptions needs to be set before localize/delocalize is called to ensure the options are up to date
   */
  set numberFormatOptions(options) {
    options.locale = getSupportedLocale(options?.locale);
    options.numberingSystem = getSupportedNumberingSystem(options?.numberingSystem);
    if (
    // No need to create the formatter if `locale` and `numberingSystem`
    // are the default values and `numberFormatOptions` has not been set
    (!this._numberFormatOptions &&
      options.locale === defaultLocale &&
      options.numberingSystem === defaultNumberingSystem &&
      // don't skip initialization if any options besides locale/numberingSystem are set
      Object.keys(options).length === 2) ||
      // cache formatter by only recreating when options change
      JSON.stringify(this._numberFormatOptions) === JSON.stringify(options)) {
      return;
    }
    this._numberFormatOptions = options;
    this._numberFormatter = new Intl.NumberFormat(this._numberFormatOptions.locale, this._numberFormatOptions);
    this._digits = [
      ...new Intl.NumberFormat(this._numberFormatOptions.locale, {
        useGrouping: false,
        numberingSystem: this._numberFormatOptions.numberingSystem,
      }).format(9876543210),
    ].reverse();
    const index = new Map(this._digits.map((d, i) => [d, i]));
    // numberingSystem is parsed to return consistent decimal separator across browsers.
    const parts = new Intl.NumberFormat(this._numberFormatOptions.locale, {
      numberingSystem: this._numberFormatOptions.numberingSystem,
    }).formatToParts(-12345678.9);
    this._actualGroup = parts.find((d) => d.type === "group").value;
    // change whitespace group separators to the unicode non-breaking space (nbsp)
    this._group = this._actualGroup.trim().length === 0 || this._actualGroup == " " ? "\u00A0" : this._actualGroup;
    this._decimal = parts.find((d) => d.type === "decimal").value;
    this._minusSign = parts.find((d) => d.type === "minusSign").value;
    this._getDigitIndex = (d) => index.get(d);
  }
}
const numberStringFormatter = new NumberStringFormat();
/**
 * Exported for testing purposes only.
 *
 * @internal
 */
let dateTimeFormatCache;
/**
 * Used to ensure all cached formats are for the same locale.
 *
 * @internal
 */
let previousLocaleUsedForCaching;
/**
 * Generates a cache key for date time format lookups.
 *
 * @internal
 */
function buildDateTimeFormatCacheKey(options = {}) {
  return Object.entries(options)
    .sort(([key1], [key2]) => key1.localeCompare(key2))
    .map((keyValue) => `${keyValue[0]}-${keyValue[1]}`)
    .flat()
    .join(":");
}
/**
 * Returns an instance of Intl.DateTimeFormat and reuses it if requested with the same locale and options.
 *
 * **Note**: the cache will be cleared if a different locale is provided
 *
 * @internal
 */
function getDateTimeFormat(locale, options) {
  locale = getSupportedLocale(locale);
  if (!dateTimeFormatCache) {
    dateTimeFormatCache = new Map();
  }
  if (previousLocaleUsedForCaching !== locale) {
    dateTimeFormatCache.clear();
    previousLocaleUsedForCaching = locale;
  }
  const key = buildDateTimeFormatCacheKey(options);
  const cached = dateTimeFormatCache.get(key);
  if (cached) {
    return cached;
  }
  const format = new Intl.DateTimeFormat(locale, options);
  dateTimeFormatCache.set(key, format);
  return format;
}



//# sourceMappingURL=locale-6e783cf0.js.map

/***/ }),

/***/ "./node_modules/@esri/calcite-components/dist/esm/observers-71d332db.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@esri/calcite-components/dist/esm/observers-71d332db.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   c: () => (/* binding */ createObserver)
/* harmony export */ });
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * See https://github.com/Esri/calcite-design-system/blob/main/LICENSE.md for details.
 * v2.0.0
 */
/**
 * This utility ensures observers are created only for browser contexts.
 *
 * @param type - the type of observer to create
 * @param callback - the observer callback
 * @param options - the observer options
 */
function createObserver(type, callback, options) {
  const Observer = getObserver(type);
  return new Observer(callback, options);
}
function getObserver(type) {
  // based on https://github.com/whatwg/dom/issues/126#issuecomment-1049814948
  class ExtendedMutationObserver extends window.MutationObserver {
    constructor(callback) {
      super(callback);
      this.observedEntry = [];
      this.callback = callback;
    }
    observe(target, options) {
      this.observedEntry.push({ target, options });
      return super.observe(target, options);
    }
    unobserve(target) {
      const newObservedEntries = this.observedEntry.filter((observed) => observed.target !== target);
      this.observedEntry = [];
      this.callback(super.takeRecords(), this);
      this.disconnect();
      newObservedEntries.forEach((observed) => this.observe(observed.target, observed.options));
    }
  }
  return (function () {
    return (type === "intersection"
      ? window.IntersectionObserver
      : type === "mutation"
        ? ExtendedMutationObserver
        : window.ResizeObserver);
  })();
}



//# sourceMappingURL=observers-71d332db.js.map

/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2FsY2l0ZS1jb21wb25lbnRzL2NodW5rcy92ZW5kb3JzLW5vZGVfbW9kdWxlc19lc3JpX2NhbGNpdGUtY29tcG9uZW50c19kaXN0X2VzbV9sb2NhbGUtNmU3ODNjZjBfanMuYnVuZGxlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVpRDs7QUFFakQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQzZHO0FBQ3pEO0FBQ1U7O0FBRTlELDJDQUEyQyxJQUFJO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFlBQVkscUJBQXFCO0FBQ2pDLGNBQWMsMkJBQTJCLEVBQUUsU0FBUyxFQUFFLHNDQUFzQztBQUM1RjtBQUNBO0FBQ0EsWUFBWSxxQkFBcUI7QUFDakM7QUFDQSx1Q0FBdUMsK0NBQStDO0FBQ3RGO0FBQ0EsbUJBQW1CLDJDQUEyQztBQUM5RCx3REFBd0QsK0JBQStCO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxxQkFBcUI7QUFDakMsaUNBQWlDLDJDQUEyQyxFQUFFLG1EQUFtRDtBQUNqSTtBQUNBLFdBQVcsa0JBQWtCLEVBQUU7QUFDL0I7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBLGNBQWMsa0JBQWtCLEVBQUUsa0JBQWtCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQiwyQkFBMkI7QUFDM0Isa0VBQWtFO0FBQ2xFO0FBQ0EseUZBQXlGLCtDQUErQztBQUN4STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsK0NBQVU7QUFDdkIsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyx1QkFBdUIsR0FBRyx1QkFBdUI7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELDJCQUEyQixFQUFFLFNBQVM7QUFDMUYsOEJBQThCLG9DQUFvQyxFQUFFLElBQUksRUFBRSxpQ0FBaUM7QUFDM0c7QUFDQTtBQUNBO0FBQ0EsOERBQThELFNBQVMsRUFBRSx3Q0FBd0M7QUFDakgsOEJBQThCLHFDQUFxQyxFQUFFLElBQUksRUFBRSxrQ0FBa0M7QUFDN0c7QUFDQTtBQUNBO0FBQ0EsU0FBUyxTQUFTLEVBQUUsdUNBQXVDO0FBQzNELFNBQVMsc0NBQXNDLEVBQUUsU0FBUztBQUMxRCxZQUFZLHNCQUFzQixFQUFFLGtEQUFrRCxFQUFFO0FBQ3hGO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQSxTQUFTLCtDQUFVO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsb0JBQW9CO0FBQy9CLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZUFBZSxFQUFFLGlCQUFpQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRFQUE0RSxTQUFTLEdBQUcscUJBQXFCO0FBQzdHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxPQUFPO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIseURBQWM7QUFDdkM7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLG1EQUEyQjtBQUM3RDtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsbURBQWlDO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxtREFBaUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxnQkFBZ0I7QUFDaEQsZ0NBQWdDLFlBQVk7QUFDNUMsZ0NBQWdDLGNBQWM7QUFDOUMsZ0NBQWdDLHNCQUFzQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLGtCQUFrQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQSwwQkFBMEIsWUFBWSxHQUFHLFlBQVk7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRXNVOztBQUV0VTs7Ozs7Ozs7Ozs7Ozs7QUNsakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGlCQUFpQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFK0I7O0FBRS9CIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZXhiLWNsaWVudC8uL25vZGVfbW9kdWxlcy9AZXNyaS9jYWxjaXRlLWNvbXBvbmVudHMvZGlzdC9lc20va2V5LTYxZjgyZGRiLmpzIiwid2VicGFjazovL2V4Yi1jbGllbnQvLi9ub2RlX21vZHVsZXMvQGVzcmkvY2FsY2l0ZS1jb21wb25lbnRzL2Rpc3QvZXNtL2xvY2FsZS02ZTc4M2NmMC5qcyIsIndlYnBhY2s6Ly9leGItY2xpZW50Ly4vbm9kZV9tb2R1bGVzL0Blc3JpL2NhbGNpdGUtY29tcG9uZW50cy9kaXN0L2VzbS9vYnNlcnZlcnMtNzFkMzMyZGIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBBbGwgbWF0ZXJpYWwgY29weXJpZ2h0IEVTUkksIEFsbCBSaWdodHMgUmVzZXJ2ZWQsIHVubGVzcyBvdGhlcndpc2Ugc3BlY2lmaWVkLlxuICogU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9Fc3JpL2NhbGNpdGUtZGVzaWduLXN5c3RlbS9ibG9iL21haW4vTElDRU5TRS5tZCBmb3IgZGV0YWlscy5cbiAqIHYyLjAuMFxuICovXG5mdW5jdGlvbiBpc0FjdGl2YXRpb25LZXkoa2V5KSB7XG4gIHJldHVybiBrZXkgPT09IFwiRW50ZXJcIiB8fCBrZXkgPT09IFwiIFwiO1xufVxuY29uc3QgbnVtYmVyS2V5cyA9IFtcIjBcIiwgXCIxXCIsIFwiMlwiLCBcIjNcIiwgXCI0XCIsIFwiNVwiLCBcIjZcIiwgXCI3XCIsIFwiOFwiLCBcIjlcIl07XG5cbmV4cG9ydCB7IGlzQWN0aXZhdGlvbktleSBhcyBpLCBudW1iZXJLZXlzIGFzIG4gfTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9a2V5LTYxZjgyZGRiLmpzLm1hcCIsIi8qIVxuICogQWxsIG1hdGVyaWFsIGNvcHlyaWdodCBFU1JJLCBBbGwgUmlnaHRzIFJlc2VydmVkLCB1bmxlc3Mgb3RoZXJ3aXNlIHNwZWNpZmllZC5cbiAqIFNlZSBodHRwczovL2dpdGh1Yi5jb20vRXNyaS9jYWxjaXRlLWRlc2lnbi1zeXN0ZW0vYmxvYi9tYWluL0xJQ0VOU0UubWQgZm9yIGRldGFpbHMuXG4gKiB2Mi4wLjBcbiAqL1xuaW1wb3J0IHsgYyBhcyBjbG9zZXN0RWxlbWVudENyb3NzU2hhZG93Qm91bmRhcnksIGEgYXMgY29udGFpbnNDcm9zc1NoYWRvd0JvdW5kYXJ5IH0gZnJvbSAnLi9kb20tZWQwMGE1ODUuanMnO1xuaW1wb3J0IHsgbiBhcyBudW1iZXJLZXlzIH0gZnJvbSAnLi9rZXktNjFmODJkZGIuanMnO1xuaW1wb3J0IHsgYyBhcyBjcmVhdGVPYnNlcnZlciB9IGZyb20gJy4vb2JzZXJ2ZXJzLTcxZDMzMmRiLmpzJztcblxuY29uc3QgdW5uZWNlc3NhcnlEZWNpbWFsID0gbmV3IFJlZ0V4cChgXFxcXCR7XCIuXCJ9KDArKT8kYCk7XG5jb25zdCB0cmFpbGluZ1plcm9zID0gbmV3IFJlZ0V4cChcIjArJFwiKTtcbi8vIGFkb3B0ZWQgZnJvbSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvNjY5MzkyNDRcbmNsYXNzIEJpZ0RlY2ltYWwge1xuICBjb25zdHJ1Y3RvcihpbnB1dCkge1xuICAgIGlmIChpbnB1dCBpbnN0YW5jZW9mIEJpZ0RlY2ltYWwpIHtcbiAgICAgIHJldHVybiBpbnB1dDtcbiAgICB9XG4gICAgY29uc3QgW2ludGVnZXJzLCBkZWNpbWFsc10gPSBleHBhbmRFeHBvbmVudGlhbE51bWJlclN0cmluZyhpbnB1dCkuc3BsaXQoXCIuXCIpLmNvbmNhdChcIlwiKTtcbiAgICB0aGlzLnZhbHVlID1cbiAgICAgIEJpZ0ludChpbnRlZ2VycyArIGRlY2ltYWxzLnBhZEVuZChCaWdEZWNpbWFsLkRFQ0lNQUxTLCBcIjBcIikuc2xpY2UoMCwgQmlnRGVjaW1hbC5ERUNJTUFMUykpICtcbiAgICAgICAgQmlnSW50KEJpZ0RlY2ltYWwuUk9VTkRFRCAmJiBkZWNpbWFsc1tCaWdEZWNpbWFsLkRFQ0lNQUxTXSA+PSBcIjVcIik7XG4gICAgdGhpcy5pc05lZ2F0aXZlID0gaW5wdXQuY2hhckF0KDApID09PSBcIi1cIjtcbiAgfVxuICBnZXRJbnRlZ2Vyc0FuZERlY2ltYWxzKCkge1xuICAgIGNvbnN0IHMgPSB0aGlzLnZhbHVlXG4gICAgICAudG9TdHJpbmcoKVxuICAgICAgLnJlcGxhY2UoXCItXCIsIFwiXCIpXG4gICAgICAucGFkU3RhcnQoQmlnRGVjaW1hbC5ERUNJTUFMUyArIDEsIFwiMFwiKTtcbiAgICBjb25zdCBpbnRlZ2VycyA9IHMuc2xpY2UoMCwgLUJpZ0RlY2ltYWwuREVDSU1BTFMpO1xuICAgIGNvbnN0IGRlY2ltYWxzID0gcy5zbGljZSgtQmlnRGVjaW1hbC5ERUNJTUFMUykucmVwbGFjZSh0cmFpbGluZ1plcm9zLCBcIlwiKTtcbiAgICByZXR1cm4geyBpbnRlZ2VycywgZGVjaW1hbHMgfTtcbiAgfVxuICB0b1N0cmluZygpIHtcbiAgICBjb25zdCB7IGludGVnZXJzLCBkZWNpbWFscyB9ID0gdGhpcy5nZXRJbnRlZ2Vyc0FuZERlY2ltYWxzKCk7XG4gICAgcmV0dXJuIGAke3RoaXMuaXNOZWdhdGl2ZSA/IFwiLVwiIDogXCJcIn0ke2ludGVnZXJzfSR7ZGVjaW1hbHMubGVuZ3RoID8gXCIuXCIgKyBkZWNpbWFscyA6IFwiXCJ9YDtcbiAgfVxuICBmb3JtYXRUb1BhcnRzKGZvcm1hdHRlcikge1xuICAgIGNvbnN0IHsgaW50ZWdlcnMsIGRlY2ltYWxzIH0gPSB0aGlzLmdldEludGVnZXJzQW5kRGVjaW1hbHMoKTtcbiAgICBjb25zdCBwYXJ0cyA9IGZvcm1hdHRlci5udW1iZXJGb3JtYXR0ZXIuZm9ybWF0VG9QYXJ0cyhCaWdJbnQoaW50ZWdlcnMpKTtcbiAgICB0aGlzLmlzTmVnYXRpdmUgJiYgcGFydHMudW5zaGlmdCh7IHR5cGU6IFwibWludXNTaWduXCIsIHZhbHVlOiBmb3JtYXR0ZXIubWludXNTaWduIH0pO1xuICAgIGlmIChkZWNpbWFscy5sZW5ndGgpIHtcbiAgICAgIHBhcnRzLnB1c2goeyB0eXBlOiBcImRlY2ltYWxcIiwgdmFsdWU6IGZvcm1hdHRlci5kZWNpbWFsIH0pO1xuICAgICAgZGVjaW1hbHMuc3BsaXQoXCJcIikuZm9yRWFjaCgoY2hhcikgPT4gcGFydHMucHVzaCh7IHR5cGU6IFwiZnJhY3Rpb25cIiwgdmFsdWU6IGNoYXIgfSkpO1xuICAgIH1cbiAgICByZXR1cm4gcGFydHM7XG4gIH1cbiAgZm9ybWF0KGZvcm1hdHRlcikge1xuICAgIGNvbnN0IHsgaW50ZWdlcnMsIGRlY2ltYWxzIH0gPSB0aGlzLmdldEludGVnZXJzQW5kRGVjaW1hbHMoKTtcbiAgICBjb25zdCBpbnRlZ2Vyc0Zvcm1hdHRlZCA9IGAke3RoaXMuaXNOZWdhdGl2ZSA/IGZvcm1hdHRlci5taW51c1NpZ24gOiBcIlwifSR7Zm9ybWF0dGVyLm51bWJlckZvcm1hdHRlci5mb3JtYXQoQmlnSW50KGludGVnZXJzKSl9YDtcbiAgICBjb25zdCBkZWNpbWFsc0Zvcm1hdHRlZCA9IGRlY2ltYWxzLmxlbmd0aFxuICAgICAgPyBgJHtmb3JtYXR0ZXIuZGVjaW1hbH0ke2RlY2ltYWxzXG4gICAgICAgIC5zcGxpdChcIlwiKVxuICAgICAgICAubWFwKChjaGFyKSA9PiBmb3JtYXR0ZXIubnVtYmVyRm9ybWF0dGVyLmZvcm1hdChOdW1iZXIoY2hhcikpKVxuICAgICAgICAuam9pbihcIlwiKX1gXG4gICAgICA6IFwiXCI7XG4gICAgcmV0dXJuIGAke2ludGVnZXJzRm9ybWF0dGVkfSR7ZGVjaW1hbHNGb3JtYXR0ZWR9YDtcbiAgfVxuICBhZGQobikge1xuICAgIHJldHVybiBCaWdEZWNpbWFsLmZyb21CaWdJbnQodGhpcy52YWx1ZSArIG5ldyBCaWdEZWNpbWFsKG4pLnZhbHVlKTtcbiAgfVxuICBzdWJ0cmFjdChuKSB7XG4gICAgcmV0dXJuIEJpZ0RlY2ltYWwuZnJvbUJpZ0ludCh0aGlzLnZhbHVlIC0gbmV3IEJpZ0RlY2ltYWwobikudmFsdWUpO1xuICB9XG4gIG11bHRpcGx5KG4pIHtcbiAgICByZXR1cm4gQmlnRGVjaW1hbC5fZGl2Um91bmQodGhpcy52YWx1ZSAqIG5ldyBCaWdEZWNpbWFsKG4pLnZhbHVlLCBCaWdEZWNpbWFsLlNISUZUKTtcbiAgfVxuICBkaXZpZGUobikge1xuICAgIHJldHVybiBCaWdEZWNpbWFsLl9kaXZSb3VuZCh0aGlzLnZhbHVlICogQmlnRGVjaW1hbC5TSElGVCwgbmV3IEJpZ0RlY2ltYWwobikudmFsdWUpO1xuICB9XG59XG4vLyBDb25maWd1cmF0aW9uOiBjb25zdGFudHNcbkJpZ0RlY2ltYWwuREVDSU1BTFMgPSAxMDA7IC8vIG51bWJlciBvZiBkZWNpbWFscyBvbiBhbGwgaW5zdGFuY2VzXG5CaWdEZWNpbWFsLlJPVU5ERUQgPSB0cnVlOyAvLyBudW1iZXJzIGFyZSB0cnVuY2F0ZWQgKGZhbHNlKSBvciByb3VuZGVkICh0cnVlKVxuQmlnRGVjaW1hbC5TSElGVCA9IEJpZ0ludChcIjFcIiArIFwiMFwiLnJlcGVhdChCaWdEZWNpbWFsLkRFQ0lNQUxTKSk7IC8vIGRlcml2ZWQgY29uc3RhbnRcbkJpZ0RlY2ltYWwuX2RpdlJvdW5kID0gKGRpdmlkZW5kLCBkaXZpc29yKSA9PiBCaWdEZWNpbWFsLmZyb21CaWdJbnQoZGl2aWRlbmQgLyBkaXZpc29yICsgKEJpZ0RlY2ltYWwuUk9VTkRFRCA/ICgoZGl2aWRlbmQgKiBCaWdJbnQoMikpIC8gZGl2aXNvcikgJSBCaWdJbnQoMikgOiBCaWdJbnQoMCkpKTtcbkJpZ0RlY2ltYWwuZnJvbUJpZ0ludCA9IChiaWdpbnQpID0+IE9iamVjdC5hc3NpZ24oT2JqZWN0LmNyZWF0ZShCaWdEZWNpbWFsLnByb3RvdHlwZSksIHsgdmFsdWU6IGJpZ2ludCwgaXNOZWdhdGl2ZTogYmlnaW50IDwgQmlnSW50KDApIH0pO1xuZnVuY3Rpb24gaXNWYWxpZE51bWJlcihudW1iZXJTdHJpbmcpIHtcbiAgcmV0dXJuICEoIW51bWJlclN0cmluZyB8fCBpc05hTihOdW1iZXIobnVtYmVyU3RyaW5nKSkpO1xufVxuZnVuY3Rpb24gcGFyc2VOdW1iZXJTdHJpbmcobnVtYmVyU3RyaW5nKSB7XG4gIGlmICghbnVtYmVyU3RyaW5nIHx8ICFzdHJpbmdDb250YWluc051bWJlcnMobnVtYmVyU3RyaW5nKSkge1xuICAgIHJldHVybiBcIlwiO1xuICB9XG4gIHJldHVybiBzYW5pdGl6ZUV4cG9uZW50aWFsTnVtYmVyU3RyaW5nKG51bWJlclN0cmluZywgKG5vbkV4cG9OdW1TdHJpbmcpID0+IHtcbiAgICBsZXQgY29udGFpbnNEZWNpbWFsID0gZmFsc2U7XG4gICAgY29uc3QgcmVzdWx0ID0gbm9uRXhwb051bVN0cmluZ1xuICAgICAgLnNwbGl0KFwiXCIpXG4gICAgICAuZmlsdGVyKCh2YWx1ZSwgaSkgPT4ge1xuICAgICAgaWYgKHZhbHVlLm1hdGNoKC9cXC4vZykgJiYgIWNvbnRhaW5zRGVjaW1hbCkge1xuICAgICAgICBjb250YWluc0RlY2ltYWwgPSB0cnVlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmICh2YWx1ZS5tYXRjaCgvXFwtL2cpICYmIGkgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVtYmVyS2V5cy5pbmNsdWRlcyh2YWx1ZSk7XG4gICAgfSlcbiAgICAgIC5qb2luKFwiXCIpO1xuICAgIHJldHVybiBpc1ZhbGlkTnVtYmVyKHJlc3VsdCkgPyBuZXcgQmlnRGVjaW1hbChyZXN1bHQpLnRvU3RyaW5nKCkgOiBcIlwiO1xuICB9KTtcbn1cbi8vIHJlZ2V4IGZvciBudW1iZXIgc2FuaXRpemF0aW9uXG5jb25zdCBhbGxMZWFkaW5nWmVyb3NPcHRpb25hbGx5TmVnYXRpdmUgPSAvXihbLTBdKTArKD89XFxkKS87XG5jb25zdCBkZWNpbWFsT25seUF0RW5kT2ZTdHJpbmcgPSAvKD8hXlxcLilcXC4kLztcbmNvbnN0IGFsbEh5cGhlbnNFeGNlcHRUaGVTdGFydCA9IC8oPyFeLSktL2c7XG5jb25zdCBpc05lZ2F0aXZlRGVjaW1hbE9ubHlaZXJvcyA9IC9eLVxcYjBcXGJcXC4/MCokLztcbmNvbnN0IGhhc1RyYWlsaW5nRGVjaW1hbFplcm9zID0gLzAqJC87XG5jb25zdCBzYW5pdGl6ZU51bWJlclN0cmluZyA9IChudW1iZXJTdHJpbmcpID0+IHNhbml0aXplRXhwb25lbnRpYWxOdW1iZXJTdHJpbmcobnVtYmVyU3RyaW5nLCAobm9uRXhwb051bVN0cmluZykgPT4ge1xuICBjb25zdCBzYW5pdGl6ZWRWYWx1ZSA9IG5vbkV4cG9OdW1TdHJpbmdcbiAgICAucmVwbGFjZShhbGxIeXBoZW5zRXhjZXB0VGhlU3RhcnQsIFwiXCIpXG4gICAgLnJlcGxhY2UoZGVjaW1hbE9ubHlBdEVuZE9mU3RyaW5nLCBcIlwiKVxuICAgIC5yZXBsYWNlKGFsbExlYWRpbmdaZXJvc09wdGlvbmFsbHlOZWdhdGl2ZSwgXCIkMVwiKTtcbiAgcmV0dXJuIGlzVmFsaWROdW1iZXIoc2FuaXRpemVkVmFsdWUpXG4gICAgPyBpc05lZ2F0aXZlRGVjaW1hbE9ubHlaZXJvcy50ZXN0KHNhbml0aXplZFZhbHVlKVxuICAgICAgPyBzYW5pdGl6ZWRWYWx1ZVxuICAgICAgOiBnZXRCaWdEZWNpbWFsQXNTdHJpbmcoc2FuaXRpemVkVmFsdWUpXG4gICAgOiBub25FeHBvTnVtU3RyaW5nO1xufSk7XG5mdW5jdGlvbiBnZXRCaWdEZWNpbWFsQXNTdHJpbmcoc2FuaXRpemVkVmFsdWUpIHtcbiAgY29uc3Qgc2FuaXRpemVkVmFsdWVEZWNpbWFscyA9IHNhbml0aXplZFZhbHVlLnNwbGl0KFwiLlwiKVsxXTtcbiAgY29uc3QgdmFsdWUgPSBuZXcgQmlnRGVjaW1hbChzYW5pdGl6ZWRWYWx1ZSkudG9TdHJpbmcoKTtcbiAgY29uc3QgW2JpZ0RlY2ltYWxWYWx1ZUludGVnZXIsIGJpZ0RlY2ltYWxWYWx1ZURlY2ltYWxzXSA9IHZhbHVlLnNwbGl0KFwiLlwiKTtcbiAgcmV0dXJuIHNhbml0aXplZFZhbHVlRGVjaW1hbHMgJiYgYmlnRGVjaW1hbFZhbHVlRGVjaW1hbHMgIT09IHNhbml0aXplZFZhbHVlRGVjaW1hbHNcbiAgICA/IGAke2JpZ0RlY2ltYWxWYWx1ZUludGVnZXJ9LiR7c2FuaXRpemVkVmFsdWVEZWNpbWFsc31gXG4gICAgOiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIHNhbml0aXplRXhwb25lbnRpYWxOdW1iZXJTdHJpbmcobnVtYmVyU3RyaW5nLCBmdW5jKSB7XG4gIGlmICghbnVtYmVyU3RyaW5nKSB7XG4gICAgcmV0dXJuIG51bWJlclN0cmluZztcbiAgfVxuICBjb25zdCBmaXJzdEUgPSBudW1iZXJTdHJpbmcudG9Mb3dlckNhc2UoKS5pbmRleE9mKFwiZVwiKSArIDE7XG4gIGlmICghZmlyc3RFKSB7XG4gICAgcmV0dXJuIGZ1bmMobnVtYmVyU3RyaW5nKTtcbiAgfVxuICByZXR1cm4gbnVtYmVyU3RyaW5nXG4gICAgLnJlcGxhY2UoL1tlRV0qJC9nLCBcIlwiKVxuICAgIC5zdWJzdHJpbmcoMCwgZmlyc3RFKVxuICAgIC5jb25jYXQobnVtYmVyU3RyaW5nLnNsaWNlKGZpcnN0RSkucmVwbGFjZSgvW2VFXS9nLCBcIlwiKSlcbiAgICAuc3BsaXQoL1tlRV0vKVxuICAgIC5tYXAoKHNlY3Rpb24sIGkpID0+IChpID09PSAxID8gZnVuYyhzZWN0aW9uLnJlcGxhY2UoL1xcLi9nLCBcIlwiKSkgOiBmdW5jKHNlY3Rpb24pKSlcbiAgICAuam9pbihcImVcIilcbiAgICAucmVwbGFjZSgvXmUvLCBcIjFlXCIpO1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhbiBleHBvbmVudGlhbCBub3RhdGlvbiBudW1iZXJTdHJpbmcgaW50byBkZWNpbWFsIG5vdGF0aW9uLlxuICogQmlnSW50IGRvZXNuJ3Qgc3VwcG9ydCBleHBvbmVudGlhbCBub3RhdGlvbiwgc28gdGhpcyBpcyByZXF1aXJlZCB0byBtYWludGFpbiBwcmVjaXNpb25cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbnVtYmVyU3RyaW5nIC0gcHJlLXZhbGlkYXRlZCBleHBvbmVudGlhbCBvciBkZWNpbWFsIG51bWJlclxuICogQHJldHVybnMge3N0cmluZ30gbnVtYmVyU3RyaW5nIGluIGRlY2ltYWwgbm90YXRpb25cbiAqL1xuZnVuY3Rpb24gZXhwYW5kRXhwb25lbnRpYWxOdW1iZXJTdHJpbmcobnVtYmVyU3RyaW5nKSB7XG4gIGNvbnN0IGV4cG9uZW50aWFsUGFydHMgPSBudW1iZXJTdHJpbmcuc3BsaXQoL1tlRV0vKTtcbiAgaWYgKGV4cG9uZW50aWFsUGFydHMubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIG51bWJlclN0cmluZztcbiAgfVxuICBjb25zdCBudW1iZXIgPSArbnVtYmVyU3RyaW5nO1xuICBpZiAoTnVtYmVyLmlzU2FmZUludGVnZXIobnVtYmVyKSkge1xuICAgIHJldHVybiBgJHtudW1iZXJ9YDtcbiAgfVxuICBjb25zdCBpc05lZ2F0aXZlID0gbnVtYmVyU3RyaW5nLmNoYXJBdCgwKSA9PT0gXCItXCI7XG4gIGNvbnN0IG1hZ25pdHVkZSA9ICtleHBvbmVudGlhbFBhcnRzWzFdO1xuICBjb25zdCBkZWNpbWFsUGFydHMgPSBleHBvbmVudGlhbFBhcnRzWzBdLnNwbGl0KFwiLlwiKTtcbiAgY29uc3QgaW50ZWdlcnMgPSAoaXNOZWdhdGl2ZSA/IGRlY2ltYWxQYXJ0c1swXS5zdWJzdHJpbmcoMSkgOiBkZWNpbWFsUGFydHNbMF0pIHx8IFwiXCI7XG4gIGNvbnN0IGRlY2ltYWxzID0gZGVjaW1hbFBhcnRzWzFdIHx8IFwiXCI7XG4gIGNvbnN0IHNoaWZ0RGVjaW1hbExlZnQgPSAoaW50ZWdlcnMsIG1hZ25pdHVkZSkgPT4ge1xuICAgIGNvbnN0IG1hZ25pdHVkZURlbHRhID0gTWF0aC5hYnMobWFnbml0dWRlKSAtIGludGVnZXJzLmxlbmd0aDtcbiAgICBjb25zdCBsZWZ0UGFkZGVkWmVyb3MgPSBtYWduaXR1ZGVEZWx0YSA+IDAgPyBgJHtcIjBcIi5yZXBlYXQobWFnbml0dWRlRGVsdGEpfSR7aW50ZWdlcnN9YCA6IGludGVnZXJzO1xuICAgIGNvbnN0IHNoaWZ0ZWREZWNpbWFsID0gYCR7bGVmdFBhZGRlZFplcm9zLnNsaWNlKDAsIG1hZ25pdHVkZSl9JHtcIi5cIn0ke2xlZnRQYWRkZWRaZXJvcy5zbGljZShtYWduaXR1ZGUpfWA7XG4gICAgcmV0dXJuIHNoaWZ0ZWREZWNpbWFsO1xuICB9O1xuICBjb25zdCBzaGlmdERlY2ltYWxSaWdodCA9IChkZWNpbWFscywgbWFnbml0dWRlKSA9PiB7XG4gICAgY29uc3QgcmlnaHRQYWRkZWRaZXJvcyA9IG1hZ25pdHVkZSA+IGRlY2ltYWxzLmxlbmd0aCA/IGAke2RlY2ltYWxzfSR7XCIwXCIucmVwZWF0KG1hZ25pdHVkZSAtIGRlY2ltYWxzLmxlbmd0aCl9YCA6IGRlY2ltYWxzO1xuICAgIGNvbnN0IHNoaWZ0ZWREZWNpbWFsID0gYCR7cmlnaHRQYWRkZWRaZXJvcy5zbGljZSgwLCBtYWduaXR1ZGUpfSR7XCIuXCJ9JHtyaWdodFBhZGRlZFplcm9zLnNsaWNlKG1hZ25pdHVkZSl9YDtcbiAgICByZXR1cm4gc2hpZnRlZERlY2ltYWw7XG4gIH07XG4gIGNvbnN0IGV4cGFuZGVkTnVtYmVyU3RyaW5nID0gbWFnbml0dWRlID4gMFxuICAgID8gYCR7aW50ZWdlcnN9JHtzaGlmdERlY2ltYWxSaWdodChkZWNpbWFscywgbWFnbml0dWRlKX1gXG4gICAgOiBgJHtzaGlmdERlY2ltYWxMZWZ0KGludGVnZXJzLCBtYWduaXR1ZGUpfSR7ZGVjaW1hbHN9YDtcbiAgcmV0dXJuIGAke2lzTmVnYXRpdmUgPyBcIi1cIiA6IFwiXCJ9JHtleHBhbmRlZE51bWJlclN0cmluZy5jaGFyQXQoMCkgPT09IFwiLlwiID8gXCIwXCIgOiBcIlwifSR7ZXhwYW5kZWROdW1iZXJTdHJpbmdcbiAgICAucmVwbGFjZSh1bm5lY2Vzc2FyeURlY2ltYWwsIFwiXCIpXG4gICAgLnJlcGxhY2UoYWxsTGVhZGluZ1plcm9zT3B0aW9uYWxseU5lZ2F0aXZlLCBcIlwiKX1gO1xufVxuZnVuY3Rpb24gc3RyaW5nQ29udGFpbnNOdW1iZXJzKHN0cmluZykge1xuICByZXR1cm4gbnVtYmVyS2V5cy5zb21lKChudW1iZXIpID0+IHN0cmluZy5pbmNsdWRlcyhudW1iZXIpKTtcbn1cbi8qKlxuICogQWRkcyBsb2NhbGl6ZWQgdHJhaWxpbmcgZGVjaW1hbHMgemVybyB2YWx1ZXMgdG8gdGhlIG51bWJlciBzdHJpbmcuXG4gKiBCaWdJbnQgY29udmVyc2lvbiB0byBzdHJpbmcgcmVtb3ZlcyB0aGUgdHJhaWxpbmcgZGVjaW1hbCB6ZXJvIHZhbHVlcyAoRXg6IDEuMDAwIGlzIHJldHVybmVkIGFzIDEpLiBUaGlzIG1ldGhvZCBoZWxwcyBhZGRpbmcgdGhlbSBiYWNrLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBsb2NhbGl6ZWRWYWx1ZSAtIGxvY2FsaXplZCBudW1iZXIgc3RyaW5nIHZhbHVlXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgLSBjdXJyZW50IHZhbHVlIGluIHRoZSBpbnB1dCBmaWVsZFxuICogQHBhcmFtIHtOdW1iZXJTdHJpbmdGb3JtYXR9IGZvcm1hdHRlciAtIG51bWJlclN0cmluZ0Zvcm1hdHRlciBpbnN0YW5jZSB0byBsb2NhbGl6ZSB0aGUgbnVtYmVyIHZhbHVlXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBsb2NhbGl6ZWQgbnVtYmVyIHN0cmluZyB2YWx1ZVxuICovXG5mdW5jdGlvbiBhZGRMb2NhbGl6ZWRUcmFpbGluZ0RlY2ltYWxaZXJvcyhsb2NhbGl6ZWRWYWx1ZSwgdmFsdWUsIGZvcm1hdHRlcikge1xuICBjb25zdCBkZWNpbWFscyA9IHZhbHVlLnNwbGl0KFwiLlwiKVsxXTtcbiAgaWYgKGRlY2ltYWxzKSB7XG4gICAgY29uc3QgdHJhaWxpbmdEZWNpbWFsWmVyb3MgPSBkZWNpbWFscy5tYXRjaChoYXNUcmFpbGluZ0RlY2ltYWxaZXJvcylbMF07XG4gICAgaWYgKHRyYWlsaW5nRGVjaW1hbFplcm9zICYmXG4gICAgICBmb3JtYXR0ZXIuZGVsb2NhbGl6ZShsb2NhbGl6ZWRWYWx1ZSkubGVuZ3RoICE9PSB2YWx1ZS5sZW5ndGggJiZcbiAgICAgIGRlY2ltYWxzLmluZGV4T2YoXCJlXCIpID09PSAtMSkge1xuICAgICAgY29uc3QgZGVjaW1hbFNlcGFyYXRvciA9IGZvcm1hdHRlci5kZWNpbWFsO1xuICAgICAgbG9jYWxpemVkVmFsdWUgPSAhbG9jYWxpemVkVmFsdWUuaW5jbHVkZXMoZGVjaW1hbFNlcGFyYXRvcilcbiAgICAgICAgPyBgJHtsb2NhbGl6ZWRWYWx1ZX0ke2RlY2ltYWxTZXBhcmF0b3J9YFxuICAgICAgICA6IGxvY2FsaXplZFZhbHVlO1xuICAgICAgcmV0dXJuIGxvY2FsaXplZFZhbHVlLnBhZEVuZChsb2NhbGl6ZWRWYWx1ZS5sZW5ndGggKyB0cmFpbGluZ0RlY2ltYWxaZXJvcy5sZW5ndGgsIGZvcm1hdHRlci5sb2NhbGl6ZShcIjBcIikpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbG9jYWxpemVkVmFsdWU7XG59XG5cbmNvbnN0IGRlZmF1bHRMb2NhbGUgPSBcImVuXCI7XG5jb25zdCB0OW5Mb2NhbGVzID0gW1xuICBcImFyXCIsXG4gIFwiYmdcIixcbiAgXCJic1wiLFxuICBcImNhXCIsXG4gIFwiY3NcIixcbiAgXCJkYVwiLFxuICBcImRlXCIsXG4gIFwiZWxcIixcbiAgZGVmYXVsdExvY2FsZSxcbiAgXCJlc1wiLFxuICBcImV0XCIsXG4gIFwiZmlcIixcbiAgXCJmclwiLFxuICBcImhlXCIsXG4gIFwiaHJcIixcbiAgXCJodVwiLFxuICBcImlkXCIsXG4gIFwiaXRcIixcbiAgXCJqYVwiLFxuICBcImtvXCIsXG4gIFwibHRcIixcbiAgXCJsdlwiLFxuICBcIm5vXCIsXG4gIFwibmxcIixcbiAgXCJwbFwiLFxuICBcInB0LUJSXCIsXG4gIFwicHQtUFRcIixcbiAgXCJyb1wiLFxuICBcInJ1XCIsXG4gIFwic2tcIixcbiAgXCJzbFwiLFxuICBcInNyXCIsXG4gIFwic3ZcIixcbiAgXCJ0aFwiLFxuICBcInRyXCIsXG4gIFwidWtcIixcbiAgXCJ2aVwiLFxuICBcInpoLUNOXCIsXG4gIFwiemgtSEtcIixcbiAgXCJ6aC1UV1wiLFxuXTtcbmNvbnN0IGxvY2FsZXMgPSBbXG4gIFwiYXJcIixcbiAgXCJiZ1wiLFxuICBcImJzXCIsXG4gIFwiY2FcIixcbiAgXCJjc1wiLFxuICBcImRhXCIsXG4gIFwiZGVcIixcbiAgXCJkZS1BVFwiLFxuICBcImRlLUNIXCIsXG4gIFwiZWxcIixcbiAgZGVmYXVsdExvY2FsZSxcbiAgXCJlbi1BVVwiLFxuICBcImVuLUNBXCIsXG4gIFwiZW4tR0JcIixcbiAgXCJlc1wiLFxuICBcImVzLU1YXCIsXG4gIFwiZXRcIixcbiAgXCJmaVwiLFxuICBcImZyXCIsXG4gIFwiZnItQ0hcIixcbiAgXCJoZVwiLFxuICBcImhpXCIsXG4gIFwiaHJcIixcbiAgXCJodVwiLFxuICBcImlkXCIsXG4gIFwiaXRcIixcbiAgXCJpdC1DSFwiLFxuICBcImphXCIsXG4gIFwia29cIixcbiAgXCJsdFwiLFxuICBcImx2XCIsXG4gIFwibWtcIixcbiAgXCJub1wiLFxuICBcIm5sXCIsXG4gIFwicGxcIixcbiAgXCJwdFwiLFxuICBcInB0LVBUXCIsXG4gIFwicm9cIixcbiAgXCJydVwiLFxuICBcInNrXCIsXG4gIFwic2xcIixcbiAgXCJzclwiLFxuICBcInN2XCIsXG4gIFwidGhcIixcbiAgXCJ0clwiLFxuICBcInVrXCIsXG4gIFwidmlcIixcbiAgXCJ6aC1DTlwiLFxuICBcInpoLUhLXCIsXG4gIFwiemgtVFdcIixcbl07XG5jb25zdCBudW1iZXJpbmdTeXN0ZW1zID0gW1wiYXJhYlwiLCBcImFyYWJleHRcIiwgXCJsYXRuXCJdO1xuY29uc3QgaXNOdW1iZXJpbmdTeXN0ZW1TdXBwb3J0ZWQgPSAobnVtYmVyaW5nU3lzdGVtKSA9PiBudW1iZXJpbmdTeXN0ZW1zLmluY2x1ZGVzKG51bWJlcmluZ1N5c3RlbSk7XG5jb25zdCBicm93c2VyTnVtYmVyaW5nU3lzdGVtID0gbmV3IEludGwuTnVtYmVyRm9ybWF0KCkucmVzb2x2ZWRPcHRpb25zKCkubnVtYmVyaW5nU3lzdGVtO1xuLy8gZm9yIGNvbnNpc3RlbnQgYnJvd3NlciBiZWhhdmlvciwgd2Ugbm9ybWFsaXplIG51bWJlcmluZ1N5c3RlbSB0byBwcmV2ZW50IHRoZSBicm93c2VyLWluZmVycmVkIHZhbHVlXG4vLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL0VzcmkvY2FsY2l0ZS1kZXNpZ24tc3lzdGVtL2lzc3Vlcy8zMDc5I2lzc3VlY29tbWVudC0xMTY4OTY0MTk1IGZvciBtb3JlIGluZm9cbmNvbnN0IGRlZmF1bHROdW1iZXJpbmdTeXN0ZW0gPSBicm93c2VyTnVtYmVyaW5nU3lzdGVtID09PSBcImFyYWJcIiB8fCAhaXNOdW1iZXJpbmdTeXN0ZW1TdXBwb3J0ZWQoYnJvd3Nlck51bWJlcmluZ1N5c3RlbSlcbiAgPyBcImxhdG5cIlxuICA6IGJyb3dzZXJOdW1iZXJpbmdTeXN0ZW07XG5jb25zdCBnZXRTdXBwb3J0ZWROdW1iZXJpbmdTeXN0ZW0gPSAobnVtYmVyaW5nU3lzdGVtKSA9PiBpc051bWJlcmluZ1N5c3RlbVN1cHBvcnRlZChudW1iZXJpbmdTeXN0ZW0pID8gbnVtYmVyaW5nU3lzdGVtIDogZGVmYXVsdE51bWJlcmluZ1N5c3RlbTtcbi8qKlxuICogR2V0cyB0aGUgbG9jYWxlIHRoYXQgYmVzdCBtYXRjaGVzIHRoZSBjb250ZXh0LlxuICpcbiAqIEBwYXJhbSBsb2NhbGUg4oCTIHRoZSBCQ1AgNDcgbG9jYWxlIGNvZGVcbiAqIEBwYXJhbSBjb250ZXh0IC0gc3BlY2lmaWVzIHdoZXRoZXIgdGhlIGxvY2FsZSBjb2RlIHNob3VsZCBtYXRjaCBpbiB0aGUgY29udGV4dCBvZiBDTERSIG9yIFQ5TiAodHJhbnNsYXRpb24pXG4gKi9cbmZ1bmN0aW9uIGdldFN1cHBvcnRlZExvY2FsZShsb2NhbGUsIGNvbnRleHQgPSBcImNsZHJcIikge1xuICBjb25zdCBjb250ZXh0dWFsTG9jYWxlcyA9IGNvbnRleHQgPT09IFwiY2xkclwiID8gbG9jYWxlcyA6IHQ5bkxvY2FsZXM7XG4gIGlmICghbG9jYWxlKSB7XG4gICAgcmV0dXJuIGRlZmF1bHRMb2NhbGU7XG4gIH1cbiAgaWYgKGNvbnRleHR1YWxMb2NhbGVzLmluY2x1ZGVzKGxvY2FsZSkpIHtcbiAgICByZXR1cm4gbG9jYWxlO1xuICB9XG4gIGxvY2FsZSA9IGxvY2FsZS50b0xvd2VyQ2FzZSgpO1xuICAvLyB3ZSBzdXBwb3J0IGJvdGggJ25iJyBhbmQgJ25vJyAoQkNQIDQ3KSBmb3IgTm9yd2VnaWFuIGJ1dCBvbmx5IGBub2AgaGFzIGNvcnJlc3BvbmRpbmcgYnVuZGxlXG4gIGlmIChsb2NhbGUgPT09IFwibmJcIikge1xuICAgIHJldHVybiBcIm5vXCI7XG4gIH1cbiAgLy8gd2UgdXNlIGBwdC1CUmAgYXMgaXQgd2lsbCBoYXZlIHRoZSBzYW1lIHRyYW5zbGF0aW9ucyBhcyBgcHRgLCB3aGljaCBoYXMgbm8gY29ycmVzcG9uZGluZyBidW5kbGVcbiAgaWYgKGNvbnRleHQgPT09IFwidDluXCIgJiYgbG9jYWxlID09PSBcInB0XCIpIHtcbiAgICByZXR1cm4gXCJwdC1CUlwiO1xuICB9XG4gIGlmIChsb2NhbGUuaW5jbHVkZXMoXCItXCIpKSB7XG4gICAgbG9jYWxlID0gbG9jYWxlLnJlcGxhY2UoLyhcXHcrKS0oXFx3KykvLCAoX21hdGNoLCBsYW5ndWFnZSwgcmVnaW9uKSA9PiBgJHtsYW5ndWFnZX0tJHtyZWdpb24udG9VcHBlckNhc2UoKX1gKTtcbiAgICBpZiAoIWNvbnRleHR1YWxMb2NhbGVzLmluY2x1ZGVzKGxvY2FsZSkpIHtcbiAgICAgIGxvY2FsZSA9IGxvY2FsZS5zcGxpdChcIi1cIilbMF07XG4gICAgfVxuICB9XG4gIC8vIHdlIGNhbiBgemgtQ05gIGFzIGJhc2UgdHJhbnNsYXRpb24gZm9yIGNoaW5lc2UgbG9jYWxlcyB3aGljaCBoYXMgbm8gY29ycmVzcG9uZGluZyBidW5kbGUuXG4gIGlmIChsb2NhbGUgPT09IFwiemhcIikge1xuICAgIHJldHVybiBcInpoLUNOXCI7XG4gIH1cbiAgaWYgKCFjb250ZXh0dWFsTG9jYWxlcy5pbmNsdWRlcyhsb2NhbGUpKSB7XG4gICAgY29uc29sZS53YXJuKGBUcmFuc2xhdGlvbnMgZm9yIHRoZSBcIiR7bG9jYWxlfVwiIGxvY2FsZSBhcmUgbm90IGF2YWlsYWJsZSBhbmQgd2lsbCBmYWxsIGJhY2sgdG8gdGhlIGRlZmF1bHQsIEVuZ2xpc2ggKGVuKS5gKTtcbiAgICByZXR1cm4gZGVmYXVsdExvY2FsZTtcbiAgfVxuICByZXR1cm4gbG9jYWxlO1xufVxuY29uc3QgY29ubmVjdGVkQ29tcG9uZW50cyA9IG5ldyBTZXQoKTtcbi8qKlxuICogVGhpcyB1dGlsaXR5IHNldHMgdXAgaW50ZXJuYWxzIGZvciBtZXNzYWdlcyBzdXBwb3J0LlxuICpcbiAqIEl0IG5lZWRzIHRvIGJlIGNhbGxlZCBpbiBgY29ubmVjdGVkQ2FsbGJhY2tgIGJlZm9yZSBhbnkgbG9naWMgdGhhdCBkZXBlbmRzIG9uIGxvY2FsZVxuICpcbiAqIEBwYXJhbSBjb21wb25lbnRcbiAqL1xuZnVuY3Rpb24gY29ubmVjdExvY2FsaXplZChjb21wb25lbnQpIHtcbiAgdXBkYXRlRWZmZWN0aXZlTG9jYWxlKGNvbXBvbmVudCk7XG4gIGlmIChjb25uZWN0ZWRDb21wb25lbnRzLnNpemUgPT09IDApIHtcbiAgICBtdXRhdGlvbk9ic2VydmVyPy5vYnNlcnZlKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCwge1xuICAgICAgYXR0cmlidXRlczogdHJ1ZSxcbiAgICAgIGF0dHJpYnV0ZUZpbHRlcjogW1wibGFuZ1wiXSxcbiAgICAgIHN1YnRyZWU6IHRydWUsXG4gICAgfSk7XG4gIH1cbiAgY29ubmVjdGVkQ29tcG9uZW50cy5hZGQoY29tcG9uZW50KTtcbn1cbi8qKlxuICogVGhpcyBpcyBvbmx5IGV4cG9ydGVkIGZvciBjb21wb25lbnRzIHRoYXQgaW1wbGVtZW50ZWQgdGhlIG5vdyBkZXByZWNhdGVkIGBsb2NhbGVgIHByb3AuXG4gKlxuICogRG8gbm90IHVzZSB0aGlzIHV0aWxzIGZvciBuZXcgY29tcG9uZW50cy5cbiAqXG4gKiBAcGFyYW0gY29tcG9uZW50XG4gKi9cbmZ1bmN0aW9uIHVwZGF0ZUVmZmVjdGl2ZUxvY2FsZShjb21wb25lbnQpIHtcbiAgY29tcG9uZW50LmVmZmVjdGl2ZUxvY2FsZSA9IGdldExvY2FsZShjb21wb25lbnQpO1xufVxuLyoqXG4gKiBUaGlzIHV0aWxpdHkgdGVhcnMgZG93biBpbnRlcm5hbHMgZm9yIG1lc3NhZ2VzIHN1cHBvcnQuXG4gKlxuICogSXQgbmVlZHMgdG8gYmUgY2FsbGVkIGluIGBkaXNjb25uZWN0ZWRDYWxsYmFja2BcbiAqXG4gKiBAcGFyYW0gY29tcG9uZW50XG4gKi9cbmZ1bmN0aW9uIGRpc2Nvbm5lY3RMb2NhbGl6ZWQoY29tcG9uZW50KSB7XG4gIGNvbm5lY3RlZENvbXBvbmVudHMuZGVsZXRlKGNvbXBvbmVudCk7XG4gIGlmIChjb25uZWN0ZWRDb21wb25lbnRzLnNpemUgPT09IDApIHtcbiAgICBtdXRhdGlvbk9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgfVxufVxuY29uc3QgbXV0YXRpb25PYnNlcnZlciA9IGNyZWF0ZU9ic2VydmVyKFwibXV0YXRpb25cIiwgKHJlY29yZHMpID0+IHtcbiAgcmVjb3Jkcy5mb3JFYWNoKChyZWNvcmQpID0+IHtcbiAgICBjb25zdCBlbCA9IHJlY29yZC50YXJnZXQ7XG4gICAgY29ubmVjdGVkQ29tcG9uZW50cy5mb3JFYWNoKChjb21wb25lbnQpID0+IHtcbiAgICAgIGNvbnN0IGluVW5yZWxhdGVkU3VidHJlZSA9ICFjb250YWluc0Nyb3NzU2hhZG93Qm91bmRhcnkoZWwsIGNvbXBvbmVudC5lbCk7XG4gICAgICBpZiAoaW5VbnJlbGF0ZWRTdWJ0cmVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNsb3Nlc3RMYW5nRWwgPSBjbG9zZXN0RWxlbWVudENyb3NzU2hhZG93Qm91bmRhcnkoY29tcG9uZW50LmVsLCBcIltsYW5nXVwiKTtcbiAgICAgIGlmICghY2xvc2VzdExhbmdFbCkge1xuICAgICAgICBjb21wb25lbnQuZWZmZWN0aXZlTG9jYWxlID0gZGVmYXVsdExvY2FsZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgY2xvc2VzdExhbmcgPSBjbG9zZXN0TGFuZ0VsLmxhbmc7XG4gICAgICBjb21wb25lbnQuZWZmZWN0aXZlTG9jYWxlID1cbiAgICAgICAgLy8gdXNlciBzZXQgbGFuZz1cIlwiIG1lYW5zIHVua25vd24gbGFuZ3VhZ2UsIHNvIHdlIHVzZSBkZWZhdWx0XG4gICAgICAgIGNsb3Nlc3RMYW5nRWwuaGFzQXR0cmlidXRlKFwibGFuZ1wiKSAmJiBjbG9zZXN0TGFuZyA9PT0gXCJcIiA/IGRlZmF1bHRMb2NhbGUgOiBjbG9zZXN0TGFuZztcbiAgICB9KTtcbiAgfSk7XG59KTtcbi8qKlxuICogVGhpcyB1dGlsIGhlbHBzIHJlc29sdmUgYSBjb21wb25lbnQncyBsb2NhbGUuXG4gKiBJdCB3aWxsIGFsc28gZmFsbCBiYWNrIG9uIHRoZSBkZXByZWNhdGVkIGBsb2NhbGVgIGlmIGEgY29tcG9uZW50IGltcGxlbWVudGVkIHRoaXMgcHJldmlvdXNseS5cbiAqXG4gKiBAcGFyYW0gY29tcG9uZW50XG4gKi9cbmZ1bmN0aW9uIGdldExvY2FsZShjb21wb25lbnQpIHtcbiAgcmV0dXJuIChjb21wb25lbnQuZWwubGFuZyB8fFxuICAgIGNsb3Nlc3RFbGVtZW50Q3Jvc3NTaGFkb3dCb3VuZGFyeShjb21wb25lbnQuZWwsIFwiW2xhbmddXCIpPy5sYW5nIHx8XG4gICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmxhbmcgfHxcbiAgICBkZWZhdWx0TG9jYWxlKTtcbn1cbi8qKlxuICogVGhpcyB1dGlsIGZvcm1hdHMgYW5kIHBhcnNlcyBudW1iZXJzIGZvciBsb2NhbGl6YXRpb25cbiAqL1xuY2xhc3MgTnVtYmVyU3RyaW5nRm9ybWF0IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5kZWxvY2FsaXplID0gKG51bWJlclN0cmluZykgPT4gXG4gICAgLy8gRm9yIHBlcmZvcm1hbmNlLCAoZGUpbG9jYWxpemF0aW9uIGlzIHNraXBwZWQgaWYgdGhlIGZvcm1hdHRlciBpc24ndCBpbml0aWFsaXplZC5cbiAgICAvLyBJbiBvcmRlciB0byBsb2NhbGl6ZS9kZWxvY2FsaXplLCBlLmcuIHdoZW4gbGFuZy9udW1iZXJpbmdTeXN0ZW0gcHJvcHMgYXJlIG5vdCBkZWZhdWx0IHZhbHVlcyxcbiAgICAvLyBgbnVtYmVyRm9ybWF0T3B0aW9uc2AgbXVzdCBiZSBzZXQgaW4gYSBjb21wb25lbnQgdG8gY3JlYXRlIGFuZCBjYWNoZSB0aGUgZm9ybWF0dGVyLlxuICAgIHRoaXMuX251bWJlckZvcm1hdE9wdGlvbnNcbiAgICAgID8gc2FuaXRpemVFeHBvbmVudGlhbE51bWJlclN0cmluZyhudW1iZXJTdHJpbmcsIChub25FeHBvTnVtU3RyaW5nKSA9PiBub25FeHBvTnVtU3RyaW5nXG4gICAgICAgIC5yZXBsYWNlKG5ldyBSZWdFeHAoYFske3RoaXMuX21pbnVzU2lnbn1dYCwgXCJnXCIpLCBcIi1cIilcbiAgICAgICAgLnJlcGxhY2UobmV3IFJlZ0V4cChgWyR7dGhpcy5fZ3JvdXB9XWAsIFwiZ1wiKSwgXCJcIilcbiAgICAgICAgLnJlcGxhY2UobmV3IFJlZ0V4cChgWyR7dGhpcy5fZGVjaW1hbH1dYCwgXCJnXCIpLCBcIi5cIilcbiAgICAgICAgLnJlcGxhY2UobmV3IFJlZ0V4cChgWyR7dGhpcy5fZGlnaXRzLmpvaW4oXCJcIil9XWAsIFwiZ1wiKSwgdGhpcy5fZ2V0RGlnaXRJbmRleCkpXG4gICAgICA6IG51bWJlclN0cmluZztcbiAgICB0aGlzLmxvY2FsaXplID0gKG51bWJlclN0cmluZykgPT4gdGhpcy5fbnVtYmVyRm9ybWF0T3B0aW9uc1xuICAgICAgPyBzYW5pdGl6ZUV4cG9uZW50aWFsTnVtYmVyU3RyaW5nKG51bWJlclN0cmluZywgKG5vbkV4cG9OdW1TdHJpbmcpID0+IGlzVmFsaWROdW1iZXIobm9uRXhwb051bVN0cmluZy50cmltKCkpXG4gICAgICAgID8gbmV3IEJpZ0RlY2ltYWwobm9uRXhwb051bVN0cmluZy50cmltKCkpXG4gICAgICAgICAgLmZvcm1hdCh0aGlzKVxuICAgICAgICAgIC5yZXBsYWNlKG5ldyBSZWdFeHAoYFske3RoaXMuX2FjdHVhbEdyb3VwfV1gLCBcImdcIiksIHRoaXMuX2dyb3VwKVxuICAgICAgICA6IG5vbkV4cG9OdW1TdHJpbmcpXG4gICAgICA6IG51bWJlclN0cmluZztcbiAgfVxuICBnZXQgZ3JvdXAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dyb3VwO1xuICB9XG4gIGdldCBkZWNpbWFsKCkge1xuICAgIHJldHVybiB0aGlzLl9kZWNpbWFsO1xuICB9XG4gIGdldCBtaW51c1NpZ24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX21pbnVzU2lnbjtcbiAgfVxuICBnZXQgZGlnaXRzKCkge1xuICAgIHJldHVybiB0aGlzLl9kaWdpdHM7XG4gIH1cbiAgZ2V0IG51bWJlckZvcm1hdHRlcigpIHtcbiAgICByZXR1cm4gdGhpcy5fbnVtYmVyRm9ybWF0dGVyO1xuICB9XG4gIGdldCBudW1iZXJGb3JtYXRPcHRpb25zKCkge1xuICAgIHJldHVybiB0aGlzLl9udW1iZXJGb3JtYXRPcHRpb25zO1xuICB9XG4gIC8qKlxuICAgKiBudW1iZXJGb3JtYXRPcHRpb25zIG5lZWRzIHRvIGJlIHNldCBiZWZvcmUgbG9jYWxpemUvZGVsb2NhbGl6ZSBpcyBjYWxsZWQgdG8gZW5zdXJlIHRoZSBvcHRpb25zIGFyZSB1cCB0byBkYXRlXG4gICAqL1xuICBzZXQgbnVtYmVyRm9ybWF0T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgb3B0aW9ucy5sb2NhbGUgPSBnZXRTdXBwb3J0ZWRMb2NhbGUob3B0aW9ucz8ubG9jYWxlKTtcbiAgICBvcHRpb25zLm51bWJlcmluZ1N5c3RlbSA9IGdldFN1cHBvcnRlZE51bWJlcmluZ1N5c3RlbShvcHRpb25zPy5udW1iZXJpbmdTeXN0ZW0pO1xuICAgIGlmIChcbiAgICAvLyBObyBuZWVkIHRvIGNyZWF0ZSB0aGUgZm9ybWF0dGVyIGlmIGBsb2NhbGVgIGFuZCBgbnVtYmVyaW5nU3lzdGVtYFxuICAgIC8vIGFyZSB0aGUgZGVmYXVsdCB2YWx1ZXMgYW5kIGBudW1iZXJGb3JtYXRPcHRpb25zYCBoYXMgbm90IGJlZW4gc2V0XG4gICAgKCF0aGlzLl9udW1iZXJGb3JtYXRPcHRpb25zICYmXG4gICAgICBvcHRpb25zLmxvY2FsZSA9PT0gZGVmYXVsdExvY2FsZSAmJlxuICAgICAgb3B0aW9ucy5udW1iZXJpbmdTeXN0ZW0gPT09IGRlZmF1bHROdW1iZXJpbmdTeXN0ZW0gJiZcbiAgICAgIC8vIGRvbid0IHNraXAgaW5pdGlhbGl6YXRpb24gaWYgYW55IG9wdGlvbnMgYmVzaWRlcyBsb2NhbGUvbnVtYmVyaW5nU3lzdGVtIGFyZSBzZXRcbiAgICAgIE9iamVjdC5rZXlzKG9wdGlvbnMpLmxlbmd0aCA9PT0gMikgfHxcbiAgICAgIC8vIGNhY2hlIGZvcm1hdHRlciBieSBvbmx5IHJlY3JlYXRpbmcgd2hlbiBvcHRpb25zIGNoYW5nZVxuICAgICAgSlNPTi5zdHJpbmdpZnkodGhpcy5fbnVtYmVyRm9ybWF0T3B0aW9ucykgPT09IEpTT04uc3RyaW5naWZ5KG9wdGlvbnMpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX251bWJlckZvcm1hdE9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMuX251bWJlckZvcm1hdHRlciA9IG5ldyBJbnRsLk51bWJlckZvcm1hdCh0aGlzLl9udW1iZXJGb3JtYXRPcHRpb25zLmxvY2FsZSwgdGhpcy5fbnVtYmVyRm9ybWF0T3B0aW9ucyk7XG4gICAgdGhpcy5fZGlnaXRzID0gW1xuICAgICAgLi4ubmV3IEludGwuTnVtYmVyRm9ybWF0KHRoaXMuX251bWJlckZvcm1hdE9wdGlvbnMubG9jYWxlLCB7XG4gICAgICAgIHVzZUdyb3VwaW5nOiBmYWxzZSxcbiAgICAgICAgbnVtYmVyaW5nU3lzdGVtOiB0aGlzLl9udW1iZXJGb3JtYXRPcHRpb25zLm51bWJlcmluZ1N5c3RlbSxcbiAgICAgIH0pLmZvcm1hdCg5ODc2NTQzMjEwKSxcbiAgICBdLnJldmVyc2UoKTtcbiAgICBjb25zdCBpbmRleCA9IG5ldyBNYXAodGhpcy5fZGlnaXRzLm1hcCgoZCwgaSkgPT4gW2QsIGldKSk7XG4gICAgLy8gbnVtYmVyaW5nU3lzdGVtIGlzIHBhcnNlZCB0byByZXR1cm4gY29uc2lzdGVudCBkZWNpbWFsIHNlcGFyYXRvciBhY3Jvc3MgYnJvd3NlcnMuXG4gICAgY29uc3QgcGFydHMgPSBuZXcgSW50bC5OdW1iZXJGb3JtYXQodGhpcy5fbnVtYmVyRm9ybWF0T3B0aW9ucy5sb2NhbGUsIHtcbiAgICAgIG51bWJlcmluZ1N5c3RlbTogdGhpcy5fbnVtYmVyRm9ybWF0T3B0aW9ucy5udW1iZXJpbmdTeXN0ZW0sXG4gICAgfSkuZm9ybWF0VG9QYXJ0cygtMTIzNDU2NzguOSk7XG4gICAgdGhpcy5fYWN0dWFsR3JvdXAgPSBwYXJ0cy5maW5kKChkKSA9PiBkLnR5cGUgPT09IFwiZ3JvdXBcIikudmFsdWU7XG4gICAgLy8gY2hhbmdlIHdoaXRlc3BhY2UgZ3JvdXAgc2VwYXJhdG9ycyB0byB0aGUgdW5pY29kZSBub24tYnJlYWtpbmcgc3BhY2UgKG5ic3ApXG4gICAgdGhpcy5fZ3JvdXAgPSB0aGlzLl9hY3R1YWxHcm91cC50cmltKCkubGVuZ3RoID09PSAwIHx8IHRoaXMuX2FjdHVhbEdyb3VwID09IFwiIFwiID8gXCJcXHUwMEEwXCIgOiB0aGlzLl9hY3R1YWxHcm91cDtcbiAgICB0aGlzLl9kZWNpbWFsID0gcGFydHMuZmluZCgoZCkgPT4gZC50eXBlID09PSBcImRlY2ltYWxcIikudmFsdWU7XG4gICAgdGhpcy5fbWludXNTaWduID0gcGFydHMuZmluZCgoZCkgPT4gZC50eXBlID09PSBcIm1pbnVzU2lnblwiKS52YWx1ZTtcbiAgICB0aGlzLl9nZXREaWdpdEluZGV4ID0gKGQpID0+IGluZGV4LmdldChkKTtcbiAgfVxufVxuY29uc3QgbnVtYmVyU3RyaW5nRm9ybWF0dGVyID0gbmV3IE51bWJlclN0cmluZ0Zvcm1hdCgpO1xuLyoqXG4gKiBFeHBvcnRlZCBmb3IgdGVzdGluZyBwdXJwb3NlcyBvbmx5LlxuICpcbiAqIEBpbnRlcm5hbFxuICovXG5sZXQgZGF0ZVRpbWVGb3JtYXRDYWNoZTtcbi8qKlxuICogVXNlZCB0byBlbnN1cmUgYWxsIGNhY2hlZCBmb3JtYXRzIGFyZSBmb3IgdGhlIHNhbWUgbG9jYWxlLlxuICpcbiAqIEBpbnRlcm5hbFxuICovXG5sZXQgcHJldmlvdXNMb2NhbGVVc2VkRm9yQ2FjaGluZztcbi8qKlxuICogR2VuZXJhdGVzIGEgY2FjaGUga2V5IGZvciBkYXRlIHRpbWUgZm9ybWF0IGxvb2t1cHMuXG4gKlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGJ1aWxkRGF0ZVRpbWVGb3JtYXRDYWNoZUtleShvcHRpb25zID0ge30pIHtcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKG9wdGlvbnMpXG4gICAgLnNvcnQoKFtrZXkxXSwgW2tleTJdKSA9PiBrZXkxLmxvY2FsZUNvbXBhcmUoa2V5MikpXG4gICAgLm1hcCgoa2V5VmFsdWUpID0+IGAke2tleVZhbHVlWzBdfS0ke2tleVZhbHVlWzFdfWApXG4gICAgLmZsYXQoKVxuICAgIC5qb2luKFwiOlwiKTtcbn1cbi8qKlxuICogUmV0dXJucyBhbiBpbnN0YW5jZSBvZiBJbnRsLkRhdGVUaW1lRm9ybWF0IGFuZCByZXVzZXMgaXQgaWYgcmVxdWVzdGVkIHdpdGggdGhlIHNhbWUgbG9jYWxlIGFuZCBvcHRpb25zLlxuICpcbiAqICoqTm90ZSoqOiB0aGUgY2FjaGUgd2lsbCBiZSBjbGVhcmVkIGlmIGEgZGlmZmVyZW50IGxvY2FsZSBpcyBwcm92aWRlZFxuICpcbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBnZXREYXRlVGltZUZvcm1hdChsb2NhbGUsIG9wdGlvbnMpIHtcbiAgbG9jYWxlID0gZ2V0U3VwcG9ydGVkTG9jYWxlKGxvY2FsZSk7XG4gIGlmICghZGF0ZVRpbWVGb3JtYXRDYWNoZSkge1xuICAgIGRhdGVUaW1lRm9ybWF0Q2FjaGUgPSBuZXcgTWFwKCk7XG4gIH1cbiAgaWYgKHByZXZpb3VzTG9jYWxlVXNlZEZvckNhY2hpbmcgIT09IGxvY2FsZSkge1xuICAgIGRhdGVUaW1lRm9ybWF0Q2FjaGUuY2xlYXIoKTtcbiAgICBwcmV2aW91c0xvY2FsZVVzZWRGb3JDYWNoaW5nID0gbG9jYWxlO1xuICB9XG4gIGNvbnN0IGtleSA9IGJ1aWxkRGF0ZVRpbWVGb3JtYXRDYWNoZUtleShvcHRpb25zKTtcbiAgY29uc3QgY2FjaGVkID0gZGF0ZVRpbWVGb3JtYXRDYWNoZS5nZXQoa2V5KTtcbiAgaWYgKGNhY2hlZCkge1xuICAgIHJldHVybiBjYWNoZWQ7XG4gIH1cbiAgY29uc3QgZm9ybWF0ID0gbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQobG9jYWxlLCBvcHRpb25zKTtcbiAgZGF0ZVRpbWVGb3JtYXRDYWNoZS5zZXQoa2V5LCBmb3JtYXQpO1xuICByZXR1cm4gZm9ybWF0O1xufVxuXG5leHBvcnQgeyBCaWdEZWNpbWFsIGFzIEIsIGFkZExvY2FsaXplZFRyYWlsaW5nRGVjaW1hbFplcm9zIGFzIGEsIGRlZmF1bHROdW1iZXJpbmdTeXN0ZW0gYXMgYiwgY29ubmVjdExvY2FsaXplZCBhcyBjLCBkaXNjb25uZWN0TG9jYWxpemVkIGFzIGQsIGdldERhdGVUaW1lRm9ybWF0IGFzIGUsIGdldFN1cHBvcnRlZE51bWJlcmluZ1N5c3RlbSBhcyBmLCBnZXRTdXBwb3J0ZWRMb2NhbGUgYXMgZywgaXNWYWxpZE51bWJlciBhcyBpLCBudW1iZXJTdHJpbmdGb3JtYXR0ZXIgYXMgbiwgcGFyc2VOdW1iZXJTdHJpbmcgYXMgcCwgc2FuaXRpemVOdW1iZXJTdHJpbmcgYXMgcyB9O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1sb2NhbGUtNmU3ODNjZjAuanMubWFwIiwiLyohXG4gKiBBbGwgbWF0ZXJpYWwgY29weXJpZ2h0IEVTUkksIEFsbCBSaWdodHMgUmVzZXJ2ZWQsIHVubGVzcyBvdGhlcndpc2Ugc3BlY2lmaWVkLlxuICogU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9Fc3JpL2NhbGNpdGUtZGVzaWduLXN5c3RlbS9ibG9iL21haW4vTElDRU5TRS5tZCBmb3IgZGV0YWlscy5cbiAqIHYyLjAuMFxuICovXG4vKipcbiAqIFRoaXMgdXRpbGl0eSBlbnN1cmVzIG9ic2VydmVycyBhcmUgY3JlYXRlZCBvbmx5IGZvciBicm93c2VyIGNvbnRleHRzLlxuICpcbiAqIEBwYXJhbSB0eXBlIC0gdGhlIHR5cGUgb2Ygb2JzZXJ2ZXIgdG8gY3JlYXRlXG4gKiBAcGFyYW0gY2FsbGJhY2sgLSB0aGUgb2JzZXJ2ZXIgY2FsbGJhY2tcbiAqIEBwYXJhbSBvcHRpb25zIC0gdGhlIG9ic2VydmVyIG9wdGlvbnNcbiAqL1xuZnVuY3Rpb24gY3JlYXRlT2JzZXJ2ZXIodHlwZSwgY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgY29uc3QgT2JzZXJ2ZXIgPSBnZXRPYnNlcnZlcih0eXBlKTtcbiAgcmV0dXJuIG5ldyBPYnNlcnZlcihjYWxsYmFjaywgb3B0aW9ucyk7XG59XG5mdW5jdGlvbiBnZXRPYnNlcnZlcih0eXBlKSB7XG4gIC8vIGJhc2VkIG9uIGh0dHBzOi8vZ2l0aHViLmNvbS93aGF0d2cvZG9tL2lzc3Vlcy8xMjYjaXNzdWVjb21tZW50LTEwNDk4MTQ5NDhcbiAgY2xhc3MgRXh0ZW5kZWRNdXRhdGlvbk9ic2VydmVyIGV4dGVuZHMgd2luZG93Lk11dGF0aW9uT2JzZXJ2ZXIge1xuICAgIGNvbnN0cnVjdG9yKGNhbGxiYWNrKSB7XG4gICAgICBzdXBlcihjYWxsYmFjayk7XG4gICAgICB0aGlzLm9ic2VydmVkRW50cnkgPSBbXTtcbiAgICAgIHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICB9XG4gICAgb2JzZXJ2ZSh0YXJnZXQsIG9wdGlvbnMpIHtcbiAgICAgIHRoaXMub2JzZXJ2ZWRFbnRyeS5wdXNoKHsgdGFyZ2V0LCBvcHRpb25zIH0pO1xuICAgICAgcmV0dXJuIHN1cGVyLm9ic2VydmUodGFyZ2V0LCBvcHRpb25zKTtcbiAgICB9XG4gICAgdW5vYnNlcnZlKHRhcmdldCkge1xuICAgICAgY29uc3QgbmV3T2JzZXJ2ZWRFbnRyaWVzID0gdGhpcy5vYnNlcnZlZEVudHJ5LmZpbHRlcigob2JzZXJ2ZWQpID0+IG9ic2VydmVkLnRhcmdldCAhPT0gdGFyZ2V0KTtcbiAgICAgIHRoaXMub2JzZXJ2ZWRFbnRyeSA9IFtdO1xuICAgICAgdGhpcy5jYWxsYmFjayhzdXBlci50YWtlUmVjb3JkcygpLCB0aGlzKTtcbiAgICAgIHRoaXMuZGlzY29ubmVjdCgpO1xuICAgICAgbmV3T2JzZXJ2ZWRFbnRyaWVzLmZvckVhY2goKG9ic2VydmVkKSA9PiB0aGlzLm9ic2VydmUob2JzZXJ2ZWQudGFyZ2V0LCBvYnNlcnZlZC5vcHRpb25zKSk7XG4gICAgfVxuICB9XG4gIHJldHVybiAoZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAodHlwZSA9PT0gXCJpbnRlcnNlY3Rpb25cIlxuICAgICAgPyB3aW5kb3cuSW50ZXJzZWN0aW9uT2JzZXJ2ZXJcbiAgICAgIDogdHlwZSA9PT0gXCJtdXRhdGlvblwiXG4gICAgICAgID8gRXh0ZW5kZWRNdXRhdGlvbk9ic2VydmVyXG4gICAgICAgIDogd2luZG93LlJlc2l6ZU9ic2VydmVyKTtcbiAgfSkoKTtcbn1cblxuZXhwb3J0IHsgY3JlYXRlT2JzZXJ2ZXIgYXMgYyB9O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1vYnNlcnZlcnMtNzFkMzMyZGIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9