define(["exports","./index2-588b02d9"],(function(exports,index2){"use strict";function isIntFieldType(type){return type==="small-integer"||type==="integer"||type==="big-integer"||type==="long"||type==="oid"}function isFloatFieldType(type){return type==="single"||type==="double"}function assert(condition,msg){if(condition===false)throw new Error(msg)}let incrementalId=0;function getIncrementalId(){incrementalId+=1;return`${incrementalId}`}const dayInMS=24*60*60*1e3-1e3;function addDay(date){return new Date(date.getTime()+dayInMS)}function subtractDay(date){return new Date(date.getTime()-dayInMS)}function removeTime(date){return new Date(date.toDateString())}function toDayRange(date){const start=removeTime(date);const end=addDay(date);return[start,end]}function areDayRange(dates){const start=dates[0];const endMinusDay=subtractDay(dates[1]);return Math.abs(endMinusDay.getTime()-start.getTime())<1e3}const Operators=Object.freeze({equal:(fieldName,value)=>`${fieldName} = ${value}`,not_equal:(fieldName,value)=>`${fieldName} <> ${value}`,is_in:(fieldName,value)=>`${fieldName} IN(${value.join(", ")})`,is_not_in:(fieldName,value)=>`${fieldName} NOT IN(${value.join(", ")})`,less:(fieldName,value)=>`${fieldName} < ${value}`,less_or_equal:(fieldName,value)=>`${fieldName} <= ${value}`,greater:(fieldName,value)=>`${fieldName} > ${value}`,greater_or_equal:(fieldName,value)=>`${fieldName} >= ${value}`,between:(fieldName,value)=>`${fieldName} BETWEEN ${value.join(" AND ")}`,not_between:(fieldName,value)=>`${fieldName} NOT BETWEEN ${value.join(" AND ")}`,contains:(fieldName,value)=>`${fieldName} LIKE '%${value.slice(1,-1)}%'`,not_contains:(fieldName,value)=>`${fieldName} NOT LIKE '%${value.slice(1,-1)}%'`,begins_with:(fieldName,value)=>`${fieldName} LIKE '${value.slice(1,-1)}%'`,not_begins_with:(fieldName,value)=>`${fieldName} NOT LIKE '${value.slice(1,-1)}%'`,ends_with:(fieldName,value)=>`${fieldName} LIKE '%${value.slice(1,-1)}'`,not_ends_with:(fieldName,value)=>`${fieldName} NOT LIKE '%${value.slice(1,-1)}'`,is_empty:(fieldName,_)=>`${fieldName} = ''`,is_not_empty:(fieldName,_)=>`${fieldName} <> ''`,is_blank:(fieldName,_)=>`${fieldName} IS Null`,is_not_blank:(fieldName,_)=>`${fieldName} IS NOT Null`,is_on:(fieldName,value)=>`${fieldName} BETWEEN ${value}`,is_not_on:(fieldName,value)=>`${fieldName} NOT BETWEEN ${value}`,is_before:(fieldName,value)=>`${fieldName} < ${value}`,is_after:(fieldName,value)=>`${fieldName} > ${value}`,is_true:(fieldName,_)=>`${fieldName} IS TRUE`,is_false:(fieldName,_)=>`${fieldName} IS FALSE`});const OperatorsSymbolToWritten={"<":"less","<=":"less_or_equal",">":"greater",">=":"greater_or_equal","=":"equal","<>":"not_equal",IN:"is_in","NOT IN":"is_not_in",BETWEEN:"between",NOTBETWEEN:"not_between"};const NumericOperators=["between","not_between","equal","not_equal","is_in","is_not_in","greater","greater_or_equal","less","less_or_equal","is_blank","is_not_blank"];const StringOperators=["equal","not_equal","is_in","is_not_in","contains","not_contains","begins_with","not_begins_with","ends_with","not_ends_with","is_blank","is_not_blank","is_empty","is_not_empty"];const DateOperators=["between","not_between","is_on","is_not_on","is_before","is_after","is_blank","is_not_blank"];const GeometryOperators=["is_blank","is_not_blank"];const BooleanOperators=["is_blank","is_not_blank","is_true","is_false"];const RangeOperators=["between","not_between"];const CollectionOperators=["is_in","is_not_in"];const NoValueOperators=["is_blank","is_not_blank","is_empty","is_not_empty","is_true","is_false"];function isRangeOperator(operator){return RangeOperators.includes(operator)}function isCollectionOperator(operator){return CollectionOperators.includes(operator)}function isNoValueOperator(operator){return NoValueOperators.includes(operator)}function formatFieldForSql(fieldName,useDelimitedIdentifiers){return useDelimitedIdentifiers?`"${fieldName}"`:fieldName}function formatDate(date){if(date===undefined){return""}const yearStr=`${date.getUTCFullYear()}`;let monthStr=`${date.getUTCMonth()+1}`;if(monthStr.length===1){monthStr=`0${monthStr}`}let dateStr=`${date.getUTCDate()}`;if(dateStr.length===1){dateStr=`0${dateStr}`}let hoursStr=`${date.getUTCHours()}`;if(hoursStr.length===1){hoursStr=`0${hoursStr}`}let minStr=`${date.getUTCMinutes()}`;if(minStr.length===1){minStr=`0${minStr}`}let secStr=`${date.getUTCSeconds()}`;if(secStr.length===1){secStr=`0${secStr}`}return`${yearStr}-${monthStr}-${dateStr} ${hoursStr}:${minStr}:${secStr}`}function formatValueForSql(value,dataType){switch(dataType){case"integer":case"small-integer":case"big-integer":case"long":case"oid":if(value===undefined||value===null){return"0"}if(typeof value!=="number"){value=parseInt(value)}if(typeof value==="number"&&isNaN(value)){return"0"}return`${value}`;case"double":case"single":if(value===undefined||value===null){return"0.0"}if(typeof value!=="number"){value=parseFloat(value)}if(typeof value==="number"&&isNaN(value)){return"0.0"}return`${value}`;case"date":const dateValue=value instanceof Date?value:undefined;const dateStr=dateValue!==undefined?`timestamp '${formatDate(dateValue)}'`:"''";return dateStr;case"string":const stringValue=value;return`'${stringValue===null||stringValue===undefined?"":stringValue.replace(/'/g,"''")}'`;case"boolean":case"geometry":return"";default:throw new Error(`Unsupported data type: ${dataType}`)}}function parseDate(strValue){const date=new Date(strValue);const utcDate=new Date(date.getTime()-date.getTimezoneOffset()*6e4);return utcDate}function parseValueFromSqlNode(node){switch(node.type){case"string":return node.value;case"number":return node.value;case"null":return null;case"timestamp":return parseDate(node.value);case"boolean":return node.value;case"function":case"binary-expression":case"column-reference":case"current-time":case"date":case"interval":case"interval-period":case"interval-qualifier":case"expression-list":case"case_expression":case"case-expression":case"timestamp":case"unary-expression":case"when-clause":throw new Error("Invalid expression: unsupported node value.")}}function parseComparisonNodeParts(operator,valueNode){const value=parseValueFromSqlNode(valueNode);switch(operator){case"IS":if(value===null){return["is_blank",undefined]}else if(typeof value==="boolean"){const boolOperator=value===true?"is_true":"is_false";return[boolOperator,undefined]}else{throw new Error("Invalid expression: unsupported value for `IS` operator.")}case"ISNOT":if(value===null){return["is_not_blank",undefined]}else{throw new Error("Invalid expression: unsupported value for `ISNOT` operator.")}case"=":if(value===""){return["is_empty",""]}else{return["equal",value]}case"<>":if(value===""){return["is_not_empty",""]}else{return["not_equal",value]}case"<":if(value instanceof Date){return["is_before",value]}else{return["less",value]}case">":if(value instanceof Date){return["is_after",value]}else{return["greater",value]}case"LIKE":assert(typeof value==="string","Invalid expression: unsupported value for `LIKE` operator.");if(value.startsWith("%")&&value.endsWith("%")){return["contains",value.substring(1,value.length-1)]}else if(value.endsWith("%")){return["begins_with",value.substring(0,value.length-1)]}else if(value.startsWith("%")){return["ends_with",value.substring(1)]}else{return["equal",value]}case"NOT LIKE":assert(typeof value==="string","Invalid expression: unsupported value for `NOT LIKE` operator.");if(value.startsWith("%")&&value.endsWith("%")){return["not_contains",value.slice(1,value.length-1)]}else if(value.endsWith("%")){return["not_begins_with",value.slice(0,value.length-1)]}else if(value.startsWith("%")){return["not_ends_with",value.slice(1)]}else{return["not_equal",value]}default:const defaultOperator=OperatorsSymbolToWritten[operator];assert(defaultOperator!==undefined,"Invalid expression: unsupported operator.");return[defaultOperator,value]}}const ExpressionGroupOperator={And:"and",Or:"or",Default:""};const SpatialRelationshipUnits=["Meters","Kilometers","Feet","Yards","Miles"];const SpatialRelationships={Intersects:"intersects",NotIntersects:"notIntersects",WithinDistance:"withinDistance",NotWithinDistance:"notWithinDistance",Contains:"contains",NotContains:"notContains",Within:"within",NotWithin:"notWithin",Nearest:"nearest"};var _a;function isEmpty(value){return value===undefined||value===null}function isValid(value){let valid=true;if(isEmpty(value)||value===""||typeof value==="number"&&isNaN(value)){valid=false}return valid}class AbstractAttributeExpression{constructor(field,dataType,value,operator,id){this.field=field;this.dataType=dataType;this.value=value;this.operator=operator;this.id=id??getIncrementalId()}}class ValueExpression extends AbstractAttributeExpression{constructor(){super(...arguments);this.type="value"}validate(){return isNoValueOperator(this.operator)||isValid(this.value)}toSQL(options){let sql;if(this.dataType==="date"){sql=this.toSQLForDate(this.value,this.operator,options)}else{const formattedField=formatFieldForSql(this.field,options?.useDelimitedIdentifiers===true);const formattedValue=formatValueForSql(this.value,this.dataType);sql=Operators[this.operator](formattedField,formattedValue)}return sql}toSQLForDate(date,operator,options){const formattedField=formatFieldForSql(this.field,options?.useDelimitedIdentifiers===true);switch(operator){case"is_on":case"is_not_on":const formattedValues=date!==undefined?toDayRange(date).map((part=>formatValueForSql(part,"date"))):["''","''"];return Operators[operator](formattedField,`${formattedValues[0]} AND ${formattedValues[1]}`);default:const formattedValue=formatValueForSql(date,"date");return Operators[operator](formattedField,formattedValue)}}}class MultiValueExpression extends AbstractAttributeExpression{constructor(){super(...arguments);this.type="multi-value"}get validValues(){return this.value.filter(isValid)}validate(){return this.validValues.length>0}toSQL(options){const formattedField=formatFieldForSql(this.field,options?.useDelimitedIdentifiers===true);const formattedValues=this.validValues.map((value=>formatValueForSql(value,this.dataType)));return Operators[this.operator](formattedField,formattedValues)}}class RangeExpression extends AbstractAttributeExpression{constructor(){super(...arguments);this.type="range"}validate(){return isValid(this.value[0])&&isValid(this.value[1])}toSQL(options){const formattedField=formatFieldForSql(this.field,options?.useDelimitedIdentifiers===true);const first=formatValueForSql(this.value[0],this.dataType);const second=formatValueForSql(this.value[1],this.dataType);return Operators[this.operator](formattedField,[first,second])}}class SpatialExpression{constructor(layer,selectingLayer,spatialRelationship,spatialRelationshipParams){this.layer=layer;this.selectingLayer=selectingLayer;this.spatialRelationship=spatialRelationship;this.spatialRelationshipParams=spatialRelationshipParams}get isDistanceRelationship(){return this.spatialRelationship==="withinDistance"||this.spatialRelationship==="notWithinDistance"}validate(){let valid=this.selectingLayer!==undefined&&this.spatialRelationship!==undefined;if(this.isDistanceRelationship){const{distance,units}=this.spatialRelationshipParams??{};valid=valid&&isValid(distance)&&isValid(units)}return valid}changeSelectingLayer(selectingLayer){return new SpatialExpression(this.layer,selectingLayer,this.spatialRelationship,this.spatialRelationshipParams)}static getValidLayersForRelationships(layer,layers,relationships){const spatialRelationshipLayers=new Map;relationships.forEach((relationship=>{let validLayers=this.filterLayersBasedOnGeometryType(layer,layers,relationship);validLayers=this.getValidSelectingLayers(layer,validLayers??[]);spatialRelationshipLayers.set(relationship,validLayers)}));return spatialRelationshipLayers}static filterLayersBasedOnGeometryType(target,layers,spatialRelationship){const geometryTypesToLayers=new Map;layers.forEach((layer=>{if(geometryTypesToLayers.has(layer.geometryType)){const value=geometryTypesToLayers.get(layer.geometryType);value.push(layer)}else{geometryTypesToLayers.set(layer.geometryType,[layer])}}));const geometryType=target.geometryType;const polygonLayers=geometryTypesToLayers.get("polygon")??[];const lineLayers=geometryTypesToLayers.get("polyline")??[];const pointLayers=geometryTypesToLayers.get("point")??[];const multipointLayers=geometryTypesToLayers.get("multipoint")??[];let validLayers=[];if(spatialRelationship==="contains"||spatialRelationship==="notContains"){if(geometryType==="polygon"){validLayers=[...pointLayers,...lineLayers,...polygonLayers,...multipointLayers]}else if(geometryType==="polyline"){validLayers=[...pointLayers,...lineLayers,...multipointLayers]}else if(geometryType==="point"){validLayers=[...pointLayers,...multipointLayers]}else if(geometryType==="multipoint"){validLayers=[...pointLayers,...multipointLayers]}else{validLayers=[]}}else if(spatialRelationship==="within"||spatialRelationship==="notWithin"){if(geometryType==="point"){validLayers=[...pointLayers,...lineLayers,...polygonLayers,...multipointLayers]}else if(geometryType==="multipoint"){validLayers=[...pointLayers,...lineLayers,...polygonLayers,...multipointLayers]}else if(geometryType==="polyline"){validLayers=[...polygonLayers,...lineLayers]}else if(geometryType==="polygon"){validLayers=polygonLayers}else{validLayers=[]}}else{validLayers=layers}return validLayers}static getValidSelectingLayers(layer,options){return options.filter((option=>layer.id!==option.id))}changeSpatialRelationship(spatialRelationship){const newExpression=new SpatialExpression(this.layer,this.selectingLayer,spatialRelationship);if(newExpression.isDistanceRelationship){newExpression.spatialRelationshipParams={distance:this.spatialRelationshipParams?.distance,units:this.spatialRelationshipParams?.units??SpatialRelationshipUnits[0]}}return newExpression}changeSpatialRelationshipDistance(distance){const newParams={...this.spatialRelationshipParams,distance};return new SpatialExpression(this.layer,this.selectingLayer,this.spatialRelationship,newParams)}changeSpatialRelationshipUnit(unit){const newParams={...this.spatialRelationshipParams,units:unit};return new SpatialExpression(this.layer,this.selectingLayer,this.spatialRelationship,newParams)}}function isSupportedField(field,options,layer){const allowGeometryFieldsOption=options?.allowGeometryFields??false;const allowGeometryTypes=[layer?.geometryFieldsInfo?.shapeAreaField,layer?.geometryFieldsInfo?.shapeLengthField].includes(field.name)&&allowGeometryFieldsOption===false;if(options?.hideObjectIdField===true&&field.name===layer?.objectIdField||allowGeometryTypes===true){return false}switch(field.type){case"string":case"small-integer":case"integer":case"single":case"double":case"long":case"big-integer":case"date":case"geometry":case"oid":return true;case"blob":case"raster":case"guid":case"global-id":case"xml":return false;default:return false}}function getAdaptedFieldType(field,options){let adaptedFieldType=undefined;if(!isEmpty(field.description)){if(field.description===options?.booleanFieldDescription){adaptedFieldType="boolean"}else if(options?.geometryFieldDescriptions?.includes(field.description)===true){adaptedFieldType="geometry"}}return adaptedFieldType}function getExpressionTypeForOperator(operator){let expressionType="value";if(isRangeOperator(operator)){expressionType="range"}else if(isCollectionOperator(operator)){expressionType="multi-value"}return expressionType}class ExpressionController{constructor(expression){this.expression=expression}changeOperator(operator){const{field,dataType,id}=this.expression;const newExpression=_a.create({field,dataType,operator,id});if(getExpressionTypeForOperator(operator)===this.expression.type){newExpression.value=this.expression.value}return newExpression}changeField(field,options){if(!isSupportedField(field,options)){throw new Error(`Unsupported field type '${field.type}' for '${field.name}'`)}const dataType=getAdaptedFieldType(field,options)??field.type;return _a.create({field:field.name,dataType,id:this.expression.id})}changeValue(value){const newExpression=_a.create({field:this.expression.field,dataType:this.expression.dataType,operator:this.expression.operator,value,id:this.expression.id});return newExpression}static create({field,dataType,operator,id,value}){let defaultOperator;let supportedOperators;let expression;switch(dataType){case"string":defaultOperator="equal";supportedOperators=StringOperators;break;case"small-integer":case"integer":case"big-integer":case"single":case"double":case"long":case"oid":defaultOperator="equal";supportedOperators=NumericOperators;break;case"date":defaultOperator="is_on";supportedOperators=DateOperators;break;case"geometry":defaultOperator="is_blank";supportedOperators=GeometryOperators;break;case"boolean":defaultOperator="is_true";supportedOperators=BooleanOperators;break;default:throw new Error(`Data type not supported: ${dataType}`)}if(operator!==undefined&&!supportedOperators.includes(operator)){throw new Error(`Invalid operator '${operator}' for type '${field}'`)}const validOperator=operator??defaultOperator;switch(getExpressionTypeForOperator(validOperator)){case"value":expression=new ValueExpression(field,dataType,value,validOperator,id);break;case"multi-value":expression=new MultiValueExpression(field,dataType,value??[],validOperator,id);break;case"range":expression=new RangeExpression(field,dataType,value??[undefined,undefined],validOperator,id);break}return expression}static createDefaultForLayer(layer,options){const validFields=layer.fields.filter((field=>isSupportedField(field,options,layer)));if(validFields.length<1){return undefined}else{const field=validFields[0];const dataType=getAdaptedFieldType(field,options)??field.type;return _a.create({field:field.name,dataType})}}}_a=ExpressionController;ExpressionController.fromSQL=async(clause,fieldsIndex,options)=>{const result=await index2.parseWhereClause(clause,fieldsIndex);return _a.fromSQLNode(result.parseTree,fieldsIndex,options)};ExpressionController.fromSQLNode=(parseTree,fieldsIndex,options)=>{assert(parseTree.type==="binary-expression","Invalid expression: not a condition.");let columnNode,valueNode;if(parseTree.left.type==="column-reference"){columnNode=parseTree.left;valueNode=parseTree.right}else{columnNode=parseTree.right;valueNode=parseTree.left}assert(columnNode.type==="column-reference","Invalid expression: missing column reference.");const field=fieldsIndex.get(columnNode.column);assert(isSupportedField(field,options),"Invalid expression: unsupported field.");let expression;const defaultOperator=OperatorsSymbolToWritten[parseTree.operator];if(isRangeOperator(defaultOperator)){assert(valueNode.type==="expression-list","Invalid expression: invalid value type.");const value=valueNode.value;const first=parseValueFromSqlNode(value[0]);const second=parseValueFromSqlNode(value[1]);expression=new RangeExpression(field.name,field.type,[first,second],defaultOperator);if(first instanceof Date&&second instanceof Date&&areDayRange([first,second])){const onOperator=expression.operator==="between"?"is_on":"is_not_on";expression=new ValueExpression(field.name,"date",first,onOperator)}}else if(isCollectionOperator(defaultOperator)){assert(valueNode.type==="expression-list","Invalid expression: invalid value type.");const values=valueNode.value;const parsedValues=values.map(parseValueFromSqlNode);expression=new MultiValueExpression(field.name,field.type,parsedValues,defaultOperator)}else{const[operator,value]=parseComparisonNodeParts(parseTree.operator,valueNode);const dataType=getAdaptedFieldType(field,options)??field.type;expression=new ValueExpression(field.name,dataType,value,operator)}return expression};exports.BooleanOperators=BooleanOperators;exports.DateOperators=DateOperators;exports.ExpressionController=ExpressionController;exports.ExpressionGroupOperator=ExpressionGroupOperator;exports.GeometryOperators=GeometryOperators;exports.NumericOperators=NumericOperators;exports.SpatialExpression=SpatialExpression;exports.SpatialRelationshipUnits=SpatialRelationshipUnits;exports.SpatialRelationships=SpatialRelationships;exports.StringOperators=StringOperators;exports.assert=assert;exports.getIncrementalId=getIncrementalId;exports.isFloatFieldType=isFloatFieldType;exports.isIntFieldType=isIntFieldType;exports.isNoValueOperator=isNoValueOperator;exports.isRangeOperator=isRangeOperator;exports.isSupportedField=isSupportedField}));
