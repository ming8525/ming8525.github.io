define(["exports","./index-ef555910","./index2-588b02d9","./t9n-24f5c39b","./expressions-18db914f","./utils-793221d4","./analysis-query-entry2-a97f8d18"],(function(exports,index,index2,t9n,expressions,utils,analysisQueryEntry2){"use strict";const HTMLClasses={flexContainer:"flex-container",halfWidth:"half-width",singleValue:"single-value",fieldSelect:"field-select",valueSelect:"value-select"};const analysisAttributeExpressionCss=":root{--analysis-quarter-spacing:0.25rem;--analysis-half-spacing:0.5rem;--analysis-three-quarter-spacing:0.75rem;--analysis-full-spacing:1rem;--analysis-component-default-width:100%;--analysis-ui-border-input:#d4d4d4;--analysis-label-font-size:var(--calcite-font-size--2);--analysis-popover-content-min-height-s:7.5rem;--analysis-popover-content-min-height-m:8.75rem;--analysis-popover-content-max-height:60vh;--analysis-popover-content-height:45vh}.flex-container{display:flex}.half-width{width:50%}.single-value{display:flex}.single-value .field-select{max-inline-size:45%}.single-value .value-select{--calcite-combobox-input-height:1rem;min-width:150px}";function getOperatorChoicesForExpression(expression){switch(expression.dataType){case"string":return expressions.StringOperators;case"small-integer":case"integer":case"big-integer":case"single":case"double":case"long":case"oid":return expressions.NumericOperators;case"date":return expressions.DateOperators;case"geometry":return expressions.GeometryOperators;case"boolean":return expressions.BooleanOperators}}const AnalysisAttributeExpression=index.proxyCustomElement(class AnalysisAttributeExpression extends index.H{constructor(){super();this.__registerHost();this.__attachShadow();this.analysisExpressionChange=index.createEvent(this,"analysisExpressionChange",7);this.analysisExpressionRemoveClick=index.createEvent(this,"analysisExpressionRemoveClick",7);this.defaultMaxDropdownItems=2e3;this.removePopover=()=>{this.uniqueValuesPopover?.remove();this.uniqueValuesPopover=undefined};this.handleUniqueValuesListChange=event=>{const selectedValues=event.detail.selectedValues;const parsedValue=this.parseStringInput(selectedValues[0],this.expression.dataType);this.expression=new expressions.ExpressionController(this.expression).changeValue(parsedValue);this.analysisExpressionChange.emit();this.removePopover()};this.renderFieldValueComboBoxItem=fieldValue=>{let isSelected=false;if(this.expression.type==="multi-value"&&this.expression.value!==undefined){isSelected=this.expression.value.includes(fieldValue.value)}else{isSelected=this.expression.value===fieldValue.value}return index.h("calcite-combobox-item",{key:fieldValue.label,value:fieldValue.value,textLabel:fieldValue.label,selected:isSelected})};this.onRemoveClick=event=>{this.analysisExpressionRemoveClick.emit();event.stopPropagation()};this.onFieldSelect=event=>{const newFieldName=event.target.selectedOption.value;const newField=this.fields?.find((field=>field.name===newFieldName));if(newField!==undefined){this.expression=new expressions.ExpressionController(this.expression).changeField(newField,this.options);this.loadFieldValues(newField.name)}this.analysisExpressionChange.emit()};this.setFieldValuesByUniqueValues=async fieldName=>{this.loadingMessage=this.strings.loadingFieldValues;let fieldValues=[];const cacheId=`${this.target.id}-${fieldName}`;let cachedFieldValueObject=index2.inCache("layerFieldValues",cacheId);if(cachedFieldValueObject===undefined){try{cachedFieldValueObject=await index2.fromCache((()=>index2.getUniqueValues({layer:this.target,fieldName})),"layerFieldValues",cacheId)}catch{this.loadingMessage=this.strings.errorRetrievingFieldValues}}const resultObjects=cachedFieldValueObject?.uniqueValueInfos??[];fieldValues=resultObjects.map((result=>({value:result.value,label:result.label??result.value})));return fieldValues};this.onOperatorSelect=event=>{const newOperator=event.target.selectedOption.value;this.expression=new expressions.ExpressionController(this.expression).changeOperator(newOperator);this.analysisExpressionChange.emit()};this.onValueInputChange=event=>{const value=event.target.value;this.expression.value=this.parseStringInput(value,this.expression.dataType);this.analysisExpressionChange.emit()};this.onValueComboboxChange=event=>{const value=event.target.value;const singleValue=Array.isArray(value)?value[0]:value;this.expression.value=this.parseStringInput(singleValue,this.expression.dataType);this.analysisExpressionChange.emit()};this.onValuesComboboxChange=event=>{expressions.assert(this.expression.type==="multi-value","Incorrect render function for expression type.");const value=event.target.value;const valueArray=Array.isArray(value)?value:[value];const validExpressionValues=valueArray.map((entry=>this.parseStringInput(entry,this.expression.dataType)));this.expression.value=validExpressionValues.filter((expressionValue=>index2.isEmptyDataItem(expressionValue)===false));this.analysisExpressionChange.emit()};this.onValueDateChange=()=>{const value=this.parseDateValueFromInputs(this.valueDateInputElement,this.valueTimeInputElement);this.expression.value=value;this.analysisExpressionChange.emit()};this.onRangeStartDateChange=()=>{expressions.assert(this.expression.type==="range","Incorrect render function for expression type.");const value=this.parseDateValueFromInputs(this.startDateInputElement,this.startTimeInputElement);this.expression.value[0]=value;this.analysisExpressionChange.emit()};this.onRangeEndDateChange=()=>{expressions.assert(this.expression.type==="range","Incorrect render function for expression type.");const value=this.parseDateValueFromInputs(this.endDateInputElement,this.endTimeInputElement);this.expression.value[1]=value;this.analysisExpressionChange.emit()};this.onRangeStartInputChange=event=>{expressions.assert(this.expression.type==="range","Incorrect render function for expression type.");const value=event.target.value;this.expression.value[0]=this.parseStringInput(value,this.expression.dataType);this.analysisExpressionChange.emit()};this.onRangeEndInputChange=event=>{expressions.assert(this.expression.type==="range","Incorrect render function for expression type.");const value=event.target.value;this.expression.value[1]=this.parseStringInput(value,this.expression.dataType);this.analysisExpressionChange.emit()};this.parseStringInput=(value,dataType)=>{let parsedValue;if(index2.isEmptyDataItem(value)){parsedValue=undefined}else if(expressions.isFloatFieldType(dataType)){parsedValue=value===""?undefined:parseFloat(value)}else if(expressions.isIntFieldType(dataType)){parsedValue=value===""?undefined:parseInt(value)}else{parsedValue=value}return parsedValue};this.parseDateValueFromInputs=(dateInput,timeInput)=>{const dateInputValue=dateInput?.valueAsDate;const timeInputValue=timeInput?.value?timeInput.value.split(":"):[0,0];return new Date(dateInputValue.getFullYear(),dateInputValue.getMonth(),dateInputValue.getDate(),Number(timeInputValue[0]),Number(timeInputValue[1]))};this.fields=undefined;this.fieldValues=[];this.loadingMessage=undefined;this.expression=undefined;this.target=undefined;this.options=undefined}get selectedField(){return this.fields?.find((field=>field.name===this.expression?.field))}async loadFields(target){this.loadAbortController?.abort();this.loadAbortController=new AbortController;try{await(target?.load(this.loadAbortController.signal))}catch(err){}const allFields=target?.fields??[];this.fields=allFields.filter((field=>expressions.isSupportedField(field,this.options,target)))}async componentWillLoad(){this.strings=t9n.getStrings();await this.loadFields(this.target);this.loadFieldValues(this.expression.field)}render(){switch(this.expression.type){case"value":return index.h("analysis-query-entry",{kind:"expression",appearance:"inline",onAnalysisQueryEntryRemove:this.onRemoveClick},index.h("div",{class:HTMLClasses.singleValue},this.renderFieldSelect("auto"),this.renderOperatorSelect("auto"),this.renderValueInput()));case"multi-value":return index.h("analysis-query-entry",{kind:"expression",appearance:"section",onAnalysisQueryEntryRemove:this.onRemoveClick},index.h("div",{class:HTMLClasses.flexContainer},this.renderFieldSelect("half"),this.renderOperatorSelect("half")),this.renderValuesInput());case"range":return index.h("analysis-query-entry",{kind:"expression",appearance:"section",onAnalysisQueryEntryRemove:this.onRemoveClick},index.h("div",{class:HTMLClasses.flexContainer},this.renderFieldSelect("half"),this.renderOperatorSelect("half")),this.renderRangeInputs())}}renderFieldSelect(width="auto"){return index.h("calcite-select",{class:HTMLClasses.fieldSelect,label:this.strings.fieldSelect,width,onCalciteSelectChange:this.onFieldSelect},this.fields?.map((field=>index.h("calcite-option",{value:field.name,selected:field.name===this.expression?.field},field.alias))))}renderOperatorSelect(width="auto"){const allChoices=getOperatorChoicesForExpression(this.expression);const hasOptions=this.getSelectedFieldDomainOptions()!==undefined;const choices=allChoices.filter((choice=>!(hasOptions&&expressions.isRangeOperator(choice))));return index.h("calcite-select",{label:this.strings.expressionOperatorSelect,key:this.expression.operator,width,onCalciteSelectChange:this.onOperatorSelect},choices.map((choice=>{const string=this.strings.operators[choice];const label=choice==="is_true"||choice==="is_false"?string.toLocaleLowerCase():string;return index.h("calcite-option",{value:choice,selected:this.expression?.operator===choice},label)})))}createUniqueValuesPopover(isDate=false,isMultiple=false){if(this.uniqueValuesPopover){this.removePopover()}const popoverWidth=this.numberInputElement?.getBoundingClientRect().width;this.uniqueValuesPopover=document.createElement("calcite-popover");const popoverProps={autoClose:true,focusTrapDisabled:true,placement:"bottom-end",offsetDistance:0,offsetSkidding:0,pointerDisabled:true,open:true,referenceElement:this.numberInputElement,style:`width: ${popoverWidth}px;`};Object.assign(this.uniqueValuesPopover,popoverProps);this.uniqueValuesPopover.addEventListener("calcitePopoverClose",this.removePopover);const uniqueValuesList=document.createElement("arcgis-filter-unique-list");const uniqueValuesListProps={uid:`arcgis-filter-unique-list_${this.expression.field}`,uniqueValues:this.fieldValues,selectedValues:[this.expression.value],layerFieldType:this.expression.dataType,isDate,props:{},multiple:isMultiple,partialUniqueValues:this.options?.maxDropdownItems===undefined?false:this.fieldValues.length>=this.options.maxDropdownItems,strings:{searchValues:this.strings.searchValues,sortByCount:this.strings.sortByCount,sortAlphabetical:this.strings.sortAlphabetical,sortSelected:this.strings.sortSelected,errors:{tooManyUniqueValues:this.strings.tooManyValuesToDisplay}},maxHeight:300};Object.assign(uniqueValuesList,uniqueValuesListProps);uniqueValuesList.addEventListener("arcgisFilterUniqueListChanged",this.handleUniqueValuesListChange);this.uniqueValuesPopover.appendChild(uniqueValuesList);document.body.append(this.uniqueValuesPopover);setTimeout((()=>requestAnimationFrame((()=>this.uniqueValuesPopover?.setFocus()))),1)}renderValueInput(){expressions.assert(this.expression.type==="value","Incorrect render function for expression type.");const{dataType,value,operator}=this.expression;const expressionValueComboBoxItem=value!==undefined&&index.h("calcite-combobox-item",{key:`${value}`,value,textLabel:`${value}`,selected:true});let filteredFieldValues=this.fieldValues.filter((obj=>obj.value!==value));const showTooManyValuesMessage=filteredFieldValues.length>this.defaultMaxDropdownItems;filteredFieldValues=filteredFieldValues.slice(0,this.options?.maxDropdownItems??this.defaultMaxDropdownItems);let input;if(expressions.isNoValueOperator(operator)){input=null}else if(expressions.isFloatFieldType(dataType)||expressions.isIntFieldType(dataType)){const step=expressions.isFloatFieldType(dataType)?"any":1;const minMax=this.getSelectedFieldMinMax();input=index.h("calcite-input-number",{step,placeholder:this.strings.inputPlaceholderText,value:value===undefined?undefined:`${value}`,onCalciteInputNumberChange:this.onValueInputChange,min:minMax?.min,max:minMax?.max,ref:element=>{if(element!==undefined){this.numberInputElement=element}}},index.h("calcite-button",{slot:"action",label:this.strings.chooseFromUniqueValues,appearance:"outline",kind:"neutral",scale:utils.UIDefaults.MediumScale,iconEnd:"chevron-down",onClick:()=>this.createUniqueValuesPopover()}))}else if(dataType==="date"){input=this.renderValueDateInput()}else{input=index.h("calcite-combobox",{class:HTMLClasses.valueSelect,label:this.strings.choiceList,allowCustomValues:true,scale:utils.UIDefaults.MediumScale,selectionMode:"single",key:this.expression.operator,value:value===undefined?undefined:`${value}`,placeholder:this.strings.inputPlaceholderText,onCalciteComboboxChange:this.onValueComboboxChange,overlayPositioning:"fixed"},expressionValueComboBoxItem,this.loadingMessage!==undefined?index.h(index.Fragment,null,index.h("calcite-combobox-item",{key:this.loadingMessage,value:undefined,textLabel:this.loadingMessage,selected:false,disabled:true})):index.h(index.Fragment,null,filteredFieldValues.map((fieldValue=>this.renderFieldValueComboBoxItem(fieldValue))),showTooManyValuesMessage&&index.h("calcite-combobox-item",{key:this.strings.tooManyValuesToDisplay,value:undefined,textLabel:this.strings.tooManyValuesToDisplay,selected:false,disabled:true})))}return input}renderValuesInput(){expressions.assert(this.expression.type==="multi-value","Incorrect render function for expression type.");let expressionValues=[];if(index2.isEmptyDataItem(this.expression.value)===false){expressionValues=this.expression.value.map((value=>`${value}`))}const expressionValueComboBoxItems=expressionValues.map((value=>index.h("calcite-combobox-item",{key:value,value,textLabel:value,selected:true})));let comboBoxItems;if(index2.isEmptyDataItem(this.fieldValues)===false){let filteredFieldValues=this.fieldValues.filter((obj=>!expressionValues.includes(`${obj.value}`)));const showTooManyValuesMessage=filteredFieldValues.length>this.defaultMaxDropdownItems;filteredFieldValues=filteredFieldValues.slice(0,this.options?.maxDropdownItems??this.defaultMaxDropdownItems);comboBoxItems=index.h(index.Fragment,null,expressionValueComboBoxItems,this.loadingMessage!==undefined?index.h("calcite-combobox-item",{key:this.loadingMessage,value:undefined,textLabel:this.loadingMessage,selected:false,disabled:true}):index.h(index.Fragment,null,filteredFieldValues?.map((fieldValue=>index.h("calcite-combobox-item",{key:`${fieldValue.label}`,value:fieldValue.value,textLabel:`${fieldValue.label}`,selected:expressionValues.includes(`${fieldValue.value}`)}))),showTooManyValuesMessage&&index.h("calcite-combobox-item",{key:this.strings.tooManyValuesToDisplay,value:undefined,textLabel:this.strings.tooManyValuesToDisplay,selected:false,disabled:true})))}else{comboBoxItems=expressionValueComboBoxItems}return index.h("calcite-combobox",{label:this.strings.multiInputPlaceholderText,onCalciteComboboxChange:this.onValuesComboboxChange,allowCustomValues:true,selectionMode:"multiple",scale:utils.UIDefaults.MediumScale,value:expressionValues,key:this.expression.operator,overlayPositioning:"fixed",placeholder:this.strings.inputPlaceholderText,clearDisabled:true},comboBoxItems)}renderValueDateInput(){expressions.assert(this.expression.type==="value","Incorrect render function for expression type.");const{operator,value}=this.expression;const date=value;const timeString=this.parseTimeValue(date);const noTimeOperators=["is_on","is_not_on"];const noTimeInput=noTimeOperators.includes(operator);const input=index.h("div",{class:HTMLClasses.flexContainer},index.h("calcite-input-date-picker",{key:"value-date",placement:"bottom",class:noTimeInput?HTMLClasses.flexContainer:HTMLClasses.halfWidth,layout:"vertical",overlayPositioning:"fixed",valueAsDate:date,onCalciteInputDatePickerChange:this.onValueDateChange,ref:e=>{this.valueDateInputElement=e}}),!noTimeInput&&index.h("calcite-input-time-picker",{key:"value-time",placement:"bottom",class:HTMLClasses.halfWidth,overlayPositioning:"fixed",value:timeString,onCalciteInputTimePickerChange:this.onValueDateChange,ref:e=>{this.valueTimeInputElement=e}}));return input}renderRangeInputs(){expressions.assert(this.expression.type==="range","Incorrect render function for expression type.");const{dataType,value}=this.expression;let inputs;if(expressions.isFloatFieldType(dataType)||expressions.isIntFieldType(dataType)){const step=expressions.isFloatFieldType(dataType)?"any":1;const minMax=this.getSelectedFieldMinMax();inputs=index.h("div",{class:HTMLClasses.flexContainer},index.h("calcite-input-number",{step,class:HTMLClasses.halfWidth,value:value[0]===undefined?"":`${value[0]}`,onCalciteInputNumberChange:this.onRangeStartInputChange,min:minMax?.min,max:minMax?.max}),index.h("calcite-input-number",{step,class:HTMLClasses.halfWidth,value:value[1]===undefined?"":`${value[1]}`,onCalciteInputNumberChange:this.onRangeEndInputChange,min:minMax?.min,max:minMax?.max}))}else if(dataType==="date"){inputs=this.renderRangeDateInputs()}else{inputs=index.h("p",null,"Not supported yet.")}return inputs}renderRangeDateInputs(){expressions.assert(this.expression.type==="range","Incorrect render function for expression type.");const{value}=this.expression;const dateFrom=value[0];const dateTo=value[1];const timeStringFrom=this.parseTimeValue(dateFrom);const timeStringTo=this.parseTimeValue(dateTo);return index.h("div",{class:HTMLClasses.flexContainer},index.h("calcite-input-date-picker",{key:"start-date",class:HTMLClasses.halfWidth,placement:"bottom",overlayPositioning:"fixed",valueAsDate:dateFrom,onCalciteInputDatePickerChange:this.onRangeStartDateChange,ref:e=>{this.startDateInputElement=e}}),index.h("calcite-input-time-picker",{key:"start-time",class:HTMLClasses.halfWidth,placement:"bottom",overlayPositioning:"fixed",value:timeStringFrom,onCalciteInputTimePickerChange:this.onRangeStartDateChange,ref:e=>{this.startTimeInputElement=e}}),index.h("calcite-input-date-picker",{key:"end-date",class:HTMLClasses.halfWidth,placement:"bottom",overlayPositioning:"fixed",valueAsDate:dateTo,onCalciteInputDatePickerChange:this.onRangeEndDateChange,ref:e=>{this.endDateInputElement=e}}),index.h("calcite-input-time-picker",{key:"end-time",class:HTMLClasses.halfWidth,placement:"bottom",overlayPositioning:"fixed",value:timeStringTo,onCalciteInputTimePickerChange:this.onRangeEndDateChange,ref:e=>{this.endTimeInputElement=e}}))}async loadFieldValues(newFieldName){let fieldValues=this.getSelectedFieldDomainOptions()??[];if(index2.isEmptyDataItem(fieldValues)){fieldValues=await this.setFieldValuesByUniqueValues(newFieldName)}fieldValues=fieldValues.filter((obj=>index2.isEmptyDataItem(obj.value)===false));this.fieldValues=fieldValues;if(this.loadingMessage!==this.strings.errorRetrievingFieldValues){this.loadingMessage=index2.isEmptyDataItem(this.fieldValues)?this.strings.noFieldValuesRetrieved:undefined}}getSelectedFieldMinMax(){let minMax;const selectedFieldDomain=this.selectedField?.domain;if(selectedFieldDomain?.type==="range"){minMax={min:selectedFieldDomain.minValue,max:selectedFieldDomain.maxValue}}return minMax}getSelectedFieldDomainOptions(){let options;const fieldName=this.selectedField?.name;const selectedFieldDomain=this.selectedField?.domain;if(selectedFieldDomain?.type==="coded-value"){options=selectedFieldDomain.codedValues.map((codedValue=>({label:codedValue.name,value:codedValue.code})))}else if(fieldName!==undefined&&fieldName===this.target?.typeIdField){options=this.target?.types.map((type=>({label:type.name,value:type.id})))}else if(fieldName!==undefined&&index2.isEmptyDataItem(this.target?.types)===false){const aggregatedOptions=new Map;for(const type of this.target.types){const domain=type.domains[fieldName];if(domain?.type==="coded-value"){for(const codedValue of domain.codedValues){const existingEntry=aggregatedOptions.get(codedValue.code);if(existingEntry===undefined){aggregatedOptions.set(codedValue.code,[codedValue.name])}else if(!existingEntry.includes(codedValue.name)){existingEntry.push(codedValue.name)}}}}if(aggregatedOptions.size>0){options=[];for(const[code,labels]of aggregatedOptions){options.push({label:labels.join(" | "),value:code})}}}return options}parseTimeValue(date){return date instanceof Date?date.toTimeString().substring(0,5):undefined}get hostElement(){return this}static get watchers(){return{target:["loadFields"]}}static get style(){return analysisAttributeExpressionCss}},[1,"analysis-attribute-expression",{expression:[1040],target:[16],options:[16],fields:[32],fieldValues:[32],loadingMessage:[32]},undefined,{target:["loadFields"]}]);function defineCustomElement(){if(typeof customElements==="undefined"){return}const components=["analysis-attribute-expression","analysis-query-entry"];components.forEach((tagName=>{switch(tagName){case"analysis-attribute-expression":if(!customElements.get(tagName)){customElements.define(tagName,AnalysisAttributeExpression)}break;case"analysis-query-entry":if(!customElements.get(tagName)){analysisQueryEntry2.defineCustomElement()}break}}))}defineCustomElement();exports.AnalysisAttributeExpression=AnalysisAttributeExpression;exports.defineCustomElement=defineCustomElement}));
