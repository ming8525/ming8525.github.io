define(["exports"],(function(exports){"use strict";const BUILD={allRenderFn:false,cmpDidLoad:true,cmpDidUnload:false,cmpDidUpdate:true,cmpDidRender:true,cmpWillLoad:true,cmpWillUpdate:true,cmpWillRender:true,connectedCallback:true,disconnectedCallback:true,element:true,event:true,hasRenderFn:true,lifecycle:true,hostListener:true,hostListenerTargetWindow:true,hostListenerTargetDocument:true,hostListenerTargetBody:true,hostListenerTargetParent:false,hostListenerTarget:true,member:true,method:true,mode:true,observeAttribute:true,prop:true,propMutable:true,reflect:true,scoped:true,shadowDom:true,slot:true,cssAnnotations:true,state:true,style:true,formAssociated:false,svg:true,updatable:true,vdomAttribute:true,vdomXlink:true,vdomClass:true,vdomFunctional:true,vdomKey:true,vdomListener:true,vdomRef:true,vdomPropOrAttr:true,vdomRender:true,vdomStyle:true,vdomText:true,watchCallback:true,taskQueue:true,hotModuleReplacement:false,isDebug:false,isDev:false,isTesting:false,hydrateServerSide:false,hydrateClientSide:false,lifecycleDOMEvents:false,lazyLoad:false,profile:false,slotRelocation:true,appendChildSlotFix:false,cloneNodeFix:false,hydratedAttribute:false,hydratedClass:true,scriptDataOpts:false,scopedSlotTextContentFix:false,shadowDomShim:false,slotChildNodesFix:false,invisiblePrehydration:true,propBoolean:true,propNumber:true,propString:true,constructableCSS:true,cmpShouldUpdate:true,devTools:false,shadowDelegatesFocus:true,initializeNextTick:false,asyncLoading:false,asyncQueue:false,transformTagName:false,attachStyles:true,experimentalSlotFixes:false};let scopeId;let contentRef;let hostTagName;let useNativeShadowDom=false;let checkSlotFallbackVisibility=false;let checkSlotRelocate=false;let isSvgMode=false;let renderingRef=null;let queuePending=false;({isDev:BUILD.isDev?true:false,isBrowser:true,isServer:false,isTesting:BUILD.isTesting?true:false});const getAssetPath=path=>{const assetUrl=new URL(path,plt.$resourcesUrl$);return assetUrl.origin!==win.location.origin?assetUrl.href:assetUrl.pathname};const setAssetPath=path=>plt.$resourcesUrl$=path;const createTime=(fnName,tagName="")=>{{return()=>{}}};const SLOT_FB_CSS="slot-fb{display:contents}slot-fb[hidden]{display:none}";const XLINK_NS="http://www.w3.org/1999/xlink";const EMPTY_OBJ={};const SVG_NS="http://www.w3.org/2000/svg";const HTML_NS="http://www.w3.org/1999/xhtml";const isDef=v=>v!=null;const isComplexType=o=>{o=typeof o;return o==="object"||o==="function"};function queryNonceMetaTagContent(doc){var _a,_b,_c;return(_c=(_b=(_a=doc.head)===null||_a===void 0?void 0:_a.querySelector('meta[name="csp-nonce"]'))===null||_b===void 0?void 0:_b.getAttribute("content"))!==null&&_c!==void 0?_c:undefined}const h=(nodeName,vnodeData,...children)=>{let child=null;let key=null;let slotName=null;let simple=false;let lastSimple=false;const vNodeChildren=[];const walk=c=>{for(let i=0;i<c.length;i++){child=c[i];if(Array.isArray(child)){walk(child)}else if(child!=null&&typeof child!=="boolean"){if(simple=typeof nodeName!=="function"&&!isComplexType(child)){child=String(child)}if(simple&&lastSimple){vNodeChildren[vNodeChildren.length-1].$text$+=child}else{vNodeChildren.push(simple?newVNode(null,child):child)}lastSimple=simple}}};walk(children);if(vnodeData){if(BUILD.isDev&&nodeName==="input"){validateInputProperties(vnodeData)}if(BUILD.vdomKey&&vnodeData.key){key=vnodeData.key}if(BUILD.slotRelocation&&vnodeData.name){slotName=vnodeData.name}if(BUILD.vdomClass){const classData=vnodeData.className||vnodeData.class;if(classData){vnodeData.class=typeof classData!=="object"?classData:Object.keys(classData).filter((k=>classData[k])).join(" ")}}}if(BUILD.isDev&&vNodeChildren.some(isHost)){consoleDevError(`The <Host> must be the single root component. Make sure:\n- You are NOT using hostData() and <Host> in the same component.\n- <Host> is used once, and it's the single root component of the render() function.`)}if(BUILD.vdomFunctional&&typeof nodeName==="function"){return nodeName(vnodeData===null?{}:vnodeData,vNodeChildren,vdomFnUtils)}const vnode=newVNode(nodeName,null);vnode.$attrs$=vnodeData;if(vNodeChildren.length>0){vnode.$children$=vNodeChildren}if(BUILD.vdomKey){vnode.$key$=key}if(BUILD.slotRelocation){vnode.$name$=slotName}return vnode};const newVNode=(tag,text)=>{const vnode={$flags$:0,$tag$:tag,$text$:text,$elm$:null,$children$:null};if(BUILD.vdomAttribute){vnode.$attrs$=null}if(BUILD.vdomKey){vnode.$key$=null}if(BUILD.slotRelocation){vnode.$name$=null}return vnode};const Host={};const isHost=node=>node&&node.$tag$===Host;const vdomFnUtils={forEach:(children,cb)=>children.map(convertToPublic).forEach(cb),map:(children,cb)=>children.map(convertToPublic).map(cb).map(convertToPrivate)};const convertToPublic=node=>({vattrs:node.$attrs$,vchildren:node.$children$,vkey:node.$key$,vname:node.$name$,vtag:node.$tag$,vtext:node.$text$});const convertToPrivate=node=>{if(typeof node.vtag==="function"){const vnodeData=Object.assign({},node.vattrs);if(node.vkey){vnodeData.key=node.vkey}if(node.vname){vnodeData.name=node.vname}return h(node.vtag,vnodeData,...node.vchildren||[])}const vnode=newVNode(node.vtag,node.vtext);vnode.$attrs$=node.vattrs;vnode.$children$=node.vchildren;vnode.$key$=node.vkey;vnode.$name$=node.vname;return vnode};const validateInputProperties=inputElm=>{const props=Object.keys(inputElm);const value=props.indexOf("value");if(value===-1){return}const typeIndex=props.indexOf("type");const minIndex=props.indexOf("min");const maxIndex=props.indexOf("max");const stepIndex=props.indexOf("step");if(value<typeIndex||value<minIndex||value<maxIndex||value<stepIndex){consoleDevWarn(`The "value" prop of <input> should be set after "min", "max", "type" and "step"`)}};const computeMode=elm=>modeResolutionChain.map((h=>h(elm))).find((m=>!!m));const parsePropertyValue=(propValue,propType)=>{if(propValue!=null&&!isComplexType(propValue)){if(propType&4){return propValue==="false"?false:propValue===""||!!propValue}if(propType&2){return parseFloat(propValue)}if(propType&1){return String(propValue)}return propValue}return propValue};const getElement=ref=>BUILD.lazyLoad?getHostRef(ref).$hostElement$:ref;const createEvent=(ref,name,flags)=>{const elm=getElement(ref);return{emit:detail=>{if(BUILD.isDev&&!elm.isConnected){consoleDevWarn(`The "${name}" event was emitted, but the dispatcher node is no longer connected to the dom.`)}return emitEvent(elm,name,{bubbles:!!(flags&4),composed:!!(flags&2),cancelable:!!(flags&1),detail})}}};const emitEvent=(elm,name,opts)=>{const ev=plt.ce(name,opts);elm.dispatchEvent(ev);return ev};const rootAppliedStyles=new WeakMap;const registerStyle=(scopeId,cssText,allowCS)=>{let style=styles.get(scopeId);if(supportsConstructableStylesheets&&allowCS){style=style||new CSSStyleSheet;if(typeof style==="string"){style=cssText}else{style.replaceSync(cssText)}}else{style=cssText}styles.set(scopeId,style)};const addStyle=(styleContainerNode,cmpMeta,mode)=>{var _a;const scopeId=getScopeId(cmpMeta,mode);const style=styles.get(scopeId);styleContainerNode=styleContainerNode.nodeType===11?styleContainerNode:doc;if(style){if(typeof style==="string"){styleContainerNode=styleContainerNode.head||styleContainerNode;let appliedStyles=rootAppliedStyles.get(styleContainerNode);let styleElm;if(!appliedStyles){rootAppliedStyles.set(styleContainerNode,appliedStyles=new Set)}if(!appliedStyles.has(scopeId)){{styleElm=doc.createElement("style");styleElm.innerHTML=style;const nonce=(_a=plt.$nonce$)!==null&&_a!==void 0?_a:queryNonceMetaTagContent(doc);if(nonce!=null){styleElm.setAttribute("nonce",nonce)}styleContainerNode.insertBefore(styleElm,styleContainerNode.querySelector("link"))}if(cmpMeta.$flags$&4){styleElm.innerHTML+=SLOT_FB_CSS}if(appliedStyles){appliedStyles.add(scopeId)}}}else if(!styleContainerNode.adoptedStyleSheets.includes(style)){styleContainerNode.adoptedStyleSheets=[...styleContainerNode.adoptedStyleSheets,style]}}return scopeId};const attachStyles=hostRef=>{const cmpMeta=hostRef.$cmpMeta$;const elm=hostRef.$hostElement$;const flags=cmpMeta.$flags$;const endAttachStyles=createTime("attachStyles",cmpMeta.$tagName$);const scopeId=addStyle(supportsShadow&&elm.shadowRoot?elm.shadowRoot:elm.getRootNode(),cmpMeta,hostRef.$modeName$);if(flags&10){elm["s-sc"]=scopeId;elm.classList.add(scopeId+"-h");if(flags&2){elm.classList.add(scopeId+"-s")}}endAttachStyles()};const getScopeId=(cmp,mode)=>"sc-"+(mode&&cmp.$flags$&32?cmp.$tagName$+"-"+mode:cmp.$tagName$);const setAccessor=(elm,memberName,oldValue,newValue,isSvg,flags)=>{if(oldValue!==newValue){let isProp=isMemberInElement(elm,memberName);let ln=memberName.toLowerCase();if(memberName==="class"){const classList=elm.classList;const oldClasses=parseClassList(oldValue);const newClasses=parseClassList(newValue);classList.remove(...oldClasses.filter((c=>c&&!newClasses.includes(c))));classList.add(...newClasses.filter((c=>c&&!oldClasses.includes(c))))}else if(memberName==="style"){{for(const prop in oldValue){if(!newValue||newValue[prop]==null){if(prop.includes("-")){elm.style.removeProperty(prop)}else{elm.style[prop]=""}}}}for(const prop in newValue){if(!oldValue||newValue[prop]!==oldValue[prop]){if(prop.includes("-")){elm.style.setProperty(prop,newValue[prop])}else{elm.style[prop]=newValue[prop]}}}}else if(memberName==="key");else if(memberName==="ref"){if(newValue){newValue(elm)}}else if(!elm.__lookupSetter__(memberName)&&memberName[0]==="o"&&memberName[1]==="n"){if(memberName[2]==="-"){memberName=memberName.slice(3)}else if(isMemberInElement(win,ln)){memberName=ln.slice(2)}else{memberName=ln[2]+memberName.slice(3)}if(oldValue||newValue){const capture=memberName.endsWith(CAPTURE_EVENT_SUFFIX);memberName=memberName.replace(CAPTURE_EVENT_REGEX,"");if(oldValue){plt.rel(elm,memberName,oldValue,capture)}if(newValue){plt.ael(elm,memberName,newValue,capture)}}}else{const isComplex=isComplexType(newValue);if((isProp||isComplex&&newValue!==null)&&!isSvg){try{if(!elm.tagName.includes("-")){const n=newValue==null?"":newValue;if(memberName==="list"){isProp=false}else if(oldValue==null||elm[memberName]!=n){elm[memberName]=n}}else{elm[memberName]=newValue}}catch(e){}}let xlink=false;{if(ln!==(ln=ln.replace(/^xlink\:?/,""))){memberName=ln;xlink=true}}if(newValue==null||newValue===false){if(newValue!==false||elm.getAttribute(memberName)===""){if(xlink){elm.removeAttributeNS(XLINK_NS,memberName)}else{elm.removeAttribute(memberName)}}}else if((!isProp||flags&4||isSvg)&&!isComplex){newValue=newValue===true?"":newValue;if(xlink){elm.setAttributeNS(XLINK_NS,memberName,newValue)}else{elm.setAttribute(memberName,newValue)}}}}};const parseClassListRegex=/\s/;const parseClassList=value=>!value?[]:value.split(parseClassListRegex);const CAPTURE_EVENT_SUFFIX="Capture";const CAPTURE_EVENT_REGEX=new RegExp(CAPTURE_EVENT_SUFFIX+"$");const updateElement=(oldVnode,newVnode,isSvgMode,memberName)=>{const elm=newVnode.$elm$.nodeType===11&&newVnode.$elm$.host?newVnode.$elm$.host:newVnode.$elm$;const oldVnodeAttrs=oldVnode&&oldVnode.$attrs$||EMPTY_OBJ;const newVnodeAttrs=newVnode.$attrs$||EMPTY_OBJ;{for(memberName in oldVnodeAttrs){if(!(memberName in newVnodeAttrs)){setAccessor(elm,memberName,oldVnodeAttrs[memberName],undefined,isSvgMode,newVnode.$flags$)}}}for(memberName in newVnodeAttrs){setAccessor(elm,memberName,oldVnodeAttrs[memberName],newVnodeAttrs[memberName],isSvgMode,newVnode.$flags$)}};const createElm=(oldParentVNode,newParentVNode,childIndex,parentElm)=>{var _a;const newVNode=newParentVNode.$children$[childIndex];let i=0;let elm;let childNode;let oldVNode;if(!useNativeShadowDom){checkSlotRelocate=true;if(newVNode.$tag$==="slot"){if(scopeId){parentElm.classList.add(scopeId+"-s")}newVNode.$flags$|=newVNode.$children$?2:1}}if(newVNode.$text$!==null){elm=newVNode.$elm$=doc.createTextNode(newVNode.$text$)}else if(newVNode.$flags$&1){elm=newVNode.$elm$=doc.createTextNode("")}else{if(!isSvgMode){isSvgMode=newVNode.$tag$==="svg"}elm=newVNode.$elm$=doc.createElementNS(isSvgMode?SVG_NS:HTML_NS,newVNode.$flags$&2?"slot-fb":newVNode.$tag$);if(isSvgMode&&newVNode.$tag$==="foreignObject"){isSvgMode=false}{updateElement(null,newVNode,isSvgMode)}if(isDef(scopeId)&&elm["s-si"]!==scopeId){elm.classList.add(elm["s-si"]=scopeId)}if(newVNode.$children$){for(i=0;i<newVNode.$children$.length;++i){childNode=createElm(oldParentVNode,newVNode,i,elm);if(childNode){elm.appendChild(childNode)}}}{if(newVNode.$tag$==="svg"){isSvgMode=false}else if(elm.tagName==="foreignObject"){isSvgMode=true}}}{elm["s-hn"]=hostTagName;if(newVNode.$flags$&(2|1)){elm["s-sr"]=true;elm["s-fs"]=(_a=newVNode.$attrs$)===null||_a===void 0?void 0:_a.slot;elm["s-cr"]=contentRef;elm["s-sn"]=newVNode.$name$||"";oldVNode=oldParentVNode&&oldParentVNode.$children$&&oldParentVNode.$children$[childIndex];if(oldVNode&&oldVNode.$tag$===newVNode.$tag$&&oldParentVNode.$elm$){putBackInOriginalLocation(oldParentVNode.$elm$,false)}}}return elm};const putBackInOriginalLocation=(parentElm,recursive)=>{var _a;plt.$flags$|=1;const oldSlotChildNodes=parentElm.childNodes;for(let i=oldSlotChildNodes.length-1;i>=0;i--){const childNode=oldSlotChildNodes[i];if(childNode["s-hn"]!==hostTagName&&childNode["s-ol"]){parentReferenceNode(childNode).insertBefore(childNode,referenceNode(childNode));childNode["s-ol"].remove();childNode["s-ol"]=undefined;childNode["s-sh"]=undefined;if(childNode.nodeType===1){childNode.setAttribute("slot",(_a=childNode["s-sn"])!==null&&_a!==void 0?_a:"")}checkSlotRelocate=true}if(recursive){putBackInOriginalLocation(childNode,recursive)}}plt.$flags$&=~1};const addVnodes=(parentElm,before,parentVNode,vnodes,startIdx,endIdx)=>{let containerElm=parentElm["s-cr"]&&parentElm["s-cr"].parentNode||parentElm;let childNode;if(containerElm.shadowRoot&&containerElm.tagName===hostTagName){containerElm=containerElm.shadowRoot}for(;startIdx<=endIdx;++startIdx){if(vnodes[startIdx]){childNode=createElm(null,parentVNode,startIdx,parentElm);if(childNode){vnodes[startIdx].$elm$=childNode;containerElm.insertBefore(childNode,referenceNode(before))}}}};const removeVnodes=(vnodes,startIdx,endIdx)=>{for(let index=startIdx;index<=endIdx;++index){const vnode=vnodes[index];if(vnode){const elm=vnode.$elm$;nullifyVNodeRefs(vnode);if(elm){{checkSlotFallbackVisibility=true;if(elm["s-ol"]){elm["s-ol"].remove()}else{putBackInOriginalLocation(elm,true)}}elm.remove()}}}};const updateChildren=(parentElm,oldCh,newVNode,newCh)=>{let oldStartIdx=0;let newStartIdx=0;let idxInOld=0;let i=0;let oldEndIdx=oldCh.length-1;let oldStartVnode=oldCh[0];let oldEndVnode=oldCh[oldEndIdx];let newEndIdx=newCh.length-1;let newStartVnode=newCh[0];let newEndVnode=newCh[newEndIdx];let node;let elmToMove;while(oldStartIdx<=oldEndIdx&&newStartIdx<=newEndIdx){if(oldStartVnode==null){oldStartVnode=oldCh[++oldStartIdx]}else if(oldEndVnode==null){oldEndVnode=oldCh[--oldEndIdx]}else if(newStartVnode==null){newStartVnode=newCh[++newStartIdx]}else if(newEndVnode==null){newEndVnode=newCh[--newEndIdx]}else if(isSameVnode(oldStartVnode,newStartVnode)){patch(oldStartVnode,newStartVnode);oldStartVnode=oldCh[++oldStartIdx];newStartVnode=newCh[++newStartIdx]}else if(isSameVnode(oldEndVnode,newEndVnode)){patch(oldEndVnode,newEndVnode);oldEndVnode=oldCh[--oldEndIdx];newEndVnode=newCh[--newEndIdx]}else if(isSameVnode(oldStartVnode,newEndVnode)){if(oldStartVnode.$tag$==="slot"||newEndVnode.$tag$==="slot"){putBackInOriginalLocation(oldStartVnode.$elm$.parentNode,false)}patch(oldStartVnode,newEndVnode);parentElm.insertBefore(oldStartVnode.$elm$,oldEndVnode.$elm$.nextSibling);oldStartVnode=oldCh[++oldStartIdx];newEndVnode=newCh[--newEndIdx]}else if(isSameVnode(oldEndVnode,newStartVnode)){if(oldStartVnode.$tag$==="slot"||newEndVnode.$tag$==="slot"){putBackInOriginalLocation(oldEndVnode.$elm$.parentNode,false)}patch(oldEndVnode,newStartVnode);parentElm.insertBefore(oldEndVnode.$elm$,oldStartVnode.$elm$);oldEndVnode=oldCh[--oldEndIdx];newStartVnode=newCh[++newStartIdx]}else{idxInOld=-1;{for(i=oldStartIdx;i<=oldEndIdx;++i){if(oldCh[i]&&oldCh[i].$key$!==null&&oldCh[i].$key$===newStartVnode.$key$){idxInOld=i;break}}}if(idxInOld>=0){elmToMove=oldCh[idxInOld];if(elmToMove.$tag$!==newStartVnode.$tag$){node=createElm(oldCh&&oldCh[newStartIdx],newVNode,idxInOld,parentElm)}else{patch(elmToMove,newStartVnode);oldCh[idxInOld]=undefined;node=elmToMove.$elm$}newStartVnode=newCh[++newStartIdx]}else{node=createElm(oldCh&&oldCh[newStartIdx],newVNode,newStartIdx,parentElm);newStartVnode=newCh[++newStartIdx]}if(node){{parentReferenceNode(oldStartVnode.$elm$).insertBefore(node,referenceNode(oldStartVnode.$elm$))}}}}if(oldStartIdx>oldEndIdx){addVnodes(parentElm,newCh[newEndIdx+1]==null?null:newCh[newEndIdx+1].$elm$,newVNode,newCh,newStartIdx,newEndIdx)}else if(newStartIdx>newEndIdx){removeVnodes(oldCh,oldStartIdx,oldEndIdx)}};const isSameVnode=(leftVNode,rightVNode)=>{if(leftVNode.$tag$===rightVNode.$tag$){if(leftVNode.$tag$==="slot"){return leftVNode.$name$===rightVNode.$name$}{return leftVNode.$key$===rightVNode.$key$}}return false};const referenceNode=node=>node&&node["s-ol"]||node;const parentReferenceNode=node=>(node["s-ol"]?node["s-ol"]:node).parentNode;const patch=(oldVNode,newVNode)=>{const elm=newVNode.$elm$=oldVNode.$elm$;const oldChildren=oldVNode.$children$;const newChildren=newVNode.$children$;const tag=newVNode.$tag$;const text=newVNode.$text$;let defaultHolder;if(text===null){{isSvgMode=tag==="svg"?true:tag==="foreignObject"?false:isSvgMode}{if(tag==="slot");else{updateElement(oldVNode,newVNode,isSvgMode)}}if(oldChildren!==null&&newChildren!==null){updateChildren(elm,oldChildren,newVNode,newChildren)}else if(newChildren!==null){if(oldVNode.$text$!==null){elm.textContent=""}addVnodes(elm,null,newVNode,newChildren,0,newChildren.length-1)}else if(oldChildren!==null){removeVnodes(oldChildren,0,oldChildren.length-1)}if(isSvgMode&&tag==="svg"){isSvgMode=false}}else if(defaultHolder=elm["s-cr"]){defaultHolder.parentNode.textContent=text}else if(oldVNode.$text$!==text){elm.data=text}};const updateFallbackSlotVisibility=elm=>{const childNodes=elm.childNodes;for(const childNode of childNodes){if(childNode.nodeType===1){if(childNode["s-sr"]){const slotName=childNode["s-sn"];childNode.hidden=false;for(const siblingNode of childNodes){if(siblingNode!==childNode){if(siblingNode["s-hn"]!==childNode["s-hn"]||slotName!==""){if(siblingNode.nodeType===1&&(slotName===siblingNode.getAttribute("slot")||slotName===siblingNode["s-sn"])){childNode.hidden=true;break}}else{if(siblingNode.nodeType===1||siblingNode.nodeType===3&&siblingNode.textContent.trim()!==""){childNode.hidden=true;break}}}}}updateFallbackSlotVisibility(childNode)}}};const relocateNodes=[];const markSlotContentForRelocation=elm=>{let node;let hostContentNodes;let j;for(const childNode of elm.childNodes){if(childNode["s-sr"]&&(node=childNode["s-cr"])&&node.parentNode){hostContentNodes=node.parentNode.childNodes;const slotName=childNode["s-sn"];for(j=hostContentNodes.length-1;j>=0;j--){node=hostContentNodes[j];if(!node["s-cn"]&&!node["s-nr"]&&node["s-hn"]!==childNode["s-hn"]&&!BUILD.experimentalSlotFixes){if(isNodeLocatedInSlot(node,slotName)){let relocateNodeData=relocateNodes.find((r=>r.$nodeToRelocate$===node));checkSlotFallbackVisibility=true;node["s-sn"]=node["s-sn"]||slotName;if(relocateNodeData){relocateNodeData.$nodeToRelocate$["s-sh"]=childNode["s-hn"];relocateNodeData.$slotRefNode$=childNode}else{node["s-sh"]=childNode["s-hn"];relocateNodes.push({$slotRefNode$:childNode,$nodeToRelocate$:node})}if(node["s-sr"]){relocateNodes.map((relocateNode=>{if(isNodeLocatedInSlot(relocateNode.$nodeToRelocate$,node["s-sn"])){relocateNodeData=relocateNodes.find((r=>r.$nodeToRelocate$===node));if(relocateNodeData&&!relocateNode.$slotRefNode$){relocateNode.$slotRefNode$=relocateNodeData.$slotRefNode$}}}))}}else if(!relocateNodes.some((r=>r.$nodeToRelocate$===node))){relocateNodes.push({$nodeToRelocate$:node})}}}}if(childNode.nodeType===1){markSlotContentForRelocation(childNode)}}};const isNodeLocatedInSlot=(nodeToRelocate,slotName)=>{if(nodeToRelocate.nodeType===1){if(nodeToRelocate.getAttribute("slot")===null&&slotName===""){return true}if(nodeToRelocate.getAttribute("slot")===slotName){return true}return false}if(nodeToRelocate["s-sn"]===slotName){return true}return slotName===""};const nullifyVNodeRefs=vNode=>{{vNode.$attrs$&&vNode.$attrs$.ref&&vNode.$attrs$.ref(null);vNode.$children$&&vNode.$children$.map(nullifyVNodeRefs)}};const renderVdom=(hostRef,renderFnResults,isInitialLoad=false)=>{var _a,_b;const hostElm=hostRef.$hostElement$;const cmpMeta=hostRef.$cmpMeta$;const oldVNode=hostRef.$vnode$||newVNode(null,null);const rootVnode=isHost(renderFnResults)?renderFnResults:h(null,null,renderFnResults);hostTagName=hostElm.tagName;if(cmpMeta.$attrsToReflect$){rootVnode.$attrs$=rootVnode.$attrs$||{};cmpMeta.$attrsToReflect$.map((([propName,attribute])=>rootVnode.$attrs$[attribute]=hostElm[propName]))}if(isInitialLoad&&rootVnode.$attrs$){for(const key of Object.keys(rootVnode.$attrs$)){if(hostElm.hasAttribute(key)&&!["key","ref","style","class"].includes(key)){rootVnode.$attrs$[key]=hostElm[key]}}}rootVnode.$tag$=null;rootVnode.$flags$|=4;hostRef.$vnode$=rootVnode;rootVnode.$elm$=oldVNode.$elm$=hostElm.shadowRoot||hostElm;{scopeId=hostElm["s-sc"]}{contentRef=hostElm["s-cr"];useNativeShadowDom=supportsShadow&&(cmpMeta.$flags$&1)!==0;checkSlotFallbackVisibility=false}patch(oldVNode,rootVnode);{plt.$flags$|=1;if(checkSlotRelocate){markSlotContentForRelocation(rootVnode.$elm$);for(const relocateData of relocateNodes){const nodeToRelocate=relocateData.$nodeToRelocate$;if(!nodeToRelocate["s-ol"]){const orgLocationNode=doc.createTextNode("");orgLocationNode["s-nr"]=nodeToRelocate;nodeToRelocate.parentNode.insertBefore(nodeToRelocate["s-ol"]=orgLocationNode,nodeToRelocate)}}for(const relocateData of relocateNodes){const nodeToRelocate=relocateData.$nodeToRelocate$;const slotRefNode=relocateData.$slotRefNode$;if(slotRefNode){const parentNodeRef=slotRefNode.parentNode;let insertBeforeNode=slotRefNode.nextSibling;{let orgLocationNode=(_a=nodeToRelocate["s-ol"])===null||_a===void 0?void 0:_a.previousSibling;while(orgLocationNode){let refNode=(_b=orgLocationNode["s-nr"])!==null&&_b!==void 0?_b:null;if(refNode&&refNode["s-sn"]===nodeToRelocate["s-sn"]&&parentNodeRef===refNode.parentNode){refNode=refNode.nextSibling;if(!refNode||!refNode["s-nr"]){insertBeforeNode=refNode;break}}orgLocationNode=orgLocationNode.previousSibling}}if(!insertBeforeNode&&parentNodeRef!==nodeToRelocate.parentNode||nodeToRelocate.nextSibling!==insertBeforeNode){if(nodeToRelocate!==insertBeforeNode){if(!nodeToRelocate["s-hn"]&&nodeToRelocate["s-ol"]){nodeToRelocate["s-hn"]=nodeToRelocate["s-ol"].parentNode.nodeName}parentNodeRef.insertBefore(nodeToRelocate,insertBeforeNode)}}}else{if(nodeToRelocate.nodeType===1){nodeToRelocate.hidden=true}}}}if(checkSlotFallbackVisibility){updateFallbackSlotVisibility(rootVnode.$elm$)}plt.$flags$&=~1;relocateNodes.length=0}};const attachToAncestor=(hostRef,ancestorComponent)=>{};const scheduleUpdate=(hostRef,isInitialLoad)=>{{hostRef.$flags$|=16}attachToAncestor(hostRef,hostRef.$ancestorComponent$);const dispatch=()=>dispatchHooks(hostRef,isInitialLoad);return writeTask(dispatch)};const dispatchHooks=(hostRef,isInitialLoad)=>{const elm=hostRef.$hostElement$;const endSchedule=createTime("scheduleUpdate",hostRef.$cmpMeta$.$tagName$);const instance=elm;let maybePromise;if(isInitialLoad){{maybePromise=safeCall(instance,"componentWillLoad")}}else{{maybePromise=safeCall(instance,"componentWillUpdate")}}{maybePromise=enqueue(maybePromise,(()=>safeCall(instance,"componentWillRender")))}endSchedule();return enqueue(maybePromise,(()=>updateComponent(hostRef,instance,isInitialLoad)))};const enqueue=(maybePromise,fn)=>isPromisey(maybePromise)?maybePromise.then(fn):fn();const isPromisey=maybePromise=>maybePromise instanceof Promise||maybePromise&&maybePromise.then&&typeof maybePromise.then==="function";const updateComponent=async(hostRef,instance,isInitialLoad)=>{const elm=hostRef.$hostElement$;const endUpdate=createTime("update",hostRef.$cmpMeta$.$tagName$);elm["s-rc"];if(isInitialLoad){attachStyles(hostRef)}const endRender=createTime("render",hostRef.$cmpMeta$.$tagName$);{callRender(hostRef,instance,elm,isInitialLoad)}endRender();endUpdate();{postUpdateComponent(hostRef)}};const callRender=(hostRef,instance,elm,isInitialLoad)=>{const allRenderFn=false;const lazyLoad=false;const taskQueue=true;const updatable=true;try{renderingRef=instance;instance=allRenderFn?instance.render():instance.render&&instance.render();if(updatable&&taskQueue){hostRef.$flags$&=~16}if(updatable||lazyLoad){hostRef.$flags$|=2}if(BUILD.hasRenderFn||BUILD.reflect){if(BUILD.vdomRender||BUILD.reflect){if(BUILD.hydrateServerSide);else{renderVdom(hostRef,instance,isInitialLoad)}}}}catch(e){consoleError(e,hostRef.$hostElement$)}renderingRef=null;return null};const postUpdateComponent=hostRef=>{const tagName=hostRef.$cmpMeta$.$tagName$;const elm=hostRef.$hostElement$;const endPostUpdate=createTime("postUpdate",tagName);const instance=elm;hostRef.$ancestorComponent$;{safeCall(instance,"componentDidRender")}if(!(hostRef.$flags$&64)){hostRef.$flags$|=64;{safeCall(instance,"componentDidLoad")}endPostUpdate()}else{{safeCall(instance,"componentDidUpdate")}endPostUpdate()}};const safeCall=(instance,method,arg)=>{if(instance&&instance[method]){try{return instance[method](arg)}catch(e){consoleError(e)}}return undefined};const getValue=(ref,propName)=>getHostRef(ref).$instanceValues$.get(propName);const setValue=(ref,propName,newVal,cmpMeta)=>{const hostRef=getHostRef(ref);const elm=ref;const oldVal=hostRef.$instanceValues$.get(propName);const flags=hostRef.$flags$;const instance=elm;newVal=parsePropertyValue(newVal,cmpMeta.$members$[propName][0]);const areBothNaN=Number.isNaN(oldVal)&&Number.isNaN(newVal);const didValueChange=newVal!==oldVal&&!areBothNaN;if(didValueChange){hostRef.$instanceValues$.set(propName,newVal);{if(cmpMeta.$watchers$&&flags&128){const watchMethods=cmpMeta.$watchers$[propName];if(watchMethods){watchMethods.map((watchMethodName=>{try{instance[watchMethodName](newVal,oldVal,propName)}catch(e){consoleError(e,elm)}}))}}if((flags&(2|16))===2){if(instance.componentShouldUpdate){if(instance.componentShouldUpdate(newVal,oldVal,propName)===false){return}}scheduleUpdate(hostRef,false)}}}};const proxyComponent=(Cstr,cmpMeta,flags)=>{var _a;const prototype=Cstr.prototype;if(cmpMeta.$members$){if(Cstr.watchers){cmpMeta.$watchers$=Cstr.watchers}const members=Object.entries(cmpMeta.$members$);members.map((([memberName,[memberFlags]])=>{if(memberFlags&31||memberFlags&32){Object.defineProperty(prototype,memberName,{get(){return getValue(this,memberName)},set(newValue){setValue(this,memberName,newValue,cmpMeta)},configurable:true,enumerable:true})}}));{const attrNameToPropName=new Map;prototype.attributeChangedCallback=function(attrName,oldValue,newValue){plt.jmp((()=>{var _a;const propName=attrNameToPropName.get(attrName);if(this.hasOwnProperty(propName)){newValue=this[propName];delete this[propName]}else if(prototype.hasOwnProperty(propName)&&typeof this[propName]==="number"&&this[propName]==newValue){return}else if(propName==null){const hostRef=getHostRef(this);const flags=hostRef===null||hostRef===void 0?void 0:hostRef.$flags$;if(flags&&!(flags&8)&&flags&128&&newValue!==oldValue){const elm=this;const instance=elm;const entry=(_a=cmpMeta.$watchers$)===null||_a===void 0?void 0:_a[attrName];entry===null||entry===void 0?void 0:entry.forEach((callbackName=>{if(instance[callbackName]!=null){instance[callbackName].call(instance,newValue,oldValue,attrName)}}))}return}this[propName]=newValue===null&&typeof this[propName]==="boolean"?false:newValue}))};Cstr.observedAttributes=Array.from(new Set([...Object.keys((_a=cmpMeta.$watchers$)!==null&&_a!==void 0?_a:{}),...members.filter((([_,m])=>m[0]&15)).map((([propName,m])=>{var _a;const attrName=m[1]||propName;attrNameToPropName.set(attrName,propName);if(m[0]&512){(_a=cmpMeta.$attrsToReflect$)===null||_a===void 0?void 0:_a.push([propName,attrName])}return attrName}))]))}}return Cstr};const initializeComponent=async(elm,hostRef,cmpMeta,hmrVersionId)=>{let Cstr;if((hostRef.$flags$&32)===0){hostRef.$flags$|=32;{Cstr=elm.constructor;customElements.whenDefined(cmpMeta.$tagName$).then((()=>hostRef.$flags$|=128))}if(Cstr.style){let style=Cstr.style;if(typeof style!=="string"){style=style[hostRef.$modeName$=computeMode(elm)]}const scopeId=getScopeId(cmpMeta,hostRef.$modeName$);if(!styles.has(scopeId)){const endRegisterStyles=createTime("registerStyles",cmpMeta.$tagName$);registerStyle(scopeId,style,!!(cmpMeta.$flags$&1));endRegisterStyles()}}}hostRef.$ancestorComponent$;const schedule=()=>scheduleUpdate(hostRef,true);{schedule()}};const fireConnectedCallback=instance=>{};const connectedCallback=elm=>{if((plt.$flags$&1)===0){const hostRef=getHostRef(elm);const cmpMeta=hostRef.$cmpMeta$;const endConnected=createTime("connectedCallback",cmpMeta.$tagName$);if(!(hostRef.$flags$&1)){hostRef.$flags$|=1;{if(cmpMeta.$flags$&(4|8)){setContentReference(elm)}}if(cmpMeta.$members$){Object.entries(cmpMeta.$members$).map((([memberName,[memberFlags]])=>{if(memberFlags&31&&elm.hasOwnProperty(memberName)){const value=elm[memberName];delete elm[memberName];elm[memberName]=value}}))}{initializeComponent(elm,hostRef,cmpMeta)}}else{addHostEventListeners(elm,hostRef,cmpMeta.$listeners$);if(hostRef===null||hostRef===void 0?void 0:hostRef.$lazyInstance$){fireConnectedCallback(hostRef.$lazyInstance$)}else if(hostRef===null||hostRef===void 0?void 0:hostRef.$onReadyPromise$){hostRef.$onReadyPromise$.then((()=>fireConnectedCallback(hostRef.$lazyInstance$)))}}endConnected()}};const setContentReference=elm=>{const contentRefElm=elm["s-cr"]=doc.createComment("");contentRefElm["s-cn"]=true;elm.insertBefore(contentRefElm,elm.firstChild)};const disconnectedCallback=async elm=>{if((plt.$flags$&1)===0){const hostRef=getHostRef(elm);{if(hostRef.$rmListeners$){hostRef.$rmListeners$.map((rmListener=>rmListener()));hostRef.$rmListeners$=undefined}}}};const patchPseudoShadowDom=(hostElementPrototype,descriptorPrototype)=>{patchCloneNode(hostElementPrototype);patchSlotAppendChild(hostElementPrototype);patchSlotAppend(hostElementPrototype);patchSlotPrepend(hostElementPrototype);patchSlotInsertAdjacentElement(hostElementPrototype);patchSlotInsertAdjacentHTML(hostElementPrototype);patchSlotInsertAdjacentText(hostElementPrototype);patchTextContent(hostElementPrototype,descriptorPrototype);patchChildSlotNodes(hostElementPrototype,descriptorPrototype)};const patchCloneNode=HostElementPrototype=>{const orgCloneNode=HostElementPrototype.cloneNode;HostElementPrototype.cloneNode=function(deep){const srcNode=this;const isShadowDom=srcNode.shadowRoot&&supportsShadow;const clonedNode=orgCloneNode.call(srcNode,isShadowDom?deep:false);if(!isShadowDom&&deep){let i=0;let slotted,nonStencilNode;const stencilPrivates=["s-id","s-cr","s-lr","s-rc","s-sc","s-p","s-cn","s-sr","s-sn","s-hn","s-ol","s-nr","s-si"];for(;i<srcNode.childNodes.length;i++){slotted=srcNode.childNodes[i]["s-nr"];nonStencilNode=stencilPrivates.every((privateField=>!srcNode.childNodes[i][privateField]));if(slotted){{clonedNode.appendChild(slotted.cloneNode(true))}}if(nonStencilNode){clonedNode.appendChild(srcNode.childNodes[i].cloneNode(true))}}}return clonedNode}};const patchSlotAppendChild=HostElementPrototype=>{HostElementPrototype.__appendChild=HostElementPrototype.appendChild;HostElementPrototype.appendChild=function(newChild){const slotName=newChild["s-sn"]=getSlotName(newChild);const slotNode=getHostSlotNode(this.childNodes,slotName);if(slotNode){const slotChildNodes=getHostSlotChildNodes(slotNode,slotName);const appendAfter=slotChildNodes[slotChildNodes.length-1];return appendAfter.parentNode.insertBefore(newChild,appendAfter.nextSibling)}return this.__appendChild(newChild)}};const patchSlotPrepend=HostElementPrototype=>{const originalPrepend=HostElementPrototype.prepend;HostElementPrototype.prepend=function(...newChildren){newChildren.forEach((newChild=>{if(typeof newChild==="string"){newChild=this.ownerDocument.createTextNode(newChild)}const slotName=newChild["s-sn"]=getSlotName(newChild);const slotNode=getHostSlotNode(this.childNodes,slotName);if(slotNode){const slotPlaceholder=document.createTextNode("");slotPlaceholder["s-nr"]=newChild;slotNode["s-cr"].parentNode.__appendChild(slotPlaceholder);newChild["s-ol"]=slotPlaceholder;const slotChildNodes=getHostSlotChildNodes(slotNode,slotName);const appendAfter=slotChildNodes[0];return appendAfter.parentNode.insertBefore(newChild,appendAfter.nextSibling)}if(newChild.nodeType===1&&!!newChild.getAttribute("slot")){newChild.hidden=true}return originalPrepend.call(this,newChild)}))}};const patchSlotAppend=HostElementPrototype=>{HostElementPrototype.append=function(...newChildren){newChildren.forEach((newChild=>{if(typeof newChild==="string"){newChild=this.ownerDocument.createTextNode(newChild)}this.appendChild(newChild)}))}};const patchSlotInsertAdjacentHTML=HostElementPrototype=>{const originalInsertAdjacentHtml=HostElementPrototype.insertAdjacentHTML;HostElementPrototype.insertAdjacentHTML=function(position,text){if(position!=="afterbegin"&&position!=="beforeend"){return originalInsertAdjacentHtml.call(this,position,text)}const container=this.ownerDocument.createElement("_");let node;container.innerHTML=text;if(position==="afterbegin"){while(node=container.firstChild){this.prepend(node)}}else if(position==="beforeend"){while(node=container.firstChild){this.append(node)}}}};const patchSlotInsertAdjacentText=HostElementPrototype=>{HostElementPrototype.insertAdjacentText=function(position,text){this.insertAdjacentHTML(position,text)}};const patchSlotInsertAdjacentElement=HostElementPrototype=>{const originalInsertAdjacentElement=HostElementPrototype.insertAdjacentElement;HostElementPrototype.insertAdjacentElement=function(position,element){if(position!=="afterbegin"&&position!=="beforeend"){return originalInsertAdjacentElement.call(this,position,element)}if(position==="afterbegin"){this.prepend(element);return element}else if(position==="beforeend"){this.append(element);return element}return element}};const patchTextContent=(hostElementPrototype,cmpMeta)=>{if(cmpMeta.$flags$&2){const descriptor=Object.getOwnPropertyDescriptor(Node.prototype,"textContent");Object.defineProperty(hostElementPrototype,"__textContent",descriptor);Object.defineProperty(hostElementPrototype,"textContent",{get(){var _a;const slotNode=getHostSlotNode(this.childNodes,"");if(((_a=slotNode===null||slotNode===void 0?void 0:slotNode.nextSibling)===null||_a===void 0?void 0:_a.nodeType)===3){return slotNode.nextSibling.textContent}else if(slotNode){return slotNode.textContent}else{return this.__textContent}},set(value){var _a;const slotNode=getHostSlotNode(this.childNodes,"");if(((_a=slotNode===null||slotNode===void 0?void 0:slotNode.nextSibling)===null||_a===void 0?void 0:_a.nodeType)===3){slotNode.nextSibling.textContent=value}else if(slotNode){slotNode.textContent=value}else{this.__textContent=value;const contentRefElm=this["s-cr"];if(contentRefElm){this.insertBefore(contentRefElm,this.firstChild)}}}})}};const patchChildSlotNodes=(elm,cmpMeta)=>{class FakeNodeList extends Array{item(n){return this[n]}}if(cmpMeta.$flags$&8){const childNodesFn=elm.__lookupGetter__("childNodes");Object.defineProperty(elm,"children",{get(){return this.childNodes.map((n=>n.nodeType===1))}});Object.defineProperty(elm,"childElementCount",{get(){return elm.children.length}});Object.defineProperty(elm,"childNodes",{get(){const childNodes=childNodesFn.call(this);if((plt.$flags$&1)===0&&getHostRef(this).$flags$&2){const result=new FakeNodeList;for(let i=0;i<childNodes.length;i++){const slot=childNodes[i]["s-nr"];if(slot){result.push(slot)}}return result}return FakeNodeList.from(childNodes)}})}};const getSlotName=node=>node["s-sn"]||node.nodeType===1&&node.getAttribute("slot")||"";const getHostSlotNode=(childNodes,slotName)=>{let i=0;let childNode;for(;i<childNodes.length;i++){childNode=childNodes[i];if(childNode["s-sr"]&&childNode["s-sn"]===slotName){return childNode}childNode=getHostSlotNode(childNode.childNodes,slotName);if(childNode){return childNode}}return null};const getHostSlotChildNodes=(n,slotName)=>{const childNodes=[n];while((n=n.nextSibling)&&n["s-sn"]===slotName){childNodes.push(n)}return childNodes};const proxyCustomElement=(Cstr,compactMeta)=>{const cmpMeta={$flags$:compactMeta[0],$tagName$:compactMeta[1]};if(BUILD.member){cmpMeta.$members$=compactMeta[2]}if(BUILD.hostListener){cmpMeta.$listeners$=compactMeta[3]}if(BUILD.watchCallback){cmpMeta.$watchers$=Cstr.$watchers$}if(BUILD.reflect){cmpMeta.$attrsToReflect$=[]}if(BUILD.shadowDom&&!supportsShadow&&cmpMeta.$flags$&1){cmpMeta.$flags$|=8}if(BUILD.experimentalSlotFixes&&BUILD.scoped){patchPseudoShadowDom(Cstr.prototype,cmpMeta)}else{if(BUILD.slotChildNodesFix){patchChildSlotNodes(Cstr.prototype,cmpMeta)}if(BUILD.cloneNodeFix){patchCloneNode(Cstr.prototype)}if(BUILD.appendChildSlotFix){patchSlotAppendChild(Cstr.prototype)}if(BUILD.scopedSlotTextContentFix){patchTextContent(Cstr.prototype,cmpMeta)}}const originalConnectedCallback=Cstr.prototype.connectedCallback;const originalDisconnectedCallback=Cstr.prototype.disconnectedCallback;Object.assign(Cstr.prototype,{__registerHost(){registerHost(this,cmpMeta)},connectedCallback(){connectedCallback(this);if(BUILD.connectedCallback&&originalConnectedCallback){originalConnectedCallback.call(this)}},disconnectedCallback(){disconnectedCallback(this);if(BUILD.disconnectedCallback&&originalDisconnectedCallback){originalDisconnectedCallback.call(this)}},__attachShadow(){if(supportsShadow){if(BUILD.shadowDelegatesFocus){this.attachShadow({mode:"open",delegatesFocus:!!(cmpMeta.$flags$&16)})}else{this.attachShadow({mode:"open"})}}else{this.shadowRoot=this}}});Cstr.is=cmpMeta.$tagName$;return proxyComponent(Cstr,cmpMeta)};const Fragment=(_,children)=>children;const addHostEventListeners=(elm,hostRef,listeners,attachParentListeners)=>{if(listeners){listeners.map((([flags,name,method])=>{const target=getHostListenerTarget(elm,flags);const handler=hostListenerProxy(hostRef,method);const opts=hostListenerOpts(flags);plt.ael(target,name,handler,opts);(hostRef.$rmListeners$=hostRef.$rmListeners$||[]).push((()=>plt.rel(target,name,handler,opts)))}))}};const hostListenerProxy=(hostRef,methodName)=>ev=>{try{if(BUILD.lazyLoad);else{hostRef.$hostElement$[methodName](ev)}}catch(e){consoleError(e)}};const getHostListenerTarget=(elm,flags)=>{if(flags&4)return doc;if(flags&8)return win;if(flags&16)return doc.body;return elm};const hostListenerOpts=flags=>supportsListenerOptions?{passive:(flags&1)!==0,capture:(flags&2)!==0}:(flags&2)!==0;const setNonce=nonce=>plt.$nonce$=nonce;const setPlatformOptions=opts=>Object.assign(plt,opts);const hostRefs=new WeakMap;const getHostRef=ref=>hostRefs.get(ref);const registerHost=(hostElement,cmpMeta)=>{const hostRef={$flags$:0,$hostElement$:hostElement,$cmpMeta$:cmpMeta,$instanceValues$:new Map};if(BUILD.isDev){hostRef.$renderCount$=0}if(BUILD.method&&BUILD.lazyLoad){hostRef.$onInstancePromise$=new Promise((r=>hostRef.$onInstanceResolve$=r))}if(BUILD.asyncLoading){hostRef.$onReadyPromise$=new Promise((r=>hostRef.$onReadyResolve$=r));hostElement["s-p"]=[];hostElement["s-rc"]=[]}addHostEventListeners(hostElement,hostRef,cmpMeta.$listeners$);return hostRefs.set(hostElement,hostRef)};const isMemberInElement=(elm,memberName)=>memberName in elm;const consoleError=(e,el)=>(0,console.error)(e,el);const STENCIL_DEV_MODE=BUILD.isTesting?["STENCIL:"]:["%cstencil","color: white;background:#4c47ff;font-weight: bold; font-size:10px; padding:2px 6px; border-radius: 5px"];const consoleDevError=(...m)=>console.error(...STENCIL_DEV_MODE,...m);const consoleDevWarn=(...m)=>console.warn(...STENCIL_DEV_MODE,...m);const styles=new Map;const modeResolutionChain=[];const win=typeof window!=="undefined"?window:{};const doc=win.document||{head:{}};const H=win.HTMLElement||class{};const plt={$flags$:0,$resourcesUrl$:"",jmp:h=>h(),raf:h=>requestAnimationFrame(h),ael:(el,eventName,listener,opts)=>el.addEventListener(eventName,listener,opts),rel:(el,eventName,listener,opts)=>el.removeEventListener(eventName,listener,opts),ce:(eventName,opts)=>new CustomEvent(eventName,opts)};const supportsShadow=BUILD.shadowDomShim&&BUILD.shadowDom?(()=>(doc.head.attachShadow+"").indexOf("[native")>-1)():true;const supportsListenerOptions=(()=>{let supportsListenerOptions=false;try{doc.addEventListener("e",null,Object.defineProperty({},"passive",{get(){supportsListenerOptions=true}}))}catch(e){}return supportsListenerOptions})();const promiseResolve=v=>Promise.resolve(v);const supportsConstructableStylesheets=BUILD.constructableCSS?(()=>{try{new CSSStyleSheet;return typeof(new CSSStyleSheet).replaceSync==="function"}catch(e){}return false})():false;const queueDomReads=[];const queueDomWrites=[];const queueTask=(queue,write)=>cb=>{queue.push(cb);if(!queuePending){queuePending=true;if(write&&plt.$flags$&4){nextTick(flush)}else{plt.raf(flush)}}};const consume=queue=>{for(let i=0;i<queue.length;i++){try{queue[i](performance.now())}catch(e){consoleError(e)}}queue.length=0};const flush=()=>{consume(queueDomReads);{consume(queueDomWrites);if(queuePending=queueDomReads.length>0){plt.raf(flush)}}};const nextTick=cb=>promiseResolve().then(cb);const writeTask=queueTask(queueDomWrites,true);exports.Fragment=Fragment;exports.H=H;exports.Host=Host;exports.createEvent=createEvent;exports.getAssetPath=getAssetPath;exports.h=h;exports.proxyCustomElement=proxyCustomElement;exports.setAssetPath=setAssetPath;exports.setNonce=setNonce;exports.setPlatformOptions=setPlatformOptions}));
