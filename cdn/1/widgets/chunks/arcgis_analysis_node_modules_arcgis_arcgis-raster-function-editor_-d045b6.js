"use strict";
(self["webpackChunkexb_client"] = self["webpackChunkexb_client"] || []).push([["vendors-extensions_widgets_arcgis_analysis_node_modules_arcgis_arcgis-raster-function-editor_-d045b6"],{

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/arcgis-raster-function-editor/dist/esm/common-strings.ro-db6b4694.js":
/*!**************************************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/arcgis-raster-function-editor/dist/esm/common-strings.ro-db6b4694.js ***!
  \**************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   addRaster: () => (/* binding */ addRaster),
/* harmony export */   addScalar: () => (/* binding */ addScalar),
/* harmony export */   breadcrumb: () => (/* binding */ breadcrumb),
/* harmony export */   breadcrumbEditor: () => (/* binding */ breadcrumbEditor),
/* harmony export */   cancel: () => (/* binding */ cancel),
/* harmony export */   category: () => (/* binding */ category),
/* harmony export */   categoryNames: () => (/* binding */ categoryNames),
/* harmony export */   close: () => (/* binding */ close),
/* harmony export */   copy: () => (/* binding */ copy),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   defaultModelName: () => (/* binding */ defaultModelName),
/* harmony export */   definitionQuery: () => (/* binding */ definitionQuery),
/* harmony export */   description: () => (/* binding */ description),
/* harmony export */   deselectFunction: () => (/* binding */ deselectFunction),
/* harmony export */   details: () => (/* binding */ details),
/* harmony export */   dialogTitle: () => (/* binding */ dialogTitle),
/* harmony export */   dontSave: () => (/* binding */ dontSave),
/* harmony export */   enterFURL: () => (/* binding */ enterFURL),
/* harmony export */   enterURL: () => (/* binding */ enterURL),
/* harmony export */   error: () => (/* binding */ error),
/* harmony export */   errorTitle: () => (/* binding */ errorTitle),
/* harmony export */   everyone: () => (/* binding */ everyone),
/* harmony export */   f32PixelType: () => (/* binding */ f32PixelType),
/* harmony export */   f64PixelType: () => (/* binding */ f64PixelType),
/* harmony export */   failedToLoadLayer: () => (/* binding */ failedToLoadLayer),
/* harmony export */   folder: () => (/* binding */ folder),
/* harmony export */   general: () => (/* binding */ general),
/* harmony export */   groupFieldName: () => (/* binding */ groupFieldName),
/* harmony export */   groupItemsBy: () => (/* binding */ groupItemsBy),
/* harmony export */   groups: () => (/* binding */ groups),
/* harmony export */   invalidRFTMessage: () => (/* binding */ invalidRFTMessage),
/* harmony export */   isDataset: () => (/* binding */ isDataset),
/* harmony export */   isPublic: () => (/* binding */ isPublic),
/* harmony export */   item: () => (/* binding */ item),
/* harmony export */   itemGroup: () => (/* binding */ itemGroup),
/* harmony export */   loadingLayer: () => (/* binding */ loadingLayer),
/* harmony export */   matchVariables: () => (/* binding */ matchVariables),
/* harmony export */   mosaic: () => (/* binding */ mosaic),
/* harmony export */   multidimensionalRules: () => (/* binding */ multidimensionalRules),
/* harmony export */   name: () => (/* binding */ name),
/* harmony export */   noTagErrorMsg: () => (/* binding */ noTagErrorMsg),
/* harmony export */   noTitleErrorMsg: () => (/* binding */ noTitleErrorMsg),
/* harmony export */   noTitleTagErrorMsg: () => (/* binding */ noTitleTagErrorMsg),
/* harmony export */   ok: () => (/* binding */ ok),
/* harmony export */   organization: () => (/* binding */ organization),
/* harmony export */   outputPixelType: () => (/* binding */ outputPixelType),
/* harmony export */   owner: () => (/* binding */ owner),
/* harmony export */   parameter: () => (/* binding */ parameter),
/* harmony export */   parameters: () => (/* binding */ parameters),
/* harmony export */   properties: () => (/* binding */ properties),
/* harmony export */   raster: () => (/* binding */ raster),
/* harmony export */   rasterFunctionEditor: () => (/* binding */ rasterFunctionEditor),
/* harmony export */   rasterFunctions: () => (/* binding */ rasterFunctions),
/* harmony export */   rfxLicenseInfo: () => (/* binding */ rfxLicenseInfo),
/* harmony export */   s16PixelType: () => (/* binding */ s16PixelType),
/* harmony export */   s32PixelType: () => (/* binding */ s32PixelType),
/* harmony export */   s8PixelType: () => (/* binding */ s8PixelType),
/* harmony export */   save: () => (/* binding */ save),
/* harmony export */   saveAs: () => (/* binding */ saveAs),
/* harmony export */   saveUtils: () => (/* binding */ saveUtils),
/* harmony export */   savingMessage: () => (/* binding */ savingMessage),
/* harmony export */   scalar: () => (/* binding */ scalar),
/* harmony export */   search: () => (/* binding */ search),
/* harmony export */   selectFeature: () => (/* binding */ selectFeature),
/* harmony export */   selectFunction: () => (/* binding */ selectFunction),
/* harmony export */   selectRaster: () => (/* binding */ selectRaster),
/* harmony export */   serviceURL: () => (/* binding */ serviceURL),
/* harmony export */   setGroupSharing: () => (/* binding */ setGroupSharing),
/* harmony export */   setSharingLevel: () => (/* binding */ setSharingLevel),
/* harmony export */   share: () => (/* binding */ share),
/* harmony export */   shareWith: () => (/* binding */ shareWith),
/* harmony export */   success: () => (/* binding */ success),
/* harmony export */   tagFieldName: () => (/* binding */ tagFieldName),
/* harmony export */   tags: () => (/* binding */ tags),
/* harmony export */   title: () => (/* binding */ title),
/* harmony export */   toolDetailsEditor: () => (/* binding */ toolDetailsEditor),
/* harmony export */   toolEditor: () => (/* binding */ toolEditor),
/* harmony export */   toolModeler: () => (/* binding */ toolModeler),
/* harmony export */   tryAgain: () => (/* binding */ tryAgain),
/* harmony export */   type: () => (/* binding */ type),
/* harmony export */   u16PixelType: () => (/* binding */ u16PixelType),
/* harmony export */   u32PixelType: () => (/* binding */ u32PixelType),
/* harmony export */   u8PixelType: () => (/* binding */ u8PixelType),
/* harmony export */   unionDimensions: () => (/* binding */ unionDimensions),
/* harmony export */   unknownPixelType: () => (/* binding */ unknownPixelType),
/* harmony export */   unsavedTitle: () => (/* binding */ unsavedTitle),
/* harmony export */   unsavedWarningExisting: () => (/* binding */ unsavedWarningExisting),
/* harmony export */   unsavedWarningNew: () => (/* binding */ unsavedWarningNew),
/* harmony export */   userStartDirection: () => (/* binding */ userStartDirection),
/* harmony export */   variables: () => (/* binding */ variables),
/* harmony export */   viewerModeMessage: () => (/* binding */ viewerModeMessage),
/* harmony export */   viewerModeTitle: () => (/* binding */ viewerModeTitle),
/* harmony export */   warning: () => (/* binding */ warning)
/* harmony export */ });
const ok = "OK.";
const cancel = "Anulare";
const enterURL = "Introduceți URL serviciu de imagini";
const serviceURL = "URL serviciu";
const selectRaster = "Selectați raster";
const failedToLoadLayer = "A eșuat încărcarea Stratului tematic";
const loadingLayer = "Se încarcă stratul";
const selectFeature = "Selectare strat tematic de obiecte spațiale";
const enterFURL = "Introducere URL serviciu de obiecte spațiale";
const addRaster = "Adăugați variabila raster";
const addScalar = "Adăugare constantă";
const raster = "Raster";
const scalar = "Scalar";
const defaultModelName = "Şablon funcţie raster";
const general = "Informații generale";
const parameters = "Parametri";
const variables = "Variabile";
const name = "Nume";
const description = "Descriere";
const parameter = "Parametru";
const isPublic = "IsPublic";
const isDataset = "IsDataset";
const unknownPixelType = "Necunoscut";
const outputPixelType = "Tip pixeli de ieşire";
const u8PixelType = "8 Bit nesemnat";
const s8PixelType = "8 Bit Semnat";
const u16PixelType = "16 Bit nesemnat";
const s16PixelType = "16 Bit Semnat";
const u32PixelType = "32 Bit nesemnat";
const s32PixelType = "32 Bit Semnat";
const f32PixelType = "32 Bit Mobil";
const f64PixelType = "64 Bit Dublu";
const properties = "Proprietăți";
const multidimensionalRules = "Reguli multidimensionale";
const matchVariables = "Variabile de potrivire";
const unionDimensions = "Dimensiuni de uniune";
const rasterFunctionEditor = {
	invalidRFTMessage: "Șablonul de funcție raster nu este valabil.",
	rfxArgsEditor: {
		outputRaster: "Raster ieșire",
		raster: "Raster",
		unsupportedDataTypeWarning: "Următoarele argumente nu sunt afişate, deoarece acestea nu sunt acceptate în prezent.",
		unsupportedFunction: "Conține funcție (funcții) de raster neacceptată(e) momentan."
	},
	rfxRasterInput: {
		selectLayer: "Selectați stratul tematic",
		browseLayers: "Răsfoire straturi tematice",
		rfxVariable: "Funcția raster variabilă"
	},
	rfxBandCombinationEditor: {
		methodLabel: "Metodă",
		bandLabel: "Bandă",
		combinationLabel: "Combinaţie"
	},
	rfxRemapGrid: {
		minimum: "Minim",
		maximum: "Maxim",
		output: "Ieşire",
		noData: "NoData",
		remapValuesLabel: "Recartografiere valori"
	},
	rfxNamedRasterEditor: {
		rasterVariables: "Variabile raster",
		deleteSelectedVars: "Eliminare variabile selectate"
	},
	rfxClippingGeometry: {
		clippingLayer: "Strat tematic de decupare",
		clippingRaster: "Se decupează raster",
		clippingGeometry: "Se decupează geometria",
		customExtent: "Măsură personalizată",
		outputExtent: "Extindere ieșire",
		currentExtent: "Extinderea curentă a hărţii",
		drawLabel: "Trasare"
	},
	rfxCustomExtent: {
		top: "Sus",
		right: "Dreapta",
		bottom: "Jos",
		left: "Stânga"
	},
	rfxRasterArrayEditor: {
		moveUp: "Deplasare în sus",
		moveDown: "Deplasare în jos",
		remove: "Eliminare"
	},
	rfxStatisticsGrid: {
		stdDev: "Abatere Dev",
		min: "Min",
		max: "Max",
		mean: "Medie"
	},
	rfxWeightedSumTableEditor: {
		weightedSumTable: "Tabel de sume ponderate",
		id: "ID",
		layer: "Strat tematic",
		field: "Field",
		weight: "Greutate",
		value: "Valoare",
		selectLayer: "Selectați stratul tematic"
	},
	rfxWeightedOverlayTableEditor: {
		weightedOverlayTable: "Tabel suprapus ponderat",
		id: "ID",
		layer: "Strat tematic",
		field: "Field",
		influence: "Influenţă",
		sumOfInfluence: "Suma influenței",
		value: "Valoare",
		remapTable: "Recartografiere tabel",
		scale: "Scară",
		scales: "Scări",
		selectRaster: "Selectați raster"
	},
	rfxFeatureSelect: {
		addFeatureLayer: "Căutare pentru un strat tematic de obiecte spaţiale",
		addPointLayer: "Căutare pentru un strat tematic de puncte spaţiale"
	},
	rfxFieldSelect: {
		value: "Valoare",
		count: "Număr"
	},
	rfxAttributeTable: {
		tableType: "Tip tabel",
		manual: "Manual",
		external: "Extern",
		minVal: "Valoare minimă",
		maxVal: "Valoare maximă",
		baseClassName: "Denumire de bază clasă",
		colorScheme: "Schemă de culori",
		defaultClassName: "Etichetă_",
		generateTable: "Generați tabel",
		browseTable: "Navigați la tabel",
		value: "Valoare",
		classname: "Denumire clasă",
		color: "Culoare"
	},
	rfxFieldNumberSwitchable: {
		number: "Numeric",
		field: "Field",
		string: "Șir",
		linearUnit: "Unitate liniară"
	},
	rfxPropertySet: {
		name: "Nume",
		value: "Valoare"
	},
	rfxConversionGrid: {
		size: "Dimensiune"
	},
	rfxTransposeBit: {
		bitPattern: "Modelul de Biți",
		outputBit: "Bit de ieșire",
		inputBit: "Bit de intrare"
	},
	rfxSpatialReference: {
		placeHolder: "Rafinați după Cuvânt Cheie",
		coordinateSystem: "Sistem de coordonate",
		gcs: "Sistem de coordonate geografice",
		pcs: "Sistem de coordonate proiectate",
		vcs: "Sistem de coordonate verticale"
	}
};
const rfxLicenseInfo = "Acest șablon de funcţie raster poate fi utilizat pentru a prelucra imaginile dvs. folosind ArcGIS Image Server.";
const rasterFunctions = {
	rfx: {
		aCosHName: "ACosH",
		aCosHSnip: "Calculează cosinusul hiperbolic invers al celulelor dintr-un raster.",
		aCosHDesc: "Funcția calculează cosinusul hiperbolic invers al pixelilor dintr-un raster.",
		aCosName: "ACos",
		aCosSnip: "Calculează cosinusul invers al pixelilor dintr-un raster.",
		aCosDesc: "Această funcție raster calculează cosinusul invers al celulelor dintr-un raster. În matematică, toate funcțiile trigonometrice au un interval definit de valori de intrare valabile, denumit domeniu. Valorile de ieșire din fiecare funcție au, de asemenea, un interval definit. Pentru acest instrument, domeniul este [-1, 1], iar intervalul este [0, pi].",
		aSinHName: "ASinH",
		aSinHSnip: "Calculează sinusul hiperbolic invers al celulelor dintr-un raster.",
		aSinHDesc: "Funcția calculează sinusul hiperbolic invers al pixelilor dintr-un raster.",
		aSinName: "ASin",
		aSinSnip: "Calculează sinusul invers al celulelor dintr-un raster.",
		aSinDesc: "Funcția calculează sinusul invers al pixelilor dintr-un raster.",
		aTan2Name: "ATan2",
		aTan2Snip: "Calculează tangenta inversă (pe baza x,y) a celulelor dintr-un raster.",
		aTan2Desc: "Funcția calculează tangenta inversă (pe baza x,y) a pixelilor dintr-un raster.",
		aTanHName: "ATanH",
		aTanHSnip: "Calculează tangenta hiperbolică inversă a celulelor dintr-un raster.",
		aTanHDesc: "Funcția calculează tangenta hiperbolică inversă a pixelilor dintr-un raster.",
		aTanName: "ATan",
		aTanSnip: "Calculează tangenta inversă a celulelor dintr-un raster.",
		aTanDesc: "Funcția calculează tangenta inversă a pixelilor dintr-un raster.",
		absName: "Abs",
		absSnip: "Calculează valoarea absolută a celulelor dintr-un raster.",
		absDesc: "Funcția Abs calculează valoarea absolută a pixelilor dintr-un raster.",
		reflectanceName: "Reflectanță aparentă",
		reflectanceSnip: "Transformă imaginile brute în valori Top of Atmosphere prin luarea în considerare a caracteristicilor senzorului, a poziției soarelui și timpului de achiziție.",
		reflectanceDesc: "Această funcție ajustează numărul digital (ND) al luminozității imaginii pentru unii dintre senzorii de satelit. Ajustările se bazează pe elevația soarelui, data achiziției și proprietățile senzorului pentru a seta amplificarea și înclinarea pentru fiecare bandă. Această funcție este folosită pentru a ajusta reflectanța sau luminozitatea, valori ale unor imagini de satelit pe baza iluminării scenei și setării amplificării senzorului. Imaginile sunt ajustate conform unei condiții de iluminare comune teoretică, prin urmare trebuie să existe mai puțină variație între scenele din date diferite și de la senzori diferiți. Acest lucru poate fi util pentru clasificarea imaginii, echilibrarea culorii și mozaicare. Această funcție poate fi utilizată doar cu imagini specifice. Senzorii aplicabili sunt Landsat MSS, Landsat TM, Landsat ETM+, Landsat 8, IKONOS, QuickBird, GeoEye-1, RapidEye, DMCii, WorldView-1, WorldView-2, SPOT 6 și Pleiades.<div><br/>Funcțiile efectuează două corecții. Prima se bazează pe setările amplificării. Valorile originale de luminozitate sunt re-create din valorile imaginii prin inversarea ecuațiilor de amplificare. A doua corecție este aferentă diferenței unghiului și luminozității soarelui. Valorile inițiale ale luminozității sunt ajustate unei stări comune a luminozității prin scene de normalizare capturate în condiții de iluminare variabile. În general, în timp ce tipul datelor de imagine rezultate este același cu tipul datelor de intrare, valorile de ieșire sunt mai mici decât valorile de intrare și sunt decupate conform intervalului de date valabil.</div>",
		argStatisticsName: "ArgStatistics",
		argStatisticsSnip: "Calculează statisticile arg inclusiv Arg Max, Arg Min, Arg Median și Durată.",
		argStatisticsDesc: "Funcția calculează statisticile arg. Există patru metode în funcția ArgStatistics: ArgMax, ArgMin, ArgMedian și Durată.",
		arithmeticName: "Aritmetic",
		arithmeticSnip: "Efectuează o operație aritmetică între două rastere sau un raster și un scalar.",
		arithmeticDesc: "Funcția aritmetică efectuează o operație aritmetică între două rastere sau un raster și un scalar și invers.",
		aspectSlopeName: "Aspect-Pantă",
		aspectSlopeSnip: "Creează un raster care prezintă simultan aspectul (direcția) și panta (înclinarea) unei suprafețe continue, conform reprezentării dintr-un model digital de elevare.",
		aspectSlopeDesc: "Funcția Pantă de Aspect creează un strat raster care afișează aspectul și panta unei suprafețe. Aspectul identifică direcția în pantă a ratei maxime de schimbare a valorii din fiecare pixel către vecinii săi. Aspectul poate fi considerat direcția pantei. Valorile rasterului de ieșire vor fi direcția de busolă a aspectului, reprezentată de o nuanță (culoare). Panta reprezintă rata de modificare a elevației pentru fiecare pixel al modelului digital de elevație (DEM). Panta reprezintă înclinarea suprafeței și este simbolizată prin trei clase prezentate cu ajutorul saturației culorii (luminozității).<div><br/>Valorile pixelilor din rasterul de ieșire aspect-înclinare reflectă o combinație a aspectului și pantei. Pixelii cu valori sub 20 sunt considerați plați și sunt prezentați cu gri. Valorile aspect-pantă de 21 și mai mult vor fi prezentate cu saturații diferite, după cum urmează: 21 până la 30 —Saturație redusă a pantei, 31 până la 40—Saturație moderată a pantei, 41 și above—Saturație ridicată a pantei</div>",
		aspectName: "Aspect",
		aspectSnip: "Prezintă direcția în care este orientat un pixel, unde 0 este orientat către nord și unghiurile cresc în sens orar până la 360.",
		aspectDesc: "Funcția de aspect identifică direcția în pantă a ratei maxime de schimbare a valorii din fiecare celulă către vecinii săi. Aspectul poate fi considerat direcția pantei. Valorile rasterului de ieșire vor fi direcția aspectului.<div><br/>Intrarea pentru această funcție este Rasterul de Intrare. Funcția de aspect este adesea aplicată unui model de elevare digitală (DEM). Implicit, aspectul apare ca o imagine pe scală de gri. Puteți adăuga funcția Colormap pentru a specifica o anumită schemă de culori sau a permite persoanei care vizualizează mozaicul să modifice simbologia cu propria schemă de culori.</div>",
		tableName: "Tabel de atribute",
		tableSnip: "Utilizează un tabel pentru a denumi și simboliza valorile dintr-un set de date. Coloanele pentru tabel sunt delimitate cu virgulă: PixelValue, AttributeName, RedValue, GreenValue, BlueValue.",
		tableDesc: "Funcția Tabel de atribute vă permite să definiți un tabel de atribute pentru a simboliza un set de date mozaic cu o singură bandă sau un set de date raster. <div><br/>Acest lucru este util atunci când doriți să prezentați imagini care au suferit o clasificare conform utilizării terenului, cum ar fi teren împădurit, mlaștini, teren agricol și urban. În plus, dacă tabelul dvs. conține câmpuri denumite roșu, verde și albastru, valorile din acele câmpuri vor fi utilizate ca o hartă de culori la redarea imaginii.</div>",
		bandArithmeticName: "Aritmetică bandă",
		bandArithmeticSnip: "Calculează indicii folosind formule prestabilite sau o expresie definită de utilizator.",
		bandArithmeticDesc: "Funcția de aritmetică bandă efectuează o operație aritmetică pe benzile unui set de date raster. Puteți alege algoritmii prestabiliți sau puteți introduce propria formulă cu o singură linie. Operatorii suportați sunt -,+,/,*, și unar -.",
		thresholdName: "Limitare binară",
		thresholdSnip: "Organizează datele continue în prim plan și fundal prin reducerea la minimum a covarianței dintre cele două clase.",
		thresholdDesc: "Atunci când un set de date raster are o distribuție bimodală, această funcție creează un nou raster care împarte datele în două clase distincte. Creează o clasă de valoare inferioară prezentată cu pixeli negri și o clasă de valoare ridicată prezentată cu pixeli albi.",
		bitwiseAndName: "Bitwise And",
		bitwiseAndSnip: "Efectuează o operație Bitwise And asupra valorilor binare a două rastere de intrare.",
		bitwiseAndDesc: "Bitwise And efectuează o operație Bitwise And asupra valorilor binare a două rastere de intrare",
		bitwiseLeftShiftName: "Bitwise Left Shift",
		bitwiseLeftShiftSnip: "Efectuează o operație Bitwise Left asupra valorilor binare a două rastere de intrare.",
		bitwiseLeftShiftDesc: "Bitwise Left Shift efectuează o operație Bitwise Left Shift asupra valorilor binare a două rastere de intrare",
		bitwiseNotName: "Bitwise Not",
		bitwiseNotSnip: "Efectuează o operație Bitwise Not (complement) asupra valorilor binare a două rastere de intrare.",
		bitwiseNotDesc: "Funcția efectuează o operație Bitwise Not (complement) asupra valorilor binare ale unui raster de intrare.",
		bitwiseOrName: "Bitwise Or",
		bitwiseOrSnip: "Efectuează o operație Bitwise Or asupra valorilor binare a două rastere de intrare.",
		bitwiseOrDesc: "Funcția efectuează o operație Bitwise Or asupra valorilor binare a două rastere de intrare. ",
		bitwiseRightShiftName: "Bitwise Right Shift",
		bitwiseRightShiftSnip: "Efectuează o operație Bitwise Right Shift asupra valorilor binare a două rastere de intrare.",
		bitwiseRightShiftDesc: "Funțcia efectuează o operație Bitwise Right Shift asupra valorilor binare a două rastere de intrare.",
		bitwiseXorName: "Bitwise Xor",
		bitwiseXorSnip: "Efectuează o operație Bitwise eXclusive Or asupra valorilor binare a două rastere de intrare.",
		bitwiseXorDesc: "Funțcia efectuează o operație Bitwise eXclusive Ir asupra valorilor binare a două rastere de intrare",
		booleanAndName: "Boolean And",
		booleanAndSnip: "Efectuează o operație Boolean And asupra valorilor celulei a două rastere de intrare. Dacă ambele valori de intrare sunt reale (non-zero), valoarea de ieșire este 1. Dacă una sau ambele intrări sunt false (zero), ieșirea este 0.",
		booleanAndDesc: "Funțcia efectuează o operație Boolean And asupra valorilor pixel a două intrări. Dacă ambele valori de intrare sunt reale (nonzero), valoarea de ieșire este 1. Dacă una sau ambele valori de intrare sunt false (zero), valoarea de ieșire este 0. ",
		booleanNotName: "Boolean Not",
		booleanNotSnip: "Efectuează o operație Boolean And (complement) asupra valorilor celulei rasterului de intrare. Dacă valorile de intrare sunt reale (non-zero), valoarea de ieșire este 0. Dacă valorile de intrare sunt false (zero), ieșirea este 1.",
		booleanNotDesc: "Funcția efectuează o operație Boolean Not (complement) asupra valorilor pixel ale rasterului de intrare. Dacă valorile de intrare sunt reale (nonzero), valoarea de ieșire este 0. Dacă valorile de intrare sunt false (zero), valoarea de ieșire este 1.",
		booleanOrName: "Boolean Or",
		booleanOrSnip: "Efectuează o operație Boolean Or asupra valorilor celulei celor două rastere de intrare. Dacă unul sau ambele valori de intrare sunt reale (non-zero), valoarea de ieșire este 1. Dacă ambele valori de intrare sunt false (zero), ieșirea este 0.",
		booleanOrDesc: "Funcția efectuează o operație Boolean Or asupra valorilor binare a două rastere de intrare. Dacă una sau ambele valori de intrare sunt reale (nonzero), valoarea de ieșire este 1. Dacă ambele valori de intrare sunt false (zero), valoarea de ieșire este 0.",
		booleanXorName: "Boolean Xor",
		booleanXorSnip: "Efectuează o operație Boolean eXclusive Or asupra valorilor celulei a două rastere de intrare. Dacă o valoare de intrare este reală (non-zero) și cealaltă falsă (zero), valoarea de ieșire este 1. Dacă ambele valori de intrare sunt reale sau ambele sunt false, ieșirea este 0.",
		booleanXorDesc: "Funcția efectuează o operație Boolean eXclusive Or asupra valorilor celulei a două rastere de intrare. Dacă o valoare de intrare este reală (nonzero) și cealaltă valoare este falsă (zero), valoarea de ieșire este 1. Dacă ambele valori de intrare sunt reale sau ambele sunt false, valoarea de ieșire este 0.",
		bufferedRasterName: "Tamponat",
		bufferedRasterSnip: "Tamponează cel(e) mai recent(e) bloc(uri) de pixeli accesate.",
		bufferedRasterDesc: "Funcția Buffered este folosită pentru a optimiza performanțele lanțurilor de funcții complexe. Stochează ieșirea în memoria părții lanțului de funcții de dinaintea acestuia. <div><br/>Introduceți această funcție în Editorul de Funcție acolo unde doriți să stocați ieșirea.</div>",
		rasterCalculatorName: "Calculator",
		rasterCalculatorSnip: "Calculează un raster dintr-o expresie matematică bazată pe raster.",
		rasterCalculatorDesc: "Funcția de Calculator vă permite să creați și să utilizați expresii și să le includeți în lanțurile de funcții.",
		cellStatisticsName: "Statisticile celulei",
		cellStatisticsSnip: "Calculează o statistică pe fiecare celulă din rastere multiple. Statisticile disponibile sunt Majoritate, Maximum, Mijlociu, Mediu, Minimum, Minoritate, Percentilă, Interval, Abatere Standard, Sumă și Varietate.",
		cellStatisticsDesc: "Această funcție calculează statisticile din rastere multiple, pixel cu pixel. Statisticile disponibile sunt majoritate. maximum, mijlociu, mediu, minimum, minoritate, interval, abatere standard, sumă și varietate.",
		classifyName: "Clasificare",
		classifySnip: "Alocă fiecare pixel unei clase. Include datele auxiliare cum ar fi o imagine segmentată.",
		classifyDesc: "Această funcție raster clasifică un set de date raster pe baza unui fișier de Definiție a Clasificatorului Esri (.ecd) și a intrărilor seturilor de date raster. Fișierul .ecd folosit în funcția Clasificare include toate informațiile pentru un set de date și clasificator specific și este generat de către instrumentele de instruire pentru clasificare, cum ar fi instrumentele Train Support Vector Machine sau Train Random Trees.",
		clipName: "Atașare",
		clipSnip: "Stabilește mărimea unui raster folosind coordonatele sau un alt set de date.",
		clipDesc: "Această funcție decupează un raster folosind o formă dreptunghiulară conform măsurilor definite sau va decupa un raster conform formei unei clase de obiecte spațiale poligonale de intrare. Forma care definește decuparea poate decupa mărimea rasterului sau decupa o zonă din raster.",
		colorspaceConversionName: "Transformarea modelului de culoare",
		colorspaceConversionSnip: "Transformă un raster din RGB în HSV și invers.",
		colorspaceConversionDesc: "Funcția de Conversie a Modelului de Culoare transformă modelul de culoare al unei imagini din spațiul de culoare de nuanță, saturație și valoare (HSV) în roșu, verde și albastru (RGB) sau invers.<div><br/>Această funcție poate fi folosită într-un set de date mozaic.</div>",
		colormapToRGBName: "Hartă a culorii în RGB",
		colormapToRGBSnip: "Transformă un raster cu o singură bandă cu o hartă a culorii într-un raster cu trei benzi (roșu, verde și albastru).",
		colormapToRGBDesc: "Această funcție transformă un raster cu o singură bandă într-un raster cu trei benzi (roșu, verde și albastru).<div><br/>Această funcție este utilă atunci când trebuie să creați un raster din trei benzi dintr-un raster cu o singură bandă cu o hartă a culorii asociată. Valorile din harta culorii vor fi folosite pentru a crea fiecare bandă roșie, verde și albastră. Această funcție poate fi folosită într-un set de date mozaic.</div>",
		colormapName: "Culoare hartă",
		colormapSnip: "Modifică valorile pixelilor pentru a prezenta datele rasterului ca scară gri sau o imagine roșie, verde, albastră (RGB), pe baza unei hărți a culorilor sau a unei rampe de culoare.",
		colormapDesc: "Funcția Harta Culorii este un tip de dispozitiv de redare a datelor rasterului. Aceasta transformă valorile pixelilor pentru a afișa datele rasterului ca fiind o scară gri sau o imagine de culori RGB bazată pe o schemă de culori sau culori specifice într-un fișier de hartă color. Puteți folosi o hartă color pentru a reprezenta datele analizate, cum ar fi o imagine clasificată sau la afișarea unei hărți topografice (sau a unei imagini scanate cu indice de culoare).<div><br/> Hărțile de culori conțin un set de valori asociate culorilor folosite pentru afișarea unui raster cu o singură bandă în mod consecvent cu aceleași culori. Fiecare valoare a pixelului este asociată unei culori, definite ca un set de valori RGB. Hărțile de culori sunt capabile să suporte orice adâncime a bitului cu excepția punctului flotant. De asemenea, suportă valorile pozitive și negative și pot include valorile lipsă cu hărți de culori. La afișarea unui set de date cu o hartă de culori care include valori lipsă, pixelii cu acele valori lipsă nu vor fi afișați.</div>",
		complexName: "Complex",
		complexSnip: "Extrage magnitudinea din numerele complexe.",
		complexDesc: "Această funcție calculează magnitudinea din valori complexe.<div><br/>Această funcție este folosită de obicei cu imagini RADAR care au un tip de date complexe. Poate fi folosită într-un set de date mozaic.</div>",
		compositeBandName: "Benzi compozite",
		compositeBandSnip: "Combină seturile de date multiple într-un raster cu benzi multiple.",
		compositeBandDesc: "Funcția de Benzi Compozite vă permite să combinați rasterele pentru a forma o imagine cu mai multe benzi.",
		conName: "Con",
		conSnip: "Efectuează o operațiune condițională Dacă, Atunci, Sau. Atunci când este folosit un operator Con, de obicei trebuie să existe două sau mai multe funcții conectate, acolo unde o funcție stabilește criteriile și a doua funcție o reprezintă operatorul Con care folosește criteriile și dictează care ar trebui să fie ieșirile reale și false.",
		conDesc: "Funcția Condițional stabilește pixelii rasterului de ieșire pe baza unei evaluări dacă//sau a fiecărui pixel de intrare. Returnează valorile pixelului din Rasterul Real dacă evaluarea condițională este reală (1) sau returnează valorile pixelului din Rasterul Fals dacă evaluarea condiționată este falsă (0). Acest criteriu este specificat de rezultatul unei funcții matematice logice, care va fi Rasterul de intrare.",
		constantName: "Constantă",
		constantSnip: "Creează un raster virtual cu o singură valoare de pixel.",
		constantDesc: "Această funcție creează un raster virtual cu o singură valoare de pixel care poate fi folosită în șabloane de funcție raster și pentru a prelucra un set de date mozaic.<div><br/>Valoarea constantă este folosită pentru fiecare valoare de pixel din raster.</div>",
		contourName: "Contur",
		contourSnip: "Creează linii de contur.",
		contourDesc: "Funcția de contur generează linii contur prin alăturarea punctelor cu aceeași elevație dintr-un set de date de elevație a rasterului. Contururile sunt izolinii create ca rastere pentru vizualizare. Următoarele caracteristici principale reprezintă forța acestei funcții: contururile sunt generate rapid și dinamic pe seturi de date foarte mari, așa cum ar fi Elevația Globală; contururile pot fi aplatizate pentru a oferi un aspect cartografic mai plăcut în timp ce se păstrează acuratețea contururilor; se asigură controlul dinamic asupra intervalului de contur; opțiunile de ieșire includ liniile de contur, contururile index și contururile umplute.<div><br/>Crearea unui strat tematic de contur ca produs raster este valoroasă pentru o gamă largă de aplicații din moment ce contururile pot fi suprapuse pe o hartă și pot oferi informații referitoare la teren fără a ascunde datele de bază. Acestea sunt utile în aplicații cum ar fi ingineria, agricultura și administrarea apelor.</div>",
		contrastBrightnessName: "Contrast și Luminozitate",
		contrastBrightnessSnip: "Ajustați contrastul și luminozitatea unui raster.",
		contrastBrightnessDesc: "Funcția de Contrast Și Luminozitate amplifică aspectul datelor raster prin modificarea luminozității și contrastului din imagine. Luminozitatea crește iluminarea generală a imaginii—de exemplu, deschizând culorile mai închise și albind culorile deschise—în timp ce contrastul ajustează diferența dintre culorile cele mai închise și cele mai deschise.<div><br/>Utilizarea acestei funcții modifică valorile pixelului; astfel, această funcție ar trebui folosită atunci când doriți să amplificați datelor și nu dacă intenționați să folosiți datele ca parte a unei analize care ar necesita valorile brute ale pixelilor. Această funcție este utilă la publicarea datelor ca un serviciu de imagini care poate fi utilizat în aplicații fără capacitate de modificare a contrastului și luminozității imaginilor, sau pentru a asigura că face o prezentare folosind setările dvs. preferate.</div>",
		convolutionName: "Convoluție",
		convolutionSnip: "Aplică un filtru pentru a clarifica, blura, detecta margini, aplatiza sau un gradient pe un raster.",
		convolutionDesc: "Funcția Convoluție efectuează filtrarea asupra valorilor pixelilor dintr-o imagine, care poate fi folosit pentru clarificarea unei imagini, blurarea unei imagini, detectarea marginilor dintr-o imagine, sau alte amplificări bazate pe nuclee. Filtrele sunt utilizate pentru îmbunătățirea calității imaginii raster prin eliminarea datelor secundare sau amplificarea obiectelor spațiale din date. Aceste filtre de convoluție sunt aplicate pe un nucleu aflat în deplasare, suprapus (fereastră sau în apropiere), cum ar fi 3 ori 3. Filtrele de convoluție funcționează prin calcularea valorii pixelului pe baza ponderii vecinilor săi.",
		corridorName: "Coridor",
		corridorSnip: "Calculează suma costurilor acumulative pentru două rastere acumulative de intrare.",
		corridorDesc: "Funcția de coridor calculează suma costurilor acumulative pentru două rastere de cost acumulative de intrare. În timp ce oricare două rastere pot fi utilizate pentru intrare, pentru a obține un rezultat semnificativ acestea trebuie să fie rastere de ieșire de cost acumulative nealterate. Ordinea celor două intrări este irelevantă.",
		cosHName: "CosH",
		cosHSnip: "Calculează cosinusul hiperbolic al celulelor dintr-un raster.",
		cosHDesc: "Funcția calculează cosinusul hiperbolic al pixelilor dintr-un raster.",
		cosName: "Cos",
		cosSnip: "Calculează cosinusul unei celule dintr-un raster.",
		cosDesc: "Funcția calculează cosinusul pixelilor dintr-un raster.",
		costAllocationName: "Alocarea Costului",
		costAllocationSnip: "Calculează, pentru fiecare celulă, sursa cu cel mai mic cost pe baza costului cel mai puțin acumulativ pe o suprafață de cost.",
		costAllocationDesc: "Funcția de Alocare a Costurilor calculează, pentru fiecare celulă, sursa cu cel mai mic cost pe baza costului cel mai puțin acumulativ pe o suprafață de cost.",
		costBackLinkName: "Link Cost Back",
		costBackLinkSnip: "Definește vecinul care este celula următoare pe traseul de cost cel mai puțin acumulativ către sursa cu cel mai mic cost.",
		costBackLinkDesc: "Funcția de Cost Back definește vecinul care este celula următoare pe traseul de cost cel mai puțin acumulativ către sursa cu cel mai mic cost.<div><br/>Rasterul de legătură inversă include valori de zero până la opt, care definesc direcția sau identifică următoarea celulă vecină (celula care succede) pe traseul de cost cel mai puțin acumulativ de la o celulă pentru a ajunge la sursa sa cu cele mai mici costuri. Dacă traseul va trece la vecinul din dreapta, celula va primi valoarea 1, 2 pentru celula diagonală din dreapta jos și continuă în sens orar. Valoarea 0 este rezervată pentru celulele sursă.</div>",
		costDistanceName: "Distanță de Cost",
		costDistanceSnip: "Calculează distanța de cost cel mai puțin acumulativă pentru fiecare celulă de la sau la sursa cu cel mai mic cost pe o suprafață de cost.",
		costDistanceDesc: "Funcția Cost Distanță calculează distanța de cost cel mai puțin acumulativă pentru fiecare celulă de la sau la sursa cu cel mai mic cost pe o suprafață de cost.",
		costPathName: "Traseu de Cost",
		costPathSnip: "Calculează traseul cu cel mai mic cost dintr-o sursă la o destinație.",
		costPathDesc: "Funcția globală Traseu de Cost calculează traseul cu cel mai mic cost dintr-o sursă la o destinație.<div><br/>Această funcție produce un raster de ieșire care înregistrează traseul sau traseele cu costul cel mai mic din locații selectate până la cea mai apropiată sursă definită în suprafața de cost acumulativă, cu privire la distanța de cost.</div>",
		curvatureName: "Curbură",
		curvatureSnip: "Calculează curbura unei suprafețe raster, incluzând opțional profilul și curbura planului.",
		curvatureDesc: "Funcția de Curbură prezintă forma sau curbura pantei. O parte a unei suprafețe poate fi concavă sau convexă; vă puteți da seama de acest lucru privind valoarea curburii. Curbura este calculată prin calcularea celei de-a doua derivative a suprafeței.<div><br/>Ieșirea funcției de Curbură poate fi folosită pentru a descrie caracteristicile fizice ale unui bazin de scurgere într-un efort pentru a înțelege procesele de eroziune și scurgere. Valoarea curburii poate fi folosită pentru a găsi șabloane de eroziune a solului cât și distribuția apei pe teren. Curbura profilului afectează accelerarea și decelerarea curgerii și, prin urmare, influențează eroziunea și depunerile. Curbura platformei influențează convergența și divergența curgerii.</div>",
		divideName: "Împărțire",
		divideSnip: "Împarte valorile a două rastere celulă cu celulă.",
		divideDesc: "Funcția de Împărțire împarte valorile a două rastere pixel cu pixel.",
		elevationVoidFillName: "Umplerea Vidului Elevației",
		elevationVoidFillSnip: "Creează pixeli acolo unde există găuri în datele dvs. de elevație.",
		elevationVoidFillDesc: "Funcția de Umplere a Vidului Elevației este utilizată pentru a crea pixeli acolo unde există găuri în elevația dvs.<div><br/>Vidul apare acolo unde nu există puncte colectate în zona reprezentată de un pixel în rasterul rezultant. Vidul este adesea cauzat de corpurile de apă, de selectarea tipului de clasă sau de excludere. Umplerea vidului este utilizată cel mai des la generarea unei suprafețe de sol.</div>",
		equalToName: "Egală cu",
		equalToSnip: "Efectuează o operație de egalizare Relațională pe două intrări de la o celulă la alta. Returnează valoarea 1 pentru celulele unde primul raster este cu cel de-al doilea raster și 0 pentru celulele unde acestea nu sunt egale.",
		equalToDesc: "Funcția efectuează o operație de egalizare pe două rastere de la un pixel la altul. Aceasta returnează valoarea 1 pentru pixelii unde primul raster este egal cu cel de-al doilea raster și valoarea 0 pentru pixeli unde aceștia nu sunt egali.",
		eucAllocationName: "Alocare Euclidiană",
		eucAllocationSnip: "Calculează, pentru fiecare celulă, cea mai apropiată sursă pe baza distanței euclidiene.",
		eucAllocationDesc: "Funcția de Alocare Euclidiană calculează, pentru fiecare celulă, cea mai apropiată sursă pe baza distanței euclidiene.",
		eucDirectionName: "Direcție Euclidiană",
		eucDirectionSnip: "Calculează, pentru fiecare celulă, direcția până la cea mai apropiată sursă, în grade.",
		eucDirectionDesc: "Funcția de Direcție Euclidiană calculează, pentru fiecare celulă, direcția până la cea mai apropiată sursă, în grade. <div><br/>Direcția este calculată de la centrul fiecărei celule până la centrul celulei sursă care se află cel mai aproape de aceasta. Gama de valori este de la 0 grade la 360 grade, cu 0 rezervat pentru celulele sursă. Spre Est (dreapta) este 90 iar valoarea crește în sens orar (180 este sudul, 270 este vestul iar 360 este nordul).</div>",
		eucDistanceName: "Distanță Euclidiană",
		eucDistanceSnip: "Calculează, pentru fiecare celulă, distanța euclidiană până la cea mai apropiată sursă.",
		eucDistanceDesc: "Funcția de Distanță Euclidiană calculează, pentru fiecare celulă, distanța până la cea mai apropiată sursă.",
		exp10Name: "Exp10",
		exp10Snip: "Calculează exponențialul în bază 10 a celulelor dintr-un raster.",
		exp10Desc: "Funcția Exp 10 calculează funcția exponențială în bază 10 a pixelilor dintr-un raster.",
		exp2Name: "Exp2",
		exp2Snip: "Calculează exponențialul în bază 2 al celulelor dintr-un raster.",
		exp2Desc: "Această funcție calculează funcția exponențială în bază 2 a pixelilor dintr-un raster.",
		expName: "Exp",
		expSnip: "Calculează exponențialul în bază e al celulelor dintr-un raster.",
		expDesc: "Această funcție calculează funcția exponențială în bază e a pixelilor dintr-un raster.",
		extractBandName: "Extragerea Benzilor",
		extractBandSnip: "Specifică benzile cu care se va lucra la utilizarea seturilor de date cu benzi multiple.",
		extractBandDesc: " Funcția de Extragere a Benzilor vă permite să extrageți una sau mai multe benzi sau să reordonați benzile într-un set de date raster cu benzi multiple.<div><br/>Puteți folosi funcția de Extragere Benzi înaintea altor funcții, cum ar fi Aritmetica, pentru a controla care dintre benzi sunt folosite ca intrare în funcția următoare.</div>",
		fillName: "Umplere",
		fillSnip: "Umple dolinele într-un raster de suprafață pentru eliminarea unor mici imperfecții ale datelor.",
		fillDesc: "Funcția de Umplere globală localizează și umple doline și vârfuri într-un raster de suprafață de elevație pentru a elimina micile imperfecții ale datelor. Funcția va completa într-un proces repetitiv până la umplerea tuturor dolinelor din cadrul limitei Z specificate.<div><br/>Atunci când suprafața de elevație este creată cu instrumentele Ortho Mapping sau cu alte mijloace, există adesea erori mici, dar semnificative, sub forma dolinelor și vârfurilor din cadrul datelor. În fotogrametrie, dolinele și vârfurile sunt menționate adesea ca găuri și vârfuri. Datorită faptului că datele de suprafață sunt folosite adesea în modelare, cum ar fi modelarea hidrologică, este important să se corecteze aceste erori de doline și vârfuri într-un mod consecvent datelor înconjurătoare.</div>",
		floatName: "Mobil",
		floatSnip: "Transformă fiecare valoare a celulei unui raster într-o reprezentare a punctului flotant.",
		floatDesc: "Funcția de Flotare transformă fiecare valoare a pixelului unui raster într-o reprezentare a punctului flotant.",
		flowAccumulationName: "Acumularea fluxului",
		flowAccumulationSnip: "Creează un raster de flux acumulat în fiecare celulă. Un factor de pondere poate fi aplicat în mod opțional.",
		flowAccumulationDesc: "Funcția globală de Acumulare a Fluxului creează un raster de flux acumulat în fiecare pixel, conform celor determinate prin acumularea greutății tuturor pixelilor care curg în fiecare pixel al pantei de coborâre. Dacă nu se pune la dispoziție niciun raster de pondere, o pondere de 1 se aplică fiecărui pixel, iar valoarea pixelilor din rasterul de ieșire este numărul de pixeli care curg în fiecare pixel.<div><br/>Pixelii de ieșire cu o acumulare de flux ridicată reprezintă zonele de flux concentrat și pot fi folosite pentru identificarea canalelor de curs. Pixelii de ieșire cu o acumulare de flux zero sunt valori topografice locale ridicate și pot fi folosite pentru identificarea crestelor.</div>",
		flowDirectionName: "Direcția fluxului",
		flowDirectionSnip: "Creează un raster de direcție a fluxului din fiecare celulă până la vecinul său de pe panta cea mai abruptă.",
		flowDirectionDesc: "Una dintre cheile derivării caracteristicilor hidrologice ale unei suprafețe o reprezintă capacitatea de stabilire a direcției fluxului din fiecare pixel din raster. Funcția rasterului Direcției de Flux ia o suprafață drept intrare și creează un raster al direcției de flux de la fiecare pixel către vecinul de pe panta de coborâre cea mai abruptă. Funcția de Direcție a Fluxului suportă trei metode de modelare a fluxului: D8 (opt direcții), direcție multiplă a fluxului (MFD) și D-Infinit (DINF). ",
		flowDistanceName: "Distanța Fluxului",
		flowDistanceSnip: "Calculează, pentru fiecare celulă, distanța minimă orizontală sau verticală a pantei de coborâre către celulele de pe un curs de apă sau râu în care curg.",
		flowDistanceDesc: "Pentru fiecare pixel, funcția va calcula distanța orizontală sau verticală a pantei de coborâre către pixel(i) pe un râu sau curs de apă în care curg aceștia. Dacă este pus la dispoziție un raster opțional de direcție a fluxului, direcția(iile) pantei de coborâre va fi limitată la cele definite de rasterul de direcție a fluxului de intrare. Ieșirea este un raster de distanță a fluxului.",
		focalName: "Statistică Focală",
		focalSnip: "Calculează statistica focală pentru fiecare pixel a unei imagini bazate pe o vecinătate focală definită.",
		focalDesc: "Funcția de Statistică Focală calculează statistica focală pentru fiecare pixel a unei imagini bazate pe o vecinătate focală definită.",
		geometricName: "Zone geometrice",
		geometricSnip: "Crește precizia pozițională a unui set de date prin contabilizarea elevației.",
		geometricDesc: "Funcția geometrică produce o imagine ortorectificată pe baza unei definiții a senzorilor și a unui model de teren. Crește precizia pozițională a unui set de date prin contabilizarea elevației.",
		grayscaleName: "Scară gri",
		grayscaleSnip: "Transformă o imagine cu benzi multiple într-o imagine pe scară gri cu o singură bandă.",
		grayscaleDesc: "Această funcție transformă o imagine cu benzi multiple într-o imagine pe scară gri cu o singură bandă.<div><br/>Această funcție aplică ponderi specificate fiecăreia dintre benzile de intrare și normalizează imaginea de ieșire. Ponderile sunt adesea aplicate deoarece unele benzi au o importanță variabilă în funcție de aplicație. De exemplu, banda albastră conține adesea mai mult zgomot decât celelalte benzi.</div>",
		greaterThanEqualName: "Mai mare decât egal",
		greaterThanEqualSnip: "Efectuează o operație de egalizare relațională mai mare decât egal cu pe două intrări de la o celulă la alta. Returnează 1 pentru celulele unde primul raster este mai mare decât sau egal cu al doilea raster și 0 dacă nu este.",
		greaterThanEqualDesc: "Funcția efectuează o operație relațională mai mare sau egală cu pe două intrări pixel cu pixel. Aceasta returnează o valoare de 1 pentru pixelii unde primul raster este mai mare decât sau egal cu al doilea raster și o valoare de 0 pentru pixeli unde primul raster nu este mai mare decât sau egal cu al doilea raster.",
		greaterThanName: "Mai mare decât",
		greaterThanSnip: "Efectuează o operație relațională mai mare decât pe două intrări de la o celulă la alta. Returnează valoarea 1 pentru celulele unde primul raster este mai mare decât cel de-al doilea raster și 0 pentru celulele unde acestea nu sunt egale.",
		greaterThanDesc: "Funcția efectuează o operație relațională mai mare decât sau egală cu pe două intrări pixel cu pixel. Returnează o valoare de 1 pentru pixelii unde primul raster este mai mare decât al doilea raster și o valoare de 0 pentru pixeli unde primul raster nu este mai mare decât al doilea raster.",
		heatIndexName: "Index căldură",
		heatIndexSnip: "Combină temperatura aerului ambiental și umiditatea relativă pentru a afla temperatura aparentă.",
		heatIndexDesc: "Această funcție calculează temperatura aparentă pe baza temperaturii ambiente și umidității relative. Temperatura aparentă este adesea descrisă ca fiind cât de cald se simte pentru corpul uman.<div><br/>Acest indice poate fi util pentru calcularea pericolelor aferente problemelor medicale cum ar fi crampele musculare, deshidratarea, epuizarea din cauza căldurii sau insolația mai gravă în zilele calde și umede. Atunci când umiditatea relativă este ridicată, devine din ce în ce mai greu pentru transpirația corporală să se evapore, lăsând persoanele fără o modalitate de răcorire naturală și eficientă. Hărțile cu indicațiile și avertizările privind căldura sunt adesea produsul reclasificării rezultatului indicelui termic în clase, acolo unde cu cât este mai mare valoarea indicelui, cu atât este mai probabil să devină o avertizare decât o simplă indicație.</div>",
		hillshadeName: "Efect de umbră",
		hillshadeSnip: "Creează o reprezentare 3D a suprafeței, cu poziția relativă a soarelui luată în considerare pentru hașurarea imaginii",
		hillshadeDesc: "Funcția Hillshade produce o reprezentare pe scară gri 3D a suprafeței terenului, cu poziția relativă a soarelui luată în considerare pentru hașurarea imaginii. <div><br/>Hașurarea este o tehnică de vizualizare a terenului determinată de o sursă de lumină și de panta și aspectul suprafeței elevației. Aceasta este o metodă calitativă de vizualizare a topografiei și nu oferă valori de elevare absolute. </div>",
		intName: "Int",
		intSnip: "Transformă fiecare valoare a celulei unui raster într-un întreg prin reducere.",
		intDesc: "Funcția Int transformă fiecare valoare a pixelului unui raster într-un întreg prin reducere.",
		interpolateIrregularDataName: "Interpolarea datelor neregulate",
		interpolateIrregularDataSnip: "Interpolează din nori de puncte sau grile neregulate.",
		interpolateIrregularDataDesc: "Unele seturi de date netCDF sau HDF își stochează geolocarea sub forma unor șiruri așezate la distanțe neregulate de pixeli sau date de puncte. La adăugarea acestor seturi de date într-un set de date mozaic, funcția de interpolare a datelor neregulate ia datele introduse neregulat în grilă și recolectează probele astfel încât fiecare pixel să aibă dimensiune uniformă și să fie pătrat.<div><br/>La adăugarea variabilelor din netCDF sau HDF într-un set de date mozaic, acesta va verifica în mod automat dacă datele sunt dispuse ]n șiruri regulate. În caz contrar, funcția de interpolare a datelor neregulate poate fi folosită pentru a transforma datele neregulate într-un raster cu grilă regulată. Puteți modifica metoda de interpolare și dimensiunea celulei folosite în funcția de interpolare a rasterului datelor neregulate. Pentru datele cu raster cu distanță regulată, nu se va aplica interpolarea iar datele vor fi citite așa cum sunt.</div>",
		isNullName: "Este nul",
		isNullSnip: "Stabilește care valori din rasterul de intrare sunt NoData de la o celulă la alta. Returnează o valoare de 1 dacă valoarea de intrare este NoData și 0 pentru celule care nu sunt.",
		isNullDesc: "Funcția Este Nul stabilește care valori din rasterul de intrare sunt NoData de la un pixel la altul. Aceasta returnează o valoare de 1 dacă valoarea de intrare este NoData și o valoare de 0 pentru pixeli care nu sunt NoData.",
		kernelDensityName: "Kernel Density",
		kernelDensitySnip: "Calculează o zonă de magnitudine pe unitate din obiectele spațiale puncte sau polilinii folosind o funcție nucleu pentru a include o suprafață conică lină în fiecare punct sau polilinie.",
		kernelDensityDesc: "Această funcție calculează o zonă de magnitudine pe unitate din obiectele spațiale puncte sau polilinii folosind o funcție nucleu pentru a include o suprafață conică lină în fiecare punct sau polilinie.",
		keyMetadataName: "Metadate principale",
		keyMetadataSnip: "Suprareglează sau introduce metadatele principale ale unui raster într-un lanț de funcții.",
		keyMetadataDesc: "Această funcție vă permite să introduceți sau să suprareglați metadatele principale ale unui raster.<div><br/>Informațiile din metadatele principale sunt folosite pentru a ajuta aplicația cu o parte din prelucrare și redare, inclusiv furnizarea unor informații utile cum ar fi denumirea senzorului, denumirile benzilor sau nebulozitatea asociată cu imaginile.</div>",
		shortestPathName: "Traseul cu cel mai mic cost",
		shortestPathSnip: "Efectuează o analiză a distanței de cost folosind intrările sursei și destinației care mai apoi sunt folosite pentru a stabili traseul cu costul cel mai mic dintr-o sursă către o destinație.",
		shortestPathDesc: "Funcția Traseului cu Cel Mai Mic Cost calculează traseul cu cel mai mic cost dintr-o sursă și până la o destinație. Distanța cu costul cel mai puțin acumulativ este calculată pentru fiecare pixel pe o suprafață a costului, către cea mai apropiată sursă. Aceasta produce un raster de ieșire care înregistrează traseul sau traseele cu costul cel mai mic, din locații selectate până la pixelii din cea mai apropiată sursă definiți în suprafața de cost acumulativă, cu privire la distanța de cost.<div><br/>Fiecărui traseu cu costul cel mai mic îi este alocată o valoare atunci când este întâlnit în cadrul procesului de scanare. Pixelul de sfârșit de pe Rasterul Sursă al unui traseu de cost primește o valoare de 1. Primul traseu primește o valoare de 3, al doilea 4 și așa mai departe. Atunci când mai multe trasee converg și urmează distanța remanentă înapoi către o sursă de pe același traseu, segmentul unde cele două trasee se deplasează împreună primește o valoare de 2. Porțiunii fuzionate a traseului nu îi poate fi alocată o valoare a unuia dintre trasee, având în vedere că porțiunea fuzionată aparține ambelor trasee.</div>",
		lessThanEqualName: "Mai mic decât egal",
		lessThanEqualSnip: "Efectuează o operație de egalizare relațională mai mică decât sau egală cu pe două intrări de la o celulă la alta. Returnează 1 pentru celulele unde primul raster este mai mic decât sau egal cu al doilea raster și 0 acolo unde nu este.",
		lessThanEqualDesc: "Funcția efectuează o operație relațională mai mică sau egală cu pe două intrări pixel cu pixel. Aceasta returnează o valoare de 1 pentru pixelii unde primul raster este mai mic decât sau egal cu al doilea raster și o valoare de 0 unde primul raster nu este mai mic decât sau egal cu al doilea raster.",
		lessThanName: "Mai mic decât",
		lessThanSnip: "Efectuează o operație relațională mai mică decât pe două intrări de la o celulă la alta. Returnează 1 pentru celulele unde primul raster este mai mic decât al doilea raster și 0 dacă nu este.",
		lessThanDesc: "Funcția efectuează o operație relațională mai mică decât pe două intrări pixel cu pixel. Aceasta returnează o valoare de 1 pentru pixelii unde primul raster este mai mic decât al doilea raster și o valoare de 0 dacă primul raster nu este mai mic decât al doilea raster.",
		lnName: "Ln",
		lnSnip: "Calculează logaritmul natural (baza e) a celulelor dintr-un raster.",
		lnDesc: "Funcția Ln calculează logaritmul natural (baza e) a fiecărui pixel dintr-un raster.",
		log10Name: "Log10",
		log10Snip: "Calculează logaritmul de bază 10 al celulelor dintr-un raster.",
		log10Desc: "Funcția Log10 calculează logaritmul de bază 10 a fiecărui pixel dintr-un raster.",
		log2Name: "Log2",
		log2Snip: "Calculează logaritmul de bază 2 al celulelor dintr-un raster.",
		log2Desc: "Funcția Log10 calculează logaritmul de bază 2 al fiecărui pixel dintr-un raster.",
		lookupName: "Căutare",
		lookupSnip: "Creează un nou raster prin căutarea valorilor găsite într-un alt câmp din tabelul rasterului de intrare.",
		lookupDesc: "Funcția creează un nou raster prin căutarea valorilor găsite într-un alt câmp din tabelul rasterului de intrare.",
		mlClassifyName: "Clasificare ML",
		mlClassifySnip: "Clasifică imaginile folosind o abordare pe fiecare pixel. Pixelii combinați sunt alocați obiectului spațial cu cel mai mare procent din acel pixel.",
		mlClassifyDesc: "Funcția ML Clasificare vă permite să efectuați o clasificare supravegheată, folosind algoritmul de clasificare de probabilitate maximă, asupra unui set de date raster sau mozaic. Această funcție necesită un fișier de semnătură de clasificare.",
		maskName: "Mască",
		maskSnip: "Stabilește valorile pe care nu doriți să le afișați.",
		maskDesc: "Această funcție raster stabilește valorile pe care nu doriți să le afișați pe rasterul dvs. Folosind funcția Mască, veți specifica una sau mai multe valori NoData sau un interval de valori de pixel valabile. ",
		minusName: "Minus",
		minusSnip: "Scade valoarea celui de-al doilea raster de intrare din valoarea primului raster de intrare de la o celulă la alta.",
		minusDesc: "Funcția scade valoarea celui de-al doilea raster de intrare din valoarea primului raster de intrare de la un pixel la altul.",
		modName: "Mod",
		modSnip: "Găsește restul (în modul) primului raster atunci când este împărțit la al doilea raster pentru fiecare celulă.",
		modDesc: "Funcția Mod găsește restul (în modul) primului raster atunci când este împărțită la al doilea raster de la un pixel la altul. Ordinea intrărilor este importantă și afectează rezultatul ieșirii.",
		mosaicRastersName: "Rastere Mozaic",
		mosaicRastersSnip: "Compilează un set de seturi de date raster pentru a crea un singur set de date.",
		mosaicRastersDesc: "Funcția de Rastere Mozaic creează o imagine mozaic din mai multe imagini. Acolo unde există o suprapunere între imagini, există mai multe metode din care puteți alege pentru a stabili ce imagini să fie afișate.",
		ndviColorizedName: "NDVI Colorizat",
		ndviColorizedSnip: "Creează un set de date cu benzi multiple care reprezintă starea de sănătate a vegetației, pe baza diferențelor dintre benzile roșu și infraroșu apropiat.",
		ndviColorizedDesc: "Funcția NDVI Colorizat aplică funcția NDVI pe imaginea de intrare și apoi utilizează o hartă color sau o rampă de culoare pentru a prezenta rezultatul.",
		ndviName: "NDVI",
		ndviSnip: "Calculează Indice de Vegetație Diferență Normalizată (NDVI).",
		ndviDesc: "Funcția NDVI creează un set de date cu o singură bandă care reprezintă starea de sănătate a vegetației, pe baza diferențelor dintre benzile roșu și infraroșu apropiat.<div><br/>NDVI este un index standardizat care vă permite să generați o imagine care afișează intensitatea verdelui, denumită și biomasa relativă. Acest index profită de contrastul caracteristicilor dintre cele două benzi dintr-un set de date raster multispectrale: absorbțiile pigmentului clorofilei din banda roșie și reflectivitatea ridicată a materialului plantelor din banda de infraroșu apropiat (NIR). Valorile NDVI extrem de reduse sau negative reprezintă zone fără nicio vegetație, cum ar fi norii, apa sau zăpada. Valorile foarte mici reprezintă zone cu vegetație redusă sau deloc, cum ar fi betonul, rocile sau solul dezgolit. Valorile moderate reprezintă zone de arbuști și pajiști. Valorile ridicate reprezintă zone de păduri și vegetație luxuriantă.</div>",
		negateName: "Anulare",
		negateSnip: "Schimbă semnul (înmulțește cu -1) valorilor celulei rasterului de intrare de la o celulă la alta.",
		negateDesc: "Funcția de anulare schimbă semnul (înmulțește cu -1) valorilor pixelului rasterului de intrare de pe un pixel ",
		nibbleName: "Nibble",
		nibbleSnip: "Înlocuiește celulele unui raster în mod corespunzător unei măști cu valorilor vecinilor cei mai apropiați.",
		nibbleDesc: "Funcția globală Nibble permite zonelor selectate ale rasterului să le fie alocată valoarea vecinului cel mai apropiat. Acest lucru este util pentru editarea zonelor unui raster unde datele pot fi eronate.",
		notEqualName: "Nu este egal cu",
		notEqualSnip: "Efectuează o operație diferit de relațională pe două intrări de la o celulă la alta. Returnează 1 pentru celulele unde primul raster nu este egal cu al doilea raster și 0 acolo unde este egal.",
		notEqualDesc: "Funcția efectuează o operație relațională diferit de pe două intrări pixel cu pixel. Aceasta returnează o valoare de 1 pentru pixelii unde primul raster nu este egal cu al doilea raster și o valoare de 0 pentru pixeli unde primul raster este egal cu al doilea raster.",
		pansharpeningName: "Panclarificare",
		pansharpeningSnip: "Amplifică artificial rezoluția spațială a unei imagini cu benzi multiple prin fuzionarea acesteia cu o imagine pancromatică de rezoluție mai mare.",
		pansharpeningDesc: "Funcția de Panclarificare utilizează o imagine pancromatică de rezoluție mai mare sau bandă raster pentru fuzionarea cu un set de date de rezoluție mai mică, cu benzi multiple, pentru a crește rezoluția spațială a imaginii cu benzi multiple.<div><br/>Scopul panclarificării este acela de a crea o imagine cu calitate vizuală ridicată. Având în vedere faptul că tehnicile modifică caracteristicile de radiometrie și spectrale ale imaginilor cu benzi multiple, imaginile pan-clarificate trebuie să fie folosite cu atenție în scopul detectării analitice de la distanță.</div>",
		pathAllocationName: "Alocarea Distanței de Traseu",
		pathAllocationSnip: "Calculează sursa cu cel mai mic cost pentru fiecare celulă pe baza costului cel mai puțin acumulativ pe o suprafață de cost, în timp ce se ține seama de distanța de suprafață și factorii de cost orizontali și verticali.",
		pathAllocationDesc: "Funcția de Alocare a Distanței Traseului calculează cea mai apropiată sursă pentru fiecare celulă pe baza costului cel mai puțin acumulativ pe o suprafață de cost, în timp ce se ține seama de distanța de suprafață și factorii de cost orizontali și verticali.",
		pathBackLinkName: "Link Distanță de Traseu Înapoi",
		pathBackLinkSnip: "Definește vecinul care este celula următoare pe traseul de cost cel mai puțin acumulativ către sursa cu cel mai mic cost, în timp ce se ține seama de distanța de suprafață și factorii de cost orizontali și verticali.",
		pathBackLinkDesc: "Funcția Link Distanță de Traseu Înapoi identifică direcționalitatea vecinului care înseamnă următoarea celulă din cel mai puțin acumulativ traseu de cost către cea mai apropiată sursă, în timp ce se ia în considerare distanța de suprafață și factorii de cost orizontali și verticali.",
		pathDistanceName: "Distanța de Traseu",
		pathDistanceSnip: "Calculează pentru fiecare celulă distanța de cost cel mai puțin acumulativă de la sau către sursa cu cele mai puține costuri, în timp ce se ține seama de distanța de suprafață și factorii de cost orizontali și verticali.",
		pathDistanceDesc: "Funcția Distanței Traseului calculează, pentru fiecare celulă, distanța de cost cel mai puțin acumulativă către cea mai apropiată sursă, în timp ce se ține seama de distanța de suprafață și factorii de cost orizontali și verticali.",
		plusName: "Plus",
		plusSnip: "Adaugă (însumează) valorile a două rastere celulă cu celulă.",
		plusDesc: "Funcția de adunare adaugă (însumează) valorile a două rastere pixel cu pixel.",
		powerName: "Putere",
		powerSnip: "Crește valorile celulei dintr-un raster la puterea valorilor găsite într-un alt raster.",
		powerDesc: "Funcția de putere crește valorile pixelului într-un raster la puterea valorilor găsite într-un alt raster.",
		radarCalibrationName: "Calibrarea radarului",
		radarCalibrationSnip: "Transformă retro-împrăștierea RADARSAT-2.",
		radarCalibrationDesc: "Această funcție poate fi folosită pentru a calibra imaginile RADARSAT-2 într-un set de date mozaic sau ca un produs raster. Calibrarea este efectuată asupra imaginilor radar astfel încât valorile pixelului să fie o reprezentare reală a retro-împrăștierii.",
		rasterInfoName: "RasterInfo",
		rasterInfoSnip: "Modifică proprietățile rasterului, cum ar fi adâncimea bitului, valoarea NoData, dimensiunea celulei și așa mai departe.",
		rasterInfoDesc: "Informații despre Raster deschide un dialog cu proprietățile setului de date raster, cum ar fi numărul de coloane și rânduri, numărul de benzi, tipul pixelului, măsura și referința spațială. Puteți edita aceste proprietăți prin selectarea setului de date raster pentru a îl folosi ca șablon. ",
		rasterizeAttributesName: "Rasterizarea Atributelor",
		rasterizeAttributesSnip: "Îmbogățește un raster prin benzi suplimentare derivate din valorile atributelor specificate ale unui tabel extern sau dintr-un serviciu de obiecte spațiale.",
		rasterizeAttributesDesc: "Funcția de Rasterizare a Atributului îmbogățește un raster prin adăugarea benzilor derivate din atribute specificate, dintr-un tabel extern sau dintr-un serviciu de obiecte spațiale. Puteți specifica în mod opțional un raster de zonă și atributul ID-ului de zonă asociat pentru a permite căutarea pe baza regiunii.",
		rasterizeFeatureClassName: "Rasterizarea obiectelor spațiale",
		rasterizeFeatureClassSnip: "Transformă caracteristicile în raster.",
		rasterizeFeatureClassDesc: "Această funcție transformă datele clasei de obiecte spațiale poligonale, polilinie și puncte într-un strat tematic de raster.<div><br/>Obiectelor spațiale li se alocă valori ale pixelilor pe baza OBJECTID (implicit) al obiectelor spațiale. În mod opțional, valorile pixelilor pot avea la bază o valoare definită de utilizator din tabelul de atribute ale obiectului spațial de intrare.</div>",
		recastName: "Transformare",
		recastSnip: "Modifică parametrii unui lanț de funcții dintr-un set de date mozaic sau serviciu de imagini. Acest lucru este adesea utilizat cu seturi de date LAS pentru a evita necesitatea de a crea un set de date mozaic separat pentru diferite reprezentări ale terenului.",
		recastDesc: "Funcția de transformare este folosită pentru modificarea dinamică a parametrului de funcție folosit într-un set de date mozaic sau serviciu de imagini fără persistența fizică a modificărilor.",
		regionGroupName: "Grup de Regiune",
		regionGroupSnip: "Pentru fiecare celulă din rezultat, este înregistrată identitatea regiunii conectate căreia îi aparține acea celulă. Un număr unic este alocat fiecărei regiuni.",
		regionGroupDesc: "Funcția globală a Regiunii Grupului înregistrează, pentru fiecare celulă din rezultat, identitatea regiunii conectate căreia îi aparține acea celulă. Un număr unic este alocat fiecărei regiuni.<div><br/>Prima regiune scanată primește valoarea unu, a doua primește valoarea doi și tot așa, până când tuturor regiunilor le este alocată câte o valoare. Scanarea se deplasează de la stânga la dreapta și de sus în jos. Valorile alocate zonelor de ieșire se bazează pe momentul în care acestea sunt întâlnite în procesul de scanare.</div>",
		regionGrowName: "Creștere Regiune",
		regionGrowSnip: "Crește regiunile din punctele de plecare.",
		regionGrowDesc: "Funcția de Creștere Regiune grupează pixelii învecinați în grupuri în funcție de raza specificată de la punctul de plecare. Grupului de pixeli sau obiectului li se alocă o valoare de umplere specificată.",
		remapName: "Remapare",
		remapSnip: "Modifică valorile pixelului prin alocarea unor noi valori intervalelor de valori ale pixelului sau cu ajutorul tabelului extern.",
		remapDesc: "Funcția de Remapare vă permite să modificați sau să reclasificați valorile pixelilor datelor raster. Acest lucru poate fi realizat fie prin specificarea unui interval de valori de pixeli pentru cartarea conform unei valori de ieșire a pixelului, sau cu ajutorul unui tabel pentru maparea valorilor pixelului conform valorii de ieșire a pixelului.",
		reprojectName: "Reproiectare",
		reprojectSnip: "Modifică proiectarea unui set de date raster, set de date mozaic sau reper raster într-un set de date mozaic. De asemenea, poate recolecta probele datelor într-o nouă dimensiune de celulă și defini o origine.",
		reprojectDesc: "Funcția de Reproiectare modifică proiectarea unui set de date raster, set de date mozaic sau reper raster într-un set de date mozaic. De asemenea, poate recolecta probele datelor într-o nouă dimensiune de celulă și defini o origine.<div><br/>Funcția de reproiectare poate fi utilizată la crearea unei arhive dintr-un set de date raster sau mozaic care nu intră în proiecția specificată. De exemplu, la crearea unui serviciu de imagini arhivate care pot fi integrate prin aplicații cu alte servicii arhivate, este important ca acestea să se afle în aceeași proiecție. Adesea, aceasta este o proiecție Web Mercator. Din moment de setul de date mozaic nu poate fi reproiectat, aveți două opțiuni—fie creați un set de date mozaic inclus în referințe din setul dvs. de date mozaic în proiecția necesară, sau adăuga funcția de Reproiectare în lanțul de funcții al setului de date mozaic. Un alt exemplu utilizează această funcție de pe reperul raster într-un set de date mozaic. La utilizarea funcției de Raster Arhivat, vă puteți dori să introduceți funcția de Reproiectare astfel încât arhiva să fie creată în noua proiecție. Reperele raster într-un set de date mozaic poate fi arhivat atunci când prelucrarea este intensă și încercați să publicați un serviciu de imagini care este rapid, fără arhivarea întregului serviciu de imagini.</div>",
		resampleName: "Re-colectarea probelor",
		resampleSnip: "Modifică dimensiunea celulei unui raster.",
		resampleDesc: "Funcția de Recolectare a probelor modifică dimensiunea celulei, tipul recolectării sau ambele.<div><br/>Funcția de Recolectare a probelor trebuie utilizată doar cu anumite cerințe de calcul; de exemplu, atunci când calculați magnitudinea-direcția vântului sau curentului care presupune Re-colectarea probelor din rezoluția sursă.</div>",
		roundDownName: "Rotunjire în scădere",
		roundDownSnip: "Dă următoarea valoare mai mică a unui număr întreg, reprezentat ca punct flotant, pentru fiecare celulă dintr-un raster.",
		roundDownDesc: "Funcția de Rotunjire în Scădere dă următorul număr întreg mai mic, ca valoare a unui punct flotant, pentru fiecare pixel dintr-un raster.",
		roundUpName: "Rotunjire în creștere",
		roundUpSnip: "Dă următoarea valoare mai mare a unui număr întreg, reprezentat ca punct flotant, pentru fiecare celulă dintr-un raster.",
		roundUpDesc: "Funcția de Rotunjire în Creștere dă următorul număr întreg mai mare, ca valoare a unui punct flotant, pentru fiecare pixel dintr-un raster.",
		segmentMeanShiftName: "Segment Mean Shift",
		segmentMeanShiftSnip: "Grupează pixelii învecinați cu caracteristici spectrale asemănătoare în segmente.",
		segmentMeanShiftDesc: "Această funcție identifică obiectele, obiectele spațiale sau segmentele din imagistica dvs. grupând împreună pixelii învecinați care au caracteristici spectrale și spațiale asemănătoare. Puteți controla suma nivelării spațiale și spectrale pentru a ajuta la derivarea obiectelor spațiale de interes.",
		s1RadiometricCalibrationName: "Calibrarea Radiometrică Sentinel-1",
		s1RadiometricCalibrationSnip: "Efectuează tipuri diferite de calibrări radiometrice pe datele Sentinel-1.",
		s1RadiometricCalibrationDesc: "Această funcție raster efectuează trei calibrări diferite pentru seturile de date Sentinel 1, inclusiv beta zero și gamma, și obține setul de date calibrat. Obiectivul calibrării SAR este acela de a asigura imagini în care valorile pixelului pot fi aferente direct retro-împrăștierii radarului aferente scenei. Deși imaginile SAR necalibrate sunt suficiente pentru utilizare calitativă, imaginile SAR calibrate sunt esențiale pentru utilizarea cantitativă a datelor SAR.<div><br/>Prelucrarea tipică a datelor SAR, care produce imagini de Nivel 1, nu include corecții radiometrice și rămâne o polarizare radiometrică semnificativă. Prin urmare, este necesar să se aplice o corecție radiometrică imaginilor SAR astfel încât valorile pixelului ale imaginilor reprezintă cu adevărat retro-împrăștierea radarului suprafeței reflectante. Corecția radiometrică este necesară și pentru comparația imaginilor SAR achiziționate cu diverși senzori sau achiziționate din același senzor în momente diferite, în moduri diferite sau prelucrată de procesoare diferite.</div>",
		s1ThermalNoiseRemovalName: "Eliminarea Zgomotului Termic Sentinel-1",
		s1ThermalNoiseRemovalSnip: "Elimină zgomotul termic de la datele Sentinel-1.",
		s1ThermalNoiseRemovalDesc: "Corecția zgomotului termic poate fi aplicată produselor Sentinel-1 Level-1 Single Look Complex (SLC) cât și produselor Level-1 Ground Range Detection (GRD) care nu au fost deja corectate. Operatorul poate elimina această corecție pe baza adnotărilor produsului pentru a reintroduce semnalul de zgomot eliminat pentru a realiza produsul original. Adnotările produsului vor fi actualizate corespunzător pentru a permite reaplicarea corecției. ",
		setNullName: "Setare nulă",
		setNullSnip: "Setare Nulă stabilește amplasarea celulelor identificate către NoData pe baza unui criteriu specificat. Returnează NoData dacă evaluarea condițională este reală, și returnează valoarea specificată de un alt raster dacă este falsă.",
		setNullDesc: "Funcția de Setare Nulă stabilește pixelii identificați către NoData, pe baza criteriilor specifice. Returnează NoData dacă evaluarea condițională este reală (1) și returnează valoarea specificată în Rasterul Fals dacă o evaluare condiționată este falsă (0). Acest criteriu este specificat de rezultatul unei funcții matematice logice, care va fi Rasterul de intrare.",
		shadedReliefName: "Relief cu umbrire",
		shadedReliefSnip: "Creează o reprezentare cu benzi multiple, codificată după culori, 3D a suprafeței, cu poziția relativă a soarelui luată în considerare pentru umbrirea imaginii.",
		shadedReliefDesc: "Funcția de relief cu umbrire creează o reprezentare color 3D a terenului prin fuzionarea imaginilor din metodele codificate după elevație și de hașurare. Această funcție utilizează proprietățile altitudinii și azimutului pentru a specifica poziția soarelui.div><br/></div>",
		sinHName: "SinH",
		sinHSnip: "Calculează sinusul hiperbolic al celulelor dintr-un raster.",
		sinHDesc: "Funcția calculează sinusul hiperbolic al pixelilor dintr-un raster.",
		sinName: "Sin",
		sinSnip: "Calculează sinusul celulelor dintr-un raster.",
		sinDesc: "Funcția calculează sinusul al pixelilor dintr-un raster.",
		slopeName: "Pantă",
		slopeSnip: "Calculează rata de schimbare de la o valoare a pixelului la vecinii săi.",
		slopeDesc: "Această funcție raster calculează panta care reprezintă rata de modificare a elevației pentru fiecare celulă a modelului digital de elevație (DEM). Este prima valoare derivată dintr-un DEM.<div><br/>Această funcție utilizează o funcție atan() accelerată. Aceasta este de șase ori mai rapidă, iar eroarea de aproximare este întotdeauna mai mică de 0,3 grade.</div>",
		speckleName: "Împrăștiere",
		speckleSnip: "Prezintă filtre pentru eliminarea zgomotului seturilor de date ale radarelor cu deschidere sintetică.",
		speckleDesc: "Împrăștierea este zgomotul de înaltă frecvență de pe datele unui radar. Imaginile generate de sistemele de radar cu deschidere sintetică (SAR) sunt foarte supuse efectelor de împrăștiere din cauza prelucrării semnalelor împrăștiate și interferenței undelor electromagnetice împrăștiate de pe suprafețe sau obiecte. Această funcție de Împrăștiere filtrează setul de date radar împrăștiate și aplatizează zgomotul în timp ce reține marginile sau obiectele spațiale clare din imagine.",
		spectralConversionName: "Conversie Spectrală",
		spectralConversionSnip: "Aplică o matrice unei imagini cu benzi multiple.",
		spectralConversionDesc: "Funcția de Conversie Spectrală aplică o matrice unei imagini multibandă pentru a afecta valorile de culoare ale ieșirii.<div><br/>Unii senzori nu colectează benzi albastre din cauza unui raport redus între semnal și zgomot. De exemplu, acest lucru poate fi folosit pentru a converti o imagine infraroșu color falsă într-o pseudo-imagine de culoare naturală.</div>",
		squareRootName: "Rădăcină pătrată",
		squareRootSnip: "Calculează rădăcina pătrată a valorilor celulelor dintr-un raster.",
		squareRootDesc: "Funcția Rădăcină Pătrată calculează rădăcina pătrată a valorilor pixelului dintr-un raster.",
		squareName: "Pătrat",
		squareSnip: "Calculează pătratul valorilor celulei dintr-un raster.",
		squareDesc: "Pătrat calculează pătratul valorilor pixelului dintr-un raster.",
		statisticsHistogramName: "Statistică și Histogramă",
		statisticsHistogramSnip: "Definirea sau asocierea statisticii și histogramei.",
		statisticsHistogramDesc: "Funcția Statistică și Histogramă este utilizată pentru a defini statistica și histograma unui raster. Puteți introduce această funcție la sfârșitul lanțului de funcționare pentru a descrie statistica și histograma unui șablon cu funcție raster (RFT). Acest lucru poate fi necesar pentru a controla afișajul implicit al rezultatului prelucrării, în special la definirea unui lanț de funcționare care conține multe funcții.<div><br/>Puteți defini statisticile prin introducerea valorilor sau importarea dintr-un set de date raster sau un fișier XML. Histogramele pot fi definite doar prin importarea unui fișier.</div>",
		statisticsName: "Statistică",
		statisticsSnip: "Calculează statistica focală pentru fiecare pixel a unei imagini bazate pe o vecinătate focală definită.",
		statisticsDesc: "Funcția de Statistică calculează statistica focală pentru fiecare pixel al unei imagini bazate pe o vecinătate focală definită.<div><br/>Funcția Statistică poate fi utilizată pentru a umple liniile lipsă dintr-o imagine. Liniile lipsă sunt provocate adesea de probleme ale senzorului unde nu sunt colectate date. Acest lucru s-a întâmplat la senzori cum ar fi Landsat 7's Enhanced Thematic Mapper Plus (ETM+). Aceste date lipsă provoacă probleme pentru analiză și la studierea imaginilor. Nu se pot face prea multe la utilizarea imaginii pentru analiză; totuși, dacă a existat o imagine suprapusă, aceasta poate fi folosită în locul conținutului lipsă. Același lucru poate fi realizat dacă imaginile sunt folosite pentru vizualizare. Totuși, nu întotdeauna există o imagine suplimentară pentru a completa conținutul lipsă, așadar acesta trebuie derivat din datele existente.</div>",
		streamLinkName: "Stream Link",
		streamLinkSnip: "Alocă valori unice secțiunilor unei rețele liniare de raster între intersecții.",
		streamLinkDesc: "Funcția globală Stream Link alocă valori unice secțiunilor unei rețele liniare de raster între intersecții.<div><br/>Link-urile sunt secțiunile unui canal de curs care conectează două îmbinări succesive, o îmbinare și evacuarea, sau o îmbinare și linia de separație a apelor de la scurgere. În hidrologie, aceste segmente de curs sunt denumite cursuri de apă. O îmbinare este aferentă unui punct de curgere și ajută la delimitarea unui sub-bazin de recepție sau scurgere.</div>",
		stretchName: "Întindere",
		stretchSnip: "Amplifică o imagine prin ajustarea intervalului de valori afișate. Acest lucru nu modifică valorile pixelilor de la bază. Dacă un pixel are o valoare în afara intervalului specificat, aceasta va apărea fie ca valoare minimă, fie ca valoare maximă.",
		stretchDesc: "Funcția de Întindere amplifică o imagine prin modificarea proprietăților cum ar fi luminozitatea, contrastul și gamma prin tipuri multiple de întindere. Această funcție utilizează statisticile de la rastere din setul de date mozaic; prin urmare, dacă folosiți această funcție, trebuie să vă asigurați că au fost calculate statisticile.<div><br/>Tipul de întindere definește o întindere de histogramă care se va aplica rasterelor pentru amplificarea aspectului acestora. Întinderea îmbunătățește aspectul datelor prin împrăștierea valorilor pixelilor de-a lungul unei histograme de la valorile minimă și maximă definite conform adâncimii bitului. </div>",
		swathName: "Serie",
		swathSnip: "Interpolează din grile neregulate sau date de serie.",
		swathDesc: "Unele seturi de date netCDF sau HDF își stochează geolocarea sub forma unor șiruri așezate la distanțe neregulate. La adăugarea acestor seturi de date într-un set de date mozaic, funcția de serie ia datele cu grilă neregulată și re-colectează probele astfel încât fiecare pixel să aibă dimensiune uniformă și să fie pătrat.<div><br/>La adăugarea variabilelor din netCDF sau HDF într-un set de date mozaic, acesta va verifica în mod automat dacă datele sunt dispuse în șiruri regulate. În caz contrar, funcția de serie se aplică automat pentru transformarea automată a rasterului neregulat în puncte și apoi într-un raster cu grilă regulată. Puteți modifica metoda de interpolare și dimensiunea celulei folosite în funcția de serie a rasterului. Pentru datele cu raster cu distanță regulată, nu se va aplica interpolarea, datele vor fi citite așa cum sunt.</div>",
		tanHName: "TanH",
		tanHSnip: "Calculează tangenta hiperbolică a celulelor dintr-un raster.",
		tanHDesc: "Funcția calculează tangenta hiperbolică a pixelilor dintr-un raster.",
		tanName: "Tan",
		tanSnip: "Calculează tangenta celulelor dintr-un raster.",
		tanDesc: "Funcția calculează tangenta pixelilor dintr-un raster. ",
		tasseledCapName: "Tasseled Cap (Kauth-Thomas)",
		tasseledCapSnip: "Calculează nivelurile de vegetație, umiditate și luminozitate. Această tehnică se bazează pe coeficienți care trebuie calculați în mod specific pentru un senzor.",
		tasseledCapDesc: "Transformarea Tasseled Cap (Kauth-Thomas) este creată pentru a analiza și reprezenta fenomenologia vegetației și modificările de dezvoltare urbană detectate de diverse sisteme de senzori ai unor sateliți. Aceasta este cunoscută sub denumirea de transformarea Tasseled Cap datorită formei distribuției grafice a datelor. Transformarea a oferit un raționament pentru șabloanele descoperite în datele Landsat MSS ale câmpurilor agricole ca funcție a ciclului de viață al recoltei. În principiu, pe măsură ce recoltele se dezvoltă de la sămânță la maturitate, există o creștere netă în ceea ce privește banda de infraroșu apropiat și o descreștere în ceea ce privește reflectanța roșie pe baza culorii solului<div><br/>Utilitatea acestei transformări s-a extins de la monitorizarea recoltelor la analizarea și reprezentarea vegetației pentru a sprijini o varietate de aplicații cum ar fi silvicultura, administrarea vegetației industriale, reprezentarea și administrarea ecosistemului, inventarierea și monitorizarea sechestrării și creditelor de carbon, dezvoltării urbane și mai multe. De asemenea, s-a extins de la sprijinirea Landsat MSS pentru a include și alte sisteme de satelit populare cum ar fi Landsat TM, Landsat ETM+, Landsat 8, IKONOS, QuickBird, WorldView-2 și senzori multispectrali RapidEye.</div>",
		timesName: "Timpi",
		timesSnip: "Înmulțește valorile a două rastere celulă cu celulă.",
		timesDesc: "Funcția de Înmulțire înmulțește valorile a două rastere pixel cu pixel.",
		transposeBitsName: "Transpunere Biți",
		transposeBitsSnip: "Desface biții pixelului de intrare și îi reprezintă conform biților specificați din pixelul de ieșire. Scopul acestei funcții este acela de a manipula biții din câteva intrări, cum ar produsele benzii de calitate Landsat 8.",
		transposeBitsDesc: "Funcția de Transpunere Bit desface biții pixelului de intrare și îi reprezintă conform biților specificați din pixelul de ieșire. Scopul acestei funcții este acela de a manipula biții din câteva intrări, cum ar fi produsele benzii de calitate Landsat 8.",
		unitConversionName: "Conversia Unității",
		unitConversionSnip: "Modifică valorile dintr-o unitate de măsură la alta.",
		unitConversionDesc: "Această funcție transformă pixelii dintr-o unitate într-o altă unitate. Sprijină conversia distanței, vitezei și temperaturii.",
		vectorFieldName: "Câmp vector",
		vectorFieldSnip: "Prezintă seturi de date cu magnitudine (u) și direcție (v) sub forma unor săgeți unde magnitudinea este reprezentată prin dimensiune iar direcția este reprezentată prin unghiul săgeții.",
		vectorFieldDesc: "Funcția Câmp Vector este utilizată pentru a compune și converti două rastere într-un raster cu două benzi care este fie de tipul datelor magnitudine-direcție sau de tipul datelor U-V.<div><br/>Uneori, valoarea U este denumită ca fiind viteza zonală, iar valoarea V este uneori denumită viteza meridională.</div>",
		viewshed2Name: "Rază vizuală",
		viewshed2Snip: "Determină locațiile de pe o suprafață raster care sunt vizibile unui set de obiecte spațiale observatoare, folosind metode geodezice.",
		viewshed2Desc: "Funcția Rază vizuală determină locațiile de pe o suprafață raster care sunt vizibile unui set de obiecte spațiale observatoare, folosind metode geodezice<div><br/>Vizibilitatea fiecărui centru de pixel este determinată de un test pentru linia de vizibilitate între țintă și fiecare observator. Dacă un observator poate vedea ținta la centrul pixelului, pixelul este considerat vizibil. Acest instrument ia în considerare întotdeauna curbura pământului la stabilirea vizibilității.</div>",
		watershedName: "Bazin hidrografic",
		watershedSnip: "Stabilește zona de contribuție de deasupra unui set de celule dintr-un raster",
		watershedDesc: "Funcția globală Rază Vizuală stabilește zona de contribuție de deasupra unui set de pixeli dintr-un raster. Razele vizuale sunt delimitate de un raster de direcție a fluxului care identifică direcția fluxului din fiecare pixel.",
		weightedOverlayName: "Suprapunere ponderată",
		weightedOverlaySnip: "Suprapune mai multe rastere folosind o scară de măsură și o greutate comună conform importanței acesteia.",
		weightedOverlayDesc: "Această funcție vă permite să suprapuneți mai multe rastere folosind o scară de măsură și o greutate comună conform importanței acesteia.",
		weightedSumName: "Sumă Ponderată",
		weightedSumSnip: "Ponderează și adaugă un șir de rastere de la o celulă la alta.",
		weightedSumDesc: "Funcția sumei ponderate vă permite să suprapuneți mai multe rastere, înmulțindu-l pe fiecare cu ponderea alocată și însumarea acestora.",
		windchillName: "Răcire eoliană",
		windchillSnip: "Combină temperatura aerului ambiental și viteza vântului pentru calcularea factorului de răcire eoliană.",
		windchillDesc: "Funcția de Răcire Eoliană este utilă pentru identificarea condițiilor de iarnă periculoase care, în funcție de timpii de expunere la elemente, pot duce la degerături sau chiar la hipotermie. Răcirea eoliană este o modalitate de a măsura frigul resimțit de o persoană atunci când vântul este luat în considerare cu temperaturile deja scăzute. Cu cât este mai mare viteza vântului, cu atât mai repede se va pierde căldura corporală și cu atât mai frig se vor simți.",
		zonalRemapName: "Remapare Zonală",
		zonalRemapSnip: "Remapați pixelii într-un raster pe baza zonelor definite într-un alt raster și o valoare de mapare dependentă de zonă definită într-un tabel.",
		zonalRemapDesc: "Această funcție vă permite să remapați pixelii într-un raster pe baza zonelor definite într-un alt raster și o valoare de mapare dependentă de zonă definită într-un tabel.",
		zonalStatisticsName: "Statistică zonală",
		zonalStatisticsSnip: "Calculează statistici pe baza valorilor unui raster în cadrul zonelor unui alt set de date.",
		zonalStatisticsDesc: "Funcția calculează statistici pe baza valorilor unui raster în cadrul zonelor unui alt set de date. O zonă este definită ca toate suprafețele din intrare care au aceeași valoare. Aceste suprafețe nu trebuie să fie continue. Atunci când intrările de zonă și valoare sunt ambele rastere de aceeași rezoluție, vor fi utilizate direct. Dacă rezoluțiile sunt diferite, o re-colectare pe plan intern este aplicată pentru a corela rezoluțiile înainte de efectuarea operării zonale.",
		flowLengthName: "Lungimea fluxului",
		flowLengthSnip: "Calculează distanța în amonte sau în aval sau distanța ponderată, de-a lungul căii fluxului pentru fiecare celulă.",
		flowLengthDesc: "Aceasta este o funcție raster globală. Această funcție creează un strat tematic raster pentru distanța în amonte sau în aval sau distanța ponderată, de-a lungul căii fluxului pentru fiecare celulă.<div><br/>Utilizarea principală a funcției Lungime flux este calcularea distanței pentru cea mai lungă cale a fluxului în cadrul unui anumit bazin. Această măsurare este utilizată deseori pentru a calcula timpul de concentrare pentru un bazin. Acest lucru se efectuează utilizând opțiunea Amonte. Această funcție poate fi utilizată și pentru a crea diagrame distanță-zonă pentru precipitațiile și efectele ploilor torențiale ipotetice, utilizând rasterul de greutate ca impedanță privind mișcarea în pantă.</div>",
		streamOrderName: "Ordonare flux",
		streamOrderSnip: "Atribuie o ordine numerică segmentelor unui raster care reprezintă ramificațiile unei rețele liniare",
		streamOrderDesc: "Aceasta este o funcție raster globală. Această funcție creează un strat tematic de raster care atribuie o ordine numerică pentru segmentele unui raster care reprezintă ramificațiile unei rețele liniare.<div><br/>Rezultatul funcției Ordonare flux va fi unul de înaltă calitate dacă stratul tematic de raster al fluxului de intrare și stratul tematic de raster al direcției fluxului de intrare sunt derivate pe baza aceleiași suprafețe. Dacă rasterul de flux este derivat pe baza unui set de date al fluxurilor rasterizate, rezultatul nu poate fi utilizat, deoarece direcția nu va corespunde locației celulelor fluxului, de la celulă la celulă. Rezultatele funcției Acumulare flux pot fi utilizate pentru a crea o rețea de flux de raster prin aplicarea unei valori de prag pentru a selecta celule cu un flux cu o acumulare mare. De exemplu, celulele cu un flux mai mare de 100 celule în acestea sunt utilizate pentru definirea rețelei de flux. Utilizați funcția Con sau Setare nul pentru a crea un raster de rețea de flux în care valorile de acumulare a fluxului de 100 sau mai multe celule sunt setate la 1, iar celelalte sunt puse în fundal (NoData). Rețeaua de flux rezultată poate fi utilizată în funcția Ordonare flux. Această funcție acceptă doar un strat tematic raster de direcție a fluxului de intrare D8. Direcțiile de flux D8 pot fi create utilizând funcția Direcție flux și sunt executate cu tipul de direcție a fluxului implicit.</div>",
		snapPourPointName: "Fixare punct de curgere",
		snapPourPointSnip: "Fixează punctele de curgere în celula cu cea mai mare acumulare de flux pe o distanță specificată",
		snapPourPointDesc: "Aceasta este o funcție raster globală. Această funcție fixează punctele de curgere în celula cu cea mai mare acumulare de flux pe o distanță specificată.<div><br/>Funcția Fixare punct de curgere este utilizată pentru a asigura selectarea punctelor cu un flux cu acumulare mare la delimitarea bazinelor hidrografice utilizând funcția Bazin hidrografic. „Fixare punct de curgere” va căuta pe o distanță fixată în jurul punctelor de curgere specificate pentru celula cu fluxul cu cea mai mare acumulare și va muta punctul de curgere în locația respectivă. Rezultatul este un strat tematic de raster cu numere întregi atunci când locațiile punctelor de curgere au fost fixate în locațiile fluxului cu cea mai mare acumulare.</div>",
		sinkName: "Dolină",
		sinkSnip: "Creează un raster care identifică toate dolinele sau zonele de scurgere internă",
		sinkDesc: "Aceasta este o funcție raster globală. Această funcție creează un strat tematic de raster care identifică toate dolinele sau zonele de scurgere internă. O dolină este o celulă sau un set de celule conectate spațial cu o direcție a fluxului care nu poate fi atribuită uneia dintre cele opt valori valide dintr-un raster de direcție a fluxului. Acest lucru se poate întâmpla dacă celulele învecinate sunt mai mari decât celula procesată sau atunci când două celule au un flux reciproc, creând o buclă de două celule.<div><br/>Funcția Dolină acceptă doar un strat tematic raster de direcție a fluxului de intrare D8. Direcțiile de flux D8 pot fi create utilizând funcția Direcție flux și sunt executate cu tipul de direcție a fluxului implicit. Rezultatul funcției Dolină este un raster cu numere întregi, fiecărei doline fiindu-i atribuită o valoare unică. Aceste valori unice au un interval cuprins între 1 și numărul total de doline. De exemplu, dacă numărul total de doline este 1000, valorile unice vor fi cuprinse între 1 și 1000.</div>",
		aggregateName: "Însumare",
		aggregateSnip: "Generează o versiune de rezoluție redusă a unui raster.",
		aggregateDesc: "Funcția Însumare reeșantionează un raster de intrare la o rezoluție mai grosieră, pe baza unei strategii de însumare specifice. Fiecare celulă de ieșire conține Suma, Minimum, Maximum sau Mediu pentru celulele de intrare care sunt cuprinse de mărimea celulei respective.<div><br/>Factorul cu care trebuie să se înmulțească dimensiunea celulei rasterului de intrare. De exemplu, o valoare de 3 a factorului de celulă ar duce la o dimensiune a celulei de ieșire de trei ori mai mare decât aceea a rasterului de intrare. Puteți defini modul de manipulare a mărimii de ieșire dacă numărul de rânduri sau coloane din intrare nu este un multiplu exact al factorului de celulă. În mod implicit, limita superioară și cea dreaptă vor fi extinse pentru a acoperi o mărime spațială mai mare decât cea a rasterului de intrare, pentru a asigura faptul că sunt procesate toate celulele de intrare. În mod alternativ, limita superioară și cea dreaptă pot fi reduse pentru a acoperi o mărime mai mică, astfel încât numărul de rânduri și de coloane procesate să fie un multiplu exact al factorului de celulă. Puteți defini modul în care celule NoData trebuie manipulate de către calculul de însumare. Mecanismul implicit este faptul că celule NoData de intrare care se încadrează în mărimea spațială a unei celule mai mari din rasterul de ieșire vor fi ignorate la determinarea valorii celulei de ieșire respective. În mod alternativ, puteți specifica faptul că, dacă există chiar și o celulă NoData de intrare individuală în cadrul mărimii spațiale a unei celule de ieșire, celula respectivă va fi NoData în rasterul de ieșire.</div>",
		ccdcName: "Analiza CCDC",
		ccdcSnip: "Evaluează modificările în ceea ce privește valorile pixelilor odată cu trecerea timpului utilizând algoritmul de Detectare și Clasificare a Modificării Continue (CCDC) și generează rezultate model.",
		ccdcDesc: "Funcția de Analiză CCDC evaluează modificările în ceea ce privește valorile pixelilor odată cu trecerea timpului utilizând algoritmul de Detectare și Clasificare a Modificării Continue (CCDC) și generează un raster multidimensional care conține rezultatele de model. Acesta este acceptat numai împreună cu funcția Detectare modificare utilizând analiza de modificări în cadrul unui șablon de funcție raster. Pentru a realiza o ieșire de raster, conectați funcția Analiză CCDC la funcția Detectarea modificărilor utilizând analiza de modificări, salvați ca șablon de funcție raster și rulați Analiză raster cu șablonul de funcție.<div><br/>Această funcție utilizează algoritmul de Detectare și Clasificare a Modificării Continue (CCDC) pentru a evalua modificările privind valorile pixelilor odată cu trecerea timpului pentru o stivă de imagini. În cadrul unei serii temporale de imagini optice sau derivate de imagini (de exemplu, NDVI), valorile pixelilor pot fluctua din mai multe motive: 1. Modificare sezonieră -- Modificările valorilor pixelilor reflectă modificări ale vegetației din cauza variabilității sezoniere a temperaturii și a precipitațiilor. În Emisfera nordică, de exemplu, ne așteptăm să vedem o densitate mai mare a vegetației verde pe timpul verii, în comparație cu iarna; 2. Modificarea graduală -- Modificările valorilor pixelilor reflectă tendințele vegetației sau ale apei de suprafață din cauza variabilității climatice sau a practicilor de administrare a solurilor pe termen lung. De exemplu, suprafața solului dezgolit pot să crească gradual ca urmare a declinului precipitațiilor pe termen lung; și 3. Modificare bruscă -- Modificările valorilor pixelilor reflectă modificările acoperirii solurilor care au loc brusc din cauza despăduririi, a dezvoltării urbane, a dezastrelor naturale etc. Algoritmul CCDC identifică toate cele trei tipuri de modificări cu scopul primar de identificare a modificării bruște. Regresia armonică și modelele de tendință sunt adaptate la date pentru a estima modificarea sezonieră și graduală, iar abaterile bruște de la modelele de tendințe reprezintă indicații ale modificării bruște.<div><br/>Algoritmul CCDC a fost inițial conceput pentru datele de Temperatură luminozitate sau Reflectanță suprafață Landsat TM, Landsat ETM+ și Landsat OLI. Cu toate acestea, funcția Detectarea modificărilor utilizând analiza de modificări, utilizată împreună cu această funcție, va detecta modificarea pentru imaginile cu benzi multiple de la orice senzor compatibil, precum și derivatele de imagini cu o singură bandă, precum indicii de bandă. De exemplu, puteți efectua detectarea modificării continue asupra unui raster de Indice de Vegetație Diferență Normalizată (NDVI), deoarece modificările bruște în NDVI pot indica despădurirea.</div>",
		computeChangeName: "Calculare modificare",
		computeChangeSnip: "Calculează diferența dintre două seturi de date de raster categorice sau continue.",
		computeChangeDesc: "Funcția Calculare modificare poate fi utilizată pentru a enumera diferențele dintre două rastere clasificate pentru analiza de modificări a acoperirii solurilor sau poate fi utilizată pentru a examina modificările între două rastere continue cu o singură bandă, precum elevația, temperatura, coronamentul etc.",
		detectChangeName: "Detectarea modificărilor utilizând analiza de modificări",
		detectChangeSnip: "Generează un strat tematic de raster care conține informații despre modificările pixelilor utilizând rasterul de analiză a modificărilor de ieșire.",
		detectChangeDesc: "<div>Funcția Detectarea modificărilor utilizând analiza de modificări generează un strat tematic de raster care conține informații despre data modificării pixelilor utilizând rasterul de analiză a modificărilor. Rasterul de analiză a modificărilor trebuie să fie generat de Analizați modificările cu ajutorul instrumentului CCDC sau de Analizați modificările cu ajutorul instrumentului LandTrendr, sau funcția raster de analiză CCDC sau funcția raster de analiză LandTrendr.</div><br><div>Această funcție raster poate fi combinată cu funcția raster de analiză CCDC sau funcția raster de analiză LandTrendr într-un șabpon de funcție raster. Pentru a realiza o ieșire de raster permanentă, conectați ieșirea funcției Analiză CCDC sau Analiză LandTrendr la funcția Detectarea modificărilor utilizând analiza de modificări, salvați ca șablon de funcție raster și rulați Analiză raster cu șablonul.</div><br><div>Parametrul <strong>Tipul Schimbării</strong> indică informațiile generate. Informațiile sunt extrase din rasterul de analiză a schimbării. La rularea acestei funcții pe ieșirea din funcția/instrumentul CCDC, puteți alege dintre opțiunile următoare:</div><ul><li><strong>Ora celei mai recente schimbări</strong>--Cea mai recentă dată și oră la care un pixel a fost marcat ca fiind schimbat.</li><li><strong>Ora celei mai vech schimbări</strong>--Cea mai veche dată și oră la care un pixel a fost marcat ca fiind schimbat.</li><li><strong>Ora celei mai mari schimbări</strong>--Data și ora la care schimbarea calculată au fost cele mai semnificative pentru un pixel.</li><li> <strong>Număr de schimbări</strong>--Numărul total de schimbări ale pixelului.</li></ul><div>La rularea acestei funcții pe ieșirea din funcția/instrumentul LandTrendr, sunt disponibile opțiunile suplimentare următoare:</div><ul><li><strong>Ora celei mai lungi schimbări</strong>--Data la care un pixel a fost marcat ca fiind schimbat, la începutul sau sfârșitul celei mai lungi perioade de schimbare.</li><li><strong>Ora celei mai scurte schimbări</strong>--Data la care un pixel a fost marcat ca fiind schimbat, la începutul sau la sfârșitul celei mai scurte perioade de schimbare.</li><li><strong>Ora celei mai rapide schimbări</strong>--Data la care un pixel a fost marcat ca fiind schimbat, la începutul sau sfârșitul celei mai rapide perioade de schimbări.</li><li><strong>Ora celei mai lente schimbări</strong>--Data la care un pixel a fost marcat ca fiind schimbat, la începutul sau la sfârșitul celei mai lente perioade de schimbare.</li></ul><div>Rasterul de ieșire este un raster cu bandă multiplă în care fiecare bandă conține informații despre schimbare în funcție de tipul de schimbare selectat și de numărul maxim de schimbări specificate. De exemplu, dacă <strong>Tipul Schimbării</strong> este setat la <strong>Ora Celei Mai Vechi Schimbări</strong> și <strong>Numărul Maxim de Schimbări</strong> este setat la 2, funcția calculează cele două date cele mai vechi când a apărut schimbarea în cadrul seriei de timp pentru fiecare pixel. Rezultatul este un raster în care prima bandă conține datele celei mai vechi schimbări după pixel, iar a doua bandă conține datele celei de-a doua cele mai vechi schimbări după pixel.</div><br><div>La aplicarea acestei funcții pe ieșirea din instrumentele LandTrendr, puteți alege dacă să extrageți data care marchează începutul sau sfârșitul unei schimbări cu ajutorul parametrului <strong>Data Segmentului</strong>. De exemplu, pentru a înțelege cum a început cea mai recentă schimbare din seria de timp, setați <strong>Tipul Schimbării</strong> la <strong>Ora celei mai recente schimbări</strong> și <strong>Data Segmentului</strong> la <strong>Începutul segmentului</strong>.</div><br><div>Folosiți parametrii de filtrare de mai jos pentru a extrage date de schimbare mai specifice din rasterul dvs. de analiză a schimbării:</div><ul><li><strong>Filtrați după an</strong>--Identificați modificările apărute într-o perioadă specifică, de exemplu, dacă căutați schimbările apărute într-un peisaj în timpul unei secete de cinci ani.</li><li><strong>Filtrați după durată</strong>--Identificați schimbările apărute într-un anumit interval de ani, de exemplu, dacă căutați doar schimbările bruște apărute în 1 sau 2 ani. Puteți calcula durata care vă interesează cu ajutorul formulei <strong>anul de sfârșit - anul de început +1</strong>. Vor fi incluse și spațiile goale din seria de timp.</li><li><strong>Filtrați după magnitudine</strong>--Identificați schimbările conform unei magnitudini date, de exemplu, dacă căutați doar schimbările mari din indicele de vegetație NDVI. Magnitudinea este o valoare absolută, așadar valorile minime și maxime nu pot fi negative. Pentru a specifica schimbarea direcțională, folosiți parametrul <strong>Direcția Schimbării</strong>.</li></ul>",
		distanceAccumulationName: "Acumularea distanței",
		distanceAccumulationSnip: "Calculează distanța acumulată pentru fiecare celulă la surse, permițând distanța de linie dreaptă, distanța de cost, distanța de suprafață reală, precum și factorii de cost verticali și orizontali.",
		distanceAccumulationDesc: "Acumularea distanței calculează distanța pentru fiecare locație din zona de studiu până la cea mai apropiată sursă sau cu costul cel mai mic. Dacă sunt furnizate doar sursele pentru intrare, atunci este calculată o distanță de linie dreaptă pentru fiecare locație din zona de studiu. Dacă ambele surse și bariere sunt utilizate ca intrare, Acumularea distanței calculează distanța de linie dreaptă din preajma barierelor. Atât pentru rasterul sursă, cât și pentru rasterul de barieră, valoarea de fundal trebuie să fie NoData, în timp ce sursele și barierele sunt reprezentate cu valori de celule valide. Valorile valide includ zero. <div><br/>Atunci când un raster de suprafață este furnizat ca intrare, este calculată distanța suprafeței efective dintre celule. Pentru a efectua analiza de cost utilizând Acumularea distanței, este necesară o suprafață de cost. Dacă este furnizată o suprafață de cost, rezultatul este un raster de distanță de cost acumulat. Atunci când sunt furnizați factori orizontali și verticali, direcționalitatea este luată în considerare ca și cum costul ar fi acumulat. Există patru caracteristici sursă care pot fi utilizate. Aceste caracteristici, care pot fi ale sursei sau ale elementelor de deplasare din sursă, sunt controlate de parametri specifici: 1. Acumularea inițială : setează costul inițial înainte de a începe mișcarea. 2. Acumularea maximă: specifică costul pe care o sursă îl poate acumula înainte de atingerea limitei sale. 3. Multiplicatorul de aplicat la costuri: specifică modul de deplasare sau magnitudinea la sursă. 4 Direcția de deplasare: identifică dacă elementul de mutare începe la o sursă și se deplasează către locații diferite de sursă sau dacă începe la locații diferite de sursă și se deplasează înapoi la o sursă.<div><br/>În mod implicit, rezultatul de la Acumularea distanței are o singură bandă, care reprezintă rasterul de acumulare a distanței. Cu toate acestea, poate fi creată și o bandă secundară, banda de direcție inversă. Această bandă indică ce direcție trebuie urmată de la fiecare locație din zona de studiu pentru a ajunge la sursa cu cele mai mici costuri. Ambele benzi vor fi necesare pentru a determina traseele optime în cadrul zonei de studiu. Pentru a genera un traseu, mai întâi utilizați funcția Extragerea Benzilor pentru a extrage rasterul de acumulare a distanței și rasterul de direcție inversă. Utilizați aceste straturi tematice ca intrare pentru funcția Traseu de Cost. În funcție, utilizați rasterul de acumulare a distanței ca intrare de raster cost-distanță și rasterul de direcție inversă ca intrare de raster de legătură inversă.</div>",
		distanceAllocationName: "Alocarea Distanței",
		distanceAllocationSnip: "Calculează alocarea distanței pentru fiecare celulă la sursele furnizate, bazându-se pe distanța de linie dreaptă, distanța de cost, distanța de suprafață reală, precum și factorii de cost verticali și orizontali.",
		distanceAllocationDesc: "Alocarea Distanței calculează la ce sursă este alocată fiecare locație din zona de studiu. Dacă sunt furnizate doar sursele pentru intrare, atunci locațiile sunt alocate utilizând o distanță de linie dreaptă față de cea mai apropiată sursă. Dacă ambele surse și bariere sunt utilizate ca intrare, Alocarea distanței calculează distanța de linie dreaptă din preajma barierelor pentru a determina cărei surse îi este alocată o locație. Atât pentru rasterul sursă, cât și pentru rasterul de barieră, valoarea de fundal trebuie să fie NoData, în timp ce sursele și barierele sunt reprezentate cu valori de celule valide. Valorile valide includ zero.<div><br/>Pentru a efectua analiza de cost utilizând Alocarea distanței, este necesară o suprafață de cost. Dacă este furnizată o suprafață de cost, rezultatul va fi un raster de alocare bazat pe cost acumulativ, nu pe distanța de linie dreaptă. Atunci când sunt furnizați factori orizontali și verticali, direcționalitatea este luată în considerare ca și cum costul ar fi acumulat. Atunci când un raster de suprafață este furnizat ca intrare, este calculată distanța suprafeței efective acoperite la trecerea dintre celule, atunci când alocarea este determinată. Există patru caracteristici sursă care pot fi utilizate. Aceste caracteristici, care pot fi ale sursei sau ale elementelor de deplasare din sursă, sunt controlate de parametri specifici: 1. Acumularea inițială : setează costul inițial înainte de a începe mișcarea. 2. Acumularea maximă: specifică costul pe care o sursă îl poate acumula înainte de atingerea limitei sale. 3. Multiplicatorul de aplicat la costuri: specifică modul de deplasare sau magnitudinea la sursă. 4 Direcția de deplasare: identifică dacă elementul de mutare începe la o sursă și se deplasează către locații diferite de sursă sau dacă începe la locații diferite de sursă și se deplasează înapoi la o sursă.<div><br/>În mod implicit, rezultatul de la Alocarea distanței are o singură bandă, care reprezintă rasterul alocării distanței. Bifarea opțiunii Boolean Generare rând și coloană sursă ca benzi suplimentare la ieșire va avea ca rezultat un raster cu benzi multiple care constă în trei benzi. Prima bandă este banda de alocare a distanței, a doua bandă include un indice de rând, iar a treia bandă include un indice de coloană. Acești indici identifică amplasarea celulei sursă care este la cea mai mică distanță de cost acumulată. Indexul rândului sursă și indexul coloanei sursă pot fi utilizate împreună pentru a efectua maparea intensității. Dacă interogați orice locație din zona dvs. de studiu din benzile doi și trei, veți afla rândul și coloana sursei cu costul cel mai mic pentru locația respectivă.</div>",
		eucBackDirectionName: "Direcție Inversă Euclidiană",
		eucBackDirectionSnip: "Calculează, pentru fiecare celulă, direcția, în grade, până la celula vecină de-a lungul celui mai scurt traseu înapoi către cea mai apropiată sursă în timp ce se evită barierele.",
		eucBackDirectionDesc: "Funcția Direcția Inversă Euclidiană are ca rezultat un raster de punct flotant continuu, care reprezintă direcția în grade înapoi la cea mai apropiată sursă, evitând barierele, dacă sunt furnizate bariere.<div><br/>Intrările pentru Direcția Inversă Euclidiană reprezintă sursa utilizată pentru calcularea direcției respective. O intrare opțională este un raster care reprezintă bariere în cadrul zonei de studiu. Atât pentru rasterul sursă, cât și pentru rasterul de barieră, valoarea de fundal trebuie să fie NoData, în timp ce sursele și barierele sunt reprezentate cu valori valide. Valorile valide includ zero. În mod implicit, calculul va procesa mărimea combinată a surselor și a barierelor, plus 2 rânduri și coloane. Dacă analiza este necesară numai în cadrul unei distanțe specificate față de surse, poate fi utilizat parametrul Distanță maximă. Direcția Inversă Euclidiană acceptă atât o metodă În plan, cât și o metodă Geodezică, în calcul. Metoda de calcul În plan va fi realizată pe un plan plat proiectat folosind un sistem de coordonate cartezian 2D. Metoda de calcul Geodezică va fi efectuată asupra elipsoidului, ceea ce înseamnă că, indiferent de proiecția de intrare sau de ieșire, rezultatelor nu se modifică.<div><br/>Rezultatul din funcția Direcție Inversă Euclidiană va fi utilizat împreună cu rezultatul din funcția Distanță Euclidiană pentru a determina cele mai scurte trasee de la locațiile din cadrul zonei de studiu înapoi la sursă. Atât rezultatul pentru Direcția Inversă Euclidiană, cât și rezultatul Distanța Euclidiană, sunt utilizate în funcția Traseu de Cost, împreună cu destinațiile, pentru a genera cele mai scurte trasee.</div>",
		expandName: "Extindere",
		expandSnip: "Extinde zonele selectate ale unui raster după zone și după un număr specificat de celule.",
		expandDesc: "Cu funcția globală Extindere, puteți generaliza sau simplifica rastere prin mărirea unor anumite zone. De asemenea, puteți controla gradul de generalizare ce va avea loc.<div><br/>Zonele pe care le selectați vor crește ca dimensiune prin extinderea în celelalte zone. Din punct de vedere conceptual, Valorile de zonă selectate pot fi vizualizate ca zone de prim plan, în timp ce celelalte valori rămân valori în fundal. Zonele de prim plan se pot extinde în zonele de fundal.<div><br/>Gradul de generalizare poate fi controlat cu parametrul Număr de celule. În mod implicit, această valoare este 1, ceea ce înseamnă că zonele selectate se vor extinde cu o valoare corespunzătoare dimensiunii unei celule. Pentru a mări gradul de generalizare, puteți specifica o valoare mai mare pentru acest parametru. Din punct de vedere conceptual, acest lucru este similar rulării instrumentului cu un număr echivalent celui specificat, iar rezultatele rulării anterioare reprezintă intrarea în iterația ulterioară.</div>",
		trendAnalysisName: "Generarea Tendinței",
		trendAnalysisSnip: "Estimează tendința pentru fiecare pixel din una sau mai multe variabile dintr-un raster multidimensional.",
		trendAnalysisDesc: "<div>Această funcție poate fi utilizată pentru aplicarea datelor pe o linie de tendință liniară, armonică sau polinomială, sau poate fi folosită pentru efectuarea detectării tendinței cu ajutorul testului Mann-Kendall sau Seasonal-Kendall.</div><br><div>Rasterul de tendință de ieșire generat cu această funcție este folosit ca intrare în funcția <strong>Preconizați cu ajutorul tendinței</strong>.</div><br><div>Testele Mann-Kendall și Seasonal-Kendall sunt folosite pentru a stabili dacă există o tendință monotonică în cadrul datelor. Acestea sunt non-parametrice, adică nu pleacă de la premisa unei distribuiri specifice a datelor. Testul Mann-Kendall nu ia în considerare corelarea serială sau efectele sezoniere. Dacă datele sunt sezoniere, testul Seasonal-Kendall este mai potrivit.</div><br><div>Dacă instrumentul este folosit pentru efectuarea testului Mann-Kendall sau a testului Seasonal-Kendall, rezultatul este un raster cu cinci benzi după cum urmează:</div><ul><li>Banda 1 = panta lui Sen</li><li>Banda 2 = valoarea p</li><li>Banda 3 = punctajul Mann-Kendall (S)</li><li>Banda 4 = Fluctuația S</li><li>Banda 4 = Fluctuația S</li><li>Banda 5 = Punctajul Z</li></ul><div>Ieșirile din testul Mann-Kendall sau Seasonal-Kendall pot fi folosite pentru a stabili care pixeli din seria dvs. multidimensională de timp au o tendință cu semnificație statistică. Puteți folosi aceste informații împreună cu analiza tendinței liniare, armonice sau polinomiale pentru a extrage tendințele semnificative din seria dvs. de timp. Puteți genera o mască incluzând pixelii cu valori p semnificative, aplicați masca rasterului multidimensional și folosi acest raster multidimensional cu mască pe post de intrare în instrument pentru efectuarea analizelor tendințelor liniare, armonice sau polinomiale.</div><br><div>Există trei opțiuni ale liniei de tendință pentru corelarea unei tendințe cu valorile variabile de-a lungul unei dimensiuni: liniară, polinomială și armonică.</div><br><div>Pentru analiza tendinței liniare, ieșirea este un raster cu trei benzi după cum urmează:</div><ul><li>Banda 1 = Pantă</li><li>Banda 2 = Interceptare</li><li>Banda 3 = eroarea mediei pătratice (RMSE) sau eroarea din jurul rândului care se potrivește cel mai bine</li></ul><div>Pentru analiza tendinței polinomiale, numărul de benzi din ieșire depinde de ordinea polinomială. Ajustarea polinomială de ordinul doi realizează un raster cu patru benzi după cum urmează:</div><ul><li>Banda 1 = Polynomial_2</li><li>Banda 2 = Polynomial_1</li><li>Banda 3 = Polynomial_0</li><li>Banda 4 = RMSE</li></ul><div>Ajustarea polinomială de ordinul trei realizează un raster cu cinci benzi după cum urmează:</div><ul><li>Banda 1 = Polynomial_3</li><li>Banda 2 = Polynomial_2</li><li>Banda 3 = Polynomial_1</li><li>Banda 4 = Polynomial_0</li><li>Banda 5 = RMSE</li></ul><div>Pentru analiza tendinței armonice, numărul de benzi din ieșire depinde de frecvența armonică. Când frecvența este setată la 1, iețirea este un raster cu cinci benzi după cum urmează:</div><ul><li>Banda 1 = Pantă</li><li>Banda 2 = Interceptare</li><li>Banda 3 = Harmonic_sin1</li><li>Banda 4 = Harmonic_cos1</li><li>Banda 5 = RMSE</li></ul><div>Când frecvența este setată la 2, ieșirea este un raster cu șapte benzi după cum urmează:</div><ul><li>Banda 1 = Pantă</li><li>Banda 2 = Interceptare</li><li>Banda 3 = Harmonic_sin1</li><li>Banda 4 = Harmonic_cos1</li><li>Banda 5 = Harmonic_sin2</li><li>Banda 6 = Harmonic_cos2</li><li>Banda 7 = RMSE</li></ul><div>Parametrul <strong>Lungimea Ciclului</strong> pentru analiza tendinței armonice este folosit pentru a indica numărul și lungimea ciclurilor pe care vă așteptați să le vedeți în datele dvs. pe durata unei zile sau a unui an. De exemplu, dacă vă așteptați ca datele dvs. să treacă prin două cicluri de variație pe parcursul unui an, lungimea ciclului va fi de 182,5 zile sau de 0,5 ani. Dacă aveți date despre temperatură colectate la fiecare trei ore și există un ciclu de variație pe zi, lungimea ciclului este de o zi.</div><br><div>Parametrul <strong>Frecvență</strong> pentru analiza tendinței armonice este folosit pentru a descrie modelul armonic care să corespundă datelor. Dacă frecvența este setată la 1, o combinație a unei curbe armonice liniare și de prim ordin va fi folosită pentru a corespunde modelului. Dacă frecvența este 2, o combinație a curbei armonice liniare, de prim ordin și a curbei armonice de ordin doi va fi folosită pentru a corespunde datelor. Dacă frecvența este 3, o curbă armonică suplimentară de ordin trei va fi folosită pentru modelarea datelor, și așa mai departe.</div><br><div>Statisticile privind indicele de concordanță al modelului pot fi generate ca ieșiri opționale. Eroarea rădăcinii medii pătrate (RMSE), R pătrat și valoarea p a pantei de tendință pot fi calculate și simbolizate. Simbolizați stratul tematic al rasterului de tendință de ieșire cu ajutorul semioticii <strong>RGB</strong> și specificați statisticile ca fiind benzile roșie, verde și albastră.</div><br>",
		spectralUnmixingName: "Stratificarea spectrală liniară",
		spectralUnmixingSnip: "Efectuează clasificarea subpixelilor și calculează abundența fracționară a tipurilor diferite de acoperiri de sol pentru pixeli individuali.",
		spectralUnmixingDesc: "Funcția Stratificarea spectrală liniară calculează acoperirea fracționară pentru pixeli individuali care conțin mai multe tipuri de acoperiri de sol. Generează un strat tematic cu benzi multiple, unde fiecare bandă corespunde abundenței fracționare a fiecărei clase de acoperire de sol. De exemplu, dacă o utilizați pentru a efectua clasificarea acoperirii de sol pe o imagine multispectrală pentru identificarea vegetației fotosintetice, solul dezgolit și vegetația moartă sau nefotosintetică.<div><br/>Ordinea rasterului cu benzi multiple de ieșire urmează ordinea profilului spectral de intrare. Numărul de clase nu poate depăși numărul de benzi din rasterul de intrare. De exemplu, nu puteți extrage informații despre mai mult de 8 clase dintr-un raster de 8 benzi.</div>",
		multidimensionalFilterName: "Filtru multidimensional",
		interpolateRasterByDimensionFunctionName: "Interpolați rasterul în funcție de dimensiune",
		interpolateRasterByDimensionFunctionSnip: "Interpolează un raster multidimensional la valorile de dimensiune specificate folosind segmente adiacente.",
		interpolateRasterByDimensionFunctionDesc: "<p>Această funcție vă permite să estimați valorile în pixeli pentru o dimensiune nedefinită dintr-un raster multidimensional. De exemplu, dacă aveți un set de date care conține temperatura oceanului la nivelul de suprafață și la 100 de metri sub nivelul mării și doriți să estimați temperatura la sub 50 de metri sub nivelul mării, puteți utiliza această funcție pentru a obține o estimare la acea adâncime folosind definiția dimensiunii după valori.</p><p>Puteți, de asemenea reduceți numărul de probe ale unui set de date lunar la un set de date zilnic folosind definiția dimensiunii după interval și specificând valoarea parametrului Pas la 1 și valoarea parametrului Unitate la Zile.</p><p>Folosiți definiția dimensiunii rasterului în funcție de țintă pentru a estima valoarea pentru Rasterul țintă.</p>",
		multidimensionalFilterSnip: "Creează un strat tematic raster dintr-un set de date de raster multidimensional prin segmentarea datelor la nivelul variabilelor și al dimensiunilor definite.",
		multidimensionalFilterDesc: "Filtrul multidimensional creează un strat tematic de raster multidimensional prin filtrarea și extragerea unui subset de variabile dintr-un raster multidimensional. De exemplu, aveți un set de date multidimensional care conține date lunare despre precipitații pentru 30 de ani și doriți să extrageți doar datele pentru ianuarie pentru a vedea cum s-au schimbat precipitațiile pentru luna respectivă.<div><br/>Utilizarea parametrului Definiția dimensiunii pentru a segmenta dimensiunile utilizând un interval, o valoare sau un interval de valori. De exemplu, dacă aveți date despre salinitatea oceanelor pentru 10 ani, colectate lunar și la o adâncime de 2 până la 500 de metri, ați putea utiliza opțiuni diferite pentru definiția dimensiunii pentru următoarele scenarii. Scenariul 1: Extrageți date despre salinitate pentru ianuarie pentru perioade de 10 ani. Alegeți După valori, setați Dimensiune la StdTime și Valori la Ianuarie. Scenariul 2: Segmentați datele despre salinitate după un interval de adâncime, de la 0 la 150 de metri. Alegeți După intervale, setați Dimensiune la StdZ și Valoare minimă la -150, iar Valoare maximă la 0. Scenariul 3: Extrageți date despre salinitate pentru primele 10 zile din ianuarie pentru o perioadă de 10 ani. Alegeți După iterație, setați Dimensiune la StdTime, setați Începutul primei iterații și Sfârșitul primei iterații la începutul și sfârșitul corespunzătoare pentru perioada de iterație, setați Pasul la 1 și Unitate la Ani.</div>",
		multidimensionalRasterName: "Raster multidimensional",
		multidimensionalRasterSnip: "Adaugă date multidimensionale la o hartă ca un strat tematic de raster multidimensional.",
		multidimensionalRasterDesc: "Funcția Raster multidimensional adaugă date multidimensionale la o hartă ca un strat tematic de raster multidimensional. Această funcție este utilă la efectuarea fluxurilor de lucru pentru analiza de raster utilizând un lanț de funcții.<div><br/>Seturile de date raster multidimensional acceptate includ netCDF, GRIB, HDF și CRF de la Esri. De asemenea, sunt acceptate seturi de date mozaic multidimensionale.</div>",
		optimalPathAsRasterName: "Traseu optim ca raster",
		optimalPathAsRasterSnip: "Calculează traseul cu cel mai mic cost dintr-o sursă la o destinație.",
		optimalPathAsRasterDesc: "Această funcție globală produce un raster de ieșire care înregistrează traseul sau traseele optime din locații selectate până la cea mai apropiată sursă definită în suprafața de cost acumulativă, cu privire la distanța de cost.<div><br/>Una sau mai multe funcții de cost ponderat (Acumularea Distanței și Alocarea Distanței) trebuie, în general, rulate înainte de rularea funcției Traseu optim ca raster pentru crearea rasterelor de acumulare a distanței și de direcție inversă de intrare. Acestea sunt straturi tematice de tip raster de intrare obligatorii pentru funcția Traseu optim. Valorile pentru traseul optim de ieșire reprezintă numărul trasee pentru o locație dată. În multe cazuri, traseele urmează aceeași rută, părăsind o sursă și apoi divergând pentru a se îndrepta către destinații diferite. De exemplu, valoarea 1 indică faptul că există un singur traseu optim pentru o locație dată, în timp ce valoarea 5 înseamnă că, pentru locația respectivă, există cinci trasee optime care parcurg celula respectivă în cadrul zonei de studiu.<div><br/>Datele de destinație de intrare trebuie să fie un strat tematic de tip raster. Setul de celule de destinație constă în toate celulele din rasterul de intrare care au valori valide. Celulele care au valori NoData nu sunt incluse în set. Valoarea zero este considerată o destinație legitimă. Un raster de destinație poate fi creat utilizând instrumentele de extragere. Dacă aveți obiecte spațiale de destinație sau de sursă, le puteți converti în raster utilizând funcția Rasterizarea obiectelor spațiale. Utilizați rasterul de acumulare a distanței sau de direcție inversă ca Raster de intrare pentru funcția de rasterizare. Acest lucru va asigura faptul că respectivul obiect spațial este rasterizat utilizând aceeași dimensiune, mărime și referință spațială pentru celulă, precum celelalte rastere care fac obiectul funcției Traseu optim ca raster. Funcția Traseu optim ca raster poate fi utilizată și pentru a deriva traseul cu cea mai mică rezistență către un model de elevație digitală (DEM). În acest caz, utilizați DEM pentru rasterul de acumulare a distanței de intrare și de ieșire din funcția Direcția fluxului pentru Rasterul de direcție inversă.</div>",
		trendName: "Predicția Utilizării Tendinței",
		trendSnip: "Calculează un strat tematic de tip raster multidimensional prognozat folosind rasterul de tendințe rezultant din funcția Generarea Tendinței sau din instrumentul de geoprocesare Generarea Rasterului de Tendințe.",
		trendDesc: "Funcția Predicția Utilizării Tendinței calculează un strat tematic de tip raster multidimensional prognozat folosind rasterul de tendințe rezultant din funcția Generarea Tendinței sau din instrumentul de geoprocesare Generarea Rasterului de Tendințe.",
		rasterCollectionName: "Procesare colecție raster",
		rasterCollectionSnip: "Procesează fiecare segment dintr-un raster multidimensional sau fiecare reper dintr-un raster mozaic. Această funcție poate, de asemenea, să efectueze agregarea mai multor segmente într-un singur segment.",
		rasterCollectionDesc: "Funcția Procesare colecție raster procesează fiecare segment dintr-un raster multidimensional sau fiecare reper dintr-un raster mozaic. Această funcție poate, de asemenea, să efectueze agregarea mai multor segmente într-un singur segment.<div><br/>Această funcție procesează fiecare segment dintr-un raster multidimensional sau din rasterul mozaic care utilizează un șablon de funcție raster. Această funcție acceptă următoarele opțiuni: 1. Specificați un șablon de funcție raster pentru Funcția Reper. De exemplu, aveți un set de date mozaic care conține 20 de ani de imagini Landsat și doriți să calculați NDVI pentru fiecare scenă din seria temporală. Pentru funcția Reper, specificați un șablon de funcție raster care conține funcția raster NDVI. 2. Specificați un șablon de funcție raster pentru Funcția Agregare. De exemplu, aveți un raster multidimensional care conține date zilnice de temperatură pentru 10 ani și doriți să calculați temperatura maximă pentru fiecare an. În funcția Agregare, specificați un șablon de funcție raster care conține funcția Statisticile celulei, cu operația setată la Maximum. La Definiția agregării, setați Dimensiune la StdTime, Tip la Cuvânt cheie interval și Interval cuvânt cheie la Anual. Rețineți faptul că setul de date mozaic de intrare nu este multidimensional, iar funcția de agregare nu va respecta definiția agregării. Funcția de agregare va agrega toate reperele sau fiecare grup într-unul dacă acestea sunt definite în șablonul funcției de agregare. Pentru mai multe informații privind utilizarea grupurilor într-un set de date mozaic, consultați Utilizarea reperelor într-un set de date mozaic în Șabloane de funcții raster. 3. Specificați un șablon de funcție raster pentru Funcția Procesare. Funcția sau lanțul de funcții din acest șablon se utilizează pentru afișarea noului raster procesat. De exemplu, specificați un șablon de funcție raster care conține funcția Harta culorii pentru a modifica modul de afișare a stratului tematic de tip raster procesat. Rețineți faptul că, dacă intrarea este un raster multidimensional, funcția de procesare este aplicată în segmentul de afișare curent. Dacă intrarea este un strat tematic mozaic sau un set de date mozaic, funcția de procesare este aplicată rasterului mozaic utilizând prima metodă de soluționare a suprapunerilor. 3. Specificați șabloanele pentru orice combinație a celor trei funcții. De exemplu, aveți un set de date mozaic care conține imagini Landsat de serii temporale și doriți să generați o imagine compozită a NDVI maxim. Pentru funcția Reper, specificați un șablon de funcție raster care conține funcția raster NDVI. Pentru funcția Agregare, specificați un șablon de funcție raster care conține funcția Statisticile celulei, cu operația setată la Maximum. Pentru funcția Procesare, specificați un șablon de funcție raster care conține funcția Harta culorii. Rețineți faptul că ordinea de procesare a funcțiilor urmează ordinea parametrilor de intrare. De exemplu, funcția Reper va fi procesată prima.</div>",
		randomName: "Aleatoriu",
		randomSnip: "Creează un raster cu valori ale pixelilor alese în mod aleatoriu dintr-o distribuție pseudoaleatoare. Sunt acceptate mai multe distribuții și generatoare de numere aleatorii.",
		randomDesc: "Funcția Aleatoriu creează un raster cu valori aleatorii ale pixelilor care pot fi utilizate în șabloane de funcții raster sau în seturi de date mozaic.<div><br/>Deși majoritatea funcțiilor funcționează pe unul sau mai multe rastere de intrare, funcția Aleatoriu nu necesită un raster de intrare. Acest lucru înseamnă că se comportă mai mult ca un set de date raster decât ca o funcție, așa că trebuie acordată o funcție specială la adăugarea sau eliminarea acestuia în/din lanțul de funcții.</div>",
		shrinkName: "Micșorare",
		shrinkSnip: "Micșorează zonele selectate cu un număr specificat de celule înlocuindu-le cu valoarea celulei care este cea mai frecventă în vecinătatea sa.",
		shrinkDesc: "Cu funcția globală Micșorare, puteți generaliza sau simplifica rastere prin micșorarea unor anumite zone. De asemenea, puteți controla gradul de generalizare ce va avea loc.<div><br/>Zonele pe care le selectați se vor micșora sau le va fi redusă dimensiunea prin extinderea celulelor din zonele vecine în acestea. Din punct de vedere conceptual, Valorile de zonă selectate pot fi vizualizate ca zone de prim plan, în timp ce celelalte valori rămân valori în fundal. Celulele din zonele aflate în prim plan pot fi înlocuite cu celule din zonele aflate în fundal. De asemenea, pot fi înlocuite insulele înguste din cadrul unei zone, care pot fi considerate ca împărtășind limitele cu zona respectivă.<div><br/>Gradul de generalizare poate fi controlat cu parametrul Număr de celule. În mod implicit, această valoare este 1, ceea ce înseamnă că zonele selectate se vor micșora cu o valoare corespunzătoare dimensiunii unei celule. Pentru a mări gradul de generalizare, puteți specifica o valoare mai mare pentru acest parametru. Din punct de vedere conceptual, acest lucru este similar rulării instrumentului cu un număr echivalent celui specificat, iar rezultatele rulării anterioare reprezintă intrarea în iterația ulterioară.</div>",
		trendToRGBName: "Tendința la RGB",
		trendToRGBSnip: "Transformă un raster de tendințe într-un raster cu trei benzi (roșu, verde și albastru).",
		trendToRGBDesc: "Funcția Tendință la RGB transformă un raster de tendințe într-un raster cu trei benzi (roșu, verde și albastru). Rasterul de tendințe este generat din funcția rasterului Generarea Tendinței sau a funcției rasterului Analiză CCDC.<div><br/>Această funcție este utilă pentru vizualizarea datelor coeficientului de model din funcția Generarea Tendinței sau a funcției Analiză CCDC: Ambele funcții estimează tendințele din valorile modificate ale pixelilor, dar este dificil să se interpreteze direct rezultatele funcțiilor.<div><br/>La fel ca în cazul mai multor funcții de raster, ar putea fi necesară utilizarea funcției Ajustarea dinamică a intervalului (DRA) pentru afișarea îmbunătățită a rezultatelor acestei funcții.</div>",
		landTrendrName: "Analiză LandTrendr",
		landTrendrSnip: "Evaluează schimbările valorilor pixelilor în timp cu ajutorul metodei de detectare pe baza Landsat a tendințelor de afectare și recuperare (LandTrendr) și generează un raster cu analiza schimbării care include rezultatele modelului.",
		landTrendrDesc: "Această funcție raster poate fi folosită doar ca intrare pentru funcția raster de Detectare a modificării folosind analiza modificării. Pentru a genera o ieșire de raster, conectați funcția Analiză LandTrendr la funcția Detectarea modificărilor utilizând analiza modificărilor într-un șablon de funcție raster și folosiți șablonul ca intrare în instrumentul de geoprocesare Generați raster din funcția raster. Rezultatul este un raster care include informații privind ora la care s-a modificat valoarea pixelului.<div><br>Scopul acestei funcții raster este acela de a extrage modificările dintr-un obiect spațial observat, astfel încât imaginile multidimensionale de intrare ideale să surprindă o observare consecventă în timp și nu trebuie să includă interferențe atmosferice sau ale senzorilor, nori sau umbre de nori. Bunele practici sunt de a utiliza datele care au fost normalizate și pot fi mascate cu ajutorul unei benzi QA, de exemplu produse de Reflectanță a Suprafeței Landsat Colecâia 1 cu o mască de nori.<div><br>Funcția efectuează analiza pe o imagine pe an, iar numărul segmentelor anuale trebuie să fie egal cu sau mai mare de valoarea specificată în parametrul <strong>Număr Minim de Observări</strong>. Se recomandă să aveți minimum șase ani de date.<div><br>Dacă aveți date lunare, săptămânale sau zilnice, se recomandă selectarea mai multor imagini din fiecare an (de preferat din același anotimp), eliminarea norilor și umbrelor norilor și combinarea imaginilor pentru a genera o singură imagine care capturează bine observarea. Dacă sunt furnizate date lunare, săptămânale sau zilnice ca raster multidimensional de intrare, funcția va identifica un segment pentru analiză pe baza datei cele mai apropiate de data menționată în parametrul <strong>Data Fotografierii</strong>.<div><br>Un obiect spațial dintr-un peisaj va avea nevoie de timp pentru a se recupera în urma unei schimbări nepermanente, cum ar fi incendiile de pădure sau infestarea cu insecte. Pentru a controla rata de recuperare recunoscută de model, setați parametrul Prag de Recuperare. Un segment distinct nu poate avea o rată de recuperare mai rapidă decât pragul 1/recuperare.<div><br>Recuperarea în urma schimbării peisajului se poate produce în sens pozitiv sau negativ. De exemplu, atunci când într-un peisaj se pierde pădurea, seria de timp a valorilor indicelui de vegetație prezintă o scădere a valorilor indicelui, iar recuperarea arată o creștere treptată a valorilor indicelui de vegetație sau o tendință de recuperare pozitivă. Specificați direcția tendinței de recuperare cu parametrul <strong>Recuperarea are o tendință crescătoare</strong>.",
		aggregateMultidimensionalName: "Multidimensional Agregat",
		aggregateMultidimensionalSnip: "Combină datele variabile raster multidimensionale existente dintr-o dimensiune.",
		aggregateMultidimensionalDesc: "Funcția Multidimensional Agregat creează un strat tematic de raster multidimensional combinând datele variabile de raster multidimensional existente într-o dimensiune.<div><br>Folosiți parametrul <strong>Definiția Dimensiunii</strong> pentru a filtra mai întâi datele de intrare pe care doriți să le agregați. De exemplu, dacă aveți 30 ani de date lunare, dar doriți doar să creați un strat tematic agregat pentru primii 15 ani, puteți utiliza parametrul <strong>Definiția Dimensiunii</strong>  pentru a specifica anii de inclus în analiză.<div><br><ul><li>Extrageți datele privind salinitatea pentru luna ianuarie în perioada de 10 ani. Alegeți <strong>După Valori</strong>, setați <strong>Dimensiune</strong> la <strong>StdTime</strong>, și setați <strong>Valori</strong> la <strong>ianuarie</strong>.</li><li>Segmentați datele despre salinitate după un interval de adâncime de la 0 la 150 metri. Alegeți <strong>După Intervale</strong>, setați <strong>Dimensiune</strong> la <strong>StdZ</strong>, și setați <strong>Valoare Minimă</strong> la <strong>-150</strong> și <strong>Valoare Maximă</strong> la <strong>0</strong>.</li><li>Extrageți datele privind salinitatea pentru luna ianuarie în perioada de 10 ani. Alegeți <strong>După Iterație</strong>, setați <strong>Dimensiune</strong> la <strong>StdTime</strong>, setați <strong>Începutul primei iterații</strong> și <strong>Sfârșitul primei iterații</strong> la începutul și sfârșitul corespunzătpare ale perioadei de iterare, setați <strong>Pas</strong> la <strong>1</strong>, și setați <strong>Unitate</strong> la <strong>Ani</strong>.</li></ul><div><br>Folosiți parametrii <strong>Definiție de Agregare</strong> pentru a alege dimensiunea de evaluat și intervalul de agregare cu ajutorul unui cuvânt cheie, a unei valori, a unui interval de valori. De exemplu, dacă aveți 30 ani de date privind temperatura suprafeței mării, colectate zilnic ți la fiecare 5 metri de adâncime până la 100 metri, puteți utiliza diversele opțiuni de interval pentru următoarele scenarii:<div><br><ul><li>Agregați datele privind temperaturile zilnice în date lunare, unde rezultatul este un raster multidimensional cu 12 segmente de timp, iar fiecare segment este agregatul fiecărei luni din toți anii. A;egeți <strong>Cuvânt Cheie Interval</strong> și setați cuvântul cheie la <strong>Recurent Lunar</strong>.</li><li>Agregați datele privind temperaturile zilnice în date lunare, unde rezultatul este un raster multidimensional cu 360 de segmente, sau 12 segmente de timp pe an (30 ani x 12 luni = 360 segmente). Alegeți <strong>Cuvânt Cheie Interval</strong> și setați cuvântul cheie la <strong>Lunar</strong>.</li><li>Agregați datele privind temperaturile lunare în intervale de câte 4 luni. Alegeți <strong>Valoarea Intervalului</strong>, setați <strong>Valoarea Intervalului</strong> la 4 și setați <strong>Unitatea</strong> la <strong>Luni</strong>.</li><li>Agregați datele privind temperaturile de la 0 la 25 metri, apoi de la 25 la 50 metri, apoi de la 50 la 100 metri. Alegeți <strong>Game de Interval</strong> și specificați adâncimile minime și maxime ca <strong>0 25; 25 50; 50 100</strong>.</li></ul>",
		mergeRastersName: "Fuzionați rasterele",
		mergeRastersSnip: "Combinați spațial seturi de date de raster multiple sau pe variabile și dimensiuni.",
		mergeRastersDesc: "Această funcție creează un raster fuzionat dintr-o listă de rastere. De exemplu, dacă aveți un set de date mozaicat care conține date lunare despre precipitații pentru 30 de ani și un alt set de date cu date lunare de4spre temperaturi pentru 10 ani, le puteți combina într-un raster multidimensional cu ambele variabile. <div><br>Dacă rasterele multidimensionale de intrare conțin variabile diferite, rasterul multidimensional de ieșire va include toate variabilele. <div><br>Dacă rasterele multidimensionale de intrare conțin dimensiuni sau valori de dimensiuni diferite, rasterul multidimensional de ieșire va include toate dimensiunile și valorile de dimensiuni. <div><br>Dacă rasterele multidimensionale de intrare conțin aceleași dimensiuni și variabile, dar extinderi spațiale diferite, rasterul multidimensional de ieșire va include variabilele și dimensiunile din toate extinderile spațiale fuzionate.<div><br>Această funcție poate fi folosită și când aveți rastere multiple pe care doriți să le tratați ca pe un singur articol, cum ar fi calcularea acelorați statistici pentru toate, sau la echilibrarea culorii, pentru a nu fi nevoiți să echilibrați culoarea fiecărei imagini în mod separat. Acest lucru este util atunci când lucrați cu imagini stocate ca tile separate din cauza constrângerilor privind dimensiunea fișierului; astfel, tilele vor fi tratate ca parte a aceleiași imagini.",
		boundaryCleanName: "Curățarea Graniței",
		boundaryCleanSnip: "Netezește granița dintre zone.",
		boundaryCleanDesc: "<p>Funcția generalizează sau simplifică rasterele netezind granițele dintre zone. Funcția oferă opțiuni pentru controlul modului în care celulele zonelor de intrare influențează netezirea și valoarea de netezire care se va aplica. Fiecare celulă de intrare este evaluată cu ajutorul vecinilor săi imediați, în număr de opt.</p><p>Procesul de netezire sortează mai întâi celulele vecine cu o anumită prioritate. Prioritatea stabilește care zonă din celulele învecinate poate înlocui valoarea celulei de prelucrare din ieșire.</p><p>Prioritatea se poate baza fie pe valoarea zonelor sau pe dimensiunea zonelor. Parametrul <strong>Tip de sortare</strong> stabilește tipul de sortare de folosit. </p><p>Setarea implicită <strong>Nu sorta</strong> evaluează prioritatea pe baza valorii zonelor. Celulele din zonele cu valori mai mari vor avea o prioritate mai mare de extindere în zone cu valori mai mici.</p><p>Dimensiunea sau suprafața totală a zonelor poate fi folosită pentru sortarea priorității. Cu setarea <strong>Descrescătoare</strong>, zonele sunt sortate după dimensiune în ordine descrescătoare. Zonele cu suprafețe totale mai mari vor avea prioritatea de extindere în zone cu suprafețe mai mici. Cu setarea <strong>Crescătoare</strong>, este valabil opusul: zonele cu suprafețe totale mai mici vor avea prioritate de extindere în zone cu suprafețe totale mai mari.</p><p>Valoarea netezirii este controlată de parametrul <strong>Rulați extindere și restrângere de două ori</strong>, care stabilește de câte ori va fi efectuat procesul de extindere și restrângere.</p><p>Dacă setarea nu este bifată, procesul de extindere și restrângere va fi efectuat o singură dată. Dacă setarea este bifată, procesul de extindere și restrângere este efectuat de două ori, având ca rezultat un grad suplimentar de netezire a granițelor dintre zone.</p><p>Dacă valorile tuturor celor opt celule învecinate sunt aceleași cu cele ale celulei de prelucrare, celula rezultantă va reține valoarea celulei de intrare.</p>",
		predictUsingRegressionName: "Predicție cu ajutorul regresiei",
		predictUsingRegressionSnip: "Calculează un raster anticipat pe baza introducerilor de date despre raster și a unui model de regresie. Modelul de regresie este rezultatul produs de instrumentul de geoprocesare a rasterelor <strong>Modelul de antrenare prin arbori aleatori</strong>.",
		predictUsingRegressionDesc: "<p>Modelul de regresie este definit într-un fișier de definiție a regresiei Esri (.ecd). Acesta conține toate informațiile pentru un set de date specific sau un set de seturi de date și modelul de regresie și este generat de instrumentul de geoprocesare a rasterelor <strong>Model de antrenare cu arbori aleatori</strong> .</p><p>Introducerea poate fi un raster cu o singură bandă, cu mai multe benzi, un raster multidimensional sau o listă a acestor tipuri. Tipurile de rastere de introducere trebuie să fie identice cu tipul de raster antrenat de modelul de regresie.</p><ul><li>Când introducerea este un raster cu mai multe benzi, fiecare bandă este tratată ca o variabilă a elementului de predicție. Benzile trebuie să fie în aceeași ordine ca și introducerea cu mai multe benzi pentru instrumentul de antrenare a modelului de regresie.</li><li>Când introducerea este un raster multidimensional, fiecare variabilă este tratată ca o variabilă de element de predicție, iar variabila trebuie să fie cu o singură bandă și să aibă o dimensiune de timp. Ordinea variabilelor și numelor trebuie să fie aceeași ca și introducerea când modelul de regresie a fost antrenat. Ieșirea este un raster multidimensional.</li><li>Introducerea poate fi o listă de elemente. Numărul de elemente și ordinea elementelor trebuie să corespundă cu introducerea când modelul de regresie a fost antrenat.</li></ul>",
		dimensionalMovingStatisticsName: "Statistica de mișcare dimensională",
		dimensionalMovingStatisticsSnip: "Calculează statisticile pe o fereastră mobilă pe date multidimensionale de-a lungul unei dimensiuni specificate.",
		dimensionalMovingStatisticsDesc: "<p>Funcția Statistici mișcare dimensională calculează diverse statistici în cadrul unei ferestre predefinite pentru toate valorile dimensiunii împreună cu o dimensiune. Această funcție ia un strat tematic de raster multidimensional ca intrare și creează un strat tematic de raster multidimensional ca ieșire care are aceeași dimensiune ca și stratul tematic de intrare.</p><p>Puteți specifica o dimensiune pentru care valorile dimensiunii sunt luate în calcul în timpul calculării. Implicit, aceasta se calculează împreună cu prima dimensiune non-spațială. Puteți, de asemenea, să specificați dimensiunea unei ferestre prin specificarea parametrilor Fereastră înapoi și Fereastră înainte.</p><p>Când Tipul statisticii este setat la Percentilă, parametrii Valoare percentilă și Tip interpolare percentilă devin disponibil. Puteți utiliza acești parametri pentru a specifica percentila pentru a calcula și alege respectiv tipul de interpolare de utilizat. Când Tipul de statistică este setat la Medie circulară, parametrul Valoare încadrare circulară devine disponibil. Valoarea de încadrare circulară este utilizată pentru a converti o valoare liniară în intervalul unei medii circulare date.</p>",
		terrainFlattenFunctionName: "Teren aplatizat",
		terrainFlattenFunctionSnip: "Corectează datele de intrare ale radarului cu deschidere sintetică (SAR) pentru distorsiuni radiometrice datorate topografiei.",
		terrainFlattenFunctionDesc: "<p>Funcția \"Terrain Flatten raster\" corectează datele de intrare ale radarului cu deschidere sintetică (SAR) pentru distorsiuni radiometrice datorate topografiei.</p><p>Datele radar de intrare trebuie mai întâi să fie calibrate la zero beta. Utilizați instrumentul \"Apply Radiometric Calibration\" pentru a calibra datele radar la beta zero.</p><p>Dacă DEM-ul de intrare nu acoperă întregul set de date SAR, instrumentul va emite valori NoData pentru pixelii din afara extensiei DEM pentru gamma nought, sigma nought, zona de împrăștiere și distorsiunile geometrice. Pentru ieșirea măștii de distorsiune geometrică, instrumentul va emite valori nedeterminate pentru pixelii din afara extensiei DEM.</p><p>DEM-ul de intrare trebuie să fie în sistemul de coordonate geografice WGS 1984 (EPSG:4326).</p>",
		createColorCompositeFunctionName: "Creați compozit culoare",
		createColorCompositeFunctionSnip: "Creează un raster cu trei benzi dintr-un set de date raster cu mai multe benzi, în care fiecare bandă poate utiliza un calcul algebric bazat pe algebra benzilor.",
		createColorCompositeFunctionDesc: "<p>Funcția de creare a rasterului compozit de culoare creează un raster cu trei benzi dintr-un set de date raster cu mai multe benzi, în care fiecare bandă poate utiliza un calcul algebric bazat pe algebra benzilor.</p><p>Atunci când definiți un algoritm aritmetic de bandă, puteți introduce o formulă algebrică pe o singură linie pentru fiecare expresie pentru a crea o ieșire multibandă. Operatorii suportați sunt unari, plus (+), minus (-), ori (*) și divide (/).</p><p>Atunci când folosiți un ID de bandă într-o expresie, identificați banda prin prefixarea B sau b la numărul benzii.</p><p>O combinație obișnuită de benzi utilizată pentru radarul cu deschidere sintetică (SAR) în unități liniare este VV pentru roșu, VH pentru verde și VV/VH pentru albastru. În cazul în care datele de intrare sunt în decibeli, combinația de benzi trebuie să fie VV pentru roșu, VH pentru verde și VV-VH pentru albastru.</p>",
		surfaceParametersName: "Parametri suprafeței",
		surfaceParametersSnip: "Determină parametrii unui raster de suprafață cum ar fi aspectul, panta și mai multe tipuri de curburi folosind metode geodezice.",
		surfaceParametersDesc: "<p>Parametrii de suprafață determină parametrii unui raster de suprafață cum ar fi aspectul, panta și mai multe tipuri de curburi folosind metode geodezice.</p><p>Această funcție poate fi utilizată pentru următoarele aplicații:</p><ul><li>Calcularea aspectului și a pantei folosind metode geodezice.</li><li>Calcularea diferitelor tipuri de curburi dintr-un raster de suprafață, de exemplu, <strong>Curba tangentă (contur normal)</strong> care caracterizează convergența geografică și divergența fluxului peste suprafață.</li></ul>",
		leastCostCorridorName: "Coridorul cu cel mai mic cost",
		leastCostCorridorSnip: "Calculează suma a două rastere de distanță cu costuri cumulative cu opțiunea de a aplica un prag pe baza procentului sau a costului cumulativ.",
		leastCostCorridorDesc: "<p>Rasterele de intrare trebuie să fie rastere de acumulare a distanței, și rezultate de rastere de direcție înapoi din funcția <strong>Acumulare distanță</strong> sau <strong>Alocare distanță</strong>. Ar trebui să se bazeze distanța de cost și aceleași setări de parametri ar trebui să fie utilizate la crearea straturilor tematice pentru fiecare sursă. Nu ar trebui să se utilizeze parametri care depind de direcționalitate (factor orizontal, factor vertical și direcție de deplasare) în crearea acestor rastere.</p><p>Valorile din rasterul coridorului de ieșire sunt suma costului acumulat pentru a ajunge într-o locație dată cu aceleași unități ca rastere de distanță de cost acumulat.</p><p>Dacă o valoare <strong>Prag</strong> este mai mare decât costul acumulat maxim când se însumează două rastere de acumulare de distanță, rasterul coridor de ieșire va acoperi aceeași suprafață ca și rasterele acumulate de intrare.</p><p>Dacă o valoare prag specificată este mai mică decât valoarea minimă din rasterul coridor, este returnat un mesaj de avertizare și rasterul de ieșire va fi gol.</p><p>Rasterul coridor de ieșire poate conține celule cu costuri acumulate ușor mai mari decât valoarea prag. Acest lucru este provocat de rasterele de direcție înapoi care utilizează celule atribuite cu costuri ușor mai ridicate decât pragul pentru a conecta celulele deconectate la coridor.</p>",
		geometricMedianName: "Mediana geometrică",
		geometricMedianSnip: "Funcția de medie geometrică se calculează ca media geometrică între pixeli într-o serie de timp d imagistică multibandă.",
		geometricMedianDesc: "<p>Această funcție reduce zgomotul și valorile excepționale în imagistica seriei de timp calculând un pixel mediu geometric pentru fiecare serie de pixeli din stiva de imagini. Algoritmul menține relațiile spectrale dintre benzi în spectrul de pixeli, pentru ca rezultatul să poată fi utilizat în analiză, cum ar fi indicii de vegetație.</p><p>Norii și umbrele trebuie să fie mascate folosind Banda QA a setului de date înainte de a aplica această funcție.</p><p>Dacă imaginea de intrare este punctul flotant, cum ar fi o suprafață reflectorizantă cu valori între 0 și 1, o valoare epsilon de 0,001 produce rezultate de calitate.</p>"
	},
	rfxArgs: {
		rasterName: "Raster",
		colorSchemeTypeName: "Tip schemă de culori",
		colormapName: "Culoare hartă",
		colormapNameName: "Nume culoare hartă",
		colorRampName: "Rampă de culoare",
		contrastOffsetName: "Offset contrast",
		brightnessOffsetName: "Offset luminozitate",
		methodName: "Metodă",
		bandNamesName: "Nume bandă",
		bandWavelengthsName: "Lungimi de undă de bandă",
		bandIdsName: "ID-uri bandă",
		missingBandActionName: "Lipsă acțiune bandă",
		conversionParametersName: "Parametrii conversie",
		hillshadeTypeName: "Tip hillshade",
		azimuthName: "Azimut",
		altitudeName: "Altitudine",
		slopeTypeName: "Se scalează",
		zFactorName: "Factor Z",
		PSPowerName: "Transmisie dimensiune pixel",
		PSZFactorName: "Factor dimensiune pixel",
		removeEdgeEffectName: "Dezactivare interpolare pixeli muchie",
		fromUnitName: "De la unitatea",
		toUnitName: "La unitatea",
		rasterTypeName: "Tip",
		minName: "Minimum ieșire",
		maxName: "Maximum ieșire",
		minPercentName: "Minimum fixare procent",
		maxPercentName: "Maximum fixare procent",
		numberOfStandardDeviationName: "Număr de deviații standard",
		sigmoidStrengthLevelName: "Nivel putere sigmoid",
		estimateStatsHistogramName: "Estimare statistici",
		DRAName: "Ajustare de domeniu dinamic",
		statisticsName: "Statistică",
		histogramsName: "Histograme",
		statisticsHistogramName: "Definiți statistici și histogramă",
		computeGammaName: "Auto Gamma",
		useGammaName: "Folosire Gamma",
		gammaName: "Gamma",
		inputNamesName: "Nume",
		expressionName: "Expresie",
		cellsizeTypeName: "Tip dimensiune celulă",
		extentTypeName: "Tip limită",
		classifierDefinitionFileName: "Introducere definiţie fişier",
		raster1Name: "Raster1",
		raster2Name: "Raster2",
		raster3Name: "Raster3",
		trueRasterName: "Raster real",
		falseRasterName: "Raster fals",
		noDataInterpretationName: "Interpolare fără date",
		noDataValuesName: "Valori fără date",
		includedRangesName: "Intervale incluse",
		curvatureTypeName: "Tip curbură",
		rastersName: "Rastere",
		attributeTableName: "Tabel",
		attributeTableTypeName: "Tip tabel",
		rowsName: "Număr de rânduri",
		columnsName: "Număr de coloane",
		kernelName: "Kernel",
		mirrorEdgesName: "Muchii în oglindă",
		influencesName: "Influenţe",
		fieldsName: "Câmpuri",
		remapsName: "Recartografiere tabel",
		evalFromName: "Scară de evaluare de la",
		evalToName: "Scară de evaluare până la",
		weightsName: "Greutăţi",
		DEMName: "DEM",
		shortRangeIDWRadiusName: "Interval scurt raza IDW",
		maxVoidWidthName: "Lățime maximă vid",
		sigmaGaussianName: "Liniarizare adaptivă",
		contourTypeName: "Tip contur",
		zBaseName: "Bază Z",
		numberOfContoursName: "Număr de contururi",
		contourIntervalName: "Interval contur",
		nthContourLineInBoldName: "A n-a linie a conturului este îngroşată",
		featureClassName: "Obiecte spațiale de intrare",
		classIndexFieldName: "Field",
		resolveOverlapMethodName: "Rezolvare metodă de suprapunere",
		resamplingTypeName: "Tip reeșantionare",
		inputCellsizeName: "Dimensiune celulă intrare",
		outputCellsizeName: "Dimensiune celulă ieșire",
		pointFeatureClassName: "Puncte de semințe",
		maxGrowthRadiusFieldName: "Câmp cu rază maximă de creştere",
		similarityThresholdFieldName: "Câmp prag de similaritate",
		fillValueFieldName: "Completaţi valoare câmp",
		spectralDetailName: "Detaliu spectral [1..20]",
		spatialDetailName: "Detaliu spațial [1..20]",
		minNumPixelsPerSegmentName: "Dimensiunea minimă segment în pixeli",
		boundariesOnlyName: "Numai limitele segmentului",
		statisticsTypeName: "Tip statistici",
		fillNoDataOnlyName: "Completați numai pixelii NoData",
		inputDataTypeName: "Tip date de intrare",
		angleReferenceSystemName: "Sistem referinţă unghi",
		outputDataTypeName: "Tip date de ieşire",
		inputSamplePointFeatureClassName: "Eşantioane de intrare",
		valueFieldName: "Câmp valoare",
		rasterInfoName: "Info Raster",
		interpolationMethodName: "Metodă de interpolare",
		radiusName: "Rază",
		radianceGainValuesName: "Amplificare radianță",
		radianceBiasValuesName: "Polarizare radianță",
		reflectedGainValuesName: "Amplificare reflectare",
		reflectedBiasValuesName: "Polarizare reflectare",
		sunElevationName: "Elevație soare (grade)",
		albedoName: "Coeficient de reflexie",
		scaleFactorName: "Factor scară",
		offsetName: "Decalare",
		thresholdTypeName: "Tip prag",
		thresholdsName: "Praguri",
		undefinedClassName: "Clasa nedefinită",
		minValueName: "Min",
		maxValueName: "Max",
		operationName: "Operație",
		clippingTypeName: "Tip decupare",
		clippingGeometryName: "Geometrie/raster de copiere",
		extentName: "Extindere ieșire",
		useInputFeatureGeometryName: "Folosiți obiectele spațiale de intrare pentru geometria de decupare",
		remapDefinitionTypeName: "Recartografiere tip definiție",
		inputRangeName: "Intervale de intrare",
		outputValuesName: "Valori de ieșire",
		noDataRangeName: "Intervale fără date",
		inputFieldName: "Câmp de intrare",
		outputFieldName: "Câmp de ieșire",
		inputMaxFieldName: "Câmp maxim de intrare (opțional)",
		remapTableTypeName: "Recartografiere tip tabel",
		allowUnmatchedName: "Permiteți valori necorelate ale pixelilor",
		changeMissingValuesToNoDataName: "Modificați valorile lipsă în fără date",
		visibleBandIDName: "ID vizibil bandă",
		infraredBandIDName: "ID infraroșu bandă",
		scientificOutputName: "Ieșire științifică",
		bandIndexesName: "Indexuri bandă",
		constantName: "Constantă",
		weightName: "Greutate",
		minimumName: "Minim",
		maximumName: "Maxim",
		sourceDataName: "Raster sursă",
		sourceFieldName: "Câmp sursă",
		costRasterName: "Raster costuri",
		maxDistanceName: "Distanță maximă",
		valueRasterName: "Raster valoare",
		costMultiplierName: "Multiplicator pentru aplicare la costuri",
		startCostName: "Cost de pornire",
		accumCostResistanceRateName: "Rată acumulativă de rezistență a costurilor",
		capacityName: "Capacitate",
		travelDirectionName: "Direcție de deplasare",
		cellSizeName: "Dimensiune celulă",
		populationFieldName: "Câmp populație",
		areaUnitsName: "Unități suprafață",
		outputValueTypeName: "Valori celulă de ieșire",
		barriersName: "Introduceți barierele",
		destinationDataName: "Raster destinație",
		destinationFieldName: "Câmp destinație",
		pathTypeName: "Tip cale",
		observerFeaturesName: "Obiecte spațiale observator",
		analysisMethodName: "Metodă analiză",
		analysisTypeName: "Tip analiză",
		verticalErrorName: "Eroare verticală",
		refractivityCoefficientName: "Coeficient refractare",
		surfaceOffsetName: "Offset suprafață",
		observerElevationName: "Elevație observator",
		observerOffsetName: "Offset observator",
		innerRadiusName: "Rază interioară",
		innerRadiusIs3DDistanceName: "Raza interioară este distanța 3D",
		outerRadiusName: "Rază exterioară",
		outerRadiusIs3DDistanceName: "Raza exterioară este distanța 3D",
		horizontalStartAngleName: "Unghi de pornire orizontal",
		horizontalEndAngleName: "Unghi de finalizare orizontal",
		verticalUpperAngleName: "Unghi superior vertical",
		verticalLowerAngleName: "Unghi inferior vertical",
		zoneDataName: "Raster zonă",
		zoneFieldName: "Câmp zonă",
		ignoreNoDataName: "Ignorare fără date în calcule",
		temperatureRasterName: "Raster temperatură",
		inTemperatureUnitsName: "Unități de temperatură",
		outHeatIndexTemperatureUnitsName: "Unități index căldură",
		relativeHumidityRasterName: "Raster umiditate relativă",
		outWindChillTemperatureUnitsName: "Unități răcire eoliană",
		windSpeedRasterName: "Raster viteză vânt",
		inWindSpeedUnitsName: "Unități viteză vânt",
		valueName: "Valoare",
		propertyName: "Nume proprietate",
		jsonName: "Metadate JSON",
		zoneTableName: "Tabel atribute zonale",
		attributeFieldNames: "Nume câmp atribute",
		backgroundName: "Valoare fundal",
		whereClauseName: "Clauză Unde",
		minimumValueFieldName: "Nume câmp valoare minimă",
		maximumValueFieldName: "Nume câmp valoare maximă",
		outValueFieldName: "Nume câmp valoare de ieșire",
		defaultValueName: "Valoare implicită de ieșire",
		conversionMatrixName: "Matrice de conversie",
		IsPseudoColorOutputName: "Este o pseudo ieșire de culoare",
		unmappedAsRandomColorName: "Alocare aleatorie a culorii la pixelii necartografiați",
		distanceMethodName: "Metoda distanței",
		flowDirRasterName: "Raster al direcției fluxului",
		pourPointName: "Raster de punct(e) de curgere",
		pourPointFieldName: "Câmpul punctului de curgere",
		constantZName: "Constantă Z",
		zOffsetName: "Decalare Z",
		geoIdName: "Geoid",
		calibrationTypeName: "Tip de calibrare",
		filterTypeName: "Tip de filtru",
		filterSizeName: "Dimensiune de filtru",
		noiseModelName: "Model de zgomot",
		noiseVarianceName: "Variație de zgomot",
		additiveNoiseMeanName: "Medie zgomot adițional",
		multiplicativeNoiseMeanName: "Medie zgomot multiplicativ",
		numberofLooksName: "Număr de contururi",
		dampingFactorName: "Factor de amortizare",
		maskRasterName: "Raster mască",
		nibbleValuesName: "Folosiți valori fără date dacă acestea sunt vecinul cel mai apropiat",
		nibbleNoDataName: "Ciugulire celule fără date",
		zLimitName: "Limită Z",
		flowDirectionTypeName: "Tip al direcției fluxului",
		weightRasterName: "Raster pondere",
		forceEdgeName: "Forțați toate celulele de margine pentru a curge în exterior",
		streamRasterName: "Raster curs",
		surfaceRasterName: "Raster suprafață",
		conversionType: "Tip convertire",
		distanceRaster1: "Distanţă Raster 1",
		distanceRaster2: "Distanţă Raster 2",
		costDistanceRaster: "Rasster distanță de cost",
		costBacklinkRaster: "Raster costuri link de revenire",
		overridesName: "Suprareglare",
		fieldName: "Field",
		signatureFileOrUrl: "Fișier de semnătură sau URL",
		redName: "Roşu",
		greenName: "Verde",
		blueName: "Albastru",
		infraredName: "Infraroșu",
		panchromaticName: "Pancromatic",
		multispectralName: "Multispectral",
		pansharpeningType: "Tip pan-îmbunătățire a clarității",
		sensorName: "Senzor",
		spatialReferenceName: "Referinţă spaţială",
		xCellsizeName: "Dimensiune celulă X",
		yCellsizeName: "Dimensiune celulă Y",
		xOriginName: "Punct de înregistrare X",
		yOriginName: "Punct de înregistrare Y",
		percentileName: "Valoare procentuală",
		neighborhoodType: "Tip de vecinătate",
		widthName: "Lățime",
		heightName: "Înălțime",
		startAngleName: "Unghi de pornire",
		endAngleName: "Unghi de finalizare",
		neighborhoodValues: "Valori de vecinătate",
		horizontalRaster: "Raster orizontal",
		horizontalFactor: "Factor orizontal",
		verticalRaster: "Raster vertical",
		verticalFactor: "Factor vertical",
		streamRaster: "Raster curs",
		flowDirRaster: "Raster al direcției fluxului",
		numberNeighborCells: "Număr de celule vecine",
		zoneConnectivity: "Conecitivitate a zonei",
		addLinkBehavior: "Adăugare legătură",
		excludedValue: "Valoare exclusă",
		constantFillCheck: "Generați umplere raster din constantă",
		fillRaster: "Umpleți raster",
		constantFillValue: "Valoare constantă",
		inputBitPositions: "Bit de intrare",
		outputBitPositions: "Bit de ieșire",
		distanceTypeName: "Tip distanță",
		barrierDataName: "Bariere raster",
		pourPointDataName: "Raster al punctului de curgere",
		accumulationRasterName: "Raster de acumulare a fluxului",
		snapDistanceName: "Distanță Fixare",
		orderMethodName: "Metodă de Comandă",
		directionMeasurementName: "Direcție de Măsurare",
		processAsMultiband: "Procesați ca multibandă",
		processMultidimensional: "Procesați ca multidimensional",
		forceFlowDirectionConvention: "Forțați protocolul direcției fluxului pentru raster cu legătură inversă",
		initialAccumulation: "Acumulare inițială",
		maximumAccumulation: "Acumulare maximă",
		sourceLocationBands: "Generați rând și coloană sursă ca benzi suplimentare în ieșire",
		backDirectionBand: "Generați direcția înapoi ca bandă suplimentară în ieșire",
		numberOfCells: "Număr de celule",
		zoneValues: "Valori ale zonei",
		shrinkMethod: "Metoda de contractare",
		expandMethod: "Metoda de extindere",
		inputSpectralProfileType: "Tip de profil spectral",
		spectralProfileFileName: "Profil spectral",
		trainingFeatureFileName: "Obiect spațial pentru instruire",
		nonNegative: "Non-negativ",
		sumToOne: "Adunați la unu",
		randomDistribution: "Distribuţie",
		meanName: "Medie",
		probabilityName: "Probabilitate",
		alphaName: "Alfa",
		betaName: "Beta",
		rName: "r",
		nName: "N",
		seed: "Plecare",
		randomNumberGenerator: "Generator de numere aleatorii",
		cellFactor: "Factor de celulă",
		aggregationType: "Tehnică de agregare",
		extentHandling: "Măsură de extindere dacă este necesară",
		trendAnalysisDimensionName: "Numele dimensiunii",
		trendAnalysisType: "Tipul tendinței",
		harmonicFrequency: "Frecvența armonică",
		polynomialOrder: "Ordine polinomială",
		cycleLengthName: "Durata ciclului",
		trendAnalysisRMSE: "RMSE",
		trendAnalysisR2: "R la pătrat",
		trendAnalysisSlopePValue: "Valoarea P a coeficientului de pantă",
		trendAnalysisSeasonalPeriod: "Perioadă sezonieră",
		cycleUnitName: "Unitate ciclu",
		predictDimensionValues: "Valori",
		dimensionDefinitionType: "Definiția dimensiunii",
		predictDimensionStart: "Început",
		predictDimensionEnd: "Sfârșit",
		predictDimensionInterval: "Interval de valori",
		dimensionUnit: "Unitate",
		interpolationCellsizeName: "Dimensiunea celulei de interpolare",
		variableName: "Variabile",
		dimensionlessName: "Fără dimensiuni",
		mdimDefinition: "Definiția dimensiunii",
		dimensionName: "Dimensiune",
		iterationStart: "Începutul primei iterații",
		iterationEnd: "Sfârșitul primei iterații",
		intervalStart: "Începutul intervalului",
		intervalEnd: "Sfârșitul intervalului",
		stepName: "Etapă",
		rangesName: "Intervale",
		minValue: "Valoare minimă",
		maxValue: "Valoare maximă",
		changeAnalysisRasterName: "Schimbați rasterul de analiză",
		changeTypeName: "Modificare tip",
		segmentDate: "Data segmentului",
		changeDirectionName: "Schimbați direcția",
		maxNumChangesName: "Număr maxim de modificări",
		filterByYear: "Filtrați după an",
		minimumYear: "Valoare minimă",
		maximumYear: "Valoare maximă",
		filterByDuration: "Filtrați după durată",
		minimumDuration: "Durată minimă",
		maximumDuration: "Durată maximă",
		filterByMagnitude: "Filtrați după magnitudine",
		minimumMagnitude: "Magnitudine minimă",
		maximumMagnitude: "Magnitudine maximă",
		filterByStartValue: "Filtrare după valoare de început",
		minimumStartValue: "Valoare de început minimă",
		maximumStartValue: "Valoare de început maximă",
		filterByEndValue: "Filtrare după valoare de sfârșit",
		minimumEndValue: "Valoare de sfârșit minimă",
		maximumEndValue: "Valoare de sfârșit maximă",
		modelTypeName: "Tipul de model",
		fromRasterName: "De pe raster",
		toRasterName: "Pe raster",
		computeChangeMethod: "Metoda de calculare a modificării",
		fromClassValues: "Valori de clasă De la (Exemplu: 2 5)",
		toClassValues: "Valori de clasă Până la (Exemplu: 2 5)",
		keepMethod: "Metodă de filtrare",
		useColorMethod: "Definiți culorile de tranziție",
		detectChangeBands: "Benzi pentru detectarea schimbării (start la 0)",
		tmaskBands: "Benzi pentru mascare temporală (start la 0)",
		chiSquaredThreshold: "Pragul de chi-pătrat pentru detectarea modificării",
		minAnomaly: "Numărul minim de observații consecutive a anomaliilor",
		updatingFrequency: "Frecvența de actualizare a ajustării (în ani)",
		distanceAccumulationRasterName: "Raster de acumulare a distanței",
		costBackdirectionRasterName: "Raster Direcție inversă sau Direcția fluxului",
		rasterCollectionName: "Colectare Raster",
		itemFunctionName: "Funcție reper",
		aggregationFunctionName: "Funcție de agregare",
		processingFunctionName: "Funcție de procesare",
		aggregationDefinitionName: "Definiție de agregare",
		queryGeometryName: "Geometria de interogare",
		factorFunctionZeroFactor: "Factor zero",
		factorFunctionCutAngle: "Unghi de tăiere",
		factorFunctionSideFactor: "Factor lateral",
		factorFunctionSlope: "Pantă",
		factorFunctionLowCutAngle: "Unghi de tăiere inferior",
		factorFunctionHighCutAngle: "Unghi de tăiere superior",
		factorFunctionCosPower: "Cosinusul puterii",
		factorFunctionSecPower: "Secanta puterii",
		factorFunctionTablePath: "Calea din tabel",
		processingBand: "Bandă de procesare",
		processingBandName: "Numele benzii de procesare",
		snappingDate: "Data efectuării fotografiei",
		maxNumSegments: "Număr maxim de segmente",
		vertexCountOvershoot: "Supramodulația numărului Vertex",
		spikeThreshold: "Prag de neregularități",
		recoveryThreshold: "Prag de recuperare",
		minNumObs: "Număr minim de observări",
		pValueThreshold: "Prag de valoare P",
		bestModelProportion: "Cea mai bună proporție de model",
		preventOneYearRecovery: "Împiedicați recuperarea într-un an",
		recoveryIncreaseTrend: "Recuperarea are tendință crescătoare",
		outputOtherBands: "Ieșire alte benzi",
		sortType: "Sortarea Tipului",
		numberOfRuns: "Rulați extinderea și restrângerea de două ori",
		percentileValue: "Valoare procentuală",
		percentileInterpolationType: "Tip de interpolare a percentilei",
		rasterInfoProperty: "Proprietate",
		rasterInfoValue: "Valoare",
		rasterInfoColumns: "Coloane",
		rasterInfoRows: "Rânduri",
		rasterInfoBandCount: "Număr de benzi",
		rasterInfoPixelSizeX: "Dimensiune celulă X",
		rasterInfoPixelSizeY: "Dimensiune celulă Y",
		rasterInfoPixelType: "Tip pixel",
		rasterExtentTop: "Sus",
		rasterExtentBottom: "Jos",
		rasterExtentLeft: "Stânga",
		rasterExtentRight: "Dreapta",
		rasterStatisticsNotCalculated: "Statistica nu a fost calculată.",
		spatialReferenceProjection: "Proiecţia",
		spatialReferenceWkid: "WKID",
		spatialReferenceLatestWkid: "WKID anterior",
		spatialReferenceWkt: "WKT",
		spatialReferenceVcsWkid: "VCSWKID",
		spatialReferenceLatestVcsWkid: "VCSWKID anterior",
		spatialReferenceAuthority: "Autoritate",
		spatialReferenceLinearUnit: "Unitate liniară",
		spatialReferenceAngularUnit: "Unitate unghiulară",
		spatialReferenceFalseEasting: "Orientare către est falsă",
		spatialReferenceFalseNorthing: "Orientare către nord falsă",
		spatialReferenceCentralMeridian: "Meridian central",
		spatialReferencePrimeMeridian: "Meridian zero",
		spatialReferenceStandardParallel1: "Paralel standard 1",
		spatialReferenceStandardParallel2: "Paralel standard 2",
		spatialReferenceLatitudeOfOrigin: "Latitudinea originii",
		spatialReferenceAuxiliarySphereType: "Tip sferă auxiliară",
		spatialReferenceDatum: "Dată",
		spatialReferenceSpheroid: "Sferoid",
		spatialReferenceSemimajorAxis: "Axă semimajoră",
		spatialReferenceSemiminorAxis: "Axă semiminoră",
		spatialReferenceInverseFlattening: "Aplatizare inversă",
		inputDefinitionFileName: "Introducere definiţie fişier",
		deleteName: "Ștergere",
		addVariableName: "Adăugare variabilă",
		maxNumPixelsPerSegment: "Dimensiunea maximă segment în pixeli",
		forwardWindowName: "Fereastra înainte",
		backwardWindowName: "Fereastra înapoi",
		noDataHandlingName: "Manevrare FărăDate",
		circularWrapValueName: "Valoarea înfășurării circulare",
		fromClassNameFieldName: "Nume de câmp pentru nume de clasă din Raster",
		toClassNameFieldName: "Nume de câmp pentru nume de clasă în Raster",
		targetRasterName: "Raster țintă",
		circularWrapValue: "Valoarea înfășurării circulare",
		bandIndexesR: "Expresie roșie",
		bandIndexesG: "Expresie verde",
		bandIndexesB: "Expresie albastră",
		exampleName: "Exemplu",
		inputName: "Introducere",
		outputName: "Ieşire",
		optionalName: "Opţional",
		browseDefinitionFile: "Răsfoire fișier de definiție",
		selectDefinitionFile: "Selectare fișier de definiție intrare",
		inputDefinitionURL: "URL fișier de definiție intrare",
		enterDefinitionFileURL: "Introduceți URL-ul fișierului de definiție",
		browseXMLFile: "Răsfoiți fișierul XML",
		selectStatsFile: "Selectați fișierul de statistici și histograme",
		enterXMLFileURL: "Introduceți URL-ul fișierului XML",
		xmlFileURL: "URL fișier XML",
		circularCalculation: "Calculare statistici circulare",
		localSurfaceType: "Tip de suprafață locală",
		surfaceParameterType: "Tip de parametru",
		neighborhoodDistance: "Distanță de vecinătate",
		useAdaptiveNeighborhood: "Utilizare vecinătate adaptivă",
		outputSlopeType: "Măsurare pantă ieșire",
		projectAzimuths: "Procent geodezic azimut",
		useEquatorialAspect: "Utilizare aspect ecuatorial",
		zUnit: "Unitate Z",
		analysisMask: "Mască de analiză",
		stdDeviation: "Deviație standard",
		"true": "True",
		"false": "Fals",
		costDistanceRaster1: "Intrare Cost cumulat Distanța de intrare Raster 1",
		costDistanceRaster2: "Intrare Cost cumulat Distanța de intrare Raster 2",
		threshold: "Prag",
		thresholdMethod: "Metoda pragului",
		directionRaster1: "Intrare Înapoi Direcție Raster 1",
		directionRaster2: "Intrare Înapoi Direcție Raster 2",
		maxIterations: "Numărul maxim de iterații",
		epsilon: "Epsilon"
	},
	enumLabels: {
		attributeTableTypeManual: "Manual",
		attributeTableTypeExternal: "Extern",
		clrSchemeTypeColormap: "Culoare hartă",
		clrSchemeTypeColorRamp: "Rampă de culoare",
		colormapTypeElevation: "Elevație",
		colormapTypeGray: "Gri",
		colormapTypeNDVI: "NDVI",
		colormapTypeNDVI2: "NDVI2",
		colormapTypeNDVI3: "NDVI3",
		colormapTypeRandom: "Aleatoriu",
		none: "Niciuna",
		slopeTypeAdjusted: "Ajustat",
		slopeTypeDegree: "Grad",
		slopeTypePercentRise: "ProcentCreștere",
		slopeTypeScaled: "Scalat",
		stretchTypeMinMax: "MinMax",
		stretchTypePercentMinMax: "ProcentMinMax",
		stretchTypeSigmoid: "Sigmoid",
		stretchTypeStdDev: "StdDev",
		hillshadeTypeSimple: "Tradiţional",
		hillshadeTypeMultidirectional: "Multidirecțional",
		bandComboByNames: "Nume bandă",
		bandComboByWavelength: "Lungimi de undă de bandă",
		bandComboByIDs: "ID-uri bandă",
		missingBandActionBestMatch: "Cea mai bună potrivire",
		missingBandActionFail: "Eșec",
		unitTypeCelsius: "Celsius",
		unitTypeCentimeters: "Centimetri",
		unitTypeDecimeters: "Decimetri",
		unitTypeFahrenheit: "Fahrenheit",
		unitTypeFeet: "Ft",
		unitTypeFeetPerSec: "Picioare pe secundă (ft/s)",
		unitTypeInches: "Inci",
		unitTypeKelvin: "Kelvin",
		unitTypeKilometers: "Kilometri",
		unitTypeKmsPerHour: "Kilometri pe oră (km/h)",
		unitTypeKnots: "Noduri (kn)",
		unitTypeMeters: "Metri",
		unitTypeMetersPerSec: "Metri pe secundă (m/s)",
		unitTypeMiles: "Mile",
		unitTypeMilesPerHour: "Mile pe oră (mph)",
		unitTypeMillimeters: "Milimetri",
		unitTypeNauticalMiles: "Mile marine",
		unitTypeYards: "Yarzi",
		unitTypeDecimalDegrees: "Grade zecimale",
		unitTypePoints: "Puncte",
		unitTypeUnknown: "Necunoscut",
		unitTypeSqMapUnits: "Unităţi de hartă dreptunghiulare",
		unitTypeSqMiles: "Mile pătrate",
		unitTypeSqKms: "Kilometri pătrați",
		unitTypeAcres: "Acri",
		unitTypeHectares: "Hectare",
		unitTypeSqYards: "Yarzi pătrați",
		unitTypeSqFt: "Ft pătrați",
		unitTypeSqInches: "Inci pătrați",
		unitTypeSqMts: "Metri pătrați",
		unitTypeSqCms: "Centimetri pătraţi",
		unitTypeSqMms: "Milimetri pătraţi",
		cellsizeTypeFirst: "Primul din",
		cellsizeTypeMin: "Min a/al",
		cellsizeTypeMax: "Max a/al",
		cellsizeTypeMean: "Medie a/al",
		cellsizeTypeLast: "Ultimul din",
		extentTypeFirst: "Primul din",
		extentTypeIntersection: "Intersecţie a/al",
		extentTypeUnion: "Reuniune a /al",
		extentTypeLast: "Ultimul din",
		noDataInterpretAny: "Potriviţi orice",
		noDataInterpretAll: "Potriviţi toate",
		curvatureTypeStandard: "Standard",
		curvatureTypeProfile: "Profil",
		curvatureTypePlanform: "Proiecţie la sol",
		filterTypeLineDetectionHorizontal: "Detectarea liniei orizontală",
		filterTypeLineDetectionVertical: "Detectarea liniei verticală",
		filterTypeLineDetectionLeftDiagonal: "Detectarea liniei diagonala stângă",
		filterTypeLineDetectionRightDiagonal: "Detectarea liniei diagonala dreaptă",
		filterTypeGradientNorth: "Gradient nord",
		filterTypeGradientWest: "Gradient vest",
		filterTypeGradientEast: "Gradient est",
		filterTypeGradientSouth: "Gradient sud",
		filterTypeGradientNorthEast: "Gradient nord est",
		filterTypeGradientNorthWest: "Gradient nord vest",
		filterTypeSmoothArithmeticMean: "Medie aritmetică liniară",
		filterTypeSmoothing3x3: "Liniarizare 3x3",
		filterTypeSmoothing5x5: "Liniarizare 5x5",
		filterTypeSharpening3x3: "Accentuare 3x3",
		filterTypeSharpening5x5: "Accentuare 5x5",
		filterTypeLaplacian3x3: "Laplacian 3x3",
		filterTypeLaplacian5x5: "Laplacian 5x5",
		filterTypeSobelHorizontal: "Sobel orizontal",
		filterTypeSobelVertical: "Sobel vertical",
		filterTypeSharpen: "Creştere claritate",
		filterTypeSharpen2: "Creștere mai mare a clarității",
		filterTypePointSpread: "Extindere punct",
		userDefined: "Definit de utilizator",
		ContourTypeLines: "Linii contur",
		ContourTypeFill: "Umplere contur",
		ContourTypeSmoothOnly: "Doar suprafață netedă",
		rasterizeFirst: "Prima",
		rasterizeLast: "Ultima",
		rasterizeSmallest: "Cea mai mică",
		rasterizeLargest: "Cea mai mare",
		resamplingTypeNearest: "Cel mai apropiat vecin",
		resamplingTypeBilinear: "Interpolare biliniară",
		resamplingTypeCubic: "Convoluție cubică",
		resamplingTypeMajority: "Majoritate",
		resamplingTypeBilinearPlus: "Interpolare biliniară plus",
		resamplingTypeGauss: "Estompare gaussiană",
		resamplingTypeGaussPlus: "Estompare gaussiană plus",
		resamplingTypeAverage: "Medie",
		resamplingTypeMinimum: "Minim",
		resamplingTypeMaximum: "Maxim",
		resamplingTypeVectorAvg: "Medie vectorială",
		minimum: "Minim",
		maximum: "Maxim",
		mean: "Medie",
		stdDeviation: "Deviaţie standard",
		uvMagDirTypeUV: "U-V",
		uvMagDirTypeMagDir: "Magnitudine-Direcţie",
		unknown: "Necunoscut",
		angleRefSysGeographic: "Geografic",
		angleRefSysArithmetic: "Aritmetic",
		interpolateIrregularDataNearest: "Cel mai apropiat vecin",
		interpolateIrregularDataBilinear: "Biliniar",
		interpolateIrregularDataTinningLinear: "Lipire liniar[",
		interpolateIrregularDataTinningNaturalNeighbor: "Vecin natural",
		interpolateIrregularDataTinningIDW: "Distanța inversă ponderată",
		esriRasterThresholdTypeConstant: "Constantă",
		esriRasterThresholdTypeOtsu: "Otsu",
		esriRasterThresholdTypeTsai: "Tsai",
		esriRasterThresholdTypeKapur: "Kapur",
		esriRasterThresholdTypeKittler: "Kittler",
		esriRasterThresholdTypeRosin: "Rosin",
		argStatsTypeMax: "Arg Max",
		argStatsTypeMin: "Arg Min",
		argStatsTypeMedian: "Arg Median",
		argStatsTypeDuration: "Durată",
		arithmeticOpPlus: "Plus",
		arithmeticOpMinus: "Minus",
		arithmeticOpMultiply: "Înmulţire",
		arithmeticOpDivide: "Împărţire",
		arithmeticOpPower: "Putere",
		arithmeticOpMode: "Mod",
		clipTypeOutside: "Se decupează în afară",
		clipTypeInside: "Se decupează înăuntru",
		yes: "Da",
		no: "Nu",
		densities: "Densităţi",
		expectedCounts: "Numere estimate",
		planar: "Planar",
		geodesic: "Geodezic",
		eachCell: "Fiecare celulă",
		eachZone: "Fiecare zonă",
		bestSingle: "Cel mai bun element unic",
		allSightlines: "Toate razele vizuale",
		perimeterSightlines: "Razele vizuale ale perimetrului",
		frequency: "Frecvenţă",
		observers: "Observatori",
		majority: "Majoritate",
		median: "Mediană",
		minority: "Minoritate",
		percentile: "Percentilă",
		range: "Interval",
		sum: "Sumă",
		variety: "Varietate",
		ndvi: "NDVI",
		savi: "SAVI",
		bandArithmeticMethodTSAVI: "SAVI transformat",
		bandArithmeticMethodMSAVI: "SAVI modificat",
		bandArithmeticMethodSultan: "Formula lui Sultan",
		gemi: "GEMI",
		pvi: "PVI",
		gvi: "GVI (Landsat TM)",
		vari: "VARI",
		sr: "SR",
		gndvi: "GNDVI",
		ndvire: "NDVIre",
		srre: "SRre",
		mtvi2: "MTVI2",
		rtviCore: "RTVICore",
		cire: "CIre",
		cig: "CIg",
		ndwi: "NDWI",
		evi: "EVI",
		ironOxide: "Oxid de fier",
		ferrousMinerals: "Minerale feroase",
		clayMinerals: "Minerale de argilă",
		wndwi: "WNDWI",
		bai: "BAI",
		mndwi: "MNDWI",
		nbr: "NBR",
		ndbi: "NDBI",
		ndmi: "NDMI",
		ndsi: "NDSI",
		localSquareRoot: "Rădăcină pătrată",
		localACos: "ACos",
		localASin: "ASin",
		localATan: "ATan",
		localATanH: "ATanH",
		localAbs: "Abs",
		localBitwiseNot: "Bitwise Not",
		localBooleanNot: "Boolean Not",
		localCos: "Cos",
		localCosH: "CosH",
		localExp: "Exp",
		localExp10: "Exp10",
		localExp2: "Exp2",
		localInt: "Int",
		localIsNull: "Este nul",
		localFloat: "Mobil",
		localLn: "Ln",
		localLog10: "Log10",
		localLog2: "Log2",
		localNegate: "Anulare",
		localRoundDown: "Rotunjire prin lipsă",
		localRoundUp: "Rotunjire prin adăugare",
		localSin: "Sin",
		localSinH: "SinH",
		localTan: "Tan",
		localTanH: "TanH",
		localACosH: "ACosH",
		localASinH: "ASinH",
		localPlus: "Plus",
		localMinus: "Minus",
		localTimes: "Timpi",
		localPower: "Putere",
		localBitwiseAnd: "Bitwise And",
		localBitwiseLeftShift: "Bitwise Left Shift",
		localBitwiseOr: "Bitwise Or",
		localBitwiseRightShift: "Bitwise Right Shift",
		localBitwiseXor: "Bitwise Xor",
		localBooleanAnd: "Boolean And",
		localBooleanOr: "Boolean Or",
		localBooleanXor: "Boolean Xor",
		localDivide: "Împărţire",
		localEqualTo: "Egală cu",
		localGreaterThan: "Mai mare decât",
		localGreaterThanEqual: "Mai mare decât egal",
		localLessThan: "Mai mic decât",
		localLessThanEqual: "Mai mic decât egal",
		localMod: "Mod",
		localNotEqual: "Nu este egal cu",
		localATan2: "ATan2",
		localSquare: "Pătrat",
		localSetNull: "Setare nulă",
		remapDefTypeList: "Listă",
		remapDefTypeTable: "Tabel",
		remapTableTypeSimple: "Simplu",
		remapTableTypeDynamic: "Dinamic",
		remapTableTypeReassignment: "Realocare",
		geomCorrectionByConstZ: "Utilzare constantă Z",
		geomCorrectionByDEM: "Utilizare DEM",
		radarCalibBetaNought: "Zero beta",
		radarCalibSigmaNought: "Zero sigma",
		radarCalibGammaNought: "Zero gama",
		speckleFilterTypeLee: "Filtru Lee",
		speckleFilterTypeEnhancedLee: "Filtru Lee îmbunătățit",
		speckleFilterTypeFrost: "Filtru Frost",
		speckleFilterTypeKuan: "Filtru Kuan",
		speckleNoiseModelMul: "Zgomot multiplicativ",
		speckleNoiseModelAdd: "Zgomot adițional",
		speckleNoiseModelAddnMul: "Zgomot adițional și multiplicativ",
		mosaicOpTypeFirst: "Primul",
		mosaicOpTypeLast: "Ultimul",
		mosaicOpTypeMin: "Min",
		mosaicOpTypeMax: "Max",
		mosaicOpTypeMean: "Medie",
		mosaicOpTypeBlend: "Amestec",
		mosaicOpTypeSum: "Sumă",
		integer: "Număr întreg",
		rfxD8: "D8",
		rfxMFD: "MFD",
		dinf: "Dinf",
		vertical: "Verticală",
		horizontal: "Orizontală",
		localCellStatisticsMajority: "Majoritate",
		localCellStatisticsMax: "Maxim",
		localCellStatisticsMean: "Medie",
		localCellStatisticsMedian: "Mediană",
		localCellStatisticsMin: "Minim",
		localCellStatisticsMinority: "Minoritate",
		localCellStatisticsRange: "Interval",
		localCellStatisticsStdDev: "Deviație standard",
		localCellStatisticsSum: "Sumă",
		localCellStatisticsVariety: "Varietate",
		localCellStatisticsMajorityIgnoreND: "Majoritate (Ignorați NoData)",
		localCellStatisticsMaxIgnoreND: "Maximum (Ignorați NoData)",
		localCellStatisticsMeanIgnoreND: "Medie (Ignorați NoData)",
		localCellStatisticsMedianIgnoreND: "Mediană (Ignorați NoData)",
		localCellStatisticsMinIgnoreND: "Minimum (Ignorați NoData)",
		localCellStatisticsMinorityIgnoreND: "Minoritate (Ignorați NoData)",
		localCellStatisticsRangeIgnoreND: "Interval (Ignorați NoData)",
		localCellStatisticsStdDevIgnoreND: "Abatere Standard (Ignorați NoData)",
		localCellStatisticsSumIgnoreND: "Sumă (Ignorați NoData)",
		localCellStatisticsVarietyIgnoreND: "Varietate (Ignorați NoData)",
		localCellStatisticsTypePercentileIgnoreND: "Procent (Ignorați Fără Date)",
		fromSource: "Din sursă",
		toSource: "Către sursă",
		colorspaceConversionRgbToHsv: "RGB către HSV",
		colorspaceConversionHsvToRgb: "HSV către RGB",
		pansharpenTypeIHS: "IHS",
		pansharpenTypeBrovey: "Brovey",
		pansharpenTypeEsri: "Esri",
		pansharpenTypeMean: "Medie",
		pansharpenTypeGramSchmidt: "Gram-Schmidt",
		rectangleNeighborhood: "Dreptunghi",
		circleNeighborhood: "Cerc",
		annulusNeighborhood: "Inel",
		wedgeNeighborhood: "Pană",
		irregularNeighborhood: "Neregulat",
		weightNeighborhood: "Greutate",
		four: "Patru",
		eight: "Opt",
		within: "În",
		cross: "Cruce",
		addLink: "Adăugare legătură",
		noLink: "Fără Link",
		weightedMean: "Medie ponderată",
		ls8QCBitPatternCirrus: "Landsat 8 Cirrus",
		ls8QCBitPatternCloud: "Landsat 8 Nor",
		ls8QCBitPatternCloudShadow: "Landsat 8 Nor Umbră",
		ls8QCBitPatternDesignatedFill: "Landsat 8 Umplere desemnată",
		ls8QCBitPatternDroppedFrame: "Landsat 8 Cadru omis",
		ls8QCBitPatternSnowIce: "Landsat 8 Zăpadă/Gheață",
		ls8QCBitPatternTerrainOcclusion: "Landsat 8 Ocluzie teren",
		ls8QCBitPatternVegetation: "Landsat 8 Vegetație",
		ls8QCBitPatternWater: "Landsat 8 Apă",
		downStream: "În aval",
		upStream: "În amonte",
		strahler: "STRAHLER",
		shreve: "SHREVE",
		currentSlice: "Sector actual",
		allSlices: "Toate sectoarele",
		expandDistance: "DISTANŢĂ",
		expandMorphological: "MORFOLOGIC",
		spectralProfileFile: "Profil spectral",
		trainingFeatureFile: "Obiect spațial pentru instruire",
		randomDistributionTypeUniform: "Uniformă",
		randomDistributionTypeUniformInteger: "Număr întreg",
		randomDistributionTypeNormal: "Normal",
		randomDistributionTypeExponential: "Exponenţial",
		randomDistributionTypePoisson: "Poisson",
		randomDistributionTypeGamma: "Gamma",
		randomDistributionTypeBinomial: "Binomial",
		randomDistributionTypeGeometric: "Zone geometrice",
		randomDistributionTypeNegativeBinomial: "Binomial negativ",
		randomGeneratorTypeStandardCRand: "Chenar C Standard",
		randomGeneratorTypeAlgorithmACM599: "Algoritm colectat ACM 599",
		randomGeneratorTypeMersenneTwister: "Mersenne Twister",
		sumName: "Sumă",
		medainName: "Mediană",
		trendLinear: "Liniar",
		trendHarmonic: "Armonică",
		trendPolynomial: "Polinomial",
		trendMannKendall: "Mann-Kendall",
		trendSeasonalKendall: "Sezonier Kendall",
		dimensionByValue: "După valoare",
		dimensionByInterval: "După interval",
		mdimDefTypeAll: "Toți",
		mdimDefTypeByValues: "După valori",
		mdimDefTypeByRanges: "După intervale",
		mdimDefTypeByIteration: "După iterație",
		mdimDefTypeByInterval: "După interval",
		mdimDefTypeByTargetRaster: "În funcție de rasterul țintă",
		esriTimeUnitsHours: "Ore",
		esriTimeUnitsDays: "Zile",
		esriTimeUnitsWeeks: "Săptămâni",
		esriTimeUnitsMonths: "Luni",
		esriTimeUnitsYears: "Ani",
		esriTimeIntervalKeywordHourly: "În fiecare oră",
		esriTimeIntervalKeywordDaily: "Zilnic",
		esriTimeIntervalKeywordWeekly: "Săptămânal",
		esriTimeIntervalKeywordDekadly: "O dată la 10 zile",
		esriTimeIntervalKeywordPentadly: "O dată la 5 zile",
		esriTimeIntervalKeywordMonthly: "Lunar",
		esriTimeIntervalKeywordQuarterly: "Trimestrial",
		esriTimeIntervalKeywordYearly: "Anual",
		esriTimeIntervalKeywordRecurringDaily: "Recurență zilnică",
		esriTimeIntervalKeywordRecurringWeekly: "Recurență săptămânală",
		esriTimeIntervalKeywordRecurringMonthly: "Recurență lunară",
		esriTimeIntervalKeywordRecurringQuarterly: "Recurență trimestrială",
		aggDefTypeAll: "Totul",
		aggDefTypeIntervalKeyword: "Interval cuvinte cheie",
		aggDefTypeIntervalValue: "Interval valori",
		aggDefTypeIntervalRanges: "Interval domenii",
		latestChange: "Data ultimei modificări",
		earliestChange: "Data primei modificări",
		largestChange: "Data celei mai mari modificări",
		numberOfChanges: "Număr de modificări",
		longestChange: "Timpul celei mai lungi schimbări",
		shortestChange: "Timpul celei mai scurte schimbări",
		fastestChange: "Timpul celei mai rapide schimbări",
		slowestChange: "Timpul celei mai lente schimbări",
		allChanges: "Totul",
		increaseChanges: "Creștere",
		decreaseChanges: "Scădere",
		segmentBeginning: "Începutul segmentului",
		segmentEnd: "Sfârșitul segmentului",
		esriComputeChangeMethodDifference: "Diferență",
		esriComputeChangeMethodRelativeDifference: "Diferență relativă",
		esriComputeChangeMethodCategorical: "Diferență de categorii",
		esriComputeChangeMethodMultispectralEuclideanDistance: "Distanță euclidiană spectrală",
		esriComputeChangeMethodMultispectralAngularDifference: "Distanță de unghi spectral",
		esriComputeChangeMethodMultispectralAxisWithBiggestChange: "Banda cu cea mai mare schimbare",
		esriComputeChangeKeepAll: "Păstrați tot",
		esriComputeChangeKeepChangedOnly: "Păstrați doar pixelii modificați",
		esriComputeChangeKeepUnchangedOnly: "Păstrați doar pixelii nemodificați",
		esriComputeChangeUseColorAverage: "Culorii medii de la și până la",
		esriComputeChangeUseColorFrom: "Culori de utilizare de la",
		esriComputeChangeUseColorTo: "Culori de utilizare până la",
		factorFunctionBinary: "Binar",
		factorFunctionForward: "Înainte",
		factorFunctionLinear: "Liniar",
		factorFunctionInvLinear: "Liniar invers",
		factorFunctionTable: "Tabel",
		factorFunctionSymLinear: "Liniar simetric",
		factorFunctionSymInvLinear: "Liniar invers simetric",
		factorFunctionCos: "Cosinus",
		factorFunctionSec: "Secantă",
		factorFunctionCosSec: "Secanta cosinusului",
		factorFunctionSecCos: "Cosinusul secantei",
		noSort: "Nu sortați",
		ascend: "Crescător",
		descend: "Descrescător",
		autoDetect: "Detectare automată",
		nearest: "Cel mai apropiat",
		linear: "Liniar",
		esriMonthJanuary: "Ianuarie",
		esriMonthFebruary: "Februarie",
		esriMonthMarch: "Martie",
		esriMonthApril: "Aprilie",
		esriMonthMay: "Mai",
		esriMonthJune: "Iunie",
		esriMonthJuly: "Iulie",
		esriMonthAugust: "August",
		esriMonthSeptember: "Septembrie",
		esriMonthOctober: "Octombrie",
		esriMonthNovember: "Noiembrie",
		esriMonthDecember: "Decembrie",
		dimensionalMovingIgnoreNoData: "Date",
		dimensionalMovingPropagateNoData: "NoData",
		dimensionalMovingFillOnlyNoData: "Completați câmpurile fără date",
		circularMean: "Medie circulară",
		circularName: "Circulară",
		arithmeticName: "Aritmetic",
		slopeName: "Pantă",
		aspectName: "Aspect",
		meanCurvature: "Curbură medie",
		profileCurvature: "Curbură de profil (linie de pantă normală)",
		tangentialCurvature: "Curbură tangențială (contur normal)",
		planCurvature: "Curbură plană (contur proiectat)",
		contourGeodesicTorsion: "Torsiune geodezică de contur",
		gaussianCurvature: "Curbură gaussiană",
		casoratiCurvature: "Curbura lui Casorati",
		localSurfaceTypeQuadratic: "Cuadratică",
		localSurfaceTypeBiquadratic: "Bicuadratică",
		thresholdNoThreshold: "Fără prag",
		thresholdPercentLeastCost: "Procent din costul cel mai scăzut",
		thresholdAccumulativeCost: "Cost acumulativ",
		clrmapTypeHillshade: "Hillshade"
	},
	categoryLabels: {
		sourceCharacteristics: "Caracteristici sursă",
		neighborhoodSettings: "Setări vecinătate",
		statistics: "Statistică",
		gamma: "Gamma",
		viewshedParameters: "Paremetrii viewshed",
		observerParameters: "Parametrii observator",
		irregularDataInterpolation: "Interpolarea neregulată a datelor",
		modelStatistics: "Statistici de model",
		aggregationDef: "Definiție de agregare",
		filterByAttributes: "Filtrare după atribute",
		percentileName: "Percentilă",
		rasterInfo: "Informații despre raster",
		extent: "Extindere",
		spatialReference: "Referinţă spaţială"
	},
	outputRasterHelpTexts: {
		outputName: "<p>Numele stratului tematic care va fi creat și adăugat pe hartă.</p>",
		resultType: "<p>Tipul de ieșire care va fi creată. Ieșirile pot fi straturi tematice de imagini satelitare cu structură tile sau straturi tematice de imagini satelitare dinamice.</p>",
		saveResultIn: "<p>Numele folderului din <b>Resursele mele</b> în care va fi salvat rezultatul.</p>"
	},
	analysisEnvironmentsHelpTexts: {
		description: "<p>Setările mediului pentru analiza în Map Viewer. </p>",
		outSR: "<p>Specifică sistemul de coordonate pentru analiză și stratul tematic de rezultate.</p>",
		extent: "<p>Specifică zona de utilizat pentru analiză.</p>",
		snapRaster: "<p>Se reglează extinderea ieșirii pentru a se potrivi cu alinierea celulelor stratului tematic specificat de fixare raster.</p>",
		cellSize: "<p>Specifică dimensiunea celulei sau rezoluția care va fi utilizată pentru analiză și pentru a crea stratul tematic de raster de ieșire.</p>",
		mask: "<p>Specifică un strat tematic mască, în care doar celulele care intră în zona măștii vor fi folosite pentru analiză.</p>",
		resamplingMethod: "<p>Specifică modul de interpolare a valorilor pixelilor când rasterele de intrare și de ieșire nu se aliniază.</p>"
	},
	mainGenStrings: {
		unsupportedDataType: "Tip neacceptat",
		currentlyUnsupported: " Un editor implicit pentru ${missingType} este în așteptare, dar va sosi în curând. Casetă de text pentru substituent temporar pentru specificarea intrărilor bazate pe șiruri.",
		unsupportedOverrideWarning: "O componentă de editor de suprascriere care furnizează un mai bun UX pentru lucrul cu următorul(i) parametru(i) este în așteptare, dar va sosi în curând:",
		overrideWidgetMissing: "Componente editor suprascriere lipsă!",
		uiIncomplete: "Trimiterea lucrării nu a reușit. Funcția nu poate fi executată pentru că unele dintre câmpurile obligatorii sunt incomplete sau lipsesc din UI.",
		count: "Număr",
		selectVariables: "Selectare variabile",
		selectFeature: "Selectarea unui strat tematic de obiect spațial",
		greaterThanErrorMessage: "Numărul de intrare trebuie să fie mai mare decât ${min}",
		lesserThanErrorMessage: "Numărul de intrare trebuie să fie mai mic decât ${max}",
		greaterThanOrEqualErrorMessage: "Numărul de intrare trebuie să fie mai mare sau egal cu ${min}",
		lesserThanOrEqualErrorMessage: "Numărul de intrare trebuie să fie mai mic sau egal cu ${max}",
		allowScalar: "Selectați un strat tematic sau introduceți o constantă",
		selectField: "Selectare câmp",
		parameterRequired: "Acest parametru este obligatoriu.",
		enterAValue: "Introduceți o valoare...",
		invalidInput: "Valoarea introdusă nu este validă.",
		itemNotFound: "Elementul nu există sau este inaccesibil.",
		itemPermissionDenied: "Nu aveți permisiuni de accesare a acestui element.",
		layerNotAvailable: "Nu s-a reușit încărcarea stratului tematic ${layerName}.",
		multipleLayersNotAvailable: "Nu s-a reușit încărcarea stratului tematic ${layerName} și a altora.",
		learnMoreLabel: "Aflați mai multe",
		fieldNotAvailable: "Nu s-a reușit încărcarea câmpului.",
		allowAnalysis: "Analiza nu este permisă în serviciul de imagine.",
		allowAnalysisReason: "Unul sau mai multe straturi tematice de pe hartă nu sunt enumerate aici pentru că nu permit analiza.",
		learnMoreText: "Aflați mai multe",
		atLeastOneRasterInput: "Cel puțin un strat tematic de intrare ar trebui să fie un strat tematic de raster.",
		browseAnalysisLayers: "Răsfoirea straturilor tematice",
		activeMapViewExtent: "Utilizarea extinderii hărții curente",
		chooseRaster: "Alegere raster de decupare",
		chooseGeometry: "Alegere geometrie de decupare",
		resultType: "Tip rezultat",
		saveInFolder: "Salvare în director",
		outputName: "Nume ieșire",
		outputLayerType: "Tip strat tematic de ieșire",
		dynamicImageryLayer: "Strat tematic de imagini satelitare dinamice",
		tiledImageryLayer: "Strat tematic de imagistică cu segmente tile",
		custom: "Personalizare",
		loading: "Se încarcă...",
		layerMissing: "Unul sau mai multe straturi tematice de pe hartă nu sunt enumerate aici pentru că nu permit analiza. Aflaţi mai multe.",
		browseCoordinateSystems: "Răsfoire sisteme de coordonate",
		unableToRepopulateOutSR: "Nu se poate popula sistemul de coordonate de ieșire.",
		defaultTitle: "Vedeți mai mult",
		"ARC (equal arc-second)": "ARC (aer egal secundar)",
		Africa: "Africa",
		Antarctica: "Antarctica",
		Argentina: "Argentina",
		Asia: "Asia",
		"Asteroid Belt": "Centură de asteroizi",
		"Atlantic Ocean": "Oceanul Atlantic",
		Australia: "Australia",
		"Australia and New Zealand": "Australia și Noua Zeelandă",
		Austria: "Austria",
		"BLM (US Feet)": "BLM (picioare SUA)",
		Bangladesh: "Bangladesh",
		"Beijing 1954": "Beijing 1954",
		Bhutan: "Bhutan",
		CGCS2000: "CGCS2000",
		Canada: "Canada",
		Caribbean: "Caraibe",
		"Caribbean Sea": "Marea Caraibelor",
		"Central America": "America Centrală",
		"Central and North America": "America Centrală și de Nord",
		Colombia: "Columbia",
		Continental: "Continental",
		"County Systems": "Sisteme regionale",
		"Democratic Republic of the Congo": "Republica Democrată Congo",
		"EPSG Arctic": "EPSG Arctic",
		Earth: "Terra",
		"Ellipsoidal-based": "Bazat pe elipsoidă",
		Europe: "Europa",
		Finland: "Finlanda",
		France: "Franţa",
		"GSK 2011": "GSK 2011",
		"Gauss Kruger": "Gauss Kruger",
		"Geographic Coordinate Systems": "Sisteme de coordonate geografice",
		Germany: "Germania",
		"Gravity-related": "Legat de gravitație",
		"Greenwich-based": "Bazat pe Greenwich",
		"Highways England": "Autostrăzi Anglia",
		Illinois: "Illinois",
		"Indian Ocean": "Oceanul Indian",
		"Indian Subcontinent": "Subcontinentul indian",
		Indiana: "Indiana",
		Indonesia: "Indonezia",
		Iowa: "Iowa",
		"Ireland and United Kingdom": "Irlanda și Regatul Unit",
		Italy: "Italia",
		Japan: "Japonia",
		Jupiter: "Jupiter",
		Kansas: "Kansas",
		"Las Vegas": "Las Vegas",
		Libya: "Libia",
		Malaysia: "Malaysia",
		"Malaysia and Singapore": "Malaysia și Singapore",
		Mars: "Marte",
		Mercury: "Mercur",
		Minnesota: "Minnesota",
		Montana: "Montana",
		"NAD 1927": "NAD 1927",
		"NAD 1927 (US Feet)": "NAD 1927 (picioare SUA)",
		"NAD 1983": "NAD 1983",
		"NAD 1983 (2011)": "NAD 1983 (2011)",
		"NAD 1983 (2011) (Intl Feet)": "NAD 1983 (2011) (picioare internaționale)",
		"NAD 1983 (2011) (Meters)": "NAD 1983 (2011) (metri)",
		"NAD 1983 (2011) (US Feet)": "NAD 1983 (2011) (picioare SUA)",
		"NAD 1983 (CORS96) (Intl Feet)": "NAD 1983 (CORS96) (picioare internaționale)",
		"NAD 1983 (CORS96) (Meters)": "NAD 1983 (CORS96) (metri)",
		"NAD 1983 (CORS96) (US Feet)": "NAD 1983 (CORS96) (picioare SUA)",
		"NAD 1983 (Intl Feet)": "NAD 1983 (picioare internaționale)",
		"NAD 1983 (Meters)": "NAD 1983 (metri)",
		"NAD 1983 (PA11) (Meters)": "NAD 1983 (PA11) (metri)",
		"NAD 1983 (PA11) (US Feet)": "NAD 1983 (PA11) (picioare SUA)",
		"NAD 1983 (US Feet)": "NAD 1983 (picioare SUA)",
		"NAD 1983 HARN (Intl Feet)": "NAD 1983 HARN (picioare internaționale)",
		"NAD 1983 HARN (Meters)": "NAD 1983 HARN (metri)",
		"NAD 1983 HARN (US Feet)": "NAD 1983 HARN (picioare SUA)",
		"NAD 1983 NSRS2007 (Intl Feet)": "NAD 1983 NSRS2007 (picioare internaționale)",
		"NAD 1983 NSRS2007 (Meters)": "NAD 1983 NSRS2007 (metri)",
		"NAD 1983 NSRS2007 (US Feet)": "NAD 1983 NSRS2007 (picioare SUA)",
		"National Grids": "Grile naționale",
		Navajo: "Navajo",
		Neptune: "Neptun",
		"New Beijing": "Noul Beijing",
		"New Zealand": "Noua Zeelandă",
		"North America": "America de Nord",
		"Northern Hemisphere": "Emisfera nordică",
		Norway: "Norvegia",
		Oceans: "Oceane",
		Oregon: "Oregon",
		"Other GCS": "Alt GCS",
		"Pacific Ocean": "Oceanul Pacific",
		Pluto: "Pluto",
		Polar: "Polar",
		Portugal: "Portugalia",
		"Projected Coordinate Systems": "Sisteme de coordonate proiectate",
		"Pulkovo 1942": "Pulkovo 1942",
		"Pulkovo 1995": "Pulkovo 1995",
		Replaced: "Înlocuit",
		"SAD 1969": "SAD 1969",
		SIRGAS: "SIRGAS",
		"SIRGAS 2000": "SIRGAS 2000",
		Saturn: "Saturn",
		"Solar System": "Sistemul Solar",
		"South Africa": "Africa de Sud",
		"South America": "America de Sud",
		"South Korea": "Coreea de Sud",
		"Southern Hemisphere": "Emisfera sudică",
		"Spheroid-based": "Pe bază sferoidă",
		"State Plane": "Avion statal",
		"State Systems": "Sisteme statale",
		Sweden: "Suedia",
		"Switzerland and Liechtenstein": "Elveția și Liechtenstein",
		Texas: "Texas",
		Tribal: "Tribale",
		Turkey: "Turcia",
		"US Feet": "Picioare SUA",
		"USA and territories": "SUA și teritoriile",
		UTM: "UTM",
		Ukraine: "Ucraina",
		"Unknown Height Systems": "Sisteme de înălțime necunoscute",
		Uranus: "Uranus",
		Venus: "Venus",
		"Vertical Coordinate Systems": "Sisteme de coordonate verticale",
		Vietnam: "Vietnam",
		"WGS 1972": "WGS 1972",
		"WGS 1984": "WGS 1984",
		Wisconsin: "Wisconsin",
		"Wisconsin CRS": "Wisconsin CRS",
		World: "Glob",
		"World (Sphere-based)": "Glob (formă sferică)",
		Wyoming: "Wyoming",
		"Xian 1980": "Xian 1980",
		done: "Gata",
		noResults: "Nu a fost găsit niciun rezultat",
		searchPlaceholder: "Nume sau WKID",
		browseTemplate: "Căutați șabloane de funcție raster",
		saveTemplate: "Salvare șablon funcție raster",
		preview: "Previzualizare",
		previewDescription: "Previzualizați rezultatul înainte de a executa analiza.",
		showPreview: "Afișare previzualizare",
		previewLayer: "Previzualizare strat tematic ${number}",
		newPreview: "Previzualizare nouă",
		previewPopup: "Activați previzualizarea rezultatelor analizei pe baza parametrilor de intrare.",
		updatePreviewLayer: "Actualizare strat tematic de previzualizare selectat",
		createPreviewLayer: "Creare strat tematic de previzualizare nou",
		maximumPreviewAllowed: "Număr maxim de straturi tematice de previzualizare permis: ${maxCount}",
		previewFailure: "Acest strat tematic de previzualizare este indisponibil. Verificați parametrii de intrare și actualizați acest strat tematic de previzualizare din nou.",
		header: "Selectați un element",
		content: "Aveți modificări nesalvate în ${rftTitle}. Dacă începeți din nou cu un șablon nou, acele modificări vor fi pierdute.",
		dontSave: "Nu salvați",
		"continue": "Continuare",
		stretch: "Fixare în fereastră",
		pan: "Panoramare",
		newTemplate: "Creare șablon nou",
		openTemplate: "Deschidere șablon",
		addFunction: "Adăugare funcții raster",
		addConstant: "Adăugare constantă",
		addRaster: "Adăugare variabilă raster",
		move: "Mutare",
		zoom: "Zoom",
		saveAs: "Salvare ca",
		clear: "Golire",
		addRasterFunctionTitle: "Adăugare funcții raster",
		templatePropertiesTitle: "Proprietăți șablon",
		browseRFT: "Căutați șabloane de funcție raster",
		defaultToolDescription: "Instrument de analiză ${toolTitle}.",
		openToolText: "Deschidere instrument",
		toolDropdownText: "Instrument derulantă",
		addToMap: "Confirmare și adăugare la hartă",
		confirm: "Confirmare",
		select: "Selectare",
		selectTask: "Selectare activitate",
		unsupportedLayer: "Acest parametru nu acceptă următoarele straturi tematice: ${layerName}.",
		viewDetails: "Vizualizați toate detaliile elementului",
		rename: "Redenumire",
		duplicate: "Duplicate",
		launch: "Deschidere pentru executare",
		templateEditor: "Editor șabloane",
		createItem: "Salvare șablon funcție raster",
		actionLabel: "Filtrare",
		filterPopoverHeading: "Filtrarea funcțiilor",
		defaultSearchPlaceholder: "Căutare după nume",
		settings: "Setări",
		summary: "Rezumat",
		definitionQuery: "Interogare definiție",
		matchVariables: "Variabile de potrivire",
		unionDimension: "Dimensiune uniune",
		nameEditorPlaceholder: "Introducere titlu",
		summaryEditorPlaceholder: "Introduceți o scurtă descriere.",
		definitionQueryPlaceholder: "Introduceți...",
		upload: "Încărcare",
		chooseImage: "Faceți clic pentru a alege un fișier",
		update: "Actualizare",
		thumbnailErrors: {
			wrongImageType: "A fost selectat tipul eronat de imagine",
			notAvailable: "Miniatură indisponibilă",
			loadError: "Nu s-a putut încărca imaginea",
			chooseFile: "Faceți clic pentru a alege fișierul"
		}
	}
};
const copy = "Copiere";
const save = "Salvați";
const title = "Titlu";
const folder = "Folder";
const tags = "Etichete";
const savingMessage = "Salvare reper în";
const shareWith = "Partajare cu";
const share = "Partajare";
const setSharingLevel = "Setați nivelul de partajare";
const setGroupSharing = "Setați partajarea cu un grup";
const owner = "Proprietar";
const organization = "Organizaţie";
const everyone = "Toată lumea (public)";
const groups = "Grupuri:";
const type = "Tip";
const mosaic = "Mozaic";
const itemGroup = "Grup de reper";
const item = "Element";
const definitionQuery = "Interogare definiție";
const groupItemsBy = "Grupați elementele după";
const groupFieldName = "Numele câmpului grup";
const tagFieldName = "Numele câmpului etichetă";
const noTitleTagErrorMsg = "Trebuie să furnizați un titlu pentru reperul dvs. și etichete pentru a permite găsirea hărții prin intermediul căutărilor.";
const noTitleErrorMsg = "Trebuie să furnizaţi un titlu pentru elementul dvs.";
const noTagErrorMsg = "Trebuie să furnizați cel puțin o etichetă pentru a ajuta utilizatorii să găsească reperul dvs. prin intermediul căutărilor.";
const error = "Eroare";
const warning = "Avertisment";
const success = "Succes";
const details = "Detalii:";
const tryAgain = "Încercaţi din nou";
const toolModeler = {
	save: "Salvați",
	editProperties: "Editare proprietăţi",
	saveAs: "Salvare ca",
	savingNotification: "Salvare modificări în reperul...",
	savingTitle: "Se salvează",
	saveFailedMessage: "Schimbările nu au putut fi salvate.",
	saveWithErrorsMessage: "Modificările au fost salvate cu următoarele erori.",
	viewItemMessage: "Vizualizați reperul salvat",
	here: "aici.",
	itemCreatedMessage: "A fost creat un element nou.",
	clickToViewItemMessage: "Faceți clic pe OK pentru a vizualiza pagina de detalii ale elementului; faceți clic pe Anulare pentru a continua.",
	readingFailed: "A eşuat încărcarea șablonului de funcție raster selectat.",
	failedToLoadXML: "A eșuat încărcarea șablonului de funcție raster selectat în format XML.",
	learnMore: "Aflați mai multe",
	overwriteTitle: "Confirmare suprascriere",
	overwriteMessage: "Doriţi să suprascrieţi elementul existent?",
	overwriteSuccessMessage: "Elementul a fost actualizat."
};
const toolEditor = {
	run: "Executare",
	save: "Salvați",
	deleteSelected: "Ştergeți elementele selectate",
	addRaster: "Adăugați raster",
	addScalar: "Adăugați valoare scalară",
	layout: "Configurație automată",
	errorTitle: "Eroare",
	invalidToolMessage: "Șablonul de funcție raster nu este valabil.",
	out: "Ieșire",
	zoomIn: "Mărire",
	zoomOut: "Micşorare",
	zoomToFit: "Fixați în fereastră",
	panOn: "Treceți pe modul pan",
	panOff: "Opriți modul pan",
	defaultModelName: "Model de instrument",
	defaultRasterName: "Raster"
};
const toolDetailsEditor = {
	defaultToolName: "Şablon funcţie raster",
	defaultToolDescription: "Adăugaţi un scurt rezumat despre funcţia raster.",
	defaultHelpText: "Dați clic pe simbolul de ajutor pentru a edita textul de asistență",
	editHelpTitle: "Asistență pentru editare",
	saveLabel: "Salvați",
	cancelLabel: "Anulare",
	thumbnail: {
		wrongImageType: "A fost selectat tipul eronat de imagine",
		notAvailable: "Miniatură indisponibilă",
		loadError: "Nu s-a putut încărca imaginea",
		chooseFile: "Faceţi clic pe selectarea fişierului"
	}
};
const saveUtils = {
	thumbnail: "Miniatură",
	sharing: "Partajare"
};
const close = "Închidere";
const unsavedWarningExisting = "Doriţi să salvaţi modificările aduse elementului <b>${itemTitle}</b> ?";
const unsavedWarningNew = "Doriţi să salvați modificările?";
const saveAs = "Salvare ca";
const dontSave = "Nu se salvează";
const unsavedTitle = "Modificări nesalvate";
const invalidRFTMessage = "Șablonul de funcție raster creat nu este valabil.";
const errorTitle = "Eroare";
const breadcrumb = "Editor de funcție raster";
const breadcrumbEditor = "Conținut > Editor de funcție raster";
const viewerModeTitle = "Numai citire";
const viewerModeMessage = "Elementul șablon de funcție raster este numai pentru citire. Modificările nu pot fi salvate.";
const userStartDirection = "Selectați o funcție pentru a începe construirea unui șablon de funcţie raster.";
const selectFunction = "Adăugare funcție";
const deselectFunction = "Eliminare funcție";
const dialogTitle = "Sistem";
const category = "Categorii";
const search = "Căutați funcţii raster";
const categoryNames = {
	analysis: "Analiză",
	appearance: "Aspect",
	classification: "Clasificare",
	conversion: "Conversie",
	correction: "Corecţie",
	dataManagement: "Administrare date",
	distance: "Distanță",
	distanceLegacy: "Distanță (Legacy)",
	hydrology: "Hidrologie",
	math: "Matematică",
	mathConditional: "Matematică: Condițional",
	mathLogical: "Matematică: Logică",
	mathTrigonometric: "Matematică: trigonometrie",
	reclass: "Reclasificare",
	statistical: "Statistic",
	surface: "Suprafață"
};
const commonStrings_ro = {
	ok: ok,
	cancel: cancel,
	enterURL: enterURL,
	serviceURL: serviceURL,
	selectRaster: selectRaster,
	failedToLoadLayer: failedToLoadLayer,
	loadingLayer: loadingLayer,
	selectFeature: selectFeature,
	enterFURL: enterFURL,
	addRaster: addRaster,
	addScalar: addScalar,
	raster: raster,
	scalar: scalar,
	defaultModelName: defaultModelName,
	general: general,
	parameters: parameters,
	variables: variables,
	name: name,
	description: description,
	parameter: parameter,
	isPublic: isPublic,
	isDataset: isDataset,
	unknownPixelType: unknownPixelType,
	outputPixelType: outputPixelType,
	u8PixelType: u8PixelType,
	s8PixelType: s8PixelType,
	u16PixelType: u16PixelType,
	s16PixelType: s16PixelType,
	u32PixelType: u32PixelType,
	s32PixelType: s32PixelType,
	f32PixelType: f32PixelType,
	f64PixelType: f64PixelType,
	properties: properties,
	multidimensionalRules: multidimensionalRules,
	matchVariables: matchVariables,
	unionDimensions: unionDimensions,
	rasterFunctionEditor: rasterFunctionEditor,
	rfxLicenseInfo: rfxLicenseInfo,
	rasterFunctions: rasterFunctions,
	copy: copy,
	save: save,
	title: title,
	folder: folder,
	tags: tags,
	savingMessage: savingMessage,
	shareWith: shareWith,
	share: share,
	setSharingLevel: setSharingLevel,
	setGroupSharing: setGroupSharing,
	owner: owner,
	organization: organization,
	everyone: everyone,
	groups: groups,
	type: type,
	mosaic: mosaic,
	itemGroup: itemGroup,
	item: item,
	definitionQuery: definitionQuery,
	groupItemsBy: groupItemsBy,
	groupFieldName: groupFieldName,
	tagFieldName: tagFieldName,
	noTitleTagErrorMsg: noTitleTagErrorMsg,
	noTitleErrorMsg: noTitleErrorMsg,
	noTagErrorMsg: noTagErrorMsg,
	error: error,
	warning: warning,
	success: success,
	details: details,
	tryAgain: tryAgain,
	toolModeler: toolModeler,
	toolEditor: toolEditor,
	toolDetailsEditor: toolDetailsEditor,
	saveUtils: saveUtils,
	close: close,
	unsavedWarningExisting: unsavedWarningExisting,
	unsavedWarningNew: unsavedWarningNew,
	saveAs: saveAs,
	dontSave: dontSave,
	unsavedTitle: unsavedTitle,
	invalidRFTMessage: invalidRFTMessage,
	errorTitle: errorTitle,
	breadcrumb: breadcrumb,
	breadcrumbEditor: breadcrumbEditor,
	viewerModeTitle: viewerModeTitle,
	viewerModeMessage: viewerModeMessage,
	userStartDirection: userStartDirection,
	selectFunction: selectFunction,
	deselectFunction: deselectFunction,
	dialogTitle: dialogTitle,
	category: category,
	search: search,
	categoryNames: categoryNames
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (commonStrings_ro);


//# sourceMappingURL=common-strings.ro-db6b4694.js.map

/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid2lkZ2V0cy9jaHVua3MvYXJjZ2lzX2FuYWx5c2lzX25vZGVfbW9kdWxlc19hcmNnaXNfYXJjZ2lzLXJhc3Rlci1mdW5jdGlvbi1lZGl0b3JfLWQwNDViNi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd1lBQXdZLCtIQUErSCw0REFBNEQ7QUFDbmtCO0FBQ0E7QUFDQSwyYkFBMmI7QUFDM2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtIQUErSDtBQUMvSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ05BQWdOO0FBQ2hOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2akJBQTZqQjtBQUM3akI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlQQUF5UDtBQUN6UDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMHhDQUEweEMsMlVBQTJVO0FBQ3JtRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc3VFQUFzdUUsMjJCQUEyMkIsT0FBTztBQUN4bEc7QUFDQTtBQUNBLCswQ0FBKzBDO0FBQy8wQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0Esc0RBQXNELGFBQWE7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0VBQStFLElBQUk7QUFDbkYsNkVBQTZFLElBQUk7QUFDakYsNEZBQTRGLElBQUk7QUFDaEcsMEZBQTBGLElBQUk7QUFDOUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUUsVUFBVTtBQUM3RSw0RUFBNEUsV0FBVztBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxPQUFPO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUZBQXVGLFNBQVM7QUFDaEc7QUFDQTtBQUNBLDRDQUE0QyxTQUFTO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELFVBQVU7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUZBQWlGLFVBQVU7QUFDM0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0dBQWtHO0FBQ2xHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRkFBc0YsVUFBVTtBQUNoRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlFQUFlLGdCQUFnQixFQUFDO0FBQ2lvQzs7QUFFanFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZXhiLWNsaWVudC8uL2V4dGVuc2lvbnMvd2lkZ2V0cy9hcmNnaXMvYW5hbHlzaXMvbm9kZV9tb2R1bGVzL0BhcmNnaXMvYXJjZ2lzLXJhc3Rlci1mdW5jdGlvbi1lZGl0b3IvZGlzdC9lc20vY29tbW9uLXN0cmluZ3Mucm8tZGI2YjQ2OTQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3Qgb2sgPSBcIk9LLlwiO1xuY29uc3QgY2FuY2VsID0gXCJBbnVsYXJlXCI7XG5jb25zdCBlbnRlclVSTCA9IFwiSW50cm9kdWNlyJtpIFVSTCBzZXJ2aWNpdSBkZSBpbWFnaW5pXCI7XG5jb25zdCBzZXJ2aWNlVVJMID0gXCJVUkwgc2VydmljaXVcIjtcbmNvbnN0IHNlbGVjdFJhc3RlciA9IFwiU2VsZWN0YcibaSByYXN0ZXJcIjtcbmNvbnN0IGZhaWxlZFRvTG9hZExheWVyID0gXCJBIGXImXVhdCDDrm5jxINyY2FyZWEgU3RyYXR1bHVpIHRlbWF0aWNcIjtcbmNvbnN0IGxvYWRpbmdMYXllciA9IFwiU2Ugw65uY2FyY8SDIHN0cmF0dWxcIjtcbmNvbnN0IHNlbGVjdEZlYXR1cmUgPSBcIlNlbGVjdGFyZSBzdHJhdCB0ZW1hdGljIGRlIG9iaWVjdGUgc3BhyJtpYWxlXCI7XG5jb25zdCBlbnRlckZVUkwgPSBcIkludHJvZHVjZXJlIFVSTCBzZXJ2aWNpdSBkZSBvYmllY3RlIHNwYcibaWFsZVwiO1xuY29uc3QgYWRkUmFzdGVyID0gXCJBZMSDdWdhyJtpIHZhcmlhYmlsYSByYXN0ZXJcIjtcbmNvbnN0IGFkZFNjYWxhciA9IFwiQWTEg3VnYXJlIGNvbnN0YW50xINcIjtcbmNvbnN0IHJhc3RlciA9IFwiUmFzdGVyXCI7XG5jb25zdCBzY2FsYXIgPSBcIlNjYWxhclwiO1xuY29uc3QgZGVmYXVsdE1vZGVsTmFtZSA9IFwixZ5hYmxvbiBmdW5jxaNpZSByYXN0ZXJcIjtcbmNvbnN0IGdlbmVyYWwgPSBcIkluZm9ybWHIm2lpIGdlbmVyYWxlXCI7XG5jb25zdCBwYXJhbWV0ZXJzID0gXCJQYXJhbWV0cmlcIjtcbmNvbnN0IHZhcmlhYmxlcyA9IFwiVmFyaWFiaWxlXCI7XG5jb25zdCBuYW1lID0gXCJOdW1lXCI7XG5jb25zdCBkZXNjcmlwdGlvbiA9IFwiRGVzY3JpZXJlXCI7XG5jb25zdCBwYXJhbWV0ZXIgPSBcIlBhcmFtZXRydVwiO1xuY29uc3QgaXNQdWJsaWMgPSBcIklzUHVibGljXCI7XG5jb25zdCBpc0RhdGFzZXQgPSBcIklzRGF0YXNldFwiO1xuY29uc3QgdW5rbm93blBpeGVsVHlwZSA9IFwiTmVjdW5vc2N1dFwiO1xuY29uc3Qgb3V0cHV0UGl4ZWxUeXBlID0gXCJUaXAgcGl4ZWxpIGRlIGllxZ9pcmVcIjtcbmNvbnN0IHU4UGl4ZWxUeXBlID0gXCI4IEJpdCBuZXNlbW5hdFwiO1xuY29uc3QgczhQaXhlbFR5cGUgPSBcIjggQml0IFNlbW5hdFwiO1xuY29uc3QgdTE2UGl4ZWxUeXBlID0gXCIxNiBCaXQgbmVzZW1uYXRcIjtcbmNvbnN0IHMxNlBpeGVsVHlwZSA9IFwiMTYgQml0IFNlbW5hdFwiO1xuY29uc3QgdTMyUGl4ZWxUeXBlID0gXCIzMiBCaXQgbmVzZW1uYXRcIjtcbmNvbnN0IHMzMlBpeGVsVHlwZSA9IFwiMzIgQml0IFNlbW5hdFwiO1xuY29uc3QgZjMyUGl4ZWxUeXBlID0gXCIzMiBCaXQgTW9iaWxcIjtcbmNvbnN0IGY2NFBpeGVsVHlwZSA9IFwiNjQgQml0IER1Ymx1XCI7XG5jb25zdCBwcm9wZXJ0aWVzID0gXCJQcm9wcmlldMSDyJtpXCI7XG5jb25zdCBtdWx0aWRpbWVuc2lvbmFsUnVsZXMgPSBcIlJlZ3VsaSBtdWx0aWRpbWVuc2lvbmFsZVwiO1xuY29uc3QgbWF0Y2hWYXJpYWJsZXMgPSBcIlZhcmlhYmlsZSBkZSBwb3RyaXZpcmVcIjtcbmNvbnN0IHVuaW9uRGltZW5zaW9ucyA9IFwiRGltZW5zaXVuaSBkZSB1bml1bmVcIjtcbmNvbnN0IHJhc3RlckZ1bmN0aW9uRWRpdG9yID0ge1xuXHRpbnZhbGlkUkZUTWVzc2FnZTogXCLImGFibG9udWwgZGUgZnVuY8ibaWUgcmFzdGVyIG51IGVzdGUgdmFsYWJpbC5cIixcblx0cmZ4QXJnc0VkaXRvcjoge1xuXHRcdG91dHB1dFJhc3RlcjogXCJSYXN0ZXIgaWXImWlyZVwiLFxuXHRcdHJhc3RlcjogXCJSYXN0ZXJcIixcblx0XHR1bnN1cHBvcnRlZERhdGFUeXBlV2FybmluZzogXCJVcm3Eg3RvYXJlbGUgYXJndW1lbnRlIG51IHN1bnQgYWZpxZ9hdGUsIGRlb2FyZWNlIGFjZXN0ZWEgbnUgc3VudCBhY2NlcHRhdGUgw65uIHByZXplbnQuXCIsXG5cdFx0dW5zdXBwb3J0ZWRGdW5jdGlvbjogXCJDb27Im2luZSBmdW5jyJtpZSAoZnVuY8ibaWkpIGRlIHJhc3RlciBuZWFjY2VwdGF0xIMoZSkgbW9tZW50YW4uXCJcblx0fSxcblx0cmZ4UmFzdGVySW5wdXQ6IHtcblx0XHRzZWxlY3RMYXllcjogXCJTZWxlY3RhyJtpIHN0cmF0dWwgdGVtYXRpY1wiLFxuXHRcdGJyb3dzZUxheWVyczogXCJSxINzZm9pcmUgc3RyYXR1cmkgdGVtYXRpY2VcIixcblx0XHRyZnhWYXJpYWJsZTogXCJGdW5jyJtpYSByYXN0ZXIgdmFyaWFiaWzEg1wiXG5cdH0sXG5cdHJmeEJhbmRDb21iaW5hdGlvbkVkaXRvcjoge1xuXHRcdG1ldGhvZExhYmVsOiBcIk1ldG9kxINcIixcblx0XHRiYW5kTGFiZWw6IFwiQmFuZMSDXCIsXG5cdFx0Y29tYmluYXRpb25MYWJlbDogXCJDb21iaW5hxaNpZVwiXG5cdH0sXG5cdHJmeFJlbWFwR3JpZDoge1xuXHRcdG1pbmltdW06IFwiTWluaW1cIixcblx0XHRtYXhpbXVtOiBcIk1heGltXCIsXG5cdFx0b3V0cHV0OiBcIkllxZ9pcmVcIixcblx0XHRub0RhdGE6IFwiTm9EYXRhXCIsXG5cdFx0cmVtYXBWYWx1ZXNMYWJlbDogXCJSZWNhcnRvZ3JhZmllcmUgdmFsb3JpXCJcblx0fSxcblx0cmZ4TmFtZWRSYXN0ZXJFZGl0b3I6IHtcblx0XHRyYXN0ZXJWYXJpYWJsZXM6IFwiVmFyaWFiaWxlIHJhc3RlclwiLFxuXHRcdGRlbGV0ZVNlbGVjdGVkVmFyczogXCJFbGltaW5hcmUgdmFyaWFiaWxlIHNlbGVjdGF0ZVwiXG5cdH0sXG5cdHJmeENsaXBwaW5nR2VvbWV0cnk6IHtcblx0XHRjbGlwcGluZ0xheWVyOiBcIlN0cmF0IHRlbWF0aWMgZGUgZGVjdXBhcmVcIixcblx0XHRjbGlwcGluZ1Jhc3RlcjogXCJTZSBkZWN1cGVhesSDIHJhc3RlclwiLFxuXHRcdGNsaXBwaW5nR2VvbWV0cnk6IFwiU2UgZGVjdXBlYXrEgyBnZW9tZXRyaWFcIixcblx0XHRjdXN0b21FeHRlbnQ6IFwiTcSDc3VyxIMgcGVyc29uYWxpemF0xINcIixcblx0XHRvdXRwdXRFeHRlbnQ6IFwiRXh0aW5kZXJlIGllyJlpcmVcIixcblx0XHRjdXJyZW50RXh0ZW50OiBcIkV4dGluZGVyZWEgY3VyZW50xIMgYSBoxINyxaNpaVwiLFxuXHRcdGRyYXdMYWJlbDogXCJUcmFzYXJlXCJcblx0fSxcblx0cmZ4Q3VzdG9tRXh0ZW50OiB7XG5cdFx0dG9wOiBcIlN1c1wiLFxuXHRcdHJpZ2h0OiBcIkRyZWFwdGFcIixcblx0XHRib3R0b206IFwiSm9zXCIsXG5cdFx0bGVmdDogXCJTdMOibmdhXCJcblx0fSxcblx0cmZ4UmFzdGVyQXJyYXlFZGl0b3I6IHtcblx0XHRtb3ZlVXA6IFwiRGVwbGFzYXJlIMOubiBzdXNcIixcblx0XHRtb3ZlRG93bjogXCJEZXBsYXNhcmUgw65uIGpvc1wiLFxuXHRcdHJlbW92ZTogXCJFbGltaW5hcmVcIlxuXHR9LFxuXHRyZnhTdGF0aXN0aWNzR3JpZDoge1xuXHRcdHN0ZERldjogXCJBYmF0ZXJlIERldlwiLFxuXHRcdG1pbjogXCJNaW5cIixcblx0XHRtYXg6IFwiTWF4XCIsXG5cdFx0bWVhbjogXCJNZWRpZVwiXG5cdH0sXG5cdHJmeFdlaWdodGVkU3VtVGFibGVFZGl0b3I6IHtcblx0XHR3ZWlnaHRlZFN1bVRhYmxlOiBcIlRhYmVsIGRlIHN1bWUgcG9uZGVyYXRlXCIsXG5cdFx0aWQ6IFwiSURcIixcblx0XHRsYXllcjogXCJTdHJhdCB0ZW1hdGljXCIsXG5cdFx0ZmllbGQ6IFwiRmllbGRcIixcblx0XHR3ZWlnaHQ6IFwiR3JldXRhdGVcIixcblx0XHR2YWx1ZTogXCJWYWxvYXJlXCIsXG5cdFx0c2VsZWN0TGF5ZXI6IFwiU2VsZWN0YcibaSBzdHJhdHVsIHRlbWF0aWNcIlxuXHR9LFxuXHRyZnhXZWlnaHRlZE92ZXJsYXlUYWJsZUVkaXRvcjoge1xuXHRcdHdlaWdodGVkT3ZlcmxheVRhYmxlOiBcIlRhYmVsIHN1cHJhcHVzIHBvbmRlcmF0XCIsXG5cdFx0aWQ6IFwiSURcIixcblx0XHRsYXllcjogXCJTdHJhdCB0ZW1hdGljXCIsXG5cdFx0ZmllbGQ6IFwiRmllbGRcIixcblx0XHRpbmZsdWVuY2U6IFwiSW5mbHVlbsWjxINcIixcblx0XHRzdW1PZkluZmx1ZW5jZTogXCJTdW1hIGluZmx1ZW7Im2VpXCIsXG5cdFx0dmFsdWU6IFwiVmFsb2FyZVwiLFxuXHRcdHJlbWFwVGFibGU6IFwiUmVjYXJ0b2dyYWZpZXJlIHRhYmVsXCIsXG5cdFx0c2NhbGU6IFwiU2NhcsSDXCIsXG5cdFx0c2NhbGVzOiBcIlNjxINyaVwiLFxuXHRcdHNlbGVjdFJhc3RlcjogXCJTZWxlY3RhyJtpIHJhc3RlclwiXG5cdH0sXG5cdHJmeEZlYXR1cmVTZWxlY3Q6IHtcblx0XHRhZGRGZWF0dXJlTGF5ZXI6IFwiQ8SDdXRhcmUgcGVudHJ1IHVuIHN0cmF0IHRlbWF0aWMgZGUgb2JpZWN0ZSBzcGHFo2lhbGVcIixcblx0XHRhZGRQb2ludExheWVyOiBcIkPEg3V0YXJlIHBlbnRydSB1biBzdHJhdCB0ZW1hdGljIGRlIHB1bmN0ZSBzcGHFo2lhbGVcIlxuXHR9LFxuXHRyZnhGaWVsZFNlbGVjdDoge1xuXHRcdHZhbHVlOiBcIlZhbG9hcmVcIixcblx0XHRjb3VudDogXCJOdW3Eg3JcIlxuXHR9LFxuXHRyZnhBdHRyaWJ1dGVUYWJsZToge1xuXHRcdHRhYmxlVHlwZTogXCJUaXAgdGFiZWxcIixcblx0XHRtYW51YWw6IFwiTWFudWFsXCIsXG5cdFx0ZXh0ZXJuYWw6IFwiRXh0ZXJuXCIsXG5cdFx0bWluVmFsOiBcIlZhbG9hcmUgbWluaW3Eg1wiLFxuXHRcdG1heFZhbDogXCJWYWxvYXJlIG1heGltxINcIixcblx0XHRiYXNlQ2xhc3NOYW1lOiBcIkRlbnVtaXJlIGRlIGJhesSDIGNsYXPEg1wiLFxuXHRcdGNvbG9yU2NoZW1lOiBcIlNjaGVtxIMgZGUgY3Vsb3JpXCIsXG5cdFx0ZGVmYXVsdENsYXNzTmFtZTogXCJFdGljaGV0xINfXCIsXG5cdFx0Z2VuZXJhdGVUYWJsZTogXCJHZW5lcmHIm2kgdGFiZWxcIixcblx0XHRicm93c2VUYWJsZTogXCJOYXZpZ2HIm2kgbGEgdGFiZWxcIixcblx0XHR2YWx1ZTogXCJWYWxvYXJlXCIsXG5cdFx0Y2xhc3NuYW1lOiBcIkRlbnVtaXJlIGNsYXPEg1wiLFxuXHRcdGNvbG9yOiBcIkN1bG9hcmVcIlxuXHR9LFxuXHRyZnhGaWVsZE51bWJlclN3aXRjaGFibGU6IHtcblx0XHRudW1iZXI6IFwiTnVtZXJpY1wiLFxuXHRcdGZpZWxkOiBcIkZpZWxkXCIsXG5cdFx0c3RyaW5nOiBcIsiYaXJcIixcblx0XHRsaW5lYXJVbml0OiBcIlVuaXRhdGUgbGluaWFyxINcIlxuXHR9LFxuXHRyZnhQcm9wZXJ0eVNldDoge1xuXHRcdG5hbWU6IFwiTnVtZVwiLFxuXHRcdHZhbHVlOiBcIlZhbG9hcmVcIlxuXHR9LFxuXHRyZnhDb252ZXJzaW9uR3JpZDoge1xuXHRcdHNpemU6IFwiRGltZW5zaXVuZVwiXG5cdH0sXG5cdHJmeFRyYW5zcG9zZUJpdDoge1xuXHRcdGJpdFBhdHRlcm46IFwiTW9kZWx1bCBkZSBCacibaVwiLFxuXHRcdG91dHB1dEJpdDogXCJCaXQgZGUgaWXImWlyZVwiLFxuXHRcdGlucHV0Qml0OiBcIkJpdCBkZSBpbnRyYXJlXCJcblx0fSxcblx0cmZ4U3BhdGlhbFJlZmVyZW5jZToge1xuXHRcdHBsYWNlSG9sZGVyOiBcIlJhZmluYcibaSBkdXDEgyBDdXbDom50IENoZWllXCIsXG5cdFx0Y29vcmRpbmF0ZVN5c3RlbTogXCJTaXN0ZW0gZGUgY29vcmRvbmF0ZVwiLFxuXHRcdGdjczogXCJTaXN0ZW0gZGUgY29vcmRvbmF0ZSBnZW9ncmFmaWNlXCIsXG5cdFx0cGNzOiBcIlNpc3RlbSBkZSBjb29yZG9uYXRlIHByb2llY3RhdGVcIixcblx0XHR2Y3M6IFwiU2lzdGVtIGRlIGNvb3Jkb25hdGUgdmVydGljYWxlXCJcblx0fVxufTtcbmNvbnN0IHJmeExpY2Vuc2VJbmZvID0gXCJBY2VzdCDImWFibG9uIGRlIGZ1bmPFo2llIHJhc3RlciBwb2F0ZSBmaSB1dGlsaXphdCBwZW50cnUgYSBwcmVsdWNyYSBpbWFnaW5pbGUgZHZzLiBmb2xvc2luZCBBcmNHSVMgSW1hZ2UgU2VydmVyLlwiO1xuY29uc3QgcmFzdGVyRnVuY3Rpb25zID0ge1xuXHRyZng6IHtcblx0XHRhQ29zSE5hbWU6IFwiQUNvc0hcIixcblx0XHRhQ29zSFNuaXA6IFwiQ2FsY3VsZWF6xIMgY29zaW51c3VsIGhpcGVyYm9saWMgaW52ZXJzIGFsIGNlbHVsZWxvciBkaW50ci11biByYXN0ZXIuXCIsXG5cdFx0YUNvc0hEZXNjOiBcIkZ1bmPIm2lhIGNhbGN1bGVhesSDIGNvc2ludXN1bCBoaXBlcmJvbGljIGludmVycyBhbCBwaXhlbGlsb3IgZGludHItdW4gcmFzdGVyLlwiLFxuXHRcdGFDb3NOYW1lOiBcIkFDb3NcIixcblx0XHRhQ29zU25pcDogXCJDYWxjdWxlYXrEgyBjb3NpbnVzdWwgaW52ZXJzIGFsIHBpeGVsaWxvciBkaW50ci11biByYXN0ZXIuXCIsXG5cdFx0YUNvc0Rlc2M6IFwiQWNlYXN0xIMgZnVuY8ibaWUgcmFzdGVyIGNhbGN1bGVhesSDIGNvc2ludXN1bCBpbnZlcnMgYWwgY2VsdWxlbG9yIGRpbnRyLXVuIHJhc3Rlci4gw45uIG1hdGVtYXRpY8SDLCB0b2F0ZSBmdW5jyJtpaWxlIHRyaWdvbm9tZXRyaWNlIGF1IHVuIGludGVydmFsIGRlZmluaXQgZGUgdmFsb3JpIGRlIGludHJhcmUgdmFsYWJpbGUsIGRlbnVtaXQgZG9tZW5pdS4gVmFsb3JpbGUgZGUgaWXImWlyZSBkaW4gZmllY2FyZSBmdW5jyJtpZSBhdSwgZGUgYXNlbWVuZWEsIHVuIGludGVydmFsIGRlZmluaXQuIFBlbnRydSBhY2VzdCBpbnN0cnVtZW50LCBkb21lbml1bCBlc3RlIFstMSwgMV0sIGlhciBpbnRlcnZhbHVsIGVzdGUgWzAsIHBpXS5cIixcblx0XHRhU2luSE5hbWU6IFwiQVNpbkhcIixcblx0XHRhU2luSFNuaXA6IFwiQ2FsY3VsZWF6xIMgc2ludXN1bCBoaXBlcmJvbGljIGludmVycyBhbCBjZWx1bGVsb3IgZGludHItdW4gcmFzdGVyLlwiLFxuXHRcdGFTaW5IRGVzYzogXCJGdW5jyJtpYSBjYWxjdWxlYXrEgyBzaW51c3VsIGhpcGVyYm9saWMgaW52ZXJzIGFsIHBpeGVsaWxvciBkaW50ci11biByYXN0ZXIuXCIsXG5cdFx0YVNpbk5hbWU6IFwiQVNpblwiLFxuXHRcdGFTaW5TbmlwOiBcIkNhbGN1bGVhesSDIHNpbnVzdWwgaW52ZXJzIGFsIGNlbHVsZWxvciBkaW50ci11biByYXN0ZXIuXCIsXG5cdFx0YVNpbkRlc2M6IFwiRnVuY8ibaWEgY2FsY3VsZWF6xIMgc2ludXN1bCBpbnZlcnMgYWwgcGl4ZWxpbG9yIGRpbnRyLXVuIHJhc3Rlci5cIixcblx0XHRhVGFuMk5hbWU6IFwiQVRhbjJcIixcblx0XHRhVGFuMlNuaXA6IFwiQ2FsY3VsZWF6xIMgdGFuZ2VudGEgaW52ZXJzxIMgKHBlIGJhemEgeCx5KSBhIGNlbHVsZWxvciBkaW50ci11biByYXN0ZXIuXCIsXG5cdFx0YVRhbjJEZXNjOiBcIkZ1bmPIm2lhIGNhbGN1bGVhesSDIHRhbmdlbnRhIGludmVyc8SDIChwZSBiYXphIHgseSkgYSBwaXhlbGlsb3IgZGludHItdW4gcmFzdGVyLlwiLFxuXHRcdGFUYW5ITmFtZTogXCJBVGFuSFwiLFxuXHRcdGFUYW5IU25pcDogXCJDYWxjdWxlYXrEgyB0YW5nZW50YSBoaXBlcmJvbGljxIMgaW52ZXJzxIMgYSBjZWx1bGVsb3IgZGludHItdW4gcmFzdGVyLlwiLFxuXHRcdGFUYW5IRGVzYzogXCJGdW5jyJtpYSBjYWxjdWxlYXrEgyB0YW5nZW50YSBoaXBlcmJvbGljxIMgaW52ZXJzxIMgYSBwaXhlbGlsb3IgZGludHItdW4gcmFzdGVyLlwiLFxuXHRcdGFUYW5OYW1lOiBcIkFUYW5cIixcblx0XHRhVGFuU25pcDogXCJDYWxjdWxlYXrEgyB0YW5nZW50YSBpbnZlcnPEgyBhIGNlbHVsZWxvciBkaW50ci11biByYXN0ZXIuXCIsXG5cdFx0YVRhbkRlc2M6IFwiRnVuY8ibaWEgY2FsY3VsZWF6xIMgdGFuZ2VudGEgaW52ZXJzxIMgYSBwaXhlbGlsb3IgZGludHItdW4gcmFzdGVyLlwiLFxuXHRcdGFic05hbWU6IFwiQWJzXCIsXG5cdFx0YWJzU25pcDogXCJDYWxjdWxlYXrEgyB2YWxvYXJlYSBhYnNvbHV0xIMgYSBjZWx1bGVsb3IgZGludHItdW4gcmFzdGVyLlwiLFxuXHRcdGFic0Rlc2M6IFwiRnVuY8ibaWEgQWJzIGNhbGN1bGVhesSDIHZhbG9hcmVhIGFic29sdXTEgyBhIHBpeGVsaWxvciBkaW50ci11biByYXN0ZXIuXCIsXG5cdFx0cmVmbGVjdGFuY2VOYW1lOiBcIlJlZmxlY3RhbsibxIMgYXBhcmVudMSDXCIsXG5cdFx0cmVmbGVjdGFuY2VTbmlwOiBcIlRyYW5zZm9ybcSDIGltYWdpbmlsZSBicnV0ZSDDrm4gdmFsb3JpIFRvcCBvZiBBdG1vc3BoZXJlIHByaW4gbHVhcmVhIMOubiBjb25zaWRlcmFyZSBhIGNhcmFjdGVyaXN0aWNpbG9yIHNlbnpvcnVsdWksIGEgcG96acibaWVpIHNvYXJlbHVpIMiZaSB0aW1wdWx1aSBkZSBhY2hpemnIm2llLlwiLFxuXHRcdHJlZmxlY3RhbmNlRGVzYzogXCJBY2Vhc3TEgyBmdW5jyJtpZSBhanVzdGVhesSDIG51bcSDcnVsIGRpZ2l0YWwgKE5EKSBhbCBsdW1pbm96aXTEg8ibaWkgaW1hZ2luaWkgcGVudHJ1IHVuaWkgZGludHJlIHNlbnpvcmlpIGRlIHNhdGVsaXQuIEFqdXN0xINyaWxlIHNlIGJhemVhesSDIHBlIGVsZXZhyJtpYSBzb2FyZWx1aSwgZGF0YSBhY2hpemnIm2llaSDImWkgcHJvcHJpZXTEg8ibaWxlIHNlbnpvcnVsdWkgcGVudHJ1IGEgc2V0YSBhbXBsaWZpY2FyZWEgyJlpIMOubmNsaW5hcmVhIHBlbnRydSBmaWVjYXJlIGJhbmTEgy4gQWNlYXN0xIMgZnVuY8ibaWUgZXN0ZSBmb2xvc2l0xIMgcGVudHJ1IGEgYWp1c3RhIHJlZmxlY3RhbsibYSBzYXUgbHVtaW5veml0YXRlYSwgdmFsb3JpIGFsZSB1bm9yIGltYWdpbmkgZGUgc2F0ZWxpdCBwZSBiYXphIGlsdW1pbsSDcmlpIHNjZW5laSDImWkgc2V0xINyaWkgYW1wbGlmaWPEg3JpaSBzZW56b3J1bHVpLiBJbWFnaW5pbGUgc3VudCBhanVzdGF0ZSBjb25mb3JtIHVuZWkgY29uZGnIm2lpIGRlIGlsdW1pbmFyZSBjb211bmUgdGVvcmV0aWPEgywgcHJpbiB1cm1hcmUgdHJlYnVpZSBzxIMgZXhpc3RlIG1haSBwdcibaW7EgyB2YXJpYcibaWUgw65udHJlIHNjZW5lbGUgZGluIGRhdGUgZGlmZXJpdGUgyJlpIGRlIGxhIHNlbnpvcmkgZGlmZXJpyJtpLiBBY2VzdCBsdWNydSBwb2F0ZSBmaSB1dGlsIHBlbnRydSBjbGFzaWZpY2FyZWEgaW1hZ2luaWksIGVjaGlsaWJyYXJlYSBjdWxvcmlpIMiZaSBtb3phaWNhcmUuIEFjZWFzdMSDIGZ1bmPIm2llIHBvYXRlIGZpIHV0aWxpemF0xIMgZG9hciBjdSBpbWFnaW5pIHNwZWNpZmljZS4gU2Vuem9yaWkgYXBsaWNhYmlsaSBzdW50IExhbmRzYXQgTVNTLCBMYW5kc2F0IFRNLCBMYW5kc2F0IEVUTSssIExhbmRzYXQgOCwgSUtPTk9TLCBRdWlja0JpcmQsIEdlb0V5ZS0xLCBSYXBpZEV5ZSwgRE1DaWksIFdvcmxkVmlldy0xLCBXb3JsZFZpZXctMiwgU1BPVCA2IMiZaSBQbGVpYWRlcy48ZGl2Pjxici8+RnVuY8ibaWlsZSBlZmVjdHVlYXrEgyBkb3XEgyBjb3JlY8ibaWkuIFByaW1hIHNlIGJhemVhesSDIHBlIHNldMSDcmlsZSBhbXBsaWZpY8SDcmlpLiBWYWxvcmlsZSBvcmlnaW5hbGUgZGUgbHVtaW5veml0YXRlIHN1bnQgcmUtY3JlYXRlIGRpbiB2YWxvcmlsZSBpbWFnaW5paSBwcmluIGludmVyc2FyZWEgZWN1YcibaWlsb3IgZGUgYW1wbGlmaWNhcmUuIEEgZG91YSBjb3JlY8ibaWUgZXN0ZSBhZmVyZW50xIMgZGlmZXJlbsibZWkgdW5naGl1bHVpIMiZaSBsdW1pbm96aXTEg8ibaWkgc29hcmVsdWkuIFZhbG9yaWxlIGluacibaWFsZSBhbGUgbHVtaW5veml0xIPIm2lpIHN1bnQgYWp1c3RhdGUgdW5laSBzdMSDcmkgY29tdW5lIGEgbHVtaW5veml0xIPIm2lpIHByaW4gc2NlbmUgZGUgbm9ybWFsaXphcmUgY2FwdHVyYXRlIMOubiBjb25kacibaWkgZGUgaWx1bWluYXJlIHZhcmlhYmlsZS4gw45uIGdlbmVyYWwsIMOubiB0aW1wIGNlIHRpcHVsIGRhdGVsb3IgZGUgaW1hZ2luZSByZXp1bHRhdGUgZXN0ZSBhY2VsYciZaSBjdSB0aXB1bCBkYXRlbG9yIGRlIGludHJhcmUsIHZhbG9yaWxlIGRlIGllyJlpcmUgc3VudCBtYWkgbWljaSBkZWPDonQgdmFsb3JpbGUgZGUgaW50cmFyZSDImWkgc3VudCBkZWN1cGF0ZSBjb25mb3JtIGludGVydmFsdWx1aSBkZSBkYXRlIHZhbGFiaWwuPC9kaXY+XCIsXG5cdFx0YXJnU3RhdGlzdGljc05hbWU6IFwiQXJnU3RhdGlzdGljc1wiLFxuXHRcdGFyZ1N0YXRpc3RpY3NTbmlwOiBcIkNhbGN1bGVhesSDIHN0YXRpc3RpY2lsZSBhcmcgaW5jbHVzaXYgQXJnIE1heCwgQXJnIE1pbiwgQXJnIE1lZGlhbiDImWkgRHVyYXTEgy5cIixcblx0XHRhcmdTdGF0aXN0aWNzRGVzYzogXCJGdW5jyJtpYSBjYWxjdWxlYXrEgyBzdGF0aXN0aWNpbGUgYXJnLiBFeGlzdMSDIHBhdHJ1IG1ldG9kZSDDrm4gZnVuY8ibaWEgQXJnU3RhdGlzdGljczogQXJnTWF4LCBBcmdNaW4sIEFyZ01lZGlhbiDImWkgRHVyYXTEgy5cIixcblx0XHRhcml0aG1ldGljTmFtZTogXCJBcml0bWV0aWNcIixcblx0XHRhcml0aG1ldGljU25pcDogXCJFZmVjdHVlYXrEgyBvIG9wZXJhyJtpZSBhcml0bWV0aWPEgyDDrm50cmUgZG91xIMgcmFzdGVyZSBzYXUgdW4gcmFzdGVyIMiZaSB1biBzY2FsYXIuXCIsXG5cdFx0YXJpdGhtZXRpY0Rlc2M6IFwiRnVuY8ibaWEgYXJpdG1ldGljxIMgZWZlY3R1ZWF6xIMgbyBvcGVyYcibaWUgYXJpdG1ldGljxIMgw65udHJlIGRvdcSDIHJhc3RlcmUgc2F1IHVuIHJhc3RlciDImWkgdW4gc2NhbGFyIMiZaSBpbnZlcnMuXCIsXG5cdFx0YXNwZWN0U2xvcGVOYW1lOiBcIkFzcGVjdC1QYW50xINcIixcblx0XHRhc3BlY3RTbG9wZVNuaXA6IFwiQ3JlZWF6xIMgdW4gcmFzdGVyIGNhcmUgcHJlemludMSDIHNpbXVsdGFuIGFzcGVjdHVsIChkaXJlY8ibaWEpIMiZaSBwYW50YSAow65uY2xpbmFyZWEpIHVuZWkgc3VwcmFmZcibZSBjb250aW51ZSwgY29uZm9ybSByZXByZXplbnTEg3JpaSBkaW50ci11biBtb2RlbCBkaWdpdGFsIGRlIGVsZXZhcmUuXCIsXG5cdFx0YXNwZWN0U2xvcGVEZXNjOiBcIkZ1bmPIm2lhIFBhbnTEgyBkZSBBc3BlY3QgY3JlZWF6xIMgdW4gc3RyYXQgcmFzdGVyIGNhcmUgYWZpyJllYXrEgyBhc3BlY3R1bCDImWkgcGFudGEgdW5laSBzdXByYWZlyJtlLiBBc3BlY3R1bCBpZGVudGlmaWPEgyBkaXJlY8ibaWEgw65uIHBhbnTEgyBhIHJhdGVpIG1heGltZSBkZSBzY2hpbWJhcmUgYSB2YWxvcmlpIGRpbiBmaWVjYXJlIHBpeGVsIGPEg3RyZSB2ZWNpbmlpIHPEg2kuIEFzcGVjdHVsIHBvYXRlIGZpIGNvbnNpZGVyYXQgZGlyZWPIm2lhIHBhbnRlaS4gVmFsb3JpbGUgcmFzdGVydWx1aSBkZSBpZciZaXJlIHZvciBmaSBkaXJlY8ibaWEgZGUgYnVzb2zEgyBhIGFzcGVjdHVsdWksIHJlcHJlemVudGF0xIMgZGUgbyBudWFuyJvEgyAoY3Vsb2FyZSkuIFBhbnRhIHJlcHJlemludMSDIHJhdGEgZGUgbW9kaWZpY2FyZSBhIGVsZXZhyJtpZWkgcGVudHJ1IGZpZWNhcmUgcGl4ZWwgYWwgbW9kZWx1bHVpIGRpZ2l0YWwgZGUgZWxldmHIm2llIChERU0pLiBQYW50YSByZXByZXppbnTEgyDDrm5jbGluYXJlYSBzdXByYWZlyJtlaSDImWkgZXN0ZSBzaW1ib2xpemF0xIMgcHJpbiB0cmVpIGNsYXNlIHByZXplbnRhdGUgY3UgYWp1dG9ydWwgc2F0dXJhyJtpZWkgY3Vsb3JpaSAobHVtaW5veml0xIPIm2lpKS48ZGl2Pjxici8+VmFsb3JpbGUgcGl4ZWxpbG9yIGRpbiByYXN0ZXJ1bCBkZSBpZciZaXJlIGFzcGVjdC3Drm5jbGluYXJlIHJlZmxlY3TEgyBvIGNvbWJpbmHIm2llIGEgYXNwZWN0dWx1aSDImWkgcGFudGVpLiBQaXhlbGlpIGN1IHZhbG9yaSBzdWIgMjAgc3VudCBjb25zaWRlcmHIm2kgcGxhyJtpIMiZaSBzdW50IHByZXplbnRhyJtpIGN1IGdyaS4gVmFsb3JpbGUgYXNwZWN0LXBhbnTEgyBkZSAyMSDImWkgbWFpIG11bHQgdm9yIGZpIHByZXplbnRhdGUgY3Ugc2F0dXJhyJtpaSBkaWZlcml0ZSwgZHVwxIMgY3VtIHVybWVhesSDOiAyMSBww6JuxIMgbGEgMzAg4oCUU2F0dXJhyJtpZSByZWR1c8SDIGEgcGFudGVpLCAzMSBww6JuxIMgbGEgNDDigJRTYXR1cmHIm2llIG1vZGVyYXTEgyBhIHBhbnRlaSwgNDEgyJlpIGFib3Zl4oCUU2F0dXJhyJtpZSByaWRpY2F0xIMgYSBwYW50ZWk8L2Rpdj5cIixcblx0XHRhc3BlY3ROYW1lOiBcIkFzcGVjdFwiLFxuXHRcdGFzcGVjdFNuaXA6IFwiUHJlemludMSDIGRpcmVjyJtpYSDDrm4gY2FyZSBlc3RlIG9yaWVudGF0IHVuIHBpeGVsLCB1bmRlIDAgZXN0ZSBvcmllbnRhdCBjxIN0cmUgbm9yZCDImWkgdW5naGl1cmlsZSBjcmVzYyDDrm4gc2VucyBvcmFyIHDDom7EgyBsYSAzNjAuXCIsXG5cdFx0YXNwZWN0RGVzYzogXCJGdW5jyJtpYSBkZSBhc3BlY3QgaWRlbnRpZmljxIMgZGlyZWPIm2lhIMOubiBwYW50xIMgYSByYXRlaSBtYXhpbWUgZGUgc2NoaW1iYXJlIGEgdmFsb3JpaSBkaW4gZmllY2FyZSBjZWx1bMSDIGPEg3RyZSB2ZWNpbmlpIHPEg2kuIEFzcGVjdHVsIHBvYXRlIGZpIGNvbnNpZGVyYXQgZGlyZWPIm2lhIHBhbnRlaS4gVmFsb3JpbGUgcmFzdGVydWx1aSBkZSBpZciZaXJlIHZvciBmaSBkaXJlY8ibaWEgYXNwZWN0dWx1aS48ZGl2Pjxici8+SW50cmFyZWEgcGVudHJ1IGFjZWFzdMSDIGZ1bmPIm2llIGVzdGUgUmFzdGVydWwgZGUgSW50cmFyZS4gRnVuY8ibaWEgZGUgYXNwZWN0IGVzdGUgYWRlc2VhIGFwbGljYXTEgyB1bnVpIG1vZGVsIGRlIGVsZXZhcmUgZGlnaXRhbMSDIChERU0pLiBJbXBsaWNpdCwgYXNwZWN0dWwgYXBhcmUgY2EgbyBpbWFnaW5lIHBlIHNjYWzEgyBkZSBncmkuIFB1dGXIm2kgYWTEg3VnYSBmdW5jyJtpYSBDb2xvcm1hcCBwZW50cnUgYSBzcGVjaWZpY2EgbyBhbnVtaXTEgyBzY2hlbcSDIGRlIGN1bG9yaSBzYXUgYSBwZXJtaXRlIHBlcnNvYW5laSBjYXJlIHZpenVhbGl6ZWF6xIMgbW96YWljdWwgc8SDIG1vZGlmaWNlIHNpbWJvbG9naWEgY3UgcHJvcHJpYSBzY2hlbcSDIGRlIGN1bG9yaS48L2Rpdj5cIixcblx0XHR0YWJsZU5hbWU6IFwiVGFiZWwgZGUgYXRyaWJ1dGVcIixcblx0XHR0YWJsZVNuaXA6IFwiVXRpbGl6ZWF6xIMgdW4gdGFiZWwgcGVudHJ1IGEgZGVudW1pIMiZaSBzaW1ib2xpemEgdmFsb3JpbGUgZGludHItdW4gc2V0IGRlIGRhdGUuIENvbG9hbmVsZSBwZW50cnUgdGFiZWwgc3VudCBkZWxpbWl0YXRlIGN1IHZpcmd1bMSDOiBQaXhlbFZhbHVlLCBBdHRyaWJ1dGVOYW1lLCBSZWRWYWx1ZSwgR3JlZW5WYWx1ZSwgQmx1ZVZhbHVlLlwiLFxuXHRcdHRhYmxlRGVzYzogXCJGdW5jyJtpYSBUYWJlbCBkZSBhdHJpYnV0ZSB2xIMgcGVybWl0ZSBzxIMgZGVmaW5pyJtpIHVuIHRhYmVsIGRlIGF0cmlidXRlIHBlbnRydSBhIHNpbWJvbGl6YSB1biBzZXQgZGUgZGF0ZSBtb3phaWMgY3UgbyBzaW5ndXLEgyBiYW5kxIMgc2F1IHVuIHNldCBkZSBkYXRlIHJhc3Rlci4gPGRpdj48YnIvPkFjZXN0IGx1Y3J1IGVzdGUgdXRpbCBhdHVuY2kgY8OibmQgZG9yacibaSBzxIMgcHJlemVudGHIm2kgaW1hZ2luaSBjYXJlIGF1IHN1ZmVyaXQgbyBjbGFzaWZpY2FyZSBjb25mb3JtIHV0aWxpesSDcmlpIHRlcmVudWx1aSwgY3VtIGFyIGZpIHRlcmVuIMOubXDEg2R1cml0LCBtbGHImXRpbmksIHRlcmVuIGFncmljb2wgyJlpIHVyYmFuLiDDjm4gcGx1cywgZGFjxIMgdGFiZWx1bCBkdnMuIGNvbsibaW5lIGPDom1wdXJpIGRlbnVtaXRlIHJvyJl1LCB2ZXJkZSDImWkgYWxiYXN0cnUsIHZhbG9yaWxlIGRpbiBhY2VsZSBjw6JtcHVyaSB2b3IgZmkgdXRpbGl6YXRlIGNhIG8gaGFydMSDIGRlIGN1bG9yaSBsYSByZWRhcmVhIGltYWdpbmlpLjwvZGl2PlwiLFxuXHRcdGJhbmRBcml0aG1ldGljTmFtZTogXCJBcml0bWV0aWPEgyBiYW5kxINcIixcblx0XHRiYW5kQXJpdGhtZXRpY1NuaXA6IFwiQ2FsY3VsZWF6xIMgaW5kaWNpaSBmb2xvc2luZCBmb3JtdWxlIHByZXN0YWJpbGl0ZSBzYXUgbyBleHByZXNpZSBkZWZpbml0xIMgZGUgdXRpbGl6YXRvci5cIixcblx0XHRiYW5kQXJpdGhtZXRpY0Rlc2M6IFwiRnVuY8ibaWEgZGUgYXJpdG1ldGljxIMgYmFuZMSDIGVmZWN0dWVhesSDIG8gb3BlcmHIm2llIGFyaXRtZXRpY8SDIHBlIGJlbnppbGUgdW51aSBzZXQgZGUgZGF0ZSByYXN0ZXIuIFB1dGXIm2kgYWxlZ2UgYWxnb3JpdG1paSBwcmVzdGFiaWxpyJtpIHNhdSBwdXRlyJtpIGludHJvZHVjZSBwcm9wcmlhIGZvcm11bMSDIGN1IG8gc2luZ3VyxIMgbGluaWUuIE9wZXJhdG9yaWkgc3Vwb3J0YcibaSBzdW50IC0sKywvLCosIMiZaSB1bmFyIC0uXCIsXG5cdFx0dGhyZXNob2xkTmFtZTogXCJMaW1pdGFyZSBiaW5hcsSDXCIsXG5cdFx0dGhyZXNob2xkU25pcDogXCJPcmdhbml6ZWF6xIMgZGF0ZWxlIGNvbnRpbnVlIMOubiBwcmltIHBsYW4gyJlpIGZ1bmRhbCBwcmluIHJlZHVjZXJlYSBsYSBtaW5pbXVtIGEgY292YXJpYW7Im2VpIGRpbnRyZSBjZWxlIGRvdcSDIGNsYXNlLlwiLFxuXHRcdHRocmVzaG9sZERlc2M6IFwiQXR1bmNpIGPDom5kIHVuIHNldCBkZSBkYXRlIHJhc3RlciBhcmUgbyBkaXN0cmlidcibaWUgYmltb2RhbMSDLCBhY2Vhc3TEgyBmdW5jyJtpZSBjcmVlYXrEgyB1biBub3UgcmFzdGVyIGNhcmUgw65tcGFydGUgZGF0ZWxlIMOubiBkb3XEgyBjbGFzZSBkaXN0aW5jdGUuIENyZWVhesSDIG8gY2xhc8SDIGRlIHZhbG9hcmUgaW5mZXJpb2FyxIMgcHJlemVudGF0xIMgY3UgcGl4ZWxpIG5lZ3JpIMiZaSBvIGNsYXPEgyBkZSB2YWxvYXJlIHJpZGljYXTEgyBwcmV6ZW50YXTEgyBjdSBwaXhlbGkgYWxiaS5cIixcblx0XHRiaXR3aXNlQW5kTmFtZTogXCJCaXR3aXNlIEFuZFwiLFxuXHRcdGJpdHdpc2VBbmRTbmlwOiBcIkVmZWN0dWVhesSDIG8gb3BlcmHIm2llIEJpdHdpc2UgQW5kIGFzdXByYSB2YWxvcmlsb3IgYmluYXJlIGEgZG91xIMgcmFzdGVyZSBkZSBpbnRyYXJlLlwiLFxuXHRcdGJpdHdpc2VBbmREZXNjOiBcIkJpdHdpc2UgQW5kIGVmZWN0dWVhesSDIG8gb3BlcmHIm2llIEJpdHdpc2UgQW5kIGFzdXByYSB2YWxvcmlsb3IgYmluYXJlIGEgZG91xIMgcmFzdGVyZSBkZSBpbnRyYXJlXCIsXG5cdFx0Yml0d2lzZUxlZnRTaGlmdE5hbWU6IFwiQml0d2lzZSBMZWZ0IFNoaWZ0XCIsXG5cdFx0Yml0d2lzZUxlZnRTaGlmdFNuaXA6IFwiRWZlY3R1ZWF6xIMgbyBvcGVyYcibaWUgQml0d2lzZSBMZWZ0IGFzdXByYSB2YWxvcmlsb3IgYmluYXJlIGEgZG91xIMgcmFzdGVyZSBkZSBpbnRyYXJlLlwiLFxuXHRcdGJpdHdpc2VMZWZ0U2hpZnREZXNjOiBcIkJpdHdpc2UgTGVmdCBTaGlmdCBlZmVjdHVlYXrEgyBvIG9wZXJhyJtpZSBCaXR3aXNlIExlZnQgU2hpZnQgYXN1cHJhIHZhbG9yaWxvciBiaW5hcmUgYSBkb3XEgyByYXN0ZXJlIGRlIGludHJhcmVcIixcblx0XHRiaXR3aXNlTm90TmFtZTogXCJCaXR3aXNlIE5vdFwiLFxuXHRcdGJpdHdpc2VOb3RTbmlwOiBcIkVmZWN0dWVhesSDIG8gb3BlcmHIm2llIEJpdHdpc2UgTm90IChjb21wbGVtZW50KSBhc3VwcmEgdmFsb3JpbG9yIGJpbmFyZSBhIGRvdcSDIHJhc3RlcmUgZGUgaW50cmFyZS5cIixcblx0XHRiaXR3aXNlTm90RGVzYzogXCJGdW5jyJtpYSBlZmVjdHVlYXrEgyBvIG9wZXJhyJtpZSBCaXR3aXNlIE5vdCAoY29tcGxlbWVudCkgYXN1cHJhIHZhbG9yaWxvciBiaW5hcmUgYWxlIHVudWkgcmFzdGVyIGRlIGludHJhcmUuXCIsXG5cdFx0Yml0d2lzZU9yTmFtZTogXCJCaXR3aXNlIE9yXCIsXG5cdFx0Yml0d2lzZU9yU25pcDogXCJFZmVjdHVlYXrEgyBvIG9wZXJhyJtpZSBCaXR3aXNlIE9yIGFzdXByYSB2YWxvcmlsb3IgYmluYXJlIGEgZG91xIMgcmFzdGVyZSBkZSBpbnRyYXJlLlwiLFxuXHRcdGJpdHdpc2VPckRlc2M6IFwiRnVuY8ibaWEgZWZlY3R1ZWF6xIMgbyBvcGVyYcibaWUgQml0d2lzZSBPciBhc3VwcmEgdmFsb3JpbG9yIGJpbmFyZSBhIGRvdcSDIHJhc3RlcmUgZGUgaW50cmFyZS4gXCIsXG5cdFx0Yml0d2lzZVJpZ2h0U2hpZnROYW1lOiBcIkJpdHdpc2UgUmlnaHQgU2hpZnRcIixcblx0XHRiaXR3aXNlUmlnaHRTaGlmdFNuaXA6IFwiRWZlY3R1ZWF6xIMgbyBvcGVyYcibaWUgQml0d2lzZSBSaWdodCBTaGlmdCBhc3VwcmEgdmFsb3JpbG9yIGJpbmFyZSBhIGRvdcSDIHJhc3RlcmUgZGUgaW50cmFyZS5cIixcblx0XHRiaXR3aXNlUmlnaHRTaGlmdERlc2M6IFwiRnVuyJtjaWEgZWZlY3R1ZWF6xIMgbyBvcGVyYcibaWUgQml0d2lzZSBSaWdodCBTaGlmdCBhc3VwcmEgdmFsb3JpbG9yIGJpbmFyZSBhIGRvdcSDIHJhc3RlcmUgZGUgaW50cmFyZS5cIixcblx0XHRiaXR3aXNlWG9yTmFtZTogXCJCaXR3aXNlIFhvclwiLFxuXHRcdGJpdHdpc2VYb3JTbmlwOiBcIkVmZWN0dWVhesSDIG8gb3BlcmHIm2llIEJpdHdpc2UgZVhjbHVzaXZlIE9yIGFzdXByYSB2YWxvcmlsb3IgYmluYXJlIGEgZG91xIMgcmFzdGVyZSBkZSBpbnRyYXJlLlwiLFxuXHRcdGJpdHdpc2VYb3JEZXNjOiBcIkZ1bsibY2lhIGVmZWN0dWVhesSDIG8gb3BlcmHIm2llIEJpdHdpc2UgZVhjbHVzaXZlIElyIGFzdXByYSB2YWxvcmlsb3IgYmluYXJlIGEgZG91xIMgcmFzdGVyZSBkZSBpbnRyYXJlXCIsXG5cdFx0Ym9vbGVhbkFuZE5hbWU6IFwiQm9vbGVhbiBBbmRcIixcblx0XHRib29sZWFuQW5kU25pcDogXCJFZmVjdHVlYXrEgyBvIG9wZXJhyJtpZSBCb29sZWFuIEFuZCBhc3VwcmEgdmFsb3JpbG9yIGNlbHVsZWkgYSBkb3XEgyByYXN0ZXJlIGRlIGludHJhcmUuIERhY8SDIGFtYmVsZSB2YWxvcmkgZGUgaW50cmFyZSBzdW50IHJlYWxlIChub24temVybyksIHZhbG9hcmVhIGRlIGllyJlpcmUgZXN0ZSAxLiBEYWPEgyB1bmEgc2F1IGFtYmVsZSBpbnRyxINyaSBzdW50IGZhbHNlICh6ZXJvKSwgaWXImWlyZWEgZXN0ZSAwLlwiLFxuXHRcdGJvb2xlYW5BbmREZXNjOiBcIkZ1bsibY2lhIGVmZWN0dWVhesSDIG8gb3BlcmHIm2llIEJvb2xlYW4gQW5kIGFzdXByYSB2YWxvcmlsb3IgcGl4ZWwgYSBkb3XEgyBpbnRyxINyaS4gRGFjxIMgYW1iZWxlIHZhbG9yaSBkZSBpbnRyYXJlIHN1bnQgcmVhbGUgKG5vbnplcm8pLCB2YWxvYXJlYSBkZSBpZciZaXJlIGVzdGUgMS4gRGFjxIMgdW5hIHNhdSBhbWJlbGUgdmFsb3JpIGRlIGludHJhcmUgc3VudCBmYWxzZSAoemVybyksIHZhbG9hcmVhIGRlIGllyJlpcmUgZXN0ZSAwLiBcIixcblx0XHRib29sZWFuTm90TmFtZTogXCJCb29sZWFuIE5vdFwiLFxuXHRcdGJvb2xlYW5Ob3RTbmlwOiBcIkVmZWN0dWVhesSDIG8gb3BlcmHIm2llIEJvb2xlYW4gQW5kIChjb21wbGVtZW50KSBhc3VwcmEgdmFsb3JpbG9yIGNlbHVsZWkgcmFzdGVydWx1aSBkZSBpbnRyYXJlLiBEYWPEgyB2YWxvcmlsZSBkZSBpbnRyYXJlIHN1bnQgcmVhbGUgKG5vbi16ZXJvKSwgdmFsb2FyZWEgZGUgaWXImWlyZSBlc3RlIDAuIERhY8SDIHZhbG9yaWxlIGRlIGludHJhcmUgc3VudCBmYWxzZSAoemVybyksIGllyJlpcmVhIGVzdGUgMS5cIixcblx0XHRib29sZWFuTm90RGVzYzogXCJGdW5jyJtpYSBlZmVjdHVlYXrEgyBvIG9wZXJhyJtpZSBCb29sZWFuIE5vdCAoY29tcGxlbWVudCkgYXN1cHJhIHZhbG9yaWxvciBwaXhlbCBhbGUgcmFzdGVydWx1aSBkZSBpbnRyYXJlLiBEYWPEgyB2YWxvcmlsZSBkZSBpbnRyYXJlIHN1bnQgcmVhbGUgKG5vbnplcm8pLCB2YWxvYXJlYSBkZSBpZciZaXJlIGVzdGUgMC4gRGFjxIMgdmFsb3JpbGUgZGUgaW50cmFyZSBzdW50IGZhbHNlICh6ZXJvKSwgdmFsb2FyZWEgZGUgaWXImWlyZSBlc3RlIDEuXCIsXG5cdFx0Ym9vbGVhbk9yTmFtZTogXCJCb29sZWFuIE9yXCIsXG5cdFx0Ym9vbGVhbk9yU25pcDogXCJFZmVjdHVlYXrEgyBvIG9wZXJhyJtpZSBCb29sZWFuIE9yIGFzdXByYSB2YWxvcmlsb3IgY2VsdWxlaSBjZWxvciBkb3XEgyByYXN0ZXJlIGRlIGludHJhcmUuIERhY8SDIHVudWwgc2F1IGFtYmVsZSB2YWxvcmkgZGUgaW50cmFyZSBzdW50IHJlYWxlIChub24temVybyksIHZhbG9hcmVhIGRlIGllyJlpcmUgZXN0ZSAxLiBEYWPEgyBhbWJlbGUgdmFsb3JpIGRlIGludHJhcmUgc3VudCBmYWxzZSAoemVybyksIGllyJlpcmVhIGVzdGUgMC5cIixcblx0XHRib29sZWFuT3JEZXNjOiBcIkZ1bmPIm2lhIGVmZWN0dWVhesSDIG8gb3BlcmHIm2llIEJvb2xlYW4gT3IgYXN1cHJhIHZhbG9yaWxvciBiaW5hcmUgYSBkb3XEgyByYXN0ZXJlIGRlIGludHJhcmUuIERhY8SDIHVuYSBzYXUgYW1iZWxlIHZhbG9yaSBkZSBpbnRyYXJlIHN1bnQgcmVhbGUgKG5vbnplcm8pLCB2YWxvYXJlYSBkZSBpZciZaXJlIGVzdGUgMS4gRGFjxIMgYW1iZWxlIHZhbG9yaSBkZSBpbnRyYXJlIHN1bnQgZmFsc2UgKHplcm8pLCB2YWxvYXJlYSBkZSBpZciZaXJlIGVzdGUgMC5cIixcblx0XHRib29sZWFuWG9yTmFtZTogXCJCb29sZWFuIFhvclwiLFxuXHRcdGJvb2xlYW5Yb3JTbmlwOiBcIkVmZWN0dWVhesSDIG8gb3BlcmHIm2llIEJvb2xlYW4gZVhjbHVzaXZlIE9yIGFzdXByYSB2YWxvcmlsb3IgY2VsdWxlaSBhIGRvdcSDIHJhc3RlcmUgZGUgaW50cmFyZS4gRGFjxIMgbyB2YWxvYXJlIGRlIGludHJhcmUgZXN0ZSByZWFsxIMgKG5vbi16ZXJvKSDImWkgY2VhbGFsdMSDIGZhbHPEgyAoemVybyksIHZhbG9hcmVhIGRlIGllyJlpcmUgZXN0ZSAxLiBEYWPEgyBhbWJlbGUgdmFsb3JpIGRlIGludHJhcmUgc3VudCByZWFsZSBzYXUgYW1iZWxlIHN1bnQgZmFsc2UsIGllyJlpcmVhIGVzdGUgMC5cIixcblx0XHRib29sZWFuWG9yRGVzYzogXCJGdW5jyJtpYSBlZmVjdHVlYXrEgyBvIG9wZXJhyJtpZSBCb29sZWFuIGVYY2x1c2l2ZSBPciBhc3VwcmEgdmFsb3JpbG9yIGNlbHVsZWkgYSBkb3XEgyByYXN0ZXJlIGRlIGludHJhcmUuIERhY8SDIG8gdmFsb2FyZSBkZSBpbnRyYXJlIGVzdGUgcmVhbMSDIChub256ZXJvKSDImWkgY2VhbGFsdMSDIHZhbG9hcmUgZXN0ZSBmYWxzxIMgKHplcm8pLCB2YWxvYXJlYSBkZSBpZciZaXJlIGVzdGUgMS4gRGFjxIMgYW1iZWxlIHZhbG9yaSBkZSBpbnRyYXJlIHN1bnQgcmVhbGUgc2F1IGFtYmVsZSBzdW50IGZhbHNlLCB2YWxvYXJlYSBkZSBpZciZaXJlIGVzdGUgMC5cIixcblx0XHRidWZmZXJlZFJhc3Rlck5hbWU6IFwiVGFtcG9uYXRcIixcblx0XHRidWZmZXJlZFJhc3RlclNuaXA6IFwiVGFtcG9uZWF6xIMgY2VsKGUpIG1haSByZWNlbnQoZSkgYmxvYyh1cmkpIGRlIHBpeGVsaSBhY2Nlc2F0ZS5cIixcblx0XHRidWZmZXJlZFJhc3RlckRlc2M6IFwiRnVuY8ibaWEgQnVmZmVyZWQgZXN0ZSBmb2xvc2l0xIMgcGVudHJ1IGEgb3B0aW1pemEgcGVyZm9ybWFuyJtlbGUgbGFuyJt1cmlsb3IgZGUgZnVuY8ibaWkgY29tcGxleGUuIFN0b2NoZWF6xIMgaWXImWlyZWEgw65uIG1lbW9yaWEgcMSDcsibaWkgbGFuyJt1bHVpIGRlIGZ1bmPIm2lpIGRlIGRpbmFpbnRlYSBhY2VzdHVpYS4gPGRpdj48YnIvPkludHJvZHVjZcibaSBhY2Vhc3TEgyBmdW5jyJtpZSDDrm4gRWRpdG9ydWwgZGUgRnVuY8ibaWUgYWNvbG8gdW5kZSBkb3JpyJtpIHPEgyBzdG9jYcibaSBpZciZaXJlYS48L2Rpdj5cIixcblx0XHRyYXN0ZXJDYWxjdWxhdG9yTmFtZTogXCJDYWxjdWxhdG9yXCIsXG5cdFx0cmFzdGVyQ2FsY3VsYXRvclNuaXA6IFwiQ2FsY3VsZWF6xIMgdW4gcmFzdGVyIGRpbnRyLW8gZXhwcmVzaWUgbWF0ZW1hdGljxIMgYmF6YXTEgyBwZSByYXN0ZXIuXCIsXG5cdFx0cmFzdGVyQ2FsY3VsYXRvckRlc2M6IFwiRnVuY8ibaWEgZGUgQ2FsY3VsYXRvciB2xIMgcGVybWl0ZSBzxIMgY3JlYcibaSDImWkgc8SDIHV0aWxpemHIm2kgZXhwcmVzaWkgyJlpIHPEgyBsZSBpbmNsdWRlyJtpIMOubiBsYW7Im3VyaWxlIGRlIGZ1bmPIm2lpLlwiLFxuXHRcdGNlbGxTdGF0aXN0aWNzTmFtZTogXCJTdGF0aXN0aWNpbGUgY2VsdWxlaVwiLFxuXHRcdGNlbGxTdGF0aXN0aWNzU25pcDogXCJDYWxjdWxlYXrEgyBvIHN0YXRpc3RpY8SDIHBlIGZpZWNhcmUgY2VsdWzEgyBkaW4gcmFzdGVyZSBtdWx0aXBsZS4gU3RhdGlzdGljaWxlIGRpc3BvbmliaWxlIHN1bnQgTWFqb3JpdGF0ZSwgTWF4aW11bSwgTWlqbG9jaXUsIE1lZGl1LCBNaW5pbXVtLCBNaW5vcml0YXRlLCBQZXJjZW50aWzEgywgSW50ZXJ2YWwsIEFiYXRlcmUgU3RhbmRhcmQsIFN1bcSDIMiZaSBWYXJpZXRhdGUuXCIsXG5cdFx0Y2VsbFN0YXRpc3RpY3NEZXNjOiBcIkFjZWFzdMSDIGZ1bmPIm2llIGNhbGN1bGVhesSDIHN0YXRpc3RpY2lsZSBkaW4gcmFzdGVyZSBtdWx0aXBsZSwgcGl4ZWwgY3UgcGl4ZWwuIFN0YXRpc3RpY2lsZSBkaXNwb25pYmlsZSBzdW50IG1ham9yaXRhdGUuIG1heGltdW0sIG1pamxvY2l1LCBtZWRpdSwgbWluaW11bSwgbWlub3JpdGF0ZSwgaW50ZXJ2YWwsIGFiYXRlcmUgc3RhbmRhcmQsIHN1bcSDIMiZaSB2YXJpZXRhdGUuXCIsXG5cdFx0Y2xhc3NpZnlOYW1lOiBcIkNsYXNpZmljYXJlXCIsXG5cdFx0Y2xhc3NpZnlTbmlwOiBcIkFsb2PEgyBmaWVjYXJlIHBpeGVsIHVuZWkgY2xhc2UuIEluY2x1ZGUgZGF0ZWxlIGF1eGlsaWFyZSBjdW0gYXIgZmkgbyBpbWFnaW5lIHNlZ21lbnRhdMSDLlwiLFxuXHRcdGNsYXNzaWZ5RGVzYzogXCJBY2Vhc3TEgyBmdW5jyJtpZSByYXN0ZXIgY2xhc2lmaWPEgyB1biBzZXQgZGUgZGF0ZSByYXN0ZXIgcGUgYmF6YSB1bnVpIGZpyJlpZXIgZGUgRGVmaW5pyJtpZSBhIENsYXNpZmljYXRvcnVsdWkgRXNyaSAoLmVjZCkgyJlpIGEgaW50csSDcmlsb3Igc2V0dXJpbG9yIGRlIGRhdGUgcmFzdGVyLiBGaciZaWVydWwgLmVjZCBmb2xvc2l0IMOubiBmdW5jyJtpYSBDbGFzaWZpY2FyZSBpbmNsdWRlIHRvYXRlIGluZm9ybWHIm2lpbGUgcGVudHJ1IHVuIHNldCBkZSBkYXRlIMiZaSBjbGFzaWZpY2F0b3Igc3BlY2lmaWMgyJlpIGVzdGUgZ2VuZXJhdCBkZSBjxIN0cmUgaW5zdHJ1bWVudGVsZSBkZSBpbnN0cnVpcmUgcGVudHJ1IGNsYXNpZmljYXJlLCBjdW0gYXIgZmkgaW5zdHJ1bWVudGVsZSBUcmFpbiBTdXBwb3J0IFZlY3RvciBNYWNoaW5lIHNhdSBUcmFpbiBSYW5kb20gVHJlZXMuXCIsXG5cdFx0Y2xpcE5hbWU6IFwiQXRhyJlhcmVcIixcblx0XHRjbGlwU25pcDogXCJTdGFiaWxlyJl0ZSBtxINyaW1lYSB1bnVpIHJhc3RlciBmb2xvc2luZCBjb29yZG9uYXRlbGUgc2F1IHVuIGFsdCBzZXQgZGUgZGF0ZS5cIixcblx0XHRjbGlwRGVzYzogXCJBY2Vhc3TEgyBmdW5jyJtpZSBkZWN1cGVhesSDIHVuIHJhc3RlciBmb2xvc2luZCBvIGZvcm3EgyBkcmVwdHVuZ2hpdWxhcsSDIGNvbmZvcm0gbcSDc3VyaWxvciBkZWZpbml0ZSBzYXUgdmEgZGVjdXBhIHVuIHJhc3RlciBjb25mb3JtIGZvcm1laSB1bmVpIGNsYXNlIGRlIG9iaWVjdGUgc3BhyJtpYWxlIHBvbGlnb25hbGUgZGUgaW50cmFyZS4gRm9ybWEgY2FyZSBkZWZpbmXImXRlIGRlY3VwYXJlYSBwb2F0ZSBkZWN1cGEgbcSDcmltZWEgcmFzdGVydWx1aSBzYXUgZGVjdXBhIG8gem9uxIMgZGluIHJhc3Rlci5cIixcblx0XHRjb2xvcnNwYWNlQ29udmVyc2lvbk5hbWU6IFwiVHJhbnNmb3JtYXJlYSBtb2RlbHVsdWkgZGUgY3Vsb2FyZVwiLFxuXHRcdGNvbG9yc3BhY2VDb252ZXJzaW9uU25pcDogXCJUcmFuc2Zvcm3EgyB1biByYXN0ZXIgZGluIFJHQiDDrm4gSFNWIMiZaSBpbnZlcnMuXCIsXG5cdFx0Y29sb3JzcGFjZUNvbnZlcnNpb25EZXNjOiBcIkZ1bmPIm2lhIGRlIENvbnZlcnNpZSBhIE1vZGVsdWx1aSBkZSBDdWxvYXJlIHRyYW5zZm9ybcSDIG1vZGVsdWwgZGUgY3Vsb2FyZSBhbCB1bmVpIGltYWdpbmkgZGluIHNwYcibaXVsIGRlIGN1bG9hcmUgZGUgbnVhbsibxIMsIHNhdHVyYcibaWUgyJlpIHZhbG9hcmUgKEhTVikgw65uIHJvyJl1LCB2ZXJkZSDImWkgYWxiYXN0cnUgKFJHQikgc2F1IGludmVycy48ZGl2Pjxici8+QWNlYXN0xIMgZnVuY8ibaWUgcG9hdGUgZmkgZm9sb3NpdMSDIMOubnRyLXVuIHNldCBkZSBkYXRlIG1vemFpYy48L2Rpdj5cIixcblx0XHRjb2xvcm1hcFRvUkdCTmFtZTogXCJIYXJ0xIMgYSBjdWxvcmlpIMOubiBSR0JcIixcblx0XHRjb2xvcm1hcFRvUkdCU25pcDogXCJUcmFuc2Zvcm3EgyB1biByYXN0ZXIgY3UgbyBzaW5ndXLEgyBiYW5kxIMgY3UgbyBoYXJ0xIMgYSBjdWxvcmlpIMOubnRyLXVuIHJhc3RlciBjdSB0cmVpIGJlbnppIChyb8iZdSwgdmVyZGUgyJlpIGFsYmFzdHJ1KS5cIixcblx0XHRjb2xvcm1hcFRvUkdCRGVzYzogXCJBY2Vhc3TEgyBmdW5jyJtpZSB0cmFuc2Zvcm3EgyB1biByYXN0ZXIgY3UgbyBzaW5ndXLEgyBiYW5kxIMgw65udHItdW4gcmFzdGVyIGN1IHRyZWkgYmVuemkgKHJvyJl1LCB2ZXJkZSDImWkgYWxiYXN0cnUpLjxkaXY+PGJyLz5BY2Vhc3TEgyBmdW5jyJtpZSBlc3RlIHV0aWzEgyBhdHVuY2kgY8OibmQgdHJlYnVpZSBzxIMgY3JlYcibaSB1biByYXN0ZXIgZGluIHRyZWkgYmVuemkgZGludHItdW4gcmFzdGVyIGN1IG8gc2luZ3VyxIMgYmFuZMSDIGN1IG8gaGFydMSDIGEgY3Vsb3JpaSBhc29jaWF0xIMuIFZhbG9yaWxlIGRpbiBoYXJ0YSBjdWxvcmlpIHZvciBmaSBmb2xvc2l0ZSBwZW50cnUgYSBjcmVhIGZpZWNhcmUgYmFuZMSDIHJvyJlpZSwgdmVyZGUgyJlpIGFsYmFzdHLEgy4gQWNlYXN0xIMgZnVuY8ibaWUgcG9hdGUgZmkgZm9sb3NpdMSDIMOubnRyLXVuIHNldCBkZSBkYXRlIG1vemFpYy48L2Rpdj5cIixcblx0XHRjb2xvcm1hcE5hbWU6IFwiQ3Vsb2FyZSBoYXJ0xINcIixcblx0XHRjb2xvcm1hcFNuaXA6IFwiTW9kaWZpY8SDIHZhbG9yaWxlIHBpeGVsaWxvciBwZW50cnUgYSBwcmV6ZW50YSBkYXRlbGUgcmFzdGVydWx1aSBjYSBzY2FyxIMgZ3JpIHNhdSBvIGltYWdpbmUgcm/ImWllLCB2ZXJkZSwgYWxiYXN0csSDIChSR0IpLCBwZSBiYXphIHVuZWkgaMSDcsibaSBhIGN1bG9yaWxvciBzYXUgYSB1bmVpIHJhbXBlIGRlIGN1bG9hcmUuXCIsXG5cdFx0Y29sb3JtYXBEZXNjOiBcIkZ1bmPIm2lhIEhhcnRhIEN1bG9yaWkgZXN0ZSB1biB0aXAgZGUgZGlzcG96aXRpdiBkZSByZWRhcmUgYSBkYXRlbG9yIHJhc3RlcnVsdWkuIEFjZWFzdGEgdHJhbnNmb3JtxIMgdmFsb3JpbGUgcGl4ZWxpbG9yIHBlbnRydSBhIGFmaciZYSBkYXRlbGUgcmFzdGVydWx1aSBjYSBmaWluZCBvIHNjYXLEgyBncmkgc2F1IG8gaW1hZ2luZSBkZSBjdWxvcmkgUkdCIGJhemF0xIMgcGUgbyBzY2hlbcSDIGRlIGN1bG9yaSBzYXUgY3Vsb3JpIHNwZWNpZmljZSDDrm50ci11biBmaciZaWVyIGRlIGhhcnTEgyBjb2xvci4gUHV0ZcibaSBmb2xvc2kgbyBoYXJ0xIMgY29sb3IgcGVudHJ1IGEgcmVwcmV6ZW50YSBkYXRlbGUgYW5hbGl6YXRlLCBjdW0gYXIgZmkgbyBpbWFnaW5lIGNsYXNpZmljYXTEgyBzYXUgbGEgYWZpyJlhcmVhIHVuZWkgaMSDcsibaSB0b3BvZ3JhZmljZSAoc2F1IGEgdW5laSBpbWFnaW5pIHNjYW5hdGUgY3UgaW5kaWNlIGRlIGN1bG9hcmUpLjxkaXY+PGJyLz4gSMSDcsibaWxlIGRlIGN1bG9yaSBjb27Im2luIHVuIHNldCBkZSB2YWxvcmkgYXNvY2lhdGUgY3Vsb3JpbG9yIGZvbG9zaXRlIHBlbnRydSBhZmnImWFyZWEgdW51aSByYXN0ZXIgY3UgbyBzaW5ndXLEgyBiYW5kxIMgw65uIG1vZCBjb25zZWN2ZW50IGN1IGFjZWxlYciZaSBjdWxvcmkuIEZpZWNhcmUgdmFsb2FyZSBhIHBpeGVsdWx1aSBlc3RlIGFzb2NpYXTEgyB1bmVpIGN1bG9yaSwgZGVmaW5pdGUgY2EgdW4gc2V0IGRlIHZhbG9yaSBSR0IuIEjEg3LIm2lsZSBkZSBjdWxvcmkgc3VudCBjYXBhYmlsZSBzxIMgc3Vwb3J0ZSBvcmljZSBhZMOibmNpbWUgYSBiaXR1bHVpIGN1IGV4Y2VwyJtpYSBwdW5jdHVsdWkgZmxvdGFudC4gRGUgYXNlbWVuZWEsIHN1cG9ydMSDIHZhbG9yaWxlIHBveml0aXZlIMiZaSBuZWdhdGl2ZSDImWkgcG90IGluY2x1ZGUgdmFsb3JpbGUgbGlwc8SDIGN1IGjEg3LIm2kgZGUgY3Vsb3JpLiBMYSBhZmnImWFyZWEgdW51aSBzZXQgZGUgZGF0ZSBjdSBvIGhhcnTEgyBkZSBjdWxvcmkgY2FyZSBpbmNsdWRlIHZhbG9yaSBsaXBzxIMsIHBpeGVsaWkgY3UgYWNlbGUgdmFsb3JpIGxpcHPEgyBudSB2b3IgZmkgYWZpyJlhyJtpLjwvZGl2PlwiLFxuXHRcdGNvbXBsZXhOYW1lOiBcIkNvbXBsZXhcIixcblx0XHRjb21wbGV4U25pcDogXCJFeHRyYWdlIG1hZ25pdHVkaW5lYSBkaW4gbnVtZXJlbGUgY29tcGxleGUuXCIsXG5cdFx0Y29tcGxleERlc2M6IFwiQWNlYXN0xIMgZnVuY8ibaWUgY2FsY3VsZWF6xIMgbWFnbml0dWRpbmVhIGRpbiB2YWxvcmkgY29tcGxleGUuPGRpdj48YnIvPkFjZWFzdMSDIGZ1bmPIm2llIGVzdGUgZm9sb3NpdMSDIGRlIG9iaWNlaSBjdSBpbWFnaW5pIFJBREFSIGNhcmUgYXUgdW4gdGlwIGRlIGRhdGUgY29tcGxleGUuIFBvYXRlIGZpIGZvbG9zaXTEgyDDrm50ci11biBzZXQgZGUgZGF0ZSBtb3phaWMuPC9kaXY+XCIsXG5cdFx0Y29tcG9zaXRlQmFuZE5hbWU6IFwiQmVuemkgY29tcG96aXRlXCIsXG5cdFx0Y29tcG9zaXRlQmFuZFNuaXA6IFwiQ29tYmluxIMgc2V0dXJpbGUgZGUgZGF0ZSBtdWx0aXBsZSDDrm50ci11biByYXN0ZXIgY3UgYmVuemkgbXVsdGlwbGUuXCIsXG5cdFx0Y29tcG9zaXRlQmFuZERlc2M6IFwiRnVuY8ibaWEgZGUgQmVuemkgQ29tcG96aXRlIHbEgyBwZXJtaXRlIHPEgyBjb21iaW5hyJtpIHJhc3RlcmVsZSBwZW50cnUgYSBmb3JtYSBvIGltYWdpbmUgY3UgbWFpIG11bHRlIGJlbnppLlwiLFxuXHRcdGNvbk5hbWU6IFwiQ29uXCIsXG5cdFx0Y29uU25pcDogXCJFZmVjdHVlYXrEgyBvIG9wZXJhyJtpdW5lIGNvbmRpyJtpb25hbMSDIERhY8SDLCBBdHVuY2ksIFNhdS4gQXR1bmNpIGPDom5kIGVzdGUgZm9sb3NpdCB1biBvcGVyYXRvciBDb24sIGRlIG9iaWNlaSB0cmVidWllIHPEgyBleGlzdGUgZG91xIMgc2F1IG1haSBtdWx0ZSBmdW5jyJtpaSBjb25lY3RhdGUsIGFjb2xvIHVuZGUgbyBmdW5jyJtpZSBzdGFiaWxlyJl0ZSBjcml0ZXJpaWxlIMiZaSBhIGRvdWEgZnVuY8ibaWUgbyByZXByZXppbnTEgyBvcGVyYXRvcnVsIENvbiBjYXJlIGZvbG9zZciZdGUgY3JpdGVyaWlsZSDImWkgZGljdGVhesSDIGNhcmUgYXIgdHJlYnVpIHPEgyBmaWUgaWXImWlyaWxlIHJlYWxlIMiZaSBmYWxzZS5cIixcblx0XHRjb25EZXNjOiBcIkZ1bmPIm2lhIENvbmRpyJtpb25hbCBzdGFiaWxlyJl0ZSBwaXhlbGlpIHJhc3RlcnVsdWkgZGUgaWXImWlyZSBwZSBiYXphIHVuZWkgZXZhbHXEg3JpIGRhY8SDLy9zYXUgYSBmaWVjxINydWkgcGl4ZWwgZGUgaW50cmFyZS4gUmV0dXJuZWF6xIMgdmFsb3JpbGUgcGl4ZWx1bHVpIGRpbiBSYXN0ZXJ1bCBSZWFsIGRhY8SDIGV2YWx1YXJlYSBjb25kacibaW9uYWzEgyBlc3RlIHJlYWzEgyAoMSkgc2F1IHJldHVybmVhesSDIHZhbG9yaWxlIHBpeGVsdWx1aSBkaW4gUmFzdGVydWwgRmFscyBkYWPEgyBldmFsdWFyZWEgY29uZGnIm2lvbmF0xIMgZXN0ZSBmYWxzxIMgKDApLiBBY2VzdCBjcml0ZXJpdSBlc3RlIHNwZWNpZmljYXQgZGUgcmV6dWx0YXR1bCB1bmVpIGZ1bmPIm2lpIG1hdGVtYXRpY2UgbG9naWNlLCBjYXJlIHZhIGZpIFJhc3RlcnVsIGRlIGludHJhcmUuXCIsXG5cdFx0Y29uc3RhbnROYW1lOiBcIkNvbnN0YW50xINcIixcblx0XHRjb25zdGFudFNuaXA6IFwiQ3JlZWF6xIMgdW4gcmFzdGVyIHZpcnR1YWwgY3UgbyBzaW5ndXLEgyB2YWxvYXJlIGRlIHBpeGVsLlwiLFxuXHRcdGNvbnN0YW50RGVzYzogXCJBY2Vhc3TEgyBmdW5jyJtpZSBjcmVlYXrEgyB1biByYXN0ZXIgdmlydHVhbCBjdSBvIHNpbmd1csSDIHZhbG9hcmUgZGUgcGl4ZWwgY2FyZSBwb2F0ZSBmaSBmb2xvc2l0xIMgw65uIMiZYWJsb2FuZSBkZSBmdW5jyJtpZSByYXN0ZXIgyJlpIHBlbnRydSBhIHByZWx1Y3JhIHVuIHNldCBkZSBkYXRlIG1vemFpYy48ZGl2Pjxici8+VmFsb2FyZWEgY29uc3RhbnTEgyBlc3RlIGZvbG9zaXTEgyBwZW50cnUgZmllY2FyZSB2YWxvYXJlIGRlIHBpeGVsIGRpbiByYXN0ZXIuPC9kaXY+XCIsXG5cdFx0Y29udG91ck5hbWU6IFwiQ29udHVyXCIsXG5cdFx0Y29udG91clNuaXA6IFwiQ3JlZWF6xIMgbGluaWkgZGUgY29udHVyLlwiLFxuXHRcdGNvbnRvdXJEZXNjOiBcIkZ1bmPIm2lhIGRlIGNvbnR1ciBnZW5lcmVhesSDIGxpbmlpIGNvbnR1ciBwcmluIGFsxIN0dXJhcmVhIHB1bmN0ZWxvciBjdSBhY2VlYciZaSBlbGV2YcibaWUgZGludHItdW4gc2V0IGRlIGRhdGUgZGUgZWxldmHIm2llIGEgcmFzdGVydWx1aS4gQ29udHVydXJpbGUgc3VudCBpem9saW5paSBjcmVhdGUgY2EgcmFzdGVyZSBwZW50cnUgdml6dWFsaXphcmUuIFVybcSDdG9hcmVsZSBjYXJhY3RlcmlzdGljaSBwcmluY2lwYWxlIHJlcHJlemludMSDIGZvcsibYSBhY2VzdGVpIGZ1bmPIm2lpOiBjb250dXJ1cmlsZSBzdW50IGdlbmVyYXRlIHJhcGlkIMiZaSBkaW5hbWljIHBlIHNldHVyaSBkZSBkYXRlIGZvYXJ0ZSBtYXJpLCBhyJlhIGN1bSBhciBmaSBFbGV2YcibaWEgR2xvYmFsxIM7IGNvbnR1cnVyaWxlIHBvdCBmaSBhcGxhdGl6YXRlIHBlbnRydSBhIG9mZXJpIHVuIGFzcGVjdCBjYXJ0b2dyYWZpYyBtYWkgcGzEg2N1dCDDrm4gdGltcCBjZSBzZSBwxINzdHJlYXrEgyBhY3VyYXRlyJtlYSBjb250dXJ1cmlsb3I7IHNlIGFzaWd1csSDIGNvbnRyb2x1bCBkaW5hbWljIGFzdXByYSBpbnRlcnZhbHVsdWkgZGUgY29udHVyOyBvcMibaXVuaWxlIGRlIGllyJlpcmUgaW5jbHVkIGxpbmlpbGUgZGUgY29udHVyLCBjb250dXJ1cmlsZSBpbmRleCDImWkgY29udHVydXJpbGUgdW1wbHV0ZS48ZGl2Pjxici8+Q3JlYXJlYSB1bnVpIHN0cmF0IHRlbWF0aWMgZGUgY29udHVyIGNhIHByb2R1cyByYXN0ZXIgZXN0ZSB2YWxvcm9hc8SDIHBlbnRydSBvIGdhbcSDIGxhcmfEgyBkZSBhcGxpY2HIm2lpIGRpbiBtb21lbnQgY2UgY29udHVydXJpbGUgcG90IGZpIHN1cHJhcHVzZSBwZSBvIGhhcnTEgyDImWkgcG90IG9mZXJpIGluZm9ybWHIm2lpIHJlZmVyaXRvYXJlIGxhIHRlcmVuIGbEg3LEgyBhIGFzY3VuZGUgZGF0ZWxlIGRlIGJhesSDLiBBY2VzdGVhIHN1bnQgdXRpbGUgw65uIGFwbGljYcibaWkgY3VtIGFyIGZpIGluZ2luZXJpYSwgYWdyaWN1bHR1cmEgyJlpIGFkbWluaXN0cmFyZWEgYXBlbG9yLjwvZGl2PlwiLFxuXHRcdGNvbnRyYXN0QnJpZ2h0bmVzc05hbWU6IFwiQ29udHJhc3QgyJlpIEx1bWlub3ppdGF0ZVwiLFxuXHRcdGNvbnRyYXN0QnJpZ2h0bmVzc1NuaXA6IFwiQWp1c3RhyJtpIGNvbnRyYXN0dWwgyJlpIGx1bWlub3ppdGF0ZWEgdW51aSByYXN0ZXIuXCIsXG5cdFx0Y29udHJhc3RCcmlnaHRuZXNzRGVzYzogXCJGdW5jyJtpYSBkZSBDb250cmFzdCDImGkgTHVtaW5veml0YXRlIGFtcGxpZmljxIMgYXNwZWN0dWwgZGF0ZWxvciByYXN0ZXIgcHJpbiBtb2RpZmljYXJlYSBsdW1pbm96aXTEg8ibaWkgyJlpIGNvbnRyYXN0dWx1aSBkaW4gaW1hZ2luZS4gTHVtaW5veml0YXRlYSBjcmXImXRlIGlsdW1pbmFyZWEgZ2VuZXJhbMSDIGEgaW1hZ2luaWnigJRkZSBleGVtcGx1LCBkZXNjaGl6w6JuZCBjdWxvcmlsZSBtYWkgw65uY2hpc2UgyJlpIGFsYmluZCBjdWxvcmlsZSBkZXNjaGlzZeKAlMOubiB0aW1wIGNlIGNvbnRyYXN0dWwgYWp1c3RlYXrEgyBkaWZlcmVuyJthIGRpbnRyZSBjdWxvcmlsZSBjZWxlIG1haSDDrm5jaGlzZSDImWkgY2VsZSBtYWkgZGVzY2hpc2UuPGRpdj48YnIvPlV0aWxpemFyZWEgYWNlc3RlaSBmdW5jyJtpaSBtb2RpZmljxIMgdmFsb3JpbGUgcGl4ZWx1bHVpOyBhc3RmZWwsIGFjZWFzdMSDIGZ1bmPIm2llIGFyIHRyZWJ1aSBmb2xvc2l0xIMgYXR1bmNpIGPDom5kIGRvcmnIm2kgc8SDIGFtcGxpZmljYcibaSBkYXRlbG9yIMiZaSBudSBkYWPEgyBpbnRlbsibaW9uYcibaSBzxIMgZm9sb3NpyJtpIGRhdGVsZSBjYSBwYXJ0ZSBhIHVuZWkgYW5hbGl6ZSBjYXJlIGFyIG5lY2VzaXRhIHZhbG9yaWxlIGJydXRlIGFsZSBwaXhlbGlsb3IuIEFjZWFzdMSDIGZ1bmPIm2llIGVzdGUgdXRpbMSDIGxhIHB1YmxpY2FyZWEgZGF0ZWxvciBjYSB1biBzZXJ2aWNpdSBkZSBpbWFnaW5pIGNhcmUgcG9hdGUgZmkgdXRpbGl6YXQgw65uIGFwbGljYcibaWkgZsSDcsSDIGNhcGFjaXRhdGUgZGUgbW9kaWZpY2FyZSBhIGNvbnRyYXN0dWx1aSDImWkgbHVtaW5veml0xIPIm2lpIGltYWdpbmlsb3IsIHNhdSBwZW50cnUgYSBhc2lndXJhIGPEgyBmYWNlIG8gcHJlemVudGFyZSBmb2xvc2luZCBzZXTEg3JpbGUgZHZzLiBwcmVmZXJhdGUuPC9kaXY+XCIsXG5cdFx0Y29udm9sdXRpb25OYW1lOiBcIkNvbnZvbHXIm2llXCIsXG5cdFx0Y29udm9sdXRpb25TbmlwOiBcIkFwbGljxIMgdW4gZmlsdHJ1IHBlbnRydSBhIGNsYXJpZmljYSwgYmx1cmEsIGRldGVjdGEgbWFyZ2luaSwgYXBsYXRpemEgc2F1IHVuIGdyYWRpZW50IHBlIHVuIHJhc3Rlci5cIixcblx0XHRjb252b2x1dGlvbkRlc2M6IFwiRnVuY8ibaWEgQ29udm9sdcibaWUgZWZlY3R1ZWF6xIMgZmlsdHJhcmVhIGFzdXByYSB2YWxvcmlsb3IgcGl4ZWxpbG9yIGRpbnRyLW8gaW1hZ2luZSwgY2FyZSBwb2F0ZSBmaSBmb2xvc2l0IHBlbnRydSBjbGFyaWZpY2FyZWEgdW5laSBpbWFnaW5pLCBibHVyYXJlYSB1bmVpIGltYWdpbmksIGRldGVjdGFyZWEgbWFyZ2luaWxvciBkaW50ci1vIGltYWdpbmUsIHNhdSBhbHRlIGFtcGxpZmljxINyaSBiYXphdGUgcGUgbnVjbGVlLiBGaWx0cmVsZSBzdW50IHV0aWxpemF0ZSBwZW50cnUgw65tYnVuxIN0xIPIm2lyZWEgY2FsaXTEg8ibaWkgaW1hZ2luaWkgcmFzdGVyIHByaW4gZWxpbWluYXJlYSBkYXRlbG9yIHNlY3VuZGFyZSBzYXUgYW1wbGlmaWNhcmVhIG9iaWVjdGVsb3Igc3BhyJtpYWxlIGRpbiBkYXRlLiBBY2VzdGUgZmlsdHJlIGRlIGNvbnZvbHXIm2llIHN1bnQgYXBsaWNhdGUgcGUgdW4gbnVjbGV1IGFmbGF0IMOubiBkZXBsYXNhcmUsIHN1cHJhcHVzIChmZXJlYXN0csSDIHNhdSDDrm4gYXByb3BpZXJlKSwgY3VtIGFyIGZpIDMgb3JpIDMuIEZpbHRyZWxlIGRlIGNvbnZvbHXIm2llIGZ1bmPIm2lvbmVhesSDIHByaW4gY2FsY3VsYXJlYSB2YWxvcmlpIHBpeGVsdWx1aSBwZSBiYXphIHBvbmRlcmlpIHZlY2luaWxvciBzxINpLlwiLFxuXHRcdGNvcnJpZG9yTmFtZTogXCJDb3JpZG9yXCIsXG5cdFx0Y29ycmlkb3JTbmlwOiBcIkNhbGN1bGVhesSDIHN1bWEgY29zdHVyaWxvciBhY3VtdWxhdGl2ZSBwZW50cnUgZG91xIMgcmFzdGVyZSBhY3VtdWxhdGl2ZSBkZSBpbnRyYXJlLlwiLFxuXHRcdGNvcnJpZG9yRGVzYzogXCJGdW5jyJtpYSBkZSBjb3JpZG9yIGNhbGN1bGVhesSDIHN1bWEgY29zdHVyaWxvciBhY3VtdWxhdGl2ZSBwZW50cnUgZG91xIMgcmFzdGVyZSBkZSBjb3N0IGFjdW11bGF0aXZlIGRlIGludHJhcmUuIMOObiB0aW1wIGNlIG9yaWNhcmUgZG91xIMgcmFzdGVyZSBwb3QgZmkgdXRpbGl6YXRlIHBlbnRydSBpbnRyYXJlLCBwZW50cnUgYSBvYsibaW5lIHVuIHJlenVsdGF0IHNlbW5pZmljYXRpdiBhY2VzdGVhIHRyZWJ1aWUgc8SDIGZpZSByYXN0ZXJlIGRlIGllyJlpcmUgZGUgY29zdCBhY3VtdWxhdGl2ZSBuZWFsdGVyYXRlLiBPcmRpbmVhIGNlbG9yIGRvdcSDIGludHLEg3JpIGVzdGUgaXJlbGV2YW50xIMuXCIsXG5cdFx0Y29zSE5hbWU6IFwiQ29zSFwiLFxuXHRcdGNvc0hTbmlwOiBcIkNhbGN1bGVhesSDIGNvc2ludXN1bCBoaXBlcmJvbGljIGFsIGNlbHVsZWxvciBkaW50ci11biByYXN0ZXIuXCIsXG5cdFx0Y29zSERlc2M6IFwiRnVuY8ibaWEgY2FsY3VsZWF6xIMgY29zaW51c3VsIGhpcGVyYm9saWMgYWwgcGl4ZWxpbG9yIGRpbnRyLXVuIHJhc3Rlci5cIixcblx0XHRjb3NOYW1lOiBcIkNvc1wiLFxuXHRcdGNvc1NuaXA6IFwiQ2FsY3VsZWF6xIMgY29zaW51c3VsIHVuZWkgY2VsdWxlIGRpbnRyLXVuIHJhc3Rlci5cIixcblx0XHRjb3NEZXNjOiBcIkZ1bmPIm2lhIGNhbGN1bGVhesSDIGNvc2ludXN1bCBwaXhlbGlsb3IgZGludHItdW4gcmFzdGVyLlwiLFxuXHRcdGNvc3RBbGxvY2F0aW9uTmFtZTogXCJBbG9jYXJlYSBDb3N0dWx1aVwiLFxuXHRcdGNvc3RBbGxvY2F0aW9uU25pcDogXCJDYWxjdWxlYXrEgywgcGVudHJ1IGZpZWNhcmUgY2VsdWzEgywgc3Vyc2EgY3UgY2VsIG1haSBtaWMgY29zdCBwZSBiYXphIGNvc3R1bHVpIGNlbCBtYWkgcHXIm2luIGFjdW11bGF0aXYgcGUgbyBzdXByYWZhyJvEgyBkZSBjb3N0LlwiLFxuXHRcdGNvc3RBbGxvY2F0aW9uRGVzYzogXCJGdW5jyJtpYSBkZSBBbG9jYXJlIGEgQ29zdHVyaWxvciBjYWxjdWxlYXrEgywgcGVudHJ1IGZpZWNhcmUgY2VsdWzEgywgc3Vyc2EgY3UgY2VsIG1haSBtaWMgY29zdCBwZSBiYXphIGNvc3R1bHVpIGNlbCBtYWkgcHXIm2luIGFjdW11bGF0aXYgcGUgbyBzdXByYWZhyJvEgyBkZSBjb3N0LlwiLFxuXHRcdGNvc3RCYWNrTGlua05hbWU6IFwiTGluayBDb3N0IEJhY2tcIixcblx0XHRjb3N0QmFja0xpbmtTbmlwOiBcIkRlZmluZciZdGUgdmVjaW51bCBjYXJlIGVzdGUgY2VsdWxhIHVybcSDdG9hcmUgcGUgdHJhc2V1bCBkZSBjb3N0IGNlbCBtYWkgcHXIm2luIGFjdW11bGF0aXYgY8SDdHJlIHN1cnNhIGN1IGNlbCBtYWkgbWljIGNvc3QuXCIsXG5cdFx0Y29zdEJhY2tMaW5rRGVzYzogXCJGdW5jyJtpYSBkZSBDb3N0IEJhY2sgZGVmaW5lyJl0ZSB2ZWNpbnVsIGNhcmUgZXN0ZSBjZWx1bGEgdXJtxIN0b2FyZSBwZSB0cmFzZXVsIGRlIGNvc3QgY2VsIG1haSBwdcibaW4gYWN1bXVsYXRpdiBjxIN0cmUgc3Vyc2EgY3UgY2VsIG1haSBtaWMgY29zdC48ZGl2Pjxici8+UmFzdGVydWwgZGUgbGVnxIN0dXLEgyBpbnZlcnPEgyBpbmNsdWRlIHZhbG9yaSBkZSB6ZXJvIHDDom7EgyBsYSBvcHQsIGNhcmUgZGVmaW5lc2MgZGlyZWPIm2lhIHNhdSBpZGVudGlmaWPEgyB1cm3Eg3RvYXJlYSBjZWx1bMSDIHZlY2luxIMgKGNlbHVsYSBjYXJlIHN1Y2NlZGUpIHBlIHRyYXNldWwgZGUgY29zdCBjZWwgbWFpIHB1yJtpbiBhY3VtdWxhdGl2IGRlIGxhIG8gY2VsdWzEgyBwZW50cnUgYSBhanVuZ2UgbGEgc3Vyc2Egc2EgY3UgY2VsZSBtYWkgbWljaSBjb3N0dXJpLiBEYWPEgyB0cmFzZXVsIHZhIHRyZWNlIGxhIHZlY2ludWwgZGluIGRyZWFwdGEsIGNlbHVsYSB2YSBwcmltaSB2YWxvYXJlYSAxLCAyIHBlbnRydSBjZWx1bGEgZGlhZ29uYWzEgyBkaW4gZHJlYXB0YSBqb3MgyJlpIGNvbnRpbnXEgyDDrm4gc2VucyBvcmFyLiBWYWxvYXJlYSAwIGVzdGUgcmV6ZXJ2YXTEgyBwZW50cnUgY2VsdWxlbGUgc3Vyc8SDLjwvZGl2PlwiLFxuXHRcdGNvc3REaXN0YW5jZU5hbWU6IFwiRGlzdGFuyJvEgyBkZSBDb3N0XCIsXG5cdFx0Y29zdERpc3RhbmNlU25pcDogXCJDYWxjdWxlYXrEgyBkaXN0YW7Im2EgZGUgY29zdCBjZWwgbWFpIHB1yJtpbiBhY3VtdWxhdGl2xIMgcGVudHJ1IGZpZWNhcmUgY2VsdWzEgyBkZSBsYSBzYXUgbGEgc3Vyc2EgY3UgY2VsIG1haSBtaWMgY29zdCBwZSBvIHN1cHJhZmHIm8SDIGRlIGNvc3QuXCIsXG5cdFx0Y29zdERpc3RhbmNlRGVzYzogXCJGdW5jyJtpYSBDb3N0IERpc3RhbsibxIMgY2FsY3VsZWF6xIMgZGlzdGFuyJthIGRlIGNvc3QgY2VsIG1haSBwdcibaW4gYWN1bXVsYXRpdsSDIHBlbnRydSBmaWVjYXJlIGNlbHVsxIMgZGUgbGEgc2F1IGxhIHN1cnNhIGN1IGNlbCBtYWkgbWljIGNvc3QgcGUgbyBzdXByYWZhyJvEgyBkZSBjb3N0LlwiLFxuXHRcdGNvc3RQYXRoTmFtZTogXCJUcmFzZXUgZGUgQ29zdFwiLFxuXHRcdGNvc3RQYXRoU25pcDogXCJDYWxjdWxlYXrEgyB0cmFzZXVsIGN1IGNlbCBtYWkgbWljIGNvc3QgZGludHItbyBzdXJzxIMgbGEgbyBkZXN0aW5hyJtpZS5cIixcblx0XHRjb3N0UGF0aERlc2M6IFwiRnVuY8ibaWEgZ2xvYmFsxIMgVHJhc2V1IGRlIENvc3QgY2FsY3VsZWF6xIMgdHJhc2V1bCBjdSBjZWwgbWFpIG1pYyBjb3N0IGRpbnRyLW8gc3Vyc8SDIGxhIG8gZGVzdGluYcibaWUuPGRpdj48YnIvPkFjZWFzdMSDIGZ1bmPIm2llIHByb2R1Y2UgdW4gcmFzdGVyIGRlIGllyJlpcmUgY2FyZSDDrm5yZWdpc3RyZWF6xIMgdHJhc2V1bCBzYXUgdHJhc2VlbGUgY3UgY29zdHVsIGNlbCBtYWkgbWljIGRpbiBsb2NhyJtpaSBzZWxlY3RhdGUgcMOibsSDIGxhIGNlYSBtYWkgYXByb3BpYXTEgyBzdXJzxIMgZGVmaW5pdMSDIMOubiBzdXByYWZhyJthIGRlIGNvc3QgYWN1bXVsYXRpdsSDLCBjdSBwcml2aXJlIGxhIGRpc3RhbsibYSBkZSBjb3N0LjwvZGl2PlwiLFxuXHRcdGN1cnZhdHVyZU5hbWU6IFwiQ3VyYnVyxINcIixcblx0XHRjdXJ2YXR1cmVTbmlwOiBcIkNhbGN1bGVhesSDIGN1cmJ1cmEgdW5laSBzdXByYWZlyJtlIHJhc3RlciwgaW5jbHV6w6JuZCBvcMibaW9uYWwgcHJvZmlsdWwgyJlpIGN1cmJ1cmEgcGxhbnVsdWkuXCIsXG5cdFx0Y3VydmF0dXJlRGVzYzogXCJGdW5jyJtpYSBkZSBDdXJidXLEgyBwcmV6aW50xIMgZm9ybWEgc2F1IGN1cmJ1cmEgcGFudGVpLiBPIHBhcnRlIGEgdW5laSBzdXByYWZlyJtlIHBvYXRlIGZpIGNvbmNhdsSDIHNhdSBjb252ZXjEgzsgdsSDIHB1dGXIm2kgZGEgc2VhbWEgZGUgYWNlc3QgbHVjcnUgcHJpdmluZCB2YWxvYXJlYSBjdXJidXJpaS4gQ3VyYnVyYSBlc3RlIGNhbGN1bGF0xIMgcHJpbiBjYWxjdWxhcmVhIGNlbGVpIGRlLWEgZG91YSBkZXJpdmF0aXZlIGEgc3VwcmFmZcibZWkuPGRpdj48YnIvPkllyJlpcmVhIGZ1bmPIm2llaSBkZSBDdXJidXLEgyBwb2F0ZSBmaSBmb2xvc2l0xIMgcGVudHJ1IGEgZGVzY3JpZSBjYXJhY3RlcmlzdGljaWxlIGZpemljZSBhbGUgdW51aSBiYXppbiBkZSBzY3VyZ2VyZSDDrm50ci11biBlZm9ydCBwZW50cnUgYSDDrm7Im2VsZWdlIHByb2Nlc2VsZSBkZSBlcm96aXVuZSDImWkgc2N1cmdlcmUuIFZhbG9hcmVhIGN1cmJ1cmlpIHBvYXRlIGZpIGZvbG9zaXTEgyBwZW50cnUgYSBnxINzaSDImWFibG9hbmUgZGUgZXJveml1bmUgYSBzb2x1bHVpIGPDonQgyJlpIGRpc3RyaWJ1yJtpYSBhcGVpIHBlIHRlcmVuLiBDdXJidXJhIHByb2ZpbHVsdWkgYWZlY3RlYXrEgyBhY2NlbGVyYXJlYSDImWkgZGVjZWxlcmFyZWEgY3VyZ2VyaWkgyJlpLCBwcmluIHVybWFyZSwgaW5mbHVlbsibZWF6xIMgZXJveml1bmVhIMiZaSBkZXB1bmVyaWxlLiBDdXJidXJhIHBsYXRmb3JtZWkgaW5mbHVlbsibZWF6xIMgY29udmVyZ2VuyJthIMiZaSBkaXZlcmdlbsibYSBjdXJnZXJpaS48L2Rpdj5cIixcblx0XHRkaXZpZGVOYW1lOiBcIsOObXDEg3LIm2lyZVwiLFxuXHRcdGRpdmlkZVNuaXA6IFwiw45tcGFydGUgdmFsb3JpbGUgYSBkb3XEgyByYXN0ZXJlIGNlbHVsxIMgY3UgY2VsdWzEgy5cIixcblx0XHRkaXZpZGVEZXNjOiBcIkZ1bmPIm2lhIGRlIMOObXDEg3LIm2lyZSDDrm1wYXJ0ZSB2YWxvcmlsZSBhIGRvdcSDIHJhc3RlcmUgcGl4ZWwgY3UgcGl4ZWwuXCIsXG5cdFx0ZWxldmF0aW9uVm9pZEZpbGxOYW1lOiBcIlVtcGxlcmVhIFZpZHVsdWkgRWxldmHIm2llaVwiLFxuXHRcdGVsZXZhdGlvblZvaWRGaWxsU25pcDogXCJDcmVlYXrEgyBwaXhlbGkgYWNvbG8gdW5kZSBleGlzdMSDIGfEg3VyaSDDrm4gZGF0ZWxlIGR2cy4gZGUgZWxldmHIm2llLlwiLFxuXHRcdGVsZXZhdGlvblZvaWRGaWxsRGVzYzogXCJGdW5jyJtpYSBkZSBVbXBsZXJlIGEgVmlkdWx1aSBFbGV2YcibaWVpIGVzdGUgdXRpbGl6YXTEgyBwZW50cnUgYSBjcmVhIHBpeGVsaSBhY29sbyB1bmRlIGV4aXN0xIMgZ8SDdXJpIMOubiBlbGV2YcibaWEgZHZzLjxkaXY+PGJyLz5WaWR1bCBhcGFyZSBhY29sbyB1bmRlIG51IGV4aXN0xIMgcHVuY3RlIGNvbGVjdGF0ZSDDrm4gem9uYSByZXByZXplbnRhdMSDIGRlIHVuIHBpeGVsIMOubiByYXN0ZXJ1bCByZXp1bHRhbnQuIFZpZHVsIGVzdGUgYWRlc2VhIGNhdXphdCBkZSBjb3JwdXJpbGUgZGUgYXDEgywgZGUgc2VsZWN0YXJlYSB0aXB1bHVpIGRlIGNsYXPEgyBzYXUgZGUgZXhjbHVkZXJlLiBVbXBsZXJlYSB2aWR1bHVpIGVzdGUgdXRpbGl6YXTEgyBjZWwgbWFpIGRlcyBsYSBnZW5lcmFyZWEgdW5laSBzdXByYWZlyJtlIGRlIHNvbC48L2Rpdj5cIixcblx0XHRlcXVhbFRvTmFtZTogXCJFZ2FsxIMgY3VcIixcblx0XHRlcXVhbFRvU25pcDogXCJFZmVjdHVlYXrEgyBvIG9wZXJhyJtpZSBkZSBlZ2FsaXphcmUgUmVsYcibaW9uYWzEgyBwZSBkb3XEgyBpbnRyxINyaSBkZSBsYSBvIGNlbHVsxIMgbGEgYWx0YS4gUmV0dXJuZWF6xIMgdmFsb2FyZWEgMSBwZW50cnUgY2VsdWxlbGUgdW5kZSBwcmltdWwgcmFzdGVyIGVzdGUgY3UgY2VsIGRlLWFsIGRvaWxlYSByYXN0ZXIgyJlpIDAgcGVudHJ1IGNlbHVsZWxlIHVuZGUgYWNlc3RlYSBudSBzdW50IGVnYWxlLlwiLFxuXHRcdGVxdWFsVG9EZXNjOiBcIkZ1bmPIm2lhIGVmZWN0dWVhesSDIG8gb3BlcmHIm2llIGRlIGVnYWxpemFyZSBwZSBkb3XEgyByYXN0ZXJlIGRlIGxhIHVuIHBpeGVsIGxhIGFsdHVsLiBBY2Vhc3RhIHJldHVybmVhesSDIHZhbG9hcmVhIDEgcGVudHJ1IHBpeGVsaWkgdW5kZSBwcmltdWwgcmFzdGVyIGVzdGUgZWdhbCBjdSBjZWwgZGUtYWwgZG9pbGVhIHJhc3RlciDImWkgdmFsb2FyZWEgMCBwZW50cnUgcGl4ZWxpIHVuZGUgYWNlyJl0aWEgbnUgc3VudCBlZ2FsaS5cIixcblx0XHRldWNBbGxvY2F0aW9uTmFtZTogXCJBbG9jYXJlIEV1Y2xpZGlhbsSDXCIsXG5cdFx0ZXVjQWxsb2NhdGlvblNuaXA6IFwiQ2FsY3VsZWF6xIMsIHBlbnRydSBmaWVjYXJlIGNlbHVsxIMsIGNlYSBtYWkgYXByb3BpYXTEgyBzdXJzxIMgcGUgYmF6YSBkaXN0YW7Im2VpIGV1Y2xpZGllbmUuXCIsXG5cdFx0ZXVjQWxsb2NhdGlvbkRlc2M6IFwiRnVuY8ibaWEgZGUgQWxvY2FyZSBFdWNsaWRpYW7EgyBjYWxjdWxlYXrEgywgcGVudHJ1IGZpZWNhcmUgY2VsdWzEgywgY2VhIG1haSBhcHJvcGlhdMSDIHN1cnPEgyBwZSBiYXphIGRpc3RhbsibZWkgZXVjbGlkaWVuZS5cIixcblx0XHRldWNEaXJlY3Rpb25OYW1lOiBcIkRpcmVjyJtpZSBFdWNsaWRpYW7Eg1wiLFxuXHRcdGV1Y0RpcmVjdGlvblNuaXA6IFwiQ2FsY3VsZWF6xIMsIHBlbnRydSBmaWVjYXJlIGNlbHVsxIMsIGRpcmVjyJtpYSBww6JuxIMgbGEgY2VhIG1haSBhcHJvcGlhdMSDIHN1cnPEgywgw65uIGdyYWRlLlwiLFxuXHRcdGV1Y0RpcmVjdGlvbkRlc2M6IFwiRnVuY8ibaWEgZGUgRGlyZWPIm2llIEV1Y2xpZGlhbsSDIGNhbGN1bGVhesSDLCBwZW50cnUgZmllY2FyZSBjZWx1bMSDLCBkaXJlY8ibaWEgcMOibsSDIGxhIGNlYSBtYWkgYXByb3BpYXTEgyBzdXJzxIMsIMOubiBncmFkZS4gPGRpdj48YnIvPkRpcmVjyJtpYSBlc3RlIGNhbGN1bGF0xIMgZGUgbGEgY2VudHJ1bCBmaWVjxINyZWkgY2VsdWxlIHDDom7EgyBsYSBjZW50cnVsIGNlbHVsZWkgc3Vyc8SDIGNhcmUgc2UgYWZsxIMgY2VsIG1haSBhcHJvYXBlIGRlIGFjZWFzdGEuIEdhbWEgZGUgdmFsb3JpIGVzdGUgZGUgbGEgMCBncmFkZSBsYSAzNjAgZ3JhZGUsIGN1IDAgcmV6ZXJ2YXQgcGVudHJ1IGNlbHVsZWxlIHN1cnPEgy4gU3ByZSBFc3QgKGRyZWFwdGEpIGVzdGUgOTAgaWFyIHZhbG9hcmVhIGNyZciZdGUgw65uIHNlbnMgb3JhciAoMTgwIGVzdGUgc3VkdWwsIDI3MCBlc3RlIHZlc3R1bCBpYXIgMzYwIGVzdGUgbm9yZHVsKS48L2Rpdj5cIixcblx0XHRldWNEaXN0YW5jZU5hbWU6IFwiRGlzdGFuyJvEgyBFdWNsaWRpYW7Eg1wiLFxuXHRcdGV1Y0Rpc3RhbmNlU25pcDogXCJDYWxjdWxlYXrEgywgcGVudHJ1IGZpZWNhcmUgY2VsdWzEgywgZGlzdGFuyJthIGV1Y2xpZGlhbsSDIHDDom7EgyBsYSBjZWEgbWFpIGFwcm9waWF0xIMgc3Vyc8SDLlwiLFxuXHRcdGV1Y0Rpc3RhbmNlRGVzYzogXCJGdW5jyJtpYSBkZSBEaXN0YW7Im8SDIEV1Y2xpZGlhbsSDIGNhbGN1bGVhesSDLCBwZW50cnUgZmllY2FyZSBjZWx1bMSDLCBkaXN0YW7Im2EgcMOibsSDIGxhIGNlYSBtYWkgYXByb3BpYXTEgyBzdXJzxIMuXCIsXG5cdFx0ZXhwMTBOYW1lOiBcIkV4cDEwXCIsXG5cdFx0ZXhwMTBTbmlwOiBcIkNhbGN1bGVhesSDIGV4cG9uZW7Im2lhbHVsIMOubiBiYXrEgyAxMCBhIGNlbHVsZWxvciBkaW50ci11biByYXN0ZXIuXCIsXG5cdFx0ZXhwMTBEZXNjOiBcIkZ1bmPIm2lhIEV4cCAxMCBjYWxjdWxlYXrEgyBmdW5jyJtpYSBleHBvbmVuyJtpYWzEgyDDrm4gYmF6xIMgMTAgYSBwaXhlbGlsb3IgZGludHItdW4gcmFzdGVyLlwiLFxuXHRcdGV4cDJOYW1lOiBcIkV4cDJcIixcblx0XHRleHAyU25pcDogXCJDYWxjdWxlYXrEgyBleHBvbmVuyJtpYWx1bCDDrm4gYmF6xIMgMiBhbCBjZWx1bGVsb3IgZGludHItdW4gcmFzdGVyLlwiLFxuXHRcdGV4cDJEZXNjOiBcIkFjZWFzdMSDIGZ1bmPIm2llIGNhbGN1bGVhesSDIGZ1bmPIm2lhIGV4cG9uZW7Im2lhbMSDIMOubiBiYXrEgyAyIGEgcGl4ZWxpbG9yIGRpbnRyLXVuIHJhc3Rlci5cIixcblx0XHRleHBOYW1lOiBcIkV4cFwiLFxuXHRcdGV4cFNuaXA6IFwiQ2FsY3VsZWF6xIMgZXhwb25lbsibaWFsdWwgw65uIGJhesSDIGUgYWwgY2VsdWxlbG9yIGRpbnRyLXVuIHJhc3Rlci5cIixcblx0XHRleHBEZXNjOiBcIkFjZWFzdMSDIGZ1bmPIm2llIGNhbGN1bGVhesSDIGZ1bmPIm2lhIGV4cG9uZW7Im2lhbMSDIMOubiBiYXrEgyBlIGEgcGl4ZWxpbG9yIGRpbnRyLXVuIHJhc3Rlci5cIixcblx0XHRleHRyYWN0QmFuZE5hbWU6IFwiRXh0cmFnZXJlYSBCZW56aWxvclwiLFxuXHRcdGV4dHJhY3RCYW5kU25pcDogXCJTcGVjaWZpY8SDIGJlbnppbGUgY3UgY2FyZSBzZSB2YSBsdWNyYSBsYSB1dGlsaXphcmVhIHNldHVyaWxvciBkZSBkYXRlIGN1IGJlbnppIG11bHRpcGxlLlwiLFxuXHRcdGV4dHJhY3RCYW5kRGVzYzogXCIgRnVuY8ibaWEgZGUgRXh0cmFnZXJlIGEgQmVuemlsb3IgdsSDIHBlcm1pdGUgc8SDIGV4dHJhZ2XIm2kgdW5hIHNhdSBtYWkgbXVsdGUgYmVuemkgc2F1IHPEgyByZW9yZG9uYcibaSBiZW56aWxlIMOubnRyLXVuIHNldCBkZSBkYXRlIHJhc3RlciBjdSBiZW56aSBtdWx0aXBsZS48ZGl2Pjxici8+UHV0ZcibaSBmb2xvc2kgZnVuY8ibaWEgZGUgRXh0cmFnZXJlIEJlbnppIMOubmFpbnRlYSBhbHRvciBmdW5jyJtpaSwgY3VtIGFyIGZpIEFyaXRtZXRpY2EsIHBlbnRydSBhIGNvbnRyb2xhIGNhcmUgZGludHJlIGJlbnppIHN1bnQgZm9sb3NpdGUgY2EgaW50cmFyZSDDrm4gZnVuY8ibaWEgdXJtxIN0b2FyZS48L2Rpdj5cIixcblx0XHRmaWxsTmFtZTogXCJVbXBsZXJlXCIsXG5cdFx0ZmlsbFNuaXA6IFwiVW1wbGUgZG9saW5lbGUgw65udHItdW4gcmFzdGVyIGRlIHN1cHJhZmHIm8SDIHBlbnRydSBlbGltaW5hcmVhIHVub3IgbWljaSBpbXBlcmZlY8ibaWkgYWxlIGRhdGVsb3IuXCIsXG5cdFx0ZmlsbERlc2M6IFwiRnVuY8ibaWEgZGUgVW1wbGVyZSBnbG9iYWzEgyBsb2NhbGl6ZWF6xIMgyJlpIHVtcGxlIGRvbGluZSDImWkgdsOicmZ1cmkgw65udHItdW4gcmFzdGVyIGRlIHN1cHJhZmHIm8SDIGRlIGVsZXZhyJtpZSBwZW50cnUgYSBlbGltaW5hIG1pY2lsZSBpbXBlcmZlY8ibaWkgYWxlIGRhdGVsb3IuIEZ1bmPIm2lhIHZhIGNvbXBsZXRhIMOubnRyLXVuIHByb2NlcyByZXBldGl0aXYgcMOibsSDIGxhIHVtcGxlcmVhIHR1dHVyb3IgZG9saW5lbG9yIGRpbiBjYWRydWwgbGltaXRlaSBaIHNwZWNpZmljYXRlLjxkaXY+PGJyLz5BdHVuY2kgY8OibmQgc3VwcmFmYcibYSBkZSBlbGV2YcibaWUgZXN0ZSBjcmVhdMSDIGN1IGluc3RydW1lbnRlbGUgT3J0aG8gTWFwcGluZyBzYXUgY3UgYWx0ZSBtaWpsb2FjZSwgZXhpc3TEgyBhZGVzZWEgZXJvcmkgbWljaSwgZGFyIHNlbW5pZmljYXRpdmUsIHN1YiBmb3JtYSBkb2xpbmVsb3IgyJlpIHbDonJmdXJpbG9yIGRpbiBjYWRydWwgZGF0ZWxvci4gw45uIGZvdG9ncmFtZXRyaWUsIGRvbGluZWxlIMiZaSB2w6JyZnVyaWxlIHN1bnQgbWVuyJtpb25hdGUgYWRlc2VhIGNhIGfEg3VyaSDImWkgdsOicmZ1cmkuIERhdG9yaXTEgyBmYXB0dWx1aSBjxIMgZGF0ZWxlIGRlIHN1cHJhZmHIm8SDIHN1bnQgZm9sb3NpdGUgYWRlc2VhIMOubiBtb2RlbGFyZSwgY3VtIGFyIGZpIG1vZGVsYXJlYSBoaWRyb2xvZ2ljxIMsIGVzdGUgaW1wb3J0YW50IHPEgyBzZSBjb3JlY3RlemUgYWNlc3RlIGVyb3JpIGRlIGRvbGluZSDImWkgdsOicmZ1cmkgw65udHItdW4gbW9kIGNvbnNlY3ZlbnQgZGF0ZWxvciDDrm5jb25qdXLEg3RvYXJlLjwvZGl2PlwiLFxuXHRcdGZsb2F0TmFtZTogXCJNb2JpbFwiLFxuXHRcdGZsb2F0U25pcDogXCJUcmFuc2Zvcm3EgyBmaWVjYXJlIHZhbG9hcmUgYSBjZWx1bGVpIHVudWkgcmFzdGVyIMOubnRyLW8gcmVwcmV6ZW50YXJlIGEgcHVuY3R1bHVpIGZsb3RhbnQuXCIsXG5cdFx0ZmxvYXREZXNjOiBcIkZ1bmPIm2lhIGRlIEZsb3RhcmUgdHJhbnNmb3JtxIMgZmllY2FyZSB2YWxvYXJlIGEgcGl4ZWx1bHVpIHVudWkgcmFzdGVyIMOubnRyLW8gcmVwcmV6ZW50YXJlIGEgcHVuY3R1bHVpIGZsb3RhbnQuXCIsXG5cdFx0Zmxvd0FjY3VtdWxhdGlvbk5hbWU6IFwiQWN1bXVsYXJlYSBmbHV4dWx1aVwiLFxuXHRcdGZsb3dBY2N1bXVsYXRpb25TbmlwOiBcIkNyZWVhesSDIHVuIHJhc3RlciBkZSBmbHV4IGFjdW11bGF0IMOubiBmaWVjYXJlIGNlbHVsxIMuIFVuIGZhY3RvciBkZSBwb25kZXJlIHBvYXRlIGZpIGFwbGljYXQgw65uIG1vZCBvcMibaW9uYWwuXCIsXG5cdFx0Zmxvd0FjY3VtdWxhdGlvbkRlc2M6IFwiRnVuY8ibaWEgZ2xvYmFsxIMgZGUgQWN1bXVsYXJlIGEgRmx1eHVsdWkgY3JlZWF6xIMgdW4gcmFzdGVyIGRlIGZsdXggYWN1bXVsYXQgw65uIGZpZWNhcmUgcGl4ZWwsIGNvbmZvcm0gY2Vsb3IgZGV0ZXJtaW5hdGUgcHJpbiBhY3VtdWxhcmVhIGdyZXV0xIPIm2lpIHR1dHVyb3IgcGl4ZWxpbG9yIGNhcmUgY3VyZyDDrm4gZmllY2FyZSBwaXhlbCBhbCBwYW50ZWkgZGUgY29ib3LDonJlLiBEYWPEgyBudSBzZSBwdW5lIGxhIGRpc3BvemnIm2llIG5pY2l1biByYXN0ZXIgZGUgcG9uZGVyZSwgbyBwb25kZXJlIGRlIDEgc2UgYXBsaWPEgyBmaWVjxINydWkgcGl4ZWwsIGlhciB2YWxvYXJlYSBwaXhlbGlsb3IgZGluIHJhc3RlcnVsIGRlIGllyJlpcmUgZXN0ZSBudW3Eg3J1bCBkZSBwaXhlbGkgY2FyZSBjdXJnIMOubiBmaWVjYXJlIHBpeGVsLjxkaXY+PGJyLz5QaXhlbGlpIGRlIGllyJlpcmUgY3UgbyBhY3VtdWxhcmUgZGUgZmx1eCByaWRpY2F0xIMgcmVwcmV6aW50xIMgem9uZWxlIGRlIGZsdXggY29uY2VudHJhdCDImWkgcG90IGZpIGZvbG9zaXRlIHBlbnRydSBpZGVudGlmaWNhcmVhIGNhbmFsZWxvciBkZSBjdXJzLiBQaXhlbGlpIGRlIGllyJlpcmUgY3UgbyBhY3VtdWxhcmUgZGUgZmx1eCB6ZXJvIHN1bnQgdmFsb3JpIHRvcG9ncmFmaWNlIGxvY2FsZSByaWRpY2F0ZSDImWkgcG90IGZpIGZvbG9zaXRlIHBlbnRydSBpZGVudGlmaWNhcmVhIGNyZXN0ZWxvci48L2Rpdj5cIixcblx0XHRmbG93RGlyZWN0aW9uTmFtZTogXCJEaXJlY8ibaWEgZmx1eHVsdWlcIixcblx0XHRmbG93RGlyZWN0aW9uU25pcDogXCJDcmVlYXrEgyB1biByYXN0ZXIgZGUgZGlyZWPIm2llIGEgZmx1eHVsdWkgZGluIGZpZWNhcmUgY2VsdWzEgyBww6JuxIMgbGEgdmVjaW51bCBzxIN1IGRlIHBlIHBhbnRhIGNlYSBtYWkgYWJydXB0xIMuXCIsXG5cdFx0Zmxvd0RpcmVjdGlvbkRlc2M6IFwiVW5hIGRpbnRyZSBjaGVpbGUgZGVyaXbEg3JpaSBjYXJhY3RlcmlzdGljaWxvciBoaWRyb2xvZ2ljZSBhbGUgdW5laSBzdXByYWZlyJtlIG8gcmVwcmV6aW50xIMgY2FwYWNpdGF0ZWEgZGUgc3RhYmlsaXJlIGEgZGlyZWPIm2llaSBmbHV4dWx1aSBkaW4gZmllY2FyZSBwaXhlbCBkaW4gcmFzdGVyLiBGdW5jyJtpYSByYXN0ZXJ1bHVpIERpcmVjyJtpZWkgZGUgRmx1eCBpYSBvIHN1cHJhZmHIm8SDIGRyZXB0IGludHJhcmUgyJlpIGNyZWVhesSDIHVuIHJhc3RlciBhbCBkaXJlY8ibaWVpIGRlIGZsdXggZGUgbGEgZmllY2FyZSBwaXhlbCBjxIN0cmUgdmVjaW51bCBkZSBwZSBwYW50YSBkZSBjb2JvcsOicmUgY2VhIG1haSBhYnJ1cHTEgy4gRnVuY8ibaWEgZGUgRGlyZWPIm2llIGEgRmx1eHVsdWkgc3Vwb3J0xIMgdHJlaSBtZXRvZGUgZGUgbW9kZWxhcmUgYSBmbHV4dWx1aTogRDggKG9wdCBkaXJlY8ibaWkpLCBkaXJlY8ibaWUgbXVsdGlwbMSDIGEgZmx1eHVsdWkgKE1GRCkgyJlpIEQtSW5maW5pdCAoRElORikuIFwiLFxuXHRcdGZsb3dEaXN0YW5jZU5hbWU6IFwiRGlzdGFuyJthIEZsdXh1bHVpXCIsXG5cdFx0Zmxvd0Rpc3RhbmNlU25pcDogXCJDYWxjdWxlYXrEgywgcGVudHJ1IGZpZWNhcmUgY2VsdWzEgywgZGlzdGFuyJthIG1pbmltxIMgb3Jpem9udGFsxIMgc2F1IHZlcnRpY2FsxIMgYSBwYW50ZWkgZGUgY29ib3LDonJlIGPEg3RyZSBjZWx1bGVsZSBkZSBwZSB1biBjdXJzIGRlIGFwxIMgc2F1IHLDonUgw65uIGNhcmUgY3VyZy5cIixcblx0XHRmbG93RGlzdGFuY2VEZXNjOiBcIlBlbnRydSBmaWVjYXJlIHBpeGVsLCBmdW5jyJtpYSB2YSBjYWxjdWxhIGRpc3RhbsibYSBvcml6b250YWzEgyBzYXUgdmVydGljYWzEgyBhIHBhbnRlaSBkZSBjb2JvcsOicmUgY8SDdHJlIHBpeGVsKGkpIHBlIHVuIHLDonUgc2F1IGN1cnMgZGUgYXDEgyDDrm4gY2FyZSBjdXJnIGFjZciZdGlhLiBEYWPEgyBlc3RlIHB1cyBsYSBkaXNwb3ppyJtpZSB1biByYXN0ZXIgb3DIm2lvbmFsIGRlIGRpcmVjyJtpZSBhIGZsdXh1bHVpLCBkaXJlY8ibaWEoaWlsZSkgcGFudGVpIGRlIGNvYm9yw6JyZSB2YSBmaSBsaW1pdGF0xIMgbGEgY2VsZSBkZWZpbml0ZSBkZSByYXN0ZXJ1bCBkZSBkaXJlY8ibaWUgYSBmbHV4dWx1aSBkZSBpbnRyYXJlLiBJZciZaXJlYSBlc3RlIHVuIHJhc3RlciBkZSBkaXN0YW7Im8SDIGEgZmx1eHVsdWkuXCIsXG5cdFx0Zm9jYWxOYW1lOiBcIlN0YXRpc3RpY8SDIEZvY2FsxINcIixcblx0XHRmb2NhbFNuaXA6IFwiQ2FsY3VsZWF6xIMgc3RhdGlzdGljYSBmb2NhbMSDIHBlbnRydSBmaWVjYXJlIHBpeGVsIGEgdW5laSBpbWFnaW5pIGJhemF0ZSBwZSBvIHZlY2luxIN0YXRlIGZvY2FsxIMgZGVmaW5pdMSDLlwiLFxuXHRcdGZvY2FsRGVzYzogXCJGdW5jyJtpYSBkZSBTdGF0aXN0aWPEgyBGb2NhbMSDIGNhbGN1bGVhesSDIHN0YXRpc3RpY2EgZm9jYWzEgyBwZW50cnUgZmllY2FyZSBwaXhlbCBhIHVuZWkgaW1hZ2luaSBiYXphdGUgcGUgbyB2ZWNpbsSDdGF0ZSBmb2NhbMSDIGRlZmluaXTEgy5cIixcblx0XHRnZW9tZXRyaWNOYW1lOiBcIlpvbmUgZ2VvbWV0cmljZVwiLFxuXHRcdGdlb21ldHJpY1NuaXA6IFwiQ3JlyJl0ZSBwcmVjaXppYSBwb3ppyJtpb25hbMSDIGEgdW51aSBzZXQgZGUgZGF0ZSBwcmluIGNvbnRhYmlsaXphcmVhIGVsZXZhyJtpZWkuXCIsXG5cdFx0Z2VvbWV0cmljRGVzYzogXCJGdW5jyJtpYSBnZW9tZXRyaWPEgyBwcm9kdWNlIG8gaW1hZ2luZSBvcnRvcmVjdGlmaWNhdMSDIHBlIGJhemEgdW5laSBkZWZpbmnIm2lpIGEgc2Vuem9yaWxvciDImWkgYSB1bnVpIG1vZGVsIGRlIHRlcmVuLiBDcmXImXRlIHByZWNpemlhIHBvemnIm2lvbmFsxIMgYSB1bnVpIHNldCBkZSBkYXRlIHByaW4gY29udGFiaWxpemFyZWEgZWxldmHIm2llaS5cIixcblx0XHRncmF5c2NhbGVOYW1lOiBcIlNjYXLEgyBncmlcIixcblx0XHRncmF5c2NhbGVTbmlwOiBcIlRyYW5zZm9ybcSDIG8gaW1hZ2luZSBjdSBiZW56aSBtdWx0aXBsZSDDrm50ci1vIGltYWdpbmUgcGUgc2NhcsSDIGdyaSBjdSBvIHNpbmd1csSDIGJhbmTEgy5cIixcblx0XHRncmF5c2NhbGVEZXNjOiBcIkFjZWFzdMSDIGZ1bmPIm2llIHRyYW5zZm9ybcSDIG8gaW1hZ2luZSBjdSBiZW56aSBtdWx0aXBsZSDDrm50ci1vIGltYWdpbmUgcGUgc2NhcsSDIGdyaSBjdSBvIHNpbmd1csSDIGJhbmTEgy48ZGl2Pjxici8+QWNlYXN0xIMgZnVuY8ibaWUgYXBsaWPEgyBwb25kZXJpIHNwZWNpZmljYXRlIGZpZWPEg3JlaWEgZGludHJlIGJlbnppbGUgZGUgaW50cmFyZSDImWkgbm9ybWFsaXplYXrEgyBpbWFnaW5lYSBkZSBpZciZaXJlLiBQb25kZXJpbGUgc3VudCBhZGVzZWEgYXBsaWNhdGUgZGVvYXJlY2UgdW5lbGUgYmVuemkgYXUgbyBpbXBvcnRhbsibxIMgdmFyaWFiaWzEgyDDrm4gZnVuY8ibaWUgZGUgYXBsaWNhyJtpZS4gRGUgZXhlbXBsdSwgYmFuZGEgYWxiYXN0csSDIGNvbsibaW5lIGFkZXNlYSBtYWkgbXVsdCB6Z29tb3QgZGVjw6J0IGNlbGVsYWx0ZSBiZW56aS48L2Rpdj5cIixcblx0XHRncmVhdGVyVGhhbkVxdWFsTmFtZTogXCJNYWkgbWFyZSBkZWPDonQgZWdhbFwiLFxuXHRcdGdyZWF0ZXJUaGFuRXF1YWxTbmlwOiBcIkVmZWN0dWVhesSDIG8gb3BlcmHIm2llIGRlIGVnYWxpemFyZSByZWxhyJtpb25hbMSDIG1haSBtYXJlIGRlY8OidCBlZ2FsIGN1IHBlIGRvdcSDIGludHLEg3JpIGRlIGxhIG8gY2VsdWzEgyBsYSBhbHRhLiBSZXR1cm5lYXrEgyAxIHBlbnRydSBjZWx1bGVsZSB1bmRlIHByaW11bCByYXN0ZXIgZXN0ZSBtYWkgbWFyZSBkZWPDonQgc2F1IGVnYWwgY3UgYWwgZG9pbGVhIHJhc3RlciDImWkgMCBkYWPEgyBudSBlc3RlLlwiLFxuXHRcdGdyZWF0ZXJUaGFuRXF1YWxEZXNjOiBcIkZ1bmPIm2lhIGVmZWN0dWVhesSDIG8gb3BlcmHIm2llIHJlbGHIm2lvbmFsxIMgbWFpIG1hcmUgc2F1IGVnYWzEgyBjdSBwZSBkb3XEgyBpbnRyxINyaSBwaXhlbCBjdSBwaXhlbC4gQWNlYXN0YSByZXR1cm5lYXrEgyBvIHZhbG9hcmUgZGUgMSBwZW50cnUgcGl4ZWxpaSB1bmRlIHByaW11bCByYXN0ZXIgZXN0ZSBtYWkgbWFyZSBkZWPDonQgc2F1IGVnYWwgY3UgYWwgZG9pbGVhIHJhc3RlciDImWkgbyB2YWxvYXJlIGRlIDAgcGVudHJ1IHBpeGVsaSB1bmRlIHByaW11bCByYXN0ZXIgbnUgZXN0ZSBtYWkgbWFyZSBkZWPDonQgc2F1IGVnYWwgY3UgYWwgZG9pbGVhIHJhc3Rlci5cIixcblx0XHRncmVhdGVyVGhhbk5hbWU6IFwiTWFpIG1hcmUgZGVjw6J0XCIsXG5cdFx0Z3JlYXRlclRoYW5TbmlwOiBcIkVmZWN0dWVhesSDIG8gb3BlcmHIm2llIHJlbGHIm2lvbmFsxIMgbWFpIG1hcmUgZGVjw6J0IHBlIGRvdcSDIGludHLEg3JpIGRlIGxhIG8gY2VsdWzEgyBsYSBhbHRhLiBSZXR1cm5lYXrEgyB2YWxvYXJlYSAxIHBlbnRydSBjZWx1bGVsZSB1bmRlIHByaW11bCByYXN0ZXIgZXN0ZSBtYWkgbWFyZSBkZWPDonQgY2VsIGRlLWFsIGRvaWxlYSByYXN0ZXIgyJlpIDAgcGVudHJ1IGNlbHVsZWxlIHVuZGUgYWNlc3RlYSBudSBzdW50IGVnYWxlLlwiLFxuXHRcdGdyZWF0ZXJUaGFuRGVzYzogXCJGdW5jyJtpYSBlZmVjdHVlYXrEgyBvIG9wZXJhyJtpZSByZWxhyJtpb25hbMSDIG1haSBtYXJlIGRlY8OidCBzYXUgZWdhbMSDIGN1IHBlIGRvdcSDIGludHLEg3JpIHBpeGVsIGN1IHBpeGVsLiBSZXR1cm5lYXrEgyBvIHZhbG9hcmUgZGUgMSBwZW50cnUgcGl4ZWxpaSB1bmRlIHByaW11bCByYXN0ZXIgZXN0ZSBtYWkgbWFyZSBkZWPDonQgYWwgZG9pbGVhIHJhc3RlciDImWkgbyB2YWxvYXJlIGRlIDAgcGVudHJ1IHBpeGVsaSB1bmRlIHByaW11bCByYXN0ZXIgbnUgZXN0ZSBtYWkgbWFyZSBkZWPDonQgYWwgZG9pbGVhIHJhc3Rlci5cIixcblx0XHRoZWF0SW5kZXhOYW1lOiBcIkluZGV4IGPEg2xkdXLEg1wiLFxuXHRcdGhlYXRJbmRleFNuaXA6IFwiQ29tYmluxIMgdGVtcGVyYXR1cmEgYWVydWx1aSBhbWJpZW50YWwgyJlpIHVtaWRpdGF0ZWEgcmVsYXRpdsSDIHBlbnRydSBhIGFmbGEgdGVtcGVyYXR1cmEgYXBhcmVudMSDLlwiLFxuXHRcdGhlYXRJbmRleERlc2M6IFwiQWNlYXN0xIMgZnVuY8ibaWUgY2FsY3VsZWF6xIMgdGVtcGVyYXR1cmEgYXBhcmVudMSDIHBlIGJhemEgdGVtcGVyYXR1cmlpIGFtYmllbnRlIMiZaSB1bWlkaXTEg8ibaWkgcmVsYXRpdmUuIFRlbXBlcmF0dXJhIGFwYXJlbnTEgyBlc3RlIGFkZXNlYSBkZXNjcmlzxIMgY2EgZmlpbmQgY8OidCBkZSBjYWxkIHNlIHNpbXRlIHBlbnRydSBjb3JwdWwgdW1hbi48ZGl2Pjxici8+QWNlc3QgaW5kaWNlIHBvYXRlIGZpIHV0aWwgcGVudHJ1IGNhbGN1bGFyZWEgcGVyaWNvbGVsb3IgYWZlcmVudGUgcHJvYmxlbWVsb3IgbWVkaWNhbGUgY3VtIGFyIGZpIGNyYW1wZWxlIG11c2N1bGFyZSwgZGVzaGlkcmF0YXJlYSwgZXB1aXphcmVhIGRpbiBjYXV6YSBjxINsZHVyaWkgc2F1IGluc29sYcibaWEgbWFpIGdyYXbEgyDDrm4gemlsZWxlIGNhbGRlIMiZaSB1bWVkZS4gQXR1bmNpIGPDom5kIHVtaWRpdGF0ZWEgcmVsYXRpdsSDIGVzdGUgcmlkaWNhdMSDLCBkZXZpbmUgZGluIGNlIMOubiBjZSBtYWkgZ3JldSBwZW50cnUgdHJhbnNwaXJhyJtpYSBjb3Jwb3JhbMSDIHPEgyBzZSBldmFwb3JlLCBsxINzw6JuZCBwZXJzb2FuZWxlIGbEg3LEgyBvIG1vZGFsaXRhdGUgZGUgcsSDY29yaXJlIG5hdHVyYWzEgyDImWkgZWZpY2llbnTEgy4gSMSDcsibaWxlIGN1IGluZGljYcibaWlsZSDImWkgYXZlcnRpesSDcmlsZSBwcml2aW5kIGPEg2xkdXJhIHN1bnQgYWRlc2VhIHByb2R1c3VsIHJlY2xhc2lmaWPEg3JpaSByZXp1bHRhdHVsdWkgaW5kaWNlbHVpIHRlcm1pYyDDrm4gY2xhc2UsIGFjb2xvIHVuZGUgY3UgY8OidCBlc3RlIG1haSBtYXJlIHZhbG9hcmVhIGluZGljZWx1aSwgY3UgYXTDonQgZXN0ZSBtYWkgcHJvYmFiaWwgc8SDIGRldmluxIMgbyBhdmVydGl6YXJlIGRlY8OidCBvIHNpbXBsxIMgaW5kaWNhyJtpZS48L2Rpdj5cIixcblx0XHRoaWxsc2hhZGVOYW1lOiBcIkVmZWN0IGRlIHVtYnLEg1wiLFxuXHRcdGhpbGxzaGFkZVNuaXA6IFwiQ3JlZWF6xIMgbyByZXByZXplbnRhcmUgM0QgYSBzdXByYWZlyJtlaSwgY3UgcG96acibaWEgcmVsYXRpdsSDIGEgc29hcmVsdWkgbHVhdMSDIMOubiBjb25zaWRlcmFyZSBwZW50cnUgaGHImXVyYXJlYSBpbWFnaW5paVwiLFxuXHRcdGhpbGxzaGFkZURlc2M6IFwiRnVuY8ibaWEgSGlsbHNoYWRlIHByb2R1Y2UgbyByZXByZXplbnRhcmUgcGUgc2NhcsSDIGdyaSAzRCBhIHN1cHJhZmXIm2VpIHRlcmVudWx1aSwgY3UgcG96acibaWEgcmVsYXRpdsSDIGEgc29hcmVsdWkgbHVhdMSDIMOubiBjb25zaWRlcmFyZSBwZW50cnUgaGHImXVyYXJlYSBpbWFnaW5paS4gPGRpdj48YnIvPkhhyJl1cmFyZWEgZXN0ZSBvIHRlaG5pY8SDIGRlIHZpenVhbGl6YXJlIGEgdGVyZW51bHVpIGRldGVybWluYXTEgyBkZSBvIHN1cnPEgyBkZSBsdW1pbsSDIMiZaSBkZSBwYW50YSDImWkgYXNwZWN0dWwgc3VwcmFmZcibZWkgZWxldmHIm2llaS4gQWNlYXN0YSBlc3RlIG8gbWV0b2TEgyBjYWxpdGF0aXbEgyBkZSB2aXp1YWxpemFyZSBhIHRvcG9ncmFmaWVpIMiZaSBudSBvZmVyxIMgdmFsb3JpIGRlIGVsZXZhcmUgYWJzb2x1dGUuIDwvZGl2PlwiLFxuXHRcdGludE5hbWU6IFwiSW50XCIsXG5cdFx0aW50U25pcDogXCJUcmFuc2Zvcm3EgyBmaWVjYXJlIHZhbG9hcmUgYSBjZWx1bGVpIHVudWkgcmFzdGVyIMOubnRyLXVuIMOubnRyZWcgcHJpbiByZWR1Y2VyZS5cIixcblx0XHRpbnREZXNjOiBcIkZ1bmPIm2lhIEludCB0cmFuc2Zvcm3EgyBmaWVjYXJlIHZhbG9hcmUgYSBwaXhlbHVsdWkgdW51aSByYXN0ZXIgw65udHItdW4gw65udHJlZyBwcmluIHJlZHVjZXJlLlwiLFxuXHRcdGludGVycG9sYXRlSXJyZWd1bGFyRGF0YU5hbWU6IFwiSW50ZXJwb2xhcmVhIGRhdGVsb3IgbmVyZWd1bGF0ZVwiLFxuXHRcdGludGVycG9sYXRlSXJyZWd1bGFyRGF0YVNuaXA6IFwiSW50ZXJwb2xlYXrEgyBkaW4gbm9yaSBkZSBwdW5jdGUgc2F1IGdyaWxlIG5lcmVndWxhdGUuXCIsXG5cdFx0aW50ZXJwb2xhdGVJcnJlZ3VsYXJEYXRhRGVzYzogXCJVbmVsZSBzZXR1cmkgZGUgZGF0ZSBuZXRDREYgc2F1IEhERiDDrsiZaSBzdG9jaGVhesSDIGdlb2xvY2FyZWEgc3ViIGZvcm1hIHVub3IgyJlpcnVyaSBhyJllemF0ZSBsYSBkaXN0YW7Im2UgbmVyZWd1bGF0ZSBkZSBwaXhlbGkgc2F1IGRhdGUgZGUgcHVuY3RlLiBMYSBhZMSDdWdhcmVhIGFjZXN0b3Igc2V0dXJpIGRlIGRhdGUgw65udHItdW4gc2V0IGRlIGRhdGUgbW96YWljLCBmdW5jyJtpYSBkZSBpbnRlcnBvbGFyZSBhIGRhdGVsb3IgbmVyZWd1bGF0ZSBpYSBkYXRlbGUgaW50cm9kdXNlIG5lcmVndWxhdCDDrm4gZ3JpbMSDIMiZaSByZWNvbGVjdGVhesSDIHByb2JlbGUgYXN0ZmVsIMOubmPDonQgZmllY2FyZSBwaXhlbCBzxIMgYWlixIMgZGltZW5zaXVuZSB1bmlmb3JtxIMgyJlpIHPEgyBmaWUgcMSDdHJhdC48ZGl2Pjxici8+TGEgYWTEg3VnYXJlYSB2YXJpYWJpbGVsb3IgZGluIG5ldENERiBzYXUgSERGIMOubnRyLXVuIHNldCBkZSBkYXRlIG1vemFpYywgYWNlc3RhIHZhIHZlcmlmaWNhIMOubiBtb2QgYXV0b21hdCBkYWPEgyBkYXRlbGUgc3VudCBkaXNwdXNlIF1uIMiZaXJ1cmkgcmVndWxhdGUuIMOObiBjYXogY29udHJhciwgZnVuY8ibaWEgZGUgaW50ZXJwb2xhcmUgYSBkYXRlbG9yIG5lcmVndWxhdGUgcG9hdGUgZmkgZm9sb3NpdMSDIHBlbnRydSBhIHRyYW5zZm9ybWEgZGF0ZWxlIG5lcmVndWxhdGUgw65udHItdW4gcmFzdGVyIGN1IGdyaWzEgyByZWd1bGF0xIMuIFB1dGXIm2kgbW9kaWZpY2EgbWV0b2RhIGRlIGludGVycG9sYXJlIMiZaSBkaW1lbnNpdW5lYSBjZWx1bGVpIGZvbG9zaXRlIMOubiBmdW5jyJtpYSBkZSBpbnRlcnBvbGFyZSBhIHJhc3RlcnVsdWkgZGF0ZWxvciBuZXJlZ3VsYXRlLiBQZW50cnUgZGF0ZWxlIGN1IHJhc3RlciBjdSBkaXN0YW7Im8SDIHJlZ3VsYXTEgywgbnUgc2UgdmEgYXBsaWNhIGludGVycG9sYXJlYSBpYXIgZGF0ZWxlIHZvciBmaSBjaXRpdGUgYciZYSBjdW0gc3VudC48L2Rpdj5cIixcblx0XHRpc051bGxOYW1lOiBcIkVzdGUgbnVsXCIsXG5cdFx0aXNOdWxsU25pcDogXCJTdGFiaWxlyJl0ZSBjYXJlIHZhbG9yaSBkaW4gcmFzdGVydWwgZGUgaW50cmFyZSBzdW50IE5vRGF0YSBkZSBsYSBvIGNlbHVsxIMgbGEgYWx0YS4gUmV0dXJuZWF6xIMgbyB2YWxvYXJlIGRlIDEgZGFjxIMgdmFsb2FyZWEgZGUgaW50cmFyZSBlc3RlIE5vRGF0YSDImWkgMCBwZW50cnUgY2VsdWxlIGNhcmUgbnUgc3VudC5cIixcblx0XHRpc051bGxEZXNjOiBcIkZ1bmPIm2lhIEVzdGUgTnVsIHN0YWJpbGXImXRlIGNhcmUgdmFsb3JpIGRpbiByYXN0ZXJ1bCBkZSBpbnRyYXJlIHN1bnQgTm9EYXRhIGRlIGxhIHVuIHBpeGVsIGxhIGFsdHVsLiBBY2Vhc3RhIHJldHVybmVhesSDIG8gdmFsb2FyZSBkZSAxIGRhY8SDIHZhbG9hcmVhIGRlIGludHJhcmUgZXN0ZSBOb0RhdGEgyJlpIG8gdmFsb2FyZSBkZSAwIHBlbnRydSBwaXhlbGkgY2FyZSBudSBzdW50IE5vRGF0YS5cIixcblx0XHRrZXJuZWxEZW5zaXR5TmFtZTogXCJLZXJuZWwgRGVuc2l0eVwiLFxuXHRcdGtlcm5lbERlbnNpdHlTbmlwOiBcIkNhbGN1bGVhesSDIG8gem9uxIMgZGUgbWFnbml0dWRpbmUgcGUgdW5pdGF0ZSBkaW4gb2JpZWN0ZWxlIHNwYcibaWFsZSBwdW5jdGUgc2F1IHBvbGlsaW5paSBmb2xvc2luZCBvIGZ1bmPIm2llIG51Y2xldSBwZW50cnUgYSBpbmNsdWRlIG8gc3VwcmFmYcibxIMgY29uaWPEgyBsaW7EgyDDrm4gZmllY2FyZSBwdW5jdCBzYXUgcG9saWxpbmllLlwiLFxuXHRcdGtlcm5lbERlbnNpdHlEZXNjOiBcIkFjZWFzdMSDIGZ1bmPIm2llIGNhbGN1bGVhesSDIG8gem9uxIMgZGUgbWFnbml0dWRpbmUgcGUgdW5pdGF0ZSBkaW4gb2JpZWN0ZWxlIHNwYcibaWFsZSBwdW5jdGUgc2F1IHBvbGlsaW5paSBmb2xvc2luZCBvIGZ1bmPIm2llIG51Y2xldSBwZW50cnUgYSBpbmNsdWRlIG8gc3VwcmFmYcibxIMgY29uaWPEgyBsaW7EgyDDrm4gZmllY2FyZSBwdW5jdCBzYXUgcG9saWxpbmllLlwiLFxuXHRcdGtleU1ldGFkYXRhTmFtZTogXCJNZXRhZGF0ZSBwcmluY2lwYWxlXCIsXG5cdFx0a2V5TWV0YWRhdGFTbmlwOiBcIlN1cHJhcmVnbGVhesSDIHNhdSBpbnRyb2R1Y2UgbWV0YWRhdGVsZSBwcmluY2lwYWxlIGFsZSB1bnVpIHJhc3RlciDDrm50ci11biBsYW7ImyBkZSBmdW5jyJtpaS5cIixcblx0XHRrZXlNZXRhZGF0YURlc2M6IFwiQWNlYXN0xIMgZnVuY8ibaWUgdsSDIHBlcm1pdGUgc8SDIGludHJvZHVjZcibaSBzYXUgc8SDIHN1cHJhcmVnbGHIm2kgbWV0YWRhdGVsZSBwcmluY2lwYWxlIGFsZSB1bnVpIHJhc3Rlci48ZGl2Pjxici8+SW5mb3JtYcibaWlsZSBkaW4gbWV0YWRhdGVsZSBwcmluY2lwYWxlIHN1bnQgZm9sb3NpdGUgcGVudHJ1IGEgYWp1dGEgYXBsaWNhyJtpYSBjdSBvIHBhcnRlIGRpbiBwcmVsdWNyYXJlIMiZaSByZWRhcmUsIGluY2x1c2l2IGZ1cm5pemFyZWEgdW5vciBpbmZvcm1hyJtpaSB1dGlsZSBjdW0gYXIgZmkgZGVudW1pcmVhIHNlbnpvcnVsdWksIGRlbnVtaXJpbGUgYmVuemlsb3Igc2F1IG5lYnVsb3ppdGF0ZWEgYXNvY2lhdMSDIGN1IGltYWdpbmlsZS48L2Rpdj5cIixcblx0XHRzaG9ydGVzdFBhdGhOYW1lOiBcIlRyYXNldWwgY3UgY2VsIG1haSBtaWMgY29zdFwiLFxuXHRcdHNob3J0ZXN0UGF0aFNuaXA6IFwiRWZlY3R1ZWF6xIMgbyBhbmFsaXrEgyBhIGRpc3RhbsibZWkgZGUgY29zdCBmb2xvc2luZCBpbnRyxINyaWxlIHN1cnNlaSDImWkgZGVzdGluYcibaWVpIGNhcmUgbWFpIGFwb2kgc3VudCBmb2xvc2l0ZSBwZW50cnUgYSBzdGFiaWxpIHRyYXNldWwgY3UgY29zdHVsIGNlbCBtYWkgbWljIGRpbnRyLW8gc3Vyc8SDIGPEg3RyZSBvIGRlc3RpbmHIm2llLlwiLFxuXHRcdHNob3J0ZXN0UGF0aERlc2M6IFwiRnVuY8ibaWEgVHJhc2V1bHVpIGN1IENlbCBNYWkgTWljIENvc3QgY2FsY3VsZWF6xIMgdHJhc2V1bCBjdSBjZWwgbWFpIG1pYyBjb3N0IGRpbnRyLW8gc3Vyc8SDIMiZaSBww6JuxIMgbGEgbyBkZXN0aW5hyJtpZS4gRGlzdGFuyJthIGN1IGNvc3R1bCBjZWwgbWFpIHB1yJtpbiBhY3VtdWxhdGl2IGVzdGUgY2FsY3VsYXTEgyBwZW50cnUgZmllY2FyZSBwaXhlbCBwZSBvIHN1cHJhZmHIm8SDIGEgY29zdHVsdWksIGPEg3RyZSBjZWEgbWFpIGFwcm9waWF0xIMgc3Vyc8SDLiBBY2Vhc3RhIHByb2R1Y2UgdW4gcmFzdGVyIGRlIGllyJlpcmUgY2FyZSDDrm5yZWdpc3RyZWF6xIMgdHJhc2V1bCBzYXUgdHJhc2VlbGUgY3UgY29zdHVsIGNlbCBtYWkgbWljLCBkaW4gbG9jYcibaWkgc2VsZWN0YXRlIHDDom7EgyBsYSBwaXhlbGlpIGRpbiBjZWEgbWFpIGFwcm9waWF0xIMgc3Vyc8SDIGRlZmluacibaSDDrm4gc3VwcmFmYcibYSBkZSBjb3N0IGFjdW11bGF0aXbEgywgY3UgcHJpdmlyZSBsYSBkaXN0YW7Im2EgZGUgY29zdC48ZGl2Pjxici8+RmllY8SDcnVpIHRyYXNldSBjdSBjb3N0dWwgY2VsIG1haSBtaWMgw65pIGVzdGUgYWxvY2F0xIMgbyB2YWxvYXJlIGF0dW5jaSBjw6JuZCBlc3RlIMOubnTDomxuaXQgw65uIGNhZHJ1bCBwcm9jZXN1bHVpIGRlIHNjYW5hcmUuIFBpeGVsdWwgZGUgc2bDonLImWl0IGRlIHBlIFJhc3RlcnVsIFN1cnPEgyBhbCB1bnVpIHRyYXNldSBkZSBjb3N0IHByaW1lyJl0ZSBvIHZhbG9hcmUgZGUgMS4gUHJpbXVsIHRyYXNldSBwcmltZciZdGUgbyB2YWxvYXJlIGRlIDMsIGFsIGRvaWxlYSA0IMiZaSBhyJlhIG1haSBkZXBhcnRlLiBBdHVuY2kgY8OibmQgbWFpIG11bHRlIHRyYXNlZSBjb252ZXJnIMiZaSB1cm1lYXrEgyBkaXN0YW7Im2EgcmVtYW5lbnTEgyDDrm5hcG9pIGPEg3RyZSBvIHN1cnPEgyBkZSBwZSBhY2VsYciZaSB0cmFzZXUsIHNlZ21lbnR1bCB1bmRlIGNlbGUgZG91xIMgdHJhc2VlIHNlIGRlcGxhc2VhesSDIMOubXByZXVuxIMgcHJpbWXImXRlIG8gdmFsb2FyZSBkZSAyLiBQb3LIm2l1bmlpIGZ1emlvbmF0ZSBhIHRyYXNldWx1aSBudSDDrmkgcG9hdGUgZmkgYWxvY2F0xIMgbyB2YWxvYXJlIGEgdW51aWEgZGludHJlIHRyYXNlZSwgYXbDom5kIMOubiB2ZWRlcmUgY8SDIHBvcsibaXVuZWEgZnV6aW9uYXTEgyBhcGFyyJtpbmUgYW1iZWxvciB0cmFzZWUuPC9kaXY+XCIsXG5cdFx0bGVzc1RoYW5FcXVhbE5hbWU6IFwiTWFpIG1pYyBkZWPDonQgZWdhbFwiLFxuXHRcdGxlc3NUaGFuRXF1YWxTbmlwOiBcIkVmZWN0dWVhesSDIG8gb3BlcmHIm2llIGRlIGVnYWxpemFyZSByZWxhyJtpb25hbMSDIG1haSBtaWPEgyBkZWPDonQgc2F1IGVnYWzEgyBjdSBwZSBkb3XEgyBpbnRyxINyaSBkZSBsYSBvIGNlbHVsxIMgbGEgYWx0YS4gUmV0dXJuZWF6xIMgMSBwZW50cnUgY2VsdWxlbGUgdW5kZSBwcmltdWwgcmFzdGVyIGVzdGUgbWFpIG1pYyBkZWPDonQgc2F1IGVnYWwgY3UgYWwgZG9pbGVhIHJhc3RlciDImWkgMCBhY29sbyB1bmRlIG51IGVzdGUuXCIsXG5cdFx0bGVzc1RoYW5FcXVhbERlc2M6IFwiRnVuY8ibaWEgZWZlY3R1ZWF6xIMgbyBvcGVyYcibaWUgcmVsYcibaW9uYWzEgyBtYWkgbWljxIMgc2F1IGVnYWzEgyBjdSBwZSBkb3XEgyBpbnRyxINyaSBwaXhlbCBjdSBwaXhlbC4gQWNlYXN0YSByZXR1cm5lYXrEgyBvIHZhbG9hcmUgZGUgMSBwZW50cnUgcGl4ZWxpaSB1bmRlIHByaW11bCByYXN0ZXIgZXN0ZSBtYWkgbWljIGRlY8OidCBzYXUgZWdhbCBjdSBhbCBkb2lsZWEgcmFzdGVyIMiZaSBvIHZhbG9hcmUgZGUgMCB1bmRlIHByaW11bCByYXN0ZXIgbnUgZXN0ZSBtYWkgbWljIGRlY8OidCBzYXUgZWdhbCBjdSBhbCBkb2lsZWEgcmFzdGVyLlwiLFxuXHRcdGxlc3NUaGFuTmFtZTogXCJNYWkgbWljIGRlY8OidFwiLFxuXHRcdGxlc3NUaGFuU25pcDogXCJFZmVjdHVlYXrEgyBvIG9wZXJhyJtpZSByZWxhyJtpb25hbMSDIG1haSBtaWPEgyBkZWPDonQgcGUgZG91xIMgaW50csSDcmkgZGUgbGEgbyBjZWx1bMSDIGxhIGFsdGEuIFJldHVybmVhesSDIDEgcGVudHJ1IGNlbHVsZWxlIHVuZGUgcHJpbXVsIHJhc3RlciBlc3RlIG1haSBtaWMgZGVjw6J0IGFsIGRvaWxlYSByYXN0ZXIgyJlpIDAgZGFjxIMgbnUgZXN0ZS5cIixcblx0XHRsZXNzVGhhbkRlc2M6IFwiRnVuY8ibaWEgZWZlY3R1ZWF6xIMgbyBvcGVyYcibaWUgcmVsYcibaW9uYWzEgyBtYWkgbWljxIMgZGVjw6J0IHBlIGRvdcSDIGludHLEg3JpIHBpeGVsIGN1IHBpeGVsLiBBY2Vhc3RhIHJldHVybmVhesSDIG8gdmFsb2FyZSBkZSAxIHBlbnRydSBwaXhlbGlpIHVuZGUgcHJpbXVsIHJhc3RlciBlc3RlIG1haSBtaWMgZGVjw6J0IGFsIGRvaWxlYSByYXN0ZXIgyJlpIG8gdmFsb2FyZSBkZSAwIGRhY8SDIHByaW11bCByYXN0ZXIgbnUgZXN0ZSBtYWkgbWljIGRlY8OidCBhbCBkb2lsZWEgcmFzdGVyLlwiLFxuXHRcdGxuTmFtZTogXCJMblwiLFxuXHRcdGxuU25pcDogXCJDYWxjdWxlYXrEgyBsb2dhcml0bXVsIG5hdHVyYWwgKGJhemEgZSkgYSBjZWx1bGVsb3IgZGludHItdW4gcmFzdGVyLlwiLFxuXHRcdGxuRGVzYzogXCJGdW5jyJtpYSBMbiBjYWxjdWxlYXrEgyBsb2dhcml0bXVsIG5hdHVyYWwgKGJhemEgZSkgYSBmaWVjxINydWkgcGl4ZWwgZGludHItdW4gcmFzdGVyLlwiLFxuXHRcdGxvZzEwTmFtZTogXCJMb2cxMFwiLFxuXHRcdGxvZzEwU25pcDogXCJDYWxjdWxlYXrEgyBsb2dhcml0bXVsIGRlIGJhesSDIDEwIGFsIGNlbHVsZWxvciBkaW50ci11biByYXN0ZXIuXCIsXG5cdFx0bG9nMTBEZXNjOiBcIkZ1bmPIm2lhIExvZzEwIGNhbGN1bGVhesSDIGxvZ2FyaXRtdWwgZGUgYmF6xIMgMTAgYSBmaWVjxINydWkgcGl4ZWwgZGludHItdW4gcmFzdGVyLlwiLFxuXHRcdGxvZzJOYW1lOiBcIkxvZzJcIixcblx0XHRsb2cyU25pcDogXCJDYWxjdWxlYXrEgyBsb2dhcml0bXVsIGRlIGJhesSDIDIgYWwgY2VsdWxlbG9yIGRpbnRyLXVuIHJhc3Rlci5cIixcblx0XHRsb2cyRGVzYzogXCJGdW5jyJtpYSBMb2cxMCBjYWxjdWxlYXrEgyBsb2dhcml0bXVsIGRlIGJhesSDIDIgYWwgZmllY8SDcnVpIHBpeGVsIGRpbnRyLXVuIHJhc3Rlci5cIixcblx0XHRsb29rdXBOYW1lOiBcIkPEg3V0YXJlXCIsXG5cdFx0bG9va3VwU25pcDogXCJDcmVlYXrEgyB1biBub3UgcmFzdGVyIHByaW4gY8SDdXRhcmVhIHZhbG9yaWxvciBnxINzaXRlIMOubnRyLXVuIGFsdCBjw6JtcCBkaW4gdGFiZWx1bCByYXN0ZXJ1bHVpIGRlIGludHJhcmUuXCIsXG5cdFx0bG9va3VwRGVzYzogXCJGdW5jyJtpYSBjcmVlYXrEgyB1biBub3UgcmFzdGVyIHByaW4gY8SDdXRhcmVhIHZhbG9yaWxvciBnxINzaXRlIMOubnRyLXVuIGFsdCBjw6JtcCBkaW4gdGFiZWx1bCByYXN0ZXJ1bHVpIGRlIGludHJhcmUuXCIsXG5cdFx0bWxDbGFzc2lmeU5hbWU6IFwiQ2xhc2lmaWNhcmUgTUxcIixcblx0XHRtbENsYXNzaWZ5U25pcDogXCJDbGFzaWZpY8SDIGltYWdpbmlsZSBmb2xvc2luZCBvIGFib3JkYXJlIHBlIGZpZWNhcmUgcGl4ZWwuIFBpeGVsaWkgY29tYmluYcibaSBzdW50IGFsb2NhyJtpIG9iaWVjdHVsdWkgc3BhyJtpYWwgY3UgY2VsIG1haSBtYXJlIHByb2NlbnQgZGluIGFjZWwgcGl4ZWwuXCIsXG5cdFx0bWxDbGFzc2lmeURlc2M6IFwiRnVuY8ibaWEgTUwgQ2xhc2lmaWNhcmUgdsSDIHBlcm1pdGUgc8SDIGVmZWN0dWHIm2kgbyBjbGFzaWZpY2FyZSBzdXByYXZlZ2hlYXTEgywgZm9sb3NpbmQgYWxnb3JpdG11bCBkZSBjbGFzaWZpY2FyZSBkZSBwcm9iYWJpbGl0YXRlIG1heGltxIMsIGFzdXByYSB1bnVpIHNldCBkZSBkYXRlIHJhc3RlciBzYXUgbW96YWljLiBBY2Vhc3TEgyBmdW5jyJtpZSBuZWNlc2l0xIMgdW4gZmnImWllciBkZSBzZW1uxIN0dXLEgyBkZSBjbGFzaWZpY2FyZS5cIixcblx0XHRtYXNrTmFtZTogXCJNYXNjxINcIixcblx0XHRtYXNrU25pcDogXCJTdGFiaWxlyJl0ZSB2YWxvcmlsZSBwZSBjYXJlIG51IGRvcmnIm2kgc8SDIGxlIGFmaciZYcibaS5cIixcblx0XHRtYXNrRGVzYzogXCJBY2Vhc3TEgyBmdW5jyJtpZSByYXN0ZXIgc3RhYmlsZciZdGUgdmFsb3JpbGUgcGUgY2FyZSBudSBkb3JpyJtpIHPEgyBsZSBhZmnImWHIm2kgcGUgcmFzdGVydWwgZHZzLiBGb2xvc2luZCBmdW5jyJtpYSBNYXNjxIMsIHZlyJtpIHNwZWNpZmljYSB1bmEgc2F1IG1haSBtdWx0ZSB2YWxvcmkgTm9EYXRhIHNhdSB1biBpbnRlcnZhbCBkZSB2YWxvcmkgZGUgcGl4ZWwgdmFsYWJpbGUuIFwiLFxuXHRcdG1pbnVzTmFtZTogXCJNaW51c1wiLFxuXHRcdG1pbnVzU25pcDogXCJTY2FkZSB2YWxvYXJlYSBjZWx1aSBkZS1hbCBkb2lsZWEgcmFzdGVyIGRlIGludHJhcmUgZGluIHZhbG9hcmVhIHByaW11bHVpIHJhc3RlciBkZSBpbnRyYXJlIGRlIGxhIG8gY2VsdWzEgyBsYSBhbHRhLlwiLFxuXHRcdG1pbnVzRGVzYzogXCJGdW5jyJtpYSBzY2FkZSB2YWxvYXJlYSBjZWx1aSBkZS1hbCBkb2lsZWEgcmFzdGVyIGRlIGludHJhcmUgZGluIHZhbG9hcmVhIHByaW11bHVpIHJhc3RlciBkZSBpbnRyYXJlIGRlIGxhIHVuIHBpeGVsIGxhIGFsdHVsLlwiLFxuXHRcdG1vZE5hbWU6IFwiTW9kXCIsXG5cdFx0bW9kU25pcDogXCJHxINzZciZdGUgcmVzdHVsICjDrm4gbW9kdWwpIHByaW11bHVpIHJhc3RlciBhdHVuY2kgY8OibmQgZXN0ZSDDrm1wxINyyJtpdCBsYSBhbCBkb2lsZWEgcmFzdGVyIHBlbnRydSBmaWVjYXJlIGNlbHVsxIMuXCIsXG5cdFx0bW9kRGVzYzogXCJGdW5jyJtpYSBNb2QgZ8SDc2XImXRlIHJlc3R1bCAow65uIG1vZHVsKSBwcmltdWx1aSByYXN0ZXIgYXR1bmNpIGPDom5kIGVzdGUgw65tcMSDcsibaXTEgyBsYSBhbCBkb2lsZWEgcmFzdGVyIGRlIGxhIHVuIHBpeGVsIGxhIGFsdHVsLiBPcmRpbmVhIGludHLEg3JpbG9yIGVzdGUgaW1wb3J0YW50xIMgyJlpIGFmZWN0ZWF6xIMgcmV6dWx0YXR1bCBpZciZaXJpaS5cIixcblx0XHRtb3NhaWNSYXN0ZXJzTmFtZTogXCJSYXN0ZXJlIE1vemFpY1wiLFxuXHRcdG1vc2FpY1Jhc3RlcnNTbmlwOiBcIkNvbXBpbGVhesSDIHVuIHNldCBkZSBzZXR1cmkgZGUgZGF0ZSByYXN0ZXIgcGVudHJ1IGEgY3JlYSB1biBzaW5ndXIgc2V0IGRlIGRhdGUuXCIsXG5cdFx0bW9zYWljUmFzdGVyc0Rlc2M6IFwiRnVuY8ibaWEgZGUgUmFzdGVyZSBNb3phaWMgY3JlZWF6xIMgbyBpbWFnaW5lIG1vemFpYyBkaW4gbWFpIG11bHRlIGltYWdpbmkuIEFjb2xvIHVuZGUgZXhpc3TEgyBvIHN1cHJhcHVuZXJlIMOubnRyZSBpbWFnaW5pLCBleGlzdMSDIG1haSBtdWx0ZSBtZXRvZGUgZGluIGNhcmUgcHV0ZcibaSBhbGVnZSBwZW50cnUgYSBzdGFiaWxpIGNlIGltYWdpbmkgc8SDIGZpZSBhZmnImWF0ZS5cIixcblx0XHRuZHZpQ29sb3JpemVkTmFtZTogXCJORFZJIENvbG9yaXphdFwiLFxuXHRcdG5kdmlDb2xvcml6ZWRTbmlwOiBcIkNyZWVhesSDIHVuIHNldCBkZSBkYXRlIGN1IGJlbnppIG11bHRpcGxlIGNhcmUgcmVwcmV6aW50xIMgc3RhcmVhIGRlIHPEg27Eg3RhdGUgYSB2ZWdldGHIm2llaSwgcGUgYmF6YSBkaWZlcmVuyJtlbG9yIGRpbnRyZSBiZW56aWxlIHJvyJl1IMiZaSBpbmZyYXJvyJl1IGFwcm9waWF0LlwiLFxuXHRcdG5kdmlDb2xvcml6ZWREZXNjOiBcIkZ1bmPIm2lhIE5EVkkgQ29sb3JpemF0IGFwbGljxIMgZnVuY8ibaWEgTkRWSSBwZSBpbWFnaW5lYSBkZSBpbnRyYXJlIMiZaSBhcG9pIHV0aWxpemVhesSDIG8gaGFydMSDIGNvbG9yIHNhdSBvIHJhbXDEgyBkZSBjdWxvYXJlIHBlbnRydSBhIHByZXplbnRhIHJlenVsdGF0dWwuXCIsXG5cdFx0bmR2aU5hbWU6IFwiTkRWSVwiLFxuXHRcdG5kdmlTbmlwOiBcIkNhbGN1bGVhesSDIEluZGljZSBkZSBWZWdldGHIm2llIERpZmVyZW7Im8SDIE5vcm1hbGl6YXTEgyAoTkRWSSkuXCIsXG5cdFx0bmR2aURlc2M6IFwiRnVuY8ibaWEgTkRWSSBjcmVlYXrEgyB1biBzZXQgZGUgZGF0ZSBjdSBvIHNpbmd1csSDIGJhbmTEgyBjYXJlIHJlcHJlemludMSDIHN0YXJlYSBkZSBzxINuxIN0YXRlIGEgdmVnZXRhyJtpZWksIHBlIGJhemEgZGlmZXJlbsibZWxvciBkaW50cmUgYmVuemlsZSByb8iZdSDImWkgaW5mcmFyb8iZdSBhcHJvcGlhdC48ZGl2Pjxici8+TkRWSSBlc3RlIHVuIGluZGV4IHN0YW5kYXJkaXphdCBjYXJlIHbEgyBwZXJtaXRlIHPEgyBnZW5lcmHIm2kgbyBpbWFnaW5lIGNhcmUgYWZpyJllYXrEgyBpbnRlbnNpdGF0ZWEgdmVyZGVsdWksIGRlbnVtaXTEgyDImWkgYmlvbWFzYSByZWxhdGl2xIMuIEFjZXN0IGluZGV4IHByb2ZpdMSDIGRlIGNvbnRyYXN0dWwgY2FyYWN0ZXJpc3RpY2lsb3IgZGludHJlIGNlbGUgZG91xIMgYmVuemkgZGludHItdW4gc2V0IGRlIGRhdGUgcmFzdGVyIG11bHRpc3BlY3RyYWxlOiBhYnNvcmLIm2lpbGUgcGlnbWVudHVsdWkgY2xvcm9maWxlaSBkaW4gYmFuZGEgcm/ImWllIMiZaSByZWZsZWN0aXZpdGF0ZWEgcmlkaWNhdMSDIGEgbWF0ZXJpYWx1bHVpIHBsYW50ZWxvciBkaW4gYmFuZGEgZGUgaW5mcmFyb8iZdSBhcHJvcGlhdCAoTklSKS4gVmFsb3JpbGUgTkRWSSBleHRyZW0gZGUgcmVkdXNlIHNhdSBuZWdhdGl2ZSByZXByZXppbnTEgyB6b25lIGbEg3LEgyBuaWNpbyB2ZWdldGHIm2llLCBjdW0gYXIgZmkgbm9yaWksIGFwYSBzYXUgesSDcGFkYS4gVmFsb3JpbGUgZm9hcnRlIG1pY2kgcmVwcmV6aW50xIMgem9uZSBjdSB2ZWdldGHIm2llIHJlZHVzxIMgc2F1IGRlbG9jLCBjdW0gYXIgZmkgYmV0b251bCwgcm9jaWxlIHNhdSBzb2x1bCBkZXpnb2xpdC4gVmFsb3JpbGUgbW9kZXJhdGUgcmVwcmV6aW50xIMgem9uZSBkZSBhcmJ1yJl0aSDImWkgcGFqaciZdGkuIFZhbG9yaWxlIHJpZGljYXRlIHJlcHJlemludMSDIHpvbmUgZGUgcMSDZHVyaSDImWkgdmVnZXRhyJtpZSBsdXh1cmlhbnTEgy48L2Rpdj5cIixcblx0XHRuZWdhdGVOYW1lOiBcIkFudWxhcmVcIixcblx0XHRuZWdhdGVTbmlwOiBcIlNjaGltYsSDIHNlbW51bCAow65ubXVsyJtlyJl0ZSBjdSAtMSkgdmFsb3JpbG9yIGNlbHVsZWkgcmFzdGVydWx1aSBkZSBpbnRyYXJlIGRlIGxhIG8gY2VsdWzEgyBsYSBhbHRhLlwiLFxuXHRcdG5lZ2F0ZURlc2M6IFwiRnVuY8ibaWEgZGUgYW51bGFyZSBzY2hpbWLEgyBzZW1udWwgKMOubm11bMibZciZdGUgY3UgLTEpIHZhbG9yaWxvciBwaXhlbHVsdWkgcmFzdGVydWx1aSBkZSBpbnRyYXJlIGRlIHBlIHVuIHBpeGVsIFwiLFxuXHRcdG5pYmJsZU5hbWU6IFwiTmliYmxlXCIsXG5cdFx0bmliYmxlU25pcDogXCLDjm5sb2N1aWXImXRlIGNlbHVsZWxlIHVudWkgcmFzdGVyIMOubiBtb2QgY29yZXNwdW56xIN0b3IgdW5laSBtxIPImXRpIGN1IHZhbG9yaWxvciB2ZWNpbmlsb3IgY2VpIG1haSBhcHJvcGlhyJtpLlwiLFxuXHRcdG5pYmJsZURlc2M6IFwiRnVuY8ibaWEgZ2xvYmFsxIMgTmliYmxlIHBlcm1pdGUgem9uZWxvciBzZWxlY3RhdGUgYWxlIHJhc3RlcnVsdWkgc8SDIGxlIGZpZSBhbG9jYXTEgyB2YWxvYXJlYSB2ZWNpbnVsdWkgY2VsIG1haSBhcHJvcGlhdC4gQWNlc3QgbHVjcnUgZXN0ZSB1dGlsIHBlbnRydSBlZGl0YXJlYSB6b25lbG9yIHVudWkgcmFzdGVyIHVuZGUgZGF0ZWxlIHBvdCBmaSBlcm9uYXRlLlwiLFxuXHRcdG5vdEVxdWFsTmFtZTogXCJOdSBlc3RlIGVnYWwgY3VcIixcblx0XHRub3RFcXVhbFNuaXA6IFwiRWZlY3R1ZWF6xIMgbyBvcGVyYcibaWUgZGlmZXJpdCBkZSByZWxhyJtpb25hbMSDIHBlIGRvdcSDIGludHLEg3JpIGRlIGxhIG8gY2VsdWzEgyBsYSBhbHRhLiBSZXR1cm5lYXrEgyAxIHBlbnRydSBjZWx1bGVsZSB1bmRlIHByaW11bCByYXN0ZXIgbnUgZXN0ZSBlZ2FsIGN1IGFsIGRvaWxlYSByYXN0ZXIgyJlpIDAgYWNvbG8gdW5kZSBlc3RlIGVnYWwuXCIsXG5cdFx0bm90RXF1YWxEZXNjOiBcIkZ1bmPIm2lhIGVmZWN0dWVhesSDIG8gb3BlcmHIm2llIHJlbGHIm2lvbmFsxIMgZGlmZXJpdCBkZSBwZSBkb3XEgyBpbnRyxINyaSBwaXhlbCBjdSBwaXhlbC4gQWNlYXN0YSByZXR1cm5lYXrEgyBvIHZhbG9hcmUgZGUgMSBwZW50cnUgcGl4ZWxpaSB1bmRlIHByaW11bCByYXN0ZXIgbnUgZXN0ZSBlZ2FsIGN1IGFsIGRvaWxlYSByYXN0ZXIgyJlpIG8gdmFsb2FyZSBkZSAwIHBlbnRydSBwaXhlbGkgdW5kZSBwcmltdWwgcmFzdGVyIGVzdGUgZWdhbCBjdSBhbCBkb2lsZWEgcmFzdGVyLlwiLFxuXHRcdHBhbnNoYXJwZW5pbmdOYW1lOiBcIlBhbmNsYXJpZmljYXJlXCIsXG5cdFx0cGFuc2hhcnBlbmluZ1NuaXA6IFwiQW1wbGlmaWPEgyBhcnRpZmljaWFsIHJlem9sdcibaWEgc3BhyJtpYWzEgyBhIHVuZWkgaW1hZ2luaSBjdSBiZW56aSBtdWx0aXBsZSBwcmluIGZ1emlvbmFyZWEgYWNlc3RlaWEgY3UgbyBpbWFnaW5lIHBhbmNyb21hdGljxIMgZGUgcmV6b2x1yJtpZSBtYWkgbWFyZS5cIixcblx0XHRwYW5zaGFycGVuaW5nRGVzYzogXCJGdW5jyJtpYSBkZSBQYW5jbGFyaWZpY2FyZSB1dGlsaXplYXrEgyBvIGltYWdpbmUgcGFuY3JvbWF0aWPEgyBkZSByZXpvbHXIm2llIG1haSBtYXJlIHNhdSBiYW5kxIMgcmFzdGVyIHBlbnRydSBmdXppb25hcmVhIGN1IHVuIHNldCBkZSBkYXRlIGRlIHJlem9sdcibaWUgbWFpIG1pY8SDLCBjdSBiZW56aSBtdWx0aXBsZSwgcGVudHJ1IGEgY3JlyJl0ZSByZXpvbHXIm2lhIHNwYcibaWFsxIMgYSBpbWFnaW5paSBjdSBiZW56aSBtdWx0aXBsZS48ZGl2Pjxici8+U2NvcHVsIHBhbmNsYXJpZmljxINyaWkgZXN0ZSBhY2VsYSBkZSBhIGNyZWEgbyBpbWFnaW5lIGN1IGNhbGl0YXRlIHZpenVhbMSDIHJpZGljYXTEgy4gQXbDom5kIMOubiB2ZWRlcmUgZmFwdHVsIGPEgyB0ZWhuaWNpbGUgbW9kaWZpY8SDIGNhcmFjdGVyaXN0aWNpbGUgZGUgcmFkaW9tZXRyaWUgyJlpIHNwZWN0cmFsZSBhbGUgaW1hZ2luaWxvciBjdSBiZW56aSBtdWx0aXBsZSwgaW1hZ2luaWxlIHBhbi1jbGFyaWZpY2F0ZSB0cmVidWllIHPEgyBmaWUgZm9sb3NpdGUgY3UgYXRlbsibaWUgw65uIHNjb3B1bCBkZXRlY3TEg3JpaSBhbmFsaXRpY2UgZGUgbGEgZGlzdGFuyJvEgy48L2Rpdj5cIixcblx0XHRwYXRoQWxsb2NhdGlvbk5hbWU6IFwiQWxvY2FyZWEgRGlzdGFuyJtlaSBkZSBUcmFzZXVcIixcblx0XHRwYXRoQWxsb2NhdGlvblNuaXA6IFwiQ2FsY3VsZWF6xIMgc3Vyc2EgY3UgY2VsIG1haSBtaWMgY29zdCBwZW50cnUgZmllY2FyZSBjZWx1bMSDIHBlIGJhemEgY29zdHVsdWkgY2VsIG1haSBwdcibaW4gYWN1bXVsYXRpdiBwZSBvIHN1cHJhZmHIm8SDIGRlIGNvc3QsIMOubiB0aW1wIGNlIHNlIMibaW5lIHNlYW1hIGRlIGRpc3RhbsibYSBkZSBzdXByYWZhyJvEgyDImWkgZmFjdG9yaWkgZGUgY29zdCBvcml6b250YWxpIMiZaSB2ZXJ0aWNhbGkuXCIsXG5cdFx0cGF0aEFsbG9jYXRpb25EZXNjOiBcIkZ1bmPIm2lhIGRlIEFsb2NhcmUgYSBEaXN0YW7Im2VpIFRyYXNldWx1aSBjYWxjdWxlYXrEgyBjZWEgbWFpIGFwcm9waWF0xIMgc3Vyc8SDIHBlbnRydSBmaWVjYXJlIGNlbHVsxIMgcGUgYmF6YSBjb3N0dWx1aSBjZWwgbWFpIHB1yJtpbiBhY3VtdWxhdGl2IHBlIG8gc3VwcmFmYcibxIMgZGUgY29zdCwgw65uIHRpbXAgY2Ugc2UgyJtpbmUgc2VhbWEgZGUgZGlzdGFuyJthIGRlIHN1cHJhZmHIm8SDIMiZaSBmYWN0b3JpaSBkZSBjb3N0IG9yaXpvbnRhbGkgyJlpIHZlcnRpY2FsaS5cIixcblx0XHRwYXRoQmFja0xpbmtOYW1lOiBcIkxpbmsgRGlzdGFuyJvEgyBkZSBUcmFzZXUgw45uYXBvaVwiLFxuXHRcdHBhdGhCYWNrTGlua1NuaXA6IFwiRGVmaW5lyJl0ZSB2ZWNpbnVsIGNhcmUgZXN0ZSBjZWx1bGEgdXJtxIN0b2FyZSBwZSB0cmFzZXVsIGRlIGNvc3QgY2VsIG1haSBwdcibaW4gYWN1bXVsYXRpdiBjxIN0cmUgc3Vyc2EgY3UgY2VsIG1haSBtaWMgY29zdCwgw65uIHRpbXAgY2Ugc2UgyJtpbmUgc2VhbWEgZGUgZGlzdGFuyJthIGRlIHN1cHJhZmHIm8SDIMiZaSBmYWN0b3JpaSBkZSBjb3N0IG9yaXpvbnRhbGkgyJlpIHZlcnRpY2FsaS5cIixcblx0XHRwYXRoQmFja0xpbmtEZXNjOiBcIkZ1bmPIm2lhIExpbmsgRGlzdGFuyJvEgyBkZSBUcmFzZXUgw45uYXBvaSBpZGVudGlmaWPEgyBkaXJlY8ibaW9uYWxpdGF0ZWEgdmVjaW51bHVpIGNhcmUgw65uc2VhbW7EgyB1cm3Eg3RvYXJlYSBjZWx1bMSDIGRpbiBjZWwgbWFpIHB1yJtpbiBhY3VtdWxhdGl2IHRyYXNldSBkZSBjb3N0IGPEg3RyZSBjZWEgbWFpIGFwcm9waWF0xIMgc3Vyc8SDLCDDrm4gdGltcCBjZSBzZSBpYSDDrm4gY29uc2lkZXJhcmUgZGlzdGFuyJthIGRlIHN1cHJhZmHIm8SDIMiZaSBmYWN0b3JpaSBkZSBjb3N0IG9yaXpvbnRhbGkgyJlpIHZlcnRpY2FsaS5cIixcblx0XHRwYXRoRGlzdGFuY2VOYW1lOiBcIkRpc3RhbsibYSBkZSBUcmFzZXVcIixcblx0XHRwYXRoRGlzdGFuY2VTbmlwOiBcIkNhbGN1bGVhesSDIHBlbnRydSBmaWVjYXJlIGNlbHVsxIMgZGlzdGFuyJthIGRlIGNvc3QgY2VsIG1haSBwdcibaW4gYWN1bXVsYXRpdsSDIGRlIGxhIHNhdSBjxIN0cmUgc3Vyc2EgY3UgY2VsZSBtYWkgcHXIm2luZSBjb3N0dXJpLCDDrm4gdGltcCBjZSBzZSDIm2luZSBzZWFtYSBkZSBkaXN0YW7Im2EgZGUgc3VwcmFmYcibxIMgyJlpIGZhY3RvcmlpIGRlIGNvc3Qgb3Jpem9udGFsaSDImWkgdmVydGljYWxpLlwiLFxuXHRcdHBhdGhEaXN0YW5jZURlc2M6IFwiRnVuY8ibaWEgRGlzdGFuyJtlaSBUcmFzZXVsdWkgY2FsY3VsZWF6xIMsIHBlbnRydSBmaWVjYXJlIGNlbHVsxIMsIGRpc3RhbsibYSBkZSBjb3N0IGNlbCBtYWkgcHXIm2luIGFjdW11bGF0aXbEgyBjxIN0cmUgY2VhIG1haSBhcHJvcGlhdMSDIHN1cnPEgywgw65uIHRpbXAgY2Ugc2UgyJtpbmUgc2VhbWEgZGUgZGlzdGFuyJthIGRlIHN1cHJhZmHIm8SDIMiZaSBmYWN0b3JpaSBkZSBjb3N0IG9yaXpvbnRhbGkgyJlpIHZlcnRpY2FsaS5cIixcblx0XHRwbHVzTmFtZTogXCJQbHVzXCIsXG5cdFx0cGx1c1NuaXA6IFwiQWRhdWfEgyAow65uc3VtZWF6xIMpIHZhbG9yaWxlIGEgZG91xIMgcmFzdGVyZSBjZWx1bMSDIGN1IGNlbHVsxIMuXCIsXG5cdFx0cGx1c0Rlc2M6IFwiRnVuY8ibaWEgZGUgYWR1bmFyZSBhZGF1Z8SDICjDrm5zdW1lYXrEgykgdmFsb3JpbGUgYSBkb3XEgyByYXN0ZXJlIHBpeGVsIGN1IHBpeGVsLlwiLFxuXHRcdHBvd2VyTmFtZTogXCJQdXRlcmVcIixcblx0XHRwb3dlclNuaXA6IFwiQ3JlyJl0ZSB2YWxvcmlsZSBjZWx1bGVpIGRpbnRyLXVuIHJhc3RlciBsYSBwdXRlcmVhIHZhbG9yaWxvciBnxINzaXRlIMOubnRyLXVuIGFsdCByYXN0ZXIuXCIsXG5cdFx0cG93ZXJEZXNjOiBcIkZ1bmPIm2lhIGRlIHB1dGVyZSBjcmXImXRlIHZhbG9yaWxlIHBpeGVsdWx1aSDDrm50ci11biByYXN0ZXIgbGEgcHV0ZXJlYSB2YWxvcmlsb3IgZ8SDc2l0ZSDDrm50ci11biBhbHQgcmFzdGVyLlwiLFxuXHRcdHJhZGFyQ2FsaWJyYXRpb25OYW1lOiBcIkNhbGlicmFyZWEgcmFkYXJ1bHVpXCIsXG5cdFx0cmFkYXJDYWxpYnJhdGlvblNuaXA6IFwiVHJhbnNmb3JtxIMgcmV0cm8tw65tcHLEg8iZdGllcmVhIFJBREFSU0FULTIuXCIsXG5cdFx0cmFkYXJDYWxpYnJhdGlvbkRlc2M6IFwiQWNlYXN0xIMgZnVuY8ibaWUgcG9hdGUgZmkgZm9sb3NpdMSDIHBlbnRydSBhIGNhbGlicmEgaW1hZ2luaWxlIFJBREFSU0FULTIgw65udHItdW4gc2V0IGRlIGRhdGUgbW96YWljIHNhdSBjYSB1biBwcm9kdXMgcmFzdGVyLiBDYWxpYnJhcmVhIGVzdGUgZWZlY3R1YXTEgyBhc3VwcmEgaW1hZ2luaWxvciByYWRhciBhc3RmZWwgw65uY8OidCB2YWxvcmlsZSBwaXhlbHVsdWkgc8SDIGZpZSBvIHJlcHJlemVudGFyZSByZWFsxIMgYSByZXRyby3Drm1wcsSDyJl0aWVyaWkuXCIsXG5cdFx0cmFzdGVySW5mb05hbWU6IFwiUmFzdGVySW5mb1wiLFxuXHRcdHJhc3RlckluZm9TbmlwOiBcIk1vZGlmaWPEgyBwcm9wcmlldMSDyJtpbGUgcmFzdGVydWx1aSwgY3VtIGFyIGZpIGFkw6JuY2ltZWEgYml0dWx1aSwgdmFsb2FyZWEgTm9EYXRhLCBkaW1lbnNpdW5lYSBjZWx1bGVpIMiZaSBhyJlhIG1haSBkZXBhcnRlLlwiLFxuXHRcdHJhc3RlckluZm9EZXNjOiBcIkluZm9ybWHIm2lpIGRlc3ByZSBSYXN0ZXIgZGVzY2hpZGUgdW4gZGlhbG9nIGN1IHByb3ByaWV0xIPIm2lsZSBzZXR1bHVpIGRlIGRhdGUgcmFzdGVyLCBjdW0gYXIgZmkgbnVtxINydWwgZGUgY29sb2FuZSDImWkgcsOibmR1cmksIG51bcSDcnVsIGRlIGJlbnppLCB0aXB1bCBwaXhlbHVsdWksIG3Eg3N1cmEgyJlpIHJlZmVyaW7Im2Egc3BhyJtpYWzEgy4gUHV0ZcibaSBlZGl0YSBhY2VzdGUgcHJvcHJpZXTEg8ibaSBwcmluIHNlbGVjdGFyZWEgc2V0dWx1aSBkZSBkYXRlIHJhc3RlciBwZW50cnUgYSDDrmwgZm9sb3NpIGNhIMiZYWJsb24uIFwiLFxuXHRcdHJhc3Rlcml6ZUF0dHJpYnV0ZXNOYW1lOiBcIlJhc3Rlcml6YXJlYSBBdHJpYnV0ZWxvclwiLFxuXHRcdHJhc3Rlcml6ZUF0dHJpYnV0ZXNTbmlwOiBcIsOObWJvZ8SDyJtlyJl0ZSB1biByYXN0ZXIgcHJpbiBiZW56aSBzdXBsaW1lbnRhcmUgZGVyaXZhdGUgZGluIHZhbG9yaWxlIGF0cmlidXRlbG9yIHNwZWNpZmljYXRlIGFsZSB1bnVpIHRhYmVsIGV4dGVybiBzYXUgZGludHItdW4gc2VydmljaXUgZGUgb2JpZWN0ZSBzcGHIm2lhbGUuXCIsXG5cdFx0cmFzdGVyaXplQXR0cmlidXRlc0Rlc2M6IFwiRnVuY8ibaWEgZGUgUmFzdGVyaXphcmUgYSBBdHJpYnV0dWx1aSDDrm1ib2fEg8ibZciZdGUgdW4gcmFzdGVyIHByaW4gYWTEg3VnYXJlYSBiZW56aWxvciBkZXJpdmF0ZSBkaW4gYXRyaWJ1dGUgc3BlY2lmaWNhdGUsIGRpbnRyLXVuIHRhYmVsIGV4dGVybiBzYXUgZGludHItdW4gc2VydmljaXUgZGUgb2JpZWN0ZSBzcGHIm2lhbGUuIFB1dGXIm2kgc3BlY2lmaWNhIMOubiBtb2Qgb3DIm2lvbmFsIHVuIHJhc3RlciBkZSB6b27EgyDImWkgYXRyaWJ1dHVsIElELXVsdWkgZGUgem9uxIMgYXNvY2lhdCBwZW50cnUgYSBwZXJtaXRlIGPEg3V0YXJlYSBwZSBiYXphIHJlZ2l1bmlpLlwiLFxuXHRcdHJhc3Rlcml6ZUZlYXR1cmVDbGFzc05hbWU6IFwiUmFzdGVyaXphcmVhIG9iaWVjdGVsb3Igc3BhyJtpYWxlXCIsXG5cdFx0cmFzdGVyaXplRmVhdHVyZUNsYXNzU25pcDogXCJUcmFuc2Zvcm3EgyBjYXJhY3RlcmlzdGljaWxlIMOubiByYXN0ZXIuXCIsXG5cdFx0cmFzdGVyaXplRmVhdHVyZUNsYXNzRGVzYzogXCJBY2Vhc3TEgyBmdW5jyJtpZSB0cmFuc2Zvcm3EgyBkYXRlbGUgY2xhc2VpIGRlIG9iaWVjdGUgc3BhyJtpYWxlIHBvbGlnb25hbGUsIHBvbGlsaW5pZSDImWkgcHVuY3RlIMOubnRyLXVuIHN0cmF0IHRlbWF0aWMgZGUgcmFzdGVyLjxkaXY+PGJyLz5PYmllY3RlbG9yIHNwYcibaWFsZSBsaSBzZSBhbG9jxIMgdmFsb3JpIGFsZSBwaXhlbGlsb3IgcGUgYmF6YSBPQkpFQ1RJRCAoaW1wbGljaXQpIGFsIG9iaWVjdGVsb3Igc3BhyJtpYWxlLiDDjm4gbW9kIG9wyJtpb25hbCwgdmFsb3JpbGUgcGl4ZWxpbG9yIHBvdCBhdmVhIGxhIGJhesSDIG8gdmFsb2FyZSBkZWZpbml0xIMgZGUgdXRpbGl6YXRvciBkaW4gdGFiZWx1bCBkZSBhdHJpYnV0ZSBhbGUgb2JpZWN0dWx1aSBzcGHIm2lhbCBkZSBpbnRyYXJlLjwvZGl2PlwiLFxuXHRcdHJlY2FzdE5hbWU6IFwiVHJhbnNmb3JtYXJlXCIsXG5cdFx0cmVjYXN0U25pcDogXCJNb2RpZmljxIMgcGFyYW1ldHJpaSB1bnVpIGxhbsibIGRlIGZ1bmPIm2lpIGRpbnRyLXVuIHNldCBkZSBkYXRlIG1vemFpYyBzYXUgc2VydmljaXUgZGUgaW1hZ2luaS4gQWNlc3QgbHVjcnUgZXN0ZSBhZGVzZWEgdXRpbGl6YXQgY3Ugc2V0dXJpIGRlIGRhdGUgTEFTIHBlbnRydSBhIGV2aXRhIG5lY2VzaXRhdGVhIGRlIGEgY3JlYSB1biBzZXQgZGUgZGF0ZSBtb3phaWMgc2VwYXJhdCBwZW50cnUgZGlmZXJpdGUgcmVwcmV6ZW50xINyaSBhbGUgdGVyZW51bHVpLlwiLFxuXHRcdHJlY2FzdERlc2M6IFwiRnVuY8ibaWEgZGUgdHJhbnNmb3JtYXJlIGVzdGUgZm9sb3NpdMSDIHBlbnRydSBtb2RpZmljYXJlYSBkaW5hbWljxIMgYSBwYXJhbWV0cnVsdWkgZGUgZnVuY8ibaWUgZm9sb3NpdCDDrm50ci11biBzZXQgZGUgZGF0ZSBtb3phaWMgc2F1IHNlcnZpY2l1IGRlIGltYWdpbmkgZsSDcsSDIHBlcnNpc3RlbsibYSBmaXppY8SDIGEgbW9kaWZpY8SDcmlsb3IuXCIsXG5cdFx0cmVnaW9uR3JvdXBOYW1lOiBcIkdydXAgZGUgUmVnaXVuZVwiLFxuXHRcdHJlZ2lvbkdyb3VwU25pcDogXCJQZW50cnUgZmllY2FyZSBjZWx1bMSDIGRpbiByZXp1bHRhdCwgZXN0ZSDDrm5yZWdpc3RyYXTEgyBpZGVudGl0YXRlYSByZWdpdW5paSBjb25lY3RhdGUgY8SDcmVpYSDDrmkgYXBhcsibaW5lIGFjZWEgY2VsdWzEgy4gVW4gbnVtxINyIHVuaWMgZXN0ZSBhbG9jYXQgZmllY8SDcmVpIHJlZ2l1bmkuXCIsXG5cdFx0cmVnaW9uR3JvdXBEZXNjOiBcIkZ1bmPIm2lhIGdsb2JhbMSDIGEgUmVnaXVuaWkgR3J1cHVsdWkgw65ucmVnaXN0cmVhesSDLCBwZW50cnUgZmllY2FyZSBjZWx1bMSDIGRpbiByZXp1bHRhdCwgaWRlbnRpdGF0ZWEgcmVnaXVuaWkgY29uZWN0YXRlIGPEg3JlaWEgw65pIGFwYXLIm2luZSBhY2VhIGNlbHVsxIMuIFVuIG51bcSDciB1bmljIGVzdGUgYWxvY2F0IGZpZWPEg3JlaSByZWdpdW5pLjxkaXY+PGJyLz5QcmltYSByZWdpdW5lIHNjYW5hdMSDIHByaW1lyJl0ZSB2YWxvYXJlYSB1bnUsIGEgZG91YSBwcmltZciZdGUgdmFsb2FyZWEgZG9pIMiZaSB0b3QgYciZYSwgcMOibsSDIGPDom5kIHR1dHVyb3IgcmVnaXVuaWxvciBsZSBlc3RlIGFsb2NhdMSDIGPDonRlIG8gdmFsb2FyZS4gU2NhbmFyZWEgc2UgZGVwbGFzZWF6xIMgZGUgbGEgc3TDom5nYSBsYSBkcmVhcHRhIMiZaSBkZSBzdXMgw65uIGpvcy4gVmFsb3JpbGUgYWxvY2F0ZSB6b25lbG9yIGRlIGllyJlpcmUgc2UgYmF6ZWF6xIMgcGUgbW9tZW50dWwgw65uIGNhcmUgYWNlc3RlYSBzdW50IMOubnTDomxuaXRlIMOubiBwcm9jZXN1bCBkZSBzY2FuYXJlLjwvZGl2PlwiLFxuXHRcdHJlZ2lvbkdyb3dOYW1lOiBcIkNyZciZdGVyZSBSZWdpdW5lXCIsXG5cdFx0cmVnaW9uR3Jvd1NuaXA6IFwiQ3JlyJl0ZSByZWdpdW5pbGUgZGluIHB1bmN0ZWxlIGRlIHBsZWNhcmUuXCIsXG5cdFx0cmVnaW9uR3Jvd0Rlc2M6IFwiRnVuY8ibaWEgZGUgQ3JlyJl0ZXJlIFJlZ2l1bmUgZ3J1cGVhesSDIHBpeGVsaWkgw65udmVjaW5hyJtpIMOubiBncnVwdXJpIMOubiBmdW5jyJtpZSBkZSByYXphIHNwZWNpZmljYXTEgyBkZSBsYSBwdW5jdHVsIGRlIHBsZWNhcmUuIEdydXB1bHVpIGRlIHBpeGVsaSBzYXUgb2JpZWN0dWx1aSBsaSBzZSBhbG9jxIMgbyB2YWxvYXJlIGRlIHVtcGxlcmUgc3BlY2lmaWNhdMSDLlwiLFxuXHRcdHJlbWFwTmFtZTogXCJSZW1hcGFyZVwiLFxuXHRcdHJlbWFwU25pcDogXCJNb2RpZmljxIMgdmFsb3JpbGUgcGl4ZWx1bHVpIHByaW4gYWxvY2FyZWEgdW5vciBub2kgdmFsb3JpIGludGVydmFsZWxvciBkZSB2YWxvcmkgYWxlIHBpeGVsdWx1aSBzYXUgY3UgYWp1dG9ydWwgdGFiZWx1bHVpIGV4dGVybi5cIixcblx0XHRyZW1hcERlc2M6IFwiRnVuY8ibaWEgZGUgUmVtYXBhcmUgdsSDIHBlcm1pdGUgc8SDIG1vZGlmaWNhyJtpIHNhdSBzxIMgcmVjbGFzaWZpY2HIm2kgdmFsb3JpbGUgcGl4ZWxpbG9yIGRhdGVsb3IgcmFzdGVyLiBBY2VzdCBsdWNydSBwb2F0ZSBmaSByZWFsaXphdCBmaWUgcHJpbiBzcGVjaWZpY2FyZWEgdW51aSBpbnRlcnZhbCBkZSB2YWxvcmkgZGUgcGl4ZWxpIHBlbnRydSBjYXJ0YXJlYSBjb25mb3JtIHVuZWkgdmFsb3JpIGRlIGllyJlpcmUgYSBwaXhlbHVsdWksIHNhdSBjdSBhanV0b3J1bCB1bnVpIHRhYmVsIHBlbnRydSBtYXBhcmVhIHZhbG9yaWxvciBwaXhlbHVsdWkgY29uZm9ybSB2YWxvcmlpIGRlIGllyJlpcmUgYSBwaXhlbHVsdWkuXCIsXG5cdFx0cmVwcm9qZWN0TmFtZTogXCJSZXByb2llY3RhcmVcIixcblx0XHRyZXByb2plY3RTbmlwOiBcIk1vZGlmaWPEgyBwcm9pZWN0YXJlYSB1bnVpIHNldCBkZSBkYXRlIHJhc3Rlciwgc2V0IGRlIGRhdGUgbW96YWljIHNhdSByZXBlciByYXN0ZXIgw65udHItdW4gc2V0IGRlIGRhdGUgbW96YWljLiBEZSBhc2VtZW5lYSwgcG9hdGUgcmVjb2xlY3RhIHByb2JlbGUgZGF0ZWxvciDDrm50ci1vIG5vdcSDIGRpbWVuc2l1bmUgZGUgY2VsdWzEgyDImWkgZGVmaW5pIG8gb3JpZ2luZS5cIixcblx0XHRyZXByb2plY3REZXNjOiBcIkZ1bmPIm2lhIGRlIFJlcHJvaWVjdGFyZSBtb2RpZmljxIMgcHJvaWVjdGFyZWEgdW51aSBzZXQgZGUgZGF0ZSByYXN0ZXIsIHNldCBkZSBkYXRlIG1vemFpYyBzYXUgcmVwZXIgcmFzdGVyIMOubnRyLXVuIHNldCBkZSBkYXRlIG1vemFpYy4gRGUgYXNlbWVuZWEsIHBvYXRlIHJlY29sZWN0YSBwcm9iZWxlIGRhdGVsb3Igw65udHItbyBub3XEgyBkaW1lbnNpdW5lIGRlIGNlbHVsxIMgyJlpIGRlZmluaSBvIG9yaWdpbmUuPGRpdj48YnIvPkZ1bmPIm2lhIGRlIHJlcHJvaWVjdGFyZSBwb2F0ZSBmaSB1dGlsaXphdMSDIGxhIGNyZWFyZWEgdW5laSBhcmhpdmUgZGludHItdW4gc2V0IGRlIGRhdGUgcmFzdGVyIHNhdSBtb3phaWMgY2FyZSBudSBpbnRyxIMgw65uIHByb2llY8ibaWEgc3BlY2lmaWNhdMSDLiBEZSBleGVtcGx1LCBsYSBjcmVhcmVhIHVudWkgc2VydmljaXUgZGUgaW1hZ2luaSBhcmhpdmF0ZSBjYXJlIHBvdCBmaSBpbnRlZ3JhdGUgcHJpbiBhcGxpY2HIm2lpIGN1IGFsdGUgc2VydmljaWkgYXJoaXZhdGUsIGVzdGUgaW1wb3J0YW50IGNhIGFjZXN0ZWEgc8SDIHNlIGFmbGUgw65uIGFjZWVhyJlpIHByb2llY8ibaWUuIEFkZXNlYSwgYWNlYXN0YSBlc3RlIG8gcHJvaWVjyJtpZSBXZWIgTWVyY2F0b3IuIERpbiBtb21lbnQgZGUgc2V0dWwgZGUgZGF0ZSBtb3phaWMgbnUgcG9hdGUgZmkgcmVwcm9pZWN0YXQsIGF2ZcibaSBkb3XEgyBvcMibaXVuaeKAlGZpZSBjcmVhyJtpIHVuIHNldCBkZSBkYXRlIG1vemFpYyBpbmNsdXMgw65uIHJlZmVyaW7Im2UgZGluIHNldHVsIGR2cy4gZGUgZGF0ZSBtb3phaWMgw65uIHByb2llY8ibaWEgbmVjZXNhcsSDLCBzYXUgYWTEg3VnYSBmdW5jyJtpYSBkZSBSZXByb2llY3RhcmUgw65uIGxhbsibdWwgZGUgZnVuY8ibaWkgYWwgc2V0dWx1aSBkZSBkYXRlIG1vemFpYy4gVW4gYWx0IGV4ZW1wbHUgdXRpbGl6ZWF6xIMgYWNlYXN0xIMgZnVuY8ibaWUgZGUgcGUgcmVwZXJ1bCByYXN0ZXIgw65udHItdW4gc2V0IGRlIGRhdGUgbW96YWljLiBMYSB1dGlsaXphcmVhIGZ1bmPIm2llaSBkZSBSYXN0ZXIgQXJoaXZhdCwgdsSDIHB1dGXIm2kgZG9yaSBzxIMgaW50cm9kdWNlyJtpIGZ1bmPIm2lhIGRlIFJlcHJvaWVjdGFyZSBhc3RmZWwgw65uY8OidCBhcmhpdmEgc8SDIGZpZSBjcmVhdMSDIMOubiBub3VhIHByb2llY8ibaWUuIFJlcGVyZWxlIHJhc3RlciDDrm50ci11biBzZXQgZGUgZGF0ZSBtb3phaWMgcG9hdGUgZmkgYXJoaXZhdCBhdHVuY2kgY8OibmQgcHJlbHVjcmFyZWEgZXN0ZSBpbnRlbnPEgyDImWkgw65uY2VyY2HIm2kgc8SDIHB1YmxpY2HIm2kgdW4gc2VydmljaXUgZGUgaW1hZ2luaSBjYXJlIGVzdGUgcmFwaWQsIGbEg3LEgyBhcmhpdmFyZWEgw65udHJlZ3VsdWkgc2VydmljaXUgZGUgaW1hZ2luaS48L2Rpdj5cIixcblx0XHRyZXNhbXBsZU5hbWU6IFwiUmUtY29sZWN0YXJlYSBwcm9iZWxvclwiLFxuXHRcdHJlc2FtcGxlU25pcDogXCJNb2RpZmljxIMgZGltZW5zaXVuZWEgY2VsdWxlaSB1bnVpIHJhc3Rlci5cIixcblx0XHRyZXNhbXBsZURlc2M6IFwiRnVuY8ibaWEgZGUgUmVjb2xlY3RhcmUgYSBwcm9iZWxvciBtb2RpZmljxIMgZGltZW5zaXVuZWEgY2VsdWxlaSwgdGlwdWwgcmVjb2xlY3TEg3JpaSBzYXUgYW1iZWxlLjxkaXY+PGJyLz5GdW5jyJtpYSBkZSBSZWNvbGVjdGFyZSBhIHByb2JlbG9yIHRyZWJ1aWUgdXRpbGl6YXTEgyBkb2FyIGN1IGFudW1pdGUgY2VyaW7Im2UgZGUgY2FsY3VsOyBkZSBleGVtcGx1LCBhdHVuY2kgY8OibmQgY2FsY3VsYcibaSBtYWduaXR1ZGluZWEtZGlyZWPIm2lhIHbDom50dWx1aSBzYXUgY3VyZW50dWx1aSBjYXJlIHByZXN1cHVuZSBSZS1jb2xlY3RhcmVhIHByb2JlbG9yIGRpbiByZXpvbHXIm2lhIHN1cnPEgy48L2Rpdj5cIixcblx0XHRyb3VuZERvd25OYW1lOiBcIlJvdHVuamlyZSDDrm4gc2PEg2RlcmVcIixcblx0XHRyb3VuZERvd25TbmlwOiBcIkTEgyB1cm3Eg3RvYXJlYSB2YWxvYXJlIG1haSBtaWPEgyBhIHVudWkgbnVtxINyIMOubnRyZWcsIHJlcHJlemVudGF0IGNhIHB1bmN0IGZsb3RhbnQsIHBlbnRydSBmaWVjYXJlIGNlbHVsxIMgZGludHItdW4gcmFzdGVyLlwiLFxuXHRcdHJvdW5kRG93bkRlc2M6IFwiRnVuY8ibaWEgZGUgUm90dW5qaXJlIMOubiBTY8SDZGVyZSBkxIMgdXJtxIN0b3J1bCBudW3Eg3Igw65udHJlZyBtYWkgbWljLCBjYSB2YWxvYXJlIGEgdW51aSBwdW5jdCBmbG90YW50LCBwZW50cnUgZmllY2FyZSBwaXhlbCBkaW50ci11biByYXN0ZXIuXCIsXG5cdFx0cm91bmRVcE5hbWU6IFwiUm90dW5qaXJlIMOubiBjcmXImXRlcmVcIixcblx0XHRyb3VuZFVwU25pcDogXCJExIMgdXJtxIN0b2FyZWEgdmFsb2FyZSBtYWkgbWFyZSBhIHVudWkgbnVtxINyIMOubnRyZWcsIHJlcHJlemVudGF0IGNhIHB1bmN0IGZsb3RhbnQsIHBlbnRydSBmaWVjYXJlIGNlbHVsxIMgZGludHItdW4gcmFzdGVyLlwiLFxuXHRcdHJvdW5kVXBEZXNjOiBcIkZ1bmPIm2lhIGRlIFJvdHVuamlyZSDDrm4gQ3JlyJl0ZXJlIGTEgyB1cm3Eg3RvcnVsIG51bcSDciDDrm50cmVnIG1haSBtYXJlLCBjYSB2YWxvYXJlIGEgdW51aSBwdW5jdCBmbG90YW50LCBwZW50cnUgZmllY2FyZSBwaXhlbCBkaW50ci11biByYXN0ZXIuXCIsXG5cdFx0c2VnbWVudE1lYW5TaGlmdE5hbWU6IFwiU2VnbWVudCBNZWFuIFNoaWZ0XCIsXG5cdFx0c2VnbWVudE1lYW5TaGlmdFNuaXA6IFwiR3J1cGVhesSDIHBpeGVsaWkgw65udmVjaW5hyJtpIGN1IGNhcmFjdGVyaXN0aWNpIHNwZWN0cmFsZSBhc2VtxINuxIN0b2FyZSDDrm4gc2VnbWVudGUuXCIsXG5cdFx0c2VnbWVudE1lYW5TaGlmdERlc2M6IFwiQWNlYXN0xIMgZnVuY8ibaWUgaWRlbnRpZmljxIMgb2JpZWN0ZWxlLCBvYmllY3RlbGUgc3BhyJtpYWxlIHNhdSBzZWdtZW50ZWxlIGRpbiBpbWFnaXN0aWNhIGR2cy4gZ3J1cMOibmQgw65tcHJldW7EgyBwaXhlbGlpIMOubnZlY2luYcibaSBjYXJlIGF1IGNhcmFjdGVyaXN0aWNpIHNwZWN0cmFsZSDImWkgc3BhyJtpYWxlIGFzZW3Eg27Eg3RvYXJlLiBQdXRlyJtpIGNvbnRyb2xhIHN1bWEgbml2ZWzEg3JpaSBzcGHIm2lhbGUgyJlpIHNwZWN0cmFsZSBwZW50cnUgYSBhanV0YSBsYSBkZXJpdmFyZWEgb2JpZWN0ZWxvciBzcGHIm2lhbGUgZGUgaW50ZXJlcy5cIixcblx0XHRzMVJhZGlvbWV0cmljQ2FsaWJyYXRpb25OYW1lOiBcIkNhbGlicmFyZWEgUmFkaW9tZXRyaWPEgyBTZW50aW5lbC0xXCIsXG5cdFx0czFSYWRpb21ldHJpY0NhbGlicmF0aW9uU25pcDogXCJFZmVjdHVlYXrEgyB0aXB1cmkgZGlmZXJpdGUgZGUgY2FsaWJyxINyaSByYWRpb21ldHJpY2UgcGUgZGF0ZWxlIFNlbnRpbmVsLTEuXCIsXG5cdFx0czFSYWRpb21ldHJpY0NhbGlicmF0aW9uRGVzYzogXCJBY2Vhc3TEgyBmdW5jyJtpZSByYXN0ZXIgZWZlY3R1ZWF6xIMgdHJlaSBjYWxpYnLEg3JpIGRpZmVyaXRlIHBlbnRydSBzZXR1cmlsZSBkZSBkYXRlIFNlbnRpbmVsIDEsIGluY2x1c2l2IGJldGEgemVybyDImWkgZ2FtbWEsIMiZaSBvYsibaW5lIHNldHVsIGRlIGRhdGUgY2FsaWJyYXQuIE9iaWVjdGl2dWwgY2FsaWJyxINyaWkgU0FSIGVzdGUgYWNlbGEgZGUgYSBhc2lndXJhIGltYWdpbmkgw65uIGNhcmUgdmFsb3JpbGUgcGl4ZWx1bHVpIHBvdCBmaSBhZmVyZW50ZSBkaXJlY3QgcmV0cm8tw65tcHLEg8iZdGllcmlpIHJhZGFydWx1aSBhZmVyZW50ZSBzY2VuZWkuIERlyJlpIGltYWdpbmlsZSBTQVIgbmVjYWxpYnJhdGUgc3VudCBzdWZpY2llbnRlIHBlbnRydSB1dGlsaXphcmUgY2FsaXRhdGl2xIMsIGltYWdpbmlsZSBTQVIgY2FsaWJyYXRlIHN1bnQgZXNlbsibaWFsZSBwZW50cnUgdXRpbGl6YXJlYSBjYW50aXRhdGl2xIMgYSBkYXRlbG9yIFNBUi48ZGl2Pjxici8+UHJlbHVjcmFyZWEgdGlwaWPEgyBhIGRhdGVsb3IgU0FSLCBjYXJlIHByb2R1Y2UgaW1hZ2luaSBkZSBOaXZlbCAxLCBudSBpbmNsdWRlIGNvcmVjyJtpaSByYWRpb21ldHJpY2UgyJlpIHLEg23Dom5lIG8gcG9sYXJpemFyZSByYWRpb21ldHJpY8SDIHNlbW5pZmljYXRpdsSDLiBQcmluIHVybWFyZSwgZXN0ZSBuZWNlc2FyIHPEgyBzZSBhcGxpY2UgbyBjb3JlY8ibaWUgcmFkaW9tZXRyaWPEgyBpbWFnaW5pbG9yIFNBUiBhc3RmZWwgw65uY8OidCB2YWxvcmlsZSBwaXhlbHVsdWkgYWxlIGltYWdpbmlsb3IgcmVwcmV6aW50xIMgY3UgYWRldsSDcmF0IHJldHJvLcOubXByxIPImXRpZXJlYSByYWRhcnVsdWkgc3VwcmFmZcibZWkgcmVmbGVjdGFudGUuIENvcmVjyJtpYSByYWRpb21ldHJpY8SDIGVzdGUgbmVjZXNhcsSDIMiZaSBwZW50cnUgY29tcGFyYcibaWEgaW1hZ2luaWxvciBTQVIgYWNoaXppyJtpb25hdGUgY3UgZGl2ZXLImWkgc2Vuem9yaSBzYXUgYWNoaXppyJtpb25hdGUgZGluIGFjZWxhyJlpIHNlbnpvciDDrm4gbW9tZW50ZSBkaWZlcml0ZSwgw65uIG1vZHVyaSBkaWZlcml0ZSBzYXUgcHJlbHVjcmF0xIMgZGUgcHJvY2Vzb2FyZSBkaWZlcml0ZS48L2Rpdj5cIixcblx0XHRzMVRoZXJtYWxOb2lzZVJlbW92YWxOYW1lOiBcIkVsaW1pbmFyZWEgWmdvbW90dWx1aSBUZXJtaWMgU2VudGluZWwtMVwiLFxuXHRcdHMxVGhlcm1hbE5vaXNlUmVtb3ZhbFNuaXA6IFwiRWxpbWluxIMgemdvbW90dWwgdGVybWljIGRlIGxhIGRhdGVsZSBTZW50aW5lbC0xLlwiLFxuXHRcdHMxVGhlcm1hbE5vaXNlUmVtb3ZhbERlc2M6IFwiQ29yZWPIm2lhIHpnb21vdHVsdWkgdGVybWljIHBvYXRlIGZpIGFwbGljYXTEgyBwcm9kdXNlbG9yIFNlbnRpbmVsLTEgTGV2ZWwtMSBTaW5nbGUgTG9vayBDb21wbGV4IChTTEMpIGPDonQgyJlpIHByb2R1c2Vsb3IgTGV2ZWwtMSBHcm91bmQgUmFuZ2UgRGV0ZWN0aW9uIChHUkQpIGNhcmUgbnUgYXUgZm9zdCBkZWphIGNvcmVjdGF0ZS4gT3BlcmF0b3J1bCBwb2F0ZSBlbGltaW5hIGFjZWFzdMSDIGNvcmVjyJtpZSBwZSBiYXphIGFkbm90xINyaWxvciBwcm9kdXN1bHVpIHBlbnRydSBhIHJlaW50cm9kdWNlIHNlbW5hbHVsIGRlIHpnb21vdCBlbGltaW5hdCBwZW50cnUgYSByZWFsaXphIHByb2R1c3VsIG9yaWdpbmFsLiBBZG5vdMSDcmlsZSBwcm9kdXN1bHVpIHZvciBmaSBhY3R1YWxpemF0ZSBjb3Jlc3B1bnrEg3RvciBwZW50cnUgYSBwZXJtaXRlIHJlYXBsaWNhcmVhIGNvcmVjyJtpZWkuIFwiLFxuXHRcdHNldE51bGxOYW1lOiBcIlNldGFyZSBudWzEg1wiLFxuXHRcdHNldE51bGxTbmlwOiBcIlNldGFyZSBOdWzEgyBzdGFiaWxlyJl0ZSBhbXBsYXNhcmVhIGNlbHVsZWxvciBpZGVudGlmaWNhdGUgY8SDdHJlIE5vRGF0YSBwZSBiYXphIHVudWkgY3JpdGVyaXUgc3BlY2lmaWNhdC4gUmV0dXJuZWF6xIMgTm9EYXRhIGRhY8SDIGV2YWx1YXJlYSBjb25kacibaW9uYWzEgyBlc3RlIHJlYWzEgywgyJlpIHJldHVybmVhesSDIHZhbG9hcmVhIHNwZWNpZmljYXTEgyBkZSB1biBhbHQgcmFzdGVyIGRhY8SDIGVzdGUgZmFsc8SDLlwiLFxuXHRcdHNldE51bGxEZXNjOiBcIkZ1bmPIm2lhIGRlIFNldGFyZSBOdWzEgyBzdGFiaWxlyJl0ZSBwaXhlbGlpIGlkZW50aWZpY2HIm2kgY8SDdHJlIE5vRGF0YSwgcGUgYmF6YSBjcml0ZXJpaWxvciBzcGVjaWZpY2UuIFJldHVybmVhesSDIE5vRGF0YSBkYWPEgyBldmFsdWFyZWEgY29uZGnIm2lvbmFsxIMgZXN0ZSByZWFsxIMgKDEpIMiZaSByZXR1cm5lYXrEgyB2YWxvYXJlYSBzcGVjaWZpY2F0xIMgw65uIFJhc3RlcnVsIEZhbHMgZGFjxIMgbyBldmFsdWFyZSBjb25kacibaW9uYXTEgyBlc3RlIGZhbHPEgyAoMCkuIEFjZXN0IGNyaXRlcml1IGVzdGUgc3BlY2lmaWNhdCBkZSByZXp1bHRhdHVsIHVuZWkgZnVuY8ibaWkgbWF0ZW1hdGljZSBsb2dpY2UsIGNhcmUgdmEgZmkgUmFzdGVydWwgZGUgaW50cmFyZS5cIixcblx0XHRzaGFkZWRSZWxpZWZOYW1lOiBcIlJlbGllZiBjdSB1bWJyaXJlXCIsXG5cdFx0c2hhZGVkUmVsaWVmU25pcDogXCJDcmVlYXrEgyBvIHJlcHJlemVudGFyZSBjdSBiZW56aSBtdWx0aXBsZSwgY29kaWZpY2F0xIMgZHVwxIMgY3Vsb3JpLCAzRCBhIHN1cHJhZmXIm2VpLCBjdSBwb3ppyJtpYSByZWxhdGl2xIMgYSBzb2FyZWx1aSBsdWF0xIMgw65uIGNvbnNpZGVyYXJlIHBlbnRydSB1bWJyaXJlYSBpbWFnaW5paS5cIixcblx0XHRzaGFkZWRSZWxpZWZEZXNjOiBcIkZ1bmPIm2lhIGRlIHJlbGllZiBjdSB1bWJyaXJlIGNyZWVhesSDIG8gcmVwcmV6ZW50YXJlIGNvbG9yIDNEIGEgdGVyZW51bHVpIHByaW4gZnV6aW9uYXJlYSBpbWFnaW5pbG9yIGRpbiBtZXRvZGVsZSBjb2RpZmljYXRlIGR1cMSDIGVsZXZhyJtpZSDImWkgZGUgaGHImXVyYXJlLiBBY2Vhc3TEgyBmdW5jyJtpZSB1dGlsaXplYXrEgyBwcm9wcmlldMSDyJtpbGUgYWx0aXR1ZGluaWkgyJlpIGF6aW11dHVsdWkgcGVudHJ1IGEgc3BlY2lmaWNhIHBvemnIm2lhIHNvYXJlbHVpLmRpdj48YnIvPjwvZGl2PlwiLFxuXHRcdHNpbkhOYW1lOiBcIlNpbkhcIixcblx0XHRzaW5IU25pcDogXCJDYWxjdWxlYXrEgyBzaW51c3VsIGhpcGVyYm9saWMgYWwgY2VsdWxlbG9yIGRpbnRyLXVuIHJhc3Rlci5cIixcblx0XHRzaW5IRGVzYzogXCJGdW5jyJtpYSBjYWxjdWxlYXrEgyBzaW51c3VsIGhpcGVyYm9saWMgYWwgcGl4ZWxpbG9yIGRpbnRyLXVuIHJhc3Rlci5cIixcblx0XHRzaW5OYW1lOiBcIlNpblwiLFxuXHRcdHNpblNuaXA6IFwiQ2FsY3VsZWF6xIMgc2ludXN1bCBjZWx1bGVsb3IgZGludHItdW4gcmFzdGVyLlwiLFxuXHRcdHNpbkRlc2M6IFwiRnVuY8ibaWEgY2FsY3VsZWF6xIMgc2ludXN1bCBhbCBwaXhlbGlsb3IgZGludHItdW4gcmFzdGVyLlwiLFxuXHRcdHNsb3BlTmFtZTogXCJQYW50xINcIixcblx0XHRzbG9wZVNuaXA6IFwiQ2FsY3VsZWF6xIMgcmF0YSBkZSBzY2hpbWJhcmUgZGUgbGEgbyB2YWxvYXJlIGEgcGl4ZWx1bHVpIGxhIHZlY2luaWkgc8SDaS5cIixcblx0XHRzbG9wZURlc2M6IFwiQWNlYXN0xIMgZnVuY8ibaWUgcmFzdGVyIGNhbGN1bGVhesSDIHBhbnRhIGNhcmUgcmVwcmV6aW50xIMgcmF0YSBkZSBtb2RpZmljYXJlIGEgZWxldmHIm2llaSBwZW50cnUgZmllY2FyZSBjZWx1bMSDIGEgbW9kZWx1bHVpIGRpZ2l0YWwgZGUgZWxldmHIm2llIChERU0pLiBFc3RlIHByaW1hIHZhbG9hcmUgZGVyaXZhdMSDIGRpbnRyLXVuIERFTS48ZGl2Pjxici8+QWNlYXN0xIMgZnVuY8ibaWUgdXRpbGl6ZWF6xIMgbyBmdW5jyJtpZSBhdGFuKCkgYWNjZWxlcmF0xIMuIEFjZWFzdGEgZXN0ZSBkZSDImWFzZSBvcmkgbWFpIHJhcGlkxIMsIGlhciBlcm9hcmVhIGRlIGFwcm94aW1hcmUgZXN0ZSDDrm50b3RkZWF1bmEgbWFpIG1pY8SDIGRlIDAsMyBncmFkZS48L2Rpdj5cIixcblx0XHRzcGVja2xlTmFtZTogXCLDjm1wcsSDyJl0aWVyZVwiLFxuXHRcdHNwZWNrbGVTbmlwOiBcIlByZXppbnTEgyBmaWx0cmUgcGVudHJ1IGVsaW1pbmFyZWEgemdvbW90dWx1aSBzZXR1cmlsb3IgZGUgZGF0ZSBhbGUgcmFkYXJlbG9yIGN1IGRlc2NoaWRlcmUgc2ludGV0aWPEgy5cIixcblx0XHRzcGVja2xlRGVzYzogXCLDjm1wcsSDyJl0aWVyZWEgZXN0ZSB6Z29tb3R1bCBkZSDDrm5hbHTEgyBmcmVjdmVuyJvEgyBkZSBwZSBkYXRlbGUgdW51aSByYWRhci4gSW1hZ2luaWxlIGdlbmVyYXRlIGRlIHNpc3RlbWVsZSBkZSByYWRhciBjdSBkZXNjaGlkZXJlIHNpbnRldGljxIMgKFNBUikgc3VudCBmb2FydGUgc3VwdXNlIGVmZWN0ZWxvciBkZSDDrm1wcsSDyJl0aWVyZSBkaW4gY2F1emEgcHJlbHVjcsSDcmlpIHNlbW5hbGVsb3Igw65tcHLEg8iZdGlhdGUgyJlpIGludGVyZmVyZW7Im2VpIHVuZGVsb3IgZWxlY3Ryb21hZ25ldGljZSDDrm1wcsSDyJl0aWF0ZSBkZSBwZSBzdXByYWZlyJtlIHNhdSBvYmllY3RlLiBBY2Vhc3TEgyBmdW5jyJtpZSBkZSDDjm1wcsSDyJl0aWVyZSBmaWx0cmVhesSDIHNldHVsIGRlIGRhdGUgcmFkYXIgw65tcHLEg8iZdGlhdGUgyJlpIGFwbGF0aXplYXrEgyB6Z29tb3R1bCDDrm4gdGltcCBjZSByZcibaW5lIG1hcmdpbmlsZSBzYXUgb2JpZWN0ZWxlIHNwYcibaWFsZSBjbGFyZSBkaW4gaW1hZ2luZS5cIixcblx0XHRzcGVjdHJhbENvbnZlcnNpb25OYW1lOiBcIkNvbnZlcnNpZSBTcGVjdHJhbMSDXCIsXG5cdFx0c3BlY3RyYWxDb252ZXJzaW9uU25pcDogXCJBcGxpY8SDIG8gbWF0cmljZSB1bmVpIGltYWdpbmkgY3UgYmVuemkgbXVsdGlwbGUuXCIsXG5cdFx0c3BlY3RyYWxDb252ZXJzaW9uRGVzYzogXCJGdW5jyJtpYSBkZSBDb252ZXJzaWUgU3BlY3RyYWzEgyBhcGxpY8SDIG8gbWF0cmljZSB1bmVpIGltYWdpbmkgbXVsdGliYW5kxIMgcGVudHJ1IGEgYWZlY3RhIHZhbG9yaWxlIGRlIGN1bG9hcmUgYWxlIGllyJlpcmlpLjxkaXY+PGJyLz5VbmlpIHNlbnpvcmkgbnUgY29sZWN0ZWF6xIMgYmVuemkgYWxiYXN0cmUgZGluIGNhdXphIHVudWkgcmFwb3J0IHJlZHVzIMOubnRyZSBzZW1uYWwgyJlpIHpnb21vdC4gRGUgZXhlbXBsdSwgYWNlc3QgbHVjcnUgcG9hdGUgZmkgZm9sb3NpdCBwZW50cnUgYSBjb252ZXJ0aSBvIGltYWdpbmUgaW5mcmFyb8iZdSBjb2xvciBmYWxzxIMgw65udHItbyBwc2V1ZG8taW1hZ2luZSBkZSBjdWxvYXJlIG5hdHVyYWzEgy48L2Rpdj5cIixcblx0XHRzcXVhcmVSb290TmFtZTogXCJSxINkxINjaW7EgyBwxIN0cmF0xINcIixcblx0XHRzcXVhcmVSb290U25pcDogXCJDYWxjdWxlYXrEgyByxINkxINjaW5hIHDEg3RyYXTEgyBhIHZhbG9yaWxvciBjZWx1bGVsb3IgZGludHItdW4gcmFzdGVyLlwiLFxuXHRcdHNxdWFyZVJvb3REZXNjOiBcIkZ1bmPIm2lhIFLEg2TEg2NpbsSDIFDEg3RyYXTEgyBjYWxjdWxlYXrEgyByxINkxINjaW5hIHDEg3RyYXTEgyBhIHZhbG9yaWxvciBwaXhlbHVsdWkgZGludHItdW4gcmFzdGVyLlwiLFxuXHRcdHNxdWFyZU5hbWU6IFwiUMSDdHJhdFwiLFxuXHRcdHNxdWFyZVNuaXA6IFwiQ2FsY3VsZWF6xIMgcMSDdHJhdHVsIHZhbG9yaWxvciBjZWx1bGVpIGRpbnRyLXVuIHJhc3Rlci5cIixcblx0XHRzcXVhcmVEZXNjOiBcIlDEg3RyYXQgY2FsY3VsZWF6xIMgcMSDdHJhdHVsIHZhbG9yaWxvciBwaXhlbHVsdWkgZGludHItdW4gcmFzdGVyLlwiLFxuXHRcdHN0YXRpc3RpY3NIaXN0b2dyYW1OYW1lOiBcIlN0YXRpc3RpY8SDIMiZaSBIaXN0b2dyYW3Eg1wiLFxuXHRcdHN0YXRpc3RpY3NIaXN0b2dyYW1TbmlwOiBcIkRlZmluaXJlYSBzYXUgYXNvY2llcmVhIHN0YXRpc3RpY2lpIMiZaSBoaXN0b2dyYW1laS5cIixcblx0XHRzdGF0aXN0aWNzSGlzdG9ncmFtRGVzYzogXCJGdW5jyJtpYSBTdGF0aXN0aWPEgyDImWkgSGlzdG9ncmFtxIMgZXN0ZSB1dGlsaXphdMSDIHBlbnRydSBhIGRlZmluaSBzdGF0aXN0aWNhIMiZaSBoaXN0b2dyYW1hIHVudWkgcmFzdGVyLiBQdXRlyJtpIGludHJvZHVjZSBhY2Vhc3TEgyBmdW5jyJtpZSBsYSBzZsOicsiZaXR1bCBsYW7Im3VsdWkgZGUgZnVuY8ibaW9uYXJlIHBlbnRydSBhIGRlc2NyaWUgc3RhdGlzdGljYSDImWkgaGlzdG9ncmFtYSB1bnVpIMiZYWJsb24gY3UgZnVuY8ibaWUgcmFzdGVyIChSRlQpLiBBY2VzdCBsdWNydSBwb2F0ZSBmaSBuZWNlc2FyIHBlbnRydSBhIGNvbnRyb2xhIGFmaciZYWp1bCBpbXBsaWNpdCBhbCByZXp1bHRhdHVsdWkgcHJlbHVjcsSDcmlpLCDDrm4gc3BlY2lhbCBsYSBkZWZpbmlyZWEgdW51aSBsYW7ImyBkZSBmdW5jyJtpb25hcmUgY2FyZSBjb27Im2luZSBtdWx0ZSBmdW5jyJtpaS48ZGl2Pjxici8+UHV0ZcibaSBkZWZpbmkgc3RhdGlzdGljaWxlIHByaW4gaW50cm9kdWNlcmVhIHZhbG9yaWxvciBzYXUgaW1wb3J0YXJlYSBkaW50ci11biBzZXQgZGUgZGF0ZSByYXN0ZXIgc2F1IHVuIGZpyJlpZXIgWE1MLiBIaXN0b2dyYW1lbGUgcG90IGZpIGRlZmluaXRlIGRvYXIgcHJpbiBpbXBvcnRhcmVhIHVudWkgZmnImWllci48L2Rpdj5cIixcblx0XHRzdGF0aXN0aWNzTmFtZTogXCJTdGF0aXN0aWPEg1wiLFxuXHRcdHN0YXRpc3RpY3NTbmlwOiBcIkNhbGN1bGVhesSDIHN0YXRpc3RpY2EgZm9jYWzEgyBwZW50cnUgZmllY2FyZSBwaXhlbCBhIHVuZWkgaW1hZ2luaSBiYXphdGUgcGUgbyB2ZWNpbsSDdGF0ZSBmb2NhbMSDIGRlZmluaXTEgy5cIixcblx0XHRzdGF0aXN0aWNzRGVzYzogXCJGdW5jyJtpYSBkZSBTdGF0aXN0aWPEgyBjYWxjdWxlYXrEgyBzdGF0aXN0aWNhIGZvY2FsxIMgcGVudHJ1IGZpZWNhcmUgcGl4ZWwgYWwgdW5laSBpbWFnaW5pIGJhemF0ZSBwZSBvIHZlY2luxIN0YXRlIGZvY2FsxIMgZGVmaW5pdMSDLjxkaXY+PGJyLz5GdW5jyJtpYSBTdGF0aXN0aWPEgyBwb2F0ZSBmaSB1dGlsaXphdMSDIHBlbnRydSBhIHVtcGxlIGxpbmlpbGUgbGlwc8SDIGRpbnRyLW8gaW1hZ2luZS4gTGluaWlsZSBsaXBzxIMgc3VudCBwcm92b2NhdGUgYWRlc2VhIGRlIHByb2JsZW1lIGFsZSBzZW56b3J1bHVpIHVuZGUgbnUgc3VudCBjb2xlY3RhdGUgZGF0ZS4gQWNlc3QgbHVjcnUgcy1hIMOubnTDom1wbGF0IGxhIHNlbnpvcmkgY3VtIGFyIGZpIExhbmRzYXQgNydzIEVuaGFuY2VkIFRoZW1hdGljIE1hcHBlciBQbHVzIChFVE0rKS4gQWNlc3RlIGRhdGUgbGlwc8SDIHByb3ZvYWPEgyBwcm9ibGVtZSBwZW50cnUgYW5hbGl6xIMgyJlpIGxhIHN0dWRpZXJlYSBpbWFnaW5pbG9yLiBOdSBzZSBwb3QgZmFjZSBwcmVhIG11bHRlIGxhIHV0aWxpemFyZWEgaW1hZ2luaWkgcGVudHJ1IGFuYWxpesSDOyB0b3R1yJlpLCBkYWPEgyBhIGV4aXN0YXQgbyBpbWFnaW5lIHN1cHJhcHVzxIMsIGFjZWFzdGEgcG9hdGUgZmkgZm9sb3NpdMSDIMOubiBsb2N1bCBjb27Im2ludXR1bHVpIGxpcHPEgy4gQWNlbGHImWkgbHVjcnUgcG9hdGUgZmkgcmVhbGl6YXQgZGFjxIMgaW1hZ2luaWxlIHN1bnQgZm9sb3NpdGUgcGVudHJ1IHZpenVhbGl6YXJlLiBUb3R1yJlpLCBudSDDrm50b3RkZWF1bmEgZXhpc3TEgyBvIGltYWdpbmUgc3VwbGltZW50YXLEgyBwZW50cnUgYSBjb21wbGV0YSBjb27Im2ludXR1bCBsaXBzxIMsIGHImWFkYXIgYWNlc3RhIHRyZWJ1aWUgZGVyaXZhdCBkaW4gZGF0ZWxlIGV4aXN0ZW50ZS48L2Rpdj5cIixcblx0XHRzdHJlYW1MaW5rTmFtZTogXCJTdHJlYW0gTGlua1wiLFxuXHRcdHN0cmVhbUxpbmtTbmlwOiBcIkFsb2PEgyB2YWxvcmkgdW5pY2Ugc2VjyJtpdW5pbG9yIHVuZWkgcmXIm2VsZSBsaW5pYXJlIGRlIHJhc3RlciDDrm50cmUgaW50ZXJzZWPIm2lpLlwiLFxuXHRcdHN0cmVhbUxpbmtEZXNjOiBcIkZ1bmPIm2lhIGdsb2JhbMSDIFN0cmVhbSBMaW5rIGFsb2PEgyB2YWxvcmkgdW5pY2Ugc2VjyJtpdW5pbG9yIHVuZWkgcmXIm2VsZSBsaW5pYXJlIGRlIHJhc3RlciDDrm50cmUgaW50ZXJzZWPIm2lpLjxkaXY+PGJyLz5MaW5rLXVyaWxlIHN1bnQgc2VjyJtpdW5pbGUgdW51aSBjYW5hbCBkZSBjdXJzIGNhcmUgY29uZWN0ZWF6xIMgZG91xIMgw65tYmluxINyaSBzdWNjZXNpdmUsIG8gw65tYmluYXJlIMiZaSBldmFjdWFyZWEsIHNhdSBvIMOubWJpbmFyZSDImWkgbGluaWEgZGUgc2VwYXJhyJtpZSBhIGFwZWxvciBkZSBsYSBzY3VyZ2VyZS4gw45uIGhpZHJvbG9naWUsIGFjZXN0ZSBzZWdtZW50ZSBkZSBjdXJzIHN1bnQgZGVudW1pdGUgY3Vyc3VyaSBkZSBhcMSDLiBPIMOubWJpbmFyZSBlc3RlIGFmZXJlbnTEgyB1bnVpIHB1bmN0IGRlIGN1cmdlcmUgyJlpIGFqdXTEgyBsYSBkZWxpbWl0YXJlYSB1bnVpIHN1Yi1iYXppbiBkZSByZWNlcMibaWUgc2F1IHNjdXJnZXJlLjwvZGl2PlwiLFxuXHRcdHN0cmV0Y2hOYW1lOiBcIsOObnRpbmRlcmVcIixcblx0XHRzdHJldGNoU25pcDogXCJBbXBsaWZpY8SDIG8gaW1hZ2luZSBwcmluIGFqdXN0YXJlYSBpbnRlcnZhbHVsdWkgZGUgdmFsb3JpIGFmaciZYXRlLiBBY2VzdCBsdWNydSBudSBtb2RpZmljxIMgdmFsb3JpbGUgcGl4ZWxpbG9yIGRlIGxhIGJhesSDLiBEYWPEgyB1biBwaXhlbCBhcmUgbyB2YWxvYXJlIMOubiBhZmFyYSBpbnRlcnZhbHVsdWkgc3BlY2lmaWNhdCwgYWNlYXN0YSB2YSBhcMSDcmVhIGZpZSBjYSB2YWxvYXJlIG1pbmltxIMsIGZpZSBjYSB2YWxvYXJlIG1heGltxIMuXCIsXG5cdFx0c3RyZXRjaERlc2M6IFwiRnVuY8ibaWEgZGUgw45udGluZGVyZSBhbXBsaWZpY8SDIG8gaW1hZ2luZSBwcmluIG1vZGlmaWNhcmVhIHByb3ByaWV0xIPIm2lsb3IgY3VtIGFyIGZpIGx1bWlub3ppdGF0ZWEsIGNvbnRyYXN0dWwgyJlpIGdhbW1hIHByaW4gdGlwdXJpIG11bHRpcGxlIGRlIMOubnRpbmRlcmUuIEFjZWFzdMSDIGZ1bmPIm2llIHV0aWxpemVhesSDIHN0YXRpc3RpY2lsZSBkZSBsYSByYXN0ZXJlIGRpbiBzZXR1bCBkZSBkYXRlIG1vemFpYzsgcHJpbiB1cm1hcmUsIGRhY8SDIGZvbG9zacibaSBhY2Vhc3TEgyBmdW5jyJtpZSwgdHJlYnVpZSBzxIMgdsSDIGFzaWd1cmHIm2kgY8SDIGF1IGZvc3QgY2FsY3VsYXRlIHN0YXRpc3RpY2lsZS48ZGl2Pjxici8+VGlwdWwgZGUgw65udGluZGVyZSBkZWZpbmXImXRlIG8gw65udGluZGVyZSBkZSBoaXN0b2dyYW3EgyBjYXJlIHNlIHZhIGFwbGljYSByYXN0ZXJlbG9yIHBlbnRydSBhbXBsaWZpY2FyZWEgYXNwZWN0dWx1aSBhY2VzdG9yYS4gw45udGluZGVyZWEgw65tYnVuxIN0xIPIm2XImXRlIGFzcGVjdHVsIGRhdGVsb3IgcHJpbiDDrm1wcsSDyJl0aWVyZWEgdmFsb3JpbG9yIHBpeGVsaWxvciBkZS1hIGx1bmd1bCB1bmVpIGhpc3RvZ3JhbWUgZGUgbGEgdmFsb3JpbGUgbWluaW3EgyDImWkgbWF4aW3EgyBkZWZpbml0ZSBjb25mb3JtIGFkw6JuY2ltaWkgYml0dWx1aS4gPC9kaXY+XCIsXG5cdFx0c3dhdGhOYW1lOiBcIlNlcmllXCIsXG5cdFx0c3dhdGhTbmlwOiBcIkludGVycG9sZWF6xIMgZGluIGdyaWxlIG5lcmVndWxhdGUgc2F1IGRhdGUgZGUgc2VyaWUuXCIsXG5cdFx0c3dhdGhEZXNjOiBcIlVuZWxlIHNldHVyaSBkZSBkYXRlIG5ldENERiBzYXUgSERGIMOuyJlpIHN0b2NoZWF6xIMgZ2VvbG9jYXJlYSBzdWIgZm9ybWEgdW5vciDImWlydXJpIGHImWV6YXRlIGxhIGRpc3RhbsibZSBuZXJlZ3VsYXRlLiBMYSBhZMSDdWdhcmVhIGFjZXN0b3Igc2V0dXJpIGRlIGRhdGUgw65udHItdW4gc2V0IGRlIGRhdGUgbW96YWljLCBmdW5jyJtpYSBkZSBzZXJpZSBpYSBkYXRlbGUgY3UgZ3JpbMSDIG5lcmVndWxhdMSDIMiZaSByZS1jb2xlY3RlYXrEgyBwcm9iZWxlIGFzdGZlbCDDrm5jw6J0IGZpZWNhcmUgcGl4ZWwgc8SDIGFpYsSDIGRpbWVuc2l1bmUgdW5pZm9ybcSDIMiZaSBzxIMgZmllIHDEg3RyYXQuPGRpdj48YnIvPkxhIGFkxIN1Z2FyZWEgdmFyaWFiaWxlbG9yIGRpbiBuZXRDREYgc2F1IEhERiDDrm50ci11biBzZXQgZGUgZGF0ZSBtb3phaWMsIGFjZXN0YSB2YSB2ZXJpZmljYSDDrm4gbW9kIGF1dG9tYXQgZGFjxIMgZGF0ZWxlIHN1bnQgZGlzcHVzZSDDrm4gyJlpcnVyaSByZWd1bGF0ZS4gw45uIGNheiBjb250cmFyLCBmdW5jyJtpYSBkZSBzZXJpZSBzZSBhcGxpY8SDIGF1dG9tYXQgcGVudHJ1IHRyYW5zZm9ybWFyZWEgYXV0b21hdMSDIGEgcmFzdGVydWx1aSBuZXJlZ3VsYXQgw65uIHB1bmN0ZSDImWkgYXBvaSDDrm50ci11biByYXN0ZXIgY3UgZ3JpbMSDIHJlZ3VsYXTEgy4gUHV0ZcibaSBtb2RpZmljYSBtZXRvZGEgZGUgaW50ZXJwb2xhcmUgyJlpIGRpbWVuc2l1bmVhIGNlbHVsZWkgZm9sb3NpdGUgw65uIGZ1bmPIm2lhIGRlIHNlcmllIGEgcmFzdGVydWx1aS4gUGVudHJ1IGRhdGVsZSBjdSByYXN0ZXIgY3UgZGlzdGFuyJvEgyByZWd1bGF0xIMsIG51IHNlIHZhIGFwbGljYSBpbnRlcnBvbGFyZWEsIGRhdGVsZSB2b3IgZmkgY2l0aXRlIGHImWEgY3VtIHN1bnQuPC9kaXY+XCIsXG5cdFx0dGFuSE5hbWU6IFwiVGFuSFwiLFxuXHRcdHRhbkhTbmlwOiBcIkNhbGN1bGVhesSDIHRhbmdlbnRhIGhpcGVyYm9saWPEgyBhIGNlbHVsZWxvciBkaW50ci11biByYXN0ZXIuXCIsXG5cdFx0dGFuSERlc2M6IFwiRnVuY8ibaWEgY2FsY3VsZWF6xIMgdGFuZ2VudGEgaGlwZXJib2xpY8SDIGEgcGl4ZWxpbG9yIGRpbnRyLXVuIHJhc3Rlci5cIixcblx0XHR0YW5OYW1lOiBcIlRhblwiLFxuXHRcdHRhblNuaXA6IFwiQ2FsY3VsZWF6xIMgdGFuZ2VudGEgY2VsdWxlbG9yIGRpbnRyLXVuIHJhc3Rlci5cIixcblx0XHR0YW5EZXNjOiBcIkZ1bmPIm2lhIGNhbGN1bGVhesSDIHRhbmdlbnRhIHBpeGVsaWxvciBkaW50ci11biByYXN0ZXIuIFwiLFxuXHRcdHRhc3NlbGVkQ2FwTmFtZTogXCJUYXNzZWxlZCBDYXAgKEthdXRoLVRob21hcylcIixcblx0XHR0YXNzZWxlZENhcFNuaXA6IFwiQ2FsY3VsZWF6xIMgbml2ZWx1cmlsZSBkZSB2ZWdldGHIm2llLCB1bWlkaXRhdGUgyJlpIGx1bWlub3ppdGF0ZS4gQWNlYXN0xIMgdGVobmljxIMgc2UgYmF6ZWF6xIMgcGUgY29lZmljaWVuyJtpIGNhcmUgdHJlYnVpZSBjYWxjdWxhyJtpIMOubiBtb2Qgc3BlY2lmaWMgcGVudHJ1IHVuIHNlbnpvci5cIixcblx0XHR0YXNzZWxlZENhcERlc2M6IFwiVHJhbnNmb3JtYXJlYSBUYXNzZWxlZCBDYXAgKEthdXRoLVRob21hcykgZXN0ZSBjcmVhdMSDIHBlbnRydSBhIGFuYWxpemEgyJlpIHJlcHJlemVudGEgZmVub21lbm9sb2dpYSB2ZWdldGHIm2llaSDImWkgbW9kaWZpY8SDcmlsZSBkZSBkZXp2b2x0YXJlIHVyYmFuxIMgZGV0ZWN0YXRlIGRlIGRpdmVyc2Ugc2lzdGVtZSBkZSBzZW56b3JpIGFpIHVub3Igc2F0ZWxpyJtpLiBBY2Vhc3RhIGVzdGUgY3Vub3NjdXTEgyBzdWIgZGVudW1pcmVhIGRlIHRyYW5zZm9ybWFyZWEgVGFzc2VsZWQgQ2FwIGRhdG9yaXTEgyBmb3JtZWkgZGlzdHJpYnXIm2llaSBncmFmaWNlIGEgZGF0ZWxvci4gVHJhbnNmb3JtYXJlYSBhIG9mZXJpdCB1biByYcibaW9uYW1lbnQgcGVudHJ1IMiZYWJsb2FuZWxlIGRlc2NvcGVyaXRlIMOubiBkYXRlbGUgTGFuZHNhdCBNU1MgYWxlIGPDom1wdXJpbG9yIGFncmljb2xlIGNhIGZ1bmPIm2llIGEgY2ljbHVsdWkgZGUgdmlhyJvEgyBhbCByZWNvbHRlaS4gw45uIHByaW5jaXBpdSwgcGUgbcSDc3VyxIMgY2UgcmVjb2x0ZWxlIHNlIGRlenZvbHTEgyBkZSBsYSBzxINtw6JuyJvEgyBsYSBtYXR1cml0YXRlLCBleGlzdMSDIG8gY3JlyJl0ZXJlIG5ldMSDIMOubiBjZWVhIGNlIHByaXZlyJl0ZSBiYW5kYSBkZSBpbmZyYXJvyJl1IGFwcm9waWF0IMiZaSBvIGRlc2NyZciZdGVyZSDDrm4gY2VlYSBjZSBwcml2ZciZdGUgcmVmbGVjdGFuyJthIHJvyJlpZSBwZSBiYXphIGN1bG9yaWkgc29sdWx1aTxkaXY+PGJyLz5VdGlsaXRhdGVhIGFjZXN0ZWkgdHJhbnNmb3JtxINyaSBzLWEgZXh0aW5zIGRlIGxhIG1vbml0b3JpemFyZWEgcmVjb2x0ZWxvciBsYSBhbmFsaXphcmVhIMiZaSByZXByZXplbnRhcmVhIHZlZ2V0YcibaWVpIHBlbnRydSBhIHNwcmlqaW5pIG8gdmFyaWV0YXRlIGRlIGFwbGljYcibaWkgY3VtIGFyIGZpIHNpbHZpY3VsdHVyYSwgYWRtaW5pc3RyYXJlYSB2ZWdldGHIm2llaSBpbmR1c3RyaWFsZSwgcmVwcmV6ZW50YXJlYSDImWkgYWRtaW5pc3RyYXJlYSBlY29zaXN0ZW11bHVpLCBpbnZlbnRhcmllcmVhIMiZaSBtb25pdG9yaXphcmVhIHNlY2hlc3RyxINyaWkgyJlpIGNyZWRpdGVsb3IgZGUgY2FyYm9uLCBkZXp2b2x0xINyaWkgdXJiYW5lIMiZaSBtYWkgbXVsdGUuIERlIGFzZW1lbmVhLCBzLWEgZXh0aW5zIGRlIGxhIHNwcmlqaW5pcmVhIExhbmRzYXQgTVNTIHBlbnRydSBhIGluY2x1ZGUgyJlpIGFsdGUgc2lzdGVtZSBkZSBzYXRlbGl0IHBvcHVsYXJlIGN1bSBhciBmaSBMYW5kc2F0IFRNLCBMYW5kc2F0IEVUTSssIExhbmRzYXQgOCwgSUtPTk9TLCBRdWlja0JpcmQsIFdvcmxkVmlldy0yIMiZaSBzZW56b3JpIG11bHRpc3BlY3RyYWxpIFJhcGlkRXllLjwvZGl2PlwiLFxuXHRcdHRpbWVzTmFtZTogXCJUaW1waVwiLFxuXHRcdHRpbWVzU25pcDogXCLDjm5tdWzIm2XImXRlIHZhbG9yaWxlIGEgZG91xIMgcmFzdGVyZSBjZWx1bMSDIGN1IGNlbHVsxIMuXCIsXG5cdFx0dGltZXNEZXNjOiBcIkZ1bmPIm2lhIGRlIMOObm11bMibaXJlIMOubm11bMibZciZdGUgdmFsb3JpbGUgYSBkb3XEgyByYXN0ZXJlIHBpeGVsIGN1IHBpeGVsLlwiLFxuXHRcdHRyYW5zcG9zZUJpdHNOYW1lOiBcIlRyYW5zcHVuZXJlIEJpyJtpXCIsXG5cdFx0dHJhbnNwb3NlQml0c1NuaXA6IFwiRGVzZmFjZSBiacibaWkgcGl4ZWx1bHVpIGRlIGludHJhcmUgyJlpIMOuaSByZXByZXppbnTEgyBjb25mb3JtIGJpyJtpbG9yIHNwZWNpZmljYcibaSBkaW4gcGl4ZWx1bCBkZSBpZciZaXJlLiBTY29wdWwgYWNlc3RlaSBmdW5jyJtpaSBlc3RlIGFjZWxhIGRlIGEgbWFuaXB1bGEgYmnIm2lpIGRpbiBjw6J0ZXZhIGludHLEg3JpLCBjdW0gYXIgcHJvZHVzZWxlIGJlbnppaSBkZSBjYWxpdGF0ZSBMYW5kc2F0IDguXCIsXG5cdFx0dHJhbnNwb3NlQml0c0Rlc2M6IFwiRnVuY8ibaWEgZGUgVHJhbnNwdW5lcmUgQml0IGRlc2ZhY2UgYmnIm2lpIHBpeGVsdWx1aSBkZSBpbnRyYXJlIMiZaSDDrmkgcmVwcmV6aW50xIMgY29uZm9ybSBiacibaWxvciBzcGVjaWZpY2HIm2kgZGluIHBpeGVsdWwgZGUgaWXImWlyZS4gU2NvcHVsIGFjZXN0ZWkgZnVuY8ibaWkgZXN0ZSBhY2VsYSBkZSBhIG1hbmlwdWxhIGJpyJtpaSBkaW4gY8OidGV2YSBpbnRyxINyaSwgY3VtIGFyIGZpIHByb2R1c2VsZSBiZW56aWkgZGUgY2FsaXRhdGUgTGFuZHNhdCA4LlwiLFxuXHRcdHVuaXRDb252ZXJzaW9uTmFtZTogXCJDb252ZXJzaWEgVW5pdMSDyJtpaVwiLFxuXHRcdHVuaXRDb252ZXJzaW9uU25pcDogXCJNb2RpZmljxIMgdmFsb3JpbGUgZGludHItbyB1bml0YXRlIGRlIG3Eg3N1csSDIGxhIGFsdGEuXCIsXG5cdFx0dW5pdENvbnZlcnNpb25EZXNjOiBcIkFjZWFzdMSDIGZ1bmPIm2llIHRyYW5zZm9ybcSDIHBpeGVsaWkgZGludHItbyB1bml0YXRlIMOubnRyLW8gYWx0xIMgdW5pdGF0ZS4gU3ByaWppbsSDIGNvbnZlcnNpYSBkaXN0YW7Im2VpLCB2aXRlemVpIMiZaSB0ZW1wZXJhdHVyaWkuXCIsXG5cdFx0dmVjdG9yRmllbGROYW1lOiBcIkPDom1wIHZlY3RvclwiLFxuXHRcdHZlY3RvckZpZWxkU25pcDogXCJQcmV6aW50xIMgc2V0dXJpIGRlIGRhdGUgY3UgbWFnbml0dWRpbmUgKHUpIMiZaSBkaXJlY8ibaWUgKHYpIHN1YiBmb3JtYSB1bm9yIHPEg2dlyJtpIHVuZGUgbWFnbml0dWRpbmVhIGVzdGUgcmVwcmV6ZW50YXTEgyBwcmluIGRpbWVuc2l1bmUgaWFyIGRpcmVjyJtpYSBlc3RlIHJlcHJlemVudGF0xIMgcHJpbiB1bmdoaXVsIHPEg2dlyJtpaS5cIixcblx0XHR2ZWN0b3JGaWVsZERlc2M6IFwiRnVuY8ibaWEgQ8OibXAgVmVjdG9yIGVzdGUgdXRpbGl6YXTEgyBwZW50cnUgYSBjb21wdW5lIMiZaSBjb252ZXJ0aSBkb3XEgyByYXN0ZXJlIMOubnRyLXVuIHJhc3RlciBjdSBkb3XEgyBiZW56aSBjYXJlIGVzdGUgZmllIGRlIHRpcHVsIGRhdGVsb3IgbWFnbml0dWRpbmUtZGlyZWPIm2llIHNhdSBkZSB0aXB1bCBkYXRlbG9yIFUtVi48ZGl2Pjxici8+VW5lb3JpLCB2YWxvYXJlYSBVIGVzdGUgZGVudW1pdMSDIGNhIGZpaW5kIHZpdGV6YSB6b25hbMSDLCBpYXIgdmFsb2FyZWEgViBlc3RlIHVuZW9yaSBkZW51bWl0xIMgdml0ZXphIG1lcmlkaW9uYWzEgy48L2Rpdj5cIixcblx0XHR2aWV3c2hlZDJOYW1lOiBcIlJhesSDIHZpenVhbMSDXCIsXG5cdFx0dmlld3NoZWQyU25pcDogXCJEZXRlcm1pbsSDIGxvY2HIm2lpbGUgZGUgcGUgbyBzdXByYWZhyJvEgyByYXN0ZXIgY2FyZSBzdW50IHZpemliaWxlIHVudWkgc2V0IGRlIG9iaWVjdGUgc3BhyJtpYWxlIG9ic2VydmF0b2FyZSwgZm9sb3NpbmQgbWV0b2RlIGdlb2RlemljZS5cIixcblx0XHR2aWV3c2hlZDJEZXNjOiBcIkZ1bmPIm2lhIFJhesSDIHZpenVhbMSDIGRldGVybWluxIMgbG9jYcibaWlsZSBkZSBwZSBvIHN1cHJhZmHIm8SDIHJhc3RlciBjYXJlIHN1bnQgdml6aWJpbGUgdW51aSBzZXQgZGUgb2JpZWN0ZSBzcGHIm2lhbGUgb2JzZXJ2YXRvYXJlLCBmb2xvc2luZCBtZXRvZGUgZ2VvZGV6aWNlPGRpdj48YnIvPlZpemliaWxpdGF0ZWEgZmllY8SDcnVpIGNlbnRydSBkZSBwaXhlbCBlc3RlIGRldGVybWluYXTEgyBkZSB1biB0ZXN0IHBlbnRydSBsaW5pYSBkZSB2aXppYmlsaXRhdGUgw65udHJlIMibaW50xIMgyJlpIGZpZWNhcmUgb2JzZXJ2YXRvci4gRGFjxIMgdW4gb2JzZXJ2YXRvciBwb2F0ZSB2ZWRlYSDIm2ludGEgbGEgY2VudHJ1bCBwaXhlbHVsdWksIHBpeGVsdWwgZXN0ZSBjb25zaWRlcmF0IHZpemliaWwuIEFjZXN0IGluc3RydW1lbnQgaWEgw65uIGNvbnNpZGVyYXJlIMOubnRvdGRlYXVuYSBjdXJidXJhIHDEg23Dom50dWx1aSBsYSBzdGFiaWxpcmVhIHZpemliaWxpdMSDyJtpaS48L2Rpdj5cIixcblx0XHR3YXRlcnNoZWROYW1lOiBcIkJhemluIGhpZHJvZ3JhZmljXCIsXG5cdFx0d2F0ZXJzaGVkU25pcDogXCJTdGFiaWxlyJl0ZSB6b25hIGRlIGNvbnRyaWJ1yJtpZSBkZSBkZWFzdXByYSB1bnVpIHNldCBkZSBjZWx1bGUgZGludHItdW4gcmFzdGVyXCIsXG5cdFx0d2F0ZXJzaGVkRGVzYzogXCJGdW5jyJtpYSBnbG9iYWzEgyBSYXrEgyBWaXp1YWzEgyBzdGFiaWxlyJl0ZSB6b25hIGRlIGNvbnRyaWJ1yJtpZSBkZSBkZWFzdXByYSB1bnVpIHNldCBkZSBwaXhlbGkgZGludHItdW4gcmFzdGVyLiBSYXplbGUgdml6dWFsZSBzdW50IGRlbGltaXRhdGUgZGUgdW4gcmFzdGVyIGRlIGRpcmVjyJtpZSBhIGZsdXh1bHVpIGNhcmUgaWRlbnRpZmljxIMgZGlyZWPIm2lhIGZsdXh1bHVpIGRpbiBmaWVjYXJlIHBpeGVsLlwiLFxuXHRcdHdlaWdodGVkT3ZlcmxheU5hbWU6IFwiU3VwcmFwdW5lcmUgcG9uZGVyYXTEg1wiLFxuXHRcdHdlaWdodGVkT3ZlcmxheVNuaXA6IFwiU3VwcmFwdW5lIG1haSBtdWx0ZSByYXN0ZXJlIGZvbG9zaW5kIG8gc2NhcsSDIGRlIG3Eg3N1csSDIMiZaSBvIGdyZXV0YXRlIGNvbXVuxIMgY29uZm9ybSBpbXBvcnRhbsibZWkgYWNlc3RlaWEuXCIsXG5cdFx0d2VpZ2h0ZWRPdmVybGF5RGVzYzogXCJBY2Vhc3TEgyBmdW5jyJtpZSB2xIMgcGVybWl0ZSBzxIMgc3VwcmFwdW5lyJtpIG1haSBtdWx0ZSByYXN0ZXJlIGZvbG9zaW5kIG8gc2NhcsSDIGRlIG3Eg3N1csSDIMiZaSBvIGdyZXV0YXRlIGNvbXVuxIMgY29uZm9ybSBpbXBvcnRhbsibZWkgYWNlc3RlaWEuXCIsXG5cdFx0d2VpZ2h0ZWRTdW1OYW1lOiBcIlN1bcSDIFBvbmRlcmF0xINcIixcblx0XHR3ZWlnaHRlZFN1bVNuaXA6IFwiUG9uZGVyZWF6xIMgyJlpIGFkYXVnxIMgdW4gyJlpciBkZSByYXN0ZXJlIGRlIGxhIG8gY2VsdWzEgyBsYSBhbHRhLlwiLFxuXHRcdHdlaWdodGVkU3VtRGVzYzogXCJGdW5jyJtpYSBzdW1laSBwb25kZXJhdGUgdsSDIHBlcm1pdGUgc8SDIHN1cHJhcHVuZcibaSBtYWkgbXVsdGUgcmFzdGVyZSwgw65ubXVsyJtpbmR1LWwgcGUgZmllY2FyZSBjdSBwb25kZXJlYSBhbG9jYXTEgyDImWkgw65uc3VtYXJlYSBhY2VzdG9yYS5cIixcblx0XHR3aW5kY2hpbGxOYW1lOiBcIlLEg2NpcmUgZW9saWFuxINcIixcblx0XHR3aW5kY2hpbGxTbmlwOiBcIkNvbWJpbsSDIHRlbXBlcmF0dXJhIGFlcnVsdWkgYW1iaWVudGFsIMiZaSB2aXRlemEgdsOibnR1bHVpIHBlbnRydSBjYWxjdWxhcmVhIGZhY3RvcnVsdWkgZGUgcsSDY2lyZSBlb2xpYW7Egy5cIixcblx0XHR3aW5kY2hpbGxEZXNjOiBcIkZ1bmPIm2lhIGRlIFLEg2NpcmUgRW9saWFuxIMgZXN0ZSB1dGlsxIMgcGVudHJ1IGlkZW50aWZpY2FyZWEgY29uZGnIm2lpbG9yIGRlIGlhcm7EgyBwZXJpY3Vsb2FzZSBjYXJlLCDDrm4gZnVuY8ibaWUgZGUgdGltcGlpIGRlIGV4cHVuZXJlIGxhIGVsZW1lbnRlLCBwb3QgZHVjZSBsYSBkZWdlcsSDdHVyaSBzYXUgY2hpYXIgbGEgaGlwb3Rlcm1pZS4gUsSDY2lyZWEgZW9saWFuxIMgZXN0ZSBvIG1vZGFsaXRhdGUgZGUgYSBtxINzdXJhIGZyaWd1bCByZXNpbcibaXQgZGUgbyBwZXJzb2FuxIMgYXR1bmNpIGPDom5kIHbDom50dWwgZXN0ZSBsdWF0IMOubiBjb25zaWRlcmFyZSBjdSB0ZW1wZXJhdHVyaWxlIGRlamEgc2PEg3p1dGUuIEN1IGPDonQgZXN0ZSBtYWkgbWFyZSB2aXRlemEgdsOibnR1bHVpLCBjdSBhdMOidCBtYWkgcmVwZWRlIHNlIHZhIHBpZXJkZSBjxINsZHVyYSBjb3Jwb3JhbMSDIMiZaSBjdSBhdMOidCBtYWkgZnJpZyBzZSB2b3Igc2ltyJtpLlwiLFxuXHRcdHpvbmFsUmVtYXBOYW1lOiBcIlJlbWFwYXJlIFpvbmFsxINcIixcblx0XHR6b25hbFJlbWFwU25pcDogXCJSZW1hcGHIm2kgcGl4ZWxpaSDDrm50ci11biByYXN0ZXIgcGUgYmF6YSB6b25lbG9yIGRlZmluaXRlIMOubnRyLXVuIGFsdCByYXN0ZXIgyJlpIG8gdmFsb2FyZSBkZSBtYXBhcmUgZGVwZW5kZW50xIMgZGUgem9uxIMgZGVmaW5pdMSDIMOubnRyLXVuIHRhYmVsLlwiLFxuXHRcdHpvbmFsUmVtYXBEZXNjOiBcIkFjZWFzdMSDIGZ1bmPIm2llIHbEgyBwZXJtaXRlIHPEgyByZW1hcGHIm2kgcGl4ZWxpaSDDrm50ci11biByYXN0ZXIgcGUgYmF6YSB6b25lbG9yIGRlZmluaXRlIMOubnRyLXVuIGFsdCByYXN0ZXIgyJlpIG8gdmFsb2FyZSBkZSBtYXBhcmUgZGVwZW5kZW50xIMgZGUgem9uxIMgZGVmaW5pdMSDIMOubnRyLXVuIHRhYmVsLlwiLFxuXHRcdHpvbmFsU3RhdGlzdGljc05hbWU6IFwiU3RhdGlzdGljxIMgem9uYWzEg1wiLFxuXHRcdHpvbmFsU3RhdGlzdGljc1NuaXA6IFwiQ2FsY3VsZWF6xIMgc3RhdGlzdGljaSBwZSBiYXphIHZhbG9yaWxvciB1bnVpIHJhc3RlciDDrm4gY2FkcnVsIHpvbmVsb3IgdW51aSBhbHQgc2V0IGRlIGRhdGUuXCIsXG5cdFx0em9uYWxTdGF0aXN0aWNzRGVzYzogXCJGdW5jyJtpYSBjYWxjdWxlYXrEgyBzdGF0aXN0aWNpIHBlIGJhemEgdmFsb3JpbG9yIHVudWkgcmFzdGVyIMOubiBjYWRydWwgem9uZWxvciB1bnVpIGFsdCBzZXQgZGUgZGF0ZS4gTyB6b27EgyBlc3RlIGRlZmluaXTEgyBjYSB0b2F0ZSBzdXByYWZlyJtlbGUgZGluIGludHJhcmUgY2FyZSBhdSBhY2VlYciZaSB2YWxvYXJlLiBBY2VzdGUgc3VwcmFmZcibZSBudSB0cmVidWllIHPEgyBmaWUgY29udGludWUuIEF0dW5jaSBjw6JuZCBpbnRyxINyaWxlIGRlIHpvbsSDIMiZaSB2YWxvYXJlIHN1bnQgYW1iZWxlIHJhc3RlcmUgZGUgYWNlZWHImWkgcmV6b2x1yJtpZSwgdm9yIGZpIHV0aWxpemF0ZSBkaXJlY3QuIERhY8SDIHJlem9sdcibaWlsZSBzdW50IGRpZmVyaXRlLCBvIHJlLWNvbGVjdGFyZSBwZSBwbGFuIGludGVybiBlc3RlIGFwbGljYXTEgyBwZW50cnUgYSBjb3JlbGEgcmV6b2x1yJtpaWxlIMOubmFpbnRlIGRlIGVmZWN0dWFyZWEgb3BlcsSDcmlpIHpvbmFsZS5cIixcblx0XHRmbG93TGVuZ3RoTmFtZTogXCJMdW5naW1lYSBmbHV4dWx1aVwiLFxuXHRcdGZsb3dMZW5ndGhTbmlwOiBcIkNhbGN1bGVhesSDIGRpc3RhbsibYSDDrm4gYW1vbnRlIHNhdSDDrm4gYXZhbCBzYXUgZGlzdGFuyJthIHBvbmRlcmF0xIMsIGRlLWEgbHVuZ3VsIGPEg2lpIGZsdXh1bHVpIHBlbnRydSBmaWVjYXJlIGNlbHVsxIMuXCIsXG5cdFx0Zmxvd0xlbmd0aERlc2M6IFwiQWNlYXN0YSBlc3RlIG8gZnVuY8ibaWUgcmFzdGVyIGdsb2JhbMSDLiBBY2Vhc3TEgyBmdW5jyJtpZSBjcmVlYXrEgyB1biBzdHJhdCB0ZW1hdGljIHJhc3RlciBwZW50cnUgZGlzdGFuyJthIMOubiBhbW9udGUgc2F1IMOubiBhdmFsIHNhdSBkaXN0YW7Im2EgcG9uZGVyYXTEgywgZGUtYSBsdW5ndWwgY8SDaWkgZmx1eHVsdWkgcGVudHJ1IGZpZWNhcmUgY2VsdWzEgy48ZGl2Pjxici8+VXRpbGl6YXJlYSBwcmluY2lwYWzEgyBhIGZ1bmPIm2llaSBMdW5naW1lIGZsdXggZXN0ZSBjYWxjdWxhcmVhIGRpc3RhbsibZWkgcGVudHJ1IGNlYSBtYWkgbHVuZ8SDIGNhbGUgYSBmbHV4dWx1aSDDrm4gY2FkcnVsIHVudWkgYW51bWl0IGJhemluLiBBY2Vhc3TEgyBtxINzdXJhcmUgZXN0ZSB1dGlsaXphdMSDIGRlc2VvcmkgcGVudHJ1IGEgY2FsY3VsYSB0aW1wdWwgZGUgY29uY2VudHJhcmUgcGVudHJ1IHVuIGJhemluLiBBY2VzdCBsdWNydSBzZSBlZmVjdHVlYXrEgyB1dGlsaXrDom5kIG9wyJtpdW5lYSBBbW9udGUuIEFjZWFzdMSDIGZ1bmPIm2llIHBvYXRlIGZpIHV0aWxpemF0xIMgyJlpIHBlbnRydSBhIGNyZWEgZGlhZ3JhbWUgZGlzdGFuyJvEgy16b27EgyBwZW50cnUgcHJlY2lwaXRhyJtpaWxlIMiZaSBlZmVjdGVsZSBwbG9pbG9yIHRvcmVuyJtpYWxlIGlwb3RldGljZSwgdXRpbGl6w6JuZCByYXN0ZXJ1bCBkZSBncmV1dGF0ZSBjYSBpbXBlZGFuyJvEgyBwcml2aW5kIG1pyJljYXJlYSDDrm4gcGFudMSDLjwvZGl2PlwiLFxuXHRcdHN0cmVhbU9yZGVyTmFtZTogXCJPcmRvbmFyZSBmbHV4XCIsXG5cdFx0c3RyZWFtT3JkZXJTbmlwOiBcIkF0cmlidWllIG8gb3JkaW5lIG51bWVyaWPEgyBzZWdtZW50ZWxvciB1bnVpIHJhc3RlciBjYXJlIHJlcHJlemludMSDIHJhbWlmaWNhyJtpaWxlIHVuZWkgcmXIm2VsZSBsaW5pYXJlXCIsXG5cdFx0c3RyZWFtT3JkZXJEZXNjOiBcIkFjZWFzdGEgZXN0ZSBvIGZ1bmPIm2llIHJhc3RlciBnbG9iYWzEgy4gQWNlYXN0xIMgZnVuY8ibaWUgY3JlZWF6xIMgdW4gc3RyYXQgdGVtYXRpYyBkZSByYXN0ZXIgY2FyZSBhdHJpYnVpZSBvIG9yZGluZSBudW1lcmljxIMgcGVudHJ1IHNlZ21lbnRlbGUgdW51aSByYXN0ZXIgY2FyZSByZXByZXppbnTEgyByYW1pZmljYcibaWlsZSB1bmVpIHJlyJtlbGUgbGluaWFyZS48ZGl2Pjxici8+UmV6dWx0YXR1bCBmdW5jyJtpZWkgT3Jkb25hcmUgZmx1eCB2YSBmaSB1bnVsIGRlIMOubmFsdMSDIGNhbGl0YXRlIGRhY8SDIHN0cmF0dWwgdGVtYXRpYyBkZSByYXN0ZXIgYWwgZmx1eHVsdWkgZGUgaW50cmFyZSDImWkgc3RyYXR1bCB0ZW1hdGljIGRlIHJhc3RlciBhbCBkaXJlY8ibaWVpIGZsdXh1bHVpIGRlIGludHJhcmUgc3VudCBkZXJpdmF0ZSBwZSBiYXphIGFjZWxlaWHImWkgc3VwcmFmZcibZS4gRGFjxIMgcmFzdGVydWwgZGUgZmx1eCBlc3RlIGRlcml2YXQgcGUgYmF6YSB1bnVpIHNldCBkZSBkYXRlIGFsIGZsdXh1cmlsb3IgcmFzdGVyaXphdGUsIHJlenVsdGF0dWwgbnUgcG9hdGUgZmkgdXRpbGl6YXQsIGRlb2FyZWNlIGRpcmVjyJtpYSBudSB2YSBjb3Jlc3B1bmRlIGxvY2HIm2llaSBjZWx1bGVsb3IgZmx1eHVsdWksIGRlIGxhIGNlbHVsxIMgbGEgY2VsdWzEgy4gUmV6dWx0YXRlbGUgZnVuY8ibaWVpIEFjdW11bGFyZSBmbHV4IHBvdCBmaSB1dGlsaXphdGUgcGVudHJ1IGEgY3JlYSBvIHJlyJtlYSBkZSBmbHV4IGRlIHJhc3RlciBwcmluIGFwbGljYXJlYSB1bmVpIHZhbG9yaSBkZSBwcmFnIHBlbnRydSBhIHNlbGVjdGEgY2VsdWxlIGN1IHVuIGZsdXggY3UgbyBhY3VtdWxhcmUgbWFyZS4gRGUgZXhlbXBsdSwgY2VsdWxlbGUgY3UgdW4gZmx1eCBtYWkgbWFyZSBkZSAxMDAgY2VsdWxlIMOubiBhY2VzdGVhIHN1bnQgdXRpbGl6YXRlIHBlbnRydSBkZWZpbmlyZWEgcmXIm2VsZWkgZGUgZmx1eC4gVXRpbGl6YcibaSBmdW5jyJtpYSBDb24gc2F1IFNldGFyZSBudWwgcGVudHJ1IGEgY3JlYSB1biByYXN0ZXIgZGUgcmXIm2VhIGRlIGZsdXggw65uIGNhcmUgdmFsb3JpbGUgZGUgYWN1bXVsYXJlIGEgZmx1eHVsdWkgZGUgMTAwIHNhdSBtYWkgbXVsdGUgY2VsdWxlIHN1bnQgc2V0YXRlIGxhIDEsIGlhciBjZWxlbGFsdGUgc3VudCBwdXNlIMOubiBmdW5kYWwgKE5vRGF0YSkuIFJlyJtlYXVhIGRlIGZsdXggcmV6dWx0YXTEgyBwb2F0ZSBmaSB1dGlsaXphdMSDIMOubiBmdW5jyJtpYSBPcmRvbmFyZSBmbHV4LiBBY2Vhc3TEgyBmdW5jyJtpZSBhY2NlcHTEgyBkb2FyIHVuIHN0cmF0IHRlbWF0aWMgcmFzdGVyIGRlIGRpcmVjyJtpZSBhIGZsdXh1bHVpIGRlIGludHJhcmUgRDguIERpcmVjyJtpaWxlIGRlIGZsdXggRDggcG90IGZpIGNyZWF0ZSB1dGlsaXrDom5kIGZ1bmPIm2lhIERpcmVjyJtpZSBmbHV4IMiZaSBzdW50IGV4ZWN1dGF0ZSBjdSB0aXB1bCBkZSBkaXJlY8ibaWUgYSBmbHV4dWx1aSBpbXBsaWNpdC48L2Rpdj5cIixcblx0XHRzbmFwUG91clBvaW50TmFtZTogXCJGaXhhcmUgcHVuY3QgZGUgY3VyZ2VyZVwiLFxuXHRcdHNuYXBQb3VyUG9pbnRTbmlwOiBcIkZpeGVhesSDIHB1bmN0ZWxlIGRlIGN1cmdlcmUgw65uIGNlbHVsYSBjdSBjZWEgbWFpIG1hcmUgYWN1bXVsYXJlIGRlIGZsdXggcGUgbyBkaXN0YW7Im8SDIHNwZWNpZmljYXTEg1wiLFxuXHRcdHNuYXBQb3VyUG9pbnREZXNjOiBcIkFjZWFzdGEgZXN0ZSBvIGZ1bmPIm2llIHJhc3RlciBnbG9iYWzEgy4gQWNlYXN0xIMgZnVuY8ibaWUgZml4ZWF6xIMgcHVuY3RlbGUgZGUgY3VyZ2VyZSDDrm4gY2VsdWxhIGN1IGNlYSBtYWkgbWFyZSBhY3VtdWxhcmUgZGUgZmx1eCBwZSBvIGRpc3RhbsibxIMgc3BlY2lmaWNhdMSDLjxkaXY+PGJyLz5GdW5jyJtpYSBGaXhhcmUgcHVuY3QgZGUgY3VyZ2VyZSBlc3RlIHV0aWxpemF0xIMgcGVudHJ1IGEgYXNpZ3VyYSBzZWxlY3RhcmVhIHB1bmN0ZWxvciBjdSB1biBmbHV4IGN1IGFjdW11bGFyZSBtYXJlIGxhIGRlbGltaXRhcmVhIGJhemluZWxvciBoaWRyb2dyYWZpY2UgdXRpbGl6w6JuZCBmdW5jyJtpYSBCYXppbiBoaWRyb2dyYWZpYy4g4oCeRml4YXJlIHB1bmN0IGRlIGN1cmdlcmXigJ0gdmEgY8SDdXRhIHBlIG8gZGlzdGFuyJvEgyBmaXhhdMSDIMOubiBqdXJ1bCBwdW5jdGVsb3IgZGUgY3VyZ2VyZSBzcGVjaWZpY2F0ZSBwZW50cnUgY2VsdWxhIGN1IGZsdXh1bCBjdSBjZWEgbWFpIG1hcmUgYWN1bXVsYXJlIMiZaSB2YSBtdXRhIHB1bmN0dWwgZGUgY3VyZ2VyZSDDrm4gbG9jYcibaWEgcmVzcGVjdGl2xIMuIFJlenVsdGF0dWwgZXN0ZSB1biBzdHJhdCB0ZW1hdGljIGRlIHJhc3RlciBjdSBudW1lcmUgw65udHJlZ2kgYXR1bmNpIGPDom5kIGxvY2HIm2lpbGUgcHVuY3RlbG9yIGRlIGN1cmdlcmUgYXUgZm9zdCBmaXhhdGUgw65uIGxvY2HIm2lpbGUgZmx1eHVsdWkgY3UgY2VhIG1haSBtYXJlIGFjdW11bGFyZS48L2Rpdj5cIixcblx0XHRzaW5rTmFtZTogXCJEb2xpbsSDXCIsXG5cdFx0c2lua1NuaXA6IFwiQ3JlZWF6xIMgdW4gcmFzdGVyIGNhcmUgaWRlbnRpZmljxIMgdG9hdGUgZG9saW5lbGUgc2F1IHpvbmVsZSBkZSBzY3VyZ2VyZSBpbnRlcm7Eg1wiLFxuXHRcdHNpbmtEZXNjOiBcIkFjZWFzdGEgZXN0ZSBvIGZ1bmPIm2llIHJhc3RlciBnbG9iYWzEgy4gQWNlYXN0xIMgZnVuY8ibaWUgY3JlZWF6xIMgdW4gc3RyYXQgdGVtYXRpYyBkZSByYXN0ZXIgY2FyZSBpZGVudGlmaWPEgyB0b2F0ZSBkb2xpbmVsZSBzYXUgem9uZWxlIGRlIHNjdXJnZXJlIGludGVybsSDLiBPIGRvbGluxIMgZXN0ZSBvIGNlbHVsxIMgc2F1IHVuIHNldCBkZSBjZWx1bGUgY29uZWN0YXRlIHNwYcibaWFsIGN1IG8gZGlyZWPIm2llIGEgZmx1eHVsdWkgY2FyZSBudSBwb2F0ZSBmaSBhdHJpYnVpdMSDIHVuZWlhIGRpbnRyZSBjZWxlIG9wdCB2YWxvcmkgdmFsaWRlIGRpbnRyLXVuIHJhc3RlciBkZSBkaXJlY8ibaWUgYSBmbHV4dWx1aS4gQWNlc3QgbHVjcnUgc2UgcG9hdGUgw65udMOibXBsYSBkYWPEgyBjZWx1bGVsZSDDrm52ZWNpbmF0ZSBzdW50IG1haSBtYXJpIGRlY8OidCBjZWx1bGEgcHJvY2VzYXTEgyBzYXUgYXR1bmNpIGPDom5kIGRvdcSDIGNlbHVsZSBhdSB1biBmbHV4IHJlY2lwcm9jLCBjcmXDom5kIG8gYnVjbMSDIGRlIGRvdcSDIGNlbHVsZS48ZGl2Pjxici8+RnVuY8ibaWEgRG9saW7EgyBhY2NlcHTEgyBkb2FyIHVuIHN0cmF0IHRlbWF0aWMgcmFzdGVyIGRlIGRpcmVjyJtpZSBhIGZsdXh1bHVpIGRlIGludHJhcmUgRDguIERpcmVjyJtpaWxlIGRlIGZsdXggRDggcG90IGZpIGNyZWF0ZSB1dGlsaXrDom5kIGZ1bmPIm2lhIERpcmVjyJtpZSBmbHV4IMiZaSBzdW50IGV4ZWN1dGF0ZSBjdSB0aXB1bCBkZSBkaXJlY8ibaWUgYSBmbHV4dWx1aSBpbXBsaWNpdC4gUmV6dWx0YXR1bCBmdW5jyJtpZWkgRG9saW7EgyBlc3RlIHVuIHJhc3RlciBjdSBudW1lcmUgw65udHJlZ2ksIGZpZWPEg3JlaSBkb2xpbmUgZmlpbmR1LWkgYXRyaWJ1aXTEgyBvIHZhbG9hcmUgdW5pY8SDLiBBY2VzdGUgdmFsb3JpIHVuaWNlIGF1IHVuIGludGVydmFsIGN1cHJpbnMgw65udHJlIDEgyJlpIG51bcSDcnVsIHRvdGFsIGRlIGRvbGluZS4gRGUgZXhlbXBsdSwgZGFjxIMgbnVtxINydWwgdG90YWwgZGUgZG9saW5lIGVzdGUgMTAwMCwgdmFsb3JpbGUgdW5pY2Ugdm9yIGZpIGN1cHJpbnNlIMOubnRyZSAxIMiZaSAxMDAwLjwvZGl2PlwiLFxuXHRcdGFnZ3JlZ2F0ZU5hbWU6IFwiw45uc3VtYXJlXCIsXG5cdFx0YWdncmVnYXRlU25pcDogXCJHZW5lcmVhesSDIG8gdmVyc2l1bmUgZGUgcmV6b2x1yJtpZSByZWR1c8SDIGEgdW51aSByYXN0ZXIuXCIsXG5cdFx0YWdncmVnYXRlRGVzYzogXCJGdW5jyJtpYSDDjm5zdW1hcmUgcmVlyJlhbnRpb25lYXrEgyB1biByYXN0ZXIgZGUgaW50cmFyZSBsYSBvIHJlem9sdcibaWUgbWFpIGdyb3NpZXLEgywgcGUgYmF6YSB1bmVpIHN0cmF0ZWdpaSBkZSDDrm5zdW1hcmUgc3BlY2lmaWNlLiBGaWVjYXJlIGNlbHVsxIMgZGUgaWXImWlyZSBjb27Im2luZSBTdW1hLCBNaW5pbXVtLCBNYXhpbXVtIHNhdSBNZWRpdSBwZW50cnUgY2VsdWxlbGUgZGUgaW50cmFyZSBjYXJlIHN1bnQgY3Vwcmluc2UgZGUgbcSDcmltZWEgY2VsdWxlaSByZXNwZWN0aXZlLjxkaXY+PGJyLz5GYWN0b3J1bCBjdSBjYXJlIHRyZWJ1aWUgc8SDIHNlIMOubm11bMibZWFzY8SDIGRpbWVuc2l1bmVhIGNlbHVsZWkgcmFzdGVydWx1aSBkZSBpbnRyYXJlLiBEZSBleGVtcGx1LCBvIHZhbG9hcmUgZGUgMyBhIGZhY3RvcnVsdWkgZGUgY2VsdWzEgyBhciBkdWNlIGxhIG8gZGltZW5zaXVuZSBhIGNlbHVsZWkgZGUgaWXImWlyZSBkZSB0cmVpIG9yaSBtYWkgbWFyZSBkZWPDonQgYWNlZWEgYSByYXN0ZXJ1bHVpIGRlIGludHJhcmUuIFB1dGXIm2kgZGVmaW5pIG1vZHVsIGRlIG1hbmlwdWxhcmUgYSBtxINyaW1paSBkZSBpZciZaXJlIGRhY8SDIG51bcSDcnVsIGRlIHLDom5kdXJpIHNhdSBjb2xvYW5lIGRpbiBpbnRyYXJlIG51IGVzdGUgdW4gbXVsdGlwbHUgZXhhY3QgYWwgZmFjdG9ydWx1aSBkZSBjZWx1bMSDLiDDjm4gbW9kIGltcGxpY2l0LCBsaW1pdGEgc3VwZXJpb2FyxIMgyJlpIGNlYSBkcmVhcHTEgyB2b3IgZmkgZXh0aW5zZSBwZW50cnUgYSBhY29wZXJpIG8gbcSDcmltZSBzcGHIm2lhbMSDIG1haSBtYXJlIGRlY8OidCBjZWEgYSByYXN0ZXJ1bHVpIGRlIGludHJhcmUsIHBlbnRydSBhIGFzaWd1cmEgZmFwdHVsIGPEgyBzdW50IHByb2Nlc2F0ZSB0b2F0ZSBjZWx1bGVsZSBkZSBpbnRyYXJlLiDDjm4gbW9kIGFsdGVybmF0aXYsIGxpbWl0YSBzdXBlcmlvYXLEgyDImWkgY2VhIGRyZWFwdMSDIHBvdCBmaSByZWR1c2UgcGVudHJ1IGEgYWNvcGVyaSBvIG3Eg3JpbWUgbWFpIG1pY8SDLCBhc3RmZWwgw65uY8OidCBudW3Eg3J1bCBkZSByw6JuZHVyaSDImWkgZGUgY29sb2FuZSBwcm9jZXNhdGUgc8SDIGZpZSB1biBtdWx0aXBsdSBleGFjdCBhbCBmYWN0b3J1bHVpIGRlIGNlbHVsxIMuIFB1dGXIm2kgZGVmaW5pIG1vZHVsIMOubiBjYXJlIGNlbHVsZSBOb0RhdGEgdHJlYnVpZSBtYW5pcHVsYXRlIGRlIGPEg3RyZSBjYWxjdWx1bCBkZSDDrm5zdW1hcmUuIE1lY2FuaXNtdWwgaW1wbGljaXQgZXN0ZSBmYXB0dWwgY8SDIGNlbHVsZSBOb0RhdGEgZGUgaW50cmFyZSBjYXJlIHNlIMOubmNhZHJlYXrEgyDDrm4gbcSDcmltZWEgc3BhyJtpYWzEgyBhIHVuZWkgY2VsdWxlIG1haSBtYXJpIGRpbiByYXN0ZXJ1bCBkZSBpZciZaXJlIHZvciBmaSBpZ25vcmF0ZSBsYSBkZXRlcm1pbmFyZWEgdmFsb3JpaSBjZWx1bGVpIGRlIGllyJlpcmUgcmVzcGVjdGl2ZS4gw45uIG1vZCBhbHRlcm5hdGl2LCBwdXRlyJtpIHNwZWNpZmljYSBmYXB0dWwgY8SDLCBkYWPEgyBleGlzdMSDIGNoaWFyIMiZaSBvIGNlbHVsxIMgTm9EYXRhIGRlIGludHJhcmUgaW5kaXZpZHVhbMSDIMOubiBjYWRydWwgbcSDcmltaWkgc3BhyJtpYWxlIGEgdW5laSBjZWx1bGUgZGUgaWXImWlyZSwgY2VsdWxhIHJlc3BlY3RpdsSDIHZhIGZpIE5vRGF0YSDDrm4gcmFzdGVydWwgZGUgaWXImWlyZS48L2Rpdj5cIixcblx0XHRjY2RjTmFtZTogXCJBbmFsaXphIENDRENcIixcblx0XHRjY2RjU25pcDogXCJFdmFsdWVhesSDIG1vZGlmaWPEg3JpbGUgw65uIGNlZWEgY2UgcHJpdmXImXRlIHZhbG9yaWxlIHBpeGVsaWxvciBvZGF0xIMgY3UgdHJlY2VyZWEgdGltcHVsdWkgdXRpbGl6w6JuZCBhbGdvcml0bXVsIGRlIERldGVjdGFyZSDImWkgQ2xhc2lmaWNhcmUgYSBNb2RpZmljxINyaWkgQ29udGludWUgKENDREMpIMiZaSBnZW5lcmVhesSDIHJlenVsdGF0ZSBtb2RlbC5cIixcblx0XHRjY2RjRGVzYzogXCJGdW5jyJtpYSBkZSBBbmFsaXrEgyBDQ0RDIGV2YWx1ZWF6xIMgbW9kaWZpY8SDcmlsZSDDrm4gY2VlYSBjZSBwcml2ZciZdGUgdmFsb3JpbGUgcGl4ZWxpbG9yIG9kYXTEgyBjdSB0cmVjZXJlYSB0aW1wdWx1aSB1dGlsaXrDom5kIGFsZ29yaXRtdWwgZGUgRGV0ZWN0YXJlIMiZaSBDbGFzaWZpY2FyZSBhIE1vZGlmaWPEg3JpaSBDb250aW51ZSAoQ0NEQykgyJlpIGdlbmVyZWF6xIMgdW4gcmFzdGVyIG11bHRpZGltZW5zaW9uYWwgY2FyZSBjb27Im2luZSByZXp1bHRhdGVsZSBkZSBtb2RlbC4gQWNlc3RhIGVzdGUgYWNjZXB0YXQgbnVtYWkgw65tcHJldW7EgyBjdSBmdW5jyJtpYSBEZXRlY3RhcmUgbW9kaWZpY2FyZSB1dGlsaXrDom5kIGFuYWxpemEgZGUgbW9kaWZpY8SDcmkgw65uIGNhZHJ1bCB1bnVpIMiZYWJsb24gZGUgZnVuY8ibaWUgcmFzdGVyLiBQZW50cnUgYSByZWFsaXphIG8gaWXImWlyZSBkZSByYXN0ZXIsIGNvbmVjdGHIm2kgZnVuY8ibaWEgQW5hbGl6xIMgQ0NEQyBsYSBmdW5jyJtpYSBEZXRlY3RhcmVhIG1vZGlmaWPEg3JpbG9yIHV0aWxpesOibmQgYW5hbGl6YSBkZSBtb2RpZmljxINyaSwgc2FsdmHIm2kgY2EgyJlhYmxvbiBkZSBmdW5jyJtpZSByYXN0ZXIgyJlpIHJ1bGHIm2kgQW5hbGl6xIMgcmFzdGVyIGN1IMiZYWJsb251bCBkZSBmdW5jyJtpZS48ZGl2Pjxici8+QWNlYXN0xIMgZnVuY8ibaWUgdXRpbGl6ZWF6xIMgYWxnb3JpdG11bCBkZSBEZXRlY3RhcmUgyJlpIENsYXNpZmljYXJlIGEgTW9kaWZpY8SDcmlpIENvbnRpbnVlIChDQ0RDKSBwZW50cnUgYSBldmFsdWEgbW9kaWZpY8SDcmlsZSBwcml2aW5kIHZhbG9yaWxlIHBpeGVsaWxvciBvZGF0xIMgY3UgdHJlY2VyZWEgdGltcHVsdWkgcGVudHJ1IG8gc3RpdsSDIGRlIGltYWdpbmkuIMOObiBjYWRydWwgdW5laSBzZXJpaSB0ZW1wb3JhbGUgZGUgaW1hZ2luaSBvcHRpY2Ugc2F1IGRlcml2YXRlIGRlIGltYWdpbmkgKGRlIGV4ZW1wbHUsIE5EVkkpLCB2YWxvcmlsZSBwaXhlbGlsb3IgcG90IGZsdWN0dWEgZGluIG1haSBtdWx0ZSBtb3RpdmU6IDEuIE1vZGlmaWNhcmUgc2V6b25pZXLEgyAtLSBNb2RpZmljxINyaWxlIHZhbG9yaWxvciBwaXhlbGlsb3IgcmVmbGVjdMSDIG1vZGlmaWPEg3JpIGFsZSB2ZWdldGHIm2llaSBkaW4gY2F1emEgdmFyaWFiaWxpdMSDyJtpaSBzZXpvbmllcmUgYSB0ZW1wZXJhdHVyaWkgyJlpIGEgcHJlY2lwaXRhyJtpaWxvci4gw45uIEVtaXNmZXJhIG5vcmRpY8SDLCBkZSBleGVtcGx1LCBuZSBhyJl0ZXB0xINtIHPEgyB2ZWRlbSBvIGRlbnNpdGF0ZSBtYWkgbWFyZSBhIHZlZ2V0YcibaWVpIHZlcmRlIHBlIHRpbXB1bCB2ZXJpaSwgw65uIGNvbXBhcmHIm2llIGN1IGlhcm5hOyAyLiBNb2RpZmljYXJlYSBncmFkdWFsxIMgLS0gTW9kaWZpY8SDcmlsZSB2YWxvcmlsb3IgcGl4ZWxpbG9yIHJlZmxlY3TEgyB0ZW5kaW7Im2VsZSB2ZWdldGHIm2llaSBzYXUgYWxlIGFwZWkgZGUgc3VwcmFmYcibxIMgZGluIGNhdXphIHZhcmlhYmlsaXTEg8ibaWkgY2xpbWF0aWNlIHNhdSBhIHByYWN0aWNpbG9yIGRlIGFkbWluaXN0cmFyZSBhIHNvbHVyaWxvciBwZSB0ZXJtZW4gbHVuZy4gRGUgZXhlbXBsdSwgc3VwcmFmYcibYSBzb2x1bHVpIGRlemdvbGl0IHBvdCBzxIMgY3JlYXNjxIMgZ3JhZHVhbCBjYSB1cm1hcmUgYSBkZWNsaW51bHVpIHByZWNpcGl0YcibaWlsb3IgcGUgdGVybWVuIGx1bmc7IMiZaSAzLiBNb2RpZmljYXJlIGJydXNjxIMgLS0gTW9kaWZpY8SDcmlsZSB2YWxvcmlsb3IgcGl4ZWxpbG9yIHJlZmxlY3TEgyBtb2RpZmljxINyaWxlIGFjb3BlcmlyaWkgc29sdXJpbG9yIGNhcmUgYXUgbG9jIGJydXNjIGRpbiBjYXV6YSBkZXNwxINkdXJpcmlpLCBhIGRlenZvbHTEg3JpaSB1cmJhbmUsIGEgZGV6YXN0cmVsb3IgbmF0dXJhbGUgZXRjLiBBbGdvcml0bXVsIENDREMgaWRlbnRpZmljxIMgdG9hdGUgY2VsZSB0cmVpIHRpcHVyaSBkZSBtb2RpZmljxINyaSBjdSBzY29wdWwgcHJpbWFyIGRlIGlkZW50aWZpY2FyZSBhIG1vZGlmaWPEg3JpaSBicnXImXRlLiBSZWdyZXNpYSBhcm1vbmljxIMgyJlpIG1vZGVsZWxlIGRlIHRlbmRpbsibxIMgc3VudCBhZGFwdGF0ZSBsYSBkYXRlIHBlbnRydSBhIGVzdGltYSBtb2RpZmljYXJlYSBzZXpvbmllcsSDIMiZaSBncmFkdWFsxIMsIGlhciBhYmF0ZXJpbGUgYnJ1yJl0ZSBkZSBsYSBtb2RlbGVsZSBkZSB0ZW5kaW7Im2UgcmVwcmV6aW50xIMgaW5kaWNhyJtpaSBhbGUgbW9kaWZpY8SDcmlpIGJydciZdGUuPGRpdj48YnIvPkFsZ29yaXRtdWwgQ0NEQyBhIGZvc3QgaW5pyJtpYWwgY29uY2VwdXQgcGVudHJ1IGRhdGVsZSBkZSBUZW1wZXJhdHVyxIMgbHVtaW5veml0YXRlIHNhdSBSZWZsZWN0YW7Im8SDIHN1cHJhZmHIm8SDIExhbmRzYXQgVE0sIExhbmRzYXQgRVRNKyDImWkgTGFuZHNhdCBPTEkuIEN1IHRvYXRlIGFjZXN0ZWEsIGZ1bmPIm2lhIERldGVjdGFyZWEgbW9kaWZpY8SDcmlsb3IgdXRpbGl6w6JuZCBhbmFsaXphIGRlIG1vZGlmaWPEg3JpLCB1dGlsaXphdMSDIMOubXByZXVuxIMgY3UgYWNlYXN0xIMgZnVuY8ibaWUsIHZhIGRldGVjdGEgbW9kaWZpY2FyZWEgcGVudHJ1IGltYWdpbmlsZSBjdSBiZW56aSBtdWx0aXBsZSBkZSBsYSBvcmljZSBzZW56b3IgY29tcGF0aWJpbCwgcHJlY3VtIMiZaSBkZXJpdmF0ZWxlIGRlIGltYWdpbmkgY3UgbyBzaW5ndXLEgyBiYW5kxIMsIHByZWN1bSBpbmRpY2lpIGRlIGJhbmTEgy4gRGUgZXhlbXBsdSwgcHV0ZcibaSBlZmVjdHVhIGRldGVjdGFyZWEgbW9kaWZpY8SDcmlpIGNvbnRpbnVlIGFzdXByYSB1bnVpIHJhc3RlciBkZSBJbmRpY2UgZGUgVmVnZXRhyJtpZSBEaWZlcmVuyJvEgyBOb3JtYWxpemF0xIMgKE5EVkkpLCBkZW9hcmVjZSBtb2RpZmljxINyaWxlIGJydciZdGUgw65uIE5EVkkgcG90IGluZGljYSBkZXNwxINkdXJpcmVhLjwvZGl2PlwiLFxuXHRcdGNvbXB1dGVDaGFuZ2VOYW1lOiBcIkNhbGN1bGFyZSBtb2RpZmljYXJlXCIsXG5cdFx0Y29tcHV0ZUNoYW5nZVNuaXA6IFwiQ2FsY3VsZWF6xIMgZGlmZXJlbsibYSBkaW50cmUgZG91xIMgc2V0dXJpIGRlIGRhdGUgZGUgcmFzdGVyIGNhdGVnb3JpY2Ugc2F1IGNvbnRpbnVlLlwiLFxuXHRcdGNvbXB1dGVDaGFuZ2VEZXNjOiBcIkZ1bmPIm2lhIENhbGN1bGFyZSBtb2RpZmljYXJlIHBvYXRlIGZpIHV0aWxpemF0xIMgcGVudHJ1IGEgZW51bWVyYSBkaWZlcmVuyJtlbGUgZGludHJlIGRvdcSDIHJhc3RlcmUgY2xhc2lmaWNhdGUgcGVudHJ1IGFuYWxpemEgZGUgbW9kaWZpY8SDcmkgYSBhY29wZXJpcmlpIHNvbHVyaWxvciBzYXUgcG9hdGUgZmkgdXRpbGl6YXTEgyBwZW50cnUgYSBleGFtaW5hIG1vZGlmaWPEg3JpbGUgw65udHJlIGRvdcSDIHJhc3RlcmUgY29udGludWUgY3UgbyBzaW5ndXLEgyBiYW5kxIMsIHByZWN1bSBlbGV2YcibaWEsIHRlbXBlcmF0dXJhLCBjb3JvbmFtZW50dWwgZXRjLlwiLFxuXHRcdGRldGVjdENoYW5nZU5hbWU6IFwiRGV0ZWN0YXJlYSBtb2RpZmljxINyaWxvciB1dGlsaXrDom5kIGFuYWxpemEgZGUgbW9kaWZpY8SDcmlcIixcblx0XHRkZXRlY3RDaGFuZ2VTbmlwOiBcIkdlbmVyZWF6xIMgdW4gc3RyYXQgdGVtYXRpYyBkZSByYXN0ZXIgY2FyZSBjb27Im2luZSBpbmZvcm1hyJtpaSBkZXNwcmUgbW9kaWZpY8SDcmlsZSBwaXhlbGlsb3IgdXRpbGl6w6JuZCByYXN0ZXJ1bCBkZSBhbmFsaXrEgyBhIG1vZGlmaWPEg3JpbG9yIGRlIGllyJlpcmUuXCIsXG5cdFx0ZGV0ZWN0Q2hhbmdlRGVzYzogXCI8ZGl2PkZ1bmPIm2lhIERldGVjdGFyZWEgbW9kaWZpY8SDcmlsb3IgdXRpbGl6w6JuZCBhbmFsaXphIGRlIG1vZGlmaWPEg3JpIGdlbmVyZWF6xIMgdW4gc3RyYXQgdGVtYXRpYyBkZSByYXN0ZXIgY2FyZSBjb27Im2luZSBpbmZvcm1hyJtpaSBkZXNwcmUgZGF0YSBtb2RpZmljxINyaWkgcGl4ZWxpbG9yIHV0aWxpesOibmQgcmFzdGVydWwgZGUgYW5hbGl6xIMgYSBtb2RpZmljxINyaWxvci4gUmFzdGVydWwgZGUgYW5hbGl6xIMgYSBtb2RpZmljxINyaWxvciB0cmVidWllIHPEgyBmaWUgZ2VuZXJhdCBkZSBBbmFsaXphyJtpIG1vZGlmaWPEg3JpbGUgY3UgYWp1dG9ydWwgaW5zdHJ1bWVudHVsdWkgQ0NEQyBzYXUgZGUgQW5hbGl6YcibaSBtb2RpZmljxINyaWxlIGN1IGFqdXRvcnVsIGluc3RydW1lbnR1bHVpIExhbmRUcmVuZHIsIHNhdSBmdW5jyJtpYSByYXN0ZXIgZGUgYW5hbGl6xIMgQ0NEQyBzYXUgZnVuY8ibaWEgcmFzdGVyIGRlIGFuYWxpesSDIExhbmRUcmVuZHIuPC9kaXY+PGJyPjxkaXY+QWNlYXN0xIMgZnVuY8ibaWUgcmFzdGVyIHBvYXRlIGZpIGNvbWJpbmF0xIMgY3UgZnVuY8ibaWEgcmFzdGVyIGRlIGFuYWxpesSDIENDREMgc2F1IGZ1bmPIm2lhIHJhc3RlciBkZSBhbmFsaXrEgyBMYW5kVHJlbmRyIMOubnRyLXVuIMiZYWJwb24gZGUgZnVuY8ibaWUgcmFzdGVyLiBQZW50cnUgYSByZWFsaXphIG8gaWXImWlyZSBkZSByYXN0ZXIgcGVybWFuZW50xIMsIGNvbmVjdGHIm2kgaWXImWlyZWEgZnVuY8ibaWVpIEFuYWxpesSDIENDREMgc2F1IEFuYWxpesSDIExhbmRUcmVuZHIgbGEgZnVuY8ibaWEgRGV0ZWN0YXJlYSBtb2RpZmljxINyaWxvciB1dGlsaXrDom5kIGFuYWxpemEgZGUgbW9kaWZpY8SDcmksIHNhbHZhyJtpIGNhIMiZYWJsb24gZGUgZnVuY8ibaWUgcmFzdGVyIMiZaSBydWxhyJtpIEFuYWxpesSDIHJhc3RlciBjdSDImWFibG9udWwuPC9kaXY+PGJyPjxkaXY+UGFyYW1ldHJ1bCA8c3Ryb25nPlRpcHVsIFNjaGltYsSDcmlpPC9zdHJvbmc+IGluZGljxIMgaW5mb3JtYcibaWlsZSBnZW5lcmF0ZS4gSW5mb3JtYcibaWlsZSBzdW50IGV4dHJhc2UgZGluIHJhc3RlcnVsIGRlIGFuYWxpesSDIGEgc2NoaW1ixINyaWkuIExhIHJ1bGFyZWEgYWNlc3RlaSBmdW5jyJtpaSBwZSBpZciZaXJlYSBkaW4gZnVuY8ibaWEvaW5zdHJ1bWVudHVsIENDREMsIHB1dGXIm2kgYWxlZ2UgZGludHJlIG9wyJtpdW5pbGUgdXJtxIN0b2FyZTo8L2Rpdj48dWw+PGxpPjxzdHJvbmc+T3JhIGNlbGVpIG1haSByZWNlbnRlIHNjaGltYsSDcmk8L3N0cm9uZz4tLUNlYSBtYWkgcmVjZW50xIMgZGF0xIMgyJlpIG9yxIMgbGEgY2FyZSB1biBwaXhlbCBhIGZvc3QgbWFyY2F0IGNhIGZpaW5kIHNjaGltYmF0LjwvbGk+PGxpPjxzdHJvbmc+T3JhIGNlbGVpIG1haSB2ZWNoIHNjaGltYsSDcmk8L3N0cm9uZz4tLUNlYSBtYWkgdmVjaGUgZGF0xIMgyJlpIG9yxIMgbGEgY2FyZSB1biBwaXhlbCBhIGZvc3QgbWFyY2F0IGNhIGZpaW5kIHNjaGltYmF0LjwvbGk+PGxpPjxzdHJvbmc+T3JhIGNlbGVpIG1haSBtYXJpIHNjaGltYsSDcmk8L3N0cm9uZz4tLURhdGEgyJlpIG9yYSBsYSBjYXJlIHNjaGltYmFyZWEgY2FsY3VsYXTEgyBhdSBmb3N0IGNlbGUgbWFpIHNlbW5pZmljYXRpdmUgcGVudHJ1IHVuIHBpeGVsLjwvbGk+PGxpPiA8c3Ryb25nPk51bcSDciBkZSBzY2hpbWLEg3JpPC9zdHJvbmc+LS1OdW3Eg3J1bCB0b3RhbCBkZSBzY2hpbWLEg3JpIGFsZSBwaXhlbHVsdWkuPC9saT48L3VsPjxkaXY+TGEgcnVsYXJlYSBhY2VzdGVpIGZ1bmPIm2lpIHBlIGllyJlpcmVhIGRpbiBmdW5jyJtpYS9pbnN0cnVtZW50dWwgTGFuZFRyZW5kciwgc3VudCBkaXNwb25pYmlsZSBvcMibaXVuaWxlIHN1cGxpbWVudGFyZSB1cm3Eg3RvYXJlOjwvZGl2Pjx1bD48bGk+PHN0cm9uZz5PcmEgY2VsZWkgbWFpIGx1bmdpIHNjaGltYsSDcmk8L3N0cm9uZz4tLURhdGEgbGEgY2FyZSB1biBwaXhlbCBhIGZvc3QgbWFyY2F0IGNhIGZpaW5kIHNjaGltYmF0LCBsYSDDrm5jZXB1dHVsIHNhdSBzZsOicsiZaXR1bCBjZWxlaSBtYWkgbHVuZ2kgcGVyaW9hZGUgZGUgc2NoaW1iYXJlLjwvbGk+PGxpPjxzdHJvbmc+T3JhIGNlbGVpIG1haSBzY3VydGUgc2NoaW1ixINyaTwvc3Ryb25nPi0tRGF0YSBsYSBjYXJlIHVuIHBpeGVsIGEgZm9zdCBtYXJjYXQgY2EgZmlpbmQgc2NoaW1iYXQsIGxhIMOubmNlcHV0dWwgc2F1IGxhIHNmw6JyyJlpdHVsIGNlbGVpIG1haSBzY3VydGUgcGVyaW9hZGUgZGUgc2NoaW1iYXJlLjwvbGk+PGxpPjxzdHJvbmc+T3JhIGNlbGVpIG1haSByYXBpZGUgc2NoaW1ixINyaTwvc3Ryb25nPi0tRGF0YSBsYSBjYXJlIHVuIHBpeGVsIGEgZm9zdCBtYXJjYXQgY2EgZmlpbmQgc2NoaW1iYXQsIGxhIMOubmNlcHV0dWwgc2F1IHNmw6JyyJlpdHVsIGNlbGVpIG1haSByYXBpZGUgcGVyaW9hZGUgZGUgc2NoaW1ixINyaS48L2xpPjxsaT48c3Ryb25nPk9yYSBjZWxlaSBtYWkgbGVudGUgc2NoaW1ixINyaTwvc3Ryb25nPi0tRGF0YSBsYSBjYXJlIHVuIHBpeGVsIGEgZm9zdCBtYXJjYXQgY2EgZmlpbmQgc2NoaW1iYXQsIGxhIMOubmNlcHV0dWwgc2F1IGxhIHNmw6JyyJlpdHVsIGNlbGVpIG1haSBsZW50ZSBwZXJpb2FkZSBkZSBzY2hpbWJhcmUuPC9saT48L3VsPjxkaXY+UmFzdGVydWwgZGUgaWXImWlyZSBlc3RlIHVuIHJhc3RlciBjdSBiYW5kxIMgbXVsdGlwbMSDIMOubiBjYXJlIGZpZWNhcmUgYmFuZMSDIGNvbsibaW5lIGluZm9ybWHIm2lpIGRlc3ByZSBzY2hpbWJhcmUgw65uIGZ1bmPIm2llIGRlIHRpcHVsIGRlIHNjaGltYmFyZSBzZWxlY3RhdCDImWkgZGUgbnVtxINydWwgbWF4aW0gZGUgc2NoaW1ixINyaSBzcGVjaWZpY2F0ZS4gRGUgZXhlbXBsdSwgZGFjxIMgPHN0cm9uZz5UaXB1bCBTY2hpbWLEg3JpaTwvc3Ryb25nPiBlc3RlIHNldGF0IGxhIDxzdHJvbmc+T3JhIENlbGVpIE1haSBWZWNoaSBTY2hpbWLEg3JpPC9zdHJvbmc+IMiZaSA8c3Ryb25nPk51bcSDcnVsIE1heGltIGRlIFNjaGltYsSDcmk8L3N0cm9uZz4gZXN0ZSBzZXRhdCBsYSAyLCBmdW5jyJtpYSBjYWxjdWxlYXrEgyBjZWxlIGRvdcSDIGRhdGUgY2VsZSBtYWkgdmVjaGkgY8OibmQgYSBhcMSDcnV0IHNjaGltYmFyZWEgw65uIGNhZHJ1bCBzZXJpZWkgZGUgdGltcCBwZW50cnUgZmllY2FyZSBwaXhlbC4gUmV6dWx0YXR1bCBlc3RlIHVuIHJhc3RlciDDrm4gY2FyZSBwcmltYSBiYW5kxIMgY29uyJtpbmUgZGF0ZWxlIGNlbGVpIG1haSB2ZWNoaSBzY2hpbWLEg3JpIGR1cMSDIHBpeGVsLCBpYXIgYSBkb3VhIGJhbmTEgyBjb27Im2luZSBkYXRlbGUgY2VsZWkgZGUtYSBkb3VhIGNlbGUgbWFpIHZlY2hpIHNjaGltYsSDcmkgZHVwxIMgcGl4ZWwuPC9kaXY+PGJyPjxkaXY+TGEgYXBsaWNhcmVhIGFjZXN0ZWkgZnVuY8ibaWkgcGUgaWXImWlyZWEgZGluIGluc3RydW1lbnRlbGUgTGFuZFRyZW5kciwgcHV0ZcibaSBhbGVnZSBkYWPEgyBzxIMgZXh0cmFnZcibaSBkYXRhIGNhcmUgbWFyY2hlYXrEgyDDrm5jZXB1dHVsIHNhdSBzZsOicsiZaXR1bCB1bmVpIHNjaGltYsSDcmkgY3UgYWp1dG9ydWwgcGFyYW1ldHJ1bHVpIDxzdHJvbmc+RGF0YSBTZWdtZW50dWx1aTwvc3Ryb25nPi4gRGUgZXhlbXBsdSwgcGVudHJ1IGEgw65uyJtlbGVnZSBjdW0gYSDDrm5jZXB1dCBjZWEgbWFpIHJlY2VudMSDIHNjaGltYmFyZSBkaW4gc2VyaWEgZGUgdGltcCwgc2V0YcibaSA8c3Ryb25nPlRpcHVsIFNjaGltYsSDcmlpPC9zdHJvbmc+IGxhIDxzdHJvbmc+T3JhIGNlbGVpIG1haSByZWNlbnRlIHNjaGltYsSDcmk8L3N0cm9uZz4gyJlpIDxzdHJvbmc+RGF0YSBTZWdtZW50dWx1aTwvc3Ryb25nPiBsYSA8c3Ryb25nPsOObmNlcHV0dWwgc2VnbWVudHVsdWk8L3N0cm9uZz4uPC9kaXY+PGJyPjxkaXY+Rm9sb3NpyJtpIHBhcmFtZXRyaWkgZGUgZmlsdHJhcmUgZGUgbWFpIGpvcyBwZW50cnUgYSBleHRyYWdlIGRhdGUgZGUgc2NoaW1iYXJlIG1haSBzcGVjaWZpY2UgZGluIHJhc3RlcnVsIGR2cy4gZGUgYW5hbGl6xIMgYSBzY2hpbWLEg3JpaTo8L2Rpdj48dWw+PGxpPjxzdHJvbmc+RmlsdHJhyJtpIGR1cMSDIGFuPC9zdHJvbmc+LS1JZGVudGlmaWNhyJtpIG1vZGlmaWPEg3JpbGUgYXDEg3J1dGUgw65udHItbyBwZXJpb2FkxIMgc3BlY2lmaWPEgywgZGUgZXhlbXBsdSwgZGFjxIMgY8SDdXRhyJtpIHNjaGltYsSDcmlsZSBhcMSDcnV0ZSDDrm50ci11biBwZWlzYWogw65uIHRpbXB1bCB1bmVpIHNlY2V0ZSBkZSBjaW5jaSBhbmkuPC9saT48bGk+PHN0cm9uZz5GaWx0cmHIm2kgZHVwxIMgZHVyYXTEgzwvc3Ryb25nPi0tSWRlbnRpZmljYcibaSBzY2hpbWLEg3JpbGUgYXDEg3J1dGUgw65udHItdW4gYW51bWl0IGludGVydmFsIGRlIGFuaSwgZGUgZXhlbXBsdSwgZGFjxIMgY8SDdXRhyJtpIGRvYXIgc2NoaW1ixINyaWxlIGJydciZdGUgYXDEg3J1dGUgw65uIDEgc2F1IDIgYW5pLiBQdXRlyJtpIGNhbGN1bGEgZHVyYXRhIGNhcmUgdsSDIGludGVyZXNlYXrEgyBjdSBhanV0b3J1bCBmb3JtdWxlaSA8c3Ryb25nPmFudWwgZGUgc2bDonLImWl0IC0gYW51bCBkZSDDrm5jZXB1dCArMTwvc3Ryb25nPi4gVm9yIGZpIGluY2x1c2UgyJlpIHNwYcibaWlsZSBnb2FsZSBkaW4gc2VyaWEgZGUgdGltcC48L2xpPjxsaT48c3Ryb25nPkZpbHRyYcibaSBkdXDEgyBtYWduaXR1ZGluZTwvc3Ryb25nPi0tSWRlbnRpZmljYcibaSBzY2hpbWLEg3JpbGUgY29uZm9ybSB1bmVpIG1hZ25pdHVkaW5pIGRhdGUsIGRlIGV4ZW1wbHUsIGRhY8SDIGPEg3V0YcibaSBkb2FyIHNjaGltYsSDcmlsZSBtYXJpIGRpbiBpbmRpY2VsZSBkZSB2ZWdldGHIm2llIE5EVkkuIE1hZ25pdHVkaW5lYSBlc3RlIG8gdmFsb2FyZSBhYnNvbHV0xIMsIGHImWFkYXIgdmFsb3JpbGUgbWluaW1lIMiZaSBtYXhpbWUgbnUgcG90IGZpIG5lZ2F0aXZlLiBQZW50cnUgYSBzcGVjaWZpY2Egc2NoaW1iYXJlYSBkaXJlY8ibaW9uYWzEgywgZm9sb3NpyJtpIHBhcmFtZXRydWwgPHN0cm9uZz5EaXJlY8ibaWEgU2NoaW1ixINyaWk8L3N0cm9uZz4uPC9saT48L3VsPlwiLFxuXHRcdGRpc3RhbmNlQWNjdW11bGF0aW9uTmFtZTogXCJBY3VtdWxhcmVhIGRpc3RhbsibZWlcIixcblx0XHRkaXN0YW5jZUFjY3VtdWxhdGlvblNuaXA6IFwiQ2FsY3VsZWF6xIMgZGlzdGFuyJthIGFjdW11bGF0xIMgcGVudHJ1IGZpZWNhcmUgY2VsdWzEgyBsYSBzdXJzZSwgcGVybWnIm8OibmQgZGlzdGFuyJthIGRlIGxpbmllIGRyZWFwdMSDLCBkaXN0YW7Im2EgZGUgY29zdCwgZGlzdGFuyJthIGRlIHN1cHJhZmHIm8SDIHJlYWzEgywgcHJlY3VtIMiZaSBmYWN0b3JpaSBkZSBjb3N0IHZlcnRpY2FsaSDImWkgb3Jpem9udGFsaS5cIixcblx0XHRkaXN0YW5jZUFjY3VtdWxhdGlvbkRlc2M6IFwiQWN1bXVsYXJlYSBkaXN0YW7Im2VpIGNhbGN1bGVhesSDIGRpc3RhbsibYSBwZW50cnUgZmllY2FyZSBsb2NhyJtpZSBkaW4gem9uYSBkZSBzdHVkaXUgcMOibsSDIGxhIGNlYSBtYWkgYXByb3BpYXTEgyBzdXJzxIMgc2F1IGN1IGNvc3R1bCBjZWwgbWFpIG1pYy4gRGFjxIMgc3VudCBmdXJuaXphdGUgZG9hciBzdXJzZWxlIHBlbnRydSBpbnRyYXJlLCBhdHVuY2kgZXN0ZSBjYWxjdWxhdMSDIG8gZGlzdGFuyJvEgyBkZSBsaW5pZSBkcmVhcHTEgyBwZW50cnUgZmllY2FyZSBsb2NhyJtpZSBkaW4gem9uYSBkZSBzdHVkaXUuIERhY8SDIGFtYmVsZSBzdXJzZSDImWkgYmFyaWVyZSBzdW50IHV0aWxpemF0ZSBjYSBpbnRyYXJlLCBBY3VtdWxhcmVhIGRpc3RhbsibZWkgY2FsY3VsZWF6xIMgZGlzdGFuyJthIGRlIGxpbmllIGRyZWFwdMSDIGRpbiBwcmVham1hIGJhcmllcmVsb3IuIEF0w6J0IHBlbnRydSByYXN0ZXJ1bCBzdXJzxIMsIGPDonQgyJlpIHBlbnRydSByYXN0ZXJ1bCBkZSBiYXJpZXLEgywgdmFsb2FyZWEgZGUgZnVuZGFsIHRyZWJ1aWUgc8SDIGZpZSBOb0RhdGEsIMOubiB0aW1wIGNlIHN1cnNlbGUgyJlpIGJhcmllcmVsZSBzdW50IHJlcHJlemVudGF0ZSBjdSB2YWxvcmkgZGUgY2VsdWxlIHZhbGlkZS4gVmFsb3JpbGUgdmFsaWRlIGluY2x1ZCB6ZXJvLiA8ZGl2Pjxici8+QXR1bmNpIGPDom5kIHVuIHJhc3RlciBkZSBzdXByYWZhyJvEgyBlc3RlIGZ1cm5pemF0IGNhIGludHJhcmUsIGVzdGUgY2FsY3VsYXTEgyBkaXN0YW7Im2Egc3VwcmFmZcibZWkgZWZlY3RpdmUgZGludHJlIGNlbHVsZS4gUGVudHJ1IGEgZWZlY3R1YSBhbmFsaXphIGRlIGNvc3QgdXRpbGl6w6JuZCBBY3VtdWxhcmVhIGRpc3RhbsibZWksIGVzdGUgbmVjZXNhcsSDIG8gc3VwcmFmYcibxIMgZGUgY29zdC4gRGFjxIMgZXN0ZSBmdXJuaXphdMSDIG8gc3VwcmFmYcibxIMgZGUgY29zdCwgcmV6dWx0YXR1bCBlc3RlIHVuIHJhc3RlciBkZSBkaXN0YW7Im8SDIGRlIGNvc3QgYWN1bXVsYXQuIEF0dW5jaSBjw6JuZCBzdW50IGZ1cm5pemHIm2kgZmFjdG9yaSBvcml6b250YWxpIMiZaSB2ZXJ0aWNhbGksIGRpcmVjyJtpb25hbGl0YXRlYSBlc3RlIGx1YXTEgyDDrm4gY29uc2lkZXJhcmUgY2EgyJlpIGN1bSBjb3N0dWwgYXIgZmkgYWN1bXVsYXQuIEV4aXN0xIMgcGF0cnUgY2FyYWN0ZXJpc3RpY2kgc3Vyc8SDIGNhcmUgcG90IGZpIHV0aWxpemF0ZS4gQWNlc3RlIGNhcmFjdGVyaXN0aWNpLCBjYXJlIHBvdCBmaSBhbGUgc3Vyc2VpIHNhdSBhbGUgZWxlbWVudGVsb3IgZGUgZGVwbGFzYXJlIGRpbiBzdXJzxIMsIHN1bnQgY29udHJvbGF0ZSBkZSBwYXJhbWV0cmkgc3BlY2lmaWNpOiAxLiBBY3VtdWxhcmVhIGluacibaWFsxIMgOuKAr3NldGVhesSDIGNvc3R1bCBpbmnIm2lhbCDDrm5haW50ZSBkZSBhIMOubmNlcGUgbWnImWNhcmVhLiAyLiBBY3VtdWxhcmVhIG1heGltxIM64oCvc3BlY2lmaWPEgyBjb3N0dWwgcGUgY2FyZSBvIHN1cnPEgyDDrmwgcG9hdGUgYWN1bXVsYSDDrm5haW50ZSBkZSBhdGluZ2VyZWEgbGltaXRlaSBzYWxlLiAzLiBNdWx0aXBsaWNhdG9ydWwgZGUgYXBsaWNhdCBsYSBjb3N0dXJpOuKAr3NwZWNpZmljxIMgbW9kdWwgZGUgZGVwbGFzYXJlIHNhdSBtYWduaXR1ZGluZWEgbGEgc3Vyc8SDLiA0IERpcmVjyJtpYSBkZSBkZXBsYXNhcmU64oCvaWRlbnRpZmljxIMgZGFjxIMgZWxlbWVudHVsIGRlIG11dGFyZSDDrm5jZXBlIGxhIG8gc3Vyc8SDIMiZaSBzZSBkZXBsYXNlYXrEgyBjxIN0cmUgbG9jYcibaWkgZGlmZXJpdGUgZGUgc3Vyc8SDIHNhdSBkYWPEgyDDrm5jZXBlIGxhIGxvY2HIm2lpIGRpZmVyaXRlIGRlIHN1cnPEgyDImWkgc2UgZGVwbGFzZWF6xIMgw65uYXBvaSBsYSBvIHN1cnPEgy48ZGl2Pjxici8+w45uIG1vZCBpbXBsaWNpdCwgcmV6dWx0YXR1bCBkZSBsYSBBY3VtdWxhcmVhIGRpc3RhbsibZWkgYXJlIG8gc2luZ3VyxIMgYmFuZMSDLCBjYXJlIHJlcHJlemludMSDIHJhc3RlcnVsIGRlIGFjdW11bGFyZSBhIGRpc3RhbsibZWkuIEN1IHRvYXRlIGFjZXN0ZWEsIHBvYXRlIGZpIGNyZWF0xIMgyJlpIG8gYmFuZMSDIHNlY3VuZGFyxIMsIGJhbmRhIGRlIGRpcmVjyJtpZSBpbnZlcnPEgy4gQWNlYXN0xIMgYmFuZMSDIGluZGljxIMgY2UgZGlyZWPIm2llIHRyZWJ1aWUgdXJtYXTEgyBkZSBsYSBmaWVjYXJlIGxvY2HIm2llIGRpbiB6b25hIGRlIHN0dWRpdSBwZW50cnUgYSBhanVuZ2UgbGEgc3Vyc2EgY3UgY2VsZSBtYWkgbWljaSBjb3N0dXJpLiBBbWJlbGUgYmVuemkgdm9yIGZpIG5lY2VzYXJlIHBlbnRydSBhIGRldGVybWluYSB0cmFzZWVsZSBvcHRpbWUgw65uIGNhZHJ1bCB6b25laSBkZSBzdHVkaXUuIFBlbnRydSBhIGdlbmVyYSB1biB0cmFzZXUsIG1haSDDrm50w6JpIHV0aWxpemHIm2kgZnVuY8ibaWEgRXh0cmFnZXJlYSBCZW56aWxvciBwZW50cnUgYSBleHRyYWdlIHJhc3RlcnVsIGRlIGFjdW11bGFyZSBhIGRpc3RhbsibZWkgyJlpIHJhc3RlcnVsIGRlIGRpcmVjyJtpZSBpbnZlcnPEgy4gVXRpbGl6YcibaSBhY2VzdGUgc3RyYXR1cmkgdGVtYXRpY2UgY2EgaW50cmFyZSBwZW50cnUgZnVuY8ibaWEgVHJhc2V1IGRlIENvc3QuIMOObiBmdW5jyJtpZSwgdXRpbGl6YcibaSByYXN0ZXJ1bCBkZSBhY3VtdWxhcmUgYSBkaXN0YW7Im2VpIGNhIGludHJhcmUgZGUgcmFzdGVyIGNvc3QtZGlzdGFuyJvEgyDImWkgcmFzdGVydWwgZGUgZGlyZWPIm2llIGludmVyc8SDIGNhIGludHJhcmUgZGUgcmFzdGVyIGRlIGxlZ8SDdHVyxIMgaW52ZXJzxIMuPC9kaXY+XCIsXG5cdFx0ZGlzdGFuY2VBbGxvY2F0aW9uTmFtZTogXCJBbG9jYXJlYSBEaXN0YW7Im2VpXCIsXG5cdFx0ZGlzdGFuY2VBbGxvY2F0aW9uU25pcDogXCJDYWxjdWxlYXrEgyBhbG9jYXJlYSBkaXN0YW7Im2VpIHBlbnRydSBmaWVjYXJlIGNlbHVsxIMgbGEgc3Vyc2VsZSBmdXJuaXphdGUsIGJhesOibmR1LXNlIHBlIGRpc3RhbsibYSBkZSBsaW5pZSBkcmVhcHTEgywgZGlzdGFuyJthIGRlIGNvc3QsIGRpc3RhbsibYSBkZSBzdXByYWZhyJvEgyByZWFsxIMsIHByZWN1bSDImWkgZmFjdG9yaWkgZGUgY29zdCB2ZXJ0aWNhbGkgyJlpIG9yaXpvbnRhbGkuXCIsXG5cdFx0ZGlzdGFuY2VBbGxvY2F0aW9uRGVzYzogXCJBbG9jYXJlYSBEaXN0YW7Im2VpIGNhbGN1bGVhesSDIGxhIGNlIHN1cnPEgyBlc3RlIGFsb2NhdMSDIGZpZWNhcmUgbG9jYcibaWUgZGluIHpvbmEgZGUgc3R1ZGl1LiBEYWPEgyBzdW50IGZ1cm5pemF0ZSBkb2FyIHN1cnNlbGUgcGVudHJ1IGludHJhcmUsIGF0dW5jaSBsb2NhyJtpaWxlIHN1bnQgYWxvY2F0ZSB1dGlsaXrDom5kIG8gZGlzdGFuyJvEgyBkZSBsaW5pZSBkcmVhcHTEgyBmYcibxIMgZGUgY2VhIG1haSBhcHJvcGlhdMSDIHN1cnPEgy4gRGFjxIMgYW1iZWxlIHN1cnNlIMiZaSBiYXJpZXJlIHN1bnQgdXRpbGl6YXRlIGNhIGludHJhcmUsIEFsb2NhcmVhIGRpc3RhbsibZWkgY2FsY3VsZWF6xIMgZGlzdGFuyJthIGRlIGxpbmllIGRyZWFwdMSDIGRpbiBwcmVham1hIGJhcmllcmVsb3IgcGVudHJ1IGEgZGV0ZXJtaW5hIGPEg3JlaSBzdXJzZSDDrmkgZXN0ZSBhbG9jYXTEgyBvIGxvY2HIm2llLiBBdMOidCBwZW50cnUgcmFzdGVydWwgc3Vyc8SDLCBjw6J0IMiZaSBwZW50cnUgcmFzdGVydWwgZGUgYmFyaWVyxIMsIHZhbG9hcmVhIGRlIGZ1bmRhbCB0cmVidWllIHPEgyBmaWUgTm9EYXRhLCDDrm4gdGltcCBjZSBzdXJzZWxlIMiZaSBiYXJpZXJlbGUgc3VudCByZXByZXplbnRhdGUgY3UgdmFsb3JpIGRlIGNlbHVsZSB2YWxpZGUuIFZhbG9yaWxlIHZhbGlkZSBpbmNsdWQgemVyby48ZGl2Pjxici8+UGVudHJ1IGEgZWZlY3R1YSBhbmFsaXphIGRlIGNvc3QgdXRpbGl6w6JuZCBBbG9jYXJlYSBkaXN0YW7Im2VpLCBlc3RlIG5lY2VzYXLEgyBvIHN1cHJhZmHIm8SDIGRlIGNvc3QuIERhY8SDIGVzdGUgZnVybml6YXTEgyBvIHN1cHJhZmHIm8SDIGRlIGNvc3QsIHJlenVsdGF0dWwgdmEgZmkgdW4gcmFzdGVyIGRlIGFsb2NhcmUgYmF6YXQgcGUgY29zdCBhY3VtdWxhdGl2LCBudSBwZSBkaXN0YW7Im2EgZGUgbGluaWUgZHJlYXB0xIMuIEF0dW5jaSBjw6JuZCBzdW50IGZ1cm5pemHIm2kgZmFjdG9yaSBvcml6b250YWxpIMiZaSB2ZXJ0aWNhbGksIGRpcmVjyJtpb25hbGl0YXRlYSBlc3RlIGx1YXTEgyDDrm4gY29uc2lkZXJhcmUgY2EgyJlpIGN1bSBjb3N0dWwgYXIgZmkgYWN1bXVsYXQuIEF0dW5jaSBjw6JuZCB1biByYXN0ZXIgZGUgc3VwcmFmYcibxIMgZXN0ZSBmdXJuaXphdCBjYSBpbnRyYXJlLCBlc3RlIGNhbGN1bGF0xIMgZGlzdGFuyJthIHN1cHJhZmXIm2VpIGVmZWN0aXZlIGFjb3Blcml0ZSBsYSB0cmVjZXJlYSBkaW50cmUgY2VsdWxlLCBhdHVuY2kgY8OibmQgYWxvY2FyZWEgZXN0ZSBkZXRlcm1pbmF0xIMuIEV4aXN0xIMgcGF0cnUgY2FyYWN0ZXJpc3RpY2kgc3Vyc8SDIGNhcmUgcG90IGZpIHV0aWxpemF0ZS4gQWNlc3RlIGNhcmFjdGVyaXN0aWNpLCBjYXJlIHBvdCBmaSBhbGUgc3Vyc2VpIHNhdSBhbGUgZWxlbWVudGVsb3IgZGUgZGVwbGFzYXJlIGRpbiBzdXJzxIMsIHN1bnQgY29udHJvbGF0ZSBkZSBwYXJhbWV0cmkgc3BlY2lmaWNpOiAxLiBBY3VtdWxhcmVhIGluacibaWFsxIMgOuKAr3NldGVhesSDIGNvc3R1bCBpbmnIm2lhbCDDrm5haW50ZSBkZSBhIMOubmNlcGUgbWnImWNhcmVhLiAyLiBBY3VtdWxhcmVhIG1heGltxIM64oCvc3BlY2lmaWPEgyBjb3N0dWwgcGUgY2FyZSBvIHN1cnPEgyDDrmwgcG9hdGUgYWN1bXVsYSDDrm5haW50ZSBkZSBhdGluZ2VyZWEgbGltaXRlaSBzYWxlLiAzLiBNdWx0aXBsaWNhdG9ydWwgZGUgYXBsaWNhdCBsYSBjb3N0dXJpOuKAr3NwZWNpZmljxIMgbW9kdWwgZGUgZGVwbGFzYXJlIHNhdSBtYWduaXR1ZGluZWEgbGEgc3Vyc8SDLiA0IERpcmVjyJtpYSBkZSBkZXBsYXNhcmU64oCvaWRlbnRpZmljxIMgZGFjxIMgZWxlbWVudHVsIGRlIG11dGFyZSDDrm5jZXBlIGxhIG8gc3Vyc8SDIMiZaSBzZSBkZXBsYXNlYXrEgyBjxIN0cmUgbG9jYcibaWkgZGlmZXJpdGUgZGUgc3Vyc8SDIHNhdSBkYWPEgyDDrm5jZXBlIGxhIGxvY2HIm2lpIGRpZmVyaXRlIGRlIHN1cnPEgyDImWkgc2UgZGVwbGFzZWF6xIMgw65uYXBvaSBsYSBvIHN1cnPEgy48ZGl2Pjxici8+w45uIG1vZCBpbXBsaWNpdCwgcmV6dWx0YXR1bCBkZSBsYSBBbG9jYXJlYSBkaXN0YW7Im2VpIGFyZSBvIHNpbmd1csSDIGJhbmTEgywgY2FyZSByZXByZXppbnTEgyByYXN0ZXJ1bCBhbG9jxINyaWkgZGlzdGFuyJtlaS4gQmlmYXJlYSBvcMibaXVuaWkgQm9vbGVhbiBHZW5lcmFyZSByw6JuZCDImWkgY29sb2FuxIMgc3Vyc8SDIGNhIGJlbnppIHN1cGxpbWVudGFyZSBsYSBpZciZaXJlIHZhIGF2ZWEgY2EgcmV6dWx0YXQgdW4gcmFzdGVyIGN1IGJlbnppIG11bHRpcGxlIGNhcmUgY29uc3TEgyDDrm4gdHJlaSBiZW56aS4gUHJpbWEgYmFuZMSDIGVzdGUgYmFuZGEgZGUgYWxvY2FyZSBhIGRpc3RhbsibZWksIGEgZG91YSBiYW5kxIMgaW5jbHVkZSB1biBpbmRpY2UgZGUgcsOibmQsIGlhciBhIHRyZWlhIGJhbmTEgyBpbmNsdWRlIHVuIGluZGljZSBkZSBjb2xvYW7Egy4gQWNlyJl0aSBpbmRpY2kgaWRlbnRpZmljxIMgYW1wbGFzYXJlYSBjZWx1bGVpIHN1cnPEgyBjYXJlIGVzdGUgbGEgY2VhIG1haSBtaWPEgyBkaXN0YW7Im8SDIGRlIGNvc3QgYWN1bXVsYXTEgy4gSW5kZXh1bCByw6JuZHVsdWkgc3Vyc8SDIMiZaSBpbmRleHVsIGNvbG9hbmVpIHN1cnPEgyBwb3QgZmkgdXRpbGl6YXRlIMOubXByZXVuxIMgcGVudHJ1IGEgZWZlY3R1YSBtYXBhcmVhIGludGVuc2l0xIPIm2lpLiBEYWPEgyBpbnRlcm9nYcibaSBvcmljZSBsb2NhyJtpZSBkaW4gem9uYSBkdnMuIGRlIHN0dWRpdSBkaW4gYmVuemlsZSBkb2kgyJlpIHRyZWksIHZlyJtpIGFmbGEgcsOibmR1bCDImWkgY29sb2FuYSBzdXJzZWkgY3UgY29zdHVsIGNlbCBtYWkgbWljIHBlbnRydSBsb2NhyJtpYSByZXNwZWN0aXbEgy48L2Rpdj5cIixcblx0XHRldWNCYWNrRGlyZWN0aW9uTmFtZTogXCJEaXJlY8ibaWUgSW52ZXJzxIMgRXVjbGlkaWFuxINcIixcblx0XHRldWNCYWNrRGlyZWN0aW9uU25pcDogXCJDYWxjdWxlYXrEgywgcGVudHJ1IGZpZWNhcmUgY2VsdWzEgywgZGlyZWPIm2lhLCDDrm4gZ3JhZGUsIHDDom7EgyBsYSBjZWx1bGEgdmVjaW7EgyBkZS1hIGx1bmd1bCBjZWx1aSBtYWkgc2N1cnQgdHJhc2V1IMOubmFwb2kgY8SDdHJlIGNlYSBtYWkgYXByb3BpYXTEgyBzdXJzxIMgw65uIHRpbXAgY2Ugc2UgZXZpdMSDIGJhcmllcmVsZS5cIixcblx0XHRldWNCYWNrRGlyZWN0aW9uRGVzYzogXCJGdW5jyJtpYSBEaXJlY8ibaWEgSW52ZXJzxIMgRXVjbGlkaWFuxIMgYXJlIGNhIHJlenVsdGF0IHVuIHJhc3RlciBkZSBwdW5jdCBmbG90YW50IGNvbnRpbnV1LCBjYXJlIHJlcHJlemludMSDIGRpcmVjyJtpYSDDrm4gZ3JhZGUgw65uYXBvaSBsYSBjZWEgbWFpIGFwcm9waWF0xIMgc3Vyc8SDLCBldml0w6JuZCBiYXJpZXJlbGUsIGRhY8SDIHN1bnQgZnVybml6YXRlIGJhcmllcmUuPGRpdj48YnIvPkludHLEg3JpbGUgcGVudHJ1IERpcmVjyJtpYSBJbnZlcnPEgyBFdWNsaWRpYW7EgyByZXByZXppbnTEgyBzdXJzYSB1dGlsaXphdMSDIHBlbnRydSBjYWxjdWxhcmVhIGRpcmVjyJtpZWkgcmVzcGVjdGl2ZS4gTyBpbnRyYXJlIG9wyJtpb25hbMSDIGVzdGUgdW4gcmFzdGVyIGNhcmUgcmVwcmV6aW50xIMgYmFyaWVyZSDDrm4gY2FkcnVsIHpvbmVpIGRlIHN0dWRpdS4gQXTDonQgcGVudHJ1IHJhc3RlcnVsIHN1cnPEgywgY8OidCDImWkgcGVudHJ1IHJhc3RlcnVsIGRlIGJhcmllcsSDLCB2YWxvYXJlYSBkZSBmdW5kYWwgdHJlYnVpZSBzxIMgZmllIE5vRGF0YSwgw65uIHRpbXAgY2Ugc3Vyc2VsZSDImWkgYmFyaWVyZWxlIHN1bnQgcmVwcmV6ZW50YXRlIGN1IHZhbG9yaSB2YWxpZGUuIFZhbG9yaWxlIHZhbGlkZSBpbmNsdWQgemVyby4gw45uIG1vZCBpbXBsaWNpdCwgY2FsY3VsdWwgdmEgcHJvY2VzYSBtxINyaW1lYSBjb21iaW5hdMSDIGEgc3Vyc2Vsb3IgyJlpIGEgYmFyaWVyZWxvciwgcGx1cyAyIHLDom5kdXJpIMiZaSBjb2xvYW5lLiBEYWPEgyBhbmFsaXphIGVzdGUgbmVjZXNhcsSDIG51bWFpIMOubiBjYWRydWwgdW5laSBkaXN0YW7Im2Ugc3BlY2lmaWNhdGUgZmHIm8SDIGRlIHN1cnNlLCBwb2F0ZSBmaSB1dGlsaXphdCBwYXJhbWV0cnVsIERpc3RhbsibxIMgbWF4aW3Egy4gRGlyZWPIm2lhIEludmVyc8SDIEV1Y2xpZGlhbsSDIGFjY2VwdMSDIGF0w6J0IG8gbWV0b2TEgyDDjm4gcGxhbiwgY8OidCDImWkgbyBtZXRvZMSDIEdlb2RlemljxIMsIMOubiBjYWxjdWwuIE1ldG9kYSBkZSBjYWxjdWwgw45uIHBsYW4gdmEgZmkgcmVhbGl6YXTEgyBwZSB1biBwbGFuIHBsYXQgcHJvaWVjdGF0IGZvbG9zaW5kIHVuIHNpc3RlbSBkZSBjb29yZG9uYXRlIGNhcnRlemlhbiAyRC4gTWV0b2RhIGRlIGNhbGN1bCBHZW9kZXppY8SDIHZhIGZpIGVmZWN0dWF0xIMgYXN1cHJhIGVsaXBzb2lkdWx1aSwgY2VlYSBjZSDDrm5zZWFtbsSDIGPEgywgaW5kaWZlcmVudCBkZSBwcm9pZWPIm2lhIGRlIGludHJhcmUgc2F1IGRlIGllyJlpcmUsIHJlenVsdGF0ZWxvciBudSBzZSBtb2RpZmljxIMuPGRpdj48YnIvPlJlenVsdGF0dWwgZGluIGZ1bmPIm2lhIERpcmVjyJtpZSBJbnZlcnPEgyBFdWNsaWRpYW7EgyB2YSBmaSB1dGlsaXphdCDDrm1wcmV1bsSDIGN1IHJlenVsdGF0dWwgZGluIGZ1bmPIm2lhIERpc3RhbsibxIMgRXVjbGlkaWFuxIMgcGVudHJ1IGEgZGV0ZXJtaW5hIGNlbGUgbWFpIHNjdXJ0ZSB0cmFzZWUgZGUgbGEgbG9jYcibaWlsZSBkaW4gY2FkcnVsIHpvbmVpIGRlIHN0dWRpdSDDrm5hcG9pIGxhIHN1cnPEgy4gQXTDonQgcmV6dWx0YXR1bCBwZW50cnUgRGlyZWPIm2lhIEludmVyc8SDIEV1Y2xpZGlhbsSDLCBjw6J0IMiZaSByZXp1bHRhdHVsIERpc3RhbsibYSBFdWNsaWRpYW7Egywgc3VudCB1dGlsaXphdGUgw65uIGZ1bmPIm2lhIFRyYXNldSBkZSBDb3N0LCDDrm1wcmV1bsSDIGN1IGRlc3RpbmHIm2lpbGUsIHBlbnRydSBhIGdlbmVyYSBjZWxlIG1haSBzY3VydGUgdHJhc2VlLjwvZGl2PlwiLFxuXHRcdGV4cGFuZE5hbWU6IFwiRXh0aW5kZXJlXCIsXG5cdFx0ZXhwYW5kU25pcDogXCJFeHRpbmRlIHpvbmVsZSBzZWxlY3RhdGUgYWxlIHVudWkgcmFzdGVyIGR1cMSDIHpvbmUgyJlpIGR1cMSDIHVuIG51bcSDciBzcGVjaWZpY2F0IGRlIGNlbHVsZS5cIixcblx0XHRleHBhbmREZXNjOiBcIkN1IGZ1bmPIm2lhIGdsb2JhbMSDIEV4dGluZGVyZSwgcHV0ZcibaSBnZW5lcmFsaXphIHNhdSBzaW1wbGlmaWNhIHJhc3RlcmUgcHJpbiBtxINyaXJlYSB1bm9yIGFudW1pdGUgem9uZS4gRGUgYXNlbWVuZWEsIHB1dGXIm2kgY29udHJvbGEgZ3JhZHVsIGRlIGdlbmVyYWxpemFyZSBjZSB2YSBhdmVhIGxvYy48ZGl2Pjxici8+Wm9uZWxlIHBlIGNhcmUgbGUgc2VsZWN0YcibaSB2b3IgY3JlyJl0ZSBjYSBkaW1lbnNpdW5lIHByaW4gZXh0aW5kZXJlYSDDrm4gY2VsZWxhbHRlIHpvbmUuIERpbiBwdW5jdCBkZSB2ZWRlcmUgY29uY2VwdHVhbCwgVmFsb3JpbGUgZGUgem9uxIMgc2VsZWN0YXRlIHBvdCBmaSB2aXp1YWxpemF0ZSBjYSB6b25lIGRlIHByaW0gcGxhbiwgw65uIHRpbXAgY2UgY2VsZWxhbHRlIHZhbG9yaSByxINtw6JuIHZhbG9yaSDDrm4gZnVuZGFsLiBab25lbGUgZGUgcHJpbSBwbGFuIHNlIHBvdCBleHRpbmRlIMOubiB6b25lbGUgZGUgZnVuZGFsLjxkaXY+PGJyLz5HcmFkdWwgZGUgZ2VuZXJhbGl6YXJlIHBvYXRlIGZpIGNvbnRyb2xhdCBjdSBwYXJhbWV0cnVsIE51bcSDciBkZSBjZWx1bGUuIMOObiBtb2QgaW1wbGljaXQsIGFjZWFzdMSDIHZhbG9hcmUgZXN0ZSAxLCBjZWVhIGNlIMOubnNlYW1uxIMgY8SDIHpvbmVsZSBzZWxlY3RhdGUgc2Ugdm9yIGV4dGluZGUgY3UgbyB2YWxvYXJlIGNvcmVzcHVuesSDdG9hcmUgZGltZW5zaXVuaWkgdW5laSBjZWx1bGUuIFBlbnRydSBhIG3Eg3JpIGdyYWR1bCBkZSBnZW5lcmFsaXphcmUsIHB1dGXIm2kgc3BlY2lmaWNhIG8gdmFsb2FyZSBtYWkgbWFyZSBwZW50cnUgYWNlc3QgcGFyYW1ldHJ1LiBEaW4gcHVuY3QgZGUgdmVkZXJlIGNvbmNlcHR1YWwsIGFjZXN0IGx1Y3J1IGVzdGUgc2ltaWxhciBydWzEg3JpaSBpbnN0cnVtZW50dWx1aSBjdSB1biBudW3Eg3IgZWNoaXZhbGVudCBjZWx1aSBzcGVjaWZpY2F0LCBpYXIgcmV6dWx0YXRlbGUgcnVsxINyaWkgYW50ZXJpb2FyZSByZXByZXppbnTEgyBpbnRyYXJlYSDDrm4gaXRlcmHIm2lhIHVsdGVyaW9hcsSDLjwvZGl2PlwiLFxuXHRcdHRyZW5kQW5hbHlzaXNOYW1lOiBcIkdlbmVyYXJlYSBUZW5kaW7Im2VpXCIsXG5cdFx0dHJlbmRBbmFseXNpc1NuaXA6IFwiRXN0aW1lYXrEgyB0ZW5kaW7Im2EgcGVudHJ1IGZpZWNhcmUgcGl4ZWwgZGluIHVuYSBzYXUgbWFpIG11bHRlIHZhcmlhYmlsZSBkaW50ci11biByYXN0ZXIgbXVsdGlkaW1lbnNpb25hbC5cIixcblx0XHR0cmVuZEFuYWx5c2lzRGVzYzogXCI8ZGl2PkFjZWFzdMSDIGZ1bmPIm2llIHBvYXRlIGZpIHV0aWxpemF0xIMgcGVudHJ1IGFwbGljYXJlYSBkYXRlbG9yIHBlIG8gbGluaWUgZGUgdGVuZGluyJvEgyBsaW5pYXLEgywgYXJtb25pY8SDIHNhdSBwb2xpbm9taWFsxIMsIHNhdSBwb2F0ZSBmaSBmb2xvc2l0xIMgcGVudHJ1IGVmZWN0dWFyZWEgZGV0ZWN0xINyaWkgdGVuZGluyJtlaSBjdSBhanV0b3J1bCB0ZXN0dWx1aSBNYW5uLUtlbmRhbGwgc2F1IFNlYXNvbmFsLUtlbmRhbGwuPC9kaXY+PGJyPjxkaXY+UmFzdGVydWwgZGUgdGVuZGluyJvEgyBkZSBpZciZaXJlIGdlbmVyYXQgY3UgYWNlYXN0xIMgZnVuY8ibaWUgZXN0ZSBmb2xvc2l0IGNhIGludHJhcmUgw65uIGZ1bmPIm2lhIDxzdHJvbmc+UHJlY29uaXphyJtpIGN1IGFqdXRvcnVsIHRlbmRpbsibZWk8L3N0cm9uZz4uPC9kaXY+PGJyPjxkaXY+VGVzdGVsZSBNYW5uLUtlbmRhbGwgyJlpIFNlYXNvbmFsLUtlbmRhbGwgc3VudCBmb2xvc2l0ZSBwZW50cnUgYSBzdGFiaWxpIGRhY8SDIGV4aXN0xIMgbyB0ZW5kaW7Im8SDIG1vbm90b25pY8SDIMOubiBjYWRydWwgZGF0ZWxvci4gQWNlc3RlYSBzdW50IG5vbi1wYXJhbWV0cmljZSwgYWRpY8SDIG51IHBsZWFjxIMgZGUgbGEgcHJlbWlzYSB1bmVpIGRpc3RyaWJ1aXJpIHNwZWNpZmljZSBhIGRhdGVsb3IuIFRlc3R1bCBNYW5uLUtlbmRhbGwgbnUgaWEgw65uIGNvbnNpZGVyYXJlIGNvcmVsYXJlYSBzZXJpYWzEgyBzYXUgZWZlY3RlbGUgc2V6b25pZXJlLiBEYWPEgyBkYXRlbGUgc3VudCBzZXpvbmllcmUsIHRlc3R1bCBTZWFzb25hbC1LZW5kYWxsIGVzdGUgbWFpIHBvdHJpdml0LjwvZGl2Pjxicj48ZGl2PkRhY8SDIGluc3RydW1lbnR1bCBlc3RlIGZvbG9zaXQgcGVudHJ1IGVmZWN0dWFyZWEgdGVzdHVsdWkgTWFubi1LZW5kYWxsIHNhdSBhIHRlc3R1bHVpIFNlYXNvbmFsLUtlbmRhbGwsIHJlenVsdGF0dWwgZXN0ZSB1biByYXN0ZXIgY3UgY2luY2kgYmVuemkgZHVwxIMgY3VtIHVybWVhesSDOjwvZGl2Pjx1bD48bGk+QmFuZGEgMSA9IHBhbnRhIGx1aSBTZW48L2xpPjxsaT5CYW5kYSAyID0gdmFsb2FyZWEgcDwvbGk+PGxpPkJhbmRhIDMgPSBwdW5jdGFqdWwgTWFubi1LZW5kYWxsIChTKTwvbGk+PGxpPkJhbmRhIDQgPSBGbHVjdHVhyJtpYSBTPC9saT48bGk+QmFuZGEgNCA9IEZsdWN0dWHIm2lhIFM8L2xpPjxsaT5CYW5kYSA1ID0gUHVuY3RhanVsIFo8L2xpPjwvdWw+PGRpdj5JZciZaXJpbGUgZGluIHRlc3R1bCBNYW5uLUtlbmRhbGwgc2F1IFNlYXNvbmFsLUtlbmRhbGwgcG90IGZpIGZvbG9zaXRlIHBlbnRydSBhIHN0YWJpbGkgY2FyZSBwaXhlbGkgZGluIHNlcmlhIGR2cy4gbXVsdGlkaW1lbnNpb25hbMSDIGRlIHRpbXAgYXUgbyB0ZW5kaW7Im8SDIGN1IHNlbW5pZmljYcibaWUgc3RhdGlzdGljxIMuIFB1dGXIm2kgZm9sb3NpIGFjZXN0ZSBpbmZvcm1hyJtpaSDDrm1wcmV1bsSDIGN1IGFuYWxpemEgdGVuZGluyJtlaSBsaW5pYXJlLCBhcm1vbmljZSBzYXUgcG9saW5vbWlhbGUgcGVudHJ1IGEgZXh0cmFnZSB0ZW5kaW7Im2VsZSBzZW1uaWZpY2F0aXZlIGRpbiBzZXJpYSBkdnMuIGRlIHRpbXAuIFB1dGXIm2kgZ2VuZXJhIG8gbWFzY8SDIGluY2x1esOibmQgcGl4ZWxpaSBjdSB2YWxvcmkgcCBzZW1uaWZpY2F0aXZlLCBhcGxpY2HIm2kgbWFzY2EgcmFzdGVydWx1aSBtdWx0aWRpbWVuc2lvbmFsIMiZaSBmb2xvc2kgYWNlc3QgcmFzdGVyIG11bHRpZGltZW5zaW9uYWwgY3UgbWFzY8SDIHBlIHBvc3QgZGUgaW50cmFyZSDDrm4gaW5zdHJ1bWVudCBwZW50cnUgZWZlY3R1YXJlYSBhbmFsaXplbG9yIHRlbmRpbsibZWxvciBsaW5pYXJlLCBhcm1vbmljZSBzYXUgcG9saW5vbWlhbGUuPC9kaXY+PGJyPjxkaXY+RXhpc3TEgyB0cmVpIG9wyJtpdW5pIGFsZSBsaW5pZWkgZGUgdGVuZGluyJvEgyBwZW50cnUgY29yZWxhcmVhIHVuZWkgdGVuZGluyJtlIGN1IHZhbG9yaWxlIHZhcmlhYmlsZSBkZS1hIGx1bmd1bCB1bmVpIGRpbWVuc2l1bmk6IGxpbmlhcsSDLCBwb2xpbm9taWFsxIMgyJlpIGFybW9uaWPEgy48L2Rpdj48YnI+PGRpdj5QZW50cnUgYW5hbGl6YSB0ZW5kaW7Im2VpIGxpbmlhcmUsIGllyJlpcmVhIGVzdGUgdW4gcmFzdGVyIGN1IHRyZWkgYmVuemkgZHVwxIMgY3VtIHVybWVhesSDOjwvZGl2Pjx1bD48bGk+QmFuZGEgMSA9IFBhbnTEgzwvbGk+PGxpPkJhbmRhIDIgPSBJbnRlcmNlcHRhcmU8L2xpPjxsaT5CYW5kYSAzID0gZXJvYXJlYSBtZWRpZWkgcMSDdHJhdGljZSAoUk1TRSkgc2F1IGVyb2FyZWEgZGluIGp1cnVsIHLDom5kdWx1aSBjYXJlIHNlIHBvdHJpdmXImXRlIGNlbCBtYWkgYmluZTwvbGk+PC91bD48ZGl2PlBlbnRydSBhbmFsaXphIHRlbmRpbsibZWkgcG9saW5vbWlhbGUsIG51bcSDcnVsIGRlIGJlbnppIGRpbiBpZciZaXJlIGRlcGluZGUgZGUgb3JkaW5lYSBwb2xpbm9taWFsxIMuIEFqdXN0YXJlYSBwb2xpbm9taWFsxIMgZGUgb3JkaW51bCBkb2kgcmVhbGl6ZWF6xIMgdW4gcmFzdGVyIGN1IHBhdHJ1IGJlbnppIGR1cMSDIGN1bSB1cm1lYXrEgzo8L2Rpdj48dWw+PGxpPkJhbmRhIDEgPSBQb2x5bm9taWFsXzI8L2xpPjxsaT5CYW5kYSAyID0gUG9seW5vbWlhbF8xPC9saT48bGk+QmFuZGEgMyA9IFBvbHlub21pYWxfMDwvbGk+PGxpPkJhbmRhIDQgPSBSTVNFPC9saT48L3VsPjxkaXY+QWp1c3RhcmVhIHBvbGlub21pYWzEgyBkZSBvcmRpbnVsIHRyZWkgcmVhbGl6ZWF6xIMgdW4gcmFzdGVyIGN1IGNpbmNpIGJlbnppIGR1cMSDIGN1bSB1cm1lYXrEgzo8L2Rpdj48dWw+PGxpPkJhbmRhIDEgPSBQb2x5bm9taWFsXzM8L2xpPjxsaT5CYW5kYSAyID0gUG9seW5vbWlhbF8yPC9saT48bGk+QmFuZGEgMyA9IFBvbHlub21pYWxfMTwvbGk+PGxpPkJhbmRhIDQgPSBQb2x5bm9taWFsXzA8L2xpPjxsaT5CYW5kYSA1ID0gUk1TRTwvbGk+PC91bD48ZGl2PlBlbnRydSBhbmFsaXphIHRlbmRpbsibZWkgYXJtb25pY2UsIG51bcSDcnVsIGRlIGJlbnppIGRpbiBpZciZaXJlIGRlcGluZGUgZGUgZnJlY3ZlbsibYSBhcm1vbmljxIMuIEPDom5kIGZyZWN2ZW7Im2EgZXN0ZSBzZXRhdMSDIGxhIDEsIGllyJtpcmVhIGVzdGUgdW4gcmFzdGVyIGN1IGNpbmNpIGJlbnppIGR1cMSDIGN1bSB1cm1lYXrEgzo8L2Rpdj48dWw+PGxpPkJhbmRhIDEgPSBQYW50xIM8L2xpPjxsaT5CYW5kYSAyID0gSW50ZXJjZXB0YXJlPC9saT48bGk+QmFuZGEgMyA9IEhhcm1vbmljX3NpbjE8L2xpPjxsaT5CYW5kYSA0ID0gSGFybW9uaWNfY29zMTwvbGk+PGxpPkJhbmRhIDUgPSBSTVNFPC9saT48L3VsPjxkaXY+Q8OibmQgZnJlY3ZlbsibYSBlc3RlIHNldGF0xIMgbGEgMiwgaWXImWlyZWEgZXN0ZSB1biByYXN0ZXIgY3UgyJlhcHRlIGJlbnppIGR1cMSDIGN1bSB1cm1lYXrEgzo8L2Rpdj48dWw+PGxpPkJhbmRhIDEgPSBQYW50xIM8L2xpPjxsaT5CYW5kYSAyID0gSW50ZXJjZXB0YXJlPC9saT48bGk+QmFuZGEgMyA9IEhhcm1vbmljX3NpbjE8L2xpPjxsaT5CYW5kYSA0ID0gSGFybW9uaWNfY29zMTwvbGk+PGxpPkJhbmRhIDUgPSBIYXJtb25pY19zaW4yPC9saT48bGk+QmFuZGEgNiA9IEhhcm1vbmljX2NvczI8L2xpPjxsaT5CYW5kYSA3ID0gUk1TRTwvbGk+PC91bD48ZGl2PlBhcmFtZXRydWwgPHN0cm9uZz5MdW5naW1lYSBDaWNsdWx1aTwvc3Ryb25nPiBwZW50cnUgYW5hbGl6YSB0ZW5kaW7Im2VpIGFybW9uaWNlIGVzdGUgZm9sb3NpdCBwZW50cnUgYSBpbmRpY2EgbnVtxINydWwgyJlpIGx1bmdpbWVhIGNpY2x1cmlsb3IgcGUgY2FyZSB2xIMgYciZdGVwdGHIm2kgc8SDIGxlIHZlZGXIm2kgw65uIGRhdGVsZSBkdnMuIHBlIGR1cmF0YSB1bmVpIHppbGUgc2F1IGEgdW51aSBhbi4gRGUgZXhlbXBsdSwgZGFjxIMgdsSDIGHImXRlcHRhyJtpIGNhIGRhdGVsZSBkdnMuIHPEgyB0cmVhY8SDIHByaW4gZG91xIMgY2ljbHVyaSBkZSB2YXJpYcibaWUgcGUgcGFyY3Vyc3VsIHVudWkgYW4sIGx1bmdpbWVhIGNpY2x1bHVpIHZhIGZpIGRlIDE4Miw1IHppbGUgc2F1IGRlIDAsNSBhbmkuIERhY8SDIGF2ZcibaSBkYXRlIGRlc3ByZSB0ZW1wZXJhdHVyxIMgY29sZWN0YXRlIGxhIGZpZWNhcmUgdHJlaSBvcmUgyJlpIGV4aXN0xIMgdW4gY2ljbHUgZGUgdmFyaWHIm2llIHBlIHppLCBsdW5naW1lYSBjaWNsdWx1aSBlc3RlIGRlIG8gemkuPC9kaXY+PGJyPjxkaXY+UGFyYW1ldHJ1bCA8c3Ryb25nPkZyZWN2ZW7Im8SDPC9zdHJvbmc+IHBlbnRydSBhbmFsaXphIHRlbmRpbsibZWkgYXJtb25pY2UgZXN0ZSBmb2xvc2l0IHBlbnRydSBhIGRlc2NyaWUgbW9kZWx1bCBhcm1vbmljIGNhcmUgc8SDIGNvcmVzcHVuZMSDIGRhdGVsb3IuIERhY8SDIGZyZWN2ZW7Im2EgZXN0ZSBzZXRhdMSDIGxhIDEsIG8gY29tYmluYcibaWUgYSB1bmVpIGN1cmJlIGFybW9uaWNlIGxpbmlhcmUgyJlpIGRlIHByaW0gb3JkaW4gdmEgZmkgZm9sb3NpdMSDIHBlbnRydSBhIGNvcmVzcHVuZGUgbW9kZWx1bHVpLiBEYWPEgyBmcmVjdmVuyJthIGVzdGUgMiwgbyBjb21iaW5hyJtpZSBhIGN1cmJlaSBhcm1vbmljZSBsaW5pYXJlLCBkZSBwcmltIG9yZGluIMiZaSBhIGN1cmJlaSBhcm1vbmljZSBkZSBvcmRpbiBkb2kgdmEgZmkgZm9sb3NpdMSDIHBlbnRydSBhIGNvcmVzcHVuZGUgZGF0ZWxvci4gRGFjxIMgZnJlY3ZlbsibYSBlc3RlIDMsIG8gY3VyYsSDIGFybW9uaWPEgyBzdXBsaW1lbnRhcsSDIGRlIG9yZGluIHRyZWkgdmEgZmkgZm9sb3NpdMSDIHBlbnRydSBtb2RlbGFyZWEgZGF0ZWxvciwgyJlpIGHImWEgbWFpIGRlcGFydGUuPC9kaXY+PGJyPjxkaXY+U3RhdGlzdGljaWxlIHByaXZpbmQgaW5kaWNlbGUgZGUgY29uY29yZGFuyJvEgyBhbCBtb2RlbHVsdWkgcG90IGZpIGdlbmVyYXRlIGNhIGllyJlpcmkgb3DIm2lvbmFsZS4gRXJvYXJlYSByxINkxINjaW5paSBtZWRpaSBwxIN0cmF0ZSAoUk1TRSksIFIgcMSDdHJhdCDImWkgdmFsb2FyZWEgcCBhIHBhbnRlaSBkZSB0ZW5kaW7Im8SDIHBvdCBmaSBjYWxjdWxhdGUgyJlpIHNpbWJvbGl6YXRlLiBTaW1ib2xpemHIm2kgc3RyYXR1bCB0ZW1hdGljIGFsIHJhc3RlcnVsdWkgZGUgdGVuZGluyJvEgyBkZSBpZciZaXJlIGN1IGFqdXRvcnVsIHNlbWlvdGljaWkgPHN0cm9uZz5SR0I8L3N0cm9uZz4gyJlpIHNwZWNpZmljYcibaSBzdGF0aXN0aWNpbGUgY2EgZmlpbmQgYmVuemlsZSByb8iZaWUsIHZlcmRlIMiZaSBhbGJhc3RyxIMuPC9kaXY+PGJyPlwiLFxuXHRcdHNwZWN0cmFsVW5taXhpbmdOYW1lOiBcIlN0cmF0aWZpY2FyZWEgc3BlY3RyYWzEgyBsaW5pYXLEg1wiLFxuXHRcdHNwZWN0cmFsVW5taXhpbmdTbmlwOiBcIkVmZWN0dWVhesSDIGNsYXNpZmljYXJlYSBzdWJwaXhlbGlsb3IgyJlpIGNhbGN1bGVhesSDIGFidW5kZW7Im2EgZnJhY8ibaW9uYXLEgyBhIHRpcHVyaWxvciBkaWZlcml0ZSBkZSBhY29wZXJpcmkgZGUgc29sIHBlbnRydSBwaXhlbGkgaW5kaXZpZHVhbGkuXCIsXG5cdFx0c3BlY3RyYWxVbm1peGluZ0Rlc2M6IFwiRnVuY8ibaWEgU3RyYXRpZmljYXJlYSBzcGVjdHJhbMSDIGxpbmlhcsSDIGNhbGN1bGVhesSDIGFjb3BlcmlyZWEgZnJhY8ibaW9uYXLEgyBwZW50cnUgcGl4ZWxpIGluZGl2aWR1YWxpIGNhcmUgY29uyJtpbiBtYWkgbXVsdGUgdGlwdXJpIGRlIGFjb3BlcmlyaSBkZSBzb2wuIEdlbmVyZWF6xIMgdW4gc3RyYXQgdGVtYXRpYyBjdSBiZW56aSBtdWx0aXBsZSwgdW5kZSBmaWVjYXJlIGJhbmTEgyBjb3Jlc3B1bmRlIGFidW5kZW7Im2VpIGZyYWPIm2lvbmFyZSBhIGZpZWPEg3JlaSBjbGFzZSBkZSBhY29wZXJpcmUgZGUgc29sLiBEZSBleGVtcGx1LCBkYWPEgyBvIHV0aWxpemHIm2kgcGVudHJ1IGEgZWZlY3R1YSBjbGFzaWZpY2FyZWEgYWNvcGVyaXJpaSBkZSBzb2wgcGUgbyBpbWFnaW5lIG11bHRpc3BlY3RyYWzEgyBwZW50cnUgaWRlbnRpZmljYXJlYSB2ZWdldGHIm2llaSBmb3Rvc2ludGV0aWNlLCBzb2x1bCBkZXpnb2xpdCDImWkgdmVnZXRhyJtpYSBtb2FydMSDIHNhdSBuZWZvdG9zaW50ZXRpY8SDLjxkaXY+PGJyLz5PcmRpbmVhIHJhc3RlcnVsdWkgY3UgYmVuemkgbXVsdGlwbGUgZGUgaWXImWlyZSB1cm1lYXrEgyBvcmRpbmVhIHByb2ZpbHVsdWkgc3BlY3RyYWwgZGUgaW50cmFyZS4gTnVtxINydWwgZGUgY2xhc2UgbnUgcG9hdGUgZGVwxIPImWkgbnVtxINydWwgZGUgYmVuemkgZGluIHJhc3RlcnVsIGRlIGludHJhcmUuIERlIGV4ZW1wbHUsIG51IHB1dGXIm2kgZXh0cmFnZSBpbmZvcm1hyJtpaSBkZXNwcmUgbWFpIG11bHQgZGUgOCBjbGFzZSBkaW50ci11biByYXN0ZXIgZGUgOCBiZW56aS48L2Rpdj5cIixcblx0XHRtdWx0aWRpbWVuc2lvbmFsRmlsdGVyTmFtZTogXCJGaWx0cnUgbXVsdGlkaW1lbnNpb25hbFwiLFxuXHRcdGludGVycG9sYXRlUmFzdGVyQnlEaW1lbnNpb25GdW5jdGlvbk5hbWU6IFwiSW50ZXJwb2xhyJtpIHJhc3RlcnVsIMOubiBmdW5jyJtpZSBkZSBkaW1lbnNpdW5lXCIsXG5cdFx0aW50ZXJwb2xhdGVSYXN0ZXJCeURpbWVuc2lvbkZ1bmN0aW9uU25pcDogXCJJbnRlcnBvbGVhesSDIHVuIHJhc3RlciBtdWx0aWRpbWVuc2lvbmFsIGxhIHZhbG9yaWxlIGRlIGRpbWVuc2l1bmUgc3BlY2lmaWNhdGUgZm9sb3NpbmQgc2VnbWVudGUgYWRpYWNlbnRlLlwiLFxuXHRcdGludGVycG9sYXRlUmFzdGVyQnlEaW1lbnNpb25GdW5jdGlvbkRlc2M6IFwiPHA+QWNlYXN0xIMgZnVuY8ibaWUgdsSDIHBlcm1pdGUgc8SDIGVzdGltYcibaSB2YWxvcmlsZSDDrm4gcGl4ZWxpIHBlbnRydSBvIGRpbWVuc2l1bmUgbmVkZWZpbml0xIMgZGludHItdW4gcmFzdGVyIG11bHRpZGltZW5zaW9uYWwuIERlIGV4ZW1wbHUsIGRhY8SDIGF2ZcibaSB1biBzZXQgZGUgZGF0ZSBjYXJlIGNvbsibaW5lIHRlbXBlcmF0dXJhIG9jZWFudWx1aSBsYSBuaXZlbHVsIGRlIHN1cHJhZmHIm8SDIMiZaSBsYSAxMDAgZGUgbWV0cmkgc3ViIG5pdmVsdWwgbcSDcmlpIMiZaSBkb3JpyJtpIHPEgyBlc3RpbWHIm2kgdGVtcGVyYXR1cmEgbGEgc3ViIDUwIGRlIG1ldHJpIHN1YiBuaXZlbHVsIG3Eg3JpaSwgcHV0ZcibaSB1dGlsaXphIGFjZWFzdMSDIGZ1bmPIm2llIHBlbnRydSBhIG9iyJtpbmUgbyBlc3RpbWFyZSBsYSBhY2VhIGFkw6JuY2ltZSBmb2xvc2luZCBkZWZpbmnIm2lhIGRpbWVuc2l1bmlpIGR1cMSDIHZhbG9yaS48L3A+PHA+UHV0ZcibaSwgZGUgYXNlbWVuZWEgcmVkdWNlyJtpIG51bcSDcnVsIGRlIHByb2JlIGFsZSB1bnVpIHNldCBkZSBkYXRlIGx1bmFyIGxhIHVuIHNldCBkZSBkYXRlIHppbG5pYyBmb2xvc2luZCBkZWZpbmnIm2lhIGRpbWVuc2l1bmlpIGR1cMSDIGludGVydmFsIMiZaSBzcGVjaWZpY8OibmQgdmFsb2FyZWEgcGFyYW1ldHJ1bHVpIFBhcyBsYSAxIMiZaSB2YWxvYXJlYSBwYXJhbWV0cnVsdWkgVW5pdGF0ZSBsYSBaaWxlLjwvcD48cD5Gb2xvc2nIm2kgZGVmaW5pyJtpYSBkaW1lbnNpdW5paSByYXN0ZXJ1bHVpIMOubiBmdW5jyJtpZSBkZSDIm2ludMSDIHBlbnRydSBhIGVzdGltYSB2YWxvYXJlYSBwZW50cnUgUmFzdGVydWwgyJtpbnTEgy48L3A+XCIsXG5cdFx0bXVsdGlkaW1lbnNpb25hbEZpbHRlclNuaXA6IFwiQ3JlZWF6xIMgdW4gc3RyYXQgdGVtYXRpYyByYXN0ZXIgZGludHItdW4gc2V0IGRlIGRhdGUgZGUgcmFzdGVyIG11bHRpZGltZW5zaW9uYWwgcHJpbiBzZWdtZW50YXJlYSBkYXRlbG9yIGxhIG5pdmVsdWwgdmFyaWFiaWxlbG9yIMiZaSBhbCBkaW1lbnNpdW5pbG9yIGRlZmluaXRlLlwiLFxuXHRcdG11bHRpZGltZW5zaW9uYWxGaWx0ZXJEZXNjOiBcIkZpbHRydWwgbXVsdGlkaW1lbnNpb25hbCBjcmVlYXrEgyB1biBzdHJhdCB0ZW1hdGljIGRlIHJhc3RlciBtdWx0aWRpbWVuc2lvbmFsIHByaW4gZmlsdHJhcmVhIMiZaSBleHRyYWdlcmVhIHVudWkgc3Vic2V0IGRlIHZhcmlhYmlsZSBkaW50ci11biByYXN0ZXIgbXVsdGlkaW1lbnNpb25hbC4gRGUgZXhlbXBsdSwgYXZlyJtpIHVuIHNldCBkZSBkYXRlIG11bHRpZGltZW5zaW9uYWwgY2FyZSBjb27Im2luZSBkYXRlIGx1bmFyZSBkZXNwcmUgcHJlY2lwaXRhyJtpaSBwZW50cnUgMzAgZGUgYW5pIMiZaSBkb3JpyJtpIHPEgyBleHRyYWdlyJtpIGRvYXIgZGF0ZWxlIHBlbnRydSBpYW51YXJpZSBwZW50cnUgYSB2ZWRlYSBjdW0gcy1hdSBzY2hpbWJhdCBwcmVjaXBpdGHIm2lpbGUgcGVudHJ1IGx1bmEgcmVzcGVjdGl2xIMuPGRpdj48YnIvPlV0aWxpemFyZWEgcGFyYW1ldHJ1bHVpIERlZmluacibaWEgZGltZW5zaXVuaWkgcGVudHJ1IGEgc2VnbWVudGEgZGltZW5zaXVuaWxlIHV0aWxpesOibmQgdW4gaW50ZXJ2YWwsIG8gdmFsb2FyZSBzYXUgdW4gaW50ZXJ2YWwgZGUgdmFsb3JpLiBEZSBleGVtcGx1LCBkYWPEgyBhdmXIm2kgZGF0ZSBkZXNwcmUgc2FsaW5pdGF0ZWEgb2NlYW5lbG9yIHBlbnRydSAxMCBhbmksIGNvbGVjdGF0ZSBsdW5hciDImWkgbGEgbyBhZMOibmNpbWUgZGUgMiBww6JuxIMgbGEgNTAwIGRlIG1ldHJpLCBhyJtpIHB1dGVhIHV0aWxpemEgb3DIm2l1bmkgZGlmZXJpdGUgcGVudHJ1IGRlZmluacibaWEgZGltZW5zaXVuaWkgcGVudHJ1IHVybcSDdG9hcmVsZSBzY2VuYXJpaS4gU2NlbmFyaXVsIDE6IEV4dHJhZ2XIm2kgZGF0ZSBkZXNwcmUgc2FsaW5pdGF0ZSBwZW50cnUgaWFudWFyaWUgcGVudHJ1IHBlcmlvYWRlIGRlIDEwIGFuaS4gQWxlZ2XIm2kgRHVwxIMgdmFsb3JpLCBzZXRhyJtpIERpbWVuc2l1bmUgbGEgU3RkVGltZSDImWkgVmFsb3JpIGxhIElhbnVhcmllLiBTY2VuYXJpdWwgMjogU2VnbWVudGHIm2kgZGF0ZWxlIGRlc3ByZSBzYWxpbml0YXRlIGR1cMSDIHVuIGludGVydmFsIGRlIGFkw6JuY2ltZSwgZGUgbGEgMCBsYSAxNTAgZGUgbWV0cmkuIEFsZWdlyJtpIER1cMSDIGludGVydmFsZSwgc2V0YcibaSBEaW1lbnNpdW5lIGxhIFN0ZFogyJlpIFZhbG9hcmUgbWluaW3EgyBsYSAtMTUwLCBpYXIgVmFsb2FyZSBtYXhpbcSDIGxhIDAuIFNjZW5hcml1bCAzOiBFeHRyYWdlyJtpIGRhdGUgZGVzcHJlIHNhbGluaXRhdGUgcGVudHJ1IHByaW1lbGUgMTAgemlsZSBkaW4gaWFudWFyaWUgcGVudHJ1IG8gcGVyaW9hZMSDIGRlIDEwIGFuaS4gQWxlZ2XIm2kgRHVwxIMgaXRlcmHIm2llLCBzZXRhyJtpIERpbWVuc2l1bmUgbGEgU3RkVGltZSwgc2V0YcibaSDDjm5jZXB1dHVsIHByaW1laSBpdGVyYcibaWkgyJlpIFNmw6JyyJlpdHVsIHByaW1laSBpdGVyYcibaWkgbGEgw65uY2VwdXR1bCDImWkgc2bDonLImWl0dWwgY29yZXNwdW56xIN0b2FyZSBwZW50cnUgcGVyaW9hZGEgZGUgaXRlcmHIm2llLCBzZXRhyJtpIFBhc3VsIGxhIDEgyJlpIFVuaXRhdGUgbGEgQW5pLjwvZGl2PlwiLFxuXHRcdG11bHRpZGltZW5zaW9uYWxSYXN0ZXJOYW1lOiBcIlJhc3RlciBtdWx0aWRpbWVuc2lvbmFsXCIsXG5cdFx0bXVsdGlkaW1lbnNpb25hbFJhc3RlclNuaXA6IFwiQWRhdWfEgyBkYXRlIG11bHRpZGltZW5zaW9uYWxlIGxhIG8gaGFydMSDIGNhIHVuIHN0cmF0IHRlbWF0aWMgZGUgcmFzdGVyIG11bHRpZGltZW5zaW9uYWwuXCIsXG5cdFx0bXVsdGlkaW1lbnNpb25hbFJhc3RlckRlc2M6IFwiRnVuY8ibaWEgUmFzdGVyIG11bHRpZGltZW5zaW9uYWwgYWRhdWfEgyBkYXRlIG11bHRpZGltZW5zaW9uYWxlIGxhIG8gaGFydMSDIGNhIHVuIHN0cmF0IHRlbWF0aWMgZGUgcmFzdGVyIG11bHRpZGltZW5zaW9uYWwuIEFjZWFzdMSDIGZ1bmPIm2llIGVzdGUgdXRpbMSDIGxhIGVmZWN0dWFyZWEgZmx1eHVyaWxvciBkZSBsdWNydSBwZW50cnUgYW5hbGl6YSBkZSByYXN0ZXIgdXRpbGl6w6JuZCB1biBsYW7ImyBkZSBmdW5jyJtpaS48ZGl2Pjxici8+U2V0dXJpbGUgZGUgZGF0ZSByYXN0ZXIgbXVsdGlkaW1lbnNpb25hbCBhY2NlcHRhdGUgaW5jbHVkIG5ldENERiwgR1JJQiwgSERGIMiZaSBDUkYgZGUgbGEgRXNyaS4gRGUgYXNlbWVuZWEsIHN1bnQgYWNjZXB0YXRlIHNldHVyaSBkZSBkYXRlIG1vemFpYyBtdWx0aWRpbWVuc2lvbmFsZS48L2Rpdj5cIixcblx0XHRvcHRpbWFsUGF0aEFzUmFzdGVyTmFtZTogXCJUcmFzZXUgb3B0aW0gY2EgcmFzdGVyXCIsXG5cdFx0b3B0aW1hbFBhdGhBc1Jhc3RlclNuaXA6IFwiQ2FsY3VsZWF6xIMgdHJhc2V1bCBjdSBjZWwgbWFpIG1pYyBjb3N0IGRpbnRyLW8gc3Vyc8SDIGxhIG8gZGVzdGluYcibaWUuXCIsXG5cdFx0b3B0aW1hbFBhdGhBc1Jhc3RlckRlc2M6IFwiQWNlYXN0xIMgZnVuY8ibaWUgZ2xvYmFsxIMgcHJvZHVjZSB1biByYXN0ZXIgZGUgaWXImWlyZSBjYXJlIMOubnJlZ2lzdHJlYXrEgyB0cmFzZXVsIHNhdSB0cmFzZWVsZSBvcHRpbWUgZGluIGxvY2HIm2lpIHNlbGVjdGF0ZSBww6JuxIMgbGEgY2VhIG1haSBhcHJvcGlhdMSDIHN1cnPEgyBkZWZpbml0xIMgw65uIHN1cHJhZmHIm2EgZGUgY29zdCBhY3VtdWxhdGl2xIMsIGN1IHByaXZpcmUgbGEgZGlzdGFuyJthIGRlIGNvc3QuPGRpdj48YnIvPlVuYSBzYXUgbWFpIG11bHRlIGZ1bmPIm2lpIGRlIGNvc3QgcG9uZGVyYXQgKEFjdW11bGFyZWEgRGlzdGFuyJtlaSDImWkgQWxvY2FyZWEgRGlzdGFuyJtlaSkgdHJlYnVpZSwgw65uIGdlbmVyYWwsIHJ1bGF0ZSDDrm5haW50ZSBkZSBydWxhcmVhIGZ1bmPIm2llaSBUcmFzZXUgb3B0aW0gY2EgcmFzdGVyIHBlbnRydSBjcmVhcmVhIHJhc3RlcmVsb3IgZGUgYWN1bXVsYXJlIGEgZGlzdGFuyJtlaSDImWkgZGUgZGlyZWPIm2llIGludmVyc8SDIGRlIGludHJhcmUuIEFjZXN0ZWEgc3VudCBzdHJhdHVyaSB0ZW1hdGljZSBkZSB0aXAgcmFzdGVyIGRlIGludHJhcmUgb2JsaWdhdG9yaWkgcGVudHJ1IGZ1bmPIm2lhIFRyYXNldSBvcHRpbS4gVmFsb3JpbGUgcGVudHJ1IHRyYXNldWwgb3B0aW0gZGUgaWXImWlyZSByZXByZXppbnTEgyBudW3Eg3J1bCB0cmFzZWUgcGVudHJ1IG8gbG9jYcibaWUgZGF0xIMuIMOObiBtdWx0ZSBjYXp1cmksIHRyYXNlZWxlIHVybWVhesSDIGFjZWVhyJlpIHJ1dMSDLCBwxINyxINzaW5kIG8gc3Vyc8SDIMiZaSBhcG9pIGRpdmVyZ8OibmQgcGVudHJ1IGEgc2Ugw65uZHJlcHRhIGPEg3RyZSBkZXN0aW5hyJtpaSBkaWZlcml0ZS4gRGUgZXhlbXBsdSwgdmFsb2FyZWEgMSBpbmRpY8SDIGZhcHR1bCBjxIMgZXhpc3TEgyB1biBzaW5ndXIgdHJhc2V1IG9wdGltIHBlbnRydSBvIGxvY2HIm2llIGRhdMSDLCDDrm4gdGltcCBjZSB2YWxvYXJlYSA1IMOubnNlYW1uxIMgY8SDLCBwZW50cnUgbG9jYcibaWEgcmVzcGVjdGl2xIMsIGV4aXN0xIMgY2luY2kgdHJhc2VlIG9wdGltZSBjYXJlIHBhcmN1cmcgY2VsdWxhIHJlc3BlY3RpdsSDIMOubiBjYWRydWwgem9uZWkgZGUgc3R1ZGl1LjxkaXY+PGJyLz5EYXRlbGUgZGUgZGVzdGluYcibaWUgZGUgaW50cmFyZSB0cmVidWllIHPEgyBmaWUgdW4gc3RyYXQgdGVtYXRpYyBkZSB0aXAgcmFzdGVyLiBTZXR1bCBkZSBjZWx1bGUgZGUgZGVzdGluYcibaWUgY29uc3TEgyDDrm4gdG9hdGUgY2VsdWxlbGUgZGluIHJhc3RlcnVsIGRlIGludHJhcmUgY2FyZSBhdSB2YWxvcmkgdmFsaWRlLiBDZWx1bGVsZSBjYXJlIGF1IHZhbG9yaSBOb0RhdGEgbnUgc3VudCBpbmNsdXNlIMOubiBzZXQuIFZhbG9hcmVhIHplcm8gZXN0ZSBjb25zaWRlcmF0xIMgbyBkZXN0aW5hyJtpZSBsZWdpdGltxIMuIFVuIHJhc3RlciBkZSBkZXN0aW5hyJtpZSBwb2F0ZSBmaSBjcmVhdCB1dGlsaXrDom5kIGluc3RydW1lbnRlbGUgZGUgZXh0cmFnZXJlLiBEYWPEgyBhdmXIm2kgb2JpZWN0ZSBzcGHIm2lhbGUgZGUgZGVzdGluYcibaWUgc2F1IGRlIHN1cnPEgywgbGUgcHV0ZcibaSBjb252ZXJ0aSDDrm4gcmFzdGVyIHV0aWxpesOibmQgZnVuY8ibaWEgUmFzdGVyaXphcmVhIG9iaWVjdGVsb3Igc3BhyJtpYWxlLiBVdGlsaXphyJtpIHJhc3RlcnVsIGRlIGFjdW11bGFyZSBhIGRpc3RhbsibZWkgc2F1IGRlIGRpcmVjyJtpZSBpbnZlcnPEgyBjYSBSYXN0ZXIgZGUgaW50cmFyZSBwZW50cnUgZnVuY8ibaWEgZGUgcmFzdGVyaXphcmUuIEFjZXN0IGx1Y3J1IHZhIGFzaWd1cmEgZmFwdHVsIGPEgyByZXNwZWN0aXZ1bCBvYmllY3Qgc3BhyJtpYWwgZXN0ZSByYXN0ZXJpemF0IHV0aWxpesOibmQgYWNlZWHImWkgZGltZW5zaXVuZSwgbcSDcmltZSDImWkgcmVmZXJpbsibxIMgc3BhyJtpYWzEgyBwZW50cnUgY2VsdWzEgywgcHJlY3VtIGNlbGVsYWx0ZSByYXN0ZXJlIGNhcmUgZmFjIG9iaWVjdHVsIGZ1bmPIm2llaSBUcmFzZXUgb3B0aW0gY2EgcmFzdGVyLiBGdW5jyJtpYSBUcmFzZXUgb3B0aW0gY2EgcmFzdGVyIHBvYXRlIGZpIHV0aWxpemF0xIMgyJlpIHBlbnRydSBhIGRlcml2YSB0cmFzZXVsIGN1IGNlYSBtYWkgbWljxIMgcmV6aXN0ZW7Im8SDIGPEg3RyZSB1biBtb2RlbCBkZSBlbGV2YcibaWUgZGlnaXRhbMSDIChERU0pLiDDjm4gYWNlc3QgY2F6LCB1dGlsaXphyJtpIERFTSBwZW50cnUgcmFzdGVydWwgZGUgYWN1bXVsYXJlIGEgZGlzdGFuyJtlaSBkZSBpbnRyYXJlIMiZaSBkZSBpZciZaXJlIGRpbiBmdW5jyJtpYSBEaXJlY8ibaWEgZmx1eHVsdWkgcGVudHJ1IFJhc3RlcnVsIGRlIGRpcmVjyJtpZSBpbnZlcnPEgy48L2Rpdj5cIixcblx0XHR0cmVuZE5hbWU6IFwiUHJlZGljyJtpYSBVdGlsaXrEg3JpaSBUZW5kaW7Im2VpXCIsXG5cdFx0dHJlbmRTbmlwOiBcIkNhbGN1bGVhesSDIHVuIHN0cmF0IHRlbWF0aWMgZGUgdGlwIHJhc3RlciBtdWx0aWRpbWVuc2lvbmFsIHByb2dub3phdCBmb2xvc2luZCByYXN0ZXJ1bCBkZSB0ZW5kaW7Im2UgcmV6dWx0YW50IGRpbiBmdW5jyJtpYSBHZW5lcmFyZWEgVGVuZGluyJtlaSBzYXUgZGluIGluc3RydW1lbnR1bCBkZSBnZW9wcm9jZXNhcmUgR2VuZXJhcmVhIFJhc3RlcnVsdWkgZGUgVGVuZGluyJtlLlwiLFxuXHRcdHRyZW5kRGVzYzogXCJGdW5jyJtpYSBQcmVkaWPIm2lhIFV0aWxpesSDcmlpIFRlbmRpbsibZWkgY2FsY3VsZWF6xIMgdW4gc3RyYXQgdGVtYXRpYyBkZSB0aXAgcmFzdGVyIG11bHRpZGltZW5zaW9uYWwgcHJvZ25vemF0IGZvbG9zaW5kIHJhc3RlcnVsIGRlIHRlbmRpbsibZSByZXp1bHRhbnQgZGluIGZ1bmPIm2lhIEdlbmVyYXJlYSBUZW5kaW7Im2VpIHNhdSBkaW4gaW5zdHJ1bWVudHVsIGRlIGdlb3Byb2Nlc2FyZSBHZW5lcmFyZWEgUmFzdGVydWx1aSBkZSBUZW5kaW7Im2UuXCIsXG5cdFx0cmFzdGVyQ29sbGVjdGlvbk5hbWU6IFwiUHJvY2VzYXJlIGNvbGVjyJtpZSByYXN0ZXJcIixcblx0XHRyYXN0ZXJDb2xsZWN0aW9uU25pcDogXCJQcm9jZXNlYXrEgyBmaWVjYXJlIHNlZ21lbnQgZGludHItdW4gcmFzdGVyIG11bHRpZGltZW5zaW9uYWwgc2F1IGZpZWNhcmUgcmVwZXIgZGludHItdW4gcmFzdGVyIG1vemFpYy4gQWNlYXN0xIMgZnVuY8ibaWUgcG9hdGUsIGRlIGFzZW1lbmVhLCBzxIMgZWZlY3R1ZXplIGFncmVnYXJlYSBtYWkgbXVsdG9yIHNlZ21lbnRlIMOubnRyLXVuIHNpbmd1ciBzZWdtZW50LlwiLFxuXHRcdHJhc3RlckNvbGxlY3Rpb25EZXNjOiBcIkZ1bmPIm2lhIFByb2Nlc2FyZSBjb2xlY8ibaWUgcmFzdGVyIHByb2Nlc2VhesSDIGZpZWNhcmUgc2VnbWVudCBkaW50ci11biByYXN0ZXIgbXVsdGlkaW1lbnNpb25hbCBzYXUgZmllY2FyZSByZXBlciBkaW50ci11biByYXN0ZXIgbW96YWljLiBBY2Vhc3TEgyBmdW5jyJtpZSBwb2F0ZSwgZGUgYXNlbWVuZWEsIHPEgyBlZmVjdHVlemUgYWdyZWdhcmVhIG1haSBtdWx0b3Igc2VnbWVudGUgw65udHItdW4gc2luZ3VyIHNlZ21lbnQuPGRpdj48YnIvPkFjZWFzdMSDIGZ1bmPIm2llIHByb2Nlc2VhesSDIGZpZWNhcmUgc2VnbWVudCBkaW50ci11biByYXN0ZXIgbXVsdGlkaW1lbnNpb25hbCBzYXUgZGluIHJhc3RlcnVsIG1vemFpYyBjYXJlIHV0aWxpemVhesSDIHVuIMiZYWJsb24gZGUgZnVuY8ibaWUgcmFzdGVyLiBBY2Vhc3TEgyBmdW5jyJtpZSBhY2NlcHTEgyB1cm3Eg3RvYXJlbGUgb3DIm2l1bmk6IDEuIFNwZWNpZmljYcibaSB1biDImWFibG9uIGRlIGZ1bmPIm2llIHJhc3RlciBwZW50cnUgRnVuY8ibaWEgUmVwZXIuIERlIGV4ZW1wbHUsIGF2ZcibaSB1biBzZXQgZGUgZGF0ZSBtb3phaWMgY2FyZSBjb27Im2luZSAyMCBkZSBhbmkgZGUgaW1hZ2luaSBMYW5kc2F0IMiZaSBkb3JpyJtpIHPEgyBjYWxjdWxhyJtpIE5EVkkgcGVudHJ1IGZpZWNhcmUgc2NlbsSDIGRpbiBzZXJpYSB0ZW1wb3JhbMSDLiBQZW50cnUgZnVuY8ibaWEgUmVwZXIsIHNwZWNpZmljYcibaSB1biDImWFibG9uIGRlIGZ1bmPIm2llIHJhc3RlciBjYXJlIGNvbsibaW5lIGZ1bmPIm2lhIHJhc3RlciBORFZJLiAyLiBTcGVjaWZpY2HIm2kgdW4gyJlhYmxvbiBkZSBmdW5jyJtpZSByYXN0ZXIgcGVudHJ1IEZ1bmPIm2lhIEFncmVnYXJlLiBEZSBleGVtcGx1LCBhdmXIm2kgdW4gcmFzdGVyIG11bHRpZGltZW5zaW9uYWwgY2FyZSBjb27Im2luZSBkYXRlIHppbG5pY2UgZGUgdGVtcGVyYXR1csSDIHBlbnRydSAxMCBhbmkgyJlpIGRvcmnIm2kgc8SDIGNhbGN1bGHIm2kgdGVtcGVyYXR1cmEgbWF4aW3EgyBwZW50cnUgZmllY2FyZSBhbi4gw45uIGZ1bmPIm2lhIEFncmVnYXJlLCBzcGVjaWZpY2HIm2kgdW4gyJlhYmxvbiBkZSBmdW5jyJtpZSByYXN0ZXIgY2FyZSBjb27Im2luZSBmdW5jyJtpYSBTdGF0aXN0aWNpbGUgY2VsdWxlaSwgY3Ugb3BlcmHIm2lhIHNldGF0xIMgbGEgTWF4aW11bS4gTGEgRGVmaW5pyJtpYSBhZ3JlZ8SDcmlpLCBzZXRhyJtpIERpbWVuc2l1bmUgbGEgU3RkVGltZSwgVGlwIGxhIEN1dsOibnQgY2hlaWUgaW50ZXJ2YWwgyJlpIEludGVydmFsIGN1dsOibnQgY2hlaWUgbGEgQW51YWwuIFJlyJtpbmXIm2kgZmFwdHVsIGPEgyBzZXR1bCBkZSBkYXRlIG1vemFpYyBkZSBpbnRyYXJlIG51IGVzdGUgbXVsdGlkaW1lbnNpb25hbCwgaWFyIGZ1bmPIm2lhIGRlIGFncmVnYXJlIG51IHZhIHJlc3BlY3RhIGRlZmluacibaWEgYWdyZWfEg3JpaS4gRnVuY8ibaWEgZGUgYWdyZWdhcmUgdmEgYWdyZWdhIHRvYXRlIHJlcGVyZWxlIHNhdSBmaWVjYXJlIGdydXAgw65udHItdW51bCBkYWPEgyBhY2VzdGVhIHN1bnQgZGVmaW5pdGUgw65uIMiZYWJsb251bCBmdW5jyJtpZWkgZGUgYWdyZWdhcmUuIFBlbnRydSBtYWkgbXVsdGUgaW5mb3JtYcibaWkgcHJpdmluZCB1dGlsaXphcmVhIGdydXB1cmlsb3Igw65udHItdW4gc2V0IGRlIGRhdGUgbW96YWljLCBjb25zdWx0YcibaSBVdGlsaXphcmVhIHJlcGVyZWxvciDDrm50ci11biBzZXQgZGUgZGF0ZSBtb3phaWMgw65uIMiYYWJsb2FuZSBkZSBmdW5jyJtpaSByYXN0ZXIuIDMuIFNwZWNpZmljYcibaSB1biDImWFibG9uIGRlIGZ1bmPIm2llIHJhc3RlciBwZW50cnUgRnVuY8ibaWEgUHJvY2VzYXJlLiBGdW5jyJtpYSBzYXUgbGFuyJt1bCBkZSBmdW5jyJtpaSBkaW4gYWNlc3QgyJlhYmxvbiBzZSB1dGlsaXplYXrEgyBwZW50cnUgYWZpyJlhcmVhIG5vdWx1aSByYXN0ZXIgcHJvY2VzYXQuIERlIGV4ZW1wbHUsIHNwZWNpZmljYcibaSB1biDImWFibG9uIGRlIGZ1bmPIm2llIHJhc3RlciBjYXJlIGNvbsibaW5lIGZ1bmPIm2lhIEhhcnRhIGN1bG9yaWkgcGVudHJ1IGEgbW9kaWZpY2EgbW9kdWwgZGUgYWZpyJlhcmUgYSBzdHJhdHVsdWkgdGVtYXRpYyBkZSB0aXAgcmFzdGVyIHByb2Nlc2F0LiBSZcibaW5lyJtpIGZhcHR1bCBjxIMsIGRhY8SDIGludHJhcmVhIGVzdGUgdW4gcmFzdGVyIG11bHRpZGltZW5zaW9uYWwsIGZ1bmPIm2lhIGRlIHByb2Nlc2FyZSBlc3RlIGFwbGljYXTEgyDDrm4gc2VnbWVudHVsIGRlIGFmaciZYXJlIGN1cmVudC4gRGFjxIMgaW50cmFyZWEgZXN0ZSB1biBzdHJhdCB0ZW1hdGljIG1vemFpYyBzYXUgdW4gc2V0IGRlIGRhdGUgbW96YWljLCBmdW5jyJtpYSBkZSBwcm9jZXNhcmUgZXN0ZSBhcGxpY2F0xIMgcmFzdGVydWx1aSBtb3phaWMgdXRpbGl6w6JuZCBwcmltYSBtZXRvZMSDIGRlIHNvbHXIm2lvbmFyZSBhIHN1cHJhcHVuZXJpbG9yLiAzLiBTcGVjaWZpY2HIm2kgyJlhYmxvYW5lbGUgcGVudHJ1IG9yaWNlIGNvbWJpbmHIm2llIGEgY2Vsb3IgdHJlaSBmdW5jyJtpaS4gRGUgZXhlbXBsdSwgYXZlyJtpIHVuIHNldCBkZSBkYXRlIG1vemFpYyBjYXJlIGNvbsibaW5lIGltYWdpbmkgTGFuZHNhdCBkZSBzZXJpaSB0ZW1wb3JhbGUgyJlpIGRvcmnIm2kgc8SDIGdlbmVyYcibaSBvIGltYWdpbmUgY29tcG96aXTEgyBhIE5EVkkgbWF4aW0uIFBlbnRydSBmdW5jyJtpYSBSZXBlciwgc3BlY2lmaWNhyJtpIHVuIMiZYWJsb24gZGUgZnVuY8ibaWUgcmFzdGVyIGNhcmUgY29uyJtpbmUgZnVuY8ibaWEgcmFzdGVyIE5EVkkuIFBlbnRydSBmdW5jyJtpYSBBZ3JlZ2FyZSwgc3BlY2lmaWNhyJtpIHVuIMiZYWJsb24gZGUgZnVuY8ibaWUgcmFzdGVyIGNhcmUgY29uyJtpbmUgZnVuY8ibaWEgU3RhdGlzdGljaWxlIGNlbHVsZWksIGN1IG9wZXJhyJtpYSBzZXRhdMSDIGxhIE1heGltdW0uIFBlbnRydSBmdW5jyJtpYSBQcm9jZXNhcmUsIHNwZWNpZmljYcibaSB1biDImWFibG9uIGRlIGZ1bmPIm2llIHJhc3RlciBjYXJlIGNvbsibaW5lIGZ1bmPIm2lhIEhhcnRhIGN1bG9yaWkuIFJlyJtpbmXIm2kgZmFwdHVsIGPEgyBvcmRpbmVhIGRlIHByb2Nlc2FyZSBhIGZ1bmPIm2lpbG9yIHVybWVhesSDIG9yZGluZWEgcGFyYW1ldHJpbG9yIGRlIGludHJhcmUuIERlIGV4ZW1wbHUsIGZ1bmPIm2lhIFJlcGVyIHZhIGZpIHByb2Nlc2F0xIMgcHJpbWEuPC9kaXY+XCIsXG5cdFx0cmFuZG9tTmFtZTogXCJBbGVhdG9yaXVcIixcblx0XHRyYW5kb21TbmlwOiBcIkNyZWVhesSDIHVuIHJhc3RlciBjdSB2YWxvcmkgYWxlIHBpeGVsaWxvciBhbGVzZSDDrm4gbW9kIGFsZWF0b3JpdSBkaW50ci1vIGRpc3RyaWJ1yJtpZSBwc2V1ZG9hbGVhdG9hcmUuIFN1bnQgYWNjZXB0YXRlIG1haSBtdWx0ZSBkaXN0cmlidcibaWkgyJlpIGdlbmVyYXRvYXJlIGRlIG51bWVyZSBhbGVhdG9yaWkuXCIsXG5cdFx0cmFuZG9tRGVzYzogXCJGdW5jyJtpYSBBbGVhdG9yaXUgY3JlZWF6xIMgdW4gcmFzdGVyIGN1IHZhbG9yaSBhbGVhdG9yaWkgYWxlIHBpeGVsaWxvciBjYXJlIHBvdCBmaSB1dGlsaXphdGUgw65uIMiZYWJsb2FuZSBkZSBmdW5jyJtpaSByYXN0ZXIgc2F1IMOubiBzZXR1cmkgZGUgZGF0ZSBtb3phaWMuPGRpdj48YnIvPkRlyJlpIG1ham9yaXRhdGVhIGZ1bmPIm2lpbG9yIGZ1bmPIm2lvbmVhesSDIHBlIHVudWwgc2F1IG1haSBtdWx0ZSByYXN0ZXJlIGRlIGludHJhcmUsIGZ1bmPIm2lhIEFsZWF0b3JpdSBudSBuZWNlc2l0xIMgdW4gcmFzdGVyIGRlIGludHJhcmUuIEFjZXN0IGx1Y3J1IMOubnNlYW1uxIMgY8SDIHNlIGNvbXBvcnTEgyBtYWkgbXVsdCBjYSB1biBzZXQgZGUgZGF0ZSByYXN0ZXIgZGVjw6J0IGNhIG8gZnVuY8ibaWUsIGHImWEgY8SDIHRyZWJ1aWUgYWNvcmRhdMSDIG8gZnVuY8ibaWUgc3BlY2lhbMSDIGxhIGFkxIN1Z2FyZWEgc2F1IGVsaW1pbmFyZWEgYWNlc3R1aWEgw65uL2RpbiBsYW7Im3VsIGRlIGZ1bmPIm2lpLjwvZGl2PlwiLFxuXHRcdHNocmlua05hbWU6IFwiTWljyJlvcmFyZVwiLFxuXHRcdHNocmlua1NuaXA6IFwiTWljyJlvcmVhesSDIHpvbmVsZSBzZWxlY3RhdGUgY3UgdW4gbnVtxINyIHNwZWNpZmljYXQgZGUgY2VsdWxlIMOubmxvY3VpbmR1LWxlIGN1IHZhbG9hcmVhIGNlbHVsZWkgY2FyZSBlc3RlIGNlYSBtYWkgZnJlY3ZlbnTEgyDDrm4gdmVjaW7Eg3RhdGVhIHNhLlwiLFxuXHRcdHNocmlua0Rlc2M6IFwiQ3UgZnVuY8ibaWEgZ2xvYmFsxIMgTWljyJlvcmFyZSwgcHV0ZcibaSBnZW5lcmFsaXphIHNhdSBzaW1wbGlmaWNhIHJhc3RlcmUgcHJpbiBtaWPImW9yYXJlYSB1bm9yIGFudW1pdGUgem9uZS4gRGUgYXNlbWVuZWEsIHB1dGXIm2kgY29udHJvbGEgZ3JhZHVsIGRlIGdlbmVyYWxpemFyZSBjZSB2YSBhdmVhIGxvYy48ZGl2Pjxici8+Wm9uZWxlIHBlIGNhcmUgbGUgc2VsZWN0YcibaSBzZSB2b3IgbWljyJlvcmEgc2F1IGxlIHZhIGZpIHJlZHVzxIMgZGltZW5zaXVuZWEgcHJpbiBleHRpbmRlcmVhIGNlbHVsZWxvciBkaW4gem9uZWxlIHZlY2luZSDDrm4gYWNlc3RlYS4gRGluIHB1bmN0IGRlIHZlZGVyZSBjb25jZXB0dWFsLCBWYWxvcmlsZSBkZSB6b27EgyBzZWxlY3RhdGUgcG90IGZpIHZpenVhbGl6YXRlIGNhIHpvbmUgZGUgcHJpbSBwbGFuLCDDrm4gdGltcCBjZSBjZWxlbGFsdGUgdmFsb3JpIHLEg23Dom4gdmFsb3JpIMOubiBmdW5kYWwuIENlbHVsZWxlIGRpbiB6b25lbGUgYWZsYXRlIMOubiBwcmltIHBsYW4gcG90IGZpIMOubmxvY3VpdGUgY3UgY2VsdWxlIGRpbiB6b25lbGUgYWZsYXRlIMOubiBmdW5kYWwuIERlIGFzZW1lbmVhLCBwb3QgZmkgw65ubG9jdWl0ZSBpbnN1bGVsZSDDrm5ndXN0ZSBkaW4gY2FkcnVsIHVuZWkgem9uZSwgY2FyZSBwb3QgZmkgY29uc2lkZXJhdGUgY2Egw65tcMSDcnTEg8iZaW5kIGxpbWl0ZWxlIGN1IHpvbmEgcmVzcGVjdGl2xIMuPGRpdj48YnIvPkdyYWR1bCBkZSBnZW5lcmFsaXphcmUgcG9hdGUgZmkgY29udHJvbGF0IGN1IHBhcmFtZXRydWwgTnVtxINyIGRlIGNlbHVsZS4gw45uIG1vZCBpbXBsaWNpdCwgYWNlYXN0xIMgdmFsb2FyZSBlc3RlIDEsIGNlZWEgY2Ugw65uc2VhbW7EgyBjxIMgem9uZWxlIHNlbGVjdGF0ZSBzZSB2b3IgbWljyJlvcmEgY3UgbyB2YWxvYXJlIGNvcmVzcHVuesSDdG9hcmUgZGltZW5zaXVuaWkgdW5laSBjZWx1bGUuIFBlbnRydSBhIG3Eg3JpIGdyYWR1bCBkZSBnZW5lcmFsaXphcmUsIHB1dGXIm2kgc3BlY2lmaWNhIG8gdmFsb2FyZSBtYWkgbWFyZSBwZW50cnUgYWNlc3QgcGFyYW1ldHJ1LiBEaW4gcHVuY3QgZGUgdmVkZXJlIGNvbmNlcHR1YWwsIGFjZXN0IGx1Y3J1IGVzdGUgc2ltaWxhciBydWzEg3JpaSBpbnN0cnVtZW50dWx1aSBjdSB1biBudW3Eg3IgZWNoaXZhbGVudCBjZWx1aSBzcGVjaWZpY2F0LCBpYXIgcmV6dWx0YXRlbGUgcnVsxINyaWkgYW50ZXJpb2FyZSByZXByZXppbnTEgyBpbnRyYXJlYSDDrm4gaXRlcmHIm2lhIHVsdGVyaW9hcsSDLjwvZGl2PlwiLFxuXHRcdHRyZW5kVG9SR0JOYW1lOiBcIlRlbmRpbsibYSBsYSBSR0JcIixcblx0XHR0cmVuZFRvUkdCU25pcDogXCJUcmFuc2Zvcm3EgyB1biByYXN0ZXIgZGUgdGVuZGluyJtlIMOubnRyLXVuIHJhc3RlciBjdSB0cmVpIGJlbnppIChyb8iZdSwgdmVyZGUgyJlpIGFsYmFzdHJ1KS5cIixcblx0XHR0cmVuZFRvUkdCRGVzYzogXCJGdW5jyJtpYSBUZW5kaW7Im8SDIGxhIFJHQiB0cmFuc2Zvcm3EgyB1biByYXN0ZXIgZGUgdGVuZGluyJtlIMOubnRyLXVuIHJhc3RlciBjdSB0cmVpIGJlbnppIChyb8iZdSwgdmVyZGUgyJlpIGFsYmFzdHJ1KS4gUmFzdGVydWwgZGUgdGVuZGluyJtlIGVzdGUgZ2VuZXJhdCBkaW4gZnVuY8ibaWEgcmFzdGVydWx1aSBHZW5lcmFyZWEgVGVuZGluyJtlaSBzYXUgYSBmdW5jyJtpZWkgcmFzdGVydWx1aSBBbmFsaXrEgyBDQ0RDLjxkaXY+PGJyLz5BY2Vhc3TEgyBmdW5jyJtpZSBlc3RlIHV0aWzEgyBwZW50cnUgdml6dWFsaXphcmVhIGRhdGVsb3IgY29lZmljaWVudHVsdWkgZGUgbW9kZWwgZGluIGZ1bmPIm2lhIEdlbmVyYXJlYSBUZW5kaW7Im2VpIHNhdSBhIGZ1bmPIm2llaSBBbmFsaXrEgyBDQ0RDOiBBbWJlbGUgZnVuY8ibaWkgZXN0aW1lYXrEgyB0ZW5kaW7Im2VsZSBkaW4gdmFsb3JpbGUgbW9kaWZpY2F0ZSBhbGUgcGl4ZWxpbG9yLCBkYXIgZXN0ZSBkaWZpY2lsIHPEgyBzZSBpbnRlcnByZXRlemUgZGlyZWN0IHJlenVsdGF0ZWxlIGZ1bmPIm2lpbG9yLjxkaXY+PGJyLz5MYSBmZWwgY2Egw65uIGNhenVsIG1haSBtdWx0b3IgZnVuY8ibaWkgZGUgcmFzdGVyLCBhciBwdXRlYSBmaSBuZWNlc2FyxIMgdXRpbGl6YXJlYSBmdW5jyJtpZWkgQWp1c3RhcmVhIGRpbmFtaWPEgyBhIGludGVydmFsdWx1aSAoRFJBKSBwZW50cnUgYWZpyJlhcmVhIMOubWJ1bsSDdMSDyJtpdMSDIGEgcmV6dWx0YXRlbG9yIGFjZXN0ZWkgZnVuY8ibaWkuPC9kaXY+XCIsXG5cdFx0bGFuZFRyZW5kck5hbWU6IFwiQW5hbGl6xIMgTGFuZFRyZW5kclwiLFxuXHRcdGxhbmRUcmVuZHJTbmlwOiBcIkV2YWx1ZWF6xIMgc2NoaW1ixINyaWxlIHZhbG9yaWxvciBwaXhlbGlsb3Igw65uIHRpbXAgY3UgYWp1dG9ydWwgbWV0b2RlaSBkZSBkZXRlY3RhcmUgcGUgYmF6YSBMYW5kc2F0IGEgdGVuZGluyJtlbG9yIGRlIGFmZWN0YXJlIMiZaSByZWN1cGVyYXJlIChMYW5kVHJlbmRyKSDImWkgZ2VuZXJlYXrEgyB1biByYXN0ZXIgY3UgYW5hbGl6YSBzY2hpbWLEg3JpaSBjYXJlIGluY2x1ZGUgcmV6dWx0YXRlbGUgbW9kZWx1bHVpLlwiLFxuXHRcdGxhbmRUcmVuZHJEZXNjOiBcIkFjZWFzdMSDIGZ1bmPIm2llIHJhc3RlciBwb2F0ZSBmaSBmb2xvc2l0xIMgZG9hciBjYSBpbnRyYXJlIHBlbnRydSBmdW5jyJtpYSByYXN0ZXIgZGUgRGV0ZWN0YXJlIGEgbW9kaWZpY8SDcmlpIGZvbG9zaW5kIGFuYWxpemEgbW9kaWZpY8SDcmlpLiBQZW50cnUgYSBnZW5lcmEgbyBpZciZaXJlIGRlIHJhc3RlciwgY29uZWN0YcibaSBmdW5jyJtpYSBBbmFsaXrEgyBMYW5kVHJlbmRyIGxhIGZ1bmPIm2lhIERldGVjdGFyZWEgbW9kaWZpY8SDcmlsb3IgdXRpbGl6w6JuZCBhbmFsaXphIG1vZGlmaWPEg3JpbG9yIMOubnRyLXVuIMiZYWJsb24gZGUgZnVuY8ibaWUgcmFzdGVyIMiZaSBmb2xvc2nIm2kgyJlhYmxvbnVsIGNhIGludHJhcmUgw65uIGluc3RydW1lbnR1bCBkZSBnZW9wcm9jZXNhcmUgR2VuZXJhyJtpIHJhc3RlciBkaW4gZnVuY8ibaWEgcmFzdGVyLiBSZXp1bHRhdHVsIGVzdGUgdW4gcmFzdGVyIGNhcmUgaW5jbHVkZSBpbmZvcm1hyJtpaSBwcml2aW5kIG9yYSBsYSBjYXJlIHMtYSBtb2RpZmljYXQgdmFsb2FyZWEgcGl4ZWx1bHVpLjxkaXY+PGJyPlNjb3B1bCBhY2VzdGVpIGZ1bmPIm2lpIHJhc3RlciBlc3RlIGFjZWxhIGRlIGEgZXh0cmFnZSBtb2RpZmljxINyaWxlIGRpbnRyLXVuIG9iaWVjdCBzcGHIm2lhbCBvYnNlcnZhdCwgYXN0ZmVsIMOubmPDonQgaW1hZ2luaWxlIG11bHRpZGltZW5zaW9uYWxlIGRlIGludHJhcmUgaWRlYWxlIHPEgyBzdXJwcmluZMSDIG8gb2JzZXJ2YXJlIGNvbnNlY3ZlbnTEgyDDrm4gdGltcCDImWkgbnUgdHJlYnVpZSBzxIMgaW5jbHVkxIMgaW50ZXJmZXJlbsibZSBhdG1vc2ZlcmljZSBzYXUgYWxlIHNlbnpvcmlsb3IsIG5vcmkgc2F1IHVtYnJlIGRlIG5vcmkuIEJ1bmVsZSBwcmFjdGljaSBzdW50IGRlIGEgdXRpbGl6YSBkYXRlbGUgY2FyZSBhdSBmb3N0IG5vcm1hbGl6YXRlIMiZaSBwb3QgZmkgbWFzY2F0ZSBjdSBhanV0b3J1bCB1bmVpIGJlbnppIFFBLCBkZSBleGVtcGx1IHByb2R1c2UgZGUgUmVmbGVjdGFuyJvEgyBhIFN1cHJhZmXIm2VpIExhbmRzYXQgQ29sZWPDomlhIDEgY3UgbyBtYXNjxIMgZGUgbm9yaS48ZGl2Pjxicj5GdW5jyJtpYSBlZmVjdHVlYXrEgyBhbmFsaXphIHBlIG8gaW1hZ2luZSBwZSBhbiwgaWFyIG51bcSDcnVsIHNlZ21lbnRlbG9yIGFudWFsZSB0cmVidWllIHPEgyBmaWUgZWdhbCBjdSBzYXUgbWFpIG1hcmUgZGUgdmFsb2FyZWEgc3BlY2lmaWNhdMSDIMOubiBwYXJhbWV0cnVsIDxzdHJvbmc+TnVtxINyIE1pbmltIGRlIE9ic2VydsSDcmk8L3N0cm9uZz4uIFNlIHJlY29tYW5kxIMgc8SDIGF2ZcibaSBtaW5pbXVtIMiZYXNlIGFuaSBkZSBkYXRlLjxkaXY+PGJyPkRhY8SDIGF2ZcibaSBkYXRlIGx1bmFyZSwgc8SDcHTEg23Dom5hbGUgc2F1IHppbG5pY2UsIHNlIHJlY29tYW5kxIMgc2VsZWN0YXJlYSBtYWkgbXVsdG9yIGltYWdpbmkgZGluIGZpZWNhcmUgYW4gKGRlIHByZWZlcmF0IGRpbiBhY2VsYciZaSBhbm90aW1wKSwgZWxpbWluYXJlYSBub3JpbG9yIMiZaSB1bWJyZWxvciBub3JpbG9yIMiZaSBjb21iaW5hcmVhIGltYWdpbmlsb3IgcGVudHJ1IGEgZ2VuZXJhIG8gc2luZ3VyxIMgaW1hZ2luZSBjYXJlIGNhcHR1cmVhesSDIGJpbmUgb2JzZXJ2YXJlYS4gRGFjxIMgc3VudCBmdXJuaXphdGUgZGF0ZSBsdW5hcmUsIHPEg3B0xINtw6JuYWxlIHNhdSB6aWxuaWNlIGNhIHJhc3RlciBtdWx0aWRpbWVuc2lvbmFsIGRlIGludHJhcmUsIGZ1bmPIm2lhIHZhIGlkZW50aWZpY2EgdW4gc2VnbWVudCBwZW50cnUgYW5hbGl6xIMgcGUgYmF6YSBkYXRlaSBjZWxlIG1haSBhcHJvcGlhdGUgZGUgZGF0YSBtZW7Im2lvbmF0xIMgw65uIHBhcmFtZXRydWwgPHN0cm9uZz5EYXRhIEZvdG9ncmFmaWVyaWk8L3N0cm9uZz4uPGRpdj48YnI+VW4gb2JpZWN0IHNwYcibaWFsIGRpbnRyLXVuIHBlaXNhaiB2YSBhdmVhIG5ldm9pZSBkZSB0aW1wIHBlbnRydSBhIHNlIHJlY3VwZXJhIMOubiB1cm1hIHVuZWkgc2NoaW1ixINyaSBuZXBlcm1hbmVudGUsIGN1bSBhciBmaSBpbmNlbmRpaWxlIGRlIHDEg2R1cmUgc2F1IGluZmVzdGFyZWEgY3UgaW5zZWN0ZS4gUGVudHJ1IGEgY29udHJvbGEgcmF0YSBkZSByZWN1cGVyYXJlIHJlY3Vub3NjdXTEgyBkZSBtb2RlbCwgc2V0YcibaSBwYXJhbWV0cnVsIFByYWcgZGUgUmVjdXBlcmFyZS4gVW4gc2VnbWVudCBkaXN0aW5jdCBudSBwb2F0ZSBhdmVhIG8gcmF0xIMgZGUgcmVjdXBlcmFyZSBtYWkgcmFwaWTEgyBkZWPDonQgcHJhZ3VsIDEvcmVjdXBlcmFyZS48ZGl2Pjxicj5SZWN1cGVyYXJlYSDDrm4gdXJtYSBzY2hpbWLEg3JpaSBwZWlzYWp1bHVpIHNlIHBvYXRlIHByb2R1Y2Ugw65uIHNlbnMgcG96aXRpdiBzYXUgbmVnYXRpdi4gRGUgZXhlbXBsdSwgYXR1bmNpIGPDom5kIMOubnRyLXVuIHBlaXNhaiBzZSBwaWVyZGUgcMSDZHVyZWEsIHNlcmlhIGRlIHRpbXAgYSB2YWxvcmlsb3IgaW5kaWNlbHVpIGRlIHZlZ2V0YcibaWUgcHJlemludMSDIG8gc2PEg2RlcmUgYSB2YWxvcmlsb3IgaW5kaWNlbHVpLCBpYXIgcmVjdXBlcmFyZWEgYXJhdMSDIG8gY3JlyJl0ZXJlIHRyZXB0YXTEgyBhIHZhbG9yaWxvciBpbmRpY2VsdWkgZGUgdmVnZXRhyJtpZSBzYXUgbyB0ZW5kaW7Im8SDIGRlIHJlY3VwZXJhcmUgcG96aXRpdsSDLiBTcGVjaWZpY2HIm2kgZGlyZWPIm2lhIHRlbmRpbsibZWkgZGUgcmVjdXBlcmFyZSBjdSBwYXJhbWV0cnVsIDxzdHJvbmc+UmVjdXBlcmFyZWEgYXJlIG8gdGVuZGluyJvEgyBjcmVzY8SDdG9hcmU8L3N0cm9uZz4uXCIsXG5cdFx0YWdncmVnYXRlTXVsdGlkaW1lbnNpb25hbE5hbWU6IFwiTXVsdGlkaW1lbnNpb25hbCBBZ3JlZ2F0XCIsXG5cdFx0YWdncmVnYXRlTXVsdGlkaW1lbnNpb25hbFNuaXA6IFwiQ29tYmluxIMgZGF0ZWxlIHZhcmlhYmlsZSByYXN0ZXIgbXVsdGlkaW1lbnNpb25hbGUgZXhpc3RlbnRlIGRpbnRyLW8gZGltZW5zaXVuZS5cIixcblx0XHRhZ2dyZWdhdGVNdWx0aWRpbWVuc2lvbmFsRGVzYzogXCJGdW5jyJtpYSBNdWx0aWRpbWVuc2lvbmFsIEFncmVnYXQgY3JlZWF6xIMgdW4gc3RyYXQgdGVtYXRpYyBkZSByYXN0ZXIgbXVsdGlkaW1lbnNpb25hbCBjb21iaW7Dom5kIGRhdGVsZSB2YXJpYWJpbGUgZGUgcmFzdGVyIG11bHRpZGltZW5zaW9uYWwgZXhpc3RlbnRlIMOubnRyLW8gZGltZW5zaXVuZS48ZGl2Pjxicj5Gb2xvc2nIm2kgcGFyYW1ldHJ1bCA8c3Ryb25nPkRlZmluacibaWEgRGltZW5zaXVuaWk8L3N0cm9uZz7CoHBlbnRydSBhIGZpbHRyYSBtYWkgw65udMOiaSBkYXRlbGUgZGUgaW50cmFyZSBwZSBjYXJlIGRvcmnIm2kgc8SDIGxlIGFncmVnYcibaS4gRGUgZXhlbXBsdSwgZGFjxIMgYXZlyJtpIDMwIGFuaSBkZSBkYXRlIGx1bmFyZSwgZGFyIGRvcmnIm2kgZG9hciBzxIMgY3JlYcibaSB1biBzdHJhdCB0ZW1hdGljIGFncmVnYXQgcGVudHJ1IHByaW1paSAxNSBhbmksIHB1dGXIm2kgdXRpbGl6YSBwYXJhbWV0cnVswqA8c3Ryb25nPkRlZmluacibaWEgRGltZW5zaXVuaWk8L3N0cm9uZz7CoCBwZW50cnUgYSBzcGVjaWZpY2EgYW5paSBkZSBpbmNsdXMgw65uIGFuYWxpesSDLjxkaXY+PGJyPjx1bD48bGk+RXh0cmFnZcibaSBkYXRlbGUgcHJpdmluZCBzYWxpbml0YXRlYSBwZW50cnUgbHVuYSBpYW51YXJpZSDDrm4gcGVyaW9hZGEgZGUgMTAgYW5pLiBBbGVnZcibaSA8c3Ryb25nPkR1cMSDIFZhbG9yaTwvc3Ryb25nPiwgc2V0YcibacKgPHN0cm9uZz5EaW1lbnNpdW5lPC9zdHJvbmc+wqBsYcKgPHN0cm9uZz5TdGRUaW1lPC9zdHJvbmc+LCDImWkgc2V0YcibaSA8c3Ryb25nPlZhbG9yaTwvc3Ryb25nPsKgbGHCoDxzdHJvbmc+aWFudWFyaWU8L3N0cm9uZz4uPC9saT48bGk+U2VnbWVudGHIm2kgZGF0ZWxlIGRlc3ByZSBzYWxpbml0YXRlIGR1cMSDIHVuIGludGVydmFsIGRlIGFkw6JuY2ltZSBkZSBsYSAwIGxhIDE1MCBtZXRyaS4gQWxlZ2XIm2kgPHN0cm9uZz5EdXDEgyBJbnRlcnZhbGU8L3N0cm9uZz4sIHNldGHIm2nCoDxzdHJvbmc+RGltZW5zaXVuZTwvc3Ryb25nPsKgbGHCoDxzdHJvbmc+U3RkWjwvc3Ryb25nPiwgyJlpIHNldGHIm2kgPHN0cm9uZz5WYWxvYXJlIE1pbmltxIM8L3N0cm9uZz7CoGxhwqA8c3Ryb25nPi0xNTA8L3N0cm9uZz7CoMiZaSA8c3Ryb25nPlZhbG9hcmUgTWF4aW3Egzwvc3Ryb25nPsKgbGHCoDxzdHJvbmc+MDwvc3Ryb25nPi48L2xpPjxsaT5FeHRyYWdlyJtpIGRhdGVsZSBwcml2aW5kIHNhbGluaXRhdGVhIHBlbnRydSBsdW5hIGlhbnVhcmllIMOubiBwZXJpb2FkYSBkZSAxMCBhbmkuIEFsZWdlyJtpIDxzdHJvbmc+RHVwxIMgSXRlcmHIm2llPC9zdHJvbmc+LCBzZXRhyJtpwqA8c3Ryb25nPkRpbWVuc2l1bmU8L3N0cm9uZz7CoGxhwqA8c3Ryb25nPlN0ZFRpbWU8L3N0cm9uZz4sIHNldGHIm2nCoDxzdHJvbmc+w45uY2VwdXR1bCBwcmltZWkgaXRlcmHIm2lpPC9zdHJvbmc+wqDImWkgPHN0cm9uZz5TZsOicsiZaXR1bCBwcmltZWkgaXRlcmHIm2lpPC9zdHJvbmc+wqBsYSDDrm5jZXB1dHVsIMiZaSBzZsOicsiZaXR1bCBjb3Jlc3B1bnrEg3RwYXJlIGFsZSBwZXJpb2FkZWkgZGUgaXRlcmFyZSwgc2V0YcibacKgPHN0cm9uZz5QYXM8L3N0cm9uZz7CoGxhwqA8c3Ryb25nPjE8L3N0cm9uZz4sIMiZaSBzZXRhyJtpwqA8c3Ryb25nPlVuaXRhdGU8L3N0cm9uZz7CoGxhwqA8c3Ryb25nPkFuaTwvc3Ryb25nPi48L2xpPjwvdWw+PGRpdj48YnI+Rm9sb3NpyJtpwqBwYXJhbWV0cmlpIDxzdHJvbmc+RGVmaW5pyJtpZSBkZSBBZ3JlZ2FyZTwvc3Ryb25nPsKgcGVudHJ1IGEgYWxlZ2UgZGltZW5zaXVuZWEgZGUgZXZhbHVhdCDImWkgaW50ZXJ2YWx1bCBkZSBhZ3JlZ2FyZSBjdSBhanV0b3J1bCB1bnVpIGN1dsOibnQgY2hlaWUsIGEgdW5laSB2YWxvcmksIGEgdW51aSBpbnRlcnZhbCBkZSB2YWxvcmkuIERlIGV4ZW1wbHUsIGRhY8SDIGF2ZcibaSAzMCBhbmkgZGUgZGF0ZSBwcml2aW5kIHRlbXBlcmF0dXJhIHN1cHJhZmXIm2VpIG3Eg3JpaSwgY29sZWN0YXRlIHppbG5pYyDIm2kgbGEgZmllY2FyZSA1IG1ldHJpIGRlIGFkw6JuY2ltZSBww6JuxIMgbGEgMTAwIG1ldHJpLCBwdXRlyJtpIHV0aWxpemEgZGl2ZXJzZWxlIG9wyJtpdW5pIGRlIGludGVydmFsIHBlbnRydSB1cm3Eg3RvYXJlbGUgc2NlbmFyaWk6PGRpdj48YnI+PHVsPjxsaT5BZ3JlZ2HIm2kgZGF0ZWxlIHByaXZpbmQgdGVtcGVyYXR1cmlsZSB6aWxuaWNlIMOubiBkYXRlIGx1bmFyZSwgdW5kZSByZXp1bHRhdHVsIGVzdGUgdW4gcmFzdGVyIG11bHRpZGltZW5zaW9uYWwgY3UgMTIgc2VnbWVudGUgZGUgdGltcCwgaWFyIGZpZWNhcmUgc2VnbWVudCBlc3RlIGFncmVnYXR1bCBmaWVjxINyZWkgbHVuaSBkaW4gdG/Im2kgYW5paS4gQTtlZ2XIm2kgPHN0cm9uZz5DdXbDom50IENoZWllIEludGVydmFsPC9zdHJvbmc+wqDImWkgc2V0YcibaSBjdXbDom50dWwgY2hlaWUgbGHCoDxzdHJvbmc+UmVjdXJlbnQgTHVuYXI8L3N0cm9uZz4uPC9saT48bGk+QWdyZWdhyJtpIGRhdGVsZSBwcml2aW5kIHRlbXBlcmF0dXJpbGUgemlsbmljZSDDrm4gZGF0ZSBsdW5hcmUsIHVuZGUgcmV6dWx0YXR1bCBlc3RlIHVuIHJhc3RlciBtdWx0aWRpbWVuc2lvbmFsIGN1IDM2MCBkZSBzZWdtZW50ZSwgc2F1IDEyIHNlZ21lbnRlIGRlIHRpbXAgcGUgYW4gKDMwIGFuaSB4IDEyIGx1bmkgPSAzNjAgc2VnbWVudGUpLiBBbGVnZcibaSA8c3Ryb25nPkN1dsOibnQgQ2hlaWUgSW50ZXJ2YWw8L3N0cm9uZz7CoMiZaSBzZXRhyJtpIGN1dsOibnR1bCBjaGVpZSBsYSA8c3Ryb25nPkx1bmFyPC9zdHJvbmc+LjwvbGk+PGxpPkFncmVnYcibaSBkYXRlbGUgcHJpdmluZCB0ZW1wZXJhdHVyaWxlIGx1bmFyZSDDrm4gaW50ZXJ2YWxlIGRlIGPDonRlIDQgbHVuaS4gQWxlZ2XIm2kgPHN0cm9uZz5WYWxvYXJlYSBJbnRlcnZhbHVsdWk8L3N0cm9uZz4sIHNldGHIm2nCoDxzdHJvbmc+VmFsb2FyZWEgSW50ZXJ2YWx1bHVpPC9zdHJvbmc+wqBsYcKgNCDImWkgc2V0YcibacKgPHN0cm9uZz5Vbml0YXRlYTwvc3Ryb25nPsKgbGHCoDxzdHJvbmc+THVuaTwvc3Ryb25nPi48L2xpPjxsaT5BZ3JlZ2HIm2kgZGF0ZWxlIHByaXZpbmQgdGVtcGVyYXR1cmlsZSBkZSBsYSAwIGxhIDI1IG1ldHJpLCBhcG9pIGRlIGxhIDI1IGxhIDUwIG1ldHJpLCBhcG9pIGRlIGxhIDUwIGxhIDEwMCBtZXRyaS4gQWxlZ2XIm2kgPHN0cm9uZz5HYW1lIGRlIEludGVydmFsPC9zdHJvbmc+wqDImWkgc3BlY2lmaWNhyJtpIGFkw6JuY2ltaWxlIG1pbmltZSDImWkgbWF4aW1lIGNhIDxzdHJvbmc+MCAyNTsgMjUgNTA7IDUwIDEwMDwvc3Ryb25nPi48L2xpPjwvdWw+XCIsXG5cdFx0bWVyZ2VSYXN0ZXJzTmFtZTogXCJGdXppb25hyJtpIHJhc3RlcmVsZVwiLFxuXHRcdG1lcmdlUmFzdGVyc1NuaXA6IFwiQ29tYmluYcibaSBzcGHIm2lhbCBzZXR1cmkgZGUgZGF0ZSBkZSByYXN0ZXIgbXVsdGlwbGUgc2F1IHBlIHZhcmlhYmlsZSDImWkgZGltZW5zaXVuaS5cIixcblx0XHRtZXJnZVJhc3RlcnNEZXNjOiBcIkFjZWFzdMSDIGZ1bmPIm2llIGNyZWVhesSDIHVuIHJhc3RlciBmdXppb25hdCBkaW50ci1vIGxpc3TEgyBkZSByYXN0ZXJlLiBEZSBleGVtcGx1LCBkYWPEgyBhdmXIm2kgdW4gc2V0IGRlIGRhdGUgbW96YWljYXQgY2FyZSBjb27Im2luZSBkYXRlIGx1bmFyZSBkZXNwcmUgcHJlY2lwaXRhyJtpaSBwZW50cnUgMzAgZGUgYW5pIMiZaSB1biBhbHQgc2V0IGRlIGRhdGUgY3UgZGF0ZSBsdW5hcmUgZGU0c3ByZSB0ZW1wZXJhdHVyaSBwZW50cnUgMTAgYW5pLCBsZSBwdXRlyJtpIGNvbWJpbmEgw65udHItdW4gcmFzdGVyIG11bHRpZGltZW5zaW9uYWwgY3UgYW1iZWxlIHZhcmlhYmlsZS4gPGRpdj48YnI+RGFjxIMgcmFzdGVyZWxlIG11bHRpZGltZW5zaW9uYWxlIGRlIGludHJhcmUgY29uyJtpbiB2YXJpYWJpbGUgZGlmZXJpdGUsIHJhc3RlcnVsIG11bHRpZGltZW5zaW9uYWwgZGUgaWXImWlyZSB2YSBpbmNsdWRlIHRvYXRlIHZhcmlhYmlsZWxlLiA8ZGl2Pjxicj5EYWPEgyByYXN0ZXJlbGUgbXVsdGlkaW1lbnNpb25hbGUgZGUgaW50cmFyZSBjb27Im2luIGRpbWVuc2l1bmkgc2F1IHZhbG9yaSBkZSBkaW1lbnNpdW5pIGRpZmVyaXRlLCByYXN0ZXJ1bCBtdWx0aWRpbWVuc2lvbmFsIGRlIGllyJlpcmUgdmEgaW5jbHVkZSB0b2F0ZSBkaW1lbnNpdW5pbGUgyJlpIHZhbG9yaWxlIGRlIGRpbWVuc2l1bmkuIDxkaXY+PGJyPkRhY8SDIHJhc3RlcmVsZSBtdWx0aWRpbWVuc2lvbmFsZSBkZSBpbnRyYXJlIGNvbsibaW4gYWNlbGVhyJlpIGRpbWVuc2l1bmkgyJlpIHZhcmlhYmlsZSwgZGFyIGV4dGluZGVyaSBzcGHIm2lhbGUgZGlmZXJpdGUsIHJhc3RlcnVsIG11bHRpZGltZW5zaW9uYWwgZGUgaWXImWlyZSB2YSBpbmNsdWRlIHZhcmlhYmlsZWxlIMiZaSBkaW1lbnNpdW5pbGUgZGluIHRvYXRlIGV4dGluZGVyaWxlIHNwYcibaWFsZSBmdXppb25hdGUuPGRpdj48YnI+QWNlYXN0xIMgZnVuY8ibaWUgcG9hdGUgZmkgZm9sb3NpdMSDIMiZaSBjw6JuZCBhdmXIm2kgcmFzdGVyZSBtdWx0aXBsZSBwZSBjYXJlIGRvcmnIm2kgc8SDIGxlIHRyYXRhyJtpIGNhIHBlIHVuIHNpbmd1ciBhcnRpY29sLCBjdW0gYXIgZmkgY2FsY3VsYXJlYSBhY2Vsb3JhyJtpIHN0YXRpc3RpY2kgcGVudHJ1IHRvYXRlLCBzYXUgbGEgZWNoaWxpYnJhcmVhIGN1bG9yaWksIHBlbnRydSBhIG51IGZpIG5ldm9pyJtpIHPEgyBlY2hpbGlicmHIm2kgY3Vsb2FyZWEgZmllY8SDcmVpIGltYWdpbmkgw65uIG1vZCBzZXBhcmF0LiBBY2VzdCBsdWNydSBlc3RlIHV0aWwgYXR1bmNpIGPDom5kIGx1Y3JhyJtpIGN1IGltYWdpbmkgc3RvY2F0ZSBjYSB0aWxlIHNlcGFyYXRlIGRpbiBjYXV6YSBjb25zdHLDom5nZXJpbG9yIHByaXZpbmQgZGltZW5zaXVuZWEgZmnImWllcnVsdWk7IGFzdGZlbCwgdGlsZWxlIHZvciBmaSB0cmF0YXRlIGNhIHBhcnRlIGEgYWNlbGVpYciZaSBpbWFnaW5pLlwiLFxuXHRcdGJvdW5kYXJ5Q2xlYW5OYW1lOiBcIkN1csSDyJthcmVhIEdyYW5pyJtlaVwiLFxuXHRcdGJvdW5kYXJ5Q2xlYW5TbmlwOiBcIk5ldGV6ZciZdGUgZ3JhbmnIm2EgZGludHJlIHpvbmUuXCIsXG5cdFx0Ym91bmRhcnlDbGVhbkRlc2M6IFwiPHA+RnVuY8ibaWEgZ2VuZXJhbGl6ZWF6xIMgc2F1IHNpbXBsaWZpY8SDIHJhc3RlcmVsZSBuZXRlemluZCBncmFuacibZWxlIGRpbnRyZSB6b25lLiBGdW5jyJtpYSBvZmVyxIMgb3DIm2l1bmkgcGVudHJ1IGNvbnRyb2x1bCBtb2R1bHVpIMOubiBjYXJlIGNlbHVsZWxlIHpvbmVsb3IgZGUgaW50cmFyZSBpbmZsdWVuyJtlYXrEgyBuZXRlemlyZWEgyJlpIHZhbG9hcmVhIGRlIG5ldGV6aXJlIGNhcmUgc2UgdmEgYXBsaWNhLiBGaWVjYXJlIGNlbHVsxIMgZGUgaW50cmFyZSBlc3RlIGV2YWx1YXTEgyBjdSBhanV0b3J1bCB2ZWNpbmlsb3Igc8SDaSBpbWVkaWHIm2ksIMOubiBudW3Eg3IgZGUgb3B0LjwvcD48cD5Qcm9jZXN1bCBkZSBuZXRlemlyZSBzb3J0ZWF6xIMgbWFpIMOubnTDomkgY2VsdWxlbGUgdmVjaW5lIGN1IG8gYW51bWl0xIMgcHJpb3JpdGF0ZS4gUHJpb3JpdGF0ZWEgc3RhYmlsZciZdGUgY2FyZSB6b27EgyBkaW4gY2VsdWxlbGUgw65udmVjaW5hdGUgcG9hdGUgw65ubG9jdWkgdmFsb2FyZWEgY2VsdWxlaSBkZSBwcmVsdWNyYXJlIGRpbiBpZciZaXJlLjwvcD48cD5Qcmlvcml0YXRlYSBzZSBwb2F0ZSBiYXphIGZpZSBwZSB2YWxvYXJlYSB6b25lbG9yIHNhdSBwZSBkaW1lbnNpdW5lYSB6b25lbG9yLiBQYXJhbWV0cnVsIDxzdHJvbmc+VGlwIGRlIHNvcnRhcmU8L3N0cm9uZz4gc3RhYmlsZciZdGUgdGlwdWwgZGUgc29ydGFyZSBkZSBmb2xvc2l0LiA8L3A+PHA+U2V0YXJlYSBpbXBsaWNpdMSDIDxzdHJvbmc+TnUgc29ydGE8L3N0cm9uZz4gZXZhbHVlYXrEgyBwcmlvcml0YXRlYSBwZSBiYXphIHZhbG9yaWkgem9uZWxvci4gQ2VsdWxlbGUgZGluIHpvbmVsZSBjdSB2YWxvcmkgbWFpIG1hcmkgdm9yIGF2ZWEgbyBwcmlvcml0YXRlIG1haSBtYXJlIGRlIGV4dGluZGVyZSDDrm4gem9uZSBjdSB2YWxvcmkgbWFpIG1pY2kuPC9wPjxwPkRpbWVuc2l1bmVhIHNhdSBzdXByYWZhyJthIHRvdGFsxIMgYSB6b25lbG9yIHBvYXRlIGZpIGZvbG9zaXTEgyBwZW50cnUgc29ydGFyZWEgcHJpb3JpdMSDyJtpaS4gQ3Ugc2V0YXJlYSA8c3Ryb25nPkRlc2NyZXNjxIN0b2FyZTwvc3Ryb25nPiwgem9uZWxlIHN1bnQgc29ydGF0ZSBkdXDEgyBkaW1lbnNpdW5lIMOubiBvcmRpbmUgZGVzY3Jlc2PEg3RvYXJlLiBab25lbGUgY3Ugc3VwcmFmZcibZSB0b3RhbGUgbWFpIG1hcmkgdm9yIGF2ZWEgcHJpb3JpdGF0ZWEgZGUgZXh0aW5kZXJlIMOubiB6b25lIGN1IHN1cHJhZmXIm2UgbWFpIG1pY2kuIEN1IHNldGFyZWEgPHN0cm9uZz5DcmVzY8SDdG9hcmU8L3N0cm9uZz4sIGVzdGUgdmFsYWJpbCBvcHVzdWw6IHpvbmVsZSBjdSBzdXByYWZlyJtlIHRvdGFsZSBtYWkgbWljaSB2b3IgYXZlYSBwcmlvcml0YXRlIGRlIGV4dGluZGVyZSDDrm4gem9uZSBjdSBzdXByYWZlyJtlIHRvdGFsZSBtYWkgbWFyaS48L3A+PHA+VmFsb2FyZWEgbmV0ZXppcmlpIGVzdGUgY29udHJvbGF0xIMgZGUgcGFyYW1ldHJ1bCA8c3Ryb25nPlJ1bGHIm2kgZXh0aW5kZXJlIMiZaSByZXN0csOibmdlcmUgZGUgZG91xIMgb3JpPC9zdHJvbmc+LCBjYXJlIHN0YWJpbGXImXRlIGRlIGPDonRlIG9yaSB2YSBmaSBlZmVjdHVhdCBwcm9jZXN1bCBkZSBleHRpbmRlcmUgyJlpIHJlc3Ryw6JuZ2VyZS48L3A+PHA+RGFjxIMgc2V0YXJlYSBudSBlc3RlIGJpZmF0xIMsIHByb2Nlc3VsIGRlIGV4dGluZGVyZSDImWkgcmVzdHLDom5nZXJlIHZhIGZpIGVmZWN0dWF0IG8gc2luZ3VyxIMgZGF0xIMuIERhY8SDIHNldGFyZWEgZXN0ZSBiaWZhdMSDLCBwcm9jZXN1bCBkZSBleHRpbmRlcmUgyJlpIHJlc3Ryw6JuZ2VyZSBlc3RlIGVmZWN0dWF0IGRlIGRvdcSDIG9yaSwgYXbDom5kIGNhIHJlenVsdGF0IHVuIGdyYWQgc3VwbGltZW50YXIgZGUgbmV0ZXppcmUgYSBncmFuacibZWxvciBkaW50cmUgem9uZS48L3A+PHA+RGFjxIMgdmFsb3JpbGUgdHV0dXJvciBjZWxvciBvcHQgY2VsdWxlIMOubnZlY2luYXRlIHN1bnQgYWNlbGVhyJlpIGN1IGNlbGUgYWxlIGNlbHVsZWkgZGUgcHJlbHVjcmFyZSwgY2VsdWxhIHJlenVsdGFudMSDIHZhIHJlyJtpbmUgdmFsb2FyZWEgY2VsdWxlaSBkZSBpbnRyYXJlLjwvcD5cIixcblx0XHRwcmVkaWN0VXNpbmdSZWdyZXNzaW9uTmFtZTogXCJQcmVkaWPIm2llIGN1IGFqdXRvcnVsIHJlZ3Jlc2llaVwiLFxuXHRcdHByZWRpY3RVc2luZ1JlZ3Jlc3Npb25TbmlwOiBcIkNhbGN1bGVhesSDIHVuIHJhc3RlciBhbnRpY2lwYXQgcGUgYmF6YSBpbnRyb2R1Y2VyaWxvciBkZSBkYXRlIGRlc3ByZSByYXN0ZXIgyJlpIGEgdW51aSBtb2RlbCBkZSByZWdyZXNpZS4gTW9kZWx1bCBkZSByZWdyZXNpZSBlc3RlIHJlenVsdGF0dWwgcHJvZHVzIGRlIGluc3RydW1lbnR1bCBkZSBnZW9wcm9jZXNhcmUgYSByYXN0ZXJlbG9yIDxzdHJvbmc+TW9kZWx1bCBkZSBhbnRyZW5hcmUgcHJpbiBhcmJvcmkgYWxlYXRvcmk8L3N0cm9uZz4uXCIsXG5cdFx0cHJlZGljdFVzaW5nUmVncmVzc2lvbkRlc2M6IFwiPHA+TW9kZWx1bCBkZSByZWdyZXNpZSBlc3RlIGRlZmluaXQgw65udHItdW4gZmnImWllciBkZSBkZWZpbmnIm2llIGEgcmVncmVzaWVpIEVzcmkgKC5lY2QpLiBBY2VzdGEgY29uyJtpbmUgdG9hdGUgaW5mb3JtYcibaWlsZSBwZW50cnUgdW4gc2V0IGRlIGRhdGUgc3BlY2lmaWMgc2F1IHVuIHNldCBkZSBzZXR1cmkgZGUgZGF0ZSDImWkgbW9kZWx1bCBkZSByZWdyZXNpZSDImWkgZXN0ZSBnZW5lcmF0IGRlIGluc3RydW1lbnR1bCBkZSBnZW9wcm9jZXNhcmUgYSByYXN0ZXJlbG9yIDxzdHJvbmc+TW9kZWwgZGUgYW50cmVuYXJlIGN1IGFyYm9yaSBhbGVhdG9yaTwvc3Ryb25nPiAuPC9wPjxwPkludHJvZHVjZXJlYSBwb2F0ZSBmaSB1biByYXN0ZXIgY3UgbyBzaW5ndXLEgyBiYW5kxIMsIGN1IG1haSBtdWx0ZSBiZW56aSwgdW4gcmFzdGVyIG11bHRpZGltZW5zaW9uYWwgc2F1IG8gbGlzdMSDIGEgYWNlc3RvciB0aXB1cmkuIFRpcHVyaWxlIGRlIHJhc3RlcmUgZGUgaW50cm9kdWNlcmUgdHJlYnVpZSBzxIMgZmllIGlkZW50aWNlIGN1IHRpcHVsIGRlIHJhc3RlciBhbnRyZW5hdCBkZSBtb2RlbHVsIGRlIHJlZ3Jlc2llLjwvcD48dWw+PGxpPkPDom5kIGludHJvZHVjZXJlYSBlc3RlIHVuIHJhc3RlciBjdSBtYWkgbXVsdGUgYmVuemksIGZpZWNhcmUgYmFuZMSDIGVzdGUgdHJhdGF0xIMgY2EgbyB2YXJpYWJpbMSDIGEgZWxlbWVudHVsdWkgZGUgcHJlZGljyJtpZS4gQmVuemlsZSB0cmVidWllIHPEgyBmaWUgw65uIGFjZWVhyJlpIG9yZGluZSBjYSDImWkgaW50cm9kdWNlcmVhIGN1IG1haSBtdWx0ZSBiZW56aSBwZW50cnUgaW5zdHJ1bWVudHVsIGRlIGFudHJlbmFyZSBhIG1vZGVsdWx1aSBkZSByZWdyZXNpZS48L2xpPjxsaT5Dw6JuZCBpbnRyb2R1Y2VyZWEgZXN0ZSB1biByYXN0ZXIgbXVsdGlkaW1lbnNpb25hbCwgZmllY2FyZSB2YXJpYWJpbMSDIGVzdGUgdHJhdGF0xIMgY2EgbyB2YXJpYWJpbMSDIGRlIGVsZW1lbnQgZGUgcHJlZGljyJtpZSwgaWFyIHZhcmlhYmlsYSB0cmVidWllIHPEgyBmaWUgY3UgbyBzaW5ndXLEgyBiYW5kxIMgyJlpIHPEgyBhaWLEgyBvIGRpbWVuc2l1bmUgZGUgdGltcC4gT3JkaW5lYSB2YXJpYWJpbGVsb3IgyJlpIG51bWVsb3IgdHJlYnVpZSBzxIMgZmllIGFjZWVhyJlpIGNhIMiZaSBpbnRyb2R1Y2VyZWEgY8OibmQgbW9kZWx1bCBkZSByZWdyZXNpZSBhIGZvc3QgYW50cmVuYXQuIEllyJlpcmVhIGVzdGUgdW4gcmFzdGVyIG11bHRpZGltZW5zaW9uYWwuPC9saT48bGk+SW50cm9kdWNlcmVhIHBvYXRlIGZpIG8gbGlzdMSDIGRlIGVsZW1lbnRlLiBOdW3Eg3J1bCBkZSBlbGVtZW50ZSDImWkgb3JkaW5lYSBlbGVtZW50ZWxvciB0cmVidWllIHPEgyBjb3Jlc3B1bmTEgyBjdSBpbnRyb2R1Y2VyZWEgY8OibmQgbW9kZWx1bCBkZSByZWdyZXNpZSBhIGZvc3QgYW50cmVuYXQuPC9saT48L3VsPlwiLFxuXHRcdGRpbWVuc2lvbmFsTW92aW5nU3RhdGlzdGljc05hbWU6IFwiU3RhdGlzdGljYSBkZSBtaciZY2FyZSBkaW1lbnNpb25hbMSDXCIsXG5cdFx0ZGltZW5zaW9uYWxNb3ZpbmdTdGF0aXN0aWNzU25pcDogXCJDYWxjdWxlYXrEgyBzdGF0aXN0aWNpbGUgcGUgbyBmZXJlYXN0csSDIG1vYmlsxIMgcGUgZGF0ZSBtdWx0aWRpbWVuc2lvbmFsZSBkZS1hIGx1bmd1bCB1bmVpIGRpbWVuc2l1bmkgc3BlY2lmaWNhdGUuXCIsXG5cdFx0ZGltZW5zaW9uYWxNb3ZpbmdTdGF0aXN0aWNzRGVzYzogXCI8cD5GdW5jyJtpYSBTdGF0aXN0aWNpIG1pyJljYXJlIGRpbWVuc2lvbmFsxIMgY2FsY3VsZWF6xIMgZGl2ZXJzZSBzdGF0aXN0aWNpIMOubiBjYWRydWwgdW5laSBmZXJlc3RyZSBwcmVkZWZpbml0ZSBwZW50cnUgdG9hdGUgdmFsb3JpbGUgZGltZW5zaXVuaWkgw65tcHJldW7EgyBjdSBvIGRpbWVuc2l1bmUuIEFjZWFzdMSDIGZ1bmPIm2llIGlhIHVuIHN0cmF0IHRlbWF0aWMgZGUgcmFzdGVyIG11bHRpZGltZW5zaW9uYWwgY2EgaW50cmFyZSDImWkgY3JlZWF6xIMgdW4gc3RyYXQgdGVtYXRpYyBkZSByYXN0ZXIgbXVsdGlkaW1lbnNpb25hbCBjYSBpZciZaXJlIGNhcmUgYXJlIGFjZWVhyJlpIGRpbWVuc2l1bmUgY2EgyJlpIHN0cmF0dWwgdGVtYXRpYyBkZSBpbnRyYXJlLjwvcD48cD5QdXRlyJtpIHNwZWNpZmljYSBvIGRpbWVuc2l1bmUgcGVudHJ1IGNhcmUgdmFsb3JpbGUgZGltZW5zaXVuaWkgc3VudCBsdWF0ZSDDrm4gY2FsY3VsIMOubiB0aW1wdWwgY2FsY3VsxINyaWkuIEltcGxpY2l0LCBhY2Vhc3RhIHNlIGNhbGN1bGVhesSDIMOubXByZXVuxIMgY3UgcHJpbWEgZGltZW5zaXVuZSBub24tc3BhyJtpYWzEgy4gUHV0ZcibaSwgZGUgYXNlbWVuZWEsIHPEgyBzcGVjaWZpY2HIm2kgZGltZW5zaXVuZWEgdW5laSBmZXJlc3RyZSBwcmluIHNwZWNpZmljYXJlYSBwYXJhbWV0cmlsb3IgRmVyZWFzdHLEgyDDrm5hcG9pIMiZaSBGZXJlYXN0csSDIMOubmFpbnRlLjwvcD48cD5Dw6JuZCBUaXB1bCBzdGF0aXN0aWNpaSBlc3RlIHNldGF0IGxhIFBlcmNlbnRpbMSDLCBwYXJhbWV0cmlpIFZhbG9hcmUgcGVyY2VudGlsxIMgyJlpIFRpcCBpbnRlcnBvbGFyZSBwZXJjZW50aWzEgyBkZXZpbiBkaXNwb25pYmlsLiBQdXRlyJtpIHV0aWxpemEgYWNlyJl0aSBwYXJhbWV0cmkgcGVudHJ1IGEgc3BlY2lmaWNhIHBlcmNlbnRpbGEgcGVudHJ1IGEgY2FsY3VsYSDImWkgYWxlZ2UgcmVzcGVjdGl2IHRpcHVsIGRlIGludGVycG9sYXJlIGRlIHV0aWxpemF0LiBDw6JuZCBUaXB1bCBkZSBzdGF0aXN0aWPEgyBlc3RlIHNldGF0IGxhIE1lZGllIGNpcmN1bGFyxIMsIHBhcmFtZXRydWwgVmFsb2FyZSDDrm5jYWRyYXJlIGNpcmN1bGFyxIMgZGV2aW5lIGRpc3BvbmliaWwuIFZhbG9hcmVhIGRlIMOubmNhZHJhcmUgY2lyY3VsYXLEgyBlc3RlIHV0aWxpemF0xIMgcGVudHJ1IGEgY29udmVydGkgbyB2YWxvYXJlIGxpbmlhcsSDIMOubiBpbnRlcnZhbHVsIHVuZWkgbWVkaWkgY2lyY3VsYXJlIGRhdGUuPC9wPlwiLFxuXHRcdHRlcnJhaW5GbGF0dGVuRnVuY3Rpb25OYW1lOiBcIlRlcmVuIGFwbGF0aXphdFwiLFxuXHRcdHRlcnJhaW5GbGF0dGVuRnVuY3Rpb25TbmlwOiBcIkNvcmVjdGVhesSDIGRhdGVsZSBkZSBpbnRyYXJlIGFsZSByYWRhcnVsdWkgY3UgZGVzY2hpZGVyZSBzaW50ZXRpY8SDIChTQVIpIHBlbnRydSBkaXN0b3JzaXVuaSByYWRpb21ldHJpY2UgZGF0b3JhdGUgdG9wb2dyYWZpZWkuXCIsXG5cdFx0dGVycmFpbkZsYXR0ZW5GdW5jdGlvbkRlc2M6IFwiPHA+RnVuY8ibaWEgXFxcIlRlcnJhaW4gRmxhdHRlbiByYXN0ZXJcXFwiIGNvcmVjdGVhesSDIGRhdGVsZSBkZSBpbnRyYXJlIGFsZSByYWRhcnVsdWkgY3UgZGVzY2hpZGVyZSBzaW50ZXRpY8SDIChTQVIpIHBlbnRydSBkaXN0b3JzaXVuaSByYWRpb21ldHJpY2UgZGF0b3JhdGUgdG9wb2dyYWZpZWkuPC9wPjxwPkRhdGVsZSByYWRhciBkZSBpbnRyYXJlIHRyZWJ1aWUgbWFpIMOubnTDomkgc8SDIGZpZSBjYWxpYnJhdGUgbGEgemVybyBiZXRhLiBVdGlsaXphyJtpIGluc3RydW1lbnR1bCBcXFwiQXBwbHkgUmFkaW9tZXRyaWMgQ2FsaWJyYXRpb25cXFwiIHBlbnRydSBhIGNhbGlicmEgZGF0ZWxlIHJhZGFyIGxhIGJldGEgemVyby48L3A+PHA+RGFjxIMgREVNLXVsIGRlIGludHJhcmUgbnUgYWNvcGVyxIMgw65udHJlZ3VsIHNldCBkZSBkYXRlIFNBUiwgaW5zdHJ1bWVudHVsIHZhIGVtaXRlIHZhbG9yaSBOb0RhdGEgcGVudHJ1IHBpeGVsaWkgZGluIGFmYXJhIGV4dGVuc2llaSBERU0gcGVudHJ1IGdhbW1hIG5vdWdodCwgc2lnbWEgbm91Z2h0LCB6b25hIGRlIMOubXByxIPImXRpZXJlIMiZaSBkaXN0b3JzaXVuaWxlIGdlb21ldHJpY2UuIFBlbnRydSBpZciZaXJlYSBtxIPImXRpaSBkZSBkaXN0b3JzaXVuZSBnZW9tZXRyaWPEgywgaW5zdHJ1bWVudHVsIHZhIGVtaXRlIHZhbG9yaSBuZWRldGVybWluYXRlIHBlbnRydSBwaXhlbGlpIGRpbiBhZmFyYSBleHRlbnNpZWkgREVNLjwvcD48cD5ERU0tdWwgZGUgaW50cmFyZSB0cmVidWllIHPEgyBmaWUgw65uIHNpc3RlbXVsIGRlIGNvb3Jkb25hdGUgZ2VvZ3JhZmljZSBXR1MgMTk4NCAoRVBTRzo0MzI2KS48L3A+XCIsXG5cdFx0Y3JlYXRlQ29sb3JDb21wb3NpdGVGdW5jdGlvbk5hbWU6IFwiQ3JlYcibaSBjb21wb3ppdCBjdWxvYXJlXCIsXG5cdFx0Y3JlYXRlQ29sb3JDb21wb3NpdGVGdW5jdGlvblNuaXA6IFwiQ3JlZWF6xIMgdW4gcmFzdGVyIGN1IHRyZWkgYmVuemkgZGludHItdW4gc2V0IGRlIGRhdGUgcmFzdGVyIGN1IG1haSBtdWx0ZSBiZW56aSwgw65uIGNhcmUgZmllY2FyZSBiYW5kxIMgcG9hdGUgdXRpbGl6YSB1biBjYWxjdWwgYWxnZWJyaWMgYmF6YXQgcGUgYWxnZWJyYSBiZW56aWxvci5cIixcblx0XHRjcmVhdGVDb2xvckNvbXBvc2l0ZUZ1bmN0aW9uRGVzYzogXCI8cD5GdW5jyJtpYSBkZSBjcmVhcmUgYSByYXN0ZXJ1bHVpIGNvbXBveml0IGRlIGN1bG9hcmUgY3JlZWF6xIMgdW4gcmFzdGVyIGN1IHRyZWkgYmVuemkgZGludHItdW4gc2V0IGRlIGRhdGUgcmFzdGVyIGN1IG1haSBtdWx0ZSBiZW56aSwgw65uIGNhcmUgZmllY2FyZSBiYW5kxIMgcG9hdGUgdXRpbGl6YSB1biBjYWxjdWwgYWxnZWJyaWMgYmF6YXQgcGUgYWxnZWJyYSBiZW56aWxvci48L3A+PHA+QXR1bmNpIGPDom5kIGRlZmluacibaSB1biBhbGdvcml0bSBhcml0bWV0aWMgZGUgYmFuZMSDLCBwdXRlyJtpIGludHJvZHVjZSBvIGZvcm11bMSDIGFsZ2VicmljxIMgcGUgbyBzaW5ndXLEgyBsaW5pZSBwZW50cnUgZmllY2FyZSBleHByZXNpZSBwZW50cnUgYSBjcmVhIG8gaWXImWlyZSBtdWx0aWJhbmTEgy4gT3BlcmF0b3JpaSBzdXBvcnRhyJtpIHN1bnQgdW5hcmksIHBsdXMgKCspLCBtaW51cyAoLSksIG9yaSAoKikgyJlpIGRpdmlkZSAoLykuPC9wPjxwPkF0dW5jaSBjw6JuZCBmb2xvc2nIm2kgdW4gSUQgZGUgYmFuZMSDIMOubnRyLW8gZXhwcmVzaWUsIGlkZW50aWZpY2HIm2kgYmFuZGEgcHJpbiBwcmVmaXhhcmVhIEIgc2F1IGIgbGEgbnVtxINydWwgYmVuemlpLjwvcD48cD5PIGNvbWJpbmHIm2llIG9iaciZbnVpdMSDIGRlIGJlbnppIHV0aWxpemF0xIMgcGVudHJ1IHJhZGFydWwgY3UgZGVzY2hpZGVyZSBzaW50ZXRpY8SDIChTQVIpIMOubiB1bml0xIPIm2kgbGluaWFyZSBlc3RlIFZWIHBlbnRydSByb8iZdSwgVkggcGVudHJ1IHZlcmRlIMiZaSBWVi9WSCBwZW50cnUgYWxiYXN0cnUuIMOObiBjYXp1bCDDrm4gY2FyZSBkYXRlbGUgZGUgaW50cmFyZSBzdW50IMOubiBkZWNpYmVsaSwgY29tYmluYcibaWEgZGUgYmVuemkgdHJlYnVpZSBzxIMgZmllIFZWIHBlbnRydSByb8iZdSwgVkggcGVudHJ1IHZlcmRlIMiZaSBWVi1WSCBwZW50cnUgYWxiYXN0cnUuPC9wPlwiLFxuXHRcdHN1cmZhY2VQYXJhbWV0ZXJzTmFtZTogXCJQYXJhbWV0cmkgc3VwcmFmZcibZWlcIixcblx0XHRzdXJmYWNlUGFyYW1ldGVyc1NuaXA6IFwiRGV0ZXJtaW7EgyBwYXJhbWV0cmlpIHVudWkgcmFzdGVyIGRlIHN1cHJhZmHIm8SDIGN1bSBhciBmaSBhc3BlY3R1bCwgcGFudGEgyJlpIG1haSBtdWx0ZSB0aXB1cmkgZGUgY3VyYnVyaSBmb2xvc2luZCBtZXRvZGUgZ2VvZGV6aWNlLlwiLFxuXHRcdHN1cmZhY2VQYXJhbWV0ZXJzRGVzYzogXCI8cD5QYXJhbWV0cmlpIGRlIHN1cHJhZmHIm8SDIGRldGVybWluxIMgcGFyYW1ldHJpaSB1bnVpIHJhc3RlciBkZSBzdXByYWZhyJvEgyBjdW0gYXIgZmkgYXNwZWN0dWwsIHBhbnRhIMiZaSBtYWkgbXVsdGUgdGlwdXJpIGRlIGN1cmJ1cmkgZm9sb3NpbmQgbWV0b2RlIGdlb2RlemljZS48L3A+PHA+QWNlYXN0xIMgZnVuY8ibaWUgcG9hdGUgZmkgdXRpbGl6YXTEgyBwZW50cnUgdXJtxIN0b2FyZWxlIGFwbGljYcibaWk6PC9wPjx1bD48bGk+Q2FsY3VsYXJlYSBhc3BlY3R1bHVpIMiZaSBhIHBhbnRlaSBmb2xvc2luZCBtZXRvZGUgZ2VvZGV6aWNlLjwvbGk+PGxpPkNhbGN1bGFyZWEgZGlmZXJpdGVsb3IgdGlwdXJpIGRlIGN1cmJ1cmkgZGludHItdW4gcmFzdGVyIGRlIHN1cHJhZmHIm8SDLCBkZSBleGVtcGx1LCA8c3Ryb25nPkN1cmJhIHRhbmdlbnTEgyAoY29udHVyIG5vcm1hbCk8L3N0cm9uZz4gY2FyZSBjYXJhY3Rlcml6ZWF6xIMgY29udmVyZ2VuyJthIGdlb2dyYWZpY8SDIMiZaSBkaXZlcmdlbsibYSBmbHV4dWx1aSBwZXN0ZSBzdXByYWZhyJvEgy48L2xpPjwvdWw+XCIsXG5cdFx0bGVhc3RDb3N0Q29ycmlkb3JOYW1lOiBcIkNvcmlkb3J1bCBjdSBjZWwgbWFpIG1pYyBjb3N0XCIsXG5cdFx0bGVhc3RDb3N0Q29ycmlkb3JTbmlwOiBcIkNhbGN1bGVhesSDIHN1bWEgYSBkb3XEgyByYXN0ZXJlIGRlIGRpc3RhbsibxIMgY3UgY29zdHVyaSBjdW11bGF0aXZlIGN1IG9wyJtpdW5lYSBkZSBhIGFwbGljYSB1biBwcmFnIHBlIGJhemEgcHJvY2VudHVsdWkgc2F1IGEgY29zdHVsdWkgY3VtdWxhdGl2LlwiLFxuXHRcdGxlYXN0Q29zdENvcnJpZG9yRGVzYzogXCI8cD5SYXN0ZXJlbGUgZGUgaW50cmFyZSB0cmVidWllIHPEgyBmaWUgcmFzdGVyZSBkZSBhY3VtdWxhcmUgYSBkaXN0YW7Im2VpLCDImWkgcmV6dWx0YXRlIGRlIHJhc3RlcmUgZGUgZGlyZWPIm2llIMOubmFwb2kgZGluIGZ1bmPIm2lhIDxzdHJvbmc+QWN1bXVsYXJlIGRpc3RhbsibxIM8L3N0cm9uZz4gc2F1IDxzdHJvbmc+QWxvY2FyZSBkaXN0YW7Im8SDPC9zdHJvbmc+LiBBciB0cmVidWkgc8SDIHNlIGJhemV6ZSBkaXN0YW7Im2EgZGUgY29zdCDImWkgYWNlbGVhyJlpIHNldMSDcmkgZGUgcGFyYW1ldHJpIGFyIHRyZWJ1aSBzxIMgZmllIHV0aWxpemF0ZSBsYSBjcmVhcmVhIHN0cmF0dXJpbG9yIHRlbWF0aWNlIHBlbnRydSBmaWVjYXJlIHN1cnPEgy4gTnUgYXIgdHJlYnVpIHPEgyBzZSB1dGlsaXplemUgcGFyYW1ldHJpIGNhcmUgZGVwaW5kIGRlIGRpcmVjyJtpb25hbGl0YXRlIChmYWN0b3Igb3Jpem9udGFsLCBmYWN0b3IgdmVydGljYWwgyJlpIGRpcmVjyJtpZSBkZSBkZXBsYXNhcmUpIMOubiBjcmVhcmVhIGFjZXN0b3IgcmFzdGVyZS48L3A+PHA+VmFsb3JpbGUgZGluIHJhc3RlcnVsIGNvcmlkb3J1bHVpIGRlIGllyJlpcmUgc3VudCBzdW1hIGNvc3R1bHVpIGFjdW11bGF0IHBlbnRydSBhIGFqdW5nZSDDrm50ci1vIGxvY2HIm2llIGRhdMSDIGN1IGFjZWxlYciZaSB1bml0xIPIm2kgY2EgcmFzdGVyZSBkZSBkaXN0YW7Im8SDIGRlIGNvc3QgYWN1bXVsYXQuPC9wPjxwPkRhY8SDIG8gdmFsb2FyZSA8c3Ryb25nPlByYWc8L3N0cm9uZz4gZXN0ZSBtYWkgbWFyZSBkZWPDonQgY29zdHVsIGFjdW11bGF0IG1heGltIGPDom5kIHNlIMOubnN1bWVhesSDIGRvdcSDIHJhc3RlcmUgZGUgYWN1bXVsYXJlIGRlIGRpc3RhbsibxIMsIHJhc3RlcnVsIGNvcmlkb3IgZGUgaWXImWlyZSB2YSBhY29wZXJpIGFjZWVhyJlpIHN1cHJhZmHIm8SDIGNhIMiZaSByYXN0ZXJlbGUgYWN1bXVsYXRlIGRlIGludHJhcmUuPC9wPjxwPkRhY8SDIG8gdmFsb2FyZSBwcmFnIHNwZWNpZmljYXTEgyBlc3RlIG1haSBtaWPEgyBkZWPDonQgdmFsb2FyZWEgbWluaW3EgyBkaW4gcmFzdGVydWwgY29yaWRvciwgZXN0ZSByZXR1cm5hdCB1biBtZXNhaiBkZSBhdmVydGl6YXJlIMiZaSByYXN0ZXJ1bCBkZSBpZciZaXJlIHZhIGZpIGdvbC48L3A+PHA+UmFzdGVydWwgY29yaWRvciBkZSBpZciZaXJlIHBvYXRlIGNvbsibaW5lIGNlbHVsZSBjdSBjb3N0dXJpIGFjdW11bGF0ZSB1yJlvciBtYWkgbWFyaSBkZWPDonQgdmFsb2FyZWEgcHJhZy4gQWNlc3QgbHVjcnUgZXN0ZSBwcm92b2NhdCBkZSByYXN0ZXJlbGUgZGUgZGlyZWPIm2llIMOubmFwb2kgY2FyZSB1dGlsaXplYXrEgyBjZWx1bGUgYXRyaWJ1aXRlIGN1IGNvc3R1cmkgdciZb3IgbWFpIHJpZGljYXRlIGRlY8OidCBwcmFndWwgcGVudHJ1IGEgY29uZWN0YSBjZWx1bGVsZSBkZWNvbmVjdGF0ZSBsYSBjb3JpZG9yLjwvcD5cIixcblx0XHRnZW9tZXRyaWNNZWRpYW5OYW1lOiBcIk1lZGlhbmEgZ2VvbWV0cmljxINcIixcblx0XHRnZW9tZXRyaWNNZWRpYW5TbmlwOiBcIkZ1bmPIm2lhIGRlIG1lZGllIGdlb21ldHJpY8SDIHNlIGNhbGN1bGVhesSDIGNhIG1lZGlhIGdlb21ldHJpY8SDIMOubnRyZSBwaXhlbGkgw65udHItbyBzZXJpZSBkZSB0aW1wIGQgaW1hZ2lzdGljxIMgbXVsdGliYW5kxIMuXCIsXG5cdFx0Z2VvbWV0cmljTWVkaWFuRGVzYzogXCI8cD5BY2Vhc3TEgyBmdW5jyJtpZSByZWR1Y2UgemdvbW90dWwgyJlpIHZhbG9yaWxlIGV4Y2VwyJtpb25hbGUgw65uIGltYWdpc3RpY2Egc2VyaWVpIGRlIHRpbXAgY2FsY3Vsw6JuZCB1biBwaXhlbCBtZWRpdSBnZW9tZXRyaWMgcGVudHJ1IGZpZWNhcmUgc2VyaWUgZGUgcGl4ZWxpIGRpbiBzdGl2YSBkZSBpbWFnaW5pLiBBbGdvcml0bXVsIG1lbsibaW5lIHJlbGHIm2lpbGUgc3BlY3RyYWxlIGRpbnRyZSBiZW56aSDDrm4gc3BlY3RydWwgZGUgcGl4ZWxpLCBwZW50cnUgY2EgcmV6dWx0YXR1bCBzxIMgcG9hdMSDIGZpIHV0aWxpemF0IMOubiBhbmFsaXrEgywgY3VtIGFyIGZpIGluZGljaWkgZGUgdmVnZXRhyJtpZS48L3A+PHA+Tm9yaWkgyJlpIHVtYnJlbGUgdHJlYnVpZSBzxIMgZmllIG1hc2NhdGUgZm9sb3NpbmQgQmFuZGEgUUEgYSBzZXR1bHVpIGRlIGRhdGUgw65uYWludGUgZGUgYSBhcGxpY2EgYWNlYXN0xIMgZnVuY8ibaWUuPC9wPjxwPkRhY8SDIGltYWdpbmVhIGRlIGludHJhcmUgZXN0ZSBwdW5jdHVsIGZsb3RhbnQsIGN1bSBhciBmaSBvIHN1cHJhZmHIm8SDIHJlZmxlY3Rvcml6YW50xIMgY3UgdmFsb3JpIMOubnRyZSAwIMiZaSAxLCBvIHZhbG9hcmUgZXBzaWxvbiBkZSAwLDAwMSBwcm9kdWNlIHJlenVsdGF0ZSBkZSBjYWxpdGF0ZS48L3A+XCJcblx0fSxcblx0cmZ4QXJnczoge1xuXHRcdHJhc3Rlck5hbWU6IFwiUmFzdGVyXCIsXG5cdFx0Y29sb3JTY2hlbWVUeXBlTmFtZTogXCJUaXAgc2NoZW3EgyBkZSBjdWxvcmlcIixcblx0XHRjb2xvcm1hcE5hbWU6IFwiQ3Vsb2FyZSBoYXJ0xINcIixcblx0XHRjb2xvcm1hcE5hbWVOYW1lOiBcIk51bWUgY3Vsb2FyZSBoYXJ0xINcIixcblx0XHRjb2xvclJhbXBOYW1lOiBcIlJhbXDEgyBkZSBjdWxvYXJlXCIsXG5cdFx0Y29udHJhc3RPZmZzZXROYW1lOiBcIk9mZnNldCBjb250cmFzdFwiLFxuXHRcdGJyaWdodG5lc3NPZmZzZXROYW1lOiBcIk9mZnNldCBsdW1pbm96aXRhdGVcIixcblx0XHRtZXRob2ROYW1lOiBcIk1ldG9kxINcIixcblx0XHRiYW5kTmFtZXNOYW1lOiBcIk51bWUgYmFuZMSDXCIsXG5cdFx0YmFuZFdhdmVsZW5ndGhzTmFtZTogXCJMdW5naW1pIGRlIHVuZMSDIGRlIGJhbmTEg1wiLFxuXHRcdGJhbmRJZHNOYW1lOiBcIklELXVyaSBiYW5kxINcIixcblx0XHRtaXNzaW5nQmFuZEFjdGlvbk5hbWU6IFwiTGlwc8SDIGFjyJtpdW5lIGJhbmTEg1wiLFxuXHRcdGNvbnZlcnNpb25QYXJhbWV0ZXJzTmFtZTogXCJQYXJhbWV0cmlpIGNvbnZlcnNpZVwiLFxuXHRcdGhpbGxzaGFkZVR5cGVOYW1lOiBcIlRpcCBoaWxsc2hhZGVcIixcblx0XHRhemltdXRoTmFtZTogXCJBemltdXRcIixcblx0XHRhbHRpdHVkZU5hbWU6IFwiQWx0aXR1ZGluZVwiLFxuXHRcdHNsb3BlVHlwZU5hbWU6IFwiU2Ugc2NhbGVhesSDXCIsXG5cdFx0ekZhY3Rvck5hbWU6IFwiRmFjdG9yIFpcIixcblx0XHRQU1Bvd2VyTmFtZTogXCJUcmFuc21pc2llIGRpbWVuc2l1bmUgcGl4ZWxcIixcblx0XHRQU1pGYWN0b3JOYW1lOiBcIkZhY3RvciBkaW1lbnNpdW5lIHBpeGVsXCIsXG5cdFx0cmVtb3ZlRWRnZUVmZmVjdE5hbWU6IFwiRGV6YWN0aXZhcmUgaW50ZXJwb2xhcmUgcGl4ZWxpIG11Y2hpZVwiLFxuXHRcdGZyb21Vbml0TmFtZTogXCJEZSBsYSB1bml0YXRlYVwiLFxuXHRcdHRvVW5pdE5hbWU6IFwiTGEgdW5pdGF0ZWFcIixcblx0XHRyYXN0ZXJUeXBlTmFtZTogXCJUaXBcIixcblx0XHRtaW5OYW1lOiBcIk1pbmltdW0gaWXImWlyZVwiLFxuXHRcdG1heE5hbWU6IFwiTWF4aW11bSBpZciZaXJlXCIsXG5cdFx0bWluUGVyY2VudE5hbWU6IFwiTWluaW11bSBmaXhhcmUgcHJvY2VudFwiLFxuXHRcdG1heFBlcmNlbnROYW1lOiBcIk1heGltdW0gZml4YXJlIHByb2NlbnRcIixcblx0XHRudW1iZXJPZlN0YW5kYXJkRGV2aWF0aW9uTmFtZTogXCJOdW3Eg3IgZGUgZGV2aWHIm2lpIHN0YW5kYXJkXCIsXG5cdFx0c2lnbW9pZFN0cmVuZ3RoTGV2ZWxOYW1lOiBcIk5pdmVsIHB1dGVyZSBzaWdtb2lkXCIsXG5cdFx0ZXN0aW1hdGVTdGF0c0hpc3RvZ3JhbU5hbWU6IFwiRXN0aW1hcmUgc3RhdGlzdGljaVwiLFxuXHRcdERSQU5hbWU6IFwiQWp1c3RhcmUgZGUgZG9tZW5pdSBkaW5hbWljXCIsXG5cdFx0c3RhdGlzdGljc05hbWU6IFwiU3RhdGlzdGljxINcIixcblx0XHRoaXN0b2dyYW1zTmFtZTogXCJIaXN0b2dyYW1lXCIsXG5cdFx0c3RhdGlzdGljc0hpc3RvZ3JhbU5hbWU6IFwiRGVmaW5pyJtpIHN0YXRpc3RpY2kgyJlpIGhpc3RvZ3JhbcSDXCIsXG5cdFx0Y29tcHV0ZUdhbW1hTmFtZTogXCJBdXRvIEdhbW1hXCIsXG5cdFx0dXNlR2FtbWFOYW1lOiBcIkZvbG9zaXJlIEdhbW1hXCIsXG5cdFx0Z2FtbWFOYW1lOiBcIkdhbW1hXCIsXG5cdFx0aW5wdXROYW1lc05hbWU6IFwiTnVtZVwiLFxuXHRcdGV4cHJlc3Npb25OYW1lOiBcIkV4cHJlc2llXCIsXG5cdFx0Y2VsbHNpemVUeXBlTmFtZTogXCJUaXAgZGltZW5zaXVuZSBjZWx1bMSDXCIsXG5cdFx0ZXh0ZW50VHlwZU5hbWU6IFwiVGlwIGxpbWl0xINcIixcblx0XHRjbGFzc2lmaWVyRGVmaW5pdGlvbkZpbGVOYW1lOiBcIkludHJvZHVjZXJlIGRlZmluacWjaWUgZmnFn2llclwiLFxuXHRcdHJhc3RlcjFOYW1lOiBcIlJhc3RlcjFcIixcblx0XHRyYXN0ZXIyTmFtZTogXCJSYXN0ZXIyXCIsXG5cdFx0cmFzdGVyM05hbWU6IFwiUmFzdGVyM1wiLFxuXHRcdHRydWVSYXN0ZXJOYW1lOiBcIlJhc3RlciByZWFsXCIsXG5cdFx0ZmFsc2VSYXN0ZXJOYW1lOiBcIlJhc3RlciBmYWxzXCIsXG5cdFx0bm9EYXRhSW50ZXJwcmV0YXRpb25OYW1lOiBcIkludGVycG9sYXJlIGbEg3LEgyBkYXRlXCIsXG5cdFx0bm9EYXRhVmFsdWVzTmFtZTogXCJWYWxvcmkgZsSDcsSDIGRhdGVcIixcblx0XHRpbmNsdWRlZFJhbmdlc05hbWU6IFwiSW50ZXJ2YWxlIGluY2x1c2VcIixcblx0XHRjdXJ2YXR1cmVUeXBlTmFtZTogXCJUaXAgY3VyYnVyxINcIixcblx0XHRyYXN0ZXJzTmFtZTogXCJSYXN0ZXJlXCIsXG5cdFx0YXR0cmlidXRlVGFibGVOYW1lOiBcIlRhYmVsXCIsXG5cdFx0YXR0cmlidXRlVGFibGVUeXBlTmFtZTogXCJUaXAgdGFiZWxcIixcblx0XHRyb3dzTmFtZTogXCJOdW3Eg3IgZGUgcsOibmR1cmlcIixcblx0XHRjb2x1bW5zTmFtZTogXCJOdW3Eg3IgZGUgY29sb2FuZVwiLFxuXHRcdGtlcm5lbE5hbWU6IFwiS2VybmVsXCIsXG5cdFx0bWlycm9yRWRnZXNOYW1lOiBcIk11Y2hpaSDDrm4gb2dsaW5kxINcIixcblx0XHRpbmZsdWVuY2VzTmFtZTogXCJJbmZsdWVuxaNlXCIsXG5cdFx0ZmllbGRzTmFtZTogXCJDw6JtcHVyaVwiLFxuXHRcdHJlbWFwc05hbWU6IFwiUmVjYXJ0b2dyYWZpZXJlIHRhYmVsXCIsXG5cdFx0ZXZhbEZyb21OYW1lOiBcIlNjYXLEgyBkZSBldmFsdWFyZSBkZSBsYVwiLFxuXHRcdGV2YWxUb05hbWU6IFwiU2NhcsSDIGRlIGV2YWx1YXJlIHDDom7EgyBsYVwiLFxuXHRcdHdlaWdodHNOYW1lOiBcIkdyZXV0xIPFo2lcIixcblx0XHRERU1OYW1lOiBcIkRFTVwiLFxuXHRcdHNob3J0UmFuZ2VJRFdSYWRpdXNOYW1lOiBcIkludGVydmFsIHNjdXJ0IHJhemEgSURXXCIsXG5cdFx0bWF4Vm9pZFdpZHRoTmFtZTogXCJMxIPIm2ltZSBtYXhpbcSDIHZpZFwiLFxuXHRcdHNpZ21hR2F1c3NpYW5OYW1lOiBcIkxpbmlhcml6YXJlIGFkYXB0aXbEg1wiLFxuXHRcdGNvbnRvdXJUeXBlTmFtZTogXCJUaXAgY29udHVyXCIsXG5cdFx0ekJhc2VOYW1lOiBcIkJhesSDIFpcIixcblx0XHRudW1iZXJPZkNvbnRvdXJzTmFtZTogXCJOdW3Eg3IgZGUgY29udHVydXJpXCIsXG5cdFx0Y29udG91ckludGVydmFsTmFtZTogXCJJbnRlcnZhbCBjb250dXJcIixcblx0XHRudGhDb250b3VyTGluZUluQm9sZE5hbWU6IFwiQSBuLWEgbGluaWUgYSBjb250dXJ1bHVpIGVzdGUgw65uZ3JvxZ9hdMSDXCIsXG5cdFx0ZmVhdHVyZUNsYXNzTmFtZTogXCJPYmllY3RlIHNwYcibaWFsZSBkZSBpbnRyYXJlXCIsXG5cdFx0Y2xhc3NJbmRleEZpZWxkTmFtZTogXCJGaWVsZFwiLFxuXHRcdHJlc29sdmVPdmVybGFwTWV0aG9kTmFtZTogXCJSZXpvbHZhcmUgbWV0b2TEgyBkZSBzdXByYXB1bmVyZVwiLFxuXHRcdHJlc2FtcGxpbmdUeXBlTmFtZTogXCJUaXAgcmVlyJlhbnRpb25hcmVcIixcblx0XHRpbnB1dENlbGxzaXplTmFtZTogXCJEaW1lbnNpdW5lIGNlbHVsxIMgaW50cmFyZVwiLFxuXHRcdG91dHB1dENlbGxzaXplTmFtZTogXCJEaW1lbnNpdW5lIGNlbHVsxIMgaWXImWlyZVwiLFxuXHRcdHBvaW50RmVhdHVyZUNsYXNzTmFtZTogXCJQdW5jdGUgZGUgc2VtaW7Im2VcIixcblx0XHRtYXhHcm93dGhSYWRpdXNGaWVsZE5hbWU6IFwiQ8OibXAgY3UgcmF6xIMgbWF4aW3EgyBkZSBjcmXFn3RlcmVcIixcblx0XHRzaW1pbGFyaXR5VGhyZXNob2xkRmllbGROYW1lOiBcIkPDom1wIHByYWcgZGUgc2ltaWxhcml0YXRlXCIsXG5cdFx0ZmlsbFZhbHVlRmllbGROYW1lOiBcIkNvbXBsZXRhxaNpIHZhbG9hcmUgY8OibXBcIixcblx0XHRzcGVjdHJhbERldGFpbE5hbWU6IFwiRGV0YWxpdSBzcGVjdHJhbCBbMS4uMjBdXCIsXG5cdFx0c3BhdGlhbERldGFpbE5hbWU6IFwiRGV0YWxpdSBzcGHIm2lhbCBbMS4uMjBdXCIsXG5cdFx0bWluTnVtUGl4ZWxzUGVyU2VnbWVudE5hbWU6IFwiRGltZW5zaXVuZWEgbWluaW3EgyBzZWdtZW50IMOubiBwaXhlbGlcIixcblx0XHRib3VuZGFyaWVzT25seU5hbWU6IFwiTnVtYWkgbGltaXRlbGUgc2VnbWVudHVsdWlcIixcblx0XHRzdGF0aXN0aWNzVHlwZU5hbWU6IFwiVGlwIHN0YXRpc3RpY2lcIixcblx0XHRmaWxsTm9EYXRhT25seU5hbWU6IFwiQ29tcGxldGHIm2kgbnVtYWkgcGl4ZWxpaSBOb0RhdGFcIixcblx0XHRpbnB1dERhdGFUeXBlTmFtZTogXCJUaXAgZGF0ZSBkZSBpbnRyYXJlXCIsXG5cdFx0YW5nbGVSZWZlcmVuY2VTeXN0ZW1OYW1lOiBcIlNpc3RlbSByZWZlcmluxaPEgyB1bmdoaVwiLFxuXHRcdG91dHB1dERhdGFUeXBlTmFtZTogXCJUaXAgZGF0ZSBkZSBpZcWfaXJlXCIsXG5cdFx0aW5wdXRTYW1wbGVQb2ludEZlYXR1cmVDbGFzc05hbWU6IFwiRcWfYW50aW9hbmUgZGUgaW50cmFyZVwiLFxuXHRcdHZhbHVlRmllbGROYW1lOiBcIkPDom1wIHZhbG9hcmVcIixcblx0XHRyYXN0ZXJJbmZvTmFtZTogXCJJbmZvIFJhc3RlclwiLFxuXHRcdGludGVycG9sYXRpb25NZXRob2ROYW1lOiBcIk1ldG9kxIMgZGUgaW50ZXJwb2xhcmVcIixcblx0XHRyYWRpdXNOYW1lOiBcIlJhesSDXCIsXG5cdFx0cmFkaWFuY2VHYWluVmFsdWVzTmFtZTogXCJBbXBsaWZpY2FyZSByYWRpYW7Im8SDXCIsXG5cdFx0cmFkaWFuY2VCaWFzVmFsdWVzTmFtZTogXCJQb2xhcml6YXJlIHJhZGlhbsibxINcIixcblx0XHRyZWZsZWN0ZWRHYWluVmFsdWVzTmFtZTogXCJBbXBsaWZpY2FyZSByZWZsZWN0YXJlXCIsXG5cdFx0cmVmbGVjdGVkQmlhc1ZhbHVlc05hbWU6IFwiUG9sYXJpemFyZSByZWZsZWN0YXJlXCIsXG5cdFx0c3VuRWxldmF0aW9uTmFtZTogXCJFbGV2YcibaWUgc29hcmUgKGdyYWRlKVwiLFxuXHRcdGFsYmVkb05hbWU6IFwiQ29lZmljaWVudCBkZSByZWZsZXhpZVwiLFxuXHRcdHNjYWxlRmFjdG9yTmFtZTogXCJGYWN0b3Igc2NhcsSDXCIsXG5cdFx0b2Zmc2V0TmFtZTogXCJEZWNhbGFyZVwiLFxuXHRcdHRocmVzaG9sZFR5cGVOYW1lOiBcIlRpcCBwcmFnXCIsXG5cdFx0dGhyZXNob2xkc05hbWU6IFwiUHJhZ3VyaVwiLFxuXHRcdHVuZGVmaW5lZENsYXNzTmFtZTogXCJDbGFzYSBuZWRlZmluaXTEg1wiLFxuXHRcdG1pblZhbHVlTmFtZTogXCJNaW5cIixcblx0XHRtYXhWYWx1ZU5hbWU6IFwiTWF4XCIsXG5cdFx0b3BlcmF0aW9uTmFtZTogXCJPcGVyYcibaWVcIixcblx0XHRjbGlwcGluZ1R5cGVOYW1lOiBcIlRpcCBkZWN1cGFyZVwiLFxuXHRcdGNsaXBwaW5nR2VvbWV0cnlOYW1lOiBcIkdlb21ldHJpZS9yYXN0ZXIgZGUgY29waWVyZVwiLFxuXHRcdGV4dGVudE5hbWU6IFwiRXh0aW5kZXJlIGllyJlpcmVcIixcblx0XHR1c2VJbnB1dEZlYXR1cmVHZW9tZXRyeU5hbWU6IFwiRm9sb3NpyJtpIG9iaWVjdGVsZSBzcGHIm2lhbGUgZGUgaW50cmFyZSBwZW50cnUgZ2VvbWV0cmlhIGRlIGRlY3VwYXJlXCIsXG5cdFx0cmVtYXBEZWZpbml0aW9uVHlwZU5hbWU6IFwiUmVjYXJ0b2dyYWZpZXJlIHRpcCBkZWZpbmnIm2llXCIsXG5cdFx0aW5wdXRSYW5nZU5hbWU6IFwiSW50ZXJ2YWxlIGRlIGludHJhcmVcIixcblx0XHRvdXRwdXRWYWx1ZXNOYW1lOiBcIlZhbG9yaSBkZSBpZciZaXJlXCIsXG5cdFx0bm9EYXRhUmFuZ2VOYW1lOiBcIkludGVydmFsZSBmxINyxIMgZGF0ZVwiLFxuXHRcdGlucHV0RmllbGROYW1lOiBcIkPDom1wIGRlIGludHJhcmVcIixcblx0XHRvdXRwdXRGaWVsZE5hbWU6IFwiQ8OibXAgZGUgaWXImWlyZVwiLFxuXHRcdGlucHV0TWF4RmllbGROYW1lOiBcIkPDom1wIG1heGltIGRlIGludHJhcmUgKG9wyJtpb25hbClcIixcblx0XHRyZW1hcFRhYmxlVHlwZU5hbWU6IFwiUmVjYXJ0b2dyYWZpZXJlIHRpcCB0YWJlbFwiLFxuXHRcdGFsbG93VW5tYXRjaGVkTmFtZTogXCJQZXJtaXRlyJtpIHZhbG9yaSBuZWNvcmVsYXRlIGFsZSBwaXhlbGlsb3JcIixcblx0XHRjaGFuZ2VNaXNzaW5nVmFsdWVzVG9Ob0RhdGFOYW1lOiBcIk1vZGlmaWNhyJtpIHZhbG9yaWxlIGxpcHPEgyDDrm4gZsSDcsSDIGRhdGVcIixcblx0XHR2aXNpYmxlQmFuZElETmFtZTogXCJJRCB2aXppYmlsIGJhbmTEg1wiLFxuXHRcdGluZnJhcmVkQmFuZElETmFtZTogXCJJRCBpbmZyYXJvyJl1IGJhbmTEg1wiLFxuXHRcdHNjaWVudGlmaWNPdXRwdXROYW1lOiBcIkllyJlpcmUgyJl0aWluyJtpZmljxINcIixcblx0XHRiYW5kSW5kZXhlc05hbWU6IFwiSW5kZXh1cmkgYmFuZMSDXCIsXG5cdFx0Y29uc3RhbnROYW1lOiBcIkNvbnN0YW50xINcIixcblx0XHR3ZWlnaHROYW1lOiBcIkdyZXV0YXRlXCIsXG5cdFx0bWluaW11bU5hbWU6IFwiTWluaW1cIixcblx0XHRtYXhpbXVtTmFtZTogXCJNYXhpbVwiLFxuXHRcdHNvdXJjZURhdGFOYW1lOiBcIlJhc3RlciBzdXJzxINcIixcblx0XHRzb3VyY2VGaWVsZE5hbWU6IFwiQ8OibXAgc3Vyc8SDXCIsXG5cdFx0Y29zdFJhc3Rlck5hbWU6IFwiUmFzdGVyIGNvc3R1cmlcIixcblx0XHRtYXhEaXN0YW5jZU5hbWU6IFwiRGlzdGFuyJvEgyBtYXhpbcSDXCIsXG5cdFx0dmFsdWVSYXN0ZXJOYW1lOiBcIlJhc3RlciB2YWxvYXJlXCIsXG5cdFx0Y29zdE11bHRpcGxpZXJOYW1lOiBcIk11bHRpcGxpY2F0b3IgcGVudHJ1IGFwbGljYXJlIGxhIGNvc3R1cmlcIixcblx0XHRzdGFydENvc3ROYW1lOiBcIkNvc3QgZGUgcG9ybmlyZVwiLFxuXHRcdGFjY3VtQ29zdFJlc2lzdGFuY2VSYXRlTmFtZTogXCJSYXTEgyBhY3VtdWxhdGl2xIMgZGUgcmV6aXN0ZW7Im8SDIGEgY29zdHVyaWxvclwiLFxuXHRcdGNhcGFjaXR5TmFtZTogXCJDYXBhY2l0YXRlXCIsXG5cdFx0dHJhdmVsRGlyZWN0aW9uTmFtZTogXCJEaXJlY8ibaWUgZGUgZGVwbGFzYXJlXCIsXG5cdFx0Y2VsbFNpemVOYW1lOiBcIkRpbWVuc2l1bmUgY2VsdWzEg1wiLFxuXHRcdHBvcHVsYXRpb25GaWVsZE5hbWU6IFwiQ8OibXAgcG9wdWxhyJtpZVwiLFxuXHRcdGFyZWFVbml0c05hbWU6IFwiVW5pdMSDyJtpIHN1cHJhZmHIm8SDXCIsXG5cdFx0b3V0cHV0VmFsdWVUeXBlTmFtZTogXCJWYWxvcmkgY2VsdWzEgyBkZSBpZciZaXJlXCIsXG5cdFx0YmFycmllcnNOYW1lOiBcIkludHJvZHVjZcibaSBiYXJpZXJlbGVcIixcblx0XHRkZXN0aW5hdGlvbkRhdGFOYW1lOiBcIlJhc3RlciBkZXN0aW5hyJtpZVwiLFxuXHRcdGRlc3RpbmF0aW9uRmllbGROYW1lOiBcIkPDom1wIGRlc3RpbmHIm2llXCIsXG5cdFx0cGF0aFR5cGVOYW1lOiBcIlRpcCBjYWxlXCIsXG5cdFx0b2JzZXJ2ZXJGZWF0dXJlc05hbWU6IFwiT2JpZWN0ZSBzcGHIm2lhbGUgb2JzZXJ2YXRvclwiLFxuXHRcdGFuYWx5c2lzTWV0aG9kTmFtZTogXCJNZXRvZMSDIGFuYWxpesSDXCIsXG5cdFx0YW5hbHlzaXNUeXBlTmFtZTogXCJUaXAgYW5hbGl6xINcIixcblx0XHR2ZXJ0aWNhbEVycm9yTmFtZTogXCJFcm9hcmUgdmVydGljYWzEg1wiLFxuXHRcdHJlZnJhY3Rpdml0eUNvZWZmaWNpZW50TmFtZTogXCJDb2VmaWNpZW50IHJlZnJhY3RhcmVcIixcblx0XHRzdXJmYWNlT2Zmc2V0TmFtZTogXCJPZmZzZXQgc3VwcmFmYcibxINcIixcblx0XHRvYnNlcnZlckVsZXZhdGlvbk5hbWU6IFwiRWxldmHIm2llIG9ic2VydmF0b3JcIixcblx0XHRvYnNlcnZlck9mZnNldE5hbWU6IFwiT2Zmc2V0IG9ic2VydmF0b3JcIixcblx0XHRpbm5lclJhZGl1c05hbWU6IFwiUmF6xIMgaW50ZXJpb2FyxINcIixcblx0XHRpbm5lclJhZGl1c0lzM0REaXN0YW5jZU5hbWU6IFwiUmF6YSBpbnRlcmlvYXLEgyBlc3RlIGRpc3RhbsibYSAzRFwiLFxuXHRcdG91dGVyUmFkaXVzTmFtZTogXCJSYXrEgyBleHRlcmlvYXLEg1wiLFxuXHRcdG91dGVyUmFkaXVzSXMzRERpc3RhbmNlTmFtZTogXCJSYXphIGV4dGVyaW9hcsSDIGVzdGUgZGlzdGFuyJthIDNEXCIsXG5cdFx0aG9yaXpvbnRhbFN0YXJ0QW5nbGVOYW1lOiBcIlVuZ2hpIGRlIHBvcm5pcmUgb3Jpem9udGFsXCIsXG5cdFx0aG9yaXpvbnRhbEVuZEFuZ2xlTmFtZTogXCJVbmdoaSBkZSBmaW5hbGl6YXJlIG9yaXpvbnRhbFwiLFxuXHRcdHZlcnRpY2FsVXBwZXJBbmdsZU5hbWU6IFwiVW5naGkgc3VwZXJpb3IgdmVydGljYWxcIixcblx0XHR2ZXJ0aWNhbExvd2VyQW5nbGVOYW1lOiBcIlVuZ2hpIGluZmVyaW9yIHZlcnRpY2FsXCIsXG5cdFx0em9uZURhdGFOYW1lOiBcIlJhc3RlciB6b27Eg1wiLFxuXHRcdHpvbmVGaWVsZE5hbWU6IFwiQ8OibXAgem9uxINcIixcblx0XHRpZ25vcmVOb0RhdGFOYW1lOiBcIklnbm9yYXJlIGbEg3LEgyBkYXRlIMOubiBjYWxjdWxlXCIsXG5cdFx0dGVtcGVyYXR1cmVSYXN0ZXJOYW1lOiBcIlJhc3RlciB0ZW1wZXJhdHVyxINcIixcblx0XHRpblRlbXBlcmF0dXJlVW5pdHNOYW1lOiBcIlVuaXTEg8ibaSBkZSB0ZW1wZXJhdHVyxINcIixcblx0XHRvdXRIZWF0SW5kZXhUZW1wZXJhdHVyZVVuaXRzTmFtZTogXCJVbml0xIPIm2kgaW5kZXggY8SDbGR1csSDXCIsXG5cdFx0cmVsYXRpdmVIdW1pZGl0eVJhc3Rlck5hbWU6IFwiUmFzdGVyIHVtaWRpdGF0ZSByZWxhdGl2xINcIixcblx0XHRvdXRXaW5kQ2hpbGxUZW1wZXJhdHVyZVVuaXRzTmFtZTogXCJVbml0xIPIm2kgcsSDY2lyZSBlb2xpYW7Eg1wiLFxuXHRcdHdpbmRTcGVlZFJhc3Rlck5hbWU6IFwiUmFzdGVyIHZpdGV6xIMgdsOibnRcIixcblx0XHRpbldpbmRTcGVlZFVuaXRzTmFtZTogXCJVbml0xIPIm2kgdml0ZXrEgyB2w6JudFwiLFxuXHRcdHZhbHVlTmFtZTogXCJWYWxvYXJlXCIsXG5cdFx0cHJvcGVydHlOYW1lOiBcIk51bWUgcHJvcHJpZXRhdGVcIixcblx0XHRqc29uTmFtZTogXCJNZXRhZGF0ZSBKU09OXCIsXG5cdFx0em9uZVRhYmxlTmFtZTogXCJUYWJlbCBhdHJpYnV0ZSB6b25hbGVcIixcblx0XHRhdHRyaWJ1dGVGaWVsZE5hbWVzOiBcIk51bWUgY8OibXAgYXRyaWJ1dGVcIixcblx0XHRiYWNrZ3JvdW5kTmFtZTogXCJWYWxvYXJlIGZ1bmRhbFwiLFxuXHRcdHdoZXJlQ2xhdXNlTmFtZTogXCJDbGF1esSDIFVuZGVcIixcblx0XHRtaW5pbXVtVmFsdWVGaWVsZE5hbWU6IFwiTnVtZSBjw6JtcCB2YWxvYXJlIG1pbmltxINcIixcblx0XHRtYXhpbXVtVmFsdWVGaWVsZE5hbWU6IFwiTnVtZSBjw6JtcCB2YWxvYXJlIG1heGltxINcIixcblx0XHRvdXRWYWx1ZUZpZWxkTmFtZTogXCJOdW1lIGPDom1wIHZhbG9hcmUgZGUgaWXImWlyZVwiLFxuXHRcdGRlZmF1bHRWYWx1ZU5hbWU6IFwiVmFsb2FyZSBpbXBsaWNpdMSDIGRlIGllyJlpcmVcIixcblx0XHRjb252ZXJzaW9uTWF0cml4TmFtZTogXCJNYXRyaWNlIGRlIGNvbnZlcnNpZVwiLFxuXHRcdElzUHNldWRvQ29sb3JPdXRwdXROYW1lOiBcIkVzdGUgbyBwc2V1ZG8gaWXImWlyZSBkZSBjdWxvYXJlXCIsXG5cdFx0dW5tYXBwZWRBc1JhbmRvbUNvbG9yTmFtZTogXCJBbG9jYXJlIGFsZWF0b3JpZSBhIGN1bG9yaWkgbGEgcGl4ZWxpaSBuZWNhcnRvZ3JhZmlhyJtpXCIsXG5cdFx0ZGlzdGFuY2VNZXRob2ROYW1lOiBcIk1ldG9kYSBkaXN0YW7Im2VpXCIsXG5cdFx0Zmxvd0RpclJhc3Rlck5hbWU6IFwiUmFzdGVyIGFsIGRpcmVjyJtpZWkgZmx1eHVsdWlcIixcblx0XHRwb3VyUG9pbnROYW1lOiBcIlJhc3RlciBkZSBwdW5jdChlKSBkZSBjdXJnZXJlXCIsXG5cdFx0cG91clBvaW50RmllbGROYW1lOiBcIkPDom1wdWwgcHVuY3R1bHVpIGRlIGN1cmdlcmVcIixcblx0XHRjb25zdGFudFpOYW1lOiBcIkNvbnN0YW50xIMgWlwiLFxuXHRcdHpPZmZzZXROYW1lOiBcIkRlY2FsYXJlIFpcIixcblx0XHRnZW9JZE5hbWU6IFwiR2VvaWRcIixcblx0XHRjYWxpYnJhdGlvblR5cGVOYW1lOiBcIlRpcCBkZSBjYWxpYnJhcmVcIixcblx0XHRmaWx0ZXJUeXBlTmFtZTogXCJUaXAgZGUgZmlsdHJ1XCIsXG5cdFx0ZmlsdGVyU2l6ZU5hbWU6IFwiRGltZW5zaXVuZSBkZSBmaWx0cnVcIixcblx0XHRub2lzZU1vZGVsTmFtZTogXCJNb2RlbCBkZSB6Z29tb3RcIixcblx0XHRub2lzZVZhcmlhbmNlTmFtZTogXCJWYXJpYcibaWUgZGUgemdvbW90XCIsXG5cdFx0YWRkaXRpdmVOb2lzZU1lYW5OYW1lOiBcIk1lZGllIHpnb21vdCBhZGnIm2lvbmFsXCIsXG5cdFx0bXVsdGlwbGljYXRpdmVOb2lzZU1lYW5OYW1lOiBcIk1lZGllIHpnb21vdCBtdWx0aXBsaWNhdGl2XCIsXG5cdFx0bnVtYmVyb2ZMb29rc05hbWU6IFwiTnVtxINyIGRlIGNvbnR1cnVyaVwiLFxuXHRcdGRhbXBpbmdGYWN0b3JOYW1lOiBcIkZhY3RvciBkZSBhbW9ydGl6YXJlXCIsXG5cdFx0bWFza1Jhc3Rlck5hbWU6IFwiUmFzdGVyIG1hc2PEg1wiLFxuXHRcdG5pYmJsZVZhbHVlc05hbWU6IFwiRm9sb3NpyJtpIHZhbG9yaSBmxINyxIMgZGF0ZSBkYWPEgyBhY2VzdGVhIHN1bnQgdmVjaW51bCBjZWwgbWFpIGFwcm9waWF0XCIsXG5cdFx0bmliYmxlTm9EYXRhTmFtZTogXCJDaXVndWxpcmUgY2VsdWxlIGbEg3LEgyBkYXRlXCIsXG5cdFx0ekxpbWl0TmFtZTogXCJMaW1pdMSDIFpcIixcblx0XHRmbG93RGlyZWN0aW9uVHlwZU5hbWU6IFwiVGlwIGFsIGRpcmVjyJtpZWkgZmx1eHVsdWlcIixcblx0XHR3ZWlnaHRSYXN0ZXJOYW1lOiBcIlJhc3RlciBwb25kZXJlXCIsXG5cdFx0Zm9yY2VFZGdlTmFtZTogXCJGb3LIm2HIm2kgdG9hdGUgY2VsdWxlbGUgZGUgbWFyZ2luZSBwZW50cnUgYSBjdXJnZSDDrm4gZXh0ZXJpb3JcIixcblx0XHRzdHJlYW1SYXN0ZXJOYW1lOiBcIlJhc3RlciBjdXJzXCIsXG5cdFx0c3VyZmFjZVJhc3Rlck5hbWU6IFwiUmFzdGVyIHN1cHJhZmHIm8SDXCIsXG5cdFx0Y29udmVyc2lvblR5cGU6IFwiVGlwIGNvbnZlcnRpcmVcIixcblx0XHRkaXN0YW5jZVJhc3RlcjE6IFwiRGlzdGFuxaPEgyBSYXN0ZXIgMVwiLFxuXHRcdGRpc3RhbmNlUmFzdGVyMjogXCJEaXN0YW7Fo8SDIFJhc3RlciAyXCIsXG5cdFx0Y29zdERpc3RhbmNlUmFzdGVyOiBcIlJhc3N0ZXIgZGlzdGFuyJvEgyBkZSBjb3N0XCIsXG5cdFx0Y29zdEJhY2tsaW5rUmFzdGVyOiBcIlJhc3RlciBjb3N0dXJpIGxpbmsgZGUgcmV2ZW5pcmVcIixcblx0XHRvdmVycmlkZXNOYW1lOiBcIlN1cHJhcmVnbGFyZVwiLFxuXHRcdGZpZWxkTmFtZTogXCJGaWVsZFwiLFxuXHRcdHNpZ25hdHVyZUZpbGVPclVybDogXCJGaciZaWVyIGRlIHNlbW7Eg3R1csSDIHNhdSBVUkxcIixcblx0XHRyZWROYW1lOiBcIlJvxZ91XCIsXG5cdFx0Z3JlZW5OYW1lOiBcIlZlcmRlXCIsXG5cdFx0Ymx1ZU5hbWU6IFwiQWxiYXN0cnVcIixcblx0XHRpbmZyYXJlZE5hbWU6IFwiSW5mcmFyb8iZdVwiLFxuXHRcdHBhbmNocm9tYXRpY05hbWU6IFwiUGFuY3JvbWF0aWNcIixcblx0XHRtdWx0aXNwZWN0cmFsTmFtZTogXCJNdWx0aXNwZWN0cmFsXCIsXG5cdFx0cGFuc2hhcnBlbmluZ1R5cGU6IFwiVGlwIHBhbi3Drm1idW7Eg3TEg8ibaXJlIGEgY2xhcml0xIPIm2lpXCIsXG5cdFx0c2Vuc29yTmFtZTogXCJTZW56b3JcIixcblx0XHRzcGF0aWFsUmVmZXJlbmNlTmFtZTogXCJSZWZlcmluxaPEgyBzcGHFo2lhbMSDXCIsXG5cdFx0eENlbGxzaXplTmFtZTogXCJEaW1lbnNpdW5lIGNlbHVsxIMgWFwiLFxuXHRcdHlDZWxsc2l6ZU5hbWU6IFwiRGltZW5zaXVuZSBjZWx1bMSDIFlcIixcblx0XHR4T3JpZ2luTmFtZTogXCJQdW5jdCBkZSDDrm5yZWdpc3RyYXJlIFhcIixcblx0XHR5T3JpZ2luTmFtZTogXCJQdW5jdCBkZSDDrm5yZWdpc3RyYXJlIFlcIixcblx0XHRwZXJjZW50aWxlTmFtZTogXCJWYWxvYXJlIHByb2NlbnR1YWzEg1wiLFxuXHRcdG5laWdoYm9yaG9vZFR5cGU6IFwiVGlwIGRlIHZlY2luxIN0YXRlXCIsXG5cdFx0d2lkdGhOYW1lOiBcIkzEg8ibaW1lXCIsXG5cdFx0aGVpZ2h0TmFtZTogXCLDjm7Eg2zIm2ltZVwiLFxuXHRcdHN0YXJ0QW5nbGVOYW1lOiBcIlVuZ2hpIGRlIHBvcm5pcmVcIixcblx0XHRlbmRBbmdsZU5hbWU6IFwiVW5naGkgZGUgZmluYWxpemFyZVwiLFxuXHRcdG5laWdoYm9yaG9vZFZhbHVlczogXCJWYWxvcmkgZGUgdmVjaW7Eg3RhdGVcIixcblx0XHRob3Jpem9udGFsUmFzdGVyOiBcIlJhc3RlciBvcml6b250YWxcIixcblx0XHRob3Jpem9udGFsRmFjdG9yOiBcIkZhY3RvciBvcml6b250YWxcIixcblx0XHR2ZXJ0aWNhbFJhc3RlcjogXCJSYXN0ZXIgdmVydGljYWxcIixcblx0XHR2ZXJ0aWNhbEZhY3RvcjogXCJGYWN0b3IgdmVydGljYWxcIixcblx0XHRzdHJlYW1SYXN0ZXI6IFwiUmFzdGVyIGN1cnNcIixcblx0XHRmbG93RGlyUmFzdGVyOiBcIlJhc3RlciBhbCBkaXJlY8ibaWVpIGZsdXh1bHVpXCIsXG5cdFx0bnVtYmVyTmVpZ2hib3JDZWxsczogXCJOdW3Eg3IgZGUgY2VsdWxlIHZlY2luZVwiLFxuXHRcdHpvbmVDb25uZWN0aXZpdHk6IFwiQ29uZWNpdGl2aXRhdGUgYSB6b25laVwiLFxuXHRcdGFkZExpbmtCZWhhdmlvcjogXCJBZMSDdWdhcmUgbGVnxIN0dXLEg1wiLFxuXHRcdGV4Y2x1ZGVkVmFsdWU6IFwiVmFsb2FyZSBleGNsdXPEg1wiLFxuXHRcdGNvbnN0YW50RmlsbENoZWNrOiBcIkdlbmVyYcibaSB1bXBsZXJlIHJhc3RlciBkaW4gY29uc3RhbnTEg1wiLFxuXHRcdGZpbGxSYXN0ZXI6IFwiVW1wbGXIm2kgcmFzdGVyXCIsXG5cdFx0Y29uc3RhbnRGaWxsVmFsdWU6IFwiVmFsb2FyZSBjb25zdGFudMSDXCIsXG5cdFx0aW5wdXRCaXRQb3NpdGlvbnM6IFwiQml0IGRlIGludHJhcmVcIixcblx0XHRvdXRwdXRCaXRQb3NpdGlvbnM6IFwiQml0IGRlIGllyJlpcmVcIixcblx0XHRkaXN0YW5jZVR5cGVOYW1lOiBcIlRpcCBkaXN0YW7Im8SDXCIsXG5cdFx0YmFycmllckRhdGFOYW1lOiBcIkJhcmllcmUgcmFzdGVyXCIsXG5cdFx0cG91clBvaW50RGF0YU5hbWU6IFwiUmFzdGVyIGFsIHB1bmN0dWx1aSBkZSBjdXJnZXJlXCIsXG5cdFx0YWNjdW11bGF0aW9uUmFzdGVyTmFtZTogXCJSYXN0ZXIgZGUgYWN1bXVsYXJlIGEgZmx1eHVsdWlcIixcblx0XHRzbmFwRGlzdGFuY2VOYW1lOiBcIkRpc3RhbsibxIMgRml4YXJlXCIsXG5cdFx0b3JkZXJNZXRob2ROYW1lOiBcIk1ldG9kxIMgZGUgQ29tYW5kxINcIixcblx0XHRkaXJlY3Rpb25NZWFzdXJlbWVudE5hbWU6IFwiRGlyZWPIm2llIGRlIE3Eg3N1cmFyZVwiLFxuXHRcdHByb2Nlc3NBc011bHRpYmFuZDogXCJQcm9jZXNhyJtpIGNhIG11bHRpYmFuZMSDXCIsXG5cdFx0cHJvY2Vzc011bHRpZGltZW5zaW9uYWw6IFwiUHJvY2VzYcibaSBjYSBtdWx0aWRpbWVuc2lvbmFsXCIsXG5cdFx0Zm9yY2VGbG93RGlyZWN0aW9uQ29udmVudGlvbjogXCJGb3LIm2HIm2kgcHJvdG9jb2x1bCBkaXJlY8ibaWVpIGZsdXh1bHVpIHBlbnRydSByYXN0ZXIgY3UgbGVnxIN0dXLEgyBpbnZlcnPEg1wiLFxuXHRcdGluaXRpYWxBY2N1bXVsYXRpb246IFwiQWN1bXVsYXJlIGluacibaWFsxINcIixcblx0XHRtYXhpbXVtQWNjdW11bGF0aW9uOiBcIkFjdW11bGFyZSBtYXhpbcSDXCIsXG5cdFx0c291cmNlTG9jYXRpb25CYW5kczogXCJHZW5lcmHIm2kgcsOibmQgyJlpIGNvbG9hbsSDIHN1cnPEgyBjYSBiZW56aSBzdXBsaW1lbnRhcmUgw65uIGllyJlpcmVcIixcblx0XHRiYWNrRGlyZWN0aW9uQmFuZDogXCJHZW5lcmHIm2kgZGlyZWPIm2lhIMOubmFwb2kgY2EgYmFuZMSDIHN1cGxpbWVudGFyxIMgw65uIGllyJlpcmVcIixcblx0XHRudW1iZXJPZkNlbGxzOiBcIk51bcSDciBkZSBjZWx1bGVcIixcblx0XHR6b25lVmFsdWVzOiBcIlZhbG9yaSBhbGUgem9uZWlcIixcblx0XHRzaHJpbmtNZXRob2Q6IFwiTWV0b2RhIGRlIGNvbnRyYWN0YXJlXCIsXG5cdFx0ZXhwYW5kTWV0aG9kOiBcIk1ldG9kYSBkZSBleHRpbmRlcmVcIixcblx0XHRpbnB1dFNwZWN0cmFsUHJvZmlsZVR5cGU6IFwiVGlwIGRlIHByb2ZpbCBzcGVjdHJhbFwiLFxuXHRcdHNwZWN0cmFsUHJvZmlsZUZpbGVOYW1lOiBcIlByb2ZpbCBzcGVjdHJhbFwiLFxuXHRcdHRyYWluaW5nRmVhdHVyZUZpbGVOYW1lOiBcIk9iaWVjdCBzcGHIm2lhbCBwZW50cnUgaW5zdHJ1aXJlXCIsXG5cdFx0bm9uTmVnYXRpdmU6IFwiTm9uLW5lZ2F0aXZcIixcblx0XHRzdW1Ub09uZTogXCJBZHVuYcibaSBsYSB1bnVcIixcblx0XHRyYW5kb21EaXN0cmlidXRpb246IFwiRGlzdHJpYnXFo2llXCIsXG5cdFx0bWVhbk5hbWU6IFwiTWVkaWVcIixcblx0XHRwcm9iYWJpbGl0eU5hbWU6IFwiUHJvYmFiaWxpdGF0ZVwiLFxuXHRcdGFscGhhTmFtZTogXCJBbGZhXCIsXG5cdFx0YmV0YU5hbWU6IFwiQmV0YVwiLFxuXHRcdHJOYW1lOiBcInJcIixcblx0XHRuTmFtZTogXCJOXCIsXG5cdFx0c2VlZDogXCJQbGVjYXJlXCIsXG5cdFx0cmFuZG9tTnVtYmVyR2VuZXJhdG9yOiBcIkdlbmVyYXRvciBkZSBudW1lcmUgYWxlYXRvcmlpXCIsXG5cdFx0Y2VsbEZhY3RvcjogXCJGYWN0b3IgZGUgY2VsdWzEg1wiLFxuXHRcdGFnZ3JlZ2F0aW9uVHlwZTogXCJUZWhuaWPEgyBkZSBhZ3JlZ2FyZVwiLFxuXHRcdGV4dGVudEhhbmRsaW5nOiBcIk3Eg3N1csSDIGRlIGV4dGluZGVyZSBkYWPEgyBlc3RlIG5lY2VzYXLEg1wiLFxuXHRcdHRyZW5kQW5hbHlzaXNEaW1lbnNpb25OYW1lOiBcIk51bWVsZSBkaW1lbnNpdW5paVwiLFxuXHRcdHRyZW5kQW5hbHlzaXNUeXBlOiBcIlRpcHVsIHRlbmRpbsibZWlcIixcblx0XHRoYXJtb25pY0ZyZXF1ZW5jeTogXCJGcmVjdmVuyJthIGFybW9uaWPEg1wiLFxuXHRcdHBvbHlub21pYWxPcmRlcjogXCJPcmRpbmUgcG9saW5vbWlhbMSDXCIsXG5cdFx0Y3ljbGVMZW5ndGhOYW1lOiBcIkR1cmF0YSBjaWNsdWx1aVwiLFxuXHRcdHRyZW5kQW5hbHlzaXNSTVNFOiBcIlJNU0VcIixcblx0XHR0cmVuZEFuYWx5c2lzUjI6IFwiUiBsYSBwxIN0cmF0XCIsXG5cdFx0dHJlbmRBbmFseXNpc1Nsb3BlUFZhbHVlOiBcIlZhbG9hcmVhIFAgYSBjb2VmaWNpZW50dWx1aSBkZSBwYW50xINcIixcblx0XHR0cmVuZEFuYWx5c2lzU2Vhc29uYWxQZXJpb2Q6IFwiUGVyaW9hZMSDIHNlem9uaWVyxINcIixcblx0XHRjeWNsZVVuaXROYW1lOiBcIlVuaXRhdGUgY2ljbHVcIixcblx0XHRwcmVkaWN0RGltZW5zaW9uVmFsdWVzOiBcIlZhbG9yaVwiLFxuXHRcdGRpbWVuc2lvbkRlZmluaXRpb25UeXBlOiBcIkRlZmluacibaWEgZGltZW5zaXVuaWlcIixcblx0XHRwcmVkaWN0RGltZW5zaW9uU3RhcnQ6IFwiw45uY2VwdXRcIixcblx0XHRwcmVkaWN0RGltZW5zaW9uRW5kOiBcIlNmw6JyyJlpdFwiLFxuXHRcdHByZWRpY3REaW1lbnNpb25JbnRlcnZhbDogXCJJbnRlcnZhbCBkZSB2YWxvcmlcIixcblx0XHRkaW1lbnNpb25Vbml0OiBcIlVuaXRhdGVcIixcblx0XHRpbnRlcnBvbGF0aW9uQ2VsbHNpemVOYW1lOiBcIkRpbWVuc2l1bmVhIGNlbHVsZWkgZGUgaW50ZXJwb2xhcmVcIixcblx0XHR2YXJpYWJsZU5hbWU6IFwiVmFyaWFiaWxlXCIsXG5cdFx0ZGltZW5zaW9ubGVzc05hbWU6IFwiRsSDcsSDIGRpbWVuc2l1bmlcIixcblx0XHRtZGltRGVmaW5pdGlvbjogXCJEZWZpbmnIm2lhIGRpbWVuc2l1bmlpXCIsXG5cdFx0ZGltZW5zaW9uTmFtZTogXCJEaW1lbnNpdW5lXCIsXG5cdFx0aXRlcmF0aW9uU3RhcnQ6IFwiw45uY2VwdXR1bCBwcmltZWkgaXRlcmHIm2lpXCIsXG5cdFx0aXRlcmF0aW9uRW5kOiBcIlNmw6JyyJlpdHVsIHByaW1laSBpdGVyYcibaWlcIixcblx0XHRpbnRlcnZhbFN0YXJ0OiBcIsOObmNlcHV0dWwgaW50ZXJ2YWx1bHVpXCIsXG5cdFx0aW50ZXJ2YWxFbmQ6IFwiU2bDonLImWl0dWwgaW50ZXJ2YWx1bHVpXCIsXG5cdFx0c3RlcE5hbWU6IFwiRXRhcMSDXCIsXG5cdFx0cmFuZ2VzTmFtZTogXCJJbnRlcnZhbGVcIixcblx0XHRtaW5WYWx1ZTogXCJWYWxvYXJlIG1pbmltxINcIixcblx0XHRtYXhWYWx1ZTogXCJWYWxvYXJlIG1heGltxINcIixcblx0XHRjaGFuZ2VBbmFseXNpc1Jhc3Rlck5hbWU6IFwiU2NoaW1iYcibaSByYXN0ZXJ1bCBkZSBhbmFsaXrEg1wiLFxuXHRcdGNoYW5nZVR5cGVOYW1lOiBcIk1vZGlmaWNhcmUgdGlwXCIsXG5cdFx0c2VnbWVudERhdGU6IFwiRGF0YSBzZWdtZW50dWx1aVwiLFxuXHRcdGNoYW5nZURpcmVjdGlvbk5hbWU6IFwiU2NoaW1iYcibaSBkaXJlY8ibaWFcIixcblx0XHRtYXhOdW1DaGFuZ2VzTmFtZTogXCJOdW3Eg3IgbWF4aW0gZGUgbW9kaWZpY8SDcmlcIixcblx0XHRmaWx0ZXJCeVllYXI6IFwiRmlsdHJhyJtpIGR1cMSDIGFuXCIsXG5cdFx0bWluaW11bVllYXI6IFwiVmFsb2FyZSBtaW5pbcSDXCIsXG5cdFx0bWF4aW11bVllYXI6IFwiVmFsb2FyZSBtYXhpbcSDXCIsXG5cdFx0ZmlsdGVyQnlEdXJhdGlvbjogXCJGaWx0cmHIm2kgZHVwxIMgZHVyYXTEg1wiLFxuXHRcdG1pbmltdW1EdXJhdGlvbjogXCJEdXJhdMSDIG1pbmltxINcIixcblx0XHRtYXhpbXVtRHVyYXRpb246IFwiRHVyYXTEgyBtYXhpbcSDXCIsXG5cdFx0ZmlsdGVyQnlNYWduaXR1ZGU6IFwiRmlsdHJhyJtpIGR1cMSDIG1hZ25pdHVkaW5lXCIsXG5cdFx0bWluaW11bU1hZ25pdHVkZTogXCJNYWduaXR1ZGluZSBtaW5pbcSDXCIsXG5cdFx0bWF4aW11bU1hZ25pdHVkZTogXCJNYWduaXR1ZGluZSBtYXhpbcSDXCIsXG5cdFx0ZmlsdGVyQnlTdGFydFZhbHVlOiBcIkZpbHRyYXJlIGR1cMSDIHZhbG9hcmUgZGUgw65uY2VwdXRcIixcblx0XHRtaW5pbXVtU3RhcnRWYWx1ZTogXCJWYWxvYXJlIGRlIMOubmNlcHV0IG1pbmltxINcIixcblx0XHRtYXhpbXVtU3RhcnRWYWx1ZTogXCJWYWxvYXJlIGRlIMOubmNlcHV0IG1heGltxINcIixcblx0XHRmaWx0ZXJCeUVuZFZhbHVlOiBcIkZpbHRyYXJlIGR1cMSDIHZhbG9hcmUgZGUgc2bDonLImWl0XCIsXG5cdFx0bWluaW11bUVuZFZhbHVlOiBcIlZhbG9hcmUgZGUgc2bDonLImWl0IG1pbmltxINcIixcblx0XHRtYXhpbXVtRW5kVmFsdWU6IFwiVmFsb2FyZSBkZSBzZsOicsiZaXQgbWF4aW3Eg1wiLFxuXHRcdG1vZGVsVHlwZU5hbWU6IFwiVGlwdWwgZGUgbW9kZWxcIixcblx0XHRmcm9tUmFzdGVyTmFtZTogXCJEZSBwZSByYXN0ZXJcIixcblx0XHR0b1Jhc3Rlck5hbWU6IFwiUGUgcmFzdGVyXCIsXG5cdFx0Y29tcHV0ZUNoYW5nZU1ldGhvZDogXCJNZXRvZGEgZGUgY2FsY3VsYXJlIGEgbW9kaWZpY8SDcmlpXCIsXG5cdFx0ZnJvbUNsYXNzVmFsdWVzOiBcIlZhbG9yaSBkZSBjbGFzxIMgRGUgbGEgKEV4ZW1wbHU6IDIgNSlcIixcblx0XHR0b0NsYXNzVmFsdWVzOiBcIlZhbG9yaSBkZSBjbGFzxIMgUMOibsSDIGxhIChFeGVtcGx1OiAyIDUpXCIsXG5cdFx0a2VlcE1ldGhvZDogXCJNZXRvZMSDIGRlIGZpbHRyYXJlXCIsXG5cdFx0dXNlQ29sb3JNZXRob2Q6IFwiRGVmaW5pyJtpIGN1bG9yaWxlIGRlIHRyYW56acibaWVcIixcblx0XHRkZXRlY3RDaGFuZ2VCYW5kczogXCJCZW56aSBwZW50cnUgZGV0ZWN0YXJlYSBzY2hpbWLEg3JpaSAoc3RhcnQgbGEgMClcIixcblx0XHR0bWFza0JhbmRzOiBcIkJlbnppIHBlbnRydSBtYXNjYXJlIHRlbXBvcmFsxIMgKHN0YXJ0IGxhIDApXCIsXG5cdFx0Y2hpU3F1YXJlZFRocmVzaG9sZDogXCJQcmFndWwgZGUgY2hpLXDEg3RyYXQgcGVudHJ1IGRldGVjdGFyZWEgbW9kaWZpY8SDcmlpXCIsXG5cdFx0bWluQW5vbWFseTogXCJOdW3Eg3J1bCBtaW5pbSBkZSBvYnNlcnZhyJtpaSBjb25zZWN1dGl2ZSBhIGFub21hbGlpbG9yXCIsXG5cdFx0dXBkYXRpbmdGcmVxdWVuY3k6IFwiRnJlY3ZlbsibYSBkZSBhY3R1YWxpemFyZSBhIGFqdXN0xINyaWkgKMOubiBhbmkpXCIsXG5cdFx0ZGlzdGFuY2VBY2N1bXVsYXRpb25SYXN0ZXJOYW1lOiBcIlJhc3RlciBkZSBhY3VtdWxhcmUgYSBkaXN0YW7Im2VpXCIsXG5cdFx0Y29zdEJhY2tkaXJlY3Rpb25SYXN0ZXJOYW1lOiBcIlJhc3RlciBEaXJlY8ibaWUgaW52ZXJzxIMgc2F1IERpcmVjyJtpYSBmbHV4dWx1aVwiLFxuXHRcdHJhc3RlckNvbGxlY3Rpb25OYW1lOiBcIkNvbGVjdGFyZSBSYXN0ZXJcIixcblx0XHRpdGVtRnVuY3Rpb25OYW1lOiBcIkZ1bmPIm2llIHJlcGVyXCIsXG5cdFx0YWdncmVnYXRpb25GdW5jdGlvbk5hbWU6IFwiRnVuY8ibaWUgZGUgYWdyZWdhcmVcIixcblx0XHRwcm9jZXNzaW5nRnVuY3Rpb25OYW1lOiBcIkZ1bmPIm2llIGRlIHByb2Nlc2FyZVwiLFxuXHRcdGFnZ3JlZ2F0aW9uRGVmaW5pdGlvbk5hbWU6IFwiRGVmaW5pyJtpZSBkZSBhZ3JlZ2FyZVwiLFxuXHRcdHF1ZXJ5R2VvbWV0cnlOYW1lOiBcIkdlb21ldHJpYSBkZSBpbnRlcm9nYXJlXCIsXG5cdFx0ZmFjdG9yRnVuY3Rpb25aZXJvRmFjdG9yOiBcIkZhY3RvciB6ZXJvXCIsXG5cdFx0ZmFjdG9yRnVuY3Rpb25DdXRBbmdsZTogXCJVbmdoaSBkZSB0xINpZXJlXCIsXG5cdFx0ZmFjdG9yRnVuY3Rpb25TaWRlRmFjdG9yOiBcIkZhY3RvciBsYXRlcmFsXCIsXG5cdFx0ZmFjdG9yRnVuY3Rpb25TbG9wZTogXCJQYW50xINcIixcblx0XHRmYWN0b3JGdW5jdGlvbkxvd0N1dEFuZ2xlOiBcIlVuZ2hpIGRlIHTEg2llcmUgaW5mZXJpb3JcIixcblx0XHRmYWN0b3JGdW5jdGlvbkhpZ2hDdXRBbmdsZTogXCJVbmdoaSBkZSB0xINpZXJlIHN1cGVyaW9yXCIsXG5cdFx0ZmFjdG9yRnVuY3Rpb25Db3NQb3dlcjogXCJDb3NpbnVzdWwgcHV0ZXJpaVwiLFxuXHRcdGZhY3RvckZ1bmN0aW9uU2VjUG93ZXI6IFwiU2VjYW50YSBwdXRlcmlpXCIsXG5cdFx0ZmFjdG9yRnVuY3Rpb25UYWJsZVBhdGg6IFwiQ2FsZWEgZGluIHRhYmVsXCIsXG5cdFx0cHJvY2Vzc2luZ0JhbmQ6IFwiQmFuZMSDIGRlIHByb2Nlc2FyZVwiLFxuXHRcdHByb2Nlc3NpbmdCYW5kTmFtZTogXCJOdW1lbGUgYmVuemlpIGRlIHByb2Nlc2FyZVwiLFxuXHRcdHNuYXBwaW5nRGF0ZTogXCJEYXRhIGVmZWN0dcSDcmlpIGZvdG9ncmFmaWVpXCIsXG5cdFx0bWF4TnVtU2VnbWVudHM6IFwiTnVtxINyIG1heGltIGRlIHNlZ21lbnRlXCIsXG5cdFx0dmVydGV4Q291bnRPdmVyc2hvb3Q6IFwiU3VwcmFtb2R1bGHIm2lhIG51bcSDcnVsdWkgVmVydGV4XCIsXG5cdFx0c3Bpa2VUaHJlc2hvbGQ6IFwiUHJhZyBkZSBuZXJlZ3VsYXJpdMSDyJtpXCIsXG5cdFx0cmVjb3ZlcnlUaHJlc2hvbGQ6IFwiUHJhZyBkZSByZWN1cGVyYXJlXCIsXG5cdFx0bWluTnVtT2JzOiBcIk51bcSDciBtaW5pbSBkZSBvYnNlcnbEg3JpXCIsXG5cdFx0cFZhbHVlVGhyZXNob2xkOiBcIlByYWcgZGUgdmFsb2FyZSBQXCIsXG5cdFx0YmVzdE1vZGVsUHJvcG9ydGlvbjogXCJDZWEgbWFpIGJ1bsSDIHByb3BvcsibaWUgZGUgbW9kZWxcIixcblx0XHRwcmV2ZW50T25lWWVhclJlY292ZXJ5OiBcIsOObXBpZWRpY2HIm2kgcmVjdXBlcmFyZWEgw65udHItdW4gYW5cIixcblx0XHRyZWNvdmVyeUluY3JlYXNlVHJlbmQ6IFwiUmVjdXBlcmFyZWEgYXJlIHRlbmRpbsibxIMgY3Jlc2PEg3RvYXJlXCIsXG5cdFx0b3V0cHV0T3RoZXJCYW5kczogXCJJZciZaXJlIGFsdGUgYmVuemlcIixcblx0XHRzb3J0VHlwZTogXCJTb3J0YXJlYSBUaXB1bHVpXCIsXG5cdFx0bnVtYmVyT2ZSdW5zOiBcIlJ1bGHIm2kgZXh0aW5kZXJlYSDImWkgcmVzdHLDom5nZXJlYSBkZSBkb3XEgyBvcmlcIixcblx0XHRwZXJjZW50aWxlVmFsdWU6IFwiVmFsb2FyZSBwcm9jZW50dWFsxINcIixcblx0XHRwZXJjZW50aWxlSW50ZXJwb2xhdGlvblR5cGU6IFwiVGlwIGRlIGludGVycG9sYXJlIGEgcGVyY2VudGlsZWlcIixcblx0XHRyYXN0ZXJJbmZvUHJvcGVydHk6IFwiUHJvcHJpZXRhdGVcIixcblx0XHRyYXN0ZXJJbmZvVmFsdWU6IFwiVmFsb2FyZVwiLFxuXHRcdHJhc3RlckluZm9Db2x1bW5zOiBcIkNvbG9hbmVcIixcblx0XHRyYXN0ZXJJbmZvUm93czogXCJSw6JuZHVyaVwiLFxuXHRcdHJhc3RlckluZm9CYW5kQ291bnQ6IFwiTnVtxINyIGRlIGJlbnppXCIsXG5cdFx0cmFzdGVySW5mb1BpeGVsU2l6ZVg6IFwiRGltZW5zaXVuZSBjZWx1bMSDIFhcIixcblx0XHRyYXN0ZXJJbmZvUGl4ZWxTaXplWTogXCJEaW1lbnNpdW5lIGNlbHVsxIMgWVwiLFxuXHRcdHJhc3RlckluZm9QaXhlbFR5cGU6IFwiVGlwIHBpeGVsXCIsXG5cdFx0cmFzdGVyRXh0ZW50VG9wOiBcIlN1c1wiLFxuXHRcdHJhc3RlckV4dGVudEJvdHRvbTogXCJKb3NcIixcblx0XHRyYXN0ZXJFeHRlbnRMZWZ0OiBcIlN0w6JuZ2FcIixcblx0XHRyYXN0ZXJFeHRlbnRSaWdodDogXCJEcmVhcHRhXCIsXG5cdFx0cmFzdGVyU3RhdGlzdGljc05vdENhbGN1bGF0ZWQ6IFwiU3RhdGlzdGljYSBudSBhIGZvc3QgY2FsY3VsYXTEgy5cIixcblx0XHRzcGF0aWFsUmVmZXJlbmNlUHJvamVjdGlvbjogXCJQcm9pZWPFo2lhXCIsXG5cdFx0c3BhdGlhbFJlZmVyZW5jZVdraWQ6IFwiV0tJRFwiLFxuXHRcdHNwYXRpYWxSZWZlcmVuY2VMYXRlc3RXa2lkOiBcIldLSUQgYW50ZXJpb3JcIixcblx0XHRzcGF0aWFsUmVmZXJlbmNlV2t0OiBcIldLVFwiLFxuXHRcdHNwYXRpYWxSZWZlcmVuY2VWY3NXa2lkOiBcIlZDU1dLSURcIixcblx0XHRzcGF0aWFsUmVmZXJlbmNlTGF0ZXN0VmNzV2tpZDogXCJWQ1NXS0lEIGFudGVyaW9yXCIsXG5cdFx0c3BhdGlhbFJlZmVyZW5jZUF1dGhvcml0eTogXCJBdXRvcml0YXRlXCIsXG5cdFx0c3BhdGlhbFJlZmVyZW5jZUxpbmVhclVuaXQ6IFwiVW5pdGF0ZSBsaW5pYXLEg1wiLFxuXHRcdHNwYXRpYWxSZWZlcmVuY2VBbmd1bGFyVW5pdDogXCJVbml0YXRlIHVuZ2hpdWxhcsSDXCIsXG5cdFx0c3BhdGlhbFJlZmVyZW5jZUZhbHNlRWFzdGluZzogXCJPcmllbnRhcmUgY8SDdHJlIGVzdCBmYWxzxINcIixcblx0XHRzcGF0aWFsUmVmZXJlbmNlRmFsc2VOb3J0aGluZzogXCJPcmllbnRhcmUgY8SDdHJlIG5vcmQgZmFsc8SDXCIsXG5cdFx0c3BhdGlhbFJlZmVyZW5jZUNlbnRyYWxNZXJpZGlhbjogXCJNZXJpZGlhbiBjZW50cmFsXCIsXG5cdFx0c3BhdGlhbFJlZmVyZW5jZVByaW1lTWVyaWRpYW46IFwiTWVyaWRpYW4gemVyb1wiLFxuXHRcdHNwYXRpYWxSZWZlcmVuY2VTdGFuZGFyZFBhcmFsbGVsMTogXCJQYXJhbGVsIHN0YW5kYXJkIDFcIixcblx0XHRzcGF0aWFsUmVmZXJlbmNlU3RhbmRhcmRQYXJhbGxlbDI6IFwiUGFyYWxlbCBzdGFuZGFyZCAyXCIsXG5cdFx0c3BhdGlhbFJlZmVyZW5jZUxhdGl0dWRlT2ZPcmlnaW46IFwiTGF0aXR1ZGluZWEgb3JpZ2luaWlcIixcblx0XHRzcGF0aWFsUmVmZXJlbmNlQXV4aWxpYXJ5U3BoZXJlVHlwZTogXCJUaXAgc2ZlcsSDIGF1eGlsaWFyxINcIixcblx0XHRzcGF0aWFsUmVmZXJlbmNlRGF0dW06IFwiRGF0xINcIixcblx0XHRzcGF0aWFsUmVmZXJlbmNlU3BoZXJvaWQ6IFwiU2Zlcm9pZFwiLFxuXHRcdHNwYXRpYWxSZWZlcmVuY2VTZW1pbWFqb3JBeGlzOiBcIkF4xIMgc2VtaW1ham9yxINcIixcblx0XHRzcGF0aWFsUmVmZXJlbmNlU2VtaW1pbm9yQXhpczogXCJBeMSDIHNlbWltaW5vcsSDXCIsXG5cdFx0c3BhdGlhbFJlZmVyZW5jZUludmVyc2VGbGF0dGVuaW5nOiBcIkFwbGF0aXphcmUgaW52ZXJzxINcIixcblx0XHRpbnB1dERlZmluaXRpb25GaWxlTmFtZTogXCJJbnRyb2R1Y2VyZSBkZWZpbmnFo2llIGZpxZ9pZXJcIixcblx0XHRkZWxldGVOYW1lOiBcIsiYdGVyZ2VyZVwiLFxuXHRcdGFkZFZhcmlhYmxlTmFtZTogXCJBZMSDdWdhcmUgdmFyaWFiaWzEg1wiLFxuXHRcdG1heE51bVBpeGVsc1BlclNlZ21lbnQ6IFwiRGltZW5zaXVuZWEgbWF4aW3EgyBzZWdtZW50IMOubiBwaXhlbGlcIixcblx0XHRmb3J3YXJkV2luZG93TmFtZTogXCJGZXJlYXN0cmEgw65uYWludGVcIixcblx0XHRiYWNrd2FyZFdpbmRvd05hbWU6IFwiRmVyZWFzdHJhIMOubmFwb2lcIixcblx0XHRub0RhdGFIYW5kbGluZ05hbWU6IFwiTWFuZXZyYXJlIEbEg3LEg0RhdGVcIixcblx0XHRjaXJjdWxhcldyYXBWYWx1ZU5hbWU6IFwiVmFsb2FyZWEgw65uZsSDyJl1csSDcmlpIGNpcmN1bGFyZVwiLFxuXHRcdGZyb21DbGFzc05hbWVGaWVsZE5hbWU6IFwiTnVtZSBkZSBjw6JtcCBwZW50cnUgbnVtZSBkZSBjbGFzxIMgZGluIFJhc3RlclwiLFxuXHRcdHRvQ2xhc3NOYW1lRmllbGROYW1lOiBcIk51bWUgZGUgY8OibXAgcGVudHJ1IG51bWUgZGUgY2xhc8SDIMOubiBSYXN0ZXJcIixcblx0XHR0YXJnZXRSYXN0ZXJOYW1lOiBcIlJhc3RlciDIm2ludMSDXCIsXG5cdFx0Y2lyY3VsYXJXcmFwVmFsdWU6IFwiVmFsb2FyZWEgw65uZsSDyJl1csSDcmlpIGNpcmN1bGFyZVwiLFxuXHRcdGJhbmRJbmRleGVzUjogXCJFeHByZXNpZSByb8iZaWVcIixcblx0XHRiYW5kSW5kZXhlc0c6IFwiRXhwcmVzaWUgdmVyZGVcIixcblx0XHRiYW5kSW5kZXhlc0I6IFwiRXhwcmVzaWUgYWxiYXN0csSDXCIsXG5cdFx0ZXhhbXBsZU5hbWU6IFwiRXhlbXBsdVwiLFxuXHRcdGlucHV0TmFtZTogXCJJbnRyb2R1Y2VyZVwiLFxuXHRcdG91dHB1dE5hbWU6IFwiSWXFn2lyZVwiLFxuXHRcdG9wdGlvbmFsTmFtZTogXCJPcMWjaW9uYWxcIixcblx0XHRicm93c2VEZWZpbml0aW9uRmlsZTogXCJSxINzZm9pcmUgZmnImWllciBkZSBkZWZpbmnIm2llXCIsXG5cdFx0c2VsZWN0RGVmaW5pdGlvbkZpbGU6IFwiU2VsZWN0YXJlIGZpyJlpZXIgZGUgZGVmaW5pyJtpZSBpbnRyYXJlXCIsXG5cdFx0aW5wdXREZWZpbml0aW9uVVJMOiBcIlVSTCBmaciZaWVyIGRlIGRlZmluacibaWUgaW50cmFyZVwiLFxuXHRcdGVudGVyRGVmaW5pdGlvbkZpbGVVUkw6IFwiSW50cm9kdWNlyJtpIFVSTC11bCBmaciZaWVydWx1aSBkZSBkZWZpbmnIm2llXCIsXG5cdFx0YnJvd3NlWE1MRmlsZTogXCJSxINzZm9pyJtpIGZpyJlpZXJ1bCBYTUxcIixcblx0XHRzZWxlY3RTdGF0c0ZpbGU6IFwiU2VsZWN0YcibaSBmaciZaWVydWwgZGUgc3RhdGlzdGljaSDImWkgaGlzdG9ncmFtZVwiLFxuXHRcdGVudGVyWE1MRmlsZVVSTDogXCJJbnRyb2R1Y2XIm2kgVVJMLXVsIGZpyJlpZXJ1bHVpIFhNTFwiLFxuXHRcdHhtbEZpbGVVUkw6IFwiVVJMIGZpyJlpZXIgWE1MXCIsXG5cdFx0Y2lyY3VsYXJDYWxjdWxhdGlvbjogXCJDYWxjdWxhcmUgc3RhdGlzdGljaSBjaXJjdWxhcmVcIixcblx0XHRsb2NhbFN1cmZhY2VUeXBlOiBcIlRpcCBkZSBzdXByYWZhyJvEgyBsb2NhbMSDXCIsXG5cdFx0c3VyZmFjZVBhcmFtZXRlclR5cGU6IFwiVGlwIGRlIHBhcmFtZXRydVwiLFxuXHRcdG5laWdoYm9yaG9vZERpc3RhbmNlOiBcIkRpc3RhbsibxIMgZGUgdmVjaW7Eg3RhdGVcIixcblx0XHR1c2VBZGFwdGl2ZU5laWdoYm9yaG9vZDogXCJVdGlsaXphcmUgdmVjaW7Eg3RhdGUgYWRhcHRpdsSDXCIsXG5cdFx0b3V0cHV0U2xvcGVUeXBlOiBcIk3Eg3N1cmFyZSBwYW50xIMgaWXImWlyZVwiLFxuXHRcdHByb2plY3RBemltdXRoczogXCJQcm9jZW50IGdlb2RlemljIGF6aW11dFwiLFxuXHRcdHVzZUVxdWF0b3JpYWxBc3BlY3Q6IFwiVXRpbGl6YXJlIGFzcGVjdCBlY3VhdG9yaWFsXCIsXG5cdFx0elVuaXQ6IFwiVW5pdGF0ZSBaXCIsXG5cdFx0YW5hbHlzaXNNYXNrOiBcIk1hc2PEgyBkZSBhbmFsaXrEg1wiLFxuXHRcdHN0ZERldmlhdGlvbjogXCJEZXZpYcibaWUgc3RhbmRhcmRcIixcblx0XHRcInRydWVcIjogXCJUcnVlXCIsXG5cdFx0XCJmYWxzZVwiOiBcIkZhbHNcIixcblx0XHRjb3N0RGlzdGFuY2VSYXN0ZXIxOiBcIkludHJhcmUgQ29zdCBjdW11bGF0IERpc3RhbsibYSBkZSBpbnRyYXJlIFJhc3RlciAxXCIsXG5cdFx0Y29zdERpc3RhbmNlUmFzdGVyMjogXCJJbnRyYXJlIENvc3QgY3VtdWxhdCBEaXN0YW7Im2EgZGUgaW50cmFyZSBSYXN0ZXIgMlwiLFxuXHRcdHRocmVzaG9sZDogXCJQcmFnXCIsXG5cdFx0dGhyZXNob2xkTWV0aG9kOiBcIk1ldG9kYSBwcmFndWx1aVwiLFxuXHRcdGRpcmVjdGlvblJhc3RlcjE6IFwiSW50cmFyZSDDjm5hcG9pIERpcmVjyJtpZSBSYXN0ZXIgMVwiLFxuXHRcdGRpcmVjdGlvblJhc3RlcjI6IFwiSW50cmFyZSDDjm5hcG9pIERpcmVjyJtpZSBSYXN0ZXIgMlwiLFxuXHRcdG1heEl0ZXJhdGlvbnM6IFwiTnVtxINydWwgbWF4aW0gZGUgaXRlcmHIm2lpXCIsXG5cdFx0ZXBzaWxvbjogXCJFcHNpbG9uXCJcblx0fSxcblx0ZW51bUxhYmVsczoge1xuXHRcdGF0dHJpYnV0ZVRhYmxlVHlwZU1hbnVhbDogXCJNYW51YWxcIixcblx0XHRhdHRyaWJ1dGVUYWJsZVR5cGVFeHRlcm5hbDogXCJFeHRlcm5cIixcblx0XHRjbHJTY2hlbWVUeXBlQ29sb3JtYXA6IFwiQ3Vsb2FyZSBoYXJ0xINcIixcblx0XHRjbHJTY2hlbWVUeXBlQ29sb3JSYW1wOiBcIlJhbXDEgyBkZSBjdWxvYXJlXCIsXG5cdFx0Y29sb3JtYXBUeXBlRWxldmF0aW9uOiBcIkVsZXZhyJtpZVwiLFxuXHRcdGNvbG9ybWFwVHlwZUdyYXk6IFwiR3JpXCIsXG5cdFx0Y29sb3JtYXBUeXBlTkRWSTogXCJORFZJXCIsXG5cdFx0Y29sb3JtYXBUeXBlTkRWSTI6IFwiTkRWSTJcIixcblx0XHRjb2xvcm1hcFR5cGVORFZJMzogXCJORFZJM1wiLFxuXHRcdGNvbG9ybWFwVHlwZVJhbmRvbTogXCJBbGVhdG9yaXVcIixcblx0XHRub25lOiBcIk5pY2l1bmFcIixcblx0XHRzbG9wZVR5cGVBZGp1c3RlZDogXCJBanVzdGF0XCIsXG5cdFx0c2xvcGVUeXBlRGVncmVlOiBcIkdyYWRcIixcblx0XHRzbG9wZVR5cGVQZXJjZW50UmlzZTogXCJQcm9jZW50Q3JlyJl0ZXJlXCIsXG5cdFx0c2xvcGVUeXBlU2NhbGVkOiBcIlNjYWxhdFwiLFxuXHRcdHN0cmV0Y2hUeXBlTWluTWF4OiBcIk1pbk1heFwiLFxuXHRcdHN0cmV0Y2hUeXBlUGVyY2VudE1pbk1heDogXCJQcm9jZW50TWluTWF4XCIsXG5cdFx0c3RyZXRjaFR5cGVTaWdtb2lkOiBcIlNpZ21vaWRcIixcblx0XHRzdHJldGNoVHlwZVN0ZERldjogXCJTdGREZXZcIixcblx0XHRoaWxsc2hhZGVUeXBlU2ltcGxlOiBcIlRyYWRpxaNpb25hbFwiLFxuXHRcdGhpbGxzaGFkZVR5cGVNdWx0aWRpcmVjdGlvbmFsOiBcIk11bHRpZGlyZWPIm2lvbmFsXCIsXG5cdFx0YmFuZENvbWJvQnlOYW1lczogXCJOdW1lIGJhbmTEg1wiLFxuXHRcdGJhbmRDb21ib0J5V2F2ZWxlbmd0aDogXCJMdW5naW1pIGRlIHVuZMSDIGRlIGJhbmTEg1wiLFxuXHRcdGJhbmRDb21ib0J5SURzOiBcIklELXVyaSBiYW5kxINcIixcblx0XHRtaXNzaW5nQmFuZEFjdGlvbkJlc3RNYXRjaDogXCJDZWEgbWFpIGJ1bsSDIHBvdHJpdmlyZVwiLFxuXHRcdG1pc3NpbmdCYW5kQWN0aW9uRmFpbDogXCJFyJllY1wiLFxuXHRcdHVuaXRUeXBlQ2Vsc2l1czogXCJDZWxzaXVzXCIsXG5cdFx0dW5pdFR5cGVDZW50aW1ldGVyczogXCJDZW50aW1ldHJpXCIsXG5cdFx0dW5pdFR5cGVEZWNpbWV0ZXJzOiBcIkRlY2ltZXRyaVwiLFxuXHRcdHVuaXRUeXBlRmFocmVuaGVpdDogXCJGYWhyZW5oZWl0XCIsXG5cdFx0dW5pdFR5cGVGZWV0OiBcIkZ0XCIsXG5cdFx0dW5pdFR5cGVGZWV0UGVyU2VjOiBcIlBpY2lvYXJlIHBlIHNlY3VuZMSDIChmdC9zKVwiLFxuXHRcdHVuaXRUeXBlSW5jaGVzOiBcIkluY2lcIixcblx0XHR1bml0VHlwZUtlbHZpbjogXCJLZWx2aW5cIixcblx0XHR1bml0VHlwZUtpbG9tZXRlcnM6IFwiS2lsb21ldHJpXCIsXG5cdFx0dW5pdFR5cGVLbXNQZXJIb3VyOiBcIktpbG9tZXRyaSBwZSBvcsSDIChrbS9oKVwiLFxuXHRcdHVuaXRUeXBlS25vdHM6IFwiTm9kdXJpIChrbilcIixcblx0XHR1bml0VHlwZU1ldGVyczogXCJNZXRyaVwiLFxuXHRcdHVuaXRUeXBlTWV0ZXJzUGVyU2VjOiBcIk1ldHJpIHBlIHNlY3VuZMSDIChtL3MpXCIsXG5cdFx0dW5pdFR5cGVNaWxlczogXCJNaWxlXCIsXG5cdFx0dW5pdFR5cGVNaWxlc1BlckhvdXI6IFwiTWlsZSBwZSBvcsSDIChtcGgpXCIsXG5cdFx0dW5pdFR5cGVNaWxsaW1ldGVyczogXCJNaWxpbWV0cmlcIixcblx0XHR1bml0VHlwZU5hdXRpY2FsTWlsZXM6IFwiTWlsZSBtYXJpbmVcIixcblx0XHR1bml0VHlwZVlhcmRzOiBcIllhcnppXCIsXG5cdFx0dW5pdFR5cGVEZWNpbWFsRGVncmVlczogXCJHcmFkZSB6ZWNpbWFsZVwiLFxuXHRcdHVuaXRUeXBlUG9pbnRzOiBcIlB1bmN0ZVwiLFxuXHRcdHVuaXRUeXBlVW5rbm93bjogXCJOZWN1bm9zY3V0XCIsXG5cdFx0dW5pdFR5cGVTcU1hcFVuaXRzOiBcIlVuaXTEg8WjaSBkZSBoYXJ0xIMgZHJlcHR1bmdoaXVsYXJlXCIsXG5cdFx0dW5pdFR5cGVTcU1pbGVzOiBcIk1pbGUgcMSDdHJhdGVcIixcblx0XHR1bml0VHlwZVNxS21zOiBcIktpbG9tZXRyaSBwxIN0cmHIm2lcIixcblx0XHR1bml0VHlwZUFjcmVzOiBcIkFjcmlcIixcblx0XHR1bml0VHlwZUhlY3RhcmVzOiBcIkhlY3RhcmVcIixcblx0XHR1bml0VHlwZVNxWWFyZHM6IFwiWWFyemkgcMSDdHJhyJtpXCIsXG5cdFx0dW5pdFR5cGVTcUZ0OiBcIkZ0IHDEg3RyYcibaVwiLFxuXHRcdHVuaXRUeXBlU3FJbmNoZXM6IFwiSW5jaSBwxIN0cmHIm2lcIixcblx0XHR1bml0VHlwZVNxTXRzOiBcIk1ldHJpIHDEg3RyYcibaVwiLFxuXHRcdHVuaXRUeXBlU3FDbXM6IFwiQ2VudGltZXRyaSBwxIN0cmHFo2lcIixcblx0XHR1bml0VHlwZVNxTW1zOiBcIk1pbGltZXRyaSBwxIN0cmHFo2lcIixcblx0XHRjZWxsc2l6ZVR5cGVGaXJzdDogXCJQcmltdWwgZGluXCIsXG5cdFx0Y2VsbHNpemVUeXBlTWluOiBcIk1pbiBhL2FsXCIsXG5cdFx0Y2VsbHNpemVUeXBlTWF4OiBcIk1heCBhL2FsXCIsXG5cdFx0Y2VsbHNpemVUeXBlTWVhbjogXCJNZWRpZSBhL2FsXCIsXG5cdFx0Y2VsbHNpemVUeXBlTGFzdDogXCJVbHRpbXVsIGRpblwiLFxuXHRcdGV4dGVudFR5cGVGaXJzdDogXCJQcmltdWwgZGluXCIsXG5cdFx0ZXh0ZW50VHlwZUludGVyc2VjdGlvbjogXCJJbnRlcnNlY8WjaWUgYS9hbFwiLFxuXHRcdGV4dGVudFR5cGVVbmlvbjogXCJSZXVuaXVuZSBhIC9hbFwiLFxuXHRcdGV4dGVudFR5cGVMYXN0OiBcIlVsdGltdWwgZGluXCIsXG5cdFx0bm9EYXRhSW50ZXJwcmV0QW55OiBcIlBvdHJpdmnFo2kgb3JpY2VcIixcblx0XHRub0RhdGFJbnRlcnByZXRBbGw6IFwiUG90cml2acWjaSB0b2F0ZVwiLFxuXHRcdGN1cnZhdHVyZVR5cGVTdGFuZGFyZDogXCJTdGFuZGFyZFwiLFxuXHRcdGN1cnZhdHVyZVR5cGVQcm9maWxlOiBcIlByb2ZpbFwiLFxuXHRcdGN1cnZhdHVyZVR5cGVQbGFuZm9ybTogXCJQcm9pZWPFo2llIGxhIHNvbFwiLFxuXHRcdGZpbHRlclR5cGVMaW5lRGV0ZWN0aW9uSG9yaXpvbnRhbDogXCJEZXRlY3RhcmVhIGxpbmllaSBvcml6b250YWzEg1wiLFxuXHRcdGZpbHRlclR5cGVMaW5lRGV0ZWN0aW9uVmVydGljYWw6IFwiRGV0ZWN0YXJlYSBsaW5pZWkgdmVydGljYWzEg1wiLFxuXHRcdGZpbHRlclR5cGVMaW5lRGV0ZWN0aW9uTGVmdERpYWdvbmFsOiBcIkRldGVjdGFyZWEgbGluaWVpIGRpYWdvbmFsYSBzdMOibmfEg1wiLFxuXHRcdGZpbHRlclR5cGVMaW5lRGV0ZWN0aW9uUmlnaHREaWFnb25hbDogXCJEZXRlY3RhcmVhIGxpbmllaSBkaWFnb25hbGEgZHJlYXB0xINcIixcblx0XHRmaWx0ZXJUeXBlR3JhZGllbnROb3J0aDogXCJHcmFkaWVudCBub3JkXCIsXG5cdFx0ZmlsdGVyVHlwZUdyYWRpZW50V2VzdDogXCJHcmFkaWVudCB2ZXN0XCIsXG5cdFx0ZmlsdGVyVHlwZUdyYWRpZW50RWFzdDogXCJHcmFkaWVudCBlc3RcIixcblx0XHRmaWx0ZXJUeXBlR3JhZGllbnRTb3V0aDogXCJHcmFkaWVudCBzdWRcIixcblx0XHRmaWx0ZXJUeXBlR3JhZGllbnROb3J0aEVhc3Q6IFwiR3JhZGllbnQgbm9yZCBlc3RcIixcblx0XHRmaWx0ZXJUeXBlR3JhZGllbnROb3J0aFdlc3Q6IFwiR3JhZGllbnQgbm9yZCB2ZXN0XCIsXG5cdFx0ZmlsdGVyVHlwZVNtb290aEFyaXRobWV0aWNNZWFuOiBcIk1lZGllIGFyaXRtZXRpY8SDIGxpbmlhcsSDXCIsXG5cdFx0ZmlsdGVyVHlwZVNtb290aGluZzN4MzogXCJMaW5pYXJpemFyZSAzeDNcIixcblx0XHRmaWx0ZXJUeXBlU21vb3RoaW5nNXg1OiBcIkxpbmlhcml6YXJlIDV4NVwiLFxuXHRcdGZpbHRlclR5cGVTaGFycGVuaW5nM3gzOiBcIkFjY2VudHVhcmUgM3gzXCIsXG5cdFx0ZmlsdGVyVHlwZVNoYXJwZW5pbmc1eDU6IFwiQWNjZW50dWFyZSA1eDVcIixcblx0XHRmaWx0ZXJUeXBlTGFwbGFjaWFuM3gzOiBcIkxhcGxhY2lhbiAzeDNcIixcblx0XHRmaWx0ZXJUeXBlTGFwbGFjaWFuNXg1OiBcIkxhcGxhY2lhbiA1eDVcIixcblx0XHRmaWx0ZXJUeXBlU29iZWxIb3Jpem9udGFsOiBcIlNvYmVsIG9yaXpvbnRhbFwiLFxuXHRcdGZpbHRlclR5cGVTb2JlbFZlcnRpY2FsOiBcIlNvYmVsIHZlcnRpY2FsXCIsXG5cdFx0ZmlsdGVyVHlwZVNoYXJwZW46IFwiQ3JlxZ90ZXJlIGNsYXJpdGF0ZVwiLFxuXHRcdGZpbHRlclR5cGVTaGFycGVuMjogXCJDcmXImXRlcmUgbWFpIG1hcmUgYSBjbGFyaXTEg8ibaWlcIixcblx0XHRmaWx0ZXJUeXBlUG9pbnRTcHJlYWQ6IFwiRXh0aW5kZXJlIHB1bmN0XCIsXG5cdFx0dXNlckRlZmluZWQ6IFwiRGVmaW5pdCBkZSB1dGlsaXphdG9yXCIsXG5cdFx0Q29udG91clR5cGVMaW5lczogXCJMaW5paSBjb250dXJcIixcblx0XHRDb250b3VyVHlwZUZpbGw6IFwiVW1wbGVyZSBjb250dXJcIixcblx0XHRDb250b3VyVHlwZVNtb290aE9ubHk6IFwiRG9hciBzdXByYWZhyJvEgyBuZXRlZMSDXCIsXG5cdFx0cmFzdGVyaXplRmlyc3Q6IFwiUHJpbWFcIixcblx0XHRyYXN0ZXJpemVMYXN0OiBcIlVsdGltYVwiLFxuXHRcdHJhc3Rlcml6ZVNtYWxsZXN0OiBcIkNlYSBtYWkgbWljxINcIixcblx0XHRyYXN0ZXJpemVMYXJnZXN0OiBcIkNlYSBtYWkgbWFyZVwiLFxuXHRcdHJlc2FtcGxpbmdUeXBlTmVhcmVzdDogXCJDZWwgbWFpIGFwcm9waWF0IHZlY2luXCIsXG5cdFx0cmVzYW1wbGluZ1R5cGVCaWxpbmVhcjogXCJJbnRlcnBvbGFyZSBiaWxpbmlhcsSDXCIsXG5cdFx0cmVzYW1wbGluZ1R5cGVDdWJpYzogXCJDb252b2x1yJtpZSBjdWJpY8SDXCIsXG5cdFx0cmVzYW1wbGluZ1R5cGVNYWpvcml0eTogXCJNYWpvcml0YXRlXCIsXG5cdFx0cmVzYW1wbGluZ1R5cGVCaWxpbmVhclBsdXM6IFwiSW50ZXJwb2xhcmUgYmlsaW5pYXLEgyBwbHVzXCIsXG5cdFx0cmVzYW1wbGluZ1R5cGVHYXVzczogXCJFc3RvbXBhcmUgZ2F1c3NpYW7Eg1wiLFxuXHRcdHJlc2FtcGxpbmdUeXBlR2F1c3NQbHVzOiBcIkVzdG9tcGFyZSBnYXVzc2lhbsSDIHBsdXNcIixcblx0XHRyZXNhbXBsaW5nVHlwZUF2ZXJhZ2U6IFwiTWVkaWVcIixcblx0XHRyZXNhbXBsaW5nVHlwZU1pbmltdW06IFwiTWluaW1cIixcblx0XHRyZXNhbXBsaW5nVHlwZU1heGltdW06IFwiTWF4aW1cIixcblx0XHRyZXNhbXBsaW5nVHlwZVZlY3RvckF2ZzogXCJNZWRpZSB2ZWN0b3JpYWzEg1wiLFxuXHRcdG1pbmltdW06IFwiTWluaW1cIixcblx0XHRtYXhpbXVtOiBcIk1heGltXCIsXG5cdFx0bWVhbjogXCJNZWRpZVwiLFxuXHRcdHN0ZERldmlhdGlvbjogXCJEZXZpYcWjaWUgc3RhbmRhcmRcIixcblx0XHR1dk1hZ0RpclR5cGVVVjogXCJVLVZcIixcblx0XHR1dk1hZ0RpclR5cGVNYWdEaXI6IFwiTWFnbml0dWRpbmUtRGlyZWPFo2llXCIsXG5cdFx0dW5rbm93bjogXCJOZWN1bm9zY3V0XCIsXG5cdFx0YW5nbGVSZWZTeXNHZW9ncmFwaGljOiBcIkdlb2dyYWZpY1wiLFxuXHRcdGFuZ2xlUmVmU3lzQXJpdGhtZXRpYzogXCJBcml0bWV0aWNcIixcblx0XHRpbnRlcnBvbGF0ZUlycmVndWxhckRhdGFOZWFyZXN0OiBcIkNlbCBtYWkgYXByb3BpYXQgdmVjaW5cIixcblx0XHRpbnRlcnBvbGF0ZUlycmVndWxhckRhdGFCaWxpbmVhcjogXCJCaWxpbmlhclwiLFxuXHRcdGludGVycG9sYXRlSXJyZWd1bGFyRGF0YVRpbm5pbmdMaW5lYXI6IFwiTGlwaXJlIGxpbmlhcltcIixcblx0XHRpbnRlcnBvbGF0ZUlycmVndWxhckRhdGFUaW5uaW5nTmF0dXJhbE5laWdoYm9yOiBcIlZlY2luIG5hdHVyYWxcIixcblx0XHRpbnRlcnBvbGF0ZUlycmVndWxhckRhdGFUaW5uaW5nSURXOiBcIkRpc3RhbsibYSBpbnZlcnPEgyBwb25kZXJhdMSDXCIsXG5cdFx0ZXNyaVJhc3RlclRocmVzaG9sZFR5cGVDb25zdGFudDogXCJDb25zdGFudMSDXCIsXG5cdFx0ZXNyaVJhc3RlclRocmVzaG9sZFR5cGVPdHN1OiBcIk90c3VcIixcblx0XHRlc3JpUmFzdGVyVGhyZXNob2xkVHlwZVRzYWk6IFwiVHNhaVwiLFxuXHRcdGVzcmlSYXN0ZXJUaHJlc2hvbGRUeXBlS2FwdXI6IFwiS2FwdXJcIixcblx0XHRlc3JpUmFzdGVyVGhyZXNob2xkVHlwZUtpdHRsZXI6IFwiS2l0dGxlclwiLFxuXHRcdGVzcmlSYXN0ZXJUaHJlc2hvbGRUeXBlUm9zaW46IFwiUm9zaW5cIixcblx0XHRhcmdTdGF0c1R5cGVNYXg6IFwiQXJnIE1heFwiLFxuXHRcdGFyZ1N0YXRzVHlwZU1pbjogXCJBcmcgTWluXCIsXG5cdFx0YXJnU3RhdHNUeXBlTWVkaWFuOiBcIkFyZyBNZWRpYW5cIixcblx0XHRhcmdTdGF0c1R5cGVEdXJhdGlvbjogXCJEdXJhdMSDXCIsXG5cdFx0YXJpdGhtZXRpY09wUGx1czogXCJQbHVzXCIsXG5cdFx0YXJpdGhtZXRpY09wTWludXM6IFwiTWludXNcIixcblx0XHRhcml0aG1ldGljT3BNdWx0aXBseTogXCLDjm5tdWzFo2lyZVwiLFxuXHRcdGFyaXRobWV0aWNPcERpdmlkZTogXCLDjm1wxINyxaNpcmVcIixcblx0XHRhcml0aG1ldGljT3BQb3dlcjogXCJQdXRlcmVcIixcblx0XHRhcml0aG1ldGljT3BNb2RlOiBcIk1vZFwiLFxuXHRcdGNsaXBUeXBlT3V0c2lkZTogXCJTZSBkZWN1cGVhesSDIMOubiBhZmFyxINcIixcblx0XHRjbGlwVHlwZUluc2lkZTogXCJTZSBkZWN1cGVhesSDIMOubsSDdW50cnVcIixcblx0XHR5ZXM6IFwiRGFcIixcblx0XHRubzogXCJOdVwiLFxuXHRcdGRlbnNpdGllczogXCJEZW5zaXTEg8WjaVwiLFxuXHRcdGV4cGVjdGVkQ291bnRzOiBcIk51bWVyZSBlc3RpbWF0ZVwiLFxuXHRcdHBsYW5hcjogXCJQbGFuYXJcIixcblx0XHRnZW9kZXNpYzogXCJHZW9kZXppY1wiLFxuXHRcdGVhY2hDZWxsOiBcIkZpZWNhcmUgY2VsdWzEg1wiLFxuXHRcdGVhY2hab25lOiBcIkZpZWNhcmUgem9uxINcIixcblx0XHRiZXN0U2luZ2xlOiBcIkNlbCBtYWkgYnVuIGVsZW1lbnQgdW5pY1wiLFxuXHRcdGFsbFNpZ2h0bGluZXM6IFwiVG9hdGUgcmF6ZWxlIHZpenVhbGVcIixcblx0XHRwZXJpbWV0ZXJTaWdodGxpbmVzOiBcIlJhemVsZSB2aXp1YWxlIGFsZSBwZXJpbWV0cnVsdWlcIixcblx0XHRmcmVxdWVuY3k6IFwiRnJlY3ZlbsWjxINcIixcblx0XHRvYnNlcnZlcnM6IFwiT2JzZXJ2YXRvcmlcIixcblx0XHRtYWpvcml0eTogXCJNYWpvcml0YXRlXCIsXG5cdFx0bWVkaWFuOiBcIk1lZGlhbsSDXCIsXG5cdFx0bWlub3JpdHk6IFwiTWlub3JpdGF0ZVwiLFxuXHRcdHBlcmNlbnRpbGU6IFwiUGVyY2VudGlsxINcIixcblx0XHRyYW5nZTogXCJJbnRlcnZhbFwiLFxuXHRcdHN1bTogXCJTdW3Eg1wiLFxuXHRcdHZhcmlldHk6IFwiVmFyaWV0YXRlXCIsXG5cdFx0bmR2aTogXCJORFZJXCIsXG5cdFx0c2F2aTogXCJTQVZJXCIsXG5cdFx0YmFuZEFyaXRobWV0aWNNZXRob2RUU0FWSTogXCJTQVZJIHRyYW5zZm9ybWF0XCIsXG5cdFx0YmFuZEFyaXRobWV0aWNNZXRob2RNU0FWSTogXCJTQVZJIG1vZGlmaWNhdFwiLFxuXHRcdGJhbmRBcml0aG1ldGljTWV0aG9kU3VsdGFuOiBcIkZvcm11bGEgbHVpIFN1bHRhblwiLFxuXHRcdGdlbWk6IFwiR0VNSVwiLFxuXHRcdHB2aTogXCJQVklcIixcblx0XHRndmk6IFwiR1ZJIChMYW5kc2F0IFRNKVwiLFxuXHRcdHZhcmk6IFwiVkFSSVwiLFxuXHRcdHNyOiBcIlNSXCIsXG5cdFx0Z25kdmk6IFwiR05EVklcIixcblx0XHRuZHZpcmU6IFwiTkRWSXJlXCIsXG5cdFx0c3JyZTogXCJTUnJlXCIsXG5cdFx0bXR2aTI6IFwiTVRWSTJcIixcblx0XHRydHZpQ29yZTogXCJSVFZJQ29yZVwiLFxuXHRcdGNpcmU6IFwiQ0lyZVwiLFxuXHRcdGNpZzogXCJDSWdcIixcblx0XHRuZHdpOiBcIk5EV0lcIixcblx0XHRldmk6IFwiRVZJXCIsXG5cdFx0aXJvbk94aWRlOiBcIk94aWQgZGUgZmllclwiLFxuXHRcdGZlcnJvdXNNaW5lcmFsczogXCJNaW5lcmFsZSBmZXJvYXNlXCIsXG5cdFx0Y2xheU1pbmVyYWxzOiBcIk1pbmVyYWxlIGRlIGFyZ2lsxINcIixcblx0XHR3bmR3aTogXCJXTkRXSVwiLFxuXHRcdGJhaTogXCJCQUlcIixcblx0XHRtbmR3aTogXCJNTkRXSVwiLFxuXHRcdG5icjogXCJOQlJcIixcblx0XHRuZGJpOiBcIk5EQklcIixcblx0XHRuZG1pOiBcIk5ETUlcIixcblx0XHRuZHNpOiBcIk5EU0lcIixcblx0XHRsb2NhbFNxdWFyZVJvb3Q6IFwiUsSDZMSDY2luxIMgcMSDdHJhdMSDXCIsXG5cdFx0bG9jYWxBQ29zOiBcIkFDb3NcIixcblx0XHRsb2NhbEFTaW46IFwiQVNpblwiLFxuXHRcdGxvY2FsQVRhbjogXCJBVGFuXCIsXG5cdFx0bG9jYWxBVGFuSDogXCJBVGFuSFwiLFxuXHRcdGxvY2FsQWJzOiBcIkFic1wiLFxuXHRcdGxvY2FsQml0d2lzZU5vdDogXCJCaXR3aXNlIE5vdFwiLFxuXHRcdGxvY2FsQm9vbGVhbk5vdDogXCJCb29sZWFuIE5vdFwiLFxuXHRcdGxvY2FsQ29zOiBcIkNvc1wiLFxuXHRcdGxvY2FsQ29zSDogXCJDb3NIXCIsXG5cdFx0bG9jYWxFeHA6IFwiRXhwXCIsXG5cdFx0bG9jYWxFeHAxMDogXCJFeHAxMFwiLFxuXHRcdGxvY2FsRXhwMjogXCJFeHAyXCIsXG5cdFx0bG9jYWxJbnQ6IFwiSW50XCIsXG5cdFx0bG9jYWxJc051bGw6IFwiRXN0ZSBudWxcIixcblx0XHRsb2NhbEZsb2F0OiBcIk1vYmlsXCIsXG5cdFx0bG9jYWxMbjogXCJMblwiLFxuXHRcdGxvY2FsTG9nMTA6IFwiTG9nMTBcIixcblx0XHRsb2NhbExvZzI6IFwiTG9nMlwiLFxuXHRcdGxvY2FsTmVnYXRlOiBcIkFudWxhcmVcIixcblx0XHRsb2NhbFJvdW5kRG93bjogXCJSb3R1bmppcmUgcHJpbiBsaXBzxINcIixcblx0XHRsb2NhbFJvdW5kVXA6IFwiUm90dW5qaXJlIHByaW4gYWTEg3VnYXJlXCIsXG5cdFx0bG9jYWxTaW46IFwiU2luXCIsXG5cdFx0bG9jYWxTaW5IOiBcIlNpbkhcIixcblx0XHRsb2NhbFRhbjogXCJUYW5cIixcblx0XHRsb2NhbFRhbkg6IFwiVGFuSFwiLFxuXHRcdGxvY2FsQUNvc0g6IFwiQUNvc0hcIixcblx0XHRsb2NhbEFTaW5IOiBcIkFTaW5IXCIsXG5cdFx0bG9jYWxQbHVzOiBcIlBsdXNcIixcblx0XHRsb2NhbE1pbnVzOiBcIk1pbnVzXCIsXG5cdFx0bG9jYWxUaW1lczogXCJUaW1waVwiLFxuXHRcdGxvY2FsUG93ZXI6IFwiUHV0ZXJlXCIsXG5cdFx0bG9jYWxCaXR3aXNlQW5kOiBcIkJpdHdpc2UgQW5kXCIsXG5cdFx0bG9jYWxCaXR3aXNlTGVmdFNoaWZ0OiBcIkJpdHdpc2UgTGVmdCBTaGlmdFwiLFxuXHRcdGxvY2FsQml0d2lzZU9yOiBcIkJpdHdpc2UgT3JcIixcblx0XHRsb2NhbEJpdHdpc2VSaWdodFNoaWZ0OiBcIkJpdHdpc2UgUmlnaHQgU2hpZnRcIixcblx0XHRsb2NhbEJpdHdpc2VYb3I6IFwiQml0d2lzZSBYb3JcIixcblx0XHRsb2NhbEJvb2xlYW5BbmQ6IFwiQm9vbGVhbiBBbmRcIixcblx0XHRsb2NhbEJvb2xlYW5PcjogXCJCb29sZWFuIE9yXCIsXG5cdFx0bG9jYWxCb29sZWFuWG9yOiBcIkJvb2xlYW4gWG9yXCIsXG5cdFx0bG9jYWxEaXZpZGU6IFwiw45tcMSDcsWjaXJlXCIsXG5cdFx0bG9jYWxFcXVhbFRvOiBcIkVnYWzEgyBjdVwiLFxuXHRcdGxvY2FsR3JlYXRlclRoYW46IFwiTWFpIG1hcmUgZGVjw6J0XCIsXG5cdFx0bG9jYWxHcmVhdGVyVGhhbkVxdWFsOiBcIk1haSBtYXJlIGRlY8OidCBlZ2FsXCIsXG5cdFx0bG9jYWxMZXNzVGhhbjogXCJNYWkgbWljIGRlY8OidFwiLFxuXHRcdGxvY2FsTGVzc1RoYW5FcXVhbDogXCJNYWkgbWljIGRlY8OidCBlZ2FsXCIsXG5cdFx0bG9jYWxNb2Q6IFwiTW9kXCIsXG5cdFx0bG9jYWxOb3RFcXVhbDogXCJOdSBlc3RlIGVnYWwgY3VcIixcblx0XHRsb2NhbEFUYW4yOiBcIkFUYW4yXCIsXG5cdFx0bG9jYWxTcXVhcmU6IFwiUMSDdHJhdFwiLFxuXHRcdGxvY2FsU2V0TnVsbDogXCJTZXRhcmUgbnVsxINcIixcblx0XHRyZW1hcERlZlR5cGVMaXN0OiBcIkxpc3TEg1wiLFxuXHRcdHJlbWFwRGVmVHlwZVRhYmxlOiBcIlRhYmVsXCIsXG5cdFx0cmVtYXBUYWJsZVR5cGVTaW1wbGU6IFwiU2ltcGx1XCIsXG5cdFx0cmVtYXBUYWJsZVR5cGVEeW5hbWljOiBcIkRpbmFtaWNcIixcblx0XHRyZW1hcFRhYmxlVHlwZVJlYXNzaWdubWVudDogXCJSZWFsb2NhcmVcIixcblx0XHRnZW9tQ29ycmVjdGlvbkJ5Q29uc3RaOiBcIlV0aWx6YXJlIGNvbnN0YW50xIMgWlwiLFxuXHRcdGdlb21Db3JyZWN0aW9uQnlERU06IFwiVXRpbGl6YXJlIERFTVwiLFxuXHRcdHJhZGFyQ2FsaWJCZXRhTm91Z2h0OiBcIlplcm8gYmV0YVwiLFxuXHRcdHJhZGFyQ2FsaWJTaWdtYU5vdWdodDogXCJaZXJvIHNpZ21hXCIsXG5cdFx0cmFkYXJDYWxpYkdhbW1hTm91Z2h0OiBcIlplcm8gZ2FtYVwiLFxuXHRcdHNwZWNrbGVGaWx0ZXJUeXBlTGVlOiBcIkZpbHRydSBMZWVcIixcblx0XHRzcGVja2xlRmlsdGVyVHlwZUVuaGFuY2VkTGVlOiBcIkZpbHRydSBMZWUgw65tYnVuxIN0xIPIm2l0XCIsXG5cdFx0c3BlY2tsZUZpbHRlclR5cGVGcm9zdDogXCJGaWx0cnUgRnJvc3RcIixcblx0XHRzcGVja2xlRmlsdGVyVHlwZUt1YW46IFwiRmlsdHJ1IEt1YW5cIixcblx0XHRzcGVja2xlTm9pc2VNb2RlbE11bDogXCJaZ29tb3QgbXVsdGlwbGljYXRpdlwiLFxuXHRcdHNwZWNrbGVOb2lzZU1vZGVsQWRkOiBcIlpnb21vdCBhZGnIm2lvbmFsXCIsXG5cdFx0c3BlY2tsZU5vaXNlTW9kZWxBZGRuTXVsOiBcIlpnb21vdCBhZGnIm2lvbmFsIMiZaSBtdWx0aXBsaWNhdGl2XCIsXG5cdFx0bW9zYWljT3BUeXBlRmlyc3Q6IFwiUHJpbXVsXCIsXG5cdFx0bW9zYWljT3BUeXBlTGFzdDogXCJVbHRpbXVsXCIsXG5cdFx0bW9zYWljT3BUeXBlTWluOiBcIk1pblwiLFxuXHRcdG1vc2FpY09wVHlwZU1heDogXCJNYXhcIixcblx0XHRtb3NhaWNPcFR5cGVNZWFuOiBcIk1lZGllXCIsXG5cdFx0bW9zYWljT3BUeXBlQmxlbmQ6IFwiQW1lc3RlY1wiLFxuXHRcdG1vc2FpY09wVHlwZVN1bTogXCJTdW3Eg1wiLFxuXHRcdGludGVnZXI6IFwiTnVtxINyIMOubnRyZWdcIixcblx0XHRyZnhEODogXCJEOFwiLFxuXHRcdHJmeE1GRDogXCJNRkRcIixcblx0XHRkaW5mOiBcIkRpbmZcIixcblx0XHR2ZXJ0aWNhbDogXCJWZXJ0aWNhbMSDXCIsXG5cdFx0aG9yaXpvbnRhbDogXCJPcml6b250YWzEg1wiLFxuXHRcdGxvY2FsQ2VsbFN0YXRpc3RpY3NNYWpvcml0eTogXCJNYWpvcml0YXRlXCIsXG5cdFx0bG9jYWxDZWxsU3RhdGlzdGljc01heDogXCJNYXhpbVwiLFxuXHRcdGxvY2FsQ2VsbFN0YXRpc3RpY3NNZWFuOiBcIk1lZGllXCIsXG5cdFx0bG9jYWxDZWxsU3RhdGlzdGljc01lZGlhbjogXCJNZWRpYW7Eg1wiLFxuXHRcdGxvY2FsQ2VsbFN0YXRpc3RpY3NNaW46IFwiTWluaW1cIixcblx0XHRsb2NhbENlbGxTdGF0aXN0aWNzTWlub3JpdHk6IFwiTWlub3JpdGF0ZVwiLFxuXHRcdGxvY2FsQ2VsbFN0YXRpc3RpY3NSYW5nZTogXCJJbnRlcnZhbFwiLFxuXHRcdGxvY2FsQ2VsbFN0YXRpc3RpY3NTdGREZXY6IFwiRGV2aWHIm2llIHN0YW5kYXJkXCIsXG5cdFx0bG9jYWxDZWxsU3RhdGlzdGljc1N1bTogXCJTdW3Eg1wiLFxuXHRcdGxvY2FsQ2VsbFN0YXRpc3RpY3NWYXJpZXR5OiBcIlZhcmlldGF0ZVwiLFxuXHRcdGxvY2FsQ2VsbFN0YXRpc3RpY3NNYWpvcml0eUlnbm9yZU5EOiBcIk1ham9yaXRhdGUgKElnbm9yYcibaSBOb0RhdGEpXCIsXG5cdFx0bG9jYWxDZWxsU3RhdGlzdGljc01heElnbm9yZU5EOiBcIk1heGltdW0gKElnbm9yYcibaSBOb0RhdGEpXCIsXG5cdFx0bG9jYWxDZWxsU3RhdGlzdGljc01lYW5JZ25vcmVORDogXCJNZWRpZSAoSWdub3JhyJtpIE5vRGF0YSlcIixcblx0XHRsb2NhbENlbGxTdGF0aXN0aWNzTWVkaWFuSWdub3JlTkQ6IFwiTWVkaWFuxIMgKElnbm9yYcibaSBOb0RhdGEpXCIsXG5cdFx0bG9jYWxDZWxsU3RhdGlzdGljc01pbklnbm9yZU5EOiBcIk1pbmltdW0gKElnbm9yYcibaSBOb0RhdGEpXCIsXG5cdFx0bG9jYWxDZWxsU3RhdGlzdGljc01pbm9yaXR5SWdub3JlTkQ6IFwiTWlub3JpdGF0ZSAoSWdub3JhyJtpIE5vRGF0YSlcIixcblx0XHRsb2NhbENlbGxTdGF0aXN0aWNzUmFuZ2VJZ25vcmVORDogXCJJbnRlcnZhbCAoSWdub3JhyJtpIE5vRGF0YSlcIixcblx0XHRsb2NhbENlbGxTdGF0aXN0aWNzU3RkRGV2SWdub3JlTkQ6IFwiQWJhdGVyZSBTdGFuZGFyZCAoSWdub3JhyJtpIE5vRGF0YSlcIixcblx0XHRsb2NhbENlbGxTdGF0aXN0aWNzU3VtSWdub3JlTkQ6IFwiU3VtxIMgKElnbm9yYcibaSBOb0RhdGEpXCIsXG5cdFx0bG9jYWxDZWxsU3RhdGlzdGljc1ZhcmlldHlJZ25vcmVORDogXCJWYXJpZXRhdGUgKElnbm9yYcibaSBOb0RhdGEpXCIsXG5cdFx0bG9jYWxDZWxsU3RhdGlzdGljc1R5cGVQZXJjZW50aWxlSWdub3JlTkQ6IFwiUHJvY2VudCAoSWdub3JhyJtpIEbEg3LEgyBEYXRlKVwiLFxuXHRcdGZyb21Tb3VyY2U6IFwiRGluIHN1cnPEg1wiLFxuXHRcdHRvU291cmNlOiBcIkPEg3RyZSBzdXJzxINcIixcblx0XHRjb2xvcnNwYWNlQ29udmVyc2lvblJnYlRvSHN2OiBcIlJHQiBjxIN0cmUgSFNWXCIsXG5cdFx0Y29sb3JzcGFjZUNvbnZlcnNpb25Ic3ZUb1JnYjogXCJIU1YgY8SDdHJlIFJHQlwiLFxuXHRcdHBhbnNoYXJwZW5UeXBlSUhTOiBcIklIU1wiLFxuXHRcdHBhbnNoYXJwZW5UeXBlQnJvdmV5OiBcIkJyb3ZleVwiLFxuXHRcdHBhbnNoYXJwZW5UeXBlRXNyaTogXCJFc3JpXCIsXG5cdFx0cGFuc2hhcnBlblR5cGVNZWFuOiBcIk1lZGllXCIsXG5cdFx0cGFuc2hhcnBlblR5cGVHcmFtU2NobWlkdDogXCJHcmFtLVNjaG1pZHRcIixcblx0XHRyZWN0YW5nbGVOZWlnaGJvcmhvb2Q6IFwiRHJlcHR1bmdoaVwiLFxuXHRcdGNpcmNsZU5laWdoYm9yaG9vZDogXCJDZXJjXCIsXG5cdFx0YW5udWx1c05laWdoYm9yaG9vZDogXCJJbmVsXCIsXG5cdFx0d2VkZ2VOZWlnaGJvcmhvb2Q6IFwiUGFuxINcIixcblx0XHRpcnJlZ3VsYXJOZWlnaGJvcmhvb2Q6IFwiTmVyZWd1bGF0XCIsXG5cdFx0d2VpZ2h0TmVpZ2hib3Job29kOiBcIkdyZXV0YXRlXCIsXG5cdFx0Zm91cjogXCJQYXRydVwiLFxuXHRcdGVpZ2h0OiBcIk9wdFwiLFxuXHRcdHdpdGhpbjogXCLDjm5cIixcblx0XHRjcm9zczogXCJDcnVjZVwiLFxuXHRcdGFkZExpbms6IFwiQWTEg3VnYXJlIGxlZ8SDdHVyxINcIixcblx0XHRub0xpbms6IFwiRsSDcsSDIExpbmtcIixcblx0XHR3ZWlnaHRlZE1lYW46IFwiTWVkaWUgcG9uZGVyYXTEg1wiLFxuXHRcdGxzOFFDQml0UGF0dGVybkNpcnJ1czogXCJMYW5kc2F0IDggQ2lycnVzXCIsXG5cdFx0bHM4UUNCaXRQYXR0ZXJuQ2xvdWQ6IFwiTGFuZHNhdCA4IE5vclwiLFxuXHRcdGxzOFFDQml0UGF0dGVybkNsb3VkU2hhZG93OiBcIkxhbmRzYXQgOCBOb3IgVW1icsSDXCIsXG5cdFx0bHM4UUNCaXRQYXR0ZXJuRGVzaWduYXRlZEZpbGw6IFwiTGFuZHNhdCA4IFVtcGxlcmUgZGVzZW1uYXTEg1wiLFxuXHRcdGxzOFFDQml0UGF0dGVybkRyb3BwZWRGcmFtZTogXCJMYW5kc2F0IDggQ2FkcnUgb21pc1wiLFxuXHRcdGxzOFFDQml0UGF0dGVyblNub3dJY2U6IFwiTGFuZHNhdCA4IFrEg3BhZMSDL0doZWHIm8SDXCIsXG5cdFx0bHM4UUNCaXRQYXR0ZXJuVGVycmFpbk9jY2x1c2lvbjogXCJMYW5kc2F0IDggT2NsdXppZSB0ZXJlblwiLFxuXHRcdGxzOFFDQml0UGF0dGVyblZlZ2V0YXRpb246IFwiTGFuZHNhdCA4IFZlZ2V0YcibaWVcIixcblx0XHRsczhRQ0JpdFBhdHRlcm5XYXRlcjogXCJMYW5kc2F0IDggQXDEg1wiLFxuXHRcdGRvd25TdHJlYW06IFwiw45uIGF2YWxcIixcblx0XHR1cFN0cmVhbTogXCLDjm4gYW1vbnRlXCIsXG5cdFx0c3RyYWhsZXI6IFwiU1RSQUhMRVJcIixcblx0XHRzaHJldmU6IFwiU0hSRVZFXCIsXG5cdFx0Y3VycmVudFNsaWNlOiBcIlNlY3RvciBhY3R1YWxcIixcblx0XHRhbGxTbGljZXM6IFwiVG9hdGUgc2VjdG9hcmVsZVwiLFxuXHRcdGV4cGFuZERpc3RhbmNlOiBcIkRJU1RBTsWixIJcIixcblx0XHRleHBhbmRNb3JwaG9sb2dpY2FsOiBcIk1PUkZPTE9HSUNcIixcblx0XHRzcGVjdHJhbFByb2ZpbGVGaWxlOiBcIlByb2ZpbCBzcGVjdHJhbFwiLFxuXHRcdHRyYWluaW5nRmVhdHVyZUZpbGU6IFwiT2JpZWN0IHNwYcibaWFsIHBlbnRydSBpbnN0cnVpcmVcIixcblx0XHRyYW5kb21EaXN0cmlidXRpb25UeXBlVW5pZm9ybTogXCJVbmlmb3JtxINcIixcblx0XHRyYW5kb21EaXN0cmlidXRpb25UeXBlVW5pZm9ybUludGVnZXI6IFwiTnVtxINyIMOubnRyZWdcIixcblx0XHRyYW5kb21EaXN0cmlidXRpb25UeXBlTm9ybWFsOiBcIk5vcm1hbFwiLFxuXHRcdHJhbmRvbURpc3RyaWJ1dGlvblR5cGVFeHBvbmVudGlhbDogXCJFeHBvbmVuxaNpYWxcIixcblx0XHRyYW5kb21EaXN0cmlidXRpb25UeXBlUG9pc3NvbjogXCJQb2lzc29uXCIsXG5cdFx0cmFuZG9tRGlzdHJpYnV0aW9uVHlwZUdhbW1hOiBcIkdhbW1hXCIsXG5cdFx0cmFuZG9tRGlzdHJpYnV0aW9uVHlwZUJpbm9taWFsOiBcIkJpbm9taWFsXCIsXG5cdFx0cmFuZG9tRGlzdHJpYnV0aW9uVHlwZUdlb21ldHJpYzogXCJab25lIGdlb21ldHJpY2VcIixcblx0XHRyYW5kb21EaXN0cmlidXRpb25UeXBlTmVnYXRpdmVCaW5vbWlhbDogXCJCaW5vbWlhbCBuZWdhdGl2XCIsXG5cdFx0cmFuZG9tR2VuZXJhdG9yVHlwZVN0YW5kYXJkQ1JhbmQ6IFwiQ2hlbmFyIEMgU3RhbmRhcmRcIixcblx0XHRyYW5kb21HZW5lcmF0b3JUeXBlQWxnb3JpdGhtQUNNNTk5OiBcIkFsZ29yaXRtIGNvbGVjdGF0IEFDTSA1OTlcIixcblx0XHRyYW5kb21HZW5lcmF0b3JUeXBlTWVyc2VubmVUd2lzdGVyOiBcIk1lcnNlbm5lIFR3aXN0ZXJcIixcblx0XHRzdW1OYW1lOiBcIlN1bcSDXCIsXG5cdFx0bWVkYWluTmFtZTogXCJNZWRpYW7Eg1wiLFxuXHRcdHRyZW5kTGluZWFyOiBcIkxpbmlhclwiLFxuXHRcdHRyZW5kSGFybW9uaWM6IFwiQXJtb25pY8SDXCIsXG5cdFx0dHJlbmRQb2x5bm9taWFsOiBcIlBvbGlub21pYWxcIixcblx0XHR0cmVuZE1hbm5LZW5kYWxsOiBcIk1hbm4tS2VuZGFsbFwiLFxuXHRcdHRyZW5kU2Vhc29uYWxLZW5kYWxsOiBcIlNlem9uaWVyIEtlbmRhbGxcIixcblx0XHRkaW1lbnNpb25CeVZhbHVlOiBcIkR1cMSDIHZhbG9hcmVcIixcblx0XHRkaW1lbnNpb25CeUludGVydmFsOiBcIkR1cMSDIGludGVydmFsXCIsXG5cdFx0bWRpbURlZlR5cGVBbGw6IFwiVG/Im2lcIixcblx0XHRtZGltRGVmVHlwZUJ5VmFsdWVzOiBcIkR1cMSDIHZhbG9yaVwiLFxuXHRcdG1kaW1EZWZUeXBlQnlSYW5nZXM6IFwiRHVwxIMgaW50ZXJ2YWxlXCIsXG5cdFx0bWRpbURlZlR5cGVCeUl0ZXJhdGlvbjogXCJEdXDEgyBpdGVyYcibaWVcIixcblx0XHRtZGltRGVmVHlwZUJ5SW50ZXJ2YWw6IFwiRHVwxIMgaW50ZXJ2YWxcIixcblx0XHRtZGltRGVmVHlwZUJ5VGFyZ2V0UmFzdGVyOiBcIsOObiBmdW5jyJtpZSBkZSByYXN0ZXJ1bCDIm2ludMSDXCIsXG5cdFx0ZXNyaVRpbWVVbml0c0hvdXJzOiBcIk9yZVwiLFxuXHRcdGVzcmlUaW1lVW5pdHNEYXlzOiBcIlppbGVcIixcblx0XHRlc3JpVGltZVVuaXRzV2Vla3M6IFwiU8SDcHTEg23Dom5pXCIsXG5cdFx0ZXNyaVRpbWVVbml0c01vbnRoczogXCJMdW5pXCIsXG5cdFx0ZXNyaVRpbWVVbml0c1llYXJzOiBcIkFuaVwiLFxuXHRcdGVzcmlUaW1lSW50ZXJ2YWxLZXl3b3JkSG91cmx5OiBcIsOObiBmaWVjYXJlIG9yxINcIixcblx0XHRlc3JpVGltZUludGVydmFsS2V5d29yZERhaWx5OiBcIlppbG5pY1wiLFxuXHRcdGVzcmlUaW1lSW50ZXJ2YWxLZXl3b3JkV2Vla2x5OiBcIlPEg3B0xINtw6JuYWxcIixcblx0XHRlc3JpVGltZUludGVydmFsS2V5d29yZERla2FkbHk6IFwiTyBkYXTEgyBsYSAxMCB6aWxlXCIsXG5cdFx0ZXNyaVRpbWVJbnRlcnZhbEtleXdvcmRQZW50YWRseTogXCJPIGRhdMSDIGxhIDUgemlsZVwiLFxuXHRcdGVzcmlUaW1lSW50ZXJ2YWxLZXl3b3JkTW9udGhseTogXCJMdW5hclwiLFxuXHRcdGVzcmlUaW1lSW50ZXJ2YWxLZXl3b3JkUXVhcnRlcmx5OiBcIlRyaW1lc3RyaWFsXCIsXG5cdFx0ZXNyaVRpbWVJbnRlcnZhbEtleXdvcmRZZWFybHk6IFwiQW51YWxcIixcblx0XHRlc3JpVGltZUludGVydmFsS2V5d29yZFJlY3VycmluZ0RhaWx5OiBcIlJlY3VyZW7Im8SDIHppbG5pY8SDXCIsXG5cdFx0ZXNyaVRpbWVJbnRlcnZhbEtleXdvcmRSZWN1cnJpbmdXZWVrbHk6IFwiUmVjdXJlbsibxIMgc8SDcHTEg23Dom5hbMSDXCIsXG5cdFx0ZXNyaVRpbWVJbnRlcnZhbEtleXdvcmRSZWN1cnJpbmdNb250aGx5OiBcIlJlY3VyZW7Im8SDIGx1bmFyxINcIixcblx0XHRlc3JpVGltZUludGVydmFsS2V5d29yZFJlY3VycmluZ1F1YXJ0ZXJseTogXCJSZWN1cmVuyJvEgyB0cmltZXN0cmlhbMSDXCIsXG5cdFx0YWdnRGVmVHlwZUFsbDogXCJUb3R1bFwiLFxuXHRcdGFnZ0RlZlR5cGVJbnRlcnZhbEtleXdvcmQ6IFwiSW50ZXJ2YWwgY3V2aW50ZSBjaGVpZVwiLFxuXHRcdGFnZ0RlZlR5cGVJbnRlcnZhbFZhbHVlOiBcIkludGVydmFsIHZhbG9yaVwiLFxuXHRcdGFnZ0RlZlR5cGVJbnRlcnZhbFJhbmdlczogXCJJbnRlcnZhbCBkb21lbmlpXCIsXG5cdFx0bGF0ZXN0Q2hhbmdlOiBcIkRhdGEgdWx0aW1laSBtb2RpZmljxINyaVwiLFxuXHRcdGVhcmxpZXN0Q2hhbmdlOiBcIkRhdGEgcHJpbWVpIG1vZGlmaWPEg3JpXCIsXG5cdFx0bGFyZ2VzdENoYW5nZTogXCJEYXRhIGNlbGVpIG1haSBtYXJpIG1vZGlmaWPEg3JpXCIsXG5cdFx0bnVtYmVyT2ZDaGFuZ2VzOiBcIk51bcSDciBkZSBtb2RpZmljxINyaVwiLFxuXHRcdGxvbmdlc3RDaGFuZ2U6IFwiVGltcHVsIGNlbGVpIG1haSBsdW5naSBzY2hpbWLEg3JpXCIsXG5cdFx0c2hvcnRlc3RDaGFuZ2U6IFwiVGltcHVsIGNlbGVpIG1haSBzY3VydGUgc2NoaW1ixINyaVwiLFxuXHRcdGZhc3Rlc3RDaGFuZ2U6IFwiVGltcHVsIGNlbGVpIG1haSByYXBpZGUgc2NoaW1ixINyaVwiLFxuXHRcdHNsb3dlc3RDaGFuZ2U6IFwiVGltcHVsIGNlbGVpIG1haSBsZW50ZSBzY2hpbWLEg3JpXCIsXG5cdFx0YWxsQ2hhbmdlczogXCJUb3R1bFwiLFxuXHRcdGluY3JlYXNlQ2hhbmdlczogXCJDcmXImXRlcmVcIixcblx0XHRkZWNyZWFzZUNoYW5nZXM6IFwiU2PEg2RlcmVcIixcblx0XHRzZWdtZW50QmVnaW5uaW5nOiBcIsOObmNlcHV0dWwgc2VnbWVudHVsdWlcIixcblx0XHRzZWdtZW50RW5kOiBcIlNmw6JyyJlpdHVsIHNlZ21lbnR1bHVpXCIsXG5cdFx0ZXNyaUNvbXB1dGVDaGFuZ2VNZXRob2REaWZmZXJlbmNlOiBcIkRpZmVyZW7Im8SDXCIsXG5cdFx0ZXNyaUNvbXB1dGVDaGFuZ2VNZXRob2RSZWxhdGl2ZURpZmZlcmVuY2U6IFwiRGlmZXJlbsibxIMgcmVsYXRpdsSDXCIsXG5cdFx0ZXNyaUNvbXB1dGVDaGFuZ2VNZXRob2RDYXRlZ29yaWNhbDogXCJEaWZlcmVuyJvEgyBkZSBjYXRlZ29yaWlcIixcblx0XHRlc3JpQ29tcHV0ZUNoYW5nZU1ldGhvZE11bHRpc3BlY3RyYWxFdWNsaWRlYW5EaXN0YW5jZTogXCJEaXN0YW7Im8SDIGV1Y2xpZGlhbsSDIHNwZWN0cmFsxINcIixcblx0XHRlc3JpQ29tcHV0ZUNoYW5nZU1ldGhvZE11bHRpc3BlY3RyYWxBbmd1bGFyRGlmZmVyZW5jZTogXCJEaXN0YW7Im8SDIGRlIHVuZ2hpIHNwZWN0cmFsXCIsXG5cdFx0ZXNyaUNvbXB1dGVDaGFuZ2VNZXRob2RNdWx0aXNwZWN0cmFsQXhpc1dpdGhCaWdnZXN0Q2hhbmdlOiBcIkJhbmRhIGN1IGNlYSBtYWkgbWFyZSBzY2hpbWJhcmVcIixcblx0XHRlc3JpQ29tcHV0ZUNoYW5nZUtlZXBBbGw6IFwiUMSDc3RyYcibaSB0b3RcIixcblx0XHRlc3JpQ29tcHV0ZUNoYW5nZUtlZXBDaGFuZ2VkT25seTogXCJQxINzdHJhyJtpIGRvYXIgcGl4ZWxpaSBtb2RpZmljYcibaVwiLFxuXHRcdGVzcmlDb21wdXRlQ2hhbmdlS2VlcFVuY2hhbmdlZE9ubHk6IFwiUMSDc3RyYcibaSBkb2FyIHBpeGVsaWkgbmVtb2RpZmljYcibaVwiLFxuXHRcdGVzcmlDb21wdXRlQ2hhbmdlVXNlQ29sb3JBdmVyYWdlOiBcIkN1bG9yaWkgbWVkaWkgZGUgbGEgyJlpIHDDom7EgyBsYVwiLFxuXHRcdGVzcmlDb21wdXRlQ2hhbmdlVXNlQ29sb3JGcm9tOiBcIkN1bG9yaSBkZSB1dGlsaXphcmUgZGUgbGFcIixcblx0XHRlc3JpQ29tcHV0ZUNoYW5nZVVzZUNvbG9yVG86IFwiQ3Vsb3JpIGRlIHV0aWxpemFyZSBww6JuxIMgbGFcIixcblx0XHRmYWN0b3JGdW5jdGlvbkJpbmFyeTogXCJCaW5hclwiLFxuXHRcdGZhY3RvckZ1bmN0aW9uRm9yd2FyZDogXCLDjm5haW50ZVwiLFxuXHRcdGZhY3RvckZ1bmN0aW9uTGluZWFyOiBcIkxpbmlhclwiLFxuXHRcdGZhY3RvckZ1bmN0aW9uSW52TGluZWFyOiBcIkxpbmlhciBpbnZlcnNcIixcblx0XHRmYWN0b3JGdW5jdGlvblRhYmxlOiBcIlRhYmVsXCIsXG5cdFx0ZmFjdG9yRnVuY3Rpb25TeW1MaW5lYXI6IFwiTGluaWFyIHNpbWV0cmljXCIsXG5cdFx0ZmFjdG9yRnVuY3Rpb25TeW1JbnZMaW5lYXI6IFwiTGluaWFyIGludmVycyBzaW1ldHJpY1wiLFxuXHRcdGZhY3RvckZ1bmN0aW9uQ29zOiBcIkNvc2ludXNcIixcblx0XHRmYWN0b3JGdW5jdGlvblNlYzogXCJTZWNhbnTEg1wiLFxuXHRcdGZhY3RvckZ1bmN0aW9uQ29zU2VjOiBcIlNlY2FudGEgY29zaW51c3VsdWlcIixcblx0XHRmYWN0b3JGdW5jdGlvblNlY0NvczogXCJDb3NpbnVzdWwgc2VjYW50ZWlcIixcblx0XHRub1NvcnQ6IFwiTnUgc29ydGHIm2lcIixcblx0XHRhc2NlbmQ6IFwiQ3Jlc2PEg3RvclwiLFxuXHRcdGRlc2NlbmQ6IFwiRGVzY3Jlc2PEg3RvclwiLFxuXHRcdGF1dG9EZXRlY3Q6IFwiRGV0ZWN0YXJlIGF1dG9tYXTEg1wiLFxuXHRcdG5lYXJlc3Q6IFwiQ2VsIG1haSBhcHJvcGlhdFwiLFxuXHRcdGxpbmVhcjogXCJMaW5pYXJcIixcblx0XHRlc3JpTW9udGhKYW51YXJ5OiBcIklhbnVhcmllXCIsXG5cdFx0ZXNyaU1vbnRoRmVicnVhcnk6IFwiRmVicnVhcmllXCIsXG5cdFx0ZXNyaU1vbnRoTWFyY2g6IFwiTWFydGllXCIsXG5cdFx0ZXNyaU1vbnRoQXByaWw6IFwiQXByaWxpZVwiLFxuXHRcdGVzcmlNb250aE1heTogXCJNYWlcIixcblx0XHRlc3JpTW9udGhKdW5lOiBcIkl1bmllXCIsXG5cdFx0ZXNyaU1vbnRoSnVseTogXCJJdWxpZVwiLFxuXHRcdGVzcmlNb250aEF1Z3VzdDogXCJBdWd1c3RcIixcblx0XHRlc3JpTW9udGhTZXB0ZW1iZXI6IFwiU2VwdGVtYnJpZVwiLFxuXHRcdGVzcmlNb250aE9jdG9iZXI6IFwiT2N0b21icmllXCIsXG5cdFx0ZXNyaU1vbnRoTm92ZW1iZXI6IFwiTm9pZW1icmllXCIsXG5cdFx0ZXNyaU1vbnRoRGVjZW1iZXI6IFwiRGVjZW1icmllXCIsXG5cdFx0ZGltZW5zaW9uYWxNb3ZpbmdJZ25vcmVOb0RhdGE6IFwiRGF0ZVwiLFxuXHRcdGRpbWVuc2lvbmFsTW92aW5nUHJvcGFnYXRlTm9EYXRhOiBcIk5vRGF0YVwiLFxuXHRcdGRpbWVuc2lvbmFsTW92aW5nRmlsbE9ubHlOb0RhdGE6IFwiQ29tcGxldGHIm2kgY8OibXB1cmlsZSBmxINyxIMgZGF0ZVwiLFxuXHRcdGNpcmN1bGFyTWVhbjogXCJNZWRpZSBjaXJjdWxhcsSDXCIsXG5cdFx0Y2lyY3VsYXJOYW1lOiBcIkNpcmN1bGFyxINcIixcblx0XHRhcml0aG1ldGljTmFtZTogXCJBcml0bWV0aWNcIixcblx0XHRzbG9wZU5hbWU6IFwiUGFudMSDXCIsXG5cdFx0YXNwZWN0TmFtZTogXCJBc3BlY3RcIixcblx0XHRtZWFuQ3VydmF0dXJlOiBcIkN1cmJ1csSDIG1lZGllXCIsXG5cdFx0cHJvZmlsZUN1cnZhdHVyZTogXCJDdXJidXLEgyBkZSBwcm9maWwgKGxpbmllIGRlIHBhbnTEgyBub3JtYWzEgylcIixcblx0XHR0YW5nZW50aWFsQ3VydmF0dXJlOiBcIkN1cmJ1csSDIHRhbmdlbsibaWFsxIMgKGNvbnR1ciBub3JtYWwpXCIsXG5cdFx0cGxhbkN1cnZhdHVyZTogXCJDdXJidXLEgyBwbGFuxIMgKGNvbnR1ciBwcm9pZWN0YXQpXCIsXG5cdFx0Y29udG91ckdlb2Rlc2ljVG9yc2lvbjogXCJUb3JzaXVuZSBnZW9kZXppY8SDIGRlIGNvbnR1clwiLFxuXHRcdGdhdXNzaWFuQ3VydmF0dXJlOiBcIkN1cmJ1csSDIGdhdXNzaWFuxINcIixcblx0XHRjYXNvcmF0aUN1cnZhdHVyZTogXCJDdXJidXJhIGx1aSBDYXNvcmF0aVwiLFxuXHRcdGxvY2FsU3VyZmFjZVR5cGVRdWFkcmF0aWM6IFwiQ3VhZHJhdGljxINcIixcblx0XHRsb2NhbFN1cmZhY2VUeXBlQmlxdWFkcmF0aWM6IFwiQmljdWFkcmF0aWPEg1wiLFxuXHRcdHRocmVzaG9sZE5vVGhyZXNob2xkOiBcIkbEg3LEgyBwcmFnXCIsXG5cdFx0dGhyZXNob2xkUGVyY2VudExlYXN0Q29zdDogXCJQcm9jZW50IGRpbiBjb3N0dWwgY2VsIG1haSBzY8SDenV0XCIsXG5cdFx0dGhyZXNob2xkQWNjdW11bGF0aXZlQ29zdDogXCJDb3N0IGFjdW11bGF0aXZcIixcblx0XHRjbHJtYXBUeXBlSGlsbHNoYWRlOiBcIkhpbGxzaGFkZVwiXG5cdH0sXG5cdGNhdGVnb3J5TGFiZWxzOiB7XG5cdFx0c291cmNlQ2hhcmFjdGVyaXN0aWNzOiBcIkNhcmFjdGVyaXN0aWNpIHN1cnPEg1wiLFxuXHRcdG5laWdoYm9yaG9vZFNldHRpbmdzOiBcIlNldMSDcmkgdmVjaW7Eg3RhdGVcIixcblx0XHRzdGF0aXN0aWNzOiBcIlN0YXRpc3RpY8SDXCIsXG5cdFx0Z2FtbWE6IFwiR2FtbWFcIixcblx0XHR2aWV3c2hlZFBhcmFtZXRlcnM6IFwiUGFyZW1ldHJpaSB2aWV3c2hlZFwiLFxuXHRcdG9ic2VydmVyUGFyYW1ldGVyczogXCJQYXJhbWV0cmlpIG9ic2VydmF0b3JcIixcblx0XHRpcnJlZ3VsYXJEYXRhSW50ZXJwb2xhdGlvbjogXCJJbnRlcnBvbGFyZWEgbmVyZWd1bGF0xIMgYSBkYXRlbG9yXCIsXG5cdFx0bW9kZWxTdGF0aXN0aWNzOiBcIlN0YXRpc3RpY2kgZGUgbW9kZWxcIixcblx0XHRhZ2dyZWdhdGlvbkRlZjogXCJEZWZpbmnIm2llIGRlIGFncmVnYXJlXCIsXG5cdFx0ZmlsdGVyQnlBdHRyaWJ1dGVzOiBcIkZpbHRyYXJlIGR1cMSDIGF0cmlidXRlXCIsXG5cdFx0cGVyY2VudGlsZU5hbWU6IFwiUGVyY2VudGlsxINcIixcblx0XHRyYXN0ZXJJbmZvOiBcIkluZm9ybWHIm2lpIGRlc3ByZSByYXN0ZXJcIixcblx0XHRleHRlbnQ6IFwiRXh0aW5kZXJlXCIsXG5cdFx0c3BhdGlhbFJlZmVyZW5jZTogXCJSZWZlcmluxaPEgyBzcGHFo2lhbMSDXCJcblx0fSxcblx0b3V0cHV0UmFzdGVySGVscFRleHRzOiB7XG5cdFx0b3V0cHV0TmFtZTogXCI8cD5OdW1lbGUgc3RyYXR1bHVpIHRlbWF0aWMgY2FyZSB2YSBmaSBjcmVhdCDImWkgYWTEg3VnYXQgcGUgaGFydMSDLjwvcD5cIixcblx0XHRyZXN1bHRUeXBlOiBcIjxwPlRpcHVsIGRlIGllyJlpcmUgY2FyZSB2YSBmaSBjcmVhdMSDLiBJZciZaXJpbGUgcG90IGZpIHN0cmF0dXJpIHRlbWF0aWNlIGRlIGltYWdpbmkgc2F0ZWxpdGFyZSBjdSBzdHJ1Y3R1csSDIHRpbGUgc2F1IHN0cmF0dXJpIHRlbWF0aWNlIGRlIGltYWdpbmkgc2F0ZWxpdGFyZSBkaW5hbWljZS48L3A+XCIsXG5cdFx0c2F2ZVJlc3VsdEluOiBcIjxwPk51bWVsZSBmb2xkZXJ1bHVpIGRpbiA8Yj5SZXN1cnNlbGUgbWVsZTwvYj4gw65uIGNhcmUgdmEgZmkgc2FsdmF0IHJlenVsdGF0dWwuPC9wPlwiXG5cdH0sXG5cdGFuYWx5c2lzRW52aXJvbm1lbnRzSGVscFRleHRzOiB7XG5cdFx0ZGVzY3JpcHRpb246IFwiPHA+U2V0xINyaWxlIG1lZGl1bHVpIHBlbnRydSBhbmFsaXphIMOubiBNYXAgVmlld2VyLiA8L3A+XCIsXG5cdFx0b3V0U1I6IFwiPHA+U3BlY2lmaWPEgyBzaXN0ZW11bCBkZSBjb29yZG9uYXRlIHBlbnRydSBhbmFsaXrEgyDImWkgc3RyYXR1bCB0ZW1hdGljIGRlIHJlenVsdGF0ZS48L3A+XCIsXG5cdFx0ZXh0ZW50OiBcIjxwPlNwZWNpZmljxIMgem9uYSBkZSB1dGlsaXphdCBwZW50cnUgYW5hbGl6xIMuPC9wPlwiLFxuXHRcdHNuYXBSYXN0ZXI6IFwiPHA+U2UgcmVnbGVhesSDIGV4dGluZGVyZWEgaWXImWlyaWkgcGVudHJ1IGEgc2UgcG90cml2aSBjdSBhbGluaWVyZWEgY2VsdWxlbG9yIHN0cmF0dWx1aSB0ZW1hdGljIHNwZWNpZmljYXQgZGUgZml4YXJlIHJhc3Rlci48L3A+XCIsXG5cdFx0Y2VsbFNpemU6IFwiPHA+U3BlY2lmaWPEgyBkaW1lbnNpdW5lYSBjZWx1bGVpIHNhdSByZXpvbHXIm2lhIGNhcmUgdmEgZmkgdXRpbGl6YXTEgyBwZW50cnUgYW5hbGl6xIMgyJlpIHBlbnRydSBhIGNyZWEgc3RyYXR1bCB0ZW1hdGljIGRlIHJhc3RlciBkZSBpZciZaXJlLjwvcD5cIixcblx0XHRtYXNrOiBcIjxwPlNwZWNpZmljxIMgdW4gc3RyYXQgdGVtYXRpYyBtYXNjxIMsIMOubiBjYXJlIGRvYXIgY2VsdWxlbGUgY2FyZSBpbnRyxIMgw65uIHpvbmEgbcSDyJl0aWkgdm9yIGZpIGZvbG9zaXRlIHBlbnRydSBhbmFsaXrEgy48L3A+XCIsXG5cdFx0cmVzYW1wbGluZ01ldGhvZDogXCI8cD5TcGVjaWZpY8SDIG1vZHVsIGRlIGludGVycG9sYXJlIGEgdmFsb3JpbG9yIHBpeGVsaWxvciBjw6JuZCByYXN0ZXJlbGUgZGUgaW50cmFyZSDImWkgZGUgaWXImWlyZSBudSBzZSBhbGluaWF6xIMuPC9wPlwiXG5cdH0sXG5cdG1haW5HZW5TdHJpbmdzOiB7XG5cdFx0dW5zdXBwb3J0ZWREYXRhVHlwZTogXCJUaXAgbmVhY2NlcHRhdFwiLFxuXHRcdGN1cnJlbnRseVVuc3VwcG9ydGVkOiBcIiBVbiBlZGl0b3IgaW1wbGljaXQgcGVudHJ1ICR7bWlzc2luZ1R5cGV9IGVzdGUgw65uIGHImXRlcHRhcmUsIGRhciB2YSBzb3NpIMOubiBjdXLDom5kLiBDYXNldMSDIGRlIHRleHQgcGVudHJ1IHN1YnN0aXR1ZW50IHRlbXBvcmFyIHBlbnRydSBzcGVjaWZpY2FyZWEgaW50csSDcmlsb3IgYmF6YXRlIHBlIMiZaXJ1cmkuXCIsXG5cdFx0dW5zdXBwb3J0ZWRPdmVycmlkZVdhcm5pbmc6IFwiTyBjb21wb25lbnTEgyBkZSBlZGl0b3IgZGUgc3VwcmFzY3JpZXJlIGNhcmUgZnVybml6ZWF6xIMgdW4gbWFpIGJ1biBVWCBwZW50cnUgbHVjcnVsIGN1IHVybcSDdG9ydWwoaSkgcGFyYW1ldHJ1KGkpIGVzdGUgw65uIGHImXRlcHRhcmUsIGRhciB2YSBzb3NpIMOubiBjdXLDom5kOlwiLFxuXHRcdG92ZXJyaWRlV2lkZ2V0TWlzc2luZzogXCJDb21wb25lbnRlIGVkaXRvciBzdXByYXNjcmllcmUgbGlwc8SDIVwiLFxuXHRcdHVpSW5jb21wbGV0ZTogXCJUcmltaXRlcmVhIGx1Y3LEg3JpaSBudSBhIHJldciZaXQuIEZ1bmPIm2lhIG51IHBvYXRlIGZpIGV4ZWN1dGF0xIMgcGVudHJ1IGPEgyB1bmVsZSBkaW50cmUgY8OibXB1cmlsZSBvYmxpZ2F0b3JpaSBzdW50IGluY29tcGxldGUgc2F1IGxpcHNlc2MgZGluIFVJLlwiLFxuXHRcdGNvdW50OiBcIk51bcSDclwiLFxuXHRcdHNlbGVjdFZhcmlhYmxlczogXCJTZWxlY3RhcmUgdmFyaWFiaWxlXCIsXG5cdFx0c2VsZWN0RmVhdHVyZTogXCJTZWxlY3RhcmVhIHVudWkgc3RyYXQgdGVtYXRpYyBkZSBvYmllY3Qgc3BhyJtpYWxcIixcblx0XHRncmVhdGVyVGhhbkVycm9yTWVzc2FnZTogXCJOdW3Eg3J1bCBkZSBpbnRyYXJlIHRyZWJ1aWUgc8SDIGZpZSBtYWkgbWFyZSBkZWPDonQgJHttaW59XCIsXG5cdFx0bGVzc2VyVGhhbkVycm9yTWVzc2FnZTogXCJOdW3Eg3J1bCBkZSBpbnRyYXJlIHRyZWJ1aWUgc8SDIGZpZSBtYWkgbWljIGRlY8OidCAke21heH1cIixcblx0XHRncmVhdGVyVGhhbk9yRXF1YWxFcnJvck1lc3NhZ2U6IFwiTnVtxINydWwgZGUgaW50cmFyZSB0cmVidWllIHPEgyBmaWUgbWFpIG1hcmUgc2F1IGVnYWwgY3UgJHttaW59XCIsXG5cdFx0bGVzc2VyVGhhbk9yRXF1YWxFcnJvck1lc3NhZ2U6IFwiTnVtxINydWwgZGUgaW50cmFyZSB0cmVidWllIHPEgyBmaWUgbWFpIG1pYyBzYXUgZWdhbCBjdSAke21heH1cIixcblx0XHRhbGxvd1NjYWxhcjogXCJTZWxlY3RhyJtpIHVuIHN0cmF0IHRlbWF0aWMgc2F1IGludHJvZHVjZcibaSBvIGNvbnN0YW50xINcIixcblx0XHRzZWxlY3RGaWVsZDogXCJTZWxlY3RhcmUgY8OibXBcIixcblx0XHRwYXJhbWV0ZXJSZXF1aXJlZDogXCJBY2VzdCBwYXJhbWV0cnUgZXN0ZSBvYmxpZ2F0b3JpdS5cIixcblx0XHRlbnRlckFWYWx1ZTogXCJJbnRyb2R1Y2XIm2kgbyB2YWxvYXJlLi4uXCIsXG5cdFx0aW52YWxpZElucHV0OiBcIlZhbG9hcmVhIGludHJvZHVzxIMgbnUgZXN0ZSB2YWxpZMSDLlwiLFxuXHRcdGl0ZW1Ob3RGb3VuZDogXCJFbGVtZW50dWwgbnUgZXhpc3TEgyBzYXUgZXN0ZSBpbmFjY2VzaWJpbC5cIixcblx0XHRpdGVtUGVybWlzc2lvbkRlbmllZDogXCJOdSBhdmXIm2kgcGVybWlzaXVuaSBkZSBhY2Nlc2FyZSBhIGFjZXN0dWkgZWxlbWVudC5cIixcblx0XHRsYXllck5vdEF2YWlsYWJsZTogXCJOdSBzLWEgcmV1yJlpdCDDrm5jxINyY2FyZWEgc3RyYXR1bHVpIHRlbWF0aWMgJHtsYXllck5hbWV9LlwiLFxuXHRcdG11bHRpcGxlTGF5ZXJzTm90QXZhaWxhYmxlOiBcIk51IHMtYSByZXXImWl0IMOubmPEg3JjYXJlYSBzdHJhdHVsdWkgdGVtYXRpYyAke2xheWVyTmFtZX0gyJlpIGEgYWx0b3JhLlwiLFxuXHRcdGxlYXJuTW9yZUxhYmVsOiBcIkFmbGHIm2kgbWFpIG11bHRlXCIsXG5cdFx0ZmllbGROb3RBdmFpbGFibGU6IFwiTnUgcy1hIHJldciZaXQgw65uY8SDcmNhcmVhIGPDom1wdWx1aS5cIixcblx0XHRhbGxvd0FuYWx5c2lzOiBcIkFuYWxpemEgbnUgZXN0ZSBwZXJtaXPEgyDDrm4gc2VydmljaXVsIGRlIGltYWdpbmUuXCIsXG5cdFx0YWxsb3dBbmFseXNpc1JlYXNvbjogXCJVbnVsIHNhdSBtYWkgbXVsdGUgc3RyYXR1cmkgdGVtYXRpY2UgZGUgcGUgaGFydMSDIG51IHN1bnQgZW51bWVyYXRlIGFpY2kgcGVudHJ1IGPEgyBudSBwZXJtaXQgYW5hbGl6YS5cIixcblx0XHRsZWFybk1vcmVUZXh0OiBcIkFmbGHIm2kgbWFpIG11bHRlXCIsXG5cdFx0YXRMZWFzdE9uZVJhc3RlcklucHV0OiBcIkNlbCBwdcibaW4gdW4gc3RyYXQgdGVtYXRpYyBkZSBpbnRyYXJlIGFyIHRyZWJ1aSBzxIMgZmllIHVuIHN0cmF0IHRlbWF0aWMgZGUgcmFzdGVyLlwiLFxuXHRcdGJyb3dzZUFuYWx5c2lzTGF5ZXJzOiBcIlLEg3Nmb2lyZWEgc3RyYXR1cmlsb3IgdGVtYXRpY2VcIixcblx0XHRhY3RpdmVNYXBWaWV3RXh0ZW50OiBcIlV0aWxpemFyZWEgZXh0aW5kZXJpaSBoxINyyJtpaSBjdXJlbnRlXCIsXG5cdFx0Y2hvb3NlUmFzdGVyOiBcIkFsZWdlcmUgcmFzdGVyIGRlIGRlY3VwYXJlXCIsXG5cdFx0Y2hvb3NlR2VvbWV0cnk6IFwiQWxlZ2VyZSBnZW9tZXRyaWUgZGUgZGVjdXBhcmVcIixcblx0XHRyZXN1bHRUeXBlOiBcIlRpcCByZXp1bHRhdFwiLFxuXHRcdHNhdmVJbkZvbGRlcjogXCJTYWx2YXJlIMOubiBkaXJlY3RvclwiLFxuXHRcdG91dHB1dE5hbWU6IFwiTnVtZSBpZciZaXJlXCIsXG5cdFx0b3V0cHV0TGF5ZXJUeXBlOiBcIlRpcCBzdHJhdCB0ZW1hdGljIGRlIGllyJlpcmVcIixcblx0XHRkeW5hbWljSW1hZ2VyeUxheWVyOiBcIlN0cmF0IHRlbWF0aWMgZGUgaW1hZ2luaSBzYXRlbGl0YXJlIGRpbmFtaWNlXCIsXG5cdFx0dGlsZWRJbWFnZXJ5TGF5ZXI6IFwiU3RyYXQgdGVtYXRpYyBkZSBpbWFnaXN0aWPEgyBjdSBzZWdtZW50ZSB0aWxlXCIsXG5cdFx0Y3VzdG9tOiBcIlBlcnNvbmFsaXphcmVcIixcblx0XHRsb2FkaW5nOiBcIlNlIMOubmNhcmPEgy4uLlwiLFxuXHRcdGxheWVyTWlzc2luZzogXCJVbnVsIHNhdSBtYWkgbXVsdGUgc3RyYXR1cmkgdGVtYXRpY2UgZGUgcGUgaGFydMSDIG51IHN1bnQgZW51bWVyYXRlIGFpY2kgcGVudHJ1IGPEgyBudSBwZXJtaXQgYW5hbGl6YS4gQWZsYcWjaSBtYWkgbXVsdGUuXCIsXG5cdFx0YnJvd3NlQ29vcmRpbmF0ZVN5c3RlbXM6IFwiUsSDc2ZvaXJlIHNpc3RlbWUgZGUgY29vcmRvbmF0ZVwiLFxuXHRcdHVuYWJsZVRvUmVwb3B1bGF0ZU91dFNSOiBcIk51IHNlIHBvYXRlIHBvcHVsYSBzaXN0ZW11bCBkZSBjb29yZG9uYXRlIGRlIGllyJlpcmUuXCIsXG5cdFx0ZGVmYXVsdFRpdGxlOiBcIlZlZGXIm2kgbWFpIG11bHRcIixcblx0XHRcIkFSQyAoZXF1YWwgYXJjLXNlY29uZClcIjogXCJBUkMgKGFlciBlZ2FsIHNlY3VuZGFyKVwiLFxuXHRcdEFmcmljYTogXCJBZnJpY2FcIixcblx0XHRBbnRhcmN0aWNhOiBcIkFudGFyY3RpY2FcIixcblx0XHRBcmdlbnRpbmE6IFwiQXJnZW50aW5hXCIsXG5cdFx0QXNpYTogXCJBc2lhXCIsXG5cdFx0XCJBc3Rlcm9pZCBCZWx0XCI6IFwiQ2VudHVyxIMgZGUgYXN0ZXJvaXppXCIsXG5cdFx0XCJBdGxhbnRpYyBPY2VhblwiOiBcIk9jZWFudWwgQXRsYW50aWNcIixcblx0XHRBdXN0cmFsaWE6IFwiQXVzdHJhbGlhXCIsXG5cdFx0XCJBdXN0cmFsaWEgYW5kIE5ldyBaZWFsYW5kXCI6IFwiQXVzdHJhbGlhIMiZaSBOb3VhIFplZWxhbmTEg1wiLFxuXHRcdEF1c3RyaWE6IFwiQXVzdHJpYVwiLFxuXHRcdFwiQkxNIChVUyBGZWV0KVwiOiBcIkJMTSAocGljaW9hcmUgU1VBKVwiLFxuXHRcdEJhbmdsYWRlc2g6IFwiQmFuZ2xhZGVzaFwiLFxuXHRcdFwiQmVpamluZyAxOTU0XCI6IFwiQmVpamluZyAxOTU0XCIsXG5cdFx0Qmh1dGFuOiBcIkJodXRhblwiLFxuXHRcdENHQ1MyMDAwOiBcIkNHQ1MyMDAwXCIsXG5cdFx0Q2FuYWRhOiBcIkNhbmFkYVwiLFxuXHRcdENhcmliYmVhbjogXCJDYXJhaWJlXCIsXG5cdFx0XCJDYXJpYmJlYW4gU2VhXCI6IFwiTWFyZWEgQ2FyYWliZWxvclwiLFxuXHRcdFwiQ2VudHJhbCBBbWVyaWNhXCI6IFwiQW1lcmljYSBDZW50cmFsxINcIixcblx0XHRcIkNlbnRyYWwgYW5kIE5vcnRoIEFtZXJpY2FcIjogXCJBbWVyaWNhIENlbnRyYWzEgyDImWkgZGUgTm9yZFwiLFxuXHRcdENvbG9tYmlhOiBcIkNvbHVtYmlhXCIsXG5cdFx0Q29udGluZW50YWw6IFwiQ29udGluZW50YWxcIixcblx0XHRcIkNvdW50eSBTeXN0ZW1zXCI6IFwiU2lzdGVtZSByZWdpb25hbGVcIixcblx0XHRcIkRlbW9jcmF0aWMgUmVwdWJsaWMgb2YgdGhlIENvbmdvXCI6IFwiUmVwdWJsaWNhIERlbW9jcmF0xIMgQ29uZ29cIixcblx0XHRcIkVQU0cgQXJjdGljXCI6IFwiRVBTRyBBcmN0aWNcIixcblx0XHRFYXJ0aDogXCJUZXJyYVwiLFxuXHRcdFwiRWxsaXBzb2lkYWwtYmFzZWRcIjogXCJCYXphdCBwZSBlbGlwc29pZMSDXCIsXG5cdFx0RXVyb3BlOiBcIkV1cm9wYVwiLFxuXHRcdEZpbmxhbmQ6IFwiRmlubGFuZGFcIixcblx0XHRGcmFuY2U6IFwiRnJhbsWjYVwiLFxuXHRcdFwiR1NLIDIwMTFcIjogXCJHU0sgMjAxMVwiLFxuXHRcdFwiR2F1c3MgS3J1Z2VyXCI6IFwiR2F1c3MgS3J1Z2VyXCIsXG5cdFx0XCJHZW9ncmFwaGljIENvb3JkaW5hdGUgU3lzdGVtc1wiOiBcIlNpc3RlbWUgZGUgY29vcmRvbmF0ZSBnZW9ncmFmaWNlXCIsXG5cdFx0R2VybWFueTogXCJHZXJtYW5pYVwiLFxuXHRcdFwiR3Jhdml0eS1yZWxhdGVkXCI6IFwiTGVnYXQgZGUgZ3Jhdml0YcibaWVcIixcblx0XHRcIkdyZWVud2ljaC1iYXNlZFwiOiBcIkJhemF0IHBlIEdyZWVud2ljaFwiLFxuXHRcdFwiSGlnaHdheXMgRW5nbGFuZFwiOiBcIkF1dG9zdHLEg3ppIEFuZ2xpYVwiLFxuXHRcdElsbGlub2lzOiBcIklsbGlub2lzXCIsXG5cdFx0XCJJbmRpYW4gT2NlYW5cIjogXCJPY2VhbnVsIEluZGlhblwiLFxuXHRcdFwiSW5kaWFuIFN1YmNvbnRpbmVudFwiOiBcIlN1YmNvbnRpbmVudHVsIGluZGlhblwiLFxuXHRcdEluZGlhbmE6IFwiSW5kaWFuYVwiLFxuXHRcdEluZG9uZXNpYTogXCJJbmRvbmV6aWFcIixcblx0XHRJb3dhOiBcIklvd2FcIixcblx0XHRcIklyZWxhbmQgYW5kIFVuaXRlZCBLaW5nZG9tXCI6IFwiSXJsYW5kYSDImWkgUmVnYXR1bCBVbml0XCIsXG5cdFx0SXRhbHk6IFwiSXRhbGlhXCIsXG5cdFx0SmFwYW46IFwiSmFwb25pYVwiLFxuXHRcdEp1cGl0ZXI6IFwiSnVwaXRlclwiLFxuXHRcdEthbnNhczogXCJLYW5zYXNcIixcblx0XHRcIkxhcyBWZWdhc1wiOiBcIkxhcyBWZWdhc1wiLFxuXHRcdExpYnlhOiBcIkxpYmlhXCIsXG5cdFx0TWFsYXlzaWE6IFwiTWFsYXlzaWFcIixcblx0XHRcIk1hbGF5c2lhIGFuZCBTaW5nYXBvcmVcIjogXCJNYWxheXNpYSDImWkgU2luZ2Fwb3JlXCIsXG5cdFx0TWFyczogXCJNYXJ0ZVwiLFxuXHRcdE1lcmN1cnk6IFwiTWVyY3VyXCIsXG5cdFx0TWlubmVzb3RhOiBcIk1pbm5lc290YVwiLFxuXHRcdE1vbnRhbmE6IFwiTW9udGFuYVwiLFxuXHRcdFwiTkFEIDE5MjdcIjogXCJOQUQgMTkyN1wiLFxuXHRcdFwiTkFEIDE5MjcgKFVTIEZlZXQpXCI6IFwiTkFEIDE5MjcgKHBpY2lvYXJlIFNVQSlcIixcblx0XHRcIk5BRCAxOTgzXCI6IFwiTkFEIDE5ODNcIixcblx0XHRcIk5BRCAxOTgzICgyMDExKVwiOiBcIk5BRCAxOTgzICgyMDExKVwiLFxuXHRcdFwiTkFEIDE5ODMgKDIwMTEpIChJbnRsIEZlZXQpXCI6IFwiTkFEIDE5ODMgKDIwMTEpIChwaWNpb2FyZSBpbnRlcm5hyJtpb25hbGUpXCIsXG5cdFx0XCJOQUQgMTk4MyAoMjAxMSkgKE1ldGVycylcIjogXCJOQUQgMTk4MyAoMjAxMSkgKG1ldHJpKVwiLFxuXHRcdFwiTkFEIDE5ODMgKDIwMTEpIChVUyBGZWV0KVwiOiBcIk5BRCAxOTgzICgyMDExKSAocGljaW9hcmUgU1VBKVwiLFxuXHRcdFwiTkFEIDE5ODMgKENPUlM5NikgKEludGwgRmVldClcIjogXCJOQUQgMTk4MyAoQ09SUzk2KSAocGljaW9hcmUgaW50ZXJuYcibaW9uYWxlKVwiLFxuXHRcdFwiTkFEIDE5ODMgKENPUlM5NikgKE1ldGVycylcIjogXCJOQUQgMTk4MyAoQ09SUzk2KSAobWV0cmkpXCIsXG5cdFx0XCJOQUQgMTk4MyAoQ09SUzk2KSAoVVMgRmVldClcIjogXCJOQUQgMTk4MyAoQ09SUzk2KSAocGljaW9hcmUgU1VBKVwiLFxuXHRcdFwiTkFEIDE5ODMgKEludGwgRmVldClcIjogXCJOQUQgMTk4MyAocGljaW9hcmUgaW50ZXJuYcibaW9uYWxlKVwiLFxuXHRcdFwiTkFEIDE5ODMgKE1ldGVycylcIjogXCJOQUQgMTk4MyAobWV0cmkpXCIsXG5cdFx0XCJOQUQgMTk4MyAoUEExMSkgKE1ldGVycylcIjogXCJOQUQgMTk4MyAoUEExMSkgKG1ldHJpKVwiLFxuXHRcdFwiTkFEIDE5ODMgKFBBMTEpIChVUyBGZWV0KVwiOiBcIk5BRCAxOTgzIChQQTExKSAocGljaW9hcmUgU1VBKVwiLFxuXHRcdFwiTkFEIDE5ODMgKFVTIEZlZXQpXCI6IFwiTkFEIDE5ODMgKHBpY2lvYXJlIFNVQSlcIixcblx0XHRcIk5BRCAxOTgzIEhBUk4gKEludGwgRmVldClcIjogXCJOQUQgMTk4MyBIQVJOIChwaWNpb2FyZSBpbnRlcm5hyJtpb25hbGUpXCIsXG5cdFx0XCJOQUQgMTk4MyBIQVJOIChNZXRlcnMpXCI6IFwiTkFEIDE5ODMgSEFSTiAobWV0cmkpXCIsXG5cdFx0XCJOQUQgMTk4MyBIQVJOIChVUyBGZWV0KVwiOiBcIk5BRCAxOTgzIEhBUk4gKHBpY2lvYXJlIFNVQSlcIixcblx0XHRcIk5BRCAxOTgzIE5TUlMyMDA3IChJbnRsIEZlZXQpXCI6IFwiTkFEIDE5ODMgTlNSUzIwMDcgKHBpY2lvYXJlIGludGVybmHIm2lvbmFsZSlcIixcblx0XHRcIk5BRCAxOTgzIE5TUlMyMDA3IChNZXRlcnMpXCI6IFwiTkFEIDE5ODMgTlNSUzIwMDcgKG1ldHJpKVwiLFxuXHRcdFwiTkFEIDE5ODMgTlNSUzIwMDcgKFVTIEZlZXQpXCI6IFwiTkFEIDE5ODMgTlNSUzIwMDcgKHBpY2lvYXJlIFNVQSlcIixcblx0XHRcIk5hdGlvbmFsIEdyaWRzXCI6IFwiR3JpbGUgbmHIm2lvbmFsZVwiLFxuXHRcdE5hdmFqbzogXCJOYXZham9cIixcblx0XHROZXB0dW5lOiBcIk5lcHR1blwiLFxuXHRcdFwiTmV3IEJlaWppbmdcIjogXCJOb3VsIEJlaWppbmdcIixcblx0XHRcIk5ldyBaZWFsYW5kXCI6IFwiTm91YSBaZWVsYW5kxINcIixcblx0XHRcIk5vcnRoIEFtZXJpY2FcIjogXCJBbWVyaWNhIGRlIE5vcmRcIixcblx0XHRcIk5vcnRoZXJuIEhlbWlzcGhlcmVcIjogXCJFbWlzZmVyYSBub3JkaWPEg1wiLFxuXHRcdE5vcndheTogXCJOb3J2ZWdpYVwiLFxuXHRcdE9jZWFuczogXCJPY2VhbmVcIixcblx0XHRPcmVnb246IFwiT3JlZ29uXCIsXG5cdFx0XCJPdGhlciBHQ1NcIjogXCJBbHQgR0NTXCIsXG5cdFx0XCJQYWNpZmljIE9jZWFuXCI6IFwiT2NlYW51bCBQYWNpZmljXCIsXG5cdFx0UGx1dG86IFwiUGx1dG9cIixcblx0XHRQb2xhcjogXCJQb2xhclwiLFxuXHRcdFBvcnR1Z2FsOiBcIlBvcnR1Z2FsaWFcIixcblx0XHRcIlByb2plY3RlZCBDb29yZGluYXRlIFN5c3RlbXNcIjogXCJTaXN0ZW1lIGRlIGNvb3Jkb25hdGUgcHJvaWVjdGF0ZVwiLFxuXHRcdFwiUHVsa292byAxOTQyXCI6IFwiUHVsa292byAxOTQyXCIsXG5cdFx0XCJQdWxrb3ZvIDE5OTVcIjogXCJQdWxrb3ZvIDE5OTVcIixcblx0XHRSZXBsYWNlZDogXCLDjm5sb2N1aXRcIixcblx0XHRcIlNBRCAxOTY5XCI6IFwiU0FEIDE5NjlcIixcblx0XHRTSVJHQVM6IFwiU0lSR0FTXCIsXG5cdFx0XCJTSVJHQVMgMjAwMFwiOiBcIlNJUkdBUyAyMDAwXCIsXG5cdFx0U2F0dXJuOiBcIlNhdHVyblwiLFxuXHRcdFwiU29sYXIgU3lzdGVtXCI6IFwiU2lzdGVtdWwgU29sYXJcIixcblx0XHRcIlNvdXRoIEFmcmljYVwiOiBcIkFmcmljYSBkZSBTdWRcIixcblx0XHRcIlNvdXRoIEFtZXJpY2FcIjogXCJBbWVyaWNhIGRlIFN1ZFwiLFxuXHRcdFwiU291dGggS29yZWFcIjogXCJDb3JlZWEgZGUgU3VkXCIsXG5cdFx0XCJTb3V0aGVybiBIZW1pc3BoZXJlXCI6IFwiRW1pc2ZlcmEgc3VkaWPEg1wiLFxuXHRcdFwiU3BoZXJvaWQtYmFzZWRcIjogXCJQZSBiYXrEgyBzZmVyb2lkxINcIixcblx0XHRcIlN0YXRlIFBsYW5lXCI6IFwiQXZpb24gc3RhdGFsXCIsXG5cdFx0XCJTdGF0ZSBTeXN0ZW1zXCI6IFwiU2lzdGVtZSBzdGF0YWxlXCIsXG5cdFx0U3dlZGVuOiBcIlN1ZWRpYVwiLFxuXHRcdFwiU3dpdHplcmxhbmQgYW5kIExpZWNodGVuc3RlaW5cIjogXCJFbHZlyJtpYSDImWkgTGllY2h0ZW5zdGVpblwiLFxuXHRcdFRleGFzOiBcIlRleGFzXCIsXG5cdFx0VHJpYmFsOiBcIlRyaWJhbGVcIixcblx0XHRUdXJrZXk6IFwiVHVyY2lhXCIsXG5cdFx0XCJVUyBGZWV0XCI6IFwiUGljaW9hcmUgU1VBXCIsXG5cdFx0XCJVU0EgYW5kIHRlcnJpdG9yaWVzXCI6IFwiU1VBIMiZaSB0ZXJpdG9yaWlsZVwiLFxuXHRcdFVUTTogXCJVVE1cIixcblx0XHRVa3JhaW5lOiBcIlVjcmFpbmFcIixcblx0XHRcIlVua25vd24gSGVpZ2h0IFN5c3RlbXNcIjogXCJTaXN0ZW1lIGRlIMOubsSDbMibaW1lIG5lY3Vub3NjdXRlXCIsXG5cdFx0VXJhbnVzOiBcIlVyYW51c1wiLFxuXHRcdFZlbnVzOiBcIlZlbnVzXCIsXG5cdFx0XCJWZXJ0aWNhbCBDb29yZGluYXRlIFN5c3RlbXNcIjogXCJTaXN0ZW1lIGRlIGNvb3Jkb25hdGUgdmVydGljYWxlXCIsXG5cdFx0VmlldG5hbTogXCJWaWV0bmFtXCIsXG5cdFx0XCJXR1MgMTk3MlwiOiBcIldHUyAxOTcyXCIsXG5cdFx0XCJXR1MgMTk4NFwiOiBcIldHUyAxOTg0XCIsXG5cdFx0V2lzY29uc2luOiBcIldpc2NvbnNpblwiLFxuXHRcdFwiV2lzY29uc2luIENSU1wiOiBcIldpc2NvbnNpbiBDUlNcIixcblx0XHRXb3JsZDogXCJHbG9iXCIsXG5cdFx0XCJXb3JsZCAoU3BoZXJlLWJhc2VkKVwiOiBcIkdsb2IgKGZvcm3EgyBzZmVyaWPEgylcIixcblx0XHRXeW9taW5nOiBcIld5b21pbmdcIixcblx0XHRcIlhpYW4gMTk4MFwiOiBcIlhpYW4gMTk4MFwiLFxuXHRcdGRvbmU6IFwiR2F0YVwiLFxuXHRcdG5vUmVzdWx0czogXCJOdSBhIGZvc3QgZ8SDc2l0IG5pY2l1biByZXp1bHRhdFwiLFxuXHRcdHNlYXJjaFBsYWNlaG9sZGVyOiBcIk51bWUgc2F1IFdLSURcIixcblx0XHRicm93c2VUZW1wbGF0ZTogXCJDxIN1dGHIm2kgyJlhYmxvYW5lIGRlIGZ1bmPIm2llIHJhc3RlclwiLFxuXHRcdHNhdmVUZW1wbGF0ZTogXCJTYWx2YXJlIMiZYWJsb24gZnVuY8ibaWUgcmFzdGVyXCIsXG5cdFx0cHJldmlldzogXCJQcmV2aXp1YWxpemFyZVwiLFxuXHRcdHByZXZpZXdEZXNjcmlwdGlvbjogXCJQcmV2aXp1YWxpemHIm2kgcmV6dWx0YXR1bCDDrm5haW50ZSBkZSBhIGV4ZWN1dGEgYW5hbGl6YS5cIixcblx0XHRzaG93UHJldmlldzogXCJBZmnImWFyZSBwcmV2aXp1YWxpemFyZVwiLFxuXHRcdHByZXZpZXdMYXllcjogXCJQcmV2aXp1YWxpemFyZSBzdHJhdCB0ZW1hdGljICR7bnVtYmVyfVwiLFxuXHRcdG5ld1ByZXZpZXc6IFwiUHJldml6dWFsaXphcmUgbm91xINcIixcblx0XHRwcmV2aWV3UG9wdXA6IFwiQWN0aXZhyJtpIHByZXZpenVhbGl6YXJlYSByZXp1bHRhdGVsb3IgYW5hbGl6ZWkgcGUgYmF6YSBwYXJhbWV0cmlsb3IgZGUgaW50cmFyZS5cIixcblx0XHR1cGRhdGVQcmV2aWV3TGF5ZXI6IFwiQWN0dWFsaXphcmUgc3RyYXQgdGVtYXRpYyBkZSBwcmV2aXp1YWxpemFyZSBzZWxlY3RhdFwiLFxuXHRcdGNyZWF0ZVByZXZpZXdMYXllcjogXCJDcmVhcmUgc3RyYXQgdGVtYXRpYyBkZSBwcmV2aXp1YWxpemFyZSBub3VcIixcblx0XHRtYXhpbXVtUHJldmlld0FsbG93ZWQ6IFwiTnVtxINyIG1heGltIGRlIHN0cmF0dXJpIHRlbWF0aWNlIGRlIHByZXZpenVhbGl6YXJlIHBlcm1pczogJHttYXhDb3VudH1cIixcblx0XHRwcmV2aWV3RmFpbHVyZTogXCJBY2VzdCBzdHJhdCB0ZW1hdGljIGRlIHByZXZpenVhbGl6YXJlIGVzdGUgaW5kaXNwb25pYmlsLiBWZXJpZmljYcibaSBwYXJhbWV0cmlpIGRlIGludHJhcmUgyJlpIGFjdHVhbGl6YcibaSBhY2VzdCBzdHJhdCB0ZW1hdGljIGRlIHByZXZpenVhbGl6YXJlIGRpbiBub3UuXCIsXG5cdFx0aGVhZGVyOiBcIlNlbGVjdGHIm2kgdW4gZWxlbWVudFwiLFxuXHRcdGNvbnRlbnQ6IFwiQXZlyJtpIG1vZGlmaWPEg3JpIG5lc2FsdmF0ZSDDrm4gJHtyZnRUaXRsZX0uIERhY8SDIMOubmNlcGXIm2kgZGluIG5vdSBjdSB1biDImWFibG9uIG5vdSwgYWNlbGUgbW9kaWZpY8SDcmkgdm9yIGZpIHBpZXJkdXRlLlwiLFxuXHRcdGRvbnRTYXZlOiBcIk51IHNhbHZhyJtpXCIsXG5cdFx0XCJjb250aW51ZVwiOiBcIkNvbnRpbnVhcmVcIixcblx0XHRzdHJldGNoOiBcIkZpeGFyZSDDrm4gZmVyZWFzdHLEg1wiLFxuXHRcdHBhbjogXCJQYW5vcmFtYXJlXCIsXG5cdFx0bmV3VGVtcGxhdGU6IFwiQ3JlYXJlIMiZYWJsb24gbm91XCIsXG5cdFx0b3BlblRlbXBsYXRlOiBcIkRlc2NoaWRlcmUgyJlhYmxvblwiLFxuXHRcdGFkZEZ1bmN0aW9uOiBcIkFkxIN1Z2FyZSBmdW5jyJtpaSByYXN0ZXJcIixcblx0XHRhZGRDb25zdGFudDogXCJBZMSDdWdhcmUgY29uc3RhbnTEg1wiLFxuXHRcdGFkZFJhc3RlcjogXCJBZMSDdWdhcmUgdmFyaWFiaWzEgyByYXN0ZXJcIixcblx0XHRtb3ZlOiBcIk11dGFyZVwiLFxuXHRcdHpvb206IFwiWm9vbVwiLFxuXHRcdHNhdmVBczogXCJTYWx2YXJlIGNhXCIsXG5cdFx0Y2xlYXI6IFwiR29saXJlXCIsXG5cdFx0YWRkUmFzdGVyRnVuY3Rpb25UaXRsZTogXCJBZMSDdWdhcmUgZnVuY8ibaWkgcmFzdGVyXCIsXG5cdFx0dGVtcGxhdGVQcm9wZXJ0aWVzVGl0bGU6IFwiUHJvcHJpZXTEg8ibaSDImWFibG9uXCIsXG5cdFx0YnJvd3NlUkZUOiBcIkPEg3V0YcibaSDImWFibG9hbmUgZGUgZnVuY8ibaWUgcmFzdGVyXCIsXG5cdFx0ZGVmYXVsdFRvb2xEZXNjcmlwdGlvbjogXCJJbnN0cnVtZW50IGRlIGFuYWxpesSDICR7dG9vbFRpdGxlfS5cIixcblx0XHRvcGVuVG9vbFRleHQ6IFwiRGVzY2hpZGVyZSBpbnN0cnVtZW50XCIsXG5cdFx0dG9vbERyb3Bkb3duVGV4dDogXCJJbnN0cnVtZW50IGRlcnVsYW50xINcIixcblx0XHRhZGRUb01hcDogXCJDb25maXJtYXJlIMiZaSBhZMSDdWdhcmUgbGEgaGFydMSDXCIsXG5cdFx0Y29uZmlybTogXCJDb25maXJtYXJlXCIsXG5cdFx0c2VsZWN0OiBcIlNlbGVjdGFyZVwiLFxuXHRcdHNlbGVjdFRhc2s6IFwiU2VsZWN0YXJlIGFjdGl2aXRhdGVcIixcblx0XHR1bnN1cHBvcnRlZExheWVyOiBcIkFjZXN0IHBhcmFtZXRydSBudSBhY2NlcHTEgyB1cm3Eg3RvYXJlbGUgc3RyYXR1cmkgdGVtYXRpY2U6ICR7bGF5ZXJOYW1lfS5cIixcblx0XHR2aWV3RGV0YWlsczogXCJWaXp1YWxpemHIm2kgdG9hdGUgZGV0YWxpaWxlIGVsZW1lbnR1bHVpXCIsXG5cdFx0cmVuYW1lOiBcIlJlZGVudW1pcmVcIixcblx0XHRkdXBsaWNhdGU6IFwiRHVwbGljYXRlXCIsXG5cdFx0bGF1bmNoOiBcIkRlc2NoaWRlcmUgcGVudHJ1IGV4ZWN1dGFyZVwiLFxuXHRcdHRlbXBsYXRlRWRpdG9yOiBcIkVkaXRvciDImWFibG9hbmVcIixcblx0XHRjcmVhdGVJdGVtOiBcIlNhbHZhcmUgyJlhYmxvbiBmdW5jyJtpZSByYXN0ZXJcIixcblx0XHRhY3Rpb25MYWJlbDogXCJGaWx0cmFyZVwiLFxuXHRcdGZpbHRlclBvcG92ZXJIZWFkaW5nOiBcIkZpbHRyYXJlYSBmdW5jyJtpaWxvclwiLFxuXHRcdGRlZmF1bHRTZWFyY2hQbGFjZWhvbGRlcjogXCJDxIN1dGFyZSBkdXDEgyBudW1lXCIsXG5cdFx0c2V0dGluZ3M6IFwiU2V0xINyaVwiLFxuXHRcdHN1bW1hcnk6IFwiUmV6dW1hdFwiLFxuXHRcdGRlZmluaXRpb25RdWVyeTogXCJJbnRlcm9nYXJlIGRlZmluacibaWVcIixcblx0XHRtYXRjaFZhcmlhYmxlczogXCJWYXJpYWJpbGUgZGUgcG90cml2aXJlXCIsXG5cdFx0dW5pb25EaW1lbnNpb246IFwiRGltZW5zaXVuZSB1bml1bmVcIixcblx0XHRuYW1lRWRpdG9yUGxhY2Vob2xkZXI6IFwiSW50cm9kdWNlcmUgdGl0bHVcIixcblx0XHRzdW1tYXJ5RWRpdG9yUGxhY2Vob2xkZXI6IFwiSW50cm9kdWNlyJtpIG8gc2N1cnTEgyBkZXNjcmllcmUuXCIsXG5cdFx0ZGVmaW5pdGlvblF1ZXJ5UGxhY2Vob2xkZXI6IFwiSW50cm9kdWNlyJtpLi4uXCIsXG5cdFx0dXBsb2FkOiBcIsOObmPEg3JjYXJlXCIsXG5cdFx0Y2hvb3NlSW1hZ2U6IFwiRmFjZcibaSBjbGljIHBlbnRydSBhIGFsZWdlIHVuIGZpyJlpZXJcIixcblx0XHR1cGRhdGU6IFwiQWN0dWFsaXphcmVcIixcblx0XHR0aHVtYm5haWxFcnJvcnM6IHtcblx0XHRcdHdyb25nSW1hZ2VUeXBlOiBcIkEgZm9zdCBzZWxlY3RhdCB0aXB1bCBlcm9uYXQgZGUgaW1hZ2luZVwiLFxuXHRcdFx0bm90QXZhaWxhYmxlOiBcIk1pbmlhdHVyxIMgaW5kaXNwb25pYmlsxINcIixcblx0XHRcdGxvYWRFcnJvcjogXCJOdSBzLWEgcHV0dXQgw65uY8SDcmNhIGltYWdpbmVhXCIsXG5cdFx0XHRjaG9vc2VGaWxlOiBcIkZhY2XIm2kgY2xpYyBwZW50cnUgYSBhbGVnZSBmaciZaWVydWxcIlxuXHRcdH1cblx0fVxufTtcbmNvbnN0IGNvcHkgPSBcIkNvcGllcmVcIjtcbmNvbnN0IHNhdmUgPSBcIlNhbHZhyJtpXCI7XG5jb25zdCB0aXRsZSA9IFwiVGl0bHVcIjtcbmNvbnN0IGZvbGRlciA9IFwiRm9sZGVyXCI7XG5jb25zdCB0YWdzID0gXCJFdGljaGV0ZVwiO1xuY29uc3Qgc2F2aW5nTWVzc2FnZSA9IFwiU2FsdmFyZSByZXBlciDDrm5cIjtcbmNvbnN0IHNoYXJlV2l0aCA9IFwiUGFydGFqYXJlIGN1XCI7XG5jb25zdCBzaGFyZSA9IFwiUGFydGFqYXJlXCI7XG5jb25zdCBzZXRTaGFyaW5nTGV2ZWwgPSBcIlNldGHIm2kgbml2ZWx1bCBkZSBwYXJ0YWphcmVcIjtcbmNvbnN0IHNldEdyb3VwU2hhcmluZyA9IFwiU2V0YcibaSBwYXJ0YWphcmVhIGN1IHVuIGdydXBcIjtcbmNvbnN0IG93bmVyID0gXCJQcm9wcmlldGFyXCI7XG5jb25zdCBvcmdhbml6YXRpb24gPSBcIk9yZ2FuaXphxaNpZVwiO1xuY29uc3QgZXZlcnlvbmUgPSBcIlRvYXTEgyBsdW1lYSAocHVibGljKVwiO1xuY29uc3QgZ3JvdXBzID0gXCJHcnVwdXJpOlwiO1xuY29uc3QgdHlwZSA9IFwiVGlwXCI7XG5jb25zdCBtb3NhaWMgPSBcIk1vemFpY1wiO1xuY29uc3QgaXRlbUdyb3VwID0gXCJHcnVwIGRlIHJlcGVyXCI7XG5jb25zdCBpdGVtID0gXCJFbGVtZW50XCI7XG5jb25zdCBkZWZpbml0aW9uUXVlcnkgPSBcIkludGVyb2dhcmUgZGVmaW5pyJtpZVwiO1xuY29uc3QgZ3JvdXBJdGVtc0J5ID0gXCJHcnVwYcibaSBlbGVtZW50ZWxlIGR1cMSDXCI7XG5jb25zdCBncm91cEZpZWxkTmFtZSA9IFwiTnVtZWxlIGPDom1wdWx1aSBncnVwXCI7XG5jb25zdCB0YWdGaWVsZE5hbWUgPSBcIk51bWVsZSBjw6JtcHVsdWkgZXRpY2hldMSDXCI7XG5jb25zdCBub1RpdGxlVGFnRXJyb3JNc2cgPSBcIlRyZWJ1aWUgc8SDIGZ1cm5pemHIm2kgdW4gdGl0bHUgcGVudHJ1IHJlcGVydWwgZHZzLiDImWkgZXRpY2hldGUgcGVudHJ1IGEgcGVybWl0ZSBnxINzaXJlYSBoxINyyJtpaSBwcmluIGludGVybWVkaXVsIGPEg3V0xINyaWxvci5cIjtcbmNvbnN0IG5vVGl0bGVFcnJvck1zZyA9IFwiVHJlYnVpZSBzxIMgZnVybml6YcWjaSB1biB0aXRsdSBwZW50cnUgZWxlbWVudHVsIGR2cy5cIjtcbmNvbnN0IG5vVGFnRXJyb3JNc2cgPSBcIlRyZWJ1aWUgc8SDIGZ1cm5pemHIm2kgY2VsIHB1yJtpbiBvIGV0aWNoZXTEgyBwZW50cnUgYSBhanV0YSB1dGlsaXphdG9yaWkgc8SDIGfEg3NlYXNjxIMgcmVwZXJ1bCBkdnMuIHByaW4gaW50ZXJtZWRpdWwgY8SDdXTEg3JpbG9yLlwiO1xuY29uc3QgZXJyb3IgPSBcIkVyb2FyZVwiO1xuY29uc3Qgd2FybmluZyA9IFwiQXZlcnRpc21lbnRcIjtcbmNvbnN0IHN1Y2Nlc3MgPSBcIlN1Y2Nlc1wiO1xuY29uc3QgZGV0YWlscyA9IFwiRGV0YWxpaTpcIjtcbmNvbnN0IHRyeUFnYWluID0gXCLDjm5jZXJjYcWjaSBkaW4gbm91XCI7XG5jb25zdCB0b29sTW9kZWxlciA9IHtcblx0c2F2ZTogXCJTYWx2YcibaVwiLFxuXHRlZGl0UHJvcGVydGllczogXCJFZGl0YXJlIHByb3ByaWV0xIPFo2lcIixcblx0c2F2ZUFzOiBcIlNhbHZhcmUgY2FcIixcblx0c2F2aW5nTm90aWZpY2F0aW9uOiBcIlNhbHZhcmUgbW9kaWZpY8SDcmkgw65uIHJlcGVydWwuLi5cIixcblx0c2F2aW5nVGl0bGU6IFwiU2Ugc2FsdmVhesSDXCIsXG5cdHNhdmVGYWlsZWRNZXNzYWdlOiBcIlNjaGltYsSDcmlsZSBudSBhdSBwdXR1dCBmaSBzYWx2YXRlLlwiLFxuXHRzYXZlV2l0aEVycm9yc01lc3NhZ2U6IFwiTW9kaWZpY8SDcmlsZSBhdSBmb3N0IHNhbHZhdGUgY3UgdXJtxIN0b2FyZWxlIGVyb3JpLlwiLFxuXHR2aWV3SXRlbU1lc3NhZ2U6IFwiVml6dWFsaXphyJtpIHJlcGVydWwgc2FsdmF0XCIsXG5cdGhlcmU6IFwiYWljaS5cIixcblx0aXRlbUNyZWF0ZWRNZXNzYWdlOiBcIkEgZm9zdCBjcmVhdCB1biBlbGVtZW50IG5vdS5cIixcblx0Y2xpY2tUb1ZpZXdJdGVtTWVzc2FnZTogXCJGYWNlyJtpIGNsaWMgcGUgT0sgcGVudHJ1IGEgdml6dWFsaXphIHBhZ2luYSBkZSBkZXRhbGlpIGFsZSBlbGVtZW50dWx1aTsgZmFjZcibaSBjbGljIHBlIEFudWxhcmUgcGVudHJ1IGEgY29udGludWEuXCIsXG5cdHJlYWRpbmdGYWlsZWQ6IFwiQSBlxZ91YXQgw65uY8SDcmNhcmVhIMiZYWJsb251bHVpIGRlIGZ1bmPIm2llIHJhc3RlciBzZWxlY3RhdC5cIixcblx0ZmFpbGVkVG9Mb2FkWE1MOiBcIkEgZciZdWF0IMOubmPEg3JjYXJlYSDImWFibG9udWx1aSBkZSBmdW5jyJtpZSByYXN0ZXIgc2VsZWN0YXQgw65uIGZvcm1hdCBYTUwuXCIsXG5cdGxlYXJuTW9yZTogXCJBZmxhyJtpIG1haSBtdWx0ZVwiLFxuXHRvdmVyd3JpdGVUaXRsZTogXCJDb25maXJtYXJlIHN1cHJhc2NyaWVyZVwiLFxuXHRvdmVyd3JpdGVNZXNzYWdlOiBcIkRvcmnFo2kgc8SDIHN1cHJhc2NyaWXFo2kgZWxlbWVudHVsIGV4aXN0ZW50P1wiLFxuXHRvdmVyd3JpdGVTdWNjZXNzTWVzc2FnZTogXCJFbGVtZW50dWwgYSBmb3N0IGFjdHVhbGl6YXQuXCJcbn07XG5jb25zdCB0b29sRWRpdG9yID0ge1xuXHRydW46IFwiRXhlY3V0YXJlXCIsXG5cdHNhdmU6IFwiU2FsdmHIm2lcIixcblx0ZGVsZXRlU2VsZWN0ZWQ6IFwixZ50ZXJnZcibaSBlbGVtZW50ZWxlIHNlbGVjdGF0ZVwiLFxuXHRhZGRSYXN0ZXI6IFwiQWTEg3VnYcibaSByYXN0ZXJcIixcblx0YWRkU2NhbGFyOiBcIkFkxIN1Z2HIm2kgdmFsb2FyZSBzY2FsYXLEg1wiLFxuXHRsYXlvdXQ6IFwiQ29uZmlndXJhyJtpZSBhdXRvbWF0xINcIixcblx0ZXJyb3JUaXRsZTogXCJFcm9hcmVcIixcblx0aW52YWxpZFRvb2xNZXNzYWdlOiBcIsiYYWJsb251bCBkZSBmdW5jyJtpZSByYXN0ZXIgbnUgZXN0ZSB2YWxhYmlsLlwiLFxuXHRvdXQ6IFwiSWXImWlyZVwiLFxuXHR6b29tSW46IFwiTcSDcmlyZVwiLFxuXHR6b29tT3V0OiBcIk1pY8Wfb3JhcmVcIixcblx0em9vbVRvRml0OiBcIkZpeGHIm2kgw65uIGZlcmVhc3RyxINcIixcblx0cGFuT246IFwiVHJlY2XIm2kgcGUgbW9kdWwgcGFuXCIsXG5cdHBhbk9mZjogXCJPcHJpyJtpIG1vZHVsIHBhblwiLFxuXHRkZWZhdWx0TW9kZWxOYW1lOiBcIk1vZGVsIGRlIGluc3RydW1lbnRcIixcblx0ZGVmYXVsdFJhc3Rlck5hbWU6IFwiUmFzdGVyXCJcbn07XG5jb25zdCB0b29sRGV0YWlsc0VkaXRvciA9IHtcblx0ZGVmYXVsdFRvb2xOYW1lOiBcIsWeYWJsb24gZnVuY8WjaWUgcmFzdGVyXCIsXG5cdGRlZmF1bHRUb29sRGVzY3JpcHRpb246IFwiQWTEg3VnYcWjaSB1biBzY3VydCByZXp1bWF0IGRlc3ByZSBmdW5jxaNpYSByYXN0ZXIuXCIsXG5cdGRlZmF1bHRIZWxwVGV4dDogXCJEYcibaSBjbGljIHBlIHNpbWJvbHVsIGRlIGFqdXRvciBwZW50cnUgYSBlZGl0YSB0ZXh0dWwgZGUgYXNpc3RlbsibxINcIixcblx0ZWRpdEhlbHBUaXRsZTogXCJBc2lzdGVuyJvEgyBwZW50cnUgZWRpdGFyZVwiLFxuXHRzYXZlTGFiZWw6IFwiU2FsdmHIm2lcIixcblx0Y2FuY2VsTGFiZWw6IFwiQW51bGFyZVwiLFxuXHR0aHVtYm5haWw6IHtcblx0XHR3cm9uZ0ltYWdlVHlwZTogXCJBIGZvc3Qgc2VsZWN0YXQgdGlwdWwgZXJvbmF0IGRlIGltYWdpbmVcIixcblx0XHRub3RBdmFpbGFibGU6IFwiTWluaWF0dXLEgyBpbmRpc3BvbmliaWzEg1wiLFxuXHRcdGxvYWRFcnJvcjogXCJOdSBzLWEgcHV0dXQgw65uY8SDcmNhIGltYWdpbmVhXCIsXG5cdFx0Y2hvb3NlRmlsZTogXCJGYWNlxaNpIGNsaWMgcGUgc2VsZWN0YXJlYSBmacWfaWVydWx1aVwiXG5cdH1cbn07XG5jb25zdCBzYXZlVXRpbHMgPSB7XG5cdHRodW1ibmFpbDogXCJNaW5pYXR1csSDXCIsXG5cdHNoYXJpbmc6IFwiUGFydGFqYXJlXCJcbn07XG5jb25zdCBjbG9zZSA9IFwiw45uY2hpZGVyZVwiO1xuY29uc3QgdW5zYXZlZFdhcm5pbmdFeGlzdGluZyA9IFwiRG9yacWjaSBzxIMgc2FsdmHFo2kgbW9kaWZpY8SDcmlsZSBhZHVzZSBlbGVtZW50dWx1aSA8Yj4ke2l0ZW1UaXRsZX08L2I+ID9cIjtcbmNvbnN0IHVuc2F2ZWRXYXJuaW5nTmV3ID0gXCJEb3JpxaNpIHPEgyBzYWx2YcibaSBtb2RpZmljxINyaWxlP1wiO1xuY29uc3Qgc2F2ZUFzID0gXCJTYWx2YXJlIGNhXCI7XG5jb25zdCBkb250U2F2ZSA9IFwiTnUgc2Ugc2FsdmVhesSDXCI7XG5jb25zdCB1bnNhdmVkVGl0bGUgPSBcIk1vZGlmaWPEg3JpIG5lc2FsdmF0ZVwiO1xuY29uc3QgaW52YWxpZFJGVE1lc3NhZ2UgPSBcIsiYYWJsb251bCBkZSBmdW5jyJtpZSByYXN0ZXIgY3JlYXQgbnUgZXN0ZSB2YWxhYmlsLlwiO1xuY29uc3QgZXJyb3JUaXRsZSA9IFwiRXJvYXJlXCI7XG5jb25zdCBicmVhZGNydW1iID0gXCJFZGl0b3IgZGUgZnVuY8ibaWUgcmFzdGVyXCI7XG5jb25zdCBicmVhZGNydW1iRWRpdG9yID0gXCJDb27Im2ludXQgPiBFZGl0b3IgZGUgZnVuY8ibaWUgcmFzdGVyXCI7XG5jb25zdCB2aWV3ZXJNb2RlVGl0bGUgPSBcIk51bWFpIGNpdGlyZVwiO1xuY29uc3Qgdmlld2VyTW9kZU1lc3NhZ2UgPSBcIkVsZW1lbnR1bCDImWFibG9uIGRlIGZ1bmPIm2llIHJhc3RlciBlc3RlIG51bWFpIHBlbnRydSBjaXRpcmUuIE1vZGlmaWPEg3JpbGUgbnUgcG90IGZpIHNhbHZhdGUuXCI7XG5jb25zdCB1c2VyU3RhcnREaXJlY3Rpb24gPSBcIlNlbGVjdGHIm2kgbyBmdW5jyJtpZSBwZW50cnUgYSDDrm5jZXBlIGNvbnN0cnVpcmVhIHVudWkgyJlhYmxvbiBkZSBmdW5jxaNpZSByYXN0ZXIuXCI7XG5jb25zdCBzZWxlY3RGdW5jdGlvbiA9IFwiQWTEg3VnYXJlIGZ1bmPIm2llXCI7XG5jb25zdCBkZXNlbGVjdEZ1bmN0aW9uID0gXCJFbGltaW5hcmUgZnVuY8ibaWVcIjtcbmNvbnN0IGRpYWxvZ1RpdGxlID0gXCJTaXN0ZW1cIjtcbmNvbnN0IGNhdGVnb3J5ID0gXCJDYXRlZ29yaWlcIjtcbmNvbnN0IHNlYXJjaCA9IFwiQ8SDdXRhyJtpIGZ1bmPFo2lpIHJhc3RlclwiO1xuY29uc3QgY2F0ZWdvcnlOYW1lcyA9IHtcblx0YW5hbHlzaXM6IFwiQW5hbGl6xINcIixcblx0YXBwZWFyYW5jZTogXCJBc3BlY3RcIixcblx0Y2xhc3NpZmljYXRpb246IFwiQ2xhc2lmaWNhcmVcIixcblx0Y29udmVyc2lvbjogXCJDb252ZXJzaWVcIixcblx0Y29ycmVjdGlvbjogXCJDb3JlY8WjaWVcIixcblx0ZGF0YU1hbmFnZW1lbnQ6IFwiQWRtaW5pc3RyYXJlIGRhdGVcIixcblx0ZGlzdGFuY2U6IFwiRGlzdGFuyJvEg1wiLFxuXHRkaXN0YW5jZUxlZ2FjeTogXCJEaXN0YW7Im8SDIChMZWdhY3kpXCIsXG5cdGh5ZHJvbG9neTogXCJIaWRyb2xvZ2llXCIsXG5cdG1hdGg6IFwiTWF0ZW1hdGljxINcIixcblx0bWF0aENvbmRpdGlvbmFsOiBcIk1hdGVtYXRpY8SDOiBDb25kacibaW9uYWxcIixcblx0bWF0aExvZ2ljYWw6IFwiTWF0ZW1hdGljxIM6IExvZ2ljxINcIixcblx0bWF0aFRyaWdvbm9tZXRyaWM6IFwiTWF0ZW1hdGljxIM6IHRyaWdvbm9tZXRyaWVcIixcblx0cmVjbGFzczogXCJSZWNsYXNpZmljYXJlXCIsXG5cdHN0YXRpc3RpY2FsOiBcIlN0YXRpc3RpY1wiLFxuXHRzdXJmYWNlOiBcIlN1cHJhZmHIm8SDXCJcbn07XG5jb25zdCBjb21tb25TdHJpbmdzX3JvID0ge1xuXHRvazogb2ssXG5cdGNhbmNlbDogY2FuY2VsLFxuXHRlbnRlclVSTDogZW50ZXJVUkwsXG5cdHNlcnZpY2VVUkw6IHNlcnZpY2VVUkwsXG5cdHNlbGVjdFJhc3Rlcjogc2VsZWN0UmFzdGVyLFxuXHRmYWlsZWRUb0xvYWRMYXllcjogZmFpbGVkVG9Mb2FkTGF5ZXIsXG5cdGxvYWRpbmdMYXllcjogbG9hZGluZ0xheWVyLFxuXHRzZWxlY3RGZWF0dXJlOiBzZWxlY3RGZWF0dXJlLFxuXHRlbnRlckZVUkw6IGVudGVyRlVSTCxcblx0YWRkUmFzdGVyOiBhZGRSYXN0ZXIsXG5cdGFkZFNjYWxhcjogYWRkU2NhbGFyLFxuXHRyYXN0ZXI6IHJhc3Rlcixcblx0c2NhbGFyOiBzY2FsYXIsXG5cdGRlZmF1bHRNb2RlbE5hbWU6IGRlZmF1bHRNb2RlbE5hbWUsXG5cdGdlbmVyYWw6IGdlbmVyYWwsXG5cdHBhcmFtZXRlcnM6IHBhcmFtZXRlcnMsXG5cdHZhcmlhYmxlczogdmFyaWFibGVzLFxuXHRuYW1lOiBuYW1lLFxuXHRkZXNjcmlwdGlvbjogZGVzY3JpcHRpb24sXG5cdHBhcmFtZXRlcjogcGFyYW1ldGVyLFxuXHRpc1B1YmxpYzogaXNQdWJsaWMsXG5cdGlzRGF0YXNldDogaXNEYXRhc2V0LFxuXHR1bmtub3duUGl4ZWxUeXBlOiB1bmtub3duUGl4ZWxUeXBlLFxuXHRvdXRwdXRQaXhlbFR5cGU6IG91dHB1dFBpeGVsVHlwZSxcblx0dThQaXhlbFR5cGU6IHU4UGl4ZWxUeXBlLFxuXHRzOFBpeGVsVHlwZTogczhQaXhlbFR5cGUsXG5cdHUxNlBpeGVsVHlwZTogdTE2UGl4ZWxUeXBlLFxuXHRzMTZQaXhlbFR5cGU6IHMxNlBpeGVsVHlwZSxcblx0dTMyUGl4ZWxUeXBlOiB1MzJQaXhlbFR5cGUsXG5cdHMzMlBpeGVsVHlwZTogczMyUGl4ZWxUeXBlLFxuXHRmMzJQaXhlbFR5cGU6IGYzMlBpeGVsVHlwZSxcblx0ZjY0UGl4ZWxUeXBlOiBmNjRQaXhlbFR5cGUsXG5cdHByb3BlcnRpZXM6IHByb3BlcnRpZXMsXG5cdG11bHRpZGltZW5zaW9uYWxSdWxlczogbXVsdGlkaW1lbnNpb25hbFJ1bGVzLFxuXHRtYXRjaFZhcmlhYmxlczogbWF0Y2hWYXJpYWJsZXMsXG5cdHVuaW9uRGltZW5zaW9uczogdW5pb25EaW1lbnNpb25zLFxuXHRyYXN0ZXJGdW5jdGlvbkVkaXRvcjogcmFzdGVyRnVuY3Rpb25FZGl0b3IsXG5cdHJmeExpY2Vuc2VJbmZvOiByZnhMaWNlbnNlSW5mbyxcblx0cmFzdGVyRnVuY3Rpb25zOiByYXN0ZXJGdW5jdGlvbnMsXG5cdGNvcHk6IGNvcHksXG5cdHNhdmU6IHNhdmUsXG5cdHRpdGxlOiB0aXRsZSxcblx0Zm9sZGVyOiBmb2xkZXIsXG5cdHRhZ3M6IHRhZ3MsXG5cdHNhdmluZ01lc3NhZ2U6IHNhdmluZ01lc3NhZ2UsXG5cdHNoYXJlV2l0aDogc2hhcmVXaXRoLFxuXHRzaGFyZTogc2hhcmUsXG5cdHNldFNoYXJpbmdMZXZlbDogc2V0U2hhcmluZ0xldmVsLFxuXHRzZXRHcm91cFNoYXJpbmc6IHNldEdyb3VwU2hhcmluZyxcblx0b3duZXI6IG93bmVyLFxuXHRvcmdhbml6YXRpb246IG9yZ2FuaXphdGlvbixcblx0ZXZlcnlvbmU6IGV2ZXJ5b25lLFxuXHRncm91cHM6IGdyb3Vwcyxcblx0dHlwZTogdHlwZSxcblx0bW9zYWljOiBtb3NhaWMsXG5cdGl0ZW1Hcm91cDogaXRlbUdyb3VwLFxuXHRpdGVtOiBpdGVtLFxuXHRkZWZpbml0aW9uUXVlcnk6IGRlZmluaXRpb25RdWVyeSxcblx0Z3JvdXBJdGVtc0J5OiBncm91cEl0ZW1zQnksXG5cdGdyb3VwRmllbGROYW1lOiBncm91cEZpZWxkTmFtZSxcblx0dGFnRmllbGROYW1lOiB0YWdGaWVsZE5hbWUsXG5cdG5vVGl0bGVUYWdFcnJvck1zZzogbm9UaXRsZVRhZ0Vycm9yTXNnLFxuXHRub1RpdGxlRXJyb3JNc2c6IG5vVGl0bGVFcnJvck1zZyxcblx0bm9UYWdFcnJvck1zZzogbm9UYWdFcnJvck1zZyxcblx0ZXJyb3I6IGVycm9yLFxuXHR3YXJuaW5nOiB3YXJuaW5nLFxuXHRzdWNjZXNzOiBzdWNjZXNzLFxuXHRkZXRhaWxzOiBkZXRhaWxzLFxuXHR0cnlBZ2FpbjogdHJ5QWdhaW4sXG5cdHRvb2xNb2RlbGVyOiB0b29sTW9kZWxlcixcblx0dG9vbEVkaXRvcjogdG9vbEVkaXRvcixcblx0dG9vbERldGFpbHNFZGl0b3I6IHRvb2xEZXRhaWxzRWRpdG9yLFxuXHRzYXZlVXRpbHM6IHNhdmVVdGlscyxcblx0Y2xvc2U6IGNsb3NlLFxuXHR1bnNhdmVkV2FybmluZ0V4aXN0aW5nOiB1bnNhdmVkV2FybmluZ0V4aXN0aW5nLFxuXHR1bnNhdmVkV2FybmluZ05ldzogdW5zYXZlZFdhcm5pbmdOZXcsXG5cdHNhdmVBczogc2F2ZUFzLFxuXHRkb250U2F2ZTogZG9udFNhdmUsXG5cdHVuc2F2ZWRUaXRsZTogdW5zYXZlZFRpdGxlLFxuXHRpbnZhbGlkUkZUTWVzc2FnZTogaW52YWxpZFJGVE1lc3NhZ2UsXG5cdGVycm9yVGl0bGU6IGVycm9yVGl0bGUsXG5cdGJyZWFkY3J1bWI6IGJyZWFkY3J1bWIsXG5cdGJyZWFkY3J1bWJFZGl0b3I6IGJyZWFkY3J1bWJFZGl0b3IsXG5cdHZpZXdlck1vZGVUaXRsZTogdmlld2VyTW9kZVRpdGxlLFxuXHR2aWV3ZXJNb2RlTWVzc2FnZTogdmlld2VyTW9kZU1lc3NhZ2UsXG5cdHVzZXJTdGFydERpcmVjdGlvbjogdXNlclN0YXJ0RGlyZWN0aW9uLFxuXHRzZWxlY3RGdW5jdGlvbjogc2VsZWN0RnVuY3Rpb24sXG5cdGRlc2VsZWN0RnVuY3Rpb246IGRlc2VsZWN0RnVuY3Rpb24sXG5cdGRpYWxvZ1RpdGxlOiBkaWFsb2dUaXRsZSxcblx0Y2F0ZWdvcnk6IGNhdGVnb3J5LFxuXHRzZWFyY2g6IHNlYXJjaCxcblx0Y2F0ZWdvcnlOYW1lczogY2F0ZWdvcnlOYW1lc1xufTtcblxuZXhwb3J0IGRlZmF1bHQgY29tbW9uU3RyaW5nc19ybztcbmV4cG9ydCB7IGFkZFJhc3RlciwgYWRkU2NhbGFyLCBicmVhZGNydW1iLCBicmVhZGNydW1iRWRpdG9yLCBjYW5jZWwsIGNhdGVnb3J5LCBjYXRlZ29yeU5hbWVzLCBjbG9zZSwgY29weSwgZGVmYXVsdE1vZGVsTmFtZSwgZGVmaW5pdGlvblF1ZXJ5LCBkZXNjcmlwdGlvbiwgZGVzZWxlY3RGdW5jdGlvbiwgZGV0YWlscywgZGlhbG9nVGl0bGUsIGRvbnRTYXZlLCBlbnRlckZVUkwsIGVudGVyVVJMLCBlcnJvciwgZXJyb3JUaXRsZSwgZXZlcnlvbmUsIGYzMlBpeGVsVHlwZSwgZjY0UGl4ZWxUeXBlLCBmYWlsZWRUb0xvYWRMYXllciwgZm9sZGVyLCBnZW5lcmFsLCBncm91cEZpZWxkTmFtZSwgZ3JvdXBJdGVtc0J5LCBncm91cHMsIGludmFsaWRSRlRNZXNzYWdlLCBpc0RhdGFzZXQsIGlzUHVibGljLCBpdGVtLCBpdGVtR3JvdXAsIGxvYWRpbmdMYXllciwgbWF0Y2hWYXJpYWJsZXMsIG1vc2FpYywgbXVsdGlkaW1lbnNpb25hbFJ1bGVzLCBuYW1lLCBub1RhZ0Vycm9yTXNnLCBub1RpdGxlRXJyb3JNc2csIG5vVGl0bGVUYWdFcnJvck1zZywgb2ssIG9yZ2FuaXphdGlvbiwgb3V0cHV0UGl4ZWxUeXBlLCBvd25lciwgcGFyYW1ldGVyLCBwYXJhbWV0ZXJzLCBwcm9wZXJ0aWVzLCByYXN0ZXIsIHJhc3RlckZ1bmN0aW9uRWRpdG9yLCByYXN0ZXJGdW5jdGlvbnMsIHJmeExpY2Vuc2VJbmZvLCBzMTZQaXhlbFR5cGUsIHMzMlBpeGVsVHlwZSwgczhQaXhlbFR5cGUsIHNhdmUsIHNhdmVBcywgc2F2ZVV0aWxzLCBzYXZpbmdNZXNzYWdlLCBzY2FsYXIsIHNlYXJjaCwgc2VsZWN0RmVhdHVyZSwgc2VsZWN0RnVuY3Rpb24sIHNlbGVjdFJhc3Rlciwgc2VydmljZVVSTCwgc2V0R3JvdXBTaGFyaW5nLCBzZXRTaGFyaW5nTGV2ZWwsIHNoYXJlLCBzaGFyZVdpdGgsIHN1Y2Nlc3MsIHRhZ0ZpZWxkTmFtZSwgdGFncywgdGl0bGUsIHRvb2xEZXRhaWxzRWRpdG9yLCB0b29sRWRpdG9yLCB0b29sTW9kZWxlciwgdHJ5QWdhaW4sIHR5cGUsIHUxNlBpeGVsVHlwZSwgdTMyUGl4ZWxUeXBlLCB1OFBpeGVsVHlwZSwgdW5pb25EaW1lbnNpb25zLCB1bmtub3duUGl4ZWxUeXBlLCB1bnNhdmVkVGl0bGUsIHVuc2F2ZWRXYXJuaW5nRXhpc3RpbmcsIHVuc2F2ZWRXYXJuaW5nTmV3LCB1c2VyU3RhcnREaXJlY3Rpb24sIHZhcmlhYmxlcywgdmlld2VyTW9kZU1lc3NhZ2UsIHZpZXdlck1vZGVUaXRsZSwgd2FybmluZyB9O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb21tb24tc3RyaW5ncy5yby1kYjZiNDY5NC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=