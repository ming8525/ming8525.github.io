"use strict";
(self["webpackChunkexb_client"] = self["webpackChunkexb_client"] || []).push([["vendors-extensions_widgets_arcgis_analysis_node_modules_arcgis_arcgis-raster-function-editor_-3cf368"],{

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/arcgis-raster-function-editor/dist/esm/common-strings.pt-PT-8f1cba9a.js":
/*!*****************************************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/arcgis-raster-function-editor/dist/esm/common-strings.pt-PT-8f1cba9a.js ***!
  \*****************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   addRaster: () => (/* binding */ addRaster),
/* harmony export */   addScalar: () => (/* binding */ addScalar),
/* harmony export */   breadcrumb: () => (/* binding */ breadcrumb),
/* harmony export */   breadcrumbEditor: () => (/* binding */ breadcrumbEditor),
/* harmony export */   cancel: () => (/* binding */ cancel),
/* harmony export */   category: () => (/* binding */ category),
/* harmony export */   categoryNames: () => (/* binding */ categoryNames),
/* harmony export */   close: () => (/* binding */ close),
/* harmony export */   copy: () => (/* binding */ copy),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   defaultModelName: () => (/* binding */ defaultModelName),
/* harmony export */   definitionQuery: () => (/* binding */ definitionQuery),
/* harmony export */   description: () => (/* binding */ description),
/* harmony export */   deselectFunction: () => (/* binding */ deselectFunction),
/* harmony export */   details: () => (/* binding */ details),
/* harmony export */   dialogTitle: () => (/* binding */ dialogTitle),
/* harmony export */   dontSave: () => (/* binding */ dontSave),
/* harmony export */   enterFURL: () => (/* binding */ enterFURL),
/* harmony export */   enterURL: () => (/* binding */ enterURL),
/* harmony export */   error: () => (/* binding */ error),
/* harmony export */   errorTitle: () => (/* binding */ errorTitle),
/* harmony export */   everyone: () => (/* binding */ everyone),
/* harmony export */   f32PixelType: () => (/* binding */ f32PixelType),
/* harmony export */   f64PixelType: () => (/* binding */ f64PixelType),
/* harmony export */   failedToLoadLayer: () => (/* binding */ failedToLoadLayer),
/* harmony export */   folder: () => (/* binding */ folder),
/* harmony export */   general: () => (/* binding */ general),
/* harmony export */   groupFieldName: () => (/* binding */ groupFieldName),
/* harmony export */   groupItemsBy: () => (/* binding */ groupItemsBy),
/* harmony export */   groups: () => (/* binding */ groups),
/* harmony export */   invalidRFTMessage: () => (/* binding */ invalidRFTMessage),
/* harmony export */   isDataset: () => (/* binding */ isDataset),
/* harmony export */   isPublic: () => (/* binding */ isPublic),
/* harmony export */   item: () => (/* binding */ item),
/* harmony export */   itemGroup: () => (/* binding */ itemGroup),
/* harmony export */   loadingLayer: () => (/* binding */ loadingLayer),
/* harmony export */   matchVariables: () => (/* binding */ matchVariables),
/* harmony export */   mosaic: () => (/* binding */ mosaic),
/* harmony export */   multidimensionalRules: () => (/* binding */ multidimensionalRules),
/* harmony export */   name: () => (/* binding */ name),
/* harmony export */   noTagErrorMsg: () => (/* binding */ noTagErrorMsg),
/* harmony export */   noTitleErrorMsg: () => (/* binding */ noTitleErrorMsg),
/* harmony export */   noTitleTagErrorMsg: () => (/* binding */ noTitleTagErrorMsg),
/* harmony export */   ok: () => (/* binding */ ok),
/* harmony export */   organization: () => (/* binding */ organization),
/* harmony export */   outputPixelType: () => (/* binding */ outputPixelType),
/* harmony export */   owner: () => (/* binding */ owner),
/* harmony export */   parameter: () => (/* binding */ parameter),
/* harmony export */   parameters: () => (/* binding */ parameters),
/* harmony export */   properties: () => (/* binding */ properties),
/* harmony export */   raster: () => (/* binding */ raster),
/* harmony export */   rasterFunctionEditor: () => (/* binding */ rasterFunctionEditor),
/* harmony export */   rasterFunctions: () => (/* binding */ rasterFunctions),
/* harmony export */   rfxLicenseInfo: () => (/* binding */ rfxLicenseInfo),
/* harmony export */   s16PixelType: () => (/* binding */ s16PixelType),
/* harmony export */   s32PixelType: () => (/* binding */ s32PixelType),
/* harmony export */   s8PixelType: () => (/* binding */ s8PixelType),
/* harmony export */   save: () => (/* binding */ save),
/* harmony export */   saveAs: () => (/* binding */ saveAs),
/* harmony export */   saveUtils: () => (/* binding */ saveUtils),
/* harmony export */   savingMessage: () => (/* binding */ savingMessage),
/* harmony export */   scalar: () => (/* binding */ scalar),
/* harmony export */   search: () => (/* binding */ search),
/* harmony export */   selectFeature: () => (/* binding */ selectFeature),
/* harmony export */   selectFunction: () => (/* binding */ selectFunction),
/* harmony export */   selectRaster: () => (/* binding */ selectRaster),
/* harmony export */   serviceURL: () => (/* binding */ serviceURL),
/* harmony export */   setGroupSharing: () => (/* binding */ setGroupSharing),
/* harmony export */   setSharingLevel: () => (/* binding */ setSharingLevel),
/* harmony export */   share: () => (/* binding */ share),
/* harmony export */   shareWith: () => (/* binding */ shareWith),
/* harmony export */   success: () => (/* binding */ success),
/* harmony export */   tagFieldName: () => (/* binding */ tagFieldName),
/* harmony export */   tags: () => (/* binding */ tags),
/* harmony export */   title: () => (/* binding */ title),
/* harmony export */   toolDetailsEditor: () => (/* binding */ toolDetailsEditor),
/* harmony export */   toolEditor: () => (/* binding */ toolEditor),
/* harmony export */   toolModeler: () => (/* binding */ toolModeler),
/* harmony export */   tryAgain: () => (/* binding */ tryAgain),
/* harmony export */   type: () => (/* binding */ type),
/* harmony export */   u16PixelType: () => (/* binding */ u16PixelType),
/* harmony export */   u32PixelType: () => (/* binding */ u32PixelType),
/* harmony export */   u8PixelType: () => (/* binding */ u8PixelType),
/* harmony export */   unionDimensions: () => (/* binding */ unionDimensions),
/* harmony export */   unknownPixelType: () => (/* binding */ unknownPixelType),
/* harmony export */   unsavedTitle: () => (/* binding */ unsavedTitle),
/* harmony export */   unsavedWarningExisting: () => (/* binding */ unsavedWarningExisting),
/* harmony export */   unsavedWarningNew: () => (/* binding */ unsavedWarningNew),
/* harmony export */   userStartDirection: () => (/* binding */ userStartDirection),
/* harmony export */   variables: () => (/* binding */ variables),
/* harmony export */   viewerModeMessage: () => (/* binding */ viewerModeMessage),
/* harmony export */   viewerModeTitle: () => (/* binding */ viewerModeTitle),
/* harmony export */   warning: () => (/* binding */ warning)
/* harmony export */ });
const ok = "Ok";
const cancel = "Cancelar";
const enterURL = "Introduzir URL de serviço de imagem";
const serviceURL = "URL de Serviço";
const selectRaster = "Selecionar Raster";
const failedToLoadLayer = "Falha ao carregar a Camada";
const loadingLayer = "A carregar camada";
const selectFeature = "Selecionar Camada de Elementos";
const enterFURL = "Introduzir URL de Serviço de Elementos";
const addRaster = "Adicionar variável raster";
const addScalar = "Adicionar constante";
const raster = "Raster";
const scalar = "Escalar";
const defaultModelName = "Modelo de Função Raster";
const general = "Geral";
const parameters = "Parâmetros";
const variables = "Variáveis";
const name = "Nome";
const description = "Descrição";
const parameter = "Parâmetro";
const isPublic = "IsPublic";
const isDataset = "IsDataset";
const unknownPixelType = "Desconhecido";
const outputPixelType = "Tipo de pixel de saída";
const u8PixelType = "8 Bit não registado";
const s8PixelType = "8 Bit registado";
const u16PixelType = "16 Bit não registado";
const s16PixelType = "16 Bit registado";
const u32PixelType = "32 Bit não registado";
const s32PixelType = "32 Bit registado";
const f32PixelType = "32 Bit flutuante";
const f64PixelType = "64 Bit duplo";
const properties = "Propriedades";
const multidimensionalRules = "Regras Multidimensionais";
const matchVariables = "Corresponder Variáveis";
const unionDimensions = "Dimensões da União";
const rasterFunctionEditor = {
	invalidRFTMessage: "O Modelo de Função Raster não é válido.",
	rfxArgsEditor: {
		outputRaster: "OutputRaster",
		raster: "Raster",
		unsupportedDataTypeWarning: "Os seguintes argumentos não são exibidos, já que não são atualmente suportados.",
		unsupportedFunction: "Contém uma ou mais funções raster atualmente não suportadas."
	},
	rfxRasterInput: {
		selectLayer: "Selecionar Camada",
		browseLayers: "Procurar Camadas",
		rfxVariable: "RasterFunctionVariable"
	},
	rfxBandCombinationEditor: {
		methodLabel: "Método",
		bandLabel: "Banda",
		combinationLabel: "Combinação"
	},
	rfxRemapGrid: {
		minimum: "Mínimo",
		maximum: "Máximo",
		output: "Saída",
		noData: "NoData",
		remapValuesLabel: "Voltar a Cartografar Valores"
	},
	rfxNamedRasterEditor: {
		rasterVariables: "Variáveis Raster",
		deleteSelectedVars: "Remover variáveis selecionadas"
	},
	rfxClippingGeometry: {
		clippingLayer: "Camada de Recorte",
		clippingRaster: "Recortar Raster",
		clippingGeometry: "Geometria de Recorte",
		customExtent: "Extensão personalizada",
		outputExtent: "Extensão de Saída",
		currentExtent: "Extensão mapa atual",
		drawLabel: "Desenhar"
	},
	rfxCustomExtent: {
		top: "Superior",
		right: "Direita",
		bottom: "Inferior",
		left: "Esquerda"
	},
	rfxRasterArrayEditor: {
		moveUp: "Mover para cima",
		moveDown: "Mover para baixo",
		remove: "Remover"
	},
	rfxStatisticsGrid: {
		stdDev: "Desvio Dev",
		min: "Mín.",
		max: "Máx.",
		mean: "Média"
	},
	rfxWeightedSumTableEditor: {
		weightedSumTable: "Tabela de Soma Ponderada",
		id: "ID",
		layer: "Camada",
		field: "Campo",
		weight: "Peso",
		value: "Valor",
		selectLayer: "Selecionar Camada"
	},
	rfxWeightedOverlayTableEditor: {
		weightedOverlayTable: "Tabela de Sobreposição Ponderada",
		id: "ID",
		layer: "Camada",
		field: "Campo",
		influence: "Influência",
		sumOfInfluence: "Soma de influência",
		value: "Valor",
		remapTable: "Voltar a Cartografar Tabela",
		scale: "Escala",
		scales: "Escalas",
		selectRaster: "Selecionar Raster"
	},
	rfxFeatureSelect: {
		addFeatureLayer: "Procurar uma camada de elementos",
		addPointLayer: "Procurar uma camada de pontos"
	},
	rfxFieldSelect: {
		value: "Valor",
		count: "Contagem"
	},
	rfxAttributeTable: {
		tableType: "Tipo de Tabela",
		manual: "Manual",
		external: "Externo",
		minVal: "Valor Mínimo",
		maxVal: "Valor Máximo",
		baseClassName: "Nome Base da Classe",
		colorScheme: "Esquema de Cores",
		defaultClassName: "Rótulo_",
		generateTable: "Criar tabela",
		browseTable: "Pesquisar Tabela",
		value: "Valor",
		classname: "ClassName",
		color: "Cor"
	},
	rfxFieldNumberSwitchable: {
		number: "Numérico",
		field: "Campo",
		string: "Texto",
		linearUnit: "Unidade Linear"
	},
	rfxPropertySet: {
		name: "Nome",
		value: "Valor"
	},
	rfxConversionGrid: {
		size: "Tamanho"
	},
	rfxTransposeBit: {
		bitPattern: "Padrão de Bits",
		outputBit: "Bit saída",
		inputBit: "Bit entrada"
	},
	rfxSpatialReference: {
		placeHolder: "Refine por Palavra-chave",
		coordinateSystem: "Sistema de Coordenadas",
		gcs: "Sistema de Coordenadas Geográficas",
		pcs: "Sistema de Coordenadas Projectadas",
		vcs: "Coordenar Sistema Vertical"
	}
};
const rfxLicenseInfo = "Este modelo de função raster pode ser utilizado para processar as suas imagens ao usar o ArcGIS Image Server.";
const rasterFunctions = {
	rfx: {
		aCosHName: "ACosH",
		aCosHSnip: "Calcula o cosseno hiperbólico inverso das células num raster.",
		aCosHDesc: "A função calcula o cosseno hiperbólico inverso dos píxeis num raster.",
		aCosName: "ACos",
		aCosSnip: "Calcula o cosseno inverso de píxeis num raster.",
		aCosDesc: "Esta função raster calcula o cosseno inverso das células num raster. Em matemática, todas as funções trigonométricas têm um intervalo definido de valores de entrada válidos, chamado domínio. Os valores de saída de cada função têm também um intervalo definido. Para esta ferramenta, o domínio é [-1, 1], e o intervalo é [0, pi].",
		aSinHName: "ASinH",
		aSinHSnip: "Calcula o seno hiperbólico inverso das células num raster.",
		aSinHDesc: "A função calcula o seno hiperbólico inverso dos píxeis num raster.",
		aSinName: "ASin",
		aSinSnip: "Calcula o seno inverso das células num raster.",
		aSinDesc: "A função calcula o seno inverso dos píxeis num raster.",
		aTan2Name: "ATan2",
		aTan2Snip: "Calcula a tangente inversa (baseada em x,y) das células num raster.",
		aTan2Desc: "A função calcula a tangente inversa (baseada em x,y) dos píxeis num raster.",
		aTanHName: "ATanH",
		aTanHSnip: "Calcula a tangente hiperbólica inversa das células num raster.",
		aTanHDesc: "A função calcula a tangente hiperbólica inversa dos píxeis num raster.",
		aTanName: "ATan",
		aTanSnip: "Calcula a tangente inversa das células num raster.",
		aTanDesc: "A função calcula a tangente inversa dos píxeis num raster.",
		absName: "Abs",
		absSnip: "Calcula o valor absoluto dos píxeis num raster.",
		absDesc: "A função Abs calcula o valor absoluto dos píxeis num raster.",
		reflectanceName: "Refletância Aparente",
		reflectanceSnip: "Converte imagens brutas em valores de Topo da Atmosfera levando em consideração as características do sensor da conta, a posição do sol e a hora da aquisição.",
		reflectanceDesc: "Esta função ajusta os valores referentes ao número digital (DN) do brilho da imagem para alguns sensores satélite. Os ajustes são baseados na elevação do sol, data da aquisição e propriedades do sensor para definir o ganho e a tendência para cada banda. Esta função é utilizada para ajustar os valores de reflexão e brilho de algumas imagens de satélite baseadas na iluminação da cena e das configurações de ganho do sensor. As imagens são ajustadas a uma condição de iluminação comum teórica, o que significa que deverá haver menos variação entre cenas de diferentes datas e diferentes sensores. Isto pode ser útil para a classificação de imagens, balanceamento de cores e construção de mosaicos. Esta função apenas pode ser utilizada com imagens específicas. Os sensores aplicáveis são o Landsat MSS, Landsat TM, Landsat ETM+, Landsat 8, IKONOS, QuickBird, GeoEye-1, RapidEye, DMCii, WorldView-1, WorldView-2, SPOT 6, e Pleiades.<div><br/>A função efetua duas correções. A primeira é baseada nas configurações do ganho. Os valores de brilho originais são recriados a partir dos valores da imagem invertendo as equações do ganho. A segunda correção está relacionada com diferenças no ângulo do sol e no brilho. Os valores de brilho originais são ajustados a uma condição de iluminação comum através de cenas normalizantes capturadas sob condições de iluminação variáveis. No geral, enquanto o tipo de dados de saída da imagem é o mesmo que o tipo de dados de entrada da imagem, os valores de saída são inferiores aos valores de entrada e estão contidos no intervalo de dados válidos.</div>",
		argStatisticsName: "ArgStatistics",
		argStatisticsSnip: "Calcula estatística arg incluindo Arg Max, Arg Min, Arg Median, e Duração.",
		argStatisticsDesc: "A função calcula estatística arg. Existem quatro métodos na função ArgStatistics: ArgMax, ArgMin, ArgMedian, e Duração.",
		arithmeticName: "Aritméticos",
		arithmeticSnip: "Executa uma operação aritmética entre dois rasters ou um raster e um escalar.",
		arithmeticDesc: "A função Aritmética executa uma operação aritmética entre dois rasters ou um raster e um escalar e vice-versa.",
		aspectSlopeName: "Aspeto-Inclinação",
		aspectSlopeSnip: "Cria um raster, que simultaneamente exibe o aspeto (direção) e a inclinação (declive) de uma superfície contínua, tal como é representado num modelo de elevação digital.",
		aspectSlopeDesc: "A função Aspeto Inclinação cria uma camada raster, que simultaneamente exibe o aspeto e a inclinação de uma superfície. O Aspeto identifica a direção de inclinação da taxa de variação máxima em valor entre cada píxel e os seus vizinhos. O aspeto pode ser visto como a direção da inclinação. Os valores do raster de saída serão a direção da bússola do aspeto, representado por uma tonalidade (cor). A inclinação representa a taxa de variação da elevação para cada píxel modelo de elevação digital (DEM). A inclinação representa o declive da superfície e é simbolizada através de três classes que são exibidas utilizando a saturação da cor (brilho).<div><br/>Os valores de píxeis no raster de aspeto-inclinação de saída refletem uma combinação de aspeto e inclinação. Píxeis com valores inferiores a 20 são considerados planos e são exibidos a cinzento. Os valores de aspeto-inclinação iguais e superiores a 21 serão apresentados com saturações variáveis da seguinte forma: 21 a 30 —Baixa saturação de inclinação, 31 a 40—Saturação de inclinação moderada, igual e superior a 41—Alta saturação de inclinação</div>",
		aspectName: "Aspeto",
		aspectSnip: "Mostra em que direção um píxel está orientado, onde 0 é para norte e os ângulos aumentam até 360 no sentido dos ponteiros do relógio.",
		aspectDesc: "A função Aspeto identifica a direção de inclinação da taxa de variação máxima em valor entre cada célula e os seus vizinhos. O aspeto pode ser visto como a direção da inclinação. Os valores do raster de saída serão a direção da bússola do aspeto.<div><br/>A entrada desta função é Raster de Entrada. A função Aspeto é muitas vezes aplicada a um modelo de elevação digital (DEM). Por defeito o aspeto aparece como uma escala de cinzentos. É possível adicionar a função Mapa de Cores para especificar um esquema de cores particular ou permitir que a pessoa que está a visualizar o mosaico possa modificar a simbologia com o seu próprio esquema de cores.</div>",
		tableName: "Tabela de Atributos",
		tableSnip: "Utiliza uma tabela para designar e simbolizar os valores num conjunto de dados. As colunas da tabela são delimitadas por vírgulas: PixelValue, AttributeName, RedValue, GreenValue, BlueValue.",
		tableDesc: "A função Tabela de Atributos permite definir uma tabela de atributos para simbolizar um conjunto de dados em mosaico de banda-única ou um conjunto de dados de um raster. <div><br/>Isto é útil quando pretende apresentar imagens que tenham sido submetidas a uma classificação de uso do solo, tal como terreno florestal, zonas húmidas, terras de cultivo e urbano. Adicionalmente, se a tabela contiver campos designados de vermelho, verde e azul, ao reproduzir a imagem, os valores dentro destes campos serão utilizados como um mapa de cores.</div>",
		bandArithmeticName: "Aritmética da Banda",
		bandArithmeticSnip: "Calcula índices utilizando fórmulas predefinidas ou expressões definidas pelo utilizador.",
		bandArithmeticDesc: "A função Banda Aritmética executa uma operação aritmética nas bandas do conjunto de dados de um raster. O utilizador pode escolher algoritmos predefinidos ou introduzir a sua própria fórmula de uma linha. Os operadores suportados são -,+,/,* e unário -.",
		thresholdName: "Limite Binário",
		thresholdSnip: "Organiza os dados contínuos entre primeiro plano e fundo minimizando a covariância entre as duas classes.",
		thresholdDesc: "Quando um conjunto de dados raster tem uma distribuição bimodal, esta função cria um novo raster, que divide os dados em duas classes diferentes. Cria uma classe de valores baixos exibida com píxeis pretos e uma classe de valores elevados exibida com píxeis brancos.",
		bitwiseAndName: "Bitwise E",
		bitwiseAndSnip: "Executa uma operação Bitwise E nos valores binários de dois rasters de entrada.",
		bitwiseAndDesc: "Bitwise E executa uma operação Bitwise E nos valores binários de dois rasters de entrada",
		bitwiseLeftShiftName: "Bitwise Esquerda Shift",
		bitwiseLeftShiftSnip: "Executa uma operação Bitwise Deslocamento à Esquerda nos valores binários de dois rasters de entrada.",
		bitwiseLeftShiftDesc: "A Bitwise Deslocamento à Esquerda executa uma operação Bitwise Deslocamento à Esquerda nos valores binários de dois rasters de entrada",
		bitwiseNotName: "Bitwise Não",
		bitwiseNotSnip: "Executa uma operação Bitwise Não nos valores binários de dois rasters de entrada.",
		bitwiseNotDesc: "A função executa uma operação Bitwise Não (complemento) nos valores binários de um raster de entrada.",
		bitwiseOrName: "Bitwise Ou",
		bitwiseOrSnip: "Executa uma operação Bitwise Ou nos valores binários de dois rasters de entrada.",
		bitwiseOrDesc: "A função executa uma operação Bitwise Ou nos valores binários de dois rasters de entrada. ",
		bitwiseRightShiftName: "Bitwise Direita Shift",
		bitwiseRightShiftSnip: "Executa uma operação Bitwise Deslocamento à Direita nos valores binários de dois rasters de entrada.",
		bitwiseRightShiftDesc: "A função executa uma operação Bitwise Deslocamento à Direita nos valores binários de dois rasters de entrada.",
		bitwiseXorName: "Bitwise Xou",
		bitwiseXorSnip: "Executa uma operação Bitwise Ou eXclusivo nos valores binários de dois rasters de entrada.",
		bitwiseXorDesc: "A função executa uma operação Bitwise Ou eXclusivo nos valores binários de dois rasters de entrada",
		booleanAndName: "Booleano E",
		booleanAndSnip: "Executa uma operação booleana E nos valores das células de dois rasters de entrada. Se ambos os valores de entrada forem verdadeiros (diferentes de zero), então, o valor de saída é 1. Se algum ou ambos as entradas forem falsos (zero), então, a saída é 0.",
		booleanAndDesc: "A função executa uma operação booleana E nos valores de píxel de duas entradas. Se ambos os valores de entrada forem verdadeiros (diferentes de zero), então, o valor de saída é 1. Se algum ou ambos os valores de entrada forem falsos (zero), então, o valor de saída é 0. ",
		booleanNotName: "Booleano Não",
		booleanNotSnip: "Executa uma operação booleana Não (complemento) nos valores das células do raster de entrada. Se os valores de entrada forem verdadeiros (diferentes de zero), então, o valor de saída é 0. Se algum ou ambos os valores de entrada forem falsos (zero), então, o valor de saída é 1.",
		booleanNotDesc: "A função executa uma operação booleana Não (complemento) nos valores de píxel do raster de entrada. Se os valores de entrada forem verdadeiros (diferentes de zero), então, o valor de saída é 0. Se algum ou ambos os valores de entrada forem falsos (zero), então, o valor de saída é 1.",
		booleanOrName: "Booleano Ou",
		booleanOrSnip: "Executa uma operação booleana Ou nos valores das células de dois rasters de entrada. Se algum ou ambos os valores de entrada forem verdadeiros (diferentes de zero), então, o valor de saída é 1. Se ambos os valores de entrada forem falsos (zero), então, o valor de saída é 0.",
		booleanOrDesc: "A função executa uma operação booleana Ou nos valores das células de dois rasters de entrada. Se algum ou ambos os valores de entrada forem verdadeiros (diferentes de zero), então, o valor de saída é 1. Se ambos os valores de entrada forem falsos (zero), então, o valor de saída é 0.",
		booleanXorName: "Booleano Xor",
		booleanXorSnip: "Executa uma operação booleana Ou eXclusivo nos valores das células de dois rasters de entrada. Se um valor de entrada for verdadeiro (diferente de zero) e o outro for falso (zero), então, o valor de saída é 1. Se ambos os valores de entrada forem verdadeiros ou ambos falsos, então, o valor de saída é 0.",
		booleanXorDesc: "A função executa uma operação booleana Ou eXclusivo nos valores das células de dois rasters de entrada. Se um valor de entrada for verdadeiro (diferente de zero) e o outro for falso (zero), então, o valor de saída é 1. Se ambos os valores de entrada forem verdadeiros ou ambos falsos, então, o valor de saída é 0.",
		bufferedRasterName: "Amortecido",
		bufferedRasterSnip: "Amortece o último bloco(s) de píxel acedido.",
		bufferedRasterDesc: "A função Amortecimento é utilizada para otimizar a performance de cadeias de funções complexas. Guarda a saída na memória da parte da cadeia da função que vem anteriormente. <div><br/>Insira esta função no Editor de Funções onde pretender armazenar a saída.</div>",
		rasterCalculatorName: "Calculadora",
		rasterCalculatorSnip: "Calcula um raster a partir de uma expressão matemática baseada num raster.",
		rasterCalculatorDesc: "A função Calculadora permite criar e correr expressões e incorporá-las nas cadeias de funções.",
		cellStatisticsName: "Estatística Celular",
		cellStatisticsSnip: "Calcula estatísticas de múltiplos rasters por célula. As estatísticas disponíveis são Maioria, Máximo, Média, Mediana, Mínimo, Minoria, Percentil, Intervalo, Desvio Padrão, Soma e Variedade.",
		cellStatisticsDesc: "Esta função executa cálculos de Estatística de múltiplos rasters, numa base de píxel a píxel. As estatísticas disponíveis são a maioria, máximo, média, mediana, mínimo, minoria, intervalo, desvio padrão, soma e variedade.",
		classifyName: "Classificar",
		classifySnip: "Atribui cada píxel a uma classe. Incorpora dados auxiliares, tais como uma imagem segmentada.",
		classifyDesc: "Esta função raster classifica um conjunto de dados raster baseado num ficheiro Esri Classifier Definition (.ecd) e num conjunto de dados raster de valores de entrada. O ficheiro .ecd utilizado na função Classificação contém toda a informação para um conjunto de dados específico e classificador e é gerado pelas ferramentas de treino de classificação, tais como o Train Support Vector Machine ou as ferramentas Train Random Trees.",
		clipName: "Recortar",
		clipSnip: "Define as medidas de um raster utilizando coordenadas ou outro conjunto de dados.",
		clipDesc: "Esta função recorta um raster utilizando uma forma retangular segundo as medidas definidas ou, então, vai recortar um raster segundo a forma da classe de caraterísticas de um polígono de entrada. A forma que define o recorte pode recortar as medidas do raster ou recortar uma área dentro do raster.",
		colorspaceConversionName: "Conversão do Modelo de Cores",
		colorspaceConversionSnip: "Converte um raster de RGB para HSV e vice-versa.",
		colorspaceConversionDesc: "A função Conversão de Modelo de Cores converte o modelo de cores de uma imagem de tonalidade, saturação e valor (HSV) de espaço cor para vermelho, verde e azul (RGB) ou vice-versa.<div><br/>Esta função pode ser utilizada num conjunto de dados de mosaico.</div>",
		colormapToRGBName: "Mapa de Cores para RGB",
		colormapToRGBSnip: "Converte um raster de banda-única com um mapa de cores num raster de três bandas (vermelho, verde e azul).",
		colormapToRGBDesc: "Esta função converte um raster de banda-única com um mapa de cores para um raster de três bandas (vermelho, verde e azul).<div><br/>Esta função é útil quando necessitar de criar um raster de três bandas a partir de um raster de banda única com um mapa de cor associado. Os valores no mapa de cores serão utilizados para criar cada banda vermelha, verde e azul. Esta função pode ser utilizada num conjunto de dados em mosaico.</div>",
		colormapName: "Mapa de Cores",
		colormapSnip: "Modifica os valores dos píxeis para exibir os dados raster ou como uma escala de cinzentos ou como uma imagem vermelha, verde e azul (RGB) baseada num mapa ou numa rampa de cores.",
		colormapDesc: "A função Mapa de Cores é um tipo de renderizador de dados raster. Transforma os valores do píxel para exibir os dados do raster como uma imagem na escala de cinzentos ou como uma imagem RGB baseada num esquema de cores ou num ficheiro de mapa de cores. É possível utilizar um mapa de cores para representar dados analisados, tal como uma imagem classificada ou ao exibir um mapa topográfico (ou o índice de uma imagem de cor digitalizada).<div><br/>Os mapas de cor contêm um conjunto de valores que estão associados a cores utilizadas para exibir um raster de banda única consistentemente com as mesmas cores. Cada valor de píxel está associado a uma cor definida como um conjunto de valores RGB. Os mapas de cores são capazes de suportar qualquer profundidade de bit com a exceção de ponto flutuante. Igualmente, suportam valores positivos e negativos e podem conter valores em falta de mapa de cores. Ao exibir um conjunto de dados com um mapa de cores contendo valores em falta, os píxeis com esses valores em falta não serão exibidos.</div>",
		complexName: "Complexo",
		complexSnip: "Extrai a magnitude de números complexos.",
		complexDesc: "Esta função calcula a magnitude de valores complexos.<div><br/>Esta função é tipicamente utilizada com imagens RADAR que têm um tipo de dados complexo. Pode ser utilizada num conjunto de dados em mosaico.</div>",
		compositeBandName: "Bandas Compostas",
		compositeBandSnip: "Combina múltiplos conjuntos de dados para um raster multibanda.",
		compositeBandDesc: "A função Bandas Compostas permite combinar rasters para formar uma imagem multibanda.",
		conName: "Con",
		conSnip: "Executa uma operação condicional If, Then, Else. Quando é utilizado um operador Con, costuma ser necessário existirem duas ou mais funções encadeadas, onde uma função dita o critério e a segunda é o operador Con, que utiliza o critério e dita quais deverão ser os valores de saída verdadeiros e falsos.",
		conDesc: "A função Con define os píxeis do raster de saída com base numa avaliação do if\\else de cada píxel de entrada. Devolve valores de píxel do Raster Verdadeiro no caso da avaliação condicional ser verdadeira (1) ou, então, valores de píxel do Raster Falso caso a avaliação condicional seja falsa (0). Este critério é definido pelo valor de saída de uma função matemática lógica, que será o Raster de entrada.",
		constantName: "Constante",
		constantSnip: "Cria um raster virtual com um único valor de píxel.",
		constantDesc: "Esta função cria um raster virtual com o valor de um único píxel, que pode ser utilizado em modelos de funções raster e para processar um conjunto de dados em mosaico.<div><br/>O valor da constante é utilizado para cada valor de píxel no raster.</div>",
		contourName: "Contorno",
		contourSnip: "Cria linhas de contorno.",
		contourDesc: "A função Contorno gera linhas de contorno juntando pontos com a mesma elevação de um conjunto de dados de elevação de raster. Os contornos são isolinhas criadas como rasters para visualização. As seguintes caraterísticas chave tornam esta função poderosa: os contornos são gerados de um modo rápido e dinâmico a partir de conjuntos de dados muito grandes, tal como a Elevação Mundial; os contornos podem ser suavizados para gerar uma aparência cartográfica mais apelativa mantendo, no entanto, a precisão do contorno; é fornecido controlo dinâmico sobre o intervalo de contorno; as opções de saída incluem linhas de contorno, contornos indexados e contornos preenchidos.<div><br/>A criação de uma camada de contorno como produto raster é valiosa para uma vasta gama de aplicações, uma vez que os contornos podem ser sobrepostos num mapa e fornecer informações sobre o terreno sem obscurecer os dados subjacentes. São úteis em aplicações como a engenharia, agricultura e a gestão de água.</div>",
		contrastBrightnessName: "Contraste e o Brilho",
		contrastBrightnessSnip: "Ajusta o contraste e o brilho de um raster.",
		contrastBrightnessDesc: "A função de Contraste e Brilho realça a aparência de dados raster modificando o brilho e o contraste dentro da imagem. O brilho aumenta a claridade geral da imagem — tornando as cores escuras mais claras e as e as cores claras mais brancas, por exemplo. —O contraste ajusta a diferença entre as cores mais escuras e as mais claras.<div><br/>A utilização desta função altera os valores de píxeis; portanto, deve ser utilizada quando se pretende melhorar a aparência dos dados e não se pretender utilizar os dados como parte de uma análise que requeira os valores de píxeis em bruto. Esta função é útil ao publicar os dados como um serviço de imagem, que pode ser utilizado em aplicações sem a capacidade de alterar o contraste e o brilho das imagens, ou para garantir que as exibe recorrendo às suas configurações preferidas.</div>",
		convolutionName: "Convolução",
		convolutionSnip: "Aplica um filtro para ajustar a nitidez, desfocar, detetar extremidades, uniformizar ou um gradiente ao longo de um raster.",
		convolutionDesc: "A função Convolução executa a filtragem dos valores de píxel numa imagem, que poderá ser utilizada para ajustar a nitidez de uma imagem, desfocar uma imagem, detetar as extremidades de uma imagem ou outras melhorias baseadas num kernel. Os filtros são utilizados para melhorar a qualidade da imagem raster ao eliminar dados artificiais ou aumentar as funcionalidades nos dados. Os filtros de convolução são aplicados num kernel em movimento e sobreposto (janela ou vizinhos), como um 3 por 3. Os filtros de convolução funcionam através do cálculo do valor de píxel com base nos pesos dos seus vizinhos.",
		corridorName: "Corredor",
		corridorSnip: "Calcula a soma de custos acumulados para os dois rasters acumulados de entrada.",
		corridorDesc: "A função de Corredor calcula a soma dos custos acumulados para dois rasters de custo acumulado de entrada. Apesar de qualquer par de rasters poder ser utilizado para a entrada, para obter um resultado significativo, deverão existir rasters de saída de custos acumulados inalterados. A ordem das duas entradas é irrelevante.",
		cosHName: "CosH",
		cosHSnip: "Calcula a cosseno hiperbólico das células num raster.",
		cosHDesc: "A função calcula o cosseno hiperbólico dos píxeis num raster.",
		cosName: "Cos",
		cosSnip: "Calcula o cosseno de uma célula num raster.",
		cosDesc: "A função calcula o cosseno dos píxeis num raster.",
		costAllocationName: "Atribuição de custos",
		costAllocationSnip: "Calcula, para cada célula, a sua origem mais económica com base no menor custo acumulado ao longo de uma superfície de custo.",
		costAllocationDesc: "A função de Atribuição de custos calcula, para cada célula, a sua origem mais económica com base no menor custo acumulado ao longo de uma superfície de custo.",
		costBackLinkName: "Ligação de Menor Custo",
		costBackLinkSnip: "Define o vizinho que é a célula seguinte no percurso de menor custo acumulado até à origem com menor custo.",
		costBackLinkDesc: "A função Ligação de Menor Custo define o vizinho que é a célula seguinte no percurso de menor custo acumulado até à origem com menor custo.<div><br/>O raster de ligação inversa contém valores de zero a oito, que definem a direção ou identificam a célula vizinha seguinte (a célula seguinte) ao longo do percurso de menor custo acumulado a partir de uma célula para atingir a sua origem de menor custo. Caso o percurso deva atravessar o vizinho direito, à célula deverá ser atribuído o valor 1, 2 para a célula diagonal inferior direita e por aí adiante no sentido dos ponteiros do relógio. O valor 0 é reservado para células de origem.</div>",
		costDistanceName: "Custo de distância",
		costDistanceSnip: "Calcula a distância com menor custo acumulado para cada célula a partir de, ou até à origem de menor custo ao longo de uma superfície de custo.",
		costDistanceDesc: "A Função de Custo de Distância calcula a distância com menor custo acumulado para cada célula a partir de, ou até à origem de menor custo ao longo de uma superfície de custo.",
		costPathName: "Percurso de custo",
		costPathSnip: "Calcula o percurso de menor custo a partir de uma origem até um destino.",
		costPathDesc: "A função de Percurso de custo global calcula o percurso de menor custo a partir de uma origem até um destino.<div><br/>Esta função produz um raster de saída que regista o percurso ou percursos de menor custo a partir de locais selecionados até à célula de origem mais próxima definida dentro da superfície de custo acumulado, em termos de distância de custo.</div>",
		curvatureName: "Curvatura",
		curvatureSnip: "Calcula a curvatura de uma superfície raster, opcionalmente incluindo a curvatura de plano e de perfil.",
		curvatureDesc: "A função de Curvatura exibe a forma ou curvatura do declive. Uma parte da superfície poderá ser côncava ou convexa; poderá saber ao observar o valor da curvatura. A curvatura é calculada através do cálculo da segunda derivada da superfície.<div><br/>A saída da função de Curvatura pode ser utilizada para descrever as características físicas de uma bacia de drenagem num esforço para compreender os processos de erosão e escoamento. O valor da curvatura poderá ser utilizado para descobrir padrões de erosão do solo assim como a distribuição de água pelos terrenos. A curvatura de perfil afeta a aceleração e desaceleração do fluxo e, como tal, influencia a erosão e a deposição. A curvatura da plataforma influencia a convergência e divergência do fluxo.</div>",
		divideName: "Dividir",
		divideSnip: "Divide os valores de dois rasters numa base célula a célula.",
		divideDesc: "A função de Divisão divide os valores de dois rasters numa base píxel a píxel.",
		elevationVoidFillName: "Preenchimento de vazio da elevação",
		elevationVoidFillSnip: "Cria píxeis onde existem buracos nos seus dados da elevação.",
		elevationVoidFillDesc: "A função de Preenchimento de Vazio da Elevação é utilizada para criar píxeis onde existem buracos na sua elevação.<div><br/>Os vazios ocorrem quando não há pontos recolhidos dentro da área representada por um píxel no raster resultante. Os vazios são muitas vezes provocados por corpos de água, seleção do tipo de classe ou exclusão. O preenchimento de vazio é normalmente utilizado durante a geração de uma superfície de solo.</div>",
		equalToName: "Igual A:",
		equalToSnip: "Realiza uma operação igual-a relacional em duas entradas numa base célula a célula. Devolve o valor 1 para células nas quais o primeiro raster iguala o segundo raster e 0 para células nas quais isso não acontece.",
		equalToDesc: "A função realiza uma operação de igual-a em dois rasters numa base píxel a píxel. Devolve o valor 1 para píxeis nos quais o primeiro raster iguala o segundo raster e o valor 0 para píxeis que não são iguais.",
		eucAllocationName: "Atribuição Euclidiana",
		eucAllocationSnip: "Calcula, para cada célula, a origem mais próxima com base na distância Euclidiana.",
		eucAllocationDesc: "A função de Atribuição Euclidiana calcula, para cada célula, a origem mais próxima com base na distância Euclidiana.",
		eucDirectionName: "Direção Euclidiana",
		eucDirectionSnip: "Calcula, para cada célula, a direção, em graus, para a origem mais próxima.",
		eucDirectionDesc: "A função de Direção Euclidiana calcula, para cada célula, a direção, em graus, para a origem mais próxima. <div><br/>A direção é calculada a partir de cada centro da célula até ao centro da célula de origem que lhe está mais próxima. O intervalo de valores vai dos 0 graus até aos 360 graus, com o 0 reservado para as células de origem. Para este (direita) está o valor 90 e os mesmos aumentam no sentido dos ponteiros do relógio (180 é sul, 270 é oeste e 360 é norte).</div>",
		eucDistanceName: "Distância Euclidiana",
		eucDistanceSnip: "Calcula, para cada célula, a distância Euclidiana até à origem mais próxima.",
		eucDistanceDesc: "A função de Distância Euclidiana calcula, para cada célula, a distância Euclidiana até à origem mais próxima.",
		exp10Name: "Exp10",
		exp10Snip: "Calcula o exponencial em base 10 das células num raster.",
		exp10Desc: "A função Exp 10 calcula o exponencial em base 10 dos píxeis num raster.",
		exp2Name: "Exp2",
		exp2Snip: "Calcula o exponencial em base 2 das células num raster.",
		exp2Desc: "Esta função calcula o exponencial em base 2 dos píxeis num raster.",
		expName: "Exp",
		expSnip: "Calcula o exponencial em base e das células num raster.",
		expDesc: "Esta função calcula o exponencial em base e dos píxeis num raster.",
		extractBandName: "Extrair Bandas",
		extractBandSnip: "Especifica que bandas utilizar, quando se utilizam conjuntos de dados multibanda.",
		extractBandDesc: " A função Extrair Bandas permite-lhe extrair uma ou mais bandas a partir de, ou reordena as bandas, um conjunto de dados de raster multibanda.<div><br/>Pode utilizar a função Extrair Bandas antes de outras funções, tais como Aritmética, para controlar quais as bandas que são utilizadas como entrada na função seguinte.</div>",
		fillName: "Preenchimento",
		fillSnip: "Preenche sumidouros num raster de superfície para remover pequenas imperfeições nos dados.",
		fillDesc: "A função de Preenchimento global localiza e preenche sumidouros e picos num raster de superfície de elevação para remover pequenas imperfeições nos dados. A função preencherá num processo iterativo até que todos os sumidouros estejam preenchidos dentro do limite Z especificado.<div><br/>Quando uma superfície de elevação é criada com ferramentas Ortocartografia ou por outros meios, existem frequentemente erros pequenos, mas significativos na forma de coletores e picos nos dados. Em fotogrametria, sumidouros e picos são muitas vezes referidos como buracos e estacas. Uma vez que os dados de superfície são muitas vezes utilizados na criação de modelos, como modelos hidrológicos, é importante corrigir estes erros de sumidouro e de pico de uma forma consistente com os dados das redondezas.</div>",
		floatName: "Flutuar",
		floatSnip: "Converte cada valor de célula de um raster numa representação de um ponto de flutuação.",
		floatDesc: "A função de Flutuação converte cada valor de píxel de um raster numa representação de um ponto de flutuação.",
		flowAccumulationName: "Acumulação de fluxo",
		flowAccumulationSnip: "Cria um raster de fluxo acumulado em cada célula. Pode ser opcionalmente um fator de peso.",
		flowAccumulationDesc: "A função global de Acumulação de Fluxo cria um raster de fluxo acumulado em cada píxel, conforme determinado pela acumulação de peso para todos os píxeis que fluem para cada píxel descendente. Caso não seja fornecido qualquer raster de peso, é aplicado um peso de 1 a cada píxel e o valor de píxeis no raster de saída é o número de píxeis que fluem para cada píxel.<div><br/>Os píxeis de saída com uma alta acumulação de fluxo são áreas de fluxo concentrado e podem ser utilizados para identificar canais de fluxo. Os píxeis de saída com uma acumulação de fluxo de zero são altos topográficos locais e podem ser utilizados para identificar cordilheiras.</div>",
		flowDirectionName: "Direção do Fluxo",
		flowDirectionSnip: "Cria um raster de direção de fluxo a partir de cada célula até ao seu vizinho com maior inclinação descendente.",
		flowDirectionDesc: "Uma dos principais elementos para a derivação de características hidrológicas de uma superfície consiste na capacidade de determinar a direção de cada píxel no raster. A função de raster da Direção do Fluxo utiliza uma superfície como entrada e cria um raster de direção de fluxo a partir de cada píxel até ao seu vizinho com maior inclinação descendente. A função de Direção do Fluxo suporta três métodos de criação de modelos de fluxo: o D8 (oito direções), Direção de Múltiplos Fluxos (MFD) e D-Infinity (DINF). ",
		flowDistanceName: "Distância do Fluxo",
		flowDistanceSnip: "Calcula para cada célula, a distância mínima horizontal ou vertical descendente até às células num rio ou corrente para o qual fluem.",
		flowDistanceDesc: "Para cada píxel, a função irá calcular a distância mínima horizontal ou vertical descendente até ao(s) píxel(eis) num rio ou corrente para o qual fluem. Caso seja fornecido um raster de direção de fluxo opcional, as direções descendentes serão limitadas às definidas pelo raster de direção do fluxo de entrada. A saída é um raster de distância de fluxo.",
		focalName: "Estatísticas Focalizadas",
		focalSnip: "Calcula as estatísticas focalizadas para cada píxel de uma imagem com base numa vizinhança focalizada definida.",
		focalDesc: "A função de Estatísticas Focalizadas calcula as estatísticas focalizadas para cada píxel de uma imagem com base numa vizinhança focalizada definida.",
		geometricName: "Geométrica",
		geometricSnip: "Aumenta a precisão posicional de um conjunto de dados tendo em conta a elevação.",
		geometricDesc: "A função Geométrica produz uma imagem ortorretificada baseada numa definição de um sensor e num modelo de terreno. Aumenta a precisão posicional de um conjunto de dados tendo em conta a elevação.",
		grayscaleName: "Escala de cinzentos",
		grayscaleSnip: "Converte uma imagem multibanda numa imagem em escala de cinzentos de banda única.",
		grayscaleDesc: "Esta função converte uma imagem multibanda numa imagem em escala de cinzentos de banda única.<div><br/>Esta função aplica os pesos especificados a cada uma das bandas de entrada e normaliza a imagem de saída. Os pesos são por vezes aplicados devido ao facto de algumas bandas terem uma importância variável dependendo da aplicação. Por exemplo, a banda azul contém muitas vezes mais ruído do que as outras bandas.</div>",
		greaterThanEqualName: "Maior Igual",
		greaterThanEqualSnip: "Realiza uma operação maior-que-igual-a Relacional em duas entradas numa base célula a célula. Devolve 1 para células nas quais o primeiro raster é maior ou igual ao segundo raster e 0 caso isso não aconteça.",
		greaterThanEqualDesc: "A função realiza uma operação maior-que-ou-igual-a Relacional em duas entradas numa base píxel a píxel. Devolve um valor de 1 para píxeis nos quais o primeiro raster é maior ou igual que o segundo raster e um valor de 0 para píxeis nos quais o primeiro raster não é maior ou igual que o segundo raster.",
		greaterThanName: "Maior do Que",
		greaterThanSnip: "Realiza uma operação maior-que Relacional em duas entradas numa base célula a célula. Devolve 1 para células nas quais o primeiro raster é maior que o segundo raster e 0 caso isso não aconteça.",
		greaterThanDesc: "A função realiza uma operação Relacional maior do que a operação em duas entradas numa base de píxel a píxel. Devolve um valor de 1 para píxeis nos quais o primeiro raster é maior que o segundo raster e um valor de 0 para píxeis nos quais o primeiro raster não é maior que o segundo raster.",
		heatIndexName: "Índice de Calor",
		heatIndexSnip: "Combine a temperatura ambiente e a humidade relativa para devolver a temperatura aparente.",
		heatIndexDesc: "Esta função calcula a temperatura aparente com base na temperatura ambiente e humidade relativa. A temperatura aparente é muitas vezes descrita como a sensação térmica do corpo humano.<div><br/>Este índice pode ser útil para calcular os perigos relacionados com questões médicas como cãibras musculares, desidratação, exaustão do calor ou a insolação mais grave em dias quentes e húmidos. Quando a humidade relativa é elevada, torna-se cada vez mais difícil a evaporação do suor do corpo, deixando os indivíduos sem uma forma natural e eficaz de se arrefecerem. Mapas de avisos ou de informação de calor são muitas vezes um produto de uma nova classificação do resultado do indicador de calor em classes, nas quais, quanto maior o valor indicador, mais provável é que se torne num aviso em vez de apenas uma informação.</div>",
		hillshadeName: "Sombreamento",
		hillshadeSnip: "Cria uma representação 3D da superfície, com a posição relativa do sol tida em conta para sombrear a imagem",
		hillshadeDesc: "A função Hillshade produz uma representação 3D à escala de cinzentos da superfície do terreno, com a posição relativa do sol tida em conta para sombrear a imagem. <div><br/>O sombreamento é uma técnica de visualização do terreno determinada por uma fonte de luz e pela inclinação e aspeto da superfície da elevação. É um método qualitativo para a visualização topográfica e não oferece valores absolutos de elevação. </div>",
		intName: "Int",
		intSnip: "Converte cada valor de célula de um raster num número inteiro por truncagem.",
		intDesc: "A função Int converte cada valor de píxel de um raster num número inteiro por truncagem.",
		interpolateIrregularDataName: "Interpolar Dados Irregulares",
		interpolateIrregularDataSnip: "Interpola a partir de nuvens de pontos ou grelhas irregulares.",
		interpolateIrregularDataDesc: "Alguns conjuntos de dados netCDF ou HDF armazenam a sua geolocalização como disposições de espaçamento irregular de píxeis ou dados de ponto. Ao adicionar estes conjuntos de dados a um conjunto de dados de mosaico, a função de interpolação de dados irregulares toma os dados irregularmente organizados e cria uma nova amostra de forma a que cada píxel seja quadrado e de uma dimensão uniforme.<div><br/>Ao adicionar variáveis de netCDF ou HDF a um conjunto de dados em mosaico, verificará automaticamente se os dados estão ordenados regularmente. Caso não estejam, a função de interpolação de dados irregulares pode ser utilizada para converter os dados irregulares num raster organizado de forma regular. Poderá alterar o método de interpolação e a célula utilizada na função de interpolação do raster de dados irregulares. Para dados de raster de espaçamento regular, não será aplicada qualquer interpolação e os dados serão lidos conforme estão.</div>",
		isNullName: "É Nulo",
		isNullSnip: "Determina quais valores dos rasters de entrada são NoData numa base célula a célula. Devolve um valor de 1 caso os valores de entrada sejam NoData e 0 para células que não são.",
		isNullDesc: "A Função É Nulo determina quais valores do raster de entrada são NoData numa base píxel a píxel. Devolve um valor de 1 caso o valor de entrada seja NoData e um valor de 0 para píxeis que são NoData.",
		kernelDensityName: "Densidade Kernel",
		kernelDensitySnip: "Calcula uma área de magnitude-por-unidade a partir de características de um ponto ou polilinhas utilizando uma função kernel para encaixar uma superfície suavemente esticada até cada ponto ou polilinha.",
		kernelDensityDesc: "Esta função calcula uma área de magnitude-por-unidade a partir de características de um ponto ou polilinhas utilizando uma função kernel para encaixar uma superfície suavemente esticada até cada ponto ou polilinha.",
		keyMetadataName: "Metadados chave",
		keyMetadataSnip: "Substitui ou introduz metadados chave de um raster numa cadeia de funções.",
		keyMetadataDesc: "Esta função permite-lhe introduzir ou substituir metadados chave de um raster.<div><br/>A informação nos metadados chave é utilizada para ajudar a aplicação com algum processamento e renderização, incluindo o fornecimento de algumas informações úteis, como o nome do sensor, nomes das bandas ou a nebulosidade associada às imagens.</div>",
		shortestPathName: "Percurso de Menor Custo",
		shortestPathSnip: "Executa uma análise de distância do custo utilizando as entradas de origem e destino que é então utilizada para determinar o percurso de menor custo a partir de uma origem até um destino.",
		shortestPathDesc: "A função de Percurso de Menor Custo calcula o percurso de menor custo a partir de uma origem até um destino. A distância com menor custo acumulado é calculada para cada píxel ao longo de uma superfície de custo, até à origem mais próxima. Isto produz um raster de saída que regista o percurso ou percursos de menor custo a partir de locais selecionados até aos píxeis de origem mais próximos definidos dentro da superfície de custo acumulado, em termos de custo de distância.<div><br/>A cada percurso de menor custo é atribuído um valor quando encontrado no processo de digitalização. O píxel final na Raster de Origem de percurso de custo recebe o valor de 1. O primeiro percurso recebe um valor de 3, o segundo 4 e por aí adiante. Quando múltiplos percursos se fundem e seguem a distância restante de volta a uma origem pelo mesmo percurso, ao segmento no qual os dois percursos viajam juntos é atribuído o valor de 2. A porção fundida do percurso não pode ser receber o valor de um dos percursos, uma vez que a porção unidade pertence a ambos os percursos.</div>",
		lessThanEqualName: "Menor Igual",
		lessThanEqualSnip: "Realiza uma operação menor-que-ou igual-que Relacional em duas entradas numa base célula a célula. Devolve 1 para células nas quais o primeiro raster é menor ou igual ao segundo raster e 0 caso isso não aconteça.",
		lessThanEqualDesc: "A função realiza uma operação menor-que-ou-igual-a Relacional em duas entradas numa base píxel a píxel. Devolve um valor de 1 para píxeis nos quais o primeiro raster é menor ou igual que o segundo raster e um valor de 0 quando não é menor que ou igual que o segundo raster.",
		lessThanName: "Menor do que",
		lessThanSnip: "Realiza uma operação menor-que Relacional em duas entradas numa base célula a célula. Devolve 1 para células nas quais o primeiro raster é menor que o segundo raster e 0 caso isso não aconteça.",
		lessThanDesc: "A função realiza uma operação menor-que Relacional em duas entradas numa base píxel a píxel. Devolve um valor de 1 para píxeis nos quais o primeiro raster é menor que o segundo raster e um valor de 0 quando não é menor que o segundo raster.",
		lnName: "Ln",
		lnSnip: "Calcula o logaritmo natural (base e) de células num raster.",
		lnDesc: "A função Ln calcula o logaritmo natural (base e) de cada píxel num raster.",
		log10Name: "Log10",
		log10Snip: "Calcula o logaritmo em base 10 de células num raster.",
		log10Desc: "A função Log10 calcula o logaritmo em base 10 de cada píxel num raster.",
		log2Name: "Log2",
		log2Snip: "Calcula o logaritmo em base 2 de células num raster.",
		log2Desc: "A função Log2 calcula o logaritmo em base 2 de cada píxel num raster.",
		lookupName: "Procura",
		lookupSnip: "Cria um novo raster ao buscar valores encontrados noutro campo na tabela do raster de entrada.",
		lookupDesc: "A função cria um novo raster ao buscar valores encontrados noutro campo na tabela do raster de entrada.",
		mlClassifyName: "Classificar ML",
		mlClassifySnip: "Classifica imagens utilizando uma abordagem píxel a píxel. Os píxeis misturados são atribuídos à característica com maior percentagem nesse píxel.",
		mlClassifyDesc: "A função Classificar ML permite-lhe realizar uma classificação supervisionada, utilizando o algoritmo de classificação de probabilidade máxima, num conjunto de dados de raster ou conjunto de dados de mosaico. Esta função necessita de um ficheiro de assinatura de classificação.",
		maskName: "Máscara",
		maskSnip: "Define valores que não deseja exibir no seu raster.",
		maskDesc: "Esta função de raster define valores que não deseja exibir no seu raster. Utilizando a função de Máscara, especificará um ou mais valores NoData ou um intervalo de valores de píxel válidos. ",
		minusName: "Menos",
		minusSnip: "Subtrai o valor do segundo raster de entrada a partir do valor do primeiro raster de entrada numa base célula a célula.",
		minusDesc: "A função Menos subtrai o valor do segundo raster de entrada a partir do valor do primeiro raster de entrada numa base píxel a píxel.",
		modName: "Mod",
		modSnip: "Encontra o resto (módulo) do primeiro raster quando dividido pelo segundo raster numa base célula a célula.",
		modDesc: "A função Mod encontra o resto (módulo) do primeiro raster quando dividido pelo segundo raster numa base píxel a píxel. A ordem das duas entradas é importante e afeta o resultado de saída.",
		mosaicRastersName: "Rasters de Mosaico",
		mosaicRastersSnip: "Cola um grupo de conjuntos de dados raster para criar um conjunto de dados.",
		mosaicRastersDesc: "A função de Rasters de Mosaico cria uma imagem de mosaico a partir de múltiplas imagens. Quando existe uma sobreposição entre imagens, existem vários métodos entre os quais poderá escolher para determinar quais imagens são apresentadas.",
		ndviColorizedName: "NDVI Colorizado",
		ndviColorizedSnip: "Cria um conjunto de dados multibanda que representa a saúde da vegetação, baseado na diferença entre as bandas vermelhas e quase infravermelhas.",
		ndviColorizedDesc: "A função NDVI Colorizado aplica a função NDVI na imagem de entrada e utilização então um mapa de cores ou rampa de cores para apresentar o resultado.",
		ndviName: "NDVI",
		ndviSnip: "Calcula o Índice de Vegetação por Diferença Normalizada (NDVI).",
		ndviDesc: "A função NDVI cria um conjunto de dados de banda única que representa a saúde da vegetação, baseado na diferença entre as bandas vermelhas e quase infravermelhas.<div><br/>NDVI é um índice padronizado que lhe permite gerar uma imagem que apresenta verdor, também conhecido como biomassa relativa. Este índice tira partido do contraste de características entre duas bandas a partir de um conjunto de dados de raster multiespectrais: a absorção do pigmento de clorofila na banda vermelha e elevada refletividade de material vegetal na banda quase infravermelha (NIR). Valores NDVI extremamente baixos ou negativos representam áreas sem qualquer vegetação, como uma nuvem, água ou neve. Valores muito baixos representam áreas de pouca a nenhuma vegetação, como cimento, rocha, ou solo descoberto. Os valores moderados representam áreas de arbustos ou relva. Os valores elevados representam áreas de floresta e vegetação frondosa.</div>",
		negateName: "Negar",
		negateSnip: "Altera o sinal (multiplica por -1) dos valores de célula do raster de entrada numa base célula a célula.",
		negateDesc: "A função Negar altera o sinal (multiplica por -1) dos valores de píxel do raster de entrada num píxel ",
		nibbleName: "Nibble",
		nibbleSnip: "Substitui células de um raster que corresponde a uma máscara com os valores dos vizinhos mais próximos.",
		nibbleDesc: "A função global Nibble permite a atribuição do valor do seu vizinho mais próximo a áreas selecionadas de um raster. Isto é útil para a edição de áreas de um raster no qual os dados poderão ser erróneos.",
		notEqualName: "Não Igual",
		notEqualSnip: "Realiza uma operação diferente-de relacional em duas entradas numa base célula a célula. Devolve 1 para células nas quais o primeiro raster é diferente-de ao segundo raster e 0 caso seja igual.",
		notEqualDesc: "A função realiza uma operação de diferente-de Relacional em duas entradas numa base píxel a píxel. Devolve um valor de 1 para píxeis nos quais o primeiro raster é diferente do segundo raster e um valor de 0 para píxeis quando é igual ao segundo raster.",
		pansharpeningName: "Nitidez pancromática",
		pansharpeningSnip: "Melhora artificialmente a resolução espacial de uma imagem multibanda fundindo-a com uma imagem pancromática de maior resolução.",
		pansharpeningDesc: "A função Pansharpening utiliza uma imagem pancromática de alta resolução ou banda de raster para que se funda com uma resolução mais baixa, conjunto de dados de raster multibanda para aumentar a resolução espacial da imagem multibanda.<div><br/>O objetivo do ajuste da nitidez é criar uma imagem visual de maior qualidade. Uma vez que as técnicas alteram a radiometria e características espectrais das imagens multibanda, as imagens \"pan sharpened\" necessitam de ser utilizadas com cuidado para fins de deteção remota analítica.</div>",
		pathAllocationName: "Atribuição de Distância de Percurso",
		pathAllocationSnip: "Calcula a origem de menor custo para cada célula com base no menor custo acumulado ao longo de uma superfície de custo, tendo em conta a distância da superfície e fatores de custo horizontal e vertical.",
		pathAllocationDesc: "A função de Atribuição de Distância de Percurso calcula a origem mais próxima para cada célula com base no menor custo acumulado ao longo de uma superfície de custo, tendo em conta a distância da superfície e fatores de custo horizontal e vertical.",
		pathBackLinkName: "Ligação de Menor Distância de Percurso",
		pathBackLinkSnip: "Define o vizinho que é a célula seguinte no percurso de menor custo acumulado até à origem com menor custo, tendo em conta a distância da superfície juntamente com os fatores de custo horizontal e vertical.",
		pathBackLinkDesc: "A função Ligação de Menor Distância de Percurso identifica a direcionalidade do vizinho que é a célula seguinte no percurso de menor custo acumulado até à origem mais próxima, tendo em conta a distância da superfície e fatores de custo horizontal e vertical.",
		pathDistanceName: "Distância de Percurso",
		pathDistanceSnip: "Calcula, para cada célula, a distância com menor custo acumulado desde ou para a origem com menor custo, tendo em conta a distância da superfície juntamente com os fatores de custo horizontal e vertical.",
		pathDistanceDesc: "A função Distância de Percurso calcula, para cada célula, a distância com menor custo acumulado para a origem mais próxima, tendo em conta a distância da superfície e fatores de custo horizontal e vertical.",
		plusName: "Mais",
		plusSnip: "Adiciona (soma) os valores de dois rasters numa base célula a célula.",
		plusDesc: "A função Soma adiciona (soma) os valores de dois rasters numa base píxel a píxel.",
		powerName: "Potência",
		powerSnip: "Eleva os valores das células num raster à potência dos valores encontrados noutro raster.",
		powerDesc: "A função Potência eleva os valores de píxel num raster à potência dos valores encontrados noutro raster.",
		radarCalibrationName: "Calibração de Radar",
		radarCalibrationSnip: "Converte a retrodifusão do RADARSAT-2.",
		radarCalibrationDesc: "Esta função pode ser utilizada para calibrar imagens do RADARSAT-2 num conjunto de dados em mosaico ou como um produto raster. A calibragem é realizada nas imagens de radar de forma a que os valores dos píxeis sejam uma representação verdadeira da retrodifusão do radar.",
		rasterInfoName: "Informação de Raster",
		rasterInfoSnip: "Modifica propriedades do raster, tais como a profundidade do bit, um valor NoData, o tamanho da célula, etc.",
		rasterInfoDesc: "A Informação de Raster abre uma caixa de diálogo com propriedades do conjunto de dados raster, tais como o número de colunas e linhas, o número de bandas, o tipo de píxel, a extensão e a referência espacial. Pode editar estas propriedades selecionando um conjunto de dados raster para utilizar como modelo. ",
		rasterizeAttributesName: "Rasterizar Atributos",
		rasterizeAttributesSnip: "Potencia um raster através de bandas adicionais derivadas de valores de atributos especificados de uma tabela externa ou de um serviço de funcionalidade.",
		rasterizeAttributesDesc: "A função Rasterizar Atributo potencia um raster adicionando bandas derivadas de valores de atributos especificados, de uma tabela externa ou de um serviço de funcionalidade. Pode opcionalmente especificar um raster de zona e o atributo de identificação de zona associado para permitir consultas baseadas em regiões.",
		rasterizeFeatureClassName: "Rasterizar Funcionalidades",
		rasterizeFeatureClassSnip: "Converte funcionalidades num raster.",
		rasterizeFeatureClassDesc: "Esta função converte dados de classes de funcionalidade de polígonos, polilinhas e pontos numa camada raster.<div><br/>São atribuídos valores de píxeis aos elementos com base em OBJECTID dos elementos (padrão). Opcionalmente, os valores de píxeis podem ser baseados num campo de valor definido pelo utilizador na tabela de atributos de funcionalidades de entrada.</div>",
		recastName: "Reformular",
		recastSnip: "Modifica os parâmetros de uma cadeia de funções num conjunto de dados em mosaico ou num serviço de imagens. Isto é frequentemente utilizado com conjuntos de dados LAS para evitar ter de se criar um conjunto de dados em mosaico separado para diferentes representações do terreno.",
		recastDesc: "A função Reformular é utilizada para modificar dinamicamente o parâmetro de função utilizado num conjunto de dados em mosaico ou num serviço de imagens sem que as alterações persistam fisicamente.",
		regionGroupName: "Grupo de Regiões",
		regionGroupSnip: "Para cada célula na saída, é registada a identidade da região ligada à qual essa célula pertence. Um único número é atribuído a cada região.",
		regionGroupDesc: "A função global Grupo de Regiões regista, para cada célula na saída, a identidade da região ligada à qual essa célula pertence. Um único número é atribuído a cada região.<div><br/>A primeira região lida recebe o valor de um, a segunda de dois, e assim sucessivamente, até que seja atribuído um valor a todas as regiões. A leitura vai da esquerda para a direita, de cima para baixo. Os valores atribuídos às zonas de saída têm por base o momento em que são encontrados no processo de leitura.</div>",
		regionGrowName: "Crescimento de Região",
		regionGrowSnip: "Desenvolve regiões a partir de pontos iniciais.",
		regionGrowDesc: "A função Crescimento de Região agrupa píxeis adjacentes em grupos, dependendo do raio especificado a partir do ponto inicial. É atribuído ao grupo de píxeis ou ao objeto um valor de preenchimento especificado.",
		remapName: "Remapear",
		remapSnip: "Altera os valores de píxeis atribuindo novos valores a intervalos de valores de píxeis ou utilizando uma tabela externa.",
		remapDesc: "A função Remapear permite-lhe alterar ou reclassificar os valores dos píxeis dos dados de raster. Isto pode ser feito quer especificando um intervalo de valores de píxeis para mapear para um valor de píxel de saída, quer utilizando uma tabela para mapear os valores de píxeis para o valor de píxel de saída.",
		reprojectName: "Reprojetar",
		reprojectSnip: "Modifica a projeção de um conjunto de dados raster, conjunto de dados em mosaico, ou item raster num conjunto de dados em mosaico. Também consegue gerar uma nova amostra dos dados para um novo tamanho da célula e definir uma origem.",
		reprojectDesc: "A função Reprojetar modifica a projeção de um conjunto de dados raster, conjunto de dados em mosaico, ou item raster num conjunto de dados em mosaico. Também consegue gerar uma nova amostra dos dados para um novo tamanho da célula e definir uma origem.<div><br/>A função Reprojetar pode ser utilizada quando se cria uma cache a partir de um conjunto de dados raster ou mosaico que não se encontra na projeção requerida. Por exemplo, ao criar um serviço de imagens em cache que pode ser integrado por aplicações com outros serviços em cache, é importante que todos estejam na mesma projeção. Isto é frequentemente uma projeção Web Mercator. Uma vez que o conjunto de dados em mosaico não pode ser reprojetado, pode fazer uma de duas coisas — criar um conjunto de dados em mosaico referenciado a partir do seu conjunto de dados em mosaico na projeção necessária, ou adicionar a função Reprojetar à cadeia de funções do conjunto de dados em mosaico. Outro exemplo utiliza esta função no item raster num conjunto de dados em mosaico. Ao utilizar a função Raster em Cache, pode querer inserir a função Reprojetar para que a cache seja criada na nova projeção. Os itens raster num conjunto de dados em mosaico podem ser armazenados em cache quando o processamento é intenso e está a tentar publicar um serviço de imagens que é rápido, sem armazenar em cache todo o serviço de imagens.</div>",
		resampleName: "Reamostragem",
		resampleSnip: "Altera o tamanho da célula de um raster.",
		resampleDesc: "A função Reamostragem altera o tamanho da célula, o tipo de reamostragem, ou ambos.<div><br/>A função Reamostragem só deve ser utilizada com requisitos de cálculo específicos; por exemplo, quando se está a calcular o vento ou a direção de magnitude atual que requer a reamostragem a partir da resolução da fonte.</div>",
		roundDownName: "Arredondar para Baixo",
		roundDownSnip: "Devolve o valor inteiro imediatamente inferior, representado simplesmente como um valor de vírgula flutuante, para cada célula num raster.",
		roundDownDesc: "A função Arredondar para Baixo devolve o inteiro imediatamente inferior, como um valor de vírgula flutuante, para cada píxel num raster.",
		roundUpName: "Arredondar para Cima",
		roundUpSnip: "Devolve o valor inteiro imediatamente superior, representado simplesmente como um valor de vírgula flutuante, para cada célula num raster.",
		roundUpDesc: "Arredondar para Cima devolve o inteiro imediatamente superior, como um valor de vírgula flutuante, para cada píxel num raster.",
		segmentMeanShiftName: "Deslocação média de segmentação",
		segmentMeanShiftSnip: "Agrupa píxeis adjacentes com características espetrais similares em segmentos.",
		segmentMeanShiftDesc: "Esta função identifica objetos, funcionalidades, ou segmentos nas suas imagens, agrupando píxeis adjacentes que têm características espetrais e espaciais similares. Pode controlar a medida de suavização espacial e espetral para ajudar a obter funcionalidades de interesse.",
		s1RadiometricCalibrationName: "Calibração Radiométrica Sentinel-1",
		s1RadiometricCalibrationSnip: "Executa diferentes tipos de calibragem radiométrica em dados Sentinel-1.",
		s1RadiometricCalibrationDesc: "Esta função raster realiza três calibragens diferentes para conjuntos de dados Sentinel 1, incluindo beta zero e gama, e gera o conjunto de dados calibrado. O objetivo da calibragem SAR é o de proporcionar imagens nas quais os valores dos píxeis possam ser diretamente relacionados com a retrodifusão de radar da cena. Embora as imagens SAR não calibradas sejam suficientes para uma utilização qualitativa, as imagens SAR calibradas são essenciais para a utilização quantitativa dos dados SAR.<div><br/>O processamento de dados SAR típicos, que produz imagens de Nível 1, não inclui correções radiométricas e permanece um desvio radiométrico significativo. Portanto, é necessário aplicar correção radiométrica às imagens SAR para que os valores dos píxeis das imagens representem verdadeiramente a retrodifusão de radar da superfície refletora. A correção radiométrica também é necessária para a comparação de imagens SAR obtidas com diferentes sensores, ou obtidas a partir do mesmo sensor em diferentes momentos, em diferentes modos, ou processadas por diferentes processadores.</div>",
		s1ThermalNoiseRemovalName: "Eliminação de Ruído Térmico de Sentinel-1",
		s1ThermalNoiseRemovalSnip: "Elimina o ruído térmico de dados Sentinel-1.",
		s1ThermalNoiseRemovalDesc: "A correção de ruído térmico pode ser aplicada a produtos Single Look Complex (SLC) de Nível 1, bem como a produtos Ground Range Detection (GRD) de Nível 1, de Sentinel-1, que ainda não tenham sido corrigidos. O operador também pode eliminar esta correção com base nas anotações do produto para reintroduzir o sinal de ruído que foi eliminado para produzir o produto original. As anotações do produto serão atualizadas em conformidade para permitir a reaplicação da correção. ",
		setNullName: "Definir Nulo",
		setNullSnip: "Definir Nulo define locais de células identificados como NoData com base num critério específico. Devolve NoData caso uma avaliação condicional seja verdadeira e devolve o valor especificado por outro raster caso seja falso.",
		setNullDesc: "A função Definir Nulo define os píxeis identificados como NoData, com base nos critérios específicos. Devolve NoData se uma avaliação condicional for verdadeira (1) e devolve o valor especificado no Raster Falso se uma avaliação condicional for falsa (0). Este critério é definido pelo valor de saída de uma função matemática lógica, que será o Raster de entrada.",
		shadedReliefName: "Relevo Sombreado",
		shadedReliefSnip: "Cria uma representação multibanda, codificada por cores e 3D da superfície, com a posição relativa do sol tida em conta para sombrear a imagem.",
		shadedReliefDesc: "A função de Relevo sombreado cria uma representação 3D a cores do terreno é criada através da fusão de imagens dos métodos de Hillshade e código-elevação. Esta função utiliza as propriedades de altitude e azimute para especificar a posição do sol.<div><br/></div>",
		sinHName: "SinH",
		sinHSnip: "Calcula o seno hiperbólico das células num raster.",
		sinHDesc: "A função calcula o seno hiperbólico dos píxeis num raster.",
		sinName: "Sin",
		sinSnip: "Calcula o seno das células num raster.",
		sinDesc: "A função calcula o seno dos píxeis num raster.",
		slopeName: "Inclinação",
		slopeSnip: "Calcula a taxa de variação do valor de um píxel para os seus vizinhos.",
		slopeDesc: "Esta função raster calcula a inclinação, que é a taxa de variação da elevação de cada célula do modelo de elevação digital (DEM). É a primeira derivada de um DEM.<div><br/>Esta função utiliza uma função atan() acelerada. É seis vezes mais rápida e o erro de aproximação é sempre inferior a 0,3 graus.</div>",
		speckleName: "Ruído",
		speckleSnip: "Fornece filtros para reduzir o ruído de conjuntos de dados de radares de abertura sintética.",
		speckleDesc: "Ruído é o ruído de alta-frequência em dados de um radar. As imagens geradas pelos sistemas de radar de abertura sintética (SAR) são altamente sujeitas a efeitos do ruído devido ao processamento de sinais dispersos e à interferência de ondas eletromagnéticas dispersas das superfícies ou objetos. Esta função de ruído filtra o conjunto de dados de radar com ruído e suaviza o ruído enquanto retém as arestas ou entidades precisas na imagem.",
		spectralConversionName: "Conversão Espectral",
		spectralConversionSnip: "Aplica uma matriz a uma imagem multibanda.",
		spectralConversionDesc: "A função Conversão Espectral aplica uma matriz a uma imagem multibanda para afetar os valores de cor da saída.<div><br/>Alguns sensores não recolhem bandas azuis devido a uma baixa relação sinal-ruído. Isto pode ser utilizado, por exemplo, para converter uma imagem infravermelha de cor falsa para uma imagem de cor pseudo natural.</div>",
		squareRootName: "Raiz Quadrada",
		squareRootSnip: "Calcula a raiz quadrada dos valores de célula num raster.",
		squareRootDesc: "A função Raiz Quadrada calcula a raiz quadrada dos valores de píxel num raster.",
		squareName: "Quadrado",
		squareSnip: "Calcula o quadrado dos valores de célula num raster.",
		squareDesc: "Quadrada calcula a raiz quadrada dos valores de píxel num raster.",
		statisticsHistogramName: "Estatísticas e Histograma",
		statisticsHistogramSnip: "Definir estatísticas ou histogramas associados.",
		statisticsHistogramDesc: "A função de Estatísticas e Histograma é utilizada para definir as estatísticas e o histograma de um raster. Poderá introduzir esta função no final da cadeia de funções para descrever as estatísticas e histograma de um modelo de função de raster (RFT). Isto poderá ser necessário para controlar a apresentação predefinida do resultado de processamento, especialmente durante a definição de uma cadeia de funções que contenha muitas funções.<div><br/>Pode definir estatísticas, digitando os valores ou importando de um conjunto de dados raster ou de um ficheiro XML. Os histogramas apenas podem ser definidos através da importação de um ficheiro.</div>",
		statisticsName: "Estatísticas",
		statisticsSnip: "Calcula as estatísticas focalizadas para cada píxel de uma imagem com base numa vizinhança focalizada definida.",
		statisticsDesc: "A função de Estatísticas calcula as estatísticas focalizadas para cada píxel de uma imagem com base numa vizinhança focalizada definida.<div><br/>A função de Estatísticas pode ser utilizada para preencher linhas não contínuas numa imagem. As linhas não contínuas são muitas vezes provocadas por problemas no sensor no qual dados não são recolhidos. Isto aconteceu em sensores como o Enhanced Thematic Mapper Plus (ETM+) da Landsat 7. Estes dados em falta provocam problemas para a análise e também durante a visualização das imagens. Pouco pode ser feito durante a utilização de imagens para análise; no entanto, caso existisse uma imagem sobreposta, esta poderá ser utilizada na vez de um conteúdo em falta. O mesmo poderá ser feito caso as imagens estejam a ser utilizadas para visualização. No entanto, não existe sempre uma imagem extra para preencher o conteúdo em falta e como tal este deverá ser derivado de dados existentes.</div>",
		streamLinkName: "Ligação de corrente",
		streamLinkSnip: "Atribui valores exclusivos a secções de uma rede linear raster entre interseções.",
		streamLinkDesc: "A função de Ligação de Corrente global atribui valores exclusivos a secções de uma rede linear raster entre interseções.<div><br/>As ligações são as secções de um canal de fluxo que liga duas junções sucessivas, uma junção e a saída, ou uma junção e a divisão da drenagem. Em hidrologia, estes segmentos de corrente chamam-se rios. Um cruzamento está relacionado com um ponto de despejo e ajuda a delinear uma área de separação de águas ou os limites de uma bacia de drenagem secundária.</div>",
		stretchName: "Esticar",
		stretchSnip: "Melhora uma imagem ao ajustar o intervalo de valores apresentado. Isto não altera os valores de píxel subjacentes. Se um píxel tiver um valor fora do intervalo especificado, ele aparecerá como o valor mínimo ou máximo.",
		stretchDesc: "A função Esticar melhora uma imagem ao alterar propriedades como o brilho, contraste e gamma através de múltiplos tipos de extensão. Esta função utiliza as estatísticas dos rasters dentro do conjunto de dados do mosaico; como tal, caso utilize esta função, deverá assegurar-se de que as estatísticas foram calculadas.<div><br/>O tipo de extensão define um histograma de extensão que será aplicado aos rasters para melhorar a sua aparência. A extensão melhora a aparência dos dados ao espalhar os valores de píxel ao longo de um histograma a partir dos valores mínimos e máximos definidos através da respetiva profundidade de bit. </div>",
		swathName: "Faixa",
		swathSnip: "Há interpolação de organizações irregulares ou dados de faixa.",
		swathDesc: "Alguns conjuntos de dados netCDF ou HDF armazenam a sua geolocalização como disposições de espaçamento irregular. Ao adicionar estes conjuntos de dados a um conjunto de dados de mosaico, a função de faixa toma dados irregularmente organizados e cria uma nova amostra de forma a que cada píxel seja quadrado e de uma dimensão uniforme.<div><br/>Ao adicionar variáveis de netCDF ou HDF a um conjunto de dados em mosaico, verificará automaticamente se os dados estão ordenados regularmente. Caso não estejam, a função de faixa é automaticamente aplicada para converter o raster irregular em pontos e depois num raster regularmente organizado. Poderá alterar o método de interpolação e a célula utilizada na função de raster de faixa. Para dados de raster de espaçamento regular, não será aplicada qualquer interpolação, os dados serão lidos conforme estão.</div>",
		tanHName: "TanH",
		tanHSnip: "Calcula a tangente hiperbólica das células num raster.",
		tanHDesc: "Esta função calcula a tangente hiperbólica dos píxeis num raster.",
		tanName: "Tan",
		tanSnip: "Calcula a tangente das células num raster.",
		tanDesc: "Esta função calcula a tangente dos píxeis num raster. ",
		tasseledCapName: "Tasseled Cap (Kauth-Thomas)",
		tasseledCapSnip: "Calcula níveis de vegetação, humidade e brilho. Esta técnica depende de coeficientes, que têm que ser calculados especificamente para cada sensor.",
		tasseledCapDesc: "A transformação Tasseled Cap (Kauth-Thomas) está desenhada para analisar e representar mudanças de vegetação e de desenvolvimento urbano detetadas por diversos sistemas de sensor de satélite. É conhecida como a transformação Tasseled Cap devido à forma da distribuição gráfica dos dados. A transformação fornece uma razão para os padrões encontrados nos dados do Landsat MSS de campos agrícolas como uma função do ciclo de vida da plantação. Essencialmente, à medida que as culturas crescem desde a semente até à maturidade, há um aumento líquido de infravermelho próximo e uma diminuição da refletância vermelha com base na cor do solo<div><br/>A utilidade desta transformação expandiu-se da monitorização das culturas para a análise e cartografia da vegetação para apoiar uma grande variedade de aplicações como a silvicultura, gestão da vegetação industrial, cartografia e gestão dos ecossistemas, inventário e monitorização para sequestro e créditos de carbono, desenvolvimento urbano, e muito mais. Também se expandiu de suportar o Landsat MSS para incluir outros sistemas de satélites populares tais como o Landsat TM, o Landsat ETM+, o Landsat 8, o IKONOS, o QuickBird, o WorldView-2 e sensores multiespectrais RapidEye.</div>",
		timesName: "Tempos",
		timesSnip: "Multiplica os valores de dois rasters numa base de célula a célula.",
		timesDesc: "A função Tempos multiplica os valores de dois rasters numa base de píxel a píxel.",
		transposeBitsName: "Transpor Bits",
		transposeBitsSnip: "Desempacota os bits do píxel de entrada e atribui-os a bits específicos no píxel de saída. O objetivo desta função é o de manipular bits de um par de entradas, tais como os produtos de banda de qualidade do Landsat 8.",
		transposeBitsDesc: "A função Transpor Bit desempacota os bits do píxel de entrada e atribui-os a bits específicos no píxel de saída. O objetivo desta função é o de manipular bits de um par de entradas, tais como os produtos de banda de qualidade do Landsat 8.",
		unitConversionName: "Conversão de Unidades",
		unitConversionSnip: "Altera valores de uma unidade de medição para outra.",
		unitConversionDesc: "Esta função converte píxeis de uma unidade para outra. Suporta a conversão de distância, velocidade e temperatura.",
		vectorFieldName: "Campo Vetorial",
		vectorFieldSnip: "Exibe conjuntos de dados em que tanto a magnitude (u) como a direção (v) são setas, onde a magnitude é representada pelo tamanho da seta e a direção pelo ângulo da mesma.",
		vectorFieldDesc: "A função Campo Vetorial é utilizada para combinar e converter dois rasters num raster de duas bandas, que seja do tipo Magnitude-Direção ou do tipo de dados U-V.<div><br/>O valor U é por vezes referido como a velocidade zonal, e o valor V é por vezes referido como a velocidade meridional.</div>",
		viewshed2Name: "Área Visível",
		viewshed2Snip: "Determina as localizações da superfície do raster que são visíveis a um grupo de funcionalidades do observador utilizando métodos geodésicos.",
		viewshed2Desc: "A função Área Visível determina as localizações da superfície raster visíveis a um conjunto de elementos de observador utilizando métodos geodésicos<div><br/>A visibilidade de cada centro de píxel é determinada por um teste de linha de visão entre o alvo e cada observador. Se um observador puder ver o alvo no centro do píxel, então, este píxel é considerado visível. Esta ferramenta considera sempre a curvatura da Terra, quando a visibilidade é determinada.</div>",
		watershedName: "Área de Separação de Águas",
		watershedSnip: "Determina a área que contribui por cima de um grupo de células num raster",
		watershedDesc: "A função Área de Separação de Águas global determina a área que contribui por cima de um grupo de píxeis num raster. Áreas de Separação de Águas são delineadas a partir de um raster de direção do fluxo, que identifica a direção do fluxo de cada píxel.",
		weightedOverlayName: "Sobreposição ponderada",
		weightedOverlaySnip: "Sobrepõe diversos rasters utilizando uma escala de medição comum e pondera cada um de acordo com a sua importância.",
		weightedOverlayDesc: "Esta função permite sobrepor diversos rasters utilizando uma escala de medição comum e ponderar cada um de acordo com a sua importância.",
		weightedSumName: "Soma Ponderada",
		weightedSumSnip: "Pondera e soma uma série de rasters numa base célula-a-célula.",
		weightedSumDesc: "A função Soma Ponderada permite sobrepor diversos rasters, multiplicando cada um pelo seu respetivo peso e somando-os a todos.",
		windchillName: "Vento Frio",
		windchillSnip: "Combina a temperatura ambiente do ar e a velocidade do vento para calcular o fator vento frio.",
		windchillDesc: "A função Vento Frio é útil para identificar condições de inverno perigosas que, dependendo dos tempos de exposição aos elementos, podem resultar em queimaduras de frio e hipotermia. Vento frio é um modo de calcular quanto frio um indivíduo sente, quando se leva o vento em consideração com temperaturas já elas frias. Quanto mais elevada a velocidade do vento, mais rapidamente o corpo vai perder calor e mais frio se vai sentir.",
		zonalRemapName: "Remapear Zonal",
		zonalRemapSnip: "Remapear píxeis num raster baseado em zonas definidas noutro raster e no mapear de valores dependentes da zona definidos numa tabela.",
		zonalRemapDesc: "Esta função permite remapear píxeis num raster baseado em zonas definidas noutro raster e no mapear de valores dependentes da zona definidos numa tabela.",
		zonalStatisticsName: "Estatística Zonal",
		zonalStatisticsSnip: "Calcula estatísticas nos valores de um raster dentro das zonas de outro conjunto de dados.",
		zonalStatisticsDesc: "A função calcula estatísticas sobre os valores de um raster dentro das zonas de outro conjunto de dados. Uma zona é definida como sendo todas as áreas na entrada que possuem o mesmo valor. Estas áreas não têm que ser contíguas. Quando as entradas zonal e de valores forem ambas rasters com a mesma resolução, então, serão utilizadas diretamente. Se as resoluções forem diferentes é aplicada uma reamostragem interna para equilibrar as resoluções antes de ser executada uma operação zonal.",
		flowLengthName: "Comprimento do Fluxo",
		flowLengthSnip: "Calcula a distância a montante ou jusante, ou distância ponderada, ao longo de um percurso do fluxo para cada célula.",
		flowLengthDesc: "Esta é uma função raster global. Esta função cria uma camada de raster da distância a montante ou jusante, ou distância ponderada, ao longo de um percurso do fluxo para cada célula.<div><br/>Uma das principais utilizações da função Comprimento do Fluxo é calcular o comprimento do percurso mais longo do fluxo numa determinada bacia. Esta medida é muitas vezes utilizada para calcular o tempo de concentração de uma bacia. Isto é efetuado com a opção A Montante. A função também pode ser utilizada para criar diagramas de distância/área de hipotéticos eventos de precipitação e escoamento utilizando o raster de peso como impedância para um movimento descendente.</div>",
		streamOrderName: "Ordem Stream",
		streamOrderSnip: "Atribui uma ordem numérica a segmentos de um raster que representam as secções de uma rede linear",
		streamOrderDesc: "Esta é uma função raster global. Esta função cria uma camada de raster que atribui uma ordem numérica a segmentos de um raster que representam as secções de uma rede linear.<div><br/>A saída da função Ordem Stream será de melhor qualidade se a camada de raster de stream de entrada e a camada de raster de direção do fluxo de entrada tiverem origem na mesma superfície. Se o raster de stream tiver origem num conjunto de dados de stream rasterizados, é possível que o resultado não possa ser utilizado numa base de célula a célula, e a direção não irá corresponder à localização das células de stream. Os resultados da função Acumulação de Fluxo podem ser utilizados para criar uma rede de raster de stream através da aplicação de um valor limite para selecionar células com um fluxo acumulado elevado. Por exemplo, as células com mais de 100 células a desembocarem nelas são utilizadas para definir a rede de stream. Utilize a função Con ou Definir Nulo para criar um raster de rede stream no qual os valores de acumulação de fluxo iguais ou superiores a 100 vão para um deles e os restantes são colocados em segundo plano (NoData). A rede de stream resultante pode ser utilizada na função Ordem Stream. Esta função apenas suporta uma camada de raster de direção de fluxo de entrada D8. As direções de fluxo D8 podem ser criadas com a função Direção do Fluxo e executadas com o tipo de direção do fluxo padrão D8.</div>",
		snapPourPointName: "Ajustar Ponto de Escoamento",
		snapPourPointSnip: "Ajusta pontos de escoamento para a célula com maior acumulação de fluxo numa distância especificada",
		snapPourPointDesc: "Esta é uma função raster global. Esta função ajusta pontos de escoamento para a célula com maior acumulação de fluxo numa distância especificada.<div><br/>A função Ajustar Ponto de Escoamento é utilizada para garantir a seleção de pontos com fluxo acumulado elevado ao delinear bacias de drenagem com a função Bacia Hidrográfica. A função Ajustar Ponto de Escoamento irá procurar dentro de uma distância de ajuste em torno dos pontos de escoamento especificados para a célula com o maior fluxo acumulado e mover o ponto de escoamento para essa localização. O resultado é uma camada de raster inteira quando as localizações dos pontos de escoamento originais tiverem sido ajustadas para localizações com maior fluxo acumulado.</div>",
		sinkName: "Coletor",
		sinkSnip: "Cria um raster que identifica todos os coletores ou áreas de drenagem interna",
		sinkDesc: "Esta é uma função raster global. Esta função cria uma camada de raster que identifica todos os coletores ou áreas de drenagem interna. Um coletor é uma célula ou um conjunto de células espacialmente ligadas com uma direção de fluxo à qual não pode ser atribuído um dos oito valores válidos num raster de direção do fluxo. Isto pode ocorrer quando todas as células vizinhas são maiores do que a célula de processamento ou quando duas células desembocam uma na outra, criando um ciclo de duas células.<div><br/>A função Coletor apenas suporta uma camada de raster de direção de fluxo de entrada D8. As direções de fluxo D8 podem ser criadas com a função Direção do Fluxo e executadas com tipo de direção do fluxo padrão D8. O resultado da função Coletor é um raster inteiro, e cada coletor tem um valor único atribuído. Estes valores únicos situam-se entre um e o número total de coletores. Por exemplo, se o número total for 1000, os valores únicos vão de 1 a 1000.</div>",
		aggregateName: "Agregar",
		aggregateSnip: "Gera uma versão de resolução reduzida de um raster.",
		aggregateDesc: "A função Agregar faz a reamostragem de uma imagem raster de entrada a uma resolução menos precisa com base numa estratégia de agregação especificada. Cada célula de saída contém a Soma, o Mínimo, o Máximo, a Média ou a Mediana das células de entrada que são englobadas pela extensão dessa célula.<div><br/>Pode especificar o fator pelo qual se pode multiplicar o tamanho da célula do raster de entrada. Por exemplo, um valor do fator de célula de três resultaria numa saída em que o tamanho de célula é três vezes maior do que o do raster de entrada. Pode definir como tratar a extensão da saída se o número de linhas ou colunas na entrada não for um múltiplo exato do fator da célula. Por predefinição, os limites superior e direito serão expandidos para cobrir uma extensão espacial maior do que a do raster de entrada, a fim de garantir que todas as células de entrada sejam processadas. Em alternativa, os limites superior e direito podem ser reduzidos para cobrir uma extensão menor, de modo a que o número de linhas e colunas processadas seja um múltiplo exato do fator da célula. Pode definir como as células NoData devem ser tratadas pelo cálculo de agregação. O mecanismo padrão é que as células NoData de entrada que se encontrem na extensão espacial de uma célula maior no raster de saída serão ignoradas ao determinar o valor dessa célula de saída. Em alternativa, pode especificar que, se existir uma única célula NoData de entrada dentro da extensão espacial de uma célula de saída, essa célula será NoData no raster de saída.</div>",
		ccdcName: "Análise CCDC",
		ccdcSnip: "Avalia alterações nos valores de píxeis ao longo do tempo utilizando o algoritmo de Deteção e Classificação de Alterações Contínuas (CCDC) e gera resultados de modelos.",
		ccdcDesc: "A função Análise CCDC avalia as alterações nos valores de píxeis ao longo do tempo utilizando o algoritmo de Deteção e Classificação de Alterações Contínuas (CCDC) e gera um raster multidimensional com os resultados do modelo. Só é suportada em conjunto com a função Detetar Alterações Através da Análise de Alterações num modelo de função raster. Para produzir uma saída de raster, associe a função Análise CCDC à função Detetar Alterações Através da Análise de Alterações, guarde como um modelo de função raster e execute a Análise Raster com o modelo de função.<div><br/>Esta função utiliza o algoritmo de Deteção e Classificação de Alterações Contínuas (CCDC) para avaliar as alterações nos valores de píxel ao longo do tempo para uma pilha de imagens. Numa série temporal de imagens óticas ou derivados de imagens (por exemplo, NDVI), os valores de píxeis podem flutuar por várias razões: 1. Alteração sazonal -- As alterações no valor dos píxeis refletem alterações na vegetação devido à variabilidade sazonal da temperatura e da precipitação. No Hemisfério Norte, por exemplo, esperamos ver uma maior densidade de vegetação verde no verão em comparação com o inverno; 2. Alteração gradual -- As alterações no valor de píxeis refletem as tendências da vegetação ou das águas superficiais devido à variabilidade climática ou às práticas de gestão do solo a longo prazo. Por exemplo, os solos descobertos podem aumentar gradualmente em área devido à diminuição da precipitação a longo prazo; e 3. Alteração abrupta -- As alterações no valor dos píxeis refletem as alterações na cobertura do solo que ocorrem subitamente devido à desflorestação, desenvolvimento urbano, catástrofes naturais, etc. O algoritmo CCDC identifica os três tipos de alterações com o objetivo principal de identificar alterações abruptas. Os modelos de regressão harmónica e de tendência são ajustados aos dados para estimar as alterações sazonais e graduais, e os desvios bruscos em relação aos modelos de tendência são indicações de alterações abruptas.<div><br/>O algoritmo CCDC foi originalmente concebido para dados de Refletância de Superfície ou Temperatura de Brilho de dados Landsat TM, Landsat ETM+ e Landsat OLI. No entanto, a função Detetar Alterações Através da Análise de Alterações em conjunto com esta função irá detetar alterações para imagens multibanda a partir de qualquer sensor suportado, bem como derivados de imagens de banda única, tais como índices de banda. Por exemplo, é possível realizar a deteção de alterações contínuas num raster de Índice de Vegetação de Diferença Normalizada (NDVI), porque alterações abruptas no NDVI podem ser indicativas de desflorestação.</div>",
		computeChangeName: "Calcular Alteração",
		computeChangeSnip: "Calcula a diferença entre dois conjuntos de dados raster categóricos ou contínuos.",
		computeChangeDesc: "A função Calcular Alteração pode ser utilizada para enumerar as diferenças entre dois rasters classificados para análise da alteração da cobertura do solo, ou pode ser utilizada para examinar as alterações entre dois rasters contínuos de banda única, como a elevação, temperatura, coberto florestal, etc.",
		detectChangeName: "Detetar Alterações Através da Análise de Alterações",
		detectChangeSnip: "Gera uma camada raster que contém informações sobre alterações de píxeis utilizando o raster de análise de alterações de saída.",
		detectChangeDesc: "<div>A função Detetar Mudanças Através da Análise de Alterações gera uma camada raster que contém informações sobre a data de alteração de píxeis utilizando o raster de análise de alterações. O raster de análise de alterações tem de ser gerado pela ferramenta Analisar Alterações Através de CCDC ou Analisar Alterações Através de LandTrendr ou a função raster Análise CCDC ou raster Análise LandTrendr.</div><br><div>Esta função raster pode ser combinada com a função raster Análise CCDC ou raster Análise LandTrendr num modelo de função raster. Para produzir uma saída de raster, associe a função Análise CCDC ou Análise LandTrendr à função Detetar Alterações Através da Análise de Alterações, guarde como um modelo de função raster e execute a Análise Raster com o modelo de função.</div><br><div>O parâmetro <strong>Tipo de Alteração</strong> indica as informações que são geradas. As informações são extraídas do raster de análise de alterações. Ao executar esta função na saída da função/ferramenta CCDC, pode escolher entre as seguintes opções:</div><ul><li><strong>Hora da última alteração</strong> - a data e hora mais recentes em que um píxel foi sinalizado como alterado.</li><li><strong>Hora da alteração mais antiga</strong> - a primeira data e hora em que um píxel foi sinalizado como alterado.</li><li><strong>Hora da maior alteração</strong> - a data e hora em que a alteração calculada foi a mais significativa para um píxel.</li><li> <strong>Número de alterações</strong> - o número total de vezes que o píxel foi alterado.</li></ul><div>Ao executar esta função na saída da função/ferramenta LandTrendr, as seguintes opções adicionais estão disponíveis:</div><ul><li><strong>Hora da maior alteração</strong> - a data em que um píxel foi sinalizado como alterado, no início ou no final do período mais longo de alterações.</li><li><strong>Hora da menor alteração</strong> - a data em que um píxel foi sinalizado como alterado, no início ou no final do período mais curto de alterações.</li><li><strong>Hora da alteração mais rápida</strong> - a data em que um píxel foi sinalizado como alterado, no início ou no final do período de alterações mais rápido.</li><li><strong>Hora da alteração mais lenta</strong> - a data em que um píxel foi sinalizado como alterado, no início ou no final do período mais lento de alterações.</li></ul><div>O raster de saída é um raster multibanda em que cada banda contém informações de alteração consoante o tipo de alteração selecionado e o número máximo de alterações especificado. Por exemplo, se o parâmetro <strong>Tipo de Alteração</strong> estiver definido para <strong>Hora da Alteração mais Antiga</strong> e o <strong>Número Máximo de Alterações</strong> estiver definido para 2, a função calcula as duas primeiras datas mais antigas em que a alteração ocorreu ao longo da série temporal para cada píxel. O resultado é um raster em que a primeira banda contém as datas da primeira alteração mais antiga por píxel e a segunda banda contém as datas da segunda alteração mais antiga por píxel.</div><br><div>Ao aplicar esta função na saída das ferramentas LandTrendr, pode escolher se pretende extrair a data que marca o início de uma alteração ou o fim de uma alteração com o parâmetro <strong>Data do Segmento</strong>. Por exemplo, para compreender como a alteração mais recente na série temporal começou, defina o parâmetro <strong>Tipo de Alteração</strong> para <strong>Hora da última alteração</strong> e <strong>Data do Segmento</strong> para <strong>Início do segmento</strong>.</div><br><div>Use os seguintes parâmetros de filtragem para extrair datas mais específicas de alterações do seu raster de análise de alterações:</div><ul><li><strong>Filtrar por ano</strong> - identifique as alterações que ocorreram num período de tempo específico, por exemplo, se estiver à procura de alterações que ocorreram numa paisagem durante cinco anos de seca.</li><li><strong>Filtrar por duração</strong> - identifique as alterações que ocorreram ao longo de um determinado intervalo de anos, por exemplo, se estiver apenas à procura de alterações abruptas que ocorreram ao longo de 1 ou 2 anos. Pode calcular a duração que pretende ao usar a fórmula <strong>ano final - ano inicial +1</strong>. As lacunas na série temporal serão incluídas.</li><li><strong>Filtrar por magnitude</strong> - identifique alterações de uma determinada magnitude, por exemplo, se estiver apenas à procura de grandes alterações no índice de vegetação NDVI. A magnitude é um valor absoluto, por isso, os valores mínimos e máximos não podem ser negativos. Para especificar a alteração direcional, use o parâmetro <strong>Direção da Alteração</strong>.</li></ul>",
		distanceAccumulationName: "Acumulação de Distância",
		distanceAccumulationSnip: "Calcula a distância acumulada para cada célula até às origens, permitindo a distância em linha reta, distância de custo, distância de superfície verdadeira, bem como fatores de custo verticais e horizontais.",
		distanceAccumulationDesc: "A acumulação de distância calcula a distância a cada local da área de estudo até à origem mais próxima ou de menor custo. Se apenas forem fornecidas as origens para entrada, é calculada uma distância em linha reta para cada local na área de estudo. Se tanto as origens como as barreiras forem utilizadas como entrada, então a Acumulação de Distância calcula a distância em linha reta em torno das barreiras. Tanto para o raster de origem como para o raster de barreira, o valor de fundo deve ser NoData, enquanto as origens e barreiras são representadas com valores válidos de células. Os valores válidos incluem zero. <div><br/>Quando um raster de superfície é fornecido como entrada, é calculada a distância real da superfície entre células. Para realizar a análise de custos utilizando a Acumulação de Distância, é necessária uma superfície de custo. Se for fornecida uma superfície de custo, o resultado será um raster de distância de custo acumulado. Quando são fornecidos fatores horizontais e verticais, a direcionalidade é considerada como custo acumulado. Existem quatro características da origem que podem ser utilizadas. Estas características, que podem ser tanto da origem como dos motores da origem, são controladas por parâmetros específicos: 1. A acumulação inicial: define o custo inicial antes do início do movimento. 2. A acumulação máxima: especifica o custo que uma origem pode acumular antes de atingir o seu limite. 3. O multiplicador a aplicar aos custos: especifica o modo de deslocação ou a magnitude na origem. 4. A direção da viagem: identifica se o motor está a começar numa origem e a deslocar-se para locais não de origem, ou se está a começar em locais não de origem e a deslocar-se de volta para uma origem.<div><br/>Por predefinição, o resultado da Acumulação de Distância é uma banda única, que é o raster de acumulação de distância. No entanto, também pode ser criada uma segunda banda, a banda de direção de retorno. Esta banda indica, a partir de cada local na área de estudo, qual a direção a seguir para chegar à origem de menor custo. Ambas as bandas serão necessárias para determinar os melhores percursos dentro da área de estudo. Para gerar um percurso, utilize primeiro a função Extrair Banda para extrair o raster de acumulação de distância e o raster de direção de retorno. Utilize estas camadas como entrada para a função Percurso de Custos. Na função, utilize o raster de acumulação de distância como entrada de Raster de Custo de Distância e o raster de direção de retorno como entrada de Raster de Ligação Inversa de Custo.</div>",
		distanceAllocationName: "Atribuição de Distância",
		distanceAllocationSnip: "Calcula a atribuição de distâncias para cada célula até às origens fornecidas com base na distância em linha reta, distância de custo, distância de superfície verdadeira, bem como em fatores de custo verticais e horizontais.",
		distanceAllocationDesc: "A Atribuição de Distância calcula a que origem é atribuída cada localização na área de estudo. Se apenas forem fornecidas as origens para entrada, as localizações são atribuídas utilizando uma distância em linha reta até à origem mais próxima. Se tanto as origens como as barreiras forem utilizadas como entrada, então a Atribuição de Distância calcula a distância em linha reta em torno das barreiras para determinar a que origem a localização é atribuída. Tanto para o raster de origem como para o raster de barreira, o valor de fundo deve ser NoData, enquanto as origens e barreiras são representadas com valores válidos de células. Os valores válidos incluem zero.<div><br/>Para realizar uma análise de custos utilizando a Atribuição de Distância, é necessária uma superfície de custo. Se for fornecida uma superfície de custo, o resultado será um raster de atribuição baseado no custo acumulado e não na distância em linha reta. Quando são fornecidos fatores horizontais e verticais, a direcionalidade é considerada como custo acumulado. Quando um raster de superfície é fornecido como entrada, é calculada a distância de superfície real coberta ao passar entre células quando a atribuição é determinada. Existem quatro características da origem que podem ser utilizadas. Estas características, que podem ser tanto da origem como dos motores da origem, são controladas por parâmetros específicos: 1. A Acumulação Inicial: define o custo inicial antes do início do movimento. 2. A Acumulação Máxima: especifica o custo que uma origem pode acumular antes de atingir o seu limite. 3. O multiplicador a aplicar aos custos: especifica o modo de deslocação ou a magnitude na origem. 4. A direção da viagem: identifica se o motor está a começar numa origem e a deslocar-se para locais não de origem, ou se está a começar em locais não de origem e a deslocar-se de volta para uma origem.<div><br/>Por predefinição, o resultado da Atribuição de Distância é uma banda única, que é o raster de atribuição de distância. Assinalar a opção Booleana Gerar linha e coluna de origem como bandas adicionais na saída, resultará num raster multibanda composto por três bandas. A primeira banda é a banda de atribuição de distância, a segunda banda contém um índice de linhas e a terceira banda contém um índice de colunas. Estes índices identificam a localização da célula de origem que se encontra a menor distância de custo acumulado. O índice de linhas da origem e o índice de colunas da origem podem ser utilizados conjuntamente para efetuar a cartografia da intensidade. Se consultar qualquer localização na sua área de estudo através das bandas dois e três, ficará a saber qual a linha e a coluna da origem de menor custo para essa localização.</div>",
		eucBackDirectionName: "Direção de Retorno Euclidiana",
		eucBackDirectionSnip: "Calcula, para cada célula, a direção, em graus, para a célula vizinha ao longo do percurso mais curto de volta até à origem mais próxima, evitando ao mesmo tempo as barreiras.",
		eucBackDirectionDesc: "A função Direção de Retorno Euclidiana resulta num raster de ponto flutuante contínuo que representa a direção, em graus, de volta à origem mais próxima, evitando ao mesmo tempo as barreiras, caso estas sejam fornecidas.<div><br/>As entradas para a função Direção de Retorno Euclidiana são a origem para a qual a direção será calculada. Uma entrada opcional é um raster que representa as barreiras dentro da área de estudo. Tanto para o raster de origem como para o raster de barreira, o valor de fundo deve ser NoData, enquanto as origens e barreiras são representadas com valores válidos. Os valores válidos incluem zero. Por predefinição, o cálculo irá processar-se na extensão combinada das origens e das barreiras, mais 2 linhas e colunas. Se a análise só for necessária a uma distância especificada das origens, pode ser utilizado o parâmetro Distância Máxima. A Direção de Retorno Euclidiana suporta tanto um método Planar como um método Geodésico no cálculo. O cálculo do método Planar será efetuado numa superfície plana projetada utilizando um sistema de coordenadas cartesiano em 2D. O cálculo do método Geodésico será efetuado na elipsoide, o que significa que, independentemente da projeção de entrada ou saída, os resultados não se alteram.<div><br/>O resultado da função Direção de Retorno Euclidiana pode ser utilizado em conjunto com o resultado da função Distância Euclidiana para determinar os percursos mais curtos a partir de localizações dentro da área de estudo até de volta à origem. Tanto o resultado da Direção de Retorno Euclidiana como o resultado da Distância Euclidiana são utilizados na função Percurso de Custo juntamente com os destinos para gerar os percursos mais curtos.</div>",
		expandName: "Expandir",
		expandSnip: "Expande zonas selecionadas de um raster por zonas por um número especificado de células.",
		expandDesc: "Com a função global Expandir, pode generalizar ou simplificar os rasters, tornando zonas específicas maiores. Pode também controlar a quantidade de generalização que irá ocorrer.<div><br/>As zonas que selecionar irão aumentar de tamanho expandindo-se para outras zonas. Conceptualmente, os Valores de Zona selecionados podem ser vistos como zonas de primeiro plano, enquanto os outros valores permanecem como zonas de segundo plano. As zonas de primeiro plano podem expandir-se para as zonas de segundo plano.<div><br/>A quantidade de generalização pode ser controlada com o parâmetro Número de Células. Por predefinição, este valor é 1, o que significa que as zonas selecionadas irão expandir-se pela quantidade correspondente ao tamanho de uma célula. Para aumentar o grau de generalização, pode especificar um valor maior para este parâmetro. Conceptualmente, isto é como executar a ferramenta tantas vezes quanto o número especificado, com os resultados da execução anterior a ser a entrada para a iteração seguinte.</div>",
		trendAnalysisName: "Gerar Tendência",
		trendAnalysisSnip: "Estima a tendência para cada píxel ao longo de uma dimensão para uma ou mais variáveis num raster multidimensional.",
		trendAnalysisDesc: "<div>Esta função pode ser usada para ajustar dados ao longo de uma linha de tendência linear, harmónica ou polinomial ou pode ser usada para realizar a deteção de tendências com o teste Mann-Kendall ou Sazonal-Kendall.</div><br><div>O raster de tendência de saída gerado com esta função é usado como entrada para a função <strong>Prever Através de Tendência</strong>.</div><br><div>Os testes de Mann-Kendall e Seasonal-Kendall são usados para determinar se existe uma tendência monotónica nos dados. Não são paramétricos, o que significa que não admitem uma distribuição específica dos dados. O teste de Mann-Kendall não considera a correlação de série ou efeitos sazonais. Se os dados forem sazonais, o teste de Sazonal-Kendall é o mais adequado.</div><br><div>Se a ferramenta for usada para realizar o teste de Mann-Kendall ou Seasonal-Kendall, a saída é um raster de cinco bandas como apresentado a seguir:</div><ul><li>Banda 1 = Inclinação de Sen</li><li>Banda 2 = Valor P</li><li>Banda 3 = Pontuação Mann-Kendall (S)</li><li>Banda 4 = Variação S</li><li>Banda 4 = Variação S</li><li>Banda 5 = Valor Z</li></ul><div>As saídas do teste Mann-Kendall ou Seasonal-Kendall podem ser usadas para determinar que píxeis na sua série temporal multidimensional têm uma tendência estatisticamente significativa. Pode usar estas informações em conjunto com a análise de tendência linear, harmónica ou polinomial para extrair tendências significativas na sua série temporal. Pode gerar uma máscara incluindo píxeis com valores p significativos, aplicar a máscara ao raster multidimensional e usar este raster multidimensional mascarado como entrada para a ferramenta para realizar análises de tendências lineares, harmónicas ou polinomiais.</div><br><div>Existem três opções de linha de tendência para ajustar uma tendência aos valores das variáveis ao longo de uma dimensão: linear, polinomial e harmónica.</div><br><div>Para uma análise de tendência linear, a saída é um raster de três bandas como apresentado a seguir:</div><ul><li>Banda 1 = Inclinação</li><li>Banda 2 = Interceção</li><li>Banda 3 = Erro Médio Quadrático (RMSE) ou o erro em torno da linha de melhor ajuste</li></ul><div>Para uma análise de tendência polinomial, o número de bandas na saída depende da ordem polinomial. O ajuste polinomial de segunda ordem produz um raster de quatro bandas como apresentado a seguir:</div><ul><li>Banda 1 = Polynomial_2</li><li>Banda 2 = Polynomial_1</li><li>Banda 3 = Polinomial_0</li><li>Banda 4 = RMSE</li></ul><div>O ajuste polinomial de terceira ordem produz um raster de cinco bandas como apresentado a seguir:</div><ul><li>Banda 1 = Polinomial_3</li><li>Banda 2 = Polinomial_2</li><li>Banda 3 = Polinomial_1</li><li>Banda 4 = Polinomial_0</li><li>Banda 5 = RMSE</li></ul><div>Para uma análise de tendência harmónica, o número de bandas na saída depende da frequência harmónica. Quando a frequência é definida como 1, a saída é um raster de cinco bandas como apresentado a seguir:</div><ul><li>Banda 1 = Inclinação</li><li>Banda 2 = Interceção</li><li>Banda 3 = Harmónica_sin1</li><li>Banda 4 = Harmónica_cos1</li><li>Banda 5 = RMSE</li></ul><div>Quando a frequência é definida como 2, a saída é um raster de sete bandas como apresentado a seguir:</div><ul><li>Banda 1 = Inclinação</li><li>Banda 2 = Interceção</li><li>Banda 3 = Harmónica_sin1</li><li>Banda 4 = Harmónica_cos1</li><li>Banda 5 = Harmónica_sin2</li><li>Banda 6 = Harmónica_cos2</li><li>Banda 7 = RMSE</li></ul><div>O parâmetro <strong>Duração do Ciclo</strong> para a análise de tendência harmónica é usado para indicar o número e a duração dos ciclos que espera ver nos seus dados ao longo de um dia ou ano. Por exemplo, se espera que os seus dados passem por dois ciclos de variação num ano, a duração do ciclo será de 182,5 dias ou 0,5 anos. Se tiver dados de temperatura recolhidos a cada três horas e existir um ciclo de variação por dia, a duração do ciclo é de um dia.</div><br><div>O parâmetro <strong>Frequência</strong> para a análise de tendência harmónica é usado para descrever o modelo harmónico a ajustar-se aos dados. Se a frequência for definida como 1, uma combinação de curva linear e de curva harmónica de primeira ordem será usada para se ajustar ao modelo. Se a frequência for 2, uma combinação de curva harmónica linear de primeira ordem e de curva harmónica de segunda ordem será usada para se ajustar aos dados. Se a frequência for 3, uma curva harmónica de terceira ordem adicional será usada para modelar os dados e assim por diante.</div><br><div>As estatísticas de ajustamento do modelo podem ser geradas como saídas opcionais. O erro médio quadrático (RMSE), R-quadrado e o valor p da inclinação da tendência podem ser calculados e simbolizados. Simbolize a camada raster de tendência de saída com a simbologia <strong>RGB</strong> e especifique as estatísticas como as bandas vermelha, verde e azul.</div><br>",
		spectralUnmixingName: "Desmistura Espetral Linear",
		spectralUnmixingSnip: "Efetua a classificação por subpíxeis e calcula a abundância fracionada dos diferentes tipos de cobertura do solo para píxeis individuais.",
		spectralUnmixingDesc: "A função Desmistura Espetral Linear calcula a cobertura fracionada de píxeis individuais que contêm vários tipos de cobertura do solo. Gera uma camada multibanda, em que cada banda corresponde à abundância fracionária de cada classe de cobertura do solo. Por exemplo, pode utilizá-la para realizar a classificação da cobertura do solo numa imagem multiespectral para identificar vegetação fotossintética, solo descoberto e vegetação morta ou não fotossintética.<div><br/>A ordem do raster multibanda de saída segue a ordem do perfil espetral de entrada. O número de classes não pode exceder o número de bandas no raster de entrada. Por exemplo, não se pode extrair informações sobre mais de 8 classes a partir de um raster de 8 bandas.</div>",
		multidimensionalFilterName: "Filtro Multidimensional",
		interpolateRasterByDimensionFunctionName: "Interpolar Raster por Dimensão",
		interpolateRasterByDimensionFunctionSnip: "Interpola um raster multidimensional em valores de dimensão especificados com secções adjacentes.",
		interpolateRasterByDimensionFunctionDesc: "<p>Esta função permite estimar valores de píxel para uma secção de dimensão indefinida num raster multidimensional. Por exemplo, se tiver um conjunto de dados com a temperatura do oceano ao nível da superfície e a 100 metros abaixo do nível do mar e pretender estimar a temperatura a 50 metros abaixo do nível do mar, pode usar esta função para obter uma estimativa a essa profundidade com a definição de dimensão Por Valores.</p><p>Também pode subamostrar um conjunto de dados mensal num conjunto de dados diário com a definição de dimensão Por Intervalo e ao especificar o valor de parâmetro Etapa como 1 e o valor de parâmetro Unidade como Dias.</p><p>Use a definição de dimensão Por Raster de Destino para estimar o valor do Raster de Destino.</p>",
		multidimensionalFilterSnip: "Cria uma camada raster a partir de um conjunto de dados raster multidimensional ou de uma camada raster multidimensional, seccionando os dados ao longo de variáveis e dimensões definidas.",
		multidimensionalFilterDesc: "O Filtro Multidimensional cria uma camada raster multidimensional através da filtragem e extração de um subconjunto de variáveis a partir de um raster multidimensional. Por exemplo, tem um conjunto de dados multidimensional que contém 30 anos de dados mensais sobre precipitação e só quer extrair dados para cada mês de janeiro para ver como a precipitação mudou para esse mês.<div><br/>Utilize o parâmetro Definição de Dimensão para seccionar dimensões utilizando um intervalo, um valor, ou um intervalo de valores. Por exemplo, se tiver 10 anos de dados relativos à salinidade dos oceanos recolhidos mensalmente e a cada 2 metros de profundidade até 500 metros, pode utilizar as diferentes opções de definição de dimensão para os cenários seguintes. Cenário 1: extrair dados relativos à salinidade para o mês de janeiro durante o período de 10 anos. Escolha Por Valores, defina Dimensão para StdTime e defina Valores para Janeiro. Cenário 2: seccionar os dados relativos à salinidade num intervalo de profundidade de 0 a 150 metros. Escolha Por Intervalos, defina Dimensão para StdZ e defina Valor Mínimo para -150 e Valor Máximo para 0. Cenário 3: extrair dados relativos à salinidade para os primeiros 10 dias de cada mês de janeiro durante um período de 10 anos. Escolha Por Iteração, defina Dimensão para StdTime, defina Início da primeira iteração e Fim da primeira iteração para os respetivos início e fim do período de iteração, defina Passo para 1, e defina Unidade para Anos.</div>",
		multidimensionalRasterName: "Raster Multidimensional",
		multidimensionalRasterSnip: "Adiciona dados multidimensionais a um mapa como uma camada raster multidimensional.",
		multidimensionalRasterDesc: "A função Raster Multidimensional adiciona dados multidimensionais a um mapa como uma camada raster multidimensional. Esta função é útil ao realizar fluxos de trabalho de análise raster utilizando uma cadeia de funções.<div><br/>Os conjuntos de dados raster multidimensionais incluem netCDF, GRIB, HDF e CRF da Esri. Os conjuntos de dados de mosaico multidimensionais também são suportados.</div>",
		optimalPathAsRasterName: "Melhor Percurso Como Raster",
		optimalPathAsRasterSnip: "Calcula o percurso de menor custo a partir de uma origem até um destino.",
		optimalPathAsRasterDesc: "Esta função global produz um raster de saída que regista o(s) melhor(es) percurso(s) a partir de locais selecionados até à célula de origem mais próxima definida dentro da superfície de custo acumulado, em termos de distância de custo.<div><br/>Uma ou mais das funções de custo ponderado (Acumulação ou Atribuição de Distância) devem geralmente ser executadas antes da função Melhor Percurso Como Raster para criar a acumulação de distância de entrada e os rasters de direção de retorno. Estas são camadas raster de entrada obrigatórias para a função Melhor Percurso. Os valores no melhor percurso de saída representam o número de percursos num determinado local. Em muitos casos, os percursos seguem o mesmo itinerário, deixando uma origem e divergindo depois para destinos diferentes. Por exemplo, um valor de um indica que existe apenas um melhor percurso num determinado local, enquanto um valor de cinco significa que, nesse local, existem cinco melhores percursos que atravessam essa célula na área de estudo.<div><br/>Os dados de destino de entrada devem ser uma camada raster. O conjunto de células de destino é composto por todas as células do raster de entrada com valores válidos. As células que têm valores NoData não estão incluídas no conjunto. O valor zero é considerado um destino legítimo. Pode ser criado um raster de destino utilizando as ferramentas de extração. Se tiver elementos de destino ou de origem, pode convertê-los para um raster utilizando a função Rasterizar Elementos. Utilize a acumulação de distância ou o raster de direção de retorno como entrada Raster para a função de rasterização. Isto irá assegurar que o elemento é rasterizado utilizando o mesmo tamanho de célula, extensão e referência espacial que os outros rasters que vão para a função Melhor Percurso Como Raster. A função Melhor Percurso Como Raster também pode ser utilizada para derivar o percurso de menor resistência até um modelo de elevação digital (DEM). Neste caso, utilize o DEM para o raster de acumulação de distância de entrada e a saída da função Direção do Fluxo para o Raster de direção de retorno.</div>",
		trendName: "Prever através de Tendência",
		trendSnip: "Calcula uma camada raster multidimensional prevista utilizando o raster de tendência de saída da função Gerar Tendência ou da ferramenta de geoprocessamento Gerar Raster de Tendência.",
		trendDesc: "A função Prever através de Tendência calcula uma camada raster multidimensional prevista utilizando o raster de tendência de saída da função Gerar Tendência ou da ferramenta de geoprocessamento Gerar Raster de Tendência.",
		rasterCollectionName: "Processar Coleção de Rasters",
		rasterCollectionSnip: "Processa cada secção num raster multidimensional ou cada item num raster em mosaico. Esta função pode também agregar várias secções numa única secção.",
		rasterCollectionDesc: "A função Processar Coleção de Rasters processa cada secção num raster multidimensional ou cada item num raster em mosaico. Esta função pode também agregar várias secções numa única secção.<div><br/>Esta função processa cada secção num raster multidimensional ou raster em mosaico utilizando um modelo de função raster. Esta função suporta as seguintes opções: 1. Especifique um modelo de função raster para a Função de Item. Por exemplo, tem um conjunto de dados em mosaico que contém 20 anos de imagens Landsat e pretende calcular o NDVI para cada cena da série temporal. Para a Função de Item, especifique um modelo de função raster que contenha a função raster NDVI. 2. Especifique um modelo de função raster para a Função de Agregação. Por exemplo, tem um raster multidimensional que contém 10 anos de dados relativos à temperatura diária e pretende calcular a temperatura máxima para cada ano. Na Função de Agregação, especifique um modelo de função raster que contenha a função Estatísticas de Células, com a operação definida como Máxima. Em Definição de Agregação, defina Dimensão para StdTime, Tipo para Palavra-chave de Intervalo e Palavra-chave de Intervalo para Anualmente. Note que se o conjunto de dados do mosaico de entrada não for multidimensional, a função de agregação não irá respeitar a definição de agregação. A função de agregação agregará todos os itens ou cada grupo num só se estes estiverem definidos no modelo da função de agregação. Para mais informações sobre a utilização de grupos num conjunto de dados de mosaico, consulte Utilizar Itens do Conjunto de Dados de Mosaico em Modelos da Função Raster. 3. Especifique um modelo de função raster para a Função de Processamento. A função ou cadeia de funções neste modelo é utilizada para exibir o novo raster processado. Por exemplo, especifique um modelo de função raster que contenha a função Mapa de Cor para alterar a forma como a camada raster processada é exibida. Tenha em conta que se a entrada for um raster multidimensional, a função de processamento é aplicada à secção de exibição atual. Se a entrada for uma camada de mosaico ou um conjunto de dados em mosaico, a função de processamento é aplicada ao raster de mosaico utilizando o Primeiro método para resolver sobreposições. 3. Especifique os modelos para qualquer combinação das três funções. Por exemplo, tem um conjunto de dados em mosaico que contém imagens da série temporal Landsat e pretende gerar uma imagem composta do NDVI máximo. Para a Função de Item, especifique um modelo de função raster que contenha a função raster NDVI. Para a Função de Agregação, especifique um modelo de função raster que contenha a função Estatísticas de Células, com a operação definida para Máximo. Para a Função de Processamento, especifique um modelo de função raster que contenha a função Mapa de Cor. Tenha em conta que a ordem de processamento da função segue a ordem dos parâmetros de entrada. Por exemplo, a Função de Item será processada em primeiro lugar.</div>",
		randomName: "Aleatório",
		randomSnip: "Cria um raster com valores de píxeis aleatórios desenhados de uma distribuição pseudoaleatória. São suportadas várias distribuições e geradores de números aleatórios.",
		randomDesc: "A função Aleatório cria um raster com valores de píxeis aleatórios que podem ser utilizados em modelos de funções raster ou conjuntos de dados em mosaico.<div><br/>Embora muitas funções funcionem num ou vários rasters de entrada, a função Aleatório não requer um raster de entrada. Isto significa que se comporta mais como um conjunto de dados raster do que como uma função, pelo que é necessário ter um cuidado especial ao adicioná-la ou removê-la da cadeia de funções.</div>",
		shrinkName: "Reduzir",
		shrinkSnip: "Reduz as zonas selecionadas por um número especificado de células, substituindo-as pelo valor da célula que é mais frequente na sua vizinhança.",
		shrinkDesc: "Com a função global Reduzir, pode generalizar ou simplificar os rasters, tornando as zonas específicas mais pequenas. Pode também controlar a quantidade de generalização que irá ocorrer.<div><br/>As zonas que selecionar irão encolher, ou reduzir em tamanho, tendo células das zonas circundantes a expandir-se para elas. Conceptualmente, os Valores de Zona selecionados podem ser vistos como zonas de primeiro plano, enquanto os outros valores permanecem como zonas de segundo plano. As células nas zonas de primeiro plano podem ser substituídas por células nas zonas de segundo plano. As ilhas finas dentro de uma zona, que podem ser vistas como partilhando limites com a zona, também podem ser substituídas.<div><br/>A quantidade de generalização pode ser controlada com o parâmetro Número de Células. Por predefinição, este valor é 1, o que significa que as zonas selecionadas irão reduzir-se pela quantidade correspondente ao tamanho de uma célula. Para aumentar o grau de generalização, pode especificar um valor maior para este parâmetro. Conceptualmente, isto é como executar a ferramenta tantas vezes quanto o número especificado, com os resultados da execução anterior a ser a entrada para a iteração seguinte.</div>",
		trendToRGBName: "Tendência para RGB",
		trendToRGBSnip: "Converte um raster de tendência num raster de três bandas (vermelho, verde e azul).",
		trendToRGBDesc: "A função Tendência para RGB converte um raster de tendência num raster de três bandas (vermelho, verde e azul). O raster de tendência é gerado a partir da função raster Gerar Tendência ou da função raster Análise CCDC.<div><br/>Esta função é útil para visualizar dados do coeficiente do modelo da função Gerar Tendência ou da função Análise CCDC. Ambas as funções estimam tendências em valores de píxeis variáveis, mas os resultados das funções são difíceis de interpretar diretamente.<div><br/>Tal como muitas funções raster, pode ter de utilizar o Ajuste de Intervalo Dinâmico (DRA) para visualizar melhor os resultados desta função.</div>",
		landTrendrName: "Análise LandTrendr",
		landTrendrSnip: "Avalia as alterações nos valores de píxeis ao longo do tempo com o método Landsat de deteção de tendências de perturbação e recuperação (LandTrendr) e gera um raster de análise de alterações com os resultados do modelo.",
		landTrendrDesc: "Esta função raster só pode ser usada como entrada para a função raster Detetar Alterações Através da Análise de Alterações. Para gerar uma saída raster, associe a função Análise LandTrendr à função Alterações Através da Análise de Alterações num modelo de função raster, e utilize o modelo como entrada na ferramenta de geoprocessamento Gerar Raster a partir da Função Raster. O resultado é um raster que contém informações relativas ao tempo em que os valores de píxel se alteraram.<div><br>O objetivo desta função raster é extrair alterações num elemento observado, pelo que as imagem multidimensionais de entrada ideais devem capturar uma observação consistente ao longo do tempo e não devem incluir interferência atmosférica ou de sensor, nuvens, ou sombra de nuvem. A melhor prática é utilizar dados que tenham sido normalizados e possam ser mascarados utilizando uma banda de QA, por ex., de Refletância de Superfície Landsat Coleção 1 com uma máscara de nuvem.<div><br>A função efetua análises numa imagem por ano, e o número de secções anuais deve ser igual ou superior ao valor especificado no parâmetro <strong>Número Mínimo de Observações</strong>. Recomenda-se que tenha pelo menos seis anos de dados.<div><br>Se tiver dados mensais, semanais ou diários, recomenda-se que selecione várias imagens de cada ano (de preferência, da mesma estação), remova as nuvens e a sombra das nuvens, e combine as imagens para gerar uma única imagem que capte bem a observação. Se forem fornecidos dados mensais, semanais, ou diários como raster de dados multidimensional, a função identificará uma secção para análise com base na data mais próxima da fornecida no parâmetro <strong>Ajuste da Data</strong>.<div><br>Um elemento numa paisagem levará frequentemente tempo a recuperar de uma alteração não permanente como um incêndio florestal ou uma infestação de insetos. Para controlar a taxa de recuperação reconhecida pelo modelo, defina o parâmetro Limiar de Recuperação. Um segmento distinto não pode ter uma taxa de recuperação mais rápida do que 1/limiar de recuperação.<div><br>A recuperação de uma alteração na paisagem pode ocorrer na direção positiva ou negativa. Por exemplo, quando uma paisagem experimenta uma perda florestal, uma série temporal de valores do índice de vegetação apresenta uma queda nos valores do índice, e a recuperação mostra um aumento gradual nos valores do índice de vegetação, ou uma tendência positiva de recuperação. Especificar a direção da tendência de recuperação com o parâmetro <strong>Recuperação com Tendência Crescente</strong>.",
		aggregateMultidimensionalName: "Agregar Multidimensional",
		aggregateMultidimensionalSnip: "Combina dados variáveis raster multidimensionais existentes ao longo de uma dimensão.",
		aggregateMultidimensionalDesc: "A função Agregar Multidimensional cria uma camada raster multidimensional ao combinar dados existentes de variáveis raster multidimensionais ao longo de uma dimensão.<div><br>Use o parâmetro <strong>Definição da Dimensão</strong> para filtrar primeiro os dados de entrada que pretende agregar. Por exemplo, se tiver 30 anos de dados mensais, mas apenas quiser criar uma camada agregada durante os primeiros 15 anos, pode usar o parâmetro <strong>Definição da Dimensão</strong> para especificar os anos a incluir na análise.<div><br><ul><li>Extrair dados relativos à salinidade para o mês de janeiro durante o período de 10 anos. Selecione <strong>Por Valores</strong>, defina <strong>Dimensão</strong> para <strong>StdTime</strong> e defina <strong>Valores</strong> para <strong>Janeiro</strong>.</li><li>Seccione os dados relativos à salinidade num intervalo de profundidade de 0 a 150 metros. Selecione <strong>Por Intervalos</strong>, defina <strong>Dimensão</strong> para <strong>StdZ</strong> e defina <strong>Valor Mínimo</strong> para <strong>-150</strong> e <strong>Valor Máximo</strong> para <strong>0</strong>.</li><li>Extraia dados relativos à salinidade para os primeiros 10 dias de cada mês de janeiro durante um período de 10 anos. Selecione <strong>Por Iteração</strong>, defina <strong>Dimensão</strong> para <strong>StdTime</strong>, defina <strong>Início da primeira iteração</strong> e <strong>Fim da primeira iteração</strong> para o início e fim correspondentes do período de iteração, defina <strong>Passo</strong> para <strong>1</strong> e defina <strong>Unidade</strong> para <strong>Anos</strong>.</li></ul><div><br>Use os parâmetros <strong>Definição de Agregação</strong> para selecionar a dimensão a avaliar e o intervalo de agregação usando uma palavra-chave, um valor ou um intervalo de valores. Por exemplo, se tiver 30 anos de dados de temperatura à superfície do mar, recolhidos diariamente e a cada 5 metros de profundidade até 100 metros, pode utilizar as diferentes opções de intervalo para os seguintes cenários:<div><br><ul><li>Agregar dados diários de temperatura em dados mensais, onde o resultado é um raster multidimensional com 12 secções de tempo, e cada secção é o agregado de cada mês ao longo de todos os anos. Selecione <strong>Palavra-chave de Intervalo</strong> e defina a palavra-chave para <strong>Mensal Recorrente</strong>.</li><li>Agregue dados diários de temperatura em dados mensais, onde o resultado é um raster multidimensional com 360 secções ou 12 secções de tempo por ano (30 anos x 12 meses = 360 secções). Selecione <strong>Palavra-chave de Intervalo</strong> e defina a palavra-chave para <strong>Mensal</strong>.</li><li>Agregue os dados de temperatura mensais em intervalos de 4 meses. Selecione <strong>Valor de Intervalo</strong>, defina <strong>Intervalo de Valor</strong> para 4 e defina <strong>Unidade</strong> para <strong>Meses</strong>.</li><li>Agregue os dados de temperatura de 0 a 25 metros, e depois de 25 a 50 metros, e de 50 a 100 metros. Selecione <strong>Intervalos</strong> e especifique as profundidades mínima e máxima como <strong>0 25; 25 50; 50 100</strong>.</li></ul>",
		mergeRastersName: "Intercalar Rasters",
		mergeRastersSnip: "Combina múltiplos conjuntos de dados raster espacialmente ou através de variáveis e dimensões.",
		mergeRastersDesc: "Esta função cria um raster intercalado a partir de uma lista de rasters. Por exemplo, se tiver um conjunto de dados em mosaico que contenha 30 anos de dados mensais de precipitação e outro conjunto de dados com 10 anos de dados mensais de temperatura, pode combiná-los num raster multidimensional com ambas as variáveis. <div><br>Se os rasters multidimensionais de entrada contiverem variáveis diferentes, o raster multidimensional de saída conterá todas as variáveis. <div><br>Se os rasters multidimensionais de entrada contiverem diferentes dimensões ou valores dimensionais, o raster multidimensional de saída incluirá todas as dimensões e valores dimensionais. <div><br>Se os rasters multidimensionais de entrada contiverem as mesmas dimensões e variáveis, mas extensões espaciais diferentes, o raster multidimensional de saída incluirá as variáveis e dimensões em todas as extensões espaciais intercaladas.<div><br>Esta função também pode ser usada quando se tem vários rasters que se pretende tratar como um único item, tal como calcular as mesmas estatísticas para todos, ou quando se faz o balanço de cor para que não seja necessário fazer o balanço de cor de cada imagem separadamente. Isto é útil quando se trabalha com imagens armazenadas como mosaicos separados devido a restrições de tamanho de ficheiro; desta forma, os mosaicos serão tratados como parte da mesma imagem.",
		boundaryCleanName: "Limpeza de Limites",
		boundaryCleanSnip: "Suaviza o limite entre as zonas.",
		boundaryCleanDesc: "<p>A função generaliza ou simplifica rasters ao suavizar os limites entre as zonas. A função fornece opções para controlar como as células das zonas na entrada influenciam a suavização e a quantidade de suavização que será aplicada. Cada célula de entrada é avaliada usando os oito vizinhos imediatos correspondentes.</p><p>O processo de suavização primeiro classifica as células vizinhas por uma prioridade particular. A prioridade determina que zona das células vizinhas pode substituir o valor da célula de processamento na saída.</p><p>A prioridade pode ser baseada no valor das zonas ou no tamanho das zonas. O parâmetro <strong>Tipo de Ordenação</strong> determina o tipo de ordenação a ser usado. </p><p>A predefinição <strong>Não ordenar</strong> avalia a prioridade com base no valor das zonas. As células de zonas com valores maiores terão uma prioridade mais alta para se expandirem para zonas com valores menores.</p><p>O tamanho/área total das zonas pode ser usado para classificar a prioridade. Com a definição <strong>Decrescente</strong>, as zonas são classificadas por tamanho em ordem decrescente. As zonas com áreas totais maiores terão prioridade de expansão para zonas com áreas menores. Com a definição <strong>Crescente</strong>, o oposto é verdadeiro: zonas com áreas totais menores terão prioridade de se expandirem para zonas com áreas totais maiores.</p><p>A quantidade de suavização é controlada pelo parâmetro <strong>Executar expansão e redução duas vezes</strong>, que determina o número de vezes que o processo de expansão e redução será realizado.</p><p>Com a definição não selecionada, o processo de expansão e redução é executado uma vez. Com a definição selecionada, o processo de expansão e redução é realizado duas vezes, resultando num grau adicional de suavização dos limites da zona.</p><p>Se os valores de todas as oito células vizinhas forem iguais aos da célula de processamento, a célula de saída manterá o valor da célula de entrada.</p>",
		predictUsingRegressionName: "Prever Com Regressão",
		predictUsingRegressionSnip: "Calcula um raster previsto com base em entradas de dados raster e num modelo de regressão. O modelo de regressão é a saída da ferramenta de geoprocessamento raster <strong>Modelo de Regressão Train Random Trees (Preparar Árvores Aleatórias)</strong>.",
		predictUsingRegressionDesc: "<p>O modelo de regressão é definido num ficheiro de definição de regressão Esri (.ecd). Contém todas as informações para um conjunto de dados específico ou conjunto de conjuntos de dados e o modelo de regressão e é gerado pela ferramenta de geoprocessamento raster <strong>Modelo de Regressão Train Random Trees (Preparar Árvores Aleatórias)</strong>.</p><p>A entrada pode ser uma única banda, uma multibanda ou um raster multidimensional ou uma lista destes tipos. Os tipos de rasters de entrada têm de ser do mesmo tipo de raster formado pelo modelo de regressão.</p><ul><li>Quando a entrada é um raster multibanda, cada banda é tratada como uma variável de previsão. As bandas têm de estar na mesma ordem que a entrada multibanda para a ferramenta de formação do modelo de regressão.</li><li>Quando a entrada é um raster multidimensional, cada variável é tratada como uma variável de previsão e a variável tem de ser de banda única e ter uma dimensão de tempo. A ordem e os nomes das variáveis têm de ser iguais aos da entrada quando o modelo de regressão foi formado. A saída é um raster multidimensional.</li><li>A entrada pode ser uma lista de itens. O número e a ordem dos itens têm de corresponder à entrada quando o modelo de regressão foi formado.</li></ul>",
		dimensionalMovingStatisticsName: "Estatísticas de Movimento Dimensional",
		dimensionalMovingStatisticsSnip: "Calcula estatísticas durante uma janela em movimento em dados multidimensionais ao longo de uma dimensão especificada.",
		dimensionalMovingStatisticsDesc: "<p>A função Estatísticas de Movimento Dimensional calcula várias estatísticas numa janela predefinida para todos os valores de dimensão ao longo de uma dimensão. Esta função recebe uma camada raster multidimensional como entrada e cria uma camada raster multidimensional como saída com o mesmo tamanho dimensional da camada de entrada.</p><p>Pode especificar uma dimensão para a qual os valores de dimensão são considerados durante o cálculo. Por predefinição, a função calcula ao longo da primeira dimensão não espacial. Também pode especificar um tamanho de janela ao especificar os parâmetros Janela Anterior e Janela Posterior.</p><p>Quando o Tipo de Estatística é definido como Percentil, os parâmetros Valor de Percentil e Tipo de Interpolação de Percentil ficam disponíveis. Pode usar estes parâmetros para especificar o percentil a ser calculado e escolher o tipo de interpolação a ser usado, respetivamente. Quando o Tipo de Estatística é definido como Média Circular, o parâmetro Valor de Moldagem Circular fica disponível. O valor de moldagem circular é usado para converter um valor linear no intervalo de uma determinada média circular.</p>",
		terrainFlattenFunctionName: "Aplanamento de Terreno",
		terrainFlattenFunctionSnip: "Corrige os dados de entrada do radar de abertura sintética (SAR) para distorções radiométricas devidas à topografia.",
		terrainFlattenFunctionDesc: "<p>A função raster Aplanamento de Terreno corrige os dados de entrada do radar de abertura sintética (SAR) para distorções radiométricas devidas à topografia.</p><p>Os dados de entrada do radar têm de ser primeiro calibrados para beta-zero. Utilize a ferramenta Aplicar Calibração Radiométrica para calibrar os dados de radar para beta-zero.</p><p>Se a entrada de DEM não abranger o conjunto de dados SAR completo, a ferramenta irá produzir valores NoData para os píxeis fora da extensão de DEM para beta-zero, sigma-zero, área de dispersão e saídas de distorção geométrica. Para a saída da máscara de distorção geométrica, a ferramenta irá produzir valores indeterminados para os píxeis fora da extensão de DEM.</p><p>A entrada de DEM tem de estar no sistema de coordenadas geográficas WGS 1984 (EPSG:4326).</p>",
		createColorCompositeFunctionName: "Criar Composição de Cores",
		createColorCompositeFunctionSnip: "Cria um raster de três bandas a partir de um conjunto de dados raster multibanda no qual cada banda pode utilizar um cálculo algébrico baseado em álgebra de banda.",
		createColorCompositeFunctionDesc: "<p>A função raster Criar Composição de Cores cria um raster de três bandas a partir de um conjunto de dados raster multibanda no qual cada banda pode utilizar um cálculo algébrico baseado em álgebra de banda.</p><p>Ao definir um algoritmo aritmético de banda, pode introduzir uma fórmula algébrica de uma linha para cada expressão para criar uma saída multibanda. Os operadores suportados são unários: mais (+), menos (-), multiplicação (*) e divisão (/).</p><p>Ao utilizar um ID de banda numa expressão, identifique a banda através do prefixo B ou b para o número de banda.</p><p>Uma combinação de banda comum utilizada para o radar de abertura sintética (SAR) em unidades lineares é VV para vermelho, VH para verde e VV/VH para azul. Se os dados de entrada estiverem em decibéis, a combinação de bandas deve ser VV para vermelho, VH para verde e VV-VH para azul.</p>",
		surfaceParametersName: "Parâmetros de Superfície",
		surfaceParametersSnip: "Determina parâmetros de um raster de superfície como aspeto, inclinação e vários tipos de curvaturas através de métodos geodésicos.",
		surfaceParametersDesc: "<p>A função Parâmetros de Superfície determina parâmetros de um raster de superfície como aspeto, inclinação e vários tipos de curvaturas através de métodos geodésicos.</p><p>Esta função pode ser utilizada para as seguintes aplicações:</p><ul><li>Calcular aspeto e inclinação através de métodos geodésicos.</li><li>Calcular diferentes tipos de curvaturas a partir de um raster de superfície de entrada, por exemplo, <strong>Curvatura tangencial (contorno normal)</strong> que caracteriza a convergência topográfica e a divergência do fluxo na superfície.</li></ul>",
		leastCostCorridorName: "Corredor de Menor Custo",
		leastCostCorridorSnip: "Calcula a soma de dois rasters de distância de custo acumulado com a opção de aplicar um limiar baseado na percentagem ou no custo acumulado.",
		leastCostCorridorDesc: "<p>Os rasters de entrada devem ser rasters de acumulação de distância e rasters de direção de retorno resultantes da função <strong>Acumulação de Distância</strong> ou <strong>Atribuição de Distância</strong>. Estes devem basear-se na distância de custo e devem ser utilizados os mesmos parâmetros ao criar as camadas para cada fonte. Nenhum parâmetro que dependa da direcionalidade (fator horizontal, fator vertical e direção de viagem) deve ser utilizado na criação destes raster.</p><p>Os valores no raster de corredor de saída são a soma do custo acumulado para alcançar uma determinada localização com as mesmas unidades que os rasters de distância de custo acumulado de entrada.</p><p>Se um valor de <strong>Limiar</strong> especificado for superior ao custo acumulado máximo quando os dois rasters de acumulação de distância são somados, o raster de corredor de saída irá cobrir a mesma área que os rasters de acumulação de entrada.</p><p>Se um valor de limiar especificado for inferior ao valor mínimo no raster de corredor, é devolvida uma mensagem de aviso e o raster de saída estará vazio.</p><p>O raster de corredor de saída pode conter células com custos acumulados ligeiramente superiores ao valor limite. Isto deve-se ao facto de os rasters de direção de retorno utilizarem células às quais foram atribuídos custos ligeiramente superiores ao limiar para ligar células desconectadas ao corredor.</p>",
		geometricMedianName: "Mediana Geométrica",
		geometricMedianSnip: "A função Mediana Geométrica calcula a mediana geométrica dos píxeis numa série temporal de imagens multibanda.",
		geometricMedianDesc: "<p>Esta função reduz o ruído e os valores atípicos em imagens de séries temporais, calculando um píxel mediano geométrico para cada conjunto de píxeis na pilha de imagens. O algoritmo mantém as relações espectrais entre as bandas nos espectros de píxeis, pelo que o resultado pode ser utilizado em análises, tais como índices de vegetação.</p><p>As nuvens e sombras devem ser mascaradas com a banda QA do conjunto de dados antes de aplicar esta função.</p><p>Se a imagem de entrada for de ponto flutuante, tal como a refletância de superfície com valores entre 0 e 1, um valor epsilon de 0,001 deverá produzir resultados de qualidade.</p>"
	},
	rfxArgs: {
		rasterName: "Raster",
		colorSchemeTypeName: "Tipo de Esquema de Cores",
		colormapName: "Mapa de Cores",
		colormapNameName: "Nome do Mapa de Cores",
		colorRampName: "Rampa de Cores",
		contrastOffsetName: "Desvio de Contraste",
		brightnessOffsetName: "Desvio de Luminosidade",
		methodName: "Método",
		bandNamesName: "Nomes de Bandas",
		bandWavelengthsName: "Comprimentos de Onda de Bandas",
		bandIdsName: "Ids de Bandas",
		missingBandActionName: "Ação de Banda em Falta",
		conversionParametersName: "Parâmetros e Conversão",
		hillshadeTypeName: "Tipo de Sombra",
		azimuthName: "Azimute",
		altitudeName: "Altitude:",
		slopeTypeName: "Dimensionar",
		zFactorName: "Fator Z",
		PSPowerName: "Potência Tamanho de Pixeis",
		PSZFactorName: "Fator Tamanho de Pixeis",
		removeEdgeEffectName: "Desativar interpolação edge pixel predefinida",
		fromUnitName: "A partir de Unidade",
		toUnitName: "Para Unidade",
		rasterTypeName: "Tipo",
		minName: "Mínimo de Saída",
		maxName: "Máximo de Saída",
		minPercentName: "Percentagem de Recorte Mínima",
		maxPercentName: "Percentagem de Recorte Máxima",
		numberOfStandardDeviationName: "Número de desvios padrão",
		sigmoidStrengthLevelName: "Nível de Força de Sigmóide",
		estimateStatsHistogramName: "Estimar Estatísticas",
		DRAName: "Ajustamento de Intervalo Dinâmico",
		statisticsName: "Estatísticas",
		histogramsName: "Histogramas",
		statisticsHistogramName: "Definir Estatísticas e Histograma",
		computeGammaName: "Gama Automática",
		useGammaName: "Utilizar Gama",
		gammaName: "Gama",
		inputNamesName: "Nomes",
		expressionName: "Expressão",
		cellsizeTypeName: "Tipo de Tamanho de Célula",
		extentTypeName: "Tipo de Extensão",
		classifierDefinitionFileName: "Ficheiro de Definição d Entrada",
		raster1Name: "Raster1",
		raster2Name: "Raster2",
		raster3Name: "Raster3",
		trueRasterName: "Raster Verdadeiro",
		falseRasterName: "Raster Falso",
		noDataInterpretationName: "Interpretação NoData",
		noDataValuesName: "Valores NoData",
		includedRangesName: "Intervalos Incluídos",
		curvatureTypeName: "Tipo de Curvatura",
		rastersName: "Rasters",
		attributeTableName: "Tabela",
		attributeTableTypeName: "Tipo de Tabela",
		rowsName: "Número de Linhas",
		columnsName: "Número de Colunas",
		kernelName: "Kernel",
		mirrorEdgesName: "Margens em Espelho",
		influencesName: "Influências",
		fieldsName: "Campos",
		remapsName: "Voltar a Cartografar Tabela",
		evalFromName: "Escala de Avaliação Desde",
		evalToName: "Escala de Avaliação Até",
		weightsName: "Pesos",
		DEMName: "DEM",
		shortRangeIDWRadiusName: "Rádio IDW de Curto Alcance",
		maxVoidWidthName: "Largura Máxima Void",
		sigmaGaussianName: "Suavização Adaptável",
		contourTypeName: "Tipo de Contorno",
		zBaseName: "Base Z",
		numberOfContoursName: "Número de contornos",
		contourIntervalName: "Intervalo de contornos",
		nthContourLineInBoldName: "Nth ContourLine A Negrito",
		featureClassName: "Elementos de Entrada:",
		classIndexFieldName: "Campo",
		resolveOverlapMethodName: "Resolver Método de Sobreposição",
		resamplingTypeName: "Tipo de Resampling",
		inputCellsizeName: "Tamanho de Células de Entrada",
		outputCellsizeName: "Tamanho de Células de Saída",
		pointFeatureClassName: "Pontos Seed",
		maxGrowthRadiusFieldName: "Campo de Raio de Crescimento Máximo",
		similarityThresholdFieldName: "Campo de Limiar de Semelhança",
		fillValueFieldName: "Campo Valor de Preenchimento",
		spectralDetailName: "Detalhe Espectral [1..20]",
		spatialDetailName: "Detalhe Espacial [1..20]",
		minNumPixelsPerSegmentName: "Tamanho de Segmento Mínimo em Pixeis",
		boundariesOnlyName: "Apenas limites de segmentos",
		statisticsTypeName: "Tipo de Estatística",
		fillNoDataOnlyName: "Preencher apenas píxeis NoData",
		inputDataTypeName: "Tipo de Dados de Entrada",
		angleReferenceSystemName: "Sistema de Referência de Ângulo",
		outputDataTypeName: "Tipo de Dados de Saída",
		inputSamplePointFeatureClassName: "Amostras de Entrada",
		valueFieldName: "Campo Valor",
		rasterInfoName: "Info. de Raster",
		interpolationMethodName: "Método de Interpolação",
		radiusName: "Raio",
		radianceGainValuesName: "Ganho de Luminosidade",
		radianceBiasValuesName: "Tendência de Luminosidade",
		reflectedGainValuesName: "Ganho de Refletância",
		reflectedBiasValuesName: "Tendência de Refletância",
		sunElevationName: "Elevação do Sol (graus)",
		albedoName: "Albedo",
		scaleFactorName: "Fator de Escala",
		offsetName: "Desvio",
		thresholdTypeName: "Tipo de Limiar",
		thresholdsName: "Limiares",
		undefinedClassName: "Classe Indefinida",
		minValueName: "Mín.",
		maxValueName: "Máx.",
		operationName: "Operação",
		clippingTypeName: "Tipo de Recorte",
		clippingGeometryName: "Recortar Geometria / Raster",
		extentName: "Extensão de Saída",
		useInputFeatureGeometryName: "Utilizar elementos de entrada para recortar geometria",
		remapDefinitionTypeName: "Tipo de Definição Voltar a Cartografar",
		inputRangeName: "Intervalos de Entrada",
		outputValuesName: "Valores de Saída",
		noDataRangeName: "Intervalos NoData",
		inputFieldName: "Introduzir Campo",
		outputFieldName: "Campo de Saída",
		inputMaxFieldName: "Campo Máx de Entrada (opcional)",
		remapTableTypeName: "Tipo de Tabela Voltar a Cartografar",
		allowUnmatchedName: "Permitir valores de pixéis sem correspondência",
		changeMissingValuesToNoDataName: "Alterar valores em falta para NoData",
		visibleBandIDName: "ID de Banda Visível",
		infraredBandIDName: "ID de Banda de Infravermelhos",
		scientificOutputName: "Saída Científica",
		bandIndexesName: "Índices de Bandas",
		constantName: "Constante",
		weightName: "Peso",
		minimumName: "Mínimo",
		maximumName: "Máximo",
		sourceDataName: "Raster de Origem",
		sourceFieldName: "Campo de Origem",
		costRasterName: "Raster de Custo",
		maxDistanceName: "Distância Máxima",
		valueRasterName: "Raster de Valor",
		costMultiplierName: "Multiplicador para aplicar a Custos",
		startCostName: "Custo Inicial",
		accumCostResistanceRateName: "Taxa de Resistência Custo Acumulativo",
		capacityName: "Capacidade",
		travelDirectionName: "Direção de Viagem",
		cellSizeName: "Cellsize",
		populationFieldName: "Campo População",
		areaUnitsName: "Unidades de Área",
		outputValueTypeName: "Valores de Células de Saída",
		barriersName: "Barreiras de Introdução",
		destinationDataName: "Raster de Destino",
		destinationFieldName: "Campo Destino",
		pathTypeName: "Tipo de Caminho",
		observerFeaturesName: "Elementos de Observadores",
		analysisMethodName: "Método de Análise",
		analysisTypeName: "Tipo de Análise",
		verticalErrorName: "Erro Vertical",
		refractivityCoefficientName: "Coeficiente de Refratividade",
		surfaceOffsetName: "Desvio de Superfície",
		observerElevationName: "Elevação de Observador",
		observerOffsetName: "Desvio de Observador",
		innerRadiusName: "Raio Interior",
		innerRadiusIs3DDistanceName: "O Raio Interior é uma Distância 3D",
		outerRadiusName: "Raior Exterior",
		outerRadiusIs3DDistanceName: "O Raio Exterior é uma Distância 3D",
		horizontalStartAngleName: "Ângulo de Início Horizontal",
		horizontalEndAngleName: "Ângulo de Fim Horizontal",
		verticalUpperAngleName: "Ângulo Superior Vertical",
		verticalLowerAngleName: "Ângulo Inferior Vertical",
		zoneDataName: "Raster de Zona",
		zoneFieldName: "Campo de Zona",
		ignoreNoDataName: "Ignorar NoData em cálculos",
		temperatureRasterName: "Raster de Temperatura",
		inTemperatureUnitsName: "Unidades de Temperatura",
		outHeatIndexTemperatureUnitsName: "Unidades de Índice de Aquecimento",
		relativeHumidityRasterName: "Raster de Humidade Relativa",
		outWindChillTemperatureUnitsName: "Unidades de Arrefecimento pelo Vento",
		windSpeedRasterName: "Raster de Velocidade do Vento",
		inWindSpeedUnitsName: "Unidades de Velocidade do Vento",
		valueName: "Valor",
		propertyName: "Nome de Propriedade",
		jsonName: "Metadados JSON",
		zoneTableName: "Tabela de Atributos Zonais",
		attributeFieldNames: "Nomes de Campo de Atributo",
		backgroundName: "Valor de Fundo",
		whereClauseName: "Cláusula Onde",
		minimumValueFieldName: "Nome de Campo de Valor Mínimo",
		maximumValueFieldName: "Nome de Campo de Valor Máximo",
		outValueFieldName: "Nome de Campo de Valor de Saída",
		defaultValueName: "Valor de Saída Padrão",
		conversionMatrixName: "Matriz de Conversão",
		IsPseudoColorOutputName: "É uma pseudo saída de cor",
		unmappedAsRandomColorName: "Atribuir aleatoriamente cor a píxeis não mapeados",
		distanceMethodName: "Método de distância",
		flowDirRasterName: "Raster de direção do fluxo",
		pourPointName: "Deitar Raster ponto(s)",
		pourPointFieldName: "Deixar campo ponto",
		constantZName: "Constante Z",
		zOffsetName: "Offset Z",
		geoIdName: "Geóide",
		calibrationTypeName: "Tipo de caibragem",
		filterTypeName: "Tipo de filtro",
		filterSizeName: "Tamanho do filtro",
		noiseModelName: "Modelo de ruído",
		noiseVarianceName: "Variação de ruído",
		additiveNoiseMeanName: "Média de ruído aditivo",
		multiplicativeNoiseMeanName: "Média de ruído multiplicativo",
		numberofLooksName: "Número de feições",
		dampingFactorName: "Fator de amortecimento",
		maskRasterName: "Raster máscara",
		nibbleValuesName: "Utilizar valores NoData se estes forem o vizinho mais próximo",
		nibbleNoDataName: "Células NoData vibração",
		zLimitName: "Limite Z",
		flowDirectionTypeName: "Tipo de direção do fluxo",
		weightRasterName: "Raster peso",
		forceEdgeName: "Forçar todas as células de bordas a fluir para fora",
		streamRasterName: "Raster de stream",
		surfaceRasterName: "Raster de superfície",
		conversionType: "Tipo de conversão",
		distanceRaster1: "Raster de distância 1",
		distanceRaster2: "Raster de distância 2",
		costDistanceRaster: "Raster de distância custo",
		costBacklinkRaster: "Raster de backlink custo",
		overridesName: "Substitui",
		fieldName: "Campo",
		signatureFileOrUrl: "Ficheiro de assinatura ou URL",
		redName: "Vermelho",
		greenName: "Verde",
		blueName: "Azul",
		infraredName: "Infravermelhos",
		panchromaticName: "Pancromático",
		multispectralName: "Multiespectral",
		pansharpeningType: "Tipo pansharpening",
		sensorName: "Sensor",
		spatialReferenceName: "Referência Espacial",
		xCellsizeName: "Tamanho da célula X",
		yCellsizeName: "Tamanho da célula Y",
		xOriginName: "Ponto de registo X",
		yOriginName: "Ponto de registo Y",
		percentileName: "Valor de Percentil",
		neighborhoodType: "Tipo vizinhança",
		widthName: "Largura",
		heightName: "Altura",
		startAngleName: "Ângulo de Início",
		endAngleName: "Ângulo de fim",
		neighborhoodValues: "Valores vizinhança",
		horizontalRaster: "Raster horizontal",
		horizontalFactor: "Fator horizontal",
		verticalRaster: "Raster vertical",
		verticalFactor: "Fator vertical",
		streamRaster: "Raster de stream",
		flowDirRaster: "Raster de direção do fluxo",
		numberNeighborCells: "Número de células vizinhas",
		zoneConnectivity: "Conectividade de zona",
		addLinkBehavior: "Adicionar Ligação",
		excludedValue: "Valor excluído",
		constantFillCheck: "Criar Raster enchimento a partir de constante",
		fillRaster: "Raster de enchimento",
		constantFillValue: "Valor Constante",
		inputBitPositions: "Bit entrada",
		outputBitPositions: "Bit saída",
		distanceTypeName: "Tipo de Distância",
		barrierDataName: "Barreiras de Raster",
		pourPointDataName: "Raster de Ponto de Escoamento",
		accumulationRasterName: "Raster de Acumulação do Fluxo",
		snapDistanceName: "Distância de Encaixe",
		orderMethodName: "Método de Ordenação",
		directionMeasurementName: "Direção da Medição",
		processAsMultiband: "Processar como Multibanda",
		processMultidimensional: "Processar como multidimensional",
		forceFlowDirectionConvention: "Forçar convenção de direção do fluxo para raster de backlink custo",
		initialAccumulation: "Acumulação Inicial",
		maximumAccumulation: "Acumulação Máxima",
		sourceLocationBands: "Gerar linha e coluna de origem como bandas adicionais na saída",
		backDirectionBand: "Gerar direção de retorno como banda adicional na saída",
		numberOfCells: "Número de Células",
		zoneValues: "Valores de Zona",
		shrinkMethod: "Reduzir Método",
		expandMethod: "Expandir Método",
		inputSpectralProfileType: "Tipo de Perfil Espetral",
		spectralProfileFileName: "Perfil Espetral",
		trainingFeatureFileName: "Elemento de Formação",
		nonNegative: "Não negativo",
		sumToOne: "Somar a Um",
		randomDistribution: "Distribuição",
		meanName: "Média",
		probabilityName: "Probabilidade",
		alphaName: "Alfa",
		betaName: "Beta",
		rName: "r",
		nName: "N",
		seed: "Seed",
		randomNumberGenerator: "Gerador de Número Aleatório",
		cellFactor: "Fator de Célula",
		aggregationType: "Técnica de agregação",
		extentHandling: "Expandir extensão se necessário",
		trendAnalysisDimensionName: "Nome da Dimensão",
		trendAnalysisType: "Tipo de Tendência",
		harmonicFrequency: "Frequência Harmónica",
		polynomialOrder: "Ordem Polinomial",
		cycleLengthName: "Duração do Ciclo",
		trendAnalysisRMSE: "RMSE",
		trendAnalysisR2: "R-quadrado",
		trendAnalysisSlopePValue: "Valor P do Coeficiente de Inclinação",
		trendAnalysisSeasonalPeriod: "Período Sazonal",
		cycleUnitName: "Unidade de Ciclo",
		predictDimensionValues: "Valores",
		dimensionDefinitionType: "Definição de Dimensão",
		predictDimensionStart: "Iniciar",
		predictDimensionEnd: "Final",
		predictDimensionInterval: "Intervalo de valor",
		dimensionUnit: "Unidade",
		interpolationCellsizeName: "Tamanho de Célula de Interpolação",
		variableName: "Variáveis",
		dimensionlessName: "Sem Dimensão",
		mdimDefinition: "Definição de Dimensão",
		dimensionName: "Dimensão",
		iterationStart: "Início da primeira iteração",
		iterationEnd: "Fim da primeira iteração",
		intervalStart: "Início do Intervalo",
		intervalEnd: "Fim do Intervalo",
		stepName: "Passo",
		rangesName: "Faixas",
		minValue: "Valor Mínimo",
		maxValue: "Valor Máximo",
		changeAnalysisRasterName: "Raster de Análise de Alterações",
		changeTypeName: "Alterar Tipo",
		segmentDate: "Data do Segmento",
		changeDirectionName: "Alterar Direção",
		maxNumChangesName: "Número Máximo de Alterações",
		filterByYear: "Filtrar por Ano",
		minimumYear: "Valor Mínimo",
		maximumYear: "Valor Máximo",
		filterByDuration: "Filtrar por Duração",
		minimumDuration: "Duração Mínima",
		maximumDuration: "Duração Máxima",
		filterByMagnitude: "Filtrar por Magnitude",
		minimumMagnitude: "Magnitude Mínima",
		maximumMagnitude: "Magnitude Máxima",
		filterByStartValue: "Filtrar Por Valor Inicial",
		minimumStartValue: "Valor Inicial Mínimo",
		maximumStartValue: "Valor Inicial Máximo",
		filterByEndValue: "Filtrar Por Valor Final",
		minimumEndValue: "Valor Final Mínimo",
		maximumEndValue: "Valor Final Máximo",
		modelTypeName: "Tipo de Modelo",
		fromRasterName: "Do Raster",
		toRasterName: "Para o Raster",
		computeChangeMethod: "Método de Calcular Alteração",
		fromClassValues: "De Valores de Classe (Exemplo: 2 5)",
		toClassValues: "Para Valores de Classe (Exemplo: 2 5)",
		keepMethod: "Filtrar Método",
		useColorMethod: "Definir Cores de Transição",
		detectChangeBands: "Bandas para Deteção de Alterações (começa no 0)",
		tmaskBands: "Bandas para Máscara Temporal (começa no 0)",
		chiSquaredThreshold: "Limiar de Chi-quadrado para Detetar Alterações",
		minAnomaly: "Observações de Anomalias Mínimas Consecutivas",
		updatingFrequency: "Atualização da Frequência de Ajuste (em anos)",
		distanceAccumulationRasterName: "Raster de Acumulação de Distância",
		costBackdirectionRasterName: "Raster de Direção de Retorno ou de Direção do Fluxo",
		rasterCollectionName: "Coleção de Raster",
		itemFunctionName: "Função do Item",
		aggregationFunctionName: "Função de Agregação",
		processingFunctionName: "Função de Processamento",
		aggregationDefinitionName: "Definição de Agregação",
		queryGeometryName: "Consultar geometria",
		factorFunctionZeroFactor: "Fator Zero",
		factorFunctionCutAngle: "Ângulo de Corte",
		factorFunctionSideFactor: "Fator Lateral",
		factorFunctionSlope: "Inclinação",
		factorFunctionLowCutAngle: "Ângulo de Corte Baixo",
		factorFunctionHighCutAngle: "Ângulo de Corte Alto",
		factorFunctionCosPower: "Potência do Cosseno",
		factorFunctionSecPower: "Potência da Secante",
		factorFunctionTablePath: "Caminho da Tabela",
		processingBand: "Banda de Processamento",
		processingBandName: "Nome da Banda de Processamento",
		snappingDate: "Ajustar Data",
		maxNumSegments: "Número Máximo de Segmentos",
		vertexCountOvershoot: "Overshoot de Contagem de Vértices",
		spikeThreshold: "Limiar de Spike",
		recoveryThreshold: "Limiar de Recuperação",
		minNumObs: "Número Mínimo de Observações",
		pValueThreshold: "Limiar de Valor P",
		bestModelProportion: "Melhor Proporção de Modelo",
		preventOneYearRecovery: "Prevenir Recuperação de Um Ano",
		recoveryIncreaseTrend: "Recuperação com Tendência Crescente",
		outputOtherBands: "Saída de Outras Bandas",
		sortType: "Tipo de Ordenação",
		numberOfRuns: "Executar expansão e redução duas vezes",
		percentileValue: "Valor de Percentil",
		percentileInterpolationType: "Tipo de interpolação de percentil",
		rasterInfoProperty: "Propriedade",
		rasterInfoValue: "Valor",
		rasterInfoColumns: "Colunas",
		rasterInfoRows: "Linhas",
		rasterInfoBandCount: "Número de Bandas",
		rasterInfoPixelSizeX: "Tamanho da Célula X",
		rasterInfoPixelSizeY: "Tamanho da Célula Y",
		rasterInfoPixelType: "Tipo de Píxel",
		rasterExtentTop: "Superior",
		rasterExtentBottom: "Inferior",
		rasterExtentLeft: "Esquerda",
		rasterExtentRight: "Direita",
		rasterStatisticsNotCalculated: "As estatísticas não foram calculadas.",
		spatialReferenceProjection: "Projeção",
		spatialReferenceWkid: "WKID",
		spatialReferenceLatestWkid: "WKID anterior",
		spatialReferenceWkt: "WKT",
		spatialReferenceVcsWkid: "VCSWKID",
		spatialReferenceLatestVcsWkid: "VCSWKID anterior",
		spatialReferenceAuthority: "Autoridade",
		spatialReferenceLinearUnit: "Unidade Linear",
		spatialReferenceAngularUnit: "Unidade Angular",
		spatialReferenceFalseEasting: "Falso Avanço para Este",
		spatialReferenceFalseNorthing: "Falso Avanço para Norte",
		spatialReferenceCentralMeridian: "Meridiano Central",
		spatialReferencePrimeMeridian: "Meridiano Principal",
		spatialReferenceStandardParallel1: "Paralela Standard 1",
		spatialReferenceStandardParallel2: "Paralela Standard 2",
		spatialReferenceLatitudeOfOrigin: "Latitude da Origem",
		spatialReferenceAuxiliarySphereType: "Tipo de Esfera Auxiliar",
		spatialReferenceDatum: "Datum",
		spatialReferenceSpheroid: "Esferoide",
		spatialReferenceSemimajorAxis: "Eixo Semi-Maior",
		spatialReferenceSemiminorAxis: "Eixo Semi-Menor",
		spatialReferenceInverseFlattening: "Achatamento Inverso",
		inputDefinitionFileName: "Ficheiro de Definição de Entrada",
		deleteName: "Eliminar",
		addVariableName: "Adicionar variável",
		maxNumPixelsPerSegment: "Tamanho de Segmento Máximo em Píxeis",
		forwardWindowName: "Janela Posterior",
		backwardWindowName: "Janela Anterior",
		noDataHandlingName: "Gestão de NoData",
		circularWrapValueName: "Valor de Moldagem Circular",
		fromClassNameFieldName: "Nome do Campo Para Nomes de Classes De Raster",
		toClassNameFieldName: "Nome do Campo Para Nomes de Classes Para o Raster",
		targetRasterName: "Raster de Destino",
		circularWrapValue: "Valor de Moldagem Circular",
		bandIndexesR: "Expressão Vermelha",
		bandIndexesG: "Expressão Verde",
		bandIndexesB: "Expressão Azul",
		exampleName: "Exemplo",
		inputName: "Introdução",
		outputName: "Saída",
		optionalName: "Opcional",
		browseDefinitionFile: "Procurar Ficheiro de Definição",
		selectDefinitionFile: "Selecionar Ficheiro de Definição de Entrada",
		inputDefinitionURL: "URL de Ficheiro de Definição de Entrada",
		enterDefinitionFileURL: "Introduzir URL de Ficheiro de Definição",
		browseXMLFile: "Procurar Ficheiro XML",
		selectStatsFile: "Selecionar Ficheiro de Estatísticas e Histogramas",
		enterXMLFileURL: "Introduzir URL de Ficheiro XML",
		xmlFileURL: "URL de Ficheiro XML",
		circularCalculation: "Calcular Estatísticas Circulares",
		localSurfaceType: "Tipo de Superfície Local",
		surfaceParameterType: "Tipo de Parâmetro",
		neighborhoodDistance: "Distância de Vizinhança",
		useAdaptiveNeighborhood: "Usar Vizinhança Adaptativa",
		outputSlopeType: "Medição de Declive de Saída",
		projectAzimuths: "Azimutes Geodésicos do Projeto",
		useEquatorialAspect: "Usar Aspeto Equatorial",
		zUnit: "Unidade Z",
		analysisMask: "Máscara de Análise",
		stdDeviation: "Desvio Padrão",
		"true": "Verdadeiro",
		"false": "Falso",
		costDistanceRaster1: "Raster de Distância de Custo Acumulativo de Entrada 1",
		costDistanceRaster2: "Raster de Distância de Custo Acumulativo de Entrada 2",
		threshold: "Limiar",
		thresholdMethod: "Método de Limiar",
		directionRaster1: "Raster de Direção de Retorno de Entrada 1",
		directionRaster2: "Raster de Direção de Retorno de Entrada 2",
		maxIterations: "Número Máximo de Iterações",
		epsilon: "Epsilon"
	},
	enumLabels: {
		attributeTableTypeManual: "Manual",
		attributeTableTypeExternal: "Externo",
		clrSchemeTypeColormap: "Mapa de Cores",
		clrSchemeTypeColorRamp: "Rampa de Cores",
		colormapTypeElevation: "Elevação",
		colormapTypeGray: "Cinza",
		colormapTypeNDVI: "NDVI",
		colormapTypeNDVI2: "NDVI2",
		colormapTypeNDVI3: "NDVI3",
		colormapTypeRandom: "Aleatório",
		none: "Nenhum",
		slopeTypeAdjusted: "Ajustado",
		slopeTypeDegree: "Grau",
		slopeTypePercentRise: "PercentRise",
		slopeTypeScaled: "Dimensionado",
		stretchTypeMinMax: "MinMax",
		stretchTypePercentMinMax: "PercentMinMax",
		stretchTypeSigmoid: "Sigmóide",
		stretchTypeStdDev: "StdDev",
		hillshadeTypeSimple: "Tradicional",
		hillshadeTypeMultidirectional: "Multidirecional",
		bandComboByNames: "Nomes de Bandas",
		bandComboByWavelength: "Comprimentos de Onda de Bandas",
		bandComboByIDs: "Ids de Bandas",
		missingBandActionBestMatch: "Melhor Correspondência",
		missingBandActionFail: "Falha",
		unitTypeCelsius: "Celsius",
		unitTypeCentimeters: "Centímetros",
		unitTypeDecimeters: "Decímetros",
		unitTypeFahrenheit: "Fahrenheit",
		unitTypeFeet: "Pés",
		unitTypeFeetPerSec: "Pés Por Segundo (pés/s)",
		unitTypeInches: "Polegadas",
		unitTypeKelvin: "Kelvin",
		unitTypeKilometers: "Quilómetros",
		unitTypeKmsPerHour: "Quilómetros Por Hora (km/h)",
		unitTypeKnots: "Nós (kn)",
		unitTypeMeters: "Metros",
		unitTypeMetersPerSec: "Metros Por Segundo (m/s)",
		unitTypeMiles: "Milhas",
		unitTypeMilesPerHour: "Milhas Por Hora (mph)",
		unitTypeMillimeters: "Milímetros",
		unitTypeNauticalMiles: "Milhas Náuticas",
		unitTypeYards: "Jardas",
		unitTypeDecimalDegrees: "Graus decimais",
		unitTypePoints: "Pontos",
		unitTypeUnknown: "Desconhecido",
		unitTypeSqMapUnits: "Unidades Quadradas de Mapa",
		unitTypeSqMiles: "Milhas Quadradas",
		unitTypeSqKms: "Quilómetros Quadrados",
		unitTypeAcres: "Acres",
		unitTypeHectares: "Hectares",
		unitTypeSqYards: "Jardas Quadradas",
		unitTypeSqFt: "Pés Quadrados",
		unitTypeSqInches: "Polegadas Quadradas",
		unitTypeSqMts: "Metros Quadrados",
		unitTypeSqCms: "Centimetros Quadrados",
		unitTypeSqMms: "Milimetros Quadrados",
		cellsizeTypeFirst: "Primeiro De",
		cellsizeTypeMin: "Mín. De",
		cellsizeTypeMax: "Máx. De",
		cellsizeTypeMean: "Média De",
		cellsizeTypeLast: "Último De",
		extentTypeFirst: "Primeiro De",
		extentTypeIntersection: "Intersecção De",
		extentTypeUnion: "União De",
		extentTypeLast: "Último De",
		noDataInterpretAny: "Corresponder Qualquer",
		noDataInterpretAll: "Corresponder Todos",
		curvatureTypeStandard: "Standard",
		curvatureTypeProfile: "Perfil",
		curvatureTypePlanform: "Asa",
		filterTypeLineDetectionHorizontal: "Deteção de Linha Horizontal",
		filterTypeLineDetectionVertical: "Deteção de Linha Vertical",
		filterTypeLineDetectionLeftDiagonal: "Deteção de Linha Diagonal Esquerda",
		filterTypeLineDetectionRightDiagonal: "Deteção de Linha Diagonal Direita",
		filterTypeGradientNorth: "Gradiente Norte",
		filterTypeGradientWest: "Gradiente Oeste",
		filterTypeGradientEast: "Gradiente Este",
		filterTypeGradientSouth: "Gradiente Sul",
		filterTypeGradientNorthEast: "Gradiente Nordeste",
		filterTypeGradientNorthWest: "Gradiente Noroeste",
		filterTypeSmoothArithmeticMean: "Média Aritmética Uniforme",
		filterTypeSmoothing3x3: "A uniformizar 3x3",
		filterTypeSmoothing5x5: "A uniformizar 5x5",
		filterTypeSharpening3x3: "A aperfeiçoar 3x3",
		filterTypeSharpening5x5: "A aperfeiçoar 5x5",
		filterTypeLaplacian3x3: "Laplaciano 3x3",
		filterTypeLaplacian5x5: "Laplaciano 5x5",
		filterTypeSobelHorizontal: "Sobel Horizontal",
		filterTypeSobelVertical: "Sobel Vertical",
		filterTypeSharpen: "Aperfeiçoar",
		filterTypeSharpen2: "Acentuar mais",
		filterTypePointSpread: "Dispersão de Pontos",
		userDefined: "Definido por Utilizador",
		ContourTypeLines: "Linhas de Contorno",
		ContourTypeFill: "Preenchimento de Contorno",
		ContourTypeSmoothOnly: "Apenas Superfície Suave",
		rasterizeFirst: "Primeiro",
		rasterizeLast: "Último",
		rasterizeSmallest: "Menor",
		rasterizeLargest: "Maior",
		resamplingTypeNearest: "Vizinho mais próximo",
		resamplingTypeBilinear: "Interpolação Bilinear",
		resamplingTypeCubic: "Convolução Cúbica",
		resamplingTypeMajority: "Maioria",
		resamplingTypeBilinearPlus: "Interpolação Bilinear Plus",
		resamplingTypeGauss: "Gauss Blur",
		resamplingTypeGaussPlus: "Gauss Blur Plus",
		resamplingTypeAverage: "Média",
		resamplingTypeMinimum: "Mínimo",
		resamplingTypeMaximum: "Máximo",
		resamplingTypeVectorAvg: "Média de Vetores",
		minimum: "Mínimo",
		maximum: "Máximo",
		mean: "Média",
		stdDeviation: "Desvio Padrão",
		uvMagDirTypeUV: "U-V",
		uvMagDirTypeMagDir: "Magnitude-Direção",
		unknown: "Desconhecido",
		angleRefSysGeographic: "Geográficos",
		angleRefSysArithmetic: "Aritméticos",
		interpolateIrregularDataNearest: "Vizinho mais próximo",
		interpolateIrregularDataBilinear: "Bilinear",
		interpolateIrregularDataTinningLinear: "Estanhagem linear",
		interpolateIrregularDataTinningNaturalNeighbor: "Vizinho natural",
		interpolateIrregularDataTinningIDW: "Distância inversa pesada",
		esriRasterThresholdTypeConstant: "Constante",
		esriRasterThresholdTypeOtsu: "Otsu",
		esriRasterThresholdTypeTsai: "Tsai",
		esriRasterThresholdTypeKapur: "Kapur",
		esriRasterThresholdTypeKittler: "Kittler",
		esriRasterThresholdTypeRosin: "Rosin",
		argStatsTypeMax: "Máx. Arg",
		argStatsTypeMin: "Mín Arg",
		argStatsTypeMedian: "Mediana Arg",
		argStatsTypeDuration: "Duração",
		arithmeticOpPlus: "Mais",
		arithmeticOpMinus: "Menos",
		arithmeticOpMultiply: "Multiplicar",
		arithmeticOpDivide: "Dividir",
		arithmeticOpPower: "Potência",
		arithmeticOpMode: "Modo",
		clipTypeOutside: "Recortar Fora",
		clipTypeInside: "Recortar Dentro",
		yes: "Sim",
		no: "Não",
		densities: "Densidades",
		expectedCounts: "Contagens Expectáveis",
		planar: "planar",
		geodesic: "Geodésica",
		eachCell: "Cada Célula",
		eachZone: "Cada Zona",
		bestSingle: "Melhor Único",
		allSightlines: "Todas as Linhas de Visão",
		perimeterSightlines: "Linhas de visão do Perímetro",
		frequency: "Frequência",
		observers: "Observadores",
		majority: "Maioria",
		median: "Mediana",
		minority: "Minoria",
		percentile: "Percentil",
		range: "Intervalo",
		sum: "Soma",
		variety: "Variedade",
		ndvi: "NDVI",
		savi: "SAVI",
		bandArithmeticMethodTSAVI: "SAVI Transformado",
		bandArithmeticMethodMSAVI: "SAVI Modificado",
		bandArithmeticMethodSultan: "Fórmula de Sultan",
		gemi: "GEMI",
		pvi: "PVI",
		gvi: "GVI (Landsat TM)",
		vari: "VARI",
		sr: "SR",
		gndvi: "GNDVI",
		ndvire: "NDVIre",
		srre: "SRre",
		mtvi2: "MTVI2",
		rtviCore: "RTVICore",
		cire: "CIre",
		cig: "CIg",
		ndwi: "NDWI",
		evi: "EVI",
		ironOxide: "Óxido de Ferro",
		ferrousMinerals: "Minerais Ferrosos",
		clayMinerals: "Minerais de Argila",
		wndwi: "WNDWI",
		bai: "BAI",
		mndwi: "MNDWI",
		nbr: "NBR",
		ndbi: "NDBI",
		ndmi: "NDMI",
		ndsi: "NDSI",
		localSquareRoot: "Raiz Quadrada",
		localACos: "ACos",
		localASin: "ASin",
		localATan: "ATan",
		localATanH: "ATanH",
		localAbs: "Abs",
		localBitwiseNot: "Bitwise Não",
		localBooleanNot: "Booleano Não",
		localCos: "Cos",
		localCosH: "CosH",
		localExp: "Exp",
		localExp10: "Exp10",
		localExp2: "Exp2",
		localInt: "Int",
		localIsNull: "É Nulo",
		localFloat: "Flutuar",
		localLn: "Ln",
		localLog10: "Log10",
		localLog2: "Log2",
		localNegate: "Negar",
		localRoundDown: "Arredondar para Baixo",
		localRoundUp: "Arredondar para Cima",
		localSin: "Sin",
		localSinH: "SinH",
		localTan: "Tan",
		localTanH: "TanH",
		localACosH: "ACosH",
		localASinH: "ASinH",
		localPlus: "Mais",
		localMinus: "Menos",
		localTimes: "Tempos",
		localPower: "Potência",
		localBitwiseAnd: "Bitwise E",
		localBitwiseLeftShift: "Bitwise Esquerda Shift",
		localBitwiseOr: "Bitwise Ou",
		localBitwiseRightShift: "Bitwise Direita Shift",
		localBitwiseXor: "Bitwise Xor",
		localBooleanAnd: "Booleano E",
		localBooleanOr: "Booleano Ou",
		localBooleanXor: "Booleano Xor",
		localDivide: "Dividir",
		localEqualTo: "Igual A:",
		localGreaterThan: "Maior do Que",
		localGreaterThanEqual: "Maior Igual",
		localLessThan: "Menor do que",
		localLessThanEqual: "Menor Igual",
		localMod: "Mod",
		localNotEqual: "Não Igual",
		localATan2: "ATan2",
		localSquare: "Quadrado",
		localSetNull: "Definir Nulo",
		remapDefTypeList: "Lista",
		remapDefTypeTable: "Tabela",
		remapTableTypeSimple: "Simples",
		remapTableTypeDynamic: "Dinâmico",
		remapTableTypeReassignment: "Reatribuição",
		geomCorrectionByConstZ: "Utilizar constante Z",
		geomCorrectionByDEM: "Utilizar DEM",
		radarCalibBetaNought: "Beta-zero",
		radarCalibSigmaNought: "Sigma-zero",
		radarCalibGammaNought: "Gama-zero",
		speckleFilterTypeLee: "Filtro Lee",
		speckleFilterTypeEnhancedLee: "Filtro Lee melhorado",
		speckleFilterTypeFrost: "Filtro Frost",
		speckleFilterTypeKuan: "Filtro Kuan",
		speckleNoiseModelMul: "Ruído multiplicativo",
		speckleNoiseModelAdd: "Ruído aditivo",
		speckleNoiseModelAddnMul: "Ruído aditivo e multiplicativo",
		mosaicOpTypeFirst: "Primeiro",
		mosaicOpTypeLast: "Último",
		mosaicOpTypeMin: "Mín.",
		mosaicOpTypeMax: "Máx.",
		mosaicOpTypeMean: "Média",
		mosaicOpTypeBlend: "Blend",
		mosaicOpTypeSum: "Soma",
		integer: "Inteiro",
		rfxD8: "D8",
		rfxMFD: "MFD",
		dinf: "Dinf",
		vertical: "Vertical",
		horizontal: "Horizontal",
		localCellStatisticsMajority: "Maioria",
		localCellStatisticsMax: "Máximo",
		localCellStatisticsMean: "Média",
		localCellStatisticsMedian: "Mediana",
		localCellStatisticsMin: "Mínimo",
		localCellStatisticsMinority: "Minoria",
		localCellStatisticsRange: "Intervalo",
		localCellStatisticsStdDev: "Desvio Padrão",
		localCellStatisticsSum: "Soma",
		localCellStatisticsVariety: "Variedade",
		localCellStatisticsMajorityIgnoreND: "Maioria (Ignorar NoData)",
		localCellStatisticsMaxIgnoreND: "Máximo (Ignorar NoData)",
		localCellStatisticsMeanIgnoreND: "Média (Ignorar NoData)",
		localCellStatisticsMedianIgnoreND: "Mediana (Ignorar NoData)",
		localCellStatisticsMinIgnoreND: "Mínimo (Ignorar NoData)",
		localCellStatisticsMinorityIgnoreND: "Minoria (Ignorar NoData)",
		localCellStatisticsRangeIgnoreND: "Intervalo (Ignorar NoData)",
		localCellStatisticsStdDevIgnoreND: "Desvio padrão (Ignorar NoData)",
		localCellStatisticsSumIgnoreND: "Soma (Ignorar NoData)",
		localCellStatisticsVarietyIgnoreND: "Variedade (Ignorar NoData)",
		localCellStatisticsTypePercentileIgnoreND: "Percentil (Ignorar NoData)",
		fromSource: "De fonte",
		toSource: "Para fonte",
		colorspaceConversionRgbToHsv: "RGB para HSV",
		colorspaceConversionHsvToRgb: "HSV para RGB",
		pansharpenTypeIHS: "IHS",
		pansharpenTypeBrovey: "Brovey",
		pansharpenTypeEsri: "Esri",
		pansharpenTypeMean: "Média",
		pansharpenTypeGramSchmidt: "Gram-Schmidt",
		rectangleNeighborhood: "Retângulo",
		circleNeighborhood: "Círculo",
		annulusNeighborhood: "Anel",
		wedgeNeighborhood: "Calço",
		irregularNeighborhood: "Irregular",
		weightNeighborhood: "Peso",
		four: "Quatro",
		eight: "Oito",
		within: "Incluído",
		cross: "Cruz",
		addLink: "Adicionar Ligação",
		noLink: "Sem ligação",
		weightedMean: "Média Ponderada",
		ls8QCBitPatternCirrus: "Landsat 8: Cirro",
		ls8QCBitPatternCloud: "Landsat 8: Nuvem",
		ls8QCBitPatternCloudShadow: "Landsat 8: Sombra de Nuvem",
		ls8QCBitPatternDesignatedFill: "Landsat 8: Preenchimento Designado",
		ls8QCBitPatternDroppedFrame: "Landsat 8: Perda de Frame",
		ls8QCBitPatternSnowIce: "Landsat 8: Neve/Gelo",
		ls8QCBitPatternTerrainOcclusion: "Landsat 8: Oclusão do Terreno",
		ls8QCBitPatternVegetation: "Landsat 8: Vegetação",
		ls8QCBitPatternWater: "Landsat 8: Água",
		downStream: "A jusante",
		upStream: "A montante",
		strahler: "STRAHLER",
		shreve: "SHREVE",
		currentSlice: "Secção Atual",
		allSlices: "Todas as Secções",
		expandDistance: "DISTÂNCIA",
		expandMorphological: "MORFOLÓGICO",
		spectralProfileFile: "Perfil Espetral",
		trainingFeatureFile: "Elemento de Formação",
		randomDistributionTypeUniform: "Uniforme",
		randomDistributionTypeUniformInteger: "Inteiro",
		randomDistributionTypeNormal: "Normal",
		randomDistributionTypeExponential: "Exponencial",
		randomDistributionTypePoisson: "Poisson",
		randomDistributionTypeGamma: "Gama",
		randomDistributionTypeBinomial: "Binomial",
		randomDistributionTypeGeometric: "Geométrica",
		randomDistributionTypeNegativeBinomial: "Binomial Negativo",
		randomGeneratorTypeStandardCRand: "Standard C Rand",
		randomGeneratorTypeAlgorithmACM599: "ACM collected algorithm 599",
		randomGeneratorTypeMersenneTwister: "Mersenne Twister",
		sumName: "Soma",
		medainName: "Mediana",
		trendLinear: "Linear",
		trendHarmonic: "Harmónica",
		trendPolynomial: "Polinomial",
		trendMannKendall: "Mann-Kendall",
		trendSeasonalKendall: "Kendall Sazonal",
		dimensionByValue: "Por Valor",
		dimensionByInterval: "Por Intervalo",
		mdimDefTypeAll: "Todos",
		mdimDefTypeByValues: "Por Valores",
		mdimDefTypeByRanges: "Por Intervalos",
		mdimDefTypeByIteration: "Por Iteração",
		mdimDefTypeByInterval: "Por Intervalo",
		mdimDefTypeByTargetRaster: "Por Raster de Destino",
		esriTimeUnitsHours: "Horas",
		esriTimeUnitsDays: "Dias",
		esriTimeUnitsWeeks: "Semanas",
		esriTimeUnitsMonths: "Meses",
		esriTimeUnitsYears: "Anos",
		esriTimeIntervalKeywordHourly: "A cada hora",
		esriTimeIntervalKeywordDaily: "Diariamente",
		esriTimeIntervalKeywordWeekly: "Semanalmente",
		esriTimeIntervalKeywordDekadly: "A cada 10 anos",
		esriTimeIntervalKeywordPentadly: "A cada 5 anos",
		esriTimeIntervalKeywordMonthly: "Mensalmente",
		esriTimeIntervalKeywordQuarterly: "Trimestral",
		esriTimeIntervalKeywordYearly: "Anualmente",
		esriTimeIntervalKeywordRecurringDaily: "Recorrente diariamente",
		esriTimeIntervalKeywordRecurringWeekly: "Recorrente semanalmente",
		esriTimeIntervalKeywordRecurringMonthly: "Recorrente mensalmente",
		esriTimeIntervalKeywordRecurringQuarterly: "Recorrente trimestralmente",
		aggDefTypeAll: "Tudo",
		aggDefTypeIntervalKeyword: "Palavra-chave de Intervalo",
		aggDefTypeIntervalValue: "Valor de Intervalo",
		aggDefTypeIntervalRanges: "Intervalos",
		latestChange: "Hora da Última Alteração",
		earliestChange: "Hora da Primeira Alteração",
		largestChange: "Hora da Maior Alteração",
		numberOfChanges: "Número de Alterações",
		longestChange: "Hora da Maior Alteração",
		shortestChange: "Hora da Menor Alteração",
		fastestChange: "Hora da Alteração Mais Rápida",
		slowestChange: "Hora da Alteração Mais Lenta",
		allChanges: "Tudo",
		increaseChanges: "Aumentar",
		decreaseChanges: "Reduzir",
		segmentBeginning: "Início do segmento",
		segmentEnd: "Fim do segmento",
		esriComputeChangeMethodDifference: "Diferença",
		esriComputeChangeMethodRelativeDifference: "Diferença Relativa",
		esriComputeChangeMethodCategorical: "Diferença Categórica",
		esriComputeChangeMethodMultispectralEuclideanDistance: "Distância Euclidiana Espectral",
		esriComputeChangeMethodMultispectralAngularDifference: "Diferença Angular Espectral",
		esriComputeChangeMethodMultispectralAxisWithBiggestChange: "Banda Com Mais Alterações",
		esriComputeChangeKeepAll: "Manter Tudo",
		esriComputeChangeKeepChangedOnly: "Manter Apenas Píxeis Alterados",
		esriComputeChangeKeepUnchangedOnly: "Manter Apenas Píxeis Inalterados",
		esriComputeChangeUseColorAverage: "De e Para Cores Médias",
		esriComputeChangeUseColorFrom: "Usar De Cores",
		esriComputeChangeUseColorTo: "Utilizar Para Cores",
		factorFunctionBinary: "Binário",
		factorFunctionForward: "Para a frente",
		factorFunctionLinear: "Linear",
		factorFunctionInvLinear: "Linear Inverso",
		factorFunctionTable: "Tabela",
		factorFunctionSymLinear: "Linear Simétrico",
		factorFunctionSymInvLinear: "Linear Simétrico Inverso",
		factorFunctionCos: "Cosseno",
		factorFunctionSec: "Secante",
		factorFunctionCosSec: "Cosseno Secante",
		factorFunctionSecCos: "Secante Cosseno",
		noSort: "Não Ordenar",
		ascend: "Crescente",
		descend: "Decrescente",
		autoDetect: "Detetar automaticamente",
		nearest: "Mais Próximo",
		linear: "Linear",
		esriMonthJanuary: "janeiro",
		esriMonthFebruary: "fevereiro",
		esriMonthMarch: "março",
		esriMonthApril: "abril",
		esriMonthMay: "maio",
		esriMonthJune: "junho",
		esriMonthJuly: "julho",
		esriMonthAugust: "agosto",
		esriMonthSeptember: "setembro",
		esriMonthOctober: "outubro",
		esriMonthNovember: "novembro",
		esriMonthDecember: "dezembro",
		dimensionalMovingIgnoreNoData: "Dados",
		dimensionalMovingPropagateNoData: "NoData",
		dimensionalMovingFillOnlyNoData: "Preencher NoData",
		circularMean: "Média Circular",
		circularName: "Circular",
		arithmeticName: "Aritméticos",
		slopeName: "Declive",
		aspectName: "Aspeto",
		meanCurvature: "Curvatura média",
		profileCurvature: "Curvatura do perfil (linha de declive normal)",
		tangentialCurvature: "Curvatura tangencial (contorno normal)",
		planCurvature: "Curvatura do plano (contorno projetado)",
		contourGeodesicTorsion: "Torção geodésica de contorno",
		gaussianCurvature: "Curvatura gaussiana",
		casoratiCurvature: "Curvas de Casorati",
		localSurfaceTypeQuadratic: "Quadrática",
		localSurfaceTypeBiquadratic: "Biquadrática",
		thresholdNoThreshold: "Sem Limiar",
		thresholdPercentLeastCost: "Percentagem de Menor Custo",
		thresholdAccumulativeCost: "Custo Acumulativo",
		clrmapTypeHillshade: "Sombreado"
	},
	categoryLabels: {
		sourceCharacteristics: "Características da Fonte",
		neighborhoodSettings: "Definições de Vizinhança",
		statistics: "Estatísticas",
		gamma: "Gama",
		viewshedParameters: "Parâmetros de Área Visível",
		observerParameters: "Parâmetros de Observador",
		irregularDataInterpolation: "Interpolação de Dados Irregular",
		modelStatistics: "Estatísticas do Modelo",
		aggregationDef: "Definição de Agregação",
		filterByAttributes: "Filtrar Por Atributos",
		percentileName: "Percentil",
		rasterInfo: "Informações do Raster",
		extent: "Estender",
		spatialReference: "Referência Espacial"
	},
	outputRasterHelpTexts: {
		outputName: "<p>O nome da camada que será criada e adicionada ao mapa.</p>",
		resultType: "<p>O tipo de saída que será criado. As saídas podem ser camadas de imagens em mosaico ou camadas de imagens dinâmicas.</p>",
		saveResultIn: "<p>O nome da pasta em <b>O Meu Conteúdo</b> onde o resultado será guardado.</p>"
	},
	analysisEnvironmentsHelpTexts: {
		description: "<p>Definições de ambiente para análise no Map Viewer. </p>",
		outSR: "<p>Especifica o sistema de coordenadas para análise e a camada de resultados.</p>",
		extent: "<p>Especifica a área a ser utilizada para análise.</p>",
		snapRaster: "<p>Ajusta a extensão da saída para que corresponda ao alinhamento da célula da camada raster de ajuste especificada.</p>",
		cellSize: "<p>Especifica o tamanho da célula ou resolução que será utilizado para análise e criar a camada de raster de saída.</p>",
		mask: "<p>Especifica uma camada de máscara na qual apenas as células que se enquadrarem na área de máscara serão utilizadas para análise.</p>",
		resamplingMethod: "<p>Especifica como interpolar valores de píxeis quando os rasters de entrada e saída não se alinham.</p>"
	},
	mainGenStrings: {
		unsupportedDataType: "Tipo não suportado",
		currentlyUnsupported: " Um editor predefinido para o tipo ${missingType} está pendente, mas está para breve. Caixa de texto temporária de espaço reservado para especificar entradas baseadas em cadeias de caracteres.",
		unsupportedOverrideWarning: "Está pendente, mas para breve, um componente do editor de substituições que proporciona uma melhor experiência de utilizador para trabalhar com os seguintes parâmetros:",
		overrideWidgetMissing: "Componente do editor de substituições em falta!",
		uiIncomplete: "O envio da tarefa falhou. A função não pode ser executada porque alguns dos campos obrigatórios estão incompletos ou em falta na IU.",
		count: "Contagem",
		selectVariables: "Selecionar variáveis",
		selectFeature: "Selecione uma camada de elementos",
		greaterThanErrorMessage: "O número de entrada tem de ser maior que ${min}",
		lesserThanErrorMessage: "O número de entrada tem de ser menor que ${max}",
		greaterThanOrEqualErrorMessage: "O número de entrada tem de ser maior ou igual a ${min}",
		lesserThanOrEqualErrorMessage: "O número de entrada tem de ser menor ou igual a ${max}",
		allowScalar: "Selecione uma camada ou introduza uma constante",
		selectField: "Selecionar campo",
		parameterRequired: "Este parâmetro é obrigatório.",
		enterAValue: "Introduza um valor...",
		invalidInput: "O valor introduzido não é válido.",
		itemNotFound: "O item não existe ou não está acessível.",
		itemPermissionDenied: "Não tem permissões para aceder a este item.",
		layerNotAvailable: "Falha ao carregar a camada ${layerName}.",
		multipleLayersNotAvailable: "Falha ao carregar a camada ${layerName} e outras.",
		learnMoreLabel: "Saber Mais",
		fieldNotAvailable: "Falha ao carregar o campo.",
		allowAnalysis: "A análise não é permitida no serviço de imagens.",
		allowAnalysisReason: "Uma ou mais camadas do mapa não estão indicadas aqui porque não permitem análises.",
		learnMoreText: "Saiba mais",
		atLeastOneRasterInput: "Pelo menos uma camada de entrada deve ser uma camada raster.",
		browseAnalysisLayers: "Procurar camadas",
		activeMapViewExtent: "Usar Extensão de Mapa Atual",
		chooseRaster: "Selecionar Recortar Raster",
		chooseGeometry: "Selecionar Recortar Geometria",
		resultType: "Tipo de resultado",
		saveInFolder: "Guardar numa pasta",
		outputName: "Nome de saída",
		outputLayerType: "Tipo de camada de saída",
		dynamicImageryLayer: "Camada de imagens dinâmica",
		tiledImageryLayer: "Camada de imagens em mosaico",
		custom: "Personalizar",
		loading: "A carregar...",
		layerMissing: "Uma ou mais camadas do mapa não estão indicadas aqui porque não permitem análises. Saiba mais.",
		browseCoordinateSystems: "Procurar sistemas de coordenadas",
		unableToRepopulateOutSR: "Não é possível preencher o sistema de coordenadas de saída.",
		defaultTitle: "Ver mais",
		"ARC (equal arc-second)": "ARC (arco-segundo igual)",
		Africa: "África",
		Antarctica: "Antártica",
		Argentina: "Argentina",
		Asia: "Ásia",
		"Asteroid Belt": "Cintura de Asteroides",
		"Atlantic Ocean": "Oceano Atlântico",
		Australia: "Austrália",
		"Australia and New Zealand": "Austrália e Nova Zelândia",
		Austria: "Áustria",
		"BLM (US Feet)": "BLM (Pés EUA)",
		Bangladesh: "Bangladesh",
		"Beijing 1954": "Beijing 1954",
		Bhutan: "Butão",
		CGCS2000: "CGCS2000",
		Canada: "Canadá",
		Caribbean: "Caraíbas",
		"Caribbean Sea": "Mar das Caraíbas",
		"Central America": "América Central",
		"Central and North America": "América Central e do Norte",
		Colombia: "Colômbia",
		Continental: "Continental",
		"County Systems": "Sistemas de Condados",
		"Democratic Republic of the Congo": "República Democrática do Congo",
		"EPSG Arctic": "Ártico EPSG",
		Earth: "Terra",
		"Ellipsoidal-based": "Baseado em elipsoidal",
		Europe: "Europa",
		Finland: "Finlândia",
		France: "França",
		"GSK 2011": "GSK 2011",
		"Gauss Kruger": "Gauss Kruger",
		"Geographic Coordinate Systems": "Sistemas de Coordenadas Geográficas",
		Germany: "Alemanha",
		"Gravity-related": "Relacionado com gravidade",
		"Greenwich-based": "Baseado em Greenwich",
		"Highways England": "Autoestradas de Inglaterra",
		Illinois: "Illinois",
		"Indian Ocean": "Oceano Índico",
		"Indian Subcontinent": "Subcontinente Indiano",
		Indiana: "Indiana",
		Indonesia: "Indonésia",
		Iowa: "Iowa",
		"Ireland and United Kingdom": "Irlanda e Reino Unido",
		Italy: "Itália",
		Japan: "Japão",
		Jupiter: "Júpiter",
		Kansas: "Kansas",
		"Las Vegas": "Las Vegas",
		Libya: "Líbia",
		Malaysia: "Malásia",
		"Malaysia and Singapore": "Malásia e Singapura",
		Mars: "Marte",
		Mercury: "Mercúrio",
		Minnesota: "Minnesota",
		Montana: "Montana",
		"NAD 1927": "NAD 1927",
		"NAD 1927 (US Feet)": "NAD 1927 (Pés EUA)",
		"NAD 1983": "NAD 1983",
		"NAD 1983 (2011)": "NAD 1983 (2011)",
		"NAD 1983 (2011) (Intl Feet)": "NAD 1983 (2011) (Pés Int.)",
		"NAD 1983 (2011) (Meters)": "NAD 1983 (2011) (Metros)",
		"NAD 1983 (2011) (US Feet)": "NAD 1983 (2011) (Pés EUA)",
		"NAD 1983 (CORS96) (Intl Feet)": "NAD 1983 (CORS96) (Pés Int.)",
		"NAD 1983 (CORS96) (Meters)": "NAD 1983 (CORS96) (Metros)",
		"NAD 1983 (CORS96) (US Feet)": "NAD 1983 (CORS96) (Pés EUA)",
		"NAD 1983 (Intl Feet)": "NAD 1983 (Pés Int.)",
		"NAD 1983 (Meters)": "NAD 1983 (Metros)",
		"NAD 1983 (PA11) (Meters)": "NAD 1983 (PA11) (Metros)",
		"NAD 1983 (PA11) (US Feet)": "NAD 1983 (PA11) (Pés EUA)",
		"NAD 1983 (US Feet)": "NAD 1983 (Pés EUA)",
		"NAD 1983 HARN (Intl Feet)": "NAD 1983 HARN (Pés Int.)",
		"NAD 1983 HARN (Meters)": "NAD 1983 HARN (Metros)",
		"NAD 1983 HARN (US Feet)": "NAD 1983 HARN (Pés EUA)",
		"NAD 1983 NSRS2007 (Intl Feet)": "NAD 1983 NSRS2007 (Pés Int.)",
		"NAD 1983 NSRS2007 (Meters)": "NAD 1983 NSRS2007 (Metros)",
		"NAD 1983 NSRS2007 (US Feet)": "NAD 1983 NSRS2007 (Pés EUA)",
		"National Grids": "Grelhas Nacionais",
		Navajo: "Navajo",
		Neptune: "Neptuno",
		"New Beijing": "Novo Pequim",
		"New Zealand": "Nova Zelândia",
		"North America": "América do Norte",
		"Northern Hemisphere": "Hemisfério Norte",
		Norway: "Noruega",
		Oceans: "Oceanos",
		Oregon: "Oregon",
		"Other GCS": "Outro GCS",
		"Pacific Ocean": "Oceano Pacífico",
		Pluto: "Plutão",
		Polar: "Polar",
		Portugal: "Portugal",
		"Projected Coordinate Systems": "Sistemas de Coordenadas Projetadas",
		"Pulkovo 1942": "Pulkovo 1942",
		"Pulkovo 1995": "Pulkovo 1995",
		Replaced: "Substituído",
		"SAD 1969": "SAD 1969",
		SIRGAS: "SIRGAS",
		"SIRGAS 2000": "SIRGAS 2000",
		Saturn: "Saturno",
		"Solar System": "Sistema Solar",
		"South Africa": "África do Sul",
		"South America": "América do Sul",
		"South Korea": "Coreia do Sul",
		"Southern Hemisphere": "Hemisfério Sul",
		"Spheroid-based": "Baseado em esferóides",
		"State Plane": "Plano Estatal",
		"State Systems": "Sistemas de Estados",
		Sweden: "Suécia",
		"Switzerland and Liechtenstein": "Suíça e Liechtenstein",
		Texas: "Texas",
		Tribal: "Tribal",
		Turkey: "Turquia",
		"US Feet": "Pés EUA",
		"USA and territories": "EUA e territórios",
		UTM: "UTM",
		Ukraine: "Ucrânia",
		"Unknown Height Systems": "Sistemas de Altura Desconhecidos",
		Uranus: "Úrano",
		Venus: "Vénus",
		"Vertical Coordinate Systems": "Sistemas de Coordenadas Verticais",
		Vietnam: "Vietname",
		"WGS 1972": "WGS 1972",
		"WGS 1984": "WGS 1984",
		Wisconsin: "Wisconsin",
		"Wisconsin CRS": "Wisconsin CRS",
		World: "Mundo",
		"World (Sphere-based)": "Mundo (Baseado em esferas)",
		Wyoming: "Wyoming",
		"Xian 1980": "Xian 1980",
		done: "Concluído",
		noResults: "Nenhum resultado encontrado",
		searchPlaceholder: "Nome ou WKID",
		browseTemplate: "Procurar templates de função raster",
		saveTemplate: "Guardar template de função raster",
		preview: "Pré-visualizar",
		previewDescription: "Pré-visualize o resultado antes de efetuar a análise.",
		showPreview: "Exibir pré-visualização",
		previewLayer: "Pré-visualizar camada ${number}",
		newPreview: "Nova pré-visualização",
		previewPopup: "Ative a pré-visualização dos resultados da análise com base nos parâmetros de entrada.",
		updatePreviewLayer: "Atualizar a camada de pré-visualização selecionada",
		createPreviewLayer: "Criar nova camada de pré-visualização",
		maximumPreviewAllowed: "Número máximo de camadas de pré-visualização permitido: ${maxCount}",
		previewFailure: "Esta camada de pré-visualização não está disponível. Verifique os parâmetros de entrada e atualize novamente esta camada de pré-visualização.",
		header: "Selecionar item",
		content: "Tem alterações não guardadas em ${rftTitle}. Se começar novamente com um novo template, essas alterações perder-se-ão.",
		dontSave: "Não guardar",
		"continue": "Continuar",
		stretch: "Ajustar à janela",
		pan: "Mover",
		newTemplate: "Criar novo template",
		openTemplate: "Abrir template",
		addFunction: "Adicionar funções raster",
		addConstant: "Adicionar constante",
		addRaster: "Adicionar variável raster",
		move: "Mover",
		zoom: "Zoom",
		saveAs: "Guardar como",
		clear: "Limpar",
		addRasterFunctionTitle: "Adicionar funções raster",
		templatePropertiesTitle: "Propriedades do template",
		browseRFT: "Procurar templates de função raster",
		defaultToolDescription: "Ferramenta de análise ${toolTitle}.",
		openToolText: "Abrir Ferramenta",
		toolDropdownText: "Lista Pendente da Ferramenta",
		addToMap: "Confirmar e adicionar ao mapa",
		confirm: "Confirmar",
		select: "Selecionar",
		selectTask: "Selecionar tarefa",
		unsupportedLayer: "Este parâmetro não suporta as seguintes camadas: ${layerName}.",
		viewDetails: "Ver detalhes completos do item",
		rename: "Alterar o nome",
		duplicate: "Duplicar",
		launch: "Abrir para execução",
		templateEditor: "Editor de Templates",
		createItem: "Guardar Template de Função Raster",
		actionLabel: "Filtrar",
		filterPopoverHeading: "Filtrar as funções",
		defaultSearchPlaceholder: "Pesquisar por nome",
		settings: "Definições",
		summary: "Resumo",
		definitionQuery: "Consulta de definição",
		matchVariables: "Corresponder variáveis",
		unionDimension: "Dimensão de união",
		nameEditorPlaceholder: "Introduzir título",
		summaryEditorPlaceholder: "Introduza uma breve descrição.",
		definitionQueryPlaceholder: "Introduza...",
		upload: "Carregar",
		chooseImage: "Clique para selecionar um ficheiro",
		update: "Atualizar",
		thumbnailErrors: {
			wrongImageType: "Tipo de imagem errado selecionado",
			notAvailable: "Imagem miniatura indisponível",
			loadError: "Não foi possível carregar a imagem",
			chooseFile: "Clique para selecionar ficheiro"
		}
	}
};
const copy = "Copiar";
const save = "Guardar";
const title = "Título";
const folder = "Pasta";
const tags = "Etiquetas";
const savingMessage = "Guardar item para";
const shareWith = "Partilhar Com";
const share = "Partilhar";
const setSharingLevel = "Definir Nível de Partilha";
const setGroupSharing = "Definir Partilha de Grupo";
const owner = "Proprietário";
const organization = "Organização";
const everyone = "Todos (público)";
const groups = "Grupos:";
const type = "Tipo";
const mosaic = "Mosaico";
const itemGroup = "Grupo de item";
const item = "Item";
const definitionQuery = "Consulta de definição";
const groupItemsBy = "Agrupar Itens Por";
const groupFieldName = "Agrupar Nome de Campo";
const tagFieldName = "Identificar Nome de Campo";
const noTitleTagErrorMsg = "Deve fornecer um título para o seu item e etiquetas para permitir que o seu mapa seja encontrado através de pesquisas.";
const noTitleErrorMsg = "Deve fornecer um título para o item.";
const noTagErrorMsg = "Deve fornecer pelo menos uma etiqueta para ajudar as pessoas a encontrar o seu item através de pesquisas.";
const error = "Erro";
const warning = "Aviso";
const success = "Realizado com Sucesso";
const details = "Detalhes:";
const tryAgain = "Tente novamente";
const toolModeler = {
	save: "Guardar",
	editProperties: "Editar Propriedades",
	saveAs: "Guardar Como",
	savingNotification: "Guardar alterações no item...",
	savingTitle: "A Guardar",
	saveFailedMessage: "Não foi possível guardar alterações.",
	saveWithErrorsMessage: "As alterações foram guardadas com os seguintes erros.",
	viewItemMessage: "Ver item guardado",
	here: "aqui.",
	itemCreatedMessage: "Foi criado um novo item.",
	clickToViewItemMessage: "Clique em OK para ver a página de detalhes do item. Clique em Cancelar para continuar.",
	readingFailed: "Falha ao carregar o modelo de funcionamento de raster selecionado.",
	failedToLoadXML: "Falha ao carregar o template da função raster selecionado no formato XML.",
	learnMore: "Saiba mais",
	overwriteTitle: "Confirmar substituição",
	overwriteMessage: "Pretende substituir o item existente?",
	overwriteSuccessMessage: "O item foi atualizado."
};
const toolEditor = {
	run: "Executar",
	save: "Guardar",
	deleteSelected: "Eliminar itens selecionados",
	addRaster: "Adicionar Raster",
	addScalar: "Adicionar Escalar",
	layout: "Layout Auto",
	errorTitle: "Erro",
	invalidToolMessage: "O modelo de funcionamento Raster não é válido.",
	out: "Fora",
	zoomIn: "Aumentar Zoom",
	zoomOut: "Reduzir Zoom",
	zoomToFit: "Ajustar à janela",
	panOn: "Mudar para modo de mover",
	panOff: "Desligar modo de mover",
	defaultModelName: "Modelo ferramenta",
	defaultRasterName: "Raster"
};
const toolDetailsEditor = {
	defaultToolName: "Modelo de Função Raster",
	defaultToolDescription: "Adicione um breve resumo acerca da função raster.",
	defaultHelpText: "Clique no ícone ajuda para editar o texto de ajuda",
	editHelpTitle: "Editar Ajuda",
	saveLabel: "Guardar",
	cancelLabel: "Cancelar",
	thumbnail: {
		wrongImageType: "Tipo de imagem errado selecionado",
		notAvailable: "Imagem miniatura indisponível",
		loadError: "Impossível carregar a imagem",
		chooseFile: "Clique para selecionar ficheiro"
	}
};
const saveUtils = {
	thumbnail: "Miniatura",
	sharing: "A Partilhar"
};
const close = "Fechar";
const unsavedWarningExisting = "Pretende guardar as alterações realizadas ao item <b>${itemTitle}</b>?";
const unsavedWarningNew = "Pretende guardar as suas alterações?";
const saveAs = "Guardar Como";
const dontSave = "Não Guardar";
const unsavedTitle = "Alterações Não-Guardadas";
const invalidRFTMessage = "O modelo de função raster criado não é válido.";
const errorTitle = "Erro";
const breadcrumb = "Editor de Funções Raster";
const breadcrumbEditor = "Conteúdo > Editor de Funções Raster";
const viewerModeTitle = "Só de Leitura";
const viewerModeMessage = "O item do modelo de função raster é só de leitura. Não é possível guardar as alterações.";
const userStartDirection = "Selecione uma função para começar a construir um modelo de função raster.";
const selectFunction = "Adicionar função";
const deselectFunction = "Remover função";
const dialogTitle = "Sistema";
const category = "Categorias";
const search = "Pesquisar Funções Raster";
const categoryNames = {
	analysis: "Análise",
	appearance: "Aspeto",
	classification: "Classificação",
	conversion: "Conversão",
	correction: "Correção",
	dataManagement: "Gestão de Dados",
	distance: "Distância",
	distanceLegacy: "Distância (Legado)",
	hydrology: "Hidrologia",
	math: "Matemática",
	mathConditional: "Mat: Condicional",
	mathLogical: "Mat: Lógica",
	mathTrigonometric: "Matemática: Trigonometria",
	reclass: "Reclassificar",
	statistical: "Estatística",
	surface: "Superfície"
};
const commonStrings_ptPT = {
	ok: ok,
	cancel: cancel,
	enterURL: enterURL,
	serviceURL: serviceURL,
	selectRaster: selectRaster,
	failedToLoadLayer: failedToLoadLayer,
	loadingLayer: loadingLayer,
	selectFeature: selectFeature,
	enterFURL: enterFURL,
	addRaster: addRaster,
	addScalar: addScalar,
	raster: raster,
	scalar: scalar,
	defaultModelName: defaultModelName,
	general: general,
	parameters: parameters,
	variables: variables,
	name: name,
	description: description,
	parameter: parameter,
	isPublic: isPublic,
	isDataset: isDataset,
	unknownPixelType: unknownPixelType,
	outputPixelType: outputPixelType,
	u8PixelType: u8PixelType,
	s8PixelType: s8PixelType,
	u16PixelType: u16PixelType,
	s16PixelType: s16PixelType,
	u32PixelType: u32PixelType,
	s32PixelType: s32PixelType,
	f32PixelType: f32PixelType,
	f64PixelType: f64PixelType,
	properties: properties,
	multidimensionalRules: multidimensionalRules,
	matchVariables: matchVariables,
	unionDimensions: unionDimensions,
	rasterFunctionEditor: rasterFunctionEditor,
	rfxLicenseInfo: rfxLicenseInfo,
	rasterFunctions: rasterFunctions,
	copy: copy,
	save: save,
	title: title,
	folder: folder,
	tags: tags,
	savingMessage: savingMessage,
	shareWith: shareWith,
	share: share,
	setSharingLevel: setSharingLevel,
	setGroupSharing: setGroupSharing,
	owner: owner,
	organization: organization,
	everyone: everyone,
	groups: groups,
	type: type,
	mosaic: mosaic,
	itemGroup: itemGroup,
	item: item,
	definitionQuery: definitionQuery,
	groupItemsBy: groupItemsBy,
	groupFieldName: groupFieldName,
	tagFieldName: tagFieldName,
	noTitleTagErrorMsg: noTitleTagErrorMsg,
	noTitleErrorMsg: noTitleErrorMsg,
	noTagErrorMsg: noTagErrorMsg,
	error: error,
	warning: warning,
	success: success,
	details: details,
	tryAgain: tryAgain,
	toolModeler: toolModeler,
	toolEditor: toolEditor,
	toolDetailsEditor: toolDetailsEditor,
	saveUtils: saveUtils,
	close: close,
	unsavedWarningExisting: unsavedWarningExisting,
	unsavedWarningNew: unsavedWarningNew,
	saveAs: saveAs,
	dontSave: dontSave,
	unsavedTitle: unsavedTitle,
	invalidRFTMessage: invalidRFTMessage,
	errorTitle: errorTitle,
	breadcrumb: breadcrumb,
	breadcrumbEditor: breadcrumbEditor,
	viewerModeTitle: viewerModeTitle,
	viewerModeMessage: viewerModeMessage,
	userStartDirection: userStartDirection,
	selectFunction: selectFunction,
	deselectFunction: deselectFunction,
	dialogTitle: dialogTitle,
	category: category,
	search: search,
	categoryNames: categoryNames
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (commonStrings_ptPT);


//# sourceMappingURL=common-strings.pt-PT-8f1cba9a.js.map

/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid2lkZ2V0cy9jaHVua3MvYXJjZ2lzX2FuYWx5c2lzX25vZGVfbW9kdWxlc19hcmNnaXNfYXJjZ2lzLXJhc3Rlci1mdW5jdGlvbi1lZGl0b3JfLTNjZjM2OC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaVpBQWlaLHFJQUFxSSw2REFBNkQ7QUFDbmxCO0FBQ0E7QUFDQSx1YUFBdWE7QUFDdmE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNJQUFzSTtBQUN0STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaU1BQWlNO0FBQ2pNO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0bUJBQTRtQjtBQUM1bUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZPQUE2TztBQUM3TztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb3FDQUFvcUMsaVVBQWlVO0FBQ3IrQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdWxHQUF1bEcsT0FBTztBQUM5bEc7QUFDQTtBQUNBLDJ6Q0FBMnpDO0FBQzN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsOERBQThELGFBQWE7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUVBQXVFLElBQUk7QUFDM0Usc0VBQXNFLElBQUk7QUFDMUUscUZBQXFGLElBQUk7QUFDekYsb0ZBQW9GLElBQUk7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsVUFBVTtBQUM3RCw0REFBNEQsV0FBVztBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxPQUFPO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0ZBQW9GLFNBQVM7QUFDN0Y7QUFDQTtBQUNBLDhDQUE4QyxTQUFTO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELFVBQVU7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFLFVBQVU7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUZBQXVGLFVBQVU7QUFDakc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpRUFBZSxrQkFBa0IsRUFBQztBQUMrbkM7O0FBRWpxQyIsInNvdXJjZXMiOlsid2VicGFjazovL2V4Yi1jbGllbnQvLi9leHRlbnNpb25zL3dpZGdldHMvYXJjZ2lzL2FuYWx5c2lzL25vZGVfbW9kdWxlcy9AYXJjZ2lzL2FyY2dpcy1yYXN0ZXItZnVuY3Rpb24tZWRpdG9yL2Rpc3QvZXNtL2NvbW1vbi1zdHJpbmdzLnB0LVBULThmMWNiYTlhLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IG9rID0gXCJPa1wiO1xuY29uc3QgY2FuY2VsID0gXCJDYW5jZWxhclwiO1xuY29uc3QgZW50ZXJVUkwgPSBcIkludHJvZHV6aXIgVVJMIGRlIHNlcnZpw6dvIGRlIGltYWdlbVwiO1xuY29uc3Qgc2VydmljZVVSTCA9IFwiVVJMIGRlIFNlcnZpw6dvXCI7XG5jb25zdCBzZWxlY3RSYXN0ZXIgPSBcIlNlbGVjaW9uYXIgUmFzdGVyXCI7XG5jb25zdCBmYWlsZWRUb0xvYWRMYXllciA9IFwiRmFsaGEgYW8gY2FycmVnYXIgYSBDYW1hZGFcIjtcbmNvbnN0IGxvYWRpbmdMYXllciA9IFwiQSBjYXJyZWdhciBjYW1hZGFcIjtcbmNvbnN0IHNlbGVjdEZlYXR1cmUgPSBcIlNlbGVjaW9uYXIgQ2FtYWRhIGRlIEVsZW1lbnRvc1wiO1xuY29uc3QgZW50ZXJGVVJMID0gXCJJbnRyb2R1emlyIFVSTCBkZSBTZXJ2acOnbyBkZSBFbGVtZW50b3NcIjtcbmNvbnN0IGFkZFJhc3RlciA9IFwiQWRpY2lvbmFyIHZhcmnDoXZlbCByYXN0ZXJcIjtcbmNvbnN0IGFkZFNjYWxhciA9IFwiQWRpY2lvbmFyIGNvbnN0YW50ZVwiO1xuY29uc3QgcmFzdGVyID0gXCJSYXN0ZXJcIjtcbmNvbnN0IHNjYWxhciA9IFwiRXNjYWxhclwiO1xuY29uc3QgZGVmYXVsdE1vZGVsTmFtZSA9IFwiTW9kZWxvIGRlIEZ1bsOnw6NvIFJhc3RlclwiO1xuY29uc3QgZ2VuZXJhbCA9IFwiR2VyYWxcIjtcbmNvbnN0IHBhcmFtZXRlcnMgPSBcIlBhcsOibWV0cm9zXCI7XG5jb25zdCB2YXJpYWJsZXMgPSBcIlZhcmnDoXZlaXNcIjtcbmNvbnN0IG5hbWUgPSBcIk5vbWVcIjtcbmNvbnN0IGRlc2NyaXB0aW9uID0gXCJEZXNjcmnDp8Ojb1wiO1xuY29uc3QgcGFyYW1ldGVyID0gXCJQYXLDom1ldHJvXCI7XG5jb25zdCBpc1B1YmxpYyA9IFwiSXNQdWJsaWNcIjtcbmNvbnN0IGlzRGF0YXNldCA9IFwiSXNEYXRhc2V0XCI7XG5jb25zdCB1bmtub3duUGl4ZWxUeXBlID0gXCJEZXNjb25oZWNpZG9cIjtcbmNvbnN0IG91dHB1dFBpeGVsVHlwZSA9IFwiVGlwbyBkZSBwaXhlbCBkZSBzYcOtZGFcIjtcbmNvbnN0IHU4UGl4ZWxUeXBlID0gXCI4IEJpdCBuw6NvIHJlZ2lzdGFkb1wiO1xuY29uc3QgczhQaXhlbFR5cGUgPSBcIjggQml0IHJlZ2lzdGFkb1wiO1xuY29uc3QgdTE2UGl4ZWxUeXBlID0gXCIxNiBCaXQgbsOjbyByZWdpc3RhZG9cIjtcbmNvbnN0IHMxNlBpeGVsVHlwZSA9IFwiMTYgQml0IHJlZ2lzdGFkb1wiO1xuY29uc3QgdTMyUGl4ZWxUeXBlID0gXCIzMiBCaXQgbsOjbyByZWdpc3RhZG9cIjtcbmNvbnN0IHMzMlBpeGVsVHlwZSA9IFwiMzIgQml0IHJlZ2lzdGFkb1wiO1xuY29uc3QgZjMyUGl4ZWxUeXBlID0gXCIzMiBCaXQgZmx1dHVhbnRlXCI7XG5jb25zdCBmNjRQaXhlbFR5cGUgPSBcIjY0IEJpdCBkdXBsb1wiO1xuY29uc3QgcHJvcGVydGllcyA9IFwiUHJvcHJpZWRhZGVzXCI7XG5jb25zdCBtdWx0aWRpbWVuc2lvbmFsUnVsZXMgPSBcIlJlZ3JhcyBNdWx0aWRpbWVuc2lvbmFpc1wiO1xuY29uc3QgbWF0Y2hWYXJpYWJsZXMgPSBcIkNvcnJlc3BvbmRlciBWYXJpw6F2ZWlzXCI7XG5jb25zdCB1bmlvbkRpbWVuc2lvbnMgPSBcIkRpbWVuc8O1ZXMgZGEgVW5pw6NvXCI7XG5jb25zdCByYXN0ZXJGdW5jdGlvbkVkaXRvciA9IHtcblx0aW52YWxpZFJGVE1lc3NhZ2U6IFwiTyBNb2RlbG8gZGUgRnVuw6fDo28gUmFzdGVyIG7Do28gw6kgdsOhbGlkby5cIixcblx0cmZ4QXJnc0VkaXRvcjoge1xuXHRcdG91dHB1dFJhc3RlcjogXCJPdXRwdXRSYXN0ZXJcIixcblx0XHRyYXN0ZXI6IFwiUmFzdGVyXCIsXG5cdFx0dW5zdXBwb3J0ZWREYXRhVHlwZVdhcm5pbmc6IFwiT3Mgc2VndWludGVzIGFyZ3VtZW50b3MgbsOjbyBzw6NvIGV4aWJpZG9zLCBqw6EgcXVlIG7Do28gc8OjbyBhdHVhbG1lbnRlIHN1cG9ydGFkb3MuXCIsXG5cdFx0dW5zdXBwb3J0ZWRGdW5jdGlvbjogXCJDb250w6ltIHVtYSBvdSBtYWlzIGZ1bsOnw7VlcyByYXN0ZXIgYXR1YWxtZW50ZSBuw6NvIHN1cG9ydGFkYXMuXCJcblx0fSxcblx0cmZ4UmFzdGVySW5wdXQ6IHtcblx0XHRzZWxlY3RMYXllcjogXCJTZWxlY2lvbmFyIENhbWFkYVwiLFxuXHRcdGJyb3dzZUxheWVyczogXCJQcm9jdXJhciBDYW1hZGFzXCIsXG5cdFx0cmZ4VmFyaWFibGU6IFwiUmFzdGVyRnVuY3Rpb25WYXJpYWJsZVwiXG5cdH0sXG5cdHJmeEJhbmRDb21iaW5hdGlvbkVkaXRvcjoge1xuXHRcdG1ldGhvZExhYmVsOiBcIk3DqXRvZG9cIixcblx0XHRiYW5kTGFiZWw6IFwiQmFuZGFcIixcblx0XHRjb21iaW5hdGlvbkxhYmVsOiBcIkNvbWJpbmHDp8Ojb1wiXG5cdH0sXG5cdHJmeFJlbWFwR3JpZDoge1xuXHRcdG1pbmltdW06IFwiTcOtbmltb1wiLFxuXHRcdG1heGltdW06IFwiTcOheGltb1wiLFxuXHRcdG91dHB1dDogXCJTYcOtZGFcIixcblx0XHRub0RhdGE6IFwiTm9EYXRhXCIsXG5cdFx0cmVtYXBWYWx1ZXNMYWJlbDogXCJWb2x0YXIgYSBDYXJ0b2dyYWZhciBWYWxvcmVzXCJcblx0fSxcblx0cmZ4TmFtZWRSYXN0ZXJFZGl0b3I6IHtcblx0XHRyYXN0ZXJWYXJpYWJsZXM6IFwiVmFyacOhdmVpcyBSYXN0ZXJcIixcblx0XHRkZWxldGVTZWxlY3RlZFZhcnM6IFwiUmVtb3ZlciB2YXJpw6F2ZWlzIHNlbGVjaW9uYWRhc1wiXG5cdH0sXG5cdHJmeENsaXBwaW5nR2VvbWV0cnk6IHtcblx0XHRjbGlwcGluZ0xheWVyOiBcIkNhbWFkYSBkZSBSZWNvcnRlXCIsXG5cdFx0Y2xpcHBpbmdSYXN0ZXI6IFwiUmVjb3J0YXIgUmFzdGVyXCIsXG5cdFx0Y2xpcHBpbmdHZW9tZXRyeTogXCJHZW9tZXRyaWEgZGUgUmVjb3J0ZVwiLFxuXHRcdGN1c3RvbUV4dGVudDogXCJFeHRlbnPDo28gcGVyc29uYWxpemFkYVwiLFxuXHRcdG91dHB1dEV4dGVudDogXCJFeHRlbnPDo28gZGUgU2HDrWRhXCIsXG5cdFx0Y3VycmVudEV4dGVudDogXCJFeHRlbnPDo28gbWFwYSBhdHVhbFwiLFxuXHRcdGRyYXdMYWJlbDogXCJEZXNlbmhhclwiXG5cdH0sXG5cdHJmeEN1c3RvbUV4dGVudDoge1xuXHRcdHRvcDogXCJTdXBlcmlvclwiLFxuXHRcdHJpZ2h0OiBcIkRpcmVpdGFcIixcblx0XHRib3R0b206IFwiSW5mZXJpb3JcIixcblx0XHRsZWZ0OiBcIkVzcXVlcmRhXCJcblx0fSxcblx0cmZ4UmFzdGVyQXJyYXlFZGl0b3I6IHtcblx0XHRtb3ZlVXA6IFwiTW92ZXIgcGFyYSBjaW1hXCIsXG5cdFx0bW92ZURvd246IFwiTW92ZXIgcGFyYSBiYWl4b1wiLFxuXHRcdHJlbW92ZTogXCJSZW1vdmVyXCJcblx0fSxcblx0cmZ4U3RhdGlzdGljc0dyaWQ6IHtcblx0XHRzdGREZXY6IFwiRGVzdmlvIERldlwiLFxuXHRcdG1pbjogXCJNw61uLlwiLFxuXHRcdG1heDogXCJNw6F4LlwiLFxuXHRcdG1lYW46IFwiTcOpZGlhXCJcblx0fSxcblx0cmZ4V2VpZ2h0ZWRTdW1UYWJsZUVkaXRvcjoge1xuXHRcdHdlaWdodGVkU3VtVGFibGU6IFwiVGFiZWxhIGRlIFNvbWEgUG9uZGVyYWRhXCIsXG5cdFx0aWQ6IFwiSURcIixcblx0XHRsYXllcjogXCJDYW1hZGFcIixcblx0XHRmaWVsZDogXCJDYW1wb1wiLFxuXHRcdHdlaWdodDogXCJQZXNvXCIsXG5cdFx0dmFsdWU6IFwiVmFsb3JcIixcblx0XHRzZWxlY3RMYXllcjogXCJTZWxlY2lvbmFyIENhbWFkYVwiXG5cdH0sXG5cdHJmeFdlaWdodGVkT3ZlcmxheVRhYmxlRWRpdG9yOiB7XG5cdFx0d2VpZ2h0ZWRPdmVybGF5VGFibGU6IFwiVGFiZWxhIGRlIFNvYnJlcG9zacOnw6NvIFBvbmRlcmFkYVwiLFxuXHRcdGlkOiBcIklEXCIsXG5cdFx0bGF5ZXI6IFwiQ2FtYWRhXCIsXG5cdFx0ZmllbGQ6IFwiQ2FtcG9cIixcblx0XHRpbmZsdWVuY2U6IFwiSW5mbHXDqm5jaWFcIixcblx0XHRzdW1PZkluZmx1ZW5jZTogXCJTb21hIGRlIGluZmx1w6puY2lhXCIsXG5cdFx0dmFsdWU6IFwiVmFsb3JcIixcblx0XHRyZW1hcFRhYmxlOiBcIlZvbHRhciBhIENhcnRvZ3JhZmFyIFRhYmVsYVwiLFxuXHRcdHNjYWxlOiBcIkVzY2FsYVwiLFxuXHRcdHNjYWxlczogXCJFc2NhbGFzXCIsXG5cdFx0c2VsZWN0UmFzdGVyOiBcIlNlbGVjaW9uYXIgUmFzdGVyXCJcblx0fSxcblx0cmZ4RmVhdHVyZVNlbGVjdDoge1xuXHRcdGFkZEZlYXR1cmVMYXllcjogXCJQcm9jdXJhciB1bWEgY2FtYWRhIGRlIGVsZW1lbnRvc1wiLFxuXHRcdGFkZFBvaW50TGF5ZXI6IFwiUHJvY3VyYXIgdW1hIGNhbWFkYSBkZSBwb250b3NcIlxuXHR9LFxuXHRyZnhGaWVsZFNlbGVjdDoge1xuXHRcdHZhbHVlOiBcIlZhbG9yXCIsXG5cdFx0Y291bnQ6IFwiQ29udGFnZW1cIlxuXHR9LFxuXHRyZnhBdHRyaWJ1dGVUYWJsZToge1xuXHRcdHRhYmxlVHlwZTogXCJUaXBvIGRlIFRhYmVsYVwiLFxuXHRcdG1hbnVhbDogXCJNYW51YWxcIixcblx0XHRleHRlcm5hbDogXCJFeHRlcm5vXCIsXG5cdFx0bWluVmFsOiBcIlZhbG9yIE3DrW5pbW9cIixcblx0XHRtYXhWYWw6IFwiVmFsb3IgTcOheGltb1wiLFxuXHRcdGJhc2VDbGFzc05hbWU6IFwiTm9tZSBCYXNlIGRhIENsYXNzZVwiLFxuXHRcdGNvbG9yU2NoZW1lOiBcIkVzcXVlbWEgZGUgQ29yZXNcIixcblx0XHRkZWZhdWx0Q2xhc3NOYW1lOiBcIlLDs3R1bG9fXCIsXG5cdFx0Z2VuZXJhdGVUYWJsZTogXCJDcmlhciB0YWJlbGFcIixcblx0XHRicm93c2VUYWJsZTogXCJQZXNxdWlzYXIgVGFiZWxhXCIsXG5cdFx0dmFsdWU6IFwiVmFsb3JcIixcblx0XHRjbGFzc25hbWU6IFwiQ2xhc3NOYW1lXCIsXG5cdFx0Y29sb3I6IFwiQ29yXCJcblx0fSxcblx0cmZ4RmllbGROdW1iZXJTd2l0Y2hhYmxlOiB7XG5cdFx0bnVtYmVyOiBcIk51bcOpcmljb1wiLFxuXHRcdGZpZWxkOiBcIkNhbXBvXCIsXG5cdFx0c3RyaW5nOiBcIlRleHRvXCIsXG5cdFx0bGluZWFyVW5pdDogXCJVbmlkYWRlIExpbmVhclwiXG5cdH0sXG5cdHJmeFByb3BlcnR5U2V0OiB7XG5cdFx0bmFtZTogXCJOb21lXCIsXG5cdFx0dmFsdWU6IFwiVmFsb3JcIlxuXHR9LFxuXHRyZnhDb252ZXJzaW9uR3JpZDoge1xuXHRcdHNpemU6IFwiVGFtYW5ob1wiXG5cdH0sXG5cdHJmeFRyYW5zcG9zZUJpdDoge1xuXHRcdGJpdFBhdHRlcm46IFwiUGFkcsOjbyBkZSBCaXRzXCIsXG5cdFx0b3V0cHV0Qml0OiBcIkJpdCBzYcOtZGFcIixcblx0XHRpbnB1dEJpdDogXCJCaXQgZW50cmFkYVwiXG5cdH0sXG5cdHJmeFNwYXRpYWxSZWZlcmVuY2U6IHtcblx0XHRwbGFjZUhvbGRlcjogXCJSZWZpbmUgcG9yIFBhbGF2cmEtY2hhdmVcIixcblx0XHRjb29yZGluYXRlU3lzdGVtOiBcIlNpc3RlbWEgZGUgQ29vcmRlbmFkYXNcIixcblx0XHRnY3M6IFwiU2lzdGVtYSBkZSBDb29yZGVuYWRhcyBHZW9ncsOhZmljYXNcIixcblx0XHRwY3M6IFwiU2lzdGVtYSBkZSBDb29yZGVuYWRhcyBQcm9qZWN0YWRhc1wiLFxuXHRcdHZjczogXCJDb29yZGVuYXIgU2lzdGVtYSBWZXJ0aWNhbFwiXG5cdH1cbn07XG5jb25zdCByZnhMaWNlbnNlSW5mbyA9IFwiRXN0ZSBtb2RlbG8gZGUgZnVuw6fDo28gcmFzdGVyIHBvZGUgc2VyIHV0aWxpemFkbyBwYXJhIHByb2Nlc3NhciBhcyBzdWFzIGltYWdlbnMgYW8gdXNhciBvIEFyY0dJUyBJbWFnZSBTZXJ2ZXIuXCI7XG5jb25zdCByYXN0ZXJGdW5jdGlvbnMgPSB7XG5cdHJmeDoge1xuXHRcdGFDb3NITmFtZTogXCJBQ29zSFwiLFxuXHRcdGFDb3NIU25pcDogXCJDYWxjdWxhIG8gY29zc2VubyBoaXBlcmLDs2xpY28gaW52ZXJzbyBkYXMgY8OpbHVsYXMgbnVtIHJhc3Rlci5cIixcblx0XHRhQ29zSERlc2M6IFwiQSBmdW7Dp8OjbyBjYWxjdWxhIG8gY29zc2VubyBoaXBlcmLDs2xpY28gaW52ZXJzbyBkb3MgcMOteGVpcyBudW0gcmFzdGVyLlwiLFxuXHRcdGFDb3NOYW1lOiBcIkFDb3NcIixcblx0XHRhQ29zU25pcDogXCJDYWxjdWxhIG8gY29zc2VubyBpbnZlcnNvIGRlIHDDrXhlaXMgbnVtIHJhc3Rlci5cIixcblx0XHRhQ29zRGVzYzogXCJFc3RhIGZ1bsOnw6NvIHJhc3RlciBjYWxjdWxhIG8gY29zc2VubyBpbnZlcnNvIGRhcyBjw6lsdWxhcyBudW0gcmFzdGVyLiBFbSBtYXRlbcOhdGljYSwgdG9kYXMgYXMgZnVuw6fDtWVzIHRyaWdvbm9tw6l0cmljYXMgdMOqbSB1bSBpbnRlcnZhbG8gZGVmaW5pZG8gZGUgdmFsb3JlcyBkZSBlbnRyYWRhIHbDoWxpZG9zLCBjaGFtYWRvIGRvbcOtbmlvLiBPcyB2YWxvcmVzIGRlIHNhw61kYSBkZSBjYWRhIGZ1bsOnw6NvIHTDqm0gdGFtYsOpbSB1bSBpbnRlcnZhbG8gZGVmaW5pZG8uIFBhcmEgZXN0YSBmZXJyYW1lbnRhLCBvIGRvbcOtbmlvIMOpIFstMSwgMV0sIGUgbyBpbnRlcnZhbG8gw6kgWzAsIHBpXS5cIixcblx0XHRhU2luSE5hbWU6IFwiQVNpbkhcIixcblx0XHRhU2luSFNuaXA6IFwiQ2FsY3VsYSBvIHNlbm8gaGlwZXJiw7NsaWNvIGludmVyc28gZGFzIGPDqWx1bGFzIG51bSByYXN0ZXIuXCIsXG5cdFx0YVNpbkhEZXNjOiBcIkEgZnVuw6fDo28gY2FsY3VsYSBvIHNlbm8gaGlwZXJiw7NsaWNvIGludmVyc28gZG9zIHDDrXhlaXMgbnVtIHJhc3Rlci5cIixcblx0XHRhU2luTmFtZTogXCJBU2luXCIsXG5cdFx0YVNpblNuaXA6IFwiQ2FsY3VsYSBvIHNlbm8gaW52ZXJzbyBkYXMgY8OpbHVsYXMgbnVtIHJhc3Rlci5cIixcblx0XHRhU2luRGVzYzogXCJBIGZ1bsOnw6NvIGNhbGN1bGEgbyBzZW5vIGludmVyc28gZG9zIHDDrXhlaXMgbnVtIHJhc3Rlci5cIixcblx0XHRhVGFuMk5hbWU6IFwiQVRhbjJcIixcblx0XHRhVGFuMlNuaXA6IFwiQ2FsY3VsYSBhIHRhbmdlbnRlIGludmVyc2EgKGJhc2VhZGEgZW0geCx5KSBkYXMgY8OpbHVsYXMgbnVtIHJhc3Rlci5cIixcblx0XHRhVGFuMkRlc2M6IFwiQSBmdW7Dp8OjbyBjYWxjdWxhIGEgdGFuZ2VudGUgaW52ZXJzYSAoYmFzZWFkYSBlbSB4LHkpIGRvcyBww614ZWlzIG51bSByYXN0ZXIuXCIsXG5cdFx0YVRhbkhOYW1lOiBcIkFUYW5IXCIsXG5cdFx0YVRhbkhTbmlwOiBcIkNhbGN1bGEgYSB0YW5nZW50ZSBoaXBlcmLDs2xpY2EgaW52ZXJzYSBkYXMgY8OpbHVsYXMgbnVtIHJhc3Rlci5cIixcblx0XHRhVGFuSERlc2M6IFwiQSBmdW7Dp8OjbyBjYWxjdWxhIGEgdGFuZ2VudGUgaGlwZXJiw7NsaWNhIGludmVyc2EgZG9zIHDDrXhlaXMgbnVtIHJhc3Rlci5cIixcblx0XHRhVGFuTmFtZTogXCJBVGFuXCIsXG5cdFx0YVRhblNuaXA6IFwiQ2FsY3VsYSBhIHRhbmdlbnRlIGludmVyc2EgZGFzIGPDqWx1bGFzIG51bSByYXN0ZXIuXCIsXG5cdFx0YVRhbkRlc2M6IFwiQSBmdW7Dp8OjbyBjYWxjdWxhIGEgdGFuZ2VudGUgaW52ZXJzYSBkb3MgcMOteGVpcyBudW0gcmFzdGVyLlwiLFxuXHRcdGFic05hbWU6IFwiQWJzXCIsXG5cdFx0YWJzU25pcDogXCJDYWxjdWxhIG8gdmFsb3IgYWJzb2x1dG8gZG9zIHDDrXhlaXMgbnVtIHJhc3Rlci5cIixcblx0XHRhYnNEZXNjOiBcIkEgZnVuw6fDo28gQWJzIGNhbGN1bGEgbyB2YWxvciBhYnNvbHV0byBkb3MgcMOteGVpcyBudW0gcmFzdGVyLlwiLFxuXHRcdHJlZmxlY3RhbmNlTmFtZTogXCJSZWZsZXTDom5jaWEgQXBhcmVudGVcIixcblx0XHRyZWZsZWN0YW5jZVNuaXA6IFwiQ29udmVydGUgaW1hZ2VucyBicnV0YXMgZW0gdmFsb3JlcyBkZSBUb3BvIGRhIEF0bW9zZmVyYSBsZXZhbmRvIGVtIGNvbnNpZGVyYcOnw6NvIGFzIGNhcmFjdGVyw61zdGljYXMgZG8gc2Vuc29yIGRhIGNvbnRhLCBhIHBvc2nDp8OjbyBkbyBzb2wgZSBhIGhvcmEgZGEgYXF1aXNpw6fDo28uXCIsXG5cdFx0cmVmbGVjdGFuY2VEZXNjOiBcIkVzdGEgZnVuw6fDo28gYWp1c3RhIG9zIHZhbG9yZXMgcmVmZXJlbnRlcyBhbyBuw7ptZXJvIGRpZ2l0YWwgKEROKSBkbyBicmlsaG8gZGEgaW1hZ2VtIHBhcmEgYWxndW5zIHNlbnNvcmVzIHNhdMOpbGl0ZS4gT3MgYWp1c3RlcyBzw6NvIGJhc2VhZG9zIG5hIGVsZXZhw6fDo28gZG8gc29sLCBkYXRhIGRhIGFxdWlzacOnw6NvIGUgcHJvcHJpZWRhZGVzIGRvIHNlbnNvciBwYXJhIGRlZmluaXIgbyBnYW5obyBlIGEgdGVuZMOqbmNpYSBwYXJhIGNhZGEgYmFuZGEuIEVzdGEgZnVuw6fDo28gw6kgdXRpbGl6YWRhIHBhcmEgYWp1c3RhciBvcyB2YWxvcmVzIGRlIHJlZmxleMOjbyBlIGJyaWxobyBkZSBhbGd1bWFzIGltYWdlbnMgZGUgc2F0w6lsaXRlIGJhc2VhZGFzIG5hIGlsdW1pbmHDp8OjbyBkYSBjZW5hIGUgZGFzIGNvbmZpZ3VyYcOnw7VlcyBkZSBnYW5obyBkbyBzZW5zb3IuIEFzIGltYWdlbnMgc8OjbyBhanVzdGFkYXMgYSB1bWEgY29uZGnDp8OjbyBkZSBpbHVtaW5hw6fDo28gY29tdW0gdGXDs3JpY2EsIG8gcXVlIHNpZ25pZmljYSBxdWUgZGV2ZXLDoSBoYXZlciBtZW5vcyB2YXJpYcOnw6NvIGVudHJlIGNlbmFzIGRlIGRpZmVyZW50ZXMgZGF0YXMgZSBkaWZlcmVudGVzIHNlbnNvcmVzLiBJc3RvIHBvZGUgc2VyIMO6dGlsIHBhcmEgYSBjbGFzc2lmaWNhw6fDo28gZGUgaW1hZ2VucywgYmFsYW5jZWFtZW50byBkZSBjb3JlcyBlIGNvbnN0cnXDp8OjbyBkZSBtb3NhaWNvcy4gRXN0YSBmdW7Dp8OjbyBhcGVuYXMgcG9kZSBzZXIgdXRpbGl6YWRhIGNvbSBpbWFnZW5zIGVzcGVjw61maWNhcy4gT3Mgc2Vuc29yZXMgYXBsaWPDoXZlaXMgc8OjbyBvIExhbmRzYXQgTVNTLCBMYW5kc2F0IFRNLCBMYW5kc2F0IEVUTSssIExhbmRzYXQgOCwgSUtPTk9TLCBRdWlja0JpcmQsIEdlb0V5ZS0xLCBSYXBpZEV5ZSwgRE1DaWksIFdvcmxkVmlldy0xLCBXb3JsZFZpZXctMiwgU1BPVCA2LCBlIFBsZWlhZGVzLjxkaXY+PGJyLz5BIGZ1bsOnw6NvIGVmZXR1YSBkdWFzIGNvcnJlw6fDtWVzLiBBIHByaW1laXJhIMOpIGJhc2VhZGEgbmFzIGNvbmZpZ3VyYcOnw7VlcyBkbyBnYW5oby4gT3MgdmFsb3JlcyBkZSBicmlsaG8gb3JpZ2luYWlzIHPDo28gcmVjcmlhZG9zIGEgcGFydGlyIGRvcyB2YWxvcmVzIGRhIGltYWdlbSBpbnZlcnRlbmRvIGFzIGVxdWHDp8O1ZXMgZG8gZ2FuaG8uIEEgc2VndW5kYSBjb3JyZcOnw6NvIGVzdMOhIHJlbGFjaW9uYWRhIGNvbSBkaWZlcmVuw6dhcyBubyDDom5ndWxvIGRvIHNvbCBlIG5vIGJyaWxoby4gT3MgdmFsb3JlcyBkZSBicmlsaG8gb3JpZ2luYWlzIHPDo28gYWp1c3RhZG9zIGEgdW1hIGNvbmRpw6fDo28gZGUgaWx1bWluYcOnw6NvIGNvbXVtIGF0cmF2w6lzIGRlIGNlbmFzIG5vcm1hbGl6YW50ZXMgY2FwdHVyYWRhcyBzb2IgY29uZGnDp8O1ZXMgZGUgaWx1bWluYcOnw6NvIHZhcmnDoXZlaXMuIE5vIGdlcmFsLCBlbnF1YW50byBvIHRpcG8gZGUgZGFkb3MgZGUgc2HDrWRhIGRhIGltYWdlbSDDqSBvIG1lc21vIHF1ZSBvIHRpcG8gZGUgZGFkb3MgZGUgZW50cmFkYSBkYSBpbWFnZW0sIG9zIHZhbG9yZXMgZGUgc2HDrWRhIHPDo28gaW5mZXJpb3JlcyBhb3MgdmFsb3JlcyBkZSBlbnRyYWRhIGUgZXN0w6NvIGNvbnRpZG9zIG5vIGludGVydmFsbyBkZSBkYWRvcyB2w6FsaWRvcy48L2Rpdj5cIixcblx0XHRhcmdTdGF0aXN0aWNzTmFtZTogXCJBcmdTdGF0aXN0aWNzXCIsXG5cdFx0YXJnU3RhdGlzdGljc1NuaXA6IFwiQ2FsY3VsYSBlc3RhdMOtc3RpY2EgYXJnIGluY2x1aW5kbyBBcmcgTWF4LCBBcmcgTWluLCBBcmcgTWVkaWFuLCBlIER1cmHDp8Ojby5cIixcblx0XHRhcmdTdGF0aXN0aWNzRGVzYzogXCJBIGZ1bsOnw6NvIGNhbGN1bGEgZXN0YXTDrXN0aWNhIGFyZy4gRXhpc3RlbSBxdWF0cm8gbcOpdG9kb3MgbmEgZnVuw6fDo28gQXJnU3RhdGlzdGljczogQXJnTWF4LCBBcmdNaW4sIEFyZ01lZGlhbiwgZSBEdXJhw6fDo28uXCIsXG5cdFx0YXJpdGhtZXRpY05hbWU6IFwiQXJpdG3DqXRpY29zXCIsXG5cdFx0YXJpdGhtZXRpY1NuaXA6IFwiRXhlY3V0YSB1bWEgb3BlcmHDp8OjbyBhcml0bcOpdGljYSBlbnRyZSBkb2lzIHJhc3RlcnMgb3UgdW0gcmFzdGVyIGUgdW0gZXNjYWxhci5cIixcblx0XHRhcml0aG1ldGljRGVzYzogXCJBIGZ1bsOnw6NvIEFyaXRtw6l0aWNhIGV4ZWN1dGEgdW1hIG9wZXJhw6fDo28gYXJpdG3DqXRpY2EgZW50cmUgZG9pcyByYXN0ZXJzIG91IHVtIHJhc3RlciBlIHVtIGVzY2FsYXIgZSB2aWNlLXZlcnNhLlwiLFxuXHRcdGFzcGVjdFNsb3BlTmFtZTogXCJBc3BldG8tSW5jbGluYcOnw6NvXCIsXG5cdFx0YXNwZWN0U2xvcGVTbmlwOiBcIkNyaWEgdW0gcmFzdGVyLCBxdWUgc2ltdWx0YW5lYW1lbnRlIGV4aWJlIG8gYXNwZXRvIChkaXJlw6fDo28pIGUgYSBpbmNsaW5hw6fDo28gKGRlY2xpdmUpIGRlIHVtYSBzdXBlcmbDrWNpZSBjb250w61udWEsIHRhbCBjb21vIMOpIHJlcHJlc2VudGFkbyBudW0gbW9kZWxvIGRlIGVsZXZhw6fDo28gZGlnaXRhbC5cIixcblx0XHRhc3BlY3RTbG9wZURlc2M6IFwiQSBmdW7Dp8OjbyBBc3BldG8gSW5jbGluYcOnw6NvIGNyaWEgdW1hIGNhbWFkYSByYXN0ZXIsIHF1ZSBzaW11bHRhbmVhbWVudGUgZXhpYmUgbyBhc3BldG8gZSBhIGluY2xpbmHDp8OjbyBkZSB1bWEgc3VwZXJmw61jaWUuIE8gQXNwZXRvIGlkZW50aWZpY2EgYSBkaXJlw6fDo28gZGUgaW5jbGluYcOnw6NvIGRhIHRheGEgZGUgdmFyaWHDp8OjbyBtw6F4aW1hIGVtIHZhbG9yIGVudHJlIGNhZGEgcMOteGVsIGUgb3Mgc2V1cyB2aXppbmhvcy4gTyBhc3BldG8gcG9kZSBzZXIgdmlzdG8gY29tbyBhIGRpcmXDp8OjbyBkYSBpbmNsaW5hw6fDo28uIE9zIHZhbG9yZXMgZG8gcmFzdGVyIGRlIHNhw61kYSBzZXLDo28gYSBkaXJlw6fDo28gZGEgYsO6c3NvbGEgZG8gYXNwZXRvLCByZXByZXNlbnRhZG8gcG9yIHVtYSB0b25hbGlkYWRlIChjb3IpLiBBIGluY2xpbmHDp8OjbyByZXByZXNlbnRhIGEgdGF4YSBkZSB2YXJpYcOnw6NvIGRhIGVsZXZhw6fDo28gcGFyYSBjYWRhIHDDrXhlbCBtb2RlbG8gZGUgZWxldmHDp8OjbyBkaWdpdGFsIChERU0pLiBBIGluY2xpbmHDp8OjbyByZXByZXNlbnRhIG8gZGVjbGl2ZSBkYSBzdXBlcmbDrWNpZSBlIMOpIHNpbWJvbGl6YWRhIGF0cmF2w6lzIGRlIHRyw6pzIGNsYXNzZXMgcXVlIHPDo28gZXhpYmlkYXMgdXRpbGl6YW5kbyBhIHNhdHVyYcOnw6NvIGRhIGNvciAoYnJpbGhvKS48ZGl2Pjxici8+T3MgdmFsb3JlcyBkZSBww614ZWlzIG5vIHJhc3RlciBkZSBhc3BldG8taW5jbGluYcOnw6NvIGRlIHNhw61kYSByZWZsZXRlbSB1bWEgY29tYmluYcOnw6NvIGRlIGFzcGV0byBlIGluY2xpbmHDp8Ojby4gUMOteGVpcyBjb20gdmFsb3JlcyBpbmZlcmlvcmVzIGEgMjAgc8OjbyBjb25zaWRlcmFkb3MgcGxhbm9zIGUgc8OjbyBleGliaWRvcyBhIGNpbnplbnRvLiBPcyB2YWxvcmVzIGRlIGFzcGV0by1pbmNsaW5hw6fDo28gaWd1YWlzIGUgc3VwZXJpb3JlcyBhIDIxIHNlcsOjbyBhcHJlc2VudGFkb3MgY29tIHNhdHVyYcOnw7VlcyB2YXJpw6F2ZWlzIGRhIHNlZ3VpbnRlIGZvcm1hOiAyMSBhIDMwIOKAlEJhaXhhIHNhdHVyYcOnw6NvIGRlIGluY2xpbmHDp8OjbywgMzEgYSA0MOKAlFNhdHVyYcOnw6NvIGRlIGluY2xpbmHDp8OjbyBtb2RlcmFkYSwgaWd1YWwgZSBzdXBlcmlvciBhIDQx4oCUQWx0YSBzYXR1cmHDp8OjbyBkZSBpbmNsaW5hw6fDo288L2Rpdj5cIixcblx0XHRhc3BlY3ROYW1lOiBcIkFzcGV0b1wiLFxuXHRcdGFzcGVjdFNuaXA6IFwiTW9zdHJhIGVtIHF1ZSBkaXJlw6fDo28gdW0gcMOteGVsIGVzdMOhIG9yaWVudGFkbywgb25kZSAwIMOpIHBhcmEgbm9ydGUgZSBvcyDDom5ndWxvcyBhdW1lbnRhbSBhdMOpIDM2MCBubyBzZW50aWRvIGRvcyBwb250ZWlyb3MgZG8gcmVsw7NnaW8uXCIsXG5cdFx0YXNwZWN0RGVzYzogXCJBIGZ1bsOnw6NvIEFzcGV0byBpZGVudGlmaWNhIGEgZGlyZcOnw6NvIGRlIGluY2xpbmHDp8OjbyBkYSB0YXhhIGRlIHZhcmlhw6fDo28gbcOheGltYSBlbSB2YWxvciBlbnRyZSBjYWRhIGPDqWx1bGEgZSBvcyBzZXVzIHZpemluaG9zLiBPIGFzcGV0byBwb2RlIHNlciB2aXN0byBjb21vIGEgZGlyZcOnw6NvIGRhIGluY2xpbmHDp8Ojby4gT3MgdmFsb3JlcyBkbyByYXN0ZXIgZGUgc2HDrWRhIHNlcsOjbyBhIGRpcmXDp8OjbyBkYSBiw7pzc29sYSBkbyBhc3BldG8uPGRpdj48YnIvPkEgZW50cmFkYSBkZXN0YSBmdW7Dp8OjbyDDqSBSYXN0ZXIgZGUgRW50cmFkYS4gQSBmdW7Dp8OjbyBBc3BldG8gw6kgbXVpdGFzIHZlemVzIGFwbGljYWRhIGEgdW0gbW9kZWxvIGRlIGVsZXZhw6fDo28gZGlnaXRhbCAoREVNKS4gUG9yIGRlZmVpdG8gbyBhc3BldG8gYXBhcmVjZSBjb21vIHVtYSBlc2NhbGEgZGUgY2luemVudG9zLiDDiSBwb3Nzw612ZWwgYWRpY2lvbmFyIGEgZnVuw6fDo28gTWFwYSBkZSBDb3JlcyBwYXJhIGVzcGVjaWZpY2FyIHVtIGVzcXVlbWEgZGUgY29yZXMgcGFydGljdWxhciBvdSBwZXJtaXRpciBxdWUgYSBwZXNzb2EgcXVlIGVzdMOhIGEgdmlzdWFsaXphciBvIG1vc2FpY28gcG9zc2EgbW9kaWZpY2FyIGEgc2ltYm9sb2dpYSBjb20gbyBzZXUgcHLDs3ByaW8gZXNxdWVtYSBkZSBjb3Jlcy48L2Rpdj5cIixcblx0XHR0YWJsZU5hbWU6IFwiVGFiZWxhIGRlIEF0cmlidXRvc1wiLFxuXHRcdHRhYmxlU25pcDogXCJVdGlsaXphIHVtYSB0YWJlbGEgcGFyYSBkZXNpZ25hciBlIHNpbWJvbGl6YXIgb3MgdmFsb3JlcyBudW0gY29uanVudG8gZGUgZGFkb3MuIEFzIGNvbHVuYXMgZGEgdGFiZWxhIHPDo28gZGVsaW1pdGFkYXMgcG9yIHbDrXJndWxhczogUGl4ZWxWYWx1ZSwgQXR0cmlidXRlTmFtZSwgUmVkVmFsdWUsIEdyZWVuVmFsdWUsIEJsdWVWYWx1ZS5cIixcblx0XHR0YWJsZURlc2M6IFwiQSBmdW7Dp8OjbyBUYWJlbGEgZGUgQXRyaWJ1dG9zIHBlcm1pdGUgZGVmaW5pciB1bWEgdGFiZWxhIGRlIGF0cmlidXRvcyBwYXJhIHNpbWJvbGl6YXIgdW0gY29uanVudG8gZGUgZGFkb3MgZW0gbW9zYWljbyBkZSBiYW5kYS3Dum5pY2Egb3UgdW0gY29uanVudG8gZGUgZGFkb3MgZGUgdW0gcmFzdGVyLiA8ZGl2Pjxici8+SXN0byDDqSDDunRpbCBxdWFuZG8gcHJldGVuZGUgYXByZXNlbnRhciBpbWFnZW5zIHF1ZSB0ZW5oYW0gc2lkbyBzdWJtZXRpZGFzIGEgdW1hIGNsYXNzaWZpY2HDp8OjbyBkZSB1c28gZG8gc29sbywgdGFsIGNvbW8gdGVycmVubyBmbG9yZXN0YWwsIHpvbmFzIGjDum1pZGFzLCB0ZXJyYXMgZGUgY3VsdGl2byBlIHVyYmFuby4gQWRpY2lvbmFsbWVudGUsIHNlIGEgdGFiZWxhIGNvbnRpdmVyIGNhbXBvcyBkZXNpZ25hZG9zIGRlIHZlcm1lbGhvLCB2ZXJkZSBlIGF6dWwsIGFvIHJlcHJvZHV6aXIgYSBpbWFnZW0sIG9zIHZhbG9yZXMgZGVudHJvIGRlc3RlcyBjYW1wb3Mgc2Vyw6NvIHV0aWxpemFkb3MgY29tbyB1bSBtYXBhIGRlIGNvcmVzLjwvZGl2PlwiLFxuXHRcdGJhbmRBcml0aG1ldGljTmFtZTogXCJBcml0bcOpdGljYSBkYSBCYW5kYVwiLFxuXHRcdGJhbmRBcml0aG1ldGljU25pcDogXCJDYWxjdWxhIMOtbmRpY2VzIHV0aWxpemFuZG8gZsOzcm11bGFzIHByZWRlZmluaWRhcyBvdSBleHByZXNzw7VlcyBkZWZpbmlkYXMgcGVsbyB1dGlsaXphZG9yLlwiLFxuXHRcdGJhbmRBcml0aG1ldGljRGVzYzogXCJBIGZ1bsOnw6NvIEJhbmRhIEFyaXRtw6l0aWNhIGV4ZWN1dGEgdW1hIG9wZXJhw6fDo28gYXJpdG3DqXRpY2EgbmFzIGJhbmRhcyBkbyBjb25qdW50byBkZSBkYWRvcyBkZSB1bSByYXN0ZXIuIE8gdXRpbGl6YWRvciBwb2RlIGVzY29saGVyIGFsZ29yaXRtb3MgcHJlZGVmaW5pZG9zIG91IGludHJvZHV6aXIgYSBzdWEgcHLDs3ByaWEgZsOzcm11bGEgZGUgdW1hIGxpbmhhLiBPcyBvcGVyYWRvcmVzIHN1cG9ydGFkb3Mgc8OjbyAtLCssLywqIGUgdW7DoXJpbyAtLlwiLFxuXHRcdHRocmVzaG9sZE5hbWU6IFwiTGltaXRlIEJpbsOhcmlvXCIsXG5cdFx0dGhyZXNob2xkU25pcDogXCJPcmdhbml6YSBvcyBkYWRvcyBjb250w61udW9zIGVudHJlIHByaW1laXJvIHBsYW5vIGUgZnVuZG8gbWluaW1pemFuZG8gYSBjb3ZhcmnDom5jaWEgZW50cmUgYXMgZHVhcyBjbGFzc2VzLlwiLFxuXHRcdHRocmVzaG9sZERlc2M6IFwiUXVhbmRvIHVtIGNvbmp1bnRvIGRlIGRhZG9zIHJhc3RlciB0ZW0gdW1hIGRpc3RyaWJ1acOnw6NvIGJpbW9kYWwsIGVzdGEgZnVuw6fDo28gY3JpYSB1bSBub3ZvIHJhc3RlciwgcXVlIGRpdmlkZSBvcyBkYWRvcyBlbSBkdWFzIGNsYXNzZXMgZGlmZXJlbnRlcy4gQ3JpYSB1bWEgY2xhc3NlIGRlIHZhbG9yZXMgYmFpeG9zIGV4aWJpZGEgY29tIHDDrXhlaXMgcHJldG9zIGUgdW1hIGNsYXNzZSBkZSB2YWxvcmVzIGVsZXZhZG9zIGV4aWJpZGEgY29tIHDDrXhlaXMgYnJhbmNvcy5cIixcblx0XHRiaXR3aXNlQW5kTmFtZTogXCJCaXR3aXNlIEVcIixcblx0XHRiaXR3aXNlQW5kU25pcDogXCJFeGVjdXRhIHVtYSBvcGVyYcOnw6NvIEJpdHdpc2UgRSBub3MgdmFsb3JlcyBiaW7DoXJpb3MgZGUgZG9pcyByYXN0ZXJzIGRlIGVudHJhZGEuXCIsXG5cdFx0Yml0d2lzZUFuZERlc2M6IFwiQml0d2lzZSBFIGV4ZWN1dGEgdW1hIG9wZXJhw6fDo28gQml0d2lzZSBFIG5vcyB2YWxvcmVzIGJpbsOhcmlvcyBkZSBkb2lzIHJhc3RlcnMgZGUgZW50cmFkYVwiLFxuXHRcdGJpdHdpc2VMZWZ0U2hpZnROYW1lOiBcIkJpdHdpc2UgRXNxdWVyZGEgU2hpZnRcIixcblx0XHRiaXR3aXNlTGVmdFNoaWZ0U25pcDogXCJFeGVjdXRhIHVtYSBvcGVyYcOnw6NvIEJpdHdpc2UgRGVzbG9jYW1lbnRvIMOgIEVzcXVlcmRhIG5vcyB2YWxvcmVzIGJpbsOhcmlvcyBkZSBkb2lzIHJhc3RlcnMgZGUgZW50cmFkYS5cIixcblx0XHRiaXR3aXNlTGVmdFNoaWZ0RGVzYzogXCJBIEJpdHdpc2UgRGVzbG9jYW1lbnRvIMOgIEVzcXVlcmRhIGV4ZWN1dGEgdW1hIG9wZXJhw6fDo28gQml0d2lzZSBEZXNsb2NhbWVudG8gw6AgRXNxdWVyZGEgbm9zIHZhbG9yZXMgYmluw6FyaW9zIGRlIGRvaXMgcmFzdGVycyBkZSBlbnRyYWRhXCIsXG5cdFx0Yml0d2lzZU5vdE5hbWU6IFwiQml0d2lzZSBOw6NvXCIsXG5cdFx0Yml0d2lzZU5vdFNuaXA6IFwiRXhlY3V0YSB1bWEgb3BlcmHDp8OjbyBCaXR3aXNlIE7Do28gbm9zIHZhbG9yZXMgYmluw6FyaW9zIGRlIGRvaXMgcmFzdGVycyBkZSBlbnRyYWRhLlwiLFxuXHRcdGJpdHdpc2VOb3REZXNjOiBcIkEgZnVuw6fDo28gZXhlY3V0YSB1bWEgb3BlcmHDp8OjbyBCaXR3aXNlIE7Do28gKGNvbXBsZW1lbnRvKSBub3MgdmFsb3JlcyBiaW7DoXJpb3MgZGUgdW0gcmFzdGVyIGRlIGVudHJhZGEuXCIsXG5cdFx0Yml0d2lzZU9yTmFtZTogXCJCaXR3aXNlIE91XCIsXG5cdFx0Yml0d2lzZU9yU25pcDogXCJFeGVjdXRhIHVtYSBvcGVyYcOnw6NvIEJpdHdpc2UgT3Ugbm9zIHZhbG9yZXMgYmluw6FyaW9zIGRlIGRvaXMgcmFzdGVycyBkZSBlbnRyYWRhLlwiLFxuXHRcdGJpdHdpc2VPckRlc2M6IFwiQSBmdW7Dp8OjbyBleGVjdXRhIHVtYSBvcGVyYcOnw6NvIEJpdHdpc2UgT3Ugbm9zIHZhbG9yZXMgYmluw6FyaW9zIGRlIGRvaXMgcmFzdGVycyBkZSBlbnRyYWRhLiBcIixcblx0XHRiaXR3aXNlUmlnaHRTaGlmdE5hbWU6IFwiQml0d2lzZSBEaXJlaXRhIFNoaWZ0XCIsXG5cdFx0Yml0d2lzZVJpZ2h0U2hpZnRTbmlwOiBcIkV4ZWN1dGEgdW1hIG9wZXJhw6fDo28gQml0d2lzZSBEZXNsb2NhbWVudG8gw6AgRGlyZWl0YSBub3MgdmFsb3JlcyBiaW7DoXJpb3MgZGUgZG9pcyByYXN0ZXJzIGRlIGVudHJhZGEuXCIsXG5cdFx0Yml0d2lzZVJpZ2h0U2hpZnREZXNjOiBcIkEgZnVuw6fDo28gZXhlY3V0YSB1bWEgb3BlcmHDp8OjbyBCaXR3aXNlIERlc2xvY2FtZW50byDDoCBEaXJlaXRhIG5vcyB2YWxvcmVzIGJpbsOhcmlvcyBkZSBkb2lzIHJhc3RlcnMgZGUgZW50cmFkYS5cIixcblx0XHRiaXR3aXNlWG9yTmFtZTogXCJCaXR3aXNlIFhvdVwiLFxuXHRcdGJpdHdpc2VYb3JTbmlwOiBcIkV4ZWN1dGEgdW1hIG9wZXJhw6fDo28gQml0d2lzZSBPdSBlWGNsdXNpdm8gbm9zIHZhbG9yZXMgYmluw6FyaW9zIGRlIGRvaXMgcmFzdGVycyBkZSBlbnRyYWRhLlwiLFxuXHRcdGJpdHdpc2VYb3JEZXNjOiBcIkEgZnVuw6fDo28gZXhlY3V0YSB1bWEgb3BlcmHDp8OjbyBCaXR3aXNlIE91IGVYY2x1c2l2byBub3MgdmFsb3JlcyBiaW7DoXJpb3MgZGUgZG9pcyByYXN0ZXJzIGRlIGVudHJhZGFcIixcblx0XHRib29sZWFuQW5kTmFtZTogXCJCb29sZWFubyBFXCIsXG5cdFx0Ym9vbGVhbkFuZFNuaXA6IFwiRXhlY3V0YSB1bWEgb3BlcmHDp8OjbyBib29sZWFuYSBFIG5vcyB2YWxvcmVzIGRhcyBjw6lsdWxhcyBkZSBkb2lzIHJhc3RlcnMgZGUgZW50cmFkYS4gU2UgYW1ib3Mgb3MgdmFsb3JlcyBkZSBlbnRyYWRhIGZvcmVtIHZlcmRhZGVpcm9zIChkaWZlcmVudGVzIGRlIHplcm8pLCBlbnTDo28sIG8gdmFsb3IgZGUgc2HDrWRhIMOpIDEuIFNlIGFsZ3VtIG91IGFtYm9zIGFzIGVudHJhZGFzIGZvcmVtIGZhbHNvcyAoemVybyksIGVudMOjbywgYSBzYcOtZGEgw6kgMC5cIixcblx0XHRib29sZWFuQW5kRGVzYzogXCJBIGZ1bsOnw6NvIGV4ZWN1dGEgdW1hIG9wZXJhw6fDo28gYm9vbGVhbmEgRSBub3MgdmFsb3JlcyBkZSBww614ZWwgZGUgZHVhcyBlbnRyYWRhcy4gU2UgYW1ib3Mgb3MgdmFsb3JlcyBkZSBlbnRyYWRhIGZvcmVtIHZlcmRhZGVpcm9zIChkaWZlcmVudGVzIGRlIHplcm8pLCBlbnTDo28sIG8gdmFsb3IgZGUgc2HDrWRhIMOpIDEuIFNlIGFsZ3VtIG91IGFtYm9zIG9zIHZhbG9yZXMgZGUgZW50cmFkYSBmb3JlbSBmYWxzb3MgKHplcm8pLCBlbnTDo28sIG8gdmFsb3IgZGUgc2HDrWRhIMOpIDAuIFwiLFxuXHRcdGJvb2xlYW5Ob3ROYW1lOiBcIkJvb2xlYW5vIE7Do29cIixcblx0XHRib29sZWFuTm90U25pcDogXCJFeGVjdXRhIHVtYSBvcGVyYcOnw6NvIGJvb2xlYW5hIE7Do28gKGNvbXBsZW1lbnRvKSBub3MgdmFsb3JlcyBkYXMgY8OpbHVsYXMgZG8gcmFzdGVyIGRlIGVudHJhZGEuIFNlIG9zIHZhbG9yZXMgZGUgZW50cmFkYSBmb3JlbSB2ZXJkYWRlaXJvcyAoZGlmZXJlbnRlcyBkZSB6ZXJvKSwgZW50w6NvLCBvIHZhbG9yIGRlIHNhw61kYSDDqSAwLiBTZSBhbGd1bSBvdSBhbWJvcyBvcyB2YWxvcmVzIGRlIGVudHJhZGEgZm9yZW0gZmFsc29zICh6ZXJvKSwgZW50w6NvLCBvIHZhbG9yIGRlIHNhw61kYSDDqSAxLlwiLFxuXHRcdGJvb2xlYW5Ob3REZXNjOiBcIkEgZnVuw6fDo28gZXhlY3V0YSB1bWEgb3BlcmHDp8OjbyBib29sZWFuYSBOw6NvIChjb21wbGVtZW50bykgbm9zIHZhbG9yZXMgZGUgcMOteGVsIGRvIHJhc3RlciBkZSBlbnRyYWRhLiBTZSBvcyB2YWxvcmVzIGRlIGVudHJhZGEgZm9yZW0gdmVyZGFkZWlyb3MgKGRpZmVyZW50ZXMgZGUgemVybyksIGVudMOjbywgbyB2YWxvciBkZSBzYcOtZGEgw6kgMC4gU2UgYWxndW0gb3UgYW1ib3Mgb3MgdmFsb3JlcyBkZSBlbnRyYWRhIGZvcmVtIGZhbHNvcyAoemVybyksIGVudMOjbywgbyB2YWxvciBkZSBzYcOtZGEgw6kgMS5cIixcblx0XHRib29sZWFuT3JOYW1lOiBcIkJvb2xlYW5vIE91XCIsXG5cdFx0Ym9vbGVhbk9yU25pcDogXCJFeGVjdXRhIHVtYSBvcGVyYcOnw6NvIGJvb2xlYW5hIE91IG5vcyB2YWxvcmVzIGRhcyBjw6lsdWxhcyBkZSBkb2lzIHJhc3RlcnMgZGUgZW50cmFkYS4gU2UgYWxndW0gb3UgYW1ib3Mgb3MgdmFsb3JlcyBkZSBlbnRyYWRhIGZvcmVtIHZlcmRhZGVpcm9zIChkaWZlcmVudGVzIGRlIHplcm8pLCBlbnTDo28sIG8gdmFsb3IgZGUgc2HDrWRhIMOpIDEuIFNlIGFtYm9zIG9zIHZhbG9yZXMgZGUgZW50cmFkYSBmb3JlbSBmYWxzb3MgKHplcm8pLCBlbnTDo28sIG8gdmFsb3IgZGUgc2HDrWRhIMOpIDAuXCIsXG5cdFx0Ym9vbGVhbk9yRGVzYzogXCJBIGZ1bsOnw6NvIGV4ZWN1dGEgdW1hIG9wZXJhw6fDo28gYm9vbGVhbmEgT3Ugbm9zIHZhbG9yZXMgZGFzIGPDqWx1bGFzIGRlIGRvaXMgcmFzdGVycyBkZSBlbnRyYWRhLiBTZSBhbGd1bSBvdSBhbWJvcyBvcyB2YWxvcmVzIGRlIGVudHJhZGEgZm9yZW0gdmVyZGFkZWlyb3MgKGRpZmVyZW50ZXMgZGUgemVybyksIGVudMOjbywgbyB2YWxvciBkZSBzYcOtZGEgw6kgMS4gU2UgYW1ib3Mgb3MgdmFsb3JlcyBkZSBlbnRyYWRhIGZvcmVtIGZhbHNvcyAoemVybyksIGVudMOjbywgbyB2YWxvciBkZSBzYcOtZGEgw6kgMC5cIixcblx0XHRib29sZWFuWG9yTmFtZTogXCJCb29sZWFubyBYb3JcIixcblx0XHRib29sZWFuWG9yU25pcDogXCJFeGVjdXRhIHVtYSBvcGVyYcOnw6NvIGJvb2xlYW5hIE91IGVYY2x1c2l2byBub3MgdmFsb3JlcyBkYXMgY8OpbHVsYXMgZGUgZG9pcyByYXN0ZXJzIGRlIGVudHJhZGEuIFNlIHVtIHZhbG9yIGRlIGVudHJhZGEgZm9yIHZlcmRhZGVpcm8gKGRpZmVyZW50ZSBkZSB6ZXJvKSBlIG8gb3V0cm8gZm9yIGZhbHNvICh6ZXJvKSwgZW50w6NvLCBvIHZhbG9yIGRlIHNhw61kYSDDqSAxLiBTZSBhbWJvcyBvcyB2YWxvcmVzIGRlIGVudHJhZGEgZm9yZW0gdmVyZGFkZWlyb3Mgb3UgYW1ib3MgZmFsc29zLCBlbnTDo28sIG8gdmFsb3IgZGUgc2HDrWRhIMOpIDAuXCIsXG5cdFx0Ym9vbGVhblhvckRlc2M6IFwiQSBmdW7Dp8OjbyBleGVjdXRhIHVtYSBvcGVyYcOnw6NvIGJvb2xlYW5hIE91IGVYY2x1c2l2byBub3MgdmFsb3JlcyBkYXMgY8OpbHVsYXMgZGUgZG9pcyByYXN0ZXJzIGRlIGVudHJhZGEuIFNlIHVtIHZhbG9yIGRlIGVudHJhZGEgZm9yIHZlcmRhZGVpcm8gKGRpZmVyZW50ZSBkZSB6ZXJvKSBlIG8gb3V0cm8gZm9yIGZhbHNvICh6ZXJvKSwgZW50w6NvLCBvIHZhbG9yIGRlIHNhw61kYSDDqSAxLiBTZSBhbWJvcyBvcyB2YWxvcmVzIGRlIGVudHJhZGEgZm9yZW0gdmVyZGFkZWlyb3Mgb3UgYW1ib3MgZmFsc29zLCBlbnTDo28sIG8gdmFsb3IgZGUgc2HDrWRhIMOpIDAuXCIsXG5cdFx0YnVmZmVyZWRSYXN0ZXJOYW1lOiBcIkFtb3J0ZWNpZG9cIixcblx0XHRidWZmZXJlZFJhc3RlclNuaXA6IFwiQW1vcnRlY2UgbyDDumx0aW1vIGJsb2NvKHMpIGRlIHDDrXhlbCBhY2VkaWRvLlwiLFxuXHRcdGJ1ZmZlcmVkUmFzdGVyRGVzYzogXCJBIGZ1bsOnw6NvIEFtb3J0ZWNpbWVudG8gw6kgdXRpbGl6YWRhIHBhcmEgb3RpbWl6YXIgYSBwZXJmb3JtYW5jZSBkZSBjYWRlaWFzIGRlIGZ1bsOnw7VlcyBjb21wbGV4YXMuIEd1YXJkYSBhIHNhw61kYSBuYSBtZW3Ds3JpYSBkYSBwYXJ0ZSBkYSBjYWRlaWEgZGEgZnVuw6fDo28gcXVlIHZlbSBhbnRlcmlvcm1lbnRlLiA8ZGl2Pjxici8+SW5zaXJhIGVzdGEgZnVuw6fDo28gbm8gRWRpdG9yIGRlIEZ1bsOnw7VlcyBvbmRlIHByZXRlbmRlciBhcm1hemVuYXIgYSBzYcOtZGEuPC9kaXY+XCIsXG5cdFx0cmFzdGVyQ2FsY3VsYXRvck5hbWU6IFwiQ2FsY3VsYWRvcmFcIixcblx0XHRyYXN0ZXJDYWxjdWxhdG9yU25pcDogXCJDYWxjdWxhIHVtIHJhc3RlciBhIHBhcnRpciBkZSB1bWEgZXhwcmVzc8OjbyBtYXRlbcOhdGljYSBiYXNlYWRhIG51bSByYXN0ZXIuXCIsXG5cdFx0cmFzdGVyQ2FsY3VsYXRvckRlc2M6IFwiQSBmdW7Dp8OjbyBDYWxjdWxhZG9yYSBwZXJtaXRlIGNyaWFyIGUgY29ycmVyIGV4cHJlc3PDtWVzIGUgaW5jb3Jwb3LDoS1sYXMgbmFzIGNhZGVpYXMgZGUgZnVuw6fDtWVzLlwiLFxuXHRcdGNlbGxTdGF0aXN0aWNzTmFtZTogXCJFc3RhdMOtc3RpY2EgQ2VsdWxhclwiLFxuXHRcdGNlbGxTdGF0aXN0aWNzU25pcDogXCJDYWxjdWxhIGVzdGF0w61zdGljYXMgZGUgbcO6bHRpcGxvcyByYXN0ZXJzIHBvciBjw6lsdWxhLiBBcyBlc3RhdMOtc3RpY2FzIGRpc3BvbsOtdmVpcyBzw6NvIE1haW9yaWEsIE3DoXhpbW8sIE3DqWRpYSwgTWVkaWFuYSwgTcOtbmltbywgTWlub3JpYSwgUGVyY2VudGlsLCBJbnRlcnZhbG8sIERlc3ZpbyBQYWRyw6NvLCBTb21hIGUgVmFyaWVkYWRlLlwiLFxuXHRcdGNlbGxTdGF0aXN0aWNzRGVzYzogXCJFc3RhIGZ1bsOnw6NvIGV4ZWN1dGEgY8OhbGN1bG9zIGRlIEVzdGF0w61zdGljYSBkZSBtw7psdGlwbG9zIHJhc3RlcnMsIG51bWEgYmFzZSBkZSBww614ZWwgYSBww614ZWwuIEFzIGVzdGF0w61zdGljYXMgZGlzcG9uw612ZWlzIHPDo28gYSBtYWlvcmlhLCBtw6F4aW1vLCBtw6lkaWEsIG1lZGlhbmEsIG3DrW5pbW8sIG1pbm9yaWEsIGludGVydmFsbywgZGVzdmlvIHBhZHLDo28sIHNvbWEgZSB2YXJpZWRhZGUuXCIsXG5cdFx0Y2xhc3NpZnlOYW1lOiBcIkNsYXNzaWZpY2FyXCIsXG5cdFx0Y2xhc3NpZnlTbmlwOiBcIkF0cmlidWkgY2FkYSBww614ZWwgYSB1bWEgY2xhc3NlLiBJbmNvcnBvcmEgZGFkb3MgYXV4aWxpYXJlcywgdGFpcyBjb21vIHVtYSBpbWFnZW0gc2VnbWVudGFkYS5cIixcblx0XHRjbGFzc2lmeURlc2M6IFwiRXN0YSBmdW7Dp8OjbyByYXN0ZXIgY2xhc3NpZmljYSB1bSBjb25qdW50byBkZSBkYWRvcyByYXN0ZXIgYmFzZWFkbyBudW0gZmljaGVpcm8gRXNyaSBDbGFzc2lmaWVyIERlZmluaXRpb24gKC5lY2QpIGUgbnVtIGNvbmp1bnRvIGRlIGRhZG9zIHJhc3RlciBkZSB2YWxvcmVzIGRlIGVudHJhZGEuIE8gZmljaGVpcm8gLmVjZCB1dGlsaXphZG8gbmEgZnVuw6fDo28gQ2xhc3NpZmljYcOnw6NvIGNvbnTDqW0gdG9kYSBhIGluZm9ybWHDp8OjbyBwYXJhIHVtIGNvbmp1bnRvIGRlIGRhZG9zIGVzcGVjw61maWNvIGUgY2xhc3NpZmljYWRvciBlIMOpIGdlcmFkbyBwZWxhcyBmZXJyYW1lbnRhcyBkZSB0cmVpbm8gZGUgY2xhc3NpZmljYcOnw6NvLCB0YWlzIGNvbW8gbyBUcmFpbiBTdXBwb3J0IFZlY3RvciBNYWNoaW5lIG91IGFzIGZlcnJhbWVudGFzIFRyYWluIFJhbmRvbSBUcmVlcy5cIixcblx0XHRjbGlwTmFtZTogXCJSZWNvcnRhclwiLFxuXHRcdGNsaXBTbmlwOiBcIkRlZmluZSBhcyBtZWRpZGFzIGRlIHVtIHJhc3RlciB1dGlsaXphbmRvIGNvb3JkZW5hZGFzIG91IG91dHJvIGNvbmp1bnRvIGRlIGRhZG9zLlwiLFxuXHRcdGNsaXBEZXNjOiBcIkVzdGEgZnVuw6fDo28gcmVjb3J0YSB1bSByYXN0ZXIgdXRpbGl6YW5kbyB1bWEgZm9ybWEgcmV0YW5ndWxhciBzZWd1bmRvIGFzIG1lZGlkYXMgZGVmaW5pZGFzIG91LCBlbnTDo28sIHZhaSByZWNvcnRhciB1bSByYXN0ZXIgc2VndW5kbyBhIGZvcm1hIGRhIGNsYXNzZSBkZSBjYXJhdGVyw61zdGljYXMgZGUgdW0gcG9sw61nb25vIGRlIGVudHJhZGEuIEEgZm9ybWEgcXVlIGRlZmluZSBvIHJlY29ydGUgcG9kZSByZWNvcnRhciBhcyBtZWRpZGFzIGRvIHJhc3RlciBvdSByZWNvcnRhciB1bWEgw6FyZWEgZGVudHJvIGRvIHJhc3Rlci5cIixcblx0XHRjb2xvcnNwYWNlQ29udmVyc2lvbk5hbWU6IFwiQ29udmVyc8OjbyBkbyBNb2RlbG8gZGUgQ29yZXNcIixcblx0XHRjb2xvcnNwYWNlQ29udmVyc2lvblNuaXA6IFwiQ29udmVydGUgdW0gcmFzdGVyIGRlIFJHQiBwYXJhIEhTViBlIHZpY2UtdmVyc2EuXCIsXG5cdFx0Y29sb3JzcGFjZUNvbnZlcnNpb25EZXNjOiBcIkEgZnVuw6fDo28gQ29udmVyc8OjbyBkZSBNb2RlbG8gZGUgQ29yZXMgY29udmVydGUgbyBtb2RlbG8gZGUgY29yZXMgZGUgdW1hIGltYWdlbSBkZSB0b25hbGlkYWRlLCBzYXR1cmHDp8OjbyBlIHZhbG9yIChIU1YpIGRlIGVzcGHDp28gY29yIHBhcmEgdmVybWVsaG8sIHZlcmRlIGUgYXp1bCAoUkdCKSBvdSB2aWNlLXZlcnNhLjxkaXY+PGJyLz5Fc3RhIGZ1bsOnw6NvIHBvZGUgc2VyIHV0aWxpemFkYSBudW0gY29uanVudG8gZGUgZGFkb3MgZGUgbW9zYWljby48L2Rpdj5cIixcblx0XHRjb2xvcm1hcFRvUkdCTmFtZTogXCJNYXBhIGRlIENvcmVzIHBhcmEgUkdCXCIsXG5cdFx0Y29sb3JtYXBUb1JHQlNuaXA6IFwiQ29udmVydGUgdW0gcmFzdGVyIGRlIGJhbmRhLcO6bmljYSBjb20gdW0gbWFwYSBkZSBjb3JlcyBudW0gcmFzdGVyIGRlIHRyw6pzIGJhbmRhcyAodmVybWVsaG8sIHZlcmRlIGUgYXp1bCkuXCIsXG5cdFx0Y29sb3JtYXBUb1JHQkRlc2M6IFwiRXN0YSBmdW7Dp8OjbyBjb252ZXJ0ZSB1bSByYXN0ZXIgZGUgYmFuZGEtw7puaWNhIGNvbSB1bSBtYXBhIGRlIGNvcmVzIHBhcmEgdW0gcmFzdGVyIGRlIHRyw6pzIGJhbmRhcyAodmVybWVsaG8sIHZlcmRlIGUgYXp1bCkuPGRpdj48YnIvPkVzdGEgZnVuw6fDo28gw6kgw7p0aWwgcXVhbmRvIG5lY2Vzc2l0YXIgZGUgY3JpYXIgdW0gcmFzdGVyIGRlIHRyw6pzIGJhbmRhcyBhIHBhcnRpciBkZSB1bSByYXN0ZXIgZGUgYmFuZGEgw7puaWNhIGNvbSB1bSBtYXBhIGRlIGNvciBhc3NvY2lhZG8uIE9zIHZhbG9yZXMgbm8gbWFwYSBkZSBjb3JlcyBzZXLDo28gdXRpbGl6YWRvcyBwYXJhIGNyaWFyIGNhZGEgYmFuZGEgdmVybWVsaGEsIHZlcmRlIGUgYXp1bC4gRXN0YSBmdW7Dp8OjbyBwb2RlIHNlciB1dGlsaXphZGEgbnVtIGNvbmp1bnRvIGRlIGRhZG9zIGVtIG1vc2FpY28uPC9kaXY+XCIsXG5cdFx0Y29sb3JtYXBOYW1lOiBcIk1hcGEgZGUgQ29yZXNcIixcblx0XHRjb2xvcm1hcFNuaXA6IFwiTW9kaWZpY2Egb3MgdmFsb3JlcyBkb3MgcMOteGVpcyBwYXJhIGV4aWJpciBvcyBkYWRvcyByYXN0ZXIgb3UgY29tbyB1bWEgZXNjYWxhIGRlIGNpbnplbnRvcyBvdSBjb21vIHVtYSBpbWFnZW0gdmVybWVsaGEsIHZlcmRlIGUgYXp1bCAoUkdCKSBiYXNlYWRhIG51bSBtYXBhIG91IG51bWEgcmFtcGEgZGUgY29yZXMuXCIsXG5cdFx0Y29sb3JtYXBEZXNjOiBcIkEgZnVuw6fDo28gTWFwYSBkZSBDb3JlcyDDqSB1bSB0aXBvIGRlIHJlbmRlcml6YWRvciBkZSBkYWRvcyByYXN0ZXIuIFRyYW5zZm9ybWEgb3MgdmFsb3JlcyBkbyBww614ZWwgcGFyYSBleGliaXIgb3MgZGFkb3MgZG8gcmFzdGVyIGNvbW8gdW1hIGltYWdlbSBuYSBlc2NhbGEgZGUgY2luemVudG9zIG91IGNvbW8gdW1hIGltYWdlbSBSR0IgYmFzZWFkYSBudW0gZXNxdWVtYSBkZSBjb3JlcyBvdSBudW0gZmljaGVpcm8gZGUgbWFwYSBkZSBjb3Jlcy4gw4kgcG9zc8OtdmVsIHV0aWxpemFyIHVtIG1hcGEgZGUgY29yZXMgcGFyYSByZXByZXNlbnRhciBkYWRvcyBhbmFsaXNhZG9zLCB0YWwgY29tbyB1bWEgaW1hZ2VtIGNsYXNzaWZpY2FkYSBvdSBhbyBleGliaXIgdW0gbWFwYSB0b3BvZ3LDoWZpY28gKG91IG8gw61uZGljZSBkZSB1bWEgaW1hZ2VtIGRlIGNvciBkaWdpdGFsaXphZGEpLjxkaXY+PGJyLz5PcyBtYXBhcyBkZSBjb3IgY29udMOqbSB1bSBjb25qdW50byBkZSB2YWxvcmVzIHF1ZSBlc3TDo28gYXNzb2NpYWRvcyBhIGNvcmVzIHV0aWxpemFkYXMgcGFyYSBleGliaXIgdW0gcmFzdGVyIGRlIGJhbmRhIMO6bmljYSBjb25zaXN0ZW50ZW1lbnRlIGNvbSBhcyBtZXNtYXMgY29yZXMuIENhZGEgdmFsb3IgZGUgcMOteGVsIGVzdMOhIGFzc29jaWFkbyBhIHVtYSBjb3IgZGVmaW5pZGEgY29tbyB1bSBjb25qdW50byBkZSB2YWxvcmVzIFJHQi4gT3MgbWFwYXMgZGUgY29yZXMgc8OjbyBjYXBhemVzIGRlIHN1cG9ydGFyIHF1YWxxdWVyIHByb2Z1bmRpZGFkZSBkZSBiaXQgY29tIGEgZXhjZcOnw6NvIGRlIHBvbnRvIGZsdXR1YW50ZS4gSWd1YWxtZW50ZSwgc3Vwb3J0YW0gdmFsb3JlcyBwb3NpdGl2b3MgZSBuZWdhdGl2b3MgZSBwb2RlbSBjb250ZXIgdmFsb3JlcyBlbSBmYWx0YSBkZSBtYXBhIGRlIGNvcmVzLiBBbyBleGliaXIgdW0gY29uanVudG8gZGUgZGFkb3MgY29tIHVtIG1hcGEgZGUgY29yZXMgY29udGVuZG8gdmFsb3JlcyBlbSBmYWx0YSwgb3MgcMOteGVpcyBjb20gZXNzZXMgdmFsb3JlcyBlbSBmYWx0YSBuw6NvIHNlcsOjbyBleGliaWRvcy48L2Rpdj5cIixcblx0XHRjb21wbGV4TmFtZTogXCJDb21wbGV4b1wiLFxuXHRcdGNvbXBsZXhTbmlwOiBcIkV4dHJhaSBhIG1hZ25pdHVkZSBkZSBuw7ptZXJvcyBjb21wbGV4b3MuXCIsXG5cdFx0Y29tcGxleERlc2M6IFwiRXN0YSBmdW7Dp8OjbyBjYWxjdWxhIGEgbWFnbml0dWRlIGRlIHZhbG9yZXMgY29tcGxleG9zLjxkaXY+PGJyLz5Fc3RhIGZ1bsOnw6NvIMOpIHRpcGljYW1lbnRlIHV0aWxpemFkYSBjb20gaW1hZ2VucyBSQURBUiBxdWUgdMOqbSB1bSB0aXBvIGRlIGRhZG9zIGNvbXBsZXhvLiBQb2RlIHNlciB1dGlsaXphZGEgbnVtIGNvbmp1bnRvIGRlIGRhZG9zIGVtIG1vc2FpY28uPC9kaXY+XCIsXG5cdFx0Y29tcG9zaXRlQmFuZE5hbWU6IFwiQmFuZGFzIENvbXBvc3Rhc1wiLFxuXHRcdGNvbXBvc2l0ZUJhbmRTbmlwOiBcIkNvbWJpbmEgbcO6bHRpcGxvcyBjb25qdW50b3MgZGUgZGFkb3MgcGFyYSB1bSByYXN0ZXIgbXVsdGliYW5kYS5cIixcblx0XHRjb21wb3NpdGVCYW5kRGVzYzogXCJBIGZ1bsOnw6NvIEJhbmRhcyBDb21wb3N0YXMgcGVybWl0ZSBjb21iaW5hciByYXN0ZXJzIHBhcmEgZm9ybWFyIHVtYSBpbWFnZW0gbXVsdGliYW5kYS5cIixcblx0XHRjb25OYW1lOiBcIkNvblwiLFxuXHRcdGNvblNuaXA6IFwiRXhlY3V0YSB1bWEgb3BlcmHDp8OjbyBjb25kaWNpb25hbCBJZiwgVGhlbiwgRWxzZS4gUXVhbmRvIMOpIHV0aWxpemFkbyB1bSBvcGVyYWRvciBDb24sIGNvc3R1bWEgc2VyIG5lY2Vzc8OhcmlvIGV4aXN0aXJlbSBkdWFzIG91IG1haXMgZnVuw6fDtWVzIGVuY2FkZWFkYXMsIG9uZGUgdW1hIGZ1bsOnw6NvIGRpdGEgbyBjcml0w6lyaW8gZSBhIHNlZ3VuZGEgw6kgbyBvcGVyYWRvciBDb24sIHF1ZSB1dGlsaXphIG8gY3JpdMOpcmlvIGUgZGl0YSBxdWFpcyBkZXZlcsOjbyBzZXIgb3MgdmFsb3JlcyBkZSBzYcOtZGEgdmVyZGFkZWlyb3MgZSBmYWxzb3MuXCIsXG5cdFx0Y29uRGVzYzogXCJBIGZ1bsOnw6NvIENvbiBkZWZpbmUgb3MgcMOteGVpcyBkbyByYXN0ZXIgZGUgc2HDrWRhIGNvbSBiYXNlIG51bWEgYXZhbGlhw6fDo28gZG8gaWZcXFxcZWxzZSBkZSBjYWRhIHDDrXhlbCBkZSBlbnRyYWRhLiBEZXZvbHZlIHZhbG9yZXMgZGUgcMOteGVsIGRvIFJhc3RlciBWZXJkYWRlaXJvIG5vIGNhc28gZGEgYXZhbGlhw6fDo28gY29uZGljaW9uYWwgc2VyIHZlcmRhZGVpcmEgKDEpIG91LCBlbnTDo28sIHZhbG9yZXMgZGUgcMOteGVsIGRvIFJhc3RlciBGYWxzbyBjYXNvIGEgYXZhbGlhw6fDo28gY29uZGljaW9uYWwgc2VqYSBmYWxzYSAoMCkuIEVzdGUgY3JpdMOpcmlvIMOpIGRlZmluaWRvIHBlbG8gdmFsb3IgZGUgc2HDrWRhIGRlIHVtYSBmdW7Dp8OjbyBtYXRlbcOhdGljYSBsw7NnaWNhLCBxdWUgc2Vyw6EgbyBSYXN0ZXIgZGUgZW50cmFkYS5cIixcblx0XHRjb25zdGFudE5hbWU6IFwiQ29uc3RhbnRlXCIsXG5cdFx0Y29uc3RhbnRTbmlwOiBcIkNyaWEgdW0gcmFzdGVyIHZpcnR1YWwgY29tIHVtIMO6bmljbyB2YWxvciBkZSBww614ZWwuXCIsXG5cdFx0Y29uc3RhbnREZXNjOiBcIkVzdGEgZnVuw6fDo28gY3JpYSB1bSByYXN0ZXIgdmlydHVhbCBjb20gbyB2YWxvciBkZSB1bSDDum5pY28gcMOteGVsLCBxdWUgcG9kZSBzZXIgdXRpbGl6YWRvIGVtIG1vZGVsb3MgZGUgZnVuw6fDtWVzIHJhc3RlciBlIHBhcmEgcHJvY2Vzc2FyIHVtIGNvbmp1bnRvIGRlIGRhZG9zIGVtIG1vc2FpY28uPGRpdj48YnIvPk8gdmFsb3IgZGEgY29uc3RhbnRlIMOpIHV0aWxpemFkbyBwYXJhIGNhZGEgdmFsb3IgZGUgcMOteGVsIG5vIHJhc3Rlci48L2Rpdj5cIixcblx0XHRjb250b3VyTmFtZTogXCJDb250b3Jub1wiLFxuXHRcdGNvbnRvdXJTbmlwOiBcIkNyaWEgbGluaGFzIGRlIGNvbnRvcm5vLlwiLFxuXHRcdGNvbnRvdXJEZXNjOiBcIkEgZnVuw6fDo28gQ29udG9ybm8gZ2VyYSBsaW5oYXMgZGUgY29udG9ybm8ganVudGFuZG8gcG9udG9zIGNvbSBhIG1lc21hIGVsZXZhw6fDo28gZGUgdW0gY29uanVudG8gZGUgZGFkb3MgZGUgZWxldmHDp8OjbyBkZSByYXN0ZXIuIE9zIGNvbnRvcm5vcyBzw6NvIGlzb2xpbmhhcyBjcmlhZGFzIGNvbW8gcmFzdGVycyBwYXJhIHZpc3VhbGl6YcOnw6NvLiBBcyBzZWd1aW50ZXMgY2FyYXRlcsOtc3RpY2FzIGNoYXZlIHRvcm5hbSBlc3RhIGZ1bsOnw6NvIHBvZGVyb3NhOiBvcyBjb250b3Jub3Mgc8OjbyBnZXJhZG9zIGRlIHVtIG1vZG8gcsOhcGlkbyBlIGRpbsOibWljbyBhIHBhcnRpciBkZSBjb25qdW50b3MgZGUgZGFkb3MgbXVpdG8gZ3JhbmRlcywgdGFsIGNvbW8gYSBFbGV2YcOnw6NvIE11bmRpYWw7IG9zIGNvbnRvcm5vcyBwb2RlbSBzZXIgc3Vhdml6YWRvcyBwYXJhIGdlcmFyIHVtYSBhcGFyw6puY2lhIGNhcnRvZ3LDoWZpY2EgbWFpcyBhcGVsYXRpdmEgbWFudGVuZG8sIG5vIGVudGFudG8sIGEgcHJlY2lzw6NvIGRvIGNvbnRvcm5vOyDDqSBmb3JuZWNpZG8gY29udHJvbG8gZGluw6JtaWNvIHNvYnJlIG8gaW50ZXJ2YWxvIGRlIGNvbnRvcm5vOyBhcyBvcMOnw7VlcyBkZSBzYcOtZGEgaW5jbHVlbSBsaW5oYXMgZGUgY29udG9ybm8sIGNvbnRvcm5vcyBpbmRleGFkb3MgZSBjb250b3Jub3MgcHJlZW5jaGlkb3MuPGRpdj48YnIvPkEgY3JpYcOnw6NvIGRlIHVtYSBjYW1hZGEgZGUgY29udG9ybm8gY29tbyBwcm9kdXRvIHJhc3RlciDDqSB2YWxpb3NhIHBhcmEgdW1hIHZhc3RhIGdhbWEgZGUgYXBsaWNhw6fDtWVzLCB1bWEgdmV6IHF1ZSBvcyBjb250b3Jub3MgcG9kZW0gc2VyIHNvYnJlcG9zdG9zIG51bSBtYXBhIGUgZm9ybmVjZXIgaW5mb3JtYcOnw7VlcyBzb2JyZSBvIHRlcnJlbm8gc2VtIG9ic2N1cmVjZXIgb3MgZGFkb3Mgc3ViamFjZW50ZXMuIFPDo28gw7p0ZWlzIGVtIGFwbGljYcOnw7VlcyBjb21vIGEgZW5nZW5oYXJpYSwgYWdyaWN1bHR1cmEgZSBhIGdlc3TDo28gZGUgw6FndWEuPC9kaXY+XCIsXG5cdFx0Y29udHJhc3RCcmlnaHRuZXNzTmFtZTogXCJDb250cmFzdGUgZSBvIEJyaWxob1wiLFxuXHRcdGNvbnRyYXN0QnJpZ2h0bmVzc1NuaXA6IFwiQWp1c3RhIG8gY29udHJhc3RlIGUgbyBicmlsaG8gZGUgdW0gcmFzdGVyLlwiLFxuXHRcdGNvbnRyYXN0QnJpZ2h0bmVzc0Rlc2M6IFwiQSBmdW7Dp8OjbyBkZSBDb250cmFzdGUgZSBCcmlsaG8gcmVhbMOnYSBhIGFwYXLDqm5jaWEgZGUgZGFkb3MgcmFzdGVyIG1vZGlmaWNhbmRvIG8gYnJpbGhvIGUgbyBjb250cmFzdGUgZGVudHJvIGRhIGltYWdlbS4gTyBicmlsaG8gYXVtZW50YSBhIGNsYXJpZGFkZSBnZXJhbCBkYSBpbWFnZW0g4oCUIHRvcm5hbmRvIGFzIGNvcmVzIGVzY3VyYXMgbWFpcyBjbGFyYXMgZSBhcyBlIGFzIGNvcmVzIGNsYXJhcyBtYWlzIGJyYW5jYXMsIHBvciBleGVtcGxvLiDigJRPIGNvbnRyYXN0ZSBhanVzdGEgYSBkaWZlcmVuw6dhIGVudHJlIGFzIGNvcmVzIG1haXMgZXNjdXJhcyBlIGFzIG1haXMgY2xhcmFzLjxkaXY+PGJyLz5BIHV0aWxpemHDp8OjbyBkZXN0YSBmdW7Dp8OjbyBhbHRlcmEgb3MgdmFsb3JlcyBkZSBww614ZWlzOyBwb3J0YW50bywgZGV2ZSBzZXIgdXRpbGl6YWRhIHF1YW5kbyBzZSBwcmV0ZW5kZSBtZWxob3JhciBhIGFwYXLDqm5jaWEgZG9zIGRhZG9zIGUgbsOjbyBzZSBwcmV0ZW5kZXIgdXRpbGl6YXIgb3MgZGFkb3MgY29tbyBwYXJ0ZSBkZSB1bWEgYW7DoWxpc2UgcXVlIHJlcXVlaXJhIG9zIHZhbG9yZXMgZGUgcMOteGVpcyBlbSBicnV0by4gRXN0YSBmdW7Dp8OjbyDDqSDDunRpbCBhbyBwdWJsaWNhciBvcyBkYWRvcyBjb21vIHVtIHNlcnZpw6dvIGRlIGltYWdlbSwgcXVlIHBvZGUgc2VyIHV0aWxpemFkbyBlbSBhcGxpY2HDp8O1ZXMgc2VtIGEgY2FwYWNpZGFkZSBkZSBhbHRlcmFyIG8gY29udHJhc3RlIGUgbyBicmlsaG8gZGFzIGltYWdlbnMsIG91IHBhcmEgZ2FyYW50aXIgcXVlIGFzIGV4aWJlIHJlY29ycmVuZG8gw6BzIHN1YXMgY29uZmlndXJhw6fDtWVzIHByZWZlcmlkYXMuPC9kaXY+XCIsXG5cdFx0Y29udm9sdXRpb25OYW1lOiBcIkNvbnZvbHXDp8Ojb1wiLFxuXHRcdGNvbnZvbHV0aW9uU25pcDogXCJBcGxpY2EgdW0gZmlsdHJvIHBhcmEgYWp1c3RhciBhIG5pdGlkZXosIGRlc2ZvY2FyLCBkZXRldGFyIGV4dHJlbWlkYWRlcywgdW5pZm9ybWl6YXIgb3UgdW0gZ3JhZGllbnRlIGFvIGxvbmdvIGRlIHVtIHJhc3Rlci5cIixcblx0XHRjb252b2x1dGlvbkRlc2M6IFwiQSBmdW7Dp8OjbyBDb252b2x1w6fDo28gZXhlY3V0YSBhIGZpbHRyYWdlbSBkb3MgdmFsb3JlcyBkZSBww614ZWwgbnVtYSBpbWFnZW0sIHF1ZSBwb2RlcsOhIHNlciB1dGlsaXphZGEgcGFyYSBhanVzdGFyIGEgbml0aWRleiBkZSB1bWEgaW1hZ2VtLCBkZXNmb2NhciB1bWEgaW1hZ2VtLCBkZXRldGFyIGFzIGV4dHJlbWlkYWRlcyBkZSB1bWEgaW1hZ2VtIG91IG91dHJhcyBtZWxob3JpYXMgYmFzZWFkYXMgbnVtIGtlcm5lbC4gT3MgZmlsdHJvcyBzw6NvIHV0aWxpemFkb3MgcGFyYSBtZWxob3JhciBhIHF1YWxpZGFkZSBkYSBpbWFnZW0gcmFzdGVyIGFvIGVsaW1pbmFyIGRhZG9zIGFydGlmaWNpYWlzIG91IGF1bWVudGFyIGFzIGZ1bmNpb25hbGlkYWRlcyBub3MgZGFkb3MuIE9zIGZpbHRyb3MgZGUgY29udm9sdcOnw6NvIHPDo28gYXBsaWNhZG9zIG51bSBrZXJuZWwgZW0gbW92aW1lbnRvIGUgc29icmVwb3N0byAoamFuZWxhIG91IHZpemluaG9zKSwgY29tbyB1bSAzIHBvciAzLiBPcyBmaWx0cm9zIGRlIGNvbnZvbHXDp8OjbyBmdW5jaW9uYW0gYXRyYXbDqXMgZG8gY8OhbGN1bG8gZG8gdmFsb3IgZGUgcMOteGVsIGNvbSBiYXNlIG5vcyBwZXNvcyBkb3Mgc2V1cyB2aXppbmhvcy5cIixcblx0XHRjb3JyaWRvck5hbWU6IFwiQ29ycmVkb3JcIixcblx0XHRjb3JyaWRvclNuaXA6IFwiQ2FsY3VsYSBhIHNvbWEgZGUgY3VzdG9zIGFjdW11bGFkb3MgcGFyYSBvcyBkb2lzIHJhc3RlcnMgYWN1bXVsYWRvcyBkZSBlbnRyYWRhLlwiLFxuXHRcdGNvcnJpZG9yRGVzYzogXCJBIGZ1bsOnw6NvIGRlIENvcnJlZG9yIGNhbGN1bGEgYSBzb21hIGRvcyBjdXN0b3MgYWN1bXVsYWRvcyBwYXJhIGRvaXMgcmFzdGVycyBkZSBjdXN0byBhY3VtdWxhZG8gZGUgZW50cmFkYS4gQXBlc2FyIGRlIHF1YWxxdWVyIHBhciBkZSByYXN0ZXJzIHBvZGVyIHNlciB1dGlsaXphZG8gcGFyYSBhIGVudHJhZGEsIHBhcmEgb2J0ZXIgdW0gcmVzdWx0YWRvIHNpZ25pZmljYXRpdm8sIGRldmVyw6NvIGV4aXN0aXIgcmFzdGVycyBkZSBzYcOtZGEgZGUgY3VzdG9zIGFjdW11bGFkb3MgaW5hbHRlcmFkb3MuIEEgb3JkZW0gZGFzIGR1YXMgZW50cmFkYXMgw6kgaXJyZWxldmFudGUuXCIsXG5cdFx0Y29zSE5hbWU6IFwiQ29zSFwiLFxuXHRcdGNvc0hTbmlwOiBcIkNhbGN1bGEgYSBjb3NzZW5vIGhpcGVyYsOzbGljbyBkYXMgY8OpbHVsYXMgbnVtIHJhc3Rlci5cIixcblx0XHRjb3NIRGVzYzogXCJBIGZ1bsOnw6NvIGNhbGN1bGEgbyBjb3NzZW5vIGhpcGVyYsOzbGljbyBkb3MgcMOteGVpcyBudW0gcmFzdGVyLlwiLFxuXHRcdGNvc05hbWU6IFwiQ29zXCIsXG5cdFx0Y29zU25pcDogXCJDYWxjdWxhIG8gY29zc2VubyBkZSB1bWEgY8OpbHVsYSBudW0gcmFzdGVyLlwiLFxuXHRcdGNvc0Rlc2M6IFwiQSBmdW7Dp8OjbyBjYWxjdWxhIG8gY29zc2VubyBkb3MgcMOteGVpcyBudW0gcmFzdGVyLlwiLFxuXHRcdGNvc3RBbGxvY2F0aW9uTmFtZTogXCJBdHJpYnVpw6fDo28gZGUgY3VzdG9zXCIsXG5cdFx0Y29zdEFsbG9jYXRpb25TbmlwOiBcIkNhbGN1bGEsIHBhcmEgY2FkYSBjw6lsdWxhLCBhIHN1YSBvcmlnZW0gbWFpcyBlY29uw7NtaWNhIGNvbSBiYXNlIG5vIG1lbm9yIGN1c3RvIGFjdW11bGFkbyBhbyBsb25nbyBkZSB1bWEgc3VwZXJmw61jaWUgZGUgY3VzdG8uXCIsXG5cdFx0Y29zdEFsbG9jYXRpb25EZXNjOiBcIkEgZnVuw6fDo28gZGUgQXRyaWJ1acOnw6NvIGRlIGN1c3RvcyBjYWxjdWxhLCBwYXJhIGNhZGEgY8OpbHVsYSwgYSBzdWEgb3JpZ2VtIG1haXMgZWNvbsOzbWljYSBjb20gYmFzZSBubyBtZW5vciBjdXN0byBhY3VtdWxhZG8gYW8gbG9uZ28gZGUgdW1hIHN1cGVyZsOtY2llIGRlIGN1c3RvLlwiLFxuXHRcdGNvc3RCYWNrTGlua05hbWU6IFwiTGlnYcOnw6NvIGRlIE1lbm9yIEN1c3RvXCIsXG5cdFx0Y29zdEJhY2tMaW5rU25pcDogXCJEZWZpbmUgbyB2aXppbmhvIHF1ZSDDqSBhIGPDqWx1bGEgc2VndWludGUgbm8gcGVyY3Vyc28gZGUgbWVub3IgY3VzdG8gYWN1bXVsYWRvIGF0w6kgw6Agb3JpZ2VtIGNvbSBtZW5vciBjdXN0by5cIixcblx0XHRjb3N0QmFja0xpbmtEZXNjOiBcIkEgZnVuw6fDo28gTGlnYcOnw6NvIGRlIE1lbm9yIEN1c3RvIGRlZmluZSBvIHZpemluaG8gcXVlIMOpIGEgY8OpbHVsYSBzZWd1aW50ZSBubyBwZXJjdXJzbyBkZSBtZW5vciBjdXN0byBhY3VtdWxhZG8gYXTDqSDDoCBvcmlnZW0gY29tIG1lbm9yIGN1c3RvLjxkaXY+PGJyLz5PIHJhc3RlciBkZSBsaWdhw6fDo28gaW52ZXJzYSBjb250w6ltIHZhbG9yZXMgZGUgemVybyBhIG9pdG8sIHF1ZSBkZWZpbmVtIGEgZGlyZcOnw6NvIG91IGlkZW50aWZpY2FtIGEgY8OpbHVsYSB2aXppbmhhIHNlZ3VpbnRlIChhIGPDqWx1bGEgc2VndWludGUpIGFvIGxvbmdvIGRvIHBlcmN1cnNvIGRlIG1lbm9yIGN1c3RvIGFjdW11bGFkbyBhIHBhcnRpciBkZSB1bWEgY8OpbHVsYSBwYXJhIGF0aW5naXIgYSBzdWEgb3JpZ2VtIGRlIG1lbm9yIGN1c3RvLiBDYXNvIG8gcGVyY3Vyc28gZGV2YSBhdHJhdmVzc2FyIG8gdml6aW5obyBkaXJlaXRvLCDDoCBjw6lsdWxhIGRldmVyw6Egc2VyIGF0cmlidcOtZG8gbyB2YWxvciAxLCAyIHBhcmEgYSBjw6lsdWxhIGRpYWdvbmFsIGluZmVyaW9yIGRpcmVpdGEgZSBwb3IgYcOtIGFkaWFudGUgbm8gc2VudGlkbyBkb3MgcG9udGVpcm9zIGRvIHJlbMOzZ2lvLiBPIHZhbG9yIDAgw6kgcmVzZXJ2YWRvIHBhcmEgY8OpbHVsYXMgZGUgb3JpZ2VtLjwvZGl2PlwiLFxuXHRcdGNvc3REaXN0YW5jZU5hbWU6IFwiQ3VzdG8gZGUgZGlzdMOibmNpYVwiLFxuXHRcdGNvc3REaXN0YW5jZVNuaXA6IFwiQ2FsY3VsYSBhIGRpc3TDom5jaWEgY29tIG1lbm9yIGN1c3RvIGFjdW11bGFkbyBwYXJhIGNhZGEgY8OpbHVsYSBhIHBhcnRpciBkZSwgb3UgYXTDqSDDoCBvcmlnZW0gZGUgbWVub3IgY3VzdG8gYW8gbG9uZ28gZGUgdW1hIHN1cGVyZsOtY2llIGRlIGN1c3RvLlwiLFxuXHRcdGNvc3REaXN0YW5jZURlc2M6IFwiQSBGdW7Dp8OjbyBkZSBDdXN0byBkZSBEaXN0w6JuY2lhIGNhbGN1bGEgYSBkaXN0w6JuY2lhIGNvbSBtZW5vciBjdXN0byBhY3VtdWxhZG8gcGFyYSBjYWRhIGPDqWx1bGEgYSBwYXJ0aXIgZGUsIG91IGF0w6kgw6Agb3JpZ2VtIGRlIG1lbm9yIGN1c3RvIGFvIGxvbmdvIGRlIHVtYSBzdXBlcmbDrWNpZSBkZSBjdXN0by5cIixcblx0XHRjb3N0UGF0aE5hbWU6IFwiUGVyY3Vyc28gZGUgY3VzdG9cIixcblx0XHRjb3N0UGF0aFNuaXA6IFwiQ2FsY3VsYSBvIHBlcmN1cnNvIGRlIG1lbm9yIGN1c3RvIGEgcGFydGlyIGRlIHVtYSBvcmlnZW0gYXTDqSB1bSBkZXN0aW5vLlwiLFxuXHRcdGNvc3RQYXRoRGVzYzogXCJBIGZ1bsOnw6NvIGRlIFBlcmN1cnNvIGRlIGN1c3RvIGdsb2JhbCBjYWxjdWxhIG8gcGVyY3Vyc28gZGUgbWVub3IgY3VzdG8gYSBwYXJ0aXIgZGUgdW1hIG9yaWdlbSBhdMOpIHVtIGRlc3Rpbm8uPGRpdj48YnIvPkVzdGEgZnVuw6fDo28gcHJvZHV6IHVtIHJhc3RlciBkZSBzYcOtZGEgcXVlIHJlZ2lzdGEgbyBwZXJjdXJzbyBvdSBwZXJjdXJzb3MgZGUgbWVub3IgY3VzdG8gYSBwYXJ0aXIgZGUgbG9jYWlzIHNlbGVjaW9uYWRvcyBhdMOpIMOgIGPDqWx1bGEgZGUgb3JpZ2VtIG1haXMgcHLDs3hpbWEgZGVmaW5pZGEgZGVudHJvIGRhIHN1cGVyZsOtY2llIGRlIGN1c3RvIGFjdW11bGFkbywgZW0gdGVybW9zIGRlIGRpc3TDom5jaWEgZGUgY3VzdG8uPC9kaXY+XCIsXG5cdFx0Y3VydmF0dXJlTmFtZTogXCJDdXJ2YXR1cmFcIixcblx0XHRjdXJ2YXR1cmVTbmlwOiBcIkNhbGN1bGEgYSBjdXJ2YXR1cmEgZGUgdW1hIHN1cGVyZsOtY2llIHJhc3Rlciwgb3BjaW9uYWxtZW50ZSBpbmNsdWluZG8gYSBjdXJ2YXR1cmEgZGUgcGxhbm8gZSBkZSBwZXJmaWwuXCIsXG5cdFx0Y3VydmF0dXJlRGVzYzogXCJBIGZ1bsOnw6NvIGRlIEN1cnZhdHVyYSBleGliZSBhIGZvcm1hIG91IGN1cnZhdHVyYSBkbyBkZWNsaXZlLiBVbWEgcGFydGUgZGEgc3VwZXJmw61jaWUgcG9kZXLDoSBzZXIgY8O0bmNhdmEgb3UgY29udmV4YTsgcG9kZXLDoSBzYWJlciBhbyBvYnNlcnZhciBvIHZhbG9yIGRhIGN1cnZhdHVyYS4gQSBjdXJ2YXR1cmEgw6kgY2FsY3VsYWRhIGF0cmF2w6lzIGRvIGPDoWxjdWxvIGRhIHNlZ3VuZGEgZGVyaXZhZGEgZGEgc3VwZXJmw61jaWUuPGRpdj48YnIvPkEgc2HDrWRhIGRhIGZ1bsOnw6NvIGRlIEN1cnZhdHVyYSBwb2RlIHNlciB1dGlsaXphZGEgcGFyYSBkZXNjcmV2ZXIgYXMgY2FyYWN0ZXLDrXN0aWNhcyBmw61zaWNhcyBkZSB1bWEgYmFjaWEgZGUgZHJlbmFnZW0gbnVtIGVzZm9yw6dvIHBhcmEgY29tcHJlZW5kZXIgb3MgcHJvY2Vzc29zIGRlIGVyb3PDo28gZSBlc2NvYW1lbnRvLiBPIHZhbG9yIGRhIGN1cnZhdHVyYSBwb2RlcsOhIHNlciB1dGlsaXphZG8gcGFyYSBkZXNjb2JyaXIgcGFkcsO1ZXMgZGUgZXJvc8OjbyBkbyBzb2xvIGFzc2ltIGNvbW8gYSBkaXN0cmlidWnDp8OjbyBkZSDDoWd1YSBwZWxvcyB0ZXJyZW5vcy4gQSBjdXJ2YXR1cmEgZGUgcGVyZmlsIGFmZXRhIGEgYWNlbGVyYcOnw6NvIGUgZGVzYWNlbGVyYcOnw6NvIGRvIGZsdXhvIGUsIGNvbW8gdGFsLCBpbmZsdWVuY2lhIGEgZXJvc8OjbyBlIGEgZGVwb3Npw6fDo28uIEEgY3VydmF0dXJhIGRhIHBsYXRhZm9ybWEgaW5mbHVlbmNpYSBhIGNvbnZlcmfDqm5jaWEgZSBkaXZlcmfDqm5jaWEgZG8gZmx1eG8uPC9kaXY+XCIsXG5cdFx0ZGl2aWRlTmFtZTogXCJEaXZpZGlyXCIsXG5cdFx0ZGl2aWRlU25pcDogXCJEaXZpZGUgb3MgdmFsb3JlcyBkZSBkb2lzIHJhc3RlcnMgbnVtYSBiYXNlIGPDqWx1bGEgYSBjw6lsdWxhLlwiLFxuXHRcdGRpdmlkZURlc2M6IFwiQSBmdW7Dp8OjbyBkZSBEaXZpc8OjbyBkaXZpZGUgb3MgdmFsb3JlcyBkZSBkb2lzIHJhc3RlcnMgbnVtYSBiYXNlIHDDrXhlbCBhIHDDrXhlbC5cIixcblx0XHRlbGV2YXRpb25Wb2lkRmlsbE5hbWU6IFwiUHJlZW5jaGltZW50byBkZSB2YXppbyBkYSBlbGV2YcOnw6NvXCIsXG5cdFx0ZWxldmF0aW9uVm9pZEZpbGxTbmlwOiBcIkNyaWEgcMOteGVpcyBvbmRlIGV4aXN0ZW0gYnVyYWNvcyBub3Mgc2V1cyBkYWRvcyBkYSBlbGV2YcOnw6NvLlwiLFxuXHRcdGVsZXZhdGlvblZvaWRGaWxsRGVzYzogXCJBIGZ1bsOnw6NvIGRlIFByZWVuY2hpbWVudG8gZGUgVmF6aW8gZGEgRWxldmHDp8OjbyDDqSB1dGlsaXphZGEgcGFyYSBjcmlhciBww614ZWlzIG9uZGUgZXhpc3RlbSBidXJhY29zIG5hIHN1YSBlbGV2YcOnw6NvLjxkaXY+PGJyLz5PcyB2YXppb3Mgb2NvcnJlbSBxdWFuZG8gbsOjbyBow6EgcG9udG9zIHJlY29saGlkb3MgZGVudHJvIGRhIMOhcmVhIHJlcHJlc2VudGFkYSBwb3IgdW0gcMOteGVsIG5vIHJhc3RlciByZXN1bHRhbnRlLiBPcyB2YXppb3Mgc8OjbyBtdWl0YXMgdmV6ZXMgcHJvdm9jYWRvcyBwb3IgY29ycG9zIGRlIMOhZ3VhLCBzZWxlw6fDo28gZG8gdGlwbyBkZSBjbGFzc2Ugb3UgZXhjbHVzw6NvLiBPIHByZWVuY2hpbWVudG8gZGUgdmF6aW8gw6kgbm9ybWFsbWVudGUgdXRpbGl6YWRvIGR1cmFudGUgYSBnZXJhw6fDo28gZGUgdW1hIHN1cGVyZsOtY2llIGRlIHNvbG8uPC9kaXY+XCIsXG5cdFx0ZXF1YWxUb05hbWU6IFwiSWd1YWwgQTpcIixcblx0XHRlcXVhbFRvU25pcDogXCJSZWFsaXphIHVtYSBvcGVyYcOnw6NvIGlndWFsLWEgcmVsYWNpb25hbCBlbSBkdWFzIGVudHJhZGFzIG51bWEgYmFzZSBjw6lsdWxhIGEgY8OpbHVsYS4gRGV2b2x2ZSBvIHZhbG9yIDEgcGFyYSBjw6lsdWxhcyBuYXMgcXVhaXMgbyBwcmltZWlybyByYXN0ZXIgaWd1YWxhIG8gc2VndW5kbyByYXN0ZXIgZSAwIHBhcmEgY8OpbHVsYXMgbmFzIHF1YWlzIGlzc28gbsOjbyBhY29udGVjZS5cIixcblx0XHRlcXVhbFRvRGVzYzogXCJBIGZ1bsOnw6NvIHJlYWxpemEgdW1hIG9wZXJhw6fDo28gZGUgaWd1YWwtYSBlbSBkb2lzIHJhc3RlcnMgbnVtYSBiYXNlIHDDrXhlbCBhIHDDrXhlbC4gRGV2b2x2ZSBvIHZhbG9yIDEgcGFyYSBww614ZWlzIG5vcyBxdWFpcyBvIHByaW1laXJvIHJhc3RlciBpZ3VhbGEgbyBzZWd1bmRvIHJhc3RlciBlIG8gdmFsb3IgMCBwYXJhIHDDrXhlaXMgcXVlIG7Do28gc8OjbyBpZ3VhaXMuXCIsXG5cdFx0ZXVjQWxsb2NhdGlvbk5hbWU6IFwiQXRyaWJ1acOnw6NvIEV1Y2xpZGlhbmFcIixcblx0XHRldWNBbGxvY2F0aW9uU25pcDogXCJDYWxjdWxhLCBwYXJhIGNhZGEgY8OpbHVsYSwgYSBvcmlnZW0gbWFpcyBwcsOzeGltYSBjb20gYmFzZSBuYSBkaXN0w6JuY2lhIEV1Y2xpZGlhbmEuXCIsXG5cdFx0ZXVjQWxsb2NhdGlvbkRlc2M6IFwiQSBmdW7Dp8OjbyBkZSBBdHJpYnVpw6fDo28gRXVjbGlkaWFuYSBjYWxjdWxhLCBwYXJhIGNhZGEgY8OpbHVsYSwgYSBvcmlnZW0gbWFpcyBwcsOzeGltYSBjb20gYmFzZSBuYSBkaXN0w6JuY2lhIEV1Y2xpZGlhbmEuXCIsXG5cdFx0ZXVjRGlyZWN0aW9uTmFtZTogXCJEaXJlw6fDo28gRXVjbGlkaWFuYVwiLFxuXHRcdGV1Y0RpcmVjdGlvblNuaXA6IFwiQ2FsY3VsYSwgcGFyYSBjYWRhIGPDqWx1bGEsIGEgZGlyZcOnw6NvLCBlbSBncmF1cywgcGFyYSBhIG9yaWdlbSBtYWlzIHByw7N4aW1hLlwiLFxuXHRcdGV1Y0RpcmVjdGlvbkRlc2M6IFwiQSBmdW7Dp8OjbyBkZSBEaXJlw6fDo28gRXVjbGlkaWFuYSBjYWxjdWxhLCBwYXJhIGNhZGEgY8OpbHVsYSwgYSBkaXJlw6fDo28sIGVtIGdyYXVzLCBwYXJhIGEgb3JpZ2VtIG1haXMgcHLDs3hpbWEuIDxkaXY+PGJyLz5BIGRpcmXDp8OjbyDDqSBjYWxjdWxhZGEgYSBwYXJ0aXIgZGUgY2FkYSBjZW50cm8gZGEgY8OpbHVsYSBhdMOpIGFvIGNlbnRybyBkYSBjw6lsdWxhIGRlIG9yaWdlbSBxdWUgbGhlIGVzdMOhIG1haXMgcHLDs3hpbWEuIE8gaW50ZXJ2YWxvIGRlIHZhbG9yZXMgdmFpIGRvcyAwIGdyYXVzIGF0w6kgYW9zIDM2MCBncmF1cywgY29tIG8gMCByZXNlcnZhZG8gcGFyYSBhcyBjw6lsdWxhcyBkZSBvcmlnZW0uIFBhcmEgZXN0ZSAoZGlyZWl0YSkgZXN0w6EgbyB2YWxvciA5MCBlIG9zIG1lc21vcyBhdW1lbnRhbSBubyBzZW50aWRvIGRvcyBwb250ZWlyb3MgZG8gcmVsw7NnaW8gKDE4MCDDqSBzdWwsIDI3MCDDqSBvZXN0ZSBlIDM2MCDDqSBub3J0ZSkuPC9kaXY+XCIsXG5cdFx0ZXVjRGlzdGFuY2VOYW1lOiBcIkRpc3TDom5jaWEgRXVjbGlkaWFuYVwiLFxuXHRcdGV1Y0Rpc3RhbmNlU25pcDogXCJDYWxjdWxhLCBwYXJhIGNhZGEgY8OpbHVsYSwgYSBkaXN0w6JuY2lhIEV1Y2xpZGlhbmEgYXTDqSDDoCBvcmlnZW0gbWFpcyBwcsOzeGltYS5cIixcblx0XHRldWNEaXN0YW5jZURlc2M6IFwiQSBmdW7Dp8OjbyBkZSBEaXN0w6JuY2lhIEV1Y2xpZGlhbmEgY2FsY3VsYSwgcGFyYSBjYWRhIGPDqWx1bGEsIGEgZGlzdMOibmNpYSBFdWNsaWRpYW5hIGF0w6kgw6Agb3JpZ2VtIG1haXMgcHLDs3hpbWEuXCIsXG5cdFx0ZXhwMTBOYW1lOiBcIkV4cDEwXCIsXG5cdFx0ZXhwMTBTbmlwOiBcIkNhbGN1bGEgbyBleHBvbmVuY2lhbCBlbSBiYXNlIDEwIGRhcyBjw6lsdWxhcyBudW0gcmFzdGVyLlwiLFxuXHRcdGV4cDEwRGVzYzogXCJBIGZ1bsOnw6NvIEV4cCAxMCBjYWxjdWxhIG8gZXhwb25lbmNpYWwgZW0gYmFzZSAxMCBkb3MgcMOteGVpcyBudW0gcmFzdGVyLlwiLFxuXHRcdGV4cDJOYW1lOiBcIkV4cDJcIixcblx0XHRleHAyU25pcDogXCJDYWxjdWxhIG8gZXhwb25lbmNpYWwgZW0gYmFzZSAyIGRhcyBjw6lsdWxhcyBudW0gcmFzdGVyLlwiLFxuXHRcdGV4cDJEZXNjOiBcIkVzdGEgZnVuw6fDo28gY2FsY3VsYSBvIGV4cG9uZW5jaWFsIGVtIGJhc2UgMiBkb3MgcMOteGVpcyBudW0gcmFzdGVyLlwiLFxuXHRcdGV4cE5hbWU6IFwiRXhwXCIsXG5cdFx0ZXhwU25pcDogXCJDYWxjdWxhIG8gZXhwb25lbmNpYWwgZW0gYmFzZSBlIGRhcyBjw6lsdWxhcyBudW0gcmFzdGVyLlwiLFxuXHRcdGV4cERlc2M6IFwiRXN0YSBmdW7Dp8OjbyBjYWxjdWxhIG8gZXhwb25lbmNpYWwgZW0gYmFzZSBlIGRvcyBww614ZWlzIG51bSByYXN0ZXIuXCIsXG5cdFx0ZXh0cmFjdEJhbmROYW1lOiBcIkV4dHJhaXIgQmFuZGFzXCIsXG5cdFx0ZXh0cmFjdEJhbmRTbmlwOiBcIkVzcGVjaWZpY2EgcXVlIGJhbmRhcyB1dGlsaXphciwgcXVhbmRvIHNlIHV0aWxpemFtIGNvbmp1bnRvcyBkZSBkYWRvcyBtdWx0aWJhbmRhLlwiLFxuXHRcdGV4dHJhY3RCYW5kRGVzYzogXCIgQSBmdW7Dp8OjbyBFeHRyYWlyIEJhbmRhcyBwZXJtaXRlLWxoZSBleHRyYWlyIHVtYSBvdSBtYWlzIGJhbmRhcyBhIHBhcnRpciBkZSwgb3UgcmVvcmRlbmEgYXMgYmFuZGFzLCB1bSBjb25qdW50byBkZSBkYWRvcyBkZSByYXN0ZXIgbXVsdGliYW5kYS48ZGl2Pjxici8+UG9kZSB1dGlsaXphciBhIGZ1bsOnw6NvIEV4dHJhaXIgQmFuZGFzIGFudGVzIGRlIG91dHJhcyBmdW7Dp8O1ZXMsIHRhaXMgY29tbyBBcml0bcOpdGljYSwgcGFyYSBjb250cm9sYXIgcXVhaXMgYXMgYmFuZGFzIHF1ZSBzw6NvIHV0aWxpemFkYXMgY29tbyBlbnRyYWRhIG5hIGZ1bsOnw6NvIHNlZ3VpbnRlLjwvZGl2PlwiLFxuXHRcdGZpbGxOYW1lOiBcIlByZWVuY2hpbWVudG9cIixcblx0XHRmaWxsU25pcDogXCJQcmVlbmNoZSBzdW1pZG91cm9zIG51bSByYXN0ZXIgZGUgc3VwZXJmw61jaWUgcGFyYSByZW1vdmVyIHBlcXVlbmFzIGltcGVyZmVpw6fDtWVzIG5vcyBkYWRvcy5cIixcblx0XHRmaWxsRGVzYzogXCJBIGZ1bsOnw6NvIGRlIFByZWVuY2hpbWVudG8gZ2xvYmFsIGxvY2FsaXphIGUgcHJlZW5jaGUgc3VtaWRvdXJvcyBlIHBpY29zIG51bSByYXN0ZXIgZGUgc3VwZXJmw61jaWUgZGUgZWxldmHDp8OjbyBwYXJhIHJlbW92ZXIgcGVxdWVuYXMgaW1wZXJmZWnDp8O1ZXMgbm9zIGRhZG9zLiBBIGZ1bsOnw6NvIHByZWVuY2hlcsOhIG51bSBwcm9jZXNzbyBpdGVyYXRpdm8gYXTDqSBxdWUgdG9kb3Mgb3Mgc3VtaWRvdXJvcyBlc3RlamFtIHByZWVuY2hpZG9zIGRlbnRybyBkbyBsaW1pdGUgWiBlc3BlY2lmaWNhZG8uPGRpdj48YnIvPlF1YW5kbyB1bWEgc3VwZXJmw61jaWUgZGUgZWxldmHDp8OjbyDDqSBjcmlhZGEgY29tIGZlcnJhbWVudGFzIE9ydG9jYXJ0b2dyYWZpYSBvdSBwb3Igb3V0cm9zIG1laW9zLCBleGlzdGVtIGZyZXF1ZW50ZW1lbnRlIGVycm9zIHBlcXVlbm9zLCBtYXMgc2lnbmlmaWNhdGl2b3MgbmEgZm9ybWEgZGUgY29sZXRvcmVzIGUgcGljb3Mgbm9zIGRhZG9zLiBFbSBmb3RvZ3JhbWV0cmlhLCBzdW1pZG91cm9zIGUgcGljb3Mgc8OjbyBtdWl0YXMgdmV6ZXMgcmVmZXJpZG9zIGNvbW8gYnVyYWNvcyBlIGVzdGFjYXMuIFVtYSB2ZXogcXVlIG9zIGRhZG9zIGRlIHN1cGVyZsOtY2llIHPDo28gbXVpdGFzIHZlemVzIHV0aWxpemFkb3MgbmEgY3JpYcOnw6NvIGRlIG1vZGVsb3MsIGNvbW8gbW9kZWxvcyBoaWRyb2zDs2dpY29zLCDDqSBpbXBvcnRhbnRlIGNvcnJpZ2lyIGVzdGVzIGVycm9zIGRlIHN1bWlkb3VybyBlIGRlIHBpY28gZGUgdW1hIGZvcm1hIGNvbnNpc3RlbnRlIGNvbSBvcyBkYWRvcyBkYXMgcmVkb25kZXphcy48L2Rpdj5cIixcblx0XHRmbG9hdE5hbWU6IFwiRmx1dHVhclwiLFxuXHRcdGZsb2F0U25pcDogXCJDb252ZXJ0ZSBjYWRhIHZhbG9yIGRlIGPDqWx1bGEgZGUgdW0gcmFzdGVyIG51bWEgcmVwcmVzZW50YcOnw6NvIGRlIHVtIHBvbnRvIGRlIGZsdXR1YcOnw6NvLlwiLFxuXHRcdGZsb2F0RGVzYzogXCJBIGZ1bsOnw6NvIGRlIEZsdXR1YcOnw6NvIGNvbnZlcnRlIGNhZGEgdmFsb3IgZGUgcMOteGVsIGRlIHVtIHJhc3RlciBudW1hIHJlcHJlc2VudGHDp8OjbyBkZSB1bSBwb250byBkZSBmbHV0dWHDp8Ojby5cIixcblx0XHRmbG93QWNjdW11bGF0aW9uTmFtZTogXCJBY3VtdWxhw6fDo28gZGUgZmx1eG9cIixcblx0XHRmbG93QWNjdW11bGF0aW9uU25pcDogXCJDcmlhIHVtIHJhc3RlciBkZSBmbHV4byBhY3VtdWxhZG8gZW0gY2FkYSBjw6lsdWxhLiBQb2RlIHNlciBvcGNpb25hbG1lbnRlIHVtIGZhdG9yIGRlIHBlc28uXCIsXG5cdFx0Zmxvd0FjY3VtdWxhdGlvbkRlc2M6IFwiQSBmdW7Dp8OjbyBnbG9iYWwgZGUgQWN1bXVsYcOnw6NvIGRlIEZsdXhvIGNyaWEgdW0gcmFzdGVyIGRlIGZsdXhvIGFjdW11bGFkbyBlbSBjYWRhIHDDrXhlbCwgY29uZm9ybWUgZGV0ZXJtaW5hZG8gcGVsYSBhY3VtdWxhw6fDo28gZGUgcGVzbyBwYXJhIHRvZG9zIG9zIHDDrXhlaXMgcXVlIGZsdWVtIHBhcmEgY2FkYSBww614ZWwgZGVzY2VuZGVudGUuIENhc28gbsOjbyBzZWphIGZvcm5lY2lkbyBxdWFscXVlciByYXN0ZXIgZGUgcGVzbywgw6kgYXBsaWNhZG8gdW0gcGVzbyBkZSAxIGEgY2FkYSBww614ZWwgZSBvIHZhbG9yIGRlIHDDrXhlaXMgbm8gcmFzdGVyIGRlIHNhw61kYSDDqSBvIG7Dum1lcm8gZGUgcMOteGVpcyBxdWUgZmx1ZW0gcGFyYSBjYWRhIHDDrXhlbC48ZGl2Pjxici8+T3MgcMOteGVpcyBkZSBzYcOtZGEgY29tIHVtYSBhbHRhIGFjdW11bGHDp8OjbyBkZSBmbHV4byBzw6NvIMOhcmVhcyBkZSBmbHV4byBjb25jZW50cmFkbyBlIHBvZGVtIHNlciB1dGlsaXphZG9zIHBhcmEgaWRlbnRpZmljYXIgY2FuYWlzIGRlIGZsdXhvLiBPcyBww614ZWlzIGRlIHNhw61kYSBjb20gdW1hIGFjdW11bGHDp8OjbyBkZSBmbHV4byBkZSB6ZXJvIHPDo28gYWx0b3MgdG9wb2dyw6FmaWNvcyBsb2NhaXMgZSBwb2RlbSBzZXIgdXRpbGl6YWRvcyBwYXJhIGlkZW50aWZpY2FyIGNvcmRpbGhlaXJhcy48L2Rpdj5cIixcblx0XHRmbG93RGlyZWN0aW9uTmFtZTogXCJEaXJlw6fDo28gZG8gRmx1eG9cIixcblx0XHRmbG93RGlyZWN0aW9uU25pcDogXCJDcmlhIHVtIHJhc3RlciBkZSBkaXJlw6fDo28gZGUgZmx1eG8gYSBwYXJ0aXIgZGUgY2FkYSBjw6lsdWxhIGF0w6kgYW8gc2V1IHZpemluaG8gY29tIG1haW9yIGluY2xpbmHDp8OjbyBkZXNjZW5kZW50ZS5cIixcblx0XHRmbG93RGlyZWN0aW9uRGVzYzogXCJVbWEgZG9zIHByaW5jaXBhaXMgZWxlbWVudG9zIHBhcmEgYSBkZXJpdmHDp8OjbyBkZSBjYXJhY3RlcsOtc3RpY2FzIGhpZHJvbMOzZ2ljYXMgZGUgdW1hIHN1cGVyZsOtY2llIGNvbnNpc3RlIG5hIGNhcGFjaWRhZGUgZGUgZGV0ZXJtaW5hciBhIGRpcmXDp8OjbyBkZSBjYWRhIHDDrXhlbCBubyByYXN0ZXIuIEEgZnVuw6fDo28gZGUgcmFzdGVyIGRhIERpcmXDp8OjbyBkbyBGbHV4byB1dGlsaXphIHVtYSBzdXBlcmbDrWNpZSBjb21vIGVudHJhZGEgZSBjcmlhIHVtIHJhc3RlciBkZSBkaXJlw6fDo28gZGUgZmx1eG8gYSBwYXJ0aXIgZGUgY2FkYSBww614ZWwgYXTDqSBhbyBzZXUgdml6aW5obyBjb20gbWFpb3IgaW5jbGluYcOnw6NvIGRlc2NlbmRlbnRlLiBBIGZ1bsOnw6NvIGRlIERpcmXDp8OjbyBkbyBGbHV4byBzdXBvcnRhIHRyw6pzIG3DqXRvZG9zIGRlIGNyaWHDp8OjbyBkZSBtb2RlbG9zIGRlIGZsdXhvOiBvIEQ4IChvaXRvIGRpcmXDp8O1ZXMpLCBEaXJlw6fDo28gZGUgTcO6bHRpcGxvcyBGbHV4b3MgKE1GRCkgZSBELUluZmluaXR5IChESU5GKS4gXCIsXG5cdFx0Zmxvd0Rpc3RhbmNlTmFtZTogXCJEaXN0w6JuY2lhIGRvIEZsdXhvXCIsXG5cdFx0Zmxvd0Rpc3RhbmNlU25pcDogXCJDYWxjdWxhIHBhcmEgY2FkYSBjw6lsdWxhLCBhIGRpc3TDom5jaWEgbcOtbmltYSBob3Jpem9udGFsIG91IHZlcnRpY2FsIGRlc2NlbmRlbnRlIGF0w6kgw6BzIGPDqWx1bGFzIG51bSByaW8gb3UgY29ycmVudGUgcGFyYSBvIHF1YWwgZmx1ZW0uXCIsXG5cdFx0Zmxvd0Rpc3RhbmNlRGVzYzogXCJQYXJhIGNhZGEgcMOteGVsLCBhIGZ1bsOnw6NvIGlyw6EgY2FsY3VsYXIgYSBkaXN0w6JuY2lhIG3DrW5pbWEgaG9yaXpvbnRhbCBvdSB2ZXJ0aWNhbCBkZXNjZW5kZW50ZSBhdMOpIGFvKHMpIHDDrXhlbChlaXMpIG51bSByaW8gb3UgY29ycmVudGUgcGFyYSBvIHF1YWwgZmx1ZW0uIENhc28gc2VqYSBmb3JuZWNpZG8gdW0gcmFzdGVyIGRlIGRpcmXDp8OjbyBkZSBmbHV4byBvcGNpb25hbCwgYXMgZGlyZcOnw7VlcyBkZXNjZW5kZW50ZXMgc2Vyw6NvIGxpbWl0YWRhcyDDoHMgZGVmaW5pZGFzIHBlbG8gcmFzdGVyIGRlIGRpcmXDp8OjbyBkbyBmbHV4byBkZSBlbnRyYWRhLiBBIHNhw61kYSDDqSB1bSByYXN0ZXIgZGUgZGlzdMOibmNpYSBkZSBmbHV4by5cIixcblx0XHRmb2NhbE5hbWU6IFwiRXN0YXTDrXN0aWNhcyBGb2NhbGl6YWRhc1wiLFxuXHRcdGZvY2FsU25pcDogXCJDYWxjdWxhIGFzIGVzdGF0w61zdGljYXMgZm9jYWxpemFkYXMgcGFyYSBjYWRhIHDDrXhlbCBkZSB1bWEgaW1hZ2VtIGNvbSBiYXNlIG51bWEgdml6aW5oYW7Dp2EgZm9jYWxpemFkYSBkZWZpbmlkYS5cIixcblx0XHRmb2NhbERlc2M6IFwiQSBmdW7Dp8OjbyBkZSBFc3RhdMOtc3RpY2FzIEZvY2FsaXphZGFzIGNhbGN1bGEgYXMgZXN0YXTDrXN0aWNhcyBmb2NhbGl6YWRhcyBwYXJhIGNhZGEgcMOteGVsIGRlIHVtYSBpbWFnZW0gY29tIGJhc2UgbnVtYSB2aXppbmhhbsOnYSBmb2NhbGl6YWRhIGRlZmluaWRhLlwiLFxuXHRcdGdlb21ldHJpY05hbWU6IFwiR2VvbcOpdHJpY2FcIixcblx0XHRnZW9tZXRyaWNTbmlwOiBcIkF1bWVudGEgYSBwcmVjaXPDo28gcG9zaWNpb25hbCBkZSB1bSBjb25qdW50byBkZSBkYWRvcyB0ZW5kbyBlbSBjb250YSBhIGVsZXZhw6fDo28uXCIsXG5cdFx0Z2VvbWV0cmljRGVzYzogXCJBIGZ1bsOnw6NvIEdlb23DqXRyaWNhIHByb2R1eiB1bWEgaW1hZ2VtIG9ydG9ycmV0aWZpY2FkYSBiYXNlYWRhIG51bWEgZGVmaW5pw6fDo28gZGUgdW0gc2Vuc29yIGUgbnVtIG1vZGVsbyBkZSB0ZXJyZW5vLiBBdW1lbnRhIGEgcHJlY2lzw6NvIHBvc2ljaW9uYWwgZGUgdW0gY29uanVudG8gZGUgZGFkb3MgdGVuZG8gZW0gY29udGEgYSBlbGV2YcOnw6NvLlwiLFxuXHRcdGdyYXlzY2FsZU5hbWU6IFwiRXNjYWxhIGRlIGNpbnplbnRvc1wiLFxuXHRcdGdyYXlzY2FsZVNuaXA6IFwiQ29udmVydGUgdW1hIGltYWdlbSBtdWx0aWJhbmRhIG51bWEgaW1hZ2VtIGVtIGVzY2FsYSBkZSBjaW56ZW50b3MgZGUgYmFuZGEgw7puaWNhLlwiLFxuXHRcdGdyYXlzY2FsZURlc2M6IFwiRXN0YSBmdW7Dp8OjbyBjb252ZXJ0ZSB1bWEgaW1hZ2VtIG11bHRpYmFuZGEgbnVtYSBpbWFnZW0gZW0gZXNjYWxhIGRlIGNpbnplbnRvcyBkZSBiYW5kYSDDum5pY2EuPGRpdj48YnIvPkVzdGEgZnVuw6fDo28gYXBsaWNhIG9zIHBlc29zIGVzcGVjaWZpY2Fkb3MgYSBjYWRhIHVtYSBkYXMgYmFuZGFzIGRlIGVudHJhZGEgZSBub3JtYWxpemEgYSBpbWFnZW0gZGUgc2HDrWRhLiBPcyBwZXNvcyBzw6NvIHBvciB2ZXplcyBhcGxpY2Fkb3MgZGV2aWRvIGFvIGZhY3RvIGRlIGFsZ3VtYXMgYmFuZGFzIHRlcmVtIHVtYSBpbXBvcnTDom5jaWEgdmFyacOhdmVsIGRlcGVuZGVuZG8gZGEgYXBsaWNhw6fDo28uIFBvciBleGVtcGxvLCBhIGJhbmRhIGF6dWwgY29udMOpbSBtdWl0YXMgdmV6ZXMgbWFpcyBydcOtZG8gZG8gcXVlIGFzIG91dHJhcyBiYW5kYXMuPC9kaXY+XCIsXG5cdFx0Z3JlYXRlclRoYW5FcXVhbE5hbWU6IFwiTWFpb3IgSWd1YWxcIixcblx0XHRncmVhdGVyVGhhbkVxdWFsU25pcDogXCJSZWFsaXphIHVtYSBvcGVyYcOnw6NvIG1haW9yLXF1ZS1pZ3VhbC1hIFJlbGFjaW9uYWwgZW0gZHVhcyBlbnRyYWRhcyBudW1hIGJhc2UgY8OpbHVsYSBhIGPDqWx1bGEuIERldm9sdmUgMSBwYXJhIGPDqWx1bGFzIG5hcyBxdWFpcyBvIHByaW1laXJvIHJhc3RlciDDqSBtYWlvciBvdSBpZ3VhbCBhbyBzZWd1bmRvIHJhc3RlciBlIDAgY2FzbyBpc3NvIG7Do28gYWNvbnRlw6dhLlwiLFxuXHRcdGdyZWF0ZXJUaGFuRXF1YWxEZXNjOiBcIkEgZnVuw6fDo28gcmVhbGl6YSB1bWEgb3BlcmHDp8OjbyBtYWlvci1xdWUtb3UtaWd1YWwtYSBSZWxhY2lvbmFsIGVtIGR1YXMgZW50cmFkYXMgbnVtYSBiYXNlIHDDrXhlbCBhIHDDrXhlbC4gRGV2b2x2ZSB1bSB2YWxvciBkZSAxIHBhcmEgcMOteGVpcyBub3MgcXVhaXMgbyBwcmltZWlybyByYXN0ZXIgw6kgbWFpb3Igb3UgaWd1YWwgcXVlIG8gc2VndW5kbyByYXN0ZXIgZSB1bSB2YWxvciBkZSAwIHBhcmEgcMOteGVpcyBub3MgcXVhaXMgbyBwcmltZWlybyByYXN0ZXIgbsOjbyDDqSBtYWlvciBvdSBpZ3VhbCBxdWUgbyBzZWd1bmRvIHJhc3Rlci5cIixcblx0XHRncmVhdGVyVGhhbk5hbWU6IFwiTWFpb3IgZG8gUXVlXCIsXG5cdFx0Z3JlYXRlclRoYW5TbmlwOiBcIlJlYWxpemEgdW1hIG9wZXJhw6fDo28gbWFpb3ItcXVlIFJlbGFjaW9uYWwgZW0gZHVhcyBlbnRyYWRhcyBudW1hIGJhc2UgY8OpbHVsYSBhIGPDqWx1bGEuIERldm9sdmUgMSBwYXJhIGPDqWx1bGFzIG5hcyBxdWFpcyBvIHByaW1laXJvIHJhc3RlciDDqSBtYWlvciBxdWUgbyBzZWd1bmRvIHJhc3RlciBlIDAgY2FzbyBpc3NvIG7Do28gYWNvbnRlw6dhLlwiLFxuXHRcdGdyZWF0ZXJUaGFuRGVzYzogXCJBIGZ1bsOnw6NvIHJlYWxpemEgdW1hIG9wZXJhw6fDo28gUmVsYWNpb25hbCBtYWlvciBkbyBxdWUgYSBvcGVyYcOnw6NvIGVtIGR1YXMgZW50cmFkYXMgbnVtYSBiYXNlIGRlIHDDrXhlbCBhIHDDrXhlbC4gRGV2b2x2ZSB1bSB2YWxvciBkZSAxIHBhcmEgcMOteGVpcyBub3MgcXVhaXMgbyBwcmltZWlybyByYXN0ZXIgw6kgbWFpb3IgcXVlIG8gc2VndW5kbyByYXN0ZXIgZSB1bSB2YWxvciBkZSAwIHBhcmEgcMOteGVpcyBub3MgcXVhaXMgbyBwcmltZWlybyByYXN0ZXIgbsOjbyDDqSBtYWlvciBxdWUgbyBzZWd1bmRvIHJhc3Rlci5cIixcblx0XHRoZWF0SW5kZXhOYW1lOiBcIsONbmRpY2UgZGUgQ2Fsb3JcIixcblx0XHRoZWF0SW5kZXhTbmlwOiBcIkNvbWJpbmUgYSB0ZW1wZXJhdHVyYSBhbWJpZW50ZSBlIGEgaHVtaWRhZGUgcmVsYXRpdmEgcGFyYSBkZXZvbHZlciBhIHRlbXBlcmF0dXJhIGFwYXJlbnRlLlwiLFxuXHRcdGhlYXRJbmRleERlc2M6IFwiRXN0YSBmdW7Dp8OjbyBjYWxjdWxhIGEgdGVtcGVyYXR1cmEgYXBhcmVudGUgY29tIGJhc2UgbmEgdGVtcGVyYXR1cmEgYW1iaWVudGUgZSBodW1pZGFkZSByZWxhdGl2YS4gQSB0ZW1wZXJhdHVyYSBhcGFyZW50ZSDDqSBtdWl0YXMgdmV6ZXMgZGVzY3JpdGEgY29tbyBhIHNlbnNhw6fDo28gdMOpcm1pY2EgZG8gY29ycG8gaHVtYW5vLjxkaXY+PGJyLz5Fc3RlIMOtbmRpY2UgcG9kZSBzZXIgw7p0aWwgcGFyYSBjYWxjdWxhciBvcyBwZXJpZ29zIHJlbGFjaW9uYWRvcyBjb20gcXVlc3TDtWVzIG3DqWRpY2FzIGNvbW8gY8OjaWJyYXMgbXVzY3VsYXJlcywgZGVzaWRyYXRhw6fDo28sIGV4YXVzdMOjbyBkbyBjYWxvciBvdSBhIGluc29sYcOnw6NvIG1haXMgZ3JhdmUgZW0gZGlhcyBxdWVudGVzIGUgaMO6bWlkb3MuIFF1YW5kbyBhIGh1bWlkYWRlIHJlbGF0aXZhIMOpIGVsZXZhZGEsIHRvcm5hLXNlIGNhZGEgdmV6IG1haXMgZGlmw61jaWwgYSBldmFwb3Jhw6fDo28gZG8gc3VvciBkbyBjb3JwbywgZGVpeGFuZG8gb3MgaW5kaXbDrWR1b3Mgc2VtIHVtYSBmb3JtYSBuYXR1cmFsIGUgZWZpY2F6IGRlIHNlIGFycmVmZWNlcmVtLiBNYXBhcyBkZSBhdmlzb3Mgb3UgZGUgaW5mb3JtYcOnw6NvIGRlIGNhbG9yIHPDo28gbXVpdGFzIHZlemVzIHVtIHByb2R1dG8gZGUgdW1hIG5vdmEgY2xhc3NpZmljYcOnw6NvIGRvIHJlc3VsdGFkbyBkbyBpbmRpY2Fkb3IgZGUgY2Fsb3IgZW0gY2xhc3NlcywgbmFzIHF1YWlzLCBxdWFudG8gbWFpb3IgbyB2YWxvciBpbmRpY2Fkb3IsIG1haXMgcHJvdsOhdmVsIMOpIHF1ZSBzZSB0b3JuZSBudW0gYXZpc28gZW0gdmV6IGRlIGFwZW5hcyB1bWEgaW5mb3JtYcOnw6NvLjwvZGl2PlwiLFxuXHRcdGhpbGxzaGFkZU5hbWU6IFwiU29tYnJlYW1lbnRvXCIsXG5cdFx0aGlsbHNoYWRlU25pcDogXCJDcmlhIHVtYSByZXByZXNlbnRhw6fDo28gM0QgZGEgc3VwZXJmw61jaWUsIGNvbSBhIHBvc2nDp8OjbyByZWxhdGl2YSBkbyBzb2wgdGlkYSBlbSBjb250YSBwYXJhIHNvbWJyZWFyIGEgaW1hZ2VtXCIsXG5cdFx0aGlsbHNoYWRlRGVzYzogXCJBIGZ1bsOnw6NvIEhpbGxzaGFkZSBwcm9kdXogdW1hIHJlcHJlc2VudGHDp8OjbyAzRCDDoCBlc2NhbGEgZGUgY2luemVudG9zIGRhIHN1cGVyZsOtY2llIGRvIHRlcnJlbm8sIGNvbSBhIHBvc2nDp8OjbyByZWxhdGl2YSBkbyBzb2wgdGlkYSBlbSBjb250YSBwYXJhIHNvbWJyZWFyIGEgaW1hZ2VtLiA8ZGl2Pjxici8+TyBzb21icmVhbWVudG8gw6kgdW1hIHTDqWNuaWNhIGRlIHZpc3VhbGl6YcOnw6NvIGRvIHRlcnJlbm8gZGV0ZXJtaW5hZGEgcG9yIHVtYSBmb250ZSBkZSBsdXogZSBwZWxhIGluY2xpbmHDp8OjbyBlIGFzcGV0byBkYSBzdXBlcmbDrWNpZSBkYSBlbGV2YcOnw6NvLiDDiSB1bSBtw6l0b2RvIHF1YWxpdGF0aXZvIHBhcmEgYSB2aXN1YWxpemHDp8OjbyB0b3BvZ3LDoWZpY2EgZSBuw6NvIG9mZXJlY2UgdmFsb3JlcyBhYnNvbHV0b3MgZGUgZWxldmHDp8Ojby4gPC9kaXY+XCIsXG5cdFx0aW50TmFtZTogXCJJbnRcIixcblx0XHRpbnRTbmlwOiBcIkNvbnZlcnRlIGNhZGEgdmFsb3IgZGUgY8OpbHVsYSBkZSB1bSByYXN0ZXIgbnVtIG7Dum1lcm8gaW50ZWlybyBwb3IgdHJ1bmNhZ2VtLlwiLFxuXHRcdGludERlc2M6IFwiQSBmdW7Dp8OjbyBJbnQgY29udmVydGUgY2FkYSB2YWxvciBkZSBww614ZWwgZGUgdW0gcmFzdGVyIG51bSBuw7ptZXJvIGludGVpcm8gcG9yIHRydW5jYWdlbS5cIixcblx0XHRpbnRlcnBvbGF0ZUlycmVndWxhckRhdGFOYW1lOiBcIkludGVycG9sYXIgRGFkb3MgSXJyZWd1bGFyZXNcIixcblx0XHRpbnRlcnBvbGF0ZUlycmVndWxhckRhdGFTbmlwOiBcIkludGVycG9sYSBhIHBhcnRpciBkZSBudXZlbnMgZGUgcG9udG9zIG91IGdyZWxoYXMgaXJyZWd1bGFyZXMuXCIsXG5cdFx0aW50ZXJwb2xhdGVJcnJlZ3VsYXJEYXRhRGVzYzogXCJBbGd1bnMgY29uanVudG9zIGRlIGRhZG9zIG5ldENERiBvdSBIREYgYXJtYXplbmFtIGEgc3VhIGdlb2xvY2FsaXphw6fDo28gY29tbyBkaXNwb3Npw6fDtWVzIGRlIGVzcGHDp2FtZW50byBpcnJlZ3VsYXIgZGUgcMOteGVpcyBvdSBkYWRvcyBkZSBwb250by4gQW8gYWRpY2lvbmFyIGVzdGVzIGNvbmp1bnRvcyBkZSBkYWRvcyBhIHVtIGNvbmp1bnRvIGRlIGRhZG9zIGRlIG1vc2FpY28sIGEgZnVuw6fDo28gZGUgaW50ZXJwb2xhw6fDo28gZGUgZGFkb3MgaXJyZWd1bGFyZXMgdG9tYSBvcyBkYWRvcyBpcnJlZ3VsYXJtZW50ZSBvcmdhbml6YWRvcyBlIGNyaWEgdW1hIG5vdmEgYW1vc3RyYSBkZSBmb3JtYSBhIHF1ZSBjYWRhIHDDrXhlbCBzZWphIHF1YWRyYWRvIGUgZGUgdW1hIGRpbWVuc8OjbyB1bmlmb3JtZS48ZGl2Pjxici8+QW8gYWRpY2lvbmFyIHZhcmnDoXZlaXMgZGUgbmV0Q0RGIG91IEhERiBhIHVtIGNvbmp1bnRvIGRlIGRhZG9zIGVtIG1vc2FpY28sIHZlcmlmaWNhcsOhIGF1dG9tYXRpY2FtZW50ZSBzZSBvcyBkYWRvcyBlc3TDo28gb3JkZW5hZG9zIHJlZ3VsYXJtZW50ZS4gQ2FzbyBuw6NvIGVzdGVqYW0sIGEgZnVuw6fDo28gZGUgaW50ZXJwb2xhw6fDo28gZGUgZGFkb3MgaXJyZWd1bGFyZXMgcG9kZSBzZXIgdXRpbGl6YWRhIHBhcmEgY29udmVydGVyIG9zIGRhZG9zIGlycmVndWxhcmVzIG51bSByYXN0ZXIgb3JnYW5pemFkbyBkZSBmb3JtYSByZWd1bGFyLiBQb2RlcsOhIGFsdGVyYXIgbyBtw6l0b2RvIGRlIGludGVycG9sYcOnw6NvIGUgYSBjw6lsdWxhIHV0aWxpemFkYSBuYSBmdW7Dp8OjbyBkZSBpbnRlcnBvbGHDp8OjbyBkbyByYXN0ZXIgZGUgZGFkb3MgaXJyZWd1bGFyZXMuIFBhcmEgZGFkb3MgZGUgcmFzdGVyIGRlIGVzcGHDp2FtZW50byByZWd1bGFyLCBuw6NvIHNlcsOhIGFwbGljYWRhIHF1YWxxdWVyIGludGVycG9sYcOnw6NvIGUgb3MgZGFkb3Mgc2Vyw6NvIGxpZG9zIGNvbmZvcm1lIGVzdMOjby48L2Rpdj5cIixcblx0XHRpc051bGxOYW1lOiBcIsOJIE51bG9cIixcblx0XHRpc051bGxTbmlwOiBcIkRldGVybWluYSBxdWFpcyB2YWxvcmVzIGRvcyByYXN0ZXJzIGRlIGVudHJhZGEgc8OjbyBOb0RhdGEgbnVtYSBiYXNlIGPDqWx1bGEgYSBjw6lsdWxhLiBEZXZvbHZlIHVtIHZhbG9yIGRlIDEgY2FzbyBvcyB2YWxvcmVzIGRlIGVudHJhZGEgc2VqYW0gTm9EYXRhIGUgMCBwYXJhIGPDqWx1bGFzIHF1ZSBuw6NvIHPDo28uXCIsXG5cdFx0aXNOdWxsRGVzYzogXCJBIEZ1bsOnw6NvIMOJIE51bG8gZGV0ZXJtaW5hIHF1YWlzIHZhbG9yZXMgZG8gcmFzdGVyIGRlIGVudHJhZGEgc8OjbyBOb0RhdGEgbnVtYSBiYXNlIHDDrXhlbCBhIHDDrXhlbC4gRGV2b2x2ZSB1bSB2YWxvciBkZSAxIGNhc28gbyB2YWxvciBkZSBlbnRyYWRhIHNlamEgTm9EYXRhIGUgdW0gdmFsb3IgZGUgMCBwYXJhIHDDrXhlaXMgcXVlIHPDo28gTm9EYXRhLlwiLFxuXHRcdGtlcm5lbERlbnNpdHlOYW1lOiBcIkRlbnNpZGFkZSBLZXJuZWxcIixcblx0XHRrZXJuZWxEZW5zaXR5U25pcDogXCJDYWxjdWxhIHVtYSDDoXJlYSBkZSBtYWduaXR1ZGUtcG9yLXVuaWRhZGUgYSBwYXJ0aXIgZGUgY2FyYWN0ZXLDrXN0aWNhcyBkZSB1bSBwb250byBvdSBwb2xpbGluaGFzIHV0aWxpemFuZG8gdW1hIGZ1bsOnw6NvIGtlcm5lbCBwYXJhIGVuY2FpeGFyIHVtYSBzdXBlcmbDrWNpZSBzdWF2ZW1lbnRlIGVzdGljYWRhIGF0w6kgY2FkYSBwb250byBvdSBwb2xpbGluaGEuXCIsXG5cdFx0a2VybmVsRGVuc2l0eURlc2M6IFwiRXN0YSBmdW7Dp8OjbyBjYWxjdWxhIHVtYSDDoXJlYSBkZSBtYWduaXR1ZGUtcG9yLXVuaWRhZGUgYSBwYXJ0aXIgZGUgY2FyYWN0ZXLDrXN0aWNhcyBkZSB1bSBwb250byBvdSBwb2xpbGluaGFzIHV0aWxpemFuZG8gdW1hIGZ1bsOnw6NvIGtlcm5lbCBwYXJhIGVuY2FpeGFyIHVtYSBzdXBlcmbDrWNpZSBzdWF2ZW1lbnRlIGVzdGljYWRhIGF0w6kgY2FkYSBwb250byBvdSBwb2xpbGluaGEuXCIsXG5cdFx0a2V5TWV0YWRhdGFOYW1lOiBcIk1ldGFkYWRvcyBjaGF2ZVwiLFxuXHRcdGtleU1ldGFkYXRhU25pcDogXCJTdWJzdGl0dWkgb3UgaW50cm9kdXogbWV0YWRhZG9zIGNoYXZlIGRlIHVtIHJhc3RlciBudW1hIGNhZGVpYSBkZSBmdW7Dp8O1ZXMuXCIsXG5cdFx0a2V5TWV0YWRhdGFEZXNjOiBcIkVzdGEgZnVuw6fDo28gcGVybWl0ZS1saGUgaW50cm9kdXppciBvdSBzdWJzdGl0dWlyIG1ldGFkYWRvcyBjaGF2ZSBkZSB1bSByYXN0ZXIuPGRpdj48YnIvPkEgaW5mb3JtYcOnw6NvIG5vcyBtZXRhZGFkb3MgY2hhdmUgw6kgdXRpbGl6YWRhIHBhcmEgYWp1ZGFyIGEgYXBsaWNhw6fDo28gY29tIGFsZ3VtIHByb2Nlc3NhbWVudG8gZSByZW5kZXJpemHDp8OjbywgaW5jbHVpbmRvIG8gZm9ybmVjaW1lbnRvIGRlIGFsZ3VtYXMgaW5mb3JtYcOnw7VlcyDDunRlaXMsIGNvbW8gbyBub21lIGRvIHNlbnNvciwgbm9tZXMgZGFzIGJhbmRhcyBvdSBhIG5lYnVsb3NpZGFkZSBhc3NvY2lhZGEgw6BzIGltYWdlbnMuPC9kaXY+XCIsXG5cdFx0c2hvcnRlc3RQYXRoTmFtZTogXCJQZXJjdXJzbyBkZSBNZW5vciBDdXN0b1wiLFxuXHRcdHNob3J0ZXN0UGF0aFNuaXA6IFwiRXhlY3V0YSB1bWEgYW7DoWxpc2UgZGUgZGlzdMOibmNpYSBkbyBjdXN0byB1dGlsaXphbmRvIGFzIGVudHJhZGFzIGRlIG9yaWdlbSBlIGRlc3Rpbm8gcXVlIMOpIGVudMOjbyB1dGlsaXphZGEgcGFyYSBkZXRlcm1pbmFyIG8gcGVyY3Vyc28gZGUgbWVub3IgY3VzdG8gYSBwYXJ0aXIgZGUgdW1hIG9yaWdlbSBhdMOpIHVtIGRlc3Rpbm8uXCIsXG5cdFx0c2hvcnRlc3RQYXRoRGVzYzogXCJBIGZ1bsOnw6NvIGRlIFBlcmN1cnNvIGRlIE1lbm9yIEN1c3RvIGNhbGN1bGEgbyBwZXJjdXJzbyBkZSBtZW5vciBjdXN0byBhIHBhcnRpciBkZSB1bWEgb3JpZ2VtIGF0w6kgdW0gZGVzdGluby4gQSBkaXN0w6JuY2lhIGNvbSBtZW5vciBjdXN0byBhY3VtdWxhZG8gw6kgY2FsY3VsYWRhIHBhcmEgY2FkYSBww614ZWwgYW8gbG9uZ28gZGUgdW1hIHN1cGVyZsOtY2llIGRlIGN1c3RvLCBhdMOpIMOgIG9yaWdlbSBtYWlzIHByw7N4aW1hLiBJc3RvIHByb2R1eiB1bSByYXN0ZXIgZGUgc2HDrWRhIHF1ZSByZWdpc3RhIG8gcGVyY3Vyc28gb3UgcGVyY3Vyc29zIGRlIG1lbm9yIGN1c3RvIGEgcGFydGlyIGRlIGxvY2FpcyBzZWxlY2lvbmFkb3MgYXTDqSBhb3MgcMOteGVpcyBkZSBvcmlnZW0gbWFpcyBwcsOzeGltb3MgZGVmaW5pZG9zIGRlbnRybyBkYSBzdXBlcmbDrWNpZSBkZSBjdXN0byBhY3VtdWxhZG8sIGVtIHRlcm1vcyBkZSBjdXN0byBkZSBkaXN0w6JuY2lhLjxkaXY+PGJyLz5BIGNhZGEgcGVyY3Vyc28gZGUgbWVub3IgY3VzdG8gw6kgYXRyaWJ1w61kbyB1bSB2YWxvciBxdWFuZG8gZW5jb250cmFkbyBubyBwcm9jZXNzbyBkZSBkaWdpdGFsaXphw6fDo28uIE8gcMOteGVsIGZpbmFsIG5hIFJhc3RlciBkZSBPcmlnZW0gZGUgcGVyY3Vyc28gZGUgY3VzdG8gcmVjZWJlIG8gdmFsb3IgZGUgMS4gTyBwcmltZWlybyBwZXJjdXJzbyByZWNlYmUgdW0gdmFsb3IgZGUgMywgbyBzZWd1bmRvIDQgZSBwb3IgYcOtIGFkaWFudGUuIFF1YW5kbyBtw7psdGlwbG9zIHBlcmN1cnNvcyBzZSBmdW5kZW0gZSBzZWd1ZW0gYSBkaXN0w6JuY2lhIHJlc3RhbnRlIGRlIHZvbHRhIGEgdW1hIG9yaWdlbSBwZWxvIG1lc21vIHBlcmN1cnNvLCBhbyBzZWdtZW50byBubyBxdWFsIG9zIGRvaXMgcGVyY3Vyc29zIHZpYWphbSBqdW50b3Mgw6kgYXRyaWJ1w61kbyBvIHZhbG9yIGRlIDIuIEEgcG9yw6fDo28gZnVuZGlkYSBkbyBwZXJjdXJzbyBuw6NvIHBvZGUgc2VyIHJlY2ViZXIgbyB2YWxvciBkZSB1bSBkb3MgcGVyY3Vyc29zLCB1bWEgdmV6IHF1ZSBhIHBvcsOnw6NvIHVuaWRhZGUgcGVydGVuY2UgYSBhbWJvcyBvcyBwZXJjdXJzb3MuPC9kaXY+XCIsXG5cdFx0bGVzc1RoYW5FcXVhbE5hbWU6IFwiTWVub3IgSWd1YWxcIixcblx0XHRsZXNzVGhhbkVxdWFsU25pcDogXCJSZWFsaXphIHVtYSBvcGVyYcOnw6NvIG1lbm9yLXF1ZS1vdSBpZ3VhbC1xdWUgUmVsYWNpb25hbCBlbSBkdWFzIGVudHJhZGFzIG51bWEgYmFzZSBjw6lsdWxhIGEgY8OpbHVsYS4gRGV2b2x2ZSAxIHBhcmEgY8OpbHVsYXMgbmFzIHF1YWlzIG8gcHJpbWVpcm8gcmFzdGVyIMOpIG1lbm9yIG91IGlndWFsIGFvIHNlZ3VuZG8gcmFzdGVyIGUgMCBjYXNvIGlzc28gbsOjbyBhY29udGXDp2EuXCIsXG5cdFx0bGVzc1RoYW5FcXVhbERlc2M6IFwiQSBmdW7Dp8OjbyByZWFsaXphIHVtYSBvcGVyYcOnw6NvIG1lbm9yLXF1ZS1vdS1pZ3VhbC1hIFJlbGFjaW9uYWwgZW0gZHVhcyBlbnRyYWRhcyBudW1hIGJhc2UgcMOteGVsIGEgcMOteGVsLiBEZXZvbHZlIHVtIHZhbG9yIGRlIDEgcGFyYSBww614ZWlzIG5vcyBxdWFpcyBvIHByaW1laXJvIHJhc3RlciDDqSBtZW5vciBvdSBpZ3VhbCBxdWUgbyBzZWd1bmRvIHJhc3RlciBlIHVtIHZhbG9yIGRlIDAgcXVhbmRvIG7Do28gw6kgbWVub3IgcXVlIG91IGlndWFsIHF1ZSBvIHNlZ3VuZG8gcmFzdGVyLlwiLFxuXHRcdGxlc3NUaGFuTmFtZTogXCJNZW5vciBkbyBxdWVcIixcblx0XHRsZXNzVGhhblNuaXA6IFwiUmVhbGl6YSB1bWEgb3BlcmHDp8OjbyBtZW5vci1xdWUgUmVsYWNpb25hbCBlbSBkdWFzIGVudHJhZGFzIG51bWEgYmFzZSBjw6lsdWxhIGEgY8OpbHVsYS4gRGV2b2x2ZSAxIHBhcmEgY8OpbHVsYXMgbmFzIHF1YWlzIG8gcHJpbWVpcm8gcmFzdGVyIMOpIG1lbm9yIHF1ZSBvIHNlZ3VuZG8gcmFzdGVyIGUgMCBjYXNvIGlzc28gbsOjbyBhY29udGXDp2EuXCIsXG5cdFx0bGVzc1RoYW5EZXNjOiBcIkEgZnVuw6fDo28gcmVhbGl6YSB1bWEgb3BlcmHDp8OjbyBtZW5vci1xdWUgUmVsYWNpb25hbCBlbSBkdWFzIGVudHJhZGFzIG51bWEgYmFzZSBww614ZWwgYSBww614ZWwuIERldm9sdmUgdW0gdmFsb3IgZGUgMSBwYXJhIHDDrXhlaXMgbm9zIHF1YWlzIG8gcHJpbWVpcm8gcmFzdGVyIMOpIG1lbm9yIHF1ZSBvIHNlZ3VuZG8gcmFzdGVyIGUgdW0gdmFsb3IgZGUgMCBxdWFuZG8gbsOjbyDDqSBtZW5vciBxdWUgbyBzZWd1bmRvIHJhc3Rlci5cIixcblx0XHRsbk5hbWU6IFwiTG5cIixcblx0XHRsblNuaXA6IFwiQ2FsY3VsYSBvIGxvZ2FyaXRtbyBuYXR1cmFsIChiYXNlIGUpIGRlIGPDqWx1bGFzIG51bSByYXN0ZXIuXCIsXG5cdFx0bG5EZXNjOiBcIkEgZnVuw6fDo28gTG4gY2FsY3VsYSBvIGxvZ2FyaXRtbyBuYXR1cmFsIChiYXNlIGUpIGRlIGNhZGEgcMOteGVsIG51bSByYXN0ZXIuXCIsXG5cdFx0bG9nMTBOYW1lOiBcIkxvZzEwXCIsXG5cdFx0bG9nMTBTbmlwOiBcIkNhbGN1bGEgbyBsb2dhcml0bW8gZW0gYmFzZSAxMCBkZSBjw6lsdWxhcyBudW0gcmFzdGVyLlwiLFxuXHRcdGxvZzEwRGVzYzogXCJBIGZ1bsOnw6NvIExvZzEwIGNhbGN1bGEgbyBsb2dhcml0bW8gZW0gYmFzZSAxMCBkZSBjYWRhIHDDrXhlbCBudW0gcmFzdGVyLlwiLFxuXHRcdGxvZzJOYW1lOiBcIkxvZzJcIixcblx0XHRsb2cyU25pcDogXCJDYWxjdWxhIG8gbG9nYXJpdG1vIGVtIGJhc2UgMiBkZSBjw6lsdWxhcyBudW0gcmFzdGVyLlwiLFxuXHRcdGxvZzJEZXNjOiBcIkEgZnVuw6fDo28gTG9nMiBjYWxjdWxhIG8gbG9nYXJpdG1vIGVtIGJhc2UgMiBkZSBjYWRhIHDDrXhlbCBudW0gcmFzdGVyLlwiLFxuXHRcdGxvb2t1cE5hbWU6IFwiUHJvY3VyYVwiLFxuXHRcdGxvb2t1cFNuaXA6IFwiQ3JpYSB1bSBub3ZvIHJhc3RlciBhbyBidXNjYXIgdmFsb3JlcyBlbmNvbnRyYWRvcyBub3V0cm8gY2FtcG8gbmEgdGFiZWxhIGRvIHJhc3RlciBkZSBlbnRyYWRhLlwiLFxuXHRcdGxvb2t1cERlc2M6IFwiQSBmdW7Dp8OjbyBjcmlhIHVtIG5vdm8gcmFzdGVyIGFvIGJ1c2NhciB2YWxvcmVzIGVuY29udHJhZG9zIG5vdXRybyBjYW1wbyBuYSB0YWJlbGEgZG8gcmFzdGVyIGRlIGVudHJhZGEuXCIsXG5cdFx0bWxDbGFzc2lmeU5hbWU6IFwiQ2xhc3NpZmljYXIgTUxcIixcblx0XHRtbENsYXNzaWZ5U25pcDogXCJDbGFzc2lmaWNhIGltYWdlbnMgdXRpbGl6YW5kbyB1bWEgYWJvcmRhZ2VtIHDDrXhlbCBhIHDDrXhlbC4gT3MgcMOteGVpcyBtaXN0dXJhZG9zIHPDo28gYXRyaWJ1w61kb3Mgw6AgY2FyYWN0ZXLDrXN0aWNhIGNvbSBtYWlvciBwZXJjZW50YWdlbSBuZXNzZSBww614ZWwuXCIsXG5cdFx0bWxDbGFzc2lmeURlc2M6IFwiQSBmdW7Dp8OjbyBDbGFzc2lmaWNhciBNTCBwZXJtaXRlLWxoZSByZWFsaXphciB1bWEgY2xhc3NpZmljYcOnw6NvIHN1cGVydmlzaW9uYWRhLCB1dGlsaXphbmRvIG8gYWxnb3JpdG1vIGRlIGNsYXNzaWZpY2HDp8OjbyBkZSBwcm9iYWJpbGlkYWRlIG3DoXhpbWEsIG51bSBjb25qdW50byBkZSBkYWRvcyBkZSByYXN0ZXIgb3UgY29uanVudG8gZGUgZGFkb3MgZGUgbW9zYWljby4gRXN0YSBmdW7Dp8OjbyBuZWNlc3NpdGEgZGUgdW0gZmljaGVpcm8gZGUgYXNzaW5hdHVyYSBkZSBjbGFzc2lmaWNhw6fDo28uXCIsXG5cdFx0bWFza05hbWU6IFwiTcOhc2NhcmFcIixcblx0XHRtYXNrU25pcDogXCJEZWZpbmUgdmFsb3JlcyBxdWUgbsOjbyBkZXNlamEgZXhpYmlyIG5vIHNldSByYXN0ZXIuXCIsXG5cdFx0bWFza0Rlc2M6IFwiRXN0YSBmdW7Dp8OjbyBkZSByYXN0ZXIgZGVmaW5lIHZhbG9yZXMgcXVlIG7Do28gZGVzZWphIGV4aWJpciBubyBzZXUgcmFzdGVyLiBVdGlsaXphbmRvIGEgZnVuw6fDo28gZGUgTcOhc2NhcmEsIGVzcGVjaWZpY2Fyw6EgdW0gb3UgbWFpcyB2YWxvcmVzIE5vRGF0YSBvdSB1bSBpbnRlcnZhbG8gZGUgdmFsb3JlcyBkZSBww614ZWwgdsOhbGlkb3MuIFwiLFxuXHRcdG1pbnVzTmFtZTogXCJNZW5vc1wiLFxuXHRcdG1pbnVzU25pcDogXCJTdWJ0cmFpIG8gdmFsb3IgZG8gc2VndW5kbyByYXN0ZXIgZGUgZW50cmFkYSBhIHBhcnRpciBkbyB2YWxvciBkbyBwcmltZWlybyByYXN0ZXIgZGUgZW50cmFkYSBudW1hIGJhc2UgY8OpbHVsYSBhIGPDqWx1bGEuXCIsXG5cdFx0bWludXNEZXNjOiBcIkEgZnVuw6fDo28gTWVub3Mgc3VidHJhaSBvIHZhbG9yIGRvIHNlZ3VuZG8gcmFzdGVyIGRlIGVudHJhZGEgYSBwYXJ0aXIgZG8gdmFsb3IgZG8gcHJpbWVpcm8gcmFzdGVyIGRlIGVudHJhZGEgbnVtYSBiYXNlIHDDrXhlbCBhIHDDrXhlbC5cIixcblx0XHRtb2ROYW1lOiBcIk1vZFwiLFxuXHRcdG1vZFNuaXA6IFwiRW5jb250cmEgbyByZXN0byAobcOzZHVsbykgZG8gcHJpbWVpcm8gcmFzdGVyIHF1YW5kbyBkaXZpZGlkbyBwZWxvIHNlZ3VuZG8gcmFzdGVyIG51bWEgYmFzZSBjw6lsdWxhIGEgY8OpbHVsYS5cIixcblx0XHRtb2REZXNjOiBcIkEgZnVuw6fDo28gTW9kIGVuY29udHJhIG8gcmVzdG8gKG3Ds2R1bG8pIGRvIHByaW1laXJvIHJhc3RlciBxdWFuZG8gZGl2aWRpZG8gcGVsbyBzZWd1bmRvIHJhc3RlciBudW1hIGJhc2UgcMOteGVsIGEgcMOteGVsLiBBIG9yZGVtIGRhcyBkdWFzIGVudHJhZGFzIMOpIGltcG9ydGFudGUgZSBhZmV0YSBvIHJlc3VsdGFkbyBkZSBzYcOtZGEuXCIsXG5cdFx0bW9zYWljUmFzdGVyc05hbWU6IFwiUmFzdGVycyBkZSBNb3NhaWNvXCIsXG5cdFx0bW9zYWljUmFzdGVyc1NuaXA6IFwiQ29sYSB1bSBncnVwbyBkZSBjb25qdW50b3MgZGUgZGFkb3MgcmFzdGVyIHBhcmEgY3JpYXIgdW0gY29uanVudG8gZGUgZGFkb3MuXCIsXG5cdFx0bW9zYWljUmFzdGVyc0Rlc2M6IFwiQSBmdW7Dp8OjbyBkZSBSYXN0ZXJzIGRlIE1vc2FpY28gY3JpYSB1bWEgaW1hZ2VtIGRlIG1vc2FpY28gYSBwYXJ0aXIgZGUgbcO6bHRpcGxhcyBpbWFnZW5zLiBRdWFuZG8gZXhpc3RlIHVtYSBzb2JyZXBvc2nDp8OjbyBlbnRyZSBpbWFnZW5zLCBleGlzdGVtIHbDoXJpb3MgbcOpdG9kb3MgZW50cmUgb3MgcXVhaXMgcG9kZXLDoSBlc2NvbGhlciBwYXJhIGRldGVybWluYXIgcXVhaXMgaW1hZ2VucyBzw6NvIGFwcmVzZW50YWRhcy5cIixcblx0XHRuZHZpQ29sb3JpemVkTmFtZTogXCJORFZJIENvbG9yaXphZG9cIixcblx0XHRuZHZpQ29sb3JpemVkU25pcDogXCJDcmlhIHVtIGNvbmp1bnRvIGRlIGRhZG9zIG11bHRpYmFuZGEgcXVlIHJlcHJlc2VudGEgYSBzYcO6ZGUgZGEgdmVnZXRhw6fDo28sIGJhc2VhZG8gbmEgZGlmZXJlbsOnYSBlbnRyZSBhcyBiYW5kYXMgdmVybWVsaGFzIGUgcXVhc2UgaW5mcmF2ZXJtZWxoYXMuXCIsXG5cdFx0bmR2aUNvbG9yaXplZERlc2M6IFwiQSBmdW7Dp8OjbyBORFZJIENvbG9yaXphZG8gYXBsaWNhIGEgZnVuw6fDo28gTkRWSSBuYSBpbWFnZW0gZGUgZW50cmFkYSBlIHV0aWxpemHDp8OjbyBlbnTDo28gdW0gbWFwYSBkZSBjb3JlcyBvdSByYW1wYSBkZSBjb3JlcyBwYXJhIGFwcmVzZW50YXIgbyByZXN1bHRhZG8uXCIsXG5cdFx0bmR2aU5hbWU6IFwiTkRWSVwiLFxuXHRcdG5kdmlTbmlwOiBcIkNhbGN1bGEgbyDDjW5kaWNlIGRlIFZlZ2V0YcOnw6NvIHBvciBEaWZlcmVuw6dhIE5vcm1hbGl6YWRhIChORFZJKS5cIixcblx0XHRuZHZpRGVzYzogXCJBIGZ1bsOnw6NvIE5EVkkgY3JpYSB1bSBjb25qdW50byBkZSBkYWRvcyBkZSBiYW5kYSDDum5pY2EgcXVlIHJlcHJlc2VudGEgYSBzYcO6ZGUgZGEgdmVnZXRhw6fDo28sIGJhc2VhZG8gbmEgZGlmZXJlbsOnYSBlbnRyZSBhcyBiYW5kYXMgdmVybWVsaGFzIGUgcXVhc2UgaW5mcmF2ZXJtZWxoYXMuPGRpdj48YnIvPk5EVkkgw6kgdW0gw61uZGljZSBwYWRyb25pemFkbyBxdWUgbGhlIHBlcm1pdGUgZ2VyYXIgdW1hIGltYWdlbSBxdWUgYXByZXNlbnRhIHZlcmRvciwgdGFtYsOpbSBjb25oZWNpZG8gY29tbyBiaW9tYXNzYSByZWxhdGl2YS4gRXN0ZSDDrW5kaWNlIHRpcmEgcGFydGlkbyBkbyBjb250cmFzdGUgZGUgY2FyYWN0ZXLDrXN0aWNhcyBlbnRyZSBkdWFzIGJhbmRhcyBhIHBhcnRpciBkZSB1bSBjb25qdW50byBkZSBkYWRvcyBkZSByYXN0ZXIgbXVsdGllc3BlY3RyYWlzOiBhIGFic29yw6fDo28gZG8gcGlnbWVudG8gZGUgY2xvcm9maWxhIG5hIGJhbmRhIHZlcm1lbGhhIGUgZWxldmFkYSByZWZsZXRpdmlkYWRlIGRlIG1hdGVyaWFsIHZlZ2V0YWwgbmEgYmFuZGEgcXVhc2UgaW5mcmF2ZXJtZWxoYSAoTklSKS4gVmFsb3JlcyBORFZJIGV4dHJlbWFtZW50ZSBiYWl4b3Mgb3UgbmVnYXRpdm9zIHJlcHJlc2VudGFtIMOhcmVhcyBzZW0gcXVhbHF1ZXIgdmVnZXRhw6fDo28sIGNvbW8gdW1hIG51dmVtLCDDoWd1YSBvdSBuZXZlLiBWYWxvcmVzIG11aXRvIGJhaXhvcyByZXByZXNlbnRhbSDDoXJlYXMgZGUgcG91Y2EgYSBuZW5odW1hIHZlZ2V0YcOnw6NvLCBjb21vIGNpbWVudG8sIHJvY2hhLCBvdSBzb2xvIGRlc2NvYmVydG8uIE9zIHZhbG9yZXMgbW9kZXJhZG9zIHJlcHJlc2VudGFtIMOhcmVhcyBkZSBhcmJ1c3RvcyBvdSByZWx2YS4gT3MgdmFsb3JlcyBlbGV2YWRvcyByZXByZXNlbnRhbSDDoXJlYXMgZGUgZmxvcmVzdGEgZSB2ZWdldGHDp8OjbyBmcm9uZG9zYS48L2Rpdj5cIixcblx0XHRuZWdhdGVOYW1lOiBcIk5lZ2FyXCIsXG5cdFx0bmVnYXRlU25pcDogXCJBbHRlcmEgbyBzaW5hbCAobXVsdGlwbGljYSBwb3IgLTEpIGRvcyB2YWxvcmVzIGRlIGPDqWx1bGEgZG8gcmFzdGVyIGRlIGVudHJhZGEgbnVtYSBiYXNlIGPDqWx1bGEgYSBjw6lsdWxhLlwiLFxuXHRcdG5lZ2F0ZURlc2M6IFwiQSBmdW7Dp8OjbyBOZWdhciBhbHRlcmEgbyBzaW5hbCAobXVsdGlwbGljYSBwb3IgLTEpIGRvcyB2YWxvcmVzIGRlIHDDrXhlbCBkbyByYXN0ZXIgZGUgZW50cmFkYSBudW0gcMOteGVsIFwiLFxuXHRcdG5pYmJsZU5hbWU6IFwiTmliYmxlXCIsXG5cdFx0bmliYmxlU25pcDogXCJTdWJzdGl0dWkgY8OpbHVsYXMgZGUgdW0gcmFzdGVyIHF1ZSBjb3JyZXNwb25kZSBhIHVtYSBtw6FzY2FyYSBjb20gb3MgdmFsb3JlcyBkb3Mgdml6aW5ob3MgbWFpcyBwcsOzeGltb3MuXCIsXG5cdFx0bmliYmxlRGVzYzogXCJBIGZ1bsOnw6NvIGdsb2JhbCBOaWJibGUgcGVybWl0ZSBhIGF0cmlidWnDp8OjbyBkbyB2YWxvciBkbyBzZXUgdml6aW5obyBtYWlzIHByw7N4aW1vIGEgw6FyZWFzIHNlbGVjaW9uYWRhcyBkZSB1bSByYXN0ZXIuIElzdG8gw6kgw7p0aWwgcGFyYSBhIGVkacOnw6NvIGRlIMOhcmVhcyBkZSB1bSByYXN0ZXIgbm8gcXVhbCBvcyBkYWRvcyBwb2RlcsOjbyBzZXIgZXJyw7NuZW9zLlwiLFxuXHRcdG5vdEVxdWFsTmFtZTogXCJOw6NvIElndWFsXCIsXG5cdFx0bm90RXF1YWxTbmlwOiBcIlJlYWxpemEgdW1hIG9wZXJhw6fDo28gZGlmZXJlbnRlLWRlIHJlbGFjaW9uYWwgZW0gZHVhcyBlbnRyYWRhcyBudW1hIGJhc2UgY8OpbHVsYSBhIGPDqWx1bGEuIERldm9sdmUgMSBwYXJhIGPDqWx1bGFzIG5hcyBxdWFpcyBvIHByaW1laXJvIHJhc3RlciDDqSBkaWZlcmVudGUtZGUgYW8gc2VndW5kbyByYXN0ZXIgZSAwIGNhc28gc2VqYSBpZ3VhbC5cIixcblx0XHRub3RFcXVhbERlc2M6IFwiQSBmdW7Dp8OjbyByZWFsaXphIHVtYSBvcGVyYcOnw6NvIGRlIGRpZmVyZW50ZS1kZSBSZWxhY2lvbmFsIGVtIGR1YXMgZW50cmFkYXMgbnVtYSBiYXNlIHDDrXhlbCBhIHDDrXhlbC4gRGV2b2x2ZSB1bSB2YWxvciBkZSAxIHBhcmEgcMOteGVpcyBub3MgcXVhaXMgbyBwcmltZWlybyByYXN0ZXIgw6kgZGlmZXJlbnRlIGRvIHNlZ3VuZG8gcmFzdGVyIGUgdW0gdmFsb3IgZGUgMCBwYXJhIHDDrXhlaXMgcXVhbmRvIMOpIGlndWFsIGFvIHNlZ3VuZG8gcmFzdGVyLlwiLFxuXHRcdHBhbnNoYXJwZW5pbmdOYW1lOiBcIk5pdGlkZXogcGFuY3JvbcOhdGljYVwiLFxuXHRcdHBhbnNoYXJwZW5pbmdTbmlwOiBcIk1lbGhvcmEgYXJ0aWZpY2lhbG1lbnRlIGEgcmVzb2x1w6fDo28gZXNwYWNpYWwgZGUgdW1hIGltYWdlbSBtdWx0aWJhbmRhIGZ1bmRpbmRvLWEgY29tIHVtYSBpbWFnZW0gcGFuY3JvbcOhdGljYSBkZSBtYWlvciByZXNvbHXDp8Ojby5cIixcblx0XHRwYW5zaGFycGVuaW5nRGVzYzogXCJBIGZ1bsOnw6NvIFBhbnNoYXJwZW5pbmcgdXRpbGl6YSB1bWEgaW1hZ2VtIHBhbmNyb23DoXRpY2EgZGUgYWx0YSByZXNvbHXDp8OjbyBvdSBiYW5kYSBkZSByYXN0ZXIgcGFyYSBxdWUgc2UgZnVuZGEgY29tIHVtYSByZXNvbHXDp8OjbyBtYWlzIGJhaXhhLCBjb25qdW50byBkZSBkYWRvcyBkZSByYXN0ZXIgbXVsdGliYW5kYSBwYXJhIGF1bWVudGFyIGEgcmVzb2x1w6fDo28gZXNwYWNpYWwgZGEgaW1hZ2VtIG11bHRpYmFuZGEuPGRpdj48YnIvPk8gb2JqZXRpdm8gZG8gYWp1c3RlIGRhIG5pdGlkZXogw6kgY3JpYXIgdW1hIGltYWdlbSB2aXN1YWwgZGUgbWFpb3IgcXVhbGlkYWRlLiBVbWEgdmV6IHF1ZSBhcyB0w6ljbmljYXMgYWx0ZXJhbSBhIHJhZGlvbWV0cmlhIGUgY2FyYWN0ZXLDrXN0aWNhcyBlc3BlY3RyYWlzIGRhcyBpbWFnZW5zIG11bHRpYmFuZGEsIGFzIGltYWdlbnMgXFxcInBhbiBzaGFycGVuZWRcXFwiIG5lY2Vzc2l0YW0gZGUgc2VyIHV0aWxpemFkYXMgY29tIGN1aWRhZG8gcGFyYSBmaW5zIGRlIGRldGXDp8OjbyByZW1vdGEgYW5hbMOtdGljYS48L2Rpdj5cIixcblx0XHRwYXRoQWxsb2NhdGlvbk5hbWU6IFwiQXRyaWJ1acOnw6NvIGRlIERpc3TDom5jaWEgZGUgUGVyY3Vyc29cIixcblx0XHRwYXRoQWxsb2NhdGlvblNuaXA6IFwiQ2FsY3VsYSBhIG9yaWdlbSBkZSBtZW5vciBjdXN0byBwYXJhIGNhZGEgY8OpbHVsYSBjb20gYmFzZSBubyBtZW5vciBjdXN0byBhY3VtdWxhZG8gYW8gbG9uZ28gZGUgdW1hIHN1cGVyZsOtY2llIGRlIGN1c3RvLCB0ZW5kbyBlbSBjb250YSBhIGRpc3TDom5jaWEgZGEgc3VwZXJmw61jaWUgZSBmYXRvcmVzIGRlIGN1c3RvIGhvcml6b250YWwgZSB2ZXJ0aWNhbC5cIixcblx0XHRwYXRoQWxsb2NhdGlvbkRlc2M6IFwiQSBmdW7Dp8OjbyBkZSBBdHJpYnVpw6fDo28gZGUgRGlzdMOibmNpYSBkZSBQZXJjdXJzbyBjYWxjdWxhIGEgb3JpZ2VtIG1haXMgcHLDs3hpbWEgcGFyYSBjYWRhIGPDqWx1bGEgY29tIGJhc2Ugbm8gbWVub3IgY3VzdG8gYWN1bXVsYWRvIGFvIGxvbmdvIGRlIHVtYSBzdXBlcmbDrWNpZSBkZSBjdXN0bywgdGVuZG8gZW0gY29udGEgYSBkaXN0w6JuY2lhIGRhIHN1cGVyZsOtY2llIGUgZmF0b3JlcyBkZSBjdXN0byBob3Jpem9udGFsIGUgdmVydGljYWwuXCIsXG5cdFx0cGF0aEJhY2tMaW5rTmFtZTogXCJMaWdhw6fDo28gZGUgTWVub3IgRGlzdMOibmNpYSBkZSBQZXJjdXJzb1wiLFxuXHRcdHBhdGhCYWNrTGlua1NuaXA6IFwiRGVmaW5lIG8gdml6aW5obyBxdWUgw6kgYSBjw6lsdWxhIHNlZ3VpbnRlIG5vIHBlcmN1cnNvIGRlIG1lbm9yIGN1c3RvIGFjdW11bGFkbyBhdMOpIMOgIG9yaWdlbSBjb20gbWVub3IgY3VzdG8sIHRlbmRvIGVtIGNvbnRhIGEgZGlzdMOibmNpYSBkYSBzdXBlcmbDrWNpZSBqdW50YW1lbnRlIGNvbSBvcyBmYXRvcmVzIGRlIGN1c3RvIGhvcml6b250YWwgZSB2ZXJ0aWNhbC5cIixcblx0XHRwYXRoQmFja0xpbmtEZXNjOiBcIkEgZnVuw6fDo28gTGlnYcOnw6NvIGRlIE1lbm9yIERpc3TDom5jaWEgZGUgUGVyY3Vyc28gaWRlbnRpZmljYSBhIGRpcmVjaW9uYWxpZGFkZSBkbyB2aXppbmhvIHF1ZSDDqSBhIGPDqWx1bGEgc2VndWludGUgbm8gcGVyY3Vyc28gZGUgbWVub3IgY3VzdG8gYWN1bXVsYWRvIGF0w6kgw6Agb3JpZ2VtIG1haXMgcHLDs3hpbWEsIHRlbmRvIGVtIGNvbnRhIGEgZGlzdMOibmNpYSBkYSBzdXBlcmbDrWNpZSBlIGZhdG9yZXMgZGUgY3VzdG8gaG9yaXpvbnRhbCBlIHZlcnRpY2FsLlwiLFxuXHRcdHBhdGhEaXN0YW5jZU5hbWU6IFwiRGlzdMOibmNpYSBkZSBQZXJjdXJzb1wiLFxuXHRcdHBhdGhEaXN0YW5jZVNuaXA6IFwiQ2FsY3VsYSwgcGFyYSBjYWRhIGPDqWx1bGEsIGEgZGlzdMOibmNpYSBjb20gbWVub3IgY3VzdG8gYWN1bXVsYWRvIGRlc2RlIG91IHBhcmEgYSBvcmlnZW0gY29tIG1lbm9yIGN1c3RvLCB0ZW5kbyBlbSBjb250YSBhIGRpc3TDom5jaWEgZGEgc3VwZXJmw61jaWUganVudGFtZW50ZSBjb20gb3MgZmF0b3JlcyBkZSBjdXN0byBob3Jpem9udGFsIGUgdmVydGljYWwuXCIsXG5cdFx0cGF0aERpc3RhbmNlRGVzYzogXCJBIGZ1bsOnw6NvIERpc3TDom5jaWEgZGUgUGVyY3Vyc28gY2FsY3VsYSwgcGFyYSBjYWRhIGPDqWx1bGEsIGEgZGlzdMOibmNpYSBjb20gbWVub3IgY3VzdG8gYWN1bXVsYWRvIHBhcmEgYSBvcmlnZW0gbWFpcyBwcsOzeGltYSwgdGVuZG8gZW0gY29udGEgYSBkaXN0w6JuY2lhIGRhIHN1cGVyZsOtY2llIGUgZmF0b3JlcyBkZSBjdXN0byBob3Jpem9udGFsIGUgdmVydGljYWwuXCIsXG5cdFx0cGx1c05hbWU6IFwiTWFpc1wiLFxuXHRcdHBsdXNTbmlwOiBcIkFkaWNpb25hIChzb21hKSBvcyB2YWxvcmVzIGRlIGRvaXMgcmFzdGVycyBudW1hIGJhc2UgY8OpbHVsYSBhIGPDqWx1bGEuXCIsXG5cdFx0cGx1c0Rlc2M6IFwiQSBmdW7Dp8OjbyBTb21hIGFkaWNpb25hIChzb21hKSBvcyB2YWxvcmVzIGRlIGRvaXMgcmFzdGVycyBudW1hIGJhc2UgcMOteGVsIGEgcMOteGVsLlwiLFxuXHRcdHBvd2VyTmFtZTogXCJQb3TDqm5jaWFcIixcblx0XHRwb3dlclNuaXA6IFwiRWxldmEgb3MgdmFsb3JlcyBkYXMgY8OpbHVsYXMgbnVtIHJhc3RlciDDoCBwb3TDqm5jaWEgZG9zIHZhbG9yZXMgZW5jb250cmFkb3Mgbm91dHJvIHJhc3Rlci5cIixcblx0XHRwb3dlckRlc2M6IFwiQSBmdW7Dp8OjbyBQb3TDqm5jaWEgZWxldmEgb3MgdmFsb3JlcyBkZSBww614ZWwgbnVtIHJhc3RlciDDoCBwb3TDqm5jaWEgZG9zIHZhbG9yZXMgZW5jb250cmFkb3Mgbm91dHJvIHJhc3Rlci5cIixcblx0XHRyYWRhckNhbGlicmF0aW9uTmFtZTogXCJDYWxpYnJhw6fDo28gZGUgUmFkYXJcIixcblx0XHRyYWRhckNhbGlicmF0aW9uU25pcDogXCJDb252ZXJ0ZSBhIHJldHJvZGlmdXPDo28gZG8gUkFEQVJTQVQtMi5cIixcblx0XHRyYWRhckNhbGlicmF0aW9uRGVzYzogXCJFc3RhIGZ1bsOnw6NvIHBvZGUgc2VyIHV0aWxpemFkYSBwYXJhIGNhbGlicmFyIGltYWdlbnMgZG8gUkFEQVJTQVQtMiBudW0gY29uanVudG8gZGUgZGFkb3MgZW0gbW9zYWljbyBvdSBjb21vIHVtIHByb2R1dG8gcmFzdGVyLiBBIGNhbGlicmFnZW0gw6kgcmVhbGl6YWRhIG5hcyBpbWFnZW5zIGRlIHJhZGFyIGRlIGZvcm1hIGEgcXVlIG9zIHZhbG9yZXMgZG9zIHDDrXhlaXMgc2VqYW0gdW1hIHJlcHJlc2VudGHDp8OjbyB2ZXJkYWRlaXJhIGRhIHJldHJvZGlmdXPDo28gZG8gcmFkYXIuXCIsXG5cdFx0cmFzdGVySW5mb05hbWU6IFwiSW5mb3JtYcOnw6NvIGRlIFJhc3RlclwiLFxuXHRcdHJhc3RlckluZm9TbmlwOiBcIk1vZGlmaWNhIHByb3ByaWVkYWRlcyBkbyByYXN0ZXIsIHRhaXMgY29tbyBhIHByb2Z1bmRpZGFkZSBkbyBiaXQsIHVtIHZhbG9yIE5vRGF0YSwgbyB0YW1hbmhvIGRhIGPDqWx1bGEsIGV0Yy5cIixcblx0XHRyYXN0ZXJJbmZvRGVzYzogXCJBIEluZm9ybWHDp8OjbyBkZSBSYXN0ZXIgYWJyZSB1bWEgY2FpeGEgZGUgZGnDoWxvZ28gY29tIHByb3ByaWVkYWRlcyBkbyBjb25qdW50byBkZSBkYWRvcyByYXN0ZXIsIHRhaXMgY29tbyBvIG7Dum1lcm8gZGUgY29sdW5hcyBlIGxpbmhhcywgbyBuw7ptZXJvIGRlIGJhbmRhcywgbyB0aXBvIGRlIHDDrXhlbCwgYSBleHRlbnPDo28gZSBhIHJlZmVyw6puY2lhIGVzcGFjaWFsLiBQb2RlIGVkaXRhciBlc3RhcyBwcm9wcmllZGFkZXMgc2VsZWNpb25hbmRvIHVtIGNvbmp1bnRvIGRlIGRhZG9zIHJhc3RlciBwYXJhIHV0aWxpemFyIGNvbW8gbW9kZWxvLiBcIixcblx0XHRyYXN0ZXJpemVBdHRyaWJ1dGVzTmFtZTogXCJSYXN0ZXJpemFyIEF0cmlidXRvc1wiLFxuXHRcdHJhc3Rlcml6ZUF0dHJpYnV0ZXNTbmlwOiBcIlBvdGVuY2lhIHVtIHJhc3RlciBhdHJhdsOpcyBkZSBiYW5kYXMgYWRpY2lvbmFpcyBkZXJpdmFkYXMgZGUgdmFsb3JlcyBkZSBhdHJpYnV0b3MgZXNwZWNpZmljYWRvcyBkZSB1bWEgdGFiZWxhIGV4dGVybmEgb3UgZGUgdW0gc2VydmnDp28gZGUgZnVuY2lvbmFsaWRhZGUuXCIsXG5cdFx0cmFzdGVyaXplQXR0cmlidXRlc0Rlc2M6IFwiQSBmdW7Dp8OjbyBSYXN0ZXJpemFyIEF0cmlidXRvIHBvdGVuY2lhIHVtIHJhc3RlciBhZGljaW9uYW5kbyBiYW5kYXMgZGVyaXZhZGFzIGRlIHZhbG9yZXMgZGUgYXRyaWJ1dG9zIGVzcGVjaWZpY2Fkb3MsIGRlIHVtYSB0YWJlbGEgZXh0ZXJuYSBvdSBkZSB1bSBzZXJ2acOnbyBkZSBmdW5jaW9uYWxpZGFkZS4gUG9kZSBvcGNpb25hbG1lbnRlIGVzcGVjaWZpY2FyIHVtIHJhc3RlciBkZSB6b25hIGUgbyBhdHJpYnV0byBkZSBpZGVudGlmaWNhw6fDo28gZGUgem9uYSBhc3NvY2lhZG8gcGFyYSBwZXJtaXRpciBjb25zdWx0YXMgYmFzZWFkYXMgZW0gcmVnacO1ZXMuXCIsXG5cdFx0cmFzdGVyaXplRmVhdHVyZUNsYXNzTmFtZTogXCJSYXN0ZXJpemFyIEZ1bmNpb25hbGlkYWRlc1wiLFxuXHRcdHJhc3Rlcml6ZUZlYXR1cmVDbGFzc1NuaXA6IFwiQ29udmVydGUgZnVuY2lvbmFsaWRhZGVzIG51bSByYXN0ZXIuXCIsXG5cdFx0cmFzdGVyaXplRmVhdHVyZUNsYXNzRGVzYzogXCJFc3RhIGZ1bsOnw6NvIGNvbnZlcnRlIGRhZG9zIGRlIGNsYXNzZXMgZGUgZnVuY2lvbmFsaWRhZGUgZGUgcG9sw61nb25vcywgcG9saWxpbmhhcyBlIHBvbnRvcyBudW1hIGNhbWFkYSByYXN0ZXIuPGRpdj48YnIvPlPDo28gYXRyaWJ1w61kb3MgdmFsb3JlcyBkZSBww614ZWlzIGFvcyBlbGVtZW50b3MgY29tIGJhc2UgZW0gT0JKRUNUSUQgZG9zIGVsZW1lbnRvcyAocGFkcsOjbykuIE9wY2lvbmFsbWVudGUsIG9zIHZhbG9yZXMgZGUgcMOteGVpcyBwb2RlbSBzZXIgYmFzZWFkb3MgbnVtIGNhbXBvIGRlIHZhbG9yIGRlZmluaWRvIHBlbG8gdXRpbGl6YWRvciBuYSB0YWJlbGEgZGUgYXRyaWJ1dG9zIGRlIGZ1bmNpb25hbGlkYWRlcyBkZSBlbnRyYWRhLjwvZGl2PlwiLFxuXHRcdHJlY2FzdE5hbWU6IFwiUmVmb3JtdWxhclwiLFxuXHRcdHJlY2FzdFNuaXA6IFwiTW9kaWZpY2Egb3MgcGFyw6JtZXRyb3MgZGUgdW1hIGNhZGVpYSBkZSBmdW7Dp8O1ZXMgbnVtIGNvbmp1bnRvIGRlIGRhZG9zIGVtIG1vc2FpY28gb3UgbnVtIHNlcnZpw6dvIGRlIGltYWdlbnMuIElzdG8gw6kgZnJlcXVlbnRlbWVudGUgdXRpbGl6YWRvIGNvbSBjb25qdW50b3MgZGUgZGFkb3MgTEFTIHBhcmEgZXZpdGFyIHRlciBkZSBzZSBjcmlhciB1bSBjb25qdW50byBkZSBkYWRvcyBlbSBtb3NhaWNvIHNlcGFyYWRvIHBhcmEgZGlmZXJlbnRlcyByZXByZXNlbnRhw6fDtWVzIGRvIHRlcnJlbm8uXCIsXG5cdFx0cmVjYXN0RGVzYzogXCJBIGZ1bsOnw6NvIFJlZm9ybXVsYXIgw6kgdXRpbGl6YWRhIHBhcmEgbW9kaWZpY2FyIGRpbmFtaWNhbWVudGUgbyBwYXLDom1ldHJvIGRlIGZ1bsOnw6NvIHV0aWxpemFkbyBudW0gY29uanVudG8gZGUgZGFkb3MgZW0gbW9zYWljbyBvdSBudW0gc2VydmnDp28gZGUgaW1hZ2VucyBzZW0gcXVlIGFzIGFsdGVyYcOnw7VlcyBwZXJzaXN0YW0gZmlzaWNhbWVudGUuXCIsXG5cdFx0cmVnaW9uR3JvdXBOYW1lOiBcIkdydXBvIGRlIFJlZ2nDtWVzXCIsXG5cdFx0cmVnaW9uR3JvdXBTbmlwOiBcIlBhcmEgY2FkYSBjw6lsdWxhIG5hIHNhw61kYSwgw6kgcmVnaXN0YWRhIGEgaWRlbnRpZGFkZSBkYSByZWdpw6NvIGxpZ2FkYSDDoCBxdWFsIGVzc2EgY8OpbHVsYSBwZXJ0ZW5jZS4gVW0gw7puaWNvIG7Dum1lcm8gw6kgYXRyaWJ1w61kbyBhIGNhZGEgcmVnacOjby5cIixcblx0XHRyZWdpb25Hcm91cERlc2M6IFwiQSBmdW7Dp8OjbyBnbG9iYWwgR3J1cG8gZGUgUmVnacO1ZXMgcmVnaXN0YSwgcGFyYSBjYWRhIGPDqWx1bGEgbmEgc2HDrWRhLCBhIGlkZW50aWRhZGUgZGEgcmVnacOjbyBsaWdhZGEgw6AgcXVhbCBlc3NhIGPDqWx1bGEgcGVydGVuY2UuIFVtIMO6bmljbyBuw7ptZXJvIMOpIGF0cmlidcOtZG8gYSBjYWRhIHJlZ2nDo28uPGRpdj48YnIvPkEgcHJpbWVpcmEgcmVnacOjbyBsaWRhIHJlY2ViZSBvIHZhbG9yIGRlIHVtLCBhIHNlZ3VuZGEgZGUgZG9pcywgZSBhc3NpbSBzdWNlc3NpdmFtZW50ZSwgYXTDqSBxdWUgc2VqYSBhdHJpYnXDrWRvIHVtIHZhbG9yIGEgdG9kYXMgYXMgcmVnacO1ZXMuIEEgbGVpdHVyYSB2YWkgZGEgZXNxdWVyZGEgcGFyYSBhIGRpcmVpdGEsIGRlIGNpbWEgcGFyYSBiYWl4by4gT3MgdmFsb3JlcyBhdHJpYnXDrWRvcyDDoHMgem9uYXMgZGUgc2HDrWRhIHTDqm0gcG9yIGJhc2UgbyBtb21lbnRvIGVtIHF1ZSBzw6NvIGVuY29udHJhZG9zIG5vIHByb2Nlc3NvIGRlIGxlaXR1cmEuPC9kaXY+XCIsXG5cdFx0cmVnaW9uR3Jvd05hbWU6IFwiQ3Jlc2NpbWVudG8gZGUgUmVnacOjb1wiLFxuXHRcdHJlZ2lvbkdyb3dTbmlwOiBcIkRlc2Vudm9sdmUgcmVnacO1ZXMgYSBwYXJ0aXIgZGUgcG9udG9zIGluaWNpYWlzLlwiLFxuXHRcdHJlZ2lvbkdyb3dEZXNjOiBcIkEgZnVuw6fDo28gQ3Jlc2NpbWVudG8gZGUgUmVnacOjbyBhZ3J1cGEgcMOteGVpcyBhZGphY2VudGVzIGVtIGdydXBvcywgZGVwZW5kZW5kbyBkbyByYWlvIGVzcGVjaWZpY2FkbyBhIHBhcnRpciBkbyBwb250byBpbmljaWFsLiDDiSBhdHJpYnXDrWRvIGFvIGdydXBvIGRlIHDDrXhlaXMgb3UgYW8gb2JqZXRvIHVtIHZhbG9yIGRlIHByZWVuY2hpbWVudG8gZXNwZWNpZmljYWRvLlwiLFxuXHRcdHJlbWFwTmFtZTogXCJSZW1hcGVhclwiLFxuXHRcdHJlbWFwU25pcDogXCJBbHRlcmEgb3MgdmFsb3JlcyBkZSBww614ZWlzIGF0cmlidWluZG8gbm92b3MgdmFsb3JlcyBhIGludGVydmFsb3MgZGUgdmFsb3JlcyBkZSBww614ZWlzIG91IHV0aWxpemFuZG8gdW1hIHRhYmVsYSBleHRlcm5hLlwiLFxuXHRcdHJlbWFwRGVzYzogXCJBIGZ1bsOnw6NvIFJlbWFwZWFyIHBlcm1pdGUtbGhlIGFsdGVyYXIgb3UgcmVjbGFzc2lmaWNhciBvcyB2YWxvcmVzIGRvcyBww614ZWlzIGRvcyBkYWRvcyBkZSByYXN0ZXIuIElzdG8gcG9kZSBzZXIgZmVpdG8gcXVlciBlc3BlY2lmaWNhbmRvIHVtIGludGVydmFsbyBkZSB2YWxvcmVzIGRlIHDDrXhlaXMgcGFyYSBtYXBlYXIgcGFyYSB1bSB2YWxvciBkZSBww614ZWwgZGUgc2HDrWRhLCBxdWVyIHV0aWxpemFuZG8gdW1hIHRhYmVsYSBwYXJhIG1hcGVhciBvcyB2YWxvcmVzIGRlIHDDrXhlaXMgcGFyYSBvIHZhbG9yIGRlIHDDrXhlbCBkZSBzYcOtZGEuXCIsXG5cdFx0cmVwcm9qZWN0TmFtZTogXCJSZXByb2pldGFyXCIsXG5cdFx0cmVwcm9qZWN0U25pcDogXCJNb2RpZmljYSBhIHByb2plw6fDo28gZGUgdW0gY29uanVudG8gZGUgZGFkb3MgcmFzdGVyLCBjb25qdW50byBkZSBkYWRvcyBlbSBtb3NhaWNvLCBvdSBpdGVtIHJhc3RlciBudW0gY29uanVudG8gZGUgZGFkb3MgZW0gbW9zYWljby4gVGFtYsOpbSBjb25zZWd1ZSBnZXJhciB1bWEgbm92YSBhbW9zdHJhIGRvcyBkYWRvcyBwYXJhIHVtIG5vdm8gdGFtYW5obyBkYSBjw6lsdWxhIGUgZGVmaW5pciB1bWEgb3JpZ2VtLlwiLFxuXHRcdHJlcHJvamVjdERlc2M6IFwiQSBmdW7Dp8OjbyBSZXByb2pldGFyIG1vZGlmaWNhIGEgcHJvamXDp8OjbyBkZSB1bSBjb25qdW50byBkZSBkYWRvcyByYXN0ZXIsIGNvbmp1bnRvIGRlIGRhZG9zIGVtIG1vc2FpY28sIG91IGl0ZW0gcmFzdGVyIG51bSBjb25qdW50byBkZSBkYWRvcyBlbSBtb3NhaWNvLiBUYW1iw6ltIGNvbnNlZ3VlIGdlcmFyIHVtYSBub3ZhIGFtb3N0cmEgZG9zIGRhZG9zIHBhcmEgdW0gbm92byB0YW1hbmhvIGRhIGPDqWx1bGEgZSBkZWZpbmlyIHVtYSBvcmlnZW0uPGRpdj48YnIvPkEgZnVuw6fDo28gUmVwcm9qZXRhciBwb2RlIHNlciB1dGlsaXphZGEgcXVhbmRvIHNlIGNyaWEgdW1hIGNhY2hlIGEgcGFydGlyIGRlIHVtIGNvbmp1bnRvIGRlIGRhZG9zIHJhc3RlciBvdSBtb3NhaWNvIHF1ZSBuw6NvIHNlIGVuY29udHJhIG5hIHByb2plw6fDo28gcmVxdWVyaWRhLiBQb3IgZXhlbXBsbywgYW8gY3JpYXIgdW0gc2VydmnDp28gZGUgaW1hZ2VucyBlbSBjYWNoZSBxdWUgcG9kZSBzZXIgaW50ZWdyYWRvIHBvciBhcGxpY2HDp8O1ZXMgY29tIG91dHJvcyBzZXJ2acOnb3MgZW0gY2FjaGUsIMOpIGltcG9ydGFudGUgcXVlIHRvZG9zIGVzdGVqYW0gbmEgbWVzbWEgcHJvamXDp8Ojby4gSXN0byDDqSBmcmVxdWVudGVtZW50ZSB1bWEgcHJvamXDp8OjbyBXZWIgTWVyY2F0b3IuIFVtYSB2ZXogcXVlIG8gY29uanVudG8gZGUgZGFkb3MgZW0gbW9zYWljbyBuw6NvIHBvZGUgc2VyIHJlcHJvamV0YWRvLCBwb2RlIGZhemVyIHVtYSBkZSBkdWFzIGNvaXNhcyDigJQgY3JpYXIgdW0gY29uanVudG8gZGUgZGFkb3MgZW0gbW9zYWljbyByZWZlcmVuY2lhZG8gYSBwYXJ0aXIgZG8gc2V1IGNvbmp1bnRvIGRlIGRhZG9zIGVtIG1vc2FpY28gbmEgcHJvamXDp8OjbyBuZWNlc3PDoXJpYSwgb3UgYWRpY2lvbmFyIGEgZnVuw6fDo28gUmVwcm9qZXRhciDDoCBjYWRlaWEgZGUgZnVuw6fDtWVzIGRvIGNvbmp1bnRvIGRlIGRhZG9zIGVtIG1vc2FpY28uIE91dHJvIGV4ZW1wbG8gdXRpbGl6YSBlc3RhIGZ1bsOnw6NvIG5vIGl0ZW0gcmFzdGVyIG51bSBjb25qdW50byBkZSBkYWRvcyBlbSBtb3NhaWNvLiBBbyB1dGlsaXphciBhIGZ1bsOnw6NvIFJhc3RlciBlbSBDYWNoZSwgcG9kZSBxdWVyZXIgaW5zZXJpciBhIGZ1bsOnw6NvIFJlcHJvamV0YXIgcGFyYSBxdWUgYSBjYWNoZSBzZWphIGNyaWFkYSBuYSBub3ZhIHByb2plw6fDo28uIE9zIGl0ZW5zIHJhc3RlciBudW0gY29uanVudG8gZGUgZGFkb3MgZW0gbW9zYWljbyBwb2RlbSBzZXIgYXJtYXplbmFkb3MgZW0gY2FjaGUgcXVhbmRvIG8gcHJvY2Vzc2FtZW50byDDqSBpbnRlbnNvIGUgZXN0w6EgYSB0ZW50YXIgcHVibGljYXIgdW0gc2VydmnDp28gZGUgaW1hZ2VucyBxdWUgw6kgcsOhcGlkbywgc2VtIGFybWF6ZW5hciBlbSBjYWNoZSB0b2RvIG8gc2VydmnDp28gZGUgaW1hZ2Vucy48L2Rpdj5cIixcblx0XHRyZXNhbXBsZU5hbWU6IFwiUmVhbW9zdHJhZ2VtXCIsXG5cdFx0cmVzYW1wbGVTbmlwOiBcIkFsdGVyYSBvIHRhbWFuaG8gZGEgY8OpbHVsYSBkZSB1bSByYXN0ZXIuXCIsXG5cdFx0cmVzYW1wbGVEZXNjOiBcIkEgZnVuw6fDo28gUmVhbW9zdHJhZ2VtIGFsdGVyYSBvIHRhbWFuaG8gZGEgY8OpbHVsYSwgbyB0aXBvIGRlIHJlYW1vc3RyYWdlbSwgb3UgYW1ib3MuPGRpdj48YnIvPkEgZnVuw6fDo28gUmVhbW9zdHJhZ2VtIHPDsyBkZXZlIHNlciB1dGlsaXphZGEgY29tIHJlcXVpc2l0b3MgZGUgY8OhbGN1bG8gZXNwZWPDrWZpY29zOyBwb3IgZXhlbXBsbywgcXVhbmRvIHNlIGVzdMOhIGEgY2FsY3VsYXIgbyB2ZW50byBvdSBhIGRpcmXDp8OjbyBkZSBtYWduaXR1ZGUgYXR1YWwgcXVlIHJlcXVlciBhIHJlYW1vc3RyYWdlbSBhIHBhcnRpciBkYSByZXNvbHXDp8OjbyBkYSBmb250ZS48L2Rpdj5cIixcblx0XHRyb3VuZERvd25OYW1lOiBcIkFycmVkb25kYXIgcGFyYSBCYWl4b1wiLFxuXHRcdHJvdW5kRG93blNuaXA6IFwiRGV2b2x2ZSBvIHZhbG9yIGludGVpcm8gaW1lZGlhdGFtZW50ZSBpbmZlcmlvciwgcmVwcmVzZW50YWRvIHNpbXBsZXNtZW50ZSBjb21vIHVtIHZhbG9yIGRlIHbDrXJndWxhIGZsdXR1YW50ZSwgcGFyYSBjYWRhIGPDqWx1bGEgbnVtIHJhc3Rlci5cIixcblx0XHRyb3VuZERvd25EZXNjOiBcIkEgZnVuw6fDo28gQXJyZWRvbmRhciBwYXJhIEJhaXhvIGRldm9sdmUgbyBpbnRlaXJvIGltZWRpYXRhbWVudGUgaW5mZXJpb3IsIGNvbW8gdW0gdmFsb3IgZGUgdsOtcmd1bGEgZmx1dHVhbnRlLCBwYXJhIGNhZGEgcMOteGVsIG51bSByYXN0ZXIuXCIsXG5cdFx0cm91bmRVcE5hbWU6IFwiQXJyZWRvbmRhciBwYXJhIENpbWFcIixcblx0XHRyb3VuZFVwU25pcDogXCJEZXZvbHZlIG8gdmFsb3IgaW50ZWlybyBpbWVkaWF0YW1lbnRlIHN1cGVyaW9yLCByZXByZXNlbnRhZG8gc2ltcGxlc21lbnRlIGNvbW8gdW0gdmFsb3IgZGUgdsOtcmd1bGEgZmx1dHVhbnRlLCBwYXJhIGNhZGEgY8OpbHVsYSBudW0gcmFzdGVyLlwiLFxuXHRcdHJvdW5kVXBEZXNjOiBcIkFycmVkb25kYXIgcGFyYSBDaW1hIGRldm9sdmUgbyBpbnRlaXJvIGltZWRpYXRhbWVudGUgc3VwZXJpb3IsIGNvbW8gdW0gdmFsb3IgZGUgdsOtcmd1bGEgZmx1dHVhbnRlLCBwYXJhIGNhZGEgcMOteGVsIG51bSByYXN0ZXIuXCIsXG5cdFx0c2VnbWVudE1lYW5TaGlmdE5hbWU6IFwiRGVzbG9jYcOnw6NvIG3DqWRpYSBkZSBzZWdtZW50YcOnw6NvXCIsXG5cdFx0c2VnbWVudE1lYW5TaGlmdFNuaXA6IFwiQWdydXBhIHDDrXhlaXMgYWRqYWNlbnRlcyBjb20gY2FyYWN0ZXLDrXN0aWNhcyBlc3BldHJhaXMgc2ltaWxhcmVzIGVtIHNlZ21lbnRvcy5cIixcblx0XHRzZWdtZW50TWVhblNoaWZ0RGVzYzogXCJFc3RhIGZ1bsOnw6NvIGlkZW50aWZpY2Egb2JqZXRvcywgZnVuY2lvbmFsaWRhZGVzLCBvdSBzZWdtZW50b3MgbmFzIHN1YXMgaW1hZ2VucywgYWdydXBhbmRvIHDDrXhlaXMgYWRqYWNlbnRlcyBxdWUgdMOqbSBjYXJhY3RlcsOtc3RpY2FzIGVzcGV0cmFpcyBlIGVzcGFjaWFpcyBzaW1pbGFyZXMuIFBvZGUgY29udHJvbGFyIGEgbWVkaWRhIGRlIHN1YXZpemHDp8OjbyBlc3BhY2lhbCBlIGVzcGV0cmFsIHBhcmEgYWp1ZGFyIGEgb2J0ZXIgZnVuY2lvbmFsaWRhZGVzIGRlIGludGVyZXNzZS5cIixcblx0XHRzMVJhZGlvbWV0cmljQ2FsaWJyYXRpb25OYW1lOiBcIkNhbGlicmHDp8OjbyBSYWRpb23DqXRyaWNhIFNlbnRpbmVsLTFcIixcblx0XHRzMVJhZGlvbWV0cmljQ2FsaWJyYXRpb25TbmlwOiBcIkV4ZWN1dGEgZGlmZXJlbnRlcyB0aXBvcyBkZSBjYWxpYnJhZ2VtIHJhZGlvbcOpdHJpY2EgZW0gZGFkb3MgU2VudGluZWwtMS5cIixcblx0XHRzMVJhZGlvbWV0cmljQ2FsaWJyYXRpb25EZXNjOiBcIkVzdGEgZnVuw6fDo28gcmFzdGVyIHJlYWxpemEgdHLDqnMgY2FsaWJyYWdlbnMgZGlmZXJlbnRlcyBwYXJhIGNvbmp1bnRvcyBkZSBkYWRvcyBTZW50aW5lbCAxLCBpbmNsdWluZG8gYmV0YSB6ZXJvIGUgZ2FtYSwgZSBnZXJhIG8gY29uanVudG8gZGUgZGFkb3MgY2FsaWJyYWRvLiBPIG9iamV0aXZvIGRhIGNhbGlicmFnZW0gU0FSIMOpIG8gZGUgcHJvcG9yY2lvbmFyIGltYWdlbnMgbmFzIHF1YWlzIG9zIHZhbG9yZXMgZG9zIHDDrXhlaXMgcG9zc2FtIHNlciBkaXJldGFtZW50ZSByZWxhY2lvbmFkb3MgY29tIGEgcmV0cm9kaWZ1c8OjbyBkZSByYWRhciBkYSBjZW5hLiBFbWJvcmEgYXMgaW1hZ2VucyBTQVIgbsOjbyBjYWxpYnJhZGFzIHNlamFtIHN1ZmljaWVudGVzIHBhcmEgdW1hIHV0aWxpemHDp8OjbyBxdWFsaXRhdGl2YSwgYXMgaW1hZ2VucyBTQVIgY2FsaWJyYWRhcyBzw6NvIGVzc2VuY2lhaXMgcGFyYSBhIHV0aWxpemHDp8OjbyBxdWFudGl0YXRpdmEgZG9zIGRhZG9zIFNBUi48ZGl2Pjxici8+TyBwcm9jZXNzYW1lbnRvIGRlIGRhZG9zIFNBUiB0w61waWNvcywgcXVlIHByb2R1eiBpbWFnZW5zIGRlIE7DrXZlbCAxLCBuw6NvIGluY2x1aSBjb3JyZcOnw7VlcyByYWRpb23DqXRyaWNhcyBlIHBlcm1hbmVjZSB1bSBkZXN2aW8gcmFkaW9tw6l0cmljbyBzaWduaWZpY2F0aXZvLiBQb3J0YW50bywgw6kgbmVjZXNzw6FyaW8gYXBsaWNhciBjb3JyZcOnw6NvIHJhZGlvbcOpdHJpY2Egw6BzIGltYWdlbnMgU0FSIHBhcmEgcXVlIG9zIHZhbG9yZXMgZG9zIHDDrXhlaXMgZGFzIGltYWdlbnMgcmVwcmVzZW50ZW0gdmVyZGFkZWlyYW1lbnRlIGEgcmV0cm9kaWZ1c8OjbyBkZSByYWRhciBkYSBzdXBlcmbDrWNpZSByZWZsZXRvcmEuIEEgY29ycmXDp8OjbyByYWRpb23DqXRyaWNhIHRhbWLDqW0gw6kgbmVjZXNzw6FyaWEgcGFyYSBhIGNvbXBhcmHDp8OjbyBkZSBpbWFnZW5zIFNBUiBvYnRpZGFzIGNvbSBkaWZlcmVudGVzIHNlbnNvcmVzLCBvdSBvYnRpZGFzIGEgcGFydGlyIGRvIG1lc21vIHNlbnNvciBlbSBkaWZlcmVudGVzIG1vbWVudG9zLCBlbSBkaWZlcmVudGVzIG1vZG9zLCBvdSBwcm9jZXNzYWRhcyBwb3IgZGlmZXJlbnRlcyBwcm9jZXNzYWRvcmVzLjwvZGl2PlwiLFxuXHRcdHMxVGhlcm1hbE5vaXNlUmVtb3ZhbE5hbWU6IFwiRWxpbWluYcOnw6NvIGRlIFJ1w61kbyBUw6lybWljbyBkZSBTZW50aW5lbC0xXCIsXG5cdFx0czFUaGVybWFsTm9pc2VSZW1vdmFsU25pcDogXCJFbGltaW5hIG8gcnXDrWRvIHTDqXJtaWNvIGRlIGRhZG9zIFNlbnRpbmVsLTEuXCIsXG5cdFx0czFUaGVybWFsTm9pc2VSZW1vdmFsRGVzYzogXCJBIGNvcnJlw6fDo28gZGUgcnXDrWRvIHTDqXJtaWNvIHBvZGUgc2VyIGFwbGljYWRhIGEgcHJvZHV0b3MgU2luZ2xlIExvb2sgQ29tcGxleCAoU0xDKSBkZSBOw612ZWwgMSwgYmVtIGNvbW8gYSBwcm9kdXRvcyBHcm91bmQgUmFuZ2UgRGV0ZWN0aW9uIChHUkQpIGRlIE7DrXZlbCAxLCBkZSBTZW50aW5lbC0xLCBxdWUgYWluZGEgbsOjbyB0ZW5oYW0gc2lkbyBjb3JyaWdpZG9zLiBPIG9wZXJhZG9yIHRhbWLDqW0gcG9kZSBlbGltaW5hciBlc3RhIGNvcnJlw6fDo28gY29tIGJhc2UgbmFzIGFub3Rhw6fDtWVzIGRvIHByb2R1dG8gcGFyYSByZWludHJvZHV6aXIgbyBzaW5hbCBkZSBydcOtZG8gcXVlIGZvaSBlbGltaW5hZG8gcGFyYSBwcm9kdXppciBvIHByb2R1dG8gb3JpZ2luYWwuIEFzIGFub3Rhw6fDtWVzIGRvIHByb2R1dG8gc2Vyw6NvIGF0dWFsaXphZGFzIGVtIGNvbmZvcm1pZGFkZSBwYXJhIHBlcm1pdGlyIGEgcmVhcGxpY2HDp8OjbyBkYSBjb3JyZcOnw6NvLiBcIixcblx0XHRzZXROdWxsTmFtZTogXCJEZWZpbmlyIE51bG9cIixcblx0XHRzZXROdWxsU25pcDogXCJEZWZpbmlyIE51bG8gZGVmaW5lIGxvY2FpcyBkZSBjw6lsdWxhcyBpZGVudGlmaWNhZG9zIGNvbW8gTm9EYXRhIGNvbSBiYXNlIG51bSBjcml0w6lyaW8gZXNwZWPDrWZpY28uIERldm9sdmUgTm9EYXRhIGNhc28gdW1hIGF2YWxpYcOnw6NvIGNvbmRpY2lvbmFsIHNlamEgdmVyZGFkZWlyYSBlIGRldm9sdmUgbyB2YWxvciBlc3BlY2lmaWNhZG8gcG9yIG91dHJvIHJhc3RlciBjYXNvIHNlamEgZmFsc28uXCIsXG5cdFx0c2V0TnVsbERlc2M6IFwiQSBmdW7Dp8OjbyBEZWZpbmlyIE51bG8gZGVmaW5lIG9zIHDDrXhlaXMgaWRlbnRpZmljYWRvcyBjb21vIE5vRGF0YSwgY29tIGJhc2Ugbm9zIGNyaXTDqXJpb3MgZXNwZWPDrWZpY29zLiBEZXZvbHZlIE5vRGF0YSBzZSB1bWEgYXZhbGlhw6fDo28gY29uZGljaW9uYWwgZm9yIHZlcmRhZGVpcmEgKDEpIGUgZGV2b2x2ZSBvIHZhbG9yIGVzcGVjaWZpY2FkbyBubyBSYXN0ZXIgRmFsc28gc2UgdW1hIGF2YWxpYcOnw6NvIGNvbmRpY2lvbmFsIGZvciBmYWxzYSAoMCkuIEVzdGUgY3JpdMOpcmlvIMOpIGRlZmluaWRvIHBlbG8gdmFsb3IgZGUgc2HDrWRhIGRlIHVtYSBmdW7Dp8OjbyBtYXRlbcOhdGljYSBsw7NnaWNhLCBxdWUgc2Vyw6EgbyBSYXN0ZXIgZGUgZW50cmFkYS5cIixcblx0XHRzaGFkZWRSZWxpZWZOYW1lOiBcIlJlbGV2byBTb21icmVhZG9cIixcblx0XHRzaGFkZWRSZWxpZWZTbmlwOiBcIkNyaWEgdW1hIHJlcHJlc2VudGHDp8OjbyBtdWx0aWJhbmRhLCBjb2RpZmljYWRhIHBvciBjb3JlcyBlIDNEIGRhIHN1cGVyZsOtY2llLCBjb20gYSBwb3Npw6fDo28gcmVsYXRpdmEgZG8gc29sIHRpZGEgZW0gY29udGEgcGFyYSBzb21icmVhciBhIGltYWdlbS5cIixcblx0XHRzaGFkZWRSZWxpZWZEZXNjOiBcIkEgZnVuw6fDo28gZGUgUmVsZXZvIHNvbWJyZWFkbyBjcmlhIHVtYSByZXByZXNlbnRhw6fDo28gM0QgYSBjb3JlcyBkbyB0ZXJyZW5vIMOpIGNyaWFkYSBhdHJhdsOpcyBkYSBmdXPDo28gZGUgaW1hZ2VucyBkb3MgbcOpdG9kb3MgZGUgSGlsbHNoYWRlIGUgY8OzZGlnby1lbGV2YcOnw6NvLiBFc3RhIGZ1bsOnw6NvIHV0aWxpemEgYXMgcHJvcHJpZWRhZGVzIGRlIGFsdGl0dWRlIGUgYXppbXV0ZSBwYXJhIGVzcGVjaWZpY2FyIGEgcG9zacOnw6NvIGRvIHNvbC48ZGl2Pjxici8+PC9kaXY+XCIsXG5cdFx0c2luSE5hbWU6IFwiU2luSFwiLFxuXHRcdHNpbkhTbmlwOiBcIkNhbGN1bGEgbyBzZW5vIGhpcGVyYsOzbGljbyBkYXMgY8OpbHVsYXMgbnVtIHJhc3Rlci5cIixcblx0XHRzaW5IRGVzYzogXCJBIGZ1bsOnw6NvIGNhbGN1bGEgbyBzZW5vIGhpcGVyYsOzbGljbyBkb3MgcMOteGVpcyBudW0gcmFzdGVyLlwiLFxuXHRcdHNpbk5hbWU6IFwiU2luXCIsXG5cdFx0c2luU25pcDogXCJDYWxjdWxhIG8gc2VubyBkYXMgY8OpbHVsYXMgbnVtIHJhc3Rlci5cIixcblx0XHRzaW5EZXNjOiBcIkEgZnVuw6fDo28gY2FsY3VsYSBvIHNlbm8gZG9zIHDDrXhlaXMgbnVtIHJhc3Rlci5cIixcblx0XHRzbG9wZU5hbWU6IFwiSW5jbGluYcOnw6NvXCIsXG5cdFx0c2xvcGVTbmlwOiBcIkNhbGN1bGEgYSB0YXhhIGRlIHZhcmlhw6fDo28gZG8gdmFsb3IgZGUgdW0gcMOteGVsIHBhcmEgb3Mgc2V1cyB2aXppbmhvcy5cIixcblx0XHRzbG9wZURlc2M6IFwiRXN0YSBmdW7Dp8OjbyByYXN0ZXIgY2FsY3VsYSBhIGluY2xpbmHDp8OjbywgcXVlIMOpIGEgdGF4YSBkZSB2YXJpYcOnw6NvIGRhIGVsZXZhw6fDo28gZGUgY2FkYSBjw6lsdWxhIGRvIG1vZGVsbyBkZSBlbGV2YcOnw6NvIGRpZ2l0YWwgKERFTSkuIMOJIGEgcHJpbWVpcmEgZGVyaXZhZGEgZGUgdW0gREVNLjxkaXY+PGJyLz5Fc3RhIGZ1bsOnw6NvIHV0aWxpemEgdW1hIGZ1bsOnw6NvIGF0YW4oKSBhY2VsZXJhZGEuIMOJIHNlaXMgdmV6ZXMgbWFpcyByw6FwaWRhIGUgbyBlcnJvIGRlIGFwcm94aW1hw6fDo28gw6kgc2VtcHJlIGluZmVyaW9yIGEgMCwzIGdyYXVzLjwvZGl2PlwiLFxuXHRcdHNwZWNrbGVOYW1lOiBcIlJ1w61kb1wiLFxuXHRcdHNwZWNrbGVTbmlwOiBcIkZvcm5lY2UgZmlsdHJvcyBwYXJhIHJlZHV6aXIgbyBydcOtZG8gZGUgY29uanVudG9zIGRlIGRhZG9zIGRlIHJhZGFyZXMgZGUgYWJlcnR1cmEgc2ludMOpdGljYS5cIixcblx0XHRzcGVja2xlRGVzYzogXCJSdcOtZG8gw6kgbyBydcOtZG8gZGUgYWx0YS1mcmVxdcOqbmNpYSBlbSBkYWRvcyBkZSB1bSByYWRhci4gQXMgaW1hZ2VucyBnZXJhZGFzIHBlbG9zIHNpc3RlbWFzIGRlIHJhZGFyIGRlIGFiZXJ0dXJhIHNpbnTDqXRpY2EgKFNBUikgc8OjbyBhbHRhbWVudGUgc3VqZWl0YXMgYSBlZmVpdG9zIGRvIHJ1w61kbyBkZXZpZG8gYW8gcHJvY2Vzc2FtZW50byBkZSBzaW5haXMgZGlzcGVyc29zIGUgw6AgaW50ZXJmZXLDqm5jaWEgZGUgb25kYXMgZWxldHJvbWFnbsOpdGljYXMgZGlzcGVyc2FzIGRhcyBzdXBlcmbDrWNpZXMgb3Ugb2JqZXRvcy4gRXN0YSBmdW7Dp8OjbyBkZSBydcOtZG8gZmlsdHJhIG8gY29uanVudG8gZGUgZGFkb3MgZGUgcmFkYXIgY29tIHJ1w61kbyBlIHN1YXZpemEgbyBydcOtZG8gZW5xdWFudG8gcmV0w6ltIGFzIGFyZXN0YXMgb3UgZW50aWRhZGVzIHByZWNpc2FzIG5hIGltYWdlbS5cIixcblx0XHRzcGVjdHJhbENvbnZlcnNpb25OYW1lOiBcIkNvbnZlcnPDo28gRXNwZWN0cmFsXCIsXG5cdFx0c3BlY3RyYWxDb252ZXJzaW9uU25pcDogXCJBcGxpY2EgdW1hIG1hdHJpeiBhIHVtYSBpbWFnZW0gbXVsdGliYW5kYS5cIixcblx0XHRzcGVjdHJhbENvbnZlcnNpb25EZXNjOiBcIkEgZnVuw6fDo28gQ29udmVyc8OjbyBFc3BlY3RyYWwgYXBsaWNhIHVtYSBtYXRyaXogYSB1bWEgaW1hZ2VtIG11bHRpYmFuZGEgcGFyYSBhZmV0YXIgb3MgdmFsb3JlcyBkZSBjb3IgZGEgc2HDrWRhLjxkaXY+PGJyLz5BbGd1bnMgc2Vuc29yZXMgbsOjbyByZWNvbGhlbSBiYW5kYXMgYXp1aXMgZGV2aWRvIGEgdW1hIGJhaXhhIHJlbGHDp8OjbyBzaW5hbC1ydcOtZG8uIElzdG8gcG9kZSBzZXIgdXRpbGl6YWRvLCBwb3IgZXhlbXBsbywgcGFyYSBjb252ZXJ0ZXIgdW1hIGltYWdlbSBpbmZyYXZlcm1lbGhhIGRlIGNvciBmYWxzYSBwYXJhIHVtYSBpbWFnZW0gZGUgY29yIHBzZXVkbyBuYXR1cmFsLjwvZGl2PlwiLFxuXHRcdHNxdWFyZVJvb3ROYW1lOiBcIlJhaXogUXVhZHJhZGFcIixcblx0XHRzcXVhcmVSb290U25pcDogXCJDYWxjdWxhIGEgcmFpeiBxdWFkcmFkYSBkb3MgdmFsb3JlcyBkZSBjw6lsdWxhIG51bSByYXN0ZXIuXCIsXG5cdFx0c3F1YXJlUm9vdERlc2M6IFwiQSBmdW7Dp8OjbyBSYWl6IFF1YWRyYWRhIGNhbGN1bGEgYSByYWl6IHF1YWRyYWRhIGRvcyB2YWxvcmVzIGRlIHDDrXhlbCBudW0gcmFzdGVyLlwiLFxuXHRcdHNxdWFyZU5hbWU6IFwiUXVhZHJhZG9cIixcblx0XHRzcXVhcmVTbmlwOiBcIkNhbGN1bGEgbyBxdWFkcmFkbyBkb3MgdmFsb3JlcyBkZSBjw6lsdWxhIG51bSByYXN0ZXIuXCIsXG5cdFx0c3F1YXJlRGVzYzogXCJRdWFkcmFkYSBjYWxjdWxhIGEgcmFpeiBxdWFkcmFkYSBkb3MgdmFsb3JlcyBkZSBww614ZWwgbnVtIHJhc3Rlci5cIixcblx0XHRzdGF0aXN0aWNzSGlzdG9ncmFtTmFtZTogXCJFc3RhdMOtc3RpY2FzIGUgSGlzdG9ncmFtYVwiLFxuXHRcdHN0YXRpc3RpY3NIaXN0b2dyYW1TbmlwOiBcIkRlZmluaXIgZXN0YXTDrXN0aWNhcyBvdSBoaXN0b2dyYW1hcyBhc3NvY2lhZG9zLlwiLFxuXHRcdHN0YXRpc3RpY3NIaXN0b2dyYW1EZXNjOiBcIkEgZnVuw6fDo28gZGUgRXN0YXTDrXN0aWNhcyBlIEhpc3RvZ3JhbWEgw6kgdXRpbGl6YWRhIHBhcmEgZGVmaW5pciBhcyBlc3RhdMOtc3RpY2FzIGUgbyBoaXN0b2dyYW1hIGRlIHVtIHJhc3Rlci4gUG9kZXLDoSBpbnRyb2R1emlyIGVzdGEgZnVuw6fDo28gbm8gZmluYWwgZGEgY2FkZWlhIGRlIGZ1bsOnw7VlcyBwYXJhIGRlc2NyZXZlciBhcyBlc3RhdMOtc3RpY2FzIGUgaGlzdG9ncmFtYSBkZSB1bSBtb2RlbG8gZGUgZnVuw6fDo28gZGUgcmFzdGVyIChSRlQpLiBJc3RvIHBvZGVyw6Egc2VyIG5lY2Vzc8OhcmlvIHBhcmEgY29udHJvbGFyIGEgYXByZXNlbnRhw6fDo28gcHJlZGVmaW5pZGEgZG8gcmVzdWx0YWRvIGRlIHByb2Nlc3NhbWVudG8sIGVzcGVjaWFsbWVudGUgZHVyYW50ZSBhIGRlZmluacOnw6NvIGRlIHVtYSBjYWRlaWEgZGUgZnVuw6fDtWVzIHF1ZSBjb250ZW5oYSBtdWl0YXMgZnVuw6fDtWVzLjxkaXY+PGJyLz5Qb2RlIGRlZmluaXIgZXN0YXTDrXN0aWNhcywgZGlnaXRhbmRvIG9zIHZhbG9yZXMgb3UgaW1wb3J0YW5kbyBkZSB1bSBjb25qdW50byBkZSBkYWRvcyByYXN0ZXIgb3UgZGUgdW0gZmljaGVpcm8gWE1MLiBPcyBoaXN0b2dyYW1hcyBhcGVuYXMgcG9kZW0gc2VyIGRlZmluaWRvcyBhdHJhdsOpcyBkYSBpbXBvcnRhw6fDo28gZGUgdW0gZmljaGVpcm8uPC9kaXY+XCIsXG5cdFx0c3RhdGlzdGljc05hbWU6IFwiRXN0YXTDrXN0aWNhc1wiLFxuXHRcdHN0YXRpc3RpY3NTbmlwOiBcIkNhbGN1bGEgYXMgZXN0YXTDrXN0aWNhcyBmb2NhbGl6YWRhcyBwYXJhIGNhZGEgcMOteGVsIGRlIHVtYSBpbWFnZW0gY29tIGJhc2UgbnVtYSB2aXppbmhhbsOnYSBmb2NhbGl6YWRhIGRlZmluaWRhLlwiLFxuXHRcdHN0YXRpc3RpY3NEZXNjOiBcIkEgZnVuw6fDo28gZGUgRXN0YXTDrXN0aWNhcyBjYWxjdWxhIGFzIGVzdGF0w61zdGljYXMgZm9jYWxpemFkYXMgcGFyYSBjYWRhIHDDrXhlbCBkZSB1bWEgaW1hZ2VtIGNvbSBiYXNlIG51bWEgdml6aW5oYW7Dp2EgZm9jYWxpemFkYSBkZWZpbmlkYS48ZGl2Pjxici8+QSBmdW7Dp8OjbyBkZSBFc3RhdMOtc3RpY2FzIHBvZGUgc2VyIHV0aWxpemFkYSBwYXJhIHByZWVuY2hlciBsaW5oYXMgbsOjbyBjb250w61udWFzIG51bWEgaW1hZ2VtLiBBcyBsaW5oYXMgbsOjbyBjb250w61udWFzIHPDo28gbXVpdGFzIHZlemVzIHByb3ZvY2FkYXMgcG9yIHByb2JsZW1hcyBubyBzZW5zb3Igbm8gcXVhbCBkYWRvcyBuw6NvIHPDo28gcmVjb2xoaWRvcy4gSXN0byBhY29udGVjZXUgZW0gc2Vuc29yZXMgY29tbyBvIEVuaGFuY2VkIFRoZW1hdGljIE1hcHBlciBQbHVzIChFVE0rKSBkYSBMYW5kc2F0IDcuIEVzdGVzIGRhZG9zIGVtIGZhbHRhIHByb3ZvY2FtIHByb2JsZW1hcyBwYXJhIGEgYW7DoWxpc2UgZSB0YW1iw6ltIGR1cmFudGUgYSB2aXN1YWxpemHDp8OjbyBkYXMgaW1hZ2Vucy4gUG91Y28gcG9kZSBzZXIgZmVpdG8gZHVyYW50ZSBhIHV0aWxpemHDp8OjbyBkZSBpbWFnZW5zIHBhcmEgYW7DoWxpc2U7IG5vIGVudGFudG8sIGNhc28gZXhpc3Rpc3NlIHVtYSBpbWFnZW0gc29icmVwb3N0YSwgZXN0YSBwb2RlcsOhIHNlciB1dGlsaXphZGEgbmEgdmV6IGRlIHVtIGNvbnRlw7pkbyBlbSBmYWx0YS4gTyBtZXNtbyBwb2RlcsOhIHNlciBmZWl0byBjYXNvIGFzIGltYWdlbnMgZXN0ZWphbSBhIHNlciB1dGlsaXphZGFzIHBhcmEgdmlzdWFsaXphw6fDo28uIE5vIGVudGFudG8sIG7Do28gZXhpc3RlIHNlbXByZSB1bWEgaW1hZ2VtIGV4dHJhIHBhcmEgcHJlZW5jaGVyIG8gY29udGXDumRvIGVtIGZhbHRhIGUgY29tbyB0YWwgZXN0ZSBkZXZlcsOhIHNlciBkZXJpdmFkbyBkZSBkYWRvcyBleGlzdGVudGVzLjwvZGl2PlwiLFxuXHRcdHN0cmVhbUxpbmtOYW1lOiBcIkxpZ2HDp8OjbyBkZSBjb3JyZW50ZVwiLFxuXHRcdHN0cmVhbUxpbmtTbmlwOiBcIkF0cmlidWkgdmFsb3JlcyBleGNsdXNpdm9zIGEgc2Vjw6fDtWVzIGRlIHVtYSByZWRlIGxpbmVhciByYXN0ZXIgZW50cmUgaW50ZXJzZcOnw7Vlcy5cIixcblx0XHRzdHJlYW1MaW5rRGVzYzogXCJBIGZ1bsOnw6NvIGRlIExpZ2HDp8OjbyBkZSBDb3JyZW50ZSBnbG9iYWwgYXRyaWJ1aSB2YWxvcmVzIGV4Y2x1c2l2b3MgYSBzZWPDp8O1ZXMgZGUgdW1hIHJlZGUgbGluZWFyIHJhc3RlciBlbnRyZSBpbnRlcnNlw6fDtWVzLjxkaXY+PGJyLz5BcyBsaWdhw6fDtWVzIHPDo28gYXMgc2Vjw6fDtWVzIGRlIHVtIGNhbmFsIGRlIGZsdXhvIHF1ZSBsaWdhIGR1YXMganVuw6fDtWVzIHN1Y2Vzc2l2YXMsIHVtYSBqdW7Dp8OjbyBlIGEgc2HDrWRhLCBvdSB1bWEganVuw6fDo28gZSBhIGRpdmlzw6NvIGRhIGRyZW5hZ2VtLiBFbSBoaWRyb2xvZ2lhLCBlc3RlcyBzZWdtZW50b3MgZGUgY29ycmVudGUgY2hhbWFtLXNlIHJpb3MuIFVtIGNydXphbWVudG8gZXN0w6EgcmVsYWNpb25hZG8gY29tIHVtIHBvbnRvIGRlIGRlc3Blam8gZSBhanVkYSBhIGRlbGluZWFyIHVtYSDDoXJlYSBkZSBzZXBhcmHDp8OjbyBkZSDDoWd1YXMgb3Ugb3MgbGltaXRlcyBkZSB1bWEgYmFjaWEgZGUgZHJlbmFnZW0gc2VjdW5kw6FyaWEuPC9kaXY+XCIsXG5cdFx0c3RyZXRjaE5hbWU6IFwiRXN0aWNhclwiLFxuXHRcdHN0cmV0Y2hTbmlwOiBcIk1lbGhvcmEgdW1hIGltYWdlbSBhbyBhanVzdGFyIG8gaW50ZXJ2YWxvIGRlIHZhbG9yZXMgYXByZXNlbnRhZG8uIElzdG8gbsOjbyBhbHRlcmEgb3MgdmFsb3JlcyBkZSBww614ZWwgc3ViamFjZW50ZXMuIFNlIHVtIHDDrXhlbCB0aXZlciB1bSB2YWxvciBmb3JhIGRvIGludGVydmFsbyBlc3BlY2lmaWNhZG8sIGVsZSBhcGFyZWNlcsOhIGNvbW8gbyB2YWxvciBtw61uaW1vIG91IG3DoXhpbW8uXCIsXG5cdFx0c3RyZXRjaERlc2M6IFwiQSBmdW7Dp8OjbyBFc3RpY2FyIG1lbGhvcmEgdW1hIGltYWdlbSBhbyBhbHRlcmFyIHByb3ByaWVkYWRlcyBjb21vIG8gYnJpbGhvLCBjb250cmFzdGUgZSBnYW1tYSBhdHJhdsOpcyBkZSBtw7psdGlwbG9zIHRpcG9zIGRlIGV4dGVuc8Ojby4gRXN0YSBmdW7Dp8OjbyB1dGlsaXphIGFzIGVzdGF0w61zdGljYXMgZG9zIHJhc3RlcnMgZGVudHJvIGRvIGNvbmp1bnRvIGRlIGRhZG9zIGRvIG1vc2FpY287IGNvbW8gdGFsLCBjYXNvIHV0aWxpemUgZXN0YSBmdW7Dp8OjbywgZGV2ZXLDoSBhc3NlZ3VyYXItc2UgZGUgcXVlIGFzIGVzdGF0w61zdGljYXMgZm9yYW0gY2FsY3VsYWRhcy48ZGl2Pjxici8+TyB0aXBvIGRlIGV4dGVuc8OjbyBkZWZpbmUgdW0gaGlzdG9ncmFtYSBkZSBleHRlbnPDo28gcXVlIHNlcsOhIGFwbGljYWRvIGFvcyByYXN0ZXJzIHBhcmEgbWVsaG9yYXIgYSBzdWEgYXBhcsOqbmNpYS4gQSBleHRlbnPDo28gbWVsaG9yYSBhIGFwYXLDqm5jaWEgZG9zIGRhZG9zIGFvIGVzcGFsaGFyIG9zIHZhbG9yZXMgZGUgcMOteGVsIGFvIGxvbmdvIGRlIHVtIGhpc3RvZ3JhbWEgYSBwYXJ0aXIgZG9zIHZhbG9yZXMgbcOtbmltb3MgZSBtw6F4aW1vcyBkZWZpbmlkb3MgYXRyYXbDqXMgZGEgcmVzcGV0aXZhIHByb2Z1bmRpZGFkZSBkZSBiaXQuIDwvZGl2PlwiLFxuXHRcdHN3YXRoTmFtZTogXCJGYWl4YVwiLFxuXHRcdHN3YXRoU25pcDogXCJIw6EgaW50ZXJwb2xhw6fDo28gZGUgb3JnYW5pemHDp8O1ZXMgaXJyZWd1bGFyZXMgb3UgZGFkb3MgZGUgZmFpeGEuXCIsXG5cdFx0c3dhdGhEZXNjOiBcIkFsZ3VucyBjb25qdW50b3MgZGUgZGFkb3MgbmV0Q0RGIG91IEhERiBhcm1hemVuYW0gYSBzdWEgZ2VvbG9jYWxpemHDp8OjbyBjb21vIGRpc3Bvc2nDp8O1ZXMgZGUgZXNwYcOnYW1lbnRvIGlycmVndWxhci4gQW8gYWRpY2lvbmFyIGVzdGVzIGNvbmp1bnRvcyBkZSBkYWRvcyBhIHVtIGNvbmp1bnRvIGRlIGRhZG9zIGRlIG1vc2FpY28sIGEgZnVuw6fDo28gZGUgZmFpeGEgdG9tYSBkYWRvcyBpcnJlZ3VsYXJtZW50ZSBvcmdhbml6YWRvcyBlIGNyaWEgdW1hIG5vdmEgYW1vc3RyYSBkZSBmb3JtYSBhIHF1ZSBjYWRhIHDDrXhlbCBzZWphIHF1YWRyYWRvIGUgZGUgdW1hIGRpbWVuc8OjbyB1bmlmb3JtZS48ZGl2Pjxici8+QW8gYWRpY2lvbmFyIHZhcmnDoXZlaXMgZGUgbmV0Q0RGIG91IEhERiBhIHVtIGNvbmp1bnRvIGRlIGRhZG9zIGVtIG1vc2FpY28sIHZlcmlmaWNhcsOhIGF1dG9tYXRpY2FtZW50ZSBzZSBvcyBkYWRvcyBlc3TDo28gb3JkZW5hZG9zIHJlZ3VsYXJtZW50ZS4gQ2FzbyBuw6NvIGVzdGVqYW0sIGEgZnVuw6fDo28gZGUgZmFpeGEgw6kgYXV0b21hdGljYW1lbnRlIGFwbGljYWRhIHBhcmEgY29udmVydGVyIG8gcmFzdGVyIGlycmVndWxhciBlbSBwb250b3MgZSBkZXBvaXMgbnVtIHJhc3RlciByZWd1bGFybWVudGUgb3JnYW5pemFkby4gUG9kZXLDoSBhbHRlcmFyIG8gbcOpdG9kbyBkZSBpbnRlcnBvbGHDp8OjbyBlIGEgY8OpbHVsYSB1dGlsaXphZGEgbmEgZnVuw6fDo28gZGUgcmFzdGVyIGRlIGZhaXhhLiBQYXJhIGRhZG9zIGRlIHJhc3RlciBkZSBlc3Bhw6dhbWVudG8gcmVndWxhciwgbsOjbyBzZXLDoSBhcGxpY2FkYSBxdWFscXVlciBpbnRlcnBvbGHDp8Ojbywgb3MgZGFkb3Mgc2Vyw6NvIGxpZG9zIGNvbmZvcm1lIGVzdMOjby48L2Rpdj5cIixcblx0XHR0YW5ITmFtZTogXCJUYW5IXCIsXG5cdFx0dGFuSFNuaXA6IFwiQ2FsY3VsYSBhIHRhbmdlbnRlIGhpcGVyYsOzbGljYSBkYXMgY8OpbHVsYXMgbnVtIHJhc3Rlci5cIixcblx0XHR0YW5IRGVzYzogXCJFc3RhIGZ1bsOnw6NvIGNhbGN1bGEgYSB0YW5nZW50ZSBoaXBlcmLDs2xpY2EgZG9zIHDDrXhlaXMgbnVtIHJhc3Rlci5cIixcblx0XHR0YW5OYW1lOiBcIlRhblwiLFxuXHRcdHRhblNuaXA6IFwiQ2FsY3VsYSBhIHRhbmdlbnRlIGRhcyBjw6lsdWxhcyBudW0gcmFzdGVyLlwiLFxuXHRcdHRhbkRlc2M6IFwiRXN0YSBmdW7Dp8OjbyBjYWxjdWxhIGEgdGFuZ2VudGUgZG9zIHDDrXhlaXMgbnVtIHJhc3Rlci4gXCIsXG5cdFx0dGFzc2VsZWRDYXBOYW1lOiBcIlRhc3NlbGVkIENhcCAoS2F1dGgtVGhvbWFzKVwiLFxuXHRcdHRhc3NlbGVkQ2FwU25pcDogXCJDYWxjdWxhIG7DrXZlaXMgZGUgdmVnZXRhw6fDo28sIGh1bWlkYWRlIGUgYnJpbGhvLiBFc3RhIHTDqWNuaWNhIGRlcGVuZGUgZGUgY29lZmljaWVudGVzLCBxdWUgdMOqbSBxdWUgc2VyIGNhbGN1bGFkb3MgZXNwZWNpZmljYW1lbnRlIHBhcmEgY2FkYSBzZW5zb3IuXCIsXG5cdFx0dGFzc2VsZWRDYXBEZXNjOiBcIkEgdHJhbnNmb3JtYcOnw6NvIFRhc3NlbGVkIENhcCAoS2F1dGgtVGhvbWFzKSBlc3TDoSBkZXNlbmhhZGEgcGFyYSBhbmFsaXNhciBlIHJlcHJlc2VudGFyIG11ZGFuw6dhcyBkZSB2ZWdldGHDp8OjbyBlIGRlIGRlc2Vudm9sdmltZW50byB1cmJhbm8gZGV0ZXRhZGFzIHBvciBkaXZlcnNvcyBzaXN0ZW1hcyBkZSBzZW5zb3IgZGUgc2F0w6lsaXRlLiDDiSBjb25oZWNpZGEgY29tbyBhIHRyYW5zZm9ybWHDp8OjbyBUYXNzZWxlZCBDYXAgZGV2aWRvIMOgIGZvcm1hIGRhIGRpc3RyaWJ1acOnw6NvIGdyw6FmaWNhIGRvcyBkYWRvcy4gQSB0cmFuc2Zvcm1hw6fDo28gZm9ybmVjZSB1bWEgcmF6w6NvIHBhcmEgb3MgcGFkcsO1ZXMgZW5jb250cmFkb3Mgbm9zIGRhZG9zIGRvIExhbmRzYXQgTVNTIGRlIGNhbXBvcyBhZ3LDrWNvbGFzIGNvbW8gdW1hIGZ1bsOnw6NvIGRvIGNpY2xvIGRlIHZpZGEgZGEgcGxhbnRhw6fDo28uIEVzc2VuY2lhbG1lbnRlLCDDoCBtZWRpZGEgcXVlIGFzIGN1bHR1cmFzIGNyZXNjZW0gZGVzZGUgYSBzZW1lbnRlIGF0w6kgw6AgbWF0dXJpZGFkZSwgaMOhIHVtIGF1bWVudG8gbMOtcXVpZG8gZGUgaW5mcmF2ZXJtZWxobyBwcsOzeGltbyBlIHVtYSBkaW1pbnVpw6fDo28gZGEgcmVmbGV0w6JuY2lhIHZlcm1lbGhhIGNvbSBiYXNlIG5hIGNvciBkbyBzb2xvPGRpdj48YnIvPkEgdXRpbGlkYWRlIGRlc3RhIHRyYW5zZm9ybWHDp8OjbyBleHBhbmRpdS1zZSBkYSBtb25pdG9yaXphw6fDo28gZGFzIGN1bHR1cmFzIHBhcmEgYSBhbsOhbGlzZSBlIGNhcnRvZ3JhZmlhIGRhIHZlZ2V0YcOnw6NvIHBhcmEgYXBvaWFyIHVtYSBncmFuZGUgdmFyaWVkYWRlIGRlIGFwbGljYcOnw7VlcyBjb21vIGEgc2lsdmljdWx0dXJhLCBnZXN0w6NvIGRhIHZlZ2V0YcOnw6NvIGluZHVzdHJpYWwsIGNhcnRvZ3JhZmlhIGUgZ2VzdMOjbyBkb3MgZWNvc3Npc3RlbWFzLCBpbnZlbnTDoXJpbyBlIG1vbml0b3JpemHDp8OjbyBwYXJhIHNlcXVlc3RybyBlIGNyw6lkaXRvcyBkZSBjYXJib25vLCBkZXNlbnZvbHZpbWVudG8gdXJiYW5vLCBlIG11aXRvIG1haXMuIFRhbWLDqW0gc2UgZXhwYW5kaXUgZGUgc3Vwb3J0YXIgbyBMYW5kc2F0IE1TUyBwYXJhIGluY2x1aXIgb3V0cm9zIHNpc3RlbWFzIGRlIHNhdMOpbGl0ZXMgcG9wdWxhcmVzIHRhaXMgY29tbyBvIExhbmRzYXQgVE0sIG8gTGFuZHNhdCBFVE0rLCBvIExhbmRzYXQgOCwgbyBJS09OT1MsIG8gUXVpY2tCaXJkLCBvIFdvcmxkVmlldy0yIGUgc2Vuc29yZXMgbXVsdGllc3BlY3RyYWlzIFJhcGlkRXllLjwvZGl2PlwiLFxuXHRcdHRpbWVzTmFtZTogXCJUZW1wb3NcIixcblx0XHR0aW1lc1NuaXA6IFwiTXVsdGlwbGljYSBvcyB2YWxvcmVzIGRlIGRvaXMgcmFzdGVycyBudW1hIGJhc2UgZGUgY8OpbHVsYSBhIGPDqWx1bGEuXCIsXG5cdFx0dGltZXNEZXNjOiBcIkEgZnVuw6fDo28gVGVtcG9zIG11bHRpcGxpY2Egb3MgdmFsb3JlcyBkZSBkb2lzIHJhc3RlcnMgbnVtYSBiYXNlIGRlIHDDrXhlbCBhIHDDrXhlbC5cIixcblx0XHR0cmFuc3Bvc2VCaXRzTmFtZTogXCJUcmFuc3BvciBCaXRzXCIsXG5cdFx0dHJhbnNwb3NlQml0c1NuaXA6IFwiRGVzZW1wYWNvdGEgb3MgYml0cyBkbyBww614ZWwgZGUgZW50cmFkYSBlIGF0cmlidWktb3MgYSBiaXRzIGVzcGVjw61maWNvcyBubyBww614ZWwgZGUgc2HDrWRhLiBPIG9iamV0aXZvIGRlc3RhIGZ1bsOnw6NvIMOpIG8gZGUgbWFuaXB1bGFyIGJpdHMgZGUgdW0gcGFyIGRlIGVudHJhZGFzLCB0YWlzIGNvbW8gb3MgcHJvZHV0b3MgZGUgYmFuZGEgZGUgcXVhbGlkYWRlIGRvIExhbmRzYXQgOC5cIixcblx0XHR0cmFuc3Bvc2VCaXRzRGVzYzogXCJBIGZ1bsOnw6NvIFRyYW5zcG9yIEJpdCBkZXNlbXBhY290YSBvcyBiaXRzIGRvIHDDrXhlbCBkZSBlbnRyYWRhIGUgYXRyaWJ1aS1vcyBhIGJpdHMgZXNwZWPDrWZpY29zIG5vIHDDrXhlbCBkZSBzYcOtZGEuIE8gb2JqZXRpdm8gZGVzdGEgZnVuw6fDo28gw6kgbyBkZSBtYW5pcHVsYXIgYml0cyBkZSB1bSBwYXIgZGUgZW50cmFkYXMsIHRhaXMgY29tbyBvcyBwcm9kdXRvcyBkZSBiYW5kYSBkZSBxdWFsaWRhZGUgZG8gTGFuZHNhdCA4LlwiLFxuXHRcdHVuaXRDb252ZXJzaW9uTmFtZTogXCJDb252ZXJzw6NvIGRlIFVuaWRhZGVzXCIsXG5cdFx0dW5pdENvbnZlcnNpb25TbmlwOiBcIkFsdGVyYSB2YWxvcmVzIGRlIHVtYSB1bmlkYWRlIGRlIG1lZGnDp8OjbyBwYXJhIG91dHJhLlwiLFxuXHRcdHVuaXRDb252ZXJzaW9uRGVzYzogXCJFc3RhIGZ1bsOnw6NvIGNvbnZlcnRlIHDDrXhlaXMgZGUgdW1hIHVuaWRhZGUgcGFyYSBvdXRyYS4gU3Vwb3J0YSBhIGNvbnZlcnPDo28gZGUgZGlzdMOibmNpYSwgdmVsb2NpZGFkZSBlIHRlbXBlcmF0dXJhLlwiLFxuXHRcdHZlY3RvckZpZWxkTmFtZTogXCJDYW1wbyBWZXRvcmlhbFwiLFxuXHRcdHZlY3RvckZpZWxkU25pcDogXCJFeGliZSBjb25qdW50b3MgZGUgZGFkb3MgZW0gcXVlIHRhbnRvIGEgbWFnbml0dWRlICh1KSBjb21vIGEgZGlyZcOnw6NvICh2KSBzw6NvIHNldGFzLCBvbmRlIGEgbWFnbml0dWRlIMOpIHJlcHJlc2VudGFkYSBwZWxvIHRhbWFuaG8gZGEgc2V0YSBlIGEgZGlyZcOnw6NvIHBlbG8gw6JuZ3VsbyBkYSBtZXNtYS5cIixcblx0XHR2ZWN0b3JGaWVsZERlc2M6IFwiQSBmdW7Dp8OjbyBDYW1wbyBWZXRvcmlhbCDDqSB1dGlsaXphZGEgcGFyYSBjb21iaW5hciBlIGNvbnZlcnRlciBkb2lzIHJhc3RlcnMgbnVtIHJhc3RlciBkZSBkdWFzIGJhbmRhcywgcXVlIHNlamEgZG8gdGlwbyBNYWduaXR1ZGUtRGlyZcOnw6NvIG91IGRvIHRpcG8gZGUgZGFkb3MgVS1WLjxkaXY+PGJyLz5PIHZhbG9yIFUgw6kgcG9yIHZlemVzIHJlZmVyaWRvIGNvbW8gYSB2ZWxvY2lkYWRlIHpvbmFsLCBlIG8gdmFsb3IgViDDqSBwb3IgdmV6ZXMgcmVmZXJpZG8gY29tbyBhIHZlbG9jaWRhZGUgbWVyaWRpb25hbC48L2Rpdj5cIixcblx0XHR2aWV3c2hlZDJOYW1lOiBcIsOBcmVhIFZpc8OtdmVsXCIsXG5cdFx0dmlld3NoZWQyU25pcDogXCJEZXRlcm1pbmEgYXMgbG9jYWxpemHDp8O1ZXMgZGEgc3VwZXJmw61jaWUgZG8gcmFzdGVyIHF1ZSBzw6NvIHZpc8OtdmVpcyBhIHVtIGdydXBvIGRlIGZ1bmNpb25hbGlkYWRlcyBkbyBvYnNlcnZhZG9yIHV0aWxpemFuZG8gbcOpdG9kb3MgZ2VvZMOpc2ljb3MuXCIsXG5cdFx0dmlld3NoZWQyRGVzYzogXCJBIGZ1bsOnw6NvIMOBcmVhIFZpc8OtdmVsIGRldGVybWluYSBhcyBsb2NhbGl6YcOnw7VlcyBkYSBzdXBlcmbDrWNpZSByYXN0ZXIgdmlzw612ZWlzIGEgdW0gY29uanVudG8gZGUgZWxlbWVudG9zIGRlIG9ic2VydmFkb3IgdXRpbGl6YW5kbyBtw6l0b2RvcyBnZW9kw6lzaWNvczxkaXY+PGJyLz5BIHZpc2liaWxpZGFkZSBkZSBjYWRhIGNlbnRybyBkZSBww614ZWwgw6kgZGV0ZXJtaW5hZGEgcG9yIHVtIHRlc3RlIGRlIGxpbmhhIGRlIHZpc8OjbyBlbnRyZSBvIGFsdm8gZSBjYWRhIG9ic2VydmFkb3IuIFNlIHVtIG9ic2VydmFkb3IgcHVkZXIgdmVyIG8gYWx2byBubyBjZW50cm8gZG8gcMOteGVsLCBlbnTDo28sIGVzdGUgcMOteGVsIMOpIGNvbnNpZGVyYWRvIHZpc8OtdmVsLiBFc3RhIGZlcnJhbWVudGEgY29uc2lkZXJhIHNlbXByZSBhIGN1cnZhdHVyYSBkYSBUZXJyYSwgcXVhbmRvIGEgdmlzaWJpbGlkYWRlIMOpIGRldGVybWluYWRhLjwvZGl2PlwiLFxuXHRcdHdhdGVyc2hlZE5hbWU6IFwiw4FyZWEgZGUgU2VwYXJhw6fDo28gZGUgw4FndWFzXCIsXG5cdFx0d2F0ZXJzaGVkU25pcDogXCJEZXRlcm1pbmEgYSDDoXJlYSBxdWUgY29udHJpYnVpIHBvciBjaW1hIGRlIHVtIGdydXBvIGRlIGPDqWx1bGFzIG51bSByYXN0ZXJcIixcblx0XHR3YXRlcnNoZWREZXNjOiBcIkEgZnVuw6fDo28gw4FyZWEgZGUgU2VwYXJhw6fDo28gZGUgw4FndWFzIGdsb2JhbCBkZXRlcm1pbmEgYSDDoXJlYSBxdWUgY29udHJpYnVpIHBvciBjaW1hIGRlIHVtIGdydXBvIGRlIHDDrXhlaXMgbnVtIHJhc3Rlci4gw4FyZWFzIGRlIFNlcGFyYcOnw6NvIGRlIMOBZ3VhcyBzw6NvIGRlbGluZWFkYXMgYSBwYXJ0aXIgZGUgdW0gcmFzdGVyIGRlIGRpcmXDp8OjbyBkbyBmbHV4bywgcXVlIGlkZW50aWZpY2EgYSBkaXJlw6fDo28gZG8gZmx1eG8gZGUgY2FkYSBww614ZWwuXCIsXG5cdFx0d2VpZ2h0ZWRPdmVybGF5TmFtZTogXCJTb2JyZXBvc2nDp8OjbyBwb25kZXJhZGFcIixcblx0XHR3ZWlnaHRlZE92ZXJsYXlTbmlwOiBcIlNvYnJlcMO1ZSBkaXZlcnNvcyByYXN0ZXJzIHV0aWxpemFuZG8gdW1hIGVzY2FsYSBkZSBtZWRpw6fDo28gY29tdW0gZSBwb25kZXJhIGNhZGEgdW0gZGUgYWNvcmRvIGNvbSBhIHN1YSBpbXBvcnTDom5jaWEuXCIsXG5cdFx0d2VpZ2h0ZWRPdmVybGF5RGVzYzogXCJFc3RhIGZ1bsOnw6NvIHBlcm1pdGUgc29icmVwb3IgZGl2ZXJzb3MgcmFzdGVycyB1dGlsaXphbmRvIHVtYSBlc2NhbGEgZGUgbWVkacOnw6NvIGNvbXVtIGUgcG9uZGVyYXIgY2FkYSB1bSBkZSBhY29yZG8gY29tIGEgc3VhIGltcG9ydMOibmNpYS5cIixcblx0XHR3ZWlnaHRlZFN1bU5hbWU6IFwiU29tYSBQb25kZXJhZGFcIixcblx0XHR3ZWlnaHRlZFN1bVNuaXA6IFwiUG9uZGVyYSBlIHNvbWEgdW1hIHPDqXJpZSBkZSByYXN0ZXJzIG51bWEgYmFzZSBjw6lsdWxhLWEtY8OpbHVsYS5cIixcblx0XHR3ZWlnaHRlZFN1bURlc2M6IFwiQSBmdW7Dp8OjbyBTb21hIFBvbmRlcmFkYSBwZXJtaXRlIHNvYnJlcG9yIGRpdmVyc29zIHJhc3RlcnMsIG11bHRpcGxpY2FuZG8gY2FkYSB1bSBwZWxvIHNldSByZXNwZXRpdm8gcGVzbyBlIHNvbWFuZG8tb3MgYSB0b2Rvcy5cIixcblx0XHR3aW5kY2hpbGxOYW1lOiBcIlZlbnRvIEZyaW9cIixcblx0XHR3aW5kY2hpbGxTbmlwOiBcIkNvbWJpbmEgYSB0ZW1wZXJhdHVyYSBhbWJpZW50ZSBkbyBhciBlIGEgdmVsb2NpZGFkZSBkbyB2ZW50byBwYXJhIGNhbGN1bGFyIG8gZmF0b3IgdmVudG8gZnJpby5cIixcblx0XHR3aW5kY2hpbGxEZXNjOiBcIkEgZnVuw6fDo28gVmVudG8gRnJpbyDDqSDDunRpbCBwYXJhIGlkZW50aWZpY2FyIGNvbmRpw6fDtWVzIGRlIGludmVybm8gcGVyaWdvc2FzIHF1ZSwgZGVwZW5kZW5kbyBkb3MgdGVtcG9zIGRlIGV4cG9zacOnw6NvIGFvcyBlbGVtZW50b3MsIHBvZGVtIHJlc3VsdGFyIGVtIHF1ZWltYWR1cmFzIGRlIGZyaW8gZSBoaXBvdGVybWlhLiBWZW50byBmcmlvIMOpIHVtIG1vZG8gZGUgY2FsY3VsYXIgcXVhbnRvIGZyaW8gdW0gaW5kaXbDrWR1byBzZW50ZSwgcXVhbmRvIHNlIGxldmEgbyB2ZW50byBlbSBjb25zaWRlcmHDp8OjbyBjb20gdGVtcGVyYXR1cmFzIGrDoSBlbGFzIGZyaWFzLiBRdWFudG8gbWFpcyBlbGV2YWRhIGEgdmVsb2NpZGFkZSBkbyB2ZW50bywgbWFpcyByYXBpZGFtZW50ZSBvIGNvcnBvIHZhaSBwZXJkZXIgY2Fsb3IgZSBtYWlzIGZyaW8gc2UgdmFpIHNlbnRpci5cIixcblx0XHR6b25hbFJlbWFwTmFtZTogXCJSZW1hcGVhciBab25hbFwiLFxuXHRcdHpvbmFsUmVtYXBTbmlwOiBcIlJlbWFwZWFyIHDDrXhlaXMgbnVtIHJhc3RlciBiYXNlYWRvIGVtIHpvbmFzIGRlZmluaWRhcyBub3V0cm8gcmFzdGVyIGUgbm8gbWFwZWFyIGRlIHZhbG9yZXMgZGVwZW5kZW50ZXMgZGEgem9uYSBkZWZpbmlkb3MgbnVtYSB0YWJlbGEuXCIsXG5cdFx0em9uYWxSZW1hcERlc2M6IFwiRXN0YSBmdW7Dp8OjbyBwZXJtaXRlIHJlbWFwZWFyIHDDrXhlaXMgbnVtIHJhc3RlciBiYXNlYWRvIGVtIHpvbmFzIGRlZmluaWRhcyBub3V0cm8gcmFzdGVyIGUgbm8gbWFwZWFyIGRlIHZhbG9yZXMgZGVwZW5kZW50ZXMgZGEgem9uYSBkZWZpbmlkb3MgbnVtYSB0YWJlbGEuXCIsXG5cdFx0em9uYWxTdGF0aXN0aWNzTmFtZTogXCJFc3RhdMOtc3RpY2EgWm9uYWxcIixcblx0XHR6b25hbFN0YXRpc3RpY3NTbmlwOiBcIkNhbGN1bGEgZXN0YXTDrXN0aWNhcyBub3MgdmFsb3JlcyBkZSB1bSByYXN0ZXIgZGVudHJvIGRhcyB6b25hcyBkZSBvdXRybyBjb25qdW50byBkZSBkYWRvcy5cIixcblx0XHR6b25hbFN0YXRpc3RpY3NEZXNjOiBcIkEgZnVuw6fDo28gY2FsY3VsYSBlc3RhdMOtc3RpY2FzIHNvYnJlIG9zIHZhbG9yZXMgZGUgdW0gcmFzdGVyIGRlbnRybyBkYXMgem9uYXMgZGUgb3V0cm8gY29uanVudG8gZGUgZGFkb3MuIFVtYSB6b25hIMOpIGRlZmluaWRhIGNvbW8gc2VuZG8gdG9kYXMgYXMgw6FyZWFzIG5hIGVudHJhZGEgcXVlIHBvc3N1ZW0gbyBtZXNtbyB2YWxvci4gRXN0YXMgw6FyZWFzIG7Do28gdMOqbSBxdWUgc2VyIGNvbnTDrWd1YXMuIFF1YW5kbyBhcyBlbnRyYWRhcyB6b25hbCBlIGRlIHZhbG9yZXMgZm9yZW0gYW1iYXMgcmFzdGVycyBjb20gYSBtZXNtYSByZXNvbHXDp8OjbywgZW50w6NvLCBzZXLDo28gdXRpbGl6YWRhcyBkaXJldGFtZW50ZS4gU2UgYXMgcmVzb2x1w6fDtWVzIGZvcmVtIGRpZmVyZW50ZXMgw6kgYXBsaWNhZGEgdW1hIHJlYW1vc3RyYWdlbSBpbnRlcm5hIHBhcmEgZXF1aWxpYnJhciBhcyByZXNvbHXDp8O1ZXMgYW50ZXMgZGUgc2VyIGV4ZWN1dGFkYSB1bWEgb3BlcmHDp8OjbyB6b25hbC5cIixcblx0XHRmbG93TGVuZ3RoTmFtZTogXCJDb21wcmltZW50byBkbyBGbHV4b1wiLFxuXHRcdGZsb3dMZW5ndGhTbmlwOiBcIkNhbGN1bGEgYSBkaXN0w6JuY2lhIGEgbW9udGFudGUgb3UganVzYW50ZSwgb3UgZGlzdMOibmNpYSBwb25kZXJhZGEsIGFvIGxvbmdvIGRlIHVtIHBlcmN1cnNvIGRvIGZsdXhvIHBhcmEgY2FkYSBjw6lsdWxhLlwiLFxuXHRcdGZsb3dMZW5ndGhEZXNjOiBcIkVzdGEgw6kgdW1hIGZ1bsOnw6NvIHJhc3RlciBnbG9iYWwuIEVzdGEgZnVuw6fDo28gY3JpYSB1bWEgY2FtYWRhIGRlIHJhc3RlciBkYSBkaXN0w6JuY2lhIGEgbW9udGFudGUgb3UganVzYW50ZSwgb3UgZGlzdMOibmNpYSBwb25kZXJhZGEsIGFvIGxvbmdvIGRlIHVtIHBlcmN1cnNvIGRvIGZsdXhvIHBhcmEgY2FkYSBjw6lsdWxhLjxkaXY+PGJyLz5VbWEgZGFzIHByaW5jaXBhaXMgdXRpbGl6YcOnw7VlcyBkYSBmdW7Dp8OjbyBDb21wcmltZW50byBkbyBGbHV4byDDqSBjYWxjdWxhciBvIGNvbXByaW1lbnRvIGRvIHBlcmN1cnNvIG1haXMgbG9uZ28gZG8gZmx1eG8gbnVtYSBkZXRlcm1pbmFkYSBiYWNpYS4gRXN0YSBtZWRpZGEgw6kgbXVpdGFzIHZlemVzIHV0aWxpemFkYSBwYXJhIGNhbGN1bGFyIG8gdGVtcG8gZGUgY29uY2VudHJhw6fDo28gZGUgdW1hIGJhY2lhLiBJc3RvIMOpIGVmZXR1YWRvIGNvbSBhIG9ww6fDo28gQSBNb250YW50ZS4gQSBmdW7Dp8OjbyB0YW1iw6ltIHBvZGUgc2VyIHV0aWxpemFkYSBwYXJhIGNyaWFyIGRpYWdyYW1hcyBkZSBkaXN0w6JuY2lhL8OhcmVhIGRlIGhpcG90w6l0aWNvcyBldmVudG9zIGRlIHByZWNpcGl0YcOnw6NvIGUgZXNjb2FtZW50byB1dGlsaXphbmRvIG8gcmFzdGVyIGRlIHBlc28gY29tbyBpbXBlZMOibmNpYSBwYXJhIHVtIG1vdmltZW50byBkZXNjZW5kZW50ZS48L2Rpdj5cIixcblx0XHRzdHJlYW1PcmRlck5hbWU6IFwiT3JkZW0gU3RyZWFtXCIsXG5cdFx0c3RyZWFtT3JkZXJTbmlwOiBcIkF0cmlidWkgdW1hIG9yZGVtIG51bcOpcmljYSBhIHNlZ21lbnRvcyBkZSB1bSByYXN0ZXIgcXVlIHJlcHJlc2VudGFtIGFzIHNlY8Onw7VlcyBkZSB1bWEgcmVkZSBsaW5lYXJcIixcblx0XHRzdHJlYW1PcmRlckRlc2M6IFwiRXN0YSDDqSB1bWEgZnVuw6fDo28gcmFzdGVyIGdsb2JhbC4gRXN0YSBmdW7Dp8OjbyBjcmlhIHVtYSBjYW1hZGEgZGUgcmFzdGVyIHF1ZSBhdHJpYnVpIHVtYSBvcmRlbSBudW3DqXJpY2EgYSBzZWdtZW50b3MgZGUgdW0gcmFzdGVyIHF1ZSByZXByZXNlbnRhbSBhcyBzZWPDp8O1ZXMgZGUgdW1hIHJlZGUgbGluZWFyLjxkaXY+PGJyLz5BIHNhw61kYSBkYSBmdW7Dp8OjbyBPcmRlbSBTdHJlYW0gc2Vyw6EgZGUgbWVsaG9yIHF1YWxpZGFkZSBzZSBhIGNhbWFkYSBkZSByYXN0ZXIgZGUgc3RyZWFtIGRlIGVudHJhZGEgZSBhIGNhbWFkYSBkZSByYXN0ZXIgZGUgZGlyZcOnw6NvIGRvIGZsdXhvIGRlIGVudHJhZGEgdGl2ZXJlbSBvcmlnZW0gbmEgbWVzbWEgc3VwZXJmw61jaWUuIFNlIG8gcmFzdGVyIGRlIHN0cmVhbSB0aXZlciBvcmlnZW0gbnVtIGNvbmp1bnRvIGRlIGRhZG9zIGRlIHN0cmVhbSByYXN0ZXJpemFkb3MsIMOpIHBvc3PDrXZlbCBxdWUgbyByZXN1bHRhZG8gbsOjbyBwb3NzYSBzZXIgdXRpbGl6YWRvIG51bWEgYmFzZSBkZSBjw6lsdWxhIGEgY8OpbHVsYSwgZSBhIGRpcmXDp8OjbyBuw6NvIGlyw6EgY29ycmVzcG9uZGVyIMOgIGxvY2FsaXphw6fDo28gZGFzIGPDqWx1bGFzIGRlIHN0cmVhbS4gT3MgcmVzdWx0YWRvcyBkYSBmdW7Dp8OjbyBBY3VtdWxhw6fDo28gZGUgRmx1eG8gcG9kZW0gc2VyIHV0aWxpemFkb3MgcGFyYSBjcmlhciB1bWEgcmVkZSBkZSByYXN0ZXIgZGUgc3RyZWFtIGF0cmF2w6lzIGRhIGFwbGljYcOnw6NvIGRlIHVtIHZhbG9yIGxpbWl0ZSBwYXJhIHNlbGVjaW9uYXIgY8OpbHVsYXMgY29tIHVtIGZsdXhvIGFjdW11bGFkbyBlbGV2YWRvLiBQb3IgZXhlbXBsbywgYXMgY8OpbHVsYXMgY29tIG1haXMgZGUgMTAwIGPDqWx1bGFzIGEgZGVzZW1ib2NhcmVtIG5lbGFzIHPDo28gdXRpbGl6YWRhcyBwYXJhIGRlZmluaXIgYSByZWRlIGRlIHN0cmVhbS4gVXRpbGl6ZSBhIGZ1bsOnw6NvIENvbiBvdSBEZWZpbmlyIE51bG8gcGFyYSBjcmlhciB1bSByYXN0ZXIgZGUgcmVkZSBzdHJlYW0gbm8gcXVhbCBvcyB2YWxvcmVzIGRlIGFjdW11bGHDp8OjbyBkZSBmbHV4byBpZ3VhaXMgb3Ugc3VwZXJpb3JlcyBhIDEwMCB2w6NvIHBhcmEgdW0gZGVsZXMgZSBvcyByZXN0YW50ZXMgc8OjbyBjb2xvY2Fkb3MgZW0gc2VndW5kbyBwbGFubyAoTm9EYXRhKS4gQSByZWRlIGRlIHN0cmVhbSByZXN1bHRhbnRlIHBvZGUgc2VyIHV0aWxpemFkYSBuYSBmdW7Dp8OjbyBPcmRlbSBTdHJlYW0uIEVzdGEgZnVuw6fDo28gYXBlbmFzIHN1cG9ydGEgdW1hIGNhbWFkYSBkZSByYXN0ZXIgZGUgZGlyZcOnw6NvIGRlIGZsdXhvIGRlIGVudHJhZGEgRDguIEFzIGRpcmXDp8O1ZXMgZGUgZmx1eG8gRDggcG9kZW0gc2VyIGNyaWFkYXMgY29tIGEgZnVuw6fDo28gRGlyZcOnw6NvIGRvIEZsdXhvIGUgZXhlY3V0YWRhcyBjb20gbyB0aXBvIGRlIGRpcmXDp8OjbyBkbyBmbHV4byBwYWRyw6NvIEQ4LjwvZGl2PlwiLFxuXHRcdHNuYXBQb3VyUG9pbnROYW1lOiBcIkFqdXN0YXIgUG9udG8gZGUgRXNjb2FtZW50b1wiLFxuXHRcdHNuYXBQb3VyUG9pbnRTbmlwOiBcIkFqdXN0YSBwb250b3MgZGUgZXNjb2FtZW50byBwYXJhIGEgY8OpbHVsYSBjb20gbWFpb3IgYWN1bXVsYcOnw6NvIGRlIGZsdXhvIG51bWEgZGlzdMOibmNpYSBlc3BlY2lmaWNhZGFcIixcblx0XHRzbmFwUG91clBvaW50RGVzYzogXCJFc3RhIMOpIHVtYSBmdW7Dp8OjbyByYXN0ZXIgZ2xvYmFsLiBFc3RhIGZ1bsOnw6NvIGFqdXN0YSBwb250b3MgZGUgZXNjb2FtZW50byBwYXJhIGEgY8OpbHVsYSBjb20gbWFpb3IgYWN1bXVsYcOnw6NvIGRlIGZsdXhvIG51bWEgZGlzdMOibmNpYSBlc3BlY2lmaWNhZGEuPGRpdj48YnIvPkEgZnVuw6fDo28gQWp1c3RhciBQb250byBkZSBFc2NvYW1lbnRvIMOpIHV0aWxpemFkYSBwYXJhIGdhcmFudGlyIGEgc2VsZcOnw6NvIGRlIHBvbnRvcyBjb20gZmx1eG8gYWN1bXVsYWRvIGVsZXZhZG8gYW8gZGVsaW5lYXIgYmFjaWFzIGRlIGRyZW5hZ2VtIGNvbSBhIGZ1bsOnw6NvIEJhY2lhIEhpZHJvZ3LDoWZpY2EuIEEgZnVuw6fDo28gQWp1c3RhciBQb250byBkZSBFc2NvYW1lbnRvIGlyw6EgcHJvY3VyYXIgZGVudHJvIGRlIHVtYSBkaXN0w6JuY2lhIGRlIGFqdXN0ZSBlbSB0b3JubyBkb3MgcG9udG9zIGRlIGVzY29hbWVudG8gZXNwZWNpZmljYWRvcyBwYXJhIGEgY8OpbHVsYSBjb20gbyBtYWlvciBmbHV4byBhY3VtdWxhZG8gZSBtb3ZlciBvIHBvbnRvIGRlIGVzY29hbWVudG8gcGFyYSBlc3NhIGxvY2FsaXphw6fDo28uIE8gcmVzdWx0YWRvIMOpIHVtYSBjYW1hZGEgZGUgcmFzdGVyIGludGVpcmEgcXVhbmRvIGFzIGxvY2FsaXphw6fDtWVzIGRvcyBwb250b3MgZGUgZXNjb2FtZW50byBvcmlnaW5haXMgdGl2ZXJlbSBzaWRvIGFqdXN0YWRhcyBwYXJhIGxvY2FsaXphw6fDtWVzIGNvbSBtYWlvciBmbHV4byBhY3VtdWxhZG8uPC9kaXY+XCIsXG5cdFx0c2lua05hbWU6IFwiQ29sZXRvclwiLFxuXHRcdHNpbmtTbmlwOiBcIkNyaWEgdW0gcmFzdGVyIHF1ZSBpZGVudGlmaWNhIHRvZG9zIG9zIGNvbGV0b3JlcyBvdSDDoXJlYXMgZGUgZHJlbmFnZW0gaW50ZXJuYVwiLFxuXHRcdHNpbmtEZXNjOiBcIkVzdGEgw6kgdW1hIGZ1bsOnw6NvIHJhc3RlciBnbG9iYWwuIEVzdGEgZnVuw6fDo28gY3JpYSB1bWEgY2FtYWRhIGRlIHJhc3RlciBxdWUgaWRlbnRpZmljYSB0b2RvcyBvcyBjb2xldG9yZXMgb3Ugw6FyZWFzIGRlIGRyZW5hZ2VtIGludGVybmEuIFVtIGNvbGV0b3Igw6kgdW1hIGPDqWx1bGEgb3UgdW0gY29uanVudG8gZGUgY8OpbHVsYXMgZXNwYWNpYWxtZW50ZSBsaWdhZGFzIGNvbSB1bWEgZGlyZcOnw6NvIGRlIGZsdXhvIMOgIHF1YWwgbsOjbyBwb2RlIHNlciBhdHJpYnXDrWRvIHVtIGRvcyBvaXRvIHZhbG9yZXMgdsOhbGlkb3MgbnVtIHJhc3RlciBkZSBkaXJlw6fDo28gZG8gZmx1eG8uIElzdG8gcG9kZSBvY29ycmVyIHF1YW5kbyB0b2RhcyBhcyBjw6lsdWxhcyB2aXppbmhhcyBzw6NvIG1haW9yZXMgZG8gcXVlIGEgY8OpbHVsYSBkZSBwcm9jZXNzYW1lbnRvIG91IHF1YW5kbyBkdWFzIGPDqWx1bGFzIGRlc2VtYm9jYW0gdW1hIG5hIG91dHJhLCBjcmlhbmRvIHVtIGNpY2xvIGRlIGR1YXMgY8OpbHVsYXMuPGRpdj48YnIvPkEgZnVuw6fDo28gQ29sZXRvciBhcGVuYXMgc3Vwb3J0YSB1bWEgY2FtYWRhIGRlIHJhc3RlciBkZSBkaXJlw6fDo28gZGUgZmx1eG8gZGUgZW50cmFkYSBEOC4gQXMgZGlyZcOnw7VlcyBkZSBmbHV4byBEOCBwb2RlbSBzZXIgY3JpYWRhcyBjb20gYSBmdW7Dp8OjbyBEaXJlw6fDo28gZG8gRmx1eG8gZSBleGVjdXRhZGFzIGNvbSB0aXBvIGRlIGRpcmXDp8OjbyBkbyBmbHV4byBwYWRyw6NvIEQ4LiBPIHJlc3VsdGFkbyBkYSBmdW7Dp8OjbyBDb2xldG9yIMOpIHVtIHJhc3RlciBpbnRlaXJvLCBlIGNhZGEgY29sZXRvciB0ZW0gdW0gdmFsb3Igw7puaWNvIGF0cmlidcOtZG8uIEVzdGVzIHZhbG9yZXMgw7puaWNvcyBzaXR1YW0tc2UgZW50cmUgdW0gZSBvIG7Dum1lcm8gdG90YWwgZGUgY29sZXRvcmVzLiBQb3IgZXhlbXBsbywgc2UgbyBuw7ptZXJvIHRvdGFsIGZvciAxMDAwLCBvcyB2YWxvcmVzIMO6bmljb3MgdsOjbyBkZSAxIGEgMTAwMC48L2Rpdj5cIixcblx0XHRhZ2dyZWdhdGVOYW1lOiBcIkFncmVnYXJcIixcblx0XHRhZ2dyZWdhdGVTbmlwOiBcIkdlcmEgdW1hIHZlcnPDo28gZGUgcmVzb2x1w6fDo28gcmVkdXppZGEgZGUgdW0gcmFzdGVyLlwiLFxuXHRcdGFnZ3JlZ2F0ZURlc2M6IFwiQSBmdW7Dp8OjbyBBZ3JlZ2FyIGZheiBhIHJlYW1vc3RyYWdlbSBkZSB1bWEgaW1hZ2VtIHJhc3RlciBkZSBlbnRyYWRhIGEgdW1hIHJlc29sdcOnw6NvIG1lbm9zIHByZWNpc2EgY29tIGJhc2UgbnVtYSBlc3RyYXTDqWdpYSBkZSBhZ3JlZ2HDp8OjbyBlc3BlY2lmaWNhZGEuIENhZGEgY8OpbHVsYSBkZSBzYcOtZGEgY29udMOpbSBhIFNvbWEsIG8gTcOtbmltbywgbyBNw6F4aW1vLCBhIE3DqWRpYSBvdSBhIE1lZGlhbmEgZGFzIGPDqWx1bGFzIGRlIGVudHJhZGEgcXVlIHPDo28gZW5nbG9iYWRhcyBwZWxhIGV4dGVuc8OjbyBkZXNzYSBjw6lsdWxhLjxkaXY+PGJyLz5Qb2RlIGVzcGVjaWZpY2FyIG8gZmF0b3IgcGVsbyBxdWFsIHNlIHBvZGUgbXVsdGlwbGljYXIgbyB0YW1hbmhvIGRhIGPDqWx1bGEgZG8gcmFzdGVyIGRlIGVudHJhZGEuIFBvciBleGVtcGxvLCB1bSB2YWxvciBkbyBmYXRvciBkZSBjw6lsdWxhIGRlIHRyw6pzIHJlc3VsdGFyaWEgbnVtYSBzYcOtZGEgZW0gcXVlIG8gdGFtYW5obyBkZSBjw6lsdWxhIMOpIHRyw6pzIHZlemVzIG1haW9yIGRvIHF1ZSBvIGRvIHJhc3RlciBkZSBlbnRyYWRhLiBQb2RlIGRlZmluaXIgY29tbyB0cmF0YXIgYSBleHRlbnPDo28gZGEgc2HDrWRhIHNlIG8gbsO6bWVybyBkZSBsaW5oYXMgb3UgY29sdW5hcyBuYSBlbnRyYWRhIG7Do28gZm9yIHVtIG3Dumx0aXBsbyBleGF0byBkbyBmYXRvciBkYSBjw6lsdWxhLiBQb3IgcHJlZGVmaW5pw6fDo28sIG9zIGxpbWl0ZXMgc3VwZXJpb3IgZSBkaXJlaXRvIHNlcsOjbyBleHBhbmRpZG9zIHBhcmEgY29icmlyIHVtYSBleHRlbnPDo28gZXNwYWNpYWwgbWFpb3IgZG8gcXVlIGEgZG8gcmFzdGVyIGRlIGVudHJhZGEsIGEgZmltIGRlIGdhcmFudGlyIHF1ZSB0b2RhcyBhcyBjw6lsdWxhcyBkZSBlbnRyYWRhIHNlamFtIHByb2Nlc3NhZGFzLiBFbSBhbHRlcm5hdGl2YSwgb3MgbGltaXRlcyBzdXBlcmlvciBlIGRpcmVpdG8gcG9kZW0gc2VyIHJlZHV6aWRvcyBwYXJhIGNvYnJpciB1bWEgZXh0ZW5zw6NvIG1lbm9yLCBkZSBtb2RvIGEgcXVlIG8gbsO6bWVybyBkZSBsaW5oYXMgZSBjb2x1bmFzIHByb2Nlc3NhZGFzIHNlamEgdW0gbcO6bHRpcGxvIGV4YXRvIGRvIGZhdG9yIGRhIGPDqWx1bGEuIFBvZGUgZGVmaW5pciBjb21vIGFzIGPDqWx1bGFzIE5vRGF0YSBkZXZlbSBzZXIgdHJhdGFkYXMgcGVsbyBjw6FsY3VsbyBkZSBhZ3JlZ2HDp8Ojby4gTyBtZWNhbmlzbW8gcGFkcsOjbyDDqSBxdWUgYXMgY8OpbHVsYXMgTm9EYXRhIGRlIGVudHJhZGEgcXVlIHNlIGVuY29udHJlbSBuYSBleHRlbnPDo28gZXNwYWNpYWwgZGUgdW1hIGPDqWx1bGEgbWFpb3Igbm8gcmFzdGVyIGRlIHNhw61kYSBzZXLDo28gaWdub3JhZGFzIGFvIGRldGVybWluYXIgbyB2YWxvciBkZXNzYSBjw6lsdWxhIGRlIHNhw61kYS4gRW0gYWx0ZXJuYXRpdmEsIHBvZGUgZXNwZWNpZmljYXIgcXVlLCBzZSBleGlzdGlyIHVtYSDDum5pY2EgY8OpbHVsYSBOb0RhdGEgZGUgZW50cmFkYSBkZW50cm8gZGEgZXh0ZW5zw6NvIGVzcGFjaWFsIGRlIHVtYSBjw6lsdWxhIGRlIHNhw61kYSwgZXNzYSBjw6lsdWxhIHNlcsOhIE5vRGF0YSBubyByYXN0ZXIgZGUgc2HDrWRhLjwvZGl2PlwiLFxuXHRcdGNjZGNOYW1lOiBcIkFuw6FsaXNlIENDRENcIixcblx0XHRjY2RjU25pcDogXCJBdmFsaWEgYWx0ZXJhw6fDtWVzIG5vcyB2YWxvcmVzIGRlIHDDrXhlaXMgYW8gbG9uZ28gZG8gdGVtcG8gdXRpbGl6YW5kbyBvIGFsZ29yaXRtbyBkZSBEZXRlw6fDo28gZSBDbGFzc2lmaWNhw6fDo28gZGUgQWx0ZXJhw6fDtWVzIENvbnTDrW51YXMgKENDREMpIGUgZ2VyYSByZXN1bHRhZG9zIGRlIG1vZGVsb3MuXCIsXG5cdFx0Y2NkY0Rlc2M6IFwiQSBmdW7Dp8OjbyBBbsOhbGlzZSBDQ0RDIGF2YWxpYSBhcyBhbHRlcmHDp8O1ZXMgbm9zIHZhbG9yZXMgZGUgcMOteGVpcyBhbyBsb25nbyBkbyB0ZW1wbyB1dGlsaXphbmRvIG8gYWxnb3JpdG1vIGRlIERldGXDp8OjbyBlIENsYXNzaWZpY2HDp8OjbyBkZSBBbHRlcmHDp8O1ZXMgQ29udMOtbnVhcyAoQ0NEQykgZSBnZXJhIHVtIHJhc3RlciBtdWx0aWRpbWVuc2lvbmFsIGNvbSBvcyByZXN1bHRhZG9zIGRvIG1vZGVsby4gU8OzIMOpIHN1cG9ydGFkYSBlbSBjb25qdW50byBjb20gYSBmdW7Dp8OjbyBEZXRldGFyIEFsdGVyYcOnw7VlcyBBdHJhdsOpcyBkYSBBbsOhbGlzZSBkZSBBbHRlcmHDp8O1ZXMgbnVtIG1vZGVsbyBkZSBmdW7Dp8OjbyByYXN0ZXIuIFBhcmEgcHJvZHV6aXIgdW1hIHNhw61kYSBkZSByYXN0ZXIsIGFzc29jaWUgYSBmdW7Dp8OjbyBBbsOhbGlzZSBDQ0RDIMOgIGZ1bsOnw6NvIERldGV0YXIgQWx0ZXJhw6fDtWVzIEF0cmF2w6lzIGRhIEFuw6FsaXNlIGRlIEFsdGVyYcOnw7VlcywgZ3VhcmRlIGNvbW8gdW0gbW9kZWxvIGRlIGZ1bsOnw6NvIHJhc3RlciBlIGV4ZWN1dGUgYSBBbsOhbGlzZSBSYXN0ZXIgY29tIG8gbW9kZWxvIGRlIGZ1bsOnw6NvLjxkaXY+PGJyLz5Fc3RhIGZ1bsOnw6NvIHV0aWxpemEgbyBhbGdvcml0bW8gZGUgRGV0ZcOnw6NvIGUgQ2xhc3NpZmljYcOnw6NvIGRlIEFsdGVyYcOnw7VlcyBDb250w61udWFzIChDQ0RDKSBwYXJhIGF2YWxpYXIgYXMgYWx0ZXJhw6fDtWVzIG5vcyB2YWxvcmVzIGRlIHDDrXhlbCBhbyBsb25nbyBkbyB0ZW1wbyBwYXJhIHVtYSBwaWxoYSBkZSBpbWFnZW5zLiBOdW1hIHPDqXJpZSB0ZW1wb3JhbCBkZSBpbWFnZW5zIMOzdGljYXMgb3UgZGVyaXZhZG9zIGRlIGltYWdlbnMgKHBvciBleGVtcGxvLCBORFZJKSwgb3MgdmFsb3JlcyBkZSBww614ZWlzIHBvZGVtIGZsdXR1YXIgcG9yIHbDoXJpYXMgcmF6w7VlczogMS4gQWx0ZXJhw6fDo28gc2F6b25hbCAtLSBBcyBhbHRlcmHDp8O1ZXMgbm8gdmFsb3IgZG9zIHDDrXhlaXMgcmVmbGV0ZW0gYWx0ZXJhw6fDtWVzIG5hIHZlZ2V0YcOnw6NvIGRldmlkbyDDoCB2YXJpYWJpbGlkYWRlIHNhem9uYWwgZGEgdGVtcGVyYXR1cmEgZSBkYSBwcmVjaXBpdGHDp8Ojby4gTm8gSGVtaXNmw6lyaW8gTm9ydGUsIHBvciBleGVtcGxvLCBlc3BlcmFtb3MgdmVyIHVtYSBtYWlvciBkZW5zaWRhZGUgZGUgdmVnZXRhw6fDo28gdmVyZGUgbm8gdmVyw6NvIGVtIGNvbXBhcmHDp8OjbyBjb20gbyBpbnZlcm5vOyAyLiBBbHRlcmHDp8OjbyBncmFkdWFsIC0tIEFzIGFsdGVyYcOnw7VlcyBubyB2YWxvciBkZSBww614ZWlzIHJlZmxldGVtIGFzIHRlbmTDqm5jaWFzIGRhIHZlZ2V0YcOnw6NvIG91IGRhcyDDoWd1YXMgc3VwZXJmaWNpYWlzIGRldmlkbyDDoCB2YXJpYWJpbGlkYWRlIGNsaW3DoXRpY2Egb3Ugw6BzIHByw6F0aWNhcyBkZSBnZXN0w6NvIGRvIHNvbG8gYSBsb25nbyBwcmF6by4gUG9yIGV4ZW1wbG8sIG9zIHNvbG9zIGRlc2NvYmVydG9zIHBvZGVtIGF1bWVudGFyIGdyYWR1YWxtZW50ZSBlbSDDoXJlYSBkZXZpZG8gw6AgZGltaW51acOnw6NvIGRhIHByZWNpcGl0YcOnw6NvIGEgbG9uZ28gcHJhem87IGUgMy4gQWx0ZXJhw6fDo28gYWJydXB0YSAtLSBBcyBhbHRlcmHDp8O1ZXMgbm8gdmFsb3IgZG9zIHDDrXhlaXMgcmVmbGV0ZW0gYXMgYWx0ZXJhw6fDtWVzIG5hIGNvYmVydHVyYSBkbyBzb2xvIHF1ZSBvY29ycmVtIHN1Yml0YW1lbnRlIGRldmlkbyDDoCBkZXNmbG9yZXN0YcOnw6NvLCBkZXNlbnZvbHZpbWVudG8gdXJiYW5vLCBjYXTDoXN0cm9mZXMgbmF0dXJhaXMsIGV0Yy4gTyBhbGdvcml0bW8gQ0NEQyBpZGVudGlmaWNhIG9zIHRyw6pzIHRpcG9zIGRlIGFsdGVyYcOnw7VlcyBjb20gbyBvYmpldGl2byBwcmluY2lwYWwgZGUgaWRlbnRpZmljYXIgYWx0ZXJhw6fDtWVzIGFicnVwdGFzLiBPcyBtb2RlbG9zIGRlIHJlZ3Jlc3PDo28gaGFybcOzbmljYSBlIGRlIHRlbmTDqm5jaWEgc8OjbyBhanVzdGFkb3MgYW9zIGRhZG9zIHBhcmEgZXN0aW1hciBhcyBhbHRlcmHDp8O1ZXMgc2F6b25haXMgZSBncmFkdWFpcywgZSBvcyBkZXN2aW9zIGJydXNjb3MgZW0gcmVsYcOnw6NvIGFvcyBtb2RlbG9zIGRlIHRlbmTDqm5jaWEgc8OjbyBpbmRpY2HDp8O1ZXMgZGUgYWx0ZXJhw6fDtWVzIGFicnVwdGFzLjxkaXY+PGJyLz5PIGFsZ29yaXRtbyBDQ0RDIGZvaSBvcmlnaW5hbG1lbnRlIGNvbmNlYmlkbyBwYXJhIGRhZG9zIGRlIFJlZmxldMOibmNpYSBkZSBTdXBlcmbDrWNpZSBvdSBUZW1wZXJhdHVyYSBkZSBCcmlsaG8gZGUgZGFkb3MgTGFuZHNhdCBUTSwgTGFuZHNhdCBFVE0rIGUgTGFuZHNhdCBPTEkuIE5vIGVudGFudG8sIGEgZnVuw6fDo28gRGV0ZXRhciBBbHRlcmHDp8O1ZXMgQXRyYXbDqXMgZGEgQW7DoWxpc2UgZGUgQWx0ZXJhw6fDtWVzIGVtIGNvbmp1bnRvIGNvbSBlc3RhIGZ1bsOnw6NvIGlyw6EgZGV0ZXRhciBhbHRlcmHDp8O1ZXMgcGFyYSBpbWFnZW5zIG11bHRpYmFuZGEgYSBwYXJ0aXIgZGUgcXVhbHF1ZXIgc2Vuc29yIHN1cG9ydGFkbywgYmVtIGNvbW8gZGVyaXZhZG9zIGRlIGltYWdlbnMgZGUgYmFuZGEgw7puaWNhLCB0YWlzIGNvbW8gw61uZGljZXMgZGUgYmFuZGEuIFBvciBleGVtcGxvLCDDqSBwb3Nzw612ZWwgcmVhbGl6YXIgYSBkZXRlw6fDo28gZGUgYWx0ZXJhw6fDtWVzIGNvbnTDrW51YXMgbnVtIHJhc3RlciBkZSDDjW5kaWNlIGRlIFZlZ2V0YcOnw6NvIGRlIERpZmVyZW7Dp2EgTm9ybWFsaXphZGEgKE5EVkkpLCBwb3JxdWUgYWx0ZXJhw6fDtWVzIGFicnVwdGFzIG5vIE5EVkkgcG9kZW0gc2VyIGluZGljYXRpdmFzIGRlIGRlc2Zsb3Jlc3Rhw6fDo28uPC9kaXY+XCIsXG5cdFx0Y29tcHV0ZUNoYW5nZU5hbWU6IFwiQ2FsY3VsYXIgQWx0ZXJhw6fDo29cIixcblx0XHRjb21wdXRlQ2hhbmdlU25pcDogXCJDYWxjdWxhIGEgZGlmZXJlbsOnYSBlbnRyZSBkb2lzIGNvbmp1bnRvcyBkZSBkYWRvcyByYXN0ZXIgY2F0ZWfDs3JpY29zIG91IGNvbnTDrW51b3MuXCIsXG5cdFx0Y29tcHV0ZUNoYW5nZURlc2M6IFwiQSBmdW7Dp8OjbyBDYWxjdWxhciBBbHRlcmHDp8OjbyBwb2RlIHNlciB1dGlsaXphZGEgcGFyYSBlbnVtZXJhciBhcyBkaWZlcmVuw6dhcyBlbnRyZSBkb2lzIHJhc3RlcnMgY2xhc3NpZmljYWRvcyBwYXJhIGFuw6FsaXNlIGRhIGFsdGVyYcOnw6NvIGRhIGNvYmVydHVyYSBkbyBzb2xvLCBvdSBwb2RlIHNlciB1dGlsaXphZGEgcGFyYSBleGFtaW5hciBhcyBhbHRlcmHDp8O1ZXMgZW50cmUgZG9pcyByYXN0ZXJzIGNvbnTDrW51b3MgZGUgYmFuZGEgw7puaWNhLCBjb21vIGEgZWxldmHDp8OjbywgdGVtcGVyYXR1cmEsIGNvYmVydG8gZmxvcmVzdGFsLCBldGMuXCIsXG5cdFx0ZGV0ZWN0Q2hhbmdlTmFtZTogXCJEZXRldGFyIEFsdGVyYcOnw7VlcyBBdHJhdsOpcyBkYSBBbsOhbGlzZSBkZSBBbHRlcmHDp8O1ZXNcIixcblx0XHRkZXRlY3RDaGFuZ2VTbmlwOiBcIkdlcmEgdW1hIGNhbWFkYSByYXN0ZXIgcXVlIGNvbnTDqW0gaW5mb3JtYcOnw7VlcyBzb2JyZSBhbHRlcmHDp8O1ZXMgZGUgcMOteGVpcyB1dGlsaXphbmRvIG8gcmFzdGVyIGRlIGFuw6FsaXNlIGRlIGFsdGVyYcOnw7VlcyBkZSBzYcOtZGEuXCIsXG5cdFx0ZGV0ZWN0Q2hhbmdlRGVzYzogXCI8ZGl2PkEgZnVuw6fDo28gRGV0ZXRhciBNdWRhbsOnYXMgQXRyYXbDqXMgZGEgQW7DoWxpc2UgZGUgQWx0ZXJhw6fDtWVzIGdlcmEgdW1hIGNhbWFkYSByYXN0ZXIgcXVlIGNvbnTDqW0gaW5mb3JtYcOnw7VlcyBzb2JyZSBhIGRhdGEgZGUgYWx0ZXJhw6fDo28gZGUgcMOteGVpcyB1dGlsaXphbmRvIG8gcmFzdGVyIGRlIGFuw6FsaXNlIGRlIGFsdGVyYcOnw7Vlcy4gTyByYXN0ZXIgZGUgYW7DoWxpc2UgZGUgYWx0ZXJhw6fDtWVzIHRlbSBkZSBzZXIgZ2VyYWRvIHBlbGEgZmVycmFtZW50YSBBbmFsaXNhciBBbHRlcmHDp8O1ZXMgQXRyYXbDqXMgZGUgQ0NEQyBvdSBBbmFsaXNhciBBbHRlcmHDp8O1ZXMgQXRyYXbDqXMgZGUgTGFuZFRyZW5kciBvdSBhIGZ1bsOnw6NvIHJhc3RlciBBbsOhbGlzZSBDQ0RDIG91IHJhc3RlciBBbsOhbGlzZSBMYW5kVHJlbmRyLjwvZGl2Pjxicj48ZGl2PkVzdGEgZnVuw6fDo28gcmFzdGVyIHBvZGUgc2VyIGNvbWJpbmFkYSBjb20gYSBmdW7Dp8OjbyByYXN0ZXIgQW7DoWxpc2UgQ0NEQyBvdSByYXN0ZXIgQW7DoWxpc2UgTGFuZFRyZW5kciBudW0gbW9kZWxvIGRlIGZ1bsOnw6NvIHJhc3Rlci4gUGFyYSBwcm9kdXppciB1bWEgc2HDrWRhIGRlIHJhc3RlciwgYXNzb2NpZSBhIGZ1bsOnw6NvIEFuw6FsaXNlIENDREMgb3UgQW7DoWxpc2UgTGFuZFRyZW5kciDDoCBmdW7Dp8OjbyBEZXRldGFyIEFsdGVyYcOnw7VlcyBBdHJhdsOpcyBkYSBBbsOhbGlzZSBkZSBBbHRlcmHDp8O1ZXMsIGd1YXJkZSBjb21vIHVtIG1vZGVsbyBkZSBmdW7Dp8OjbyByYXN0ZXIgZSBleGVjdXRlIGEgQW7DoWxpc2UgUmFzdGVyIGNvbSBvIG1vZGVsbyBkZSBmdW7Dp8Ojby48L2Rpdj48YnI+PGRpdj5PIHBhcsOibWV0cm8gPHN0cm9uZz5UaXBvIGRlIEFsdGVyYcOnw6NvPC9zdHJvbmc+IGluZGljYSBhcyBpbmZvcm1hw6fDtWVzIHF1ZSBzw6NvIGdlcmFkYXMuIEFzIGluZm9ybWHDp8O1ZXMgc8OjbyBleHRyYcOtZGFzIGRvIHJhc3RlciBkZSBhbsOhbGlzZSBkZSBhbHRlcmHDp8O1ZXMuIEFvIGV4ZWN1dGFyIGVzdGEgZnVuw6fDo28gbmEgc2HDrWRhIGRhIGZ1bsOnw6NvL2ZlcnJhbWVudGEgQ0NEQywgcG9kZSBlc2NvbGhlciBlbnRyZSBhcyBzZWd1aW50ZXMgb3DDp8O1ZXM6PC9kaXY+PHVsPjxsaT48c3Ryb25nPkhvcmEgZGEgw7psdGltYSBhbHRlcmHDp8Ojbzwvc3Ryb25nPiAtIGEgZGF0YSBlIGhvcmEgbWFpcyByZWNlbnRlcyBlbSBxdWUgdW0gcMOteGVsIGZvaSBzaW5hbGl6YWRvIGNvbW8gYWx0ZXJhZG8uPC9saT48bGk+PHN0cm9uZz5Ib3JhIGRhIGFsdGVyYcOnw6NvIG1haXMgYW50aWdhPC9zdHJvbmc+IC0gYSBwcmltZWlyYSBkYXRhIGUgaG9yYSBlbSBxdWUgdW0gcMOteGVsIGZvaSBzaW5hbGl6YWRvIGNvbW8gYWx0ZXJhZG8uPC9saT48bGk+PHN0cm9uZz5Ib3JhIGRhIG1haW9yIGFsdGVyYcOnw6NvPC9zdHJvbmc+IC0gYSBkYXRhIGUgaG9yYSBlbSBxdWUgYSBhbHRlcmHDp8OjbyBjYWxjdWxhZGEgZm9pIGEgbWFpcyBzaWduaWZpY2F0aXZhIHBhcmEgdW0gcMOteGVsLjwvbGk+PGxpPiA8c3Ryb25nPk7Dum1lcm8gZGUgYWx0ZXJhw6fDtWVzPC9zdHJvbmc+IC0gbyBuw7ptZXJvIHRvdGFsIGRlIHZlemVzIHF1ZSBvIHDDrXhlbCBmb2kgYWx0ZXJhZG8uPC9saT48L3VsPjxkaXY+QW8gZXhlY3V0YXIgZXN0YSBmdW7Dp8OjbyBuYSBzYcOtZGEgZGEgZnVuw6fDo28vZmVycmFtZW50YSBMYW5kVHJlbmRyLCBhcyBzZWd1aW50ZXMgb3DDp8O1ZXMgYWRpY2lvbmFpcyBlc3TDo28gZGlzcG9uw612ZWlzOjwvZGl2Pjx1bD48bGk+PHN0cm9uZz5Ib3JhIGRhIG1haW9yIGFsdGVyYcOnw6NvPC9zdHJvbmc+IC0gYSBkYXRhIGVtIHF1ZSB1bSBww614ZWwgZm9pIHNpbmFsaXphZG8gY29tbyBhbHRlcmFkbywgbm8gaW7DrWNpbyBvdSBubyBmaW5hbCBkbyBwZXLDrW9kbyBtYWlzIGxvbmdvIGRlIGFsdGVyYcOnw7Vlcy48L2xpPjxsaT48c3Ryb25nPkhvcmEgZGEgbWVub3IgYWx0ZXJhw6fDo288L3N0cm9uZz4gLSBhIGRhdGEgZW0gcXVlIHVtIHDDrXhlbCBmb2kgc2luYWxpemFkbyBjb21vIGFsdGVyYWRvLCBubyBpbsOtY2lvIG91IG5vIGZpbmFsIGRvIHBlcsOtb2RvIG1haXMgY3VydG8gZGUgYWx0ZXJhw6fDtWVzLjwvbGk+PGxpPjxzdHJvbmc+SG9yYSBkYSBhbHRlcmHDp8OjbyBtYWlzIHLDoXBpZGE8L3N0cm9uZz4gLSBhIGRhdGEgZW0gcXVlIHVtIHDDrXhlbCBmb2kgc2luYWxpemFkbyBjb21vIGFsdGVyYWRvLCBubyBpbsOtY2lvIG91IG5vIGZpbmFsIGRvIHBlcsOtb2RvIGRlIGFsdGVyYcOnw7VlcyBtYWlzIHLDoXBpZG8uPC9saT48bGk+PHN0cm9uZz5Ib3JhIGRhIGFsdGVyYcOnw6NvIG1haXMgbGVudGE8L3N0cm9uZz4gLSBhIGRhdGEgZW0gcXVlIHVtIHDDrXhlbCBmb2kgc2luYWxpemFkbyBjb21vIGFsdGVyYWRvLCBubyBpbsOtY2lvIG91IG5vIGZpbmFsIGRvIHBlcsOtb2RvIG1haXMgbGVudG8gZGUgYWx0ZXJhw6fDtWVzLjwvbGk+PC91bD48ZGl2Pk8gcmFzdGVyIGRlIHNhw61kYSDDqSB1bSByYXN0ZXIgbXVsdGliYW5kYSBlbSBxdWUgY2FkYSBiYW5kYSBjb250w6ltIGluZm9ybWHDp8O1ZXMgZGUgYWx0ZXJhw6fDo28gY29uc29hbnRlIG8gdGlwbyBkZSBhbHRlcmHDp8OjbyBzZWxlY2lvbmFkbyBlIG8gbsO6bWVybyBtw6F4aW1vIGRlIGFsdGVyYcOnw7VlcyBlc3BlY2lmaWNhZG8uIFBvciBleGVtcGxvLCBzZSBvIHBhcsOibWV0cm8gPHN0cm9uZz5UaXBvIGRlIEFsdGVyYcOnw6NvPC9zdHJvbmc+IGVzdGl2ZXIgZGVmaW5pZG8gcGFyYSA8c3Ryb25nPkhvcmEgZGEgQWx0ZXJhw6fDo28gbWFpcyBBbnRpZ2E8L3N0cm9uZz4gZSBvIDxzdHJvbmc+TsO6bWVybyBNw6F4aW1vIGRlIEFsdGVyYcOnw7Vlczwvc3Ryb25nPiBlc3RpdmVyIGRlZmluaWRvIHBhcmEgMiwgYSBmdW7Dp8OjbyBjYWxjdWxhIGFzIGR1YXMgcHJpbWVpcmFzIGRhdGFzIG1haXMgYW50aWdhcyBlbSBxdWUgYSBhbHRlcmHDp8OjbyBvY29ycmV1IGFvIGxvbmdvIGRhIHPDqXJpZSB0ZW1wb3JhbCBwYXJhIGNhZGEgcMOteGVsLiBPIHJlc3VsdGFkbyDDqSB1bSByYXN0ZXIgZW0gcXVlIGEgcHJpbWVpcmEgYmFuZGEgY29udMOpbSBhcyBkYXRhcyBkYSBwcmltZWlyYSBhbHRlcmHDp8OjbyBtYWlzIGFudGlnYSBwb3IgcMOteGVsIGUgYSBzZWd1bmRhIGJhbmRhIGNvbnTDqW0gYXMgZGF0YXMgZGEgc2VndW5kYSBhbHRlcmHDp8OjbyBtYWlzIGFudGlnYSBwb3IgcMOteGVsLjwvZGl2Pjxicj48ZGl2PkFvIGFwbGljYXIgZXN0YSBmdW7Dp8OjbyBuYSBzYcOtZGEgZGFzIGZlcnJhbWVudGFzIExhbmRUcmVuZHIsIHBvZGUgZXNjb2xoZXIgc2UgcHJldGVuZGUgZXh0cmFpciBhIGRhdGEgcXVlIG1hcmNhIG8gaW7DrWNpbyBkZSB1bWEgYWx0ZXJhw6fDo28gb3UgbyBmaW0gZGUgdW1hIGFsdGVyYcOnw6NvIGNvbSBvIHBhcsOibWV0cm8gPHN0cm9uZz5EYXRhIGRvIFNlZ21lbnRvPC9zdHJvbmc+LiBQb3IgZXhlbXBsbywgcGFyYSBjb21wcmVlbmRlciBjb21vIGEgYWx0ZXJhw6fDo28gbWFpcyByZWNlbnRlIG5hIHPDqXJpZSB0ZW1wb3JhbCBjb21lw6dvdSwgZGVmaW5hIG8gcGFyw6JtZXRybyA8c3Ryb25nPlRpcG8gZGUgQWx0ZXJhw6fDo288L3N0cm9uZz4gcGFyYSA8c3Ryb25nPkhvcmEgZGEgw7psdGltYSBhbHRlcmHDp8Ojbzwvc3Ryb25nPiBlIDxzdHJvbmc+RGF0YSBkbyBTZWdtZW50bzwvc3Ryb25nPiBwYXJhIDxzdHJvbmc+SW7DrWNpbyBkbyBzZWdtZW50bzwvc3Ryb25nPi48L2Rpdj48YnI+PGRpdj5Vc2Ugb3Mgc2VndWludGVzIHBhcsOibWV0cm9zIGRlIGZpbHRyYWdlbSBwYXJhIGV4dHJhaXIgZGF0YXMgbWFpcyBlc3BlY8OtZmljYXMgZGUgYWx0ZXJhw6fDtWVzIGRvIHNldSByYXN0ZXIgZGUgYW7DoWxpc2UgZGUgYWx0ZXJhw6fDtWVzOjwvZGl2Pjx1bD48bGk+PHN0cm9uZz5GaWx0cmFyIHBvciBhbm88L3N0cm9uZz4gLSBpZGVudGlmaXF1ZSBhcyBhbHRlcmHDp8O1ZXMgcXVlIG9jb3JyZXJhbSBudW0gcGVyw61vZG8gZGUgdGVtcG8gZXNwZWPDrWZpY28sIHBvciBleGVtcGxvLCBzZSBlc3RpdmVyIMOgIHByb2N1cmEgZGUgYWx0ZXJhw6fDtWVzIHF1ZSBvY29ycmVyYW0gbnVtYSBwYWlzYWdlbSBkdXJhbnRlIGNpbmNvIGFub3MgZGUgc2VjYS48L2xpPjxsaT48c3Ryb25nPkZpbHRyYXIgcG9yIGR1cmHDp8Ojbzwvc3Ryb25nPiAtIGlkZW50aWZpcXVlIGFzIGFsdGVyYcOnw7VlcyBxdWUgb2NvcnJlcmFtIGFvIGxvbmdvIGRlIHVtIGRldGVybWluYWRvIGludGVydmFsbyBkZSBhbm9zLCBwb3IgZXhlbXBsbywgc2UgZXN0aXZlciBhcGVuYXMgw6AgcHJvY3VyYSBkZSBhbHRlcmHDp8O1ZXMgYWJydXB0YXMgcXVlIG9jb3JyZXJhbSBhbyBsb25nbyBkZSAxIG91IDIgYW5vcy4gUG9kZSBjYWxjdWxhciBhIGR1cmHDp8OjbyBxdWUgcHJldGVuZGUgYW8gdXNhciBhIGbDs3JtdWxhIDxzdHJvbmc+YW5vIGZpbmFsIC0gYW5vIGluaWNpYWwgKzE8L3N0cm9uZz4uIEFzIGxhY3VuYXMgbmEgc8OpcmllIHRlbXBvcmFsIHNlcsOjbyBpbmNsdcOtZGFzLjwvbGk+PGxpPjxzdHJvbmc+RmlsdHJhciBwb3IgbWFnbml0dWRlPC9zdHJvbmc+IC0gaWRlbnRpZmlxdWUgYWx0ZXJhw6fDtWVzIGRlIHVtYSBkZXRlcm1pbmFkYSBtYWduaXR1ZGUsIHBvciBleGVtcGxvLCBzZSBlc3RpdmVyIGFwZW5hcyDDoCBwcm9jdXJhIGRlIGdyYW5kZXMgYWx0ZXJhw6fDtWVzIG5vIMOtbmRpY2UgZGUgdmVnZXRhw6fDo28gTkRWSS4gQSBtYWduaXR1ZGUgw6kgdW0gdmFsb3IgYWJzb2x1dG8sIHBvciBpc3NvLCBvcyB2YWxvcmVzIG3DrW5pbW9zIGUgbcOheGltb3MgbsOjbyBwb2RlbSBzZXIgbmVnYXRpdm9zLiBQYXJhIGVzcGVjaWZpY2FyIGEgYWx0ZXJhw6fDo28gZGlyZWNpb25hbCwgdXNlIG8gcGFyw6JtZXRybyA8c3Ryb25nPkRpcmXDp8OjbyBkYSBBbHRlcmHDp8Ojbzwvc3Ryb25nPi48L2xpPjwvdWw+XCIsXG5cdFx0ZGlzdGFuY2VBY2N1bXVsYXRpb25OYW1lOiBcIkFjdW11bGHDp8OjbyBkZSBEaXN0w6JuY2lhXCIsXG5cdFx0ZGlzdGFuY2VBY2N1bXVsYXRpb25TbmlwOiBcIkNhbGN1bGEgYSBkaXN0w6JuY2lhIGFjdW11bGFkYSBwYXJhIGNhZGEgY8OpbHVsYSBhdMOpIMOgcyBvcmlnZW5zLCBwZXJtaXRpbmRvIGEgZGlzdMOibmNpYSBlbSBsaW5oYSByZXRhLCBkaXN0w6JuY2lhIGRlIGN1c3RvLCBkaXN0w6JuY2lhIGRlIHN1cGVyZsOtY2llIHZlcmRhZGVpcmEsIGJlbSBjb21vIGZhdG9yZXMgZGUgY3VzdG8gdmVydGljYWlzIGUgaG9yaXpvbnRhaXMuXCIsXG5cdFx0ZGlzdGFuY2VBY2N1bXVsYXRpb25EZXNjOiBcIkEgYWN1bXVsYcOnw6NvIGRlIGRpc3TDom5jaWEgY2FsY3VsYSBhIGRpc3TDom5jaWEgYSBjYWRhIGxvY2FsIGRhIMOhcmVhIGRlIGVzdHVkbyBhdMOpIMOgIG9yaWdlbSBtYWlzIHByw7N4aW1hIG91IGRlIG1lbm9yIGN1c3RvLiBTZSBhcGVuYXMgZm9yZW0gZm9ybmVjaWRhcyBhcyBvcmlnZW5zIHBhcmEgZW50cmFkYSwgw6kgY2FsY3VsYWRhIHVtYSBkaXN0w6JuY2lhIGVtIGxpbmhhIHJldGEgcGFyYSBjYWRhIGxvY2FsIG5hIMOhcmVhIGRlIGVzdHVkby4gU2UgdGFudG8gYXMgb3JpZ2VucyBjb21vIGFzIGJhcnJlaXJhcyBmb3JlbSB1dGlsaXphZGFzIGNvbW8gZW50cmFkYSwgZW50w6NvIGEgQWN1bXVsYcOnw6NvIGRlIERpc3TDom5jaWEgY2FsY3VsYSBhIGRpc3TDom5jaWEgZW0gbGluaGEgcmV0YSBlbSB0b3JubyBkYXMgYmFycmVpcmFzLiBUYW50byBwYXJhIG8gcmFzdGVyIGRlIG9yaWdlbSBjb21vIHBhcmEgbyByYXN0ZXIgZGUgYmFycmVpcmEsIG8gdmFsb3IgZGUgZnVuZG8gZGV2ZSBzZXIgTm9EYXRhLCBlbnF1YW50byBhcyBvcmlnZW5zIGUgYmFycmVpcmFzIHPDo28gcmVwcmVzZW50YWRhcyBjb20gdmFsb3JlcyB2w6FsaWRvcyBkZSBjw6lsdWxhcy4gT3MgdmFsb3JlcyB2w6FsaWRvcyBpbmNsdWVtIHplcm8uIDxkaXY+PGJyLz5RdWFuZG8gdW0gcmFzdGVyIGRlIHN1cGVyZsOtY2llIMOpIGZvcm5lY2lkbyBjb21vIGVudHJhZGEsIMOpIGNhbGN1bGFkYSBhIGRpc3TDom5jaWEgcmVhbCBkYSBzdXBlcmbDrWNpZSBlbnRyZSBjw6lsdWxhcy4gUGFyYSByZWFsaXphciBhIGFuw6FsaXNlIGRlIGN1c3RvcyB1dGlsaXphbmRvIGEgQWN1bXVsYcOnw6NvIGRlIERpc3TDom5jaWEsIMOpIG5lY2Vzc8OhcmlhIHVtYSBzdXBlcmbDrWNpZSBkZSBjdXN0by4gU2UgZm9yIGZvcm5lY2lkYSB1bWEgc3VwZXJmw61jaWUgZGUgY3VzdG8sIG8gcmVzdWx0YWRvIHNlcsOhIHVtIHJhc3RlciBkZSBkaXN0w6JuY2lhIGRlIGN1c3RvIGFjdW11bGFkby4gUXVhbmRvIHPDo28gZm9ybmVjaWRvcyBmYXRvcmVzIGhvcml6b250YWlzIGUgdmVydGljYWlzLCBhIGRpcmVjaW9uYWxpZGFkZSDDqSBjb25zaWRlcmFkYSBjb21vIGN1c3RvIGFjdW11bGFkby4gRXhpc3RlbSBxdWF0cm8gY2FyYWN0ZXLDrXN0aWNhcyBkYSBvcmlnZW0gcXVlIHBvZGVtIHNlciB1dGlsaXphZGFzLiBFc3RhcyBjYXJhY3RlcsOtc3RpY2FzLCBxdWUgcG9kZW0gc2VyIHRhbnRvIGRhIG9yaWdlbSBjb21vIGRvcyBtb3RvcmVzIGRhIG9yaWdlbSwgc8OjbyBjb250cm9sYWRhcyBwb3IgcGFyw6JtZXRyb3MgZXNwZWPDrWZpY29zOiAxLiBBIGFjdW11bGHDp8OjbyBpbmljaWFsOuKAr2RlZmluZSBvIGN1c3RvIGluaWNpYWwgYW50ZXMgZG8gaW7DrWNpbyBkbyBtb3ZpbWVudG8uIDIuIEEgYWN1bXVsYcOnw6NvIG3DoXhpbWE64oCvZXNwZWNpZmljYSBvIGN1c3RvIHF1ZSB1bWEgb3JpZ2VtIHBvZGUgYWN1bXVsYXIgYW50ZXMgZGUgYXRpbmdpciBvIHNldSBsaW1pdGUuIDMuIE8gbXVsdGlwbGljYWRvciBhIGFwbGljYXIgYW9zIGN1c3RvczrigK9lc3BlY2lmaWNhIG8gbW9kbyBkZSBkZXNsb2Nhw6fDo28gb3UgYSBtYWduaXR1ZGUgbmEgb3JpZ2VtLiA0LiBBIGRpcmXDp8OjbyBkYSB2aWFnZW064oCvaWRlbnRpZmljYSBzZSBvIG1vdG9yIGVzdMOhIGEgY29tZcOnYXIgbnVtYSBvcmlnZW0gZSBhIGRlc2xvY2FyLXNlIHBhcmEgbG9jYWlzIG7Do28gZGUgb3JpZ2VtLCBvdSBzZSBlc3TDoSBhIGNvbWXDp2FyIGVtIGxvY2FpcyBuw6NvIGRlIG9yaWdlbSBlIGEgZGVzbG9jYXItc2UgZGUgdm9sdGEgcGFyYSB1bWEgb3JpZ2VtLjxkaXY+PGJyLz5Qb3IgcHJlZGVmaW5pw6fDo28sIG8gcmVzdWx0YWRvIGRhIEFjdW11bGHDp8OjbyBkZSBEaXN0w6JuY2lhIMOpIHVtYSBiYW5kYSDDum5pY2EsIHF1ZSDDqSBvIHJhc3RlciBkZSBhY3VtdWxhw6fDo28gZGUgZGlzdMOibmNpYS4gTm8gZW50YW50bywgdGFtYsOpbSBwb2RlIHNlciBjcmlhZGEgdW1hIHNlZ3VuZGEgYmFuZGEsIGEgYmFuZGEgZGUgZGlyZcOnw6NvIGRlIHJldG9ybm8uIEVzdGEgYmFuZGEgaW5kaWNhLCBhIHBhcnRpciBkZSBjYWRhIGxvY2FsIG5hIMOhcmVhIGRlIGVzdHVkbywgcXVhbCBhIGRpcmXDp8OjbyBhIHNlZ3VpciBwYXJhIGNoZWdhciDDoCBvcmlnZW0gZGUgbWVub3IgY3VzdG8uIEFtYmFzIGFzIGJhbmRhcyBzZXLDo28gbmVjZXNzw6FyaWFzIHBhcmEgZGV0ZXJtaW5hciBvcyBtZWxob3JlcyBwZXJjdXJzb3MgZGVudHJvIGRhIMOhcmVhIGRlIGVzdHVkby4gUGFyYSBnZXJhciB1bSBwZXJjdXJzbywgdXRpbGl6ZSBwcmltZWlybyBhIGZ1bsOnw6NvIEV4dHJhaXIgQmFuZGEgcGFyYSBleHRyYWlyIG8gcmFzdGVyIGRlIGFjdW11bGHDp8OjbyBkZSBkaXN0w6JuY2lhIGUgbyByYXN0ZXIgZGUgZGlyZcOnw6NvIGRlIHJldG9ybm8uIFV0aWxpemUgZXN0YXMgY2FtYWRhcyBjb21vIGVudHJhZGEgcGFyYSBhIGZ1bsOnw6NvIFBlcmN1cnNvIGRlIEN1c3Rvcy4gTmEgZnVuw6fDo28sIHV0aWxpemUgbyByYXN0ZXIgZGUgYWN1bXVsYcOnw6NvIGRlIGRpc3TDom5jaWEgY29tbyBlbnRyYWRhIGRlIFJhc3RlciBkZSBDdXN0byBkZSBEaXN0w6JuY2lhIGUgbyByYXN0ZXIgZGUgZGlyZcOnw6NvIGRlIHJldG9ybm8gY29tbyBlbnRyYWRhIGRlIFJhc3RlciBkZSBMaWdhw6fDo28gSW52ZXJzYSBkZSBDdXN0by48L2Rpdj5cIixcblx0XHRkaXN0YW5jZUFsbG9jYXRpb25OYW1lOiBcIkF0cmlidWnDp8OjbyBkZSBEaXN0w6JuY2lhXCIsXG5cdFx0ZGlzdGFuY2VBbGxvY2F0aW9uU25pcDogXCJDYWxjdWxhIGEgYXRyaWJ1acOnw6NvIGRlIGRpc3TDom5jaWFzIHBhcmEgY2FkYSBjw6lsdWxhIGF0w6kgw6BzIG9yaWdlbnMgZm9ybmVjaWRhcyBjb20gYmFzZSBuYSBkaXN0w6JuY2lhIGVtIGxpbmhhIHJldGEsIGRpc3TDom5jaWEgZGUgY3VzdG8sIGRpc3TDom5jaWEgZGUgc3VwZXJmw61jaWUgdmVyZGFkZWlyYSwgYmVtIGNvbW8gZW0gZmF0b3JlcyBkZSBjdXN0byB2ZXJ0aWNhaXMgZSBob3Jpem9udGFpcy5cIixcblx0XHRkaXN0YW5jZUFsbG9jYXRpb25EZXNjOiBcIkEgQXRyaWJ1acOnw6NvIGRlIERpc3TDom5jaWEgY2FsY3VsYSBhIHF1ZSBvcmlnZW0gw6kgYXRyaWJ1w61kYSBjYWRhIGxvY2FsaXphw6fDo28gbmEgw6FyZWEgZGUgZXN0dWRvLiBTZSBhcGVuYXMgZm9yZW0gZm9ybmVjaWRhcyBhcyBvcmlnZW5zIHBhcmEgZW50cmFkYSwgYXMgbG9jYWxpemHDp8O1ZXMgc8OjbyBhdHJpYnXDrWRhcyB1dGlsaXphbmRvIHVtYSBkaXN0w6JuY2lhIGVtIGxpbmhhIHJldGEgYXTDqSDDoCBvcmlnZW0gbWFpcyBwcsOzeGltYS4gU2UgdGFudG8gYXMgb3JpZ2VucyBjb21vIGFzIGJhcnJlaXJhcyBmb3JlbSB1dGlsaXphZGFzIGNvbW8gZW50cmFkYSwgZW50w6NvIGEgQXRyaWJ1acOnw6NvIGRlIERpc3TDom5jaWEgY2FsY3VsYSBhIGRpc3TDom5jaWEgZW0gbGluaGEgcmV0YSBlbSB0b3JubyBkYXMgYmFycmVpcmFzIHBhcmEgZGV0ZXJtaW5hciBhIHF1ZSBvcmlnZW0gYSBsb2NhbGl6YcOnw6NvIMOpIGF0cmlidcOtZGEuIFRhbnRvIHBhcmEgbyByYXN0ZXIgZGUgb3JpZ2VtIGNvbW8gcGFyYSBvIHJhc3RlciBkZSBiYXJyZWlyYSwgbyB2YWxvciBkZSBmdW5kbyBkZXZlIHNlciBOb0RhdGEsIGVucXVhbnRvIGFzIG9yaWdlbnMgZSBiYXJyZWlyYXMgc8OjbyByZXByZXNlbnRhZGFzIGNvbSB2YWxvcmVzIHbDoWxpZG9zIGRlIGPDqWx1bGFzLiBPcyB2YWxvcmVzIHbDoWxpZG9zIGluY2x1ZW0gemVyby48ZGl2Pjxici8+UGFyYSByZWFsaXphciB1bWEgYW7DoWxpc2UgZGUgY3VzdG9zIHV0aWxpemFuZG8gYSBBdHJpYnVpw6fDo28gZGUgRGlzdMOibmNpYSwgw6kgbmVjZXNzw6FyaWEgdW1hIHN1cGVyZsOtY2llIGRlIGN1c3RvLiBTZSBmb3IgZm9ybmVjaWRhIHVtYSBzdXBlcmbDrWNpZSBkZSBjdXN0bywgbyByZXN1bHRhZG8gc2Vyw6EgdW0gcmFzdGVyIGRlIGF0cmlidWnDp8OjbyBiYXNlYWRvIG5vIGN1c3RvIGFjdW11bGFkbyBlIG7Do28gbmEgZGlzdMOibmNpYSBlbSBsaW5oYSByZXRhLiBRdWFuZG8gc8OjbyBmb3JuZWNpZG9zIGZhdG9yZXMgaG9yaXpvbnRhaXMgZSB2ZXJ0aWNhaXMsIGEgZGlyZWNpb25hbGlkYWRlIMOpIGNvbnNpZGVyYWRhIGNvbW8gY3VzdG8gYWN1bXVsYWRvLiBRdWFuZG8gdW0gcmFzdGVyIGRlIHN1cGVyZsOtY2llIMOpIGZvcm5lY2lkbyBjb21vIGVudHJhZGEsIMOpIGNhbGN1bGFkYSBhIGRpc3TDom5jaWEgZGUgc3VwZXJmw61jaWUgcmVhbCBjb2JlcnRhIGFvIHBhc3NhciBlbnRyZSBjw6lsdWxhcyBxdWFuZG8gYSBhdHJpYnVpw6fDo28gw6kgZGV0ZXJtaW5hZGEuIEV4aXN0ZW0gcXVhdHJvIGNhcmFjdGVyw61zdGljYXMgZGEgb3JpZ2VtIHF1ZSBwb2RlbSBzZXIgdXRpbGl6YWRhcy4gRXN0YXMgY2FyYWN0ZXLDrXN0aWNhcywgcXVlIHBvZGVtIHNlciB0YW50byBkYSBvcmlnZW0gY29tbyBkb3MgbW90b3JlcyBkYSBvcmlnZW0sIHPDo28gY29udHJvbGFkYXMgcG9yIHBhcsOibWV0cm9zIGVzcGVjw61maWNvczogMS4gQSBBY3VtdWxhw6fDo28gSW5pY2lhbDrigK9kZWZpbmUgbyBjdXN0byBpbmljaWFsIGFudGVzIGRvIGluw61jaW8gZG8gbW92aW1lbnRvLiAyLiBBIEFjdW11bGHDp8OjbyBNw6F4aW1hOuKAr2VzcGVjaWZpY2EgbyBjdXN0byBxdWUgdW1hIG9yaWdlbSBwb2RlIGFjdW11bGFyIGFudGVzIGRlIGF0aW5naXIgbyBzZXUgbGltaXRlLiAzLiBPIG11bHRpcGxpY2Fkb3IgYSBhcGxpY2FyIGFvcyBjdXN0b3M64oCvZXNwZWNpZmljYSBvIG1vZG8gZGUgZGVzbG9jYcOnw6NvIG91IGEgbWFnbml0dWRlIG5hIG9yaWdlbS4gNC4gQSBkaXJlw6fDo28gZGEgdmlhZ2VtOuKAr2lkZW50aWZpY2Egc2UgbyBtb3RvciBlc3TDoSBhIGNvbWXDp2FyIG51bWEgb3JpZ2VtIGUgYSBkZXNsb2Nhci1zZSBwYXJhIGxvY2FpcyBuw6NvIGRlIG9yaWdlbSwgb3Ugc2UgZXN0w6EgYSBjb21lw6dhciBlbSBsb2NhaXMgbsOjbyBkZSBvcmlnZW0gZSBhIGRlc2xvY2FyLXNlIGRlIHZvbHRhIHBhcmEgdW1hIG9yaWdlbS48ZGl2Pjxici8+UG9yIHByZWRlZmluacOnw6NvLCBvIHJlc3VsdGFkbyBkYSBBdHJpYnVpw6fDo28gZGUgRGlzdMOibmNpYSDDqSB1bWEgYmFuZGEgw7puaWNhLCBxdWUgw6kgbyByYXN0ZXIgZGUgYXRyaWJ1acOnw6NvIGRlIGRpc3TDom5jaWEuIEFzc2luYWxhciBhIG9ww6fDo28gQm9vbGVhbmEgR2VyYXIgbGluaGEgZSBjb2x1bmEgZGUgb3JpZ2VtIGNvbW8gYmFuZGFzIGFkaWNpb25haXMgbmEgc2HDrWRhLCByZXN1bHRhcsOhIG51bSByYXN0ZXIgbXVsdGliYW5kYSBjb21wb3N0byBwb3IgdHLDqnMgYmFuZGFzLiBBIHByaW1laXJhIGJhbmRhIMOpIGEgYmFuZGEgZGUgYXRyaWJ1acOnw6NvIGRlIGRpc3TDom5jaWEsIGEgc2VndW5kYSBiYW5kYSBjb250w6ltIHVtIMOtbmRpY2UgZGUgbGluaGFzIGUgYSB0ZXJjZWlyYSBiYW5kYSBjb250w6ltIHVtIMOtbmRpY2UgZGUgY29sdW5hcy4gRXN0ZXMgw61uZGljZXMgaWRlbnRpZmljYW0gYSBsb2NhbGl6YcOnw6NvIGRhIGPDqWx1bGEgZGUgb3JpZ2VtIHF1ZSBzZSBlbmNvbnRyYSBhIG1lbm9yIGRpc3TDom5jaWEgZGUgY3VzdG8gYWN1bXVsYWRvLiBPIMOtbmRpY2UgZGUgbGluaGFzIGRhIG9yaWdlbSBlIG8gw61uZGljZSBkZSBjb2x1bmFzIGRhIG9yaWdlbSBwb2RlbSBzZXIgdXRpbGl6YWRvcyBjb25qdW50YW1lbnRlIHBhcmEgZWZldHVhciBhIGNhcnRvZ3JhZmlhIGRhIGludGVuc2lkYWRlLiBTZSBjb25zdWx0YXIgcXVhbHF1ZXIgbG9jYWxpemHDp8OjbyBuYSBzdWEgw6FyZWEgZGUgZXN0dWRvIGF0cmF2w6lzIGRhcyBiYW5kYXMgZG9pcyBlIHRyw6pzLCBmaWNhcsOhIGEgc2FiZXIgcXVhbCBhIGxpbmhhIGUgYSBjb2x1bmEgZGEgb3JpZ2VtIGRlIG1lbm9yIGN1c3RvIHBhcmEgZXNzYSBsb2NhbGl6YcOnw6NvLjwvZGl2PlwiLFxuXHRcdGV1Y0JhY2tEaXJlY3Rpb25OYW1lOiBcIkRpcmXDp8OjbyBkZSBSZXRvcm5vIEV1Y2xpZGlhbmFcIixcblx0XHRldWNCYWNrRGlyZWN0aW9uU25pcDogXCJDYWxjdWxhLCBwYXJhIGNhZGEgY8OpbHVsYSwgYSBkaXJlw6fDo28sIGVtIGdyYXVzLCBwYXJhIGEgY8OpbHVsYSB2aXppbmhhIGFvIGxvbmdvIGRvIHBlcmN1cnNvIG1haXMgY3VydG8gZGUgdm9sdGEgYXTDqSDDoCBvcmlnZW0gbWFpcyBwcsOzeGltYSwgZXZpdGFuZG8gYW8gbWVzbW8gdGVtcG8gYXMgYmFycmVpcmFzLlwiLFxuXHRcdGV1Y0JhY2tEaXJlY3Rpb25EZXNjOiBcIkEgZnVuw6fDo28gRGlyZcOnw6NvIGRlIFJldG9ybm8gRXVjbGlkaWFuYSByZXN1bHRhIG51bSByYXN0ZXIgZGUgcG9udG8gZmx1dHVhbnRlIGNvbnTDrW51byBxdWUgcmVwcmVzZW50YSBhIGRpcmXDp8OjbywgZW0gZ3JhdXMsIGRlIHZvbHRhIMOgIG9yaWdlbSBtYWlzIHByw7N4aW1hLCBldml0YW5kbyBhbyBtZXNtbyB0ZW1wbyBhcyBiYXJyZWlyYXMsIGNhc28gZXN0YXMgc2VqYW0gZm9ybmVjaWRhcy48ZGl2Pjxici8+QXMgZW50cmFkYXMgcGFyYSBhIGZ1bsOnw6NvIERpcmXDp8OjbyBkZSBSZXRvcm5vIEV1Y2xpZGlhbmEgc8OjbyBhIG9yaWdlbSBwYXJhIGEgcXVhbCBhIGRpcmXDp8OjbyBzZXLDoSBjYWxjdWxhZGEuIFVtYSBlbnRyYWRhIG9wY2lvbmFsIMOpIHVtIHJhc3RlciBxdWUgcmVwcmVzZW50YSBhcyBiYXJyZWlyYXMgZGVudHJvIGRhIMOhcmVhIGRlIGVzdHVkby4gVGFudG8gcGFyYSBvIHJhc3RlciBkZSBvcmlnZW0gY29tbyBwYXJhIG8gcmFzdGVyIGRlIGJhcnJlaXJhLCBvIHZhbG9yIGRlIGZ1bmRvIGRldmUgc2VyIE5vRGF0YSwgZW5xdWFudG8gYXMgb3JpZ2VucyBlIGJhcnJlaXJhcyBzw6NvIHJlcHJlc2VudGFkYXMgY29tIHZhbG9yZXMgdsOhbGlkb3MuIE9zIHZhbG9yZXMgdsOhbGlkb3MgaW5jbHVlbSB6ZXJvLiBQb3IgcHJlZGVmaW5pw6fDo28sIG8gY8OhbGN1bG8gaXLDoSBwcm9jZXNzYXItc2UgbmEgZXh0ZW5zw6NvIGNvbWJpbmFkYSBkYXMgb3JpZ2VucyBlIGRhcyBiYXJyZWlyYXMsIG1haXMgMiBsaW5oYXMgZSBjb2x1bmFzLiBTZSBhIGFuw6FsaXNlIHPDsyBmb3IgbmVjZXNzw6FyaWEgYSB1bWEgZGlzdMOibmNpYSBlc3BlY2lmaWNhZGEgZGFzIG9yaWdlbnMsIHBvZGUgc2VyIHV0aWxpemFkbyBvIHBhcsOibWV0cm8gRGlzdMOibmNpYSBNw6F4aW1hLiBBIERpcmXDp8OjbyBkZSBSZXRvcm5vIEV1Y2xpZGlhbmEgc3Vwb3J0YSB0YW50byB1bSBtw6l0b2RvIFBsYW5hciBjb21vIHVtIG3DqXRvZG8gR2VvZMOpc2ljbyBubyBjw6FsY3Vsby4gTyBjw6FsY3VsbyBkbyBtw6l0b2RvIFBsYW5hciBzZXLDoSBlZmV0dWFkbyBudW1hIHN1cGVyZsOtY2llIHBsYW5hIHByb2pldGFkYSB1dGlsaXphbmRvIHVtIHNpc3RlbWEgZGUgY29vcmRlbmFkYXMgY2FydGVzaWFubyBlbSAyRC4gTyBjw6FsY3VsbyBkbyBtw6l0b2RvIEdlb2TDqXNpY28gc2Vyw6EgZWZldHVhZG8gbmEgZWxpcHNvaWRlLCBvIHF1ZSBzaWduaWZpY2EgcXVlLCBpbmRlcGVuZGVudGVtZW50ZSBkYSBwcm9qZcOnw6NvIGRlIGVudHJhZGEgb3Ugc2HDrWRhLCBvcyByZXN1bHRhZG9zIG7Do28gc2UgYWx0ZXJhbS48ZGl2Pjxici8+TyByZXN1bHRhZG8gZGEgZnVuw6fDo28gRGlyZcOnw6NvIGRlIFJldG9ybm8gRXVjbGlkaWFuYSBwb2RlIHNlciB1dGlsaXphZG8gZW0gY29uanVudG8gY29tIG8gcmVzdWx0YWRvIGRhIGZ1bsOnw6NvIERpc3TDom5jaWEgRXVjbGlkaWFuYSBwYXJhIGRldGVybWluYXIgb3MgcGVyY3Vyc29zIG1haXMgY3VydG9zIGEgcGFydGlyIGRlIGxvY2FsaXphw6fDtWVzIGRlbnRybyBkYSDDoXJlYSBkZSBlc3R1ZG8gYXTDqSBkZSB2b2x0YSDDoCBvcmlnZW0uIFRhbnRvIG8gcmVzdWx0YWRvIGRhIERpcmXDp8OjbyBkZSBSZXRvcm5vIEV1Y2xpZGlhbmEgY29tbyBvIHJlc3VsdGFkbyBkYSBEaXN0w6JuY2lhIEV1Y2xpZGlhbmEgc8OjbyB1dGlsaXphZG9zIG5hIGZ1bsOnw6NvIFBlcmN1cnNvIGRlIEN1c3RvIGp1bnRhbWVudGUgY29tIG9zIGRlc3Rpbm9zIHBhcmEgZ2VyYXIgb3MgcGVyY3Vyc29zIG1haXMgY3VydG9zLjwvZGl2PlwiLFxuXHRcdGV4cGFuZE5hbWU6IFwiRXhwYW5kaXJcIixcblx0XHRleHBhbmRTbmlwOiBcIkV4cGFuZGUgem9uYXMgc2VsZWNpb25hZGFzIGRlIHVtIHJhc3RlciBwb3Igem9uYXMgcG9yIHVtIG7Dum1lcm8gZXNwZWNpZmljYWRvIGRlIGPDqWx1bGFzLlwiLFxuXHRcdGV4cGFuZERlc2M6IFwiQ29tIGEgZnVuw6fDo28gZ2xvYmFsIEV4cGFuZGlyLCBwb2RlIGdlbmVyYWxpemFyIG91IHNpbXBsaWZpY2FyIG9zIHJhc3RlcnMsIHRvcm5hbmRvIHpvbmFzIGVzcGVjw61maWNhcyBtYWlvcmVzLiBQb2RlIHRhbWLDqW0gY29udHJvbGFyIGEgcXVhbnRpZGFkZSBkZSBnZW5lcmFsaXphw6fDo28gcXVlIGlyw6Egb2NvcnJlci48ZGl2Pjxici8+QXMgem9uYXMgcXVlIHNlbGVjaW9uYXIgaXLDo28gYXVtZW50YXIgZGUgdGFtYW5obyBleHBhbmRpbmRvLXNlIHBhcmEgb3V0cmFzIHpvbmFzLiBDb25jZXB0dWFsbWVudGUsIG9zIFZhbG9yZXMgZGUgWm9uYSBzZWxlY2lvbmFkb3MgcG9kZW0gc2VyIHZpc3RvcyBjb21vIHpvbmFzIGRlIHByaW1laXJvIHBsYW5vLCBlbnF1YW50byBvcyBvdXRyb3MgdmFsb3JlcyBwZXJtYW5lY2VtIGNvbW8gem9uYXMgZGUgc2VndW5kbyBwbGFuby4gQXMgem9uYXMgZGUgcHJpbWVpcm8gcGxhbm8gcG9kZW0gZXhwYW5kaXItc2UgcGFyYSBhcyB6b25hcyBkZSBzZWd1bmRvIHBsYW5vLjxkaXY+PGJyLz5BIHF1YW50aWRhZGUgZGUgZ2VuZXJhbGl6YcOnw6NvIHBvZGUgc2VyIGNvbnRyb2xhZGEgY29tIG8gcGFyw6JtZXRybyBOw7ptZXJvIGRlIEPDqWx1bGFzLiBQb3IgcHJlZGVmaW5pw6fDo28sIGVzdGUgdmFsb3Igw6kgMSwgbyBxdWUgc2lnbmlmaWNhIHF1ZSBhcyB6b25hcyBzZWxlY2lvbmFkYXMgaXLDo28gZXhwYW5kaXItc2UgcGVsYSBxdWFudGlkYWRlIGNvcnJlc3BvbmRlbnRlIGFvIHRhbWFuaG8gZGUgdW1hIGPDqWx1bGEuIFBhcmEgYXVtZW50YXIgbyBncmF1IGRlIGdlbmVyYWxpemHDp8OjbywgcG9kZSBlc3BlY2lmaWNhciB1bSB2YWxvciBtYWlvciBwYXJhIGVzdGUgcGFyw6JtZXRyby4gQ29uY2VwdHVhbG1lbnRlLCBpc3RvIMOpIGNvbW8gZXhlY3V0YXIgYSBmZXJyYW1lbnRhIHRhbnRhcyB2ZXplcyBxdWFudG8gbyBuw7ptZXJvIGVzcGVjaWZpY2FkbywgY29tIG9zIHJlc3VsdGFkb3MgZGEgZXhlY3XDp8OjbyBhbnRlcmlvciBhIHNlciBhIGVudHJhZGEgcGFyYSBhIGl0ZXJhw6fDo28gc2VndWludGUuPC9kaXY+XCIsXG5cdFx0dHJlbmRBbmFseXNpc05hbWU6IFwiR2VyYXIgVGVuZMOqbmNpYVwiLFxuXHRcdHRyZW5kQW5hbHlzaXNTbmlwOiBcIkVzdGltYSBhIHRlbmTDqm5jaWEgcGFyYSBjYWRhIHDDrXhlbCBhbyBsb25nbyBkZSB1bWEgZGltZW5zw6NvIHBhcmEgdW1hIG91IG1haXMgdmFyacOhdmVpcyBudW0gcmFzdGVyIG11bHRpZGltZW5zaW9uYWwuXCIsXG5cdFx0dHJlbmRBbmFseXNpc0Rlc2M6IFwiPGRpdj5Fc3RhIGZ1bsOnw6NvIHBvZGUgc2VyIHVzYWRhIHBhcmEgYWp1c3RhciBkYWRvcyBhbyBsb25nbyBkZSB1bWEgbGluaGEgZGUgdGVuZMOqbmNpYSBsaW5lYXIsIGhhcm3Ds25pY2Egb3UgcG9saW5vbWlhbCBvdSBwb2RlIHNlciB1c2FkYSBwYXJhIHJlYWxpemFyIGEgZGV0ZcOnw6NvIGRlIHRlbmTDqm5jaWFzIGNvbSBvIHRlc3RlIE1hbm4tS2VuZGFsbCBvdSBTYXpvbmFsLUtlbmRhbGwuPC9kaXY+PGJyPjxkaXY+TyByYXN0ZXIgZGUgdGVuZMOqbmNpYSBkZSBzYcOtZGEgZ2VyYWRvIGNvbSBlc3RhIGZ1bsOnw6NvIMOpIHVzYWRvIGNvbW8gZW50cmFkYSBwYXJhIGEgZnVuw6fDo28gPHN0cm9uZz5QcmV2ZXIgQXRyYXbDqXMgZGUgVGVuZMOqbmNpYTwvc3Ryb25nPi48L2Rpdj48YnI+PGRpdj5PcyB0ZXN0ZXMgZGUgTWFubi1LZW5kYWxsIGUgU2Vhc29uYWwtS2VuZGFsbCBzw6NvIHVzYWRvcyBwYXJhIGRldGVybWluYXIgc2UgZXhpc3RlIHVtYSB0ZW5kw6puY2lhIG1vbm90w7NuaWNhIG5vcyBkYWRvcy4gTsOjbyBzw6NvIHBhcmFtw6l0cmljb3MsIG8gcXVlIHNpZ25pZmljYSBxdWUgbsOjbyBhZG1pdGVtIHVtYSBkaXN0cmlidWnDp8OjbyBlc3BlY8OtZmljYSBkb3MgZGFkb3MuIE8gdGVzdGUgZGUgTWFubi1LZW5kYWxsIG7Do28gY29uc2lkZXJhIGEgY29ycmVsYcOnw6NvIGRlIHPDqXJpZSBvdSBlZmVpdG9zIHNhem9uYWlzLiBTZSBvcyBkYWRvcyBmb3JlbSBzYXpvbmFpcywgbyB0ZXN0ZSBkZSBTYXpvbmFsLUtlbmRhbGwgw6kgbyBtYWlzIGFkZXF1YWRvLjwvZGl2Pjxicj48ZGl2PlNlIGEgZmVycmFtZW50YSBmb3IgdXNhZGEgcGFyYSByZWFsaXphciBvIHRlc3RlIGRlIE1hbm4tS2VuZGFsbCBvdSBTZWFzb25hbC1LZW5kYWxsLCBhIHNhw61kYSDDqSB1bSByYXN0ZXIgZGUgY2luY28gYmFuZGFzIGNvbW8gYXByZXNlbnRhZG8gYSBzZWd1aXI6PC9kaXY+PHVsPjxsaT5CYW5kYSAxID0gSW5jbGluYcOnw6NvIGRlIFNlbjwvbGk+PGxpPkJhbmRhIDIgPSBWYWxvciBQPC9saT48bGk+QmFuZGEgMyA9IFBvbnR1YcOnw6NvIE1hbm4tS2VuZGFsbCAoUyk8L2xpPjxsaT5CYW5kYSA0ID0gVmFyaWHDp8OjbyBTPC9saT48bGk+QmFuZGEgNCA9IFZhcmlhw6fDo28gUzwvbGk+PGxpPkJhbmRhIDUgPSBWYWxvciBaPC9saT48L3VsPjxkaXY+QXMgc2HDrWRhcyBkbyB0ZXN0ZSBNYW5uLUtlbmRhbGwgb3UgU2Vhc29uYWwtS2VuZGFsbCBwb2RlbSBzZXIgdXNhZGFzIHBhcmEgZGV0ZXJtaW5hciBxdWUgcMOteGVpcyBuYSBzdWEgc8OpcmllIHRlbXBvcmFsIG11bHRpZGltZW5zaW9uYWwgdMOqbSB1bWEgdGVuZMOqbmNpYSBlc3RhdGlzdGljYW1lbnRlIHNpZ25pZmljYXRpdmEuIFBvZGUgdXNhciBlc3RhcyBpbmZvcm1hw6fDtWVzIGVtIGNvbmp1bnRvIGNvbSBhIGFuw6FsaXNlIGRlIHRlbmTDqm5jaWEgbGluZWFyLCBoYXJtw7NuaWNhIG91IHBvbGlub21pYWwgcGFyYSBleHRyYWlyIHRlbmTDqm5jaWFzIHNpZ25pZmljYXRpdmFzIG5hIHN1YSBzw6lyaWUgdGVtcG9yYWwuIFBvZGUgZ2VyYXIgdW1hIG3DoXNjYXJhIGluY2x1aW5kbyBww614ZWlzIGNvbSB2YWxvcmVzIHAgc2lnbmlmaWNhdGl2b3MsIGFwbGljYXIgYSBtw6FzY2FyYSBhbyByYXN0ZXIgbXVsdGlkaW1lbnNpb25hbCBlIHVzYXIgZXN0ZSByYXN0ZXIgbXVsdGlkaW1lbnNpb25hbCBtYXNjYXJhZG8gY29tbyBlbnRyYWRhIHBhcmEgYSBmZXJyYW1lbnRhIHBhcmEgcmVhbGl6YXIgYW7DoWxpc2VzIGRlIHRlbmTDqm5jaWFzIGxpbmVhcmVzLCBoYXJtw7NuaWNhcyBvdSBwb2xpbm9taWFpcy48L2Rpdj48YnI+PGRpdj5FeGlzdGVtIHRyw6pzIG9ww6fDtWVzIGRlIGxpbmhhIGRlIHRlbmTDqm5jaWEgcGFyYSBhanVzdGFyIHVtYSB0ZW5kw6puY2lhIGFvcyB2YWxvcmVzIGRhcyB2YXJpw6F2ZWlzIGFvIGxvbmdvIGRlIHVtYSBkaW1lbnPDo286IGxpbmVhciwgcG9saW5vbWlhbCBlIGhhcm3Ds25pY2EuPC9kaXY+PGJyPjxkaXY+UGFyYSB1bWEgYW7DoWxpc2UgZGUgdGVuZMOqbmNpYSBsaW5lYXIsIGEgc2HDrWRhIMOpIHVtIHJhc3RlciBkZSB0csOqcyBiYW5kYXMgY29tbyBhcHJlc2VudGFkbyBhIHNlZ3Vpcjo8L2Rpdj48dWw+PGxpPkJhbmRhIDEgPSBJbmNsaW5hw6fDo288L2xpPjxsaT5CYW5kYSAyID0gSW50ZXJjZcOnw6NvPC9saT48bGk+QmFuZGEgMyA9IEVycm8gTcOpZGlvIFF1YWRyw6F0aWNvIChSTVNFKSBvdSBvIGVycm8gZW0gdG9ybm8gZGEgbGluaGEgZGUgbWVsaG9yIGFqdXN0ZTwvbGk+PC91bD48ZGl2PlBhcmEgdW1hIGFuw6FsaXNlIGRlIHRlbmTDqm5jaWEgcG9saW5vbWlhbCwgbyBuw7ptZXJvIGRlIGJhbmRhcyBuYSBzYcOtZGEgZGVwZW5kZSBkYSBvcmRlbSBwb2xpbm9taWFsLiBPIGFqdXN0ZSBwb2xpbm9taWFsIGRlIHNlZ3VuZGEgb3JkZW0gcHJvZHV6IHVtIHJhc3RlciBkZSBxdWF0cm8gYmFuZGFzIGNvbW8gYXByZXNlbnRhZG8gYSBzZWd1aXI6PC9kaXY+PHVsPjxsaT5CYW5kYSAxID0gUG9seW5vbWlhbF8yPC9saT48bGk+QmFuZGEgMiA9IFBvbHlub21pYWxfMTwvbGk+PGxpPkJhbmRhIDMgPSBQb2xpbm9taWFsXzA8L2xpPjxsaT5CYW5kYSA0ID0gUk1TRTwvbGk+PC91bD48ZGl2Pk8gYWp1c3RlIHBvbGlub21pYWwgZGUgdGVyY2VpcmEgb3JkZW0gcHJvZHV6IHVtIHJhc3RlciBkZSBjaW5jbyBiYW5kYXMgY29tbyBhcHJlc2VudGFkbyBhIHNlZ3Vpcjo8L2Rpdj48dWw+PGxpPkJhbmRhIDEgPSBQb2xpbm9taWFsXzM8L2xpPjxsaT5CYW5kYSAyID0gUG9saW5vbWlhbF8yPC9saT48bGk+QmFuZGEgMyA9IFBvbGlub21pYWxfMTwvbGk+PGxpPkJhbmRhIDQgPSBQb2xpbm9taWFsXzA8L2xpPjxsaT5CYW5kYSA1ID0gUk1TRTwvbGk+PC91bD48ZGl2PlBhcmEgdW1hIGFuw6FsaXNlIGRlIHRlbmTDqm5jaWEgaGFybcOzbmljYSwgbyBuw7ptZXJvIGRlIGJhbmRhcyBuYSBzYcOtZGEgZGVwZW5kZSBkYSBmcmVxdcOqbmNpYSBoYXJtw7NuaWNhLiBRdWFuZG8gYSBmcmVxdcOqbmNpYSDDqSBkZWZpbmlkYSBjb21vIDEsIGEgc2HDrWRhIMOpIHVtIHJhc3RlciBkZSBjaW5jbyBiYW5kYXMgY29tbyBhcHJlc2VudGFkbyBhIHNlZ3Vpcjo8L2Rpdj48dWw+PGxpPkJhbmRhIDEgPSBJbmNsaW5hw6fDo288L2xpPjxsaT5CYW5kYSAyID0gSW50ZXJjZcOnw6NvPC9saT48bGk+QmFuZGEgMyA9IEhhcm3Ds25pY2Ffc2luMTwvbGk+PGxpPkJhbmRhIDQgPSBIYXJtw7NuaWNhX2NvczE8L2xpPjxsaT5CYW5kYSA1ID0gUk1TRTwvbGk+PC91bD48ZGl2PlF1YW5kbyBhIGZyZXF1w6puY2lhIMOpIGRlZmluaWRhIGNvbW8gMiwgYSBzYcOtZGEgw6kgdW0gcmFzdGVyIGRlIHNldGUgYmFuZGFzIGNvbW8gYXByZXNlbnRhZG8gYSBzZWd1aXI6PC9kaXY+PHVsPjxsaT5CYW5kYSAxID0gSW5jbGluYcOnw6NvPC9saT48bGk+QmFuZGEgMiA9IEludGVyY2XDp8OjbzwvbGk+PGxpPkJhbmRhIDMgPSBIYXJtw7NuaWNhX3NpbjE8L2xpPjxsaT5CYW5kYSA0ID0gSGFybcOzbmljYV9jb3MxPC9saT48bGk+QmFuZGEgNSA9IEhhcm3Ds25pY2Ffc2luMjwvbGk+PGxpPkJhbmRhIDYgPSBIYXJtw7NuaWNhX2NvczI8L2xpPjxsaT5CYW5kYSA3ID0gUk1TRTwvbGk+PC91bD48ZGl2Pk8gcGFyw6JtZXRybyA8c3Ryb25nPkR1cmHDp8OjbyBkbyBDaWNsbzwvc3Ryb25nPiBwYXJhIGEgYW7DoWxpc2UgZGUgdGVuZMOqbmNpYSBoYXJtw7NuaWNhIMOpIHVzYWRvIHBhcmEgaW5kaWNhciBvIG7Dum1lcm8gZSBhIGR1cmHDp8OjbyBkb3MgY2ljbG9zIHF1ZSBlc3BlcmEgdmVyIG5vcyBzZXVzIGRhZG9zIGFvIGxvbmdvIGRlIHVtIGRpYSBvdSBhbm8uIFBvciBleGVtcGxvLCBzZSBlc3BlcmEgcXVlIG9zIHNldXMgZGFkb3MgcGFzc2VtIHBvciBkb2lzIGNpY2xvcyBkZSB2YXJpYcOnw6NvIG51bSBhbm8sIGEgZHVyYcOnw6NvIGRvIGNpY2xvIHNlcsOhIGRlIDE4Miw1IGRpYXMgb3UgMCw1IGFub3MuIFNlIHRpdmVyIGRhZG9zIGRlIHRlbXBlcmF0dXJhIHJlY29saGlkb3MgYSBjYWRhIHRyw6pzIGhvcmFzIGUgZXhpc3RpciB1bSBjaWNsbyBkZSB2YXJpYcOnw6NvIHBvciBkaWEsIGEgZHVyYcOnw6NvIGRvIGNpY2xvIMOpIGRlIHVtIGRpYS48L2Rpdj48YnI+PGRpdj5PIHBhcsOibWV0cm8gPHN0cm9uZz5GcmVxdcOqbmNpYTwvc3Ryb25nPiBwYXJhIGEgYW7DoWxpc2UgZGUgdGVuZMOqbmNpYSBoYXJtw7NuaWNhIMOpIHVzYWRvIHBhcmEgZGVzY3JldmVyIG8gbW9kZWxvIGhhcm3Ds25pY28gYSBhanVzdGFyLXNlIGFvcyBkYWRvcy4gU2UgYSBmcmVxdcOqbmNpYSBmb3IgZGVmaW5pZGEgY29tbyAxLCB1bWEgY29tYmluYcOnw6NvIGRlIGN1cnZhIGxpbmVhciBlIGRlIGN1cnZhIGhhcm3Ds25pY2EgZGUgcHJpbWVpcmEgb3JkZW0gc2Vyw6EgdXNhZGEgcGFyYSBzZSBhanVzdGFyIGFvIG1vZGVsby4gU2UgYSBmcmVxdcOqbmNpYSBmb3IgMiwgdW1hIGNvbWJpbmHDp8OjbyBkZSBjdXJ2YSBoYXJtw7NuaWNhIGxpbmVhciBkZSBwcmltZWlyYSBvcmRlbSBlIGRlIGN1cnZhIGhhcm3Ds25pY2EgZGUgc2VndW5kYSBvcmRlbSBzZXLDoSB1c2FkYSBwYXJhIHNlIGFqdXN0YXIgYW9zIGRhZG9zLiBTZSBhIGZyZXF1w6puY2lhIGZvciAzLCB1bWEgY3VydmEgaGFybcOzbmljYSBkZSB0ZXJjZWlyYSBvcmRlbSBhZGljaW9uYWwgc2Vyw6EgdXNhZGEgcGFyYSBtb2RlbGFyIG9zIGRhZG9zIGUgYXNzaW0gcG9yIGRpYW50ZS48L2Rpdj48YnI+PGRpdj5BcyBlc3RhdMOtc3RpY2FzIGRlIGFqdXN0YW1lbnRvIGRvIG1vZGVsbyBwb2RlbSBzZXIgZ2VyYWRhcyBjb21vIHNhw61kYXMgb3BjaW9uYWlzLiBPIGVycm8gbcOpZGlvIHF1YWRyw6F0aWNvIChSTVNFKSwgUi1xdWFkcmFkbyBlIG8gdmFsb3IgcCBkYSBpbmNsaW5hw6fDo28gZGEgdGVuZMOqbmNpYSBwb2RlbSBzZXIgY2FsY3VsYWRvcyBlIHNpbWJvbGl6YWRvcy4gU2ltYm9saXplIGEgY2FtYWRhIHJhc3RlciBkZSB0ZW5kw6puY2lhIGRlIHNhw61kYSBjb20gYSBzaW1ib2xvZ2lhIDxzdHJvbmc+UkdCPC9zdHJvbmc+IGUgZXNwZWNpZmlxdWUgYXMgZXN0YXTDrXN0aWNhcyBjb21vIGFzIGJhbmRhcyB2ZXJtZWxoYSwgdmVyZGUgZSBhenVsLjwvZGl2Pjxicj5cIixcblx0XHRzcGVjdHJhbFVubWl4aW5nTmFtZTogXCJEZXNtaXN0dXJhIEVzcGV0cmFsIExpbmVhclwiLFxuXHRcdHNwZWN0cmFsVW5taXhpbmdTbmlwOiBcIkVmZXR1YSBhIGNsYXNzaWZpY2HDp8OjbyBwb3Igc3VicMOteGVpcyBlIGNhbGN1bGEgYSBhYnVuZMOibmNpYSBmcmFjaW9uYWRhIGRvcyBkaWZlcmVudGVzIHRpcG9zIGRlIGNvYmVydHVyYSBkbyBzb2xvIHBhcmEgcMOteGVpcyBpbmRpdmlkdWFpcy5cIixcblx0XHRzcGVjdHJhbFVubWl4aW5nRGVzYzogXCJBIGZ1bsOnw6NvIERlc21pc3R1cmEgRXNwZXRyYWwgTGluZWFyIGNhbGN1bGEgYSBjb2JlcnR1cmEgZnJhY2lvbmFkYSBkZSBww614ZWlzIGluZGl2aWR1YWlzIHF1ZSBjb250w6ptIHbDoXJpb3MgdGlwb3MgZGUgY29iZXJ0dXJhIGRvIHNvbG8uIEdlcmEgdW1hIGNhbWFkYSBtdWx0aWJhbmRhLCBlbSBxdWUgY2FkYSBiYW5kYSBjb3JyZXNwb25kZSDDoCBhYnVuZMOibmNpYSBmcmFjaW9uw6FyaWEgZGUgY2FkYSBjbGFzc2UgZGUgY29iZXJ0dXJhIGRvIHNvbG8uIFBvciBleGVtcGxvLCBwb2RlIHV0aWxpesOhLWxhIHBhcmEgcmVhbGl6YXIgYSBjbGFzc2lmaWNhw6fDo28gZGEgY29iZXJ0dXJhIGRvIHNvbG8gbnVtYSBpbWFnZW0gbXVsdGllc3BlY3RyYWwgcGFyYSBpZGVudGlmaWNhciB2ZWdldGHDp8OjbyBmb3Rvc3NpbnTDqXRpY2EsIHNvbG8gZGVzY29iZXJ0byBlIHZlZ2V0YcOnw6NvIG1vcnRhIG91IG7Do28gZm90b3NzaW50w6l0aWNhLjxkaXY+PGJyLz5BIG9yZGVtIGRvIHJhc3RlciBtdWx0aWJhbmRhIGRlIHNhw61kYSBzZWd1ZSBhIG9yZGVtIGRvIHBlcmZpbCBlc3BldHJhbCBkZSBlbnRyYWRhLiBPIG7Dum1lcm8gZGUgY2xhc3NlcyBuw6NvIHBvZGUgZXhjZWRlciBvIG7Dum1lcm8gZGUgYmFuZGFzIG5vIHJhc3RlciBkZSBlbnRyYWRhLiBQb3IgZXhlbXBsbywgbsOjbyBzZSBwb2RlIGV4dHJhaXIgaW5mb3JtYcOnw7VlcyBzb2JyZSBtYWlzIGRlIDggY2xhc3NlcyBhIHBhcnRpciBkZSB1bSByYXN0ZXIgZGUgOCBiYW5kYXMuPC9kaXY+XCIsXG5cdFx0bXVsdGlkaW1lbnNpb25hbEZpbHRlck5hbWU6IFwiRmlsdHJvIE11bHRpZGltZW5zaW9uYWxcIixcblx0XHRpbnRlcnBvbGF0ZVJhc3RlckJ5RGltZW5zaW9uRnVuY3Rpb25OYW1lOiBcIkludGVycG9sYXIgUmFzdGVyIHBvciBEaW1lbnPDo29cIixcblx0XHRpbnRlcnBvbGF0ZVJhc3RlckJ5RGltZW5zaW9uRnVuY3Rpb25TbmlwOiBcIkludGVycG9sYSB1bSByYXN0ZXIgbXVsdGlkaW1lbnNpb25hbCBlbSB2YWxvcmVzIGRlIGRpbWVuc8OjbyBlc3BlY2lmaWNhZG9zIGNvbSBzZWPDp8O1ZXMgYWRqYWNlbnRlcy5cIixcblx0XHRpbnRlcnBvbGF0ZVJhc3RlckJ5RGltZW5zaW9uRnVuY3Rpb25EZXNjOiBcIjxwPkVzdGEgZnVuw6fDo28gcGVybWl0ZSBlc3RpbWFyIHZhbG9yZXMgZGUgcMOteGVsIHBhcmEgdW1hIHNlY8Onw6NvIGRlIGRpbWVuc8OjbyBpbmRlZmluaWRhIG51bSByYXN0ZXIgbXVsdGlkaW1lbnNpb25hbC4gUG9yIGV4ZW1wbG8sIHNlIHRpdmVyIHVtIGNvbmp1bnRvIGRlIGRhZG9zIGNvbSBhIHRlbXBlcmF0dXJhIGRvIG9jZWFubyBhbyBuw612ZWwgZGEgc3VwZXJmw61jaWUgZSBhIDEwMCBtZXRyb3MgYWJhaXhvIGRvIG7DrXZlbCBkbyBtYXIgZSBwcmV0ZW5kZXIgZXN0aW1hciBhIHRlbXBlcmF0dXJhIGEgNTAgbWV0cm9zIGFiYWl4byBkbyBuw612ZWwgZG8gbWFyLCBwb2RlIHVzYXIgZXN0YSBmdW7Dp8OjbyBwYXJhIG9idGVyIHVtYSBlc3RpbWF0aXZhIGEgZXNzYSBwcm9mdW5kaWRhZGUgY29tIGEgZGVmaW5pw6fDo28gZGUgZGltZW5zw6NvIFBvciBWYWxvcmVzLjwvcD48cD5UYW1iw6ltIHBvZGUgc3ViYW1vc3RyYXIgdW0gY29uanVudG8gZGUgZGFkb3MgbWVuc2FsIG51bSBjb25qdW50byBkZSBkYWRvcyBkacOhcmlvIGNvbSBhIGRlZmluacOnw6NvIGRlIGRpbWVuc8OjbyBQb3IgSW50ZXJ2YWxvIGUgYW8gZXNwZWNpZmljYXIgbyB2YWxvciBkZSBwYXLDom1ldHJvIEV0YXBhIGNvbW8gMSBlIG8gdmFsb3IgZGUgcGFyw6JtZXRybyBVbmlkYWRlIGNvbW8gRGlhcy48L3A+PHA+VXNlIGEgZGVmaW5pw6fDo28gZGUgZGltZW5zw6NvIFBvciBSYXN0ZXIgZGUgRGVzdGlubyBwYXJhIGVzdGltYXIgbyB2YWxvciBkbyBSYXN0ZXIgZGUgRGVzdGluby48L3A+XCIsXG5cdFx0bXVsdGlkaW1lbnNpb25hbEZpbHRlclNuaXA6IFwiQ3JpYSB1bWEgY2FtYWRhIHJhc3RlciBhIHBhcnRpciBkZSB1bSBjb25qdW50byBkZSBkYWRvcyByYXN0ZXIgbXVsdGlkaW1lbnNpb25hbCBvdSBkZSB1bWEgY2FtYWRhIHJhc3RlciBtdWx0aWRpbWVuc2lvbmFsLCBzZWNjaW9uYW5kbyBvcyBkYWRvcyBhbyBsb25nbyBkZSB2YXJpw6F2ZWlzIGUgZGltZW5zw7VlcyBkZWZpbmlkYXMuXCIsXG5cdFx0bXVsdGlkaW1lbnNpb25hbEZpbHRlckRlc2M6IFwiTyBGaWx0cm8gTXVsdGlkaW1lbnNpb25hbCBjcmlhIHVtYSBjYW1hZGEgcmFzdGVyIG11bHRpZGltZW5zaW9uYWwgYXRyYXbDqXMgZGEgZmlsdHJhZ2VtIGUgZXh0cmHDp8OjbyBkZSB1bSBzdWJjb25qdW50byBkZSB2YXJpw6F2ZWlzIGEgcGFydGlyIGRlIHVtIHJhc3RlciBtdWx0aWRpbWVuc2lvbmFsLiBQb3IgZXhlbXBsbywgdGVtIHVtIGNvbmp1bnRvIGRlIGRhZG9zIG11bHRpZGltZW5zaW9uYWwgcXVlIGNvbnTDqW0gMzAgYW5vcyBkZSBkYWRvcyBtZW5zYWlzIHNvYnJlIHByZWNpcGl0YcOnw6NvIGUgc8OzIHF1ZXIgZXh0cmFpciBkYWRvcyBwYXJhIGNhZGEgbcOqcyBkZSBqYW5laXJvIHBhcmEgdmVyIGNvbW8gYSBwcmVjaXBpdGHDp8OjbyBtdWRvdSBwYXJhIGVzc2UgbcOqcy48ZGl2Pjxici8+VXRpbGl6ZSBvIHBhcsOibWV0cm8gRGVmaW5pw6fDo28gZGUgRGltZW5zw6NvIHBhcmEgc2VjY2lvbmFyIGRpbWVuc8O1ZXMgdXRpbGl6YW5kbyB1bSBpbnRlcnZhbG8sIHVtIHZhbG9yLCBvdSB1bSBpbnRlcnZhbG8gZGUgdmFsb3Jlcy4gUG9yIGV4ZW1wbG8sIHNlIHRpdmVyIDEwIGFub3MgZGUgZGFkb3MgcmVsYXRpdm9zIMOgIHNhbGluaWRhZGUgZG9zIG9jZWFub3MgcmVjb2xoaWRvcyBtZW5zYWxtZW50ZSBlIGEgY2FkYSAyIG1ldHJvcyBkZSBwcm9mdW5kaWRhZGUgYXTDqSA1MDAgbWV0cm9zLCBwb2RlIHV0aWxpemFyIGFzIGRpZmVyZW50ZXMgb3DDp8O1ZXMgZGUgZGVmaW5pw6fDo28gZGUgZGltZW5zw6NvIHBhcmEgb3MgY2Vuw6FyaW9zIHNlZ3VpbnRlcy4gQ2Vuw6FyaW8gMTogZXh0cmFpciBkYWRvcyByZWxhdGl2b3Mgw6Agc2FsaW5pZGFkZSBwYXJhIG8gbcOqcyBkZSBqYW5laXJvIGR1cmFudGUgbyBwZXLDrW9kbyBkZSAxMCBhbm9zLiBFc2NvbGhhIFBvciBWYWxvcmVzLCBkZWZpbmEgRGltZW5zw6NvIHBhcmEgU3RkVGltZSBlIGRlZmluYSBWYWxvcmVzIHBhcmEgSmFuZWlyby4gQ2Vuw6FyaW8gMjogc2VjY2lvbmFyIG9zIGRhZG9zIHJlbGF0aXZvcyDDoCBzYWxpbmlkYWRlIG51bSBpbnRlcnZhbG8gZGUgcHJvZnVuZGlkYWRlIGRlIDAgYSAxNTAgbWV0cm9zLiBFc2NvbGhhIFBvciBJbnRlcnZhbG9zLCBkZWZpbmEgRGltZW5zw6NvIHBhcmEgU3RkWiBlIGRlZmluYSBWYWxvciBNw61uaW1vIHBhcmEgLTE1MCBlIFZhbG9yIE3DoXhpbW8gcGFyYSAwLiBDZW7DoXJpbyAzOiBleHRyYWlyIGRhZG9zIHJlbGF0aXZvcyDDoCBzYWxpbmlkYWRlIHBhcmEgb3MgcHJpbWVpcm9zIDEwIGRpYXMgZGUgY2FkYSBtw6pzIGRlIGphbmVpcm8gZHVyYW50ZSB1bSBwZXLDrW9kbyBkZSAxMCBhbm9zLiBFc2NvbGhhIFBvciBJdGVyYcOnw6NvLCBkZWZpbmEgRGltZW5zw6NvIHBhcmEgU3RkVGltZSwgZGVmaW5hIEluw61jaW8gZGEgcHJpbWVpcmEgaXRlcmHDp8OjbyBlIEZpbSBkYSBwcmltZWlyYSBpdGVyYcOnw6NvIHBhcmEgb3MgcmVzcGV0aXZvcyBpbsOtY2lvIGUgZmltIGRvIHBlcsOtb2RvIGRlIGl0ZXJhw6fDo28sIGRlZmluYSBQYXNzbyBwYXJhIDEsIGUgZGVmaW5hIFVuaWRhZGUgcGFyYSBBbm9zLjwvZGl2PlwiLFxuXHRcdG11bHRpZGltZW5zaW9uYWxSYXN0ZXJOYW1lOiBcIlJhc3RlciBNdWx0aWRpbWVuc2lvbmFsXCIsXG5cdFx0bXVsdGlkaW1lbnNpb25hbFJhc3RlclNuaXA6IFwiQWRpY2lvbmEgZGFkb3MgbXVsdGlkaW1lbnNpb25haXMgYSB1bSBtYXBhIGNvbW8gdW1hIGNhbWFkYSByYXN0ZXIgbXVsdGlkaW1lbnNpb25hbC5cIixcblx0XHRtdWx0aWRpbWVuc2lvbmFsUmFzdGVyRGVzYzogXCJBIGZ1bsOnw6NvIFJhc3RlciBNdWx0aWRpbWVuc2lvbmFsIGFkaWNpb25hIGRhZG9zIG11bHRpZGltZW5zaW9uYWlzIGEgdW0gbWFwYSBjb21vIHVtYSBjYW1hZGEgcmFzdGVyIG11bHRpZGltZW5zaW9uYWwuIEVzdGEgZnVuw6fDo28gw6kgw7p0aWwgYW8gcmVhbGl6YXIgZmx1eG9zIGRlIHRyYWJhbGhvIGRlIGFuw6FsaXNlIHJhc3RlciB1dGlsaXphbmRvIHVtYSBjYWRlaWEgZGUgZnVuw6fDtWVzLjxkaXY+PGJyLz5PcyBjb25qdW50b3MgZGUgZGFkb3MgcmFzdGVyIG11bHRpZGltZW5zaW9uYWlzIGluY2x1ZW0gbmV0Q0RGLCBHUklCLCBIREYgZSBDUkYgZGEgRXNyaS4gT3MgY29uanVudG9zIGRlIGRhZG9zIGRlIG1vc2FpY28gbXVsdGlkaW1lbnNpb25haXMgdGFtYsOpbSBzw6NvIHN1cG9ydGFkb3MuPC9kaXY+XCIsXG5cdFx0b3B0aW1hbFBhdGhBc1Jhc3Rlck5hbWU6IFwiTWVsaG9yIFBlcmN1cnNvIENvbW8gUmFzdGVyXCIsXG5cdFx0b3B0aW1hbFBhdGhBc1Jhc3RlclNuaXA6IFwiQ2FsY3VsYSBvIHBlcmN1cnNvIGRlIG1lbm9yIGN1c3RvIGEgcGFydGlyIGRlIHVtYSBvcmlnZW0gYXTDqSB1bSBkZXN0aW5vLlwiLFxuXHRcdG9wdGltYWxQYXRoQXNSYXN0ZXJEZXNjOiBcIkVzdGEgZnVuw6fDo28gZ2xvYmFsIHByb2R1eiB1bSByYXN0ZXIgZGUgc2HDrWRhIHF1ZSByZWdpc3RhIG8ocykgbWVsaG9yKGVzKSBwZXJjdXJzbyhzKSBhIHBhcnRpciBkZSBsb2NhaXMgc2VsZWNpb25hZG9zIGF0w6kgw6AgY8OpbHVsYSBkZSBvcmlnZW0gbWFpcyBwcsOzeGltYSBkZWZpbmlkYSBkZW50cm8gZGEgc3VwZXJmw61jaWUgZGUgY3VzdG8gYWN1bXVsYWRvLCBlbSB0ZXJtb3MgZGUgZGlzdMOibmNpYSBkZSBjdXN0by48ZGl2Pjxici8+VW1hIG91IG1haXMgZGFzIGZ1bsOnw7VlcyBkZSBjdXN0byBwb25kZXJhZG8gKEFjdW11bGHDp8OjbyBvdSBBdHJpYnVpw6fDo28gZGUgRGlzdMOibmNpYSkgZGV2ZW0gZ2VyYWxtZW50ZSBzZXIgZXhlY3V0YWRhcyBhbnRlcyBkYSBmdW7Dp8OjbyBNZWxob3IgUGVyY3Vyc28gQ29tbyBSYXN0ZXIgcGFyYSBjcmlhciBhIGFjdW11bGHDp8OjbyBkZSBkaXN0w6JuY2lhIGRlIGVudHJhZGEgZSBvcyByYXN0ZXJzIGRlIGRpcmXDp8OjbyBkZSByZXRvcm5vLiBFc3RhcyBzw6NvIGNhbWFkYXMgcmFzdGVyIGRlIGVudHJhZGEgb2JyaWdhdMOzcmlhcyBwYXJhIGEgZnVuw6fDo28gTWVsaG9yIFBlcmN1cnNvLiBPcyB2YWxvcmVzIG5vIG1lbGhvciBwZXJjdXJzbyBkZSBzYcOtZGEgcmVwcmVzZW50YW0gbyBuw7ptZXJvIGRlIHBlcmN1cnNvcyBudW0gZGV0ZXJtaW5hZG8gbG9jYWwuIEVtIG11aXRvcyBjYXNvcywgb3MgcGVyY3Vyc29zIHNlZ3VlbSBvIG1lc21vIGl0aW5lcsOhcmlvLCBkZWl4YW5kbyB1bWEgb3JpZ2VtIGUgZGl2ZXJnaW5kbyBkZXBvaXMgcGFyYSBkZXN0aW5vcyBkaWZlcmVudGVzLiBQb3IgZXhlbXBsbywgdW0gdmFsb3IgZGUgdW0gaW5kaWNhIHF1ZSBleGlzdGUgYXBlbmFzIHVtIG1lbGhvciBwZXJjdXJzbyBudW0gZGV0ZXJtaW5hZG8gbG9jYWwsIGVucXVhbnRvIHVtIHZhbG9yIGRlIGNpbmNvIHNpZ25pZmljYSBxdWUsIG5lc3NlIGxvY2FsLCBleGlzdGVtIGNpbmNvIG1lbGhvcmVzIHBlcmN1cnNvcyBxdWUgYXRyYXZlc3NhbSBlc3NhIGPDqWx1bGEgbmEgw6FyZWEgZGUgZXN0dWRvLjxkaXY+PGJyLz5PcyBkYWRvcyBkZSBkZXN0aW5vIGRlIGVudHJhZGEgZGV2ZW0gc2VyIHVtYSBjYW1hZGEgcmFzdGVyLiBPIGNvbmp1bnRvIGRlIGPDqWx1bGFzIGRlIGRlc3Rpbm8gw6kgY29tcG9zdG8gcG9yIHRvZGFzIGFzIGPDqWx1bGFzIGRvIHJhc3RlciBkZSBlbnRyYWRhIGNvbSB2YWxvcmVzIHbDoWxpZG9zLiBBcyBjw6lsdWxhcyBxdWUgdMOqbSB2YWxvcmVzIE5vRGF0YSBuw6NvIGVzdMOjbyBpbmNsdcOtZGFzIG5vIGNvbmp1bnRvLiBPIHZhbG9yIHplcm8gw6kgY29uc2lkZXJhZG8gdW0gZGVzdGlubyBsZWfDrXRpbW8uIFBvZGUgc2VyIGNyaWFkbyB1bSByYXN0ZXIgZGUgZGVzdGlubyB1dGlsaXphbmRvIGFzIGZlcnJhbWVudGFzIGRlIGV4dHJhw6fDo28uIFNlIHRpdmVyIGVsZW1lbnRvcyBkZSBkZXN0aW5vIG91IGRlIG9yaWdlbSwgcG9kZSBjb252ZXJ0w6otbG9zIHBhcmEgdW0gcmFzdGVyIHV0aWxpemFuZG8gYSBmdW7Dp8OjbyBSYXN0ZXJpemFyIEVsZW1lbnRvcy4gVXRpbGl6ZSBhIGFjdW11bGHDp8OjbyBkZSBkaXN0w6JuY2lhIG91IG8gcmFzdGVyIGRlIGRpcmXDp8OjbyBkZSByZXRvcm5vIGNvbW8gZW50cmFkYSBSYXN0ZXIgcGFyYSBhIGZ1bsOnw6NvIGRlIHJhc3Rlcml6YcOnw6NvLiBJc3RvIGlyw6EgYXNzZWd1cmFyIHF1ZSBvIGVsZW1lbnRvIMOpIHJhc3Rlcml6YWRvIHV0aWxpemFuZG8gbyBtZXNtbyB0YW1hbmhvIGRlIGPDqWx1bGEsIGV4dGVuc8OjbyBlIHJlZmVyw6puY2lhIGVzcGFjaWFsIHF1ZSBvcyBvdXRyb3MgcmFzdGVycyBxdWUgdsOjbyBwYXJhIGEgZnVuw6fDo28gTWVsaG9yIFBlcmN1cnNvIENvbW8gUmFzdGVyLiBBIGZ1bsOnw6NvIE1lbGhvciBQZXJjdXJzbyBDb21vIFJhc3RlciB0YW1iw6ltIHBvZGUgc2VyIHV0aWxpemFkYSBwYXJhIGRlcml2YXIgbyBwZXJjdXJzbyBkZSBtZW5vciByZXNpc3TDqm5jaWEgYXTDqSB1bSBtb2RlbG8gZGUgZWxldmHDp8OjbyBkaWdpdGFsIChERU0pLiBOZXN0ZSBjYXNvLCB1dGlsaXplIG8gREVNIHBhcmEgbyByYXN0ZXIgZGUgYWN1bXVsYcOnw6NvIGRlIGRpc3TDom5jaWEgZGUgZW50cmFkYSBlIGEgc2HDrWRhIGRhIGZ1bsOnw6NvIERpcmXDp8OjbyBkbyBGbHV4byBwYXJhIG8gUmFzdGVyIGRlIGRpcmXDp8OjbyBkZSByZXRvcm5vLjwvZGl2PlwiLFxuXHRcdHRyZW5kTmFtZTogXCJQcmV2ZXIgYXRyYXbDqXMgZGUgVGVuZMOqbmNpYVwiLFxuXHRcdHRyZW5kU25pcDogXCJDYWxjdWxhIHVtYSBjYW1hZGEgcmFzdGVyIG11bHRpZGltZW5zaW9uYWwgcHJldmlzdGEgdXRpbGl6YW5kbyBvIHJhc3RlciBkZSB0ZW5kw6puY2lhIGRlIHNhw61kYSBkYSBmdW7Dp8OjbyBHZXJhciBUZW5kw6puY2lhIG91IGRhIGZlcnJhbWVudGEgZGUgZ2VvcHJvY2Vzc2FtZW50byBHZXJhciBSYXN0ZXIgZGUgVGVuZMOqbmNpYS5cIixcblx0XHR0cmVuZERlc2M6IFwiQSBmdW7Dp8OjbyBQcmV2ZXIgYXRyYXbDqXMgZGUgVGVuZMOqbmNpYSBjYWxjdWxhIHVtYSBjYW1hZGEgcmFzdGVyIG11bHRpZGltZW5zaW9uYWwgcHJldmlzdGEgdXRpbGl6YW5kbyBvIHJhc3RlciBkZSB0ZW5kw6puY2lhIGRlIHNhw61kYSBkYSBmdW7Dp8OjbyBHZXJhciBUZW5kw6puY2lhIG91IGRhIGZlcnJhbWVudGEgZGUgZ2VvcHJvY2Vzc2FtZW50byBHZXJhciBSYXN0ZXIgZGUgVGVuZMOqbmNpYS5cIixcblx0XHRyYXN0ZXJDb2xsZWN0aW9uTmFtZTogXCJQcm9jZXNzYXIgQ29sZcOnw6NvIGRlIFJhc3RlcnNcIixcblx0XHRyYXN0ZXJDb2xsZWN0aW9uU25pcDogXCJQcm9jZXNzYSBjYWRhIHNlY8Onw6NvIG51bSByYXN0ZXIgbXVsdGlkaW1lbnNpb25hbCBvdSBjYWRhIGl0ZW0gbnVtIHJhc3RlciBlbSBtb3NhaWNvLiBFc3RhIGZ1bsOnw6NvIHBvZGUgdGFtYsOpbSBhZ3JlZ2FyIHbDoXJpYXMgc2Vjw6fDtWVzIG51bWEgw7puaWNhIHNlY8Onw6NvLlwiLFxuXHRcdHJhc3RlckNvbGxlY3Rpb25EZXNjOiBcIkEgZnVuw6fDo28gUHJvY2Vzc2FyIENvbGXDp8OjbyBkZSBSYXN0ZXJzIHByb2Nlc3NhIGNhZGEgc2Vjw6fDo28gbnVtIHJhc3RlciBtdWx0aWRpbWVuc2lvbmFsIG91IGNhZGEgaXRlbSBudW0gcmFzdGVyIGVtIG1vc2FpY28uIEVzdGEgZnVuw6fDo28gcG9kZSB0YW1iw6ltIGFncmVnYXIgdsOhcmlhcyBzZWPDp8O1ZXMgbnVtYSDDum5pY2Egc2Vjw6fDo28uPGRpdj48YnIvPkVzdGEgZnVuw6fDo28gcHJvY2Vzc2EgY2FkYSBzZWPDp8OjbyBudW0gcmFzdGVyIG11bHRpZGltZW5zaW9uYWwgb3UgcmFzdGVyIGVtIG1vc2FpY28gdXRpbGl6YW5kbyB1bSBtb2RlbG8gZGUgZnVuw6fDo28gcmFzdGVyLiBFc3RhIGZ1bsOnw6NvIHN1cG9ydGEgYXMgc2VndWludGVzIG9ww6fDtWVzOiAxLiBFc3BlY2lmaXF1ZSB1bSBtb2RlbG8gZGUgZnVuw6fDo28gcmFzdGVyIHBhcmEgYSBGdW7Dp8OjbyBkZSBJdGVtLiBQb3IgZXhlbXBsbywgdGVtIHVtIGNvbmp1bnRvIGRlIGRhZG9zIGVtIG1vc2FpY28gcXVlIGNvbnTDqW0gMjAgYW5vcyBkZSBpbWFnZW5zIExhbmRzYXQgZSBwcmV0ZW5kZSBjYWxjdWxhciBvIE5EVkkgcGFyYSBjYWRhIGNlbmEgZGEgc8OpcmllIHRlbXBvcmFsLiBQYXJhIGEgRnVuw6fDo28gZGUgSXRlbSwgZXNwZWNpZmlxdWUgdW0gbW9kZWxvIGRlIGZ1bsOnw6NvIHJhc3RlciBxdWUgY29udGVuaGEgYSBmdW7Dp8OjbyByYXN0ZXIgTkRWSS4gMi4gRXNwZWNpZmlxdWUgdW0gbW9kZWxvIGRlIGZ1bsOnw6NvIHJhc3RlciBwYXJhIGEgRnVuw6fDo28gZGUgQWdyZWdhw6fDo28uIFBvciBleGVtcGxvLCB0ZW0gdW0gcmFzdGVyIG11bHRpZGltZW5zaW9uYWwgcXVlIGNvbnTDqW0gMTAgYW5vcyBkZSBkYWRvcyByZWxhdGl2b3Mgw6AgdGVtcGVyYXR1cmEgZGnDoXJpYSBlIHByZXRlbmRlIGNhbGN1bGFyIGEgdGVtcGVyYXR1cmEgbcOheGltYSBwYXJhIGNhZGEgYW5vLiBOYSBGdW7Dp8OjbyBkZSBBZ3JlZ2HDp8OjbywgZXNwZWNpZmlxdWUgdW0gbW9kZWxvIGRlIGZ1bsOnw6NvIHJhc3RlciBxdWUgY29udGVuaGEgYSBmdW7Dp8OjbyBFc3RhdMOtc3RpY2FzIGRlIEPDqWx1bGFzLCBjb20gYSBvcGVyYcOnw6NvIGRlZmluaWRhIGNvbW8gTcOheGltYS4gRW0gRGVmaW5pw6fDo28gZGUgQWdyZWdhw6fDo28sIGRlZmluYSBEaW1lbnPDo28gcGFyYSBTdGRUaW1lLCBUaXBvIHBhcmEgUGFsYXZyYS1jaGF2ZSBkZSBJbnRlcnZhbG8gZSBQYWxhdnJhLWNoYXZlIGRlIEludGVydmFsbyBwYXJhIEFudWFsbWVudGUuIE5vdGUgcXVlIHNlIG8gY29uanVudG8gZGUgZGFkb3MgZG8gbW9zYWljbyBkZSBlbnRyYWRhIG7Do28gZm9yIG11bHRpZGltZW5zaW9uYWwsIGEgZnVuw6fDo28gZGUgYWdyZWdhw6fDo28gbsOjbyBpcsOhIHJlc3BlaXRhciBhIGRlZmluacOnw6NvIGRlIGFncmVnYcOnw6NvLiBBIGZ1bsOnw6NvIGRlIGFncmVnYcOnw6NvIGFncmVnYXLDoSB0b2RvcyBvcyBpdGVucyBvdSBjYWRhIGdydXBvIG51bSBzw7Mgc2UgZXN0ZXMgZXN0aXZlcmVtIGRlZmluaWRvcyBubyBtb2RlbG8gZGEgZnVuw6fDo28gZGUgYWdyZWdhw6fDo28uIFBhcmEgbWFpcyBpbmZvcm1hw6fDtWVzIHNvYnJlIGEgdXRpbGl6YcOnw6NvIGRlIGdydXBvcyBudW0gY29uanVudG8gZGUgZGFkb3MgZGUgbW9zYWljbywgY29uc3VsdGUgVXRpbGl6YXIgSXRlbnMgZG8gQ29uanVudG8gZGUgRGFkb3MgZGUgTW9zYWljbyBlbSBNb2RlbG9zIGRhIEZ1bsOnw6NvIFJhc3Rlci4gMy4gRXNwZWNpZmlxdWUgdW0gbW9kZWxvIGRlIGZ1bsOnw6NvIHJhc3RlciBwYXJhIGEgRnVuw6fDo28gZGUgUHJvY2Vzc2FtZW50by4gQSBmdW7Dp8OjbyBvdSBjYWRlaWEgZGUgZnVuw6fDtWVzIG5lc3RlIG1vZGVsbyDDqSB1dGlsaXphZGEgcGFyYSBleGliaXIgbyBub3ZvIHJhc3RlciBwcm9jZXNzYWRvLiBQb3IgZXhlbXBsbywgZXNwZWNpZmlxdWUgdW0gbW9kZWxvIGRlIGZ1bsOnw6NvIHJhc3RlciBxdWUgY29udGVuaGEgYSBmdW7Dp8OjbyBNYXBhIGRlIENvciBwYXJhIGFsdGVyYXIgYSBmb3JtYSBjb21vIGEgY2FtYWRhIHJhc3RlciBwcm9jZXNzYWRhIMOpIGV4aWJpZGEuIFRlbmhhIGVtIGNvbnRhIHF1ZSBzZSBhIGVudHJhZGEgZm9yIHVtIHJhc3RlciBtdWx0aWRpbWVuc2lvbmFsLCBhIGZ1bsOnw6NvIGRlIHByb2Nlc3NhbWVudG8gw6kgYXBsaWNhZGEgw6Agc2Vjw6fDo28gZGUgZXhpYmnDp8OjbyBhdHVhbC4gU2UgYSBlbnRyYWRhIGZvciB1bWEgY2FtYWRhIGRlIG1vc2FpY28gb3UgdW0gY29uanVudG8gZGUgZGFkb3MgZW0gbW9zYWljbywgYSBmdW7Dp8OjbyBkZSBwcm9jZXNzYW1lbnRvIMOpIGFwbGljYWRhIGFvIHJhc3RlciBkZSBtb3NhaWNvIHV0aWxpemFuZG8gbyBQcmltZWlybyBtw6l0b2RvIHBhcmEgcmVzb2x2ZXIgc29icmVwb3Npw6fDtWVzLiAzLiBFc3BlY2lmaXF1ZSBvcyBtb2RlbG9zIHBhcmEgcXVhbHF1ZXIgY29tYmluYcOnw6NvIGRhcyB0csOqcyBmdW7Dp8O1ZXMuIFBvciBleGVtcGxvLCB0ZW0gdW0gY29uanVudG8gZGUgZGFkb3MgZW0gbW9zYWljbyBxdWUgY29udMOpbSBpbWFnZW5zIGRhIHPDqXJpZSB0ZW1wb3JhbCBMYW5kc2F0IGUgcHJldGVuZGUgZ2VyYXIgdW1hIGltYWdlbSBjb21wb3N0YSBkbyBORFZJIG3DoXhpbW8uIFBhcmEgYSBGdW7Dp8OjbyBkZSBJdGVtLCBlc3BlY2lmaXF1ZSB1bSBtb2RlbG8gZGUgZnVuw6fDo28gcmFzdGVyIHF1ZSBjb250ZW5oYSBhIGZ1bsOnw6NvIHJhc3RlciBORFZJLiBQYXJhIGEgRnVuw6fDo28gZGUgQWdyZWdhw6fDo28sIGVzcGVjaWZpcXVlIHVtIG1vZGVsbyBkZSBmdW7Dp8OjbyByYXN0ZXIgcXVlIGNvbnRlbmhhIGEgZnVuw6fDo28gRXN0YXTDrXN0aWNhcyBkZSBDw6lsdWxhcywgY29tIGEgb3BlcmHDp8OjbyBkZWZpbmlkYSBwYXJhIE3DoXhpbW8uIFBhcmEgYSBGdW7Dp8OjbyBkZSBQcm9jZXNzYW1lbnRvLCBlc3BlY2lmaXF1ZSB1bSBtb2RlbG8gZGUgZnVuw6fDo28gcmFzdGVyIHF1ZSBjb250ZW5oYSBhIGZ1bsOnw6NvIE1hcGEgZGUgQ29yLiBUZW5oYSBlbSBjb250YSBxdWUgYSBvcmRlbSBkZSBwcm9jZXNzYW1lbnRvIGRhIGZ1bsOnw6NvIHNlZ3VlIGEgb3JkZW0gZG9zIHBhcsOibWV0cm9zIGRlIGVudHJhZGEuIFBvciBleGVtcGxvLCBhIEZ1bsOnw6NvIGRlIEl0ZW0gc2Vyw6EgcHJvY2Vzc2FkYSBlbSBwcmltZWlybyBsdWdhci48L2Rpdj5cIixcblx0XHRyYW5kb21OYW1lOiBcIkFsZWF0w7NyaW9cIixcblx0XHRyYW5kb21TbmlwOiBcIkNyaWEgdW0gcmFzdGVyIGNvbSB2YWxvcmVzIGRlIHDDrXhlaXMgYWxlYXTDs3Jpb3MgZGVzZW5oYWRvcyBkZSB1bWEgZGlzdHJpYnVpw6fDo28gcHNldWRvYWxlYXTDs3JpYS4gU8OjbyBzdXBvcnRhZGFzIHbDoXJpYXMgZGlzdHJpYnVpw6fDtWVzIGUgZ2VyYWRvcmVzIGRlIG7Dum1lcm9zIGFsZWF0w7NyaW9zLlwiLFxuXHRcdHJhbmRvbURlc2M6IFwiQSBmdW7Dp8OjbyBBbGVhdMOzcmlvIGNyaWEgdW0gcmFzdGVyIGNvbSB2YWxvcmVzIGRlIHDDrXhlaXMgYWxlYXTDs3Jpb3MgcXVlIHBvZGVtIHNlciB1dGlsaXphZG9zIGVtIG1vZGVsb3MgZGUgZnVuw6fDtWVzIHJhc3RlciBvdSBjb25qdW50b3MgZGUgZGFkb3MgZW0gbW9zYWljby48ZGl2Pjxici8+RW1ib3JhIG11aXRhcyBmdW7Dp8O1ZXMgZnVuY2lvbmVtIG51bSBvdSB2w6FyaW9zIHJhc3RlcnMgZGUgZW50cmFkYSwgYSBmdW7Dp8OjbyBBbGVhdMOzcmlvIG7Do28gcmVxdWVyIHVtIHJhc3RlciBkZSBlbnRyYWRhLiBJc3RvIHNpZ25pZmljYSBxdWUgc2UgY29tcG9ydGEgbWFpcyBjb21vIHVtIGNvbmp1bnRvIGRlIGRhZG9zIHJhc3RlciBkbyBxdWUgY29tbyB1bWEgZnVuw6fDo28sIHBlbG8gcXVlIMOpIG5lY2Vzc8OhcmlvIHRlciB1bSBjdWlkYWRvIGVzcGVjaWFsIGFvIGFkaWNpb27DoS1sYSBvdSByZW1vdsOqLWxhIGRhIGNhZGVpYSBkZSBmdW7Dp8O1ZXMuPC9kaXY+XCIsXG5cdFx0c2hyaW5rTmFtZTogXCJSZWR1emlyXCIsXG5cdFx0c2hyaW5rU25pcDogXCJSZWR1eiBhcyB6b25hcyBzZWxlY2lvbmFkYXMgcG9yIHVtIG7Dum1lcm8gZXNwZWNpZmljYWRvIGRlIGPDqWx1bGFzLCBzdWJzdGl0dWluZG8tYXMgcGVsbyB2YWxvciBkYSBjw6lsdWxhIHF1ZSDDqSBtYWlzIGZyZXF1ZW50ZSBuYSBzdWEgdml6aW5oYW7Dp2EuXCIsXG5cdFx0c2hyaW5rRGVzYzogXCJDb20gYSBmdW7Dp8OjbyBnbG9iYWwgUmVkdXppciwgcG9kZSBnZW5lcmFsaXphciBvdSBzaW1wbGlmaWNhciBvcyByYXN0ZXJzLCB0b3JuYW5kbyBhcyB6b25hcyBlc3BlY8OtZmljYXMgbWFpcyBwZXF1ZW5hcy4gUG9kZSB0YW1iw6ltIGNvbnRyb2xhciBhIHF1YW50aWRhZGUgZGUgZ2VuZXJhbGl6YcOnw6NvIHF1ZSBpcsOhIG9jb3JyZXIuPGRpdj48YnIvPkFzIHpvbmFzIHF1ZSBzZWxlY2lvbmFyIGlyw6NvIGVuY29saGVyLCBvdSByZWR1emlyIGVtIHRhbWFuaG8sIHRlbmRvIGPDqWx1bGFzIGRhcyB6b25hcyBjaXJjdW5kYW50ZXMgYSBleHBhbmRpci1zZSBwYXJhIGVsYXMuIENvbmNlcHR1YWxtZW50ZSwgb3MgVmFsb3JlcyBkZSBab25hIHNlbGVjaW9uYWRvcyBwb2RlbSBzZXIgdmlzdG9zIGNvbW8gem9uYXMgZGUgcHJpbWVpcm8gcGxhbm8sIGVucXVhbnRvIG9zIG91dHJvcyB2YWxvcmVzIHBlcm1hbmVjZW0gY29tbyB6b25hcyBkZSBzZWd1bmRvIHBsYW5vLiBBcyBjw6lsdWxhcyBuYXMgem9uYXMgZGUgcHJpbWVpcm8gcGxhbm8gcG9kZW0gc2VyIHN1YnN0aXR1w61kYXMgcG9yIGPDqWx1bGFzIG5hcyB6b25hcyBkZSBzZWd1bmRvIHBsYW5vLiBBcyBpbGhhcyBmaW5hcyBkZW50cm8gZGUgdW1hIHpvbmEsIHF1ZSBwb2RlbSBzZXIgdmlzdGFzIGNvbW8gcGFydGlsaGFuZG8gbGltaXRlcyBjb20gYSB6b25hLCB0YW1iw6ltIHBvZGVtIHNlciBzdWJzdGl0dcOtZGFzLjxkaXY+PGJyLz5BIHF1YW50aWRhZGUgZGUgZ2VuZXJhbGl6YcOnw6NvIHBvZGUgc2VyIGNvbnRyb2xhZGEgY29tIG8gcGFyw6JtZXRybyBOw7ptZXJvIGRlIEPDqWx1bGFzLiBQb3IgcHJlZGVmaW5pw6fDo28sIGVzdGUgdmFsb3Igw6kgMSwgbyBxdWUgc2lnbmlmaWNhIHF1ZSBhcyB6b25hcyBzZWxlY2lvbmFkYXMgaXLDo28gcmVkdXppci1zZSBwZWxhIHF1YW50aWRhZGUgY29ycmVzcG9uZGVudGUgYW8gdGFtYW5obyBkZSB1bWEgY8OpbHVsYS4gUGFyYSBhdW1lbnRhciBvIGdyYXUgZGUgZ2VuZXJhbGl6YcOnw6NvLCBwb2RlIGVzcGVjaWZpY2FyIHVtIHZhbG9yIG1haW9yIHBhcmEgZXN0ZSBwYXLDom1ldHJvLiBDb25jZXB0dWFsbWVudGUsIGlzdG8gw6kgY29tbyBleGVjdXRhciBhIGZlcnJhbWVudGEgdGFudGFzIHZlemVzIHF1YW50byBvIG7Dum1lcm8gZXNwZWNpZmljYWRvLCBjb20gb3MgcmVzdWx0YWRvcyBkYSBleGVjdcOnw6NvIGFudGVyaW9yIGEgc2VyIGEgZW50cmFkYSBwYXJhIGEgaXRlcmHDp8OjbyBzZWd1aW50ZS48L2Rpdj5cIixcblx0XHR0cmVuZFRvUkdCTmFtZTogXCJUZW5kw6puY2lhIHBhcmEgUkdCXCIsXG5cdFx0dHJlbmRUb1JHQlNuaXA6IFwiQ29udmVydGUgdW0gcmFzdGVyIGRlIHRlbmTDqm5jaWEgbnVtIHJhc3RlciBkZSB0csOqcyBiYW5kYXMgKHZlcm1lbGhvLCB2ZXJkZSBlIGF6dWwpLlwiLFxuXHRcdHRyZW5kVG9SR0JEZXNjOiBcIkEgZnVuw6fDo28gVGVuZMOqbmNpYSBwYXJhIFJHQiBjb252ZXJ0ZSB1bSByYXN0ZXIgZGUgdGVuZMOqbmNpYSBudW0gcmFzdGVyIGRlIHRyw6pzIGJhbmRhcyAodmVybWVsaG8sIHZlcmRlIGUgYXp1bCkuIE8gcmFzdGVyIGRlIHRlbmTDqm5jaWEgw6kgZ2VyYWRvIGEgcGFydGlyIGRhIGZ1bsOnw6NvIHJhc3RlciBHZXJhciBUZW5kw6puY2lhIG91IGRhIGZ1bsOnw6NvIHJhc3RlciBBbsOhbGlzZSBDQ0RDLjxkaXY+PGJyLz5Fc3RhIGZ1bsOnw6NvIMOpIMO6dGlsIHBhcmEgdmlzdWFsaXphciBkYWRvcyBkbyBjb2VmaWNpZW50ZSBkbyBtb2RlbG8gZGEgZnVuw6fDo28gR2VyYXIgVGVuZMOqbmNpYSBvdSBkYSBmdW7Dp8OjbyBBbsOhbGlzZSBDQ0RDLiBBbWJhcyBhcyBmdW7Dp8O1ZXMgZXN0aW1hbSB0ZW5kw6puY2lhcyBlbSB2YWxvcmVzIGRlIHDDrXhlaXMgdmFyacOhdmVpcywgbWFzIG9zIHJlc3VsdGFkb3MgZGFzIGZ1bsOnw7VlcyBzw6NvIGRpZsOtY2VpcyBkZSBpbnRlcnByZXRhciBkaXJldGFtZW50ZS48ZGl2Pjxici8+VGFsIGNvbW8gbXVpdGFzIGZ1bsOnw7VlcyByYXN0ZXIsIHBvZGUgdGVyIGRlIHV0aWxpemFyIG8gQWp1c3RlIGRlIEludGVydmFsbyBEaW7Dom1pY28gKERSQSkgcGFyYSB2aXN1YWxpemFyIG1lbGhvciBvcyByZXN1bHRhZG9zIGRlc3RhIGZ1bsOnw6NvLjwvZGl2PlwiLFxuXHRcdGxhbmRUcmVuZHJOYW1lOiBcIkFuw6FsaXNlIExhbmRUcmVuZHJcIixcblx0XHRsYW5kVHJlbmRyU25pcDogXCJBdmFsaWEgYXMgYWx0ZXJhw6fDtWVzIG5vcyB2YWxvcmVzIGRlIHDDrXhlaXMgYW8gbG9uZ28gZG8gdGVtcG8gY29tIG8gbcOpdG9kbyBMYW5kc2F0IGRlIGRldGXDp8OjbyBkZSB0ZW5kw6puY2lhcyBkZSBwZXJ0dXJiYcOnw6NvIGUgcmVjdXBlcmHDp8OjbyAoTGFuZFRyZW5kcikgZSBnZXJhIHVtIHJhc3RlciBkZSBhbsOhbGlzZSBkZSBhbHRlcmHDp8O1ZXMgY29tIG9zIHJlc3VsdGFkb3MgZG8gbW9kZWxvLlwiLFxuXHRcdGxhbmRUcmVuZHJEZXNjOiBcIkVzdGEgZnVuw6fDo28gcmFzdGVyIHPDsyBwb2RlIHNlciB1c2FkYSBjb21vIGVudHJhZGEgcGFyYSBhIGZ1bsOnw6NvIHJhc3RlciBEZXRldGFyIEFsdGVyYcOnw7VlcyBBdHJhdsOpcyBkYSBBbsOhbGlzZSBkZSBBbHRlcmHDp8O1ZXMuIFBhcmEgZ2VyYXIgdW1hIHNhw61kYSByYXN0ZXIsIGFzc29jaWUgYSBmdW7Dp8OjbyBBbsOhbGlzZSBMYW5kVHJlbmRyIMOgIGZ1bsOnw6NvIEFsdGVyYcOnw7VlcyBBdHJhdsOpcyBkYSBBbsOhbGlzZSBkZSBBbHRlcmHDp8O1ZXMgbnVtIG1vZGVsbyBkZSBmdW7Dp8OjbyByYXN0ZXIsIGUgdXRpbGl6ZSBvIG1vZGVsbyBjb21vIGVudHJhZGEgbmEgZmVycmFtZW50YSBkZSBnZW9wcm9jZXNzYW1lbnRvIEdlcmFyIFJhc3RlciBhIHBhcnRpciBkYSBGdW7Dp8OjbyBSYXN0ZXIuIE8gcmVzdWx0YWRvIMOpIHVtIHJhc3RlciBxdWUgY29udMOpbSBpbmZvcm1hw6fDtWVzIHJlbGF0aXZhcyBhbyB0ZW1wbyBlbSBxdWUgb3MgdmFsb3JlcyBkZSBww614ZWwgc2UgYWx0ZXJhcmFtLjxkaXY+PGJyPk8gb2JqZXRpdm8gZGVzdGEgZnVuw6fDo28gcmFzdGVyIMOpIGV4dHJhaXIgYWx0ZXJhw6fDtWVzIG51bSBlbGVtZW50byBvYnNlcnZhZG8sIHBlbG8gcXVlIGFzIGltYWdlbSBtdWx0aWRpbWVuc2lvbmFpcyBkZSBlbnRyYWRhIGlkZWFpcyBkZXZlbSBjYXB0dXJhciB1bWEgb2JzZXJ2YcOnw6NvIGNvbnNpc3RlbnRlIGFvIGxvbmdvIGRvIHRlbXBvIGUgbsOjbyBkZXZlbSBpbmNsdWlyIGludGVyZmVyw6puY2lhIGF0bW9zZsOpcmljYSBvdSBkZSBzZW5zb3IsIG51dmVucywgb3Ugc29tYnJhIGRlIG51dmVtLiBBIG1lbGhvciBwcsOhdGljYSDDqSB1dGlsaXphciBkYWRvcyBxdWUgdGVuaGFtIHNpZG8gbm9ybWFsaXphZG9zIGUgcG9zc2FtIHNlciBtYXNjYXJhZG9zIHV0aWxpemFuZG8gdW1hIGJhbmRhIGRlIFFBLCBwb3IgZXguLCBkZSBSZWZsZXTDom5jaWEgZGUgU3VwZXJmw61jaWUgTGFuZHNhdCBDb2xlw6fDo28gMSBjb20gdW1hIG3DoXNjYXJhIGRlIG51dmVtLjxkaXY+PGJyPkEgZnVuw6fDo28gZWZldHVhIGFuw6FsaXNlcyBudW1hIGltYWdlbSBwb3IgYW5vLCBlIG8gbsO6bWVybyBkZSBzZWPDp8O1ZXMgYW51YWlzIGRldmUgc2VyIGlndWFsIG91IHN1cGVyaW9yIGFvIHZhbG9yIGVzcGVjaWZpY2FkbyBubyBwYXLDom1ldHJvIDxzdHJvbmc+TsO6bWVybyBNw61uaW1vIGRlIE9ic2VydmHDp8O1ZXM8L3N0cm9uZz4uIFJlY29tZW5kYS1zZSBxdWUgdGVuaGEgcGVsbyBtZW5vcyBzZWlzIGFub3MgZGUgZGFkb3MuPGRpdj48YnI+U2UgdGl2ZXIgZGFkb3MgbWVuc2Fpcywgc2VtYW5haXMgb3UgZGnDoXJpb3MsIHJlY29tZW5kYS1zZSBxdWUgc2VsZWNpb25lIHbDoXJpYXMgaW1hZ2VucyBkZSBjYWRhIGFubyAoZGUgcHJlZmVyw6puY2lhLCBkYSBtZXNtYSBlc3Rhw6fDo28pLCByZW1vdmEgYXMgbnV2ZW5zIGUgYSBzb21icmEgZGFzIG51dmVucywgZSBjb21iaW5lIGFzIGltYWdlbnMgcGFyYSBnZXJhciB1bWEgw7puaWNhIGltYWdlbSBxdWUgY2FwdGUgYmVtIGEgb2JzZXJ2YcOnw6NvLiBTZSBmb3JlbSBmb3JuZWNpZG9zIGRhZG9zIG1lbnNhaXMsIHNlbWFuYWlzLCBvdSBkacOhcmlvcyBjb21vIHJhc3RlciBkZSBkYWRvcyBtdWx0aWRpbWVuc2lvbmFsLCBhIGZ1bsOnw6NvIGlkZW50aWZpY2Fyw6EgdW1hIHNlY8Onw6NvIHBhcmEgYW7DoWxpc2UgY29tIGJhc2UgbmEgZGF0YSBtYWlzIHByw7N4aW1hIGRhIGZvcm5lY2lkYSBubyBwYXLDom1ldHJvIDxzdHJvbmc+QWp1c3RlIGRhIERhdGE8L3N0cm9uZz4uPGRpdj48YnI+VW0gZWxlbWVudG8gbnVtYSBwYWlzYWdlbSBsZXZhcsOhIGZyZXF1ZW50ZW1lbnRlIHRlbXBvIGEgcmVjdXBlcmFyIGRlIHVtYSBhbHRlcmHDp8OjbyBuw6NvIHBlcm1hbmVudGUgY29tbyB1bSBpbmPDqm5kaW8gZmxvcmVzdGFsIG91IHVtYSBpbmZlc3Rhw6fDo28gZGUgaW5zZXRvcy4gUGFyYSBjb250cm9sYXIgYSB0YXhhIGRlIHJlY3VwZXJhw6fDo28gcmVjb25oZWNpZGEgcGVsbyBtb2RlbG8sIGRlZmluYSBvIHBhcsOibWV0cm8gTGltaWFyIGRlIFJlY3VwZXJhw6fDo28uIFVtIHNlZ21lbnRvIGRpc3RpbnRvIG7Do28gcG9kZSB0ZXIgdW1hIHRheGEgZGUgcmVjdXBlcmHDp8OjbyBtYWlzIHLDoXBpZGEgZG8gcXVlIDEvbGltaWFyIGRlIHJlY3VwZXJhw6fDo28uPGRpdj48YnI+QSByZWN1cGVyYcOnw6NvIGRlIHVtYSBhbHRlcmHDp8OjbyBuYSBwYWlzYWdlbSBwb2RlIG9jb3JyZXIgbmEgZGlyZcOnw6NvIHBvc2l0aXZhIG91IG5lZ2F0aXZhLiBQb3IgZXhlbXBsbywgcXVhbmRvIHVtYSBwYWlzYWdlbSBleHBlcmltZW50YSB1bWEgcGVyZGEgZmxvcmVzdGFsLCB1bWEgc8OpcmllIHRlbXBvcmFsIGRlIHZhbG9yZXMgZG8gw61uZGljZSBkZSB2ZWdldGHDp8OjbyBhcHJlc2VudGEgdW1hIHF1ZWRhIG5vcyB2YWxvcmVzIGRvIMOtbmRpY2UsIGUgYSByZWN1cGVyYcOnw6NvIG1vc3RyYSB1bSBhdW1lbnRvIGdyYWR1YWwgbm9zIHZhbG9yZXMgZG8gw61uZGljZSBkZSB2ZWdldGHDp8Ojbywgb3UgdW1hIHRlbmTDqm5jaWEgcG9zaXRpdmEgZGUgcmVjdXBlcmHDp8Ojby4gRXNwZWNpZmljYXIgYSBkaXJlw6fDo28gZGEgdGVuZMOqbmNpYSBkZSByZWN1cGVyYcOnw6NvIGNvbSBvIHBhcsOibWV0cm8gPHN0cm9uZz5SZWN1cGVyYcOnw6NvIGNvbSBUZW5kw6puY2lhIENyZXNjZW50ZTwvc3Ryb25nPi5cIixcblx0XHRhZ2dyZWdhdGVNdWx0aWRpbWVuc2lvbmFsTmFtZTogXCJBZ3JlZ2FyIE11bHRpZGltZW5zaW9uYWxcIixcblx0XHRhZ2dyZWdhdGVNdWx0aWRpbWVuc2lvbmFsU25pcDogXCJDb21iaW5hIGRhZG9zIHZhcmnDoXZlaXMgcmFzdGVyIG11bHRpZGltZW5zaW9uYWlzIGV4aXN0ZW50ZXMgYW8gbG9uZ28gZGUgdW1hIGRpbWVuc8Ojby5cIixcblx0XHRhZ2dyZWdhdGVNdWx0aWRpbWVuc2lvbmFsRGVzYzogXCJBIGZ1bsOnw6NvIEFncmVnYXIgTXVsdGlkaW1lbnNpb25hbCBjcmlhIHVtYSBjYW1hZGEgcmFzdGVyIG11bHRpZGltZW5zaW9uYWwgYW8gY29tYmluYXIgZGFkb3MgZXhpc3RlbnRlcyBkZSB2YXJpw6F2ZWlzIHJhc3RlciBtdWx0aWRpbWVuc2lvbmFpcyBhbyBsb25nbyBkZSB1bWEgZGltZW5zw6NvLjxkaXY+PGJyPlVzZSBvIHBhcsOibWV0cm/CoDxzdHJvbmc+RGVmaW5pw6fDo28gZGEgRGltZW5zw6NvPC9zdHJvbmc+wqBwYXJhIGZpbHRyYXIgcHJpbWVpcm8gb3MgZGFkb3MgZGUgZW50cmFkYSBxdWUgcHJldGVuZGUgYWdyZWdhci4gUG9yIGV4ZW1wbG8sIHNlIHRpdmVyIDMwIGFub3MgZGUgZGFkb3MgbWVuc2FpcywgbWFzIGFwZW5hcyBxdWlzZXIgY3JpYXIgdW1hIGNhbWFkYSBhZ3JlZ2FkYSBkdXJhbnRlIG9zIHByaW1laXJvcyAxNSBhbm9zLCBwb2RlIHVzYXIgbyBwYXLDom1ldHJvwqA8c3Ryb25nPkRlZmluacOnw6NvIGRhIERpbWVuc8Ojbzwvc3Ryb25nPsKgcGFyYSBlc3BlY2lmaWNhciBvcyBhbm9zIGEgaW5jbHVpciBuYSBhbsOhbGlzZS48ZGl2Pjxicj48dWw+PGxpPkV4dHJhaXIgZGFkb3MgcmVsYXRpdm9zIMOgIHNhbGluaWRhZGUgcGFyYSBvIG3DqnMgZGUgamFuZWlybyBkdXJhbnRlIG8gcGVyw61vZG8gZGUgMTAgYW5vcy4gU2VsZWNpb25lwqA8c3Ryb25nPlBvciBWYWxvcmVzPC9zdHJvbmc+LCBkZWZpbmHCoDxzdHJvbmc+RGltZW5zw6NvPC9zdHJvbmc+wqBwYXJhwqA8c3Ryb25nPlN0ZFRpbWU8L3N0cm9uZz4gZSBkZWZpbmHCoDxzdHJvbmc+VmFsb3Jlczwvc3Ryb25nPsKgcGFyYcKgPHN0cm9uZz5KYW5laXJvPC9zdHJvbmc+LjwvbGk+PGxpPlNlY2Npb25lIG9zIGRhZG9zIHJlbGF0aXZvcyDDoCBzYWxpbmlkYWRlIG51bSBpbnRlcnZhbG8gZGUgcHJvZnVuZGlkYWRlIGRlIDAgYSAxNTAgbWV0cm9zLiBTZWxlY2lvbmXCoDxzdHJvbmc+UG9yIEludGVydmFsb3M8L3N0cm9uZz4sIGRlZmluYcKgPHN0cm9uZz5EaW1lbnPDo288L3N0cm9uZz7CoHBhcmHCoDxzdHJvbmc+U3RkWjwvc3Ryb25nPiBlIGRlZmluYcKgPHN0cm9uZz5WYWxvciBNw61uaW1vPC9zdHJvbmc+wqBwYXJhwqA8c3Ryb25nPi0xNTA8L3N0cm9uZz7CoGXCoDxzdHJvbmc+VmFsb3IgTcOheGltbzwvc3Ryb25nPsKgcGFyYcKgPHN0cm9uZz4wPC9zdHJvbmc+LjwvbGk+PGxpPkV4dHJhaWEgZGFkb3MgcmVsYXRpdm9zIMOgIHNhbGluaWRhZGUgcGFyYSBvcyBwcmltZWlyb3MgMTAgZGlhcyBkZSBjYWRhIG3DqnMgZGUgamFuZWlybyBkdXJhbnRlIHVtIHBlcsOtb2RvIGRlIDEwIGFub3MuIFNlbGVjaW9uZcKgPHN0cm9uZz5Qb3IgSXRlcmHDp8Ojbzwvc3Ryb25nPiwgZGVmaW5hwqA8c3Ryb25nPkRpbWVuc8Ojbzwvc3Ryb25nPsKgcGFyYcKgPHN0cm9uZz5TdGRUaW1lPC9zdHJvbmc+LCBkZWZpbmHCoDxzdHJvbmc+SW7DrWNpbyBkYSBwcmltZWlyYSBpdGVyYcOnw6NvPC9zdHJvbmc+wqBlwqA8c3Ryb25nPkZpbSBkYSBwcmltZWlyYSBpdGVyYcOnw6NvPC9zdHJvbmc+wqBwYXJhIG8gaW7DrWNpbyBlIGZpbSBjb3JyZXNwb25kZW50ZXMgZG8gcGVyw61vZG8gZGUgaXRlcmHDp8OjbywgZGVmaW5hwqA8c3Ryb25nPlBhc3NvPC9zdHJvbmc+wqBwYXJhwqA8c3Ryb25nPjE8L3N0cm9uZz4gZSBkZWZpbmHCoDxzdHJvbmc+VW5pZGFkZTwvc3Ryb25nPsKgcGFyYcKgPHN0cm9uZz5Bbm9zPC9zdHJvbmc+LjwvbGk+PC91bD48ZGl2Pjxicj5Vc2Ugb3MgcGFyw6JtZXRyb3PCoDxzdHJvbmc+RGVmaW5pw6fDo28gZGUgQWdyZWdhw6fDo288L3N0cm9uZz7CoHBhcmEgc2VsZWNpb25hciBhIGRpbWVuc8OjbyBhIGF2YWxpYXIgZSBvIGludGVydmFsbyBkZSBhZ3JlZ2HDp8OjbyB1c2FuZG8gdW1hIHBhbGF2cmEtY2hhdmUsIHVtIHZhbG9yIG91IHVtIGludGVydmFsbyBkZSB2YWxvcmVzLiBQb3IgZXhlbXBsbywgc2UgdGl2ZXIgMzAgYW5vcyBkZSBkYWRvcyBkZSB0ZW1wZXJhdHVyYSDDoCBzdXBlcmbDrWNpZSBkbyBtYXIsIHJlY29saGlkb3MgZGlhcmlhbWVudGUgZSBhIGNhZGEgNSBtZXRyb3MgZGUgcHJvZnVuZGlkYWRlIGF0w6kgMTAwIG1ldHJvcywgcG9kZSB1dGlsaXphciBhcyBkaWZlcmVudGVzIG9ww6fDtWVzIGRlIGludGVydmFsbyBwYXJhIG9zIHNlZ3VpbnRlcyBjZW7DoXJpb3M6PGRpdj48YnI+PHVsPjxsaT5BZ3JlZ2FyIGRhZG9zIGRpw6FyaW9zIGRlIHRlbXBlcmF0dXJhIGVtIGRhZG9zIG1lbnNhaXMsIG9uZGUgbyByZXN1bHRhZG8gw6kgdW0gcmFzdGVyIG11bHRpZGltZW5zaW9uYWwgY29tIDEyIHNlY8Onw7VlcyBkZSB0ZW1wbywgZSBjYWRhIHNlY8Onw6NvIMOpIG8gYWdyZWdhZG8gZGUgY2FkYSBtw6pzIGFvIGxvbmdvIGRlIHRvZG9zIG9zIGFub3MuIFNlbGVjaW9uZcKgPHN0cm9uZz5QYWxhdnJhLWNoYXZlIGRlIEludGVydmFsbzwvc3Ryb25nPsKgZSBkZWZpbmEgYSBwYWxhdnJhLWNoYXZlIHBhcmHCoDxzdHJvbmc+TWVuc2FsIFJlY29ycmVudGU8L3N0cm9uZz4uPC9saT48bGk+QWdyZWd1ZSBkYWRvcyBkacOhcmlvcyBkZSB0ZW1wZXJhdHVyYSBlbSBkYWRvcyBtZW5zYWlzLCBvbmRlIG8gcmVzdWx0YWRvIMOpIHVtIHJhc3RlciBtdWx0aWRpbWVuc2lvbmFsIGNvbSAzNjAgc2Vjw6fDtWVzIG91IDEyIHNlY8Onw7VlcyBkZSB0ZW1wbyBwb3IgYW5vICgzMCBhbm9zIHggMTIgbWVzZXMgPSAzNjAgc2Vjw6fDtWVzKS4gU2VsZWNpb25lwqA8c3Ryb25nPlBhbGF2cmEtY2hhdmUgZGUgSW50ZXJ2YWxvPC9zdHJvbmc+wqBlIGRlZmluYSBhIHBhbGF2cmEtY2hhdmUgcGFyYcKgPHN0cm9uZz5NZW5zYWw8L3N0cm9uZz4uPC9saT48bGk+QWdyZWd1ZSBvcyBkYWRvcyBkZSB0ZW1wZXJhdHVyYSBtZW5zYWlzIGVtIGludGVydmFsb3MgZGUgNCBtZXNlcy4gU2VsZWNpb25lwqA8c3Ryb25nPlZhbG9yIGRlIEludGVydmFsbzwvc3Ryb25nPiwgZGVmaW5hwqA8c3Ryb25nPkludGVydmFsbyBkZSBWYWxvcjwvc3Ryb25nPsKgcGFyYcKgNCBlIGRlZmluYcKgPHN0cm9uZz5VbmlkYWRlPC9zdHJvbmc+wqBwYXJhwqA8c3Ryb25nPk1lc2VzPC9zdHJvbmc+LjwvbGk+PGxpPkFncmVndWUgb3MgZGFkb3MgZGUgdGVtcGVyYXR1cmEgZGUgMCBhIDI1IG1ldHJvcywgZSBkZXBvaXMgZGUgMjUgYSA1MCBtZXRyb3MsIGUgZGUgNTAgYSAxMDAgbWV0cm9zLiBTZWxlY2lvbmXCoDxzdHJvbmc+SW50ZXJ2YWxvczwvc3Ryb25nPsKgZSBlc3BlY2lmaXF1ZSBhcyBwcm9mdW5kaWRhZGVzIG3DrW5pbWEgZSBtw6F4aW1hIGNvbW/CoDxzdHJvbmc+MCAyNTsgMjUgNTA7IDUwIDEwMDwvc3Ryb25nPi48L2xpPjwvdWw+XCIsXG5cdFx0bWVyZ2VSYXN0ZXJzTmFtZTogXCJJbnRlcmNhbGFyIFJhc3RlcnNcIixcblx0XHRtZXJnZVJhc3RlcnNTbmlwOiBcIkNvbWJpbmEgbcO6bHRpcGxvcyBjb25qdW50b3MgZGUgZGFkb3MgcmFzdGVyIGVzcGFjaWFsbWVudGUgb3UgYXRyYXbDqXMgZGUgdmFyacOhdmVpcyBlIGRpbWVuc8O1ZXMuXCIsXG5cdFx0bWVyZ2VSYXN0ZXJzRGVzYzogXCJFc3RhIGZ1bsOnw6NvIGNyaWEgdW0gcmFzdGVyIGludGVyY2FsYWRvIGEgcGFydGlyIGRlIHVtYSBsaXN0YSBkZSByYXN0ZXJzLiBQb3IgZXhlbXBsbywgc2UgdGl2ZXIgdW0gY29uanVudG8gZGUgZGFkb3MgZW0gbW9zYWljbyBxdWUgY29udGVuaGEgMzAgYW5vcyBkZSBkYWRvcyBtZW5zYWlzIGRlIHByZWNpcGl0YcOnw6NvIGUgb3V0cm8gY29uanVudG8gZGUgZGFkb3MgY29tIDEwIGFub3MgZGUgZGFkb3MgbWVuc2FpcyBkZSB0ZW1wZXJhdHVyYSwgcG9kZSBjb21iaW7DoS1sb3MgbnVtIHJhc3RlciBtdWx0aWRpbWVuc2lvbmFsIGNvbSBhbWJhcyBhcyB2YXJpw6F2ZWlzLiA8ZGl2Pjxicj5TZSBvcyByYXN0ZXJzIG11bHRpZGltZW5zaW9uYWlzIGRlIGVudHJhZGEgY29udGl2ZXJlbSB2YXJpw6F2ZWlzIGRpZmVyZW50ZXMsIG8gcmFzdGVyIG11bHRpZGltZW5zaW9uYWwgZGUgc2HDrWRhIGNvbnRlcsOhIHRvZGFzIGFzIHZhcmnDoXZlaXMuIDxkaXY+PGJyPlNlIG9zIHJhc3RlcnMgbXVsdGlkaW1lbnNpb25haXMgZGUgZW50cmFkYSBjb250aXZlcmVtIGRpZmVyZW50ZXMgZGltZW5zw7VlcyBvdSB2YWxvcmVzIGRpbWVuc2lvbmFpcywgbyByYXN0ZXIgbXVsdGlkaW1lbnNpb25hbCBkZSBzYcOtZGEgaW5jbHVpcsOhIHRvZGFzIGFzIGRpbWVuc8O1ZXMgZSB2YWxvcmVzIGRpbWVuc2lvbmFpcy4gPGRpdj48YnI+U2Ugb3MgcmFzdGVycyBtdWx0aWRpbWVuc2lvbmFpcyBkZSBlbnRyYWRhIGNvbnRpdmVyZW0gYXMgbWVzbWFzIGRpbWVuc8O1ZXMgZSB2YXJpw6F2ZWlzLCBtYXMgZXh0ZW5zw7VlcyBlc3BhY2lhaXMgZGlmZXJlbnRlcywgbyByYXN0ZXIgbXVsdGlkaW1lbnNpb25hbCBkZSBzYcOtZGEgaW5jbHVpcsOhIGFzIHZhcmnDoXZlaXMgZSBkaW1lbnPDtWVzIGVtIHRvZGFzIGFzIGV4dGVuc8O1ZXMgZXNwYWNpYWlzIGludGVyY2FsYWRhcy48ZGl2Pjxicj5Fc3RhIGZ1bsOnw6NvIHRhbWLDqW0gcG9kZSBzZXIgdXNhZGEgcXVhbmRvIHNlIHRlbSB2w6FyaW9zIHJhc3RlcnMgcXVlIHNlIHByZXRlbmRlIHRyYXRhciBjb21vIHVtIMO6bmljbyBpdGVtLCB0YWwgY29tbyBjYWxjdWxhciBhcyBtZXNtYXMgZXN0YXTDrXN0aWNhcyBwYXJhIHRvZG9zLCBvdSBxdWFuZG8gc2UgZmF6IG8gYmFsYW7Dp28gZGUgY29yIHBhcmEgcXVlIG7Do28gc2VqYSBuZWNlc3PDoXJpbyBmYXplciBvIGJhbGFuw6dvIGRlIGNvciBkZSBjYWRhIGltYWdlbSBzZXBhcmFkYW1lbnRlLiBJc3RvIMOpIMO6dGlsIHF1YW5kbyBzZSB0cmFiYWxoYSBjb20gaW1hZ2VucyBhcm1hemVuYWRhcyBjb21vIG1vc2FpY29zIHNlcGFyYWRvcyBkZXZpZG8gYSByZXN0cmnDp8O1ZXMgZGUgdGFtYW5obyBkZSBmaWNoZWlybzsgZGVzdGEgZm9ybWEsIG9zIG1vc2FpY29zIHNlcsOjbyB0cmF0YWRvcyBjb21vIHBhcnRlIGRhIG1lc21hIGltYWdlbS5cIixcblx0XHRib3VuZGFyeUNsZWFuTmFtZTogXCJMaW1wZXphIGRlIExpbWl0ZXNcIixcblx0XHRib3VuZGFyeUNsZWFuU25pcDogXCJTdWF2aXphIG8gbGltaXRlIGVudHJlIGFzIHpvbmFzLlwiLFxuXHRcdGJvdW5kYXJ5Q2xlYW5EZXNjOiBcIjxwPkEgZnVuw6fDo28gZ2VuZXJhbGl6YSBvdSBzaW1wbGlmaWNhIHJhc3RlcnMgYW8gc3Vhdml6YXIgb3MgbGltaXRlcyBlbnRyZSBhcyB6b25hcy4gQSBmdW7Dp8OjbyBmb3JuZWNlIG9ww6fDtWVzIHBhcmEgY29udHJvbGFyIGNvbW8gYXMgY8OpbHVsYXMgZGFzIHpvbmFzIG5hIGVudHJhZGEgaW5mbHVlbmNpYW0gYSBzdWF2aXphw6fDo28gZSBhIHF1YW50aWRhZGUgZGUgc3Vhdml6YcOnw6NvIHF1ZSBzZXLDoSBhcGxpY2FkYS4gQ2FkYSBjw6lsdWxhIGRlIGVudHJhZGEgw6kgYXZhbGlhZGEgdXNhbmRvIG9zIG9pdG8gdml6aW5ob3MgaW1lZGlhdG9zIGNvcnJlc3BvbmRlbnRlcy48L3A+PHA+TyBwcm9jZXNzbyBkZSBzdWF2aXphw6fDo28gcHJpbWVpcm8gY2xhc3NpZmljYSBhcyBjw6lsdWxhcyB2aXppbmhhcyBwb3IgdW1hIHByaW9yaWRhZGUgcGFydGljdWxhci4gQSBwcmlvcmlkYWRlIGRldGVybWluYSBxdWUgem9uYSBkYXMgY8OpbHVsYXMgdml6aW5oYXMgcG9kZSBzdWJzdGl0dWlyIG8gdmFsb3IgZGEgY8OpbHVsYSBkZSBwcm9jZXNzYW1lbnRvIG5hIHNhw61kYS48L3A+PHA+QSBwcmlvcmlkYWRlIHBvZGUgc2VyIGJhc2VhZGEgbm8gdmFsb3IgZGFzIHpvbmFzIG91IG5vIHRhbWFuaG8gZGFzIHpvbmFzLiBPIHBhcsOibWV0cm8gPHN0cm9uZz5UaXBvIGRlIE9yZGVuYcOnw6NvPC9zdHJvbmc+IGRldGVybWluYSBvIHRpcG8gZGUgb3JkZW5hw6fDo28gYSBzZXIgdXNhZG8uIDwvcD48cD5BIHByZWRlZmluacOnw6NvIDxzdHJvbmc+TsOjbyBvcmRlbmFyPC9zdHJvbmc+IGF2YWxpYSBhIHByaW9yaWRhZGUgY29tIGJhc2Ugbm8gdmFsb3IgZGFzIHpvbmFzLiBBcyBjw6lsdWxhcyBkZSB6b25hcyBjb20gdmFsb3JlcyBtYWlvcmVzIHRlcsOjbyB1bWEgcHJpb3JpZGFkZSBtYWlzIGFsdGEgcGFyYSBzZSBleHBhbmRpcmVtIHBhcmEgem9uYXMgY29tIHZhbG9yZXMgbWVub3Jlcy48L3A+PHA+TyB0YW1hbmhvL8OhcmVhIHRvdGFsIGRhcyB6b25hcyBwb2RlIHNlciB1c2FkbyBwYXJhIGNsYXNzaWZpY2FyIGEgcHJpb3JpZGFkZS4gQ29tIGEgZGVmaW5pw6fDo28gPHN0cm9uZz5EZWNyZXNjZW50ZTwvc3Ryb25nPiwgYXMgem9uYXMgc8OjbyBjbGFzc2lmaWNhZGFzIHBvciB0YW1hbmhvIGVtIG9yZGVtIGRlY3Jlc2NlbnRlLiBBcyB6b25hcyBjb20gw6FyZWFzIHRvdGFpcyBtYWlvcmVzIHRlcsOjbyBwcmlvcmlkYWRlIGRlIGV4cGFuc8OjbyBwYXJhIHpvbmFzIGNvbSDDoXJlYXMgbWVub3Jlcy4gQ29tIGEgZGVmaW5pw6fDo28gPHN0cm9uZz5DcmVzY2VudGU8L3N0cm9uZz4sIG8gb3Bvc3RvIMOpIHZlcmRhZGVpcm86IHpvbmFzIGNvbSDDoXJlYXMgdG90YWlzIG1lbm9yZXMgdGVyw6NvIHByaW9yaWRhZGUgZGUgc2UgZXhwYW5kaXJlbSBwYXJhIHpvbmFzIGNvbSDDoXJlYXMgdG90YWlzIG1haW9yZXMuPC9wPjxwPkEgcXVhbnRpZGFkZSBkZSBzdWF2aXphw6fDo28gw6kgY29udHJvbGFkYSBwZWxvIHBhcsOibWV0cm8gPHN0cm9uZz5FeGVjdXRhciBleHBhbnPDo28gZSByZWR1w6fDo28gZHVhcyB2ZXplczwvc3Ryb25nPiwgcXVlIGRldGVybWluYSBvIG7Dum1lcm8gZGUgdmV6ZXMgcXVlIG8gcHJvY2Vzc28gZGUgZXhwYW5zw6NvIGUgcmVkdcOnw6NvIHNlcsOhIHJlYWxpemFkby48L3A+PHA+Q29tIGEgZGVmaW5pw6fDo28gbsOjbyBzZWxlY2lvbmFkYSwgbyBwcm9jZXNzbyBkZSBleHBhbnPDo28gZSByZWR1w6fDo28gw6kgZXhlY3V0YWRvIHVtYSB2ZXouIENvbSBhIGRlZmluacOnw6NvIHNlbGVjaW9uYWRhLCBvIHByb2Nlc3NvIGRlIGV4cGFuc8OjbyBlIHJlZHXDp8OjbyDDqSByZWFsaXphZG8gZHVhcyB2ZXplcywgcmVzdWx0YW5kbyBudW0gZ3JhdSBhZGljaW9uYWwgZGUgc3Vhdml6YcOnw6NvIGRvcyBsaW1pdGVzIGRhIHpvbmEuPC9wPjxwPlNlIG9zIHZhbG9yZXMgZGUgdG9kYXMgYXMgb2l0byBjw6lsdWxhcyB2aXppbmhhcyBmb3JlbSBpZ3VhaXMgYW9zIGRhIGPDqWx1bGEgZGUgcHJvY2Vzc2FtZW50bywgYSBjw6lsdWxhIGRlIHNhw61kYSBtYW50ZXLDoSBvIHZhbG9yIGRhIGPDqWx1bGEgZGUgZW50cmFkYS48L3A+XCIsXG5cdFx0cHJlZGljdFVzaW5nUmVncmVzc2lvbk5hbWU6IFwiUHJldmVyIENvbSBSZWdyZXNzw6NvXCIsXG5cdFx0cHJlZGljdFVzaW5nUmVncmVzc2lvblNuaXA6IFwiQ2FsY3VsYSB1bSByYXN0ZXIgcHJldmlzdG8gY29tIGJhc2UgZW0gZW50cmFkYXMgZGUgZGFkb3MgcmFzdGVyIGUgbnVtIG1vZGVsbyBkZSByZWdyZXNzw6NvLiBPIG1vZGVsbyBkZSByZWdyZXNzw6NvIMOpIGEgc2HDrWRhIGRhIGZlcnJhbWVudGEgZGUgZ2VvcHJvY2Vzc2FtZW50byByYXN0ZXIgPHN0cm9uZz5Nb2RlbG8gZGUgUmVncmVzc8OjbyBUcmFpbiBSYW5kb20gVHJlZXMgKFByZXBhcmFyIMOBcnZvcmVzIEFsZWF0w7NyaWFzKTwvc3Ryb25nPi5cIixcblx0XHRwcmVkaWN0VXNpbmdSZWdyZXNzaW9uRGVzYzogXCI8cD5PIG1vZGVsbyBkZSByZWdyZXNzw6NvIMOpIGRlZmluaWRvIG51bSBmaWNoZWlybyBkZSBkZWZpbmnDp8OjbyBkZSByZWdyZXNzw6NvIEVzcmkgKC5lY2QpLiBDb250w6ltIHRvZGFzIGFzIGluZm9ybWHDp8O1ZXMgcGFyYSB1bSBjb25qdW50byBkZSBkYWRvcyBlc3BlY8OtZmljbyBvdSBjb25qdW50byBkZSBjb25qdW50b3MgZGUgZGFkb3MgZSBvIG1vZGVsbyBkZSByZWdyZXNzw6NvIGUgw6kgZ2VyYWRvIHBlbGEgZmVycmFtZW50YSBkZSBnZW9wcm9jZXNzYW1lbnRvIHJhc3RlciA8c3Ryb25nPk1vZGVsbyBkZSBSZWdyZXNzw6NvIFRyYWluIFJhbmRvbSBUcmVlcyAoUHJlcGFyYXIgw4Fydm9yZXMgQWxlYXTDs3JpYXMpPC9zdHJvbmc+LjwvcD48cD5BIGVudHJhZGEgcG9kZSBzZXIgdW1hIMO6bmljYSBiYW5kYSwgdW1hIG11bHRpYmFuZGEgb3UgdW0gcmFzdGVyIG11bHRpZGltZW5zaW9uYWwgb3UgdW1hIGxpc3RhIGRlc3RlcyB0aXBvcy4gT3MgdGlwb3MgZGUgcmFzdGVycyBkZSBlbnRyYWRhIHTDqm0gZGUgc2VyIGRvIG1lc21vIHRpcG8gZGUgcmFzdGVyIGZvcm1hZG8gcGVsbyBtb2RlbG8gZGUgcmVncmVzc8Ojby48L3A+PHVsPjxsaT5RdWFuZG8gYSBlbnRyYWRhIMOpIHVtIHJhc3RlciBtdWx0aWJhbmRhLCBjYWRhIGJhbmRhIMOpIHRyYXRhZGEgY29tbyB1bWEgdmFyacOhdmVsIGRlIHByZXZpc8Ojby4gQXMgYmFuZGFzIHTDqm0gZGUgZXN0YXIgbmEgbWVzbWEgb3JkZW0gcXVlIGEgZW50cmFkYSBtdWx0aWJhbmRhIHBhcmEgYSBmZXJyYW1lbnRhIGRlIGZvcm1hw6fDo28gZG8gbW9kZWxvIGRlIHJlZ3Jlc3PDo28uPC9saT48bGk+UXVhbmRvIGEgZW50cmFkYSDDqSB1bSByYXN0ZXIgbXVsdGlkaW1lbnNpb25hbCwgY2FkYSB2YXJpw6F2ZWwgw6kgdHJhdGFkYSBjb21vIHVtYSB2YXJpw6F2ZWwgZGUgcHJldmlzw6NvIGUgYSB2YXJpw6F2ZWwgdGVtIGRlIHNlciBkZSBiYW5kYSDDum5pY2EgZSB0ZXIgdW1hIGRpbWVuc8OjbyBkZSB0ZW1wby4gQSBvcmRlbSBlIG9zIG5vbWVzIGRhcyB2YXJpw6F2ZWlzIHTDqm0gZGUgc2VyIGlndWFpcyBhb3MgZGEgZW50cmFkYSBxdWFuZG8gbyBtb2RlbG8gZGUgcmVncmVzc8OjbyBmb2kgZm9ybWFkby4gQSBzYcOtZGEgw6kgdW0gcmFzdGVyIG11bHRpZGltZW5zaW9uYWwuPC9saT48bGk+QSBlbnRyYWRhIHBvZGUgc2VyIHVtYSBsaXN0YSBkZSBpdGVucy4gTyBuw7ptZXJvIGUgYSBvcmRlbSBkb3MgaXRlbnMgdMOqbSBkZSBjb3JyZXNwb25kZXIgw6AgZW50cmFkYSBxdWFuZG8gbyBtb2RlbG8gZGUgcmVncmVzc8OjbyBmb2kgZm9ybWFkby48L2xpPjwvdWw+XCIsXG5cdFx0ZGltZW5zaW9uYWxNb3ZpbmdTdGF0aXN0aWNzTmFtZTogXCJFc3RhdMOtc3RpY2FzIGRlIE1vdmltZW50byBEaW1lbnNpb25hbFwiLFxuXHRcdGRpbWVuc2lvbmFsTW92aW5nU3RhdGlzdGljc1NuaXA6IFwiQ2FsY3VsYSBlc3RhdMOtc3RpY2FzIGR1cmFudGUgdW1hIGphbmVsYSBlbSBtb3ZpbWVudG8gZW0gZGFkb3MgbXVsdGlkaW1lbnNpb25haXMgYW8gbG9uZ28gZGUgdW1hIGRpbWVuc8OjbyBlc3BlY2lmaWNhZGEuXCIsXG5cdFx0ZGltZW5zaW9uYWxNb3ZpbmdTdGF0aXN0aWNzRGVzYzogXCI8cD5BIGZ1bsOnw6NvIEVzdGF0w61zdGljYXMgZGUgTW92aW1lbnRvIERpbWVuc2lvbmFsIGNhbGN1bGEgdsOhcmlhcyBlc3RhdMOtc3RpY2FzIG51bWEgamFuZWxhIHByZWRlZmluaWRhIHBhcmEgdG9kb3Mgb3MgdmFsb3JlcyBkZSBkaW1lbnPDo28gYW8gbG9uZ28gZGUgdW1hIGRpbWVuc8Ojby4gRXN0YSBmdW7Dp8OjbyByZWNlYmUgdW1hIGNhbWFkYSByYXN0ZXIgbXVsdGlkaW1lbnNpb25hbCBjb21vIGVudHJhZGEgZSBjcmlhIHVtYSBjYW1hZGEgcmFzdGVyIG11bHRpZGltZW5zaW9uYWwgY29tbyBzYcOtZGEgY29tIG8gbWVzbW8gdGFtYW5obyBkaW1lbnNpb25hbCBkYSBjYW1hZGEgZGUgZW50cmFkYS48L3A+PHA+UG9kZSBlc3BlY2lmaWNhciB1bWEgZGltZW5zw6NvIHBhcmEgYSBxdWFsIG9zIHZhbG9yZXMgZGUgZGltZW5zw6NvIHPDo28gY29uc2lkZXJhZG9zIGR1cmFudGUgbyBjw6FsY3Vsby4gUG9yIHByZWRlZmluacOnw6NvLCBhIGZ1bsOnw6NvIGNhbGN1bGEgYW8gbG9uZ28gZGEgcHJpbWVpcmEgZGltZW5zw6NvIG7Do28gZXNwYWNpYWwuIFRhbWLDqW0gcG9kZSBlc3BlY2lmaWNhciB1bSB0YW1hbmhvIGRlIGphbmVsYSBhbyBlc3BlY2lmaWNhciBvcyBwYXLDom1ldHJvcyBKYW5lbGEgQW50ZXJpb3IgZSBKYW5lbGEgUG9zdGVyaW9yLjwvcD48cD5RdWFuZG8gbyBUaXBvIGRlIEVzdGF0w61zdGljYSDDqSBkZWZpbmlkbyBjb21vIFBlcmNlbnRpbCwgb3MgcGFyw6JtZXRyb3MgVmFsb3IgZGUgUGVyY2VudGlsIGUgVGlwbyBkZSBJbnRlcnBvbGHDp8OjbyBkZSBQZXJjZW50aWwgZmljYW0gZGlzcG9uw612ZWlzLiBQb2RlIHVzYXIgZXN0ZXMgcGFyw6JtZXRyb3MgcGFyYSBlc3BlY2lmaWNhciBvIHBlcmNlbnRpbCBhIHNlciBjYWxjdWxhZG8gZSBlc2NvbGhlciBvIHRpcG8gZGUgaW50ZXJwb2xhw6fDo28gYSBzZXIgdXNhZG8sIHJlc3BldGl2YW1lbnRlLiBRdWFuZG8gbyBUaXBvIGRlIEVzdGF0w61zdGljYSDDqSBkZWZpbmlkbyBjb21vIE3DqWRpYSBDaXJjdWxhciwgbyBwYXLDom1ldHJvIFZhbG9yIGRlIE1vbGRhZ2VtIENpcmN1bGFyIGZpY2EgZGlzcG9uw612ZWwuIE8gdmFsb3IgZGUgbW9sZGFnZW0gY2lyY3VsYXIgw6kgdXNhZG8gcGFyYSBjb252ZXJ0ZXIgdW0gdmFsb3IgbGluZWFyIG5vIGludGVydmFsbyBkZSB1bWEgZGV0ZXJtaW5hZGEgbcOpZGlhIGNpcmN1bGFyLjwvcD5cIixcblx0XHR0ZXJyYWluRmxhdHRlbkZ1bmN0aW9uTmFtZTogXCJBcGxhbmFtZW50byBkZSBUZXJyZW5vXCIsXG5cdFx0dGVycmFpbkZsYXR0ZW5GdW5jdGlvblNuaXA6IFwiQ29ycmlnZSBvcyBkYWRvcyBkZSBlbnRyYWRhIGRvIHJhZGFyIGRlIGFiZXJ0dXJhIHNpbnTDqXRpY2EgKFNBUikgcGFyYSBkaXN0b3LDp8O1ZXMgcmFkaW9tw6l0cmljYXMgZGV2aWRhcyDDoCB0b3BvZ3JhZmlhLlwiLFxuXHRcdHRlcnJhaW5GbGF0dGVuRnVuY3Rpb25EZXNjOiBcIjxwPkEgZnVuw6fDo28gcmFzdGVyIEFwbGFuYW1lbnRvIGRlIFRlcnJlbm8gY29ycmlnZSBvcyBkYWRvcyBkZSBlbnRyYWRhIGRvIHJhZGFyIGRlIGFiZXJ0dXJhIHNpbnTDqXRpY2EgKFNBUikgcGFyYSBkaXN0b3LDp8O1ZXMgcmFkaW9tw6l0cmljYXMgZGV2aWRhcyDDoCB0b3BvZ3JhZmlhLjwvcD48cD5PcyBkYWRvcyBkZSBlbnRyYWRhIGRvIHJhZGFyIHTDqm0gZGUgc2VyIHByaW1laXJvIGNhbGlicmFkb3MgcGFyYSBiZXRhLXplcm8uIFV0aWxpemUgYSBmZXJyYW1lbnRhIEFwbGljYXIgQ2FsaWJyYcOnw6NvIFJhZGlvbcOpdHJpY2EgcGFyYSBjYWxpYnJhciBvcyBkYWRvcyBkZSByYWRhciBwYXJhIGJldGEtemVyby48L3A+PHA+U2UgYSBlbnRyYWRhIGRlIERFTSBuw6NvIGFicmFuZ2VyIG8gY29uanVudG8gZGUgZGFkb3MgU0FSIGNvbXBsZXRvLCBhIGZlcnJhbWVudGEgaXLDoSBwcm9kdXppciB2YWxvcmVzIE5vRGF0YSBwYXJhIG9zIHDDrXhlaXMgZm9yYSBkYSBleHRlbnPDo28gZGUgREVNIHBhcmEgYmV0YS16ZXJvLCBzaWdtYS16ZXJvLCDDoXJlYSBkZSBkaXNwZXJzw6NvIGUgc2HDrWRhcyBkZSBkaXN0b3LDp8OjbyBnZW9tw6l0cmljYS4gUGFyYSBhIHNhw61kYSBkYSBtw6FzY2FyYSBkZSBkaXN0b3LDp8OjbyBnZW9tw6l0cmljYSwgYSBmZXJyYW1lbnRhIGlyw6EgcHJvZHV6aXIgdmFsb3JlcyBpbmRldGVybWluYWRvcyBwYXJhIG9zIHDDrXhlaXMgZm9yYSBkYSBleHRlbnPDo28gZGUgREVNLjwvcD48cD5BIGVudHJhZGEgZGUgREVNIHRlbSBkZSBlc3RhciBubyBzaXN0ZW1hIGRlIGNvb3JkZW5hZGFzIGdlb2dyw6FmaWNhcyBXR1MgMTk4NCAoRVBTRzo0MzI2KS48L3A+XCIsXG5cdFx0Y3JlYXRlQ29sb3JDb21wb3NpdGVGdW5jdGlvbk5hbWU6IFwiQ3JpYXIgQ29tcG9zacOnw6NvIGRlIENvcmVzXCIsXG5cdFx0Y3JlYXRlQ29sb3JDb21wb3NpdGVGdW5jdGlvblNuaXA6IFwiQ3JpYSB1bSByYXN0ZXIgZGUgdHLDqnMgYmFuZGFzIGEgcGFydGlyIGRlIHVtIGNvbmp1bnRvIGRlIGRhZG9zIHJhc3RlciBtdWx0aWJhbmRhIG5vIHF1YWwgY2FkYSBiYW5kYSBwb2RlIHV0aWxpemFyIHVtIGPDoWxjdWxvIGFsZ8OpYnJpY28gYmFzZWFkbyBlbSDDoWxnZWJyYSBkZSBiYW5kYS5cIixcblx0XHRjcmVhdGVDb2xvckNvbXBvc2l0ZUZ1bmN0aW9uRGVzYzogXCI8cD5BIGZ1bsOnw6NvIHJhc3RlciBDcmlhciBDb21wb3Npw6fDo28gZGUgQ29yZXMgY3JpYSB1bSByYXN0ZXIgZGUgdHLDqnMgYmFuZGFzIGEgcGFydGlyIGRlIHVtIGNvbmp1bnRvIGRlIGRhZG9zIHJhc3RlciBtdWx0aWJhbmRhIG5vIHF1YWwgY2FkYSBiYW5kYSBwb2RlIHV0aWxpemFyIHVtIGPDoWxjdWxvIGFsZ8OpYnJpY28gYmFzZWFkbyBlbSDDoWxnZWJyYSBkZSBiYW5kYS48L3A+PHA+QW8gZGVmaW5pciB1bSBhbGdvcml0bW8gYXJpdG3DqXRpY28gZGUgYmFuZGEsIHBvZGUgaW50cm9kdXppciB1bWEgZsOzcm11bGEgYWxnw6licmljYSBkZSB1bWEgbGluaGEgcGFyYSBjYWRhIGV4cHJlc3PDo28gcGFyYSBjcmlhciB1bWEgc2HDrWRhIG11bHRpYmFuZGEuIE9zIG9wZXJhZG9yZXMgc3Vwb3J0YWRvcyBzw6NvIHVuw6FyaW9zOiBtYWlzICgrKSwgbWVub3MgKC0pLCBtdWx0aXBsaWNhw6fDo28gKCopIGUgZGl2aXPDo28gKC8pLjwvcD48cD5BbyB1dGlsaXphciB1bSBJRCBkZSBiYW5kYSBudW1hIGV4cHJlc3PDo28sIGlkZW50aWZpcXVlIGEgYmFuZGEgYXRyYXbDqXMgZG8gcHJlZml4byBCIG91IGIgcGFyYSBvIG7Dum1lcm8gZGUgYmFuZGEuPC9wPjxwPlVtYSBjb21iaW5hw6fDo28gZGUgYmFuZGEgY29tdW0gdXRpbGl6YWRhIHBhcmEgbyByYWRhciBkZSBhYmVydHVyYSBzaW50w6l0aWNhIChTQVIpIGVtIHVuaWRhZGVzIGxpbmVhcmVzIMOpIFZWIHBhcmEgdmVybWVsaG8sIFZIIHBhcmEgdmVyZGUgZSBWVi9WSCBwYXJhIGF6dWwuIFNlIG9zIGRhZG9zIGRlIGVudHJhZGEgZXN0aXZlcmVtIGVtIGRlY2liw6lpcywgYSBjb21iaW5hw6fDo28gZGUgYmFuZGFzIGRldmUgc2VyIFZWIHBhcmEgdmVybWVsaG8sIFZIIHBhcmEgdmVyZGUgZSBWVi1WSCBwYXJhIGF6dWwuPC9wPlwiLFxuXHRcdHN1cmZhY2VQYXJhbWV0ZXJzTmFtZTogXCJQYXLDom1ldHJvcyBkZSBTdXBlcmbDrWNpZVwiLFxuXHRcdHN1cmZhY2VQYXJhbWV0ZXJzU25pcDogXCJEZXRlcm1pbmEgcGFyw6JtZXRyb3MgZGUgdW0gcmFzdGVyIGRlIHN1cGVyZsOtY2llIGNvbW8gYXNwZXRvLCBpbmNsaW5hw6fDo28gZSB2w6FyaW9zIHRpcG9zIGRlIGN1cnZhdHVyYXMgYXRyYXbDqXMgZGUgbcOpdG9kb3MgZ2VvZMOpc2ljb3MuXCIsXG5cdFx0c3VyZmFjZVBhcmFtZXRlcnNEZXNjOiBcIjxwPkEgZnVuw6fDo28gUGFyw6JtZXRyb3MgZGUgU3VwZXJmw61jaWUgZGV0ZXJtaW5hIHBhcsOibWV0cm9zIGRlIHVtIHJhc3RlciBkZSBzdXBlcmbDrWNpZSBjb21vIGFzcGV0bywgaW5jbGluYcOnw6NvIGUgdsOhcmlvcyB0aXBvcyBkZSBjdXJ2YXR1cmFzIGF0cmF2w6lzIGRlIG3DqXRvZG9zIGdlb2TDqXNpY29zLjwvcD48cD5Fc3RhIGZ1bsOnw6NvIHBvZGUgc2VyIHV0aWxpemFkYSBwYXJhIGFzIHNlZ3VpbnRlcyBhcGxpY2HDp8O1ZXM6PC9wPjx1bD48bGk+Q2FsY3VsYXIgYXNwZXRvIGUgaW5jbGluYcOnw6NvIGF0cmF2w6lzIGRlIG3DqXRvZG9zIGdlb2TDqXNpY29zLjwvbGk+PGxpPkNhbGN1bGFyIGRpZmVyZW50ZXMgdGlwb3MgZGUgY3VydmF0dXJhcyBhIHBhcnRpciBkZSB1bSByYXN0ZXIgZGUgc3VwZXJmw61jaWUgZGUgZW50cmFkYSwgcG9yIGV4ZW1wbG8sIDxzdHJvbmc+Q3VydmF0dXJhIHRhbmdlbmNpYWwgKGNvbnRvcm5vIG5vcm1hbCk8L3N0cm9uZz4gcXVlIGNhcmFjdGVyaXphIGEgY29udmVyZ8OqbmNpYSB0b3BvZ3LDoWZpY2EgZSBhIGRpdmVyZ8OqbmNpYSBkbyBmbHV4byBuYSBzdXBlcmbDrWNpZS48L2xpPjwvdWw+XCIsXG5cdFx0bGVhc3RDb3N0Q29ycmlkb3JOYW1lOiBcIkNvcnJlZG9yIGRlIE1lbm9yIEN1c3RvXCIsXG5cdFx0bGVhc3RDb3N0Q29ycmlkb3JTbmlwOiBcIkNhbGN1bGEgYSBzb21hIGRlIGRvaXMgcmFzdGVycyBkZSBkaXN0w6JuY2lhIGRlIGN1c3RvIGFjdW11bGFkbyBjb20gYSBvcMOnw6NvIGRlIGFwbGljYXIgdW0gbGltaWFyIGJhc2VhZG8gbmEgcGVyY2VudGFnZW0gb3Ugbm8gY3VzdG8gYWN1bXVsYWRvLlwiLFxuXHRcdGxlYXN0Q29zdENvcnJpZG9yRGVzYzogXCI8cD5PcyByYXN0ZXJzIGRlIGVudHJhZGEgZGV2ZW0gc2VyIHJhc3RlcnMgZGUgYWN1bXVsYcOnw6NvIGRlIGRpc3TDom5jaWEgZSByYXN0ZXJzIGRlIGRpcmXDp8OjbyBkZSByZXRvcm5vIHJlc3VsdGFudGVzIGRhIGZ1bsOnw6NvIDxzdHJvbmc+QWN1bXVsYcOnw6NvIGRlIERpc3TDom5jaWE8L3N0cm9uZz4gb3UgPHN0cm9uZz5BdHJpYnVpw6fDo28gZGUgRGlzdMOibmNpYTwvc3Ryb25nPi4gRXN0ZXMgZGV2ZW0gYmFzZWFyLXNlIG5hIGRpc3TDom5jaWEgZGUgY3VzdG8gZSBkZXZlbSBzZXIgdXRpbGl6YWRvcyBvcyBtZXNtb3MgcGFyw6JtZXRyb3MgYW8gY3JpYXIgYXMgY2FtYWRhcyBwYXJhIGNhZGEgZm9udGUuIE5lbmh1bSBwYXLDom1ldHJvIHF1ZSBkZXBlbmRhIGRhIGRpcmVjaW9uYWxpZGFkZSAoZmF0b3IgaG9yaXpvbnRhbCwgZmF0b3IgdmVydGljYWwgZSBkaXJlw6fDo28gZGUgdmlhZ2VtKSBkZXZlIHNlciB1dGlsaXphZG8gbmEgY3JpYcOnw6NvIGRlc3RlcyByYXN0ZXIuPC9wPjxwPk9zIHZhbG9yZXMgbm8gcmFzdGVyIGRlIGNvcnJlZG9yIGRlIHNhw61kYSBzw6NvIGEgc29tYSBkbyBjdXN0byBhY3VtdWxhZG8gcGFyYSBhbGNhbsOnYXIgdW1hIGRldGVybWluYWRhIGxvY2FsaXphw6fDo28gY29tIGFzIG1lc21hcyB1bmlkYWRlcyBxdWUgb3MgcmFzdGVycyBkZSBkaXN0w6JuY2lhIGRlIGN1c3RvIGFjdW11bGFkbyBkZSBlbnRyYWRhLjwvcD48cD5TZSB1bSB2YWxvciBkZSA8c3Ryb25nPkxpbWlhcjwvc3Ryb25nPiBlc3BlY2lmaWNhZG8gZm9yIHN1cGVyaW9yIGFvIGN1c3RvIGFjdW11bGFkbyBtw6F4aW1vIHF1YW5kbyBvcyBkb2lzIHJhc3RlcnMgZGUgYWN1bXVsYcOnw6NvIGRlIGRpc3TDom5jaWEgc8OjbyBzb21hZG9zLCBvIHJhc3RlciBkZSBjb3JyZWRvciBkZSBzYcOtZGEgaXLDoSBjb2JyaXIgYSBtZXNtYSDDoXJlYSBxdWUgb3MgcmFzdGVycyBkZSBhY3VtdWxhw6fDo28gZGUgZW50cmFkYS48L3A+PHA+U2UgdW0gdmFsb3IgZGUgbGltaWFyIGVzcGVjaWZpY2FkbyBmb3IgaW5mZXJpb3IgYW8gdmFsb3IgbcOtbmltbyBubyByYXN0ZXIgZGUgY29ycmVkb3IsIMOpIGRldm9sdmlkYSB1bWEgbWVuc2FnZW0gZGUgYXZpc28gZSBvIHJhc3RlciBkZSBzYcOtZGEgZXN0YXLDoSB2YXppby48L3A+PHA+TyByYXN0ZXIgZGUgY29ycmVkb3IgZGUgc2HDrWRhIHBvZGUgY29udGVyIGPDqWx1bGFzIGNvbSBjdXN0b3MgYWN1bXVsYWRvcyBsaWdlaXJhbWVudGUgc3VwZXJpb3JlcyBhbyB2YWxvciBsaW1pdGUuIElzdG8gZGV2ZS1zZSBhbyBmYWN0byBkZSBvcyByYXN0ZXJzIGRlIGRpcmXDp8OjbyBkZSByZXRvcm5vIHV0aWxpemFyZW0gY8OpbHVsYXMgw6BzIHF1YWlzIGZvcmFtIGF0cmlidcOtZG9zIGN1c3RvcyBsaWdlaXJhbWVudGUgc3VwZXJpb3JlcyBhbyBsaW1pYXIgcGFyYSBsaWdhciBjw6lsdWxhcyBkZXNjb25lY3RhZGFzIGFvIGNvcnJlZG9yLjwvcD5cIixcblx0XHRnZW9tZXRyaWNNZWRpYW5OYW1lOiBcIk1lZGlhbmEgR2VvbcOpdHJpY2FcIixcblx0XHRnZW9tZXRyaWNNZWRpYW5TbmlwOiBcIkEgZnVuw6fDo28gTWVkaWFuYSBHZW9tw6l0cmljYSBjYWxjdWxhIGEgbWVkaWFuYSBnZW9tw6l0cmljYSBkb3MgcMOteGVpcyBudW1hIHPDqXJpZSB0ZW1wb3JhbCBkZSBpbWFnZW5zIG11bHRpYmFuZGEuXCIsXG5cdFx0Z2VvbWV0cmljTWVkaWFuRGVzYzogXCI8cD5Fc3RhIGZ1bsOnw6NvIHJlZHV6IG8gcnXDrWRvIGUgb3MgdmFsb3JlcyBhdMOtcGljb3MgZW0gaW1hZ2VucyBkZSBzw6lyaWVzIHRlbXBvcmFpcywgY2FsY3VsYW5kbyB1bSBww614ZWwgbWVkaWFubyBnZW9tw6l0cmljbyBwYXJhIGNhZGEgY29uanVudG8gZGUgcMOteGVpcyBuYSBwaWxoYSBkZSBpbWFnZW5zLiBPIGFsZ29yaXRtbyBtYW50w6ltIGFzIHJlbGHDp8O1ZXMgZXNwZWN0cmFpcyBlbnRyZSBhcyBiYW5kYXMgbm9zIGVzcGVjdHJvcyBkZSBww614ZWlzLCBwZWxvIHF1ZSBvIHJlc3VsdGFkbyBwb2RlIHNlciB1dGlsaXphZG8gZW0gYW7DoWxpc2VzLCB0YWlzIGNvbW8gw61uZGljZXMgZGUgdmVnZXRhw6fDo28uPC9wPjxwPkFzIG51dmVucyBlIHNvbWJyYXMgZGV2ZW0gc2VyIG1hc2NhcmFkYXMgY29tIGEgYmFuZGEgUUEgZG8gY29uanVudG8gZGUgZGFkb3MgYW50ZXMgZGUgYXBsaWNhciBlc3RhIGZ1bsOnw6NvLjwvcD48cD5TZSBhIGltYWdlbSBkZSBlbnRyYWRhIGZvciBkZSBwb250byBmbHV0dWFudGUsIHRhbCBjb21vIGEgcmVmbGV0w6JuY2lhIGRlIHN1cGVyZsOtY2llIGNvbSB2YWxvcmVzIGVudHJlIDAgZSAxLCB1bSB2YWxvciBlcHNpbG9uIGRlIDAsMDAxIGRldmVyw6EgcHJvZHV6aXIgcmVzdWx0YWRvcyBkZSBxdWFsaWRhZGUuPC9wPlwiXG5cdH0sXG5cdHJmeEFyZ3M6IHtcblx0XHRyYXN0ZXJOYW1lOiBcIlJhc3RlclwiLFxuXHRcdGNvbG9yU2NoZW1lVHlwZU5hbWU6IFwiVGlwbyBkZSBFc3F1ZW1hIGRlIENvcmVzXCIsXG5cdFx0Y29sb3JtYXBOYW1lOiBcIk1hcGEgZGUgQ29yZXNcIixcblx0XHRjb2xvcm1hcE5hbWVOYW1lOiBcIk5vbWUgZG8gTWFwYSBkZSBDb3Jlc1wiLFxuXHRcdGNvbG9yUmFtcE5hbWU6IFwiUmFtcGEgZGUgQ29yZXNcIixcblx0XHRjb250cmFzdE9mZnNldE5hbWU6IFwiRGVzdmlvIGRlIENvbnRyYXN0ZVwiLFxuXHRcdGJyaWdodG5lc3NPZmZzZXROYW1lOiBcIkRlc3ZpbyBkZSBMdW1pbm9zaWRhZGVcIixcblx0XHRtZXRob2ROYW1lOiBcIk3DqXRvZG9cIixcblx0XHRiYW5kTmFtZXNOYW1lOiBcIk5vbWVzIGRlIEJhbmRhc1wiLFxuXHRcdGJhbmRXYXZlbGVuZ3Roc05hbWU6IFwiQ29tcHJpbWVudG9zIGRlIE9uZGEgZGUgQmFuZGFzXCIsXG5cdFx0YmFuZElkc05hbWU6IFwiSWRzIGRlIEJhbmRhc1wiLFxuXHRcdG1pc3NpbmdCYW5kQWN0aW9uTmFtZTogXCJBw6fDo28gZGUgQmFuZGEgZW0gRmFsdGFcIixcblx0XHRjb252ZXJzaW9uUGFyYW1ldGVyc05hbWU6IFwiUGFyw6JtZXRyb3MgZSBDb252ZXJzw6NvXCIsXG5cdFx0aGlsbHNoYWRlVHlwZU5hbWU6IFwiVGlwbyBkZSBTb21icmFcIixcblx0XHRhemltdXRoTmFtZTogXCJBemltdXRlXCIsXG5cdFx0YWx0aXR1ZGVOYW1lOiBcIkFsdGl0dWRlOlwiLFxuXHRcdHNsb3BlVHlwZU5hbWU6IFwiRGltZW5zaW9uYXJcIixcblx0XHR6RmFjdG9yTmFtZTogXCJGYXRvciBaXCIsXG5cdFx0UFNQb3dlck5hbWU6IFwiUG90w6puY2lhIFRhbWFuaG8gZGUgUGl4ZWlzXCIsXG5cdFx0UFNaRmFjdG9yTmFtZTogXCJGYXRvciBUYW1hbmhvIGRlIFBpeGVpc1wiLFxuXHRcdHJlbW92ZUVkZ2VFZmZlY3ROYW1lOiBcIkRlc2F0aXZhciBpbnRlcnBvbGHDp8OjbyBlZGdlIHBpeGVsIHByZWRlZmluaWRhXCIsXG5cdFx0ZnJvbVVuaXROYW1lOiBcIkEgcGFydGlyIGRlIFVuaWRhZGVcIixcblx0XHR0b1VuaXROYW1lOiBcIlBhcmEgVW5pZGFkZVwiLFxuXHRcdHJhc3RlclR5cGVOYW1lOiBcIlRpcG9cIixcblx0XHRtaW5OYW1lOiBcIk3DrW5pbW8gZGUgU2HDrWRhXCIsXG5cdFx0bWF4TmFtZTogXCJNw6F4aW1vIGRlIFNhw61kYVwiLFxuXHRcdG1pblBlcmNlbnROYW1lOiBcIlBlcmNlbnRhZ2VtIGRlIFJlY29ydGUgTcOtbmltYVwiLFxuXHRcdG1heFBlcmNlbnROYW1lOiBcIlBlcmNlbnRhZ2VtIGRlIFJlY29ydGUgTcOheGltYVwiLFxuXHRcdG51bWJlck9mU3RhbmRhcmREZXZpYXRpb25OYW1lOiBcIk7Dum1lcm8gZGUgZGVzdmlvcyBwYWRyw6NvXCIsXG5cdFx0c2lnbW9pZFN0cmVuZ3RoTGV2ZWxOYW1lOiBcIk7DrXZlbCBkZSBGb3LDp2EgZGUgU2lnbcOzaWRlXCIsXG5cdFx0ZXN0aW1hdGVTdGF0c0hpc3RvZ3JhbU5hbWU6IFwiRXN0aW1hciBFc3RhdMOtc3RpY2FzXCIsXG5cdFx0RFJBTmFtZTogXCJBanVzdGFtZW50byBkZSBJbnRlcnZhbG8gRGluw6JtaWNvXCIsXG5cdFx0c3RhdGlzdGljc05hbWU6IFwiRXN0YXTDrXN0aWNhc1wiLFxuXHRcdGhpc3RvZ3JhbXNOYW1lOiBcIkhpc3RvZ3JhbWFzXCIsXG5cdFx0c3RhdGlzdGljc0hpc3RvZ3JhbU5hbWU6IFwiRGVmaW5pciBFc3RhdMOtc3RpY2FzIGUgSGlzdG9ncmFtYVwiLFxuXHRcdGNvbXB1dGVHYW1tYU5hbWU6IFwiR2FtYSBBdXRvbcOhdGljYVwiLFxuXHRcdHVzZUdhbW1hTmFtZTogXCJVdGlsaXphciBHYW1hXCIsXG5cdFx0Z2FtbWFOYW1lOiBcIkdhbWFcIixcblx0XHRpbnB1dE5hbWVzTmFtZTogXCJOb21lc1wiLFxuXHRcdGV4cHJlc3Npb25OYW1lOiBcIkV4cHJlc3PDo29cIixcblx0XHRjZWxsc2l6ZVR5cGVOYW1lOiBcIlRpcG8gZGUgVGFtYW5obyBkZSBDw6lsdWxhXCIsXG5cdFx0ZXh0ZW50VHlwZU5hbWU6IFwiVGlwbyBkZSBFeHRlbnPDo29cIixcblx0XHRjbGFzc2lmaWVyRGVmaW5pdGlvbkZpbGVOYW1lOiBcIkZpY2hlaXJvIGRlIERlZmluacOnw6NvIGQgRW50cmFkYVwiLFxuXHRcdHJhc3RlcjFOYW1lOiBcIlJhc3RlcjFcIixcblx0XHRyYXN0ZXIyTmFtZTogXCJSYXN0ZXIyXCIsXG5cdFx0cmFzdGVyM05hbWU6IFwiUmFzdGVyM1wiLFxuXHRcdHRydWVSYXN0ZXJOYW1lOiBcIlJhc3RlciBWZXJkYWRlaXJvXCIsXG5cdFx0ZmFsc2VSYXN0ZXJOYW1lOiBcIlJhc3RlciBGYWxzb1wiLFxuXHRcdG5vRGF0YUludGVycHJldGF0aW9uTmFtZTogXCJJbnRlcnByZXRhw6fDo28gTm9EYXRhXCIsXG5cdFx0bm9EYXRhVmFsdWVzTmFtZTogXCJWYWxvcmVzIE5vRGF0YVwiLFxuXHRcdGluY2x1ZGVkUmFuZ2VzTmFtZTogXCJJbnRlcnZhbG9zIEluY2x1w61kb3NcIixcblx0XHRjdXJ2YXR1cmVUeXBlTmFtZTogXCJUaXBvIGRlIEN1cnZhdHVyYVwiLFxuXHRcdHJhc3RlcnNOYW1lOiBcIlJhc3RlcnNcIixcblx0XHRhdHRyaWJ1dGVUYWJsZU5hbWU6IFwiVGFiZWxhXCIsXG5cdFx0YXR0cmlidXRlVGFibGVUeXBlTmFtZTogXCJUaXBvIGRlIFRhYmVsYVwiLFxuXHRcdHJvd3NOYW1lOiBcIk7Dum1lcm8gZGUgTGluaGFzXCIsXG5cdFx0Y29sdW1uc05hbWU6IFwiTsO6bWVybyBkZSBDb2x1bmFzXCIsXG5cdFx0a2VybmVsTmFtZTogXCJLZXJuZWxcIixcblx0XHRtaXJyb3JFZGdlc05hbWU6IFwiTWFyZ2VucyBlbSBFc3BlbGhvXCIsXG5cdFx0aW5mbHVlbmNlc05hbWU6IFwiSW5mbHXDqm5jaWFzXCIsXG5cdFx0ZmllbGRzTmFtZTogXCJDYW1wb3NcIixcblx0XHRyZW1hcHNOYW1lOiBcIlZvbHRhciBhIENhcnRvZ3JhZmFyIFRhYmVsYVwiLFxuXHRcdGV2YWxGcm9tTmFtZTogXCJFc2NhbGEgZGUgQXZhbGlhw6fDo28gRGVzZGVcIixcblx0XHRldmFsVG9OYW1lOiBcIkVzY2FsYSBkZSBBdmFsaWHDp8OjbyBBdMOpXCIsXG5cdFx0d2VpZ2h0c05hbWU6IFwiUGVzb3NcIixcblx0XHRERU1OYW1lOiBcIkRFTVwiLFxuXHRcdHNob3J0UmFuZ2VJRFdSYWRpdXNOYW1lOiBcIlLDoWRpbyBJRFcgZGUgQ3VydG8gQWxjYW5jZVwiLFxuXHRcdG1heFZvaWRXaWR0aE5hbWU6IFwiTGFyZ3VyYSBNw6F4aW1hIFZvaWRcIixcblx0XHRzaWdtYUdhdXNzaWFuTmFtZTogXCJTdWF2aXphw6fDo28gQWRhcHTDoXZlbFwiLFxuXHRcdGNvbnRvdXJUeXBlTmFtZTogXCJUaXBvIGRlIENvbnRvcm5vXCIsXG5cdFx0ekJhc2VOYW1lOiBcIkJhc2UgWlwiLFxuXHRcdG51bWJlck9mQ29udG91cnNOYW1lOiBcIk7Dum1lcm8gZGUgY29udG9ybm9zXCIsXG5cdFx0Y29udG91ckludGVydmFsTmFtZTogXCJJbnRlcnZhbG8gZGUgY29udG9ybm9zXCIsXG5cdFx0bnRoQ29udG91ckxpbmVJbkJvbGROYW1lOiBcIk50aCBDb250b3VyTGluZSBBIE5lZ3JpdG9cIixcblx0XHRmZWF0dXJlQ2xhc3NOYW1lOiBcIkVsZW1lbnRvcyBkZSBFbnRyYWRhOlwiLFxuXHRcdGNsYXNzSW5kZXhGaWVsZE5hbWU6IFwiQ2FtcG9cIixcblx0XHRyZXNvbHZlT3ZlcmxhcE1ldGhvZE5hbWU6IFwiUmVzb2x2ZXIgTcOpdG9kbyBkZSBTb2JyZXBvc2nDp8Ojb1wiLFxuXHRcdHJlc2FtcGxpbmdUeXBlTmFtZTogXCJUaXBvIGRlIFJlc2FtcGxpbmdcIixcblx0XHRpbnB1dENlbGxzaXplTmFtZTogXCJUYW1hbmhvIGRlIEPDqWx1bGFzIGRlIEVudHJhZGFcIixcblx0XHRvdXRwdXRDZWxsc2l6ZU5hbWU6IFwiVGFtYW5obyBkZSBDw6lsdWxhcyBkZSBTYcOtZGFcIixcblx0XHRwb2ludEZlYXR1cmVDbGFzc05hbWU6IFwiUG9udG9zIFNlZWRcIixcblx0XHRtYXhHcm93dGhSYWRpdXNGaWVsZE5hbWU6IFwiQ2FtcG8gZGUgUmFpbyBkZSBDcmVzY2ltZW50byBNw6F4aW1vXCIsXG5cdFx0c2ltaWxhcml0eVRocmVzaG9sZEZpZWxkTmFtZTogXCJDYW1wbyBkZSBMaW1pYXIgZGUgU2VtZWxoYW7Dp2FcIixcblx0XHRmaWxsVmFsdWVGaWVsZE5hbWU6IFwiQ2FtcG8gVmFsb3IgZGUgUHJlZW5jaGltZW50b1wiLFxuXHRcdHNwZWN0cmFsRGV0YWlsTmFtZTogXCJEZXRhbGhlIEVzcGVjdHJhbCBbMS4uMjBdXCIsXG5cdFx0c3BhdGlhbERldGFpbE5hbWU6IFwiRGV0YWxoZSBFc3BhY2lhbCBbMS4uMjBdXCIsXG5cdFx0bWluTnVtUGl4ZWxzUGVyU2VnbWVudE5hbWU6IFwiVGFtYW5obyBkZSBTZWdtZW50byBNw61uaW1vIGVtIFBpeGVpc1wiLFxuXHRcdGJvdW5kYXJpZXNPbmx5TmFtZTogXCJBcGVuYXMgbGltaXRlcyBkZSBzZWdtZW50b3NcIixcblx0XHRzdGF0aXN0aWNzVHlwZU5hbWU6IFwiVGlwbyBkZSBFc3RhdMOtc3RpY2FcIixcblx0XHRmaWxsTm9EYXRhT25seU5hbWU6IFwiUHJlZW5jaGVyIGFwZW5hcyBww614ZWlzIE5vRGF0YVwiLFxuXHRcdGlucHV0RGF0YVR5cGVOYW1lOiBcIlRpcG8gZGUgRGFkb3MgZGUgRW50cmFkYVwiLFxuXHRcdGFuZ2xlUmVmZXJlbmNlU3lzdGVtTmFtZTogXCJTaXN0ZW1hIGRlIFJlZmVyw6puY2lhIGRlIMOCbmd1bG9cIixcblx0XHRvdXRwdXREYXRhVHlwZU5hbWU6IFwiVGlwbyBkZSBEYWRvcyBkZSBTYcOtZGFcIixcblx0XHRpbnB1dFNhbXBsZVBvaW50RmVhdHVyZUNsYXNzTmFtZTogXCJBbW9zdHJhcyBkZSBFbnRyYWRhXCIsXG5cdFx0dmFsdWVGaWVsZE5hbWU6IFwiQ2FtcG8gVmFsb3JcIixcblx0XHRyYXN0ZXJJbmZvTmFtZTogXCJJbmZvLiBkZSBSYXN0ZXJcIixcblx0XHRpbnRlcnBvbGF0aW9uTWV0aG9kTmFtZTogXCJNw6l0b2RvIGRlIEludGVycG9sYcOnw6NvXCIsXG5cdFx0cmFkaXVzTmFtZTogXCJSYWlvXCIsXG5cdFx0cmFkaWFuY2VHYWluVmFsdWVzTmFtZTogXCJHYW5obyBkZSBMdW1pbm9zaWRhZGVcIixcblx0XHRyYWRpYW5jZUJpYXNWYWx1ZXNOYW1lOiBcIlRlbmTDqm5jaWEgZGUgTHVtaW5vc2lkYWRlXCIsXG5cdFx0cmVmbGVjdGVkR2FpblZhbHVlc05hbWU6IFwiR2FuaG8gZGUgUmVmbGV0w6JuY2lhXCIsXG5cdFx0cmVmbGVjdGVkQmlhc1ZhbHVlc05hbWU6IFwiVGVuZMOqbmNpYSBkZSBSZWZsZXTDom5jaWFcIixcblx0XHRzdW5FbGV2YXRpb25OYW1lOiBcIkVsZXZhw6fDo28gZG8gU29sIChncmF1cylcIixcblx0XHRhbGJlZG9OYW1lOiBcIkFsYmVkb1wiLFxuXHRcdHNjYWxlRmFjdG9yTmFtZTogXCJGYXRvciBkZSBFc2NhbGFcIixcblx0XHRvZmZzZXROYW1lOiBcIkRlc3Zpb1wiLFxuXHRcdHRocmVzaG9sZFR5cGVOYW1lOiBcIlRpcG8gZGUgTGltaWFyXCIsXG5cdFx0dGhyZXNob2xkc05hbWU6IFwiTGltaWFyZXNcIixcblx0XHR1bmRlZmluZWRDbGFzc05hbWU6IFwiQ2xhc3NlIEluZGVmaW5pZGFcIixcblx0XHRtaW5WYWx1ZU5hbWU6IFwiTcOtbi5cIixcblx0XHRtYXhWYWx1ZU5hbWU6IFwiTcOheC5cIixcblx0XHRvcGVyYXRpb25OYW1lOiBcIk9wZXJhw6fDo29cIixcblx0XHRjbGlwcGluZ1R5cGVOYW1lOiBcIlRpcG8gZGUgUmVjb3J0ZVwiLFxuXHRcdGNsaXBwaW5nR2VvbWV0cnlOYW1lOiBcIlJlY29ydGFyIEdlb21ldHJpYSAvIFJhc3RlclwiLFxuXHRcdGV4dGVudE5hbWU6IFwiRXh0ZW5zw6NvIGRlIFNhw61kYVwiLFxuXHRcdHVzZUlucHV0RmVhdHVyZUdlb21ldHJ5TmFtZTogXCJVdGlsaXphciBlbGVtZW50b3MgZGUgZW50cmFkYSBwYXJhIHJlY29ydGFyIGdlb21ldHJpYVwiLFxuXHRcdHJlbWFwRGVmaW5pdGlvblR5cGVOYW1lOiBcIlRpcG8gZGUgRGVmaW5pw6fDo28gVm9sdGFyIGEgQ2FydG9ncmFmYXJcIixcblx0XHRpbnB1dFJhbmdlTmFtZTogXCJJbnRlcnZhbG9zIGRlIEVudHJhZGFcIixcblx0XHRvdXRwdXRWYWx1ZXNOYW1lOiBcIlZhbG9yZXMgZGUgU2HDrWRhXCIsXG5cdFx0bm9EYXRhUmFuZ2VOYW1lOiBcIkludGVydmFsb3MgTm9EYXRhXCIsXG5cdFx0aW5wdXRGaWVsZE5hbWU6IFwiSW50cm9kdXppciBDYW1wb1wiLFxuXHRcdG91dHB1dEZpZWxkTmFtZTogXCJDYW1wbyBkZSBTYcOtZGFcIixcblx0XHRpbnB1dE1heEZpZWxkTmFtZTogXCJDYW1wbyBNw6F4IGRlIEVudHJhZGEgKG9wY2lvbmFsKVwiLFxuXHRcdHJlbWFwVGFibGVUeXBlTmFtZTogXCJUaXBvIGRlIFRhYmVsYSBWb2x0YXIgYSBDYXJ0b2dyYWZhclwiLFxuXHRcdGFsbG93VW5tYXRjaGVkTmFtZTogXCJQZXJtaXRpciB2YWxvcmVzIGRlIHBpeMOpaXMgc2VtIGNvcnJlc3BvbmTDqm5jaWFcIixcblx0XHRjaGFuZ2VNaXNzaW5nVmFsdWVzVG9Ob0RhdGFOYW1lOiBcIkFsdGVyYXIgdmFsb3JlcyBlbSBmYWx0YSBwYXJhIE5vRGF0YVwiLFxuXHRcdHZpc2libGVCYW5kSUROYW1lOiBcIklEIGRlIEJhbmRhIFZpc8OtdmVsXCIsXG5cdFx0aW5mcmFyZWRCYW5kSUROYW1lOiBcIklEIGRlIEJhbmRhIGRlIEluZnJhdmVybWVsaG9zXCIsXG5cdFx0c2NpZW50aWZpY091dHB1dE5hbWU6IFwiU2HDrWRhIENpZW50w61maWNhXCIsXG5cdFx0YmFuZEluZGV4ZXNOYW1lOiBcIsONbmRpY2VzIGRlIEJhbmRhc1wiLFxuXHRcdGNvbnN0YW50TmFtZTogXCJDb25zdGFudGVcIixcblx0XHR3ZWlnaHROYW1lOiBcIlBlc29cIixcblx0XHRtaW5pbXVtTmFtZTogXCJNw61uaW1vXCIsXG5cdFx0bWF4aW11bU5hbWU6IFwiTcOheGltb1wiLFxuXHRcdHNvdXJjZURhdGFOYW1lOiBcIlJhc3RlciBkZSBPcmlnZW1cIixcblx0XHRzb3VyY2VGaWVsZE5hbWU6IFwiQ2FtcG8gZGUgT3JpZ2VtXCIsXG5cdFx0Y29zdFJhc3Rlck5hbWU6IFwiUmFzdGVyIGRlIEN1c3RvXCIsXG5cdFx0bWF4RGlzdGFuY2VOYW1lOiBcIkRpc3TDom5jaWEgTcOheGltYVwiLFxuXHRcdHZhbHVlUmFzdGVyTmFtZTogXCJSYXN0ZXIgZGUgVmFsb3JcIixcblx0XHRjb3N0TXVsdGlwbGllck5hbWU6IFwiTXVsdGlwbGljYWRvciBwYXJhIGFwbGljYXIgYSBDdXN0b3NcIixcblx0XHRzdGFydENvc3ROYW1lOiBcIkN1c3RvIEluaWNpYWxcIixcblx0XHRhY2N1bUNvc3RSZXNpc3RhbmNlUmF0ZU5hbWU6IFwiVGF4YSBkZSBSZXNpc3TDqm5jaWEgQ3VzdG8gQWN1bXVsYXRpdm9cIixcblx0XHRjYXBhY2l0eU5hbWU6IFwiQ2FwYWNpZGFkZVwiLFxuXHRcdHRyYXZlbERpcmVjdGlvbk5hbWU6IFwiRGlyZcOnw6NvIGRlIFZpYWdlbVwiLFxuXHRcdGNlbGxTaXplTmFtZTogXCJDZWxsc2l6ZVwiLFxuXHRcdHBvcHVsYXRpb25GaWVsZE5hbWU6IFwiQ2FtcG8gUG9wdWxhw6fDo29cIixcblx0XHRhcmVhVW5pdHNOYW1lOiBcIlVuaWRhZGVzIGRlIMOBcmVhXCIsXG5cdFx0b3V0cHV0VmFsdWVUeXBlTmFtZTogXCJWYWxvcmVzIGRlIEPDqWx1bGFzIGRlIFNhw61kYVwiLFxuXHRcdGJhcnJpZXJzTmFtZTogXCJCYXJyZWlyYXMgZGUgSW50cm9kdcOnw6NvXCIsXG5cdFx0ZGVzdGluYXRpb25EYXRhTmFtZTogXCJSYXN0ZXIgZGUgRGVzdGlub1wiLFxuXHRcdGRlc3RpbmF0aW9uRmllbGROYW1lOiBcIkNhbXBvIERlc3Rpbm9cIixcblx0XHRwYXRoVHlwZU5hbWU6IFwiVGlwbyBkZSBDYW1pbmhvXCIsXG5cdFx0b2JzZXJ2ZXJGZWF0dXJlc05hbWU6IFwiRWxlbWVudG9zIGRlIE9ic2VydmFkb3Jlc1wiLFxuXHRcdGFuYWx5c2lzTWV0aG9kTmFtZTogXCJNw6l0b2RvIGRlIEFuw6FsaXNlXCIsXG5cdFx0YW5hbHlzaXNUeXBlTmFtZTogXCJUaXBvIGRlIEFuw6FsaXNlXCIsXG5cdFx0dmVydGljYWxFcnJvck5hbWU6IFwiRXJybyBWZXJ0aWNhbFwiLFxuXHRcdHJlZnJhY3Rpdml0eUNvZWZmaWNpZW50TmFtZTogXCJDb2VmaWNpZW50ZSBkZSBSZWZyYXRpdmlkYWRlXCIsXG5cdFx0c3VyZmFjZU9mZnNldE5hbWU6IFwiRGVzdmlvIGRlIFN1cGVyZsOtY2llXCIsXG5cdFx0b2JzZXJ2ZXJFbGV2YXRpb25OYW1lOiBcIkVsZXZhw6fDo28gZGUgT2JzZXJ2YWRvclwiLFxuXHRcdG9ic2VydmVyT2Zmc2V0TmFtZTogXCJEZXN2aW8gZGUgT2JzZXJ2YWRvclwiLFxuXHRcdGlubmVyUmFkaXVzTmFtZTogXCJSYWlvIEludGVyaW9yXCIsXG5cdFx0aW5uZXJSYWRpdXNJczNERGlzdGFuY2VOYW1lOiBcIk8gUmFpbyBJbnRlcmlvciDDqSB1bWEgRGlzdMOibmNpYSAzRFwiLFxuXHRcdG91dGVyUmFkaXVzTmFtZTogXCJSYWlvciBFeHRlcmlvclwiLFxuXHRcdG91dGVyUmFkaXVzSXMzRERpc3RhbmNlTmFtZTogXCJPIFJhaW8gRXh0ZXJpb3Igw6kgdW1hIERpc3TDom5jaWEgM0RcIixcblx0XHRob3Jpem9udGFsU3RhcnRBbmdsZU5hbWU6IFwiw4JuZ3VsbyBkZSBJbsOtY2lvIEhvcml6b250YWxcIixcblx0XHRob3Jpem9udGFsRW5kQW5nbGVOYW1lOiBcIsOCbmd1bG8gZGUgRmltIEhvcml6b250YWxcIixcblx0XHR2ZXJ0aWNhbFVwcGVyQW5nbGVOYW1lOiBcIsOCbmd1bG8gU3VwZXJpb3IgVmVydGljYWxcIixcblx0XHR2ZXJ0aWNhbExvd2VyQW5nbGVOYW1lOiBcIsOCbmd1bG8gSW5mZXJpb3IgVmVydGljYWxcIixcblx0XHR6b25lRGF0YU5hbWU6IFwiUmFzdGVyIGRlIFpvbmFcIixcblx0XHR6b25lRmllbGROYW1lOiBcIkNhbXBvIGRlIFpvbmFcIixcblx0XHRpZ25vcmVOb0RhdGFOYW1lOiBcIklnbm9yYXIgTm9EYXRhIGVtIGPDoWxjdWxvc1wiLFxuXHRcdHRlbXBlcmF0dXJlUmFzdGVyTmFtZTogXCJSYXN0ZXIgZGUgVGVtcGVyYXR1cmFcIixcblx0XHRpblRlbXBlcmF0dXJlVW5pdHNOYW1lOiBcIlVuaWRhZGVzIGRlIFRlbXBlcmF0dXJhXCIsXG5cdFx0b3V0SGVhdEluZGV4VGVtcGVyYXR1cmVVbml0c05hbWU6IFwiVW5pZGFkZXMgZGUgw41uZGljZSBkZSBBcXVlY2ltZW50b1wiLFxuXHRcdHJlbGF0aXZlSHVtaWRpdHlSYXN0ZXJOYW1lOiBcIlJhc3RlciBkZSBIdW1pZGFkZSBSZWxhdGl2YVwiLFxuXHRcdG91dFdpbmRDaGlsbFRlbXBlcmF0dXJlVW5pdHNOYW1lOiBcIlVuaWRhZGVzIGRlIEFycmVmZWNpbWVudG8gcGVsbyBWZW50b1wiLFxuXHRcdHdpbmRTcGVlZFJhc3Rlck5hbWU6IFwiUmFzdGVyIGRlIFZlbG9jaWRhZGUgZG8gVmVudG9cIixcblx0XHRpbldpbmRTcGVlZFVuaXRzTmFtZTogXCJVbmlkYWRlcyBkZSBWZWxvY2lkYWRlIGRvIFZlbnRvXCIsXG5cdFx0dmFsdWVOYW1lOiBcIlZhbG9yXCIsXG5cdFx0cHJvcGVydHlOYW1lOiBcIk5vbWUgZGUgUHJvcHJpZWRhZGVcIixcblx0XHRqc29uTmFtZTogXCJNZXRhZGFkb3MgSlNPTlwiLFxuXHRcdHpvbmVUYWJsZU5hbWU6IFwiVGFiZWxhIGRlIEF0cmlidXRvcyBab25haXNcIixcblx0XHRhdHRyaWJ1dGVGaWVsZE5hbWVzOiBcIk5vbWVzIGRlIENhbXBvIGRlIEF0cmlidXRvXCIsXG5cdFx0YmFja2dyb3VuZE5hbWU6IFwiVmFsb3IgZGUgRnVuZG9cIixcblx0XHR3aGVyZUNsYXVzZU5hbWU6IFwiQ2zDoXVzdWxhIE9uZGVcIixcblx0XHRtaW5pbXVtVmFsdWVGaWVsZE5hbWU6IFwiTm9tZSBkZSBDYW1wbyBkZSBWYWxvciBNw61uaW1vXCIsXG5cdFx0bWF4aW11bVZhbHVlRmllbGROYW1lOiBcIk5vbWUgZGUgQ2FtcG8gZGUgVmFsb3IgTcOheGltb1wiLFxuXHRcdG91dFZhbHVlRmllbGROYW1lOiBcIk5vbWUgZGUgQ2FtcG8gZGUgVmFsb3IgZGUgU2HDrWRhXCIsXG5cdFx0ZGVmYXVsdFZhbHVlTmFtZTogXCJWYWxvciBkZSBTYcOtZGEgUGFkcsOjb1wiLFxuXHRcdGNvbnZlcnNpb25NYXRyaXhOYW1lOiBcIk1hdHJpeiBkZSBDb252ZXJzw6NvXCIsXG5cdFx0SXNQc2V1ZG9Db2xvck91dHB1dE5hbWU6IFwiw4kgdW1hIHBzZXVkbyBzYcOtZGEgZGUgY29yXCIsXG5cdFx0dW5tYXBwZWRBc1JhbmRvbUNvbG9yTmFtZTogXCJBdHJpYnVpciBhbGVhdG9yaWFtZW50ZSBjb3IgYSBww614ZWlzIG7Do28gbWFwZWFkb3NcIixcblx0XHRkaXN0YW5jZU1ldGhvZE5hbWU6IFwiTcOpdG9kbyBkZSBkaXN0w6JuY2lhXCIsXG5cdFx0Zmxvd0RpclJhc3Rlck5hbWU6IFwiUmFzdGVyIGRlIGRpcmXDp8OjbyBkbyBmbHV4b1wiLFxuXHRcdHBvdXJQb2ludE5hbWU6IFwiRGVpdGFyIFJhc3RlciBwb250byhzKVwiLFxuXHRcdHBvdXJQb2ludEZpZWxkTmFtZTogXCJEZWl4YXIgY2FtcG8gcG9udG9cIixcblx0XHRjb25zdGFudFpOYW1lOiBcIkNvbnN0YW50ZSBaXCIsXG5cdFx0ek9mZnNldE5hbWU6IFwiT2Zmc2V0IFpcIixcblx0XHRnZW9JZE5hbWU6IFwiR2XDs2lkZVwiLFxuXHRcdGNhbGlicmF0aW9uVHlwZU5hbWU6IFwiVGlwbyBkZSBjYWlicmFnZW1cIixcblx0XHRmaWx0ZXJUeXBlTmFtZTogXCJUaXBvIGRlIGZpbHRyb1wiLFxuXHRcdGZpbHRlclNpemVOYW1lOiBcIlRhbWFuaG8gZG8gZmlsdHJvXCIsXG5cdFx0bm9pc2VNb2RlbE5hbWU6IFwiTW9kZWxvIGRlIHJ1w61kb1wiLFxuXHRcdG5vaXNlVmFyaWFuY2VOYW1lOiBcIlZhcmlhw6fDo28gZGUgcnXDrWRvXCIsXG5cdFx0YWRkaXRpdmVOb2lzZU1lYW5OYW1lOiBcIk3DqWRpYSBkZSBydcOtZG8gYWRpdGl2b1wiLFxuXHRcdG11bHRpcGxpY2F0aXZlTm9pc2VNZWFuTmFtZTogXCJNw6lkaWEgZGUgcnXDrWRvIG11bHRpcGxpY2F0aXZvXCIsXG5cdFx0bnVtYmVyb2ZMb29rc05hbWU6IFwiTsO6bWVybyBkZSBmZWnDp8O1ZXNcIixcblx0XHRkYW1waW5nRmFjdG9yTmFtZTogXCJGYXRvciBkZSBhbW9ydGVjaW1lbnRvXCIsXG5cdFx0bWFza1Jhc3Rlck5hbWU6IFwiUmFzdGVyIG3DoXNjYXJhXCIsXG5cdFx0bmliYmxlVmFsdWVzTmFtZTogXCJVdGlsaXphciB2YWxvcmVzIE5vRGF0YSBzZSBlc3RlcyBmb3JlbSBvIHZpemluaG8gbWFpcyBwcsOzeGltb1wiLFxuXHRcdG5pYmJsZU5vRGF0YU5hbWU6IFwiQ8OpbHVsYXMgTm9EYXRhIHZpYnJhw6fDo29cIixcblx0XHR6TGltaXROYW1lOiBcIkxpbWl0ZSBaXCIsXG5cdFx0Zmxvd0RpcmVjdGlvblR5cGVOYW1lOiBcIlRpcG8gZGUgZGlyZcOnw6NvIGRvIGZsdXhvXCIsXG5cdFx0d2VpZ2h0UmFzdGVyTmFtZTogXCJSYXN0ZXIgcGVzb1wiLFxuXHRcdGZvcmNlRWRnZU5hbWU6IFwiRm9yw6dhciB0b2RhcyBhcyBjw6lsdWxhcyBkZSBib3JkYXMgYSBmbHVpciBwYXJhIGZvcmFcIixcblx0XHRzdHJlYW1SYXN0ZXJOYW1lOiBcIlJhc3RlciBkZSBzdHJlYW1cIixcblx0XHRzdXJmYWNlUmFzdGVyTmFtZTogXCJSYXN0ZXIgZGUgc3VwZXJmw61jaWVcIixcblx0XHRjb252ZXJzaW9uVHlwZTogXCJUaXBvIGRlIGNvbnZlcnPDo29cIixcblx0XHRkaXN0YW5jZVJhc3RlcjE6IFwiUmFzdGVyIGRlIGRpc3TDom5jaWEgMVwiLFxuXHRcdGRpc3RhbmNlUmFzdGVyMjogXCJSYXN0ZXIgZGUgZGlzdMOibmNpYSAyXCIsXG5cdFx0Y29zdERpc3RhbmNlUmFzdGVyOiBcIlJhc3RlciBkZSBkaXN0w6JuY2lhIGN1c3RvXCIsXG5cdFx0Y29zdEJhY2tsaW5rUmFzdGVyOiBcIlJhc3RlciBkZSBiYWNrbGluayBjdXN0b1wiLFxuXHRcdG92ZXJyaWRlc05hbWU6IFwiU3Vic3RpdHVpXCIsXG5cdFx0ZmllbGROYW1lOiBcIkNhbXBvXCIsXG5cdFx0c2lnbmF0dXJlRmlsZU9yVXJsOiBcIkZpY2hlaXJvIGRlIGFzc2luYXR1cmEgb3UgVVJMXCIsXG5cdFx0cmVkTmFtZTogXCJWZXJtZWxob1wiLFxuXHRcdGdyZWVuTmFtZTogXCJWZXJkZVwiLFxuXHRcdGJsdWVOYW1lOiBcIkF6dWxcIixcblx0XHRpbmZyYXJlZE5hbWU6IFwiSW5mcmF2ZXJtZWxob3NcIixcblx0XHRwYW5jaHJvbWF0aWNOYW1lOiBcIlBhbmNyb23DoXRpY29cIixcblx0XHRtdWx0aXNwZWN0cmFsTmFtZTogXCJNdWx0aWVzcGVjdHJhbFwiLFxuXHRcdHBhbnNoYXJwZW5pbmdUeXBlOiBcIlRpcG8gcGFuc2hhcnBlbmluZ1wiLFxuXHRcdHNlbnNvck5hbWU6IFwiU2Vuc29yXCIsXG5cdFx0c3BhdGlhbFJlZmVyZW5jZU5hbWU6IFwiUmVmZXLDqm5jaWEgRXNwYWNpYWxcIixcblx0XHR4Q2VsbHNpemVOYW1lOiBcIlRhbWFuaG8gZGEgY8OpbHVsYSBYXCIsXG5cdFx0eUNlbGxzaXplTmFtZTogXCJUYW1hbmhvIGRhIGPDqWx1bGEgWVwiLFxuXHRcdHhPcmlnaW5OYW1lOiBcIlBvbnRvIGRlIHJlZ2lzdG8gWFwiLFxuXHRcdHlPcmlnaW5OYW1lOiBcIlBvbnRvIGRlIHJlZ2lzdG8gWVwiLFxuXHRcdHBlcmNlbnRpbGVOYW1lOiBcIlZhbG9yIGRlIFBlcmNlbnRpbFwiLFxuXHRcdG5laWdoYm9yaG9vZFR5cGU6IFwiVGlwbyB2aXppbmhhbsOnYVwiLFxuXHRcdHdpZHRoTmFtZTogXCJMYXJndXJhXCIsXG5cdFx0aGVpZ2h0TmFtZTogXCJBbHR1cmFcIixcblx0XHRzdGFydEFuZ2xlTmFtZTogXCLDgm5ndWxvIGRlIEluw61jaW9cIixcblx0XHRlbmRBbmdsZU5hbWU6IFwiw4JuZ3VsbyBkZSBmaW1cIixcblx0XHRuZWlnaGJvcmhvb2RWYWx1ZXM6IFwiVmFsb3JlcyB2aXppbmhhbsOnYVwiLFxuXHRcdGhvcml6b250YWxSYXN0ZXI6IFwiUmFzdGVyIGhvcml6b250YWxcIixcblx0XHRob3Jpem9udGFsRmFjdG9yOiBcIkZhdG9yIGhvcml6b250YWxcIixcblx0XHR2ZXJ0aWNhbFJhc3RlcjogXCJSYXN0ZXIgdmVydGljYWxcIixcblx0XHR2ZXJ0aWNhbEZhY3RvcjogXCJGYXRvciB2ZXJ0aWNhbFwiLFxuXHRcdHN0cmVhbVJhc3RlcjogXCJSYXN0ZXIgZGUgc3RyZWFtXCIsXG5cdFx0Zmxvd0RpclJhc3RlcjogXCJSYXN0ZXIgZGUgZGlyZcOnw6NvIGRvIGZsdXhvXCIsXG5cdFx0bnVtYmVyTmVpZ2hib3JDZWxsczogXCJOw7ptZXJvIGRlIGPDqWx1bGFzIHZpemluaGFzXCIsXG5cdFx0em9uZUNvbm5lY3Rpdml0eTogXCJDb25lY3RpdmlkYWRlIGRlIHpvbmFcIixcblx0XHRhZGRMaW5rQmVoYXZpb3I6IFwiQWRpY2lvbmFyIExpZ2HDp8Ojb1wiLFxuXHRcdGV4Y2x1ZGVkVmFsdWU6IFwiVmFsb3IgZXhjbHXDrWRvXCIsXG5cdFx0Y29uc3RhbnRGaWxsQ2hlY2s6IFwiQ3JpYXIgUmFzdGVyIGVuY2hpbWVudG8gYSBwYXJ0aXIgZGUgY29uc3RhbnRlXCIsXG5cdFx0ZmlsbFJhc3RlcjogXCJSYXN0ZXIgZGUgZW5jaGltZW50b1wiLFxuXHRcdGNvbnN0YW50RmlsbFZhbHVlOiBcIlZhbG9yIENvbnN0YW50ZVwiLFxuXHRcdGlucHV0Qml0UG9zaXRpb25zOiBcIkJpdCBlbnRyYWRhXCIsXG5cdFx0b3V0cHV0Qml0UG9zaXRpb25zOiBcIkJpdCBzYcOtZGFcIixcblx0XHRkaXN0YW5jZVR5cGVOYW1lOiBcIlRpcG8gZGUgRGlzdMOibmNpYVwiLFxuXHRcdGJhcnJpZXJEYXRhTmFtZTogXCJCYXJyZWlyYXMgZGUgUmFzdGVyXCIsXG5cdFx0cG91clBvaW50RGF0YU5hbWU6IFwiUmFzdGVyIGRlIFBvbnRvIGRlIEVzY29hbWVudG9cIixcblx0XHRhY2N1bXVsYXRpb25SYXN0ZXJOYW1lOiBcIlJhc3RlciBkZSBBY3VtdWxhw6fDo28gZG8gRmx1eG9cIixcblx0XHRzbmFwRGlzdGFuY2VOYW1lOiBcIkRpc3TDom5jaWEgZGUgRW5jYWl4ZVwiLFxuXHRcdG9yZGVyTWV0aG9kTmFtZTogXCJNw6l0b2RvIGRlIE9yZGVuYcOnw6NvXCIsXG5cdFx0ZGlyZWN0aW9uTWVhc3VyZW1lbnROYW1lOiBcIkRpcmXDp8OjbyBkYSBNZWRpw6fDo29cIixcblx0XHRwcm9jZXNzQXNNdWx0aWJhbmQ6IFwiUHJvY2Vzc2FyIGNvbW8gTXVsdGliYW5kYVwiLFxuXHRcdHByb2Nlc3NNdWx0aWRpbWVuc2lvbmFsOiBcIlByb2Nlc3NhciBjb21vIG11bHRpZGltZW5zaW9uYWxcIixcblx0XHRmb3JjZUZsb3dEaXJlY3Rpb25Db252ZW50aW9uOiBcIkZvcsOnYXIgY29udmVuw6fDo28gZGUgZGlyZcOnw6NvIGRvIGZsdXhvIHBhcmEgcmFzdGVyIGRlIGJhY2tsaW5rIGN1c3RvXCIsXG5cdFx0aW5pdGlhbEFjY3VtdWxhdGlvbjogXCJBY3VtdWxhw6fDo28gSW5pY2lhbFwiLFxuXHRcdG1heGltdW1BY2N1bXVsYXRpb246IFwiQWN1bXVsYcOnw6NvIE3DoXhpbWFcIixcblx0XHRzb3VyY2VMb2NhdGlvbkJhbmRzOiBcIkdlcmFyIGxpbmhhIGUgY29sdW5hIGRlIG9yaWdlbSBjb21vIGJhbmRhcyBhZGljaW9uYWlzIG5hIHNhw61kYVwiLFxuXHRcdGJhY2tEaXJlY3Rpb25CYW5kOiBcIkdlcmFyIGRpcmXDp8OjbyBkZSByZXRvcm5vIGNvbW8gYmFuZGEgYWRpY2lvbmFsIG5hIHNhw61kYVwiLFxuXHRcdG51bWJlck9mQ2VsbHM6IFwiTsO6bWVybyBkZSBDw6lsdWxhc1wiLFxuXHRcdHpvbmVWYWx1ZXM6IFwiVmFsb3JlcyBkZSBab25hXCIsXG5cdFx0c2hyaW5rTWV0aG9kOiBcIlJlZHV6aXIgTcOpdG9kb1wiLFxuXHRcdGV4cGFuZE1ldGhvZDogXCJFeHBhbmRpciBNw6l0b2RvXCIsXG5cdFx0aW5wdXRTcGVjdHJhbFByb2ZpbGVUeXBlOiBcIlRpcG8gZGUgUGVyZmlsIEVzcGV0cmFsXCIsXG5cdFx0c3BlY3RyYWxQcm9maWxlRmlsZU5hbWU6IFwiUGVyZmlsIEVzcGV0cmFsXCIsXG5cdFx0dHJhaW5pbmdGZWF0dXJlRmlsZU5hbWU6IFwiRWxlbWVudG8gZGUgRm9ybWHDp8Ojb1wiLFxuXHRcdG5vbk5lZ2F0aXZlOiBcIk7Do28gbmVnYXRpdm9cIixcblx0XHRzdW1Ub09uZTogXCJTb21hciBhIFVtXCIsXG5cdFx0cmFuZG9tRGlzdHJpYnV0aW9uOiBcIkRpc3RyaWJ1acOnw6NvXCIsXG5cdFx0bWVhbk5hbWU6IFwiTcOpZGlhXCIsXG5cdFx0cHJvYmFiaWxpdHlOYW1lOiBcIlByb2JhYmlsaWRhZGVcIixcblx0XHRhbHBoYU5hbWU6IFwiQWxmYVwiLFxuXHRcdGJldGFOYW1lOiBcIkJldGFcIixcblx0XHRyTmFtZTogXCJyXCIsXG5cdFx0bk5hbWU6IFwiTlwiLFxuXHRcdHNlZWQ6IFwiU2VlZFwiLFxuXHRcdHJhbmRvbU51bWJlckdlbmVyYXRvcjogXCJHZXJhZG9yIGRlIE7Dum1lcm8gQWxlYXTDs3Jpb1wiLFxuXHRcdGNlbGxGYWN0b3I6IFwiRmF0b3IgZGUgQ8OpbHVsYVwiLFxuXHRcdGFnZ3JlZ2F0aW9uVHlwZTogXCJUw6ljbmljYSBkZSBhZ3JlZ2HDp8Ojb1wiLFxuXHRcdGV4dGVudEhhbmRsaW5nOiBcIkV4cGFuZGlyIGV4dGVuc8OjbyBzZSBuZWNlc3PDoXJpb1wiLFxuXHRcdHRyZW5kQW5hbHlzaXNEaW1lbnNpb25OYW1lOiBcIk5vbWUgZGEgRGltZW5zw6NvXCIsXG5cdFx0dHJlbmRBbmFseXNpc1R5cGU6IFwiVGlwbyBkZSBUZW5kw6puY2lhXCIsXG5cdFx0aGFybW9uaWNGcmVxdWVuY3k6IFwiRnJlcXXDqm5jaWEgSGFybcOzbmljYVwiLFxuXHRcdHBvbHlub21pYWxPcmRlcjogXCJPcmRlbSBQb2xpbm9taWFsXCIsXG5cdFx0Y3ljbGVMZW5ndGhOYW1lOiBcIkR1cmHDp8OjbyBkbyBDaWNsb1wiLFxuXHRcdHRyZW5kQW5hbHlzaXNSTVNFOiBcIlJNU0VcIixcblx0XHR0cmVuZEFuYWx5c2lzUjI6IFwiUi1xdWFkcmFkb1wiLFxuXHRcdHRyZW5kQW5hbHlzaXNTbG9wZVBWYWx1ZTogXCJWYWxvciBQIGRvIENvZWZpY2llbnRlIGRlIEluY2xpbmHDp8Ojb1wiLFxuXHRcdHRyZW5kQW5hbHlzaXNTZWFzb25hbFBlcmlvZDogXCJQZXLDrW9kbyBTYXpvbmFsXCIsXG5cdFx0Y3ljbGVVbml0TmFtZTogXCJVbmlkYWRlIGRlIENpY2xvXCIsXG5cdFx0cHJlZGljdERpbWVuc2lvblZhbHVlczogXCJWYWxvcmVzXCIsXG5cdFx0ZGltZW5zaW9uRGVmaW5pdGlvblR5cGU6IFwiRGVmaW5pw6fDo28gZGUgRGltZW5zw6NvXCIsXG5cdFx0cHJlZGljdERpbWVuc2lvblN0YXJ0OiBcIkluaWNpYXJcIixcblx0XHRwcmVkaWN0RGltZW5zaW9uRW5kOiBcIkZpbmFsXCIsXG5cdFx0cHJlZGljdERpbWVuc2lvbkludGVydmFsOiBcIkludGVydmFsbyBkZSB2YWxvclwiLFxuXHRcdGRpbWVuc2lvblVuaXQ6IFwiVW5pZGFkZVwiLFxuXHRcdGludGVycG9sYXRpb25DZWxsc2l6ZU5hbWU6IFwiVGFtYW5obyBkZSBDw6lsdWxhIGRlIEludGVycG9sYcOnw6NvXCIsXG5cdFx0dmFyaWFibGVOYW1lOiBcIlZhcmnDoXZlaXNcIixcblx0XHRkaW1lbnNpb25sZXNzTmFtZTogXCJTZW0gRGltZW5zw6NvXCIsXG5cdFx0bWRpbURlZmluaXRpb246IFwiRGVmaW5pw6fDo28gZGUgRGltZW5zw6NvXCIsXG5cdFx0ZGltZW5zaW9uTmFtZTogXCJEaW1lbnPDo29cIixcblx0XHRpdGVyYXRpb25TdGFydDogXCJJbsOtY2lvIGRhIHByaW1laXJhIGl0ZXJhw6fDo29cIixcblx0XHRpdGVyYXRpb25FbmQ6IFwiRmltIGRhIHByaW1laXJhIGl0ZXJhw6fDo29cIixcblx0XHRpbnRlcnZhbFN0YXJ0OiBcIkluw61jaW8gZG8gSW50ZXJ2YWxvXCIsXG5cdFx0aW50ZXJ2YWxFbmQ6IFwiRmltIGRvIEludGVydmFsb1wiLFxuXHRcdHN0ZXBOYW1lOiBcIlBhc3NvXCIsXG5cdFx0cmFuZ2VzTmFtZTogXCJGYWl4YXNcIixcblx0XHRtaW5WYWx1ZTogXCJWYWxvciBNw61uaW1vXCIsXG5cdFx0bWF4VmFsdWU6IFwiVmFsb3IgTcOheGltb1wiLFxuXHRcdGNoYW5nZUFuYWx5c2lzUmFzdGVyTmFtZTogXCJSYXN0ZXIgZGUgQW7DoWxpc2UgZGUgQWx0ZXJhw6fDtWVzXCIsXG5cdFx0Y2hhbmdlVHlwZU5hbWU6IFwiQWx0ZXJhciBUaXBvXCIsXG5cdFx0c2VnbWVudERhdGU6IFwiRGF0YSBkbyBTZWdtZW50b1wiLFxuXHRcdGNoYW5nZURpcmVjdGlvbk5hbWU6IFwiQWx0ZXJhciBEaXJlw6fDo29cIixcblx0XHRtYXhOdW1DaGFuZ2VzTmFtZTogXCJOw7ptZXJvIE3DoXhpbW8gZGUgQWx0ZXJhw6fDtWVzXCIsXG5cdFx0ZmlsdGVyQnlZZWFyOiBcIkZpbHRyYXIgcG9yIEFub1wiLFxuXHRcdG1pbmltdW1ZZWFyOiBcIlZhbG9yIE3DrW5pbW9cIixcblx0XHRtYXhpbXVtWWVhcjogXCJWYWxvciBNw6F4aW1vXCIsXG5cdFx0ZmlsdGVyQnlEdXJhdGlvbjogXCJGaWx0cmFyIHBvciBEdXJhw6fDo29cIixcblx0XHRtaW5pbXVtRHVyYXRpb246IFwiRHVyYcOnw6NvIE3DrW5pbWFcIixcblx0XHRtYXhpbXVtRHVyYXRpb246IFwiRHVyYcOnw6NvIE3DoXhpbWFcIixcblx0XHRmaWx0ZXJCeU1hZ25pdHVkZTogXCJGaWx0cmFyIHBvciBNYWduaXR1ZGVcIixcblx0XHRtaW5pbXVtTWFnbml0dWRlOiBcIk1hZ25pdHVkZSBNw61uaW1hXCIsXG5cdFx0bWF4aW11bU1hZ25pdHVkZTogXCJNYWduaXR1ZGUgTcOheGltYVwiLFxuXHRcdGZpbHRlckJ5U3RhcnRWYWx1ZTogXCJGaWx0cmFyIFBvciBWYWxvciBJbmljaWFsXCIsXG5cdFx0bWluaW11bVN0YXJ0VmFsdWU6IFwiVmFsb3IgSW5pY2lhbCBNw61uaW1vXCIsXG5cdFx0bWF4aW11bVN0YXJ0VmFsdWU6IFwiVmFsb3IgSW5pY2lhbCBNw6F4aW1vXCIsXG5cdFx0ZmlsdGVyQnlFbmRWYWx1ZTogXCJGaWx0cmFyIFBvciBWYWxvciBGaW5hbFwiLFxuXHRcdG1pbmltdW1FbmRWYWx1ZTogXCJWYWxvciBGaW5hbCBNw61uaW1vXCIsXG5cdFx0bWF4aW11bUVuZFZhbHVlOiBcIlZhbG9yIEZpbmFsIE3DoXhpbW9cIixcblx0XHRtb2RlbFR5cGVOYW1lOiBcIlRpcG8gZGUgTW9kZWxvXCIsXG5cdFx0ZnJvbVJhc3Rlck5hbWU6IFwiRG8gUmFzdGVyXCIsXG5cdFx0dG9SYXN0ZXJOYW1lOiBcIlBhcmEgbyBSYXN0ZXJcIixcblx0XHRjb21wdXRlQ2hhbmdlTWV0aG9kOiBcIk3DqXRvZG8gZGUgQ2FsY3VsYXIgQWx0ZXJhw6fDo29cIixcblx0XHRmcm9tQ2xhc3NWYWx1ZXM6IFwiRGUgVmFsb3JlcyBkZSBDbGFzc2UgKEV4ZW1wbG86IDIgNSlcIixcblx0XHR0b0NsYXNzVmFsdWVzOiBcIlBhcmEgVmFsb3JlcyBkZSBDbGFzc2UgKEV4ZW1wbG86IDIgNSlcIixcblx0XHRrZWVwTWV0aG9kOiBcIkZpbHRyYXIgTcOpdG9kb1wiLFxuXHRcdHVzZUNvbG9yTWV0aG9kOiBcIkRlZmluaXIgQ29yZXMgZGUgVHJhbnNpw6fDo29cIixcblx0XHRkZXRlY3RDaGFuZ2VCYW5kczogXCJCYW5kYXMgcGFyYSBEZXRlw6fDo28gZGUgQWx0ZXJhw6fDtWVzIChjb21lw6dhIG5vIDApXCIsXG5cdFx0dG1hc2tCYW5kczogXCJCYW5kYXMgcGFyYSBNw6FzY2FyYSBUZW1wb3JhbCAoY29tZcOnYSBubyAwKVwiLFxuXHRcdGNoaVNxdWFyZWRUaHJlc2hvbGQ6IFwiTGltaWFyIGRlIENoaS1xdWFkcmFkbyBwYXJhIERldGV0YXIgQWx0ZXJhw6fDtWVzXCIsXG5cdFx0bWluQW5vbWFseTogXCJPYnNlcnZhw6fDtWVzIGRlIEFub21hbGlhcyBNw61uaW1hcyBDb25zZWN1dGl2YXNcIixcblx0XHR1cGRhdGluZ0ZyZXF1ZW5jeTogXCJBdHVhbGl6YcOnw6NvIGRhIEZyZXF1w6puY2lhIGRlIEFqdXN0ZSAoZW0gYW5vcylcIixcblx0XHRkaXN0YW5jZUFjY3VtdWxhdGlvblJhc3Rlck5hbWU6IFwiUmFzdGVyIGRlIEFjdW11bGHDp8OjbyBkZSBEaXN0w6JuY2lhXCIsXG5cdFx0Y29zdEJhY2tkaXJlY3Rpb25SYXN0ZXJOYW1lOiBcIlJhc3RlciBkZSBEaXJlw6fDo28gZGUgUmV0b3JubyBvdSBkZSBEaXJlw6fDo28gZG8gRmx1eG9cIixcblx0XHRyYXN0ZXJDb2xsZWN0aW9uTmFtZTogXCJDb2xlw6fDo28gZGUgUmFzdGVyXCIsXG5cdFx0aXRlbUZ1bmN0aW9uTmFtZTogXCJGdW7Dp8OjbyBkbyBJdGVtXCIsXG5cdFx0YWdncmVnYXRpb25GdW5jdGlvbk5hbWU6IFwiRnVuw6fDo28gZGUgQWdyZWdhw6fDo29cIixcblx0XHRwcm9jZXNzaW5nRnVuY3Rpb25OYW1lOiBcIkZ1bsOnw6NvIGRlIFByb2Nlc3NhbWVudG9cIixcblx0XHRhZ2dyZWdhdGlvbkRlZmluaXRpb25OYW1lOiBcIkRlZmluacOnw6NvIGRlIEFncmVnYcOnw6NvXCIsXG5cdFx0cXVlcnlHZW9tZXRyeU5hbWU6IFwiQ29uc3VsdGFyIGdlb21ldHJpYVwiLFxuXHRcdGZhY3RvckZ1bmN0aW9uWmVyb0ZhY3RvcjogXCJGYXRvciBaZXJvXCIsXG5cdFx0ZmFjdG9yRnVuY3Rpb25DdXRBbmdsZTogXCLDgm5ndWxvIGRlIENvcnRlXCIsXG5cdFx0ZmFjdG9yRnVuY3Rpb25TaWRlRmFjdG9yOiBcIkZhdG9yIExhdGVyYWxcIixcblx0XHRmYWN0b3JGdW5jdGlvblNsb3BlOiBcIkluY2xpbmHDp8Ojb1wiLFxuXHRcdGZhY3RvckZ1bmN0aW9uTG93Q3V0QW5nbGU6IFwiw4JuZ3VsbyBkZSBDb3J0ZSBCYWl4b1wiLFxuXHRcdGZhY3RvckZ1bmN0aW9uSGlnaEN1dEFuZ2xlOiBcIsOCbmd1bG8gZGUgQ29ydGUgQWx0b1wiLFxuXHRcdGZhY3RvckZ1bmN0aW9uQ29zUG93ZXI6IFwiUG90w6puY2lhIGRvIENvc3Nlbm9cIixcblx0XHRmYWN0b3JGdW5jdGlvblNlY1Bvd2VyOiBcIlBvdMOqbmNpYSBkYSBTZWNhbnRlXCIsXG5cdFx0ZmFjdG9yRnVuY3Rpb25UYWJsZVBhdGg6IFwiQ2FtaW5obyBkYSBUYWJlbGFcIixcblx0XHRwcm9jZXNzaW5nQmFuZDogXCJCYW5kYSBkZSBQcm9jZXNzYW1lbnRvXCIsXG5cdFx0cHJvY2Vzc2luZ0JhbmROYW1lOiBcIk5vbWUgZGEgQmFuZGEgZGUgUHJvY2Vzc2FtZW50b1wiLFxuXHRcdHNuYXBwaW5nRGF0ZTogXCJBanVzdGFyIERhdGFcIixcblx0XHRtYXhOdW1TZWdtZW50czogXCJOw7ptZXJvIE3DoXhpbW8gZGUgU2VnbWVudG9zXCIsXG5cdFx0dmVydGV4Q291bnRPdmVyc2hvb3Q6IFwiT3ZlcnNob290IGRlIENvbnRhZ2VtIGRlIFbDqXJ0aWNlc1wiLFxuXHRcdHNwaWtlVGhyZXNob2xkOiBcIkxpbWlhciBkZSBTcGlrZVwiLFxuXHRcdHJlY292ZXJ5VGhyZXNob2xkOiBcIkxpbWlhciBkZSBSZWN1cGVyYcOnw6NvXCIsXG5cdFx0bWluTnVtT2JzOiBcIk7Dum1lcm8gTcOtbmltbyBkZSBPYnNlcnZhw6fDtWVzXCIsXG5cdFx0cFZhbHVlVGhyZXNob2xkOiBcIkxpbWlhciBkZSBWYWxvciBQXCIsXG5cdFx0YmVzdE1vZGVsUHJvcG9ydGlvbjogXCJNZWxob3IgUHJvcG9yw6fDo28gZGUgTW9kZWxvXCIsXG5cdFx0cHJldmVudE9uZVllYXJSZWNvdmVyeTogXCJQcmV2ZW5pciBSZWN1cGVyYcOnw6NvIGRlIFVtIEFub1wiLFxuXHRcdHJlY292ZXJ5SW5jcmVhc2VUcmVuZDogXCJSZWN1cGVyYcOnw6NvIGNvbSBUZW5kw6puY2lhIENyZXNjZW50ZVwiLFxuXHRcdG91dHB1dE90aGVyQmFuZHM6IFwiU2HDrWRhIGRlIE91dHJhcyBCYW5kYXNcIixcblx0XHRzb3J0VHlwZTogXCJUaXBvIGRlIE9yZGVuYcOnw6NvXCIsXG5cdFx0bnVtYmVyT2ZSdW5zOiBcIkV4ZWN1dGFyIGV4cGFuc8OjbyBlIHJlZHXDp8OjbyBkdWFzIHZlemVzXCIsXG5cdFx0cGVyY2VudGlsZVZhbHVlOiBcIlZhbG9yIGRlIFBlcmNlbnRpbFwiLFxuXHRcdHBlcmNlbnRpbGVJbnRlcnBvbGF0aW9uVHlwZTogXCJUaXBvIGRlIGludGVycG9sYcOnw6NvIGRlIHBlcmNlbnRpbFwiLFxuXHRcdHJhc3RlckluZm9Qcm9wZXJ0eTogXCJQcm9wcmllZGFkZVwiLFxuXHRcdHJhc3RlckluZm9WYWx1ZTogXCJWYWxvclwiLFxuXHRcdHJhc3RlckluZm9Db2x1bW5zOiBcIkNvbHVuYXNcIixcblx0XHRyYXN0ZXJJbmZvUm93czogXCJMaW5oYXNcIixcblx0XHRyYXN0ZXJJbmZvQmFuZENvdW50OiBcIk7Dum1lcm8gZGUgQmFuZGFzXCIsXG5cdFx0cmFzdGVySW5mb1BpeGVsU2l6ZVg6IFwiVGFtYW5obyBkYSBDw6lsdWxhIFhcIixcblx0XHRyYXN0ZXJJbmZvUGl4ZWxTaXplWTogXCJUYW1hbmhvIGRhIEPDqWx1bGEgWVwiLFxuXHRcdHJhc3RlckluZm9QaXhlbFR5cGU6IFwiVGlwbyBkZSBQw614ZWxcIixcblx0XHRyYXN0ZXJFeHRlbnRUb3A6IFwiU3VwZXJpb3JcIixcblx0XHRyYXN0ZXJFeHRlbnRCb3R0b206IFwiSW5mZXJpb3JcIixcblx0XHRyYXN0ZXJFeHRlbnRMZWZ0OiBcIkVzcXVlcmRhXCIsXG5cdFx0cmFzdGVyRXh0ZW50UmlnaHQ6IFwiRGlyZWl0YVwiLFxuXHRcdHJhc3RlclN0YXRpc3RpY3NOb3RDYWxjdWxhdGVkOiBcIkFzIGVzdGF0w61zdGljYXMgbsOjbyBmb3JhbSBjYWxjdWxhZGFzLlwiLFxuXHRcdHNwYXRpYWxSZWZlcmVuY2VQcm9qZWN0aW9uOiBcIlByb2plw6fDo29cIixcblx0XHRzcGF0aWFsUmVmZXJlbmNlV2tpZDogXCJXS0lEXCIsXG5cdFx0c3BhdGlhbFJlZmVyZW5jZUxhdGVzdFdraWQ6IFwiV0tJRCBhbnRlcmlvclwiLFxuXHRcdHNwYXRpYWxSZWZlcmVuY2VXa3Q6IFwiV0tUXCIsXG5cdFx0c3BhdGlhbFJlZmVyZW5jZVZjc1draWQ6IFwiVkNTV0tJRFwiLFxuXHRcdHNwYXRpYWxSZWZlcmVuY2VMYXRlc3RWY3NXa2lkOiBcIlZDU1dLSUQgYW50ZXJpb3JcIixcblx0XHRzcGF0aWFsUmVmZXJlbmNlQXV0aG9yaXR5OiBcIkF1dG9yaWRhZGVcIixcblx0XHRzcGF0aWFsUmVmZXJlbmNlTGluZWFyVW5pdDogXCJVbmlkYWRlIExpbmVhclwiLFxuXHRcdHNwYXRpYWxSZWZlcmVuY2VBbmd1bGFyVW5pdDogXCJVbmlkYWRlIEFuZ3VsYXJcIixcblx0XHRzcGF0aWFsUmVmZXJlbmNlRmFsc2VFYXN0aW5nOiBcIkZhbHNvIEF2YW7Dp28gcGFyYSBFc3RlXCIsXG5cdFx0c3BhdGlhbFJlZmVyZW5jZUZhbHNlTm9ydGhpbmc6IFwiRmFsc28gQXZhbsOnbyBwYXJhIE5vcnRlXCIsXG5cdFx0c3BhdGlhbFJlZmVyZW5jZUNlbnRyYWxNZXJpZGlhbjogXCJNZXJpZGlhbm8gQ2VudHJhbFwiLFxuXHRcdHNwYXRpYWxSZWZlcmVuY2VQcmltZU1lcmlkaWFuOiBcIk1lcmlkaWFubyBQcmluY2lwYWxcIixcblx0XHRzcGF0aWFsUmVmZXJlbmNlU3RhbmRhcmRQYXJhbGxlbDE6IFwiUGFyYWxlbGEgU3RhbmRhcmQgMVwiLFxuXHRcdHNwYXRpYWxSZWZlcmVuY2VTdGFuZGFyZFBhcmFsbGVsMjogXCJQYXJhbGVsYSBTdGFuZGFyZCAyXCIsXG5cdFx0c3BhdGlhbFJlZmVyZW5jZUxhdGl0dWRlT2ZPcmlnaW46IFwiTGF0aXR1ZGUgZGEgT3JpZ2VtXCIsXG5cdFx0c3BhdGlhbFJlZmVyZW5jZUF1eGlsaWFyeVNwaGVyZVR5cGU6IFwiVGlwbyBkZSBFc2ZlcmEgQXV4aWxpYXJcIixcblx0XHRzcGF0aWFsUmVmZXJlbmNlRGF0dW06IFwiRGF0dW1cIixcblx0XHRzcGF0aWFsUmVmZXJlbmNlU3BoZXJvaWQ6IFwiRXNmZXJvaWRlXCIsXG5cdFx0c3BhdGlhbFJlZmVyZW5jZVNlbWltYWpvckF4aXM6IFwiRWl4byBTZW1pLU1haW9yXCIsXG5cdFx0c3BhdGlhbFJlZmVyZW5jZVNlbWltaW5vckF4aXM6IFwiRWl4byBTZW1pLU1lbm9yXCIsXG5cdFx0c3BhdGlhbFJlZmVyZW5jZUludmVyc2VGbGF0dGVuaW5nOiBcIkFjaGF0YW1lbnRvIEludmVyc29cIixcblx0XHRpbnB1dERlZmluaXRpb25GaWxlTmFtZTogXCJGaWNoZWlybyBkZSBEZWZpbmnDp8OjbyBkZSBFbnRyYWRhXCIsXG5cdFx0ZGVsZXRlTmFtZTogXCJFbGltaW5hclwiLFxuXHRcdGFkZFZhcmlhYmxlTmFtZTogXCJBZGljaW9uYXIgdmFyacOhdmVsXCIsXG5cdFx0bWF4TnVtUGl4ZWxzUGVyU2VnbWVudDogXCJUYW1hbmhvIGRlIFNlZ21lbnRvIE3DoXhpbW8gZW0gUMOteGVpc1wiLFxuXHRcdGZvcndhcmRXaW5kb3dOYW1lOiBcIkphbmVsYSBQb3N0ZXJpb3JcIixcblx0XHRiYWNrd2FyZFdpbmRvd05hbWU6IFwiSmFuZWxhIEFudGVyaW9yXCIsXG5cdFx0bm9EYXRhSGFuZGxpbmdOYW1lOiBcIkdlc3TDo28gZGUgTm9EYXRhXCIsXG5cdFx0Y2lyY3VsYXJXcmFwVmFsdWVOYW1lOiBcIlZhbG9yIGRlIE1vbGRhZ2VtIENpcmN1bGFyXCIsXG5cdFx0ZnJvbUNsYXNzTmFtZUZpZWxkTmFtZTogXCJOb21lIGRvIENhbXBvIFBhcmEgTm9tZXMgZGUgQ2xhc3NlcyBEZSBSYXN0ZXJcIixcblx0XHR0b0NsYXNzTmFtZUZpZWxkTmFtZTogXCJOb21lIGRvIENhbXBvIFBhcmEgTm9tZXMgZGUgQ2xhc3NlcyBQYXJhIG8gUmFzdGVyXCIsXG5cdFx0dGFyZ2V0UmFzdGVyTmFtZTogXCJSYXN0ZXIgZGUgRGVzdGlub1wiLFxuXHRcdGNpcmN1bGFyV3JhcFZhbHVlOiBcIlZhbG9yIGRlIE1vbGRhZ2VtIENpcmN1bGFyXCIsXG5cdFx0YmFuZEluZGV4ZXNSOiBcIkV4cHJlc3PDo28gVmVybWVsaGFcIixcblx0XHRiYW5kSW5kZXhlc0c6IFwiRXhwcmVzc8OjbyBWZXJkZVwiLFxuXHRcdGJhbmRJbmRleGVzQjogXCJFeHByZXNzw6NvIEF6dWxcIixcblx0XHRleGFtcGxlTmFtZTogXCJFeGVtcGxvXCIsXG5cdFx0aW5wdXROYW1lOiBcIkludHJvZHXDp8Ojb1wiLFxuXHRcdG91dHB1dE5hbWU6IFwiU2HDrWRhXCIsXG5cdFx0b3B0aW9uYWxOYW1lOiBcIk9wY2lvbmFsXCIsXG5cdFx0YnJvd3NlRGVmaW5pdGlvbkZpbGU6IFwiUHJvY3VyYXIgRmljaGVpcm8gZGUgRGVmaW5pw6fDo29cIixcblx0XHRzZWxlY3REZWZpbml0aW9uRmlsZTogXCJTZWxlY2lvbmFyIEZpY2hlaXJvIGRlIERlZmluacOnw6NvIGRlIEVudHJhZGFcIixcblx0XHRpbnB1dERlZmluaXRpb25VUkw6IFwiVVJMIGRlIEZpY2hlaXJvIGRlIERlZmluacOnw6NvIGRlIEVudHJhZGFcIixcblx0XHRlbnRlckRlZmluaXRpb25GaWxlVVJMOiBcIkludHJvZHV6aXIgVVJMIGRlIEZpY2hlaXJvIGRlIERlZmluacOnw6NvXCIsXG5cdFx0YnJvd3NlWE1MRmlsZTogXCJQcm9jdXJhciBGaWNoZWlybyBYTUxcIixcblx0XHRzZWxlY3RTdGF0c0ZpbGU6IFwiU2VsZWNpb25hciBGaWNoZWlybyBkZSBFc3RhdMOtc3RpY2FzIGUgSGlzdG9ncmFtYXNcIixcblx0XHRlbnRlclhNTEZpbGVVUkw6IFwiSW50cm9kdXppciBVUkwgZGUgRmljaGVpcm8gWE1MXCIsXG5cdFx0eG1sRmlsZVVSTDogXCJVUkwgZGUgRmljaGVpcm8gWE1MXCIsXG5cdFx0Y2lyY3VsYXJDYWxjdWxhdGlvbjogXCJDYWxjdWxhciBFc3RhdMOtc3RpY2FzIENpcmN1bGFyZXNcIixcblx0XHRsb2NhbFN1cmZhY2VUeXBlOiBcIlRpcG8gZGUgU3VwZXJmw61jaWUgTG9jYWxcIixcblx0XHRzdXJmYWNlUGFyYW1ldGVyVHlwZTogXCJUaXBvIGRlIFBhcsOibWV0cm9cIixcblx0XHRuZWlnaGJvcmhvb2REaXN0YW5jZTogXCJEaXN0w6JuY2lhIGRlIFZpemluaGFuw6dhXCIsXG5cdFx0dXNlQWRhcHRpdmVOZWlnaGJvcmhvb2Q6IFwiVXNhciBWaXppbmhhbsOnYSBBZGFwdGF0aXZhXCIsXG5cdFx0b3V0cHV0U2xvcGVUeXBlOiBcIk1lZGnDp8OjbyBkZSBEZWNsaXZlIGRlIFNhw61kYVwiLFxuXHRcdHByb2plY3RBemltdXRoczogXCJBemltdXRlcyBHZW9kw6lzaWNvcyBkbyBQcm9qZXRvXCIsXG5cdFx0dXNlRXF1YXRvcmlhbEFzcGVjdDogXCJVc2FyIEFzcGV0byBFcXVhdG9yaWFsXCIsXG5cdFx0elVuaXQ6IFwiVW5pZGFkZSBaXCIsXG5cdFx0YW5hbHlzaXNNYXNrOiBcIk3DoXNjYXJhIGRlIEFuw6FsaXNlXCIsXG5cdFx0c3RkRGV2aWF0aW9uOiBcIkRlc3ZpbyBQYWRyw6NvXCIsXG5cdFx0XCJ0cnVlXCI6IFwiVmVyZGFkZWlyb1wiLFxuXHRcdFwiZmFsc2VcIjogXCJGYWxzb1wiLFxuXHRcdGNvc3REaXN0YW5jZVJhc3RlcjE6IFwiUmFzdGVyIGRlIERpc3TDom5jaWEgZGUgQ3VzdG8gQWN1bXVsYXRpdm8gZGUgRW50cmFkYSAxXCIsXG5cdFx0Y29zdERpc3RhbmNlUmFzdGVyMjogXCJSYXN0ZXIgZGUgRGlzdMOibmNpYSBkZSBDdXN0byBBY3VtdWxhdGl2byBkZSBFbnRyYWRhIDJcIixcblx0XHR0aHJlc2hvbGQ6IFwiTGltaWFyXCIsXG5cdFx0dGhyZXNob2xkTWV0aG9kOiBcIk3DqXRvZG8gZGUgTGltaWFyXCIsXG5cdFx0ZGlyZWN0aW9uUmFzdGVyMTogXCJSYXN0ZXIgZGUgRGlyZcOnw6NvIGRlIFJldG9ybm8gZGUgRW50cmFkYSAxXCIsXG5cdFx0ZGlyZWN0aW9uUmFzdGVyMjogXCJSYXN0ZXIgZGUgRGlyZcOnw6NvIGRlIFJldG9ybm8gZGUgRW50cmFkYSAyXCIsXG5cdFx0bWF4SXRlcmF0aW9uczogXCJOw7ptZXJvIE3DoXhpbW8gZGUgSXRlcmHDp8O1ZXNcIixcblx0XHRlcHNpbG9uOiBcIkVwc2lsb25cIlxuXHR9LFxuXHRlbnVtTGFiZWxzOiB7XG5cdFx0YXR0cmlidXRlVGFibGVUeXBlTWFudWFsOiBcIk1hbnVhbFwiLFxuXHRcdGF0dHJpYnV0ZVRhYmxlVHlwZUV4dGVybmFsOiBcIkV4dGVybm9cIixcblx0XHRjbHJTY2hlbWVUeXBlQ29sb3JtYXA6IFwiTWFwYSBkZSBDb3Jlc1wiLFxuXHRcdGNsclNjaGVtZVR5cGVDb2xvclJhbXA6IFwiUmFtcGEgZGUgQ29yZXNcIixcblx0XHRjb2xvcm1hcFR5cGVFbGV2YXRpb246IFwiRWxldmHDp8Ojb1wiLFxuXHRcdGNvbG9ybWFwVHlwZUdyYXk6IFwiQ2luemFcIixcblx0XHRjb2xvcm1hcFR5cGVORFZJOiBcIk5EVklcIixcblx0XHRjb2xvcm1hcFR5cGVORFZJMjogXCJORFZJMlwiLFxuXHRcdGNvbG9ybWFwVHlwZU5EVkkzOiBcIk5EVkkzXCIsXG5cdFx0Y29sb3JtYXBUeXBlUmFuZG9tOiBcIkFsZWF0w7NyaW9cIixcblx0XHRub25lOiBcIk5lbmh1bVwiLFxuXHRcdHNsb3BlVHlwZUFkanVzdGVkOiBcIkFqdXN0YWRvXCIsXG5cdFx0c2xvcGVUeXBlRGVncmVlOiBcIkdyYXVcIixcblx0XHRzbG9wZVR5cGVQZXJjZW50UmlzZTogXCJQZXJjZW50UmlzZVwiLFxuXHRcdHNsb3BlVHlwZVNjYWxlZDogXCJEaW1lbnNpb25hZG9cIixcblx0XHRzdHJldGNoVHlwZU1pbk1heDogXCJNaW5NYXhcIixcblx0XHRzdHJldGNoVHlwZVBlcmNlbnRNaW5NYXg6IFwiUGVyY2VudE1pbk1heFwiLFxuXHRcdHN0cmV0Y2hUeXBlU2lnbW9pZDogXCJTaWdtw7NpZGVcIixcblx0XHRzdHJldGNoVHlwZVN0ZERldjogXCJTdGREZXZcIixcblx0XHRoaWxsc2hhZGVUeXBlU2ltcGxlOiBcIlRyYWRpY2lvbmFsXCIsXG5cdFx0aGlsbHNoYWRlVHlwZU11bHRpZGlyZWN0aW9uYWw6IFwiTXVsdGlkaXJlY2lvbmFsXCIsXG5cdFx0YmFuZENvbWJvQnlOYW1lczogXCJOb21lcyBkZSBCYW5kYXNcIixcblx0XHRiYW5kQ29tYm9CeVdhdmVsZW5ndGg6IFwiQ29tcHJpbWVudG9zIGRlIE9uZGEgZGUgQmFuZGFzXCIsXG5cdFx0YmFuZENvbWJvQnlJRHM6IFwiSWRzIGRlIEJhbmRhc1wiLFxuXHRcdG1pc3NpbmdCYW5kQWN0aW9uQmVzdE1hdGNoOiBcIk1lbGhvciBDb3JyZXNwb25kw6puY2lhXCIsXG5cdFx0bWlzc2luZ0JhbmRBY3Rpb25GYWlsOiBcIkZhbGhhXCIsXG5cdFx0dW5pdFR5cGVDZWxzaXVzOiBcIkNlbHNpdXNcIixcblx0XHR1bml0VHlwZUNlbnRpbWV0ZXJzOiBcIkNlbnTDrW1ldHJvc1wiLFxuXHRcdHVuaXRUeXBlRGVjaW1ldGVyczogXCJEZWPDrW1ldHJvc1wiLFxuXHRcdHVuaXRUeXBlRmFocmVuaGVpdDogXCJGYWhyZW5oZWl0XCIsXG5cdFx0dW5pdFR5cGVGZWV0OiBcIlDDqXNcIixcblx0XHR1bml0VHlwZUZlZXRQZXJTZWM6IFwiUMOpcyBQb3IgU2VndW5kbyAocMOpcy9zKVwiLFxuXHRcdHVuaXRUeXBlSW5jaGVzOiBcIlBvbGVnYWRhc1wiLFxuXHRcdHVuaXRUeXBlS2VsdmluOiBcIktlbHZpblwiLFxuXHRcdHVuaXRUeXBlS2lsb21ldGVyczogXCJRdWlsw7NtZXRyb3NcIixcblx0XHR1bml0VHlwZUttc1BlckhvdXI6IFwiUXVpbMOzbWV0cm9zIFBvciBIb3JhIChrbS9oKVwiLFxuXHRcdHVuaXRUeXBlS25vdHM6IFwiTsOzcyAoa24pXCIsXG5cdFx0dW5pdFR5cGVNZXRlcnM6IFwiTWV0cm9zXCIsXG5cdFx0dW5pdFR5cGVNZXRlcnNQZXJTZWM6IFwiTWV0cm9zIFBvciBTZWd1bmRvIChtL3MpXCIsXG5cdFx0dW5pdFR5cGVNaWxlczogXCJNaWxoYXNcIixcblx0XHR1bml0VHlwZU1pbGVzUGVySG91cjogXCJNaWxoYXMgUG9yIEhvcmEgKG1waClcIixcblx0XHR1bml0VHlwZU1pbGxpbWV0ZXJzOiBcIk1pbMOtbWV0cm9zXCIsXG5cdFx0dW5pdFR5cGVOYXV0aWNhbE1pbGVzOiBcIk1pbGhhcyBOw6F1dGljYXNcIixcblx0XHR1bml0VHlwZVlhcmRzOiBcIkphcmRhc1wiLFxuXHRcdHVuaXRUeXBlRGVjaW1hbERlZ3JlZXM6IFwiR3JhdXMgZGVjaW1haXNcIixcblx0XHR1bml0VHlwZVBvaW50czogXCJQb250b3NcIixcblx0XHR1bml0VHlwZVVua25vd246IFwiRGVzY29uaGVjaWRvXCIsXG5cdFx0dW5pdFR5cGVTcU1hcFVuaXRzOiBcIlVuaWRhZGVzIFF1YWRyYWRhcyBkZSBNYXBhXCIsXG5cdFx0dW5pdFR5cGVTcU1pbGVzOiBcIk1pbGhhcyBRdWFkcmFkYXNcIixcblx0XHR1bml0VHlwZVNxS21zOiBcIlF1aWzDs21ldHJvcyBRdWFkcmFkb3NcIixcblx0XHR1bml0VHlwZUFjcmVzOiBcIkFjcmVzXCIsXG5cdFx0dW5pdFR5cGVIZWN0YXJlczogXCJIZWN0YXJlc1wiLFxuXHRcdHVuaXRUeXBlU3FZYXJkczogXCJKYXJkYXMgUXVhZHJhZGFzXCIsXG5cdFx0dW5pdFR5cGVTcUZ0OiBcIlDDqXMgUXVhZHJhZG9zXCIsXG5cdFx0dW5pdFR5cGVTcUluY2hlczogXCJQb2xlZ2FkYXMgUXVhZHJhZGFzXCIsXG5cdFx0dW5pdFR5cGVTcU10czogXCJNZXRyb3MgUXVhZHJhZG9zXCIsXG5cdFx0dW5pdFR5cGVTcUNtczogXCJDZW50aW1ldHJvcyBRdWFkcmFkb3NcIixcblx0XHR1bml0VHlwZVNxTW1zOiBcIk1pbGltZXRyb3MgUXVhZHJhZG9zXCIsXG5cdFx0Y2VsbHNpemVUeXBlRmlyc3Q6IFwiUHJpbWVpcm8gRGVcIixcblx0XHRjZWxsc2l6ZVR5cGVNaW46IFwiTcOtbi4gRGVcIixcblx0XHRjZWxsc2l6ZVR5cGVNYXg6IFwiTcOheC4gRGVcIixcblx0XHRjZWxsc2l6ZVR5cGVNZWFuOiBcIk3DqWRpYSBEZVwiLFxuXHRcdGNlbGxzaXplVHlwZUxhc3Q6IFwiw5psdGltbyBEZVwiLFxuXHRcdGV4dGVudFR5cGVGaXJzdDogXCJQcmltZWlybyBEZVwiLFxuXHRcdGV4dGVudFR5cGVJbnRlcnNlY3Rpb246IFwiSW50ZXJzZWPDp8OjbyBEZVwiLFxuXHRcdGV4dGVudFR5cGVVbmlvbjogXCJVbmnDo28gRGVcIixcblx0XHRleHRlbnRUeXBlTGFzdDogXCLDmmx0aW1vIERlXCIsXG5cdFx0bm9EYXRhSW50ZXJwcmV0QW55OiBcIkNvcnJlc3BvbmRlciBRdWFscXVlclwiLFxuXHRcdG5vRGF0YUludGVycHJldEFsbDogXCJDb3JyZXNwb25kZXIgVG9kb3NcIixcblx0XHRjdXJ2YXR1cmVUeXBlU3RhbmRhcmQ6IFwiU3RhbmRhcmRcIixcblx0XHRjdXJ2YXR1cmVUeXBlUHJvZmlsZTogXCJQZXJmaWxcIixcblx0XHRjdXJ2YXR1cmVUeXBlUGxhbmZvcm06IFwiQXNhXCIsXG5cdFx0ZmlsdGVyVHlwZUxpbmVEZXRlY3Rpb25Ib3Jpem9udGFsOiBcIkRldGXDp8OjbyBkZSBMaW5oYSBIb3Jpem9udGFsXCIsXG5cdFx0ZmlsdGVyVHlwZUxpbmVEZXRlY3Rpb25WZXJ0aWNhbDogXCJEZXRlw6fDo28gZGUgTGluaGEgVmVydGljYWxcIixcblx0XHRmaWx0ZXJUeXBlTGluZURldGVjdGlvbkxlZnREaWFnb25hbDogXCJEZXRlw6fDo28gZGUgTGluaGEgRGlhZ29uYWwgRXNxdWVyZGFcIixcblx0XHRmaWx0ZXJUeXBlTGluZURldGVjdGlvblJpZ2h0RGlhZ29uYWw6IFwiRGV0ZcOnw6NvIGRlIExpbmhhIERpYWdvbmFsIERpcmVpdGFcIixcblx0XHRmaWx0ZXJUeXBlR3JhZGllbnROb3J0aDogXCJHcmFkaWVudGUgTm9ydGVcIixcblx0XHRmaWx0ZXJUeXBlR3JhZGllbnRXZXN0OiBcIkdyYWRpZW50ZSBPZXN0ZVwiLFxuXHRcdGZpbHRlclR5cGVHcmFkaWVudEVhc3Q6IFwiR3JhZGllbnRlIEVzdGVcIixcblx0XHRmaWx0ZXJUeXBlR3JhZGllbnRTb3V0aDogXCJHcmFkaWVudGUgU3VsXCIsXG5cdFx0ZmlsdGVyVHlwZUdyYWRpZW50Tm9ydGhFYXN0OiBcIkdyYWRpZW50ZSBOb3JkZXN0ZVwiLFxuXHRcdGZpbHRlclR5cGVHcmFkaWVudE5vcnRoV2VzdDogXCJHcmFkaWVudGUgTm9yb2VzdGVcIixcblx0XHRmaWx0ZXJUeXBlU21vb3RoQXJpdGhtZXRpY01lYW46IFwiTcOpZGlhIEFyaXRtw6l0aWNhIFVuaWZvcm1lXCIsXG5cdFx0ZmlsdGVyVHlwZVNtb290aGluZzN4MzogXCJBIHVuaWZvcm1pemFyIDN4M1wiLFxuXHRcdGZpbHRlclR5cGVTbW9vdGhpbmc1eDU6IFwiQSB1bmlmb3JtaXphciA1eDVcIixcblx0XHRmaWx0ZXJUeXBlU2hhcnBlbmluZzN4MzogXCJBIGFwZXJmZWnDp29hciAzeDNcIixcblx0XHRmaWx0ZXJUeXBlU2hhcnBlbmluZzV4NTogXCJBIGFwZXJmZWnDp29hciA1eDVcIixcblx0XHRmaWx0ZXJUeXBlTGFwbGFjaWFuM3gzOiBcIkxhcGxhY2lhbm8gM3gzXCIsXG5cdFx0ZmlsdGVyVHlwZUxhcGxhY2lhbjV4NTogXCJMYXBsYWNpYW5vIDV4NVwiLFxuXHRcdGZpbHRlclR5cGVTb2JlbEhvcml6b250YWw6IFwiU29iZWwgSG9yaXpvbnRhbFwiLFxuXHRcdGZpbHRlclR5cGVTb2JlbFZlcnRpY2FsOiBcIlNvYmVsIFZlcnRpY2FsXCIsXG5cdFx0ZmlsdGVyVHlwZVNoYXJwZW46IFwiQXBlcmZlacOnb2FyXCIsXG5cdFx0ZmlsdGVyVHlwZVNoYXJwZW4yOiBcIkFjZW50dWFyIG1haXNcIixcblx0XHRmaWx0ZXJUeXBlUG9pbnRTcHJlYWQ6IFwiRGlzcGVyc8OjbyBkZSBQb250b3NcIixcblx0XHR1c2VyRGVmaW5lZDogXCJEZWZpbmlkbyBwb3IgVXRpbGl6YWRvclwiLFxuXHRcdENvbnRvdXJUeXBlTGluZXM6IFwiTGluaGFzIGRlIENvbnRvcm5vXCIsXG5cdFx0Q29udG91clR5cGVGaWxsOiBcIlByZWVuY2hpbWVudG8gZGUgQ29udG9ybm9cIixcblx0XHRDb250b3VyVHlwZVNtb290aE9ubHk6IFwiQXBlbmFzIFN1cGVyZsOtY2llIFN1YXZlXCIsXG5cdFx0cmFzdGVyaXplRmlyc3Q6IFwiUHJpbWVpcm9cIixcblx0XHRyYXN0ZXJpemVMYXN0OiBcIsOabHRpbW9cIixcblx0XHRyYXN0ZXJpemVTbWFsbGVzdDogXCJNZW5vclwiLFxuXHRcdHJhc3Rlcml6ZUxhcmdlc3Q6IFwiTWFpb3JcIixcblx0XHRyZXNhbXBsaW5nVHlwZU5lYXJlc3Q6IFwiVml6aW5obyBtYWlzIHByw7N4aW1vXCIsXG5cdFx0cmVzYW1wbGluZ1R5cGVCaWxpbmVhcjogXCJJbnRlcnBvbGHDp8OjbyBCaWxpbmVhclwiLFxuXHRcdHJlc2FtcGxpbmdUeXBlQ3ViaWM6IFwiQ29udm9sdcOnw6NvIEPDumJpY2FcIixcblx0XHRyZXNhbXBsaW5nVHlwZU1ham9yaXR5OiBcIk1haW9yaWFcIixcblx0XHRyZXNhbXBsaW5nVHlwZUJpbGluZWFyUGx1czogXCJJbnRlcnBvbGHDp8OjbyBCaWxpbmVhciBQbHVzXCIsXG5cdFx0cmVzYW1wbGluZ1R5cGVHYXVzczogXCJHYXVzcyBCbHVyXCIsXG5cdFx0cmVzYW1wbGluZ1R5cGVHYXVzc1BsdXM6IFwiR2F1c3MgQmx1ciBQbHVzXCIsXG5cdFx0cmVzYW1wbGluZ1R5cGVBdmVyYWdlOiBcIk3DqWRpYVwiLFxuXHRcdHJlc2FtcGxpbmdUeXBlTWluaW11bTogXCJNw61uaW1vXCIsXG5cdFx0cmVzYW1wbGluZ1R5cGVNYXhpbXVtOiBcIk3DoXhpbW9cIixcblx0XHRyZXNhbXBsaW5nVHlwZVZlY3RvckF2ZzogXCJNw6lkaWEgZGUgVmV0b3Jlc1wiLFxuXHRcdG1pbmltdW06IFwiTcOtbmltb1wiLFxuXHRcdG1heGltdW06IFwiTcOheGltb1wiLFxuXHRcdG1lYW46IFwiTcOpZGlhXCIsXG5cdFx0c3RkRGV2aWF0aW9uOiBcIkRlc3ZpbyBQYWRyw6NvXCIsXG5cdFx0dXZNYWdEaXJUeXBlVVY6IFwiVS1WXCIsXG5cdFx0dXZNYWdEaXJUeXBlTWFnRGlyOiBcIk1hZ25pdHVkZS1EaXJlw6fDo29cIixcblx0XHR1bmtub3duOiBcIkRlc2NvbmhlY2lkb1wiLFxuXHRcdGFuZ2xlUmVmU3lzR2VvZ3JhcGhpYzogXCJHZW9ncsOhZmljb3NcIixcblx0XHRhbmdsZVJlZlN5c0FyaXRobWV0aWM6IFwiQXJpdG3DqXRpY29zXCIsXG5cdFx0aW50ZXJwb2xhdGVJcnJlZ3VsYXJEYXRhTmVhcmVzdDogXCJWaXppbmhvIG1haXMgcHLDs3hpbW9cIixcblx0XHRpbnRlcnBvbGF0ZUlycmVndWxhckRhdGFCaWxpbmVhcjogXCJCaWxpbmVhclwiLFxuXHRcdGludGVycG9sYXRlSXJyZWd1bGFyRGF0YVRpbm5pbmdMaW5lYXI6IFwiRXN0YW5oYWdlbSBsaW5lYXJcIixcblx0XHRpbnRlcnBvbGF0ZUlycmVndWxhckRhdGFUaW5uaW5nTmF0dXJhbE5laWdoYm9yOiBcIlZpemluaG8gbmF0dXJhbFwiLFxuXHRcdGludGVycG9sYXRlSXJyZWd1bGFyRGF0YVRpbm5pbmdJRFc6IFwiRGlzdMOibmNpYSBpbnZlcnNhIHBlc2FkYVwiLFxuXHRcdGVzcmlSYXN0ZXJUaHJlc2hvbGRUeXBlQ29uc3RhbnQ6IFwiQ29uc3RhbnRlXCIsXG5cdFx0ZXNyaVJhc3RlclRocmVzaG9sZFR5cGVPdHN1OiBcIk90c3VcIixcblx0XHRlc3JpUmFzdGVyVGhyZXNob2xkVHlwZVRzYWk6IFwiVHNhaVwiLFxuXHRcdGVzcmlSYXN0ZXJUaHJlc2hvbGRUeXBlS2FwdXI6IFwiS2FwdXJcIixcblx0XHRlc3JpUmFzdGVyVGhyZXNob2xkVHlwZUtpdHRsZXI6IFwiS2l0dGxlclwiLFxuXHRcdGVzcmlSYXN0ZXJUaHJlc2hvbGRUeXBlUm9zaW46IFwiUm9zaW5cIixcblx0XHRhcmdTdGF0c1R5cGVNYXg6IFwiTcOheC4gQXJnXCIsXG5cdFx0YXJnU3RhdHNUeXBlTWluOiBcIk3DrW4gQXJnXCIsXG5cdFx0YXJnU3RhdHNUeXBlTWVkaWFuOiBcIk1lZGlhbmEgQXJnXCIsXG5cdFx0YXJnU3RhdHNUeXBlRHVyYXRpb246IFwiRHVyYcOnw6NvXCIsXG5cdFx0YXJpdGhtZXRpY09wUGx1czogXCJNYWlzXCIsXG5cdFx0YXJpdGhtZXRpY09wTWludXM6IFwiTWVub3NcIixcblx0XHRhcml0aG1ldGljT3BNdWx0aXBseTogXCJNdWx0aXBsaWNhclwiLFxuXHRcdGFyaXRobWV0aWNPcERpdmlkZTogXCJEaXZpZGlyXCIsXG5cdFx0YXJpdGhtZXRpY09wUG93ZXI6IFwiUG90w6puY2lhXCIsXG5cdFx0YXJpdGhtZXRpY09wTW9kZTogXCJNb2RvXCIsXG5cdFx0Y2xpcFR5cGVPdXRzaWRlOiBcIlJlY29ydGFyIEZvcmFcIixcblx0XHRjbGlwVHlwZUluc2lkZTogXCJSZWNvcnRhciBEZW50cm9cIixcblx0XHR5ZXM6IFwiU2ltXCIsXG5cdFx0bm86IFwiTsOjb1wiLFxuXHRcdGRlbnNpdGllczogXCJEZW5zaWRhZGVzXCIsXG5cdFx0ZXhwZWN0ZWRDb3VudHM6IFwiQ29udGFnZW5zIEV4cGVjdMOhdmVpc1wiLFxuXHRcdHBsYW5hcjogXCJwbGFuYXJcIixcblx0XHRnZW9kZXNpYzogXCJHZW9kw6lzaWNhXCIsXG5cdFx0ZWFjaENlbGw6IFwiQ2FkYSBDw6lsdWxhXCIsXG5cdFx0ZWFjaFpvbmU6IFwiQ2FkYSBab25hXCIsXG5cdFx0YmVzdFNpbmdsZTogXCJNZWxob3Igw5puaWNvXCIsXG5cdFx0YWxsU2lnaHRsaW5lczogXCJUb2RhcyBhcyBMaW5oYXMgZGUgVmlzw6NvXCIsXG5cdFx0cGVyaW1ldGVyU2lnaHRsaW5lczogXCJMaW5oYXMgZGUgdmlzw6NvIGRvIFBlcsOtbWV0cm9cIixcblx0XHRmcmVxdWVuY3k6IFwiRnJlcXXDqm5jaWFcIixcblx0XHRvYnNlcnZlcnM6IFwiT2JzZXJ2YWRvcmVzXCIsXG5cdFx0bWFqb3JpdHk6IFwiTWFpb3JpYVwiLFxuXHRcdG1lZGlhbjogXCJNZWRpYW5hXCIsXG5cdFx0bWlub3JpdHk6IFwiTWlub3JpYVwiLFxuXHRcdHBlcmNlbnRpbGU6IFwiUGVyY2VudGlsXCIsXG5cdFx0cmFuZ2U6IFwiSW50ZXJ2YWxvXCIsXG5cdFx0c3VtOiBcIlNvbWFcIixcblx0XHR2YXJpZXR5OiBcIlZhcmllZGFkZVwiLFxuXHRcdG5kdmk6IFwiTkRWSVwiLFxuXHRcdHNhdmk6IFwiU0FWSVwiLFxuXHRcdGJhbmRBcml0aG1ldGljTWV0aG9kVFNBVkk6IFwiU0FWSSBUcmFuc2Zvcm1hZG9cIixcblx0XHRiYW5kQXJpdGhtZXRpY01ldGhvZE1TQVZJOiBcIlNBVkkgTW9kaWZpY2Fkb1wiLFxuXHRcdGJhbmRBcml0aG1ldGljTWV0aG9kU3VsdGFuOiBcIkbDs3JtdWxhIGRlIFN1bHRhblwiLFxuXHRcdGdlbWk6IFwiR0VNSVwiLFxuXHRcdHB2aTogXCJQVklcIixcblx0XHRndmk6IFwiR1ZJIChMYW5kc2F0IFRNKVwiLFxuXHRcdHZhcmk6IFwiVkFSSVwiLFxuXHRcdHNyOiBcIlNSXCIsXG5cdFx0Z25kdmk6IFwiR05EVklcIixcblx0XHRuZHZpcmU6IFwiTkRWSXJlXCIsXG5cdFx0c3JyZTogXCJTUnJlXCIsXG5cdFx0bXR2aTI6IFwiTVRWSTJcIixcblx0XHRydHZpQ29yZTogXCJSVFZJQ29yZVwiLFxuXHRcdGNpcmU6IFwiQ0lyZVwiLFxuXHRcdGNpZzogXCJDSWdcIixcblx0XHRuZHdpOiBcIk5EV0lcIixcblx0XHRldmk6IFwiRVZJXCIsXG5cdFx0aXJvbk94aWRlOiBcIsOTeGlkbyBkZSBGZXJyb1wiLFxuXHRcdGZlcnJvdXNNaW5lcmFsczogXCJNaW5lcmFpcyBGZXJyb3Nvc1wiLFxuXHRcdGNsYXlNaW5lcmFsczogXCJNaW5lcmFpcyBkZSBBcmdpbGFcIixcblx0XHR3bmR3aTogXCJXTkRXSVwiLFxuXHRcdGJhaTogXCJCQUlcIixcblx0XHRtbmR3aTogXCJNTkRXSVwiLFxuXHRcdG5icjogXCJOQlJcIixcblx0XHRuZGJpOiBcIk5EQklcIixcblx0XHRuZG1pOiBcIk5ETUlcIixcblx0XHRuZHNpOiBcIk5EU0lcIixcblx0XHRsb2NhbFNxdWFyZVJvb3Q6IFwiUmFpeiBRdWFkcmFkYVwiLFxuXHRcdGxvY2FsQUNvczogXCJBQ29zXCIsXG5cdFx0bG9jYWxBU2luOiBcIkFTaW5cIixcblx0XHRsb2NhbEFUYW46IFwiQVRhblwiLFxuXHRcdGxvY2FsQVRhbkg6IFwiQVRhbkhcIixcblx0XHRsb2NhbEFiczogXCJBYnNcIixcblx0XHRsb2NhbEJpdHdpc2VOb3Q6IFwiQml0d2lzZSBOw6NvXCIsXG5cdFx0bG9jYWxCb29sZWFuTm90OiBcIkJvb2xlYW5vIE7Do29cIixcblx0XHRsb2NhbENvczogXCJDb3NcIixcblx0XHRsb2NhbENvc0g6IFwiQ29zSFwiLFxuXHRcdGxvY2FsRXhwOiBcIkV4cFwiLFxuXHRcdGxvY2FsRXhwMTA6IFwiRXhwMTBcIixcblx0XHRsb2NhbEV4cDI6IFwiRXhwMlwiLFxuXHRcdGxvY2FsSW50OiBcIkludFwiLFxuXHRcdGxvY2FsSXNOdWxsOiBcIsOJIE51bG9cIixcblx0XHRsb2NhbEZsb2F0OiBcIkZsdXR1YXJcIixcblx0XHRsb2NhbExuOiBcIkxuXCIsXG5cdFx0bG9jYWxMb2cxMDogXCJMb2cxMFwiLFxuXHRcdGxvY2FsTG9nMjogXCJMb2cyXCIsXG5cdFx0bG9jYWxOZWdhdGU6IFwiTmVnYXJcIixcblx0XHRsb2NhbFJvdW5kRG93bjogXCJBcnJlZG9uZGFyIHBhcmEgQmFpeG9cIixcblx0XHRsb2NhbFJvdW5kVXA6IFwiQXJyZWRvbmRhciBwYXJhIENpbWFcIixcblx0XHRsb2NhbFNpbjogXCJTaW5cIixcblx0XHRsb2NhbFNpbkg6IFwiU2luSFwiLFxuXHRcdGxvY2FsVGFuOiBcIlRhblwiLFxuXHRcdGxvY2FsVGFuSDogXCJUYW5IXCIsXG5cdFx0bG9jYWxBQ29zSDogXCJBQ29zSFwiLFxuXHRcdGxvY2FsQVNpbkg6IFwiQVNpbkhcIixcblx0XHRsb2NhbFBsdXM6IFwiTWFpc1wiLFxuXHRcdGxvY2FsTWludXM6IFwiTWVub3NcIixcblx0XHRsb2NhbFRpbWVzOiBcIlRlbXBvc1wiLFxuXHRcdGxvY2FsUG93ZXI6IFwiUG90w6puY2lhXCIsXG5cdFx0bG9jYWxCaXR3aXNlQW5kOiBcIkJpdHdpc2UgRVwiLFxuXHRcdGxvY2FsQml0d2lzZUxlZnRTaGlmdDogXCJCaXR3aXNlIEVzcXVlcmRhIFNoaWZ0XCIsXG5cdFx0bG9jYWxCaXR3aXNlT3I6IFwiQml0d2lzZSBPdVwiLFxuXHRcdGxvY2FsQml0d2lzZVJpZ2h0U2hpZnQ6IFwiQml0d2lzZSBEaXJlaXRhIFNoaWZ0XCIsXG5cdFx0bG9jYWxCaXR3aXNlWG9yOiBcIkJpdHdpc2UgWG9yXCIsXG5cdFx0bG9jYWxCb29sZWFuQW5kOiBcIkJvb2xlYW5vIEVcIixcblx0XHRsb2NhbEJvb2xlYW5PcjogXCJCb29sZWFubyBPdVwiLFxuXHRcdGxvY2FsQm9vbGVhblhvcjogXCJCb29sZWFubyBYb3JcIixcblx0XHRsb2NhbERpdmlkZTogXCJEaXZpZGlyXCIsXG5cdFx0bG9jYWxFcXVhbFRvOiBcIklndWFsIEE6XCIsXG5cdFx0bG9jYWxHcmVhdGVyVGhhbjogXCJNYWlvciBkbyBRdWVcIixcblx0XHRsb2NhbEdyZWF0ZXJUaGFuRXF1YWw6IFwiTWFpb3IgSWd1YWxcIixcblx0XHRsb2NhbExlc3NUaGFuOiBcIk1lbm9yIGRvIHF1ZVwiLFxuXHRcdGxvY2FsTGVzc1RoYW5FcXVhbDogXCJNZW5vciBJZ3VhbFwiLFxuXHRcdGxvY2FsTW9kOiBcIk1vZFwiLFxuXHRcdGxvY2FsTm90RXF1YWw6IFwiTsOjbyBJZ3VhbFwiLFxuXHRcdGxvY2FsQVRhbjI6IFwiQVRhbjJcIixcblx0XHRsb2NhbFNxdWFyZTogXCJRdWFkcmFkb1wiLFxuXHRcdGxvY2FsU2V0TnVsbDogXCJEZWZpbmlyIE51bG9cIixcblx0XHRyZW1hcERlZlR5cGVMaXN0OiBcIkxpc3RhXCIsXG5cdFx0cmVtYXBEZWZUeXBlVGFibGU6IFwiVGFiZWxhXCIsXG5cdFx0cmVtYXBUYWJsZVR5cGVTaW1wbGU6IFwiU2ltcGxlc1wiLFxuXHRcdHJlbWFwVGFibGVUeXBlRHluYW1pYzogXCJEaW7Dom1pY29cIixcblx0XHRyZW1hcFRhYmxlVHlwZVJlYXNzaWdubWVudDogXCJSZWF0cmlidWnDp8Ojb1wiLFxuXHRcdGdlb21Db3JyZWN0aW9uQnlDb25zdFo6IFwiVXRpbGl6YXIgY29uc3RhbnRlIFpcIixcblx0XHRnZW9tQ29ycmVjdGlvbkJ5REVNOiBcIlV0aWxpemFyIERFTVwiLFxuXHRcdHJhZGFyQ2FsaWJCZXRhTm91Z2h0OiBcIkJldGEtemVyb1wiLFxuXHRcdHJhZGFyQ2FsaWJTaWdtYU5vdWdodDogXCJTaWdtYS16ZXJvXCIsXG5cdFx0cmFkYXJDYWxpYkdhbW1hTm91Z2h0OiBcIkdhbWEtemVyb1wiLFxuXHRcdHNwZWNrbGVGaWx0ZXJUeXBlTGVlOiBcIkZpbHRybyBMZWVcIixcblx0XHRzcGVja2xlRmlsdGVyVHlwZUVuaGFuY2VkTGVlOiBcIkZpbHRybyBMZWUgbWVsaG9yYWRvXCIsXG5cdFx0c3BlY2tsZUZpbHRlclR5cGVGcm9zdDogXCJGaWx0cm8gRnJvc3RcIixcblx0XHRzcGVja2xlRmlsdGVyVHlwZUt1YW46IFwiRmlsdHJvIEt1YW5cIixcblx0XHRzcGVja2xlTm9pc2VNb2RlbE11bDogXCJSdcOtZG8gbXVsdGlwbGljYXRpdm9cIixcblx0XHRzcGVja2xlTm9pc2VNb2RlbEFkZDogXCJSdcOtZG8gYWRpdGl2b1wiLFxuXHRcdHNwZWNrbGVOb2lzZU1vZGVsQWRkbk11bDogXCJSdcOtZG8gYWRpdGl2byBlIG11bHRpcGxpY2F0aXZvXCIsXG5cdFx0bW9zYWljT3BUeXBlRmlyc3Q6IFwiUHJpbWVpcm9cIixcblx0XHRtb3NhaWNPcFR5cGVMYXN0OiBcIsOabHRpbW9cIixcblx0XHRtb3NhaWNPcFR5cGVNaW46IFwiTcOtbi5cIixcblx0XHRtb3NhaWNPcFR5cGVNYXg6IFwiTcOheC5cIixcblx0XHRtb3NhaWNPcFR5cGVNZWFuOiBcIk3DqWRpYVwiLFxuXHRcdG1vc2FpY09wVHlwZUJsZW5kOiBcIkJsZW5kXCIsXG5cdFx0bW9zYWljT3BUeXBlU3VtOiBcIlNvbWFcIixcblx0XHRpbnRlZ2VyOiBcIkludGVpcm9cIixcblx0XHRyZnhEODogXCJEOFwiLFxuXHRcdHJmeE1GRDogXCJNRkRcIixcblx0XHRkaW5mOiBcIkRpbmZcIixcblx0XHR2ZXJ0aWNhbDogXCJWZXJ0aWNhbFwiLFxuXHRcdGhvcml6b250YWw6IFwiSG9yaXpvbnRhbFwiLFxuXHRcdGxvY2FsQ2VsbFN0YXRpc3RpY3NNYWpvcml0eTogXCJNYWlvcmlhXCIsXG5cdFx0bG9jYWxDZWxsU3RhdGlzdGljc01heDogXCJNw6F4aW1vXCIsXG5cdFx0bG9jYWxDZWxsU3RhdGlzdGljc01lYW46IFwiTcOpZGlhXCIsXG5cdFx0bG9jYWxDZWxsU3RhdGlzdGljc01lZGlhbjogXCJNZWRpYW5hXCIsXG5cdFx0bG9jYWxDZWxsU3RhdGlzdGljc01pbjogXCJNw61uaW1vXCIsXG5cdFx0bG9jYWxDZWxsU3RhdGlzdGljc01pbm9yaXR5OiBcIk1pbm9yaWFcIixcblx0XHRsb2NhbENlbGxTdGF0aXN0aWNzUmFuZ2U6IFwiSW50ZXJ2YWxvXCIsXG5cdFx0bG9jYWxDZWxsU3RhdGlzdGljc1N0ZERldjogXCJEZXN2aW8gUGFkcsOjb1wiLFxuXHRcdGxvY2FsQ2VsbFN0YXRpc3RpY3NTdW06IFwiU29tYVwiLFxuXHRcdGxvY2FsQ2VsbFN0YXRpc3RpY3NWYXJpZXR5OiBcIlZhcmllZGFkZVwiLFxuXHRcdGxvY2FsQ2VsbFN0YXRpc3RpY3NNYWpvcml0eUlnbm9yZU5EOiBcIk1haW9yaWEgKElnbm9yYXIgTm9EYXRhKVwiLFxuXHRcdGxvY2FsQ2VsbFN0YXRpc3RpY3NNYXhJZ25vcmVORDogXCJNw6F4aW1vIChJZ25vcmFyIE5vRGF0YSlcIixcblx0XHRsb2NhbENlbGxTdGF0aXN0aWNzTWVhbklnbm9yZU5EOiBcIk3DqWRpYSAoSWdub3JhciBOb0RhdGEpXCIsXG5cdFx0bG9jYWxDZWxsU3RhdGlzdGljc01lZGlhbklnbm9yZU5EOiBcIk1lZGlhbmEgKElnbm9yYXIgTm9EYXRhKVwiLFxuXHRcdGxvY2FsQ2VsbFN0YXRpc3RpY3NNaW5JZ25vcmVORDogXCJNw61uaW1vIChJZ25vcmFyIE5vRGF0YSlcIixcblx0XHRsb2NhbENlbGxTdGF0aXN0aWNzTWlub3JpdHlJZ25vcmVORDogXCJNaW5vcmlhIChJZ25vcmFyIE5vRGF0YSlcIixcblx0XHRsb2NhbENlbGxTdGF0aXN0aWNzUmFuZ2VJZ25vcmVORDogXCJJbnRlcnZhbG8gKElnbm9yYXIgTm9EYXRhKVwiLFxuXHRcdGxvY2FsQ2VsbFN0YXRpc3RpY3NTdGREZXZJZ25vcmVORDogXCJEZXN2aW8gcGFkcsOjbyAoSWdub3JhciBOb0RhdGEpXCIsXG5cdFx0bG9jYWxDZWxsU3RhdGlzdGljc1N1bUlnbm9yZU5EOiBcIlNvbWEgKElnbm9yYXIgTm9EYXRhKVwiLFxuXHRcdGxvY2FsQ2VsbFN0YXRpc3RpY3NWYXJpZXR5SWdub3JlTkQ6IFwiVmFyaWVkYWRlIChJZ25vcmFyIE5vRGF0YSlcIixcblx0XHRsb2NhbENlbGxTdGF0aXN0aWNzVHlwZVBlcmNlbnRpbGVJZ25vcmVORDogXCJQZXJjZW50aWwgKElnbm9yYXIgTm9EYXRhKVwiLFxuXHRcdGZyb21Tb3VyY2U6IFwiRGUgZm9udGVcIixcblx0XHR0b1NvdXJjZTogXCJQYXJhIGZvbnRlXCIsXG5cdFx0Y29sb3JzcGFjZUNvbnZlcnNpb25SZ2JUb0hzdjogXCJSR0IgcGFyYSBIU1ZcIixcblx0XHRjb2xvcnNwYWNlQ29udmVyc2lvbkhzdlRvUmdiOiBcIkhTViBwYXJhIFJHQlwiLFxuXHRcdHBhbnNoYXJwZW5UeXBlSUhTOiBcIklIU1wiLFxuXHRcdHBhbnNoYXJwZW5UeXBlQnJvdmV5OiBcIkJyb3ZleVwiLFxuXHRcdHBhbnNoYXJwZW5UeXBlRXNyaTogXCJFc3JpXCIsXG5cdFx0cGFuc2hhcnBlblR5cGVNZWFuOiBcIk3DqWRpYVwiLFxuXHRcdHBhbnNoYXJwZW5UeXBlR3JhbVNjaG1pZHQ6IFwiR3JhbS1TY2htaWR0XCIsXG5cdFx0cmVjdGFuZ2xlTmVpZ2hib3Job29kOiBcIlJldMOibmd1bG9cIixcblx0XHRjaXJjbGVOZWlnaGJvcmhvb2Q6IFwiQ8OtcmN1bG9cIixcblx0XHRhbm51bHVzTmVpZ2hib3Job29kOiBcIkFuZWxcIixcblx0XHR3ZWRnZU5laWdoYm9yaG9vZDogXCJDYWzDp29cIixcblx0XHRpcnJlZ3VsYXJOZWlnaGJvcmhvb2Q6IFwiSXJyZWd1bGFyXCIsXG5cdFx0d2VpZ2h0TmVpZ2hib3Job29kOiBcIlBlc29cIixcblx0XHRmb3VyOiBcIlF1YXRyb1wiLFxuXHRcdGVpZ2h0OiBcIk9pdG9cIixcblx0XHR3aXRoaW46IFwiSW5jbHXDrWRvXCIsXG5cdFx0Y3Jvc3M6IFwiQ3J1elwiLFxuXHRcdGFkZExpbms6IFwiQWRpY2lvbmFyIExpZ2HDp8Ojb1wiLFxuXHRcdG5vTGluazogXCJTZW0gbGlnYcOnw6NvXCIsXG5cdFx0d2VpZ2h0ZWRNZWFuOiBcIk3DqWRpYSBQb25kZXJhZGFcIixcblx0XHRsczhRQ0JpdFBhdHRlcm5DaXJydXM6IFwiTGFuZHNhdCA4OiBDaXJyb1wiLFxuXHRcdGxzOFFDQml0UGF0dGVybkNsb3VkOiBcIkxhbmRzYXQgODogTnV2ZW1cIixcblx0XHRsczhRQ0JpdFBhdHRlcm5DbG91ZFNoYWRvdzogXCJMYW5kc2F0IDg6IFNvbWJyYSBkZSBOdXZlbVwiLFxuXHRcdGxzOFFDQml0UGF0dGVybkRlc2lnbmF0ZWRGaWxsOiBcIkxhbmRzYXQgODogUHJlZW5jaGltZW50byBEZXNpZ25hZG9cIixcblx0XHRsczhRQ0JpdFBhdHRlcm5Ecm9wcGVkRnJhbWU6IFwiTGFuZHNhdCA4OiBQZXJkYSBkZSBGcmFtZVwiLFxuXHRcdGxzOFFDQml0UGF0dGVyblNub3dJY2U6IFwiTGFuZHNhdCA4OiBOZXZlL0dlbG9cIixcblx0XHRsczhRQ0JpdFBhdHRlcm5UZXJyYWluT2NjbHVzaW9uOiBcIkxhbmRzYXQgODogT2NsdXPDo28gZG8gVGVycmVub1wiLFxuXHRcdGxzOFFDQml0UGF0dGVyblZlZ2V0YXRpb246IFwiTGFuZHNhdCA4OiBWZWdldGHDp8Ojb1wiLFxuXHRcdGxzOFFDQml0UGF0dGVybldhdGVyOiBcIkxhbmRzYXQgODogw4FndWFcIixcblx0XHRkb3duU3RyZWFtOiBcIkEganVzYW50ZVwiLFxuXHRcdHVwU3RyZWFtOiBcIkEgbW9udGFudGVcIixcblx0XHRzdHJhaGxlcjogXCJTVFJBSExFUlwiLFxuXHRcdHNocmV2ZTogXCJTSFJFVkVcIixcblx0XHRjdXJyZW50U2xpY2U6IFwiU2Vjw6fDo28gQXR1YWxcIixcblx0XHRhbGxTbGljZXM6IFwiVG9kYXMgYXMgU2Vjw6fDtWVzXCIsXG5cdFx0ZXhwYW5kRGlzdGFuY2U6IFwiRElTVMOCTkNJQVwiLFxuXHRcdGV4cGFuZE1vcnBob2xvZ2ljYWw6IFwiTU9SRk9Mw5NHSUNPXCIsXG5cdFx0c3BlY3RyYWxQcm9maWxlRmlsZTogXCJQZXJmaWwgRXNwZXRyYWxcIixcblx0XHR0cmFpbmluZ0ZlYXR1cmVGaWxlOiBcIkVsZW1lbnRvIGRlIEZvcm1hw6fDo29cIixcblx0XHRyYW5kb21EaXN0cmlidXRpb25UeXBlVW5pZm9ybTogXCJVbmlmb3JtZVwiLFxuXHRcdHJhbmRvbURpc3RyaWJ1dGlvblR5cGVVbmlmb3JtSW50ZWdlcjogXCJJbnRlaXJvXCIsXG5cdFx0cmFuZG9tRGlzdHJpYnV0aW9uVHlwZU5vcm1hbDogXCJOb3JtYWxcIixcblx0XHRyYW5kb21EaXN0cmlidXRpb25UeXBlRXhwb25lbnRpYWw6IFwiRXhwb25lbmNpYWxcIixcblx0XHRyYW5kb21EaXN0cmlidXRpb25UeXBlUG9pc3NvbjogXCJQb2lzc29uXCIsXG5cdFx0cmFuZG9tRGlzdHJpYnV0aW9uVHlwZUdhbW1hOiBcIkdhbWFcIixcblx0XHRyYW5kb21EaXN0cmlidXRpb25UeXBlQmlub21pYWw6IFwiQmlub21pYWxcIixcblx0XHRyYW5kb21EaXN0cmlidXRpb25UeXBlR2VvbWV0cmljOiBcIkdlb23DqXRyaWNhXCIsXG5cdFx0cmFuZG9tRGlzdHJpYnV0aW9uVHlwZU5lZ2F0aXZlQmlub21pYWw6IFwiQmlub21pYWwgTmVnYXRpdm9cIixcblx0XHRyYW5kb21HZW5lcmF0b3JUeXBlU3RhbmRhcmRDUmFuZDogXCJTdGFuZGFyZCBDIFJhbmRcIixcblx0XHRyYW5kb21HZW5lcmF0b3JUeXBlQWxnb3JpdGhtQUNNNTk5OiBcIkFDTSBjb2xsZWN0ZWQgYWxnb3JpdGhtIDU5OVwiLFxuXHRcdHJhbmRvbUdlbmVyYXRvclR5cGVNZXJzZW5uZVR3aXN0ZXI6IFwiTWVyc2VubmUgVHdpc3RlclwiLFxuXHRcdHN1bU5hbWU6IFwiU29tYVwiLFxuXHRcdG1lZGFpbk5hbWU6IFwiTWVkaWFuYVwiLFxuXHRcdHRyZW5kTGluZWFyOiBcIkxpbmVhclwiLFxuXHRcdHRyZW5kSGFybW9uaWM6IFwiSGFybcOzbmljYVwiLFxuXHRcdHRyZW5kUG9seW5vbWlhbDogXCJQb2xpbm9taWFsXCIsXG5cdFx0dHJlbmRNYW5uS2VuZGFsbDogXCJNYW5uLUtlbmRhbGxcIixcblx0XHR0cmVuZFNlYXNvbmFsS2VuZGFsbDogXCJLZW5kYWxsIFNhem9uYWxcIixcblx0XHRkaW1lbnNpb25CeVZhbHVlOiBcIlBvciBWYWxvclwiLFxuXHRcdGRpbWVuc2lvbkJ5SW50ZXJ2YWw6IFwiUG9yIEludGVydmFsb1wiLFxuXHRcdG1kaW1EZWZUeXBlQWxsOiBcIlRvZG9zXCIsXG5cdFx0bWRpbURlZlR5cGVCeVZhbHVlczogXCJQb3IgVmFsb3Jlc1wiLFxuXHRcdG1kaW1EZWZUeXBlQnlSYW5nZXM6IFwiUG9yIEludGVydmFsb3NcIixcblx0XHRtZGltRGVmVHlwZUJ5SXRlcmF0aW9uOiBcIlBvciBJdGVyYcOnw6NvXCIsXG5cdFx0bWRpbURlZlR5cGVCeUludGVydmFsOiBcIlBvciBJbnRlcnZhbG9cIixcblx0XHRtZGltRGVmVHlwZUJ5VGFyZ2V0UmFzdGVyOiBcIlBvciBSYXN0ZXIgZGUgRGVzdGlub1wiLFxuXHRcdGVzcmlUaW1lVW5pdHNIb3VyczogXCJIb3Jhc1wiLFxuXHRcdGVzcmlUaW1lVW5pdHNEYXlzOiBcIkRpYXNcIixcblx0XHRlc3JpVGltZVVuaXRzV2Vla3M6IFwiU2VtYW5hc1wiLFxuXHRcdGVzcmlUaW1lVW5pdHNNb250aHM6IFwiTWVzZXNcIixcblx0XHRlc3JpVGltZVVuaXRzWWVhcnM6IFwiQW5vc1wiLFxuXHRcdGVzcmlUaW1lSW50ZXJ2YWxLZXl3b3JkSG91cmx5OiBcIkEgY2FkYSBob3JhXCIsXG5cdFx0ZXNyaVRpbWVJbnRlcnZhbEtleXdvcmREYWlseTogXCJEaWFyaWFtZW50ZVwiLFxuXHRcdGVzcmlUaW1lSW50ZXJ2YWxLZXl3b3JkV2Vla2x5OiBcIlNlbWFuYWxtZW50ZVwiLFxuXHRcdGVzcmlUaW1lSW50ZXJ2YWxLZXl3b3JkRGVrYWRseTogXCJBIGNhZGEgMTAgYW5vc1wiLFxuXHRcdGVzcmlUaW1lSW50ZXJ2YWxLZXl3b3JkUGVudGFkbHk6IFwiQSBjYWRhIDUgYW5vc1wiLFxuXHRcdGVzcmlUaW1lSW50ZXJ2YWxLZXl3b3JkTW9udGhseTogXCJNZW5zYWxtZW50ZVwiLFxuXHRcdGVzcmlUaW1lSW50ZXJ2YWxLZXl3b3JkUXVhcnRlcmx5OiBcIlRyaW1lc3RyYWxcIixcblx0XHRlc3JpVGltZUludGVydmFsS2V5d29yZFllYXJseTogXCJBbnVhbG1lbnRlXCIsXG5cdFx0ZXNyaVRpbWVJbnRlcnZhbEtleXdvcmRSZWN1cnJpbmdEYWlseTogXCJSZWNvcnJlbnRlIGRpYXJpYW1lbnRlXCIsXG5cdFx0ZXNyaVRpbWVJbnRlcnZhbEtleXdvcmRSZWN1cnJpbmdXZWVrbHk6IFwiUmVjb3JyZW50ZSBzZW1hbmFsbWVudGVcIixcblx0XHRlc3JpVGltZUludGVydmFsS2V5d29yZFJlY3VycmluZ01vbnRobHk6IFwiUmVjb3JyZW50ZSBtZW5zYWxtZW50ZVwiLFxuXHRcdGVzcmlUaW1lSW50ZXJ2YWxLZXl3b3JkUmVjdXJyaW5nUXVhcnRlcmx5OiBcIlJlY29ycmVudGUgdHJpbWVzdHJhbG1lbnRlXCIsXG5cdFx0YWdnRGVmVHlwZUFsbDogXCJUdWRvXCIsXG5cdFx0YWdnRGVmVHlwZUludGVydmFsS2V5d29yZDogXCJQYWxhdnJhLWNoYXZlIGRlIEludGVydmFsb1wiLFxuXHRcdGFnZ0RlZlR5cGVJbnRlcnZhbFZhbHVlOiBcIlZhbG9yIGRlIEludGVydmFsb1wiLFxuXHRcdGFnZ0RlZlR5cGVJbnRlcnZhbFJhbmdlczogXCJJbnRlcnZhbG9zXCIsXG5cdFx0bGF0ZXN0Q2hhbmdlOiBcIkhvcmEgZGEgw5psdGltYSBBbHRlcmHDp8Ojb1wiLFxuXHRcdGVhcmxpZXN0Q2hhbmdlOiBcIkhvcmEgZGEgUHJpbWVpcmEgQWx0ZXJhw6fDo29cIixcblx0XHRsYXJnZXN0Q2hhbmdlOiBcIkhvcmEgZGEgTWFpb3IgQWx0ZXJhw6fDo29cIixcblx0XHRudW1iZXJPZkNoYW5nZXM6IFwiTsO6bWVybyBkZSBBbHRlcmHDp8O1ZXNcIixcblx0XHRsb25nZXN0Q2hhbmdlOiBcIkhvcmEgZGEgTWFpb3IgQWx0ZXJhw6fDo29cIixcblx0XHRzaG9ydGVzdENoYW5nZTogXCJIb3JhIGRhIE1lbm9yIEFsdGVyYcOnw6NvXCIsXG5cdFx0ZmFzdGVzdENoYW5nZTogXCJIb3JhIGRhIEFsdGVyYcOnw6NvIE1haXMgUsOhcGlkYVwiLFxuXHRcdHNsb3dlc3RDaGFuZ2U6IFwiSG9yYSBkYSBBbHRlcmHDp8OjbyBNYWlzIExlbnRhXCIsXG5cdFx0YWxsQ2hhbmdlczogXCJUdWRvXCIsXG5cdFx0aW5jcmVhc2VDaGFuZ2VzOiBcIkF1bWVudGFyXCIsXG5cdFx0ZGVjcmVhc2VDaGFuZ2VzOiBcIlJlZHV6aXJcIixcblx0XHRzZWdtZW50QmVnaW5uaW5nOiBcIkluw61jaW8gZG8gc2VnbWVudG9cIixcblx0XHRzZWdtZW50RW5kOiBcIkZpbSBkbyBzZWdtZW50b1wiLFxuXHRcdGVzcmlDb21wdXRlQ2hhbmdlTWV0aG9kRGlmZmVyZW5jZTogXCJEaWZlcmVuw6dhXCIsXG5cdFx0ZXNyaUNvbXB1dGVDaGFuZ2VNZXRob2RSZWxhdGl2ZURpZmZlcmVuY2U6IFwiRGlmZXJlbsOnYSBSZWxhdGl2YVwiLFxuXHRcdGVzcmlDb21wdXRlQ2hhbmdlTWV0aG9kQ2F0ZWdvcmljYWw6IFwiRGlmZXJlbsOnYSBDYXRlZ8OzcmljYVwiLFxuXHRcdGVzcmlDb21wdXRlQ2hhbmdlTWV0aG9kTXVsdGlzcGVjdHJhbEV1Y2xpZGVhbkRpc3RhbmNlOiBcIkRpc3TDom5jaWEgRXVjbGlkaWFuYSBFc3BlY3RyYWxcIixcblx0XHRlc3JpQ29tcHV0ZUNoYW5nZU1ldGhvZE11bHRpc3BlY3RyYWxBbmd1bGFyRGlmZmVyZW5jZTogXCJEaWZlcmVuw6dhIEFuZ3VsYXIgRXNwZWN0cmFsXCIsXG5cdFx0ZXNyaUNvbXB1dGVDaGFuZ2VNZXRob2RNdWx0aXNwZWN0cmFsQXhpc1dpdGhCaWdnZXN0Q2hhbmdlOiBcIkJhbmRhIENvbSBNYWlzIEFsdGVyYcOnw7Vlc1wiLFxuXHRcdGVzcmlDb21wdXRlQ2hhbmdlS2VlcEFsbDogXCJNYW50ZXIgVHVkb1wiLFxuXHRcdGVzcmlDb21wdXRlQ2hhbmdlS2VlcENoYW5nZWRPbmx5OiBcIk1hbnRlciBBcGVuYXMgUMOteGVpcyBBbHRlcmFkb3NcIixcblx0XHRlc3JpQ29tcHV0ZUNoYW5nZUtlZXBVbmNoYW5nZWRPbmx5OiBcIk1hbnRlciBBcGVuYXMgUMOteGVpcyBJbmFsdGVyYWRvc1wiLFxuXHRcdGVzcmlDb21wdXRlQ2hhbmdlVXNlQ29sb3JBdmVyYWdlOiBcIkRlIGUgUGFyYSBDb3JlcyBNw6lkaWFzXCIsXG5cdFx0ZXNyaUNvbXB1dGVDaGFuZ2VVc2VDb2xvckZyb206IFwiVXNhciBEZSBDb3Jlc1wiLFxuXHRcdGVzcmlDb21wdXRlQ2hhbmdlVXNlQ29sb3JUbzogXCJVdGlsaXphciBQYXJhIENvcmVzXCIsXG5cdFx0ZmFjdG9yRnVuY3Rpb25CaW5hcnk6IFwiQmluw6FyaW9cIixcblx0XHRmYWN0b3JGdW5jdGlvbkZvcndhcmQ6IFwiUGFyYSBhIGZyZW50ZVwiLFxuXHRcdGZhY3RvckZ1bmN0aW9uTGluZWFyOiBcIkxpbmVhclwiLFxuXHRcdGZhY3RvckZ1bmN0aW9uSW52TGluZWFyOiBcIkxpbmVhciBJbnZlcnNvXCIsXG5cdFx0ZmFjdG9yRnVuY3Rpb25UYWJsZTogXCJUYWJlbGFcIixcblx0XHRmYWN0b3JGdW5jdGlvblN5bUxpbmVhcjogXCJMaW5lYXIgU2ltw6l0cmljb1wiLFxuXHRcdGZhY3RvckZ1bmN0aW9uU3ltSW52TGluZWFyOiBcIkxpbmVhciBTaW3DqXRyaWNvIEludmVyc29cIixcblx0XHRmYWN0b3JGdW5jdGlvbkNvczogXCJDb3NzZW5vXCIsXG5cdFx0ZmFjdG9yRnVuY3Rpb25TZWM6IFwiU2VjYW50ZVwiLFxuXHRcdGZhY3RvckZ1bmN0aW9uQ29zU2VjOiBcIkNvc3Nlbm8gU2VjYW50ZVwiLFxuXHRcdGZhY3RvckZ1bmN0aW9uU2VjQ29zOiBcIlNlY2FudGUgQ29zc2Vub1wiLFxuXHRcdG5vU29ydDogXCJOw6NvIE9yZGVuYXJcIixcblx0XHRhc2NlbmQ6IFwiQ3Jlc2NlbnRlXCIsXG5cdFx0ZGVzY2VuZDogXCJEZWNyZXNjZW50ZVwiLFxuXHRcdGF1dG9EZXRlY3Q6IFwiRGV0ZXRhciBhdXRvbWF0aWNhbWVudGVcIixcblx0XHRuZWFyZXN0OiBcIk1haXMgUHLDs3hpbW9cIixcblx0XHRsaW5lYXI6IFwiTGluZWFyXCIsXG5cdFx0ZXNyaU1vbnRoSmFudWFyeTogXCJqYW5laXJvXCIsXG5cdFx0ZXNyaU1vbnRoRmVicnVhcnk6IFwiZmV2ZXJlaXJvXCIsXG5cdFx0ZXNyaU1vbnRoTWFyY2g6IFwibWFyw6dvXCIsXG5cdFx0ZXNyaU1vbnRoQXByaWw6IFwiYWJyaWxcIixcblx0XHRlc3JpTW9udGhNYXk6IFwibWFpb1wiLFxuXHRcdGVzcmlNb250aEp1bmU6IFwianVuaG9cIixcblx0XHRlc3JpTW9udGhKdWx5OiBcImp1bGhvXCIsXG5cdFx0ZXNyaU1vbnRoQXVndXN0OiBcImFnb3N0b1wiLFxuXHRcdGVzcmlNb250aFNlcHRlbWJlcjogXCJzZXRlbWJyb1wiLFxuXHRcdGVzcmlNb250aE9jdG9iZXI6IFwib3V0dWJyb1wiLFxuXHRcdGVzcmlNb250aE5vdmVtYmVyOiBcIm5vdmVtYnJvXCIsXG5cdFx0ZXNyaU1vbnRoRGVjZW1iZXI6IFwiZGV6ZW1icm9cIixcblx0XHRkaW1lbnNpb25hbE1vdmluZ0lnbm9yZU5vRGF0YTogXCJEYWRvc1wiLFxuXHRcdGRpbWVuc2lvbmFsTW92aW5nUHJvcGFnYXRlTm9EYXRhOiBcIk5vRGF0YVwiLFxuXHRcdGRpbWVuc2lvbmFsTW92aW5nRmlsbE9ubHlOb0RhdGE6IFwiUHJlZW5jaGVyIE5vRGF0YVwiLFxuXHRcdGNpcmN1bGFyTWVhbjogXCJNw6lkaWEgQ2lyY3VsYXJcIixcblx0XHRjaXJjdWxhck5hbWU6IFwiQ2lyY3VsYXJcIixcblx0XHRhcml0aG1ldGljTmFtZTogXCJBcml0bcOpdGljb3NcIixcblx0XHRzbG9wZU5hbWU6IFwiRGVjbGl2ZVwiLFxuXHRcdGFzcGVjdE5hbWU6IFwiQXNwZXRvXCIsXG5cdFx0bWVhbkN1cnZhdHVyZTogXCJDdXJ2YXR1cmEgbcOpZGlhXCIsXG5cdFx0cHJvZmlsZUN1cnZhdHVyZTogXCJDdXJ2YXR1cmEgZG8gcGVyZmlsIChsaW5oYSBkZSBkZWNsaXZlIG5vcm1hbClcIixcblx0XHR0YW5nZW50aWFsQ3VydmF0dXJlOiBcIkN1cnZhdHVyYSB0YW5nZW5jaWFsIChjb250b3JubyBub3JtYWwpXCIsXG5cdFx0cGxhbkN1cnZhdHVyZTogXCJDdXJ2YXR1cmEgZG8gcGxhbm8gKGNvbnRvcm5vIHByb2pldGFkbylcIixcblx0XHRjb250b3VyR2VvZGVzaWNUb3JzaW9uOiBcIlRvcsOnw6NvIGdlb2TDqXNpY2EgZGUgY29udG9ybm9cIixcblx0XHRnYXVzc2lhbkN1cnZhdHVyZTogXCJDdXJ2YXR1cmEgZ2F1c3NpYW5hXCIsXG5cdFx0Y2Fzb3JhdGlDdXJ2YXR1cmU6IFwiQ3VydmFzIGRlIENhc29yYXRpXCIsXG5cdFx0bG9jYWxTdXJmYWNlVHlwZVF1YWRyYXRpYzogXCJRdWFkcsOhdGljYVwiLFxuXHRcdGxvY2FsU3VyZmFjZVR5cGVCaXF1YWRyYXRpYzogXCJCaXF1YWRyw6F0aWNhXCIsXG5cdFx0dGhyZXNob2xkTm9UaHJlc2hvbGQ6IFwiU2VtIExpbWlhclwiLFxuXHRcdHRocmVzaG9sZFBlcmNlbnRMZWFzdENvc3Q6IFwiUGVyY2VudGFnZW0gZGUgTWVub3IgQ3VzdG9cIixcblx0XHR0aHJlc2hvbGRBY2N1bXVsYXRpdmVDb3N0OiBcIkN1c3RvIEFjdW11bGF0aXZvXCIsXG5cdFx0Y2xybWFwVHlwZUhpbGxzaGFkZTogXCJTb21icmVhZG9cIlxuXHR9LFxuXHRjYXRlZ29yeUxhYmVsczoge1xuXHRcdHNvdXJjZUNoYXJhY3RlcmlzdGljczogXCJDYXJhY3RlcsOtc3RpY2FzIGRhIEZvbnRlXCIsXG5cdFx0bmVpZ2hib3Job29kU2V0dGluZ3M6IFwiRGVmaW5pw6fDtWVzIGRlIFZpemluaGFuw6dhXCIsXG5cdFx0c3RhdGlzdGljczogXCJFc3RhdMOtc3RpY2FzXCIsXG5cdFx0Z2FtbWE6IFwiR2FtYVwiLFxuXHRcdHZpZXdzaGVkUGFyYW1ldGVyczogXCJQYXLDom1ldHJvcyBkZSDDgXJlYSBWaXPDrXZlbFwiLFxuXHRcdG9ic2VydmVyUGFyYW1ldGVyczogXCJQYXLDom1ldHJvcyBkZSBPYnNlcnZhZG9yXCIsXG5cdFx0aXJyZWd1bGFyRGF0YUludGVycG9sYXRpb246IFwiSW50ZXJwb2xhw6fDo28gZGUgRGFkb3MgSXJyZWd1bGFyXCIsXG5cdFx0bW9kZWxTdGF0aXN0aWNzOiBcIkVzdGF0w61zdGljYXMgZG8gTW9kZWxvXCIsXG5cdFx0YWdncmVnYXRpb25EZWY6IFwiRGVmaW5pw6fDo28gZGUgQWdyZWdhw6fDo29cIixcblx0XHRmaWx0ZXJCeUF0dHJpYnV0ZXM6IFwiRmlsdHJhciBQb3IgQXRyaWJ1dG9zXCIsXG5cdFx0cGVyY2VudGlsZU5hbWU6IFwiUGVyY2VudGlsXCIsXG5cdFx0cmFzdGVySW5mbzogXCJJbmZvcm1hw6fDtWVzIGRvIFJhc3RlclwiLFxuXHRcdGV4dGVudDogXCJFc3RlbmRlclwiLFxuXHRcdHNwYXRpYWxSZWZlcmVuY2U6IFwiUmVmZXLDqm5jaWEgRXNwYWNpYWxcIlxuXHR9LFxuXHRvdXRwdXRSYXN0ZXJIZWxwVGV4dHM6IHtcblx0XHRvdXRwdXROYW1lOiBcIjxwPk8gbm9tZSBkYSBjYW1hZGEgcXVlIHNlcsOhIGNyaWFkYSBlIGFkaWNpb25hZGEgYW8gbWFwYS48L3A+XCIsXG5cdFx0cmVzdWx0VHlwZTogXCI8cD5PIHRpcG8gZGUgc2HDrWRhIHF1ZSBzZXLDoSBjcmlhZG8uIEFzIHNhw61kYXMgcG9kZW0gc2VyIGNhbWFkYXMgZGUgaW1hZ2VucyBlbSBtb3NhaWNvIG91IGNhbWFkYXMgZGUgaW1hZ2VucyBkaW7Dom1pY2FzLjwvcD5cIixcblx0XHRzYXZlUmVzdWx0SW46IFwiPHA+TyBub21lIGRhIHBhc3RhIGVtIDxiPk8gTWV1IENvbnRlw7pkbzwvYj4gb25kZSBvIHJlc3VsdGFkbyBzZXLDoSBndWFyZGFkby48L3A+XCJcblx0fSxcblx0YW5hbHlzaXNFbnZpcm9ubWVudHNIZWxwVGV4dHM6IHtcblx0XHRkZXNjcmlwdGlvbjogXCI8cD5EZWZpbmnDp8O1ZXMgZGUgYW1iaWVudGUgcGFyYSBhbsOhbGlzZSBubyBNYXAgVmlld2VyLiA8L3A+XCIsXG5cdFx0b3V0U1I6IFwiPHA+RXNwZWNpZmljYSBvIHNpc3RlbWEgZGUgY29vcmRlbmFkYXMgcGFyYSBhbsOhbGlzZSBlIGEgY2FtYWRhIGRlIHJlc3VsdGFkb3MuPC9wPlwiLFxuXHRcdGV4dGVudDogXCI8cD5Fc3BlY2lmaWNhIGEgw6FyZWEgYSBzZXIgdXRpbGl6YWRhIHBhcmEgYW7DoWxpc2UuPC9wPlwiLFxuXHRcdHNuYXBSYXN0ZXI6IFwiPHA+QWp1c3RhIGEgZXh0ZW5zw6NvIGRhIHNhw61kYSBwYXJhIHF1ZSBjb3JyZXNwb25kYSBhbyBhbGluaGFtZW50byBkYSBjw6lsdWxhIGRhIGNhbWFkYSByYXN0ZXIgZGUgYWp1c3RlIGVzcGVjaWZpY2FkYS48L3A+XCIsXG5cdFx0Y2VsbFNpemU6IFwiPHA+RXNwZWNpZmljYSBvIHRhbWFuaG8gZGEgY8OpbHVsYSBvdSByZXNvbHXDp8OjbyBxdWUgc2Vyw6EgdXRpbGl6YWRvIHBhcmEgYW7DoWxpc2UgZSBjcmlhciBhIGNhbWFkYSBkZSByYXN0ZXIgZGUgc2HDrWRhLjwvcD5cIixcblx0XHRtYXNrOiBcIjxwPkVzcGVjaWZpY2EgdW1hIGNhbWFkYSBkZSBtw6FzY2FyYSBuYSBxdWFsIGFwZW5hcyBhcyBjw6lsdWxhcyBxdWUgc2UgZW5xdWFkcmFyZW0gbmEgw6FyZWEgZGUgbcOhc2NhcmEgc2Vyw6NvIHV0aWxpemFkYXMgcGFyYSBhbsOhbGlzZS48L3A+XCIsXG5cdFx0cmVzYW1wbGluZ01ldGhvZDogXCI8cD5Fc3BlY2lmaWNhIGNvbW8gaW50ZXJwb2xhciB2YWxvcmVzIGRlIHDDrXhlaXMgcXVhbmRvIG9zIHJhc3RlcnMgZGUgZW50cmFkYSBlIHNhw61kYSBuw6NvIHNlIGFsaW5oYW0uPC9wPlwiXG5cdH0sXG5cdG1haW5HZW5TdHJpbmdzOiB7XG5cdFx0dW5zdXBwb3J0ZWREYXRhVHlwZTogXCJUaXBvIG7Do28gc3Vwb3J0YWRvXCIsXG5cdFx0Y3VycmVudGx5VW5zdXBwb3J0ZWQ6IFwiIFVtIGVkaXRvciBwcmVkZWZpbmlkbyBwYXJhIG8gdGlwbyAke21pc3NpbmdUeXBlfSBlc3TDoSBwZW5kZW50ZSwgbWFzIGVzdMOhIHBhcmEgYnJldmUuIENhaXhhIGRlIHRleHRvIHRlbXBvcsOhcmlhIGRlIGVzcGHDp28gcmVzZXJ2YWRvIHBhcmEgZXNwZWNpZmljYXIgZW50cmFkYXMgYmFzZWFkYXMgZW0gY2FkZWlhcyBkZSBjYXJhY3RlcmVzLlwiLFxuXHRcdHVuc3VwcG9ydGVkT3ZlcnJpZGVXYXJuaW5nOiBcIkVzdMOhIHBlbmRlbnRlLCBtYXMgcGFyYSBicmV2ZSwgdW0gY29tcG9uZW50ZSBkbyBlZGl0b3IgZGUgc3Vic3RpdHVpw6fDtWVzIHF1ZSBwcm9wb3JjaW9uYSB1bWEgbWVsaG9yIGV4cGVyacOqbmNpYSBkZSB1dGlsaXphZG9yIHBhcmEgdHJhYmFsaGFyIGNvbSBvcyBzZWd1aW50ZXMgcGFyw6JtZXRyb3M6XCIsXG5cdFx0b3ZlcnJpZGVXaWRnZXRNaXNzaW5nOiBcIkNvbXBvbmVudGUgZG8gZWRpdG9yIGRlIHN1YnN0aXR1acOnw7VlcyBlbSBmYWx0YSFcIixcblx0XHR1aUluY29tcGxldGU6IFwiTyBlbnZpbyBkYSB0YXJlZmEgZmFsaG91LiBBIGZ1bsOnw6NvIG7Do28gcG9kZSBzZXIgZXhlY3V0YWRhIHBvcnF1ZSBhbGd1bnMgZG9zIGNhbXBvcyBvYnJpZ2F0w7NyaW9zIGVzdMOjbyBpbmNvbXBsZXRvcyBvdSBlbSBmYWx0YSBuYSBJVS5cIixcblx0XHRjb3VudDogXCJDb250YWdlbVwiLFxuXHRcdHNlbGVjdFZhcmlhYmxlczogXCJTZWxlY2lvbmFyIHZhcmnDoXZlaXNcIixcblx0XHRzZWxlY3RGZWF0dXJlOiBcIlNlbGVjaW9uZSB1bWEgY2FtYWRhIGRlIGVsZW1lbnRvc1wiLFxuXHRcdGdyZWF0ZXJUaGFuRXJyb3JNZXNzYWdlOiBcIk8gbsO6bWVybyBkZSBlbnRyYWRhIHRlbSBkZSBzZXIgbWFpb3IgcXVlICR7bWlufVwiLFxuXHRcdGxlc3NlclRoYW5FcnJvck1lc3NhZ2U6IFwiTyBuw7ptZXJvIGRlIGVudHJhZGEgdGVtIGRlIHNlciBtZW5vciBxdWUgJHttYXh9XCIsXG5cdFx0Z3JlYXRlclRoYW5PckVxdWFsRXJyb3JNZXNzYWdlOiBcIk8gbsO6bWVybyBkZSBlbnRyYWRhIHRlbSBkZSBzZXIgbWFpb3Igb3UgaWd1YWwgYSAke21pbn1cIixcblx0XHRsZXNzZXJUaGFuT3JFcXVhbEVycm9yTWVzc2FnZTogXCJPIG7Dum1lcm8gZGUgZW50cmFkYSB0ZW0gZGUgc2VyIG1lbm9yIG91IGlndWFsIGEgJHttYXh9XCIsXG5cdFx0YWxsb3dTY2FsYXI6IFwiU2VsZWNpb25lIHVtYSBjYW1hZGEgb3UgaW50cm9kdXphIHVtYSBjb25zdGFudGVcIixcblx0XHRzZWxlY3RGaWVsZDogXCJTZWxlY2lvbmFyIGNhbXBvXCIsXG5cdFx0cGFyYW1ldGVyUmVxdWlyZWQ6IFwiRXN0ZSBwYXLDom1ldHJvIMOpIG9icmlnYXTDs3Jpby5cIixcblx0XHRlbnRlckFWYWx1ZTogXCJJbnRyb2R1emEgdW0gdmFsb3IuLi5cIixcblx0XHRpbnZhbGlkSW5wdXQ6IFwiTyB2YWxvciBpbnRyb2R1emlkbyBuw6NvIMOpIHbDoWxpZG8uXCIsXG5cdFx0aXRlbU5vdEZvdW5kOiBcIk8gaXRlbSBuw6NvIGV4aXN0ZSBvdSBuw6NvIGVzdMOhIGFjZXNzw612ZWwuXCIsXG5cdFx0aXRlbVBlcm1pc3Npb25EZW5pZWQ6IFwiTsOjbyB0ZW0gcGVybWlzc8O1ZXMgcGFyYSBhY2VkZXIgYSBlc3RlIGl0ZW0uXCIsXG5cdFx0bGF5ZXJOb3RBdmFpbGFibGU6IFwiRmFsaGEgYW8gY2FycmVnYXIgYSBjYW1hZGEgJHtsYXllck5hbWV9LlwiLFxuXHRcdG11bHRpcGxlTGF5ZXJzTm90QXZhaWxhYmxlOiBcIkZhbGhhIGFvIGNhcnJlZ2FyIGEgY2FtYWRhICR7bGF5ZXJOYW1lfSBlIG91dHJhcy5cIixcblx0XHRsZWFybk1vcmVMYWJlbDogXCJTYWJlciBNYWlzXCIsXG5cdFx0ZmllbGROb3RBdmFpbGFibGU6IFwiRmFsaGEgYW8gY2FycmVnYXIgbyBjYW1wby5cIixcblx0XHRhbGxvd0FuYWx5c2lzOiBcIkEgYW7DoWxpc2UgbsOjbyDDqSBwZXJtaXRpZGEgbm8gc2VydmnDp28gZGUgaW1hZ2Vucy5cIixcblx0XHRhbGxvd0FuYWx5c2lzUmVhc29uOiBcIlVtYSBvdSBtYWlzIGNhbWFkYXMgZG8gbWFwYSBuw6NvIGVzdMOjbyBpbmRpY2FkYXMgYXF1aSBwb3JxdWUgbsOjbyBwZXJtaXRlbSBhbsOhbGlzZXMuXCIsXG5cdFx0bGVhcm5Nb3JlVGV4dDogXCJTYWliYSBtYWlzXCIsXG5cdFx0YXRMZWFzdE9uZVJhc3RlcklucHV0OiBcIlBlbG8gbWVub3MgdW1hIGNhbWFkYSBkZSBlbnRyYWRhIGRldmUgc2VyIHVtYSBjYW1hZGEgcmFzdGVyLlwiLFxuXHRcdGJyb3dzZUFuYWx5c2lzTGF5ZXJzOiBcIlByb2N1cmFyIGNhbWFkYXNcIixcblx0XHRhY3RpdmVNYXBWaWV3RXh0ZW50OiBcIlVzYXIgRXh0ZW5zw6NvIGRlIE1hcGEgQXR1YWxcIixcblx0XHRjaG9vc2VSYXN0ZXI6IFwiU2VsZWNpb25hciBSZWNvcnRhciBSYXN0ZXJcIixcblx0XHRjaG9vc2VHZW9tZXRyeTogXCJTZWxlY2lvbmFyIFJlY29ydGFyIEdlb21ldHJpYVwiLFxuXHRcdHJlc3VsdFR5cGU6IFwiVGlwbyBkZSByZXN1bHRhZG9cIixcblx0XHRzYXZlSW5Gb2xkZXI6IFwiR3VhcmRhciBudW1hIHBhc3RhXCIsXG5cdFx0b3V0cHV0TmFtZTogXCJOb21lIGRlIHNhw61kYVwiLFxuXHRcdG91dHB1dExheWVyVHlwZTogXCJUaXBvIGRlIGNhbWFkYSBkZSBzYcOtZGFcIixcblx0XHRkeW5hbWljSW1hZ2VyeUxheWVyOiBcIkNhbWFkYSBkZSBpbWFnZW5zIGRpbsOibWljYVwiLFxuXHRcdHRpbGVkSW1hZ2VyeUxheWVyOiBcIkNhbWFkYSBkZSBpbWFnZW5zIGVtIG1vc2FpY29cIixcblx0XHRjdXN0b206IFwiUGVyc29uYWxpemFyXCIsXG5cdFx0bG9hZGluZzogXCJBIGNhcnJlZ2FyLi4uXCIsXG5cdFx0bGF5ZXJNaXNzaW5nOiBcIlVtYSBvdSBtYWlzIGNhbWFkYXMgZG8gbWFwYSBuw6NvIGVzdMOjbyBpbmRpY2FkYXMgYXF1aSBwb3JxdWUgbsOjbyBwZXJtaXRlbSBhbsOhbGlzZXMuIFNhaWJhIG1haXMuXCIsXG5cdFx0YnJvd3NlQ29vcmRpbmF0ZVN5c3RlbXM6IFwiUHJvY3VyYXIgc2lzdGVtYXMgZGUgY29vcmRlbmFkYXNcIixcblx0XHR1bmFibGVUb1JlcG9wdWxhdGVPdXRTUjogXCJOw6NvIMOpIHBvc3PDrXZlbCBwcmVlbmNoZXIgbyBzaXN0ZW1hIGRlIGNvb3JkZW5hZGFzIGRlIHNhw61kYS5cIixcblx0XHRkZWZhdWx0VGl0bGU6IFwiVmVyIG1haXNcIixcblx0XHRcIkFSQyAoZXF1YWwgYXJjLXNlY29uZClcIjogXCJBUkMgKGFyY28tc2VndW5kbyBpZ3VhbClcIixcblx0XHRBZnJpY2E6IFwiw4FmcmljYVwiLFxuXHRcdEFudGFyY3RpY2E6IFwiQW50w6FydGljYVwiLFxuXHRcdEFyZ2VudGluYTogXCJBcmdlbnRpbmFcIixcblx0XHRBc2lhOiBcIsOBc2lhXCIsXG5cdFx0XCJBc3Rlcm9pZCBCZWx0XCI6IFwiQ2ludHVyYSBkZSBBc3Rlcm9pZGVzXCIsXG5cdFx0XCJBdGxhbnRpYyBPY2VhblwiOiBcIk9jZWFubyBBdGzDom50aWNvXCIsXG5cdFx0QXVzdHJhbGlhOiBcIkF1c3Ryw6FsaWFcIixcblx0XHRcIkF1c3RyYWxpYSBhbmQgTmV3IFplYWxhbmRcIjogXCJBdXN0csOhbGlhIGUgTm92YSBaZWzDom5kaWFcIixcblx0XHRBdXN0cmlhOiBcIsOBdXN0cmlhXCIsXG5cdFx0XCJCTE0gKFVTIEZlZXQpXCI6IFwiQkxNIChQw6lzIEVVQSlcIixcblx0XHRCYW5nbGFkZXNoOiBcIkJhbmdsYWRlc2hcIixcblx0XHRcIkJlaWppbmcgMTk1NFwiOiBcIkJlaWppbmcgMTk1NFwiLFxuXHRcdEJodXRhbjogXCJCdXTDo29cIixcblx0XHRDR0NTMjAwMDogXCJDR0NTMjAwMFwiLFxuXHRcdENhbmFkYTogXCJDYW5hZMOhXCIsXG5cdFx0Q2FyaWJiZWFuOiBcIkNhcmHDrWJhc1wiLFxuXHRcdFwiQ2FyaWJiZWFuIFNlYVwiOiBcIk1hciBkYXMgQ2FyYcOtYmFzXCIsXG5cdFx0XCJDZW50cmFsIEFtZXJpY2FcIjogXCJBbcOpcmljYSBDZW50cmFsXCIsXG5cdFx0XCJDZW50cmFsIGFuZCBOb3J0aCBBbWVyaWNhXCI6IFwiQW3DqXJpY2EgQ2VudHJhbCBlIGRvIE5vcnRlXCIsXG5cdFx0Q29sb21iaWE6IFwiQ29sw7RtYmlhXCIsXG5cdFx0Q29udGluZW50YWw6IFwiQ29udGluZW50YWxcIixcblx0XHRcIkNvdW50eSBTeXN0ZW1zXCI6IFwiU2lzdGVtYXMgZGUgQ29uZGFkb3NcIixcblx0XHRcIkRlbW9jcmF0aWMgUmVwdWJsaWMgb2YgdGhlIENvbmdvXCI6IFwiUmVww7pibGljYSBEZW1vY3LDoXRpY2EgZG8gQ29uZ29cIixcblx0XHRcIkVQU0cgQXJjdGljXCI6IFwiw4FydGljbyBFUFNHXCIsXG5cdFx0RWFydGg6IFwiVGVycmFcIixcblx0XHRcIkVsbGlwc29pZGFsLWJhc2VkXCI6IFwiQmFzZWFkbyBlbSBlbGlwc29pZGFsXCIsXG5cdFx0RXVyb3BlOiBcIkV1cm9wYVwiLFxuXHRcdEZpbmxhbmQ6IFwiRmlubMOibmRpYVwiLFxuXHRcdEZyYW5jZTogXCJGcmFuw6dhXCIsXG5cdFx0XCJHU0sgMjAxMVwiOiBcIkdTSyAyMDExXCIsXG5cdFx0XCJHYXVzcyBLcnVnZXJcIjogXCJHYXVzcyBLcnVnZXJcIixcblx0XHRcIkdlb2dyYXBoaWMgQ29vcmRpbmF0ZSBTeXN0ZW1zXCI6IFwiU2lzdGVtYXMgZGUgQ29vcmRlbmFkYXMgR2VvZ3LDoWZpY2FzXCIsXG5cdFx0R2VybWFueTogXCJBbGVtYW5oYVwiLFxuXHRcdFwiR3Jhdml0eS1yZWxhdGVkXCI6IFwiUmVsYWNpb25hZG8gY29tIGdyYXZpZGFkZVwiLFxuXHRcdFwiR3JlZW53aWNoLWJhc2VkXCI6IFwiQmFzZWFkbyBlbSBHcmVlbndpY2hcIixcblx0XHRcIkhpZ2h3YXlzIEVuZ2xhbmRcIjogXCJBdXRvZXN0cmFkYXMgZGUgSW5nbGF0ZXJyYVwiLFxuXHRcdElsbGlub2lzOiBcIklsbGlub2lzXCIsXG5cdFx0XCJJbmRpYW4gT2NlYW5cIjogXCJPY2Vhbm8gw41uZGljb1wiLFxuXHRcdFwiSW5kaWFuIFN1YmNvbnRpbmVudFwiOiBcIlN1YmNvbnRpbmVudGUgSW5kaWFub1wiLFxuXHRcdEluZGlhbmE6IFwiSW5kaWFuYVwiLFxuXHRcdEluZG9uZXNpYTogXCJJbmRvbsOpc2lhXCIsXG5cdFx0SW93YTogXCJJb3dhXCIsXG5cdFx0XCJJcmVsYW5kIGFuZCBVbml0ZWQgS2luZ2RvbVwiOiBcIklybGFuZGEgZSBSZWlubyBVbmlkb1wiLFxuXHRcdEl0YWx5OiBcIkl0w6FsaWFcIixcblx0XHRKYXBhbjogXCJKYXDDo29cIixcblx0XHRKdXBpdGVyOiBcIkrDunBpdGVyXCIsXG5cdFx0S2Fuc2FzOiBcIkthbnNhc1wiLFxuXHRcdFwiTGFzIFZlZ2FzXCI6IFwiTGFzIFZlZ2FzXCIsXG5cdFx0TGlieWE6IFwiTMOtYmlhXCIsXG5cdFx0TWFsYXlzaWE6IFwiTWFsw6FzaWFcIixcblx0XHRcIk1hbGF5c2lhIGFuZCBTaW5nYXBvcmVcIjogXCJNYWzDoXNpYSBlIFNpbmdhcHVyYVwiLFxuXHRcdE1hcnM6IFwiTWFydGVcIixcblx0XHRNZXJjdXJ5OiBcIk1lcmPDunJpb1wiLFxuXHRcdE1pbm5lc290YTogXCJNaW5uZXNvdGFcIixcblx0XHRNb250YW5hOiBcIk1vbnRhbmFcIixcblx0XHRcIk5BRCAxOTI3XCI6IFwiTkFEIDE5MjdcIixcblx0XHRcIk5BRCAxOTI3IChVUyBGZWV0KVwiOiBcIk5BRCAxOTI3IChQw6lzIEVVQSlcIixcblx0XHRcIk5BRCAxOTgzXCI6IFwiTkFEIDE5ODNcIixcblx0XHRcIk5BRCAxOTgzICgyMDExKVwiOiBcIk5BRCAxOTgzICgyMDExKVwiLFxuXHRcdFwiTkFEIDE5ODMgKDIwMTEpIChJbnRsIEZlZXQpXCI6IFwiTkFEIDE5ODMgKDIwMTEpIChQw6lzIEludC4pXCIsXG5cdFx0XCJOQUQgMTk4MyAoMjAxMSkgKE1ldGVycylcIjogXCJOQUQgMTk4MyAoMjAxMSkgKE1ldHJvcylcIixcblx0XHRcIk5BRCAxOTgzICgyMDExKSAoVVMgRmVldClcIjogXCJOQUQgMTk4MyAoMjAxMSkgKFDDqXMgRVVBKVwiLFxuXHRcdFwiTkFEIDE5ODMgKENPUlM5NikgKEludGwgRmVldClcIjogXCJOQUQgMTk4MyAoQ09SUzk2KSAoUMOpcyBJbnQuKVwiLFxuXHRcdFwiTkFEIDE5ODMgKENPUlM5NikgKE1ldGVycylcIjogXCJOQUQgMTk4MyAoQ09SUzk2KSAoTWV0cm9zKVwiLFxuXHRcdFwiTkFEIDE5ODMgKENPUlM5NikgKFVTIEZlZXQpXCI6IFwiTkFEIDE5ODMgKENPUlM5NikgKFDDqXMgRVVBKVwiLFxuXHRcdFwiTkFEIDE5ODMgKEludGwgRmVldClcIjogXCJOQUQgMTk4MyAoUMOpcyBJbnQuKVwiLFxuXHRcdFwiTkFEIDE5ODMgKE1ldGVycylcIjogXCJOQUQgMTk4MyAoTWV0cm9zKVwiLFxuXHRcdFwiTkFEIDE5ODMgKFBBMTEpIChNZXRlcnMpXCI6IFwiTkFEIDE5ODMgKFBBMTEpIChNZXRyb3MpXCIsXG5cdFx0XCJOQUQgMTk4MyAoUEExMSkgKFVTIEZlZXQpXCI6IFwiTkFEIDE5ODMgKFBBMTEpIChQw6lzIEVVQSlcIixcblx0XHRcIk5BRCAxOTgzIChVUyBGZWV0KVwiOiBcIk5BRCAxOTgzIChQw6lzIEVVQSlcIixcblx0XHRcIk5BRCAxOTgzIEhBUk4gKEludGwgRmVldClcIjogXCJOQUQgMTk4MyBIQVJOIChQw6lzIEludC4pXCIsXG5cdFx0XCJOQUQgMTk4MyBIQVJOIChNZXRlcnMpXCI6IFwiTkFEIDE5ODMgSEFSTiAoTWV0cm9zKVwiLFxuXHRcdFwiTkFEIDE5ODMgSEFSTiAoVVMgRmVldClcIjogXCJOQUQgMTk4MyBIQVJOIChQw6lzIEVVQSlcIixcblx0XHRcIk5BRCAxOTgzIE5TUlMyMDA3IChJbnRsIEZlZXQpXCI6IFwiTkFEIDE5ODMgTlNSUzIwMDcgKFDDqXMgSW50LilcIixcblx0XHRcIk5BRCAxOTgzIE5TUlMyMDA3IChNZXRlcnMpXCI6IFwiTkFEIDE5ODMgTlNSUzIwMDcgKE1ldHJvcylcIixcblx0XHRcIk5BRCAxOTgzIE5TUlMyMDA3IChVUyBGZWV0KVwiOiBcIk5BRCAxOTgzIE5TUlMyMDA3IChQw6lzIEVVQSlcIixcblx0XHRcIk5hdGlvbmFsIEdyaWRzXCI6IFwiR3JlbGhhcyBOYWNpb25haXNcIixcblx0XHROYXZham86IFwiTmF2YWpvXCIsXG5cdFx0TmVwdHVuZTogXCJOZXB0dW5vXCIsXG5cdFx0XCJOZXcgQmVpamluZ1wiOiBcIk5vdm8gUGVxdWltXCIsXG5cdFx0XCJOZXcgWmVhbGFuZFwiOiBcIk5vdmEgWmVsw6JuZGlhXCIsXG5cdFx0XCJOb3J0aCBBbWVyaWNhXCI6IFwiQW3DqXJpY2EgZG8gTm9ydGVcIixcblx0XHRcIk5vcnRoZXJuIEhlbWlzcGhlcmVcIjogXCJIZW1pc2bDqXJpbyBOb3J0ZVwiLFxuXHRcdE5vcndheTogXCJOb3J1ZWdhXCIsXG5cdFx0T2NlYW5zOiBcIk9jZWFub3NcIixcblx0XHRPcmVnb246IFwiT3JlZ29uXCIsXG5cdFx0XCJPdGhlciBHQ1NcIjogXCJPdXRybyBHQ1NcIixcblx0XHRcIlBhY2lmaWMgT2NlYW5cIjogXCJPY2Vhbm8gUGFjw61maWNvXCIsXG5cdFx0UGx1dG86IFwiUGx1dMOjb1wiLFxuXHRcdFBvbGFyOiBcIlBvbGFyXCIsXG5cdFx0UG9ydHVnYWw6IFwiUG9ydHVnYWxcIixcblx0XHRcIlByb2plY3RlZCBDb29yZGluYXRlIFN5c3RlbXNcIjogXCJTaXN0ZW1hcyBkZSBDb29yZGVuYWRhcyBQcm9qZXRhZGFzXCIsXG5cdFx0XCJQdWxrb3ZvIDE5NDJcIjogXCJQdWxrb3ZvIDE5NDJcIixcblx0XHRcIlB1bGtvdm8gMTk5NVwiOiBcIlB1bGtvdm8gMTk5NVwiLFxuXHRcdFJlcGxhY2VkOiBcIlN1YnN0aXR1w61kb1wiLFxuXHRcdFwiU0FEIDE5NjlcIjogXCJTQUQgMTk2OVwiLFxuXHRcdFNJUkdBUzogXCJTSVJHQVNcIixcblx0XHRcIlNJUkdBUyAyMDAwXCI6IFwiU0lSR0FTIDIwMDBcIixcblx0XHRTYXR1cm46IFwiU2F0dXJub1wiLFxuXHRcdFwiU29sYXIgU3lzdGVtXCI6IFwiU2lzdGVtYSBTb2xhclwiLFxuXHRcdFwiU291dGggQWZyaWNhXCI6IFwiw4FmcmljYSBkbyBTdWxcIixcblx0XHRcIlNvdXRoIEFtZXJpY2FcIjogXCJBbcOpcmljYSBkbyBTdWxcIixcblx0XHRcIlNvdXRoIEtvcmVhXCI6IFwiQ29yZWlhIGRvIFN1bFwiLFxuXHRcdFwiU291dGhlcm4gSGVtaXNwaGVyZVwiOiBcIkhlbWlzZsOpcmlvIFN1bFwiLFxuXHRcdFwiU3BoZXJvaWQtYmFzZWRcIjogXCJCYXNlYWRvIGVtIGVzZmVyw7NpZGVzXCIsXG5cdFx0XCJTdGF0ZSBQbGFuZVwiOiBcIlBsYW5vIEVzdGF0YWxcIixcblx0XHRcIlN0YXRlIFN5c3RlbXNcIjogXCJTaXN0ZW1hcyBkZSBFc3RhZG9zXCIsXG5cdFx0U3dlZGVuOiBcIlN1w6ljaWFcIixcblx0XHRcIlN3aXR6ZXJsYW5kIGFuZCBMaWVjaHRlbnN0ZWluXCI6IFwiU3XDrcOnYSBlIExpZWNodGVuc3RlaW5cIixcblx0XHRUZXhhczogXCJUZXhhc1wiLFxuXHRcdFRyaWJhbDogXCJUcmliYWxcIixcblx0XHRUdXJrZXk6IFwiVHVycXVpYVwiLFxuXHRcdFwiVVMgRmVldFwiOiBcIlDDqXMgRVVBXCIsXG5cdFx0XCJVU0EgYW5kIHRlcnJpdG9yaWVzXCI6IFwiRVVBIGUgdGVycml0w7NyaW9zXCIsXG5cdFx0VVRNOiBcIlVUTVwiLFxuXHRcdFVrcmFpbmU6IFwiVWNyw6JuaWFcIixcblx0XHRcIlVua25vd24gSGVpZ2h0IFN5c3RlbXNcIjogXCJTaXN0ZW1hcyBkZSBBbHR1cmEgRGVzY29uaGVjaWRvc1wiLFxuXHRcdFVyYW51czogXCLDmnJhbm9cIixcblx0XHRWZW51czogXCJWw6ludXNcIixcblx0XHRcIlZlcnRpY2FsIENvb3JkaW5hdGUgU3lzdGVtc1wiOiBcIlNpc3RlbWFzIGRlIENvb3JkZW5hZGFzIFZlcnRpY2Fpc1wiLFxuXHRcdFZpZXRuYW06IFwiVmlldG5hbWVcIixcblx0XHRcIldHUyAxOTcyXCI6IFwiV0dTIDE5NzJcIixcblx0XHRcIldHUyAxOTg0XCI6IFwiV0dTIDE5ODRcIixcblx0XHRXaXNjb25zaW46IFwiV2lzY29uc2luXCIsXG5cdFx0XCJXaXNjb25zaW4gQ1JTXCI6IFwiV2lzY29uc2luIENSU1wiLFxuXHRcdFdvcmxkOiBcIk11bmRvXCIsXG5cdFx0XCJXb3JsZCAoU3BoZXJlLWJhc2VkKVwiOiBcIk11bmRvIChCYXNlYWRvIGVtIGVzZmVyYXMpXCIsXG5cdFx0V3lvbWluZzogXCJXeW9taW5nXCIsXG5cdFx0XCJYaWFuIDE5ODBcIjogXCJYaWFuIDE5ODBcIixcblx0XHRkb25lOiBcIkNvbmNsdcOtZG9cIixcblx0XHRub1Jlc3VsdHM6IFwiTmVuaHVtIHJlc3VsdGFkbyBlbmNvbnRyYWRvXCIsXG5cdFx0c2VhcmNoUGxhY2Vob2xkZXI6IFwiTm9tZSBvdSBXS0lEXCIsXG5cdFx0YnJvd3NlVGVtcGxhdGU6IFwiUHJvY3VyYXIgdGVtcGxhdGVzIGRlIGZ1bsOnw6NvIHJhc3RlclwiLFxuXHRcdHNhdmVUZW1wbGF0ZTogXCJHdWFyZGFyIHRlbXBsYXRlIGRlIGZ1bsOnw6NvIHJhc3RlclwiLFxuXHRcdHByZXZpZXc6IFwiUHLDqS12aXN1YWxpemFyXCIsXG5cdFx0cHJldmlld0Rlc2NyaXB0aW9uOiBcIlByw6ktdmlzdWFsaXplIG8gcmVzdWx0YWRvIGFudGVzIGRlIGVmZXR1YXIgYSBhbsOhbGlzZS5cIixcblx0XHRzaG93UHJldmlldzogXCJFeGliaXIgcHLDqS12aXN1YWxpemHDp8Ojb1wiLFxuXHRcdHByZXZpZXdMYXllcjogXCJQcsOpLXZpc3VhbGl6YXIgY2FtYWRhICR7bnVtYmVyfVwiLFxuXHRcdG5ld1ByZXZpZXc6IFwiTm92YSBwcsOpLXZpc3VhbGl6YcOnw6NvXCIsXG5cdFx0cHJldmlld1BvcHVwOiBcIkF0aXZlIGEgcHLDqS12aXN1YWxpemHDp8OjbyBkb3MgcmVzdWx0YWRvcyBkYSBhbsOhbGlzZSBjb20gYmFzZSBub3MgcGFyw6JtZXRyb3MgZGUgZW50cmFkYS5cIixcblx0XHR1cGRhdGVQcmV2aWV3TGF5ZXI6IFwiQXR1YWxpemFyIGEgY2FtYWRhIGRlIHByw6ktdmlzdWFsaXphw6fDo28gc2VsZWNpb25hZGFcIixcblx0XHRjcmVhdGVQcmV2aWV3TGF5ZXI6IFwiQ3JpYXIgbm92YSBjYW1hZGEgZGUgcHLDqS12aXN1YWxpemHDp8Ojb1wiLFxuXHRcdG1heGltdW1QcmV2aWV3QWxsb3dlZDogXCJOw7ptZXJvIG3DoXhpbW8gZGUgY2FtYWRhcyBkZSBwcsOpLXZpc3VhbGl6YcOnw6NvIHBlcm1pdGlkbzogJHttYXhDb3VudH1cIixcblx0XHRwcmV2aWV3RmFpbHVyZTogXCJFc3RhIGNhbWFkYSBkZSBwcsOpLXZpc3VhbGl6YcOnw6NvIG7Do28gZXN0w6EgZGlzcG9uw612ZWwuIFZlcmlmaXF1ZSBvcyBwYXLDom1ldHJvcyBkZSBlbnRyYWRhIGUgYXR1YWxpemUgbm92YW1lbnRlIGVzdGEgY2FtYWRhIGRlIHByw6ktdmlzdWFsaXphw6fDo28uXCIsXG5cdFx0aGVhZGVyOiBcIlNlbGVjaW9uYXIgaXRlbVwiLFxuXHRcdGNvbnRlbnQ6IFwiVGVtIGFsdGVyYcOnw7VlcyBuw6NvIGd1YXJkYWRhcyBlbSAke3JmdFRpdGxlfS4gU2UgY29tZcOnYXIgbm92YW1lbnRlIGNvbSB1bSBub3ZvIHRlbXBsYXRlLCBlc3NhcyBhbHRlcmHDp8O1ZXMgcGVyZGVyLXNlLcOjby5cIixcblx0XHRkb250U2F2ZTogXCJOw6NvIGd1YXJkYXJcIixcblx0XHRcImNvbnRpbnVlXCI6IFwiQ29udGludWFyXCIsXG5cdFx0c3RyZXRjaDogXCJBanVzdGFyIMOgIGphbmVsYVwiLFxuXHRcdHBhbjogXCJNb3ZlclwiLFxuXHRcdG5ld1RlbXBsYXRlOiBcIkNyaWFyIG5vdm8gdGVtcGxhdGVcIixcblx0XHRvcGVuVGVtcGxhdGU6IFwiQWJyaXIgdGVtcGxhdGVcIixcblx0XHRhZGRGdW5jdGlvbjogXCJBZGljaW9uYXIgZnVuw6fDtWVzIHJhc3RlclwiLFxuXHRcdGFkZENvbnN0YW50OiBcIkFkaWNpb25hciBjb25zdGFudGVcIixcblx0XHRhZGRSYXN0ZXI6IFwiQWRpY2lvbmFyIHZhcmnDoXZlbCByYXN0ZXJcIixcblx0XHRtb3ZlOiBcIk1vdmVyXCIsXG5cdFx0em9vbTogXCJab29tXCIsXG5cdFx0c2F2ZUFzOiBcIkd1YXJkYXIgY29tb1wiLFxuXHRcdGNsZWFyOiBcIkxpbXBhclwiLFxuXHRcdGFkZFJhc3RlckZ1bmN0aW9uVGl0bGU6IFwiQWRpY2lvbmFyIGZ1bsOnw7VlcyByYXN0ZXJcIixcblx0XHR0ZW1wbGF0ZVByb3BlcnRpZXNUaXRsZTogXCJQcm9wcmllZGFkZXMgZG8gdGVtcGxhdGVcIixcblx0XHRicm93c2VSRlQ6IFwiUHJvY3VyYXIgdGVtcGxhdGVzIGRlIGZ1bsOnw6NvIHJhc3RlclwiLFxuXHRcdGRlZmF1bHRUb29sRGVzY3JpcHRpb246IFwiRmVycmFtZW50YSBkZSBhbsOhbGlzZSAke3Rvb2xUaXRsZX0uXCIsXG5cdFx0b3BlblRvb2xUZXh0OiBcIkFicmlyIEZlcnJhbWVudGFcIixcblx0XHR0b29sRHJvcGRvd25UZXh0OiBcIkxpc3RhIFBlbmRlbnRlIGRhIEZlcnJhbWVudGFcIixcblx0XHRhZGRUb01hcDogXCJDb25maXJtYXIgZSBhZGljaW9uYXIgYW8gbWFwYVwiLFxuXHRcdGNvbmZpcm06IFwiQ29uZmlybWFyXCIsXG5cdFx0c2VsZWN0OiBcIlNlbGVjaW9uYXJcIixcblx0XHRzZWxlY3RUYXNrOiBcIlNlbGVjaW9uYXIgdGFyZWZhXCIsXG5cdFx0dW5zdXBwb3J0ZWRMYXllcjogXCJFc3RlIHBhcsOibWV0cm8gbsOjbyBzdXBvcnRhIGFzIHNlZ3VpbnRlcyBjYW1hZGFzOiAke2xheWVyTmFtZX0uXCIsXG5cdFx0dmlld0RldGFpbHM6IFwiVmVyIGRldGFsaGVzIGNvbXBsZXRvcyBkbyBpdGVtXCIsXG5cdFx0cmVuYW1lOiBcIkFsdGVyYXIgbyBub21lXCIsXG5cdFx0ZHVwbGljYXRlOiBcIkR1cGxpY2FyXCIsXG5cdFx0bGF1bmNoOiBcIkFicmlyIHBhcmEgZXhlY3XDp8Ojb1wiLFxuXHRcdHRlbXBsYXRlRWRpdG9yOiBcIkVkaXRvciBkZSBUZW1wbGF0ZXNcIixcblx0XHRjcmVhdGVJdGVtOiBcIkd1YXJkYXIgVGVtcGxhdGUgZGUgRnVuw6fDo28gUmFzdGVyXCIsXG5cdFx0YWN0aW9uTGFiZWw6IFwiRmlsdHJhclwiLFxuXHRcdGZpbHRlclBvcG92ZXJIZWFkaW5nOiBcIkZpbHRyYXIgYXMgZnVuw6fDtWVzXCIsXG5cdFx0ZGVmYXVsdFNlYXJjaFBsYWNlaG9sZGVyOiBcIlBlc3F1aXNhciBwb3Igbm9tZVwiLFxuXHRcdHNldHRpbmdzOiBcIkRlZmluacOnw7Vlc1wiLFxuXHRcdHN1bW1hcnk6IFwiUmVzdW1vXCIsXG5cdFx0ZGVmaW5pdGlvblF1ZXJ5OiBcIkNvbnN1bHRhIGRlIGRlZmluacOnw6NvXCIsXG5cdFx0bWF0Y2hWYXJpYWJsZXM6IFwiQ29ycmVzcG9uZGVyIHZhcmnDoXZlaXNcIixcblx0XHR1bmlvbkRpbWVuc2lvbjogXCJEaW1lbnPDo28gZGUgdW5pw6NvXCIsXG5cdFx0bmFtZUVkaXRvclBsYWNlaG9sZGVyOiBcIkludHJvZHV6aXIgdMOtdHVsb1wiLFxuXHRcdHN1bW1hcnlFZGl0b3JQbGFjZWhvbGRlcjogXCJJbnRyb2R1emEgdW1hIGJyZXZlIGRlc2NyacOnw6NvLlwiLFxuXHRcdGRlZmluaXRpb25RdWVyeVBsYWNlaG9sZGVyOiBcIkludHJvZHV6YS4uLlwiLFxuXHRcdHVwbG9hZDogXCJDYXJyZWdhclwiLFxuXHRcdGNob29zZUltYWdlOiBcIkNsaXF1ZSBwYXJhIHNlbGVjaW9uYXIgdW0gZmljaGVpcm9cIixcblx0XHR1cGRhdGU6IFwiQXR1YWxpemFyXCIsXG5cdFx0dGh1bWJuYWlsRXJyb3JzOiB7XG5cdFx0XHR3cm9uZ0ltYWdlVHlwZTogXCJUaXBvIGRlIGltYWdlbSBlcnJhZG8gc2VsZWNpb25hZG9cIixcblx0XHRcdG5vdEF2YWlsYWJsZTogXCJJbWFnZW0gbWluaWF0dXJhIGluZGlzcG9uw612ZWxcIixcblx0XHRcdGxvYWRFcnJvcjogXCJOw6NvIGZvaSBwb3Nzw612ZWwgY2FycmVnYXIgYSBpbWFnZW1cIixcblx0XHRcdGNob29zZUZpbGU6IFwiQ2xpcXVlIHBhcmEgc2VsZWNpb25hciBmaWNoZWlyb1wiXG5cdFx0fVxuXHR9XG59O1xuY29uc3QgY29weSA9IFwiQ29waWFyXCI7XG5jb25zdCBzYXZlID0gXCJHdWFyZGFyXCI7XG5jb25zdCB0aXRsZSA9IFwiVMOtdHVsb1wiO1xuY29uc3QgZm9sZGVyID0gXCJQYXN0YVwiO1xuY29uc3QgdGFncyA9IFwiRXRpcXVldGFzXCI7XG5jb25zdCBzYXZpbmdNZXNzYWdlID0gXCJHdWFyZGFyIGl0ZW0gcGFyYVwiO1xuY29uc3Qgc2hhcmVXaXRoID0gXCJQYXJ0aWxoYXIgQ29tXCI7XG5jb25zdCBzaGFyZSA9IFwiUGFydGlsaGFyXCI7XG5jb25zdCBzZXRTaGFyaW5nTGV2ZWwgPSBcIkRlZmluaXIgTsOtdmVsIGRlIFBhcnRpbGhhXCI7XG5jb25zdCBzZXRHcm91cFNoYXJpbmcgPSBcIkRlZmluaXIgUGFydGlsaGEgZGUgR3J1cG9cIjtcbmNvbnN0IG93bmVyID0gXCJQcm9wcmlldMOhcmlvXCI7XG5jb25zdCBvcmdhbml6YXRpb24gPSBcIk9yZ2FuaXphw6fDo29cIjtcbmNvbnN0IGV2ZXJ5b25lID0gXCJUb2RvcyAocMO6YmxpY28pXCI7XG5jb25zdCBncm91cHMgPSBcIkdydXBvczpcIjtcbmNvbnN0IHR5cGUgPSBcIlRpcG9cIjtcbmNvbnN0IG1vc2FpYyA9IFwiTW9zYWljb1wiO1xuY29uc3QgaXRlbUdyb3VwID0gXCJHcnVwbyBkZSBpdGVtXCI7XG5jb25zdCBpdGVtID0gXCJJdGVtXCI7XG5jb25zdCBkZWZpbml0aW9uUXVlcnkgPSBcIkNvbnN1bHRhIGRlIGRlZmluacOnw6NvXCI7XG5jb25zdCBncm91cEl0ZW1zQnkgPSBcIkFncnVwYXIgSXRlbnMgUG9yXCI7XG5jb25zdCBncm91cEZpZWxkTmFtZSA9IFwiQWdydXBhciBOb21lIGRlIENhbXBvXCI7XG5jb25zdCB0YWdGaWVsZE5hbWUgPSBcIklkZW50aWZpY2FyIE5vbWUgZGUgQ2FtcG9cIjtcbmNvbnN0IG5vVGl0bGVUYWdFcnJvck1zZyA9IFwiRGV2ZSBmb3JuZWNlciB1bSB0w610dWxvIHBhcmEgbyBzZXUgaXRlbSBlIGV0aXF1ZXRhcyBwYXJhIHBlcm1pdGlyIHF1ZSBvIHNldSBtYXBhIHNlamEgZW5jb250cmFkbyBhdHJhdsOpcyBkZSBwZXNxdWlzYXMuXCI7XG5jb25zdCBub1RpdGxlRXJyb3JNc2cgPSBcIkRldmUgZm9ybmVjZXIgdW0gdMOtdHVsbyBwYXJhIG8gaXRlbS5cIjtcbmNvbnN0IG5vVGFnRXJyb3JNc2cgPSBcIkRldmUgZm9ybmVjZXIgcGVsbyBtZW5vcyB1bWEgZXRpcXVldGEgcGFyYSBhanVkYXIgYXMgcGVzc29hcyBhIGVuY29udHJhciBvIHNldSBpdGVtIGF0cmF2w6lzIGRlIHBlc3F1aXNhcy5cIjtcbmNvbnN0IGVycm9yID0gXCJFcnJvXCI7XG5jb25zdCB3YXJuaW5nID0gXCJBdmlzb1wiO1xuY29uc3Qgc3VjY2VzcyA9IFwiUmVhbGl6YWRvIGNvbSBTdWNlc3NvXCI7XG5jb25zdCBkZXRhaWxzID0gXCJEZXRhbGhlczpcIjtcbmNvbnN0IHRyeUFnYWluID0gXCJUZW50ZSBub3ZhbWVudGVcIjtcbmNvbnN0IHRvb2xNb2RlbGVyID0ge1xuXHRzYXZlOiBcIkd1YXJkYXJcIixcblx0ZWRpdFByb3BlcnRpZXM6IFwiRWRpdGFyIFByb3ByaWVkYWRlc1wiLFxuXHRzYXZlQXM6IFwiR3VhcmRhciBDb21vXCIsXG5cdHNhdmluZ05vdGlmaWNhdGlvbjogXCJHdWFyZGFyIGFsdGVyYcOnw7VlcyBubyBpdGVtLi4uXCIsXG5cdHNhdmluZ1RpdGxlOiBcIkEgR3VhcmRhclwiLFxuXHRzYXZlRmFpbGVkTWVzc2FnZTogXCJOw6NvIGZvaSBwb3Nzw612ZWwgZ3VhcmRhciBhbHRlcmHDp8O1ZXMuXCIsXG5cdHNhdmVXaXRoRXJyb3JzTWVzc2FnZTogXCJBcyBhbHRlcmHDp8O1ZXMgZm9yYW0gZ3VhcmRhZGFzIGNvbSBvcyBzZWd1aW50ZXMgZXJyb3MuXCIsXG5cdHZpZXdJdGVtTWVzc2FnZTogXCJWZXIgaXRlbSBndWFyZGFkb1wiLFxuXHRoZXJlOiBcImFxdWkuXCIsXG5cdGl0ZW1DcmVhdGVkTWVzc2FnZTogXCJGb2kgY3JpYWRvIHVtIG5vdm8gaXRlbS5cIixcblx0Y2xpY2tUb1ZpZXdJdGVtTWVzc2FnZTogXCJDbGlxdWUgZW0gT0sgcGFyYSB2ZXIgYSBww6FnaW5hIGRlIGRldGFsaGVzIGRvIGl0ZW0uIENsaXF1ZSBlbSBDYW5jZWxhciBwYXJhIGNvbnRpbnVhci5cIixcblx0cmVhZGluZ0ZhaWxlZDogXCJGYWxoYSBhbyBjYXJyZWdhciBvIG1vZGVsbyBkZSBmdW5jaW9uYW1lbnRvIGRlIHJhc3RlciBzZWxlY2lvbmFkby5cIixcblx0ZmFpbGVkVG9Mb2FkWE1MOiBcIkZhbGhhIGFvIGNhcnJlZ2FyIG8gdGVtcGxhdGUgZGEgZnVuw6fDo28gcmFzdGVyIHNlbGVjaW9uYWRvIG5vIGZvcm1hdG8gWE1MLlwiLFxuXHRsZWFybk1vcmU6IFwiU2FpYmEgbWFpc1wiLFxuXHRvdmVyd3JpdGVUaXRsZTogXCJDb25maXJtYXIgc3Vic3RpdHVpw6fDo29cIixcblx0b3ZlcndyaXRlTWVzc2FnZTogXCJQcmV0ZW5kZSBzdWJzdGl0dWlyIG8gaXRlbSBleGlzdGVudGU/XCIsXG5cdG92ZXJ3cml0ZVN1Y2Nlc3NNZXNzYWdlOiBcIk8gaXRlbSBmb2kgYXR1YWxpemFkby5cIlxufTtcbmNvbnN0IHRvb2xFZGl0b3IgPSB7XG5cdHJ1bjogXCJFeGVjdXRhclwiLFxuXHRzYXZlOiBcIkd1YXJkYXJcIixcblx0ZGVsZXRlU2VsZWN0ZWQ6IFwiRWxpbWluYXIgaXRlbnMgc2VsZWNpb25hZG9zXCIsXG5cdGFkZFJhc3RlcjogXCJBZGljaW9uYXIgUmFzdGVyXCIsXG5cdGFkZFNjYWxhcjogXCJBZGljaW9uYXIgRXNjYWxhclwiLFxuXHRsYXlvdXQ6IFwiTGF5b3V0IEF1dG9cIixcblx0ZXJyb3JUaXRsZTogXCJFcnJvXCIsXG5cdGludmFsaWRUb29sTWVzc2FnZTogXCJPIG1vZGVsbyBkZSBmdW5jaW9uYW1lbnRvIFJhc3RlciBuw6NvIMOpIHbDoWxpZG8uXCIsXG5cdG91dDogXCJGb3JhXCIsXG5cdHpvb21JbjogXCJBdW1lbnRhciBab29tXCIsXG5cdHpvb21PdXQ6IFwiUmVkdXppciBab29tXCIsXG5cdHpvb21Ub0ZpdDogXCJBanVzdGFyIMOgIGphbmVsYVwiLFxuXHRwYW5PbjogXCJNdWRhciBwYXJhIG1vZG8gZGUgbW92ZXJcIixcblx0cGFuT2ZmOiBcIkRlc2xpZ2FyIG1vZG8gZGUgbW92ZXJcIixcblx0ZGVmYXVsdE1vZGVsTmFtZTogXCJNb2RlbG8gZmVycmFtZW50YVwiLFxuXHRkZWZhdWx0UmFzdGVyTmFtZTogXCJSYXN0ZXJcIlxufTtcbmNvbnN0IHRvb2xEZXRhaWxzRWRpdG9yID0ge1xuXHRkZWZhdWx0VG9vbE5hbWU6IFwiTW9kZWxvIGRlIEZ1bsOnw6NvIFJhc3RlclwiLFxuXHRkZWZhdWx0VG9vbERlc2NyaXB0aW9uOiBcIkFkaWNpb25lIHVtIGJyZXZlIHJlc3VtbyBhY2VyY2EgZGEgZnVuw6fDo28gcmFzdGVyLlwiLFxuXHRkZWZhdWx0SGVscFRleHQ6IFwiQ2xpcXVlIG5vIMOtY29uZSBhanVkYSBwYXJhIGVkaXRhciBvIHRleHRvIGRlIGFqdWRhXCIsXG5cdGVkaXRIZWxwVGl0bGU6IFwiRWRpdGFyIEFqdWRhXCIsXG5cdHNhdmVMYWJlbDogXCJHdWFyZGFyXCIsXG5cdGNhbmNlbExhYmVsOiBcIkNhbmNlbGFyXCIsXG5cdHRodW1ibmFpbDoge1xuXHRcdHdyb25nSW1hZ2VUeXBlOiBcIlRpcG8gZGUgaW1hZ2VtIGVycmFkbyBzZWxlY2lvbmFkb1wiLFxuXHRcdG5vdEF2YWlsYWJsZTogXCJJbWFnZW0gbWluaWF0dXJhIGluZGlzcG9uw612ZWxcIixcblx0XHRsb2FkRXJyb3I6IFwiSW1wb3Nzw612ZWwgY2FycmVnYXIgYSBpbWFnZW1cIixcblx0XHRjaG9vc2VGaWxlOiBcIkNsaXF1ZSBwYXJhIHNlbGVjaW9uYXIgZmljaGVpcm9cIlxuXHR9XG59O1xuY29uc3Qgc2F2ZVV0aWxzID0ge1xuXHR0aHVtYm5haWw6IFwiTWluaWF0dXJhXCIsXG5cdHNoYXJpbmc6IFwiQSBQYXJ0aWxoYXJcIlxufTtcbmNvbnN0IGNsb3NlID0gXCJGZWNoYXJcIjtcbmNvbnN0IHVuc2F2ZWRXYXJuaW5nRXhpc3RpbmcgPSBcIlByZXRlbmRlIGd1YXJkYXIgYXMgYWx0ZXJhw6fDtWVzIHJlYWxpemFkYXMgYW8gaXRlbSA8Yj4ke2l0ZW1UaXRsZX08L2I+P1wiO1xuY29uc3QgdW5zYXZlZFdhcm5pbmdOZXcgPSBcIlByZXRlbmRlIGd1YXJkYXIgYXMgc3VhcyBhbHRlcmHDp8O1ZXM/XCI7XG5jb25zdCBzYXZlQXMgPSBcIkd1YXJkYXIgQ29tb1wiO1xuY29uc3QgZG9udFNhdmUgPSBcIk7Do28gR3VhcmRhclwiO1xuY29uc3QgdW5zYXZlZFRpdGxlID0gXCJBbHRlcmHDp8O1ZXMgTsOjby1HdWFyZGFkYXNcIjtcbmNvbnN0IGludmFsaWRSRlRNZXNzYWdlID0gXCJPIG1vZGVsbyBkZSBmdW7Dp8OjbyByYXN0ZXIgY3JpYWRvIG7Do28gw6kgdsOhbGlkby5cIjtcbmNvbnN0IGVycm9yVGl0bGUgPSBcIkVycm9cIjtcbmNvbnN0IGJyZWFkY3J1bWIgPSBcIkVkaXRvciBkZSBGdW7Dp8O1ZXMgUmFzdGVyXCI7XG5jb25zdCBicmVhZGNydW1iRWRpdG9yID0gXCJDb250ZcO6ZG8gPiBFZGl0b3IgZGUgRnVuw6fDtWVzIFJhc3RlclwiO1xuY29uc3Qgdmlld2VyTW9kZVRpdGxlID0gXCJTw7MgZGUgTGVpdHVyYVwiO1xuY29uc3Qgdmlld2VyTW9kZU1lc3NhZ2UgPSBcIk8gaXRlbSBkbyBtb2RlbG8gZGUgZnVuw6fDo28gcmFzdGVyIMOpIHPDsyBkZSBsZWl0dXJhLiBOw6NvIMOpIHBvc3PDrXZlbCBndWFyZGFyIGFzIGFsdGVyYcOnw7Vlcy5cIjtcbmNvbnN0IHVzZXJTdGFydERpcmVjdGlvbiA9IFwiU2VsZWNpb25lIHVtYSBmdW7Dp8OjbyBwYXJhIGNvbWXDp2FyIGEgY29uc3RydWlyIHVtIG1vZGVsbyBkZSBmdW7Dp8OjbyByYXN0ZXIuXCI7XG5jb25zdCBzZWxlY3RGdW5jdGlvbiA9IFwiQWRpY2lvbmFyIGZ1bsOnw6NvXCI7XG5jb25zdCBkZXNlbGVjdEZ1bmN0aW9uID0gXCJSZW1vdmVyIGZ1bsOnw6NvXCI7XG5jb25zdCBkaWFsb2dUaXRsZSA9IFwiU2lzdGVtYVwiO1xuY29uc3QgY2F0ZWdvcnkgPSBcIkNhdGVnb3JpYXNcIjtcbmNvbnN0IHNlYXJjaCA9IFwiUGVzcXVpc2FyIEZ1bsOnw7VlcyBSYXN0ZXJcIjtcbmNvbnN0IGNhdGVnb3J5TmFtZXMgPSB7XG5cdGFuYWx5c2lzOiBcIkFuw6FsaXNlXCIsXG5cdGFwcGVhcmFuY2U6IFwiQXNwZXRvXCIsXG5cdGNsYXNzaWZpY2F0aW9uOiBcIkNsYXNzaWZpY2HDp8Ojb1wiLFxuXHRjb252ZXJzaW9uOiBcIkNvbnZlcnPDo29cIixcblx0Y29ycmVjdGlvbjogXCJDb3JyZcOnw6NvXCIsXG5cdGRhdGFNYW5hZ2VtZW50OiBcIkdlc3TDo28gZGUgRGFkb3NcIixcblx0ZGlzdGFuY2U6IFwiRGlzdMOibmNpYVwiLFxuXHRkaXN0YW5jZUxlZ2FjeTogXCJEaXN0w6JuY2lhIChMZWdhZG8pXCIsXG5cdGh5ZHJvbG9neTogXCJIaWRyb2xvZ2lhXCIsXG5cdG1hdGg6IFwiTWF0ZW3DoXRpY2FcIixcblx0bWF0aENvbmRpdGlvbmFsOiBcIk1hdDogQ29uZGljaW9uYWxcIixcblx0bWF0aExvZ2ljYWw6IFwiTWF0OiBMw7NnaWNhXCIsXG5cdG1hdGhUcmlnb25vbWV0cmljOiBcIk1hdGVtw6F0aWNhOiBUcmlnb25vbWV0cmlhXCIsXG5cdHJlY2xhc3M6IFwiUmVjbGFzc2lmaWNhclwiLFxuXHRzdGF0aXN0aWNhbDogXCJFc3RhdMOtc3RpY2FcIixcblx0c3VyZmFjZTogXCJTdXBlcmbDrWNpZVwiXG59O1xuY29uc3QgY29tbW9uU3RyaW5nc19wdFBUID0ge1xuXHRvazogb2ssXG5cdGNhbmNlbDogY2FuY2VsLFxuXHRlbnRlclVSTDogZW50ZXJVUkwsXG5cdHNlcnZpY2VVUkw6IHNlcnZpY2VVUkwsXG5cdHNlbGVjdFJhc3Rlcjogc2VsZWN0UmFzdGVyLFxuXHRmYWlsZWRUb0xvYWRMYXllcjogZmFpbGVkVG9Mb2FkTGF5ZXIsXG5cdGxvYWRpbmdMYXllcjogbG9hZGluZ0xheWVyLFxuXHRzZWxlY3RGZWF0dXJlOiBzZWxlY3RGZWF0dXJlLFxuXHRlbnRlckZVUkw6IGVudGVyRlVSTCxcblx0YWRkUmFzdGVyOiBhZGRSYXN0ZXIsXG5cdGFkZFNjYWxhcjogYWRkU2NhbGFyLFxuXHRyYXN0ZXI6IHJhc3Rlcixcblx0c2NhbGFyOiBzY2FsYXIsXG5cdGRlZmF1bHRNb2RlbE5hbWU6IGRlZmF1bHRNb2RlbE5hbWUsXG5cdGdlbmVyYWw6IGdlbmVyYWwsXG5cdHBhcmFtZXRlcnM6IHBhcmFtZXRlcnMsXG5cdHZhcmlhYmxlczogdmFyaWFibGVzLFxuXHRuYW1lOiBuYW1lLFxuXHRkZXNjcmlwdGlvbjogZGVzY3JpcHRpb24sXG5cdHBhcmFtZXRlcjogcGFyYW1ldGVyLFxuXHRpc1B1YmxpYzogaXNQdWJsaWMsXG5cdGlzRGF0YXNldDogaXNEYXRhc2V0LFxuXHR1bmtub3duUGl4ZWxUeXBlOiB1bmtub3duUGl4ZWxUeXBlLFxuXHRvdXRwdXRQaXhlbFR5cGU6IG91dHB1dFBpeGVsVHlwZSxcblx0dThQaXhlbFR5cGU6IHU4UGl4ZWxUeXBlLFxuXHRzOFBpeGVsVHlwZTogczhQaXhlbFR5cGUsXG5cdHUxNlBpeGVsVHlwZTogdTE2UGl4ZWxUeXBlLFxuXHRzMTZQaXhlbFR5cGU6IHMxNlBpeGVsVHlwZSxcblx0dTMyUGl4ZWxUeXBlOiB1MzJQaXhlbFR5cGUsXG5cdHMzMlBpeGVsVHlwZTogczMyUGl4ZWxUeXBlLFxuXHRmMzJQaXhlbFR5cGU6IGYzMlBpeGVsVHlwZSxcblx0ZjY0UGl4ZWxUeXBlOiBmNjRQaXhlbFR5cGUsXG5cdHByb3BlcnRpZXM6IHByb3BlcnRpZXMsXG5cdG11bHRpZGltZW5zaW9uYWxSdWxlczogbXVsdGlkaW1lbnNpb25hbFJ1bGVzLFxuXHRtYXRjaFZhcmlhYmxlczogbWF0Y2hWYXJpYWJsZXMsXG5cdHVuaW9uRGltZW5zaW9uczogdW5pb25EaW1lbnNpb25zLFxuXHRyYXN0ZXJGdW5jdGlvbkVkaXRvcjogcmFzdGVyRnVuY3Rpb25FZGl0b3IsXG5cdHJmeExpY2Vuc2VJbmZvOiByZnhMaWNlbnNlSW5mbyxcblx0cmFzdGVyRnVuY3Rpb25zOiByYXN0ZXJGdW5jdGlvbnMsXG5cdGNvcHk6IGNvcHksXG5cdHNhdmU6IHNhdmUsXG5cdHRpdGxlOiB0aXRsZSxcblx0Zm9sZGVyOiBmb2xkZXIsXG5cdHRhZ3M6IHRhZ3MsXG5cdHNhdmluZ01lc3NhZ2U6IHNhdmluZ01lc3NhZ2UsXG5cdHNoYXJlV2l0aDogc2hhcmVXaXRoLFxuXHRzaGFyZTogc2hhcmUsXG5cdHNldFNoYXJpbmdMZXZlbDogc2V0U2hhcmluZ0xldmVsLFxuXHRzZXRHcm91cFNoYXJpbmc6IHNldEdyb3VwU2hhcmluZyxcblx0b3duZXI6IG93bmVyLFxuXHRvcmdhbml6YXRpb246IG9yZ2FuaXphdGlvbixcblx0ZXZlcnlvbmU6IGV2ZXJ5b25lLFxuXHRncm91cHM6IGdyb3Vwcyxcblx0dHlwZTogdHlwZSxcblx0bW9zYWljOiBtb3NhaWMsXG5cdGl0ZW1Hcm91cDogaXRlbUdyb3VwLFxuXHRpdGVtOiBpdGVtLFxuXHRkZWZpbml0aW9uUXVlcnk6IGRlZmluaXRpb25RdWVyeSxcblx0Z3JvdXBJdGVtc0J5OiBncm91cEl0ZW1zQnksXG5cdGdyb3VwRmllbGROYW1lOiBncm91cEZpZWxkTmFtZSxcblx0dGFnRmllbGROYW1lOiB0YWdGaWVsZE5hbWUsXG5cdG5vVGl0bGVUYWdFcnJvck1zZzogbm9UaXRsZVRhZ0Vycm9yTXNnLFxuXHRub1RpdGxlRXJyb3JNc2c6IG5vVGl0bGVFcnJvck1zZyxcblx0bm9UYWdFcnJvck1zZzogbm9UYWdFcnJvck1zZyxcblx0ZXJyb3I6IGVycm9yLFxuXHR3YXJuaW5nOiB3YXJuaW5nLFxuXHRzdWNjZXNzOiBzdWNjZXNzLFxuXHRkZXRhaWxzOiBkZXRhaWxzLFxuXHR0cnlBZ2FpbjogdHJ5QWdhaW4sXG5cdHRvb2xNb2RlbGVyOiB0b29sTW9kZWxlcixcblx0dG9vbEVkaXRvcjogdG9vbEVkaXRvcixcblx0dG9vbERldGFpbHNFZGl0b3I6IHRvb2xEZXRhaWxzRWRpdG9yLFxuXHRzYXZlVXRpbHM6IHNhdmVVdGlscyxcblx0Y2xvc2U6IGNsb3NlLFxuXHR1bnNhdmVkV2FybmluZ0V4aXN0aW5nOiB1bnNhdmVkV2FybmluZ0V4aXN0aW5nLFxuXHR1bnNhdmVkV2FybmluZ05ldzogdW5zYXZlZFdhcm5pbmdOZXcsXG5cdHNhdmVBczogc2F2ZUFzLFxuXHRkb250U2F2ZTogZG9udFNhdmUsXG5cdHVuc2F2ZWRUaXRsZTogdW5zYXZlZFRpdGxlLFxuXHRpbnZhbGlkUkZUTWVzc2FnZTogaW52YWxpZFJGVE1lc3NhZ2UsXG5cdGVycm9yVGl0bGU6IGVycm9yVGl0bGUsXG5cdGJyZWFkY3J1bWI6IGJyZWFkY3J1bWIsXG5cdGJyZWFkY3J1bWJFZGl0b3I6IGJyZWFkY3J1bWJFZGl0b3IsXG5cdHZpZXdlck1vZGVUaXRsZTogdmlld2VyTW9kZVRpdGxlLFxuXHR2aWV3ZXJNb2RlTWVzc2FnZTogdmlld2VyTW9kZU1lc3NhZ2UsXG5cdHVzZXJTdGFydERpcmVjdGlvbjogdXNlclN0YXJ0RGlyZWN0aW9uLFxuXHRzZWxlY3RGdW5jdGlvbjogc2VsZWN0RnVuY3Rpb24sXG5cdGRlc2VsZWN0RnVuY3Rpb246IGRlc2VsZWN0RnVuY3Rpb24sXG5cdGRpYWxvZ1RpdGxlOiBkaWFsb2dUaXRsZSxcblx0Y2F0ZWdvcnk6IGNhdGVnb3J5LFxuXHRzZWFyY2g6IHNlYXJjaCxcblx0Y2F0ZWdvcnlOYW1lczogY2F0ZWdvcnlOYW1lc1xufTtcblxuZXhwb3J0IGRlZmF1bHQgY29tbW9uU3RyaW5nc19wdFBUO1xuZXhwb3J0IHsgYWRkUmFzdGVyLCBhZGRTY2FsYXIsIGJyZWFkY3J1bWIsIGJyZWFkY3J1bWJFZGl0b3IsIGNhbmNlbCwgY2F0ZWdvcnksIGNhdGVnb3J5TmFtZXMsIGNsb3NlLCBjb3B5LCBkZWZhdWx0TW9kZWxOYW1lLCBkZWZpbml0aW9uUXVlcnksIGRlc2NyaXB0aW9uLCBkZXNlbGVjdEZ1bmN0aW9uLCBkZXRhaWxzLCBkaWFsb2dUaXRsZSwgZG9udFNhdmUsIGVudGVyRlVSTCwgZW50ZXJVUkwsIGVycm9yLCBlcnJvclRpdGxlLCBldmVyeW9uZSwgZjMyUGl4ZWxUeXBlLCBmNjRQaXhlbFR5cGUsIGZhaWxlZFRvTG9hZExheWVyLCBmb2xkZXIsIGdlbmVyYWwsIGdyb3VwRmllbGROYW1lLCBncm91cEl0ZW1zQnksIGdyb3VwcywgaW52YWxpZFJGVE1lc3NhZ2UsIGlzRGF0YXNldCwgaXNQdWJsaWMsIGl0ZW0sIGl0ZW1Hcm91cCwgbG9hZGluZ0xheWVyLCBtYXRjaFZhcmlhYmxlcywgbW9zYWljLCBtdWx0aWRpbWVuc2lvbmFsUnVsZXMsIG5hbWUsIG5vVGFnRXJyb3JNc2csIG5vVGl0bGVFcnJvck1zZywgbm9UaXRsZVRhZ0Vycm9yTXNnLCBvaywgb3JnYW5pemF0aW9uLCBvdXRwdXRQaXhlbFR5cGUsIG93bmVyLCBwYXJhbWV0ZXIsIHBhcmFtZXRlcnMsIHByb3BlcnRpZXMsIHJhc3RlciwgcmFzdGVyRnVuY3Rpb25FZGl0b3IsIHJhc3RlckZ1bmN0aW9ucywgcmZ4TGljZW5zZUluZm8sIHMxNlBpeGVsVHlwZSwgczMyUGl4ZWxUeXBlLCBzOFBpeGVsVHlwZSwgc2F2ZSwgc2F2ZUFzLCBzYXZlVXRpbHMsIHNhdmluZ01lc3NhZ2UsIHNjYWxhciwgc2VhcmNoLCBzZWxlY3RGZWF0dXJlLCBzZWxlY3RGdW5jdGlvbiwgc2VsZWN0UmFzdGVyLCBzZXJ2aWNlVVJMLCBzZXRHcm91cFNoYXJpbmcsIHNldFNoYXJpbmdMZXZlbCwgc2hhcmUsIHNoYXJlV2l0aCwgc3VjY2VzcywgdGFnRmllbGROYW1lLCB0YWdzLCB0aXRsZSwgdG9vbERldGFpbHNFZGl0b3IsIHRvb2xFZGl0b3IsIHRvb2xNb2RlbGVyLCB0cnlBZ2FpbiwgdHlwZSwgdTE2UGl4ZWxUeXBlLCB1MzJQaXhlbFR5cGUsIHU4UGl4ZWxUeXBlLCB1bmlvbkRpbWVuc2lvbnMsIHVua25vd25QaXhlbFR5cGUsIHVuc2F2ZWRUaXRsZSwgdW5zYXZlZFdhcm5pbmdFeGlzdGluZywgdW5zYXZlZFdhcm5pbmdOZXcsIHVzZXJTdGFydERpcmVjdGlvbiwgdmFyaWFibGVzLCB2aWV3ZXJNb2RlTWVzc2FnZSwgdmlld2VyTW9kZVRpdGxlLCB3YXJuaW5nIH07XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbW1vbi1zdHJpbmdzLnB0LVBULThmMWNiYTlhLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==