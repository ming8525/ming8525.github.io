"use strict";
(self["webpackChunkexb_client"] = self["webpackChunkexb_client"] || []).push([["vendors-extensions_widgets_arcgis_analysis_node_modules_arcgis_app-components_dist_esm_layer--210f32"],{

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/functional-44de8fcf.js":
/*!****************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/functional-44de8fcf.js ***!
  \****************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   a: () => (/* binding */ arrayToLookupMap),
/* harmony export */   b: () => (/* binding */ unique),
/* harmony export */   c: () => (/* binding */ throttle),
/* harmony export */   d: () => (/* binding */ debounce),
/* harmony export */   e: () => (/* binding */ escapeRegExp),
/* harmony export */   f: () => (/* binding */ arraysAreEquivalent),
/* harmony export */   g: () => (/* binding */ chunk),
/* harmony export */   i: () => (/* binding */ isDefined),
/* harmony export */   m: () => (/* binding */ minDelay),
/* harmony export */   t: () => (/* binding */ timeout),
/* harmony export */   u: () => (/* binding */ uniqueBy)
/* harmony export */ });
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v4.0.58
 */
/**
 * Call a function only after it has not been called for n milliseconds
 * @param fn    - function to call
 * @param delay - delay in milliseconds
 */
const debounce = (fn, delay) => {
    let timeout;
    let status = "idle";
    function flush(...args) {
        status = "flushed";
        return debounced(...args);
    }
    function invoke(...args) {
        status = "invoked";
        return debounced(...args);
    }
    function cancel(...args) {
        status = "cancelled";
        return debounced(...args);
    }
    function getStatus() {
        return status;
    }
    const debounced = (...args) => new Promise((resolve) => {
        switch (status) {
            case "flushed":
                status = "idle";
                if (timeout) {
                    clearTimeout(timeout);
                    resolve(fn(...args));
                }
                else {
                    resolve(null);
                }
                break;
            case "invoked":
                clearTimeout(timeout);
                status = "idle";
                resolve(fn(...args));
                break;
            case "cancelled":
                clearTimeout(timeout);
                status = "idle";
                resolve(null);
                break;
            default:
                if (timeout) {
                    clearTimeout(timeout);
                }
                status = "pending";
                timeout = setTimeout(() => {
                    status = "idle";
                    return resolve(fn(...args));
                }, delay);
                break;
        }
    });
    debounced.flush = flush;
    debounced.invoke = invoke;
    debounced.cancel = cancel;
    debounced.getStatus = getStatus;
    return debounced;
};
/**
 * Call a function only after n milliseconds have elapsed
 * @param fn    - function to call
 * @param delay - delay in milliseconds
 */
const throttle = (fn, delay) => {
    let timeout;
    return (...args) => new Promise((resolve) => {
        if (timeout) {
            return;
        }
        timeout = setTimeout(() => {
            clearTimeout(timeout);
            timeout = undefined;
            resolve(fn(...args));
        }, delay);
    });
};
function escapeRegExp(str) {
    return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"); // $& means the whole matched string
}
function isDefined(value) {
    return value !== undefined && value !== null;
}
/**
 * Set a minimum time for a promise to resolve (useful for preventing flash of loaders)
 */
async function minDelay(promise, minDelay) {
    await Promise.all([promise, timeout(minDelay)]);
    return promise;
}
/**
 * Helper method to inline setTimeout as an await in async functions
 */
function timeout(ms) {
    return new Promise((resolve) => setTimeout(resolve, ms));
}
const arrayToLookupMap = (dataArr, getKeyAndItem) => Object.fromEntries((dataArr || []).map((item) => {
    const { key, data } = getKeyAndItem(item);
    return [key, data];
}));
/**
 * Check whether two arrays have the same number of elements
 * and whether they contain the same elements
 * regardless of order
 */
const arraysAreEquivalent = (arr1, arr2) => arr1.length === arr2.length && arr1.reduce((memo, str) => memo && arr2.indexOf(str) > -1, true);
function uniqueBy(myArr, getItemId) {
    const resultArr = [];
    const lookupMap = {};
    myArr.forEach((item) => {
        const id = getItemId(item);
        if (lookupMap[id] == null) {
            lookupMap[id] = item;
            resultArr.push(item);
        }
    });
    return resultArr;
}
function unique(myArr) {
    const primitives = { boolean: {}, number: {}, string: {} };
    const objs = [];
    return myArr.filter((item) => {
        let type = typeof item;
        if (type in primitives) {
            return primitives[type].hasOwnProperty(item) ? false : (primitives[type][item] = true);
        }
        else {
            return objs.indexOf(item) >= 0 ? false : objs.push(item);
        }
    });
}
const chunk = (arr, size) => [...Array(Math.ceil(arr.length / size))].map((_, i) => arr.slice(size * i, size + size * i));



//# sourceMappingURL=functional-44de8fcf.js.map

/***/ }),

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/layer-9a7593aa.js":
/*!***********************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/layer-9a7593aa.js ***!
  \***********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ AOI),
/* harmony export */   N: () => (/* binding */ NavigationTab),
/* harmony export */   a: () => (/* binding */ getImageItemCount),
/* harmony export */   b: () => (/* binding */ buildLayerQuery),
/* harmony export */   c: () => (/* binding */ getFilteredImageItems),
/* harmony export */   d: () => (/* binding */ getDefaultImageItemCardDisplayedFields),
/* harmony export */   e: () => (/* binding */ getMinAndMaxValuesForLayerField),
/* harmony export */   f: () => (/* binding */ getUniqueValuesForLayerField),
/* harmony export */   g: () => (/* binding */ getFilteredVisibleImageItems),
/* harmony export */   h: () => (/* binding */ getSupportedLayerFields),
/* harmony export */   i: () => (/* binding */ isAbortedError),
/* harmony export */   j: () => (/* binding */ getDefaultSelectedLayerField),
/* harmony export */   k: () => (/* binding */ isNumericFieldType),
/* harmony export */   l: () => (/* binding */ getFormattedDateString),
/* harmony export */   m: () => (/* binding */ getImageItemGeometry)
/* harmony export */ });
/* harmony import */ var _loadModules_b4ac1247_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./loadModules-b4ac1247.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/loadModules-b4ac1247.js");
/* harmony import */ var _functional_44de8fcf_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./functional-44de8fcf.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/functional-44de8fcf.js");
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v4.0.58
 */



var NavigationTab;
(function (NavigationTab) {
    NavigationTab["Inspect"] = "inspect";
    NavigationTab["Select"] = "select";
})(NavigationTab || (NavigationTab = {}));
var AOI;
(function (AOI) {
    AOI["Visible"] = "visible";
    AOI["DisplayExtent"] = "displayExtent";
    AOI["All"] = "all";
})(AOI || (AOI = {}));
/**
 * check if the error is abort error.
 *
 * @param error
 */
function isAbortedError(error) {
    return (error === null || error === void 0 ? void 0 : error.name) === "AbortError";
}
/**
 * check if field type is numeric type.
 *
 * @param fieldType
 */
function isNumericFieldType(fieldType) {
    const numericFieldTypes = ["small-integer", "big-integer", "integer", "single", "double", "oid"];
    return numericFieldTypes.includes(fieldType);
}
/**
 * get formatted date string from a timestamp.
 *
 * @param unixTimestamp timestamp
 * @returns date string in the format of "yyyy-mm-dd hh:mm:ss"
 */
function getFormattedDateString(unixTimestamp) {
    const dateObj = new Date(unixTimestamp);
    return `${dateObj.getFullYear()}-${padString((dateObj.getMonth() + 1).toString(), 2, "0")}-${padString(dateObj.getDate().toString(), 2, "0")} ${padString(dateObj.getHours().toString(), 2, "0")}:${padString(dateObj.getMinutes().toString(), 2, "0")}:${padString(dateObj.getSeconds().toString(), 2, "0")}`;
}
function padString(str, targetLength, padString) {
    padString = padString || " ";
    while (str.length < targetLength) {
        str = padString + str;
    }
    return str;
}

/**
 * get the default selected layer field for a given layer
 *
 * @param layerFields - layer's fields
 * @returns __esri.Field - default selected layer field
 *
 */
function getDefaultSelectedLayerField(layerFields) {
    const bestField = layerFields.find((field) => field.name.toLowerCase() === "best");
    if (bestField) {
        return bestField;
    }
    const acquisitionDateField = layerFields.find((field) => field.name.toLowerCase() === "acquisitiondate");
    if (acquisitionDateField) {
        return acquisitionDateField;
    }
    const dateTypeField = layerFields.find((field) => field.name.toLowerCase() === "date");
    if (dateTypeField) {
        return dateTypeField;
    }
    const intOrDoubleTypeField = layerFields.find((field) => field.type === "double" || field.type === "integer");
    return intOrDoubleTypeField;
}
/**
 * get the image item count that match the query condition
 *
 * @param layer - imagery layer
 * @param query - layer query
 * @returns number - raster item count
 *
 */
async function getImageItemCount(layer, query) {
    let count;
    try {
        count = await layer.queryRasterCount(query);
    }
    catch (err) {
        console.log(err);
        //
    }
    return Number.isInteger(count) ? count : null;
}
/**
 * get image items that match the query condition
 *
 * @param layer - imagery layer
 * @param query - query
 * @returns __esri.FeatureSet - raster items
 *
 */
async function getFilteredImageItems(layer, query) {
    query.outFields = ["*"];
    query.returnGeometry = true;
    const res = await layer.queryRasters(query);
    return Array.isArray(res === null || res === void 0 ? void 0 : res.features) ? res : null;
}
/**
 * get the geometry of image item
 *
 * @param layer - imagery layer
 * @param imageItemObjectID - image item object id
 * @returns __esri.Geometry - image item geometry
 *
 */
async function getImageItemGeometry(layer, imageItemObjectID) {
    var _a;
    const query = layer.createQuery();
    query.where = `${layer.objectIdField} = ${imageItemObjectID}`;
    query.returnGeometry = true;
    let res;
    try {
        res = await layer.queryRasters(query);
    }
    catch (err) {
        console.log(err);
        //
    }
    return ((_a = res === null || res === void 0 ? void 0 : res.features) === null || _a === void 0 ? void 0 : _a[0].geometry) || null;
}
/**
 * get default displayed fields for image item cards
 *
 * @param layer - imagery layer
 * @param selectedQueryField - current selected query field
 * @returns __esri.Field[] - default displayed fields
 *
 */
function getDefaultImageItemCardDisplayedFields(layer, selectedQueryField) {
    const layerFields = layer.fields;
    const layerObjectIdFieldName = layer.objectIdField;
    let defaultField = layerFields.find((field) => field.name.toLowerCase() === "name");
    if (!defaultField) {
        defaultField = layerFields.find((field) => field.name === layerObjectIdFieldName);
    }
    if (defaultField && defaultField.name !== selectedQueryField.name) {
        return [defaultField, selectedQueryField];
    }
    return [selectedQueryField];
}
/**
 * get supported layer fields based on field type for display and selection
 *
 * @param layerFields - imagery layer
 * @returns __esri.Field[] - supported fields
 *
 */
function getSupportedLayerFields(layerFields) {
    const supportedFieldTypes = ["small-integer", "big-integer", "integer", "single", "double", "date", "oid", "string"];
    return Array.isArray(layerFields) ? layerFields.filter((field) => supportedFieldTypes.includes(field.type)) : [];
}
/**
 * build layer query
 *
 * @param layerFields - imagery layer
 * @param queryField  - query field
 * @param queryValue - query value
 * @param selectedAOI - selected area of interest
 * @param isOverviewsIncluded - is Overviews included
 * @param mapExtent - map extent
 * @returns __esri.Query - layer query
 *
 */
function buildLayerQuery(layer, queryField, queryValues, selectedAOI, isOverviewsIncluded, mapExtent) {
    const query = layer.createQuery();
    if ((queryValues === null || queryValues === void 0 ? void 0 : queryValues.length) > 0) {
        let queryValueWhereClause = "";
        if (queryField.type === "date") {
            if (queryValues.length === 1) {
                const startDate = new Date(queryValues[0]);
                const endDateTimestamp = startDate.setSeconds(startDate.getSeconds() + 1);
                queryValueWhereClause = queryValueWhereClause = `${queryField.name} BETWEEN timestamp '${getFormattedDateString(queryValues[0])}' AND timestamp '${getFormattedDateString(endDateTimestamp)}'`;
            }
            if (queryValues.length === 2) {
                queryValueWhereClause = `${queryField.name} BETWEEN timestamp '${getFormattedDateString(queryValues[0])}' AND timestamp '${getFormattedDateString(queryValues[1])}'`;
            }
        }
        else {
            if (queryValues.length === 1) {
                queryValueWhereClause =
                    typeof queryValues[0] === "string"
                        ? `${queryField.name}='${queryValues[0]}'`
                        : `${queryField.name}=${queryValues[0]}`;
            }
            if (queryValues.length === 2) {
                queryValueWhereClause =
                    typeof queryValues[0] === "string"
                        ? `${queryField.name} BETWEEN '${queryValues[0]}' AND '${queryValues[1]}'`
                        : `${queryField.name} BETWEEN ${queryValues[0]} AND ${queryValues[1]}`;
            }
        }
        query.where = queryValueWhereClause;
    }
    const queryOverviewWhereClause = "(Category <> 2)";
    if (!isOverviewsIncluded) {
        const newWhereClause = queryOverviewWhereClause + (query.where ? " AND " + query.where : "");
        query.where = newWhereClause;
    }
    else {
        query.where = query.where.replace(queryOverviewWhereClause, "");
    }
    query.geometry = selectedAOI === AOI.DisplayExtent ? mapExtent : null;
    query.spatialRelationship = selectedAOI === AOI.DisplayExtent ? "intersects" : null;
    return query;
}
/**
 * get unique value for an attribute field in the imagery layer
 *
 * @param layer - imagery layer
 * @param queryFieldName - query field name
 * @param selectedAOI - selected AOI
 * @param mapExtent - map extent
 * @param abortSignal - abort signal
 * @param isFetchingAll - whether is fetching all results
 * @returns Array<string | number> - unique value array
 */
async function getUniqueValuesForLayerField(layer, queryField, selectedAOI, mapExtent, abortSignal, isFetchingAll = false) {
    var _a, _b;
    if (!queryField)
        return [];
    const query = layer.createQuery();
    query.where = "1=1";
    const isConstrainedByMapExtent = selectedAOI === AOI.DisplayExtent || selectedAOI === AOI.Visible;
    query.geometry = isConstrainedByMapExtent ? mapExtent : null;
    query.spatialRelationship = isConstrainedByMapExtent ? "intersects" : null;
    query.outFields = [queryField];
    query.orderByFields = [`${queryField} ASC`];
    query.returnExceededLimitFeatures = true;
    query.returnGeometry = false;
    const resultValues = [];
    if (isFetchingAll) {
        let hasMore = true;
        while (hasMore) {
            const res = await layer.queryRasters(query, { signal: abortSignal });
            hasMore = res === null || res === void 0 ? void 0 : res.exceededTransferLimit;
            if (((_a = res.features) === null || _a === void 0 ? void 0 : _a.length) > 0) {
                const valuesToAdd = (0,_functional_44de8fcf_js__WEBPACK_IMPORTED_MODULE_1__.b)(res.features.map((feature) => feature.attributes[queryField]));
                resultValues.push(...valuesToAdd);
            }
        }
        return resultValues;
    }
    const res = await layer.queryRasters(query, { signal: abortSignal });
    if (((_b = res === null || res === void 0 ? void 0 : res.features) === null || _b === void 0 ? void 0 : _b.length) > 0) {
        const valuesToAdd = (0,_functional_44de8fcf_js__WEBPACK_IMPORTED_MODULE_1__.b)(res.features.map((feature) => feature.attributes[queryField]));
        return valuesToAdd;
    }
    return [];
}
/**
 * get min/max value for an attribute field in the imagery layer
 *
 * @param layer - imagery layer
 * @param queryFieldName - query field name
 * @param selectedAOI - selected AOI
 * @param mapExtent - map extent
 * @param abortSignal - abort signal
 * @returns Array<string | number> - min/max value array [min, max]
 */
async function getMinAndMaxValuesForLayerField(layer, queryFieldName, selectedAOI, mapExtent, abortSignal) {
    var _a;
    if (!queryFieldName)
        return [];
    const query = layer.createQuery();
    query.where = "1=1";
    const isConstrainedByMapExtent = selectedAOI === AOI.DisplayExtent || selectedAOI === AOI.Visible;
    query.geometry = isConstrainedByMapExtent ? mapExtent : null;
    query.spatialRelationship = isConstrainedByMapExtent ? "intersects" : null;
    query.returnGeometry = false;
    query.outStatistics = [
        {
            statisticType: "min",
            onStatisticField: queryFieldName,
            outStatisticFieldName: "MIN_FIELD_VALUE"
        },
        {
            statisticType: "max",
            onStatisticField: queryFieldName,
            outStatisticFieldName: "MAX_FIELD_VALUE"
        }
    ];
    const res = await layer.queryRasters(query, { signal: abortSignal });
    if (((_a = res === null || res === void 0 ? void 0 : res.features) === null || _a === void 0 ? void 0 : _a.length) > 0) {
        const [feature] = res.features;
        return [feature.attributes["MIN_FIELD_VALUE"], feature.attributes["MAX_FIELD_VALUE"]];
    }
    return [];
}
/**
 * generate the parameters for imagery layer identify function
 *
 * @param layer - imagery layer
 * @param mapView - current map view
 * @returns __esri.ImageIdentifyParameters
 */
async function generateIdentifyParams(layer, mapView) {
    const [Polygon, Point, ImageIdentifyParameters] = await (0,_loadModules_b4ac1247_js__WEBPACK_IMPORTED_MODULE_0__.l)([
        "esri/geometry/Polygon",
        "esri/geometry/Point",
        "esri/rest/support/ImageIdentifyParameters"
    ]);
    const { extent, width, height } = mapView;
    const polygon = new Polygon(extent.spatialReference);
    polygon.addRing([
        [extent.xmin, extent.ymin],
        [extent.xmin, extent.ymax],
        [extent.xmax, extent.ymax],
        [extent.xmax, extent.ymin],
        [extent.xmin, extent.ymin]
    ]);
    const psX = (extent.xmax - extent.xmin) / width;
    const psY = (extent.ymax - extent.ymin) / height;
    const pixelSize = new Point(psX, psY, extent.spatialReference);
    const identifyParams = new ImageIdentifyParameters();
    identifyParams.geometry = polygon;
    identifyParams.returnGeometry = false;
    identifyParams.pixelSize = pixelSize;
    const mosaicRule = layer.mosaicRule.clone();
    if (layer.definitionExpression) {
        mosaicRule.where = layer.definitionExpression;
    }
    identifyParams.mosaicRule = mosaicRule;
    return identifyParams;
}
/**
 * get visible image items that match the query condition
 *
 * @param layer - imagery layer
 * @param mapView - current map view
 * @param layerQuery - current map view
 * @returns __esri.FeatureSet - raster items
 */
async function getFilteredVisibleImageItems(layer, mapView, layerQuery) {
    var _a;
    let visibleImageItemObjectIds = [];
    const identifyParams = await generateIdentifyParams(layer, mapView);
    if (layer.visible) {
        const identifyResult = await layer.identify(identifyParams);
        if (!((_a = identifyResult === null || identifyResult === void 0 ? void 0 : identifyResult.catalogItems) === null || _a === void 0 ? void 0 : _a.features) || !(identifyResult === null || identifyResult === void 0 ? void 0 : identifyResult.catalogItemVisibilities))
            return null;
        const objectIdFieldName = layer.objectIdField;
        for (let i = 0; i < identifyResult.catalogItems.features.length; i++) {
            if (identifyResult.catalogItemVisibilities[i] > 0) {
                visibleImageItemObjectIds.push(identifyResult.catalogItems.features[i].attributes[objectIdFieldName]);
            }
        }
        if (visibleImageItemObjectIds.length === 0)
            return null;
        const objectIdQueryString = `${layer.objectIdField} in (${visibleImageItemObjectIds
            .map((oid) => `${oid}`)
            .join(",")})`;
        layerQuery.where = `${layerQuery.where} AND ${objectIdQueryString}`;
        layerQuery.outFields = ["*"];
        layerQuery.returnGeometry = true;
        const res = await layer.queryRasters(layerQuery);
        return Array.isArray(res === null || res === void 0 ? void 0 : res.features) ? res : null;
    }
}



//# sourceMappingURL=layer-9a7593aa.js.map

/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid2lkZ2V0cy9jaHVua3MvYXJjZ2lzX2FuYWx5c2lzX25vZGVfbW9kdWxlc19hcmNnaXNfYXBwLWNvbXBvbmVudHNfZGlzdF9lc21fbGF5ZXItLTIxMGYzMi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBLGlDQUFpQyxzQkFBc0I7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxZQUFZO0FBQ3hCO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsV0FBVyxZQUFZO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVpTTs7QUFFak07Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQy9JQTtBQUNBO0FBQ0E7QUFDQTtBQUM2RDtBQUNOOztBQUV2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsc0NBQXNDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGtCQUFrQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsc0JBQXNCLEdBQUcsdURBQXVELEdBQUcsaURBQWlELEVBQUUsaURBQWlELEdBQUcsbURBQW1ELEdBQUcsbURBQW1EO0FBQ2pUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIscUJBQXFCLElBQUksa0JBQWtCO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUUsaUJBQWlCLHFCQUFxQix1Q0FBdUMsbUJBQW1CLHlDQUF5QztBQUM1TTtBQUNBO0FBQ0EsMkNBQTJDLGlCQUFpQixxQkFBcUIsdUNBQXVDLG1CQUFtQix1Q0FBdUM7QUFDbEw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGdCQUFnQixJQUFJLGVBQWU7QUFDaEUsNkJBQTZCLGdCQUFnQixHQUFHLGVBQWU7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsaUJBQWlCLFdBQVcsZUFBZSxTQUFTLGVBQWU7QUFDaEcsNkJBQTZCLGlCQUFpQixVQUFVLGdCQUFnQixNQUFNLGVBQWU7QUFDN0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsWUFBWTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQscUJBQXFCO0FBQy9FO0FBQ0E7QUFDQSxvQ0FBb0MsMERBQU07QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxxQkFBcUI7QUFDdkU7QUFDQSw0QkFBNEIsMERBQU07QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QscUJBQXFCO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsMkRBQVc7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHdCQUF3QjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsaURBQWlEO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxxQkFBcUIsTUFBTTtBQUNsRSw2QkFBNkIsSUFBSTtBQUNqQyx1QkFBdUI7QUFDdkIsOEJBQThCLGtCQUFrQixNQUFNLG9CQUFvQjtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWtiOztBQUVsYiIsInNvdXJjZXMiOlsid2VicGFjazovL2V4Yi1jbGllbnQvLi9leHRlbnNpb25zL3dpZGdldHMvYXJjZ2lzL2FuYWx5c2lzL25vZGVfbW9kdWxlcy9AYXJjZ2lzL2FwcC1jb21wb25lbnRzL2Rpc3QvZXNtL2Z1bmN0aW9uYWwtNDRkZThmY2YuanMiLCJ3ZWJwYWNrOi8vZXhiLWNsaWVudC8uL2V4dGVuc2lvbnMvd2lkZ2V0cy9hcmNnaXMvYW5hbHlzaXMvbm9kZV9tb2R1bGVzL0BhcmNnaXMvYXBwLWNvbXBvbmVudHMvZGlzdC9lc20vbGF5ZXItOWE3NTkzYWEuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBBbGwgbWF0ZXJpYWwgY29weXJpZ2h0IEVTUkksIEFsbCBSaWdodHMgUmVzZXJ2ZWQsIHVubGVzcyBvdGhlcndpc2Ugc3BlY2lmaWVkLlxuICogdjQuMC41OFxuICovXG4vKipcbiAqIENhbGwgYSBmdW5jdGlvbiBvbmx5IGFmdGVyIGl0IGhhcyBub3QgYmVlbiBjYWxsZWQgZm9yIG4gbWlsbGlzZWNvbmRzXG4gKiBAcGFyYW0gZm4gICAgLSBmdW5jdGlvbiB0byBjYWxsXG4gKiBAcGFyYW0gZGVsYXkgLSBkZWxheSBpbiBtaWxsaXNlY29uZHNcbiAqL1xuY29uc3QgZGVib3VuY2UgPSAoZm4sIGRlbGF5KSA9PiB7XG4gICAgbGV0IHRpbWVvdXQ7XG4gICAgbGV0IHN0YXR1cyA9IFwiaWRsZVwiO1xuICAgIGZ1bmN0aW9uIGZsdXNoKC4uLmFyZ3MpIHtcbiAgICAgICAgc3RhdHVzID0gXCJmbHVzaGVkXCI7XG4gICAgICAgIHJldHVybiBkZWJvdW5jZWQoLi4uYXJncyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGludm9rZSguLi5hcmdzKSB7XG4gICAgICAgIHN0YXR1cyA9IFwiaW52b2tlZFwiO1xuICAgICAgICByZXR1cm4gZGVib3VuY2VkKC4uLmFyZ3MpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjYW5jZWwoLi4uYXJncykge1xuICAgICAgICBzdGF0dXMgPSBcImNhbmNlbGxlZFwiO1xuICAgICAgICByZXR1cm4gZGVib3VuY2VkKC4uLmFyZ3MpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRTdGF0dXMoKSB7XG4gICAgICAgIHJldHVybiBzdGF0dXM7XG4gICAgfVxuICAgIGNvbnN0IGRlYm91bmNlZCA9ICguLi5hcmdzKSA9PiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICBzd2l0Y2ggKHN0YXR1cykge1xuICAgICAgICAgICAgY2FzZSBcImZsdXNoZWRcIjpcbiAgICAgICAgICAgICAgICBzdGF0dXMgPSBcImlkbGVcIjtcbiAgICAgICAgICAgICAgICBpZiAodGltZW91dCkge1xuICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoZm4oLi4uYXJncykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShudWxsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiaW52b2tlZFwiOlxuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgICAgICAgICBzdGF0dXMgPSBcImlkbGVcIjtcbiAgICAgICAgICAgICAgICByZXNvbHZlKGZuKC4uLmFyZ3MpKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJjYW5jZWxsZWRcIjpcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgICAgICAgICAgc3RhdHVzID0gXCJpZGxlXCI7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShudWxsKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgaWYgKHRpbWVvdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzdGF0dXMgPSBcInBlbmRpbmdcIjtcbiAgICAgICAgICAgICAgICB0aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cyA9IFwiaWRsZVwiO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZShmbiguLi5hcmdzKSk7XG4gICAgICAgICAgICAgICAgfSwgZGVsYXkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgZGVib3VuY2VkLmZsdXNoID0gZmx1c2g7XG4gICAgZGVib3VuY2VkLmludm9rZSA9IGludm9rZTtcbiAgICBkZWJvdW5jZWQuY2FuY2VsID0gY2FuY2VsO1xuICAgIGRlYm91bmNlZC5nZXRTdGF0dXMgPSBnZXRTdGF0dXM7XG4gICAgcmV0dXJuIGRlYm91bmNlZDtcbn07XG4vKipcbiAqIENhbGwgYSBmdW5jdGlvbiBvbmx5IGFmdGVyIG4gbWlsbGlzZWNvbmRzIGhhdmUgZWxhcHNlZFxuICogQHBhcmFtIGZuICAgIC0gZnVuY3Rpb24gdG8gY2FsbFxuICogQHBhcmFtIGRlbGF5IC0gZGVsYXkgaW4gbWlsbGlzZWNvbmRzXG4gKi9cbmNvbnN0IHRocm90dGxlID0gKGZuLCBkZWxheSkgPT4ge1xuICAgIGxldCB0aW1lb3V0O1xuICAgIHJldHVybiAoLi4uYXJncykgPT4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgaWYgKHRpbWVvdXQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgICAgICB0aW1lb3V0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgcmVzb2x2ZShmbiguLi5hcmdzKSk7XG4gICAgICAgIH0sIGRlbGF5KTtcbiAgICB9KTtcbn07XG5mdW5jdGlvbiBlc2NhcGVSZWdFeHAoc3RyKSB7XG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKC9bLiorP14ke30oKXxbXFxdXFxcXF0vZywgXCJcXFxcJCZcIik7IC8vICQmIG1lYW5zIHRoZSB3aG9sZSBtYXRjaGVkIHN0cmluZ1xufVxuZnVuY3Rpb24gaXNEZWZpbmVkKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGw7XG59XG4vKipcbiAqIFNldCBhIG1pbmltdW0gdGltZSBmb3IgYSBwcm9taXNlIHRvIHJlc29sdmUgKHVzZWZ1bCBmb3IgcHJldmVudGluZyBmbGFzaCBvZiBsb2FkZXJzKVxuICovXG5hc3luYyBmdW5jdGlvbiBtaW5EZWxheShwcm9taXNlLCBtaW5EZWxheSkge1xuICAgIGF3YWl0IFByb21pc2UuYWxsKFtwcm9taXNlLCB0aW1lb3V0KG1pbkRlbGF5KV0pO1xuICAgIHJldHVybiBwcm9taXNlO1xufVxuLyoqXG4gKiBIZWxwZXIgbWV0aG9kIHRvIGlubGluZSBzZXRUaW1lb3V0IGFzIGFuIGF3YWl0IGluIGFzeW5jIGZ1bmN0aW9uc1xuICovXG5mdW5jdGlvbiB0aW1lb3V0KG1zKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIG1zKSk7XG59XG5jb25zdCBhcnJheVRvTG9va3VwTWFwID0gKGRhdGFBcnIsIGdldEtleUFuZEl0ZW0pID0+IE9iamVjdC5mcm9tRW50cmllcygoZGF0YUFyciB8fCBbXSkubWFwKChpdGVtKSA9PiB7XG4gICAgY29uc3QgeyBrZXksIGRhdGEgfSA9IGdldEtleUFuZEl0ZW0oaXRlbSk7XG4gICAgcmV0dXJuIFtrZXksIGRhdGFdO1xufSkpO1xuLyoqXG4gKiBDaGVjayB3aGV0aGVyIHR3byBhcnJheXMgaGF2ZSB0aGUgc2FtZSBudW1iZXIgb2YgZWxlbWVudHNcbiAqIGFuZCB3aGV0aGVyIHRoZXkgY29udGFpbiB0aGUgc2FtZSBlbGVtZW50c1xuICogcmVnYXJkbGVzcyBvZiBvcmRlclxuICovXG5jb25zdCBhcnJheXNBcmVFcXVpdmFsZW50ID0gKGFycjEsIGFycjIpID0+IGFycjEubGVuZ3RoID09PSBhcnIyLmxlbmd0aCAmJiBhcnIxLnJlZHVjZSgobWVtbywgc3RyKSA9PiBtZW1vICYmIGFycjIuaW5kZXhPZihzdHIpID4gLTEsIHRydWUpO1xuZnVuY3Rpb24gdW5pcXVlQnkobXlBcnIsIGdldEl0ZW1JZCkge1xuICAgIGNvbnN0IHJlc3VsdEFyciA9IFtdO1xuICAgIGNvbnN0IGxvb2t1cE1hcCA9IHt9O1xuICAgIG15QXJyLmZvckVhY2goKGl0ZW0pID0+IHtcbiAgICAgICAgY29uc3QgaWQgPSBnZXRJdGVtSWQoaXRlbSk7XG4gICAgICAgIGlmIChsb29rdXBNYXBbaWRdID09IG51bGwpIHtcbiAgICAgICAgICAgIGxvb2t1cE1hcFtpZF0gPSBpdGVtO1xuICAgICAgICAgICAgcmVzdWx0QXJyLnB1c2goaXRlbSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0QXJyO1xufVxuZnVuY3Rpb24gdW5pcXVlKG15QXJyKSB7XG4gICAgY29uc3QgcHJpbWl0aXZlcyA9IHsgYm9vbGVhbjoge30sIG51bWJlcjoge30sIHN0cmluZzoge30gfTtcbiAgICBjb25zdCBvYmpzID0gW107XG4gICAgcmV0dXJuIG15QXJyLmZpbHRlcigoaXRlbSkgPT4ge1xuICAgICAgICBsZXQgdHlwZSA9IHR5cGVvZiBpdGVtO1xuICAgICAgICBpZiAodHlwZSBpbiBwcmltaXRpdmVzKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJpbWl0aXZlc1t0eXBlXS5oYXNPd25Qcm9wZXJ0eShpdGVtKSA/IGZhbHNlIDogKHByaW1pdGl2ZXNbdHlwZV1baXRlbV0gPSB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBvYmpzLmluZGV4T2YoaXRlbSkgPj0gMCA/IGZhbHNlIDogb2Jqcy5wdXNoKGl0ZW0pO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5jb25zdCBjaHVuayA9IChhcnIsIHNpemUpID0+IFsuLi5BcnJheShNYXRoLmNlaWwoYXJyLmxlbmd0aCAvIHNpemUpKV0ubWFwKChfLCBpKSA9PiBhcnIuc2xpY2Uoc2l6ZSAqIGksIHNpemUgKyBzaXplICogaSkpO1xuXG5leHBvcnQgeyBhcnJheVRvTG9va3VwTWFwIGFzIGEsIHVuaXF1ZSBhcyBiLCB0aHJvdHRsZSBhcyBjLCBkZWJvdW5jZSBhcyBkLCBlc2NhcGVSZWdFeHAgYXMgZSwgYXJyYXlzQXJlRXF1aXZhbGVudCBhcyBmLCBjaHVuayBhcyBnLCBpc0RlZmluZWQgYXMgaSwgbWluRGVsYXkgYXMgbSwgdGltZW91dCBhcyB0LCB1bmlxdWVCeSBhcyB1IH07XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZ1bmN0aW9uYWwtNDRkZThmY2YuanMubWFwIiwiLyohXG4gKiBBbGwgbWF0ZXJpYWwgY29weXJpZ2h0IEVTUkksIEFsbCBSaWdodHMgUmVzZXJ2ZWQsIHVubGVzcyBvdGhlcndpc2Ugc3BlY2lmaWVkLlxuICogdjQuMC41OFxuICovXG5pbXBvcnQgeyBsIGFzIGxvYWRNb2R1bGVzIH0gZnJvbSAnLi9sb2FkTW9kdWxlcy1iNGFjMTI0Ny5qcyc7XG5pbXBvcnQgeyBiIGFzIHVuaXF1ZSB9IGZyb20gJy4vZnVuY3Rpb25hbC00NGRlOGZjZi5qcyc7XG5cbnZhciBOYXZpZ2F0aW9uVGFiO1xuKGZ1bmN0aW9uIChOYXZpZ2F0aW9uVGFiKSB7XG4gICAgTmF2aWdhdGlvblRhYltcIkluc3BlY3RcIl0gPSBcImluc3BlY3RcIjtcbiAgICBOYXZpZ2F0aW9uVGFiW1wiU2VsZWN0XCJdID0gXCJzZWxlY3RcIjtcbn0pKE5hdmlnYXRpb25UYWIgfHwgKE5hdmlnYXRpb25UYWIgPSB7fSkpO1xudmFyIEFPSTtcbihmdW5jdGlvbiAoQU9JKSB7XG4gICAgQU9JW1wiVmlzaWJsZVwiXSA9IFwidmlzaWJsZVwiO1xuICAgIEFPSVtcIkRpc3BsYXlFeHRlbnRcIl0gPSBcImRpc3BsYXlFeHRlbnRcIjtcbiAgICBBT0lbXCJBbGxcIl0gPSBcImFsbFwiO1xufSkoQU9JIHx8IChBT0kgPSB7fSkpO1xuLyoqXG4gKiBjaGVjayBpZiB0aGUgZXJyb3IgaXMgYWJvcnQgZXJyb3IuXG4gKlxuICogQHBhcmFtIGVycm9yXG4gKi9cbmZ1bmN0aW9uIGlzQWJvcnRlZEVycm9yKGVycm9yKSB7XG4gICAgcmV0dXJuIChlcnJvciA9PT0gbnVsbCB8fCBlcnJvciA9PT0gdm9pZCAwID8gdm9pZCAwIDogZXJyb3IubmFtZSkgPT09IFwiQWJvcnRFcnJvclwiO1xufVxuLyoqXG4gKiBjaGVjayBpZiBmaWVsZCB0eXBlIGlzIG51bWVyaWMgdHlwZS5cbiAqXG4gKiBAcGFyYW0gZmllbGRUeXBlXG4gKi9cbmZ1bmN0aW9uIGlzTnVtZXJpY0ZpZWxkVHlwZShmaWVsZFR5cGUpIHtcbiAgICBjb25zdCBudW1lcmljRmllbGRUeXBlcyA9IFtcInNtYWxsLWludGVnZXJcIiwgXCJiaWctaW50ZWdlclwiLCBcImludGVnZXJcIiwgXCJzaW5nbGVcIiwgXCJkb3VibGVcIiwgXCJvaWRcIl07XG4gICAgcmV0dXJuIG51bWVyaWNGaWVsZFR5cGVzLmluY2x1ZGVzKGZpZWxkVHlwZSk7XG59XG4vKipcbiAqIGdldCBmb3JtYXR0ZWQgZGF0ZSBzdHJpbmcgZnJvbSBhIHRpbWVzdGFtcC5cbiAqXG4gKiBAcGFyYW0gdW5peFRpbWVzdGFtcCB0aW1lc3RhbXBcbiAqIEByZXR1cm5zIGRhdGUgc3RyaW5nIGluIHRoZSBmb3JtYXQgb2YgXCJ5eXl5LW1tLWRkIGhoOm1tOnNzXCJcbiAqL1xuZnVuY3Rpb24gZ2V0Rm9ybWF0dGVkRGF0ZVN0cmluZyh1bml4VGltZXN0YW1wKSB7XG4gICAgY29uc3QgZGF0ZU9iaiA9IG5ldyBEYXRlKHVuaXhUaW1lc3RhbXApO1xuICAgIHJldHVybiBgJHtkYXRlT2JqLmdldEZ1bGxZZWFyKCl9LSR7cGFkU3RyaW5nKChkYXRlT2JqLmdldE1vbnRoKCkgKyAxKS50b1N0cmluZygpLCAyLCBcIjBcIil9LSR7cGFkU3RyaW5nKGRhdGVPYmouZ2V0RGF0ZSgpLnRvU3RyaW5nKCksIDIsIFwiMFwiKX0gJHtwYWRTdHJpbmcoZGF0ZU9iai5nZXRIb3VycygpLnRvU3RyaW5nKCksIDIsIFwiMFwiKX06JHtwYWRTdHJpbmcoZGF0ZU9iai5nZXRNaW51dGVzKCkudG9TdHJpbmcoKSwgMiwgXCIwXCIpfToke3BhZFN0cmluZyhkYXRlT2JqLmdldFNlY29uZHMoKS50b1N0cmluZygpLCAyLCBcIjBcIil9YDtcbn1cbmZ1bmN0aW9uIHBhZFN0cmluZyhzdHIsIHRhcmdldExlbmd0aCwgcGFkU3RyaW5nKSB7XG4gICAgcGFkU3RyaW5nID0gcGFkU3RyaW5nIHx8IFwiIFwiO1xuICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgdGFyZ2V0TGVuZ3RoKSB7XG4gICAgICAgIHN0ciA9IHBhZFN0cmluZyArIHN0cjtcbiAgICB9XG4gICAgcmV0dXJuIHN0cjtcbn1cblxuLyoqXG4gKiBnZXQgdGhlIGRlZmF1bHQgc2VsZWN0ZWQgbGF5ZXIgZmllbGQgZm9yIGEgZ2l2ZW4gbGF5ZXJcbiAqXG4gKiBAcGFyYW0gbGF5ZXJGaWVsZHMgLSBsYXllcidzIGZpZWxkc1xuICogQHJldHVybnMgX19lc3JpLkZpZWxkIC0gZGVmYXVsdCBzZWxlY3RlZCBsYXllciBmaWVsZFxuICpcbiAqL1xuZnVuY3Rpb24gZ2V0RGVmYXVsdFNlbGVjdGVkTGF5ZXJGaWVsZChsYXllckZpZWxkcykge1xuICAgIGNvbnN0IGJlc3RGaWVsZCA9IGxheWVyRmllbGRzLmZpbmQoKGZpZWxkKSA9PiBmaWVsZC5uYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwiYmVzdFwiKTtcbiAgICBpZiAoYmVzdEZpZWxkKSB7XG4gICAgICAgIHJldHVybiBiZXN0RmllbGQ7XG4gICAgfVxuICAgIGNvbnN0IGFjcXVpc2l0aW9uRGF0ZUZpZWxkID0gbGF5ZXJGaWVsZHMuZmluZCgoZmllbGQpID0+IGZpZWxkLm5hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJhY3F1aXNpdGlvbmRhdGVcIik7XG4gICAgaWYgKGFjcXVpc2l0aW9uRGF0ZUZpZWxkKSB7XG4gICAgICAgIHJldHVybiBhY3F1aXNpdGlvbkRhdGVGaWVsZDtcbiAgICB9XG4gICAgY29uc3QgZGF0ZVR5cGVGaWVsZCA9IGxheWVyRmllbGRzLmZpbmQoKGZpZWxkKSA9PiBmaWVsZC5uYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwiZGF0ZVwiKTtcbiAgICBpZiAoZGF0ZVR5cGVGaWVsZCkge1xuICAgICAgICByZXR1cm4gZGF0ZVR5cGVGaWVsZDtcbiAgICB9XG4gICAgY29uc3QgaW50T3JEb3VibGVUeXBlRmllbGQgPSBsYXllckZpZWxkcy5maW5kKChmaWVsZCkgPT4gZmllbGQudHlwZSA9PT0gXCJkb3VibGVcIiB8fCBmaWVsZC50eXBlID09PSBcImludGVnZXJcIik7XG4gICAgcmV0dXJuIGludE9yRG91YmxlVHlwZUZpZWxkO1xufVxuLyoqXG4gKiBnZXQgdGhlIGltYWdlIGl0ZW0gY291bnQgdGhhdCBtYXRjaCB0aGUgcXVlcnkgY29uZGl0aW9uXG4gKlxuICogQHBhcmFtIGxheWVyIC0gaW1hZ2VyeSBsYXllclxuICogQHBhcmFtIHF1ZXJ5IC0gbGF5ZXIgcXVlcnlcbiAqIEByZXR1cm5zIG51bWJlciAtIHJhc3RlciBpdGVtIGNvdW50XG4gKlxuICovXG5hc3luYyBmdW5jdGlvbiBnZXRJbWFnZUl0ZW1Db3VudChsYXllciwgcXVlcnkpIHtcbiAgICBsZXQgY291bnQ7XG4gICAgdHJ5IHtcbiAgICAgICAgY291bnQgPSBhd2FpdCBsYXllci5xdWVyeVJhc3RlckNvdW50KHF1ZXJ5KTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycikge1xuICAgICAgICBjb25zb2xlLmxvZyhlcnIpO1xuICAgICAgICAvL1xuICAgIH1cbiAgICByZXR1cm4gTnVtYmVyLmlzSW50ZWdlcihjb3VudCkgPyBjb3VudCA6IG51bGw7XG59XG4vKipcbiAqIGdldCBpbWFnZSBpdGVtcyB0aGF0IG1hdGNoIHRoZSBxdWVyeSBjb25kaXRpb25cbiAqXG4gKiBAcGFyYW0gbGF5ZXIgLSBpbWFnZXJ5IGxheWVyXG4gKiBAcGFyYW0gcXVlcnkgLSBxdWVyeVxuICogQHJldHVybnMgX19lc3JpLkZlYXR1cmVTZXQgLSByYXN0ZXIgaXRlbXNcbiAqXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGdldEZpbHRlcmVkSW1hZ2VJdGVtcyhsYXllciwgcXVlcnkpIHtcbiAgICBxdWVyeS5vdXRGaWVsZHMgPSBbXCIqXCJdO1xuICAgIHF1ZXJ5LnJldHVybkdlb21ldHJ5ID0gdHJ1ZTtcbiAgICBjb25zdCByZXMgPSBhd2FpdCBsYXllci5xdWVyeVJhc3RlcnMocXVlcnkpO1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KHJlcyA9PT0gbnVsbCB8fCByZXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlcy5mZWF0dXJlcykgPyByZXMgOiBudWxsO1xufVxuLyoqXG4gKiBnZXQgdGhlIGdlb21ldHJ5IG9mIGltYWdlIGl0ZW1cbiAqXG4gKiBAcGFyYW0gbGF5ZXIgLSBpbWFnZXJ5IGxheWVyXG4gKiBAcGFyYW0gaW1hZ2VJdGVtT2JqZWN0SUQgLSBpbWFnZSBpdGVtIG9iamVjdCBpZFxuICogQHJldHVybnMgX19lc3JpLkdlb21ldHJ5IC0gaW1hZ2UgaXRlbSBnZW9tZXRyeVxuICpcbiAqL1xuYXN5bmMgZnVuY3Rpb24gZ2V0SW1hZ2VJdGVtR2VvbWV0cnkobGF5ZXIsIGltYWdlSXRlbU9iamVjdElEKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IHF1ZXJ5ID0gbGF5ZXIuY3JlYXRlUXVlcnkoKTtcbiAgICBxdWVyeS53aGVyZSA9IGAke2xheWVyLm9iamVjdElkRmllbGR9ID0gJHtpbWFnZUl0ZW1PYmplY3RJRH1gO1xuICAgIHF1ZXJ5LnJldHVybkdlb21ldHJ5ID0gdHJ1ZTtcbiAgICBsZXQgcmVzO1xuICAgIHRyeSB7XG4gICAgICAgIHJlcyA9IGF3YWl0IGxheWVyLnF1ZXJ5UmFzdGVycyhxdWVyeSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgY29uc29sZS5sb2coZXJyKTtcbiAgICAgICAgLy9cbiAgICB9XG4gICAgcmV0dXJuICgoX2EgPSByZXMgPT09IG51bGwgfHwgcmVzID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZXMuZmVhdHVyZXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVswXS5nZW9tZXRyeSkgfHwgbnVsbDtcbn1cbi8qKlxuICogZ2V0IGRlZmF1bHQgZGlzcGxheWVkIGZpZWxkcyBmb3IgaW1hZ2UgaXRlbSBjYXJkc1xuICpcbiAqIEBwYXJhbSBsYXllciAtIGltYWdlcnkgbGF5ZXJcbiAqIEBwYXJhbSBzZWxlY3RlZFF1ZXJ5RmllbGQgLSBjdXJyZW50IHNlbGVjdGVkIHF1ZXJ5IGZpZWxkXG4gKiBAcmV0dXJucyBfX2VzcmkuRmllbGRbXSAtIGRlZmF1bHQgZGlzcGxheWVkIGZpZWxkc1xuICpcbiAqL1xuZnVuY3Rpb24gZ2V0RGVmYXVsdEltYWdlSXRlbUNhcmREaXNwbGF5ZWRGaWVsZHMobGF5ZXIsIHNlbGVjdGVkUXVlcnlGaWVsZCkge1xuICAgIGNvbnN0IGxheWVyRmllbGRzID0gbGF5ZXIuZmllbGRzO1xuICAgIGNvbnN0IGxheWVyT2JqZWN0SWRGaWVsZE5hbWUgPSBsYXllci5vYmplY3RJZEZpZWxkO1xuICAgIGxldCBkZWZhdWx0RmllbGQgPSBsYXllckZpZWxkcy5maW5kKChmaWVsZCkgPT4gZmllbGQubmFtZS50b0xvd2VyQ2FzZSgpID09PSBcIm5hbWVcIik7XG4gICAgaWYgKCFkZWZhdWx0RmllbGQpIHtcbiAgICAgICAgZGVmYXVsdEZpZWxkID0gbGF5ZXJGaWVsZHMuZmluZCgoZmllbGQpID0+IGZpZWxkLm5hbWUgPT09IGxheWVyT2JqZWN0SWRGaWVsZE5hbWUpO1xuICAgIH1cbiAgICBpZiAoZGVmYXVsdEZpZWxkICYmIGRlZmF1bHRGaWVsZC5uYW1lICE9PSBzZWxlY3RlZFF1ZXJ5RmllbGQubmFtZSkge1xuICAgICAgICByZXR1cm4gW2RlZmF1bHRGaWVsZCwgc2VsZWN0ZWRRdWVyeUZpZWxkXTtcbiAgICB9XG4gICAgcmV0dXJuIFtzZWxlY3RlZFF1ZXJ5RmllbGRdO1xufVxuLyoqXG4gKiBnZXQgc3VwcG9ydGVkIGxheWVyIGZpZWxkcyBiYXNlZCBvbiBmaWVsZCB0eXBlIGZvciBkaXNwbGF5IGFuZCBzZWxlY3Rpb25cbiAqXG4gKiBAcGFyYW0gbGF5ZXJGaWVsZHMgLSBpbWFnZXJ5IGxheWVyXG4gKiBAcmV0dXJucyBfX2VzcmkuRmllbGRbXSAtIHN1cHBvcnRlZCBmaWVsZHNcbiAqXG4gKi9cbmZ1bmN0aW9uIGdldFN1cHBvcnRlZExheWVyRmllbGRzKGxheWVyRmllbGRzKSB7XG4gICAgY29uc3Qgc3VwcG9ydGVkRmllbGRUeXBlcyA9IFtcInNtYWxsLWludGVnZXJcIiwgXCJiaWctaW50ZWdlclwiLCBcImludGVnZXJcIiwgXCJzaW5nbGVcIiwgXCJkb3VibGVcIiwgXCJkYXRlXCIsIFwib2lkXCIsIFwic3RyaW5nXCJdO1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KGxheWVyRmllbGRzKSA/IGxheWVyRmllbGRzLmZpbHRlcigoZmllbGQpID0+IHN1cHBvcnRlZEZpZWxkVHlwZXMuaW5jbHVkZXMoZmllbGQudHlwZSkpIDogW107XG59XG4vKipcbiAqIGJ1aWxkIGxheWVyIHF1ZXJ5XG4gKlxuICogQHBhcmFtIGxheWVyRmllbGRzIC0gaW1hZ2VyeSBsYXllclxuICogQHBhcmFtIHF1ZXJ5RmllbGQgIC0gcXVlcnkgZmllbGRcbiAqIEBwYXJhbSBxdWVyeVZhbHVlIC0gcXVlcnkgdmFsdWVcbiAqIEBwYXJhbSBzZWxlY3RlZEFPSSAtIHNlbGVjdGVkIGFyZWEgb2YgaW50ZXJlc3RcbiAqIEBwYXJhbSBpc092ZXJ2aWV3c0luY2x1ZGVkIC0gaXMgT3ZlcnZpZXdzIGluY2x1ZGVkXG4gKiBAcGFyYW0gbWFwRXh0ZW50IC0gbWFwIGV4dGVudFxuICogQHJldHVybnMgX19lc3JpLlF1ZXJ5IC0gbGF5ZXIgcXVlcnlcbiAqXG4gKi9cbmZ1bmN0aW9uIGJ1aWxkTGF5ZXJRdWVyeShsYXllciwgcXVlcnlGaWVsZCwgcXVlcnlWYWx1ZXMsIHNlbGVjdGVkQU9JLCBpc092ZXJ2aWV3c0luY2x1ZGVkLCBtYXBFeHRlbnQpIHtcbiAgICBjb25zdCBxdWVyeSA9IGxheWVyLmNyZWF0ZVF1ZXJ5KCk7XG4gICAgaWYgKChxdWVyeVZhbHVlcyA9PT0gbnVsbCB8fCBxdWVyeVZhbHVlcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcXVlcnlWYWx1ZXMubGVuZ3RoKSA+IDApIHtcbiAgICAgICAgbGV0IHF1ZXJ5VmFsdWVXaGVyZUNsYXVzZSA9IFwiXCI7XG4gICAgICAgIGlmIChxdWVyeUZpZWxkLnR5cGUgPT09IFwiZGF0ZVwiKSB7XG4gICAgICAgICAgICBpZiAocXVlcnlWYWx1ZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RhcnREYXRlID0gbmV3IERhdGUocXVlcnlWYWx1ZXNbMF0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IGVuZERhdGVUaW1lc3RhbXAgPSBzdGFydERhdGUuc2V0U2Vjb25kcyhzdGFydERhdGUuZ2V0U2Vjb25kcygpICsgMSk7XG4gICAgICAgICAgICAgICAgcXVlcnlWYWx1ZVdoZXJlQ2xhdXNlID0gcXVlcnlWYWx1ZVdoZXJlQ2xhdXNlID0gYCR7cXVlcnlGaWVsZC5uYW1lfSBCRVRXRUVOIHRpbWVzdGFtcCAnJHtnZXRGb3JtYXR0ZWREYXRlU3RyaW5nKHF1ZXJ5VmFsdWVzWzBdKX0nIEFORCB0aW1lc3RhbXAgJyR7Z2V0Rm9ybWF0dGVkRGF0ZVN0cmluZyhlbmREYXRlVGltZXN0YW1wKX0nYDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChxdWVyeVZhbHVlcy5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVZhbHVlV2hlcmVDbGF1c2UgPSBgJHtxdWVyeUZpZWxkLm5hbWV9IEJFVFdFRU4gdGltZXN0YW1wICcke2dldEZvcm1hdHRlZERhdGVTdHJpbmcocXVlcnlWYWx1ZXNbMF0pfScgQU5EIHRpbWVzdGFtcCAnJHtnZXRGb3JtYXR0ZWREYXRlU3RyaW5nKHF1ZXJ5VmFsdWVzWzFdKX0nYDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChxdWVyeVZhbHVlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVZhbHVlV2hlcmVDbGF1c2UgPVxuICAgICAgICAgICAgICAgICAgICB0eXBlb2YgcXVlcnlWYWx1ZXNbMF0gPT09IFwic3RyaW5nXCJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gYCR7cXVlcnlGaWVsZC5uYW1lfT0nJHtxdWVyeVZhbHVlc1swXX0nYFxuICAgICAgICAgICAgICAgICAgICAgICAgOiBgJHtxdWVyeUZpZWxkLm5hbWV9PSR7cXVlcnlWYWx1ZXNbMF19YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChxdWVyeVZhbHVlcy5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVZhbHVlV2hlcmVDbGF1c2UgPVxuICAgICAgICAgICAgICAgICAgICB0eXBlb2YgcXVlcnlWYWx1ZXNbMF0gPT09IFwic3RyaW5nXCJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gYCR7cXVlcnlGaWVsZC5uYW1lfSBCRVRXRUVOICcke3F1ZXJ5VmFsdWVzWzBdfScgQU5EICcke3F1ZXJ5VmFsdWVzWzFdfSdgXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGAke3F1ZXJ5RmllbGQubmFtZX0gQkVUV0VFTiAke3F1ZXJ5VmFsdWVzWzBdfSBBTkQgJHtxdWVyeVZhbHVlc1sxXX1gO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXJ5LndoZXJlID0gcXVlcnlWYWx1ZVdoZXJlQ2xhdXNlO1xuICAgIH1cbiAgICBjb25zdCBxdWVyeU92ZXJ2aWV3V2hlcmVDbGF1c2UgPSBcIihDYXRlZ29yeSA8PiAyKVwiO1xuICAgIGlmICghaXNPdmVydmlld3NJbmNsdWRlZCkge1xuICAgICAgICBjb25zdCBuZXdXaGVyZUNsYXVzZSA9IHF1ZXJ5T3ZlcnZpZXdXaGVyZUNsYXVzZSArIChxdWVyeS53aGVyZSA/IFwiIEFORCBcIiArIHF1ZXJ5LndoZXJlIDogXCJcIik7XG4gICAgICAgIHF1ZXJ5LndoZXJlID0gbmV3V2hlcmVDbGF1c2U7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBxdWVyeS53aGVyZSA9IHF1ZXJ5LndoZXJlLnJlcGxhY2UocXVlcnlPdmVydmlld1doZXJlQ2xhdXNlLCBcIlwiKTtcbiAgICB9XG4gICAgcXVlcnkuZ2VvbWV0cnkgPSBzZWxlY3RlZEFPSSA9PT0gQU9JLkRpc3BsYXlFeHRlbnQgPyBtYXBFeHRlbnQgOiBudWxsO1xuICAgIHF1ZXJ5LnNwYXRpYWxSZWxhdGlvbnNoaXAgPSBzZWxlY3RlZEFPSSA9PT0gQU9JLkRpc3BsYXlFeHRlbnQgPyBcImludGVyc2VjdHNcIiA6IG51bGw7XG4gICAgcmV0dXJuIHF1ZXJ5O1xufVxuLyoqXG4gKiBnZXQgdW5pcXVlIHZhbHVlIGZvciBhbiBhdHRyaWJ1dGUgZmllbGQgaW4gdGhlIGltYWdlcnkgbGF5ZXJcbiAqXG4gKiBAcGFyYW0gbGF5ZXIgLSBpbWFnZXJ5IGxheWVyXG4gKiBAcGFyYW0gcXVlcnlGaWVsZE5hbWUgLSBxdWVyeSBmaWVsZCBuYW1lXG4gKiBAcGFyYW0gc2VsZWN0ZWRBT0kgLSBzZWxlY3RlZCBBT0lcbiAqIEBwYXJhbSBtYXBFeHRlbnQgLSBtYXAgZXh0ZW50XG4gKiBAcGFyYW0gYWJvcnRTaWduYWwgLSBhYm9ydCBzaWduYWxcbiAqIEBwYXJhbSBpc0ZldGNoaW5nQWxsIC0gd2hldGhlciBpcyBmZXRjaGluZyBhbGwgcmVzdWx0c1xuICogQHJldHVybnMgQXJyYXk8c3RyaW5nIHwgbnVtYmVyPiAtIHVuaXF1ZSB2YWx1ZSBhcnJheVxuICovXG5hc3luYyBmdW5jdGlvbiBnZXRVbmlxdWVWYWx1ZXNGb3JMYXllckZpZWxkKGxheWVyLCBxdWVyeUZpZWxkLCBzZWxlY3RlZEFPSSwgbWFwRXh0ZW50LCBhYm9ydFNpZ25hbCwgaXNGZXRjaGluZ0FsbCA9IGZhbHNlKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICBpZiAoIXF1ZXJ5RmllbGQpXG4gICAgICAgIHJldHVybiBbXTtcbiAgICBjb25zdCBxdWVyeSA9IGxheWVyLmNyZWF0ZVF1ZXJ5KCk7XG4gICAgcXVlcnkud2hlcmUgPSBcIjE9MVwiO1xuICAgIGNvbnN0IGlzQ29uc3RyYWluZWRCeU1hcEV4dGVudCA9IHNlbGVjdGVkQU9JID09PSBBT0kuRGlzcGxheUV4dGVudCB8fCBzZWxlY3RlZEFPSSA9PT0gQU9JLlZpc2libGU7XG4gICAgcXVlcnkuZ2VvbWV0cnkgPSBpc0NvbnN0cmFpbmVkQnlNYXBFeHRlbnQgPyBtYXBFeHRlbnQgOiBudWxsO1xuICAgIHF1ZXJ5LnNwYXRpYWxSZWxhdGlvbnNoaXAgPSBpc0NvbnN0cmFpbmVkQnlNYXBFeHRlbnQgPyBcImludGVyc2VjdHNcIiA6IG51bGw7XG4gICAgcXVlcnkub3V0RmllbGRzID0gW3F1ZXJ5RmllbGRdO1xuICAgIHF1ZXJ5Lm9yZGVyQnlGaWVsZHMgPSBbYCR7cXVlcnlGaWVsZH0gQVNDYF07XG4gICAgcXVlcnkucmV0dXJuRXhjZWVkZWRMaW1pdEZlYXR1cmVzID0gdHJ1ZTtcbiAgICBxdWVyeS5yZXR1cm5HZW9tZXRyeSA9IGZhbHNlO1xuICAgIGNvbnN0IHJlc3VsdFZhbHVlcyA9IFtdO1xuICAgIGlmIChpc0ZldGNoaW5nQWxsKSB7XG4gICAgICAgIGxldCBoYXNNb3JlID0gdHJ1ZTtcbiAgICAgICAgd2hpbGUgKGhhc01vcmUpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IGxheWVyLnF1ZXJ5UmFzdGVycyhxdWVyeSwgeyBzaWduYWw6IGFib3J0U2lnbmFsIH0pO1xuICAgICAgICAgICAgaGFzTW9yZSA9IHJlcyA9PT0gbnVsbCB8fCByZXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlcy5leGNlZWRlZFRyYW5zZmVyTGltaXQ7XG4gICAgICAgICAgICBpZiAoKChfYSA9IHJlcy5mZWF0dXJlcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmxlbmd0aCkgPiAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWVzVG9BZGQgPSB1bmlxdWUocmVzLmZlYXR1cmVzLm1hcCgoZmVhdHVyZSkgPT4gZmVhdHVyZS5hdHRyaWJ1dGVzW3F1ZXJ5RmllbGRdKSk7XG4gICAgICAgICAgICAgICAgcmVzdWx0VmFsdWVzLnB1c2goLi4udmFsdWVzVG9BZGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHRWYWx1ZXM7XG4gICAgfVxuICAgIGNvbnN0IHJlcyA9IGF3YWl0IGxheWVyLnF1ZXJ5UmFzdGVycyhxdWVyeSwgeyBzaWduYWw6IGFib3J0U2lnbmFsIH0pO1xuICAgIGlmICgoKF9iID0gcmVzID09PSBudWxsIHx8IHJlcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVzLmZlYXR1cmVzKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IubGVuZ3RoKSA+IDApIHtcbiAgICAgICAgY29uc3QgdmFsdWVzVG9BZGQgPSB1bmlxdWUocmVzLmZlYXR1cmVzLm1hcCgoZmVhdHVyZSkgPT4gZmVhdHVyZS5hdHRyaWJ1dGVzW3F1ZXJ5RmllbGRdKSk7XG4gICAgICAgIHJldHVybiB2YWx1ZXNUb0FkZDtcbiAgICB9XG4gICAgcmV0dXJuIFtdO1xufVxuLyoqXG4gKiBnZXQgbWluL21heCB2YWx1ZSBmb3IgYW4gYXR0cmlidXRlIGZpZWxkIGluIHRoZSBpbWFnZXJ5IGxheWVyXG4gKlxuICogQHBhcmFtIGxheWVyIC0gaW1hZ2VyeSBsYXllclxuICogQHBhcmFtIHF1ZXJ5RmllbGROYW1lIC0gcXVlcnkgZmllbGQgbmFtZVxuICogQHBhcmFtIHNlbGVjdGVkQU9JIC0gc2VsZWN0ZWQgQU9JXG4gKiBAcGFyYW0gbWFwRXh0ZW50IC0gbWFwIGV4dGVudFxuICogQHBhcmFtIGFib3J0U2lnbmFsIC0gYWJvcnQgc2lnbmFsXG4gKiBAcmV0dXJucyBBcnJheTxzdHJpbmcgfCBudW1iZXI+IC0gbWluL21heCB2YWx1ZSBhcnJheSBbbWluLCBtYXhdXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGdldE1pbkFuZE1heFZhbHVlc0ZvckxheWVyRmllbGQobGF5ZXIsIHF1ZXJ5RmllbGROYW1lLCBzZWxlY3RlZEFPSSwgbWFwRXh0ZW50LCBhYm9ydFNpZ25hbCkge1xuICAgIHZhciBfYTtcbiAgICBpZiAoIXF1ZXJ5RmllbGROYW1lKVxuICAgICAgICByZXR1cm4gW107XG4gICAgY29uc3QgcXVlcnkgPSBsYXllci5jcmVhdGVRdWVyeSgpO1xuICAgIHF1ZXJ5LndoZXJlID0gXCIxPTFcIjtcbiAgICBjb25zdCBpc0NvbnN0cmFpbmVkQnlNYXBFeHRlbnQgPSBzZWxlY3RlZEFPSSA9PT0gQU9JLkRpc3BsYXlFeHRlbnQgfHwgc2VsZWN0ZWRBT0kgPT09IEFPSS5WaXNpYmxlO1xuICAgIHF1ZXJ5Lmdlb21ldHJ5ID0gaXNDb25zdHJhaW5lZEJ5TWFwRXh0ZW50ID8gbWFwRXh0ZW50IDogbnVsbDtcbiAgICBxdWVyeS5zcGF0aWFsUmVsYXRpb25zaGlwID0gaXNDb25zdHJhaW5lZEJ5TWFwRXh0ZW50ID8gXCJpbnRlcnNlY3RzXCIgOiBudWxsO1xuICAgIHF1ZXJ5LnJldHVybkdlb21ldHJ5ID0gZmFsc2U7XG4gICAgcXVlcnkub3V0U3RhdGlzdGljcyA9IFtcbiAgICAgICAge1xuICAgICAgICAgICAgc3RhdGlzdGljVHlwZTogXCJtaW5cIixcbiAgICAgICAgICAgIG9uU3RhdGlzdGljRmllbGQ6IHF1ZXJ5RmllbGROYW1lLFxuICAgICAgICAgICAgb3V0U3RhdGlzdGljRmllbGROYW1lOiBcIk1JTl9GSUVMRF9WQUxVRVwiXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIHN0YXRpc3RpY1R5cGU6IFwibWF4XCIsXG4gICAgICAgICAgICBvblN0YXRpc3RpY0ZpZWxkOiBxdWVyeUZpZWxkTmFtZSxcbiAgICAgICAgICAgIG91dFN0YXRpc3RpY0ZpZWxkTmFtZTogXCJNQVhfRklFTERfVkFMVUVcIlxuICAgICAgICB9XG4gICAgXTtcbiAgICBjb25zdCByZXMgPSBhd2FpdCBsYXllci5xdWVyeVJhc3RlcnMocXVlcnksIHsgc2lnbmFsOiBhYm9ydFNpZ25hbCB9KTtcbiAgICBpZiAoKChfYSA9IHJlcyA9PT0gbnVsbCB8fCByZXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlcy5mZWF0dXJlcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmxlbmd0aCkgPiAwKSB7XG4gICAgICAgIGNvbnN0IFtmZWF0dXJlXSA9IHJlcy5mZWF0dXJlcztcbiAgICAgICAgcmV0dXJuIFtmZWF0dXJlLmF0dHJpYnV0ZXNbXCJNSU5fRklFTERfVkFMVUVcIl0sIGZlYXR1cmUuYXR0cmlidXRlc1tcIk1BWF9GSUVMRF9WQUxVRVwiXV07XG4gICAgfVxuICAgIHJldHVybiBbXTtcbn1cbi8qKlxuICogZ2VuZXJhdGUgdGhlIHBhcmFtZXRlcnMgZm9yIGltYWdlcnkgbGF5ZXIgaWRlbnRpZnkgZnVuY3Rpb25cbiAqXG4gKiBAcGFyYW0gbGF5ZXIgLSBpbWFnZXJ5IGxheWVyXG4gKiBAcGFyYW0gbWFwVmlldyAtIGN1cnJlbnQgbWFwIHZpZXdcbiAqIEByZXR1cm5zIF9fZXNyaS5JbWFnZUlkZW50aWZ5UGFyYW1ldGVyc1xuICovXG5hc3luYyBmdW5jdGlvbiBnZW5lcmF0ZUlkZW50aWZ5UGFyYW1zKGxheWVyLCBtYXBWaWV3KSB7XG4gICAgY29uc3QgW1BvbHlnb24sIFBvaW50LCBJbWFnZUlkZW50aWZ5UGFyYW1ldGVyc10gPSBhd2FpdCBsb2FkTW9kdWxlcyhbXG4gICAgICAgIFwiZXNyaS9nZW9tZXRyeS9Qb2x5Z29uXCIsXG4gICAgICAgIFwiZXNyaS9nZW9tZXRyeS9Qb2ludFwiLFxuICAgICAgICBcImVzcmkvcmVzdC9zdXBwb3J0L0ltYWdlSWRlbnRpZnlQYXJhbWV0ZXJzXCJcbiAgICBdKTtcbiAgICBjb25zdCB7IGV4dGVudCwgd2lkdGgsIGhlaWdodCB9ID0gbWFwVmlldztcbiAgICBjb25zdCBwb2x5Z29uID0gbmV3IFBvbHlnb24oZXh0ZW50LnNwYXRpYWxSZWZlcmVuY2UpO1xuICAgIHBvbHlnb24uYWRkUmluZyhbXG4gICAgICAgIFtleHRlbnQueG1pbiwgZXh0ZW50LnltaW5dLFxuICAgICAgICBbZXh0ZW50LnhtaW4sIGV4dGVudC55bWF4XSxcbiAgICAgICAgW2V4dGVudC54bWF4LCBleHRlbnQueW1heF0sXG4gICAgICAgIFtleHRlbnQueG1heCwgZXh0ZW50LnltaW5dLFxuICAgICAgICBbZXh0ZW50LnhtaW4sIGV4dGVudC55bWluXVxuICAgIF0pO1xuICAgIGNvbnN0IHBzWCA9IChleHRlbnQueG1heCAtIGV4dGVudC54bWluKSAvIHdpZHRoO1xuICAgIGNvbnN0IHBzWSA9IChleHRlbnQueW1heCAtIGV4dGVudC55bWluKSAvIGhlaWdodDtcbiAgICBjb25zdCBwaXhlbFNpemUgPSBuZXcgUG9pbnQocHNYLCBwc1ksIGV4dGVudC5zcGF0aWFsUmVmZXJlbmNlKTtcbiAgICBjb25zdCBpZGVudGlmeVBhcmFtcyA9IG5ldyBJbWFnZUlkZW50aWZ5UGFyYW1ldGVycygpO1xuICAgIGlkZW50aWZ5UGFyYW1zLmdlb21ldHJ5ID0gcG9seWdvbjtcbiAgICBpZGVudGlmeVBhcmFtcy5yZXR1cm5HZW9tZXRyeSA9IGZhbHNlO1xuICAgIGlkZW50aWZ5UGFyYW1zLnBpeGVsU2l6ZSA9IHBpeGVsU2l6ZTtcbiAgICBjb25zdCBtb3NhaWNSdWxlID0gbGF5ZXIubW9zYWljUnVsZS5jbG9uZSgpO1xuICAgIGlmIChsYXllci5kZWZpbml0aW9uRXhwcmVzc2lvbikge1xuICAgICAgICBtb3NhaWNSdWxlLndoZXJlID0gbGF5ZXIuZGVmaW5pdGlvbkV4cHJlc3Npb247XG4gICAgfVxuICAgIGlkZW50aWZ5UGFyYW1zLm1vc2FpY1J1bGUgPSBtb3NhaWNSdWxlO1xuICAgIHJldHVybiBpZGVudGlmeVBhcmFtcztcbn1cbi8qKlxuICogZ2V0IHZpc2libGUgaW1hZ2UgaXRlbXMgdGhhdCBtYXRjaCB0aGUgcXVlcnkgY29uZGl0aW9uXG4gKlxuICogQHBhcmFtIGxheWVyIC0gaW1hZ2VyeSBsYXllclxuICogQHBhcmFtIG1hcFZpZXcgLSBjdXJyZW50IG1hcCB2aWV3XG4gKiBAcGFyYW0gbGF5ZXJRdWVyeSAtIGN1cnJlbnQgbWFwIHZpZXdcbiAqIEByZXR1cm5zIF9fZXNyaS5GZWF0dXJlU2V0IC0gcmFzdGVyIGl0ZW1zXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGdldEZpbHRlcmVkVmlzaWJsZUltYWdlSXRlbXMobGF5ZXIsIG1hcFZpZXcsIGxheWVyUXVlcnkpIHtcbiAgICB2YXIgX2E7XG4gICAgbGV0IHZpc2libGVJbWFnZUl0ZW1PYmplY3RJZHMgPSBbXTtcbiAgICBjb25zdCBpZGVudGlmeVBhcmFtcyA9IGF3YWl0IGdlbmVyYXRlSWRlbnRpZnlQYXJhbXMobGF5ZXIsIG1hcFZpZXcpO1xuICAgIGlmIChsYXllci52aXNpYmxlKSB7XG4gICAgICAgIGNvbnN0IGlkZW50aWZ5UmVzdWx0ID0gYXdhaXQgbGF5ZXIuaWRlbnRpZnkoaWRlbnRpZnlQYXJhbXMpO1xuICAgICAgICBpZiAoISgoX2EgPSBpZGVudGlmeVJlc3VsdCA9PT0gbnVsbCB8fCBpZGVudGlmeVJlc3VsdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogaWRlbnRpZnlSZXN1bHQuY2F0YWxvZ0l0ZW1zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZmVhdHVyZXMpIHx8ICEoaWRlbnRpZnlSZXN1bHQgPT09IG51bGwgfHwgaWRlbnRpZnlSZXN1bHQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGlkZW50aWZ5UmVzdWx0LmNhdGFsb2dJdGVtVmlzaWJpbGl0aWVzKSlcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBjb25zdCBvYmplY3RJZEZpZWxkTmFtZSA9IGxheWVyLm9iamVjdElkRmllbGQ7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaWRlbnRpZnlSZXN1bHQuY2F0YWxvZ0l0ZW1zLmZlYXR1cmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoaWRlbnRpZnlSZXN1bHQuY2F0YWxvZ0l0ZW1WaXNpYmlsaXRpZXNbaV0gPiAwKSB7XG4gICAgICAgICAgICAgICAgdmlzaWJsZUltYWdlSXRlbU9iamVjdElkcy5wdXNoKGlkZW50aWZ5UmVzdWx0LmNhdGFsb2dJdGVtcy5mZWF0dXJlc1tpXS5hdHRyaWJ1dGVzW29iamVjdElkRmllbGROYW1lXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZpc2libGVJbWFnZUl0ZW1PYmplY3RJZHMubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGNvbnN0IG9iamVjdElkUXVlcnlTdHJpbmcgPSBgJHtsYXllci5vYmplY3RJZEZpZWxkfSBpbiAoJHt2aXNpYmxlSW1hZ2VJdGVtT2JqZWN0SWRzXG4gICAgICAgICAgICAubWFwKChvaWQpID0+IGAke29pZH1gKVxuICAgICAgICAgICAgLmpvaW4oXCIsXCIpfSlgO1xuICAgICAgICBsYXllclF1ZXJ5LndoZXJlID0gYCR7bGF5ZXJRdWVyeS53aGVyZX0gQU5EICR7b2JqZWN0SWRRdWVyeVN0cmluZ31gO1xuICAgICAgICBsYXllclF1ZXJ5Lm91dEZpZWxkcyA9IFtcIipcIl07XG4gICAgICAgIGxheWVyUXVlcnkucmV0dXJuR2VvbWV0cnkgPSB0cnVlO1xuICAgICAgICBjb25zdCByZXMgPSBhd2FpdCBsYXllci5xdWVyeVJhc3RlcnMobGF5ZXJRdWVyeSk7XG4gICAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KHJlcyA9PT0gbnVsbCB8fCByZXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlcy5mZWF0dXJlcykgPyByZXMgOiBudWxsO1xuICAgIH1cbn1cblxuZXhwb3J0IHsgQU9JIGFzIEEsIE5hdmlnYXRpb25UYWIgYXMgTiwgZ2V0SW1hZ2VJdGVtQ291bnQgYXMgYSwgYnVpbGRMYXllclF1ZXJ5IGFzIGIsIGdldEZpbHRlcmVkSW1hZ2VJdGVtcyBhcyBjLCBnZXREZWZhdWx0SW1hZ2VJdGVtQ2FyZERpc3BsYXllZEZpZWxkcyBhcyBkLCBnZXRNaW5BbmRNYXhWYWx1ZXNGb3JMYXllckZpZWxkIGFzIGUsIGdldFVuaXF1ZVZhbHVlc0ZvckxheWVyRmllbGQgYXMgZiwgZ2V0RmlsdGVyZWRWaXNpYmxlSW1hZ2VJdGVtcyBhcyBnLCBnZXRTdXBwb3J0ZWRMYXllckZpZWxkcyBhcyBoLCBpc0Fib3J0ZWRFcnJvciBhcyBpLCBnZXREZWZhdWx0U2VsZWN0ZWRMYXllckZpZWxkIGFzIGosIGlzTnVtZXJpY0ZpZWxkVHlwZSBhcyBrLCBnZXRGb3JtYXR0ZWREYXRlU3RyaW5nIGFzIGwsIGdldEltYWdlSXRlbUdlb21ldHJ5IGFzIG0gfTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bGF5ZXItOWE3NTkzYWEuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9