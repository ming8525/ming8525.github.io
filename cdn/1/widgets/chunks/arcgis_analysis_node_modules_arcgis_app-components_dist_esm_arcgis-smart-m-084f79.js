"use strict";
(self["webpackChunkexb_client"] = self["webpackChunkexb_client"] || []).push([["extensions_widgets_arcgis_analysis_node_modules_arcgis_app-components_dist_esm_arcgis-smart-m-084f79"],{

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/arcgis-smart-mapping-slider-input.entry.js":
/*!************************************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/arcgis-smart-mapping-slider-input.entry.js ***!
  \************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   arcgis_smart_mapping_slider_input: () => (/* binding */ ArcgisSmartMappingSliderInput)
/* harmony export */ });
/* harmony import */ var _index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index-e3bf7da7.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/index-e3bf7da7.js");
/* harmony import */ var _raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./raster-unique-value-0976ec7f.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/raster-unique-value-0976ec7f.js");
/* harmony import */ var _loadModules_b4ac1247_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./loadModules-b4ac1247.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/loadModules-b4ac1247.js");
/* harmony import */ var _commonEnums_fcf13661_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./commonEnums-fcf13661.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/commonEnums-fcf13661.js");
/* harmony import */ var _functional_44de8fcf_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./functional-44de8fcf.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/functional-44de8fcf.js");
/* harmony import */ var _languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./languageUtil-ef0e54b2.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/languageUtil-ef0e54b2.js");
/* harmony import */ var _dom_4d367677_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./dom-4d367677.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/dom-4d367677.js");
/* harmony import */ var _locale_050b6db9_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./locale-050b6db9.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/locale-050b6db9.js");
/* harmony import */ var _index_05956cab_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./index-05956cab.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/index-05956cab.js");
/* harmony import */ var _commonFunctions_b0830e9e_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./commonFunctions-b0830e9e.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/commonFunctions-b0830e9e.js");
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v4.0.58
 */











const arcgisSmartMappingSliderInputCss = ".combo{display:flex;align-items:center;justify-content:space-between;position:relative;width:100%}.slider{width:43%;height:44px;background-color:transparent;position:relative;margin:0 4px 0 4px}.slider .esri-slider__content{margin-bottom:20px}.input{width:51%}";

const ArcgisSmartMappingSliderInput = class {
    constructor(hostRef) {
        (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.r)(this, hostRef);
        this.arcgisSmartMappingSliderInputChange = (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, "arcgisSmartMappingSliderInputChange", 7);
        this.disabled = false;
        this.min = undefined;
        this.max = undefined;
        this.values = undefined;
        this.precision = undefined;
        this.prefixText = undefined;
        this.suffixText = undefined;
    }
    //--------------------------------------------------------------------------
    //
    //  Lifecycle
    //
    //--------------------------------------------------------------------------
    componentDidLoad() {
        const { config } = _raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_1__.s;
        this.hostElement.shadowRoot.firstElementChild.insertAdjacentHTML("beforebegin", `<link rel="stylesheet" href="${config.jsapiUrl}/themes/light/main.css" />`);
    }
    //--------------------------------------------------------------------------
    //
    // Render Methods
    //
    //--------------------------------------------------------------------------
    render() {
        const { modules } = _raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_1__.s;
        if (!this.sliderInput) {
            const config = {
                min: this.min,
                max: this.max,
                values: this.values,
                precision: this.precision
            };
            this.sliderInput = new modules.Slider(config);
        }
        else {
            let config = {
                min: this.min,
                max: this.max,
                values: this.values
            };
            this.sliderInput.set(config);
        }
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "combo" }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "slider slider-bottom-label", ref: (node) => {
                if (node) {
                    this.afterSliderInputCreate(node);
                }
            } }), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-input-number", { disabled: this.disabled, class: "input", min: this.min, max: this.max, value: `${this.values[0]}`, scale: "s", prefixText: this.prefixText, suffixText: this.suffixText, step: (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_1__.ac)(this.precision) ? Math.pow(10, -1 * this.precision) : 1, onCalciteInputNumberInput: () => {
                const value = parseFloat(this.sliderValueNode.value);
                if (!value || value < this.min || value > this.max) {
                    this.sliderValueHandle = setTimeout(() => this.handleSliderValueChange(), 3000);
                }
                else {
                    clearTimeout(this.sliderValueHandle);
                    this.handleSliderValueChange();
                }
            }, ref: (node) => {
                if (node) {
                    this.sliderValueNode = node;
                }
            } })));
    }
    // -------------------------------------------------------------------
    //
    //  Private methods
    //
    // -------------------------------------------------------------------
    afterSliderInputCreate(node) {
        if (!this.sliderInput.container) {
            const divNode = document.createElement("div");
            node.append(divNode);
            this.sliderInput.container = divNode;
            this.createSliderInputChangeEvents();
        }
    }
    createSliderInputChangeEvents() {
        this.sliderInput.on("thumb-change", () => {
            this.handleSliderInputValueChange();
        });
        this.sliderInput.on("thumb-drag", (0,_functional_44de8fcf_js__WEBPACK_IMPORTED_MODULE_4__.d)(() => {
            this.handleSliderInputValueChange();
        }, 100));
    }
    handleSliderInputValueChange() {
        this.sliderValueNode.value = `${this.sliderInput.values[0]}`;
        this.arcgisSmartMappingSliderInputChange.emit(this.sliderInput.values[0]);
    }
    handleSliderValueChange() {
        let value = parseFloat(this.sliderValueNode.value);
        if (isNaN(value) || value < this.min) {
            value = this.min;
        }
        else if (value > this.max) {
            value = this.max;
        }
        this.sliderValueNode.value = `${value}`;
        this.sliderInput.values = [value];
        this.arcgisSmartMappingSliderInputChange.emit(this.sliderInput.values[0]);
    }
    get hostElement() { return (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.d)(this); }
};
ArcgisSmartMappingSliderInput.style = arcgisSmartMappingSliderInputCss;



//# sourceMappingURL=arcgis-smart-mapping-slider-input.entry.js.map

/***/ }),

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/functional-44de8fcf.js":
/*!****************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/functional-44de8fcf.js ***!
  \****************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   a: () => (/* binding */ arrayToLookupMap),
/* harmony export */   b: () => (/* binding */ unique),
/* harmony export */   c: () => (/* binding */ throttle),
/* harmony export */   d: () => (/* binding */ debounce),
/* harmony export */   e: () => (/* binding */ escapeRegExp),
/* harmony export */   f: () => (/* binding */ arraysAreEquivalent),
/* harmony export */   g: () => (/* binding */ chunk),
/* harmony export */   i: () => (/* binding */ isDefined),
/* harmony export */   m: () => (/* binding */ minDelay),
/* harmony export */   t: () => (/* binding */ timeout),
/* harmony export */   u: () => (/* binding */ uniqueBy)
/* harmony export */ });
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v4.0.58
 */
/**
 * Call a function only after it has not been called for n milliseconds
 * @param fn    - function to call
 * @param delay - delay in milliseconds
 */
const debounce = (fn, delay) => {
    let timeout;
    let status = "idle";
    function flush(...args) {
        status = "flushed";
        return debounced(...args);
    }
    function invoke(...args) {
        status = "invoked";
        return debounced(...args);
    }
    function cancel(...args) {
        status = "cancelled";
        return debounced(...args);
    }
    function getStatus() {
        return status;
    }
    const debounced = (...args) => new Promise((resolve) => {
        switch (status) {
            case "flushed":
                status = "idle";
                if (timeout) {
                    clearTimeout(timeout);
                    resolve(fn(...args));
                }
                else {
                    resolve(null);
                }
                break;
            case "invoked":
                clearTimeout(timeout);
                status = "idle";
                resolve(fn(...args));
                break;
            case "cancelled":
                clearTimeout(timeout);
                status = "idle";
                resolve(null);
                break;
            default:
                if (timeout) {
                    clearTimeout(timeout);
                }
                status = "pending";
                timeout = setTimeout(() => {
                    status = "idle";
                    return resolve(fn(...args));
                }, delay);
                break;
        }
    });
    debounced.flush = flush;
    debounced.invoke = invoke;
    debounced.cancel = cancel;
    debounced.getStatus = getStatus;
    return debounced;
};
/**
 * Call a function only after n milliseconds have elapsed
 * @param fn    - function to call
 * @param delay - delay in milliseconds
 */
const throttle = (fn, delay) => {
    let timeout;
    return (...args) => new Promise((resolve) => {
        if (timeout) {
            return;
        }
        timeout = setTimeout(() => {
            clearTimeout(timeout);
            timeout = undefined;
            resolve(fn(...args));
        }, delay);
    });
};
function escapeRegExp(str) {
    return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"); // $& means the whole matched string
}
function isDefined(value) {
    return value !== undefined && value !== null;
}
/**
 * Set a minimum time for a promise to resolve (useful for preventing flash of loaders)
 */
async function minDelay(promise, minDelay) {
    await Promise.all([promise, timeout(minDelay)]);
    return promise;
}
/**
 * Helper method to inline setTimeout as an await in async functions
 */
function timeout(ms) {
    return new Promise((resolve) => setTimeout(resolve, ms));
}
const arrayToLookupMap = (dataArr, getKeyAndItem) => Object.fromEntries((dataArr || []).map((item) => {
    const { key, data } = getKeyAndItem(item);
    return [key, data];
}));
/**
 * Check whether two arrays have the same number of elements
 * and whether they contain the same elements
 * regardless of order
 */
const arraysAreEquivalent = (arr1, arr2) => arr1.length === arr2.length && arr1.reduce((memo, str) => memo && arr2.indexOf(str) > -1, true);
function uniqueBy(myArr, getItemId) {
    const resultArr = [];
    const lookupMap = {};
    myArr.forEach((item) => {
        const id = getItemId(item);
        if (lookupMap[id] == null) {
            lookupMap[id] = item;
            resultArr.push(item);
        }
    });
    return resultArr;
}
function unique(myArr) {
    const primitives = { boolean: {}, number: {}, string: {} };
    const objs = [];
    return myArr.filter((item) => {
        let type = typeof item;
        if (type in primitives) {
            return primitives[type].hasOwnProperty(item) ? false : (primitives[type][item] = true);
        }
        else {
            return objs.indexOf(item) >= 0 ? false : objs.push(item);
        }
    });
}
const chunk = (arr, size) => [...Array(Math.ceil(arr.length / size))].map((_, i) => arr.slice(size * i, size + size * i));



//# sourceMappingURL=functional-44de8fcf.js.map

/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid2lkZ2V0cy9jaHVua3MvYXJjZ2lzX2FuYWx5c2lzX25vZGVfbW9kdWxlc19hcmNnaXNfYXBwLWNvbXBvbmVudHNfZGlzdF9lc21fYXJjZ2lzLXNtYXJ0LW0tMDg0Zjc5LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDa0c7QUFDTjtBQUN6RDtBQUNBO0FBQ3NCO0FBQ3JCO0FBQ1Q7QUFDRztBQUNEO0FBQ1U7O0FBRXZDLGlEQUFpRCxhQUFhLG1CQUFtQiw4QkFBOEIsa0JBQWtCLFdBQVcsUUFBUSxVQUFVLFlBQVksNkJBQTZCLGtCQUFrQixtQkFBbUIsOEJBQThCLG1CQUFtQixPQUFPLFVBQVU7O0FBRTlTO0FBQ0E7QUFDQSxRQUFRLHFEQUFnQjtBQUN4QixtREFBbUQscURBQVc7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixTQUFTLEVBQUUsK0RBQWlCO0FBQzVDLHdIQUF3SCxnQkFBZ0I7QUFDeEk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsVUFBVSxFQUFFLCtEQUFpQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHFEQUFDLFVBQVUsZ0JBQWdCLEVBQUUscURBQUMsVUFBVTtBQUN4RDtBQUNBO0FBQ0E7QUFDQSxlQUFlLEdBQUcscURBQUMsMkJBQTJCLGlGQUFpRixlQUFlLCtFQUErRSxvRUFBUztBQUN0TztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULDBDQUEwQywwREFBUTtBQUNsRDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0Esd0NBQXdDLDJCQUEyQjtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxNQUFNO0FBQzlDO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixPQUFPLHFEQUFVO0FBQ3pDO0FBQ0E7O0FBRThFOztBQUU5RTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDNUhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBLGlDQUFpQyxzQkFBc0I7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxZQUFZO0FBQ3hCO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsV0FBVyxZQUFZO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVpTTs7QUFFak0iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9leGItY2xpZW50Ly4vZXh0ZW5zaW9ucy93aWRnZXRzL2FyY2dpcy9hbmFseXNpcy9ub2RlX21vZHVsZXMvQGFyY2dpcy9hcHAtY29tcG9uZW50cy9kaXN0L2VzbS9hcmNnaXMtc21hcnQtbWFwcGluZy1zbGlkZXItaW5wdXQuZW50cnkuanMiLCJ3ZWJwYWNrOi8vZXhiLWNsaWVudC8uL2V4dGVuc2lvbnMvd2lkZ2V0cy9hcmNnaXMvYW5hbHlzaXMvbm9kZV9tb2R1bGVzL0BhcmNnaXMvYXBwLWNvbXBvbmVudHMvZGlzdC9lc20vZnVuY3Rpb25hbC00NGRlOGZjZi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIEFsbCBtYXRlcmlhbCBjb3B5cmlnaHQgRVNSSSwgQWxsIFJpZ2h0cyBSZXNlcnZlZCwgdW5sZXNzIG90aGVyd2lzZSBzcGVjaWZpZWQuXG4gKiB2NC4wLjU4XG4gKi9cbmltcG9ydCB7IHIgYXMgcmVnaXN0ZXJJbnN0YW5jZSwgYyBhcyBjcmVhdGVFdmVudCwgaCwgZCBhcyBnZXRFbGVtZW50IH0gZnJvbSAnLi9pbmRleC1lM2JmN2RhNy5qcyc7XG5pbXBvcnQgeyBhYyBhcyBpc0RlZmluZWQsIHMgYXMgc21hcnRNYXBwaW5nU3RhdGUgfSBmcm9tICcuL3Jhc3Rlci11bmlxdWUtdmFsdWUtMDk3NmVjN2YuanMnO1xuaW1wb3J0ICcuL2xvYWRNb2R1bGVzLWI0YWMxMjQ3LmpzJztcbmltcG9ydCAnLi9jb21tb25FbnVtcy1mY2YxMzY2MS5qcyc7XG5pbXBvcnQgeyBkIGFzIGRlYm91bmNlIH0gZnJvbSAnLi9mdW5jdGlvbmFsLTQ0ZGU4ZmNmLmpzJztcbmltcG9ydCAnLi9sYW5ndWFnZVV0aWwtZWYwZTU0YjIuanMnO1xuaW1wb3J0ICcuL2RvbS00ZDM2NzY3Ny5qcyc7XG5pbXBvcnQgJy4vbG9jYWxlLTA1MGI2ZGI5LmpzJztcbmltcG9ydCAnLi9pbmRleC0wNTk1NmNhYi5qcyc7XG5pbXBvcnQgJy4vY29tbW9uRnVuY3Rpb25zLWIwODMwZTllLmpzJztcblxuY29uc3QgYXJjZ2lzU21hcnRNYXBwaW5nU2xpZGVySW5wdXRDc3MgPSBcIi5jb21ib3tkaXNwbGF5OmZsZXg7YWxpZ24taXRlbXM6Y2VudGVyO2p1c3RpZnktY29udGVudDpzcGFjZS1iZXR3ZWVuO3Bvc2l0aW9uOnJlbGF0aXZlO3dpZHRoOjEwMCV9LnNsaWRlcnt3aWR0aDo0MyU7aGVpZ2h0OjQ0cHg7YmFja2dyb3VuZC1jb2xvcjp0cmFuc3BhcmVudDtwb3NpdGlvbjpyZWxhdGl2ZTttYXJnaW46MCA0cHggMCA0cHh9LnNsaWRlciAuZXNyaS1zbGlkZXJfX2NvbnRlbnR7bWFyZ2luLWJvdHRvbToyMHB4fS5pbnB1dHt3aWR0aDo1MSV9XCI7XG5cbmNvbnN0IEFyY2dpc1NtYXJ0TWFwcGluZ1NsaWRlcklucHV0ID0gY2xhc3Mge1xuICAgIGNvbnN0cnVjdG9yKGhvc3RSZWYpIHtcbiAgICAgICAgcmVnaXN0ZXJJbnN0YW5jZSh0aGlzLCBob3N0UmVmKTtcbiAgICAgICAgdGhpcy5hcmNnaXNTbWFydE1hcHBpbmdTbGlkZXJJbnB1dENoYW5nZSA9IGNyZWF0ZUV2ZW50KHRoaXMsIFwiYXJjZ2lzU21hcnRNYXBwaW5nU2xpZGVySW5wdXRDaGFuZ2VcIiwgNyk7XG4gICAgICAgIHRoaXMuZGlzYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5taW4gPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMubWF4ID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLnZhbHVlcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5wcmVjaXNpb24gPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMucHJlZml4VGV4dCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5zdWZmaXhUZXh0ID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy9cbiAgICAvLyAgTGlmZWN5Y2xlXG4gICAgLy9cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgY29tcG9uZW50RGlkTG9hZCgpIHtcbiAgICAgICAgY29uc3QgeyBjb25maWcgfSA9IHNtYXJ0TWFwcGluZ1N0YXRlO1xuICAgICAgICB0aGlzLmhvc3RFbGVtZW50LnNoYWRvd1Jvb3QuZmlyc3RFbGVtZW50Q2hpbGQuaW5zZXJ0QWRqYWNlbnRIVE1MKFwiYmVmb3JlYmVnaW5cIiwgYDxsaW5rIHJlbD1cInN0eWxlc2hlZXRcIiBocmVmPVwiJHtjb25maWcuanNhcGlVcmx9L3RoZW1lcy9saWdodC9tYWluLmNzc1wiIC8+YCk7XG4gICAgfVxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvL1xuICAgIC8vIFJlbmRlciBNZXRob2RzXG4gICAgLy9cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgcmVuZGVyKCkge1xuICAgICAgICBjb25zdCB7IG1vZHVsZXMgfSA9IHNtYXJ0TWFwcGluZ1N0YXRlO1xuICAgICAgICBpZiAoIXRoaXMuc2xpZGVySW5wdXQpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbmZpZyA9IHtcbiAgICAgICAgICAgICAgICBtaW46IHRoaXMubWluLFxuICAgICAgICAgICAgICAgIG1heDogdGhpcy5tYXgsXG4gICAgICAgICAgICAgICAgdmFsdWVzOiB0aGlzLnZhbHVlcyxcbiAgICAgICAgICAgICAgICBwcmVjaXNpb246IHRoaXMucHJlY2lzaW9uXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5zbGlkZXJJbnB1dCA9IG5ldyBtb2R1bGVzLlNsaWRlcihjb25maWcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IGNvbmZpZyA9IHtcbiAgICAgICAgICAgICAgICBtaW46IHRoaXMubWluLFxuICAgICAgICAgICAgICAgIG1heDogdGhpcy5tYXgsXG4gICAgICAgICAgICAgICAgdmFsdWVzOiB0aGlzLnZhbHVlc1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMuc2xpZGVySW5wdXQuc2V0KGNvbmZpZyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChoKFwiZGl2XCIsIHsgY2xhc3M6IFwiY29tYm9cIiB9LCBoKFwiZGl2XCIsIHsgY2xhc3M6IFwic2xpZGVyIHNsaWRlci1ib3R0b20tbGFiZWxcIiwgcmVmOiAobm9kZSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChub2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWZ0ZXJTbGlkZXJJbnB1dENyZWF0ZShub2RlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IH0pLCBoKFwiY2FsY2l0ZS1pbnB1dC1udW1iZXJcIiwgeyBkaXNhYmxlZDogdGhpcy5kaXNhYmxlZCwgY2xhc3M6IFwiaW5wdXRcIiwgbWluOiB0aGlzLm1pbiwgbWF4OiB0aGlzLm1heCwgdmFsdWU6IGAke3RoaXMudmFsdWVzWzBdfWAsIHNjYWxlOiBcInNcIiwgcHJlZml4VGV4dDogdGhpcy5wcmVmaXhUZXh0LCBzdWZmaXhUZXh0OiB0aGlzLnN1ZmZpeFRleHQsIHN0ZXA6IGlzRGVmaW5lZCh0aGlzLnByZWNpc2lvbikgPyBNYXRoLnBvdygxMCwgLTEgKiB0aGlzLnByZWNpc2lvbikgOiAxLCBvbkNhbGNpdGVJbnB1dE51bWJlcklucHV0OiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBwYXJzZUZsb2F0KHRoaXMuc2xpZGVyVmFsdWVOb2RlLnZhbHVlKTtcbiAgICAgICAgICAgICAgICBpZiAoIXZhbHVlIHx8IHZhbHVlIDwgdGhpcy5taW4gfHwgdmFsdWUgPiB0aGlzLm1heCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNsaWRlclZhbHVlSGFuZGxlID0gc2V0VGltZW91dCgoKSA9PiB0aGlzLmhhbmRsZVNsaWRlclZhbHVlQ2hhbmdlKCksIDMwMDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuc2xpZGVyVmFsdWVIYW5kbGUpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZVNsaWRlclZhbHVlQ2hhbmdlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgcmVmOiAobm9kZSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChub2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2xpZGVyVmFsdWVOb2RlID0gbm9kZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IH0pKSk7XG4gICAgfVxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvL1xuICAgIC8vICBQcml2YXRlIG1ldGhvZHNcbiAgICAvL1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBhZnRlclNsaWRlcklucHV0Q3JlYXRlKG5vZGUpIHtcbiAgICAgICAgaWYgKCF0aGlzLnNsaWRlcklucHV0LmNvbnRhaW5lcikge1xuICAgICAgICAgICAgY29uc3QgZGl2Tm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgICAgICBub2RlLmFwcGVuZChkaXZOb2RlKTtcbiAgICAgICAgICAgIHRoaXMuc2xpZGVySW5wdXQuY29udGFpbmVyID0gZGl2Tm9kZTtcbiAgICAgICAgICAgIHRoaXMuY3JlYXRlU2xpZGVySW5wdXRDaGFuZ2VFdmVudHMoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjcmVhdGVTbGlkZXJJbnB1dENoYW5nZUV2ZW50cygpIHtcbiAgICAgICAgdGhpcy5zbGlkZXJJbnB1dC5vbihcInRodW1iLWNoYW5nZVwiLCAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZVNsaWRlcklucHV0VmFsdWVDaGFuZ2UoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc2xpZGVySW5wdXQub24oXCJ0aHVtYi1kcmFnXCIsIGRlYm91bmNlKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlU2xpZGVySW5wdXRWYWx1ZUNoYW5nZSgpO1xuICAgICAgICB9LCAxMDApKTtcbiAgICB9XG4gICAgaGFuZGxlU2xpZGVySW5wdXRWYWx1ZUNoYW5nZSgpIHtcbiAgICAgICAgdGhpcy5zbGlkZXJWYWx1ZU5vZGUudmFsdWUgPSBgJHt0aGlzLnNsaWRlcklucHV0LnZhbHVlc1swXX1gO1xuICAgICAgICB0aGlzLmFyY2dpc1NtYXJ0TWFwcGluZ1NsaWRlcklucHV0Q2hhbmdlLmVtaXQodGhpcy5zbGlkZXJJbnB1dC52YWx1ZXNbMF0pO1xuICAgIH1cbiAgICBoYW5kbGVTbGlkZXJWYWx1ZUNoYW5nZSgpIHtcbiAgICAgICAgbGV0IHZhbHVlID0gcGFyc2VGbG9hdCh0aGlzLnNsaWRlclZhbHVlTm9kZS52YWx1ZSk7XG4gICAgICAgIGlmIChpc05hTih2YWx1ZSkgfHwgdmFsdWUgPCB0aGlzLm1pbikge1xuICAgICAgICAgICAgdmFsdWUgPSB0aGlzLm1pbjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2YWx1ZSA+IHRoaXMubWF4KSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHRoaXMubWF4O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2xpZGVyVmFsdWVOb2RlLnZhbHVlID0gYCR7dmFsdWV9YDtcbiAgICAgICAgdGhpcy5zbGlkZXJJbnB1dC52YWx1ZXMgPSBbdmFsdWVdO1xuICAgICAgICB0aGlzLmFyY2dpc1NtYXJ0TWFwcGluZ1NsaWRlcklucHV0Q2hhbmdlLmVtaXQodGhpcy5zbGlkZXJJbnB1dC52YWx1ZXNbMF0pO1xuICAgIH1cbiAgICBnZXQgaG9zdEVsZW1lbnQoKSB7IHJldHVybiBnZXRFbGVtZW50KHRoaXMpOyB9XG59O1xuQXJjZ2lzU21hcnRNYXBwaW5nU2xpZGVySW5wdXQuc3R5bGUgPSBhcmNnaXNTbWFydE1hcHBpbmdTbGlkZXJJbnB1dENzcztcblxuZXhwb3J0IHsgQXJjZ2lzU21hcnRNYXBwaW5nU2xpZGVySW5wdXQgYXMgYXJjZ2lzX3NtYXJ0X21hcHBpbmdfc2xpZGVyX2lucHV0IH07XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFyY2dpcy1zbWFydC1tYXBwaW5nLXNsaWRlci1pbnB1dC5lbnRyeS5qcy5tYXAiLCIvKiFcbiAqIEFsbCBtYXRlcmlhbCBjb3B5cmlnaHQgRVNSSSwgQWxsIFJpZ2h0cyBSZXNlcnZlZCwgdW5sZXNzIG90aGVyd2lzZSBzcGVjaWZpZWQuXG4gKiB2NC4wLjU4XG4gKi9cbi8qKlxuICogQ2FsbCBhIGZ1bmN0aW9uIG9ubHkgYWZ0ZXIgaXQgaGFzIG5vdCBiZWVuIGNhbGxlZCBmb3IgbiBtaWxsaXNlY29uZHNcbiAqIEBwYXJhbSBmbiAgICAtIGZ1bmN0aW9uIHRvIGNhbGxcbiAqIEBwYXJhbSBkZWxheSAtIGRlbGF5IGluIG1pbGxpc2Vjb25kc1xuICovXG5jb25zdCBkZWJvdW5jZSA9IChmbiwgZGVsYXkpID0+IHtcbiAgICBsZXQgdGltZW91dDtcbiAgICBsZXQgc3RhdHVzID0gXCJpZGxlXCI7XG4gICAgZnVuY3Rpb24gZmx1c2goLi4uYXJncykge1xuICAgICAgICBzdGF0dXMgPSBcImZsdXNoZWRcIjtcbiAgICAgICAgcmV0dXJuIGRlYm91bmNlZCguLi5hcmdzKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaW52b2tlKC4uLmFyZ3MpIHtcbiAgICAgICAgc3RhdHVzID0gXCJpbnZva2VkXCI7XG4gICAgICAgIHJldHVybiBkZWJvdW5jZWQoLi4uYXJncyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNhbmNlbCguLi5hcmdzKSB7XG4gICAgICAgIHN0YXR1cyA9IFwiY2FuY2VsbGVkXCI7XG4gICAgICAgIHJldHVybiBkZWJvdW5jZWQoLi4uYXJncyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldFN0YXR1cygpIHtcbiAgICAgICAgcmV0dXJuIHN0YXR1cztcbiAgICB9XG4gICAgY29uc3QgZGVib3VuY2VkID0gKC4uLmFyZ3MpID0+IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgIHN3aXRjaCAoc3RhdHVzKSB7XG4gICAgICAgICAgICBjYXNlIFwiZmx1c2hlZFwiOlxuICAgICAgICAgICAgICAgIHN0YXR1cyA9IFwiaWRsZVwiO1xuICAgICAgICAgICAgICAgIGlmICh0aW1lb3V0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShmbiguLi5hcmdzKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKG51bGwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJpbnZva2VkXCI6XG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICAgICAgICAgIHN0YXR1cyA9IFwiaWRsZVwiO1xuICAgICAgICAgICAgICAgIHJlc29sdmUoZm4oLi4uYXJncykpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImNhbmNlbGxlZFwiOlxuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgICAgICAgICBzdGF0dXMgPSBcImlkbGVcIjtcbiAgICAgICAgICAgICAgICByZXNvbHZlKG51bGwpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBpZiAodGltZW91dCkge1xuICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN0YXR1cyA9IFwicGVuZGluZ1wiO1xuICAgICAgICAgICAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzID0gXCJpZGxlXCI7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKGZuKC4uLmFyZ3MpKTtcbiAgICAgICAgICAgICAgICB9LCBkZWxheSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBkZWJvdW5jZWQuZmx1c2ggPSBmbHVzaDtcbiAgICBkZWJvdW5jZWQuaW52b2tlID0gaW52b2tlO1xuICAgIGRlYm91bmNlZC5jYW5jZWwgPSBjYW5jZWw7XG4gICAgZGVib3VuY2VkLmdldFN0YXR1cyA9IGdldFN0YXR1cztcbiAgICByZXR1cm4gZGVib3VuY2VkO1xufTtcbi8qKlxuICogQ2FsbCBhIGZ1bmN0aW9uIG9ubHkgYWZ0ZXIgbiBtaWxsaXNlY29uZHMgaGF2ZSBlbGFwc2VkXG4gKiBAcGFyYW0gZm4gICAgLSBmdW5jdGlvbiB0byBjYWxsXG4gKiBAcGFyYW0gZGVsYXkgLSBkZWxheSBpbiBtaWxsaXNlY29uZHNcbiAqL1xuY29uc3QgdGhyb3R0bGUgPSAoZm4sIGRlbGF5KSA9PiB7XG4gICAgbGV0IHRpbWVvdXQ7XG4gICAgcmV0dXJuICguLi5hcmdzKSA9PiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICBpZiAodGltZW91dCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgICAgIHRpbWVvdXQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICByZXNvbHZlKGZuKC4uLmFyZ3MpKTtcbiAgICAgICAgfSwgZGVsYXkpO1xuICAgIH0pO1xufTtcbmZ1bmN0aW9uIGVzY2FwZVJlZ0V4cChzdHIpIHtcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoL1suKis/XiR7fSgpfFtcXF1cXFxcXS9nLCBcIlxcXFwkJlwiKTsgLy8gJCYgbWVhbnMgdGhlIHdob2xlIG1hdGNoZWQgc3RyaW5nXG59XG5mdW5jdGlvbiBpc0RlZmluZWQodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbDtcbn1cbi8qKlxuICogU2V0IGEgbWluaW11bSB0aW1lIGZvciBhIHByb21pc2UgdG8gcmVzb2x2ZSAodXNlZnVsIGZvciBwcmV2ZW50aW5nIGZsYXNoIG9mIGxvYWRlcnMpXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIG1pbkRlbGF5KHByb21pc2UsIG1pbkRlbGF5KSB7XG4gICAgYXdhaXQgUHJvbWlzZS5hbGwoW3Byb21pc2UsIHRpbWVvdXQobWluRGVsYXkpXSk7XG4gICAgcmV0dXJuIHByb21pc2U7XG59XG4vKipcbiAqIEhlbHBlciBtZXRob2QgdG8gaW5saW5lIHNldFRpbWVvdXQgYXMgYW4gYXdhaXQgaW4gYXN5bmMgZnVuY3Rpb25zXG4gKi9cbmZ1bmN0aW9uIHRpbWVvdXQobXMpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgbXMpKTtcbn1cbmNvbnN0IGFycmF5VG9Mb29rdXBNYXAgPSAoZGF0YUFyciwgZ2V0S2V5QW5kSXRlbSkgPT4gT2JqZWN0LmZyb21FbnRyaWVzKChkYXRhQXJyIHx8IFtdKS5tYXAoKGl0ZW0pID0+IHtcbiAgICBjb25zdCB7IGtleSwgZGF0YSB9ID0gZ2V0S2V5QW5kSXRlbShpdGVtKTtcbiAgICByZXR1cm4gW2tleSwgZGF0YV07XG59KSk7XG4vKipcbiAqIENoZWNrIHdoZXRoZXIgdHdvIGFycmF5cyBoYXZlIHRoZSBzYW1lIG51bWJlciBvZiBlbGVtZW50c1xuICogYW5kIHdoZXRoZXIgdGhleSBjb250YWluIHRoZSBzYW1lIGVsZW1lbnRzXG4gKiByZWdhcmRsZXNzIG9mIG9yZGVyXG4gKi9cbmNvbnN0IGFycmF5c0FyZUVxdWl2YWxlbnQgPSAoYXJyMSwgYXJyMikgPT4gYXJyMS5sZW5ndGggPT09IGFycjIubGVuZ3RoICYmIGFycjEucmVkdWNlKChtZW1vLCBzdHIpID0+IG1lbW8gJiYgYXJyMi5pbmRleE9mKHN0cikgPiAtMSwgdHJ1ZSk7XG5mdW5jdGlvbiB1bmlxdWVCeShteUFyciwgZ2V0SXRlbUlkKSB7XG4gICAgY29uc3QgcmVzdWx0QXJyID0gW107XG4gICAgY29uc3QgbG9va3VwTWFwID0ge307XG4gICAgbXlBcnIuZm9yRWFjaCgoaXRlbSkgPT4ge1xuICAgICAgICBjb25zdCBpZCA9IGdldEl0ZW1JZChpdGVtKTtcbiAgICAgICAgaWYgKGxvb2t1cE1hcFtpZF0gPT0gbnVsbCkge1xuICAgICAgICAgICAgbG9va3VwTWFwW2lkXSA9IGl0ZW07XG4gICAgICAgICAgICByZXN1bHRBcnIucHVzaChpdGVtKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHRBcnI7XG59XG5mdW5jdGlvbiB1bmlxdWUobXlBcnIpIHtcbiAgICBjb25zdCBwcmltaXRpdmVzID0geyBib29sZWFuOiB7fSwgbnVtYmVyOiB7fSwgc3RyaW5nOiB7fSB9O1xuICAgIGNvbnN0IG9ianMgPSBbXTtcbiAgICByZXR1cm4gbXlBcnIuZmlsdGVyKChpdGVtKSA9PiB7XG4gICAgICAgIGxldCB0eXBlID0gdHlwZW9mIGl0ZW07XG4gICAgICAgIGlmICh0eXBlIGluIHByaW1pdGl2ZXMpIHtcbiAgICAgICAgICAgIHJldHVybiBwcmltaXRpdmVzW3R5cGVdLmhhc093blByb3BlcnR5KGl0ZW0pID8gZmFsc2UgOiAocHJpbWl0aXZlc1t0eXBlXVtpdGVtXSA9IHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG9ianMuaW5kZXhPZihpdGVtKSA+PSAwID8gZmFsc2UgOiBvYmpzLnB1c2goaXRlbSk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmNvbnN0IGNodW5rID0gKGFyciwgc2l6ZSkgPT4gWy4uLkFycmF5KE1hdGguY2VpbChhcnIubGVuZ3RoIC8gc2l6ZSkpXS5tYXAoKF8sIGkpID0+IGFyci5zbGljZShzaXplICogaSwgc2l6ZSArIHNpemUgKiBpKSk7XG5cbmV4cG9ydCB7IGFycmF5VG9Mb29rdXBNYXAgYXMgYSwgdW5pcXVlIGFzIGIsIHRocm90dGxlIGFzIGMsIGRlYm91bmNlIGFzIGQsIGVzY2FwZVJlZ0V4cCBhcyBlLCBhcnJheXNBcmVFcXVpdmFsZW50IGFzIGYsIGNodW5rIGFzIGcsIGlzRGVmaW5lZCBhcyBpLCBtaW5EZWxheSBhcyBtLCB0aW1lb3V0IGFzIHQsIHVuaXF1ZUJ5IGFzIHUgfTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZnVuY3Rpb25hbC00NGRlOGZjZi5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=