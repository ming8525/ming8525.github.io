"use strict";
(self["webpackChunkexb_client"] = self["webpackChunkexb_client"] || []).push([["vendors-extensions_widgets_arcgis_analysis_node_modules_arcgis_app-components_dist_esm_raster-86525b"],{

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/raster-renderer-a62f152c.js":
/*!*********************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/raster-renderer-a62f152c.js ***!
  \*********************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   a: () => (/* binding */ applyRasterRenderer),
/* harmony export */   g: () => (/* binding */ getRasterRendererType),
/* harmony export */   n: () => (/* binding */ normalizeColorRamp)
/* harmony export */ });
/* harmony import */ var _raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./raster-unique-value-0976ec7f.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/raster-unique-value-0976ec7f.js");
/* harmony import */ var _loadModules_b4ac1247_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./loadModules-b4ac1247.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/loadModules-b4ac1247.js");
/* harmony import */ var _commonEnums_fcf13661_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./commonEnums-fcf13661.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/commonEnums-fcf13661.js");
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v4.0.58
 */




function getRasterRendererType() {
    var _a, _b;
    const { layer: smLayer } = _raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.s;
    const layer = smLayer;
    switch ((_a = layer === null || layer === void 0 ? void 0 : layer.renderer) === null || _a === void 0 ? void 0 : _a.type) {
        case "flow":
            return "raster-flow";
        case "vector-field":
            return "raster-vector-field";
        case "class-breaks":
            return "raster-class-breaks";
        case "unique-value":
            return "raster-unique-value";
        case "raster-stretch":
            return (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.k)(layer) ? "raster-rgb" : "raster-stretch";
        case "raster-shaded-relief":
            return "raster-shaded-relief";
        default:
            return (_b = layer.renderer) === null || _b === void 0 ? void 0 : _b.type;
    }
}
// TODO: add other raster renderer types
function applyRasterRenderer(renderer, layer) {
    if ("renderer" in layer) {
        layer.renderer = renderer;
    }
}
function normalizeColorRamp(colorRamp) {
    const { modules } = _raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.s;
    if (!colorRamp) {
        return [
            new modules.esriColor([0, 0, 0, 1]),
            new modules.esriColor([50, 50, 50, 1]),
            new modules.esriColor([73, 73, 73, 1]),
            new modules.esriColor([140, 140, 140, 1]),
            new modules.esriColor([255, 255, 255, 1])
        ];
    }
    if ((colorRamp === null || colorRamp === void 0 ? void 0 : colorRamp.type) !== "multipart") {
        return [colorRamp.fromColor, colorRamp.toColor];
    }
    const colorRamps = colorRamp.colorRamps;
    const colors = colorRamps.map((colorRamp) => colorRamp.fromColor);
    colors.push(colorRamps[colorRamps.length - 1].toColor);
    return colors;
}



//# sourceMappingURL=raster-renderer-a62f152c.js.map

/***/ }),

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/raster-symbolStyler-9b32ef48.js":
/*!*************************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/raster-symbolStyler-9b32ef48.js ***!
  \*************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   a: () => (/* binding */ buildSymbolStylerForRasterUniqueValuesValue),
/* harmony export */   b: () => (/* binding */ buildSymbolStylerForRasterClassBreaksValue),
/* harmony export */   c: () => (/* binding */ createColorRamp),
/* harmony export */   d: () => (/* binding */ buildSymbolStylerForRasterUniqueValuesRamp),
/* harmony export */   e: () => (/* binding */ buildSymbolStylerForRasterClassBreaksRamp),
/* harmony export */   f: () => (/* binding */ buildSymbolStylerForRasterShadedRelief),
/* harmony export */   g: () => (/* binding */ buildSymbolStylerForRasterStretch),
/* harmony export */   h: () => (/* binding */ buildSymbolStylerForRasterFlow)
/* harmony export */ });
/* harmony import */ var _raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./raster-unique-value-0976ec7f.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/raster-unique-value-0976ec7f.js");
/* harmony import */ var _loadModules_b4ac1247_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./loadModules-b4ac1247.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/loadModules-b4ac1247.js");
/* harmony import */ var _commonEnums_fcf13661_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./commonEnums-fcf13661.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/commonEnums-fcf13661.js");
/* harmony import */ var _raster_renderer_a62f152c_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./raster-renderer-a62f152c.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/raster-renderer-a62f152c.js");
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v4.0.58
 */





let lastStylerSourceId;
const defaultGeometry = "polygon";
function getAllColors() {
    const { modules } = _raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.s;
    return [
        new modules.esriColor("#ff4040"),
        new modules.esriColor("#ff8200"),
        new modules.esriColor("#faa83f"),
        new modules.esriColor("#ffd159"),
        new modules.esriColor("#74b566"),
        new modules.esriColor("#008977"),
        new modules.esriColor("#33e3c8"),
        new modules.esriColor("#43abeb"),
        new modules.esriColor("#4c64c9"),
        new modules.esriColor("#9868ed"),
        new modules.esriColor("#b155e6"),
        new modules.esriColor("#db5181"),
        new modules.esriColor("#e03b99"),
        new modules.esriColor("#2b2b2b"),
        new modules.esriColor("#bdbdbd"),
        new modules.esriColor("#ffffff")
    ];
}
async function createSymbolStylerElement(popoverNode) {
    const symbolStyler = document.createElement("arcgis-symbol-styler");
    symbolStyler.initialSourceId = lastStylerSourceId;
    symbolStyler.style = "max-height: max(calc(100vh - 200px), 300px)"; // not the best, but easiest
    symbolStyler.popoverProps = {
        placement: "bottom-end",
        offsetDistance: 10,
        offsetSkidding: _raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.s.isRTL ? 3 : -3,
        pointerDisabled: "true",
        popoverWidth: 315,
        //overlayPositioning: "fixed", -- buggy, offset issue
        refElement: await popoverNode.getPopoverRefElement()
    };
    symbolStyler.addEventListener("arcgisSymbolStylerSourceIdChange", ({ detail: activeSourceId }) => (lastStylerSourceId = activeSourceId));
    return symbolStyler;
}
function symbolStylerEdit(symbolStyler, symbol, props) {
    if (document.URL.indexOf("debug=true") > -1) {
        console.log("symbol", JSON.stringify(symbol, null, 2));
        console.log("props", JSON.stringify(Object.assign(Object.assign({}, props), { portal: "..." })));
    }
    return symbolStyler.edit(symbol, props);
}
function onStylerEditWrapper(onStylerEdit, event) {
    const { symbol, info: { marker, stroke, fill } } = event.detail;
    if (document.URL.indexOf("debug=true") > -1) {
        console.log("onStylerEdit - symbol:", JSON.stringify(symbol === null || symbol === void 0 ? void 0 : symbol.toJSON(), null, 2));
        console.log("onStylerEdit - info.marker:", JSON.stringify(marker));
        console.log("onStylerEdit - info.stroke:", JSON.stringify(stroke));
        console.log("onStylerEdit - info.fill:", JSON.stringify(fill));
    }
    onStylerEdit(event);
}
async function buildSymbolStylerForRasterFlow(options) {
    const { layer: smLayer, mapView, modules, portal, strings } = _raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.s;
    const layer = smLayer;
    const renderer = layer.renderer;
    const { onChange, popoverNode } = options;
    const colorVisVar = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.a)(renderer, "color");
    const symbolStyler = await createSymbolStylerElement(popoverNode);
    let onStylerEdit, edit;
    if (colorVisVar) {
        const currentColors = colorVisVar.stops.map((colorStop) => colorStop.color);
        const schemes = modules.colorSchemes.getSchemes({
            basemapTheme: (await modules.colorUtils.getBackgroundColorTheme(mapView)),
            geometryType: defaultGeometry,
            theme: "high-to-low"
        });
        let colorRampsAndSchemes = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.a9)(schemes, 0);
        // not sure if the check for length is really needed
        colorRampsAndSchemes = colorRampsAndSchemes.filter((obj) => { var _a; return ((_a = obj.colors) === null || _a === void 0 ? void 0 : _a.length) === colorVisVar.stops.length; });
        const colorRamps = colorRampsAndSchemes.map((obj) => {
            return {
                stops: obj.colors.reverse(),
                tags: obj.scheme.tags,
                name: obj.scheme.name
            };
        });
        onStylerEdit = ({ detail: detail }) => {
            const renderer = layer.renderer;
            const colorVisVar = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.a)(renderer, "color");
            colorVisVar.stops.reverse().forEach((stop, idx) => {
                stop.color = detail.info.fill.color[idx];
            });
            onChange();
        };
        edit = symbolStylerEdit(symbolStyler, (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.S)(layer, mapView), {
            portal,
            sections: {
                marker: {
                    parts: {
                        preview: false,
                        rotation: false,
                        size: false
                    }
                },
                fill: {
                    type: "color-ramp",
                    style: "continuous",
                    open: true,
                    //colorRampsOpen: true,
                    colorRamps
                    //transparencyOpen: true,
                }
            },
            fill: {
                color: currentColors.reverse()
            }
        });
        symbolStyler.stringOverrides = {
            fillColor: strings.styler.color,
            fillTransparency: strings.styler.transparency
        };
    }
    else {
        const suggestedFillColors = getAllColors;
        onStylerEdit = ({ detail: fill }) => {
            const renderer = layer.renderer;
            renderer.color = fill.symbol.color;
            onChange();
        };
        edit = symbolStylerEdit(symbolStyler, (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.S)(layer, mapView), {
            portal,
            sections: {
                marker: {
                    parts: {
                        preview: false,
                        rotation: false,
                        size: false
                    }
                },
                fill: {
                    type: "color",
                    optional: false,
                    open: true,
                    suggestedColorsOpen: true,
                    transparencyOpen: true,
                    suggestedColors: suggestedFillColors
                }
            },
            fill: {
                color: renderer.color || suggestedFillColors[1]
            },
            fillEnabled: true
        });
        symbolStyler.stringOverrides = {
            fillColor: strings.styler.color,
            fillTransparency: strings.styler.transparency
        };
    }
    symbolStyler.addEventListener("arcgisSymbolStylerEdit", onStylerEditWrapper.bind(null, onStylerEdit));
    popoverNode.addStyler(symbolStyler);
    await edit;
}
async function buildSymbolStylerForRasterStretch(options) {
    const { layer: smLayer, modules, strings } = _raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.s;
    const layer = smLayer;
    const renderer = layer.renderer;
    const { onChange, popoverNode } = options;
    const symbolStyler = await createSymbolStylerElement(popoverNode);
    options.defaultColors = renderer.colorRamp
        ? getColorRampColors(renderer.colorRamp).map((color) => new modules.esriColor(color))
        : null;
    const edit = symbolStyler.edit(new modules.SimpleMarkerSymbol(), getRasterSymbolStylerProps(options));
    symbolStyler.stringOverrides = {
        fillColor: strings.styler.color
    };
    const onFillChange = ({ detail: fill }) => {
        const colors = modules.esriLang.clone(fill.color);
        const renderer = layer.renderer;
        renderer.colorRamp = createColorRamp(colors.reverse());
        onChange();
    };
    symbolStyler.addEventListener("arcgisSymbolStylerFillChange", onFillChange);
    popoverNode.addStyler(symbolStyler);
    await edit;
}
async function buildSymbolStylerForRasterShadedRelief(options) {
    const { layer: smLayer, modules, strings } = _raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.s;
    const layer = smLayer;
    const renderer = layer.renderer;
    const { onChange, popoverNode } = options;
    const symbolStyler = await createSymbolStylerElement(popoverNode);
    options.defaultColors = renderer.colorRamp
        ? getColorRampColors(renderer.colorRamp).map((color) => new modules.esriColor(color))
        : null;
    const edit = symbolStyler.edit(new modules.SimpleMarkerSymbol(), getRasterSymbolStylerProps(options));
    symbolStyler.stringOverrides = {
        fillColor: strings.styler.color
    };
    const onFillChange = ({ detail: fill }) => {
        const colors = modules.esriLang.clone(fill.color);
        const renderer = layer.renderer;
        renderer.colorRamp = createColorRamp(colors.reverse());
        onChange();
    };
    symbolStyler.addEventListener("arcgisSymbolStylerFillChange", onFillChange);
    popoverNode.addStyler(symbolStyler);
    await edit;
}
async function buildSymbolStylerForRasterClassBreaksValue(options) {
    var _a;
    const { layer: smLayer, mapView, classedSymbolSelectedIdx, portal, modules, strings } = _raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.s;
    const layer = smLayer;
    const renderer = layer.renderer;
    const { onChange, popoverNode } = options;
    const rendererType = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.g)();
    // it takes the first symbol as a reference
    let symbol = ((_a = renderer.classBreakInfos) === null || _a === void 0 ? void 0 : _a.length)
        ? modules.esriLang.clone(renderer.classBreakInfos[classedSymbolSelectedIdx].symbol)
        : (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.S)(layer, mapView, rendererType);
    const fillEnabled = symbol.type === "picture-marker" ? false : !!symbol.color;
    const strokeEnabled = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.a5)(symbol);
    const suggestedFillColors = getAllColors();
    const onStylerEdit = ({ detail: { symbol } }) => {
        // ignore symbol outlines for raster-class-breaks renderers
        if (symbol.outline) {
            symbol.outline.width = 0;
        }
        const renderer = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.h)(layer);
        const infos = renderer.classBreakInfos.slice();
        const info = infos[classedSymbolSelectedIdx];
        info.symbol = symbol;
        renderer.classBreakInfos = infos;
        onChange();
    };
    let stroke;
    if (symbol.type === "simple-fill") {
        const sym = symbol;
        if (sym.outline) {
            stroke = {
                color: sym.outline.color || new modules.esriColor([0, 0, 0, 0.5]),
                size: sym.outline.width,
                style: sym.outline.style
            };
        }
    }
    const symbolStyler = await createSymbolStylerElement(popoverNode);
    const edit = symbolStylerEdit(symbolStyler, modules.esriLang.clone(symbol), {
        portal,
        sections: {
            marker: {
                parts: {
                    preview: false,
                    rotation: false,
                    size: false
                }
            },
            fill: {
                type: "color",
                open: true,
                optional: true,
                suggestedColorsOpen: true,
                transparencyOpen: (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.a6)(symbol),
                suggestedColors: suggestedFillColors,
                parts: {
                    transparency: false
                }
            }
        },
        fill: {
            color: (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.t)(symbol)
        },
        stroke,
        fillEnabled,
        strokeEnabled
    });
    symbolStyler.stringOverrides = {
        fillColor: strings.styler.color,
        fillTransparency: strings.styler.transparency
    };
    symbolStyler.addEventListener("arcgisSymbolStylerEdit", onStylerEditWrapper.bind(null, onStylerEdit));
    popoverNode.addStyler(symbolStyler);
    await edit;
}
async function buildSymbolStylerForRasterClassBreaksRamp(options) {
    var _a;
    const { layer: smLayer, modules, strings } = _raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.s;
    const layer = smLayer;
    const renderer = layer.renderer;
    const { onChange, popoverNode } = options;
    let breakColors = getBreakColors(renderer.authoringInfo.colorRamp, renderer.classBreakInfos.length).map((value) => new modules.esriColor(value.slice(1)));
    if (renderer.classBreakInfos) {
        breakColors = renderer.classBreakInfos.map((classBreakInfo) => classBreakInfo.symbol.color);
    }
    const symbolStyler = await createSymbolStylerElement(popoverNode);
    options.defaultColors = (((_a = renderer.authoringInfo) === null || _a === void 0 ? void 0 : _a.colorRamp)
        ? breakColors
        : [
            [0, 0, 255],
            [0, 255, 255],
            [255, 255, 0],
            [255, 0, 0]
        ]).map((color) => new modules.esriColor(color));
    correctTransparencyForDefaultColors(options.defaultColors);
    const edit = symbolStyler.edit(new modules.SimpleMarkerSymbol(), getRasterSymbolStylerProps(options));
    symbolStyler.stringOverrides = {
        fillColor: strings.styler.color,
        fillTransparency: strings.styler.transparency
    };
    const onFillChange = ({ detail: fill }) => {
        const colors = modules.esriLang.clone(fill.color);
        const { layer: smLayer } = _raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.s;
        const layer = smLayer;
        let renderer = layer.renderer;
        // update colors for classBreakInfos regardless
        const reversedColors = modules.esriLang.clone(colors).reverse();
        renderer.classBreakInfos.map((classBreakInfo, idx) => (classBreakInfo.symbol.color = new modules.esriColor(reversedColors[idx])));
        // update authoringInfo colorRamp only if the user has changed symbology by selecting an Esri-recommended ramp
        const matchingColorRamp = getMatchingColorRamp(colors);
        if (matchingColorRamp) {
            renderer.authoringInfo.colorRamp = matchingColorRamp;
        }
        onChange();
    };
    symbolStyler.addEventListener("arcgisSymbolStylerFillChange", onFillChange);
    popoverNode.addStyler(symbolStyler);
    await edit;
}
function getColorRampColors(colorRamp) {
    if ((colorRamp === null || colorRamp === void 0 ? void 0 : colorRamp.type) === "multipart") {
        const colorRamps = colorRamp.colorRamps;
        const colors = colorRamps.map((_colorRamp) => _colorRamp.fromColor);
        colors.push(colorRamps[colorRamps.length - 1].toColor);
        return colors;
    }
    else {
        return [colorRamp.fromColor, colorRamp.toColor];
    }
}
async function buildSymbolStylerForRasterUniqueValuesRamp(options) {
    var _a, _b, _c, _d, _e;
    const { layer: smLayer, mapView, modules } = _raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.s;
    const layer = smLayer;
    const renderer = layer.renderer;
    const { onChange, popoverNode } = options;
    const uniqueValueInfos = renderer.uniqueValueInfos;
    const symbolStyler = await createSymbolStylerElement(popoverNode);
    const schemes = modules.typeSchemes.getSchemes({
        basemap: mapView.map.basemap,
        geometryType: (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.D)(layer) || defaultGeometry
    });
    const colors = [];
    const colorRampsAndSchemes = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.a9)(schemes, Math.min(uniqueValueInfos.length, 10));
    const defaultColors = colorRampsAndSchemes[0].colors;
    colors.push(...((uniqueValueInfos === null || uniqueValueInfos === void 0 ? void 0 : uniqueValueInfos.length)
        ? renderer.uniqueValueInfos.map((uniqueValueInfo, idx) => (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.t)(uniqueValueInfo.symbol) || new modules.esriColor(defaultColors[idx % defaultColors.length]))
        : []));
    const colorRamps = colorRampsAndSchemes.map((obj) => {
        return {
            stops: obj.colors,
            tags: obj.scheme.tags,
            name: obj.scheme.name
        };
    });
    if ((!((_a = renderer.authoringInfo) === null || _a === void 0 ? void 0 : _a.colorRamp) && colors) ||
        (!isRasterColorRamp((_b = renderer.authoringInfo) === null || _b === void 0 ? void 0 : _b.colorRamp) && !isSchemeColorRamp((_c = renderer.authoringInfo) === null || _c === void 0 ? void 0 : _c.colorRamp))) {
        options.defaultColors = colors.reverse() || null;
    }
    else {
        const defaultBreakColors = getBreakColors((_d = renderer.authoringInfo) === null || _d === void 0 ? void 0 : _d.colorRamp, renderer.uniqueValueInfos.length).map((value) => value.slice(1));
        const custom = JSON.stringify(defaultBreakColors) !== JSON.stringify(colors);
        if (custom) {
            options.defaultColors = colors.reverse() || null;
        }
    }
    options.extraColorRamps = colorRamps;
    if (!options.defaultColors) {
        options.defaultColors = ((_e = renderer.authoringInfo) === null || _e === void 0 ? void 0 : _e.colorRamp)
            ? getColorRampColors(renderer.authoringInfo.colorRamp)
                .reverse()
                .map((color) => new modules.esriColor(color))
            : colors.reverse() || null;
    }
    correctTransparencyForDefaultColors(options.defaultColors);
    const edit = symbolStyler.edit(new modules.SimpleMarkerSymbol(), getRasterSymbolStylerProps(options));
    symbolStyler.stringOverrides = {
        fillColor: ""
    };
    const onFillChange = ({ detail: fill }) => {
        const colors = modules.esriLang.clone(fill.color);
        const colorRamp = createColorRamp(colors);
        const renderer = layer.renderer;
        const authoringInfo = renderer.authoringInfo || {};
        authoringInfo.colorRamp = colorRamp;
        renderer.authoringInfo = authoringInfo;
        const infoColors = getBreakColors(colorRamp, renderer.uniqueValueInfos.length).map((value) => value.slice(1));
        const newUniqueValueInfos = [];
        renderer.uniqueValueInfos.forEach((uniqueValueInfo, idx) => {
            uniqueValueInfo = uniqueValueInfo.clone();
            newUniqueValueInfos.push(uniqueValueInfo);
            (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.r)(uniqueValueInfo.symbol, new modules.esriColor(infoColors[idx]));
        });
        renderer.uniqueValueInfos = newUniqueValueInfos;
        onChange();
    };
    symbolStyler.addEventListener("arcgisSymbolStylerFillChange", onFillChange);
    popoverNode.addStyler(symbolStyler);
    await edit;
}
async function buildSymbolStylerForRasterUniqueValuesValue(options) {
    const { layer: smLayer, mapView, selectedValue, lastDefault, portal, modules } = _raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.s;
    const layer = smLayer;
    const renderer = layer.renderer;
    const rendererType = (0,_raster_renderer_a62f152c_js__WEBPACK_IMPORTED_MODULE_3__.g)();
    const { onChange, popoverNode } = options;
    const isPolygon = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.q)(layer);
    let symbol = selectedValue === -1
        ? renderer.defaultSymbol || lastDefault.defaultSymbol
        : renderer.uniqueValueInfos[selectedValue].symbol;
    if (!isSupportedSymbol(symbol)) {
        symbol = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.S)(layer, mapView, rendererType);
        if (selectedValue === -1 && !renderer.defaultSymbol) {
            lastDefault.defaultSymbol = symbol;
        }
    }
    const fillEnabled = symbol.type === "picture-marker" ? false : !!symbol.color;
    const strokeEnabled = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.a5)(symbol);
    let suggestedFillColors;
    if (selectedValue === -1) {
        suggestedFillColors = getGrayColors();
    }
    else {
        const schemes = modules.typeSchemes.getSchemes({
            basemap: mapView.map.basemap,
            geometryType: (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.D)(layer)
        });
        suggestedFillColors = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.a7)(schemes).slice(0, 16);
    }
    const onStylerEdit = ({ detail: { symbol } }) => {
        // ignore symbol outlines for raster-unique-value renderers
        if (symbol.outline) {
            symbol.outline.width = 0;
        }
        const renderer = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.h)(layer);
        if (selectedValue === -1) {
            renderer.defaultSymbol = symbol;
        }
        else {
            const infos = renderer.uniqueValueInfos.slice();
            infos[selectedValue].symbol = symbol;
            renderer.uniqueValueInfos = infos;
        }
        onChange();
    };
    let stroke;
    const sym = symbol;
    if (sym.outline) {
        stroke = {
            color: sym.outline.color ? sym.outline.color : new modules.esriColor([0, 0, 0, 0.5]),
            size: sym.outline.width,
            style: sym.outline.style,
            autoAdjusted: false
        };
    }
    else {
        stroke = {
            color: new modules.esriColor([0, 0, 0, 0.5]),
            size: 1,
            style: "solid",
            autoAdjusted: false
        };
    }
    const symbolStyler = await createSymbolStylerElement(popoverNode);
    let edit;
    edit = symbolStylerEdit(symbolStyler, modules.esriLang.clone(symbol), {
        portal,
        symbolFilter: isPolygon && !(0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.a8)() ? "simple" : undefined,
        sections: {
            marker: {
                parts: {
                    preview: false,
                    rotation: false,
                    size: false
                }
            },
            fill: {
                type: "color",
                open: true,
                optional: true,
                suggestedColorsOpen: true,
                parts: {
                    transparency: false
                }
            }
        },
        fill: {
            color: (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.t)(symbol) || adjustAlpha(suggestedFillColors[selectedValue], 0.85)
        },
        stroke,
        fillEnabled,
        strokeEnabled
    });
    symbolStyler.addEventListener("arcgisSymbolStylerEdit", onStylerEditWrapper.bind(null, onStylerEdit));
    popoverNode.addStyler(symbolStyler);
    await edit;
}
/**
 * create a colorramp from an array of colors
 */
function createColorRamp(colors) {
    const { modules } = _raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.s;
    const rampColors = [];
    for (let i = 0; i < colors.length - 1; i++) {
        rampColors[i] = new modules.AlgorithmicColorRamp({
            algorithm: "hsv",
            fromColor: colors[i],
            toColor: colors[i + 1] || new modules.esriColor({ r: 255, g: 255, b: 255, a: 1 })
        });
    }
    if (colors.length > 2) {
        const colorRamp = new modules.MultipartColorRamp({
            colorRamps: rampColors
        });
        return colorRamp;
    }
    return rampColors[0];
}
function getMatchingColorRamp(colors) {
    var _a;
    const { layer: smLayer, modules } = _raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.s;
    const layer = smLayer;
    const renderer = layer.renderer;
    const colorRamps = getRasterColorRamps();
    const clonedColorRamps = modules.esriLang.clone(colorRamps);
    clonedColorRamps.forEach((colorRamp) => {
        colorRamp.stops = getBreakColors(createColorRamp(colorRamp.stops), renderer.classBreakInfos.length)
            .map((value) => new modules.esriColor(value.slice(1)))
            .reverse();
    });
    const matchingDefaultRamps = clonedColorRamps.filter((colorRamp) => {
        const match = JSON.stringify(colorRamp.stops) === JSON.stringify(colors);
        const reversedMatch = JSON.stringify(modules.esriLang.clone(colorRamp.stops).reverse()) === JSON.stringify(colors);
        return match || reversedMatch;
    });
    if (matchingDefaultRamps.length) {
        const matchingRamp = colorRamps.filter((colorRamp) => {
            return colorRamp.name === matchingDefaultRamps[0].name;
        });
        const newAuthoringInfoColorRamp = createColorRamp((_a = matchingRamp[0]) === null || _a === void 0 ? void 0 : _a.stops);
        return newAuthoringInfoColorRamp;
    }
    else {
        return null;
    }
}
function getRasterSymbolStylerProps(options) {
    const { layer: smLayer, modules, portal } = _raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.s;
    const layer = smLayer;
    const renderer = layer.renderer;
    const { defaultColors, extraColorRamps } = options;
    const fill = {
        color: (defaultColors === null || defaultColors === void 0 ? void 0 : defaultColors.reverse()) || [new modules.esriColor([255, 255, 255, 1]), new modules.esriColor([0, 0, 0, 1])]
    };
    const stroke = {
        color: new modules.esriColor([0, 0, 0, 0.5]),
        size: 1,
        style: "solid"
    };
    // add raster color schemes
    const colorRamps = getRasterColorRamps();
    if (extraColorRamps) {
        colorRamps.push(...extraColorRamps);
    }
    colorRamps.sort((a) => (a.tags.indexOf("raster") > -1 ? -1 : 1));
    if (renderer.type === "class-breaks") {
        colorRamps.forEach((colorRamp) => {
            colorRamp.stops = getBreakColors(createColorRamp(colorRamp.stops), renderer.classBreakInfos.length)
                .map((value) => new modules.esriColor(value.slice(1)))
                .reverse();
        });
    }
    else if (renderer.type === "unique-value") {
        colorRamps.forEach((colorRamp) => colorRamp.stops.reverse());
    }
    return {
        portal,
        sections: {
            marker: {
                parts: {
                    preview: false,
                    rotation: false,
                    size: false
                }
            },
            fill: {
                type: "color-ramp",
                style: renderer.type === "class-breaks" ? "discrete" : "continuous",
                colorRamps: colorRamps,
                open: true,
                colorRampsOpen: true,
                parts: {
                    colorRamps: true,
                    transparency: layer.type === "imagery-tile"
                },
                extraParts: {
                    autoStrokeAdjust: false,
                    width: true
                }
            }
        },
        stroke: Object.assign(Object.assign({}, stroke), { color: [
                new modules.esriColor([13, 38, 68, 1]),
                new modules.esriColor([56, 98, 122, 1]),
                new modules.esriColor([98, 158, 176, 1]),
                new modules.esriColor([177, 205, 194, 1]),
                new modules.esriColor([255, 252, 212, 1])
            ] }),
        fill
    };
}
function isRasterColorRamp(colorRamp) {
    const { modules } = _raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.s;
    const rampId = modules.rasterColorRampUtils.getColorRampName(colorRamp);
    return !!rampId;
}
function getRasterColorRamps() {
    const { modules } = _raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.s;
    return modules.rasterColorRampUtils.all().map(({ name, colors }) => ({ name, stops: colors, tags: ["raster"] }));
}
function getBreakColors(ramp, breaks) {
    const { modules } = _raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.s;
    return modules.rasterColorRampUtils.convertColorRampToColormap(ramp, { numColors: breaks, interpolateAlpha: true });
}
function getGrayColors() {
    const { modules } = _raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.s;
    return [
        new modules.esriColor([255, 255, 255]),
        new modules.esriColor([178, 178, 178]),
        new modules.esriColor([128, 128, 128]),
        new modules.esriColor([92, 92, 92]),
        new modules.esriColor([77, 77, 77]),
        new modules.esriColor([51, 51, 51]),
        new modules.esriColor([26, 26, 26])
    ];
}
function adjustAlpha(color, alpha) {
    if (color) {
        color.a = alpha;
    }
    return color;
}
function isSupportedSymbol(sym) {
    return ["simple-fill", "simple-marker", "simple-line", "picture-marker", "cim"].indexOf(sym === null || sym === void 0 ? void 0 : sym.type) > -1;
}
function isSchemeColorRamp(colorRamp) {
    // all schemes are multipart; no schemes are algorithmic
    if (!(colorRamp === null || colorRamp === void 0 ? void 0 : colorRamp.colorRamps)) {
        return false;
    }
    const { layer: smLayer, mapView, modules } = _raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.s;
    const layer = smLayer;
    const renderer = layer.renderer;
    const uniqueValueInfos = renderer.uniqueValueInfos;
    const schemes = modules.typeSchemes.getSchemes({
        basemap: mapView.map.basemap,
        geometryType: (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.D)(layer) || defaultGeometry
    });
    const rampsWithSchemes = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.a9)(schemes, Math.min(uniqueValueInfos.length, 10));
    const sameLengthSchemes = rampsWithSchemes.filter((scheme) => {
        return scheme.colors.length === colorRamp.colorRamps.length + 1;
    });
    const currentScheme = [];
    currentScheme.push(colorRamp.colorRamps[0].fromColor);
    colorRamp.colorRamps.forEach((ramp) => {
        currentScheme.push(ramp.toColor);
    });
    const matchingScheme = sameLengthSchemes.filter((sameLengthScheme) => {
        const match = JSON.stringify(sameLengthScheme.colors) === JSON.stringify(currentScheme);
        const reversedMatch = JSON.stringify(modules.esriLang.clone(sameLengthScheme.colors).reverse()) === JSON.stringify(currentScheme);
        return match || reversedMatch;
    });
    return matchingScheme.length > 0;
}
function correctTransparencyForDefaultColors(defaultColors) {
    const { modules } = _raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.s;
    defaultColors === null || defaultColors === void 0 ? void 0 : defaultColors.forEach((defaultColor, idx) => {
        if (defaultColor.r === 0 && defaultColor.g === 0 && defaultColor.b === 0 && defaultColor.a === 0) {
            defaultColors[idx] = new modules.esriColor([255, 255, 255, 0]);
        }
    });
}



//# sourceMappingURL=raster-symbolStyler-9b32ef48.js.map

/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid2lkZ2V0cy9jaHVua3MvYXJjZ2lzX2FuYWx5c2lzX25vZGVfbW9kdWxlc19hcmNnaXNfYXBwLWNvbXBvbmVudHNfZGlzdF9lc21fcmFzdGVyLTg2NTI1Yi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNxRztBQUNsRTtBQUNBOztBQUVuQztBQUNBO0FBQ0EsWUFBWSxpQkFBaUIsRUFBRSwrREFBaUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixtRUFBbUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFVBQVUsRUFBRSwrREFBaUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFeUY7O0FBRXpGOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDekRBO0FBQ0E7QUFDQTtBQUNBO0FBQzRXO0FBQ3pVO0FBQ0E7QUFDd0M7O0FBRTNFO0FBQ0E7QUFDQTtBQUNBLFlBQVksVUFBVSxFQUFFLCtEQUFpQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RTtBQUN4RTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsK0RBQWlCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RUFBeUUsd0JBQXdCO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRUFBMEUsWUFBWSxlQUFlO0FBQ3JHO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxnQkFBZ0IseUJBQXlCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksb0RBQW9ELEVBQUUsK0RBQWlCO0FBQ25GO0FBQ0E7QUFDQSxZQUFZLHdCQUF3QjtBQUNwQyx3QkFBd0IsbUVBQVM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxtQ0FBbUMsb0VBQXdCO0FBQzNEO0FBQ0Esc0VBQXNFLFFBQVEseUdBQXlHO0FBQ3ZMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCwwQkFBMEIsZ0JBQWdCO0FBQzFDO0FBQ0EsZ0NBQWdDLG1FQUFTO0FBQ3pDO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLDhDQUE4QyxtRUFBZ0I7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixjQUFjO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLG1FQUFnQjtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksbUNBQW1DLEVBQUUsK0RBQWlCO0FBQ2xFO0FBQ0E7QUFDQSxZQUFZLHdCQUF3QjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGNBQWM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLG1DQUFtQyxFQUFFLCtEQUFpQjtBQUNsRTtBQUNBO0FBQ0EsWUFBWSx3QkFBd0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixjQUFjO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDhFQUE4RSxFQUFFLCtEQUFpQjtBQUM3RztBQUNBO0FBQ0EsWUFBWSx3QkFBd0I7QUFDcEMseUJBQXlCLG1FQUFlO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLFVBQVUsbUVBQWdCO0FBQzFCO0FBQ0EsMEJBQTBCLG9FQUFnQjtBQUMxQztBQUNBLDRCQUE0QixVQUFVLFVBQVU7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsbUVBQVc7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0Msb0VBQWU7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLG1CQUFtQixtRUFBYztBQUNqQyxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxtQ0FBbUMsRUFBRSwrREFBaUI7QUFDbEU7QUFDQTtBQUNBLFlBQVksd0JBQXdCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGNBQWM7QUFDMUM7QUFDQSxnQkFBZ0IsaUJBQWlCLEVBQUUsK0RBQWlCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLG1DQUFtQyxFQUFFLCtEQUFpQjtBQUNsRTtBQUNBO0FBQ0EsWUFBWSx3QkFBd0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsbUVBQWU7QUFDckMsS0FBSztBQUNMO0FBQ0EsaUNBQWlDLG9FQUF3QjtBQUN6RDtBQUNBO0FBQ0Esa0VBQWtFLG1FQUFjO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixjQUFjO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLG1FQUFnQjtBQUM1QixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksdUVBQXVFLEVBQUUsK0RBQWlCO0FBQ3RHO0FBQ0E7QUFDQSx5QkFBeUIsK0RBQXFCO0FBQzlDLFlBQVksd0JBQXdCO0FBQ3BDLHNCQUFzQixtRUFBYTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixtRUFBZ0I7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixvRUFBZ0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsbUVBQWU7QUFDekMsU0FBUztBQUNULDhCQUE4QixvRUFBYTtBQUMzQztBQUNBLDRCQUE0QixVQUFVLFVBQVU7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsbUVBQVc7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxvRUFBZ0I7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsbUJBQW1CLG1FQUFjO0FBQ2pDLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksVUFBVSxFQUFFLCtEQUFpQjtBQUN6QztBQUNBLG9CQUFvQix1QkFBdUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0EsOERBQThELDhCQUE4QjtBQUM1RixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSwwQkFBMEIsRUFBRSwrREFBaUI7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksa0NBQWtDLEVBQUUsK0RBQWlCO0FBQ2pFO0FBQ0E7QUFDQSxZQUFZLGlDQUFpQztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCw4Q0FBOEMsYUFBYTtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxVQUFVLEVBQUUsK0RBQWlCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxVQUFVLEVBQUUsK0RBQWlCO0FBQ3pDLHFEQUFxRCxjQUFjLFFBQVEsdUNBQXVDO0FBQ2xIO0FBQ0E7QUFDQSxZQUFZLFVBQVUsRUFBRSwrREFBaUI7QUFDekMsMkVBQTJFLDJDQUEyQztBQUN0SDtBQUNBO0FBQ0EsWUFBWSxVQUFVLEVBQUUsK0RBQWlCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0EsWUFBWSxtQ0FBbUMsRUFBRSwrREFBaUI7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixtRUFBZTtBQUNyQyxLQUFLO0FBQ0wsNkJBQTZCLG9FQUF3QjtBQUNyRDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFlBQVksVUFBVSxFQUFFLCtEQUFpQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFOFY7O0FBRTlWIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZXhiLWNsaWVudC8uL2V4dGVuc2lvbnMvd2lkZ2V0cy9hcmNnaXMvYW5hbHlzaXMvbm9kZV9tb2R1bGVzL0BhcmNnaXMvYXBwLWNvbXBvbmVudHMvZGlzdC9lc20vcmFzdGVyLXJlbmRlcmVyLWE2MmYxNTJjLmpzIiwid2VicGFjazovL2V4Yi1jbGllbnQvLi9leHRlbnNpb25zL3dpZGdldHMvYXJjZ2lzL2FuYWx5c2lzL25vZGVfbW9kdWxlcy9AYXJjZ2lzL2FwcC1jb21wb25lbnRzL2Rpc3QvZXNtL3Jhc3Rlci1zeW1ib2xTdHlsZXItOWIzMmVmNDguanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBBbGwgbWF0ZXJpYWwgY29weXJpZ2h0IEVTUkksIEFsbCBSaWdodHMgUmVzZXJ2ZWQsIHVubGVzcyBvdGhlcndpc2Ugc3BlY2lmaWVkLlxuICogdjQuMC41OFxuICovXG5pbXBvcnQgeyBrIGFzIGlzUmFzdGVyUkdCUmVuZGVyZXIsIHMgYXMgc21hcnRNYXBwaW5nU3RhdGUgfSBmcm9tICcuL3Jhc3Rlci11bmlxdWUtdmFsdWUtMDk3NmVjN2YuanMnO1xuaW1wb3J0ICcuL2xvYWRNb2R1bGVzLWI0YWMxMjQ3LmpzJztcbmltcG9ydCAnLi9jb21tb25FbnVtcy1mY2YxMzY2MS5qcyc7XG5cbmZ1bmN0aW9uIGdldFJhc3RlclJlbmRlcmVyVHlwZSgpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIGNvbnN0IHsgbGF5ZXI6IHNtTGF5ZXIgfSA9IHNtYXJ0TWFwcGluZ1N0YXRlO1xuICAgIGNvbnN0IGxheWVyID0gc21MYXllcjtcbiAgICBzd2l0Y2ggKChfYSA9IGxheWVyID09PSBudWxsIHx8IGxheWVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBsYXllci5yZW5kZXJlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnR5cGUpIHtcbiAgICAgICAgY2FzZSBcImZsb3dcIjpcbiAgICAgICAgICAgIHJldHVybiBcInJhc3Rlci1mbG93XCI7XG4gICAgICAgIGNhc2UgXCJ2ZWN0b3ItZmllbGRcIjpcbiAgICAgICAgICAgIHJldHVybiBcInJhc3Rlci12ZWN0b3ItZmllbGRcIjtcbiAgICAgICAgY2FzZSBcImNsYXNzLWJyZWFrc1wiOlxuICAgICAgICAgICAgcmV0dXJuIFwicmFzdGVyLWNsYXNzLWJyZWFrc1wiO1xuICAgICAgICBjYXNlIFwidW5pcXVlLXZhbHVlXCI6XG4gICAgICAgICAgICByZXR1cm4gXCJyYXN0ZXItdW5pcXVlLXZhbHVlXCI7XG4gICAgICAgIGNhc2UgXCJyYXN0ZXItc3RyZXRjaFwiOlxuICAgICAgICAgICAgcmV0dXJuIGlzUmFzdGVyUkdCUmVuZGVyZXIobGF5ZXIpID8gXCJyYXN0ZXItcmdiXCIgOiBcInJhc3Rlci1zdHJldGNoXCI7XG4gICAgICAgIGNhc2UgXCJyYXN0ZXItc2hhZGVkLXJlbGllZlwiOlxuICAgICAgICAgICAgcmV0dXJuIFwicmFzdGVyLXNoYWRlZC1yZWxpZWZcIjtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiAoX2IgPSBsYXllci5yZW5kZXJlcikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnR5cGU7XG4gICAgfVxufVxuLy8gVE9ETzogYWRkIG90aGVyIHJhc3RlciByZW5kZXJlciB0eXBlc1xuZnVuY3Rpb24gYXBwbHlSYXN0ZXJSZW5kZXJlcihyZW5kZXJlciwgbGF5ZXIpIHtcbiAgICBpZiAoXCJyZW5kZXJlclwiIGluIGxheWVyKSB7XG4gICAgICAgIGxheWVyLnJlbmRlcmVyID0gcmVuZGVyZXI7XG4gICAgfVxufVxuZnVuY3Rpb24gbm9ybWFsaXplQ29sb3JSYW1wKGNvbG9yUmFtcCkge1xuICAgIGNvbnN0IHsgbW9kdWxlcyB9ID0gc21hcnRNYXBwaW5nU3RhdGU7XG4gICAgaWYgKCFjb2xvclJhbXApIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIG5ldyBtb2R1bGVzLmVzcmlDb2xvcihbMCwgMCwgMCwgMV0pLFxuICAgICAgICAgICAgbmV3IG1vZHVsZXMuZXNyaUNvbG9yKFs1MCwgNTAsIDUwLCAxXSksXG4gICAgICAgICAgICBuZXcgbW9kdWxlcy5lc3JpQ29sb3IoWzczLCA3MywgNzMsIDFdKSxcbiAgICAgICAgICAgIG5ldyBtb2R1bGVzLmVzcmlDb2xvcihbMTQwLCAxNDAsIDE0MCwgMV0pLFxuICAgICAgICAgICAgbmV3IG1vZHVsZXMuZXNyaUNvbG9yKFsyNTUsIDI1NSwgMjU1LCAxXSlcbiAgICAgICAgXTtcbiAgICB9XG4gICAgaWYgKChjb2xvclJhbXAgPT09IG51bGwgfHwgY29sb3JSYW1wID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb2xvclJhbXAudHlwZSkgIT09IFwibXVsdGlwYXJ0XCIpIHtcbiAgICAgICAgcmV0dXJuIFtjb2xvclJhbXAuZnJvbUNvbG9yLCBjb2xvclJhbXAudG9Db2xvcl07XG4gICAgfVxuICAgIGNvbnN0IGNvbG9yUmFtcHMgPSBjb2xvclJhbXAuY29sb3JSYW1wcztcbiAgICBjb25zdCBjb2xvcnMgPSBjb2xvclJhbXBzLm1hcCgoY29sb3JSYW1wKSA9PiBjb2xvclJhbXAuZnJvbUNvbG9yKTtcbiAgICBjb2xvcnMucHVzaChjb2xvclJhbXBzW2NvbG9yUmFtcHMubGVuZ3RoIC0gMV0udG9Db2xvcik7XG4gICAgcmV0dXJuIGNvbG9ycztcbn1cblxuZXhwb3J0IHsgYXBwbHlSYXN0ZXJSZW5kZXJlciBhcyBhLCBnZXRSYXN0ZXJSZW5kZXJlclR5cGUgYXMgZywgbm9ybWFsaXplQ29sb3JSYW1wIGFzIG4gfTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmFzdGVyLXJlbmRlcmVyLWE2MmYxNTJjLmpzLm1hcCIsIi8qIVxuICogQWxsIG1hdGVyaWFsIGNvcHlyaWdodCBFU1JJLCBBbGwgUmlnaHRzIFJlc2VydmVkLCB1bmxlc3Mgb3RoZXJ3aXNlIHNwZWNpZmllZC5cbiAqIHY0LjAuNThcbiAqL1xuaW1wb3J0IHsgYSBhcyBnZXRWaXNWYXIsIFMgYXMgZ2V0RGVmYXVsdFN5bWJvbCwgZyBhcyBnZXRSZW5kZXJlclR5cGUsIGE1IGFzIGhhc1N5bWJvbE91dGxpbmUsIGE2IGFzIGlzUGljdHVyZU1hcmtlciwgdCBhcyBnZXRTeW1ib2xDb2xvciwgRCBhcyBnZXRHZW9tZXRyeVR5cGUsIHEgYXMgaXNQb2x5Z29uVHlwZSwgYTcgYXMgZ2V0RmlsbENvbG9ycywgYTggYXMgbGF5ZXJTdXBwb3J0c0NJTSwgcyBhcyBzbWFydE1hcHBpbmdTdGF0ZSwgYTkgYXMgZ2V0Q29sb3JSYW1wc1dpdGhTY2hlbWVzLCBoIGFzIGdldFJlbmRlcmVyLCByIGFzIGFwcGx5U3ltYm9sQ29sb3IgfSBmcm9tICcuL3Jhc3Rlci11bmlxdWUtdmFsdWUtMDk3NmVjN2YuanMnO1xuaW1wb3J0ICcuL2xvYWRNb2R1bGVzLWI0YWMxMjQ3LmpzJztcbmltcG9ydCAnLi9jb21tb25FbnVtcy1mY2YxMzY2MS5qcyc7XG5pbXBvcnQgeyBnIGFzIGdldFJhc3RlclJlbmRlcmVyVHlwZSB9IGZyb20gJy4vcmFzdGVyLXJlbmRlcmVyLWE2MmYxNTJjLmpzJztcblxubGV0IGxhc3RTdHlsZXJTb3VyY2VJZDtcbmNvbnN0IGRlZmF1bHRHZW9tZXRyeSA9IFwicG9seWdvblwiO1xuZnVuY3Rpb24gZ2V0QWxsQ29sb3JzKCkge1xuICAgIGNvbnN0IHsgbW9kdWxlcyB9ID0gc21hcnRNYXBwaW5nU3RhdGU7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgbmV3IG1vZHVsZXMuZXNyaUNvbG9yKFwiI2ZmNDA0MFwiKSxcbiAgICAgICAgbmV3IG1vZHVsZXMuZXNyaUNvbG9yKFwiI2ZmODIwMFwiKSxcbiAgICAgICAgbmV3IG1vZHVsZXMuZXNyaUNvbG9yKFwiI2ZhYTgzZlwiKSxcbiAgICAgICAgbmV3IG1vZHVsZXMuZXNyaUNvbG9yKFwiI2ZmZDE1OVwiKSxcbiAgICAgICAgbmV3IG1vZHVsZXMuZXNyaUNvbG9yKFwiIzc0YjU2NlwiKSxcbiAgICAgICAgbmV3IG1vZHVsZXMuZXNyaUNvbG9yKFwiIzAwODk3N1wiKSxcbiAgICAgICAgbmV3IG1vZHVsZXMuZXNyaUNvbG9yKFwiIzMzZTNjOFwiKSxcbiAgICAgICAgbmV3IG1vZHVsZXMuZXNyaUNvbG9yKFwiIzQzYWJlYlwiKSxcbiAgICAgICAgbmV3IG1vZHVsZXMuZXNyaUNvbG9yKFwiIzRjNjRjOVwiKSxcbiAgICAgICAgbmV3IG1vZHVsZXMuZXNyaUNvbG9yKFwiIzk4NjhlZFwiKSxcbiAgICAgICAgbmV3IG1vZHVsZXMuZXNyaUNvbG9yKFwiI2IxNTVlNlwiKSxcbiAgICAgICAgbmV3IG1vZHVsZXMuZXNyaUNvbG9yKFwiI2RiNTE4MVwiKSxcbiAgICAgICAgbmV3IG1vZHVsZXMuZXNyaUNvbG9yKFwiI2UwM2I5OVwiKSxcbiAgICAgICAgbmV3IG1vZHVsZXMuZXNyaUNvbG9yKFwiIzJiMmIyYlwiKSxcbiAgICAgICAgbmV3IG1vZHVsZXMuZXNyaUNvbG9yKFwiI2JkYmRiZFwiKSxcbiAgICAgICAgbmV3IG1vZHVsZXMuZXNyaUNvbG9yKFwiI2ZmZmZmZlwiKVxuICAgIF07XG59XG5hc3luYyBmdW5jdGlvbiBjcmVhdGVTeW1ib2xTdHlsZXJFbGVtZW50KHBvcG92ZXJOb2RlKSB7XG4gICAgY29uc3Qgc3ltYm9sU3R5bGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImFyY2dpcy1zeW1ib2wtc3R5bGVyXCIpO1xuICAgIHN5bWJvbFN0eWxlci5pbml0aWFsU291cmNlSWQgPSBsYXN0U3R5bGVyU291cmNlSWQ7XG4gICAgc3ltYm9sU3R5bGVyLnN0eWxlID0gXCJtYXgtaGVpZ2h0OiBtYXgoY2FsYygxMDB2aCAtIDIwMHB4KSwgMzAwcHgpXCI7IC8vIG5vdCB0aGUgYmVzdCwgYnV0IGVhc2llc3RcbiAgICBzeW1ib2xTdHlsZXIucG9wb3ZlclByb3BzID0ge1xuICAgICAgICBwbGFjZW1lbnQ6IFwiYm90dG9tLWVuZFwiLFxuICAgICAgICBvZmZzZXREaXN0YW5jZTogMTAsXG4gICAgICAgIG9mZnNldFNraWRkaW5nOiBzbWFydE1hcHBpbmdTdGF0ZS5pc1JUTCA/IDMgOiAtMyxcbiAgICAgICAgcG9pbnRlckRpc2FibGVkOiBcInRydWVcIixcbiAgICAgICAgcG9wb3ZlcldpZHRoOiAzMTUsXG4gICAgICAgIC8vb3ZlcmxheVBvc2l0aW9uaW5nOiBcImZpeGVkXCIsIC0tIGJ1Z2d5LCBvZmZzZXQgaXNzdWVcbiAgICAgICAgcmVmRWxlbWVudDogYXdhaXQgcG9wb3Zlck5vZGUuZ2V0UG9wb3ZlclJlZkVsZW1lbnQoKVxuICAgIH07XG4gICAgc3ltYm9sU3R5bGVyLmFkZEV2ZW50TGlzdGVuZXIoXCJhcmNnaXNTeW1ib2xTdHlsZXJTb3VyY2VJZENoYW5nZVwiLCAoeyBkZXRhaWw6IGFjdGl2ZVNvdXJjZUlkIH0pID0+IChsYXN0U3R5bGVyU291cmNlSWQgPSBhY3RpdmVTb3VyY2VJZCkpO1xuICAgIHJldHVybiBzeW1ib2xTdHlsZXI7XG59XG5mdW5jdGlvbiBzeW1ib2xTdHlsZXJFZGl0KHN5bWJvbFN0eWxlciwgc3ltYm9sLCBwcm9wcykge1xuICAgIGlmIChkb2N1bWVudC5VUkwuaW5kZXhPZihcImRlYnVnPXRydWVcIikgPiAtMSkge1xuICAgICAgICBjb25zb2xlLmxvZyhcInN5bWJvbFwiLCBKU09OLnN0cmluZ2lmeShzeW1ib2wsIG51bGwsIDIpKTtcbiAgICAgICAgY29uc29sZS5sb2coXCJwcm9wc1wiLCBKU09OLnN0cmluZ2lmeShPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHByb3BzKSwgeyBwb3J0YWw6IFwiLi4uXCIgfSkpKTtcbiAgICB9XG4gICAgcmV0dXJuIHN5bWJvbFN0eWxlci5lZGl0KHN5bWJvbCwgcHJvcHMpO1xufVxuZnVuY3Rpb24gb25TdHlsZXJFZGl0V3JhcHBlcihvblN0eWxlckVkaXQsIGV2ZW50KSB7XG4gICAgY29uc3QgeyBzeW1ib2wsIGluZm86IHsgbWFya2VyLCBzdHJva2UsIGZpbGwgfSB9ID0gZXZlbnQuZGV0YWlsO1xuICAgIGlmIChkb2N1bWVudC5VUkwuaW5kZXhPZihcImRlYnVnPXRydWVcIikgPiAtMSkge1xuICAgICAgICBjb25zb2xlLmxvZyhcIm9uU3R5bGVyRWRpdCAtIHN5bWJvbDpcIiwgSlNPTi5zdHJpbmdpZnkoc3ltYm9sID09PSBudWxsIHx8IHN5bWJvbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogc3ltYm9sLnRvSlNPTigpLCBudWxsLCAyKSk7XG4gICAgICAgIGNvbnNvbGUubG9nKFwib25TdHlsZXJFZGl0IC0gaW5mby5tYXJrZXI6XCIsIEpTT04uc3RyaW5naWZ5KG1hcmtlcikpO1xuICAgICAgICBjb25zb2xlLmxvZyhcIm9uU3R5bGVyRWRpdCAtIGluZm8uc3Ryb2tlOlwiLCBKU09OLnN0cmluZ2lmeShzdHJva2UpKTtcbiAgICAgICAgY29uc29sZS5sb2coXCJvblN0eWxlckVkaXQgLSBpbmZvLmZpbGw6XCIsIEpTT04uc3RyaW5naWZ5KGZpbGwpKTtcbiAgICB9XG4gICAgb25TdHlsZXJFZGl0KGV2ZW50KTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGJ1aWxkU3ltYm9sU3R5bGVyRm9yUmFzdGVyRmxvdyhvcHRpb25zKSB7XG4gICAgY29uc3QgeyBsYXllcjogc21MYXllciwgbWFwVmlldywgbW9kdWxlcywgcG9ydGFsLCBzdHJpbmdzIH0gPSBzbWFydE1hcHBpbmdTdGF0ZTtcbiAgICBjb25zdCBsYXllciA9IHNtTGF5ZXI7XG4gICAgY29uc3QgcmVuZGVyZXIgPSBsYXllci5yZW5kZXJlcjtcbiAgICBjb25zdCB7IG9uQ2hhbmdlLCBwb3BvdmVyTm9kZSB9ID0gb3B0aW9ucztcbiAgICBjb25zdCBjb2xvclZpc1ZhciA9IGdldFZpc1ZhcihyZW5kZXJlciwgXCJjb2xvclwiKTtcbiAgICBjb25zdCBzeW1ib2xTdHlsZXIgPSBhd2FpdCBjcmVhdGVTeW1ib2xTdHlsZXJFbGVtZW50KHBvcG92ZXJOb2RlKTtcbiAgICBsZXQgb25TdHlsZXJFZGl0LCBlZGl0O1xuICAgIGlmIChjb2xvclZpc1Zhcikge1xuICAgICAgICBjb25zdCBjdXJyZW50Q29sb3JzID0gY29sb3JWaXNWYXIuc3RvcHMubWFwKChjb2xvclN0b3ApID0+IGNvbG9yU3RvcC5jb2xvcik7XG4gICAgICAgIGNvbnN0IHNjaGVtZXMgPSBtb2R1bGVzLmNvbG9yU2NoZW1lcy5nZXRTY2hlbWVzKHtcbiAgICAgICAgICAgIGJhc2VtYXBUaGVtZTogKGF3YWl0IG1vZHVsZXMuY29sb3JVdGlscy5nZXRCYWNrZ3JvdW5kQ29sb3JUaGVtZShtYXBWaWV3KSksXG4gICAgICAgICAgICBnZW9tZXRyeVR5cGU6IGRlZmF1bHRHZW9tZXRyeSxcbiAgICAgICAgICAgIHRoZW1lOiBcImhpZ2gtdG8tbG93XCJcbiAgICAgICAgfSk7XG4gICAgICAgIGxldCBjb2xvclJhbXBzQW5kU2NoZW1lcyA9IGdldENvbG9yUmFtcHNXaXRoU2NoZW1lcyhzY2hlbWVzLCAwKTtcbiAgICAgICAgLy8gbm90IHN1cmUgaWYgdGhlIGNoZWNrIGZvciBsZW5ndGggaXMgcmVhbGx5IG5lZWRlZFxuICAgICAgICBjb2xvclJhbXBzQW5kU2NoZW1lcyA9IGNvbG9yUmFtcHNBbmRTY2hlbWVzLmZpbHRlcigob2JqKSA9PiB7IHZhciBfYTsgcmV0dXJuICgoX2EgPSBvYmouY29sb3JzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubGVuZ3RoKSA9PT0gY29sb3JWaXNWYXIuc3RvcHMubGVuZ3RoOyB9KTtcbiAgICAgICAgY29uc3QgY29sb3JSYW1wcyA9IGNvbG9yUmFtcHNBbmRTY2hlbWVzLm1hcCgob2JqKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHN0b3BzOiBvYmouY29sb3JzLnJldmVyc2UoKSxcbiAgICAgICAgICAgICAgICB0YWdzOiBvYmouc2NoZW1lLnRhZ3MsXG4gICAgICAgICAgICAgICAgbmFtZTogb2JqLnNjaGVtZS5uYW1lXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICAgICAgb25TdHlsZXJFZGl0ID0gKHsgZGV0YWlsOiBkZXRhaWwgfSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVuZGVyZXIgPSBsYXllci5yZW5kZXJlcjtcbiAgICAgICAgICAgIGNvbnN0IGNvbG9yVmlzVmFyID0gZ2V0VmlzVmFyKHJlbmRlcmVyLCBcImNvbG9yXCIpO1xuICAgICAgICAgICAgY29sb3JWaXNWYXIuc3RvcHMucmV2ZXJzZSgpLmZvckVhY2goKHN0b3AsIGlkeCkgPT4ge1xuICAgICAgICAgICAgICAgIHN0b3AuY29sb3IgPSBkZXRhaWwuaW5mby5maWxsLmNvbG9yW2lkeF07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIG9uQ2hhbmdlKCk7XG4gICAgICAgIH07XG4gICAgICAgIGVkaXQgPSBzeW1ib2xTdHlsZXJFZGl0KHN5bWJvbFN0eWxlciwgZ2V0RGVmYXVsdFN5bWJvbChsYXllciwgbWFwVmlldyksIHtcbiAgICAgICAgICAgIHBvcnRhbCxcbiAgICAgICAgICAgIHNlY3Rpb25zOiB7XG4gICAgICAgICAgICAgICAgbWFya2VyOiB7XG4gICAgICAgICAgICAgICAgICAgIHBhcnRzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcmV2aWV3OiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvdGF0aW9uOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpemU6IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGZpbGw6IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJjb2xvci1yYW1wXCIsXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlOiBcImNvbnRpbnVvdXNcIixcbiAgICAgICAgICAgICAgICAgICAgb3BlbjogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgLy9jb2xvclJhbXBzT3BlbjogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgY29sb3JSYW1wc1xuICAgICAgICAgICAgICAgICAgICAvL3RyYW5zcGFyZW5jeU9wZW46IHRydWUsXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZpbGw6IHtcbiAgICAgICAgICAgICAgICBjb2xvcjogY3VycmVudENvbG9ycy5yZXZlcnNlKClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHN5bWJvbFN0eWxlci5zdHJpbmdPdmVycmlkZXMgPSB7XG4gICAgICAgICAgICBmaWxsQ29sb3I6IHN0cmluZ3Muc3R5bGVyLmNvbG9yLFxuICAgICAgICAgICAgZmlsbFRyYW5zcGFyZW5jeTogc3RyaW5ncy5zdHlsZXIudHJhbnNwYXJlbmN5XG4gICAgICAgIH07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBzdWdnZXN0ZWRGaWxsQ29sb3JzID0gZ2V0QWxsQ29sb3JzO1xuICAgICAgICBvblN0eWxlckVkaXQgPSAoeyBkZXRhaWw6IGZpbGwgfSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVuZGVyZXIgPSBsYXllci5yZW5kZXJlcjtcbiAgICAgICAgICAgIHJlbmRlcmVyLmNvbG9yID0gZmlsbC5zeW1ib2wuY29sb3I7XG4gICAgICAgICAgICBvbkNoYW5nZSgpO1xuICAgICAgICB9O1xuICAgICAgICBlZGl0ID0gc3ltYm9sU3R5bGVyRWRpdChzeW1ib2xTdHlsZXIsIGdldERlZmF1bHRTeW1ib2wobGF5ZXIsIG1hcFZpZXcpLCB7XG4gICAgICAgICAgICBwb3J0YWwsXG4gICAgICAgICAgICBzZWN0aW9uczoge1xuICAgICAgICAgICAgICAgIG1hcmtlcjoge1xuICAgICAgICAgICAgICAgICAgICBwYXJ0czoge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJldmlldzogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICByb3RhdGlvbjogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBzaXplOiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBmaWxsOiB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiY29sb3JcIixcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9uYWw6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBvcGVuOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBzdWdnZXN0ZWRDb2xvcnNPcGVuOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICB0cmFuc3BhcmVuY3lPcGVuOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBzdWdnZXN0ZWRDb2xvcnM6IHN1Z2dlc3RlZEZpbGxDb2xvcnNcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZmlsbDoge1xuICAgICAgICAgICAgICAgIGNvbG9yOiByZW5kZXJlci5jb2xvciB8fCBzdWdnZXN0ZWRGaWxsQ29sb3JzWzFdXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZmlsbEVuYWJsZWQ6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIHN5bWJvbFN0eWxlci5zdHJpbmdPdmVycmlkZXMgPSB7XG4gICAgICAgICAgICBmaWxsQ29sb3I6IHN0cmluZ3Muc3R5bGVyLmNvbG9yLFxuICAgICAgICAgICAgZmlsbFRyYW5zcGFyZW5jeTogc3RyaW5ncy5zdHlsZXIudHJhbnNwYXJlbmN5XG4gICAgICAgIH07XG4gICAgfVxuICAgIHN5bWJvbFN0eWxlci5hZGRFdmVudExpc3RlbmVyKFwiYXJjZ2lzU3ltYm9sU3R5bGVyRWRpdFwiLCBvblN0eWxlckVkaXRXcmFwcGVyLmJpbmQobnVsbCwgb25TdHlsZXJFZGl0KSk7XG4gICAgcG9wb3Zlck5vZGUuYWRkU3R5bGVyKHN5bWJvbFN0eWxlcik7XG4gICAgYXdhaXQgZWRpdDtcbn1cbmFzeW5jIGZ1bmN0aW9uIGJ1aWxkU3ltYm9sU3R5bGVyRm9yUmFzdGVyU3RyZXRjaChvcHRpb25zKSB7XG4gICAgY29uc3QgeyBsYXllcjogc21MYXllciwgbW9kdWxlcywgc3RyaW5ncyB9ID0gc21hcnRNYXBwaW5nU3RhdGU7XG4gICAgY29uc3QgbGF5ZXIgPSBzbUxheWVyO1xuICAgIGNvbnN0IHJlbmRlcmVyID0gbGF5ZXIucmVuZGVyZXI7XG4gICAgY29uc3QgeyBvbkNoYW5nZSwgcG9wb3Zlck5vZGUgfSA9IG9wdGlvbnM7XG4gICAgY29uc3Qgc3ltYm9sU3R5bGVyID0gYXdhaXQgY3JlYXRlU3ltYm9sU3R5bGVyRWxlbWVudChwb3BvdmVyTm9kZSk7XG4gICAgb3B0aW9ucy5kZWZhdWx0Q29sb3JzID0gcmVuZGVyZXIuY29sb3JSYW1wXG4gICAgICAgID8gZ2V0Q29sb3JSYW1wQ29sb3JzKHJlbmRlcmVyLmNvbG9yUmFtcCkubWFwKChjb2xvcikgPT4gbmV3IG1vZHVsZXMuZXNyaUNvbG9yKGNvbG9yKSlcbiAgICAgICAgOiBudWxsO1xuICAgIGNvbnN0IGVkaXQgPSBzeW1ib2xTdHlsZXIuZWRpdChuZXcgbW9kdWxlcy5TaW1wbGVNYXJrZXJTeW1ib2woKSwgZ2V0UmFzdGVyU3ltYm9sU3R5bGVyUHJvcHMob3B0aW9ucykpO1xuICAgIHN5bWJvbFN0eWxlci5zdHJpbmdPdmVycmlkZXMgPSB7XG4gICAgICAgIGZpbGxDb2xvcjogc3RyaW5ncy5zdHlsZXIuY29sb3JcbiAgICB9O1xuICAgIGNvbnN0IG9uRmlsbENoYW5nZSA9ICh7IGRldGFpbDogZmlsbCB9KSA9PiB7XG4gICAgICAgIGNvbnN0IGNvbG9ycyA9IG1vZHVsZXMuZXNyaUxhbmcuY2xvbmUoZmlsbC5jb2xvcik7XG4gICAgICAgIGNvbnN0IHJlbmRlcmVyID0gbGF5ZXIucmVuZGVyZXI7XG4gICAgICAgIHJlbmRlcmVyLmNvbG9yUmFtcCA9IGNyZWF0ZUNvbG9yUmFtcChjb2xvcnMucmV2ZXJzZSgpKTtcbiAgICAgICAgb25DaGFuZ2UoKTtcbiAgICB9O1xuICAgIHN5bWJvbFN0eWxlci5hZGRFdmVudExpc3RlbmVyKFwiYXJjZ2lzU3ltYm9sU3R5bGVyRmlsbENoYW5nZVwiLCBvbkZpbGxDaGFuZ2UpO1xuICAgIHBvcG92ZXJOb2RlLmFkZFN0eWxlcihzeW1ib2xTdHlsZXIpO1xuICAgIGF3YWl0IGVkaXQ7XG59XG5hc3luYyBmdW5jdGlvbiBidWlsZFN5bWJvbFN0eWxlckZvclJhc3RlclNoYWRlZFJlbGllZihvcHRpb25zKSB7XG4gICAgY29uc3QgeyBsYXllcjogc21MYXllciwgbW9kdWxlcywgc3RyaW5ncyB9ID0gc21hcnRNYXBwaW5nU3RhdGU7XG4gICAgY29uc3QgbGF5ZXIgPSBzbUxheWVyO1xuICAgIGNvbnN0IHJlbmRlcmVyID0gbGF5ZXIucmVuZGVyZXI7XG4gICAgY29uc3QgeyBvbkNoYW5nZSwgcG9wb3Zlck5vZGUgfSA9IG9wdGlvbnM7XG4gICAgY29uc3Qgc3ltYm9sU3R5bGVyID0gYXdhaXQgY3JlYXRlU3ltYm9sU3R5bGVyRWxlbWVudChwb3BvdmVyTm9kZSk7XG4gICAgb3B0aW9ucy5kZWZhdWx0Q29sb3JzID0gcmVuZGVyZXIuY29sb3JSYW1wXG4gICAgICAgID8gZ2V0Q29sb3JSYW1wQ29sb3JzKHJlbmRlcmVyLmNvbG9yUmFtcCkubWFwKChjb2xvcikgPT4gbmV3IG1vZHVsZXMuZXNyaUNvbG9yKGNvbG9yKSlcbiAgICAgICAgOiBudWxsO1xuICAgIGNvbnN0IGVkaXQgPSBzeW1ib2xTdHlsZXIuZWRpdChuZXcgbW9kdWxlcy5TaW1wbGVNYXJrZXJTeW1ib2woKSwgZ2V0UmFzdGVyU3ltYm9sU3R5bGVyUHJvcHMob3B0aW9ucykpO1xuICAgIHN5bWJvbFN0eWxlci5zdHJpbmdPdmVycmlkZXMgPSB7XG4gICAgICAgIGZpbGxDb2xvcjogc3RyaW5ncy5zdHlsZXIuY29sb3JcbiAgICB9O1xuICAgIGNvbnN0IG9uRmlsbENoYW5nZSA9ICh7IGRldGFpbDogZmlsbCB9KSA9PiB7XG4gICAgICAgIGNvbnN0IGNvbG9ycyA9IG1vZHVsZXMuZXNyaUxhbmcuY2xvbmUoZmlsbC5jb2xvcik7XG4gICAgICAgIGNvbnN0IHJlbmRlcmVyID0gbGF5ZXIucmVuZGVyZXI7XG4gICAgICAgIHJlbmRlcmVyLmNvbG9yUmFtcCA9IGNyZWF0ZUNvbG9yUmFtcChjb2xvcnMucmV2ZXJzZSgpKTtcbiAgICAgICAgb25DaGFuZ2UoKTtcbiAgICB9O1xuICAgIHN5bWJvbFN0eWxlci5hZGRFdmVudExpc3RlbmVyKFwiYXJjZ2lzU3ltYm9sU3R5bGVyRmlsbENoYW5nZVwiLCBvbkZpbGxDaGFuZ2UpO1xuICAgIHBvcG92ZXJOb2RlLmFkZFN0eWxlcihzeW1ib2xTdHlsZXIpO1xuICAgIGF3YWl0IGVkaXQ7XG59XG5hc3luYyBmdW5jdGlvbiBidWlsZFN5bWJvbFN0eWxlckZvclJhc3RlckNsYXNzQnJlYWtzVmFsdWUob3B0aW9ucykge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCB7IGxheWVyOiBzbUxheWVyLCBtYXBWaWV3LCBjbGFzc2VkU3ltYm9sU2VsZWN0ZWRJZHgsIHBvcnRhbCwgbW9kdWxlcywgc3RyaW5ncyB9ID0gc21hcnRNYXBwaW5nU3RhdGU7XG4gICAgY29uc3QgbGF5ZXIgPSBzbUxheWVyO1xuICAgIGNvbnN0IHJlbmRlcmVyID0gbGF5ZXIucmVuZGVyZXI7XG4gICAgY29uc3QgeyBvbkNoYW5nZSwgcG9wb3Zlck5vZGUgfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgcmVuZGVyZXJUeXBlID0gZ2V0UmVuZGVyZXJUeXBlKCk7XG4gICAgLy8gaXQgdGFrZXMgdGhlIGZpcnN0IHN5bWJvbCBhcyBhIHJlZmVyZW5jZVxuICAgIGxldCBzeW1ib2wgPSAoKF9hID0gcmVuZGVyZXIuY2xhc3NCcmVha0luZm9zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubGVuZ3RoKVxuICAgICAgICA/IG1vZHVsZXMuZXNyaUxhbmcuY2xvbmUocmVuZGVyZXIuY2xhc3NCcmVha0luZm9zW2NsYXNzZWRTeW1ib2xTZWxlY3RlZElkeF0uc3ltYm9sKVxuICAgICAgICA6IGdldERlZmF1bHRTeW1ib2wobGF5ZXIsIG1hcFZpZXcsIHJlbmRlcmVyVHlwZSk7XG4gICAgY29uc3QgZmlsbEVuYWJsZWQgPSBzeW1ib2wudHlwZSA9PT0gXCJwaWN0dXJlLW1hcmtlclwiID8gZmFsc2UgOiAhIXN5bWJvbC5jb2xvcjtcbiAgICBjb25zdCBzdHJva2VFbmFibGVkID0gaGFzU3ltYm9sT3V0bGluZShzeW1ib2wpO1xuICAgIGNvbnN0IHN1Z2dlc3RlZEZpbGxDb2xvcnMgPSBnZXRBbGxDb2xvcnMoKTtcbiAgICBjb25zdCBvblN0eWxlckVkaXQgPSAoeyBkZXRhaWw6IHsgc3ltYm9sIH0gfSkgPT4ge1xuICAgICAgICAvLyBpZ25vcmUgc3ltYm9sIG91dGxpbmVzIGZvciByYXN0ZXItY2xhc3MtYnJlYWtzIHJlbmRlcmVyc1xuICAgICAgICBpZiAoc3ltYm9sLm91dGxpbmUpIHtcbiAgICAgICAgICAgIHN5bWJvbC5vdXRsaW5lLndpZHRoID0gMDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZW5kZXJlciA9IGdldFJlbmRlcmVyKGxheWVyKTtcbiAgICAgICAgY29uc3QgaW5mb3MgPSByZW5kZXJlci5jbGFzc0JyZWFrSW5mb3Muc2xpY2UoKTtcbiAgICAgICAgY29uc3QgaW5mbyA9IGluZm9zW2NsYXNzZWRTeW1ib2xTZWxlY3RlZElkeF07XG4gICAgICAgIGluZm8uc3ltYm9sID0gc3ltYm9sO1xuICAgICAgICByZW5kZXJlci5jbGFzc0JyZWFrSW5mb3MgPSBpbmZvcztcbiAgICAgICAgb25DaGFuZ2UoKTtcbiAgICB9O1xuICAgIGxldCBzdHJva2U7XG4gICAgaWYgKHN5bWJvbC50eXBlID09PSBcInNpbXBsZS1maWxsXCIpIHtcbiAgICAgICAgY29uc3Qgc3ltID0gc3ltYm9sO1xuICAgICAgICBpZiAoc3ltLm91dGxpbmUpIHtcbiAgICAgICAgICAgIHN0cm9rZSA9IHtcbiAgICAgICAgICAgICAgICBjb2xvcjogc3ltLm91dGxpbmUuY29sb3IgfHwgbmV3IG1vZHVsZXMuZXNyaUNvbG9yKFswLCAwLCAwLCAwLjVdKSxcbiAgICAgICAgICAgICAgICBzaXplOiBzeW0ub3V0bGluZS53aWR0aCxcbiAgICAgICAgICAgICAgICBzdHlsZTogc3ltLm91dGxpbmUuc3R5bGVcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3Qgc3ltYm9sU3R5bGVyID0gYXdhaXQgY3JlYXRlU3ltYm9sU3R5bGVyRWxlbWVudChwb3BvdmVyTm9kZSk7XG4gICAgY29uc3QgZWRpdCA9IHN5bWJvbFN0eWxlckVkaXQoc3ltYm9sU3R5bGVyLCBtb2R1bGVzLmVzcmlMYW5nLmNsb25lKHN5bWJvbCksIHtcbiAgICAgICAgcG9ydGFsLFxuICAgICAgICBzZWN0aW9uczoge1xuICAgICAgICAgICAgbWFya2VyOiB7XG4gICAgICAgICAgICAgICAgcGFydHM6IHtcbiAgICAgICAgICAgICAgICAgICAgcHJldmlldzogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIHJvdGF0aW9uOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgc2l6ZTogZmFsc2VcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZmlsbDoge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiY29sb3JcIixcbiAgICAgICAgICAgICAgICBvcGVuOiB0cnVlLFxuICAgICAgICAgICAgICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgICAgICAgICAgICAgIHN1Z2dlc3RlZENvbG9yc09wZW46IHRydWUsXG4gICAgICAgICAgICAgICAgdHJhbnNwYXJlbmN5T3BlbjogaXNQaWN0dXJlTWFya2VyKHN5bWJvbCksXG4gICAgICAgICAgICAgICAgc3VnZ2VzdGVkQ29sb3JzOiBzdWdnZXN0ZWRGaWxsQ29sb3JzLFxuICAgICAgICAgICAgICAgIHBhcnRzOiB7XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zcGFyZW5jeTogZmFsc2VcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGZpbGw6IHtcbiAgICAgICAgICAgIGNvbG9yOiBnZXRTeW1ib2xDb2xvcihzeW1ib2wpXG4gICAgICAgIH0sXG4gICAgICAgIHN0cm9rZSxcbiAgICAgICAgZmlsbEVuYWJsZWQsXG4gICAgICAgIHN0cm9rZUVuYWJsZWRcbiAgICB9KTtcbiAgICBzeW1ib2xTdHlsZXIuc3RyaW5nT3ZlcnJpZGVzID0ge1xuICAgICAgICBmaWxsQ29sb3I6IHN0cmluZ3Muc3R5bGVyLmNvbG9yLFxuICAgICAgICBmaWxsVHJhbnNwYXJlbmN5OiBzdHJpbmdzLnN0eWxlci50cmFuc3BhcmVuY3lcbiAgICB9O1xuICAgIHN5bWJvbFN0eWxlci5hZGRFdmVudExpc3RlbmVyKFwiYXJjZ2lzU3ltYm9sU3R5bGVyRWRpdFwiLCBvblN0eWxlckVkaXRXcmFwcGVyLmJpbmQobnVsbCwgb25TdHlsZXJFZGl0KSk7XG4gICAgcG9wb3Zlck5vZGUuYWRkU3R5bGVyKHN5bWJvbFN0eWxlcik7XG4gICAgYXdhaXQgZWRpdDtcbn1cbmFzeW5jIGZ1bmN0aW9uIGJ1aWxkU3ltYm9sU3R5bGVyRm9yUmFzdGVyQ2xhc3NCcmVha3NSYW1wKG9wdGlvbnMpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgeyBsYXllcjogc21MYXllciwgbW9kdWxlcywgc3RyaW5ncyB9ID0gc21hcnRNYXBwaW5nU3RhdGU7XG4gICAgY29uc3QgbGF5ZXIgPSBzbUxheWVyO1xuICAgIGNvbnN0IHJlbmRlcmVyID0gbGF5ZXIucmVuZGVyZXI7XG4gICAgY29uc3QgeyBvbkNoYW5nZSwgcG9wb3Zlck5vZGUgfSA9IG9wdGlvbnM7XG4gICAgbGV0IGJyZWFrQ29sb3JzID0gZ2V0QnJlYWtDb2xvcnMocmVuZGVyZXIuYXV0aG9yaW5nSW5mby5jb2xvclJhbXAsIHJlbmRlcmVyLmNsYXNzQnJlYWtJbmZvcy5sZW5ndGgpLm1hcCgodmFsdWUpID0+IG5ldyBtb2R1bGVzLmVzcmlDb2xvcih2YWx1ZS5zbGljZSgxKSkpO1xuICAgIGlmIChyZW5kZXJlci5jbGFzc0JyZWFrSW5mb3MpIHtcbiAgICAgICAgYnJlYWtDb2xvcnMgPSByZW5kZXJlci5jbGFzc0JyZWFrSW5mb3MubWFwKChjbGFzc0JyZWFrSW5mbykgPT4gY2xhc3NCcmVha0luZm8uc3ltYm9sLmNvbG9yKTtcbiAgICB9XG4gICAgY29uc3Qgc3ltYm9sU3R5bGVyID0gYXdhaXQgY3JlYXRlU3ltYm9sU3R5bGVyRWxlbWVudChwb3BvdmVyTm9kZSk7XG4gICAgb3B0aW9ucy5kZWZhdWx0Q29sb3JzID0gKCgoX2EgPSByZW5kZXJlci5hdXRob3JpbmdJbmZvKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY29sb3JSYW1wKVxuICAgICAgICA/IGJyZWFrQ29sb3JzXG4gICAgICAgIDogW1xuICAgICAgICAgICAgWzAsIDAsIDI1NV0sXG4gICAgICAgICAgICBbMCwgMjU1LCAyNTVdLFxuICAgICAgICAgICAgWzI1NSwgMjU1LCAwXSxcbiAgICAgICAgICAgIFsyNTUsIDAsIDBdXG4gICAgICAgIF0pLm1hcCgoY29sb3IpID0+IG5ldyBtb2R1bGVzLmVzcmlDb2xvcihjb2xvcikpO1xuICAgIGNvcnJlY3RUcmFuc3BhcmVuY3lGb3JEZWZhdWx0Q29sb3JzKG9wdGlvbnMuZGVmYXVsdENvbG9ycyk7XG4gICAgY29uc3QgZWRpdCA9IHN5bWJvbFN0eWxlci5lZGl0KG5ldyBtb2R1bGVzLlNpbXBsZU1hcmtlclN5bWJvbCgpLCBnZXRSYXN0ZXJTeW1ib2xTdHlsZXJQcm9wcyhvcHRpb25zKSk7XG4gICAgc3ltYm9sU3R5bGVyLnN0cmluZ092ZXJyaWRlcyA9IHtcbiAgICAgICAgZmlsbENvbG9yOiBzdHJpbmdzLnN0eWxlci5jb2xvcixcbiAgICAgICAgZmlsbFRyYW5zcGFyZW5jeTogc3RyaW5ncy5zdHlsZXIudHJhbnNwYXJlbmN5XG4gICAgfTtcbiAgICBjb25zdCBvbkZpbGxDaGFuZ2UgPSAoeyBkZXRhaWw6IGZpbGwgfSkgPT4ge1xuICAgICAgICBjb25zdCBjb2xvcnMgPSBtb2R1bGVzLmVzcmlMYW5nLmNsb25lKGZpbGwuY29sb3IpO1xuICAgICAgICBjb25zdCB7IGxheWVyOiBzbUxheWVyIH0gPSBzbWFydE1hcHBpbmdTdGF0ZTtcbiAgICAgICAgY29uc3QgbGF5ZXIgPSBzbUxheWVyO1xuICAgICAgICBsZXQgcmVuZGVyZXIgPSBsYXllci5yZW5kZXJlcjtcbiAgICAgICAgLy8gdXBkYXRlIGNvbG9ycyBmb3IgY2xhc3NCcmVha0luZm9zIHJlZ2FyZGxlc3NcbiAgICAgICAgY29uc3QgcmV2ZXJzZWRDb2xvcnMgPSBtb2R1bGVzLmVzcmlMYW5nLmNsb25lKGNvbG9ycykucmV2ZXJzZSgpO1xuICAgICAgICByZW5kZXJlci5jbGFzc0JyZWFrSW5mb3MubWFwKChjbGFzc0JyZWFrSW5mbywgaWR4KSA9PiAoY2xhc3NCcmVha0luZm8uc3ltYm9sLmNvbG9yID0gbmV3IG1vZHVsZXMuZXNyaUNvbG9yKHJldmVyc2VkQ29sb3JzW2lkeF0pKSk7XG4gICAgICAgIC8vIHVwZGF0ZSBhdXRob3JpbmdJbmZvIGNvbG9yUmFtcCBvbmx5IGlmIHRoZSB1c2VyIGhhcyBjaGFuZ2VkIHN5bWJvbG9neSBieSBzZWxlY3RpbmcgYW4gRXNyaS1yZWNvbW1lbmRlZCByYW1wXG4gICAgICAgIGNvbnN0IG1hdGNoaW5nQ29sb3JSYW1wID0gZ2V0TWF0Y2hpbmdDb2xvclJhbXAoY29sb3JzKTtcbiAgICAgICAgaWYgKG1hdGNoaW5nQ29sb3JSYW1wKSB7XG4gICAgICAgICAgICByZW5kZXJlci5hdXRob3JpbmdJbmZvLmNvbG9yUmFtcCA9IG1hdGNoaW5nQ29sb3JSYW1wO1xuICAgICAgICB9XG4gICAgICAgIG9uQ2hhbmdlKCk7XG4gICAgfTtcbiAgICBzeW1ib2xTdHlsZXIuYWRkRXZlbnRMaXN0ZW5lcihcImFyY2dpc1N5bWJvbFN0eWxlckZpbGxDaGFuZ2VcIiwgb25GaWxsQ2hhbmdlKTtcbiAgICBwb3BvdmVyTm9kZS5hZGRTdHlsZXIoc3ltYm9sU3R5bGVyKTtcbiAgICBhd2FpdCBlZGl0O1xufVxuZnVuY3Rpb24gZ2V0Q29sb3JSYW1wQ29sb3JzKGNvbG9yUmFtcCkge1xuICAgIGlmICgoY29sb3JSYW1wID09PSBudWxsIHx8IGNvbG9yUmFtcCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29sb3JSYW1wLnR5cGUpID09PSBcIm11bHRpcGFydFwiKSB7XG4gICAgICAgIGNvbnN0IGNvbG9yUmFtcHMgPSBjb2xvclJhbXAuY29sb3JSYW1wcztcbiAgICAgICAgY29uc3QgY29sb3JzID0gY29sb3JSYW1wcy5tYXAoKF9jb2xvclJhbXApID0+IF9jb2xvclJhbXAuZnJvbUNvbG9yKTtcbiAgICAgICAgY29sb3JzLnB1c2goY29sb3JSYW1wc1tjb2xvclJhbXBzLmxlbmd0aCAtIDFdLnRvQ29sb3IpO1xuICAgICAgICByZXR1cm4gY29sb3JzO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFtjb2xvclJhbXAuZnJvbUNvbG9yLCBjb2xvclJhbXAudG9Db2xvcl07XG4gICAgfVxufVxuYXN5bmMgZnVuY3Rpb24gYnVpbGRTeW1ib2xTdHlsZXJGb3JSYXN0ZXJVbmlxdWVWYWx1ZXNSYW1wKG9wdGlvbnMpIHtcbiAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lO1xuICAgIGNvbnN0IHsgbGF5ZXI6IHNtTGF5ZXIsIG1hcFZpZXcsIG1vZHVsZXMgfSA9IHNtYXJ0TWFwcGluZ1N0YXRlO1xuICAgIGNvbnN0IGxheWVyID0gc21MYXllcjtcbiAgICBjb25zdCByZW5kZXJlciA9IGxheWVyLnJlbmRlcmVyO1xuICAgIGNvbnN0IHsgb25DaGFuZ2UsIHBvcG92ZXJOb2RlIH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IHVuaXF1ZVZhbHVlSW5mb3MgPSByZW5kZXJlci51bmlxdWVWYWx1ZUluZm9zO1xuICAgIGNvbnN0IHN5bWJvbFN0eWxlciA9IGF3YWl0IGNyZWF0ZVN5bWJvbFN0eWxlckVsZW1lbnQocG9wb3Zlck5vZGUpO1xuICAgIGNvbnN0IHNjaGVtZXMgPSBtb2R1bGVzLnR5cGVTY2hlbWVzLmdldFNjaGVtZXMoe1xuICAgICAgICBiYXNlbWFwOiBtYXBWaWV3Lm1hcC5iYXNlbWFwLFxuICAgICAgICBnZW9tZXRyeVR5cGU6IGdldEdlb21ldHJ5VHlwZShsYXllcikgfHwgZGVmYXVsdEdlb21ldHJ5XG4gICAgfSk7XG4gICAgY29uc3QgY29sb3JzID0gW107XG4gICAgY29uc3QgY29sb3JSYW1wc0FuZFNjaGVtZXMgPSBnZXRDb2xvclJhbXBzV2l0aFNjaGVtZXMoc2NoZW1lcywgTWF0aC5taW4odW5pcXVlVmFsdWVJbmZvcy5sZW5ndGgsIDEwKSk7XG4gICAgY29uc3QgZGVmYXVsdENvbG9ycyA9IGNvbG9yUmFtcHNBbmRTY2hlbWVzWzBdLmNvbG9ycztcbiAgICBjb2xvcnMucHVzaCguLi4oKHVuaXF1ZVZhbHVlSW5mb3MgPT09IG51bGwgfHwgdW5pcXVlVmFsdWVJbmZvcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogdW5pcXVlVmFsdWVJbmZvcy5sZW5ndGgpXG4gICAgICAgID8gcmVuZGVyZXIudW5pcXVlVmFsdWVJbmZvcy5tYXAoKHVuaXF1ZVZhbHVlSW5mbywgaWR4KSA9PiBnZXRTeW1ib2xDb2xvcih1bmlxdWVWYWx1ZUluZm8uc3ltYm9sKSB8fCBuZXcgbW9kdWxlcy5lc3JpQ29sb3IoZGVmYXVsdENvbG9yc1tpZHggJSBkZWZhdWx0Q29sb3JzLmxlbmd0aF0pKVxuICAgICAgICA6IFtdKSk7XG4gICAgY29uc3QgY29sb3JSYW1wcyA9IGNvbG9yUmFtcHNBbmRTY2hlbWVzLm1hcCgob2JqKSA9PiB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdG9wczogb2JqLmNvbG9ycyxcbiAgICAgICAgICAgIHRhZ3M6IG9iai5zY2hlbWUudGFncyxcbiAgICAgICAgICAgIG5hbWU6IG9iai5zY2hlbWUubmFtZVxuICAgICAgICB9O1xuICAgIH0pO1xuICAgIGlmICgoISgoX2EgPSByZW5kZXJlci5hdXRob3JpbmdJbmZvKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY29sb3JSYW1wKSAmJiBjb2xvcnMpIHx8XG4gICAgICAgICghaXNSYXN0ZXJDb2xvclJhbXAoKF9iID0gcmVuZGVyZXIuYXV0aG9yaW5nSW5mbykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNvbG9yUmFtcCkgJiYgIWlzU2NoZW1lQ29sb3JSYW1wKChfYyA9IHJlbmRlcmVyLmF1dGhvcmluZ0luZm8pID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5jb2xvclJhbXApKSkge1xuICAgICAgICBvcHRpb25zLmRlZmF1bHRDb2xvcnMgPSBjb2xvcnMucmV2ZXJzZSgpIHx8IG51bGw7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBkZWZhdWx0QnJlYWtDb2xvcnMgPSBnZXRCcmVha0NvbG9ycygoX2QgPSByZW5kZXJlci5hdXRob3JpbmdJbmZvKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuY29sb3JSYW1wLCByZW5kZXJlci51bmlxdWVWYWx1ZUluZm9zLmxlbmd0aCkubWFwKCh2YWx1ZSkgPT4gdmFsdWUuc2xpY2UoMSkpO1xuICAgICAgICBjb25zdCBjdXN0b20gPSBKU09OLnN0cmluZ2lmeShkZWZhdWx0QnJlYWtDb2xvcnMpICE9PSBKU09OLnN0cmluZ2lmeShjb2xvcnMpO1xuICAgICAgICBpZiAoY3VzdG9tKSB7XG4gICAgICAgICAgICBvcHRpb25zLmRlZmF1bHRDb2xvcnMgPSBjb2xvcnMucmV2ZXJzZSgpIHx8IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgb3B0aW9ucy5leHRyYUNvbG9yUmFtcHMgPSBjb2xvclJhbXBzO1xuICAgIGlmICghb3B0aW9ucy5kZWZhdWx0Q29sb3JzKSB7XG4gICAgICAgIG9wdGlvbnMuZGVmYXVsdENvbG9ycyA9ICgoX2UgPSByZW5kZXJlci5hdXRob3JpbmdJbmZvKSA9PT0gbnVsbCB8fCBfZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2UuY29sb3JSYW1wKVxuICAgICAgICAgICAgPyBnZXRDb2xvclJhbXBDb2xvcnMocmVuZGVyZXIuYXV0aG9yaW5nSW5mby5jb2xvclJhbXApXG4gICAgICAgICAgICAgICAgLnJldmVyc2UoKVxuICAgICAgICAgICAgICAgIC5tYXAoKGNvbG9yKSA9PiBuZXcgbW9kdWxlcy5lc3JpQ29sb3IoY29sb3IpKVxuICAgICAgICAgICAgOiBjb2xvcnMucmV2ZXJzZSgpIHx8IG51bGw7XG4gICAgfVxuICAgIGNvcnJlY3RUcmFuc3BhcmVuY3lGb3JEZWZhdWx0Q29sb3JzKG9wdGlvbnMuZGVmYXVsdENvbG9ycyk7XG4gICAgY29uc3QgZWRpdCA9IHN5bWJvbFN0eWxlci5lZGl0KG5ldyBtb2R1bGVzLlNpbXBsZU1hcmtlclN5bWJvbCgpLCBnZXRSYXN0ZXJTeW1ib2xTdHlsZXJQcm9wcyhvcHRpb25zKSk7XG4gICAgc3ltYm9sU3R5bGVyLnN0cmluZ092ZXJyaWRlcyA9IHtcbiAgICAgICAgZmlsbENvbG9yOiBcIlwiXG4gICAgfTtcbiAgICBjb25zdCBvbkZpbGxDaGFuZ2UgPSAoeyBkZXRhaWw6IGZpbGwgfSkgPT4ge1xuICAgICAgICBjb25zdCBjb2xvcnMgPSBtb2R1bGVzLmVzcmlMYW5nLmNsb25lKGZpbGwuY29sb3IpO1xuICAgICAgICBjb25zdCBjb2xvclJhbXAgPSBjcmVhdGVDb2xvclJhbXAoY29sb3JzKTtcbiAgICAgICAgY29uc3QgcmVuZGVyZXIgPSBsYXllci5yZW5kZXJlcjtcbiAgICAgICAgY29uc3QgYXV0aG9yaW5nSW5mbyA9IHJlbmRlcmVyLmF1dGhvcmluZ0luZm8gfHwge307XG4gICAgICAgIGF1dGhvcmluZ0luZm8uY29sb3JSYW1wID0gY29sb3JSYW1wO1xuICAgICAgICByZW5kZXJlci5hdXRob3JpbmdJbmZvID0gYXV0aG9yaW5nSW5mbztcbiAgICAgICAgY29uc3QgaW5mb0NvbG9ycyA9IGdldEJyZWFrQ29sb3JzKGNvbG9yUmFtcCwgcmVuZGVyZXIudW5pcXVlVmFsdWVJbmZvcy5sZW5ndGgpLm1hcCgodmFsdWUpID0+IHZhbHVlLnNsaWNlKDEpKTtcbiAgICAgICAgY29uc3QgbmV3VW5pcXVlVmFsdWVJbmZvcyA9IFtdO1xuICAgICAgICByZW5kZXJlci51bmlxdWVWYWx1ZUluZm9zLmZvckVhY2goKHVuaXF1ZVZhbHVlSW5mbywgaWR4KSA9PiB7XG4gICAgICAgICAgICB1bmlxdWVWYWx1ZUluZm8gPSB1bmlxdWVWYWx1ZUluZm8uY2xvbmUoKTtcbiAgICAgICAgICAgIG5ld1VuaXF1ZVZhbHVlSW5mb3MucHVzaCh1bmlxdWVWYWx1ZUluZm8pO1xuICAgICAgICAgICAgYXBwbHlTeW1ib2xDb2xvcih1bmlxdWVWYWx1ZUluZm8uc3ltYm9sLCBuZXcgbW9kdWxlcy5lc3JpQ29sb3IoaW5mb0NvbG9yc1tpZHhdKSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZW5kZXJlci51bmlxdWVWYWx1ZUluZm9zID0gbmV3VW5pcXVlVmFsdWVJbmZvcztcbiAgICAgICAgb25DaGFuZ2UoKTtcbiAgICB9O1xuICAgIHN5bWJvbFN0eWxlci5hZGRFdmVudExpc3RlbmVyKFwiYXJjZ2lzU3ltYm9sU3R5bGVyRmlsbENoYW5nZVwiLCBvbkZpbGxDaGFuZ2UpO1xuICAgIHBvcG92ZXJOb2RlLmFkZFN0eWxlcihzeW1ib2xTdHlsZXIpO1xuICAgIGF3YWl0IGVkaXQ7XG59XG5hc3luYyBmdW5jdGlvbiBidWlsZFN5bWJvbFN0eWxlckZvclJhc3RlclVuaXF1ZVZhbHVlc1ZhbHVlKG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IGxheWVyOiBzbUxheWVyLCBtYXBWaWV3LCBzZWxlY3RlZFZhbHVlLCBsYXN0RGVmYXVsdCwgcG9ydGFsLCBtb2R1bGVzIH0gPSBzbWFydE1hcHBpbmdTdGF0ZTtcbiAgICBjb25zdCBsYXllciA9IHNtTGF5ZXI7XG4gICAgY29uc3QgcmVuZGVyZXIgPSBsYXllci5yZW5kZXJlcjtcbiAgICBjb25zdCByZW5kZXJlclR5cGUgPSBnZXRSYXN0ZXJSZW5kZXJlclR5cGUoKTtcbiAgICBjb25zdCB7IG9uQ2hhbmdlLCBwb3BvdmVyTm9kZSB9ID0gb3B0aW9ucztcbiAgICBjb25zdCBpc1BvbHlnb24gPSBpc1BvbHlnb25UeXBlKGxheWVyKTtcbiAgICBsZXQgc3ltYm9sID0gc2VsZWN0ZWRWYWx1ZSA9PT0gLTFcbiAgICAgICAgPyByZW5kZXJlci5kZWZhdWx0U3ltYm9sIHx8IGxhc3REZWZhdWx0LmRlZmF1bHRTeW1ib2xcbiAgICAgICAgOiByZW5kZXJlci51bmlxdWVWYWx1ZUluZm9zW3NlbGVjdGVkVmFsdWVdLnN5bWJvbDtcbiAgICBpZiAoIWlzU3VwcG9ydGVkU3ltYm9sKHN5bWJvbCkpIHtcbiAgICAgICAgc3ltYm9sID0gZ2V0RGVmYXVsdFN5bWJvbChsYXllciwgbWFwVmlldywgcmVuZGVyZXJUeXBlKTtcbiAgICAgICAgaWYgKHNlbGVjdGVkVmFsdWUgPT09IC0xICYmICFyZW5kZXJlci5kZWZhdWx0U3ltYm9sKSB7XG4gICAgICAgICAgICBsYXN0RGVmYXVsdC5kZWZhdWx0U3ltYm9sID0gc3ltYm9sO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGZpbGxFbmFibGVkID0gc3ltYm9sLnR5cGUgPT09IFwicGljdHVyZS1tYXJrZXJcIiA/IGZhbHNlIDogISFzeW1ib2wuY29sb3I7XG4gICAgY29uc3Qgc3Ryb2tlRW5hYmxlZCA9IGhhc1N5bWJvbE91dGxpbmUoc3ltYm9sKTtcbiAgICBsZXQgc3VnZ2VzdGVkRmlsbENvbG9ycztcbiAgICBpZiAoc2VsZWN0ZWRWYWx1ZSA9PT0gLTEpIHtcbiAgICAgICAgc3VnZ2VzdGVkRmlsbENvbG9ycyA9IGdldEdyYXlDb2xvcnMoKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IHNjaGVtZXMgPSBtb2R1bGVzLnR5cGVTY2hlbWVzLmdldFNjaGVtZXMoe1xuICAgICAgICAgICAgYmFzZW1hcDogbWFwVmlldy5tYXAuYmFzZW1hcCxcbiAgICAgICAgICAgIGdlb21ldHJ5VHlwZTogZ2V0R2VvbWV0cnlUeXBlKGxheWVyKVxuICAgICAgICB9KTtcbiAgICAgICAgc3VnZ2VzdGVkRmlsbENvbG9ycyA9IGdldEZpbGxDb2xvcnMoc2NoZW1lcykuc2xpY2UoMCwgMTYpO1xuICAgIH1cbiAgICBjb25zdCBvblN0eWxlckVkaXQgPSAoeyBkZXRhaWw6IHsgc3ltYm9sIH0gfSkgPT4ge1xuICAgICAgICAvLyBpZ25vcmUgc3ltYm9sIG91dGxpbmVzIGZvciByYXN0ZXItdW5pcXVlLXZhbHVlIHJlbmRlcmVyc1xuICAgICAgICBpZiAoc3ltYm9sLm91dGxpbmUpIHtcbiAgICAgICAgICAgIHN5bWJvbC5vdXRsaW5lLndpZHRoID0gMDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZW5kZXJlciA9IGdldFJlbmRlcmVyKGxheWVyKTtcbiAgICAgICAgaWYgKHNlbGVjdGVkVmFsdWUgPT09IC0xKSB7XG4gICAgICAgICAgICByZW5kZXJlci5kZWZhdWx0U3ltYm9sID0gc3ltYm9sO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgaW5mb3MgPSByZW5kZXJlci51bmlxdWVWYWx1ZUluZm9zLnNsaWNlKCk7XG4gICAgICAgICAgICBpbmZvc1tzZWxlY3RlZFZhbHVlXS5zeW1ib2wgPSBzeW1ib2w7XG4gICAgICAgICAgICByZW5kZXJlci51bmlxdWVWYWx1ZUluZm9zID0gaW5mb3M7XG4gICAgICAgIH1cbiAgICAgICAgb25DaGFuZ2UoKTtcbiAgICB9O1xuICAgIGxldCBzdHJva2U7XG4gICAgY29uc3Qgc3ltID0gc3ltYm9sO1xuICAgIGlmIChzeW0ub3V0bGluZSkge1xuICAgICAgICBzdHJva2UgPSB7XG4gICAgICAgICAgICBjb2xvcjogc3ltLm91dGxpbmUuY29sb3IgPyBzeW0ub3V0bGluZS5jb2xvciA6IG5ldyBtb2R1bGVzLmVzcmlDb2xvcihbMCwgMCwgMCwgMC41XSksXG4gICAgICAgICAgICBzaXplOiBzeW0ub3V0bGluZS53aWR0aCxcbiAgICAgICAgICAgIHN0eWxlOiBzeW0ub3V0bGluZS5zdHlsZSxcbiAgICAgICAgICAgIGF1dG9BZGp1c3RlZDogZmFsc2VcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHN0cm9rZSA9IHtcbiAgICAgICAgICAgIGNvbG9yOiBuZXcgbW9kdWxlcy5lc3JpQ29sb3IoWzAsIDAsIDAsIDAuNV0pLFxuICAgICAgICAgICAgc2l6ZTogMSxcbiAgICAgICAgICAgIHN0eWxlOiBcInNvbGlkXCIsXG4gICAgICAgICAgICBhdXRvQWRqdXN0ZWQ6IGZhbHNlXG4gICAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IHN5bWJvbFN0eWxlciA9IGF3YWl0IGNyZWF0ZVN5bWJvbFN0eWxlckVsZW1lbnQocG9wb3Zlck5vZGUpO1xuICAgIGxldCBlZGl0O1xuICAgIGVkaXQgPSBzeW1ib2xTdHlsZXJFZGl0KHN5bWJvbFN0eWxlciwgbW9kdWxlcy5lc3JpTGFuZy5jbG9uZShzeW1ib2wpLCB7XG4gICAgICAgIHBvcnRhbCxcbiAgICAgICAgc3ltYm9sRmlsdGVyOiBpc1BvbHlnb24gJiYgIWxheWVyU3VwcG9ydHNDSU0oKSA/IFwic2ltcGxlXCIgOiB1bmRlZmluZWQsXG4gICAgICAgIHNlY3Rpb25zOiB7XG4gICAgICAgICAgICBtYXJrZXI6IHtcbiAgICAgICAgICAgICAgICBwYXJ0czoge1xuICAgICAgICAgICAgICAgICAgICBwcmV2aWV3OiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgcm90YXRpb246IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBzaXplOiBmYWxzZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmaWxsOiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJjb2xvclwiLFxuICAgICAgICAgICAgICAgIG9wZW46IHRydWUsXG4gICAgICAgICAgICAgICAgb3B0aW9uYWw6IHRydWUsXG4gICAgICAgICAgICAgICAgc3VnZ2VzdGVkQ29sb3JzT3BlbjogdHJ1ZSxcbiAgICAgICAgICAgICAgICBwYXJ0czoge1xuICAgICAgICAgICAgICAgICAgICB0cmFuc3BhcmVuY3k6IGZhbHNlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBmaWxsOiB7XG4gICAgICAgICAgICBjb2xvcjogZ2V0U3ltYm9sQ29sb3Ioc3ltYm9sKSB8fCBhZGp1c3RBbHBoYShzdWdnZXN0ZWRGaWxsQ29sb3JzW3NlbGVjdGVkVmFsdWVdLCAwLjg1KVxuICAgICAgICB9LFxuICAgICAgICBzdHJva2UsXG4gICAgICAgIGZpbGxFbmFibGVkLFxuICAgICAgICBzdHJva2VFbmFibGVkXG4gICAgfSk7XG4gICAgc3ltYm9sU3R5bGVyLmFkZEV2ZW50TGlzdGVuZXIoXCJhcmNnaXNTeW1ib2xTdHlsZXJFZGl0XCIsIG9uU3R5bGVyRWRpdFdyYXBwZXIuYmluZChudWxsLCBvblN0eWxlckVkaXQpKTtcbiAgICBwb3BvdmVyTm9kZS5hZGRTdHlsZXIoc3ltYm9sU3R5bGVyKTtcbiAgICBhd2FpdCBlZGl0O1xufVxuLyoqXG4gKiBjcmVhdGUgYSBjb2xvcnJhbXAgZnJvbSBhbiBhcnJheSBvZiBjb2xvcnNcbiAqL1xuZnVuY3Rpb24gY3JlYXRlQ29sb3JSYW1wKGNvbG9ycykge1xuICAgIGNvbnN0IHsgbW9kdWxlcyB9ID0gc21hcnRNYXBwaW5nU3RhdGU7XG4gICAgY29uc3QgcmFtcENvbG9ycyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29sb3JzLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICByYW1wQ29sb3JzW2ldID0gbmV3IG1vZHVsZXMuQWxnb3JpdGhtaWNDb2xvclJhbXAoe1xuICAgICAgICAgICAgYWxnb3JpdGhtOiBcImhzdlwiLFxuICAgICAgICAgICAgZnJvbUNvbG9yOiBjb2xvcnNbaV0sXG4gICAgICAgICAgICB0b0NvbG9yOiBjb2xvcnNbaSArIDFdIHx8IG5ldyBtb2R1bGVzLmVzcmlDb2xvcih7IHI6IDI1NSwgZzogMjU1LCBiOiAyNTUsIGE6IDEgfSlcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChjb2xvcnMubGVuZ3RoID4gMikge1xuICAgICAgICBjb25zdCBjb2xvclJhbXAgPSBuZXcgbW9kdWxlcy5NdWx0aXBhcnRDb2xvclJhbXAoe1xuICAgICAgICAgICAgY29sb3JSYW1wczogcmFtcENvbG9yc1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGNvbG9yUmFtcDtcbiAgICB9XG4gICAgcmV0dXJuIHJhbXBDb2xvcnNbMF07XG59XG5mdW5jdGlvbiBnZXRNYXRjaGluZ0NvbG9yUmFtcChjb2xvcnMpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgeyBsYXllcjogc21MYXllciwgbW9kdWxlcyB9ID0gc21hcnRNYXBwaW5nU3RhdGU7XG4gICAgY29uc3QgbGF5ZXIgPSBzbUxheWVyO1xuICAgIGNvbnN0IHJlbmRlcmVyID0gbGF5ZXIucmVuZGVyZXI7XG4gICAgY29uc3QgY29sb3JSYW1wcyA9IGdldFJhc3RlckNvbG9yUmFtcHMoKTtcbiAgICBjb25zdCBjbG9uZWRDb2xvclJhbXBzID0gbW9kdWxlcy5lc3JpTGFuZy5jbG9uZShjb2xvclJhbXBzKTtcbiAgICBjbG9uZWRDb2xvclJhbXBzLmZvckVhY2goKGNvbG9yUmFtcCkgPT4ge1xuICAgICAgICBjb2xvclJhbXAuc3RvcHMgPSBnZXRCcmVha0NvbG9ycyhjcmVhdGVDb2xvclJhbXAoY29sb3JSYW1wLnN0b3BzKSwgcmVuZGVyZXIuY2xhc3NCcmVha0luZm9zLmxlbmd0aClcbiAgICAgICAgICAgIC5tYXAoKHZhbHVlKSA9PiBuZXcgbW9kdWxlcy5lc3JpQ29sb3IodmFsdWUuc2xpY2UoMSkpKVxuICAgICAgICAgICAgLnJldmVyc2UoKTtcbiAgICB9KTtcbiAgICBjb25zdCBtYXRjaGluZ0RlZmF1bHRSYW1wcyA9IGNsb25lZENvbG9yUmFtcHMuZmlsdGVyKChjb2xvclJhbXApID0+IHtcbiAgICAgICAgY29uc3QgbWF0Y2ggPSBKU09OLnN0cmluZ2lmeShjb2xvclJhbXAuc3RvcHMpID09PSBKU09OLnN0cmluZ2lmeShjb2xvcnMpO1xuICAgICAgICBjb25zdCByZXZlcnNlZE1hdGNoID0gSlNPTi5zdHJpbmdpZnkobW9kdWxlcy5lc3JpTGFuZy5jbG9uZShjb2xvclJhbXAuc3RvcHMpLnJldmVyc2UoKSkgPT09IEpTT04uc3RyaW5naWZ5KGNvbG9ycyk7XG4gICAgICAgIHJldHVybiBtYXRjaCB8fCByZXZlcnNlZE1hdGNoO1xuICAgIH0pO1xuICAgIGlmIChtYXRjaGluZ0RlZmF1bHRSYW1wcy5sZW5ndGgpIHtcbiAgICAgICAgY29uc3QgbWF0Y2hpbmdSYW1wID0gY29sb3JSYW1wcy5maWx0ZXIoKGNvbG9yUmFtcCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGNvbG9yUmFtcC5uYW1lID09PSBtYXRjaGluZ0RlZmF1bHRSYW1wc1swXS5uYW1lO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgbmV3QXV0aG9yaW5nSW5mb0NvbG9yUmFtcCA9IGNyZWF0ZUNvbG9yUmFtcCgoX2EgPSBtYXRjaGluZ1JhbXBbMF0pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zdG9wcyk7XG4gICAgICAgIHJldHVybiBuZXdBdXRob3JpbmdJbmZvQ29sb3JSYW1wO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0UmFzdGVyU3ltYm9sU3R5bGVyUHJvcHMob3B0aW9ucykge1xuICAgIGNvbnN0IHsgbGF5ZXI6IHNtTGF5ZXIsIG1vZHVsZXMsIHBvcnRhbCB9ID0gc21hcnRNYXBwaW5nU3RhdGU7XG4gICAgY29uc3QgbGF5ZXIgPSBzbUxheWVyO1xuICAgIGNvbnN0IHJlbmRlcmVyID0gbGF5ZXIucmVuZGVyZXI7XG4gICAgY29uc3QgeyBkZWZhdWx0Q29sb3JzLCBleHRyYUNvbG9yUmFtcHMgfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgZmlsbCA9IHtcbiAgICAgICAgY29sb3I6IChkZWZhdWx0Q29sb3JzID09PSBudWxsIHx8IGRlZmF1bHRDb2xvcnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRlZmF1bHRDb2xvcnMucmV2ZXJzZSgpKSB8fCBbbmV3IG1vZHVsZXMuZXNyaUNvbG9yKFsyNTUsIDI1NSwgMjU1LCAxXSksIG5ldyBtb2R1bGVzLmVzcmlDb2xvcihbMCwgMCwgMCwgMV0pXVxuICAgIH07XG4gICAgY29uc3Qgc3Ryb2tlID0ge1xuICAgICAgICBjb2xvcjogbmV3IG1vZHVsZXMuZXNyaUNvbG9yKFswLCAwLCAwLCAwLjVdKSxcbiAgICAgICAgc2l6ZTogMSxcbiAgICAgICAgc3R5bGU6IFwic29saWRcIlxuICAgIH07XG4gICAgLy8gYWRkIHJhc3RlciBjb2xvciBzY2hlbWVzXG4gICAgY29uc3QgY29sb3JSYW1wcyA9IGdldFJhc3RlckNvbG9yUmFtcHMoKTtcbiAgICBpZiAoZXh0cmFDb2xvclJhbXBzKSB7XG4gICAgICAgIGNvbG9yUmFtcHMucHVzaCguLi5leHRyYUNvbG9yUmFtcHMpO1xuICAgIH1cbiAgICBjb2xvclJhbXBzLnNvcnQoKGEpID0+IChhLnRhZ3MuaW5kZXhPZihcInJhc3RlclwiKSA+IC0xID8gLTEgOiAxKSk7XG4gICAgaWYgKHJlbmRlcmVyLnR5cGUgPT09IFwiY2xhc3MtYnJlYWtzXCIpIHtcbiAgICAgICAgY29sb3JSYW1wcy5mb3JFYWNoKChjb2xvclJhbXApID0+IHtcbiAgICAgICAgICAgIGNvbG9yUmFtcC5zdG9wcyA9IGdldEJyZWFrQ29sb3JzKGNyZWF0ZUNvbG9yUmFtcChjb2xvclJhbXAuc3RvcHMpLCByZW5kZXJlci5jbGFzc0JyZWFrSW5mb3MubGVuZ3RoKVxuICAgICAgICAgICAgICAgIC5tYXAoKHZhbHVlKSA9PiBuZXcgbW9kdWxlcy5lc3JpQ29sb3IodmFsdWUuc2xpY2UoMSkpKVxuICAgICAgICAgICAgICAgIC5yZXZlcnNlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIGlmIChyZW5kZXJlci50eXBlID09PSBcInVuaXF1ZS12YWx1ZVwiKSB7XG4gICAgICAgIGNvbG9yUmFtcHMuZm9yRWFjaCgoY29sb3JSYW1wKSA9PiBjb2xvclJhbXAuc3RvcHMucmV2ZXJzZSgpKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcG9ydGFsLFxuICAgICAgICBzZWN0aW9uczoge1xuICAgICAgICAgICAgbWFya2VyOiB7XG4gICAgICAgICAgICAgICAgcGFydHM6IHtcbiAgICAgICAgICAgICAgICAgICAgcHJldmlldzogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIHJvdGF0aW9uOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgc2l6ZTogZmFsc2VcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZmlsbDoge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiY29sb3ItcmFtcFwiLFxuICAgICAgICAgICAgICAgIHN0eWxlOiByZW5kZXJlci50eXBlID09PSBcImNsYXNzLWJyZWFrc1wiID8gXCJkaXNjcmV0ZVwiIDogXCJjb250aW51b3VzXCIsXG4gICAgICAgICAgICAgICAgY29sb3JSYW1wczogY29sb3JSYW1wcyxcbiAgICAgICAgICAgICAgICBvcGVuOiB0cnVlLFxuICAgICAgICAgICAgICAgIGNvbG9yUmFtcHNPcGVuOiB0cnVlLFxuICAgICAgICAgICAgICAgIHBhcnRzOiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbG9yUmFtcHM6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zcGFyZW5jeTogbGF5ZXIudHlwZSA9PT0gXCJpbWFnZXJ5LXRpbGVcIlxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZXh0cmFQYXJ0czoge1xuICAgICAgICAgICAgICAgICAgICBhdXRvU3Ryb2tlQWRqdXN0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IHRydWVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHN0cm9rZTogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBzdHJva2UpLCB7IGNvbG9yOiBbXG4gICAgICAgICAgICAgICAgbmV3IG1vZHVsZXMuZXNyaUNvbG9yKFsxMywgMzgsIDY4LCAxXSksXG4gICAgICAgICAgICAgICAgbmV3IG1vZHVsZXMuZXNyaUNvbG9yKFs1NiwgOTgsIDEyMiwgMV0pLFxuICAgICAgICAgICAgICAgIG5ldyBtb2R1bGVzLmVzcmlDb2xvcihbOTgsIDE1OCwgMTc2LCAxXSksXG4gICAgICAgICAgICAgICAgbmV3IG1vZHVsZXMuZXNyaUNvbG9yKFsxNzcsIDIwNSwgMTk0LCAxXSksXG4gICAgICAgICAgICAgICAgbmV3IG1vZHVsZXMuZXNyaUNvbG9yKFsyNTUsIDI1MiwgMjEyLCAxXSlcbiAgICAgICAgICAgIF0gfSksXG4gICAgICAgIGZpbGxcbiAgICB9O1xufVxuZnVuY3Rpb24gaXNSYXN0ZXJDb2xvclJhbXAoY29sb3JSYW1wKSB7XG4gICAgY29uc3QgeyBtb2R1bGVzIH0gPSBzbWFydE1hcHBpbmdTdGF0ZTtcbiAgICBjb25zdCByYW1wSWQgPSBtb2R1bGVzLnJhc3RlckNvbG9yUmFtcFV0aWxzLmdldENvbG9yUmFtcE5hbWUoY29sb3JSYW1wKTtcbiAgICByZXR1cm4gISFyYW1wSWQ7XG59XG5mdW5jdGlvbiBnZXRSYXN0ZXJDb2xvclJhbXBzKCkge1xuICAgIGNvbnN0IHsgbW9kdWxlcyB9ID0gc21hcnRNYXBwaW5nU3RhdGU7XG4gICAgcmV0dXJuIG1vZHVsZXMucmFzdGVyQ29sb3JSYW1wVXRpbHMuYWxsKCkubWFwKCh7IG5hbWUsIGNvbG9ycyB9KSA9PiAoeyBuYW1lLCBzdG9wczogY29sb3JzLCB0YWdzOiBbXCJyYXN0ZXJcIl0gfSkpO1xufVxuZnVuY3Rpb24gZ2V0QnJlYWtDb2xvcnMocmFtcCwgYnJlYWtzKSB7XG4gICAgY29uc3QgeyBtb2R1bGVzIH0gPSBzbWFydE1hcHBpbmdTdGF0ZTtcbiAgICByZXR1cm4gbW9kdWxlcy5yYXN0ZXJDb2xvclJhbXBVdGlscy5jb252ZXJ0Q29sb3JSYW1wVG9Db2xvcm1hcChyYW1wLCB7IG51bUNvbG9yczogYnJlYWtzLCBpbnRlcnBvbGF0ZUFscGhhOiB0cnVlIH0pO1xufVxuZnVuY3Rpb24gZ2V0R3JheUNvbG9ycygpIHtcbiAgICBjb25zdCB7IG1vZHVsZXMgfSA9IHNtYXJ0TWFwcGluZ1N0YXRlO1xuICAgIHJldHVybiBbXG4gICAgICAgIG5ldyBtb2R1bGVzLmVzcmlDb2xvcihbMjU1LCAyNTUsIDI1NV0pLFxuICAgICAgICBuZXcgbW9kdWxlcy5lc3JpQ29sb3IoWzE3OCwgMTc4LCAxNzhdKSxcbiAgICAgICAgbmV3IG1vZHVsZXMuZXNyaUNvbG9yKFsxMjgsIDEyOCwgMTI4XSksXG4gICAgICAgIG5ldyBtb2R1bGVzLmVzcmlDb2xvcihbOTIsIDkyLCA5Ml0pLFxuICAgICAgICBuZXcgbW9kdWxlcy5lc3JpQ29sb3IoWzc3LCA3NywgNzddKSxcbiAgICAgICAgbmV3IG1vZHVsZXMuZXNyaUNvbG9yKFs1MSwgNTEsIDUxXSksXG4gICAgICAgIG5ldyBtb2R1bGVzLmVzcmlDb2xvcihbMjYsIDI2LCAyNl0pXG4gICAgXTtcbn1cbmZ1bmN0aW9uIGFkanVzdEFscGhhKGNvbG9yLCBhbHBoYSkge1xuICAgIGlmIChjb2xvcikge1xuICAgICAgICBjb2xvci5hID0gYWxwaGE7XG4gICAgfVxuICAgIHJldHVybiBjb2xvcjtcbn1cbmZ1bmN0aW9uIGlzU3VwcG9ydGVkU3ltYm9sKHN5bSkge1xuICAgIHJldHVybiBbXCJzaW1wbGUtZmlsbFwiLCBcInNpbXBsZS1tYXJrZXJcIiwgXCJzaW1wbGUtbGluZVwiLCBcInBpY3R1cmUtbWFya2VyXCIsIFwiY2ltXCJdLmluZGV4T2Yoc3ltID09PSBudWxsIHx8IHN5bSA9PT0gdm9pZCAwID8gdm9pZCAwIDogc3ltLnR5cGUpID4gLTE7XG59XG5mdW5jdGlvbiBpc1NjaGVtZUNvbG9yUmFtcChjb2xvclJhbXApIHtcbiAgICAvLyBhbGwgc2NoZW1lcyBhcmUgbXVsdGlwYXJ0OyBubyBzY2hlbWVzIGFyZSBhbGdvcml0aG1pY1xuICAgIGlmICghKGNvbG9yUmFtcCA9PT0gbnVsbCB8fCBjb2xvclJhbXAgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbG9yUmFtcC5jb2xvclJhbXBzKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IHsgbGF5ZXI6IHNtTGF5ZXIsIG1hcFZpZXcsIG1vZHVsZXMgfSA9IHNtYXJ0TWFwcGluZ1N0YXRlO1xuICAgIGNvbnN0IGxheWVyID0gc21MYXllcjtcbiAgICBjb25zdCByZW5kZXJlciA9IGxheWVyLnJlbmRlcmVyO1xuICAgIGNvbnN0IHVuaXF1ZVZhbHVlSW5mb3MgPSByZW5kZXJlci51bmlxdWVWYWx1ZUluZm9zO1xuICAgIGNvbnN0IHNjaGVtZXMgPSBtb2R1bGVzLnR5cGVTY2hlbWVzLmdldFNjaGVtZXMoe1xuICAgICAgICBiYXNlbWFwOiBtYXBWaWV3Lm1hcC5iYXNlbWFwLFxuICAgICAgICBnZW9tZXRyeVR5cGU6IGdldEdlb21ldHJ5VHlwZShsYXllcikgfHwgZGVmYXVsdEdlb21ldHJ5XG4gICAgfSk7XG4gICAgY29uc3QgcmFtcHNXaXRoU2NoZW1lcyA9IGdldENvbG9yUmFtcHNXaXRoU2NoZW1lcyhzY2hlbWVzLCBNYXRoLm1pbih1bmlxdWVWYWx1ZUluZm9zLmxlbmd0aCwgMTApKTtcbiAgICBjb25zdCBzYW1lTGVuZ3RoU2NoZW1lcyA9IHJhbXBzV2l0aFNjaGVtZXMuZmlsdGVyKChzY2hlbWUpID0+IHtcbiAgICAgICAgcmV0dXJuIHNjaGVtZS5jb2xvcnMubGVuZ3RoID09PSBjb2xvclJhbXAuY29sb3JSYW1wcy5sZW5ndGggKyAxO1xuICAgIH0pO1xuICAgIGNvbnN0IGN1cnJlbnRTY2hlbWUgPSBbXTtcbiAgICBjdXJyZW50U2NoZW1lLnB1c2goY29sb3JSYW1wLmNvbG9yUmFtcHNbMF0uZnJvbUNvbG9yKTtcbiAgICBjb2xvclJhbXAuY29sb3JSYW1wcy5mb3JFYWNoKChyYW1wKSA9PiB7XG4gICAgICAgIGN1cnJlbnRTY2hlbWUucHVzaChyYW1wLnRvQ29sb3IpO1xuICAgIH0pO1xuICAgIGNvbnN0IG1hdGNoaW5nU2NoZW1lID0gc2FtZUxlbmd0aFNjaGVtZXMuZmlsdGVyKChzYW1lTGVuZ3RoU2NoZW1lKSA9PiB7XG4gICAgICAgIGNvbnN0IG1hdGNoID0gSlNPTi5zdHJpbmdpZnkoc2FtZUxlbmd0aFNjaGVtZS5jb2xvcnMpID09PSBKU09OLnN0cmluZ2lmeShjdXJyZW50U2NoZW1lKTtcbiAgICAgICAgY29uc3QgcmV2ZXJzZWRNYXRjaCA9IEpTT04uc3RyaW5naWZ5KG1vZHVsZXMuZXNyaUxhbmcuY2xvbmUoc2FtZUxlbmd0aFNjaGVtZS5jb2xvcnMpLnJldmVyc2UoKSkgPT09IEpTT04uc3RyaW5naWZ5KGN1cnJlbnRTY2hlbWUpO1xuICAgICAgICByZXR1cm4gbWF0Y2ggfHwgcmV2ZXJzZWRNYXRjaDtcbiAgICB9KTtcbiAgICByZXR1cm4gbWF0Y2hpbmdTY2hlbWUubGVuZ3RoID4gMDtcbn1cbmZ1bmN0aW9uIGNvcnJlY3RUcmFuc3BhcmVuY3lGb3JEZWZhdWx0Q29sb3JzKGRlZmF1bHRDb2xvcnMpIHtcbiAgICBjb25zdCB7IG1vZHVsZXMgfSA9IHNtYXJ0TWFwcGluZ1N0YXRlO1xuICAgIGRlZmF1bHRDb2xvcnMgPT09IG51bGwgfHwgZGVmYXVsdENvbG9ycyA9PT0gdm9pZCAwID8gdm9pZCAwIDogZGVmYXVsdENvbG9ycy5mb3JFYWNoKChkZWZhdWx0Q29sb3IsIGlkeCkgPT4ge1xuICAgICAgICBpZiAoZGVmYXVsdENvbG9yLnIgPT09IDAgJiYgZGVmYXVsdENvbG9yLmcgPT09IDAgJiYgZGVmYXVsdENvbG9yLmIgPT09IDAgJiYgZGVmYXVsdENvbG9yLmEgPT09IDApIHtcbiAgICAgICAgICAgIGRlZmF1bHRDb2xvcnNbaWR4XSA9IG5ldyBtb2R1bGVzLmVzcmlDb2xvcihbMjU1LCAyNTUsIDI1NSwgMF0pO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5cbmV4cG9ydCB7IGJ1aWxkU3ltYm9sU3R5bGVyRm9yUmFzdGVyVW5pcXVlVmFsdWVzVmFsdWUgYXMgYSwgYnVpbGRTeW1ib2xTdHlsZXJGb3JSYXN0ZXJDbGFzc0JyZWFrc1ZhbHVlIGFzIGIsIGNyZWF0ZUNvbG9yUmFtcCBhcyBjLCBidWlsZFN5bWJvbFN0eWxlckZvclJhc3RlclVuaXF1ZVZhbHVlc1JhbXAgYXMgZCwgYnVpbGRTeW1ib2xTdHlsZXJGb3JSYXN0ZXJDbGFzc0JyZWFrc1JhbXAgYXMgZSwgYnVpbGRTeW1ib2xTdHlsZXJGb3JSYXN0ZXJTaGFkZWRSZWxpZWYgYXMgZiwgYnVpbGRTeW1ib2xTdHlsZXJGb3JSYXN0ZXJTdHJldGNoIGFzIGcsIGJ1aWxkU3ltYm9sU3R5bGVyRm9yUmFzdGVyRmxvdyBhcyBoIH07XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJhc3Rlci1zeW1ib2xTdHlsZXItOWIzMmVmNDguanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9