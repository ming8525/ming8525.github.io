"use strict";
(self["webpackChunkexb_client"] = self["webpackChunkexb_client"] || []).push([["vendors-extensions_widgets_arcgis_analysis_node_modules_arcgis_app-components_dist_esm_arcgis-550448"],{

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/arcgis-schema-editor.entry.js":
/*!***********************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/arcgis-schema-editor.entry.js ***!
  \***********************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   arcgis_schema_editor: () => (/* binding */ ArcgisSchemaEditor)
/* harmony export */ });
/* harmony import */ var _index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index-e3bf7da7.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/index-e3bf7da7.js");
/* harmony import */ var _categories_ca134005_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./categories-ca134005.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/categories-ca134005.js");
/* harmony import */ var _locale_050b6db9_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./locale-050b6db9.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/locale-050b6db9.js");
/* harmony import */ var _util_2a0e2f08_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./util-2a0e2f08.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/util-2a0e2f08.js");
/* harmony import */ var _dom_4d367677_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./dom-4d367677.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/dom-4d367677.js");
/* harmony import */ var _languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./languageUtil-ef0e54b2.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/languageUtil-ef0e54b2.js");
/* harmony import */ var _loadModules_b4ac1247_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./loadModules-b4ac1247.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/loadModules-b4ac1247.js");
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v4.0.58
 */








const arcgisSchemaEditorCss = ".expand-collapse-all{margin-bottom:1rem}";

const ArcgisSchemaEditor = class {
    constructor(hostRef) {
        (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.r)(this, hostRef);
        this.arcgisSchemaEditorListOrderChange = (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, "arcgisSchemaEditorListOrderChange", 7);
        this.arcgisSchemaEditorDelete = (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, "arcgisSchemaEditorDelete", 7);
        this.arcgisSchemaEditorInvalidMove = (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, "arcgisSchemaEditorInvalidMove", 7);
        this.arcgisSchemaEditorTitleInvalid = (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, "arcgisSchemaEditorTitleInvalid", 7);
        /**
         * When moving a category from one parent to another, the events will be emitted twice
         * (once for the old parent and once for the new parent).
         *
         * This is to avoid emitting the same events multiple times
         */
        this.prevChangeEventPayload = null;
        this.prevSchema = null;
        this.handleExpandCollapseAllClick = () => {
            this.isCollapsedAll = !this.isCollapsedAll;
            this.itemRef.expandOrCollapseAll(this.isCollapsedAll);
        };
        this.handleListOrderChange = (payload) => {
            const { categorySchema, arcgisSchemaEditorListOrderChange, uiCategory } = this;
            const newSchema = (0,_util_2a0e2f08_js__WEBPACK_IMPORTED_MODULE_3__.g)(uiCategory, payload);
            arcgisSchemaEditorListOrderChange.emit(Object.assign(Object.assign({}, payload), { newSchema }));
            this.prevSchema = categorySchema;
        };
        this.handleDeleteClick = (payload) => {
            const { arcgisSchemaEditorDelete, uiCategory } = this;
            const newSchema = (0,_util_2a0e2f08_js__WEBPACK_IMPORTED_MODULE_3__.a)(uiCategory, payload);
            arcgisSchemaEditorDelete.emit(Object.assign(Object.assign({}, payload), { newSchema }));
            this.prevSchema = this.categorySchema;
        };
        this.handleSaveNewTitle = async (payload) => {
            const { saveNewTitle, uiCategory, arcgisSchemaEditorTitleInvalid } = this;
            const path = payload.path;
            const titleErrorCode = (0,_util_2a0e2f08_js__WEBPACK_IMPORTED_MODULE_3__.c)({
                targetParentCategory: (0,_util_2a0e2f08_js__WEBPACK_IMPORTED_MODULE_3__.b)(uiCategory, path).parentCategory,
                targetCategory: { path, title: payload.newTitle }
            });
            if (titleErrorCode) {
                arcgisSchemaEditorTitleInvalid.emit(Object.assign(Object.assign({}, payload), { errorCode: titleErrorCode }));
                return false;
            }
            // Make a copy in case the consumers already mutated the schema
            const prevSchema = this.categorySchema;
            const newSchema = (0,_util_2a0e2f08_js__WEBPACK_IMPORTED_MODULE_3__.d)(uiCategory, payload);
            const saveResult = await saveNewTitle(Object.assign(Object.assign({}, payload), { newSchema }));
            if (saveResult) {
                this.prevSchema = prevSchema;
                // Also optimistically update the UI
                const { targetCategory, parentCategory } = (0,_util_2a0e2f08_js__WEBPACK_IMPORTED_MODULE_3__.b)(uiCategory, payload.path);
                targetCategory.title = payload.newTitle;
                targetCategory.path = (0,_categories_ca134005_js__WEBPACK_IMPORTED_MODULE_1__.a)(parentCategory.path, targetCategory);
            }
            return saveResult;
        };
        this.handleSaveNewCategory = async (payload) => {
            const { saveNewCategory, uiCategory, arcgisSchemaEditorTitleInvalid } = this;
            const path = payload.path;
            const { parentCategory, targetCategory } = (0,_util_2a0e2f08_js__WEBPACK_IMPORTED_MODULE_3__.b)(uiCategory, path);
            const titleErrorCode = (0,_util_2a0e2f08_js__WEBPACK_IMPORTED_MODULE_3__.c)({
                targetParentCategory: targetCategory !== null && targetCategory !== void 0 ? targetCategory : parentCategory,
                targetCategory: { path, title: payload.newTitle }
            });
            if (titleErrorCode) {
                arcgisSchemaEditorTitleInvalid.emit(Object.assign(Object.assign({}, payload), { errorCode: titleErrorCode }));
                return false;
            }
            // Make a copy in case the consumers already mutated the schema
            const prevSchema = this.categorySchema;
            const newSchema = (0,_util_2a0e2f08_js__WEBPACK_IMPORTED_MODULE_3__.e)(uiCategory, payload);
            const saveResult = await saveNewCategory(Object.assign(Object.assign({}, payload), { newSchema }));
            if (saveResult) {
                this.prevSchema = prevSchema;
            }
            return saveResult;
        };
        this.isMoveValid = (payload) => {
            const { maxDepth, arcgisSchemaEditorInvalidMove, prevChangeEventPayload } = this;
            const { fromCategory, toCategory, fromItemCategory } = payload;
            const { fromCategory: prevFromCategory, fromItemCategory: prevFromItemCategory, toCategory: prevToCategory, fromIndex: prevFromIndex, toIndex: prevToIndex } = prevChangeEventPayload !== null && prevChangeEventPayload !== void 0 ? prevChangeEventPayload : {};
            // Avoid emitting the same event multiple times
            if (prevChangeEventPayload &&
                prevFromCategory.path === fromCategory.path &&
                prevFromItemCategory.path === fromItemCategory.path &&
                prevToCategory.path === toCategory.path &&
                prevFromIndex === payload.fromIndex &&
                prevToIndex === payload.toIndex) {
                // `null` is reserved for duplicate event handling
                return null;
            }
            this.prevChangeEventPayload = payload;
            const { path: toPath } = toCategory;
            if (typeof maxDepth === "number" && toPath && (0,_util_2a0e2f08_js__WEBPACK_IMPORTED_MODULE_3__.f)(toPath) > maxDepth) {
                // Can always move to the root
                arcgisSchemaEditorInvalidMove.emit(Object.assign(Object.assign({}, payload), { errorCode: "maxDepthExceeded" }));
                return false;
            }
            const titleErrorCode = (0,_util_2a0e2f08_js__WEBPACK_IMPORTED_MODULE_3__.c)({
                targetParentCategory: toCategory,
                targetCategory: fromItemCategory
            });
            if (titleErrorCode) {
                arcgisSchemaEditorInvalidMove.emit(Object.assign(Object.assign({}, payload), { errorCode: titleErrorCode }));
                return false;
            }
            return true;
        };
        this.categorySchema = undefined;
        this.categoryAggregationData = undefined;
        this.showInputByDefault = false;
        this.newCategoryMode = undefined;
        this.maxDepth = 2;
        this.maxCategories = 900;
        this.canCollapseAll = true;
        this.canEditCategory = undefined;
        this.saveNewTitle = undefined;
        this.saveNewCategory = undefined;
        this.isCollapsedAll = false;
        this.uiCategory = undefined;
        this.canAddCategory = false;
        this.canDeleteCategory = false;
    }
    async componentWillLoad() {
        const locale = await (0,_locale_050b6db9_js__WEBPACK_IMPORTED_MODULE_2__.g)(this.el);
        this.i18n = locale[0];
        this.categorySchemaChangeHandler();
    }
    /** Can be used in case erroring out on schema update */
    async revertSchema() {
        this.categorySchema = this.prevSchema;
    }
    categorySchemaChangeHandler() {
        const { categorySchema, categoryAggregationData } = this;
        this.uiCategory = (0,_util_2a0e2f08_js__WEBPACK_IMPORTED_MODULE_3__.h)(categorySchema, categoryAggregationData);
        const numCategory = (0,_util_2a0e2f08_js__WEBPACK_IMPORTED_MODULE_3__.i)(categorySchema);
        this.canAddCategory = numCategory < this.maxCategories;
        // TODO: rethink this later if we want to allow deleting the root category
        this.canDeleteCategory = true;
    }
    render() {
        const { uiCategory, newCategoryMode, showInputByDefault, canAddCategory, canDeleteCategory, canEditCategory, canCollapseAll, i18n, isCollapsedAll, maxDepth, handleExpandCollapseAllClick, handleListOrderChange, handleSaveNewTitle, handleSaveNewCategory, isMoveValid } = this;
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)(_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.H, null, canCollapseAll && ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-button", { iconStart: isCollapsedAll ? "chevron-down" : "chevron-up", appearance: "transparent", onClick: handleExpandCollapseAllClick, class: "expand-collapse-all" }, isCollapsedAll ? i18n.expandAll : i18n.collapseAll)), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("arcgis-schema-editor-category", {
            // First level is just a placeholder to avoid repeating the same code
            category: uiCategory, newCategoryMode: newCategoryMode, showInputByDefault: showInputByDefault, canAddCategory: canAddCategory, canDeleteCategory: canDeleteCategory, canEditCategory: canEditCategory, i18n: i18n, maxDepth: maxDepth, isMoveValid: isMoveValid, onListOrderChanged: (event) => handleListOrderChange(event.detail), onArcgisSchemaEditorInternalDeleteClick: (event) => this.handleDeleteClick(event.detail), saveNewTitle: handleSaveNewTitle, saveNewCategory: handleSaveNewCategory, ref: (el) => (this.itemRef = el)
        })));
    }
    get el() { return (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.d)(this); }
    static get watchers() { return {
        "categorySchema": ["categorySchemaChangeHandler"]
    }; }
};
ArcgisSchemaEditor.style = arcgisSchemaEditorCss;



//# sourceMappingURL=arcgis-schema-editor.entry.js.map

/***/ }),

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/categories-ca134005.js":
/*!****************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/categories-ca134005.js ***!
  \****************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   C: () => (/* binding */ CATEGORY_BASE_PATH),
/* harmony export */   U: () => (/* binding */ UPPER_CATEGORY_BASE_PATH),
/* harmony export */   a: () => (/* binding */ getCategoryUIPath),
/* harmony export */   g: () => (/* binding */ getRootCategoryPath)
/* harmony export */ });
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v4.0.58
 */
const CATEGORY_BASE_PATH = "/categories";
const UPPER_CATEGORY_BASE_PATH = "/Categories";

// TODO: add unit tests
/**
 * Construct the path of the category based on the parent path and the category title
 */
const getCategoryUIPath = (parentPath, category, lowerCase = true) => {
    const basePath = parentPath !== null && parentPath !== void 0 ? parentPath : "";
    return `${basePath}${basePath.endsWith("/") ? "" : "/"}${lowerCase ? category.title.toLocaleLowerCase() : category.title}`;
};
/**
 * Find the root node title to use for categories
 */
function getRootCategoryPath(categories) {
    var _a;
    let categoryTitle = (_a = categories === null || categories === void 0 ? void 0 : categories[0]) === null || _a === void 0 ? void 0 : _a.title;
    if (categoryTitle && categoryTitle.charAt(0) !== "/") {
        categoryTitle = `/${categoryTitle}`;
    }
    return categoryTitle || UPPER_CATEGORY_BASE_PATH;
}



//# sourceMappingURL=categories-ca134005.js.map

/***/ }),

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/languageUtil-ef0e54b2.js":
/*!******************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/languageUtil-ef0e54b2.js ***!
  \******************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   C: () => (/* binding */ CSS_UTILITY),
/* harmony export */   a: () => (/* binding */ formatDate),
/* harmony export */   b: () => (/* binding */ formatPlural),
/* harmony export */   f: () => (/* binding */ formatNumber),
/* harmony export */   g: () => (/* binding */ getElementDir),
/* harmony export */   l: () => (/* binding */ languageMap)
/* harmony export */ });
/* harmony import */ var _loadModules_b4ac1247_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./loadModules-b4ac1247.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/loadModules-b4ac1247.js");
/* harmony import */ var _dom_4d367677_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./dom-4d367677.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/dom-4d367677.js");
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v4.0.58
 */



const languageMap = new Map([
    ["ar", "ar"],
    ["bg", "bg"],
    ["bs", "bs"],
    ["ca", "ca"],
    ["cs", "cs"],
    ["da", "da"],
    ["de", "de"],
    ["el", "el"],
    ["en", "en"],
    ["es", "es"],
    ["et", "et"],
    ["fi", "fi"],
    ["fr", "fr"],
    ["he", "he"],
    ["hr", "hr"],
    ["hu", "hu"],
    ["id", "id"],
    ["it", "it"],
    ["ja", "ja"],
    ["ko", "ko"],
    ["lt", "lt"],
    ["lv", "lv"],
    ["nb", "nb"],
    ["nl", "nl"],
    ["pl", "pl"],
    ["pt-br", "pt-BR"],
    ["pt-pt", "pt-PT"],
    ["ro", "ro"],
    ["ru", "ru"],
    ["sk", "sk"],
    ["sl", "sl"],
    ["sr", "sr"],
    ["sv", "sv"],
    ["th", "th"],
    ["tr", "tr"],
    ["uk", "uk"],
    ["vi", "vi"],
    ["zh-cn", "zh-CN"],
    ["zh-hk", "zh-HK"],
    ["zh-tw", "zh-TW"]
]);
// rtl
function getElementDir(el) {
    return getElementProp(el, "dir", "ltr");
}
function getElementProp(el, prop, value) {
    const closestWithProp = (0,_dom_4d367677_js__WEBPACK_IMPORTED_MODULE_1__.c)(el, `[${prop}]`);
    return closestWithProp ? closestWithProp.getAttribute(prop) : value;
}
// css
const CSS_UTILITY = {
    rtl: "arcgis--rtl"
};
async function formatNumber(number, options) {
    const { api, type, places } = options || {};
    if (api === 4) {
        const [intl] = await (0,_loadModules_b4ac1247_js__WEBPACK_IMPORTED_MODULE_0__.l)(["esri/intl"]);
        const numberFormatIntlOptions = intl.convertNumberFormatToIntlOptions({
            places,
            style: type,
            digitSeparator: true
        });
        return intl.formatNumber(number, Object.assign(Object.assign({}, numberFormatIntlOptions), { style: type }));
    }
    const [dojoNumber] = await (0,_loadModules_b4ac1247_js__WEBPACK_IMPORTED_MODULE_0__.l)(["dojo/number"]);
    return dojoNumber.format(number, {
        type,
        places,
        pattern: options === null || options === void 0 ? void 0 : options.pattern
    });
}
const cache = {};
function formatDate(date) {
    const lang = document.documentElement.lang;
    const dayShortMonthYear = {
        year: "numeric",
        month: "short",
        day: "numeric"
    };
    if (!cache[lang]) {
        cache[lang] = new Intl.DateTimeFormat(document.documentElement.lang, dayShortMonthYear);
    }
    return cache[lang].format(date);
}
function formatPlural(lang, stringObj, number) {
    const singles = ["id", "ja", "ko", "th", "vi", "zh-cn", "zh-hk", "zh-tw"];
    const likeEnglish = [
        "en",
        "ca",
        "da",
        "de",
        "el",
        "es",
        "et",
        "fi",
        "hi",
        "hu",
        "it",
        "nb",
        "nl",
        "pt-pt",
        "sv",
        "tr"
    ];
    const locale = lang !== null && lang !== void 0 ? lang : "en";
    // if the number is one, or it is a "simple" language, return the 1 string
    if (number === 1 || singles.includes(locale)) {
        return stringObj.single.replace("${number}", "1");
    }
    // if the number is not 1 and the language uses the same pluralization strategy as english,
    // return the multiple string
    if (number !== 1 && likeEnglish.includes(locale)) {
        return stringObj.multiple.replace("${number}", `${number}`);
    }
    // if none of the above worked, return the "unknown" string
    return stringObj.unknown.replace("${number}", `${number}`);
}



//# sourceMappingURL=languageUtil-ef0e54b2.js.map

/***/ }),

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/locale-050b6db9.js":
/*!************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/locale-050b6db9.js ***!
  \************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   a: () => (/* binding */ getComponentClosestLanguage),
/* harmony export */   g: () => (/* binding */ getLocaleComponentStrings)
/* harmony export */ });
/* harmony import */ var _dom_4d367677_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dom-4d367677.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/dom-4d367677.js");
/* harmony import */ var _languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./languageUtil-ef0e54b2.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/languageUtil-ef0e54b2.js");
/* harmony import */ var _index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./index-e3bf7da7.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/index-e3bf7da7.js");
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v4.0.58
 */




// https://medium.com/stencil-tricks/implementing-internationalisation-i18n-with-stencil-5e6559554117
function getComponentClosestLanguage(element) {
    var _a, _b, _c;
    const closestElement = (_a = (0,_dom_4d367677_js__WEBPACK_IMPORTED_MODULE_0__.c)(element, "[lang]")) !== null && _a !== void 0 ? _a : (_c = (_b = element.shadowRoot) === null || _b === void 0 ? void 0 : _b.ownerDocument) === null || _c === void 0 ? void 0 : _c.documentElement;
    // language set by the calling application or browser. defaults to english.
    const lang = ((closestElement === null || closestElement === void 0 ? void 0 : closestElement.lang) || (navigator === null || navigator === void 0 ? void 0 : navigator.language) || "en").toLowerCase();
    if (_languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_1__.l.has(lang)) {
        return _languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_1__.l.get(lang);
    }
    else {
        // "ru-RU" maps to "ru" use case
        if (_languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_1__.l.has(lang.slice(0, 2))) {
            return _languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_1__.l.get(lang.slice(0, 2));
        }
        else {
            return "en";
        }
    }
}
function getComponentClosestLanguageIntl(element) {
    var _a, _b, _c;
    // it's OK if we don't have the 4 letter language file for it
    // 4 letter language code needed for formatting numbers
    const closestElement = (_a = (0,_dom_4d367677_js__WEBPACK_IMPORTED_MODULE_0__.c)(element, "[lang]")) !== null && _a !== void 0 ? _a : (_c = (_b = element.shadowRoot) === null || _b === void 0 ? void 0 : _b.ownerDocument) === null || _c === void 0 ? void 0 : _c.documentElement;
    // language set by the calling application or browser. defaults to english.
    const lang = ((closestElement === null || closestElement === void 0 ? void 0 : closestElement.lang) || (navigator === null || navigator === void 0 ? void 0 : navigator.language) || "en").toLowerCase();
    if (_languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_1__.l.has(lang)) {
        return _languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_1__.l.get(lang);
    }
    else {
        if (_languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_1__.l.has(lang.slice(0, 2))) {
            // we support the 2 letter coded language
            // e.g. it-CH vs it
            return lang;
        }
        else {
            return "en";
        }
    }
}
function fetchLocaleStringsForComponent(componentName, locale) {
    return new Promise((resolve, reject) => {
        fetch((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_2__.a)(`../arcgis-app-assets/i18n/${componentName}.i18n.${locale}.json`)).then((result) => {
            if (result.ok)
                resolve(result.json());
            else
                reject();
        }, () => reject());
    });
}
const stringCache = {};
function fetchLocaleStringsFromCache(componentName, locale) {
    const id = `${componentName}${locale}`;
    if (!stringCache[id]) {
        stringCache[id] = fetchLocaleStringsForComponent(componentName, locale);
    }
    return stringCache[id];
}
/**
 * Get strings and language codes.
 * This method returns 2 language codes.
 * The first one returns a code that's also supported as a language file.
 * The second one returns a code where there is support for the first 2 letters of the code as part of a language file,
 * but will return the original 4 letter code from the page.
 * E.g. For "it-ch" it will return "it" as the first language code and "it-ch" as the second.
 * The second one is required for esri.intl.setLocale() to get the correct formatting.
 *
 * If a tagName is provided it will overwite the element's tagName
 *
 *  @return [ strings, first language code, second language code]
 */
async function getLocaleComponentStrings(element, tagName) {
    const componentName = tagName || element.tagName.toLowerCase();
    const componentLanguage = getComponentClosestLanguage(element);
    const componentLanguageIntl = getComponentClosestLanguageIntl(element);
    let strings;
    try {
        strings = await fetchLocaleStringsFromCache(componentName, componentLanguage);
    }
    catch (e) {
        console.warn(`no locale for ${componentName} (${componentLanguage}) loading default locale en.`);
        strings = await fetchLocaleStringsFromCache(componentName, "en");
    }
    return [strings, componentLanguage, componentLanguageIntl];
}



//# sourceMappingURL=locale-050b6db9.js.map

/***/ }),

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/util-2a0e2f08.js":
/*!**********************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/util-2a0e2f08.js ***!
  \**********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   M: () => (/* binding */ MAX_CATEGORY_NAME_LENGTH),
/* harmony export */   a: () => (/* binding */ getNewCategorySchemaFromDelete),
/* harmony export */   b: () => (/* binding */ getCategoryFromPath),
/* harmony export */   c: () => (/* binding */ checkNewCategoryTitleValid),
/* harmony export */   d: () => (/* binding */ getNewCategorySchemaFromTitleChange),
/* harmony export */   e: () => (/* binding */ getNewCategorySchemaFromCategoryAdd),
/* harmony export */   f: () => (/* binding */ getPathLength),
/* harmony export */   g: () => (/* binding */ getNewCategorySchemaFromMove),
/* harmony export */   h: () => (/* binding */ getUICategoryFromCategorySchema),
/* harmony export */   i: () => (/* binding */ countNumCategories)
/* harmony export */ });
/* harmony import */ var _categories_ca134005_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./categories-ca134005.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/categories-ca134005.js");
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v4.0.58
 */


// TODO: add unit tests
const getNewCategorySchemaFromMove = (category, { fromCategory: { path: fromPath }, toCategory: { path: toPath }, fromIndex, toIndex }) => {
    // Copy since this will be a destructive operation
    const uiCategory = structuredClone(category);
    const fromCategory = getCategoryFromPath(uiCategory, fromPath);
    let toCategory = fromCategory;
    if (fromPath !== toPath) {
        toCategory = getCategoryFromPath(uiCategory, toPath);
    }
    const [removed] = fromCategory.targetCategory.categories.splice(fromIndex, 1);
    toCategory.targetCategory.categories.splice(toIndex, 0, removed);
    return getCategorySchemaFromUICategory(uiCategory);
};
const getNewCategorySchemaFromTitleChange = (category, { newTitle, path }) => {
    const uiCategory = structuredClone(category);
    const categoryToChange = getCategoryFromPath(uiCategory, path);
    categoryToChange.targetCategory.title = newTitle;
    return getCategorySchemaFromUICategory(uiCategory);
};
const getNewCategorySchemaFromCategoryAdd = (category, { newTitle, path }) => {
    const uiCategory = structuredClone(category);
    // Remove the last part since it's just the placeholder
    // e.g. `/categories/category 1/new-input` -> `/categories/category 1`
    const containerPath = path.replace(/\/[^/]+$/, "");
    if (containerPath) {
        const { targetCategory } = getCategoryFromPath(uiCategory, containerPath);
        targetCategory.categories.push({ title: newTitle, categories: [], count: 0, path: null });
    }
    else {
        /**
         * This means we're adding a root level category when there is no category yet
         *
         * Can happens when we first set up the category schema
         */
        uiCategory.categories.push({ title: newTitle, categories: [], count: 0, path: null });
    }
    return getCategorySchemaFromUICategory(uiCategory);
};
const getNewCategorySchemaFromDelete = (category, { path }) => {
    const uiCategory = structuredClone(category);
    const { targetIndex, parentCategory } = getCategoryFromPath(uiCategory, path);
    parentCategory === null || parentCategory === void 0 ? void 0 : parentCategory.categories.splice(targetIndex, 1);
    return getCategorySchemaFromUICategory(uiCategory);
};
// * --- Utils
// Path we want to remove the base path since we count root as 0th level then also remove the beginning `/` to avoid empty string
const getPathLength = (path) => { var _a; return (_a = path === null || path === void 0 ? void 0 : path.replace(_categories_ca134005_js__WEBPACK_IMPORTED_MODULE_0__.C, "").slice(1).split("/").length) !== null && _a !== void 0 ? _a : 0; };
/**
 * Get the category from schema based on the path
 */
const getCategoryFromPath = (uiCategory, path) => {
    if (path == null || path === _categories_ca134005_js__WEBPACK_IMPORTED_MODULE_0__.C) {
        // Root level
        return { targetCategory: uiCategory, targetIndex: 1, parentCategory: null };
    }
    // Path starts with `/` so remove it
    const pathParts = path.slice(1).split("/");
    let curPath = path.indexOf(_categories_ca134005_js__WEBPACK_IMPORTED_MODULE_0__.C) === 0 ? (0,_categories_ca134005_js__WEBPACK_IMPORTED_MODULE_0__.a)("", { title: pathParts.shift() }) : "";
    let parentCategory = null;
    let targetCategory = uiCategory;
    let targetIndex = 0;
    do {
        curPath = (0,_categories_ca134005_js__WEBPACK_IMPORTED_MODULE_0__.a)(curPath, { title: pathParts.shift() });
        parentCategory = targetCategory;
        targetIndex = targetCategory.categories.findIndex((subcategory) => subcategory.path === curPath);
        targetCategory = targetCategory.categories[targetIndex];
    } while (pathParts.length > 0 && targetCategory.categories.length);
    return { targetCategory, targetIndex, parentCategory };
};
/**
 * Create a nested category schema from the aggregated search result starting from root
 */
const getUICategoryFromCategorySchema = (categorySchema, categoryAggregationData) => {
    var _a, _b;
    return ({
        title: "",
        path: null,
        count: (_b = (_a = categoryAggregationData.fieldValues.find((fieldValue) => fieldValue.value === _categories_ca134005_js__WEBPACK_IMPORTED_MODULE_0__.C)) === null || _a === void 0 ? void 0 : _a.count) !== null && _b !== void 0 ? _b : 0,
        categories: getUICategoryFromCategorySchemaRecursive(null, categorySchema, categoryAggregationData)
    });
};
const getCategorySchemaFromUICategory = (uiCategory) => uiCategory.categories.map(getCategoryFromUICategory);
const getCategoryFromUICategory = (uiCategory) => ({
    title: uiCategory.title,
    categories: uiCategory.categories.map(getCategoryFromUICategory)
});
const getUICategoryFromCategorySchemaRecursive = (parentPath, categorySchema, categoryAggregationData) => {
    return categorySchema.map((category) => {
        var _a, _b;
        const path = (0,_categories_ca134005_js__WEBPACK_IMPORTED_MODULE_0__.a)(parentPath !== null && parentPath !== void 0 ? parentPath : _categories_ca134005_js__WEBPACK_IMPORTED_MODULE_0__.C, category);
        const categoryCount = (_a = categoryAggregationData.fieldValues.find((fieldValue) => fieldValue.value === path)) === null || _a === void 0 ? void 0 : _a.count;
        const subcategories = getUICategoryFromCategorySchemaRecursive(path, (_b = category.categories) !== null && _b !== void 0 ? _b : [], categoryAggregationData);
        return {
            title: category.title,
            path,
            count: categoryCount !== null && categoryCount !== void 0 ? categoryCount : 0,
            categories: subcategories
        };
    });
};
const countNumCategories = (categorySchema) => {
    // + 1 is itself
    return categorySchema.reduce((acc, cur) => { var _a; return acc + 1 + countNumCategories((_a = cur.categories) !== null && _a !== void 0 ? _a : []); }, 0);
};
const checkNewCategoryTitleValid = ({ targetCategory, targetParentCategory }) => {
    var _a;
    const categoryLowerCaseTitle = (_a = targetCategory.title.toLocaleLowerCase()) === null || _a === void 0 ? void 0 : _a.trim();
    if (!categoryLowerCaseTitle) {
        return "emptyTitle";
    }
    if (categoryLowerCaseTitle.length > MAX_CATEGORY_NAME_LENGTH) {
        return "maxCharacter";
    }
    // No duplicate category name on the same level
    if (targetParentCategory.categories.some((category) => category.title.toLowerCase() === categoryLowerCaseTitle && category.path !== targetCategory.path)) {
        return "destinationHasSameName";
    }
    return null;
};
const MAX_CATEGORY_NAME_LENGTH = 100;



//# sourceMappingURL=util-2a0e2f08.js.map

/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid2lkZ2V0cy9jaHVua3MvYXJjZ2lzX2FuYWx5c2lzX25vZGVfbW9kdWxlc19hcmNnaXNfYXBwLWNvbXBvbmVudHNfZGlzdF9lc21fYXJjZ2lzLTU1MDQ0OC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQzZHO0FBQzNDO0FBQ0k7QUFDd1E7QUFDblQ7QUFDUztBQUNEOztBQUVuQyxvREFBb0QsbUJBQW1COztBQUV2RTtBQUNBO0FBQ0EsUUFBUSxxREFBZ0I7QUFDeEIsaURBQWlELHFEQUFXO0FBQzVELHdDQUF3QyxxREFBVztBQUNuRCw2Q0FBNkMscURBQVc7QUFDeEQsOENBQThDLHFEQUFXO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGdFQUFnRTtBQUNwRiw4QkFBOEIsb0RBQTRCO0FBQzFELGlGQUFpRixjQUFjLFdBQVc7QUFDMUc7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHVDQUF1QztBQUMzRCw4QkFBOEIsb0RBQThCO0FBQzVELHdFQUF3RSxjQUFjLFdBQVc7QUFDakc7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDJEQUEyRDtBQUMvRTtBQUNBLG1DQUFtQyxvREFBMEI7QUFDN0Qsc0NBQXNDLG9EQUFtQjtBQUN6RCxrQ0FBa0M7QUFDbEMsYUFBYTtBQUNiO0FBQ0Esa0ZBQWtGLGNBQWMsMkJBQTJCO0FBQzNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLG9EQUFtQztBQUNqRSxnRkFBZ0YsY0FBYyxXQUFXO0FBQ3pHO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixpQ0FBaUMsRUFBRSxvREFBbUI7QUFDOUU7QUFDQSxzQ0FBc0MsMERBQWlCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDhEQUE4RDtBQUNsRjtBQUNBLG9CQUFvQixpQ0FBaUMsRUFBRSxvREFBbUI7QUFDMUUsbUNBQW1DLG9EQUEwQjtBQUM3RDtBQUNBLGtDQUFrQztBQUNsQyxhQUFhO0FBQ2I7QUFDQSxrRkFBa0YsY0FBYywyQkFBMkI7QUFDM0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsb0RBQW1DO0FBQ2pFLG1GQUFtRixjQUFjLFdBQVc7QUFDNUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtFQUFrRTtBQUN0RixvQkFBb0IsNkNBQTZDO0FBQ2pFLG9CQUFvQixxSkFBcUo7QUFDeks7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixlQUFlO0FBQ25DLDBEQUEwRCxvREFBYTtBQUN2RTtBQUNBLGlGQUFpRixjQUFjLCtCQUErQjtBQUM5SDtBQUNBO0FBQ0EsbUNBQW1DLG9EQUEwQjtBQUM3RDtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsaUZBQWlGLGNBQWMsMkJBQTJCO0FBQzFIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsc0RBQXlCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsMENBQTBDO0FBQzFELDBCQUEwQixvREFBK0I7QUFDekQsNEJBQTRCLG9EQUFrQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG1RQUFtUTtBQUNuUixnQkFBZ0IscURBQUMsQ0FBQyxpREFBSSwyQkFBMkIscURBQUMscUJBQXFCLDJKQUEySix3REFBd0QscURBQUM7QUFDM1I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLGVBQWUsT0FBTyxxREFBVTtBQUNoQyw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7O0FBRXNEOztBQUV0RDs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN6S0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsU0FBUyxFQUFFLGtDQUFrQyxFQUFFLGdFQUFnRTtBQUM3SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGNBQWM7QUFDMUM7QUFDQTtBQUNBOztBQUVvSDs7QUFFcEg7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUM2RDtBQUNjOztBQUUzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLG1EQUFpQyxTQUFTLEtBQUs7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLG9CQUFvQjtBQUNoQztBQUNBLDZCQUE2QiwyREFBVztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCx1RUFBdUUsOEJBQThCLGFBQWE7QUFDbEg7QUFDQSwrQkFBK0IsMkRBQVc7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsT0FBTztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxPQUFPLE1BQU0sT0FBTztBQUNqRTtBQUNBO0FBQ0Esd0NBQXdDLE9BQU8sTUFBTSxPQUFPO0FBQzVEOztBQUV5SDs7QUFFekg7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ2hJQTtBQUNBO0FBQ0E7QUFDQTtBQUMyRTtBQUNiO0FBQ047O0FBRXhEO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxtREFBaUM7QUFDbEU7QUFDQTtBQUNBLFFBQVEsd0RBQVc7QUFDbkIsZUFBZSx3REFBVztBQUMxQjtBQUNBO0FBQ0E7QUFDQSxZQUFZLHdEQUFXO0FBQ3ZCLG1CQUFtQix3REFBVztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxtREFBaUM7QUFDbEU7QUFDQTtBQUNBLFFBQVEsd0RBQVc7QUFDbkIsZUFBZSx3REFBVztBQUMxQjtBQUNBO0FBQ0EsWUFBWSx3REFBVztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxxREFBWSw4QkFBOEIsY0FBYyxRQUFRLE9BQU87QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixjQUFjLEVBQUUsT0FBTztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsZUFBZSxHQUFHLGtCQUFrQjtBQUMxRTtBQUNBO0FBQ0E7QUFDQTs7QUFFNEU7O0FBRTVFOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNoR0E7QUFDQTtBQUNBO0FBQ0E7QUFDMkY7O0FBRTNGO0FBQ0Esa0RBQWtELGdCQUFnQixnQkFBZ0IsZ0JBQWdCLGNBQWMsc0JBQXNCO0FBQ3RJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsZ0JBQWdCO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsZ0JBQWdCO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsaUJBQWlCO0FBQ2pDLHlDQUF5Qyx1REFBdUQ7QUFDaEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsdURBQXVEO0FBQzVGO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxNQUFNO0FBQzFEO0FBQ0EsWUFBWSw4QkFBOEI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxRQUFRLHNFQUFzRSxzREFBa0I7QUFDbEk7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsc0RBQWtCO0FBQ25EO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixzREFBa0IsVUFBVSwwREFBaUIsT0FBTywwQkFBMEI7QUFDN0c7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsMERBQWlCLFlBQVksMEJBQTBCO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUdBQXlHLHNEQUFrQjtBQUMzSDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiwwREFBaUIsNkRBQTZELHNEQUFrQjtBQUNySDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxRQUFRLGlHQUFpRztBQUMxSjtBQUNBLHNDQUFzQyxzQ0FBc0M7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVtVjs7QUFFblYiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9leGItY2xpZW50Ly4vZXh0ZW5zaW9ucy93aWRnZXRzL2FyY2dpcy9hbmFseXNpcy9ub2RlX21vZHVsZXMvQGFyY2dpcy9hcHAtY29tcG9uZW50cy9kaXN0L2VzbS9hcmNnaXMtc2NoZW1hLWVkaXRvci5lbnRyeS5qcyIsIndlYnBhY2s6Ly9leGItY2xpZW50Ly4vZXh0ZW5zaW9ucy93aWRnZXRzL2FyY2dpcy9hbmFseXNpcy9ub2RlX21vZHVsZXMvQGFyY2dpcy9hcHAtY29tcG9uZW50cy9kaXN0L2VzbS9jYXRlZ29yaWVzLWNhMTM0MDA1LmpzIiwid2VicGFjazovL2V4Yi1jbGllbnQvLi9leHRlbnNpb25zL3dpZGdldHMvYXJjZ2lzL2FuYWx5c2lzL25vZGVfbW9kdWxlcy9AYXJjZ2lzL2FwcC1jb21wb25lbnRzL2Rpc3QvZXNtL2xhbmd1YWdlVXRpbC1lZjBlNTRiMi5qcyIsIndlYnBhY2s6Ly9leGItY2xpZW50Ly4vZXh0ZW5zaW9ucy93aWRnZXRzL2FyY2dpcy9hbmFseXNpcy9ub2RlX21vZHVsZXMvQGFyY2dpcy9hcHAtY29tcG9uZW50cy9kaXN0L2VzbS9sb2NhbGUtMDUwYjZkYjkuanMiLCJ3ZWJwYWNrOi8vZXhiLWNsaWVudC8uL2V4dGVuc2lvbnMvd2lkZ2V0cy9hcmNnaXMvYW5hbHlzaXMvbm9kZV9tb2R1bGVzL0BhcmNnaXMvYXBwLWNvbXBvbmVudHMvZGlzdC9lc20vdXRpbC0yYTBlMmYwOC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIEFsbCBtYXRlcmlhbCBjb3B5cmlnaHQgRVNSSSwgQWxsIFJpZ2h0cyBSZXNlcnZlZCwgdW5sZXNzIG90aGVyd2lzZSBzcGVjaWZpZWQuXG4gKiB2NC4wLjU4XG4gKi9cbmltcG9ydCB7IHIgYXMgcmVnaXN0ZXJJbnN0YW5jZSwgYyBhcyBjcmVhdGVFdmVudCwgaCwgSCBhcyBIb3N0LCBkIGFzIGdldEVsZW1lbnQgfSBmcm9tICcuL2luZGV4LWUzYmY3ZGE3LmpzJztcbmltcG9ydCB7IGEgYXMgZ2V0Q2F0ZWdvcnlVSVBhdGggfSBmcm9tICcuL2NhdGVnb3JpZXMtY2ExMzQwMDUuanMnO1xuaW1wb3J0IHsgZyBhcyBnZXRMb2NhbGVDb21wb25lbnRTdHJpbmdzIH0gZnJvbSAnLi9sb2NhbGUtMDUwYjZkYjkuanMnO1xuaW1wb3J0IHsgZyBhcyBnZXROZXdDYXRlZ29yeVNjaGVtYUZyb21Nb3ZlLCBhIGFzIGdldE5ld0NhdGVnb3J5U2NoZW1hRnJvbURlbGV0ZSwgYyBhcyBjaGVja05ld0NhdGVnb3J5VGl0bGVWYWxpZCwgYiBhcyBnZXRDYXRlZ29yeUZyb21QYXRoLCBkIGFzIGdldE5ld0NhdGVnb3J5U2NoZW1hRnJvbVRpdGxlQ2hhbmdlLCBlIGFzIGdldE5ld0NhdGVnb3J5U2NoZW1hRnJvbUNhdGVnb3J5QWRkLCBmIGFzIGdldFBhdGhMZW5ndGgsIGggYXMgZ2V0VUlDYXRlZ29yeUZyb21DYXRlZ29yeVNjaGVtYSwgaSBhcyBjb3VudE51bUNhdGVnb3JpZXMgfSBmcm9tICcuL3V0aWwtMmEwZTJmMDguanMnO1xuaW1wb3J0ICcuL2RvbS00ZDM2NzY3Ny5qcyc7XG5pbXBvcnQgJy4vbGFuZ3VhZ2VVdGlsLWVmMGU1NGIyLmpzJztcbmltcG9ydCAnLi9sb2FkTW9kdWxlcy1iNGFjMTI0Ny5qcyc7XG5cbmNvbnN0IGFyY2dpc1NjaGVtYUVkaXRvckNzcyA9IFwiLmV4cGFuZC1jb2xsYXBzZS1hbGx7bWFyZ2luLWJvdHRvbToxcmVtfVwiO1xuXG5jb25zdCBBcmNnaXNTY2hlbWFFZGl0b3IgPSBjbGFzcyB7XG4gICAgY29uc3RydWN0b3IoaG9zdFJlZikge1xuICAgICAgICByZWdpc3Rlckluc3RhbmNlKHRoaXMsIGhvc3RSZWYpO1xuICAgICAgICB0aGlzLmFyY2dpc1NjaGVtYUVkaXRvckxpc3RPcmRlckNoYW5nZSA9IGNyZWF0ZUV2ZW50KHRoaXMsIFwiYXJjZ2lzU2NoZW1hRWRpdG9yTGlzdE9yZGVyQ2hhbmdlXCIsIDcpO1xuICAgICAgICB0aGlzLmFyY2dpc1NjaGVtYUVkaXRvckRlbGV0ZSA9IGNyZWF0ZUV2ZW50KHRoaXMsIFwiYXJjZ2lzU2NoZW1hRWRpdG9yRGVsZXRlXCIsIDcpO1xuICAgICAgICB0aGlzLmFyY2dpc1NjaGVtYUVkaXRvckludmFsaWRNb3ZlID0gY3JlYXRlRXZlbnQodGhpcywgXCJhcmNnaXNTY2hlbWFFZGl0b3JJbnZhbGlkTW92ZVwiLCA3KTtcbiAgICAgICAgdGhpcy5hcmNnaXNTY2hlbWFFZGl0b3JUaXRsZUludmFsaWQgPSBjcmVhdGVFdmVudCh0aGlzLCBcImFyY2dpc1NjaGVtYUVkaXRvclRpdGxlSW52YWxpZFwiLCA3KTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZW4gbW92aW5nIGEgY2F0ZWdvcnkgZnJvbSBvbmUgcGFyZW50IHRvIGFub3RoZXIsIHRoZSBldmVudHMgd2lsbCBiZSBlbWl0dGVkIHR3aWNlXG4gICAgICAgICAqIChvbmNlIGZvciB0aGUgb2xkIHBhcmVudCBhbmQgb25jZSBmb3IgdGhlIG5ldyBwYXJlbnQpLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGlzIGlzIHRvIGF2b2lkIGVtaXR0aW5nIHRoZSBzYW1lIGV2ZW50cyBtdWx0aXBsZSB0aW1lc1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wcmV2Q2hhbmdlRXZlbnRQYXlsb2FkID0gbnVsbDtcbiAgICAgICAgdGhpcy5wcmV2U2NoZW1hID0gbnVsbDtcbiAgICAgICAgdGhpcy5oYW5kbGVFeHBhbmRDb2xsYXBzZUFsbENsaWNrID0gKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5pc0NvbGxhcHNlZEFsbCA9ICF0aGlzLmlzQ29sbGFwc2VkQWxsO1xuICAgICAgICAgICAgdGhpcy5pdGVtUmVmLmV4cGFuZE9yQ29sbGFwc2VBbGwodGhpcy5pc0NvbGxhcHNlZEFsbCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlTGlzdE9yZGVyQ2hhbmdlID0gKHBheWxvYWQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgY2F0ZWdvcnlTY2hlbWEsIGFyY2dpc1NjaGVtYUVkaXRvckxpc3RPcmRlckNoYW5nZSwgdWlDYXRlZ29yeSB9ID0gdGhpcztcbiAgICAgICAgICAgIGNvbnN0IG5ld1NjaGVtYSA9IGdldE5ld0NhdGVnb3J5U2NoZW1hRnJvbU1vdmUodWlDYXRlZ29yeSwgcGF5bG9hZCk7XG4gICAgICAgICAgICBhcmNnaXNTY2hlbWFFZGl0b3JMaXN0T3JkZXJDaGFuZ2UuZW1pdChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHBheWxvYWQpLCB7IG5ld1NjaGVtYSB9KSk7XG4gICAgICAgICAgICB0aGlzLnByZXZTY2hlbWEgPSBjYXRlZ29yeVNjaGVtYTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVEZWxldGVDbGljayA9IChwYXlsb2FkKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IGFyY2dpc1NjaGVtYUVkaXRvckRlbGV0ZSwgdWlDYXRlZ29yeSB9ID0gdGhpcztcbiAgICAgICAgICAgIGNvbnN0IG5ld1NjaGVtYSA9IGdldE5ld0NhdGVnb3J5U2NoZW1hRnJvbURlbGV0ZSh1aUNhdGVnb3J5LCBwYXlsb2FkKTtcbiAgICAgICAgICAgIGFyY2dpc1NjaGVtYUVkaXRvckRlbGV0ZS5lbWl0KE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcGF5bG9hZCksIHsgbmV3U2NoZW1hIH0pKTtcbiAgICAgICAgICAgIHRoaXMucHJldlNjaGVtYSA9IHRoaXMuY2F0ZWdvcnlTY2hlbWE7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlU2F2ZU5ld1RpdGxlID0gYXN5bmMgKHBheWxvYWQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgc2F2ZU5ld1RpdGxlLCB1aUNhdGVnb3J5LCBhcmNnaXNTY2hlbWFFZGl0b3JUaXRsZUludmFsaWQgfSA9IHRoaXM7XG4gICAgICAgICAgICBjb25zdCBwYXRoID0gcGF5bG9hZC5wYXRoO1xuICAgICAgICAgICAgY29uc3QgdGl0bGVFcnJvckNvZGUgPSBjaGVja05ld0NhdGVnb3J5VGl0bGVWYWxpZCh7XG4gICAgICAgICAgICAgICAgdGFyZ2V0UGFyZW50Q2F0ZWdvcnk6IGdldENhdGVnb3J5RnJvbVBhdGgodWlDYXRlZ29yeSwgcGF0aCkucGFyZW50Q2F0ZWdvcnksXG4gICAgICAgICAgICAgICAgdGFyZ2V0Q2F0ZWdvcnk6IHsgcGF0aCwgdGl0bGU6IHBheWxvYWQubmV3VGl0bGUgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAodGl0bGVFcnJvckNvZGUpIHtcbiAgICAgICAgICAgICAgICBhcmNnaXNTY2hlbWFFZGl0b3JUaXRsZUludmFsaWQuZW1pdChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHBheWxvYWQpLCB7IGVycm9yQ29kZTogdGl0bGVFcnJvckNvZGUgfSkpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE1ha2UgYSBjb3B5IGluIGNhc2UgdGhlIGNvbnN1bWVycyBhbHJlYWR5IG11dGF0ZWQgdGhlIHNjaGVtYVxuICAgICAgICAgICAgY29uc3QgcHJldlNjaGVtYSA9IHRoaXMuY2F0ZWdvcnlTY2hlbWE7XG4gICAgICAgICAgICBjb25zdCBuZXdTY2hlbWEgPSBnZXROZXdDYXRlZ29yeVNjaGVtYUZyb21UaXRsZUNoYW5nZSh1aUNhdGVnb3J5LCBwYXlsb2FkKTtcbiAgICAgICAgICAgIGNvbnN0IHNhdmVSZXN1bHQgPSBhd2FpdCBzYXZlTmV3VGl0bGUoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBwYXlsb2FkKSwgeyBuZXdTY2hlbWEgfSkpO1xuICAgICAgICAgICAgaWYgKHNhdmVSZXN1bHQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnByZXZTY2hlbWEgPSBwcmV2U2NoZW1hO1xuICAgICAgICAgICAgICAgIC8vIEFsc28gb3B0aW1pc3RpY2FsbHkgdXBkYXRlIHRoZSBVSVxuICAgICAgICAgICAgICAgIGNvbnN0IHsgdGFyZ2V0Q2F0ZWdvcnksIHBhcmVudENhdGVnb3J5IH0gPSBnZXRDYXRlZ29yeUZyb21QYXRoKHVpQ2F0ZWdvcnksIHBheWxvYWQucGF0aCk7XG4gICAgICAgICAgICAgICAgdGFyZ2V0Q2F0ZWdvcnkudGl0bGUgPSBwYXlsb2FkLm5ld1RpdGxlO1xuICAgICAgICAgICAgICAgIHRhcmdldENhdGVnb3J5LnBhdGggPSBnZXRDYXRlZ29yeVVJUGF0aChwYXJlbnRDYXRlZ29yeS5wYXRoLCB0YXJnZXRDYXRlZ29yeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc2F2ZVJlc3VsdDtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVTYXZlTmV3Q2F0ZWdvcnkgPSBhc3luYyAocGF5bG9hZCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBzYXZlTmV3Q2F0ZWdvcnksIHVpQ2F0ZWdvcnksIGFyY2dpc1NjaGVtYUVkaXRvclRpdGxlSW52YWxpZCB9ID0gdGhpcztcbiAgICAgICAgICAgIGNvbnN0IHBhdGggPSBwYXlsb2FkLnBhdGg7XG4gICAgICAgICAgICBjb25zdCB7IHBhcmVudENhdGVnb3J5LCB0YXJnZXRDYXRlZ29yeSB9ID0gZ2V0Q2F0ZWdvcnlGcm9tUGF0aCh1aUNhdGVnb3J5LCBwYXRoKTtcbiAgICAgICAgICAgIGNvbnN0IHRpdGxlRXJyb3JDb2RlID0gY2hlY2tOZXdDYXRlZ29yeVRpdGxlVmFsaWQoe1xuICAgICAgICAgICAgICAgIHRhcmdldFBhcmVudENhdGVnb3J5OiB0YXJnZXRDYXRlZ29yeSAhPT0gbnVsbCAmJiB0YXJnZXRDYXRlZ29yeSAhPT0gdm9pZCAwID8gdGFyZ2V0Q2F0ZWdvcnkgOiBwYXJlbnRDYXRlZ29yeSxcbiAgICAgICAgICAgICAgICB0YXJnZXRDYXRlZ29yeTogeyBwYXRoLCB0aXRsZTogcGF5bG9hZC5uZXdUaXRsZSB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICh0aXRsZUVycm9yQ29kZSkge1xuICAgICAgICAgICAgICAgIGFyY2dpc1NjaGVtYUVkaXRvclRpdGxlSW52YWxpZC5lbWl0KE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcGF5bG9hZCksIHsgZXJyb3JDb2RlOiB0aXRsZUVycm9yQ29kZSB9KSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTWFrZSBhIGNvcHkgaW4gY2FzZSB0aGUgY29uc3VtZXJzIGFscmVhZHkgbXV0YXRlZCB0aGUgc2NoZW1hXG4gICAgICAgICAgICBjb25zdCBwcmV2U2NoZW1hID0gdGhpcy5jYXRlZ29yeVNjaGVtYTtcbiAgICAgICAgICAgIGNvbnN0IG5ld1NjaGVtYSA9IGdldE5ld0NhdGVnb3J5U2NoZW1hRnJvbUNhdGVnb3J5QWRkKHVpQ2F0ZWdvcnksIHBheWxvYWQpO1xuICAgICAgICAgICAgY29uc3Qgc2F2ZVJlc3VsdCA9IGF3YWl0IHNhdmVOZXdDYXRlZ29yeShPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHBheWxvYWQpLCB7IG5ld1NjaGVtYSB9KSk7XG4gICAgICAgICAgICBpZiAoc2F2ZVJlc3VsdCkge1xuICAgICAgICAgICAgICAgIHRoaXMucHJldlNjaGVtYSA9IHByZXZTY2hlbWE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc2F2ZVJlc3VsdDtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5pc01vdmVWYWxpZCA9IChwYXlsb2FkKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IG1heERlcHRoLCBhcmNnaXNTY2hlbWFFZGl0b3JJbnZhbGlkTW92ZSwgcHJldkNoYW5nZUV2ZW50UGF5bG9hZCB9ID0gdGhpcztcbiAgICAgICAgICAgIGNvbnN0IHsgZnJvbUNhdGVnb3J5LCB0b0NhdGVnb3J5LCBmcm9tSXRlbUNhdGVnb3J5IH0gPSBwYXlsb2FkO1xuICAgICAgICAgICAgY29uc3QgeyBmcm9tQ2F0ZWdvcnk6IHByZXZGcm9tQ2F0ZWdvcnksIGZyb21JdGVtQ2F0ZWdvcnk6IHByZXZGcm9tSXRlbUNhdGVnb3J5LCB0b0NhdGVnb3J5OiBwcmV2VG9DYXRlZ29yeSwgZnJvbUluZGV4OiBwcmV2RnJvbUluZGV4LCB0b0luZGV4OiBwcmV2VG9JbmRleCB9ID0gcHJldkNoYW5nZUV2ZW50UGF5bG9hZCAhPT0gbnVsbCAmJiBwcmV2Q2hhbmdlRXZlbnRQYXlsb2FkICE9PSB2b2lkIDAgPyBwcmV2Q2hhbmdlRXZlbnRQYXlsb2FkIDoge307XG4gICAgICAgICAgICAvLyBBdm9pZCBlbWl0dGluZyB0aGUgc2FtZSBldmVudCBtdWx0aXBsZSB0aW1lc1xuICAgICAgICAgICAgaWYgKHByZXZDaGFuZ2VFdmVudFBheWxvYWQgJiZcbiAgICAgICAgICAgICAgICBwcmV2RnJvbUNhdGVnb3J5LnBhdGggPT09IGZyb21DYXRlZ29yeS5wYXRoICYmXG4gICAgICAgICAgICAgICAgcHJldkZyb21JdGVtQ2F0ZWdvcnkucGF0aCA9PT0gZnJvbUl0ZW1DYXRlZ29yeS5wYXRoICYmXG4gICAgICAgICAgICAgICAgcHJldlRvQ2F0ZWdvcnkucGF0aCA9PT0gdG9DYXRlZ29yeS5wYXRoICYmXG4gICAgICAgICAgICAgICAgcHJldkZyb21JbmRleCA9PT0gcGF5bG9hZC5mcm9tSW5kZXggJiZcbiAgICAgICAgICAgICAgICBwcmV2VG9JbmRleCA9PT0gcGF5bG9hZC50b0luZGV4KSB7XG4gICAgICAgICAgICAgICAgLy8gYG51bGxgIGlzIHJlc2VydmVkIGZvciBkdXBsaWNhdGUgZXZlbnQgaGFuZGxpbmdcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucHJldkNoYW5nZUV2ZW50UGF5bG9hZCA9IHBheWxvYWQ7XG4gICAgICAgICAgICBjb25zdCB7IHBhdGg6IHRvUGF0aCB9ID0gdG9DYXRlZ29yeTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbWF4RGVwdGggPT09IFwibnVtYmVyXCIgJiYgdG9QYXRoICYmIGdldFBhdGhMZW5ndGgodG9QYXRoKSA+IG1heERlcHRoKSB7XG4gICAgICAgICAgICAgICAgLy8gQ2FuIGFsd2F5cyBtb3ZlIHRvIHRoZSByb290XG4gICAgICAgICAgICAgICAgYXJjZ2lzU2NoZW1hRWRpdG9ySW52YWxpZE1vdmUuZW1pdChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHBheWxvYWQpLCB7IGVycm9yQ29kZTogXCJtYXhEZXB0aEV4Y2VlZGVkXCIgfSkpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHRpdGxlRXJyb3JDb2RlID0gY2hlY2tOZXdDYXRlZ29yeVRpdGxlVmFsaWQoe1xuICAgICAgICAgICAgICAgIHRhcmdldFBhcmVudENhdGVnb3J5OiB0b0NhdGVnb3J5LFxuICAgICAgICAgICAgICAgIHRhcmdldENhdGVnb3J5OiBmcm9tSXRlbUNhdGVnb3J5XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICh0aXRsZUVycm9yQ29kZSkge1xuICAgICAgICAgICAgICAgIGFyY2dpc1NjaGVtYUVkaXRvckludmFsaWRNb3ZlLmVtaXQoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBwYXlsb2FkKSwgeyBlcnJvckNvZGU6IHRpdGxlRXJyb3JDb2RlIH0pKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5jYXRlZ29yeVNjaGVtYSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5jYXRlZ29yeUFnZ3JlZ2F0aW9uRGF0YSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5zaG93SW5wdXRCeURlZmF1bHQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5uZXdDYXRlZ29yeU1vZGUgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMubWF4RGVwdGggPSAyO1xuICAgICAgICB0aGlzLm1heENhdGVnb3JpZXMgPSA5MDA7XG4gICAgICAgIHRoaXMuY2FuQ29sbGFwc2VBbGwgPSB0cnVlO1xuICAgICAgICB0aGlzLmNhbkVkaXRDYXRlZ29yeSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5zYXZlTmV3VGl0bGUgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuc2F2ZU5ld0NhdGVnb3J5ID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmlzQ29sbGFwc2VkQWxsID0gZmFsc2U7XG4gICAgICAgIHRoaXMudWlDYXRlZ29yeSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5jYW5BZGRDYXRlZ29yeSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmNhbkRlbGV0ZUNhdGVnb3J5ID0gZmFsc2U7XG4gICAgfVxuICAgIGFzeW5jIGNvbXBvbmVudFdpbGxMb2FkKCkge1xuICAgICAgICBjb25zdCBsb2NhbGUgPSBhd2FpdCBnZXRMb2NhbGVDb21wb25lbnRTdHJpbmdzKHRoaXMuZWwpO1xuICAgICAgICB0aGlzLmkxOG4gPSBsb2NhbGVbMF07XG4gICAgICAgIHRoaXMuY2F0ZWdvcnlTY2hlbWFDaGFuZ2VIYW5kbGVyKCk7XG4gICAgfVxuICAgIC8qKiBDYW4gYmUgdXNlZCBpbiBjYXNlIGVycm9yaW5nIG91dCBvbiBzY2hlbWEgdXBkYXRlICovXG4gICAgYXN5bmMgcmV2ZXJ0U2NoZW1hKCkge1xuICAgICAgICB0aGlzLmNhdGVnb3J5U2NoZW1hID0gdGhpcy5wcmV2U2NoZW1hO1xuICAgIH1cbiAgICBjYXRlZ29yeVNjaGVtYUNoYW5nZUhhbmRsZXIoKSB7XG4gICAgICAgIGNvbnN0IHsgY2F0ZWdvcnlTY2hlbWEsIGNhdGVnb3J5QWdncmVnYXRpb25EYXRhIH0gPSB0aGlzO1xuICAgICAgICB0aGlzLnVpQ2F0ZWdvcnkgPSBnZXRVSUNhdGVnb3J5RnJvbUNhdGVnb3J5U2NoZW1hKGNhdGVnb3J5U2NoZW1hLCBjYXRlZ29yeUFnZ3JlZ2F0aW9uRGF0YSk7XG4gICAgICAgIGNvbnN0IG51bUNhdGVnb3J5ID0gY291bnROdW1DYXRlZ29yaWVzKGNhdGVnb3J5U2NoZW1hKTtcbiAgICAgICAgdGhpcy5jYW5BZGRDYXRlZ29yeSA9IG51bUNhdGVnb3J5IDwgdGhpcy5tYXhDYXRlZ29yaWVzO1xuICAgICAgICAvLyBUT0RPOiByZXRoaW5rIHRoaXMgbGF0ZXIgaWYgd2Ugd2FudCB0byBhbGxvdyBkZWxldGluZyB0aGUgcm9vdCBjYXRlZ29yeVxuICAgICAgICB0aGlzLmNhbkRlbGV0ZUNhdGVnb3J5ID0gdHJ1ZTtcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICBjb25zdCB7IHVpQ2F0ZWdvcnksIG5ld0NhdGVnb3J5TW9kZSwgc2hvd0lucHV0QnlEZWZhdWx0LCBjYW5BZGRDYXRlZ29yeSwgY2FuRGVsZXRlQ2F0ZWdvcnksIGNhbkVkaXRDYXRlZ29yeSwgY2FuQ29sbGFwc2VBbGwsIGkxOG4sIGlzQ29sbGFwc2VkQWxsLCBtYXhEZXB0aCwgaGFuZGxlRXhwYW5kQ29sbGFwc2VBbGxDbGljaywgaGFuZGxlTGlzdE9yZGVyQ2hhbmdlLCBoYW5kbGVTYXZlTmV3VGl0bGUsIGhhbmRsZVNhdmVOZXdDYXRlZ29yeSwgaXNNb3ZlVmFsaWQgfSA9IHRoaXM7XG4gICAgICAgIHJldHVybiAoaChIb3N0LCBudWxsLCBjYW5Db2xsYXBzZUFsbCAmJiAoaChcImNhbGNpdGUtYnV0dG9uXCIsIHsgaWNvblN0YXJ0OiBpc0NvbGxhcHNlZEFsbCA/IFwiY2hldnJvbi1kb3duXCIgOiBcImNoZXZyb24tdXBcIiwgYXBwZWFyYW5jZTogXCJ0cmFuc3BhcmVudFwiLCBvbkNsaWNrOiBoYW5kbGVFeHBhbmRDb2xsYXBzZUFsbENsaWNrLCBjbGFzczogXCJleHBhbmQtY29sbGFwc2UtYWxsXCIgfSwgaXNDb2xsYXBzZWRBbGwgPyBpMThuLmV4cGFuZEFsbCA6IGkxOG4uY29sbGFwc2VBbGwpKSwgaChcImFyY2dpcy1zY2hlbWEtZWRpdG9yLWNhdGVnb3J5XCIsIHtcbiAgICAgICAgICAgIC8vIEZpcnN0IGxldmVsIGlzIGp1c3QgYSBwbGFjZWhvbGRlciB0byBhdm9pZCByZXBlYXRpbmcgdGhlIHNhbWUgY29kZVxuICAgICAgICAgICAgY2F0ZWdvcnk6IHVpQ2F0ZWdvcnksIG5ld0NhdGVnb3J5TW9kZTogbmV3Q2F0ZWdvcnlNb2RlLCBzaG93SW5wdXRCeURlZmF1bHQ6IHNob3dJbnB1dEJ5RGVmYXVsdCwgY2FuQWRkQ2F0ZWdvcnk6IGNhbkFkZENhdGVnb3J5LCBjYW5EZWxldGVDYXRlZ29yeTogY2FuRGVsZXRlQ2F0ZWdvcnksIGNhbkVkaXRDYXRlZ29yeTogY2FuRWRpdENhdGVnb3J5LCBpMThuOiBpMThuLCBtYXhEZXB0aDogbWF4RGVwdGgsIGlzTW92ZVZhbGlkOiBpc01vdmVWYWxpZCwgb25MaXN0T3JkZXJDaGFuZ2VkOiAoZXZlbnQpID0+IGhhbmRsZUxpc3RPcmRlckNoYW5nZShldmVudC5kZXRhaWwpLCBvbkFyY2dpc1NjaGVtYUVkaXRvckludGVybmFsRGVsZXRlQ2xpY2s6IChldmVudCkgPT4gdGhpcy5oYW5kbGVEZWxldGVDbGljayhldmVudC5kZXRhaWwpLCBzYXZlTmV3VGl0bGU6IGhhbmRsZVNhdmVOZXdUaXRsZSwgc2F2ZU5ld0NhdGVnb3J5OiBoYW5kbGVTYXZlTmV3Q2F0ZWdvcnksIHJlZjogKGVsKSA9PiAodGhpcy5pdGVtUmVmID0gZWwpXG4gICAgICAgIH0pKSk7XG4gICAgfVxuICAgIGdldCBlbCgpIHsgcmV0dXJuIGdldEVsZW1lbnQodGhpcyk7IH1cbiAgICBzdGF0aWMgZ2V0IHdhdGNoZXJzKCkgeyByZXR1cm4ge1xuICAgICAgICBcImNhdGVnb3J5U2NoZW1hXCI6IFtcImNhdGVnb3J5U2NoZW1hQ2hhbmdlSGFuZGxlclwiXVxuICAgIH07IH1cbn07XG5BcmNnaXNTY2hlbWFFZGl0b3Iuc3R5bGUgPSBhcmNnaXNTY2hlbWFFZGl0b3JDc3M7XG5cbmV4cG9ydCB7IEFyY2dpc1NjaGVtYUVkaXRvciBhcyBhcmNnaXNfc2NoZW1hX2VkaXRvciB9O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1hcmNnaXMtc2NoZW1hLWVkaXRvci5lbnRyeS5qcy5tYXAiLCIvKiFcbiAqIEFsbCBtYXRlcmlhbCBjb3B5cmlnaHQgRVNSSSwgQWxsIFJpZ2h0cyBSZXNlcnZlZCwgdW5sZXNzIG90aGVyd2lzZSBzcGVjaWZpZWQuXG4gKiB2NC4wLjU4XG4gKi9cbmNvbnN0IENBVEVHT1JZX0JBU0VfUEFUSCA9IFwiL2NhdGVnb3JpZXNcIjtcbmNvbnN0IFVQUEVSX0NBVEVHT1JZX0JBU0VfUEFUSCA9IFwiL0NhdGVnb3JpZXNcIjtcblxuLy8gVE9ETzogYWRkIHVuaXQgdGVzdHNcbi8qKlxuICogQ29uc3RydWN0IHRoZSBwYXRoIG9mIHRoZSBjYXRlZ29yeSBiYXNlZCBvbiB0aGUgcGFyZW50IHBhdGggYW5kIHRoZSBjYXRlZ29yeSB0aXRsZVxuICovXG5jb25zdCBnZXRDYXRlZ29yeVVJUGF0aCA9IChwYXJlbnRQYXRoLCBjYXRlZ29yeSwgbG93ZXJDYXNlID0gdHJ1ZSkgPT4ge1xuICAgIGNvbnN0IGJhc2VQYXRoID0gcGFyZW50UGF0aCAhPT0gbnVsbCAmJiBwYXJlbnRQYXRoICE9PSB2b2lkIDAgPyBwYXJlbnRQYXRoIDogXCJcIjtcbiAgICByZXR1cm4gYCR7YmFzZVBhdGh9JHtiYXNlUGF0aC5lbmRzV2l0aChcIi9cIikgPyBcIlwiIDogXCIvXCJ9JHtsb3dlckNhc2UgPyBjYXRlZ29yeS50aXRsZS50b0xvY2FsZUxvd2VyQ2FzZSgpIDogY2F0ZWdvcnkudGl0bGV9YDtcbn07XG4vKipcbiAqIEZpbmQgdGhlIHJvb3Qgbm9kZSB0aXRsZSB0byB1c2UgZm9yIGNhdGVnb3JpZXNcbiAqL1xuZnVuY3Rpb24gZ2V0Um9vdENhdGVnb3J5UGF0aChjYXRlZ29yaWVzKSB7XG4gICAgdmFyIF9hO1xuICAgIGxldCBjYXRlZ29yeVRpdGxlID0gKF9hID0gY2F0ZWdvcmllcyA9PT0gbnVsbCB8fCBjYXRlZ29yaWVzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjYXRlZ29yaWVzWzBdKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudGl0bGU7XG4gICAgaWYgKGNhdGVnb3J5VGl0bGUgJiYgY2F0ZWdvcnlUaXRsZS5jaGFyQXQoMCkgIT09IFwiL1wiKSB7XG4gICAgICAgIGNhdGVnb3J5VGl0bGUgPSBgLyR7Y2F0ZWdvcnlUaXRsZX1gO1xuICAgIH1cbiAgICByZXR1cm4gY2F0ZWdvcnlUaXRsZSB8fCBVUFBFUl9DQVRFR09SWV9CQVNFX1BBVEg7XG59XG5cbmV4cG9ydCB7IENBVEVHT1JZX0JBU0VfUEFUSCBhcyBDLCBVUFBFUl9DQVRFR09SWV9CQVNFX1BBVEggYXMgVSwgZ2V0Q2F0ZWdvcnlVSVBhdGggYXMgYSwgZ2V0Um9vdENhdGVnb3J5UGF0aCBhcyBnIH07XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNhdGVnb3JpZXMtY2ExMzQwMDUuanMubWFwIiwiLyohXG4gKiBBbGwgbWF0ZXJpYWwgY29weXJpZ2h0IEVTUkksIEFsbCBSaWdodHMgUmVzZXJ2ZWQsIHVubGVzcyBvdGhlcndpc2Ugc3BlY2lmaWVkLlxuICogdjQuMC41OFxuICovXG5pbXBvcnQgeyBsIGFzIGxvYWRNb2R1bGVzIH0gZnJvbSAnLi9sb2FkTW9kdWxlcy1iNGFjMTI0Ny5qcyc7XG5pbXBvcnQgeyBjIGFzIGNsb3Nlc3RFbGVtZW50Q3Jvc3NTaGFkb3dCb3VuZGFyeSB9IGZyb20gJy4vZG9tLTRkMzY3Njc3LmpzJztcblxuY29uc3QgbGFuZ3VhZ2VNYXAgPSBuZXcgTWFwKFtcbiAgICBbXCJhclwiLCBcImFyXCJdLFxuICAgIFtcImJnXCIsIFwiYmdcIl0sXG4gICAgW1wiYnNcIiwgXCJic1wiXSxcbiAgICBbXCJjYVwiLCBcImNhXCJdLFxuICAgIFtcImNzXCIsIFwiY3NcIl0sXG4gICAgW1wiZGFcIiwgXCJkYVwiXSxcbiAgICBbXCJkZVwiLCBcImRlXCJdLFxuICAgIFtcImVsXCIsIFwiZWxcIl0sXG4gICAgW1wiZW5cIiwgXCJlblwiXSxcbiAgICBbXCJlc1wiLCBcImVzXCJdLFxuICAgIFtcImV0XCIsIFwiZXRcIl0sXG4gICAgW1wiZmlcIiwgXCJmaVwiXSxcbiAgICBbXCJmclwiLCBcImZyXCJdLFxuICAgIFtcImhlXCIsIFwiaGVcIl0sXG4gICAgW1wiaHJcIiwgXCJoclwiXSxcbiAgICBbXCJodVwiLCBcImh1XCJdLFxuICAgIFtcImlkXCIsIFwiaWRcIl0sXG4gICAgW1wiaXRcIiwgXCJpdFwiXSxcbiAgICBbXCJqYVwiLCBcImphXCJdLFxuICAgIFtcImtvXCIsIFwia29cIl0sXG4gICAgW1wibHRcIiwgXCJsdFwiXSxcbiAgICBbXCJsdlwiLCBcImx2XCJdLFxuICAgIFtcIm5iXCIsIFwibmJcIl0sXG4gICAgW1wibmxcIiwgXCJubFwiXSxcbiAgICBbXCJwbFwiLCBcInBsXCJdLFxuICAgIFtcInB0LWJyXCIsIFwicHQtQlJcIl0sXG4gICAgW1wicHQtcHRcIiwgXCJwdC1QVFwiXSxcbiAgICBbXCJyb1wiLCBcInJvXCJdLFxuICAgIFtcInJ1XCIsIFwicnVcIl0sXG4gICAgW1wic2tcIiwgXCJza1wiXSxcbiAgICBbXCJzbFwiLCBcInNsXCJdLFxuICAgIFtcInNyXCIsIFwic3JcIl0sXG4gICAgW1wic3ZcIiwgXCJzdlwiXSxcbiAgICBbXCJ0aFwiLCBcInRoXCJdLFxuICAgIFtcInRyXCIsIFwidHJcIl0sXG4gICAgW1widWtcIiwgXCJ1a1wiXSxcbiAgICBbXCJ2aVwiLCBcInZpXCJdLFxuICAgIFtcInpoLWNuXCIsIFwiemgtQ05cIl0sXG4gICAgW1wiemgtaGtcIiwgXCJ6aC1IS1wiXSxcbiAgICBbXCJ6aC10d1wiLCBcInpoLVRXXCJdXG5dKTtcbi8vIHJ0bFxuZnVuY3Rpb24gZ2V0RWxlbWVudERpcihlbCkge1xuICAgIHJldHVybiBnZXRFbGVtZW50UHJvcChlbCwgXCJkaXJcIiwgXCJsdHJcIik7XG59XG5mdW5jdGlvbiBnZXRFbGVtZW50UHJvcChlbCwgcHJvcCwgdmFsdWUpIHtcbiAgICBjb25zdCBjbG9zZXN0V2l0aFByb3AgPSBjbG9zZXN0RWxlbWVudENyb3NzU2hhZG93Qm91bmRhcnkoZWwsIGBbJHtwcm9wfV1gKTtcbiAgICByZXR1cm4gY2xvc2VzdFdpdGhQcm9wID8gY2xvc2VzdFdpdGhQcm9wLmdldEF0dHJpYnV0ZShwcm9wKSA6IHZhbHVlO1xufVxuLy8gY3NzXG5jb25zdCBDU1NfVVRJTElUWSA9IHtcbiAgICBydGw6IFwiYXJjZ2lzLS1ydGxcIlxufTtcbmFzeW5jIGZ1bmN0aW9uIGZvcm1hdE51bWJlcihudW1iZXIsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IGFwaSwgdHlwZSwgcGxhY2VzIH0gPSBvcHRpb25zIHx8IHt9O1xuICAgIGlmIChhcGkgPT09IDQpIHtcbiAgICAgICAgY29uc3QgW2ludGxdID0gYXdhaXQgbG9hZE1vZHVsZXMoW1wiZXNyaS9pbnRsXCJdKTtcbiAgICAgICAgY29uc3QgbnVtYmVyRm9ybWF0SW50bE9wdGlvbnMgPSBpbnRsLmNvbnZlcnROdW1iZXJGb3JtYXRUb0ludGxPcHRpb25zKHtcbiAgICAgICAgICAgIHBsYWNlcyxcbiAgICAgICAgICAgIHN0eWxlOiB0eXBlLFxuICAgICAgICAgICAgZGlnaXRTZXBhcmF0b3I6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBpbnRsLmZvcm1hdE51bWJlcihudW1iZXIsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbnVtYmVyRm9ybWF0SW50bE9wdGlvbnMpLCB7IHN0eWxlOiB0eXBlIH0pKTtcbiAgICB9XG4gICAgY29uc3QgW2Rvam9OdW1iZXJdID0gYXdhaXQgbG9hZE1vZHVsZXMoW1wiZG9qby9udW1iZXJcIl0pO1xuICAgIHJldHVybiBkb2pvTnVtYmVyLmZvcm1hdChudW1iZXIsIHtcbiAgICAgICAgdHlwZSxcbiAgICAgICAgcGxhY2VzLFxuICAgICAgICBwYXR0ZXJuOiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMucGF0dGVyblxuICAgIH0pO1xufVxuY29uc3QgY2FjaGUgPSB7fTtcbmZ1bmN0aW9uIGZvcm1hdERhdGUoZGF0ZSkge1xuICAgIGNvbnN0IGxhbmcgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQubGFuZztcbiAgICBjb25zdCBkYXlTaG9ydE1vbnRoWWVhciA9IHtcbiAgICAgICAgeWVhcjogXCJudW1lcmljXCIsXG4gICAgICAgIG1vbnRoOiBcInNob3J0XCIsXG4gICAgICAgIGRheTogXCJudW1lcmljXCJcbiAgICB9O1xuICAgIGlmICghY2FjaGVbbGFuZ10pIHtcbiAgICAgICAgY2FjaGVbbGFuZ10gPSBuZXcgSW50bC5EYXRlVGltZUZvcm1hdChkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQubGFuZywgZGF5U2hvcnRNb250aFllYXIpO1xuICAgIH1cbiAgICByZXR1cm4gY2FjaGVbbGFuZ10uZm9ybWF0KGRhdGUpO1xufVxuZnVuY3Rpb24gZm9ybWF0UGx1cmFsKGxhbmcsIHN0cmluZ09iaiwgbnVtYmVyKSB7XG4gICAgY29uc3Qgc2luZ2xlcyA9IFtcImlkXCIsIFwiamFcIiwgXCJrb1wiLCBcInRoXCIsIFwidmlcIiwgXCJ6aC1jblwiLCBcInpoLWhrXCIsIFwiemgtdHdcIl07XG4gICAgY29uc3QgbGlrZUVuZ2xpc2ggPSBbXG4gICAgICAgIFwiZW5cIixcbiAgICAgICAgXCJjYVwiLFxuICAgICAgICBcImRhXCIsXG4gICAgICAgIFwiZGVcIixcbiAgICAgICAgXCJlbFwiLFxuICAgICAgICBcImVzXCIsXG4gICAgICAgIFwiZXRcIixcbiAgICAgICAgXCJmaVwiLFxuICAgICAgICBcImhpXCIsXG4gICAgICAgIFwiaHVcIixcbiAgICAgICAgXCJpdFwiLFxuICAgICAgICBcIm5iXCIsXG4gICAgICAgIFwibmxcIixcbiAgICAgICAgXCJwdC1wdFwiLFxuICAgICAgICBcInN2XCIsXG4gICAgICAgIFwidHJcIlxuICAgIF07XG4gICAgY29uc3QgbG9jYWxlID0gbGFuZyAhPT0gbnVsbCAmJiBsYW5nICE9PSB2b2lkIDAgPyBsYW5nIDogXCJlblwiO1xuICAgIC8vIGlmIHRoZSBudW1iZXIgaXMgb25lLCBvciBpdCBpcyBhIFwic2ltcGxlXCIgbGFuZ3VhZ2UsIHJldHVybiB0aGUgMSBzdHJpbmdcbiAgICBpZiAobnVtYmVyID09PSAxIHx8IHNpbmdsZXMuaW5jbHVkZXMobG9jYWxlKSkge1xuICAgICAgICByZXR1cm4gc3RyaW5nT2JqLnNpbmdsZS5yZXBsYWNlKFwiJHtudW1iZXJ9XCIsIFwiMVwiKTtcbiAgICB9XG4gICAgLy8gaWYgdGhlIG51bWJlciBpcyBub3QgMSBhbmQgdGhlIGxhbmd1YWdlIHVzZXMgdGhlIHNhbWUgcGx1cmFsaXphdGlvbiBzdHJhdGVneSBhcyBlbmdsaXNoLFxuICAgIC8vIHJldHVybiB0aGUgbXVsdGlwbGUgc3RyaW5nXG4gICAgaWYgKG51bWJlciAhPT0gMSAmJiBsaWtlRW5nbGlzaC5pbmNsdWRlcyhsb2NhbGUpKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmdPYmoubXVsdGlwbGUucmVwbGFjZShcIiR7bnVtYmVyfVwiLCBgJHtudW1iZXJ9YCk7XG4gICAgfVxuICAgIC8vIGlmIG5vbmUgb2YgdGhlIGFib3ZlIHdvcmtlZCwgcmV0dXJuIHRoZSBcInVua25vd25cIiBzdHJpbmdcbiAgICByZXR1cm4gc3RyaW5nT2JqLnVua25vd24ucmVwbGFjZShcIiR7bnVtYmVyfVwiLCBgJHtudW1iZXJ9YCk7XG59XG5cbmV4cG9ydCB7IENTU19VVElMSVRZIGFzIEMsIGZvcm1hdERhdGUgYXMgYSwgZm9ybWF0UGx1cmFsIGFzIGIsIGZvcm1hdE51bWJlciBhcyBmLCBnZXRFbGVtZW50RGlyIGFzIGcsIGxhbmd1YWdlTWFwIGFzIGwgfTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bGFuZ3VhZ2VVdGlsLWVmMGU1NGIyLmpzLm1hcCIsIi8qIVxuICogQWxsIG1hdGVyaWFsIGNvcHlyaWdodCBFU1JJLCBBbGwgUmlnaHRzIFJlc2VydmVkLCB1bmxlc3Mgb3RoZXJ3aXNlIHNwZWNpZmllZC5cbiAqIHY0LjAuNThcbiAqL1xuaW1wb3J0IHsgYyBhcyBjbG9zZXN0RWxlbWVudENyb3NzU2hhZG93Qm91bmRhcnkgfSBmcm9tICcuL2RvbS00ZDM2NzY3Ny5qcyc7XG5pbXBvcnQgeyBsIGFzIGxhbmd1YWdlTWFwIH0gZnJvbSAnLi9sYW5ndWFnZVV0aWwtZWYwZTU0YjIuanMnO1xuaW1wb3J0IHsgYSBhcyBnZXRBc3NldFBhdGggfSBmcm9tICcuL2luZGV4LWUzYmY3ZGE3LmpzJztcblxuLy8gaHR0cHM6Ly9tZWRpdW0uY29tL3N0ZW5jaWwtdHJpY2tzL2ltcGxlbWVudGluZy1pbnRlcm5hdGlvbmFsaXNhdGlvbi1pMThuLXdpdGgtc3RlbmNpbC01ZTY1NTk1NTQxMTdcbmZ1bmN0aW9uIGdldENvbXBvbmVudENsb3Nlc3RMYW5ndWFnZShlbGVtZW50KSB7XG4gICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgY29uc3QgY2xvc2VzdEVsZW1lbnQgPSAoX2EgPSBjbG9zZXN0RWxlbWVudENyb3NzU2hhZG93Qm91bmRhcnkoZWxlbWVudCwgXCJbbGFuZ11cIikpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IChfYyA9IChfYiA9IGVsZW1lbnQuc2hhZG93Um9vdCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLm93bmVyRG9jdW1lbnQpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5kb2N1bWVudEVsZW1lbnQ7XG4gICAgLy8gbGFuZ3VhZ2Ugc2V0IGJ5IHRoZSBjYWxsaW5nIGFwcGxpY2F0aW9uIG9yIGJyb3dzZXIuIGRlZmF1bHRzIHRvIGVuZ2xpc2guXG4gICAgY29uc3QgbGFuZyA9ICgoY2xvc2VzdEVsZW1lbnQgPT09IG51bGwgfHwgY2xvc2VzdEVsZW1lbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNsb3Nlc3RFbGVtZW50LmxhbmcpIHx8IChuYXZpZ2F0b3IgPT09IG51bGwgfHwgbmF2aWdhdG9yID09PSB2b2lkIDAgPyB2b2lkIDAgOiBuYXZpZ2F0b3IubGFuZ3VhZ2UpIHx8IFwiZW5cIikudG9Mb3dlckNhc2UoKTtcbiAgICBpZiAobGFuZ3VhZ2VNYXAuaGFzKGxhbmcpKSB7XG4gICAgICAgIHJldHVybiBsYW5ndWFnZU1hcC5nZXQobGFuZyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBcInJ1LVJVXCIgbWFwcyB0byBcInJ1XCIgdXNlIGNhc2VcbiAgICAgICAgaWYgKGxhbmd1YWdlTWFwLmhhcyhsYW5nLnNsaWNlKDAsIDIpKSkge1xuICAgICAgICAgICAgcmV0dXJuIGxhbmd1YWdlTWFwLmdldChsYW5nLnNsaWNlKDAsIDIpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBcImVuXCI7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBnZXRDb21wb25lbnRDbG9zZXN0TGFuZ3VhZ2VJbnRsKGVsZW1lbnQpIHtcbiAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAvLyBpdCdzIE9LIGlmIHdlIGRvbid0IGhhdmUgdGhlIDQgbGV0dGVyIGxhbmd1YWdlIGZpbGUgZm9yIGl0XG4gICAgLy8gNCBsZXR0ZXIgbGFuZ3VhZ2UgY29kZSBuZWVkZWQgZm9yIGZvcm1hdHRpbmcgbnVtYmVyc1xuICAgIGNvbnN0IGNsb3Nlc3RFbGVtZW50ID0gKF9hID0gY2xvc2VzdEVsZW1lbnRDcm9zc1NoYWRvd0JvdW5kYXJ5KGVsZW1lbnQsIFwiW2xhbmddXCIpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAoX2MgPSAoX2IgPSBlbGVtZW50LnNoYWRvd1Jvb3QpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5vd25lckRvY3VtZW50KSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuZG9jdW1lbnRFbGVtZW50O1xuICAgIC8vIGxhbmd1YWdlIHNldCBieSB0aGUgY2FsbGluZyBhcHBsaWNhdGlvbiBvciBicm93c2VyLiBkZWZhdWx0cyB0byBlbmdsaXNoLlxuICAgIGNvbnN0IGxhbmcgPSAoKGNsb3Nlc3RFbGVtZW50ID09PSBudWxsIHx8IGNsb3Nlc3RFbGVtZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjbG9zZXN0RWxlbWVudC5sYW5nKSB8fCAobmF2aWdhdG9yID09PSBudWxsIHx8IG5hdmlnYXRvciA9PT0gdm9pZCAwID8gdm9pZCAwIDogbmF2aWdhdG9yLmxhbmd1YWdlKSB8fCBcImVuXCIpLnRvTG93ZXJDYXNlKCk7XG4gICAgaWYgKGxhbmd1YWdlTWFwLmhhcyhsYW5nKSkge1xuICAgICAgICByZXR1cm4gbGFuZ3VhZ2VNYXAuZ2V0KGxhbmcpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKGxhbmd1YWdlTWFwLmhhcyhsYW5nLnNsaWNlKDAsIDIpKSkge1xuICAgICAgICAgICAgLy8gd2Ugc3VwcG9ydCB0aGUgMiBsZXR0ZXIgY29kZWQgbGFuZ3VhZ2VcbiAgICAgICAgICAgIC8vIGUuZy4gaXQtQ0ggdnMgaXRcbiAgICAgICAgICAgIHJldHVybiBsYW5nO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFwiZW5cIjtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGZldGNoTG9jYWxlU3RyaW5nc0ZvckNvbXBvbmVudChjb21wb25lbnROYW1lLCBsb2NhbGUpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBmZXRjaChnZXRBc3NldFBhdGgoYC4uL2FyY2dpcy1hcHAtYXNzZXRzL2kxOG4vJHtjb21wb25lbnROYW1lfS5pMThuLiR7bG9jYWxlfS5qc29uYCkpLnRoZW4oKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgaWYgKHJlc3VsdC5vaylcbiAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdC5qc29uKCkpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHJlamVjdCgpO1xuICAgICAgICB9LCAoKSA9PiByZWplY3QoKSk7XG4gICAgfSk7XG59XG5jb25zdCBzdHJpbmdDYWNoZSA9IHt9O1xuZnVuY3Rpb24gZmV0Y2hMb2NhbGVTdHJpbmdzRnJvbUNhY2hlKGNvbXBvbmVudE5hbWUsIGxvY2FsZSkge1xuICAgIGNvbnN0IGlkID0gYCR7Y29tcG9uZW50TmFtZX0ke2xvY2FsZX1gO1xuICAgIGlmICghc3RyaW5nQ2FjaGVbaWRdKSB7XG4gICAgICAgIHN0cmluZ0NhY2hlW2lkXSA9IGZldGNoTG9jYWxlU3RyaW5nc0ZvckNvbXBvbmVudChjb21wb25lbnROYW1lLCBsb2NhbGUpO1xuICAgIH1cbiAgICByZXR1cm4gc3RyaW5nQ2FjaGVbaWRdO1xufVxuLyoqXG4gKiBHZXQgc3RyaW5ncyBhbmQgbGFuZ3VhZ2UgY29kZXMuXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIDIgbGFuZ3VhZ2UgY29kZXMuXG4gKiBUaGUgZmlyc3Qgb25lIHJldHVybnMgYSBjb2RlIHRoYXQncyBhbHNvIHN1cHBvcnRlZCBhcyBhIGxhbmd1YWdlIGZpbGUuXG4gKiBUaGUgc2Vjb25kIG9uZSByZXR1cm5zIGEgY29kZSB3aGVyZSB0aGVyZSBpcyBzdXBwb3J0IGZvciB0aGUgZmlyc3QgMiBsZXR0ZXJzIG9mIHRoZSBjb2RlIGFzIHBhcnQgb2YgYSBsYW5ndWFnZSBmaWxlLFxuICogYnV0IHdpbGwgcmV0dXJuIHRoZSBvcmlnaW5hbCA0IGxldHRlciBjb2RlIGZyb20gdGhlIHBhZ2UuXG4gKiBFLmcuIEZvciBcIml0LWNoXCIgaXQgd2lsbCByZXR1cm4gXCJpdFwiIGFzIHRoZSBmaXJzdCBsYW5ndWFnZSBjb2RlIGFuZCBcIml0LWNoXCIgYXMgdGhlIHNlY29uZC5cbiAqIFRoZSBzZWNvbmQgb25lIGlzIHJlcXVpcmVkIGZvciBlc3JpLmludGwuc2V0TG9jYWxlKCkgdG8gZ2V0IHRoZSBjb3JyZWN0IGZvcm1hdHRpbmcuXG4gKlxuICogSWYgYSB0YWdOYW1lIGlzIHByb3ZpZGVkIGl0IHdpbGwgb3ZlcndpdGUgdGhlIGVsZW1lbnQncyB0YWdOYW1lXG4gKlxuICogIEByZXR1cm4gWyBzdHJpbmdzLCBmaXJzdCBsYW5ndWFnZSBjb2RlLCBzZWNvbmQgbGFuZ3VhZ2UgY29kZV1cbiAqL1xuYXN5bmMgZnVuY3Rpb24gZ2V0TG9jYWxlQ29tcG9uZW50U3RyaW5ncyhlbGVtZW50LCB0YWdOYW1lKSB7XG4gICAgY29uc3QgY29tcG9uZW50TmFtZSA9IHRhZ05hbWUgfHwgZWxlbWVudC50YWdOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgY29uc3QgY29tcG9uZW50TGFuZ3VhZ2UgPSBnZXRDb21wb25lbnRDbG9zZXN0TGFuZ3VhZ2UoZWxlbWVudCk7XG4gICAgY29uc3QgY29tcG9uZW50TGFuZ3VhZ2VJbnRsID0gZ2V0Q29tcG9uZW50Q2xvc2VzdExhbmd1YWdlSW50bChlbGVtZW50KTtcbiAgICBsZXQgc3RyaW5ncztcbiAgICB0cnkge1xuICAgICAgICBzdHJpbmdzID0gYXdhaXQgZmV0Y2hMb2NhbGVTdHJpbmdzRnJvbUNhY2hlKGNvbXBvbmVudE5hbWUsIGNvbXBvbmVudExhbmd1YWdlKTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgY29uc29sZS53YXJuKGBubyBsb2NhbGUgZm9yICR7Y29tcG9uZW50TmFtZX0gKCR7Y29tcG9uZW50TGFuZ3VhZ2V9KSBsb2FkaW5nIGRlZmF1bHQgbG9jYWxlIGVuLmApO1xuICAgICAgICBzdHJpbmdzID0gYXdhaXQgZmV0Y2hMb2NhbGVTdHJpbmdzRnJvbUNhY2hlKGNvbXBvbmVudE5hbWUsIFwiZW5cIik7XG4gICAgfVxuICAgIHJldHVybiBbc3RyaW5ncywgY29tcG9uZW50TGFuZ3VhZ2UsIGNvbXBvbmVudExhbmd1YWdlSW50bF07XG59XG5cbmV4cG9ydCB7IGdldENvbXBvbmVudENsb3Nlc3RMYW5ndWFnZSBhcyBhLCBnZXRMb2NhbGVDb21wb25lbnRTdHJpbmdzIGFzIGcgfTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bG9jYWxlLTA1MGI2ZGI5LmpzLm1hcCIsIi8qIVxuICogQWxsIG1hdGVyaWFsIGNvcHlyaWdodCBFU1JJLCBBbGwgUmlnaHRzIFJlc2VydmVkLCB1bmxlc3Mgb3RoZXJ3aXNlIHNwZWNpZmllZC5cbiAqIHY0LjAuNThcbiAqL1xuaW1wb3J0IHsgQyBhcyBDQVRFR09SWV9CQVNFX1BBVEgsIGEgYXMgZ2V0Q2F0ZWdvcnlVSVBhdGggfSBmcm9tICcuL2NhdGVnb3JpZXMtY2ExMzQwMDUuanMnO1xuXG4vLyBUT0RPOiBhZGQgdW5pdCB0ZXN0c1xuY29uc3QgZ2V0TmV3Q2F0ZWdvcnlTY2hlbWFGcm9tTW92ZSA9IChjYXRlZ29yeSwgeyBmcm9tQ2F0ZWdvcnk6IHsgcGF0aDogZnJvbVBhdGggfSwgdG9DYXRlZ29yeTogeyBwYXRoOiB0b1BhdGggfSwgZnJvbUluZGV4LCB0b0luZGV4IH0pID0+IHtcbiAgICAvLyBDb3B5IHNpbmNlIHRoaXMgd2lsbCBiZSBhIGRlc3RydWN0aXZlIG9wZXJhdGlvblxuICAgIGNvbnN0IHVpQ2F0ZWdvcnkgPSBzdHJ1Y3R1cmVkQ2xvbmUoY2F0ZWdvcnkpO1xuICAgIGNvbnN0IGZyb21DYXRlZ29yeSA9IGdldENhdGVnb3J5RnJvbVBhdGgodWlDYXRlZ29yeSwgZnJvbVBhdGgpO1xuICAgIGxldCB0b0NhdGVnb3J5ID0gZnJvbUNhdGVnb3J5O1xuICAgIGlmIChmcm9tUGF0aCAhPT0gdG9QYXRoKSB7XG4gICAgICAgIHRvQ2F0ZWdvcnkgPSBnZXRDYXRlZ29yeUZyb21QYXRoKHVpQ2F0ZWdvcnksIHRvUGF0aCk7XG4gICAgfVxuICAgIGNvbnN0IFtyZW1vdmVkXSA9IGZyb21DYXRlZ29yeS50YXJnZXRDYXRlZ29yeS5jYXRlZ29yaWVzLnNwbGljZShmcm9tSW5kZXgsIDEpO1xuICAgIHRvQ2F0ZWdvcnkudGFyZ2V0Q2F0ZWdvcnkuY2F0ZWdvcmllcy5zcGxpY2UodG9JbmRleCwgMCwgcmVtb3ZlZCk7XG4gICAgcmV0dXJuIGdldENhdGVnb3J5U2NoZW1hRnJvbVVJQ2F0ZWdvcnkodWlDYXRlZ29yeSk7XG59O1xuY29uc3QgZ2V0TmV3Q2F0ZWdvcnlTY2hlbWFGcm9tVGl0bGVDaGFuZ2UgPSAoY2F0ZWdvcnksIHsgbmV3VGl0bGUsIHBhdGggfSkgPT4ge1xuICAgIGNvbnN0IHVpQ2F0ZWdvcnkgPSBzdHJ1Y3R1cmVkQ2xvbmUoY2F0ZWdvcnkpO1xuICAgIGNvbnN0IGNhdGVnb3J5VG9DaGFuZ2UgPSBnZXRDYXRlZ29yeUZyb21QYXRoKHVpQ2F0ZWdvcnksIHBhdGgpO1xuICAgIGNhdGVnb3J5VG9DaGFuZ2UudGFyZ2V0Q2F0ZWdvcnkudGl0bGUgPSBuZXdUaXRsZTtcbiAgICByZXR1cm4gZ2V0Q2F0ZWdvcnlTY2hlbWFGcm9tVUlDYXRlZ29yeSh1aUNhdGVnb3J5KTtcbn07XG5jb25zdCBnZXROZXdDYXRlZ29yeVNjaGVtYUZyb21DYXRlZ29yeUFkZCA9IChjYXRlZ29yeSwgeyBuZXdUaXRsZSwgcGF0aCB9KSA9PiB7XG4gICAgY29uc3QgdWlDYXRlZ29yeSA9IHN0cnVjdHVyZWRDbG9uZShjYXRlZ29yeSk7XG4gICAgLy8gUmVtb3ZlIHRoZSBsYXN0IHBhcnQgc2luY2UgaXQncyBqdXN0IHRoZSBwbGFjZWhvbGRlclxuICAgIC8vIGUuZy4gYC9jYXRlZ29yaWVzL2NhdGVnb3J5IDEvbmV3LWlucHV0YCAtPiBgL2NhdGVnb3JpZXMvY2F0ZWdvcnkgMWBcbiAgICBjb25zdCBjb250YWluZXJQYXRoID0gcGF0aC5yZXBsYWNlKC9cXC9bXi9dKyQvLCBcIlwiKTtcbiAgICBpZiAoY29udGFpbmVyUGF0aCkge1xuICAgICAgICBjb25zdCB7IHRhcmdldENhdGVnb3J5IH0gPSBnZXRDYXRlZ29yeUZyb21QYXRoKHVpQ2F0ZWdvcnksIGNvbnRhaW5lclBhdGgpO1xuICAgICAgICB0YXJnZXRDYXRlZ29yeS5jYXRlZ29yaWVzLnB1c2goeyB0aXRsZTogbmV3VGl0bGUsIGNhdGVnb3JpZXM6IFtdLCBjb3VudDogMCwgcGF0aDogbnVsbCB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIG1lYW5zIHdlJ3JlIGFkZGluZyBhIHJvb3QgbGV2ZWwgY2F0ZWdvcnkgd2hlbiB0aGVyZSBpcyBubyBjYXRlZ29yeSB5ZXRcbiAgICAgICAgICpcbiAgICAgICAgICogQ2FuIGhhcHBlbnMgd2hlbiB3ZSBmaXJzdCBzZXQgdXAgdGhlIGNhdGVnb3J5IHNjaGVtYVxuICAgICAgICAgKi9cbiAgICAgICAgdWlDYXRlZ29yeS5jYXRlZ29yaWVzLnB1c2goeyB0aXRsZTogbmV3VGl0bGUsIGNhdGVnb3JpZXM6IFtdLCBjb3VudDogMCwgcGF0aDogbnVsbCB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGdldENhdGVnb3J5U2NoZW1hRnJvbVVJQ2F0ZWdvcnkodWlDYXRlZ29yeSk7XG59O1xuY29uc3QgZ2V0TmV3Q2F0ZWdvcnlTY2hlbWFGcm9tRGVsZXRlID0gKGNhdGVnb3J5LCB7IHBhdGggfSkgPT4ge1xuICAgIGNvbnN0IHVpQ2F0ZWdvcnkgPSBzdHJ1Y3R1cmVkQ2xvbmUoY2F0ZWdvcnkpO1xuICAgIGNvbnN0IHsgdGFyZ2V0SW5kZXgsIHBhcmVudENhdGVnb3J5IH0gPSBnZXRDYXRlZ29yeUZyb21QYXRoKHVpQ2F0ZWdvcnksIHBhdGgpO1xuICAgIHBhcmVudENhdGVnb3J5ID09PSBudWxsIHx8IHBhcmVudENhdGVnb3J5ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJlbnRDYXRlZ29yeS5jYXRlZ29yaWVzLnNwbGljZSh0YXJnZXRJbmRleCwgMSk7XG4gICAgcmV0dXJuIGdldENhdGVnb3J5U2NoZW1hRnJvbVVJQ2F0ZWdvcnkodWlDYXRlZ29yeSk7XG59O1xuLy8gKiAtLS0gVXRpbHNcbi8vIFBhdGggd2Ugd2FudCB0byByZW1vdmUgdGhlIGJhc2UgcGF0aCBzaW5jZSB3ZSBjb3VudCByb290IGFzIDB0aCBsZXZlbCB0aGVuIGFsc28gcmVtb3ZlIHRoZSBiZWdpbm5pbmcgYC9gIHRvIGF2b2lkIGVtcHR5IHN0cmluZ1xuY29uc3QgZ2V0UGF0aExlbmd0aCA9IChwYXRoKSA9PiB7IHZhciBfYTsgcmV0dXJuIChfYSA9IHBhdGggPT09IG51bGwgfHwgcGF0aCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGF0aC5yZXBsYWNlKENBVEVHT1JZX0JBU0VfUEFUSCwgXCJcIikuc2xpY2UoMSkuc3BsaXQoXCIvXCIpLmxlbmd0aCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMDsgfTtcbi8qKlxuICogR2V0IHRoZSBjYXRlZ29yeSBmcm9tIHNjaGVtYSBiYXNlZCBvbiB0aGUgcGF0aFxuICovXG5jb25zdCBnZXRDYXRlZ29yeUZyb21QYXRoID0gKHVpQ2F0ZWdvcnksIHBhdGgpID0+IHtcbiAgICBpZiAocGF0aCA9PSBudWxsIHx8IHBhdGggPT09IENBVEVHT1JZX0JBU0VfUEFUSCkge1xuICAgICAgICAvLyBSb290IGxldmVsXG4gICAgICAgIHJldHVybiB7IHRhcmdldENhdGVnb3J5OiB1aUNhdGVnb3J5LCB0YXJnZXRJbmRleDogMSwgcGFyZW50Q2F0ZWdvcnk6IG51bGwgfTtcbiAgICB9XG4gICAgLy8gUGF0aCBzdGFydHMgd2l0aCBgL2Agc28gcmVtb3ZlIGl0XG4gICAgY29uc3QgcGF0aFBhcnRzID0gcGF0aC5zbGljZSgxKS5zcGxpdChcIi9cIik7XG4gICAgbGV0IGN1clBhdGggPSBwYXRoLmluZGV4T2YoQ0FURUdPUllfQkFTRV9QQVRIKSA9PT0gMCA/IGdldENhdGVnb3J5VUlQYXRoKFwiXCIsIHsgdGl0bGU6IHBhdGhQYXJ0cy5zaGlmdCgpIH0pIDogXCJcIjtcbiAgICBsZXQgcGFyZW50Q2F0ZWdvcnkgPSBudWxsO1xuICAgIGxldCB0YXJnZXRDYXRlZ29yeSA9IHVpQ2F0ZWdvcnk7XG4gICAgbGV0IHRhcmdldEluZGV4ID0gMDtcbiAgICBkbyB7XG4gICAgICAgIGN1clBhdGggPSBnZXRDYXRlZ29yeVVJUGF0aChjdXJQYXRoLCB7IHRpdGxlOiBwYXRoUGFydHMuc2hpZnQoKSB9KTtcbiAgICAgICAgcGFyZW50Q2F0ZWdvcnkgPSB0YXJnZXRDYXRlZ29yeTtcbiAgICAgICAgdGFyZ2V0SW5kZXggPSB0YXJnZXRDYXRlZ29yeS5jYXRlZ29yaWVzLmZpbmRJbmRleCgoc3ViY2F0ZWdvcnkpID0+IHN1YmNhdGVnb3J5LnBhdGggPT09IGN1clBhdGgpO1xuICAgICAgICB0YXJnZXRDYXRlZ29yeSA9IHRhcmdldENhdGVnb3J5LmNhdGVnb3JpZXNbdGFyZ2V0SW5kZXhdO1xuICAgIH0gd2hpbGUgKHBhdGhQYXJ0cy5sZW5ndGggPiAwICYmIHRhcmdldENhdGVnb3J5LmNhdGVnb3JpZXMubGVuZ3RoKTtcbiAgICByZXR1cm4geyB0YXJnZXRDYXRlZ29yeSwgdGFyZ2V0SW5kZXgsIHBhcmVudENhdGVnb3J5IH07XG59O1xuLyoqXG4gKiBDcmVhdGUgYSBuZXN0ZWQgY2F0ZWdvcnkgc2NoZW1hIGZyb20gdGhlIGFnZ3JlZ2F0ZWQgc2VhcmNoIHJlc3VsdCBzdGFydGluZyBmcm9tIHJvb3RcbiAqL1xuY29uc3QgZ2V0VUlDYXRlZ29yeUZyb21DYXRlZ29yeVNjaGVtYSA9IChjYXRlZ29yeVNjaGVtYSwgY2F0ZWdvcnlBZ2dyZWdhdGlvbkRhdGEpID0+IHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIHJldHVybiAoe1xuICAgICAgICB0aXRsZTogXCJcIixcbiAgICAgICAgcGF0aDogbnVsbCxcbiAgICAgICAgY291bnQ6IChfYiA9IChfYSA9IGNhdGVnb3J5QWdncmVnYXRpb25EYXRhLmZpZWxkVmFsdWVzLmZpbmQoKGZpZWxkVmFsdWUpID0+IGZpZWxkVmFsdWUudmFsdWUgPT09IENBVEVHT1JZX0JBU0VfUEFUSCkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jb3VudCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogMCxcbiAgICAgICAgY2F0ZWdvcmllczogZ2V0VUlDYXRlZ29yeUZyb21DYXRlZ29yeVNjaGVtYVJlY3Vyc2l2ZShudWxsLCBjYXRlZ29yeVNjaGVtYSwgY2F0ZWdvcnlBZ2dyZWdhdGlvbkRhdGEpXG4gICAgfSk7XG59O1xuY29uc3QgZ2V0Q2F0ZWdvcnlTY2hlbWFGcm9tVUlDYXRlZ29yeSA9ICh1aUNhdGVnb3J5KSA9PiB1aUNhdGVnb3J5LmNhdGVnb3JpZXMubWFwKGdldENhdGVnb3J5RnJvbVVJQ2F0ZWdvcnkpO1xuY29uc3QgZ2V0Q2F0ZWdvcnlGcm9tVUlDYXRlZ29yeSA9ICh1aUNhdGVnb3J5KSA9PiAoe1xuICAgIHRpdGxlOiB1aUNhdGVnb3J5LnRpdGxlLFxuICAgIGNhdGVnb3JpZXM6IHVpQ2F0ZWdvcnkuY2F0ZWdvcmllcy5tYXAoZ2V0Q2F0ZWdvcnlGcm9tVUlDYXRlZ29yeSlcbn0pO1xuY29uc3QgZ2V0VUlDYXRlZ29yeUZyb21DYXRlZ29yeVNjaGVtYVJlY3Vyc2l2ZSA9IChwYXJlbnRQYXRoLCBjYXRlZ29yeVNjaGVtYSwgY2F0ZWdvcnlBZ2dyZWdhdGlvbkRhdGEpID0+IHtcbiAgICByZXR1cm4gY2F0ZWdvcnlTY2hlbWEubWFwKChjYXRlZ29yeSkgPT4ge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBjb25zdCBwYXRoID0gZ2V0Q2F0ZWdvcnlVSVBhdGgocGFyZW50UGF0aCAhPT0gbnVsbCAmJiBwYXJlbnRQYXRoICE9PSB2b2lkIDAgPyBwYXJlbnRQYXRoIDogQ0FURUdPUllfQkFTRV9QQVRILCBjYXRlZ29yeSk7XG4gICAgICAgIGNvbnN0IGNhdGVnb3J5Q291bnQgPSAoX2EgPSBjYXRlZ29yeUFnZ3JlZ2F0aW9uRGF0YS5maWVsZFZhbHVlcy5maW5kKChmaWVsZFZhbHVlKSA9PiBmaWVsZFZhbHVlLnZhbHVlID09PSBwYXRoKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNvdW50O1xuICAgICAgICBjb25zdCBzdWJjYXRlZ29yaWVzID0gZ2V0VUlDYXRlZ29yeUZyb21DYXRlZ29yeVNjaGVtYVJlY3Vyc2l2ZShwYXRoLCAoX2IgPSBjYXRlZ29yeS5jYXRlZ29yaWVzKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBbXSwgY2F0ZWdvcnlBZ2dyZWdhdGlvbkRhdGEpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdGl0bGU6IGNhdGVnb3J5LnRpdGxlLFxuICAgICAgICAgICAgcGF0aCxcbiAgICAgICAgICAgIGNvdW50OiBjYXRlZ29yeUNvdW50ICE9PSBudWxsICYmIGNhdGVnb3J5Q291bnQgIT09IHZvaWQgMCA/IGNhdGVnb3J5Q291bnQgOiAwLFxuICAgICAgICAgICAgY2F0ZWdvcmllczogc3ViY2F0ZWdvcmllc1xuICAgICAgICB9O1xuICAgIH0pO1xufTtcbmNvbnN0IGNvdW50TnVtQ2F0ZWdvcmllcyA9IChjYXRlZ29yeVNjaGVtYSkgPT4ge1xuICAgIC8vICsgMSBpcyBpdHNlbGZcbiAgICByZXR1cm4gY2F0ZWdvcnlTY2hlbWEucmVkdWNlKChhY2MsIGN1cikgPT4geyB2YXIgX2E7IHJldHVybiBhY2MgKyAxICsgY291bnROdW1DYXRlZ29yaWVzKChfYSA9IGN1ci5jYXRlZ29yaWVzKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBbXSk7IH0sIDApO1xufTtcbmNvbnN0IGNoZWNrTmV3Q2F0ZWdvcnlUaXRsZVZhbGlkID0gKHsgdGFyZ2V0Q2F0ZWdvcnksIHRhcmdldFBhcmVudENhdGVnb3J5IH0pID0+IHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgY2F0ZWdvcnlMb3dlckNhc2VUaXRsZSA9IChfYSA9IHRhcmdldENhdGVnb3J5LnRpdGxlLnRvTG9jYWxlTG93ZXJDYXNlKCkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS50cmltKCk7XG4gICAgaWYgKCFjYXRlZ29yeUxvd2VyQ2FzZVRpdGxlKSB7XG4gICAgICAgIHJldHVybiBcImVtcHR5VGl0bGVcIjtcbiAgICB9XG4gICAgaWYgKGNhdGVnb3J5TG93ZXJDYXNlVGl0bGUubGVuZ3RoID4gTUFYX0NBVEVHT1JZX05BTUVfTEVOR1RIKSB7XG4gICAgICAgIHJldHVybiBcIm1heENoYXJhY3RlclwiO1xuICAgIH1cbiAgICAvLyBObyBkdXBsaWNhdGUgY2F0ZWdvcnkgbmFtZSBvbiB0aGUgc2FtZSBsZXZlbFxuICAgIGlmICh0YXJnZXRQYXJlbnRDYXRlZ29yeS5jYXRlZ29yaWVzLnNvbWUoKGNhdGVnb3J5KSA9PiBjYXRlZ29yeS50aXRsZS50b0xvd2VyQ2FzZSgpID09PSBjYXRlZ29yeUxvd2VyQ2FzZVRpdGxlICYmIGNhdGVnb3J5LnBhdGggIT09IHRhcmdldENhdGVnb3J5LnBhdGgpKSB7XG4gICAgICAgIHJldHVybiBcImRlc3RpbmF0aW9uSGFzU2FtZU5hbWVcIjtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59O1xuY29uc3QgTUFYX0NBVEVHT1JZX05BTUVfTEVOR1RIID0gMTAwO1xuXG5leHBvcnQgeyBNQVhfQ0FURUdPUllfTkFNRV9MRU5HVEggYXMgTSwgZ2V0TmV3Q2F0ZWdvcnlTY2hlbWFGcm9tRGVsZXRlIGFzIGEsIGdldENhdGVnb3J5RnJvbVBhdGggYXMgYiwgY2hlY2tOZXdDYXRlZ29yeVRpdGxlVmFsaWQgYXMgYywgZ2V0TmV3Q2F0ZWdvcnlTY2hlbWFGcm9tVGl0bGVDaGFuZ2UgYXMgZCwgZ2V0TmV3Q2F0ZWdvcnlTY2hlbWFGcm9tQ2F0ZWdvcnlBZGQgYXMgZSwgZ2V0UGF0aExlbmd0aCBhcyBmLCBnZXROZXdDYXRlZ29yeVNjaGVtYUZyb21Nb3ZlIGFzIGcsIGdldFVJQ2F0ZWdvcnlGcm9tQ2F0ZWdvcnlTY2hlbWEgYXMgaCwgY291bnROdW1DYXRlZ29yaWVzIGFzIGkgfTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbC0yYTBlMmYwOC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=