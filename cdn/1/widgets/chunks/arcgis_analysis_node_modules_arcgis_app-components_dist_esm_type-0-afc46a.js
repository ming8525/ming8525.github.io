"use strict";
(self["webpackChunkexb_client"] = self["webpackChunkexb_client"] || []).push([["vendors-extensions_widgets_arcgis_analysis_node_modules_arcgis_app-components_dist_esm_type-0-afc46a"],{

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/type-0ace5d2e.js":
/*!**********************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/type-0ace5d2e.js ***!
  \**********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   a: () => (/* binding */ createTypeRendererFromExisting),
/* harmony export */   b: () => (/* binding */ getOtherUniqueValueClasses),
/* harmony export */   c: () => (/* binding */ createTypeRenderer),
/* harmony export */   d: () => (/* binding */ getUniqueGroupName),
/* harmony export */   e: () => (/* binding */ getDateLabel),
/* harmony export */   f: () => (/* binding */ separateMergedClasses),
/* harmony export */   g: () => (/* binding */ getOtherUniqueValueInfos),
/* harmony export */   s: () => (/* binding */ sameTypeField)
/* harmony export */ });
/* harmony import */ var _raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./raster-unique-value-0976ec7f.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/raster-unique-value-0976ec7f.js");
/* harmony import */ var _loadModules_b4ac1247_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./loadModules-b4ac1247.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/loadModules-b4ac1247.js");
/* harmony import */ var _commonFunctions_b0830e9e_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./commonFunctions-b0830e9e.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/commonFunctions-b0830e9e.js");
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v4.0.58
 */




/**
 * Updates the layer with a Color renderer with default settings
 * @param options: options
 */
function createTypeRenderer(options) {
    var _a;
    const { layer: smLayer, mapImageSublayer, mapView, modules } = _raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.s;
    const layer = smLayer;
    options = options || {};
    const extras = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.m)((0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.h)(layer));
    const fieldInfo = options.fieldInfos[0];
    return modules.TypeCreator.createRenderer({
        layer,
        view: mapView,
        field: fieldInfo.field,
        valueExpression: fieldInfo.expression,
        valueExpressionTitle: fieldInfo.expressionTitle,
        numTypes: options.numTypes || 10,
        sortBy: options.sortBy || "count",
        typeScheme: options.typeScheme || (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__._)(),
        returnAllCodedValues: true,
        outlineOptimizationEnabled: mapImageSublayer
            ? false
            : (0,_commonFunctions_b0830e9e_js__WEBPACK_IMPORTED_MODULE_2__.i)(options.outlineOptimizationEnabled)
                ? options.outlineOptimizationEnabled
                : true,
        sizeOptimizationEnabled: mapImageSublayer
            ? false
            : (0,_commonFunctions_b0830e9e_js__WEBPACK_IMPORTED_MODULE_2__.i)(options.sizeOptimizationEnabled)
                ? options.sizeOptimizationEnabled
                : true,
        legendOptions: options.legendOptions,
        defaultSymbolEnabled: true,
        forBinning: ((_a = layer.featureReduction) === null || _a === void 0 ? void 0 : _a.type) === "binning"
    }).then((result) => {
        //console.log("modules.TypeCreator.createRenderer", result);
        if (!result.excludedUniqueValueInfos.length) {
            result.renderer.defaultLabel = null;
            result.renderer.defaultSymbol = null;
        }
        if (sameTypeField(options)) {
            // re-use type renderer
            const renderer = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.h)(layer).clone();
            const sizeAutoVisVar = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.a)(renderer, "size", "auto");
            const sizeOutlineVisVar = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.a)(renderer, "size", "outline");
            result.renderer.visualVariables = [];
            if (sizeAutoVisVar) {
                result.renderer.visualVariables = result.renderer.visualVariables || [];
                result.renderer.visualVariables.push(sizeAutoVisVar);
            }
            if (sizeOutlineVisVar) {
                result.renderer.visualVariables = result.renderer.visualVariables || [];
                result.renderer.visualVariables.push(sizeOutlineVisVar);
            }
            result.renderer.uniqueValueInfos = renderer.uniqueValueInfos;
            // if we keep the uniqueValueInfos, we also need to keep the additional fields
            result.renderer.field2 = renderer.field2;
            result.renderer.field3 = renderer.field3;
            if ((0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.q)(layer) && (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.g)() === "type-size") {
                // switch markers to polygons
                const polygonSymbol = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.S)(layer, mapView);
                const infos = result.renderer.uniqueValueInfos.slice();
                infos.map((valueInfo) => {
                    const color = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.t)(valueInfo.symbol);
                    valueInfo.symbol = polygonSymbol.clone();
                    (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.r)(valueInfo.symbol, color);
                });
                result.renderer.uniqueValueInfos = infos;
            }
        }
        (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.l)(extras, result.renderer);
        return Promise.resolve(result);
    }, (error) => Promise.reject(error));
}
/**
 * Creates a Type renderer with settings from current renderer
 * @param options: options, only contains what needs to be overwritten
 */
function createTypeRendererFromExisting(options) {
    var _a;
    const { layer: smLayer, mapImageSublayer, mapView, modules } = _raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.s;
    const layer = smLayer;
    options = options || [];
    let fieldInfo = options.fieldInfos ? options.fieldInfos[0] : null;
    const renderer = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.h)(layer);
    const extras = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.m)(renderer);
    const symbol = renderer.uniqueValueInfos && renderer.uniqueValueInfos.length ? renderer.uniqueValueInfos[0].symbol : null;
    const defaultSymbol = renderer.defaultSymbol;
    const defaultLabel = renderer.defaultLabel;
    // TODO need to keep ramp
    const fieldInfoChange = fieldInfo && (fieldInfo.field != renderer.field || fieldInfo.expression != renderer.valueExpression);
    options = options || {};
    return modules.TypeCreator.createRenderer({
        layer,
        view: mapView,
        field: fieldInfo ? fieldInfo.field : renderer.field,
        valueExpression: fieldInfo ? fieldInfo.expression : renderer.valueExpression,
        valueExpressionTitle: fieldInfo ? fieldInfo.expressionTitle : renderer.valueExpressionTitle,
        numTypes: options.numTypes || (fieldInfoChange ? 10 : renderer.uniqueValueInfos.length),
        sortBy: options.sortBy || "count",
        typeScheme: (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__._)(),
        outlineOptimizationEnabled: mapImageSublayer
            ? false
            : (0,_commonFunctions_b0830e9e_js__WEBPACK_IMPORTED_MODULE_2__.i)(options.outlineOptimizationEnabled)
                ? options.outlineOptimizationEnabled
                : !!extras.sizeOutlineVisVar,
        sizeOptimizationEnabled: mapImageSublayer
            ? false
            : (0,_commonFunctions_b0830e9e_js__WEBPACK_IMPORTED_MODULE_2__.i)(options.sizeOptimizationEnabled)
                ? options.sizeOptimizationEnabled
                : !!extras.sizeAutoVisVar,
        legendOptions: options.legendOptions || renderer.legendOptions,
        defaultSymbolEnabled: (0,_commonFunctions_b0830e9e_js__WEBPACK_IMPORTED_MODULE_2__.i)(options.defaultSymbolEnabled) || !!renderer.defaultSymbol,
        forBinning: ((_a = layer.featureReduction) === null || _a === void 0 ? void 0 : _a.type) === "binning"
    }).then((result) => {
        (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.l)(extras, result.renderer);
        if (symbol && result.renderer.uniqueValueInfos && result.renderer.uniqueValueInfos.length) {
            const infos = result.renderer.uniqueValueInfos.slice();
            infos.map((info) => {
                // keep the same symbol style, not the color
                const sym = symbol.clone();
                (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.r)(sym, (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.t)(info.symbol));
                info.symbol = sym;
            });
            result.renderer.uniqueValueInfos = infos;
        }
        if (defaultSymbol) {
            result.renderer.defaultSymbol = defaultSymbol;
            result.renderer.defaultLabel = defaultLabel;
        }
        return Promise.resolve(result);
    }, (error) => Promise.reject(error));
}
// From JS-API
// maybe in future use esri/smartMapping/support/utils.formatAnyDate(value: number | string | Date, options?: FormatAnyDateOptions | Nil): string
const dateFormatIntervalOptions = {
    // Display both date and time components:
    millisecond: "long-month-day-year-long-time",
    second: "long-month-day-year-long-time",
    minute: "long-month-day-year-short-time",
    hour: "long-month-day-year-short-time",
    // Just display the date component.
    day: "long-month-day-year",
    month: "long-month-day-year",
    // Just display the year.
    year: "year"
};
function getDateLabel(value, field) {
    const { allUniqueValues, locale, mapView, modules } = _raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.s;
    modules.intl.setLocale(locale);
    if ((field === null || field === void 0 ? void 0 : field.simpleFieldType) === _raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.w.DATE) {
        const dateFormat = allUniqueValues &&
            // @ts-ignore
            modules.rendererSupportUtils.calculateDateFormatInterval(allUniqueValues.map((uv) => uv.value));
        if (mapView.timeZone === "unknown") {
            return modules.intl.formatDate(value, Object.assign(Object.assign({}, modules.intl.convertDateFormatToIntlOptions(dateFormat ? dateFormatIntervalOptions[dateFormat] : "long-month-day-year")), { timeZone: "utc", timeZoneName: "shortOffset" }));
        }
        else {
            // known issues with formatting it-CH
            return modules.intl.formatDate(value, Object.assign(Object.assign({}, modules.intl.convertDateFormatToIntlOptions(dateFormat ? dateFormatIntervalOptions[dateFormat] : "long-month-day-year")), { timeZone: mapView.timeZone }));
        }
    }
    else {
        // date-only
        return modules.intl.formatDateOnly(value, modules.intl.convertDateFormatToIntlOptions("long-month-day-year"));
    }
}
function getOtherUniqueValueClasses() {
    const { allUniqueValues, layer, modules } = _raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.s;
    const renderer = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.h)(layer);
    if (!(allUniqueValues === null || allUniqueValues === void 0 ? void 0 : allUniqueValues.length) || !(0,_commonFunctions_b0830e9e_js__WEBPACK_IMPORTED_MODULE_2__.i)(allUniqueValues[0].count)) {
        return [];
    }
    let typeValues = [];
    renderer.uniqueValueGroups.forEach((uniqueValueGroup) => {
        const values = [];
        uniqueValueGroup.classes.forEach((uniqueValueClass) => uniqueValueClass.values.forEach((value) => values.push(`${value.value}`)));
        typeValues = typeValues.concat(values);
    });
    const otherInfos = allUniqueValues.filter((info) => typeValues.indexOf(`${info.value}`) === -1);
    const otherClasses = otherInfos.map((info) => {
        return new modules.UniqueValueClass({
            label: info.label,
            symbol: info.symbol,
            values: [
                {
                    value: info.value
                }
            ]
        });
    });
    return otherClasses;
}
function getOtherUniqueValueInfos() {
    const { allUniqueValues, layer } = _raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.s;
    const renderer = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.h)(layer);
    if (!(allUniqueValues === null || allUniqueValues === void 0 ? void 0 : allUniqueValues.length) || !(0,_commonFunctions_b0830e9e_js__WEBPACK_IMPORTED_MODULE_2__.i)(allUniqueValues[0].count)) {
        return [];
    }
    let typeValues = [];
    renderer.uniqueValueGroups.forEach((uniqueValueGroup) => {
        const values = [];
        uniqueValueGroup.classes.forEach((uniqueValueClass) => uniqueValueClass.values.forEach((value) => values.push(`${value.value}`)));
        typeValues = typeValues.concat(values);
    });
    const otherInfos = allUniqueValues.filter((info) => typeValues.indexOf(`${info.value}`) === -1);
    return otherInfos;
}
function getUniqueGroupName(groups) {
    const { strings } = _raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.s;
    let count = 1;
    let newGroupHeading = strings.panels.type.defaultGroupName.replace("${number}", count.toString());
    while (groups.find((group) => group.heading === newGroupHeading)) {
        newGroupHeading = strings.panels.type.defaultGroupName.replace("${number}", (++count).toString());
    }
    return newGroupHeading;
}
function sameTypeField(options) {
    const { layer } = _raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.s;
    if (["type", "type-size"].indexOf((0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.g)()) > -1) {
        const renderer = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.h)(layer);
        const renderFieldInfo = {
            field: renderer.field,
            expression: renderer.valueExpression,
            expressionTitle: renderer.valueExpressionTitle
        };
        if ((0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.x)(options.fieldInfos[0], renderFieldInfo)) {
            return true;
        }
    }
    return false;
}
function separateMergedClasses(group, classIdxs) {
    const { layer, mapView, modules } = _raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.s;
    const renderer = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.h)(layer);
    const field = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.u)(renderer.field);
    const isInt = field && ["small-integer", "integer", "big-integer", "long"].indexOf((0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.z)(field.layerField)) > -1;
    const isDate = (field === null || field === void 0 ? void 0 : field.simpleFieldType) === _raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.w.DATE;
    const isDateOnly = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.z)(field.layerField) === "date-only";
    const newClasses = [];
    const scheme = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__._)();
    let counter = 0;
    group.classes.forEach((uvClass, idx) => {
        var _a;
        if (uvClass.values.length === 1 || (classIdxs && classIdxs.indexOf(idx) === -1)) {
            newClasses.push(uvClass);
            counter++;
        }
        else if (!classIdxs || classIdxs.indexOf(idx) > -1) {
            const symbol = ["simple-marker", "simple-line", "simple-fill", "cim"].indexOf((_a = uvClass.symbol) === null || _a === void 0 ? void 0 : _a.type) > -1
                ? uvClass.symbol
                : (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.S)(layer, mapView, (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.g)());
            uvClass.values.forEach((value, idx) => {
                const newSymbol = modules.esriLang.clone(symbol);
                if (idx > 0) {
                    // change color
                    if (scheme) {
                        const color = scheme.colors[(group.classes.length + counter) % scheme.colors.length];
                        color && (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.r)(newSymbol, color);
                    }
                    else {
                        // just pick some colors from the primary scheme
                        const primaryRampColors = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.$)().colors;
                        const color = new modules.esriColor(primaryRampColors[(group.classes.length + counter) % 10]);
                        color && (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.r)(newSymbol, color);
                    }
                }
                const label = isDate || isDateOnly
                    ? this.getDateLabel(value.value, field)
                    : (field === null || field === void 0 ? void 0 : field.simpleFieldType) === _raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.w.NUMBER
                        ? __esri.intl.formatNumber(isInt ? parseInt(value.value) : parseFloat(value.value))
                        : value.value;
                newClasses.push(new modules.UniqueValueClass({
                    values: [new modules.UniqueValue({ value: value.value })],
                    label,
                    symbol: newSymbol
                }));
                counter++;
            });
        }
    });
    group.classes = newClasses;
}



//# sourceMappingURL=type-0ace5d2e.js.map

/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid2lkZ2V0cy9jaHVua3MvYXJjZ2lzX2FuYWx5c2lzX25vZGVfbW9kdWxlc19hcmNnaXNfYXBwLWNvbXBvbmVudHNfZGlzdF9lc21fdHlwZS0wLWFmYzQ2YS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ3dZO0FBQ3JXO0FBQzRCOztBQUUvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHFEQUFxRCxFQUFFLCtEQUFpQjtBQUNwRjtBQUNBO0FBQ0EsbUJBQW1CLG1FQUFnQixDQUFDLG1FQUFXO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxtRUFBYztBQUN4RDtBQUNBO0FBQ0E7QUFDQSxjQUFjLCtEQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYywrREFBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLG1FQUFXO0FBQ3hDLG1DQUFtQyxtRUFBUztBQUM1QyxzQ0FBc0MsbUVBQVM7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsbUVBQWEsV0FBVyxtRUFBZTtBQUN2RDtBQUNBLHNDQUFzQyxtRUFBZ0I7QUFDdEQ7QUFDQTtBQUNBLGtDQUFrQyxtRUFBYztBQUNoRDtBQUNBLG9CQUFvQixtRUFBZ0I7QUFDcEMsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLFFBQVEsbUVBQWlCO0FBQ3pCO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxxREFBcUQsRUFBRSwrREFBaUI7QUFDcEY7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLG1FQUFXO0FBQ2hDLG1CQUFtQixtRUFBZ0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixtRUFBYztBQUNsQztBQUNBO0FBQ0EsY0FBYywrREFBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsK0RBQVM7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLCtEQUFTO0FBQ3ZDO0FBQ0EsS0FBSztBQUNMLFFBQVEsbUVBQWlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsbUVBQWdCLE1BQU0sbUVBQWM7QUFDcEQ7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDRDQUE0QyxFQUFFLCtEQUFpQjtBQUMzRTtBQUNBLGtGQUFrRiwrREFBZ0I7QUFDbEc7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRkFBZ0YsOEhBQThILDhDQUE4QztBQUM1UDtBQUNBO0FBQ0E7QUFDQSxnRkFBZ0YsOEhBQThILDRCQUE0QjtBQUMxTztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxrQ0FBa0MsRUFBRSwrREFBaUI7QUFDakUscUJBQXFCLG1FQUFXO0FBQ2hDLHdHQUF3RywrREFBUztBQUNqSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUhBQXlILFlBQVk7QUFDckk7QUFDQSxLQUFLO0FBQ0wsOEVBQThFLFdBQVc7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxZQUFZLHlCQUF5QixFQUFFLCtEQUFpQjtBQUN4RCxxQkFBcUIsbUVBQVc7QUFDaEMsd0dBQXdHLCtEQUFTO0FBQ2pIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5SEFBeUgsWUFBWTtBQUNySTtBQUNBLEtBQUs7QUFDTCw4RUFBOEUsV0FBVztBQUN6RjtBQUNBO0FBQ0E7QUFDQSxZQUFZLFVBQVUsRUFBRSwrREFBaUI7QUFDekM7QUFDQSwwRUFBMEUsT0FBTztBQUNqRjtBQUNBLDBFQUEwRSxPQUFPO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRLEVBQUUsK0RBQWlCO0FBQ3ZDLHNDQUFzQyxtRUFBZTtBQUNyRCx5QkFBeUIsbUVBQVc7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksbUVBQWU7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSwwQkFBMEIsRUFBRSwrREFBaUI7QUFDekQscUJBQXFCLG1FQUFXO0FBQ2hDLGtCQUFrQixtRUFBUTtBQUMxQix1RkFBdUYsbUVBQVk7QUFDbkcsNkZBQTZGLCtEQUFnQjtBQUM3Ryx1QkFBdUIsbUVBQVk7QUFDbkM7QUFDQSxtQkFBbUIsbUVBQWM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsbUVBQWdCLGlCQUFpQixtRUFBZTtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsbUVBQWdCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxtRUFBb0I7QUFDdEU7QUFDQSxpQ0FBaUMsbUVBQWdCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0dBQWdHLCtEQUFnQjtBQUNoSDtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsb0JBQW9CO0FBQzNFO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxhQUFhO0FBQ2I7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFb087O0FBRXBPIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZXhiLWNsaWVudC8uL2V4dGVuc2lvbnMvd2lkZ2V0cy9hcmNnaXMvYW5hbHlzaXMvbm9kZV9tb2R1bGVzL0BhcmNnaXMvYXBwLWNvbXBvbmVudHMvZGlzdC9lc20vdHlwZS0wYWNlNWQyZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIEFsbCBtYXRlcmlhbCBjb3B5cmlnaHQgRVNSSSwgQWxsIFJpZ2h0cyBSZXNlcnZlZCwgdW5sZXNzIG90aGVyd2lzZSBzcGVjaWZpZWQuXG4gKiB2NC4wLjU4XG4gKi9cbmltcG9ydCB7IF8gYXMgZmluZFR5cGVTY2hlbWUsIGggYXMgZ2V0UmVuZGVyZXIsIGEgYXMgZ2V0VmlzVmFyLCBxIGFzIGlzUG9seWdvblR5cGUsIGcgYXMgZ2V0UmVuZGVyZXJUeXBlLCBTIGFzIGdldERlZmF1bHRTeW1ib2wsIHQgYXMgZ2V0U3ltYm9sQ29sb3IsIHIgYXMgYXBwbHlTeW1ib2xDb2xvciwgbCBhcyBhcHBseUV4dHJhVmlzVmFycywgcyBhcyBzbWFydE1hcHBpbmdTdGF0ZSwgbSBhcyBzYXZlRXh0cmFWaXNWYXJzLCB3IGFzIHNpbXBsZUZpZWxkVHlwZXMsIHggYXMgaXNTYW1lRmllbGRJbmZvLCB1IGFzIGdldEZpZWxkLCB6IGFzIGdldEZpZWxkVHlwZSwgJCBhcyBnZXRQcmltYXJ5VHlwZVNjaGVtZSB9IGZyb20gJy4vcmFzdGVyLXVuaXF1ZS12YWx1ZS0wOTc2ZWM3Zi5qcyc7XG5pbXBvcnQgJy4vbG9hZE1vZHVsZXMtYjRhYzEyNDcuanMnO1xuaW1wb3J0IHsgaSBhcyBpc0RlZmluZWQgfSBmcm9tICcuL2NvbW1vbkZ1bmN0aW9ucy1iMDgzMGU5ZS5qcyc7XG5cbi8qKlxuICogVXBkYXRlcyB0aGUgbGF5ZXIgd2l0aCBhIENvbG9yIHJlbmRlcmVyIHdpdGggZGVmYXVsdCBzZXR0aW5nc1xuICogQHBhcmFtIG9wdGlvbnM6IG9wdGlvbnNcbiAqL1xuZnVuY3Rpb24gY3JlYXRlVHlwZVJlbmRlcmVyKG9wdGlvbnMpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgeyBsYXllcjogc21MYXllciwgbWFwSW1hZ2VTdWJsYXllciwgbWFwVmlldywgbW9kdWxlcyB9ID0gc21hcnRNYXBwaW5nU3RhdGU7XG4gICAgY29uc3QgbGF5ZXIgPSBzbUxheWVyO1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIGNvbnN0IGV4dHJhcyA9IHNhdmVFeHRyYVZpc1ZhcnMoZ2V0UmVuZGVyZXIobGF5ZXIpKTtcbiAgICBjb25zdCBmaWVsZEluZm8gPSBvcHRpb25zLmZpZWxkSW5mb3NbMF07XG4gICAgcmV0dXJuIG1vZHVsZXMuVHlwZUNyZWF0b3IuY3JlYXRlUmVuZGVyZXIoe1xuICAgICAgICBsYXllcixcbiAgICAgICAgdmlldzogbWFwVmlldyxcbiAgICAgICAgZmllbGQ6IGZpZWxkSW5mby5maWVsZCxcbiAgICAgICAgdmFsdWVFeHByZXNzaW9uOiBmaWVsZEluZm8uZXhwcmVzc2lvbixcbiAgICAgICAgdmFsdWVFeHByZXNzaW9uVGl0bGU6IGZpZWxkSW5mby5leHByZXNzaW9uVGl0bGUsXG4gICAgICAgIG51bVR5cGVzOiBvcHRpb25zLm51bVR5cGVzIHx8IDEwLFxuICAgICAgICBzb3J0Qnk6IG9wdGlvbnMuc29ydEJ5IHx8IFwiY291bnRcIixcbiAgICAgICAgdHlwZVNjaGVtZTogb3B0aW9ucy50eXBlU2NoZW1lIHx8IGZpbmRUeXBlU2NoZW1lKCksXG4gICAgICAgIHJldHVybkFsbENvZGVkVmFsdWVzOiB0cnVlLFxuICAgICAgICBvdXRsaW5lT3B0aW1pemF0aW9uRW5hYmxlZDogbWFwSW1hZ2VTdWJsYXllclxuICAgICAgICAgICAgPyBmYWxzZVxuICAgICAgICAgICAgOiBpc0RlZmluZWQob3B0aW9ucy5vdXRsaW5lT3B0aW1pemF0aW9uRW5hYmxlZClcbiAgICAgICAgICAgICAgICA/IG9wdGlvbnMub3V0bGluZU9wdGltaXphdGlvbkVuYWJsZWRcbiAgICAgICAgICAgICAgICA6IHRydWUsXG4gICAgICAgIHNpemVPcHRpbWl6YXRpb25FbmFibGVkOiBtYXBJbWFnZVN1YmxheWVyXG4gICAgICAgICAgICA/IGZhbHNlXG4gICAgICAgICAgICA6IGlzRGVmaW5lZChvcHRpb25zLnNpemVPcHRpbWl6YXRpb25FbmFibGVkKVxuICAgICAgICAgICAgICAgID8gb3B0aW9ucy5zaXplT3B0aW1pemF0aW9uRW5hYmxlZFxuICAgICAgICAgICAgICAgIDogdHJ1ZSxcbiAgICAgICAgbGVnZW5kT3B0aW9uczogb3B0aW9ucy5sZWdlbmRPcHRpb25zLFxuICAgICAgICBkZWZhdWx0U3ltYm9sRW5hYmxlZDogdHJ1ZSxcbiAgICAgICAgZm9yQmlubmluZzogKChfYSA9IGxheWVyLmZlYXR1cmVSZWR1Y3Rpb24pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS50eXBlKSA9PT0gXCJiaW5uaW5nXCJcbiAgICB9KS50aGVuKChyZXN1bHQpID0+IHtcbiAgICAgICAgLy9jb25zb2xlLmxvZyhcIm1vZHVsZXMuVHlwZUNyZWF0b3IuY3JlYXRlUmVuZGVyZXJcIiwgcmVzdWx0KTtcbiAgICAgICAgaWYgKCFyZXN1bHQuZXhjbHVkZWRVbmlxdWVWYWx1ZUluZm9zLmxlbmd0aCkge1xuICAgICAgICAgICAgcmVzdWx0LnJlbmRlcmVyLmRlZmF1bHRMYWJlbCA9IG51bGw7XG4gICAgICAgICAgICByZXN1bHQucmVuZGVyZXIuZGVmYXVsdFN5bWJvbCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNhbWVUeXBlRmllbGQob3B0aW9ucykpIHtcbiAgICAgICAgICAgIC8vIHJlLXVzZSB0eXBlIHJlbmRlcmVyXG4gICAgICAgICAgICBjb25zdCByZW5kZXJlciA9IGdldFJlbmRlcmVyKGxheWVyKS5jbG9uZSgpO1xuICAgICAgICAgICAgY29uc3Qgc2l6ZUF1dG9WaXNWYXIgPSBnZXRWaXNWYXIocmVuZGVyZXIsIFwic2l6ZVwiLCBcImF1dG9cIik7XG4gICAgICAgICAgICBjb25zdCBzaXplT3V0bGluZVZpc1ZhciA9IGdldFZpc1ZhcihyZW5kZXJlciwgXCJzaXplXCIsIFwib3V0bGluZVwiKTtcbiAgICAgICAgICAgIHJlc3VsdC5yZW5kZXJlci52aXN1YWxWYXJpYWJsZXMgPSBbXTtcbiAgICAgICAgICAgIGlmIChzaXplQXV0b1Zpc1Zhcikge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5yZW5kZXJlci52aXN1YWxWYXJpYWJsZXMgPSByZXN1bHQucmVuZGVyZXIudmlzdWFsVmFyaWFibGVzIHx8IFtdO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5yZW5kZXJlci52aXN1YWxWYXJpYWJsZXMucHVzaChzaXplQXV0b1Zpc1Zhcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2l6ZU91dGxpbmVWaXNWYXIpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucmVuZGVyZXIudmlzdWFsVmFyaWFibGVzID0gcmVzdWx0LnJlbmRlcmVyLnZpc3VhbFZhcmlhYmxlcyB8fCBbXTtcbiAgICAgICAgICAgICAgICByZXN1bHQucmVuZGVyZXIudmlzdWFsVmFyaWFibGVzLnB1c2goc2l6ZU91dGxpbmVWaXNWYXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0LnJlbmRlcmVyLnVuaXF1ZVZhbHVlSW5mb3MgPSByZW5kZXJlci51bmlxdWVWYWx1ZUluZm9zO1xuICAgICAgICAgICAgLy8gaWYgd2Uga2VlcCB0aGUgdW5pcXVlVmFsdWVJbmZvcywgd2UgYWxzbyBuZWVkIHRvIGtlZXAgdGhlIGFkZGl0aW9uYWwgZmllbGRzXG4gICAgICAgICAgICByZXN1bHQucmVuZGVyZXIuZmllbGQyID0gcmVuZGVyZXIuZmllbGQyO1xuICAgICAgICAgICAgcmVzdWx0LnJlbmRlcmVyLmZpZWxkMyA9IHJlbmRlcmVyLmZpZWxkMztcbiAgICAgICAgICAgIGlmIChpc1BvbHlnb25UeXBlKGxheWVyKSAmJiBnZXRSZW5kZXJlclR5cGUoKSA9PT0gXCJ0eXBlLXNpemVcIikge1xuICAgICAgICAgICAgICAgIC8vIHN3aXRjaCBtYXJrZXJzIHRvIHBvbHlnb25zXG4gICAgICAgICAgICAgICAgY29uc3QgcG9seWdvblN5bWJvbCA9IGdldERlZmF1bHRTeW1ib2wobGF5ZXIsIG1hcFZpZXcpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGluZm9zID0gcmVzdWx0LnJlbmRlcmVyLnVuaXF1ZVZhbHVlSW5mb3Muc2xpY2UoKTtcbiAgICAgICAgICAgICAgICBpbmZvcy5tYXAoKHZhbHVlSW5mbykgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjb2xvciA9IGdldFN5bWJvbENvbG9yKHZhbHVlSW5mby5zeW1ib2wpO1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZUluZm8uc3ltYm9sID0gcG9seWdvblN5bWJvbC5jbG9uZSgpO1xuICAgICAgICAgICAgICAgICAgICBhcHBseVN5bWJvbENvbG9yKHZhbHVlSW5mby5zeW1ib2wsIGNvbG9yKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXN1bHQucmVuZGVyZXIudW5pcXVlVmFsdWVJbmZvcyA9IGluZm9zO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGFwcGx5RXh0cmFWaXNWYXJzKGV4dHJhcywgcmVzdWx0LnJlbmRlcmVyKTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShyZXN1bHQpO1xuICAgIH0sIChlcnJvcikgPT4gUHJvbWlzZS5yZWplY3QoZXJyb3IpKTtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIFR5cGUgcmVuZGVyZXIgd2l0aCBzZXR0aW5ncyBmcm9tIGN1cnJlbnQgcmVuZGVyZXJcbiAqIEBwYXJhbSBvcHRpb25zOiBvcHRpb25zLCBvbmx5IGNvbnRhaW5zIHdoYXQgbmVlZHMgdG8gYmUgb3ZlcndyaXR0ZW5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlVHlwZVJlbmRlcmVyRnJvbUV4aXN0aW5nKG9wdGlvbnMpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgeyBsYXllcjogc21MYXllciwgbWFwSW1hZ2VTdWJsYXllciwgbWFwVmlldywgbW9kdWxlcyB9ID0gc21hcnRNYXBwaW5nU3RhdGU7XG4gICAgY29uc3QgbGF5ZXIgPSBzbUxheWVyO1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IFtdO1xuICAgIGxldCBmaWVsZEluZm8gPSBvcHRpb25zLmZpZWxkSW5mb3MgPyBvcHRpb25zLmZpZWxkSW5mb3NbMF0gOiBudWxsO1xuICAgIGNvbnN0IHJlbmRlcmVyID0gZ2V0UmVuZGVyZXIobGF5ZXIpO1xuICAgIGNvbnN0IGV4dHJhcyA9IHNhdmVFeHRyYVZpc1ZhcnMocmVuZGVyZXIpO1xuICAgIGNvbnN0IHN5bWJvbCA9IHJlbmRlcmVyLnVuaXF1ZVZhbHVlSW5mb3MgJiYgcmVuZGVyZXIudW5pcXVlVmFsdWVJbmZvcy5sZW5ndGggPyByZW5kZXJlci51bmlxdWVWYWx1ZUluZm9zWzBdLnN5bWJvbCA6IG51bGw7XG4gICAgY29uc3QgZGVmYXVsdFN5bWJvbCA9IHJlbmRlcmVyLmRlZmF1bHRTeW1ib2w7XG4gICAgY29uc3QgZGVmYXVsdExhYmVsID0gcmVuZGVyZXIuZGVmYXVsdExhYmVsO1xuICAgIC8vIFRPRE8gbmVlZCB0byBrZWVwIHJhbXBcbiAgICBjb25zdCBmaWVsZEluZm9DaGFuZ2UgPSBmaWVsZEluZm8gJiYgKGZpZWxkSW5mby5maWVsZCAhPSByZW5kZXJlci5maWVsZCB8fCBmaWVsZEluZm8uZXhwcmVzc2lvbiAhPSByZW5kZXJlci52YWx1ZUV4cHJlc3Npb24pO1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIHJldHVybiBtb2R1bGVzLlR5cGVDcmVhdG9yLmNyZWF0ZVJlbmRlcmVyKHtcbiAgICAgICAgbGF5ZXIsXG4gICAgICAgIHZpZXc6IG1hcFZpZXcsXG4gICAgICAgIGZpZWxkOiBmaWVsZEluZm8gPyBmaWVsZEluZm8uZmllbGQgOiByZW5kZXJlci5maWVsZCxcbiAgICAgICAgdmFsdWVFeHByZXNzaW9uOiBmaWVsZEluZm8gPyBmaWVsZEluZm8uZXhwcmVzc2lvbiA6IHJlbmRlcmVyLnZhbHVlRXhwcmVzc2lvbixcbiAgICAgICAgdmFsdWVFeHByZXNzaW9uVGl0bGU6IGZpZWxkSW5mbyA/IGZpZWxkSW5mby5leHByZXNzaW9uVGl0bGUgOiByZW5kZXJlci52YWx1ZUV4cHJlc3Npb25UaXRsZSxcbiAgICAgICAgbnVtVHlwZXM6IG9wdGlvbnMubnVtVHlwZXMgfHwgKGZpZWxkSW5mb0NoYW5nZSA/IDEwIDogcmVuZGVyZXIudW5pcXVlVmFsdWVJbmZvcy5sZW5ndGgpLFxuICAgICAgICBzb3J0Qnk6IG9wdGlvbnMuc29ydEJ5IHx8IFwiY291bnRcIixcbiAgICAgICAgdHlwZVNjaGVtZTogZmluZFR5cGVTY2hlbWUoKSxcbiAgICAgICAgb3V0bGluZU9wdGltaXphdGlvbkVuYWJsZWQ6IG1hcEltYWdlU3VibGF5ZXJcbiAgICAgICAgICAgID8gZmFsc2VcbiAgICAgICAgICAgIDogaXNEZWZpbmVkKG9wdGlvbnMub3V0bGluZU9wdGltaXphdGlvbkVuYWJsZWQpXG4gICAgICAgICAgICAgICAgPyBvcHRpb25zLm91dGxpbmVPcHRpbWl6YXRpb25FbmFibGVkXG4gICAgICAgICAgICAgICAgOiAhIWV4dHJhcy5zaXplT3V0bGluZVZpc1ZhcixcbiAgICAgICAgc2l6ZU9wdGltaXphdGlvbkVuYWJsZWQ6IG1hcEltYWdlU3VibGF5ZXJcbiAgICAgICAgICAgID8gZmFsc2VcbiAgICAgICAgICAgIDogaXNEZWZpbmVkKG9wdGlvbnMuc2l6ZU9wdGltaXphdGlvbkVuYWJsZWQpXG4gICAgICAgICAgICAgICAgPyBvcHRpb25zLnNpemVPcHRpbWl6YXRpb25FbmFibGVkXG4gICAgICAgICAgICAgICAgOiAhIWV4dHJhcy5zaXplQXV0b1Zpc1ZhcixcbiAgICAgICAgbGVnZW5kT3B0aW9uczogb3B0aW9ucy5sZWdlbmRPcHRpb25zIHx8IHJlbmRlcmVyLmxlZ2VuZE9wdGlvbnMsXG4gICAgICAgIGRlZmF1bHRTeW1ib2xFbmFibGVkOiBpc0RlZmluZWQob3B0aW9ucy5kZWZhdWx0U3ltYm9sRW5hYmxlZCkgfHwgISFyZW5kZXJlci5kZWZhdWx0U3ltYm9sLFxuICAgICAgICBmb3JCaW5uaW5nOiAoKF9hID0gbGF5ZXIuZmVhdHVyZVJlZHVjdGlvbikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnR5cGUpID09PSBcImJpbm5pbmdcIlxuICAgIH0pLnRoZW4oKHJlc3VsdCkgPT4ge1xuICAgICAgICBhcHBseUV4dHJhVmlzVmFycyhleHRyYXMsIHJlc3VsdC5yZW5kZXJlcik7XG4gICAgICAgIGlmIChzeW1ib2wgJiYgcmVzdWx0LnJlbmRlcmVyLnVuaXF1ZVZhbHVlSW5mb3MgJiYgcmVzdWx0LnJlbmRlcmVyLnVuaXF1ZVZhbHVlSW5mb3MubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zdCBpbmZvcyA9IHJlc3VsdC5yZW5kZXJlci51bmlxdWVWYWx1ZUluZm9zLnNsaWNlKCk7XG4gICAgICAgICAgICBpbmZvcy5tYXAoKGluZm8pID0+IHtcbiAgICAgICAgICAgICAgICAvLyBrZWVwIHRoZSBzYW1lIHN5bWJvbCBzdHlsZSwgbm90IHRoZSBjb2xvclxuICAgICAgICAgICAgICAgIGNvbnN0IHN5bSA9IHN5bWJvbC5jbG9uZSgpO1xuICAgICAgICAgICAgICAgIGFwcGx5U3ltYm9sQ29sb3Ioc3ltLCBnZXRTeW1ib2xDb2xvcihpbmZvLnN5bWJvbCkpO1xuICAgICAgICAgICAgICAgIGluZm8uc3ltYm9sID0gc3ltO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXN1bHQucmVuZGVyZXIudW5pcXVlVmFsdWVJbmZvcyA9IGluZm9zO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkZWZhdWx0U3ltYm9sKSB7XG4gICAgICAgICAgICByZXN1bHQucmVuZGVyZXIuZGVmYXVsdFN5bWJvbCA9IGRlZmF1bHRTeW1ib2w7XG4gICAgICAgICAgICByZXN1bHQucmVuZGVyZXIuZGVmYXVsdExhYmVsID0gZGVmYXVsdExhYmVsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocmVzdWx0KTtcbiAgICB9LCAoZXJyb3IpID0+IFByb21pc2UucmVqZWN0KGVycm9yKSk7XG59XG4vLyBGcm9tIEpTLUFQSVxuLy8gbWF5YmUgaW4gZnV0dXJlIHVzZSBlc3JpL3NtYXJ0TWFwcGluZy9zdXBwb3J0L3V0aWxzLmZvcm1hdEFueURhdGUodmFsdWU6IG51bWJlciB8IHN0cmluZyB8IERhdGUsIG9wdGlvbnM/OiBGb3JtYXRBbnlEYXRlT3B0aW9ucyB8IE5pbCk6IHN0cmluZ1xuY29uc3QgZGF0ZUZvcm1hdEludGVydmFsT3B0aW9ucyA9IHtcbiAgICAvLyBEaXNwbGF5IGJvdGggZGF0ZSBhbmQgdGltZSBjb21wb25lbnRzOlxuICAgIG1pbGxpc2Vjb25kOiBcImxvbmctbW9udGgtZGF5LXllYXItbG9uZy10aW1lXCIsXG4gICAgc2Vjb25kOiBcImxvbmctbW9udGgtZGF5LXllYXItbG9uZy10aW1lXCIsXG4gICAgbWludXRlOiBcImxvbmctbW9udGgtZGF5LXllYXItc2hvcnQtdGltZVwiLFxuICAgIGhvdXI6IFwibG9uZy1tb250aC1kYXkteWVhci1zaG9ydC10aW1lXCIsXG4gICAgLy8gSnVzdCBkaXNwbGF5IHRoZSBkYXRlIGNvbXBvbmVudC5cbiAgICBkYXk6IFwibG9uZy1tb250aC1kYXkteWVhclwiLFxuICAgIG1vbnRoOiBcImxvbmctbW9udGgtZGF5LXllYXJcIixcbiAgICAvLyBKdXN0IGRpc3BsYXkgdGhlIHllYXIuXG4gICAgeWVhcjogXCJ5ZWFyXCJcbn07XG5mdW5jdGlvbiBnZXREYXRlTGFiZWwodmFsdWUsIGZpZWxkKSB7XG4gICAgY29uc3QgeyBhbGxVbmlxdWVWYWx1ZXMsIGxvY2FsZSwgbWFwVmlldywgbW9kdWxlcyB9ID0gc21hcnRNYXBwaW5nU3RhdGU7XG4gICAgbW9kdWxlcy5pbnRsLnNldExvY2FsZShsb2NhbGUpO1xuICAgIGlmICgoZmllbGQgPT09IG51bGwgfHwgZmllbGQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZpZWxkLnNpbXBsZUZpZWxkVHlwZSkgPT09IHNpbXBsZUZpZWxkVHlwZXMuREFURSkge1xuICAgICAgICBjb25zdCBkYXRlRm9ybWF0ID0gYWxsVW5pcXVlVmFsdWVzICYmXG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICBtb2R1bGVzLnJlbmRlcmVyU3VwcG9ydFV0aWxzLmNhbGN1bGF0ZURhdGVGb3JtYXRJbnRlcnZhbChhbGxVbmlxdWVWYWx1ZXMubWFwKCh1dikgPT4gdXYudmFsdWUpKTtcbiAgICAgICAgaWYgKG1hcFZpZXcudGltZVpvbmUgPT09IFwidW5rbm93blwiKSB7XG4gICAgICAgICAgICByZXR1cm4gbW9kdWxlcy5pbnRsLmZvcm1hdERhdGUodmFsdWUsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbW9kdWxlcy5pbnRsLmNvbnZlcnREYXRlRm9ybWF0VG9JbnRsT3B0aW9ucyhkYXRlRm9ybWF0ID8gZGF0ZUZvcm1hdEludGVydmFsT3B0aW9uc1tkYXRlRm9ybWF0XSA6IFwibG9uZy1tb250aC1kYXkteWVhclwiKSksIHsgdGltZVpvbmU6IFwidXRjXCIsIHRpbWVab25lTmFtZTogXCJzaG9ydE9mZnNldFwiIH0pKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGtub3duIGlzc3VlcyB3aXRoIGZvcm1hdHRpbmcgaXQtQ0hcbiAgICAgICAgICAgIHJldHVybiBtb2R1bGVzLmludGwuZm9ybWF0RGF0ZSh2YWx1ZSwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBtb2R1bGVzLmludGwuY29udmVydERhdGVGb3JtYXRUb0ludGxPcHRpb25zKGRhdGVGb3JtYXQgPyBkYXRlRm9ybWF0SW50ZXJ2YWxPcHRpb25zW2RhdGVGb3JtYXRdIDogXCJsb25nLW1vbnRoLWRheS15ZWFyXCIpKSwgeyB0aW1lWm9uZTogbWFwVmlldy50aW1lWm9uZSB9KSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIGRhdGUtb25seVxuICAgICAgICByZXR1cm4gbW9kdWxlcy5pbnRsLmZvcm1hdERhdGVPbmx5KHZhbHVlLCBtb2R1bGVzLmludGwuY29udmVydERhdGVGb3JtYXRUb0ludGxPcHRpb25zKFwibG9uZy1tb250aC1kYXkteWVhclwiKSk7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0T3RoZXJVbmlxdWVWYWx1ZUNsYXNzZXMoKSB7XG4gICAgY29uc3QgeyBhbGxVbmlxdWVWYWx1ZXMsIGxheWVyLCBtb2R1bGVzIH0gPSBzbWFydE1hcHBpbmdTdGF0ZTtcbiAgICBjb25zdCByZW5kZXJlciA9IGdldFJlbmRlcmVyKGxheWVyKTtcbiAgICBpZiAoIShhbGxVbmlxdWVWYWx1ZXMgPT09IG51bGwgfHwgYWxsVW5pcXVlVmFsdWVzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhbGxVbmlxdWVWYWx1ZXMubGVuZ3RoKSB8fCAhaXNEZWZpbmVkKGFsbFVuaXF1ZVZhbHVlc1swXS5jb3VudCkpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBsZXQgdHlwZVZhbHVlcyA9IFtdO1xuICAgIHJlbmRlcmVyLnVuaXF1ZVZhbHVlR3JvdXBzLmZvckVhY2goKHVuaXF1ZVZhbHVlR3JvdXApID0+IHtcbiAgICAgICAgY29uc3QgdmFsdWVzID0gW107XG4gICAgICAgIHVuaXF1ZVZhbHVlR3JvdXAuY2xhc3Nlcy5mb3JFYWNoKCh1bmlxdWVWYWx1ZUNsYXNzKSA9PiB1bmlxdWVWYWx1ZUNsYXNzLnZhbHVlcy5mb3JFYWNoKCh2YWx1ZSkgPT4gdmFsdWVzLnB1c2goYCR7dmFsdWUudmFsdWV9YCkpKTtcbiAgICAgICAgdHlwZVZhbHVlcyA9IHR5cGVWYWx1ZXMuY29uY2F0KHZhbHVlcyk7XG4gICAgfSk7XG4gICAgY29uc3Qgb3RoZXJJbmZvcyA9IGFsbFVuaXF1ZVZhbHVlcy5maWx0ZXIoKGluZm8pID0+IHR5cGVWYWx1ZXMuaW5kZXhPZihgJHtpbmZvLnZhbHVlfWApID09PSAtMSk7XG4gICAgY29uc3Qgb3RoZXJDbGFzc2VzID0gb3RoZXJJbmZvcy5tYXAoKGluZm8pID0+IHtcbiAgICAgICAgcmV0dXJuIG5ldyBtb2R1bGVzLlVuaXF1ZVZhbHVlQ2xhc3Moe1xuICAgICAgICAgICAgbGFiZWw6IGluZm8ubGFiZWwsXG4gICAgICAgICAgICBzeW1ib2w6IGluZm8uc3ltYm9sLFxuICAgICAgICAgICAgdmFsdWVzOiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogaW5mby52YWx1ZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF1cbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIG90aGVyQ2xhc3Nlcztcbn1cbmZ1bmN0aW9uIGdldE90aGVyVW5pcXVlVmFsdWVJbmZvcygpIHtcbiAgICBjb25zdCB7IGFsbFVuaXF1ZVZhbHVlcywgbGF5ZXIgfSA9IHNtYXJ0TWFwcGluZ1N0YXRlO1xuICAgIGNvbnN0IHJlbmRlcmVyID0gZ2V0UmVuZGVyZXIobGF5ZXIpO1xuICAgIGlmICghKGFsbFVuaXF1ZVZhbHVlcyA9PT0gbnVsbCB8fCBhbGxVbmlxdWVWYWx1ZXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGFsbFVuaXF1ZVZhbHVlcy5sZW5ndGgpIHx8ICFpc0RlZmluZWQoYWxsVW5pcXVlVmFsdWVzWzBdLmNvdW50KSkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGxldCB0eXBlVmFsdWVzID0gW107XG4gICAgcmVuZGVyZXIudW5pcXVlVmFsdWVHcm91cHMuZm9yRWFjaCgodW5pcXVlVmFsdWVHcm91cCkgPT4ge1xuICAgICAgICBjb25zdCB2YWx1ZXMgPSBbXTtcbiAgICAgICAgdW5pcXVlVmFsdWVHcm91cC5jbGFzc2VzLmZvckVhY2goKHVuaXF1ZVZhbHVlQ2xhc3MpID0+IHVuaXF1ZVZhbHVlQ2xhc3MudmFsdWVzLmZvckVhY2goKHZhbHVlKSA9PiB2YWx1ZXMucHVzaChgJHt2YWx1ZS52YWx1ZX1gKSkpO1xuICAgICAgICB0eXBlVmFsdWVzID0gdHlwZVZhbHVlcy5jb25jYXQodmFsdWVzKTtcbiAgICB9KTtcbiAgICBjb25zdCBvdGhlckluZm9zID0gYWxsVW5pcXVlVmFsdWVzLmZpbHRlcigoaW5mbykgPT4gdHlwZVZhbHVlcy5pbmRleE9mKGAke2luZm8udmFsdWV9YCkgPT09IC0xKTtcbiAgICByZXR1cm4gb3RoZXJJbmZvcztcbn1cbmZ1bmN0aW9uIGdldFVuaXF1ZUdyb3VwTmFtZShncm91cHMpIHtcbiAgICBjb25zdCB7IHN0cmluZ3MgfSA9IHNtYXJ0TWFwcGluZ1N0YXRlO1xuICAgIGxldCBjb3VudCA9IDE7XG4gICAgbGV0IG5ld0dyb3VwSGVhZGluZyA9IHN0cmluZ3MucGFuZWxzLnR5cGUuZGVmYXVsdEdyb3VwTmFtZS5yZXBsYWNlKFwiJHtudW1iZXJ9XCIsIGNvdW50LnRvU3RyaW5nKCkpO1xuICAgIHdoaWxlIChncm91cHMuZmluZCgoZ3JvdXApID0+IGdyb3VwLmhlYWRpbmcgPT09IG5ld0dyb3VwSGVhZGluZykpIHtcbiAgICAgICAgbmV3R3JvdXBIZWFkaW5nID0gc3RyaW5ncy5wYW5lbHMudHlwZS5kZWZhdWx0R3JvdXBOYW1lLnJlcGxhY2UoXCIke251bWJlcn1cIiwgKCsrY291bnQpLnRvU3RyaW5nKCkpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3R3JvdXBIZWFkaW5nO1xufVxuZnVuY3Rpb24gc2FtZVR5cGVGaWVsZChvcHRpb25zKSB7XG4gICAgY29uc3QgeyBsYXllciB9ID0gc21hcnRNYXBwaW5nU3RhdGU7XG4gICAgaWYgKFtcInR5cGVcIiwgXCJ0eXBlLXNpemVcIl0uaW5kZXhPZihnZXRSZW5kZXJlclR5cGUoKSkgPiAtMSkge1xuICAgICAgICBjb25zdCByZW5kZXJlciA9IGdldFJlbmRlcmVyKGxheWVyKTtcbiAgICAgICAgY29uc3QgcmVuZGVyRmllbGRJbmZvID0ge1xuICAgICAgICAgICAgZmllbGQ6IHJlbmRlcmVyLmZpZWxkLFxuICAgICAgICAgICAgZXhwcmVzc2lvbjogcmVuZGVyZXIudmFsdWVFeHByZXNzaW9uLFxuICAgICAgICAgICAgZXhwcmVzc2lvblRpdGxlOiByZW5kZXJlci52YWx1ZUV4cHJlc3Npb25UaXRsZVxuICAgICAgICB9O1xuICAgICAgICBpZiAoaXNTYW1lRmllbGRJbmZvKG9wdGlvbnMuZmllbGRJbmZvc1swXSwgcmVuZGVyRmllbGRJbmZvKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gc2VwYXJhdGVNZXJnZWRDbGFzc2VzKGdyb3VwLCBjbGFzc0lkeHMpIHtcbiAgICBjb25zdCB7IGxheWVyLCBtYXBWaWV3LCBtb2R1bGVzIH0gPSBzbWFydE1hcHBpbmdTdGF0ZTtcbiAgICBjb25zdCByZW5kZXJlciA9IGdldFJlbmRlcmVyKGxheWVyKTtcbiAgICBjb25zdCBmaWVsZCA9IGdldEZpZWxkKHJlbmRlcmVyLmZpZWxkKTtcbiAgICBjb25zdCBpc0ludCA9IGZpZWxkICYmIFtcInNtYWxsLWludGVnZXJcIiwgXCJpbnRlZ2VyXCIsIFwiYmlnLWludGVnZXJcIiwgXCJsb25nXCJdLmluZGV4T2YoZ2V0RmllbGRUeXBlKGZpZWxkLmxheWVyRmllbGQpKSA+IC0xO1xuICAgIGNvbnN0IGlzRGF0ZSA9IChmaWVsZCA9PT0gbnVsbCB8fCBmaWVsZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogZmllbGQuc2ltcGxlRmllbGRUeXBlKSA9PT0gc2ltcGxlRmllbGRUeXBlcy5EQVRFO1xuICAgIGNvbnN0IGlzRGF0ZU9ubHkgPSBnZXRGaWVsZFR5cGUoZmllbGQubGF5ZXJGaWVsZCkgPT09IFwiZGF0ZS1vbmx5XCI7XG4gICAgY29uc3QgbmV3Q2xhc3NlcyA9IFtdO1xuICAgIGNvbnN0IHNjaGVtZSA9IGZpbmRUeXBlU2NoZW1lKCk7XG4gICAgbGV0IGNvdW50ZXIgPSAwO1xuICAgIGdyb3VwLmNsYXNzZXMuZm9yRWFjaCgodXZDbGFzcywgaWR4KSA9PiB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKHV2Q2xhc3MudmFsdWVzLmxlbmd0aCA9PT0gMSB8fCAoY2xhc3NJZHhzICYmIGNsYXNzSWR4cy5pbmRleE9mKGlkeCkgPT09IC0xKSkge1xuICAgICAgICAgICAgbmV3Q2xhc3Nlcy5wdXNoKHV2Q2xhc3MpO1xuICAgICAgICAgICAgY291bnRlcisrO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFjbGFzc0lkeHMgfHwgY2xhc3NJZHhzLmluZGV4T2YoaWR4KSA+IC0xKSB7XG4gICAgICAgICAgICBjb25zdCBzeW1ib2wgPSBbXCJzaW1wbGUtbWFya2VyXCIsIFwic2ltcGxlLWxpbmVcIiwgXCJzaW1wbGUtZmlsbFwiLCBcImNpbVwiXS5pbmRleE9mKChfYSA9IHV2Q2xhc3Muc3ltYm9sKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudHlwZSkgPiAtMVxuICAgICAgICAgICAgICAgID8gdXZDbGFzcy5zeW1ib2xcbiAgICAgICAgICAgICAgICA6IGdldERlZmF1bHRTeW1ib2wobGF5ZXIsIG1hcFZpZXcsIGdldFJlbmRlcmVyVHlwZSgpKTtcbiAgICAgICAgICAgIHV2Q2xhc3MudmFsdWVzLmZvckVhY2goKHZhbHVlLCBpZHgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdTeW1ib2wgPSBtb2R1bGVzLmVzcmlMYW5nLmNsb25lKHN5bWJvbCk7XG4gICAgICAgICAgICAgICAgaWYgKGlkeCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gY2hhbmdlIGNvbG9yXG4gICAgICAgICAgICAgICAgICAgIGlmIChzY2hlbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbG9yID0gc2NoZW1lLmNvbG9yc1soZ3JvdXAuY2xhc3Nlcy5sZW5ndGggKyBjb3VudGVyKSAlIHNjaGVtZS5jb2xvcnMubGVuZ3RoXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yICYmIGFwcGx5U3ltYm9sQ29sb3IobmV3U3ltYm9sLCBjb2xvcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBqdXN0IHBpY2sgc29tZSBjb2xvcnMgZnJvbSB0aGUgcHJpbWFyeSBzY2hlbWVcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHByaW1hcnlSYW1wQ29sb3JzID0gZ2V0UHJpbWFyeVR5cGVTY2hlbWUoKS5jb2xvcnM7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjb2xvciA9IG5ldyBtb2R1bGVzLmVzcmlDb2xvcihwcmltYXJ5UmFtcENvbG9yc1soZ3JvdXAuY2xhc3Nlcy5sZW5ndGggKyBjb3VudGVyKSAlIDEwXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvciAmJiBhcHBseVN5bWJvbENvbG9yKG5ld1N5bWJvbCwgY29sb3IpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGxhYmVsID0gaXNEYXRlIHx8IGlzRGF0ZU9ubHlcbiAgICAgICAgICAgICAgICAgICAgPyB0aGlzLmdldERhdGVMYWJlbCh2YWx1ZS52YWx1ZSwgZmllbGQpXG4gICAgICAgICAgICAgICAgICAgIDogKGZpZWxkID09PSBudWxsIHx8IGZpZWxkID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmaWVsZC5zaW1wbGVGaWVsZFR5cGUpID09PSBzaW1wbGVGaWVsZFR5cGVzLk5VTUJFUlxuICAgICAgICAgICAgICAgICAgICAgICAgPyBfX2VzcmkuaW50bC5mb3JtYXROdW1iZXIoaXNJbnQgPyBwYXJzZUludCh2YWx1ZS52YWx1ZSkgOiBwYXJzZUZsb2F0KHZhbHVlLnZhbHVlKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIDogdmFsdWUudmFsdWU7XG4gICAgICAgICAgICAgICAgbmV3Q2xhc3Nlcy5wdXNoKG5ldyBtb2R1bGVzLlVuaXF1ZVZhbHVlQ2xhc3Moe1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZXM6IFtuZXcgbW9kdWxlcy5VbmlxdWVWYWx1ZSh7IHZhbHVlOiB2YWx1ZS52YWx1ZSB9KV0sXG4gICAgICAgICAgICAgICAgICAgIGxhYmVsLFxuICAgICAgICAgICAgICAgICAgICBzeW1ib2w6IG5ld1N5bWJvbFxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICBjb3VudGVyKys7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGdyb3VwLmNsYXNzZXMgPSBuZXdDbGFzc2VzO1xufVxuXG5leHBvcnQgeyBjcmVhdGVUeXBlUmVuZGVyZXJGcm9tRXhpc3RpbmcgYXMgYSwgZ2V0T3RoZXJVbmlxdWVWYWx1ZUNsYXNzZXMgYXMgYiwgY3JlYXRlVHlwZVJlbmRlcmVyIGFzIGMsIGdldFVuaXF1ZUdyb3VwTmFtZSBhcyBkLCBnZXREYXRlTGFiZWwgYXMgZSwgc2VwYXJhdGVNZXJnZWRDbGFzc2VzIGFzIGYsIGdldE90aGVyVW5pcXVlVmFsdWVJbmZvcyBhcyBnLCBzYW1lVHlwZUZpZWxkIGFzIHMgfTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHlwZS0wYWNlNWQyZS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=