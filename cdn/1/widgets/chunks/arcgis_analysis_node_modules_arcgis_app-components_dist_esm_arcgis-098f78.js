"use strict";
(self["webpackChunkexb_client"] = self["webpackChunkexb_client"] || []).push([["vendors-extensions_widgets_arcgis_analysis_node_modules_arcgis_app-components_dist_esm_arcgis-098f78"],{

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/arcgis-image-display-order.entry.js":
/*!*****************************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/arcgis-image-display-order.entry.js ***!
  \*****************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   arcgis_image_display_order: () => (/* binding */ ArcgisImageDisplayOrder)
/* harmony export */ });
/* harmony import */ var _index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index-e3bf7da7.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/index-e3bf7da7.js");
/* harmony import */ var _functional_44de8fcf_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./functional-44de8fcf.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/functional-44de8fcf.js");
/* harmony import */ var _locale_050b6db9_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./locale-050b6db9.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/locale-050b6db9.js");
/* harmony import */ var _languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./languageUtil-ef0e54b2.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/languageUtil-ef0e54b2.js");
/* harmony import */ var _dom_4d367677_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./dom-4d367677.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/dom-4d367677.js");
/* harmony import */ var _loadModules_b4ac1247_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./loadModules-b4ac1247.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/loadModules-b4ac1247.js");
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v4.0.58
 */







const defaultMosaicMethods = [
    "center",
    "northwest",
    "lock-raster",
    "attribute",
    "nadir",
    "viewpoint",
    "seamline",
    "none"
];
const defaultMosaicOperators = ["first", "last", "min", "max", "mean", "blend", "sum"];
const allowedFieldTypeList = [
    "double",
    "single",
    "long",
    "integer",
    "small-integer",
    "oid",
    "date",
    "big-integer",
    "date-only"
];

const mosaicMethodMapping = (method) => {
    method = method.toLowerCase();
    switch (method) {
        case "lockraster":
        case "lock-raster":
            return "lock-raster";
        case "byattribute":
            return "attribute";
        default:
            return method;
    }
};
const mosaicMethodToOperatorsMapping = (mosaicMethod) => {
    switch (mosaicMethod) {
        case "seamline":
            return ["first", "blend"];
        default:
            return defaultMosaicOperators;
    }
};

const arcgisImageDisplayOrderCss = ":host{display:flex;height:100%}.image-display-order-lock-input{margin-top:var(--arcgis-app-cap-spacing-half)}";

const ArcgisImageDisplayOrder = class {
    constructor(hostRef) {
        (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.r)(this, hostRef);
        this.arcgisImageDisplayOrderClose = (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, "arcgisImageDisplayOrderClose", 7);
        this.mosaicMethodList = defaultMosaicMethods;
        this.attributeFieldList = [];
        this.handleMosaicMethodChange = (event) => {
            var _a, _b, _c;
            const target = event.target;
            const updatedMethod = (_a = target.selectedOption) === null || _a === void 0 ? void 0 : _a.value;
            const { lockRasterIds: activeLockRasterIds, operation: activeOperation } = this.activeMosaicRule;
            const updatedSortField = updatedMethod === "attribute" ? (_c = (_b = this.attributeFieldList) === null || _b === void 0 ? void 0 : _b[0]) === null || _c === void 0 ? void 0 : _c.name : null;
            const updatedLockRasterIds = updatedMethod !== "lock-raster" ? null : activeLockRasterIds;
            const updatedAscending = updatedMethod === "seamline" ? null : true;
            const seamlineOperators = mosaicMethodToOperatorsMapping("seamline");
            const updatedOperation = updatedMethod === "seamline" && seamlineOperators.includes(activeOperation)
                ? activeOperation
                : "first";
            this.activeMosaicRule.method = updatedMethod;
            this.activeMosaicRule.sortField = updatedSortField;
            this.activeMosaicRule.sortValue = null;
            this.activeMosaicRule.lockRasterIds = updatedLockRasterIds;
            this.activeMosaicRule.ascending = updatedAscending;
            this.activeMosaicRule.operation = updatedOperation;
            this.updateActiveMosaicRule();
        };
        this.handleAttributeFieldChange = (event) => {
            var _a;
            const target = event.target;
            const updatedSortField = (_a = target.selectedOption) === null || _a === void 0 ? void 0 : _a.value;
            this.activeMosaicRule.sortField = updatedSortField;
            this.updateActiveMosaicRule();
        };
        this.debouncedHandleAttributeValueChange = (0,_functional_44de8fcf_js__WEBPACK_IMPORTED_MODULE_1__.d)((sortValue) => {
            this.activeMosaicRule.sortValue = sortValue;
            this.updateActiveMosaicRule();
        }, 300);
        this.handleDateAttributeValueChange = (event) => {
            const target = event.target;
            const targetValue = target === null || target === void 0 ? void 0 : target.value;
            const updatedSortValue = targetValue.replace(/\-/g, "/");
            this.debouncedHandleAttributeValueChange(updatedSortValue);
        };
        this.handleAttributeValueChange = (event) => {
            const target = event.target;
            const targetValue = target === null || target === void 0 ? void 0 : target.value;
            const updatedSortValue = +targetValue;
            this.debouncedHandleAttributeValueChange(updatedSortValue);
        };
        this.debouncedHandleRasterIDsChange = (0,_functional_44de8fcf_js__WEBPACK_IMPORTED_MODULE_1__.d)((rasterIds) => {
            this.activeMosaicRule.lockRasterIds = rasterIds;
            this.updateActiveMosaicRule();
        }, 300);
        this.handleRasterIDsChange = (event) => {
            const target = event.target;
            const updatedRasterIds = target === null || target === void 0 ? void 0 : target.value;
            const commaSeparatedNumRegExp = /^[0-9]+(,[0-9]+)*$/;
            if (!commaSeparatedNumRegExp.test(updatedRasterIds)) {
                return;
            }
            const updatedLockRasterIds = updatedRasterIds
                .split(",")
                .map((rasterId) => parseInt(rasterId, 10));
            this.debouncedHandleRasterIDsChange(updatedLockRasterIds);
        };
        this.debouncedHandleReverseOrderChange = (0,_functional_44de8fcf_js__WEBPACK_IMPORTED_MODULE_1__.d)((reverseOrder) => {
            this.activeMosaicRule.ascending = !reverseOrder;
            this.updateActiveMosaicRule();
        }, 300);
        this.handleReverseOrderChange = (event) => {
            const target = event.target;
            const updatedReverseOrder = target === null || target === void 0 ? void 0 : target.checked;
            this.debouncedHandleReverseOrderChange(updatedReverseOrder);
        };
        this.handleMosaicOperatorChange = (event) => {
            var _a;
            const target = event.target;
            const updatedOperator = (_a = target.selectedOption) === null || _a === void 0 ? void 0 : _a.value;
            this.activeMosaicRule.operation = updatedOperator;
            this.updateActiveMosaicRule();
        };
        this.handleDone = () => {
            this.arcgisImageDisplayOrderClose.emit("save");
        };
        this.handleCancel = () => {
            this.layer.mosaicRule = this.originalMosaicRule;
            this.activeMosaicRule = this.originalMosaicRule.clone();
            this.arcgisImageDisplayOrderClose.emit("cancel");
            return;
        };
        this.layer = undefined;
        this.dismissible = false;
        this.activeMosaicRule = null;
    }
    watchStateHandler(newMosaicRule, oldMosaicRule) {
        if (!newMosaicRule || !oldMosaicRule) {
            return;
        }
        this.layer.mosaicRule = newMosaicRule;
    }
    //--------------------------------------------------------------------------
    //
    //  Lifecycle
    //
    //--------------------------------------------------------------------------
    async componentWillLoad() {
        const [strings] = await (0,_locale_050b6db9_js__WEBPACK_IMPORTED_MODULE_2__.g)(this.hostElement);
        this.strings = strings;
        this.init();
    }
    // --------------------------------------------------------------------------
    //
    //  Render Methods
    //
    //--------------------------------------------------------------------------
    render() {
        const rtl = (0,_languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_3__.g)(this.hostElement) === "rtl";
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)(_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.H, { class: "calcite-match-height" }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-panel", { heading: this.strings.imageDisplayOrder, closable: this.dismissible, loading: !this.activeMosaicRule, onCalcitePanelClose: this.handleCancel, class: {
                panel: true,
                [_languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_3__.C.rtl]: rtl
            } }, this.renderMosaicRule(), this.renderFooterActions())));
    }
    renderMosaicRule() {
        if (!this.activeMosaicRule) {
            return null;
        }
        const activeMosaicMethod = this.activeMosaicRule.method;
        const shouldRenderAttributeFilter = activeMosaicMethod === "attribute";
        const shouldRenderRasterIds = activeMosaicMethod === "lock-raster";
        const shouldRenderReverseOrder = activeMosaicMethod !== "seamline";
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-block", { heading: "", open: true }, this.renderMosaicMethodSelection(), shouldRenderAttributeFilter && this.renderAttributeFilter(), shouldRenderRasterIds && this.renderRasterId(), shouldRenderReverseOrder && this.renderReverseOrder(), this.renderMosaicOperatorSelection()));
    }
    renderMosaicMethodSelection() {
        const { method: activeMethod } = this.activeMosaicRule;
        const { mosaicMethod, componentLabel, mosaicMethodLabel } = this.strings;
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", null, mosaicMethod, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-select", { label: componentLabel["methodSelect"], onCalciteSelectChange: this.handleMosaicMethodChange }, this.mosaicMethodList.map((method) => ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-option", { key: method, value: method, label: mosaicMethodLabel[method], selected: method === activeMethod }))))));
    }
    renderAttributeFilter() {
        var _a;
        const { sortField } = this.activeMosaicRule;
        const currentSortFieldType = (_a = this.attributeFieldList.find(({ name }) => name === sortField)) === null || _a === void 0 ? void 0 : _a.type;
        const shouldRenderDateAttributeFilter = currentSortFieldType === "date" || currentSortFieldType === "date-only";
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", null, this.renderAttributeMethodSelection(), shouldRenderDateAttributeFilter
            ? this.renderAttributeDatePicker()
            : this.renderAttributeSortValue()));
    }
    renderAttributeMethodSelection() {
        const { sortField: activeSortField } = this.activeMosaicRule;
        const { attribute, componentLabel } = this.strings;
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", null, attribute, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-select", { label: componentLabel["attributeFieldSelect"], onCalciteSelectChange: this.handleAttributeFieldChange }, this.attributeFieldList.map(({ name, alias }) => ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-option", { key: name, value: name, label: alias, selected: name === activeSortField }))))));
    }
    renderAttributeDatePicker() {
        const { sortValue } = this.activeMosaicRule;
        const { highestPriorityValue } = this.strings;
        const datePickerValue = (sortValue === null || sortValue === void 0 ? void 0 : sortValue.toString().indexOf("/")) > -1 ? sortValue.replace(/\//g, "-") : "";
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", null, highestPriorityValue, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-input-date-picker", { placement: "bottom-end", "overlay-positioning": "fixed", value: datePickerValue, onCalciteInputDatePickerChange: this.handleDateAttributeValueChange })));
    }
    renderAttributeSortValue() {
        const { sortValue } = this.activeMosaicRule;
        const { highestPriorityValue } = this.strings;
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", null, highestPriorityValue, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-input", { type: "number", step: 0.001, value: sortValue === null || sortValue === void 0 ? void 0 : sortValue.toString(), onCalciteInputInput: this.handleAttributeValueChange })));
    }
    renderRasterId() {
        const { lockRasterIds } = this.activeMosaicRule;
        const rasterIdsString = lockRasterIds === null || lockRasterIds === void 0 ? void 0 : lockRasterIds.join(",");
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", null, this.strings.imageIDs, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-input", { class: "image-display-order-lock-input", placeholder: this.strings.useCommaDelimiter, value: rasterIdsString, onCalciteInputInput: this.handleRasterIDsChange })));
    }
    renderReverseOrder() {
        const { ascending } = this.activeMosaicRule;
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", { layout: "inline-space-between" }, this.strings.reverserOrder, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-switch", { checked: !ascending, onCalciteSwitchChange: this.handleReverseOrderChange })));
    }
    renderMosaicOperatorSelection() {
        const { method, operation: activeOperator } = this.activeMosaicRule;
        const mosaicOperatorList = mosaicMethodToOperatorsMapping(method);
        const { mosaicOperator, componentLabel, mosaicOperatorLabel } = this.strings;
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", null, mosaicOperator, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-select", { label: componentLabel["operatorSelect"], onCalciteSelectChange: this.handleMosaicOperatorChange }, mosaicOperatorList.map((operator) => ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-option", { key: operator, value: operator, label: mosaicOperatorLabel[operator], selected: operator === activeOperator }))))));
    }
    renderFooterActions() {
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)(_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.F, null, this.renderDoneButton(), this.renderCancelButton()));
    }
    renderDoneButton() {
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-button", { slot: "footer", appearance: "solid", color: "blue", width: "half", disabled: !this.activeMosaicRule, onClick: this.handleDone }, this.strings.done));
    }
    renderCancelButton() {
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-button", { slot: "footer", appearance: "outline-fill", width: "half", disabled: !this.activeMosaicRule, onClick: this.handleCancel }, this.strings.cancel));
    }
    // --------------------------------------------------------------------------
    //
    //  Private methods
    //
    // --------------------------------------------------------------------------
    async init() {
        await this.layer.load();
        this.originalMosaicRule = this.getOriginalMosaicRule();
        this.activeMosaicRule = this.originalMosaicRule.clone();
        this.mosaicMethodList = this.getMosaicMethodList();
        this.attributeFieldList = this.getAttributeFieldList();
    }
    updateActiveMosaicRule() {
        this.activeMosaicRule = this.activeMosaicRule.clone();
    }
    getOriginalMosaicRule() {
        const { mosaicRule, defaultMosaicRule } = this.layer;
        return mosaicRule !== null && mosaicRule !== void 0 ? mosaicRule : defaultMosaicRule;
    }
    getAllowedAttributeFieldList() {
        const { fields: layerFields, sourceJSON } = this.layer;
        const allowedFieldList = layerFields.filter(({ type }) => allowedFieldTypeList.includes(type));
        allowedFieldList.sort((a, b) => a.alias.localeCompare(b.alias));
        const { sortableFields } = sourceJSON || {};
        if (!(sortableFields === null || sortableFields === void 0 ? void 0 : sortableFields.length)) {
            return allowedFieldList;
        }
        const sourceJSONSortableFields = sortableFields === null || sortableFields === void 0 ? void 0 : sortableFields.split(",").map((field) => field.toLowerCase());
        const fieldList = allowedFieldList.filter((layerField) => sourceJSONSortableFields.includes(layerField.name.toLocaleLowerCase()));
        return fieldList;
    }
    filterAttributeFieldList(attributeFieldList) {
        var _a, _b;
        const shouldFilterCategory = ((_b = (_a = this.layer.sourceJSON) === null || _a === void 0 ? void 0 : _a.sortField) === null || _b === void 0 ? void 0 : _b.toLowerCase()) !== "category";
        if (!shouldFilterCategory) {
            return attributeFieldList;
        }
        return attributeFieldList.filter((layerField) => layerField.name.toLocaleLowerCase() !== "category");
    }
    getAttributeFieldList() {
        const allowedAttributeFieldList = this.getAllowedAttributeFieldList();
        const filteredAttributeFieldList = this.filterAttributeFieldList(allowedAttributeFieldList);
        return filteredAttributeFieldList;
    }
    getAllowedMosaicMethodList() {
        const { sourceJSON } = this.layer;
        if (!sourceJSON) {
            return defaultMosaicMethods;
        }
        const { currentVersion, allowedMosaicMethods: sourceJSONAllowedMosaicMethods } = sourceJSON;
        const isValidVersion = currentVersion && currentVersion >= 10.1;
        const hasAllowedMosaciMethods = (sourceJSONAllowedMosaicMethods === null || sourceJSONAllowedMosaicMethods === void 0 ? void 0 : sourceJSONAllowedMosaicMethods.length) > 1;
        if (!isValidVersion || !hasAllowedMosaciMethods) {
            return defaultMosaicMethods;
        }
        const allowedMosaicMethodList = sourceJSONAllowedMosaicMethods
            .split(",")
            .map((method) => mosaicMethodMapping(method.toLowerCase()));
        const noneMosaicMethod = "none";
        if (!allowedMosaicMethodList.includes(noneMosaicMethod)) {
            allowedMosaicMethodList.push(noneMosaicMethod);
        }
        return allowedMosaicMethodList;
    }
    filteredMosaicMethodList(mosaicMethodList) {
        const viewpointMosaicMethod = "viewpoint";
        return mosaicMethodList.filter((method) => method !== viewpointMosaicMethod);
    }
    getMosaicMethodList() {
        const allowedMosaicMethods = this.getAllowedMosaicMethodList();
        const filteredMosaicMethods = this.filteredMosaicMethodList(allowedMosaicMethods);
        return filteredMosaicMethods;
    }
    get hostElement() { return (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.d)(this); }
    static get watchers() { return {
        "activeMosaicRule": ["watchStateHandler"]
    }; }
};
ArcgisImageDisplayOrder.style = arcgisImageDisplayOrderCss;



//# sourceMappingURL=arcgis-image-display-order.entry.js.map

/***/ }),

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/functional-44de8fcf.js":
/*!****************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/functional-44de8fcf.js ***!
  \****************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   a: () => (/* binding */ arrayToLookupMap),
/* harmony export */   b: () => (/* binding */ unique),
/* harmony export */   c: () => (/* binding */ throttle),
/* harmony export */   d: () => (/* binding */ debounce),
/* harmony export */   e: () => (/* binding */ escapeRegExp),
/* harmony export */   f: () => (/* binding */ arraysAreEquivalent),
/* harmony export */   g: () => (/* binding */ chunk),
/* harmony export */   i: () => (/* binding */ isDefined),
/* harmony export */   m: () => (/* binding */ minDelay),
/* harmony export */   t: () => (/* binding */ timeout),
/* harmony export */   u: () => (/* binding */ uniqueBy)
/* harmony export */ });
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v4.0.58
 */
/**
 * Call a function only after it has not been called for n milliseconds
 * @param fn    - function to call
 * @param delay - delay in milliseconds
 */
const debounce = (fn, delay) => {
    let timeout;
    let status = "idle";
    function flush(...args) {
        status = "flushed";
        return debounced(...args);
    }
    function invoke(...args) {
        status = "invoked";
        return debounced(...args);
    }
    function cancel(...args) {
        status = "cancelled";
        return debounced(...args);
    }
    function getStatus() {
        return status;
    }
    const debounced = (...args) => new Promise((resolve) => {
        switch (status) {
            case "flushed":
                status = "idle";
                if (timeout) {
                    clearTimeout(timeout);
                    resolve(fn(...args));
                }
                else {
                    resolve(null);
                }
                break;
            case "invoked":
                clearTimeout(timeout);
                status = "idle";
                resolve(fn(...args));
                break;
            case "cancelled":
                clearTimeout(timeout);
                status = "idle";
                resolve(null);
                break;
            default:
                if (timeout) {
                    clearTimeout(timeout);
                }
                status = "pending";
                timeout = setTimeout(() => {
                    status = "idle";
                    return resolve(fn(...args));
                }, delay);
                break;
        }
    });
    debounced.flush = flush;
    debounced.invoke = invoke;
    debounced.cancel = cancel;
    debounced.getStatus = getStatus;
    return debounced;
};
/**
 * Call a function only after n milliseconds have elapsed
 * @param fn    - function to call
 * @param delay - delay in milliseconds
 */
const throttle = (fn, delay) => {
    let timeout;
    return (...args) => new Promise((resolve) => {
        if (timeout) {
            return;
        }
        timeout = setTimeout(() => {
            clearTimeout(timeout);
            timeout = undefined;
            resolve(fn(...args));
        }, delay);
    });
};
function escapeRegExp(str) {
    return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"); // $& means the whole matched string
}
function isDefined(value) {
    return value !== undefined && value !== null;
}
/**
 * Set a minimum time for a promise to resolve (useful for preventing flash of loaders)
 */
async function minDelay(promise, minDelay) {
    await Promise.all([promise, timeout(minDelay)]);
    return promise;
}
/**
 * Helper method to inline setTimeout as an await in async functions
 */
function timeout(ms) {
    return new Promise((resolve) => setTimeout(resolve, ms));
}
const arrayToLookupMap = (dataArr, getKeyAndItem) => Object.fromEntries((dataArr || []).map((item) => {
    const { key, data } = getKeyAndItem(item);
    return [key, data];
}));
/**
 * Check whether two arrays have the same number of elements
 * and whether they contain the same elements
 * regardless of order
 */
const arraysAreEquivalent = (arr1, arr2) => arr1.length === arr2.length && arr1.reduce((memo, str) => memo && arr2.indexOf(str) > -1, true);
function uniqueBy(myArr, getItemId) {
    const resultArr = [];
    const lookupMap = {};
    myArr.forEach((item) => {
        const id = getItemId(item);
        if (lookupMap[id] == null) {
            lookupMap[id] = item;
            resultArr.push(item);
        }
    });
    return resultArr;
}
function unique(myArr) {
    const primitives = { boolean: {}, number: {}, string: {} };
    const objs = [];
    return myArr.filter((item) => {
        let type = typeof item;
        if (type in primitives) {
            return primitives[type].hasOwnProperty(item) ? false : (primitives[type][item] = true);
        }
        else {
            return objs.indexOf(item) >= 0 ? false : objs.push(item);
        }
    });
}
const chunk = (arr, size) => [...Array(Math.ceil(arr.length / size))].map((_, i) => arr.slice(size * i, size + size * i));



//# sourceMappingURL=functional-44de8fcf.js.map

/***/ }),

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/languageUtil-ef0e54b2.js":
/*!******************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/languageUtil-ef0e54b2.js ***!
  \******************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   C: () => (/* binding */ CSS_UTILITY),
/* harmony export */   a: () => (/* binding */ formatDate),
/* harmony export */   b: () => (/* binding */ formatPlural),
/* harmony export */   f: () => (/* binding */ formatNumber),
/* harmony export */   g: () => (/* binding */ getElementDir),
/* harmony export */   l: () => (/* binding */ languageMap)
/* harmony export */ });
/* harmony import */ var _loadModules_b4ac1247_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./loadModules-b4ac1247.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/loadModules-b4ac1247.js");
/* harmony import */ var _dom_4d367677_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./dom-4d367677.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/dom-4d367677.js");
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v4.0.58
 */



const languageMap = new Map([
    ["ar", "ar"],
    ["bg", "bg"],
    ["bs", "bs"],
    ["ca", "ca"],
    ["cs", "cs"],
    ["da", "da"],
    ["de", "de"],
    ["el", "el"],
    ["en", "en"],
    ["es", "es"],
    ["et", "et"],
    ["fi", "fi"],
    ["fr", "fr"],
    ["he", "he"],
    ["hr", "hr"],
    ["hu", "hu"],
    ["id", "id"],
    ["it", "it"],
    ["ja", "ja"],
    ["ko", "ko"],
    ["lt", "lt"],
    ["lv", "lv"],
    ["nb", "nb"],
    ["nl", "nl"],
    ["pl", "pl"],
    ["pt-br", "pt-BR"],
    ["pt-pt", "pt-PT"],
    ["ro", "ro"],
    ["ru", "ru"],
    ["sk", "sk"],
    ["sl", "sl"],
    ["sr", "sr"],
    ["sv", "sv"],
    ["th", "th"],
    ["tr", "tr"],
    ["uk", "uk"],
    ["vi", "vi"],
    ["zh-cn", "zh-CN"],
    ["zh-hk", "zh-HK"],
    ["zh-tw", "zh-TW"]
]);
// rtl
function getElementDir(el) {
    return getElementProp(el, "dir", "ltr");
}
function getElementProp(el, prop, value) {
    const closestWithProp = (0,_dom_4d367677_js__WEBPACK_IMPORTED_MODULE_1__.c)(el, `[${prop}]`);
    return closestWithProp ? closestWithProp.getAttribute(prop) : value;
}
// css
const CSS_UTILITY = {
    rtl: "arcgis--rtl"
};
async function formatNumber(number, options) {
    const { api, type, places } = options || {};
    if (api === 4) {
        const [intl] = await (0,_loadModules_b4ac1247_js__WEBPACK_IMPORTED_MODULE_0__.l)(["esri/intl"]);
        const numberFormatIntlOptions = intl.convertNumberFormatToIntlOptions({
            places,
            style: type,
            digitSeparator: true
        });
        return intl.formatNumber(number, Object.assign(Object.assign({}, numberFormatIntlOptions), { style: type }));
    }
    const [dojoNumber] = await (0,_loadModules_b4ac1247_js__WEBPACK_IMPORTED_MODULE_0__.l)(["dojo/number"]);
    return dojoNumber.format(number, {
        type,
        places,
        pattern: options === null || options === void 0 ? void 0 : options.pattern
    });
}
const cache = {};
function formatDate(date) {
    const lang = document.documentElement.lang;
    const dayShortMonthYear = {
        year: "numeric",
        month: "short",
        day: "numeric"
    };
    if (!cache[lang]) {
        cache[lang] = new Intl.DateTimeFormat(document.documentElement.lang, dayShortMonthYear);
    }
    return cache[lang].format(date);
}
function formatPlural(lang, stringObj, number) {
    const singles = ["id", "ja", "ko", "th", "vi", "zh-cn", "zh-hk", "zh-tw"];
    const likeEnglish = [
        "en",
        "ca",
        "da",
        "de",
        "el",
        "es",
        "et",
        "fi",
        "hi",
        "hu",
        "it",
        "nb",
        "nl",
        "pt-pt",
        "sv",
        "tr"
    ];
    const locale = lang !== null && lang !== void 0 ? lang : "en";
    // if the number is one, or it is a "simple" language, return the 1 string
    if (number === 1 || singles.includes(locale)) {
        return stringObj.single.replace("${number}", "1");
    }
    // if the number is not 1 and the language uses the same pluralization strategy as english,
    // return the multiple string
    if (number !== 1 && likeEnglish.includes(locale)) {
        return stringObj.multiple.replace("${number}", `${number}`);
    }
    // if none of the above worked, return the "unknown" string
    return stringObj.unknown.replace("${number}", `${number}`);
}



//# sourceMappingURL=languageUtil-ef0e54b2.js.map

/***/ }),

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/locale-050b6db9.js":
/*!************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/locale-050b6db9.js ***!
  \************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   a: () => (/* binding */ getComponentClosestLanguage),
/* harmony export */   g: () => (/* binding */ getLocaleComponentStrings)
/* harmony export */ });
/* harmony import */ var _dom_4d367677_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dom-4d367677.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/dom-4d367677.js");
/* harmony import */ var _languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./languageUtil-ef0e54b2.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/languageUtil-ef0e54b2.js");
/* harmony import */ var _index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./index-e3bf7da7.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/index-e3bf7da7.js");
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v4.0.58
 */




// https://medium.com/stencil-tricks/implementing-internationalisation-i18n-with-stencil-5e6559554117
function getComponentClosestLanguage(element) {
    var _a, _b, _c;
    const closestElement = (_a = (0,_dom_4d367677_js__WEBPACK_IMPORTED_MODULE_0__.c)(element, "[lang]")) !== null && _a !== void 0 ? _a : (_c = (_b = element.shadowRoot) === null || _b === void 0 ? void 0 : _b.ownerDocument) === null || _c === void 0 ? void 0 : _c.documentElement;
    // language set by the calling application or browser. defaults to english.
    const lang = ((closestElement === null || closestElement === void 0 ? void 0 : closestElement.lang) || (navigator === null || navigator === void 0 ? void 0 : navigator.language) || "en").toLowerCase();
    if (_languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_1__.l.has(lang)) {
        return _languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_1__.l.get(lang);
    }
    else {
        // "ru-RU" maps to "ru" use case
        if (_languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_1__.l.has(lang.slice(0, 2))) {
            return _languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_1__.l.get(lang.slice(0, 2));
        }
        else {
            return "en";
        }
    }
}
function getComponentClosestLanguageIntl(element) {
    var _a, _b, _c;
    // it's OK if we don't have the 4 letter language file for it
    // 4 letter language code needed for formatting numbers
    const closestElement = (_a = (0,_dom_4d367677_js__WEBPACK_IMPORTED_MODULE_0__.c)(element, "[lang]")) !== null && _a !== void 0 ? _a : (_c = (_b = element.shadowRoot) === null || _b === void 0 ? void 0 : _b.ownerDocument) === null || _c === void 0 ? void 0 : _c.documentElement;
    // language set by the calling application or browser. defaults to english.
    const lang = ((closestElement === null || closestElement === void 0 ? void 0 : closestElement.lang) || (navigator === null || navigator === void 0 ? void 0 : navigator.language) || "en").toLowerCase();
    if (_languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_1__.l.has(lang)) {
        return _languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_1__.l.get(lang);
    }
    else {
        if (_languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_1__.l.has(lang.slice(0, 2))) {
            // we support the 2 letter coded language
            // e.g. it-CH vs it
            return lang;
        }
        else {
            return "en";
        }
    }
}
function fetchLocaleStringsForComponent(componentName, locale) {
    return new Promise((resolve, reject) => {
        fetch((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_2__.a)(`../arcgis-app-assets/i18n/${componentName}.i18n.${locale}.json`)).then((result) => {
            if (result.ok)
                resolve(result.json());
            else
                reject();
        }, () => reject());
    });
}
const stringCache = {};
function fetchLocaleStringsFromCache(componentName, locale) {
    const id = `${componentName}${locale}`;
    if (!stringCache[id]) {
        stringCache[id] = fetchLocaleStringsForComponent(componentName, locale);
    }
    return stringCache[id];
}
/**
 * Get strings and language codes.
 * This method returns 2 language codes.
 * The first one returns a code that's also supported as a language file.
 * The second one returns a code where there is support for the first 2 letters of the code as part of a language file,
 * but will return the original 4 letter code from the page.
 * E.g. For "it-ch" it will return "it" as the first language code and "it-ch" as the second.
 * The second one is required for esri.intl.setLocale() to get the correct formatting.
 *
 * If a tagName is provided it will overwite the element's tagName
 *
 *  @return [ strings, first language code, second language code]
 */
async function getLocaleComponentStrings(element, tagName) {
    const componentName = tagName || element.tagName.toLowerCase();
    const componentLanguage = getComponentClosestLanguage(element);
    const componentLanguageIntl = getComponentClosestLanguageIntl(element);
    let strings;
    try {
        strings = await fetchLocaleStringsFromCache(componentName, componentLanguage);
    }
    catch (e) {
        console.warn(`no locale for ${componentName} (${componentLanguage}) loading default locale en.`);
        strings = await fetchLocaleStringsFromCache(componentName, "en");
    }
    return [strings, componentLanguage, componentLanguageIntl];
}



//# sourceMappingURL=locale-050b6db9.js.map

/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid2lkZ2V0cy9jaHVua3MvYXJjZ2lzX2FuYWx5c2lzX25vZGVfbW9kdWxlc19hcmNnaXNfYXBwLWNvbXBvbmVudHNfZGlzdF9lc21fYXJjZ2lzLTA5OGY3OC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDNEg7QUFDbkU7QUFDYTtBQUNZO0FBQ3ZEO0FBQ1E7O0FBRW5DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMENBQTBDLGFBQWEsWUFBWSxnQ0FBZ0MsOENBQThDOztBQUVqSjtBQUNBO0FBQ0EsUUFBUSxxREFBZ0I7QUFDeEIsNENBQTRDLHFEQUFXO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixpRUFBaUU7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsMERBQVE7QUFDM0Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsMERBQVE7QUFDdEQ7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsMERBQVE7QUFDekQ7QUFDQTtBQUNBLFNBQVM7QUFDVDtB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O0FBQ047O0FBRXhEO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxtREFBaUM7QUFDbEU7QUFDQTtBQUNBLFFBQVEsd0RBQVc7QUFDbkIsZUFBZSx3REFBVztBQUMxQjtBQUNBO0FBQ0E7QUFDQSxZQUFZLHdEQUFXO0FBQ3ZCLG1CQUFtQix3REFBVztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxtREFBaUM7QUFDbEU7QUFDQTtBQUNBLFFBQVEsd0RBQVc7QUFDbkIsZUFBZSx3REFBVztBQUMxQjtBQUNBO0FBQ0EsWUFBWSx3REFBVztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxxREFBWSw4QkFBOEIsY0FBYyxRQUFRLE9BQU87QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixjQUFjLEVBQUUsT0FBTztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsZUFBZSxHQUFHLGtCQUFrQjtBQUMxRTtBQUNBO0FBQ0E7QUFDQTs7QUFFNEU7O0FBRTVFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZXhiLWNsaWVudC8uL2V4dGVuc2lvbnMvd2lkZ2V0cy9hcmNnaXMvYW5hbHlzaXMvbm9kZV9tb2R1bGVzL0BhcmNnaXMvYXBwLWNvbXBvbmVudHMvZGlzdC9lc20vYXJjZ2lzLWltYWdlLWRpc3BsYXktb3JkZXIuZW50cnkuanMiLCJ3ZWJwYWNrOi8vZXhiLWNsaWVudC8uL2V4dGVuc2lvbnMvd2lkZ2V0cy9hcmNnaXMvYW5hbHlzaXMvbm9kZV9tb2R1bGVzL0BhcmNnaXMvYXBwLWNvbXBvbmVudHMvZGlzdC9lc20vZnVuY3Rpb25hbC00NGRlOGZjZi5qcyIsIndlYnBhY2s6Ly9leGItY2xpZW50Ly4vZXh0ZW5zaW9ucy93aWRnZXRzL2FyY2dpcy9hbmFseXNpcy9ub2RlX21vZHVsZXMvQGFyY2dpcy9hcHAtY29tcG9uZW50cy9kaXN0L2VzbS9sYW5ndWFnZVV0aWwtZWYwZTU0YjIuanMiLCJ3ZWJwYWNrOi8vZXhiLWNsaWVudC8uL2V4dGVuc2lvbnMvd2lkZ2V0cy9hcmNnaXMvYW5hbHlzaXMvbm9kZV9tb2R1bGVzL0BhcmNnaXMvYXBwLWNvbXBvbmVudHMvZGlzdC9lc20vbG9jYWxlLTA1MGI2ZGI5LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogQWxsIG1hdGVyaWFsIGNvcHlyaWdodCBFU1JJLCBBbGwgUmlnaHRzIFJlc2VydmVkLCB1bmxlc3Mgb3RoZXJ3aXNlIHNwZWNpZmllZC5cbiAqIHY0LjAuNThcbiAqL1xuaW1wb3J0IHsgciBhcyByZWdpc3Rlckluc3RhbmNlLCBjIGFzIGNyZWF0ZUV2ZW50LCBoLCBIIGFzIEhvc3QsIEYgYXMgRnJhZ21lbnQsIGQgYXMgZ2V0RWxlbWVudCB9IGZyb20gJy4vaW5kZXgtZTNiZjdkYTcuanMnO1xuaW1wb3J0IHsgZCBhcyBkZWJvdW5jZSB9IGZyb20gJy4vZnVuY3Rpb25hbC00NGRlOGZjZi5qcyc7XG5pbXBvcnQgeyBnIGFzIGdldExvY2FsZUNvbXBvbmVudFN0cmluZ3MgfSBmcm9tICcuL2xvY2FsZS0wNTBiNmRiOS5qcyc7XG5pbXBvcnQgeyBnIGFzIGdldEVsZW1lbnREaXIsIEMgYXMgQ1NTX1VUSUxJVFkgfSBmcm9tICcuL2xhbmd1YWdlVXRpbC1lZjBlNTRiMi5qcyc7XG5pbXBvcnQgJy4vZG9tLTRkMzY3Njc3LmpzJztcbmltcG9ydCAnLi9sb2FkTW9kdWxlcy1iNGFjMTI0Ny5qcyc7XG5cbmNvbnN0IGRlZmF1bHRNb3NhaWNNZXRob2RzID0gW1xuICAgIFwiY2VudGVyXCIsXG4gICAgXCJub3J0aHdlc3RcIixcbiAgICBcImxvY2stcmFzdGVyXCIsXG4gICAgXCJhdHRyaWJ1dGVcIixcbiAgICBcIm5hZGlyXCIsXG4gICAgXCJ2aWV3cG9pbnRcIixcbiAgICBcInNlYW1saW5lXCIsXG4gICAgXCJub25lXCJcbl07XG5jb25zdCBkZWZhdWx0TW9zYWljT3BlcmF0b3JzID0gW1wiZmlyc3RcIiwgXCJsYXN0XCIsIFwibWluXCIsIFwibWF4XCIsIFwibWVhblwiLCBcImJsZW5kXCIsIFwic3VtXCJdO1xuY29uc3QgYWxsb3dlZEZpZWxkVHlwZUxpc3QgPSBbXG4gICAgXCJkb3VibGVcIixcbiAgICBcInNpbmdsZVwiLFxuICAgIFwibG9uZ1wiLFxuICAgIFwiaW50ZWdlclwiLFxuICAgIFwic21hbGwtaW50ZWdlclwiLFxuICAgIFwib2lkXCIsXG4gICAgXCJkYXRlXCIsXG4gICAgXCJiaWctaW50ZWdlclwiLFxuICAgIFwiZGF0ZS1vbmx5XCJcbl07XG5cbmNvbnN0IG1vc2FpY01ldGhvZE1hcHBpbmcgPSAobWV0aG9kKSA9PiB7XG4gICAgbWV0aG9kID0gbWV0aG9kLnRvTG93ZXJDYXNlKCk7XG4gICAgc3dpdGNoIChtZXRob2QpIHtcbiAgICAgICAgY2FzZSBcImxvY2tyYXN0ZXJcIjpcbiAgICAgICAgY2FzZSBcImxvY2stcmFzdGVyXCI6XG4gICAgICAgICAgICByZXR1cm4gXCJsb2NrLXJhc3RlclwiO1xuICAgICAgICBjYXNlIFwiYnlhdHRyaWJ1dGVcIjpcbiAgICAgICAgICAgIHJldHVybiBcImF0dHJpYnV0ZVwiO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIG1ldGhvZDtcbiAgICB9XG59O1xuY29uc3QgbW9zYWljTWV0aG9kVG9PcGVyYXRvcnNNYXBwaW5nID0gKG1vc2FpY01ldGhvZCkgPT4ge1xuICAgIHN3aXRjaCAobW9zYWljTWV0aG9kKSB7XG4gICAgICAgIGNhc2UgXCJzZWFtbGluZVwiOlxuICAgICAgICAgICAgcmV0dXJuIFtcImZpcnN0XCIsIFwiYmxlbmRcIl07XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gZGVmYXVsdE1vc2FpY09wZXJhdG9ycztcbiAgICB9XG59O1xuXG5jb25zdCBhcmNnaXNJbWFnZURpc3BsYXlPcmRlckNzcyA9IFwiOmhvc3R7ZGlzcGxheTpmbGV4O2hlaWdodDoxMDAlfS5pbWFnZS1kaXNwbGF5LW9yZGVyLWxvY2staW5wdXR7bWFyZ2luLXRvcDp2YXIoLS1hcmNnaXMtYXBwLWNhcC1zcGFjaW5nLWhhbGYpfVwiO1xuXG5jb25zdCBBcmNnaXNJbWFnZURpc3BsYXlPcmRlciA9IGNsYXNzIHtcbiAgICBjb25zdHJ1Y3Rvcihob3N0UmVmKSB7XG4gICAgICAgIHJlZ2lzdGVySW5zdGFuY2UodGhpcywgaG9zdFJlZik7XG4gICAgICAgIHRoaXMuYXJjZ2lzSW1hZ2VEaXNwbGF5T3JkZXJDbG9zZSA9IGNyZWF0ZUV2ZW50KHRoaXMsIFwiYXJjZ2lzSW1hZ2VEaXNwbGF5T3JkZXJDbG9zZVwiLCA3KTtcbiAgICAgICAgdGhpcy5tb3NhaWNNZXRob2RMaXN0ID0gZGVmYXVsdE1vc2FpY01ldGhvZHM7XG4gICAgICAgIHRoaXMuYXR0cmlidXRlRmllbGRMaXN0ID0gW107XG4gICAgICAgIHRoaXMuaGFuZGxlTW9zYWljTWV0aG9kQ2hhbmdlID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldCA9IGV2ZW50LnRhcmdldDtcbiAgICAgICAgICAgIGNvbnN0IHVwZGF0ZWRNZXRob2QgPSAoX2EgPSB0YXJnZXQuc2VsZWN0ZWRPcHRpb24pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS52YWx1ZTtcbiAgICAgICAgICAgIGNvbnN0IHsgbG9ja1Jhc3RlcklkczogYWN0aXZlTG9ja1Jhc3Rlcklkcywgb3BlcmF0aW9uOiBhY3RpdmVPcGVyYXRpb24gfSA9IHRoaXMuYWN0aXZlTW9zYWljUnVsZTtcbiAgICAgICAgICAgIGNvbnN0IHVwZGF0ZWRTb3J0RmllbGQgPSB1cGRhdGVkTWV0aG9kID09PSBcImF0dHJpYnV0ZVwiID8gKF9jID0gKF9iID0gdGhpcy5hdHRyaWJ1dGVGaWVsZExpc3QpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYlswXSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLm5hbWUgOiBudWxsO1xuICAgICAgICAgICAgY29uc3QgdXBkYXRlZExvY2tSYXN0ZXJJZHMgPSB1cGRhdGVkTWV0aG9kICE9PSBcImxvY2stcmFzdGVyXCIgPyBudWxsIDogYWN0aXZlTG9ja1Jhc3RlcklkcztcbiAgICAgICAgICAgIGNvbnN0IHVwZGF0ZWRBc2NlbmRpbmcgPSB1cGRhdGVkTWV0aG9kID09PSBcInNlYW1saW5lXCIgPyBudWxsIDogdHJ1ZTtcbiAgICAgICAgICAgIGNvbnN0IHNlYW1saW5lT3BlcmF0b3JzID0gbW9zYWljTWV0aG9kVG9PcGVyYXRvcnNNYXBwaW5nKFwic2VhbWxpbmVcIik7XG4gICAgICAgICAgICBjb25zdCB1cGRhdGVkT3BlcmF0aW9uID0gdXBkYXRlZE1ldGhvZCA9PT0gXCJzZWFtbGluZVwiICYmIHNlYW1saW5lT3BlcmF0b3JzLmluY2x1ZGVzKGFjdGl2ZU9wZXJhdGlvbilcbiAgICAgICAgICAgICAgICA/IGFjdGl2ZU9wZXJhdGlvblxuICAgICAgICAgICAgICAgIDogXCJmaXJzdFwiO1xuICAgICAgICAgICAgdGhpcy5hY3RpdmVNb3NhaWNSdWxlLm1ldGhvZCA9IHVwZGF0ZWRNZXRob2Q7XG4gICAgICAgICAgICB0aGlzLmFjdGl2ZU1vc2FpY1J1bGUuc29ydEZpZWxkID0gdXBkYXRlZFNvcnRGaWVsZDtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlTW9zYWljUnVsZS5zb3J0VmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5hY3RpdmVNb3NhaWNSdWxlLmxvY2tSYXN0ZXJJZHMgPSB1cGRhdGVkTG9ja1Jhc3RlcklkcztcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlTW9zYWljUnVsZS5hc2NlbmRpbmcgPSB1cGRhdGVkQXNjZW5kaW5nO1xuICAgICAgICAgICAgdGhpcy5hY3RpdmVNb3NhaWNSdWxlLm9wZXJhdGlvbiA9IHVwZGF0ZWRPcGVyYXRpb247XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUFjdGl2ZU1vc2FpY1J1bGUoKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVBdHRyaWJ1dGVGaWVsZENoYW5nZSA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgY29uc3QgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0O1xuICAgICAgICAgICAgY29uc3QgdXBkYXRlZFNvcnRGaWVsZCA9IChfYSA9IHRhcmdldC5zZWxlY3RlZE9wdGlvbikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnZhbHVlO1xuICAgICAgICAgICAgdGhpcy5hY3RpdmVNb3NhaWNSdWxlLnNvcnRGaWVsZCA9IHVwZGF0ZWRTb3J0RmllbGQ7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUFjdGl2ZU1vc2FpY1J1bGUoKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5kZWJvdW5jZWRIYW5kbGVBdHRyaWJ1dGVWYWx1ZUNoYW5nZSA9IGRlYm91bmNlKChzb3J0VmFsdWUpID0+IHtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlTW9zYWljUnVsZS5zb3J0VmFsdWUgPSBzb3J0VmFsdWU7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUFjdGl2ZU1vc2FpY1J1bGUoKTtcbiAgICAgICAgfSwgMzAwKTtcbiAgICAgICAgdGhpcy5oYW5kbGVEYXRlQXR0cmlidXRlVmFsdWVDaGFuZ2UgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldCA9IGV2ZW50LnRhcmdldDtcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldFZhbHVlID0gdGFyZ2V0ID09PSBudWxsIHx8IHRhcmdldCA9PT0gdm9pZCAwID8gdm9pZCAwIDogdGFyZ2V0LnZhbHVlO1xuICAgICAgICAgICAgY29uc3QgdXBkYXRlZFNvcnRWYWx1ZSA9IHRhcmdldFZhbHVlLnJlcGxhY2UoL1xcLS9nLCBcIi9cIik7XG4gICAgICAgICAgICB0aGlzLmRlYm91bmNlZEhhbmRsZUF0dHJpYnV0ZVZhbHVlQ2hhbmdlKHVwZGF0ZWRTb3J0VmFsdWUpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZUF0dHJpYnV0ZVZhbHVlQ2hhbmdlID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB0YXJnZXQgPSBldmVudC50YXJnZXQ7XG4gICAgICAgICAgICBjb25zdCB0YXJnZXRWYWx1ZSA9IHRhcmdldCA9PT0gbnVsbCB8fCB0YXJnZXQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHRhcmdldC52YWx1ZTtcbiAgICAgICAgICAgIGNvbnN0IHVwZGF0ZWRTb3J0VmFsdWUgPSArdGFyZ2V0VmFsdWU7XG4gICAgICAgICAgICB0aGlzLmRlYm91bmNlZEhhbmRsZUF0dHJpYnV0ZVZhbHVlQ2hhbmdlKHVwZGF0ZWRTb3J0VmFsdWUpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmRlYm91bmNlZEhhbmRsZVJhc3RlcklEc0NoYW5nZSA9IGRlYm91bmNlKChyYXN0ZXJJZHMpID0+IHtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlTW9zYWljUnVsZS5sb2NrUmFzdGVySWRzID0gcmFzdGVySWRzO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVBY3RpdmVNb3NhaWNSdWxlKCk7XG4gICAgICAgIH0sIDMwMCk7XG4gICAgICAgIHRoaXMuaGFuZGxlUmFzdGVySURzQ2hhbmdlID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB0YXJnZXQgPSBldmVudC50YXJnZXQ7XG4gICAgICAgICAgICBjb25zdCB1cGRhdGVkUmFzdGVySWRzID0gdGFyZ2V0ID09PSBudWxsIHx8IHRhcmdldCA9PT0gdm9pZCAwID8gdm9pZCAwIDogdGFyZ2V0LnZhbHVlO1xuICAgICAgICAgICAgY29uc3QgY29tbWFTZXBhcmF0ZWROdW1SZWdFeHAgPSAvXlswLTldKygsWzAtOV0rKSokLztcbiAgICAgICAgICAgIGlmICghY29tbWFTZXBhcmF0ZWROdW1SZWdFeHAudGVzdCh1cGRhdGVkUmFzdGVySWRzKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHVwZGF0ZWRMb2NrUmFzdGVySWRzID0gdXBkYXRlZFJhc3Rlcklkc1xuICAgICAgICAgICAgICAgIC5zcGxpdChcIixcIilcbiAgICAgICAgICAgICAgICAubWFwKChyYXN0ZXJJZCkgPT4gcGFyc2VJbnQocmFzdGVySWQsIDEwKSk7XG4gICAgICAgICAgICB0aGlzLmRlYm91bmNlZEhhbmRsZVJhc3RlcklEc0NoYW5nZSh1cGRhdGVkTG9ja1Jhc3Rlcklkcyk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZGVib3VuY2VkSGFuZGxlUmV2ZXJzZU9yZGVyQ2hhbmdlID0gZGVib3VuY2UoKHJldmVyc2VPcmRlcikgPT4ge1xuICAgICAgICAgICAgdGhpcy5hY3RpdmVNb3NhaWNSdWxlLmFzY2VuZGluZyA9ICFyZXZlcnNlT3JkZXI7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUFjdGl2ZU1vc2FpY1J1bGUoKTtcbiAgICAgICAgfSwgMzAwKTtcbiAgICAgICAgdGhpcy5oYW5kbGVSZXZlcnNlT3JkZXJDaGFuZ2UgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldCA9IGV2ZW50LnRhcmdldDtcbiAgICAgICAgICAgIGNvbnN0IHVwZGF0ZWRSZXZlcnNlT3JkZXIgPSB0YXJnZXQgPT09IG51bGwgfHwgdGFyZ2V0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0YXJnZXQuY2hlY2tlZDtcbiAgICAgICAgICAgIHRoaXMuZGVib3VuY2VkSGFuZGxlUmV2ZXJzZU9yZGVyQ2hhbmdlKHVwZGF0ZWRSZXZlcnNlT3JkZXIpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZU1vc2FpY09wZXJhdG9yQ2hhbmdlID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICBjb25zdCB0YXJnZXQgPSBldmVudC50YXJnZXQ7XG4gICAgICAgICAgICBjb25zdCB1cGRhdGVkT3BlcmF0b3IgPSAoX2EgPSB0YXJnZXQuc2VsZWN0ZWRPcHRpb24pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS52YWx1ZTtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlTW9zYWljUnVsZS5vcGVyYXRpb24gPSB1cGRhdGVkT3BlcmF0b3I7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUFjdGl2ZU1vc2FpY1J1bGUoKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVEb25lID0gKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5hcmNnaXNJbWFnZURpc3BsYXlPcmRlckNsb3NlLmVtaXQoXCJzYXZlXCIpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZUNhbmNlbCA9ICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMubGF5ZXIubW9zYWljUnVsZSA9IHRoaXMub3JpZ2luYWxNb3NhaWNSdWxlO1xuICAgICAgICAgICAgdGhpcy5hY3RpdmVNb3NhaWNSdWxlID0gdGhpcy5vcmlnaW5hbE1vc2FpY1J1bGUuY2xvbmUoKTtcbiAgICAgICAgICAgIHRoaXMuYXJjZ2lzSW1hZ2VEaXNwbGF5T3JkZXJDbG9zZS5lbWl0KFwiY2FuY2VsXCIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmxheWVyID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmRpc21pc3NpYmxlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuYWN0aXZlTW9zYWljUnVsZSA9IG51bGw7XG4gICAgfVxuICAgIHdhdGNoU3RhdGVIYW5kbGVyKG5ld01vc2FpY1J1bGUsIG9sZE1vc2FpY1J1bGUpIHtcbiAgICAgICAgaWYgKCFuZXdNb3NhaWNSdWxlIHx8ICFvbGRNb3NhaWNSdWxlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sYXllci5tb3NhaWNSdWxlID0gbmV3TW9zYWljUnVsZTtcbiAgICB9XG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vXG4gICAgLy8gIExpZmVjeWNsZVxuICAgIC8vXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIGFzeW5jIGNvbXBvbmVudFdpbGxMb2FkKCkge1xuICAgICAgICBjb25zdCBbc3RyaW5nc10gPSBhd2FpdCBnZXRMb2NhbGVDb21wb25lbnRTdHJpbmdzKHRoaXMuaG9zdEVsZW1lbnQpO1xuICAgICAgICB0aGlzLnN0cmluZ3MgPSBzdHJpbmdzO1xuICAgICAgICB0aGlzLmluaXQoKTtcbiAgICB9XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvL1xuICAgIC8vICBSZW5kZXIgTWV0aG9kc1xuICAgIC8vXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgY29uc3QgcnRsID0gZ2V0RWxlbWVudERpcih0aGlzLmhvc3RFbGVtZW50KSA9PT0gXCJydGxcIjtcbiAgICAgICAgcmV0dXJuIChoKEhvc3QsIHsgY2xhc3M6IFwiY2FsY2l0ZS1tYXRjaC1oZWlnaHRcIiB9LCBoKFwiY2FsY2l0ZS1wYW5lbFwiLCB7IGhlYWRpbmc6IHRoaXMuc3RyaW5ncy5pbWFnZURpc3BsYXlPcmRlciwgY2xvc2FibGU6IHRoaXMuZGlzbWlzc2libGUsIGxvYWRpbmc6ICF0aGlzLmFjdGl2ZU1vc2FpY1J1bGUsIG9uQ2FsY2l0ZVBhbmVsQ2xvc2U6IHRoaXMuaGFuZGxlQ2FuY2VsLCBjbGFzczoge1xuICAgICAgICAgICAgICAgIHBhbmVsOiB0cnVlLFxuICAgICAgICAgICAgICAgIFtDU1NfVVRJTElUWS5ydGxdOiBydGxcbiAgICAgICAgICAgIH0gfSwgdGhpcy5yZW5kZXJNb3NhaWNSdWxlKCksIHRoaXMucmVuZGVyRm9vdGVyQWN0aW9ucygpKSkpO1xuICAgIH1cbiAgICByZW5kZXJNb3NhaWNSdWxlKCkge1xuICAgICAgICBpZiAoIXRoaXMuYWN0aXZlTW9zYWljUnVsZSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYWN0aXZlTW9zYWljTWV0aG9kID0gdGhpcy5hY3RpdmVNb3NhaWNSdWxlLm1ldGhvZDtcbiAgICAgICAgY29uc3Qgc2hvdWxkUmVuZGVyQXR0cmlidXRlRmlsdGVyID0gYWN0aXZlTW9zYWljTWV0aG9kID09PSBcImF0dHJpYnV0ZVwiO1xuICAgICAgICBjb25zdCBzaG91bGRSZW5kZXJSYXN0ZXJJZHMgPSBhY3RpdmVNb3NhaWNNZXRob2QgPT09IFwibG9jay1yYXN0ZXJcIjtcbiAgICAgICAgY29uc3Qgc2hvdWxkUmVuZGVyUmV2ZXJzZU9yZGVyID0gYWN0aXZlTW9zYWljTWV0aG9kICE9PSBcInNlYW1saW5lXCI7XG4gICAgICAgIHJldHVybiAoaChcImNhbGNpdGUtYmxvY2tcIiwgeyBoZWFkaW5nOiBcIlwiLCBvcGVuOiB0cnVlIH0sIHRoaXMucmVuZGVyTW9zYWljTWV0aG9kU2VsZWN0aW9uKCksIHNob3VsZFJlbmRlckF0dHJpYnV0ZUZpbHRlciAmJiB0aGlzLnJlbmRlckF0dHJpYnV0ZUZpbHRlcigpLCBzaG91bGRSZW5kZXJSYXN0ZXJJZHMgJiYgdGhpcy5yZW5kZXJSYXN0ZXJJZCgpLCBzaG91bGRSZW5kZXJSZXZlcnNlT3JkZXIgJiYgdGhpcy5yZW5kZXJSZXZlcnNlT3JkZXIoKSwgdGhpcy5yZW5kZXJNb3NhaWNPcGVyYXRvclNlbGVjdGlvbigpKSk7XG4gICAgfVxuICAgIHJlbmRlck1vc2FpY01ldGhvZFNlbGVjdGlvbigpIHtcbiAgICAgICAgY29uc3QgeyBtZXRob2Q6IGFjdGl2ZU1ldGhvZCB9ID0gdGhpcy5hY3RpdmVNb3NhaWNSdWxlO1xuICAgICAgICBjb25zdCB7IG1vc2FpY01ldGhvZCwgY29tcG9uZW50TGFiZWwsIG1vc2FpY01ldGhvZExhYmVsIH0gPSB0aGlzLnN0cmluZ3M7XG4gICAgICAgIHJldHVybiAoaChcImNhbGNpdGUtbGFiZWxcIiwgbnVsbCwgbW9zYWljTWV0aG9kLCBoKFwiY2FsY2l0ZS1zZWxlY3RcIiwgeyBsYWJlbDogY29tcG9uZW50TGFiZWxbXCJtZXRob2RTZWxlY3RcIl0sIG9uQ2FsY2l0ZVNlbGVjdENoYW5nZTogdGhpcy5oYW5kbGVNb3NhaWNNZXRob2RDaGFuZ2UgfSwgdGhpcy5tb3NhaWNNZXRob2RMaXN0Lm1hcCgobWV0aG9kKSA9PiAoaChcImNhbGNpdGUtb3B0aW9uXCIsIHsga2V5OiBtZXRob2QsIHZhbHVlOiBtZXRob2QsIGxhYmVsOiBtb3NhaWNNZXRob2RMYWJlbFttZXRob2RdLCBzZWxlY3RlZDogbWV0aG9kID09PSBhY3RpdmVNZXRob2QgfSkpKSkpKTtcbiAgICB9XG4gICAgcmVuZGVyQXR0cmlidXRlRmlsdGVyKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IHsgc29ydEZpZWxkIH0gPSB0aGlzLmFjdGl2ZU1vc2FpY1J1bGU7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRTb3J0RmllbGRUeXBlID0gKF9hID0gdGhpcy5hdHRyaWJ1dGVGaWVsZExpc3QuZmluZCgoeyBuYW1lIH0pID0+IG5hbWUgPT09IHNvcnRGaWVsZCkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS50eXBlO1xuICAgICAgICBjb25zdCBzaG91bGRSZW5kZXJEYXRlQXR0cmlidXRlRmlsdGVyID0gY3VycmVudFNvcnRGaWVsZFR5cGUgPT09IFwiZGF0ZVwiIHx8IGN1cnJlbnRTb3J0RmllbGRUeXBlID09PSBcImRhdGUtb25seVwiO1xuICAgICAgICByZXR1cm4gKGgoXCJkaXZcIiwgbnVsbCwgdGhpcy5yZW5kZXJBdHRyaWJ1dGVNZXRob2RTZWxlY3Rpb24oKSwgc2hvdWxkUmVuZGVyRGF0ZUF0dHJpYnV0ZUZpbHRlclxuICAgICAgICAgICAgPyB0aGlzLnJlbmRlckF0dHJpYnV0ZURhdGVQaWNrZXIoKVxuICAgICAgICAgICAgOiB0aGlzLnJlbmRlckF0dHJpYnV0ZVNvcnRWYWx1ZSgpKSk7XG4gICAgfVxuICAgIHJlbmRlckF0dHJpYnV0ZU1ldGhvZFNlbGVjdGlvbigpIHtcbiAgICAgICAgY29uc3QgeyBzb3J0RmllbGQ6IGFjdGl2ZVNvcnRGaWVsZCB9ID0gdGhpcy5hY3RpdmVNb3NhaWNSdWxlO1xuICAgICAgICBjb25zdCB7IGF0dHJpYnV0ZSwgY29tcG9uZW50TGFiZWwgfSA9IHRoaXMuc3RyaW5ncztcbiAgICAgICAgcmV0dXJuIChoKFwiY2FsY2l0ZS1sYWJlbFwiLCBudWxsLCBhdHRyaWJ1dGUsIGgoXCJjYWxjaXRlLXNlbGVjdFwiLCB7IGxhYmVsOiBjb21wb25lbnRMYWJlbFtcImF0dHJpYnV0ZUZpZWxkU2VsZWN0XCJdLCBvbkNhbGNpdGVTZWxlY3RDaGFuZ2U6IHRoaXMuaGFuZGxlQXR0cmlidXRlRmllbGRDaGFuZ2UgfSwgdGhpcy5hdHRyaWJ1dGVGaWVsZExpc3QubWFwKCh7IG5hbWUsIGFsaWFzIH0pID0+IChoKFwiY2FsY2l0ZS1vcHRpb25cIiwgeyBrZXk6IG5hbWUsIHZhbHVlOiBuYW1lLCBsYWJlbDogYWxpYXMsIHNlbGVjdGVkOiBuYW1lID09PSBhY3RpdmVTb3J0RmllbGQgfSkpKSkpKTtcbiAgICB9XG4gICAgcmVuZGVyQXR0cmlidXRlRGF0ZVBpY2tlcigpIHtcbiAgICAgICAgY29uc3QgeyBzb3J0VmFsdWUgfSA9IHRoaXMuYWN0aXZlTW9zYWljUnVsZTtcbiAgICAgICAgY29uc3QgeyBoaWdoZXN0UHJpb3JpdHlWYWx1ZSB9ID0gdGhpcy5zdHJpbmdzO1xuICAgICAgICBjb25zdCBkYXRlUGlja2VyVmFsdWUgPSAoc29ydFZhbHVlID09PSBudWxsIHx8IHNvcnRWYWx1ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogc29ydFZhbHVlLnRvU3RyaW5nKCkuaW5kZXhPZihcIi9cIikpID4gLTEgPyBzb3J0VmFsdWUucmVwbGFjZSgvXFwvL2csIFwiLVwiKSA6IFwiXCI7XG4gICAgICAgIHJldHVybiAoaChcImNhbGNpdGUtbGFiZWxcIiwgbnVsbCwgaGlnaGVzdFByaW9yaXR5VmFsdWUsIGgoXCJjYWxjaXRlLWlucHV0LWRhdGUtcGlja2VyXCIsIHsgcGxhY2VtZW50OiBcImJvdHRvbS1lbmRcIiwgXCJvdmVybGF5LXBvc2l0aW9uaW5nXCI6IFwiZml4ZWRcIiwgdmFsdWU6IGRhdGVQaWNrZXJWYWx1ZSwgb25DYWxjaXRlSW5wdXREYXRlUGlja2VyQ2hhbmdlOiB0aGlzLmhhbmRsZURhdGVBdHRyaWJ1dGVWYWx1ZUNoYW5nZSB9KSkpO1xuICAgIH1cbiAgICByZW5kZXJBdHRyaWJ1dGVTb3J0VmFsdWUoKSB7XG4gICAgICAgIGNvbnN0IHsgc29ydFZhbHVlIH0gPSB0aGlzLmFjdGl2ZU1vc2FpY1J1bGU7XG4gICAgICAgIGNvbnN0IHsgaGlnaGVzdFByaW9yaXR5VmFsdWUgfSA9IHRoaXMuc3RyaW5ncztcbiAgICAgICAgcmV0dXJuIChoKFwiY2FsY2l0ZS1sYWJlbFwiLCBudWxsLCBoaWdoZXN0UHJpb3JpdHlWYWx1ZSwgaChcImNhbGNpdGUtaW5wdXRcIiwgeyB0eXBlOiBcIm51bWJlclwiLCBzdGVwOiAwLjAwMSwgdmFsdWU6IHNvcnRWYWx1ZSA9PT0gbnVsbCB8fCBzb3J0VmFsdWUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNvcnRWYWx1ZS50b1N0cmluZygpLCBvbkNhbGNpdGVJbnB1dElucHV0OiB0aGlzLmhhbmRsZUF0dHJpYnV0ZVZhbHVlQ2hhbmdlIH0pKSk7XG4gICAgfVxuICAgIHJlbmRlclJhc3RlcklkKCkge1xuICAgICAgICBjb25zdCB7IGxvY2tSYXN0ZXJJZHMgfSA9IHRoaXMuYWN0aXZlTW9zYWljUnVsZTtcbiAgICAgICAgY29uc3QgcmFzdGVySWRzU3RyaW5nID0gbG9ja1Jhc3RlcklkcyA9PT0gbnVsbCB8fCBsb2NrUmFzdGVySWRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBsb2NrUmFzdGVySWRzLmpvaW4oXCIsXCIpO1xuICAgICAgICByZXR1cm4gKGgoXCJjYWxjaXRlLWxhYmVsXCIsIG51bGwsIHRoaXMuc3RyaW5ncy5pbWFnZUlEcywgaChcImNhbGNpdGUtaW5wdXRcIiwgeyBjbGFzczogXCJpbWFnZS1kaXNwbGF5LW9yZGVyLWxvY2staW5wdXRcIiwgcGxhY2Vob2xkZXI6IHRoaXMuc3RyaW5ncy51c2VDb21tYURlbGltaXRlciwgdmFsdWU6IHJhc3Rlcklkc1N0cmluZywgb25DYWxjaXRlSW5wdXRJbnB1dDogdGhpcy5oYW5kbGVSYXN0ZXJJRHNDaGFuZ2UgfSkpKTtcbiAgICB9XG4gICAgcmVuZGVyUmV2ZXJzZU9yZGVyKCkge1xuICAgICAgICBjb25zdCB7IGFzY2VuZGluZyB9ID0gdGhpcy5hY3RpdmVNb3NhaWNSdWxlO1xuICAgICAgICByZXR1cm4gKGgoXCJjYWxjaXRlLWxhYmVsXCIsIHsgbGF5b3V0OiBcImlubGluZS1zcGFjZS1iZXR3ZWVuXCIgfSwgdGhpcy5zdHJpbmdzLnJldmVyc2VyT3JkZXIsIGgoXCJjYWxjaXRlLXN3aXRjaFwiLCB7IGNoZWNrZWQ6ICFhc2NlbmRpbmcsIG9uQ2FsY2l0ZVN3aXRjaENoYW5nZTogdGhpcy5oYW5kbGVSZXZlcnNlT3JkZXJDaGFuZ2UgfSkpKTtcbiAgICB9XG4gICAgcmVuZGVyTW9zYWljT3BlcmF0b3JTZWxlY3Rpb24oKSB7XG4gICAgICAgIGNvbnN0IHsgbWV0aG9kLCBvcGVyYXRpb246IGFjdGl2ZU9wZXJhdG9yIH0gPSB0aGlzLmFjdGl2ZU1vc2FpY1J1bGU7XG4gICAgICAgIGNvbnN0IG1vc2FpY09wZXJhdG9yTGlzdCA9IG1vc2FpY01ldGhvZFRvT3BlcmF0b3JzTWFwcGluZyhtZXRob2QpO1xuICAgICAgICBjb25zdCB7IG1vc2FpY09wZXJhdG9yLCBjb21wb25lbnRMYWJlbCwgbW9zYWljT3BlcmF0b3JMYWJlbCB9ID0gdGhpcy5zdHJpbmdzO1xuICAgICAgICByZXR1cm4gKGgoXCJjYWxjaXRlLWxhYmVsXCIsIG51bGwsIG1vc2FpY09wZXJhdG9yLCBoKFwiY2FsY2l0ZS1zZWxlY3RcIiwgeyBsYWJlbDogY29tcG9uZW50TGFiZWxbXCJvcGVyYXRvclNlbGVjdFwiXSwgb25DYWxjaXRlU2VsZWN0Q2hhbmdlOiB0aGlzLmhhbmRsZU1vc2FpY09wZXJhdG9yQ2hhbmdlIH0sIG1vc2FpY09wZXJhdG9yTGlzdC5tYXAoKG9wZXJhdG9yKSA9PiAoaChcImNhbGNpdGUtb3B0aW9uXCIsIHsga2V5OiBvcGVyYXRvciwgdmFsdWU6IG9wZXJhdG9yLCBsYWJlbDogbW9zYWljT3BlcmF0b3JMYWJlbFtvcGVyYXRvcl0sIHNlbGVjdGVkOiBvcGVyYXRvciA9PT0gYWN0aXZlT3BlcmF0b3IgfSkpKSkpKTtcbiAgICB9XG4gICAgcmVuZGVyRm9vdGVyQWN0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIChoKEZyYWdtZW50LCBudWxsLCB0aGlzLnJlbmRlckRvbmVCdXR0b24oKSwgdGhpcy5yZW5kZXJDYW5jZWxCdXR0b24oKSkpO1xuICAgIH1cbiAgICByZW5kZXJEb25lQnV0dG9uKCkge1xuICAgICAgICByZXR1cm4gKGgoXCJjYWxjaXRlLWJ1dHRvblwiLCB7IHNsb3Q6IFwiZm9vdGVyXCIsIGFwcGVhcmFuY2U6IFwic29saWRcIiwgY29sb3I6IFwiYmx1ZVwiLCB3aWR0aDogXCJoYWxmXCIsIGRpc2FibGVkOiAhdGhpcy5hY3RpdmVNb3NhaWNSdWxlLCBvbkNsaWNrOiB0aGlzLmhhbmRsZURvbmUgfSwgdGhpcy5zdHJpbmdzLmRvbmUpKTtcbiAgICB9XG4gICAgcmVuZGVyQ2FuY2VsQnV0dG9uKCkge1xuICAgICAgICByZXR1cm4gKGgoXCJjYWxjaXRlLWJ1dHRvblwiLCB7IHNsb3Q6IFwiZm9vdGVyXCIsIGFwcGVhcmFuY2U6IFwib3V0bGluZS1maWxsXCIsIHdpZHRoOiBcImhhbGZcIiwgZGlzYWJsZWQ6ICF0aGlzLmFjdGl2ZU1vc2FpY1J1bGUsIG9uQ2xpY2s6IHRoaXMuaGFuZGxlQ2FuY2VsIH0sIHRoaXMuc3RyaW5ncy5jYW5jZWwpKTtcbiAgICB9XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvL1xuICAgIC8vICBQcml2YXRlIG1ldGhvZHNcbiAgICAvL1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgYXN5bmMgaW5pdCgpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sYXllci5sb2FkKCk7XG4gICAgICAgIHRoaXMub3JpZ2luYWxNb3NhaWNSdWxlID0gdGhpcy5nZXRPcmlnaW5hbE1vc2FpY1J1bGUoKTtcbiAgICAgICAgdGhpcy5hY3RpdmVNb3NhaWNSdWxlID0gdGhpcy5vcmlnaW5hbE1vc2FpY1J1bGUuY2xvbmUoKTtcbiAgICAgICAgdGhpcy5tb3NhaWNNZXRob2RMaXN0ID0gdGhpcy5nZXRNb3NhaWNNZXRob2RMaXN0KCk7XG4gICAgICAgIHRoaXMuYXR0cmlidXRlRmllbGRMaXN0ID0gdGhpcy5nZXRBdHRyaWJ1dGVGaWVsZExpc3QoKTtcbiAgICB9XG4gICAgdXBkYXRlQWN0aXZlTW9zYWljUnVsZSgpIHtcbiAgICAgICAgdGhpcy5hY3RpdmVNb3NhaWNSdWxlID0gdGhpcy5hY3RpdmVNb3NhaWNSdWxlLmNsb25lKCk7XG4gICAgfVxuICAgIGdldE9yaWdpbmFsTW9zYWljUnVsZSgpIHtcbiAgICAgICAgY29uc3QgeyBtb3NhaWNSdWxlLCBkZWZhdWx0TW9zYWljUnVsZSB9ID0gdGhpcy5sYXllcjtcbiAgICAgICAgcmV0dXJuIG1vc2FpY1J1bGUgIT09IG51bGwgJiYgbW9zYWljUnVsZSAhPT0gdm9pZCAwID8gbW9zYWljUnVsZSA6IGRlZmF1bHRNb3NhaWNSdWxlO1xuICAgIH1cbiAgICBnZXRBbGxvd2VkQXR0cmlidXRlRmllbGRMaXN0KCkge1xuICAgICAgICBjb25zdCB7IGZpZWxkczogbGF5ZXJGaWVsZHMsIHNvdXJjZUpTT04gfSA9IHRoaXMubGF5ZXI7XG4gICAgICAgIGNvbnN0IGFsbG93ZWRGaWVsZExpc3QgPSBsYXllckZpZWxkcy5maWx0ZXIoKHsgdHlwZSB9KSA9PiBhbGxvd2VkRmllbGRUeXBlTGlzdC5pbmNsdWRlcyh0eXBlKSk7XG4gICAgICAgIGFsbG93ZWRGaWVsZExpc3Quc29ydCgoYSwgYikgPT4gYS5hbGlhcy5sb2NhbGVDb21wYXJlKGIuYWxpYXMpKTtcbiAgICAgICAgY29uc3QgeyBzb3J0YWJsZUZpZWxkcyB9ID0gc291cmNlSlNPTiB8fCB7fTtcbiAgICAgICAgaWYgKCEoc29ydGFibGVGaWVsZHMgPT09IG51bGwgfHwgc29ydGFibGVGaWVsZHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNvcnRhYmxlRmllbGRzLmxlbmd0aCkpIHtcbiAgICAgICAgICAgIHJldHVybiBhbGxvd2VkRmllbGRMaXN0O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNvdXJjZUpTT05Tb3J0YWJsZUZpZWxkcyA9IHNvcnRhYmxlRmllbGRzID09PSBudWxsIHx8IHNvcnRhYmxlRmllbGRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzb3J0YWJsZUZpZWxkcy5zcGxpdChcIixcIikubWFwKChmaWVsZCkgPT4gZmllbGQudG9Mb3dlckNhc2UoKSk7XG4gICAgICAgIGNvbnN0IGZpZWxkTGlzdCA9IGFsbG93ZWRGaWVsZExpc3QuZmlsdGVyKChsYXllckZpZWxkKSA9PiBzb3VyY2VKU09OU29ydGFibGVGaWVsZHMuaW5jbHVkZXMobGF5ZXJGaWVsZC5uYW1lLnRvTG9jYWxlTG93ZXJDYXNlKCkpKTtcbiAgICAgICAgcmV0dXJuIGZpZWxkTGlzdDtcbiAgICB9XG4gICAgZmlsdGVyQXR0cmlidXRlRmllbGRMaXN0KGF0dHJpYnV0ZUZpZWxkTGlzdCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBjb25zdCBzaG91bGRGaWx0ZXJDYXRlZ29yeSA9ICgoX2IgPSAoX2EgPSB0aGlzLmxheWVyLnNvdXJjZUpTT04pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zb3J0RmllbGQpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi50b0xvd2VyQ2FzZSgpKSAhPT0gXCJjYXRlZ29yeVwiO1xuICAgICAgICBpZiAoIXNob3VsZEZpbHRlckNhdGVnb3J5KSB7XG4gICAgICAgICAgICByZXR1cm4gYXR0cmlidXRlRmllbGRMaXN0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhdHRyaWJ1dGVGaWVsZExpc3QuZmlsdGVyKChsYXllckZpZWxkKSA9PiBsYXllckZpZWxkLm5hbWUudG9Mb2NhbGVMb3dlckNhc2UoKSAhPT0gXCJjYXRlZ29yeVwiKTtcbiAgICB9XG4gICAgZ2V0QXR0cmlidXRlRmllbGRMaXN0KCkge1xuICAgICAgICBjb25zdCBhbGxvd2VkQXR0cmlidXRlRmllbGRMaXN0ID0gdGhpcy5nZXRBbGxvd2VkQXR0cmlidXRlRmllbGRMaXN0KCk7XG4gICAgICAgIGNvbnN0IGZpbHRlcmVkQXR0cmlidXRlRmllbGRMaXN0ID0gdGhpcy5maWx0ZXJBdHRyaWJ1dGVGaWVsZExpc3QoYWxsb3dlZEF0dHJpYnV0ZUZpZWxkTGlzdCk7XG4gICAgICAgIHJldHVybiBmaWx0ZXJlZEF0dHJpYnV0ZUZpZWxkTGlzdDtcbiAgICB9XG4gICAgZ2V0QWxsb3dlZE1vc2FpY01ldGhvZExpc3QoKSB7XG4gICAgICAgIGNvbnN0IHsgc291cmNlSlNPTiB9ID0gdGhpcy5sYXllcjtcbiAgICAgICAgaWYgKCFzb3VyY2VKU09OKSB7XG4gICAgICAgICAgICByZXR1cm4gZGVmYXVsdE1vc2FpY01ldGhvZHM7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBjdXJyZW50VmVyc2lvbiwgYWxsb3dlZE1vc2FpY01ldGhvZHM6IHNvdXJjZUpTT05BbGxvd2VkTW9zYWljTWV0aG9kcyB9ID0gc291cmNlSlNPTjtcbiAgICAgICAgY29uc3QgaXNWYWxpZFZlcnNpb24gPSBjdXJyZW50VmVyc2lvbiAmJiBjdXJyZW50VmVyc2lvbiA+PSAxMC4xO1xuICAgICAgICBjb25zdCBoYXNBbGxvd2VkTW9zYWNpTWV0aG9kcyA9IChzb3VyY2VKU09OQWxsb3dlZE1vc2FpY01ldGhvZHMgPT09IG51bGwgfHwgc291cmNlSlNPTkFsbG93ZWRNb3NhaWNNZXRob2RzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzb3VyY2VKU09OQWxsb3dlZE1vc2FpY01ldGhvZHMubGVuZ3RoKSA+IDE7XG4gICAgICAgIGlmICghaXNWYWxpZFZlcnNpb24gfHwgIWhhc0FsbG93ZWRNb3NhY2lNZXRob2RzKSB7XG4gICAgICAgICAgICByZXR1cm4gZGVmYXVsdE1vc2FpY01ldGhvZHM7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYWxsb3dlZE1vc2FpY01ldGhvZExpc3QgPSBzb3VyY2VKU09OQWxsb3dlZE1vc2FpY01ldGhvZHNcbiAgICAgICAgICAgIC5zcGxpdChcIixcIilcbiAgICAgICAgICAgIC5tYXAoKG1ldGhvZCkgPT4gbW9zYWljTWV0aG9kTWFwcGluZyhtZXRob2QudG9Mb3dlckNhc2UoKSkpO1xuICAgICAgICBjb25zdCBub25lTW9zYWljTWV0aG9kID0gXCJub25lXCI7XG4gICAgICAgIGlmICghYWxsb3dlZE1vc2FpY01ldGhvZExpc3QuaW5jbHVkZXMobm9uZU1vc2FpY01ldGhvZCkpIHtcbiAgICAgICAgICAgIGFsbG93ZWRNb3NhaWNNZXRob2RMaXN0LnB1c2gobm9uZU1vc2FpY01ldGhvZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFsbG93ZWRNb3NhaWNNZXRob2RMaXN0O1xuICAgIH1cbiAgICBmaWx0ZXJlZE1vc2FpY01ldGhvZExpc3QobW9zYWljTWV0aG9kTGlzdCkge1xuICAgICAgICBjb25zdCB2aWV3cG9pbnRNb3NhaWNNZXRob2QgPSBcInZpZXdwb2ludFwiO1xuICAgICAgICByZXR1cm4gbW9zYWljTWV0aG9kTGlzdC5maWx0ZXIoKG1ldGhvZCkgPT4gbWV0aG9kICE9PSB2aWV3cG9pbnRNb3NhaWNNZXRob2QpO1xuICAgIH1cbiAgICBnZXRNb3NhaWNNZXRob2RMaXN0KCkge1xuICAgICAgICBjb25zdCBhbGxvd2VkTW9zYWljTWV0aG9kcyA9IHRoaXMuZ2V0QWxsb3dlZE1vc2FpY01ldGhvZExpc3QoKTtcbiAgICAgICAgY29uc3QgZmlsdGVyZWRNb3NhaWNNZXRob2RzID0gdGhpcy5maWx0ZXJlZE1vc2FpY01ldGhvZExpc3QoYWxsb3dlZE1vc2FpY01ldGhvZHMpO1xuICAgICAgICByZXR1cm4gZmlsdGVyZWRNb3NhaWNNZXRob2RzO1xuICAgIH1cbiAgICBnZXQgaG9zdEVsZW1lbnQoKSB7IHJldHVybiBnZXRFbGVtZW50KHRoaXMpOyB9XG4gICAgc3RhdGljIGdldCB3YXRjaGVycygpIHsgcmV0dXJuIHtcbiAgICAgICAgXCJhY3RpdmVNb3NhaWNSdWxlXCI6IFtcIndhdGNoU3RhdGVIYW5kbGVyXCJdXG4gICAgfTsgfVxufTtcbkFyY2dpc0ltYWdlRGlzcGxheU9yZGVyLnN0eWxlID0gYXJjZ2lzSW1hZ2VEaXNwbGF5T3JkZXJDc3M7XG5cbmV4cG9ydCB7IEFyY2dpc0ltYWdlRGlzcGxheU9yZGVyIGFzIGFyY2dpc19pbWFnZV9kaXNwbGF5X29yZGVyIH07XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFyY2dpcy1pbWFnZS1kaXNwbGF5LW9yZGVyLmVudHJ5LmpzLm1hcCIsIi8qIVxuICogQWxsIG1hdGVyaWFsIGNvcHlyaWdodCBFU1JJLCBBbGwgUmlnaHRzIFJlc2VydmVkLCB1bmxlc3Mgb3RoZXJ3aXNlIHNwZWNpZmllZC5cbiAqIHY0LjAuNThcbiAqL1xuLyoqXG4gKiBDYWxsIGEgZnVuY3Rpb24gb25seSBhZnRlciBpdCBoYXMgbm90IGJlZW4gY2FsbGVkIGZvciBuIG1pbGxpc2Vjb25kc1xuICogQHBhcmFtIGZuICAgIC0gZnVuY3Rpb24gdG8gY2FsbFxuICogQHBhcmFtIGRlbGF5IC0gZGVsYXkgaW4gbWlsbGlzZWNvbmRzXG4gKi9cbmNvbnN0IGRlYm91bmNlID0gKGZuLCBkZWxheSkgPT4ge1xuICAgIGxldCB0aW1lb3V0O1xuICAgIGxldCBzdGF0dXMgPSBcImlkbGVcIjtcbiAgICBmdW5jdGlvbiBmbHVzaCguLi5hcmdzKSB7XG4gICAgICAgIHN0YXR1cyA9IFwiZmx1c2hlZFwiO1xuICAgICAgICByZXR1cm4gZGVib3VuY2VkKC4uLmFyZ3MpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpbnZva2UoLi4uYXJncykge1xuICAgICAgICBzdGF0dXMgPSBcImludm9rZWRcIjtcbiAgICAgICAgcmV0dXJuIGRlYm91bmNlZCguLi5hcmdzKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2FuY2VsKC4uLmFyZ3MpIHtcbiAgICAgICAgc3RhdHVzID0gXCJjYW5jZWxsZWRcIjtcbiAgICAgICAgcmV0dXJuIGRlYm91bmNlZCguLi5hcmdzKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0U3RhdHVzKCkge1xuICAgICAgICByZXR1cm4gc3RhdHVzO1xuICAgIH1cbiAgICBjb25zdCBkZWJvdW5jZWQgPSAoLi4uYXJncykgPT4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgc3dpdGNoIChzdGF0dXMpIHtcbiAgICAgICAgICAgIGNhc2UgXCJmbHVzaGVkXCI6XG4gICAgICAgICAgICAgICAgc3RhdHVzID0gXCJpZGxlXCI7XG4gICAgICAgICAgICAgICAgaWYgKHRpbWVvdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGZuKC4uLmFyZ3MpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUobnVsbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImludm9rZWRcIjpcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgICAgICAgICAgc3RhdHVzID0gXCJpZGxlXCI7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShmbiguLi5hcmdzKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiY2FuY2VsbGVkXCI6XG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICAgICAgICAgIHN0YXR1cyA9IFwiaWRsZVwiO1xuICAgICAgICAgICAgICAgIHJlc29sdmUobnVsbCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGlmICh0aW1lb3V0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3RhdHVzID0gXCJwZW5kaW5nXCI7XG4gICAgICAgICAgICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMgPSBcImlkbGVcIjtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUoZm4oLi4uYXJncykpO1xuICAgICAgICAgICAgICAgIH0sIGRlbGF5KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGRlYm91bmNlZC5mbHVzaCA9IGZsdXNoO1xuICAgIGRlYm91bmNlZC5pbnZva2UgPSBpbnZva2U7XG4gICAgZGVib3VuY2VkLmNhbmNlbCA9IGNhbmNlbDtcbiAgICBkZWJvdW5jZWQuZ2V0U3RhdHVzID0gZ2V0U3RhdHVzO1xuICAgIHJldHVybiBkZWJvdW5jZWQ7XG59O1xuLyoqXG4gKiBDYWxsIGEgZnVuY3Rpb24gb25seSBhZnRlciBuIG1pbGxpc2Vjb25kcyBoYXZlIGVsYXBzZWRcbiAqIEBwYXJhbSBmbiAgICAtIGZ1bmN0aW9uIHRvIGNhbGxcbiAqIEBwYXJhbSBkZWxheSAtIGRlbGF5IGluIG1pbGxpc2Vjb25kc1xuICovXG5jb25zdCB0aHJvdHRsZSA9IChmbiwgZGVsYXkpID0+IHtcbiAgICBsZXQgdGltZW91dDtcbiAgICByZXR1cm4gKC4uLmFyZ3MpID0+IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgIGlmICh0aW1lb3V0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICAgICAgdGltZW91dCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHJlc29sdmUoZm4oLi4uYXJncykpO1xuICAgICAgICB9LCBkZWxheSk7XG4gICAgfSk7XG59O1xuZnVuY3Rpb24gZXNjYXBlUmVnRXhwKHN0cikge1xuICAgIHJldHVybiBzdHIucmVwbGFjZSgvWy4qKz9eJHt9KCl8W1xcXVxcXFxdL2csIFwiXFxcXCQmXCIpOyAvLyAkJiBtZWFucyB0aGUgd2hvbGUgbWF0Y2hlZCBzdHJpbmdcbn1cbmZ1bmN0aW9uIGlzRGVmaW5lZCh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsO1xufVxuLyoqXG4gKiBTZXQgYSBtaW5pbXVtIHRpbWUgZm9yIGEgcHJvbWlzZSB0byByZXNvbHZlICh1c2VmdWwgZm9yIHByZXZlbnRpbmcgZmxhc2ggb2YgbG9hZGVycylcbiAqL1xuYXN5bmMgZnVuY3Rpb24gbWluRGVsYXkocHJvbWlzZSwgbWluRGVsYXkpIHtcbiAgICBhd2FpdCBQcm9taXNlLmFsbChbcHJvbWlzZSwgdGltZW91dChtaW5EZWxheSldKTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbn1cbi8qKlxuICogSGVscGVyIG1ldGhvZCB0byBpbmxpbmUgc2V0VGltZW91dCBhcyBhbiBhd2FpdCBpbiBhc3luYyBmdW5jdGlvbnNcbiAqL1xuZnVuY3Rpb24gdGltZW91dChtcykge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlLCBtcykpO1xufVxuY29uc3QgYXJyYXlUb0xvb2t1cE1hcCA9IChkYXRhQXJyLCBnZXRLZXlBbmRJdGVtKSA9PiBPYmplY3QuZnJvbUVudHJpZXMoKGRhdGFBcnIgfHwgW10pLm1hcCgoaXRlbSkgPT4ge1xuICAgIGNvbnN0IHsga2V5LCBkYXRhIH0gPSBnZXRLZXlBbmRJdGVtKGl0ZW0pO1xuICAgIHJldHVybiBba2V5LCBkYXRhXTtcbn0pKTtcbi8qKlxuICogQ2hlY2sgd2hldGhlciB0d28gYXJyYXlzIGhhdmUgdGhlIHNhbWUgbnVtYmVyIG9mIGVsZW1lbnRzXG4gKiBhbmQgd2hldGhlciB0aGV5IGNvbnRhaW4gdGhlIHNhbWUgZWxlbWVudHNcbiAqIHJlZ2FyZGxlc3Mgb2Ygb3JkZXJcbiAqL1xuY29uc3QgYXJyYXlzQXJlRXF1aXZhbGVudCA9IChhcnIxLCBhcnIyKSA9PiBhcnIxLmxlbmd0aCA9PT0gYXJyMi5sZW5ndGggJiYgYXJyMS5yZWR1Y2UoKG1lbW8sIHN0cikgPT4gbWVtbyAmJiBhcnIyLmluZGV4T2Yoc3RyKSA+IC0xLCB0cnVlKTtcbmZ1bmN0aW9uIHVuaXF1ZUJ5KG15QXJyLCBnZXRJdGVtSWQpIHtcbiAgICBjb25zdCByZXN1bHRBcnIgPSBbXTtcbiAgICBjb25zdCBsb29rdXBNYXAgPSB7fTtcbiAgICBteUFyci5mb3JFYWNoKChpdGVtKSA9PiB7XG4gICAgICAgIGNvbnN0IGlkID0gZ2V0SXRlbUlkKGl0ZW0pO1xuICAgICAgICBpZiAobG9va3VwTWFwW2lkXSA9PSBudWxsKSB7XG4gICAgICAgICAgICBsb29rdXBNYXBbaWRdID0gaXRlbTtcbiAgICAgICAgICAgIHJlc3VsdEFyci5wdXNoKGl0ZW0pO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdEFycjtcbn1cbmZ1bmN0aW9uIHVuaXF1ZShteUFycikge1xuICAgIGNvbnN0IHByaW1pdGl2ZXMgPSB7IGJvb2xlYW46IHt9LCBudW1iZXI6IHt9LCBzdHJpbmc6IHt9IH07XG4gICAgY29uc3Qgb2JqcyA9IFtdO1xuICAgIHJldHVybiBteUFyci5maWx0ZXIoKGl0ZW0pID0+IHtcbiAgICAgICAgbGV0IHR5cGUgPSB0eXBlb2YgaXRlbTtcbiAgICAgICAgaWYgKHR5cGUgaW4gcHJpbWl0aXZlcykge1xuICAgICAgICAgICAgcmV0dXJuIHByaW1pdGl2ZXNbdHlwZV0uaGFzT3duUHJvcGVydHkoaXRlbSkgPyBmYWxzZSA6IChwcmltaXRpdmVzW3R5cGVdW2l0ZW1dID0gdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gb2Jqcy5pbmRleE9mKGl0ZW0pID49IDAgPyBmYWxzZSA6IG9ianMucHVzaChpdGVtKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuY29uc3QgY2h1bmsgPSAoYXJyLCBzaXplKSA9PiBbLi4uQXJyYXkoTWF0aC5jZWlsKGFyci5sZW5ndGggLyBzaXplKSldLm1hcCgoXywgaSkgPT4gYXJyLnNsaWNlKHNpemUgKiBpLCBzaXplICsgc2l6ZSAqIGkpKTtcblxuZXhwb3J0IHsgYXJyYXlUb0xvb2t1cE1hcCBhcyBhLCB1bmlxdWUgYXMgYiwgdGhyb3R0bGUgYXMgYywgZGVib3VuY2UgYXMgZCwgZXNjYXBlUmVnRXhwIGFzIGUsIGFycmF5c0FyZUVxdWl2YWxlbnQgYXMgZiwgY2h1bmsgYXMgZywgaXNEZWZpbmVkIGFzIGksIG1pbkRlbGF5IGFzIG0sIHRpbWVvdXQgYXMgdCwgdW5pcXVlQnkgYXMgdSB9O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1mdW5jdGlvbmFsLTQ0ZGU4ZmNmLmpzLm1hcCIsIi8qIVxuICogQWxsIG1hdGVyaWFsIGNvcHlyaWdodCBFU1JJLCBBbGwgUmlnaHRzIFJlc2VydmVkLCB1bmxlc3Mgb3RoZXJ3aXNlIHNwZWNpZmllZC5cbiAqIHY0LjAuNThcbiAqL1xuaW1wb3J0IHsgbCBhcyBsb2FkTW9kdWxlcyB9IGZyb20gJy4vbG9hZE1vZHVsZXMtYjRhYzEyNDcuanMnO1xuaW1wb3J0IHsgYyBhcyBjbG9zZXN0RWxlbWVudENyb3NzU2hhZG93Qm91bmRhcnkgfSBmcm9tICcuL2RvbS00ZDM2NzY3Ny5qcyc7XG5cbmNvbnN0IGxhbmd1YWdlTWFwID0gbmV3IE1hcChbXG4gICAgW1wiYXJcIiwgXCJhclwiXSxcbiAgICBbXCJiZ1wiLCBcImJnXCJdLFxuICAgIFtcImJzXCIsIFwiYnNcIl0sXG4gICAgW1wiY2FcIiwgXCJjYVwiXSxcbiAgICBbXCJjc1wiLCBcImNzXCJdLFxuICAgIFtcImRhXCIsIFwiZGFcIl0sXG4gICAgW1wiZGVcIiwgXCJkZVwiXSxcbiAgICBbXCJlbFwiLCBcImVsXCJdLFxuICAgIFtcImVuXCIsIFwiZW5cIl0sXG4gICAgW1wiZXNcIiwgXCJlc1wiXSxcbiAgICBbXCJldFwiLCBcImV0XCJdLFxuICAgIFtcImZpXCIsIFwiZmlcIl0sXG4gICAgW1wiZnJcIiwgXCJmclwiXSxcbiAgICBbXCJoZVwiLCBcImhlXCJdLFxuICAgIFtcImhyXCIsIFwiaHJcIl0sXG4gICAgW1wiaHVcIiwgXCJodVwiXSxcbiAgICBbXCJpZFwiLCBcImlkXCJdLFxuICAgIFtcIml0XCIsIFwiaXRcIl0sXG4gICAgW1wiamFcIiwgXCJqYVwiXSxcbiAgICBbXCJrb1wiLCBcImtvXCJdLFxuICAgIFtcImx0XCIsIFwibHRcIl0sXG4gICAgW1wibHZcIiwgXCJsdlwiXSxcbiAgICBbXCJuYlwiLCBcIm5iXCJdLFxuICAgIFtcIm5sXCIsIFwibmxcIl0sXG4gICAgW1wicGxcIiwgXCJwbFwiXSxcbiAgICBbXCJwdC1iclwiLCBcInB0LUJSXCJdLFxuICAgIFtcInB0LXB0XCIsIFwicHQtUFRcIl0sXG4gICAgW1wicm9cIiwgXCJyb1wiXSxcbiAgICBbXCJydVwiLCBcInJ1XCJdLFxuICAgIFtcInNrXCIsIFwic2tcIl0sXG4gICAgW1wic2xcIiwgXCJzbFwiXSxcbiAgICBbXCJzclwiLCBcInNyXCJdLFxuICAgIFtcInN2XCIsIFwic3ZcIl0sXG4gICAgW1widGhcIiwgXCJ0aFwiXSxcbiAgICBbXCJ0clwiLCBcInRyXCJdLFxuICAgIFtcInVrXCIsIFwidWtcIl0sXG4gICAgW1widmlcIiwgXCJ2aVwiXSxcbiAgICBbXCJ6aC1jblwiLCBcInpoLUNOXCJdLFxuICAgIFtcInpoLWhrXCIsIFwiemgtSEtcIl0sXG4gICAgW1wiemgtdHdcIiwgXCJ6aC1UV1wiXVxuXSk7XG4vLyBydGxcbmZ1bmN0aW9uIGdldEVsZW1lbnREaXIoZWwpIHtcbiAgICByZXR1cm4gZ2V0RWxlbWVudFByb3AoZWwsIFwiZGlyXCIsIFwibHRyXCIpO1xufVxuZnVuY3Rpb24gZ2V0RWxlbWVudFByb3AoZWwsIHByb3AsIHZhbHVlKSB7XG4gICAgY29uc3QgY2xvc2VzdFdpdGhQcm9wID0gY2xvc2VzdEVsZW1lbnRDcm9zc1NoYWRvd0JvdW5kYXJ5KGVsLCBgWyR7cHJvcH1dYCk7XG4gICAgcmV0dXJuIGNsb3Nlc3RXaXRoUHJvcCA/IGNsb3Nlc3RXaXRoUHJvcC5nZXRBdHRyaWJ1dGUocHJvcCkgOiB2YWx1ZTtcbn1cbi8vIGNzc1xuY29uc3QgQ1NTX1VUSUxJVFkgPSB7XG4gICAgcnRsOiBcImFyY2dpcy0tcnRsXCJcbn07XG5hc3luYyBmdW5jdGlvbiBmb3JtYXROdW1iZXIobnVtYmVyLCBvcHRpb25zKSB7XG4gICAgY29uc3QgeyBhcGksIHR5cGUsIHBsYWNlcyB9ID0gb3B0aW9ucyB8fCB7fTtcbiAgICBpZiAoYXBpID09PSA0KSB7XG4gICAgICAgIGNvbnN0IFtpbnRsXSA9IGF3YWl0IGxvYWRNb2R1bGVzKFtcImVzcmkvaW50bFwiXSk7XG4gICAgICAgIGNvbnN0IG51bWJlckZvcm1hdEludGxPcHRpb25zID0gaW50bC5jb252ZXJ0TnVtYmVyRm9ybWF0VG9JbnRsT3B0aW9ucyh7XG4gICAgICAgICAgICBwbGFjZXMsXG4gICAgICAgICAgICBzdHlsZTogdHlwZSxcbiAgICAgICAgICAgIGRpZ2l0U2VwYXJhdG9yOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gaW50bC5mb3JtYXROdW1iZXIobnVtYmVyLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG51bWJlckZvcm1hdEludGxPcHRpb25zKSwgeyBzdHlsZTogdHlwZSB9KSk7XG4gICAgfVxuICAgIGNvbnN0IFtkb2pvTnVtYmVyXSA9IGF3YWl0IGxvYWRNb2R1bGVzKFtcImRvam8vbnVtYmVyXCJdKTtcbiAgICByZXR1cm4gZG9qb051bWJlci5mb3JtYXQobnVtYmVyLCB7XG4gICAgICAgIHR5cGUsXG4gICAgICAgIHBsYWNlcyxcbiAgICAgICAgcGF0dGVybjogb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnBhdHRlcm5cbiAgICB9KTtcbn1cbmNvbnN0IGNhY2hlID0ge307XG5mdW5jdGlvbiBmb3JtYXREYXRlKGRhdGUpIHtcbiAgICBjb25zdCBsYW5nID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50Lmxhbmc7XG4gICAgY29uc3QgZGF5U2hvcnRNb250aFllYXIgPSB7XG4gICAgICAgIHllYXI6IFwibnVtZXJpY1wiLFxuICAgICAgICBtb250aDogXCJzaG9ydFwiLFxuICAgICAgICBkYXk6IFwibnVtZXJpY1wiXG4gICAgfTtcbiAgICBpZiAoIWNhY2hlW2xhbmddKSB7XG4gICAgICAgIGNhY2hlW2xhbmddID0gbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmxhbmcsIGRheVNob3J0TW9udGhZZWFyKTtcbiAgICB9XG4gICAgcmV0dXJuIGNhY2hlW2xhbmddLmZvcm1hdChkYXRlKTtcbn1cbmZ1bmN0aW9uIGZvcm1hdFBsdXJhbChsYW5nLCBzdHJpbmdPYmosIG51bWJlcikge1xuICAgIGNvbnN0IHNpbmdsZXMgPSBbXCJpZFwiLCBcImphXCIsIFwia29cIiwgXCJ0aFwiLCBcInZpXCIsIFwiemgtY25cIiwgXCJ6aC1oa1wiLCBcInpoLXR3XCJdO1xuICAgIGNvbnN0IGxpa2VFbmdsaXNoID0gW1xuICAgICAgICBcImVuXCIsXG4gICAgICAgIFwiY2FcIixcbiAgICAgICAgXCJkYVwiLFxuICAgICAgICBcImRlXCIsXG4gICAgICAgIFwiZWxcIixcbiAgICAgICAgXCJlc1wiLFxuICAgICAgICBcImV0XCIsXG4gICAgICAgIFwiZmlcIixcbiAgICAgICAgXCJoaVwiLFxuICAgICAgICBcImh1XCIsXG4gICAgICAgIFwiaXRcIixcbiAgICAgICAgXCJuYlwiLFxuICAgICAgICBcIm5sXCIsXG4gICAgICAgIFwicHQtcHRcIixcbiAgICAgICAgXCJzdlwiLFxuICAgICAgICBcInRyXCJcbiAgICBdO1xuICAgIGNvbnN0IGxvY2FsZSA9IGxhbmcgIT09IG51bGwgJiYgbGFuZyAhPT0gdm9pZCAwID8gbGFuZyA6IFwiZW5cIjtcbiAgICAvLyBpZiB0aGUgbnVtYmVyIGlzIG9uZSwgb3IgaXQgaXMgYSBcInNpbXBsZVwiIGxhbmd1YWdlLCByZXR1cm4gdGhlIDEgc3RyaW5nXG4gICAgaWYgKG51bWJlciA9PT0gMSB8fCBzaW5nbGVzLmluY2x1ZGVzKGxvY2FsZSkpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZ09iai5zaW5nbGUucmVwbGFjZShcIiR7bnVtYmVyfVwiLCBcIjFcIik7XG4gICAgfVxuICAgIC8vIGlmIHRoZSBudW1iZXIgaXMgbm90IDEgYW5kIHRoZSBsYW5ndWFnZSB1c2VzIHRoZSBzYW1lIHBsdXJhbGl6YXRpb24gc3RyYXRlZ3kgYXMgZW5nbGlzaCxcbiAgICAvLyByZXR1cm4gdGhlIG11bHRpcGxlIHN0cmluZ1xuICAgIGlmIChudW1iZXIgIT09IDEgJiYgbGlrZUVuZ2xpc2guaW5jbHVkZXMobG9jYWxlKSkge1xuICAgICAgICByZXR1cm4gc3RyaW5nT2JqLm11bHRpcGxlLnJlcGxhY2UoXCIke251bWJlcn1cIiwgYCR7bnVtYmVyfWApO1xuICAgIH1cbiAgICAvLyBpZiBub25lIG9mIHRoZSBhYm92ZSB3b3JrZWQsIHJldHVybiB0aGUgXCJ1bmtub3duXCIgc3RyaW5nXG4gICAgcmV0dXJuIHN0cmluZ09iai51bmtub3duLnJlcGxhY2UoXCIke251bWJlcn1cIiwgYCR7bnVtYmVyfWApO1xufVxuXG5leHBvcnQgeyBDU1NfVVRJTElUWSBhcyBDLCBmb3JtYXREYXRlIGFzIGEsIGZvcm1hdFBsdXJhbCBhcyBiLCBmb3JtYXROdW1iZXIgYXMgZiwgZ2V0RWxlbWVudERpciBhcyBnLCBsYW5ndWFnZU1hcCBhcyBsIH07XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxhbmd1YWdlVXRpbC1lZjBlNTRiMi5qcy5tYXAiLCIvKiFcbiAqIEFsbCBtYXRlcmlhbCBjb3B5cmlnaHQgRVNSSSwgQWxsIFJpZ2h0cyBSZXNlcnZlZCwgdW5sZXNzIG90aGVyd2lzZSBzcGVjaWZpZWQuXG4gKiB2NC4wLjU4XG4gKi9cbmltcG9ydCB7IGMgYXMgY2xvc2VzdEVsZW1lbnRDcm9zc1NoYWRvd0JvdW5kYXJ5IH0gZnJvbSAnLi9kb20tNGQzNjc2NzcuanMnO1xuaW1wb3J0IHsgbCBhcyBsYW5ndWFnZU1hcCB9IGZyb20gJy4vbGFuZ3VhZ2VVdGlsLWVmMGU1NGIyLmpzJztcbmltcG9ydCB7IGEgYXMgZ2V0QXNzZXRQYXRoIH0gZnJvbSAnLi9pbmRleC1lM2JmN2RhNy5qcyc7XG5cbi8vIGh0dHBzOi8vbWVkaXVtLmNvbS9zdGVuY2lsLXRyaWNrcy9pbXBsZW1lbnRpbmctaW50ZXJuYXRpb25hbGlzYXRpb24taTE4bi13aXRoLXN0ZW5jaWwtNWU2NTU5NTU0MTE3XG5mdW5jdGlvbiBnZXRDb21wb25lbnRDbG9zZXN0TGFuZ3VhZ2UoZWxlbWVudCkge1xuICAgIHZhciBfYSwgX2IsIF9jO1xuICAgIGNvbnN0IGNsb3Nlc3RFbGVtZW50ID0gKF9hID0gY2xvc2VzdEVsZW1lbnRDcm9zc1NoYWRvd0JvdW5kYXJ5KGVsZW1lbnQsIFwiW2xhbmddXCIpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAoX2MgPSAoX2IgPSBlbGVtZW50LnNoYWRvd1Jvb3QpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5vd25lckRvY3VtZW50KSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuZG9jdW1lbnRFbGVtZW50O1xuICAgIC8vIGxhbmd1YWdlIHNldCBieSB0aGUgY2FsbGluZyBhcHBsaWNhdGlvbiBvciBicm93c2VyLiBkZWZhdWx0cyB0byBlbmdsaXNoLlxuICAgIGNvbnN0IGxhbmcgPSAoKGNsb3Nlc3RFbGVtZW50ID09PSBudWxsIHx8IGNsb3Nlc3RFbGVtZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjbG9zZXN0RWxlbWVudC5sYW5nKSB8fCAobmF2aWdhdG9yID09PSBudWxsIHx8IG5hdmlnYXRvciA9PT0gdm9pZCAwID8gdm9pZCAwIDogbmF2aWdhdG9yLmxhbmd1YWdlKSB8fCBcImVuXCIpLnRvTG93ZXJDYXNlKCk7XG4gICAgaWYgKGxhbmd1YWdlTWFwLmhhcyhsYW5nKSkge1xuICAgICAgICByZXR1cm4gbGFuZ3VhZ2VNYXAuZ2V0KGxhbmcpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gXCJydS1SVVwiIG1hcHMgdG8gXCJydVwiIHVzZSBjYXNlXG4gICAgICAgIGlmIChsYW5ndWFnZU1hcC5oYXMobGFuZy5zbGljZSgwLCAyKSkpIHtcbiAgICAgICAgICAgIHJldHVybiBsYW5ndWFnZU1hcC5nZXQobGFuZy5zbGljZSgwLCAyKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gXCJlblwiO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0Q29tcG9uZW50Q2xvc2VzdExhbmd1YWdlSW50bChlbGVtZW50KSB7XG4gICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgLy8gaXQncyBPSyBpZiB3ZSBkb24ndCBoYXZlIHRoZSA0IGxldHRlciBsYW5ndWFnZSBmaWxlIGZvciBpdFxuICAgIC8vIDQgbGV0dGVyIGxhbmd1YWdlIGNvZGUgbmVlZGVkIGZvciBmb3JtYXR0aW5nIG51bWJlcnNcbiAgICBjb25zdCBjbG9zZXN0RWxlbWVudCA9IChfYSA9IGNsb3Nlc3RFbGVtZW50Q3Jvc3NTaGFkb3dCb3VuZGFyeShlbGVtZW50LCBcIltsYW5nXVwiKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogKF9jID0gKF9iID0gZWxlbWVudC5zaGFkb3dSb290KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iub3duZXJEb2N1bWVudCkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmRvY3VtZW50RWxlbWVudDtcbiAgICAvLyBsYW5ndWFnZSBzZXQgYnkgdGhlIGNhbGxpbmcgYXBwbGljYXRpb24gb3IgYnJvd3Nlci4gZGVmYXVsdHMgdG8gZW5nbGlzaC5cbiAgICBjb25zdCBsYW5nID0gKChjbG9zZXN0RWxlbWVudCA9PT0gbnVsbCB8fCBjbG9zZXN0RWxlbWVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2xvc2VzdEVsZW1lbnQubGFuZykgfHwgKG5hdmlnYXRvciA9PT0gbnVsbCB8fCBuYXZpZ2F0b3IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG5hdmlnYXRvci5sYW5ndWFnZSkgfHwgXCJlblwiKS50b0xvd2VyQ2FzZSgpO1xuICAgIGlmIChsYW5ndWFnZU1hcC5oYXMobGFuZykpIHtcbiAgICAgICAgcmV0dXJuIGxhbmd1YWdlTWFwLmdldChsYW5nKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmIChsYW5ndWFnZU1hcC5oYXMobGFuZy5zbGljZSgwLCAyKSkpIHtcbiAgICAgICAgICAgIC8vIHdlIHN1cHBvcnQgdGhlIDIgbGV0dGVyIGNvZGVkIGxhbmd1YWdlXG4gICAgICAgICAgICAvLyBlLmcuIGl0LUNIIHZzIGl0XG4gICAgICAgICAgICByZXR1cm4gbGFuZztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBcImVuXCI7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBmZXRjaExvY2FsZVN0cmluZ3NGb3JDb21wb25lbnQoY29tcG9uZW50TmFtZSwgbG9jYWxlKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgZmV0Y2goZ2V0QXNzZXRQYXRoKGAuLi9hcmNnaXMtYXBwLWFzc2V0cy9pMThuLyR7Y29tcG9uZW50TmFtZX0uaTE4bi4ke2xvY2FsZX0uanNvbmApKS50aGVuKChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgIGlmIChyZXN1bHQub2spXG4gICAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQuanNvbigpKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICByZWplY3QoKTtcbiAgICAgICAgfSwgKCkgPT4gcmVqZWN0KCkpO1xuICAgIH0pO1xufVxuY29uc3Qgc3RyaW5nQ2FjaGUgPSB7fTtcbmZ1bmN0aW9uIGZldGNoTG9jYWxlU3RyaW5nc0Zyb21DYWNoZShjb21wb25lbnROYW1lLCBsb2NhbGUpIHtcbiAgICBjb25zdCBpZCA9IGAke2NvbXBvbmVudE5hbWV9JHtsb2NhbGV9YDtcbiAgICBpZiAoIXN0cmluZ0NhY2hlW2lkXSkge1xuICAgICAgICBzdHJpbmdDYWNoZVtpZF0gPSBmZXRjaExvY2FsZVN0cmluZ3NGb3JDb21wb25lbnQoY29tcG9uZW50TmFtZSwgbG9jYWxlKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0cmluZ0NhY2hlW2lkXTtcbn1cbi8qKlxuICogR2V0IHN0cmluZ3MgYW5kIGxhbmd1YWdlIGNvZGVzLlxuICogVGhpcyBtZXRob2QgcmV0dXJucyAyIGxhbmd1YWdlIGNvZGVzLlxuICogVGhlIGZpcnN0IG9uZSByZXR1cm5zIGEgY29kZSB0aGF0J3MgYWxzbyBzdXBwb3J0ZWQgYXMgYSBsYW5ndWFnZSBmaWxlLlxuICogVGhlIHNlY29uZCBvbmUgcmV0dXJucyBhIGNvZGUgd2hlcmUgdGhlcmUgaXMgc3VwcG9ydCBmb3IgdGhlIGZpcnN0IDIgbGV0dGVycyBvZiB0aGUgY29kZSBhcyBwYXJ0IG9mIGEgbGFuZ3VhZ2UgZmlsZSxcbiAqIGJ1dCB3aWxsIHJldHVybiB0aGUgb3JpZ2luYWwgNCBsZXR0ZXIgY29kZSBmcm9tIHRoZSBwYWdlLlxuICogRS5nLiBGb3IgXCJpdC1jaFwiIGl0IHdpbGwgcmV0dXJuIFwiaXRcIiBhcyB0aGUgZmlyc3QgbGFuZ3VhZ2UgY29kZSBhbmQgXCJpdC1jaFwiIGFzIHRoZSBzZWNvbmQuXG4gKiBUaGUgc2Vjb25kIG9uZSBpcyByZXF1aXJlZCBmb3IgZXNyaS5pbnRsLnNldExvY2FsZSgpIHRvIGdldCB0aGUgY29ycmVjdCBmb3JtYXR0aW5nLlxuICpcbiAqIElmIGEgdGFnTmFtZSBpcyBwcm92aWRlZCBpdCB3aWxsIG92ZXJ3aXRlIHRoZSBlbGVtZW50J3MgdGFnTmFtZVxuICpcbiAqICBAcmV0dXJuIFsgc3RyaW5ncywgZmlyc3QgbGFuZ3VhZ2UgY29kZSwgc2Vjb25kIGxhbmd1YWdlIGNvZGVdXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGdldExvY2FsZUNvbXBvbmVudFN0cmluZ3MoZWxlbWVudCwgdGFnTmFtZSkge1xuICAgIGNvbnN0IGNvbXBvbmVudE5hbWUgPSB0YWdOYW1lIHx8IGVsZW1lbnQudGFnTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIGNvbnN0IGNvbXBvbmVudExhbmd1YWdlID0gZ2V0Q29tcG9uZW50Q2xvc2VzdExhbmd1YWdlKGVsZW1lbnQpO1xuICAgIGNvbnN0IGNvbXBvbmVudExhbmd1YWdlSW50bCA9IGdldENvbXBvbmVudENsb3Nlc3RMYW5ndWFnZUludGwoZWxlbWVudCk7XG4gICAgbGV0IHN0cmluZ3M7XG4gICAgdHJ5IHtcbiAgICAgICAgc3RyaW5ncyA9IGF3YWl0IGZldGNoTG9jYWxlU3RyaW5nc0Zyb21DYWNoZShjb21wb25lbnROYW1lLCBjb21wb25lbnRMYW5ndWFnZSk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIGNvbnNvbGUud2Fybihgbm8gbG9jYWxlIGZvciAke2NvbXBvbmVudE5hbWV9ICgke2NvbXBvbmVudExhbmd1YWdlfSkgbG9hZGluZyBkZWZhdWx0IGxvY2FsZSBlbi5gKTtcbiAgICAgICAgc3RyaW5ncyA9IGF3YWl0IGZldGNoTG9jYWxlU3RyaW5nc0Zyb21DYWNoZShjb21wb25lbnROYW1lLCBcImVuXCIpO1xuICAgIH1cbiAgICByZXR1cm4gW3N0cmluZ3MsIGNvbXBvbmVudExhbmd1YWdlLCBjb21wb25lbnRMYW5ndWFnZUludGxdO1xufVxuXG5leHBvcnQgeyBnZXRDb21wb25lbnRDbG9zZXN0TGFuZ3VhZ2UgYXMgYSwgZ2V0TG9jYWxlQ29tcG9uZW50U3RyaW5ncyBhcyBnIH07XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxvY2FsZS0wNTBiNmRiOS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=