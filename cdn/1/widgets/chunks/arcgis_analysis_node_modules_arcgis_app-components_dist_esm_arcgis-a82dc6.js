"use strict";
(self["webpackChunkexb_client"] = self["webpackChunkexb_client"] || []).push([["vendors-extensions_widgets_arcgis_analysis_node_modules_arcgis_app-components_dist_esm_arcgis-a82dc6"],{

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/arcgis-raster-multidimensional-info.entry.js":
/*!**************************************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/arcgis-raster-multidimensional-info.entry.js ***!
  \**************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   arcgis_raster_multidimensional_info: () => (/* binding */ ArcgisRasterMultidimensionalInfo)
/* harmony export */ });
/* harmony import */ var _index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index-e3bf7da7.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/index-e3bf7da7.js");
/* harmony import */ var _locale_050b6db9_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./locale-050b6db9.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/locale-050b6db9.js");
/* harmony import */ var _multidimensional_69f3968f_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./multidimensional-69f3968f.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/multidimensional-69f3968f.js");
/* harmony import */ var _localStorage_9c4e7a3a_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./localStorage-9c4e7a3a.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/localStorage-9c4e7a3a.js");
/* harmony import */ var _dom_4d367677_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./dom-4d367677.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/dom-4d367677.js");
/* harmony import */ var _languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./languageUtil-ef0e54b2.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/languageUtil-ef0e54b2.js");
/* harmony import */ var _loadModules_b4ac1247_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./loadModules-b4ac1247.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/loadModules-b4ac1247.js");
/* harmony import */ var _commonFunctions_b0830e9e_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./commonFunctions-b0830e9e.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/commonFunctions-b0830e9e.js");
/* harmony import */ var _commonEnums_fcf13661_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./commonEnums-fcf13661.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/commonEnums-fcf13661.js");
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v4.0.58
 */










const arcgisRasterMultidimensionalInfoCss = ":host{display:flex;flex:1 1 auto}.info{width:100%}.info-content{height:var(--calcite-loader-size, 64px)}.default-variable{font-size:var(--calcite-font-size--2)}.notice{margin-bottom:10px}";

const ArcgisRasterMultidimensionalInfo = class {
    constructor(hostRef) {
        (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.r)(this, hostRef);
        this.keepActiveDimension = true;
        this.showFilterLength = 10;
        this.showRawSourceInfo = true;
        this.layer = undefined;
        this.open = true;
        this.showStatistics = false;
        this.useTable = true;
        this.multidimensionalInfo = undefined;
        this.selectedVariableNames = [];
    }
    watchLayer(newValue, _oldValue) {
        this.closePopover();
        this.multidimensionalInfo = null;
        this.selectedVariableNames = [];
        this.initLayer(newValue);
    }
    //--------------------------------------------------------------------------
    //
    //  Lifecycle
    //
    //--------------------------------------------------------------------------
    async componentWillLoad() {
        [this.strings] = await (0,_locale_050b6db9_js__WEBPACK_IMPORTED_MODULE_1__.g)(this.hostElement);
        this.initLayer(this.layer);
    }
    disconnectedCallback() {
        this.closePopover();
    }
    // --------------------------------------------------------------------------
    //
    //  public methods
    //
    // --------------------------------------------------------------------------
    async done() {
        this.closePopover();
    }
    // --------------------------------------------------------------------------
    //
    //  Render methods
    //
    // --------------------------------------------------------------------------
    render() {
        var _a, _b, _c;
        const { layer, multidimensionalInfo, strings } = this;
        if (!multidimensionalInfo) {
            const loading = !(layer === null || layer === void 0 ? void 0 : layer.loaded);
            return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)(_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.H, null, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-block", { class: "info", heading: strings.multidimensionalInfo.info, collapsible: true, open: !!this.open, loading: loading }, loading ? (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "info-content" }) : (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", null, strings.general.unsupported))));
        }
        const { variables } = multidimensionalInfo;
        const rasterInfo = layer.type === "imagery" ? layer.serviceRasterInfo : layer.rasterInfo;
        const defaultVariable = (_b = (_a = rasterInfo.keyProperties) === null || _a === void 0 ? void 0 : _a["DefaultVariable"]) !== null && _b !== void 0 ? _b : variables[0].name;
        const allDimensions = [];
        variables.forEach(({ dimensions }) => dimensions.forEach((dimension) => {
            if (!allDimensions.some((existingDimension) => existingDimension.name === dimension.name)) {
                allDimensions.push(dimension);
            }
        }));
        const dimensionDesc = allDimensions
            .map(({ name, values }) => {
            const dimName = name === "StdTime"
                ? strings.multidimensionalInfo.timeValues
                : name === "StdZ"
                    ? strings.multidimensionalInfo.zValues
                    : strings.multidimensionalInfo.generalValues.replace("${dimensionName}", name);
            const length = values === null || values === void 0 ? void 0 : values.length;
            return length ? `${dimName}: ${length}` : dimName;
        })
            .join("; ");
        const searchItems = variables.map(({ name, dimensions }) => ({
            name,
            dimensionNames: dimensions.map((dimensionInfo) => dimensionInfo.name)
        }));
        const selectedVariables = ((_c = this.selectedVariableNames) === null || _c === void 0 ? void 0 : _c.length)
            ? variables.filter(({ name }) => this.selectedVariableNames.includes(name))
            : variables;
        const filterBox = variables.length >= this.showFilterLength && ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-filter", { items: searchItems, messageOverrides: {
                clear: strings.general.clear,
                label: strings.multidimensionalInfo.searchVariables
            }, placeholder: strings.multidimensionalInfo.searchVariables, onCalciteFilterChange: (event) => {
                const filteredItems = event.target.filteredItems;
                this.selectedVariableNames = filteredItems.map(({ name }) => name);
            } }));
        const variableSelect = ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { ref: (el) => (this.variableEL = el) }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", null, `${strings.multidimensionalInfo.variables}: ${variables.length}; ${dimensionDesc}`), filterBox, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-list", null, selectedVariables.map((variableInfo) => this.renderVariableListItem(variableInfo, variableInfo.name === defaultVariable)))));
        const isTipNeeded = !(0,_localStorage_9c4e7a3a_js__WEBPACK_IMPORTED_MODULE_3__.g)(_localStorage_9c4e7a3a_js__WEBPACK_IMPORTED_MODULE_3__.l.ARCGIS_COMPONENT_NOTIFICATIONS, _localStorage_9c4e7a3a_js__WEBPACK_IMPORTED_MODULE_3__.a.MULTIDIMENSIONAL_INFO_TIP_DISMISSED);
        const message = isTipNeeded && ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-notice", { open: true, closable: true, icon: true, scale: "s", class: "notice", onCalciteNoticeClose: () => {
                (0,_localStorage_9c4e7a3a_js__WEBPACK_IMPORTED_MODULE_3__.s)(_localStorage_9c4e7a3a_js__WEBPACK_IMPORTED_MODULE_3__.l.ARCGIS_COMPONENT_NOTIFICATIONS, {
                    key: _localStorage_9c4e7a3a_js__WEBPACK_IMPORTED_MODULE_3__.a.MULTIDIMENSIONAL_INFO_TIP_DISMISSED,
                    value: "true"
                });
            } }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { slot: "message" }, " ", strings.multidimensionalInfo.tip)));
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)(_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.H, null, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-block", { class: "info", heading: strings.multidimensionalInfo.info, collapsible: true, open: !!this.open, onCalciteBlockToggle: (evt) => !evt.target.open && this.closePopover() }, message, variableSelect, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("slot", null))));
    }
    renderVariableListItem(variableInfo, isDefaultVariable) {
        const { name, unit, description } = variableInfo;
        const label = unit ? `${name} (${unit})` : `${name}`;
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-list-item", { label: label, description: description, key: name, onClick: () => this.renderPickListPopover(variableInfo) }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-action", { icon: "information", scale: "s", text: this.strings.general.close, slot: "actions-start", onClick: () => this.renderPickListPopover(variableInfo) }), isDefaultVariable ? ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-chip", { slot: "actions-end", value: undefined }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("span", { class: "default-variable" }, this.strings.general.default))) : null));
    }
    renderPickListPopover(variableInfo) {
        if (this.popOver) {
            this.popOver.keepActiveDimension = this.keepActiveDimension;
            this.popOver.variableInfo = variableInfo;
            this.popOver.setFocus("dismiss-button");
            return;
        }
        const popOver = document.createElement("arcgis-raster-multidimensional-variable-info");
        popOver.keepActiveDimension = this.keepActiveDimension;
        popOver.variableInfo = variableInfo;
        popOver.showStatistics = this.showStatistics;
        popOver.useTable = this.useTable;
        popOver.strings = this.strings;
        let offsetSkidding = 0;
        if (this.variableEL) {
            offsetSkidding =
                this.variableEL.getBoundingClientRect().top - this.hostElement.getBoundingClientRect().top;
        }
        popOver.popoverProps = {
            refElement: this.hostElement,
            placement: "leading-start",
            offsetDistance: 0,
            offsetSkidding,
            popoverWidth: 100
        };
        popOver.addEventListener("arcgisRasterMultidimensionalVariableInfoDismiss", (_evt) => {
            this.closePopover();
        });
        document.body.appendChild(popOver);
        popOver.componentOnReady().then(() => {
            // yield execution to DOM
            // according to Stencil doc, this is fired right after sync execution of componentDidMount, but apparently DOM rendering is not fired yet.
            // calcite-button impl depends on actual dom which in turn requires dom renderer to happen first.
            // https://github.com/Esri/calcite-components/blob/c07dd561d1e78601b3b2f92154d448c36c1c9c06/src/components/button/button.tsx#L222
            // this is probably fixable by Calcite, or turn into some sort of utility function
            requestAnimationFrame(() => popOver.setFocus("dismiss-button"));
        });
        this.popOver = popOver;
    }
    // --------------------------------------------------------------------------
    //
    //  Private methods
    //
    // --------------------------------------------------------------------------
    closePopover() {
        if (this.popOver) {
            document.body.removeChild(this.popOver);
            this.popOver = null;
        }
    }
    async initLayer(layer) {
        if (!layer) {
            return;
        }
        if (!layer.loaded) {
            await layer.load();
        }
        this.multidimensionalInfo = await (0,_multidimensional_69f3968f_js__WEBPACK_IMPORTED_MODULE_2__.a)(layer, this.showRawSourceInfo);
    }
    get hostElement() { return (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.d)(this); }
    static get watchers() { return {
        "layer": ["watchLayer"]
    }; }
};
ArcgisRasterMultidimensionalInfo.style = arcgisRasterMultidimensionalInfoCss;



//# sourceMappingURL=arcgis-raster-multidimensional-info.entry.js.map

/***/ }),

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/localStorage-9c4e7a3a.js":
/*!******************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/localStorage-9c4e7a3a.js ***!
  \******************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   a: () => (/* binding */ arcgisComponentNotificationsKeys),
/* harmony export */   g: () => (/* binding */ getSingleObjectLocalStorage),
/* harmony export */   l: () => (/* binding */ localStorageKeys),
/* harmony export */   s: () => (/* binding */ setSingleObjectLocalStorage)
/* harmony export */ });
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v4.0.58
 */
var localStorageKeys;
(function (localStorageKeys) {
    localStorageKeys["ARCGIS_COMPONENT_NOTIFICATIONS"] = "arcgisComponent_notifications";
})(localStorageKeys || (localStorageKeys = {}));
var arcgisComponentNotificationsKeys;
(function (arcgisComponentNotificationsKeys) {
    arcgisComponentNotificationsKeys["FEATURE_REDUCTION_WARNING_DISMISSED"] = "arcgis_feature_reduction_warning_dismissed";
    arcgisComponentNotificationsKeys["POPUP_WARNING_DISMISSED"] = "arcgis_popup_warning_dismissed";
    arcgisComponentNotificationsKeys["INCOMPATIBLE_VECTOR_SYMBOLS_DISMISSED"] = "arcgis_symbol_styler_incompatible_vector_symbols_dismissed";
    arcgisComponentNotificationsKeys["EFFECTS_TIP_DISMISSED"] = "arcgis_effects_tip_dismissed";
    arcgisComponentNotificationsKeys["LAYER_VIEW_DEFINITION_DISMISSED"] = "arcgis_layer_view_definition_dismissed";
    arcgisComponentNotificationsKeys["LAYER_OVERRIDE_STATUS_TIP_DISMISSED"] = "arcgis_layer_override_status_tip_dismissed";
    arcgisComponentNotificationsKeys["SMART_MAPPING_TIP1_DISMISSED"] = "arcgis_smart_mapping_tip1_dismissed";
    arcgisComponentNotificationsKeys["SMART_MAPPING_TIP2_DISMISSED"] = "arcgis_smart_mapping_tip2_dismissed";
    arcgisComponentNotificationsKeys["LAYER_VIEW_JOIN_TIP_DISMISSED"] = "arcgis_layer_view_join_tip_dismissed";
    arcgisComponentNotificationsKeys["MULTIDIMENSIONAL_INFO_TIP_DISMISSED"] = "arcgis_multidimensional_info_tip_dismissed";
})(arcgisComponentNotificationsKeys || (arcgisComponentNotificationsKeys = {}));
const getLocalStorage = (localStorageKey) => {
    return localStorage.getItem(localStorageKey);
};
const setLocalStorage = (localStorageKey, value) => {
    localStorage.setItem(localStorageKey, value);
};
const getObjectLocalStorage = (localStorageKey) => {
    return JSON.parse(getLocalStorage(localStorageKey)) || {};
};
const setSingleObjectLocalStorage = (localStorageKey, keyValueObject) => {
    const setLocalStorageVal = getObjectLocalStorage(localStorageKey);
    setLocalStorageVal[keyValueObject.key] = keyValueObject.value;
    setLocalStorage(localStorageKey, JSON.stringify(setLocalStorageVal));
};
const getSingleObjectLocalStorage = (localStorageKey, objectKey) => {
    const getLocalStorageVal = getObjectLocalStorage(localStorageKey);
    if (getLocalStorageVal === null || getLocalStorageVal === void 0 ? void 0 : getLocalStorageVal.hasOwnProperty(objectKey)) {
        return getLocalStorageVal[objectKey];
    }
    else {
        return null;
    }
};



//# sourceMappingURL=localStorage-9c4e7a3a.js.map

/***/ }),

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/locale-050b6db9.js":
/*!************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/locale-050b6db9.js ***!
  \************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   a: () => (/* binding */ getComponentClosestLanguage),
/* harmony export */   g: () => (/* binding */ getLocaleComponentStrings)
/* harmony export */ });
/* harmony import */ var _dom_4d367677_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dom-4d367677.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/dom-4d367677.js");
/* harmony import */ var _languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./languageUtil-ef0e54b2.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/languageUtil-ef0e54b2.js");
/* harmony import */ var _index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./index-e3bf7da7.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/index-e3bf7da7.js");
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v4.0.58
 */




// https://medium.com/stencil-tricks/implementing-internationalisation-i18n-with-stencil-5e6559554117
function getComponentClosestLanguage(element) {
    var _a, _b, _c;
    const closestElement = (_a = (0,_dom_4d367677_js__WEBPACK_IMPORTED_MODULE_0__.c)(element, "[lang]")) !== null && _a !== void 0 ? _a : (_c = (_b = element.shadowRoot) === null || _b === void 0 ? void 0 : _b.ownerDocument) === null || _c === void 0 ? void 0 : _c.documentElement;
    // language set by the calling application or browser. defaults to english.
    const lang = ((closestElement === null || closestElement === void 0 ? void 0 : closestElement.lang) || (navigator === null || navigator === void 0 ? void 0 : navigator.language) || "en").toLowerCase();
    if (_languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_1__.l.has(lang)) {
        return _languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_1__.l.get(lang);
    }
    else {
        // "ru-RU" maps to "ru" use case
        if (_languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_1__.l.has(lang.slice(0, 2))) {
            return _languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_1__.l.get(lang.slice(0, 2));
        }
        else {
            return "en";
        }
    }
}
function getComponentClosestLanguageIntl(element) {
    var _a, _b, _c;
    // it's OK if we don't have the 4 letter language file for it
    // 4 letter language code needed for formatting numbers
    const closestElement = (_a = (0,_dom_4d367677_js__WEBPACK_IMPORTED_MODULE_0__.c)(element, "[lang]")) !== null && _a !== void 0 ? _a : (_c = (_b = element.shadowRoot) === null || _b === void 0 ? void 0 : _b.ownerDocument) === null || _c === void 0 ? void 0 : _c.documentElement;
    // language set by the calling application or browser. defaults to english.
    const lang = ((closestElement === null || closestElement === void 0 ? void 0 : closestElement.lang) || (navigator === null || navigator === void 0 ? void 0 : navigator.language) || "en").toLowerCase();
    if (_languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_1__.l.has(lang)) {
        return _languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_1__.l.get(lang);
    }
    else {
        if (_languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_1__.l.has(lang.slice(0, 2))) {
            // we support the 2 letter coded language
            // e.g. it-CH vs it
            return lang;
        }
        else {
            return "en";
        }
    }
}
function fetchLocaleStringsForComponent(componentName, locale) {
    return new Promise((resolve, reject) => {
        fetch((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_2__.a)(`../arcgis-app-assets/i18n/${componentName}.i18n.${locale}.json`)).then((result) => {
            if (result.ok)
                resolve(result.json());
            else
                reject();
        }, () => reject());
    });
}
const stringCache = {};
function fetchLocaleStringsFromCache(componentName, locale) {
    const id = `${componentName}${locale}`;
    if (!stringCache[id]) {
        stringCache[id] = fetchLocaleStringsForComponent(componentName, locale);
    }
    return stringCache[id];
}
/**
 * Get strings and language codes.
 * This method returns 2 language codes.
 * The first one returns a code that's also supported as a language file.
 * The second one returns a code where there is support for the first 2 letters of the code as part of a language file,
 * but will return the original 4 letter code from the page.
 * E.g. For "it-ch" it will return "it" as the first language code and "it-ch" as the second.
 * The second one is required for esri.intl.setLocale() to get the correct formatting.
 *
 * If a tagName is provided it will overwite the element's tagName
 *
 *  @return [ strings, first language code, second language code]
 */
async function getLocaleComponentStrings(element, tagName) {
    const componentName = tagName || element.tagName.toLowerCase();
    const componentLanguage = getComponentClosestLanguage(element);
    const componentLanguageIntl = getComponentClosestLanguageIntl(element);
    let strings;
    try {
        strings = await fetchLocaleStringsFromCache(componentName, componentLanguage);
    }
    catch (e) {
        console.warn(`no locale for ${componentName} (${componentLanguage}) loading default locale en.`);
        strings = await fetchLocaleStringsFromCache(componentName, "en");
    }
    return [strings, componentLanguage, componentLanguageIntl];
}



//# sourceMappingURL=locale-050b6db9.js.map

/***/ }),

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/multidimensional-69f3968f.js":
/*!**********************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/multidimensional-69f3968f.js ***!
  \**********************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   a: () => (/* binding */ getMultidimensionalInfo),
/* harmony export */   b: () => (/* binding */ getDefaultDimensionSliceValue),
/* harmony export */   c: () => (/* binding */ getMultidimensionalDefinition),
/* harmony export */   f: () => (/* binding */ formatDimensionValue),
/* harmony export */   g: () => (/* binding */ getClippedDimensionInfo),
/* harmony export */   i: () => (/* binding */ isTimeDimension),
/* harmony export */   m: () => (/* binding */ minVersionRFTMultidimensionalInfo),
/* harmony export */   u: () => (/* binding */ updateDimensionalDefinition)
/* harmony export */ });
/* harmony import */ var _commonFunctions_b0830e9e_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./commonFunctions-b0830e9e.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/commonFunctions-b0830e9e.js");
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v4.0.58
 */


const minVersionRFTMultidimensionalInfo = 10.9;
function formatTime(value, options) {
    const date = new Date(value);
    const { useFriendlyISOFormat, intl, format } = options;
    if (useFriendlyISOFormat && intl) {
        return intl.formatDate(date, Object.assign(Object.assign({}, intl.convertDateFormatToIntlOptions(format !== null && format !== void 0 ? format : "short-date-long-time")), { timeZone: "UTC" }));
    }
    let isoTimeString = new Date(value).toISOString();
    isoTimeString = isoTimeString.slice(0, isoTimeString.indexOf(".")) + "Z";
    return isoTimeString;
}
function formatMonth(value_base1, intl, format = "long") {
    // using an arbitrary date (the day the code was written) to avoid side effects of setMonth near the end of the month
    // setMonth will move the date to the next month when new month doesn't have current date (e.g. 9/31, 2/30)
    // date = new Date(2002, 9, 31); date.setMonth(8); console.log(date.toLocaleDateString())
    const date = new Date(2022, 9, 10);
    date.setMonth(value_base1 - 1);
    return intl.formatDate(date, { month: format });
}
function formatQuarter(value_base1, intl) {
    const startMonth = formatMonth((value_base1 - 1) * 3 + 1, intl, "short");
    const endMonth = formatMonth(value_base1 * 3, intl, "short");
    return `${startMonth} - ${endMonth}`;
}
function formatDimensionValue(value, dimensionInfo, options = {}) {
    var _a, _b, _c, _d;
    if (value == null) {
        return "";
    }
    const { intl, useRecurringTimeLabel } = options;
    if (useRecurringTimeLabel && intl && !Array.isArray(value)) {
        const intervalUnit = (_a = dimensionInfo.intervalUnit) === null || _a === void 0 ? void 0 : _a.toLowerCase().trim();
        // weekly and daily are not supported yet
        const canUseRecurringTimeLabel = isRecurringTimeDimension(dimensionInfo) && (intervalUnit === "months" || intervalUnit === "quarters");
        if (canUseRecurringTimeLabel) {
            return intervalUnit === "months" ? formatMonth(value, intl) : formatQuarter(value, intl);
        }
    }
    // this is prefered when labeling a slider alike control
    const lastElement = (_b = dimensionInfo.values) === null || _b === void 0 ? void 0 : _b[dimensionInfo.values.length - 1];
    if (options.useStartOrEndForRangedValue && Array.isArray(value) && value.length === 2 && Array.isArray(lastElement)) {
        const isLastElement = value.join("-") === lastElement.join("-");
        value = isLastElement ? value[1] : value[0];
    }
    const isTime = isTimeDimension(dimensionInfo);
    if (!isTime) {
        return Array.isArray(value)
            ? value.map((element) => { var _a; return (_a = intl === null || intl === void 0 ? void 0 : intl.formatNumber(element)) !== null && _a !== void 0 ? _a : String(element); }).join(" - ")
            : (_c = intl === null || intl === void 0 ? void 0 : intl.formatNumber(value)) !== null && _c !== void 0 ? _c : String(value);
    }
    if (options.useFriendlyISOFormat && !options.format) {
        let resolution = (_d = dimensionInfo.intervalUnit) === null || _d === void 0 ? void 0 : _d.toLowerCase().trim();
        let { interval, extent } = dimensionInfo;
        if (resolution === "months") {
            if (interval > 11) {
                resolution = "year";
            }
        }
        else if (resolution === "days") {
            if (interval > 364) {
                resolution = "year";
            }
            else if (interval > 27) {
                resolution = "months";
            }
        }
        else if (resolution === "hours") {
            resolution = "days";
        }
        if (!["years", "months", "days"].includes(resolution) && (extent === null || extent === void 0 ? void 0 : extent.length)) {
            const interval = (extent[1] - extent[0]) / dimensionInfo.values.length;
            const day = 86400000;
            if (interval >= 365 * day) {
                resolution = "years";
            }
            else if (interval >= 28 * day) {
                resolution = "months";
            }
        }
        const format = resolution === "years" ? "year" : resolution === "months" ? "short-month-year" : "short-date";
        options = Object.assign({ format }, options);
    }
    return Array.isArray(value)
        ? value.map((element) => formatTime(element, options)).join(" - ")
        : formatTime(value, options);
}
function getClippedDimensionInfo(dimensionInfo, multidimensionalSubset) {
    var _a;
    const constraint = (_a = multidimensionalSubset === null || multidimensionalSubset === void 0 ? void 0 : multidimensionalSubset.dimensions) === null || _a === void 0 ? void 0 : _a.find(({ name }) => name === dimensionInfo.name);
    if (!(constraint === null || constraint === void 0 ? void 0 : constraint.extent)) {
        return dimensionInfo;
    }
    const extent = [...constraint.extent];
    const values = dimensionInfo.values.filter((value) => {
        // must be contained, intersection is not sufficient
        if (Array.isArray(value)) {
            if (!(0,_commonFunctions_b0830e9e_js__WEBPACK_IMPORTED_MODULE_0__.i)(extent[1]) || extent[0] === extent[1]) {
                return value[0] === extent[0];
            }
            return value[0] >= extent[0] && value[0] <= extent[1] && value[1] >= extent[0] && value[1] <= extent[1];
        }
        return value >= extent[0] && value <= extent[1];
    });
    // this is a special case, when last slice of a ranged dimension series is used
    if (values.length === 0) {
        const lastValue = dimensionInfo.values[dimensionInfo.values.length - 1];
        if (Array.isArray(lastValue) && lastValue[1] === extent[0]) {
            values.push(lastValue);
        }
    }
    return Object.assign(Object.assign({}, dimensionInfo), { extent, values });
}
function getDefaultDimensionSliceValue(dimensionInfo) {
    var _a;
    const { values, extent, name } = dimensionInfo;
    let value = (_a = values === null || values === void 0 ? void 0 : values[0]) !== null && _a !== void 0 ? _a : extent[0];
    if (name.toLowerCase() === "stdz" &&
        !dimensionInfo.hasRanges &&
        Math.abs(extent[1]) <= Math.abs(extent[0])) {
        if (values === null || values === void 0 ? void 0 : values.length) {
            value = values[values.length - 1];
        }
        else {
            value = extent[1];
        }
    }
    return value;
}
function getMultidimensionalDefinition(layer) {
    var _a, _b;
    return layer.type === "imagery-tile"
        ? layer.multidimensionalDefinition
        : (_b = ((_a = layer.mosaicRule) !== null && _a !== void 0 ? _a : layer._defaultServiceMosaicRule)) === null || _b === void 0 ? void 0 : _b.multidimensionalDefinition;
}
async function getMultidimensionalInfo(layer, useRawSourceInfo) {
    var _a, _b;
    if (layer.type === "imagery-tile") {
        return layer.rasterInfo.multidimensionalInfo;
    }
    const { rasterFunction, version } = layer;
    if (useRawSourceInfo ||
        version <= minVersionRFTMultidimensionalInfo ||
        !rasterFunction ||
        ((_a = rasterFunction.functionName) === null || _a === void 0 ? void 0 : _a.toLowerCase()) === "none") {
        return layer.serviceRasterInfo.multidimensionalInfo;
    }
    const rasterInfo = (_b = (await layer.generateRasterInfo(layer.rasterFunction))) !== null && _b !== void 0 ? _b : layer.serviceRasterInfo;
    return rasterInfo.multidimensionalInfo;
}
function isTimeDimension(dimensionInfo, ignoreRecuring = false) {
    return dimensionInfo.name === "StdTime" && (ignoreRecuring || !dimensionInfo.recurring);
}
function isRecurringTimeDimension(dimensionInfo) {
    return dimensionInfo.name === "StdTime" && !!dimensionInfo.recurring;
}
function updateDimensionalDefinition(def, dimensionInfo, activeMultidimensionalSubset) {
    dimensionInfo = getClippedDimensionInfo(dimensionInfo, activeMultidimensionalSubset);
    const originalFormattedValue = formatDimensionValue(def.values[0], dimensionInfo);
    const hasOriginalFormattedValue = dimensionInfo.values.some((val) => originalFormattedValue === formatDimensionValue(val, dimensionInfo));
    if (!hasOriginalFormattedValue) {
        // get default slice value when def.values is invalid
        const value = getDefaultDimensionSliceValue(dimensionInfo);
        def.values = [value];
    }
}



//# sourceMappingURL=multidimensional-69f3968f.js.map

/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid2lkZ2V0cy9jaHVua3MvYXJjZ2lzX2FuYWx5c2lzX25vZGVfbW9kdWxlc19hcmNnaXNfYXBwLWNvbXBvbmVudHNfZGlzdF9lc21fYXJjZ2lzLWE4MmRjNi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDMkY7QUFDckI7QUFDUTtBQUNnRztBQUNuSjtBQUNTO0FBQ0Q7QUFDSTtBQUNKOztBQUVuQyxtREFBbUQsYUFBYSxjQUFjLE1BQU0sV0FBVyxjQUFjLHdDQUF3QyxrQkFBa0Isc0NBQXNDLFFBQVEsbUJBQW1COztBQUV4TztBQUNBO0FBQ0EsUUFBUSxxREFBZ0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0Isc0RBQXlCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsdUNBQXVDO0FBQ3ZEO0FBQ0E7QUFDQSxvQkFBb0IscURBQUMsQ0FBQyxpREFBSSxRQUFRLHFEQUFDLG9CQUFvQixtSEFBbUgsWUFBWSxxREFBQyxVQUFVLHVCQUF1QixJQUFJLHFEQUFDO0FBQzdOO0FBQ0EsZ0JBQWdCLFlBQVk7QUFDNUI7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLFlBQVk7QUFDekM7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0Esb0JBQW9CLGNBQWM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RUFBNEUsY0FBYztBQUMxRjtBQUNBLCtCQUErQixRQUFRLElBQUksT0FBTztBQUNsRCxTQUFTO0FBQ1QscUJBQXFCO0FBQ3JCLDZDQUE2QyxrQkFBa0I7QUFDL0Q7QUFDQTtBQUNB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QWlCLCtEQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsb0JBQW9CLGdCQUFnQjtBQUM3RTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHVCQUF1QjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDBCQUEwQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFeVE7O0FBRXpRIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZXhiLWNsaWVudC8uL2V4dGVuc2lvbnMvd2lkZ2V0cy9hcmNnaXMvYW5hbHlzaXMvbm9kZV9tb2R1bGVzL0BhcmNnaXMvYXBwLWNvbXBvbmVudHMvZGlzdC9lc20vYXJjZ2lzLXJhc3Rlci1tdWx0aWRpbWVuc2lvbmFsLWluZm8uZW50cnkuanMiLCJ3ZWJwYWNrOi8vZXhiLWNsaWVudC8uL2V4dGVuc2lvbnMvd2lkZ2V0cy9hcmNnaXMvYW5hbHlzaXMvbm9kZV9tb2R1bGVzL0BhcmNnaXMvYXBwLWNvbXBvbmVudHMvZGlzdC9lc20vbG9jYWxTdG9yYWdlLTljNGU3YTNhLmpzIiwid2VicGFjazovL2V4Yi1jbGllbnQvLi9leHRlbnNpb25zL3dpZGdldHMvYXJjZ2lzL2FuYWx5c2lzL25vZGVfbW9kdWxlcy9AYXJjZ2lzL2FwcC1jb21wb25lbnRzL2Rpc3QvZXNtL2xvY2FsZS0wNTBiNmRiOS5qcyIsIndlYnBhY2s6Ly9leGItY2xpZW50Ly4vZXh0ZW5zaW9ucy93aWRnZXRzL2FyY2dpcy9hbmFseXNpcy9ub2RlX21vZHVsZXMvQGFyY2dpcy9hcHAtY29tcG9uZW50cy9kaXN0L2VzbS9tdWx0aWRpbWVuc2lvbmFsLTY5ZjM5NjhmLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogQWxsIG1hdGVyaWFsIGNvcHlyaWdodCBFU1JJLCBBbGwgUmlnaHRzIFJlc2VydmVkLCB1bmxlc3Mgb3RoZXJ3aXNlIHNwZWNpZmllZC5cbiAqIHY0LjAuNThcbiAqL1xuaW1wb3J0IHsgciBhcyByZWdpc3Rlckluc3RhbmNlLCBoLCBIIGFzIEhvc3QsIGQgYXMgZ2V0RWxlbWVudCB9IGZyb20gJy4vaW5kZXgtZTNiZjdkYTcuanMnO1xuaW1wb3J0IHsgZyBhcyBnZXRMb2NhbGVDb21wb25lbnRTdHJpbmdzIH0gZnJvbSAnLi9sb2NhbGUtMDUwYjZkYjkuanMnO1xuaW1wb3J0IHsgYSBhcyBnZXRNdWx0aWRpbWVuc2lvbmFsSW5mbyB9IGZyb20gJy4vbXVsdGlkaW1lbnNpb25hbC02OWYzOTY4Zi5qcyc7XG5pbXBvcnQgeyBnIGFzIGdldFNpbmdsZU9iamVjdExvY2FsU3RvcmFnZSwgcyBhcyBzZXRTaW5nbGVPYmplY3RMb2NhbFN0b3JhZ2UsIGEgYXMgYXJjZ2lzQ29tcG9uZW50Tm90aWZpY2F0aW9uc0tleXMsIGwgYXMgbG9jYWxTdG9yYWdlS2V5cyB9IGZyb20gJy4vbG9jYWxTdG9yYWdlLTljNGU3YTNhLmpzJztcbmltcG9ydCAnLi9kb20tNGQzNjc2NzcuanMnO1xuaW1wb3J0ICcuL2xhbmd1YWdlVXRpbC1lZjBlNTRiMi5qcyc7XG5pbXBvcnQgJy4vbG9hZE1vZHVsZXMtYjRhYzEyNDcuanMnO1xuaW1wb3J0ICcuL2NvbW1vbkZ1bmN0aW9ucy1iMDgzMGU5ZS5qcyc7XG5pbXBvcnQgJy4vY29tbW9uRW51bXMtZmNmMTM2NjEuanMnO1xuXG5jb25zdCBhcmNnaXNSYXN0ZXJNdWx0aWRpbWVuc2lvbmFsSW5mb0NzcyA9IFwiOmhvc3R7ZGlzcGxheTpmbGV4O2ZsZXg6MSAxIGF1dG99LmluZm97d2lkdGg6MTAwJX0uaW5mby1jb250ZW50e2hlaWdodDp2YXIoLS1jYWxjaXRlLWxvYWRlci1zaXplLCA2NHB4KX0uZGVmYXVsdC12YXJpYWJsZXtmb250LXNpemU6dmFyKC0tY2FsY2l0ZS1mb250LXNpemUtLTIpfS5ub3RpY2V7bWFyZ2luLWJvdHRvbToxMHB4fVwiO1xuXG5jb25zdCBBcmNnaXNSYXN0ZXJNdWx0aWRpbWVuc2lvbmFsSW5mbyA9IGNsYXNzIHtcbiAgICBjb25zdHJ1Y3Rvcihob3N0UmVmKSB7XG4gICAgICAgIHJlZ2lzdGVySW5zdGFuY2UodGhpcywgaG9zdFJlZik7XG4gICAgICAgIHRoaXMua2VlcEFjdGl2ZURpbWVuc2lvbiA9IHRydWU7XG4gICAgICAgIHRoaXMuc2hvd0ZpbHRlckxlbmd0aCA9IDEwO1xuICAgICAgICB0aGlzLnNob3dSYXdTb3VyY2VJbmZvID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5sYXllciA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5vcGVuID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5zaG93U3RhdGlzdGljcyA9IGZhbHNlO1xuICAgICAgICB0aGlzLnVzZVRhYmxlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5tdWx0aWRpbWVuc2lvbmFsSW5mbyA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5zZWxlY3RlZFZhcmlhYmxlTmFtZXMgPSBbXTtcbiAgICB9XG4gICAgd2F0Y2hMYXllcihuZXdWYWx1ZSwgX29sZFZhbHVlKSB7XG4gICAgICAgIHRoaXMuY2xvc2VQb3BvdmVyKCk7XG4gICAgICAgIHRoaXMubXVsdGlkaW1lbnNpb25hbEluZm8gPSBudWxsO1xuICAgICAgICB0aGlzLnNlbGVjdGVkVmFyaWFibGVOYW1lcyA9IFtdO1xuICAgICAgICB0aGlzLmluaXRMYXllcihuZXdWYWx1ZSk7XG4gICAgfVxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvL1xuICAgIC8vICBMaWZlY3ljbGVcbiAgICAvL1xuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBhc3luYyBjb21wb25lbnRXaWxsTG9hZCgpIHtcbiAgICAgICAgW3RoaXMuc3RyaW5nc10gPSBhd2FpdCBnZXRMb2NhbGVDb21wb25lbnRTdHJpbmdzKHRoaXMuaG9zdEVsZW1lbnQpO1xuICAgICAgICB0aGlzLmluaXRMYXllcih0aGlzLmxheWVyKTtcbiAgICB9XG4gICAgZGlzY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgICAgIHRoaXMuY2xvc2VQb3BvdmVyKCk7XG4gICAgfVxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy9cbiAgICAvLyAgcHVibGljIG1ldGhvZHNcbiAgICAvL1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgYXN5bmMgZG9uZSgpIHtcbiAgICAgICAgdGhpcy5jbG9zZVBvcG92ZXIoKTtcbiAgICB9XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvL1xuICAgIC8vICBSZW5kZXIgbWV0aG9kc1xuICAgIC8vXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICBjb25zdCB7IGxheWVyLCBtdWx0aWRpbWVuc2lvbmFsSW5mbywgc3RyaW5ncyB9ID0gdGhpcztcbiAgICAgICAgaWYgKCFtdWx0aWRpbWVuc2lvbmFsSW5mbykge1xuICAgICAgICAgICAgY29uc3QgbG9hZGluZyA9ICEobGF5ZXIgPT09IG51bGwgfHwgbGF5ZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGxheWVyLmxvYWRlZCk7XG4gICAgICAgICAgICByZXR1cm4gKGgoSG9zdCwgbnVsbCwgaChcImNhbGNpdGUtYmxvY2tcIiwgeyBjbGFzczogXCJpbmZvXCIsIGhlYWRpbmc6IHN0cmluZ3MubXVsdGlkaW1lbnNpb25hbEluZm8uaW5mbywgY29sbGFwc2libGU6IHRydWUsIG9wZW46ICEhdGhpcy5vcGVuLCBsb2FkaW5nOiBsb2FkaW5nIH0sIGxvYWRpbmcgPyBoKFwiZGl2XCIsIHsgY2xhc3M6IFwiaW5mby1jb250ZW50XCIgfSkgOiBoKFwiZGl2XCIsIG51bGwsIHN0cmluZ3MuZ2VuZXJhbC51bnN1cHBvcnRlZCkpKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyB2YXJpYWJsZXMgfSA9IG11bHRpZGltZW5zaW9uYWxJbmZvO1xuICAgICAgICBjb25zdCByYXN0ZXJJbmZvID0gbGF5ZXIudHlwZSA9PT0gXCJpbWFnZXJ5XCIgPyBsYXllci5zZXJ2aWNlUmFzdGVySW5mbyA6IGxheWVyLnJhc3RlckluZm87XG4gICAgICAgIGNvbnN0IGRlZmF1bHRWYXJpYWJsZSA9IChfYiA9IChfYSA9IHJhc3RlckluZm8ua2V5UHJvcGVydGllcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hW1wiRGVmYXVsdFZhcmlhYmxlXCJdKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiB2YXJpYWJsZXNbMF0ubmFtZTtcbiAgICAgICAgY29uc3QgYWxsRGltZW5zaW9ucyA9IFtdO1xuICAgICAgICB2YXJpYWJsZXMuZm9yRWFjaCgoeyBkaW1lbnNpb25zIH0pID0+IGRpbWVuc2lvbnMuZm9yRWFjaCgoZGltZW5zaW9uKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWFsbERpbWVuc2lvbnMuc29tZSgoZXhpc3RpbmdEaW1lbnNpb24pID0+IGV4aXN0aW5nRGltZW5zaW9uLm5hbWUgPT09IGRpbWVuc2lvbi5uYW1lKSkge1xuICAgICAgICAgICAgICAgIGFsbERpbWVuc2lvbnMucHVzaChkaW1lbnNpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSk7XG4gICAgICAgIGNvbnN0IGRpbWVuc2lvbkRlc2MgPSBhbGxEaW1lbnNpb25zXG4gICAgICAgICAgICAubWFwKCh7IG5hbWUsIHZhbHVlcyB9KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBkaW1OYW1lID0gbmFtZSA9PT0gXCJTdGRUaW1lXCJcbiAgICAgICAgICAgICAgICA/IHN0cmluZ3MubXVsdGlkaW1lbnNpb25hbEluZm8udGltZVZhbHVlc1xuICAgICAgICAgICAgICAgIDogbmFtZSA9PT0gXCJTdGRaXCJcbiAgICAgICAgICAgICAgICAgICAgPyBzdHJpbmdzLm11bHRpZGltZW5zaW9uYWxJbmZvLnpWYWx1ZXNcbiAgICAgICAgICAgICAgICAgICAgOiBzdHJpbmdzLm11bHRpZGltZW5zaW9uYWxJbmZvLmdlbmVyYWxWYWx1ZXMucmVwbGFjZShcIiR7ZGltZW5zaW9uTmFtZX1cIiwgbmFtZSk7XG4gICAgICAgICAgICBjb25zdCBsZW5ndGggPSB2YWx1ZXMgPT09IG51bGwgfHwgdmFsdWVzID09PSB2b2lkIDAgPyB2b2lkIDAgOiB2YWx1ZXMubGVuZ3RoO1xuICAgICAgICAgICAgcmV0dXJuIGxlbmd0aCA/IGAke2RpbU5hbWV9OiAke2xlbmd0aH1gIDogZGltTmFtZTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5qb2luKFwiOyBcIik7XG4gICAgICAgIGNvbnN0IHNlYXJjaEl0ZW1zID0gdmFyaWFibGVzLm1hcCgoeyBuYW1lLCBkaW1lbnNpb25zIH0pID0+ICh7XG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgZGltZW5zaW9uTmFtZXM6IGRpbWVuc2lvbnMubWFwKChkaW1lbnNpb25JbmZvKSA9PiBkaW1lbnNpb25JbmZvLm5hbWUpXG4gICAgICAgIH0pKTtcbiAgICAgICAgY29uc3Qgc2VsZWN0ZWRWYXJpYWJsZXMgPSAoKF9jID0gdGhpcy5zZWxlY3RlZFZhcmlhYmxlTmFtZXMpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5sZW5ndGgpXG4gICAgICAgICAgICA/IHZhcmlhYmxlcy5maWx0ZXIoKHsgbmFtZSB9KSA9PiB0aGlzLnNlbGVjdGVkVmFyaWFibGVOYW1lcy5pbmNsdWRlcyhuYW1lKSlcbiAgICAgICAgICAgIDogdmFyaWFibGVzO1xuICAgICAgICBjb25zdCBmaWx0ZXJCb3ggPSB2YXJpYWJsZXMubGVuZ3RoID49IHRoaXMuc2hvd0ZpbHRlckxlbmd0aCAmJiAoaChcImNhbGNpdGUtZmlsdGVyXCIsIHsgaXRlbXM6IHNlYXJjaEl0ZW1zLCBtZXNzYWdlT3ZlcnJpZGVzOiB7XG4gICAgICAgICAgICAgICAgY2xlYXI6IHN0cmluZ3MuZ2VuZXJhbC5jbGVhcixcbiAgICAgICAgICAgICAgICBsYWJlbDogc3RyaW5ncy5tdWx0aWRpbWVuc2lvbmFsSW5mby5zZWFyY2hWYXJpYWJsZXNcbiAgICAgICAgICAgIH0sIHBsYWNlaG9sZGVyOiBzdHJpbmdzLm11bHRpZGltZW5zaW9uYWxJbmZvLnNlYXJjaFZhcmlhYmxlcywgb25DYWxjaXRlRmlsdGVyQ2hhbmdlOiAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBmaWx0ZXJlZEl0ZW1zID0gZXZlbnQudGFyZ2V0LmZpbHRlcmVkSXRlbXM7XG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RlZFZhcmlhYmxlTmFtZXMgPSBmaWx0ZXJlZEl0ZW1zLm1hcCgoeyBuYW1lIH0pID0+IG5hbWUpO1xuICAgICAgICAgICAgfSB9KSk7XG4gICAgICAgIGNvbnN0IHZhcmlhYmxlU2VsZWN0ID0gKGgoXCJkaXZcIiwgeyByZWY6IChlbCkgPT4gKHRoaXMudmFyaWFibGVFTCA9IGVsKSB9LCBoKFwiY2FsY2l0ZS1sYWJlbFwiLCBudWxsLCBgJHtzdHJpbmdzLm11bHRpZGltZW5zaW9uYWxJbmZvLnZhcmlhYmxlc306ICR7dmFyaWFibGVzLmxlbmd0aH07ICR7ZGltZW5zaW9uRGVzY31gKSwgZmlsdGVyQm94LCBoKFwiY2FsY2l0ZS1saXN0XCIsIG51bGwsIHNlbGVjdGVkVmFyaWFibGVzLm1hcCgodmFyaWFibGVJbmZvKSA9PiB0aGlzLnJlbmRlclZhcmlhYmxlTGlzdEl0ZW0odmFyaWFibGVJbmZvLCB2YXJpYWJsZUluZm8ubmFtZSA9PT0gZGVmYXVsdFZhcmlhYmxlKSkpKSk7XG4gICAgICAgIGNvbnN0IGlzVGlwTmVlZGVkID0gIWdldFNpbmdsZU9iamVjdExvY2FsU3RvcmFnZShsb2NhbFN0b3JhZ2VLZXlzLkFSQ0dJU19DT01QT05FTlRfTk9USUZJQ0FUSU9OUywgYXJjZ2lzQ29tcG9uZW50Tm90aWZpY2F0aW9uc0tleXMuTVVMVElESU1FTlNJT05BTF9JTkZPX1RJUF9ESVNNSVNTRUQpO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gaXNUaXBOZWVkZWQgJiYgKGgoXCJjYWxjaXRlLW5vdGljZVwiLCB7IG9wZW46IHRydWUsIGNsb3NhYmxlOiB0cnVlLCBpY29uOiB0cnVlLCBzY2FsZTogXCJzXCIsIGNsYXNzOiBcIm5vdGljZVwiLCBvbkNhbGNpdGVOb3RpY2VDbG9zZTogKCkgPT4ge1xuICAgICAgICAgICAgICAgIHNldFNpbmdsZU9iamVjdExvY2FsU3RvcmFnZShsb2NhbFN0b3JhZ2VLZXlzLkFSQ0dJU19DT01QT05FTlRfTk9USUZJQ0FUSU9OUywge1xuICAgICAgICAgICAgICAgICAgICBrZXk6IGFyY2dpc0NvbXBvbmVudE5vdGlmaWNhdGlvbnNLZXlzLk1VTFRJRElNRU5TSU9OQUxfSU5GT19USVBfRElTTUlTU0VELFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogXCJ0cnVlXCJcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gfSwgaChcImRpdlwiLCB7IHNsb3Q6IFwibWVzc2FnZVwiIH0sIFwiIFwiLCBzdHJpbmdzLm11bHRpZGltZW5zaW9uYWxJbmZvLnRpcCkpKTtcbiAgICAgICAgcmV0dXJuIChoKEhvc3QsIG51bGwsIGgoXCJjYWxjaXRlLWJsb2NrXCIsIHsgY2xhc3M6IFwiaW5mb1wiLCBoZWFkaW5nOiBzdHJpbmdzLm11bHRpZGltZW5zaW9uYWxJbmZvLmluZm8sIGNvbGxhcHNpYmxlOiB0cnVlLCBvcGVuOiAhIXRoaXMub3Blbiwgb25DYWxjaXRlQmxvY2tUb2dnbGU6IChldnQpID0+ICFldnQudGFyZ2V0Lm9wZW4gJiYgdGhpcy5jbG9zZVBvcG92ZXIoKSB9LCBtZXNzYWdlLCB2YXJpYWJsZVNlbGVjdCwgaChcInNsb3RcIiwgbnVsbCkpKSk7XG4gICAgfVxuICAgIHJlbmRlclZhcmlhYmxlTGlzdEl0ZW0odmFyaWFibGVJbmZvLCBpc0RlZmF1bHRWYXJpYWJsZSkge1xuICAgICAgICBjb25zdCB7IG5hbWUsIHVuaXQsIGRlc2NyaXB0aW9uIH0gPSB2YXJpYWJsZUluZm87XG4gICAgICAgIGNvbnN0IGxhYmVsID0gdW5pdCA/IGAke25hbWV9ICgke3VuaXR9KWAgOiBgJHtuYW1lfWA7XG4gICAgICAgIHJldHVybiAoaChcImNhbGNpdGUtbGlzdC1pdGVtXCIsIHsgbGFiZWw6IGxhYmVsLCBkZXNjcmlwdGlvbjogZGVzY3JpcHRpb24sIGtleTogbmFtZSwgb25DbGljazogKCkgPT4gdGhpcy5yZW5kZXJQaWNrTGlzdFBvcG92ZXIodmFyaWFibGVJbmZvKSB9LCBoKFwiY2FsY2l0ZS1hY3Rpb25cIiwgeyBpY29uOiBcImluZm9ybWF0aW9uXCIsIHNjYWxlOiBcInNcIiwgdGV4dDogdGhpcy5zdHJpbmdzLmdlbmVyYWwuY2xvc2UsIHNsb3Q6IFwiYWN0aW9ucy1zdGFydFwiLCBvbkNsaWNrOiAoKSA9PiB0aGlzLnJlbmRlclBpY2tMaXN0UG9wb3Zlcih2YXJpYWJsZUluZm8pIH0pLCBpc0RlZmF1bHRWYXJpYWJsZSA/IChoKFwiY2FsY2l0ZS1jaGlwXCIsIHsgc2xvdDogXCJhY3Rpb25zLWVuZFwiLCB2YWx1ZTogdW5kZWZpbmVkIH0sIGgoXCJzcGFuXCIsIHsgY2xhc3M6IFwiZGVmYXVsdC12YXJpYWJsZVwiIH0sIHRoaXMuc3RyaW5ncy5nZW5lcmFsLmRlZmF1bHQpKSkgOiBudWxsKSk7XG4gICAgfVxuICAgIHJlbmRlclBpY2tMaXN0UG9wb3Zlcih2YXJpYWJsZUluZm8pIHtcbiAgICAgICAgaWYgKHRoaXMucG9wT3Zlcikge1xuICAgICAgICAgICAgdGhpcy5wb3BPdmVyLmtlZXBBY3RpdmVEaW1lbnNpb24gPSB0aGlzLmtlZXBBY3RpdmVEaW1lbnNpb247XG4gICAgICAgICAgICB0aGlzLnBvcE92ZXIudmFyaWFibGVJbmZvID0gdmFyaWFibGVJbmZvO1xuICAgICAgICAgICAgdGhpcy5wb3BPdmVyLnNldEZvY3VzKFwiZGlzbWlzcy1idXR0b25cIik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcG9wT3ZlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJhcmNnaXMtcmFzdGVyLW11bHRpZGltZW5zaW9uYWwtdmFyaWFibGUtaW5mb1wiKTtcbiAgICAgICAgcG9wT3Zlci5rZWVwQWN0aXZlRGltZW5zaW9uID0gdGhpcy5rZWVwQWN0aXZlRGltZW5zaW9uO1xuICAgICAgICBwb3BPdmVyLnZhcmlhYmxlSW5mbyA9IHZhcmlhYmxlSW5mbztcbiAgICAgICAgcG9wT3Zlci5zaG93U3RhdGlzdGljcyA9IHRoaXMuc2hvd1N0YXRpc3RpY3M7XG4gICAgICAgIHBvcE92ZXIudXNlVGFibGUgPSB0aGlzLnVzZVRhYmxlO1xuICAgICAgICBwb3BPdmVyLnN0cmluZ3MgPSB0aGlzLnN0cmluZ3M7XG4gICAgICAgIGxldCBvZmZzZXRTa2lkZGluZyA9IDA7XG4gICAgICAgIGlmICh0aGlzLnZhcmlhYmxlRUwpIHtcbiAgICAgICAgICAgIG9mZnNldFNraWRkaW5nID1cbiAgICAgICAgICAgICAgICB0aGlzLnZhcmlhYmxlRUwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wIC0gdGhpcy5ob3N0RWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3A7XG4gICAgICAgIH1cbiAgICAgICAgcG9wT3Zlci5wb3BvdmVyUHJvcHMgPSB7XG4gICAgICAgICAgICByZWZFbGVtZW50OiB0aGlzLmhvc3RFbGVtZW50LFxuICAgICAgICAgICAgcGxhY2VtZW50OiBcImxlYWRpbmctc3RhcnRcIixcbiAgICAgICAgICAgIG9mZnNldERpc3RhbmNlOiAwLFxuICAgICAgICAgICAgb2Zmc2V0U2tpZGRpbmcsXG4gICAgICAgICAgICBwb3BvdmVyV2lkdGg6IDEwMFxuICAgICAgICB9O1xuICAgICAgICBwb3BPdmVyLmFkZEV2ZW50TGlzdGVuZXIoXCJhcmNnaXNSYXN0ZXJNdWx0aWRpbWVuc2lvbmFsVmFyaWFibGVJbmZvRGlzbWlzc1wiLCAoX2V2dCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5jbG9zZVBvcG92ZXIoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQocG9wT3Zlcik7XG4gICAgICAgIHBvcE92ZXIuY29tcG9uZW50T25SZWFkeSgpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgLy8geWllbGQgZXhlY3V0aW9uIHRvIERPTVxuICAgICAgICAgICAgLy8gYWNjb3JkaW5nIHRvIFN0ZW5jaWwgZG9jLCB0aGlzIGlzIGZpcmVkIHJpZ2h0IGFmdGVyIHN5bmMgZXhlY3V0aW9uIG9mIGNvbXBvbmVudERpZE1vdW50LCBidXQgYXBwYXJlbnRseSBET00gcmVuZGVyaW5nIGlzIG5vdCBmaXJlZCB5ZXQuXG4gICAgICAgICAgICAvLyBjYWxjaXRlLWJ1dHRvbiBpbXBsIGRlcGVuZHMgb24gYWN0dWFsIGRvbSB3aGljaCBpbiB0dXJuIHJlcXVpcmVzIGRvbSByZW5kZXJlciB0byBoYXBwZW4gZmlyc3QuXG4gICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vRXNyaS9jYWxjaXRlLWNvbXBvbmVudHMvYmxvYi9jMDdkZDU2MWQxZTc4NjAxYjNiMmY5MjE1NGQ0NDhjMzZjMWM5YzA2L3NyYy9jb21wb25lbnRzL2J1dHRvbi9idXR0b24udHN4I0wyMjJcbiAgICAgICAgICAgIC8vIHRoaXMgaXMgcHJvYmFibHkgZml4YWJsZSBieSBDYWxjaXRlLCBvciB0dXJuIGludG8gc29tZSBzb3J0IG9mIHV0aWxpdHkgZnVuY3Rpb25cbiAgICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiBwb3BPdmVyLnNldEZvY3VzKFwiZGlzbWlzcy1idXR0b25cIikpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5wb3BPdmVyID0gcG9wT3ZlcjtcbiAgICB9XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvL1xuICAgIC8vICBQcml2YXRlIG1ldGhvZHNcbiAgICAvL1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgY2xvc2VQb3BvdmVyKCkge1xuICAgICAgICBpZiAodGhpcy5wb3BPdmVyKSB7XG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKHRoaXMucG9wT3Zlcik7XG4gICAgICAgICAgICB0aGlzLnBvcE92ZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGluaXRMYXllcihsYXllcikge1xuICAgICAgICBpZiAoIWxheWVyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFsYXllci5sb2FkZWQpIHtcbiAgICAgICAgICAgIGF3YWl0IGxheWVyLmxvYWQoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm11bHRpZGltZW5zaW9uYWxJbmZvID0gYXdhaXQgZ2V0TXVsdGlkaW1lbnNpb25hbEluZm8obGF5ZXIsIHRoaXMuc2hvd1Jhd1NvdXJjZUluZm8pO1xuICAgIH1cbiAgICBnZXQgaG9zdEVsZW1lbnQoKSB7IHJldHVybiBnZXRFbGVtZW50KHRoaXMpOyB9XG4gICAgc3RhdGljIGdldCB3YXRjaGVycygpIHsgcmV0dXJuIHtcbiAgICAgICAgXCJsYXllclwiOiBbXCJ3YXRjaExheWVyXCJdXG4gICAgfTsgfVxufTtcbkFyY2dpc1Jhc3Rlck11bHRpZGltZW5zaW9uYWxJbmZvLnN0eWxlID0gYXJjZ2lzUmFzdGVyTXVsdGlkaW1lbnNpb25hbEluZm9Dc3M7XG5cbmV4cG9ydCB7IEFyY2dpc1Jhc3Rlck11bHRpZGltZW5zaW9uYWxJbmZvIGFzIGFyY2dpc19yYXN0ZXJfbXVsdGlkaW1lbnNpb25hbF9pbmZvIH07XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFyY2dpcy1yYXN0ZXItbXVsdGlkaW1lbnNpb25hbC1pbmZvLmVudHJ5LmpzLm1hcCIsIi8qIVxuICogQWxsIG1hdGVyaWFsIGNvcHlyaWdodCBFU1JJLCBBbGwgUmlnaHRzIFJlc2VydmVkLCB1bmxlc3Mgb3RoZXJ3aXNlIHNwZWNpZmllZC5cbiAqIHY0LjAuNThcbiAqL1xudmFyIGxvY2FsU3RvcmFnZUtleXM7XG4oZnVuY3Rpb24gKGxvY2FsU3RvcmFnZUtleXMpIHtcbiAgICBsb2NhbFN0b3JhZ2VLZXlzW1wiQVJDR0lTX0NPTVBPTkVOVF9OT1RJRklDQVRJT05TXCJdID0gXCJhcmNnaXNDb21wb25lbnRfbm90aWZpY2F0aW9uc1wiO1xufSkobG9jYWxTdG9yYWdlS2V5cyB8fCAobG9jYWxTdG9yYWdlS2V5cyA9IHt9KSk7XG52YXIgYXJjZ2lzQ29tcG9uZW50Tm90aWZpY2F0aW9uc0tleXM7XG4oZnVuY3Rpb24gKGFyY2dpc0NvbXBvbmVudE5vdGlmaWNhdGlvbnNLZXlzKSB7XG4gICAgYXJjZ2lzQ29tcG9uZW50Tm90aWZpY2F0aW9uc0tleXNbXCJGRUFUVVJFX1JFRFVDVElPTl9XQVJOSU5HX0RJU01JU1NFRFwiXSA9IFwiYXJjZ2lzX2ZlYXR1cmVfcmVkdWN0aW9uX3dhcm5pbmdfZGlzbWlzc2VkXCI7XG4gICAgYXJjZ2lzQ29tcG9uZW50Tm90aWZpY2F0aW9uc0tleXNbXCJQT1BVUF9XQVJOSU5HX0RJU01JU1NFRFwiXSA9IFwiYXJjZ2lzX3BvcHVwX3dhcm5pbmdfZGlzbWlzc2VkXCI7XG4gICAgYXJjZ2lzQ29tcG9uZW50Tm90aWZpY2F0aW9uc0tleXNbXCJJTkNPTVBBVElCTEVfVkVDVE9SX1NZTUJPTFNfRElTTUlTU0VEXCJdID0gXCJhcmNnaXNfc3ltYm9sX3N0eWxlcl9pbmNvbXBhdGlibGVfdmVjdG9yX3N5bWJvbHNfZGlzbWlzc2VkXCI7XG4gICAgYXJjZ2lzQ29tcG9uZW50Tm90aWZpY2F0aW9uc0tleXNbXCJFRkZFQ1RTX1RJUF9ESVNNSVNTRURcIl0gPSBcImFyY2dpc19lZmZlY3RzX3RpcF9kaXNtaXNzZWRcIjtcbiAgICBhcmNnaXNDb21wb25lbnROb3RpZmljYXRpb25zS2V5c1tcIkxBWUVSX1ZJRVdfREVGSU5JVElPTl9ESVNNSVNTRURcIl0gPSBcImFyY2dpc19sYXllcl92aWV3X2RlZmluaXRpb25fZGlzbWlzc2VkXCI7XG4gICAgYXJjZ2lzQ29tcG9uZW50Tm90aWZpY2F0aW9uc0tleXNbXCJMQVlFUl9PVkVSUklERV9TVEFUVVNfVElQX0RJU01JU1NFRFwiXSA9IFwiYXJjZ2lzX2xheWVyX292ZXJyaWRlX3N0YXR1c190aXBfZGlzbWlzc2VkXCI7XG4gICAgYXJjZ2lzQ29tcG9uZW50Tm90aWZpY2F0aW9uc0tleXNbXCJTTUFSVF9NQVBQSU5HX1RJUDFfRElTTUlTU0VEXCJdID0gXCJhcmNnaXNfc21hcnRfbWFwcGluZ190aXAxX2Rpc21pc3NlZFwiO1xuICAgIGFyY2dpc0NvbXBvbmVudE5vdGlmaWNhdGlvbnNLZXlzW1wiU01BUlRfTUFQUElOR19USVAyX0RJU01JU1NFRFwiXSA9IFwiYXJjZ2lzX3NtYXJ0X21hcHBpbmdfdGlwMl9kaXNtaXNzZWRcIjtcbiAgICBhcmNnaXNDb21wb25lbnROb3RpZmljYXRpb25zS2V5c1tcIkxBWUVSX1ZJRVdfSk9JTl9USVBfRElTTUlTU0VEXCJdID0gXCJhcmNnaXNfbGF5ZXJfdmlld19qb2luX3RpcF9kaXNtaXNzZWRcIjtcbiAgICBhcmNnaXNDb21wb25lbnROb3RpZmljYXRpb25zS2V5c1tcIk1VTFRJRElNRU5TSU9OQUxfSU5GT19USVBfRElTTUlTU0VEXCJdID0gXCJhcmNnaXNfbXVsdGlkaW1lbnNpb25hbF9pbmZvX3RpcF9kaXNtaXNzZWRcIjtcbn0pKGFyY2dpc0NvbXBvbmVudE5vdGlmaWNhdGlvbnNLZXlzIHx8IChhcmNnaXNDb21wb25lbnROb3RpZmljYXRpb25zS2V5cyA9IHt9KSk7XG5jb25zdCBnZXRMb2NhbFN0b3JhZ2UgPSAobG9jYWxTdG9yYWdlS2V5KSA9PiB7XG4gICAgcmV0dXJuIGxvY2FsU3RvcmFnZS5nZXRJdGVtKGxvY2FsU3RvcmFnZUtleSk7XG59O1xuY29uc3Qgc2V0TG9jYWxTdG9yYWdlID0gKGxvY2FsU3RvcmFnZUtleSwgdmFsdWUpID0+IHtcbiAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShsb2NhbFN0b3JhZ2VLZXksIHZhbHVlKTtcbn07XG5jb25zdCBnZXRPYmplY3RMb2NhbFN0b3JhZ2UgPSAobG9jYWxTdG9yYWdlS2V5KSA9PiB7XG4gICAgcmV0dXJuIEpTT04ucGFyc2UoZ2V0TG9jYWxTdG9yYWdlKGxvY2FsU3RvcmFnZUtleSkpIHx8IHt9O1xufTtcbmNvbnN0IHNldFNpbmdsZU9iamVjdExvY2FsU3RvcmFnZSA9IChsb2NhbFN0b3JhZ2VLZXksIGtleVZhbHVlT2JqZWN0KSA9PiB7XG4gICAgY29uc3Qgc2V0TG9jYWxTdG9yYWdlVmFsID0gZ2V0T2JqZWN0TG9jYWxTdG9yYWdlKGxvY2FsU3RvcmFnZUtleSk7XG4gICAgc2V0TG9jYWxTdG9yYWdlVmFsW2tleVZhbHVlT2JqZWN0LmtleV0gPSBrZXlWYWx1ZU9iamVjdC52YWx1ZTtcbiAgICBzZXRMb2NhbFN0b3JhZ2UobG9jYWxTdG9yYWdlS2V5LCBKU09OLnN0cmluZ2lmeShzZXRMb2NhbFN0b3JhZ2VWYWwpKTtcbn07XG5jb25zdCBnZXRTaW5nbGVPYmplY3RMb2NhbFN0b3JhZ2UgPSAobG9jYWxTdG9yYWdlS2V5LCBvYmplY3RLZXkpID0+IHtcbiAgICBjb25zdCBnZXRMb2NhbFN0b3JhZ2VWYWwgPSBnZXRPYmplY3RMb2NhbFN0b3JhZ2UobG9jYWxTdG9yYWdlS2V5KTtcbiAgICBpZiAoZ2V0TG9jYWxTdG9yYWdlVmFsID09PSBudWxsIHx8IGdldExvY2FsU3RvcmFnZVZhbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogZ2V0TG9jYWxTdG9yYWdlVmFsLmhhc093blByb3BlcnR5KG9iamVjdEtleSkpIHtcbiAgICAgICAgcmV0dXJuIGdldExvY2FsU3RvcmFnZVZhbFtvYmplY3RLZXldO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufTtcblxuZXhwb3J0IHsgYXJjZ2lzQ29tcG9uZW50Tm90aWZpY2F0aW9uc0tleXMgYXMgYSwgZ2V0U2luZ2xlT2JqZWN0TG9jYWxTdG9yYWdlIGFzIGcsIGxvY2FsU3RvcmFnZUtleXMgYXMgbCwgc2V0U2luZ2xlT2JqZWN0TG9jYWxTdG9yYWdlIGFzIHMgfTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bG9jYWxTdG9yYWdlLTljNGU3YTNhLmpzLm1hcCIsIi8qIVxuICogQWxsIG1hdGVyaWFsIGNvcHlyaWdodCBFU1JJLCBBbGwgUmlnaHRzIFJlc2VydmVkLCB1bmxlc3Mgb3RoZXJ3aXNlIHNwZWNpZmllZC5cbiAqIHY0LjAuNThcbiAqL1xuaW1wb3J0IHsgYyBhcyBjbG9zZXN0RWxlbWVudENyb3NzU2hhZG93Qm91bmRhcnkgfSBmcm9tICcuL2RvbS00ZDM2NzY3Ny5qcyc7XG5pbXBvcnQgeyBsIGFzIGxhbmd1YWdlTWFwIH0gZnJvbSAnLi9sYW5ndWFnZVV0aWwtZWYwZTU0YjIuanMnO1xuaW1wb3J0IHsgYSBhcyBnZXRBc3NldFBhdGggfSBmcm9tICcuL2luZGV4LWUzYmY3ZGE3LmpzJztcblxuLy8gaHR0cHM6Ly9tZWRpdW0uY29tL3N0ZW5jaWwtdHJpY2tzL2ltcGxlbWVudGluZy1pbnRlcm5hdGlvbmFsaXNhdGlvbi1pMThuLXdpdGgtc3RlbmNpbC01ZTY1NTk1NTQxMTdcbmZ1bmN0aW9uIGdldENvbXBvbmVudENsb3Nlc3RMYW5ndWFnZShlbGVtZW50KSB7XG4gICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgY29uc3QgY2xvc2VzdEVsZW1lbnQgPSAoX2EgPSBjbG9zZXN0RWxlbWVudENyb3NzU2hhZG93Qm91bmRhcnkoZWxlbWVudCwgXCJbbGFuZ11cIikpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IChfYyA9IChfYiA9IGVsZW1lbnQuc2hhZG93Um9vdCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLm93bmVyRG9jdW1lbnQpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5kb2N1bWVudEVsZW1lbnQ7XG4gICAgLy8gbGFuZ3VhZ2Ugc2V0IGJ5IHRoZSBjYWxsaW5nIGFwcGxpY2F0aW9uIG9yIGJyb3dzZXIuIGRlZmF1bHRzIHRvIGVuZ2xpc2guXG4gICAgY29uc3QgbGFuZyA9ICgoY2xvc2VzdEVsZW1lbnQgPT09IG51bGwgfHwgY2xvc2VzdEVsZW1lbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNsb3Nlc3RFbGVtZW50LmxhbmcpIHx8IChuYXZpZ2F0b3IgPT09IG51bGwgfHwgbmF2aWdhdG9yID09PSB2b2lkIDAgPyB2b2lkIDAgOiBuYXZpZ2F0b3IubGFuZ3VhZ2UpIHx8IFwiZW5cIikudG9Mb3dlckNhc2UoKTtcbiAgICBpZiAobGFuZ3VhZ2VNYXAuaGFzKGxhbmcpKSB7XG4gICAgICAgIHJldHVybiBsYW5ndWFnZU1hcC5nZXQobGFuZyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBcInJ1LVJVXCIgbWFwcyB0byBcInJ1XCIgdXNlIGNhc2VcbiAgICAgICAgaWYgKGxhbmd1YWdlTWFwLmhhcyhsYW5nLnNsaWNlKDAsIDIpKSkge1xuICAgICAgICAgICAgcmV0dXJuIGxhbmd1YWdlTWFwLmdldChsYW5nLnNsaWNlKDAsIDIpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBcImVuXCI7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBnZXRDb21wb25lbnRDbG9zZXN0TGFuZ3VhZ2VJbnRsKGVsZW1lbnQpIHtcbiAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAvLyBpdCdzIE9LIGlmIHdlIGRvbid0IGhhdmUgdGhlIDQgbGV0dGVyIGxhbmd1YWdlIGZpbGUgZm9yIGl0XG4gICAgLy8gNCBsZXR0ZXIgbGFuZ3VhZ2UgY29kZSBuZWVkZWQgZm9yIGZvcm1hdHRpbmcgbnVtYmVyc1xuICAgIGNvbnN0IGNsb3Nlc3RFbGVtZW50ID0gKF9hID0gY2xvc2VzdEVsZW1lbnRDcm9zc1NoYWRvd0JvdW5kYXJ5KGVsZW1lbnQsIFwiW2xhbmddXCIpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAoX2MgPSAoX2IgPSBlbGVtZW50LnNoYWRvd1Jvb3QpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5vd25lckRvY3VtZW50KSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuZG9jdW1lbnRFbGVtZW50O1xuICAgIC8vIGxhbmd1YWdlIHNldCBieSB0aGUgY2FsbGluZyBhcHBsaWNhdGlvbiBvciBicm93c2VyLiBkZWZhdWx0cyB0byBlbmdsaXNoLlxuICAgIGNvbnN0IGxhbmcgPSAoKGNsb3Nlc3RFbGVtZW50ID09PSBudWxsIHx8IGNsb3Nlc3RFbGVtZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjbG9zZXN0RWxlbWVudC5sYW5nKSB8fCAobmF2aWdhdG9yID09PSBudWxsIHx8IG5hdmlnYXRvciA9PT0gdm9pZCAwID8gdm9pZCAwIDogbmF2aWdhdG9yLmxhbmd1YWdlKSB8fCBcImVuXCIpLnRvTG93ZXJDYXNlKCk7XG4gICAgaWYgKGxhbmd1YWdlTWFwLmhhcyhsYW5nKSkge1xuICAgICAgICByZXR1cm4gbGFuZ3VhZ2VNYXAuZ2V0KGxhbmcpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKGxhbmd1YWdlTWFwLmhhcyhsYW5nLnNsaWNlKDAsIDIpKSkge1xuICAgICAgICAgICAgLy8gd2Ugc3VwcG9ydCB0aGUgMiBsZXR0ZXIgY29kZWQgbGFuZ3VhZ2VcbiAgICAgICAgICAgIC8vIGUuZy4gaXQtQ0ggdnMgaXRcbiAgICAgICAgICAgIHJldHVybiBsYW5nO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFwiZW5cIjtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGZldGNoTG9jYWxlU3RyaW5nc0ZvckNvbXBvbmVudChjb21wb25lbnROYW1lLCBsb2NhbGUpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBmZXRjaChnZXRBc3NldFBhdGgoYC4uL2FyY2dpcy1hcHAtYXNzZXRzL2kxOG4vJHtjb21wb25lbnROYW1lfS5pMThuLiR7bG9jYWxlfS5qc29uYCkpLnRoZW4oKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgaWYgKHJlc3VsdC5vaylcbiAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdC5qc29uKCkpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHJlamVjdCgpO1xuICAgICAgICB9LCAoKSA9PiByZWplY3QoKSk7XG4gICAgfSk7XG59XG5jb25zdCBzdHJpbmdDYWNoZSA9IHt9O1xuZnVuY3Rpb24gZmV0Y2hMb2NhbGVTdHJpbmdzRnJvbUNhY2hlKGNvbXBvbmVudE5hbWUsIGxvY2FsZSkge1xuICAgIGNvbnN0IGlkID0gYCR7Y29tcG9uZW50TmFtZX0ke2xvY2FsZX1gO1xuICAgIGlmICghc3RyaW5nQ2FjaGVbaWRdKSB7XG4gICAgICAgIHN0cmluZ0NhY2hlW2lkXSA9IGZldGNoTG9jYWxlU3RyaW5nc0ZvckNvbXBvbmVudChjb21wb25lbnROYW1lLCBsb2NhbGUpO1xuICAgIH1cbiAgICByZXR1cm4gc3RyaW5nQ2FjaGVbaWRdO1xufVxuLyoqXG4gKiBHZXQgc3RyaW5ncyBhbmQgbGFuZ3VhZ2UgY29kZXMuXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIDIgbGFuZ3VhZ2UgY29kZXMuXG4gKiBUaGUgZmlyc3Qgb25lIHJldHVybnMgYSBjb2RlIHRoYXQncyBhbHNvIHN1cHBvcnRlZCBhcyBhIGxhbmd1YWdlIGZpbGUuXG4gKiBUaGUgc2Vjb25kIG9uZSByZXR1cm5zIGEgY29kZSB3aGVyZSB0aGVyZSBpcyBzdXBwb3J0IGZvciB0aGUgZmlyc3QgMiBsZXR0ZXJzIG9mIHRoZSBjb2RlIGFzIHBhcnQgb2YgYSBsYW5ndWFnZSBmaWxlLFxuICogYnV0IHdpbGwgcmV0dXJuIHRoZSBvcmlnaW5hbCA0IGxldHRlciBjb2RlIGZyb20gdGhlIHBhZ2UuXG4gKiBFLmcuIEZvciBcIml0LWNoXCIgaXQgd2lsbCByZXR1cm4gXCJpdFwiIGFzIHRoZSBmaXJzdCBsYW5ndWFnZSBjb2RlIGFuZCBcIml0LWNoXCIgYXMgdGhlIHNlY29uZC5cbiAqIFRoZSBzZWNvbmQgb25lIGlzIHJlcXVpcmVkIGZvciBlc3JpLmludGwuc2V0TG9jYWxlKCkgdG8gZ2V0IHRoZSBjb3JyZWN0IGZvcm1hdHRpbmcuXG4gKlxuICogSWYgYSB0YWdOYW1lIGlzIHByb3ZpZGVkIGl0IHdpbGwgb3ZlcndpdGUgdGhlIGVsZW1lbnQncyB0YWdOYW1lXG4gKlxuICogIEByZXR1cm4gWyBzdHJpbmdzLCBmaXJzdCBsYW5ndWFnZSBjb2RlLCBzZWNvbmQgbGFuZ3VhZ2UgY29kZV1cbiAqL1xuYXN5bmMgZnVuY3Rpb24gZ2V0TG9jYWxlQ29tcG9uZW50U3RyaW5ncyhlbGVtZW50LCB0YWdOYW1lKSB7XG4gICAgY29uc3QgY29tcG9uZW50TmFtZSA9IHRhZ05hbWUgfHwgZWxlbWVudC50YWdOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgY29uc3QgY29tcG9uZW50TGFuZ3VhZ2UgPSBnZXRDb21wb25lbnRDbG9zZXN0TGFuZ3VhZ2UoZWxlbWVudCk7XG4gICAgY29uc3QgY29tcG9uZW50TGFuZ3VhZ2VJbnRsID0gZ2V0Q29tcG9uZW50Q2xvc2VzdExhbmd1YWdlSW50bChlbGVtZW50KTtcbiAgICBsZXQgc3RyaW5ncztcbiAgICB0cnkge1xuICAgICAgICBzdHJpbmdzID0gYXdhaXQgZmV0Y2hMb2NhbGVTdHJpbmdzRnJvbUNhY2hlKGNvbXBvbmVudE5hbWUsIGNvbXBvbmVudExhbmd1YWdlKTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgY29uc29sZS53YXJuKGBubyBsb2NhbGUgZm9yICR7Y29tcG9uZW50TmFtZX0gKCR7Y29tcG9uZW50TGFuZ3VhZ2V9KSBsb2FkaW5nIGRlZmF1bHQgbG9jYWxlIGVuLmApO1xuICAgICAgICBzdHJpbmdzID0gYXdhaXQgZmV0Y2hMb2NhbGVTdHJpbmdzRnJvbUNhY2hlKGNvbXBvbmVudE5hbWUsIFwiZW5cIik7XG4gICAgfVxuICAgIHJldHVybiBbc3RyaW5ncywgY29tcG9uZW50TGFuZ3VhZ2UsIGNvbXBvbmVudExhbmd1YWdlSW50bF07XG59XG5cbmV4cG9ydCB7IGdldENvbXBvbmVudENsb3Nlc3RMYW5ndWFnZSBhcyBhLCBnZXRMb2NhbGVDb21wb25lbnRTdHJpbmdzIGFzIGcgfTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bG9jYWxlLTA1MGI2ZGI5LmpzLm1hcCIsIi8qIVxuICogQWxsIG1hdGVyaWFsIGNvcHlyaWdodCBFU1JJLCBBbGwgUmlnaHRzIFJlc2VydmVkLCB1bmxlc3Mgb3RoZXJ3aXNlIHNwZWNpZmllZC5cbiAqIHY0LjAuNThcbiAqL1xuaW1wb3J0IHsgaSBhcyBpc0RlZmluZWQgfSBmcm9tICcuL2NvbW1vbkZ1bmN0aW9ucy1iMDgzMGU5ZS5qcyc7XG5cbmNvbnN0IG1pblZlcnNpb25SRlRNdWx0aWRpbWVuc2lvbmFsSW5mbyA9IDEwLjk7XG5mdW5jdGlvbiBmb3JtYXRUaW1lKHZhbHVlLCBvcHRpb25zKSB7XG4gICAgY29uc3QgZGF0ZSA9IG5ldyBEYXRlKHZhbHVlKTtcbiAgICBjb25zdCB7IHVzZUZyaWVuZGx5SVNPRm9ybWF0LCBpbnRsLCBmb3JtYXQgfSA9IG9wdGlvbnM7XG4gICAgaWYgKHVzZUZyaWVuZGx5SVNPRm9ybWF0ICYmIGludGwpIHtcbiAgICAgICAgcmV0dXJuIGludGwuZm9ybWF0RGF0ZShkYXRlLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGludGwuY29udmVydERhdGVGb3JtYXRUb0ludGxPcHRpb25zKGZvcm1hdCAhPT0gbnVsbCAmJiBmb3JtYXQgIT09IHZvaWQgMCA/IGZvcm1hdCA6IFwic2hvcnQtZGF0ZS1sb25nLXRpbWVcIikpLCB7IHRpbWVab25lOiBcIlVUQ1wiIH0pKTtcbiAgICB9XG4gICAgbGV0IGlzb1RpbWVTdHJpbmcgPSBuZXcgRGF0ZSh2YWx1ZSkudG9JU09TdHJpbmcoKTtcbiAgICBpc29UaW1lU3RyaW5nID0gaXNvVGltZVN0cmluZy5zbGljZSgwLCBpc29UaW1lU3RyaW5nLmluZGV4T2YoXCIuXCIpKSArIFwiWlwiO1xuICAgIHJldHVybiBpc29UaW1lU3RyaW5nO1xufVxuZnVuY3Rpb24gZm9ybWF0TW9udGgodmFsdWVfYmFzZTEsIGludGwsIGZvcm1hdCA9IFwibG9uZ1wiKSB7XG4gICAgLy8gdXNpbmcgYW4gYXJiaXRyYXJ5IGRhdGUgKHRoZSBkYXkgdGhlIGNvZGUgd2FzIHdyaXR0ZW4pIHRvIGF2b2lkIHNpZGUgZWZmZWN0cyBvZiBzZXRNb250aCBuZWFyIHRoZSBlbmQgb2YgdGhlIG1vbnRoXG4gICAgLy8gc2V0TW9udGggd2lsbCBtb3ZlIHRoZSBkYXRlIHRvIHRoZSBuZXh0IG1vbnRoIHdoZW4gbmV3IG1vbnRoIGRvZXNuJ3QgaGF2ZSBjdXJyZW50IGRhdGUgKGUuZy4gOS8zMSwgMi8zMClcbiAgICAvLyBkYXRlID0gbmV3IERhdGUoMjAwMiwgOSwgMzEpOyBkYXRlLnNldE1vbnRoKDgpOyBjb25zb2xlLmxvZyhkYXRlLnRvTG9jYWxlRGF0ZVN0cmluZygpKVxuICAgIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZSgyMDIyLCA5LCAxMCk7XG4gICAgZGF0ZS5zZXRNb250aCh2YWx1ZV9iYXNlMSAtIDEpO1xuICAgIHJldHVybiBpbnRsLmZvcm1hdERhdGUoZGF0ZSwgeyBtb250aDogZm9ybWF0IH0pO1xufVxuZnVuY3Rpb24gZm9ybWF0UXVhcnRlcih2YWx1ZV9iYXNlMSwgaW50bCkge1xuICAgIGNvbnN0IHN0YXJ0TW9udGggPSBmb3JtYXRNb250aCgodmFsdWVfYmFzZTEgLSAxKSAqIDMgKyAxLCBpbnRsLCBcInNob3J0XCIpO1xuICAgIGNvbnN0IGVuZE1vbnRoID0gZm9ybWF0TW9udGgodmFsdWVfYmFzZTEgKiAzLCBpbnRsLCBcInNob3J0XCIpO1xuICAgIHJldHVybiBgJHtzdGFydE1vbnRofSAtICR7ZW5kTW9udGh9YDtcbn1cbmZ1bmN0aW9uIGZvcm1hdERpbWVuc2lvblZhbHVlKHZhbHVlLCBkaW1lbnNpb25JbmZvLCBvcHRpb25zID0ge30pIHtcbiAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfVxuICAgIGNvbnN0IHsgaW50bCwgdXNlUmVjdXJyaW5nVGltZUxhYmVsIH0gPSBvcHRpb25zO1xuICAgIGlmICh1c2VSZWN1cnJpbmdUaW1lTGFiZWwgJiYgaW50bCAmJiAhQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgY29uc3QgaW50ZXJ2YWxVbml0ID0gKF9hID0gZGltZW5zaW9uSW5mby5pbnRlcnZhbFVuaXQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS50b0xvd2VyQ2FzZSgpLnRyaW0oKTtcbiAgICAgICAgLy8gd2Vla2x5IGFuZCBkYWlseSBhcmUgbm90IHN1cHBvcnRlZCB5ZXRcbiAgICAgICAgY29uc3QgY2FuVXNlUmVjdXJyaW5nVGltZUxhYmVsID0gaXNSZWN1cnJpbmdUaW1lRGltZW5zaW9uKGRpbWVuc2lvbkluZm8pICYmIChpbnRlcnZhbFVuaXQgPT09IFwibW9udGhzXCIgfHwgaW50ZXJ2YWxVbml0ID09PSBcInF1YXJ0ZXJzXCIpO1xuICAgICAgICBpZiAoY2FuVXNlUmVjdXJyaW5nVGltZUxhYmVsKSB7XG4gICAgICAgICAgICByZXR1cm4gaW50ZXJ2YWxVbml0ID09PSBcIm1vbnRoc1wiID8gZm9ybWF0TW9udGgodmFsdWUsIGludGwpIDogZm9ybWF0UXVhcnRlcih2YWx1ZSwgaW50bCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gdGhpcyBpcyBwcmVmZXJlZCB3aGVuIGxhYmVsaW5nIGEgc2xpZGVyIGFsaWtlIGNvbnRyb2xcbiAgICBjb25zdCBsYXN0RWxlbWVudCA9IChfYiA9IGRpbWVuc2lvbkluZm8udmFsdWVzKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2JbZGltZW5zaW9uSW5mby52YWx1ZXMubGVuZ3RoIC0gMV07XG4gICAgaWYgKG9wdGlvbnMudXNlU3RhcnRPckVuZEZvclJhbmdlZFZhbHVlICYmIEFycmF5LmlzQXJyYXkodmFsdWUpICYmIHZhbHVlLmxlbmd0aCA9PT0gMiAmJiBBcnJheS5pc0FycmF5KGxhc3RFbGVtZW50KSkge1xuICAgICAgICBjb25zdCBpc0xhc3RFbGVtZW50ID0gdmFsdWUuam9pbihcIi1cIikgPT09IGxhc3RFbGVtZW50LmpvaW4oXCItXCIpO1xuICAgICAgICB2YWx1ZSA9IGlzTGFzdEVsZW1lbnQgPyB2YWx1ZVsxXSA6IHZhbHVlWzBdO1xuICAgIH1cbiAgICBjb25zdCBpc1RpbWUgPSBpc1RpbWVEaW1lbnNpb24oZGltZW5zaW9uSW5mbyk7XG4gICAgaWYgKCFpc1RpbWUpIHtcbiAgICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsdWUpXG4gICAgICAgICAgICA/IHZhbHVlLm1hcCgoZWxlbWVudCkgPT4geyB2YXIgX2E7IHJldHVybiAoX2EgPSBpbnRsID09PSBudWxsIHx8IGludGwgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGludGwuZm9ybWF0TnVtYmVyKGVsZW1lbnQpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBTdHJpbmcoZWxlbWVudCk7IH0pLmpvaW4oXCIgLSBcIilcbiAgICAgICAgICAgIDogKF9jID0gaW50bCA9PT0gbnVsbCB8fCBpbnRsID09PSB2b2lkIDAgPyB2b2lkIDAgOiBpbnRsLmZvcm1hdE51bWJlcih2YWx1ZSkpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IFN0cmluZyh2YWx1ZSk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLnVzZUZyaWVuZGx5SVNPRm9ybWF0ICYmICFvcHRpb25zLmZvcm1hdCkge1xuICAgICAgICBsZXQgcmVzb2x1dGlvbiA9IChfZCA9IGRpbWVuc2lvbkluZm8uaW50ZXJ2YWxVbml0KSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QudG9Mb3dlckNhc2UoKS50cmltKCk7XG4gICAgICAgIGxldCB7IGludGVydmFsLCBleHRlbnQgfSA9IGRpbWVuc2lvbkluZm87XG4gICAgICAgIGlmIChyZXNvbHV0aW9uID09PSBcIm1vbnRoc1wiKSB7XG4gICAgICAgICAgICBpZiAoaW50ZXJ2YWwgPiAxMSkge1xuICAgICAgICAgICAgICAgIHJlc29sdXRpb24gPSBcInllYXJcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChyZXNvbHV0aW9uID09PSBcImRheXNcIikge1xuICAgICAgICAgICAgaWYgKGludGVydmFsID4gMzY0KSB7XG4gICAgICAgICAgICAgICAgcmVzb2x1dGlvbiA9IFwieWVhclwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaW50ZXJ2YWwgPiAyNykge1xuICAgICAgICAgICAgICAgIHJlc29sdXRpb24gPSBcIm1vbnRoc1wiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHJlc29sdXRpb24gPT09IFwiaG91cnNcIikge1xuICAgICAgICAgICAgcmVzb2x1dGlvbiA9IFwiZGF5c1wiO1xuICAgICAgICB9XG4gICAgICAgIGlmICghW1wieWVhcnNcIiwgXCJtb250aHNcIiwgXCJkYXlzXCJdLmluY2x1ZGVzKHJlc29sdXRpb24pICYmIChleHRlbnQgPT09IG51bGwgfHwgZXh0ZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBleHRlbnQubGVuZ3RoKSkge1xuICAgICAgICAgICAgY29uc3QgaW50ZXJ2YWwgPSAoZXh0ZW50WzFdIC0gZXh0ZW50WzBdKSAvIGRpbWVuc2lvbkluZm8udmFsdWVzLmxlbmd0aDtcbiAgICAgICAgICAgIGNvbnN0IGRheSA9IDg2NDAwMDAwO1xuICAgICAgICAgICAgaWYgKGludGVydmFsID49IDM2NSAqIGRheSkge1xuICAgICAgICAgICAgICAgIHJlc29sdXRpb24gPSBcInllYXJzXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpbnRlcnZhbCA+PSAyOCAqIGRheSkge1xuICAgICAgICAgICAgICAgIHJlc29sdXRpb24gPSBcIm1vbnRoc1wiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZvcm1hdCA9IHJlc29sdXRpb24gPT09IFwieWVhcnNcIiA/IFwieWVhclwiIDogcmVzb2x1dGlvbiA9PT0gXCJtb250aHNcIiA/IFwic2hvcnQtbW9udGgteWVhclwiIDogXCJzaG9ydC1kYXRlXCI7XG4gICAgICAgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHsgZm9ybWF0IH0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh2YWx1ZSlcbiAgICAgICAgPyB2YWx1ZS5tYXAoKGVsZW1lbnQpID0+IGZvcm1hdFRpbWUoZWxlbWVudCwgb3B0aW9ucykpLmpvaW4oXCIgLSBcIilcbiAgICAgICAgOiBmb3JtYXRUaW1lKHZhbHVlLCBvcHRpb25zKTtcbn1cbmZ1bmN0aW9uIGdldENsaXBwZWREaW1lbnNpb25JbmZvKGRpbWVuc2lvbkluZm8sIG11bHRpZGltZW5zaW9uYWxTdWJzZXQpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgY29uc3RyYWludCA9IChfYSA9IG11bHRpZGltZW5zaW9uYWxTdWJzZXQgPT09IG51bGwgfHwgbXVsdGlkaW1lbnNpb25hbFN1YnNldCA9PT0gdm9pZCAwID8gdm9pZCAwIDogbXVsdGlkaW1lbnNpb25hbFN1YnNldC5kaW1lbnNpb25zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZmluZCgoeyBuYW1lIH0pID0+IG5hbWUgPT09IGRpbWVuc2lvbkluZm8ubmFtZSk7XG4gICAgaWYgKCEoY29uc3RyYWludCA9PT0gbnVsbCB8fCBjb25zdHJhaW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb25zdHJhaW50LmV4dGVudCkpIHtcbiAgICAgICAgcmV0dXJuIGRpbWVuc2lvbkluZm87XG4gICAgfVxuICAgIGNvbnN0IGV4dGVudCA9IFsuLi5jb25zdHJhaW50LmV4dGVudF07XG4gICAgY29uc3QgdmFsdWVzID0gZGltZW5zaW9uSW5mby52YWx1ZXMuZmlsdGVyKCh2YWx1ZSkgPT4ge1xuICAgICAgICAvLyBtdXN0IGJlIGNvbnRhaW5lZCwgaW50ZXJzZWN0aW9uIGlzIG5vdCBzdWZmaWNpZW50XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgaWYgKCFpc0RlZmluZWQoZXh0ZW50WzFdKSB8fCBleHRlbnRbMF0gPT09IGV4dGVudFsxXSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZVswXSA9PT0gZXh0ZW50WzBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlWzBdID49IGV4dGVudFswXSAmJiB2YWx1ZVswXSA8PSBleHRlbnRbMV0gJiYgdmFsdWVbMV0gPj0gZXh0ZW50WzBdICYmIHZhbHVlWzFdIDw9IGV4dGVudFsxXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWUgPj0gZXh0ZW50WzBdICYmIHZhbHVlIDw9IGV4dGVudFsxXTtcbiAgICB9KTtcbiAgICAvLyB0aGlzIGlzIGEgc3BlY2lhbCBjYXNlLCB3aGVuIGxhc3Qgc2xpY2Ugb2YgYSByYW5nZWQgZGltZW5zaW9uIHNlcmllcyBpcyB1c2VkXG4gICAgaWYgKHZhbHVlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgY29uc3QgbGFzdFZhbHVlID0gZGltZW5zaW9uSW5mby52YWx1ZXNbZGltZW5zaW9uSW5mby52YWx1ZXMubGVuZ3RoIC0gMV07XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGxhc3RWYWx1ZSkgJiYgbGFzdFZhbHVlWzFdID09PSBleHRlbnRbMF0pIHtcbiAgICAgICAgICAgIHZhbHVlcy5wdXNoKGxhc3RWYWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZGltZW5zaW9uSW5mbyksIHsgZXh0ZW50LCB2YWx1ZXMgfSk7XG59XG5mdW5jdGlvbiBnZXREZWZhdWx0RGltZW5zaW9uU2xpY2VWYWx1ZShkaW1lbnNpb25JbmZvKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IHsgdmFsdWVzLCBleHRlbnQsIG5hbWUgfSA9IGRpbWVuc2lvbkluZm87XG4gICAgbGV0IHZhbHVlID0gKF9hID0gdmFsdWVzID09PSBudWxsIHx8IHZhbHVlcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogdmFsdWVzWzBdKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBleHRlbnRbMF07XG4gICAgaWYgKG5hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJzdGR6XCIgJiZcbiAgICAgICAgIWRpbWVuc2lvbkluZm8uaGFzUmFuZ2VzICYmXG4gICAgICAgIE1hdGguYWJzKGV4dGVudFsxXSkgPD0gTWF0aC5hYnMoZXh0ZW50WzBdKSkge1xuICAgICAgICBpZiAodmFsdWVzID09PSBudWxsIHx8IHZhbHVlcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogdmFsdWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZXNbdmFsdWVzLmxlbmd0aCAtIDFdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFsdWUgPSBleHRlbnRbMV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuZnVuY3Rpb24gZ2V0TXVsdGlkaW1lbnNpb25hbERlZmluaXRpb24obGF5ZXIpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIHJldHVybiBsYXllci50eXBlID09PSBcImltYWdlcnktdGlsZVwiXG4gICAgICAgID8gbGF5ZXIubXVsdGlkaW1lbnNpb25hbERlZmluaXRpb25cbiAgICAgICAgOiAoX2IgPSAoKF9hID0gbGF5ZXIubW9zYWljUnVsZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogbGF5ZXIuX2RlZmF1bHRTZXJ2aWNlTW9zYWljUnVsZSkpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5tdWx0aWRpbWVuc2lvbmFsRGVmaW5pdGlvbjtcbn1cbmFzeW5jIGZ1bmN0aW9uIGdldE11bHRpZGltZW5zaW9uYWxJbmZvKGxheWVyLCB1c2VSYXdTb3VyY2VJbmZvKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICBpZiAobGF5ZXIudHlwZSA9PT0gXCJpbWFnZXJ5LXRpbGVcIikge1xuICAgICAgICByZXR1cm4gbGF5ZXIucmFzdGVySW5mby5tdWx0aWRpbWVuc2lvbmFsSW5mbztcbiAgICB9XG4gICAgY29uc3QgeyByYXN0ZXJGdW5jdGlvbiwgdmVyc2lvbiB9ID0gbGF5ZXI7XG4gICAgaWYgKHVzZVJhd1NvdXJjZUluZm8gfHxcbiAgICAgICAgdmVyc2lvbiA8PSBtaW5WZXJzaW9uUkZUTXVsdGlkaW1lbnNpb25hbEluZm8gfHxcbiAgICAgICAgIXJhc3RlckZ1bmN0aW9uIHx8XG4gICAgICAgICgoX2EgPSByYXN0ZXJGdW5jdGlvbi5mdW5jdGlvbk5hbWUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS50b0xvd2VyQ2FzZSgpKSA9PT0gXCJub25lXCIpIHtcbiAgICAgICAgcmV0dXJuIGxheWVyLnNlcnZpY2VSYXN0ZXJJbmZvLm11bHRpZGltZW5zaW9uYWxJbmZvO1xuICAgIH1cbiAgICBjb25zdCByYXN0ZXJJbmZvID0gKF9iID0gKGF3YWl0IGxheWVyLmdlbmVyYXRlUmFzdGVySW5mbyhsYXllci5yYXN0ZXJGdW5jdGlvbikpKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBsYXllci5zZXJ2aWNlUmFzdGVySW5mbztcbiAgICByZXR1cm4gcmFzdGVySW5mby5tdWx0aWRpbWVuc2lvbmFsSW5mbztcbn1cbmZ1bmN0aW9uIGlzVGltZURpbWVuc2lvbihkaW1lbnNpb25JbmZvLCBpZ25vcmVSZWN1cmluZyA9IGZhbHNlKSB7XG4gICAgcmV0dXJuIGRpbWVuc2lvbkluZm8ubmFtZSA9PT0gXCJTdGRUaW1lXCIgJiYgKGlnbm9yZVJlY3VyaW5nIHx8ICFkaW1lbnNpb25JbmZvLnJlY3VycmluZyk7XG59XG5mdW5jdGlvbiBpc1JlY3VycmluZ1RpbWVEaW1lbnNpb24oZGltZW5zaW9uSW5mbykge1xuICAgIHJldHVybiBkaW1lbnNpb25JbmZvLm5hbWUgPT09IFwiU3RkVGltZVwiICYmICEhZGltZW5zaW9uSW5mby5yZWN1cnJpbmc7XG59XG5mdW5jdGlvbiB1cGRhdGVEaW1lbnNpb25hbERlZmluaXRpb24oZGVmLCBkaW1lbnNpb25JbmZvLCBhY3RpdmVNdWx0aWRpbWVuc2lvbmFsU3Vic2V0KSB7XG4gICAgZGltZW5zaW9uSW5mbyA9IGdldENsaXBwZWREaW1lbnNpb25JbmZvKGRpbWVuc2lvbkluZm8sIGFjdGl2ZU11bHRpZGltZW5zaW9uYWxTdWJzZXQpO1xuICAgIGNvbnN0IG9yaWdpbmFsRm9ybWF0dGVkVmFsdWUgPSBmb3JtYXREaW1lbnNpb25WYWx1ZShkZWYudmFsdWVzWzBdLCBkaW1lbnNpb25JbmZvKTtcbiAgICBjb25zdCBoYXNPcmlnaW5hbEZvcm1hdHRlZFZhbHVlID0gZGltZW5zaW9uSW5mby52YWx1ZXMuc29tZSgodmFsKSA9PiBvcmlnaW5hbEZvcm1hdHRlZFZhbHVlID09PSBmb3JtYXREaW1lbnNpb25WYWx1ZSh2YWwsIGRpbWVuc2lvbkluZm8pKTtcbiAgICBpZiAoIWhhc09yaWdpbmFsRm9ybWF0dGVkVmFsdWUpIHtcbiAgICAgICAgLy8gZ2V0IGRlZmF1bHQgc2xpY2UgdmFsdWUgd2hlbiBkZWYudmFsdWVzIGlzIGludmFsaWRcbiAgICAgICAgY29uc3QgdmFsdWUgPSBnZXREZWZhdWx0RGltZW5zaW9uU2xpY2VWYWx1ZShkaW1lbnNpb25JbmZvKTtcbiAgICAgICAgZGVmLnZhbHVlcyA9IFt2YWx1ZV07XG4gICAgfVxufVxuXG5leHBvcnQgeyBnZXRNdWx0aWRpbWVuc2lvbmFsSW5mbyBhcyBhLCBnZXREZWZhdWx0RGltZW5zaW9uU2xpY2VWYWx1ZSBhcyBiLCBnZXRNdWx0aWRpbWVuc2lvbmFsRGVmaW5pdGlvbiBhcyBjLCBmb3JtYXREaW1lbnNpb25WYWx1ZSBhcyBmLCBnZXRDbGlwcGVkRGltZW5zaW9uSW5mbyBhcyBnLCBpc1RpbWVEaW1lbnNpb24gYXMgaSwgbWluVmVyc2lvblJGVE11bHRpZGltZW5zaW9uYWxJbmZvIGFzIG0sIHVwZGF0ZURpbWVuc2lvbmFsRGVmaW5pdGlvbiBhcyB1IH07XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW11bHRpZGltZW5zaW9uYWwtNjlmMzk2OGYuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9