"use strict";
(self["webpackChunkexb_client"] = self["webpackChunkexb_client"] || []).push([["vendors-extensions_widgets_arcgis_analysis_node_modules_arcgis_app-components_dist_esm_arcgis-c13757"],{

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/arcgis-schema-editor-category_2.entry.js":
/*!**********************************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/arcgis-schema-editor-category_2.entry.js ***!
  \**********************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   arcgis_schema_editor_category: () => (/* binding */ ArcgisSchemaEditorCategory),
/* harmony export */   arcgis_schema_editor_category_row: () => (/* binding */ ArcgisSchemaEditorCategoryRow)
/* harmony export */ });
/* harmony import */ var _index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index-e3bf7da7.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/index-e3bf7da7.js");
/* harmony import */ var _sortable_esm_7e785780_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./sortable.esm-7e785780.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/sortable.esm-7e785780.js");
/* harmony import */ var _categories_ca134005_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./categories-ca134005.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/categories-ca134005.js");
/* harmony import */ var _util_2a0e2f08_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./util-2a0e2f08.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/util-2a0e2f08.js");
/* harmony import */ var _functional_44de8fcf_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./functional-44de8fcf.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/functional-44de8fcf.js");
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v4.0.58
 */






const ARCGIS_SCHEMA_EDITOR_DRAG_HANDLE_CLASS = "arcgis-schema-editor-category-row__drag-handle";

const arcgisSchemaEditorCategoryCss = ".arcgis-schema-editor-category__category-container{list-style-type:none;margin-top:0px;margin-bottom:0px;margin-bottom:0.25rem;padding-inline-start:1rem;margin-inline-start:1rem;border-left:1px solid var(--calcite-color-border-2)}.arcgis-schema-editor-category__category-container--root{margin-left:0px;margin-right:0px;padding-left:0px;padding-right:0px;border-width:0px}.arcgis-schema-editor-category__category-container__hidden{display:none}.arcgis-schema-editor-category__add-category-btn--hide,.arcgis-schema-editor-category__new-category--hide{display:none}";

const ArcgisSchemaEditorCategory = class {
    constructor(hostRef) {
        (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.r)(this, hostRef);
        this.arcgisSchemaEditorInternalDeleteClick = (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, "arcgisSchemaEditorInternalDeleteClick", 7);
        this.listOrderChanged = (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, "listOrderChanged", 7);
        this.itemRefs = {};
        this.isMaxDepth = false;
        this.isRoot = false;
        this.renderCategoryContainer = () => {
            const { category, canAddCategory, isRoot, isCollapsed, isAddingCategory, isBeingDragged, canEditCategory, saveNewTitle, saveNewCategory, maxDepth, i18n, isMoveValid, canDeleteCategory, newCategoryMode, isMaxDepth } = this;
            const path = category.path;
            const hideSubcategories = isCollapsed || isBeingDragged;
            return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("ul", { class: {
                    "arcgis-schema-editor-category__category-container": true,
                    // Use css to hide so it doesn't flicker when expanding
                    "arcgis-schema-editor-category__category-container__hidden": hideSubcategories,
                    "arcgis-schema-editor-category__category-container--root": isRoot
                }, ref: (ele) => (this.dragContainerRef = ele) }, category.categories.map((subcategory) => {
                const categoryPath = subcategory.path;
                return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("li", { key: categoryPath }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("arcgis-schema-editor-category", { category: subcategory, newCategoryMode: newCategoryMode, canAddCategory: canAddCategory, canDeleteCategory: canDeleteCategory, canEditCategory: canEditCategory, i18n: i18n, maxDepth: maxDepth, isMoveValid: isMoveValid, saveNewTitle: saveNewTitle, saveNewCategory: saveNewCategory, ref: (el) => (this.itemRefs[categoryPath] = el) })));
            }), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("arcgis-schema-editor-category-row", { class: {
                    // Can't just not render to prevent flicker animation
                    "arcgis-schema-editor-category__new-category--hide": !isAddingCategory
                }, category: {
                    categories: [],
                    count: 0,
                    path: (0,_categories_ca134005_js__WEBPACK_IMPORTED_MODULE_2__.a)(path, { title: "new-category" }),
                    title: ""
                }, isCollapsible: false, isCollapsed: true, isNewCategory: true, canDeleteCategory: false, canEditCategory: () => true, i18n: i18n, onArcgisSchemaEditorInternalCancelClick: () => (this.isAddingCategory = false), saveNewTitle: async (event) => {
                    const doSave = await saveNewCategory(event);
                    if (doSave) {
                        this.isAddingCategory = false;
                    }
                    return doSave;
                }, ref: (ele) => (this.newCategoryRef = ele) }), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-button", { appearance: "transparent", kind: "neutral", onClick: () => (this.isAddingCategory = true), iconStart: "plus-circle", ref: (el) => (this.addCategoryButtonRef = el), class: {
                    "arcgis-schema-editor-category__add-category-btn--hide": isAddingCategory || isMaxDepth || isBeingDragged || !canAddCategory || isCollapsed
                } }), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-tooltip", { referenceElement: this.addCategoryButtonRef }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", null, isRoot ? i18n.categoryItem.addCategory : i18n.categoryItem.addSubcategory))));
        };
        this.category = undefined;
        this.canAddCategory = undefined;
        this.canDeleteCategory = undefined;
        this.newCategoryMode = undefined;
        this.showInputByDefault = false;
        this.canEditCategory = undefined;
        this.maxDepth = undefined;
        this.i18n = undefined;
        this.isMoveValid = undefined;
        this.saveNewTitle = undefined;
        this.saveNewCategory = undefined;
        this.isCollapsed = false;
        this.isBeingDragged = false;
        this.isAddingCategory = false;
        this.addCategoryButtonRef = undefined;
    }
    componentWillLoad() {
        const path = this.category.path;
        this.isRoot = path === null;
        this.isMaxDepth = this.isRoot ? false : (0,_util_2a0e2f08_js__WEBPACK_IMPORTED_MODULE_3__.f)(path) > this.maxDepth;
        this.isCollapsed = this.newCategoryMode && !this.isRoot;
    }
    componentDidLoad() {
        // Have to do it here since this will trigger `@Watch("isAddingCategory") and `reset` depends on a ref
        //  which is only available after the first mount
        this.onShowInputByDefaultChange();
        new _sortable_esm_7e785780_js__WEBPACK_IMPORTED_MODULE_1__.S(this.dragContainerRef, {
            group: "arcgis-schema-editor",
            animation: 200,
            handle: `.${ARCGIS_SCHEMA_EDITOR_DRAG_HANDLE_CLASS}`,
            chosenClass: "arcgis-schema-editor-category-row--dragging",
            onSort: (event) => {
                const { from, to, oldIndex, newIndex, item } = event;
                const fromCategory = from.closest("arcgis-schema-editor-category").category;
                const toCategory = to.closest("arcgis-schema-editor-category").category;
                // `item` is the element being dragged, not the container so we need to look downward instead of upward
                const fromItemCategory = item.querySelector("arcgis-schema-editor-category").category;
                const payload = {
                    fromCategory,
                    toCategory,
                    fromItemCategory,
                    fromIndex: oldIndex,
                    toIndex: newIndex
                };
                const isValidMove = this.isMoveValid ? this.isMoveValid(payload) : true;
                if (isValidMove === null) {
                    // Duplicate event case, just ignore
                    return;
                }
                if (!isValidMove) {
                    // Revert the move
                    from.insertBefore(item, from.children[oldIndex > newIndex ? oldIndex + 1 : oldIndex]);
                    return;
                }
                this.listOrderChanged.emit(payload);
            },
            setData: (dataTransfer) => {
                // ! Required by Firefox in order to DnD work: https://stackoverflow.com/a/19055350/1411105
                // https://github.com/SortableJS/Sortable/issues/1267#issuecomment-494757862
                dataTransfer.setData("foo", "bar");
            }
        });
    }
    onShowInputByDefaultChange() {
        this.isAddingCategory = this.newCategoryMode && this.isRoot && this.showInputByDefault;
    }
    onIsAddingCategoryChange() {
        var _a;
        (_a = this.newCategoryRef) === null || _a === void 0 ? void 0 : _a.reset();
    }
    async expandOrCollapseAll(collapseAll) {
        if (!this.isRoot) {
            this.isCollapsed = collapseAll;
        }
        Object.values(this.itemRefs).forEach((item) => {
            // `?` because when collapsing, the child will be null
            item === null || item === void 0 ? void 0 : item.expandOrCollapseAll(collapseAll);
        });
    }
    async setIsBeingDragged(isBeingDragged) {
        const hasChildren = this.category.categories.length > 0;
        if (hasChildren) {
            this.isBeingDragged = isBeingDragged;
        }
    }
    render() {
        const { category, canDeleteCategory, canEditCategory, isRoot, isMaxDepth, isCollapsed, i18n, renderCategoryContainer, saveNewTitle, arcgisSchemaEditorInternalDeleteClick } = this;
        /**
         * In case of the root, we don't really have a root row
         *  so we just renders a category and its children, appropriately styled if nested
         */
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)(_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.H, null, !isRoot && ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("arcgis-schema-editor-category-row", { category: category, isCollapsible: !isMaxDepth, isCollapsed: isCollapsed, canDeleteCategory: canDeleteCategory, canEditCategory: (category) => canEditCategory({ category, parentCategory: this.category }), i18n: i18n, onArcgisSchemaEditorInternalDeleteClick: (event) => {
                event.stopPropagation();
                arcgisSchemaEditorInternalDeleteClick.emit(event.detail);
            }, onArcgisSchemaEditorInternalExpandClick: (event) => (this.isCollapsed = event.detail.isCollapsed), saveNewTitle: saveNewTitle })), renderCategoryContainer()));
    }
    get el() { return (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.d)(this); }
    static get watchers() { return {
        "showInputByDefault": ["onShowInputByDefaultChange"],
        "isAddingCategory": ["onIsAddingCategoryChange"]
    }; }
};
ArcgisSchemaEditorCategory.style = arcgisSchemaEditorCategoryCss;

const arcgisSchemaEditorCategoryRowCss = ".arcgis-schema-editor-category-row{display:flex;align-items:center;background-color:var(--calcite-color-foreground-1);height:2.5rem;margin-bottom:0.25rem}.arcgis-schema-editor-category-row--editing{padding-left:0.5rem;padding-right:0.5rem}.arcgis-schema-editor-category-row__inline-input{font-size:0.875rem;width:100%}.arcgis-schema-editor-category-row__cta{display:flex;align-items:center;justify-content:center;height:100%;width:2.5rem}.arcgis-schema-editor-category-row__drag-handle{height:100%}.arcgis-schema-editor-category-row__btn-popover{white-space:nowrap;padding-left:0.5rem;padding-right:0.5rem;padding-top:0.25rem;padding-bottom:0.25rem}.arcgis-schema-editor-category-row__cant-edit-reason{--calcite-ui-icon-color:var(--calcite-color-status-warning)}.arcgis-schema-editor-category-row--dragging{opacity:0.25}";

const ArcgisSchemaEditorCategoryRow = class {
    constructor(hostRef) {
        (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.r)(this, hostRef);
        this.arcgisSchemaEditorInternalDeleteClick = (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, "arcgisSchemaEditorInternalDeleteClick", 7);
        this.arcgisSchemaEditorInternalExpandClick = (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, "arcgisSchemaEditorInternalExpandClick", 7);
        this.arcgisSchemaEditorInternalCancelClick = (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, "arcgisSchemaEditorInternalCancelClick", 7);
        this.onCancelEdit = () => {
            const { arcgisSchemaEditorInternalCancelClick, isNewCategory } = this;
            if (!isNewCategory) {
                this.isEditing = false;
            }
            this.editedCategoryTitle = this.category.title;
            arcgisSchemaEditorInternalCancelClick.emit();
        };
        this.onSaveEdit = async () => {
            const { category, editInputRef, editedCategoryTitle, saveNewTitle, setInvalid, isNewCategory } = this;
            if (!editedCategoryTitle) {
                setInvalid();
                return false;
            }
            if (editedCategoryTitle === category.title && !isNewCategory) {
                this.isEditing = false;
                return true;
            }
            editInputRef.status = "idle";
            try {
                const saveResult = await saveNewTitle({
                    newTitle: editedCategoryTitle,
                    path: category.path,
                    categoryCount: category.count
                });
                if (!saveResult) {
                    setInvalid();
                    return false;
                }
                if (!isNewCategory) {
                    this.isEditing = false;
                }
                return true;
            }
            catch (error) {
                if (!isNewCategory) {
                    this.isEditing = false;
                }
                console.error(error);
                return false;
            }
        };
        this.setInvalid = () => {
            const { editInputRef } = this;
            editInputRef.status = "invalid";
            editInputRef.setFocus();
        };
        this.category = undefined;
        this.i18n = undefined;
        this.isNewCategory = false;
        this.canEditCategory = undefined;
        this.canDeleteCategory = undefined;
        this.isCollapsible = undefined;
        this.isCollapsed = undefined;
        this.saveNewTitle = undefined;
        this.isEditing = this.isNewCategory;
        this.editedCategoryTitle = this.category.title;
        this.expandCollapseButtonRef = undefined;
        this.deleteButtonRef = undefined;
        this.editInputRef = undefined;
        this.cantEditIconRef = undefined;
    }
    async reset() {
        const { isNewCategory, category, canEditReason } = this;
        if (isNewCategory && canEditReason === true) {
            this.editedCategoryTitle = category.title;
            this.editInputRef.status = "idle";
            /**
             * ! This is to handle the edge case where the `x` cta is clicked
             *  which cc-inline-editable will automatically go out of the edit mode
             * However, we don't want that in `isNewCategory` mode so we need to set it back to true
             *  after a bit to trigger the re-render
             */
            this.isEditing = false;
            await (0,_functional_44de8fcf_js__WEBPACK_IMPORTED_MODULE_4__.t)(50);
            this.isEditing = true;
            this.editInputRef.setFocus();
        }
    }
    async setFocus() {
        this.editInputRef.setFocus();
    }
    componentWillLoad() {
        var _a, _b;
        this.canEditReason = (_b = (_a = this.canEditCategory) === null || _a === void 0 ? void 0 : _a.call(this, this.category)) !== null && _b !== void 0 ? _b : true;
    }
    render() {
        const { category, isCollapsed, isEditing, isCollapsible, canDeleteCategory, canEditReason, i18n, editedCategoryTitle, onCancelEdit, onSaveEdit, arcgisSchemaEditorInternalExpandClick, isNewCategory } = this;
        const count = category.count;
        const textContent = isEditing
            ? editedCategoryTitle
            : `${editedCategoryTitle} ${count ? `(${count})` : ""}`;
        const showEdit = canEditReason === true;
        const showDelete = showEdit && !isEditing && !isNewCategory && canDeleteCategory;
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)(_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.H, null, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "arcgis-schema-editor-category-row" }, !isNewCategory && !isEditing && ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-button", { appearance: "transparent", kind: "neutral", iconStart: "drag", class: ARCGIS_SCHEMA_EDITOR_DRAG_HANDLE_CLASS })), isCollapsible && ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)(_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.F, null, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-button", { appearance: "transparent", kind: "neutral", onClick: () => arcgisSchemaEditorInternalExpandClick.emit({ isCollapsed: !isCollapsed }), iconStart: isCollapsed || isEditing ? "chevron-up" : "chevron-down", class: "cta", ref: (el) => (this.expandCollapseButtonRef = el) }), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-tooltip", { referenceElement: this.expandCollapseButtonRef }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "btn-popover" }, isCollapsed ? i18n.categoryItem.expand : i18n.categoryItem.collapse)))), showEdit ? ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-inline-editable", { class: "arcgis-schema-editor-category-row__inline-input", controls: true, editingEnabled: isEditing, afterConfirm: async () => {
                // ! Even though this trigger the loading state of the check CTA, the cancel CTA is still clickable
                // TODO: add a handle for when it's clicked when we're still loading
                const isValid = await onSaveEdit();
                if (isValid === false) {
                    // Throw to prevent getting out of edit mode
                    throw new Error();
                }
            }, onCalciteInlineEditableEditCancel: (event) => {
                event.stopPropagation();
                onCancelEdit();
            },
            // @ts-ignore --- we need to disable the trash can button on edit
            onCalciteInternalInlineEditableEnableEditingChange: () => (this.isEditing = true) }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-input", { value: textContent, onCalciteInputInput: (event) => (this.editedCategoryTitle = event.target.value), required: true, ref: (ele) => (this.editInputRef = ele) }))) : ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)(_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.F, null, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "arcgis-schema-editor-category-row__inline-input" }, textContent), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-action", { class: "arcgis-schema-editor-category-row__cant-edit-reason", icon: "exclamation-mark-triangle-f", appearance: "transparent", label: canEditReason, ref: (el) => (this.cantEditIconRef = el), text: "", textEnabled: false }), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-tooltip", { referenceElement: this.cantEditIconRef }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "btn-popover" }, canEditReason)))), showDelete && ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)(_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.F, null, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-button", { appearance: "transparent", kind: "danger", onClick: () => this.arcgisSchemaEditorInternalDeleteClick.emit({
                path: category.path,
                categoryCount: count
            }), iconStart: "trash", class: "cta", ref: (el) => (this.deleteButtonRef = el) }), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-tooltip", { referenceElement: this.deleteButtonRef }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "btn-popover" }, i18n.categoryItem.deleteCategory)))))));
    }
    get el() { return (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.d)(this); }
};
ArcgisSchemaEditorCategoryRow.style = arcgisSchemaEditorCategoryRowCss;



//# sourceMappingURL=arcgis-schema-editor-category_2.entry.js.map

/***/ }),

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/categories-ca134005.js":
/*!****************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/categories-ca134005.js ***!
  \****************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   C: () => (/* binding */ CATEGORY_BASE_PATH),
/* harmony export */   U: () => (/* binding */ UPPER_CATEGORY_BASE_PATH),
/* harmony export */   a: () => (/* binding */ getCategoryUIPath),
/* harmony export */   g: () => (/* binding */ getRootCategoryPath)
/* harmony export */ });
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v4.0.58
 */
const CATEGORY_BASE_PATH = "/categories";
const UPPER_CATEGORY_BASE_PATH = "/Categories";

// TODO: add unit tests
/**
 * Construct the path of the category based on the parent path and the category title
 */
const getCategoryUIPath = (parentPath, category, lowerCase = true) => {
    const basePath = parentPath !== null && parentPath !== void 0 ? parentPath : "";
    return `${basePath}${basePath.endsWith("/") ? "" : "/"}${lowerCase ? category.title.toLocaleLowerCase() : category.title}`;
};
/**
 * Find the root node title to use for categories
 */
function getRootCategoryPath(categories) {
    var _a;
    let categoryTitle = (_a = categories === null || categories === void 0 ? void 0 : categories[0]) === null || _a === void 0 ? void 0 : _a.title;
    if (categoryTitle && categoryTitle.charAt(0) !== "/") {
        categoryTitle = `/${categoryTitle}`;
    }
    return categoryTitle || UPPER_CATEGORY_BASE_PATH;
}



//# sourceMappingURL=categories-ca134005.js.map

/***/ }),

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/functional-44de8fcf.js":
/*!****************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/functional-44de8fcf.js ***!
  \****************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   a: () => (/* binding */ arrayToLookupMap),
/* harmony export */   b: () => (/* binding */ unique),
/* harmony export */   c: () => (/* binding */ throttle),
/* harmony export */   d: () => (/* binding */ debounce),
/* harmony export */   e: () => (/* binding */ escapeRegExp),
/* harmony export */   f: () => (/* binding */ arraysAreEquivalent),
/* harmony export */   g: () => (/* binding */ chunk),
/* harmony export */   i: () => (/* binding */ isDefined),
/* harmony export */   m: () => (/* binding */ minDelay),
/* harmony export */   t: () => (/* binding */ timeout),
/* harmony export */   u: () => (/* binding */ uniqueBy)
/* harmony export */ });
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v4.0.58
 */
/**
 * Call a function only after it has not been called for n milliseconds
 * @param fn    - function to call
 * @param delay - delay in milliseconds
 */
const debounce = (fn, delay) => {
    let timeout;
    let status = "idle";
    function flush(...args) {
        status = "flushed";
        return debounced(...args);
    }
    function invoke(...args) {
        status = "invoked";
        return debounced(...args);
    }
    function cancel(...args) {
        status = "cancelled";
        return debounced(...args);
    }
    function getStatus() {
        return status;
    }
    const debounced = (...args) => new Promise((resolve) => {
        switch (status) {
            case "flushed":
                status = "idle";
                if (timeout) {
                    clearTimeout(timeout);
                    resolve(fn(...args));
                }
                else {
                    resolve(null);
                }
                break;
            case "invoked":
                clearTimeout(timeout);
                status = "idle";
                resolve(fn(...args));
                break;
            case "cancelled":
                clearTimeout(timeout);
                status = "idle";
                resolve(null);
                break;
            default:
                if (timeout) {
                    clearTimeout(timeout);
                }
                status = "pending";
                timeout = setTimeout(() => {
                    status = "idle";
                    return resolve(fn(...args));
                }, delay);
                break;
        }
    });
    debounced.flush = flush;
    debounced.invoke = invoke;
    debounced.cancel = cancel;
    debounced.getStatus = getStatus;
    return debounced;
};
/**
 * Call a function only after n milliseconds have elapsed
 * @param fn    - function to call
 * @param delay - delay in milliseconds
 */
const throttle = (fn, delay) => {
    let timeout;
    return (...args) => new Promise((resolve) => {
        if (timeout) {
            return;
        }
        timeout = setTimeout(() => {
            clearTimeout(timeout);
            timeout = undefined;
            resolve(fn(...args));
        }, delay);
    });
};
function escapeRegExp(str) {
    return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"); // $& means the whole matched string
}
function isDefined(value) {
    return value !== undefined && value !== null;
}
/**
 * Set a minimum time for a promise to resolve (useful for preventing flash of loaders)
 */
async function minDelay(promise, minDelay) {
    await Promise.all([promise, timeout(minDelay)]);
    return promise;
}
/**
 * Helper method to inline setTimeout as an await in async functions
 */
function timeout(ms) {
    return new Promise((resolve) => setTimeout(resolve, ms));
}
const arrayToLookupMap = (dataArr, getKeyAndItem) => Object.fromEntries((dataArr || []).map((item) => {
    const { key, data } = getKeyAndItem(item);
    return [key, data];
}));
/**
 * Check whether two arrays have the same number of elements
 * and whether they contain the same elements
 * regardless of order
 */
const arraysAreEquivalent = (arr1, arr2) => arr1.length === arr2.length && arr1.reduce((memo, str) => memo && arr2.indexOf(str) > -1, true);
function uniqueBy(myArr, getItemId) {
    const resultArr = [];
    const lookupMap = {};
    myArr.forEach((item) => {
        const id = getItemId(item);
        if (lookupMap[id] == null) {
            lookupMap[id] = item;
            resultArr.push(item);
        }
    });
    return resultArr;
}
function unique(myArr) {
    const primitives = { boolean: {}, number: {}, string: {} };
    const objs = [];
    return myArr.filter((item) => {
        let type = typeof item;
        if (type in primitives) {
            return primitives[type].hasOwnProperty(item) ? false : (primitives[type][item] = true);
        }
        else {
            return objs.indexOf(item) >= 0 ? false : objs.push(item);
        }
    });
}
const chunk = (arr, size) => [...Array(Math.ceil(arr.length / size))].map((_, i) => arr.slice(size * i, size + size * i));



//# sourceMappingURL=functional-44de8fcf.js.map

/***/ }),

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/util-2a0e2f08.js":
/*!**********************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/util-2a0e2f08.js ***!
  \**********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   M: () => (/* binding */ MAX_CATEGORY_NAME_LENGTH),
/* harmony export */   a: () => (/* binding */ getNewCategorySchemaFromDelete),
/* harmony export */   b: () => (/* binding */ getCategoryFromPath),
/* harmony export */   c: () => (/* binding */ checkNewCategoryTitleValid),
/* harmony export */   d: () => (/* binding */ getNewCategorySchemaFromTitleChange),
/* harmony export */   e: () => (/* binding */ getNewCategorySchemaFromCategoryAdd),
/* harmony export */   f: () => (/* binding */ getPathLength),
/* harmony export */   g: () => (/* binding */ getNewCategorySchemaFromMove),
/* harmony export */   h: () => (/* binding */ getUICategoryFromCategorySchema),
/* harmony export */   i: () => (/* binding */ countNumCategories)
/* harmony export */ });
/* harmony import */ var _categories_ca134005_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./categories-ca134005.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/categories-ca134005.js");
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v4.0.58
 */


// TODO: add unit tests
const getNewCategorySchemaFromMove = (category, { fromCategory: { path: fromPath }, toCategory: { path: toPath }, fromIndex, toIndex }) => {
    // Copy since this will be a destructive operation
    const uiCategory = structuredClone(category);
    const fromCategory = getCategoryFromPath(uiCategory, fromPath);
    let toCategory = fromCategory;
    if (fromPath !== toPath) {
        toCategory = getCategoryFromPath(uiCategory, toPath);
    }
    const [removed] = fromCategory.targetCategory.categories.splice(fromIndex, 1);
    toCategory.targetCategory.categories.splice(toIndex, 0, removed);
    return getCategorySchemaFromUICategory(uiCategory);
};
const getNewCategorySchemaFromTitleChange = (category, { newTitle, path }) => {
    const uiCategory = structuredClone(category);
    const categoryToChange = getCategoryFromPath(uiCategory, path);
    categoryToChange.targetCategory.title = newTitle;
    return getCategorySchemaFromUICategory(uiCategory);
};
const getNewCategorySchemaFromCategoryAdd = (category, { newTitle, path }) => {
    const uiCategory = structuredClone(category);
    // Remove the last part since it's just the placeholder
    // e.g. `/categories/category 1/new-input` -> `/categories/category 1`
    const containerPath = path.replace(/\/[^/]+$/, "");
    if (containerPath) {
        const { targetCategory } = getCategoryFromPath(uiCategory, containerPath);
        targetCategory.categories.push({ title: newTitle, categories: [], count: 0, path: null });
    }
    else {
        /**
         * This means we're adding a root level category when there is no category yet
         *
         * Can happens when we first set up the category schema
         */
        uiCategory.categories.push({ title: newTitle, categories: [], count: 0, path: null });
    }
    return getCategorySchemaFromUICategory(uiCategory);
};
const getNewCategorySchemaFromDelete = (category, { path }) => {
    const uiCategory = structuredClone(category);
    const { targetIndex, parentCategory } = getCategoryFromPath(uiCategory, path);
    parentCategory === null || parentCategory === void 0 ? void 0 : parentCategory.categories.splice(targetIndex, 1);
    return getCategorySchemaFromUICategory(uiCategory);
};
// * --- Utils
// Path we want to remove the base path since we count root as 0th level then also remove the beginning `/` to avoid empty string
const getPathLength = (path) => { var _a; return (_a = path === null || path === void 0 ? void 0 : path.replace(_categories_ca134005_js__WEBPACK_IMPORTED_MODULE_0__.C, "").slice(1).split("/").length) !== null && _a !== void 0 ? _a : 0; };
/**
 * Get the category from schema based on the path
 */
const getCategoryFromPath = (uiCategory, path) => {
    if (path == null || path === _categories_ca134005_js__WEBPACK_IMPORTED_MODULE_0__.C) {
        // Root level
        return { targetCategory: uiCategory, targetIndex: 1, parentCategory: null };
    }
    // Path starts with `/` so remove it
    const pathParts = path.slice(1).split("/");
    let curPath = path.indexOf(_categories_ca134005_js__WEBPACK_IMPORTED_MODULE_0__.C) === 0 ? (0,_categories_ca134005_js__WEBPACK_IMPORTED_MODULE_0__.a)("", { title: pathParts.shift() }) : "";
    let parentCategory = null;
    let targetCategory = uiCategory;
    let targetIndex = 0;
    do {
        curPath = (0,_categories_ca134005_js__WEBPACK_IMPORTED_MODULE_0__.a)(curPath, { title: pathParts.shift() });
        parentCategory = targetCategory;
        targetIndex = targetCategory.categories.findIndex((subcategory) => subcategory.path === curPath);
        targetCategory = targetCategory.categories[targetIndex];
    } while (pathParts.length > 0 && targetCategory.categories.length);
    return { targetCategory, targetIndex, parentCategory };
};
/**
 * Create a nested category schema from the aggregated search result starting from root
 */
const getUICategoryFromCategorySchema = (categorySchema, categoryAggregationData) => {
    var _a, _b;
    return ({
        title: "",
        path: null,
        count: (_b = (_a = categoryAggregationData.fieldValues.find((fieldValue) => fieldValue.value === _categories_ca134005_js__WEBPACK_IMPORTED_MODULE_0__.C)) === null || _a === void 0 ? void 0 : _a.count) !== null && _b !== void 0 ? _b : 0,
        categories: getUICategoryFromCategorySchemaRecursive(null, categorySchema, categoryAggregationData)
    });
};
const getCategorySchemaFromUICategory = (uiCategory) => uiCategory.categories.map(getCategoryFromUICategory);
const getCategoryFromUICategory = (uiCategory) => ({
    title: uiCategory.title,
    categories: uiCategory.categories.map(getCategoryFromUICategory)
});
const getUICategoryFromCategorySchemaRecursive = (parentPath, categorySchema, categoryAggregationData) => {
    return categorySchema.map((category) => {
        var _a, _b;
        const path = (0,_categories_ca134005_js__WEBPACK_IMPORTED_MODULE_0__.a)(parentPath !== null && parentPath !== void 0 ? parentPath : _categories_ca134005_js__WEBPACK_IMPORTED_MODULE_0__.C, category);
        const categoryCount = (_a = categoryAggregationData.fieldValues.find((fieldValue) => fieldValue.value === path)) === null || _a === void 0 ? void 0 : _a.count;
        const subcategories = getUICategoryFromCategorySchemaRecursive(path, (_b = category.categories) !== null && _b !== void 0 ? _b : [], categoryAggregationData);
        return {
            title: category.title,
            path,
            count: categoryCount !== null && categoryCount !== void 0 ? categoryCount : 0,
            categories: subcategories
        };
    });
};
const countNumCategories = (categorySchema) => {
    // + 1 is itself
    return categorySchema.reduce((acc, cur) => { var _a; return acc + 1 + countNumCategories((_a = cur.categories) !== null && _a !== void 0 ? _a : []); }, 0);
};
const checkNewCategoryTitleValid = ({ targetCategory, targetParentCategory }) => {
    var _a;
    const categoryLowerCaseTitle = (_a = targetCategory.title.toLocaleLowerCase()) === null || _a === void 0 ? void 0 : _a.trim();
    if (!categoryLowerCaseTitle) {
        return "emptyTitle";
    }
    if (categoryLowerCaseTitle.length > MAX_CATEGORY_NAME_LENGTH) {
        return "maxCharacter";
    }
    // No duplicate category name on the same level
    if (targetParentCategory.categories.some((category) => category.title.toLowerCase() === categoryLowerCaseTitle && category.path !== targetCategory.path)) {
        return "destinationHasSameName";
    }
    return null;
};
const MAX_CATEGORY_NAME_LENGTH = 100;



//# sourceMappingURL=util-2a0e2f08.js.map

/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid2lkZ2V0cy9jaHVua3MvYXJjZ2lzX2FuYWx5c2lzX25vZGVfbW9kdWxlc19hcmNnaXNfYXBwLWNvbXBvbmVudHNfZGlzdF9lc21fYXJjZ2lzLWMxMzc1Ny5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDNEg7QUFDakU7QUFDTztBQUNWO0FBQ0E7O0FBRXhEOztBQUVBLDBGQUEwRixxQkFBcUIsZUFBZSxrQkFBa0Isc0JBQXNCLDBCQUEwQix5QkFBeUIsb0RBQW9ELHlEQUF5RCxnQkFBZ0IsaUJBQWlCLGlCQUFpQixrQkFBa0IsaUJBQWlCLDJEQUEyRCxhQUFhLDBHQUEwRyxhQUFhOztBQUUxbEI7QUFDQTtBQUNBLFFBQVEscURBQWdCO0FBQ3hCLHFEQUFxRCxxREFBVztBQUNoRSxnQ0FBZ0MscURBQVc7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsK01BQStNO0FBQ25PO0FBQ0E7QUFDQSxvQkFBb0IscURBQUMsU0FBUztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiwrQ0FBK0M7QUFDaEU7QUFDQSx3QkFBd0IscURBQUMsU0FBUyxtQkFBbUIsRUFBRSxxREFBQyxvQ0FBb0MsMFVBQTBVO0FBQ3RhLGFBQWEsR0FBRyxxREFBQyx3Q0FBd0M7QUFDekQ7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsMEJBQTBCLDBEQUFpQixTQUFTLHVCQUF1QjtBQUMzRTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLDZDQUE2QyxHQUFHLHFEQUFDLHFCQUFxQjtBQUN2RjtBQUNBLG1CQUFtQixHQUFHLHFEQUFDLHNCQUFzQiw2Q0FBNkMsRUFBRSxxREFBQztBQUM3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELG9EQUFhO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksd0RBQVE7QUFDcEI7QUFDQTtBQUNBLHdCQUF3Qix1Q0FBdUM7QUFDL0Q7QUFDQTtBQUNBLHdCQUF3QixxQ0FBcUM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixvS0FBb0s7QUFDcEw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IscURBQUMsQ0FBQyxpREFBSSxvQkFBb0IscURBQUMsd0NBQXdDLGlLQUFpSyx5Q0FBeUM7QUFDN1I7QUFDQTtBQUNBLGFBQWEsaUlBQWlJO0FBQzlJO0FBQ0EsZUFBZSxPQUFPLHFEQUFVO0FBQ2hDLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDZFQUE2RSxhQUFhLG1CQUFtQixtREFBbUQsY0FBYyxzQkFBc0IsNENBQTRDLG9CQUFvQixxQkFBcUIsaURBQWlELG1CQUFtQixXQUFXLHdDQUF3QyxhQUFhLG1CQUFtQix1QkFBdUIsWUFBWSxhQUFhLGdEQUFnRCxZQUFZLGdEQUFnRCxtQkFBbUIsb0JBQW9CLHFCQUFxQixvQkFBb0IsdUJBQXVCLHFEQUFxRCw0REFBNEQsNkNBQTZDLGFBQWE7O0FBRTkxQjtBQUNBO0FBQ0EsUUFBUSxxREFBZ0I7QUFDeEIscURBQXFELHFEQUFXO0FBQ2hFLHFEQUFxRCxxREFBVztBQUNoRSxxREFBcUQscURBQVc7QUFDaEU7QUFDQSxvQkFBb0IsdURBQXVEO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHVGQUF1RjtBQUMzRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixlQUFlO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHlDQUF5QztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiwwREFBTztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsK0xBQStMO0FBQy9NO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixxQkFBcUIsRUFBRSxZQUFZLE1BQU0sUUFBUTtBQUNsRTtBQUNBO0FBQ0EsZ0JBQWdCLHFEQUFDLENBQUMsaURBQUksUUFBUSxxREFBQyxVQUFVLDRDQUE0QyxtQ0FBbUMscURBQUMscUJBQXFCLDhHQUE4RyxzQkFBc0IscURBQUMsQ0FBQyxpREFBUSxRQUFRLHFEQUFDLHFCQUFxQix3R0FBd0csMkJBQTJCLHdJQUF3SSxHQUFHLHFEQUFDLHNCQUFzQixnREFBZ0QsRUFBRSxxREFBQyxVQUFVLHNCQUFzQix1RkFBdUYscURBQUMsOEJBQThCO0FBQ3h5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsK0ZBQStGLEVBQUUscURBQUMsb0JBQW9CLDhKQUE4SixPQUFPLHFEQUFDLENBQUMsaURBQVEsUUFBUSxxREFBQyxVQUFVLDBEQUEwRCxnQkFBZ0IscURBQUMscUJBQXFCLDROQUE0TixHQUFHLHFEQUFDLHNCQUFzQix3Q0FBd0MsRUFBRSxxREFBQyxVQUFVLHNCQUFzQixvQ0FBb0MscURBQUMsQ0FBQyxpREFBUSxRQUFRLHFEQUFDLHFCQUFxQjtBQUNyeUI7QUFDQTtBQUNBLGFBQWEsK0VBQStFLEdBQUcscURBQUMsc0JBQXNCLHdDQUF3QyxFQUFFLHFEQUFDLFVBQVUsc0JBQXNCO0FBQ2pNO0FBQ0EsZUFBZSxPQUFPLHFEQUFVO0FBQ2hDO0FBQ0E7O0FBRTJJOztBQUUzSTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUMxUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsU0FBUyxFQUFFLGtDQUFrQyxFQUFFLGdFQUFnRTtBQUM3SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGNBQWM7QUFDMUM7QUFDQTtBQUNBOztBQUVvSDs7QUFFcEg7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQSxpQ0FBaUMsc0JBQXNCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksWUFBWTtBQUN4QjtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLFdBQVcsWUFBWTtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFaU07O0FBRWpNOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUMvSUE7QUFDQTtBQUNBO0FBQ0E7QUFDMkY7O0FBRTNGO0FBQ0Esa0RBQWtELGdCQUFnQixnQkFBZ0IsZ0JBQWdCLGNBQWMsc0JBQXNCO0FBQ3RJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsZ0JBQWdCO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsZ0JBQWdCO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsaUJBQWlCO0FBQ2pDLHlDQUF5Qyx1REFBdUQ7QUFDaEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsdURBQXVEO0FBQzVGO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxNQUFNO0FBQzFEO0FBQ0EsWUFBWSw4QkFBOEI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxRQUFRLHNFQUFzRSxzREFBa0I7QUFDbEk7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsc0RBQWtCO0FBQ25EO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixzREFBa0IsVUFBVSwwREFBaUIsT0FBTywwQkFBMEI7QUFDN0c7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsMERBQWlCLFlBQVksMEJBQTBCO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUdBQXlHLHNEQUFrQjtBQUMzSDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiwwREFBaUIsNkRBQTZELHNEQUFrQjtBQUNySDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxRQUFRLGlHQUFpRztBQUMxSjtBQUNBLHNDQUFzQyxzQ0FBc0M7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVtVjs7QUFFblYiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9leGItY2xpZW50Ly4vZXh0ZW5zaW9ucy93aWRnZXRzL2FyY2dpcy9hbmFseXNpcy9ub2RlX21vZHVsZXMvQGFyY2dpcy9hcHAtY29tcG9uZW50cy9kaXN0L2VzbS9hcmNnaXMtc2NoZW1hLWVkaXRvci1jYXRlZ29yeV8yLmVudHJ5LmpzIiwid2VicGFjazovL2V4Yi1jbGllbnQvLi9leHRlbnNpb25zL3dpZGdldHMvYXJjZ2lzL2FuYWx5c2lzL25vZGVfbW9kdWxlcy9AYXJjZ2lzL2FwcC1jb21wb25lbnRzL2Rpc3QvZXNtL2NhdGVnb3JpZXMtY2ExMzQwMDUuanMiLCJ3ZWJwYWNrOi8vZXhiLWNsaWVudC8uL2V4dGVuc2lvbnMvd2lkZ2V0cy9hcmNnaXMvYW5hbHlzaXMvbm9kZV9tb2R1bGVzL0BhcmNnaXMvYXBwLWNvbXBvbmVudHMvZGlzdC9lc20vZnVuY3Rpb25hbC00NGRlOGZjZi5qcyIsIndlYnBhY2s6Ly9leGItY2xpZW50Ly4vZXh0ZW5zaW9ucy93aWRnZXRzL2FyY2dpcy9hbmFseXNpcy9ub2RlX21vZHVsZXMvQGFyY2dpcy9hcHAtY29tcG9uZW50cy9kaXN0L2VzbS91dGlsLTJhMGUyZjA4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogQWxsIG1hdGVyaWFsIGNvcHlyaWdodCBFU1JJLCBBbGwgUmlnaHRzIFJlc2VydmVkLCB1bmxlc3Mgb3RoZXJ3aXNlIHNwZWNpZmllZC5cbiAqIHY0LjAuNThcbiAqL1xuaW1wb3J0IHsgciBhcyByZWdpc3Rlckluc3RhbmNlLCBjIGFzIGNyZWF0ZUV2ZW50LCBoLCBIIGFzIEhvc3QsIGQgYXMgZ2V0RWxlbWVudCwgRiBhcyBGcmFnbWVudCB9IGZyb20gJy4vaW5kZXgtZTNiZjdkYTcuanMnO1xuaW1wb3J0IHsgUyBhcyBTb3J0YWJsZSB9IGZyb20gJy4vc29ydGFibGUuZXNtLTdlNzg1NzgwLmpzJztcbmltcG9ydCB7IGEgYXMgZ2V0Q2F0ZWdvcnlVSVBhdGggfSBmcm9tICcuL2NhdGVnb3JpZXMtY2ExMzQwMDUuanMnO1xuaW1wb3J0IHsgZiBhcyBnZXRQYXRoTGVuZ3RoIH0gZnJvbSAnLi91dGlsLTJhMGUyZjA4LmpzJztcbmltcG9ydCB7IHQgYXMgdGltZW91dCB9IGZyb20gJy4vZnVuY3Rpb25hbC00NGRlOGZjZi5qcyc7XG5cbmNvbnN0IEFSQ0dJU19TQ0hFTUFfRURJVE9SX0RSQUdfSEFORExFX0NMQVNTID0gXCJhcmNnaXMtc2NoZW1hLWVkaXRvci1jYXRlZ29yeS1yb3dfX2RyYWctaGFuZGxlXCI7XG5cbmNvbnN0IGFyY2dpc1NjaGVtYUVkaXRvckNhdGVnb3J5Q3NzID0gXCIuYXJjZ2lzLXNjaGVtYS1lZGl0b3ItY2F0ZWdvcnlfX2NhdGVnb3J5LWNvbnRhaW5lcntsaXN0LXN0eWxlLXR5cGU6bm9uZTttYXJnaW4tdG9wOjBweDttYXJnaW4tYm90dG9tOjBweDttYXJnaW4tYm90dG9tOjAuMjVyZW07cGFkZGluZy1pbmxpbmUtc3RhcnQ6MXJlbTttYXJnaW4taW5saW5lLXN0YXJ0OjFyZW07Ym9yZGVyLWxlZnQ6MXB4IHNvbGlkIHZhcigtLWNhbGNpdGUtY29sb3ItYm9yZGVyLTIpfS5hcmNnaXMtc2NoZW1hLWVkaXRvci1jYXRlZ29yeV9fY2F0ZWdvcnktY29udGFpbmVyLS1yb290e21hcmdpbi1sZWZ0OjBweDttYXJnaW4tcmlnaHQ6MHB4O3BhZGRpbmctbGVmdDowcHg7cGFkZGluZy1yaWdodDowcHg7Ym9yZGVyLXdpZHRoOjBweH0uYXJjZ2lzLXNjaGVtYS1lZGl0b3ItY2F0ZWdvcnlfX2NhdGVnb3J5LWNvbnRhaW5lcl9faGlkZGVue2Rpc3BsYXk6bm9uZX0uYXJjZ2lzLXNjaGVtYS1lZGl0b3ItY2F0ZWdvcnlfX2FkZC1jYXRlZ29yeS1idG4tLWhpZGUsLmFyY2dpcy1zY2hlbWEtZWRpdG9yLWNhdGVnb3J5X19uZXctY2F0ZWdvcnktLWhpZGV7ZGlzcGxheTpub25lfVwiO1xuXG5jb25zdCBBcmNnaXNTY2hlbWFFZGl0b3JDYXRlZ29yeSA9IGNsYXNzIHtcbiAgICBjb25zdHJ1Y3Rvcihob3N0UmVmKSB7XG4gICAgICAgIHJlZ2lzdGVySW5zdGFuY2UodGhpcywgaG9zdFJlZik7XG4gICAgICAgIHRoaXMuYXJjZ2lzU2NoZW1hRWRpdG9ySW50ZXJuYWxEZWxldGVDbGljayA9IGNyZWF0ZUV2ZW50KHRoaXMsIFwiYXJjZ2lzU2NoZW1hRWRpdG9ySW50ZXJuYWxEZWxldGVDbGlja1wiLCA3KTtcbiAgICAgICAgdGhpcy5saXN0T3JkZXJDaGFuZ2VkID0gY3JlYXRlRXZlbnQodGhpcywgXCJsaXN0T3JkZXJDaGFuZ2VkXCIsIDcpO1xuICAgICAgICB0aGlzLml0ZW1SZWZzID0ge307XG4gICAgICAgIHRoaXMuaXNNYXhEZXB0aCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmlzUm9vdCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnJlbmRlckNhdGVnb3J5Q29udGFpbmVyID0gKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBjYXRlZ29yeSwgY2FuQWRkQ2F0ZWdvcnksIGlzUm9vdCwgaXNDb2xsYXBzZWQsIGlzQWRkaW5nQ2F0ZWdvcnksIGlzQmVpbmdEcmFnZ2VkLCBjYW5FZGl0Q2F0ZWdvcnksIHNhdmVOZXdUaXRsZSwgc2F2ZU5ld0NhdGVnb3J5LCBtYXhEZXB0aCwgaTE4biwgaXNNb3ZlVmFsaWQsIGNhbkRlbGV0ZUNhdGVnb3J5LCBuZXdDYXRlZ29yeU1vZGUsIGlzTWF4RGVwdGggfSA9IHRoaXM7XG4gICAgICAgICAgICBjb25zdCBwYXRoID0gY2F0ZWdvcnkucGF0aDtcbiAgICAgICAgICAgIGNvbnN0IGhpZGVTdWJjYXRlZ29yaWVzID0gaXNDb2xsYXBzZWQgfHwgaXNCZWluZ0RyYWdnZWQ7XG4gICAgICAgICAgICByZXR1cm4gKGgoXCJ1bFwiLCB7IGNsYXNzOiB7XG4gICAgICAgICAgICAgICAgICAgIFwiYXJjZ2lzLXNjaGVtYS1lZGl0b3ItY2F0ZWdvcnlfX2NhdGVnb3J5LWNvbnRhaW5lclwiOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAvLyBVc2UgY3NzIHRvIGhpZGUgc28gaXQgZG9lc24ndCBmbGlja2VyIHdoZW4gZXhwYW5kaW5nXG4gICAgICAgICAgICAgICAgICAgIFwiYXJjZ2lzLXNjaGVtYS1lZGl0b3ItY2F0ZWdvcnlfX2NhdGVnb3J5LWNvbnRhaW5lcl9faGlkZGVuXCI6IGhpZGVTdWJjYXRlZ29yaWVzLFxuICAgICAgICAgICAgICAgICAgICBcImFyY2dpcy1zY2hlbWEtZWRpdG9yLWNhdGVnb3J5X19jYXRlZ29yeS1jb250YWluZXItLXJvb3RcIjogaXNSb290XG4gICAgICAgICAgICAgICAgfSwgcmVmOiAoZWxlKSA9PiAodGhpcy5kcmFnQ29udGFpbmVyUmVmID0gZWxlKSB9LCBjYXRlZ29yeS5jYXRlZ29yaWVzLm1hcCgoc3ViY2F0ZWdvcnkpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBjYXRlZ29yeVBhdGggPSBzdWJjYXRlZ29yeS5wYXRoO1xuICAgICAgICAgICAgICAgIHJldHVybiAoaChcImxpXCIsIHsga2V5OiBjYXRlZ29yeVBhdGggfSwgaChcImFyY2dpcy1zY2hlbWEtZWRpdG9yLWNhdGVnb3J5XCIsIHsgY2F0ZWdvcnk6IHN1YmNhdGVnb3J5LCBuZXdDYXRlZ29yeU1vZGU6IG5ld0NhdGVnb3J5TW9kZSwgY2FuQWRkQ2F0ZWdvcnk6IGNhbkFkZENhdGVnb3J5LCBjYW5EZWxldGVDYXRlZ29yeTogY2FuRGVsZXRlQ2F0ZWdvcnksIGNhbkVkaXRDYXRlZ29yeTogY2FuRWRpdENhdGVnb3J5LCBpMThuOiBpMThuLCBtYXhEZXB0aDogbWF4RGVwdGgsIGlzTW92ZVZhbGlkOiBpc01vdmVWYWxpZCwgc2F2ZU5ld1RpdGxlOiBzYXZlTmV3VGl0bGUsIHNhdmVOZXdDYXRlZ29yeTogc2F2ZU5ld0NhdGVnb3J5LCByZWY6IChlbCkgPT4gKHRoaXMuaXRlbVJlZnNbY2F0ZWdvcnlQYXRoXSA9IGVsKSB9KSkpO1xuICAgICAgICAgICAgfSksIGgoXCJhcmNnaXMtc2NoZW1hLWVkaXRvci1jYXRlZ29yeS1yb3dcIiwgeyBjbGFzczoge1xuICAgICAgICAgICAgICAgICAgICAvLyBDYW4ndCBqdXN0IG5vdCByZW5kZXIgdG8gcHJldmVudCBmbGlja2VyIGFuaW1hdGlvblxuICAgICAgICAgICAgICAgICAgICBcImFyY2dpcy1zY2hlbWEtZWRpdG9yLWNhdGVnb3J5X19uZXctY2F0ZWdvcnktLWhpZGVcIjogIWlzQWRkaW5nQ2F0ZWdvcnlcbiAgICAgICAgICAgICAgICB9LCBjYXRlZ29yeToge1xuICAgICAgICAgICAgICAgICAgICBjYXRlZ29yaWVzOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgY291bnQ6IDAsXG4gICAgICAgICAgICAgICAgICAgIHBhdGg6IGdldENhdGVnb3J5VUlQYXRoKHBhdGgsIHsgdGl0bGU6IFwibmV3LWNhdGVnb3J5XCIgfSksXG4gICAgICAgICAgICAgICAgICAgIHRpdGxlOiBcIlwiXG4gICAgICAgICAgICAgICAgfSwgaXNDb2xsYXBzaWJsZTogZmFsc2UsIGlzQ29sbGFwc2VkOiB0cnVlLCBpc05ld0NhdGVnb3J5OiB0cnVlLCBjYW5EZWxldGVDYXRlZ29yeTogZmFsc2UsIGNhbkVkaXRDYXRlZ29yeTogKCkgPT4gdHJ1ZSwgaTE4bjogaTE4biwgb25BcmNnaXNTY2hlbWFFZGl0b3JJbnRlcm5hbENhbmNlbENsaWNrOiAoKSA9PiAodGhpcy5pc0FkZGluZ0NhdGVnb3J5ID0gZmFsc2UpLCBzYXZlTmV3VGl0bGU6IGFzeW5jIChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkb1NhdmUgPSBhd2FpdCBzYXZlTmV3Q2F0ZWdvcnkoZXZlbnQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZG9TYXZlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmlzQWRkaW5nQ2F0ZWdvcnkgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZG9TYXZlO1xuICAgICAgICAgICAgICAgIH0sIHJlZjogKGVsZSkgPT4gKHRoaXMubmV3Q2F0ZWdvcnlSZWYgPSBlbGUpIH0pLCBoKFwiY2FsY2l0ZS1idXR0b25cIiwgeyBhcHBlYXJhbmNlOiBcInRyYW5zcGFyZW50XCIsIGtpbmQ6IFwibmV1dHJhbFwiLCBvbkNsaWNrOiAoKSA9PiAodGhpcy5pc0FkZGluZ0NhdGVnb3J5ID0gdHJ1ZSksIGljb25TdGFydDogXCJwbHVzLWNpcmNsZVwiLCByZWY6IChlbCkgPT4gKHRoaXMuYWRkQ2F0ZWdvcnlCdXR0b25SZWYgPSBlbCksIGNsYXNzOiB7XG4gICAgICAgICAgICAgICAgICAgIFwiYXJjZ2lzLXNjaGVtYS1lZGl0b3ItY2F0ZWdvcnlfX2FkZC1jYXRlZ29yeS1idG4tLWhpZGVcIjogaXNBZGRpbmdDYXRlZ29yeSB8fCBpc01heERlcHRoIHx8IGlzQmVpbmdEcmFnZ2VkIHx8ICFjYW5BZGRDYXRlZ29yeSB8fCBpc0NvbGxhcHNlZFxuICAgICAgICAgICAgICAgIH0gfSksIGgoXCJjYWxjaXRlLXRvb2x0aXBcIiwgeyByZWZlcmVuY2VFbGVtZW50OiB0aGlzLmFkZENhdGVnb3J5QnV0dG9uUmVmIH0sIGgoXCJkaXZcIiwgbnVsbCwgaXNSb290ID8gaTE4bi5jYXRlZ29yeUl0ZW0uYWRkQ2F0ZWdvcnkgOiBpMThuLmNhdGVnb3J5SXRlbS5hZGRTdWJjYXRlZ29yeSkpKSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuY2F0ZWdvcnkgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuY2FuQWRkQ2F0ZWdvcnkgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuY2FuRGVsZXRlQ2F0ZWdvcnkgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMubmV3Q2F0ZWdvcnlNb2RlID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLnNob3dJbnB1dEJ5RGVmYXVsdCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmNhbkVkaXRDYXRlZ29yeSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5tYXhEZXB0aCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5pMThuID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmlzTW92ZVZhbGlkID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLnNhdmVOZXdUaXRsZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5zYXZlTmV3Q2F0ZWdvcnkgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuaXNDb2xsYXBzZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pc0JlaW5nRHJhZ2dlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmlzQWRkaW5nQ2F0ZWdvcnkgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5hZGRDYXRlZ29yeUJ1dHRvblJlZiA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgY29tcG9uZW50V2lsbExvYWQoKSB7XG4gICAgICAgIGNvbnN0IHBhdGggPSB0aGlzLmNhdGVnb3J5LnBhdGg7XG4gICAgICAgIHRoaXMuaXNSb290ID0gcGF0aCA9PT0gbnVsbDtcbiAgICAgICAgdGhpcy5pc01heERlcHRoID0gdGhpcy5pc1Jvb3QgPyBmYWxzZSA6IGdldFBhdGhMZW5ndGgocGF0aCkgPiB0aGlzLm1heERlcHRoO1xuICAgICAgICB0aGlzLmlzQ29sbGFwc2VkID0gdGhpcy5uZXdDYXRlZ29yeU1vZGUgJiYgIXRoaXMuaXNSb290O1xuICAgIH1cbiAgICBjb21wb25lbnREaWRMb2FkKCkge1xuICAgICAgICAvLyBIYXZlIHRvIGRvIGl0IGhlcmUgc2luY2UgdGhpcyB3aWxsIHRyaWdnZXIgYEBXYXRjaChcImlzQWRkaW5nQ2F0ZWdvcnlcIikgYW5kIGByZXNldGAgZGVwZW5kcyBvbiBhIHJlZlxuICAgICAgICAvLyAgd2hpY2ggaXMgb25seSBhdmFpbGFibGUgYWZ0ZXIgdGhlIGZpcnN0IG1vdW50XG4gICAgICAgIHRoaXMub25TaG93SW5wdXRCeURlZmF1bHRDaGFuZ2UoKTtcbiAgICAgICAgbmV3IFNvcnRhYmxlKHRoaXMuZHJhZ0NvbnRhaW5lclJlZiwge1xuICAgICAgICAgICAgZ3JvdXA6IFwiYXJjZ2lzLXNjaGVtYS1lZGl0b3JcIixcbiAgICAgICAgICAgIGFuaW1hdGlvbjogMjAwLFxuICAgICAgICAgICAgaGFuZGxlOiBgLiR7QVJDR0lTX1NDSEVNQV9FRElUT1JfRFJBR19IQU5ETEVfQ0xBU1N9YCxcbiAgICAgICAgICAgIGNob3NlbkNsYXNzOiBcImFyY2dpcy1zY2hlbWEtZWRpdG9yLWNhdGVnb3J5LXJvdy0tZHJhZ2dpbmdcIixcbiAgICAgICAgICAgIG9uU29ydDogKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBmcm9tLCB0bywgb2xkSW5kZXgsIG5ld0luZGV4LCBpdGVtIH0gPSBldmVudDtcbiAgICAgICAgICAgICAgICBjb25zdCBmcm9tQ2F0ZWdvcnkgPSBmcm9tLmNsb3Nlc3QoXCJhcmNnaXMtc2NoZW1hLWVkaXRvci1jYXRlZ29yeVwiKS5jYXRlZ29yeTtcbiAgICAgICAgICAgICAgICBjb25zdCB0b0NhdGVnb3J5ID0gdG8uY2xvc2VzdChcImFyY2dpcy1zY2hlbWEtZWRpdG9yLWNhdGVnb3J5XCIpLmNhdGVnb3J5O1xuICAgICAgICAgICAgICAgIC8vIGBpdGVtYCBpcyB0aGUgZWxlbWVudCBiZWluZyBkcmFnZ2VkLCBub3QgdGhlIGNvbnRhaW5lciBzbyB3ZSBuZWVkIHRvIGxvb2sgZG93bndhcmQgaW5zdGVhZCBvZiB1cHdhcmRcbiAgICAgICAgICAgICAgICBjb25zdCBmcm9tSXRlbUNhdGVnb3J5ID0gaXRlbS5xdWVyeVNlbGVjdG9yKFwiYXJjZ2lzLXNjaGVtYS1lZGl0b3ItY2F0ZWdvcnlcIikuY2F0ZWdvcnk7XG4gICAgICAgICAgICAgICAgY29uc3QgcGF5bG9hZCA9IHtcbiAgICAgICAgICAgICAgICAgICAgZnJvbUNhdGVnb3J5LFxuICAgICAgICAgICAgICAgICAgICB0b0NhdGVnb3J5LFxuICAgICAgICAgICAgICAgICAgICBmcm9tSXRlbUNhdGVnb3J5LFxuICAgICAgICAgICAgICAgICAgICBmcm9tSW5kZXg6IG9sZEluZGV4LFxuICAgICAgICAgICAgICAgICAgICB0b0luZGV4OiBuZXdJbmRleFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgY29uc3QgaXNWYWxpZE1vdmUgPSB0aGlzLmlzTW92ZVZhbGlkID8gdGhpcy5pc01vdmVWYWxpZChwYXlsb2FkKSA6IHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKGlzVmFsaWRNb3ZlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIER1cGxpY2F0ZSBldmVudCBjYXNlLCBqdXN0IGlnbm9yZVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghaXNWYWxpZE1vdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gUmV2ZXJ0IHRoZSBtb3ZlXG4gICAgICAgICAgICAgICAgICAgIGZyb20uaW5zZXJ0QmVmb3JlKGl0ZW0sIGZyb20uY2hpbGRyZW5bb2xkSW5kZXggPiBuZXdJbmRleCA/IG9sZEluZGV4ICsgMSA6IG9sZEluZGV4XSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5saXN0T3JkZXJDaGFuZ2VkLmVtaXQocGF5bG9hZCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2V0RGF0YTogKGRhdGFUcmFuc2ZlcikgPT4ge1xuICAgICAgICAgICAgICAgIC8vICEgUmVxdWlyZWQgYnkgRmlyZWZveCBpbiBvcmRlciB0byBEbkQgd29yazogaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzE5MDU1MzUwLzE0MTExMDVcbiAgICAgICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vU29ydGFibGVKUy9Tb3J0YWJsZS9pc3N1ZXMvMTI2NyNpc3N1ZWNvbW1lbnQtNDk0NzU3ODYyXG4gICAgICAgICAgICAgICAgZGF0YVRyYW5zZmVyLnNldERhdGEoXCJmb29cIiwgXCJiYXJcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBvblNob3dJbnB1dEJ5RGVmYXVsdENoYW5nZSgpIHtcbiAgICAgICAgdGhpcy5pc0FkZGluZ0NhdGVnb3J5ID0gdGhpcy5uZXdDYXRlZ29yeU1vZGUgJiYgdGhpcy5pc1Jvb3QgJiYgdGhpcy5zaG93SW5wdXRCeURlZmF1bHQ7XG4gICAgfVxuICAgIG9uSXNBZGRpbmdDYXRlZ29yeUNoYW5nZSgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICAoX2EgPSB0aGlzLm5ld0NhdGVnb3J5UmVmKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVzZXQoKTtcbiAgICB9XG4gICAgYXN5bmMgZXhwYW5kT3JDb2xsYXBzZUFsbChjb2xsYXBzZUFsbCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNSb290KSB7XG4gICAgICAgICAgICB0aGlzLmlzQ29sbGFwc2VkID0gY29sbGFwc2VBbGw7XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LnZhbHVlcyh0aGlzLml0ZW1SZWZzKS5mb3JFYWNoKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAvLyBgP2AgYmVjYXVzZSB3aGVuIGNvbGxhcHNpbmcsIHRoZSBjaGlsZCB3aWxsIGJlIG51bGxcbiAgICAgICAgICAgIGl0ZW0gPT09IG51bGwgfHwgaXRlbSA9PT0gdm9pZCAwID8gdm9pZCAwIDogaXRlbS5leHBhbmRPckNvbGxhcHNlQWxsKGNvbGxhcHNlQWxsKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIHNldElzQmVpbmdEcmFnZ2VkKGlzQmVpbmdEcmFnZ2VkKSB7XG4gICAgICAgIGNvbnN0IGhhc0NoaWxkcmVuID0gdGhpcy5jYXRlZ29yeS5jYXRlZ29yaWVzLmxlbmd0aCA+IDA7XG4gICAgICAgIGlmIChoYXNDaGlsZHJlbikge1xuICAgICAgICAgICAgdGhpcy5pc0JlaW5nRHJhZ2dlZCA9IGlzQmVpbmdEcmFnZ2VkO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgY29uc3QgeyBjYXRlZ29yeSwgY2FuRGVsZXRlQ2F0ZWdvcnksIGNhbkVkaXRDYXRlZ29yeSwgaXNSb290LCBpc01heERlcHRoLCBpc0NvbGxhcHNlZCwgaTE4biwgcmVuZGVyQ2F0ZWdvcnlDb250YWluZXIsIHNhdmVOZXdUaXRsZSwgYXJjZ2lzU2NoZW1hRWRpdG9ySW50ZXJuYWxEZWxldGVDbGljayB9ID0gdGhpcztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEluIGNhc2Ugb2YgdGhlIHJvb3QsIHdlIGRvbid0IHJlYWxseSBoYXZlIGEgcm9vdCByb3dcbiAgICAgICAgICogIHNvIHdlIGp1c3QgcmVuZGVycyBhIGNhdGVnb3J5IGFuZCBpdHMgY2hpbGRyZW4sIGFwcHJvcHJpYXRlbHkgc3R5bGVkIGlmIG5lc3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgcmV0dXJuIChoKEhvc3QsIG51bGwsICFpc1Jvb3QgJiYgKGgoXCJhcmNnaXMtc2NoZW1hLWVkaXRvci1jYXRlZ29yeS1yb3dcIiwgeyBjYXRlZ29yeTogY2F0ZWdvcnksIGlzQ29sbGFwc2libGU6ICFpc01heERlcHRoLCBpc0NvbGxhcHNlZDogaXNDb2xsYXBzZWQsIGNhbkRlbGV0ZUNhdGVnb3J5OiBjYW5EZWxldGVDYXRlZ29yeSwgY2FuRWRpdENhdGVnb3J5OiAoY2F0ZWdvcnkpID0+IGNhbkVkaXRDYXRlZ29yeSh7IGNhdGVnb3J5LCBwYXJlbnRDYXRlZ29yeTogdGhpcy5jYXRlZ29yeSB9KSwgaTE4bjogaTE4biwgb25BcmNnaXNTY2hlbWFFZGl0b3JJbnRlcm5hbERlbGV0ZUNsaWNrOiAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICBhcmNnaXNTY2hlbWFFZGl0b3JJbnRlcm5hbERlbGV0ZUNsaWNrLmVtaXQoZXZlbnQuZGV0YWlsKTtcbiAgICAgICAgICAgIH0sIG9uQXJjZ2lzU2NoZW1hRWRpdG9ySW50ZXJuYWxFeHBhbmRDbGljazogKGV2ZW50KSA9PiAodGhpcy5pc0NvbGxhcHNlZCA9IGV2ZW50LmRldGFpbC5pc0NvbGxhcHNlZCksIHNhdmVOZXdUaXRsZTogc2F2ZU5ld1RpdGxlIH0pKSwgcmVuZGVyQ2F0ZWdvcnlDb250YWluZXIoKSkpO1xuICAgIH1cbiAgICBnZXQgZWwoKSB7IHJldHVybiBnZXRFbGVtZW50KHRoaXMpOyB9XG4gICAgc3RhdGljIGdldCB3YXRjaGVycygpIHsgcmV0dXJuIHtcbiAgICAgICAgXCJzaG93SW5wdXRCeURlZmF1bHRcIjogW1wib25TaG93SW5wdXRCeURlZmF1bHRDaGFuZ2VcIl0sXG4gICAgICAgIFwiaXNBZGRpbmdDYXRlZ29yeVwiOiBbXCJvbklzQWRkaW5nQ2F0ZWdvcnlDaGFuZ2VcIl1cbiAgICB9OyB9XG59O1xuQXJjZ2lzU2NoZW1hRWRpdG9yQ2F0ZWdvcnkuc3R5bGUgPSBhcmNnaXNTY2hlbWFFZGl0b3JDYXRlZ29yeUNzcztcblxuY29uc3QgYXJjZ2lzU2NoZW1hRWRpdG9yQ2F0ZWdvcnlSb3dDc3MgPSBcIi5hcmNnaXMtc2NoZW1hLWVkaXRvci1jYXRlZ29yeS1yb3d7ZGlzcGxheTpmbGV4O2FsaWduLWl0ZW1zOmNlbnRlcjtiYWNrZ3JvdW5kLWNvbG9yOnZhcigtLWNhbGNpdGUtY29sb3ItZm9yZWdyb3VuZC0xKTtoZWlnaHQ6Mi41cmVtO21hcmdpbi1ib3R0b206MC4yNXJlbX0uYXJjZ2lzLXNjaGVtYS1lZGl0b3ItY2F0ZWdvcnktcm93LS1lZGl0aW5ne3BhZGRpbmctbGVmdDowLjVyZW07cGFkZGluZy1yaWdodDowLjVyZW19LmFyY2dpcy1zY2hlbWEtZWRpdG9yLWNhdGVnb3J5LXJvd19faW5saW5lLWlucHV0e2ZvbnQtc2l6ZTowLjg3NXJlbTt3aWR0aDoxMDAlfS5hcmNnaXMtc2NoZW1hLWVkaXRvci1jYXRlZ29yeS1yb3dfX2N0YXtkaXNwbGF5OmZsZXg7YWxpZ24taXRlbXM6Y2VudGVyO2p1c3RpZnktY29udGVudDpjZW50ZXI7aGVpZ2h0OjEwMCU7d2lkdGg6Mi41cmVtfS5hcmNnaXMtc2NoZW1hLWVkaXRvci1jYXRlZ29yeS1yb3dfX2RyYWctaGFuZGxle2hlaWdodDoxMDAlfS5hcmNnaXMtc2NoZW1hLWVkaXRvci1jYXRlZ29yeS1yb3dfX2J0bi1wb3BvdmVye3doaXRlLXNwYWNlOm5vd3JhcDtwYWRkaW5nLWxlZnQ6MC41cmVtO3BhZGRpbmctcmlnaHQ6MC41cmVtO3BhZGRpbmctdG9wOjAuMjVyZW07cGFkZGluZy1ib3R0b206MC4yNXJlbX0uYXJjZ2lzLXNjaGVtYS1lZGl0b3ItY2F0ZWdvcnktcm93X19jYW50LWVkaXQtcmVhc29uey0tY2FsY2l0ZS11aS1pY29uLWNvbG9yOnZhcigtLWNhbGNpdGUtY29sb3Itc3RhdHVzLXdhcm5pbmcpfS5hcmNnaXMtc2NoZW1hLWVkaXRvci1jYXRlZ29yeS1yb3ctLWRyYWdnaW5ne29wYWNpdHk6MC4yNX1cIjtcblxuY29uc3QgQXJjZ2lzU2NoZW1hRWRpdG9yQ2F0ZWdvcnlSb3cgPSBjbGFzcyB7XG4gICAgY29uc3RydWN0b3IoaG9zdFJlZikge1xuICAgICAgICByZWdpc3Rlckluc3RhbmNlKHRoaXMsIGhvc3RSZWYpO1xuICAgICAgICB0aGlzLmFyY2dpc1NjaGVtYUVkaXRvckludGVybmFsRGVsZXRlQ2xpY2sgPSBjcmVhdGVFdmVudCh0aGlzLCBcImFyY2dpc1NjaGVtYUVkaXRvckludGVybmFsRGVsZXRlQ2xpY2tcIiwgNyk7XG4gICAgICAgIHRoaXMuYXJjZ2lzU2NoZW1hRWRpdG9ySW50ZXJuYWxFeHBhbmRDbGljayA9IGNyZWF0ZUV2ZW50KHRoaXMsIFwiYXJjZ2lzU2NoZW1hRWRpdG9ySW50ZXJuYWxFeHBhbmRDbGlja1wiLCA3KTtcbiAgICAgICAgdGhpcy5hcmNnaXNTY2hlbWFFZGl0b3JJbnRlcm5hbENhbmNlbENsaWNrID0gY3JlYXRlRXZlbnQodGhpcywgXCJhcmNnaXNTY2hlbWFFZGl0b3JJbnRlcm5hbENhbmNlbENsaWNrXCIsIDcpO1xuICAgICAgICB0aGlzLm9uQ2FuY2VsRWRpdCA9ICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgYXJjZ2lzU2NoZW1hRWRpdG9ySW50ZXJuYWxDYW5jZWxDbGljaywgaXNOZXdDYXRlZ29yeSB9ID0gdGhpcztcbiAgICAgICAgICAgIGlmICghaXNOZXdDYXRlZ29yeSkge1xuICAgICAgICAgICAgICAgIHRoaXMuaXNFZGl0aW5nID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmVkaXRlZENhdGVnb3J5VGl0bGUgPSB0aGlzLmNhdGVnb3J5LnRpdGxlO1xuICAgICAgICAgICAgYXJjZ2lzU2NoZW1hRWRpdG9ySW50ZXJuYWxDYW5jZWxDbGljay5lbWl0KCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMub25TYXZlRWRpdCA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgY2F0ZWdvcnksIGVkaXRJbnB1dFJlZiwgZWRpdGVkQ2F0ZWdvcnlUaXRsZSwgc2F2ZU5ld1RpdGxlLCBzZXRJbnZhbGlkLCBpc05ld0NhdGVnb3J5IH0gPSB0aGlzO1xuICAgICAgICAgICAgaWYgKCFlZGl0ZWRDYXRlZ29yeVRpdGxlKSB7XG4gICAgICAgICAgICAgICAgc2V0SW52YWxpZCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlZGl0ZWRDYXRlZ29yeVRpdGxlID09PSBjYXRlZ29yeS50aXRsZSAmJiAhaXNOZXdDYXRlZ29yeSkge1xuICAgICAgICAgICAgICAgIHRoaXMuaXNFZGl0aW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlZGl0SW5wdXRSZWYuc3RhdHVzID0gXCJpZGxlXCI7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNhdmVSZXN1bHQgPSBhd2FpdCBzYXZlTmV3VGl0bGUoe1xuICAgICAgICAgICAgICAgICAgICBuZXdUaXRsZTogZWRpdGVkQ2F0ZWdvcnlUaXRsZSxcbiAgICAgICAgICAgICAgICAgICAgcGF0aDogY2F0ZWdvcnkucGF0aCxcbiAgICAgICAgICAgICAgICAgICAgY2F0ZWdvcnlDb3VudDogY2F0ZWdvcnkuY291bnRcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAoIXNhdmVSZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0SW52YWxpZCgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghaXNOZXdDYXRlZ29yeSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmlzRWRpdGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGlmICghaXNOZXdDYXRlZ29yeSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmlzRWRpdGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuc2V0SW52YWxpZCA9ICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgZWRpdElucHV0UmVmIH0gPSB0aGlzO1xuICAgICAgICAgICAgZWRpdElucHV0UmVmLnN0YXR1cyA9IFwiaW52YWxpZFwiO1xuICAgICAgICAgICAgZWRpdElucHV0UmVmLnNldEZvY3VzKCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuY2F0ZWdvcnkgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuaTE4biA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5pc05ld0NhdGVnb3J5ID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY2FuRWRpdENhdGVnb3J5ID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmNhbkRlbGV0ZUNhdGVnb3J5ID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmlzQ29sbGFwc2libGUgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuaXNDb2xsYXBzZWQgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuc2F2ZU5ld1RpdGxlID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmlzRWRpdGluZyA9IHRoaXMuaXNOZXdDYXRlZ29yeTtcbiAgICAgICAgdGhpcy5lZGl0ZWRDYXRlZ29yeVRpdGxlID0gdGhpcy5jYXRlZ29yeS50aXRsZTtcbiAgICAgICAgdGhpcy5leHBhbmRDb2xsYXBzZUJ1dHRvblJlZiA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5kZWxldGVCdXR0b25SZWYgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuZWRpdElucHV0UmVmID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmNhbnRFZGl0SWNvblJlZiA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgYXN5bmMgcmVzZXQoKSB7XG4gICAgICAgIGNvbnN0IHsgaXNOZXdDYXRlZ29yeSwgY2F0ZWdvcnksIGNhbkVkaXRSZWFzb24gfSA9IHRoaXM7XG4gICAgICAgIGlmIChpc05ld0NhdGVnb3J5ICYmIGNhbkVkaXRSZWFzb24gPT09IHRydWUpIHtcbiAgICAgICAgICAgIHRoaXMuZWRpdGVkQ2F0ZWdvcnlUaXRsZSA9IGNhdGVnb3J5LnRpdGxlO1xuICAgICAgICAgICAgdGhpcy5lZGl0SW5wdXRSZWYuc3RhdHVzID0gXCJpZGxlXCI7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqICEgVGhpcyBpcyB0byBoYW5kbGUgdGhlIGVkZ2UgY2FzZSB3aGVyZSB0aGUgYHhgIGN0YSBpcyBjbGlja2VkXG4gICAgICAgICAgICAgKiAgd2hpY2ggY2MtaW5saW5lLWVkaXRhYmxlIHdpbGwgYXV0b21hdGljYWxseSBnbyBvdXQgb2YgdGhlIGVkaXQgbW9kZVxuICAgICAgICAgICAgICogSG93ZXZlciwgd2UgZG9uJ3Qgd2FudCB0aGF0IGluIGBpc05ld0NhdGVnb3J5YCBtb2RlIHNvIHdlIG5lZWQgdG8gc2V0IGl0IGJhY2sgdG8gdHJ1ZVxuICAgICAgICAgICAgICogIGFmdGVyIGEgYml0IHRvIHRyaWdnZXIgdGhlIHJlLXJlbmRlclxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLmlzRWRpdGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgYXdhaXQgdGltZW91dCg1MCk7XG4gICAgICAgICAgICB0aGlzLmlzRWRpdGluZyA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmVkaXRJbnB1dFJlZi5zZXRGb2N1cygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIHNldEZvY3VzKCkge1xuICAgICAgICB0aGlzLmVkaXRJbnB1dFJlZi5zZXRGb2N1cygpO1xuICAgIH1cbiAgICBjb21wb25lbnRXaWxsTG9hZCgpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgdGhpcy5jYW5FZGl0UmVhc29uID0gKF9iID0gKF9hID0gdGhpcy5jYW5FZGl0Q2F0ZWdvcnkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHRoaXMsIHRoaXMuY2F0ZWdvcnkpKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiB0cnVlO1xuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGNvbnN0IHsgY2F0ZWdvcnksIGlzQ29sbGFwc2VkLCBpc0VkaXRpbmcsIGlzQ29sbGFwc2libGUsIGNhbkRlbGV0ZUNhdGVnb3J5LCBjYW5FZGl0UmVhc29uLCBpMThuLCBlZGl0ZWRDYXRlZ29yeVRpdGxlLCBvbkNhbmNlbEVkaXQsIG9uU2F2ZUVkaXQsIGFyY2dpc1NjaGVtYUVkaXRvckludGVybmFsRXhwYW5kQ2xpY2ssIGlzTmV3Q2F0ZWdvcnkgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IGNvdW50ID0gY2F0ZWdvcnkuY291bnQ7XG4gICAgICAgIGNvbnN0IHRleHRDb250ZW50ID0gaXNFZGl0aW5nXG4gICAgICAgICAgICA/IGVkaXRlZENhdGVnb3J5VGl0bGVcbiAgICAgICAgICAgIDogYCR7ZWRpdGVkQ2F0ZWdvcnlUaXRsZX0gJHtjb3VudCA/IGAoJHtjb3VudH0pYCA6IFwiXCJ9YDtcbiAgICAgICAgY29uc3Qgc2hvd0VkaXQgPSBjYW5FZGl0UmVhc29uID09PSB0cnVlO1xuICAgICAgICBjb25zdCBzaG93RGVsZXRlID0gc2hvd0VkaXQgJiYgIWlzRWRpdGluZyAmJiAhaXNOZXdDYXRlZ29yeSAmJiBjYW5EZWxldGVDYXRlZ29yeTtcbiAgICAgICAgcmV0dXJuIChoKEhvc3QsIG51bGwsIGgoXCJkaXZcIiwgeyBjbGFzczogXCJhcmNnaXMtc2NoZW1hLWVkaXRvci1jYXRlZ29yeS1yb3dcIiB9LCAhaXNOZXdDYXRlZ29yeSAmJiAhaXNFZGl0aW5nICYmIChoKFwiY2FsY2l0ZS1idXR0b25cIiwgeyBhcHBlYXJhbmNlOiBcInRyYW5zcGFyZW50XCIsIGtpbmQ6IFwibmV1dHJhbFwiLCBpY29uU3RhcnQ6IFwiZHJhZ1wiLCBjbGFzczogQVJDR0lTX1NDSEVNQV9FRElUT1JfRFJBR19IQU5ETEVfQ0xBU1MgfSkpLCBpc0NvbGxhcHNpYmxlICYmIChoKEZyYWdtZW50LCBudWxsLCBoKFwiY2FsY2l0ZS1idXR0b25cIiwgeyBhcHBlYXJhbmNlOiBcInRyYW5zcGFyZW50XCIsIGtpbmQ6IFwibmV1dHJhbFwiLCBvbkNsaWNrOiAoKSA9PiBhcmNnaXNTY2hlbWFFZGl0b3JJbnRlcm5hbEV4cGFuZENsaWNrLmVtaXQoeyBpc0NvbGxhcHNlZDogIWlzQ29sbGFwc2VkIH0pLCBpY29uU3RhcnQ6IGlzQ29sbGFwc2VkIHx8IGlzRWRpdGluZyA/IFwiY2hldnJvbi11cFwiIDogXCJjaGV2cm9uLWRvd25cIiwgY2xhc3M6IFwiY3RhXCIsIHJlZjogKGVsKSA9PiAodGhpcy5leHBhbmRDb2xsYXBzZUJ1dHRvblJlZiA9IGVsKSB9KSwgaChcImNhbGNpdGUtdG9vbHRpcFwiLCB7IHJlZmVyZW5jZUVsZW1lbnQ6IHRoaXMuZXhwYW5kQ29sbGFwc2VCdXR0b25SZWYgfSwgaChcImRpdlwiLCB7IGNsYXNzOiBcImJ0bi1wb3BvdmVyXCIgfSwgaXNDb2xsYXBzZWQgPyBpMThuLmNhdGVnb3J5SXRlbS5leHBhbmQgOiBpMThuLmNhdGVnb3J5SXRlbS5jb2xsYXBzZSkpKSksIHNob3dFZGl0ID8gKGgoXCJjYWxjaXRlLWlubGluZS1lZGl0YWJsZVwiLCB7IGNsYXNzOiBcImFyY2dpcy1zY2hlbWEtZWRpdG9yLWNhdGVnb3J5LXJvd19faW5saW5lLWlucHV0XCIsIGNvbnRyb2xzOiB0cnVlLCBlZGl0aW5nRW5hYmxlZDogaXNFZGl0aW5nLCBhZnRlckNvbmZpcm06IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICAvLyAhIEV2ZW4gdGhvdWdoIHRoaXMgdHJpZ2dlciB0aGUgbG9hZGluZyBzdGF0ZSBvZiB0aGUgY2hlY2sgQ1RBLCB0aGUgY2FuY2VsIENUQSBpcyBzdGlsbCBjbGlja2FibGVcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBhZGQgYSBoYW5kbGUgZm9yIHdoZW4gaXQncyBjbGlja2VkIHdoZW4gd2UncmUgc3RpbGwgbG9hZGluZ1xuICAgICAgICAgICAgICAgIGNvbnN0IGlzVmFsaWQgPSBhd2FpdCBvblNhdmVFZGl0KCk7XG4gICAgICAgICAgICAgICAgaWYgKGlzVmFsaWQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRocm93IHRvIHByZXZlbnQgZ2V0dGluZyBvdXQgb2YgZWRpdCBtb2RlXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIG9uQ2FsY2l0ZUlubGluZUVkaXRhYmxlRWRpdENhbmNlbDogKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgb25DYW5jZWxFZGl0KCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZSAtLS0gd2UgbmVlZCB0byBkaXNhYmxlIHRoZSB0cmFzaCBjYW4gYnV0dG9uIG9uIGVkaXRcbiAgICAgICAgICAgIG9uQ2FsY2l0ZUludGVybmFsSW5saW5lRWRpdGFibGVFbmFibGVFZGl0aW5nQ2hhbmdlOiAoKSA9PiAodGhpcy5pc0VkaXRpbmcgPSB0cnVlKSB9LCBoKFwiY2FsY2l0ZS1pbnB1dFwiLCB7IHZhbHVlOiB0ZXh0Q29udGVudCwgb25DYWxjaXRlSW5wdXRJbnB1dDogKGV2ZW50KSA9PiAodGhpcy5lZGl0ZWRDYXRlZ29yeVRpdGxlID0gZXZlbnQudGFyZ2V0LnZhbHVlKSwgcmVxdWlyZWQ6IHRydWUsIHJlZjogKGVsZSkgPT4gKHRoaXMuZWRpdElucHV0UmVmID0gZWxlKSB9KSkpIDogKGgoRnJhZ21lbnQsIG51bGwsIGgoXCJkaXZcIiwgeyBjbGFzczogXCJhcmNnaXMtc2NoZW1hLWVkaXRvci1jYXRlZ29yeS1yb3dfX2lubGluZS1pbnB1dFwiIH0sIHRleHRDb250ZW50KSwgaChcImNhbGNpdGUtYWN0aW9uXCIsIHsgY2xhc3M6IFwiYXJjZ2lzLXNjaGVtYS1lZGl0b3ItY2F0ZWdvcnktcm93X19jYW50LWVkaXQtcmVhc29uXCIsIGljb246IFwiZXhjbGFtYXRpb24tbWFyay10cmlhbmdsZS1mXCIsIGFwcGVhcmFuY2U6IFwidHJhbnNwYXJlbnRcIiwgbGFiZWw6IGNhbkVkaXRSZWFzb24sIHJlZjogKGVsKSA9PiAodGhpcy5jYW50RWRpdEljb25SZWYgPSBlbCksIHRleHQ6IFwiXCIsIHRleHRFbmFibGVkOiBmYWxzZSB9KSwgaChcImNhbGNpdGUtdG9vbHRpcFwiLCB7IHJlZmVyZW5jZUVsZW1lbnQ6IHRoaXMuY2FudEVkaXRJY29uUmVmIH0sIGgoXCJkaXZcIiwgeyBjbGFzczogXCJidG4tcG9wb3ZlclwiIH0sIGNhbkVkaXRSZWFzb24pKSkpLCBzaG93RGVsZXRlICYmIChoKEZyYWdtZW50LCBudWxsLCBoKFwiY2FsY2l0ZS1idXR0b25cIiwgeyBhcHBlYXJhbmNlOiBcInRyYW5zcGFyZW50XCIsIGtpbmQ6IFwiZGFuZ2VyXCIsIG9uQ2xpY2s6ICgpID0+IHRoaXMuYXJjZ2lzU2NoZW1hRWRpdG9ySW50ZXJuYWxEZWxldGVDbGljay5lbWl0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBjYXRlZ29yeS5wYXRoLFxuICAgICAgICAgICAgICAgIGNhdGVnb3J5Q291bnQ6IGNvdW50XG4gICAgICAgICAgICB9KSwgaWNvblN0YXJ0OiBcInRyYXNoXCIsIGNsYXNzOiBcImN0YVwiLCByZWY6IChlbCkgPT4gKHRoaXMuZGVsZXRlQnV0dG9uUmVmID0gZWwpIH0pLCBoKFwiY2FsY2l0ZS10b29sdGlwXCIsIHsgcmVmZXJlbmNlRWxlbWVudDogdGhpcy5kZWxldGVCdXR0b25SZWYgfSwgaChcImRpdlwiLCB7IGNsYXNzOiBcImJ0bi1wb3BvdmVyXCIgfSwgaTE4bi5jYXRlZ29yeUl0ZW0uZGVsZXRlQ2F0ZWdvcnkpKSkpKSkpO1xuICAgIH1cbiAgICBnZXQgZWwoKSB7IHJldHVybiBnZXRFbGVtZW50KHRoaXMpOyB9XG59O1xuQXJjZ2lzU2NoZW1hRWRpdG9yQ2F0ZWdvcnlSb3cuc3R5bGUgPSBhcmNnaXNTY2hlbWFFZGl0b3JDYXRlZ29yeVJvd0NzcztcblxuZXhwb3J0IHsgQXJjZ2lzU2NoZW1hRWRpdG9yQ2F0ZWdvcnkgYXMgYXJjZ2lzX3NjaGVtYV9lZGl0b3JfY2F0ZWdvcnksIEFyY2dpc1NjaGVtYUVkaXRvckNhdGVnb3J5Um93IGFzIGFyY2dpc19zY2hlbWFfZWRpdG9yX2NhdGVnb3J5X3JvdyB9O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1hcmNnaXMtc2NoZW1hLWVkaXRvci1jYXRlZ29yeV8yLmVudHJ5LmpzLm1hcCIsIi8qIVxuICogQWxsIG1hdGVyaWFsIGNvcHlyaWdodCBFU1JJLCBBbGwgUmlnaHRzIFJlc2VydmVkLCB1bmxlc3Mgb3RoZXJ3aXNlIHNwZWNpZmllZC5cbiAqIHY0LjAuNThcbiAqL1xuY29uc3QgQ0FURUdPUllfQkFTRV9QQVRIID0gXCIvY2F0ZWdvcmllc1wiO1xuY29uc3QgVVBQRVJfQ0FURUdPUllfQkFTRV9QQVRIID0gXCIvQ2F0ZWdvcmllc1wiO1xuXG4vLyBUT0RPOiBhZGQgdW5pdCB0ZXN0c1xuLyoqXG4gKiBDb25zdHJ1Y3QgdGhlIHBhdGggb2YgdGhlIGNhdGVnb3J5IGJhc2VkIG9uIHRoZSBwYXJlbnQgcGF0aCBhbmQgdGhlIGNhdGVnb3J5IHRpdGxlXG4gKi9cbmNvbnN0IGdldENhdGVnb3J5VUlQYXRoID0gKHBhcmVudFBhdGgsIGNhdGVnb3J5LCBsb3dlckNhc2UgPSB0cnVlKSA9PiB7XG4gICAgY29uc3QgYmFzZVBhdGggPSBwYXJlbnRQYXRoICE9PSBudWxsICYmIHBhcmVudFBhdGggIT09IHZvaWQgMCA/IHBhcmVudFBhdGggOiBcIlwiO1xuICAgIHJldHVybiBgJHtiYXNlUGF0aH0ke2Jhc2VQYXRoLmVuZHNXaXRoKFwiL1wiKSA/IFwiXCIgOiBcIi9cIn0ke2xvd2VyQ2FzZSA/IGNhdGVnb3J5LnRpdGxlLnRvTG9jYWxlTG93ZXJDYXNlKCkgOiBjYXRlZ29yeS50aXRsZX1gO1xufTtcbi8qKlxuICogRmluZCB0aGUgcm9vdCBub2RlIHRpdGxlIHRvIHVzZSBmb3IgY2F0ZWdvcmllc1xuICovXG5mdW5jdGlvbiBnZXRSb290Q2F0ZWdvcnlQYXRoKGNhdGVnb3JpZXMpIHtcbiAgICB2YXIgX2E7XG4gICAgbGV0IGNhdGVnb3J5VGl0bGUgPSAoX2EgPSBjYXRlZ29yaWVzID09PSBudWxsIHx8IGNhdGVnb3JpZXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNhdGVnb3JpZXNbMF0pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS50aXRsZTtcbiAgICBpZiAoY2F0ZWdvcnlUaXRsZSAmJiBjYXRlZ29yeVRpdGxlLmNoYXJBdCgwKSAhPT0gXCIvXCIpIHtcbiAgICAgICAgY2F0ZWdvcnlUaXRsZSA9IGAvJHtjYXRlZ29yeVRpdGxlfWA7XG4gICAgfVxuICAgIHJldHVybiBjYXRlZ29yeVRpdGxlIHx8IFVQUEVSX0NBVEVHT1JZX0JBU0VfUEFUSDtcbn1cblxuZXhwb3J0IHsgQ0FURUdPUllfQkFTRV9QQVRIIGFzIEMsIFVQUEVSX0NBVEVHT1JZX0JBU0VfUEFUSCBhcyBVLCBnZXRDYXRlZ29yeVVJUGF0aCBhcyBhLCBnZXRSb290Q2F0ZWdvcnlQYXRoIGFzIGcgfTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2F0ZWdvcmllcy1jYTEzNDAwNS5qcy5tYXAiLCIvKiFcbiAqIEFsbCBtYXRlcmlhbCBjb3B5cmlnaHQgRVNSSSwgQWxsIFJpZ2h0cyBSZXNlcnZlZCwgdW5sZXNzIG90aGVyd2lzZSBzcGVjaWZpZWQuXG4gKiB2NC4wLjU4XG4gKi9cbi8qKlxuICogQ2FsbCBhIGZ1bmN0aW9uIG9ubHkgYWZ0ZXIgaXQgaGFzIG5vdCBiZWVuIGNhbGxlZCBmb3IgbiBtaWxsaXNlY29uZHNcbiAqIEBwYXJhbSBmbiAgICAtIGZ1bmN0aW9uIHRvIGNhbGxcbiAqIEBwYXJhbSBkZWxheSAtIGRlbGF5IGluIG1pbGxpc2Vjb25kc1xuICovXG5jb25zdCBkZWJvdW5jZSA9IChmbiwgZGVsYXkpID0+IHtcbiAgICBsZXQgdGltZW91dDtcbiAgICBsZXQgc3RhdHVzID0gXCJpZGxlXCI7XG4gICAgZnVuY3Rpb24gZmx1c2goLi4uYXJncykge1xuICAgICAgICBzdGF0dXMgPSBcImZsdXNoZWRcIjtcbiAgICAgICAgcmV0dXJuIGRlYm91bmNlZCguLi5hcmdzKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaW52b2tlKC4uLmFyZ3MpIHtcbiAgICAgICAgc3RhdHVzID0gXCJpbnZva2VkXCI7XG4gICAgICAgIHJldHVybiBkZWJvdW5jZWQoLi4uYXJncyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNhbmNlbCguLi5hcmdzKSB7XG4gICAgICAgIHN0YXR1cyA9IFwiY2FuY2VsbGVkXCI7XG4gICAgICAgIHJldHVybiBkZWJvdW5jZWQoLi4uYXJncyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldFN0YXR1cygpIHtcbiAgICAgICAgcmV0dXJuIHN0YXR1cztcbiAgICB9XG4gICAgY29uc3QgZGVib3VuY2VkID0gKC4uLmFyZ3MpID0+IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgIHN3aXRjaCAoc3RhdHVzKSB7XG4gICAgICAgICAgICBjYXNlIFwiZmx1c2hlZFwiOlxuICAgICAgICAgICAgICAgIHN0YXR1cyA9IFwiaWRsZVwiO1xuICAgICAgICAgICAgICAgIGlmICh0aW1lb3V0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShmbiguLi5hcmdzKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKG51bGwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJpbnZva2VkXCI6XG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICAgICAgICAgIHN0YXR1cyA9IFwiaWRsZVwiO1xuICAgICAgICAgICAgICAgIHJlc29sdmUoZm4oLi4uYXJncykpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImNhbmNlbGxlZFwiOlxuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgICAgICAgICBzdGF0dXMgPSBcImlkbGVcIjtcbiAgICAgICAgICAgICAgICByZXNvbHZlKG51bGwpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBpZiAodGltZW91dCkge1xuICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN0YXR1cyA9IFwicGVuZGluZ1wiO1xuICAgICAgICAgICAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzID0gXCJpZGxlXCI7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKGZuKC4uLmFyZ3MpKTtcbiAgICAgICAgICAgICAgICB9LCBkZWxheSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBkZWJvdW5jZWQuZmx1c2ggPSBmbHVzaDtcbiAgICBkZWJvdW5jZWQuaW52b2tlID0gaW52b2tlO1xuICAgIGRlYm91bmNlZC5jYW5jZWwgPSBjYW5jZWw7XG4gICAgZGVib3VuY2VkLmdldFN0YXR1cyA9IGdldFN0YXR1cztcbiAgICByZXR1cm4gZGVib3VuY2VkO1xufTtcbi8qKlxuICogQ2FsbCBhIGZ1bmN0aW9uIG9ubHkgYWZ0ZXIgbiBtaWxsaXNlY29uZHMgaGF2ZSBlbGFwc2VkXG4gKiBAcGFyYW0gZm4gICAgLSBmdW5jdGlvbiB0byBjYWxsXG4gKiBAcGFyYW0gZGVsYXkgLSBkZWxheSBpbiBtaWxsaXNlY29uZHNcbiAqL1xuY29uc3QgdGhyb3R0bGUgPSAoZm4sIGRlbGF5KSA9PiB7XG4gICAgbGV0IHRpbWVvdXQ7XG4gICAgcmV0dXJuICguLi5hcmdzKSA9PiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICBpZiAodGltZW91dCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgICAgIHRpbWVvdXQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICByZXNvbHZlKGZuKC4uLmFyZ3MpKTtcbiAgICAgICAgfSwgZGVsYXkpO1xuICAgIH0pO1xufTtcbmZ1bmN0aW9uIGVzY2FwZVJlZ0V4cChzdHIpIHtcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoL1suKis/XiR7fSgpfFtcXF1cXFxcXS9nLCBcIlxcXFwkJlwiKTsgLy8gJCYgbWVhbnMgdGhlIHdob2xlIG1hdGNoZWQgc3RyaW5nXG59XG5mdW5jdGlvbiBpc0RlZmluZWQodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbDtcbn1cbi8qKlxuICogU2V0IGEgbWluaW11bSB0aW1lIGZvciBhIHByb21pc2UgdG8gcmVzb2x2ZSAodXNlZnVsIGZvciBwcmV2ZW50aW5nIGZsYXNoIG9mIGxvYWRlcnMpXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIG1pbkRlbGF5KHByb21pc2UsIG1pbkRlbGF5KSB7XG4gICAgYXdhaXQgUHJvbWlzZS5hbGwoW3Byb21pc2UsIHRpbWVvdXQobWluRGVsYXkpXSk7XG4gICAgcmV0dXJuIHByb21pc2U7XG59XG4vKipcbiAqIEhlbHBlciBtZXRob2QgdG8gaW5saW5lIHNldFRpbWVvdXQgYXMgYW4gYXdhaXQgaW4gYXN5bmMgZnVuY3Rpb25zXG4gKi9cbmZ1bmN0aW9uIHRpbWVvdXQobXMpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgbXMpKTtcbn1cbmNvbnN0IGFycmF5VG9Mb29rdXBNYXAgPSAoZGF0YUFyciwgZ2V0S2V5QW5kSXRlbSkgPT4gT2JqZWN0LmZyb21FbnRyaWVzKChkYXRhQXJyIHx8IFtdKS5tYXAoKGl0ZW0pID0+IHtcbiAgICBjb25zdCB7IGtleSwgZGF0YSB9ID0gZ2V0S2V5QW5kSXRlbShpdGVtKTtcbiAgICByZXR1cm4gW2tleSwgZGF0YV07XG59KSk7XG4vKipcbiAqIENoZWNrIHdoZXRoZXIgdHdvIGFycmF5cyBoYXZlIHRoZSBzYW1lIG51bWJlciBvZiBlbGVtZW50c1xuICogYW5kIHdoZXRoZXIgdGhleSBjb250YWluIHRoZSBzYW1lIGVsZW1lbnRzXG4gKiByZWdhcmRsZXNzIG9mIG9yZGVyXG4gKi9cbmNvbnN0IGFycmF5c0FyZUVxdWl2YWxlbnQgPSAoYXJyMSwgYXJyMikgPT4gYXJyMS5sZW5ndGggPT09IGFycjIubGVuZ3RoICYmIGFycjEucmVkdWNlKChtZW1vLCBzdHIpID0+IG1lbW8gJiYgYXJyMi5pbmRleE9mKHN0cikgPiAtMSwgdHJ1ZSk7XG5mdW5jdGlvbiB1bmlxdWVCeShteUFyciwgZ2V0SXRlbUlkKSB7XG4gICAgY29uc3QgcmVzdWx0QXJyID0gW107XG4gICAgY29uc3QgbG9va3VwTWFwID0ge307XG4gICAgbXlBcnIuZm9yRWFjaCgoaXRlbSkgPT4ge1xuICAgICAgICBjb25zdCBpZCA9IGdldEl0ZW1JZChpdGVtKTtcbiAgICAgICAgaWYgKGxvb2t1cE1hcFtpZF0gPT0gbnVsbCkge1xuICAgICAgICAgICAgbG9va3VwTWFwW2lkXSA9IGl0ZW07XG4gICAgICAgICAgICByZXN1bHRBcnIucHVzaChpdGVtKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHRBcnI7XG59XG5mdW5jdGlvbiB1bmlxdWUobXlBcnIpIHtcbiAgICBjb25zdCBwcmltaXRpdmVzID0geyBib29sZWFuOiB7fSwgbnVtYmVyOiB7fSwgc3RyaW5nOiB7fSB9O1xuICAgIGNvbnN0IG9ianMgPSBbXTtcbiAgICByZXR1cm4gbXlBcnIuZmlsdGVyKChpdGVtKSA9PiB7XG4gICAgICAgIGxldCB0eXBlID0gdHlwZW9mIGl0ZW07XG4gICAgICAgIGlmICh0eXBlIGluIHByaW1pdGl2ZXMpIHtcbiAgICAgICAgICAgIHJldHVybiBwcmltaXRpdmVzW3R5cGVdLmhhc093blByb3BlcnR5KGl0ZW0pID8gZmFsc2UgOiAocHJpbWl0aXZlc1t0eXBlXVtpdGVtXSA9IHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG9ianMuaW5kZXhPZihpdGVtKSA+PSAwID8gZmFsc2UgOiBvYmpzLnB1c2goaXRlbSk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmNvbnN0IGNodW5rID0gKGFyciwgc2l6ZSkgPT4gWy4uLkFycmF5KE1hdGguY2VpbChhcnIubGVuZ3RoIC8gc2l6ZSkpXS5tYXAoKF8sIGkpID0+IGFyci5zbGljZShzaXplICogaSwgc2l6ZSArIHNpemUgKiBpKSk7XG5cbmV4cG9ydCB7IGFycmF5VG9Mb29rdXBNYXAgYXMgYSwgdW5pcXVlIGFzIGIsIHRocm90dGxlIGFzIGMsIGRlYm91bmNlIGFzIGQsIGVzY2FwZVJlZ0V4cCBhcyBlLCBhcnJheXNBcmVFcXVpdmFsZW50IGFzIGYsIGNodW5rIGFzIGcsIGlzRGVmaW5lZCBhcyBpLCBtaW5EZWxheSBhcyBtLCB0aW1lb3V0IGFzIHQsIHVuaXF1ZUJ5IGFzIHUgfTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZnVuY3Rpb25hbC00NGRlOGZjZi5qcy5tYXAiLCIvKiFcbiAqIEFsbCBtYXRlcmlhbCBjb3B5cmlnaHQgRVNSSSwgQWxsIFJpZ2h0cyBSZXNlcnZlZCwgdW5sZXNzIG90aGVyd2lzZSBzcGVjaWZpZWQuXG4gKiB2NC4wLjU4XG4gKi9cbmltcG9ydCB7IEMgYXMgQ0FURUdPUllfQkFTRV9QQVRILCBhIGFzIGdldENhdGVnb3J5VUlQYXRoIH0gZnJvbSAnLi9jYXRlZ29yaWVzLWNhMTM0MDA1LmpzJztcblxuLy8gVE9ETzogYWRkIHVuaXQgdGVzdHNcbmNvbnN0IGdldE5ld0NhdGVnb3J5U2NoZW1hRnJvbU1vdmUgPSAoY2F0ZWdvcnksIHsgZnJvbUNhdGVnb3J5OiB7IHBhdGg6IGZyb21QYXRoIH0sIHRvQ2F0ZWdvcnk6IHsgcGF0aDogdG9QYXRoIH0sIGZyb21JbmRleCwgdG9JbmRleCB9KSA9PiB7XG4gICAgLy8gQ29weSBzaW5jZSB0aGlzIHdpbGwgYmUgYSBkZXN0cnVjdGl2ZSBvcGVyYXRpb25cbiAgICBjb25zdCB1aUNhdGVnb3J5ID0gc3RydWN0dXJlZENsb25lKGNhdGVnb3J5KTtcbiAgICBjb25zdCBmcm9tQ2F0ZWdvcnkgPSBnZXRDYXRlZ29yeUZyb21QYXRoKHVpQ2F0ZWdvcnksIGZyb21QYXRoKTtcbiAgICBsZXQgdG9DYXRlZ29yeSA9IGZyb21DYXRlZ29yeTtcbiAgICBpZiAoZnJvbVBhdGggIT09IHRvUGF0aCkge1xuICAgICAgICB0b0NhdGVnb3J5ID0gZ2V0Q2F0ZWdvcnlGcm9tUGF0aCh1aUNhdGVnb3J5LCB0b1BhdGgpO1xuICAgIH1cbiAgICBjb25zdCBbcmVtb3ZlZF0gPSBmcm9tQ2F0ZWdvcnkudGFyZ2V0Q2F0ZWdvcnkuY2F0ZWdvcmllcy5zcGxpY2UoZnJvbUluZGV4LCAxKTtcbiAgICB0b0NhdGVnb3J5LnRhcmdldENhdGVnb3J5LmNhdGVnb3JpZXMuc3BsaWNlKHRvSW5kZXgsIDAsIHJlbW92ZWQpO1xuICAgIHJldHVybiBnZXRDYXRlZ29yeVNjaGVtYUZyb21VSUNhdGVnb3J5KHVpQ2F0ZWdvcnkpO1xufTtcbmNvbnN0IGdldE5ld0NhdGVnb3J5U2NoZW1hRnJvbVRpdGxlQ2hhbmdlID0gKGNhdGVnb3J5LCB7IG5ld1RpdGxlLCBwYXRoIH0pID0+IHtcbiAgICBjb25zdCB1aUNhdGVnb3J5ID0gc3RydWN0dXJlZENsb25lKGNhdGVnb3J5KTtcbiAgICBjb25zdCBjYXRlZ29yeVRvQ2hhbmdlID0gZ2V0Q2F0ZWdvcnlGcm9tUGF0aCh1aUNhdGVnb3J5LCBwYXRoKTtcbiAgICBjYXRlZ29yeVRvQ2hhbmdlLnRhcmdldENhdGVnb3J5LnRpdGxlID0gbmV3VGl0bGU7XG4gICAgcmV0dXJuIGdldENhdGVnb3J5U2NoZW1hRnJvbVVJQ2F0ZWdvcnkodWlDYXRlZ29yeSk7XG59O1xuY29uc3QgZ2V0TmV3Q2F0ZWdvcnlTY2hlbWFGcm9tQ2F0ZWdvcnlBZGQgPSAoY2F0ZWdvcnksIHsgbmV3VGl0bGUsIHBhdGggfSkgPT4ge1xuICAgIGNvbnN0IHVpQ2F0ZWdvcnkgPSBzdHJ1Y3R1cmVkQ2xvbmUoY2F0ZWdvcnkpO1xuICAgIC8vIFJlbW92ZSB0aGUgbGFzdCBwYXJ0IHNpbmNlIGl0J3MganVzdCB0aGUgcGxhY2Vob2xkZXJcbiAgICAvLyBlLmcuIGAvY2F0ZWdvcmllcy9jYXRlZ29yeSAxL25ldy1pbnB1dGAgLT4gYC9jYXRlZ29yaWVzL2NhdGVnb3J5IDFgXG4gICAgY29uc3QgY29udGFpbmVyUGF0aCA9IHBhdGgucmVwbGFjZSgvXFwvW14vXSskLywgXCJcIik7XG4gICAgaWYgKGNvbnRhaW5lclBhdGgpIHtcbiAgICAgICAgY29uc3QgeyB0YXJnZXRDYXRlZ29yeSB9ID0gZ2V0Q2F0ZWdvcnlGcm9tUGF0aCh1aUNhdGVnb3J5LCBjb250YWluZXJQYXRoKTtcbiAgICAgICAgdGFyZ2V0Q2F0ZWdvcnkuY2F0ZWdvcmllcy5wdXNoKHsgdGl0bGU6IG5ld1RpdGxlLCBjYXRlZ29yaWVzOiBbXSwgY291bnQ6IDAsIHBhdGg6IG51bGwgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBtZWFucyB3ZSdyZSBhZGRpbmcgYSByb290IGxldmVsIGNhdGVnb3J5IHdoZW4gdGhlcmUgaXMgbm8gY2F0ZWdvcnkgeWV0XG4gICAgICAgICAqXG4gICAgICAgICAqIENhbiBoYXBwZW5zIHdoZW4gd2UgZmlyc3Qgc2V0IHVwIHRoZSBjYXRlZ29yeSBzY2hlbWFcbiAgICAgICAgICovXG4gICAgICAgIHVpQ2F0ZWdvcnkuY2F0ZWdvcmllcy5wdXNoKHsgdGl0bGU6IG5ld1RpdGxlLCBjYXRlZ29yaWVzOiBbXSwgY291bnQ6IDAsIHBhdGg6IG51bGwgfSk7XG4gICAgfVxuICAgIHJldHVybiBnZXRDYXRlZ29yeVNjaGVtYUZyb21VSUNhdGVnb3J5KHVpQ2F0ZWdvcnkpO1xufTtcbmNvbnN0IGdldE5ld0NhdGVnb3J5U2NoZW1hRnJvbURlbGV0ZSA9IChjYXRlZ29yeSwgeyBwYXRoIH0pID0+IHtcbiAgICBjb25zdCB1aUNhdGVnb3J5ID0gc3RydWN0dXJlZENsb25lKGNhdGVnb3J5KTtcbiAgICBjb25zdCB7IHRhcmdldEluZGV4LCBwYXJlbnRDYXRlZ29yeSB9ID0gZ2V0Q2F0ZWdvcnlGcm9tUGF0aCh1aUNhdGVnb3J5LCBwYXRoKTtcbiAgICBwYXJlbnRDYXRlZ29yeSA9PT0gbnVsbCB8fCBwYXJlbnRDYXRlZ29yeSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyZW50Q2F0ZWdvcnkuY2F0ZWdvcmllcy5zcGxpY2UodGFyZ2V0SW5kZXgsIDEpO1xuICAgIHJldHVybiBnZXRDYXRlZ29yeVNjaGVtYUZyb21VSUNhdGVnb3J5KHVpQ2F0ZWdvcnkpO1xufTtcbi8vICogLS0tIFV0aWxzXG4vLyBQYXRoIHdlIHdhbnQgdG8gcmVtb3ZlIHRoZSBiYXNlIHBhdGggc2luY2Ugd2UgY291bnQgcm9vdCBhcyAwdGggbGV2ZWwgdGhlbiBhbHNvIHJlbW92ZSB0aGUgYmVnaW5uaW5nIGAvYCB0byBhdm9pZCBlbXB0eSBzdHJpbmdcbmNvbnN0IGdldFBhdGhMZW5ndGggPSAocGF0aCkgPT4geyB2YXIgX2E7IHJldHVybiAoX2EgPSBwYXRoID09PSBudWxsIHx8IHBhdGggPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhdGgucmVwbGFjZShDQVRFR09SWV9CQVNFX1BBVEgsIFwiXCIpLnNsaWNlKDEpLnNwbGl0KFwiL1wiKS5sZW5ndGgpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDA7IH07XG4vKipcbiAqIEdldCB0aGUgY2F0ZWdvcnkgZnJvbSBzY2hlbWEgYmFzZWQgb24gdGhlIHBhdGhcbiAqL1xuY29uc3QgZ2V0Q2F0ZWdvcnlGcm9tUGF0aCA9ICh1aUNhdGVnb3J5LCBwYXRoKSA9PiB7XG4gICAgaWYgKHBhdGggPT0gbnVsbCB8fCBwYXRoID09PSBDQVRFR09SWV9CQVNFX1BBVEgpIHtcbiAgICAgICAgLy8gUm9vdCBsZXZlbFxuICAgICAgICByZXR1cm4geyB0YXJnZXRDYXRlZ29yeTogdWlDYXRlZ29yeSwgdGFyZ2V0SW5kZXg6IDEsIHBhcmVudENhdGVnb3J5OiBudWxsIH07XG4gICAgfVxuICAgIC8vIFBhdGggc3RhcnRzIHdpdGggYC9gIHNvIHJlbW92ZSBpdFxuICAgIGNvbnN0IHBhdGhQYXJ0cyA9IHBhdGguc2xpY2UoMSkuc3BsaXQoXCIvXCIpO1xuICAgIGxldCBjdXJQYXRoID0gcGF0aC5pbmRleE9mKENBVEVHT1JZX0JBU0VfUEFUSCkgPT09IDAgPyBnZXRDYXRlZ29yeVVJUGF0aChcIlwiLCB7IHRpdGxlOiBwYXRoUGFydHMuc2hpZnQoKSB9KSA6IFwiXCI7XG4gICAgbGV0IHBhcmVudENhdGVnb3J5ID0gbnVsbDtcbiAgICBsZXQgdGFyZ2V0Q2F0ZWdvcnkgPSB1aUNhdGVnb3J5O1xuICAgIGxldCB0YXJnZXRJbmRleCA9IDA7XG4gICAgZG8ge1xuICAgICAgICBjdXJQYXRoID0gZ2V0Q2F0ZWdvcnlVSVBhdGgoY3VyUGF0aCwgeyB0aXRsZTogcGF0aFBhcnRzLnNoaWZ0KCkgfSk7XG4gICAgICAgIHBhcmVudENhdGVnb3J5ID0gdGFyZ2V0Q2F0ZWdvcnk7XG4gICAgICAgIHRhcmdldEluZGV4ID0gdGFyZ2V0Q2F0ZWdvcnkuY2F0ZWdvcmllcy5maW5kSW5kZXgoKHN1YmNhdGVnb3J5KSA9PiBzdWJjYXRlZ29yeS5wYXRoID09PSBjdXJQYXRoKTtcbiAgICAgICAgdGFyZ2V0Q2F0ZWdvcnkgPSB0YXJnZXRDYXRlZ29yeS5jYXRlZ29yaWVzW3RhcmdldEluZGV4XTtcbiAgICB9IHdoaWxlIChwYXRoUGFydHMubGVuZ3RoID4gMCAmJiB0YXJnZXRDYXRlZ29yeS5jYXRlZ29yaWVzLmxlbmd0aCk7XG4gICAgcmV0dXJuIHsgdGFyZ2V0Q2F0ZWdvcnksIHRhcmdldEluZGV4LCBwYXJlbnRDYXRlZ29yeSB9O1xufTtcbi8qKlxuICogQ3JlYXRlIGEgbmVzdGVkIGNhdGVnb3J5IHNjaGVtYSBmcm9tIHRoZSBhZ2dyZWdhdGVkIHNlYXJjaCByZXN1bHQgc3RhcnRpbmcgZnJvbSByb290XG4gKi9cbmNvbnN0IGdldFVJQ2F0ZWdvcnlGcm9tQ2F0ZWdvcnlTY2hlbWEgPSAoY2F0ZWdvcnlTY2hlbWEsIGNhdGVnb3J5QWdncmVnYXRpb25EYXRhKSA9PiB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICByZXR1cm4gKHtcbiAgICAgICAgdGl0bGU6IFwiXCIsXG4gICAgICAgIHBhdGg6IG51bGwsXG4gICAgICAgIGNvdW50OiAoX2IgPSAoX2EgPSBjYXRlZ29yeUFnZ3JlZ2F0aW9uRGF0YS5maWVsZFZhbHVlcy5maW5kKChmaWVsZFZhbHVlKSA9PiBmaWVsZFZhbHVlLnZhbHVlID09PSBDQVRFR09SWV9CQVNFX1BBVEgpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY291bnQpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IDAsXG4gICAgICAgIGNhdGVnb3JpZXM6IGdldFVJQ2F0ZWdvcnlGcm9tQ2F0ZWdvcnlTY2hlbWFSZWN1cnNpdmUobnVsbCwgY2F0ZWdvcnlTY2hlbWEsIGNhdGVnb3J5QWdncmVnYXRpb25EYXRhKVxuICAgIH0pO1xufTtcbmNvbnN0IGdldENhdGVnb3J5U2NoZW1hRnJvbVVJQ2F0ZWdvcnkgPSAodWlDYXRlZ29yeSkgPT4gdWlDYXRlZ29yeS5jYXRlZ29yaWVzLm1hcChnZXRDYXRlZ29yeUZyb21VSUNhdGVnb3J5KTtcbmNvbnN0IGdldENhdGVnb3J5RnJvbVVJQ2F0ZWdvcnkgPSAodWlDYXRlZ29yeSkgPT4gKHtcbiAgICB0aXRsZTogdWlDYXRlZ29yeS50aXRsZSxcbiAgICBjYXRlZ29yaWVzOiB1aUNhdGVnb3J5LmNhdGVnb3JpZXMubWFwKGdldENhdGVnb3J5RnJvbVVJQ2F0ZWdvcnkpXG59KTtcbmNvbnN0IGdldFVJQ2F0ZWdvcnlGcm9tQ2F0ZWdvcnlTY2hlbWFSZWN1cnNpdmUgPSAocGFyZW50UGF0aCwgY2F0ZWdvcnlTY2hlbWEsIGNhdGVnb3J5QWdncmVnYXRpb25EYXRhKSA9PiB7XG4gICAgcmV0dXJuIGNhdGVnb3J5U2NoZW1hLm1hcCgoY2F0ZWdvcnkpID0+IHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgY29uc3QgcGF0aCA9IGdldENhdGVnb3J5VUlQYXRoKHBhcmVudFBhdGggIT09IG51bGwgJiYgcGFyZW50UGF0aCAhPT0gdm9pZCAwID8gcGFyZW50UGF0aCA6IENBVEVHT1JZX0JBU0VfUEFUSCwgY2F0ZWdvcnkpO1xuICAgICAgICBjb25zdCBjYXRlZ29yeUNvdW50ID0gKF9hID0gY2F0ZWdvcnlBZ2dyZWdhdGlvbkRhdGEuZmllbGRWYWx1ZXMuZmluZCgoZmllbGRWYWx1ZSkgPT4gZmllbGRWYWx1ZS52YWx1ZSA9PT0gcGF0aCkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jb3VudDtcbiAgICAgICAgY29uc3Qgc3ViY2F0ZWdvcmllcyA9IGdldFVJQ2F0ZWdvcnlGcm9tQ2F0ZWdvcnlTY2hlbWFSZWN1cnNpdmUocGF0aCwgKF9iID0gY2F0ZWdvcnkuY2F0ZWdvcmllcykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogW10sIGNhdGVnb3J5QWdncmVnYXRpb25EYXRhKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRpdGxlOiBjYXRlZ29yeS50aXRsZSxcbiAgICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgICBjb3VudDogY2F0ZWdvcnlDb3VudCAhPT0gbnVsbCAmJiBjYXRlZ29yeUNvdW50ICE9PSB2b2lkIDAgPyBjYXRlZ29yeUNvdW50IDogMCxcbiAgICAgICAgICAgIGNhdGVnb3JpZXM6IHN1YmNhdGVnb3JpZXNcbiAgICAgICAgfTtcbiAgICB9KTtcbn07XG5jb25zdCBjb3VudE51bUNhdGVnb3JpZXMgPSAoY2F0ZWdvcnlTY2hlbWEpID0+IHtcbiAgICAvLyArIDEgaXMgaXRzZWxmXG4gICAgcmV0dXJuIGNhdGVnb3J5U2NoZW1hLnJlZHVjZSgoYWNjLCBjdXIpID0+IHsgdmFyIF9hOyByZXR1cm4gYWNjICsgMSArIGNvdW50TnVtQ2F0ZWdvcmllcygoX2EgPSBjdXIuY2F0ZWdvcmllcykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogW10pOyB9LCAwKTtcbn07XG5jb25zdCBjaGVja05ld0NhdGVnb3J5VGl0bGVWYWxpZCA9ICh7IHRhcmdldENhdGVnb3J5LCB0YXJnZXRQYXJlbnRDYXRlZ29yeSB9KSA9PiB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IGNhdGVnb3J5TG93ZXJDYXNlVGl0bGUgPSAoX2EgPSB0YXJnZXRDYXRlZ29yeS50aXRsZS50b0xvY2FsZUxvd2VyQ2FzZSgpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudHJpbSgpO1xuICAgIGlmICghY2F0ZWdvcnlMb3dlckNhc2VUaXRsZSkge1xuICAgICAgICByZXR1cm4gXCJlbXB0eVRpdGxlXCI7XG4gICAgfVxuICAgIGlmIChjYXRlZ29yeUxvd2VyQ2FzZVRpdGxlLmxlbmd0aCA+IE1BWF9DQVRFR09SWV9OQU1FX0xFTkdUSCkge1xuICAgICAgICByZXR1cm4gXCJtYXhDaGFyYWN0ZXJcIjtcbiAgICB9XG4gICAgLy8gTm8gZHVwbGljYXRlIGNhdGVnb3J5IG5hbWUgb24gdGhlIHNhbWUgbGV2ZWxcbiAgICBpZiAodGFyZ2V0UGFyZW50Q2F0ZWdvcnkuY2F0ZWdvcmllcy5zb21lKChjYXRlZ29yeSkgPT4gY2F0ZWdvcnkudGl0bGUudG9Mb3dlckNhc2UoKSA9PT0gY2F0ZWdvcnlMb3dlckNhc2VUaXRsZSAmJiBjYXRlZ29yeS5wYXRoICE9PSB0YXJnZXRDYXRlZ29yeS5wYXRoKSkge1xuICAgICAgICByZXR1cm4gXCJkZXN0aW5hdGlvbkhhc1NhbWVOYW1lXCI7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufTtcbmNvbnN0IE1BWF9DQVRFR09SWV9OQU1FX0xFTkdUSCA9IDEwMDtcblxuZXhwb3J0IHsgTUFYX0NBVEVHT1JZX05BTUVfTEVOR1RIIGFzIE0sIGdldE5ld0NhdGVnb3J5U2NoZW1hRnJvbURlbGV0ZSBhcyBhLCBnZXRDYXRlZ29yeUZyb21QYXRoIGFzIGIsIGNoZWNrTmV3Q2F0ZWdvcnlUaXRsZVZhbGlkIGFzIGMsIGdldE5ld0NhdGVnb3J5U2NoZW1hRnJvbVRpdGxlQ2hhbmdlIGFzIGQsIGdldE5ld0NhdGVnb3J5U2NoZW1hRnJvbUNhdGVnb3J5QWRkIGFzIGUsIGdldFBhdGhMZW5ndGggYXMgZiwgZ2V0TmV3Q2F0ZWdvcnlTY2hlbWFGcm9tTW92ZSBhcyBnLCBnZXRVSUNhdGVnb3J5RnJvbUNhdGVnb3J5U2NoZW1hIGFzIGgsIGNvdW50TnVtQ2F0ZWdvcmllcyBhcyBpIH07XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWwtMmEwZTJmMDguanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9