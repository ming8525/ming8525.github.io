"use strict";
(self["webpackChunkexb_client"] = self["webpackChunkexb_client"] || []).push([["vendors-extensions_widgets_arcgis_analysis_node_modules_arcgis_app-components_dist_esm_functi-1ef940"],{

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/functional-44de8fcf.js":
/*!****************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/functional-44de8fcf.js ***!
  \****************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   a: () => (/* binding */ arrayToLookupMap),
/* harmony export */   b: () => (/* binding */ unique),
/* harmony export */   c: () => (/* binding */ throttle),
/* harmony export */   d: () => (/* binding */ debounce),
/* harmony export */   e: () => (/* binding */ escapeRegExp),
/* harmony export */   f: () => (/* binding */ arraysAreEquivalent),
/* harmony export */   g: () => (/* binding */ chunk),
/* harmony export */   i: () => (/* binding */ isDefined),
/* harmony export */   m: () => (/* binding */ minDelay),
/* harmony export */   t: () => (/* binding */ timeout),
/* harmony export */   u: () => (/* binding */ uniqueBy)
/* harmony export */ });
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v4.0.58
 */
/**
 * Call a function only after it has not been called for n milliseconds
 * @param fn    - function to call
 * @param delay - delay in milliseconds
 */
const debounce = (fn, delay) => {
    let timeout;
    let status = "idle";
    function flush(...args) {
        status = "flushed";
        return debounced(...args);
    }
    function invoke(...args) {
        status = "invoked";
        return debounced(...args);
    }
    function cancel(...args) {
        status = "cancelled";
        return debounced(...args);
    }
    function getStatus() {
        return status;
    }
    const debounced = (...args) => new Promise((resolve) => {
        switch (status) {
            case "flushed":
                status = "idle";
                if (timeout) {
                    clearTimeout(timeout);
                    resolve(fn(...args));
                }
                else {
                    resolve(null);
                }
                break;
            case "invoked":
                clearTimeout(timeout);
                status = "idle";
                resolve(fn(...args));
                break;
            case "cancelled":
                clearTimeout(timeout);
                status = "idle";
                resolve(null);
                break;
            default:
                if (timeout) {
                    clearTimeout(timeout);
                }
                status = "pending";
                timeout = setTimeout(() => {
                    status = "idle";
                    return resolve(fn(...args));
                }, delay);
                break;
        }
    });
    debounced.flush = flush;
    debounced.invoke = invoke;
    debounced.cancel = cancel;
    debounced.getStatus = getStatus;
    return debounced;
};
/**
 * Call a function only after n milliseconds have elapsed
 * @param fn    - function to call
 * @param delay - delay in milliseconds
 */
const throttle = (fn, delay) => {
    let timeout;
    return (...args) => new Promise((resolve) => {
        if (timeout) {
            return;
        }
        timeout = setTimeout(() => {
            clearTimeout(timeout);
            timeout = undefined;
            resolve(fn(...args));
        }, delay);
    });
};
function escapeRegExp(str) {
    return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"); // $& means the whole matched string
}
function isDefined(value) {
    return value !== undefined && value !== null;
}
/**
 * Set a minimum time for a promise to resolve (useful for preventing flash of loaders)
 */
async function minDelay(promise, minDelay) {
    await Promise.all([promise, timeout(minDelay)]);
    return promise;
}
/**
 * Helper method to inline setTimeout as an await in async functions
 */
function timeout(ms) {
    return new Promise((resolve) => setTimeout(resolve, ms));
}
const arrayToLookupMap = (dataArr, getKeyAndItem) => Object.fromEntries((dataArr || []).map((item) => {
    const { key, data } = getKeyAndItem(item);
    return [key, data];
}));
/**
 * Check whether two arrays have the same number of elements
 * and whether they contain the same elements
 * regardless of order
 */
const arraysAreEquivalent = (arr1, arr2) => arr1.length === arr2.length && arr1.reduce((memo, str) => memo && arr2.indexOf(str) > -1, true);
function uniqueBy(myArr, getItemId) {
    const resultArr = [];
    const lookupMap = {};
    myArr.forEach((item) => {
        const id = getItemId(item);
        if (lookupMap[id] == null) {
            lookupMap[id] = item;
            resultArr.push(item);
        }
    });
    return resultArr;
}
function unique(myArr) {
    const primitives = { boolean: {}, number: {}, string: {} };
    const objs = [];
    return myArr.filter((item) => {
        let type = typeof item;
        if (type in primitives) {
            return primitives[type].hasOwnProperty(item) ? false : (primitives[type][item] = true);
        }
        else {
            return objs.indexOf(item) >= 0 ? false : objs.push(item);
        }
    });
}
const chunk = (arr, size) => [...Array(Math.ceil(arr.length / size))].map((_, i) => arr.slice(size * i, size + size * i));



//# sourceMappingURL=functional-44de8fcf.js.map

/***/ }),

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/locale-050b6db9.js":
/*!************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/locale-050b6db9.js ***!
  \************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   a: () => (/* binding */ getComponentClosestLanguage),
/* harmony export */   g: () => (/* binding */ getLocaleComponentStrings)
/* harmony export */ });
/* harmony import */ var _dom_4d367677_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dom-4d367677.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/dom-4d367677.js");
/* harmony import */ var _languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./languageUtil-ef0e54b2.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/languageUtil-ef0e54b2.js");
/* harmony import */ var _index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./index-e3bf7da7.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/index-e3bf7da7.js");
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v4.0.58
 */




// https://medium.com/stencil-tricks/implementing-internationalisation-i18n-with-stencil-5e6559554117
function getComponentClosestLanguage(element) {
    var _a, _b, _c;
    const closestElement = (_a = (0,_dom_4d367677_js__WEBPACK_IMPORTED_MODULE_0__.c)(element, "[lang]")) !== null && _a !== void 0 ? _a : (_c = (_b = element.shadowRoot) === null || _b === void 0 ? void 0 : _b.ownerDocument) === null || _c === void 0 ? void 0 : _c.documentElement;
    // language set by the calling application or browser. defaults to english.
    const lang = ((closestElement === null || closestElement === void 0 ? void 0 : closestElement.lang) || (navigator === null || navigator === void 0 ? void 0 : navigator.language) || "en").toLowerCase();
    if (_languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_1__.l.has(lang)) {
        return _languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_1__.l.get(lang);
    }
    else {
        // "ru-RU" maps to "ru" use case
        if (_languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_1__.l.has(lang.slice(0, 2))) {
            return _languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_1__.l.get(lang.slice(0, 2));
        }
        else {
            return "en";
        }
    }
}
function getComponentClosestLanguageIntl(element) {
    var _a, _b, _c;
    // it's OK if we don't have the 4 letter language file for it
    // 4 letter language code needed for formatting numbers
    const closestElement = (_a = (0,_dom_4d367677_js__WEBPACK_IMPORTED_MODULE_0__.c)(element, "[lang]")) !== null && _a !== void 0 ? _a : (_c = (_b = element.shadowRoot) === null || _b === void 0 ? void 0 : _b.ownerDocument) === null || _c === void 0 ? void 0 : _c.documentElement;
    // language set by the calling application or browser. defaults to english.
    const lang = ((closestElement === null || closestElement === void 0 ? void 0 : closestElement.lang) || (navigator === null || navigator === void 0 ? void 0 : navigator.language) || "en").toLowerCase();
    if (_languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_1__.l.has(lang)) {
        return _languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_1__.l.get(lang);
    }
    else {
        if (_languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_1__.l.has(lang.slice(0, 2))) {
            // we support the 2 letter coded language
            // e.g. it-CH vs it
            return lang;
        }
        else {
            return "en";
        }
    }
}
function fetchLocaleStringsForComponent(componentName, locale) {
    return new Promise((resolve, reject) => {
        fetch((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_2__.a)(`../arcgis-app-assets/i18n/${componentName}.i18n.${locale}.json`)).then((result) => {
            if (result.ok)
                resolve(result.json());
            else
                reject();
        }, () => reject());
    });
}
const stringCache = {};
function fetchLocaleStringsFromCache(componentName, locale) {
    const id = `${componentName}${locale}`;
    if (!stringCache[id]) {
        stringCache[id] = fetchLocaleStringsForComponent(componentName, locale);
    }
    return stringCache[id];
}
/**
 * Get strings and language codes.
 * This method returns 2 language codes.
 * The first one returns a code that's also supported as a language file.
 * The second one returns a code where there is support for the first 2 letters of the code as part of a language file,
 * but will return the original 4 letter code from the page.
 * E.g. For "it-ch" it will return "it" as the first language code and "it-ch" as the second.
 * The second one is required for esri.intl.setLocale() to get the correct formatting.
 *
 * If a tagName is provided it will overwite the element's tagName
 *
 *  @return [ strings, first language code, second language code]
 */
async function getLocaleComponentStrings(element, tagName) {
    const componentName = tagName || element.tagName.toLowerCase();
    const componentLanguage = getComponentClosestLanguage(element);
    const componentLanguageIntl = getComponentClosestLanguageIntl(element);
    let strings;
    try {
        strings = await fetchLocaleStringsFromCache(componentName, componentLanguage);
    }
    catch (e) {
        console.warn(`no locale for ${componentName} (${componentLanguage}) loading default locale en.`);
        strings = await fetchLocaleStringsFromCache(componentName, "en");
    }
    return [strings, componentLanguage, componentLanguageIntl];
}



//# sourceMappingURL=locale-050b6db9.js.map

/***/ }),

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/symbolUtils-f207d979.js":
/*!*****************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/symbolUtils-f207d979.js ***!
  \*****************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   a: () => (/* binding */ isSMSSymbol),
/* harmony export */   b: () => (/* binding */ isSFSSymbol),
/* harmony export */   c: () => (/* binding */ isSLSSymbol),
/* harmony export */   d: () => (/* binding */ isPMSSymbol),
/* harmony export */   e: () => (/* binding */ esriModules),
/* harmony export */   f: () => (/* binding */ isPolygonCIM),
/* harmony export */   g: () => (/* binding */ geometryType),
/* harmony export */   h: () => (/* binding */ isLineCIM),
/* harmony export */   i: () => (/* binding */ isCIMSymbol),
/* harmony export */   j: () => (/* binding */ isPointCIM)
/* harmony export */ });
/* harmony import */ var _loadModules_b4ac1247_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./loadModules-b4ac1247.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/loadModules-b4ac1247.js");
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v4.0.58
 */


function geometryType(symbol) {
    if (symbol.type === "cim") {
        return symbol.data.symbol.type === "CIMLineSymbol"
            ? "line"
            : symbol.data.symbol.type === "CIMPolygonSymbol"
                ? "polygon"
                : "point";
    }
    return symbol.type === "simple-marker" || symbol.type === "picture-marker"
        ? "point"
        : symbol.type === "simple-line"
            ? "line"
            : "polygon";
}
const esriModules = {
    loaded: false,
    async load() {
        if (this.loaded) {
            return;
        }
        const [screenUtils, Color, Portal, CIMSymbol, WebStyleSymbol, devEnvironmentUtils, promiseUtils, urlUtils, PortalItem, previewSymbol2D, gfxUtils, jsonUtils, styleUtils, svgUtils, symbolUtils, cimSymbolUtils, webStyleSymbolUtils] = await (0,_loadModules_b4ac1247_js__WEBPACK_IMPORTED_MODULE_0__.l)([
            "esri/core/screenUtils",
            "esri/Color",
            "esri/portal/Portal",
            "esri/symbols/CIMSymbol",
            "esri/symbols/WebStyleSymbol",
            "esri/core/devEnvironmentUtils",
            "esri/core/promiseUtils",
            "esri/core/urlUtils",
            "esri/portal/PortalItem",
            "esri/symbols/support/previewSymbol2D",
            "esri/symbols/support/gfxUtils",
            "esri/symbols/support/jsonUtils",
            "esri/symbols/support/styleUtils",
            "esri/symbols/support/svgUtils",
            "esri/symbols/support/symbolUtils",
            "esri/symbols/support/cimSymbolUtils",
            "esri/symbols/support/webStyleSymbolUtils"
        ]);
        this.Color = Color;
        this.Portal = Portal;
        this.CIMSymbol = CIMSymbol;
        this.WebStyleSymbol = WebStyleSymbol;
        this.devEnvironmentUtils = devEnvironmentUtils;
        this.previewSymbol2D = previewSymbol2D;
        this.promiseUtils = promiseUtils;
        this.urlUtils = urlUtils;
        this.PortalItem = PortalItem;
        this.gfxUtils = gfxUtils;
        this.jsonUtils = jsonUtils;
        this.screenUtils = screenUtils;
        this.styleUtils = styleUtils;
        this.svgUtils = svgUtils;
        this.symbolUtils = symbolUtils;
        this.cimSymbolUtils = cimSymbolUtils;
        this.webStyleSymbolUtils = webStyleSymbolUtils;
        this.loaded = true;
    }
};
function isCIMSymbol(symbol) {
    return (symbol === null || symbol === void 0 ? void 0 : symbol.type) === "cim";
}
function isSMSSymbol(symbol) {
    return (symbol === null || symbol === void 0 ? void 0 : symbol.type) === "simple-marker";
}
function isPMSSymbol(symbol) {
    return (symbol === null || symbol === void 0 ? void 0 : symbol.type) === "picture-marker";
}
function isSLSSymbol(symbol) {
    return (symbol === null || symbol === void 0 ? void 0 : symbol.type) === "simple-line";
}
function isSFSSymbol(symbol) {
    return (symbol === null || symbol === void 0 ? void 0 : symbol.type) === "simple-fill";
}
function isPointCIM(symbol) {
    return symbol.data.symbol.type === "CIMPointSymbol";
}
function isLineCIM(symbol) {
    return symbol.data.symbol.type === "CIMLineSymbol";
}
function isPolygonCIM(symbol) {
    return symbol.data.symbol.type === "CIMPolygonSymbol";
}



//# sourceMappingURL=symbolUtils-f207d979.js.map

/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid2lkZ2V0cy9jaHVua3MvYXJjZ2lzX2FuYWx5c2lzX25vZGVfbW9kdWxlc19hcmNnaXNfYXBwLWNvbXBvbmVudHNfZGlzdF9lc21fZnVuY3RpLTFlZjk0MC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBLGlDQUFpQyxzQkFBc0I7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxZQUFZO0FBQ3hCO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsV0FBVyxZQUFZO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVpTTs7QUFFak07Ozs7Ozs7Ozs7Ozs7Ozs7OztBQy9JQTtBQUNBO0FBQ0E7QUFDQTtBQUMyRTtBQUNiO0FBQ047O0FBRXhEO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxtREFBaUM7QUFDbEU7QUFDQTtBQUNBLFFBQVEsd0RBQVc7QUFDbkIsZUFBZSx3REFBVztBQUMxQjtBQUNBO0FBQ0E7QUFDQSxZQUFZLHdEQUFXO0FBQ3ZCLG1CQUFtQix3REFBVztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxtREFBaUM7QUFDbEU7QUFDQTtBQUNBLFFBQVEsd0RBQVc7QUFDbkIsZUFBZSx3REFBVztBQUMxQjtBQUNBO0FBQ0EsWUFBWSx3REFBVztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxxREFBWSw4QkFBOEIsY0FBYyxRQUFRLE9BQU87QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixjQUFjLEVBQUUsT0FBTztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsZUFBZSxHQUFHLGtCQUFrQjtBQUMxRTtBQUNBO0FBQ0E7QUFDQTs7QUFFNEU7O0FBRTVFOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNoR0E7QUFDQTtBQUNBO0FBQ0E7QUFDNkQ7O0FBRTdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxUEFBcVAsMkRBQVc7QUFDaFE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFNkw7O0FBRTdMIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZXhiLWNsaWVudC8uL2V4dGVuc2lvbnMvd2lkZ2V0cy9hcmNnaXMvYW5hbHlzaXMvbm9kZV9tb2R1bGVzL0BhcmNnaXMvYXBwLWNvbXBvbmVudHMvZGlzdC9lc20vZnVuY3Rpb25hbC00NGRlOGZjZi5qcyIsIndlYnBhY2s6Ly9leGItY2xpZW50Ly4vZXh0ZW5zaW9ucy93aWRnZXRzL2FyY2dpcy9hbmFseXNpcy9ub2RlX21vZHVsZXMvQGFyY2dpcy9hcHAtY29tcG9uZW50cy9kaXN0L2VzbS9sb2NhbGUtMDUwYjZkYjkuanMiLCJ3ZWJwYWNrOi8vZXhiLWNsaWVudC8uL2V4dGVuc2lvbnMvd2lkZ2V0cy9hcmNnaXMvYW5hbHlzaXMvbm9kZV9tb2R1bGVzL0BhcmNnaXMvYXBwLWNvbXBvbmVudHMvZGlzdC9lc20vc3ltYm9sVXRpbHMtZjIwN2Q5NzkuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBBbGwgbWF0ZXJpYWwgY29weXJpZ2h0IEVTUkksIEFsbCBSaWdodHMgUmVzZXJ2ZWQsIHVubGVzcyBvdGhlcndpc2Ugc3BlY2lmaWVkLlxuICogdjQuMC41OFxuICovXG4vKipcbiAqIENhbGwgYSBmdW5jdGlvbiBvbmx5IGFmdGVyIGl0IGhhcyBub3QgYmVlbiBjYWxsZWQgZm9yIG4gbWlsbGlzZWNvbmRzXG4gKiBAcGFyYW0gZm4gICAgLSBmdW5jdGlvbiB0byBjYWxsXG4gKiBAcGFyYW0gZGVsYXkgLSBkZWxheSBpbiBtaWxsaXNlY29uZHNcbiAqL1xuY29uc3QgZGVib3VuY2UgPSAoZm4sIGRlbGF5KSA9PiB7XG4gICAgbGV0IHRpbWVvdXQ7XG4gICAgbGV0IHN0YXR1cyA9IFwiaWRsZVwiO1xuICAgIGZ1bmN0aW9uIGZsdXNoKC4uLmFyZ3MpIHtcbiAgICAgICAgc3RhdHVzID0gXCJmbHVzaGVkXCI7XG4gICAgICAgIHJldHVybiBkZWJvdW5jZWQoLi4uYXJncyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGludm9rZSguLi5hcmdzKSB7XG4gICAgICAgIHN0YXR1cyA9IFwiaW52b2tlZFwiO1xuICAgICAgICByZXR1cm4gZGVib3VuY2VkKC4uLmFyZ3MpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjYW5jZWwoLi4uYXJncykge1xuICAgICAgICBzdGF0dXMgPSBcImNhbmNlbGxlZFwiO1xuICAgICAgICByZXR1cm4gZGVib3VuY2VkKC4uLmFyZ3MpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRTdGF0dXMoKSB7XG4gICAgICAgIHJldHVybiBzdGF0dXM7XG4gICAgfVxuICAgIGNvbnN0IGRlYm91bmNlZCA9ICguLi5hcmdzKSA9PiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICBzd2l0Y2ggKHN0YXR1cykge1xuICAgICAgICAgICAgY2FzZSBcImZsdXNoZWRcIjpcbiAgICAgICAgICAgICAgICBzdGF0dXMgPSBcImlkbGVcIjtcbiAgICAgICAgICAgICAgICBpZiAodGltZW91dCkge1xuICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoZm4oLi4uYXJncykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShudWxsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiaW52b2tlZFwiOlxuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgICAgICAgICBzdGF0dXMgPSBcImlkbGVcIjtcbiAgICAgICAgICAgICAgICByZXNvbHZlKGZuKC4uLmFyZ3MpKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJjYW5jZWxsZWRcIjpcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgICAgICAgICAgc3RhdHVzID0gXCJpZGxlXCI7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShudWxsKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgaWYgKHRpbWVvdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzdGF0dXMgPSBcInBlbmRpbmdcIjtcbiAgICAgICAgICAgICAgICB0aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cyA9IFwiaWRsZVwiO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZShmbiguLi5hcmdzKSk7XG4gICAgICAgICAgICAgICAgfSwgZGVsYXkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgZGVib3VuY2VkLmZsdXNoID0gZmx1c2g7XG4gICAgZGVib3VuY2VkLmludm9rZSA9IGludm9rZTtcbiAgICBkZWJvdW5jZWQuY2FuY2VsID0gY2FuY2VsO1xuICAgIGRlYm91bmNlZC5nZXRTdGF0dXMgPSBnZXRTdGF0dXM7XG4gICAgcmV0dXJuIGRlYm91bmNlZDtcbn07XG4vKipcbiAqIENhbGwgYSBmdW5jdGlvbiBvbmx5IGFmdGVyIG4gbWlsbGlzZWNvbmRzIGhhdmUgZWxhcHNlZFxuICogQHBhcmFtIGZuICAgIC0gZnVuY3Rpb24gdG8gY2FsbFxuICogQHBhcmFtIGRlbGF5IC0gZGVsYXkgaW4gbWlsbGlzZWNvbmRzXG4gKi9cbmNvbnN0IHRocm90dGxlID0gKGZuLCBkZWxheSkgPT4ge1xuICAgIGxldCB0aW1lb3V0O1xuICAgIHJldHVybiAoLi4uYXJncykgPT4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgaWYgKHRpbWVvdXQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgICAgICB0aW1lb3V0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgcmVzb2x2ZShmbiguLi5hcmdzKSk7XG4gICAgICAgIH0sIGRlbGF5KTtcbiAgICB9KTtcbn07XG5mdW5jdGlvbiBlc2NhcGVSZWdFeHAoc3RyKSB7XG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKC9bLiorP14ke30oKXxbXFxdXFxcXF0vZywgXCJcXFxcJCZcIik7IC8vICQmIG1lYW5zIHRoZSB3aG9sZSBtYXRjaGVkIHN0cmluZ1xufVxuZnVuY3Rpb24gaXNEZWZpbmVkKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGw7XG59XG4vKipcbiAqIFNldCBhIG1pbmltdW0gdGltZSBmb3IgYSBwcm9taXNlIHRvIHJlc29sdmUgKHVzZWZ1bCBmb3IgcHJldmVudGluZyBmbGFzaCBvZiBsb2FkZXJzKVxuICovXG5hc3luYyBmdW5jdGlvbiBtaW5EZWxheShwcm9taXNlLCBtaW5EZWxheSkge1xuICAgIGF3YWl0IFByb21pc2UuYWxsKFtwcm9taXNlLCB0aW1lb3V0KG1pbkRlbGF5KV0pO1xuICAgIHJldHVybiBwcm9taXNlO1xufVxuLyoqXG4gKiBIZWxwZXIgbWV0aG9kIHRvIGlubGluZSBzZXRUaW1lb3V0IGFzIGFuIGF3YWl0IGluIGFzeW5jIGZ1bmN0aW9uc1xuICovXG5mdW5jdGlvbiB0aW1lb3V0KG1zKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIG1zKSk7XG59XG5jb25zdCBhcnJheVRvTG9va3VwTWFwID0gKGRhdGFBcnIsIGdldEtleUFuZEl0ZW0pID0+IE9iamVjdC5mcm9tRW50cmllcygoZGF0YUFyciB8fCBbXSkubWFwKChpdGVtKSA9PiB7XG4gICAgY29uc3QgeyBrZXksIGRhdGEgfSA9IGdldEtleUFuZEl0ZW0oaXRlbSk7XG4gICAgcmV0dXJuIFtrZXksIGRhdGFdO1xufSkpO1xuLyoqXG4gKiBDaGVjayB3aGV0aGVyIHR3byBhcnJheXMgaGF2ZSB0aGUgc2FtZSBudW1iZXIgb2YgZWxlbWVudHNcbiAqIGFuZCB3aGV0aGVyIHRoZXkgY29udGFpbiB0aGUgc2FtZSBlbGVtZW50c1xuICogcmVnYXJkbGVzcyBvZiBvcmRlclxuICovXG5jb25zdCBhcnJheXNBcmVFcXVpdmFsZW50ID0gKGFycjEsIGFycjIpID0+IGFycjEubGVuZ3RoID09PSBhcnIyLmxlbmd0aCAmJiBhcnIxLnJlZHVjZSgobWVtbywgc3RyKSA9PiBtZW1vICYmIGFycjIuaW5kZXhPZihzdHIpID4gLTEsIHRydWUpO1xuZnVuY3Rpb24gdW5pcXVlQnkobXlBcnIsIGdldEl0ZW1JZCkge1xuICAgIGNvbnN0IHJlc3VsdEFyciA9IFtdO1xuICAgIGNvbnN0IGxvb2t1cE1hcCA9IHt9O1xuICAgIG15QXJyLmZvckVhY2goKGl0ZW0pID0+IHtcbiAgICAgICAgY29uc3QgaWQgPSBnZXRJdGVtSWQoaXRlbSk7XG4gICAgICAgIGlmIChsb29rdXBNYXBbaWRdID09IG51bGwpIHtcbiAgICAgICAgICAgIGxvb2t1cE1hcFtpZF0gPSBpdGVtO1xuICAgICAgICAgICAgcmVzdWx0QXJyLnB1c2goaXRlbSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0QXJyO1xufVxuZnVuY3Rpb24gdW5pcXVlKG15QXJyKSB7XG4gICAgY29uc3QgcHJpbWl0aXZlcyA9IHsgYm9vbGVhbjoge30sIG51bWJlcjoge30sIHN0cmluZzoge30gfTtcbiAgICBjb25zdCBvYmpzID0gW107XG4gICAgcmV0dXJuIG15QXJyLmZpbHRlcigoaXRlbSkgPT4ge1xuICAgICAgICBsZXQgdHlwZSA9IHR5cGVvZiBpdGVtO1xuICAgICAgICBpZiAodHlwZSBpbiBwcmltaXRpdmVzKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJpbWl0aXZlc1t0eXBlXS5oYXNPd25Qcm9wZXJ0eShpdGVtKSA/IGZhbHNlIDogKHByaW1pdGl2ZXNbdHlwZV1baXRlbV0gPSB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBvYmpzLmluZGV4T2YoaXRlbSkgPj0gMCA/IGZhbHNlIDogb2Jqcy5wdXNoKGl0ZW0pO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5jb25zdCBjaHVuayA9IChhcnIsIHNpemUpID0+IFsuLi5BcnJheShNYXRoLmNlaWwoYXJyLmxlbmd0aCAvIHNpemUpKV0ubWFwKChfLCBpKSA9PiBhcnIuc2xpY2Uoc2l6ZSAqIGksIHNpemUgKyBzaXplICogaSkpO1xuXG5leHBvcnQgeyBhcnJheVRvTG9va3VwTWFwIGFzIGEsIHVuaXF1ZSBhcyBiLCB0aHJvdHRsZSBhcyBjLCBkZWJvdW5jZSBhcyBkLCBlc2NhcGVSZWdFeHAgYXMgZSwgYXJyYXlzQXJlRXF1aXZhbGVudCBhcyBmLCBjaHVuayBhcyBnLCBpc0RlZmluZWQgYXMgaSwgbWluRGVsYXkgYXMgbSwgdGltZW91dCBhcyB0LCB1bmlxdWVCeSBhcyB1IH07XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZ1bmN0aW9uYWwtNDRkZThmY2YuanMubWFwIiwiLyohXG4gKiBBbGwgbWF0ZXJpYWwgY29weXJpZ2h0IEVTUkksIEFsbCBSaWdodHMgUmVzZXJ2ZWQsIHVubGVzcyBvdGhlcndpc2Ugc3BlY2lmaWVkLlxuICogdjQuMC41OFxuICovXG5pbXBvcnQgeyBjIGFzIGNsb3Nlc3RFbGVtZW50Q3Jvc3NTaGFkb3dCb3VuZGFyeSB9IGZyb20gJy4vZG9tLTRkMzY3Njc3LmpzJztcbmltcG9ydCB7IGwgYXMgbGFuZ3VhZ2VNYXAgfSBmcm9tICcuL2xhbmd1YWdlVXRpbC1lZjBlNTRiMi5qcyc7XG5pbXBvcnQgeyBhIGFzIGdldEFzc2V0UGF0aCB9IGZyb20gJy4vaW5kZXgtZTNiZjdkYTcuanMnO1xuXG4vLyBodHRwczovL21lZGl1bS5jb20vc3RlbmNpbC10cmlja3MvaW1wbGVtZW50aW5nLWludGVybmF0aW9uYWxpc2F0aW9uLWkxOG4td2l0aC1zdGVuY2lsLTVlNjU1OTU1NDExN1xuZnVuY3Rpb24gZ2V0Q29tcG9uZW50Q2xvc2VzdExhbmd1YWdlKGVsZW1lbnQpIHtcbiAgICB2YXIgX2EsIF9iLCBfYztcbiAgICBjb25zdCBjbG9zZXN0RWxlbWVudCA9IChfYSA9IGNsb3Nlc3RFbGVtZW50Q3Jvc3NTaGFkb3dCb3VuZGFyeShlbGVtZW50LCBcIltsYW5nXVwiKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogKF9jID0gKF9iID0gZWxlbWVudC5zaGFkb3dSb290KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iub3duZXJEb2N1bWVudCkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmRvY3VtZW50RWxlbWVudDtcbiAgICAvLyBsYW5ndWFnZSBzZXQgYnkgdGhlIGNhbGxpbmcgYXBwbGljYXRpb24gb3IgYnJvd3Nlci4gZGVmYXVsdHMgdG8gZW5nbGlzaC5cbiAgICBjb25zdCBsYW5nID0gKChjbG9zZXN0RWxlbWVudCA9PT0gbnVsbCB8fCBjbG9zZXN0RWxlbWVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2xvc2VzdEVsZW1lbnQubGFuZykgfHwgKG5hdmlnYXRvciA9PT0gbnVsbCB8fCBuYXZpZ2F0b3IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG5hdmlnYXRvci5sYW5ndWFnZSkgfHwgXCJlblwiKS50b0xvd2VyQ2FzZSgpO1xuICAgIGlmIChsYW5ndWFnZU1hcC5oYXMobGFuZykpIHtcbiAgICAgICAgcmV0dXJuIGxhbmd1YWdlTWFwLmdldChsYW5nKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIFwicnUtUlVcIiBtYXBzIHRvIFwicnVcIiB1c2UgY2FzZVxuICAgICAgICBpZiAobGFuZ3VhZ2VNYXAuaGFzKGxhbmcuc2xpY2UoMCwgMikpKSB7XG4gICAgICAgICAgICByZXR1cm4gbGFuZ3VhZ2VNYXAuZ2V0KGxhbmcuc2xpY2UoMCwgMikpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFwiZW5cIjtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGdldENvbXBvbmVudENsb3Nlc3RMYW5ndWFnZUludGwoZWxlbWVudCkge1xuICAgIHZhciBfYSwgX2IsIF9jO1xuICAgIC8vIGl0J3MgT0sgaWYgd2UgZG9uJ3QgaGF2ZSB0aGUgNCBsZXR0ZXIgbGFuZ3VhZ2UgZmlsZSBmb3IgaXRcbiAgICAvLyA0IGxldHRlciBsYW5ndWFnZSBjb2RlIG5lZWRlZCBmb3IgZm9ybWF0dGluZyBudW1iZXJzXG4gICAgY29uc3QgY2xvc2VzdEVsZW1lbnQgPSAoX2EgPSBjbG9zZXN0RWxlbWVudENyb3NzU2hhZG93Qm91bmRhcnkoZWxlbWVudCwgXCJbbGFuZ11cIikpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IChfYyA9IChfYiA9IGVsZW1lbnQuc2hhZG93Um9vdCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLm93bmVyRG9jdW1lbnQpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5kb2N1bWVudEVsZW1lbnQ7XG4gICAgLy8gbGFuZ3VhZ2Ugc2V0IGJ5IHRoZSBjYWxsaW5nIGFwcGxpY2F0aW9uIG9yIGJyb3dzZXIuIGRlZmF1bHRzIHRvIGVuZ2xpc2guXG4gICAgY29uc3QgbGFuZyA9ICgoY2xvc2VzdEVsZW1lbnQgPT09IG51bGwgfHwgY2xvc2VzdEVsZW1lbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNsb3Nlc3RFbGVtZW50LmxhbmcpIHx8IChuYXZpZ2F0b3IgPT09IG51bGwgfHwgbmF2aWdhdG9yID09PSB2b2lkIDAgPyB2b2lkIDAgOiBuYXZpZ2F0b3IubGFuZ3VhZ2UpIHx8IFwiZW5cIikudG9Mb3dlckNhc2UoKTtcbiAgICBpZiAobGFuZ3VhZ2VNYXAuaGFzKGxhbmcpKSB7XG4gICAgICAgIHJldHVybiBsYW5ndWFnZU1hcC5nZXQobGFuZyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAobGFuZ3VhZ2VNYXAuaGFzKGxhbmcuc2xpY2UoMCwgMikpKSB7XG4gICAgICAgICAgICAvLyB3ZSBzdXBwb3J0IHRoZSAyIGxldHRlciBjb2RlZCBsYW5ndWFnZVxuICAgICAgICAgICAgLy8gZS5nLiBpdC1DSCB2cyBpdFxuICAgICAgICAgICAgcmV0dXJuIGxhbmc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gXCJlblwiO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gZmV0Y2hMb2NhbGVTdHJpbmdzRm9yQ29tcG9uZW50KGNvbXBvbmVudE5hbWUsIGxvY2FsZSkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGZldGNoKGdldEFzc2V0UGF0aChgLi4vYXJjZ2lzLWFwcC1hc3NldHMvaTE4bi8ke2NvbXBvbmVudE5hbWV9LmkxOG4uJHtsb2NhbGV9Lmpzb25gKSkudGhlbigocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICBpZiAocmVzdWx0Lm9rKVxuICAgICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0Lmpzb24oKSk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgcmVqZWN0KCk7XG4gICAgICAgIH0sICgpID0+IHJlamVjdCgpKTtcbiAgICB9KTtcbn1cbmNvbnN0IHN0cmluZ0NhY2hlID0ge307XG5mdW5jdGlvbiBmZXRjaExvY2FsZVN0cmluZ3NGcm9tQ2FjaGUoY29tcG9uZW50TmFtZSwgbG9jYWxlKSB7XG4gICAgY29uc3QgaWQgPSBgJHtjb21wb25lbnROYW1lfSR7bG9jYWxlfWA7XG4gICAgaWYgKCFzdHJpbmdDYWNoZVtpZF0pIHtcbiAgICAgICAgc3RyaW5nQ2FjaGVbaWRdID0gZmV0Y2hMb2NhbGVTdHJpbmdzRm9yQ29tcG9uZW50KGNvbXBvbmVudE5hbWUsIGxvY2FsZSk7XG4gICAgfVxuICAgIHJldHVybiBzdHJpbmdDYWNoZVtpZF07XG59XG4vKipcbiAqIEdldCBzdHJpbmdzIGFuZCBsYW5ndWFnZSBjb2Rlcy5cbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgMiBsYW5ndWFnZSBjb2Rlcy5cbiAqIFRoZSBmaXJzdCBvbmUgcmV0dXJucyBhIGNvZGUgdGhhdCdzIGFsc28gc3VwcG9ydGVkIGFzIGEgbGFuZ3VhZ2UgZmlsZS5cbiAqIFRoZSBzZWNvbmQgb25lIHJldHVybnMgYSBjb2RlIHdoZXJlIHRoZXJlIGlzIHN1cHBvcnQgZm9yIHRoZSBmaXJzdCAyIGxldHRlcnMgb2YgdGhlIGNvZGUgYXMgcGFydCBvZiBhIGxhbmd1YWdlIGZpbGUsXG4gKiBidXQgd2lsbCByZXR1cm4gdGhlIG9yaWdpbmFsIDQgbGV0dGVyIGNvZGUgZnJvbSB0aGUgcGFnZS5cbiAqIEUuZy4gRm9yIFwiaXQtY2hcIiBpdCB3aWxsIHJldHVybiBcIml0XCIgYXMgdGhlIGZpcnN0IGxhbmd1YWdlIGNvZGUgYW5kIFwiaXQtY2hcIiBhcyB0aGUgc2Vjb25kLlxuICogVGhlIHNlY29uZCBvbmUgaXMgcmVxdWlyZWQgZm9yIGVzcmkuaW50bC5zZXRMb2NhbGUoKSB0byBnZXQgdGhlIGNvcnJlY3QgZm9ybWF0dGluZy5cbiAqXG4gKiBJZiBhIHRhZ05hbWUgaXMgcHJvdmlkZWQgaXQgd2lsbCBvdmVyd2l0ZSB0aGUgZWxlbWVudCdzIHRhZ05hbWVcbiAqXG4gKiAgQHJldHVybiBbIHN0cmluZ3MsIGZpcnN0IGxhbmd1YWdlIGNvZGUsIHNlY29uZCBsYW5ndWFnZSBjb2RlXVxuICovXG5hc3luYyBmdW5jdGlvbiBnZXRMb2NhbGVDb21wb25lbnRTdHJpbmdzKGVsZW1lbnQsIHRhZ05hbWUpIHtcbiAgICBjb25zdCBjb21wb25lbnROYW1lID0gdGFnTmFtZSB8fCBlbGVtZW50LnRhZ05hbWUudG9Mb3dlckNhc2UoKTtcbiAgICBjb25zdCBjb21wb25lbnRMYW5ndWFnZSA9IGdldENvbXBvbmVudENsb3Nlc3RMYW5ndWFnZShlbGVtZW50KTtcbiAgICBjb25zdCBjb21wb25lbnRMYW5ndWFnZUludGwgPSBnZXRDb21wb25lbnRDbG9zZXN0TGFuZ3VhZ2VJbnRsKGVsZW1lbnQpO1xuICAgIGxldCBzdHJpbmdzO1xuICAgIHRyeSB7XG4gICAgICAgIHN0cmluZ3MgPSBhd2FpdCBmZXRjaExvY2FsZVN0cmluZ3NGcm9tQ2FjaGUoY29tcG9uZW50TmFtZSwgY29tcG9uZW50TGFuZ3VhZ2UpO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICBjb25zb2xlLndhcm4oYG5vIGxvY2FsZSBmb3IgJHtjb21wb25lbnROYW1lfSAoJHtjb21wb25lbnRMYW5ndWFnZX0pIGxvYWRpbmcgZGVmYXVsdCBsb2NhbGUgZW4uYCk7XG4gICAgICAgIHN0cmluZ3MgPSBhd2FpdCBmZXRjaExvY2FsZVN0cmluZ3NGcm9tQ2FjaGUoY29tcG9uZW50TmFtZSwgXCJlblwiKTtcbiAgICB9XG4gICAgcmV0dXJuIFtzdHJpbmdzLCBjb21wb25lbnRMYW5ndWFnZSwgY29tcG9uZW50TGFuZ3VhZ2VJbnRsXTtcbn1cblxuZXhwb3J0IHsgZ2V0Q29tcG9uZW50Q2xvc2VzdExhbmd1YWdlIGFzIGEsIGdldExvY2FsZUNvbXBvbmVudFN0cmluZ3MgYXMgZyB9O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1sb2NhbGUtMDUwYjZkYjkuanMubWFwIiwiLyohXG4gKiBBbGwgbWF0ZXJpYWwgY29weXJpZ2h0IEVTUkksIEFsbCBSaWdodHMgUmVzZXJ2ZWQsIHVubGVzcyBvdGhlcndpc2Ugc3BlY2lmaWVkLlxuICogdjQuMC41OFxuICovXG5pbXBvcnQgeyBsIGFzIGxvYWRNb2R1bGVzIH0gZnJvbSAnLi9sb2FkTW9kdWxlcy1iNGFjMTI0Ny5qcyc7XG5cbmZ1bmN0aW9uIGdlb21ldHJ5VHlwZShzeW1ib2wpIHtcbiAgICBpZiAoc3ltYm9sLnR5cGUgPT09IFwiY2ltXCIpIHtcbiAgICAgICAgcmV0dXJuIHN5bWJvbC5kYXRhLnN5bWJvbC50eXBlID09PSBcIkNJTUxpbmVTeW1ib2xcIlxuICAgICAgICAgICAgPyBcImxpbmVcIlxuICAgICAgICAgICAgOiBzeW1ib2wuZGF0YS5zeW1ib2wudHlwZSA9PT0gXCJDSU1Qb2x5Z29uU3ltYm9sXCJcbiAgICAgICAgICAgICAgICA/IFwicG9seWdvblwiXG4gICAgICAgICAgICAgICAgOiBcInBvaW50XCI7XG4gICAgfVxuICAgIHJldHVybiBzeW1ib2wudHlwZSA9PT0gXCJzaW1wbGUtbWFya2VyXCIgfHwgc3ltYm9sLnR5cGUgPT09IFwicGljdHVyZS1tYXJrZXJcIlxuICAgICAgICA/IFwicG9pbnRcIlxuICAgICAgICA6IHN5bWJvbC50eXBlID09PSBcInNpbXBsZS1saW5lXCJcbiAgICAgICAgICAgID8gXCJsaW5lXCJcbiAgICAgICAgICAgIDogXCJwb2x5Z29uXCI7XG59XG5jb25zdCBlc3JpTW9kdWxlcyA9IHtcbiAgICBsb2FkZWQ6IGZhbHNlLFxuICAgIGFzeW5jIGxvYWQoKSB7XG4gICAgICAgIGlmICh0aGlzLmxvYWRlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IFtzY3JlZW5VdGlscywgQ29sb3IsIFBvcnRhbCwgQ0lNU3ltYm9sLCBXZWJTdHlsZVN5bWJvbCwgZGV2RW52aXJvbm1lbnRVdGlscywgcHJvbWlzZVV0aWxzLCB1cmxVdGlscywgUG9ydGFsSXRlbSwgcHJldmlld1N5bWJvbDJELCBnZnhVdGlscywganNvblV0aWxzLCBzdHlsZVV0aWxzLCBzdmdVdGlscywgc3ltYm9sVXRpbHMsIGNpbVN5bWJvbFV0aWxzLCB3ZWJTdHlsZVN5bWJvbFV0aWxzXSA9IGF3YWl0IGxvYWRNb2R1bGVzKFtcbiAgICAgICAgICAgIFwiZXNyaS9jb3JlL3NjcmVlblV0aWxzXCIsXG4gICAgICAgICAgICBcImVzcmkvQ29sb3JcIixcbiAgICAgICAgICAgIFwiZXNyaS9wb3J0YWwvUG9ydGFsXCIsXG4gICAgICAgICAgICBcImVzcmkvc3ltYm9scy9DSU1TeW1ib2xcIixcbiAgICAgICAgICAgIFwiZXNyaS9zeW1ib2xzL1dlYlN0eWxlU3ltYm9sXCIsXG4gICAgICAgICAgICBcImVzcmkvY29yZS9kZXZFbnZpcm9ubWVudFV0aWxzXCIsXG4gICAgICAgICAgICBcImVzcmkvY29yZS9wcm9taXNlVXRpbHNcIixcbiAgICAgICAgICAgIFwiZXNyaS9jb3JlL3VybFV0aWxzXCIsXG4gICAgICAgICAgICBcImVzcmkvcG9ydGFsL1BvcnRhbEl0ZW1cIixcbiAgICAgICAgICAgIFwiZXNyaS9zeW1ib2xzL3N1cHBvcnQvcHJldmlld1N5bWJvbDJEXCIsXG4gICAgICAgICAgICBcImVzcmkvc3ltYm9scy9zdXBwb3J0L2dmeFV0aWxzXCIsXG4gICAgICAgICAgICBcImVzcmkvc3ltYm9scy9zdXBwb3J0L2pzb25VdGlsc1wiLFxuICAgICAgICAgICAgXCJlc3JpL3N5bWJvbHMvc3VwcG9ydC9zdHlsZVV0aWxzXCIsXG4gICAgICAgICAgICBcImVzcmkvc3ltYm9scy9zdXBwb3J0L3N2Z1V0aWxzXCIsXG4gICAgICAgICAgICBcImVzcmkvc3ltYm9scy9zdXBwb3J0L3N5bWJvbFV0aWxzXCIsXG4gICAgICAgICAgICBcImVzcmkvc3ltYm9scy9zdXBwb3J0L2NpbVN5bWJvbFV0aWxzXCIsXG4gICAgICAgICAgICBcImVzcmkvc3ltYm9scy9zdXBwb3J0L3dlYlN0eWxlU3ltYm9sVXRpbHNcIlxuICAgICAgICBdKTtcbiAgICAgICAgdGhpcy5Db2xvciA9IENvbG9yO1xuICAgICAgICB0aGlzLlBvcnRhbCA9IFBvcnRhbDtcbiAgICAgICAgdGhpcy5DSU1TeW1ib2wgPSBDSU1TeW1ib2w7XG4gICAgICAgIHRoaXMuV2ViU3R5bGVTeW1ib2wgPSBXZWJTdHlsZVN5bWJvbDtcbiAgICAgICAgdGhpcy5kZXZFbnZpcm9ubWVudFV0aWxzID0gZGV2RW52aXJvbm1lbnRVdGlscztcbiAgICAgICAgdGhpcy5wcmV2aWV3U3ltYm9sMkQgPSBwcmV2aWV3U3ltYm9sMkQ7XG4gICAgICAgIHRoaXMucHJvbWlzZVV0aWxzID0gcHJvbWlzZVV0aWxzO1xuICAgICAgICB0aGlzLnVybFV0aWxzID0gdXJsVXRpbHM7XG4gICAgICAgIHRoaXMuUG9ydGFsSXRlbSA9IFBvcnRhbEl0ZW07XG4gICAgICAgIHRoaXMuZ2Z4VXRpbHMgPSBnZnhVdGlscztcbiAgICAgICAgdGhpcy5qc29uVXRpbHMgPSBqc29uVXRpbHM7XG4gICAgICAgIHRoaXMuc2NyZWVuVXRpbHMgPSBzY3JlZW5VdGlscztcbiAgICAgICAgdGhpcy5zdHlsZVV0aWxzID0gc3R5bGVVdGlscztcbiAgICAgICAgdGhpcy5zdmdVdGlscyA9IHN2Z1V0aWxzO1xuICAgICAgICB0aGlzLnN5bWJvbFV0aWxzID0gc3ltYm9sVXRpbHM7XG4gICAgICAgIHRoaXMuY2ltU3ltYm9sVXRpbHMgPSBjaW1TeW1ib2xVdGlscztcbiAgICAgICAgdGhpcy53ZWJTdHlsZVN5bWJvbFV0aWxzID0gd2ViU3R5bGVTeW1ib2xVdGlscztcbiAgICAgICAgdGhpcy5sb2FkZWQgPSB0cnVlO1xuICAgIH1cbn07XG5mdW5jdGlvbiBpc0NJTVN5bWJvbChzeW1ib2wpIHtcbiAgICByZXR1cm4gKHN5bWJvbCA9PT0gbnVsbCB8fCBzeW1ib2wgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHN5bWJvbC50eXBlKSA9PT0gXCJjaW1cIjtcbn1cbmZ1bmN0aW9uIGlzU01TU3ltYm9sKHN5bWJvbCkge1xuICAgIHJldHVybiAoc3ltYm9sID09PSBudWxsIHx8IHN5bWJvbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogc3ltYm9sLnR5cGUpID09PSBcInNpbXBsZS1tYXJrZXJcIjtcbn1cbmZ1bmN0aW9uIGlzUE1TU3ltYm9sKHN5bWJvbCkge1xuICAgIHJldHVybiAoc3ltYm9sID09PSBudWxsIHx8IHN5bWJvbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogc3ltYm9sLnR5cGUpID09PSBcInBpY3R1cmUtbWFya2VyXCI7XG59XG5mdW5jdGlvbiBpc1NMU1N5bWJvbChzeW1ib2wpIHtcbiAgICByZXR1cm4gKHN5bWJvbCA9PT0gbnVsbCB8fCBzeW1ib2wgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHN5bWJvbC50eXBlKSA9PT0gXCJzaW1wbGUtbGluZVwiO1xufVxuZnVuY3Rpb24gaXNTRlNTeW1ib2woc3ltYm9sKSB7XG4gICAgcmV0dXJuIChzeW1ib2wgPT09IG51bGwgfHwgc3ltYm9sID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzeW1ib2wudHlwZSkgPT09IFwic2ltcGxlLWZpbGxcIjtcbn1cbmZ1bmN0aW9uIGlzUG9pbnRDSU0oc3ltYm9sKSB7XG4gICAgcmV0dXJuIHN5bWJvbC5kYXRhLnN5bWJvbC50eXBlID09PSBcIkNJTVBvaW50U3ltYm9sXCI7XG59XG5mdW5jdGlvbiBpc0xpbmVDSU0oc3ltYm9sKSB7XG4gICAgcmV0dXJuIHN5bWJvbC5kYXRhLnN5bWJvbC50eXBlID09PSBcIkNJTUxpbmVTeW1ib2xcIjtcbn1cbmZ1bmN0aW9uIGlzUG9seWdvbkNJTShzeW1ib2wpIHtcbiAgICByZXR1cm4gc3ltYm9sLmRhdGEuc3ltYm9sLnR5cGUgPT09IFwiQ0lNUG9seWdvblN5bWJvbFwiO1xufVxuXG5leHBvcnQgeyBpc1NNU1N5bWJvbCBhcyBhLCBpc1NGU1N5bWJvbCBhcyBiLCBpc1NMU1N5bWJvbCBhcyBjLCBpc1BNU1N5bWJvbCBhcyBkLCBlc3JpTW9kdWxlcyBhcyBlLCBpc1BvbHlnb25DSU0gYXMgZiwgZ2VvbWV0cnlUeXBlIGFzIGcsIGlzTGluZUNJTSBhcyBoLCBpc0NJTVN5bWJvbCBhcyBpLCBpc1BvaW50Q0lNIGFzIGogfTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3ltYm9sVXRpbHMtZjIwN2Q5NzkuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9