"use strict";
(self["webpackChunkexb_client"] = self["webpackChunkexb_client"] || []).push([["vendors-extensions_widgets_arcgis_analysis_node_modules_arcgis_arcgis-raster-function-editor_-3691da"],{

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/arcgis-raster-function-editor/dist/esm/interfaces-879f83d7.js":
/*!*******************************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/arcgis-raster-function-editor/dist/esm/interfaces-879f83d7.js ***!
  \*******************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   F: () => (/* binding */ FunctionType),
/* harmony export */   R: () => (/* binding */ RFxListViewMode)
/* harmony export */ });
/**
 * Defines how a raster function template is applied on an image service
 */
const FunctionType = {
    Mosaic: 0,
    Item: 1,
    ItemGroup: 2
};
/**
 * CORE: the list is shown in rfx-editor-core -> has an action item in the end of the function list item.
 */
const RFxListViewMode = {
    CORE: "CORE",
    STANDARD: "STANDARD"
};



//# sourceMappingURL=interfaces-879f83d7.js.map

/***/ }),

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/arcgis-raster-function-editor/dist/esm/localization-helper-4819b67d.js":
/*!****************************************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/arcgis-raster-function-editor/dist/esm/localization-helper-4819b67d.js ***!
  \****************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   D: () => (/* binding */ DefaultLocale),
/* harmony export */   S: () => (/* binding */ SupportedLocales),
/* harmony export */   a: () => (/* binding */ getDirectionBasedOnRTL),
/* harmony export */   b: () => (/* binding */ fetchComponentLocaleStrings),
/* harmony export */   f: () => (/* binding */ formatLocalizedHelpUrl),
/* harmony export */   g: () => (/* binding */ getLocaleInfo)
/* harmony export */ });
/**
 * Locale list reference [JSAPI](https://devtopia.esri.com/WebGIS/arcgis-js-api/tree/master/esri/nls)
 * also has Hindi: "hi"
 */
const SupportedLocales = {
    Arabic: "ar",
    Bosnian: "bs",
    Bulgarian: "bg",
    Catalan: "ca",
    Czech: "cs",
    Danish: "da",
    German: "de",
    Greek: "el",
    English: "en",
    EnglishUSA: "en-US",
    Spanish: "es",
    Estonian: "et",
    Finnish: "fi",
    French: "fr",
    Hebrew: "he",
    Hindi: "hi",
    Croatian: "hr",
    Hungarian: "hu",
    Indonesian: "id",
    Italian: "it",
    Japanese: "ja",
    Korean: "ko",
    Lithuanian: "lt",
    Latvian: "lv",
    NorwegianBokml: "nb",
    Dutch: "nl",
    Polish: "pl",
    PortugueseBrazil: "pt-BR",
    PortuguesePortugal: "pt-PT",
    Romanian: "ro",
    Russian: "ru",
    Serbian: "sr",
    Slovenian: "sl",
    Slovak: "sk",
    Swedish: "sv",
    Thai: "th",
    Turkish: "tr",
    Ukrainian: "uk",
    Vietnamese: "vi",
    ChineseChina: "zh-CN",
    ChineseHongKong: "zh-HK",
    ChineseTaiwan: "zh-TW"
};
const SupportedOnlineHelpLocales = ["ar", "de", "es", "fr", "it", "ja", "ko", "ru", "pl", "pt-br", "zh-cn"];
const LocaleMap = {
    "en-AU": "en",
    "en-CA": "en",
    "en-GB": "en",
    "en-US": "en",
    "es-ES": "es",
    "es-MX": "es",
    "de-CH": "de",
    "de-AT": "de",
    "de-DE": "de",
    "fr-CH": "fr",
    "fr-FR": "fr",
    "it-CH": "it",
    "it-IT": "it",
    ind: "id",
    ukr: "uk"
};
/**
 * List of supported locales that are RTL
 * reference: https://devtopia.esri.com/WebGIS/arcgis-js-api/blob/4master/esri/intl/locale.ts
 */
const RTLLocales = [SupportedLocales.Arabic, SupportedLocales.Hebrew];
const DefaultLocale = SupportedLocales.English;
/**
 * Utility to centralize logic, and return "rtl" or "rtl" depending on rtl boolean
 * @param {boolean} rtl whether locale is in Right to Left direction
 * @returns {"ltr" | "rtl"} codes that can be passed to "dir" prop of a component.
 */
function getDirectionBasedOnRTL(rtl) {
    return rtl === true ? "rtl" : "ltr";
}
/**
 * Helper function to find the closest element crossing multiple (parent) shadowDOM boundaries.
 * The implementation is based on [this](https://stackoverflow.com/questions/54520554/custom-element-getrootnode-closest-function-crossing-multiple-parent-shadowd) solution.
 *
 * @param {string} selector
 * @param {Element} base
 */
function getClosestElement(selector, base) {
    function closestFrom(el) {
        let element;
        if (el === undefined || el === document || el === window)
            element = null;
        else {
            const found = el.closest(selector);
            element = found || closestFrom(el.getRootNode().host);
        }
        return element;
    }
    return closestFrom(base);
}
/**
 * Converts the given locale to a supported locale using the provided locale map.
 *
 * @param {string | undefined} locale - The locale to be converted.
 * @param {object} localeMap - A map of locales to supported locales.
 * @returns {string} - The supported locale.
 */
function convertToSupportedLocale(locale, localeMap) {
    const defaultLocale = DefaultLocale;
    let localeSanitized = locale?.toLowerCase();
    if (localeSanitized !== undefined && localeSanitized.indexOf("-") !== -1) {
        const [lang, region] = localeSanitized.split("-");
        localeSanitized = `${lang}-${region.toUpperCase()}`;
    }
    if (!localeSanitized) {
        return defaultLocale;
    }
    const localeMapKeys = Object.keys(LocaleMap);
    if (localeMapKeys.includes(localeSanitized) === true) {
        return localeMap[localeSanitized];
    }
    return localeSanitized;
}
/**
 * Retrieves locale information; In the case of Regional codes (en-au) it is converted to a supported locale (en).
 *
 * @param {Element} [element=document.documentElement] - The element to search for locale information.
 * @returns {Object} An object containing the locale information.
 * @property {string} locale - The locale code.
 * @property {boolean} rtl - A flag indicating whether the locale is right-to-left.
 */
function getLocaleInfo(element = document.documentElement) {
    // Gets the closest element with a lang attribute and falls back to navigator.language if not found
    const closestElement = getClosestElement("[lang]", element);
    const locale = closestElement?.lang ?? window.navigator.language;
    const supportedLocales = Object.values(SupportedLocales);
    const defaultLocale = DefaultLocale;
    const convertedLocale = convertToSupportedLocale(locale, LocaleMap);
    const isSupportedLocale = supportedLocales.includes(convertedLocale);
    return {
        locale: isSupportedLocale ? convertedLocale : defaultLocale,
        rtl: RTLLocales.includes(locale)
    };
}
/**
 * Fetches the locale file of the given component; defaults to `"en"` locale
 * @param componentName
 * @param props
 * @param locale
 * @param resourcesUrl
 * @param props.path
 * @param props.locale
 * @param props.baseURL
 */
async function fetchLocaleStrings(props) {
    const { path, locale, baseURL } = props;
    // Using the getPublicPath method that leverages `data-resources-url` currently this is not working.
    // const rUrl = getPublicPath(componentName) || resourcesUrl;
    let localeData = {};
    try {
        const response = await fetch(`${baseURL}t9n/${path}.t9n.${locale}.json`);
        localeData = await response.json();
    }
    catch (e) {
        const defaultResponse = await fetch(`${baseURL}t9n/${path}.t9n.${DefaultLocale}.json`);
        localeData = await defaultResponse.json();
    }
    return localeData;
}
async function fetchComponentLocaleStrings(element, baseURL) {
    const componentName = element.tagName.toLowerCase();
    const { locale, rtl } = getLocaleInfo(element);
    const strings = await fetchLocaleStrings({ path: componentName, locale, baseURL });
    return { strings, dir: getDirectionBasedOnRTL(rtl), locale: locale };
}
/**
 * Formats a URL to link to
 * @param {string} url the url string from after the locale
 * @param {string} basePath the base path from the signed in portal object.
 * @param {string} locale the locale abbreviation for the browser.
 * @returns {string} the formatted url.
 */
function formatLocalizedHelpUrl(url, basePath, locale = "en") {
    let localeSanitized = locale;
    const localeMapKeys = Object.keys(LocaleMap);
    if (localeMapKeys.includes(locale) === true) {
        localeSanitized = LocaleMap[locale];
    }
    const localeInLowerCase = localeSanitized.toLocaleLowerCase();
    if (SupportedOnlineHelpLocales.includes(localeInLowerCase) === true) {
        // following regex tests /en/ is present in url and replaces it with the locale
        // https://docdev.arcgis.com/en/arcgis-online/analyze/aggregate-points-mv.htm
        // self Response only provides with `en` locale not as per the user locale or current app locale
        // so we need this replace call.
        basePath = basePath.replace(/^https?:\/\/[^/]+\/en/, (match) => match.replace("en", localeInLowerCase));
    }
    const learnMoreUrl = `${basePath}analyze/${url}`;
    return learnMoreUrl;
}



//# sourceMappingURL=localization-helper-4819b67d.js.map

/***/ }),

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/arcgis-raster-function-editor/dist/esm/rfx-functions-list_3.entry.js":
/*!**************************************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/arcgis-raster-function-editor/dist/esm/rfx-functions-list_3.entry.js ***!
  \**************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   rfx_functions_list: () => (/* binding */ RfxFunctionsList),
/* harmony export */   rfx_list_view: () => (/* binding */ RasterFunctionsList),
/* harmony export */   rfx_search: () => (/* binding */ RfxSearch)
/* harmony export */ });
/* harmony import */ var _index_da1b7138_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index-da1b7138.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/arcgis-raster-function-editor/dist/esm/index-da1b7138.js");
/* harmony import */ var _localization_helper_4819b67d_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./localization-helper-4819b67d.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/arcgis-raster-function-editor/dist/esm/localization-helper-4819b67d.js");
/* harmony import */ var _arcgis_core_core_lang_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @arcgis/core/core/lang.js */ "@arcgis/core/core/lang.js");
/* harmony import */ var _ui_utils_928a4096_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ui-utils-928a4096.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/arcgis-raster-function-editor/dist/esm/ui-utils-928a4096.js");
/* harmony import */ var _arcgis_core_identity_IdentityManager_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @arcgis/core/identity/IdentityManager.js */ "@arcgis/core/identity/IdentityManager.js");
/* harmony import */ var _arcgis_core_core_urlUtils_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @arcgis/core/core/urlUtils.js */ "@arcgis/core/core/urlUtils.js");
/* harmony import */ var _arcgis_core_layers_Layer_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @arcgis/core/layers/Layer.js */ "@arcgis/core/layers/Layer.js");
/* harmony import */ var _arcgis_core_layers_ImageryLayer_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @arcgis/core/layers/ImageryLayer.js */ "@arcgis/core/layers/ImageryLayer.js");
/* harmony import */ var _arcgis_core_smartMapping_raster_renderers_stretch_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @arcgis/core/smartMapping/raster/renderers/stretch.js */ "@arcgis/core/smartMapping/raster/renderers/stretch.js");
/* harmony import */ var _common_fda1462e_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./common-fda1462e.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/arcgis-raster-function-editor/dist/esm/common-fda1462e.js");
/* harmony import */ var _arcgis_core_rest_support_AlgorithmicColorRamp_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @arcgis/core/rest/support/AlgorithmicColorRamp.js */ "@arcgis/core/rest/support/AlgorithmicColorRamp.js");
/* harmony import */ var _arcgis_core_rest_support_MultipartColorRamp_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @arcgis/core/rest/support/MultipartColorRamp.js */ "@arcgis/core/rest/support/MultipartColorRamp.js");
/* harmony import */ var _arcgis_core_Color_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @arcgis/core/Color.js */ "@arcgis/core/Color.js");
/* harmony import */ var _colorRampUtils_8bdd46c5_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./colorRampUtils-8bdd46c5.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/arcgis-raster-function-editor/dist/esm/colorRampUtils-8bdd46c5.js");
/* harmony import */ var _arcgis_core_rest_geoprocessor_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! @arcgis/core/rest/geoprocessor.js */ "@arcgis/core/rest/geoprocessor.js");
/* harmony import */ var _arcgis_core_request_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! @arcgis/core/request.js */ "@arcgis/core/request.js");
/* harmony import */ var _arcgis_core_portal_PortalItem_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! @arcgis/core/portal/PortalItem.js */ "@arcgis/core/portal/PortalItem.js");
/* harmony import */ var _interfaces_879f83d7_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./interfaces-879f83d7.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/arcgis-raster-function-editor/dist/esm/interfaces-879f83d7.js");
/* harmony import */ var _functions_f1f2dffd_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./functions-f1f2dffd.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/arcgis-raster-function-editor/dist/esm/functions-f1f2dffd.js");
/* harmony import */ var _Uint8Array_68e1e3f9_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./_Uint8Array-68e1e3f9.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/arcgis-raster-function-editor/dist/esm/_Uint8Array-68e1e3f9.js");
/* harmony import */ var _getTag_96af029d_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./_getTag-96af029d.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/arcgis-raster-function-editor/dist/esm/_getTag-96af029d.js");
/* harmony import */ var _resources_27c66f5c_js__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./resources-27c66f5c.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/arcgis-raster-function-editor/dist/esm/resources-27c66f5c.js");
/* harmony import */ var _type_gaurds_1840747f_js__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./type-gaurds-1840747f.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/arcgis-raster-function-editor/dist/esm/type-gaurds-1840747f.js");
























const HTMLClasses$1 = {
    noResultsContainer: "no-results-container",
    toolCategoryWrapper: "tool-category-wrapper",
    noResultsIcon: "no-results-icon",
    toolsListItem: "tools-list-item"
};

const rfxFunctionsListCss = ":root{--calcite-color-brand:#007ac2;--calcite-color-brand-hover:#00619b;--calcite-color-brand-press:#004874;--calcite-color-status-info:#00619b;--calcite-color-status-success:#35ac46;--calcite-color-status-warning:#edd317;--calcite-color-status-danger:#d83020;--calcite-color-status-danger-hover:#a82b1e;--calcite-color-status-danger-press:#7c1d13;--calcite-color-background:#f8f8f8;--calcite-color-foreground-1:#ffffff;--calcite-color-foreground-2:#f3f3f3;--calcite-color-foreground-3:#eaeaea;--calcite-color-text-1:#151515;--calcite-color-text-2:#4a4a4a;--calcite-color-text-3:#6a6a6a;--calcite-color-text-inverse:#ffffff;--calcite-color-text-link:#00619b;--calcite-color-border-1:#cacaca;--calcite-color-border-2:#d4d4d4;--calcite-color-border-3:#dfdfdf;--calcite-color-border-input:#949494;--rfx-quarter-spacing:0.25rem;--rfx-half-spacing:0.5rem;--rfx-three-quarter-spacing:0.75rem;--rfx-full-spacing:1rem;--rfx-component-default-width:100%;--rfx-ui-border-input:var(--calcite-color-border-2);--rfx-popover-content-min-height:30vh;--rfx-popover-content-max-height:60vh;--rfx-popover-content-height:45vh;--rfx-widget-content-height:30vh}:host{display:flex;flex-direction:column;flex-wrap:wrap}.tool-category-wrapper{width:100%}.no-results-container{justify-content:center;display:flex;flex-direction:column;width:100%;align-items:center;color:var(--calcite-color-text-3)}.no-results-icon{margin-top:1.5rem}";

const RfxFunctionsList = class {
    constructor(hostRef) {
        (0,_index_da1b7138_js__WEBPACK_IMPORTED_MODULE_0__.r)(this, hostRef);
        this.triggerChangePanel = (0,_index_da1b7138_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, "triggerChangePanel", 7);
        this.triggerSelectTool = (0,_index_da1b7138_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, "triggerSelectTool", 7);
        this.openCategoriesChange = (0,_index_da1b7138_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, "openCategoriesChange", 7);
        /**
         * Gets called when the user selects the tool
         * @param rfxFunctionItem
         * @category Private
         */
        this.modifyPanelState = (rfxFunctionItem) => {
            this.triggerSelectTool.emit(rfxFunctionItem);
            this.triggerChangePanel.emit(1);
        };
        /**
         * Gets called to render the tool icon
         * @param rfxFunctionItem
         * @category Private
         */
        this.getRfxFunctionIcon = (rfxFunctionItem) => {
            let icon = "";
            // const { analysisEngine } = rfxFunctionItem;
            // TODO: logic can be reused when each function has unique icon
            const functionTypes = ["raster", "geoanalytics"];
            const functionType = functionTypes[0];
            switch (functionType) {
                case "raster":
                    icon = "raster-analysis";
                    break;
                case "geoanalytics":
                    icon = "map-pin";
                    break;
                default:
                    icon = "hammer";
            }
            return rfxFunctionItem.icon ?? icon;
        };
        /**
         * Gets called to render the function icon
         * @category Private
         */
        this.displayResults = () => {
            const keys = Array.from(this.rfxFunctionsMap.keys());
            return this.searchIsActive ? ((0,_index_da1b7138_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-list", { selectionAppearance: "border" }, this.renderFunctionSearchList(keys))) : (this.renderRfxFunctionsCategoriesList(keys));
        };
        /**
         * Renders searched calcite-list-items when search is active
         * @param keys Toolmap keys
         * @returns array of category calcite-lists
         * @category Private
         */
        this.renderFunctionSearchList = (keys) => {
            const calciteListItems = [];
            keys.map((category) => {
                const functionsInCategory = this.rfxFunctionsMap.get(category);
                if (functionsInCategory !== undefined && functionsInCategory.length > 0) {
                    calciteListItems.push(...this.renderRfxFunctions(category));
                }
            });
            return calciteListItems;
        };
        /**
         * Renders all the lists when search is not active
         * @param keys Toolmap keys
         * @returns array of category calcite-lists
         * @category Private
         */
        this.renderRfxFunctionsCategoriesList = (keys) => {
            const rfxFunctionCategoryBlocks = keys.map((category, i) => {
                const functionsInCategory = this.rfxFunctionsMap.get(category);
                if (functionsInCategory !== undefined && functionsInCategory.length > 0) {
                    return ((0,_index_da1b7138_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-block", { class: HTMLClasses$1.toolCategoryWrapper, dir: this.dir, heading: this.rfxFunctionsMap.get(category)[0].categoryTitle, collapsible: true, open: this.openCategories.has(i), onCalciteBlockToggle: () => this.openCategoriesChange.emit(i) }, (0,_index_da1b7138_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-list", { selectionAppearance: "border" }, this.renderRfxFunctions(category))));
                }
            });
            return rfxFunctionCategoryBlocks;
        };
        /**
         * Renders the no results message and icon
         * @category Render UX
         */
        this.renderNoResults = () => {
            return ((0,_index_da1b7138_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: HTMLClasses$1.noResultsContainer }, (0,_index_da1b7138_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-icon", { class: HTMLClasses$1.noResultsIcon, icon: "search", scale: "m" }), (0,_index_da1b7138_js__WEBPACK_IMPORTED_MODULE_0__.h)("p", null, this.strings.noResults)));
        };
        /**
         * Renders tooltip with function description
         * @category Render UX
         */
        this.createRfxFunctionCategoryHelp = () => {
            this.rfxFunctionHelpTooltip = document.createElement("calcite-tooltip");
            document.body.appendChild(this.rfxFunctionHelpTooltip);
        };
        /**
         * Calls the createRfxFunctionCategoryHelp method to show the tooltip after a 500 millisecond delay
         * @param e
         * @param toolTitle
         * @param toolDescription
         * @category Event Handler
         */
        this.showRfxFunctionTooltip = (e, toolTitle, toolDescription) => {
            this.removeHelpTooltip();
            const targetElement = e.target;
            this.createRfxFunctionCategoryHelp();
            if (this.rfxFunctionHelpTooltip !== undefined && targetElement !== undefined) {
                this.rfxFunctionHelpTooltip.referenceElement = targetElement;
                this.rfxFunctionHelpTooltip.placement = "left";
                this.rfxFunctionHelpTooltip.innerText =
                    toolDescription ?? (0,_common_fda1462e_js__WEBPACK_IMPORTED_MODULE_9__.f)(this.strings.defaultToolDescription, { toolTitle });
                this.hoverTimer = setTimeout(() => {
                    if (this.rfxFunctionHelpTooltip !== undefined) {
                        this.rfxFunctionHelpTooltip.open = true;
                    }
                }, 500);
            }
        };
        /**
         * Removes tooltip for tool
         * @category Private
         */
        this.removeHelpTooltip = () => {
            clearTimeout(this.hoverTimer);
            if (this.rfxFunctionHelpTooltip !== undefined) {
                this.rfxFunctionHelpTooltip?.remove();
                this.rfxFunctionHelpTooltip.open = false;
            }
        };
        /**
         * Renders the list of functions
         * @category Render UX
         * @param category
         * @returns HTMLElement
         */
        this.renderRfxFunctions = (category) => {
            return (this.rfxFunctionsMap.get(category)?.map((rfxFunctionItem) => {
                return ((0,_index_da1b7138_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-list-item", { class: HTMLClasses$1.toolsListItem, label: rfxFunctionItem.title, description: this.showFunctionDescription === true ? rfxFunctionItem.description : "", onClick: () => this.isEmbeddedInCoreApp ? null : this.modifyPanelState(rfxFunctionItem), onMouseOver: (event) => this.showRfxFunctionTooltip(event, rfxFunctionItem.title, rfxFunctionItem.description), onMouseOut: this.removeHelpTooltip, value: `${category}_${rfxFunctionItem.toolName}`, key: `${category}_${rfxFunctionItem.toolName}`, scale: this.scale }, (0,_index_da1b7138_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-icon", { icon: this.getRfxFunctionIcon(rfxFunctionItem), slot: "content-start", scale: this.scale }), this.isEmbeddedInCoreApp ? ((0,_index_da1b7138_js__WEBPACK_IMPORTED_MODULE_0__.h)(_index_da1b7138_js__WEBPACK_IMPORTED_MODULE_0__.F, null, (0,_index_da1b7138_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-icon", { id: "add-tool", icon: "plus-circle", slot: "content-end", scale: this.scale, onClick: () => this.modifyPanelState(rfxFunctionItem) }), (0,_index_da1b7138_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-tooltip", { referenceElement: "add-tool", label: "Hello" }, (0,_index_da1b7138_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", null, "Hello")))) : null));
            }) ?? []);
        };
        this.categories = undefined;
        this.mode = _interfaces_879f83d7_js__WEBPACK_IMPORTED_MODULE_17__.R.STANDARD;
        this.rfxFunctionsArray = [];
        this.searchIsActive = undefined;
        this.scale = _ui_utils_928a4096_js__WEBPACK_IMPORTED_MODULE_3__.U.Scale;
        this.showFunctionDescription = undefined;
        this.openCategories = new Set([0]);
        this.rfxFunctionsMap = new Map();
    }
    onBuildRfxFunctionsMap() {
        const newFunctionsMap = new Map();
        for (let i = 0; i < this.categories?.length; i += 1) {
            newFunctionsMap.set(this.categories[i], this.rfxFunctionsArray.filter((rfxFunctionItem) => {
                return rfxFunctionItem.categoryName === this.categories[i];
            }));
        }
        this.rfxFunctionsMap = newFunctionsMap;
    }
    get isEmbeddedInCoreApp() {
        return this.mode === _interfaces_879f83d7_js__WEBPACK_IMPORTED_MODULE_17__.R.CORE;
    }
    /**
     * @category Lifecycle
     */
    async componentWillLoad() {
        ({ strings: this.strings, dir: this.dir } = await (0,_localization_helper_4819b67d_js__WEBPACK_IMPORTED_MODULE_1__.b)(this.hostElement, (0,_index_da1b7138_js__WEBPACK_IMPORTED_MODULE_0__.g)(`.`)));
        this.onBuildRfxFunctionsMap();
    }
    /**
     * @category Lifestyle
     */
    disconnectedCallback() {
        this.removeHelpTooltip();
        this.rfxFunctionHelpTooltip?.remove();
    }
    /**
     * @category Lifecycle
     * Render lifecycle method
     */
    render() {
        return ((0,_index_da1b7138_js__WEBPACK_IMPORTED_MODULE_0__.h)(_index_da1b7138_js__WEBPACK_IMPORTED_MODULE_0__.H, null, this.rfxFunctionsArray.length > 0 ? this.displayResults() : this.renderNoResults()));
    }
    static get assetsDirs() { return ["t9n"]; }
    get hostElement() { return (0,_index_da1b7138_js__WEBPACK_IMPORTED_MODULE_0__.a)(this); }
    static get watchers() { return {
        "categories": ["onBuildRfxFunctionsMap"],
        "rfxFunctionsArray": ["onBuildRfxFunctionsMap"]
    }; }
};
RfxFunctionsList.style = rfxFunctionsListCss;

const RasterFunctionsList = class {
    constructor(hostRef) {
        (0,_index_da1b7138_js__WEBPACK_IMPORTED_MODULE_0__.r)(this, hostRef);
        this.triggerSelectFunction = (0,_index_da1b7138_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, "triggerSelectFunction", 7);
        /**
         *  Analysis studio search's calcite filter's value
         *  @category Private
         */
        this.searchValue = "";
        /**
         * The most recent filter selection, to filter search results
         * @category Private
         */
        this.filterValue = [];
        /**
         * @category Private
         * @param event the search results
         */
        this.searchCallback = (event) => {
            this.searchValue = event.detail.searchValue;
            this.functionsList = [...event.detail.rfxFunctions];
            this.filterValue = [...event.detail.filterValue];
        };
        /**
         * handler called as soon as the panel changes
         * @category Private
         * @param panelChangeEvent custom event containing the direction where the flow is to move
         */
        this.handleTriggerPanelChange = (panelChangeEvent) => {
        };
        /**
         * handler called as soon as a rfx is opened or selected from the rfx list
         * @category Private
         * @param selectToolEvent custom event containing the data for the tool selected
         */
        this.handleTriggerSelectTool = (selectToolEvent) => {
            const selectedRFx = selectToolEvent.detail;
            this.triggerSelectFunction.emit(selectedRFx.toolName);
        };
        /**
         * handler called as soon as a category in the list is open
         * @category Private
         * @param event custom event containing the category number
         */
        this.handleOpenCategoryChange = (event) => {
            const categoryNumber = event.detail;
            if (this.openCategories.has(categoryNumber)) {
                this.openCategories.delete(categoryNumber);
            }
            else {
                this.openCategories.add(categoryNumber);
            }
        };
        this.functionsList = [];
        this.mode = undefined;
        this.openCategories = new Set([0]);
        this.showToolDescription = undefined;
        this.scale = _ui_utils_928a4096_js__WEBPACK_IMPORTED_MODULE_3__.U.Scale;
    }
    //--------------------------------------------------------------------------
    //
    //  Public Methods
    //
    //--------------------------------------------------------------------------
    /**
     * @category Lifecycle
     */
    async connectedCallback() {
        const { rfxFunctions, rfxCategories } = await (0,_functions_f1f2dffd_js__WEBPACK_IMPORTED_MODULE_18__.a)();
        this.rfxFunctionsArray = rfxFunctions.map((rasterTool) => {
            return {
                analysisEngine: "raster",
                categoryName: rasterTool.category,
                categoryTitle: rasterTool.categoryTitle,
                description: rasterTool.snippet,
                icon: "raster-function",
                title: rasterTool.title,
                toolName: rasterTool.name,
                analysisType: "rft"
            };
        });
        if (this.rfxFunctionsArray?.length > -1) {
            this.rfxCategories = rfxCategories;
            this.functionsList = [...this.rfxFunctionsArray];
        }
    }
    render() {
        return ((0,_index_da1b7138_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", null, (0,_index_da1b7138_js__WEBPACK_IMPORTED_MODULE_0__.h)("rfx-search", { rfxFunctionsArray: this.rfxFunctionsArray ?? [], onAnalysisStudioSearchUpdate: this.searchCallback, searchValue: this.searchValue, filterValue: this.filterValue, hideFilter: true }), (0,_index_da1b7138_js__WEBPACK_IMPORTED_MODULE_0__.h)("rfx-functions-list", { rfxFunctionsArray: this.functionsList, categories: this.rfxCategories, searchIsActive: this.searchValue !== "", showFunctionDescription: false, mode: this.mode, scale: this.scale, onTriggerChangePanel: this.handleTriggerPanelChange, onTriggerSelectTool: this.handleTriggerSelectTool, openCategories: this.openCategories, onOpenCategoriesChange: this.handleOpenCategoryChange })));
    }
};

const HTMLClasses = {
    actionPadding: "action-padding",
    rtl: "analysis--rtl"
};

const rfxSearchCss = ":root{--calcite-color-brand:#007ac2;--calcite-color-brand-hover:#00619b;--calcite-color-brand-press:#004874;--calcite-color-status-info:#00619b;--calcite-color-status-success:#35ac46;--calcite-color-status-warning:#edd317;--calcite-color-status-danger:#d83020;--calcite-color-status-danger-hover:#a82b1e;--calcite-color-status-danger-press:#7c1d13;--calcite-color-background:#f8f8f8;--calcite-color-foreground-1:#ffffff;--calcite-color-foreground-2:#f3f3f3;--calcite-color-foreground-3:#eaeaea;--calcite-color-text-1:#151515;--calcite-color-text-2:#4a4a4a;--calcite-color-text-3:#6a6a6a;--calcite-color-text-inverse:#ffffff;--calcite-color-text-link:#00619b;--calcite-color-border-1:#cacaca;--calcite-color-border-2:#d4d4d4;--calcite-color-border-3:#dfdfdf;--calcite-color-border-input:#949494;--rfx-quarter-spacing:0.25rem;--rfx-half-spacing:0.5rem;--rfx-three-quarter-spacing:0.75rem;--rfx-full-spacing:1rem;--rfx-component-default-width:100%;--rfx-ui-border-input:var(--calcite-color-border-2);--rfx-popover-content-min-height:30vh;--rfx-popover-content-max-height:60vh;--rfx-popover-content-height:45vh;--rfx-widget-content-height:30vh}:host{display:flex;background-color:var(--calcite-color-foreground-1);border-bottom:1px solid var(--calcite-color-border-3)}.action-padding{padding-right:var(--analysis-half-spacing);padding-left:0rem}:host(.analysis--rtl) .action-padding{padding-left:var(--analysis-half-spacing);padding-right:0rem}";

const RfxSearch = class {
    constructor(hostRef) {
        (0,_index_da1b7138_js__WEBPACK_IMPORTED_MODULE_0__.r)(this, hostRef);
        this.analysisStudioSearchUpdate = (0,_index_da1b7138_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, "analysisStudioSearchUpdate", 7);
        /**
         * TODO: Currently filter is hidden and doesn't work.
         * Applies the filter to an input
         * @param data
         * @param filterSelection
         * @category private
         */
        this.filterList = (data, filterSelection) => {
            // return data.filter((rfxFunctionItem: RfxFunctionItem) => {
            // return filterSelection.length === 0 ? true : filterSelection.includes(rfxFunctionItem.analysisEngine);
            // });
            return data.filter(() => {
                return filterSelection.length === 0 ? true : false;
            });
        };
        /**
         * Creates the array of functions that only contain searchable information
         * @param data
         * @category private
         */
        this.getSearchableFunctionsList = (data) => {
            const rfxFunctions = data ?? this.rfxFunctionsArray;
            return rfxFunctions.map((rfxFunctionItem) => {
                return {
                    title: rfxFunctionItem.title,
                    toolName: rfxFunctionItem.toolName,
                    keys: rfxFunctionItem.keys
                };
            });
        };
        /**
         * Backtracks from an array of RfxSearchableItems to RfxFunctionItems
         * @param searchList
         * @category private
         */
        this.getToolsListFromSearchList = (searchList) => {
            return searchList.map((searchableItem) => {
                return this.rfxFunctionsArray.filter((rfxFunctionItem) => {
                    return (searchableItem.title === rfxFunctionItem.title &&
                        searchableItem.toolName === rfxFunctionItem.toolName);
                })[0];
            });
        };
        /**
         * Called whenever the search is updated and emits an event to parent components containing the results of the search
         * @category Private
         * @param event the results of the search
         */
        this.onAnalysisStudioSearchUpdate = () => {
            if (this.calciteFilter.value !== this.searchValue) {
                const filterResult = this.calciteFilter.filteredItems;
                const filteredFunctions = this.filterList(this.getToolsListFromSearchList(filterResult), this.filterValue);
                this.rfxFunctionItems = [...filteredFunctions];
                this.analysisStudioSearchUpdate.emit({
                    rfxFunctions: this.rfxFunctionItems,
                    searchValue: this.calciteFilter.value ?? "",
                    filterValue: this.filterValue
                });
            }
        };
        /**
         * This function is called when the filter selection is updated and emits an event
         * with updated filter and search values
         * @param {string} filterItemValue the value of the filter item that was selected
         * @category private
         */
        this.handleFilterItemSelection = (filterItemValue) => {
            const isSelected = this.filterValue.includes(filterItemValue);
            const newFilterSelection = isSelected === false
                ? [...this.filterValue, filterItemValue]
                : this.filterValue.filter((value) => value !== filterItemValue);
            const data = this.calciteFilter.value === ""
                ? this.rfxFunctionsArray
                : this.getToolsListFromSearchList(this.calciteFilter.filteredItems);
            this.rfxFunctionItems = this.filterList(data, newFilterSelection);
            this.analysisStudioSearchUpdate.emit({
                rfxFunctions: this.rfxFunctionItems,
                searchValue: this.searchValue ?? "",
                filterValue: newFilterSelection
            });
        };
        this.open = false;
        this.rfxFunctionItems = undefined;
        this.rfxFunctionsArray = undefined;
        this.searchValue = undefined;
        this.filterValue = undefined;
        this.placeholderText = undefined;
        this.hideFilter = false;
    }
    onDataChange(newValue) {
        this.getSearchableFunctionsList(newValue);
    }
    /**
     * @category Lifecycle
     */
    async componentWillLoad() {
        ({ strings: this.strings, dir: this.dir } = await (0,_localization_helper_4819b67d_js__WEBPACK_IMPORTED_MODULE_1__.b)(this.hostElement, (0,_index_da1b7138_js__WEBPACK_IMPORTED_MODULE_0__.g)(`.`)));
        // TODO: get locale, implemnt later when we add support for "keys"
        const commonT9n = {
            toolInfoKeys: {}
        };
        // const commonT9n = await fetchLocaleStrings({
        //   baseURL: `${getAssetPath("assets")}/`,
        //   locale: state.locale,
        //   path: "common"
        // });
        this.searchKeys = commonT9n.toolInfoKeys;
        this.rfxFunctionsArray.forEach((rfxFunctionItem) => {
            rfxFunctionItem.keys = (rfxFunctionItem.keys ?? []).map((key) => {
                const formattedKey = key.replace("$", "");
                return this.searchKeys?.[formattedKey];
            });
            return rfxFunctionItem;
        });
        this.rfxFunctionItems = [...this.rfxFunctionsArray];
    }
    /**
     * @category Lifecycle
     */
    componentDidLoad() {
        // Forces the calcite filter to generate filteredItems without
        // firing the search change event. Needed for filterValue updates
        // Issue documented in calcite-components repo #4111
        this.calciteFilter.items = [...this.calciteFilter.items];
    }
    /**
     * TODO: currently does no filtering, will be useful when filter support is added
     * Renders a dropdown item for the filter dropdown
     * @param {string} value the value of the dropdown item, used to determine if the item is selected
     * @param {string} label the label of the dropdown item
     * @category private
     */
    // private renderDropdownItem(value: string, label: string): HTMLCalciteDropdownItemElement {
    //   return (
    //     <calcite-dropdown-item
    //       key={value}
    //       label={label}
    //       selected={this.filterValue.includes(value)}
    //       onCalciteDropdownItemSelect={() => this.handleFilterItemSelection(value)}
    //     >
    //       {label}
    //     </calcite-dropdown-item>
    //   );
    // }
    /**
     * TODO: currently does no filtering, will be useful when filter support is added
     * Conditionally renders the dropdown menu that allows the user to filter the functions by type
     * if there is only one type of function, the dropdown is not rendered
     * @category private
     */
    // private renderDropdown(): HTMLCalciteDropdownGroupElement {
    //   const performableTypes = {
    //     // standard: state.canPerformStandard,
    //     // raster: state.canPerformRaster,
    //     standard: false,
    //     raster: true,
    //     geoanalytics: false // FIXME: Revert change once geoanalytics tools are available
    //   };
    //   // Only render the dropdown if there are multiple types of tools that can be performed
    //   const shouldRender =
    //     Object.values(performableTypes).filter((canPerform) => canPerform === true).length > 1;
    //   return (
    //     shouldRender && (
    //       <calcite-dropdown placement="bottom-start" overlayPositioning="fixed" closeOnSelectDisabled>
    //         <calcite-action
    //           text={this.strings.actionLabel}
    //           icon="sliders"
    //           appearance="solid"
    //           scale="s"
    //           class={HTMLClasses.actionPadding}
    //           slot="trigger"
    //         >
    //           <calcite-tooltip
    //             label={this.strings.actionLabel}
    //             overlayPositioning="fixed"
    //             closeOnClick
    //             slot="tooltip"
    //             placement="trailing"
    //           >
    //             {this.strings.actionLabel}
    //           </calcite-tooltip>
    //         </calcite-action>
    //         <calcite-dropdown-group
    //           key="tools-filter"
    //           groupTitle={this.strings.analysisEngine}
    //           selectionMode="multiple"
    //         >
    //           {performableTypes.raster &&
    //             this.renderDropdownItem("raster", this.strings.rasterAnalysis)}
    //         </calcite-dropdown-group>
    //       </calcite-dropdown>
    //     )
    //   );
    // }
    /**
     * @category Lifecycle
     * Render lifecycle method
     */
    render() {
        return ((0,_index_da1b7138_js__WEBPACK_IMPORTED_MODULE_0__.h)(_index_da1b7138_js__WEBPACK_IMPORTED_MODULE_0__.H, { class: { [HTMLClasses.rtl]: this.dir === "rtl" } }, (0,_index_da1b7138_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-filter", { placeholder: this.placeholderText ?? this.strings.defaultSearchPlaceholder, items: this.getSearchableFunctionsList(this.rfxFunctionsArray), onCalciteFilterChange: this.onAnalysisStudioSearchUpdate, value: this.searchValue, ref: (e) => {
                this.calciteFilter = e;
            }, dir: this.dir })));
    }
    static get assetsDirs() { return ["t9n"]; }
    get hostElement() { return (0,_index_da1b7138_js__WEBPACK_IMPORTED_MODULE_0__.a)(this); }
    static get watchers() { return {
        "rfxFunctionItems": ["onDataChange"]
    }; }
};
RfxSearch.style = rfxSearchCss;



//# sourceMappingURL=rfx-functions-list_3.entry.js.map

/***/ }),

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/arcgis-raster-function-editor/dist/esm/type-gaurds-1840747f.js":
/*!********************************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/arcgis-raster-function-editor/dist/esm/type-gaurds-1840747f.js ***!
  \********************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ ARGS_KEYWORD),
/* harmony export */   F: () => (/* binding */ FUNCTION_KEYWORD),
/* harmony export */   R: () => (/* binding */ RFV_TYPE),
/* harmony export */   T: () => (/* binding */ TYPE_KEYWORD),
/* harmony export */   a: () => (/* binding */ isRFxArg),
/* harmony export */   b: () => (/* binding */ RFT_TYPE),
/* harmony export */   c: () => (/* binding */ isReferencedObject),
/* harmony export */   d: () => (/* binding */ isNumber),
/* harmony export */   e: () => (/* binding */ isWidgetValueBoolean),
/* harmony export */   f: () => (/* binding */ isColorRamp),
/* harmony export */   g: () => (/* binding */ isRecordSet),
/* harmony export */   h: () => (/* binding */ isFeatureLayer),
/* harmony export */   i: () => (/* binding */ isEmptyDataItem),
/* harmony export */   j: () => (/* binding */ isTileLayer),
/* harmony export */   k: () => (/* binding */ isDynamicImageryLayer),
/* harmony export */   l: () => (/* binding */ isImageryLayer),
/* harmony export */   m: () => (/* binding */ isImageryTileLayer)
/* harmony export */ });
/* harmony import */ var _getTag_96af029d_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_getTag-96af029d.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/arcgis-raster-function-editor/dist/esm/_getTag-96af029d.js");


/** `Object#toString` result references. */
var mapTag = '[object Map]',
    setTag = '[object Set]';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Checks if `value` is an empty object, collection, map, or set.
 *
 * Objects are considered empty if they have no own enumerable string keyed
 * properties.
 *
 * Array-like values such as `arguments` objects, arrays, buffers, strings, or
 * jQuery-like collections are considered empty if they have a `length` of `0`.
 * Similarly, maps and sets are considered empty if they have a `size` of `0`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is empty, else `false`.
 * @example
 *
 * _.isEmpty(null);
 * // => true
 *
 * _.isEmpty(true);
 * // => true
 *
 * _.isEmpty(1);
 * // => true
 *
 * _.isEmpty([1, 2, 3]);
 * // => false
 *
 * _.isEmpty({ 'a': 1 });
 * // => false
 */
function isEmpty(value) {
  if (value == null) {
    return true;
  }
  if ((0,_getTag_96af029d_js__WEBPACK_IMPORTED_MODULE_0__.i)(value) &&
      ((0,_getTag_96af029d_js__WEBPACK_IMPORTED_MODULE_0__.a)(value) || typeof value == 'string' || typeof value.splice == 'function' ||
        (0,_getTag_96af029d_js__WEBPACK_IMPORTED_MODULE_0__.b)(value) || (0,_getTag_96af029d_js__WEBPACK_IMPORTED_MODULE_0__.c)(value) || (0,_getTag_96af029d_js__WEBPACK_IMPORTED_MODULE_0__.d)(value))) {
    return !value.length;
  }
  var tag = (0,_getTag_96af029d_js__WEBPACK_IMPORTED_MODULE_0__.g)(value);
  if (tag == mapTag || tag == setTag) {
    return !value.size;
  }
  if ((0,_getTag_96af029d_js__WEBPACK_IMPORTED_MODULE_0__.e)(value)) {
    return !(0,_getTag_96af029d_js__WEBPACK_IMPORTED_MODULE_0__.f)(value).length;
  }
  for (var key in value) {
    if (hasOwnProperty.call(value, key)) {
      return false;
    }
  }
  return true;
}

const RFT_TYPE = "RasterFunctionTemplate";
const TYPE_KEYWORD = "type";
const RFV_TYPE = "RasterFunctionVariable";
const ARGS_KEYWORD = "arguments";
const FUNCTION_KEYWORD = "function";
function isReferencedObject(obj) {
    if (!obj) {
        return false;
    }
    if (obj._object_ref_id != null) {
        return true;
    }
    return false;
}
function isNumber(x) {
    x = String(x).trim();
    if (x === "") {
        return false;
    }
    return /^[+-]?(\d+)?(\.\d+)?$/.test(x);
}
function isWidgetValueBoolean(x) {
    x = String(x).trim();
    return ["true", "false"].indexOf(x) >= 0;
}
function isColorRamp(rfxArg) {
    if (!rfxArg) {
        return false;
    }
    if (rfxArg.type && rfxArg.type.toLowerCase().indexOf("colorramp") >= 0) {
        return true;
    }
    if (rfxArg.value && rfxArg.value.type && rfxArg.value.type.toLowerCase().indexOf("colorramp") >= 0) {
        return true;
    }
    return false;
}
function isRecordSet(rfxArg) {
    return rfxArg.type && rfxArg.type.toLowerCase().indexOf("recordset") >= 0;
}
/**
 * Determines whether the given RFT element is an RFx argument.
 *
 * @param {any} rftElement - The RFT element to check.
 * @returns {boolean} `true` if the given element is RasterFunctionTemplate,
 * RasterFunctionVariable, isColorRamp, isRecordSet; `false` otherwise.
 */
function isRFxArg(rftElement) {
    if (!rftElement) {
        return false;
    }
    const type = rftElement.type;
    return [RFT_TYPE, RFV_TYPE].indexOf(type) >= 0 || isColorRamp(rftElement) || isRecordSet(rftElement);
}
/**
 * Determines if the input is a FeatureLayer
 * @param {__esri.Layer} layer the layer to check the type of
 * @returns {layer is __esri.FeatureLayer} layer is a FeatureLayer
 */
function isFeatureLayer(layer) {
    return layer.type === "feature";
}
/**
 * Determines if the input is a TileLayer
 * @param {__esri.Layer} layer the layer to check the type of
 * @returns {layer is __esri.TileLayer} layer is a TileLayer
 */
function isTileLayer(layer) {
    return layer.type === "tile";
}
/**
 * Determines if the input is a ImageryTileLayer
 * @param {__esri.Layer} layer the layer to check the type of
 * @returns {layer is __esri.ImageryLayer} layer is a ImageryLayer
 */
function isDynamicImageryLayer(layer) {
    return (layer.type === "imagery-tile" &&
        layer.sourceJSON.capabilities.toLowerCase().indexOf("tilesonly") < 0);
}
/**
 * Determines if the input is a ImageryLayer
 * @param {__esri.Layer} layer the layer to check the type of
 * @returns {layer is __esri.ImageryLayer} layer is a ImageryLayer
 */
function isImageryLayer(layer) {
    return layer.type === "imagery" || isDynamicImageryLayer(layer);
}
/**
 * Determines if the input is a ImageryTileLayer
 * @param {__esri.Layer} layer the layer to check the type of
 * @returns {layer is __esri.ImageryTileLayer} layer is a ImageryTileLayer
 */
function isImageryTileLayer(layer) {
    return layer.type === "imagery-tile" && !isDynamicImageryLayer(layer);
}
function isEveryPropertyEmpty(value) {
    let isAllPropsEmpty = true;
    if (typeof value === "object" && (0,_getTag_96af029d_js__WEBPACK_IMPORTED_MODULE_0__.a)(value) === false) {
        // using for-in as it will work with objects with properties that set via accessors as well
        for (const prop in value) {
            // This will tell the TypeScript compiler that the obj object has a string index signature,
            // and will allow to access its properties using a string index without getting the "Element implicitly has an 'any' type" error.
            const propValue = value?.[prop];
            if (value.hasOwnProperty(prop) === true && propValue !== undefined && propValue !== null && propValue !== "") {
                isAllPropsEmpty = false;
                break;
            }
        }
    }
    return isAllPropsEmpty;
}
/**
 * Check for an empty value for data items like GPString and Field.
 * @param value data item value.
 * @returns whether the value is considered empty.
 */
function isEmptyDataItem(value) {
    return (value === undefined ||
        value === null ||
        // single-select, "" is a special case for strings
        (typeof value === "string" && value === "") ||
        // single-select, empty objects are a special case for nested values
        ((0,_getTag_96af029d_js__WEBPACK_IMPORTED_MODULE_0__.h)(value) && isEmpty(value)) ||
        // multi-select
        (Array.isArray(value) && value.length < 1) ||
        // only testing objects which are not arrays
        // TODO: combine isEveryPropertyEmpty and isEmptyDataItem to single function
        (typeof value === "object" && (0,_getTag_96af029d_js__WEBPACK_IMPORTED_MODULE_0__.a)(value) === false && isEveryPropertyEmpty(value)));
}



//# sourceMappingURL=type-gaurds-1840747f.js.map

/***/ }),

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/arcgis-raster-function-editor/dist/esm/ui-utils-928a4096.js":
/*!*****************************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/arcgis-raster-function-editor/dist/esm/ui-utils-928a4096.js ***!
  \*****************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   C: () => (/* binding */ CalciteScale),
/* harmony export */   U: () => (/* binding */ UIDefaults),
/* harmony export */   a: () => (/* binding */ CalciteOverlayPositioning)
/* harmony export */ });
const UIDefaults = {
    Scale: "s",
    PopoverTimer: 60
};
const CalciteScale = {
    s: "s",
    m: "m"
};
const CalciteOverlayPositioning = {
    absolute: "absolute",
    fixed: "fixed"
};



//# sourceMappingURL=ui-utils-928a4096.js.map

/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid2lkZ2V0cy9jaHVua3MvYXJjZ2lzX2FuYWx5c2lzX25vZGVfbW9kdWxlc19hcmNnaXNfYXJjZ2lzLXJhc3Rlci1mdW5jdGlvbi1lZGl0b3JfLTM2OTFkYS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFbUQ7O0FBRW5EOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEIsYUFBYSxlQUFlO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLG9CQUFvQjtBQUMvQixXQUFXLFFBQVE7QUFDbkIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixL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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsc0RBQWE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0Msc0RBQU87QUFDN0M7O0FBRWtXOztBQUVsVzs7Ozs7Ozs7Ozs7Ozs7OztBQ3pNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRThFOztBQUU5RSIsInNvdXJjZXMiOlsid2VicGFjazovL2V4Yi1jbGllbnQvLi9leHRlbnNpb25zL3dpZGdldHMvYXJjZ2lzL2FuYWx5c2lzL25vZGVfbW9kdWxlcy9AYXJjZ2lzL2FyY2dpcy1yYXN0ZXItZnVuY3Rpb24tZWRpdG9yL2Rpc3QvZXNtL2ludGVyZmFjZXMtODc5ZjgzZDcuanMiLCJ3ZWJwYWNrOi8vZXhiLWNsaWVudC8uL2V4dGVuc2lvbnMvd2lkZ2V0cy9hcmNnaXMvYW5hbHlzaXMvbm9kZV9tb2R1bGVzL0BhcmNnaXMvYXJjZ2lzLXJhc3Rlci1mdW5jdGlvbi1lZGl0b3IvZGlzdC9lc20vbG9jYWxpemF0aW9uLWhlbHBlci00ODE5YjY3ZC5qcyIsIndlYnBhY2s6Ly9leGItY2xpZW50Ly4vZXh0ZW5zaW9ucy93aWRnZXRzL2FyY2dpcy9hbmFseXNpcy9ub2RlX21vZHVsZXMvQGFyY2dpcy9hcmNnaXMtcmFzdGVyLWZ1bmN0aW9uLWVkaXRvci9kaXN0L2VzbS9yZngtZnVuY3Rpb25zLWxpc3RfMy5lbnRyeS5qcyIsIndlYnBhY2s6Ly9leGItY2xpZW50Ly4vZXh0ZW5zaW9ucy93aWRnZXRzL2FyY2dpcy9hbmFseXNpcy9ub2RlX21vZHVsZXMvQGFyY2dpcy9hcmNnaXMtcmFzdGVyLWZ1bmN0aW9uLWVkaXRvci9kaXN0L2VzbS90eXBlLWdhdXJkcy0xODQwNzQ3Zi5qcyIsIndlYnBhY2s6Ly9leGItY2xpZW50Ly4vZXh0ZW5zaW9ucy93aWRnZXRzL2FyY2dpcy9hbmFseXNpcy9ub2RlX21vZHVsZXMvQGFyY2dpcy9hcmNnaXMtcmFzdGVyLWZ1bmN0aW9uLWVkaXRvci9kaXN0L2VzbS91aS11dGlscy05MjhhNDA5Ni5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIERlZmluZXMgaG93IGEgcmFzdGVyIGZ1bmN0aW9uIHRlbXBsYXRlIGlzIGFwcGxpZWQgb24gYW4gaW1hZ2Ugc2VydmljZVxuICovXG5jb25zdCBGdW5jdGlvblR5cGUgPSB7XG4gICAgTW9zYWljOiAwLFxuICAgIEl0ZW06IDEsXG4gICAgSXRlbUdyb3VwOiAyXG59O1xuLyoqXG4gKiBDT1JFOiB0aGUgbGlzdCBpcyBzaG93biBpbiByZngtZWRpdG9yLWNvcmUgLT4gaGFzIGFuIGFjdGlvbiBpdGVtIGluIHRoZSBlbmQgb2YgdGhlIGZ1bmN0aW9uIGxpc3QgaXRlbS5cbiAqL1xuY29uc3QgUkZ4TGlzdFZpZXdNb2RlID0ge1xuICAgIENPUkU6IFwiQ09SRVwiLFxuICAgIFNUQU5EQVJEOiBcIlNUQU5EQVJEXCJcbn07XG5cbmV4cG9ydCB7IEZ1bmN0aW9uVHlwZSBhcyBGLCBSRnhMaXN0Vmlld01vZGUgYXMgUiB9O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbnRlcmZhY2VzLTg3OWY4M2Q3LmpzLm1hcCIsIi8qKlxuICogTG9jYWxlIGxpc3QgcmVmZXJlbmNlIFtKU0FQSV0oaHR0cHM6Ly9kZXZ0b3BpYS5lc3JpLmNvbS9XZWJHSVMvYXJjZ2lzLWpzLWFwaS90cmVlL21hc3Rlci9lc3JpL25scylcbiAqIGFsc28gaGFzIEhpbmRpOiBcImhpXCJcbiAqL1xuY29uc3QgU3VwcG9ydGVkTG9jYWxlcyA9IHtcbiAgICBBcmFiaWM6IFwiYXJcIixcbiAgICBCb3NuaWFuOiBcImJzXCIsXG4gICAgQnVsZ2FyaWFuOiBcImJnXCIsXG4gICAgQ2F0YWxhbjogXCJjYVwiLFxuICAgIEN6ZWNoOiBcImNzXCIsXG4gICAgRGFuaXNoOiBcImRhXCIsXG4gICAgR2VybWFuOiBcImRlXCIsXG4gICAgR3JlZWs6IFwiZWxcIixcbiAgICBFbmdsaXNoOiBcImVuXCIsXG4gICAgRW5nbGlzaFVTQTogXCJlbi1VU1wiLFxuICAgIFNwYW5pc2g6IFwiZXNcIixcbiAgICBFc3RvbmlhbjogXCJldFwiLFxuICAgIEZpbm5pc2g6IFwiZmlcIixcbiAgICBGcmVuY2g6IFwiZnJcIixcbiAgICBIZWJyZXc6IFwiaGVcIixcbiAgICBIaW5kaTogXCJoaVwiLFxuICAgIENyb2F0aWFuOiBcImhyXCIsXG4gICAgSHVuZ2FyaWFuOiBcImh1XCIsXG4gICAgSW5kb25lc2lhbjogXCJpZFwiLFxuICAgIEl0YWxpYW46IFwiaXRcIixcbiAgICBKYXBhbmVzZTogXCJqYVwiLFxuICAgIEtvcmVhbjogXCJrb1wiLFxuICAgIExpdGh1YW5pYW46IFwibHRcIixcbiAgICBMYXR2aWFuOiBcImx2XCIsXG4gICAgTm9yd2VnaWFuQm9rbWw6IFwibmJcIixcbiAgICBEdXRjaDogXCJubFwiLFxuICAgIFBvbGlzaDogXCJwbFwiLFxuICAgIFBvcnR1Z3Vlc2VCcmF6aWw6IFwicHQtQlJcIixcbiAgICBQb3J0dWd1ZXNlUG9ydHVnYWw6IFwicHQtUFRcIixcbiAgICBSb21hbmlhbjogXCJyb1wiLFxuICAgIFJ1c3NpYW46IFwicnVcIixcbiAgICBTZXJiaWFuOiBcInNyXCIsXG4gICAgU2xvdmVuaWFuOiBcInNsXCIsXG4gICAgU2xvdmFrOiBcInNrXCIsXG4gICAgU3dlZGlzaDogXCJzdlwiLFxuICAgIFRoYWk6IFwidGhcIixcbiAgICBUdXJraXNoOiBcInRyXCIsXG4gICAgVWtyYWluaWFuOiBcInVrXCIsXG4gICAgVmlldG5hbWVzZTogXCJ2aVwiLFxuICAgIENoaW5lc2VDaGluYTogXCJ6aC1DTlwiLFxuICAgIENoaW5lc2VIb25nS29uZzogXCJ6aC1IS1wiLFxuICAgIENoaW5lc2VUYWl3YW46IFwiemgtVFdcIlxufTtcbmNvbnN0IFN1cHBvcnRlZE9ubGluZUhlbHBMb2NhbGVzID0gW1wiYXJcIiwgXCJkZVwiLCBcImVzXCIsIFwiZnJcIiwgXCJpdFwiLCBcImphXCIsIFwia29cIiwgXCJydVwiLCBcInBsXCIsIFwicHQtYnJcIiwgXCJ6aC1jblwiXTtcbmNvbnN0IExvY2FsZU1hcCA9IHtcbiAgICBcImVuLUFVXCI6IFwiZW5cIixcbiAgICBcImVuLUNBXCI6IFwiZW5cIixcbiAgICBcImVuLUdCXCI6IFwiZW5cIixcbiAgICBcImVuLVVTXCI6IFwiZW5cIixcbiAgICBcImVzLUVTXCI6IFwiZXNcIixcbiAgICBcImVzLU1YXCI6IFwiZXNcIixcbiAgICBcImRlLUNIXCI6IFwiZGVcIixcbiAgICBcImRlLUFUXCI6IFwiZGVcIixcbiAgICBcImRlLURFXCI6IFwiZGVcIixcbiAgICBcImZyLUNIXCI6IFwiZnJcIixcbiAgICBcImZyLUZSXCI6IFwiZnJcIixcbiAgICBcIml0LUNIXCI6IFwiaXRcIixcbiAgICBcIml0LUlUXCI6IFwiaXRcIixcbiAgICBpbmQ6IFwiaWRcIixcbiAgICB1a3I6IFwidWtcIlxufTtcbi8qKlxuICogTGlzdCBvZiBzdXBwb3J0ZWQgbG9jYWxlcyB0aGF0IGFyZSBSVExcbiAqIHJlZmVyZW5jZTogaHR0cHM6Ly9kZXZ0b3BpYS5lc3JpLmNvbS9XZWJHSVMvYXJjZ2lzLWpzLWFwaS9ibG9iLzRtYXN0ZXIvZXNyaS9pbnRsL2xvY2FsZS50c1xuICovXG5jb25zdCBSVExMb2NhbGVzID0gW1N1cHBvcnRlZExvY2FsZXMuQXJhYmljLCBTdXBwb3J0ZWRMb2NhbGVzLkhlYnJld107XG5jb25zdCBEZWZhdWx0TG9jYWxlID0gU3VwcG9ydGVkTG9jYWxlcy5FbmdsaXNoO1xuLyoqXG4gKiBVdGlsaXR5IHRvIGNlbnRyYWxpemUgbG9naWMsIGFuZCByZXR1cm4gXCJydGxcIiBvciBcInJ0bFwiIGRlcGVuZGluZyBvbiBydGwgYm9vbGVhblxuICogQHBhcmFtIHtib29sZWFufSBydGwgd2hldGhlciBsb2NhbGUgaXMgaW4gUmlnaHQgdG8gTGVmdCBkaXJlY3Rpb25cbiAqIEByZXR1cm5zIHtcImx0clwiIHwgXCJydGxcIn0gY29kZXMgdGhhdCBjYW4gYmUgcGFzc2VkIHRvIFwiZGlyXCIgcHJvcCBvZiBhIGNvbXBvbmVudC5cbiAqL1xuZnVuY3Rpb24gZ2V0RGlyZWN0aW9uQmFzZWRPblJUTChydGwpIHtcbiAgICByZXR1cm4gcnRsID09PSB0cnVlID8gXCJydGxcIiA6IFwibHRyXCI7XG59XG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiB0byBmaW5kIHRoZSBjbG9zZXN0IGVsZW1lbnQgY3Jvc3NpbmcgbXVsdGlwbGUgKHBhcmVudCkgc2hhZG93RE9NIGJvdW5kYXJpZXMuXG4gKiBUaGUgaW1wbGVtZW50YXRpb24gaXMgYmFzZWQgb24gW3RoaXNdKGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzU0NTIwNTU0L2N1c3RvbS1lbGVtZW50LWdldHJvb3Rub2RlLWNsb3Nlc3QtZnVuY3Rpb24tY3Jvc3NpbmctbXVsdGlwbGUtcGFyZW50LXNoYWRvd2QpIHNvbHV0aW9uLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzZWxlY3RvclxuICogQHBhcmFtIHtFbGVtZW50fSBiYXNlXG4gKi9cbmZ1bmN0aW9uIGdldENsb3Nlc3RFbGVtZW50KHNlbGVjdG9yLCBiYXNlKSB7XG4gICAgZnVuY3Rpb24gY2xvc2VzdEZyb20oZWwpIHtcbiAgICAgICAgbGV0IGVsZW1lbnQ7XG4gICAgICAgIGlmIChlbCA9PT0gdW5kZWZpbmVkIHx8IGVsID09PSBkb2N1bWVudCB8fCBlbCA9PT0gd2luZG93KVxuICAgICAgICAgICAgZWxlbWVudCA9IG51bGw7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgZm91bmQgPSBlbC5jbG9zZXN0KHNlbGVjdG9yKTtcbiAgICAgICAgICAgIGVsZW1lbnQgPSBmb3VuZCB8fCBjbG9zZXN0RnJvbShlbC5nZXRSb290Tm9kZSgpLmhvc3QpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbGVtZW50O1xuICAgIH1cbiAgICByZXR1cm4gY2xvc2VzdEZyb20oYmFzZSk7XG59XG4vKipcbiAqIENvbnZlcnRzIHRoZSBnaXZlbiBsb2NhbGUgdG8gYSBzdXBwb3J0ZWQgbG9jYWxlIHVzaW5nIHRoZSBwcm92aWRlZCBsb2NhbGUgbWFwLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nIHwgdW5kZWZpbmVkfSBsb2NhbGUgLSBUaGUgbG9jYWxlIHRvIGJlIGNvbnZlcnRlZC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBsb2NhbGVNYXAgLSBBIG1hcCBvZiBsb2NhbGVzIHRvIHN1cHBvcnRlZCBsb2NhbGVzLlxuICogQHJldHVybnMge3N0cmluZ30gLSBUaGUgc3VwcG9ydGVkIGxvY2FsZS5cbiAqL1xuZnVuY3Rpb24gY29udmVydFRvU3VwcG9ydGVkTG9jYWxlKGxvY2FsZSwgbG9jYWxlTWFwKSB7XG4gICAgY29uc3QgZGVmYXVsdExvY2FsZSA9IERlZmF1bHRMb2NhbGU7XG4gICAgbGV0IGxvY2FsZVNhbml0aXplZCA9IGxvY2FsZT8udG9Mb3dlckNhc2UoKTtcbiAgICBpZiAobG9jYWxlU2FuaXRpemVkICE9PSB1bmRlZmluZWQgJiYgbG9jYWxlU2FuaXRpemVkLmluZGV4T2YoXCItXCIpICE9PSAtMSkge1xuICAgICAgICBjb25zdCBbbGFuZywgcmVnaW9uXSA9IGxvY2FsZVNhbml0aXplZC5zcGxpdChcIi1cIik7XG4gICAgICAgIGxvY2FsZVNhbml0aXplZCA9IGAke2xhbmd9LSR7cmVnaW9uLnRvVXBwZXJDYXNlKCl9YDtcbiAgICB9XG4gICAgaWYgKCFsb2NhbGVTYW5pdGl6ZWQpIHtcbiAgICAgICAgcmV0dXJuIGRlZmF1bHRMb2NhbGU7XG4gICAgfVxuICAgIGNvbnN0IGxvY2FsZU1hcEtleXMgPSBPYmplY3Qua2V5cyhMb2NhbGVNYXApO1xuICAgIGlmIChsb2NhbGVNYXBLZXlzLmluY2x1ZGVzKGxvY2FsZVNhbml0aXplZCkgPT09IHRydWUpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsZU1hcFtsb2NhbGVTYW5pdGl6ZWRdO1xuICAgIH1cbiAgICByZXR1cm4gbG9jYWxlU2FuaXRpemVkO1xufVxuLyoqXG4gKiBSZXRyaWV2ZXMgbG9jYWxlIGluZm9ybWF0aW9uOyBJbiB0aGUgY2FzZSBvZiBSZWdpb25hbCBjb2RlcyAoZW4tYXUpIGl0IGlzIGNvbnZlcnRlZCB0byBhIHN1cHBvcnRlZCBsb2NhbGUgKGVuKS5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IFtlbGVtZW50PWRvY3VtZW50LmRvY3VtZW50RWxlbWVudF0gLSBUaGUgZWxlbWVudCB0byBzZWFyY2ggZm9yIGxvY2FsZSBpbmZvcm1hdGlvbi5cbiAqIEByZXR1cm5zIHtPYmplY3R9IEFuIG9iamVjdCBjb250YWluaW5nIHRoZSBsb2NhbGUgaW5mb3JtYXRpb24uXG4gKiBAcHJvcGVydHkge3N0cmluZ30gbG9jYWxlIC0gVGhlIGxvY2FsZSBjb2RlLlxuICogQHByb3BlcnR5IHtib29sZWFufSBydGwgLSBBIGZsYWcgaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBsb2NhbGUgaXMgcmlnaHQtdG8tbGVmdC5cbiAqL1xuZnVuY3Rpb24gZ2V0TG9jYWxlSW5mbyhlbGVtZW50ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KSB7XG4gICAgLy8gR2V0cyB0aGUgY2xvc2VzdCBlbGVtZW50IHdpdGggYSBsYW5nIGF0dHJpYnV0ZSBhbmQgZmFsbHMgYmFjayB0byBuYXZpZ2F0b3IubGFuZ3VhZ2UgaWYgbm90IGZvdW5kXG4gICAgY29uc3QgY2xvc2VzdEVsZW1lbnQgPSBnZXRDbG9zZXN0RWxlbWVudChcIltsYW5nXVwiLCBlbGVtZW50KTtcbiAgICBjb25zdCBsb2NhbGUgPSBjbG9zZXN0RWxlbWVudD8ubGFuZyA/PyB3aW5kb3cubmF2aWdhdG9yLmxhbmd1YWdlO1xuICAgIGNvbnN0IHN1cHBvcnRlZExvY2FsZXMgPSBPYmplY3QudmFsdWVzKFN1cHBvcnRlZExvY2FsZXMpO1xuICAgIGNvbnN0IGRlZmF1bHRMb2NhbGUgPSBEZWZhdWx0TG9jYWxlO1xuICAgIGNvbnN0IGNvbnZlcnRlZExvY2FsZSA9IGNvbnZlcnRUb1N1cHBvcnRlZExvY2FsZShsb2NhbGUsIExvY2FsZU1hcCk7XG4gICAgY29uc3QgaXNTdXBwb3J0ZWRMb2NhbGUgPSBzdXBwb3J0ZWRMb2NhbGVzLmluY2x1ZGVzKGNvbnZlcnRlZExvY2FsZSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbG9jYWxlOiBpc1N1cHBvcnRlZExvY2FsZSA/IGNvbnZlcnRlZExvY2FsZSA6IGRlZmF1bHRMb2NhbGUsXG4gICAgICAgIHJ0bDogUlRMTG9jYWxlcy5pbmNsdWRlcyhsb2NhbGUpXG4gICAgfTtcbn1cbi8qKlxuICogRmV0Y2hlcyB0aGUgbG9jYWxlIGZpbGUgb2YgdGhlIGdpdmVuIGNvbXBvbmVudDsgZGVmYXVsdHMgdG8gYFwiZW5cImAgbG9jYWxlXG4gKiBAcGFyYW0gY29tcG9uZW50TmFtZVxuICogQHBhcmFtIHByb3BzXG4gKiBAcGFyYW0gbG9jYWxlXG4gKiBAcGFyYW0gcmVzb3VyY2VzVXJsXG4gKiBAcGFyYW0gcHJvcHMucGF0aFxuICogQHBhcmFtIHByb3BzLmxvY2FsZVxuICogQHBhcmFtIHByb3BzLmJhc2VVUkxcbiAqL1xuYXN5bmMgZnVuY3Rpb24gZmV0Y2hMb2NhbGVTdHJpbmdzKHByb3BzKSB7XG4gICAgY29uc3QgeyBwYXRoLCBsb2NhbGUsIGJhc2VVUkwgfSA9IHByb3BzO1xuICAgIC8vIFVzaW5nIHRoZSBnZXRQdWJsaWNQYXRoIG1ldGhvZCB0aGF0IGxldmVyYWdlcyBgZGF0YS1yZXNvdXJjZXMtdXJsYCBjdXJyZW50bHkgdGhpcyBpcyBub3Qgd29ya2luZy5cbiAgICAvLyBjb25zdCByVXJsID0gZ2V0UHVibGljUGF0aChjb21wb25lbnROYW1lKSB8fCByZXNvdXJjZXNVcmw7XG4gICAgbGV0IGxvY2FsZURhdGEgPSB7fTtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke2Jhc2VVUkx9dDluLyR7cGF0aH0udDluLiR7bG9jYWxlfS5qc29uYCk7XG4gICAgICAgIGxvY2FsZURhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIGNvbnN0IGRlZmF1bHRSZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke2Jhc2VVUkx9dDluLyR7cGF0aH0udDluLiR7RGVmYXVsdExvY2FsZX0uanNvbmApO1xuICAgICAgICBsb2NhbGVEYXRhID0gYXdhaXQgZGVmYXVsdFJlc3BvbnNlLmpzb24oKTtcbiAgICB9XG4gICAgcmV0dXJuIGxvY2FsZURhdGE7XG59XG5hc3luYyBmdW5jdGlvbiBmZXRjaENvbXBvbmVudExvY2FsZVN0cmluZ3MoZWxlbWVudCwgYmFzZVVSTCkge1xuICAgIGNvbnN0IGNvbXBvbmVudE5hbWUgPSBlbGVtZW50LnRhZ05hbWUudG9Mb3dlckNhc2UoKTtcbiAgICBjb25zdCB7IGxvY2FsZSwgcnRsIH0gPSBnZXRMb2NhbGVJbmZvKGVsZW1lbnQpO1xuICAgIGNvbnN0IHN0cmluZ3MgPSBhd2FpdCBmZXRjaExvY2FsZVN0cmluZ3MoeyBwYXRoOiBjb21wb25lbnROYW1lLCBsb2NhbGUsIGJhc2VVUkwgfSk7XG4gICAgcmV0dXJuIHsgc3RyaW5ncywgZGlyOiBnZXREaXJlY3Rpb25CYXNlZE9uUlRMKHJ0bCksIGxvY2FsZTogbG9jYWxlIH07XG59XG4vKipcbiAqIEZvcm1hdHMgYSBVUkwgdG8gbGluayB0b1xuICogQHBhcmFtIHtzdHJpbmd9IHVybCB0aGUgdXJsIHN0cmluZyBmcm9tIGFmdGVyIHRoZSBsb2NhbGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBiYXNlUGF0aCB0aGUgYmFzZSBwYXRoIGZyb20gdGhlIHNpZ25lZCBpbiBwb3J0YWwgb2JqZWN0LlxuICogQHBhcmFtIHtzdHJpbmd9IGxvY2FsZSB0aGUgbG9jYWxlIGFiYnJldmlhdGlvbiBmb3IgdGhlIGJyb3dzZXIuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSB0aGUgZm9ybWF0dGVkIHVybC5cbiAqL1xuZnVuY3Rpb24gZm9ybWF0TG9jYWxpemVkSGVscFVybCh1cmwsIGJhc2VQYXRoLCBsb2NhbGUgPSBcImVuXCIpIHtcbiAgICBsZXQgbG9jYWxlU2FuaXRpemVkID0gbG9jYWxlO1xuICAgIGNvbnN0IGxvY2FsZU1hcEtleXMgPSBPYmplY3Qua2V5cyhMb2NhbGVNYXApO1xuICAgIGlmIChsb2NhbGVNYXBLZXlzLmluY2x1ZGVzKGxvY2FsZSkgPT09IHRydWUpIHtcbiAgICAgICAgbG9jYWxlU2FuaXRpemVkID0gTG9jYWxlTWFwW2xvY2FsZV07XG4gICAgfVxuICAgIGNvbnN0IGxvY2FsZUluTG93ZXJDYXNlID0gbG9jYWxlU2FuaXRpemVkLnRvTG9jYWxlTG93ZXJDYXNlKCk7XG4gICAgaWYgKFN1cHBvcnRlZE9ubGluZUhlbHBMb2NhbGVzLmluY2x1ZGVzKGxvY2FsZUluTG93ZXJDYXNlKSA9PT0gdHJ1ZSkge1xuICAgICAgICAvLyBmb2xsb3dpbmcgcmVnZXggdGVzdHMgL2VuLyBpcyBwcmVzZW50IGluIHVybCBhbmQgcmVwbGFjZXMgaXQgd2l0aCB0aGUgbG9jYWxlXG4gICAgICAgIC8vIGh0dHBzOi8vZG9jZGV2LmFyY2dpcy5jb20vZW4vYXJjZ2lzLW9ubGluZS9hbmFseXplL2FnZ3JlZ2F0ZS1wb2ludHMtbXYuaHRtXG4gICAgICAgIC8vIHNlbGYgUmVzcG9uc2Ugb25seSBwcm92aWRlcyB3aXRoIGBlbmAgbG9jYWxlIG5vdCBhcyBwZXIgdGhlIHVzZXIgbG9jYWxlIG9yIGN1cnJlbnQgYXBwIGxvY2FsZVxuICAgICAgICAvLyBzbyB3ZSBuZWVkIHRoaXMgcmVwbGFjZSBjYWxsLlxuICAgICAgICBiYXNlUGF0aCA9IGJhc2VQYXRoLnJlcGxhY2UoL15odHRwcz86XFwvXFwvW14vXStcXC9lbi8sIChtYXRjaCkgPT4gbWF0Y2gucmVwbGFjZShcImVuXCIsIGxvY2FsZUluTG93ZXJDYXNlKSk7XG4gICAgfVxuICAgIGNvbnN0IGxlYXJuTW9yZVVybCA9IGAke2Jhc2VQYXRofWFuYWx5emUvJHt1cmx9YDtcbiAgICByZXR1cm4gbGVhcm5Nb3JlVXJsO1xufVxuXG5leHBvcnQgeyBEZWZhdWx0TG9jYWxlIGFzIEQsIFN1cHBvcnRlZExvY2FsZXMgYXMgUywgZ2V0RGlyZWN0aW9uQmFzZWRPblJUTCBhcyBhLCBmZXRjaENvbXBvbmVudExvY2FsZVN0cmluZ3MgYXMgYiwgZm9ybWF0TG9jYWxpemVkSGVscFVybCBhcyBmLCBnZXRMb2NhbGVJbmZvIGFzIGcgfTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bG9jYWxpemF0aW9uLWhlbHBlci00ODE5YjY3ZC5qcy5tYXAiLCJpbXBvcnQgeyByIGFzIHJlZ2lzdGVySW5zdGFuY2UsIGMgYXMgY3JlYXRlRXZlbnQsIGgsIEYgYXMgRnJhZ21lbnQsIGcgYXMgZ2V0QXNzZXRQYXRoLCBIIGFzIEhvc3QsIGEgYXMgZ2V0RWxlbWVudCB9IGZyb20gJy4vaW5kZXgtZGExYjcxMzguanMnO1xuaW1wb3J0IHsgYiBhcyBmZXRjaENvbXBvbmVudExvY2FsZVN0cmluZ3MgfSBmcm9tICcuL2xvY2FsaXphdGlvbi1oZWxwZXItNDgxOWI2N2QuanMnO1xuaW1wb3J0ICdAYXJjZ2lzL2NvcmUvY29yZS9sYW5nLmpzJztcbmltcG9ydCB7IFUgYXMgVUlEZWZhdWx0cyB9IGZyb20gJy4vdWktdXRpbHMtOTI4YTQwOTYuanMnO1xuaW1wb3J0ICdAYXJjZ2lzL2NvcmUvaWRlbnRpdHkvSWRlbnRpdHlNYW5hZ2VyLmpzJztcbmltcG9ydCAnQGFyY2dpcy9jb3JlL2NvcmUvdXJsVXRpbHMuanMnO1xuaW1wb3J0ICdAYXJjZ2lzL2NvcmUvbGF5ZXJzL0xheWVyLmpzJztcbmltcG9ydCAnQGFyY2dpcy9jb3JlL2xheWVycy9JbWFnZXJ5TGF5ZXIuanMnO1xuaW1wb3J0ICdAYXJjZ2lzL2NvcmUvc21hcnRNYXBwaW5nL3Jhc3Rlci9yZW5kZXJlcnMvc3RyZXRjaC5qcyc7XG5pbXBvcnQgeyBmIGFzIGZvcm1hdE1lc3NhZ2UgfSBmcm9tICcuL2NvbW1vbi1mZGExNDYyZS5qcyc7XG5pbXBvcnQgJ0BhcmNnaXMvY29yZS9yZXN0L3N1cHBvcnQvQWxnb3JpdGhtaWNDb2xvclJhbXAuanMnO1xuaW1wb3J0ICdAYXJjZ2lzL2NvcmUvcmVzdC9zdXBwb3J0L011bHRpcGFydENvbG9yUmFtcC5qcyc7XG5pbXBvcnQgJ0BhcmNnaXMvY29yZS9Db2xvci5qcyc7XG5pbXBvcnQgJy4vY29sb3JSYW1wVXRpbHMtOGJkZDQ2YzUuanMnO1xuaW1wb3J0ICdAYXJjZ2lzL2NvcmUvcmVzdC9nZW9wcm9jZXNzb3IuanMnO1xuaW1wb3J0ICdAYXJjZ2lzL2NvcmUvcmVxdWVzdC5qcyc7XG5pbXBvcnQgJ0BhcmNnaXMvY29yZS9wb3J0YWwvUG9ydGFsSXRlbS5qcyc7XG5pbXBvcnQgeyBSIGFzIFJGeExpc3RWaWV3TW9kZSB9IGZyb20gJy4vaW50ZXJmYWNlcy04NzlmODNkNy5qcyc7XG5pbXBvcnQgeyBhIGFzIGdldEZ1bmN0aW9uc0FuZENhdGVnb3JpZXMgfSBmcm9tICcuL2Z1bmN0aW9ucy1mMWYyZGZmZC5qcyc7XG5pbXBvcnQgJy4vX1VpbnQ4QXJyYXktNjhlMWUzZjkuanMnO1xuaW1wb3J0ICcuL19nZXRUYWctOTZhZjAyOWQuanMnO1xuaW1wb3J0ICcuL3Jlc291cmNlcy0yN2M2NmY1Yy5qcyc7XG5pbXBvcnQgJy4vdHlwZS1nYXVyZHMtMTg0MDc0N2YuanMnO1xuXG5jb25zdCBIVE1MQ2xhc3NlcyQxID0ge1xuICAgIG5vUmVzdWx0c0NvbnRhaW5lcjogXCJuby1yZXN1bHRzLWNvbnRhaW5lclwiLFxuICAgIHRvb2xDYXRlZ29yeVdyYXBwZXI6IFwidG9vbC1jYXRlZ29yeS13cmFwcGVyXCIsXG4gICAgbm9SZXN1bHRzSWNvbjogXCJuby1yZXN1bHRzLWljb25cIixcbiAgICB0b29sc0xpc3RJdGVtOiBcInRvb2xzLWxpc3QtaXRlbVwiXG59O1xuXG5jb25zdCByZnhGdW5jdGlvbnNMaXN0Q3NzID0gXCI6cm9vdHstLWNhbGNpdGUtY29sb3ItYnJhbmQ6IzAwN2FjMjstLWNhbGNpdGUtY29sb3ItYnJhbmQtaG92ZXI6IzAwNjE5YjstLWNhbGNpdGUtY29sb3ItYnJhbmQtcHJlc3M6IzAwNDg3NDstLWNhbGNpdGUtY29sb3Itc3RhdHVzLWluZm86IzAwNjE5YjstLWNhbGNpdGUtY29sb3Itc3RhdHVzLXN1Y2Nlc3M6IzM1YWM0NjstLWNhbGNpdGUtY29sb3Itc3RhdHVzLXdhcm5pbmc6I2VkZDMxNzstLWNhbGNpdGUtY29sb3Itc3RhdHVzLWRhbmdlcjojZDgzMDIwOy0tY2FsY2l0ZS1jb2xvci1zdGF0dXMtZGFuZ2VyLWhvdmVyOiNhODJiMWU7LS1jYWxjaXRlLWNvbG9yLXN0YXR1cy1kYW5nZXItcHJlc3M6IzdjMWQxMzstLWNhbGNpdGUtY29sb3ItYmFja2dyb3VuZDojZjhmOGY4Oy0tY2FsY2l0ZS1jb2xvci1mb3JlZ3JvdW5kLTE6I2ZmZmZmZjstLWNhbGNpdGUtY29sb3ItZm9yZWdyb3VuZC0yOiNmM2YzZjM7LS1jYWxjaXRlLWNvbG9yLWZvcmVncm91bmQtMzojZWFlYWVhOy0tY2FsY2l0ZS1jb2xvci10ZXh0LTE6IzE1MTUxNTstLWNhbGNpdGUtY29sb3ItdGV4dC0yOiM0YTRhNGE7LS1jYWxjaXRlLWNvbG9yLXRleHQtMzojNmE2YTZhOy0tY2FsY2l0ZS1jb2xvci10ZXh0LWludmVyc2U6I2ZmZmZmZjstLWNhbGNpdGUtY29sb3ItdGV4dC1saW5rOiMwMDYxOWI7LS1jYWxjaXRlLWNvbG9yLWJvcmRlci0xOiNjYWNhY2E7LS1jYWxjaXRlLWNvbG9yLWJvcmRlci0yOiNkNGQ0ZDQ7LS1jYWxjaXRlLWNvbG9yLWJvcmRlci0zOiNkZmRmZGY7LS1jYWxjaXRlLWNvbG9yLWJvcmRlci1pbnB1dDojOTQ5NDk0Oy0tcmZ4LXF1YXJ0ZXItc3BhY2luZzowLjI1cmVtOy0tcmZ4LWhhbGYtc3BhY2luZzowLjVyZW07LS1yZngtdGhyZWUtcXVhcnRlci1zcGFjaW5nOjAuNzVyZW07LS1yZngtZnVsbC1zcGFjaW5nOjFyZW07LS1yZngtY29tcG9uZW50LWRlZmF1bHQtd2lkdGg6MTAwJTstLXJmeC11aS1ib3JkZXItaW5wdXQ6dmFyKC0tY2FsY2l0ZS1jb2xvci1ib3JkZXItMik7LS1yZngtcG9wb3Zlci1jb250ZW50LW1pbi1oZWlnaHQ6MzB2aDstLXJmeC1wb3BvdmVyLWNvbnRlbnQtbWF4LWhlaWdodDo2MHZoOy0tcmZ4LXBvcG92ZXItY29udGVudC1oZWlnaHQ6NDV2aDstLXJmeC13aWRnZXQtY29udGVudC1oZWlnaHQ6MzB2aH06aG9zdHtkaXNwbGF5OmZsZXg7ZmxleC1kaXJlY3Rpb246Y29sdW1uO2ZsZXgtd3JhcDp3cmFwfS50b29sLWNhdGVnb3J5LXdyYXBwZXJ7d2lkdGg6MTAwJX0ubm8tcmVzdWx0cy1jb250YWluZXJ7anVzdGlmeS1jb250ZW50OmNlbnRlcjtkaXNwbGF5OmZsZXg7ZmxleC1kaXJlY3Rpb246Y29sdW1uO3dpZHRoOjEwMCU7YWxpZ24taXRlbXM6Y2VudGVyO2NvbG9yOnZhcigtLWNhbGNpdGUtY29sb3ItdGV4dC0zKX0ubm8tcmVzdWx0cy1pY29ue21hcmdpbi10b3A6MS41cmVtfVwiO1xuXG5jb25zdCBSZnhGdW5jdGlvbnNMaXN0ID0gY2xhc3Mge1xuICAgIGNvbnN0cnVjdG9yKGhvc3RSZWYpIHtcbiAgICAgICAgcmVnaXN0ZXJJbnN0YW5jZSh0aGlzLCBob3N0UmVmKTtcbiAgICAgICAgdGhpcy50cmlnZ2VyQ2hhbmdlUGFuZWwgPSBjcmVhdGVFdmVudCh0aGlzLCBcInRyaWdnZXJDaGFuZ2VQYW5lbFwiLCA3KTtcbiAgICAgICAgdGhpcy50cmlnZ2VyU2VsZWN0VG9vbCA9IGNyZWF0ZUV2ZW50KHRoaXMsIFwidHJpZ2dlclNlbGVjdFRvb2xcIiwgNyk7XG4gICAgICAgIHRoaXMub3BlbkNhdGVnb3JpZXNDaGFuZ2UgPSBjcmVhdGVFdmVudCh0aGlzLCBcIm9wZW5DYXRlZ29yaWVzQ2hhbmdlXCIsIDcpO1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGUgdXNlciBzZWxlY3RzIHRoZSB0b29sXG4gICAgICAgICAqIEBwYXJhbSByZnhGdW5jdGlvbkl0ZW1cbiAgICAgICAgICogQGNhdGVnb3J5IFByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubW9kaWZ5UGFuZWxTdGF0ZSA9IChyZnhGdW5jdGlvbkl0ZW0pID0+IHtcbiAgICAgICAgICAgIHRoaXMudHJpZ2dlclNlbGVjdFRvb2wuZW1pdChyZnhGdW5jdGlvbkl0ZW0pO1xuICAgICAgICAgICAgdGhpcy50cmlnZ2VyQ2hhbmdlUGFuZWwuZW1pdCgxKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldHMgY2FsbGVkIHRvIHJlbmRlciB0aGUgdG9vbCBpY29uXG4gICAgICAgICAqIEBwYXJhbSByZnhGdW5jdGlvbkl0ZW1cbiAgICAgICAgICogQGNhdGVnb3J5IFByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZ2V0UmZ4RnVuY3Rpb25JY29uID0gKHJmeEZ1bmN0aW9uSXRlbSkgPT4ge1xuICAgICAgICAgICAgbGV0IGljb24gPSBcIlwiO1xuICAgICAgICAgICAgLy8gY29uc3QgeyBhbmFseXNpc0VuZ2luZSB9ID0gcmZ4RnVuY3Rpb25JdGVtO1xuICAgICAgICAgICAgLy8gVE9ETzogbG9naWMgY2FuIGJlIHJldXNlZCB3aGVuIGVhY2ggZnVuY3Rpb24gaGFzIHVuaXF1ZSBpY29uXG4gICAgICAgICAgICBjb25zdCBmdW5jdGlvblR5cGVzID0gW1wicmFzdGVyXCIsIFwiZ2VvYW5hbHl0aWNzXCJdO1xuICAgICAgICAgICAgY29uc3QgZnVuY3Rpb25UeXBlID0gZnVuY3Rpb25UeXBlc1swXTtcbiAgICAgICAgICAgIHN3aXRjaCAoZnVuY3Rpb25UeXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcInJhc3RlclwiOlxuICAgICAgICAgICAgICAgICAgICBpY29uID0gXCJyYXN0ZXItYW5hbHlzaXNcIjtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcImdlb2FuYWx5dGljc1wiOlxuICAgICAgICAgICAgICAgICAgICBpY29uID0gXCJtYXAtcGluXCI7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGljb24gPSBcImhhbW1lclwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJmeEZ1bmN0aW9uSXRlbS5pY29uID8/IGljb247XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXRzIGNhbGxlZCB0byByZW5kZXIgdGhlIGZ1bmN0aW9uIGljb25cbiAgICAgICAgICogQGNhdGVnb3J5IFByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZGlzcGxheVJlc3VsdHMgPSAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBrZXlzID0gQXJyYXkuZnJvbSh0aGlzLnJmeEZ1bmN0aW9uc01hcC5rZXlzKCkpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2VhcmNoSXNBY3RpdmUgPyAoaChcImNhbGNpdGUtbGlzdFwiLCB7IHNlbGVjdGlvbkFwcGVhcmFuY2U6IFwiYm9yZGVyXCIgfSwgdGhpcy5yZW5kZXJGdW5jdGlvblNlYXJjaExpc3Qoa2V5cykpKSA6ICh0aGlzLnJlbmRlclJmeEZ1bmN0aW9uc0NhdGVnb3JpZXNMaXN0KGtleXMpKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlbmRlcnMgc2VhcmNoZWQgY2FsY2l0ZS1saXN0LWl0ZW1zIHdoZW4gc2VhcmNoIGlzIGFjdGl2ZVxuICAgICAgICAgKiBAcGFyYW0ga2V5cyBUb29sbWFwIGtleXNcbiAgICAgICAgICogQHJldHVybnMgYXJyYXkgb2YgY2F0ZWdvcnkgY2FsY2l0ZS1saXN0c1xuICAgICAgICAgKiBAY2F0ZWdvcnkgUHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yZW5kZXJGdW5jdGlvblNlYXJjaExpc3QgPSAoa2V5cykgPT4ge1xuICAgICAgICAgICAgY29uc3QgY2FsY2l0ZUxpc3RJdGVtcyA9IFtdO1xuICAgICAgICAgICAga2V5cy5tYXAoKGNhdGVnb3J5KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgZnVuY3Rpb25zSW5DYXRlZ29yeSA9IHRoaXMucmZ4RnVuY3Rpb25zTWFwLmdldChjYXRlZ29yeSk7XG4gICAgICAgICAgICAgICAgaWYgKGZ1bmN0aW9uc0luQ2F0ZWdvcnkgIT09IHVuZGVmaW5lZCAmJiBmdW5jdGlvbnNJbkNhdGVnb3J5Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsY2l0ZUxpc3RJdGVtcy5wdXNoKC4uLnRoaXMucmVuZGVyUmZ4RnVuY3Rpb25zKGNhdGVnb3J5KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gY2FsY2l0ZUxpc3RJdGVtcztcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlbmRlcnMgYWxsIHRoZSBsaXN0cyB3aGVuIHNlYXJjaCBpcyBub3QgYWN0aXZlXG4gICAgICAgICAqIEBwYXJhbSBrZXlzIFRvb2xtYXAga2V5c1xuICAgICAgICAgKiBAcmV0dXJucyBhcnJheSBvZiBjYXRlZ29yeSBjYWxjaXRlLWxpc3RzXG4gICAgICAgICAqIEBjYXRlZ29yeSBQcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnJlbmRlclJmeEZ1bmN0aW9uc0NhdGVnb3JpZXNMaXN0ID0gKGtleXMpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJmeEZ1bmN0aW9uQ2F0ZWdvcnlCbG9ja3MgPSBrZXlzLm1hcCgoY2F0ZWdvcnksIGkpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBmdW5jdGlvbnNJbkNhdGVnb3J5ID0gdGhpcy5yZnhGdW5jdGlvbnNNYXAuZ2V0KGNhdGVnb3J5KTtcbiAgICAgICAgICAgICAgICBpZiAoZnVuY3Rpb25zSW5DYXRlZ29yeSAhPT0gdW5kZWZpbmVkICYmIGZ1bmN0aW9uc0luQ2F0ZWdvcnkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKGgoXCJjYWxjaXRlLWJsb2NrXCIsIHsgY2xhc3M6IEhUTUxDbGFzc2VzJDEudG9vbENhdGVnb3J5V3JhcHBlciwgZGlyOiB0aGlzLmRpciwgaGVhZGluZzogdGhpcy5yZnhGdW5jdGlvbnNNYXAuZ2V0KGNhdGVnb3J5KVswXS5jYXRlZ29yeVRpdGxlLCBjb2xsYXBzaWJsZTogdHJ1ZSwgb3BlbjogdGhpcy5vcGVuQ2F0ZWdvcmllcy5oYXMoaSksIG9uQ2FsY2l0ZUJsb2NrVG9nZ2xlOiAoKSA9PiB0aGlzLm9wZW5DYXRlZ29yaWVzQ2hhbmdlLmVtaXQoaSkgfSwgaChcImNhbGNpdGUtbGlzdFwiLCB7IHNlbGVjdGlvbkFwcGVhcmFuY2U6IFwiYm9yZGVyXCIgfSwgdGhpcy5yZW5kZXJSZnhGdW5jdGlvbnMoY2F0ZWdvcnkpKSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJmeEZ1bmN0aW9uQ2F0ZWdvcnlCbG9ja3M7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZW5kZXJzIHRoZSBubyByZXN1bHRzIG1lc3NhZ2UgYW5kIGljb25cbiAgICAgICAgICogQGNhdGVnb3J5IFJlbmRlciBVWFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yZW5kZXJOb1Jlc3VsdHMgPSAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gKGgoXCJkaXZcIiwgeyBjbGFzczogSFRNTENsYXNzZXMkMS5ub1Jlc3VsdHNDb250YWluZXIgfSwgaChcImNhbGNpdGUtaWNvblwiLCB7IGNsYXNzOiBIVE1MQ2xhc3NlcyQxLm5vUmVzdWx0c0ljb24sIGljb246IFwic2VhcmNoXCIsIHNjYWxlOiBcIm1cIiB9KSwgaChcInBcIiwgbnVsbCwgdGhpcy5zdHJpbmdzLm5vUmVzdWx0cykpKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlbmRlcnMgdG9vbHRpcCB3aXRoIGZ1bmN0aW9uIGRlc2NyaXB0aW9uXG4gICAgICAgICAqIEBjYXRlZ29yeSBSZW5kZXIgVVhcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY3JlYXRlUmZ4RnVuY3Rpb25DYXRlZ29yeUhlbHAgPSAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnJmeEZ1bmN0aW9uSGVscFRvb2x0aXAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FsY2l0ZS10b29sdGlwXCIpO1xuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0aGlzLnJmeEZ1bmN0aW9uSGVscFRvb2x0aXApO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQ2FsbHMgdGhlIGNyZWF0ZVJmeEZ1bmN0aW9uQ2F0ZWdvcnlIZWxwIG1ldGhvZCB0byBzaG93IHRoZSB0b29sdGlwIGFmdGVyIGEgNTAwIG1pbGxpc2Vjb25kIGRlbGF5XG4gICAgICAgICAqIEBwYXJhbSBlXG4gICAgICAgICAqIEBwYXJhbSB0b29sVGl0bGVcbiAgICAgICAgICogQHBhcmFtIHRvb2xEZXNjcmlwdGlvblxuICAgICAgICAgKiBAY2F0ZWdvcnkgRXZlbnQgSGFuZGxlclxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zaG93UmZ4RnVuY3Rpb25Ub29sdGlwID0gKGUsIHRvb2xUaXRsZSwgdG9vbERlc2NyaXB0aW9uKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZUhlbHBUb29sdGlwKCk7XG4gICAgICAgICAgICBjb25zdCB0YXJnZXRFbGVtZW50ID0gZS50YXJnZXQ7XG4gICAgICAgICAgICB0aGlzLmNyZWF0ZVJmeEZ1bmN0aW9uQ2F0ZWdvcnlIZWxwKCk7XG4gICAgICAgICAgICBpZiAodGhpcy5yZnhGdW5jdGlvbkhlbHBUb29sdGlwICE9PSB1bmRlZmluZWQgJiYgdGFyZ2V0RWxlbWVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZnhGdW5jdGlvbkhlbHBUb29sdGlwLnJlZmVyZW5jZUVsZW1lbnQgPSB0YXJnZXRFbGVtZW50O1xuICAgICAgICAgICAgICAgIHRoaXMucmZ4RnVuY3Rpb25IZWxwVG9vbHRpcC5wbGFjZW1lbnQgPSBcImxlZnRcIjtcbiAgICAgICAgICAgICAgICB0aGlzLnJmeEZ1bmN0aW9uSGVscFRvb2x0aXAuaW5uZXJUZXh0ID1cbiAgICAgICAgICAgICAgICAgICAgdG9vbERlc2NyaXB0aW9uID8/IGZvcm1hdE1lc3NhZ2UodGhpcy5zdHJpbmdzLmRlZmF1bHRUb29sRGVzY3JpcHRpb24sIHsgdG9vbFRpdGxlIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMuaG92ZXJUaW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5yZnhGdW5jdGlvbkhlbHBUb29sdGlwICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmZ4RnVuY3Rpb25IZWxwVG9vbHRpcC5vcGVuID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIDUwMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZW1vdmVzIHRvb2x0aXAgZm9yIHRvb2xcbiAgICAgICAgICogQGNhdGVnb3J5IFByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucmVtb3ZlSGVscFRvb2x0aXAgPSAoKSA9PiB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5ob3ZlclRpbWVyKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnJmeEZ1bmN0aW9uSGVscFRvb2x0aXAgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRoaXMucmZ4RnVuY3Rpb25IZWxwVG9vbHRpcD8ucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5yZnhGdW5jdGlvbkhlbHBUb29sdGlwLm9wZW4gPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlbmRlcnMgdGhlIGxpc3Qgb2YgZnVuY3Rpb25zXG4gICAgICAgICAqIEBjYXRlZ29yeSBSZW5kZXIgVVhcbiAgICAgICAgICogQHBhcmFtIGNhdGVnb3J5XG4gICAgICAgICAqIEByZXR1cm5zIEhUTUxFbGVtZW50XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnJlbmRlclJmeEZ1bmN0aW9ucyA9IChjYXRlZ29yeSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuICh0aGlzLnJmeEZ1bmN0aW9uc01hcC5nZXQoY2F0ZWdvcnkpPy5tYXAoKHJmeEZ1bmN0aW9uSXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiAoaChcImNhbGNpdGUtbGlzdC1pdGVtXCIsIHsgY2xhc3M6IEhUTUxDbGFzc2VzJDEudG9vbHNMaXN0SXRlbSwgbGFiZWw6IHJmeEZ1bmN0aW9uSXRlbS50aXRsZSwgZGVzY3JpcHRpb246IHRoaXMuc2hvd0Z1bmN0aW9uRGVzY3JpcHRpb24gPT09IHRydWUgPyByZnhGdW5jdGlvbkl0ZW0uZGVzY3JpcHRpb24gOiBcIlwiLCBvbkNsaWNrOiAoKSA9PiB0aGlzLmlzRW1iZWRkZWRJbkNvcmVBcHAgPyBudWxsIDogdGhpcy5tb2RpZnlQYW5lbFN0YXRlKHJmeEZ1bmN0aW9uSXRlbSksIG9uTW91c2VPdmVyOiAoZXZlbnQpID0+IHRoaXMuc2hvd1JmeEZ1bmN0aW9uVG9vbHRpcChldmVudCwgcmZ4RnVuY3Rpb25JdGVtLnRpdGxlLCByZnhGdW5jdGlvbkl0ZW0uZGVzY3JpcHRpb24pLCBvbk1vdXNlT3V0OiB0aGlzLnJlbW92ZUhlbHBUb29sdGlwLCB2YWx1ZTogYCR7Y2F0ZWdvcnl9XyR7cmZ4RnVuY3Rpb25JdGVtLnRvb2xOYW1lfWAsIGtleTogYCR7Y2F0ZWdvcnl9XyR7cmZ4RnVuY3Rpb25JdGVtLnRvb2xOYW1lfWAsIHNjYWxlOiB0aGlzLnNjYWxlIH0sIGgoXCJjYWxjaXRlLWljb25cIiwgeyBpY29uOiB0aGlzLmdldFJmeEZ1bmN0aW9uSWNvbihyZnhGdW5jdGlvbkl0ZW0pLCBzbG90OiBcImNvbnRlbnQtc3RhcnRcIiwgc2NhbGU6IHRoaXMuc2NhbGUgfSksIHRoaXMuaXNFbWJlZGRlZEluQ29yZUFwcCA/IChoKEZyYWdtZW50LCBudWxsLCBoKFwiY2FsY2l0ZS1pY29uXCIsIHsgaWQ6IFwiYWRkLXRvb2xcIiwgaWNvbjogXCJwbHVzLWNpcmNsZVwiLCBzbG90OiBcImNvbnRlbnQtZW5kXCIsIHNjYWxlOiB0aGlzLnNjYWxlLCBvbkNsaWNrOiAoKSA9PiB0aGlzLm1vZGlmeVBhbmVsU3RhdGUocmZ4RnVuY3Rpb25JdGVtKSB9KSwgaChcImNhbGNpdGUtdG9vbHRpcFwiLCB7IHJlZmVyZW5jZUVsZW1lbnQ6IFwiYWRkLXRvb2xcIiwgbGFiZWw6IFwiSGVsbG9cIiB9LCBoKFwiZGl2XCIsIG51bGwsIFwiSGVsbG9cIikpKSkgOiBudWxsKSk7XG4gICAgICAgICAgICB9KSA/PyBbXSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuY2F0ZWdvcmllcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5tb2RlID0gUkZ4TGlzdFZpZXdNb2RlLlNUQU5EQVJEO1xuICAgICAgICB0aGlzLnJmeEZ1bmN0aW9uc0FycmF5ID0gW107XG4gICAgICAgIHRoaXMuc2VhcmNoSXNBY3RpdmUgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuc2NhbGUgPSBVSURlZmF1bHRzLlNjYWxlO1xuICAgICAgICB0aGlzLnNob3dGdW5jdGlvbkRlc2NyaXB0aW9uID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLm9wZW5DYXRlZ29yaWVzID0gbmV3IFNldChbMF0pO1xuICAgICAgICB0aGlzLnJmeEZ1bmN0aW9uc01hcCA9IG5ldyBNYXAoKTtcbiAgICB9XG4gICAgb25CdWlsZFJmeEZ1bmN0aW9uc01hcCgpIHtcbiAgICAgICAgY29uc3QgbmV3RnVuY3Rpb25zTWFwID0gbmV3IE1hcCgpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY2F0ZWdvcmllcz8ubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIG5ld0Z1bmN0aW9uc01hcC5zZXQodGhpcy5jYXRlZ29yaWVzW2ldLCB0aGlzLnJmeEZ1bmN0aW9uc0FycmF5LmZpbHRlcigocmZ4RnVuY3Rpb25JdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJmeEZ1bmN0aW9uSXRlbS5jYXRlZ29yeU5hbWUgPT09IHRoaXMuY2F0ZWdvcmllc1tpXTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJmeEZ1bmN0aW9uc01hcCA9IG5ld0Z1bmN0aW9uc01hcDtcbiAgICB9XG4gICAgZ2V0IGlzRW1iZWRkZWRJbkNvcmVBcHAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vZGUgPT09IFJGeExpc3RWaWV3TW9kZS5DT1JFO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAY2F0ZWdvcnkgTGlmZWN5Y2xlXG4gICAgICovXG4gICAgYXN5bmMgY29tcG9uZW50V2lsbExvYWQoKSB7XG4gICAgICAgICh7IHN0cmluZ3M6IHRoaXMuc3RyaW5ncywgZGlyOiB0aGlzLmRpciB9ID0gYXdhaXQgZmV0Y2hDb21wb25lbnRMb2NhbGVTdHJpbmdzKHRoaXMuaG9zdEVsZW1lbnQsIGdldEFzc2V0UGF0aChgLmApKSk7XG4gICAgICAgIHRoaXMub25CdWlsZFJmeEZ1bmN0aW9uc01hcCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAY2F0ZWdvcnkgTGlmZXN0eWxlXG4gICAgICovXG4gICAgZGlzY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlSGVscFRvb2x0aXAoKTtcbiAgICAgICAgdGhpcy5yZnhGdW5jdGlvbkhlbHBUb29sdGlwPy5yZW1vdmUoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGNhdGVnb3J5IExpZmVjeWNsZVxuICAgICAqIFJlbmRlciBsaWZlY3ljbGUgbWV0aG9kXG4gICAgICovXG4gICAgcmVuZGVyKCkge1xuICAgICAgICByZXR1cm4gKGgoSG9zdCwgbnVsbCwgdGhpcy5yZnhGdW5jdGlvbnNBcnJheS5sZW5ndGggPiAwID8gdGhpcy5kaXNwbGF5UmVzdWx0cygpIDogdGhpcy5yZW5kZXJOb1Jlc3VsdHMoKSkpO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0IGFzc2V0c0RpcnMoKSB7IHJldHVybiBbXCJ0OW5cIl07IH1cbiAgICBnZXQgaG9zdEVsZW1lbnQoKSB7IHJldHVybiBnZXRFbGVtZW50KHRoaXMpOyB9XG4gICAgc3RhdGljIGdldCB3YXRjaGVycygpIHsgcmV0dXJuIHtcbiAgICAgICAgXCJjYXRlZ29yaWVzXCI6IFtcIm9uQnVpbGRSZnhGdW5jdGlvbnNNYXBcIl0sXG4gICAgICAgIFwicmZ4RnVuY3Rpb25zQXJyYXlcIjogW1wib25CdWlsZFJmeEZ1bmN0aW9uc01hcFwiXVxuICAgIH07IH1cbn07XG5SZnhGdW5jdGlvbnNMaXN0LnN0eWxlID0gcmZ4RnVuY3Rpb25zTGlzdENzcztcblxuY29uc3QgUmFzdGVyRnVuY3Rpb25zTGlzdCA9IGNsYXNzIHtcbiAgICBjb25zdHJ1Y3Rvcihob3N0UmVmKSB7XG4gICAgICAgIHJlZ2lzdGVySW5zdGFuY2UodGhpcywgaG9zdFJlZik7XG4gICAgICAgIHRoaXMudHJpZ2dlclNlbGVjdEZ1bmN0aW9uID0gY3JlYXRlRXZlbnQodGhpcywgXCJ0cmlnZ2VyU2VsZWN0RnVuY3Rpb25cIiwgNyk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiAgQW5hbHlzaXMgc3R1ZGlvIHNlYXJjaCdzIGNhbGNpdGUgZmlsdGVyJ3MgdmFsdWVcbiAgICAgICAgICogIEBjYXRlZ29yeSBQcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNlYXJjaFZhbHVlID0gXCJcIjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBtb3N0IHJlY2VudCBmaWx0ZXIgc2VsZWN0aW9uLCB0byBmaWx0ZXIgc2VhcmNoIHJlc3VsdHNcbiAgICAgICAgICogQGNhdGVnb3J5IFByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZmlsdGVyVmFsdWUgPSBbXTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBjYXRlZ29yeSBQcml2YXRlXG4gICAgICAgICAqIEBwYXJhbSBldmVudCB0aGUgc2VhcmNoIHJlc3VsdHNcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc2VhcmNoQ2FsbGJhY2sgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc2VhcmNoVmFsdWUgPSBldmVudC5kZXRhaWwuc2VhcmNoVmFsdWU7XG4gICAgICAgICAgICB0aGlzLmZ1bmN0aW9uc0xpc3QgPSBbLi4uZXZlbnQuZGV0YWlsLnJmeEZ1bmN0aW9uc107XG4gICAgICAgICAgICB0aGlzLmZpbHRlclZhbHVlID0gWy4uLmV2ZW50LmRldGFpbC5maWx0ZXJWYWx1ZV07XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBoYW5kbGVyIGNhbGxlZCBhcyBzb29uIGFzIHRoZSBwYW5lbCBjaGFuZ2VzXG4gICAgICAgICAqIEBjYXRlZ29yeSBQcml2YXRlXG4gICAgICAgICAqIEBwYXJhbSBwYW5lbENoYW5nZUV2ZW50IGN1c3RvbSBldmVudCBjb250YWluaW5nIHRoZSBkaXJlY3Rpb24gd2hlcmUgdGhlIGZsb3cgaXMgdG8gbW92ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5oYW5kbGVUcmlnZ2VyUGFuZWxDaGFuZ2UgPSAocGFuZWxDaGFuZ2VFdmVudCkgPT4ge1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogaGFuZGxlciBjYWxsZWQgYXMgc29vbiBhcyBhIHJmeCBpcyBvcGVuZWQgb3Igc2VsZWN0ZWQgZnJvbSB0aGUgcmZ4IGxpc3RcbiAgICAgICAgICogQGNhdGVnb3J5IFByaXZhdGVcbiAgICAgICAgICogQHBhcmFtIHNlbGVjdFRvb2xFdmVudCBjdXN0b20gZXZlbnQgY29udGFpbmluZyB0aGUgZGF0YSBmb3IgdGhlIHRvb2wgc2VsZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaGFuZGxlVHJpZ2dlclNlbGVjdFRvb2wgPSAoc2VsZWN0VG9vbEV2ZW50KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBzZWxlY3RlZFJGeCA9IHNlbGVjdFRvb2xFdmVudC5kZXRhaWw7XG4gICAgICAgICAgICB0aGlzLnRyaWdnZXJTZWxlY3RGdW5jdGlvbi5lbWl0KHNlbGVjdGVkUkZ4LnRvb2xOYW1lKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGhhbmRsZXIgY2FsbGVkIGFzIHNvb24gYXMgYSBjYXRlZ29yeSBpbiB0aGUgbGlzdCBpcyBvcGVuXG4gICAgICAgICAqIEBjYXRlZ29yeSBQcml2YXRlXG4gICAgICAgICAqIEBwYXJhbSBldmVudCBjdXN0b20gZXZlbnQgY29udGFpbmluZyB0aGUgY2F0ZWdvcnkgbnVtYmVyXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmhhbmRsZU9wZW5DYXRlZ29yeUNoYW5nZSA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgY2F0ZWdvcnlOdW1iZXIgPSBldmVudC5kZXRhaWw7XG4gICAgICAgICAgICBpZiAodGhpcy5vcGVuQ2F0ZWdvcmllcy5oYXMoY2F0ZWdvcnlOdW1iZXIpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vcGVuQ2F0ZWdvcmllcy5kZWxldGUoY2F0ZWdvcnlOdW1iZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vcGVuQ2F0ZWdvcmllcy5hZGQoY2F0ZWdvcnlOdW1iZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmZ1bmN0aW9uc0xpc3QgPSBbXTtcbiAgICAgICAgdGhpcy5tb2RlID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLm9wZW5DYXRlZ29yaWVzID0gbmV3IFNldChbMF0pO1xuICAgICAgICB0aGlzLnNob3dUb29sRGVzY3JpcHRpb24gPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuc2NhbGUgPSBVSURlZmF1bHRzLlNjYWxlO1xuICAgIH1cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy9cbiAgICAvLyAgUHVibGljIE1ldGhvZHNcbiAgICAvL1xuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvKipcbiAgICAgKiBAY2F0ZWdvcnkgTGlmZWN5Y2xlXG4gICAgICovXG4gICAgYXN5bmMgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgICAgIGNvbnN0IHsgcmZ4RnVuY3Rpb25zLCByZnhDYXRlZ29yaWVzIH0gPSBhd2FpdCBnZXRGdW5jdGlvbnNBbmRDYXRlZ29yaWVzKCk7XG4gICAgICAgIHRoaXMucmZ4RnVuY3Rpb25zQXJyYXkgPSByZnhGdW5jdGlvbnMubWFwKChyYXN0ZXJUb29sKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGFuYWx5c2lzRW5naW5lOiBcInJhc3RlclwiLFxuICAgICAgICAgICAgICAgIGNhdGVnb3J5TmFtZTogcmFzdGVyVG9vbC5jYXRlZ29yeSxcbiAgICAgICAgICAgICAgICBjYXRlZ29yeVRpdGxlOiByYXN0ZXJUb29sLmNhdGVnb3J5VGl0bGUsXG4gICAgICAgICAgICAgICAgZGVzY3JpcHRpb246IHJhc3RlclRvb2wuc25pcHBldCxcbiAgICAgICAgICAgICAgICBpY29uOiBcInJhc3Rlci1mdW5jdGlvblwiLFxuICAgICAgICAgICAgICAgIHRpdGxlOiByYXN0ZXJUb29sLnRpdGxlLFxuICAgICAgICAgICAgICAgIHRvb2xOYW1lOiByYXN0ZXJUb29sLm5hbWUsXG4gICAgICAgICAgICAgICAgYW5hbHlzaXNUeXBlOiBcInJmdFwiXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHRoaXMucmZ4RnVuY3Rpb25zQXJyYXk/Lmxlbmd0aCA+IC0xKSB7XG4gICAgICAgICAgICB0aGlzLnJmeENhdGVnb3JpZXMgPSByZnhDYXRlZ29yaWVzO1xuICAgICAgICAgICAgdGhpcy5mdW5jdGlvbnNMaXN0ID0gWy4uLnRoaXMucmZ4RnVuY3Rpb25zQXJyYXldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgcmV0dXJuIChoKFwiZGl2XCIsIG51bGwsIGgoXCJyZngtc2VhcmNoXCIsIHsgcmZ4RnVuY3Rpb25zQXJyYXk6IHRoaXMucmZ4RnVuY3Rpb25zQXJyYXkgPz8gW10sIG9uQW5hbHlzaXNTdHVkaW9TZWFyY2hVcGRhdGU6IHRoaXMuc2VhcmNoQ2FsbGJhY2ssIHNlYXJjaFZhbHVlOiB0aGlzLnNlYXJjaFZhbHVlLCBmaWx0ZXJWYWx1ZTogdGhpcy5maWx0ZXJWYWx1ZSwgaGlkZUZpbHRlcjogdHJ1ZSB9KSwgaChcInJmeC1mdW5jdGlvbnMtbGlzdFwiLCB7IHJmeEZ1bmN0aW9uc0FycmF5OiB0aGlzLmZ1bmN0aW9uc0xpc3QsIGNhdGVnb3JpZXM6IHRoaXMucmZ4Q2F0ZWdvcmllcywgc2VhcmNoSXNBY3RpdmU6IHRoaXMuc2VhcmNoVmFsdWUgIT09IFwiXCIsIHNob3dGdW5jdGlvbkRlc2NyaXB0aW9uOiBmYWxzZSwgbW9kZTogdGhpcy5tb2RlLCBzY2FsZTogdGhpcy5zY2FsZSwgb25UcmlnZ2VyQ2hhbmdlUGFuZWw6IHRoaXMuaGFuZGxlVHJpZ2dlclBhbmVsQ2hhbmdlLCBvblRyaWdnZXJTZWxlY3RUb29sOiB0aGlzLmhhbmRsZVRyaWdnZXJTZWxlY3RUb29sLCBvcGVuQ2F0ZWdvcmllczogdGhpcy5vcGVuQ2F0ZWdvcmllcywgb25PcGVuQ2F0ZWdvcmllc0NoYW5nZTogdGhpcy5oYW5kbGVPcGVuQ2F0ZWdvcnlDaGFuZ2UgfSkpKTtcbiAgICB9XG59O1xuXG5jb25zdCBIVE1MQ2xhc3NlcyA9IHtcbiAgICBhY3Rpb25QYWRkaW5nOiBcImFjdGlvbi1wYWRkaW5nXCIsXG4gICAgcnRsOiBcImFuYWx5c2lzLS1ydGxcIlxufTtcblxuY29uc3QgcmZ4U2VhcmNoQ3NzID0gXCI6cm9vdHstLWNhbGNpdGUtY29sb3ItYnJhbmQ6IzAwN2FjMjstLWNhbGNpdGUtY29sb3ItYnJhbmQtaG92ZXI6IzAwNjE5YjstLWNhbGNpdGUtY29sb3ItYnJhbmQtcHJlc3M6IzAwNDg3NDstLWNhbGNpdGUtY29sb3Itc3RhdHVzLWluZm86IzAwNjE5YjstLWNhbGNpdGUtY29sb3Itc3RhdHVzLXN1Y2Nlc3M6IzM1YWM0NjstLWNhbGNpdGUtY29sb3Itc3RhdHVzLXdhcm5pbmc6I2VkZDMxNzstLWNhbGNpdGUtY29sb3Itc3RhdHVzLWRhbmdlcjojZDgzMDIwOy0tY2FsY2l0ZS1jb2xvci1zdGF0dXMtZGFuZ2VyLWhvdmVyOiNhODJiMWU7LS1jYWxjaXRlLWNvbG9yLXN0YXR1cy1kYW5nZXItcHJlc3M6IzdjMWQxMzstLWNhbGNpdGUtY29sb3ItYmFja2dyb3VuZDojZjhmOGY4Oy0tY2FsY2l0ZS1jb2xvci1mb3JlZ3JvdW5kLTE6I2ZmZmZmZjstLWNhbGNpdGUtY29sb3ItZm9yZWdyb3VuZC0yOiNmM2YzZjM7LS1jYWxjaXRlLWNvbG9yLWZvcmVncm91bmQtMzojZWFlYWVhOy0tY2FsY2l0ZS1jb2xvci10ZXh0LTE6IzE1MTUxNTstLWNhbGNpdGUtY29sb3ItdGV4dC0yOiM0YTRhNGE7LS1jYWxjaXRlLWNvbG9yLXRleHQtMzojNmE2YTZhOy0tY2FsY2l0ZS1jb2xvci10ZXh0LWludmVyc2U6I2ZmZmZmZjstLWNhbGNpdGUtY29sb3ItdGV4dC1saW5rOiMwMDYxOWI7LS1jYWxjaXRlLWNvbG9yLWJvcmRlci0xOiNjYWNhY2E7LS1jYWxjaXRlLWNvbG9yLWJvcmRlci0yOiNkNGQ0ZDQ7LS1jYWxjaXRlLWNvbG9yLWJvcmRlci0zOiNkZmRmZGY7LS1jYWxjaXRlLWNvbG9yLWJvcmRlci1pbnB1dDojOTQ5NDk0Oy0tcmZ4LXF1YXJ0ZXItc3BhY2luZzowLjI1cmVtOy0tcmZ4LWhhbGYtc3BhY2luZzowLjVyZW07LS1yZngtdGhyZWUtcXVhcnRlci1zcGFjaW5nOjAuNzVyZW07LS1yZngtZnVsbC1zcGFjaW5nOjFyZW07LS1yZngtY29tcG9uZW50LWRlZmF1bHQtd2lkdGg6MTAwJTstLXJmeC11aS1ib3JkZXItaW5wdXQ6dmFyKC0tY2FsY2l0ZS1jb2xvci1ib3JkZXItMik7LS1yZngtcG9wb3Zlci1jb250ZW50LW1pbi1oZWlnaHQ6MzB2aDstLXJmeC1wb3BvdmVyLWNvbnRlbnQtbWF4LWhlaWdodDo2MHZoOy0tcmZ4LXBvcG92ZXItY29udGVudC1oZWlnaHQ6NDV2aDstLXJmeC13aWRnZXQtY29udGVudC1oZWlnaHQ6MzB2aH06aG9zdHtkaXNwbGF5OmZsZXg7YmFja2dyb3VuZC1jb2xvcjp2YXIoLS1jYWxjaXRlLWNvbG9yLWZvcmVncm91bmQtMSk7Ym9yZGVyLWJvdHRvbToxcHggc29saWQgdmFyKC0tY2FsY2l0ZS1jb2xvci1ib3JkZXItMyl9LmFjdGlvbi1wYWRkaW5ne3BhZGRpbmctcmlnaHQ6dmFyKC0tYW5hbHlzaXMtaGFsZi1zcGFjaW5nKTtwYWRkaW5nLWxlZnQ6MHJlbX06aG9zdCguYW5hbHlzaXMtLXJ0bCkgLmFjdGlvbi1wYWRkaW5ne3BhZGRpbmctbGVmdDp2YXIoLS1hbmFseXNpcy1oYWxmLXNwYWNpbmcpO3BhZGRpbmctcmlnaHQ6MHJlbX1cIjtcblxuY29uc3QgUmZ4U2VhcmNoID0gY2xhc3Mge1xuICAgIGNvbnN0cnVjdG9yKGhvc3RSZWYpIHtcbiAgICAgICAgcmVnaXN0ZXJJbnN0YW5jZSh0aGlzLCBob3N0UmVmKTtcbiAgICAgICAgdGhpcy5hbmFseXNpc1N0dWRpb1NlYXJjaFVwZGF0ZSA9IGNyZWF0ZUV2ZW50KHRoaXMsIFwiYW5hbHlzaXNTdHVkaW9TZWFyY2hVcGRhdGVcIiwgNyk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUT0RPOiBDdXJyZW50bHkgZmlsdGVyIGlzIGhpZGRlbiBhbmQgZG9lc24ndCB3b3JrLlxuICAgICAgICAgKiBBcHBsaWVzIHRoZSBmaWx0ZXIgdG8gYW4gaW5wdXRcbiAgICAgICAgICogQHBhcmFtIGRhdGFcbiAgICAgICAgICogQHBhcmFtIGZpbHRlclNlbGVjdGlvblxuICAgICAgICAgKiBAY2F0ZWdvcnkgcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5maWx0ZXJMaXN0ID0gKGRhdGEsIGZpbHRlclNlbGVjdGlvbikgPT4ge1xuICAgICAgICAgICAgLy8gcmV0dXJuIGRhdGEuZmlsdGVyKChyZnhGdW5jdGlvbkl0ZW06IFJmeEZ1bmN0aW9uSXRlbSkgPT4ge1xuICAgICAgICAgICAgLy8gcmV0dXJuIGZpbHRlclNlbGVjdGlvbi5sZW5ndGggPT09IDAgPyB0cnVlIDogZmlsdGVyU2VsZWN0aW9uLmluY2x1ZGVzKHJmeEZ1bmN0aW9uSXRlbS5hbmFseXNpc0VuZ2luZSk7XG4gICAgICAgICAgICAvLyB9KTtcbiAgICAgICAgICAgIHJldHVybiBkYXRhLmZpbHRlcigoKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZpbHRlclNlbGVjdGlvbi5sZW5ndGggPT09IDAgPyB0cnVlIDogZmFsc2U7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgdGhlIGFycmF5IG9mIGZ1bmN0aW9ucyB0aGF0IG9ubHkgY29udGFpbiBzZWFyY2hhYmxlIGluZm9ybWF0aW9uXG4gICAgICAgICAqIEBwYXJhbSBkYXRhXG4gICAgICAgICAqIEBjYXRlZ29yeSBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmdldFNlYXJjaGFibGVGdW5jdGlvbnNMaXN0ID0gKGRhdGEpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJmeEZ1bmN0aW9ucyA9IGRhdGEgPz8gdGhpcy5yZnhGdW5jdGlvbnNBcnJheTtcbiAgICAgICAgICAgIHJldHVybiByZnhGdW5jdGlvbnMubWFwKChyZnhGdW5jdGlvbkl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICB0aXRsZTogcmZ4RnVuY3Rpb25JdGVtLnRpdGxlLFxuICAgICAgICAgICAgICAgICAgICB0b29sTmFtZTogcmZ4RnVuY3Rpb25JdGVtLnRvb2xOYW1lLFxuICAgICAgICAgICAgICAgICAgICBrZXlzOiByZnhGdW5jdGlvbkl0ZW0ua2V5c1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEJhY2t0cmFja3MgZnJvbSBhbiBhcnJheSBvZiBSZnhTZWFyY2hhYmxlSXRlbXMgdG8gUmZ4RnVuY3Rpb25JdGVtc1xuICAgICAgICAgKiBAcGFyYW0gc2VhcmNoTGlzdFxuICAgICAgICAgKiBAY2F0ZWdvcnkgcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5nZXRUb29sc0xpc3RGcm9tU2VhcmNoTGlzdCA9IChzZWFyY2hMaXN0KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gc2VhcmNoTGlzdC5tYXAoKHNlYXJjaGFibGVJdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmZ4RnVuY3Rpb25zQXJyYXkuZmlsdGVyKChyZnhGdW5jdGlvbkl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChzZWFyY2hhYmxlSXRlbS50aXRsZSA9PT0gcmZ4RnVuY3Rpb25JdGVtLnRpdGxlICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWFyY2hhYmxlSXRlbS50b29sTmFtZSA9PT0gcmZ4RnVuY3Rpb25JdGVtLnRvb2xOYW1lKTtcbiAgICAgICAgICAgICAgICB9KVswXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQ2FsbGVkIHdoZW5ldmVyIHRoZSBzZWFyY2ggaXMgdXBkYXRlZCBhbmQgZW1pdHMgYW4gZXZlbnQgdG8gcGFyZW50IGNvbXBvbmVudHMgY29udGFpbmluZyB0aGUgcmVzdWx0cyBvZiB0aGUgc2VhcmNoXG4gICAgICAgICAqIEBjYXRlZ29yeSBQcml2YXRlXG4gICAgICAgICAqIEBwYXJhbSBldmVudCB0aGUgcmVzdWx0cyBvZiB0aGUgc2VhcmNoXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm9uQW5hbHlzaXNTdHVkaW9TZWFyY2hVcGRhdGUgPSAoKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5jYWxjaXRlRmlsdGVyLnZhbHVlICE9PSB0aGlzLnNlYXJjaFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZmlsdGVyUmVzdWx0ID0gdGhpcy5jYWxjaXRlRmlsdGVyLmZpbHRlcmVkSXRlbXM7XG4gICAgICAgICAgICAgICAgY29uc3QgZmlsdGVyZWRGdW5jdGlvbnMgPSB0aGlzLmZpbHRlckxpc3QodGhpcy5nZXRUb29sc0xpc3RGcm9tU2VhcmNoTGlzdChmaWx0ZXJSZXN1bHQpLCB0aGlzLmZpbHRlclZhbHVlKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJmeEZ1bmN0aW9uSXRlbXMgPSBbLi4uZmlsdGVyZWRGdW5jdGlvbnNdO1xuICAgICAgICAgICAgICAgIHRoaXMuYW5hbHlzaXNTdHVkaW9TZWFyY2hVcGRhdGUuZW1pdCh7XG4gICAgICAgICAgICAgICAgICAgIHJmeEZ1bmN0aW9uczogdGhpcy5yZnhGdW5jdGlvbkl0ZW1zLFxuICAgICAgICAgICAgICAgICAgICBzZWFyY2hWYWx1ZTogdGhpcy5jYWxjaXRlRmlsdGVyLnZhbHVlID8/IFwiXCIsXG4gICAgICAgICAgICAgICAgICAgIGZpbHRlclZhbHVlOiB0aGlzLmZpbHRlclZhbHVlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCB3aGVuIHRoZSBmaWx0ZXIgc2VsZWN0aW9uIGlzIHVwZGF0ZWQgYW5kIGVtaXRzIGFuIGV2ZW50XG4gICAgICAgICAqIHdpdGggdXBkYXRlZCBmaWx0ZXIgYW5kIHNlYXJjaCB2YWx1ZXNcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGZpbHRlckl0ZW1WYWx1ZSB0aGUgdmFsdWUgb2YgdGhlIGZpbHRlciBpdGVtIHRoYXQgd2FzIHNlbGVjdGVkXG4gICAgICAgICAqIEBjYXRlZ29yeSBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmhhbmRsZUZpbHRlckl0ZW1TZWxlY3Rpb24gPSAoZmlsdGVySXRlbVZhbHVlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBpc1NlbGVjdGVkID0gdGhpcy5maWx0ZXJWYWx1ZS5pbmNsdWRlcyhmaWx0ZXJJdGVtVmFsdWUpO1xuICAgICAgICAgICAgY29uc3QgbmV3RmlsdGVyU2VsZWN0aW9uID0gaXNTZWxlY3RlZCA9PT0gZmFsc2VcbiAgICAgICAgICAgICAgICA/IFsuLi50aGlzLmZpbHRlclZhbHVlLCBmaWx0ZXJJdGVtVmFsdWVdXG4gICAgICAgICAgICAgICAgOiB0aGlzLmZpbHRlclZhbHVlLmZpbHRlcigodmFsdWUpID0+IHZhbHVlICE9PSBmaWx0ZXJJdGVtVmFsdWUpO1xuICAgICAgICAgICAgY29uc3QgZGF0YSA9IHRoaXMuY2FsY2l0ZUZpbHRlci52YWx1ZSA9PT0gXCJcIlxuICAgICAgICAgICAgICAgID8gdGhpcy5yZnhGdW5jdGlvbnNBcnJheVxuICAgICAgICAgICAgICAgIDogdGhpcy5nZXRUb29sc0xpc3RGcm9tU2VhcmNoTGlzdCh0aGlzLmNhbGNpdGVGaWx0ZXIuZmlsdGVyZWRJdGVtcyk7XG4gICAgICAgICAgICB0aGlzLnJmeEZ1bmN0aW9uSXRlbXMgPSB0aGlzLmZpbHRlckxpc3QoZGF0YSwgbmV3RmlsdGVyU2VsZWN0aW9uKTtcbiAgICAgICAgICAgIHRoaXMuYW5hbHlzaXNTdHVkaW9TZWFyY2hVcGRhdGUuZW1pdCh7XG4gICAgICAgICAgICAgICAgcmZ4RnVuY3Rpb25zOiB0aGlzLnJmeEZ1bmN0aW9uSXRlbXMsXG4gICAgICAgICAgICAgICAgc2VhcmNoVmFsdWU6IHRoaXMuc2VhcmNoVmFsdWUgPz8gXCJcIixcbiAgICAgICAgICAgICAgICBmaWx0ZXJWYWx1ZTogbmV3RmlsdGVyU2VsZWN0aW9uXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5vcGVuID0gZmFsc2U7XG4gICAgICAgIHRoaXMucmZ4RnVuY3Rpb25JdGVtcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5yZnhGdW5jdGlvbnNBcnJheSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5zZWFyY2hWYWx1ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5maWx0ZXJWYWx1ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5wbGFjZWhvbGRlclRleHQgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuaGlkZUZpbHRlciA9IGZhbHNlO1xuICAgIH1cbiAgICBvbkRhdGFDaGFuZ2UobmV3VmFsdWUpIHtcbiAgICAgICAgdGhpcy5nZXRTZWFyY2hhYmxlRnVuY3Rpb25zTGlzdChuZXdWYWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBjYXRlZ29yeSBMaWZlY3ljbGVcbiAgICAgKi9cbiAgICBhc3luYyBjb21wb25lbnRXaWxsTG9hZCgpIHtcbiAgICAgICAgKHsgc3RyaW5nczogdGhpcy5zdHJpbmdzLCBkaXI6IHRoaXMuZGlyIH0gPSBhd2FpdCBmZXRjaENvbXBvbmVudExvY2FsZVN0cmluZ3ModGhpcy5ob3N0RWxlbWVudCwgZ2V0QXNzZXRQYXRoKGAuYCkpKTtcbiAgICAgICAgLy8gVE9ETzogZ2V0IGxvY2FsZSwgaW1wbGVtbnQgbGF0ZXIgd2hlbiB3ZSBhZGQgc3VwcG9ydCBmb3IgXCJrZXlzXCJcbiAgICAgICAgY29uc3QgY29tbW9uVDluID0ge1xuICAgICAgICAgICAgdG9vbEluZm9LZXlzOiB7fVxuICAgICAgICB9O1xuICAgICAgICAvLyBjb25zdCBjb21tb25UOW4gPSBhd2FpdCBmZXRjaExvY2FsZVN0cmluZ3Moe1xuICAgICAgICAvLyAgIGJhc2VVUkw6IGAke2dldEFzc2V0UGF0aChcImFzc2V0c1wiKX0vYCxcbiAgICAgICAgLy8gICBsb2NhbGU6IHN0YXRlLmxvY2FsZSxcbiAgICAgICAgLy8gICBwYXRoOiBcImNvbW1vblwiXG4gICAgICAgIC8vIH0pO1xuICAgICAgICB0aGlzLnNlYXJjaEtleXMgPSBjb21tb25UOW4udG9vbEluZm9LZXlzO1xuICAgICAgICB0aGlzLnJmeEZ1bmN0aW9uc0FycmF5LmZvckVhY2goKHJmeEZ1bmN0aW9uSXRlbSkgPT4ge1xuICAgICAgICAgICAgcmZ4RnVuY3Rpb25JdGVtLmtleXMgPSAocmZ4RnVuY3Rpb25JdGVtLmtleXMgPz8gW10pLm1hcCgoa2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgZm9ybWF0dGVkS2V5ID0ga2V5LnJlcGxhY2UoXCIkXCIsIFwiXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNlYXJjaEtleXM/Lltmb3JtYXR0ZWRLZXldO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmZ4RnVuY3Rpb25JdGVtO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5yZnhGdW5jdGlvbkl0ZW1zID0gWy4uLnRoaXMucmZ4RnVuY3Rpb25zQXJyYXldO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAY2F0ZWdvcnkgTGlmZWN5Y2xlXG4gICAgICovXG4gICAgY29tcG9uZW50RGlkTG9hZCgpIHtcbiAgICAgICAgLy8gRm9yY2VzIHRoZSBjYWxjaXRlIGZpbHRlciB0byBnZW5lcmF0ZSBmaWx0ZXJlZEl0ZW1zIHdpdGhvdXRcbiAgICAgICAgLy8gZmlyaW5nIHRoZSBzZWFyY2ggY2hhbmdlIGV2ZW50LiBOZWVkZWQgZm9yIGZpbHRlclZhbHVlIHVwZGF0ZXNcbiAgICAgICAgLy8gSXNzdWUgZG9jdW1lbnRlZCBpbiBjYWxjaXRlLWNvbXBvbmVudHMgcmVwbyAjNDExMVxuICAgICAgICB0aGlzLmNhbGNpdGVGaWx0ZXIuaXRlbXMgPSBbLi4udGhpcy5jYWxjaXRlRmlsdGVyLml0ZW1zXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVE9ETzogY3VycmVudGx5IGRvZXMgbm8gZmlsdGVyaW5nLCB3aWxsIGJlIHVzZWZ1bCB3aGVuIGZpbHRlciBzdXBwb3J0IGlzIGFkZGVkXG4gICAgICogUmVuZGVycyBhIGRyb3Bkb3duIGl0ZW0gZm9yIHRoZSBmaWx0ZXIgZHJvcGRvd25cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgdGhlIHZhbHVlIG9mIHRoZSBkcm9wZG93biBpdGVtLCB1c2VkIHRvIGRldGVybWluZSBpZiB0aGUgaXRlbSBpcyBzZWxlY3RlZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBsYWJlbCB0aGUgbGFiZWwgb2YgdGhlIGRyb3Bkb3duIGl0ZW1cbiAgICAgKiBAY2F0ZWdvcnkgcHJpdmF0ZVxuICAgICAqL1xuICAgIC8vIHByaXZhdGUgcmVuZGVyRHJvcGRvd25JdGVtKHZhbHVlOiBzdHJpbmcsIGxhYmVsOiBzdHJpbmcpOiBIVE1MQ2FsY2l0ZURyb3Bkb3duSXRlbUVsZW1lbnQge1xuICAgIC8vICAgcmV0dXJuIChcbiAgICAvLyAgICAgPGNhbGNpdGUtZHJvcGRvd24taXRlbVxuICAgIC8vICAgICAgIGtleT17dmFsdWV9XG4gICAgLy8gICAgICAgbGFiZWw9e2xhYmVsfVxuICAgIC8vICAgICAgIHNlbGVjdGVkPXt0aGlzLmZpbHRlclZhbHVlLmluY2x1ZGVzKHZhbHVlKX1cbiAgICAvLyAgICAgICBvbkNhbGNpdGVEcm9wZG93bkl0ZW1TZWxlY3Q9eygpID0+IHRoaXMuaGFuZGxlRmlsdGVySXRlbVNlbGVjdGlvbih2YWx1ZSl9XG4gICAgLy8gICAgID5cbiAgICAvLyAgICAgICB7bGFiZWx9XG4gICAgLy8gICAgIDwvY2FsY2l0ZS1kcm9wZG93bi1pdGVtPlxuICAgIC8vICAgKTtcbiAgICAvLyB9XG4gICAgLyoqXG4gICAgICogVE9ETzogY3VycmVudGx5IGRvZXMgbm8gZmlsdGVyaW5nLCB3aWxsIGJlIHVzZWZ1bCB3aGVuIGZpbHRlciBzdXBwb3J0IGlzIGFkZGVkXG4gICAgICogQ29uZGl0aW9uYWxseSByZW5kZXJzIHRoZSBkcm9wZG93biBtZW51IHRoYXQgYWxsb3dzIHRoZSB1c2VyIHRvIGZpbHRlciB0aGUgZnVuY3Rpb25zIGJ5IHR5cGVcbiAgICAgKiBpZiB0aGVyZSBpcyBvbmx5IG9uZSB0eXBlIG9mIGZ1bmN0aW9uLCB0aGUgZHJvcGRvd24gaXMgbm90IHJlbmRlcmVkXG4gICAgICogQGNhdGVnb3J5IHByaXZhdGVcbiAgICAgKi9cbiAgICAvLyBwcml2YXRlIHJlbmRlckRyb3Bkb3duKCk6IEhUTUxDYWxjaXRlRHJvcGRvd25Hcm91cEVsZW1lbnQge1xuICAgIC8vICAgY29uc3QgcGVyZm9ybWFibGVUeXBlcyA9IHtcbiAgICAvLyAgICAgLy8gc3RhbmRhcmQ6IHN0YXRlLmNhblBlcmZvcm1TdGFuZGFyZCxcbiAgICAvLyAgICAgLy8gcmFzdGVyOiBzdGF0ZS5jYW5QZXJmb3JtUmFzdGVyLFxuICAgIC8vICAgICBzdGFuZGFyZDogZmFsc2UsXG4gICAgLy8gICAgIHJhc3RlcjogdHJ1ZSxcbiAgICAvLyAgICAgZ2VvYW5hbHl0aWNzOiBmYWxzZSAvLyBGSVhNRTogUmV2ZXJ0IGNoYW5nZSBvbmNlIGdlb2FuYWx5dGljcyB0b29scyBhcmUgYXZhaWxhYmxlXG4gICAgLy8gICB9O1xuICAgIC8vICAgLy8gT25seSByZW5kZXIgdGhlIGRyb3Bkb3duIGlmIHRoZXJlIGFyZSBtdWx0aXBsZSB0eXBlcyBvZiB0b29scyB0aGF0IGNhbiBiZSBwZXJmb3JtZWRcbiAgICAvLyAgIGNvbnN0IHNob3VsZFJlbmRlciA9XG4gICAgLy8gICAgIE9iamVjdC52YWx1ZXMocGVyZm9ybWFibGVUeXBlcykuZmlsdGVyKChjYW5QZXJmb3JtKSA9PiBjYW5QZXJmb3JtID09PSB0cnVlKS5sZW5ndGggPiAxO1xuICAgIC8vICAgcmV0dXJuIChcbiAgICAvLyAgICAgc2hvdWxkUmVuZGVyICYmIChcbiAgICAvLyAgICAgICA8Y2FsY2l0ZS1kcm9wZG93biBwbGFjZW1lbnQ9XCJib3R0b20tc3RhcnRcIiBvdmVybGF5UG9zaXRpb25pbmc9XCJmaXhlZFwiIGNsb3NlT25TZWxlY3REaXNhYmxlZD5cbiAgICAvLyAgICAgICAgIDxjYWxjaXRlLWFjdGlvblxuICAgIC8vICAgICAgICAgICB0ZXh0PXt0aGlzLnN0cmluZ3MuYWN0aW9uTGFiZWx9XG4gICAgLy8gICAgICAgICAgIGljb249XCJzbGlkZXJzXCJcbiAgICAvLyAgICAgICAgICAgYXBwZWFyYW5jZT1cInNvbGlkXCJcbiAgICAvLyAgICAgICAgICAgc2NhbGU9XCJzXCJcbiAgICAvLyAgICAgICAgICAgY2xhc3M9e0hUTUxDbGFzc2VzLmFjdGlvblBhZGRpbmd9XG4gICAgLy8gICAgICAgICAgIHNsb3Q9XCJ0cmlnZ2VyXCJcbiAgICAvLyAgICAgICAgID5cbiAgICAvLyAgICAgICAgICAgPGNhbGNpdGUtdG9vbHRpcFxuICAgIC8vICAgICAgICAgICAgIGxhYmVsPXt0aGlzLnN0cmluZ3MuYWN0aW9uTGFiZWx9XG4gICAgLy8gICAgICAgICAgICAgb3ZlcmxheVBvc2l0aW9uaW5nPVwiZml4ZWRcIlxuICAgIC8vICAgICAgICAgICAgIGNsb3NlT25DbGlja1xuICAgIC8vICAgICAgICAgICAgIHNsb3Q9XCJ0b29sdGlwXCJcbiAgICAvLyAgICAgICAgICAgICBwbGFjZW1lbnQ9XCJ0cmFpbGluZ1wiXG4gICAgLy8gICAgICAgICAgID5cbiAgICAvLyAgICAgICAgICAgICB7dGhpcy5zdHJpbmdzLmFjdGlvbkxhYmVsfVxuICAgIC8vICAgICAgICAgICA8L2NhbGNpdGUtdG9vbHRpcD5cbiAgICAvLyAgICAgICAgIDwvY2FsY2l0ZS1hY3Rpb24+XG4gICAgLy8gICAgICAgICA8Y2FsY2l0ZS1kcm9wZG93bi1ncm91cFxuICAgIC8vICAgICAgICAgICBrZXk9XCJ0b29scy1maWx0ZXJcIlxuICAgIC8vICAgICAgICAgICBncm91cFRpdGxlPXt0aGlzLnN0cmluZ3MuYW5hbHlzaXNFbmdpbmV9XG4gICAgLy8gICAgICAgICAgIHNlbGVjdGlvbk1vZGU9XCJtdWx0aXBsZVwiXG4gICAgLy8gICAgICAgICA+XG4gICAgLy8gICAgICAgICAgIHtwZXJmb3JtYWJsZVR5cGVzLnJhc3RlciAmJlxuICAgIC8vICAgICAgICAgICAgIHRoaXMucmVuZGVyRHJvcGRvd25JdGVtKFwicmFzdGVyXCIsIHRoaXMuc3RyaW5ncy5yYXN0ZXJBbmFseXNpcyl9XG4gICAgLy8gICAgICAgICA8L2NhbGNpdGUtZHJvcGRvd24tZ3JvdXA+XG4gICAgLy8gICAgICAgPC9jYWxjaXRlLWRyb3Bkb3duPlxuICAgIC8vICAgICApXG4gICAgLy8gICApO1xuICAgIC8vIH1cbiAgICAvKipcbiAgICAgKiBAY2F0ZWdvcnkgTGlmZWN5Y2xlXG4gICAgICogUmVuZGVyIGxpZmVjeWNsZSBtZXRob2RcbiAgICAgKi9cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHJldHVybiAoaChIb3N0LCB7IGNsYXNzOiB7IFtIVE1MQ2xhc3Nlcy5ydGxdOiB0aGlzLmRpciA9PT0gXCJydGxcIiB9IH0sIGgoXCJjYWxjaXRlLWZpbHRlclwiLCB7IHBsYWNlaG9sZGVyOiB0aGlzLnBsYWNlaG9sZGVyVGV4dCA/PyB0aGlzLnN0cmluZ3MuZGVmYXVsdFNlYXJjaFBsYWNlaG9sZGVyLCBpdGVtczogdGhpcy5nZXRTZWFyY2hhYmxlRnVuY3Rpb25zTGlzdCh0aGlzLnJmeEZ1bmN0aW9uc0FycmF5KSwgb25DYWxjaXRlRmlsdGVyQ2hhbmdlOiB0aGlzLm9uQW5hbHlzaXNTdHVkaW9TZWFyY2hVcGRhdGUsIHZhbHVlOiB0aGlzLnNlYXJjaFZhbHVlLCByZWY6IChlKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5jYWxjaXRlRmlsdGVyID0gZTtcbiAgICAgICAgICAgIH0sIGRpcjogdGhpcy5kaXIgfSkpKTtcbiAgICB9XG4gICAgc3RhdGljIGdldCBhc3NldHNEaXJzKCkgeyByZXR1cm4gW1widDluXCJdOyB9XG4gICAgZ2V0IGhvc3RFbGVtZW50KCkgeyByZXR1cm4gZ2V0RWxlbWVudCh0aGlzKTsgfVxuICAgIHN0YXRpYyBnZXQgd2F0Y2hlcnMoKSB7IHJldHVybiB7XG4gICAgICAgIFwicmZ4RnVuY3Rpb25JdGVtc1wiOiBbXCJvbkRhdGFDaGFuZ2VcIl1cbiAgICB9OyB9XG59O1xuUmZ4U2VhcmNoLnN0eWxlID0gcmZ4U2VhcmNoQ3NzO1xuXG5leHBvcnQgeyBSZnhGdW5jdGlvbnNMaXN0IGFzIHJmeF9mdW5jdGlvbnNfbGlzdCwgUmFzdGVyRnVuY3Rpb25zTGlzdCBhcyByZnhfbGlzdF92aWV3LCBSZnhTZWFyY2ggYXMgcmZ4X3NlYXJjaCB9O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZngtZnVuY3Rpb25zLWxpc3RfMy5lbnRyeS5qcy5tYXAiLCJpbXBvcnQgeyBpIGFzIGlzQXJyYXlMaWtlLCBhIGFzIGlzQXJyYXksIGIgYXMgaXNCdWZmZXIsIGMgYXMgaXNUeXBlZEFycmF5LCBkIGFzIGlzQXJndW1lbnRzLCBnIGFzIGdldFRhZywgZSBhcyBpc1Byb3RvdHlwZSwgZiBhcyBiYXNlS2V5cywgaCBhcyBpc1BsYWluT2JqZWN0IH0gZnJvbSAnLi9fZ2V0VGFnLTk2YWYwMjlkLmpzJztcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIG1hcFRhZyA9ICdbb2JqZWN0IE1hcF0nLFxuICAgIHNldFRhZyA9ICdbb2JqZWN0IFNldF0nO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGFuIGVtcHR5IG9iamVjdCwgY29sbGVjdGlvbiwgbWFwLCBvciBzZXQuXG4gKlxuICogT2JqZWN0cyBhcmUgY29uc2lkZXJlZCBlbXB0eSBpZiB0aGV5IGhhdmUgbm8gb3duIGVudW1lcmFibGUgc3RyaW5nIGtleWVkXG4gKiBwcm9wZXJ0aWVzLlxuICpcbiAqIEFycmF5LWxpa2UgdmFsdWVzIHN1Y2ggYXMgYGFyZ3VtZW50c2Agb2JqZWN0cywgYXJyYXlzLCBidWZmZXJzLCBzdHJpbmdzLCBvclxuICogalF1ZXJ5LWxpa2UgY29sbGVjdGlvbnMgYXJlIGNvbnNpZGVyZWQgZW1wdHkgaWYgdGhleSBoYXZlIGEgYGxlbmd0aGAgb2YgYDBgLlxuICogU2ltaWxhcmx5LCBtYXBzIGFuZCBzZXRzIGFyZSBjb25zaWRlcmVkIGVtcHR5IGlmIHRoZXkgaGF2ZSBhIGBzaXplYCBvZiBgMGAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgZW1wdHksIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0VtcHR5KG51bGwpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNFbXB0eSh0cnVlKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzRW1wdHkoMSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0VtcHR5KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNFbXB0eSh7ICdhJzogMSB9KTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRW1wdHkodmFsdWUpIHtcbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoaXNBcnJheUxpa2UodmFsdWUpICYmXG4gICAgICAoaXNBcnJheSh2YWx1ZSkgfHwgdHlwZW9mIHZhbHVlID09ICdzdHJpbmcnIHx8IHR5cGVvZiB2YWx1ZS5zcGxpY2UgPT0gJ2Z1bmN0aW9uJyB8fFxuICAgICAgICBpc0J1ZmZlcih2YWx1ZSkgfHwgaXNUeXBlZEFycmF5KHZhbHVlKSB8fCBpc0FyZ3VtZW50cyh2YWx1ZSkpKSB7XG4gICAgcmV0dXJuICF2YWx1ZS5sZW5ndGg7XG4gIH1cbiAgdmFyIHRhZyA9IGdldFRhZyh2YWx1ZSk7XG4gIGlmICh0YWcgPT0gbWFwVGFnIHx8IHRhZyA9PSBzZXRUYWcpIHtcbiAgICByZXR1cm4gIXZhbHVlLnNpemU7XG4gIH1cbiAgaWYgKGlzUHJvdG90eXBlKHZhbHVlKSkge1xuICAgIHJldHVybiAhYmFzZUtleXModmFsdWUpLmxlbmd0aDtcbiAgfVxuICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwga2V5KSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuY29uc3QgUkZUX1RZUEUgPSBcIlJhc3RlckZ1bmN0aW9uVGVtcGxhdGVcIjtcbmNvbnN0IFRZUEVfS0VZV09SRCA9IFwidHlwZVwiO1xuY29uc3QgUkZWX1RZUEUgPSBcIlJhc3RlckZ1bmN0aW9uVmFyaWFibGVcIjtcbmNvbnN0IEFSR1NfS0VZV09SRCA9IFwiYXJndW1lbnRzXCI7XG5jb25zdCBGVU5DVElPTl9LRVlXT1JEID0gXCJmdW5jdGlvblwiO1xuZnVuY3Rpb24gaXNSZWZlcmVuY2VkT2JqZWN0KG9iaikge1xuICAgIGlmICghb2JqKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKG9iai5fb2JqZWN0X3JlZl9pZCAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBpc051bWJlcih4KSB7XG4gICAgeCA9IFN0cmluZyh4KS50cmltKCk7XG4gICAgaWYgKHggPT09IFwiXCIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gL15bKy1dPyhcXGQrKT8oXFwuXFxkKyk/JC8udGVzdCh4KTtcbn1cbmZ1bmN0aW9uIGlzV2lkZ2V0VmFsdWVCb29sZWFuKHgpIHtcbiAgICB4ID0gU3RyaW5nKHgpLnRyaW0oKTtcbiAgICByZXR1cm4gW1widHJ1ZVwiLCBcImZhbHNlXCJdLmluZGV4T2YoeCkgPj0gMDtcbn1cbmZ1bmN0aW9uIGlzQ29sb3JSYW1wKHJmeEFyZykge1xuICAgIGlmICghcmZ4QXJnKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHJmeEFyZy50eXBlICYmIHJmeEFyZy50eXBlLnRvTG93ZXJDYXNlKCkuaW5kZXhPZihcImNvbG9ycmFtcFwiKSA+PSAwKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAocmZ4QXJnLnZhbHVlICYmIHJmeEFyZy52YWx1ZS50eXBlICYmIHJmeEFyZy52YWx1ZS50eXBlLnRvTG93ZXJDYXNlKCkuaW5kZXhPZihcImNvbG9ycmFtcFwiKSA+PSAwKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBpc1JlY29yZFNldChyZnhBcmcpIHtcbiAgICByZXR1cm4gcmZ4QXJnLnR5cGUgJiYgcmZ4QXJnLnR5cGUudG9Mb3dlckNhc2UoKS5pbmRleE9mKFwicmVjb3Jkc2V0XCIpID49IDA7XG59XG4vKipcbiAqIERldGVybWluZXMgd2hldGhlciB0aGUgZ2l2ZW4gUkZUIGVsZW1lbnQgaXMgYW4gUkZ4IGFyZ3VtZW50LlxuICpcbiAqIEBwYXJhbSB7YW55fSByZnRFbGVtZW50IC0gVGhlIFJGVCBlbGVtZW50IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgZ2l2ZW4gZWxlbWVudCBpcyBSYXN0ZXJGdW5jdGlvblRlbXBsYXRlLFxuICogUmFzdGVyRnVuY3Rpb25WYXJpYWJsZSwgaXNDb2xvclJhbXAsIGlzUmVjb3JkU2V0OyBgZmFsc2VgIG90aGVyd2lzZS5cbiAqL1xuZnVuY3Rpb24gaXNSRnhBcmcocmZ0RWxlbWVudCkge1xuICAgIGlmICghcmZ0RWxlbWVudCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IHR5cGUgPSByZnRFbGVtZW50LnR5cGU7XG4gICAgcmV0dXJuIFtSRlRfVFlQRSwgUkZWX1RZUEVdLmluZGV4T2YodHlwZSkgPj0gMCB8fCBpc0NvbG9yUmFtcChyZnRFbGVtZW50KSB8fCBpc1JlY29yZFNldChyZnRFbGVtZW50KTtcbn1cbi8qKlxuICogRGV0ZXJtaW5lcyBpZiB0aGUgaW5wdXQgaXMgYSBGZWF0dXJlTGF5ZXJcbiAqIEBwYXJhbSB7X19lc3JpLkxheWVyfSBsYXllciB0aGUgbGF5ZXIgdG8gY2hlY2sgdGhlIHR5cGUgb2ZcbiAqIEByZXR1cm5zIHtsYXllciBpcyBfX2VzcmkuRmVhdHVyZUxheWVyfSBsYXllciBpcyBhIEZlYXR1cmVMYXllclxuICovXG5mdW5jdGlvbiBpc0ZlYXR1cmVMYXllcihsYXllcikge1xuICAgIHJldHVybiBsYXllci50eXBlID09PSBcImZlYXR1cmVcIjtcbn1cbi8qKlxuICogRGV0ZXJtaW5lcyBpZiB0aGUgaW5wdXQgaXMgYSBUaWxlTGF5ZXJcbiAqIEBwYXJhbSB7X19lc3JpLkxheWVyfSBsYXllciB0aGUgbGF5ZXIgdG8gY2hlY2sgdGhlIHR5cGUgb2ZcbiAqIEByZXR1cm5zIHtsYXllciBpcyBfX2VzcmkuVGlsZUxheWVyfSBsYXllciBpcyBhIFRpbGVMYXllclxuICovXG5mdW5jdGlvbiBpc1RpbGVMYXllcihsYXllcikge1xuICAgIHJldHVybiBsYXllci50eXBlID09PSBcInRpbGVcIjtcbn1cbi8qKlxuICogRGV0ZXJtaW5lcyBpZiB0aGUgaW5wdXQgaXMgYSBJbWFnZXJ5VGlsZUxheWVyXG4gKiBAcGFyYW0ge19fZXNyaS5MYXllcn0gbGF5ZXIgdGhlIGxheWVyIHRvIGNoZWNrIHRoZSB0eXBlIG9mXG4gKiBAcmV0dXJucyB7bGF5ZXIgaXMgX19lc3JpLkltYWdlcnlMYXllcn0gbGF5ZXIgaXMgYSBJbWFnZXJ5TGF5ZXJcbiAqL1xuZnVuY3Rpb24gaXNEeW5hbWljSW1hZ2VyeUxheWVyKGxheWVyKSB7XG4gICAgcmV0dXJuIChsYXllci50eXBlID09PSBcImltYWdlcnktdGlsZVwiICYmXG4gICAgICAgIGxheWVyLnNvdXJjZUpTT04uY2FwYWJpbGl0aWVzLnRvTG93ZXJDYXNlKCkuaW5kZXhPZihcInRpbGVzb25seVwiKSA8IDApO1xufVxuLyoqXG4gKiBEZXRlcm1pbmVzIGlmIHRoZSBpbnB1dCBpcyBhIEltYWdlcnlMYXllclxuICogQHBhcmFtIHtfX2VzcmkuTGF5ZXJ9IGxheWVyIHRoZSBsYXllciB0byBjaGVjayB0aGUgdHlwZSBvZlxuICogQHJldHVybnMge2xheWVyIGlzIF9fZXNyaS5JbWFnZXJ5TGF5ZXJ9IGxheWVyIGlzIGEgSW1hZ2VyeUxheWVyXG4gKi9cbmZ1bmN0aW9uIGlzSW1hZ2VyeUxheWVyKGxheWVyKSB7XG4gICAgcmV0dXJuIGxheWVyLnR5cGUgPT09IFwiaW1hZ2VyeVwiIHx8IGlzRHluYW1pY0ltYWdlcnlMYXllcihsYXllcik7XG59XG4vKipcbiAqIERldGVybWluZXMgaWYgdGhlIGlucHV0IGlzIGEgSW1hZ2VyeVRpbGVMYXllclxuICogQHBhcmFtIHtfX2VzcmkuTGF5ZXJ9IGxheWVyIHRoZSBsYXllciB0byBjaGVjayB0aGUgdHlwZSBvZlxuICogQHJldHVybnMge2xheWVyIGlzIF9fZXNyaS5JbWFnZXJ5VGlsZUxheWVyfSBsYXllciBpcyBhIEltYWdlcnlUaWxlTGF5ZXJcbiAqL1xuZnVuY3Rpb24gaXNJbWFnZXJ5VGlsZUxheWVyKGxheWVyKSB7XG4gICAgcmV0dXJuIGxheWVyLnR5cGUgPT09IFwiaW1hZ2VyeS10aWxlXCIgJiYgIWlzRHluYW1pY0ltYWdlcnlMYXllcihsYXllcik7XG59XG5mdW5jdGlvbiBpc0V2ZXJ5UHJvcGVydHlFbXB0eSh2YWx1ZSkge1xuICAgIGxldCBpc0FsbFByb3BzRW1wdHkgPSB0cnVlO1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiYgaXNBcnJheSh2YWx1ZSkgPT09IGZhbHNlKSB7XG4gICAgICAgIC8vIHVzaW5nIGZvci1pbiBhcyBpdCB3aWxsIHdvcmsgd2l0aCBvYmplY3RzIHdpdGggcHJvcGVydGllcyB0aGF0IHNldCB2aWEgYWNjZXNzb3JzIGFzIHdlbGxcbiAgICAgICAgZm9yIChjb25zdCBwcm9wIGluIHZhbHVlKSB7XG4gICAgICAgICAgICAvLyBUaGlzIHdpbGwgdGVsbCB0aGUgVHlwZVNjcmlwdCBjb21waWxlciB0aGF0IHRoZSBvYmogb2JqZWN0IGhhcyBhIHN0cmluZyBpbmRleCBzaWduYXR1cmUsXG4gICAgICAgICAgICAvLyBhbmQgd2lsbCBhbGxvdyB0byBhY2Nlc3MgaXRzIHByb3BlcnRpZXMgdXNpbmcgYSBzdHJpbmcgaW5kZXggd2l0aG91dCBnZXR0aW5nIHRoZSBcIkVsZW1lbnQgaW1wbGljaXRseSBoYXMgYW4gJ2FueScgdHlwZVwiIGVycm9yLlxuICAgICAgICAgICAgY29uc3QgcHJvcFZhbHVlID0gdmFsdWU/Lltwcm9wXTtcbiAgICAgICAgICAgIGlmICh2YWx1ZS5oYXNPd25Qcm9wZXJ0eShwcm9wKSA9PT0gdHJ1ZSAmJiBwcm9wVmFsdWUgIT09IHVuZGVmaW5lZCAmJiBwcm9wVmFsdWUgIT09IG51bGwgJiYgcHJvcFZhbHVlICE9PSBcIlwiKSB7XG4gICAgICAgICAgICAgICAgaXNBbGxQcm9wc0VtcHR5ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGlzQWxsUHJvcHNFbXB0eTtcbn1cbi8qKlxuICogQ2hlY2sgZm9yIGFuIGVtcHR5IHZhbHVlIGZvciBkYXRhIGl0ZW1zIGxpa2UgR1BTdHJpbmcgYW5kIEZpZWxkLlxuICogQHBhcmFtIHZhbHVlIGRhdGEgaXRlbSB2YWx1ZS5cbiAqIEByZXR1cm5zIHdoZXRoZXIgdGhlIHZhbHVlIGlzIGNvbnNpZGVyZWQgZW1wdHkuXG4gKi9cbmZ1bmN0aW9uIGlzRW1wdHlEYXRhSXRlbSh2YWx1ZSkge1xuICAgIHJldHVybiAodmFsdWUgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICB2YWx1ZSA9PT0gbnVsbCB8fFxuICAgICAgICAvLyBzaW5nbGUtc2VsZWN0LCBcIlwiIGlzIGEgc3BlY2lhbCBjYXNlIGZvciBzdHJpbmdzXG4gICAgICAgICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiYgdmFsdWUgPT09IFwiXCIpIHx8XG4gICAgICAgIC8vIHNpbmdsZS1zZWxlY3QsIGVtcHR5IG9iamVjdHMgYXJlIGEgc3BlY2lhbCBjYXNlIGZvciBuZXN0ZWQgdmFsdWVzXG4gICAgICAgIChpc1BsYWluT2JqZWN0KHZhbHVlKSAmJiBpc0VtcHR5KHZhbHVlKSkgfHxcbiAgICAgICAgLy8gbXVsdGktc2VsZWN0XG4gICAgICAgIChBcnJheS5pc0FycmF5KHZhbHVlKSAmJiB2YWx1ZS5sZW5ndGggPCAxKSB8fFxuICAgICAgICAvLyBvbmx5IHRlc3Rpbmcgb2JqZWN0cyB3aGljaCBhcmUgbm90IGFycmF5c1xuICAgICAgICAvLyBUT0RPOiBjb21iaW5lIGlzRXZlcnlQcm9wZXJ0eUVtcHR5IGFuZCBpc0VtcHR5RGF0YUl0ZW0gdG8gc2luZ2xlIGZ1bmN0aW9uXG4gICAgICAgICh0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiYgaXNBcnJheSh2YWx1ZSkgPT09IGZhbHNlICYmIGlzRXZlcnlQcm9wZXJ0eUVtcHR5KHZhbHVlKSkpO1xufVxuXG5leHBvcnQgeyBBUkdTX0tFWVdPUkQgYXMgQSwgRlVOQ1RJT05fS0VZV09SRCBhcyBGLCBSRlZfVFlQRSBhcyBSLCBUWVBFX0tFWVdPUkQgYXMgVCwgaXNSRnhBcmcgYXMgYSwgUkZUX1RZUEUgYXMgYiwgaXNSZWZlcmVuY2VkT2JqZWN0IGFzIGMsIGlzTnVtYmVyIGFzIGQsIGlzV2lkZ2V0VmFsdWVCb29sZWFuIGFzIGUsIGlzQ29sb3JSYW1wIGFzIGYsIGlzUmVjb3JkU2V0IGFzIGcsIGlzRmVhdHVyZUxheWVyIGFzIGgsIGlzRW1wdHlEYXRhSXRlbSBhcyBpLCBpc1RpbGVMYXllciBhcyBqLCBpc0R5bmFtaWNJbWFnZXJ5TGF5ZXIgYXMgaywgaXNJbWFnZXJ5TGF5ZXIgYXMgbCwgaXNJbWFnZXJ5VGlsZUxheWVyIGFzIG0gfTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHlwZS1nYXVyZHMtMTg0MDc0N2YuanMubWFwIiwiY29uc3QgVUlEZWZhdWx0cyA9IHtcbiAgICBTY2FsZTogXCJzXCIsXG4gICAgUG9wb3ZlclRpbWVyOiA2MFxufTtcbmNvbnN0IENhbGNpdGVTY2FsZSA9IHtcbiAgICBzOiBcInNcIixcbiAgICBtOiBcIm1cIlxufTtcbmNvbnN0IENhbGNpdGVPdmVybGF5UG9zaXRpb25pbmcgPSB7XG4gICAgYWJzb2x1dGU6IFwiYWJzb2x1dGVcIixcbiAgICBmaXhlZDogXCJmaXhlZFwiXG59O1xuXG5leHBvcnQgeyBDYWxjaXRlU2NhbGUgYXMgQywgVUlEZWZhdWx0cyBhcyBVLCBDYWxjaXRlT3ZlcmxheVBvc2l0aW9uaW5nIGFzIGEgfTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dWktdXRpbHMtOTI4YTQwOTYuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9