"use strict";
(self["webpackChunkexb_client"] = self["webpackChunkexb_client"] || []).push([["vendors-extensions_widgets_arcgis_analysis_node_modules_arcgis_app-components_dist_esm_locale-158e80"],{

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/item-c58ffced.js":
/*!**********************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/item-c58ffced.js ***!
  \**********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   a: () => (/* binding */ getHydratedItem),
/* harmony export */   b: () => (/* binding */ getItemDataUrl),
/* harmony export */   c: () => (/* binding */ getItem),
/* harmony export */   d: () => (/* binding */ getItemGroups),
/* harmony export */   g: () => (/* binding */ getItemData),
/* harmony export */   i: () => (/* binding */ isEditableItem)
/* harmony export */ });
/* harmony import */ var _portal_d518b571_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./portal-d518b571.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/portal-d518b571.js");
/* harmony import */ var _service_8c2c4241_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./service-8c2c4241.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/service-8c2c4241.js");
/* harmony import */ var _url_4c3ae54c_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./url-4c3ae54c.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/url-4c3ae54c.js");
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v4.0.58
 */




const getHydratedItem = async (itemId, portal) => {
    try {
        const item = await (0,_service_8c2c4241_js__WEBPACK_IMPORTED_MODULE_1__.r)(getItemUrl(itemId, portal), portal);
        // TODO: check if we still need to do this
        // if (isHostedService(item.typeKeywords, item.type)) {
        //   const itemData = getItemData(item.id, portal);
        //   return { result: { ...item, ...itemInfo, ...itemData } };
        // }
        return { result: item };
    }
    catch (error) {
        console.error(error);
        return { error: { code: "unhandledError" } };
    }
};
const getItemDataUrl = (itemId, portal) => `${getItemUrl(itemId, portal)}/data`;
const getItemData = async (itemId, portal) => {
    return (0,_service_8c2c4241_js__WEBPACK_IMPORTED_MODULE_1__.r)(getItemDataUrl(itemId, portal), portal);
};
// TODO: remove these once we figure out how to efficiently disable the toast on the Home App
const getItemUrl = (itemId, portal) => `${(0,_portal_d518b571_js__WEBPACK_IMPORTED_MODULE_0__.g)(portal)}content/items/${itemId}`;
const getItem = async (itemId, portal, requestOptions) => {
    try {
        const url = getItemUrl(itemId, portal);
        return await (0,_service_8c2c4241_js__WEBPACK_IMPORTED_MODULE_1__.r)(url, portal, requestOptions);
    }
    catch (error) {
        console.warn(error);
    }
};
const getItemGroups = async (itemId, portal) => {
    try {
        const url = `${getItemUrl(itemId, portal)}/groups`;
        return { result: await (0,_service_8c2c4241_js__WEBPACK_IMPORTED_MODULE_1__.r)(url, portal) };
    }
    catch (error) {
        // TODO: handle error
        console.error(error);
        return { error: { code: "unhandledError" } };
    }
};
const isEditableItem = async (item, portal) => {
    let isEditable = false;
    if ((0,_service_8c2c4241_js__WEBPACK_IMPORTED_MODULE_1__.i)(item.typeKeywords, item.type)) {
        isEditable = await hasEditingCapability(item.url, portal);
    }
    return isEditable;
};
const hasEditingCapability = async (layerUrl, portal, requiredNoToken = false) => {
    var _a, _b, _c;
    if (layerUrl) {
        try {
            const result = await (0,_service_8c2c4241_js__WEBPACK_IMPORTED_MODULE_1__.r)(`${(_a = (0,_url_4c3ae54c_js__WEBPACK_IMPORTED_MODULE_2__.p)(layerUrl)) === null || _a === void 0 ? void 0 : _a.baseServerUrl}/layers`, portal, { addTokenManually: !requiredNoToken });
            return (_b = result === null || result === void 0 ? void 0 : result.layers) === null || _b === void 0 ? void 0 : _b.reduce((memo, layer) => memo || (layer === null || layer === void 0 ? void 0 : layer.capabilities.includes("Editing")), false);
        }
        catch (error) {
            if ((_c = error === null || error === void 0 ? void 0 : error.message) === null || _c === void 0 ? void 0 : _c.toLowerCase().includes("token required")) {
                return hasEditingCapability(layerUrl, portal, true);
            }
        }
    }
    return false;
};



//# sourceMappingURL=item-c58ffced.js.map

/***/ }),

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/languageUtil-ef0e54b2.js":
/*!******************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/languageUtil-ef0e54b2.js ***!
  \******************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   C: () => (/* binding */ CSS_UTILITY),
/* harmony export */   a: () => (/* binding */ formatDate),
/* harmony export */   b: () => (/* binding */ formatPlural),
/* harmony export */   f: () => (/* binding */ formatNumber),
/* harmony export */   g: () => (/* binding */ getElementDir),
/* harmony export */   l: () => (/* binding */ languageMap)
/* harmony export */ });
/* harmony import */ var _loadModules_b4ac1247_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./loadModules-b4ac1247.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/loadModules-b4ac1247.js");
/* harmony import */ var _dom_4d367677_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./dom-4d367677.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/dom-4d367677.js");
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v4.0.58
 */



const languageMap = new Map([
    ["ar", "ar"],
    ["bg", "bg"],
    ["bs", "bs"],
    ["ca", "ca"],
    ["cs", "cs"],
    ["da", "da"],
    ["de", "de"],
    ["el", "el"],
    ["en", "en"],
    ["es", "es"],
    ["et", "et"],
    ["fi", "fi"],
    ["fr", "fr"],
    ["he", "he"],
    ["hr", "hr"],
    ["hu", "hu"],
    ["id", "id"],
    ["it", "it"],
    ["ja", "ja"],
    ["ko", "ko"],
    ["lt", "lt"],
    ["lv", "lv"],
    ["nb", "nb"],
    ["nl", "nl"],
    ["pl", "pl"],
    ["pt-br", "pt-BR"],
    ["pt-pt", "pt-PT"],
    ["ro", "ro"],
    ["ru", "ru"],
    ["sk", "sk"],
    ["sl", "sl"],
    ["sr", "sr"],
    ["sv", "sv"],
    ["th", "th"],
    ["tr", "tr"],
    ["uk", "uk"],
    ["vi", "vi"],
    ["zh-cn", "zh-CN"],
    ["zh-hk", "zh-HK"],
    ["zh-tw", "zh-TW"]
]);
// rtl
function getElementDir(el) {
    return getElementProp(el, "dir", "ltr");
}
function getElementProp(el, prop, value) {
    const closestWithProp = (0,_dom_4d367677_js__WEBPACK_IMPORTED_MODULE_1__.c)(el, `[${prop}]`);
    return closestWithProp ? closestWithProp.getAttribute(prop) : value;
}
// css
const CSS_UTILITY = {
    rtl: "arcgis--rtl"
};
async function formatNumber(number, options) {
    const { api, type, places } = options || {};
    if (api === 4) {
        const [intl] = await (0,_loadModules_b4ac1247_js__WEBPACK_IMPORTED_MODULE_0__.l)(["esri/intl"]);
        const numberFormatIntlOptions = intl.convertNumberFormatToIntlOptions({
            places,
            style: type,
            digitSeparator: true
        });
        return intl.formatNumber(number, Object.assign(Object.assign({}, numberFormatIntlOptions), { style: type }));
    }
    const [dojoNumber] = await (0,_loadModules_b4ac1247_js__WEBPACK_IMPORTED_MODULE_0__.l)(["dojo/number"]);
    return dojoNumber.format(number, {
        type,
        places,
        pattern: options === null || options === void 0 ? void 0 : options.pattern
    });
}
const cache = {};
function formatDate(date) {
    const lang = document.documentElement.lang;
    const dayShortMonthYear = {
        year: "numeric",
        month: "short",
        day: "numeric"
    };
    if (!cache[lang]) {
        cache[lang] = new Intl.DateTimeFormat(document.documentElement.lang, dayShortMonthYear);
    }
    return cache[lang].format(date);
}
function formatPlural(lang, stringObj, number) {
    const singles = ["id", "ja", "ko", "th", "vi", "zh-cn", "zh-hk", "zh-tw"];
    const likeEnglish = [
        "en",
        "ca",
        "da",
        "de",
        "el",
        "es",
        "et",
        "fi",
        "hi",
        "hu",
        "it",
        "nb",
        "nl",
        "pt-pt",
        "sv",
        "tr"
    ];
    const locale = lang !== null && lang !== void 0 ? lang : "en";
    // if the number is one, or it is a "simple" language, return the 1 string
    if (number === 1 || singles.includes(locale)) {
        return stringObj.single.replace("${number}", "1");
    }
    // if the number is not 1 and the language uses the same pluralization strategy as english,
    // return the multiple string
    if (number !== 1 && likeEnglish.includes(locale)) {
        return stringObj.multiple.replace("${number}", `${number}`);
    }
    // if none of the above worked, return the "unknown" string
    return stringObj.unknown.replace("${number}", `${number}`);
}



//# sourceMappingURL=languageUtil-ef0e54b2.js.map

/***/ }),

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/locale-050b6db9.js":
/*!************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/locale-050b6db9.js ***!
  \************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   a: () => (/* binding */ getComponentClosestLanguage),
/* harmony export */   g: () => (/* binding */ getLocaleComponentStrings)
/* harmony export */ });
/* harmony import */ var _dom_4d367677_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dom-4d367677.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/dom-4d367677.js");
/* harmony import */ var _languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./languageUtil-ef0e54b2.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/languageUtil-ef0e54b2.js");
/* harmony import */ var _index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./index-e3bf7da7.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/index-e3bf7da7.js");
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v4.0.58
 */




// https://medium.com/stencil-tricks/implementing-internationalisation-i18n-with-stencil-5e6559554117
function getComponentClosestLanguage(element) {
    var _a, _b, _c;
    const closestElement = (_a = (0,_dom_4d367677_js__WEBPACK_IMPORTED_MODULE_0__.c)(element, "[lang]")) !== null && _a !== void 0 ? _a : (_c = (_b = element.shadowRoot) === null || _b === void 0 ? void 0 : _b.ownerDocument) === null || _c === void 0 ? void 0 : _c.documentElement;
    // language set by the calling application or browser. defaults to english.
    const lang = ((closestElement === null || closestElement === void 0 ? void 0 : closestElement.lang) || (navigator === null || navigator === void 0 ? void 0 : navigator.language) || "en").toLowerCase();
    if (_languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_1__.l.has(lang)) {
        return _languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_1__.l.get(lang);
    }
    else {
        // "ru-RU" maps to "ru" use case
        if (_languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_1__.l.has(lang.slice(0, 2))) {
            return _languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_1__.l.get(lang.slice(0, 2));
        }
        else {
            return "en";
        }
    }
}
function getComponentClosestLanguageIntl(element) {
    var _a, _b, _c;
    // it's OK if we don't have the 4 letter language file for it
    // 4 letter language code needed for formatting numbers
    const closestElement = (_a = (0,_dom_4d367677_js__WEBPACK_IMPORTED_MODULE_0__.c)(element, "[lang]")) !== null && _a !== void 0 ? _a : (_c = (_b = element.shadowRoot) === null || _b === void 0 ? void 0 : _b.ownerDocument) === null || _c === void 0 ? void 0 : _c.documentElement;
    // language set by the calling application or browser. defaults to english.
    const lang = ((closestElement === null || closestElement === void 0 ? void 0 : closestElement.lang) || (navigator === null || navigator === void 0 ? void 0 : navigator.language) || "en").toLowerCase();
    if (_languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_1__.l.has(lang)) {
        return _languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_1__.l.get(lang);
    }
    else {
        if (_languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_1__.l.has(lang.slice(0, 2))) {
            // we support the 2 letter coded language
            // e.g. it-CH vs it
            return lang;
        }
        else {
            return "en";
        }
    }
}
function fetchLocaleStringsForComponent(componentName, locale) {
    return new Promise((resolve, reject) => {
        fetch((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_2__.a)(`../arcgis-app-assets/i18n/${componentName}.i18n.${locale}.json`)).then((result) => {
            if (result.ok)
                resolve(result.json());
            else
                reject();
        }, () => reject());
    });
}
const stringCache = {};
function fetchLocaleStringsFromCache(componentName, locale) {
    const id = `${componentName}${locale}`;
    if (!stringCache[id]) {
        stringCache[id] = fetchLocaleStringsForComponent(componentName, locale);
    }
    return stringCache[id];
}
/**
 * Get strings and language codes.
 * This method returns 2 language codes.
 * The first one returns a code that's also supported as a language file.
 * The second one returns a code where there is support for the first 2 letters of the code as part of a language file,
 * but will return the original 4 letter code from the page.
 * E.g. For "it-ch" it will return "it" as the first language code and "it-ch" as the second.
 * The second one is required for esri.intl.setLocale() to get the correct formatting.
 *
 * If a tagName is provided it will overwite the element's tagName
 *
 *  @return [ strings, first language code, second language code]
 */
async function getLocaleComponentStrings(element, tagName) {
    const componentName = tagName || element.tagName.toLowerCase();
    const componentLanguage = getComponentClosestLanguage(element);
    const componentLanguageIntl = getComponentClosestLanguageIntl(element);
    let strings;
    try {
        strings = await fetchLocaleStringsFromCache(componentName, componentLanguage);
    }
    catch (e) {
        console.warn(`no locale for ${componentName} (${componentLanguage}) loading default locale en.`);
        strings = await fetchLocaleStringsFromCache(componentName, "en");
    }
    return [strings, componentLanguage, componentLanguageIntl];
}



//# sourceMappingURL=locale-050b6db9.js.map

/***/ }),

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/privileges-5c382f61.js":
/*!****************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/privileges-5c382f61.js ***!
  \****************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   a: () => (/* binding */ isPublicUser),
/* harmony export */   b: () => (/* binding */ isOrgAdmin),
/* harmony export */   c: () => (/* binding */ isHostedPortal),
/* harmony export */   d: () => (/* binding */ isCustomRole),
/* harmony export */   e: () => (/* binding */ canUpdateOrgGroups),
/* harmony export */   f: () => (/* binding */ canUpdateItemCategories),
/* harmony export */   g: () => (/* binding */ canManageCollaborations),
/* harmony export */   h: () => (/* binding */ isOrgUser),
/* harmony export */   i: () => (/* binding */ isDeveloper),
/* harmony export */   j: () => (/* binding */ canShareItemToGroup),
/* harmony export */   k: () => (/* binding */ canShareItemToOrg),
/* harmony export */   l: () => (/* binding */ adminCanShareOthersItemToGroup),
/* harmony export */   m: () => (/* binding */ canShareOthersItemsToOrg),
/* harmony export */   n: () => (/* binding */ canShareItemToPublic),
/* harmony export */   o: () => (/* binding */ canShareOthersItemsToPublic),
/* harmony export */   p: () => (/* binding */ hasAdminSharePrivilege),
/* harmony export */   q: () => (/* binding */ canViewOthersOrgItems)
/* harmony export */ });
/* harmony import */ var _item_3535552d_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./item-3535552d.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/item-3535552d.js");
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v4.0.58
 */


const getUserRole = (user) => {
    var _a, _b, _c;
    return typeof (user === null || user === void 0 ? void 0 : user.role) === "string" && !!(user === null || user === void 0 ? void 0 : user.role)
        ? user === null || user === void 0 ? void 0 : user.role
        : (_b = (_a = user === null || user === void 0 ? void 0 : user.roleId) !== null && _a !== void 0 ? _a : user === null || user === void 0 ? void 0 : user.id) !== null && _b !== void 0 ? _b : (_c = user === null || user === void 0 ? void 0 : user.sourceJSON) === null || _c === void 0 ? void 0 : _c.id;
};
function isPublicUser(user) {
    return user && !user.orgId;
}
function isHostedPortal(portal) {
    return !portal.isPortal || !!portal.isBackedBySDS;
}
function isDeveloper(subscriptionInfo) {
    const devSubscriptionTypes = ["Trial Developer", "Developer", "Developer Subscription"];
    return devSubscriptionTypes.includes(subscriptionInfo === null || subscriptionInfo === void 0 ? void 0 : subscriptionInfo.type);
}
function isOrgAdmin(user) {
    return getUserRole(user) === "org_admin" || getUserRole(user) === "account_admin";
}
function isOrgUser(user) {
    return getUserRole(user) === "org_user" || getUserRole(user) === "account_user";
}
function isCustomRole(user) {
    // The Home App collapse the `roleId` and `role` into a single `id` property, that's why
    //  https://devtopia.esri.com/WebGIS/arcgis-portal-app/blob/master/src/js/arcgisonline/sharing/dijit/Role.ts#L469 works
    // In practice, we only need to check if `roleId` exist
    //  https://devtopia.esri.com/WebGIS/arcgis-portal-app/issues/44682#issuecomment-4146866
    return !!(user === null || user === void 0 ? void 0 : user.roleId) && user.roleId.length > 0;
}
/**
 * Checks whether the privilege "portal:admin:updateItemCategorySchema" is granted.
 */
function canUpdateItemCategories(user) {
    var _a;
    return !!((_a = user === null || user === void 0 ? void 0 : user.privileges) === null || _a === void 0 ? void 0 : _a.includes("portal:admin:updateItemCategorySchema"));
}
/**
 * Checks whether the privilege "portal:admin:updateGroups" is granted.
 */
function canUpdateOrgGroups(user) {
    var _a;
    return !!((_a = user === null || user === void 0 ? void 0 : user.privileges) === null || _a === void 0 ? void 0 : _a.includes("portal:admin:updateGroups"));
}
/**
 * Checks whether the user is allowed to update other user's items in their organization.
 */
function canUpdateOrgItems(user) {
    return ((user === null || user === void 0 ? void 0 : user.privileges) || []).includes("portal:admin:updateItems");
}
/**
 * Checks to ensure the portal is an organization portal
 */
function isOrgPortal(portal) {
    return !!(portal.urlKey && portal.customBaseUrl) || !!portal.isPortal;
}
/**
 * Checks whether the user is allowed to share their item to groups
 */
function canShareItemToGroup(user) {
    return ((user === null || user === void 0 ? void 0 : user.privileges) || []).includes("portal:user:shareToGroup");
}
/**
 * Checks whether the user can share an item on a given portal
 */
function canShare(user, portal) {
    return (!isOrgPortal(portal) ||
        canShareItemToGroup(user) ||
        canShareItemToOrg(user) ||
        (!!portal.canSharePublic && canShareItemToPublic(user)));
}
/**
 * Checks whether the user is allowed to share their item ot the organization.
 */
function canShareItemToOrg(user) {
    return ((user === null || user === void 0 ? void 0 : user.privileges) || []).includes("portal:user:shareToOrg");
}
/**
 * Checks whether the user is allowed to share their item to public
 */
function canShareItemToPublic(user) {
    return ((user === null || user === void 0 ? void 0 : user.privileges) || []).includes("portal:user:shareToPublic");
}
/**
 * Checks whether the user can share other user's items
 */
function canShareOthersItemsToOrg(user) {
    return ((user === null || user === void 0 ? void 0 : user.privileges) || []).includes("portal:admin:shareToOrg");
}
/**
 * Checks whether the user can share other user's items
 */
function canShareOthersItemsToPublic(user) {
    return ((user === null || user === void 0 ? void 0 : user.privileges) || []).includes("portal:admin:shareToPublic");
}
/**
 * Checks whether the user can share other user's items
 */
function adminCanShareOthersItemToGroup(user) {
    return ((user === null || user === void 0 ? void 0 : user.privileges) || []).includes("portal:admin:shareToGroup");
}
/**
 * Checks whether the user is in an allowed organization and has the power to manage collaborations
 */
function canManageCollaborations(config, user, portal, subscriptionInfo) {
    const excludedOrgTypes = ["Trial", "Trial Press", "Trial Developer", "Developer Subscription", "Evaluation"];
    const isValidOrgType = subscriptionInfo && !excludedOrgTypes.includes(subscriptionInfo.type);
    const hasPrivilege = ((user === null || user === void 0 ? void 0 : user.privileges) || []).includes("portal:admin:manageCollaborations");
    return !!((config === null || config === void 0 ? void 0 : config.collaborationsEnabled) &&
        user &&
        (isOrgAdmin(user) || hasPrivilege) &&
        ((portal === null || portal === void 0 ? void 0 : portal.isPortal) || isValidOrgType));
}
/**
 * Checks whether the user can view other organization users' items
 */
function canViewOrgItems(user) {
    return ((user === null || user === void 0 ? void 0 : user.privileges) || []).includes("portal:admin:viewItems");
}
/**
 * Checks whether the user can view other organization users' items
 */
function canViewOthersOrgItems(user) {
    return !!user && (!isCustomRole(user) || (isCustomRole(user) && canViewOrgItems(user)));
}
// TODO: add unit tests
const hasAdminSharePrivilege = ({ items, user, portal }) => {
    const item = items[0];
    // enterprise incorrectly returns items owned by "esri_" as item control admin (WebGIS/arcgis-portal-app#38695)
    const owner = item.owner;
    const whitelistOwner = ["esri_livingatlas"];
    if (portal.isPortal && owner !== user.username && owner.includes("esri_") && !whitelistOwner.includes(owner)) {
        return false;
    }
    const isOwnerOrAdmin = (0,_item_3535552d_js__WEBPACK_IMPORTED_MODULE_0__.u)(item, user);
    const isCustom = isCustomRole(user);
    const canShareOrgItems = canShareOthersItems(user);
    const canUpdateAndShare = (0,_item_3535552d_js__WEBPACK_IMPORTED_MODULE_0__.c)(item, user) &&
        canUpdateOrgItems(user) &&
        !isCustom &&
        (canShare(user, portal) || canShareOthersItems(user));
    // if it's the item owner or admin, or custom admin who can share
    return isOwnerOrAdmin || canUpdateAndShare || ((0,_item_3535552d_js__WEBPACK_IMPORTED_MODULE_0__.d)(items, user) && canShareOrgItems);
};
/**
 * Checks whether the user can share other user's items
 */
function canShareOthersItems(user) {
    return adminCanShareOthersItemToGroup(user) || canShareOthersItemsToOrg(user) || canShareOthersItemsToPublic(user);
}



//# sourceMappingURL=privileges-5c382f61.js.map

/***/ }),

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/service-8c2c4241.js":
/*!*************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/service-8c2c4241.js ***!
  \*************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   a: () => (/* binding */ getServiceUrlResponse),
/* harmony export */   g: () => (/* binding */ getRelatedItems),
/* harmony export */   i: () => (/* binding */ isHostedService),
/* harmony export */   r: () => (/* binding */ requestFetch)
/* harmony export */ });
/* harmony import */ var _portal_d518b571_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./portal-d518b571.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/portal-d518b571.js");
/* harmony import */ var _config_75adf962_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./config-75adf962.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/config-75adf962.js");
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v4.0.58
 */



/** Work-around since using `request` directly will trigger unwanted toast on the Home App if the layer is unavailable */
const requestFetch = async (url, portal, options = {}) => {
    const { body, usePost, addTokenManually, api = _config_75adf962_js__WEBPACK_IMPORTED_MODULE_1__.c === null || _config_75adf962_js__WEBPACK_IMPORTED_MODULE_1__.c === void 0 ? void 0 : _config_75adf962_js__WEBPACK_IMPORTED_MODULE_1__.c.api, customToken } = options;
    const data = new URLSearchParams();
    if (body) {
        Object.entries(body).forEach(([key, value]) => {
            if (value !== undefined) {
                data.append(key, value);
            }
        });
    }
    const urlToSend = new URL(url);
    urlToSend.searchParams.append("f", "json");
    if (customToken) {
        urlToSend.searchParams.append("token", customToken);
    }
    else {
        const token = addTokenManually === false ? null : await (0,_portal_d518b571_js__WEBPACK_IMPORTED_MODULE_0__.h)(portal, api);
        if (token) {
            urlToSend.searchParams.append("token", token);
        }
    }
    const response = await fetch(urlToSend.toString(), {
        body: usePost ? data : undefined,
        method: usePost ? "POST" : "GET"
    });
    const result = await response.json();
    const error = result.error;
    if (error) {
        throw typeof error === "string" ? new Error(error) : error;
    }
    return result;
};

/**
 * Send a request to get data for `url`. This request will not include a token to avoid token leak
 */
const getServiceUrlResponse = async (url, portal) => {
    var _a;
    try {
        return { result: await requestFetch(url, portal, { addTokenManually: false }) };
    }
    catch (error) {
        const tokenRequiredMessage = "token required";
        if ((_a = error === null || error === void 0 ? void 0 : error.message) === null || _a === void 0 ? void 0 : _a.toLowerCase().includes(tokenRequiredMessage)) {
            return { error: { code: "tokenRequired" } };
        }
        console.error(error);
        return { error: { code: "unhandledError" } };
    }
};
async function getRelatedItems(itemId, portal, { relationshipType, direction }) {
    const url = `${(0,_portal_d518b571_js__WEBPACK_IMPORTED_MODULE_0__.g)(portal)}content/items/${itemId}/relatedItems`;
    return await (0,_portal_d518b571_js__WEBPACK_IMPORTED_MODULE_0__.r)(url, { relationshipType, direction });
}

const isHostedService = (typeKeywords, type) => type === "Feature Service" && typeKeywords.includes("Hosted Service");



//# sourceMappingURL=service-8c2c4241.js.map

/***/ }),

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/services-66aee31b.js":
/*!**************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/services-66aee31b.js ***!
  \**************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   a: () => (/* binding */ analyzeSharingDetail),
/* harmony export */   b: () => (/* binding */ shareItems),
/* harmony export */   c: () => (/* binding */ isBlockedFromSharingToPublic),
/* harmony export */   d: () => (/* binding */ isBlockedFromDeveloperSharingToPublic),
/* harmony export */   e: () => (/* binding */ dependencyCheckCacheTypes),
/* harmony export */   i: () => (/* binding */ isAccessLevelGreater),
/* harmony export */   s: () => (/* binding */ shareItemsToSharedGroups),
/* harmony export */   u: () => (/* binding */ unshareItems)
/* harmony export */ });
/* harmony import */ var _server_item_8d384796_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./server-item-8d384796.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/server-item-8d384796.js");
/* harmony import */ var _portal_d518b571_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./portal-d518b571.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/portal-d518b571.js");
/* harmony import */ var _item_3535552d_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./item-3535552d.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/item-3535552d.js");
/* harmony import */ var _service_8c2c4241_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./service-8c2c4241.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/service-8c2c4241.js");
/* harmony import */ var _functional_44de8fcf_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./functional-44de8fcf.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/functional-44de8fcf.js");
/* harmony import */ var _privileges_5c382f61_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./privileges-5c382f61.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/privileges-5c382f61.js");
/* harmony import */ var _item_c58ffced_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./item-c58ffced.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/item-c58ffced.js");
/* harmony import */ var _url_4c3ae54c_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./url-4c3ae54c.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/url-4c3ae54c.js");
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v4.0.58
 */









/**
 * Share items to the specified groups with the specified access level
 *
 * Note: `request` will toast an error on the Home app `useFetchRequest` is a workaround. TODO: remove this once we have a better way
 *
 * */
const shareItems = async (items, shareLevel, groupIds, config, useFetchRequest = false) => {
    const { portal, user } = config;
    const url = `${(0,_portal_d518b571_js__WEBPACK_IMPORTED_MODULE_1__.g)(portal)}content/users/${user.username}/shareItems`;
    let result = [];
    const shareLevelOptions = shareLevel ? toShareLevelOptions(shareLevel) : {};
    if (items.every((item) => (0,_item_3535552d_js__WEBPACK_IMPORTED_MODULE_2__.i)(item, user))) {
        try {
            result = (await (0,_service_8c2c4241_js__WEBPACK_IMPORTED_MODULE_3__.r)(url, portal, {
                body: Object.assign({ items: items.map((item) => item.id).join(","), groups: (groupIds === null || groupIds === void 0 ? void 0 : groupIds.length) ? groupIds.join(",") : undefined, confirmItemControl: true }, shareLevelOptions),
                usePost: true
            })).results;
        }
        catch (error) {
            console.error(error);
            return { error: { code: "unhandledError" } };
        }
    }
    else {
        // TODO: hair splitting error here
        result = (await Promise.all(items.map(({ id }) => shareItem(id, shareLevelOptions, groupIds, portal, useFetchRequest)))).map((response) => response.result);
    }
    return { result };
};
const unshareItems = async (itemIds, groupIds, config) => {
    const { portal, user } = config;
    const url = `${(0,_portal_d518b571_js__WEBPACK_IMPORTED_MODULE_1__.g)(portal)}content/users/${user.username}/unshareItems`;
    try {
        const result = (await (0,_service_8c2c4241_js__WEBPACK_IMPORTED_MODULE_3__.r)(url, portal, {
            body: { items: itemIds.join(","), groups: (groupIds === null || groupIds === void 0 ? void 0 : groupIds.length) ? groupIds.join(",") : null },
            usePost: true
        })).results;
        return { result };
    }
    catch (error) {
        console.error(error);
        return { error: { code: "unhandledError" } };
    }
};
/**
 * Share single item to the specified groups with the specified access level
 *
 * Note: `request` will toast an error on the Home app `useFetchRequest` is a workaround. TODO: remove this once we have a better way
 *
 * */
async function shareItem(itemId, shareLevelOptions, groups, portal, useFetchRequest = false) {
    try {
        const url = `${(0,_server_item_8d384796_js__WEBPACK_IMPORTED_MODULE_0__.g)(itemId, portal)}/share`;
        const params = Object.assign({ groups: (groups === null || groups === void 0 ? void 0 : groups.length) ? groups.join(",") : null, confirmItemControl: true }, shareLevelOptions);
        let result;
        if (useFetchRequest) {
            result = await (0,_service_8c2c4241_js__WEBPACK_IMPORTED_MODULE_3__.r)(url, portal, { body: params, usePost: true });
        }
        else {
            result = await (0,_portal_d518b571_js__WEBPACK_IMPORTED_MODULE_1__.r)(url, params, {}, "post");
        }
        return { result };
    }
    catch (error) {
        console.error(error);
        return { error: { code: "unhandledError" } };
    }
}
function toShareLevelOptions(shareLevel) {
    switch (shareLevel) {
        case "public":
            return { org: false, everyone: true };
        case "org":
            return { org: true, everyone: false };
        case "private":
            return { org: false, everyone: false };
        case "shared":
            return { org: false, everyone: false };
        default:
            return {};
    }
}

// disable public sharing of certain items
// WebGIS/arcgis-portal-app#26591, WebGIS/arcgis-portal-app#26987, WebGIS/arcgis-portal-app#30517
// WebGIS/arcgis-portal-app#35924, WebGIS/arcgis-portal-app#36835
function isBlockedFromSharingToPublic(item) {
    const { typeKeywords, type, url } = item;
    const hasNonShareableKeyword = typeKeywords && nonPubliclyShareableKeywords.some((keyword) => typeKeywords.includes(keyword));
    // ! No need to check for portal.isPortal here as that url type is only in ArcGIS Online
    const isOnlineDynamicImageryService = type === "Image Service" && (url === null || url === void 0 ? void 0 : url.includes("://iservices")) && url.includes("arcgis.com");
    const isNonShareableType = nonPubliclyShareableTypes.includes(type);
    return hasNonShareableKeyword || isOnlineDynamicImageryService || isNonShareableType;
}
function isBlockedFromDeveloperSharingToPublic(item) {
    var _a;
    const isHosted = (_a = item.typeKeywords) === null || _a === void 0 ? void 0 : _a.includes("Hosted Service");
    const blackListTypes = [
        "Vector Tile Service",
        "Map Service",
        "Scene Service",
        "Feature Service"
    ];
    return blackListTypes.includes(item.type) && isHosted;
}
const nonPubliclyShareableKeywords = [
    "Location Tracking Service",
    "Location Tracking View",
    "IoTFeed",
    "IoTFeatureLayer",
    "IoTMapImageLayer",
    "IoTStreamLayer",
    "Administrative Report",
    "EditExtensionIndoorsSpaces",
    "ArcgisWorkflowJobLocation"
];
const nonPubliclyShareableTypes = ["Knowledge Graph", "Pro Project"];

// * --- Dependent item layers
const getDependentItemLayers = async (mainItem, portal) => {
    const id = mainItem.id;
    let getDataError;
    let itemsAndLayers = { items: [], layers: [] };
    switch (mainItem.type) {
        case "Group Layer":
            ({ result: itemsAndLayers, error: getDataError } = await getGroupLayerDependentItemLayers(id, portal));
            break;
        case "Web Map":
        case "Web Scene":
            ({ result: itemsAndLayers, error: getDataError } = await getWebMapDependentItemLayers(id, portal));
            break;
        case "Web Mapping Application":
            ({ result: itemsAndLayers, error: getDataError } = await getWebAppDependentItemLayers(id, portal));
            break;
        case "Web Experience":
        case "Web Experience Template":
            ({ result: itemsAndLayers, error: getDataError } = await getWebExperienceDependentItemLayers(id, mainItem.typeKeywords, portal));
            break;
        case "Big Data File Share":
            ({ result: itemsAndLayers, error: getDataError } = await getBDFSDependentItems(mainItem, portal));
            break;
        case "Data Store":
            ({ result: itemsAndLayers, error: getDataError } = await getCloudDataStoreDependentItems(mainItem, portal));
            break;
    }
    return { result: itemsAndLayers, error: getDataError };
};
// * --- Group layer
const getGroupLayerDependentItemLayers = async (itemId, portal) => {
    try {
        const itemData = await (0,_item_c58ffced_js__WEBPACK_IMPORTED_MODULE_6__.g)(itemId, portal);
        return {
            result: {
                items: [],
                layers: [Object.assign({}, itemData)]
            }
        };
    }
    catch (error) {
        // TODO: handle more error
        console.error(error);
        return { error: { code: "unhandledError" } };
    }
};
// * --- Web map
const getWebMapDependentItemLayers = async (itemId, portal) => {
    var _a, _b;
    try {
        const itemData = await (0,_item_c58ffced_js__WEBPACK_IMPORTED_MODULE_6__.g)(itemId, portal);
        const { operationalLayers, baseMap, tables, ground } = itemData;
        return {
            result: {
                items: [],
                layers: [
                    ...(operationalLayers !== null && operationalLayers !== void 0 ? operationalLayers : []),
                    ...((_a = baseMap === null || baseMap === void 0 ? void 0 : baseMap.baseMapLayers) !== null && _a !== void 0 ? _a : []),
                    ...((_b = ground === null || ground === void 0 ? void 0 : ground.layers) !== null && _b !== void 0 ? _b : []),
                    ...(tables !== null && tables !== void 0 ? tables : [])
                ]
            }
        };
    }
    catch (error) {
        // TODO: handle more error
        console.error(error);
        return { error: { code: "unhandledError" } };
    }
};
// * --- Web app
const getWebAppDependentItemLayers = async (itemId, portal) => {
    try {
        const itemData = await (0,_item_c58ffced_js__WEBPACK_IMPORTED_MODULE_6__.g)(itemId, portal);
        if (!itemData) {
            return { result: { items: [], layers: [] } };
        }
        const webAppMapList = getWebAppMapList(itemData);
        const dependentItems = (await Promise.all(webAppMapList.map((itemId) => (0,_item_c58ffced_js__WEBPACK_IMPORTED_MODULE_6__.a)(itemId, portal))))
            // TODO: handle errors
            .map(({ result }) => result)
            .filter((item) => item);
        const dependentItemLayers = await Promise.all(dependentItems.map((item) => getDependentItemLayers(item, portal)));
        const { items, layers } = flattenDependentItemsAndLayerResponse(dependentItemLayers
            .map(({ result }) => result)
            .flat()
            .filter((result) => result));
        return {
            // Web map application doesn't have any layers so we only return the layers from dep items
            result: { items: [...dependentItems, ...items], layers }
        };
    }
    catch (error) {
        // TODO: handle more error
        console.error(error);
        return { error: { code: "unhandledError" } };
    }
};
const getWebAppMapList = (appData) => {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
    const items = ((_a = appData === null || appData === void 0 ? void 0 : appData.map) === null || _a === void 0 ? void 0 : _a.itemId) ? [appData.map.itemId] : [];
    const portfolioCollection = (_d = (_c = (_b = appData.values) === null || _b === void 0 ? void 0 : _b.itemCollection) === null || _c === void 0 ? void 0 : _c.map((el) => el.id)) !== null && _d !== void 0 ? _d : [];
    const maps = (_g = (_f = (_e = appData.values) === null || _e === void 0 ? void 0 : _e.webmap) === null || _f === void 0 ? void 0 : _f.split(",")) !== null && _g !== void 0 ? _g : [];
    const scenes = (_k = (_j = (_h = appData.values) === null || _h === void 0 ? void 0 : _h.webscene) === null || _j === void 0 ? void 0 : _j.split(",")) !== null && _k !== void 0 ? _k : [];
    return [...items, ...portfolioCollection, ...maps, ...scenes];
};
// * --- Web experience
const getWebExperienceDependentItemLayers = async (itemId, typeKeywords, portal) => {
    const draftUrl = `${(0,_server_item_8d384796_js__WEBPACK_IMPORTED_MODULE_0__.g)(itemId, portal)}/resources/config/config.json`;
    const itemDataUrl = (0,_item_c58ffced_js__WEBPACK_IMPORTED_MODULE_6__.b)(itemId, portal);
    const dataUrls = [];
    if (typeKeywords.includes("status: Draft")) {
        dataUrls.push(draftUrl);
    }
    else if (typeKeywords.includes("status: Changed")) {
        dataUrls.push(draftUrl, itemDataUrl);
    }
    else {
        dataUrls.push(itemDataUrl);
    }
    try {
        const allItems = [];
        const allDependentItems = [];
        const allLayers = [];
        await Promise.all(dataUrls.map(async (dataUrl) => {
            const itemData = await (0,_service_8c2c4241_js__WEBPACK_IMPORTED_MODULE_3__.r)(dataUrl, portal);
            if (!(itemData === null || itemData === void 0 ? void 0 : itemData.dataSources) && !(itemData === null || itemData === void 0 ? void 0 : itemData.utilities)) {
                return;
            }
            const dependentItems = (await Promise.all(getWebExperienceDependencyIdList(itemData).map((itemId) => (0,_item_c58ffced_js__WEBPACK_IMPORTED_MODULE_6__.a)(itemId, portal)))) // TODO: handle errors
                .map(({ result }) => result)
                .filter((item) => item);
            const dependentItemLayers = await Promise.all(dependentItems.map((item) => getDependentItemLayers(item, portal)));
            const { items, layers } = flattenDependentItemsAndLayerResponse(dependentItemLayers.flatMap(({ result }) => result).filter((layer) => layer));
            allLayers.push(...layers);
            allItems.push(...items);
            allDependentItems.push(...dependentItems);
        }));
        return {
            // Web experience doesn't have any layers so we only return the layers from dep items
            result: { items: [...allDependentItems, ...allItems], layers: allLayers }
        };
    }
    catch (error) {
        // TODO: handle more error
        console.error(error);
        return { error: { code: "unhandledError" } };
    }
};
function getWebExperienceDependencyIdList(data) {
    const dataSources = data.dataSources || {};
    const utilities = data.utilities || {};
    const allDeps = [...Object.values(dataSources), ...Object.values(utilities)];
    return allDeps.map((dep) => dep.itemId).filter((id) => id);
}
// * --- Big data file share
const getBDFSDependentItems = async (item, portal) => {
    try {
        // Data Store (Big Data File Share: File Share, HDFS, Hive & Cloud) -> Data Store (Big Data File Share)
        const { relatedItems } = await (0,_service_8c2c4241_js__WEBPACK_IMPORTED_MODULE_3__.g)(item.id, portal, {
            relationshipType: "BDFSDataStore2BDFSCatalogService",
            direction: "reverse"
        });
        // Data Store (Big Data File Share: Cloud) -> Data Store (Big Data File Share) - display 2 items
        // Here the share request must be sent using the ID of the Data Store (Cloud) item
        const typeKeywords = relatedItems[0].typeKeywords;
        if (typeKeywords.includes("bigDataFileShare") && typeKeywords.includes("dataStore")) {
            const { result: relatedDataStoreResult } = await getCloudDataStoreDependentItems(relatedItems[0], portal);
            const { items: relatedDataStore } = relatedDataStoreResult;
            const bdfsItem = await (0,_item_c58ffced_js__WEBPACK_IMPORTED_MODULE_6__.c)(relatedItems[0].id, portal);
            return { result: { items: [...relatedDataStore, bdfsItem], layers: [] } };
        }
        // Data Store (Big Data File Share: File Share, HDFS && Hive) -> Data Store (Big Data File Share) - display 1 item
        return {
            result: {
                items: await Promise.all(relatedItems.map((relatedItem) => (0,_item_c58ffced_js__WEBPACK_IMPORTED_MODULE_6__.c)(relatedItem.id, portal))),
                layers: []
            }
        };
    }
    catch (error) {
        console.error(error);
        return { error: { code: "unhandledError" } };
    }
};
// * --- Data Store (Big Data File Share) -> Data Store (Cloud) - display 1 item
const getCloudDataStoreDependentItems = async (item, portal) => {
    try {
        const { relatedItems } = await (0,_service_8c2c4241_js__WEBPACK_IMPORTED_MODULE_3__.g)(item.id, portal, {
            relationshipType: "CloudDataStore2BDFSDataStore",
            direction: "reverse"
        });
        return {
            result: {
                items: await Promise.all(relatedItems.map((relatedItem) => (0,_item_c58ffced_js__WEBPACK_IMPORTED_MODULE_6__.c)(relatedItem.id, portal))),
                layers: []
            }
        };
    }
    catch (error) {
        console.error("error:", error);
        return { error: { code: "unhandledError" } };
    }
};
const flattenDependentItemsAndLayerResponse = (responses) => {
    return {
        items: responses.flatMap((response) => response.items),
        layers: responses.flatMap((response) => response.layers)
    };
};

/**
 * Get the groups that a layer is shared with
 */
async function getLayerSharedGroups(layerId, portal, includeFavoriteGroups = false) {
    try {
        const { result } = await (0,_item_c58ffced_js__WEBPACK_IMPORTED_MODULE_6__.d)(layerId, portal);
        return {
            result: [...result.admin, ...result.member, ...result.other]
                .filter((group) => includeFavoriteGroups || !group.isFav)
                .map((group) => group.id)
        };
    }
    catch (error) {
        console.error(error);
        return { error: { code: "unhandledError" } };
    }
}

const isWebMapTable = (layer) => 
// ! This is just a workaround for now but it's not completely safe since there is no discriminator
!("layerType" in layer) && layer.url && layer.popupInfo;
const isSupportedLayerTypeForUrlCheck = (layer) => {
    const validTypes = [
        "table",
        "ArcGISFeatureLayer",
        "ArcGISTiledMapServiceLayer",
        "VectorTileLayer",
        "GroupLayer",
        "ArcGISImageServiceLayer",
        "ArcGISTiledImageServiceLayer",
        "SubtypeGroupLayer",
        "ArcGISStreamLayer"
    ];
    return validTypes.includes(layer.layerType);
};
const isTileLayer = (layer) => layer.layerType === "ArcGISTiledMapServiceLayer";
const isTileOperationLayerWithPopup = (layer) => layer.layerType === "ArcGISTiledMapServiceLayer" && "layers" in layer && layer.layers[0].disablePopup === false;
const isVectorTileLayer = (layer) => layer.layerType === "VectorTileLayer" && "styleUrl" in layer;
const DEFAULT_SHARING_DETAILS = {
    needsGroupUpdate: false,
    needsShareLevelUpdate: false,
    canEditShareLevel: true,
    premium: false,
    bdfsDatastore: false
};

const accessLevel = {
    private: 0,
    shared: 1,
    org: 2,
    public: 3
};
const isAccessLevelGreater = (mainAccess, otherAccess) => accessLevel[mainAccess] > accessLevel[otherAccess];
/**
 * Given a URL and a relative path, return the full URL
 * e.g: https://www.arcgis.com/sharing/rest/content/items/1234567890abcdefg and "../../", return https://www.arcgis.com/sharing/rest/
 *
 */
const traverseUrls = ({ path, url }) => {
    const urlParts = url.split("/");
    const pathParts = path.split("/");
    const urlPartsToKeep = urlParts.slice(0, urlParts.length - pathParts.length);
    return urlPartsToKeep.join("/");
};

const filterUrlsFromSameOrigin = async (portal, urlsToCheck) => {
    const { owningSystemUrl: mainItemOwningSystemUrl } = await (0,_portal_d518b571_js__WEBPACK_IMPORTED_MODULE_1__.f)(async () => (0,_portal_d518b571_js__WEBPACK_IMPORTED_MODULE_1__.a)(portal), "portalInfo", portal.id);
    const urlOwningSystemInfo = await Promise.all(urlsToCheck.map(async (url) => {
        try {
            const { owningSystemUrl } = await (0,_portal_d518b571_js__WEBPACK_IMPORTED_MODULE_1__.b)(url);
            return { owningSystemUrl, url };
        }
        catch (error) {
            console.error(error);
            return { owningSystemUrl: null, url };
        }
    }));
    return (urlOwningSystemInfo
        // TODO: handle Enterprise case
        .filter(({ owningSystemUrl }) => owningSystemUrl === mainItemOwningSystemUrl)
        .map(({ url }) => url));
};

/** Get the source item for tile layer
 * @param layer - The layer to get the source item for with layer type of ArcGISTiledMapServiceLayer
 */
const getTileLayerSourceItem = async (layer, portal) => {
    try {
        const itemId = layer.itemId;
        const itemData = await (0,_portal_d518b571_js__WEBPACK_IMPORTED_MODULE_1__.f)(() => (0,_item_c58ffced_js__WEBPACK_IMPORTED_MODULE_6__.g)(itemId, portal), "itemData", itemId);
        // Currently a tile layer can only be created from a single layer so we can just take the first layer
        const { layerItemId: sourceItemId } = itemData === null || itemData === void 0 ? void 0 : itemData.layers[0];
        if (!sourceItemId) {
            return { error: { code: "unhandledError" } };
        }
        return { result: await (0,_item_c58ffced_js__WEBPACK_IMPORTED_MODULE_6__.c)(sourceItemId, portal) };
    }
    catch (error) {
        console.error(error);
        return { error: { code: "unhandledError" } };
    }
};
/** Get source items for items duplicated from another item
 *
 * This will ignore items that is not on the same environment as the main item
 * or if not using the same federated server if we're in Enterprise
 *
 * https://devtopia.esri.com/WebGIS/arcgis-app-components/issues/3809
 */
const getSourceItemsFromUrls = async (itemUrls, portal) => {
    const validUrlInfos = itemUrls.filter((urlInfo) => !!(urlInfo === null || urlInfo === void 0 ? void 0 : urlInfo.url) && isSupportedLayerTypeForUrlCheck({ layerType: urlInfo.layerType }));
    const validItemUrls = await filterOutDiffOriginAGSUrls(validUrlInfos.map((urlInfo) => urlInfo.url), portal);
    // Some url is a root.json url so we need to go through another layer of getSourceItemsFromUrls to get the actual item
    const rootJSONServiceURL = [];
    // * First send request without token
    const requiredTokenUrls = [];
    const noTokenMetaData = [];
    await Promise.all(validItemUrls.map(async (url) => {
        const { result, error } = await (0,_portal_d518b571_js__WEBPACK_IMPORTED_MODULE_1__.f)(() => (0,_service_8c2c4241_js__WEBPACK_IMPORTED_MODULE_3__.a)(url, portal), "itemMetadata", `${url}--no-token`);
        if ((error === null || error === void 0 ? void 0 : error.code) === "tokenRequired") {
            requiredTokenUrls.push(url);
            return;
        }
        if (isRootJSONResponse(result)) {
            rootJSONServiceURL.push(getRootJSONResponseUrl(result, url));
        }
        else {
            noTokenMetaData.push(result);
        }
    }));
    const noTokenServiceIds = noTokenMetaData.map((metaData) => metaData === null || metaData === void 0 ? void 0 : metaData.serviceItemId);
    // * For urls that require token, check if they are in the same origin
    const sameHostRestUrls = await filterUrlsFromSameOrigin(portal, requiredTokenUrls);
    // If yes, then we can just get the item detail
    const requiredTokenMetaData = await Promise.all(sameHostRestUrls.map(async (url) => ({
        response: await (0,_service_8c2c4241_js__WEBPACK_IMPORTED_MODULE_3__.r)(url, portal, { addTokenManually: true }),
        url // We need this for root json url
    })));
    const requiredTokenServiceIds = requiredTokenMetaData.reduce((idList, { response, url }) => {
        if (isRootJSONResponse(response)) {
            rootJSONServiceURL.push(getRootJSONResponseUrl(response, url));
            return idList;
        }
        return [...idList, response === null || response === void 0 ? void 0 : response.serviceItemId];
    }, []);
    // * Then just get the item detail
    const returnItems = await Promise.all([...noTokenServiceIds, ...requiredTokenServiceIds].map(async (serviceItemId) => serviceItemId ? (0,_item_c58ffced_js__WEBPACK_IMPORTED_MODULE_6__.c)(serviceItemId, portal) : null));
    // We repeat the same process to get the actual `serviceItemId` then the item via the root json URL
    const rootJSONItems = rootJSONServiceURL.length <= 0
        ? []
        : await getSourceItemsFromUrls(rootJSONServiceURL.map((url) => ({ url, layerType: "VectorTileLayer" })), portal);
    return [...returnItems.filter((item) => !!item), ...rootJSONItems];
};
const isRootJSONResponse = (response) => {
    return !!(response === null || response === void 0 ? void 0 : response.sources);
};
const getRootJSONResponseUrl = (response, url) => {
    var _a;
    const responseUrl = (_a = Object.values(response.sources)[0]) === null || _a === void 0 ? void 0 : _a.url;
    if (!responseUrl) {
        return null;
    }
    return responseUrl.includes("..") ? traverseUrls({ url, path: responseUrl }) : responseUrl;
};
const filterOutDiffOriginAGSUrls = async (urls, portal) => {
    const validAgsURL = urls.filter((url) => !!url && !!(0,_url_4c3ae54c_js__WEBPACK_IMPORTED_MODULE_7__.p)(url));
    // TODO R3: we'll fine-grain checking this later and once items have better spec
    const nonAGSUrls = urls.filter((url) => !url || !(0,_url_4c3ae54c_js__WEBPACK_IMPORTED_MODULE_7__.p)(url));
    const sameOriginUrls = await filterUrlsFromSameOrigin(portal, validAgsURL);
    return [...sameOriginUrls, ...nonAGSUrls];
};

const getSourceItemsFromDependentLayers = async (dependentLayers, portal) => {
    // * Recursively flatten layers, focusing on GroupLayer
    const flattenedLayers = [];
    const analyzeLayer = (layer) => {
        if (isWebMapTable(layer)) {
            flattenedLayers.push({
                id: layer.id,
                url: layer.url,
                layerType: "table",
                getType: "normal"
            });
            return;
        }
        if (layer.layerType === "GroupLayer") {
            if (layer.itemId) {
                // A GroupLayer item
                flattenedLayers.push({
                    id: layer.id,
                    itemId: layer.itemId,
                    layerType: "GroupLayer",
                    getType: "normal"
                });
            }
            layer.layers.forEach((subLayer) => {
                if (isWebMapTable(subLayer) || subLayer.layerType === "GroupLayer") {
                    analyzeLayer(subLayer);
                    return;
                }
                const subLayerUrl = subLayer.url;
                if (!subLayerUrl) {
                    analyzeLayer(subLayer);
                    return;
                }
                const parseUrlInfo = (0,_url_4c3ae54c_js__WEBPACK_IMPORTED_MODULE_7__.p)(subLayerUrl);
                analyzeLayer(Object.assign(Object.assign({}, subLayer), { 
                    // If a layer in GroupLayer has index in their URL, we'll want to strip them out first
                    // This might create some duplicated URLs but we already filter them out below via the `layerItemIdLookupMap`
                    url: (parseUrlInfo === null || parseUrlInfo === void 0 ? void 0 : parseUrlInfo.index) != null ? parseUrlInfo.baseServerUrl : subLayer.url }));
            });
            return;
        }
        if (isVectorTileLayer(layer)) {
            flattenedLayers.push({
                id: layer.id,
                url: layer.styleUrl,
                itemId: layer.itemId,
                layerType: layer.layerType,
                getType: "normal"
            });
            return;
        }
        // We need to also fetch the original item this tile layer is created from
        if (isTileLayer(layer)) {
            // If the tile layer has popup enabled, we can just take the layer directly
            //  which is simply via layers[0]'s `layerItemId`
            //  if not, we'll have to go into /data and get the `layerItemId` first from there
            const isTileLayerWithPopup = isTileOperationLayerWithPopup(layer);
            if (isTileLayerWithPopup) {
                const firstSubLayer = layer.layers[0];
                flattenedLayers.push({
                    id: firstSubLayer.id,
                    url: firstSubLayer.layerUrl,
                    getType: "normal",
                    layerType: layer.layerType,
                    itemId: firstSubLayer.layerItemId
                });
                // ! We also want to check for the tile layer sharing mismatch so there is no return here
            }
            flattenedLayers.push({
                id: layer.id,
                getType: isTileLayerWithPopup ? "normal" : "tile-layer-with-no-popup",
                itemId: layer.itemId,
                layerType: layer.layerType,
                url: layer.url
            });
            return;
        }
        if (layer.itemId || layer.url) {
            flattenedLayers.push({
                id: layer.id,
                url: layer.url,
                itemId: layer.itemId,
                layerType: layer.layerType,
                getType: "normal"
            });
        }
    };
    dependentLayers.forEach(analyzeLayer);
    const layerItemIdLookupMap = (0,_functional_44de8fcf_js__WEBPACK_IMPORTED_MODULE_4__.a)(flattenedLayers, (layer) => {
        if (layer.itemId) {
            return { key: layer.itemId, data: { searchType: "item-id", layerType: layer.layerType } };
        }
        // Layer from shallow copied or duplicated items
        // However, if layer doesn't have both `itemId` and `url`, we'll just have the key as `null` and ignore them since there is no way to get the source item
        return { key: layer.url, data: { searchType: "url", layerType: layer.layerType } };
    });
    const uniqueIds = Object.keys(layerItemIdLookupMap).filter((id) => layerItemIdLookupMap[id].searchType === "item-id");
    try {
        // * --- Handle getting source item
        const itemsFromIds = (await Promise.all(uniqueIds.map((id) => (0,_item_c58ffced_js__WEBPACK_IMPORTED_MODULE_6__.c)(id, portal)))).filter((itemInfo) => !!itemInfo);
        // Handle tile layer source item if the tile layer doesn't have popup enabled
        const dependentTileLayers = flattenedLayers.filter(({ getType: type, itemId }) => type === "tile-layer-with-no-popup" && !!itemId);
        const tileLayerSourceItems = (await Promise.all(dependentTileLayers.map((layer) => getTileLayerSourceItem(layer, portal)))).map(({ result }) => result);
        // Handle item duplicated from another item --- currently also handle vector tile layer
        //  because isHostedService doesn't count vector tile layer as hosted service
        const nonHostedItems = itemsFromIds.filter((item) => !(0,_service_8c2c4241_js__WEBPACK_IMPORTED_MODULE_3__.i)(item.typeKeywords, item.type));
        const nonHostedItemInfos = await getSourceItemsFromUrls(nonHostedItems.map((item) => {
            const { url, id } = item;
            const layerInfo = layerItemIdLookupMap[id];
            return layerInfo ? { layerType: layerInfo.layerType, url } : null;
        }), portal);
        const nonHostedItemsLookupByUrl = (0,_functional_44de8fcf_js__WEBPACK_IMPORTED_MODULE_4__.a)(nonHostedItemInfos, (item) => ({
            key: item.url,
            data: item
        }));
        // Handle shallow copied layers
        const shallowedCopiedLayerUrls = Object.keys(layerItemIdLookupMap)
            .map((url) => {
            const layerInfo = layerItemIdLookupMap[url];
            return layerInfo && layerInfo.searchType === "url" ? { layerType: layerInfo.layerType, url } : null;
        })
            .filter((layerInfo) => layerInfo);
        const shallowCopiedItems = await getSourceItemsFromUrls(shallowedCopiedLayerUrls, portal);
        // * Aggregate the result
        const sourceItems = [];
        itemsFromIds
            .filter((itemInfo) => itemInfo)
            .forEach((item) => {
            const itemUrl = item.url;
            sourceItems.push({ sourceItem: item });
            const nonHostedSourceItem = nonHostedItemsLookupByUrl[itemUrl];
            if (nonHostedSourceItem && item.id !== nonHostedSourceItem.id) {
                sourceItems.push({ sourceItem: nonHostedSourceItem });
            }
        });
        [...tileLayerSourceItems, ...shallowCopiedItems].forEach((item) => {
            if (!item) {
                return;
            }
            sourceItems.push({ layer: null, sourceItem: item });
        });
        return { result: sourceItems };
    }
    catch (error) {
        console.error(error);
        return { error: { code: "unhandledError" } };
    }
};

/**
 * Analyze sharing detail of the item and return any mismatch or sharing issues
 *
 * @param overrideLayers
 * Normally, the util will fetch the layers from the /data endpoint
 * However, if the user has overrideLayers layers, we can pass them in here
 *
 * **Note!!!**: Make sure the layers passed in is in the form of what we would receive from the /data endpoint of the item, not JS API's `Layer`
 *
 * This is useful in the case of Map Viewer where the /data endpoint is not updated with the latest layers after save
 * However, cases like DataStore and BDFS use the items directly and therefore this param is redundant
 *
 * @param options - options - see {@link Options}
 */
const analyzeSharingDetail = async (item, portal, overrideLayers, options = { clearDataCacheOnDone: true }) => {
    if (item.access === "private") {
        return {
            result: {
                needEditableLayers: [],
                needPubliclyEditableLayers: [],
                needDataCollectionLayers: [],
                needsShareLevelUpdateLayers: [],
                premiumLayers: [],
                notEditableLayers: [],
                needBDFSDatastoreUpdate: [],
                needAuthentication: []
            }
        };
    }
    const { result, error } = await getLayerAndSharingDetail(item, portal, overrideLayers);
    if (error) {
        return { error };
    }
    const sharingDetailBuckets = {
        needEditableLayers: [],
        needPubliclyEditableLayers: [],
        needDataCollectionLayers: [],
        needsShareLevelUpdateLayers: [],
        premiumLayers: [],
        notEditableLayers: [],
        needBDFSDatastoreUpdate: [],
        needAuthentication: checkIfDeveloperBasemap(item)
            ? [
                {
                    sourceItem: item,
                    detail: {
                        bdfsDatastore: false,
                        canEditShareLevel: true,
                        needsGroupUpdate: false,
                        needsShareLevelUpdate: false,
                        premium: false
                    }
                }
            ]
            : []
    };
    await Promise.all(result === null || result === void 0 ? void 0 : result.map(async (info) => {
        const bucket = await getSharingDetailBucket({
            mainItem: item,
            sharingDetailResult: info,
            portal
        });
        bucket && sharingDetailBuckets[bucket].push(info);
    }));
    if (options.clearDataCacheOnDone) {
        // TODO: find a way to scope this to the function only (possibly through store of cache)
        //  but right now we don't have a use case for that so it should be fine...
        dependencyCheckCacheTypes.forEach((type) => (0,_portal_d518b571_js__WEBPACK_IMPORTED_MODULE_1__.c)(type));
    }
    return { result: sharingDetailBuckets };
};
/**
 * Get item and layers from /data in case user doesn't pass layers

  * Ultimately, the goal is to get the source item and their sharing detail from all the dependent layers
 */
const getLayerAndSharingDetail = async (mainItem, portal, overrideLayers) => {
    let itemsToCheck = [];
    let dependentLayers = [...(overrideLayers || [])];
    let getDataError;
    if (!(dependentLayers === null || dependentLayers === void 0 ? void 0 : dependentLayers.length)) {
        // If the consumer doesn't pass in any layers, we need to get the layers from the actual endpoints
        const { error, result } = await getDependentItemLayers(mainItem, portal);
        getDataError = error;
        dependentLayers = result.layers;
        itemsToCheck = result.items;
    }
    if (getDataError) {
        return { error: getDataError };
    }
    if (dependentLayers.length <= 0 && itemsToCheck.length <= 0) {
        return { error: { code: "dataNotAvailable" } };
    }
    try {
        // For BDFS and Data Store, we already retrieve the deps in getDependentItemLayers which is also the source items
        // and there is no need to get the source item again
        if (mainItem.type !== "Big Data File Share" && mainItem.type !== "Data Store") {
            const { result: dependentLayerSourceItems, error } = await getSourceItemsFromDependentLayers(dependentLayers, portal);
            if (error) {
                return { error };
            }
            itemsToCheck.push(...dependentLayerSourceItems.map(({ sourceItem }) => sourceItem));
        }
        // * Group sharing stuff
        const { result: mainItemSharingGroups, error: getSharedGroupsError } = await getLayerSharedGroups(mainItem.id, portal);
        if (getSharedGroupsError) {
            return { error: getSharedGroupsError };
        }
        // Sometimes layers can be created from he same source layers so we need to make sure we don't check the same source item multiple times
        const allSourceItems = (0,_functional_44de8fcf_js__WEBPACK_IMPORTED_MODULE_4__.u)(itemsToCheck, (item) => item.id);
        const result = await Promise.all(allSourceItems.map(async (item) => {
            const sharingDetail = await getItemSharingDetail({
                sourceItem: item,
                mainItemAccess: mainItem.access,
                mainItemSharingGroups,
                portal
            });
            return { sourceItem: item, detail: sharingDetail };
        }));
        return { result };
    }
    catch (error) {
        console.error(error);
        return { error: { code: "unhandledError" } };
    }
};
async function getItemSharingDetail({ mainItemAccess, mainItemSharingGroups, portal, sourceItem }) {
    const { access: sourceItemAccess, itemControl } = sourceItem;
    const sharingDetail = Object.assign({}, DEFAULT_SHARING_DETAILS);
    const isMainItemSharingToPublic = mainItemAccess === "public";
    if (isBlockedFromSharingToPublic(sourceItem) && isMainItemSharingToPublic) {
        return Object.assign(Object.assign({}, sharingDetail), { needsShareLevelUpdate: true, canEditShareLevel: false });
    }
    // Can current user update the sharing on this item, and do they need to, if the layer is public
    // it doesn't really matter if they can or cannot
    if (sourceItemAccess !== "public") {
        sharingDetail.canEditShareLevel = checkCanUpdateShareLevel(itemControl);
        sharingDetail.needsGroupUpdate = await checkNeedGroupUpdate({
            sourceItem,
            isMainItemSharingToPublic,
            mainItemSharingGroups,
            portal
        });
        sharingDetail.needsShareLevelUpdate = checkNeedShareUpdate({
            mainItemAccess,
            sourceItemAccess
        });
    }
    else {
        // Is this item considered a premium item
        sharingDetail.premium = isPremiumContent(sourceItem);
    }
    return sharingDetail;
}
const checkCanUpdateShareLevel = (itemControl) => itemControl === "admin";
const checkIfDeveloperBasemap = (item) => item.typeKeywords.includes("DeveloperBasemap");
const checkNeedGroupUpdate = async ({ sourceItem, isMainItemSharingToPublic, portal, mainItemSharingGroups }) => {
    // TODO: remove this once we have fine-grain check for
    //  https://devtopia.esri.com/WebGIS/arcgis-app-components/pull/4068
    if (isMainItemSharingToPublic) {
        return false;
    }
    const { result: layerSharedGroups } = await getLayerSharedGroups(sourceItem.id, portal);
    return !sharedWithSameGroups(mainItemSharingGroups, layerSharedGroups);
};
const checkNeedShareUpdate = ({ mainItemAccess, sourceItemAccess }) => 
// "shared" is the same as "private" with groups so it needs group update, not share update
!(sourceItemAccess === "private" && mainItemAccess === "shared") &&
    isAccessLevelGreater(mainItemAccess, sourceItemAccess);
function isPremiumContent(item) {
    return (0,_item_3535552d_js__WEBPACK_IMPORTED_MODULE_2__.a)(item) || (0,_item_3535552d_js__WEBPACK_IMPORTED_MODULE_2__.b)(item);
    // return selectedShareLevel !== "public" ? false : isSubscriber(item) || isPremium(item);
}
function sharedWithSameGroups(sharedGroups, layerSharedGroups) {
    if (sharedGroups === null || sharedGroups === void 0 ? void 0 : sharedGroups.length) {
        // We use `sharedGroups` to check the order since we only need to check if layerSharedGroups
        // contains the same groups in the same order as sharedGroups, not the other way around
        const groupsNotSharedWithLayer = sharedGroups.filter((value) => !(layerSharedGroups || []).includes(value));
        return groupsNotSharedWithLayer.length <= 0;
    }
    return true;
}
/**
 * Share `items` with groups fetch from `sourceItemsForGroups`
 */
async function shareItemsToSharedGroups(items, sourceItemsForGroups, shareLevel, portal, shouldUpdateGroup = true) {
    const { user } = portal;
    const sharedGroupsList = !shouldUpdateGroup
        ? []
        : await Promise.all(sourceItemsForGroups.map(async (mainItem) => {
            const { result: groupIds } = await getLayerSharedGroups(mainItem.id, portal);
            return groupIds;
        }));
    const groupIds = sharedGroupsList.flat(1);
    return shareItems(items, shareLevel, groupIds, { portal, user }, true);
}
// https://www.figma.com/file/BBmw0ioRw0ZQmCqFHJeH2N/Share-Flowchart-5?type=whiteboard&node-id=401-149&t=E77ZkPzT8cboGdt7-0
const getSharingDetailBucket = async ({ mainItem, sharingDetailResult, portal }) => {
    var _a;
    const { sourceItem, detail } = sharingDetailResult;
    const { canEditShareLevel, needsGroupUpdate, needsShareLevelUpdate, premium } = detail;
    if (detail.bdfsDatastore) {
        return "needBDFSDatastoreUpdate";
    }
    if (!needsGroupUpdate && !needsShareLevelUpdate && !premium) {
        return null;
    }
    if (!canEditShareLevel && !premium) {
        return "notEditableLayers";
    }
    switch (mainItem.access) {
        case "public":
            if (premium) {
                return "premiumLayers";
            }
            if (sourceItem.access !== "public") {
                const developer = (0,_privileges_5c382f61_js__WEBPACK_IMPORTED_MODULE_5__.i)(portal.subscriptionInfo || ((_a = portal.sourceJSON) === null || _a === void 0 ? void 0 : _a.subscriptionInfo));
                if (developer && isBlockedFromDeveloperSharingToPublic(sourceItem)) {
                    return "notEditableLayers";
                }
                if (await (0,_item_c58ffced_js__WEBPACK_IMPORTED_MODULE_6__.i)(sourceItem, portal)) {
                    const isDataCollectionLayer = sourceItem.typeKeywords.includes("Public Data Collection");
                    return isDataCollectionLayer ? "needEditableLayers" : "needDataCollectionLayers";
                }
            }
            return "needsShareLevelUpdateLayers";
        case "org":
        case "shared":
        case "private":
            if (premium) {
                return null;
            }
            return "needsShareLevelUpdateLayers";
        default:
            assertNever(mainItem.access);
    }
};
// We don't blow up the cache for portal info since that information will not likely be changed
const dependencyCheckCacheTypes = ["itemData", "itemMetadata"];
const assertNever = (access) => {
    throw new Error(`Unexpected share level ${access}`);
};



//# sourceMappingURL=services-66aee31b.js.map

/***/ }),

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/utils-f4f44b88.js":
/*!***********************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/utils-f4f44b88.js ***!
  \***********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   D: () => (/* binding */ DEFAULT_SHARING_DETAIL),
/* harmony export */   a: () => (/* binding */ getUsernameQuery),
/* harmony export */   b: () => (/* binding */ showRevertGroupWarning),
/* harmony export */   c: () => (/* binding */ showRevertShareLevelWarning),
/* harmony export */   d: () => (/* binding */ DEFAULT_SHARE_LEVELS),
/* harmony export */   e: () => (/* binding */ showShareLevelChangeWarning),
/* harmony export */   f: () => (/* binding */ isShareLevelDirty),
/* harmony export */   g: () => (/* binding */ getItemsAndGroupsToUpdateShare),
/* harmony export */   h: () => (/* binding */ getPossibleShareLevel),
/* harmony export */   i: () => (/* binding */ isSelectedGroupDataDirty),
/* harmony export */   j: () => (/* binding */ getShareMode),
/* harmony export */   k: () => (/* binding */ canShareItemToGroup),
/* harmony export */   l: () => (/* binding */ checkIfSharingMixed),
/* harmony export */   s: () => (/* binding */ showEditGroupWarning)
/* harmony export */ });
/* harmony import */ var _privileges_5c382f61_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./privileges-5c382f61.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/privileges-5c382f61.js");
/* harmony import */ var _functional_44de8fcf_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./functional-44de8fcf.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/functional-44de8fcf.js");
/* harmony import */ var _item_3535552d_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./item-3535552d.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/item-3535552d.js");
/* harmony import */ var _services_66aee31b_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./services-66aee31b.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/services-66aee31b.js");
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v4.0.58
 */





const groupsAreOwnedByOrg = (user, groupData) => {
    const { username, orgId } = user;
    return groupData.every(({ group }) => {
        const isOwner = username === (group === null || group === void 0 ? void 0 : group.owner);
        const isOwnedByMyOrg = orgId === group.orgId;
        return isOwner || isOwnedByMyOrg;
    });
};
const canShareItemToGroup = (selectedGroupData, user) => userCanShare(user) || ((0,_privileges_5c382f61_js__WEBPACK_IMPORTED_MODULE_0__.l)(user) && groupsAreOwnedByOrg(user, selectedGroupData));
const userCanShare = (user) => !(0,_privileges_5c382f61_js__WEBPACK_IMPORTED_MODULE_0__.h)(user) || userCanShareItemToGroup(user);
/**
 * Checks if the groups are in a mixed state where at least one group is shared with different items than the rest
 */
const checkIfSharingMixed = (items, selectedGroups) => selectedGroups.some(({ selectedByItemIds }) => selectedByItemIds.length !== items.length);
/**
 * Checks whether the user is allowed to share their item to groups
 */
function userCanShareItemToGroup(user) {
    return (user.privileges || []).includes("portal:user:shareToGroup");
}
const privateItemsHaveBeenSharedToGroups = ({ items, groupData }) => items
    .filter((item) => {
    const access = item.access;
    return access === "private" || access === "shared";
})
    .reduce((memo, item) => memo || itemHasBeenSharedToGroups({ item, groupData }), false);
const itemHasBeenSharedToGroups = ({ item, groupData }) => groupData.reduce((memo, groupData) => memo || (!!groupData.selectedByItemIds && groupData.selectedByItemIds.includes(item.id)), false);
const showEditGroupWarning = (user, selectedShareLevels) => !(0,_privileges_5c382f61_js__WEBPACK_IMPORTED_MODULE_0__.h)(user) &&
    !(0,_privileges_5c382f61_js__WEBPACK_IMPORTED_MODULE_0__.j)(user) &&
    // They can't share to org anyway so no need to check that
    selectedShareLevels.some((shareLevel) => shareLevel === "private");
const showRevertGroupWarning = (user, selectedShareLevels, initialSelectedGroupData) => (0,_privileges_5c382f61_js__WEBPACK_IMPORTED_MODULE_0__.a)(user) &&
    selectedShareLevels.some((shareLevel) => shareLevel === "private") &&
    initialSelectedGroupData.length > 0;
const showRevertShareLevelWarning = (user, items, selectedGroupData) => !(0,_privileges_5c382f61_js__WEBPACK_IMPORTED_MODULE_0__.h)(user) &&
    !(0,_privileges_5c382f61_js__WEBPACK_IMPORTED_MODULE_0__.k)(user) &&
    privateItemsHaveBeenSharedToGroups({ items, groupData: selectedGroupData });
const showShareLevelChangeWarning = (user, newShareLevel, selectedGroupData) => !(0,_privileges_5c382f61_js__WEBPACK_IMPORTED_MODULE_0__.b)(user) &&
    !(0,_privileges_5c382f61_js__WEBPACK_IMPORTED_MODULE_0__.h)(user) &&
    !(0,_privileges_5c382f61_js__WEBPACK_IMPORTED_MODULE_0__.k)(user) &&
    newShareLevel === "private" &&
    Object.keys(selectedGroupData).length > 0;

const getUsernameQuery = ({ shareMode, currentUsername, user, userGroupLookup, isPrivate }) => {
    var _a;
    let groupIds = [];
    let groupIdsQuery;
    if (userGroupLookup) {
        let currentUserGroups = [];
        if (shareMode === "admin" && ((_a = userGroupLookup[currentUsername]) === null || _a === void 0 ? void 0 : _a.length) && currentUsername !== user.username) {
            // In admin case, we want to also includes groups that the item owner has access to
            currentUserGroups = [...userGroupLookup[currentUsername]];
        }
        if (shareMode !== "admin" || !isPrivate) {
            // For admin, we only want to include the admin's groups if the item is not private
            // For private item owner, includes groups that they can share to
            userGroupLookup[user.username].forEach((group) => {
                if (!currentUserGroups.some((g) => g.id === group.id)) {
                    currentUserGroups.push(group);
                }
            });
        }
        currentUserGroups === null || currentUserGroups === void 0 ? void 0 : currentUserGroups.forEach((group) => {
            var _a;
            // include group ids that the current user is owner or admin or if viewOnly is false
            const memberType = (_a = group.userMembership) === null || _a === void 0 ? void 0 : _a.memberType;
            if (group.isViewOnly && (memberType === "owner" || memberType === "admin")) {
                groupIds.push(group.id);
            }
        });
    }
    if (groupIds.length) {
        groupIdsQuery = `(isviewonly:false OR id:(${groupIds.join(" OR ")}))`;
    }
    const adminGroupQuery = groupIds.length ? ` OR id:(${groupIds.join(" OR ")})` : "";
    switch (shareMode) {
        // In the default (item owner) case, we want to show all the groups
        // that the user either owns or has write access to.
        // Write access is indicated by the isviewonly flag.
        //
        // Ideally, we'd also be able to show groups the current user is admin of
        // maybe with a syntax like admin:${currentUsername}
        // but the search endpoint does not support that.
        case "default":
            return groupIdsQuery || `(owner:${currentUsername} OR isviewonly:false)`;
        // group owner mode should only see groups owned by the current user
        // excluding shared-update groups
        case "group":
            return `owner:${currentUsername} -capabilities:updateitemcontrol`;
        // In admin cases, we want all the groups the current user is a member of.
        // this is handled by the searchUserAccess and searchUserName params
        // outside of the query string.
        case "admin":
            if (user.username === currentUsername) {
                return `(isviewonly:false${adminGroupQuery} OR owner:${user.username}) -capabilities:updateitemcontrol`;
            }
            // When looking at the content user's groups, show that user's groups
            // or groups they have access to.
            // WebGIS/arcgis-portal-app#28041
            return `(owner:${currentUsername} OR isviewonly:false${adminGroupQuery})`;
        default:
            return "";
    }
};

const DEFAULT_SHARING_DETAIL = {
    needEditableLayers: [],
    needPubliclyEditableLayers: [],
    needDataCollectionLayers: [],
    needsShareLevelUpdateLayers: [],
    premiumLayers: [],
    notEditableLayers: [],
    needAuthentication: [],
    needBDFSDatastoreUpdate: []
};
const DEFAULT_SHARE_LEVELS = ["private", "org", "public"];

// TODO: add unit test
/**
 * Compose the list of items/groups to share and unshare
 *
 * ! This assume when we share/unshare, we share/unshare to all items
 *
 * Useful for /shareItems or /unshareItems endpoints
 *  */
const getItemsAndGroupsToUpdateShare = (initialSelectedGroupData, curSelectedGroupData) => {
    // 3 states to handle:
    // 1: groups that are completely unshared from the all items -> unshareData
    // 2: groups that are completely shared to all items -> shareData
    // 3: mixed sharing -> we don't care // ! it will affect the activity log but we don't care for now
    const completelyUnsharedGroupData = initialSelectedGroupData.filter((groupData) => !curSelectedGroupData.some((curGroupData) => curGroupData.group.id === groupData.group.id));
    const completelySharedGroupData = curSelectedGroupData.filter((groupData) => {
        const initialGroupData = initialSelectedGroupData.find((initialGroupData) => initialGroupData.group.id === groupData.group.id);
        // This assume that when we share/unshare, we share/unshare to all items,
        //  so this means groupData.selectedByItemIds.length is already the max
        // This would make the util independent of the length of the items array
        return !initialGroupData || initialGroupData.selectedByItemIds.length < groupData.selectedByItemIds.length;
    });
    return {
        unshareGroupIds: completelyUnsharedGroupData.map((groupData) => groupData.group.id),
        shareGroupIds: completelySharedGroupData.map((groupData) => groupData.group.id)
    };
};
const getPossibleShareLevel = (user, items, portal) => {
    const isPublicUser$1 = (0,_privileges_5c382f61_js__WEBPACK_IMPORTED_MODULE_0__.a)(user);
    let possibleShareLevelOptions = DEFAULT_SHARE_LEVELS;
    if (isPublicUser$1) {
        possibleShareLevelOptions = ["private", "public"];
    }
    else if (!portal.canSharePublic && !(0,_privileges_5c382f61_js__WEBPACK_IMPORTED_MODULE_0__.b)(user)) {
        possibleShareLevelOptions = ["private", "org"];
    }
    possibleShareLevelOptions = possibleShareLevelOptions.filter((shareLevel) => canShareLevel(shareLevel, items, user, portal));
    return possibleShareLevelOptions;
};
const canShareLevel = (shareLevel, items, user, portal) => {
    var _a;
    if (shareLevel === "private") {
        return true;
    }
    const isOwnerOfAllItems = itemsOwnedByUser(user, items);
    const itemsBelongToOrg = itemsOwnedByOrg(user, items);
    const isItemAdmin = (0,_privileges_5c382f61_js__WEBPACK_IMPORTED_MODULE_0__.b)(user) && !(0,_privileges_5c382f61_js__WEBPACK_IMPORTED_MODULE_0__.d)(user) && itemsBelongToOrg;
    const isCustomItemAdmin = (0,_privileges_5c382f61_js__WEBPACK_IMPORTED_MODULE_0__.b)(user) && (0,_privileges_5c382f61_js__WEBPACK_IMPORTED_MODULE_0__.d)(user) && itemsBelongToOrg;
    const isPublicUser$1 = (0,_privileges_5c382f61_js__WEBPACK_IMPORTED_MODULE_0__.a)(user);
    if (shareLevel === "org") {
        if (isPublicUser$1) {
            return false;
        }
        return (((0,_privileges_5c382f61_js__WEBPACK_IMPORTED_MODULE_0__.k)(user) && (isOwnerOfAllItems || isItemAdmin)) ||
            ((0,_privileges_5c382f61_js__WEBPACK_IMPORTED_MODULE_0__.m)(user) && (isItemAdmin || isCustomItemAdmin)));
    }
    if (shareLevel === "public") {
        const developer = (0,_privileges_5c382f61_js__WEBPACK_IMPORTED_MODULE_0__.i)((portal === null || portal === void 0 ? void 0 : portal.subscriptionInfo) || ((_a = portal === null || portal === void 0 ? void 0 : portal.sourceJSON) === null || _a === void 0 ? void 0 : _a.subscriptionInfo));
        if (items.length === 1 &&
            ((0,_services_66aee31b_js__WEBPACK_IMPORTED_MODULE_3__.c)(items[0]) || (developer && (0,_services_66aee31b_js__WEBPACK_IMPORTED_MODULE_3__.d)(items[0])))) {
            return false;
        }
        const canSharePublic = portal.canSharePublic;
        return (isPublicUser$1 ||
            ((0,_privileges_5c382f61_js__WEBPACK_IMPORTED_MODULE_0__.n)(user) && ((isOwnerOfAllItems && canSharePublic) || isItemAdmin)) ||
            ((0,_privileges_5c382f61_js__WEBPACK_IMPORTED_MODULE_0__.o)(user) && (isItemAdmin || isCustomItemAdmin)));
    }
};
/**
 * Determine the share mode of the user based on the item.
 *
 * ! We only consider the first item on the list
 */
const getShareMode = (items, user, portal) => {
    var _a;
    const item = items[0];
    if ((0,_item_3535552d_js__WEBPACK_IMPORTED_MODULE_2__.i)(item, user)) {
        return "default";
    }
    /**
     * if there is no org id on the item, deduce that the user can do admin things
     *
     * if item.orgId is present, check equality against portal user's org
     */
    const itemOwnerAndUserSameOrg = (!item.orgId && !((_a = item.sourceJSON) === null || _a === void 0 ? void 0 : _a.orgId)) || itemsOwnedByOrg(user, [item]);
    if ((0,_privileges_5c382f61_js__WEBPACK_IMPORTED_MODULE_0__.p)({ items, user, portal }) && itemOwnerAndUserSameOrg) {
        return "admin";
    }
    // if the user is not item owner or org admin, they enter group sharing mode
    // which is very restricted
    return "group";
};
const itemsOwnedByUser = (user, items) => {
    return items.every((item) => (0,_item_3535552d_js__WEBPACK_IMPORTED_MODULE_2__.i)(item, user));
};
const itemsOwnedByOrg = (user, items) => {
    const userOrgId = user === null || user === void 0 ? void 0 : user.orgId;
    return items.every((item) => {
        var _a, _b;
        return ((0,_item_3535552d_js__WEBPACK_IMPORTED_MODULE_2__.i)(item, user) ||
            item.orgId === userOrgId ||
            ((_a = item.sourceJSON) === null || _a === void 0 ? void 0 : _a.orgId) === userOrgId ||
            ((_b = item.portal) === null || _b === void 0 ? void 0 : _b.id) === userOrgId ||
            item.isOrgItem);
    });
};
const isShareLevelDirty = (selectedShareLevels, initialShareLevels, items, selectedGroupData) => selectedShareLevels.some((curShareLevel, index) => {
    const initialShareLevel = initialShareLevels[index];
    // "shared" level = shared to group + "private"
    if (initialShareLevel === "shared" && curShareLevel === "private") {
        const item = items[index];
        return !selectedGroupData.some((groupData) => groupData.selectedByItemIds.includes(item.id));
    }
    return initialShareLevel !== curShareLevel;
});
// TODO: optimize this O(n^3)...
const isSelectedGroupDataDirty = (initialSelectedGroupData, curSelectedGroupData) => {
    if (initialSelectedGroupData.length !== curSelectedGroupData.length) {
        return true;
    }
    return curSelectedGroupData.some((curGroupData) => {
        const initialGroupData = initialSelectedGroupData.find((initialGroupData) => initialGroupData.group.id === curGroupData.group.id);
        if (!initialGroupData) {
            return true;
        }
        return !(0,_functional_44de8fcf_js__WEBPACK_IMPORTED_MODULE_1__.f)(initialGroupData.selectedByItemIds, curGroupData.selectedByItemIds);
    });
};



//# sourceMappingURL=utils-f4f44b88.js.map

/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid2lkZ2V0cy9jaHVua3MvYXJjZ2lzX2FuYWx5c2lzX25vZGVfbW9kdWxlc19hcmNnaXNfYXBwLWNvbXBvbmVudHNfZGlzdF9lc21fbG9jYWxlLTE1OGU4MC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUMyRDtBQUNxQjtBQUNwQjs7QUFFNUQ7QUFDQTtBQUNBLDJCQUEyQix1REFBWTtBQUN2QztBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsVUFBVTtBQUNoQztBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0EsOENBQThDLDJCQUEyQjtBQUN6RTtBQUNBLFdBQVcsdURBQVk7QUFDdkI7QUFDQTtBQUNBLDBDQUEwQyxzREFBYyxTQUFTLGdCQUFnQixPQUFPO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQix1REFBWTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QiwyQkFBMkI7QUFDbEQsaUJBQWlCLGNBQWMsdURBQVk7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsdURBQWU7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyx1REFBWSxJQUFJLE1BQU0sbURBQWtCLGtFQUFrRSxvQkFBb0Isb0NBQW9DO0FBQ25NO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUU4SDs7QUFFOUg7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzFFQTtBQUNBO0FBQ0E7QUFDQTtBQUM2RDtBQUNjOztBQUUzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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Q0E7QUFDQTtBQUNBLHdCQUF3QiwwREFBVSxXQUFXLDBEQUFZO0FBQ3pELDhCQUE4QiwwREFBVSxVQUFVLDBEQUFZO0FBQzlELDJCQUEyQiwwREFBWTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiwwREFBaUI7QUFDbEMsYUFBYSwwREFBd0I7QUFDckM7QUFDQTtBQUNBLDBCQUEwQiwwREFBVztBQUNyQztBQUNBLGFBQWEsd0RBQTRCLDRCQUE0Qix3REFBcUM7QUFDMUc7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLDBEQUFvQjtBQUNqQyxhQUFhLDBEQUEyQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsb0RBQU87QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSwwREFBc0IsR0FBRyxxQkFBcUI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsb0RBQU87QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixvREFBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsMERBQW1CO0FBQ25DLEtBQUs7QUFDTDs7QUFFb1o7O0FBRXBaIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZXhiLWNsaWVudC8uL2V4dGVuc2lvbnMvd2lkZ2V0cy9hcmNnaXMvYW5hbHlzaXMvbm9kZV9tb2R1bGVzL0BhcmNnaXMvYXBwLWNvbXBvbmVudHMvZGlzdC9lc20vaXRlbS1jNThmZmNlZC5qcyIsIndlYnBhY2s6Ly9leGItY2xpZW50Ly4vZXh0ZW5zaW9ucy93aWRnZXRzL2FyY2dpcy9hbmFseXNpcy9ub2RlX21vZHVsZXMvQGFyY2dpcy9hcHAtY29tcG9uZW50cy9kaXN0L2VzbS9sYW5ndWFnZVV0aWwtZWYwZTU0YjIuanMiLCJ3ZWJwYWNrOi8vZXhiLWNsaWVudC8uL2V4dGVuc2lvbnMvd2lkZ2V0cy9hcmNnaXMvYW5hbHlzaXMvbm9kZV9tb2R1bGVzL0BhcmNnaXMvYXBwLWNvbXBvbmVudHMvZGlzdC9lc20vbG9jYWxlLTA1MGI2ZGI5LmpzIiwid2VicGFjazovL2V4Yi1jbGllbnQvLi9leHRlbnNpb25zL3dpZGdldHMvYXJjZ2lzL2FuYWx5c2lzL25vZGVfbW9kdWxlcy9AYXJjZ2lzL2FwcC1jb21wb25lbnRzL2Rpc3QvZXNtL3ByaXZpbGVnZXMtNWMzODJmNjEuanMiLCJ3ZWJwYWNrOi8vZXhiLWNsaWVudC8uL2V4dGVuc2lvbnMvd2lkZ2V0cy9hcmNnaXMvYW5hbHlzaXMvbm9kZV9tb2R1bGVzL0BhcmNnaXMvYXBwLWNvbXBvbmVudHMvZGlzdC9lc20vc2VydmljZS04YzJjNDI0MS5qcyIsIndlYnBhY2s6Ly9leGItY2xpZW50Ly4vZXh0ZW5zaW9ucy93aWRnZXRzL2FyY2dpcy9hbmFseXNpcy9ub2RlX21vZHVsZXMvQGFyY2dpcy9hcHAtY29tcG9uZW50cy9kaXN0L2VzbS9zZXJ2aWNlcy02NmFlZTMxYi5qcyIsIndlYnBhY2s6Ly9leGItY2xpZW50Ly4vZXh0ZW5zaW9ucy93aWRnZXRzL2FyY2dpcy9hbmFseXNpcy9ub2RlX21vZHVsZXMvQGFyY2dpcy9hcHAtY29tcG9uZW50cy9kaXN0L2VzbS91dGlscy1mNGY0NGI4OC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIEFsbCBtYXRlcmlhbCBjb3B5cmlnaHQgRVNSSSwgQWxsIFJpZ2h0cyBSZXNlcnZlZCwgdW5sZXNzIG90aGVyd2lzZSBzcGVjaWZpZWQuXG4gKiB2NC4wLjU4XG4gKi9cbmltcG9ydCB7IGcgYXMgZ2V0UmVzdEJhc2VVcmwgfSBmcm9tICcuL3BvcnRhbC1kNTE4YjU3MS5qcyc7XG5pbXBvcnQgeyBpIGFzIGlzSG9zdGVkU2VydmljZSwgciBhcyByZXF1ZXN0RmV0Y2ggfSBmcm9tICcuL3NlcnZpY2UtOGMyYzQyNDEuanMnO1xuaW1wb3J0IHsgcCBhcyBwYXJzZUFHU1NlcnZlckluZm8gfSBmcm9tICcuL3VybC00YzNhZTU0Yy5qcyc7XG5cbmNvbnN0IGdldEh5ZHJhdGVkSXRlbSA9IGFzeW5jIChpdGVtSWQsIHBvcnRhbCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGl0ZW0gPSBhd2FpdCByZXF1ZXN0RmV0Y2goZ2V0SXRlbVVybChpdGVtSWQsIHBvcnRhbCksIHBvcnRhbCk7XG4gICAgICAgIC8vIFRPRE86IGNoZWNrIGlmIHdlIHN0aWxsIG5lZWQgdG8gZG8gdGhpc1xuICAgICAgICAvLyBpZiAoaXNIb3N0ZWRTZXJ2aWNlKGl0ZW0udHlwZUtleXdvcmRzLCBpdGVtLnR5cGUpKSB7XG4gICAgICAgIC8vICAgY29uc3QgaXRlbURhdGEgPSBnZXRJdGVtRGF0YShpdGVtLmlkLCBwb3J0YWwpO1xuICAgICAgICAvLyAgIHJldHVybiB7IHJlc3VsdDogeyAuLi5pdGVtLCAuLi5pdGVtSW5mbywgLi4uaXRlbURhdGEgfSB9O1xuICAgICAgICAvLyB9XG4gICAgICAgIHJldHVybiB7IHJlc3VsdDogaXRlbSB9O1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gICAgICAgIHJldHVybiB7IGVycm9yOiB7IGNvZGU6IFwidW5oYW5kbGVkRXJyb3JcIiB9IH07XG4gICAgfVxufTtcbmNvbnN0IGdldEl0ZW1EYXRhVXJsID0gKGl0ZW1JZCwgcG9ydGFsKSA9PiBgJHtnZXRJdGVtVXJsKGl0ZW1JZCwgcG9ydGFsKX0vZGF0YWA7XG5jb25zdCBnZXRJdGVtRGF0YSA9IGFzeW5jIChpdGVtSWQsIHBvcnRhbCkgPT4ge1xuICAgIHJldHVybiByZXF1ZXN0RmV0Y2goZ2V0SXRlbURhdGFVcmwoaXRlbUlkLCBwb3J0YWwpLCBwb3J0YWwpO1xufTtcbi8vIFRPRE86IHJlbW92ZSB0aGVzZSBvbmNlIHdlIGZpZ3VyZSBvdXQgaG93IHRvIGVmZmljaWVudGx5IGRpc2FibGUgdGhlIHRvYXN0IG9uIHRoZSBIb21lIEFwcFxuY29uc3QgZ2V0SXRlbVVybCA9IChpdGVtSWQsIHBvcnRhbCkgPT4gYCR7Z2V0UmVzdEJhc2VVcmwocG9ydGFsKX1jb250ZW50L2l0ZW1zLyR7aXRlbUlkfWA7XG5jb25zdCBnZXRJdGVtID0gYXN5bmMgKGl0ZW1JZCwgcG9ydGFsLCByZXF1ZXN0T3B0aW9ucykgPT4ge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHVybCA9IGdldEl0ZW1VcmwoaXRlbUlkLCBwb3J0YWwpO1xuICAgICAgICByZXR1cm4gYXdhaXQgcmVxdWVzdEZldGNoKHVybCwgcG9ydGFsLCByZXF1ZXN0T3B0aW9ucyk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLndhcm4oZXJyb3IpO1xuICAgIH1cbn07XG5jb25zdCBnZXRJdGVtR3JvdXBzID0gYXN5bmMgKGl0ZW1JZCwgcG9ydGFsKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgdXJsID0gYCR7Z2V0SXRlbVVybChpdGVtSWQsIHBvcnRhbCl9L2dyb3Vwc2A7XG4gICAgICAgIHJldHVybiB7IHJlc3VsdDogYXdhaXQgcmVxdWVzdEZldGNoKHVybCwgcG9ydGFsKSB9O1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgLy8gVE9ETzogaGFuZGxlIGVycm9yXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xuICAgICAgICByZXR1cm4geyBlcnJvcjogeyBjb2RlOiBcInVuaGFuZGxlZEVycm9yXCIgfSB9O1xuICAgIH1cbn07XG5jb25zdCBpc0VkaXRhYmxlSXRlbSA9IGFzeW5jIChpdGVtLCBwb3J0YWwpID0+IHtcbiAgICBsZXQgaXNFZGl0YWJsZSA9IGZhbHNlO1xuICAgIGlmIChpc0hvc3RlZFNlcnZpY2UoaXRlbS50eXBlS2V5d29yZHMsIGl0ZW0udHlwZSkpIHtcbiAgICAgICAgaXNFZGl0YWJsZSA9IGF3YWl0IGhhc0VkaXRpbmdDYXBhYmlsaXR5KGl0ZW0udXJsLCBwb3J0YWwpO1xuICAgIH1cbiAgICByZXR1cm4gaXNFZGl0YWJsZTtcbn07XG5jb25zdCBoYXNFZGl0aW5nQ2FwYWJpbGl0eSA9IGFzeW5jIChsYXllclVybCwgcG9ydGFsLCByZXF1aXJlZE5vVG9rZW4gPSBmYWxzZSkgPT4ge1xuICAgIHZhciBfYSwgX2IsIF9jO1xuICAgIGlmIChsYXllclVybCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVxdWVzdEZldGNoKGAkeyhfYSA9IHBhcnNlQUdTU2VydmVySW5mbyhsYXllclVybCkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5iYXNlU2VydmVyVXJsfS9sYXllcnNgLCBwb3J0YWwsIHsgYWRkVG9rZW5NYW51YWxseTogIXJlcXVpcmVkTm9Ub2tlbiB9KTtcbiAgICAgICAgICAgIHJldHVybiAoX2IgPSByZXN1bHQgPT09IG51bGwgfHwgcmVzdWx0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZXN1bHQubGF5ZXJzKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IucmVkdWNlKChtZW1vLCBsYXllcikgPT4gbWVtbyB8fCAobGF5ZXIgPT09IG51bGwgfHwgbGF5ZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGxheWVyLmNhcGFiaWxpdGllcy5pbmNsdWRlcyhcIkVkaXRpbmdcIikpLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoKF9jID0gZXJyb3IgPT09IG51bGwgfHwgZXJyb3IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGVycm9yLm1lc3NhZ2UpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKFwidG9rZW4gcmVxdWlyZWRcIikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaGFzRWRpdGluZ0NhcGFiaWxpdHkobGF5ZXJVcmwsIHBvcnRhbCwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxuZXhwb3J0IHsgZ2V0SHlkcmF0ZWRJdGVtIGFzIGEsIGdldEl0ZW1EYXRhVXJsIGFzIGIsIGdldEl0ZW0gYXMgYywgZ2V0SXRlbUdyb3VwcyBhcyBkLCBnZXRJdGVtRGF0YSBhcyBnLCBpc0VkaXRhYmxlSXRlbSBhcyBpIH07XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWl0ZW0tYzU4ZmZjZWQuanMubWFwIiwiLyohXG4gKiBBbGwgbWF0ZXJpYWwgY29weXJpZ2h0IEVTUkksIEFsbCBSaWdodHMgUmVzZXJ2ZWQsIHVubGVzcyBvdGhlcndpc2Ugc3BlY2lmaWVkLlxuICogdjQuMC41OFxuICovXG5pbXBvcnQgeyBsIGFzIGxvYWRNb2R1bGVzIH0gZnJvbSAnLi9sb2FkTW9kdWxlcy1iNGFjMTI0Ny5qcyc7XG5pbXBvcnQgeyBjIGFzIGNsb3Nlc3RFbGVtZW50Q3Jvc3NTaGFkb3dCb3VuZGFyeSB9IGZyb20gJy4vZG9tLTRkMzY3Njc3LmpzJztcblxuY29uc3QgbGFuZ3VhZ2VNYXAgPSBuZXcgTWFwKFtcbiAgICBbXCJhclwiLCBcImFyXCJdLFxuICAgIFtcImJnXCIsIFwiYmdcIl0sXG4gICAgW1wiYnNcIiwgXCJic1wiXSxcbiAgICBbXCJjYVwiLCBcImNhXCJdLFxuICAgIFtcImNzXCIsIFwiY3NcIl0sXG4gICAgW1wiZGFcIiwgXCJkYVwiXSxcbiAgICBbXCJkZVwiLCBcImRlXCJdLFxuICAgIFtcImVsXCIsIFwiZWxcIl0sXG4gICAgW1wiZW5cIiwgXCJlblwiXSxcbiAgICBbXCJlc1wiLCBcImVzXCJdLFxuICAgIFtcImV0XCIsIFwiZXRcIl0sXG4gICAgW1wiZmlcIiwgXCJmaVwiXSxcbiAgICBbXCJmclwiLCBcImZyXCJdLFxuICAgIFtcImhlXCIsIFwiaGVcIl0sXG4gICAgW1wiaHJcIiwgXCJoclwiXSxcbiAgICBbXCJodVwiLCBcImh1XCJdLFxuICAgIFtcImlkXCIsIFwiaWRcIl0sXG4gICAgW1wiaXRcIiwgXCJpdFwiXSxcbiAgICBbXCJqYVwiLCBcImphXCJdLFxuICAgIFtcImtvXCIsIFwia29cIl0sXG4gICAgW1wibHRcIiwgXCJsdFwiXSxcbiAgICBbXCJsdlwiLCBcImx2XCJdLFxuICAgIFtcIm5iXCIsIFwibmJcIl0sXG4gICAgW1wibmxcIiwgXCJubFwiXSxcbiAgICBbXCJwbFwiLCBcInBsXCJdLFxuICAgIFtcInB0LWJyXCIsIFwicHQtQlJcIl0sXG4gICAgW1wicHQtcHRcIiwgXCJwdC1QVFwiXSxcbiAgICBbXCJyb1wiLCBcInJvXCJdLFxuICAgIFtcInJ1XCIsIFwicnVcIl0sXG4gICAgW1wic2tcIiwgXCJza1wiXSxcbiAgICBbXCJzbFwiLCBcInNsXCJdLFxuICAgIFtcInNyXCIsIFwic3JcIl0sXG4gICAgW1wic3ZcIiwgXCJzdlwiXSxcbiAgICBbXCJ0aFwiLCBcInRoXCJdLFxuICAgIFtcInRyXCIsIFwidHJcIl0sXG4gICAgW1widWtcIiwgXCJ1a1wiXSxcbiAgICBbXCJ2aVwiLCBcInZpXCJdLFxuICAgIFtcInpoLWNuXCIsIFwiemgtQ05cIl0sXG4gICAgW1wiemgtaGtcIiwgXCJ6aC1IS1wiXSxcbiAgICBbXCJ6aC10d1wiLCBcInpoLVRXXCJdXG5dKTtcbi8vIHJ0bFxuZnVuY3Rpb24gZ2V0RWxlbWVudERpcihlbCkge1xuICAgIHJldHVybiBnZXRFbGVtZW50UHJvcChlbCwgXCJkaXJcIiwgXCJsdHJcIik7XG59XG5mdW5jdGlvbiBnZXRFbGVtZW50UHJvcChlbCwgcHJvcCwgdmFsdWUpIHtcbiAgICBjb25zdCBjbG9zZXN0V2l0aFByb3AgPSBjbG9zZXN0RWxlbWVudENyb3NzU2hhZG93Qm91bmRhcnkoZWwsIGBbJHtwcm9wfV1gKTtcbiAgICByZXR1cm4gY2xvc2VzdFdpdGhQcm9wID8gY2xvc2VzdFdpdGhQcm9wLmdldEF0dHJpYnV0ZShwcm9wKSA6IHZhbHVlO1xufVxuLy8gY3NzXG5jb25zdCBDU1NfVVRJTElUWSA9IHtcbiAgICBydGw6IFwiYXJjZ2lzLS1ydGxcIlxufTtcbmFzeW5jIGZ1bmN0aW9uIGZvcm1hdE51bWJlcihudW1iZXIsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IGFwaSwgdHlwZSwgcGxhY2VzIH0gPSBvcHRpb25zIHx8IHt9O1xuICAgIGlmIChhcGkgPT09IDQpIHtcbiAgICAgICAgY29uc3QgW2ludGxdID0gYXdhaXQgbG9hZE1vZHVsZXMoW1wiZXNyaS9pbnRsXCJdKTtcbiAgICAgICAgY29uc3QgbnVtYmVyRm9ybWF0SW50bE9wdGlvbnMgPSBpbnRsLmNvbnZlcnROdW1iZXJGb3JtYXRUb0ludGxPcHRpb25zKHtcbiAgICAgICAgICAgIHBsYWNlcyxcbiAgICAgICAgICAgIHN0eWxlOiB0eXBlLFxuICAgICAgICAgICAgZGlnaXRTZXBhcmF0b3I6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBpbnRsLmZvcm1hdE51bWJlcihudW1iZXIsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbnVtYmVyRm9ybWF0SW50bE9wdGlvbnMpLCB7IHN0eWxlOiB0eXBlIH0pKTtcbiAgICB9XG4gICAgY29uc3QgW2Rvam9OdW1iZXJdID0gYXdhaXQgbG9hZE1vZHVsZXMoW1wiZG9qby9udW1iZXJcIl0pO1xuICAgIHJldHVybiBkb2pvTnVtYmVyLmZvcm1hdChudW1iZXIsIHtcbiAgICAgICAgdHlwZSxcbiAgICAgICAgcGxhY2VzLFxuICAgICAgICBwYXR0ZXJuOiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMucGF0dGVyblxuICAgIH0pO1xufVxuY29uc3QgY2FjaGUgPSB7fTtcbmZ1bmN0aW9uIGZvcm1hdERhdGUoZGF0ZSkge1xuICAgIGNvbnN0IGxhbmcgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQubGFuZztcbiAgICBjb25zdCBkYXlTaG9ydE1vbnRoWWVhciA9IHtcbiAgICAgICAgeWVhcjogXCJudW1lcmljXCIsXG4gICAgICAgIG1vbnRoOiBcInNob3J0XCIsXG4gICAgICAgIGRheTogXCJudW1lcmljXCJcbiAgICB9O1xuICAgIGlmICghY2FjaGVbbGFuZ10pIHtcbiAgICAgICAgY2FjaGVbbGFuZ10gPSBuZXcgSW50bC5EYXRlVGltZUZvcm1hdChkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQubGFuZywgZGF5U2hvcnRNb250aFllYXIpO1xuICAgIH1cbiAgICByZXR1cm4gY2FjaGVbbGFuZ10uZm9ybWF0KGRhdGUpO1xufVxuZnVuY3Rpb24gZm9ybWF0UGx1cmFsKGxhbmcsIHN0cmluZ09iaiwgbnVtYmVyKSB7XG4gICAgY29uc3Qgc2luZ2xlcyA9IFtcImlkXCIsIFwiamFcIiwgXCJrb1wiLCBcInRoXCIsIFwidmlcIiwgXCJ6aC1jblwiLCBcInpoLWhrXCIsIFwiemgtdHdcIl07XG4gICAgY29uc3QgbGlrZUVuZ2xpc2ggPSBbXG4gICAgICAgIFwiZW5cIixcbiAgICAgICAgXCJjYVwiLFxuICAgICAgICBcImRhXCIsXG4gICAgICAgIFwiZGVcIixcbiAgICAgICAgXCJlbFwiLFxuICAgICAgICBcImVzXCIsXG4gICAgICAgIFwiZXRcIixcbiAgICAgICAgXCJmaVwiLFxuICAgICAgICBcImhpXCIsXG4gICAgICAgIFwiaHVcIixcbiAgICAgICAgXCJpdFwiLFxuICAgICAgICBcIm5iXCIsXG4gICAgICAgIFwibmxcIixcbiAgICAgICAgXCJwdC1wdFwiLFxuICAgICAgICBcInN2XCIsXG4gICAgICAgIFwidHJcIlxuICAgIF07XG4gICAgY29uc3QgbG9jYWxlID0gbGFuZyAhPT0gbnVsbCAmJiBsYW5nICE9PSB2b2lkIDAgPyBsYW5nIDogXCJlblwiO1xuICAgIC8vIGlmIHRoZSBudW1iZXIgaXMgb25lLCBvciBpdCBpcyBhIFwic2ltcGxlXCIgbGFuZ3VhZ2UsIHJldHVybiB0aGUgMSBzdHJpbmdcbiAgICBpZiAobnVtYmVyID09PSAxIHx8IHNpbmdsZXMuaW5jbHVkZXMobG9jYWxlKSkge1xuICAgICAgICByZXR1cm4gc3RyaW5nT2JqLnNpbmdsZS5yZXBsYWNlKFwiJHtudW1iZXJ9XCIsIFwiMVwiKTtcbiAgICB9XG4gICAgLy8gaWYgdGhlIG51bWJlciBpcyBub3QgMSBhbmQgdGhlIGxhbmd1YWdlIHVzZXMgdGhlIHNhbWUgcGx1cmFsaXphdGlvbiBzdHJhdGVneSBhcyBlbmdsaXNoLFxuICAgIC8vIHJldHVybiB0aGUgbXVsdGlwbGUgc3RyaW5nXG4gICAgaWYgKG51bWJlciAhPT0gMSAmJiBsaWtlRW5nbGlzaC5pbmNsdWRlcyhsb2NhbGUpKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmdPYmoubXVsdGlwbGUucmVwbGFjZShcIiR7bnVtYmVyfVwiLCBgJHtudW1iZXJ9YCk7XG4gICAgfVxuICAgIC8vIGlmIG5vbmUgb2YgdGhlIGFib3ZlIHdvcmtlZCwgcmV0dXJuIHRoZSBcInVua25vd25cIiBzdHJpbmdcbiAgICByZXR1cm4gc3RyaW5nT2JqLnVua25vd24ucmVwbGFjZShcIiR7bnVtYmVyfVwiLCBgJHtudW1iZXJ9YCk7XG59XG5cbmV4cG9ydCB7IENTU19VVElMSVRZIGFzIEMsIGZvcm1hdERhdGUgYXMgYSwgZm9ybWF0UGx1cmFsIGFzIGIsIGZvcm1hdE51bWJlciBhcyBmLCBnZXRFbGVtZW50RGlyIGFzIGcsIGxhbmd1YWdlTWFwIGFzIGwgfTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bGFuZ3VhZ2VVdGlsLWVmMGU1NGIyLmpzLm1hcCIsIi8qIVxuICogQWxsIG1hdGVyaWFsIGNvcHlyaWdodCBFU1JJLCBBbGwgUmlnaHRzIFJlc2VydmVkLCB1bmxlc3Mgb3RoZXJ3aXNlIHNwZWNpZmllZC5cbiAqIHY0LjAuNThcbiAqL1xuaW1wb3J0IHsgYyBhcyBjbG9zZXN0RWxlbWVudENyb3NzU2hhZG93Qm91bmRhcnkgfSBmcm9tICcuL2RvbS00ZDM2NzY3Ny5qcyc7XG5pbXBvcnQgeyBsIGFzIGxhbmd1YWdlTWFwIH0gZnJvbSAnLi9sYW5ndWFnZVV0aWwtZWYwZTU0YjIuanMnO1xuaW1wb3J0IHsgYSBhcyBnZXRBc3NldFBhdGggfSBmcm9tICcuL2luZGV4LWUzYmY3ZGE3LmpzJztcblxuLy8gaHR0cHM6Ly9tZWRpdW0uY29tL3N0ZW5jaWwtdHJpY2tzL2ltcGxlbWVudGluZy1pbnRlcm5hdGlvbmFsaXNhdGlvbi1pMThuLXdpdGgtc3RlbmNpbC01ZTY1NTk1NTQxMTdcbmZ1bmN0aW9uIGdldENvbXBvbmVudENsb3Nlc3RMYW5ndWFnZShlbGVtZW50KSB7XG4gICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgY29uc3QgY2xvc2VzdEVsZW1lbnQgPSAoX2EgPSBjbG9zZXN0RWxlbWVudENyb3NzU2hhZG93Qm91bmRhcnkoZWxlbWVudCwgXCJbbGFuZ11cIikpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IChfYyA9IChfYiA9IGVsZW1lbnQuc2hhZG93Um9vdCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLm93bmVyRG9jdW1lbnQpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5kb2N1bWVudEVsZW1lbnQ7XG4gICAgLy8gbGFuZ3VhZ2Ugc2V0IGJ5IHRoZSBjYWxsaW5nIGFwcGxpY2F0aW9uIG9yIGJyb3dzZXIuIGRlZmF1bHRzIHRvIGVuZ2xpc2guXG4gICAgY29uc3QgbGFuZyA9ICgoY2xvc2VzdEVsZW1lbnQgPT09IG51bGwgfHwgY2xvc2VzdEVsZW1lbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNsb3Nlc3RFbGVtZW50LmxhbmcpIHx8IChuYXZpZ2F0b3IgPT09IG51bGwgfHwgbmF2aWdhdG9yID09PSB2b2lkIDAgPyB2b2lkIDAgOiBuYXZpZ2F0b3IubGFuZ3VhZ2UpIHx8IFwiZW5cIikudG9Mb3dlckNhc2UoKTtcbiAgICBpZiAobGFuZ3VhZ2VNYXAuaGFzKGxhbmcpKSB7XG4gICAgICAgIHJldHVybiBsYW5ndWFnZU1hcC5nZXQobGFuZyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBcInJ1LVJVXCIgbWFwcyB0byBcInJ1XCIgdXNlIGNhc2VcbiAgICAgICAgaWYgKGxhbmd1YWdlTWFwLmhhcyhsYW5nLnNsaWNlKDAsIDIpKSkge1xuICAgICAgICAgICAgcmV0dXJuIGxhbmd1YWdlTWFwLmdldChsYW5nLnNsaWNlKDAsIDIpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBcImVuXCI7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBnZXRDb21wb25lbnRDbG9zZXN0TGFuZ3VhZ2VJbnRsKGVsZW1lbnQpIHtcbiAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAvLyBpdCdzIE9LIGlmIHdlIGRvbid0IGhhdmUgdGhlIDQgbGV0dGVyIGxhbmd1YWdlIGZpbGUgZm9yIGl0XG4gICAgLy8gNCBsZXR0ZXIgbGFuZ3VhZ2UgY29kZSBuZWVkZWQgZm9yIGZvcm1hdHRpbmcgbnVtYmVyc1xuICAgIGNvbnN0IGNsb3Nlc3RFbGVtZW50ID0gKF9hID0gY2xvc2VzdEVsZW1lbnRDcm9zc1NoYWRvd0JvdW5kYXJ5KGVsZW1lbnQsIFwiW2xhbmddXCIpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAoX2MgPSAoX2IgPSBlbGVtZW50LnNoYWRvd1Jvb3QpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5vd25lckRvY3VtZW50KSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuZG9jdW1lbnRFbGVtZW50O1xuICAgIC8vIGxhbmd1YWdlIHNldCBieSB0aGUgY2FsbGluZyBhcHBsaWNhdGlvbiBvciBicm93c2VyLiBkZWZhdWx0cyB0byBlbmdsaXNoLlxuICAgIGNvbnN0IGxhbmcgPSAoKGNsb3Nlc3RFbGVtZW50ID09PSBudWxsIHx8IGNsb3Nlc3RFbGVtZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjbG9zZXN0RWxlbWVudC5sYW5nKSB8fCAobmF2aWdhdG9yID09PSBudWxsIHx8IG5hdmlnYXRvciA9PT0gdm9pZCAwID8gdm9pZCAwIDogbmF2aWdhdG9yLmxhbmd1YWdlKSB8fCBcImVuXCIpLnRvTG93ZXJDYXNlKCk7XG4gICAgaWYgKGxhbmd1YWdlTWFwLmhhcyhsYW5nKSkge1xuICAgICAgICByZXR1cm4gbGFuZ3VhZ2VNYXAuZ2V0KGxhbmcpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKGxhbmd1YWdlTWFwLmhhcyhsYW5nLnNsaWNlKDAsIDIpKSkge1xuICAgICAgICAgICAgLy8gd2Ugc3VwcG9ydCB0aGUgMiBsZXR0ZXIgY29kZWQgbGFuZ3VhZ2VcbiAgICAgICAgICAgIC8vIGUuZy4gaXQtQ0ggdnMgaXRcbiAgICAgICAgICAgIHJldHVybiBsYW5nO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFwiZW5cIjtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGZldGNoTG9jYWxlU3RyaW5nc0ZvckNvbXBvbmVudChjb21wb25lbnROYW1lLCBsb2NhbGUpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBmZXRjaChnZXRBc3NldFBhdGgoYC4uL2FyY2dpcy1hcHAtYXNzZXRzL2kxOG4vJHtjb21wb25lbnROYW1lfS5pMThuLiR7bG9jYWxlfS5qc29uYCkpLnRoZW4oKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgaWYgKHJlc3VsdC5vaylcbiAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdC5qc29uKCkpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHJlamVjdCgpO1xuICAgICAgICB9LCAoKSA9PiByZWplY3QoKSk7XG4gICAgfSk7XG59XG5jb25zdCBzdHJpbmdDYWNoZSA9IHt9O1xuZnVuY3Rpb24gZmV0Y2hMb2NhbGVTdHJpbmdzRnJvbUNhY2hlKGNvbXBvbmVudE5hbWUsIGxvY2FsZSkge1xuICAgIGNvbnN0IGlkID0gYCR7Y29tcG9uZW50TmFtZX0ke2xvY2FsZX1gO1xuICAgIGlmICghc3RyaW5nQ2FjaGVbaWRdKSB7XG4gICAgICAgIHN0cmluZ0NhY2hlW2lkXSA9IGZldGNoTG9jYWxlU3RyaW5nc0ZvckNvbXBvbmVudChjb21wb25lbnROYW1lLCBsb2NhbGUpO1xuICAgIH1cbiAgICByZXR1cm4gc3RyaW5nQ2FjaGVbaWRdO1xufVxuLyoqXG4gKiBHZXQgc3RyaW5ncyBhbmQgbGFuZ3VhZ2UgY29kZXMuXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIDIgbGFuZ3VhZ2UgY29kZXMuXG4gKiBUaGUgZmlyc3Qgb25lIHJldHVybnMgYSBjb2RlIHRoYXQncyBhbHNvIHN1cHBvcnRlZCBhcyBhIGxhbmd1YWdlIGZpbGUuXG4gKiBUaGUgc2Vjb25kIG9uZSByZXR1cm5zIGEgY29kZSB3aGVyZSB0aGVyZSBpcyBzdXBwb3J0IGZvciB0aGUgZmlyc3QgMiBsZXR0ZXJzIG9mIHRoZSBjb2RlIGFzIHBhcnQgb2YgYSBsYW5ndWFnZSBmaWxlLFxuICogYnV0IHdpbGwgcmV0dXJuIHRoZSBvcmlnaW5hbCA0IGxldHRlciBjb2RlIGZyb20gdGhlIHBhZ2UuXG4gKiBFLmcuIEZvciBcIml0LWNoXCIgaXQgd2lsbCByZXR1cm4gXCJpdFwiIGFzIHRoZSBmaXJzdCBsYW5ndWFnZSBjb2RlIGFuZCBcIml0LWNoXCIgYXMgdGhlIHNlY29uZC5cbiAqIFRoZSBzZWNvbmQgb25lIGlzIHJlcXVpcmVkIGZvciBlc3JpLmludGwuc2V0TG9jYWxlKCkgdG8gZ2V0IHRoZSBjb3JyZWN0IGZvcm1hdHRpbmcuXG4gKlxuICogSWYgYSB0YWdOYW1lIGlzIHByb3ZpZGVkIGl0IHdpbGwgb3ZlcndpdGUgdGhlIGVsZW1lbnQncyB0YWdOYW1lXG4gKlxuICogIEByZXR1cm4gWyBzdHJpbmdzLCBmaXJzdCBsYW5ndWFnZSBjb2RlLCBzZWNvbmQgbGFuZ3VhZ2UgY29kZV1cbiAqL1xuYXN5bmMgZnVuY3Rpb24gZ2V0TG9jYWxlQ29tcG9uZW50U3RyaW5ncyhlbGVtZW50LCB0YWdOYW1lKSB7XG4gICAgY29uc3QgY29tcG9uZW50TmFtZSA9IHRhZ05hbWUgfHwgZWxlbWVudC50YWdOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgY29uc3QgY29tcG9uZW50TGFuZ3VhZ2UgPSBnZXRDb21wb25lbnRDbG9zZXN0TGFuZ3VhZ2UoZWxlbWVudCk7XG4gICAgY29uc3QgY29tcG9uZW50TGFuZ3VhZ2VJbnRsID0gZ2V0Q29tcG9uZW50Q2xvc2VzdExhbmd1YWdlSW50bChlbGVtZW50KTtcbiAgICBsZXQgc3RyaW5ncztcbiAgICB0cnkge1xuICAgICAgICBzdHJpbmdzID0gYXdhaXQgZmV0Y2hMb2NhbGVTdHJpbmdzRnJvbUNhY2hlKGNvbXBvbmVudE5hbWUsIGNvbXBvbmVudExhbmd1YWdlKTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgY29uc29sZS53YXJuKGBubyBsb2NhbGUgZm9yICR7Y29tcG9uZW50TmFtZX0gKCR7Y29tcG9uZW50TGFuZ3VhZ2V9KSBsb2FkaW5nIGRlZmF1bHQgbG9jYWxlIGVuLmApO1xuICAgICAgICBzdHJpbmdzID0gYXdhaXQgZmV0Y2hMb2NhbGVTdHJpbmdzRnJvbUNhY2hlKGNvbXBvbmVudE5hbWUsIFwiZW5cIik7XG4gICAgfVxuICAgIHJldHVybiBbc3RyaW5ncywgY29tcG9uZW50TGFuZ3VhZ2UsIGNvbXBvbmVudExhbmd1YWdlSW50bF07XG59XG5cbmV4cG9ydCB7IGdldENvbXBvbmVudENsb3Nlc3RMYW5ndWFnZSBhcyBhLCBnZXRMb2NhbGVDb21wb25lbnRTdHJpbmdzIGFzIGcgfTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bG9jYWxlLTA1MGI2ZGI5LmpzLm1hcCIsIi8qIVxuICogQWxsIG1hdGVyaWFsIGNvcHlyaWdodCBFU1JJLCBBbGwgUmlnaHRzIFJlc2VydmVkLCB1bmxlc3Mgb3RoZXJ3aXNlIHNwZWNpZmllZC5cbiAqIHY0LjAuNThcbiAqL1xuaW1wb3J0IHsgdSBhcyB1c2VySXNJdGVtQWRtaW4sIGMgYXMgY2FuVXBkYXRlSXRlbSwgZCBhcyBpdGVtc0JlbG9uZ1RvVXNlck9yZyB9IGZyb20gJy4vaXRlbS0zNTM1NTUyZC5qcyc7XG5cbmNvbnN0IGdldFVzZXJSb2xlID0gKHVzZXIpID0+IHtcbiAgICB2YXIgX2EsIF9iLCBfYztcbiAgICByZXR1cm4gdHlwZW9mICh1c2VyID09PSBudWxsIHx8IHVzZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHVzZXIucm9sZSkgPT09IFwic3RyaW5nXCIgJiYgISEodXNlciA9PT0gbnVsbCB8fCB1c2VyID09PSB2b2lkIDAgPyB2b2lkIDAgOiB1c2VyLnJvbGUpXG4gICAgICAgID8gdXNlciA9PT0gbnVsbCB8fCB1c2VyID09PSB2b2lkIDAgPyB2b2lkIDAgOiB1c2VyLnJvbGVcbiAgICAgICAgOiAoX2IgPSAoX2EgPSB1c2VyID09PSBudWxsIHx8IHVzZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHVzZXIucm9sZUlkKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB1c2VyID09PSBudWxsIHx8IHVzZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHVzZXIuaWQpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IChfYyA9IHVzZXIgPT09IG51bGwgfHwgdXNlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogdXNlci5zb3VyY2VKU09OKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuaWQ7XG59O1xuZnVuY3Rpb24gaXNQdWJsaWNVc2VyKHVzZXIpIHtcbiAgICByZXR1cm4gdXNlciAmJiAhdXNlci5vcmdJZDtcbn1cbmZ1bmN0aW9uIGlzSG9zdGVkUG9ydGFsKHBvcnRhbCkge1xuICAgIHJldHVybiAhcG9ydGFsLmlzUG9ydGFsIHx8ICEhcG9ydGFsLmlzQmFja2VkQnlTRFM7XG59XG5mdW5jdGlvbiBpc0RldmVsb3BlcihzdWJzY3JpcHRpb25JbmZvKSB7XG4gICAgY29uc3QgZGV2U3Vic2NyaXB0aW9uVHlwZXMgPSBbXCJUcmlhbCBEZXZlbG9wZXJcIiwgXCJEZXZlbG9wZXJcIiwgXCJEZXZlbG9wZXIgU3Vic2NyaXB0aW9uXCJdO1xuICAgIHJldHVybiBkZXZTdWJzY3JpcHRpb25UeXBlcy5pbmNsdWRlcyhzdWJzY3JpcHRpb25JbmZvID09PSBudWxsIHx8IHN1YnNjcmlwdGlvbkluZm8gPT09IHZvaWQgMCA/IHZvaWQgMCA6IHN1YnNjcmlwdGlvbkluZm8udHlwZSk7XG59XG5mdW5jdGlvbiBpc09yZ0FkbWluKHVzZXIpIHtcbiAgICByZXR1cm4gZ2V0VXNlclJvbGUodXNlcikgPT09IFwib3JnX2FkbWluXCIgfHwgZ2V0VXNlclJvbGUodXNlcikgPT09IFwiYWNjb3VudF9hZG1pblwiO1xufVxuZnVuY3Rpb24gaXNPcmdVc2VyKHVzZXIpIHtcbiAgICByZXR1cm4gZ2V0VXNlclJvbGUodXNlcikgPT09IFwib3JnX3VzZXJcIiB8fCBnZXRVc2VyUm9sZSh1c2VyKSA9PT0gXCJhY2NvdW50X3VzZXJcIjtcbn1cbmZ1bmN0aW9uIGlzQ3VzdG9tUm9sZSh1c2VyKSB7XG4gICAgLy8gVGhlIEhvbWUgQXBwIGNvbGxhcHNlIHRoZSBgcm9sZUlkYCBhbmQgYHJvbGVgIGludG8gYSBzaW5nbGUgYGlkYCBwcm9wZXJ0eSwgdGhhdCdzIHdoeVxuICAgIC8vICBodHRwczovL2RldnRvcGlhLmVzcmkuY29tL1dlYkdJUy9hcmNnaXMtcG9ydGFsLWFwcC9ibG9iL21hc3Rlci9zcmMvanMvYXJjZ2lzb25saW5lL3NoYXJpbmcvZGlqaXQvUm9sZS50cyNMNDY5IHdvcmtzXG4gICAgLy8gSW4gcHJhY3RpY2UsIHdlIG9ubHkgbmVlZCB0byBjaGVjayBpZiBgcm9sZUlkYCBleGlzdFxuICAgIC8vICBodHRwczovL2RldnRvcGlhLmVzcmkuY29tL1dlYkdJUy9hcmNnaXMtcG9ydGFsLWFwcC9pc3N1ZXMvNDQ2ODIjaXNzdWVjb21tZW50LTQxNDY4NjZcbiAgICByZXR1cm4gISEodXNlciA9PT0gbnVsbCB8fCB1c2VyID09PSB2b2lkIDAgPyB2b2lkIDAgOiB1c2VyLnJvbGVJZCkgJiYgdXNlci5yb2xlSWQubGVuZ3RoID4gMDtcbn1cbi8qKlxuICogQ2hlY2tzIHdoZXRoZXIgdGhlIHByaXZpbGVnZSBcInBvcnRhbDphZG1pbjp1cGRhdGVJdGVtQ2F0ZWdvcnlTY2hlbWFcIiBpcyBncmFudGVkLlxuICovXG5mdW5jdGlvbiBjYW5VcGRhdGVJdGVtQ2F0ZWdvcmllcyh1c2VyKSB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiAhISgoX2EgPSB1c2VyID09PSBudWxsIHx8IHVzZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHVzZXIucHJpdmlsZWdlcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmluY2x1ZGVzKFwicG9ydGFsOmFkbWluOnVwZGF0ZUl0ZW1DYXRlZ29yeVNjaGVtYVwiKSk7XG59XG4vKipcbiAqIENoZWNrcyB3aGV0aGVyIHRoZSBwcml2aWxlZ2UgXCJwb3J0YWw6YWRtaW46dXBkYXRlR3JvdXBzXCIgaXMgZ3JhbnRlZC5cbiAqL1xuZnVuY3Rpb24gY2FuVXBkYXRlT3JnR3JvdXBzKHVzZXIpIHtcbiAgICB2YXIgX2E7XG4gICAgcmV0dXJuICEhKChfYSA9IHVzZXIgPT09IG51bGwgfHwgdXNlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogdXNlci5wcml2aWxlZ2VzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaW5jbHVkZXMoXCJwb3J0YWw6YWRtaW46dXBkYXRlR3JvdXBzXCIpKTtcbn1cbi8qKlxuICogQ2hlY2tzIHdoZXRoZXIgdGhlIHVzZXIgaXMgYWxsb3dlZCB0byB1cGRhdGUgb3RoZXIgdXNlcidzIGl0ZW1zIGluIHRoZWlyIG9yZ2FuaXphdGlvbi5cbiAqL1xuZnVuY3Rpb24gY2FuVXBkYXRlT3JnSXRlbXModXNlcikge1xuICAgIHJldHVybiAoKHVzZXIgPT09IG51bGwgfHwgdXNlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogdXNlci5wcml2aWxlZ2VzKSB8fCBbXSkuaW5jbHVkZXMoXCJwb3J0YWw6YWRtaW46dXBkYXRlSXRlbXNcIik7XG59XG4vKipcbiAqIENoZWNrcyB0byBlbnN1cmUgdGhlIHBvcnRhbCBpcyBhbiBvcmdhbml6YXRpb24gcG9ydGFsXG4gKi9cbmZ1bmN0aW9uIGlzT3JnUG9ydGFsKHBvcnRhbCkge1xuICAgIHJldHVybiAhIShwb3J0YWwudXJsS2V5ICYmIHBvcnRhbC5jdXN0b21CYXNlVXJsKSB8fCAhIXBvcnRhbC5pc1BvcnRhbDtcbn1cbi8qKlxuICogQ2hlY2tzIHdoZXRoZXIgdGhlIHVzZXIgaXMgYWxsb3dlZCB0byBzaGFyZSB0aGVpciBpdGVtIHRvIGdyb3Vwc1xuICovXG5mdW5jdGlvbiBjYW5TaGFyZUl0ZW1Ub0dyb3VwKHVzZXIpIHtcbiAgICByZXR1cm4gKCh1c2VyID09PSBudWxsIHx8IHVzZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHVzZXIucHJpdmlsZWdlcykgfHwgW10pLmluY2x1ZGVzKFwicG9ydGFsOnVzZXI6c2hhcmVUb0dyb3VwXCIpO1xufVxuLyoqXG4gKiBDaGVja3Mgd2hldGhlciB0aGUgdXNlciBjYW4gc2hhcmUgYW4gaXRlbSBvbiBhIGdpdmVuIHBvcnRhbFxuICovXG5mdW5jdGlvbiBjYW5TaGFyZSh1c2VyLCBwb3J0YWwpIHtcbiAgICByZXR1cm4gKCFpc09yZ1BvcnRhbChwb3J0YWwpIHx8XG4gICAgICAgIGNhblNoYXJlSXRlbVRvR3JvdXAodXNlcikgfHxcbiAgICAgICAgY2FuU2hhcmVJdGVtVG9PcmcodXNlcikgfHxcbiAgICAgICAgKCEhcG9ydGFsLmNhblNoYXJlUHVibGljICYmIGNhblNoYXJlSXRlbVRvUHVibGljKHVzZXIpKSk7XG59XG4vKipcbiAqIENoZWNrcyB3aGV0aGVyIHRoZSB1c2VyIGlzIGFsbG93ZWQgdG8gc2hhcmUgdGhlaXIgaXRlbSBvdCB0aGUgb3JnYW5pemF0aW9uLlxuICovXG5mdW5jdGlvbiBjYW5TaGFyZUl0ZW1Ub09yZyh1c2VyKSB7XG4gICAgcmV0dXJuICgodXNlciA9PT0gbnVsbCB8fCB1c2VyID09PSB2b2lkIDAgPyB2b2lkIDAgOiB1c2VyLnByaXZpbGVnZXMpIHx8IFtdKS5pbmNsdWRlcyhcInBvcnRhbDp1c2VyOnNoYXJlVG9PcmdcIik7XG59XG4vKipcbiAqIENoZWNrcyB3aGV0aGVyIHRoZSB1c2VyIGlzIGFsbG93ZWQgdG8gc2hhcmUgdGhlaXIgaXRlbSB0byBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gY2FuU2hhcmVJdGVtVG9QdWJsaWModXNlcikge1xuICAgIHJldHVybiAoKHVzZXIgPT09IG51bGwgfHwgdXNlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogdXNlci5wcml2aWxlZ2VzKSB8fCBbXSkuaW5jbHVkZXMoXCJwb3J0YWw6dXNlcjpzaGFyZVRvUHVibGljXCIpO1xufVxuLyoqXG4gKiBDaGVja3Mgd2hldGhlciB0aGUgdXNlciBjYW4gc2hhcmUgb3RoZXIgdXNlcidzIGl0ZW1zXG4gKi9cbmZ1bmN0aW9uIGNhblNoYXJlT3RoZXJzSXRlbXNUb09yZyh1c2VyKSB7XG4gICAgcmV0dXJuICgodXNlciA9PT0gbnVsbCB8fCB1c2VyID09PSB2b2lkIDAgPyB2b2lkIDAgOiB1c2VyLnByaXZpbGVnZXMpIHx8IFtdKS5pbmNsdWRlcyhcInBvcnRhbDphZG1pbjpzaGFyZVRvT3JnXCIpO1xufVxuLyoqXG4gKiBDaGVja3Mgd2hldGhlciB0aGUgdXNlciBjYW4gc2hhcmUgb3RoZXIgdXNlcidzIGl0ZW1zXG4gKi9cbmZ1bmN0aW9uIGNhblNoYXJlT3RoZXJzSXRlbXNUb1B1YmxpYyh1c2VyKSB7XG4gICAgcmV0dXJuICgodXNlciA9PT0gbnVsbCB8fCB1c2VyID09PSB2b2lkIDAgPyB2b2lkIDAgOiB1c2VyLnByaXZpbGVnZXMpIHx8IFtdKS5pbmNsdWRlcyhcInBvcnRhbDphZG1pbjpzaGFyZVRvUHVibGljXCIpO1xufVxuLyoqXG4gKiBDaGVja3Mgd2hldGhlciB0aGUgdXNlciBjYW4gc2hhcmUgb3RoZXIgdXNlcidzIGl0ZW1zXG4gKi9cbmZ1bmN0aW9uIGFkbWluQ2FuU2hhcmVPdGhlcnNJdGVtVG9Hcm91cCh1c2VyKSB7XG4gICAgcmV0dXJuICgodXNlciA9PT0gbnVsbCB8fCB1c2VyID09PSB2b2lkIDAgPyB2b2lkIDAgOiB1c2VyLnByaXZpbGVnZXMpIHx8IFtdKS5pbmNsdWRlcyhcInBvcnRhbDphZG1pbjpzaGFyZVRvR3JvdXBcIik7XG59XG4vKipcbiAqIENoZWNrcyB3aGV0aGVyIHRoZSB1c2VyIGlzIGluIGFuIGFsbG93ZWQgb3JnYW5pemF0aW9uIGFuZCBoYXMgdGhlIHBvd2VyIHRvIG1hbmFnZSBjb2xsYWJvcmF0aW9uc1xuICovXG5mdW5jdGlvbiBjYW5NYW5hZ2VDb2xsYWJvcmF0aW9ucyhjb25maWcsIHVzZXIsIHBvcnRhbCwgc3Vic2NyaXB0aW9uSW5mbykge1xuICAgIGNvbnN0IGV4Y2x1ZGVkT3JnVHlwZXMgPSBbXCJUcmlhbFwiLCBcIlRyaWFsIFByZXNzXCIsIFwiVHJpYWwgRGV2ZWxvcGVyXCIsIFwiRGV2ZWxvcGVyIFN1YnNjcmlwdGlvblwiLCBcIkV2YWx1YXRpb25cIl07XG4gICAgY29uc3QgaXNWYWxpZE9yZ1R5cGUgPSBzdWJzY3JpcHRpb25JbmZvICYmICFleGNsdWRlZE9yZ1R5cGVzLmluY2x1ZGVzKHN1YnNjcmlwdGlvbkluZm8udHlwZSk7XG4gICAgY29uc3QgaGFzUHJpdmlsZWdlID0gKCh1c2VyID09PSBudWxsIHx8IHVzZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHVzZXIucHJpdmlsZWdlcykgfHwgW10pLmluY2x1ZGVzKFwicG9ydGFsOmFkbWluOm1hbmFnZUNvbGxhYm9yYXRpb25zXCIpO1xuICAgIHJldHVybiAhISgoY29uZmlnID09PSBudWxsIHx8IGNvbmZpZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29uZmlnLmNvbGxhYm9yYXRpb25zRW5hYmxlZCkgJiZcbiAgICAgICAgdXNlciAmJlxuICAgICAgICAoaXNPcmdBZG1pbih1c2VyKSB8fCBoYXNQcml2aWxlZ2UpICYmXG4gICAgICAgICgocG9ydGFsID09PSBudWxsIHx8IHBvcnRhbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcG9ydGFsLmlzUG9ydGFsKSB8fCBpc1ZhbGlkT3JnVHlwZSkpO1xufVxuLyoqXG4gKiBDaGVja3Mgd2hldGhlciB0aGUgdXNlciBjYW4gdmlldyBvdGhlciBvcmdhbml6YXRpb24gdXNlcnMnIGl0ZW1zXG4gKi9cbmZ1bmN0aW9uIGNhblZpZXdPcmdJdGVtcyh1c2VyKSB7XG4gICAgcmV0dXJuICgodXNlciA9PT0gbnVsbCB8fCB1c2VyID09PSB2b2lkIDAgPyB2b2lkIDAgOiB1c2VyLnByaXZpbGVnZXMpIHx8IFtdKS5pbmNsdWRlcyhcInBvcnRhbDphZG1pbjp2aWV3SXRlbXNcIik7XG59XG4vKipcbiAqIENoZWNrcyB3aGV0aGVyIHRoZSB1c2VyIGNhbiB2aWV3IG90aGVyIG9yZ2FuaXphdGlvbiB1c2VycycgaXRlbXNcbiAqL1xuZnVuY3Rpb24gY2FuVmlld090aGVyc09yZ0l0ZW1zKHVzZXIpIHtcbiAgICByZXR1cm4gISF1c2VyICYmICghaXNDdXN0b21Sb2xlKHVzZXIpIHx8IChpc0N1c3RvbVJvbGUodXNlcikgJiYgY2FuVmlld09yZ0l0ZW1zKHVzZXIpKSk7XG59XG4vLyBUT0RPOiBhZGQgdW5pdCB0ZXN0c1xuY29uc3QgaGFzQWRtaW5TaGFyZVByaXZpbGVnZSA9ICh7IGl0ZW1zLCB1c2VyLCBwb3J0YWwgfSkgPT4ge1xuICAgIGNvbnN0IGl0ZW0gPSBpdGVtc1swXTtcbiAgICAvLyBlbnRlcnByaXNlIGluY29ycmVjdGx5IHJldHVybnMgaXRlbXMgb3duZWQgYnkgXCJlc3JpX1wiIGFzIGl0ZW0gY29udHJvbCBhZG1pbiAoV2ViR0lTL2FyY2dpcy1wb3J0YWwtYXBwIzM4Njk1KVxuICAgIGNvbnN0IG93bmVyID0gaXRlbS5vd25lcjtcbiAgICBjb25zdCB3aGl0ZWxpc3RPd25lciA9IFtcImVzcmlfbGl2aW5nYXRsYXNcIl07XG4gICAgaWYgKHBvcnRhbC5pc1BvcnRhbCAmJiBvd25lciAhPT0gdXNlci51c2VybmFtZSAmJiBvd25lci5pbmNsdWRlcyhcImVzcmlfXCIpICYmICF3aGl0ZWxpc3RPd25lci5pbmNsdWRlcyhvd25lcikpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBpc093bmVyT3JBZG1pbiA9IHVzZXJJc0l0ZW1BZG1pbihpdGVtLCB1c2VyKTtcbiAgICBjb25zdCBpc0N1c3RvbSA9IGlzQ3VzdG9tUm9sZSh1c2VyKTtcbiAgICBjb25zdCBjYW5TaGFyZU9yZ0l0ZW1zID0gY2FuU2hhcmVPdGhlcnNJdGVtcyh1c2VyKTtcbiAgICBjb25zdCBjYW5VcGRhdGVBbmRTaGFyZSA9IGNhblVwZGF0ZUl0ZW0oaXRlbSwgdXNlcikgJiZcbiAgICAgICAgY2FuVXBkYXRlT3JnSXRlbXModXNlcikgJiZcbiAgICAgICAgIWlzQ3VzdG9tICYmXG4gICAgICAgIChjYW5TaGFyZSh1c2VyLCBwb3J0YWwpIHx8IGNhblNoYXJlT3RoZXJzSXRlbXModXNlcikpO1xuICAgIC8vIGlmIGl0J3MgdGhlIGl0ZW0gb3duZXIgb3IgYWRtaW4sIG9yIGN1c3RvbSBhZG1pbiB3aG8gY2FuIHNoYXJlXG4gICAgcmV0dXJuIGlzT3duZXJPckFkbWluIHx8IGNhblVwZGF0ZUFuZFNoYXJlIHx8IChpdGVtc0JlbG9uZ1RvVXNlck9yZyhpdGVtcywgdXNlcikgJiYgY2FuU2hhcmVPcmdJdGVtcyk7XG59O1xuLyoqXG4gKiBDaGVja3Mgd2hldGhlciB0aGUgdXNlciBjYW4gc2hhcmUgb3RoZXIgdXNlcidzIGl0ZW1zXG4gKi9cbmZ1bmN0aW9uIGNhblNoYXJlT3RoZXJzSXRlbXModXNlcikge1xuICAgIHJldHVybiBhZG1pbkNhblNoYXJlT3RoZXJzSXRlbVRvR3JvdXAodXNlcikgfHwgY2FuU2hhcmVPdGhlcnNJdGVtc1RvT3JnKHVzZXIpIHx8IGNhblNoYXJlT3RoZXJzSXRlbXNUb1B1YmxpYyh1c2VyKTtcbn1cblxuZXhwb3J0IHsgaXNQdWJsaWNVc2VyIGFzIGEsIGlzT3JnQWRtaW4gYXMgYiwgaXNIb3N0ZWRQb3J0YWwgYXMgYywgaXNDdXN0b21Sb2xlIGFzIGQsIGNhblVwZGF0ZU9yZ0dyb3VwcyBhcyBlLCBjYW5VcGRhdGVJdGVtQ2F0ZWdvcmllcyBhcyBmLCBjYW5NYW5hZ2VDb2xsYWJvcmF0aW9ucyBhcyBnLCBpc09yZ1VzZXIgYXMgaCwgaXNEZXZlbG9wZXIgYXMgaSwgY2FuU2hhcmVJdGVtVG9Hcm91cCBhcyBqLCBjYW5TaGFyZUl0ZW1Ub09yZyBhcyBrLCBhZG1pbkNhblNoYXJlT3RoZXJzSXRlbVRvR3JvdXAgYXMgbCwgY2FuU2hhcmVPdGhlcnNJdGVtc1RvT3JnIGFzIG0sIGNhblNoYXJlSXRlbVRvUHVibGljIGFzIG4sIGNhblNoYXJlT3RoZXJzSXRlbXNUb1B1YmxpYyBhcyBvLCBoYXNBZG1pblNoYXJlUHJpdmlsZWdlIGFzIHAsIGNhblZpZXdPdGhlcnNPcmdJdGVtcyBhcyBxIH07XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXByaXZpbGVnZXMtNWMzODJmNjEuanMubWFwIiwiLyohXG4gKiBBbGwgbWF0ZXJpYWwgY29weXJpZ2h0IEVTUkksIEFsbCBSaWdodHMgUmVzZXJ2ZWQsIHVubGVzcyBvdGhlcndpc2Ugc3BlY2lmaWVkLlxuICogdjQuMC41OFxuICovXG5pbXBvcnQgeyBoIGFzIGdldFBvcnRhbFRva2VuLCByIGFzIHJlcXVlc3QsIGcgYXMgZ2V0UmVzdEJhc2VVcmwgfSBmcm9tICcuL3BvcnRhbC1kNTE4YjU3MS5qcyc7XG5pbXBvcnQgeyBjIGFzIGNvbmZpZ1N0YXRlIH0gZnJvbSAnLi9jb25maWctNzVhZGY5NjIuanMnO1xuXG4vKiogV29yay1hcm91bmQgc2luY2UgdXNpbmcgYHJlcXVlc3RgIGRpcmVjdGx5IHdpbGwgdHJpZ2dlciB1bndhbnRlZCB0b2FzdCBvbiB0aGUgSG9tZSBBcHAgaWYgdGhlIGxheWVyIGlzIHVuYXZhaWxhYmxlICovXG5jb25zdCByZXF1ZXN0RmV0Y2ggPSBhc3luYyAodXJsLCBwb3J0YWwsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgIGNvbnN0IHsgYm9keSwgdXNlUG9zdCwgYWRkVG9rZW5NYW51YWxseSwgYXBpID0gY29uZmlnU3RhdGUgPT09IG51bGwgfHwgY29uZmlnU3RhdGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbmZpZ1N0YXRlLmFwaSwgY3VzdG9tVG9rZW4gfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgZGF0YSA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoKTtcbiAgICBpZiAoYm9keSkge1xuICAgICAgICBPYmplY3QuZW50cmllcyhib2R5KS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgZGF0YS5hcHBlbmQoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCB1cmxUb1NlbmQgPSBuZXcgVVJMKHVybCk7XG4gICAgdXJsVG9TZW5kLnNlYXJjaFBhcmFtcy5hcHBlbmQoXCJmXCIsIFwianNvblwiKTtcbiAgICBpZiAoY3VzdG9tVG9rZW4pIHtcbiAgICAgICAgdXJsVG9TZW5kLnNlYXJjaFBhcmFtcy5hcHBlbmQoXCJ0b2tlblwiLCBjdXN0b21Ub2tlbik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCB0b2tlbiA9IGFkZFRva2VuTWFudWFsbHkgPT09IGZhbHNlID8gbnVsbCA6IGF3YWl0IGdldFBvcnRhbFRva2VuKHBvcnRhbCwgYXBpKTtcbiAgICAgICAgaWYgKHRva2VuKSB7XG4gICAgICAgICAgICB1cmxUb1NlbmQuc2VhcmNoUGFyYW1zLmFwcGVuZChcInRva2VuXCIsIHRva2VuKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybFRvU2VuZC50b1N0cmluZygpLCB7XG4gICAgICAgIGJvZHk6IHVzZVBvc3QgPyBkYXRhIDogdW5kZWZpbmVkLFxuICAgICAgICBtZXRob2Q6IHVzZVBvc3QgPyBcIlBPU1RcIiA6IFwiR0VUXCJcbiAgICB9KTtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgY29uc3QgZXJyb3IgPSByZXN1bHQuZXJyb3I7XG4gICAgaWYgKGVycm9yKSB7XG4gICAgICAgIHRocm93IHR5cGVvZiBlcnJvciA9PT0gXCJzdHJpbmdcIiA/IG5ldyBFcnJvcihlcnJvcikgOiBlcnJvcjtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogU2VuZCBhIHJlcXVlc3QgdG8gZ2V0IGRhdGEgZm9yIGB1cmxgLiBUaGlzIHJlcXVlc3Qgd2lsbCBub3QgaW5jbHVkZSBhIHRva2VuIHRvIGF2b2lkIHRva2VuIGxlYWtcbiAqL1xuY29uc3QgZ2V0U2VydmljZVVybFJlc3BvbnNlID0gYXN5bmMgKHVybCwgcG9ydGFsKSA9PiB7XG4gICAgdmFyIF9hO1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiB7IHJlc3VsdDogYXdhaXQgcmVxdWVzdEZldGNoKHVybCwgcG9ydGFsLCB7IGFkZFRva2VuTWFudWFsbHk6IGZhbHNlIH0pIH07XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zdCB0b2tlblJlcXVpcmVkTWVzc2FnZSA9IFwidG9rZW4gcmVxdWlyZWRcIjtcbiAgICAgICAgaWYgKChfYSA9IGVycm9yID09PSBudWxsIHx8IGVycm9yID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlcnJvci5tZXNzYWdlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyh0b2tlblJlcXVpcmVkTWVzc2FnZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB7IGVycm9yOiB7IGNvZGU6IFwidG9rZW5SZXF1aXJlZFwiIH0gfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgICAgICAgcmV0dXJuIHsgZXJyb3I6IHsgY29kZTogXCJ1bmhhbmRsZWRFcnJvclwiIH0gfTtcbiAgICB9XG59O1xuYXN5bmMgZnVuY3Rpb24gZ2V0UmVsYXRlZEl0ZW1zKGl0ZW1JZCwgcG9ydGFsLCB7IHJlbGF0aW9uc2hpcFR5cGUsIGRpcmVjdGlvbiB9KSB7XG4gICAgY29uc3QgdXJsID0gYCR7Z2V0UmVzdEJhc2VVcmwocG9ydGFsKX1jb250ZW50L2l0ZW1zLyR7aXRlbUlkfS9yZWxhdGVkSXRlbXNgO1xuICAgIHJldHVybiBhd2FpdCByZXF1ZXN0KHVybCwgeyByZWxhdGlvbnNoaXBUeXBlLCBkaXJlY3Rpb24gfSk7XG59XG5cbmNvbnN0IGlzSG9zdGVkU2VydmljZSA9ICh0eXBlS2V5d29yZHMsIHR5cGUpID0+IHR5cGUgPT09IFwiRmVhdHVyZSBTZXJ2aWNlXCIgJiYgdHlwZUtleXdvcmRzLmluY2x1ZGVzKFwiSG9zdGVkIFNlcnZpY2VcIik7XG5cbmV4cG9ydCB7IGdldFNlcnZpY2VVcmxSZXNwb25zZSBhcyBhLCBnZXRSZWxhdGVkSXRlbXMgYXMgZywgaXNIb3N0ZWRTZXJ2aWNlIGFzIGksIHJlcXVlc3RGZXRjaCBhcyByIH07XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNlcnZpY2UtOGMyYzQyNDEuanMubWFwIiwiLyohXG4gKiBBbGwgbWF0ZXJpYWwgY29weXJpZ2h0IEVTUkksIEFsbCBSaWdodHMgUmVzZXJ2ZWQsIHVubGVzcyBvdGhlcndpc2Ugc3BlY2lmaWVkLlxuICogdjQuMC41OFxuICovXG5pbXBvcnQgeyBnIGFzIGdldEl0ZW1VcmwgfSBmcm9tICcuL3NlcnZlci1pdGVtLThkMzg0Nzk2LmpzJztcbmltcG9ydCB7IGcgYXMgZ2V0UmVzdEJhc2VVcmwsIHIgYXMgcmVxdWVzdCwgZiBhcyBmcm9tQ2FjaGUsIGEgYXMgZ2V0UG9ydGFsUmVzdEluZm8sIGIgYXMgZ2V0UG9ydGFsUmVzdEluZm9Gcm9tVXJsLCBjIGFzIGNsZWFyQ2FjaGUgfSBmcm9tICcuL3BvcnRhbC1kNTE4YjU3MS5qcyc7XG5pbXBvcnQgeyBpIGFzIGlzT3duZXIsIGEgYXMgaXNTdWJzY3JpYmVyLCBiIGFzIGlzUHJlbWl1bSB9IGZyb20gJy4vaXRlbS0zNTM1NTUyZC5qcyc7XG5pbXBvcnQgeyByIGFzIHJlcXVlc3RGZXRjaCwgZyBhcyBnZXRSZWxhdGVkSXRlbXMsIGEgYXMgZ2V0U2VydmljZVVybFJlc3BvbnNlLCBpIGFzIGlzSG9zdGVkU2VydmljZSB9IGZyb20gJy4vc2VydmljZS04YzJjNDI0MS5qcyc7XG5pbXBvcnQgeyBhIGFzIGFycmF5VG9Mb29rdXBNYXAsIHUgYXMgdW5pcXVlQnkgfSBmcm9tICcuL2Z1bmN0aW9uYWwtNDRkZThmY2YuanMnO1xuaW1wb3J0IHsgaSBhcyBpc0RldmVsb3BlciB9IGZyb20gJy4vcHJpdmlsZWdlcy01YzM4MmY2MS5qcyc7XG5pbXBvcnQgeyBnIGFzIGdldEl0ZW1EYXRhLCBhIGFzIGdldEh5ZHJhdGVkSXRlbSwgYiBhcyBnZXRJdGVtRGF0YVVybCwgYyBhcyBnZXRJdGVtLCBkIGFzIGdldEl0ZW1Hcm91cHMsIGkgYXMgaXNFZGl0YWJsZUl0ZW0gfSBmcm9tICcuL2l0ZW0tYzU4ZmZjZWQuanMnO1xuaW1wb3J0IHsgcCBhcyBwYXJzZUFHU1NlcnZlckluZm8gfSBmcm9tICcuL3VybC00YzNhZTU0Yy5qcyc7XG5cbi8qKlxuICogU2hhcmUgaXRlbXMgdG8gdGhlIHNwZWNpZmllZCBncm91cHMgd2l0aCB0aGUgc3BlY2lmaWVkIGFjY2VzcyBsZXZlbFxuICpcbiAqIE5vdGU6IGByZXF1ZXN0YCB3aWxsIHRvYXN0IGFuIGVycm9yIG9uIHRoZSBIb21lIGFwcCBgdXNlRmV0Y2hSZXF1ZXN0YCBpcyBhIHdvcmthcm91bmQuIFRPRE86IHJlbW92ZSB0aGlzIG9uY2Ugd2UgaGF2ZSBhIGJldHRlciB3YXlcbiAqXG4gKiAqL1xuY29uc3Qgc2hhcmVJdGVtcyA9IGFzeW5jIChpdGVtcywgc2hhcmVMZXZlbCwgZ3JvdXBJZHMsIGNvbmZpZywgdXNlRmV0Y2hSZXF1ZXN0ID0gZmFsc2UpID0+IHtcbiAgICBjb25zdCB7IHBvcnRhbCwgdXNlciB9ID0gY29uZmlnO1xuICAgIGNvbnN0IHVybCA9IGAke2dldFJlc3RCYXNlVXJsKHBvcnRhbCl9Y29udGVudC91c2Vycy8ke3VzZXIudXNlcm5hbWV9L3NoYXJlSXRlbXNgO1xuICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICBjb25zdCBzaGFyZUxldmVsT3B0aW9ucyA9IHNoYXJlTGV2ZWwgPyB0b1NoYXJlTGV2ZWxPcHRpb25zKHNoYXJlTGV2ZWwpIDoge307XG4gICAgaWYgKGl0ZW1zLmV2ZXJ5KChpdGVtKSA9PiBpc093bmVyKGl0ZW0sIHVzZXIpKSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVzdWx0ID0gKGF3YWl0IHJlcXVlc3RGZXRjaCh1cmwsIHBvcnRhbCwge1xuICAgICAgICAgICAgICAgIGJvZHk6IE9iamVjdC5hc3NpZ24oeyBpdGVtczogaXRlbXMubWFwKChpdGVtKSA9PiBpdGVtLmlkKS5qb2luKFwiLFwiKSwgZ3JvdXBzOiAoZ3JvdXBJZHMgPT09IG51bGwgfHwgZ3JvdXBJZHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGdyb3VwSWRzLmxlbmd0aCkgPyBncm91cElkcy5qb2luKFwiLFwiKSA6IHVuZGVmaW5lZCwgY29uZmlybUl0ZW1Db250cm9sOiB0cnVlIH0sIHNoYXJlTGV2ZWxPcHRpb25zKSxcbiAgICAgICAgICAgICAgICB1c2VQb3N0OiB0cnVlXG4gICAgICAgICAgICB9KSkucmVzdWx0cztcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgcmV0dXJuIHsgZXJyb3I6IHsgY29kZTogXCJ1bmhhbmRsZWRFcnJvclwiIH0gfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gVE9ETzogaGFpciBzcGxpdHRpbmcgZXJyb3IgaGVyZVxuICAgICAgICByZXN1bHQgPSAoYXdhaXQgUHJvbWlzZS5hbGwoaXRlbXMubWFwKCh7IGlkIH0pID0+IHNoYXJlSXRlbShpZCwgc2hhcmVMZXZlbE9wdGlvbnMsIGdyb3VwSWRzLCBwb3J0YWwsIHVzZUZldGNoUmVxdWVzdCkpKSkubWFwKChyZXNwb25zZSkgPT4gcmVzcG9uc2UucmVzdWx0KTtcbiAgICB9XG4gICAgcmV0dXJuIHsgcmVzdWx0IH07XG59O1xuY29uc3QgdW5zaGFyZUl0ZW1zID0gYXN5bmMgKGl0ZW1JZHMsIGdyb3VwSWRzLCBjb25maWcpID0+IHtcbiAgICBjb25zdCB7IHBvcnRhbCwgdXNlciB9ID0gY29uZmlnO1xuICAgIGNvbnN0IHVybCA9IGAke2dldFJlc3RCYXNlVXJsKHBvcnRhbCl9Y29udGVudC91c2Vycy8ke3VzZXIudXNlcm5hbWV9L3Vuc2hhcmVJdGVtc2A7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gKGF3YWl0IHJlcXVlc3RGZXRjaCh1cmwsIHBvcnRhbCwge1xuICAgICAgICAgICAgYm9keTogeyBpdGVtczogaXRlbUlkcy5qb2luKFwiLFwiKSwgZ3JvdXBzOiAoZ3JvdXBJZHMgPT09IG51bGwgfHwgZ3JvdXBJZHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGdyb3VwSWRzLmxlbmd0aCkgPyBncm91cElkcy5qb2luKFwiLFwiKSA6IG51bGwgfSxcbiAgICAgICAgICAgIHVzZVBvc3Q6IHRydWVcbiAgICAgICAgfSkpLnJlc3VsdHM7XG4gICAgICAgIHJldHVybiB7IHJlc3VsdCB9O1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gICAgICAgIHJldHVybiB7IGVycm9yOiB7IGNvZGU6IFwidW5oYW5kbGVkRXJyb3JcIiB9IH07XG4gICAgfVxufTtcbi8qKlxuICogU2hhcmUgc2luZ2xlIGl0ZW0gdG8gdGhlIHNwZWNpZmllZCBncm91cHMgd2l0aCB0aGUgc3BlY2lmaWVkIGFjY2VzcyBsZXZlbFxuICpcbiAqIE5vdGU6IGByZXF1ZXN0YCB3aWxsIHRvYXN0IGFuIGVycm9yIG9uIHRoZSBIb21lIGFwcCBgdXNlRmV0Y2hSZXF1ZXN0YCBpcyBhIHdvcmthcm91bmQuIFRPRE86IHJlbW92ZSB0aGlzIG9uY2Ugd2UgaGF2ZSBhIGJldHRlciB3YXlcbiAqXG4gKiAqL1xuYXN5bmMgZnVuY3Rpb24gc2hhcmVJdGVtKGl0ZW1JZCwgc2hhcmVMZXZlbE9wdGlvbnMsIGdyb3VwcywgcG9ydGFsLCB1c2VGZXRjaFJlcXVlc3QgPSBmYWxzZSkge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHVybCA9IGAke2dldEl0ZW1VcmwoaXRlbUlkLCBwb3J0YWwpfS9zaGFyZWA7XG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IE9iamVjdC5hc3NpZ24oeyBncm91cHM6IChncm91cHMgPT09IG51bGwgfHwgZ3JvdXBzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBncm91cHMubGVuZ3RoKSA/IGdyb3Vwcy5qb2luKFwiLFwiKSA6IG51bGwsIGNvbmZpcm1JdGVtQ29udHJvbDogdHJ1ZSB9LCBzaGFyZUxldmVsT3B0aW9ucyk7XG4gICAgICAgIGxldCByZXN1bHQ7XG4gICAgICAgIGlmICh1c2VGZXRjaFJlcXVlc3QpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGF3YWl0IHJlcXVlc3RGZXRjaCh1cmwsIHBvcnRhbCwgeyBib2R5OiBwYXJhbXMsIHVzZVBvc3Q6IHRydWUgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgPSBhd2FpdCByZXF1ZXN0KHVybCwgcGFyYW1zLCB7fSwgXCJwb3N0XCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHJlc3VsdCB9O1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gICAgICAgIHJldHVybiB7IGVycm9yOiB7IGNvZGU6IFwidW5oYW5kbGVkRXJyb3JcIiB9IH07XG4gICAgfVxufVxuZnVuY3Rpb24gdG9TaGFyZUxldmVsT3B0aW9ucyhzaGFyZUxldmVsKSB7XG4gICAgc3dpdGNoIChzaGFyZUxldmVsKSB7XG4gICAgICAgIGNhc2UgXCJwdWJsaWNcIjpcbiAgICAgICAgICAgIHJldHVybiB7IG9yZzogZmFsc2UsIGV2ZXJ5b25lOiB0cnVlIH07XG4gICAgICAgIGNhc2UgXCJvcmdcIjpcbiAgICAgICAgICAgIHJldHVybiB7IG9yZzogdHJ1ZSwgZXZlcnlvbmU6IGZhbHNlIH07XG4gICAgICAgIGNhc2UgXCJwcml2YXRlXCI6XG4gICAgICAgICAgICByZXR1cm4geyBvcmc6IGZhbHNlLCBldmVyeW9uZTogZmFsc2UgfTtcbiAgICAgICAgY2FzZSBcInNoYXJlZFwiOlxuICAgICAgICAgICAgcmV0dXJuIHsgb3JnOiBmYWxzZSwgZXZlcnlvbmU6IGZhbHNlIH07XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4ge307XG4gICAgfVxufVxuXG4vLyBkaXNhYmxlIHB1YmxpYyBzaGFyaW5nIG9mIGNlcnRhaW4gaXRlbXNcbi8vIFdlYkdJUy9hcmNnaXMtcG9ydGFsLWFwcCMyNjU5MSwgV2ViR0lTL2FyY2dpcy1wb3J0YWwtYXBwIzI2OTg3LCBXZWJHSVMvYXJjZ2lzLXBvcnRhbC1hcHAjMzA1MTdcbi8vIFdlYkdJUy9hcmNnaXMtcG9ydGFsLWFwcCMzNTkyNCwgV2ViR0lTL2FyY2dpcy1wb3J0YWwtYXBwIzM2ODM1XG5mdW5jdGlvbiBpc0Jsb2NrZWRGcm9tU2hhcmluZ1RvUHVibGljKGl0ZW0pIHtcbiAgICBjb25zdCB7IHR5cGVLZXl3b3JkcywgdHlwZSwgdXJsIH0gPSBpdGVtO1xuICAgIGNvbnN0IGhhc05vblNoYXJlYWJsZUtleXdvcmQgPSB0eXBlS2V5d29yZHMgJiYgbm9uUHVibGljbHlTaGFyZWFibGVLZXl3b3Jkcy5zb21lKChrZXl3b3JkKSA9PiB0eXBlS2V5d29yZHMuaW5jbHVkZXMoa2V5d29yZCkpO1xuICAgIC8vICEgTm8gbmVlZCB0byBjaGVjayBmb3IgcG9ydGFsLmlzUG9ydGFsIGhlcmUgYXMgdGhhdCB1cmwgdHlwZSBpcyBvbmx5IGluIEFyY0dJUyBPbmxpbmVcbiAgICBjb25zdCBpc09ubGluZUR5bmFtaWNJbWFnZXJ5U2VydmljZSA9IHR5cGUgPT09IFwiSW1hZ2UgU2VydmljZVwiICYmICh1cmwgPT09IG51bGwgfHwgdXJsID09PSB2b2lkIDAgPyB2b2lkIDAgOiB1cmwuaW5jbHVkZXMoXCI6Ly9pc2VydmljZXNcIikpICYmIHVybC5pbmNsdWRlcyhcImFyY2dpcy5jb21cIik7XG4gICAgY29uc3QgaXNOb25TaGFyZWFibGVUeXBlID0gbm9uUHVibGljbHlTaGFyZWFibGVUeXBlcy5pbmNsdWRlcyh0eXBlKTtcbiAgICByZXR1cm4gaGFzTm9uU2hhcmVhYmxlS2V5d29yZCB8fCBpc09ubGluZUR5bmFtaWNJbWFnZXJ5U2VydmljZSB8fCBpc05vblNoYXJlYWJsZVR5cGU7XG59XG5mdW5jdGlvbiBpc0Jsb2NrZWRGcm9tRGV2ZWxvcGVyU2hhcmluZ1RvUHVibGljKGl0ZW0pIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgaXNIb3N0ZWQgPSAoX2EgPSBpdGVtLnR5cGVLZXl3b3JkcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmluY2x1ZGVzKFwiSG9zdGVkIFNlcnZpY2VcIik7XG4gICAgY29uc3QgYmxhY2tMaXN0VHlwZXMgPSBbXG4gICAgICAgIFwiVmVjdG9yIFRpbGUgU2VydmljZVwiLFxuICAgICAgICBcIk1hcCBTZXJ2aWNlXCIsXG4gICAgICAgIFwiU2NlbmUgU2VydmljZVwiLFxuICAgICAgICBcIkZlYXR1cmUgU2VydmljZVwiXG4gICAgXTtcbiAgICByZXR1cm4gYmxhY2tMaXN0VHlwZXMuaW5jbHVkZXMoaXRlbS50eXBlKSAmJiBpc0hvc3RlZDtcbn1cbmNvbnN0IG5vblB1YmxpY2x5U2hhcmVhYmxlS2V5d29yZHMgPSBbXG4gICAgXCJMb2NhdGlvbiBUcmFja2luZyBTZXJ2aWNlXCIsXG4gICAgXCJMb2NhdGlvbiBUcmFja2luZyBWaWV3XCIsXG4gICAgXCJJb1RGZWVkXCIsXG4gICAgXCJJb1RGZWF0dXJlTGF5ZXJcIixcbiAgICBcIklvVE1hcEltYWdlTGF5ZXJcIixcbiAgICBcIklvVFN0cmVhbUxheWVyXCIsXG4gICAgXCJBZG1pbmlzdHJhdGl2ZSBSZXBvcnRcIixcbiAgICBcIkVkaXRFeHRlbnNpb25JbmRvb3JzU3BhY2VzXCIsXG4gICAgXCJBcmNnaXNXb3JrZmxvd0pvYkxvY2F0aW9uXCJcbl07XG5jb25zdCBub25QdWJsaWNseVNoYXJlYWJsZVR5cGVzID0gW1wiS25vd2xlZGdlIEdyYXBoXCIsIFwiUHJvIFByb2plY3RcIl07XG5cbi8vICogLS0tIERlcGVuZGVudCBpdGVtIGxheWVyc1xuY29uc3QgZ2V0RGVwZW5kZW50SXRlbUxheWVycyA9IGFzeW5jIChtYWluSXRlbSwgcG9ydGFsKSA9PiB7XG4gICAgY29uc3QgaWQgPSBtYWluSXRlbS5pZDtcbiAgICBsZXQgZ2V0RGF0YUVycm9yO1xuICAgIGxldCBpdGVtc0FuZExheWVycyA9IHsgaXRlbXM6IFtdLCBsYXllcnM6IFtdIH07XG4gICAgc3dpdGNoIChtYWluSXRlbS50eXBlKSB7XG4gICAgICAgIGNhc2UgXCJHcm91cCBMYXllclwiOlxuICAgICAgICAgICAgKHsgcmVzdWx0OiBpdGVtc0FuZExheWVycywgZXJyb3I6IGdldERhdGFFcnJvciB9ID0gYXdhaXQgZ2V0R3JvdXBMYXllckRlcGVuZGVudEl0ZW1MYXllcnMoaWQsIHBvcnRhbCkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJXZWIgTWFwXCI6XG4gICAgICAgIGNhc2UgXCJXZWIgU2NlbmVcIjpcbiAgICAgICAgICAgICh7IHJlc3VsdDogaXRlbXNBbmRMYXllcnMsIGVycm9yOiBnZXREYXRhRXJyb3IgfSA9IGF3YWl0IGdldFdlYk1hcERlcGVuZGVudEl0ZW1MYXllcnMoaWQsIHBvcnRhbCkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJXZWIgTWFwcGluZyBBcHBsaWNhdGlvblwiOlxuICAgICAgICAgICAgKHsgcmVzdWx0OiBpdGVtc0FuZExheWVycywgZXJyb3I6IGdldERhdGFFcnJvciB9ID0gYXdhaXQgZ2V0V2ViQXBwRGVwZW5kZW50SXRlbUxheWVycyhpZCwgcG9ydGFsKSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIldlYiBFeHBlcmllbmNlXCI6XG4gICAgICAgIGNhc2UgXCJXZWIgRXhwZXJpZW5jZSBUZW1wbGF0ZVwiOlxuICAgICAgICAgICAgKHsgcmVzdWx0OiBpdGVtc0FuZExheWVycywgZXJyb3I6IGdldERhdGFFcnJvciB9ID0gYXdhaXQgZ2V0V2ViRXhwZXJpZW5jZURlcGVuZGVudEl0ZW1MYXllcnMoaWQsIG1haW5JdGVtLnR5cGVLZXl3b3JkcywgcG9ydGFsKSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIkJpZyBEYXRhIEZpbGUgU2hhcmVcIjpcbiAgICAgICAgICAgICh7IHJlc3VsdDogaXRlbXNBbmRMYXllcnMsIGVycm9yOiBnZXREYXRhRXJyb3IgfSA9IGF3YWl0IGdldEJERlNEZXBlbmRlbnRJdGVtcyhtYWluSXRlbSwgcG9ydGFsKSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIkRhdGEgU3RvcmVcIjpcbiAgICAgICAgICAgICh7IHJlc3VsdDogaXRlbXNBbmRMYXllcnMsIGVycm9yOiBnZXREYXRhRXJyb3IgfSA9IGF3YWl0IGdldENsb3VkRGF0YVN0b3JlRGVwZW5kZW50SXRlbXMobWFpbkl0ZW0sIHBvcnRhbCkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiB7IHJlc3VsdDogaXRlbXNBbmRMYXllcnMsIGVycm9yOiBnZXREYXRhRXJyb3IgfTtcbn07XG4vLyAqIC0tLSBHcm91cCBsYXllclxuY29uc3QgZ2V0R3JvdXBMYXllckRlcGVuZGVudEl0ZW1MYXllcnMgPSBhc3luYyAoaXRlbUlkLCBwb3J0YWwpID0+IHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBpdGVtRGF0YSA9IGF3YWl0IGdldEl0ZW1EYXRhKGl0ZW1JZCwgcG9ydGFsKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJlc3VsdDoge1xuICAgICAgICAgICAgICAgIGl0ZW1zOiBbXSxcbiAgICAgICAgICAgICAgICBsYXllcnM6IFtPYmplY3QuYXNzaWduKHt9LCBpdGVtRGF0YSldXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAvLyBUT0RPOiBoYW5kbGUgbW9yZSBlcnJvclxuICAgICAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgICAgICAgcmV0dXJuIHsgZXJyb3I6IHsgY29kZTogXCJ1bmhhbmRsZWRFcnJvclwiIH0gfTtcbiAgICB9XG59O1xuLy8gKiAtLS0gV2ViIG1hcFxuY29uc3QgZ2V0V2ViTWFwRGVwZW5kZW50SXRlbUxheWVycyA9IGFzeW5jIChpdGVtSWQsIHBvcnRhbCkgPT4ge1xuICAgIHZhciBfYSwgX2I7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgaXRlbURhdGEgPSBhd2FpdCBnZXRJdGVtRGF0YShpdGVtSWQsIHBvcnRhbCk7XG4gICAgICAgIGNvbnN0IHsgb3BlcmF0aW9uYWxMYXllcnMsIGJhc2VNYXAsIHRhYmxlcywgZ3JvdW5kIH0gPSBpdGVtRGF0YTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJlc3VsdDoge1xuICAgICAgICAgICAgICAgIGl0ZW1zOiBbXSxcbiAgICAgICAgICAgICAgICBsYXllcnM6IFtcbiAgICAgICAgICAgICAgICAgICAgLi4uKG9wZXJhdGlvbmFsTGF5ZXJzICE9PSBudWxsICYmIG9wZXJhdGlvbmFsTGF5ZXJzICE9PSB2b2lkIDAgPyBvcGVyYXRpb25hbExheWVycyA6IFtdKSxcbiAgICAgICAgICAgICAgICAgICAgLi4uKChfYSA9IGJhc2VNYXAgPT09IG51bGwgfHwgYmFzZU1hcCA9PT0gdm9pZCAwID8gdm9pZCAwIDogYmFzZU1hcC5iYXNlTWFwTGF5ZXJzKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBbXSksXG4gICAgICAgICAgICAgICAgICAgIC4uLigoX2IgPSBncm91bmQgPT09IG51bGwgfHwgZ3JvdW5kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBncm91bmQubGF5ZXJzKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBbXSksXG4gICAgICAgICAgICAgICAgICAgIC4uLih0YWJsZXMgIT09IG51bGwgJiYgdGFibGVzICE9PSB2b2lkIDAgPyB0YWJsZXMgOiBbXSlcbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAvLyBUT0RPOiBoYW5kbGUgbW9yZSBlcnJvclxuICAgICAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgICAgICAgcmV0dXJuIHsgZXJyb3I6IHsgY29kZTogXCJ1bmhhbmRsZWRFcnJvclwiIH0gfTtcbiAgICB9XG59O1xuLy8gKiAtLS0gV2ViIGFwcFxuY29uc3QgZ2V0V2ViQXBwRGVwZW5kZW50SXRlbUxheWVycyA9IGFzeW5jIChpdGVtSWQsIHBvcnRhbCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGl0ZW1EYXRhID0gYXdhaXQgZ2V0SXRlbURhdGEoaXRlbUlkLCBwb3J0YWwpO1xuICAgICAgICBpZiAoIWl0ZW1EYXRhKSB7XG4gICAgICAgICAgICByZXR1cm4geyByZXN1bHQ6IHsgaXRlbXM6IFtdLCBsYXllcnM6IFtdIH0gfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB3ZWJBcHBNYXBMaXN0ID0gZ2V0V2ViQXBwTWFwTGlzdChpdGVtRGF0YSk7XG4gICAgICAgIGNvbnN0IGRlcGVuZGVudEl0ZW1zID0gKGF3YWl0IFByb21pc2UuYWxsKHdlYkFwcE1hcExpc3QubWFwKChpdGVtSWQpID0+IGdldEh5ZHJhdGVkSXRlbShpdGVtSWQsIHBvcnRhbCkpKSlcbiAgICAgICAgICAgIC8vIFRPRE86IGhhbmRsZSBlcnJvcnNcbiAgICAgICAgICAgIC5tYXAoKHsgcmVzdWx0IH0pID0+IHJlc3VsdClcbiAgICAgICAgICAgIC5maWx0ZXIoKGl0ZW0pID0+IGl0ZW0pO1xuICAgICAgICBjb25zdCBkZXBlbmRlbnRJdGVtTGF5ZXJzID0gYXdhaXQgUHJvbWlzZS5hbGwoZGVwZW5kZW50SXRlbXMubWFwKChpdGVtKSA9PiBnZXREZXBlbmRlbnRJdGVtTGF5ZXJzKGl0ZW0sIHBvcnRhbCkpKTtcbiAgICAgICAgY29uc3QgeyBpdGVtcywgbGF5ZXJzIH0gPSBmbGF0dGVuRGVwZW5kZW50SXRlbXNBbmRMYXllclJlc3BvbnNlKGRlcGVuZGVudEl0ZW1MYXllcnNcbiAgICAgICAgICAgIC5tYXAoKHsgcmVzdWx0IH0pID0+IHJlc3VsdClcbiAgICAgICAgICAgIC5mbGF0KClcbiAgICAgICAgICAgIC5maWx0ZXIoKHJlc3VsdCkgPT4gcmVzdWx0KSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAvLyBXZWIgbWFwIGFwcGxpY2F0aW9uIGRvZXNuJ3QgaGF2ZSBhbnkgbGF5ZXJzIHNvIHdlIG9ubHkgcmV0dXJuIHRoZSBsYXllcnMgZnJvbSBkZXAgaXRlbXNcbiAgICAgICAgICAgIHJlc3VsdDogeyBpdGVtczogWy4uLmRlcGVuZGVudEl0ZW1zLCAuLi5pdGVtc10sIGxheWVycyB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAvLyBUT0RPOiBoYW5kbGUgbW9yZSBlcnJvclxuICAgICAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgICAgICAgcmV0dXJuIHsgZXJyb3I6IHsgY29kZTogXCJ1bmhhbmRsZWRFcnJvclwiIH0gfTtcbiAgICB9XG59O1xuY29uc3QgZ2V0V2ViQXBwTWFwTGlzdCA9IChhcHBEYXRhKSA9PiB7XG4gICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2YsIF9nLCBfaCwgX2osIF9rO1xuICAgIGNvbnN0IGl0ZW1zID0gKChfYSA9IGFwcERhdGEgPT09IG51bGwgfHwgYXBwRGF0YSA9PT0gdm9pZCAwID8gdm9pZCAwIDogYXBwRGF0YS5tYXApID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5pdGVtSWQpID8gW2FwcERhdGEubWFwLml0ZW1JZF0gOiBbXTtcbiAgICBjb25zdCBwb3J0Zm9saW9Db2xsZWN0aW9uID0gKF9kID0gKF9jID0gKF9iID0gYXBwRGF0YS52YWx1ZXMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5pdGVtQ29sbGVjdGlvbikgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLm1hcCgoZWwpID0+IGVsLmlkKSkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogW107XG4gICAgY29uc3QgbWFwcyA9IChfZyA9IChfZiA9IChfZSA9IGFwcERhdGEudmFsdWVzKSA9PT0gbnVsbCB8fCBfZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Uud2VibWFwKSA9PT0gbnVsbCB8fCBfZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Yuc3BsaXQoXCIsXCIpKSAhPT0gbnVsbCAmJiBfZyAhPT0gdm9pZCAwID8gX2cgOiBbXTtcbiAgICBjb25zdCBzY2VuZXMgPSAoX2sgPSAoX2ogPSAoX2ggPSBhcHBEYXRhLnZhbHVlcykgPT09IG51bGwgfHwgX2ggPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9oLndlYnNjZW5lKSA9PT0gbnVsbCB8fCBfaiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2ouc3BsaXQoXCIsXCIpKSAhPT0gbnVsbCAmJiBfayAhPT0gdm9pZCAwID8gX2sgOiBbXTtcbiAgICByZXR1cm4gWy4uLml0ZW1zLCAuLi5wb3J0Zm9saW9Db2xsZWN0aW9uLCAuLi5tYXBzLCAuLi5zY2VuZXNdO1xufTtcbi8vICogLS0tIFdlYiBleHBlcmllbmNlXG5jb25zdCBnZXRXZWJFeHBlcmllbmNlRGVwZW5kZW50SXRlbUxheWVycyA9IGFzeW5jIChpdGVtSWQsIHR5cGVLZXl3b3JkcywgcG9ydGFsKSA9PiB7XG4gICAgY29uc3QgZHJhZnRVcmwgPSBgJHtnZXRJdGVtVXJsKGl0ZW1JZCwgcG9ydGFsKX0vcmVzb3VyY2VzL2NvbmZpZy9jb25maWcuanNvbmA7XG4gICAgY29uc3QgaXRlbURhdGFVcmwgPSBnZXRJdGVtRGF0YVVybChpdGVtSWQsIHBvcnRhbCk7XG4gICAgY29uc3QgZGF0YVVybHMgPSBbXTtcbiAgICBpZiAodHlwZUtleXdvcmRzLmluY2x1ZGVzKFwic3RhdHVzOiBEcmFmdFwiKSkge1xuICAgICAgICBkYXRhVXJscy5wdXNoKGRyYWZ0VXJsKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZUtleXdvcmRzLmluY2x1ZGVzKFwic3RhdHVzOiBDaGFuZ2VkXCIpKSB7XG4gICAgICAgIGRhdGFVcmxzLnB1c2goZHJhZnRVcmwsIGl0ZW1EYXRhVXJsKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGRhdGFVcmxzLnB1c2goaXRlbURhdGFVcmwpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBjb25zdCBhbGxJdGVtcyA9IFtdO1xuICAgICAgICBjb25zdCBhbGxEZXBlbmRlbnRJdGVtcyA9IFtdO1xuICAgICAgICBjb25zdCBhbGxMYXllcnMgPSBbXTtcbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoZGF0YVVybHMubWFwKGFzeW5jIChkYXRhVXJsKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBpdGVtRGF0YSA9IGF3YWl0IHJlcXVlc3RGZXRjaChkYXRhVXJsLCBwb3J0YWwpO1xuICAgICAgICAgICAgaWYgKCEoaXRlbURhdGEgPT09IG51bGwgfHwgaXRlbURhdGEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGl0ZW1EYXRhLmRhdGFTb3VyY2VzKSAmJiAhKGl0ZW1EYXRhID09PSBudWxsIHx8IGl0ZW1EYXRhID09PSB2b2lkIDAgPyB2b2lkIDAgOiBpdGVtRGF0YS51dGlsaXRpZXMpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZGVwZW5kZW50SXRlbXMgPSAoYXdhaXQgUHJvbWlzZS5hbGwoZ2V0V2ViRXhwZXJpZW5jZURlcGVuZGVuY3lJZExpc3QoaXRlbURhdGEpLm1hcCgoaXRlbUlkKSA9PiBnZXRIeWRyYXRlZEl0ZW0oaXRlbUlkLCBwb3J0YWwpKSkpIC8vIFRPRE86IGhhbmRsZSBlcnJvcnNcbiAgICAgICAgICAgICAgICAubWFwKCh7IHJlc3VsdCB9KSA9PiByZXN1bHQpXG4gICAgICAgICAgICAgICAgLmZpbHRlcigoaXRlbSkgPT4gaXRlbSk7XG4gICAgICAgICAgICBjb25zdCBkZXBlbmRlbnRJdGVtTGF5ZXJzID0gYXdhaXQgUHJvbWlzZS5hbGwoZGVwZW5kZW50SXRlbXMubWFwKChpdGVtKSA9PiBnZXREZXBlbmRlbnRJdGVtTGF5ZXJzKGl0ZW0sIHBvcnRhbCkpKTtcbiAgICAgICAgICAgIGNvbnN0IHsgaXRlbXMsIGxheWVycyB9ID0gZmxhdHRlbkRlcGVuZGVudEl0ZW1zQW5kTGF5ZXJSZXNwb25zZShkZXBlbmRlbnRJdGVtTGF5ZXJzLmZsYXRNYXAoKHsgcmVzdWx0IH0pID0+IHJlc3VsdCkuZmlsdGVyKChsYXllcikgPT4gbGF5ZXIpKTtcbiAgICAgICAgICAgIGFsbExheWVycy5wdXNoKC4uLmxheWVycyk7XG4gICAgICAgICAgICBhbGxJdGVtcy5wdXNoKC4uLml0ZW1zKTtcbiAgICAgICAgICAgIGFsbERlcGVuZGVudEl0ZW1zLnB1c2goLi4uZGVwZW5kZW50SXRlbXMpO1xuICAgICAgICB9KSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAvLyBXZWIgZXhwZXJpZW5jZSBkb2Vzbid0IGhhdmUgYW55IGxheWVycyBzbyB3ZSBvbmx5IHJldHVybiB0aGUgbGF5ZXJzIGZyb20gZGVwIGl0ZW1zXG4gICAgICAgICAgICByZXN1bHQ6IHsgaXRlbXM6IFsuLi5hbGxEZXBlbmRlbnRJdGVtcywgLi4uYWxsSXRlbXNdLCBsYXllcnM6IGFsbExheWVycyB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAvLyBUT0RPOiBoYW5kbGUgbW9yZSBlcnJvclxuICAgICAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgICAgICAgcmV0dXJuIHsgZXJyb3I6IHsgY29kZTogXCJ1bmhhbmRsZWRFcnJvclwiIH0gfTtcbiAgICB9XG59O1xuZnVuY3Rpb24gZ2V0V2ViRXhwZXJpZW5jZURlcGVuZGVuY3lJZExpc3QoZGF0YSkge1xuICAgIGNvbnN0IGRhdGFTb3VyY2VzID0gZGF0YS5kYXRhU291cmNlcyB8fCB7fTtcbiAgICBjb25zdCB1dGlsaXRpZXMgPSBkYXRhLnV0aWxpdGllcyB8fCB7fTtcbiAgICBjb25zdCBhbGxEZXBzID0gWy4uLk9iamVjdC52YWx1ZXMoZGF0YVNvdXJjZXMpLCAuLi5PYmplY3QudmFsdWVzKHV0aWxpdGllcyldO1xuICAgIHJldHVybiBhbGxEZXBzLm1hcCgoZGVwKSA9PiBkZXAuaXRlbUlkKS5maWx0ZXIoKGlkKSA9PiBpZCk7XG59XG4vLyAqIC0tLSBCaWcgZGF0YSBmaWxlIHNoYXJlXG5jb25zdCBnZXRCREZTRGVwZW5kZW50SXRlbXMgPSBhc3luYyAoaXRlbSwgcG9ydGFsKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gRGF0YSBTdG9yZSAoQmlnIERhdGEgRmlsZSBTaGFyZTogRmlsZSBTaGFyZSwgSERGUywgSGl2ZSAmIENsb3VkKSAtPiBEYXRhIFN0b3JlIChCaWcgRGF0YSBGaWxlIFNoYXJlKVxuICAgICAgICBjb25zdCB7IHJlbGF0ZWRJdGVtcyB9ID0gYXdhaXQgZ2V0UmVsYXRlZEl0ZW1zKGl0ZW0uaWQsIHBvcnRhbCwge1xuICAgICAgICAgICAgcmVsYXRpb25zaGlwVHlwZTogXCJCREZTRGF0YVN0b3JlMkJERlNDYXRhbG9nU2VydmljZVwiLFxuICAgICAgICAgICAgZGlyZWN0aW9uOiBcInJldmVyc2VcIlxuICAgICAgICB9KTtcbiAgICAgICAgLy8gRGF0YSBTdG9yZSAoQmlnIERhdGEgRmlsZSBTaGFyZTogQ2xvdWQpIC0+IERhdGEgU3RvcmUgKEJpZyBEYXRhIEZpbGUgU2hhcmUpIC0gZGlzcGxheSAyIGl0ZW1zXG4gICAgICAgIC8vIEhlcmUgdGhlIHNoYXJlIHJlcXVlc3QgbXVzdCBiZSBzZW50IHVzaW5nIHRoZSBJRCBvZiB0aGUgRGF0YSBTdG9yZSAoQ2xvdWQpIGl0ZW1cbiAgICAgICAgY29uc3QgdHlwZUtleXdvcmRzID0gcmVsYXRlZEl0ZW1zWzBdLnR5cGVLZXl3b3JkcztcbiAgICAgICAgaWYgKHR5cGVLZXl3b3Jkcy5pbmNsdWRlcyhcImJpZ0RhdGFGaWxlU2hhcmVcIikgJiYgdHlwZUtleXdvcmRzLmluY2x1ZGVzKFwiZGF0YVN0b3JlXCIpKSB7XG4gICAgICAgICAgICBjb25zdCB7IHJlc3VsdDogcmVsYXRlZERhdGFTdG9yZVJlc3VsdCB9ID0gYXdhaXQgZ2V0Q2xvdWREYXRhU3RvcmVEZXBlbmRlbnRJdGVtcyhyZWxhdGVkSXRlbXNbMF0sIHBvcnRhbCk7XG4gICAgICAgICAgICBjb25zdCB7IGl0ZW1zOiByZWxhdGVkRGF0YVN0b3JlIH0gPSByZWxhdGVkRGF0YVN0b3JlUmVzdWx0O1xuICAgICAgICAgICAgY29uc3QgYmRmc0l0ZW0gPSBhd2FpdCBnZXRJdGVtKHJlbGF0ZWRJdGVtc1swXS5pZCwgcG9ydGFsKTtcbiAgICAgICAgICAgIHJldHVybiB7IHJlc3VsdDogeyBpdGVtczogWy4uLnJlbGF0ZWREYXRhU3RvcmUsIGJkZnNJdGVtXSwgbGF5ZXJzOiBbXSB9IH07XG4gICAgICAgIH1cbiAgICAgICAgLy8gRGF0YSBTdG9yZSAoQmlnIERhdGEgRmlsZSBTaGFyZTogRmlsZSBTaGFyZSwgSERGUyAmJiBIaXZlKSAtPiBEYXRhIFN0b3JlIChCaWcgRGF0YSBGaWxlIFNoYXJlKSAtIGRpc3BsYXkgMSBpdGVtXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByZXN1bHQ6IHtcbiAgICAgICAgICAgICAgICBpdGVtczogYXdhaXQgUHJvbWlzZS5hbGwocmVsYXRlZEl0ZW1zLm1hcCgocmVsYXRlZEl0ZW0pID0+IGdldEl0ZW0ocmVsYXRlZEl0ZW0uaWQsIHBvcnRhbCkpKSxcbiAgICAgICAgICAgICAgICBsYXllcnM6IFtdXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgICAgICAgcmV0dXJuIHsgZXJyb3I6IHsgY29kZTogXCJ1bmhhbmRsZWRFcnJvclwiIH0gfTtcbiAgICB9XG59O1xuLy8gKiAtLS0gRGF0YSBTdG9yZSAoQmlnIERhdGEgRmlsZSBTaGFyZSkgLT4gRGF0YSBTdG9yZSAoQ2xvdWQpIC0gZGlzcGxheSAxIGl0ZW1cbmNvbnN0IGdldENsb3VkRGF0YVN0b3JlRGVwZW5kZW50SXRlbXMgPSBhc3luYyAoaXRlbSwgcG9ydGFsKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgeyByZWxhdGVkSXRlbXMgfSA9IGF3YWl0IGdldFJlbGF0ZWRJdGVtcyhpdGVtLmlkLCBwb3J0YWwsIHtcbiAgICAgICAgICAgIHJlbGF0aW9uc2hpcFR5cGU6IFwiQ2xvdWREYXRhU3RvcmUyQkRGU0RhdGFTdG9yZVwiLFxuICAgICAgICAgICAgZGlyZWN0aW9uOiBcInJldmVyc2VcIlxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJlc3VsdDoge1xuICAgICAgICAgICAgICAgIGl0ZW1zOiBhd2FpdCBQcm9taXNlLmFsbChyZWxhdGVkSXRlbXMubWFwKChyZWxhdGVkSXRlbSkgPT4gZ2V0SXRlbShyZWxhdGVkSXRlbS5pZCwgcG9ydGFsKSkpLFxuICAgICAgICAgICAgICAgIGxheWVyczogW11cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJlcnJvcjpcIiwgZXJyb3IpO1xuICAgICAgICByZXR1cm4geyBlcnJvcjogeyBjb2RlOiBcInVuaGFuZGxlZEVycm9yXCIgfSB9O1xuICAgIH1cbn07XG5jb25zdCBmbGF0dGVuRGVwZW5kZW50SXRlbXNBbmRMYXllclJlc3BvbnNlID0gKHJlc3BvbnNlcykgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICAgIGl0ZW1zOiByZXNwb25zZXMuZmxhdE1hcCgocmVzcG9uc2UpID0+IHJlc3BvbnNlLml0ZW1zKSxcbiAgICAgICAgbGF5ZXJzOiByZXNwb25zZXMuZmxhdE1hcCgocmVzcG9uc2UpID0+IHJlc3BvbnNlLmxheWVycylcbiAgICB9O1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIGdyb3VwcyB0aGF0IGEgbGF5ZXIgaXMgc2hhcmVkIHdpdGhcbiAqL1xuYXN5bmMgZnVuY3Rpb24gZ2V0TGF5ZXJTaGFyZWRHcm91cHMobGF5ZXJJZCwgcG9ydGFsLCBpbmNsdWRlRmF2b3JpdGVHcm91cHMgPSBmYWxzZSkge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHsgcmVzdWx0IH0gPSBhd2FpdCBnZXRJdGVtR3JvdXBzKGxheWVySWQsIHBvcnRhbCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByZXN1bHQ6IFsuLi5yZXN1bHQuYWRtaW4sIC4uLnJlc3VsdC5tZW1iZXIsIC4uLnJlc3VsdC5vdGhlcl1cbiAgICAgICAgICAgICAgICAuZmlsdGVyKChncm91cCkgPT4gaW5jbHVkZUZhdm9yaXRlR3JvdXBzIHx8ICFncm91cC5pc0ZhdilcbiAgICAgICAgICAgICAgICAubWFwKChncm91cCkgPT4gZ3JvdXAuaWQpXG4gICAgICAgIH07XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgICAgICAgcmV0dXJuIHsgZXJyb3I6IHsgY29kZTogXCJ1bmhhbmRsZWRFcnJvclwiIH0gfTtcbiAgICB9XG59XG5cbmNvbnN0IGlzV2ViTWFwVGFibGUgPSAobGF5ZXIpID0+IFxuLy8gISBUaGlzIGlzIGp1c3QgYSB3b3JrYXJvdW5kIGZvciBub3cgYnV0IGl0J3Mgbm90IGNvbXBsZXRlbHkgc2FmZSBzaW5jZSB0aGVyZSBpcyBubyBkaXNjcmltaW5hdG9yXG4hKFwibGF5ZXJUeXBlXCIgaW4gbGF5ZXIpICYmIGxheWVyLnVybCAmJiBsYXllci5wb3B1cEluZm87XG5jb25zdCBpc1N1cHBvcnRlZExheWVyVHlwZUZvclVybENoZWNrID0gKGxheWVyKSA9PiB7XG4gICAgY29uc3QgdmFsaWRUeXBlcyA9IFtcbiAgICAgICAgXCJ0YWJsZVwiLFxuICAgICAgICBcIkFyY0dJU0ZlYXR1cmVMYXllclwiLFxuICAgICAgICBcIkFyY0dJU1RpbGVkTWFwU2VydmljZUxheWVyXCIsXG4gICAgICAgIFwiVmVjdG9yVGlsZUxheWVyXCIsXG4gICAgICAgIFwiR3JvdXBMYXllclwiLFxuICAgICAgICBcIkFyY0dJU0ltYWdlU2VydmljZUxheWVyXCIsXG4gICAgICAgIFwiQXJjR0lTVGlsZWRJbWFnZVNlcnZpY2VMYXllclwiLFxuICAgICAgICBcIlN1YnR5cGVHcm91cExheWVyXCIsXG4gICAgICAgIFwiQXJjR0lTU3RyZWFtTGF5ZXJcIlxuICAgIF07XG4gICAgcmV0dXJuIHZhbGlkVHlwZXMuaW5jbHVkZXMobGF5ZXIubGF5ZXJUeXBlKTtcbn07XG5jb25zdCBpc1RpbGVMYXllciA9IChsYXllcikgPT4gbGF5ZXIubGF5ZXJUeXBlID09PSBcIkFyY0dJU1RpbGVkTWFwU2VydmljZUxheWVyXCI7XG5jb25zdCBpc1RpbGVPcGVyYXRpb25MYXllcldpdGhQb3B1cCA9IChsYXllcikgPT4gbGF5ZXIubGF5ZXJUeXBlID09PSBcIkFyY0dJU1RpbGVkTWFwU2VydmljZUxheWVyXCIgJiYgXCJsYXllcnNcIiBpbiBsYXllciAmJiBsYXllci5sYXllcnNbMF0uZGlzYWJsZVBvcHVwID09PSBmYWxzZTtcbmNvbnN0IGlzVmVjdG9yVGlsZUxheWVyID0gKGxheWVyKSA9PiBsYXllci5sYXllclR5cGUgPT09IFwiVmVjdG9yVGlsZUxheWVyXCIgJiYgXCJzdHlsZVVybFwiIGluIGxheWVyO1xuY29uc3QgREVGQVVMVF9TSEFSSU5HX0RFVEFJTFMgPSB7XG4gICAgbmVlZHNHcm91cFVwZGF0ZTogZmFsc2UsXG4gICAgbmVlZHNTaGFyZUxldmVsVXBkYXRlOiBmYWxzZSxcbiAgICBjYW5FZGl0U2hhcmVMZXZlbDogdHJ1ZSxcbiAgICBwcmVtaXVtOiBmYWxzZSxcbiAgICBiZGZzRGF0YXN0b3JlOiBmYWxzZVxufTtcblxuY29uc3QgYWNjZXNzTGV2ZWwgPSB7XG4gICAgcHJpdmF0ZTogMCxcbiAgICBzaGFyZWQ6IDEsXG4gICAgb3JnOiAyLFxuICAgIHB1YmxpYzogM1xufTtcbmNvbnN0IGlzQWNjZXNzTGV2ZWxHcmVhdGVyID0gKG1haW5BY2Nlc3MsIG90aGVyQWNjZXNzKSA9PiBhY2Nlc3NMZXZlbFttYWluQWNjZXNzXSA+IGFjY2Vzc0xldmVsW290aGVyQWNjZXNzXTtcbi8qKlxuICogR2l2ZW4gYSBVUkwgYW5kIGEgcmVsYXRpdmUgcGF0aCwgcmV0dXJuIHRoZSBmdWxsIFVSTFxuICogZS5nOiBodHRwczovL3d3dy5hcmNnaXMuY29tL3NoYXJpbmcvcmVzdC9jb250ZW50L2l0ZW1zLzEyMzQ1Njc4OTBhYmNkZWZnIGFuZCBcIi4uLy4uL1wiLCByZXR1cm4gaHR0cHM6Ly93d3cuYXJjZ2lzLmNvbS9zaGFyaW5nL3Jlc3QvXG4gKlxuICovXG5jb25zdCB0cmF2ZXJzZVVybHMgPSAoeyBwYXRoLCB1cmwgfSkgPT4ge1xuICAgIGNvbnN0IHVybFBhcnRzID0gdXJsLnNwbGl0KFwiL1wiKTtcbiAgICBjb25zdCBwYXRoUGFydHMgPSBwYXRoLnNwbGl0KFwiL1wiKTtcbiAgICBjb25zdCB1cmxQYXJ0c1RvS2VlcCA9IHVybFBhcnRzLnNsaWNlKDAsIHVybFBhcnRzLmxlbmd0aCAtIHBhdGhQYXJ0cy5sZW5ndGgpO1xuICAgIHJldHVybiB1cmxQYXJ0c1RvS2VlcC5qb2luKFwiL1wiKTtcbn07XG5cbmNvbnN0IGZpbHRlclVybHNGcm9tU2FtZU9yaWdpbiA9IGFzeW5jIChwb3J0YWwsIHVybHNUb0NoZWNrKSA9PiB7XG4gICAgY29uc3QgeyBvd25pbmdTeXN0ZW1Vcmw6IG1haW5JdGVtT3duaW5nU3lzdGVtVXJsIH0gPSBhd2FpdCBmcm9tQ2FjaGUoYXN5bmMgKCkgPT4gZ2V0UG9ydGFsUmVzdEluZm8ocG9ydGFsKSwgXCJwb3J0YWxJbmZvXCIsIHBvcnRhbC5pZCk7XG4gICAgY29uc3QgdXJsT3duaW5nU3lzdGVtSW5mbyA9IGF3YWl0IFByb21pc2UuYWxsKHVybHNUb0NoZWNrLm1hcChhc3luYyAodXJsKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCB7IG93bmluZ1N5c3RlbVVybCB9ID0gYXdhaXQgZ2V0UG9ydGFsUmVzdEluZm9Gcm9tVXJsKHVybCk7XG4gICAgICAgICAgICByZXR1cm4geyBvd25pbmdTeXN0ZW1VcmwsIHVybCB9O1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gICAgICAgICAgICByZXR1cm4geyBvd25pbmdTeXN0ZW1Vcmw6IG51bGwsIHVybCB9O1xuICAgICAgICB9XG4gICAgfSkpO1xuICAgIHJldHVybiAodXJsT3duaW5nU3lzdGVtSW5mb1xuICAgICAgICAvLyBUT0RPOiBoYW5kbGUgRW50ZXJwcmlzZSBjYXNlXG4gICAgICAgIC5maWx0ZXIoKHsgb3duaW5nU3lzdGVtVXJsIH0pID0+IG93bmluZ1N5c3RlbVVybCA9PT0gbWFpbkl0ZW1Pd25pbmdTeXN0ZW1VcmwpXG4gICAgICAgIC5tYXAoKHsgdXJsIH0pID0+IHVybCkpO1xufTtcblxuLyoqIEdldCB0aGUgc291cmNlIGl0ZW0gZm9yIHRpbGUgbGF5ZXJcbiAqIEBwYXJhbSBsYXllciAtIFRoZSBsYXllciB0byBnZXQgdGhlIHNvdXJjZSBpdGVtIGZvciB3aXRoIGxheWVyIHR5cGUgb2YgQXJjR0lTVGlsZWRNYXBTZXJ2aWNlTGF5ZXJcbiAqL1xuY29uc3QgZ2V0VGlsZUxheWVyU291cmNlSXRlbSA9IGFzeW5jIChsYXllciwgcG9ydGFsKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgaXRlbUlkID0gbGF5ZXIuaXRlbUlkO1xuICAgICAgICBjb25zdCBpdGVtRGF0YSA9IGF3YWl0IGZyb21DYWNoZSgoKSA9PiBnZXRJdGVtRGF0YShpdGVtSWQsIHBvcnRhbCksIFwiaXRlbURhdGFcIiwgaXRlbUlkKTtcbiAgICAgICAgLy8gQ3VycmVudGx5IGEgdGlsZSBsYXllciBjYW4gb25seSBiZSBjcmVhdGVkIGZyb20gYSBzaW5nbGUgbGF5ZXIgc28gd2UgY2FuIGp1c3QgdGFrZSB0aGUgZmlyc3QgbGF5ZXJcbiAgICAgICAgY29uc3QgeyBsYXllckl0ZW1JZDogc291cmNlSXRlbUlkIH0gPSBpdGVtRGF0YSA9PT0gbnVsbCB8fCBpdGVtRGF0YSA9PT0gdm9pZCAwID8gdm9pZCAwIDogaXRlbURhdGEubGF5ZXJzWzBdO1xuICAgICAgICBpZiAoIXNvdXJjZUl0ZW1JZCkge1xuICAgICAgICAgICAgcmV0dXJuIHsgZXJyb3I6IHsgY29kZTogXCJ1bmhhbmRsZWRFcnJvclwiIH0gfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyByZXN1bHQ6IGF3YWl0IGdldEl0ZW0oc291cmNlSXRlbUlkLCBwb3J0YWwpIH07XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgICAgICAgcmV0dXJuIHsgZXJyb3I6IHsgY29kZTogXCJ1bmhhbmRsZWRFcnJvclwiIH0gfTtcbiAgICB9XG59O1xuLyoqIEdldCBzb3VyY2UgaXRlbXMgZm9yIGl0ZW1zIGR1cGxpY2F0ZWQgZnJvbSBhbm90aGVyIGl0ZW1cbiAqXG4gKiBUaGlzIHdpbGwgaWdub3JlIGl0ZW1zIHRoYXQgaXMgbm90IG9uIHRoZSBzYW1lIGVudmlyb25tZW50IGFzIHRoZSBtYWluIGl0ZW1cbiAqIG9yIGlmIG5vdCB1c2luZyB0aGUgc2FtZSBmZWRlcmF0ZWQgc2VydmVyIGlmIHdlJ3JlIGluIEVudGVycHJpc2VcbiAqXG4gKiBodHRwczovL2RldnRvcGlhLmVzcmkuY29tL1dlYkdJUy9hcmNnaXMtYXBwLWNvbXBvbmVudHMvaXNzdWVzLzM4MDlcbiAqL1xuY29uc3QgZ2V0U291cmNlSXRlbXNGcm9tVXJscyA9IGFzeW5jIChpdGVtVXJscywgcG9ydGFsKSA9PiB7XG4gICAgY29uc3QgdmFsaWRVcmxJbmZvcyA9IGl0ZW1VcmxzLmZpbHRlcigodXJsSW5mbykgPT4gISEodXJsSW5mbyA9PT0gbnVsbCB8fCB1cmxJbmZvID09PSB2b2lkIDAgPyB2b2lkIDAgOiB1cmxJbmZvLnVybCkgJiYgaXNTdXBwb3J0ZWRMYXllclR5cGVGb3JVcmxDaGVjayh7IGxheWVyVHlwZTogdXJsSW5mby5sYXllclR5cGUgfSkpO1xuICAgIGNvbnN0IHZhbGlkSXRlbVVybHMgPSBhd2FpdCBmaWx0ZXJPdXREaWZmT3JpZ2luQUdTVXJscyh2YWxpZFVybEluZm9zLm1hcCgodXJsSW5mbykgPT4gdXJsSW5mby51cmwpLCBwb3J0YWwpO1xuICAgIC8vIFNvbWUgdXJsIGlzIGEgcm9vdC5qc29uIHVybCBzbyB3ZSBuZWVkIHRvIGdvIHRocm91Z2ggYW5vdGhlciBsYXllciBvZiBnZXRTb3VyY2VJdGVtc0Zyb21VcmxzIHRvIGdldCB0aGUgYWN0dWFsIGl0ZW1cbiAgICBjb25zdCByb290SlNPTlNlcnZpY2VVUkwgPSBbXTtcbiAgICAvLyAqIEZpcnN0IHNlbmQgcmVxdWVzdCB3aXRob3V0IHRva2VuXG4gICAgY29uc3QgcmVxdWlyZWRUb2tlblVybHMgPSBbXTtcbiAgICBjb25zdCBub1Rva2VuTWV0YURhdGEgPSBbXTtcbiAgICBhd2FpdCBQcm9taXNlLmFsbCh2YWxpZEl0ZW1VcmxzLm1hcChhc3luYyAodXJsKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgcmVzdWx0LCBlcnJvciB9ID0gYXdhaXQgZnJvbUNhY2hlKCgpID0+IGdldFNlcnZpY2VVcmxSZXNwb25zZSh1cmwsIHBvcnRhbCksIFwiaXRlbU1ldGFkYXRhXCIsIGAke3VybH0tLW5vLXRva2VuYCk7XG4gICAgICAgIGlmICgoZXJyb3IgPT09IG51bGwgfHwgZXJyb3IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGVycm9yLmNvZGUpID09PSBcInRva2VuUmVxdWlyZWRcIikge1xuICAgICAgICAgICAgcmVxdWlyZWRUb2tlblVybHMucHVzaCh1cmwpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1Jvb3RKU09OUmVzcG9uc2UocmVzdWx0KSkge1xuICAgICAgICAgICAgcm9vdEpTT05TZXJ2aWNlVVJMLnB1c2goZ2V0Um9vdEpTT05SZXNwb25zZVVybChyZXN1bHQsIHVybCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbm9Ub2tlbk1ldGFEYXRhLnB1c2gocmVzdWx0KTtcbiAgICAgICAgfVxuICAgIH0pKTtcbiAgICBjb25zdCBub1Rva2VuU2VydmljZUlkcyA9IG5vVG9rZW5NZXRhRGF0YS5tYXAoKG1ldGFEYXRhKSA9PiBtZXRhRGF0YSA9PT0gbnVsbCB8fCBtZXRhRGF0YSA9PT0gdm9pZCAwID8gdm9pZCAwIDogbWV0YURhdGEuc2VydmljZUl0ZW1JZCk7XG4gICAgLy8gKiBGb3IgdXJscyB0aGF0IHJlcXVpcmUgdG9rZW4sIGNoZWNrIGlmIHRoZXkgYXJlIGluIHRoZSBzYW1lIG9yaWdpblxuICAgIGNvbnN0IHNhbWVIb3N0UmVzdFVybHMgPSBhd2FpdCBmaWx0ZXJVcmxzRnJvbVNhbWVPcmlnaW4ocG9ydGFsLCByZXF1aXJlZFRva2VuVXJscyk7XG4gICAgLy8gSWYgeWVzLCB0aGVuIHdlIGNhbiBqdXN0IGdldCB0aGUgaXRlbSBkZXRhaWxcbiAgICBjb25zdCByZXF1aXJlZFRva2VuTWV0YURhdGEgPSBhd2FpdCBQcm9taXNlLmFsbChzYW1lSG9zdFJlc3RVcmxzLm1hcChhc3luYyAodXJsKSA9PiAoe1xuICAgICAgICByZXNwb25zZTogYXdhaXQgcmVxdWVzdEZldGNoKHVybCwgcG9ydGFsLCB7IGFkZFRva2VuTWFudWFsbHk6IHRydWUgfSksXG4gICAgICAgIHVybCAvLyBXZSBuZWVkIHRoaXMgZm9yIHJvb3QganNvbiB1cmxcbiAgICB9KSkpO1xuICAgIGNvbnN0IHJlcXVpcmVkVG9rZW5TZXJ2aWNlSWRzID0gcmVxdWlyZWRUb2tlbk1ldGFEYXRhLnJlZHVjZSgoaWRMaXN0LCB7IHJlc3BvbnNlLCB1cmwgfSkgPT4ge1xuICAgICAgICBpZiAoaXNSb290SlNPTlJlc3BvbnNlKHJlc3BvbnNlKSkge1xuICAgICAgICAgICAgcm9vdEpTT05TZXJ2aWNlVVJMLnB1c2goZ2V0Um9vdEpTT05SZXNwb25zZVVybChyZXNwb25zZSwgdXJsKSk7XG4gICAgICAgICAgICByZXR1cm4gaWRMaXN0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbLi4uaWRMaXN0LCByZXNwb25zZSA9PT0gbnVsbCB8fCByZXNwb25zZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVzcG9uc2Uuc2VydmljZUl0ZW1JZF07XG4gICAgfSwgW10pO1xuICAgIC8vICogVGhlbiBqdXN0IGdldCB0aGUgaXRlbSBkZXRhaWxcbiAgICBjb25zdCByZXR1cm5JdGVtcyA9IGF3YWl0IFByb21pc2UuYWxsKFsuLi5ub1Rva2VuU2VydmljZUlkcywgLi4ucmVxdWlyZWRUb2tlblNlcnZpY2VJZHNdLm1hcChhc3luYyAoc2VydmljZUl0ZW1JZCkgPT4gc2VydmljZUl0ZW1JZCA/IGdldEl0ZW0oc2VydmljZUl0ZW1JZCwgcG9ydGFsKSA6IG51bGwpKTtcbiAgICAvLyBXZSByZXBlYXQgdGhlIHNhbWUgcHJvY2VzcyB0byBnZXQgdGhlIGFjdHVhbCBgc2VydmljZUl0ZW1JZGAgdGhlbiB0aGUgaXRlbSB2aWEgdGhlIHJvb3QganNvbiBVUkxcbiAgICBjb25zdCByb290SlNPTkl0ZW1zID0gcm9vdEpTT05TZXJ2aWNlVVJMLmxlbmd0aCA8PSAwXG4gICAgICAgID8gW11cbiAgICAgICAgOiBhd2FpdCBnZXRTb3VyY2VJdGVtc0Zyb21VcmxzKHJvb3RKU09OU2VydmljZVVSTC5tYXAoKHVybCkgPT4gKHsgdXJsLCBsYXllclR5cGU6IFwiVmVjdG9yVGlsZUxheWVyXCIgfSkpLCBwb3J0YWwpO1xuICAgIHJldHVybiBbLi4ucmV0dXJuSXRlbXMuZmlsdGVyKChpdGVtKSA9PiAhIWl0ZW0pLCAuLi5yb290SlNPTkl0ZW1zXTtcbn07XG5jb25zdCBpc1Jvb3RKU09OUmVzcG9uc2UgPSAocmVzcG9uc2UpID0+IHtcbiAgICByZXR1cm4gISEocmVzcG9uc2UgPT09IG51bGwgfHwgcmVzcG9uc2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlc3BvbnNlLnNvdXJjZXMpO1xufTtcbmNvbnN0IGdldFJvb3RKU09OUmVzcG9uc2VVcmwgPSAocmVzcG9uc2UsIHVybCkgPT4ge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCByZXNwb25zZVVybCA9IChfYSA9IE9iamVjdC52YWx1ZXMocmVzcG9uc2Uuc291cmNlcylbMF0pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS51cmw7XG4gICAgaWYgKCFyZXNwb25zZVVybCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3BvbnNlVXJsLmluY2x1ZGVzKFwiLi5cIikgPyB0cmF2ZXJzZVVybHMoeyB1cmwsIHBhdGg6IHJlc3BvbnNlVXJsIH0pIDogcmVzcG9uc2VVcmw7XG59O1xuY29uc3QgZmlsdGVyT3V0RGlmZk9yaWdpbkFHU1VybHMgPSBhc3luYyAodXJscywgcG9ydGFsKSA9PiB7XG4gICAgY29uc3QgdmFsaWRBZ3NVUkwgPSB1cmxzLmZpbHRlcigodXJsKSA9PiAhIXVybCAmJiAhIXBhcnNlQUdTU2VydmVySW5mbyh1cmwpKTtcbiAgICAvLyBUT0RPIFIzOiB3ZSdsbCBmaW5lLWdyYWluIGNoZWNraW5nIHRoaXMgbGF0ZXIgYW5kIG9uY2UgaXRlbXMgaGF2ZSBiZXR0ZXIgc3BlY1xuICAgIGNvbnN0IG5vbkFHU1VybHMgPSB1cmxzLmZpbHRlcigodXJsKSA9PiAhdXJsIHx8ICFwYXJzZUFHU1NlcnZlckluZm8odXJsKSk7XG4gICAgY29uc3Qgc2FtZU9yaWdpblVybHMgPSBhd2FpdCBmaWx0ZXJVcmxzRnJvbVNhbWVPcmlnaW4ocG9ydGFsLCB2YWxpZEFnc1VSTCk7XG4gICAgcmV0dXJuIFsuLi5zYW1lT3JpZ2luVXJscywgLi4ubm9uQUdTVXJsc107XG59O1xuXG5jb25zdCBnZXRTb3VyY2VJdGVtc0Zyb21EZXBlbmRlbnRMYXllcnMgPSBhc3luYyAoZGVwZW5kZW50TGF5ZXJzLCBwb3J0YWwpID0+IHtcbiAgICAvLyAqIFJlY3Vyc2l2ZWx5IGZsYXR0ZW4gbGF5ZXJzLCBmb2N1c2luZyBvbiBHcm91cExheWVyXG4gICAgY29uc3QgZmxhdHRlbmVkTGF5ZXJzID0gW107XG4gICAgY29uc3QgYW5hbHl6ZUxheWVyID0gKGxheWVyKSA9PiB7XG4gICAgICAgIGlmIChpc1dlYk1hcFRhYmxlKGxheWVyKSkge1xuICAgICAgICAgICAgZmxhdHRlbmVkTGF5ZXJzLnB1c2goe1xuICAgICAgICAgICAgICAgIGlkOiBsYXllci5pZCxcbiAgICAgICAgICAgICAgICB1cmw6IGxheWVyLnVybCxcbiAgICAgICAgICAgICAgICBsYXllclR5cGU6IFwidGFibGVcIixcbiAgICAgICAgICAgICAgICBnZXRUeXBlOiBcIm5vcm1hbFwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGF5ZXIubGF5ZXJUeXBlID09PSBcIkdyb3VwTGF5ZXJcIikge1xuICAgICAgICAgICAgaWYgKGxheWVyLml0ZW1JZCkge1xuICAgICAgICAgICAgICAgIC8vIEEgR3JvdXBMYXllciBpdGVtXG4gICAgICAgICAgICAgICAgZmxhdHRlbmVkTGF5ZXJzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBpZDogbGF5ZXIuaWQsXG4gICAgICAgICAgICAgICAgICAgIGl0ZW1JZDogbGF5ZXIuaXRlbUlkLFxuICAgICAgICAgICAgICAgICAgICBsYXllclR5cGU6IFwiR3JvdXBMYXllclwiLFxuICAgICAgICAgICAgICAgICAgICBnZXRUeXBlOiBcIm5vcm1hbFwiXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsYXllci5sYXllcnMuZm9yRWFjaCgoc3ViTGF5ZXIpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoaXNXZWJNYXBUYWJsZShzdWJMYXllcikgfHwgc3ViTGF5ZXIubGF5ZXJUeXBlID09PSBcIkdyb3VwTGF5ZXJcIikge1xuICAgICAgICAgICAgICAgICAgICBhbmFseXplTGF5ZXIoc3ViTGF5ZXIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHN1YkxheWVyVXJsID0gc3ViTGF5ZXIudXJsO1xuICAgICAgICAgICAgICAgIGlmICghc3ViTGF5ZXJVcmwpIHtcbiAgICAgICAgICAgICAgICAgICAgYW5hbHl6ZUxheWVyKHN1YkxheWVyKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBwYXJzZVVybEluZm8gPSBwYXJzZUFHU1NlcnZlckluZm8oc3ViTGF5ZXJVcmwpO1xuICAgICAgICAgICAgICAgIGFuYWx5emVMYXllcihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHN1YkxheWVyKSwgeyBcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgYSBsYXllciBpbiBHcm91cExheWVyIGhhcyBpbmRleCBpbiB0aGVpciBVUkwsIHdlJ2xsIHdhbnQgdG8gc3RyaXAgdGhlbSBvdXQgZmlyc3RcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBtaWdodCBjcmVhdGUgc29tZSBkdXBsaWNhdGVkIFVSTHMgYnV0IHdlIGFscmVhZHkgZmlsdGVyIHRoZW0gb3V0IGJlbG93IHZpYSB0aGUgYGxheWVySXRlbUlkTG9va3VwTWFwYFxuICAgICAgICAgICAgICAgICAgICB1cmw6IChwYXJzZVVybEluZm8gPT09IG51bGwgfHwgcGFyc2VVcmxJbmZvID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJzZVVybEluZm8uaW5kZXgpICE9IG51bGwgPyBwYXJzZVVybEluZm8uYmFzZVNlcnZlclVybCA6IHN1YkxheWVyLnVybCB9KSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNWZWN0b3JUaWxlTGF5ZXIobGF5ZXIpKSB7XG4gICAgICAgICAgICBmbGF0dGVuZWRMYXllcnMucHVzaCh7XG4gICAgICAgICAgICAgICAgaWQ6IGxheWVyLmlkLFxuICAgICAgICAgICAgICAgIHVybDogbGF5ZXIuc3R5bGVVcmwsXG4gICAgICAgICAgICAgICAgaXRlbUlkOiBsYXllci5pdGVtSWQsXG4gICAgICAgICAgICAgICAgbGF5ZXJUeXBlOiBsYXllci5sYXllclR5cGUsXG4gICAgICAgICAgICAgICAgZ2V0VHlwZTogXCJub3JtYWxcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gV2UgbmVlZCB0byBhbHNvIGZldGNoIHRoZSBvcmlnaW5hbCBpdGVtIHRoaXMgdGlsZSBsYXllciBpcyBjcmVhdGVkIGZyb21cbiAgICAgICAgaWYgKGlzVGlsZUxheWVyKGxheWVyKSkge1xuICAgICAgICAgICAgLy8gSWYgdGhlIHRpbGUgbGF5ZXIgaGFzIHBvcHVwIGVuYWJsZWQsIHdlIGNhbiBqdXN0IHRha2UgdGhlIGxheWVyIGRpcmVjdGx5XG4gICAgICAgICAgICAvLyAgd2hpY2ggaXMgc2ltcGx5IHZpYSBsYXllcnNbMF0ncyBgbGF5ZXJJdGVtSWRgXG4gICAgICAgICAgICAvLyAgaWYgbm90LCB3ZSdsbCBoYXZlIHRvIGdvIGludG8gL2RhdGEgYW5kIGdldCB0aGUgYGxheWVySXRlbUlkYCBmaXJzdCBmcm9tIHRoZXJlXG4gICAgICAgICAgICBjb25zdCBpc1RpbGVMYXllcldpdGhQb3B1cCA9IGlzVGlsZU9wZXJhdGlvbkxheWVyV2l0aFBvcHVwKGxheWVyKTtcbiAgICAgICAgICAgIGlmIChpc1RpbGVMYXllcldpdGhQb3B1cCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpcnN0U3ViTGF5ZXIgPSBsYXllci5sYXllcnNbMF07XG4gICAgICAgICAgICAgICAgZmxhdHRlbmVkTGF5ZXJzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBpZDogZmlyc3RTdWJMYXllci5pZCxcbiAgICAgICAgICAgICAgICAgICAgdXJsOiBmaXJzdFN1YkxheWVyLmxheWVyVXJsLFxuICAgICAgICAgICAgICAgICAgICBnZXRUeXBlOiBcIm5vcm1hbFwiLFxuICAgICAgICAgICAgICAgICAgICBsYXllclR5cGU6IGxheWVyLmxheWVyVHlwZSxcbiAgICAgICAgICAgICAgICAgICAgaXRlbUlkOiBmaXJzdFN1YkxheWVyLmxheWVySXRlbUlkXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgLy8gISBXZSBhbHNvIHdhbnQgdG8gY2hlY2sgZm9yIHRoZSB0aWxlIGxheWVyIHNoYXJpbmcgbWlzbWF0Y2ggc28gdGhlcmUgaXMgbm8gcmV0dXJuIGhlcmVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZsYXR0ZW5lZExheWVycy5wdXNoKHtcbiAgICAgICAgICAgICAgICBpZDogbGF5ZXIuaWQsXG4gICAgICAgICAgICAgICAgZ2V0VHlwZTogaXNUaWxlTGF5ZXJXaXRoUG9wdXAgPyBcIm5vcm1hbFwiIDogXCJ0aWxlLWxheWVyLXdpdGgtbm8tcG9wdXBcIixcbiAgICAgICAgICAgICAgICBpdGVtSWQ6IGxheWVyLml0ZW1JZCxcbiAgICAgICAgICAgICAgICBsYXllclR5cGU6IGxheWVyLmxheWVyVHlwZSxcbiAgICAgICAgICAgICAgICB1cmw6IGxheWVyLnVybFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxheWVyLml0ZW1JZCB8fCBsYXllci51cmwpIHtcbiAgICAgICAgICAgIGZsYXR0ZW5lZExheWVycy5wdXNoKHtcbiAgICAgICAgICAgICAgICBpZDogbGF5ZXIuaWQsXG4gICAgICAgICAgICAgICAgdXJsOiBsYXllci51cmwsXG4gICAgICAgICAgICAgICAgaXRlbUlkOiBsYXllci5pdGVtSWQsXG4gICAgICAgICAgICAgICAgbGF5ZXJUeXBlOiBsYXllci5sYXllclR5cGUsXG4gICAgICAgICAgICAgICAgZ2V0VHlwZTogXCJub3JtYWxcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGRlcGVuZGVudExheWVycy5mb3JFYWNoKGFuYWx5emVMYXllcik7XG4gICAgY29uc3QgbGF5ZXJJdGVtSWRMb29rdXBNYXAgPSBhcnJheVRvTG9va3VwTWFwKGZsYXR0ZW5lZExheWVycywgKGxheWVyKSA9PiB7XG4gICAgICAgIGlmIChsYXllci5pdGVtSWQpIHtcbiAgICAgICAgICAgIHJldHVybiB7IGtleTogbGF5ZXIuaXRlbUlkLCBkYXRhOiB7IHNlYXJjaFR5cGU6IFwiaXRlbS1pZFwiLCBsYXllclR5cGU6IGxheWVyLmxheWVyVHlwZSB9IH07XG4gICAgICAgIH1cbiAgICAgICAgLy8gTGF5ZXIgZnJvbSBzaGFsbG93IGNvcGllZCBvciBkdXBsaWNhdGVkIGl0ZW1zXG4gICAgICAgIC8vIEhvd2V2ZXIsIGlmIGxheWVyIGRvZXNuJ3QgaGF2ZSBib3RoIGBpdGVtSWRgIGFuZCBgdXJsYCwgd2UnbGwganVzdCBoYXZlIHRoZSBrZXkgYXMgYG51bGxgIGFuZCBpZ25vcmUgdGhlbSBzaW5jZSB0aGVyZSBpcyBubyB3YXkgdG8gZ2V0IHRoZSBzb3VyY2UgaXRlbVxuICAgICAgICByZXR1cm4geyBrZXk6IGxheWVyLnVybCwgZGF0YTogeyBzZWFyY2hUeXBlOiBcInVybFwiLCBsYXllclR5cGU6IGxheWVyLmxheWVyVHlwZSB9IH07XG4gICAgfSk7XG4gICAgY29uc3QgdW5pcXVlSWRzID0gT2JqZWN0LmtleXMobGF5ZXJJdGVtSWRMb29rdXBNYXApLmZpbHRlcigoaWQpID0+IGxheWVySXRlbUlkTG9va3VwTWFwW2lkXS5zZWFyY2hUeXBlID09PSBcIml0ZW0taWRcIik7XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gKiAtLS0gSGFuZGxlIGdldHRpbmcgc291cmNlIGl0ZW1cbiAgICAgICAgY29uc3QgaXRlbXNGcm9tSWRzID0gKGF3YWl0IFByb21pc2UuYWxsKHVuaXF1ZUlkcy5tYXAoKGlkKSA9PiBnZXRJdGVtKGlkLCBwb3J0YWwpKSkpLmZpbHRlcigoaXRlbUluZm8pID0+ICEhaXRlbUluZm8pO1xuICAgICAgICAvLyBIYW5kbGUgdGlsZSBsYXllciBzb3VyY2UgaXRlbSBpZiB0aGUgdGlsZSBsYXllciBkb2Vzbid0IGhhdmUgcG9wdXAgZW5hYmxlZFxuICAgICAgICBjb25zdCBkZXBlbmRlbnRUaWxlTGF5ZXJzID0gZmxhdHRlbmVkTGF5ZXJzLmZpbHRlcigoeyBnZXRUeXBlOiB0eXBlLCBpdGVtSWQgfSkgPT4gdHlwZSA9PT0gXCJ0aWxlLWxheWVyLXdpdGgtbm8tcG9wdXBcIiAmJiAhIWl0ZW1JZCk7XG4gICAgICAgIGNvbnN0IHRpbGVMYXllclNvdXJjZUl0ZW1zID0gKGF3YWl0IFByb21pc2UuYWxsKGRlcGVuZGVudFRpbGVMYXllcnMubWFwKChsYXllcikgPT4gZ2V0VGlsZUxheWVyU291cmNlSXRlbShsYXllciwgcG9ydGFsKSkpKS5tYXAoKHsgcmVzdWx0IH0pID0+IHJlc3VsdCk7XG4gICAgICAgIC8vIEhhbmRsZSBpdGVtIGR1cGxpY2F0ZWQgZnJvbSBhbm90aGVyIGl0ZW0gLS0tIGN1cnJlbnRseSBhbHNvIGhhbmRsZSB2ZWN0b3IgdGlsZSBsYXllclxuICAgICAgICAvLyAgYmVjYXVzZSBpc0hvc3RlZFNlcnZpY2UgZG9lc24ndCBjb3VudCB2ZWN0b3IgdGlsZSBsYXllciBhcyBob3N0ZWQgc2VydmljZVxuICAgICAgICBjb25zdCBub25Ib3N0ZWRJdGVtcyA9IGl0ZW1zRnJvbUlkcy5maWx0ZXIoKGl0ZW0pID0+ICFpc0hvc3RlZFNlcnZpY2UoaXRlbS50eXBlS2V5d29yZHMsIGl0ZW0udHlwZSkpO1xuICAgICAgICBjb25zdCBub25Ib3N0ZWRJdGVtSW5mb3MgPSBhd2FpdCBnZXRTb3VyY2VJdGVtc0Zyb21VcmxzKG5vbkhvc3RlZEl0ZW1zLm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyB1cmwsIGlkIH0gPSBpdGVtO1xuICAgICAgICAgICAgY29uc3QgbGF5ZXJJbmZvID0gbGF5ZXJJdGVtSWRMb29rdXBNYXBbaWRdO1xuICAgICAgICAgICAgcmV0dXJuIGxheWVySW5mbyA/IHsgbGF5ZXJUeXBlOiBsYXllckluZm8ubGF5ZXJUeXBlLCB1cmwgfSA6IG51bGw7XG4gICAgICAgIH0pLCBwb3J0YWwpO1xuICAgICAgICBjb25zdCBub25Ib3N0ZWRJdGVtc0xvb2t1cEJ5VXJsID0gYXJyYXlUb0xvb2t1cE1hcChub25Ib3N0ZWRJdGVtSW5mb3MsIChpdGVtKSA9PiAoe1xuICAgICAgICAgICAga2V5OiBpdGVtLnVybCxcbiAgICAgICAgICAgIGRhdGE6IGl0ZW1cbiAgICAgICAgfSkpO1xuICAgICAgICAvLyBIYW5kbGUgc2hhbGxvdyBjb3BpZWQgbGF5ZXJzXG4gICAgICAgIGNvbnN0IHNoYWxsb3dlZENvcGllZExheWVyVXJscyA9IE9iamVjdC5rZXlzKGxheWVySXRlbUlkTG9va3VwTWFwKVxuICAgICAgICAgICAgLm1hcCgodXJsKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBsYXllckluZm8gPSBsYXllckl0ZW1JZExvb2t1cE1hcFt1cmxdO1xuICAgICAgICAgICAgcmV0dXJuIGxheWVySW5mbyAmJiBsYXllckluZm8uc2VhcmNoVHlwZSA9PT0gXCJ1cmxcIiA/IHsgbGF5ZXJUeXBlOiBsYXllckluZm8ubGF5ZXJUeXBlLCB1cmwgfSA6IG51bGw7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAuZmlsdGVyKChsYXllckluZm8pID0+IGxheWVySW5mbyk7XG4gICAgICAgIGNvbnN0IHNoYWxsb3dDb3BpZWRJdGVtcyA9IGF3YWl0IGdldFNvdXJjZUl0ZW1zRnJvbVVybHMoc2hhbGxvd2VkQ29waWVkTGF5ZXJVcmxzLCBwb3J0YWwpO1xuICAgICAgICAvLyAqIEFnZ3JlZ2F0ZSB0aGUgcmVzdWx0XG4gICAgICAgIGNvbnN0IHNvdXJjZUl0ZW1zID0gW107XG4gICAgICAgIGl0ZW1zRnJvbUlkc1xuICAgICAgICAgICAgLmZpbHRlcigoaXRlbUluZm8pID0+IGl0ZW1JbmZvKVxuICAgICAgICAgICAgLmZvckVhY2goKGl0ZW0pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGl0ZW1VcmwgPSBpdGVtLnVybDtcbiAgICAgICAgICAgIHNvdXJjZUl0ZW1zLnB1c2goeyBzb3VyY2VJdGVtOiBpdGVtIH0pO1xuICAgICAgICAgICAgY29uc3Qgbm9uSG9zdGVkU291cmNlSXRlbSA9IG5vbkhvc3RlZEl0ZW1zTG9va3VwQnlVcmxbaXRlbVVybF07XG4gICAgICAgICAgICBpZiAobm9uSG9zdGVkU291cmNlSXRlbSAmJiBpdGVtLmlkICE9PSBub25Ib3N0ZWRTb3VyY2VJdGVtLmlkKSB7XG4gICAgICAgICAgICAgICAgc291cmNlSXRlbXMucHVzaCh7IHNvdXJjZUl0ZW06IG5vbkhvc3RlZFNvdXJjZUl0ZW0gfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBbLi4udGlsZUxheWVyU291cmNlSXRlbXMsIC4uLnNoYWxsb3dDb3BpZWRJdGVtc10uZm9yRWFjaCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgaWYgKCFpdGVtKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc291cmNlSXRlbXMucHVzaCh7IGxheWVyOiBudWxsLCBzb3VyY2VJdGVtOiBpdGVtIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHsgcmVzdWx0OiBzb3VyY2VJdGVtcyB9O1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gICAgICAgIHJldHVybiB7IGVycm9yOiB7IGNvZGU6IFwidW5oYW5kbGVkRXJyb3JcIiB9IH07XG4gICAgfVxufTtcblxuLyoqXG4gKiBBbmFseXplIHNoYXJpbmcgZGV0YWlsIG9mIHRoZSBpdGVtIGFuZCByZXR1cm4gYW55IG1pc21hdGNoIG9yIHNoYXJpbmcgaXNzdWVzXG4gKlxuICogQHBhcmFtIG92ZXJyaWRlTGF5ZXJzXG4gKiBOb3JtYWxseSwgdGhlIHV0aWwgd2lsbCBmZXRjaCB0aGUgbGF5ZXJzIGZyb20gdGhlIC9kYXRhIGVuZHBvaW50XG4gKiBIb3dldmVyLCBpZiB0aGUgdXNlciBoYXMgb3ZlcnJpZGVMYXllcnMgbGF5ZXJzLCB3ZSBjYW4gcGFzcyB0aGVtIGluIGhlcmVcbiAqXG4gKiAqKk5vdGUhISEqKjogTWFrZSBzdXJlIHRoZSBsYXllcnMgcGFzc2VkIGluIGlzIGluIHRoZSBmb3JtIG9mIHdoYXQgd2Ugd291bGQgcmVjZWl2ZSBmcm9tIHRoZSAvZGF0YSBlbmRwb2ludCBvZiB0aGUgaXRlbSwgbm90IEpTIEFQSSdzIGBMYXllcmBcbiAqXG4gKiBUaGlzIGlzIHVzZWZ1bCBpbiB0aGUgY2FzZSBvZiBNYXAgVmlld2VyIHdoZXJlIHRoZSAvZGF0YSBlbmRwb2ludCBpcyBub3QgdXBkYXRlZCB3aXRoIHRoZSBsYXRlc3QgbGF5ZXJzIGFmdGVyIHNhdmVcbiAqIEhvd2V2ZXIsIGNhc2VzIGxpa2UgRGF0YVN0b3JlIGFuZCBCREZTIHVzZSB0aGUgaXRlbXMgZGlyZWN0bHkgYW5kIHRoZXJlZm9yZSB0aGlzIHBhcmFtIGlzIHJlZHVuZGFudFxuICpcbiAqIEBwYXJhbSBvcHRpb25zIC0gb3B0aW9ucyAtIHNlZSB7QGxpbmsgT3B0aW9uc31cbiAqL1xuY29uc3QgYW5hbHl6ZVNoYXJpbmdEZXRhaWwgPSBhc3luYyAoaXRlbSwgcG9ydGFsLCBvdmVycmlkZUxheWVycywgb3B0aW9ucyA9IHsgY2xlYXJEYXRhQ2FjaGVPbkRvbmU6IHRydWUgfSkgPT4ge1xuICAgIGlmIChpdGVtLmFjY2VzcyA9PT0gXCJwcml2YXRlXCIpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJlc3VsdDoge1xuICAgICAgICAgICAgICAgIG5lZWRFZGl0YWJsZUxheWVyczogW10sXG4gICAgICAgICAgICAgICAgbmVlZFB1YmxpY2x5RWRpdGFibGVMYXllcnM6IFtdLFxuICAgICAgICAgICAgICAgIG5lZWREYXRhQ29sbGVjdGlvbkxheWVyczogW10sXG4gICAgICAgICAgICAgICAgbmVlZHNTaGFyZUxldmVsVXBkYXRlTGF5ZXJzOiBbXSxcbiAgICAgICAgICAgICAgICBwcmVtaXVtTGF5ZXJzOiBbXSxcbiAgICAgICAgICAgICAgICBub3RFZGl0YWJsZUxheWVyczogW10sXG4gICAgICAgICAgICAgICAgbmVlZEJERlNEYXRhc3RvcmVVcGRhdGU6IFtdLFxuICAgICAgICAgICAgICAgIG5lZWRBdXRoZW50aWNhdGlvbjogW11cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgeyByZXN1bHQsIGVycm9yIH0gPSBhd2FpdCBnZXRMYXllckFuZFNoYXJpbmdEZXRhaWwoaXRlbSwgcG9ydGFsLCBvdmVycmlkZUxheWVycyk7XG4gICAgaWYgKGVycm9yKSB7XG4gICAgICAgIHJldHVybiB7IGVycm9yIH07XG4gICAgfVxuICAgIGNvbnN0IHNoYXJpbmdEZXRhaWxCdWNrZXRzID0ge1xuICAgICAgICBuZWVkRWRpdGFibGVMYXllcnM6IFtdLFxuICAgICAgICBuZWVkUHVibGljbHlFZGl0YWJsZUxheWVyczogW10sXG4gICAgICAgIG5lZWREYXRhQ29sbGVjdGlvbkxheWVyczogW10sXG4gICAgICAgIG5lZWRzU2hhcmVMZXZlbFVwZGF0ZUxheWVyczogW10sXG4gICAgICAgIHByZW1pdW1MYXllcnM6IFtdLFxuICAgICAgICBub3RFZGl0YWJsZUxheWVyczogW10sXG4gICAgICAgIG5lZWRCREZTRGF0YXN0b3JlVXBkYXRlOiBbXSxcbiAgICAgICAgbmVlZEF1dGhlbnRpY2F0aW9uOiBjaGVja0lmRGV2ZWxvcGVyQmFzZW1hcChpdGVtKVxuICAgICAgICAgICAgPyBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBzb3VyY2VJdGVtOiBpdGVtLFxuICAgICAgICAgICAgICAgICAgICBkZXRhaWw6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJkZnNEYXRhc3RvcmU6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2FuRWRpdFNoYXJlTGV2ZWw6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBuZWVkc0dyb3VwVXBkYXRlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5lZWRzU2hhcmVMZXZlbFVwZGF0ZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmVtaXVtOiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXVxuICAgICAgICAgICAgOiBbXVxuICAgIH07XG4gICAgYXdhaXQgUHJvbWlzZS5hbGwocmVzdWx0ID09PSBudWxsIHx8IHJlc3VsdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVzdWx0Lm1hcChhc3luYyAoaW5mbykgPT4ge1xuICAgICAgICBjb25zdCBidWNrZXQgPSBhd2FpdCBnZXRTaGFyaW5nRGV0YWlsQnVja2V0KHtcbiAgICAgICAgICAgIG1haW5JdGVtOiBpdGVtLFxuICAgICAgICAgICAgc2hhcmluZ0RldGFpbFJlc3VsdDogaW5mbyxcbiAgICAgICAgICAgIHBvcnRhbFxuICAgICAgICB9KTtcbiAgICAgICAgYnVja2V0ICYmIHNoYXJpbmdEZXRhaWxCdWNrZXRzW2J1Y2tldF0ucHVzaChpbmZvKTtcbiAgICB9KSk7XG4gICAgaWYgKG9wdGlvbnMuY2xlYXJEYXRhQ2FjaGVPbkRvbmUpIHtcbiAgICAgICAgLy8gVE9ETzogZmluZCBhIHdheSB0byBzY29wZSB0aGlzIHRvIHRoZSBmdW5jdGlvbiBvbmx5IChwb3NzaWJseSB0aHJvdWdoIHN0b3JlIG9mIGNhY2hlKVxuICAgICAgICAvLyAgYnV0IHJpZ2h0IG5vdyB3ZSBkb24ndCBoYXZlIGEgdXNlIGNhc2UgZm9yIHRoYXQgc28gaXQgc2hvdWxkIGJlIGZpbmUuLi5cbiAgICAgICAgZGVwZW5kZW5jeUNoZWNrQ2FjaGVUeXBlcy5mb3JFYWNoKCh0eXBlKSA9PiBjbGVhckNhY2hlKHR5cGUpKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgcmVzdWx0OiBzaGFyaW5nRGV0YWlsQnVja2V0cyB9O1xufTtcbi8qKlxuICogR2V0IGl0ZW0gYW5kIGxheWVycyBmcm9tIC9kYXRhIGluIGNhc2UgdXNlciBkb2Vzbid0IHBhc3MgbGF5ZXJzXG5cbiAgKiBVbHRpbWF0ZWx5LCB0aGUgZ29hbCBpcyB0byBnZXQgdGhlIHNvdXJjZSBpdGVtIGFuZCB0aGVpciBzaGFyaW5nIGRldGFpbCBmcm9tIGFsbCB0aGUgZGVwZW5kZW50IGxheWVyc1xuICovXG5jb25zdCBnZXRMYXllckFuZFNoYXJpbmdEZXRhaWwgPSBhc3luYyAobWFpbkl0ZW0sIHBvcnRhbCwgb3ZlcnJpZGVMYXllcnMpID0+IHtcbiAgICBsZXQgaXRlbXNUb0NoZWNrID0gW107XG4gICAgbGV0IGRlcGVuZGVudExheWVycyA9IFsuLi4ob3ZlcnJpZGVMYXllcnMgfHwgW10pXTtcbiAgICBsZXQgZ2V0RGF0YUVycm9yO1xuICAgIGlmICghKGRlcGVuZGVudExheWVycyA9PT0gbnVsbCB8fCBkZXBlbmRlbnRMYXllcnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRlcGVuZGVudExheWVycy5sZW5ndGgpKSB7XG4gICAgICAgIC8vIElmIHRoZSBjb25zdW1lciBkb2Vzbid0IHBhc3MgaW4gYW55IGxheWVycywgd2UgbmVlZCB0byBnZXQgdGhlIGxheWVycyBmcm9tIHRoZSBhY3R1YWwgZW5kcG9pbnRzXG4gICAgICAgIGNvbnN0IHsgZXJyb3IsIHJlc3VsdCB9ID0gYXdhaXQgZ2V0RGVwZW5kZW50SXRlbUxheWVycyhtYWluSXRlbSwgcG9ydGFsKTtcbiAgICAgICAgZ2V0RGF0YUVycm9yID0gZXJyb3I7XG4gICAgICAgIGRlcGVuZGVudExheWVycyA9IHJlc3VsdC5sYXllcnM7XG4gICAgICAgIGl0ZW1zVG9DaGVjayA9IHJlc3VsdC5pdGVtcztcbiAgICB9XG4gICAgaWYgKGdldERhdGFFcnJvcikge1xuICAgICAgICByZXR1cm4geyBlcnJvcjogZ2V0RGF0YUVycm9yIH07XG4gICAgfVxuICAgIGlmIChkZXBlbmRlbnRMYXllcnMubGVuZ3RoIDw9IDAgJiYgaXRlbXNUb0NoZWNrLmxlbmd0aCA8PSAwKSB7XG4gICAgICAgIHJldHVybiB7IGVycm9yOiB7IGNvZGU6IFwiZGF0YU5vdEF2YWlsYWJsZVwiIH0gfTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gRm9yIEJERlMgYW5kIERhdGEgU3RvcmUsIHdlIGFscmVhZHkgcmV0cmlldmUgdGhlIGRlcHMgaW4gZ2V0RGVwZW5kZW50SXRlbUxheWVycyB3aGljaCBpcyBhbHNvIHRoZSBzb3VyY2UgaXRlbXNcbiAgICAgICAgLy8gYW5kIHRoZXJlIGlzIG5vIG5lZWQgdG8gZ2V0IHRoZSBzb3VyY2UgaXRlbSBhZ2FpblxuICAgICAgICBpZiAobWFpbkl0ZW0udHlwZSAhPT0gXCJCaWcgRGF0YSBGaWxlIFNoYXJlXCIgJiYgbWFpbkl0ZW0udHlwZSAhPT0gXCJEYXRhIFN0b3JlXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgcmVzdWx0OiBkZXBlbmRlbnRMYXllclNvdXJjZUl0ZW1zLCBlcnJvciB9ID0gYXdhaXQgZ2V0U291cmNlSXRlbXNGcm9tRGVwZW5kZW50TGF5ZXJzKGRlcGVuZGVudExheWVycywgcG9ydGFsKTtcbiAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGVycm9yIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpdGVtc1RvQ2hlY2sucHVzaCguLi5kZXBlbmRlbnRMYXllclNvdXJjZUl0ZW1zLm1hcCgoeyBzb3VyY2VJdGVtIH0pID0+IHNvdXJjZUl0ZW0pKTtcbiAgICAgICAgfVxuICAgICAgICAvLyAqIEdyb3VwIHNoYXJpbmcgc3R1ZmZcbiAgICAgICAgY29uc3QgeyByZXN1bHQ6IG1haW5JdGVtU2hhcmluZ0dyb3VwcywgZXJyb3I6IGdldFNoYXJlZEdyb3Vwc0Vycm9yIH0gPSBhd2FpdCBnZXRMYXllclNoYXJlZEdyb3VwcyhtYWluSXRlbS5pZCwgcG9ydGFsKTtcbiAgICAgICAgaWYgKGdldFNoYXJlZEdyb3Vwc0Vycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4geyBlcnJvcjogZ2V0U2hhcmVkR3JvdXBzRXJyb3IgfTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTb21ldGltZXMgbGF5ZXJzIGNhbiBiZSBjcmVhdGVkIGZyb20gaGUgc2FtZSBzb3VyY2UgbGF5ZXJzIHNvIHdlIG5lZWQgdG8gbWFrZSBzdXJlIHdlIGRvbid0IGNoZWNrIHRoZSBzYW1lIHNvdXJjZSBpdGVtIG11bHRpcGxlIHRpbWVzXG4gICAgICAgIGNvbnN0IGFsbFNvdXJjZUl0ZW1zID0gdW5pcXVlQnkoaXRlbXNUb0NoZWNrLCAoaXRlbSkgPT4gaXRlbS5pZCk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IFByb21pc2UuYWxsKGFsbFNvdXJjZUl0ZW1zLm1hcChhc3luYyAoaXRlbSkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc2hhcmluZ0RldGFpbCA9IGF3YWl0IGdldEl0ZW1TaGFyaW5nRGV0YWlsKHtcbiAgICAgICAgICAgICAgICBzb3VyY2VJdGVtOiBpdGVtLFxuICAgICAgICAgICAgICAgIG1haW5JdGVtQWNjZXNzOiBtYWluSXRlbS5hY2Nlc3MsXG4gICAgICAgICAgICAgICAgbWFpbkl0ZW1TaGFyaW5nR3JvdXBzLFxuICAgICAgICAgICAgICAgIHBvcnRhbFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4geyBzb3VyY2VJdGVtOiBpdGVtLCBkZXRhaWw6IHNoYXJpbmdEZXRhaWwgfTtcbiAgICAgICAgfSkpO1xuICAgICAgICByZXR1cm4geyByZXN1bHQgfTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xuICAgICAgICByZXR1cm4geyBlcnJvcjogeyBjb2RlOiBcInVuaGFuZGxlZEVycm9yXCIgfSB9O1xuICAgIH1cbn07XG5hc3luYyBmdW5jdGlvbiBnZXRJdGVtU2hhcmluZ0RldGFpbCh7IG1haW5JdGVtQWNjZXNzLCBtYWluSXRlbVNoYXJpbmdHcm91cHMsIHBvcnRhbCwgc291cmNlSXRlbSB9KSB7XG4gICAgY29uc3QgeyBhY2Nlc3M6IHNvdXJjZUl0ZW1BY2Nlc3MsIGl0ZW1Db250cm9sIH0gPSBzb3VyY2VJdGVtO1xuICAgIGNvbnN0IHNoYXJpbmdEZXRhaWwgPSBPYmplY3QuYXNzaWduKHt9LCBERUZBVUxUX1NIQVJJTkdfREVUQUlMUyk7XG4gICAgY29uc3QgaXNNYWluSXRlbVNoYXJpbmdUb1B1YmxpYyA9IG1haW5JdGVtQWNjZXNzID09PSBcInB1YmxpY1wiO1xuICAgIGlmIChpc0Jsb2NrZWRGcm9tU2hhcmluZ1RvUHVibGljKHNvdXJjZUl0ZW0pICYmIGlzTWFpbkl0ZW1TaGFyaW5nVG9QdWJsaWMpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgc2hhcmluZ0RldGFpbCksIHsgbmVlZHNTaGFyZUxldmVsVXBkYXRlOiB0cnVlLCBjYW5FZGl0U2hhcmVMZXZlbDogZmFsc2UgfSk7XG4gICAgfVxuICAgIC8vIENhbiBjdXJyZW50IHVzZXIgdXBkYXRlIHRoZSBzaGFyaW5nIG9uIHRoaXMgaXRlbSwgYW5kIGRvIHRoZXkgbmVlZCB0bywgaWYgdGhlIGxheWVyIGlzIHB1YmxpY1xuICAgIC8vIGl0IGRvZXNuJ3QgcmVhbGx5IG1hdHRlciBpZiB0aGV5IGNhbiBvciBjYW5ub3RcbiAgICBpZiAoc291cmNlSXRlbUFjY2VzcyAhPT0gXCJwdWJsaWNcIikge1xuICAgICAgICBzaGFyaW5nRGV0YWlsLmNhbkVkaXRTaGFyZUxldmVsID0gY2hlY2tDYW5VcGRhdGVTaGFyZUxldmVsKGl0ZW1Db250cm9sKTtcbiAgICAgICAgc2hhcmluZ0RldGFpbC5uZWVkc0dyb3VwVXBkYXRlID0gYXdhaXQgY2hlY2tOZWVkR3JvdXBVcGRhdGUoe1xuICAgICAgICAgICAgc291cmNlSXRlbSxcbiAgICAgICAgICAgIGlzTWFpbkl0ZW1TaGFyaW5nVG9QdWJsaWMsXG4gICAgICAgICAgICBtYWluSXRlbVNoYXJpbmdHcm91cHMsXG4gICAgICAgICAgICBwb3J0YWxcbiAgICAgICAgfSk7XG4gICAgICAgIHNoYXJpbmdEZXRhaWwubmVlZHNTaGFyZUxldmVsVXBkYXRlID0gY2hlY2tOZWVkU2hhcmVVcGRhdGUoe1xuICAgICAgICAgICAgbWFpbkl0ZW1BY2Nlc3MsXG4gICAgICAgICAgICBzb3VyY2VJdGVtQWNjZXNzXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gSXMgdGhpcyBpdGVtIGNvbnNpZGVyZWQgYSBwcmVtaXVtIGl0ZW1cbiAgICAgICAgc2hhcmluZ0RldGFpbC5wcmVtaXVtID0gaXNQcmVtaXVtQ29udGVudChzb3VyY2VJdGVtKTtcbiAgICB9XG4gICAgcmV0dXJuIHNoYXJpbmdEZXRhaWw7XG59XG5jb25zdCBjaGVja0NhblVwZGF0ZVNoYXJlTGV2ZWwgPSAoaXRlbUNvbnRyb2wpID0+IGl0ZW1Db250cm9sID09PSBcImFkbWluXCI7XG5jb25zdCBjaGVja0lmRGV2ZWxvcGVyQmFzZW1hcCA9IChpdGVtKSA9PiBpdGVtLnR5cGVLZXl3b3Jkcy5pbmNsdWRlcyhcIkRldmVsb3BlckJhc2VtYXBcIik7XG5jb25zdCBjaGVja05lZWRHcm91cFVwZGF0ZSA9IGFzeW5jICh7IHNvdXJjZUl0ZW0sIGlzTWFpbkl0ZW1TaGFyaW5nVG9QdWJsaWMsIHBvcnRhbCwgbWFpbkl0ZW1TaGFyaW5nR3JvdXBzIH0pID0+IHtcbiAgICAvLyBUT0RPOiByZW1vdmUgdGhpcyBvbmNlIHdlIGhhdmUgZmluZS1ncmFpbiBjaGVjayBmb3JcbiAgICAvLyAgaHR0cHM6Ly9kZXZ0b3BpYS5lc3JpLmNvbS9XZWJHSVMvYXJjZ2lzLWFwcC1jb21wb25lbnRzL3B1bGwvNDA2OFxuICAgIGlmIChpc01haW5JdGVtU2hhcmluZ1RvUHVibGljKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgeyByZXN1bHQ6IGxheWVyU2hhcmVkR3JvdXBzIH0gPSBhd2FpdCBnZXRMYXllclNoYXJlZEdyb3Vwcyhzb3VyY2VJdGVtLmlkLCBwb3J0YWwpO1xuICAgIHJldHVybiAhc2hhcmVkV2l0aFNhbWVHcm91cHMobWFpbkl0ZW1TaGFyaW5nR3JvdXBzLCBsYXllclNoYXJlZEdyb3Vwcyk7XG59O1xuY29uc3QgY2hlY2tOZWVkU2hhcmVVcGRhdGUgPSAoeyBtYWluSXRlbUFjY2Vzcywgc291cmNlSXRlbUFjY2VzcyB9KSA9PiBcbi8vIFwic2hhcmVkXCIgaXMgdGhlIHNhbWUgYXMgXCJwcml2YXRlXCIgd2l0aCBncm91cHMgc28gaXQgbmVlZHMgZ3JvdXAgdXBkYXRlLCBub3Qgc2hhcmUgdXBkYXRlXG4hKHNvdXJjZUl0ZW1BY2Nlc3MgPT09IFwicHJpdmF0ZVwiICYmIG1haW5JdGVtQWNjZXNzID09PSBcInNoYXJlZFwiKSAmJlxuICAgIGlzQWNjZXNzTGV2ZWxHcmVhdGVyKG1haW5JdGVtQWNjZXNzLCBzb3VyY2VJdGVtQWNjZXNzKTtcbmZ1bmN0aW9uIGlzUHJlbWl1bUNvbnRlbnQoaXRlbSkge1xuICAgIHJldHVybiBpc1N1YnNjcmliZXIoaXRlbSkgfHwgaXNQcmVtaXVtKGl0ZW0pO1xuICAgIC8vIHJldHVybiBzZWxlY3RlZFNoYXJlTGV2ZWwgIT09IFwicHVibGljXCIgPyBmYWxzZSA6IGlzU3Vic2NyaWJlcihpdGVtKSB8fCBpc1ByZW1pdW0oaXRlbSk7XG59XG5mdW5jdGlvbiBzaGFyZWRXaXRoU2FtZUdyb3VwcyhzaGFyZWRHcm91cHMsIGxheWVyU2hhcmVkR3JvdXBzKSB7XG4gICAgaWYgKHNoYXJlZEdyb3VwcyA9PT0gbnVsbCB8fCBzaGFyZWRHcm91cHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNoYXJlZEdyb3Vwcy5sZW5ndGgpIHtcbiAgICAgICAgLy8gV2UgdXNlIGBzaGFyZWRHcm91cHNgIHRvIGNoZWNrIHRoZSBvcmRlciBzaW5jZSB3ZSBvbmx5IG5lZWQgdG8gY2hlY2sgaWYgbGF5ZXJTaGFyZWRHcm91cHNcbiAgICAgICAgLy8gY29udGFpbnMgdGhlIHNhbWUgZ3JvdXBzIGluIHRoZSBzYW1lIG9yZGVyIGFzIHNoYXJlZEdyb3Vwcywgbm90IHRoZSBvdGhlciB3YXkgYXJvdW5kXG4gICAgICAgIGNvbnN0IGdyb3Vwc05vdFNoYXJlZFdpdGhMYXllciA9IHNoYXJlZEdyb3Vwcy5maWx0ZXIoKHZhbHVlKSA9PiAhKGxheWVyU2hhcmVkR3JvdXBzIHx8IFtdKS5pbmNsdWRlcyh2YWx1ZSkpO1xuICAgICAgICByZXR1cm4gZ3JvdXBzTm90U2hhcmVkV2l0aExheWVyLmxlbmd0aCA8PSAwO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbi8qKlxuICogU2hhcmUgYGl0ZW1zYCB3aXRoIGdyb3VwcyBmZXRjaCBmcm9tIGBzb3VyY2VJdGVtc0Zvckdyb3Vwc2BcbiAqL1xuYXN5bmMgZnVuY3Rpb24gc2hhcmVJdGVtc1RvU2hhcmVkR3JvdXBzKGl0ZW1zLCBzb3VyY2VJdGVtc0Zvckdyb3Vwcywgc2hhcmVMZXZlbCwgcG9ydGFsLCBzaG91bGRVcGRhdGVHcm91cCA9IHRydWUpIHtcbiAgICBjb25zdCB7IHVzZXIgfSA9IHBvcnRhbDtcbiAgICBjb25zdCBzaGFyZWRHcm91cHNMaXN0ID0gIXNob3VsZFVwZGF0ZUdyb3VwXG4gICAgICAgID8gW11cbiAgICAgICAgOiBhd2FpdCBQcm9taXNlLmFsbChzb3VyY2VJdGVtc0Zvckdyb3Vwcy5tYXAoYXN5bmMgKG1haW5JdGVtKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IHJlc3VsdDogZ3JvdXBJZHMgfSA9IGF3YWl0IGdldExheWVyU2hhcmVkR3JvdXBzKG1haW5JdGVtLmlkLCBwb3J0YWwpO1xuICAgICAgICAgICAgcmV0dXJuIGdyb3VwSWRzO1xuICAgICAgICB9KSk7XG4gICAgY29uc3QgZ3JvdXBJZHMgPSBzaGFyZWRHcm91cHNMaXN0LmZsYXQoMSk7XG4gICAgcmV0dXJuIHNoYXJlSXRlbXMoaXRlbXMsIHNoYXJlTGV2ZWwsIGdyb3VwSWRzLCB7IHBvcnRhbCwgdXNlciB9LCB0cnVlKTtcbn1cbi8vIGh0dHBzOi8vd3d3LmZpZ21hLmNvbS9maWxlL0JCbXcwaW9SdzBaUW1DcUZISmVIMk4vU2hhcmUtRmxvd2NoYXJ0LTU/dHlwZT13aGl0ZWJvYXJkJm5vZGUtaWQ9NDAxLTE0OSZ0PUU3N1prUHpUOGNib0dkdDctMFxuY29uc3QgZ2V0U2hhcmluZ0RldGFpbEJ1Y2tldCA9IGFzeW5jICh7IG1haW5JdGVtLCBzaGFyaW5nRGV0YWlsUmVzdWx0LCBwb3J0YWwgfSkgPT4ge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCB7IHNvdXJjZUl0ZW0sIGRldGFpbCB9ID0gc2hhcmluZ0RldGFpbFJlc3VsdDtcbiAgICBjb25zdCB7IGNhbkVkaXRTaGFyZUxldmVsLCBuZWVkc0dyb3VwVXBkYXRlLCBuZWVkc1NoYXJlTGV2ZWxVcGRhdGUsIHByZW1pdW0gfSA9IGRldGFpbDtcbiAgICBpZiAoZGV0YWlsLmJkZnNEYXRhc3RvcmUpIHtcbiAgICAgICAgcmV0dXJuIFwibmVlZEJERlNEYXRhc3RvcmVVcGRhdGVcIjtcbiAgICB9XG4gICAgaWYgKCFuZWVkc0dyb3VwVXBkYXRlICYmICFuZWVkc1NoYXJlTGV2ZWxVcGRhdGUgJiYgIXByZW1pdW0pIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmICghY2FuRWRpdFNoYXJlTGV2ZWwgJiYgIXByZW1pdW0pIHtcbiAgICAgICAgcmV0dXJuIFwibm90RWRpdGFibGVMYXllcnNcIjtcbiAgICB9XG4gICAgc3dpdGNoIChtYWluSXRlbS5hY2Nlc3MpIHtcbiAgICAgICAgY2FzZSBcInB1YmxpY1wiOlxuICAgICAgICAgICAgaWYgKHByZW1pdW0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJwcmVtaXVtTGF5ZXJzXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc291cmNlSXRlbS5hY2Nlc3MgIT09IFwicHVibGljXCIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkZXZlbG9wZXIgPSBpc0RldmVsb3Blcihwb3J0YWwuc3Vic2NyaXB0aW9uSW5mbyB8fCAoKF9hID0gcG9ydGFsLnNvdXJjZUpTT04pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zdWJzY3JpcHRpb25JbmZvKSk7XG4gICAgICAgICAgICAgICAgaWYgKGRldmVsb3BlciAmJiBpc0Jsb2NrZWRGcm9tRGV2ZWxvcGVyU2hhcmluZ1RvUHVibGljKHNvdXJjZUl0ZW0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcIm5vdEVkaXRhYmxlTGF5ZXJzXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChhd2FpdCBpc0VkaXRhYmxlSXRlbShzb3VyY2VJdGVtLCBwb3J0YWwpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGlzRGF0YUNvbGxlY3Rpb25MYXllciA9IHNvdXJjZUl0ZW0udHlwZUtleXdvcmRzLmluY2x1ZGVzKFwiUHVibGljIERhdGEgQ29sbGVjdGlvblwiKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlzRGF0YUNvbGxlY3Rpb25MYXllciA/IFwibmVlZEVkaXRhYmxlTGF5ZXJzXCIgOiBcIm5lZWREYXRhQ29sbGVjdGlvbkxheWVyc1wiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBcIm5lZWRzU2hhcmVMZXZlbFVwZGF0ZUxheWVyc1wiO1xuICAgICAgICBjYXNlIFwib3JnXCI6XG4gICAgICAgIGNhc2UgXCJzaGFyZWRcIjpcbiAgICAgICAgY2FzZSBcInByaXZhdGVcIjpcbiAgICAgICAgICAgIGlmIChwcmVtaXVtKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gXCJuZWVkc1NoYXJlTGV2ZWxVcGRhdGVMYXllcnNcIjtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGFzc2VydE5ldmVyKG1haW5JdGVtLmFjY2Vzcyk7XG4gICAgfVxufTtcbi8vIFdlIGRvbid0IGJsb3cgdXAgdGhlIGNhY2hlIGZvciBwb3J0YWwgaW5mbyBzaW5jZSB0aGF0IGluZm9ybWF0aW9uIHdpbGwgbm90IGxpa2VseSBiZSBjaGFuZ2VkXG5jb25zdCBkZXBlbmRlbmN5Q2hlY2tDYWNoZVR5cGVzID0gW1wiaXRlbURhdGFcIiwgXCJpdGVtTWV0YWRhdGFcIl07XG5jb25zdCBhc3NlcnROZXZlciA9IChhY2Nlc3MpID0+IHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFVuZXhwZWN0ZWQgc2hhcmUgbGV2ZWwgJHthY2Nlc3N9YCk7XG59O1xuXG5leHBvcnQgeyBhbmFseXplU2hhcmluZ0RldGFpbCBhcyBhLCBzaGFyZUl0ZW1zIGFzIGIsIGlzQmxvY2tlZEZyb21TaGFyaW5nVG9QdWJsaWMgYXMgYywgaXNCbG9ja2VkRnJvbURldmVsb3BlclNoYXJpbmdUb1B1YmxpYyBhcyBkLCBkZXBlbmRlbmN5Q2hlY2tDYWNoZVR5cGVzIGFzIGUsIGlzQWNjZXNzTGV2ZWxHcmVhdGVyIGFzIGksIHNoYXJlSXRlbXNUb1NoYXJlZEdyb3VwcyBhcyBzLCB1bnNoYXJlSXRlbXMgYXMgdSB9O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1zZXJ2aWNlcy02NmFlZTMxYi5qcy5tYXAiLCIvKiFcbiAqIEFsbCBtYXRlcmlhbCBjb3B5cmlnaHQgRVNSSSwgQWxsIFJpZ2h0cyBSZXNlcnZlZCwgdW5sZXNzIG90aGVyd2lzZSBzcGVjaWZpZWQuXG4gKiB2NC4wLjU4XG4gKi9cbmltcG9ydCB7IGggYXMgaXNPcmdVc2VyLCBqIGFzIGNhblNoYXJlSXRlbVRvR3JvdXAkMSwgYSBhcyBpc1B1YmxpY1VzZXIsIGsgYXMgY2FuU2hhcmVJdGVtVG9PcmcsIGIgYXMgaXNPcmdBZG1pbiwgbCBhcyBhZG1pbkNhblNoYXJlT3RoZXJzSXRlbVRvR3JvdXAsIGQgYXMgaXNDdXN0b21Sb2xlLCBtIGFzIGNhblNoYXJlT3RoZXJzSXRlbXNUb09yZywgbiBhcyBjYW5TaGFyZUl0ZW1Ub1B1YmxpYywgbyBhcyBjYW5TaGFyZU90aGVyc0l0ZW1zVG9QdWJsaWMsIHAgYXMgaGFzQWRtaW5TaGFyZVByaXZpbGVnZSwgaSBhcyBpc0RldmVsb3BlciB9IGZyb20gJy4vcHJpdmlsZWdlcy01YzM4MmY2MS5qcyc7XG5pbXBvcnQgeyBmIGFzIGFycmF5c0FyZUVxdWl2YWxlbnQgfSBmcm9tICcuL2Z1bmN0aW9uYWwtNDRkZThmY2YuanMnO1xuaW1wb3J0IHsgaSBhcyBpc093bmVyIH0gZnJvbSAnLi9pdGVtLTM1MzU1NTJkLmpzJztcbmltcG9ydCB7IGMgYXMgaXNCbG9ja2VkRnJvbVNoYXJpbmdUb1B1YmxpYywgZCBhcyBpc0Jsb2NrZWRGcm9tRGV2ZWxvcGVyU2hhcmluZ1RvUHVibGljIH0gZnJvbSAnLi9zZXJ2aWNlcy02NmFlZTMxYi5qcyc7XG5cbmNvbnN0IGdyb3Vwc0FyZU93bmVkQnlPcmcgPSAodXNlciwgZ3JvdXBEYXRhKSA9PiB7XG4gICAgY29uc3QgeyB1c2VybmFtZSwgb3JnSWQgfSA9IHVzZXI7XG4gICAgcmV0dXJuIGdyb3VwRGF0YS5ldmVyeSgoeyBncm91cCB9KSA9PiB7XG4gICAgICAgIGNvbnN0IGlzT3duZXIgPSB1c2VybmFtZSA9PT0gKGdyb3VwID09PSBudWxsIHx8IGdyb3VwID09PSB2b2lkIDAgPyB2b2lkIDAgOiBncm91cC5vd25lcik7XG4gICAgICAgIGNvbnN0IGlzT3duZWRCeU15T3JnID0gb3JnSWQgPT09IGdyb3VwLm9yZ0lkO1xuICAgICAgICByZXR1cm4gaXNPd25lciB8fCBpc093bmVkQnlNeU9yZztcbiAgICB9KTtcbn07XG5jb25zdCBjYW5TaGFyZUl0ZW1Ub0dyb3VwID0gKHNlbGVjdGVkR3JvdXBEYXRhLCB1c2VyKSA9PiB1c2VyQ2FuU2hhcmUodXNlcikgfHwgKGFkbWluQ2FuU2hhcmVPdGhlcnNJdGVtVG9Hcm91cCh1c2VyKSAmJiBncm91cHNBcmVPd25lZEJ5T3JnKHVzZXIsIHNlbGVjdGVkR3JvdXBEYXRhKSk7XG5jb25zdCB1c2VyQ2FuU2hhcmUgPSAodXNlcikgPT4gIWlzT3JnVXNlcih1c2VyKSB8fCB1c2VyQ2FuU2hhcmVJdGVtVG9Hcm91cCh1c2VyKTtcbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBncm91cHMgYXJlIGluIGEgbWl4ZWQgc3RhdGUgd2hlcmUgYXQgbGVhc3Qgb25lIGdyb3VwIGlzIHNoYXJlZCB3aXRoIGRpZmZlcmVudCBpdGVtcyB0aGFuIHRoZSByZXN0XG4gKi9cbmNvbnN0IGNoZWNrSWZTaGFyaW5nTWl4ZWQgPSAoaXRlbXMsIHNlbGVjdGVkR3JvdXBzKSA9PiBzZWxlY3RlZEdyb3Vwcy5zb21lKCh7IHNlbGVjdGVkQnlJdGVtSWRzIH0pID0+IHNlbGVjdGVkQnlJdGVtSWRzLmxlbmd0aCAhPT0gaXRlbXMubGVuZ3RoKTtcbi8qKlxuICogQ2hlY2tzIHdoZXRoZXIgdGhlIHVzZXIgaXMgYWxsb3dlZCB0byBzaGFyZSB0aGVpciBpdGVtIHRvIGdyb3Vwc1xuICovXG5mdW5jdGlvbiB1c2VyQ2FuU2hhcmVJdGVtVG9Hcm91cCh1c2VyKSB7XG4gICAgcmV0dXJuICh1c2VyLnByaXZpbGVnZXMgfHwgW10pLmluY2x1ZGVzKFwicG9ydGFsOnVzZXI6c2hhcmVUb0dyb3VwXCIpO1xufVxuY29uc3QgcHJpdmF0ZUl0ZW1zSGF2ZUJlZW5TaGFyZWRUb0dyb3VwcyA9ICh7IGl0ZW1zLCBncm91cERhdGEgfSkgPT4gaXRlbXNcbiAgICAuZmlsdGVyKChpdGVtKSA9PiB7XG4gICAgY29uc3QgYWNjZXNzID0gaXRlbS5hY2Nlc3M7XG4gICAgcmV0dXJuIGFjY2VzcyA9PT0gXCJwcml2YXRlXCIgfHwgYWNjZXNzID09PSBcInNoYXJlZFwiO1xufSlcbiAgICAucmVkdWNlKChtZW1vLCBpdGVtKSA9PiBtZW1vIHx8IGl0ZW1IYXNCZWVuU2hhcmVkVG9Hcm91cHMoeyBpdGVtLCBncm91cERhdGEgfSksIGZhbHNlKTtcbmNvbnN0IGl0ZW1IYXNCZWVuU2hhcmVkVG9Hcm91cHMgPSAoeyBpdGVtLCBncm91cERhdGEgfSkgPT4gZ3JvdXBEYXRhLnJlZHVjZSgobWVtbywgZ3JvdXBEYXRhKSA9PiBtZW1vIHx8ICghIWdyb3VwRGF0YS5zZWxlY3RlZEJ5SXRlbUlkcyAmJiBncm91cERhdGEuc2VsZWN0ZWRCeUl0ZW1JZHMuaW5jbHVkZXMoaXRlbS5pZCkpLCBmYWxzZSk7XG5jb25zdCBzaG93RWRpdEdyb3VwV2FybmluZyA9ICh1c2VyLCBzZWxlY3RlZFNoYXJlTGV2ZWxzKSA9PiAhaXNPcmdVc2VyKHVzZXIpICYmXG4gICAgIWNhblNoYXJlSXRlbVRvR3JvdXAkMSh1c2VyKSAmJlxuICAgIC8vIFRoZXkgY2FuJ3Qgc2hhcmUgdG8gb3JnIGFueXdheSBzbyBubyBuZWVkIHRvIGNoZWNrIHRoYXRcbiAgICBzZWxlY3RlZFNoYXJlTGV2ZWxzLnNvbWUoKHNoYXJlTGV2ZWwpID0+IHNoYXJlTGV2ZWwgPT09IFwicHJpdmF0ZVwiKTtcbmNvbnN0IHNob3dSZXZlcnRHcm91cFdhcm5pbmcgPSAodXNlciwgc2VsZWN0ZWRTaGFyZUxldmVscywgaW5pdGlhbFNlbGVjdGVkR3JvdXBEYXRhKSA9PiBpc1B1YmxpY1VzZXIodXNlcikgJiZcbiAgICBzZWxlY3RlZFNoYXJlTGV2ZWxzLnNvbWUoKHNoYXJlTGV2ZWwpID0+IHNoYXJlTGV2ZWwgPT09IFwicHJpdmF0ZVwiKSAmJlxuICAgIGluaXRpYWxTZWxlY3RlZEdyb3VwRGF0YS5sZW5ndGggPiAwO1xuY29uc3Qgc2hvd1JldmVydFNoYXJlTGV2ZWxXYXJuaW5nID0gKHVzZXIsIGl0ZW1zLCBzZWxlY3RlZEdyb3VwRGF0YSkgPT4gIWlzT3JnVXNlcih1c2VyKSAmJlxuICAgICFjYW5TaGFyZUl0ZW1Ub09yZyh1c2VyKSAmJlxuICAgIHByaXZhdGVJdGVtc0hhdmVCZWVuU2hhcmVkVG9Hcm91cHMoeyBpdGVtcywgZ3JvdXBEYXRhOiBzZWxlY3RlZEdyb3VwRGF0YSB9KTtcbmNvbnN0IHNob3dTaGFyZUxldmVsQ2hhbmdlV2FybmluZyA9ICh1c2VyLCBuZXdTaGFyZUxldmVsLCBzZWxlY3RlZEdyb3VwRGF0YSkgPT4gIWlzT3JnQWRtaW4odXNlcikgJiZcbiAgICAhaXNPcmdVc2VyKHVzZXIpICYmXG4gICAgIWNhblNoYXJlSXRlbVRvT3JnKHVzZXIpICYmXG4gICAgbmV3U2hhcmVMZXZlbCA9PT0gXCJwcml2YXRlXCIgJiZcbiAgICBPYmplY3Qua2V5cyhzZWxlY3RlZEdyb3VwRGF0YSkubGVuZ3RoID4gMDtcblxuY29uc3QgZ2V0VXNlcm5hbWVRdWVyeSA9ICh7IHNoYXJlTW9kZSwgY3VycmVudFVzZXJuYW1lLCB1c2VyLCB1c2VyR3JvdXBMb29rdXAsIGlzUHJpdmF0ZSB9KSA9PiB7XG4gICAgdmFyIF9hO1xuICAgIGxldCBncm91cElkcyA9IFtdO1xuICAgIGxldCBncm91cElkc1F1ZXJ5O1xuICAgIGlmICh1c2VyR3JvdXBMb29rdXApIHtcbiAgICAgICAgbGV0IGN1cnJlbnRVc2VyR3JvdXBzID0gW107XG4gICAgICAgIGlmIChzaGFyZU1vZGUgPT09IFwiYWRtaW5cIiAmJiAoKF9hID0gdXNlckdyb3VwTG9va3VwW2N1cnJlbnRVc2VybmFtZV0pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5sZW5ndGgpICYmIGN1cnJlbnRVc2VybmFtZSAhPT0gdXNlci51c2VybmFtZSkge1xuICAgICAgICAgICAgLy8gSW4gYWRtaW4gY2FzZSwgd2Ugd2FudCB0byBhbHNvIGluY2x1ZGVzIGdyb3VwcyB0aGF0IHRoZSBpdGVtIG93bmVyIGhhcyBhY2Nlc3MgdG9cbiAgICAgICAgICAgIGN1cnJlbnRVc2VyR3JvdXBzID0gWy4uLnVzZXJHcm91cExvb2t1cFtjdXJyZW50VXNlcm5hbWVdXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2hhcmVNb2RlICE9PSBcImFkbWluXCIgfHwgIWlzUHJpdmF0ZSkge1xuICAgICAgICAgICAgLy8gRm9yIGFkbWluLCB3ZSBvbmx5IHdhbnQgdG8gaW5jbHVkZSB0aGUgYWRtaW4ncyBncm91cHMgaWYgdGhlIGl0ZW0gaXMgbm90IHByaXZhdGVcbiAgICAgICAgICAgIC8vIEZvciBwcml2YXRlIGl0ZW0gb3duZXIsIGluY2x1ZGVzIGdyb3VwcyB0aGF0IHRoZXkgY2FuIHNoYXJlIHRvXG4gICAgICAgICAgICB1c2VyR3JvdXBMb29rdXBbdXNlci51c2VybmFtZV0uZm9yRWFjaCgoZ3JvdXApID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIWN1cnJlbnRVc2VyR3JvdXBzLnNvbWUoKGcpID0+IGcuaWQgPT09IGdyb3VwLmlkKSkge1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50VXNlckdyb3Vwcy5wdXNoKGdyb3VwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50VXNlckdyb3VwcyA9PT0gbnVsbCB8fCBjdXJyZW50VXNlckdyb3VwcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY3VycmVudFVzZXJHcm91cHMuZm9yRWFjaCgoZ3JvdXApID0+IHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIC8vIGluY2x1ZGUgZ3JvdXAgaWRzIHRoYXQgdGhlIGN1cnJlbnQgdXNlciBpcyBvd25lciBvciBhZG1pbiBvciBpZiB2aWV3T25seSBpcyBmYWxzZVxuICAgICAgICAgICAgY29uc3QgbWVtYmVyVHlwZSA9IChfYSA9IGdyb3VwLnVzZXJNZW1iZXJzaGlwKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubWVtYmVyVHlwZTtcbiAgICAgICAgICAgIGlmIChncm91cC5pc1ZpZXdPbmx5ICYmIChtZW1iZXJUeXBlID09PSBcIm93bmVyXCIgfHwgbWVtYmVyVHlwZSA9PT0gXCJhZG1pblwiKSkge1xuICAgICAgICAgICAgICAgIGdyb3VwSWRzLnB1c2goZ3JvdXAuaWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgaWYgKGdyb3VwSWRzLmxlbmd0aCkge1xuICAgICAgICBncm91cElkc1F1ZXJ5ID0gYChpc3ZpZXdvbmx5OmZhbHNlIE9SIGlkOigke2dyb3VwSWRzLmpvaW4oXCIgT1IgXCIpfSkpYDtcbiAgICB9XG4gICAgY29uc3QgYWRtaW5Hcm91cFF1ZXJ5ID0gZ3JvdXBJZHMubGVuZ3RoID8gYCBPUiBpZDooJHtncm91cElkcy5qb2luKFwiIE9SIFwiKX0pYCA6IFwiXCI7XG4gICAgc3dpdGNoIChzaGFyZU1vZGUpIHtcbiAgICAgICAgLy8gSW4gdGhlIGRlZmF1bHQgKGl0ZW0gb3duZXIpIGNhc2UsIHdlIHdhbnQgdG8gc2hvdyBhbGwgdGhlIGdyb3Vwc1xuICAgICAgICAvLyB0aGF0IHRoZSB1c2VyIGVpdGhlciBvd25zIG9yIGhhcyB3cml0ZSBhY2Nlc3MgdG8uXG4gICAgICAgIC8vIFdyaXRlIGFjY2VzcyBpcyBpbmRpY2F0ZWQgYnkgdGhlIGlzdmlld29ubHkgZmxhZy5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gSWRlYWxseSwgd2UnZCBhbHNvIGJlIGFibGUgdG8gc2hvdyBncm91cHMgdGhlIGN1cnJlbnQgdXNlciBpcyBhZG1pbiBvZlxuICAgICAgICAvLyBtYXliZSB3aXRoIGEgc3ludGF4IGxpa2UgYWRtaW46JHtjdXJyZW50VXNlcm5hbWV9XG4gICAgICAgIC8vIGJ1dCB0aGUgc2VhcmNoIGVuZHBvaW50IGRvZXMgbm90IHN1cHBvcnQgdGhhdC5cbiAgICAgICAgY2FzZSBcImRlZmF1bHRcIjpcbiAgICAgICAgICAgIHJldHVybiBncm91cElkc1F1ZXJ5IHx8IGAob3duZXI6JHtjdXJyZW50VXNlcm5hbWV9IE9SIGlzdmlld29ubHk6ZmFsc2UpYDtcbiAgICAgICAgLy8gZ3JvdXAgb3duZXIgbW9kZSBzaG91bGQgb25seSBzZWUgZ3JvdXBzIG93bmVkIGJ5IHRoZSBjdXJyZW50IHVzZXJcbiAgICAgICAgLy8gZXhjbHVkaW5nIHNoYXJlZC11cGRhdGUgZ3JvdXBzXG4gICAgICAgIGNhc2UgXCJncm91cFwiOlxuICAgICAgICAgICAgcmV0dXJuIGBvd25lcjoke2N1cnJlbnRVc2VybmFtZX0gLWNhcGFiaWxpdGllczp1cGRhdGVpdGVtY29udHJvbGA7XG4gICAgICAgIC8vIEluIGFkbWluIGNhc2VzLCB3ZSB3YW50IGFsbCB0aGUgZ3JvdXBzIHRoZSBjdXJyZW50IHVzZXIgaXMgYSBtZW1iZXIgb2YuXG4gICAgICAgIC8vIHRoaXMgaXMgaGFuZGxlZCBieSB0aGUgc2VhcmNoVXNlckFjY2VzcyBhbmQgc2VhcmNoVXNlck5hbWUgcGFyYW1zXG4gICAgICAgIC8vIG91dHNpZGUgb2YgdGhlIHF1ZXJ5IHN0cmluZy5cbiAgICAgICAgY2FzZSBcImFkbWluXCI6XG4gICAgICAgICAgICBpZiAodXNlci51c2VybmFtZSA9PT0gY3VycmVudFVzZXJuYW1lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGAoaXN2aWV3b25seTpmYWxzZSR7YWRtaW5Hcm91cFF1ZXJ5fSBPUiBvd25lcjoke3VzZXIudXNlcm5hbWV9KSAtY2FwYWJpbGl0aWVzOnVwZGF0ZWl0ZW1jb250cm9sYDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFdoZW4gbG9va2luZyBhdCB0aGUgY29udGVudCB1c2VyJ3MgZ3JvdXBzLCBzaG93IHRoYXQgdXNlcidzIGdyb3Vwc1xuICAgICAgICAgICAgLy8gb3IgZ3JvdXBzIHRoZXkgaGF2ZSBhY2Nlc3MgdG8uXG4gICAgICAgICAgICAvLyBXZWJHSVMvYXJjZ2lzLXBvcnRhbC1hcHAjMjgwNDFcbiAgICAgICAgICAgIHJldHVybiBgKG93bmVyOiR7Y3VycmVudFVzZXJuYW1lfSBPUiBpc3ZpZXdvbmx5OmZhbHNlJHthZG1pbkdyb3VwUXVlcnl9KWA7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gXCJcIjtcbiAgICB9XG59O1xuXG5jb25zdCBERUZBVUxUX1NIQVJJTkdfREVUQUlMID0ge1xuICAgIG5lZWRFZGl0YWJsZUxheWVyczogW10sXG4gICAgbmVlZFB1YmxpY2x5RWRpdGFibGVMYXllcnM6IFtdLFxuICAgIG5lZWREYXRhQ29sbGVjdGlvbkxheWVyczogW10sXG4gICAgbmVlZHNTaGFyZUxldmVsVXBkYXRlTGF5ZXJzOiBbXSxcbiAgICBwcmVtaXVtTGF5ZXJzOiBbXSxcbiAgICBub3RFZGl0YWJsZUxheWVyczogW10sXG4gICAgbmVlZEF1dGhlbnRpY2F0aW9uOiBbXSxcbiAgICBuZWVkQkRGU0RhdGFzdG9yZVVwZGF0ZTogW11cbn07XG5jb25zdCBERUZBVUxUX1NIQVJFX0xFVkVMUyA9IFtcInByaXZhdGVcIiwgXCJvcmdcIiwgXCJwdWJsaWNcIl07XG5cbi8vIFRPRE86IGFkZCB1bml0IHRlc3Rcbi8qKlxuICogQ29tcG9zZSB0aGUgbGlzdCBvZiBpdGVtcy9ncm91cHMgdG8gc2hhcmUgYW5kIHVuc2hhcmVcbiAqXG4gKiAhIFRoaXMgYXNzdW1lIHdoZW4gd2Ugc2hhcmUvdW5zaGFyZSwgd2Ugc2hhcmUvdW5zaGFyZSB0byBhbGwgaXRlbXNcbiAqXG4gKiBVc2VmdWwgZm9yIC9zaGFyZUl0ZW1zIG9yIC91bnNoYXJlSXRlbXMgZW5kcG9pbnRzXG4gKiAgKi9cbmNvbnN0IGdldEl0ZW1zQW5kR3JvdXBzVG9VcGRhdGVTaGFyZSA9IChpbml0aWFsU2VsZWN0ZWRHcm91cERhdGEsIGN1clNlbGVjdGVkR3JvdXBEYXRhKSA9PiB7XG4gICAgLy8gMyBzdGF0ZXMgdG8gaGFuZGxlOlxuICAgIC8vIDE6IGdyb3VwcyB0aGF0IGFyZSBjb21wbGV0ZWx5IHVuc2hhcmVkIGZyb20gdGhlIGFsbCBpdGVtcyAtPiB1bnNoYXJlRGF0YVxuICAgIC8vIDI6IGdyb3VwcyB0aGF0IGFyZSBjb21wbGV0ZWx5IHNoYXJlZCB0byBhbGwgaXRlbXMgLT4gc2hhcmVEYXRhXG4gICAgLy8gMzogbWl4ZWQgc2hhcmluZyAtPiB3ZSBkb24ndCBjYXJlIC8vICEgaXQgd2lsbCBhZmZlY3QgdGhlIGFjdGl2aXR5IGxvZyBidXQgd2UgZG9uJ3QgY2FyZSBmb3Igbm93XG4gICAgY29uc3QgY29tcGxldGVseVVuc2hhcmVkR3JvdXBEYXRhID0gaW5pdGlhbFNlbGVjdGVkR3JvdXBEYXRhLmZpbHRlcigoZ3JvdXBEYXRhKSA9PiAhY3VyU2VsZWN0ZWRHcm91cERhdGEuc29tZSgoY3VyR3JvdXBEYXRhKSA9PiBjdXJHcm91cERhdGEuZ3JvdXAuaWQgPT09IGdyb3VwRGF0YS5ncm91cC5pZCkpO1xuICAgIGNvbnN0IGNvbXBsZXRlbHlTaGFyZWRHcm91cERhdGEgPSBjdXJTZWxlY3RlZEdyb3VwRGF0YS5maWx0ZXIoKGdyb3VwRGF0YSkgPT4ge1xuICAgICAgICBjb25zdCBpbml0aWFsR3JvdXBEYXRhID0gaW5pdGlhbFNlbGVjdGVkR3JvdXBEYXRhLmZpbmQoKGluaXRpYWxHcm91cERhdGEpID0+IGluaXRpYWxHcm91cERhdGEuZ3JvdXAuaWQgPT09IGdyb3VwRGF0YS5ncm91cC5pZCk7XG4gICAgICAgIC8vIFRoaXMgYXNzdW1lIHRoYXQgd2hlbiB3ZSBzaGFyZS91bnNoYXJlLCB3ZSBzaGFyZS91bnNoYXJlIHRvIGFsbCBpdGVtcyxcbiAgICAgICAgLy8gIHNvIHRoaXMgbWVhbnMgZ3JvdXBEYXRhLnNlbGVjdGVkQnlJdGVtSWRzLmxlbmd0aCBpcyBhbHJlYWR5IHRoZSBtYXhcbiAgICAgICAgLy8gVGhpcyB3b3VsZCBtYWtlIHRoZSB1dGlsIGluZGVwZW5kZW50IG9mIHRoZSBsZW5ndGggb2YgdGhlIGl0ZW1zIGFycmF5XG4gICAgICAgIHJldHVybiAhaW5pdGlhbEdyb3VwRGF0YSB8fCBpbml0aWFsR3JvdXBEYXRhLnNlbGVjdGVkQnlJdGVtSWRzLmxlbmd0aCA8IGdyb3VwRGF0YS5zZWxlY3RlZEJ5SXRlbUlkcy5sZW5ndGg7XG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdW5zaGFyZUdyb3VwSWRzOiBjb21wbGV0ZWx5VW5zaGFyZWRHcm91cERhdGEubWFwKChncm91cERhdGEpID0+IGdyb3VwRGF0YS5ncm91cC5pZCksXG4gICAgICAgIHNoYXJlR3JvdXBJZHM6IGNvbXBsZXRlbHlTaGFyZWRHcm91cERhdGEubWFwKChncm91cERhdGEpID0+IGdyb3VwRGF0YS5ncm91cC5pZClcbiAgICB9O1xufTtcbmNvbnN0IGdldFBvc3NpYmxlU2hhcmVMZXZlbCA9ICh1c2VyLCBpdGVtcywgcG9ydGFsKSA9PiB7XG4gICAgY29uc3QgaXNQdWJsaWNVc2VyJDEgPSBpc1B1YmxpY1VzZXIodXNlcik7XG4gICAgbGV0IHBvc3NpYmxlU2hhcmVMZXZlbE9wdGlvbnMgPSBERUZBVUxUX1NIQVJFX0xFVkVMUztcbiAgICBpZiAoaXNQdWJsaWNVc2VyJDEpIHtcbiAgICAgICAgcG9zc2libGVTaGFyZUxldmVsT3B0aW9ucyA9IFtcInByaXZhdGVcIiwgXCJwdWJsaWNcIl07XG4gICAgfVxuICAgIGVsc2UgaWYgKCFwb3J0YWwuY2FuU2hhcmVQdWJsaWMgJiYgIWlzT3JnQWRtaW4odXNlcikpIHtcbiAgICAgICAgcG9zc2libGVTaGFyZUxldmVsT3B0aW9ucyA9IFtcInByaXZhdGVcIiwgXCJvcmdcIl07XG4gICAgfVxuICAgIHBvc3NpYmxlU2hhcmVMZXZlbE9wdGlvbnMgPSBwb3NzaWJsZVNoYXJlTGV2ZWxPcHRpb25zLmZpbHRlcigoc2hhcmVMZXZlbCkgPT4gY2FuU2hhcmVMZXZlbChzaGFyZUxldmVsLCBpdGVtcywgdXNlciwgcG9ydGFsKSk7XG4gICAgcmV0dXJuIHBvc3NpYmxlU2hhcmVMZXZlbE9wdGlvbnM7XG59O1xuY29uc3QgY2FuU2hhcmVMZXZlbCA9IChzaGFyZUxldmVsLCBpdGVtcywgdXNlciwgcG9ydGFsKSA9PiB7XG4gICAgdmFyIF9hO1xuICAgIGlmIChzaGFyZUxldmVsID09PSBcInByaXZhdGVcIikge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY29uc3QgaXNPd25lck9mQWxsSXRlbXMgPSBpdGVtc093bmVkQnlVc2VyKHVzZXIsIGl0ZW1zKTtcbiAgICBjb25zdCBpdGVtc0JlbG9uZ1RvT3JnID0gaXRlbXNPd25lZEJ5T3JnKHVzZXIsIGl0ZW1zKTtcbiAgICBjb25zdCBpc0l0ZW1BZG1pbiA9IGlzT3JnQWRtaW4odXNlcikgJiYgIWlzQ3VzdG9tUm9sZSh1c2VyKSAmJiBpdGVtc0JlbG9uZ1RvT3JnO1xuICAgIGNvbnN0IGlzQ3VzdG9tSXRlbUFkbWluID0gaXNPcmdBZG1pbih1c2VyKSAmJiBpc0N1c3RvbVJvbGUodXNlcikgJiYgaXRlbXNCZWxvbmdUb09yZztcbiAgICBjb25zdCBpc1B1YmxpY1VzZXIkMSA9IGlzUHVibGljVXNlcih1c2VyKTtcbiAgICBpZiAoc2hhcmVMZXZlbCA9PT0gXCJvcmdcIikge1xuICAgICAgICBpZiAoaXNQdWJsaWNVc2VyJDEpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKChjYW5TaGFyZUl0ZW1Ub09yZyh1c2VyKSAmJiAoaXNPd25lck9mQWxsSXRlbXMgfHwgaXNJdGVtQWRtaW4pKSB8fFxuICAgICAgICAgICAgKGNhblNoYXJlT3RoZXJzSXRlbXNUb09yZyh1c2VyKSAmJiAoaXNJdGVtQWRtaW4gfHwgaXNDdXN0b21JdGVtQWRtaW4pKSk7XG4gICAgfVxuICAgIGlmIChzaGFyZUxldmVsID09PSBcInB1YmxpY1wiKSB7XG4gICAgICAgIGNvbnN0IGRldmVsb3BlciA9IGlzRGV2ZWxvcGVyKChwb3J0YWwgPT09IG51bGwgfHwgcG9ydGFsID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwb3J0YWwuc3Vic2NyaXB0aW9uSW5mbykgfHwgKChfYSA9IHBvcnRhbCA9PT0gbnVsbCB8fCBwb3J0YWwgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBvcnRhbC5zb3VyY2VKU09OKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc3Vic2NyaXB0aW9uSW5mbykpO1xuICAgICAgICBpZiAoaXRlbXMubGVuZ3RoID09PSAxICYmXG4gICAgICAgICAgICAoaXNCbG9ja2VkRnJvbVNoYXJpbmdUb1B1YmxpYyhpdGVtc1swXSkgfHwgKGRldmVsb3BlciAmJiBpc0Jsb2NrZWRGcm9tRGV2ZWxvcGVyU2hhcmluZ1RvUHVibGljKGl0ZW1zWzBdKSkpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2FuU2hhcmVQdWJsaWMgPSBwb3J0YWwuY2FuU2hhcmVQdWJsaWM7XG4gICAgICAgIHJldHVybiAoaXNQdWJsaWNVc2VyJDEgfHxcbiAgICAgICAgICAgIChjYW5TaGFyZUl0ZW1Ub1B1YmxpYyh1c2VyKSAmJiAoKGlzT3duZXJPZkFsbEl0ZW1zICYmIGNhblNoYXJlUHVibGljKSB8fCBpc0l0ZW1BZG1pbikpIHx8XG4gICAgICAgICAgICAoY2FuU2hhcmVPdGhlcnNJdGVtc1RvUHVibGljKHVzZXIpICYmIChpc0l0ZW1BZG1pbiB8fCBpc0N1c3RvbUl0ZW1BZG1pbikpKTtcbiAgICB9XG59O1xuLyoqXG4gKiBEZXRlcm1pbmUgdGhlIHNoYXJlIG1vZGUgb2YgdGhlIHVzZXIgYmFzZWQgb24gdGhlIGl0ZW0uXG4gKlxuICogISBXZSBvbmx5IGNvbnNpZGVyIHRoZSBmaXJzdCBpdGVtIG9uIHRoZSBsaXN0XG4gKi9cbmNvbnN0IGdldFNoYXJlTW9kZSA9IChpdGVtcywgdXNlciwgcG9ydGFsKSA9PiB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IGl0ZW0gPSBpdGVtc1swXTtcbiAgICBpZiAoaXNPd25lcihpdGVtLCB1c2VyKSkge1xuICAgICAgICByZXR1cm4gXCJkZWZhdWx0XCI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGlmIHRoZXJlIGlzIG5vIG9yZyBpZCBvbiB0aGUgaXRlbSwgZGVkdWNlIHRoYXQgdGhlIHVzZXIgY2FuIGRvIGFkbWluIHRoaW5nc1xuICAgICAqXG4gICAgICogaWYgaXRlbS5vcmdJZCBpcyBwcmVzZW50LCBjaGVjayBlcXVhbGl0eSBhZ2FpbnN0IHBvcnRhbCB1c2VyJ3Mgb3JnXG4gICAgICovXG4gICAgY29uc3QgaXRlbU93bmVyQW5kVXNlclNhbWVPcmcgPSAoIWl0ZW0ub3JnSWQgJiYgISgoX2EgPSBpdGVtLnNvdXJjZUpTT04pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5vcmdJZCkpIHx8IGl0ZW1zT3duZWRCeU9yZyh1c2VyLCBbaXRlbV0pO1xuICAgIGlmIChoYXNBZG1pblNoYXJlUHJpdmlsZWdlKHsgaXRlbXMsIHVzZXIsIHBvcnRhbCB9KSAmJiBpdGVtT3duZXJBbmRVc2VyU2FtZU9yZykge1xuICAgICAgICByZXR1cm4gXCJhZG1pblwiO1xuICAgIH1cbiAgICAvLyBpZiB0aGUgdXNlciBpcyBub3QgaXRlbSBvd25lciBvciBvcmcgYWRtaW4sIHRoZXkgZW50ZXIgZ3JvdXAgc2hhcmluZyBtb2RlXG4gICAgLy8gd2hpY2ggaXMgdmVyeSByZXN0cmljdGVkXG4gICAgcmV0dXJuIFwiZ3JvdXBcIjtcbn07XG5jb25zdCBpdGVtc093bmVkQnlVc2VyID0gKHVzZXIsIGl0ZW1zKSA9PiB7XG4gICAgcmV0dXJuIGl0ZW1zLmV2ZXJ5KChpdGVtKSA9PiBpc093bmVyKGl0ZW0sIHVzZXIpKTtcbn07XG5jb25zdCBpdGVtc093bmVkQnlPcmcgPSAodXNlciwgaXRlbXMpID0+IHtcbiAgICBjb25zdCB1c2VyT3JnSWQgPSB1c2VyID09PSBudWxsIHx8IHVzZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHVzZXIub3JnSWQ7XG4gICAgcmV0dXJuIGl0ZW1zLmV2ZXJ5KChpdGVtKSA9PiB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHJldHVybiAoaXNPd25lcihpdGVtLCB1c2VyKSB8fFxuICAgICAgICAgICAgaXRlbS5vcmdJZCA9PT0gdXNlck9yZ0lkIHx8XG4gICAgICAgICAgICAoKF9hID0gaXRlbS5zb3VyY2VKU09OKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Eub3JnSWQpID09PSB1c2VyT3JnSWQgfHxcbiAgICAgICAgICAgICgoX2IgPSBpdGVtLnBvcnRhbCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmlkKSA9PT0gdXNlck9yZ0lkIHx8XG4gICAgICAgICAgICBpdGVtLmlzT3JnSXRlbSk7XG4gICAgfSk7XG59O1xuY29uc3QgaXNTaGFyZUxldmVsRGlydHkgPSAoc2VsZWN0ZWRTaGFyZUxldmVscywgaW5pdGlhbFNoYXJlTGV2ZWxzLCBpdGVtcywgc2VsZWN0ZWRHcm91cERhdGEpID0+IHNlbGVjdGVkU2hhcmVMZXZlbHMuc29tZSgoY3VyU2hhcmVMZXZlbCwgaW5kZXgpID0+IHtcbiAgICBjb25zdCBpbml0aWFsU2hhcmVMZXZlbCA9IGluaXRpYWxTaGFyZUxldmVsc1tpbmRleF07XG4gICAgLy8gXCJzaGFyZWRcIiBsZXZlbCA9IHNoYXJlZCB0byBncm91cCArIFwicHJpdmF0ZVwiXG4gICAgaWYgKGluaXRpYWxTaGFyZUxldmVsID09PSBcInNoYXJlZFwiICYmIGN1clNoYXJlTGV2ZWwgPT09IFwicHJpdmF0ZVwiKSB7XG4gICAgICAgIGNvbnN0IGl0ZW0gPSBpdGVtc1tpbmRleF07XG4gICAgICAgIHJldHVybiAhc2VsZWN0ZWRHcm91cERhdGEuc29tZSgoZ3JvdXBEYXRhKSA9PiBncm91cERhdGEuc2VsZWN0ZWRCeUl0ZW1JZHMuaW5jbHVkZXMoaXRlbS5pZCkpO1xuICAgIH1cbiAgICByZXR1cm4gaW5pdGlhbFNoYXJlTGV2ZWwgIT09IGN1clNoYXJlTGV2ZWw7XG59KTtcbi8vIFRPRE86IG9wdGltaXplIHRoaXMgTyhuXjMpLi4uXG5jb25zdCBpc1NlbGVjdGVkR3JvdXBEYXRhRGlydHkgPSAoaW5pdGlhbFNlbGVjdGVkR3JvdXBEYXRhLCBjdXJTZWxlY3RlZEdyb3VwRGF0YSkgPT4ge1xuICAgIGlmIChpbml0aWFsU2VsZWN0ZWRHcm91cERhdGEubGVuZ3RoICE9PSBjdXJTZWxlY3RlZEdyb3VwRGF0YS5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBjdXJTZWxlY3RlZEdyb3VwRGF0YS5zb21lKChjdXJHcm91cERhdGEpID0+IHtcbiAgICAgICAgY29uc3QgaW5pdGlhbEdyb3VwRGF0YSA9IGluaXRpYWxTZWxlY3RlZEdyb3VwRGF0YS5maW5kKChpbml0aWFsR3JvdXBEYXRhKSA9PiBpbml0aWFsR3JvdXBEYXRhLmdyb3VwLmlkID09PSBjdXJHcm91cERhdGEuZ3JvdXAuaWQpO1xuICAgICAgICBpZiAoIWluaXRpYWxHcm91cERhdGEpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAhYXJyYXlzQXJlRXF1aXZhbGVudChpbml0aWFsR3JvdXBEYXRhLnNlbGVjdGVkQnlJdGVtSWRzLCBjdXJHcm91cERhdGEuc2VsZWN0ZWRCeUl0ZW1JZHMpO1xuICAgIH0pO1xufTtcblxuZXhwb3J0IHsgREVGQVVMVF9TSEFSSU5HX0RFVEFJTCBhcyBELCBnZXRVc2VybmFtZVF1ZXJ5IGFzIGEsIHNob3dSZXZlcnRHcm91cFdhcm5pbmcgYXMgYiwgc2hvd1JldmVydFNoYXJlTGV2ZWxXYXJuaW5nIGFzIGMsIERFRkFVTFRfU0hBUkVfTEVWRUxTIGFzIGQsIHNob3dTaGFyZUxldmVsQ2hhbmdlV2FybmluZyBhcyBlLCBpc1NoYXJlTGV2ZWxEaXJ0eSBhcyBmLCBnZXRJdGVtc0FuZEdyb3Vwc1RvVXBkYXRlU2hhcmUgYXMgZywgZ2V0UG9zc2libGVTaGFyZUxldmVsIGFzIGgsIGlzU2VsZWN0ZWRHcm91cERhdGFEaXJ0eSBhcyBpLCBnZXRTaGFyZU1vZGUgYXMgaiwgY2FuU2hhcmVJdGVtVG9Hcm91cCBhcyBrLCBjaGVja0lmU2hhcmluZ01peGVkIGFzIGwsIHNob3dFZGl0R3JvdXBXYXJuaW5nIGFzIHMgfTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbHMtZjRmNDRiODguanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9