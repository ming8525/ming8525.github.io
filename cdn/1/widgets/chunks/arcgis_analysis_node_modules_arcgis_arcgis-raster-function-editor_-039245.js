"use strict";
(self["webpackChunkexb_client"] = self["webpackChunkexb_client"] || []).push([["vendors-extensions_widgets_arcgis_analysis_node_modules_arcgis_arcgis-raster-function-editor_-039245"],{

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/arcgis-raster-function-editor/dist/esm/layer-helper-3867eef7.js":
/*!*********************************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/arcgis-raster-function-editor/dist/esm/layer-helper-3867eef7.js ***!
  \*********************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   a: () => (/* binding */ createDefaultRasterRFxVariable),
/* harmony export */   b: () => (/* binding */ getLayerUrl),
/* harmony export */   c: () => (/* binding */ cloneRasterJSON),
/* harmony export */   d: () => (/* binding */ getRasterJsonFromLayer),
/* harmony export */   e: () => (/* binding */ getLayerIdfromRasterValue),
/* harmony export */   f: () => (/* binding */ getImageServiceLayerItem),
/* harmony export */   g: () => (/* binding */ getLayerUrlWithoutToken),
/* harmony export */   h: () => (/* binding */ getFeatureLayerObject),
/* harmony export */   i: () => (/* binding */ isRasterTypeFloat),
/* harmony export */   j: () => (/* binding */ getLayerExtent),
/* harmony export */   k: () => (/* binding */ getGeometry),
/* harmony export */   l: () => (/* binding */ isChangeAnalysisTypeCCDC),
/* harmony export */   m: () => (/* binding */ checkLayerAllowAnalysis),
/* harmony export */   n: () => (/* binding */ filterLayersAllowAnalysis),
/* harmony export */   o: () => (/* binding */ createRasterRenderingLayer),
/* harmony export */   p: () => (/* binding */ createStrecthRenderer),
/* harmony export */   s: () => (/* binding */ sanitizeUrl)
/* harmony export */ });
/* harmony import */ var _arcgis_core_identity_IdentityManager_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @arcgis/core/identity/IdentityManager.js */ "@arcgis/core/identity/IdentityManager.js");
/* harmony import */ var _arcgis_core_core_lang_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @arcgis/core/core/lang.js */ "@arcgis/core/core/lang.js");
/* harmony import */ var _arcgis_core_core_urlUtils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @arcgis/core/core/urlUtils.js */ "@arcgis/core/core/urlUtils.js");
/* harmony import */ var _arcgis_core_layers_Layer_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @arcgis/core/layers/Layer.js */ "@arcgis/core/layers/Layer.js");
/* harmony import */ var _arcgis_core_layers_ImageryLayer_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @arcgis/core/layers/ImageryLayer.js */ "@arcgis/core/layers/ImageryLayer.js");
/* harmony import */ var _arcgis_core_smartMapping_raster_renderers_stretch_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @arcgis/core/smartMapping/raster/renderers/stretch.js */ "@arcgis/core/smartMapping/raster/renderers/stretch.js");
/* harmony import */ var _common_fda1462e_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./common-fda1462e.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/arcgis-raster-function-editor/dist/esm/common-fda1462e.js");
/* harmony import */ var _type_gaurds_1840747f_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./type-gaurds-1840747f.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/arcgis-raster-function-editor/dist/esm/type-gaurds-1840747f.js");
/* harmony import */ var _interfaces_d0c68944_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./interfaces-d0c68944.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/arcgis-raster-function-editor/dist/esm/interfaces-d0c68944.js");
/* harmony import */ var _Uint8Array_68e1e3f9_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./_Uint8Array-68e1e3f9.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/arcgis-raster-function-editor/dist/esm/_Uint8Array-68e1e3f9.js");
/* harmony import */ var _getTag_96af029d_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./_getTag-96af029d.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/arcgis-raster-function-editor/dist/esm/_getTag-96af029d.js");












/** Used to match property names within property paths. */
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
    reIsPlainProp = /^\w*$/;

/**
 * Checks if `value` is a property name and not a property path.
 *
 * @private
 * @param {*} value The value to check.
 * @param {Object} [object] The object to query keys on.
 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
 */
function isKey(value, object) {
  if ((0,_getTag_96af029d_js__WEBPACK_IMPORTED_MODULE_10__.a)(value)) {
    return false;
  }
  var type = typeof value;
  if (type == 'number' || type == 'symbol' || type == 'boolean' ||
      value == null || (0,_common_fda1462e_js__WEBPACK_IMPORTED_MODULE_6__.c)(value)) {
    return true;
  }
  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
    (object != null && value in Object(object));
}

/** Error message constants. */
var FUNC_ERROR_TEXT = 'Expected a function';

/**
 * Creates a function that memoizes the result of `func`. If `resolver` is
 * provided, it determines the cache key for storing the result based on the
 * arguments provided to the memoized function. By default, the first argument
 * provided to the memoized function is used as the map cache key. The `func`
 * is invoked with the `this` binding of the memoized function.
 *
 * **Note:** The cache is exposed as the `cache` property on the memoized
 * function. Its creation may be customized by replacing the `_.memoize.Cache`
 * constructor with one whose instances implement the
 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
 * method interface of `clear`, `delete`, `get`, `has`, and `set`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to have its output memoized.
 * @param {Function} [resolver] The function to resolve the cache key.
 * @returns {Function} Returns the new memoized function.
 * @example
 *
 * var object = { 'a': 1, 'b': 2 };
 * var other = { 'c': 3, 'd': 4 };
 *
 * var values = _.memoize(_.values);
 * values(object);
 * // => [1, 2]
 *
 * values(other);
 * // => [3, 4]
 *
 * object.a = 2;
 * values(object);
 * // => [1, 2]
 *
 * // Modify the result cache.
 * values.cache.set(object, ['a', 'b']);
 * values(object);
 * // => ['a', 'b']
 *
 * // Replace `_.memoize.Cache`.
 * _.memoize.Cache = WeakMap;
 */
function memoize(func, resolver) {
  if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  var memoized = function() {
    var args = arguments,
        key = resolver ? resolver.apply(this, args) : args[0],
        cache = memoized.cache;

    if (cache.has(key)) {
      return cache.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result) || cache;
    return result;
  };
  memoized.cache = new (memoize.Cache || _Uint8Array_68e1e3f9_js__WEBPACK_IMPORTED_MODULE_9__.M);
  return memoized;
}

// Expose `MapCache`.
memoize.Cache = _Uint8Array_68e1e3f9_js__WEBPACK_IMPORTED_MODULE_9__.M;

/** Used as the maximum memoize cache size. */
var MAX_MEMOIZE_SIZE = 500;

/**
 * A specialized version of `_.memoize` which clears the memoized function's
 * cache when it exceeds `MAX_MEMOIZE_SIZE`.
 *
 * @private
 * @param {Function} func The function to have its output memoized.
 * @returns {Function} Returns the new memoized function.
 */
function memoizeCapped(func) {
  var result = memoize(func, function(key) {
    if (cache.size === MAX_MEMOIZE_SIZE) {
      cache.clear();
    }
    return key;
  });

  var cache = result.cache;
  return result;
}

/** Used to match property names within property paths. */
var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

/** Used to match backslashes in property paths. */
var reEscapeChar = /\\(\\)?/g;

/**
 * Converts `string` to a property path array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the property path array.
 */
var stringToPath = memoizeCapped(function(string) {
  var result = [];
  if (string.charCodeAt(0) === 46 /* . */) {
    result.push('');
  }
  string.replace(rePropName, function(match, number, quote, subString) {
    result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));
  });
  return result;
});

/**
 * Casts `value` to a path array if it's not one.
 *
 * @private
 * @param {*} value The value to inspect.
 * @param {Object} [object] The object to query keys on.
 * @returns {Array} Returns the cast property path array.
 */
function castPath(value, object) {
  if ((0,_getTag_96af029d_js__WEBPACK_IMPORTED_MODULE_10__.a)(value)) {
    return value;
  }
  return isKey(value, object) ? [value] : stringToPath((0,_common_fda1462e_js__WEBPACK_IMPORTED_MODULE_6__.d)(value));
}

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/**
 * Converts `value` to a string key if it's not a string or symbol.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {string|symbol} Returns the key.
 */
function toKey(value) {
  if (typeof value == 'string' || (0,_common_fda1462e_js__WEBPACK_IMPORTED_MODULE_6__.c)(value)) {
    return value;
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

/**
 * The base implementation of `_.set`.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {Array|string} path The path of the property to set.
 * @param {*} value The value to set.
 * @param {Function} [customizer] The function to customize path creation.
 * @returns {Object} Returns `object`.
 */
function baseSet(object, path, value, customizer) {
  if (!(0,_getTag_96af029d_js__WEBPACK_IMPORTED_MODULE_10__.j)(object)) {
    return object;
  }
  path = castPath(path, object);

  var index = -1,
      length = path.length,
      lastIndex = length - 1,
      nested = object;

  while (nested != null && ++index < length) {
    var key = toKey(path[index]),
        newValue = value;

    if (key === '__proto__' || key === 'constructor' || key === 'prototype') {
      return object;
    }

    if (index != lastIndex) {
      var objValue = nested[key];
      newValue = customizer ? customizer(objValue, key, nested) : undefined;
      if (newValue === undefined) {
        newValue = (0,_getTag_96af029d_js__WEBPACK_IMPORTED_MODULE_10__.j)(objValue)
          ? objValue
          : ((0,_Uint8Array_68e1e3f9_js__WEBPACK_IMPORTED_MODULE_9__.i)(path[index + 1]) ? [] : {});
      }
    }
    (0,_Uint8Array_68e1e3f9_js__WEBPACK_IMPORTED_MODULE_9__.a)(nested, key, newValue);
    nested = nested[key];
  }
  return object;
}

/**
 * Sets the value at `path` of `object`. If a portion of `path` doesn't exist,
 * it's created. Arrays are created for missing index properties while objects
 * are created for all other missing properties. Use `_.setWith` to customize
 * `path` creation.
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @memberOf _
 * @since 3.7.0
 * @category Object
 * @param {Object} object The object to modify.
 * @param {Array|string} path The path of the property to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns `object`.
 * @example
 *
 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
 *
 * _.set(object, 'a[0].b.c', 4);
 * console.log(object.a[0].b.c);
 * // => 4
 *
 * _.set(object, ['x', '0', 'y', 'z'], 5);
 * console.log(object.x[0].y.z);
 * // => 5
 */
function set(object, path, value) {
  return object == null ? object : baseSet(object, path, value);
}

/**
 * Clone a RasterJSON obj.
 * @param {RasterJSON} rasterJSON to be cloned.
 * @returns A cloned copy of RasterJSON obj.
 */
function cloneRasterJSON(rasterJSON) {
    return _arcgis_core_core_lang_js__WEBPACK_IMPORTED_MODULE_1__.clone(rasterJSON);
}
/**
 * Create a new Raster RFxVariable with default props.
 * @returns A default Raster RFxVariable.
 */
function createDefaultRasterRFxVariable() {
    return _arcgis_core_core_lang_js__WEBPACK_IMPORTED_MODULE_1__.clone(_interfaces_d0c68944_js__WEBPACK_IMPORTED_MODULE_8__.d);
}
/**
 * Helper function for sanitizeTokensFromJobParams - splits the url into parts and removes the ?token
 * @param {string} url url to be sanitized
 * @returns {string} sanitized string
 */
function sanitizeUrl(url) {
    return _arcgis_core_core_urlUtils_js__WEBPACK_IMPORTED_MODULE_2__.urlToObject(url).path;
}
/**
 * gives a url without token.
 * @param url layer url.
 * @returns url without token.
 */
function getLayerUrlWithoutToken(url) {
    if (url?.indexOf("?token=") > 0) {
        url = url.slice(0, url.indexOf("?token="));
    }
    return url;
}
function getLayerUrl(inputLayer) {
    let inputURL = getLayerUrlWithoutToken(inputLayer?.url);
    if (inputLayer.type === "feature") {
        inputURL = `${inputURL}/${inputLayer.layerId ?? 0}`;
    }
    const credential = _arcgis_core_identity_IdentityManager_js__WEBPACK_IMPORTED_MODULE_0__["default"].findCredential(inputLayer.url);
    // Add credentials for secured services
    if (credential !== undefined) {
        inputURL = `${inputURL}${"?token="}${credential.token}`;
    }
    return inputURL;
}
/**
 * Converts an input layer to a RasterJSON object.
 * @param inputLayer The input layer to convert.
 * @returns The RasterJSON object.
 */
function getRasterJsonFromLayer(inputLayer) {
    const rURL = getLayerUrl(inputLayer);
    const rasterObj = { url: rURL, name: inputLayer.title };
    if (!(0,_type_gaurds_1840747f_js__WEBPACK_IMPORTED_MODULE_7__.i)(inputLayer.renderingRule)) {
        rasterObj.renderingRule = inputLayer.renderingRule.toJSON();
    }
    if (!(0,_type_gaurds_1840747f_js__WEBPACK_IMPORTED_MODULE_7__.i)(inputLayer.definitionExpression)) {
        let mosaicRule = inputLayer.mosaicRule;
        if (!(0,_type_gaurds_1840747f_js__WEBPACK_IMPORTED_MODULE_7__.i)(mosaicRule)) {
            mosaicRule = mosaicRule.clone();
            mosaicRule.where = inputLayer.definitionExpression;
            rasterObj.mosaicRule = mosaicRule.toJSON();
        }
    }
    else if (!(0,_type_gaurds_1840747f_js__WEBPACK_IMPORTED_MODULE_7__.i)(inputLayer.mosaicRule)) {
        rasterObj.mosaicRule = inputLayer.mosaicRule.toJSON?.();
    }
    return rasterObj;
}
function getLayerIdfromRasterValue(rasterArgValue, layers) {
    if ((0,_type_gaurds_1840747f_js__WEBPACK_IMPORTED_MODULE_7__.i)(rasterArgValue?.url) || (0,_type_gaurds_1840747f_js__WEBPACK_IMPORTED_MODULE_7__.i)(layers)) {
        return;
    }
    const url = sanitizeUrl(rasterArgValue.url);
    const selectedLayerId = layers.find((layer) => layer.url === url)?.id;
    return selectedLayerId;
}
function getImageServiceTitle(url) {
    const urlParts = url.split("/"), title = urlParts[urlParts.length - 2];
    return title;
}
/**
 * Helper function to create an ArcGISImageServiceLayer Object.
 * if input item has mosaicRule property we create it as a mosaicRule Object
 * if input item has renderingRule property we create it as a RasterFunction Object
 *
 * Used in RfxRasterArrayEditor and RfxRasterInput
 *
 * @param {*} item - object with layer name, url with optional mosaicRule
 * and renderingRule property.
 * @returns - ArcGISImageServiceLayer Object
 */
async function getImageServiceLayerItem(item) {
    if ((0,_type_gaurds_1840747f_js__WEBPACK_IMPORTED_MODULE_7__.i)(item?.url)) {
        return;
    }
    const layerItem = _arcgis_core_core_lang_js__WEBPACK_IMPORTED_MODULE_1__.clone(item);
    let layer = undefined;
    if (!layerItem.name) {
        layerItem.name = getImageServiceTitle(layerItem.url);
    }
    try {
        layer = await _arcgis_core_layers_Layer_js__WEBPACK_IMPORTED_MODULE_3__["default"].fromArcGISServerUrl({
            url: sanitizeUrl(item.url),
            properties: {
                renderingRule: item.renderingRule,
                mosaicRule: item.mosaicRule
            }
        });
        layer.name = item.name;
    }
    catch (error) {
        // console.log("Cant load the layer");
    }
    return layer;
}
/**
 * Helper function to create a FeatureLayer Object from FeatureJSON.
 *
 * Used in RFxFeatureSelect
 *
 * @param {FeatureJSON} featureJSON - feature JSON which contains layer name and url
 * @returns {Promise<__esri.FeatureLayer>} promise of feature layer object
 */
async function getFeatureLayerObject(featureJSON) {
    const featureUrl = featureJSON?.url, featureName = featureJSON?.name;
    if ((0,_type_gaurds_1840747f_js__WEBPACK_IMPORTED_MODULE_7__.i)(featureUrl)) {
        return;
    }
    let layer = undefined;
    try {
        layer = await _arcgis_core_layers_Layer_js__WEBPACK_IMPORTED_MODULE_3__["default"].fromArcGISServerUrl({
            url: sanitizeUrl(featureUrl)
        });
        layer.name = featureName;
    }
    catch (error) {
        console.error("Failed to load feature layer from RFT JSON.");
    }
    return layer;
}
function isRasterTypeFloat(pixelType) {
    // should give true for f32 and f64
    return pixelType?.toLocaleLowerCase().indexOf("f") >= 0;
}
function getLayerExtent(layer) {
    const extent = layer && (layer.extent || layer.fullExtent);
    if ((0,_type_gaurds_1840747f_js__WEBPACK_IMPORTED_MODULE_7__.i)(extent)) {
        return undefined;
    }
    const { xmin, ymin, xmax, ymax, spatialReference } = extent;
    const { wkid, latestWkid, wkt } = spatialReference;
    const newExtent = {
        xmin,
        ymin,
        xmax,
        ymax
    };
    if (!(0,_type_gaurds_1840747f_js__WEBPACK_IMPORTED_MODULE_7__.i)(wkid)) {
        set(newExtent, "spatialReference.wkid", wkid);
    }
    if (!(0,_type_gaurds_1840747f_js__WEBPACK_IMPORTED_MODULE_7__.i)(latestWkid)) {
        set(newExtent, "spatialReference.latestWkid", latestWkid);
    }
    if (!(0,_type_gaurds_1840747f_js__WEBPACK_IMPORTED_MODULE_7__.i)(wkt)) {
        set(newExtent, "spatialReference.wkt", wkt);
    }
    return newExtent;
}
// TODO ama10117 - implement function
// export function projectGeometrySpatialReference(geometry, outSR) {
//   const geometryService = new GeometryService(esriConfig.defaults.geometryService.url);
//   return geometryService.project(geometry, outSR);
// }
/**
 * Utility function to query geometries from a feature layer
 * @param featureLayer
 * @returns
 */
async function getGeometry(featureLayer) {
    if ((0,_type_gaurds_1840747f_js__WEBPACK_IMPORTED_MODULE_7__.i)(featureLayer)) {
        return Promise.resolve(undefined);
    }
    // const query = new Query();
    const query = {
        returnGeometry: true,
        where: "1 = 1"
    };
    const features = await featureLayer.queryFeatures(query);
    if ((0,_type_gaurds_1840747f_js__WEBPACK_IMPORTED_MODULE_7__.i)(features)) {
        return Promise.resolve(undefined);
    }
    const geoms = features.features?.map((feature) => feature?.geometry);
    return geoms;
}
function isChangeAnalysisTypeCCDC(layer) {
    const ChangeAnalysisParameters = layer?.rasterInfo?.keyProperties?.ChangeAnalysisParameters;
    const ChangeAnalysisType = ChangeAnalysisParameters?.AnalysisType;
    return ChangeAnalysisType === "CCDC";
}
/**
 * This function checks whether a layer is allowed for analysis
 * @param {SupportedImageryLayerTypes} layer mapLayer to be checked
 * @returns {boolean} true if layer is allowed for analysis and false otherwise
 */
function checkLayerAllowAnalysis(layer) {
    let allowedAnalysis = true;
    // check allowAnalysis flag from sourceJSON
    if (layer.sourceJSON?.allowAnalysis === false) {
        allowedAnalysis = false;
    }
    const isLayerHosted = layer.portalItem?.typeKeywords?.includes("Hosted Service") ?? false;
    if (isLayerHosted) {
        // if the hosted imagery layer is within the same org as user,
        // then it is considered as collocated service which analysis tool could directly access the source data.
        allowedAnalysis = layer.portalItem.isOrgItem ?? false ? true : allowedAnalysis;
    }
    return allowedAnalysis;
}
/**
 * This function filters a list of layers by checking allow analysis property and returns list of layers allowed for analysis
 * @param {SupportedImageryLayerTypes[]} layers mapLayers to be filtered
 * @returns {SupportedImageryLayerTypes[]} list of layers filtered allow for analysis
 */
function filterLayersAllowAnalysis(layers) {
    return layers.filter((layer) => checkLayerAllowAnalysis(layer));
}
function createRasterRenderingLayer(url, raster) {
    const rasterString = JSON.stringify(raster);
    //this is the best we can do with window.btoa(). Otherwise we should consider using a different library.
    // btoa() only support characters from String.fromCodePoint(0) up to String.fromCodePoint(255).
    // For Base64 characters with a code point 256 or higher you need to encode/decode these before and after.
    // const base64Value = window.btoa(unescape(encodeURIComponent(rasterString)));
    return new _arcgis_core_layers_ImageryLayer_js__WEBPACK_IMPORTED_MODULE_4__["default"]({ url, raster: btoa((0,_common_fda1462e_js__WEBPACK_IMPORTED_MODULE_6__.t)(rasterString)) });
}
function createStrecthRenderer(layer) {
    return _arcgis_core_smartMapping_raster_renderers_stretch_js__WEBPACK_IMPORTED_MODULE_5__.createRenderer({
        layer,
        stretchType: "min-max",
        dynamicRangeAdjustment: true,
        useGamma: false
    });
}



//# sourceMappingURL=layer-helper-3867eef7.js.map

/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid2lkZ2V0cy9jaHVua3MvYXJjZ2lzX2FuYWx5c2lzX25vZGVfbW9kdWxlc19hcmNnaXNfYXJjZ2lzLXJhc3Rlci1mdW5jdGlvbi1lZGl0b3JfLTAzOTI0NS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQThEO0FBQ1I7QUFDSTtBQUNUO0FBQ2M7QUFDK0I7QUFDWDtBQUNsQjtBQUNNO0FBQ21CO0FBQ3RCOztBQUVwRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZCxXQUFXLFFBQVE7QUFDbkIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQSxNQUFNLHVEQUFPO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsc0RBQVE7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckIsV0FBVyxVQUFVO0FBQ3JCLGFBQWEsVUFBVTtBQUN2QjtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxzREFBUTtBQUNqRDtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCLHNEQUFROztBQUV4QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckIsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNB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QztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFd2Q7O0FBRXhkIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZXhiLWNsaWVudC8uL2V4dGVuc2lvbnMvd2lkZ2V0cy9hcmNnaXMvYW5hbHlzaXMvbm9kZV9tb2R1bGVzL0BhcmNnaXMvYXJjZ2lzLXJhc3Rlci1mdW5jdGlvbi1lZGl0b3IvZGlzdC9lc20vbGF5ZXItaGVscGVyLTM4NjdlZWY3LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBlc3JpSWQgZnJvbSAnQGFyY2dpcy9jb3JlL2lkZW50aXR5L0lkZW50aXR5TWFuYWdlci5qcyc7XG5pbXBvcnQgKiBhcyBlc3JpTGFuZyBmcm9tICdAYXJjZ2lzL2NvcmUvY29yZS9sYW5nLmpzJztcbmltcG9ydCAqIGFzIHVybFV0aWxzIGZyb20gJ0BhcmNnaXMvY29yZS9jb3JlL3VybFV0aWxzLmpzJztcbmltcG9ydCBMYXllciBmcm9tICdAYXJjZ2lzL2NvcmUvbGF5ZXJzL0xheWVyLmpzJztcbmltcG9ydCBJbWFnZXJ5TGF5ZXIgZnJvbSAnQGFyY2dpcy9jb3JlL2xheWVycy9JbWFnZXJ5TGF5ZXIuanMnO1xuaW1wb3J0ICogYXMgcmFzdGVyU3RyZXRjaENyZWF0b3IgZnJvbSAnQGFyY2dpcy9jb3JlL3NtYXJ0TWFwcGluZy9yYXN0ZXIvcmVuZGVyZXJzL3N0cmV0Y2guanMnO1xuaW1wb3J0IHsgYyBhcyBpc1N5bWJvbCwgZCBhcyB0b1N0cmluZywgdCBhcyB0b0JpbmFyeSB9IGZyb20gJy4vY29tbW9uLWZkYTE0NjJlLmpzJztcbmltcG9ydCB7IGkgYXMgaXNFbXB0eURhdGFJdGVtIH0gZnJvbSAnLi90eXBlLWdhdXJkcy0xODQwNzQ3Zi5qcyc7XG5pbXBvcnQgeyBkIGFzIGRlZmF1bHRSYXN0ZXJOb2RlUHJvcHMgfSBmcm9tICcuL2ludGVyZmFjZXMtZDBjNjg5NDQuanMnO1xuaW1wb3J0IHsgTSBhcyBNYXBDYWNoZSwgaSBhcyBpc0luZGV4LCBhIGFzIGFzc2lnblZhbHVlIH0gZnJvbSAnLi9fVWludDhBcnJheS02OGUxZTNmOS5qcyc7XG5pbXBvcnQgeyBhIGFzIGlzQXJyYXksIGogYXMgaXNPYmplY3QgfSBmcm9tICcuL19nZXRUYWctOTZhZjAyOWQuanMnO1xuXG4vKiogVXNlZCB0byBtYXRjaCBwcm9wZXJ0eSBuYW1lcyB3aXRoaW4gcHJvcGVydHkgcGF0aHMuICovXG52YXIgcmVJc0RlZXBQcm9wID0gL1xcLnxcXFsoPzpbXltcXF1dKnwoW1wiJ10pKD86KD8hXFwxKVteXFxcXF18XFxcXC4pKj9cXDEpXFxdLyxcbiAgICByZUlzUGxhaW5Qcm9wID0gL15cXHcqJC87XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBwcm9wZXJ0eSBuYW1lIGFuZCBub3QgYSBwcm9wZXJ0eSBwYXRoLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5IGtleXMgb24uXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHByb3BlcnR5IG5hbWUsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNLZXkodmFsdWUsIG9iamVjdCkge1xuICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIGlmICh0eXBlID09ICdudW1iZXInIHx8IHR5cGUgPT0gJ3N5bWJvbCcgfHwgdHlwZSA9PSAnYm9vbGVhbicgfHxcbiAgICAgIHZhbHVlID09IG51bGwgfHwgaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIHJlSXNQbGFpblByb3AudGVzdCh2YWx1ZSkgfHwgIXJlSXNEZWVwUHJvcC50ZXN0KHZhbHVlKSB8fFxuICAgIChvYmplY3QgIT0gbnVsbCAmJiB2YWx1ZSBpbiBPYmplY3Qob2JqZWN0KSk7XG59XG5cbi8qKiBFcnJvciBtZXNzYWdlIGNvbnN0YW50cy4gKi9cbnZhciBGVU5DX0VSUk9SX1RFWFQgPSAnRXhwZWN0ZWQgYSBmdW5jdGlvbic7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgbWVtb2l6ZXMgdGhlIHJlc3VsdCBvZiBgZnVuY2AuIElmIGByZXNvbHZlcmAgaXNcbiAqIHByb3ZpZGVkLCBpdCBkZXRlcm1pbmVzIHRoZSBjYWNoZSBrZXkgZm9yIHN0b3JpbmcgdGhlIHJlc3VsdCBiYXNlZCBvbiB0aGVcbiAqIGFyZ3VtZW50cyBwcm92aWRlZCB0byB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24uIEJ5IGRlZmF1bHQsIHRoZSBmaXJzdCBhcmd1bWVudFxuICogcHJvdmlkZWQgdG8gdGhlIG1lbW9pemVkIGZ1bmN0aW9uIGlzIHVzZWQgYXMgdGhlIG1hcCBjYWNoZSBrZXkuIFRoZSBgZnVuY2BcbiAqIGlzIGludm9rZWQgd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgdGhlIG1lbW9pemVkIGZ1bmN0aW9uLlxuICpcbiAqICoqTm90ZToqKiBUaGUgY2FjaGUgaXMgZXhwb3NlZCBhcyB0aGUgYGNhY2hlYCBwcm9wZXJ0eSBvbiB0aGUgbWVtb2l6ZWRcbiAqIGZ1bmN0aW9uLiBJdHMgY3JlYXRpb24gbWF5IGJlIGN1c3RvbWl6ZWQgYnkgcmVwbGFjaW5nIHRoZSBgXy5tZW1vaXplLkNhY2hlYFxuICogY29uc3RydWN0b3Igd2l0aCBvbmUgd2hvc2UgaW5zdGFuY2VzIGltcGxlbWVudCB0aGVcbiAqIFtgTWFwYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtcHJvcGVydGllcy1vZi10aGUtbWFwLXByb3RvdHlwZS1vYmplY3QpXG4gKiBtZXRob2QgaW50ZXJmYWNlIG9mIGBjbGVhcmAsIGBkZWxldGVgLCBgZ2V0YCwgYGhhc2AsIGFuZCBgc2V0YC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGhhdmUgaXRzIG91dHB1dCBtZW1vaXplZC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtyZXNvbHZlcl0gVGhlIGZ1bmN0aW9uIHRvIHJlc29sdmUgdGhlIGNhY2hlIGtleS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IG1lbW9pemVkIGZ1bmN0aW9uLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEsICdiJzogMiB9O1xuICogdmFyIG90aGVyID0geyAnYyc6IDMsICdkJzogNCB9O1xuICpcbiAqIHZhciB2YWx1ZXMgPSBfLm1lbW9pemUoXy52YWx1ZXMpO1xuICogdmFsdWVzKG9iamVjdCk7XG4gKiAvLyA9PiBbMSwgMl1cbiAqXG4gKiB2YWx1ZXMob3RoZXIpO1xuICogLy8gPT4gWzMsIDRdXG4gKlxuICogb2JqZWN0LmEgPSAyO1xuICogdmFsdWVzKG9iamVjdCk7XG4gKiAvLyA9PiBbMSwgMl1cbiAqXG4gKiAvLyBNb2RpZnkgdGhlIHJlc3VsdCBjYWNoZS5cbiAqIHZhbHVlcy5jYWNoZS5zZXQob2JqZWN0LCBbJ2EnLCAnYiddKTtcbiAqIHZhbHVlcyhvYmplY3QpO1xuICogLy8gPT4gWydhJywgJ2InXVxuICpcbiAqIC8vIFJlcGxhY2UgYF8ubWVtb2l6ZS5DYWNoZWAuXG4gKiBfLm1lbW9pemUuQ2FjaGUgPSBXZWFrTWFwO1xuICovXG5mdW5jdGlvbiBtZW1vaXplKGZ1bmMsIHJlc29sdmVyKSB7XG4gIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nIHx8IChyZXNvbHZlciAhPSBudWxsICYmIHR5cGVvZiByZXNvbHZlciAhPSAnZnVuY3Rpb24nKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgfVxuICB2YXIgbWVtb2l6ZWQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAga2V5ID0gcmVzb2x2ZXIgPyByZXNvbHZlci5hcHBseSh0aGlzLCBhcmdzKSA6IGFyZ3NbMF0sXG4gICAgICAgIGNhY2hlID0gbWVtb2l6ZWQuY2FjaGU7XG5cbiAgICBpZiAoY2FjaGUuaGFzKGtleSkpIHtcbiAgICAgIHJldHVybiBjYWNoZS5nZXQoa2V5KTtcbiAgICB9XG4gICAgdmFyIHJlc3VsdCA9IGZ1bmMuYXBwbHkodGhpcywgYXJncyk7XG4gICAgbWVtb2l6ZWQuY2FjaGUgPSBjYWNoZS5zZXQoa2V5LCByZXN1bHQpIHx8IGNhY2hlO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG4gIG1lbW9pemVkLmNhY2hlID0gbmV3IChtZW1vaXplLkNhY2hlIHx8IE1hcENhY2hlKTtcbiAgcmV0dXJuIG1lbW9pemVkO1xufVxuXG4vLyBFeHBvc2UgYE1hcENhY2hlYC5cbm1lbW9pemUuQ2FjaGUgPSBNYXBDYWNoZTtcblxuLyoqIFVzZWQgYXMgdGhlIG1heGltdW0gbWVtb2l6ZSBjYWNoZSBzaXplLiAqL1xudmFyIE1BWF9NRU1PSVpFX1NJWkUgPSA1MDA7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLm1lbW9pemVgIHdoaWNoIGNsZWFycyB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24nc1xuICogY2FjaGUgd2hlbiBpdCBleGNlZWRzIGBNQVhfTUVNT0laRV9TSVpFYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaGF2ZSBpdHMgb3V0cHV0IG1lbW9pemVkLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgbWVtb2l6ZWQgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG1lbW9pemVDYXBwZWQoZnVuYykge1xuICB2YXIgcmVzdWx0ID0gbWVtb2l6ZShmdW5jLCBmdW5jdGlvbihrZXkpIHtcbiAgICBpZiAoY2FjaGUuc2l6ZSA9PT0gTUFYX01FTU9JWkVfU0laRSkge1xuICAgICAgY2FjaGUuY2xlYXIoKTtcbiAgICB9XG4gICAgcmV0dXJuIGtleTtcbiAgfSk7XG5cbiAgdmFyIGNhY2hlID0gcmVzdWx0LmNhY2hlO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKiogVXNlZCB0byBtYXRjaCBwcm9wZXJ0eSBuYW1lcyB3aXRoaW4gcHJvcGVydHkgcGF0aHMuICovXG52YXIgcmVQcm9wTmFtZSA9IC9bXi5bXFxdXSt8XFxbKD86KC0/XFxkKyg/OlxcLlxcZCspPyl8KFtcIiddKSgoPzooPyFcXDIpW15cXFxcXXxcXFxcLikqPylcXDIpXFxdfCg/PSg/OlxcLnxcXFtcXF0pKD86XFwufFxcW1xcXXwkKSkvZztcblxuLyoqIFVzZWQgdG8gbWF0Y2ggYmFja3NsYXNoZXMgaW4gcHJvcGVydHkgcGF0aHMuICovXG52YXIgcmVFc2NhcGVDaGFyID0gL1xcXFwoXFxcXCk/L2c7XG5cbi8qKlxuICogQ29udmVydHMgYHN0cmluZ2AgdG8gYSBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgcHJvcGVydHkgcGF0aCBhcnJheS5cbiAqL1xudmFyIHN0cmluZ1RvUGF0aCA9IG1lbW9pemVDYXBwZWQoZnVuY3Rpb24oc3RyaW5nKSB7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgaWYgKHN0cmluZy5jaGFyQ29kZUF0KDApID09PSA0NiAvKiAuICovKSB7XG4gICAgcmVzdWx0LnB1c2goJycpO1xuICB9XG4gIHN0cmluZy5yZXBsYWNlKHJlUHJvcE5hbWUsIGZ1bmN0aW9uKG1hdGNoLCBudW1iZXIsIHF1b3RlLCBzdWJTdHJpbmcpIHtcbiAgICByZXN1bHQucHVzaChxdW90ZSA/IHN1YlN0cmluZy5yZXBsYWNlKHJlRXNjYXBlQ2hhciwgJyQxJykgOiAobnVtYmVyIHx8IG1hdGNoKSk7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufSk7XG5cbi8qKlxuICogQ2FzdHMgYHZhbHVlYCB0byBhIHBhdGggYXJyYXkgaWYgaXQncyBub3Qgb25lLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkga2V5cyBvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgY2FzdCBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuICovXG5mdW5jdGlvbiBjYXN0UGF0aCh2YWx1ZSwgb2JqZWN0KSB7XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICByZXR1cm4gaXNLZXkodmFsdWUsIG9iamVjdCkgPyBbdmFsdWVdIDogc3RyaW5nVG9QYXRoKHRvU3RyaW5nKHZhbHVlKSk7XG59XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIElORklOSVRZID0gMSAvIDA7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZyBrZXkgaWYgaXQncyBub3QgYSBzdHJpbmcgb3Igc3ltYm9sLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxuICogQHJldHVybnMge3N0cmluZ3xzeW1ib2x9IFJldHVybnMgdGhlIGtleS5cbiAqL1xuZnVuY3Rpb24gdG9LZXkodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJyB8fCBpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgdmFyIHJlc3VsdCA9ICh2YWx1ZSArICcnKTtcbiAgcmV0dXJuIChyZXN1bHQgPT0gJzAnICYmICgxIC8gdmFsdWUpID09IC1JTkZJTklUWSkgPyAnLTAnIDogcmVzdWx0O1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnNldGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgcGF0aCBjcmVhdGlvbi5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VTZXQob2JqZWN0LCBwYXRoLCB2YWx1ZSwgY3VzdG9taXplcikge1xuICBpZiAoIWlzT2JqZWN0KG9iamVjdCkpIHtcbiAgICByZXR1cm4gb2JqZWN0O1xuICB9XG4gIHBhdGggPSBjYXN0UGF0aChwYXRoLCBvYmplY3QpO1xuXG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gcGF0aC5sZW5ndGgsXG4gICAgICBsYXN0SW5kZXggPSBsZW5ndGggLSAxLFxuICAgICAgbmVzdGVkID0gb2JqZWN0O1xuXG4gIHdoaWxlIChuZXN0ZWQgIT0gbnVsbCAmJiArK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGtleSA9IHRvS2V5KHBhdGhbaW5kZXhdKSxcbiAgICAgICAgbmV3VmFsdWUgPSB2YWx1ZTtcblxuICAgIGlmIChrZXkgPT09ICdfX3Byb3RvX18nIHx8IGtleSA9PT0gJ2NvbnN0cnVjdG9yJyB8fCBrZXkgPT09ICdwcm90b3R5cGUnKSB7XG4gICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH1cblxuICAgIGlmIChpbmRleCAhPSBsYXN0SW5kZXgpIHtcbiAgICAgIHZhciBvYmpWYWx1ZSA9IG5lc3RlZFtrZXldO1xuICAgICAgbmV3VmFsdWUgPSBjdXN0b21pemVyID8gY3VzdG9taXplcihvYmpWYWx1ZSwga2V5LCBuZXN0ZWQpIDogdW5kZWZpbmVkO1xuICAgICAgaWYgKG5ld1ZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbmV3VmFsdWUgPSBpc09iamVjdChvYmpWYWx1ZSlcbiAgICAgICAgICA/IG9ialZhbHVlXG4gICAgICAgICAgOiAoaXNJbmRleChwYXRoW2luZGV4ICsgMV0pID8gW10gOiB7fSk7XG4gICAgICB9XG4gICAgfVxuICAgIGFzc2lnblZhbHVlKG5lc3RlZCwga2V5LCBuZXdWYWx1ZSk7XG4gICAgbmVzdGVkID0gbmVzdGVkW2tleV07XG4gIH1cbiAgcmV0dXJuIG9iamVjdDtcbn1cblxuLyoqXG4gKiBTZXRzIHRoZSB2YWx1ZSBhdCBgcGF0aGAgb2YgYG9iamVjdGAuIElmIGEgcG9ydGlvbiBvZiBgcGF0aGAgZG9lc24ndCBleGlzdCxcbiAqIGl0J3MgY3JlYXRlZC4gQXJyYXlzIGFyZSBjcmVhdGVkIGZvciBtaXNzaW5nIGluZGV4IHByb3BlcnRpZXMgd2hpbGUgb2JqZWN0c1xuICogYXJlIGNyZWF0ZWQgZm9yIGFsbCBvdGhlciBtaXNzaW5nIHByb3BlcnRpZXMuIFVzZSBgXy5zZXRXaXRoYCB0byBjdXN0b21pemVcbiAqIGBwYXRoYCBjcmVhdGlvbi5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgb2JqZWN0YC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuNy4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogW3sgJ2InOiB7ICdjJzogMyB9IH1dIH07XG4gKlxuICogXy5zZXQob2JqZWN0LCAnYVswXS5iLmMnLCA0KTtcbiAqIGNvbnNvbGUubG9nKG9iamVjdC5hWzBdLmIuYyk7XG4gKiAvLyA9PiA0XG4gKlxuICogXy5zZXQob2JqZWN0LCBbJ3gnLCAnMCcsICd5JywgJ3onXSwgNSk7XG4gKiBjb25zb2xlLmxvZyhvYmplY3QueFswXS55LnopO1xuICogLy8gPT4gNVxuICovXG5mdW5jdGlvbiBzZXQob2JqZWN0LCBwYXRoLCB2YWx1ZSkge1xuICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyBvYmplY3QgOiBiYXNlU2V0KG9iamVjdCwgcGF0aCwgdmFsdWUpO1xufVxuXG4vKipcbiAqIENsb25lIGEgUmFzdGVySlNPTiBvYmouXG4gKiBAcGFyYW0ge1Jhc3RlckpTT059IHJhc3RlckpTT04gdG8gYmUgY2xvbmVkLlxuICogQHJldHVybnMgQSBjbG9uZWQgY29weSBvZiBSYXN0ZXJKU09OIG9iai5cbiAqL1xuZnVuY3Rpb24gY2xvbmVSYXN0ZXJKU09OKHJhc3RlckpTT04pIHtcbiAgICByZXR1cm4gZXNyaUxhbmcuY2xvbmUocmFzdGVySlNPTik7XG59XG4vKipcbiAqIENyZWF0ZSBhIG5ldyBSYXN0ZXIgUkZ4VmFyaWFibGUgd2l0aCBkZWZhdWx0IHByb3BzLlxuICogQHJldHVybnMgQSBkZWZhdWx0IFJhc3RlciBSRnhWYXJpYWJsZS5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlRGVmYXVsdFJhc3RlclJGeFZhcmlhYmxlKCkge1xuICAgIHJldHVybiBlc3JpTGFuZy5jbG9uZShkZWZhdWx0UmFzdGVyTm9kZVByb3BzKTtcbn1cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIGZvciBzYW5pdGl6ZVRva2Vuc0Zyb21Kb2JQYXJhbXMgLSBzcGxpdHMgdGhlIHVybCBpbnRvIHBhcnRzIGFuZCByZW1vdmVzIHRoZSA/dG9rZW5cbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgdXJsIHRvIGJlIHNhbml0aXplZFxuICogQHJldHVybnMge3N0cmluZ30gc2FuaXRpemVkIHN0cmluZ1xuICovXG5mdW5jdGlvbiBzYW5pdGl6ZVVybCh1cmwpIHtcbiAgICByZXR1cm4gdXJsVXRpbHMudXJsVG9PYmplY3QodXJsKS5wYXRoO1xufVxuLyoqXG4gKiBnaXZlcyBhIHVybCB3aXRob3V0IHRva2VuLlxuICogQHBhcmFtIHVybCBsYXllciB1cmwuXG4gKiBAcmV0dXJucyB1cmwgd2l0aG91dCB0b2tlbi5cbiAqL1xuZnVuY3Rpb24gZ2V0TGF5ZXJVcmxXaXRob3V0VG9rZW4odXJsKSB7XG4gICAgaWYgKHVybD8uaW5kZXhPZihcIj90b2tlbj1cIikgPiAwKSB7XG4gICAgICAgIHVybCA9IHVybC5zbGljZSgwLCB1cmwuaW5kZXhPZihcIj90b2tlbj1cIikpO1xuICAgIH1cbiAgICByZXR1cm4gdXJsO1xufVxuZnVuY3Rpb24gZ2V0TGF5ZXJVcmwoaW5wdXRMYXllcikge1xuICAgIGxldCBpbnB1dFVSTCA9IGdldExheWVyVXJsV2l0aG91dFRva2VuKGlucHV0TGF5ZXI/LnVybCk7XG4gICAgaWYgKGlucHV0TGF5ZXIudHlwZSA9PT0gXCJmZWF0dXJlXCIpIHtcbiAgICAgICAgaW5wdXRVUkwgPSBgJHtpbnB1dFVSTH0vJHtpbnB1dExheWVyLmxheWVySWQgPz8gMH1gO1xuICAgIH1cbiAgICBjb25zdCBjcmVkZW50aWFsID0gZXNyaUlkLmZpbmRDcmVkZW50aWFsKGlucHV0TGF5ZXIudXJsKTtcbiAgICAvLyBBZGQgY3JlZGVudGlhbHMgZm9yIHNlY3VyZWQgc2VydmljZXNcbiAgICBpZiAoY3JlZGVudGlhbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlucHV0VVJMID0gYCR7aW5wdXRVUkx9JHtcIj90b2tlbj1cIn0ke2NyZWRlbnRpYWwudG9rZW59YDtcbiAgICB9XG4gICAgcmV0dXJuIGlucHV0VVJMO1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhbiBpbnB1dCBsYXllciB0byBhIFJhc3RlckpTT04gb2JqZWN0LlxuICogQHBhcmFtIGlucHV0TGF5ZXIgVGhlIGlucHV0IGxheWVyIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyBUaGUgUmFzdGVySlNPTiBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGdldFJhc3Rlckpzb25Gcm9tTGF5ZXIoaW5wdXRMYXllcikge1xuICAgIGNvbnN0IHJVUkwgPSBnZXRMYXllclVybChpbnB1dExheWVyKTtcbiAgICBjb25zdCByYXN0ZXJPYmogPSB7IHVybDogclVSTCwgbmFtZTogaW5wdXRMYXllci50aXRsZSB9O1xuICAgIGlmICghaXNFbXB0eURhdGFJdGVtKGlucHV0TGF5ZXIucmVuZGVyaW5nUnVsZSkpIHtcbiAgICAgICAgcmFzdGVyT2JqLnJlbmRlcmluZ1J1bGUgPSBpbnB1dExheWVyLnJlbmRlcmluZ1J1bGUudG9KU09OKCk7XG4gICAgfVxuICAgIGlmICghaXNFbXB0eURhdGFJdGVtKGlucHV0TGF5ZXIuZGVmaW5pdGlvbkV4cHJlc3Npb24pKSB7XG4gICAgICAgIGxldCBtb3NhaWNSdWxlID0gaW5wdXRMYXllci5tb3NhaWNSdWxlO1xuICAgICAgICBpZiAoIWlzRW1wdHlEYXRhSXRlbShtb3NhaWNSdWxlKSkge1xuICAgICAgICAgICAgbW9zYWljUnVsZSA9IG1vc2FpY1J1bGUuY2xvbmUoKTtcbiAgICAgICAgICAgIG1vc2FpY1J1bGUud2hlcmUgPSBpbnB1dExheWVyLmRlZmluaXRpb25FeHByZXNzaW9uO1xuICAgICAgICAgICAgcmFzdGVyT2JqLm1vc2FpY1J1bGUgPSBtb3NhaWNSdWxlLnRvSlNPTigpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKCFpc0VtcHR5RGF0YUl0ZW0oaW5wdXRMYXllci5tb3NhaWNSdWxlKSkge1xuICAgICAgICByYXN0ZXJPYmoubW9zYWljUnVsZSA9IGlucHV0TGF5ZXIubW9zYWljUnVsZS50b0pTT04/LigpO1xuICAgIH1cbiAgICByZXR1cm4gcmFzdGVyT2JqO1xufVxuZnVuY3Rpb24gZ2V0TGF5ZXJJZGZyb21SYXN0ZXJWYWx1ZShyYXN0ZXJBcmdWYWx1ZSwgbGF5ZXJzKSB7XG4gICAgaWYgKGlzRW1wdHlEYXRhSXRlbShyYXN0ZXJBcmdWYWx1ZT8udXJsKSB8fCBpc0VtcHR5RGF0YUl0ZW0obGF5ZXJzKSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHVybCA9IHNhbml0aXplVXJsKHJhc3RlckFyZ1ZhbHVlLnVybCk7XG4gICAgY29uc3Qgc2VsZWN0ZWRMYXllcklkID0gbGF5ZXJzLmZpbmQoKGxheWVyKSA9PiBsYXllci51cmwgPT09IHVybCk/LmlkO1xuICAgIHJldHVybiBzZWxlY3RlZExheWVySWQ7XG59XG5mdW5jdGlvbiBnZXRJbWFnZVNlcnZpY2VUaXRsZSh1cmwpIHtcbiAgICBjb25zdCB1cmxQYXJ0cyA9IHVybC5zcGxpdChcIi9cIiksIHRpdGxlID0gdXJsUGFydHNbdXJsUGFydHMubGVuZ3RoIC0gMl07XG4gICAgcmV0dXJuIHRpdGxlO1xufVxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdG8gY3JlYXRlIGFuIEFyY0dJU0ltYWdlU2VydmljZUxheWVyIE9iamVjdC5cbiAqIGlmIGlucHV0IGl0ZW0gaGFzIG1vc2FpY1J1bGUgcHJvcGVydHkgd2UgY3JlYXRlIGl0IGFzIGEgbW9zYWljUnVsZSBPYmplY3RcbiAqIGlmIGlucHV0IGl0ZW0gaGFzIHJlbmRlcmluZ1J1bGUgcHJvcGVydHkgd2UgY3JlYXRlIGl0IGFzIGEgUmFzdGVyRnVuY3Rpb24gT2JqZWN0XG4gKlxuICogVXNlZCBpbiBSZnhSYXN0ZXJBcnJheUVkaXRvciBhbmQgUmZ4UmFzdGVySW5wdXRcbiAqXG4gKiBAcGFyYW0geyp9IGl0ZW0gLSBvYmplY3Qgd2l0aCBsYXllciBuYW1lLCB1cmwgd2l0aCBvcHRpb25hbCBtb3NhaWNSdWxlXG4gKiBhbmQgcmVuZGVyaW5nUnVsZSBwcm9wZXJ0eS5cbiAqIEByZXR1cm5zIC0gQXJjR0lTSW1hZ2VTZXJ2aWNlTGF5ZXIgT2JqZWN0XG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGdldEltYWdlU2VydmljZUxheWVySXRlbShpdGVtKSB7XG4gICAgaWYgKGlzRW1wdHlEYXRhSXRlbShpdGVtPy51cmwpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbGF5ZXJJdGVtID0gZXNyaUxhbmcuY2xvbmUoaXRlbSk7XG4gICAgbGV0IGxheWVyID0gdW5kZWZpbmVkO1xuICAgIGlmICghbGF5ZXJJdGVtLm5hbWUpIHtcbiAgICAgICAgbGF5ZXJJdGVtLm5hbWUgPSBnZXRJbWFnZVNlcnZpY2VUaXRsZShsYXllckl0ZW0udXJsKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgbGF5ZXIgPSBhd2FpdCBMYXllci5mcm9tQXJjR0lTU2VydmVyVXJsKHtcbiAgICAgICAgICAgIHVybDogc2FuaXRpemVVcmwoaXRlbS51cmwpLFxuICAgICAgICAgICAgcHJvcGVydGllczoge1xuICAgICAgICAgICAgICAgIHJlbmRlcmluZ1J1bGU6IGl0ZW0ucmVuZGVyaW5nUnVsZSxcbiAgICAgICAgICAgICAgICBtb3NhaWNSdWxlOiBpdGVtLm1vc2FpY1J1bGVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGxheWVyLm5hbWUgPSBpdGVtLm5hbWU7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAvLyBjb25zb2xlLmxvZyhcIkNhbnQgbG9hZCB0aGUgbGF5ZXJcIik7XG4gICAgfVxuICAgIHJldHVybiBsYXllcjtcbn1cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRvIGNyZWF0ZSBhIEZlYXR1cmVMYXllciBPYmplY3QgZnJvbSBGZWF0dXJlSlNPTi5cbiAqXG4gKiBVc2VkIGluIFJGeEZlYXR1cmVTZWxlY3RcbiAqXG4gKiBAcGFyYW0ge0ZlYXR1cmVKU09OfSBmZWF0dXJlSlNPTiAtIGZlYXR1cmUgSlNPTiB3aGljaCBjb250YWlucyBsYXllciBuYW1lIGFuZCB1cmxcbiAqIEByZXR1cm5zIHtQcm9taXNlPF9fZXNyaS5GZWF0dXJlTGF5ZXI+fSBwcm9taXNlIG9mIGZlYXR1cmUgbGF5ZXIgb2JqZWN0XG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGdldEZlYXR1cmVMYXllck9iamVjdChmZWF0dXJlSlNPTikge1xuICAgIGNvbnN0IGZlYXR1cmVVcmwgPSBmZWF0dXJlSlNPTj8udXJsLCBmZWF0dXJlTmFtZSA9IGZlYXR1cmVKU09OPy5uYW1lO1xuICAgIGlmIChpc0VtcHR5RGF0YUl0ZW0oZmVhdHVyZVVybCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgbGF5ZXIgPSB1bmRlZmluZWQ7XG4gICAgdHJ5IHtcbiAgICAgICAgbGF5ZXIgPSBhd2FpdCBMYXllci5mcm9tQXJjR0lTU2VydmVyVXJsKHtcbiAgICAgICAgICAgIHVybDogc2FuaXRpemVVcmwoZmVhdHVyZVVybClcbiAgICAgICAgfSk7XG4gICAgICAgIGxheWVyLm5hbWUgPSBmZWF0dXJlTmFtZTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJGYWlsZWQgdG8gbG9hZCBmZWF0dXJlIGxheWVyIGZyb20gUkZUIEpTT04uXCIpO1xuICAgIH1cbiAgICByZXR1cm4gbGF5ZXI7XG59XG5mdW5jdGlvbiBpc1Jhc3RlclR5cGVGbG9hdChwaXhlbFR5cGUpIHtcbiAgICAvLyBzaG91bGQgZ2l2ZSB0cnVlIGZvciBmMzIgYW5kIGY2NFxuICAgIHJldHVybiBwaXhlbFR5cGU/LnRvTG9jYWxlTG93ZXJDYXNlKCkuaW5kZXhPZihcImZcIikgPj0gMDtcbn1cbmZ1bmN0aW9uIGdldExheWVyRXh0ZW50KGxheWVyKSB7XG4gICAgY29uc3QgZXh0ZW50ID0gbGF5ZXIgJiYgKGxheWVyLmV4dGVudCB8fCBsYXllci5mdWxsRXh0ZW50KTtcbiAgICBpZiAoaXNFbXB0eURhdGFJdGVtKGV4dGVudCkpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgY29uc3QgeyB4bWluLCB5bWluLCB4bWF4LCB5bWF4LCBzcGF0aWFsUmVmZXJlbmNlIH0gPSBleHRlbnQ7XG4gICAgY29uc3QgeyB3a2lkLCBsYXRlc3RXa2lkLCB3a3QgfSA9IHNwYXRpYWxSZWZlcmVuY2U7XG4gICAgY29uc3QgbmV3RXh0ZW50ID0ge1xuICAgICAgICB4bWluLFxuICAgICAgICB5bWluLFxuICAgICAgICB4bWF4LFxuICAgICAgICB5bWF4XG4gICAgfTtcbiAgICBpZiAoIWlzRW1wdHlEYXRhSXRlbSh3a2lkKSkge1xuICAgICAgICBzZXQobmV3RXh0ZW50LCBcInNwYXRpYWxSZWZlcmVuY2Uud2tpZFwiLCB3a2lkKTtcbiAgICB9XG4gICAgaWYgKCFpc0VtcHR5RGF0YUl0ZW0obGF0ZXN0V2tpZCkpIHtcbiAgICAgICAgc2V0KG5ld0V4dGVudCwgXCJzcGF0aWFsUmVmZXJlbmNlLmxhdGVzdFdraWRcIiwgbGF0ZXN0V2tpZCk7XG4gICAgfVxuICAgIGlmICghaXNFbXB0eURhdGFJdGVtKHdrdCkpIHtcbiAgICAgICAgc2V0KG5ld0V4dGVudCwgXCJzcGF0aWFsUmVmZXJlbmNlLndrdFwiLCB3a3QpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3RXh0ZW50O1xufVxuLy8gVE9ETyBhbWExMDExNyAtIGltcGxlbWVudCBmdW5jdGlvblxuLy8gZXhwb3J0IGZ1bmN0aW9uIHByb2plY3RHZW9tZXRyeVNwYXRpYWxSZWZlcmVuY2UoZ2VvbWV0cnksIG91dFNSKSB7XG4vLyAgIGNvbnN0IGdlb21ldHJ5U2VydmljZSA9IG5ldyBHZW9tZXRyeVNlcnZpY2UoZXNyaUNvbmZpZy5kZWZhdWx0cy5nZW9tZXRyeVNlcnZpY2UudXJsKTtcbi8vICAgcmV0dXJuIGdlb21ldHJ5U2VydmljZS5wcm9qZWN0KGdlb21ldHJ5LCBvdXRTUik7XG4vLyB9XG4vKipcbiAqIFV0aWxpdHkgZnVuY3Rpb24gdG8gcXVlcnkgZ2VvbWV0cmllcyBmcm9tIGEgZmVhdHVyZSBsYXllclxuICogQHBhcmFtIGZlYXR1cmVMYXllclxuICogQHJldHVybnNcbiAqL1xuYXN5bmMgZnVuY3Rpb24gZ2V0R2VvbWV0cnkoZmVhdHVyZUxheWVyKSB7XG4gICAgaWYgKGlzRW1wdHlEYXRhSXRlbShmZWF0dXJlTGF5ZXIpKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodW5kZWZpbmVkKTtcbiAgICB9XG4gICAgLy8gY29uc3QgcXVlcnkgPSBuZXcgUXVlcnkoKTtcbiAgICBjb25zdCBxdWVyeSA9IHtcbiAgICAgICAgcmV0dXJuR2VvbWV0cnk6IHRydWUsXG4gICAgICAgIHdoZXJlOiBcIjEgPSAxXCJcbiAgICB9O1xuICAgIGNvbnN0IGZlYXR1cmVzID0gYXdhaXQgZmVhdHVyZUxheWVyLnF1ZXJ5RmVhdHVyZXMocXVlcnkpO1xuICAgIGlmIChpc0VtcHR5RGF0YUl0ZW0oZmVhdHVyZXMpKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodW5kZWZpbmVkKTtcbiAgICB9XG4gICAgY29uc3QgZ2VvbXMgPSBmZWF0dXJlcy5mZWF0dXJlcz8ubWFwKChmZWF0dXJlKSA9PiBmZWF0dXJlPy5nZW9tZXRyeSk7XG4gICAgcmV0dXJuIGdlb21zO1xufVxuZnVuY3Rpb24gaXNDaGFuZ2VBbmFseXNpc1R5cGVDQ0RDKGxheWVyKSB7XG4gICAgY29uc3QgQ2hhbmdlQW5hbHlzaXNQYXJhbWV0ZXJzID0gbGF5ZXI/LnJhc3RlckluZm8/LmtleVByb3BlcnRpZXM/LkNoYW5nZUFuYWx5c2lzUGFyYW1ldGVycztcbiAgICBjb25zdCBDaGFuZ2VBbmFseXNpc1R5cGUgPSBDaGFuZ2VBbmFseXNpc1BhcmFtZXRlcnM/LkFuYWx5c2lzVHlwZTtcbiAgICByZXR1cm4gQ2hhbmdlQW5hbHlzaXNUeXBlID09PSBcIkNDRENcIjtcbn1cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBjaGVja3Mgd2hldGhlciBhIGxheWVyIGlzIGFsbG93ZWQgZm9yIGFuYWx5c2lzXG4gKiBAcGFyYW0ge1N1cHBvcnRlZEltYWdlcnlMYXllclR5cGVzfSBsYXllciBtYXBMYXllciB0byBiZSBjaGVja2VkXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiBsYXllciBpcyBhbGxvd2VkIGZvciBhbmFseXNpcyBhbmQgZmFsc2Ugb3RoZXJ3aXNlXG4gKi9cbmZ1bmN0aW9uIGNoZWNrTGF5ZXJBbGxvd0FuYWx5c2lzKGxheWVyKSB7XG4gICAgbGV0IGFsbG93ZWRBbmFseXNpcyA9IHRydWU7XG4gICAgLy8gY2hlY2sgYWxsb3dBbmFseXNpcyBmbGFnIGZyb20gc291cmNlSlNPTlxuICAgIGlmIChsYXllci5zb3VyY2VKU09OPy5hbGxvd0FuYWx5c2lzID09PSBmYWxzZSkge1xuICAgICAgICBhbGxvd2VkQW5hbHlzaXMgPSBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgaXNMYXllckhvc3RlZCA9IGxheWVyLnBvcnRhbEl0ZW0/LnR5cGVLZXl3b3Jkcz8uaW5jbHVkZXMoXCJIb3N0ZWQgU2VydmljZVwiKSA/PyBmYWxzZTtcbiAgICBpZiAoaXNMYXllckhvc3RlZCkge1xuICAgICAgICAvLyBpZiB0aGUgaG9zdGVkIGltYWdlcnkgbGF5ZXIgaXMgd2l0aGluIHRoZSBzYW1lIG9yZyBhcyB1c2VyLFxuICAgICAgICAvLyB0aGVuIGl0IGlzIGNvbnNpZGVyZWQgYXMgY29sbG9jYXRlZCBzZXJ2aWNlIHdoaWNoIGFuYWx5c2lzIHRvb2wgY291bGQgZGlyZWN0bHkgYWNjZXNzIHRoZSBzb3VyY2UgZGF0YS5cbiAgICAgICAgYWxsb3dlZEFuYWx5c2lzID0gbGF5ZXIucG9ydGFsSXRlbS5pc09yZ0l0ZW0gPz8gZmFsc2UgPyB0cnVlIDogYWxsb3dlZEFuYWx5c2lzO1xuICAgIH1cbiAgICByZXR1cm4gYWxsb3dlZEFuYWx5c2lzO1xufVxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGZpbHRlcnMgYSBsaXN0IG9mIGxheWVycyBieSBjaGVja2luZyBhbGxvdyBhbmFseXNpcyBwcm9wZXJ0eSBhbmQgcmV0dXJucyBsaXN0IG9mIGxheWVycyBhbGxvd2VkIGZvciBhbmFseXNpc1xuICogQHBhcmFtIHtTdXBwb3J0ZWRJbWFnZXJ5TGF5ZXJUeXBlc1tdfSBsYXllcnMgbWFwTGF5ZXJzIHRvIGJlIGZpbHRlcmVkXG4gKiBAcmV0dXJucyB7U3VwcG9ydGVkSW1hZ2VyeUxheWVyVHlwZXNbXX0gbGlzdCBvZiBsYXllcnMgZmlsdGVyZWQgYWxsb3cgZm9yIGFuYWx5c2lzXG4gKi9cbmZ1bmN0aW9uIGZpbHRlckxheWVyc0FsbG93QW5hbHlzaXMobGF5ZXJzKSB7XG4gICAgcmV0dXJuIGxheWVycy5maWx0ZXIoKGxheWVyKSA9PiBjaGVja0xheWVyQWxsb3dBbmFseXNpcyhsYXllcikpO1xufVxuZnVuY3Rpb24gY3JlYXRlUmFzdGVyUmVuZGVyaW5nTGF5ZXIodXJsLCByYXN0ZXIpIHtcbiAgICBjb25zdCByYXN0ZXJTdHJpbmcgPSBKU09OLnN0cmluZ2lmeShyYXN0ZXIpO1xuICAgIC8vdGhpcyBpcyB0aGUgYmVzdCB3ZSBjYW4gZG8gd2l0aCB3aW5kb3cuYnRvYSgpLiBPdGhlcndpc2Ugd2Ugc2hvdWxkIGNvbnNpZGVyIHVzaW5nIGEgZGlmZmVyZW50IGxpYnJhcnkuXG4gICAgLy8gYnRvYSgpIG9ubHkgc3VwcG9ydCBjaGFyYWN0ZXJzIGZyb20gU3RyaW5nLmZyb21Db2RlUG9pbnQoMCkgdXAgdG8gU3RyaW5nLmZyb21Db2RlUG9pbnQoMjU1KS5cbiAgICAvLyBGb3IgQmFzZTY0IGNoYXJhY3RlcnMgd2l0aCBhIGNvZGUgcG9pbnQgMjU2IG9yIGhpZ2hlciB5b3UgbmVlZCB0byBlbmNvZGUvZGVjb2RlIHRoZXNlIGJlZm9yZSBhbmQgYWZ0ZXIuXG4gICAgLy8gY29uc3QgYmFzZTY0VmFsdWUgPSB3aW5kb3cuYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQocmFzdGVyU3RyaW5nKSkpO1xuICAgIHJldHVybiBuZXcgSW1hZ2VyeUxheWVyKHsgdXJsLCByYXN0ZXI6IGJ0b2EodG9CaW5hcnkocmFzdGVyU3RyaW5nKSkgfSk7XG59XG5mdW5jdGlvbiBjcmVhdGVTdHJlY3RoUmVuZGVyZXIobGF5ZXIpIHtcbiAgICByZXR1cm4gcmFzdGVyU3RyZXRjaENyZWF0b3IuY3JlYXRlUmVuZGVyZXIoe1xuICAgICAgICBsYXllcixcbiAgICAgICAgc3RyZXRjaFR5cGU6IFwibWluLW1heFwiLFxuICAgICAgICBkeW5hbWljUmFuZ2VBZGp1c3RtZW50OiB0cnVlLFxuICAgICAgICB1c2VHYW1tYTogZmFsc2VcbiAgICB9KTtcbn1cblxuZXhwb3J0IHsgY3JlYXRlRGVmYXVsdFJhc3RlclJGeFZhcmlhYmxlIGFzIGEsIGdldExheWVyVXJsIGFzIGIsIGNsb25lUmFzdGVySlNPTiBhcyBjLCBnZXRSYXN0ZXJKc29uRnJvbUxheWVyIGFzIGQsIGdldExheWVySWRmcm9tUmFzdGVyVmFsdWUgYXMgZSwgZ2V0SW1hZ2VTZXJ2aWNlTGF5ZXJJdGVtIGFzIGYsIGdldExheWVyVXJsV2l0aG91dFRva2VuIGFzIGcsIGdldEZlYXR1cmVMYXllck9iamVjdCBhcyBoLCBpc1Jhc3RlclR5cGVGbG9hdCBhcyBpLCBnZXRMYXllckV4dGVudCBhcyBqLCBnZXRHZW9tZXRyeSBhcyBrLCBpc0NoYW5nZUFuYWx5c2lzVHlwZUNDREMgYXMgbCwgY2hlY2tMYXllckFsbG93QW5hbHlzaXMgYXMgbSwgZmlsdGVyTGF5ZXJzQWxsb3dBbmFseXNpcyBhcyBuLCBjcmVhdGVSYXN0ZXJSZW5kZXJpbmdMYXllciBhcyBvLCBjcmVhdGVTdHJlY3RoUmVuZGVyZXIgYXMgcCwgc2FuaXRpemVVcmwgYXMgcyB9O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1sYXllci1oZWxwZXItMzg2N2VlZjcuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9