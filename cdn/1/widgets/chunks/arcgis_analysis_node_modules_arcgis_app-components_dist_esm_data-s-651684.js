"use strict";
(self["webpackChunkexb_client"] = self["webpackChunkexb_client"] || []).push([["vendors-extensions_widgets_arcgis_analysis_node_modules_arcgis_app-components_dist_esm_data-s-651684"],{

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/data-store-e2ae6a67.js":
/*!****************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/data-store-e2ae6a67.js ***!
  \****************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   a: () => (/* binding */ addDataStore),
/* harmony export */   b: () => (/* binding */ requestCloudStoreList),
/* harmony export */   c: () => (/* binding */ validateDatastoreForServers),
/* harmony export */   d: () => (/* binding */ checkServersType),
/* harmony export */   e: () => (/* binding */ validateDatastoreServer),
/* harmony export */   f: () => (/* binding */ fetchCloudStorageRegionInfo),
/* harmony export */   g: () => (/* binding */ getDatastoreContents),
/* harmony export */   h: () => (/* binding */ handleDatabaseFileDrop),
/* harmony export */   p: () => (/* binding */ publishFromDataStore),
/* harmony export */   r: () => (/* binding */ requestCloudStoreInfo),
/* harmony export */   v: () => (/* binding */ validateDatastoreForOnline)
/* harmony export */ });
/* harmony import */ var _portal_d518b571_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./portal-d518b571.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/portal-d518b571.js");
/* harmony import */ var _service_8c2c4241_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./service-8c2c4241.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/service-8c2c4241.js");
/* harmony import */ var _config_75adf962_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./config-75adf962.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/config-75adf962.js");
/* harmony import */ var _functional_44de8fcf_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./functional-44de8fcf.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/functional-44de8fcf.js");
/* harmony import */ var _data_store_8e83fb7a_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./data-store-8e83fb7a.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/data-store-8e83fb7a.js");
/* harmony import */ var _feature_layer_573bb473_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./feature-layer-573bb473.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/feature-layer-573bb473.js");
/* harmony import */ var _server_item_8d384796_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./server-item-8d384796.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/server-item-8d384796.js");
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v4.0.58
 */








const pollForDataStoreJob = async (jobId, jobKey) => {
    var _a, _b;
    const portal = _config_75adf962_js__WEBPACK_IMPORTED_MODULE_2__.c.portal;
    const restBaseUrl = `${(_a = portal.restUrl) !== null && _a !== void 0 ? _a : portal.portalUrl}portals/${portal.id}`;
    const jobDetailsApiUrl = `${restBaseUrl}/jobs/${encodeURIComponent(jobId)}/?key=${encodeURIComponent(jobKey)}`;
    try {
        return {
            result: await (0,_portal_d518b571_js__WEBPACK_IMPORTED_MODULE_0__.p)(jobDetailsApiUrl, {
                pendingStatuses: ["processing", "submitted"],
                successStatuses: ["succeeded"]
            }, "post")
        };
    }
    catch (error) {
        console.error(error);
        const errMessage = (_b = error.messages) === null || _b === void 0 ? void 0 : _b[0];
        if (errMessage === null || errMessage === void 0 ? void 0 : errMessage.includes("ERROR 000623")) {
            return { error: { code: "invalidDataStorePublishType" } };
        }
        return { error: { code: "unhandledError", message: JSON.stringify(error) } };
    }
};
const publishFromDataStore = async (dataStoreInfo, portal, 
/**
 * There is a tricky case where ImageServer needs to be use for cacheDataset instead of MapServer
 *
 * Currently, making another call to backend to check would be really long so we use retry as a faster workaround
 */
useRetryWorkaround) => {
    var _a;
    try {
        const { folder, type, cacheStoreId, serviceName, pathInCachedStore, description, serverId, tags } = dataStoreInfo;
        let configType;
        switch (type) {
            case "i3sRestCache":
            case "extractedScenePackage":
                configType = "SceneServer";
                break;
            case "vectorCacheDataset":
                configType = "VectorTileServer";
                break;
            case "cacheDataset":
                configType = useRetryWorkaround ? "ImageServer" : "MapServer";
                break;
        }
        // https://developers.arcgis.com/rest/users-groups-and-items/publish-datasets-to-datastore.htm
        const serviceConfiguration = JSON.stringify({
            type: configType,
            serviceName,
            properties: { pathInCachedStore, cacheStoreId }
        });
        const requestData = {
            serviceConfiguration,
            serverId,
            tags,
            f: "json"
        };
        const url = `${(0,_portal_d518b571_js__WEBPACK_IMPORTED_MODULE_0__.g)()}portals/self/datastores/publish`;
        const { jobId, key } = await (0,_portal_d518b571_js__WEBPACK_IMPORTED_MODULE_0__.r)(url, requestData, {}, "post");
        const { error, result } = await pollForDataStoreJob(jobId, key);
        if ((error === null || error === void 0 ? void 0 : error.code) === "invalidDataStorePublishType") {
            // Workaround as explain above
            return dataStoreInfo.type === "cacheDataset"
                ? publishFromDataStore(dataStoreInfo, portal, true)
                : { error: { code: "invalidDataStorePublishType", message: JSON.stringify(error.message) } };
        }
        else if (error) {
            return { error: { code: "failToPublishFromDataStore", message: JSON.stringify(error.message) } };
        }
        const resultService = (_a = result === null || result === void 0 ? void 0 : result.result) === null || _a === void 0 ? void 0 : _a.services[0];
        if (!(0,_feature_layer_573bb473_js__WEBPACK_IMPORTED_MODULE_5__.t)(folder)) {
            await (0,_server_item_8d384796_js__WEBPACK_IMPORTED_MODULE_6__.m)(resultService.serviceItemId, folder.id);
        }
        // publish API doesn't support changing the summary / snippet, so we make a separate call for it
        // https://developers.arcgis.com/rest/users-groups-and-items/update-item.htm
        const itemUpdateData = {
            snippet: description,
            f: "json"
        };
        await (0,_server_item_8d384796_js__WEBPACK_IMPORTED_MODULE_6__.u)(resultService.serviceItemId, itemUpdateData);
        return { result: resultService };
    }
    catch (error) {
        console.error(error);
        return { error: { code: "failToPublishFromDataStore", message: JSON.stringify(error) } };
    }
};
const getDatastoreContents = async (datastoreId, path, type, serverId) => {
    var _a;
    // https://developers.arcgis.com/rest/users-groups-and-items/describe-datastore.htm
    const portal = _config_75adf962_js__WEBPACK_IMPORTED_MODULE_2__.c.portal;
    const restBaseUrl = `${(_a = portal.restUrl) !== null && _a !== void 0 ? _a : portal.portalUrl}portals/${portal.id}`;
    const datastoreDescriptionApiUrl = `${restBaseUrl}/datastores/describe`;
    const datastoreDescriptionApiPayload = { datastoreId, serverId, path, type, f: "json" };
    try {
        const { jobId, key } = await (0,_portal_d518b571_js__WEBPACK_IMPORTED_MODULE_0__.r)(datastoreDescriptionApiUrl, datastoreDescriptionApiPayload, {}, "post");
        const { result } = await pollForDataStoreJob(jobId, key);
        return { result: result.result };
    }
    catch (error) {
        console.error(error);
        return { error: { code: "failToListDataStoreContents", message: JSON.stringify(error) } };
    }
};
const validateDatastoreServer = async (server, datastoreId) => {
    var _a;
    // https://developers.arcgis.com/rest/users-groups-and-items/validate-datastore.htm
    const portal = _config_75adf962_js__WEBPACK_IMPORTED_MODULE_2__.c.portal;
    const restBaseUrl = `${(_a = portal.restUrl) !== null && _a !== void 0 ? _a : portal.portalUrl}portals/${portal.id}`;
    const validateServerUrl = `${restBaseUrl}/datastores/validate`;
    const validateServerPayload = { datastoreId: datastoreId, serverId: server.id, f: "json" };
    try {
        const { status } = await (0,_portal_d518b571_js__WEBPACK_IMPORTED_MODULE_0__.r)(validateServerUrl, validateServerPayload, {}, "post");
        return { result: status };
    }
    catch (error) {
        console.error(error);
        return { error: { code: "unhandledError", message: JSON.stringify(error) } };
    }
};
const handleDatabaseFileDrop = async (url, data, hostingServerAdminUrl) => {
    let itemName;
    try {
        const { result } = await (0,_portal_d518b571_js__WEBPACK_IMPORTED_MODULE_0__.d)(url, data, {}, "post").then((response) => {
            if (response.status === "success") {
                itemName = response.item.itemName;
                return submitDatabaseFileJob(response.item, hostingServerAdminUrl);
            }
        });
        const connString = Object.assign(Object.assign({}, result), { itemName: itemName });
        return { result: connString };
    }
    catch (error) {
        console.error(error);
        return { error: { code: "unhandledError", message: JSON.stringify(error) } };
    }
};
const submitDatabaseFileJob = async (item, hostingServerAdminUrl) => {
    const publishingToolsUrl = (0,_data_store_8e83fb7a_js__WEBPACK_IMPORTED_MODULE_4__.k)(hostingServerAdminUrl);
    const url = `${publishingToolsUrl}/Get%20Database%20Connection%20String/submitJob`;
    const data = { in_inputData: item.itemID, in_connDataType: "UPLOADED_CONNECTION_FILE_ID" };
    try {
        const { jobId, jobStatus } = await (0,_portal_d518b571_js__WEBPACK_IMPORTED_MODULE_0__.r)(url, data, {}, "post");
        if ((jobStatus || "") === "esriJobSubmitted") {
            const url = `${publishingToolsUrl}/Get%20Database%20Connection%20String/jobs/${jobId}`;
            const result = await (0,_portal_d518b571_js__WEBPACK_IMPORTED_MODULE_0__.p)(url, {
                requestParams: { jobId: jobId, jobStatus: jobStatus },
                pendingStatuses: ["esriJobNew", "esriJobSubmitted", "esriJobWaiting", "esriJobExecuting"],
                successStatuses: ["esriJobSucceeded"]
            });
            const connectionString = await (0,_data_store_8e83fb7a_js__WEBPACK_IMPORTED_MODULE_4__.g)(result, publishingToolsUrl);
            return { result: connectionString };
        }
        return { result: null };
    }
    catch (error) {
        console.error(error);
        return { error: { code: "unhandledError", message: JSON.stringify(error) } };
    }
};
const fetchCloudStorageRegionInfo = async (provider) => {
    const regionInfoURL = "https://esriresources.s3.amazonaws.com/1120/regionsforcloudstorage.dat";
    try {
        const response = await (0,_portal_d518b571_js__WEBPACK_IMPORTED_MODULE_0__.r)(regionInfoURL);
        let result;
        if (provider === "amazon") {
            result = response.Amazon.regions;
        }
        else if (provider === "azure" || provider === "azuredatalakegen2store") {
            result = response.environments;
        }
        else if (provider === "alibaba") {
            result = response.Alibaba.regions;
        }
        else if (provider === "google") {
            result = response.Google.regions;
        }
        return { result: result };
    }
    catch (error) {
        console.error(error);
        return { error: { code: "unhandledError", message: JSON.stringify(error) } };
    }
};
const validateDatastoreForOnline = async (orgId, portal, payload) => {
    var _a;
    const url = `${portal.helperServices.datastoreManagement.url}/${orgId}/data/validateDataItem`;
    const item = JSON.stringify(payload);
    try {
        const validateResponse = await (0,_service_8c2c4241_js__WEBPACK_IMPORTED_MODULE_1__.r)(url, portal, {
            body: { item, f: "json" },
            usePost: true
        });
        return { result: validateResponse };
    }
    catch (error) {
        // Always log. A lot can go wrong with external connections, and the REST API returns more info
        // that may be helpful to Tech Support or others while debugging.
        console.error("Data Store validation error", error);
        const errorLookups = [
            ["incorrect username or password", "invalidUsernameOrPassword"]
        ];
        let errorMessage = ((_a = JSON.stringify(error)) === null || _a === void 0 ? void 0 : _a.toLowerCase()) || "";
        for (const [lookup, code] of errorLookups) {
            if (errorMessage.includes(lookup)) {
                return { error: { code } };
            }
        }
        return { error: { code: "unhandledError" } };
    }
};
const validateDatastoreForServers = async (item, serverList, datastoreType) => {
    const responses = await Promise.all(serverList.map((server) => validateServerForAddDataStore(item, server, datastoreType)));
    let servers = serverList.map((server, index) => {
        var _a, _b, _c, _d, _e, _f;
        const response = responses[index];
        const machine = (_a = response === null || response === void 0 ? void 0 : response.machines) === null || _a === void 0 ? void 0 : _a[0];
        const dataItem = (_b = machine === null || machine === void 0 ? void 0 : machine.dataItems) === null || _b === void 0 ? void 0 : _b[0];
        if ((response === null || response === void 0 ? void 0 : response.status) &&
            ((response === null || response === void 0 ? void 0 : response.status) === "success" || (machine === null || machine === void 0 ? void 0 : machine.machine.toLowerCase()) === server.name.toLowerCase().split(":")[0])) {
            return Object.assign(Object.assign({}, server), { serverStatus: (response === null || response === void 0 ? void 0 : response.status) || ((_c = response === null || response === void 0 ? void 0 : response.machines[0]) === null || _c === void 0 ? void 0 : _c.status), errorMsg: ((machine === null || machine === void 0 ? void 0 : machine.status) === "error" && ((_d = response === null || response === void 0 ? void 0 : response.error) === null || _d === void 0 ? void 0 : _d.message) && JSON.parse((_e = response === null || response === void 0 ? void 0 : response.error) === null || _e === void 0 ? void 0 : _e.message).message) ||
                    (dataItem === null || dataItem === void 0 ? void 0 : dataItem.message), error: dataItem === null || dataItem === void 0 ? void 0 : dataItem.error });
        }
        else {
            return Object.assign(Object.assign({}, server), { serverStatus: "error", errorMsg: (((_f = response === null || response === void 0 ? void 0 : response.error) === null || _f === void 0 ? void 0 : _f.message) && JSON.parse(response.error.message).message) || (dataItem === null || dataItem === void 0 ? void 0 : dataItem.message), error: dataItem === null || dataItem === void 0 ? void 0 : dataItem.error });
        }
    });
    return servers;
};
const validateServerForAddDataStore = async (item, server, datastoreType) => {
    var _a;
    let datastorePayload;
    const bdfsType = item.bdfsType;
    let validateServerPayload = null;
    if (datastoreType === "bdfs") {
        if (bdfsType === "fileshare") {
            datastorePayload = (0,_data_store_8e83fb7a_js__WEBPACK_IMPORTED_MODULE_4__.c)(item);
        }
        else if (bdfsType === "hdfs") {
            datastorePayload = (0,_data_store_8e83fb7a_js__WEBPACK_IMPORTED_MODULE_4__.a)(item);
        }
        else if (bdfsType === "hive") {
            datastorePayload = (0,_data_store_8e83fb7a_js__WEBPACK_IMPORTED_MODULE_4__.b)(item);
        }
        else if (bdfsType === "cloud") {
            if (item.bdfsCloudType === "new") {
                datastorePayload = (0,_data_store_8e83fb7a_js__WEBPACK_IMPORTED_MODULE_4__.d)(item);
                datastorePayload.info.isManaged = false;
            }
            // validating against existing cloud data store
            else {
                validateServerPayload = {
                    serverId: server.id,
                    datastoreId: item.bdfsExistingDatastore.id,
                    f: "json"
                };
            }
        }
    }
    else {
        if (datastoreType === "folder") {
            datastorePayload = (0,_data_store_8e83fb7a_js__WEBPACK_IMPORTED_MODULE_4__.e)(item);
        }
        else if (datastoreType === "database") {
            datastorePayload = (0,_data_store_8e83fb7a_js__WEBPACK_IMPORTED_MODULE_4__.f)(item);
        }
        else if (datastoreType === "cloud") {
            datastorePayload = (0,_data_store_8e83fb7a_js__WEBPACK_IMPORTED_MODULE_4__.d)(item);
        }
        else if (datastoreType === "nosql") {
            datastorePayload = (0,_data_store_8e83fb7a_js__WEBPACK_IMPORTED_MODULE_4__.h)(item);
        }
        datastorePayload.info.isManaged = false;
    }
    // https://developers.arcgis.com/rest/users-groups-and-items/validate-datastore.htm
    const portal = _config_75adf962_js__WEBPACK_IMPORTED_MODULE_2__.c.portal;
    const restBaseUrl = `${(_a = portal.restUrl) !== null && _a !== void 0 ? _a : portal.portalUrl}portals/${portal.id}`;
    const validateServerUrl = `${restBaseUrl}/datastores/validate`;
    if (!validateServerPayload && item.allowServicesRestart) {
        validateServerPayload = {
            datastore: JSON.stringify(datastorePayload),
            serverId: server.id,
            options: JSON.stringify({ allowServicesRestart: true }),
            f: "json"
        };
    }
    else {
        validateServerPayload = {
            datastore: JSON.stringify(datastorePayload),
            serverId: server.id,
            f: "json"
        };
    }
    try {
        const { status, machines } = await (0,_portal_d518b571_js__WEBPACK_IMPORTED_MODULE_0__.r)(validateServerUrl, validateServerPayload, {}, "post");
        return { status: status, machines: machines };
    }
    catch (error) {
        console.error(error);
        return { error: { code: "unhandledError", message: JSON.stringify(error) } };
    }
};
const checkServersType = async (serverList) => {
    let serverTypes = [];
    let servers = serverList;
    if ((0,_data_store_8e83fb7a_js__WEBPACK_IMPORTED_MODULE_4__.i)()) {
        const serversToValidate = [];
        servers.forEach((federatedServer) => {
            if (federatedServer.isHosted) {
                const serverItem = { name: federatedServer.adminUrl, type: "Linux" };
                serverTypes.push(serverItem);
            }
            else if (federatedServer.serverRole === "FEDERATED_SERVER") {
                serversToValidate.push(federatedServer);
            }
        });
        const responses = await Promise.allSettled(serversToValidate.map((server) => {
            const url = `${server.adminUrl}/admin/machines?f=json`;
            return (0,_portal_d518b571_js__WEBPACK_IMPORTED_MODULE_0__.r)(url, {}, {}, "post");
        }));
        await Promise.allSettled(responses.map((response) => {
            var _a;
            return validateServerTypeKubernetes((_a = response === null || response === void 0 ? void 0 : response.value) === null || _a === void 0 ? void 0 : _a.machines, servers).then((validatedServerTypes) => {
                serverTypes = [...serverTypes, ...validatedServerTypes];
            });
        }));
    }
    else {
        // 1. Retrieve the Federated machines
        const responses = await Promise.allSettled(servers.map((server) => {
            const url = `${server.adminUrl}/admin/machines?f=json`;
            return (0,_portal_d518b571_js__WEBPACK_IMPORTED_MODULE_0__.r)(url, {}, {}, "post");
        }));
        await Promise.allSettled(responses.map((response) => {
            var _a;
            return validateServerType((_a = response === null || response === void 0 ? void 0 : response.value) === null || _a === void 0 ? void 0 : _a.machines, servers).then((result) => {
                servers = [...result.serverList];
                serverTypes = result.serverTypes;
            });
        }));
    }
    return { servers: servers, serverTypes: serverTypes };
};
const validateServerType = async (machines, serverList) => {
    let serverTypes = [];
    // 2. Validate server type
    serverList.map((server, index) => {
        if (machines === null || machines === void 0 ? void 0 : machines[index]) {
            server.shouldFilter = false;
        }
        else {
            server.shouldFilter = true;
        }
    });
    serverList.filter((server) => {
        return !server.shouldFilter;
    });
    for (let index = 0; index < serverList.length; index++) {
        const machine = machines[0].machineName;
        const url = `${machines[0].adminURL}/machines/${machine}?f=json`;
        await (0,_portal_d518b571_js__WEBPACK_IMPORTED_MODULE_0__.r)(url, {}, {}, "post").then((result) => {
            if (result) {
                const serverItem = {
                    name: serverList[index].adminUrl,
                    type: result.platform.indexOf("Windows") > -1 ? "Windows" : "Linux"
                };
                serverTypes.push(serverItem);
            }
        });
    }
    return { serverTypes: serverTypes, serverList: serverList };
};
const requestCloudStoreList = async () => {
    const orgId = _config_75adf962_js__WEBPACK_IMPORTED_MODULE_2__.c.user.orgId;
    const type = "Data Store";
    const q = `orgid:${orgId} type:"${type}"`;
    const num = 10000;
    const content = { q, num };
    const url = `${(0,_portal_d518b571_js__WEBPACK_IMPORTED_MODULE_0__.g)()}search`;
    const supportedCloudStores = [
        "cloudStore_amazon",
        "cloudStore_azure",
        "cloudStore_azuredatalakegen2store",
        "cloudStore_azureDataLakeStore"
    ];
    try {
        const existingCloudStoreIds = [];
        const { results } = await (0,_portal_d518b571_js__WEBPACK_IMPORTED_MODULE_0__.r)(url, content);
        results === null || results === void 0 ? void 0 : results.forEach(({ id, title, type, typeKeywords }) => {
            // Exclude Big Data File Share items
            if (!typeKeywords.includes("bigDataFileShare") &&
                typeKeywords.some((keyword) => supportedCloudStores.includes(keyword))) {
                existingCloudStoreIds.push({ id, title, type, typeKeywords });
            }
        });
        return { result: existingCloudStoreIds };
    }
    catch (error) {
        console.error(error);
        return { error: { code: "unhandledError", message: JSON.stringify(error) } };
    }
};
const requestCloudStoreInfo = async (selectedCloudStoreId) => {
    const url = `${(0,_portal_d518b571_js__WEBPACK_IMPORTED_MODULE_0__.g)()}content/items/${selectedCloudStoreId}/data`;
    try {
        const { id, path, provider } = await (0,_portal_d518b571_js__WEBPACK_IMPORTED_MODULE_0__.r)(url);
        return { id: id, path: path, provider: provider };
    }
    catch (error) {
        console.error(error);
        return { error: { code: "unhandledError", message: JSON.stringify(error) } };
    }
};
const validateServerTypeKubernetes = async (machines, serverList) => {
    let serverTypes = [];
    await Promise.all(serverList.map((federatedServer, index) => {
        if (!federatedServer.isHosted) {
            const machine = machines[0].machineName;
            const url = `${machines[0].adminURL}/machines/${machine}?f=json`;
            return (0,_portal_d518b571_js__WEBPACK_IMPORTED_MODULE_0__.r)(url, {}, {}, "post").then((result) => {
                if (!result.isHosted) {
                    const serverItem = {
                        name: serverList[index].adminUrl,
                        type: result.platform.indexOf("Windows") > -1 ? "Windows" : "Linux"
                    };
                    serverTypes.push(serverItem);
                }
            });
        }
    }));
    return serverTypes;
};
const registerDataStoreWithServers = async (addItemInfo, item, title, tags, categories, snippet) => {
    var _a;
    const { portal } = _config_75adf962_js__WEBPACK_IMPORTED_MODULE_2__.c;
    const restBaseUrl = `${(_a = portal.restUrl) !== null && _a !== void 0 ? _a : portal.portalUrl}portals/${portal.id}`;
    const servers = item.dataStoreSelectedServers;
    const addResults = await Promise.all(servers.map((serverId) => {
        const content = {
            serverId,
            datastoreId: addItemInfo.id
        };
        if ((0,_data_store_8e83fb7a_js__WEBPACK_IMPORTED_MODULE_4__.i)() && item.addDataStoreType === "folder" && item.allowServicesRestart) {
            content.options = JSON.stringify({ allowServicesRestart: true });
        }
        const addToServerUrl = `${restBaseUrl}/datastores/addToServer`;
        return (0,_portal_d518b571_js__WEBPACK_IMPORTED_MODULE_0__.r)(addToServerUrl, content, {}, "post");
    }));
    let result = { success: false, id: null, folder: null };
    for (const addResult of addResults) {
        // TODO: error checking for the servers
        // const errors = [];
        // if (!addResult || !(addResult.result[1] || {}).success) {
        //   errors.push(addResult.result[1]);
        // }
        if (addResult.success) {
            if (item.addDataStoreType === "bdfs" && item.bdfsType === "cloud" && item.bdfsCloudType === "new") {
                result = await addBdfsDataStoreItem(item, title, tags, categories, snippet, addItemInfo.id);
                return result;
            }
            else {
                if (["folder", "database", "nosql", "cloud"].includes(item.addDataStoreType)) {
                    result = { success: true, id: addItemInfo.id, folder: addItemInfo.id };
                }
                else {
                    // For BDFS Data Store: get Catalog Service item id
                    const getCatalog = async () => {
                        const itemUrl = `${(0,_portal_d518b571_js__WEBPACK_IMPORTED_MODULE_0__.g)()}content/items/${addItemInfo.id}/relatedItems`;
                        const response = await (0,_portal_d518b571_js__WEBPACK_IMPORTED_MODULE_0__.r)(itemUrl, {
                            relationshipType: "BDFSDataStore2BDFSCatalogService",
                            direction: "forward"
                        });
                        if (response.total) {
                            result = { success: true, id: response.relatedItems[0].id, folder: addItemInfo.id };
                            return result;
                        }
                        else {
                            await (0,_functional_44de8fcf_js__WEBPACK_IMPORTED_MODULE_3__.t)(10000);
                            return getCatalog();
                        }
                    };
                    result = getCatalog();
                }
            }
        }
    }
    return result;
};
//for adding BDFS cloud data store
const addBdfsDataStoreItem = async (item, title, tags, categories, snippet, cloudId, cloudPath) => {
    const url = `${(0,_portal_d518b571_js__WEBPACK_IMPORTED_MODULE_0__.g)()}content/items/${cloudId}/data`;
    const response = await (0,_portal_d518b571_js__WEBPACK_IMPORTED_MODULE_0__.r)(url);
    const path = cloudPath || response.path;
    const datastoreTitle = path.split("/")[2].split("_")[0];
    const data = {
        type: "Data Store",
        title: title || datastoreTitle,
        tags: tags,
        categories: categories,
        snippet: snippet,
        text: ""
    };
    data.text = (0,_data_store_8e83fb7a_js__WEBPACK_IMPORTED_MODULE_4__.j)(data.title, path);
    item.addDataStoreType = "bdfsDataStore";
    let addItemResponse = await (0,_feature_layer_573bb473_js__WEBPACK_IMPORTED_MODULE_5__.u)(data, null);
    if (addItemResponse.success && _config_75adf962_js__WEBPACK_IMPORTED_MODULE_2__.c.portal.isPortal) {
        addItemResponse = await registerDataStoreWithServers(addItemResponse, item);
    }
    return addItemResponse;
};
const addDataStore = async (item, title, tags, categories, snippet) => {
    const datastoreType = item.addDataStoreType;
    const data = {
        type: "Data Store",
        title: title,
        tags: tags,
        categories: categories,
        snippet: snippet,
        text: "",
        typeKeywords: item.typeKeywords
    };
    let text;
    const bdfsType = item.bdfsType;
    if (datastoreType === "bdfs") {
        if (bdfsType === "fileshare") {
            text = (0,_data_store_8e83fb7a_js__WEBPACK_IMPORTED_MODULE_4__.c)(item, title);
        }
        else if (bdfsType === "hdfs") {
            text = (0,_data_store_8e83fb7a_js__WEBPACK_IMPORTED_MODULE_4__.a)(item, title);
        }
        else if (bdfsType === "hive") {
            text = (0,_data_store_8e83fb7a_js__WEBPACK_IMPORTED_MODULE_4__.b)(item, title);
        }
        else if (bdfsType === "cloud") {
            if (item.bdfsCloudType === "new") {
                text = (0,_data_store_8e83fb7a_js__WEBPACK_IMPORTED_MODULE_4__.d)(item, title);
                text.info.isManaged = false;
            }
            else {
                return await addBdfsDataStoreItem(item, title, tags, categories, snippet, item.bdfsExistingDatastore.id, item.bdfsExistingDatastore.path);
            }
        }
    }
    else {
        if (datastoreType === "folder") {
            text = (0,_data_store_8e83fb7a_js__WEBPACK_IMPORTED_MODULE_4__.e)(item, title);
        }
        else if (datastoreType === "database") {
            text = (0,_data_store_8e83fb7a_js__WEBPACK_IMPORTED_MODULE_4__.f)(item, title);
        }
        else if (datastoreType === "cloud") {
            text = (0,_data_store_8e83fb7a_js__WEBPACK_IMPORTED_MODULE_4__.d)(item, title);
        }
        else if (datastoreType === "nosql") {
            text = (0,_data_store_8e83fb7a_js__WEBPACK_IMPORTED_MODULE_4__.h)(item, title);
        }
        text.info.isManaged = false;
    }
    data.text = JSON.stringify(text);
    let response = await (0,_feature_layer_573bb473_js__WEBPACK_IMPORTED_MODULE_5__.u)(data, null);
    if (response.success && _config_75adf962_js__WEBPACK_IMPORTED_MODULE_2__.c.portal.isPortal) {
        response = await registerDataStoreWithServers(response, item, title, tags, categories, snippet);
    }
    return response;
};



//# sourceMappingURL=data-store-e2ae6a67.js.map

/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid2lkZ2V0cy9jaHVua3MvYXJjZ2lzX2FuYWx5c2lzX25vZGVfbW9kdWxlc19hcmNnaXNfYXBwLWNvbXBvbmVudHNfZGlzdF9lc21fZGF0YS1zLTY1MTY4NC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUMrRztBQUNyRDtBQUNGO0FBQ0E7QUFDa1Y7QUFDNVQ7QUFDSDs7QUFFM0U7QUFDQTtBQUNBLG1CQUFtQixrREFBVztBQUM5QiwyQkFBMkIsd0VBQXdFLFVBQVUsVUFBVTtBQUN2SCxnQ0FBZ0MsWUFBWSxRQUFRLDBCQUEwQixRQUFRLDJCQUEyQjtBQUNqSDtBQUNBO0FBQ0EsMEJBQTBCLHNEQUFhO0FBQ3ZDO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLFNBQVM7QUFDOUI7QUFDQSxpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDBGQUEwRjtBQUMxRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsc0RBQWMsR0FBRztBQUN4QyxnQkFBZ0IsYUFBYSxRQUFRLHNEQUFPLHFCQUFxQjtBQUNqRSxnQkFBZ0IsZ0JBQWdCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBLHFCQUFxQixTQUFTO0FBQzlCO0FBQ0E7QUFDQSxhQUFhLDZEQUFZO0FBQ3pCLGtCQUFrQiwyREFBUTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsMkRBQVU7QUFDeEIs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Q0E7QUFDQSxrQ0FBa0MsMERBQU87QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHNEQUFjLEdBQUcsZ0JBQWdCLFFBQVE7QUFDNUQsMkJBQTJCLHNEQUFPO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDBEQUFvQjtBQUNwQztBQUNBLGdDQUFnQyw2REFBTztBQUN2QyxtQ0FBbUMsa0RBQVc7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsMERBQWlDO0FBQ3BEO0FBQ0E7QUFDQSxtQkFBbUIsMERBQTRCO0FBQy9DO0FBQ0E7QUFDQSxtQkFBbUIsMERBQTRCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QiwwREFBNkI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDBEQUFzQjtBQUN6QztBQUNBO0FBQ0EsbUJBQW1CLDBEQUF3QjtBQUMzQztBQUNBO0FBQ0EsbUJBQW1CLDBEQUE2QjtBQUNoRDtBQUNBO0FBQ0EsbUJBQW1CLDBEQUFxQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qiw2REFBTztBQUNoQyw0QkFBNEIsa0RBQVc7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7O0FBRWtVOztBQUVsVSIsInNvdXJjZXMiOlsid2VicGFjazovL2V4Yi1jbGllbnQvLi9leHRlbnNpb25zL3dpZGdldHMvYXJjZ2lzL2FuYWx5c2lzL25vZGVfbW9kdWxlcy9AYXJjZ2lzL2FwcC1jb21wb25lbnRzL2Rpc3QvZXNtL2RhdGEtc3RvcmUtZTJhZTZhNjcuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBBbGwgbWF0ZXJpYWwgY29weXJpZ2h0IEVTUkksIEFsbCBSaWdodHMgUmVzZXJ2ZWQsIHVubGVzcyBvdGhlcndpc2Ugc3BlY2lmaWVkLlxuICogdjQuMC41OFxuICovXG5pbXBvcnQgeyBnIGFzIGdldFJlc3RCYXNlVXJsLCByIGFzIHJlcXVlc3QsIGQgYXMgZm9ybVJlcXVlc3QsIHAgYXMgcG9sbEZvclN0YXR1cyB9IGZyb20gJy4vcG9ydGFsLWQ1MThiNTcxLmpzJztcbmltcG9ydCB7IHIgYXMgcmVxdWVzdEZldGNoIH0gZnJvbSAnLi9zZXJ2aWNlLThjMmM0MjQxLmpzJztcbmltcG9ydCB7IGMgYXMgY29uZmlnU3RhdGUgfSBmcm9tICcuL2NvbmZpZy03NWFkZjk2Mi5qcyc7XG5pbXBvcnQgeyB0IGFzIHRpbWVvdXQgfSBmcm9tICcuL2Z1bmN0aW9uYWwtNDRkZThmY2YuanMnO1xuaW1wb3J0IHsgZyBhcyBnZXRDb25uZWN0aW9uU3RyaW5nLCBjIGFzIGNyZWF0ZUZpbGVTaGFyZVByb3ZpZGVyRGF0YU9iamVjdCwgYSBhcyBjcmVhdGVIZGZzUHJvdmlkZXJEYXRhT2JqZWN0LCBiIGFzIGNyZWF0ZUhpdmVQcm92aWRlckRhdGFPYmplY3QsIGQgYXMgY3JlYXRlQ2xvdWRQcm92aWRlckRhdGFPYmplY3QsIGUgYXMgY3JlYXRlRm9sZGVyRGF0YU9iamVjdCwgZiBhcyBjcmVhdGVEYXRhYmFzZURhdGFPYmplY3QsIGggYXMgY3JlYXRlTm9TcWxEYXRhT2JqZWN0LCBpIGFzIGlzQXJjR0lTRW50ZXJwcmlzZU9uS3ViZXJuZXRlcywgaiBhcyBnZXRCZGZzUGFyYW1ldGVySXRlbSwgayBhcyBnZXRQdWJsaXNoaW5nVG9vbHNVcmwgfSBmcm9tICcuL2RhdGEtc3RvcmUtOGU4M2ZiN2EuanMnO1xuaW1wb3J0IHsgdCBhcyBpc0ZvbGRlclJvb3QsIHUgYXMgYWRkSXRlbSB9IGZyb20gJy4vZmVhdHVyZS1sYXllci01NzNiYjQ3My5qcyc7XG5pbXBvcnQgeyBtIGFzIG1vdmVJdGVtLCB1IGFzIHVwZGF0ZUl0ZW0gfSBmcm9tICcuL3NlcnZlci1pdGVtLThkMzg0Nzk2LmpzJztcblxuY29uc3QgcG9sbEZvckRhdGFTdG9yZUpvYiA9IGFzeW5jIChqb2JJZCwgam9iS2V5KSA9PiB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICBjb25zdCBwb3J0YWwgPSBjb25maWdTdGF0ZS5wb3J0YWw7XG4gICAgY29uc3QgcmVzdEJhc2VVcmwgPSBgJHsoX2EgPSBwb3J0YWwucmVzdFVybCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogcG9ydGFsLnBvcnRhbFVybH1wb3J0YWxzLyR7cG9ydGFsLmlkfWA7XG4gICAgY29uc3Qgam9iRGV0YWlsc0FwaVVybCA9IGAke3Jlc3RCYXNlVXJsfS9qb2JzLyR7ZW5jb2RlVVJJQ29tcG9uZW50KGpvYklkKX0vP2tleT0ke2VuY29kZVVSSUNvbXBvbmVudChqb2JLZXkpfWA7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJlc3VsdDogYXdhaXQgcG9sbEZvclN0YXR1cyhqb2JEZXRhaWxzQXBpVXJsLCB7XG4gICAgICAgICAgICAgICAgcGVuZGluZ1N0YXR1c2VzOiBbXCJwcm9jZXNzaW5nXCIsIFwic3VibWl0dGVkXCJdLFxuICAgICAgICAgICAgICAgIHN1Y2Nlc3NTdGF0dXNlczogW1wic3VjY2VlZGVkXCJdXG4gICAgICAgICAgICB9LCBcInBvc3RcIilcbiAgICAgICAgfTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xuICAgICAgICBjb25zdCBlcnJNZXNzYWdlID0gKF9iID0gZXJyb3IubWVzc2FnZXMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYlswXTtcbiAgICAgICAgaWYgKGVyck1lc3NhZ2UgPT09IG51bGwgfHwgZXJyTWVzc2FnZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZXJyTWVzc2FnZS5pbmNsdWRlcyhcIkVSUk9SIDAwMDYyM1wiKSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgZXJyb3I6IHsgY29kZTogXCJpbnZhbGlkRGF0YVN0b3JlUHVibGlzaFR5cGVcIiB9IH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgZXJyb3I6IHsgY29kZTogXCJ1bmhhbmRsZWRFcnJvclwiLCBtZXNzYWdlOiBKU09OLnN0cmluZ2lmeShlcnJvcikgfSB9O1xuICAgIH1cbn07XG5jb25zdCBwdWJsaXNoRnJvbURhdGFTdG9yZSA9IGFzeW5jIChkYXRhU3RvcmVJbmZvLCBwb3J0YWwsIFxuLyoqXG4gKiBUaGVyZSBpcyBhIHRyaWNreSBjYXNlIHdoZXJlIEltYWdlU2VydmVyIG5lZWRzIHRvIGJlIHVzZSBmb3IgY2FjaGVEYXRhc2V0IGluc3RlYWQgb2YgTWFwU2VydmVyXG4gKlxuICogQ3VycmVudGx5LCBtYWtpbmcgYW5vdGhlciBjYWxsIHRvIGJhY2tlbmQgdG8gY2hlY2sgd291bGQgYmUgcmVhbGx5IGxvbmcgc28gd2UgdXNlIHJldHJ5IGFzIGEgZmFzdGVyIHdvcmthcm91bmRcbiAqL1xudXNlUmV0cnlXb3JrYXJvdW5kKSA9PiB7XG4gICAgdmFyIF9hO1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHsgZm9sZGVyLCB0eXBlLCBjYWNoZVN0b3JlSWQsIHNlcnZpY2VOYW1lLCBwYXRoSW5DYWNoZWRTdG9yZSwgZGVzY3JpcHRpb24sIHNlcnZlcklkLCB0YWdzIH0gPSBkYXRhU3RvcmVJbmZvO1xuICAgICAgICBsZXQgY29uZmlnVHlwZTtcbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICBjYXNlIFwiaTNzUmVzdENhY2hlXCI6XG4gICAgICAgICAgICBjYXNlIFwiZXh0cmFjdGVkU2NlbmVQYWNrYWdlXCI6XG4gICAgICAgICAgICAgICAgY29uZmlnVHlwZSA9IFwiU2NlbmVTZXJ2ZXJcIjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJ2ZWN0b3JDYWNoZURhdGFzZXRcIjpcbiAgICAgICAgICAgICAgICBjb25maWdUeXBlID0gXCJWZWN0b3JUaWxlU2VydmVyXCI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiY2FjaGVEYXRhc2V0XCI6XG4gICAgICAgICAgICAgICAgY29uZmlnVHlwZSA9IHVzZVJldHJ5V29ya2Fyb3VuZCA/IFwiSW1hZ2VTZXJ2ZXJcIiA6IFwiTWFwU2VydmVyXCI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXJzLmFyY2dpcy5jb20vcmVzdC91c2Vycy1ncm91cHMtYW5kLWl0ZW1zL3B1Ymxpc2gtZGF0YXNldHMtdG8tZGF0YXN0b3JlLmh0bVxuICAgICAgICBjb25zdCBzZXJ2aWNlQ29uZmlndXJhdGlvbiA9IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgIHR5cGU6IGNvbmZpZ1R5cGUsXG4gICAgICAgICAgICBzZXJ2aWNlTmFtZSxcbiAgICAgICAgICAgIHByb3BlcnRpZXM6IHsgcGF0aEluQ2FjaGVkU3RvcmUsIGNhY2hlU3RvcmVJZCB9XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCByZXF1ZXN0RGF0YSA9IHtcbiAgICAgICAgICAgIHNlcnZpY2VDb25maWd1cmF0aW9uLFxuICAgICAgICAgICAgc2VydmVySWQsXG4gICAgICAgICAgICB0YWdzLFxuICAgICAgICAgICAgZjogXCJqc29uXCJcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgdXJsID0gYCR7Z2V0UmVzdEJhc2VVcmwoKX1wb3J0YWxzL3NlbGYvZGF0YXN0b3Jlcy9wdWJsaXNoYDtcbiAgICAgICAgY29uc3QgeyBqb2JJZCwga2V5IH0gPSBhd2FpdCByZXF1ZXN0KHVybCwgcmVxdWVzdERhdGEsIHt9LCBcInBvc3RcIik7XG4gICAgICAgIGNvbnN0IHsgZXJyb3IsIHJlc3VsdCB9ID0gYXdhaXQgcG9sbEZvckRhdGFTdG9yZUpvYihqb2JJZCwga2V5KTtcbiAgICAgICAgaWYgKChlcnJvciA9PT0gbnVsbCB8fCBlcnJvciA9PT0gdm9pZCAwID8gdm9pZCAwIDogZXJyb3IuY29kZSkgPT09IFwiaW52YWxpZERhdGFTdG9yZVB1Ymxpc2hUeXBlXCIpIHtcbiAgICAgICAgICAgIC8vIFdvcmthcm91bmQgYXMgZXhwbGFpbiBhYm92ZVxuICAgICAgICAgICAgcmV0dXJuIGRhdGFTdG9yZUluZm8udHlwZSA9PT0gXCJjYWNoZURhdGFzZXRcIlxuICAgICAgICAgICAgICAgID8gcHVibGlzaEZyb21EYXRhU3RvcmUoZGF0YVN0b3JlSW5mbywgcG9ydGFsLCB0cnVlKVxuICAgICAgICAgICAgICAgIDogeyBlcnJvcjogeyBjb2RlOiBcImludmFsaWREYXRhU3RvcmVQdWJsaXNoVHlwZVwiLCBtZXNzYWdlOiBKU09OLnN0cmluZ2lmeShlcnJvci5tZXNzYWdlKSB9IH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiB7IGVycm9yOiB7IGNvZGU6IFwiZmFpbFRvUHVibGlzaEZyb21EYXRhU3RvcmVcIiwgbWVzc2FnZTogSlNPTi5zdHJpbmdpZnkoZXJyb3IubWVzc2FnZSkgfSB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VsdFNlcnZpY2UgPSAoX2EgPSByZXN1bHQgPT09IG51bGwgfHwgcmVzdWx0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZXN1bHQucmVzdWx0KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2VydmljZXNbMF07XG4gICAgICAgIGlmICghaXNGb2xkZXJSb290KGZvbGRlcikpIHtcbiAgICAgICAgICAgIGF3YWl0IG1vdmVJdGVtKHJlc3VsdFNlcnZpY2Uuc2VydmljZUl0ZW1JZCwgZm9sZGVyLmlkKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBwdWJsaXNoIEFQSSBkb2Vzbid0IHN1cHBvcnQgY2hhbmdpbmcgdGhlIHN1bW1hcnkgLyBzbmlwcGV0LCBzbyB3ZSBtYWtlIGEgc2VwYXJhdGUgY2FsbCBmb3IgaXRcbiAgICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXJzLmFyY2dpcy5jb20vcmVzdC91c2Vycy1ncm91cHMtYW5kLWl0ZW1zL3VwZGF0ZS1pdGVtLmh0bVxuICAgICAgICBjb25zdCBpdGVtVXBkYXRlRGF0YSA9IHtcbiAgICAgICAgICAgIHNuaXBwZXQ6IGRlc2NyaXB0aW9uLFxuICAgICAgICAgICAgZjogXCJqc29uXCJcbiAgICAgICAgfTtcbiAgICAgICAgYXdhaXQgdXBkYXRlSXRlbShyZXN1bHRTZXJ2aWNlLnNlcnZpY2VJdGVtSWQsIGl0ZW1VcGRhdGVEYXRhKTtcbiAgICAgICAgcmV0dXJuIHsgcmVzdWx0OiByZXN1bHRTZXJ2aWNlIH07XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgICAgICAgcmV0dXJuIHsgZXJyb3I6IHsgY29kZTogXCJmYWlsVG9QdWJsaXNoRnJvbURhdGFTdG9yZVwiLCBtZXNzYWdlOiBKU09OLnN0cmluZ2lmeShlcnJvcikgfSB9O1xuICAgIH1cbn07XG5jb25zdCBnZXREYXRhc3RvcmVDb250ZW50cyA9IGFzeW5jIChkYXRhc3RvcmVJZCwgcGF0aCwgdHlwZSwgc2VydmVySWQpID0+IHtcbiAgICB2YXIgX2E7XG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXJzLmFyY2dpcy5jb20vcmVzdC91c2Vycy1ncm91cHMtYW5kLWl0ZW1zL2Rlc2NyaWJlLWRhdGFzdG9yZS5odG1cbiAgICBjb25zdCBwb3J0YWwgPSBjb25maWdTdGF0ZS5wb3J0YWw7XG4gICAgY29uc3QgcmVzdEJhc2VVcmwgPSBgJHsoX2EgPSBwb3J0YWwucmVzdFVybCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogcG9ydGFsLnBvcnRhbFVybH1wb3J0YWxzLyR7cG9ydGFsLmlkfWA7XG4gICAgY29uc3QgZGF0YXN0b3JlRGVzY3JpcHRpb25BcGlVcmwgPSBgJHtyZXN0QmFzZVVybH0vZGF0YXN0b3Jlcy9kZXNjcmliZWA7XG4gICAgY29uc3QgZGF0YXN0b3JlRGVzY3JpcHRpb25BcGlQYXlsb2FkID0geyBkYXRhc3RvcmVJZCwgc2VydmVySWQsIHBhdGgsIHR5cGUsIGY6IFwianNvblwiIH07XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgeyBqb2JJZCwga2V5IH0gPSBhd2FpdCByZXF1ZXN0KGRhdGFzdG9yZURlc2NyaXB0aW9uQXBpVXJsLCBkYXRhc3RvcmVEZXNjcmlwdGlvbkFwaVBheWxvYWQsIHt9LCBcInBvc3RcIik7XG4gICAgICAgIGNvbnN0IHsgcmVzdWx0IH0gPSBhd2FpdCBwb2xsRm9yRGF0YVN0b3JlSm9iKGpvYklkLCBrZXkpO1xuICAgICAgICByZXR1cm4geyByZXN1bHQ6IHJlc3VsdC5yZXN1bHQgfTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xuICAgICAgICByZXR1cm4geyBlcnJvcjogeyBjb2RlOiBcImZhaWxUb0xpc3REYXRhU3RvcmVDb250ZW50c1wiLCBtZXNzYWdlOiBKU09OLnN0cmluZ2lmeShlcnJvcikgfSB9O1xuICAgIH1cbn07XG5jb25zdCB2YWxpZGF0ZURhdGFzdG9yZVNlcnZlciA9IGFzeW5jIChzZXJ2ZXIsIGRhdGFzdG9yZUlkKSA9PiB7XG4gICAgdmFyIF9hO1xuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVycy5hcmNnaXMuY29tL3Jlc3QvdXNlcnMtZ3JvdXBzLWFuZC1pdGVtcy92YWxpZGF0ZS1kYXRhc3RvcmUuaHRtXG4gICAgY29uc3QgcG9ydGFsID0gY29uZmlnU3RhdGUucG9ydGFsO1xuICAgIGNvbnN0IHJlc3RCYXNlVXJsID0gYCR7KF9hID0gcG9ydGFsLnJlc3RVcmwpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHBvcnRhbC5wb3J0YWxVcmx9cG9ydGFscy8ke3BvcnRhbC5pZH1gO1xuICAgIGNvbnN0IHZhbGlkYXRlU2VydmVyVXJsID0gYCR7cmVzdEJhc2VVcmx9L2RhdGFzdG9yZXMvdmFsaWRhdGVgO1xuICAgIGNvbnN0IHZhbGlkYXRlU2VydmVyUGF5bG9hZCA9IHsgZGF0YXN0b3JlSWQ6IGRhdGFzdG9yZUlkLCBzZXJ2ZXJJZDogc2VydmVyLmlkLCBmOiBcImpzb25cIiB9O1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHsgc3RhdHVzIH0gPSBhd2FpdCByZXF1ZXN0KHZhbGlkYXRlU2VydmVyVXJsLCB2YWxpZGF0ZVNlcnZlclBheWxvYWQsIHt9LCBcInBvc3RcIik7XG4gICAgICAgIHJldHVybiB7IHJlc3VsdDogc3RhdHVzIH07XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgICAgICAgcmV0dXJuIHsgZXJyb3I6IHsgY29kZTogXCJ1bmhhbmRsZWRFcnJvclwiLCBtZXNzYWdlOiBKU09OLnN0cmluZ2lmeShlcnJvcikgfSB9O1xuICAgIH1cbn07XG5jb25zdCBoYW5kbGVEYXRhYmFzZUZpbGVEcm9wID0gYXN5bmMgKHVybCwgZGF0YSwgaG9zdGluZ1NlcnZlckFkbWluVXJsKSA9PiB7XG4gICAgbGV0IGl0ZW1OYW1lO1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHsgcmVzdWx0IH0gPSBhd2FpdCBmb3JtUmVxdWVzdCh1cmwsIGRhdGEsIHt9LCBcInBvc3RcIikudGhlbigocmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IFwic3VjY2Vzc1wiKSB7XG4gICAgICAgICAgICAgICAgaXRlbU5hbWUgPSByZXNwb25zZS5pdGVtLml0ZW1OYW1lO1xuICAgICAgICAgICAgICAgIHJldHVybiBzdWJtaXREYXRhYmFzZUZpbGVKb2IocmVzcG9uc2UuaXRlbSwgaG9zdGluZ1NlcnZlckFkbWluVXJsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGNvbm5TdHJpbmcgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHJlc3VsdCksIHsgaXRlbU5hbWU6IGl0ZW1OYW1lIH0pO1xuICAgICAgICByZXR1cm4geyByZXN1bHQ6IGNvbm5TdHJpbmcgfTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xuICAgICAgICByZXR1cm4geyBlcnJvcjogeyBjb2RlOiBcInVuaGFuZGxlZEVycm9yXCIsIG1lc3NhZ2U6IEpTT04uc3RyaW5naWZ5KGVycm9yKSB9IH07XG4gICAgfVxufTtcbmNvbnN0IHN1Ym1pdERhdGFiYXNlRmlsZUpvYiA9IGFzeW5jIChpdGVtLCBob3N0aW5nU2VydmVyQWRtaW5VcmwpID0+IHtcbiAgICBjb25zdCBwdWJsaXNoaW5nVG9vbHNVcmwgPSBnZXRQdWJsaXNoaW5nVG9vbHNVcmwoaG9zdGluZ1NlcnZlckFkbWluVXJsKTtcbiAgICBjb25zdCB1cmwgPSBgJHtwdWJsaXNoaW5nVG9vbHNVcmx9L0dldCUyMERhdGFiYXNlJTIwQ29ubmVjdGlvbiUyMFN0cmluZy9zdWJtaXRKb2JgO1xuICAgIGNvbnN0IGRhdGEgPSB7IGluX2lucHV0RGF0YTogaXRlbS5pdGVtSUQsIGluX2Nvbm5EYXRhVHlwZTogXCJVUExPQURFRF9DT05ORUNUSU9OX0ZJTEVfSURcIiB9O1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHsgam9iSWQsIGpvYlN0YXR1cyB9ID0gYXdhaXQgcmVxdWVzdCh1cmwsIGRhdGEsIHt9LCBcInBvc3RcIik7XG4gICAgICAgIGlmICgoam9iU3RhdHVzIHx8IFwiXCIpID09PSBcImVzcmlKb2JTdWJtaXR0ZWRcIikge1xuICAgICAgICAgICAgY29uc3QgdXJsID0gYCR7cHVibGlzaGluZ1Rvb2xzVXJsfS9HZXQlMjBEYXRhYmFzZSUyMENvbm5lY3Rpb24lMjBTdHJpbmcvam9icy8ke2pvYklkfWA7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBwb2xsRm9yU3RhdHVzKHVybCwge1xuICAgICAgICAgICAgICAgIHJlcXVlc3RQYXJhbXM6IHsgam9iSWQ6IGpvYklkLCBqb2JTdGF0dXM6IGpvYlN0YXR1cyB9LFxuICAgICAgICAgICAgICAgIHBlbmRpbmdTdGF0dXNlczogW1wiZXNyaUpvYk5ld1wiLCBcImVzcmlKb2JTdWJtaXR0ZWRcIiwgXCJlc3JpSm9iV2FpdGluZ1wiLCBcImVzcmlKb2JFeGVjdXRpbmdcIl0sXG4gICAgICAgICAgICAgICAgc3VjY2Vzc1N0YXR1c2VzOiBbXCJlc3JpSm9iU3VjY2VlZGVkXCJdXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IGNvbm5lY3Rpb25TdHJpbmcgPSBhd2FpdCBnZXRDb25uZWN0aW9uU3RyaW5nKHJlc3VsdCwgcHVibGlzaGluZ1Rvb2xzVXJsKTtcbiAgICAgICAgICAgIHJldHVybiB7IHJlc3VsdDogY29ubmVjdGlvblN0cmluZyB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHJlc3VsdDogbnVsbCB9O1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gICAgICAgIHJldHVybiB7IGVycm9yOiB7IGNvZGU6IFwidW5oYW5kbGVkRXJyb3JcIiwgbWVzc2FnZTogSlNPTi5zdHJpbmdpZnkoZXJyb3IpIH0gfTtcbiAgICB9XG59O1xuY29uc3QgZmV0Y2hDbG91ZFN0b3JhZ2VSZWdpb25JbmZvID0gYXN5bmMgKHByb3ZpZGVyKSA9PiB7XG4gICAgY29uc3QgcmVnaW9uSW5mb1VSTCA9IFwiaHR0cHM6Ly9lc3JpcmVzb3VyY2VzLnMzLmFtYXpvbmF3cy5jb20vMTEyMC9yZWdpb25zZm9yY2xvdWRzdG9yYWdlLmRhdFwiO1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgcmVxdWVzdChyZWdpb25JbmZvVVJMKTtcbiAgICAgICAgbGV0IHJlc3VsdDtcbiAgICAgICAgaWYgKHByb3ZpZGVyID09PSBcImFtYXpvblwiKSB7XG4gICAgICAgICAgICByZXN1bHQgPSByZXNwb25zZS5BbWF6b24ucmVnaW9ucztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwcm92aWRlciA9PT0gXCJhenVyZVwiIHx8IHByb3ZpZGVyID09PSBcImF6dXJlZGF0YWxha2VnZW4yc3RvcmVcIikge1xuICAgICAgICAgICAgcmVzdWx0ID0gcmVzcG9uc2UuZW52aXJvbm1lbnRzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHByb3ZpZGVyID09PSBcImFsaWJhYmFcIikge1xuICAgICAgICAgICAgcmVzdWx0ID0gcmVzcG9uc2UuQWxpYmFiYS5yZWdpb25zO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHByb3ZpZGVyID09PSBcImdvb2dsZVwiKSB7XG4gICAgICAgICAgICByZXN1bHQgPSByZXNwb25zZS5Hb29nbGUucmVnaW9ucztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyByZXN1bHQ6IHJlc3VsdCB9O1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gICAgICAgIHJldHVybiB7IGVycm9yOiB7IGNvZGU6IFwidW5oYW5kbGVkRXJyb3JcIiwgbWVzc2FnZTogSlNPTi5zdHJpbmdpZnkoZXJyb3IpIH0gfTtcbiAgICB9XG59O1xuY29uc3QgdmFsaWRhdGVEYXRhc3RvcmVGb3JPbmxpbmUgPSBhc3luYyAob3JnSWQsIHBvcnRhbCwgcGF5bG9hZCkgPT4ge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCB1cmwgPSBgJHtwb3J0YWwuaGVscGVyU2VydmljZXMuZGF0YXN0b3JlTWFuYWdlbWVudC51cmx9LyR7b3JnSWR9L2RhdGEvdmFsaWRhdGVEYXRhSXRlbWA7XG4gICAgY29uc3QgaXRlbSA9IEpTT04uc3RyaW5naWZ5KHBheWxvYWQpO1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHZhbGlkYXRlUmVzcG9uc2UgPSBhd2FpdCByZXF1ZXN0RmV0Y2godXJsLCBwb3J0YWwsIHtcbiAgICAgICAgICAgIGJvZHk6IHsgaXRlbSwgZjogXCJqc29uXCIgfSxcbiAgICAgICAgICAgIHVzZVBvc3Q6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7IHJlc3VsdDogdmFsaWRhdGVSZXNwb25zZSB9O1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgLy8gQWx3YXlzIGxvZy4gQSBsb3QgY2FuIGdvIHdyb25nIHdpdGggZXh0ZXJuYWwgY29ubmVjdGlvbnMsIGFuZCB0aGUgUkVTVCBBUEkgcmV0dXJucyBtb3JlIGluZm9cbiAgICAgICAgLy8gdGhhdCBtYXkgYmUgaGVscGZ1bCB0byBUZWNoIFN1cHBvcnQgb3Igb3RoZXJzIHdoaWxlIGRlYnVnZ2luZy5cbiAgICAgICAgY29uc29sZS5lcnJvcihcIkRhdGEgU3RvcmUgdmFsaWRhdGlvbiBlcnJvclwiLCBlcnJvcik7XG4gICAgICAgIGNvbnN0IGVycm9yTG9va3VwcyA9IFtcbiAgICAgICAgICAgIFtcImluY29ycmVjdCB1c2VybmFtZSBvciBwYXNzd29yZFwiLCBcImludmFsaWRVc2VybmFtZU9yUGFzc3dvcmRcIl1cbiAgICAgICAgXTtcbiAgICAgICAgbGV0IGVycm9yTWVzc2FnZSA9ICgoX2EgPSBKU09OLnN0cmluZ2lmeShlcnJvcikpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS50b0xvd2VyQ2FzZSgpKSB8fCBcIlwiO1xuICAgICAgICBmb3IgKGNvbnN0IFtsb29rdXAsIGNvZGVdIG9mIGVycm9yTG9va3Vwcykge1xuICAgICAgICAgICAgaWYgKGVycm9yTWVzc2FnZS5pbmNsdWRlcyhsb29rdXApKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZXJyb3I6IHsgY29kZSB9IH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgZXJyb3I6IHsgY29kZTogXCJ1bmhhbmRsZWRFcnJvclwiIH0gfTtcbiAgICB9XG59O1xuY29uc3QgdmFsaWRhdGVEYXRhc3RvcmVGb3JTZXJ2ZXJzID0gYXN5bmMgKGl0ZW0sIHNlcnZlckxpc3QsIGRhdGFzdG9yZVR5cGUpID0+IHtcbiAgICBjb25zdCByZXNwb25zZXMgPSBhd2FpdCBQcm9taXNlLmFsbChzZXJ2ZXJMaXN0Lm1hcCgoc2VydmVyKSA9PiB2YWxpZGF0ZVNlcnZlckZvckFkZERhdGFTdG9yZShpdGVtLCBzZXJ2ZXIsIGRhdGFzdG9yZVR5cGUpKSk7XG4gICAgbGV0IHNlcnZlcnMgPSBzZXJ2ZXJMaXN0Lm1hcCgoc2VydmVyLCBpbmRleCkgPT4ge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZjtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSByZXNwb25zZXNbaW5kZXhdO1xuICAgICAgICBjb25zdCBtYWNoaW5lID0gKF9hID0gcmVzcG9uc2UgPT09IG51bGwgfHwgcmVzcG9uc2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlc3BvbnNlLm1hY2hpbmVzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FbMF07XG4gICAgICAgIGNvbnN0IGRhdGFJdGVtID0gKF9iID0gbWFjaGluZSA9PT0gbnVsbCB8fCBtYWNoaW5lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBtYWNoaW5lLmRhdGFJdGVtcykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iWzBdO1xuICAgICAgICBpZiAoKHJlc3BvbnNlID09PSBudWxsIHx8IHJlc3BvbnNlID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZXNwb25zZS5zdGF0dXMpICYmXG4gICAgICAgICAgICAoKHJlc3BvbnNlID09PSBudWxsIHx8IHJlc3BvbnNlID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZXNwb25zZS5zdGF0dXMpID09PSBcInN1Y2Nlc3NcIiB8fCAobWFjaGluZSA9PT0gbnVsbCB8fCBtYWNoaW5lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBtYWNoaW5lLm1hY2hpbmUudG9Mb3dlckNhc2UoKSkgPT09IHNlcnZlci5uYW1lLnRvTG93ZXJDYXNlKCkuc3BsaXQoXCI6XCIpWzBdKSkge1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgc2VydmVyKSwgeyBzZXJ2ZXJTdGF0dXM6IChyZXNwb25zZSA9PT0gbnVsbCB8fCByZXNwb25zZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVzcG9uc2Uuc3RhdHVzKSB8fCAoKF9jID0gcmVzcG9uc2UgPT09IG51bGwgfHwgcmVzcG9uc2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlc3BvbnNlLm1hY2hpbmVzWzBdKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Muc3RhdHVzKSwgZXJyb3JNc2c6ICgobWFjaGluZSA9PT0gbnVsbCB8fCBtYWNoaW5lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBtYWNoaW5lLnN0YXR1cykgPT09IFwiZXJyb3JcIiAmJiAoKF9kID0gcmVzcG9uc2UgPT09IG51bGwgfHwgcmVzcG9uc2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlc3BvbnNlLmVycm9yKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QubWVzc2FnZSkgJiYgSlNPTi5wYXJzZSgoX2UgPSByZXNwb25zZSA9PT0gbnVsbCB8fCByZXNwb25zZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVzcG9uc2UuZXJyb3IpID09PSBudWxsIHx8IF9lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZS5tZXNzYWdlKS5tZXNzYWdlKSB8fFxuICAgICAgICAgICAgICAgICAgICAoZGF0YUl0ZW0gPT09IG51bGwgfHwgZGF0YUl0ZW0gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRhdGFJdGVtLm1lc3NhZ2UpLCBlcnJvcjogZGF0YUl0ZW0gPT09IG51bGwgfHwgZGF0YUl0ZW0gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRhdGFJdGVtLmVycm9yIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgc2VydmVyKSwgeyBzZXJ2ZXJTdGF0dXM6IFwiZXJyb3JcIiwgZXJyb3JNc2c6ICgoKF9mID0gcmVzcG9uc2UgPT09IG51bGwgfHwgcmVzcG9uc2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlc3BvbnNlLmVycm9yKSA9PT0gbnVsbCB8fCBfZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2YubWVzc2FnZSkgJiYgSlNPTi5wYXJzZShyZXNwb25zZS5lcnJvci5tZXNzYWdlKS5tZXNzYWdlKSB8fCAoZGF0YUl0ZW0gPT09IG51bGwgfHwgZGF0YUl0ZW0gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRhdGFJdGVtLm1lc3NhZ2UpLCBlcnJvcjogZGF0YUl0ZW0gPT09IG51bGwgfHwgZGF0YUl0ZW0gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRhdGFJdGVtLmVycm9yIH0pO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHNlcnZlcnM7XG59O1xuY29uc3QgdmFsaWRhdGVTZXJ2ZXJGb3JBZGREYXRhU3RvcmUgPSBhc3luYyAoaXRlbSwgc2VydmVyLCBkYXRhc3RvcmVUeXBlKSA9PiB7XG4gICAgdmFyIF9hO1xuICAgIGxldCBkYXRhc3RvcmVQYXlsb2FkO1xuICAgIGNvbnN0IGJkZnNUeXBlID0gaXRlbS5iZGZzVHlwZTtcbiAgICBsZXQgdmFsaWRhdGVTZXJ2ZXJQYXlsb2FkID0gbnVsbDtcbiAgICBpZiAoZGF0YXN0b3JlVHlwZSA9PT0gXCJiZGZzXCIpIHtcbiAgICAgICAgaWYgKGJkZnNUeXBlID09PSBcImZpbGVzaGFyZVwiKSB7XG4gICAgICAgICAgICBkYXRhc3RvcmVQYXlsb2FkID0gY3JlYXRlRmlsZVNoYXJlUHJvdmlkZXJEYXRhT2JqZWN0KGl0ZW0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGJkZnNUeXBlID09PSBcImhkZnNcIikge1xuICAgICAgICAgICAgZGF0YXN0b3JlUGF5bG9hZCA9IGNyZWF0ZUhkZnNQcm92aWRlckRhdGFPYmplY3QoaXRlbSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYmRmc1R5cGUgPT09IFwiaGl2ZVwiKSB7XG4gICAgICAgICAgICBkYXRhc3RvcmVQYXlsb2FkID0gY3JlYXRlSGl2ZVByb3ZpZGVyRGF0YU9iamVjdChpdGVtKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChiZGZzVHlwZSA9PT0gXCJjbG91ZFwiKSB7XG4gICAgICAgICAgICBpZiAoaXRlbS5iZGZzQ2xvdWRUeXBlID09PSBcIm5ld1wiKSB7XG4gICAgICAgICAgICAgICAgZGF0YXN0b3JlUGF5bG9hZCA9IGNyZWF0ZUNsb3VkUHJvdmlkZXJEYXRhT2JqZWN0KGl0ZW0pO1xuICAgICAgICAgICAgICAgIGRhdGFzdG9yZVBheWxvYWQuaW5mby5pc01hbmFnZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHZhbGlkYXRpbmcgYWdhaW5zdCBleGlzdGluZyBjbG91ZCBkYXRhIHN0b3JlXG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YWxpZGF0ZVNlcnZlclBheWxvYWQgPSB7XG4gICAgICAgICAgICAgICAgICAgIHNlcnZlcklkOiBzZXJ2ZXIuaWQsXG4gICAgICAgICAgICAgICAgICAgIGRhdGFzdG9yZUlkOiBpdGVtLmJkZnNFeGlzdGluZ0RhdGFzdG9yZS5pZCxcbiAgICAgICAgICAgICAgICAgICAgZjogXCJqc29uXCJcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAoZGF0YXN0b3JlVHlwZSA9PT0gXCJmb2xkZXJcIikge1xuICAgICAgICAgICAgZGF0YXN0b3JlUGF5bG9hZCA9IGNyZWF0ZUZvbGRlckRhdGFPYmplY3QoaXRlbSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGF0YXN0b3JlVHlwZSA9PT0gXCJkYXRhYmFzZVwiKSB7XG4gICAgICAgICAgICBkYXRhc3RvcmVQYXlsb2FkID0gY3JlYXRlRGF0YWJhc2VEYXRhT2JqZWN0KGl0ZW0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRhdGFzdG9yZVR5cGUgPT09IFwiY2xvdWRcIikge1xuICAgICAgICAgICAgZGF0YXN0b3JlUGF5bG9hZCA9IGNyZWF0ZUNsb3VkUHJvdmlkZXJEYXRhT2JqZWN0KGl0ZW0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRhdGFzdG9yZVR5cGUgPT09IFwibm9zcWxcIikge1xuICAgICAgICAgICAgZGF0YXN0b3JlUGF5bG9hZCA9IGNyZWF0ZU5vU3FsRGF0YU9iamVjdChpdGVtKTtcbiAgICAgICAgfVxuICAgICAgICBkYXRhc3RvcmVQYXlsb2FkLmluZm8uaXNNYW5hZ2VkID0gZmFsc2U7XG4gICAgfVxuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVycy5hcmNnaXMuY29tL3Jlc3QvdXNlcnMtZ3JvdXBzLWFuZC1pdGVtcy92YWxpZGF0ZS1kYXRhc3RvcmUuaHRtXG4gICAgY29uc3QgcG9ydGFsID0gY29uZmlnU3RhdGUucG9ydGFsO1xuICAgIGNvbnN0IHJlc3RCYXNlVXJsID0gYCR7KF9hID0gcG9ydGFsLnJlc3RVcmwpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHBvcnRhbC5wb3J0YWxVcmx9cG9ydGFscy8ke3BvcnRhbC5pZH1gO1xuICAgIGNvbnN0IHZhbGlkYXRlU2VydmVyVXJsID0gYCR7cmVzdEJhc2VVcmx9L2RhdGFzdG9yZXMvdmFsaWRhdGVgO1xuICAgIGlmICghdmFsaWRhdGVTZXJ2ZXJQYXlsb2FkICYmIGl0ZW0uYWxsb3dTZXJ2aWNlc1Jlc3RhcnQpIHtcbiAgICAgICAgdmFsaWRhdGVTZXJ2ZXJQYXlsb2FkID0ge1xuICAgICAgICAgICAgZGF0YXN0b3JlOiBKU09OLnN0cmluZ2lmeShkYXRhc3RvcmVQYXlsb2FkKSxcbiAgICAgICAgICAgIHNlcnZlcklkOiBzZXJ2ZXIuaWQsXG4gICAgICAgICAgICBvcHRpb25zOiBKU09OLnN0cmluZ2lmeSh7IGFsbG93U2VydmljZXNSZXN0YXJ0OiB0cnVlIH0pLFxuICAgICAgICAgICAgZjogXCJqc29uXCJcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHZhbGlkYXRlU2VydmVyUGF5bG9hZCA9IHtcbiAgICAgICAgICAgIGRhdGFzdG9yZTogSlNPTi5zdHJpbmdpZnkoZGF0YXN0b3JlUGF5bG9hZCksXG4gICAgICAgICAgICBzZXJ2ZXJJZDogc2VydmVyLmlkLFxuICAgICAgICAgICAgZjogXCJqc29uXCJcbiAgICAgICAgfTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgeyBzdGF0dXMsIG1hY2hpbmVzIH0gPSBhd2FpdCByZXF1ZXN0KHZhbGlkYXRlU2VydmVyVXJsLCB2YWxpZGF0ZVNlcnZlclBheWxvYWQsIHt9LCBcInBvc3RcIik7XG4gICAgICAgIHJldHVybiB7IHN0YXR1czogc3RhdHVzLCBtYWNoaW5lczogbWFjaGluZXMgfTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xuICAgICAgICByZXR1cm4geyBlcnJvcjogeyBjb2RlOiBcInVuaGFuZGxlZEVycm9yXCIsIG1lc3NhZ2U6IEpTT04uc3RyaW5naWZ5KGVycm9yKSB9IH07XG4gICAgfVxufTtcbmNvbnN0IGNoZWNrU2VydmVyc1R5cGUgPSBhc3luYyAoc2VydmVyTGlzdCkgPT4ge1xuICAgIGxldCBzZXJ2ZXJUeXBlcyA9IFtdO1xuICAgIGxldCBzZXJ2ZXJzID0gc2VydmVyTGlzdDtcbiAgICBpZiAoaXNBcmNHSVNFbnRlcnByaXNlT25LdWJlcm5ldGVzKCkpIHtcbiAgICAgICAgY29uc3Qgc2VydmVyc1RvVmFsaWRhdGUgPSBbXTtcbiAgICAgICAgc2VydmVycy5mb3JFYWNoKChmZWRlcmF0ZWRTZXJ2ZXIpID0+IHtcbiAgICAgICAgICAgIGlmIChmZWRlcmF0ZWRTZXJ2ZXIuaXNIb3N0ZWQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzZXJ2ZXJJdGVtID0geyBuYW1lOiBmZWRlcmF0ZWRTZXJ2ZXIuYWRtaW5VcmwsIHR5cGU6IFwiTGludXhcIiB9O1xuICAgICAgICAgICAgICAgIHNlcnZlclR5cGVzLnB1c2goc2VydmVySXRlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChmZWRlcmF0ZWRTZXJ2ZXIuc2VydmVyUm9sZSA9PT0gXCJGRURFUkFURURfU0VSVkVSXCIpIHtcbiAgICAgICAgICAgICAgICBzZXJ2ZXJzVG9WYWxpZGF0ZS5wdXNoKGZlZGVyYXRlZFNlcnZlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCByZXNwb25zZXMgPSBhd2FpdCBQcm9taXNlLmFsbFNldHRsZWQoc2VydmVyc1RvVmFsaWRhdGUubWFwKChzZXJ2ZXIpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHVybCA9IGAke3NlcnZlci5hZG1pblVybH0vYWRtaW4vbWFjaGluZXM/Zj1qc29uYDtcbiAgICAgICAgICAgIHJldHVybiByZXF1ZXN0KHVybCwge30sIHt9LCBcInBvc3RcIik7XG4gICAgICAgIH0pKTtcbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGxTZXR0bGVkKHJlc3BvbnNlcy5tYXAoKHJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICByZXR1cm4gdmFsaWRhdGVTZXJ2ZXJUeXBlS3ViZXJuZXRlcygoX2EgPSByZXNwb25zZSA9PT0gbnVsbCB8fCByZXNwb25zZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVzcG9uc2UudmFsdWUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5tYWNoaW5lcywgc2VydmVycykudGhlbigodmFsaWRhdGVkU2VydmVyVHlwZXMpID0+IHtcbiAgICAgICAgICAgICAgICBzZXJ2ZXJUeXBlcyA9IFsuLi5zZXJ2ZXJUeXBlcywgLi4udmFsaWRhdGVkU2VydmVyVHlwZXNdO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIDEuIFJldHJpZXZlIHRoZSBGZWRlcmF0ZWQgbWFjaGluZXNcbiAgICAgICAgY29uc3QgcmVzcG9uc2VzID0gYXdhaXQgUHJvbWlzZS5hbGxTZXR0bGVkKHNlcnZlcnMubWFwKChzZXJ2ZXIpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHVybCA9IGAke3NlcnZlci5hZG1pblVybH0vYWRtaW4vbWFjaGluZXM/Zj1qc29uYDtcbiAgICAgICAgICAgIHJldHVybiByZXF1ZXN0KHVybCwge30sIHt9LCBcInBvc3RcIik7XG4gICAgICAgIH0pKTtcbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGxTZXR0bGVkKHJlc3BvbnNlcy5tYXAoKHJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICByZXR1cm4gdmFsaWRhdGVTZXJ2ZXJUeXBlKChfYSA9IHJlc3BvbnNlID09PSBudWxsIHx8IHJlc3BvbnNlID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZXNwb25zZS52YWx1ZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm1hY2hpbmVzLCBzZXJ2ZXJzKS50aGVuKChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICBzZXJ2ZXJzID0gWy4uLnJlc3VsdC5zZXJ2ZXJMaXN0XTtcbiAgICAgICAgICAgICAgICBzZXJ2ZXJUeXBlcyA9IHJlc3VsdC5zZXJ2ZXJUeXBlcztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KSk7XG4gICAgfVxuICAgIHJldHVybiB7IHNlcnZlcnM6IHNlcnZlcnMsIHNlcnZlclR5cGVzOiBzZXJ2ZXJUeXBlcyB9O1xufTtcbmNvbnN0IHZhbGlkYXRlU2VydmVyVHlwZSA9IGFzeW5jIChtYWNoaW5lcywgc2VydmVyTGlzdCkgPT4ge1xuICAgIGxldCBzZXJ2ZXJUeXBlcyA9IFtdO1xuICAgIC8vIDIuIFZhbGlkYXRlIHNlcnZlciB0eXBlXG4gICAgc2VydmVyTGlzdC5tYXAoKHNlcnZlciwgaW5kZXgpID0+IHtcbiAgICAgICAgaWYgKG1hY2hpbmVzID09PSBudWxsIHx8IG1hY2hpbmVzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBtYWNoaW5lc1tpbmRleF0pIHtcbiAgICAgICAgICAgIHNlcnZlci5zaG91bGRGaWx0ZXIgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNlcnZlci5zaG91bGRGaWx0ZXIgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgc2VydmVyTGlzdC5maWx0ZXIoKHNlcnZlcikgPT4ge1xuICAgICAgICByZXR1cm4gIXNlcnZlci5zaG91bGRGaWx0ZXI7XG4gICAgfSk7XG4gICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IHNlcnZlckxpc3QubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgIGNvbnN0IG1hY2hpbmUgPSBtYWNoaW5lc1swXS5tYWNoaW5lTmFtZTtcbiAgICAgICAgY29uc3QgdXJsID0gYCR7bWFjaGluZXNbMF0uYWRtaW5VUkx9L21hY2hpbmVzLyR7bWFjaGluZX0/Zj1qc29uYDtcbiAgICAgICAgYXdhaXQgcmVxdWVzdCh1cmwsIHt9LCB7fSwgXCJwb3N0XCIpLnRoZW4oKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNlcnZlckl0ZW0gPSB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IHNlcnZlckxpc3RbaW5kZXhdLmFkbWluVXJsLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiByZXN1bHQucGxhdGZvcm0uaW5kZXhPZihcIldpbmRvd3NcIikgPiAtMSA/IFwiV2luZG93c1wiIDogXCJMaW51eFwiXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBzZXJ2ZXJUeXBlcy5wdXNoKHNlcnZlckl0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHsgc2VydmVyVHlwZXM6IHNlcnZlclR5cGVzLCBzZXJ2ZXJMaXN0OiBzZXJ2ZXJMaXN0IH07XG59O1xuY29uc3QgcmVxdWVzdENsb3VkU3RvcmVMaXN0ID0gYXN5bmMgKCkgPT4ge1xuICAgIGNvbnN0IG9yZ0lkID0gY29uZmlnU3RhdGUudXNlci5vcmdJZDtcbiAgICBjb25zdCB0eXBlID0gXCJEYXRhIFN0b3JlXCI7XG4gICAgY29uc3QgcSA9IGBvcmdpZDoke29yZ0lkfSB0eXBlOlwiJHt0eXBlfVwiYDtcbiAgICBjb25zdCBudW0gPSAxMDAwMDtcbiAgICBjb25zdCBjb250ZW50ID0geyBxLCBudW0gfTtcbiAgICBjb25zdCB1cmwgPSBgJHtnZXRSZXN0QmFzZVVybCgpfXNlYXJjaGA7XG4gICAgY29uc3Qgc3VwcG9ydGVkQ2xvdWRTdG9yZXMgPSBbXG4gICAgICAgIFwiY2xvdWRTdG9yZV9hbWF6b25cIixcbiAgICAgICAgXCJjbG91ZFN0b3JlX2F6dXJlXCIsXG4gICAgICAgIFwiY2xvdWRTdG9yZV9henVyZWRhdGFsYWtlZ2VuMnN0b3JlXCIsXG4gICAgICAgIFwiY2xvdWRTdG9yZV9henVyZURhdGFMYWtlU3RvcmVcIlxuICAgIF07XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgZXhpc3RpbmdDbG91ZFN0b3JlSWRzID0gW107XG4gICAgICAgIGNvbnN0IHsgcmVzdWx0cyB9ID0gYXdhaXQgcmVxdWVzdCh1cmwsIGNvbnRlbnQpO1xuICAgICAgICByZXN1bHRzID09PSBudWxsIHx8IHJlc3VsdHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlc3VsdHMuZm9yRWFjaCgoeyBpZCwgdGl0bGUsIHR5cGUsIHR5cGVLZXl3b3JkcyB9KSA9PiB7XG4gICAgICAgICAgICAvLyBFeGNsdWRlIEJpZyBEYXRhIEZpbGUgU2hhcmUgaXRlbXNcbiAgICAgICAgICAgIGlmICghdHlwZUtleXdvcmRzLmluY2x1ZGVzKFwiYmlnRGF0YUZpbGVTaGFyZVwiKSAmJlxuICAgICAgICAgICAgICAgIHR5cGVLZXl3b3Jkcy5zb21lKChrZXl3b3JkKSA9PiBzdXBwb3J0ZWRDbG91ZFN0b3Jlcy5pbmNsdWRlcyhrZXl3b3JkKSkpIHtcbiAgICAgICAgICAgICAgICBleGlzdGluZ0Nsb3VkU3RvcmVJZHMucHVzaCh7IGlkLCB0aXRsZSwgdHlwZSwgdHlwZUtleXdvcmRzIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHsgcmVzdWx0OiBleGlzdGluZ0Nsb3VkU3RvcmVJZHMgfTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xuICAgICAgICByZXR1cm4geyBlcnJvcjogeyBjb2RlOiBcInVuaGFuZGxlZEVycm9yXCIsIG1lc3NhZ2U6IEpTT04uc3RyaW5naWZ5KGVycm9yKSB9IH07XG4gICAgfVxufTtcbmNvbnN0IHJlcXVlc3RDbG91ZFN0b3JlSW5mbyA9IGFzeW5jIChzZWxlY3RlZENsb3VkU3RvcmVJZCkgPT4ge1xuICAgIGNvbnN0IHVybCA9IGAke2dldFJlc3RCYXNlVXJsKCl9Y29udGVudC9pdGVtcy8ke3NlbGVjdGVkQ2xvdWRTdG9yZUlkfS9kYXRhYDtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCB7IGlkLCBwYXRoLCBwcm92aWRlciB9ID0gYXdhaXQgcmVxdWVzdCh1cmwpO1xuICAgICAgICByZXR1cm4geyBpZDogaWQsIHBhdGg6IHBhdGgsIHByb3ZpZGVyOiBwcm92aWRlciB9O1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gICAgICAgIHJldHVybiB7IGVycm9yOiB7IGNvZGU6IFwidW5oYW5kbGVkRXJyb3JcIiwgbWVzc2FnZTogSlNPTi5zdHJpbmdpZnkoZXJyb3IpIH0gfTtcbiAgICB9XG59O1xuY29uc3QgdmFsaWRhdGVTZXJ2ZXJUeXBlS3ViZXJuZXRlcyA9IGFzeW5jIChtYWNoaW5lcywgc2VydmVyTGlzdCkgPT4ge1xuICAgIGxldCBzZXJ2ZXJUeXBlcyA9IFtdO1xuICAgIGF3YWl0IFByb21pc2UuYWxsKHNlcnZlckxpc3QubWFwKChmZWRlcmF0ZWRTZXJ2ZXIsIGluZGV4KSA9PiB7XG4gICAgICAgIGlmICghZmVkZXJhdGVkU2VydmVyLmlzSG9zdGVkKSB7XG4gICAgICAgICAgICBjb25zdCBtYWNoaW5lID0gbWFjaGluZXNbMF0ubWFjaGluZU5hbWU7XG4gICAgICAgICAgICBjb25zdCB1cmwgPSBgJHttYWNoaW5lc1swXS5hZG1pblVSTH0vbWFjaGluZXMvJHttYWNoaW5lfT9mPWpzb25gO1xuICAgICAgICAgICAgcmV0dXJuIHJlcXVlc3QodXJsLCB7fSwge30sIFwicG9zdFwiKS50aGVuKChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIXJlc3VsdC5pc0hvc3RlZCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzZXJ2ZXJJdGVtID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogc2VydmVyTGlzdFtpbmRleF0uYWRtaW5VcmwsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiByZXN1bHQucGxhdGZvcm0uaW5kZXhPZihcIldpbmRvd3NcIikgPiAtMSA/IFwiV2luZG93c1wiIDogXCJMaW51eFwiXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHNlcnZlclR5cGVzLnB1c2goc2VydmVySXRlbSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9KSk7XG4gICAgcmV0dXJuIHNlcnZlclR5cGVzO1xufTtcbmNvbnN0IHJlZ2lzdGVyRGF0YVN0b3JlV2l0aFNlcnZlcnMgPSBhc3luYyAoYWRkSXRlbUluZm8sIGl0ZW0sIHRpdGxlLCB0YWdzLCBjYXRlZ29yaWVzLCBzbmlwcGV0KSA9PiB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IHsgcG9ydGFsIH0gPSBjb25maWdTdGF0ZTtcbiAgICBjb25zdCByZXN0QmFzZVVybCA9IGAkeyhfYSA9IHBvcnRhbC5yZXN0VXJsKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBwb3J0YWwucG9ydGFsVXJsfXBvcnRhbHMvJHtwb3J0YWwuaWR9YDtcbiAgICBjb25zdCBzZXJ2ZXJzID0gaXRlbS5kYXRhU3RvcmVTZWxlY3RlZFNlcnZlcnM7XG4gICAgY29uc3QgYWRkUmVzdWx0cyA9IGF3YWl0IFByb21pc2UuYWxsKHNlcnZlcnMubWFwKChzZXJ2ZXJJZCkgPT4ge1xuICAgICAgICBjb25zdCBjb250ZW50ID0ge1xuICAgICAgICAgICAgc2VydmVySWQsXG4gICAgICAgICAgICBkYXRhc3RvcmVJZDogYWRkSXRlbUluZm8uaWRcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGlzQXJjR0lTRW50ZXJwcmlzZU9uS3ViZXJuZXRlcygpICYmIGl0ZW0uYWRkRGF0YVN0b3JlVHlwZSA9PT0gXCJmb2xkZXJcIiAmJiBpdGVtLmFsbG93U2VydmljZXNSZXN0YXJ0KSB7XG4gICAgICAgICAgICBjb250ZW50Lm9wdGlvbnMgPSBKU09OLnN0cmluZ2lmeSh7IGFsbG93U2VydmljZXNSZXN0YXJ0OiB0cnVlIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFkZFRvU2VydmVyVXJsID0gYCR7cmVzdEJhc2VVcmx9L2RhdGFzdG9yZXMvYWRkVG9TZXJ2ZXJgO1xuICAgICAgICByZXR1cm4gcmVxdWVzdChhZGRUb1NlcnZlclVybCwgY29udGVudCwge30sIFwicG9zdFwiKTtcbiAgICB9KSk7XG4gICAgbGV0IHJlc3VsdCA9IHsgc3VjY2VzczogZmFsc2UsIGlkOiBudWxsLCBmb2xkZXI6IG51bGwgfTtcbiAgICBmb3IgKGNvbnN0IGFkZFJlc3VsdCBvZiBhZGRSZXN1bHRzKSB7XG4gICAgICAgIC8vIFRPRE86IGVycm9yIGNoZWNraW5nIGZvciB0aGUgc2VydmVyc1xuICAgICAgICAvLyBjb25zdCBlcnJvcnMgPSBbXTtcbiAgICAgICAgLy8gaWYgKCFhZGRSZXN1bHQgfHwgIShhZGRSZXN1bHQucmVzdWx0WzFdIHx8IHt9KS5zdWNjZXNzKSB7XG4gICAgICAgIC8vICAgZXJyb3JzLnB1c2goYWRkUmVzdWx0LnJlc3VsdFsxXSk7XG4gICAgICAgIC8vIH1cbiAgICAgICAgaWYgKGFkZFJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgICAgICBpZiAoaXRlbS5hZGREYXRhU3RvcmVUeXBlID09PSBcImJkZnNcIiAmJiBpdGVtLmJkZnNUeXBlID09PSBcImNsb3VkXCIgJiYgaXRlbS5iZGZzQ2xvdWRUeXBlID09PSBcIm5ld1wiKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gYXdhaXQgYWRkQmRmc0RhdGFTdG9yZUl0ZW0oaXRlbSwgdGl0bGUsIHRhZ3MsIGNhdGVnb3JpZXMsIHNuaXBwZXQsIGFkZEl0ZW1JbmZvLmlkKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKFtcImZvbGRlclwiLCBcImRhdGFiYXNlXCIsIFwibm9zcWxcIiwgXCJjbG91ZFwiXS5pbmNsdWRlcyhpdGVtLmFkZERhdGFTdG9yZVR5cGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHsgc3VjY2VzczogdHJ1ZSwgaWQ6IGFkZEl0ZW1JbmZvLmlkLCBmb2xkZXI6IGFkZEl0ZW1JbmZvLmlkIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBGb3IgQkRGUyBEYXRhIFN0b3JlOiBnZXQgQ2F0YWxvZyBTZXJ2aWNlIGl0ZW0gaWRcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZ2V0Q2F0YWxvZyA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGl0ZW1VcmwgPSBgJHtnZXRSZXN0QmFzZVVybCgpfWNvbnRlbnQvaXRlbXMvJHthZGRJdGVtSW5mby5pZH0vcmVsYXRlZEl0ZW1zYDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgcmVxdWVzdChpdGVtVXJsLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVsYXRpb25zaGlwVHlwZTogXCJCREZTRGF0YVN0b3JlMkJERlNDYXRhbG9nU2VydmljZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpcmVjdGlvbjogXCJmb3J3YXJkXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlLnRvdGFsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0geyBzdWNjZXNzOiB0cnVlLCBpZDogcmVzcG9uc2UucmVsYXRlZEl0ZW1zWzBdLmlkLCBmb2xkZXI6IGFkZEl0ZW1JbmZvLmlkIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRpbWVvdXQoMTAwMDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBnZXRDYXRhbG9nKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGdldENhdGFsb2coKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG4vL2ZvciBhZGRpbmcgQkRGUyBjbG91ZCBkYXRhIHN0b3JlXG5jb25zdCBhZGRCZGZzRGF0YVN0b3JlSXRlbSA9IGFzeW5jIChpdGVtLCB0aXRsZSwgdGFncywgY2F0ZWdvcmllcywgc25pcHBldCwgY2xvdWRJZCwgY2xvdWRQYXRoKSA9PiB7XG4gICAgY29uc3QgdXJsID0gYCR7Z2V0UmVzdEJhc2VVcmwoKX1jb250ZW50L2l0ZW1zLyR7Y2xvdWRJZH0vZGF0YWA7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCByZXF1ZXN0KHVybCk7XG4gICAgY29uc3QgcGF0aCA9IGNsb3VkUGF0aCB8fCByZXNwb25zZS5wYXRoO1xuICAgIGNvbnN0IGRhdGFzdG9yZVRpdGxlID0gcGF0aC5zcGxpdChcIi9cIilbMl0uc3BsaXQoXCJfXCIpWzBdO1xuICAgIGNvbnN0IGRhdGEgPSB7XG4gICAgICAgIHR5cGU6IFwiRGF0YSBTdG9yZVwiLFxuICAgICAgICB0aXRsZTogdGl0bGUgfHwgZGF0YXN0b3JlVGl0bGUsXG4gICAgICAgIHRhZ3M6IHRhZ3MsXG4gICAgICAgIGNhdGVnb3JpZXM6IGNhdGVnb3JpZXMsXG4gICAgICAgIHNuaXBwZXQ6IHNuaXBwZXQsXG4gICAgICAgIHRleHQ6IFwiXCJcbiAgICB9O1xuICAgIGRhdGEudGV4dCA9IGdldEJkZnNQYXJhbWV0ZXJJdGVtKGRhdGEudGl0bGUsIHBhdGgpO1xuICAgIGl0ZW0uYWRkRGF0YVN0b3JlVHlwZSA9IFwiYmRmc0RhdGFTdG9yZVwiO1xuICAgIGxldCBhZGRJdGVtUmVzcG9uc2UgPSBhd2FpdCBhZGRJdGVtKGRhdGEsIG51bGwpO1xuICAgIGlmIChhZGRJdGVtUmVzcG9uc2Uuc3VjY2VzcyAmJiBjb25maWdTdGF0ZS5wb3J0YWwuaXNQb3J0YWwpIHtcbiAgICAgICAgYWRkSXRlbVJlc3BvbnNlID0gYXdhaXQgcmVnaXN0ZXJEYXRhU3RvcmVXaXRoU2VydmVycyhhZGRJdGVtUmVzcG9uc2UsIGl0ZW0pO1xuICAgIH1cbiAgICByZXR1cm4gYWRkSXRlbVJlc3BvbnNlO1xufTtcbmNvbnN0IGFkZERhdGFTdG9yZSA9IGFzeW5jIChpdGVtLCB0aXRsZSwgdGFncywgY2F0ZWdvcmllcywgc25pcHBldCkgPT4ge1xuICAgIGNvbnN0IGRhdGFzdG9yZVR5cGUgPSBpdGVtLmFkZERhdGFTdG9yZVR5cGU7XG4gICAgY29uc3QgZGF0YSA9IHtcbiAgICAgICAgdHlwZTogXCJEYXRhIFN0b3JlXCIsXG4gICAgICAgIHRpdGxlOiB0aXRsZSxcbiAgICAgICAgdGFnczogdGFncyxcbiAgICAgICAgY2F0ZWdvcmllczogY2F0ZWdvcmllcyxcbiAgICAgICAgc25pcHBldDogc25pcHBldCxcbiAgICAgICAgdGV4dDogXCJcIixcbiAgICAgICAgdHlwZUtleXdvcmRzOiBpdGVtLnR5cGVLZXl3b3Jkc1xuICAgIH07XG4gICAgbGV0IHRleHQ7XG4gICAgY29uc3QgYmRmc1R5cGUgPSBpdGVtLmJkZnNUeXBlO1xuICAgIGlmIChkYXRhc3RvcmVUeXBlID09PSBcImJkZnNcIikge1xuICAgICAgICBpZiAoYmRmc1R5cGUgPT09IFwiZmlsZXNoYXJlXCIpIHtcbiAgICAgICAgICAgIHRleHQgPSBjcmVhdGVGaWxlU2hhcmVQcm92aWRlckRhdGFPYmplY3QoaXRlbSwgdGl0bGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGJkZnNUeXBlID09PSBcImhkZnNcIikge1xuICAgICAgICAgICAgdGV4dCA9IGNyZWF0ZUhkZnNQcm92aWRlckRhdGFPYmplY3QoaXRlbSwgdGl0bGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGJkZnNUeXBlID09PSBcImhpdmVcIikge1xuICAgICAgICAgICAgdGV4dCA9IGNyZWF0ZUhpdmVQcm92aWRlckRhdGFPYmplY3QoaXRlbSwgdGl0bGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGJkZnNUeXBlID09PSBcImNsb3VkXCIpIHtcbiAgICAgICAgICAgIGlmIChpdGVtLmJkZnNDbG91ZFR5cGUgPT09IFwibmV3XCIpIHtcbiAgICAgICAgICAgICAgICB0ZXh0ID0gY3JlYXRlQ2xvdWRQcm92aWRlckRhdGFPYmplY3QoaXRlbSwgdGl0bGUpO1xuICAgICAgICAgICAgICAgIHRleHQuaW5mby5pc01hbmFnZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCBhZGRCZGZzRGF0YVN0b3JlSXRlbShpdGVtLCB0aXRsZSwgdGFncywgY2F0ZWdvcmllcywgc25pcHBldCwgaXRlbS5iZGZzRXhpc3RpbmdEYXRhc3RvcmUuaWQsIGl0ZW0uYmRmc0V4aXN0aW5nRGF0YXN0b3JlLnBhdGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAoZGF0YXN0b3JlVHlwZSA9PT0gXCJmb2xkZXJcIikge1xuICAgICAgICAgICAgdGV4dCA9IGNyZWF0ZUZvbGRlckRhdGFPYmplY3QoaXRlbSwgdGl0bGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRhdGFzdG9yZVR5cGUgPT09IFwiZGF0YWJhc2VcIikge1xuICAgICAgICAgICAgdGV4dCA9IGNyZWF0ZURhdGFiYXNlRGF0YU9iamVjdChpdGVtLCB0aXRsZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGF0YXN0b3JlVHlwZSA9PT0gXCJjbG91ZFwiKSB7XG4gICAgICAgICAgICB0ZXh0ID0gY3JlYXRlQ2xvdWRQcm92aWRlckRhdGFPYmplY3QoaXRlbSwgdGl0bGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRhdGFzdG9yZVR5cGUgPT09IFwibm9zcWxcIikge1xuICAgICAgICAgICAgdGV4dCA9IGNyZWF0ZU5vU3FsRGF0YU9iamVjdChpdGVtLCB0aXRsZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGV4dC5pbmZvLmlzTWFuYWdlZCA9IGZhbHNlO1xuICAgIH1cbiAgICBkYXRhLnRleHQgPSBKU09OLnN0cmluZ2lmeSh0ZXh0KTtcbiAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCBhZGRJdGVtKGRhdGEsIG51bGwpO1xuICAgIGlmIChyZXNwb25zZS5zdWNjZXNzICYmIGNvbmZpZ1N0YXRlLnBvcnRhbC5pc1BvcnRhbCkge1xuICAgICAgICByZXNwb25zZSA9IGF3YWl0IHJlZ2lzdGVyRGF0YVN0b3JlV2l0aFNlcnZlcnMocmVzcG9uc2UsIGl0ZW0sIHRpdGxlLCB0YWdzLCBjYXRlZ29yaWVzLCBzbmlwcGV0KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3BvbnNlO1xufTtcblxuZXhwb3J0IHsgYWRkRGF0YVN0b3JlIGFzIGEsIHJlcXVlc3RDbG91ZFN0b3JlTGlzdCBhcyBiLCB2YWxpZGF0ZURhdGFzdG9yZUZvclNlcnZlcnMgYXMgYywgY2hlY2tTZXJ2ZXJzVHlwZSBhcyBkLCB2YWxpZGF0ZURhdGFzdG9yZVNlcnZlciBhcyBlLCBmZXRjaENsb3VkU3RvcmFnZVJlZ2lvbkluZm8gYXMgZiwgZ2V0RGF0YXN0b3JlQ29udGVudHMgYXMgZywgaGFuZGxlRGF0YWJhc2VGaWxlRHJvcCBhcyBoLCBwdWJsaXNoRnJvbURhdGFTdG9yZSBhcyBwLCByZXF1ZXN0Q2xvdWRTdG9yZUluZm8gYXMgciwgdmFsaWRhdGVEYXRhc3RvcmVGb3JPbmxpbmUgYXMgdiB9O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhLXN0b3JlLWUyYWU2YTY3LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==