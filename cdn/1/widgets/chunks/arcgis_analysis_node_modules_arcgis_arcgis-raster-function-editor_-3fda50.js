"use strict";
(self["webpackChunkexb_client"] = self["webpackChunkexb_client"] || []).push([["vendors-extensions_widgets_arcgis_analysis_node_modules_arcgis_arcgis-raster-function-editor_-3fda50"],{

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/arcgis-raster-function-editor/dist/esm/common-strings.es-c65ca642.js":
/*!**************************************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/arcgis-raster-function-editor/dist/esm/common-strings.es-c65ca642.js ***!
  \**************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   addRaster: () => (/* binding */ addRaster),
/* harmony export */   addScalar: () => (/* binding */ addScalar),
/* harmony export */   breadcrumb: () => (/* binding */ breadcrumb),
/* harmony export */   breadcrumbEditor: () => (/* binding */ breadcrumbEditor),
/* harmony export */   cancel: () => (/* binding */ cancel),
/* harmony export */   category: () => (/* binding */ category),
/* harmony export */   categoryNames: () => (/* binding */ categoryNames),
/* harmony export */   close: () => (/* binding */ close),
/* harmony export */   copy: () => (/* binding */ copy),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   defaultModelName: () => (/* binding */ defaultModelName),
/* harmony export */   definitionQuery: () => (/* binding */ definitionQuery),
/* harmony export */   description: () => (/* binding */ description),
/* harmony export */   deselectFunction: () => (/* binding */ deselectFunction),
/* harmony export */   details: () => (/* binding */ details),
/* harmony export */   dialogTitle: () => (/* binding */ dialogTitle),
/* harmony export */   dontSave: () => (/* binding */ dontSave),
/* harmony export */   enterFURL: () => (/* binding */ enterFURL),
/* harmony export */   enterURL: () => (/* binding */ enterURL),
/* harmony export */   error: () => (/* binding */ error),
/* harmony export */   errorTitle: () => (/* binding */ errorTitle),
/* harmony export */   everyone: () => (/* binding */ everyone),
/* harmony export */   f32PixelType: () => (/* binding */ f32PixelType),
/* harmony export */   f64PixelType: () => (/* binding */ f64PixelType),
/* harmony export */   failedToLoadLayer: () => (/* binding */ failedToLoadLayer),
/* harmony export */   folder: () => (/* binding */ folder),
/* harmony export */   general: () => (/* binding */ general),
/* harmony export */   groupFieldName: () => (/* binding */ groupFieldName),
/* harmony export */   groupItemsBy: () => (/* binding */ groupItemsBy),
/* harmony export */   groups: () => (/* binding */ groups),
/* harmony export */   invalidRFTMessage: () => (/* binding */ invalidRFTMessage),
/* harmony export */   isDataset: () => (/* binding */ isDataset),
/* harmony export */   isPublic: () => (/* binding */ isPublic),
/* harmony export */   item: () => (/* binding */ item),
/* harmony export */   itemGroup: () => (/* binding */ itemGroup),
/* harmony export */   loadingLayer: () => (/* binding */ loadingLayer),
/* harmony export */   matchVariables: () => (/* binding */ matchVariables),
/* harmony export */   mosaic: () => (/* binding */ mosaic),
/* harmony export */   multidimensionalRules: () => (/* binding */ multidimensionalRules),
/* harmony export */   name: () => (/* binding */ name),
/* harmony export */   noTagErrorMsg: () => (/* binding */ noTagErrorMsg),
/* harmony export */   noTitleErrorMsg: () => (/* binding */ noTitleErrorMsg),
/* harmony export */   noTitleTagErrorMsg: () => (/* binding */ noTitleTagErrorMsg),
/* harmony export */   ok: () => (/* binding */ ok),
/* harmony export */   organization: () => (/* binding */ organization),
/* harmony export */   outputPixelType: () => (/* binding */ outputPixelType),
/* harmony export */   owner: () => (/* binding */ owner),
/* harmony export */   parameter: () => (/* binding */ parameter),
/* harmony export */   parameters: () => (/* binding */ parameters),
/* harmony export */   properties: () => (/* binding */ properties),
/* harmony export */   raster: () => (/* binding */ raster),
/* harmony export */   rasterFunctionEditor: () => (/* binding */ rasterFunctionEditor),
/* harmony export */   rasterFunctions: () => (/* binding */ rasterFunctions),
/* harmony export */   rfxLicenseInfo: () => (/* binding */ rfxLicenseInfo),
/* harmony export */   s16PixelType: () => (/* binding */ s16PixelType),
/* harmony export */   s32PixelType: () => (/* binding */ s32PixelType),
/* harmony export */   s8PixelType: () => (/* binding */ s8PixelType),
/* harmony export */   save: () => (/* binding */ save),
/* harmony export */   saveAs: () => (/* binding */ saveAs),
/* harmony export */   saveUtils: () => (/* binding */ saveUtils),
/* harmony export */   savingMessage: () => (/* binding */ savingMessage),
/* harmony export */   scalar: () => (/* binding */ scalar),
/* harmony export */   search: () => (/* binding */ search),
/* harmony export */   selectFeature: () => (/* binding */ selectFeature),
/* harmony export */   selectFunction: () => (/* binding */ selectFunction),
/* harmony export */   selectRaster: () => (/* binding */ selectRaster),
/* harmony export */   serviceURL: () => (/* binding */ serviceURL),
/* harmony export */   setGroupSharing: () => (/* binding */ setGroupSharing),
/* harmony export */   setSharingLevel: () => (/* binding */ setSharingLevel),
/* harmony export */   share: () => (/* binding */ share),
/* harmony export */   shareWith: () => (/* binding */ shareWith),
/* harmony export */   success: () => (/* binding */ success),
/* harmony export */   tagFieldName: () => (/* binding */ tagFieldName),
/* harmony export */   tags: () => (/* binding */ tags),
/* harmony export */   title: () => (/* binding */ title),
/* harmony export */   toolDetailsEditor: () => (/* binding */ toolDetailsEditor),
/* harmony export */   toolEditor: () => (/* binding */ toolEditor),
/* harmony export */   toolModeler: () => (/* binding */ toolModeler),
/* harmony export */   tryAgain: () => (/* binding */ tryAgain),
/* harmony export */   type: () => (/* binding */ type),
/* harmony export */   u16PixelType: () => (/* binding */ u16PixelType),
/* harmony export */   u32PixelType: () => (/* binding */ u32PixelType),
/* harmony export */   u8PixelType: () => (/* binding */ u8PixelType),
/* harmony export */   unionDimensions: () => (/* binding */ unionDimensions),
/* harmony export */   unknownPixelType: () => (/* binding */ unknownPixelType),
/* harmony export */   unsavedTitle: () => (/* binding */ unsavedTitle),
/* harmony export */   unsavedWarningExisting: () => (/* binding */ unsavedWarningExisting),
/* harmony export */   unsavedWarningNew: () => (/* binding */ unsavedWarningNew),
/* harmony export */   userStartDirection: () => (/* binding */ userStartDirection),
/* harmony export */   variables: () => (/* binding */ variables),
/* harmony export */   viewerModeMessage: () => (/* binding */ viewerModeMessage),
/* harmony export */   viewerModeTitle: () => (/* binding */ viewerModeTitle),
/* harmony export */   warning: () => (/* binding */ warning)
/* harmony export */ });
const ok = "Aceptar";
const cancel = "Cancelar";
const enterURL = "Introducir URL de servicio de imágenes";
const serviceURL = "URL de servicio";
const selectRaster = "Seleccionar ráster";
const failedToLoadLayer = "Fallo al cargar la capa";
const loadingLayer = "Cargando capa";
const selectFeature = "Seleccionar capa de entidad";
const enterFURL = "Introducir URL de servicio de entidades";
const addRaster = "Agregar variable de ráster";
const addScalar = "Agregar constante";
const raster = "Calculadora ráster";
const scalar = "Escalar";
const defaultModelName = "Plantilla de función ráster";
const general = "General";
const parameters = "Parámetros";
const variables = "Variables";
const name = "Nombre";
const description = "Descripción";
const parameter = "Parámetro";
const isPublic = "IsPublic";
const isDataset = "IsDataset";
const unknownPixelType = "Desconocido";
const outputPixelType = "Tipo de píxel de salida";
const u8PixelType = "8 bits sin signo";
const s8PixelType = "8 bits con signo";
const u16PixelType = "16 bits sin signo";
const s16PixelType = "16 bits con signo";
const u32PixelType = "32 bits sin signo";
const s32PixelType = "32 bits con signo";
const f32PixelType = "32 bits flotante";
const f64PixelType = "64 bits doble";
const properties = "Propiedades";
const multidimensionalRules = "Reglas multidimensionales";
const matchVariables = "Reasociar variables";
const unionDimensions = "Combinar dimensiones";
const rasterFunctionEditor = {
	invalidRFTMessage: "La plantilla de función ráster no es válida.",
	rfxArgsEditor: {
		outputRaster: "Ráster de salida",
		raster: "Calculadora ráster",
		unsupportedDataTypeWarning: "Los siguientes argumentos no se visualizan, ya que no se admiten actualmente.",
		unsupportedFunction: "Contiene funciones ráster actualmente no admitidas."
	},
	rfxRasterInput: {
		selectLayer: "Seleccionar capa",
		browseLayers: "Examinar capas",
		rfxVariable: "RasterFunctionVariable"
	},
	rfxBandCombinationEditor: {
		methodLabel: "Método",
		bandLabel: "Banda",
		combinationLabel: "Combinación"
	},
	rfxRemapGrid: {
		minimum: "Mínimo",
		maximum: "Máximo",
		output: "Salida",
		noData: "NoData",
		remapValuesLabel: "Nueva representación cartográfica de valores"
	},
	rfxNamedRasterEditor: {
		rasterVariables: "Variables de ráster",
		deleteSelectedVars: "Eliminar variables seleccionadas"
	},
	rfxClippingGeometry: {
		clippingLayer: "Capa de recorte",
		clippingRaster: "Ráster de clipping",
		clippingGeometry: "Geometría de recorte",
		customExtent: "Extensión personalizada",
		outputExtent: "Extensión de salida",
		currentExtent: "Extensión de mapa actual",
		drawLabel: "Dibujar"
	},
	rfxCustomExtent: {
		top: "Superior",
		right: "Derecha",
		bottom: "Inferior",
		left: "Izquierda"
	},
	rfxRasterArrayEditor: {
		moveUp: "Mover hacia arriba",
		moveDown: "Mover hacia abajo",
		remove: "Eliminar"
	},
	rfxStatisticsGrid: {
		stdDev: "Desviación estándar",
		min: "Mín.",
		max: "Máx.",
		mean: "Valor medio"
	},
	rfxWeightedSumTableEditor: {
		weightedSumTable: "Tabla de sumas ponderadas",
		id: "Id.",
		layer: "Capa",
		field: "Campo",
		weight: "Peso",
		value: "Valor",
		selectLayer: "Seleccionar capa"
	},
	rfxWeightedOverlayTableEditor: {
		weightedOverlayTable: "Tabla Superposición ponderada",
		id: "Id.",
		layer: "Capa",
		field: "Campo",
		influence: "Influencia",
		sumOfInfluence: "Suma de influencia",
		value: "Valor",
		remapTable: "Volver a representar la tabla",
		scale: "Escala",
		scales: "Escalas",
		selectRaster: "Seleccionar ráster"
	},
	rfxFeatureSelect: {
		addFeatureLayer: "Buscar una capa de entidades",
		addPointLayer: "Buscar una capa de puntos"
	},
	rfxFieldSelect: {
		value: "Valor",
		count: "Recuento"
	},
	rfxAttributeTable: {
		tableType: "Tipo de tabla",
		manual: "Manual",
		external: "Externo",
		minVal: "Valor mínimo",
		maxVal: "Valor Máximo",
		baseClassName: "Nombre base de clase",
		colorScheme: "Esquema de colores",
		defaultClassName: "Etiqueta_",
		generateTable: "Generar tabla",
		browseTable: "Tabla de explorador",
		value: "Valor",
		classname: "ClassName",
		color: "Color"
	},
	rfxFieldNumberSwitchable: {
		number: "Numérico",
		field: "Campo",
		string: "Cadena",
		linearUnit: "Unidad lineal"
	},
	rfxPropertySet: {
		name: "Nombre",
		value: "Valor"
	},
	rfxConversionGrid: {
		size: "Tamaño"
	},
	rfxTransposeBit: {
		bitPattern: "Patrón de bits",
		outputBit: "Bit de salida",
		inputBit: "Bit de entrada"
	},
	rfxSpatialReference: {
		placeHolder: "Refinar por palabra clave",
		coordinateSystem: "Sistema de coordenadas",
		gcs: "Sistema de coordenadas geográficas",
		pcs: "Sistema de coordenadas proyectadas",
		vcs: "Sistema de coordenadas vertical"
	}
};
const rfxLicenseInfo = "Esta plantilla de función ráster se puede usar para procesar sus imágenes mediante ArcGIS Image Server.";
const rasterFunctions = {
	rfx: {
		aCosHName: "Arcocoseno hiperbólico (ACosH)",
		aCosHSnip: "Calcula el coseno inverso hiperbólico de celdas en un ráster.",
		aCosHDesc: "La función calcula el coseno inverso hiperbólico de los píxeles de un ráster.",
		aCosName: "Arcocoseno (ACos)",
		aCosSnip: "Calcula el coseno inverso de los píxeles de un ráster.",
		aCosDesc: "Esta función ráster calcula el coseno inverso de las celdas de un ráster. En matemáticas, todas las funciones trigonométricas tienen un rango definido de valores de entrada válidos, llamado dominio. Los valores de salida de cada función también tienen un rango definido. Para esta herramienta, el dominio es [-1, 1] y el rango es [0, pi].",
		aSinHName: "Arcoseno hiperbólico (ASinH)",
		aSinHSnip: "Calcula el seno inverso hiperbólico de celdas en un ráster.",
		aSinHDesc: "La función calcula el arcoseno inverso hiperbólico de los píxeles de un ráster.",
		aSinName: "Arcoseno (ASin)",
		aSinSnip: "Calcula el seno inverso de celdas en un ráster.",
		aSinDesc: "La función calcula el seno inverso de los píxeles de un ráster.",
		aTan2Name: "Arcotangente (x/y) (ATan2)",
		aTan2Snip: "Calcula la tangente inversa (basada en x,y) de celdas en un ráster.",
		aTan2Desc: "La función calcula la tangente inversa (basada en x,y) de los píxeles de un ráster.",
		aTanHName: "Arcotangente hiperbólica (ATanH)",
		aTanHSnip: "Calcula la tangente inversa hiperbólica de celdas en un ráster.",
		aTanHDesc: "La función calcula la tangente inversa hiperbólica de los píxeles de un ráster.",
		aTanName: "Arcotangente (ATan)",
		aTanSnip: "Calcula la tangente inversa de celdas en un ráster.",
		aTanDesc: "La función calcula la tangente inversa de los píxeles de un ráster.",
		absName: "Valor absoluto",
		absSnip: "Calcula el valor absoluto de las celdas de un ráster.",
		absDesc: "La función Abs calcula el valor absoluto de los píxeles de un ráster.",
		reflectanceName: "Reflectancia aparente",
		reflectanceSnip: "Convierte las imágenes sin procesar en valores de Parte superior de la atmósfera teniendo en cuenta características del sensor, la posición del sol y el momento de captura.",
		reflectanceDesc: "Esta función ajusta los valores de número digital (DN) de brillo de la imagen para algunos de los sensores de satélites. Los ajustes se basan en la elevación del sol, la fecha de adquisición y las propiedades del sensor para configurar la ganancia y el sesgo de cada banda. Esta función se usa para ajustar los valores de reflectancia o brillo de algunas imágenes de satélite en función de la iluminación de la escena y de los ajustes de ganancia del sensor. Las imágenes se ajustan a una condición de iluminación teóricamente común, por lo que debería haber menos variación entre las escenas de diferentes fechas y de diferentes sensores. Esto puede ser útil para la clasificación de imágenes, el balance de color y la creación de mosaicos. Esta función solo se puede usar con imágenes concretas. Los sensores válidos son Landsat MSS, Landsat TM, Landsat ETM+, Landsat 8, IKONOS, QuickBird, GeoEye-1, RapidEye, DMCii, WorldView-1, WorldView-2, SPOT 6 y Pleiades.<div><br/>La función realiza dos correcciones. La primera se basa en la configuración de ganancia. Los valores de brillo originales se vuelven a crear a partir de los valores de la imagen al revertir las ecuaciones de ganancia. La segunda corrección tiene que ver con las diferencias en el ángulo del sol y el brillo. Los valores de brillo originales se ajustan a una condición de iluminación común mediante la normalización de las escenas capturadas en condiciones de iluminación variables. En general, mientras que el tipo de datos de imagen de salida coincide con el de entrada, los valores de salida son más bajos que los de entrada y están limitados al rango de datos válido.</div>",
		argStatisticsName: "ArgStatistics",
		argStatisticsSnip: "Calcula estadísticas arg, como Arg Max, Arg Min, Arg Medio y Duración.",
		argStatisticsDesc: "Esta función computa estadísticas arg. En la función ArgStatistics existen cuatro métodos: ArgMax, ArgMin, ArgMedian y Duration.",
		arithmeticName: "Aritmética",
		arithmeticSnip: "Realiza una operación aritmética entre dos rásteres o un ráster y un escalar.",
		arithmeticDesc: "La función aritmética realiza una operación aritmética entre dos rásteres o un ráster y un escalar y viceversa.",
		aspectSlopeName: "Orientación-pendiente",
		aspectSlopeSnip: "Crea un ráster que muestra al mismo tiempo la orientación (dirección) y la pendiente (inclinación) de una superficie continua, representado en un modelo digital de elevación.",
		aspectSlopeDesc: "La función Pendiente de orientación crea una capa ráster que visualiza simultáneamente la orientación y la pendiente de una superficie. La orientación identifica la dirección de la pendiente descendente de la tasa de cambio máxima en un valor desde cada píxel hacia sus vecinos. La orientación puede pensarse como la dirección de la pendiente. Los valores del ráster de salida serán la dirección de brújula de la orientación, representada por un tono (color). La pendiente representa la tasa de cambio de elevación para cada píxel de modelo digital de elevación (DEM). La pendiente representa la inclinación de la superficie y se simboliza en tres clases que se muestran mediante la saturación (viveza) del color.<div><br/>Los valores de píxel del ráster de orientación-pendiente de salida reflejan una combinación de la orientación y la pendiente. Los píxeles con valores inferiores a 20 se consideran planos y se muestran en gris. Los valores de orientación-pendiente de 21 y superiores se mostrarán con saturaciones variables, de la siguiente forma: 21 a 30: —saturación de pendiente baja, 31 a 40: —saturación de pendiente media, 41 y superiores: —saturación de pendiente alta</div>",
		aspectName: "Orientación",
		aspectSnip: "Muestra la dirección de un píxel, donde 0 es el norte y los ángulos aumentan en el sentido de las agujas del reloj hasta 360.",
		aspectDesc: "La función Orientación identifica la dirección de la pendiente descendente de la tasa de cambio máxima en un valor desde cada celda hacia sus vecinas. La orientación puede pensarse como la dirección de la pendiente. Los valores del ráster de salida serán la dirección de brújula de la orientación.<div><br/>La entrada para esta función es el ráster de entrada. La función Orientación se aplica frecuentemente a un modelo digital de elevación (DEM). De forma predeterminada, la orientación aparece como una imagen en escala de grises. Puede agregar la función Mapa de color para especificar una combinación de colores determinada o permitir a la persona que visualiza el mosaico modificar la simbología con su propio esquema de colores.</div>",
		tableName: "Tabla de atributos",
		tableSnip: "Utiliza una tabla para dar nombre y simbolizar los valores de un dataset. Las columnas de la tabla están delimitadas por comas: PixelValue, AttributeName, RedValue, GreenValue, BlueValue.",
		tableDesc: "La función Tabla de atributos le permite definir una tabla de atributos para simbolizar un dataset ráster o dataset de mosaico de banda única. <div><br/>Es útil cuando desea presentar imágenes que se han sometido a una clasificación del uso del suelo, por ejemplo, suelo del bosque, pantano, suelos de cultivo y urbano. Además, si su tabla contiene campos denominados rojo, verde y azul, los valores dentro de esos campos se utilizarán como un mapa de color al representar en pantalla la imagen.</div>",
		bandArithmeticName: "Aritmética de banda",
		bandArithmeticSnip: "Calcula índices usando fórmulas predefinidas o una expresión definida por el usuario.",
		bandArithmeticDesc: "La función Aritmética de banda realiza una operación aritmética en las bandas de un dataset ráster. Puede elegir algoritmos predefinidos o puede introducir su propia fórmula de línea única. Los operadores permitidos son -,+,/,* y unario -.",
		thresholdName: "Definición de umbral binario",
		thresholdSnip: "Organiza datos continuos en los valores de primer plano y de fondo minimizando la covarianza entre las dos clases.",
		thresholdDesc: "Cuando un dataset ráster tiene una distribución bimodal, esta función crea un nuevo ráster que divide los datos en dos clases distintas. Crea una clase de valor bajo, que se muestra con píxeles negros, y una clase de valor alto, que se muestra con píxeles blancos.",
		bitwiseAndName: "Bitwise And",
		bitwiseAndSnip: "Realiza una operación Bitwise And (Y bit a bit) sobre los valores binarios de dos rásteres de entrada.",
		bitwiseAndDesc: "Bitwise And realiza la operación Bitwise And (Y bit a bit) sobre los valores binarios de dos rásteres de entrada.",
		bitwiseLeftShiftName: "Bitwise Left Shift",
		bitwiseLeftShiftSnip: "Realiza una operación del método Bitwise Left Shift sobre los valores binarios de dos rásteres de entrada.",
		bitwiseLeftShiftDesc: "Bitwise Left Shift realiza una operación del método Bitwise Left Shift sobre los valores binarios de dos rásteres de entrada.",
		bitwiseNotName: "Bitwise Not",
		bitwiseNotSnip: "Realiza una operación Bitwise Not (complemento) sobre valores binarios de dos rásteres de entrada.",
		bitwiseNotDesc: "La función realiza una operación Bitwise Not (complemento) sobre el valor binario de un ráster de entrada.",
		bitwiseOrName: "Bitwise Or",
		bitwiseOrSnip: "Realiza una operación Bitwise Or sobre los valores binarios de dos rásteres de entrada.",
		bitwiseOrDesc: "La función realiza una operación Bitwise Or sobre los valores binarios de dos rásteres de entrada. ",
		bitwiseRightShiftName: "Bitwise Right Shift",
		bitwiseRightShiftSnip: "Realiza una operación Bitwise Right Shift sobre los valores binarios de dos rásteres de entrada.",
		bitwiseRightShiftDesc: "La función realiza una operación Bitwise Right Shift sobre los valores binarios de dos rásteres de entrada.",
		bitwiseXorName: "Bitwise XOr",
		bitwiseXorSnip: "Realiza una operación Bitwise eXclusive Or sobre los valores binarios de dos rásteres de entrada.",
		bitwiseXorDesc: "La función realiza una operación Bitwise eXclusive Or sobre los valores binarios de dos rásteres de entrada.",
		booleanAndName: "Booleana And",
		booleanAndSnip: "Realiza una operación Booleana And sobre los valores de celda de dos rásteres de entrada. Si los dos valores de entrada son verdaderos (distintos de cero), el valor de salida es 1. Si una o ambas entradas son falsas (cero), la salida es 0.",
		booleanAndDesc: "La función realiza una operación Boolean And sobre los valores de los píxeles de dos entradas. Si los dos valores de entrada son verdaderos (distintos de cero), el valor de salida es 1. Si uno o los dos valores de entrada son falsos (cero), el valor de salida es 0. ",
		booleanNotName: "Booleana Not",
		booleanNotSnip: "Realiza una operación booleana Not (complementario) sobre los valores de celda del ráster de entrada. Si los valores de entrada son verdaderos (distintos de cero), el valor de salida es 0. Si los valores de entrada son falsos (cero), la salida es 1.",
		booleanNotDesc: "La función realiza una operación Booleana Not (complementaria) sobre los valores de los píxeles del ráster de entrada. Si los valores de entrada son verdaderos (distintos de cero), el valor de salida es 0. Si los valores de entrada son falsos (cero), el valor de salida es 1.",
		booleanOrName: "Booleana Or",
		booleanOrSnip: "Realiza una operación Booleana Or sobre los valores de las celdas de dos rásteres de entrada. Si uno o ambos valores de entrada son verdaderos (distintos de cero), el valor de salida es 1. Si los dos valores de entrada son falsos (cero), la salida es 0.",
		booleanOrDesc: "La función realiza una operación Booleana Or sobre los valores de las celdas de dos rásteres de entrada. Si uno o los dos valores de entrada son verdaderos (distintos de cero), el valor de salida es 1. Si los dos valores de entrada son falsos (cero), el valor de salida es 0.",
		booleanXorName: "Booleana XOr",
		booleanXorSnip: "Realiza una operación booleana Or exclusiva sobre los valores de celda de dos rásteres de entrada. Si un valor de entrada es verdadero (distinto de cero) y el otro es falso (cero), la salida es 1. Si los dos valores de entrada son verdaderos o los dos son falsos, la salida es 0.",
		booleanXorDesc: "La función realiza una operación booleana Or exclusiva sobre los valores de celda de dos rásteres de entrada. Si un valor de entrada es verdadero (distinto de cero) y el otro valor es falso (cero), el valor de salida es 1. Si los dos valores de entrada son verdaderos, o si los dos son falsos, el valor de salida es 0.",
		bufferedRasterName: "Zona de influencia",
		bufferedRasterSnip: "Crea una zona de influencia alrededor de los últimos bloques de píxeles a los cuales se ha accedido.",
		bufferedRasterDesc: "La función En zona de influencia se utiliza para optimizar el rendimiento de cadenas de funciones complejas. Almacena en la memoria la salida de la parte de la cadena de funciones que la precede. <div><br/>Inserte esta función en el Editor de función donde desee almacenar la salida.</div>",
		rasterCalculatorName: "Calculadora",
		rasterCalculatorSnip: "Calcula un ráster a partir de una expresión matemática basada en rásteres.",
		rasterCalculatorDesc: "La función Calculadora permite crear y ejecutar expresiones e incorporarlas en cadenas de funciones.",
		cellStatisticsName: "Estadísticas de celdas",
		cellStatisticsSnip: "Calcula una estadística por celda de rásteres múltiples. Las estadísticas disponibles son mayoría, máximo, valor medio, mediana, mínimo, minoría, percentil, rango, desviación estándar, suma y variedad.",
		cellStatisticsDesc: "Esta función calcula las estadísticas de varios rásteres píxel por píxel. Las estadísticas disponibles son mayoría, máximo, valor medio, mediana, mínimo, minoría, rango, desviación estándar, suma y variedad.",
		classifyName: "Clasificar",
		classifySnip: "Asigna cada píxel a una clase. Incorpore datos secundarios, por ejemplo, una imagen segmentada.",
		classifyDesc: "Esta función ráster clasifica un dataset ráster a partir de un archivo de definición de clasificador de Esri (.ecd) y de entradas de dataset ráster. El archivo .ecd utilizado en la función Clasificar contiene toda la información necesaria para un dataset y un clasificador concretos, y se genera con herramientas de preparación de clasificación, por ejemplo, las herramientas Preparar clasificador de máquina de vectores de soporte o Preparar clasificador de árboles aleatorios.",
		clipName: "Recortar",
		clipSnip: "Establece la extensión de un ráster mediante coordenadas u otro dataset.",
		clipDesc: "Esta función recorta un ráster utilizando una forma rectangular según la extensión definida o recorta un ráster según la forma de una clase de entidad poligonal de entrada. La forma que define el recorte puede exceder la extensión del ráster o sobresalir de un área dentro del ráster.",
		colorspaceConversionName: "Conversión de modelo de color",
		colorspaceConversionSnip: "Convierte un ráster de RGB a HSV y viceversa.",
		colorspaceConversionDesc: "La función Conversión de modelo de color convierte el modelo de color de una imagen de tono, saturación y valor (HSV) a rojo, verde y azul (RGB) o viceversa.<div><br/>Esta función se puede usar en un dataset de mosaico.</div>",
		colormapToRGBName: "Mapa de color a RGB",
		colormapToRGBSnip: "Convierte un ráster de banda simple con un mapa de color en un ráster de banda triple (rojo, verde y azul).",
		colormapToRGBDesc: "Esta función convierte un ráster de banda simple con un mapa de color en un ráster de banda triple (rojo, verde y azul).<div><br/>Esta función resulta útil cuando se necesita crear un ráster de tres bandas a partir de un ráster de una sola banda que tiene un mapa de color asociado. Los valores del mapa de color se usan para crear las distintas bandas: roja, verde y azul. Esta función se puede usar en un dataset de mosaico.</div>",
		colormapName: "Mapa de color",
		colormapSnip: "Cambia los valores de píxel para mostrar los datos ráster como una escala de grises o como una imagen roja, verde, azul (RGB), basándose en un mapa de color o en una rampa de color.",
		colormapDesc: "La función Mapa de color es un tipo de renderizador de datos ráster. Transforma los valores de píxel para mostrar datos ráster como escala de grises o imagen de color RGB basada en un esquema de color o colores específicos de un archivo de mapa de color. Puede utilizar un mapa de color para representar datos analizados, por ejemplo, una imagen clasificada, o al mostrar un mapa topográfico (o una imagen digitalizada en color indexada).<div><br/>Los mapas de color contienen un conjunto de valores que se asocian con colores utilizados para visualizar un ráster de una única banda de forma consistente con los mismos colores. Cada valor de píxel está asociado a un color, que se define como un conjunto de valores RGB. Los mapas de color tienen la capacidad de admitir cualquier profundidad de bit, excepto el punto flotante. También pueden admitir los valores positivos y negativos, y pueden contener valores asignados de color que faltan. Al visualizar un dataset con un mapa de colores que contiene valores perdidos, los píxeles de dichos valores no se visualizan.</div>",
		complexName: "Complejo",
		complexSnip: "Extrae la magnitud de números complejos.",
		complexDesc: "Esta función calcula la magnitud de los valores complejos.<div><br/>Esta función se utiliza típicamente con las imágenes de radar que tienen un tipo de datos complejo. Se puede usar en un dataset de mosaico.</div>",
		compositeBandName: "Bandas compuestas",
		compositeBandSnip: "Combina varios datasets en un ráster multibanda.",
		compositeBandDesc: "La función Bandas compuestas permite combinar rásteres para crear una imagen multibanda.",
		conName: "Evaluación condicional",
		conSnip: "Realiza una operación If, Then, Else condicional. Cuando se utiliza un operador condicional, normalmente se necesitan dos o más funciones encadenadas, en la que la primera función indica los criterios y la segunda función es el operador condicional que usa los criterios y dicta cuáles deberían ser las salidas verdaderas y falsas.",
		conDesc: "La función Con define los píxeles del ráster de salida en función de una evaluación ifelse de cada píxel de entrada. Devuelve los valores de píxel del Ráster verdadero si la evaluación es True (1) o devuelve los valores de píxel del Ráster falso si la evaluación condicional es False (0). Este criterio viene determinado por la salida de una función matemática lógica, que será el Ráster de entrada.",
		constantName: "Constante",
		constantSnip: "Crea un ráster virtual con un valor de píxel único.",
		constantDesc: "Esta función crea un ráster virtual con un único valor de píxel que se puede utilizar en plantillas de función ráster y para procesar un dataset de mosaico.<div><br/>El valor de constante se utiliza para cada valor de píxel en el ráster.</div>",
		contourName: "Curvas de nivel",
		contourSnip: "Crea líneas de curvas de nivel.",
		contourDesc: "La función Curvas de nivel genera líneas de curvas de nivel uniendo puntos con la misma elevación a partir de un dataset de elevación ráster. Los contornos son isolíneas creadas como rásteres para la visualización. Las siguientes características clave hacen que esta función sea potente: las curvas de nivel se generan de forma rápida y dinámica en datasets muy grandes como, por ejemplo, la World Elevation; el intervalo de curvas de nivel se pueden suavizar para proporcionar una apariencia más agradable cartográficamente, manteniendo la precisión de las curvas de nivel; se proporciona control dinámico sobre el intervalo de las curvas de nivel; entre las opciones de salida se incluyen líneas de curvas de nivel, curvas de nivel de índice y curvas de nivel rellenas.<div><br/>La creación de una capa de curvas de nivel como un producto ráster resulta muy valioso para una amplia gama de aplicaciones, dado que las curvas de nivel se pueden superponer en un mapa y proporcionar información sobre el terreno sin ocultar los datos subyacentes. Resultan útiles en aplicaciones relacionadas con la ingeniería, la agricultura y la gestión de aguas.</div>",
		contrastBrightnessName: "Contraste y brillo",
		contrastBrightnessSnip: "Ajusta el contraste y brillo de un ráster.",
		contrastBrightnessDesc: "La función Brillo y contraste mejora la apariencia de los datos ráster al modificar el brillo y el contraste dentro de la imagen. El brillo aumenta la luminosidad total de la imagen, por ejemplo, aclarando los colores oscuros y blanqueando los claros, mientras que el contraste ajusta la diferencia entre los colores más claros y los más oscuros.<div><br/>Al utilizar esta función se alteran los valores de píxel. Por lo tanto, esta función se debe utilizar cuando desee mejorar la apariencia de los datos y no debe utilizarla si desea usar los datos como parte de un análisis que requerirá los valores de píxel originales. Esta función resulta útil a la hora de publicar los datos como un servicio de imágenes que se pueden utilizar en aplicaciones, sin poder alterar el contraste ni el brillo de las imágenes, o para garantizar que se muestren utilizando sus ajustes preferidos.</div>",
		convolutionName: "Convolución",
		convolutionSnip: "Aplica un filtro para mejorar la nitidez, desenfocar, detectar los bordes, suavizar, o bien un gradiente a través de un ráster.",
		convolutionDesc: "La función de convolución realiza el filtrado de los valores de píxel de una imagen, lo que se puede utilizar para aumentar su nitidez, difuminarla, detectar sus ejes u otros realces basados en el kernel. Los filtros se utilizan para mejorar la calidad de la imagen de ráster al eliminar datos falsos o mejorar las entidades de los datos. Estos filtros de convolución se aplican a un kernel móvil o superpuesto (ventana o vecindad), como 3 x 3. Los filtros de convolución actúan calculando el valor de píxel en función de la ponderación de sus vecinos.",
		corridorName: "Corredor",
		corridorSnip: "Calcula la suma de los costes acumulativos de dos rásteres acumulativos de entrada.",
		corridorDesc: "La función Corredor calcula la suma de los costes acumulativos de dos rásteres de costes acumulativos de entrada. Aunque para la entrada se pueden utilizar dos rásteres cualquiera, para obtener un resultado significativo deben ser rásteres de coste acumulativo de salida sin alterar. El orden de las dos entradas es irrelevante.",
		cosHName: "Coseno hiperbólico (CosH)",
		cosHSnip: "Calcula el coseno hiperbólico de celdas en un ráster.",
		cosHDesc: "La función calcula el coseno hiperbólico de los píxeles de un ráster.",
		cosName: "Coseno (Cos)",
		cosSnip: "Calcula el coseno de una celda de un ráster.",
		cosDesc: "La función calcula el coseno de los píxeles de un ráster.",
		costAllocationName: "Asignación de costes",
		costAllocationSnip: "Calcula, para cada celda, el origen de menor coste en función del menor coste acumulativo por una superficie de coste.",
		costAllocationDesc: "La función Asignación de costes calcula, para cada celda, el origen de menor coste en función del menor coste acumulativo por una superficie de coste.",
		costBackLinkName: "Vínculo de menor coste",
		costBackLinkSnip: "Define el vecino que es la celda siguiente en la ruta de menor coste acumulativo al origen de menor coste.",
		costBackLinkDesc: "La función Vínculo de menor coste define el vecino que es la celda siguiente en la ruta de menor coste acumulativo al origen de menor coste.<div><br/>El ráster de vínculo de menor coste contiene valores de cero a ocho que definen la dirección o identifican la siguiente celda vecina (la celda que sigue) a lo largo de la ruta con menor coste acumulativo desde una celda para llegar al origen de menor coste. Si la ruta es pasar al elemento próximo derecho, se le asignará a la celda el valor 1, 2 para la celda diagonal derecha inferior y continuando en el sentido de las agujas del reloj. El valor 0 se reserva para las celdas de origen.</div>",
		costDistanceName: "Coste de distancia",
		costDistanceSnip: "Calcula el menor coste de distancia acumulativo para cada celda desde o hasta el origen de menor coste por una superficie de coste.",
		costDistanceDesc: "La función Coste de distancia calcula el menor coste-distancia acumulativo para cada celda desde o hasta el origen de menor coste por una superficie de coste.",
		costPathName: "Ruta de coste",
		costPathSnip: "Calcula la ruta de menor coste desde un origen a su destino.",
		costPathDesc: "La función global Ruta de coste calcula la ruta de menor coste desde un origen a un destino.<div><br/>Esta función produce un ráster de salida que registra la ruta o las rutas de menor coste desde las ubicaciones seleccionadas hasta la celda de origen más cercana definida dentro de la superficie de coste acumulativo, en términos de coste-distancia.</div>",
		curvatureName: "Curvatura",
		curvatureSnip: "Calcula la curvatura de una superficie de ráster e incluye, opcionalmente, la curvatura del perfil y del plano.",
		curvatureDesc: "La función de curvatura muestra la forma o la curvatura de la pendiente. Una parte de la superficie puede ser cóncava o convexa; eso se puede comprobar consultando el valor de la curvatura. La curvatura se obtiene calculando la derivada segunda de la superficie.<div><br/>La salida de la función de curvatura se puede utilizar para describir las características físicas de una cuenca de drenaje para intentar entender los procesos de erosión y escorrentía. El valor de la curvatura se puede utilizar para buscar patrones de erosión del suelo, así como la distribución del agua en la tierra. La curvatura del perfil afecta la aceleración y desaceleración del flujo y, por lo tanto, influye en la erosión y la sedimentación. La curvatura de la plataforma influye en la convergencia y divergencia del flujo.</div>",
		divideName: "División",
		divideSnip: "Divide los valores de dos rásteres celda por celda.",
		divideDesc: "La función Dividir divide los valores de dos rásteres píxel por píxel.",
		elevationVoidFillName: "Relleno de vacío de elevación",
		elevationVoidFillSnip: "Crea píxeles donde hay agujeros dentro de los datos de elevación.",
		elevationVoidFillDesc: "La función de relleno de vacío de elevación se utiliza para crear píxeles donde existen agujeros en la elevación.<div><br/>Los vacíos se producen cuando no hay puntos capturados dentro del área representada por un píxel en el ráster resultante. Los vacíos a menudo se ocasionan por masas de agua, por la selección de tipos de clase o por exclusión. El llenado de vacío se usa más comúnmente cuando se genera una superficie de tierra.</div>",
		equalToName: "Igual a",
		equalToSnip: "Realiza una operación relacional de igualdad sobre dos entradas en una base de celda a celda. Devuelve un 1 para las celdas donde el primer ráster es igual al segundo ráster y un 0 para las celdas donde no lo es.",
		equalToDesc: "La función realiza una operación Igual a en dos rásteres píxel por píxel. Devuelve un valor de 1 para los píxeles en los que el primer ráster es igual al segundo ráster, y un valor de 0 para los píxeles en los que los rásteres no son iguales.",
		eucAllocationName: "Asignación euclidiana",
		eucAllocationSnip: "Calcula, para cada celda, el origen más cercano según la distancia euclidiana.",
		eucAllocationDesc: "La función Asignación euclidiana calcula, para cada celda, el origen más cercano según la distancia euclidiana.",
		eucDirectionName: "Dirección euclidiana",
		eucDirectionSnip: "Calcula, para cada celda, la dirección en grados hacia el origen más cercano.",
		eucDirectionDesc: "La función Dirección euclidiana calcula, para cada celda, la dirección en grados hacia el origen más cercano. <div><br/>La dirección se calcula desde el centro de cada celda hasta el centro de la celda de origen que está más cerca. El rango de valores es de 0 grados hasta 360 grados, con el 0 reservado para las celdas de origen. Hacia el este (derecha) es 90 y los valores aumentan en el sentido de las agujas del reloj (180 es sur, 270 es oeste y 360 es norte).</div>",
		eucDistanceName: "Distancia euclidiana",
		eucDistanceSnip: "Calcula, para cada celda, la distancia euclidiana hasta el origen más cercano.",
		eucDistanceDesc: "La función Distancia euclidiana calcula, para cada celda, la distancia euclidiana hasta el origen más cercano.",
		exp10Name: "Exponencial en base 10 (Exp10)",
		exp10Snip: "Calcula el exponencial en base 10 de las celdas de un ráster.",
		exp10Desc: "La función Exp 10 calcula el exponencial en base 10 de los píxeles de un ráster.",
		exp2Name: "Exponencial en base 2 (Exp2)",
		exp2Snip: "Calcula el exponencial en base 2 de las celdas de un ráster.",
		exp2Desc: "Esta función calcula el exponencial en base 2 de los píxeles de un ráster.",
		expName: "Exponencial en base e (Exp)",
		expSnip: "Calcula el exponencial en base e de las celdas de un ráster.",
		expDesc: "Esta función calcula el exponencial en base e de los píxeles de un ráster.",
		extractBandName: "Extraer bandas",
		extractBandSnip: "Especifica las bandas con las que se va a trabajar al usar datasets multibanda.",
		extractBandDesc: " La función Extraer bandas permite extraer una o varias bandas de un dataset ráster multibanda o reordenar sus bandas.<div><br/>Puede utilizar la función Extraer bandas antes de otras funciones, como Aritmética, para controlar las bandas que se utilizan como entrada en la siguiente función.</div>",
		fillName: "Relleno",
		fillSnip: "Rellena hendiduras en una superficie de ráster para quitar pequeñas imperfecciones en los datos.",
		fillDesc: "La función global Relleno localiza y rellena los sumideros y picos de un ráster de superficie de elevación para eliminar las pequeñas imperfecciones de los datos. La función rellena un proceso iterativo hasta que todos los sumideros quedan rellenos dentro del Límite Z especificado.<div><br/>Cuando se crea una superficie de elevación con las herramientas de Representación cartográfica de ortofotos o con otros medios, a menudo se producen errores pequeños, pero significativos, en forma de sumideros y picos en los datos. En fotogrametría, los sumideros y picos a menudo se conocen como agujeros y picos. Dado que los datos de superficie a menudo se usan en el modelado, como el modelado hidrológico, es importante corregir estos errores de sumidero y pico de forma consistente con los datos circundantes.</div>",
		floatName: "Flotante",
		floatSnip: "Convierte el valor de cada celda de un ráster en una representación de punto flotante.",
		floatDesc: "La función Flotante convierte el valor de píxel de un ráster en una representación con punto flotante.",
		flowAccumulationName: "Acumulación de flujo",
		flowAccumulationSnip: "Crea un ráster de flujo acumulado en cada celda. Opcionalmente, puede aplicar un factor de peso.",
		flowAccumulationDesc: "La función global Acumulación de flujo crea un ráster del flujo acumulado para cada píxel, determinada al acumular el peso de todos los píxeles que fluyen hacia cada píxel descendente. Si no se indica un ráster de peso, se aplica un peso de 1 a cada píxel, y el valor de los píxeles del ráster de salida es el número de píxeles que fluyen en cada píxel.<div><br/>Los píxeles de salida con una acumulación de flujo alta son áreas de flujo concentrado y se pueden utilizar para identificar canales de curso de agua. Los píxeles de salida con una acumulación de flujo cero son las alturas topográficas locales y se pueden utilizar para identificar crestas.</div>",
		flowDirectionName: "Dirección de flujo",
		flowDirectionSnip: "Crea un ráster de dirección de flujo desde cada celda hasta su vecina con la pendiente descendente más empinada.",
		flowDirectionDesc: "Una de las claves para derivar características hidrológicas de una superficie es la capacidad de determinar la dirección de flujo de cada píxel del ráster. La función ráster Dirección de flujo toma una superficie como entrada y crea un ráster de dirección de flujo desde cada píxel hasta su vecino con la pendiente descendente más empinada. La función Dirección de flujo admite tres métodos de modelado de flujo: D8 (ocho direcciones), Dirección del flujo múltiple (MFD) y D-Infinity (DINF). ",
		flowDistanceName: "Distancia de flujo",
		flowDistanceSnip: "Computa, para cada celda, la distancia horizontal o vertical mínima en una pendiente descendente hasta varias celdas de un curso de agua o un río hacia el que fluyen.",
		flowDistanceDesc: "Para cada píxel, la función calcula la distancia horizontal o vertical mínima en pendiente descendente al píxel o los píxeles del río o curso de agua en el que fluyen. Si se proporciona un ráster de dirección de flujo opcional, las direcciones de pendiente descendente se limitarán a aquellas definidas por el ráster de dirección del flujo de entrada. La salida es un ráster de distancia de flujo.",
		focalName: "Estadísticas focalizadas",
		focalSnip: "Calcula las estadísticas focales para cada píxel de una imagen basándose en una vecindad focal definida.",
		focalDesc: "La función Estadísticas focalizadas calcula las estadísticas focales para cada píxel de una imagen basándose en una vecindad focal definida.",
		geometricName: "Geométrica",
		geometricSnip: "Aumenta la exactitud de posición de un dataset teniendo en cuenta la elevación.",
		geometricDesc: "La función Geométrica genera una imagen ortorrectificada basada en una definición de sensor y un modelo de terreno. Aumenta la exactitud de posición de un dataset teniendo en cuenta la elevación.",
		grayscaleName: "Escala de grises",
		grayscaleSnip: "Convierte una imagen multibanda en una imagen en escala de grises de banda única.",
		grayscaleDesc: "Esta función convierte una imagen multibanda en una imagen en escala de grises de banda única.<div><br/>Esta función aplica los pesos especificados a cada una de las bandas de entrada y normaliza la imagen de salida. Los pesos se aplican a menudo porque algunas bandas tienen una importancia variable en función de la aplicación. Por ejemplo, la banda azul a menudo contiene más ruido que otras bandas.</div>",
		greaterThanEqualName: "Mayor o igual que",
		greaterThanEqualSnip: "Realiza una operación relacional mayor que sobre dos entradas en una base de celda a celda. Devuelve 1 para las celdas donde el primer ráster es mayor o igual que el segundo ráster y 0 si no lo es.",
		greaterThanEqualDesc: "La función realiza una operación relacional Mayor o igual que sobre dos entradas píxel por píxel. Devuelve un valor de 1 para los píxeles en los que el primer ráster es mayor o igual que el segundo ráster, y un valor de 0 para los píxeles en los que el primer ráster no es mayor ni igual que el segundo ráster.",
		greaterThanName: "Mayor que",
		greaterThanSnip: "Realiza una operación relacional mayor que sobre dos entradas en una base de celda a celda. Devuelve 1 para las celdas donde el primer ráster es mayor que el segundo ráster y 0 para las celdas si no lo es.",
		greaterThanDesc: "La función realiza una operación relacional Mayor que sobre dos entradas píxel por píxel. Devuelve un valor de 1 para los píxeles en los que el primer ráster es mayor que el segundo ráster, y un valor de 0 para los píxeles en los que el primer ráster no es mayor que el segundo ráster.",
		heatIndexName: "Índice de calor",
		heatIndexSnip: "Combina la temperatura ambiente del aire y la humedad relativa para devolver la sensación térmica.",
		heatIndexDesc: "Esta función calcula la sensación térmica a partir de la temperatura ambiente y la humedad relativa. La temperatura aparente se suele describir como la percepción de temperatura del cuerpo humano.<div><br/>Este índice puede resultar útil para calcular los peligros relacionados con problemas médicos como calambres musculares, deshidratación, agotamiento por calor o insolaciones graves en días calurosos y húmedos. Cuando la humedad relativa es alta, aumenta la dificultad de que se evapore el sudor del cuerpo, con lo que las personas pierden la capacidad natural de reducir su temperatura. Los avisos o advertencias de los mapas de calor suelen ser el resultado de reclasificar los resultados del índice de calor en clases; cuanto mayor es el valor del índice, más probable es que se convierta en una advertencia en lugar de un simple aviso.</div>",
		hillshadeName: "Sombreado",
		hillshadeSnip: "Crea una representación 3D de la superficie que tiene en cuenta la posición relativa del sol para sombrear la imagen.",
		hillshadeDesc: "La función Sombreado produce una representación 3D en escala de grises de la superficie del terreno, que tiene en cuenta la posición relativa del sol para sombrear la imagen. <div><br/>El sombreado es una técnica que permite visualizar terreno en función de una fuente de luz y de la pendiente y la orientación de la superficie de elevación. Es un método cualitativo para visualizar la topografía y no proporciona valores de elevación absolutos. </div>",
		intName: "Entero",
		intSnip: "Convierte cada valor de celda de un ráster a un entero mediante truncamiento.",
		intDesc: "La función Int convierte cada valor de píxel de un ráster a un entero mediante truncamiento.",
		interpolateIrregularDataName: "Interpolar datos irregulares",
		interpolateIrregularDataSnip: "Interpola a partir de nubes de puntos o cuadrículas irregulares.",
		interpolateIrregularDataDesc: "Algunos datasets de netCDF o HDF almacenan su geolocalización como matrices de píxeles o datos de puntos con espacios irregulares. Al agregar estos datasets a un dataset de mosaico, la función de interpolar datos irregulares toma los datos cuadriculados irregulares y los remuestrea para cada píxel tenga un tamaño uniforme y sea cuadrado.<div><br/>Al agregar variables de netCDF o HDF a un dataset de mosaico, comprobará automáticamente si los datos están dispuestos en la matriz de forma regular. Si no es así, se puede utilizar la función de interpolar datos irregulares para convertir los datos irregulares en un ráster cuadriculado regular. Puede cambiar el método de interpolación y el tamaño de celda utilizados en la función de interpolar ráster de datos irregulares. Para los datos ráster con espacios regulares, no se aplicará la interpolación y los datos se leerán tal cual.</div>",
		isNullName: "Es nulo",
		isNullSnip: "Determina qué valores de los rásteres de entrada son NoData a través de cada celda individual. Devuelve un valor de 1 si los valores de entrada es NoData y 0 para las celdas que no lo son.",
		isNullDesc: "La función Es nulo determina qué valores del ráster de entrada son NoData píxel por píxel. Devuelve un valor de 1 si el valor de entrada es NoData, y un valor de 0 para los píxeles que no sean NoData.",
		kernelDensityName: "Densidad kernel",
		kernelDensitySnip: "Calcula una magnitud por unidad de área a partir de entidades de punto o polilínea mediante una función kernel para adaptar una superficie suavemente estrechada a cada punto o polilínea.",
		kernelDensityDesc: "Esta función calcula una magnitud por unidad de área a partir de entidades de punto o polilínea mediante una función kernel para adaptar una superficie suavemente estrechada a cada punto o polilínea.",
		keyMetadataName: "Metadatos clave",
		keyMetadataSnip: "Invalida o inserta metadatos clave de un ráster en una cadena de función.",
		keyMetadataDesc: "Esta función le permite insertar o invalidar metadatos clave de un ráster.<div><br/>La información de los metadatos clave se usa para ayudar a la aplicación con parte del procesamiento y la representación en pantalla, incluyendo proporcionar información útil como, por ejemplo, el nombre del sensor, los nombres de bandas o la cobertura de la nube asociada a las imágenes.</div>",
		shortestPathName: "Ruta de menor coste",
		shortestPathSnip: "Realiza un análisis de coste-distancia con las entradas de origen y destino, que se utilizan a continuación para determinar la ruta de menor coste desde un origen a un destino.",
		shortestPathDesc: "La función Ruta de menor coste calcula la ruta de menor coste desde un origen a un destino. La distancia de menor coste acumulativo se calcula para cada píxel hasta la fuente más cercana sobre una superficie de coste. Esto genera un ráster de salida que registra la ruta o las rutas de menor coste desde las ubicaciones seleccionadas hasta los píxeles de origen más cercanos definidos dentro de la superficie de coste acumulativo en términos de coste de distancia.<div><br/>A cada ruta de menor coste se le asigna un valor cuando se encuentra en el proceso de escaneado. El píxel final del Ráster de origen de una ruta de coste recibe un valor igual a 1. La primera ruta recibe un valor igual a 3, el segundo igual a 4 y así sucesivamente. Cuando se fusionan varias rutas y siguen la distancia restante hasta un origen en la misma ruta, al segmento en el que las dos rutas viajan juntas se le asigna el valor 2. A la parte fusionada de la ruta no se le puede asignar el valor de una de las rutas, ya que la parte fusionada pertenece a ambas rutas.</div>",
		lessThanEqualName: "Menor o igual que",
		lessThanEqualSnip: "Realiza una operación relacional menor o igual que sobre dos entradas en una base de celda a celda. Devuelve 1 para las celdas donde el primer ráster es menor o igual que el segundo ráster y 0 donde no lo es.",
		lessThanEqualDesc: "La función realiza una operación relacional Menor o igual que sobre dos entradas píxel por píxel. Devuelve un valor de 1 para los píxeles en los que el primer ráster es menor o igual que el segundo ráster, y un valor de 0 si no es menor ni igual que el segundo ráster.",
		lessThanName: "Menor que",
		lessThanSnip: "Realiza una operación relacional menor que sobre dos entradas en una base de celda a celda. Devuelve 1 para las celdas donde el primer ráster es menor que el segundo ráster y 0 si no lo es.",
		lessThanDesc: "La función realiza una operación relacional Menor que sobre dos entradas píxel por píxel. Devuelve un valor de 1 para los píxeles en los que el primer ráster es menor que el segundo ráster, y un valor de 0 si no es menor que el segundo ráster.",
		lnName: "Logaritmo neperiano (Ln)",
		lnSnip: "Calcula el logaritmo natural (base e) de las celdas en un ráster.",
		lnDesc: "La función Ln calcula el logaritmo natural (base e) de cada píxel de un ráster.",
		log10Name: "Logaritmo en base 10 (Log10)",
		log10Snip: "Calcula el logaritmo base 10 de las celdas en un ráster.",
		log10Desc: "La función Log10 calcula el logaritmo en base 10 de cada píxel de un ráster.",
		log2Name: "Logaritmo en base 2 (Log2)",
		log2Snip: "Calcula el logaritmo base 2 de las celdas en un ráster.",
		log2Desc: "La función Log2 calcula el logaritmo en base 2 de cada píxel de un ráster.",
		lookupName: "Búsqueda",
		lookupSnip: "Crea un nuevo ráster a partir de la búsqueda de valores que se encuentran en otro campo en la tabla del ráster de entrada.",
		lookupDesc: "La función crea un nuevo ráster a partir de la búsqueda de valores que se encuentran en otro campo en la tabla del ráster de entrada.",
		mlClassifyName: "Clasificar ML",
		mlClassifySnip: "Clasifica las imágenes aplicando un planteamiento de píxel a píxel. Se asignan píxeles mixtos a la entidad con el porcentaje más alto de ese píxel.",
		mlClassifyDesc: "La función Clasificar ML le permite realizar una clasificación supervisada utilizando el algoritmo de clasificación de máxima verosimilitud sobre un dataset ráster o un dataset de mosaico. Esta función requiere un archivo de firma de clasificación.",
		maskName: "Máscara",
		maskSnip: "Establece los valores que no quiere mostrar.",
		maskDesc: "Esta función ráster define valores que no deseará mostrar en su ráster. Con la función Máscara, especificará uno o varios valores NoData o un rango de valores de píxel válido. ",
		minusName: "Resta",
		minusSnip: "Resta el valor del segundo ráster de entrada al valor del primer ráster de entrada celda por celda.",
		minusDesc: "La función Menos resta el valor del segundo ráster de entrada del valor del primer ráster de entrada píxel por píxel.",
		modName: "Módulo",
		modSnip: "Determina el resto (módulo) del primer ráster cuando se divide por el segundo ráster celda por celda.",
		modDesc: "La función Mod determina el resto (módulo) del primer ráster cuando se divide por el segundo ráster píxel por píxel. El orden de las entradas es importante y afecta al resultado de salida.",
		mosaicRastersName: "Rásteres de mosaico",
		mosaicRastersSnip: "Une un conjunto de datasets ráster para crear un dataset.",
		mosaicRastersDesc: "La función Rásteres de mosaico crea una imagen de mosaico a partir de varias imágenes. Si hay superposición entre las imágenes, hay varios métodos entre los que se puede elegir para determinar qué imágenes se muestran.",
		ndviColorizedName: "NDVI a color",
		ndviColorizedSnip: "Crea un dataset multibanda que representa la salud de la vegetación, en función de la diferencia entre las bandas roja e infrarroja cercana.",
		ndviColorizedDesc: "La función NDVI a color aplica la función NVDI a la imagen de entrada y, a continuación, utiliza un mapa de color o una rampa de color para mostrar el resultado.",
		ndviName: "NDVI",
		ndviSnip: "Calcula un Índice de Vegetación de Diferencia Normalizada (NDVI).",
		ndviDesc: "La función NDVI crea un dataset de banda única que representa la salud de la vegetación, en función de la diferencia entre las bandas roja e infrarroja cercana.<div><br/>El NDVI es un índice normalizado que le permite generar una imagen que muestra el verdor, también conocida como biomasa relativa. Este índice aprovecha el contraste de características entre dos bandas de un dataset ráster multiespectral: la absorción de pigmento de clorofila en la banda roja y la alta reflectividad del material de las plantas en la banda infrarroja cercana (NIR). Los valores NDVI extremadamente bajos o negativos representan a las áreas sin ninguna vegetación, tales como nubes, agua o nieve. Los valores muy bajos representan a áreas con muy poca vegetación o sin ninguna vegetación, tales como hormigón, piedra o suelo desnudo. Los valores moderados representan áreas de matorrales y praderas. Los valores altos representan a las zonas forestales y la vegetación densa.</div>",
		negateName: "Cambio de signo",
		negateSnip: "Cambia el signo (multiplica por -1) de los valores de celda del ráster de entrada celda por celda.",
		negateDesc: "La función Cambio de Signo cambia el signo (multiplica por -1) de los valores de píxel del ráster de entrada en un píxel. ",
		nibbleName: "Nibble",
		nibbleSnip: "Reemplaza las celdas de un ráster que corresponden a una máscara con los valores de los vecinos más cercanos.",
		nibbleDesc: "La función global Nibble permite asignar a las áreas seleccionadas de un ráster el valor de su vecino más cercano. Resulta útil para la edición de áreas de un ráster en las que los datos pueden ser erróneos.",
		notEqualName: "No igual",
		notEqualSnip: "Realiza una operación relacional de desigualdad sobre dos entradas a través de cada celda individual. Devuelve 1 para las celdas donde el primer ráster no es igual al segundo ráster y 0 donde es igual.",
		notEqualDesc: "La función realiza una operación relacional No igual que sobre dos entradas píxel por píxel. Devuelve un valor de 1 para los píxeles en los que el primer ráster no es igual al segundo ráster, y un valor de 0 para los píxeles donde es igual al segundo ráster.",
		pansharpeningName: "Refinado pancromático",
		pansharpeningSnip: "Mejora artificialmente la resolución espacial de una imagen multibanda mediante su fusión con una imagen pancromática de mayor resolución.",
		pansharpeningDesc: "La función Refinado pancromático utiliza una imagen pancromática de mayor resolución o banda de ráster para fusionarla con un dataset ráster multibanda de menor resolución y así aumentar la resolución espacial de la imagen multibanda.<div><br/>La finalidad del refinado pancromático es crear una imagen visual de mayor calidad. Dado que las técnicas modifican las características radiométricas y espectrales de las imágenes multibanda, las imágenes con refinado pancromático se deben usar con cautela para fines de teledetección analítica.</div>",
		pathAllocationName: "Asignación de la distancia de ruta",
		pathAllocationSnip: "Calcula el origen de menor coste para cada celda en función del menor coste acumulativo por una superficie de coste y tiene en cuenta la distancia de la superficie y los factores de coste horizontal y vertical.",
		pathAllocationDesc: "La función Asignación de distancia de ruta calcula la fuente más cercana a cada celda en función del coste acumulativo inferior sobre una superficie de coste a la vez que se tiene en cuenta la distancia de la superficie y los factores de coste vertical y horizontal.",
		pathBackLinkName: "Vínculo de menor distancia de ruta",
		pathBackLinkSnip: "Define el vecino que es la celda siguiente en la ruta de menor coste acumulativo hasta el origen de menor coste y tiene en cuenta la distancia de la superficie y los factores de coste horizontal y vertical.",
		pathBackLinkDesc: "La función Vínculo de menor distancia de ruta identifica la direccionalidad del vecino que es la celda siguiente en la ruta de coste acumulativo inferior a la fuente más cercana, a la vez que se tiene en cuenta la distancia de la superficie y los factores de coste horizontal y vertical.",
		pathDistanceName: "Distancia de ruta",
		pathDistanceSnip: "Calcula, para cada celda, el menor coste de distancia acumulativo desde o hasta el origen de menor coste y tiene en cuenta la distancia de la superficie y los factores de coste horizontal y vertical.",
		pathDistanceDesc: "La función Distancia de ruta calcula para cada celda la distancia de coste acumulativo inferior a la fuente más cercana a la vez que se tiene en cuenta la distancia de la superficie y los factores de coste vertical y horizontal.",
		plusName: "Plus",
		plusSnip: "Agrega (suma) los valores de dos rásteres celda por celda.",
		plusDesc: "La función Suma agrega (suma) los valores de dos rásteres píxel por píxel.",
		powerName: "Potencia",
		powerSnip: "Eleva los valores de celda de un ráster a la potencia de los valores encontrados en otro ráster.",
		powerDesc: "La función Potencia eleva los valores de píxel de un ráster a la potencia de los valores encontrados en otro ráster.",
		radarCalibrationName: "Calibración de radar",
		radarCalibrationSnip: "Convierte RADARSAT-2 a retrodispersión.",
		radarCalibrationDesc: "Esta función se utiliza para calibrar imágenes RADARSAT-2 en un dataset de mosaico o como producto ráster. La calibración se realiza en las imágenes de radar de manera que los valores de píxel sean una representación verdadera de la retrodispersión del radar.",
		rasterInfoName: "RasterInfo",
		rasterInfoSnip: "Modifica las propiedades del ráster, como la profundidad de bit, el valor NoData, el tamaño de celda, etc.",
		rasterInfoDesc: "La Información de ráster abre un cuadro de diálogo con propiedades del dataset ráster, como el número de columnas y filas, el número de bandas, el tipo de píxel, la extensión y la referencia espacial. Puede editar estas propiedades al seleccionar un dataset ráster para utilizar como plantilla. ",
		rasterizeAttributesName: "Rasterizar atributos",
		rasterizeAttributesSnip: "Enriquece un ráster mediante bandas adicionales derivadas de valores de atributos especificados, desde una tabla externa o un servicio de entidades.",
		rasterizeAttributesDesc: "La función Rasterizar atributos enriquece un ráster agregando bandas derivadas de valores de atributos especificados, desde una tabla externa o un servicio de entidades. También puede especificar un ráster de zona y el atributo de Id. de zona asociado para habilitar consultas regionales.",
		rasterizeFeatureClassName: "Rasterizar entidades",
		rasterizeFeatureClassSnip: "Convierte entidades en un ráster.",
		rasterizeFeatureClassDesc: "Esta función convierte datos de una clase de entidad poligonal, de polilínea y de punto en una capa ráster.<div><br/>A las entidades se les asignan valores de píxel según el OBJECTID de la entidad (predeterminado). Opcionalmente, los valores de píxel pueden estar basados en un campo de valor definido por el usuario en la tabla de atributos de la entidad de entrada.</div>",
		recastName: "Reformular",
		recastSnip: "Modifica los parámetros de una cadena de funciones de un dataset de mosaico o un servicio de imágenes. Se utiliza con frecuencia con los datasets LAS para evitar tener que crear un dataset de mosaico separado para distintas representaciones del terreno.",
		recastDesc: "La función Reformular se utiliza para modificar dinámicamente el parámetro de función empleado en un dataset de mosaico o un servicio de imágenes sin mantener físicamente los cambios.",
		regionGroupName: "Grupo de regiones",
		regionGroupSnip: "Para cada celda en la salida, se registra la identidad de la región conectada a la que pertenece esa celda. Se asigna un número único a cada región.",
		regionGroupDesc: "La función Grupo de regiones registra, para cada celda de la salida, la identidad de la región conectada a la que pertenece la celda. Se asigna un número único a cada región.<div><br/>La primera región escaneada recibe el valor uno, la segunda dos, y así sucesivamente, hasta que se asigna un valor a todas las regiones. El escaneo se desplaza de izquierda a derecha, de arriba hacia abajo. Los valores que se asignen a las zonas de salida dependerán del momento en que se encuentran en el proceso de escaneo.</div>",
		regionGrowName: "Crecimiento de región",
		regionGrowSnip: "Hace crecer las regiones a partir de puntos semilla.",
		regionGrowDesc: "La función Crecimiento de región agrupa píxeles vecinos en grupos en función del radio especificado respecto desde el punto de semilla. Se asigna al grupo de píxeles u objetos un valor de relleno especificado.",
		remapName: "Nueva representación cartográfica",
		remapSnip: "Cambia los valores de píxel asignando nuevos valores a rangos de valores de píxel o usando una tabla externa.",
		remapDesc: "La función de nueva representación cartográfica le permite cambiar o reclasificar los valores de píxel de los datos ráster. Se puede hacer especificando un rango de valores de píxel para representar cartográficamente un valor de píxel de salida, o bien usando una tabla para representar cartográficamente los valores de píxeles para generar el valor de píxel.",
		reprojectName: "Volver a proyectar",
		reprojectSnip: "Modifica la proyección de un dataset ráster, dataset de mosaico o elemento de ráster en un dataset de mosaico. También pueden remuestrear los datos para un nuevo tamaño de celda y definir un origen.",
		reprojectDesc: "La función Reproyectar modifica la proyección de un dataset ráster, dataset de mosaico o elemento de ráster en un dataset de mosaico. También pueden remuestrear los datos para un nuevo tamaño de celda y definir un origen.<div><br/>La función Reproyectar se puede usar al crear una caché a partir de un dataset ráster o de mosaico que no se encuentra en la proyección requerida. Por ejemplo, al crear un servicio de imágenes en caché que se puede integrar con aplicaciones con otros servicios en caché, es importante que todos se encuentren en la misma proyección. Con frecuencia se trata de una proyección Web Mercator. Dado que no es posible reproyectar el dataset de mosaico, es posible hacer una de dos cosas: crear un dataset de mosaico al que se hace referencia desde su dataset de mosaico en la proyección necesaria o agregar la función Reproyectar a la cadena de funciones del dataset de mosaico. Otro ejemplo usa esta función con el elemento de ráster de un dataset de mosaico. Al utilizar la función Ráster en caché, quizá desee insertar la función Reproyectar de forma que la caché se cree en la nueva proyección. Los elementos de ráster en un dataset de mosaico se pueden almacenar en caché cuando el procesamiento es intenso y está tratando publicar un servicio de imágenes rápido, sin el almacenar en caché todo el servicio de imágenes.</div>",
		resampleName: "Remuestrear",
		resampleSnip: "Cambia el tamaño de celda de un ráster.",
		resampleDesc: "La función Remuestrear cambia el tamaño de celda, el tipo de remuestreo o ambos.<div><br/>La función Remuestrear solo se debería utilizar con requisitos de cálculo específicos, por ejemplo, cuando calcula la magnitud-dirección del viento o la corriente que requiere el remuestreo de la resolución de origen.</div>",
		roundDownName: "Redondeo hacia abajo",
		roundDownSnip: "Devuelve el valor entero inmediatamente más bajo, representado como un punto flotante, con cada celda de un ráster.",
		roundDownDesc: "La función Redondeo hacia abajo devuelve el número entero inmediatamente inferior, como un valor de punto flotante, para cada píxel de un ráster.",
		roundUpName: "Redondeo hacia arriba",
		roundUpSnip: "Devuelve el valor entero inmediatamente más alto, representado como un punto flotante, con cada celda de un ráster.",
		roundUpDesc: "Redondeo hacia arriba devuelve el número entero inmediatamente superior, como un valor de punto flotante, para cada píxel de un ráster.",
		segmentMeanShiftName: "Segmentación (desplazamiento medio)",
		segmentMeanShiftSnip: "Agrupa los píxeles adyacentes con características espectrales similares en segmentos.",
		segmentMeanShiftDesc: "Esta función identifica objetos, entidades o segmentos en sus imágenes agrupando los píxeles adyacentes que tienen características espectrales y espaciales similares. Puede controlar la cantidad de suavizado espacial y espectral para ayudarle a obtener entidades de interés.",
		s1RadiometricCalibrationName: "Calibración radiométrica de Sentinel-1",
		s1RadiometricCalibrationSnip: "Realiza diferentes tipos de calibraciones radiométricas en datos de Sentinel-1.",
		s1RadiometricCalibrationDesc: "Esta función ráster realiza tres calibraciones diferentes para datasets de Sentinel-1, incluidas beta cero y sigma cero, y genera el dataset calibrado. El objetivo de la calibración de SAR consiste en ofrecer imágenes en las que los valores de píxel se pueden relacionar directamente con la retrodispersión del radar de la escena. Aunque las imágenes de SAR sin calibrar bastan para un uso cualitativo, las imágenes de SAR calibradas son primordiales para un uso cuantitativo de los datos de SAR.<div><br/>El procesamiento habitual de los datos de SAR, que genera imágenes de nivel 1, no incluye correcciones radiométricas y persiste una importante desviación radiométrica. Por tanto, debe aplicar correcciones radiométricas a las imágenes de SAR para que los valores de píxel de las imágenes representen verdaderamente la retrodispersión del radar de la superficie reflectante. La corrección radiométrica también se necesita para comparar las imágenes de SAR adquiridas de sensores distintos, o adquiridas del mismo sensor a horas distintas, en modos distintos o procesadas por procesadores distintos.</div>",
		s1ThermalNoiseRemovalName: "Eliminación de ruido térmico de Sentinel-1",
		s1ThermalNoiseRemovalSnip: "Elimina el ruido térmico de los datos de Sentinel-1.",
		s1ThermalNoiseRemovalDesc: "La corrección del ruido térmico se puede aplicar a los productos Single Look Complex (SLC) de nivel 1 y a los productos Ground Range Detection (GRD) de nivel 1 de Sentinel-1 que no hayan sido corregidos. El operador también puede eliminar esta corrección en función de las anotaciones del producto para reintroducir la señal de ruido eliminada para generar el producto original. Las anotaciones de producto se actualizarán en consecuencia para permitir que se vuelva a aplicar la corrección. ",
		setNullName: "Establecer nulos",
		setNullSnip: "Establecer nulos establece las ubicaciones de celda identificadas en NoData según los criterios especificados. Devuelve NoData si una evaluación condicional es verdadera y devuelve un valor especificado por otro ráster si es falsa.",
		setNullDesc: "La función Establecer nulos define los píxeles identificados como NoData según criterios específicos. Devuelve NoData si una evaluación condicional es verdadera (1) y devuelve el valor especificado en el Ráster falso si una evaluación condicional es falsa (0). Este criterio viene determinado por la salida de una función matemática lógica, que será el Ráster de entrada.",
		shadedReliefName: "Relieve con sombra",
		shadedReliefSnip: "Crea una representación multibanda, con códigos de color y 3D de la superficie, teniendo en cuenta la posición relativa del sol para sombrear la imagen.",
		shadedReliefDesc: "La función Relieve sombreado crea un modelo de representación 3D del terreno en color mediante la fusión de imágenes a partir de los métodos de codificación de elevación y de sombreado. Esta función utiliza las propiedades de altitud y acimut para especificar la posición del sol.<div><br/></div>",
		sinHName: "Seno hiperbólico (SinH)",
		sinHSnip: "Calcula el seno hiperbólico de las celdas de un ráster.",
		sinHDesc: "La función calcula el seno hiperbólico de los píxeles de un ráster.",
		sinName: "Seno (Sin)",
		sinSnip: "Calcula el seno de las celdas de un ráster.",
		sinDesc: "La función calcula el seno de los píxeles de un ráster.",
		slopeName: "Pendiente",
		slopeSnip: "Calcula la tasa de cambio desde un valor de píxel hacia sus vecinos.",
		slopeDesc: "La función ráster calcula la pendiente, que es la tasa de cambio de elevación para cada celda de modelo digital de elevación (DEM). Es la primera derivada de un DEM.<div><br/>Esta función utiliza una función atan() acelerada. Es seis veces más rápido, y el error de aproximación siempre es menor de 0.3 grados.</div>",
		speckleName: "Moteado",
		speckleSnip: "Proporciona filtros para quitar ruido a datasets de radar de apertura sintética.",
		speckleDesc: "El moteado es el ruido de alta frecuencia de los datos de radar. Las imágenes generadas por los sistemas de radar de apertura sintética (SAR) son muy proclives a contener ruido de moteado debido al procesamiento de señales dispersas y la interferencia de las ondas electromagnéticas dispersadas por superficies u objetos. Esta función de ruido filtra el dataset de radar con ruido y suaviza el ruido mientas retiene los bordes o entidades precisas en la imagen.",
		spectralConversionName: "Conversión espectral",
		spectralConversionSnip: "Aplica una matriz a una imagen multibanda.",
		spectralConversionDesc: "La función Conversión espectral aplica una matriz a una imagen multibanda para influir en los valores de color del resultado.<div><br/>Algunos sensores no recogen bandas azules debido a una baja relación señal-ruido. Se puede utilizar, por ejemplo, para convertir una imagen de infrarrojos de colores falsos en una imagen en color pseudonatural.</div>",
		squareRootName: "Raíz cuadrada",
		squareRootSnip: "Calcula la raíz cuadrada de los valores de celda de un ráster.",
		squareRootDesc: "La función Raíz cuadrada calcula la raíz cuadrada de los valores de píxel de un ráster.",
		squareName: "Cuadrado",
		squareSnip: "Calcula el cuadrado de los valores de celda de un ráster.",
		squareDesc: "Cuadrado calcula el cuadrado de los valores de píxel de un ráster.",
		statisticsHistogramName: "Estadísticas e histograma",
		statisticsHistogramSnip: "Definir o asociar estadísticas e histograma.",
		statisticsHistogramDesc: "La función Estadísticas e histograma se utiliza para definir las estadísticas y el histograma de un ráster. Puede insertar esta función al final de la cadena de funciones para describir las estadísticas y el histograma de una plantilla de función ráster (RFT). Puede ser necesario hacerlo para controlar la visualización predeterminada del resultado de procesamiento, especialmente al definir una cadena de funciones que contiene muchas funciones.<div><br/>Puede definir estadísticas escribiendo los valores o importar desde un dataset ráster o un archivo XML. Los histogramas solo pueden definirse importando un archivo.</div>",
		statisticsName: "Estadísticas",
		statisticsSnip: "Calcula las estadísticas focales para cada píxel de una imagen basándose en una vecindad focal definida.",
		statisticsDesc: "La función Estadísticas calcula las estadísticas focales para cada píxel de una imagen basándose en una vecindad focal definida.<div><br/>La función Estadísticas se puede utilizar para rellenar líneas no continuas en una imagen. Las líneas no continuas con frecuencia las ocasionan los problemas en el sensor donde no se recopilan los datos. Esto ha ocurrido en los sensores como el instrumento de asignador temático mejorado Plus (ETM+) de Landsat 7. Este datos faltantes ocasionan problemas para el análisis y también a la hora de examinar las imágenes. No hay mucho que hacer al utilizar las imágenes para el análisis; sin embargo, si hubo alguna imagen superpuesta, se podría utilizar en lugar del contenido faltante. Lo mismo se podría hacer si las imágenes se utilizan para visualización. Sin embargo, no siempre hay una imagen adicional para rellenar el contenido que falta, así que se debe derivar de los datos existentes.</div>",
		streamLinkName: "Vínculo de curso de agua",
		streamLinkSnip: "Asigna valores únicos a secciones de una red lineal de ráster entre intersecciones.",
		streamLinkDesc: "La función global Vínculo de curso de agua asigna valores únicos a secciones de una red de ráster lineal entre intersecciones.<div><br/>Los vínculos son las secciones de un canal de curso de agua que conecta dos cruces sucesivos, un cruce y la salida o un cruce y la división de drenaje. En hidrología, estos segmentos de curso de agua se llaman alcances. Un cruce se relaciona con un punto de fluidez y ayuda a delinear el límite de la subcuenca de la cuenca hidrográfica o del drenaje.</div>",
		stretchName: "Extensión",
		stretchSnip: "Mejora una imagen ajustando el rango de valores mostrados. Con ello no se alteran los valores de píxel subyacentes. Si un píxel tiene un valor ajeno al rango especificado, aparecerá como el valor mínimo o el máximo.",
		stretchDesc: "La función Extender mejora las imágenes, para ello, cambia propiedades como el brillo, el contraste y gamma a través de varios tipos de extensión. Esta función usa las estadísticas de los rásteres del dataset de mosaico; por tanto, si usa esta función, debe asegurarse de que se han calculado las estadísticas.<div><br/>El tipo de extensión define una extensión del histograma que se va a aplicar a los rásteres para mejorar su apariencia. La extensión mejora el aspecto de los datos ya que expande los valores de píxel en un histograma a partir de los valores máximo y mínimo que se han definido según su profundidad de bits. </div>",
		swathName: "Franja",
		swathSnip: "Interpola a partir de cuadrículas irregulares o datos de franjas.",
		swathDesc: "Algunos datasets de netCDF o HDF almacenan su geolocalización como matrices con espacios irregulares. Al agregar estos datasets a un dataset de mosaico, la función de franja toma los datos cuadriculados irregulares y los remuestrea para que cada píxel tenga un tamaño uniforme y sea cuadrado.<div><br/>Al agregar variables de netCDF o HDF a un dataset de mosaico, comprobará automáticamente si los datos están dispuestos en la matriz de forma regular. Si no es así, se aplica automáticamente la función de franja para convertir los rásteres irregulares en puntos y, después, en un ráster cuadriculado regular. Puede cambiar el método de interpolación y el tamaño de celda utilizados en la función ráster de franja. Para los datos ráster con espacios regulares, no se aplicará la interpolación y los datos se leerán tal cual.</div>",
		tanHName: "Tangente hiperbólica (TanH)",
		tanHSnip: "Calcula la tangente hiperbólica de celdas en un ráster.",
		tanHDesc: "La función calcula la tangente hiperbólica de los píxeles de un ráster.",
		tanName: "Tangente (Tan)",
		tanSnip: "Calcula la tangente de celdas en un ráster.",
		tanDesc: "La función calcula la tangente de los píxeles de un ráster. ",
		tasseledCapName: "Tasseled Cap (Kauth-Thomas)",
		tasseledCapSnip: "Calcula los niveles de vegetación, la humedad y la luminosidad. Esta técnica se basa en coeficientes que deben calcularse específicamente para un sensor.",
		tasseledCapDesc: "La transformación Tasseled Cap (Kauth-Thomas) está diseñada para analizar y representar fenomenología de la vegetación y cambios de desarrollo urbano detectados por diversos sistemas de sensor de satélite. Se conoce como la transformación Tasseled Cap debido a la forma de la distribución gráfica de los datos. Esta transformación proporcionó una lógica para los patrones encontrados en los datos MSS Landsat de campos agrícolas como una función del ciclo de vida del cultivo. Esencialmente, a medida que los cultivos crecen desde la semilla hasta la madurez, hay un aumento neto de infrarrojo cercano y una disminución de reflectancia roja con base en el color del suelo<div><br/>La utilidad de esta transformación se ha ampliado de los cultivos de seguimiento para al análisis y la representación cartográfica de la vegetación para apoyar una variedad de aplicaciones, como la silvicultura, la gestión de vegetación industrial, la representación cartográfica y la gestión de ecosistemas, el inventario y el control de la retención del carbono y los créditos, el desarrollo urbanístico, y muchas más. También se ha ampliado su compatibilidad inicial con Landsat MSS para incluir otros sistemas de satélite populares, como Landsat TM, Landsat ETM+, Landsat 8, IKONOS, QuickBird, WorldView-2 y los sensores multiespectrales RapidEye.</div>",
		timesName: "Times",
		timesSnip: "Multiplica los valores de dos rásteres celda por celda.",
		timesDesc: "La función Multiplicación multiplica los valores de dos rásteres píxel por píxel.",
		transposeBitsName: "Transponer bits",
		transposeBitsSnip: "Desempaqueta los bits del píxel de entrada y los asigna a los bits especificados en el píxel de salida. El objetivo de esta función es manipular bits de un par de entradas, como los productos de banda de calidad de Landsat 8.",
		transposeBitsDesc: "La función Transponer bits desempaqueta los bits del píxel de entrada y los asigna a los bits especificados en el píxel de salida. El objetivo de esta función es manipular bits de un par de entradas, como los productos de banda de calidad de Landsat 8.",
		unitConversionName: "Conversión de unidad",
		unitConversionSnip: "Cambia los valores de una unidad de medida a otra.",
		unitConversionDesc: "Esta función convierte píxeles de una unidad a otra. Admite la conversión de distancia, velocidad y temperatura.",
		vectorFieldName: "Campo vectorial",
		vectorFieldSnip: "Muestra datasets con magnitud (u) y dirección (v) como flechas cuyo tamaño representa la magnitud, mientras que el ángulo representa la dirección.",
		vectorFieldDesc: "La función Campo de vector se utiliza para combinar y convertir dos rásteres en un ráster de dos bandas que sea del tipo de datos Magnitud-Dirección o del tipo de datos U-V.<div><br/>El valor U en ocasiones se conoce como velocidad zonal, y el valor V, como velocidad meridional.</div>",
		viewshed2Name: "Cuenca visual",
		viewshed2Snip: "Determina las ubicaciones de superficie ráster visibles para un conjunto de entidades de observador utilizando métodos geodésicos.",
		viewshed2Desc: "La función Cuenca visual determina las ubicaciones de superficie ráster visibles para un conjunto de entidades de observador utilizando métodos geodésicos<div><br/>Una prueba de línea de visión entre el destino y cada observador determina la visibilidad de cada centro de píxel. Si un observador puede ver el destino en el centro del píxel, se considera que el píxel es visible. Esta herramienta siempre tiene en cuenta la curvatura de la tierra a la hora de determinar la visibilidad.</div>",
		watershedName: "Cuenca hidrográfica",
		watershedSnip: "Determina el área de contribución por sobre un conjunto de celdas de un ráster.",
		watershedDesc: "La función global Cuenca hidrográfica determina el área de cuenca contribuyente por encima de un conjunto de píxeles de un ráster. Las cuencas hidrográficas se delinean a partir de un ráster de dirección de flujo que identifica la dirección de flujo de cada píxel.",
		weightedOverlayName: "Superposición ponderada",
		weightedOverlaySnip: "Superpone varios rásters con una escala de medición común y pondera cada uno según su importancia.",
		weightedOverlayDesc: "Esta función permite superponer varios rásteres con una escala de medición común y pondera cada uno según su importancia.",
		weightedSumName: "Suma ponderada",
		weightedSumSnip: "Pondera y agrega un conjunto de rásteres celda por celda.",
		weightedSumDesc: "La función Suma ponderada permite superponer varios rásteres al multiplicar cada uno por su peso y sumar los resultados.",
		windchillName: "Sensación térmica",
		windchillSnip: "Combina la temperatura ambiente del aire y la velocidad del viento para calcular el factor de sensación térmica.",
		windchillDesc: "La función de sensación térmica resulta útil para identificar las condiciones invernales peligrosas que, dependiendo de los tiempos de exposición a los elementos, pueden causar congelación o incluso hipotermia. La sensación térmica es una forma de medir cuánto frío siente una persona cuando se tiene en cuenta el viento combinado con unas temperaturas ya de por sí frías. Cuanto más rápida sea la velocidad del viento, más rápida será la pérdida de calor del cuerpo y más frío se sentirá.",
		zonalRemapName: "Nueva representación cartográfica zonal",
		zonalRemapSnip: "Se realiza una nueva representación cartográfica de los píxeles de un ráster basándose en las zonas definidas en otro ráster y en la representación cartográfica de los valores que dependen de la zona que se haya definido en una tabla.",
		zonalRemapDesc: "Esta función le permite realizar una nueva representación cartográfica de los píxeles de un ráster basándose en las zonas definidas en otro ráster y en la representación cartográfica de los valores que dependen de la zona que se haya definido en una tabla.",
		zonalStatisticsName: "Estadísticas zonales",
		zonalStatisticsSnip: "Calcula estadísticas sobre valores de un ráster dentro de zonas de otro dataset.",
		zonalStatisticsDesc: "La función calcula estadísticas sobre valores de un ráster dentro de zonas de otro dataset. Una zona se define como todas las áreas de la entrada que tienen el mismo valor. No es necesario que estas áreas sean contiguas. Cuando tanto las entradas de zona como las de valor son rásteres de la misma resolución, se utilizarán directamente. Si las resoluciones son diferentes, se aplica un remuestreo interno para hacerlas coincidir antes de realizar la operación zonal.",
		flowLengthName: "Longitud de flujo",
		flowLengthSnip: "Calcula la distancia aguas arriba o aguas abajo o la distancia ponderada a lo largo de la ruta de flujo para cada celda.",
		flowLengthDesc: "Esta es una función ráster global. Esta función crea una capa ráster de distancia aguas arriba o aguas abajo, o distancia ponderada, a lo largo de la ruta de flujo de cada celda.<div><br/>Un uso principal de la función Longitud de flujo es calcular la longitud de la ruta de flujo más larga dentro de una cuenca determinada. Esta medida se utiliza generalmente para calcular el tiempo de concentración de una cuenca. Se realiza con la opción Aguas arriba. La función también se puede utilizar para crear diagramas de distancia-área de eventos hipotéticos de precipitación y escorrentía mediante el ráster de peso, como una impedancia al movimiento descendente.</div>",
		streamOrderName: "Clasificación de arroyos",
		streamOrderSnip: "Asigna un orden numérico a segmentos de un ráster que representa las ramas de una red lineal",
		streamOrderDesc: "Esta es una función ráster global. Esta función crea una capa ráster que asigna un orden numérico a los segmentos de un ráster que representan las ramas de una red lineal.<div><br/>La salida de la función Clasificación de cursos de agua será de mayor calidad si la capa ráster de curso de agua de entrada y el ráster de dirección del flujo de entrada se derivan de la misma superficie. Si el ráster de curso de agua se deriva de un dataset de curso de agua rasterizado, la salida puede no ser útil porque, a través de cada celda individual, la dirección no corresponderá con la ubicación de las celdas de curso de agua. El resultado de la función Acumulación de flujo se puede usar para crear una red de cursos de agua en ráster aplicando un valor de umbral para seleccionar las celdas que presentan un flujo acumulado elevado. Por ejemplo, las celdas que tienen más de 100 celdas que fluyen hacia ellas se utilizan para definir la red de corrientes. Use la función Con o Establecer nulos para crear un ráster de red de cursos de agua en el que los valores de acumulación de flujo de 100 o más se convierten en uno y el resto se dejan en segundo plano (NoData). La red de cursos de agua resultante puede usarse en la función Clasificación de cursos de agua. Esta función solo admite una capa ráster de dirección del flujo de entrada D8. Puede crear direcciones de flujo D8 con la función Dirección de flujo y ejecutarla con el tipo de dirección de flujo predeterminado, D8.</div>",
		snapPourPointName: "Ajuste de corrientes",
		snapPourPointSnip: "Ajusta las corrientes a las celdas de la acumulación de flujo más alta dentro de una distancia específica",
		snapPourPointDesc: "Esta es una función ráster global. Esta función ajusta las corrientes a las celdas de la acumulación de flujo más alta dentro de una distancia específica.<div><br/>La función Alinear punto de fluidez se utiliza para asegurar la selección de puntos de flujo acumulado alto cuando se delinean cuencas de drenaje al utilizar la función Cuenca hidrográfica. Alinear punto de fluidez buscará, dentro de una distancia de alineación alrededor de los puntos de fluidez especificados, la celda de mayor flujo acumulado y moverá el punto de fluidez a esa ubicación. La salida es una capa ráster de tipo entero cuando las ubicaciones originales del punto de fluidez se han alineado a ubicaciones de mayor flujo acumulado.</div>",
		sinkName: "Sumidero",
		sinkSnip: "Crea una capa ráster que identifica todos los sumideros o áreas de drenaje interno",
		sinkDesc: "Esta es una función ráster global. Esta función crea una capa ráster que identifica todos los sumideros o áreas de drenaje interno. Un sumidero es una celda o un conjunto de celdas conectadas espacialmente, con una dirección de flujo a la que no se le puede asignar uno de los ocho valores válidos en un ráster de dirección de flujo. Esto puede ocurrir cuando todas las celdas vecinas son mayores que la celda de procesamiento o cuando dos celdas fluyen entre sí, creando un bucle de dos celdas.<div><br/>La función Sumidero solo admite una capa ráster de dirección del flujo de entrada D8. Puede crear direcciones de flujo D8 con la función Dirección de flujo y ejecutarla con el tipo de dirección de flujo predeterminado, D8. La salida de la función Sumidero es un ráster entero en el que cada sumidero tiene asignado un valor único. Estos valores únicos presentan un rango entre uno y el número total de sumideros. Por ejemplo, si el número total de sumideros fuera 1.000, el rango de valores únicos sería de 1 a 1.000.</div>",
		aggregateName: "Agregar",
		aggregateSnip: "Genera una versión de resolución reducida de un ráster.",
		aggregateDesc: "La función Agregar remuestrea un ráster de entrada a una resolución más gruesa basándose en una estrategia de agregación especificada. Cada celda de salida contiene la Suma, el Mínimo, el Máximo, el Valor medio o la Mediana de las celdas de entrada abarcadas por la extensión de esa celda.<div><br/>Puede especificar el factor por el que se multiplica el tamaño de celda del ráster de entrada. Por ejemplo, un valor de factor de celda de 3 resultaría en una salida donde el tamaño de celda es tres veces mayor que el del ráster de entrada. Puede definir cómo tratar la extensión de la salida si el número de filas o columnas de la entrada no es un múltiplo exacto del factor de celda. Por defecto, los límites superior y derecho se expandirán para cubrir una extensión espacial mayor que la del ráster de entrada, a fin de garantizar que todas las celdas de entrada se procesen. Como alternativa, los límites superior y derecho se pueden reducir para cubrir una extensión menor, de forma que el número de filas y columnas procesado sea un múltiplo exacto del factor de celda. Puede definir cómo va a tratar el cálculo de agregación de las celdas NoData. El mecanismo predeterminado es que las celdas NoData de entrada que se encuentren dentro de la extensión espacial de una celda más grande del ráster de salida se ignorarán al determinar el valor de esa celda de salida. Como alternativa, puede especificar que, si existe incluso una sola celda NoData de entrada dentro de la extensión espacial de una celda de salida, dicha celda será NoData en el ráster de salida.</div>",
		ccdcName: "Análisis CCDC",
		ccdcSnip: "Evalúa los cambios en los valores de píxel a lo largo del tiempo utilizando el algoritmo Clasificación y detección de cambios continuas (CCDC) y genera los resultados del modelo.",
		ccdcDesc: "La función Análisis CCDC evalúa los cambios en los valores de píxel a lo largo del tiempo utilizando el algoritmo Clasificación y detección de cambios continuas (CCDC) y genera un ráster multidimensional que contiene los resultados del modelo. Solo se admite junto con la función Detectar cambios con análisis de cambios en una plantilla de función ráster. Para generar una salida de ráster, conecte la función Análisis CCDC con la función Detectar cambios con análisis de cambios, guarde como una plantilla de función ráster y ejecute Análisis de ráster con la plantilla de función.<div><br/>Esta función utiliza el algoritmo Clasificación y detección de cambios continuas (CCDC) para evaluar los cambios en los valores de píxel a lo largo del tiempo para una pila de imágenes. En una serie temporal de imágenes ópticas o derivados de imágenes (por ejemplo, NDVI), los valores de píxel pueden fluctuar por diversos motivos: 1. Cambio estacional: los cambios de valor de píxel reflejan cambios en la vegetación debido a la variabilidad estacional de la temperatura y las precipitaciones. En el hemisferio norte, por ejemplo, se espera ver una mayor densidad de vegetación verde en verano en comparación con el invierno. 2. Cambio gradual: los cambios de valor de píxel reflejan las tendencias de la vegetación o del agua superficial debido a la variabilidad climática o a prácticas de gestión del suelo a largo plazo. Por ejemplo, el área de suelo desnudo podría aumentar gradualmente debido a una disminución a largo plazo de las precipitaciones. 3. Cambio abrupto: los cambios de valor de píxel reflejan los cambios de la cobertura del suelo que ocurren repentinamente debido a la deforestación, el desarrollo urbanístico, catástrofes naturales, etc. El algoritmo CCDC identifica los tres tipos de cambio con el fin principal de identificar un cambio abrupto. Los modelos de tendencia y regresión armónicas se ajustan a los datos para estimar un cambio estacional o gradual, y las desviaciones repentinas de los modelos de tendencia son indicaciones de un cambio abrupto.<div><br/>El algoritmo CCDC se diseñó originalmente para datos de Temperatura de brillo o Reflectancia de superficie de datos de Landsat TM, Landsat ETM+ y Landsat OLI. Sin embargo, la función Detectar cambios con análisis de cambios junto con esta función detectará cambios en las imágenes multibanda de cualquier sensor admitido, así como derivados de imágenes de una sola banda como índices de banda. Por ejemplo, puede realizar una detección de cambios continua en un ráster de Índice de vegetación de diferencia normalizada (NDVI), porque los cambios abruptos en un NDVI pueden ser indicio de deforestación.</div>",
		computeChangeName: "Calcular cambio",
		computeChangeSnip: "Calcula la diferencia entre dos datasets ráster continuos o de categorías.",
		computeChangeDesc: "La función Calcular cambio se puede utilizar para enumerar las diferencias entre dos rásteres clasificados para el análisis de cambios de cobertura de suelo o se puede utilizar para examinar los cambios entre dos rásteres continuos de una sola banda, por ejemplo, elevación, temperatura, extensión de cobertura, etc.",
		detectChangeName: "Detectar cambios con análisis de cambios",
		detectChangeSnip: "Genera una capa ráster que contiene información de cambios de píxel con el ráster de análisis de cambios de salida.",
		detectChangeDesc: "<div>La función Detectar cambios con análisis de cambios genera una capa ráster que contiene información de fecha de cambio de píxel con el ráster de análisis de cambios. El ráster de análisis de cambios debe ser generado por la herramienta Analizar cambios usando CCDC o la herramienta Analizar cambios con LandTrendr, o bien la función ráster Análisis CCDC o Análisis LandTrendr.</div><br><div>Esta función ráster se puede combinar con las funciones ráster Análisis CCDC o Análisis LandTrendr en una plantilla de función ráster. Para generar una salida de ráster permanente, conecte la función Análisis CCDC o la función Análisis LandTrendr con la función Detectar cambios con análisis de cambios, guarde como una plantilla de función ráster y ejecute Análisis de ráster con la plantilla.</div><br><div>El parámetro <strong>Tipo de cambio</strong> indica la información que se genera. La información se extrae del ráster de análisis de cambios. Cuando se ejecuta esta función en la salida de la función/herramienta CCDC, puede elegir entre las siguientes opciones:</div><ul><li><strong>Hora del último cambio</strong>: la fecha y hora más recientes en las que se marcó un píxel como cambiado.</li><li><strong>Hora del cambio más antiguo</strong>: la fecha y hora en la que se marcó un píxel como cambiado.</li><li><strong>Hora del cambio más grande</strong>: la fecha y hora en las que el cambio calculado era la más significativa para un píxel.</li><li> <strong>Número de cambios</strong>: el número total de veces que el píxel ha cambiado.</li></ul><div>Al ejecutar esta función en la salida de la función/herramienta LandTrendr, están disponibles las siguientes opciones adicionales:</div><ul><li><strong>Hora del cambio más largo</strong>: la fecha en la que un píxel fue marcado como cambiado, al principio o al final del periodo de cambio más largo.</li><li><strong>Hora del cambio más corto</strong>: la fecha en la que un píxel se marcó como cambiado, al principio o al final del periodo de cambio más corto.</li><li><strong>Hora del cambio más rápido</strong>: la fecha en la que un píxel se marcó como cambiado, al principio o al final del periodo de cambio más rápido.</li><li><strong>Hora del cambio más lento</strong>: la fecha en la que un píxel se marcó como cambiado, al principio o al final del periodo de cambio más lento.</li></ul><div>El ráster de salida es un ráster multibanda en el que cada banda contiene información de cambios en función del tipo de cambio seleccionado y del número máximo de cambios especificado. Por ejemplo, si <strong>Tipo de cambio</strong> está definido como <strong>Hora del cambio más temprano</strong> y <strong>Número máximo de cambios</strong> está definido como 2, la función calcula las dos fechas más tempranas en las que se produjeron cambios durante toda la serie temporal para cada píxel. El resultado es un ráster en el que la primera banda contiene las fechas del cambio más temprano por píxel y la segunda banda contiene las fechas del segundo cambio más temprano por píxel.</div><br><div>Al aplicar esta función en la salida de las herramientas LandTrendr, puede elegir si desea extraer la fecha que marca el inicio de un cambio o el final de un cambio con el parámetro <strong>Fecha de segmento</strong>. Por ejemplo, para entender cómo se inició el cambio más reciente en la serie temporal, establezca el <strong>Tipo de cambio</strong> en <strong>Hora del cambio más reciente</strong> y la <strong>Fecha de segmento</strong> en <strong>Inicio de segmento</strong>.</div><br><div>Utilice los siguientes parámetros de filtrado para extraer fechas de cambio más específicas del ráster de análisis de cambios:</div><ul><li><strong>Filtrar por año</strong>: identifique los cambios que se produjeron en un período de tiempo específico, por ejemplo, si está buscando cambios que se produjeran en un paisaje durante cinco años de sequía.</li><li><strong>Filtrar por duración</strong>: identifique los cambios que se produjeron a lo largo de un rango determinado de años, por ejemplo, si solo está buscando cambios abruptos que se produjeran en 1 o 2 años. Puede calcular la duración que le interese con la fórmula <strong>año final - año inicial +1</strong>. Se incluirán los huecos en las series temporales.</li><li><strong>Filtrar por magnitud</strong>: identifique los cambios de una magnitud determinada, por ejemplo, si solo está buscando cambios grandes en el índice de vegetación NDVI. La magnitud es un valor absoluto, por lo que los valores mínimo y máximo no pueden ser negativos. Para especificar el cambio direccional, utilice el parámetro <strong>Cambiar dirección</strong>.</li></ul>",
		distanceAccumulationName: "Acumulación de distancia",
		distanceAccumulationSnip: "Calcula la distancia acumulada para cada celda a los orígenes, teniendo en cuenta la distancia en línea recta, coste-distancia, verdadera distancia de superficie y factores de coste vertical y horizontal.",
		distanceAccumulationDesc: "Acumulación de distancia calcula la distancia de cada ubicación del área de estudio al origen más cercano, o de menor coste. Si solo se proporcionan los orígenes para la entrada, entonces se calcula una distancia en línea recta hasta cada ubicación del área de estudio. Si se utilizan orígenes y barreras como entrada, entonces Acumulación de distancia calcula la distancia en línea recta alrededor de las barreras. Para el ráster de origen y el ráster de barrera, el valor de fondo debería ser NoData, mientras que los orígenes y las barreras se representan con valores de celda válidos. Entre los valores válidos se incluye cero. <div><br/>Cuando se proporciona un ráster de superficie como entrada, entonces se calcula la distancia de superficie real entre las celdas. Para realizar un análisis de coste con Acumulación de distancia, se necesita una superficie de coste. Si se proporciona una superficie de coste, entonces el resultado es un ráster de coste-distancia acumulado. Cuando se proporcionan los factores horizontal y vertical, entonces se acumula la direccionalidad que se considera como coste. Se pueden utilizar cuatro características de origen. Estas características, que pueden ser del origen o de los elementos que se mueven desde el origen, se controlan por medio de parámetros específicos: 1. Acumulación inicial: define el coste inicial antes de que se inicie el movimiento. 2. Acumulación máxima: especifica el coste que puede acumular un origen antes de alcanzar su límite. 3. Multiplicador para aplicar a los costes: especifica el modo de desplazamiento o la magnitud en el origen. 4. Dirección del viaje: identifica si el elemento que se mueve comienza en un origen y se mueve a ubicaciones distintas del origen, o comienza en ubicaciones distintas del origen y regresa a un origen.<div><br/>Por defecto, el resultado de Acumulación de distancia es una banda única, que es el ráster de acumulación de distancia. Sin embargo, también se puede crear una segunda banda, la banda de dirección hacia atrás.  Esta banda indica para cada ubicación del área de estudio la dirección en la que ir para llegar al origen de menor coste.  Se necesitarán ambas bandas para determinar las rutas óptimas dentro del área de estudio. Para generar una ruta, utilice primero la función Extraer banda para extraer el ráster de acumulación de distancia y el ráster de dirección hacia atrás. Utilice estas capas como entrada de la función Ruta de coste. En la función, use el ráster de acumulación de distancia como entrada del Ráster de coste-distancia y el ráster de dirección hacia atrás como la entrada del Ráster de vínculo de menor coste.</div>",
		distanceAllocationName: "Asignación de distancia",
		distanceAllocationSnip: "Calcula la asignación de distancia para cada celda a los orígenes proporcionados en función de la distancia en línea recta, coste-distancia, verdadera distancia de superficie y factores de coste vertical y horizontal.",
		distanceAllocationDesc: "Asignación de distancia calcula a qué origen se asigna cada ubicación del área de estudio. Si solo se proporcionan los orígenes para la entrada, entonces se asignan las ubicaciones con una distancia en línea recta hasta el origen más cercano. Si se utilizan orígenes y barreras como entrada, entonces Asignación de distancia calcula la distancia en línea recta alrededor de las barreras para determinar a qué ubicación se asigna un origen. Para el ráster de origen y el ráster de barrera, el valor de fondo debería ser NoData, mientras que los orígenes y las barreras se representan con valores de celda válidos. Entre los valores válidos se incluye cero.<div><br/>Para realizar un análisis de coste con Asignación de distancia, se necesita una superficie de coste. Si se proporciona una superficie de coste, entonces el resultado es un ráster de asignación basado en el coste acumulativo, no en una distancia en línea recta. Cuando se proporcionan los factores horizontal y vertical, entonces se acumula la direccionalidad que se considera como coste. Cuando se proporciona un ráster de superficie como entrada, entonces la distancia de superficie real cubierta al pasar entre celdas se calcula cuando se determina la asignación. Se pueden utilizar cuatro características de origen. Estas características, que pueden ser del origen o de los elementos que se mueven desde el origen, se controlan por medio de parámetros específicos: 1. Acumulación inicial: define el coste inicial antes de que se inicie el movimiento. 2. Acumulación máxima: especifica el coste que puede acumular un origen antes de alcanzar su límite. 3. Multiplicador para aplicar a los costes: especifica el modo de desplazamiento o la magnitud en el origen. 4. Dirección del viaje: identifica si el elemento que se mueve comienza en un origen y se mueve a ubicaciones distintas del origen, o comienza en ubicaciones distintas del origen y regresa a un origen.<div><br/>Por defecto, el resultado de Asignación de distancia es una banda única, que es el ráster de asignación de distancia. Al activar la opción booleana Generar fila y columna de origen como bandas adicionales en la salida resultará en un ráster multibanda que consta de tres bandas. La primera banda es la banda de asignación de distancia, la segunda banda contiene un índice de fila y la tercera banda contiene un índice de columna. Estos índices identifican la ubicación de la celda de origen más cercana al menor coste-distancia acumulado. El índice de fila de origen y el índice de columna de origen se pueden utilizar juntos para realizar una representación de la intensidad. Si consulta cualquier ubicación en su área de estudio en las bandas dos y tres, sabrá la fila y la columna del origen de menor coste para esa ubicación.</div>",
		eucBackDirectionName: "Dirección euclidiana hacia atrás",
		eucBackDirectionSnip: "Calcula en grados, para cada celda, la dirección a la celda vecina por la ruta más corta, de vuelta al origen más cercano, a la vez que evita las barreras.",
		eucBackDirectionDesc: "La función Dirección euclidiana hacia atrás resulta en un ráster de punto flotante continuo que representa la dirección en grados de vuelta al origen más cercano a la vez que se evitan las barreras, si se proporcionan.<div><br/>Las entradas de Dirección euclidiana hacia atrás son el origen para el que se calculará la dirección. Una entrada opcional es un ráster que representa barreras dentro del área de estudio. Para el ráster de origen y el ráster de barrera, el valor de fondo debería ser NoData, mientras que los orígenes y las barreras se representan con valores válidos. Entre los valores válidos se incluye cero. Por defecto, el cálculo se procesará a la extensión combinada de los orígenes y barreras, además de 2 filas y columnas. Si solo se necesita el análisis dentro de una distancia especificada de los orígenes, entonces se puede usar el parámetro Distancia máxima. Dirección euclidiana hacia atrás admite un método planar y un método geodésico en el cálculo. El cálculo del método planar se realizará en un plano llano proyectado con un sistema de coordenadas cartesianas 2D. El cálculo del método geodésico se realizará en el elipsoide, lo que significa que, independientemente de la proyección de entrada o salida, los resultados no cambian.<div><br/>El resultado de la función Dirección euclidiana hacia atrás se puede utilizar junto con el resultado de la función Distancia euclidiana para determinar las rutas más cortas de las ubicaciones dentro del área de estudio hasta el origen. El resultado de Dirección euclidiana hacia atrás y el resultado de Distancia euclidiana se utilizan en la función Ruta de coste junto con destinos para generar las rutas más cortas.</div>",
		expandName: "Expandir",
		expandSnip: "Expande las zonas seleccionadas de un ráster por zonas en una cantidad especificada de celdas.",
		expandDesc: "Con la función global Expandir, puede generalizar, o simplificar, rásteres haciendo más grandes determinadas zonas. También puede controlar la cantidad de generalización que se producirá.<div><br/>Las zonas que seleccione se incrementarán en tamaño expandiéndose a otras zonas. Conceptualmente, puede visualizar los Valores de zona seleccionados como zonas en primer plano, mientras que el resto de valores permanecen en zonas en segundo plano. Las zonas en primer plano se pueden expandir en zonas en segundo plano.<div><br/>Es posible controlar la cantidad de generalización con el parámetro Número de celdas. De manera predeterminada, este valor es 1, que significa que las zonas seleccionadas se expandirán según la cantidad que corresponda al tamaño de una celda. Para aumentar el grado de generalización, puede especificar un valor mayor para este parámetro. Conceptualmente, es como ejecutar la herramienta tantas veces como el número especificado, siendo los resultados de la ejecución anterior la entrada a la iteración subsiguiente.</div>",
		trendAnalysisName: "Generar tendencia",
		trendAnalysisSnip: "Estima la tendencia de cada píxel a lo largo de una dimensión para una o varias variables de un ráster multidimensional.",
		trendAnalysisDesc: "<div>Esta función se puede utilizar para ajustar datos a lo largo de una línea de tendencia lineal, armónica o polinómica, o se puede utilizar para realizar la detección de tendencias utilizando la prueba de Mann-Kendall o Seasonal-Kendall.</div><br><div>El ráster de tendencia de salida generado con esta función se utiliza como entrada para la función <strong>Predecir con tendencia</strong>.</div><br><div>Las pruebas de Mann-Kendall y Seasonal-Kendall se utilizan para determinar si existe una tendencia monotónica en los datos. Son no paramétricos, lo que significa que no asumen una distribución específica de los datos. La prueba Mann-Kendall no considera la correlación de serie o los efectos estacionales. Si los datos son estacionales, la prueba de Seasonal-Kendall es más apropiada.</div><br><div>Si la herramienta se utiliza para realizar la prueba de Mann-Kendall o Seasonal-Kendall, la salida es un ráster de cinco bandas con la siguiente información:</div><ul><li>Banda 1 = Banda de pendiente de Sen</li><li>Banda 2 = valor P</li><li>Banda 3 = Puntuación de Mann-Kendall (S)</li><li>Banda 4 = Varianza S</li><li></li><li>Banda 5 = Puntuación Z</li></ul><div>Las salidas de las pruebas Mann-Kendall o Seasonal-Kendall se pueden usar para determinar qué píxeles de su serie temporal multidimensional presentan una tendencia estadísticamente significativa. Puede utilizar esta información junto con el análisis de tendencia lineal, armónica o polinómica para extraer tendencias significativas en su serie temporal. Puede generar una máscara que incluya píxeles con valores p significativos, aplicar la máscara al ráster multidimensional y utilizar este ráster multidimensional enmascarado como entrada de la herramienta para realizar un análisis de tendencia lineal, monotónica o polinómica.</div><br><div>Existen tres opciones de línea de tendencia para ajustar una tendencia a los valores de la variable a lo largo de una dimensión: lineal, polinómica y armónica.</div><br><div>En el caso del análisis de tendencia lineal, la salida es un ráster de tres bandas, donde:</div><ul><li>Banda 1 = Pendiente</li><li>Banda 2 = Interceptar</li><li>Banda 3 = Error cuadrático medio (RMSE) o error alrededor de la línea de mejor ajuste</li></ul><div>En el caso del análisis de tendencia polinómica, el número de bandas de la salida depende del orden polinómico. Un ajuste polinómico de segundo orden produce un ráster de cuatro bandas, donde:</div><ul><li>Banda 1 = Polynomial_2</li><li>Banda 2 = Polynomial_1</li><li>Banda 3 = Polynomial_0</li><li>Banda 4 = RMSE</li></ul><div>Un ajuste polinómico de tercer orden produce un ráster de cinco bandas, donde:</div><ul><li>Banda 1 = Polynomial_3</li><li>Banda 2 = Polynomial_2</li><li>Banda 3 = Polynomial_1</li><li>Banda 4 = Polynomial_0</li><li>Banda 5 = RMSE</li></ul><div>En el caso del análisis de tendencia armónico, el número de bandas de la salida depende de la frecuencia armónica. Si la frecuencia se establece en 1, la salida será un ráster de cinco bandas, donde:</div><ul><li>Banda 1 = Pendiente</li><li>Banda 2 = Interceptar</li><li>Banda 3 = Harmonic_sin1</li><li>Banda 4 = Harmonic_cos1</li><li>Banda 5 = RMSE</li></ul><div>Si la frecuencia se establece en 2, la salida será un ráster de siete bandas, donde::</div><ul><li>Banda 1 = Pendiente</li><li>Banda 2 = Interceptar</li><li>Banda 3 = Harmonic_sin1</li><li>Banda 4 = Harmonic_cos1</li><li>Banda 5 = Harmonic_sin2</li><li>Banda 6 = Harmonic_cos2</li><li>Banda 7 = RMSE</li></ul><div>El parámetro <strong>Longitud del ciclo</strong> del análisis de tendencia armónico se utiliza para indicar el número y longitud de ciclos que espera ver en sus datos a lo largo de un día o año. Por ejemplo, si espera que sus datos pasen dos ciclos de variación en un año, la longitud de ciclo será 182,5 días o 0,5 años. Si recopila datos de temperatura cada tres horas y hay un ciclo de variación al día, la longitud de ciclo es de un día.</div><br><div>El parámetro <strong>Frecuencia del análisis</strong> de tendencia armónico se utiliza para describir el modelo armónico que se ajustará a los datos. Si la frecuencia se define como 1, se utilizará una combinación de curva lineal y curva armónica de primer orden para ajustar el modelo. Si la frecuencia es 2, se utilizará una combinación de lineal, curva armónica de primer orden y curva armónica de segundo orden para ajustar los datos. Si la frecuencia es 3, se utilizará una curva armónica adicional de tercer orden para modelar los datos, y así sucesivamente.</div><br><div>Se pueden generar estadísticas de idoneidad de ajuste del modelo como salidas opcionales. Se pueden calcular y simbolizar el error cuadrático medio (RMSE), R cuadrado y el valor P de pendiente de tendencia. Simbolice la capa ráster de tendencia de salida mediante la simbología <strong>RGB</strong> y especifique las estadísticas como las bandas roja, verde y azul.</div><br>",
		spectralUnmixingName: "Espectral lineal sin mezclas",
		spectralUnmixingSnip: "Realiza la clasificación por subpíxeles y calcula la abundancia fraccionaria de los diferentes tipos de cobertura de suelo de los píxeles individuales.",
		spectralUnmixingDesc: "La función Espectral lineal sin mezclas calcula la cobertura fraccional de píxeles individuales que contienen varios tipos de cobertura de suelo. Genera una capa multibanda, donde cada banda corresponde a la abundancia fraccional de cada clase de cobertura de suelo. Por ejemplo, puede utilizarla para realizar la clasificación de la cobertura de suelo en una imagen multiespectral para identificar la vegetación fotosintética, el suelo desnudo y vegetación muerta o no fotosintética.<div><br/>El orden del ráster multibanda de salida sigue el orden del perfil espectral de entrada. El número de clases no puede ser mayor que el número de bandas del ráster de entrada. Por ejemplo, no puede extraer información sobre más de 8 clases de un ráster de 8 bandas.</div>",
		multidimensionalFilterName: "Filtro multidimensional",
		interpolateRasterByDimensionFunctionName: "Interpolar ráster por dimensión",
		interpolateRasterByDimensionFunctionSnip: "Interpola un ráster multidimensional con valores de dimensión especificados usando porciones adyacentes.",
		interpolateRasterByDimensionFunctionDesc: "<p>Esta función le permite estimar los valores de píxel de una división de dimensión no definida en un ráster multidimensional. Por ejemplo, si tiene un dataset que contiene la temperatura del océano en el nivel de la superficie y a 100 metros por debajo del nivel del mar y desea estimar la temperatura a 50 metros por debajo del nivel del mar, puede utilizar esta función para obtener una estimación de esa profundidad mediante la definición de dimensión Por valores.</p><p>También puede reducir el tamaño de un datase mensual al de un dataset diario utilizando la definición de la dimensión Por intervalo y especificando el valor del parámetro Paso como 1 y el valor del parámetro Unidad como Días.</p><p>Utilice la definición de dimensión Por ráster de destino para estimar el valor del ráster de destino.</p>",
		multidimensionalFilterSnip: "Crea una capa ráster a partir de un dataset ráster multidimensional o una capa ráster multidimensional dividiendo los datos en variables y dimensiones definidas.",
		multidimensionalFilterDesc: "Filtro multidimensional crea una capa ráster multidimensional filtrando y extrayendo un subconjunto de variables de un ráster multidimensional. Por ejemplo, tiene un dataset multidimensional con 30 años de datos de precipitaciones mensuales, y solo desea extraer datos de cada enero para ver cómo han cambiado las precipitaciones ese mes.<div><br/>Use el parámetro Definición de dimensión para dividir las dimensiones por un intervalo, un valor o un rango de valores. Por ejemplo, si cuenta con 10 años de datos de salinidad del océano que se han recopilado mensualmente y a cada 2 metros de profundidad hasta llegar a los 500 metros, podría usar las distintas opciones de definición de dimensión en los siguientes escenarios. Escenario 1: extraer los datos de salinidad para el mes de enero durante el período de 10 años. Elija Por valores, cambie Dimensión a StdTime y cambie Valores a Enero. Escenario 2: dividir los datos de salinidad en un rango de profundidad de 0 a 150 metros. Elija Por rangos, cambie Dimensión a StdZ y cambie Valor mínimo a -150 y Valor máximo a 0. Escenario 3: extraer los datos de salinidad de los primeros 10 días de cada mes de enero durante un período de 10 años. Elija Por iteración, cambie Dimensión a StdTime, cambie Inicio de la primera iteración y Fin de la primera iteración para el inicio y el fin correspondientes del periodo de iteración, cambie Paso a 1 y cambie Unidad a Años.</div>",
		multidimensionalRasterName: "Ráster multidimensional",
		multidimensionalRasterSnip: "Agrega datos multidimensionales a un mapa como capa ráster multidimensional.",
		multidimensionalRasterDesc: "La función Ráster multidimensional agrega datos multidimensionales a un mapa como capa ráster multidimensional. Esta función resulta útil al realizar flujos de trabajo de análisis de ráster con una cadena de funciones.<div><br/>Entre los datasets ráster multidimensionales admitidos se encuentran netCDF, GRIB, HDF y CRF de Esri. También se admiten datasets de mosaico multidimensionales.</div>",
		optimalPathAsRasterName: "Ruta óptima como ráster",
		optimalPathAsRasterSnip: "Calcula la ruta de menor coste desde un origen a su destino.",
		optimalPathAsRasterDesc: "Esta función global produce un ráster de salida que registra la ruta o las rutas óptimas desde las ubicaciones seleccionadas hasta la celda de origen más cercana definida dentro de la superficie de coste acumulativo, en términos de coste-distancia.<div><br/>En general, se requiere que se ejecuten una o varias de las funciones de coste ponderado (Acumulación de distancia o Asignación de distancia) antes de ejecutar la función Ruta óptima como ráster para crear los rásteres de acumulación de distancia de entrada y dirección hacia atrás. Son capas ráster de entrada obligatorias para la función Ruta óptima. Los valores de la ruta óptima de salida representan el número de rutas en una ubicación determinada. En muchos casos, las vías siguen las mismas rutas, abandonan un origen y divergen para ir a destinos diferentes. Por ejemplo, un valor de uno indica que solo hay una ruta óptima en una ubicación determinada, mientras que un valor de cinco significa que hay cinco rutas óptimas en la ubicación que atraviesan esa celda en el área de estudio.<div><br/>Los datos de destino de entrada deben ser una capa ráster. El conjunto de celdas de destino son todas las celdas del ráster de entrada con valores válidos. Las celdas sin valores NoData no se incluyen en el conjunto. El valor cero se considera un destino legítimo. Se puede crear un ráster de destino con las herramientas de extracción. Si tiene entidades de origen o destino, puede convertirlas a ráster con la función Rasterizar entidades. Use el ráster de acumulación de distancia o dirección hacia atrás como entrada del ráster para la función de rasterización. De esta manera, se garantiza que la entidad se rasterice con los mismos valores de tamaño de celda, extensión y referencia espacial que el resto de rásteres de la función Ruta óptima como ráster. La función Ruta óptima como ráster también se puede utilizar para derivar la ruta de menor resistencia a un modelo digital de elevación (DEM). En este caso, utilice el DEM para el ráster de acumulación de distancia de entrada y la salida de la función Dirección de flujo para el ráster de dirección hacia atrás.</div>",
		trendName: "Predecir con tendencia",
		trendSnip: "Calcula una capa ráster multidimensional prevista utilizando el ráster de tendencia de salida de la función Generar tendencia o la herramienta de geoprocesamiento Generar ráster de tendencia.",
		trendDesc: "La función Predecir con tendencia calcula una capa ráster multidimensional prevista utilizando el ráster de tendencia de salida de la función Generar tendencia o la herramienta de geoprocesamiento Generar ráster de tendencia.",
		rasterCollectionName: "Procesar colección de rásteres",
		rasterCollectionSnip: "Procesa cada división de un ráster multidimensional o cada elemento de un ráster de mosaico. Esta función también puede agregar varias divisiones a una única división.",
		rasterCollectionDesc: "La función Procesar colección de rásteres procesa cada división de un ráster multidimensional o cada elemento de un ráster de mosaico. Esta función también puede agregar varias divisiones a una única división.<div><br/>Esta función procesa cada división de un ráster multidimensional o ráster de mosaico con una plantilla de función ráster. Esta función admite las siguientes opciones: 1. Especificar una plantilla de función ráster para la Función de elemento. Por ejemplo, tiene un dataset de mosaico con 20 años de imágenes de Landsat y desea calcular el NDVI para cada escena de la serie temporal. En Función de elemento, especifique una plantilla de función ráster que contenga la función ráster NDVI. 2. Especificar una plantilla de función ráster para la Función de agregación. Por ejemplo, tiene un ráster multidimensional con 10 años de datos de temperatura diarios y desea calcular la temperatura máxima de cada año. En la Función de agregación, especifique una plantilla de función ráster que contenga la función Estadísticas de celdas, con la operación definida como Máximo. En Definición de agregación, defina Dimensión como StdTime, Tipo como Palabra clave de intervalo e Intervalo de palabra clave como Anualmente. Tenga en cuenta que si el dataset de mosaico de entrada no es multidimensional, la función de agregación no respetará la definición de agregación. La función de agregación agregará todos los elementos o cada grupo en uno si se definen en la plantilla de función de agregación. Para más información sobre el uso de grupos en un dataset de mosaico, consulte Usar elementos de un dataset de mosaico en plantillas de función ráster. 3. Especificar una plantilla de función ráster para la Función de procesamiento. La función o cadena de funciones de esta plantilla se utiliza para visualizar el nuevo ráster procesado. Por ejemplo, especifique una plantilla de función ráster con la función Mapa de color para cambiar la manera de visualizar la capa ráster procesada. Tenga en cuenta que, si la entrada es un ráster multidimensional, se aplica la función de procesamiento a la división de visualización actual. Si la entrada es una capa de mosaico o dataset de mosaico, se aplica la función de procesamiento al ráster de mosaico con el Primer método para resolver superposiciones. 3. Especificar plantillas para cualquier combinación de las tres funciones. Por ejemplo, tiene un dataset de mosaico con imágenes de Landsat de serie temporal y desea generar una imagen compuesta del máximo NDVI. En Función de elemento, especifique una plantilla de función ráster que contenga la función ráster NDVI. En Función de agregación, especifique una plantilla de función ráster que contenga la función Estadísticas de celdas, con la operación definida como Máximo. En Función de procesamiento, especifique una plantilla de función ráster que contenga la función Mapa de color. Tenga en cuenta que el orden de procesamiento de la función sigue el de los parámetros de entrada. Por ejemplo, la Función de elemento se procesará primero.</div>",
		randomName: "Aleatorio",
		randomSnip: "Crea un ráster con valores de píxel aleatorios dibujados a partir de una distribución pseudoaleatoria. Se admiten varias distribuciones y generadores de números aleatorios.",
		randomDesc: "La función Aleatorio crea un ráster con valores de píxel aleatorios que se puede utilizar en plantillas de función ráster o datasets de mosaico.<div><br/>Aunque muchas funciones operan en uno o varios rásteres de entrada, la función Aleatorio no requiere ningún ráster de entrada. Significa que se comporta más como un dataset ráster que como una función; por ello, debe prestar especial atención al agregarla o eliminarla de la cadena de funciones.</div>",
		shrinkName: "Encoger",
		shrinkSnip: "Encoge las zonas seleccionadas en una cantidad especificada de celdas al reemplazarlas con el valor de la celda que es más frecuente en la vecindad.",
		shrinkDesc: "Con la función global Encoger, puede generalizar, o simplificar, rásteres haciendo más pequeñas determinadas zonas. También puede controlar la cantidad de generalización que se producirá.<div><br/>Las zonas seleccionadas se encogen, o reducen su tamaño, puesto que las celdas zonas circundantes se expanden sobre ellas. Conceptualmente, puede visualizar los Valores de zona seleccionados como zonas en primer plano, mientras que el resto de valores permanecen en zonas en segundo plano. Las celdas de las zonas en primer plano se pueden sustituir por celdas de las zonas en segundo plano. También es probable que se reemplacen las islas finas dentro de una zona, que pueden verse como que comparten límites con la zona.<div><br/>Es posible controlar la cantidad de generalización con el parámetro Número de celdas. De manera predeterminada, este valor es 1, que significa que las zonas seleccionadas se encogerán según la cantidad que corresponda al tamaño de una celda. Para aumentar el grado de generalización, puede especificar un valor mayor para este parámetro. Conceptualmente, es como ejecutar la herramienta tantas veces como el número especificado, siendo los resultados de la ejecución anterior la entrada a la iteración subsiguiente.</div>",
		trendToRGBName: "De tendencia a RGB",
		trendToRGBSnip: "Convierte un ráster de tendencia en un ráster de tres bandas (roja, verde y azul).",
		trendToRGBDesc: "La función De tendencia a RGB convierte un ráster de tendencia en un ráster de tres bandas (roja, verde y azul). El ráster de tendencia se genera a partir de la función ráster Generar tendencia o la función ráster Análisis CCDC.<div><br/>Esta función resulta útil para visualizar los datos de coeficiente del modelo desde las funciones Generar tendencia o Análisis CCDC. Ambas funciones estiman tendencias para valores de píxel cambiantes, pero los resultados de las funciones son difíciles de interpretar directamente.<div><br/>Al igual que muchas funciones ráster, puede que necesite utilizar Ajuste de rango dinámico (DRA) para visualizar mejor los resultados de esta función.</div>",
		landTrendrName: "Análisis LandTrendr",
		landTrendrSnip: "Evalúa los cambios en los valores de píxel a lo largo del tiempo utilizando la detección de tendencias basada en Landsat en el método de alteraciones y recuperación (LandTrendr) y genera un ráster de análisis de cambios que contiene los resultados del modelo.",
		landTrendrDesc: "Esta función ráster solo se puede utilizar como entrada para la función ráster Detectar cambios con análisis de cambios. Para generar una salida de ráster, conecte la función Análisis LandTrendr con la función Detectar cambios con análisis de cambios en una plantilla de función ráster y utilice la plantilla como entrada en la herramienta de geoprocesamiento Generar ráster a partir de la función Ráster. El resultado es un ráster que contiene información sobre el momento en el que cambiaron los valores de píxel.<div><br>La finalidad de esta función de ráster consiste en extraer cambios en una entidad observada, por lo que las imágenes multidimensionales de entrada ideales deben capturar una observación consistente a través del tiempo y no deben incluir interferencia atmosférica o de sensores, nubes ni sombra de nubes. La mejor práctica consiste en utilizar datos que se hayan normalizado y puedan enmascararse usando una banda de control de calidad, por ejemplo productos de Reflectancia de superficie de Colección de Landsat 1 con una máscara de nube.<div><br>La función realiza análisis en una imagen al año, y el número de periodos anuales debe ser igual o mayor que el valor especificado en el parámetro <strong>Cantidad mínima de observaciones</strong>. Se recomienda disponer de al menos seis años de datos.<div><br>Si tuviera datos mensuales, semanales o diarios, se recomienda seleccionar varias imágenes de cada año (preferiblemente de la misma estación), retirar nubes y sombra de nubes, y combinar las imágenes para generar una única imagen que capture adecuadamente la observación. Si se proporcionan datos mensualmente, semanalmente o diariamente como el ráster multidimensional de entrada, la función identificará una división para análisis basada en la fecha más cercana que se proporciona en el parámetro <strong>Fecha de alineación</strong>.<div><br>Una entidad en un paisaje suele requerir tiempo de recuperación con respecto a un cambio no permanente como por ejemplo un incendio forestal o plaga de insectos. Para controlar la velocidad de recuperación reconocida por el modelo, establezca el parámetro Umbral de recuperación. Un segmento distinto no puede tener una velocidad de recuperación que sea mayor de 1/umbral de recuperación.<div><br>La recuperación de un cambio en el paisaje puede producirse en la dirección positiva o negativa. Por ejemplo, cuando un paisaje experimenta pérdida forestal, una serie temporal de valores del índice de vegetación muestra una caída en los valores del índice, y la recuperación muestra un incremento gradual en los valores del índice de vegetación, o una tendencia de recuperación positiva. Especifique la dirección de la tendencia de recuperación con el parámetro <strong>Recuperación con tendencia en aumento</strong>.",
		aggregateMultidimensionalName: "Agregar multidimensional",
		aggregateMultidimensionalSnip: "Combine los datos de variables de ráster multidimensional existentes a lo largo de una dimensión.",
		aggregateMultidimensionalDesc: "La función Agregar multidimensional crea una capa ráster multidimensional combinando los datos de variables ráster multidimensionales existentes a lo largo de una dimensión.<div><br>Utilice el parámetro <strong>Definición de dimensión</strong> para filtrar primero los datos de entrada que desea agregar. Por ejemplo, si tiene 30 años de datos mensuales, pero solo desea crear una capa agregada de los 15 primeros años, puede utilizar el parámetro <strong>Definición de dimensión</strong> para especificar los años que desea incluir en el análisis.<div><br><ul><li>Extraiga los datos de salinidad para el mes de enero durante el periodo de 10 años. Elija <strong>Por valores</strong>, defina <strong>Dimensión</strong> como <strong>StdTime</strong> y defina <strong>Valores</strong> como <strong>Enero</strong>.</li><li>Divida los datos de salinidad en un rango de profundidad de 0 a 150 metros. Elija <strong>Por rangos</strong>, defina <strong>Dimensión</strong> como <strong>StdZ</strong> y defina <strong>Valor mínimo</strong> como <strong>-150</strong> y <strong>Valor máximo</strong> como <strong>0</strong>.</li><li>Extraiga los datos de salinidad de los primeros 10 días de cada mes de enero durante un periodo de 10 años. Elija <strong>Por iteración</strong>, defina <strong>Dimensión</strong> como <strong>StdTime</strong>, defina <strong>Inicio de la primera iteración</strong> y <strong>Fin de la primera iteración</strong> como el inicio y el fin correspondientes del periodo de iteración, defina <strong>Paso</strong> como <strong>1</strong> y defina <strong>Unidad</strong> como <strong>Años</strong>.</li></ul><div><br>Utilice los parámetros <strong>Definición de agregación</strong> para elegir la dimensión que se va a evaluar y el intervalo de agregación mediante una palabra clave, un valor o un rango de valores. Por ejemplo, si cuenta con 30 años de datos de temperatura de la superficie del mar que se han recopilado diariamente y en cada 5 metros de profundidad hasta llegar a los 100 metros, puede utilizar las distintas opciones de intervalos en estos escenarios:<div><br><ul><li>Agregue datos de temperatura diarios en datos mensuales, donde el resultado es un ráster multidimensional con 12 periodos de tiempo, y cada periodo es la agregación de cada mes a lo largo de los años. Elija <strong>Palabra clave de intervalo</strong> y defina la palabra clave como <strong>Recurrente mensualmente</strong>.</li><li>Agregue datos de temperatura diarios en datos mensuales, donde el resultado es un ráster multidimensional con 360 periodos, o bien 12 periodos de tiempo por año (30 años x 12 meses = 360 periodos). Seleccione <strong>Palabra clave de intervalo</strong> y defina la palabra clave como <strong>Mensualmente</strong>.</li><li>Agregue datos de temperatura mensuales en intervalos de 4 meses. Seleccione <strong>Valor de intervalo</strong>, defina <strong>Intervalo de valor</strong> como 4 y defina <strong>Unidad</strong> como <strong>Meses</strong>.</li><li>Agregue datos de temperatura de 0 a 25 metros, después de 25 a 50 metros, por último, de 50 a 100 metros. Seleccione <strong>Rangos de intervalos</strong> y especifique las profundidades mínima y máxima como <strong>0 25; 25 50; 50 100</strong>.</li></ul>",
		mergeRastersName: "Fusionar rásters",
		mergeRastersSnip: "Combina varios datasets de ráster espacialmente, o a través de variables y dimensiones.",
		mergeRastersDesc: "Esta función crea un ráster fusionado a partir de una lista de rásteres. Por ejemplo, si tiene un dataset de mosaico con 30 años de datos de precipitaciones mensuales y otro dataset con 10 años de datos de temperatura mensuales, puede combinarlos en un ráster multidimensional con ambas variables. <div><br>Si los rásteres multidimensionales de entrada contienen diferentes variables, el ráster multidimensional de salida contendrá todas las variables. <div><br>Si los rásteres multidimensionales de entrada contienen diferentes dimensiones o valores de dimensiones, el ráster multidimensional incluirá todas las dimensiones y valores de dimensiones. <div><br>Si los rásteres multidimensionales de entrada contienen las mismas dimensiones y variables pero diferentes extensiones espaciales, el ráster multidimensional de salida contendrá las variables y dimensiones a través de las extensiones espaciales fusionadas.<div><br>Esta función también puede utilizarse si tiene varios rásteres que desea tratar como un único elemento, por ejemplo, para calcular las mismas estadísticas para todos, o al realizar un balance de color para no tener que hacerlo en cada imagen por separado. Resulta útil al trabajar con imágenes almacenadas como teselas separadas debido a restricciones de tamaño de archivos; de esta forma, las teselas se tratarán como parte de la misma imagen.",
		boundaryCleanName: "Refinado de límites",
		boundaryCleanSnip: "Suaviza el límite entre zonas.",
		boundaryCleanDesc: "<p>La función generaliza o simplifica rásteres al suavizar los límites entre zonas. La función proporciona opciones para controlar cómo las celdas de las zonas de la entrada influyen en el suavizado y la cantidad de suavizado que se aplicará. Cada celda de entrada se evalúa utilizando sus ocho vecinos inmediatos.</p><p>El proceso de suavizado primero ordena las celdas vecinas por una prioridad en particular. La prioridad determina qué zona de las celdas vecinas puede reemplazar el valor de la celda de procesamiento en la salida.</p><p>La prioridad puede basarse en el valor o en el tamaño de las zonas. El parámetro <strong>Tipo de ordenación</strong> determina el tipo de ordenación que se debe utilizar. </p><p>La configuración predeterminada <strong>No ordenar</strong> evalúa la prioridad en función del valor de las zonas. Las celdas de zonas con valores más grandes tendrán mayor prioridad para expandirse en zonas con valores más pequeños.</p><p>El tamaño o el área total de las zonas se puede utilizar para ordenar la prioridad. Con el ajuste <strong>Descendente</strong>, las zonas se ordenan por tamaño en orden descendente. Las zonas con áreas totales más grandes tendrán prioridad para expandirse en zonas con áreas más pequeñas. Con la configuración <strong>Ascendente</strong> ocurre lo contrario: las zonas con áreas totales más pequeñas tendrán prioridad para expandirse en zonas con áreas totales más grandes.</p><p>La cantidad de suavizado se controla mediante el parámetro <strong>Ejecutar expansión y contracción dos veces</strong>, que determina el número de veces que se realizará el proceso de expansión y contracción.</p><p>Con esta configuración desactivada, el proceso de expansión y contracción se realiza una vez. Con esta configuración activada, el proceso de expansión y contracción se realiza dos veces, lo que da lugar a un grado adicional de suavizado de los límites de la zona.</p><p>Si los valores de las ocho celdas vecinas son los mismos que la celda de procesamiento, la celda de salida conservará el valor de la celda de entrada.</p>",
		predictUsingRegressionName: "Predecir con regresión",
		predictUsingRegressionSnip: "Calcula un ráster predicho basado en las entradas de datos del ráster y un modelo de regresión. El modelo de regresión es el resultado de la herramienta de geoprocesamiento ráster del <strong>modelo de regresión de árboles aleatorios</strong>.",
		predictUsingRegressionDesc: "<p>El modelo de regresión se define en un archivo de definición de regresión de Esri (.ecd). Contiene toda la información de un dataset específico o un conjunto de datasets, así como el modelo de regresión, y se genera con la herramienta de geoprocesamiento ráster <strong>Entrenar modelo de regresión de árboles aleatorios</strong>.</p><p>El resultado puede ser una sola banda, una multibanda, un ráster multidimensional o una lista de estos tipos. Los tipos de los rásteres de resultados deben ser del mismo tipo de ráster entrenado por el modelo de regresión.</p><ul><li>Cuando la entrada es un ráster multibanda, se trata a cada banda como un predictor variable. Las bandas deben tener el mismo orden que la entrada de multibanda para la herramienta de entrenamiento del modelo de regresión.</li><li>Cuando la entrada es un ráster multidimensional, cada variable se trata como una variable de indicador, y la variable debe ser de banda única y debe tener una dimensión de tiempo. El orden y los nombres de las variables deben ser los mismos que los de entrada cuando se entrenó el modelo de regresión. El resultado es un ráster multidimensional.</li><li>El resultado puede ser una lista de elementos. El número de elementos y el orden de los elementos deben coincidir con los de la entrada cuando se entrenó el modelo de regresión.</li></ul>",
		dimensionalMovingStatisticsName: "Estadísticas móviles dimensionales",
		dimensionalMovingStatisticsSnip: "Calcula estadísticas en una ventana móvil de datos multidimensionales a lo largo de una dimensión especificada.",
		dimensionalMovingStatisticsDesc: "<p>La función Estadística móvil dimensional calcula varias estadísticas en una ventana predefinida correspondiente a todos los valores de dimensión a lo largo de una dimensión. Esta función toma una capa ráster multidimensional como entrada y crea una capa ráster multidimensional como salida que tienen el mismo tamaño dimensional que la capa de entrada.</p><p>Puede especificar una dimensión para la que se tienen en cuenta los valores de dimensión durante el cálculo. De forma predeterminada, se calcula a lo largo de la primera dimensión no espacial. También puede especificar un tamaño de ventana especificando los parámetros Ventana regresiva y Ventana progresiva.</p><p>Cuando Tipo de estadísticas se configura en Percentil, los parámetros Valor de percentil y Tipo de interpolación de percentil pasan a estar disponibles. Puede utilizar estos parámetros para especificar el percentil para calcular y elegir respectivamente el tipo de interpolación que se va a utilizar. Cuando Tipo de estadística se configura en Media circular, el parámetro Valor de envoltura circular pasa a estar disponible. El valor de envoltura circular se utiliza para convertir un valor lineal al rango de una media circular determinada.</p>",
		terrainFlattenFunctionName: "Aplanamiento del terreno",
		terrainFlattenFunctionSnip: "Corrige los datos de entrada de radar de apertura sintética (SAR) para detectar distorsiones radiométricas debidas a la topografía.",
		terrainFlattenFunctionDesc: "<p>La función ráster Aplanamiento del terreno corrige los datos de entrada de radar de apertura sintética (SAR) para detectar distorsiones radiométricas debidas a la topografía.</p><p>Los datos de radar de entrada se deben calibrar primero en beta cero. Utilice la herramienta Aplicar calibración radiométrica para calibrar los datos del radar en beta cero.</p><p>Si el DEM de entrada no abarca todo el dataset de SAR, la herramienta generará valores NoData para los píxeles fuera de la extensión del DEM para las salidas de gamma cero, sigma cero, área de dispersión y distorsión geométrica. Para la salida de máscara de distorsión geométrica, la herramienta generará valores no determinados para los píxeles fuera de la extensión del DEM.</p><p>El DEM de entrada debe estar en el sistema de coordenadas geográficas WGS 1984 (EPSG:4326).</p>",
		createColorCompositeFunctionName: "Crear composición de color",
		createColorCompositeFunctionSnip: "Crea un ráster de tres bandas a partir de un dataset ráster multibanda en el que cada banda puede utilizar un cálculo algebraico en función del álgebra de bandas.",
		createColorCompositeFunctionDesc: "<p>La función ráster Crear composición de color crea un ráster de tres bandas a partir de un dataset ráster multibanda en el que cada banda puede utilizar un cálculo algebraico en función del álgebra de bandas.</p><p>Al definir un algoritmo de aritmética de banda, puede introducir una fórmula algebraica de línea única para cada expresión con el fin de crear una salida multibanda. Los operadores admitidos son unarios: suma (+), resta (-), multiplicación (*) y división (/).</p><p>Al utilizar un Id. de banda en una expresión, identifique la banda agregando el prefijo B o b al número de banda.</p><p>Una combinación de bandas habitual utilizada para radar de apertura sintética (SAR) en unidades lineales es VV para rojo, VH para verde y VV/VH para azul. Si los datos de entrada están en decibelios, la combinación de bandas debe ser VV para rojo, VH para verde y VV-VH para azul.</p>",
		surfaceParametersName: "Parámetros de superficie",
		surfaceParametersSnip: "Determina los parámetros de un ráster de superficie como la orientación, la pendiente y varios tipos de curvaturas utilizando métodos geodésicos.",
		surfaceParametersDesc: "<p>La función Parámetros de superficie determina los parámetros de un ráster de superficie como la orientación, la pendiente y varios tipos de curvaturas utilizando métodos geodésicos.</p><p>Esta función se puede utilizar para las siguientes aplicaciones:</p><ul><li>Calcular la orientación y la pendiente utilizando métodos geodésicos.</li><li>Calcular distintos tipos de curvaturas a partir de un ráster de superficie de entrada, por ejemplo, <strong>Curvatura tangencial (curva de nivel normal),</strong> que caracteriza la convergencia topográfica y la divergencia del flujo por la superficie.</li></ul>",
		leastCostCorridorName: "Corredor de menor coste",
		leastCostCorridorSnip: "Calcula la suma de dos rásteres de coste de distancia acumulativo con la opción de aplicar un umbral basado en un porcentaje o un coste acumulativo.",
		leastCostCorridorDesc: "<p>Los rásteres de entrada deben ser la salida de rásteres de acumulación de distancia y dirección hacia atrás desde la función <strong>Acumulación de distancia</strong> o <strong>Asignación de distancia</strong>. Deben basarse en el coste-distancia y se debe utilizar la misma configuración de parámetros al crear las capas para cada origen. En la creación de estos rásteres no deben utilizarse parámetros que dependan de la direccionalidad (factor horizontal, factor vertical y dirección del viaje).</p><p>Los valores del ráster de corredor de salida son la suma del coste acumulativo para alcanzar una ubicación determinada con las mismas unidades que los rásteres de coste-distancia acumulativo de entrada.</p><p>Si un valor de <strong>Umbral</strong> especificado es mayor que el coste acumulativo máximo cuando se suman los dos rásteres de acumulación de distancia, el ráster de corredor de salida abarcará la misma área que los rásteres acumulativos de entrada.</p><p>Si un valor de umbral especificado es menor que el valor mínimo del ráster de corredor, se devuelve un mensaje de advertencia y el ráster de salida estará vacío.</p><p>El ráster de corredor de salida puede contener celdas con costes acumulativos ligeramente mayores que el valor de umbral. Procede de los rásteres de dirección hacia atrás que utilizan celdas que tienen asignados costes ligeramente mayores que el umbral para conectar celdas desconectadas al corredor.</p>",
		geometricMedianName: "Mediana geométrica",
		geometricMedianSnip: "La función Mediana geométrica calcula la mediana geométrica en los píxeles de una serie temporal de imágenes multibanda.",
		geometricMedianDesc: "<p>Esta función reduce el ruido y los valores atípicos en imágenes de serie temporal calculando un píxel de mediana geométrica para cada matriz de píxeles en la pila de imágenes. El algoritmo mantiene las relaciones espectrales entre las bandas del espectro de píxeles, de modo que la salida se puede utilizar en análisis, como los índices de vegetación.</p><p>Las nubes y sombras deben enmascararse con la banda de QA del dataset antes de aplicar esta función.</p><p>Si la imagen de entrada es de punto flotante, como una reflectancia de superficie con valores entre 0 y 1, un valor de épsilon de 0,001 debería producir resultados de calidad.</p>"
	},
	rfxArgs: {
		rasterName: "Calculadora ráster",
		colorSchemeTypeName: "Tipo de esquema de colores",
		colormapName: "Mapa de color",
		colormapNameName: "Nombre de mapa de color",
		colorRampName: "Rampa de color",
		contrastOffsetName: "Desplazamiento de contraste",
		brightnessOffsetName: "Desplazamiento de brillo",
		methodName: "Método",
		bandNamesName: "Nombres de banda",
		bandWavelengthsName: "Longitudes de onda de bandas",
		bandIdsName: "Id. de banda",
		missingBandActionName: "Acción de banda ausente",
		conversionParametersName: "Parámetros de conversión",
		hillshadeTypeName: "Tipo sombreado",
		azimuthName: "Acimut",
		altitudeName: "Altitud",
		slopeTypeName: "Escalado",
		zFactorName: "Factor Z",
		PSPowerName: "Potencia de tamaño de píxel",
		PSZFactorName: "Factor de tamaño de píxeles",
		removeEdgeEffectName: "Deshabilitar interpolación de píxeles de borde predeterminada",
		fromUnitName: "Unidad de origen",
		toUnitName: "Unidad de destino",
		rasterTypeName: "Tipo",
		minName: "Mínimo de salida",
		maxName: "Máximo de salida",
		minPercentName: "Mínimo de porcentaje de recorte",
		maxPercentName: "Máximo de porcentaje de recorte",
		numberOfStandardDeviationName: "Número de desviaciones estándar",
		sigmoidStrengthLevelName: "Nivel de fuerza sigmoidea",
		estimateStatsHistogramName: "Estimar estadísticas",
		DRAName: "Ajuste de rango dinámico",
		statisticsName: "Estadísticas",
		histogramsName: "Histogramas",
		statisticsHistogramName: "Definir estadísticas e histograma",
		computeGammaName: "Gamma automático",
		useGammaName: "Usar gamma",
		gammaName: "Gamma",
		inputNamesName: "Nombres",
		expressionName: "Expresión",
		cellsizeTypeName: "Tipo de tamaño de celda",
		extentTypeName: "Tipo de extensión",
		classifierDefinitionFileName: "Archivo de definición de entrada",
		raster1Name: "Ráster 1",
		raster2Name: "Ráster 2",
		raster3Name: "Ráster 3",
		trueRasterName: "Ráster verdadero",
		falseRasterName: "Ráster falso",
		noDataInterpretationName: "Interpretación de NoData",
		noDataValuesName: "Valores de NoData",
		includedRangesName: "Rangos incluidos",
		curvatureTypeName: "Tipo de curvatura",
		rastersName: "Rásteres",
		attributeTableName: "Tabla",
		attributeTableTypeName: "Tipo de tabla",
		rowsName: "Número de filas",
		columnsName: "Número de columnas",
		kernelName: "Kernel",
		mirrorEdgesName: "Reflejar bordes",
		influencesName: "Influencias",
		fieldsName: "Campos",
		remapsName: "Volver a representar la tabla",
		evalFromName: "Escala de evaluación inicial",
		evalToName: "Escala de evaluación final",
		weightsName: "Pesos",
		DEMName: "DEM",
		shortRangeIDWRadiusName: "Radio de IDW de corto alcance",
		maxVoidWidthName: "Ancho máx. de vacío",
		sigmaGaussianName: "Alisado adaptable",
		contourTypeName: "Tipo de curva de nivel",
		zBaseName: "Base Z",
		numberOfContoursName: "Cantidad de curvas de nivel",
		contourIntervalName: "Intervalo de curvas de nivel",
		nthContourLineInBoldName: "Línea de contorno N en negrita",
		featureClassName: "Entidades de entrada",
		classIndexFieldName: "Campo",
		resolveOverlapMethodName: "Método Resolver superposición",
		resamplingTypeName: "Tipo de remuestreo",
		inputCellsizeName: "Tamaño de celda de entrada",
		outputCellsizeName: "Tamaño de celda de salida",
		pointFeatureClassName: "Puntos iniciales",
		maxGrowthRadiusFieldName: "Campo de radio de crecimiento máximo",
		similarityThresholdFieldName: "Campo de umbral de similitud",
		fillValueFieldName: "Campo de valor de relleno",
		spectralDetailName: "Detalle espectral [1..20]",
		spatialDetailName: "Detalle espacial [1..20]",
		minNumPixelsPerSegmentName: "Tamaño de segmento mínimo en píxeles",
		boundariesOnlyName: "Solo límites de segmento",
		statisticsTypeName: "Tipo de estadísticas",
		fillNoDataOnlyName: "Rellenar solo píxeles NoData",
		inputDataTypeName: "Tipo de datos de entrada",
		angleReferenceSystemName: "Sistema de referencia angular",
		outputDataTypeName: "Tipo de Datos de Salida",
		inputSamplePointFeatureClassName: "Muestras de entrada",
		valueFieldName: "Campo de valor",
		rasterInfoName: "Información de ráster",
		interpolationMethodName: "Método de interpolación",
		radiusName: "Radio",
		radianceGainValuesName: "Ganancia de radiancia",
		radianceBiasValuesName: "Sesgo de radiancia",
		reflectedGainValuesName: "Ganancia de reflectancia",
		reflectedBiasValuesName: "Sesgo de reflectancia",
		sunElevationName: "Elevación del sol (grados)",
		albedoName: "Albedo",
		scaleFactorName: "Factor de escala",
		offsetName: "Desplazamiento",
		thresholdTypeName: "Tipo de umbral",
		thresholdsName: "Umbrales",
		undefinedClassName: "Clase sin definir",
		minValueName: "Mín.",
		maxValueName: "Máx.",
		operationName: "Operación",
		clippingTypeName: "Tipo de clipping",
		clippingGeometryName: "Geometría/ráster de recorte",
		extentName: "Extensión de salida",
		useInputFeatureGeometryName: "Utilizar entidades de entrada para recortar geometría",
		remapDefinitionTypeName: "Tipo de definición de nueva representación cartográfica",
		inputRangeName: "Rangos de entrada",
		outputValuesName: "Valores de salida",
		noDataRangeName: "Rangos de NoData",
		inputFieldName: "Campo de entrada",
		outputFieldName: "Campo de salida",
		inputMaxFieldName: "Campo de máx. de entrada (opcional)",
		remapTableTypeName: "Tipo de tabla de nueva representación cartográfica",
		allowUnmatchedName: "Permitir valores de píxel sin concordancia",
		changeMissingValuesToNoDataName: "Cambiar los valores ausentes por NoData",
		visibleBandIDName: "Id. de banda visible",
		infraredBandIDName: "Id. de banda infrarroja",
		scientificOutputName: "Salida científica",
		bandIndexesName: "Índices de banda",
		constantName: "Constante",
		weightName: "Peso",
		minimumName: "Mínimo",
		maximumName: "Máximo",
		sourceDataName: "Ráster de origen",
		sourceFieldName: "Campo de origen",
		costRasterName: "Ráster de costes",
		maxDistanceName: "Distancia máxima",
		valueRasterName: "Ráster de valor",
		costMultiplierName: "Multiplicador para aplicar a los costes",
		startCostName: "Coste inicial",
		accumCostResistanceRateName: "Tasa de resistencia del coste acumulado",
		capacityName: "Capacidad",
		travelDirectionName: "Dirección del viaje",
		cellSizeName: "Tamaño de celda",
		populationFieldName: "Campo de población",
		areaUnitsName: "Unidades de área",
		outputValueTypeName: "Valores de celda de salida",
		barriersName: "Barreras de entrada",
		destinationDataName: "Ráster de destino",
		destinationFieldName: "Campo de destino",
		pathTypeName: "Tipo de ruta",
		observerFeaturesName: "Entidades de observador",
		analysisMethodName: "Método de análisis",
		analysisTypeName: "Tipo de análisis",
		verticalErrorName: "Error vertical",
		refractivityCoefficientName: "Coeficiente de refracción",
		surfaceOffsetName: "Desplazamiento de superficie",
		observerElevationName: "Elevación de observador",
		observerOffsetName: "Desplazamiento de observador",
		innerRadiusName: "Radio interno",
		innerRadiusIs3DDistanceName: "El radio interno es una distancia 3D",
		outerRadiusName: "Radio externo",
		outerRadiusIs3DDistanceName: "El radio externo es una distancia 3D",
		horizontalStartAngleName: "Ángulo de inicio horizontal",
		horizontalEndAngleName: "Ángulo de finalización horizontal",
		verticalUpperAngleName: "Ángulo superior vertical",
		verticalLowerAngleName: "Ángulo inferior vertical",
		zoneDataName: "Ráster de zona",
		zoneFieldName: "Campo de zona",
		ignoreNoDataName: "Ignorar los NoData en los cálculos",
		temperatureRasterName: "Ráster de temperatura",
		inTemperatureUnitsName: "Unidades de temperatura",
		outHeatIndexTemperatureUnitsName: "Unidades de índice de calor",
		relativeHumidityRasterName: "Ráster de humedad relativa",
		outWindChillTemperatureUnitsName: "Unidades de sensación térmica",
		windSpeedRasterName: "Ráster de velocidad del viento",
		inWindSpeedUnitsName: "Unidades de velocidad del viento",
		valueName: "Valor",
		propertyName: "Nombre de Propiedades",
		jsonName: "JSON de metadatos",
		zoneTableName: "Tabla de atributos zonales",
		attributeFieldNames: "Nombres de campo de atributo",
		backgroundName: "Valor de fondo",
		whereClauseName: "Cláusula Where",
		minimumValueFieldName: "Nombre de campo de valor mínimo",
		maximumValueFieldName: "Nombre de campo de valor máximo",
		outValueFieldName: "Nombre de campo de valor de salida",
		defaultValueName: "Valor de salida predeterminado",
		conversionMatrixName: "Matriz de conversión",
		IsPseudoColorOutputName: "Es una salida en pseudocolor",
		unmappedAsRandomColorName: "Asignar color aleatoriamente a píxeles no asignados",
		distanceMethodName: "Método de distancia",
		flowDirRasterName: "Ráster de dirección de flujo",
		pourPointName: "Ráster de puntos de fluidez",
		pourPointFieldName: "Campo de punto de fluidez",
		constantZName: "Z constante",
		zOffsetName: "Desplazamiento Z",
		geoIdName: "Geoide",
		calibrationTypeName: "Tipo de calibración",
		filterTypeName: "Tipo de filtro",
		filterSizeName: "Tamaño de filtro",
		noiseModelName: "Modelo de ruido",
		noiseVarianceName: "Varianza de ruido",
		additiveNoiseMeanName: "Media de ruido aditivo",
		multiplicativeNoiseMeanName: "Media de ruido multiplicativo",
		numberofLooksName: "Cantidad de aspectos",
		dampingFactorName: "Factor de vaciado",
		maskRasterName: "Ráster de máscara",
		nibbleValuesName: "Utilizar los valores NoData si son los del vecino más próximo (nearest neighbor)",
		nibbleNoDataName: "Celdas NoData de Nibble",
		zLimitName: "Límite Z",
		flowDirectionTypeName: "Tipo de dirección de flujo",
		weightRasterName: "Ráster de peso",
		forceEdgeName: "Forzar todas las celdas de eje para que se desplacen hacia fuera",
		streamRasterName: "Ráster de curso de agua",
		surfaceRasterName: "Ráster de superficie",
		conversionType: "Tipo de conversión",
		distanceRaster1: "Ráster de distancia 1",
		distanceRaster2: "Ráster de distancia 2",
		costDistanceRaster: "Ráster de coste-distancia",
		costBacklinkRaster: "Ráster de vínculo de menor coste",
		overridesName: "Invalidaciones",
		fieldName: "Campo",
		signatureFileOrUrl: "Archivo de firma o URL",
		redName: "Rojo",
		greenName: "Verde",
		blueName: "Azul",
		infraredName: "Infrarrojo",
		panchromaticName: "Pancromático",
		multispectralName: "Multiespectral",
		pansharpeningType: "Tipo de refinado pancromático",
		sensorName: "Sensor",
		spatialReferenceName: "Referencia espacial",
		xCellsizeName: "Tamaño de celda X",
		yCellsizeName: "Tamaño de celda Y",
		xOriginName: "Punto de registro X",
		yOriginName: "Punto de registro Y",
		percentileName: "Valor de percentil",
		neighborhoodType: "Tipo de vecindad",
		widthName: "Ancho",
		heightName: "Altura",
		startAngleName: "Ángulo inicial",
		endAngleName: "Ángulo final",
		neighborhoodValues: "Valores vecinos",
		horizontalRaster: "Ráster horizontal",
		horizontalFactor: "Factores horizontales",
		verticalRaster: "Ráster vertical",
		verticalFactor: "Factor vertical",
		streamRaster: "Ráster de curso de agua",
		flowDirRaster: "Ráster de dirección de flujo",
		numberNeighborCells: "Cantidad de celdas vecinas",
		zoneConnectivity: "Conectividad de zona",
		addLinkBehavior: "Agregar vínculo",
		excludedValue: "Valor excluido",
		constantFillCheck: "Generar ráster de relleno a partir de constante",
		fillRaster: "Ráster de relleno",
		constantFillValue: "Valor constante",
		inputBitPositions: "Bit de entrada",
		outputBitPositions: "Bit de salida",
		distanceTypeName: "Tipo de distancia",
		barrierDataName: "Barreras de ráster",
		pourPointDataName: "Ráster de puntos de fluidez",
		accumulationRasterName: "Ráster de acumulación de flujo",
		snapDistanceName: "Distancia de alineación",
		orderMethodName: "Método de ordenación",
		directionMeasurementName: "Dirección de medición",
		processAsMultiband: "Procesar como multibanda",
		processMultidimensional: "Procesar como multidimensional",
		forceFlowDirectionConvention: "Forzar convención de dirección del flujo para ráster de vínculo",
		initialAccumulation: "Acumulación inicial",
		maximumAccumulation: "Acumulación máxima",
		sourceLocationBands: "Generar fila y columna de origen como bandas adicionales en la salida",
		backDirectionBand: "Generar dirección hacia atrás como banda adicional en la salida",
		numberOfCells: "Número de celdas",
		zoneValues: "Valores de zona",
		shrinkMethod: "Método Encoger",
		expandMethod: "Método de expansión",
		inputSpectralProfileType: "Tipo de perfil espectral",
		spectralProfileFileName: "Perfil espectral",
		trainingFeatureFileName: "Entidad de entrenamiento",
		nonNegative: "No negativo",
		sumToOne: "Sumar uno",
		randomDistribution: "Distribución",
		meanName: "Valor medio",
		probabilityName: "Probabilidad",
		alphaName: "Alfa",
		betaName: "Beta",
		rName: "r",
		nName: "N",
		seed: "Valor de inicialización",
		randomNumberGenerator: "Generador de números aleatorios",
		cellFactor: "Factor de celda",
		aggregationType: "Técnica de agregación",
		extentHandling: "Ampliar la extensión si es necesario",
		trendAnalysisDimensionName: "Nombre de dimensión",
		trendAnalysisType: "Tipo de tendencia",
		harmonicFrequency: "Frecuencia armónica",
		polynomialOrder: "Orden polinómico",
		cycleLengthName: "Longitud del ciclo",
		trendAnalysisRMSE: "RMSE",
		trendAnalysisR2: "R cuadrado",
		trendAnalysisSlopePValue: "Valor P del coeficiente de pendiente",
		trendAnalysisSeasonalPeriod: "Periodo estacional",
		cycleUnitName: "Unidad de ciclo",
		predictDimensionValues: "Valores",
		dimensionDefinitionType: "Definición de dimensión",
		predictDimensionStart: "Comenzar",
		predictDimensionEnd: "Fin",
		predictDimensionInterval: "Intervalo de valor",
		dimensionUnit: "Unidad",
		interpolationCellsizeName: "Tamaño de celda de interpolación",
		variableName: "Variables",
		dimensionlessName: "Sin dimensión",
		mdimDefinition: "Definición de dimensión",
		dimensionName: "Dimensión",
		iterationStart: "Inicio de la primera iteración",
		iterationEnd: "Final de la primera iteración",
		intervalStart: "Inicio de intervalo",
		intervalEnd: "Fin de intervalo",
		stepName: "Paso",
		rangesName: "Rangos",
		minValue: "Valor mínimo",
		maxValue: "Valor máximo",
		changeAnalysisRasterName: "Ráster de análisis de cambios",
		changeTypeName: "Cambiar tipo",
		segmentDate: "Fecha del segmento",
		changeDirectionName: "Cambiar dirección",
		maxNumChangesName: "Número máximo de cambios",
		filterByYear: "Filtrar por año",
		minimumYear: "Valor Mínimo",
		maximumYear: "Valor Máximo",
		filterByDuration: "Filtrar por duración",
		minimumDuration: "Duración mínima",
		maximumDuration: "Duración máxima",
		filterByMagnitude: "Filtrar por magnitud",
		minimumMagnitude: "Magnitud mínima",
		maximumMagnitude: "Magnitud máxima",
		filterByStartValue: "Filtrar por valor de inicio",
		minimumStartValue: "Valor de inicio mínimo",
		maximumStartValue: "Valor de inicio máximo",
		filterByEndValue: "Filtrar por valor final",
		minimumEndValue: "Valor final mínimo",
		maximumEndValue: "Valor final máximo",
		modelTypeName: "Tipo de modelo",
		fromRasterName: "De ráster",
		toRasterName: "A ráster",
		computeChangeMethod: "Método de cálculo del cambio",
		fromClassValues: "Valores de clase desde (Ejemplo: 2 5)",
		toClassValues: "Valores de clase hasta (Ejemplo: 2 5)",
		keepMethod: "Método de filtrado",
		useColorMethod: "Definir colores de transición",
		detectChangeBands: "Bandas para detectar cambios (empezar en 0)",
		tmaskBands: "Bandas para el enmascaramiento temporal (empezar en 0)",
		chiSquaredThreshold: "Umbral de chi cuadrado para detectar cambios",
		minAnomaly: "Observaciones de anomalías consecutivas mínimas",
		updatingFrequency: "Actualizando la frecuencia de ajuste (en años)",
		distanceAccumulationRasterName: "Ráster de acumulación de distancia",
		costBackdirectionRasterName: "Ráster de dirección de flujo o dirección hacia atrás",
		rasterCollectionName: "Colección de rásteres",
		itemFunctionName: "Función de elemento",
		aggregationFunctionName: "Función de consolidación",
		processingFunctionName: "Función de procesamiento",
		aggregationDefinitionName: "Definición de agregación",
		queryGeometryName: "Geometría de consultas",
		factorFunctionZeroFactor: "Factor cero",
		factorFunctionCutAngle: "Ángulo de corte",
		factorFunctionSideFactor: "Factor de lado",
		factorFunctionSlope: "Pendiente",
		factorFunctionLowCutAngle: "Ángulo de corte bajo",
		factorFunctionHighCutAngle: "Ángulo de corte alto",
		factorFunctionCosPower: "Potencia de coseno",
		factorFunctionSecPower: "Potencia de secante",
		factorFunctionTablePath: "Ruta de tabla",
		processingBand: "Banda de procesamiento",
		processingBandName: "Nombre de la banda de procesamiento",
		snappingDate: "Fecha de alineación",
		maxNumSegments: "Número máximo de segmentos",
		vertexCountOvershoot: "Arco colgante de conteo de vértices",
		spikeThreshold: "Umbral de pico",
		recoveryThreshold: "Umbral de recuperación",
		minNumObs: "Cantidad mínima de observaciones",
		pValueThreshold: "Umbral de valor P",
		bestModelProportion: "Mejor proporción de modelo",
		preventOneYearRecovery: "Prevenir recuperación de un año",
		recoveryIncreaseTrend: "Recuperación con tendencia en aumento",
		outputOtherBands: "Salida otras bandas",
		sortType: "Tipo de ordenación",
		numberOfRuns: "Ejecutar la expansión y el acortamiento en ambos sentidos",
		percentileValue: "Valor de percentil",
		percentileInterpolationType: "Tipo de interpolación percentil",
		rasterInfoProperty: "Propiedad",
		rasterInfoValue: "Valor",
		rasterInfoColumns: "Columnas",
		rasterInfoRows: "Filas",
		rasterInfoBandCount: "Número de bandas",
		rasterInfoPixelSizeX: "Tamaño de celda X",
		rasterInfoPixelSizeY: "Tamaño de celda Y",
		rasterInfoPixelType: "Tipo de píxel",
		rasterExtentTop: "Arriba",
		rasterExtentBottom: "Abajo",
		rasterExtentLeft: "Izquierda",
		rasterExtentRight: "Derecha",
		rasterStatisticsNotCalculated: "No se han calculado las estadísticas.",
		spatialReferenceProjection: "Proyección",
		spatialReferenceWkid: "WKID",
		spatialReferenceLatestWkid: "WKID anterior",
		spatialReferenceWkt: "WKT",
		spatialReferenceVcsWkid: "VCSWKID",
		spatialReferenceLatestVcsWkid: "VCSWKID anterior",
		spatialReferenceAuthority: "Autoridad",
		spatialReferenceLinearUnit: "Unidad lineal",
		spatialReferenceAngularUnit: "Unidad angular",
		spatialReferenceFalseEasting: "Falso Este",
		spatialReferenceFalseNorthing: "Falso Norte",
		spatialReferenceCentralMeridian: "Meridiano central",
		spatialReferencePrimeMeridian: "Meridiano base",
		spatialReferenceStandardParallel1: "Paralelo estándar 1",
		spatialReferenceStandardParallel2: "Paralelo estándar 2",
		spatialReferenceLatitudeOfOrigin: "Latitud de origen",
		spatialReferenceAuxiliarySphereType: "Tipo de esfera auxiliar",
		spatialReferenceDatum: "Datum",
		spatialReferenceSpheroid: "Esferoide",
		spatialReferenceSemimajorAxis: "Semieje mayor",
		spatialReferenceSemiminorAxis: "Semieje menor",
		spatialReferenceInverseFlattening: "Aplanamiento inverso",
		inputDefinitionFileName: "Archivo de definición de entrada",
		deleteName: "Eliminar",
		addVariableName: "Agregar variable",
		maxNumPixelsPerSegment: "Tamaño de segmento máximo en píxeles",
		forwardWindowName: "Ventana de avance",
		backwardWindowName: "Ventana de retroceso",
		noDataHandlingName: "Manejo de NoData",
		circularWrapValueName: "Valor de envoltura circular",
		fromClassNameFieldName: "Nombre de campo para nombres de clase en Desde ráster",
		toClassNameFieldName: "Nombre de campo para nombres de clase en Hasta ráster",
		targetRasterName: "Ráster de destino",
		circularWrapValue: "Valor de envoltura circular",
		bandIndexesR: "Expresión roja",
		bandIndexesG: "Expresión verde",
		bandIndexesB: "Expresión azul",
		exampleName: "Ejemplo",
		inputName: "Entrada",
		outputName: "Salida",
		optionalName: "Opcional",
		browseDefinitionFile: "Examinar archivo de definición",
		selectDefinitionFile: "Seleccionar archivo de definición de entrada",
		inputDefinitionURL: "URL de archivo de definición de entrada",
		enterDefinitionFileURL: "Introducir la URL del archivo de definición",
		browseXMLFile: "Examinar archivo XML",
		selectStatsFile: "Seleccionar archivo de estadísticas e histogramas",
		enterXMLFileURL: "Introducir la URL del archivo XML",
		xmlFileURL: "URL de archivo XML",
		circularCalculation: "Calcular estadísticas circulares",
		localSurfaceType: "Tipo de superficie local",
		surfaceParameterType: "Tipo de parámetro",
		neighborhoodDistance: "Distancia de vecindad",
		useAdaptiveNeighborhood: "Utilizar vecindad adaptable",
		outputSlopeType: "Medida de pendiente de salida",
		projectAzimuths: "Acimuts geodésicos del proyecto",
		useEquatorialAspect: "Utilizar orientación ecuatorial",
		zUnit: "Unidad z",
		analysisMask: "Máscara de análisis",
		stdDeviation: "Desviación estándar",
		"true": "Verdadero",
		"false": "Falso",
		costDistanceRaster1: "Ráster de distancia de coste acumulativo de entrada 1",
		costDistanceRaster2: "Ráster de distancia de coste acumulativo de entrada 2",
		threshold: "Umbral",
		thresholdMethod: "Método de umbral",
		directionRaster1: "Ráster de dirección hacia atrás de entrada 1",
		directionRaster2: "Ráster de dirección hacia atrás de entrada 2",
		maxIterations: "Número máximo de iteraciones",
		epsilon: "Ípsilon"
	},
	enumLabels: {
		attributeTableTypeManual: "Manual",
		attributeTableTypeExternal: "Externo",
		clrSchemeTypeColormap: "Mapa de color",
		clrSchemeTypeColorRamp: "Rampa de color",
		colormapTypeElevation: "Elevación",
		colormapTypeGray: "Gris",
		colormapTypeNDVI: "NDVI",
		colormapTypeNDVI2: "NDVI2",
		colormapTypeNDVI3: "NDVI3",
		colormapTypeRandom: "Aleatorio",
		none: "Ninguna",
		slopeTypeAdjusted: "Ajustado",
		slopeTypeDegree: "Grado",
		slopeTypePercentRise: "Elevación en porcentaje",
		slopeTypeScaled: "Escalado",
		stretchTypeMinMax: "MinMax",
		stretchTypePercentMinMax: "PercentMinMax",
		stretchTypeSigmoid: "Sigmoideo",
		stretchTypeStdDev: "StdDev",
		hillshadeTypeSimple: "Tradicional",
		hillshadeTypeMultidirectional: "Multidireccional",
		bandComboByNames: "Nombres de banda",
		bandComboByWavelength: "Longitudes de onda de bandas",
		bandComboByIDs: "Id. de banda",
		missingBandActionBestMatch: "Mejor coincidencia",
		missingBandActionFail: "Error",
		unitTypeCelsius: "Centígrados",
		unitTypeCentimeters: "Centímetros",
		unitTypeDecimeters: "Decímetros",
		unitTypeFahrenheit: "Fahrenheit",
		unitTypeFeet: "Pies",
		unitTypeFeetPerSec: "Pies por segundo (pies/s)",
		unitTypeInches: "Pulgadas",
		unitTypeKelvin: "Kelvin",
		unitTypeKilometers: "Kilómetros",
		unitTypeKmsPerHour: "Kilómetros por hora (km/h)",
		unitTypeKnots: "Nudos (kn)",
		unitTypeMeters: "Metros",
		unitTypeMetersPerSec: "Metros por segundo (m/s)",
		unitTypeMiles: "Millas",
		unitTypeMilesPerHour: "Millas por hora (mph)",
		unitTypeMillimeters: "Milímetros",
		unitTypeNauticalMiles: "Millas náuticas",
		unitTypeYards: "Yardas",
		unitTypeDecimalDegrees: "Grados decimales",
		unitTypePoints: "Puntos",
		unitTypeUnknown: "Desconocido",
		unitTypeSqMapUnits: "Unidades de mapa Cuadradas",
		unitTypeSqMiles: "Millas cuadradas",
		unitTypeSqKms: "Kilómetros cuadrados",
		unitTypeAcres: "Acres",
		unitTypeHectares: "Hectáreas",
		unitTypeSqYards: "Yardas cuadradas",
		unitTypeSqFt: "Pies cuadrados",
		unitTypeSqInches: "Pulgadas Cuadradas",
		unitTypeSqMts: "Metros cuadrados",
		unitTypeSqCms: "Centímetros Cuadrados",
		unitTypeSqMms: "Milímetros Cuadrados",
		cellsizeTypeFirst: "Primero de",
		cellsizeTypeMin: "Mínimo de",
		cellsizeTypeMax: "Máximo de",
		cellsizeTypeMean: "Valor medio de",
		cellsizeTypeLast: "Último de",
		extentTypeFirst: "Primero de",
		extentTypeIntersection: "Intersección de",
		extentTypeUnion: "Combinación de",
		extentTypeLast: "Último de",
		noDataInterpretAny: "Hacer coincidir con cualquiera",
		noDataInterpretAll: "Hacer coincidir con todos",
		curvatureTypeStandard: "Standard",
		curvatureTypeProfile: "Perfil",
		curvatureTypePlanform: "Plano",
		filterTypeLineDetectionHorizontal: "Horizontal de detección de línea",
		filterTypeLineDetectionVertical: "Vertical de detección de línea",
		filterTypeLineDetectionLeftDiagonal: "Diagonal izquierda de detección de línea",
		filterTypeLineDetectionRightDiagonal: "Diagonal derecha de detección de línea",
		filterTypeGradientNorth: "Gradiente norte",
		filterTypeGradientWest: "Gradiente oeste",
		filterTypeGradientEast: "Gradiente este",
		filterTypeGradientSouth: "Gradiente sur",
		filterTypeGradientNorthEast: "Gradiente noreste",
		filterTypeGradientNorthWest: "Gradiente noroeste",
		filterTypeSmoothArithmeticMean: "Suavizar valor medio aritmético",
		filterTypeSmoothing3x3: "Suavizado 3x3",
		filterTypeSmoothing5x5: "Suavizado 5x5",
		filterTypeSharpening3x3: "Nitidez 3x3",
		filterTypeSharpening5x5: "Nitidez 5x5",
		filterTypeLaplacian3x3: "Laplaciano 3x3",
		filterTypeLaplacian5x5: "Laplaciano 5x5",
		filterTypeSobelHorizontal: "Horizontal de Sobel",
		filterTypeSobelVertical: "Vertical de Sobel",
		filterTypeSharpen: "Refinar",
		filterTypeSharpen2: "Refinar más",
		filterTypePointSpread: "Extensión de punto",
		userDefined: "Definido por el usuario",
		ContourTypeLines: "Líneas de curvas de nivel",
		ContourTypeFill: "Relleno de curvas de nivel",
		ContourTypeSmoothOnly: "Suavizar solo superficie",
		rasterizeFirst: "Primero",
		rasterizeLast: "Último(a)",
		rasterizeSmallest: "Más pequeño",
		rasterizeLargest: "Más grande",
		resamplingTypeNearest: "Vecino Más Próximo",
		resamplingTypeBilinear: "Interpolación bilineal",
		resamplingTypeCubic: "Convolución cúbica",
		resamplingTypeMajority: "Mayoría",
		resamplingTypeBilinearPlus: "Interpolación bilineal plus",
		resamplingTypeGauss: "Desenfoque gaussiano",
		resamplingTypeGaussPlus: "Desenfoque gaussiano plus",
		resamplingTypeAverage: "Media",
		resamplingTypeMinimum: "Mínimo",
		resamplingTypeMaximum: "Máximo",
		resamplingTypeVectorAvg: "Promedio vectorial",
		minimum: "Mínimo",
		maximum: "Máximo",
		mean: "Valor medio",
		stdDeviation: "Desviación estándar",
		uvMagDirTypeUV: "U-V",
		uvMagDirTypeMagDir: "Magnitud-dirección",
		unknown: "Desconocido",
		angleRefSysGeographic: "Geográfico",
		angleRefSysArithmetic: "Aritmética",
		interpolateIrregularDataNearest: "Vecino Más Próximo",
		interpolateIrregularDataBilinear: "Bilineal",
		interpolateIrregularDataTinningLinear: "Simplificación lineal",
		interpolateIrregularDataTinningNaturalNeighbor: "Vecino natural",
		interpolateIrregularDataTinningIDW: "Distancia inversa ponderada",
		esriRasterThresholdTypeConstant: "Constante",
		esriRasterThresholdTypeOtsu: "Otsu",
		esriRasterThresholdTypeTsai: "Tsai",
		esriRasterThresholdTypeKapur: "Kapur",
		esriRasterThresholdTypeKittler: "Kittler",
		esriRasterThresholdTypeRosin: "Rosin",
		argStatsTypeMax: "Arg Max",
		argStatsTypeMin: "Arg Min",
		argStatsTypeMedian: "Arg Medio",
		argStatsTypeDuration: "Duración",
		arithmeticOpPlus: "Plus",
		arithmeticOpMinus: "Resta",
		arithmeticOpMultiply: "Multiplicar",
		arithmeticOpDivide: "Dividir",
		arithmeticOpPower: "Potencia",
		arithmeticOpMode: "Modo",
		clipTypeOutside: "Clip fuera",
		clipTypeInside: "Clip dentro",
		yes: "Sí",
		no: "No",
		densities: "Densidades",
		expectedCounts: "Recuentos esperados",
		planar: "Planar",
		geodesic: "Geodésico",
		eachCell: "Cada celda",
		eachZone: "Cada zona",
		bestSingle: "Mejor Simple",
		allSightlines: "Todas las líneas de visión",
		perimeterSightlines: "Líneas de visión de perímetro",
		frequency: "Frecuencia",
		observers: "Observadores",
		majority: "Mayoría",
		median: "Mediana",
		minority: "Minoría",
		percentile: "Percentil",
		range: "Rango",
		sum: "Suma",
		variety: "Variedad",
		ndvi: "NDVI",
		savi: "SAVI",
		bandArithmeticMethodTSAVI: "SAVI transformado",
		bandArithmeticMethodMSAVI: "SAVI modificado",
		bandArithmeticMethodSultan: "Fórmula de Sultan",
		gemi: "GEMI",
		pvi: "PVI",
		gvi: "GVI (Landsat TM)",
		vari: "VARI",
		sr: "SR",
		gndvi: "GNDVI",
		ndvire: "NDVIre",
		srre: "SRre",
		mtvi2: "MTVI2",
		rtviCore: "RTVICore",
		cire: "CIre",
		cig: "CIg",
		ndwi: "NDWI",
		evi: "EVI",
		ironOxide: "Óxido de hierro",
		ferrousMinerals: "Minerales ferrosos",
		clayMinerals: "Minerales arcillosos",
		wndwi: "WNDWI",
		bai: "BAI",
		mndwi: "MNDWI",
		nbr: "NBR",
		ndbi: "NDBI",
		ndmi: "NDMI",
		ndsi: "NDSI",
		localSquareRoot: "Raíz cuadrada",
		localACos: "Arcocoseno (ACos)",
		localASin: "Arcoseno (ASin)",
		localATan: "Arcotangente (ATan)",
		localATanH: "Arcotangente hiperbólica (ATanH)",
		localAbs: "Valor absoluto",
		localBitwiseNot: "Bitwise Not",
		localBooleanNot: "Booleana Not",
		localCos: "Coseno (Cos)",
		localCosH: "Coseno hiperbólico (CosH)",
		localExp: "Exponencial en base e (Exp)",
		localExp10: "Exponencial en base 10 (Exp10)",
		localExp2: "Exponencial en base 2 (Exp2)",
		localInt: "Entero",
		localIsNull: "Es nulo",
		localFloat: "Flotante",
		localLn: "Logaritmo neperiano (Ln)",
		localLog10: "Logaritmo en base 10 (Log10)",
		localLog2: "Logaritmo en base 2 (Log2)",
		localNegate: "Cambio de signo",
		localRoundDown: "Redondeo hacia abajo",
		localRoundUp: "Redondeo hacia arriba",
		localSin: "Seno (Sin)",
		localSinH: "Seno hiperbólico (SinH)",
		localTan: "Tangente (Tan)",
		localTanH: "Tangente hiperbólica (TanH)",
		localACosH: "Arcocoseno hiperbólico (ACosH)",
		localASinH: "Arcoseno hiperbólico (ASinH)",
		localPlus: "Plus",
		localMinus: "Resta",
		localTimes: "Multiplicación",
		localPower: "Potencia",
		localBitwiseAnd: "Bitwise And",
		localBitwiseLeftShift: "Bitwise Left Shift",
		localBitwiseOr: "Bitwise Or",
		localBitwiseRightShift: "Bitwise Right Shift",
		localBitwiseXor: "Bitwise XOr",
		localBooleanAnd: "Booleana And",
		localBooleanOr: "Booleana Or",
		localBooleanXor: "Booleana XOr",
		localDivide: "Dividir",
		localEqualTo: "Igual a",
		localGreaterThan: "Mayor que",
		localGreaterThanEqual: "Mayor o igual que",
		localLessThan: "Menor que",
		localLessThanEqual: "Menor o igual que",
		localMod: "Módulo",
		localNotEqual: "No igual",
		localATan2: "Arcotangente (x/y) (ATan2)",
		localSquare: "Cuadrado",
		localSetNull: "Establecer nulos",
		remapDefTypeList: "Lista",
		remapDefTypeTable: "Tabla",
		remapTableTypeSimple: "Simple",
		remapTableTypeDynamic: "Dynamic",
		remapTableTypeReassignment: "Reasignación",
		geomCorrectionByConstZ: "Usar Z constante",
		geomCorrectionByDEM: "Usar DEM",
		radarCalibBetaNought: "Beta cero",
		radarCalibSigmaNought: "Sigma cero",
		radarCalibGammaNought: "Gamma cero",
		speckleFilterTypeLee: "Filtro Lee",
		speckleFilterTypeEnhancedLee: "Filtro Lee mejorado",
		speckleFilterTypeFrost: "Filtro Congelamiento",
		speckleFilterTypeKuan: "Filtro Kuan",
		speckleNoiseModelMul: "Ruido multiplicativo",
		speckleNoiseModelAdd: "Ruido aditivo",
		speckleNoiseModelAddnMul: "Ruido aditivo y multiplicativo",
		mosaicOpTypeFirst: "Primero",
		mosaicOpTypeLast: "Último(a)",
		mosaicOpTypeMin: "Mín.",
		mosaicOpTypeMax: "Máx.",
		mosaicOpTypeMean: "Valor medio",
		mosaicOpTypeBlend: "Combinar",
		mosaicOpTypeSum: "Suma",
		integer: "Entero",
		rfxD8: "D8",
		rfxMFD: "MFD",
		dinf: "Dinf",
		vertical: "Vertical",
		horizontal: "Horizontal",
		localCellStatisticsMajority: "Mayoría",
		localCellStatisticsMax: "Máximo",
		localCellStatisticsMean: "Valor medio",
		localCellStatisticsMedian: "Mediana",
		localCellStatisticsMin: "Mínimo",
		localCellStatisticsMinority: "Minoría",
		localCellStatisticsRange: "Rango",
		localCellStatisticsStdDev: "Desviación estándar",
		localCellStatisticsSum: "Suma",
		localCellStatisticsVariety: "Variedad",
		localCellStatisticsMajorityIgnoreND: "Mayoría (ignorar NoData)",
		localCellStatisticsMaxIgnoreND: "Máximo (ignorar NoData)",
		localCellStatisticsMeanIgnoreND: "Media (ignorar NoData)",
		localCellStatisticsMedianIgnoreND: "Mediana (ignorar NoData)",
		localCellStatisticsMinIgnoreND: "Mínimo (ignorar NoData)",
		localCellStatisticsMinorityIgnoreND: "Minoría (ignorar NoData)",
		localCellStatisticsRangeIgnoreND: "Rango (ignorar NoData)",
		localCellStatisticsStdDevIgnoreND: "Desviación estándar (ignorar NoData)",
		localCellStatisticsSumIgnoreND: "Suma (ignorar NoData)",
		localCellStatisticsVarietyIgnoreND: "Variedad (ignorar NoData)",
		localCellStatisticsTypePercentileIgnoreND: "Percentil (ignorar NoData)",
		fromSource: "De origen",
		toSource: "A origen",
		colorspaceConversionRgbToHsv: "RGB a HSV",
		colorspaceConversionHsvToRgb: "HSV a RGB",
		pansharpenTypeIHS: "IHS",
		pansharpenTypeBrovey: "Brovey",
		pansharpenTypeEsri: "Esri",
		pansharpenTypeMean: "Valor medio",
		pansharpenTypeGramSchmidt: "Gram-Schmidt",
		rectangleNeighborhood: "Rectángulo",
		circleNeighborhood: "Círculo",
		annulusNeighborhood: "Anillo",
		wedgeNeighborhood: "Porción de círculo",
		irregularNeighborhood: "Irregular",
		weightNeighborhood: "Peso",
		four: "Cuatro",
		eight: "Ocho",
		within: "Dentro de",
		cross: "Cruz",
		addLink: "Agregar vínculo",
		noLink: "Sin vínculo",
		weightedMean: "Media ponderada",
		ls8QCBitPatternCirrus: "Landsat 8 Cirrus",
		ls8QCBitPatternCloud: "Landsat 8 Nube",
		ls8QCBitPatternCloudShadow: "Landsat 8 Sombra de nube",
		ls8QCBitPatternDesignatedFill: "Landsat 8 Relleno",
		ls8QCBitPatternDroppedFrame: "Landsat 8 Dropped Frame",
		ls8QCBitPatternSnowIce: "Landsat 8 Nieve/Hielo",
		ls8QCBitPatternTerrainOcclusion: "Landsat 8 Oclusión del terreno",
		ls8QCBitPatternVegetation: "Landsat 8 Vegetación",
		ls8QCBitPatternWater: "Landsat 8 Agua",
		downStream: "Aguas abajo",
		upStream: "Aguas arriba",
		strahler: "STRAHLER",
		shreve: "SHREVE",
		currentSlice: "División actual",
		allSlices: "Todas las divisiones",
		expandDistance: "DISTANCE",
		expandMorphological: "MORFOLÓGICO",
		spectralProfileFile: "Perfil espectral",
		trainingFeatureFile: "Entidad de entrenamiento",
		randomDistributionTypeUniform: "Uniforme",
		randomDistributionTypeUniformInteger: "Entero",
		randomDistributionTypeNormal: "Normal",
		randomDistributionTypeExponential: "Exponencial",
		randomDistributionTypePoisson: "Poisson",
		randomDistributionTypeGamma: "Gamma",
		randomDistributionTypeBinomial: "Binomial",
		randomDistributionTypeGeometric: "Geométrica",
		randomDistributionTypeNegativeBinomial: "Binomial negativa",
		randomGeneratorTypeStandardCRand: "Rand C estándar",
		randomGeneratorTypeAlgorithmACM599: "Algoritmo 599 capturado por ACM",
		randomGeneratorTypeMersenneTwister: "Mersenne Twister",
		sumName: "Suma",
		medainName: "Mediana",
		trendLinear: "Lineal",
		trendHarmonic: "Armónica",
		trendPolynomial: "Polinómica",
		trendMannKendall: "Mann-Kendall",
		trendSeasonalKendall: "Seasonal Kendall",
		dimensionByValue: "Por valor",
		dimensionByInterval: "Por intervalo",
		mdimDefTypeAll: "Todo",
		mdimDefTypeByValues: "Por valores",
		mdimDefTypeByRanges: "Por rangos",
		mdimDefTypeByIteration: "Por iteración",
		mdimDefTypeByInterval: "Por intervalo",
		mdimDefTypeByTargetRaster: "Por ráster de destino",
		esriTimeUnitsHours: "Horas",
		esriTimeUnitsDays: "Días",
		esriTimeUnitsWeeks: "Semanas",
		esriTimeUnitsMonths: "Meses",
		esriTimeUnitsYears: "Años",
		esriTimeIntervalKeywordHourly: "Cada hora",
		esriTimeIntervalKeywordDaily: "Diariamente",
		esriTimeIntervalKeywordWeekly: "Semanalmente",
		esriTimeIntervalKeywordDekadly: "Cada década",
		esriTimeIntervalKeywordPentadly: "Cada lustro",
		esriTimeIntervalKeywordMonthly: "Mensualmente",
		esriTimeIntervalKeywordQuarterly: "Trimestralmente",
		esriTimeIntervalKeywordYearly: "Anualmente",
		esriTimeIntervalKeywordRecurringDaily: "Recurrente diariamente",
		esriTimeIntervalKeywordRecurringWeekly: "Recurrente semanalmente",
		esriTimeIntervalKeywordRecurringMonthly: "Recurrente mensualmente",
		esriTimeIntervalKeywordRecurringQuarterly: "Recurrente trimestralmente",
		aggDefTypeAll: "Todo",
		aggDefTypeIntervalKeyword: "Palabra clave de intervalo",
		aggDefTypeIntervalValue: "Valor de intervalo",
		aggDefTypeIntervalRanges: "Rangos de intervalos",
		latestChange: "Hora del cambio más reciente",
		earliestChange: "Hora del cambio más temprano",
		largestChange: "Hora del cambio más grande",
		numberOfChanges: "Número de cambios",
		longestChange: "Hora del cambio más largo",
		shortestChange: "Hora del cambio más corto",
		fastestChange: "Hora del cambio más rápido",
		slowestChange: "Hora del cambio más lento",
		allChanges: "Todo",
		increaseChanges: "Aumentar",
		decreaseChanges: "Disminuir",
		segmentBeginning: "Inicio del segmento",
		segmentEnd: "Fin del segmento",
		esriComputeChangeMethodDifference: "Diferencia",
		esriComputeChangeMethodRelativeDifference: "Diferencia relativa",
		esriComputeChangeMethodCategorical: "Diferencia de categoría",
		esriComputeChangeMethodMultispectralEuclideanDistance: "Distancia euclidiana espectral",
		esriComputeChangeMethodMultispectralAngularDifference: "Diferencia de ángulo espectral",
		esriComputeChangeMethodMultispectralAxisWithBiggestChange: "Banda con más cambio",
		esriComputeChangeKeepAll: "Conservar todo",
		esriComputeChangeKeepChangedOnly: "Conservar solo píxeles modificados",
		esriComputeChangeKeepUnchangedOnly: "Conservar solo píxeles no modificados",
		esriComputeChangeUseColorAverage: "Promedio de desde y hasta colores",
		esriComputeChangeUseColorFrom: "Utilizar colores desde",
		esriComputeChangeUseColorTo: "Utilizar colores hasta",
		factorFunctionBinary: "Binario",
		factorFunctionForward: "Hacia delante",
		factorFunctionLinear: "Lineal",
		factorFunctionInvLinear: "Lineal inversa",
		factorFunctionTable: "Tabla",
		factorFunctionSymLinear: "Lineal simétrico",
		factorFunctionSymInvLinear: "Lineal inverso simétrico",
		factorFunctionCos: "Coseno",
		factorFunctionSec: "Secante",
		factorFunctionCosSec: "Secante de coseno",
		factorFunctionSecCos: "Coseno de secante",
		noSort: "No ordenar",
		ascend: "Ascender",
		descend: "Descender",
		autoDetect: "Detección automática",
		nearest: "Más cercano",
		linear: "Lineal",
		esriMonthJanuary: "Enero",
		esriMonthFebruary: "Febrero",
		esriMonthMarch: "Marzo",
		esriMonthApril: "Abril",
		esriMonthMay: "Mayo",
		esriMonthJune: "Junio",
		esriMonthJuly: "Julio",
		esriMonthAugust: "Agosto",
		esriMonthSeptember: "Septiembre",
		esriMonthOctober: "Octubre",
		esriMonthNovember: "Noviembre",
		esriMonthDecember: "Diciembre",
		dimensionalMovingIgnoreNoData: "Datos",
		dimensionalMovingPropagateNoData: "NoData",
		dimensionalMovingFillOnlyNoData: "Rellenar NoData",
		circularMean: "Valor medio circular",
		circularName: "Circular",
		arithmeticName: "Aritmética",
		slopeName: "Pendiente",
		aspectName: "Orientación",
		meanCurvature: "Curvatura media",
		profileCurvature: "Curvatura de perfil (línea de pendiente normal)",
		tangentialCurvature: "Curvatura tangencial (curva de nivel normal)",
		planCurvature: "Curvatura del plano (curva de nivel proyectada)",
		contourGeodesicTorsion: "Torsión geodésica de curvas de nivel",
		gaussianCurvature: "Curvatura gaussiana",
		casoratiCurvature: "Curvatura de Casorati",
		localSurfaceTypeQuadratic: "Cuadrática",
		localSurfaceTypeBiquadratic: "Bicuadrática",
		thresholdNoThreshold: "Ningún umbral",
		thresholdPercentLeastCost: "Porcentaje del menor coste",
		thresholdAccumulativeCost: "Coste acumulativo",
		clrmapTypeHillshade: "Sombreado"
	},
	categoryLabels: {
		sourceCharacteristics: "Características de origen",
		neighborhoodSettings: "Configuración de vecindad",
		statistics: "Estadísticas",
		gamma: "Gamma",
		viewshedParameters: "Parámetros de cuenca visual",
		observerParameters: "Parámetros de observador",
		irregularDataInterpolation: "Interpolación de datos irregulares",
		modelStatistics: "Estadísticas de modelo",
		aggregationDef: "Definición de agregación",
		filterByAttributes: "Filtrar por atributos",
		percentileName: "Percentil",
		rasterInfo: "Información del ráster",
		extent: "Extensión",
		spatialReference: "Referencia espacial"
	},
	outputRasterHelpTexts: {
		outputName: "<p>El nombre de la capa que se creará y se agregará al mapa.</p>",
		resultType: "<p>El tipo de salida que se creará. Las salidas pueden ser capas de imágenes en teselas o capas de imágenes dinámicas.</p>",
		saveResultIn: "<p>El nombre de la carpeta de <b>Mi contenido</b> en la que se guardará el resultado.</p>"
	},
	analysisEnvironmentsHelpTexts: {
		description: "<p>Configuración del entorno para el análisis en Map Viewer. </p>",
		outSR: "<p>Especifica el sistema de coordenadas para el análisis y la capa de resultados.</p>",
		extent: "<p>Especifica el área que se va a utilizar para el análisis.</p>",
		snapRaster: "<p>Ajusta la extensión de la salida para que coincida con la alineación de celda de la capa ráster de alineación especificada.</p>",
		cellSize: "<p>Especifica el tamaño o la resolución de celda que se utilizará para crear la capa ráster de salida.</p>",
		mask: "<p>Especifica una capa de máscara, en la que solo se utilizarán para el análisis las celdas que se encuentren dentro del área de la máscara.</p>",
		resamplingMethod: "<p>Especifica cómo interpolar valores de píxel cuando los rásteres de entrada y salida no se alinean.</p>"
	},
	mainGenStrings: {
		unsupportedDataType: "Tipo no admitido",
		currentlyUnsupported: " Hay pendiente un editor predeterminado para ${missingType}, pero estará disponible próximamente. Cuadro de texto de marcador de posición temporal para especificar entradas basadas en cadenas de caracteres.",
		unsupportedOverrideWarning: "Hay pendiente un componente de editor de excepciones que proporciona una mejor experiencia de usuario para trabajar con los siguientes parámetros, pero estará disponible próximamente:",
		overrideWidgetMissing: "¡Falta el componente de editor de excepciones!",
		uiIncomplete: "Error al enviar trabajo. No se puede ejecutar la función porque algunos de los campos requeridos están incompletos o faltan en la UI.",
		count: "Recuento",
		selectVariables: "Seleccionar variables",
		selectFeature: "Seleccionar una capa de entidades",
		greaterThanErrorMessage: "El número de entrada debe ser mayor que ${min}",
		lesserThanErrorMessage: "El número de entrada debe ser menor que ${max}",
		greaterThanOrEqualErrorMessage: "El número de entrada debe ser mayor o igual que ${min}",
		lesserThanOrEqualErrorMessage: "El número de entrada debe ser menor o igual que ${max}",
		allowScalar: "Seleccione una capa o introduzca una constante",
		selectField: "Seleccionar campo",
		parameterRequired: "Este parámetro es obligatorio.",
		enterAValue: "Introduzca un valor...",
		invalidInput: "El valor introducido no es válido.",
		itemNotFound: "El elemento no existe o no es accesible.",
		itemPermissionDenied: "No tiene permisos para acceder a este elemento.",
		layerNotAvailable: "Fallo al cargar la capa ${layerName}.",
		multipleLayersNotAvailable: "Error al cargar la capa ${layerName} y otros.",
		learnMoreLabel: "Más información",
		fieldNotAvailable: "Error al cargar el campo.",
		allowAnalysis: "No se permite el análisis en el servicio de imágenes.",
		allowAnalysisReason: "Una o varias capas del mapa no figuran aquí porque no permiten el análisis.",
		learnMoreText: "Más información",
		atLeastOneRasterInput: "Al menos una capa de entrada debe ser una capa ráster.",
		browseAnalysisLayers: "Examinar capas",
		activeMapViewExtent: "Usar extensión del mapa actual",
		chooseRaster: "Elegir ráster de recorte",
		chooseGeometry: "Elegir geometría de recorte",
		resultType: "Tipo de resultado",
		saveInFolder: "Guardar en carpeta",
		outputName: "Nombre de salida",
		outputLayerType: "Tipo de capa de salida",
		dynamicImageryLayer: "Capa de imágenes dinámicas",
		tiledImageryLayer: "Capa de imágenes en teselas",
		custom: "Personalizada",
		loading: "Cargando...",
		layerMissing: "Una o varias capas del mapa no figuran aquí porque no permiten el análisis. Más información.",
		browseCoordinateSystems: "Examinar sistemas de coordenadas",
		unableToRepopulateOutSR: "No se puede completar el sistema de coordenadas de salida.",
		defaultTitle: "Ver más",
		"ARC (equal arc-second)": "ARC (arcosegundo equivalente)",
		Africa: "África",
		Antarctica: "Antártida",
		Argentina: "Argentina",
		Asia: "Asia",
		"Asteroid Belt": "Cinturón de asteroides",
		"Atlantic Ocean": "Océano Atlántico",
		Australia: "Australia",
		"Australia and New Zealand": "Australia y Nueva Zelanda",
		Austria: "Austria",
		"BLM (US Feet)": "BLM (pies EE. UU.)",
		Bangladesh: "Bangladés",
		"Beijing 1954": "Pekín 1954",
		Bhutan: "Bután",
		CGCS2000: "CGCS2000",
		Canada: "Canadá",
		Caribbean: "Caribe",
		"Caribbean Sea": "Mar Caribe",
		"Central America": "Centroamérica",
		"Central and North America": "Norteamérica y Centroamérica",
		Colombia: "Colombia",
		Continental: "Continental",
		"County Systems": "Sistemas de condado",
		"Democratic Republic of the Congo": "República Democrática del Congo",
		"EPSG Arctic": "EPSG Arctic",
		Earth: "Tierra",
		"Ellipsoidal-based": "Basado en elipsoidales",
		Europe: "Europa",
		Finland: "Finlandia",
		France: "Francia",
		"GSK 2011": "GSK 2011",
		"Gauss Kruger": "Gauss-Krüger",
		"Geographic Coordinate Systems": "Sistemas de coordenadas geográficas",
		Germany: "Alemania",
		"Gravity-related": "Relacionado con gravedad",
		"Greenwich-based": "Basado en Greenwich",
		"Highways England": "Highways England",
		Illinois: "Illinois",
		"Indian Ocean": "Océano Índico",
		"Indian Subcontinent": "Subcontinente indio",
		Indiana: "Indiana",
		Indonesia: "Indonesia",
		Iowa: "Iowa",
		"Ireland and United Kingdom": "Irlanda y Reino Unido",
		Italy: "Italia",
		Japan: "Japón",
		Jupiter: "Júpiter",
		Kansas: "Kansas",
		"Las Vegas": "Las Vegas",
		Libya: "Libia",
		Malaysia: "Malasia",
		"Malaysia and Singapore": "Malasia y Singapur",
		Mars: "Marte",
		Mercury: "Mercurio",
		Minnesota: "Minnesota",
		Montana: "Montana",
		"NAD 1927": "NAD 1927",
		"NAD 1927 (US Feet)": "NAD 1927 (pies EE. UU.)",
		"NAD 1983": "NAD 1983",
		"NAD 1983 (2011)": "NAD 1983 (2011)",
		"NAD 1983 (2011) (Intl Feet)": "NAD 1983 (2011) (pies internacional)",
		"NAD 1983 (2011) (Meters)": "NAD 1983 (2011) (metros)",
		"NAD 1983 (2011) (US Feet)": "NAD 1983 (2011) (pies EE. UU.)",
		"NAD 1983 (CORS96) (Intl Feet)": "NAD 1983 (CORS96) (pies internacional)",
		"NAD 1983 (CORS96) (Meters)": "NAD 1983 (CORS96) (metros)",
		"NAD 1983 (CORS96) (US Feet)": "NAD 1983 (CORS96) (pies EE. UU.)",
		"NAD 1983 (Intl Feet)": "NAD 1983 (pies internacional)",
		"NAD 1983 (Meters)": "NAD 1983 (metros)",
		"NAD 1983 (PA11) (Meters)": "NAD 1983 (PA11) (metros)",
		"NAD 1983 (PA11) (US Feet)": "NAD 1983 (PA11) (pies EE. UU.)",
		"NAD 1983 (US Feet)": "NAD 1983 (pies EE. UU.)",
		"NAD 1983 HARN (Intl Feet)": "NAD 1983 HARN (pies internacional)",
		"NAD 1983 HARN (Meters)": "NAD 1983 HARN (metros)",
		"NAD 1983 HARN (US Feet)": "NAD 1983 HARN (pies EE. UU.)",
		"NAD 1983 NSRS2007 (Intl Feet)": "NAD 1983 NSRS2007 (pies internacional)",
		"NAD 1983 NSRS2007 (Meters)": "NAD 1983 NSRS2007 (metros)",
		"NAD 1983 NSRS2007 (US Feet)": "NAD 1983 NSRS2007 (pies EE. UU.)",
		"National Grids": "Cuadrículas nacionales",
		Navajo: "Navajo",
		Neptune: "Neptuno",
		"New Beijing": "Nuevo Pekín",
		"New Zealand": "Nueva Zelanda",
		"North America": "Norteamérica",
		"Northern Hemisphere": "Hemisferio septentrional",
		Norway: "Noruega",
		Oceans: "Océanos",
		Oregon: "Oregón",
		"Other GCS": "Otros sistemas GCS",
		"Pacific Ocean": "Océano Pacífico",
		Pluto: "Plutón",
		Polar: "Polar",
		Portugal: "Portugal",
		"Projected Coordinate Systems": "Sistemas de coordenadas proyectadas",
		"Pulkovo 1942": "Pulkovo 1942",
		"Pulkovo 1995": "Pulkovo 1995",
		Replaced: "Sustituido",
		"SAD 1969": "SAD 1969",
		SIRGAS: "SIRGAS",
		"SIRGAS 2000": "SIRGAS 2000",
		Saturn: "Saturno",
		"Solar System": "Sistema solar",
		"South Africa": "Sudáfrica",
		"South America": "Sudamérica",
		"South Korea": "Corea del Sur",
		"Southern Hemisphere": "Hemisferio meridional",
		"Spheroid-based": "Basado en esferoides",
		"State Plane": "Plano estatal",
		"State Systems": "Sistemas estatales",
		Sweden: "Suecia",
		"Switzerland and Liechtenstein": "Suiza y Liechtenstein",
		Texas: "Texas",
		Tribal: "Tribal",
		Turkey: "Turquía",
		"US Feet": "Pies de EE. UU.",
		"USA and territories": "Estados Unidos y territorios",
		UTM: "UTM",
		Ukraine: "Ucrania",
		"Unknown Height Systems": "Sistemas de altura desconocidos",
		Uranus: "Urano",
		Venus: "Venus",
		"Vertical Coordinate Systems": "Sistemas de coordenadas verticales",
		Vietnam: "Vietnam",
		"WGS 1972": "WGS 1972",
		"WGS 1984": "WGS 1984",
		Wisconsin: "Wisconsin",
		"Wisconsin CRS": "Wisconsin CRS",
		World: "Mundo",
		"World (Sphere-based)": "Mundo (basado en Sphere)",
		Wyoming: "Wyoming",
		"Xian 1980": "Xian 1980",
		done: "Listo",
		noResults: "No se encontró ningún resultado",
		searchPlaceholder: "Nombre en WKID",
		browseTemplate: "Examinar plantillas de función ráster",
		saveTemplate: "Guardar plantilla de función ráster",
		preview: "Previsualización",
		previewDescription: "Obtenga una vista previa del resultado antes de ejecutar el análisis.",
		showPreview: "Mostrar vista previa",
		previewLayer: "Capa de vista previa ${number}",
		newPreview: "Nueva vista previa",
		previewPopup: "Habilite la vista previa de los resultados del análisis según los parámetros de entrada.",
		updatePreviewLayer: "Actualizar la capa de vista previa seleccionada",
		createPreviewLayer: "Crear nueva capa de vista previa",
		maximumPreviewAllowed: "Número máximo de capas de vista previa permitidas: ${maxCount}",
		previewFailure: "Esta capa de vista previa no está disponible. Compruebe los parámetros de entrada y vuelva a actualizar esta capa de vista previa.",
		header: "Seleccionar elemento",
		content: "Hay cambios sin guardar en ${rftTitle}. Si vuelve a empezar con una plantilla nueva, esos cambios se perderán.",
		dontSave: "No guardar",
		"continue": "Continuar",
		stretch: "Ajustar a ventana",
		pan: "Desplazamiento panorámico",
		newTemplate: "Crear nueva plantilla",
		openTemplate: "Abrir plantilla",
		addFunction: "Agregar funciones de ráster",
		addConstant: "Agregar constante",
		addRaster: "Agregar variable de ráster",
		move: "Mover",
		zoom: "Zoom",
		saveAs: "Guardar como",
		clear: "Borrar",
		addRasterFunctionTitle: "Agregar funciones de ráster",
		templatePropertiesTitle: "Propiedades de plantilla",
		browseRFT: "Examinar plantillas de función ráster",
		defaultToolDescription: "Herramienta de análisis ${toolTitle}.",
		openToolText: "Herramienta Abrir",
		toolDropdownText: "Menú desplegable de herramientas",
		addToMap: "Confirmar y agregar al mapa",
		confirm: "Confirmar",
		select: "Seleccionar",
		selectTask: "Seleccionar tarea",
		unsupportedLayer: "Este parámetro no admite las siguientes capas: ${layerName}.",
		viewDetails: "Ver todos los detalles del elemento",
		rename: "Cambiar nombre",
		duplicate: "Duplicada",
		launch: "Abrir para ejecutar",
		templateEditor: "Editor de plantillas",
		createItem: "Guardar plantilla de función ráster",
		actionLabel: "Filtrar",
		filterPopoverHeading: "Filtrar las funciones",
		defaultSearchPlaceholder: "Buscar por nombre",
		settings: "Ajustes",
		summary: "Resumen",
		definitionQuery: "Consulta de definición",
		matchVariables: "Variables de coincidencia",
		unionDimension: "Combinar dimensión",
		nameEditorPlaceholder: "Introducir título",
		summaryEditorPlaceholder: "Introduzca una descripción corta.",
		definitionQueryPlaceholder: "Introducir...",
		upload: "Cargar",
		chooseImage: "Haga clic para elegir un archivo",
		update: "Actualizar",
		thumbnailErrors: {
			wrongImageType: "Tipo de imagen incorrecto seleccionado",
			notAvailable: "Vista en miniatura no disponible",
			loadError: "No se puede cargar la imagen",
			chooseFile: "Haga clic para elegir archivo"
		}
	}
};
const copy = "Copiar";
const save = "Guardar";
const title = "Título";
const folder = "Carpeta";
const tags = "Etiquetas";
const savingMessage = "Guardando elemento en";
const shareWith = "Compartir con";
const share = "Compartir";
const setSharingLevel = "Definir nivel de uso compartido";
const setGroupSharing = "Definir uso compartido de grupo";
const owner = "Propietario";
const organization = "Organización";
const everyone = "Todos (público)";
const groups = "Grupos:";
const type = "Tipo";
const mosaic = "Mosaico";
const itemGroup = "Grupo de elementos";
const item = "Elemento";
const definitionQuery = "Consulta de definición";
const groupItemsBy = "Agrupar elementos por";
const groupFieldName = "Nombre de campo de grupo";
const tagFieldName = "Nombre de campo de etiqueta";
const noTitleTagErrorMsg = "Debe proporcionar un título para su elemento y etiquetas para que su mapa aparezca en búsquedas.";
const noTitleErrorMsg = "Debe proporcionar un título para su elemento.";
const noTagErrorMsg = "Debe proporcionar al menos una etiqueta para que las personas puedan encontrar su elemento en búsquedas.";
const error = "Error";
const warning = "Advertencia";
const success = "Correcto";
const details = "Detalles:";
const tryAgain = "Volver a intentarlo";
const toolModeler = {
	save: "Guardar",
	editProperties: "Editar propiedades",
	saveAs: "Guardar como",
	savingNotification: "Guardando cambios en el elemento...",
	savingTitle: "Guardando",
	saveFailedMessage: "Error al guardar los cambios.",
	saveWithErrorsMessage: "Los cambios se guardaron con los siguientes errores.",
	viewItemMessage: "Visualizar el elemento guardado",
	here: "aquí.",
	itemCreatedMessage: "Se ha creado un nuevo elemento.",
	clickToViewItemMessage: "Haga clic en Aceptar para ver la página de detalles del elemento; haga clic en Cancelar para continuar.",
	readingFailed: "Error al cargar la plantilla de función ráster seleccionada.",
	failedToLoadXML: "Error al cargar la plantilla de función ráster seleccionada en formato XML.",
	learnMore: "Más información",
	overwriteTitle: "Confirmar sobrescritura",
	overwriteMessage: "¿Desea sobrescribir el elemento existente?",
	overwriteSuccessMessage: "El elemento se ha actualizado."
};
const toolEditor = {
	run: "Ejecutar",
	save: "Guardar",
	deleteSelected: "Eliminar elementos seleccionados",
	addRaster: "Agregar ráster",
	addScalar: "Agregar escalar",
	layout: "Diseño automático",
	errorTitle: "Error",
	invalidToolMessage: "La plantilla de función ráster no es válida.",
	out: "Salida",
	zoomIn: "Acercar",
	zoomOut: "Alejar",
	zoomToFit: "Ajustar a ventana",
	panOn: "Cambiar al modo de desplazamiento panorámico",
	panOff: "Desactivar modo de desplazamiento panorámico",
	defaultModelName: "Modelo de herramienta",
	defaultRasterName: "Ráster"
};
const toolDetailsEditor = {
	defaultToolName: "Plantilla de función ráster",
	defaultToolDescription: "Agregue un breve resumen sobre la función ráster.",
	defaultHelpText: "Haga clic en el icono de ayuda para editar el texto de ayuda",
	editHelpTitle: "Editar Ayuda",
	saveLabel: "Guardar",
	cancelLabel: "Cancelar",
	thumbnail: {
		wrongImageType: "Tipo de imagen incorrecto seleccionado",
		notAvailable: "Miniatura no disponible",
		loadError: "No se puede cargar la imagen",
		chooseFile: "Haga clic para seleccionar el archivo"
	}
};
const saveUtils = {
	thumbnail: "Vista en miniatura",
	sharing: "Compartir"
};
const close = "Cerrar";
const unsavedWarningExisting = "¿Desea guardar los cambios del elemento <b>${itemTitle}</b>?";
const unsavedWarningNew = "¿Desea guardar los cambios?";
const saveAs = "Guardar como";
const dontSave = "No guardar";
const unsavedTitle = "Cambios no guardados";
const invalidRFTMessage = "La plantilla de función ráster creada no es válida.";
const errorTitle = "Error";
const breadcrumb = "Editor de funciones ráster";
const breadcrumbEditor = "Contenido > Editor de funciones ráster";
const viewerModeTitle = "Solo lectura";
const viewerModeMessage = "El elemento de la plantilla de la función ráster es de solo lectura. Los cambios no se pueden guardar.";
const userStartDirection = "Seleccione una función para empezar a crear una plantilla de función ráster.";
const selectFunction = "Agregar función";
const deselectFunction = "Eliminar función";
const dialogTitle = "Sistema";
const category = "Categorías";
const search = "Buscar funciones ráster";
const categoryNames = {
	analysis: "Análisis",
	appearance: "Apariencia",
	classification: "Clasificación",
	conversion: "Conversión",
	correction: "Corrección",
	dataManagement: "Administración de datos",
	distance: "Distancia",
	distanceLegacy: "Distancia (heredada)",
	hydrology: "Hidrología",
	math: "Matemática",
	mathConditional: "Matemática: condicional",
	mathLogical: "Matemática: lógica",
	mathTrigonometric: "Matemática: trigonométrica",
	reclass: "Reclasificar",
	statistical: "Estadístico",
	surface: "Superficie"
};
const commonStrings_es = {
	ok: ok,
	cancel: cancel,
	enterURL: enterURL,
	serviceURL: serviceURL,
	selectRaster: selectRaster,
	failedToLoadLayer: failedToLoadLayer,
	loadingLayer: loadingLayer,
	selectFeature: selectFeature,
	enterFURL: enterFURL,
	addRaster: addRaster,
	addScalar: addScalar,
	raster: raster,
	scalar: scalar,
	defaultModelName: defaultModelName,
	general: general,
	parameters: parameters,
	variables: variables,
	name: name,
	description: description,
	parameter: parameter,
	isPublic: isPublic,
	isDataset: isDataset,
	unknownPixelType: unknownPixelType,
	outputPixelType: outputPixelType,
	u8PixelType: u8PixelType,
	s8PixelType: s8PixelType,
	u16PixelType: u16PixelType,
	s16PixelType: s16PixelType,
	u32PixelType: u32PixelType,
	s32PixelType: s32PixelType,
	f32PixelType: f32PixelType,
	f64PixelType: f64PixelType,
	properties: properties,
	multidimensionalRules: multidimensionalRules,
	matchVariables: matchVariables,
	unionDimensions: unionDimensions,
	rasterFunctionEditor: rasterFunctionEditor,
	rfxLicenseInfo: rfxLicenseInfo,
	rasterFunctions: rasterFunctions,
	copy: copy,
	save: save,
	title: title,
	folder: folder,
	tags: tags,
	savingMessage: savingMessage,
	shareWith: shareWith,
	share: share,
	setSharingLevel: setSharingLevel,
	setGroupSharing: setGroupSharing,
	owner: owner,
	organization: organization,
	everyone: everyone,
	groups: groups,
	type: type,
	mosaic: mosaic,
	itemGroup: itemGroup,
	item: item,
	definitionQuery: definitionQuery,
	groupItemsBy: groupItemsBy,
	groupFieldName: groupFieldName,
	tagFieldName: tagFieldName,
	noTitleTagErrorMsg: noTitleTagErrorMsg,
	noTitleErrorMsg: noTitleErrorMsg,
	noTagErrorMsg: noTagErrorMsg,
	error: error,
	warning: warning,
	success: success,
	details: details,
	tryAgain: tryAgain,
	toolModeler: toolModeler,
	toolEditor: toolEditor,
	toolDetailsEditor: toolDetailsEditor,
	saveUtils: saveUtils,
	close: close,
	unsavedWarningExisting: unsavedWarningExisting,
	unsavedWarningNew: unsavedWarningNew,
	saveAs: saveAs,
	dontSave: dontSave,
	unsavedTitle: unsavedTitle,
	invalidRFTMessage: invalidRFTMessage,
	errorTitle: errorTitle,
	breadcrumb: breadcrumb,
	breadcrumbEditor: breadcrumbEditor,
	viewerModeTitle: viewerModeTitle,
	viewerModeMessage: viewerModeMessage,
	userStartDirection: userStartDirection,
	selectFunction: selectFunction,
	deselectFunction: deselectFunction,
	dialogTitle: dialogTitle,
	category: category,
	search: search,
	categoryNames: categoryNames
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (commonStrings_es);


//# sourceMappingURL=common-strings.es-c65ca642.js.map

/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid2lkZ2V0cy9jaHVua3MvYXJjZ2lzX2FuYWx5c2lzX25vZGVfbW9kdWxlc19hcmNnaXNfYXJjZ2lzLXJhc3Rlci1mdW5jdGlvbi1lZGl0b3JfLTNmZGE1MC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseWFBQXlhLHNLQUFzSywyRUFBMkU7QUFDMXBCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtSkFBbUo7QUFDbko7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHl1QkFBeXVCO0FBQ3p1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaW9CQUFpb0I7QUFDam9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2T0FBNk87QUFDN087QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1YQUFtWDtBQUNuWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa3JHQUFrckcsT0FBTztBQUN6ckc7QUFDQTtBQUNBLHl5Q0FBeXlDO0FBQ3p5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0Esd0VBQXdFLFlBQVk7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFLElBQUk7QUFDMUUscUVBQXFFLElBQUk7QUFDekUscUZBQXFGLElBQUk7QUFDekYsb0ZBQW9GLElBQUk7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsVUFBVTtBQUMxRCx5REFBeUQsV0FBVztBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxPQUFPO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0VBQStFLFNBQVM7QUFDeEY7QUFDQTtBQUNBLHlDQUF5QyxTQUFTO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELFVBQVU7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFLFVBQVU7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEZBQTRGO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RUFBNkUsVUFBVTtBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlFQUFlLGdCQUFnQixFQUFDO0FBQ2lvQzs7QUFFanFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZXhiLWNsaWVudC8uL2V4dGVuc2lvbnMvd2lkZ2V0cy9hcmNnaXMvYW5hbHlzaXMvbm9kZV9tb2R1bGVzL0BhcmNnaXMvYXJjZ2lzLXJhc3Rlci1mdW5jdGlvbi1lZGl0b3IvZGlzdC9lc20vY29tbW9uLXN0cmluZ3MuZXMtYzY1Y2E2NDIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3Qgb2sgPSBcIkFjZXB0YXJcIjtcbmNvbnN0IGNhbmNlbCA9IFwiQ2FuY2VsYXJcIjtcbmNvbnN0IGVudGVyVVJMID0gXCJJbnRyb2R1Y2lyIFVSTCBkZSBzZXJ2aWNpbyBkZSBpbcOhZ2VuZXNcIjtcbmNvbnN0IHNlcnZpY2VVUkwgPSBcIlVSTCBkZSBzZXJ2aWNpb1wiO1xuY29uc3Qgc2VsZWN0UmFzdGVyID0gXCJTZWxlY2Npb25hciByw6FzdGVyXCI7XG5jb25zdCBmYWlsZWRUb0xvYWRMYXllciA9IFwiRmFsbG8gYWwgY2FyZ2FyIGxhIGNhcGFcIjtcbmNvbnN0IGxvYWRpbmdMYXllciA9IFwiQ2FyZ2FuZG8gY2FwYVwiO1xuY29uc3Qgc2VsZWN0RmVhdHVyZSA9IFwiU2VsZWNjaW9uYXIgY2FwYSBkZSBlbnRpZGFkXCI7XG5jb25zdCBlbnRlckZVUkwgPSBcIkludHJvZHVjaXIgVVJMIGRlIHNlcnZpY2lvIGRlIGVudGlkYWRlc1wiO1xuY29uc3QgYWRkUmFzdGVyID0gXCJBZ3JlZ2FyIHZhcmlhYmxlIGRlIHLDoXN0ZXJcIjtcbmNvbnN0IGFkZFNjYWxhciA9IFwiQWdyZWdhciBjb25zdGFudGVcIjtcbmNvbnN0IHJhc3RlciA9IFwiQ2FsY3VsYWRvcmEgcsOhc3RlclwiO1xuY29uc3Qgc2NhbGFyID0gXCJFc2NhbGFyXCI7XG5jb25zdCBkZWZhdWx0TW9kZWxOYW1lID0gXCJQbGFudGlsbGEgZGUgZnVuY2nDs24gcsOhc3RlclwiO1xuY29uc3QgZ2VuZXJhbCA9IFwiR2VuZXJhbFwiO1xuY29uc3QgcGFyYW1ldGVycyA9IFwiUGFyw6FtZXRyb3NcIjtcbmNvbnN0IHZhcmlhYmxlcyA9IFwiVmFyaWFibGVzXCI7XG5jb25zdCBuYW1lID0gXCJOb21icmVcIjtcbmNvbnN0IGRlc2NyaXB0aW9uID0gXCJEZXNjcmlwY2nDs25cIjtcbmNvbnN0IHBhcmFtZXRlciA9IFwiUGFyw6FtZXRyb1wiO1xuY29uc3QgaXNQdWJsaWMgPSBcIklzUHVibGljXCI7XG5jb25zdCBpc0RhdGFzZXQgPSBcIklzRGF0YXNldFwiO1xuY29uc3QgdW5rbm93blBpeGVsVHlwZSA9IFwiRGVzY29ub2NpZG9cIjtcbmNvbnN0IG91dHB1dFBpeGVsVHlwZSA9IFwiVGlwbyBkZSBww614ZWwgZGUgc2FsaWRhXCI7XG5jb25zdCB1OFBpeGVsVHlwZSA9IFwiOCBiaXRzIHNpbiBzaWdub1wiO1xuY29uc3QgczhQaXhlbFR5cGUgPSBcIjggYml0cyBjb24gc2lnbm9cIjtcbmNvbnN0IHUxNlBpeGVsVHlwZSA9IFwiMTYgYml0cyBzaW4gc2lnbm9cIjtcbmNvbnN0IHMxNlBpeGVsVHlwZSA9IFwiMTYgYml0cyBjb24gc2lnbm9cIjtcbmNvbnN0IHUzMlBpeGVsVHlwZSA9IFwiMzIgYml0cyBzaW4gc2lnbm9cIjtcbmNvbnN0IHMzMlBpeGVsVHlwZSA9IFwiMzIgYml0cyBjb24gc2lnbm9cIjtcbmNvbnN0IGYzMlBpeGVsVHlwZSA9IFwiMzIgYml0cyBmbG90YW50ZVwiO1xuY29uc3QgZjY0UGl4ZWxUeXBlID0gXCI2NCBiaXRzIGRvYmxlXCI7XG5jb25zdCBwcm9wZXJ0aWVzID0gXCJQcm9waWVkYWRlc1wiO1xuY29uc3QgbXVsdGlkaW1lbnNpb25hbFJ1bGVzID0gXCJSZWdsYXMgbXVsdGlkaW1lbnNpb25hbGVzXCI7XG5jb25zdCBtYXRjaFZhcmlhYmxlcyA9IFwiUmVhc29jaWFyIHZhcmlhYmxlc1wiO1xuY29uc3QgdW5pb25EaW1lbnNpb25zID0gXCJDb21iaW5hciBkaW1lbnNpb25lc1wiO1xuY29uc3QgcmFzdGVyRnVuY3Rpb25FZGl0b3IgPSB7XG5cdGludmFsaWRSRlRNZXNzYWdlOiBcIkxhIHBsYW50aWxsYSBkZSBmdW5jacOzbiByw6FzdGVyIG5vIGVzIHbDoWxpZGEuXCIsXG5cdHJmeEFyZ3NFZGl0b3I6IHtcblx0XHRvdXRwdXRSYXN0ZXI6IFwiUsOhc3RlciBkZSBzYWxpZGFcIixcblx0XHRyYXN0ZXI6IFwiQ2FsY3VsYWRvcmEgcsOhc3RlclwiLFxuXHRcdHVuc3VwcG9ydGVkRGF0YVR5cGVXYXJuaW5nOiBcIkxvcyBzaWd1aWVudGVzIGFyZ3VtZW50b3Mgbm8gc2UgdmlzdWFsaXphbiwgeWEgcXVlIG5vIHNlIGFkbWl0ZW4gYWN0dWFsbWVudGUuXCIsXG5cdFx0dW5zdXBwb3J0ZWRGdW5jdGlvbjogXCJDb250aWVuZSBmdW5jaW9uZXMgcsOhc3RlciBhY3R1YWxtZW50ZSBubyBhZG1pdGlkYXMuXCJcblx0fSxcblx0cmZ4UmFzdGVySW5wdXQ6IHtcblx0XHRzZWxlY3RMYXllcjogXCJTZWxlY2Npb25hciBjYXBhXCIsXG5cdFx0YnJvd3NlTGF5ZXJzOiBcIkV4YW1pbmFyIGNhcGFzXCIsXG5cdFx0cmZ4VmFyaWFibGU6IFwiUmFzdGVyRnVuY3Rpb25WYXJpYWJsZVwiXG5cdH0sXG5cdHJmeEJhbmRDb21iaW5hdGlvbkVkaXRvcjoge1xuXHRcdG1ldGhvZExhYmVsOiBcIk3DqXRvZG9cIixcblx0XHRiYW5kTGFiZWw6IFwiQmFuZGFcIixcblx0XHRjb21iaW5hdGlvbkxhYmVsOiBcIkNvbWJpbmFjacOzblwiXG5cdH0sXG5cdHJmeFJlbWFwR3JpZDoge1xuXHRcdG1pbmltdW06IFwiTcOtbmltb1wiLFxuXHRcdG1heGltdW06IFwiTcOheGltb1wiLFxuXHRcdG91dHB1dDogXCJTYWxpZGFcIixcblx0XHRub0RhdGE6IFwiTm9EYXRhXCIsXG5cdFx0cmVtYXBWYWx1ZXNMYWJlbDogXCJOdWV2YSByZXByZXNlbnRhY2nDs24gY2FydG9ncsOhZmljYSBkZSB2YWxvcmVzXCJcblx0fSxcblx0cmZ4TmFtZWRSYXN0ZXJFZGl0b3I6IHtcblx0XHRyYXN0ZXJWYXJpYWJsZXM6IFwiVmFyaWFibGVzIGRlIHLDoXN0ZXJcIixcblx0XHRkZWxldGVTZWxlY3RlZFZhcnM6IFwiRWxpbWluYXIgdmFyaWFibGVzIHNlbGVjY2lvbmFkYXNcIlxuXHR9LFxuXHRyZnhDbGlwcGluZ0dlb21ldHJ5OiB7XG5cdFx0Y2xpcHBpbmdMYXllcjogXCJDYXBhIGRlIHJlY29ydGVcIixcblx0XHRjbGlwcGluZ1Jhc3RlcjogXCJSw6FzdGVyIGRlIGNsaXBwaW5nXCIsXG5cdFx0Y2xpcHBpbmdHZW9tZXRyeTogXCJHZW9tZXRyw61hIGRlIHJlY29ydGVcIixcblx0XHRjdXN0b21FeHRlbnQ6IFwiRXh0ZW5zacOzbiBwZXJzb25hbGl6YWRhXCIsXG5cdFx0b3V0cHV0RXh0ZW50OiBcIkV4dGVuc2nDs24gZGUgc2FsaWRhXCIsXG5cdFx0Y3VycmVudEV4dGVudDogXCJFeHRlbnNpw7NuIGRlIG1hcGEgYWN0dWFsXCIsXG5cdFx0ZHJhd0xhYmVsOiBcIkRpYnVqYXJcIlxuXHR9LFxuXHRyZnhDdXN0b21FeHRlbnQ6IHtcblx0XHR0b3A6IFwiU3VwZXJpb3JcIixcblx0XHRyaWdodDogXCJEZXJlY2hhXCIsXG5cdFx0Ym90dG9tOiBcIkluZmVyaW9yXCIsXG5cdFx0bGVmdDogXCJJenF1aWVyZGFcIlxuXHR9LFxuXHRyZnhSYXN0ZXJBcnJheUVkaXRvcjoge1xuXHRcdG1vdmVVcDogXCJNb3ZlciBoYWNpYSBhcnJpYmFcIixcblx0XHRtb3ZlRG93bjogXCJNb3ZlciBoYWNpYSBhYmFqb1wiLFxuXHRcdHJlbW92ZTogXCJFbGltaW5hclwiXG5cdH0sXG5cdHJmeFN0YXRpc3RpY3NHcmlkOiB7XG5cdFx0c3RkRGV2OiBcIkRlc3ZpYWNpw7NuIGVzdMOhbmRhclwiLFxuXHRcdG1pbjogXCJNw61uLlwiLFxuXHRcdG1heDogXCJNw6F4LlwiLFxuXHRcdG1lYW46IFwiVmFsb3IgbWVkaW9cIlxuXHR9LFxuXHRyZnhXZWlnaHRlZFN1bVRhYmxlRWRpdG9yOiB7XG5cdFx0d2VpZ2h0ZWRTdW1UYWJsZTogXCJUYWJsYSBkZSBzdW1hcyBwb25kZXJhZGFzXCIsXG5cdFx0aWQ6IFwiSWQuXCIsXG5cdFx0bGF5ZXI6IFwiQ2FwYVwiLFxuXHRcdGZpZWxkOiBcIkNhbXBvXCIsXG5cdFx0d2VpZ2h0OiBcIlBlc29cIixcblx0XHR2YWx1ZTogXCJWYWxvclwiLFxuXHRcdHNlbGVjdExheWVyOiBcIlNlbGVjY2lvbmFyIGNhcGFcIlxuXHR9LFxuXHRyZnhXZWlnaHRlZE92ZXJsYXlUYWJsZUVkaXRvcjoge1xuXHRcdHdlaWdodGVkT3ZlcmxheVRhYmxlOiBcIlRhYmxhIFN1cGVycG9zaWNpw7NuIHBvbmRlcmFkYVwiLFxuXHRcdGlkOiBcIklkLlwiLFxuXHRcdGxheWVyOiBcIkNhcGFcIixcblx0XHRmaWVsZDogXCJDYW1wb1wiLFxuXHRcdGluZmx1ZW5jZTogXCJJbmZsdWVuY2lhXCIsXG5cdFx0c3VtT2ZJbmZsdWVuY2U6IFwiU3VtYSBkZSBpbmZsdWVuY2lhXCIsXG5cdFx0dmFsdWU6IFwiVmFsb3JcIixcblx0XHRyZW1hcFRhYmxlOiBcIlZvbHZlciBhIHJlcHJlc2VudGFyIGxhIHRhYmxhXCIsXG5cdFx0c2NhbGU6IFwiRXNjYWxhXCIsXG5cdFx0c2NhbGVzOiBcIkVzY2FsYXNcIixcblx0XHRzZWxlY3RSYXN0ZXI6IFwiU2VsZWNjaW9uYXIgcsOhc3RlclwiXG5cdH0sXG5cdHJmeEZlYXR1cmVTZWxlY3Q6IHtcblx0XHRhZGRGZWF0dXJlTGF5ZXI6IFwiQnVzY2FyIHVuYSBjYXBhIGRlIGVudGlkYWRlc1wiLFxuXHRcdGFkZFBvaW50TGF5ZXI6IFwiQnVzY2FyIHVuYSBjYXBhIGRlIHB1bnRvc1wiXG5cdH0sXG5cdHJmeEZpZWxkU2VsZWN0OiB7XG5cdFx0dmFsdWU6IFwiVmFsb3JcIixcblx0XHRjb3VudDogXCJSZWN1ZW50b1wiXG5cdH0sXG5cdHJmeEF0dHJpYnV0ZVRhYmxlOiB7XG5cdFx0dGFibGVUeXBlOiBcIlRpcG8gZGUgdGFibGFcIixcblx0XHRtYW51YWw6IFwiTWFudWFsXCIsXG5cdFx0ZXh0ZXJuYWw6IFwiRXh0ZXJub1wiLFxuXHRcdG1pblZhbDogXCJWYWxvciBtw61uaW1vXCIsXG5cdFx0bWF4VmFsOiBcIlZhbG9yIE3DoXhpbW9cIixcblx0XHRiYXNlQ2xhc3NOYW1lOiBcIk5vbWJyZSBiYXNlIGRlIGNsYXNlXCIsXG5cdFx0Y29sb3JTY2hlbWU6IFwiRXNxdWVtYSBkZSBjb2xvcmVzXCIsXG5cdFx0ZGVmYXVsdENsYXNzTmFtZTogXCJFdGlxdWV0YV9cIixcblx0XHRnZW5lcmF0ZVRhYmxlOiBcIkdlbmVyYXIgdGFibGFcIixcblx0XHRicm93c2VUYWJsZTogXCJUYWJsYSBkZSBleHBsb3JhZG9yXCIsXG5cdFx0dmFsdWU6IFwiVmFsb3JcIixcblx0XHRjbGFzc25hbWU6IFwiQ2xhc3NOYW1lXCIsXG5cdFx0Y29sb3I6IFwiQ29sb3JcIlxuXHR9LFxuXHRyZnhGaWVsZE51bWJlclN3aXRjaGFibGU6IHtcblx0XHRudW1iZXI6IFwiTnVtw6lyaWNvXCIsXG5cdFx0ZmllbGQ6IFwiQ2FtcG9cIixcblx0XHRzdHJpbmc6IFwiQ2FkZW5hXCIsXG5cdFx0bGluZWFyVW5pdDogXCJVbmlkYWQgbGluZWFsXCJcblx0fSxcblx0cmZ4UHJvcGVydHlTZXQ6IHtcblx0XHRuYW1lOiBcIk5vbWJyZVwiLFxuXHRcdHZhbHVlOiBcIlZhbG9yXCJcblx0fSxcblx0cmZ4Q29udmVyc2lvbkdyaWQ6IHtcblx0XHRzaXplOiBcIlRhbWHDsW9cIlxuXHR9LFxuXHRyZnhUcmFuc3Bvc2VCaXQ6IHtcblx0XHRiaXRQYXR0ZXJuOiBcIlBhdHLDs24gZGUgYml0c1wiLFxuXHRcdG91dHB1dEJpdDogXCJCaXQgZGUgc2FsaWRhXCIsXG5cdFx0aW5wdXRCaXQ6IFwiQml0IGRlIGVudHJhZGFcIlxuXHR9LFxuXHRyZnhTcGF0aWFsUmVmZXJlbmNlOiB7XG5cdFx0cGxhY2VIb2xkZXI6IFwiUmVmaW5hciBwb3IgcGFsYWJyYSBjbGF2ZVwiLFxuXHRcdGNvb3JkaW5hdGVTeXN0ZW06IFwiU2lzdGVtYSBkZSBjb29yZGVuYWRhc1wiLFxuXHRcdGdjczogXCJTaXN0ZW1hIGRlIGNvb3JkZW5hZGFzIGdlb2dyw6FmaWNhc1wiLFxuXHRcdHBjczogXCJTaXN0ZW1hIGRlIGNvb3JkZW5hZGFzIHByb3llY3RhZGFzXCIsXG5cdFx0dmNzOiBcIlNpc3RlbWEgZGUgY29vcmRlbmFkYXMgdmVydGljYWxcIlxuXHR9XG59O1xuY29uc3QgcmZ4TGljZW5zZUluZm8gPSBcIkVzdGEgcGxhbnRpbGxhIGRlIGZ1bmNpw7NuIHLDoXN0ZXIgc2UgcHVlZGUgdXNhciBwYXJhIHByb2Nlc2FyIHN1cyBpbcOhZ2VuZXMgbWVkaWFudGUgQXJjR0lTIEltYWdlIFNlcnZlci5cIjtcbmNvbnN0IHJhc3RlckZ1bmN0aW9ucyA9IHtcblx0cmZ4OiB7XG5cdFx0YUNvc0hOYW1lOiBcIkFyY29jb3Nlbm8gaGlwZXJiw7NsaWNvIChBQ29zSClcIixcblx0XHRhQ29zSFNuaXA6IFwiQ2FsY3VsYSBlbCBjb3Nlbm8gaW52ZXJzbyBoaXBlcmLDs2xpY28gZGUgY2VsZGFzIGVuIHVuIHLDoXN0ZXIuXCIsXG5cdFx0YUNvc0hEZXNjOiBcIkxhIGZ1bmNpw7NuIGNhbGN1bGEgZWwgY29zZW5vIGludmVyc28gaGlwZXJiw7NsaWNvIGRlIGxvcyBww614ZWxlcyBkZSB1biByw6FzdGVyLlwiLFxuXHRcdGFDb3NOYW1lOiBcIkFyY29jb3Nlbm8gKEFDb3MpXCIsXG5cdFx0YUNvc1NuaXA6IFwiQ2FsY3VsYSBlbCBjb3Nlbm8gaW52ZXJzbyBkZSBsb3MgcMOteGVsZXMgZGUgdW4gcsOhc3Rlci5cIixcblx0XHRhQ29zRGVzYzogXCJFc3RhIGZ1bmNpw7NuIHLDoXN0ZXIgY2FsY3VsYSBlbCBjb3Nlbm8gaW52ZXJzbyBkZSBsYXMgY2VsZGFzIGRlIHVuIHLDoXN0ZXIuIEVuIG1hdGVtw6F0aWNhcywgdG9kYXMgbGFzIGZ1bmNpb25lcyB0cmlnb25vbcOpdHJpY2FzIHRpZW5lbiB1biByYW5nbyBkZWZpbmlkbyBkZSB2YWxvcmVzIGRlIGVudHJhZGEgdsOhbGlkb3MsIGxsYW1hZG8gZG9taW5pby4gTG9zIHZhbG9yZXMgZGUgc2FsaWRhIGRlIGNhZGEgZnVuY2nDs24gdGFtYmnDqW4gdGllbmVuIHVuIHJhbmdvIGRlZmluaWRvLiBQYXJhIGVzdGEgaGVycmFtaWVudGEsIGVsIGRvbWluaW8gZXMgWy0xLCAxXSB5IGVsIHJhbmdvIGVzIFswLCBwaV0uXCIsXG5cdFx0YVNpbkhOYW1lOiBcIkFyY29zZW5vIGhpcGVyYsOzbGljbyAoQVNpbkgpXCIsXG5cdFx0YVNpbkhTbmlwOiBcIkNhbGN1bGEgZWwgc2VubyBpbnZlcnNvIGhpcGVyYsOzbGljbyBkZSBjZWxkYXMgZW4gdW4gcsOhc3Rlci5cIixcblx0XHRhU2luSERlc2M6IFwiTGEgZnVuY2nDs24gY2FsY3VsYSBlbCBhcmNvc2VubyBpbnZlcnNvIGhpcGVyYsOzbGljbyBkZSBsb3MgcMOteGVsZXMgZGUgdW4gcsOhc3Rlci5cIixcblx0XHRhU2luTmFtZTogXCJBcmNvc2VubyAoQVNpbilcIixcblx0XHRhU2luU25pcDogXCJDYWxjdWxhIGVsIHNlbm8gaW52ZXJzbyBkZSBjZWxkYXMgZW4gdW4gcsOhc3Rlci5cIixcblx0XHRhU2luRGVzYzogXCJMYSBmdW5jacOzbiBjYWxjdWxhIGVsIHNlbm8gaW52ZXJzbyBkZSBsb3MgcMOteGVsZXMgZGUgdW4gcsOhc3Rlci5cIixcblx0XHRhVGFuMk5hbWU6IFwiQXJjb3RhbmdlbnRlICh4L3kpIChBVGFuMilcIixcblx0XHRhVGFuMlNuaXA6IFwiQ2FsY3VsYSBsYSB0YW5nZW50ZSBpbnZlcnNhIChiYXNhZGEgZW4geCx5KSBkZSBjZWxkYXMgZW4gdW4gcsOhc3Rlci5cIixcblx0XHRhVGFuMkRlc2M6IFwiTGEgZnVuY2nDs24gY2FsY3VsYSBsYSB0YW5nZW50ZSBpbnZlcnNhIChiYXNhZGEgZW4geCx5KSBkZSBsb3MgcMOteGVsZXMgZGUgdW4gcsOhc3Rlci5cIixcblx0XHRhVGFuSE5hbWU6IFwiQXJjb3RhbmdlbnRlIGhpcGVyYsOzbGljYSAoQVRhbkgpXCIsXG5cdFx0YVRhbkhTbmlwOiBcIkNhbGN1bGEgbGEgdGFuZ2VudGUgaW52ZXJzYSBoaXBlcmLDs2xpY2EgZGUgY2VsZGFzIGVuIHVuIHLDoXN0ZXIuXCIsXG5cdFx0YVRhbkhEZXNjOiBcIkxhIGZ1bmNpw7NuIGNhbGN1bGEgbGEgdGFuZ2VudGUgaW52ZXJzYSBoaXBlcmLDs2xpY2EgZGUgbG9zIHDDrXhlbGVzIGRlIHVuIHLDoXN0ZXIuXCIsXG5cdFx0YVRhbk5hbWU6IFwiQXJjb3RhbmdlbnRlIChBVGFuKVwiLFxuXHRcdGFUYW5TbmlwOiBcIkNhbGN1bGEgbGEgdGFuZ2VudGUgaW52ZXJzYSBkZSBjZWxkYXMgZW4gdW4gcsOhc3Rlci5cIixcblx0XHRhVGFuRGVzYzogXCJMYSBmdW5jacOzbiBjYWxjdWxhIGxhIHRhbmdlbnRlIGludmVyc2EgZGUgbG9zIHDDrXhlbGVzIGRlIHVuIHLDoXN0ZXIuXCIsXG5cdFx0YWJzTmFtZTogXCJWYWxvciBhYnNvbHV0b1wiLFxuXHRcdGFic1NuaXA6IFwiQ2FsY3VsYSBlbCB2YWxvciBhYnNvbHV0byBkZSBsYXMgY2VsZGFzIGRlIHVuIHLDoXN0ZXIuXCIsXG5cdFx0YWJzRGVzYzogXCJMYSBmdW5jacOzbiBBYnMgY2FsY3VsYSBlbCB2YWxvciBhYnNvbHV0byBkZSBsb3MgcMOteGVsZXMgZGUgdW4gcsOhc3Rlci5cIixcblx0XHRyZWZsZWN0YW5jZU5hbWU6IFwiUmVmbGVjdGFuY2lhIGFwYXJlbnRlXCIsXG5cdFx0cmVmbGVjdGFuY2VTbmlwOiBcIkNvbnZpZXJ0ZSBsYXMgaW3DoWdlbmVzIHNpbiBwcm9jZXNhciBlbiB2YWxvcmVzIGRlIFBhcnRlIHN1cGVyaW9yIGRlIGxhIGF0bcOzc2ZlcmEgdGVuaWVuZG8gZW4gY3VlbnRhIGNhcmFjdGVyw61zdGljYXMgZGVsIHNlbnNvciwgbGEgcG9zaWNpw7NuIGRlbCBzb2wgeSBlbCBtb21lbnRvIGRlIGNhcHR1cmEuXCIsXG5cdFx0cmVmbGVjdGFuY2VEZXNjOiBcIkVzdGEgZnVuY2nDs24gYWp1c3RhIGxvcyB2YWxvcmVzIGRlIG7Dum1lcm8gZGlnaXRhbCAoRE4pIGRlIGJyaWxsbyBkZSBsYSBpbWFnZW4gcGFyYSBhbGd1bm9zIGRlIGxvcyBzZW5zb3JlcyBkZSBzYXTDqWxpdGVzLiBMb3MgYWp1c3RlcyBzZSBiYXNhbiBlbiBsYSBlbGV2YWNpw7NuIGRlbCBzb2wsIGxhIGZlY2hhIGRlIGFkcXVpc2ljacOzbiB5IGxhcyBwcm9waWVkYWRlcyBkZWwgc2Vuc29yIHBhcmEgY29uZmlndXJhciBsYSBnYW5hbmNpYSB5IGVsIHNlc2dvIGRlIGNhZGEgYmFuZGEuIEVzdGEgZnVuY2nDs24gc2UgdXNhIHBhcmEgYWp1c3RhciBsb3MgdmFsb3JlcyBkZSByZWZsZWN0YW5jaWEgbyBicmlsbG8gZGUgYWxndW5hcyBpbcOhZ2VuZXMgZGUgc2F0w6lsaXRlIGVuIGZ1bmNpw7NuIGRlIGxhIGlsdW1pbmFjacOzbiBkZSBsYSBlc2NlbmEgeSBkZSBsb3MgYWp1c3RlcyBkZSBnYW5hbmNpYSBkZWwgc2Vuc29yLiBMYXMgaW3DoWdlbmVzIHNlIGFqdXN0YW4gYSB1bmEgY29uZGljacOzbiBkZSBpbHVtaW5hY2nDs24gdGXDs3JpY2FtZW50ZSBjb23Dum4sIHBvciBsbyBxdWUgZGViZXLDrWEgaGFiZXIgbWVub3MgdmFyaWFjacOzbiBlbnRyZSBsYXMgZXNjZW5hcyBkZSBkaWZlcmVudGVzIGZlY2hhcyB5IGRlIGRpZmVyZW50ZXMgc2Vuc29yZXMuIEVzdG8gcHVlZGUgc2VyIMO6dGlsIHBhcmEgbGEgY2xhc2lmaWNhY2nDs24gZGUgaW3DoWdlbmVzLCBlbCBiYWxhbmNlIGRlIGNvbG9yIHkgbGEgY3JlYWNpw7NuIGRlIG1vc2FpY29zLiBFc3RhIGZ1bmNpw7NuIHNvbG8gc2UgcHVlZGUgdXNhciBjb24gaW3DoWdlbmVzIGNvbmNyZXRhcy4gTG9zIHNlbnNvcmVzIHbDoWxpZG9zIHNvbiBMYW5kc2F0IE1TUywgTGFuZHNhdCBUTSwgTGFuZHNhdCBFVE0rLCBMYW5kc2F0IDgsIElLT05PUywgUXVpY2tCaXJkLCBHZW9FeWUtMSwgUmFwaWRFeWUsIERNQ2lpLCBXb3JsZFZpZXctMSwgV29ybGRWaWV3LTIsIFNQT1QgNiB5IFBsZWlhZGVzLjxkaXY+PGJyLz5MYSBmdW5jacOzbiByZWFsaXphIGRvcyBjb3JyZWNjaW9uZXMuIExhIHByaW1lcmEgc2UgYmFzYSBlbiBsYSBjb25maWd1cmFjacOzbiBkZSBnYW5hbmNpYS4gTG9zIHZhbG9yZXMgZGUgYnJpbGxvIG9yaWdpbmFsZXMgc2UgdnVlbHZlbiBhIGNyZWFyIGEgcGFydGlyIGRlIGxvcyB2YWxvcmVzIGRlIGxhIGltYWdlbiBhbCByZXZlcnRpciBsYXMgZWN1YWNpb25lcyBkZSBnYW5hbmNpYS4gTGEgc2VndW5kYSBjb3JyZWNjacOzbiB0aWVuZSBxdWUgdmVyIGNvbiBsYXMgZGlmZXJlbmNpYXMgZW4gZWwgw6FuZ3VsbyBkZWwgc29sIHkgZWwgYnJpbGxvLiBMb3MgdmFsb3JlcyBkZSBicmlsbG8gb3JpZ2luYWxlcyBzZSBhanVzdGFuIGEgdW5hIGNvbmRpY2nDs24gZGUgaWx1bWluYWNpw7NuIGNvbcO6biBtZWRpYW50ZSBsYSBub3JtYWxpemFjacOzbiBkZSBsYXMgZXNjZW5hcyBjYXB0dXJhZGFzIGVuIGNvbmRpY2lvbmVzIGRlIGlsdW1pbmFjacOzbiB2YXJpYWJsZXMuIEVuIGdlbmVyYWwsIG1pZW50cmFzIHF1ZSBlbCB0aXBvIGRlIGRhdG9zIGRlIGltYWdlbiBkZSBzYWxpZGEgY29pbmNpZGUgY29uIGVsIGRlIGVudHJhZGEsIGxvcyB2YWxvcmVzIGRlIHNhbGlkYSBzb24gbcOhcyBiYWpvcyBxdWUgbG9zIGRlIGVudHJhZGEgeSBlc3TDoW4gbGltaXRhZG9zIGFsIHJhbmdvIGRlIGRhdG9zIHbDoWxpZG8uPC9kaXY+XCIsXG5cdFx0YXJnU3RhdGlzdGljc05hbWU6IFwiQXJnU3RhdGlzdGljc1wiLFxuXHRcdGFyZ1N0YXRpc3RpY3NTbmlwOiBcIkNhbGN1bGEgZXN0YWTDrXN0aWNhcyBhcmcsIGNvbW8gQXJnIE1heCwgQXJnIE1pbiwgQXJnIE1lZGlvIHkgRHVyYWNpw7NuLlwiLFxuXHRcdGFyZ1N0YXRpc3RpY3NEZXNjOiBcIkVzdGEgZnVuY2nDs24gY29tcHV0YSBlc3RhZMOtc3RpY2FzIGFyZy4gRW4gbGEgZnVuY2nDs24gQXJnU3RhdGlzdGljcyBleGlzdGVuIGN1YXRybyBtw6l0b2RvczogQXJnTWF4LCBBcmdNaW4sIEFyZ01lZGlhbiB5IER1cmF0aW9uLlwiLFxuXHRcdGFyaXRobWV0aWNOYW1lOiBcIkFyaXRtw6l0aWNhXCIsXG5cdFx0YXJpdGhtZXRpY1NuaXA6IFwiUmVhbGl6YSB1bmEgb3BlcmFjacOzbiBhcml0bcOpdGljYSBlbnRyZSBkb3MgcsOhc3RlcmVzIG8gdW4gcsOhc3RlciB5IHVuIGVzY2FsYXIuXCIsXG5cdFx0YXJpdGhtZXRpY0Rlc2M6IFwiTGEgZnVuY2nDs24gYXJpdG3DqXRpY2EgcmVhbGl6YSB1bmEgb3BlcmFjacOzbiBhcml0bcOpdGljYSBlbnRyZSBkb3MgcsOhc3RlcmVzIG8gdW4gcsOhc3RlciB5IHVuIGVzY2FsYXIgeSB2aWNldmVyc2EuXCIsXG5cdFx0YXNwZWN0U2xvcGVOYW1lOiBcIk9yaWVudGFjacOzbi1wZW5kaWVudGVcIixcblx0XHRhc3BlY3RTbG9wZVNuaXA6IFwiQ3JlYSB1biByw6FzdGVyIHF1ZSBtdWVzdHJhIGFsIG1pc21vIHRpZW1wbyBsYSBvcmllbnRhY2nDs24gKGRpcmVjY2nDs24pIHkgbGEgcGVuZGllbnRlIChpbmNsaW5hY2nDs24pIGRlIHVuYSBzdXBlcmZpY2llIGNvbnRpbnVhLCByZXByZXNlbnRhZG8gZW4gdW4gbW9kZWxvIGRpZ2l0YWwgZGUgZWxldmFjacOzbi5cIixcblx0XHRhc3BlY3RTbG9wZURlc2M6IFwiTGEgZnVuY2nDs24gUGVuZGllbnRlIGRlIG9yaWVudGFjacOzbiBjcmVhIHVuYSBjYXBhIHLDoXN0ZXIgcXVlIHZpc3VhbGl6YSBzaW11bHTDoW5lYW1lbnRlIGxhIG9yaWVudGFjacOzbiB5IGxhIHBlbmRpZW50ZSBkZSB1bmEgc3VwZXJmaWNpZS4gTGEgb3JpZW50YWNpw7NuIGlkZW50aWZpY2EgbGEgZGlyZWNjacOzbiBkZSBsYSBwZW5kaWVudGUgZGVzY2VuZGVudGUgZGUgbGEgdGFzYSBkZSBjYW1iaW8gbcOheGltYSBlbiB1biB2YWxvciBkZXNkZSBjYWRhIHDDrXhlbCBoYWNpYSBzdXMgdmVjaW5vcy4gTGEgb3JpZW50YWNpw7NuIHB1ZWRlIHBlbnNhcnNlIGNvbW8gbGEgZGlyZWNjacOzbiBkZSBsYSBwZW5kaWVudGUuIExvcyB2YWxvcmVzIGRlbCByw6FzdGVyIGRlIHNhbGlkYSBzZXLDoW4gbGEgZGlyZWNjacOzbiBkZSBicsO6anVsYSBkZSBsYSBvcmllbnRhY2nDs24sIHJlcHJlc2VudGFkYSBwb3IgdW4gdG9ubyAoY29sb3IpLiBMYSBwZW5kaWVudGUgcmVwcmVzZW50YSBsYSB0YXNhIGRlIGNhbWJpbyBkZSBlbGV2YWNpw7NuIHBhcmEgY2FkYSBww614ZWwgZGUgbW9kZWxvIGRpZ2l0YWwgZGUgZWxldmFjacOzbiAoREVNKS4gTGEgcGVuZGllbnRlIHJlcHJlc2VudGEgbGEgaW5jbGluYWNpw7NuIGRlIGxhIHN1cGVyZmljaWUgeSBzZSBzaW1ib2xpemEgZW4gdHJlcyBjbGFzZXMgcXVlIHNlIG11ZXN0cmFuIG1lZGlhbnRlIGxhIHNhdHVyYWNpw7NuICh2aXZlemEpIGRlbCBjb2xvci48ZGl2Pjxici8+TG9zIHZhbG9yZXMgZGUgcMOteGVsIGRlbCByw6FzdGVyIGRlIG9yaWVudGFjacOzbi1wZW5kaWVudGUgZGUgc2FsaWRhIHJlZmxlamFuIHVuYSBjb21iaW5hY2nDs24gZGUgbGEgb3JpZW50YWNpw7NuIHkgbGEgcGVuZGllbnRlLiBMb3MgcMOteGVsZXMgY29uIHZhbG9yZXMgaW5mZXJpb3JlcyBhIDIwIHNlIGNvbnNpZGVyYW4gcGxhbm9zIHkgc2UgbXVlc3RyYW4gZW4gZ3Jpcy4gTG9zIHZhbG9yZXMgZGUgb3JpZW50YWNpw7NuLXBlbmRpZW50ZSBkZSAyMSB5IHN1cGVyaW9yZXMgc2UgbW9zdHJhcsOhbiBjb24gc2F0dXJhY2lvbmVzIHZhcmlhYmxlcywgZGUgbGEgc2lndWllbnRlIGZvcm1hOiAyMSBhIDMwOiDigJRzYXR1cmFjacOzbiBkZSBwZW5kaWVudGUgYmFqYSwgMzEgYSA0MDog4oCUc2F0dXJhY2nDs24gZGUgcGVuZGllbnRlIG1lZGlhLCA0MSB5IHN1cGVyaW9yZXM6IOKAlHNhdHVyYWNpw7NuIGRlIHBlbmRpZW50ZSBhbHRhPC9kaXY+XCIsXG5cdFx0YXNwZWN0TmFtZTogXCJPcmllbnRhY2nDs25cIixcblx0XHRhc3BlY3RTbmlwOiBcIk11ZXN0cmEgbGEgZGlyZWNjacOzbiBkZSB1biBww614ZWwsIGRvbmRlIDAgZXMgZWwgbm9ydGUgeSBsb3Mgw6FuZ3Vsb3MgYXVtZW50YW4gZW4gZWwgc2VudGlkbyBkZSBsYXMgYWd1amFzIGRlbCByZWxvaiBoYXN0YSAzNjAuXCIsXG5cdFx0YXNwZWN0RGVzYzogXCJMYSBmdW5jacOzbiBPcmllbnRhY2nDs24gaWRlbnRpZmljYSBsYSBkaXJlY2Npw7NuIGRlIGxhIHBlbmRpZW50ZSBkZXNjZW5kZW50ZSBkZSBsYSB0YXNhIGRlIGNhbWJpbyBtw6F4aW1hIGVuIHVuIHZhbG9yIGRlc2RlIGNhZGEgY2VsZGEgaGFjaWEgc3VzIHZlY2luYXMuIExhIG9yaWVudGFjacOzbiBwdWVkZSBwZW5zYXJzZSBjb21vIGxhIGRpcmVjY2nDs24gZGUgbGEgcGVuZGllbnRlLiBMb3MgdmFsb3JlcyBkZWwgcsOhc3RlciBkZSBzYWxpZGEgc2Vyw6FuIGxhIGRpcmVjY2nDs24gZGUgYnLDump1bGEgZGUgbGEgb3JpZW50YWNpw7NuLjxkaXY+PGJyLz5MYSBlbnRyYWRhIHBhcmEgZXN0YSBmdW5jacOzbiBlcyBlbCByw6FzdGVyIGRlIGVudHJhZGEuIExhIGZ1bmNpw7NuIE9yaWVudGFjacOzbiBzZSBhcGxpY2EgZnJlY3VlbnRlbWVudGUgYSB1biBtb2RlbG8gZGlnaXRhbCBkZSBlbGV2YWNpw7NuIChERU0pLiBEZSBmb3JtYSBwcmVkZXRlcm1pbmFkYSwgbGEgb3JpZW50YWNpw7NuIGFwYXJlY2UgY29tbyB1bmEgaW1hZ2VuIGVuIGVzY2FsYSBkZSBncmlzZXMuIFB1ZWRlIGFncmVnYXIgbGEgZnVuY2nDs24gTWFwYSBkZSBjb2xvciBwYXJhIGVzcGVjaWZpY2FyIHVuYSBjb21iaW5hY2nDs24gZGUgY29sb3JlcyBkZXRlcm1pbmFkYSBvIHBlcm1pdGlyIGEgbGEgcGVyc29uYSBxdWUgdmlzdWFsaXphIGVsIG1vc2FpY28gbW9kaWZpY2FyIGxhIHNpbWJvbG9nw61hIGNvbiBzdSBwcm9waW8gZXNxdWVtYSBkZSBjb2xvcmVzLjwvZGl2PlwiLFxuXHRcdHRhYmxlTmFtZTogXCJUYWJsYSBkZSBhdHJpYnV0b3NcIixcblx0XHR0YWJsZVNuaXA6IFwiVXRpbGl6YSB1bmEgdGFibGEgcGFyYSBkYXIgbm9tYnJlIHkgc2ltYm9saXphciBsb3MgdmFsb3JlcyBkZSB1biBkYXRhc2V0LiBMYXMgY29sdW1uYXMgZGUgbGEgdGFibGEgZXN0w6FuIGRlbGltaXRhZGFzIHBvciBjb21hczogUGl4ZWxWYWx1ZSwgQXR0cmlidXRlTmFtZSwgUmVkVmFsdWUsIEdyZWVuVmFsdWUsIEJsdWVWYWx1ZS5cIixcblx0XHR0YWJsZURlc2M6IFwiTGEgZnVuY2nDs24gVGFibGEgZGUgYXRyaWJ1dG9zIGxlIHBlcm1pdGUgZGVmaW5pciB1bmEgdGFibGEgZGUgYXRyaWJ1dG9zIHBhcmEgc2ltYm9saXphciB1biBkYXRhc2V0IHLDoXN0ZXIgbyBkYXRhc2V0IGRlIG1vc2FpY28gZGUgYmFuZGEgw7puaWNhLiA8ZGl2Pjxici8+RXMgw7p0aWwgY3VhbmRvIGRlc2VhIHByZXNlbnRhciBpbcOhZ2VuZXMgcXVlIHNlIGhhbiBzb21ldGlkbyBhIHVuYSBjbGFzaWZpY2FjacOzbiBkZWwgdXNvIGRlbCBzdWVsbywgcG9yIGVqZW1wbG8sIHN1ZWxvIGRlbCBib3NxdWUsIHBhbnRhbm8sIHN1ZWxvcyBkZSBjdWx0aXZvIHkgdXJiYW5vLiBBZGVtw6FzLCBzaSBzdSB0YWJsYSBjb250aWVuZSBjYW1wb3MgZGVub21pbmFkb3Mgcm9qbywgdmVyZGUgeSBhenVsLCBsb3MgdmFsb3JlcyBkZW50cm8gZGUgZXNvcyBjYW1wb3Mgc2UgdXRpbGl6YXLDoW4gY29tbyB1biBtYXBhIGRlIGNvbG9yIGFsIHJlcHJlc2VudGFyIGVuIHBhbnRhbGxhIGxhIGltYWdlbi48L2Rpdj5cIixcblx0XHRiYW5kQXJpdGhtZXRpY05hbWU6IFwiQXJpdG3DqXRpY2EgZGUgYmFuZGFcIixcblx0XHRiYW5kQXJpdGhtZXRpY1NuaXA6IFwiQ2FsY3VsYSDDrW5kaWNlcyB1c2FuZG8gZsOzcm11bGFzIHByZWRlZmluaWRhcyBvIHVuYSBleHByZXNpw7NuIGRlZmluaWRhIHBvciBlbCB1c3VhcmlvLlwiLFxuXHRcdGJhbmRBcml0aG1ldGljRGVzYzogXCJMYSBmdW5jacOzbiBBcml0bcOpdGljYSBkZSBiYW5kYSByZWFsaXphIHVuYSBvcGVyYWNpw7NuIGFyaXRtw6l0aWNhIGVuIGxhcyBiYW5kYXMgZGUgdW4gZGF0YXNldCByw6FzdGVyLiBQdWVkZSBlbGVnaXIgYWxnb3JpdG1vcyBwcmVkZWZpbmlkb3MgbyBwdWVkZSBpbnRyb2R1Y2lyIHN1IHByb3BpYSBmw7NybXVsYSBkZSBsw61uZWEgw7puaWNhLiBMb3Mgb3BlcmFkb3JlcyBwZXJtaXRpZG9zIHNvbiAtLCssLywqIHkgdW5hcmlvIC0uXCIsXG5cdFx0dGhyZXNob2xkTmFtZTogXCJEZWZpbmljacOzbiBkZSB1bWJyYWwgYmluYXJpb1wiLFxuXHRcdHRocmVzaG9sZFNuaXA6IFwiT3JnYW5pemEgZGF0b3MgY29udGludW9zIGVuIGxvcyB2YWxvcmVzIGRlIHByaW1lciBwbGFubyB5IGRlIGZvbmRvIG1pbmltaXphbmRvIGxhIGNvdmFyaWFuemEgZW50cmUgbGFzIGRvcyBjbGFzZXMuXCIsXG5cdFx0dGhyZXNob2xkRGVzYzogXCJDdWFuZG8gdW4gZGF0YXNldCByw6FzdGVyIHRpZW5lIHVuYSBkaXN0cmlidWNpw7NuIGJpbW9kYWwsIGVzdGEgZnVuY2nDs24gY3JlYSB1biBudWV2byByw6FzdGVyIHF1ZSBkaXZpZGUgbG9zIGRhdG9zIGVuIGRvcyBjbGFzZXMgZGlzdGludGFzLiBDcmVhIHVuYSBjbGFzZSBkZSB2YWxvciBiYWpvLCBxdWUgc2UgbXVlc3RyYSBjb24gcMOteGVsZXMgbmVncm9zLCB5IHVuYSBjbGFzZSBkZSB2YWxvciBhbHRvLCBxdWUgc2UgbXVlc3RyYSBjb24gcMOteGVsZXMgYmxhbmNvcy5cIixcblx0XHRiaXR3aXNlQW5kTmFtZTogXCJCaXR3aXNlIEFuZFwiLFxuXHRcdGJpdHdpc2VBbmRTbmlwOiBcIlJlYWxpemEgdW5hIG9wZXJhY2nDs24gQml0d2lzZSBBbmQgKFkgYml0IGEgYml0KSBzb2JyZSBsb3MgdmFsb3JlcyBiaW5hcmlvcyBkZSBkb3MgcsOhc3RlcmVzIGRlIGVudHJhZGEuXCIsXG5cdFx0Yml0d2lzZUFuZERlc2M6IFwiQml0d2lzZSBBbmQgcmVhbGl6YSBsYSBvcGVyYWNpw7NuIEJpdHdpc2UgQW5kIChZIGJpdCBhIGJpdCkgc29icmUgbG9zIHZhbG9yZXMgYmluYXJpb3MgZGUgZG9zIHLDoXN0ZXJlcyBkZSBlbnRyYWRhLlwiLFxuXHRcdGJpdHdpc2VMZWZ0U2hpZnROYW1lOiBcIkJpdHdpc2UgTGVmdCBTaGlmdFwiLFxuXHRcdGJpdHdpc2VMZWZ0U2hpZnRTbmlwOiBcIlJlYWxpemEgdW5hIG9wZXJhY2nDs24gZGVsIG3DqXRvZG8gQml0d2lzZSBMZWZ0IFNoaWZ0IHNvYnJlIGxvcyB2YWxvcmVzIGJpbmFyaW9zIGRlIGRvcyByw6FzdGVyZXMgZGUgZW50cmFkYS5cIixcblx0XHRiaXR3aXNlTGVmdFNoaWZ0RGVzYzogXCJCaXR3aXNlIExlZnQgU2hpZnQgcmVhbGl6YSB1bmEgb3BlcmFjacOzbiBkZWwgbcOpdG9kbyBCaXR3aXNlIExlZnQgU2hpZnQgc29icmUgbG9zIHZhbG9yZXMgYmluYXJpb3MgZGUgZG9zIHLDoXN0ZXJlcyBkZSBlbnRyYWRhLlwiLFxuXHRcdGJpdHdpc2VOb3ROYW1lOiBcIkJpdHdpc2UgTm90XCIsXG5cdFx0Yml0d2lzZU5vdFNuaXA6IFwiUmVhbGl6YSB1bmEgb3BlcmFjacOzbiBCaXR3aXNlIE5vdCAoY29tcGxlbWVudG8pIHNvYnJlIHZhbG9yZXMgYmluYXJpb3MgZGUgZG9zIHLDoXN0ZXJlcyBkZSBlbnRyYWRhLlwiLFxuXHRcdGJpdHdpc2VOb3REZXNjOiBcIkxhIGZ1bmNpw7NuIHJlYWxpemEgdW5hIG9wZXJhY2nDs24gQml0d2lzZSBOb3QgKGNvbXBsZW1lbnRvKSBzb2JyZSBlbCB2YWxvciBiaW5hcmlvIGRlIHVuIHLDoXN0ZXIgZGUgZW50cmFkYS5cIixcblx0XHRiaXR3aXNlT3JOYW1lOiBcIkJpdHdpc2UgT3JcIixcblx0XHRiaXR3aXNlT3JTbmlwOiBcIlJlYWxpemEgdW5hIG9wZXJhY2nDs24gQml0d2lzZSBPciBzb2JyZSBsb3MgdmFsb3JlcyBiaW5hcmlvcyBkZSBkb3MgcsOhc3RlcmVzIGRlIGVudHJhZGEuXCIsXG5cdFx0Yml0d2lzZU9yRGVzYzogXCJMYSBmdW5jacOzbiByZWFsaXphIHVuYSBvcGVyYWNpw7NuIEJpdHdpc2UgT3Igc29icmUgbG9zIHZhbG9yZXMgYmluYXJpb3MgZGUgZG9zIHLDoXN0ZXJlcyBkZSBlbnRyYWRhLiBcIixcblx0XHRiaXR3aXNlUmlnaHRTaGlmdE5hbWU6IFwiQml0d2lzZSBSaWdodCBTaGlmdFwiLFxuXHRcdGJpdHdpc2VSaWdodFNoaWZ0U25pcDogXCJSZWFsaXphIHVuYSBvcGVyYWNpw7NuIEJpdHdpc2UgUmlnaHQgU2hpZnQgc29icmUgbG9zIHZhbG9yZXMgYmluYXJpb3MgZGUgZG9zIHLDoXN0ZXJlcyBkZSBlbnRyYWRhLlwiLFxuXHRcdGJpdHdpc2VSaWdodFNoaWZ0RGVzYzogXCJMYSBmdW5jacOzbiByZWFsaXphIHVuYSBvcGVyYWNpw7NuIEJpdHdpc2UgUmlnaHQgU2hpZnQgc29icmUgbG9zIHZhbG9yZXMgYmluYXJpb3MgZGUgZG9zIHLDoXN0ZXJlcyBkZSBlbnRyYWRhLlwiLFxuXHRcdGJpdHdpc2VYb3JOYW1lOiBcIkJpdHdpc2UgWE9yXCIsXG5cdFx0Yml0d2lzZVhvclNuaXA6IFwiUmVhbGl6YSB1bmEgb3BlcmFjacOzbiBCaXR3aXNlIGVYY2x1c2l2ZSBPciBzb2JyZSBsb3MgdmFsb3JlcyBiaW5hcmlvcyBkZSBkb3MgcsOhc3RlcmVzIGRlIGVudHJhZGEuXCIsXG5cdFx0Yml0d2lzZVhvckRlc2M6IFwiTGEgZnVuY2nDs24gcmVhbGl6YSB1bmEgb3BlcmFjacOzbiBCaXR3aXNlIGVYY2x1c2l2ZSBPciBzb2JyZSBsb3MgdmFsb3JlcyBiaW5hcmlvcyBkZSBkb3MgcsOhc3RlcmVzIGRlIGVudHJhZGEuXCIsXG5cdFx0Ym9vbGVhbkFuZE5hbWU6IFwiQm9vbGVhbmEgQW5kXCIsXG5cdFx0Ym9vbGVhbkFuZFNuaXA6IFwiUmVhbGl6YSB1bmEgb3BlcmFjacOzbiBCb29sZWFuYSBBbmQgc29icmUgbG9zIHZhbG9yZXMgZGUgY2VsZGEgZGUgZG9zIHLDoXN0ZXJlcyBkZSBlbnRyYWRhLiBTaSBsb3MgZG9zIHZhbG9yZXMgZGUgZW50cmFkYSBzb24gdmVyZGFkZXJvcyAoZGlzdGludG9zIGRlIGNlcm8pLCBlbCB2YWxvciBkZSBzYWxpZGEgZXMgMS4gU2kgdW5hIG8gYW1iYXMgZW50cmFkYXMgc29uIGZhbHNhcyAoY2VybyksIGxhIHNhbGlkYSBlcyAwLlwiLFxuXHRcdGJvb2xlYW5BbmREZXNjOiBcIkxhIGZ1bmNpw7NuIHJlYWxpemEgdW5hIG9wZXJhY2nDs24gQm9vbGVhbiBBbmQgc29icmUgbG9zIHZhbG9yZXMgZGUgbG9zIHDDrXhlbGVzIGRlIGRvcyBlbnRyYWRhcy4gU2kgbG9zIGRvcyB2YWxvcmVzIGRlIGVudHJhZGEgc29uIHZlcmRhZGVyb3MgKGRpc3RpbnRvcyBkZSBjZXJvKSwgZWwgdmFsb3IgZGUgc2FsaWRhIGVzIDEuIFNpIHVubyBvIGxvcyBkb3MgdmFsb3JlcyBkZSBlbnRyYWRhIHNvbiBmYWxzb3MgKGNlcm8pLCBlbCB2YWxvciBkZSBzYWxpZGEgZXMgMC4gXCIsXG5cdFx0Ym9vbGVhbk5vdE5hbWU6IFwiQm9vbGVhbmEgTm90XCIsXG5cdFx0Ym9vbGVhbk5vdFNuaXA6IFwiUmVhbGl6YSB1bmEgb3BlcmFjacOzbiBib29sZWFuYSBOb3QgKGNvbXBsZW1lbnRhcmlvKSBzb2JyZSBsb3MgdmFsb3JlcyBkZSBjZWxkYSBkZWwgcsOhc3RlciBkZSBlbnRyYWRhLiBTaSBsb3MgdmFsb3JlcyBkZSBlbnRyYWRhIHNvbiB2ZXJkYWRlcm9zIChkaXN0aW50b3MgZGUgY2VybyksIGVsIHZhbG9yIGRlIHNhbGlkYSBlcyAwLiBTaSBsb3MgdmFsb3JlcyBkZSBlbnRyYWRhIHNvbiBmYWxzb3MgKGNlcm8pLCBsYSBzYWxpZGEgZXMgMS5cIixcblx0XHRib29sZWFuTm90RGVzYzogXCJMYSBmdW5jacOzbiByZWFsaXphIHVuYSBvcGVyYWNpw7NuIEJvb2xlYW5hIE5vdCAoY29tcGxlbWVudGFyaWEpIHNvYnJlIGxvcyB2YWxvcmVzIGRlIGxvcyBww614ZWxlcyBkZWwgcsOhc3RlciBkZSBlbnRyYWRhLiBTaSBsb3MgdmFsb3JlcyBkZSBlbnRyYWRhIHNvbiB2ZXJkYWRlcm9zIChkaXN0aW50b3MgZGUgY2VybyksIGVsIHZhbG9yIGRlIHNhbGlkYSBlcyAwLiBTaSBsb3MgdmFsb3JlcyBkZSBlbnRyYWRhIHNvbiBmYWxzb3MgKGNlcm8pLCBlbCB2YWxvciBkZSBzYWxpZGEgZXMgMS5cIixcblx0XHRib29sZWFuT3JOYW1lOiBcIkJvb2xlYW5hIE9yXCIsXG5cdFx0Ym9vbGVhbk9yU25pcDogXCJSZWFsaXphIHVuYSBvcGVyYWNpw7NuIEJvb2xlYW5hIE9yIHNvYnJlIGxvcyB2YWxvcmVzIGRlIGxhcyBjZWxkYXMgZGUgZG9zIHLDoXN0ZXJlcyBkZSBlbnRyYWRhLiBTaSB1bm8gbyBhbWJvcyB2YWxvcmVzIGRlIGVudHJhZGEgc29uIHZlcmRhZGVyb3MgKGRpc3RpbnRvcyBkZSBjZXJvKSwgZWwgdmFsb3IgZGUgc2FsaWRhIGVzIDEuIFNpIGxvcyBkb3MgdmFsb3JlcyBkZSBlbnRyYWRhIHNvbiBmYWxzb3MgKGNlcm8pLCBsYSBzYWxpZGEgZXMgMC5cIixcblx0XHRib29sZWFuT3JEZXNjOiBcIkxhIGZ1bmNpw7NuIHJlYWxpemEgdW5hIG9wZXJhY2nDs24gQm9vbGVhbmEgT3Igc29icmUgbG9zIHZhbG9yZXMgZGUgbGFzIGNlbGRhcyBkZSBkb3MgcsOhc3RlcmVzIGRlIGVudHJhZGEuIFNpIHVubyBvIGxvcyBkb3MgdmFsb3JlcyBkZSBlbnRyYWRhIHNvbiB2ZXJkYWRlcm9zIChkaXN0aW50b3MgZGUgY2VybyksIGVsIHZhbG9yIGRlIHNhbGlkYSBlcyAxLiBTaSBsb3MgZG9zIHZhbG9yZXMgZGUgZW50cmFkYSBzb24gZmFsc29zIChjZXJvKSwgZWwgdmFsb3IgZGUgc2FsaWRhIGVzIDAuXCIsXG5cdFx0Ym9vbGVhblhvck5hbWU6IFwiQm9vbGVhbmEgWE9yXCIsXG5cdFx0Ym9vbGVhblhvclNuaXA6IFwiUmVhbGl6YSB1bmEgb3BlcmFjacOzbiBib29sZWFuYSBPciBleGNsdXNpdmEgc29icmUgbG9zIHZhbG9yZXMgZGUgY2VsZGEgZGUgZG9zIHLDoXN0ZXJlcyBkZSBlbnRyYWRhLiBTaSB1biB2YWxvciBkZSBlbnRyYWRhIGVzIHZlcmRhZGVybyAoZGlzdGludG8gZGUgY2VybykgeSBlbCBvdHJvIGVzIGZhbHNvIChjZXJvKSwgbGEgc2FsaWRhIGVzIDEuIFNpIGxvcyBkb3MgdmFsb3JlcyBkZSBlbnRyYWRhIHNvbiB2ZXJkYWRlcm9zIG8gbG9zIGRvcyBzb24gZmFsc29zLCBsYSBzYWxpZGEgZXMgMC5cIixcblx0XHRib29sZWFuWG9yRGVzYzogXCJMYSBmdW5jacOzbiByZWFsaXphIHVuYSBvcGVyYWNpw7NuIGJvb2xlYW5hIE9yIGV4Y2x1c2l2YSBzb2JyZSBsb3MgdmFsb3JlcyBkZSBjZWxkYSBkZSBkb3MgcsOhc3RlcmVzIGRlIGVudHJhZGEuIFNpIHVuIHZhbG9yIGRlIGVudHJhZGEgZXMgdmVyZGFkZXJvIChkaXN0aW50byBkZSBjZXJvKSB5IGVsIG90cm8gdmFsb3IgZXMgZmFsc28gKGNlcm8pLCBlbCB2YWxvciBkZSBzYWxpZGEgZXMgMS4gU2kgbG9zIGRvcyB2YWxvcmVzIGRlIGVudHJhZGEgc29uIHZlcmRhZGVyb3MsIG8gc2kgbG9zIGRvcyBzb24gZmFsc29zLCBlbCB2YWxvciBkZSBzYWxpZGEgZXMgMC5cIixcblx0XHRidWZmZXJlZFJhc3Rlck5hbWU6IFwiWm9uYSBkZSBpbmZsdWVuY2lhXCIsXG5cdFx0YnVmZmVyZWRSYXN0ZXJTbmlwOiBcIkNyZWEgdW5hIHpvbmEgZGUgaW5mbHVlbmNpYSBhbHJlZGVkb3IgZGUgbG9zIMO6bHRpbW9zIGJsb3F1ZXMgZGUgcMOteGVsZXMgYSBsb3MgY3VhbGVzIHNlIGhhIGFjY2VkaWRvLlwiLFxuXHRcdGJ1ZmZlcmVkUmFzdGVyRGVzYzogXCJMYSBmdW5jacOzbiBFbiB6b25hIGRlIGluZmx1ZW5jaWEgc2UgdXRpbGl6YSBwYXJhIG9wdGltaXphciBlbCByZW5kaW1pZW50byBkZSBjYWRlbmFzIGRlIGZ1bmNpb25lcyBjb21wbGVqYXMuIEFsbWFjZW5hIGVuIGxhIG1lbW9yaWEgbGEgc2FsaWRhIGRlIGxhIHBhcnRlIGRlIGxhIGNhZGVuYSBkZSBmdW5jaW9uZXMgcXVlIGxhIHByZWNlZGUuIDxkaXY+PGJyLz5JbnNlcnRlIGVzdGEgZnVuY2nDs24gZW4gZWwgRWRpdG9yIGRlIGZ1bmNpw7NuIGRvbmRlIGRlc2VlIGFsbWFjZW5hciBsYSBzYWxpZGEuPC9kaXY+XCIsXG5cdFx0cmFzdGVyQ2FsY3VsYXRvck5hbWU6IFwiQ2FsY3VsYWRvcmFcIixcblx0XHRyYXN0ZXJDYWxjdWxhdG9yU25pcDogXCJDYWxjdWxhIHVuIHLDoXN0ZXIgYSBwYXJ0aXIgZGUgdW5hIGV4cHJlc2nDs24gbWF0ZW3DoXRpY2EgYmFzYWRhIGVuIHLDoXN0ZXJlcy5cIixcblx0XHRyYXN0ZXJDYWxjdWxhdG9yRGVzYzogXCJMYSBmdW5jacOzbiBDYWxjdWxhZG9yYSBwZXJtaXRlIGNyZWFyIHkgZWplY3V0YXIgZXhwcmVzaW9uZXMgZSBpbmNvcnBvcmFybGFzIGVuIGNhZGVuYXMgZGUgZnVuY2lvbmVzLlwiLFxuXHRcdGNlbGxTdGF0aXN0aWNzTmFtZTogXCJFc3RhZMOtc3RpY2FzIGRlIGNlbGRhc1wiLFxuXHRcdGNlbGxTdGF0aXN0aWNzU25pcDogXCJDYWxjdWxhIHVuYSBlc3RhZMOtc3RpY2EgcG9yIGNlbGRhIGRlIHLDoXN0ZXJlcyBtw7psdGlwbGVzLiBMYXMgZXN0YWTDrXN0aWNhcyBkaXNwb25pYmxlcyBzb24gbWF5b3LDrWEsIG3DoXhpbW8sIHZhbG9yIG1lZGlvLCBtZWRpYW5hLCBtw61uaW1vLCBtaW5vcsOtYSwgcGVyY2VudGlsLCByYW5nbywgZGVzdmlhY2nDs24gZXN0w6FuZGFyLCBzdW1hIHkgdmFyaWVkYWQuXCIsXG5cdFx0Y2VsbFN0YXRpc3RpY3NEZXNjOiBcIkVzdGEgZnVuY2nDs24gY2FsY3VsYSBsYXMgZXN0YWTDrXN0aWNhcyBkZSB2YXJpb3MgcsOhc3RlcmVzIHDDrXhlbCBwb3IgcMOteGVsLiBMYXMgZXN0YWTDrXN0aWNhcyBkaXNwb25pYmxlcyBzb24gbWF5b3LDrWEsIG3DoXhpbW8sIHZhbG9yIG1lZGlvLCBtZWRpYW5hLCBtw61uaW1vLCBtaW5vcsOtYSwgcmFuZ28sIGRlc3ZpYWNpw7NuIGVzdMOhbmRhciwgc3VtYSB5IHZhcmllZGFkLlwiLFxuXHRcdGNsYXNzaWZ5TmFtZTogXCJDbGFzaWZpY2FyXCIsXG5cdFx0Y2xhc3NpZnlTbmlwOiBcIkFzaWduYSBjYWRhIHDDrXhlbCBhIHVuYSBjbGFzZS4gSW5jb3Jwb3JlIGRhdG9zIHNlY3VuZGFyaW9zLCBwb3IgZWplbXBsbywgdW5hIGltYWdlbiBzZWdtZW50YWRhLlwiLFxuXHRcdGNsYXNzaWZ5RGVzYzogXCJFc3RhIGZ1bmNpw7NuIHLDoXN0ZXIgY2xhc2lmaWNhIHVuIGRhdGFzZXQgcsOhc3RlciBhIHBhcnRpciBkZSB1biBhcmNoaXZvIGRlIGRlZmluaWNpw7NuIGRlIGNsYXNpZmljYWRvciBkZSBFc3JpICguZWNkKSB5IGRlIGVudHJhZGFzIGRlIGRhdGFzZXQgcsOhc3Rlci4gRWwgYXJjaGl2byAuZWNkIHV0aWxpemFkbyBlbiBsYSBmdW5jacOzbiBDbGFzaWZpY2FyIGNvbnRpZW5lIHRvZGEgbGEgaW5mb3JtYWNpw7NuIG5lY2VzYXJpYSBwYXJhIHVuIGRhdGFzZXQgeSB1biBjbGFzaWZpY2Fkb3IgY29uY3JldG9zLCB5IHNlIGdlbmVyYSBjb24gaGVycmFtaWVudGFzIGRlIHByZXBhcmFjacOzbiBkZSBjbGFzaWZpY2FjacOzbiwgcG9yIGVqZW1wbG8sIGxhcyBoZXJyYW1pZW50YXMgUHJlcGFyYXIgY2xhc2lmaWNhZG9yIGRlIG3DoXF1aW5hIGRlIHZlY3RvcmVzIGRlIHNvcG9ydGUgbyBQcmVwYXJhciBjbGFzaWZpY2Fkb3IgZGUgw6FyYm9sZXMgYWxlYXRvcmlvcy5cIixcblx0XHRjbGlwTmFtZTogXCJSZWNvcnRhclwiLFxuXHRcdGNsaXBTbmlwOiBcIkVzdGFibGVjZSBsYSBleHRlbnNpw7NuIGRlIHVuIHLDoXN0ZXIgbWVkaWFudGUgY29vcmRlbmFkYXMgdSBvdHJvIGRhdGFzZXQuXCIsXG5cdFx0Y2xpcERlc2M6IFwiRXN0YSBmdW5jacOzbiByZWNvcnRhIHVuIHLDoXN0ZXIgdXRpbGl6YW5kbyB1bmEgZm9ybWEgcmVjdGFuZ3VsYXIgc2Vnw7puIGxhIGV4dGVuc2nDs24gZGVmaW5pZGEgbyByZWNvcnRhIHVuIHLDoXN0ZXIgc2Vnw7puIGxhIGZvcm1hIGRlIHVuYSBjbGFzZSBkZSBlbnRpZGFkIHBvbGlnb25hbCBkZSBlbnRyYWRhLiBMYSBmb3JtYSBxdWUgZGVmaW5lIGVsIHJlY29ydGUgcHVlZGUgZXhjZWRlciBsYSBleHRlbnNpw7NuIGRlbCByw6FzdGVyIG8gc29icmVzYWxpciBkZSB1biDDoXJlYSBkZW50cm8gZGVsIHLDoXN0ZXIuXCIsXG5cdFx0Y29sb3JzcGFjZUNvbnZlcnNpb25OYW1lOiBcIkNvbnZlcnNpw7NuIGRlIG1vZGVsbyBkZSBjb2xvclwiLFxuXHRcdGNvbG9yc3BhY2VDb252ZXJzaW9uU25pcDogXCJDb252aWVydGUgdW4gcsOhc3RlciBkZSBSR0IgYSBIU1YgeSB2aWNldmVyc2EuXCIsXG5cdFx0Y29sb3JzcGFjZUNvbnZlcnNpb25EZXNjOiBcIkxhIGZ1bmNpw7NuIENvbnZlcnNpw7NuIGRlIG1vZGVsbyBkZSBjb2xvciBjb252aWVydGUgZWwgbW9kZWxvIGRlIGNvbG9yIGRlIHVuYSBpbWFnZW4gZGUgdG9ubywgc2F0dXJhY2nDs24geSB2YWxvciAoSFNWKSBhIHJvam8sIHZlcmRlIHkgYXp1bCAoUkdCKSBvIHZpY2V2ZXJzYS48ZGl2Pjxici8+RXN0YSBmdW5jacOzbiBzZSBwdWVkZSB1c2FyIGVuIHVuIGRhdGFzZXQgZGUgbW9zYWljby48L2Rpdj5cIixcblx0XHRjb2xvcm1hcFRvUkdCTmFtZTogXCJNYXBhIGRlIGNvbG9yIGEgUkdCXCIsXG5cdFx0Y29sb3JtYXBUb1JHQlNuaXA6IFwiQ29udmllcnRlIHVuIHLDoXN0ZXIgZGUgYmFuZGEgc2ltcGxlIGNvbiB1biBtYXBhIGRlIGNvbG9yIGVuIHVuIHLDoXN0ZXIgZGUgYmFuZGEgdHJpcGxlIChyb2pvLCB2ZXJkZSB5IGF6dWwpLlwiLFxuXHRcdGNvbG9ybWFwVG9SR0JEZXNjOiBcIkVzdGEgZnVuY2nDs24gY29udmllcnRlIHVuIHLDoXN0ZXIgZGUgYmFuZGEgc2ltcGxlIGNvbiB1biBtYXBhIGRlIGNvbG9yIGVuIHVuIHLDoXN0ZXIgZGUgYmFuZGEgdHJpcGxlIChyb2pvLCB2ZXJkZSB5IGF6dWwpLjxkaXY+PGJyLz5Fc3RhIGZ1bmNpw7NuIHJlc3VsdGEgw7p0aWwgY3VhbmRvIHNlIG5lY2VzaXRhIGNyZWFyIHVuIHLDoXN0ZXIgZGUgdHJlcyBiYW5kYXMgYSBwYXJ0aXIgZGUgdW4gcsOhc3RlciBkZSB1bmEgc29sYSBiYW5kYSBxdWUgdGllbmUgdW4gbWFwYSBkZSBjb2xvciBhc29jaWFkby4gTG9zIHZhbG9yZXMgZGVsIG1hcGEgZGUgY29sb3Igc2UgdXNhbiBwYXJhIGNyZWFyIGxhcyBkaXN0aW50YXMgYmFuZGFzOiByb2phLCB2ZXJkZSB5IGF6dWwuIEVzdGEgZnVuY2nDs24gc2UgcHVlZGUgdXNhciBlbiB1biBkYXRhc2V0IGRlIG1vc2FpY28uPC9kaXY+XCIsXG5cdFx0Y29sb3JtYXBOYW1lOiBcIk1hcGEgZGUgY29sb3JcIixcblx0XHRjb2xvcm1hcFNuaXA6IFwiQ2FtYmlhIGxvcyB2YWxvcmVzIGRlIHDDrXhlbCBwYXJhIG1vc3RyYXIgbG9zIGRhdG9zIHLDoXN0ZXIgY29tbyB1bmEgZXNjYWxhIGRlIGdyaXNlcyBvIGNvbW8gdW5hIGltYWdlbiByb2phLCB2ZXJkZSwgYXp1bCAoUkdCKSwgYmFzw6FuZG9zZSBlbiB1biBtYXBhIGRlIGNvbG9yIG8gZW4gdW5hIHJhbXBhIGRlIGNvbG9yLlwiLFxuXHRcdGNvbG9ybWFwRGVzYzogXCJMYSBmdW5jacOzbiBNYXBhIGRlIGNvbG9yIGVzIHVuIHRpcG8gZGUgcmVuZGVyaXphZG9yIGRlIGRhdG9zIHLDoXN0ZXIuIFRyYW5zZm9ybWEgbG9zIHZhbG9yZXMgZGUgcMOteGVsIHBhcmEgbW9zdHJhciBkYXRvcyByw6FzdGVyIGNvbW8gZXNjYWxhIGRlIGdyaXNlcyBvIGltYWdlbiBkZSBjb2xvciBSR0IgYmFzYWRhIGVuIHVuIGVzcXVlbWEgZGUgY29sb3IgbyBjb2xvcmVzIGVzcGVjw61maWNvcyBkZSB1biBhcmNoaXZvIGRlIG1hcGEgZGUgY29sb3IuIFB1ZWRlIHV0aWxpemFyIHVuIG1hcGEgZGUgY29sb3IgcGFyYSByZXByZXNlbnRhciBkYXRvcyBhbmFsaXphZG9zLCBwb3IgZWplbXBsbywgdW5hIGltYWdlbiBjbGFzaWZpY2FkYSwgbyBhbCBtb3N0cmFyIHVuIG1hcGEgdG9wb2dyw6FmaWNvIChvIHVuYSBpbWFnZW4gZGlnaXRhbGl6YWRhIGVuIGNvbG9yIGluZGV4YWRhKS48ZGl2Pjxici8+TG9zIG1hcGFzIGRlIGNvbG9yIGNvbnRpZW5lbiB1biBjb25qdW50byBkZSB2YWxvcmVzIHF1ZSBzZSBhc29jaWFuIGNvbiBjb2xvcmVzIHV0aWxpemFkb3MgcGFyYSB2aXN1YWxpemFyIHVuIHLDoXN0ZXIgZGUgdW5hIMO6bmljYSBiYW5kYSBkZSBmb3JtYSBjb25zaXN0ZW50ZSBjb24gbG9zIG1pc21vcyBjb2xvcmVzLiBDYWRhIHZhbG9yIGRlIHDDrXhlbCBlc3TDoSBhc29jaWFkbyBhIHVuIGNvbG9yLCBxdWUgc2UgZGVmaW5lIGNvbW8gdW4gY29uanVudG8gZGUgdmFsb3JlcyBSR0IuIExvcyBtYXBhcyBkZSBjb2xvciB0aWVuZW4gbGEgY2FwYWNpZGFkIGRlIGFkbWl0aXIgY3VhbHF1aWVyIHByb2Z1bmRpZGFkIGRlIGJpdCwgZXhjZXB0byBlbCBwdW50byBmbG90YW50ZS4gVGFtYmnDqW4gcHVlZGVuIGFkbWl0aXIgbG9zIHZhbG9yZXMgcG9zaXRpdm9zIHkgbmVnYXRpdm9zLCB5IHB1ZWRlbiBjb250ZW5lciB2YWxvcmVzIGFzaWduYWRvcyBkZSBjb2xvciBxdWUgZmFsdGFuLiBBbCB2aXN1YWxpemFyIHVuIGRhdGFzZXQgY29uIHVuIG1hcGEgZGUgY29sb3JlcyBxdWUgY29udGllbmUgdmFsb3JlcyBwZXJkaWRvcywgbG9zIHDDrXhlbGVzIGRlIGRpY2hvcyB2YWxvcmVzIG5vIHNlIHZpc3VhbGl6YW4uPC9kaXY+XCIsXG5cdFx0Y29tcGxleE5hbWU6IFwiQ29tcGxlam9cIixcblx0XHRjb21wbGV4U25pcDogXCJFeHRyYWUgbGEgbWFnbml0dWQgZGUgbsO6bWVyb3MgY29tcGxlam9zLlwiLFxuXHRcdGNvbXBsZXhEZXNjOiBcIkVzdGEgZnVuY2nDs24gY2FsY3VsYSBsYSBtYWduaXR1ZCBkZSBsb3MgdmFsb3JlcyBjb21wbGVqb3MuPGRpdj48YnIvPkVzdGEgZnVuY2nDs24gc2UgdXRpbGl6YSB0w61waWNhbWVudGUgY29uIGxhcyBpbcOhZ2VuZXMgZGUgcmFkYXIgcXVlIHRpZW5lbiB1biB0aXBvIGRlIGRhdG9zIGNvbXBsZWpvLiBTZSBwdWVkZSB1c2FyIGVuIHVuIGRhdGFzZXQgZGUgbW9zYWljby48L2Rpdj5cIixcblx0XHRjb21wb3NpdGVCYW5kTmFtZTogXCJCYW5kYXMgY29tcHVlc3Rhc1wiLFxuXHRcdGNvbXBvc2l0ZUJhbmRTbmlwOiBcIkNvbWJpbmEgdmFyaW9zIGRhdGFzZXRzIGVuIHVuIHLDoXN0ZXIgbXVsdGliYW5kYS5cIixcblx0XHRjb21wb3NpdGVCYW5kRGVzYzogXCJMYSBmdW5jacOzbiBCYW5kYXMgY29tcHVlc3RhcyBwZXJtaXRlIGNvbWJpbmFyIHLDoXN0ZXJlcyBwYXJhIGNyZWFyIHVuYSBpbWFnZW4gbXVsdGliYW5kYS5cIixcblx0XHRjb25OYW1lOiBcIkV2YWx1YWNpw7NuIGNvbmRpY2lvbmFsXCIsXG5cdFx0Y29uU25pcDogXCJSZWFsaXphIHVuYSBvcGVyYWNpw7NuIElmLCBUaGVuLCBFbHNlIGNvbmRpY2lvbmFsLiBDdWFuZG8gc2UgdXRpbGl6YSB1biBvcGVyYWRvciBjb25kaWNpb25hbCwgbm9ybWFsbWVudGUgc2UgbmVjZXNpdGFuIGRvcyBvIG3DoXMgZnVuY2lvbmVzIGVuY2FkZW5hZGFzLCBlbiBsYSBxdWUgbGEgcHJpbWVyYSBmdW5jacOzbiBpbmRpY2EgbG9zIGNyaXRlcmlvcyB5IGxhIHNlZ3VuZGEgZnVuY2nDs24gZXMgZWwgb3BlcmFkb3IgY29uZGljaW9uYWwgcXVlIHVzYSBsb3MgY3JpdGVyaW9zIHkgZGljdGEgY3XDoWxlcyBkZWJlcsOtYW4gc2VyIGxhcyBzYWxpZGFzIHZlcmRhZGVyYXMgeSBmYWxzYXMuXCIsXG5cdFx0Y29uRGVzYzogXCJMYSBmdW5jacOzbiBDb24gZGVmaW5lIGxvcyBww614ZWxlcyBkZWwgcsOhc3RlciBkZSBzYWxpZGEgZW4gZnVuY2nDs24gZGUgdW5hIGV2YWx1YWNpw7NuIGlmZWxzZSBkZSBjYWRhIHDDrXhlbCBkZSBlbnRyYWRhLiBEZXZ1ZWx2ZSBsb3MgdmFsb3JlcyBkZSBww614ZWwgZGVsIFLDoXN0ZXIgdmVyZGFkZXJvIHNpIGxhIGV2YWx1YWNpw7NuIGVzIFRydWUgKDEpIG8gZGV2dWVsdmUgbG9zIHZhbG9yZXMgZGUgcMOteGVsIGRlbCBSw6FzdGVyIGZhbHNvIHNpIGxhIGV2YWx1YWNpw7NuIGNvbmRpY2lvbmFsIGVzIEZhbHNlICgwKS4gRXN0ZSBjcml0ZXJpbyB2aWVuZSBkZXRlcm1pbmFkbyBwb3IgbGEgc2FsaWRhIGRlIHVuYSBmdW5jacOzbiBtYXRlbcOhdGljYSBsw7NnaWNhLCBxdWUgc2Vyw6EgZWwgUsOhc3RlciBkZSBlbnRyYWRhLlwiLFxuXHRcdGNvbnN0YW50TmFtZTogXCJDb25zdGFudGVcIixcblx0XHRjb25zdGFudFNuaXA6IFwiQ3JlYSB1biByw6FzdGVyIHZpcnR1YWwgY29uIHVuIHZhbG9yIGRlIHDDrXhlbCDDum5pY28uXCIsXG5cdFx0Y29uc3RhbnREZXNjOiBcIkVzdGEgZnVuY2nDs24gY3JlYSB1biByw6FzdGVyIHZpcnR1YWwgY29uIHVuIMO6bmljbyB2YWxvciBkZSBww614ZWwgcXVlIHNlIHB1ZWRlIHV0aWxpemFyIGVuIHBsYW50aWxsYXMgZGUgZnVuY2nDs24gcsOhc3RlciB5IHBhcmEgcHJvY2VzYXIgdW4gZGF0YXNldCBkZSBtb3NhaWNvLjxkaXY+PGJyLz5FbCB2YWxvciBkZSBjb25zdGFudGUgc2UgdXRpbGl6YSBwYXJhIGNhZGEgdmFsb3IgZGUgcMOteGVsIGVuIGVsIHLDoXN0ZXIuPC9kaXY+XCIsXG5cdFx0Y29udG91ck5hbWU6IFwiQ3VydmFzIGRlIG5pdmVsXCIsXG5cdFx0Y29udG91clNuaXA6IFwiQ3JlYSBsw61uZWFzIGRlIGN1cnZhcyBkZSBuaXZlbC5cIixcblx0XHRjb250b3VyRGVzYzogXCJMYSBmdW5jacOzbiBDdXJ2YXMgZGUgbml2ZWwgZ2VuZXJhIGzDrW5lYXMgZGUgY3VydmFzIGRlIG5pdmVsIHVuaWVuZG8gcHVudG9zIGNvbiBsYSBtaXNtYSBlbGV2YWNpw7NuIGEgcGFydGlyIGRlIHVuIGRhdGFzZXQgZGUgZWxldmFjacOzbiByw6FzdGVyLiBMb3MgY29udG9ybm9zIHNvbiBpc29sw61uZWFzIGNyZWFkYXMgY29tbyByw6FzdGVyZXMgcGFyYSBsYSB2aXN1YWxpemFjacOzbi4gTGFzIHNpZ3VpZW50ZXMgY2FyYWN0ZXLDrXN0aWNhcyBjbGF2ZSBoYWNlbiBxdWUgZXN0YSBmdW5jacOzbiBzZWEgcG90ZW50ZTogbGFzIGN1cnZhcyBkZSBuaXZlbCBzZSBnZW5lcmFuIGRlIGZvcm1hIHLDoXBpZGEgeSBkaW7DoW1pY2EgZW4gZGF0YXNldHMgbXV5IGdyYW5kZXMgY29tbywgcG9yIGVqZW1wbG8sIGxhIFdvcmxkIEVsZXZhdGlvbjsgZWwgaW50ZXJ2YWxvIGRlIGN1cnZhcyBkZSBuaXZlbCBzZSBwdWVkZW4gc3Vhdml6YXIgcGFyYSBwcm9wb3JjaW9uYXIgdW5hIGFwYXJpZW5jaWEgbcOhcyBhZ3JhZGFibGUgY2FydG9ncsOhZmljYW1lbnRlLCBtYW50ZW5pZW5kbyBsYSBwcmVjaXNpw7NuIGRlIGxhcyBjdXJ2YXMgZGUgbml2ZWw7IHNlIHByb3BvcmNpb25hIGNvbnRyb2wgZGluw6FtaWNvIHNvYnJlIGVsIGludGVydmFsbyBkZSBsYXMgY3VydmFzIGRlIG5pdmVsOyBlbnRyZSBsYXMgb3BjaW9uZXMgZGUgc2FsaWRhIHNlIGluY2x1eWVuIGzDrW5lYXMgZGUgY3VydmFzIGRlIG5pdmVsLCBjdXJ2YXMgZGUgbml2ZWwgZGUgw61uZGljZSB5IGN1cnZhcyBkZSBuaXZlbCByZWxsZW5hcy48ZGl2Pjxici8+TGEgY3JlYWNpw7NuIGRlIHVuYSBjYXBhIGRlIGN1cnZhcyBkZSBuaXZlbCBjb21vIHVuIHByb2R1Y3RvIHLDoXN0ZXIgcmVzdWx0YSBtdXkgdmFsaW9zbyBwYXJhIHVuYSBhbXBsaWEgZ2FtYSBkZSBhcGxpY2FjaW9uZXMsIGRhZG8gcXVlIGxhcyBjdXJ2YXMgZGUgbml2ZWwgc2UgcHVlZGVuIHN1cGVycG9uZXIgZW4gdW4gbWFwYSB5IHByb3BvcmNpb25hciBpbmZvcm1hY2nDs24gc29icmUgZWwgdGVycmVubyBzaW4gb2N1bHRhciBsb3MgZGF0b3Mgc3VieWFjZW50ZXMuIFJlc3VsdGFuIMO6dGlsZXMgZW4gYXBsaWNhY2lvbmVzIHJlbGFjaW9uYWRhcyBjb24gbGEgaW5nZW5pZXLDrWEsIGxhIGFncmljdWx0dXJhIHkgbGEgZ2VzdGnDs24gZGUgYWd1YXMuPC9kaXY+XCIsXG5cdFx0Y29udHJhc3RCcmlnaHRuZXNzTmFtZTogXCJDb250cmFzdGUgeSBicmlsbG9cIixcblx0XHRjb250cmFzdEJyaWdodG5lc3NTbmlwOiBcIkFqdXN0YSBlbCBjb250cmFzdGUgeSBicmlsbG8gZGUgdW4gcsOhc3Rlci5cIixcblx0XHRjb250cmFzdEJyaWdodG5lc3NEZXNjOiBcIkxhIGZ1bmNpw7NuIEJyaWxsbyB5IGNvbnRyYXN0ZSBtZWpvcmEgbGEgYXBhcmllbmNpYSBkZSBsb3MgZGF0b3MgcsOhc3RlciBhbCBtb2RpZmljYXIgZWwgYnJpbGxvIHkgZWwgY29udHJhc3RlIGRlbnRybyBkZSBsYSBpbWFnZW4uIEVsIGJyaWxsbyBhdW1lbnRhIGxhIGx1bWlub3NpZGFkIHRvdGFsIGRlIGxhIGltYWdlbiwgcG9yIGVqZW1wbG8sIGFjbGFyYW5kbyBsb3MgY29sb3JlcyBvc2N1cm9zIHkgYmxhbnF1ZWFuZG8gbG9zIGNsYXJvcywgbWllbnRyYXMgcXVlIGVsIGNvbnRyYXN0ZSBhanVzdGEgbGEgZGlmZXJlbmNpYSBlbnRyZSBsb3MgY29sb3JlcyBtw6FzIGNsYXJvcyB5IGxvcyBtw6FzIG9zY3Vyb3MuPGRpdj48YnIvPkFsIHV0aWxpemFyIGVzdGEgZnVuY2nDs24gc2UgYWx0ZXJhbiBsb3MgdmFsb3JlcyBkZSBww614ZWwuIFBvciBsbyB0YW50bywgZXN0YSBmdW5jacOzbiBzZSBkZWJlIHV0aWxpemFyIGN1YW5kbyBkZXNlZSBtZWpvcmFyIGxhIGFwYXJpZW5jaWEgZGUgbG9zIGRhdG9zIHkgbm8gZGViZSB1dGlsaXphcmxhIHNpIGRlc2VhIHVzYXIgbG9zIGRhdG9zIGNvbW8gcGFydGUgZGUgdW4gYW7DoWxpc2lzIHF1ZSByZXF1ZXJpcsOhIGxvcyB2YWxvcmVzIGRlIHDDrXhlbCBvcmlnaW5hbGVzLiBFc3RhIGZ1bmNpw7NuIHJlc3VsdGEgw7p0aWwgYSBsYSBob3JhIGRlIHB1YmxpY2FyIGxvcyBkYXRvcyBjb21vIHVuIHNlcnZpY2lvIGRlIGltw6FnZW5lcyBxdWUgc2UgcHVlZGVuIHV0aWxpemFyIGVuIGFwbGljYWNpb25lcywgc2luIHBvZGVyIGFsdGVyYXIgZWwgY29udHJhc3RlIG5pIGVsIGJyaWxsbyBkZSBsYXMgaW3DoWdlbmVzLCBvIHBhcmEgZ2FyYW50aXphciBxdWUgc2UgbXVlc3RyZW4gdXRpbGl6YW5kbyBzdXMgYWp1c3RlcyBwcmVmZXJpZG9zLjwvZGl2PlwiLFxuXHRcdGNvbnZvbHV0aW9uTmFtZTogXCJDb252b2x1Y2nDs25cIixcblx0XHRjb252b2x1dGlvblNuaXA6IFwiQXBsaWNhIHVuIGZpbHRybyBwYXJhIG1lam9yYXIgbGEgbml0aWRleiwgZGVzZW5mb2NhciwgZGV0ZWN0YXIgbG9zIGJvcmRlcywgc3Vhdml6YXIsIG8gYmllbiB1biBncmFkaWVudGUgYSB0cmF2w6lzIGRlIHVuIHLDoXN0ZXIuXCIsXG5cdFx0Y29udm9sdXRpb25EZXNjOiBcIkxhIGZ1bmNpw7NuIGRlIGNvbnZvbHVjacOzbiByZWFsaXphIGVsIGZpbHRyYWRvIGRlIGxvcyB2YWxvcmVzIGRlIHDDrXhlbCBkZSB1bmEgaW1hZ2VuLCBsbyBxdWUgc2UgcHVlZGUgdXRpbGl6YXIgcGFyYSBhdW1lbnRhciBzdSBuaXRpZGV6LCBkaWZ1bWluYXJsYSwgZGV0ZWN0YXIgc3VzIGVqZXMgdSBvdHJvcyByZWFsY2VzIGJhc2Fkb3MgZW4gZWwga2VybmVsLiBMb3MgZmlsdHJvcyBzZSB1dGlsaXphbiBwYXJhIG1lam9yYXIgbGEgY2FsaWRhZCBkZSBsYSBpbWFnZW4gZGUgcsOhc3RlciBhbCBlbGltaW5hciBkYXRvcyBmYWxzb3MgbyBtZWpvcmFyIGxhcyBlbnRpZGFkZXMgZGUgbG9zIGRhdG9zLiBFc3RvcyBmaWx0cm9zIGRlIGNvbnZvbHVjacOzbiBzZSBhcGxpY2FuIGEgdW4ga2VybmVsIG3Ds3ZpbCBvIHN1cGVycHVlc3RvICh2ZW50YW5hIG8gdmVjaW5kYWQpLCBjb21vIDMgeCAzLiBMb3MgZmlsdHJvcyBkZSBjb252b2x1Y2nDs24gYWN0w7phbiBjYWxjdWxhbmRvIGVsIHZhbG9yIGRlIHDDrXhlbCBlbiBmdW5jacOzbiBkZSBsYSBwb25kZXJhY2nDs24gZGUgc3VzIHZlY2lub3MuXCIsXG5cdFx0Y29ycmlkb3JOYW1lOiBcIkNvcnJlZG9yXCIsXG5cdFx0Y29ycmlkb3JTbmlwOiBcIkNhbGN1bGEgbGEgc3VtYSBkZSBsb3MgY29zdGVzIGFjdW11bGF0aXZvcyBkZSBkb3MgcsOhc3RlcmVzIGFjdW11bGF0aXZvcyBkZSBlbnRyYWRhLlwiLFxuXHRcdGNvcnJpZG9yRGVzYzogXCJMYSBmdW5jacOzbiBDb3JyZWRvciBjYWxjdWxhIGxhIHN1bWEgZGUgbG9zIGNvc3RlcyBhY3VtdWxhdGl2b3MgZGUgZG9zIHLDoXN0ZXJlcyBkZSBjb3N0ZXMgYWN1bXVsYXRpdm9zIGRlIGVudHJhZGEuIEF1bnF1ZSBwYXJhIGxhIGVudHJhZGEgc2UgcHVlZGVuIHV0aWxpemFyIGRvcyByw6FzdGVyZXMgY3VhbHF1aWVyYSwgcGFyYSBvYnRlbmVyIHVuIHJlc3VsdGFkbyBzaWduaWZpY2F0aXZvIGRlYmVuIHNlciByw6FzdGVyZXMgZGUgY29zdGUgYWN1bXVsYXRpdm8gZGUgc2FsaWRhIHNpbiBhbHRlcmFyLiBFbCBvcmRlbiBkZSBsYXMgZG9zIGVudHJhZGFzIGVzIGlycmVsZXZhbnRlLlwiLFxuXHRcdGNvc0hOYW1lOiBcIkNvc2VubyBoaXBlcmLDs2xpY28gKENvc0gpXCIsXG5cdFx0Y29zSFNuaXA6IFwiQ2FsY3VsYSBlbCBjb3Nlbm8gaGlwZXJiw7NsaWNvIGRlIGNlbGRhcyBlbiB1biByw6FzdGVyLlwiLFxuXHRcdGNvc0hEZXNjOiBcIkxhIGZ1bmNpw7NuIGNhbGN1bGEgZWwgY29zZW5vIGhpcGVyYsOzbGljbyBkZSBsb3MgcMOteGVsZXMgZGUgdW4gcsOhc3Rlci5cIixcblx0XHRjb3NOYW1lOiBcIkNvc2VubyAoQ29zKVwiLFxuXHRcdGNvc1NuaXA6IFwiQ2FsY3VsYSBlbCBjb3Nlbm8gZGUgdW5hIGNlbGRhIGRlIHVuIHLDoXN0ZXIuXCIsXG5cdFx0Y29zRGVzYzogXCJMYSBmdW5jacOzbiBjYWxjdWxhIGVsIGNvc2VubyBkZSBsb3MgcMOteGVsZXMgZGUgdW4gcsOhc3Rlci5cIixcblx0XHRjb3N0QWxsb2NhdGlvbk5hbWU6IFwiQXNpZ25hY2nDs24gZGUgY29zdGVzXCIsXG5cdFx0Y29zdEFsbG9jYXRpb25TbmlwOiBcIkNhbGN1bGEsIHBhcmEgY2FkYSBjZWxkYSwgZWwgb3JpZ2VuIGRlIG1lbm9yIGNvc3RlIGVuIGZ1bmNpw7NuIGRlbCBtZW5vciBjb3N0ZSBhY3VtdWxhdGl2byBwb3IgdW5hIHN1cGVyZmljaWUgZGUgY29zdGUuXCIsXG5cdFx0Y29zdEFsbG9jYXRpb25EZXNjOiBcIkxhIGZ1bmNpw7NuIEFzaWduYWNpw7NuIGRlIGNvc3RlcyBjYWxjdWxhLCBwYXJhIGNhZGEgY2VsZGEsIGVsIG9yaWdlbiBkZSBtZW5vciBjb3N0ZSBlbiBmdW5jacOzbiBkZWwgbWVub3IgY29zdGUgYWN1bXVsYXRpdm8gcG9yIHVuYSBzdXBlcmZpY2llIGRlIGNvc3RlLlwiLFxuXHRcdGNvc3RCYWNrTGlua05hbWU6IFwiVsOtbmN1bG8gZGUgbWVub3IgY29zdGVcIixcblx0XHRjb3N0QmFja0xpbmtTbmlwOiBcIkRlZmluZSBlbCB2ZWNpbm8gcXVlIGVzIGxhIGNlbGRhIHNpZ3VpZW50ZSBlbiBsYSBydXRhIGRlIG1lbm9yIGNvc3RlIGFjdW11bGF0aXZvIGFsIG9yaWdlbiBkZSBtZW5vciBjb3N0ZS5cIixcblx0XHRjb3N0QmFja0xpbmtEZXNjOiBcIkxhIGZ1bmNpw7NuIFbDrW5jdWxvIGRlIG1lbm9yIGNvc3RlIGRlZmluZSBlbCB2ZWNpbm8gcXVlIGVzIGxhIGNlbGRhIHNpZ3VpZW50ZSBlbiBsYSBydXRhIGRlIG1lbm9yIGNvc3RlIGFjdW11bGF0aXZvIGFsIG9yaWdlbiBkZSBtZW5vciBjb3N0ZS48ZGl2Pjxici8+RWwgcsOhc3RlciBkZSB2w61uY3VsbyBkZSBtZW5vciBjb3N0ZSBjb250aWVuZSB2YWxvcmVzIGRlIGNlcm8gYSBvY2hvIHF1ZSBkZWZpbmVuIGxhIGRpcmVjY2nDs24gbyBpZGVudGlmaWNhbiBsYSBzaWd1aWVudGUgY2VsZGEgdmVjaW5hIChsYSBjZWxkYSBxdWUgc2lndWUpIGEgbG8gbGFyZ28gZGUgbGEgcnV0YSBjb24gbWVub3IgY29zdGUgYWN1bXVsYXRpdm8gZGVzZGUgdW5hIGNlbGRhIHBhcmEgbGxlZ2FyIGFsIG9yaWdlbiBkZSBtZW5vciBjb3N0ZS4gU2kgbGEgcnV0YSBlcyBwYXNhciBhbCBlbGVtZW50byBwcsOzeGltbyBkZXJlY2hvLCBzZSBsZSBhc2lnbmFyw6EgYSBsYSBjZWxkYSBlbCB2YWxvciAxLCAyIHBhcmEgbGEgY2VsZGEgZGlhZ29uYWwgZGVyZWNoYSBpbmZlcmlvciB5IGNvbnRpbnVhbmRvIGVuIGVsIHNlbnRpZG8gZGUgbGFzIGFndWphcyBkZWwgcmVsb2ouIEVsIHZhbG9yIDAgc2UgcmVzZXJ2YSBwYXJhIGxhcyBjZWxkYXMgZGUgb3JpZ2VuLjwvZGl2PlwiLFxuXHRcdGNvc3REaXN0YW5jZU5hbWU6IFwiQ29zdGUgZGUgZGlzdGFuY2lhXCIsXG5cdFx0Y29zdERpc3RhbmNlU25pcDogXCJDYWxjdWxhIGVsIG1lbm9yIGNvc3RlIGRlIGRpc3RhbmNpYSBhY3VtdWxhdGl2byBwYXJhIGNhZGEgY2VsZGEgZGVzZGUgbyBoYXN0YSBlbCBvcmlnZW4gZGUgbWVub3IgY29zdGUgcG9yIHVuYSBzdXBlcmZpY2llIGRlIGNvc3RlLlwiLFxuXHRcdGNvc3REaXN0YW5jZURlc2M6IFwiTGEgZnVuY2nDs24gQ29zdGUgZGUgZGlzdGFuY2lhIGNhbGN1bGEgZWwgbWVub3IgY29zdGUtZGlzdGFuY2lhIGFjdW11bGF0aXZvIHBhcmEgY2FkYSBjZWxkYSBkZXNkZSBvIGhhc3RhIGVsIG9yaWdlbiBkZSBtZW5vciBjb3N0ZSBwb3IgdW5hIHN1cGVyZmljaWUgZGUgY29zdGUuXCIsXG5cdFx0Y29zdFBhdGhOYW1lOiBcIlJ1dGEgZGUgY29zdGVcIixcblx0XHRjb3N0UGF0aFNuaXA6IFwiQ2FsY3VsYSBsYSBydXRhIGRlIG1lbm9yIGNvc3RlIGRlc2RlIHVuIG9yaWdlbiBhIHN1IGRlc3Rpbm8uXCIsXG5cdFx0Y29zdFBhdGhEZXNjOiBcIkxhIGZ1bmNpw7NuIGdsb2JhbCBSdXRhIGRlIGNvc3RlIGNhbGN1bGEgbGEgcnV0YSBkZSBtZW5vciBjb3N0ZSBkZXNkZSB1biBvcmlnZW4gYSB1biBkZXN0aW5vLjxkaXY+PGJyLz5Fc3RhIGZ1bmNpw7NuIHByb2R1Y2UgdW4gcsOhc3RlciBkZSBzYWxpZGEgcXVlIHJlZ2lzdHJhIGxhIHJ1dGEgbyBsYXMgcnV0YXMgZGUgbWVub3IgY29zdGUgZGVzZGUgbGFzIHViaWNhY2lvbmVzIHNlbGVjY2lvbmFkYXMgaGFzdGEgbGEgY2VsZGEgZGUgb3JpZ2VuIG3DoXMgY2VyY2FuYSBkZWZpbmlkYSBkZW50cm8gZGUgbGEgc3VwZXJmaWNpZSBkZSBjb3N0ZSBhY3VtdWxhdGl2bywgZW4gdMOpcm1pbm9zIGRlIGNvc3RlLWRpc3RhbmNpYS48L2Rpdj5cIixcblx0XHRjdXJ2YXR1cmVOYW1lOiBcIkN1cnZhdHVyYVwiLFxuXHRcdGN1cnZhdHVyZVNuaXA6IFwiQ2FsY3VsYSBsYSBjdXJ2YXR1cmEgZGUgdW5hIHN1cGVyZmljaWUgZGUgcsOhc3RlciBlIGluY2x1eWUsIG9wY2lvbmFsbWVudGUsIGxhIGN1cnZhdHVyYSBkZWwgcGVyZmlsIHkgZGVsIHBsYW5vLlwiLFxuXHRcdGN1cnZhdHVyZURlc2M6IFwiTGEgZnVuY2nDs24gZGUgY3VydmF0dXJhIG11ZXN0cmEgbGEgZm9ybWEgbyBsYSBjdXJ2YXR1cmEgZGUgbGEgcGVuZGllbnRlLiBVbmEgcGFydGUgZGUgbGEgc3VwZXJmaWNpZSBwdWVkZSBzZXIgY8OzbmNhdmEgbyBjb252ZXhhOyBlc28gc2UgcHVlZGUgY29tcHJvYmFyIGNvbnN1bHRhbmRvIGVsIHZhbG9yIGRlIGxhIGN1cnZhdHVyYS4gTGEgY3VydmF0dXJhIHNlIG9idGllbmUgY2FsY3VsYW5kbyBsYSBkZXJpdmFkYSBzZWd1bmRhIGRlIGxhIHN1cGVyZmljaWUuPGRpdj48YnIvPkxhIHNhbGlkYSBkZSBsYSBmdW5jacOzbiBkZSBjdXJ2YXR1cmEgc2UgcHVlZGUgdXRpbGl6YXIgcGFyYSBkZXNjcmliaXIgbGFzIGNhcmFjdGVyw61zdGljYXMgZsOtc2ljYXMgZGUgdW5hIGN1ZW5jYSBkZSBkcmVuYWplIHBhcmEgaW50ZW50YXIgZW50ZW5kZXIgbG9zIHByb2Nlc29zIGRlIGVyb3Npw7NuIHkgZXNjb3JyZW50w61hLiBFbCB2YWxvciBkZSBsYSBjdXJ2YXR1cmEgc2UgcHVlZGUgdXRpbGl6YXIgcGFyYSBidXNjYXIgcGF0cm9uZXMgZGUgZXJvc2nDs24gZGVsIHN1ZWxvLCBhc8OtIGNvbW8gbGEgZGlzdHJpYnVjacOzbiBkZWwgYWd1YSBlbiBsYSB0aWVycmEuIExhIGN1cnZhdHVyYSBkZWwgcGVyZmlsIGFmZWN0YSBsYSBhY2VsZXJhY2nDs24geSBkZXNhY2VsZXJhY2nDs24gZGVsIGZsdWpvIHksIHBvciBsbyB0YW50bywgaW5mbHV5ZSBlbiBsYSBlcm9zacOzbiB5IGxhIHNlZGltZW50YWNpw7NuLiBMYSBjdXJ2YXR1cmEgZGUgbGEgcGxhdGFmb3JtYSBpbmZsdXllIGVuIGxhIGNvbnZlcmdlbmNpYSB5IGRpdmVyZ2VuY2lhIGRlbCBmbHVqby48L2Rpdj5cIixcblx0XHRkaXZpZGVOYW1lOiBcIkRpdmlzacOzblwiLFxuXHRcdGRpdmlkZVNuaXA6IFwiRGl2aWRlIGxvcyB2YWxvcmVzIGRlIGRvcyByw6FzdGVyZXMgY2VsZGEgcG9yIGNlbGRhLlwiLFxuXHRcdGRpdmlkZURlc2M6IFwiTGEgZnVuY2nDs24gRGl2aWRpciBkaXZpZGUgbG9zIHZhbG9yZXMgZGUgZG9zIHLDoXN0ZXJlcyBww614ZWwgcG9yIHDDrXhlbC5cIixcblx0XHRlbGV2YXRpb25Wb2lkRmlsbE5hbWU6IFwiUmVsbGVubyBkZSB2YWPDrW8gZGUgZWxldmFjacOzblwiLFxuXHRcdGVsZXZhdGlvblZvaWRGaWxsU25pcDogXCJDcmVhIHDDrXhlbGVzIGRvbmRlIGhheSBhZ3VqZXJvcyBkZW50cm8gZGUgbG9zIGRhdG9zIGRlIGVsZXZhY2nDs24uXCIsXG5cdFx0ZWxldmF0aW9uVm9pZEZpbGxEZXNjOiBcIkxhIGZ1bmNpw7NuIGRlIHJlbGxlbm8gZGUgdmFjw61vIGRlIGVsZXZhY2nDs24gc2UgdXRpbGl6YSBwYXJhIGNyZWFyIHDDrXhlbGVzIGRvbmRlIGV4aXN0ZW4gYWd1amVyb3MgZW4gbGEgZWxldmFjacOzbi48ZGl2Pjxici8+TG9zIHZhY8Otb3Mgc2UgcHJvZHVjZW4gY3VhbmRvIG5vIGhheSBwdW50b3MgY2FwdHVyYWRvcyBkZW50cm8gZGVsIMOhcmVhIHJlcHJlc2VudGFkYSBwb3IgdW4gcMOteGVsIGVuIGVsIHLDoXN0ZXIgcmVzdWx0YW50ZS4gTG9zIHZhY8Otb3MgYSBtZW51ZG8gc2Ugb2Nhc2lvbmFuIHBvciBtYXNhcyBkZSBhZ3VhLCBwb3IgbGEgc2VsZWNjacOzbiBkZSB0aXBvcyBkZSBjbGFzZSBvIHBvciBleGNsdXNpw7NuLiBFbCBsbGVuYWRvIGRlIHZhY8OtbyBzZSB1c2EgbcOhcyBjb23Dum5tZW50ZSBjdWFuZG8gc2UgZ2VuZXJhIHVuYSBzdXBlcmZpY2llIGRlIHRpZXJyYS48L2Rpdj5cIixcblx0XHRlcXVhbFRvTmFtZTogXCJJZ3VhbCBhXCIsXG5cdFx0ZXF1YWxUb1NuaXA6IFwiUmVhbGl6YSB1bmEgb3BlcmFjacOzbiByZWxhY2lvbmFsIGRlIGlndWFsZGFkIHNvYnJlIGRvcyBlbnRyYWRhcyBlbiB1bmEgYmFzZSBkZSBjZWxkYSBhIGNlbGRhLiBEZXZ1ZWx2ZSB1biAxIHBhcmEgbGFzIGNlbGRhcyBkb25kZSBlbCBwcmltZXIgcsOhc3RlciBlcyBpZ3VhbCBhbCBzZWd1bmRvIHLDoXN0ZXIgeSB1biAwIHBhcmEgbGFzIGNlbGRhcyBkb25kZSBubyBsbyBlcy5cIixcblx0XHRlcXVhbFRvRGVzYzogXCJMYSBmdW5jacOzbiByZWFsaXphIHVuYSBvcGVyYWNpw7NuIElndWFsIGEgZW4gZG9zIHLDoXN0ZXJlcyBww614ZWwgcG9yIHDDrXhlbC4gRGV2dWVsdmUgdW4gdmFsb3IgZGUgMSBwYXJhIGxvcyBww614ZWxlcyBlbiBsb3MgcXVlIGVsIHByaW1lciByw6FzdGVyIGVzIGlndWFsIGFsIHNlZ3VuZG8gcsOhc3RlciwgeSB1biB2YWxvciBkZSAwIHBhcmEgbG9zIHDDrXhlbGVzIGVuIGxvcyBxdWUgbG9zIHLDoXN0ZXJlcyBubyBzb24gaWd1YWxlcy5cIixcblx0XHRldWNBbGxvY2F0aW9uTmFtZTogXCJBc2lnbmFjacOzbiBldWNsaWRpYW5hXCIsXG5cdFx0ZXVjQWxsb2NhdGlvblNuaXA6IFwiQ2FsY3VsYSwgcGFyYSBjYWRhIGNlbGRhLCBlbCBvcmlnZW4gbcOhcyBjZXJjYW5vIHNlZ8O6biBsYSBkaXN0YW5jaWEgZXVjbGlkaWFuYS5cIixcblx0XHRldWNBbGxvY2F0aW9uRGVzYzogXCJMYSBmdW5jacOzbiBBc2lnbmFjacOzbiBldWNsaWRpYW5hIGNhbGN1bGEsIHBhcmEgY2FkYSBjZWxkYSwgZWwgb3JpZ2VuIG3DoXMgY2VyY2FubyBzZWfDum4gbGEgZGlzdGFuY2lhIGV1Y2xpZGlhbmEuXCIsXG5cdFx0ZXVjRGlyZWN0aW9uTmFtZTogXCJEaXJlY2Npw7NuIGV1Y2xpZGlhbmFcIixcblx0XHRldWNEaXJlY3Rpb25TbmlwOiBcIkNhbGN1bGEsIHBhcmEgY2FkYSBjZWxkYSwgbGEgZGlyZWNjacOzbiBlbiBncmFkb3MgaGFjaWEgZWwgb3JpZ2VuIG3DoXMgY2VyY2Fuby5cIixcblx0XHRldWNEaXJlY3Rpb25EZXNjOiBcIkxhIGZ1bmNpw7NuIERpcmVjY2nDs24gZXVjbGlkaWFuYSBjYWxjdWxhLCBwYXJhIGNhZGEgY2VsZGEsIGxhIGRpcmVjY2nDs24gZW4gZ3JhZG9zIGhhY2lhIGVsIG9yaWdlbiBtw6FzIGNlcmNhbm8uIDxkaXY+PGJyLz5MYSBkaXJlY2Npw7NuIHNlIGNhbGN1bGEgZGVzZGUgZWwgY2VudHJvIGRlIGNhZGEgY2VsZGEgaGFzdGEgZWwgY2VudHJvIGRlIGxhIGNlbGRhIGRlIG9yaWdlbiBxdWUgZXN0w6EgbcOhcyBjZXJjYS4gRWwgcmFuZ28gZGUgdmFsb3JlcyBlcyBkZSAwIGdyYWRvcyBoYXN0YSAzNjAgZ3JhZG9zLCBjb24gZWwgMCByZXNlcnZhZG8gcGFyYSBsYXMgY2VsZGFzIGRlIG9yaWdlbi4gSGFjaWEgZWwgZXN0ZSAoZGVyZWNoYSkgZXMgOTAgeSBsb3MgdmFsb3JlcyBhdW1lbnRhbiBlbiBlbCBzZW50aWRvIGRlIGxhcyBhZ3VqYXMgZGVsIHJlbG9qICgxODAgZXMgc3VyLCAyNzAgZXMgb2VzdGUgeSAzNjAgZXMgbm9ydGUpLjwvZGl2PlwiLFxuXHRcdGV1Y0Rpc3RhbmNlTmFtZTogXCJEaXN0YW5jaWEgZXVjbGlkaWFuYVwiLFxuXHRcdGV1Y0Rpc3RhbmNlU25pcDogXCJDYWxjdWxhLCBwYXJhIGNhZGEgY2VsZGEsIGxhIGRpc3RhbmNpYSBldWNsaWRpYW5hIGhhc3RhIGVsIG9yaWdlbiBtw6FzIGNlcmNhbm8uXCIsXG5cdFx0ZXVjRGlzdGFuY2VEZXNjOiBcIkxhIGZ1bmNpw7NuIERpc3RhbmNpYSBldWNsaWRpYW5hIGNhbGN1bGEsIHBhcmEgY2FkYSBjZWxkYSwgbGEgZGlzdGFuY2lhIGV1Y2xpZGlhbmEgaGFzdGEgZWwgb3JpZ2VuIG3DoXMgY2VyY2Fuby5cIixcblx0XHRleHAxME5hbWU6IFwiRXhwb25lbmNpYWwgZW4gYmFzZSAxMCAoRXhwMTApXCIsXG5cdFx0ZXhwMTBTbmlwOiBcIkNhbGN1bGEgZWwgZXhwb25lbmNpYWwgZW4gYmFzZSAxMCBkZSBsYXMgY2VsZGFzIGRlIHVuIHLDoXN0ZXIuXCIsXG5cdFx0ZXhwMTBEZXNjOiBcIkxhIGZ1bmNpw7NuIEV4cCAxMCBjYWxjdWxhIGVsIGV4cG9uZW5jaWFsIGVuIGJhc2UgMTAgZGUgbG9zIHDDrXhlbGVzIGRlIHVuIHLDoXN0ZXIuXCIsXG5cdFx0ZXhwMk5hbWU6IFwiRXhwb25lbmNpYWwgZW4gYmFzZSAyIChFeHAyKVwiLFxuXHRcdGV4cDJTbmlwOiBcIkNhbGN1bGEgZWwgZXhwb25lbmNpYWwgZW4gYmFzZSAyIGRlIGxhcyBjZWxkYXMgZGUgdW4gcsOhc3Rlci5cIixcblx0XHRleHAyRGVzYzogXCJFc3RhIGZ1bmNpw7NuIGNhbGN1bGEgZWwgZXhwb25lbmNpYWwgZW4gYmFzZSAyIGRlIGxvcyBww614ZWxlcyBkZSB1biByw6FzdGVyLlwiLFxuXHRcdGV4cE5hbWU6IFwiRXhwb25lbmNpYWwgZW4gYmFzZSBlIChFeHApXCIsXG5cdFx0ZXhwU25pcDogXCJDYWxjdWxhIGVsIGV4cG9uZW5jaWFsIGVuIGJhc2UgZSBkZSBsYXMgY2VsZGFzIGRlIHVuIHLDoXN0ZXIuXCIsXG5cdFx0ZXhwRGVzYzogXCJFc3RhIGZ1bmNpw7NuIGNhbGN1bGEgZWwgZXhwb25lbmNpYWwgZW4gYmFzZSBlIGRlIGxvcyBww614ZWxlcyBkZSB1biByw6FzdGVyLlwiLFxuXHRcdGV4dHJhY3RCYW5kTmFtZTogXCJFeHRyYWVyIGJhbmRhc1wiLFxuXHRcdGV4dHJhY3RCYW5kU25pcDogXCJFc3BlY2lmaWNhIGxhcyBiYW5kYXMgY29uIGxhcyBxdWUgc2UgdmEgYSB0cmFiYWphciBhbCB1c2FyIGRhdGFzZXRzIG11bHRpYmFuZGEuXCIsXG5cdFx0ZXh0cmFjdEJhbmREZXNjOiBcIiBMYSBmdW5jacOzbiBFeHRyYWVyIGJhbmRhcyBwZXJtaXRlIGV4dHJhZXIgdW5hIG8gdmFyaWFzIGJhbmRhcyBkZSB1biBkYXRhc2V0IHLDoXN0ZXIgbXVsdGliYW5kYSBvIHJlb3JkZW5hciBzdXMgYmFuZGFzLjxkaXY+PGJyLz5QdWVkZSB1dGlsaXphciBsYSBmdW5jacOzbiBFeHRyYWVyIGJhbmRhcyBhbnRlcyBkZSBvdHJhcyBmdW5jaW9uZXMsIGNvbW8gQXJpdG3DqXRpY2EsIHBhcmEgY29udHJvbGFyIGxhcyBiYW5kYXMgcXVlIHNlIHV0aWxpemFuIGNvbW8gZW50cmFkYSBlbiBsYSBzaWd1aWVudGUgZnVuY2nDs24uPC9kaXY+XCIsXG5cdFx0ZmlsbE5hbWU6IFwiUmVsbGVub1wiLFxuXHRcdGZpbGxTbmlwOiBcIlJlbGxlbmEgaGVuZGlkdXJhcyBlbiB1bmEgc3VwZXJmaWNpZSBkZSByw6FzdGVyIHBhcmEgcXVpdGFyIHBlcXVlw7FhcyBpbXBlcmZlY2Npb25lcyBlbiBsb3MgZGF0b3MuXCIsXG5cdFx0ZmlsbERlc2M6IFwiTGEgZnVuY2nDs24gZ2xvYmFsIFJlbGxlbm8gbG9jYWxpemEgeSByZWxsZW5hIGxvcyBzdW1pZGVyb3MgeSBwaWNvcyBkZSB1biByw6FzdGVyIGRlIHN1cGVyZmljaWUgZGUgZWxldmFjacOzbiBwYXJhIGVsaW1pbmFyIGxhcyBwZXF1ZcOxYXMgaW1wZXJmZWNjaW9uZXMgZGUgbG9zIGRhdG9zLiBMYSBmdW5jacOzbiByZWxsZW5hIHVuIHByb2Nlc28gaXRlcmF0aXZvIGhhc3RhIHF1ZSB0b2RvcyBsb3Mgc3VtaWRlcm9zIHF1ZWRhbiByZWxsZW5vcyBkZW50cm8gZGVsIEzDrW1pdGUgWiBlc3BlY2lmaWNhZG8uPGRpdj48YnIvPkN1YW5kbyBzZSBjcmVhIHVuYSBzdXBlcmZpY2llIGRlIGVsZXZhY2nDs24gY29uIGxhcyBoZXJyYW1pZW50YXMgZGUgUmVwcmVzZW50YWNpw7NuIGNhcnRvZ3LDoWZpY2EgZGUgb3J0b2ZvdG9zIG8gY29uIG90cm9zIG1lZGlvcywgYSBtZW51ZG8gc2UgcHJvZHVjZW4gZXJyb3JlcyBwZXF1ZcOxb3MsIHBlcm8gc2lnbmlmaWNhdGl2b3MsIGVuIGZvcm1hIGRlIHN1bWlkZXJvcyB5IHBpY29zIGVuIGxvcyBkYXRvcy4gRW4gZm90b2dyYW1ldHLDrWEsIGxvcyBzdW1pZGVyb3MgeSBwaWNvcyBhIG1lbnVkbyBzZSBjb25vY2VuIGNvbW8gYWd1amVyb3MgeSBwaWNvcy4gRGFkbyBxdWUgbG9zIGRhdG9zIGRlIHN1cGVyZmljaWUgYSBtZW51ZG8gc2UgdXNhbiBlbiBlbCBtb2RlbGFkbywgY29tbyBlbCBtb2RlbGFkbyBoaWRyb2zDs2dpY28sIGVzIGltcG9ydGFudGUgY29ycmVnaXIgZXN0b3MgZXJyb3JlcyBkZSBzdW1pZGVybyB5IHBpY28gZGUgZm9ybWEgY29uc2lzdGVudGUgY29uIGxvcyBkYXRvcyBjaXJjdW5kYW50ZXMuPC9kaXY+XCIsXG5cdFx0ZmxvYXROYW1lOiBcIkZsb3RhbnRlXCIsXG5cdFx0ZmxvYXRTbmlwOiBcIkNvbnZpZXJ0ZSBlbCB2YWxvciBkZSBjYWRhIGNlbGRhIGRlIHVuIHLDoXN0ZXIgZW4gdW5hIHJlcHJlc2VudGFjacOzbiBkZSBwdW50byBmbG90YW50ZS5cIixcblx0XHRmbG9hdERlc2M6IFwiTGEgZnVuY2nDs24gRmxvdGFudGUgY29udmllcnRlIGVsIHZhbG9yIGRlIHDDrXhlbCBkZSB1biByw6FzdGVyIGVuIHVuYSByZXByZXNlbnRhY2nDs24gY29uIHB1bnRvIGZsb3RhbnRlLlwiLFxuXHRcdGZsb3dBY2N1bXVsYXRpb25OYW1lOiBcIkFjdW11bGFjacOzbiBkZSBmbHVqb1wiLFxuXHRcdGZsb3dBY2N1bXVsYXRpb25TbmlwOiBcIkNyZWEgdW4gcsOhc3RlciBkZSBmbHVqbyBhY3VtdWxhZG8gZW4gY2FkYSBjZWxkYS4gT3BjaW9uYWxtZW50ZSwgcHVlZGUgYXBsaWNhciB1biBmYWN0b3IgZGUgcGVzby5cIixcblx0XHRmbG93QWNjdW11bGF0aW9uRGVzYzogXCJMYSBmdW5jacOzbiBnbG9iYWwgQWN1bXVsYWNpw7NuIGRlIGZsdWpvIGNyZWEgdW4gcsOhc3RlciBkZWwgZmx1am8gYWN1bXVsYWRvIHBhcmEgY2FkYSBww614ZWwsIGRldGVybWluYWRhIGFsIGFjdW11bGFyIGVsIHBlc28gZGUgdG9kb3MgbG9zIHDDrXhlbGVzIHF1ZSBmbHV5ZW4gaGFjaWEgY2FkYSBww614ZWwgZGVzY2VuZGVudGUuIFNpIG5vIHNlIGluZGljYSB1biByw6FzdGVyIGRlIHBlc28sIHNlIGFwbGljYSB1biBwZXNvIGRlIDEgYSBjYWRhIHDDrXhlbCwgeSBlbCB2YWxvciBkZSBsb3MgcMOteGVsZXMgZGVsIHLDoXN0ZXIgZGUgc2FsaWRhIGVzIGVsIG7Dum1lcm8gZGUgcMOteGVsZXMgcXVlIGZsdXllbiBlbiBjYWRhIHDDrXhlbC48ZGl2Pjxici8+TG9zIHDDrXhlbGVzIGRlIHNhbGlkYSBjb24gdW5hIGFjdW11bGFjacOzbiBkZSBmbHVqbyBhbHRhIHNvbiDDoXJlYXMgZGUgZmx1am8gY29uY2VudHJhZG8geSBzZSBwdWVkZW4gdXRpbGl6YXIgcGFyYSBpZGVudGlmaWNhciBjYW5hbGVzIGRlIGN1cnNvIGRlIGFndWEuIExvcyBww614ZWxlcyBkZSBzYWxpZGEgY29uIHVuYSBhY3VtdWxhY2nDs24gZGUgZmx1am8gY2VybyBzb24gbGFzIGFsdHVyYXMgdG9wb2dyw6FmaWNhcyBsb2NhbGVzIHkgc2UgcHVlZGVuIHV0aWxpemFyIHBhcmEgaWRlbnRpZmljYXIgY3Jlc3Rhcy48L2Rpdj5cIixcblx0XHRmbG93RGlyZWN0aW9uTmFtZTogXCJEaXJlY2Npw7NuIGRlIGZsdWpvXCIsXG5cdFx0Zmxvd0RpcmVjdGlvblNuaXA6IFwiQ3JlYSB1biByw6FzdGVyIGRlIGRpcmVjY2nDs24gZGUgZmx1am8gZGVzZGUgY2FkYSBjZWxkYSBoYXN0YSBzdSB2ZWNpbmEgY29uIGxhIHBlbmRpZW50ZSBkZXNjZW5kZW50ZSBtw6FzIGVtcGluYWRhLlwiLFxuXHRcdGZsb3dEaXJlY3Rpb25EZXNjOiBcIlVuYSBkZSBsYXMgY2xhdmVzIHBhcmEgZGVyaXZhciBjYXJhY3RlcsOtc3RpY2FzIGhpZHJvbMOzZ2ljYXMgZGUgdW5hIHN1cGVyZmljaWUgZXMgbGEgY2FwYWNpZGFkIGRlIGRldGVybWluYXIgbGEgZGlyZWNjacOzbiBkZSBmbHVqbyBkZSBjYWRhIHDDrXhlbCBkZWwgcsOhc3Rlci4gTGEgZnVuY2nDs24gcsOhc3RlciBEaXJlY2Npw7NuIGRlIGZsdWpvIHRvbWEgdW5hIHN1cGVyZmljaWUgY29tbyBlbnRyYWRhIHkgY3JlYSB1biByw6FzdGVyIGRlIGRpcmVjY2nDs24gZGUgZmx1am8gZGVzZGUgY2FkYSBww614ZWwgaGFzdGEgc3UgdmVjaW5vIGNvbiBsYSBwZW5kaWVudGUgZGVzY2VuZGVudGUgbcOhcyBlbXBpbmFkYS4gTGEgZnVuY2nDs24gRGlyZWNjacOzbiBkZSBmbHVqbyBhZG1pdGUgdHJlcyBtw6l0b2RvcyBkZSBtb2RlbGFkbyBkZSBmbHVqbzogRDggKG9jaG8gZGlyZWNjaW9uZXMpLCBEaXJlY2Npw7NuIGRlbCBmbHVqbyBtw7psdGlwbGUgKE1GRCkgeSBELUluZmluaXR5IChESU5GKS4gXCIsXG5cdFx0Zmxvd0Rpc3RhbmNlTmFtZTogXCJEaXN0YW5jaWEgZGUgZmx1am9cIixcblx0XHRmbG93RGlzdGFuY2VTbmlwOiBcIkNvbXB1dGEsIHBhcmEgY2FkYSBjZWxkYSwgbGEgZGlzdGFuY2lhIGhvcml6b250YWwgbyB2ZXJ0aWNhbCBtw61uaW1hIGVuIHVuYSBwZW5kaWVudGUgZGVzY2VuZGVudGUgaGFzdGEgdmFyaWFzIGNlbGRhcyBkZSB1biBjdXJzbyBkZSBhZ3VhIG8gdW4gcsOtbyBoYWNpYSBlbCBxdWUgZmx1eWVuLlwiLFxuXHRcdGZsb3dEaXN0YW5jZURlc2M6IFwiUGFyYSBjYWRhIHDDrXhlbCwgbGEgZnVuY2nDs24gY2FsY3VsYSBsYSBkaXN0YW5jaWEgaG9yaXpvbnRhbCBvIHZlcnRpY2FsIG3DrW5pbWEgZW4gcGVuZGllbnRlIGRlc2NlbmRlbnRlIGFsIHDDrXhlbCBvIGxvcyBww614ZWxlcyBkZWwgcsOtbyBvIGN1cnNvIGRlIGFndWEgZW4gZWwgcXVlIGZsdXllbi4gU2kgc2UgcHJvcG9yY2lvbmEgdW4gcsOhc3RlciBkZSBkaXJlY2Npw7NuIGRlIGZsdWpvIG9wY2lvbmFsLCBsYXMgZGlyZWNjaW9uZXMgZGUgcGVuZGllbnRlIGRlc2NlbmRlbnRlIHNlIGxpbWl0YXLDoW4gYSBhcXVlbGxhcyBkZWZpbmlkYXMgcG9yIGVsIHLDoXN0ZXIgZGUgZGlyZWNjacOzbiBkZWwgZmx1am8gZGUgZW50cmFkYS4gTGEgc2FsaWRhIGVzIHVuIHLDoXN0ZXIgZGUgZGlzdGFuY2lhIGRlIGZsdWpvLlwiLFxuXHRcdGZvY2FsTmFtZTogXCJFc3RhZMOtc3RpY2FzIGZvY2FsaXphZGFzXCIsXG5cdFx0Zm9jYWxTbmlwOiBcIkNhbGN1bGEgbGFzIGVzdGFkw61zdGljYXMgZm9jYWxlcyBwYXJhIGNhZGEgcMOteGVsIGRlIHVuYSBpbWFnZW4gYmFzw6FuZG9zZSBlbiB1bmEgdmVjaW5kYWQgZm9jYWwgZGVmaW5pZGEuXCIsXG5cdFx0Zm9jYWxEZXNjOiBcIkxhIGZ1bmNpw7NuIEVzdGFkw61zdGljYXMgZm9jYWxpemFkYXMgY2FsY3VsYSBsYXMgZXN0YWTDrXN0aWNhcyBmb2NhbGVzIHBhcmEgY2FkYSBww614ZWwgZGUgdW5hIGltYWdlbiBiYXPDoW5kb3NlIGVuIHVuYSB2ZWNpbmRhZCBmb2NhbCBkZWZpbmlkYS5cIixcblx0XHRnZW9tZXRyaWNOYW1lOiBcIkdlb23DqXRyaWNhXCIsXG5cdFx0Z2VvbWV0cmljU25pcDogXCJBdW1lbnRhIGxhIGV4YWN0aXR1ZCBkZSBwb3NpY2nDs24gZGUgdW4gZGF0YXNldCB0ZW5pZW5kbyBlbiBjdWVudGEgbGEgZWxldmFjacOzbi5cIixcblx0XHRnZW9tZXRyaWNEZXNjOiBcIkxhIGZ1bmNpw7NuIEdlb23DqXRyaWNhIGdlbmVyYSB1bmEgaW1hZ2VuIG9ydG9ycmVjdGlmaWNhZGEgYmFzYWRhIGVuIHVuYSBkZWZpbmljacOzbiBkZSBzZW5zb3IgeSB1biBtb2RlbG8gZGUgdGVycmVuby4gQXVtZW50YSBsYSBleGFjdGl0dWQgZGUgcG9zaWNpw7NuIGRlIHVuIGRhdGFzZXQgdGVuaWVuZG8gZW4gY3VlbnRhIGxhIGVsZXZhY2nDs24uXCIsXG5cdFx0Z3JheXNjYWxlTmFtZTogXCJFc2NhbGEgZGUgZ3Jpc2VzXCIsXG5cdFx0Z3JheXNjYWxlU25pcDogXCJDb252aWVydGUgdW5hIGltYWdlbiBtdWx0aWJhbmRhIGVuIHVuYSBpbWFnZW4gZW4gZXNjYWxhIGRlIGdyaXNlcyBkZSBiYW5kYSDDum5pY2EuXCIsXG5cdFx0Z3JheXNjYWxlRGVzYzogXCJFc3RhIGZ1bmNpw7NuIGNvbnZpZXJ0ZSB1bmEgaW1hZ2VuIG11bHRpYmFuZGEgZW4gdW5hIGltYWdlbiBlbiBlc2NhbGEgZGUgZ3Jpc2VzIGRlIGJhbmRhIMO6bmljYS48ZGl2Pjxici8+RXN0YSBmdW5jacOzbiBhcGxpY2EgbG9zIHBlc29zIGVzcGVjaWZpY2Fkb3MgYSBjYWRhIHVuYSBkZSBsYXMgYmFuZGFzIGRlIGVudHJhZGEgeSBub3JtYWxpemEgbGEgaW1hZ2VuIGRlIHNhbGlkYS4gTG9zIHBlc29zIHNlIGFwbGljYW4gYSBtZW51ZG8gcG9ycXVlIGFsZ3VuYXMgYmFuZGFzIHRpZW5lbiB1bmEgaW1wb3J0YW5jaWEgdmFyaWFibGUgZW4gZnVuY2nDs24gZGUgbGEgYXBsaWNhY2nDs24uIFBvciBlamVtcGxvLCBsYSBiYW5kYSBhenVsIGEgbWVudWRvIGNvbnRpZW5lIG3DoXMgcnVpZG8gcXVlIG90cmFzIGJhbmRhcy48L2Rpdj5cIixcblx0XHRncmVhdGVyVGhhbkVxdWFsTmFtZTogXCJNYXlvciBvIGlndWFsIHF1ZVwiLFxuXHRcdGdyZWF0ZXJUaGFuRXF1YWxTbmlwOiBcIlJlYWxpemEgdW5hIG9wZXJhY2nDs24gcmVsYWNpb25hbCBtYXlvciBxdWUgc29icmUgZG9zIGVudHJhZGFzIGVuIHVuYSBiYXNlIGRlIGNlbGRhIGEgY2VsZGEuIERldnVlbHZlIDEgcGFyYSBsYXMgY2VsZGFzIGRvbmRlIGVsIHByaW1lciByw6FzdGVyIGVzIG1heW9yIG8gaWd1YWwgcXVlIGVsIHNlZ3VuZG8gcsOhc3RlciB5IDAgc2kgbm8gbG8gZXMuXCIsXG5cdFx0Z3JlYXRlclRoYW5FcXVhbERlc2M6IFwiTGEgZnVuY2nDs24gcmVhbGl6YSB1bmEgb3BlcmFjacOzbiByZWxhY2lvbmFsIE1heW9yIG8gaWd1YWwgcXVlIHNvYnJlIGRvcyBlbnRyYWRhcyBww614ZWwgcG9yIHDDrXhlbC4gRGV2dWVsdmUgdW4gdmFsb3IgZGUgMSBwYXJhIGxvcyBww614ZWxlcyBlbiBsb3MgcXVlIGVsIHByaW1lciByw6FzdGVyIGVzIG1heW9yIG8gaWd1YWwgcXVlIGVsIHNlZ3VuZG8gcsOhc3RlciwgeSB1biB2YWxvciBkZSAwIHBhcmEgbG9zIHDDrXhlbGVzIGVuIGxvcyBxdWUgZWwgcHJpbWVyIHLDoXN0ZXIgbm8gZXMgbWF5b3IgbmkgaWd1YWwgcXVlIGVsIHNlZ3VuZG8gcsOhc3Rlci5cIixcblx0XHRncmVhdGVyVGhhbk5hbWU6IFwiTWF5b3IgcXVlXCIsXG5cdFx0Z3JlYXRlclRoYW5TbmlwOiBcIlJlYWxpemEgdW5hIG9wZXJhY2nDs24gcmVsYWNpb25hbCBtYXlvciBxdWUgc29icmUgZG9zIGVudHJhZGFzIGVuIHVuYSBiYXNlIGRlIGNlbGRhIGEgY2VsZGEuIERldnVlbHZlIDEgcGFyYSBsYXMgY2VsZGFzIGRvbmRlIGVsIHByaW1lciByw6FzdGVyIGVzIG1heW9yIHF1ZSBlbCBzZWd1bmRvIHLDoXN0ZXIgeSAwIHBhcmEgbGFzIGNlbGRhcyBzaSBubyBsbyBlcy5cIixcblx0XHRncmVhdGVyVGhhbkRlc2M6IFwiTGEgZnVuY2nDs24gcmVhbGl6YSB1bmEgb3BlcmFjacOzbiByZWxhY2lvbmFsIE1heW9yIHF1ZSBzb2JyZSBkb3MgZW50cmFkYXMgcMOteGVsIHBvciBww614ZWwuIERldnVlbHZlIHVuIHZhbG9yIGRlIDEgcGFyYSBsb3MgcMOteGVsZXMgZW4gbG9zIHF1ZSBlbCBwcmltZXIgcsOhc3RlciBlcyBtYXlvciBxdWUgZWwgc2VndW5kbyByw6FzdGVyLCB5IHVuIHZhbG9yIGRlIDAgcGFyYSBsb3MgcMOteGVsZXMgZW4gbG9zIHF1ZSBlbCBwcmltZXIgcsOhc3RlciBubyBlcyBtYXlvciBxdWUgZWwgc2VndW5kbyByw6FzdGVyLlwiLFxuXHRcdGhlYXRJbmRleE5hbWU6IFwiw41uZGljZSBkZSBjYWxvclwiLFxuXHRcdGhlYXRJbmRleFNuaXA6IFwiQ29tYmluYSBsYSB0ZW1wZXJhdHVyYSBhbWJpZW50ZSBkZWwgYWlyZSB5IGxhIGh1bWVkYWQgcmVsYXRpdmEgcGFyYSBkZXZvbHZlciBsYSBzZW5zYWNpw7NuIHTDqXJtaWNhLlwiLFxuXHRcdGhlYXRJbmRleERlc2M6IFwiRXN0YSBmdW5jacOzbiBjYWxjdWxhIGxhIHNlbnNhY2nDs24gdMOpcm1pY2EgYSBwYXJ0aXIgZGUgbGEgdGVtcGVyYXR1cmEgYW1iaWVudGUgeSBsYSBodW1lZGFkIHJlbGF0aXZhLiBMYSB0ZW1wZXJhdHVyYSBhcGFyZW50ZSBzZSBzdWVsZSBkZXNjcmliaXIgY29tbyBsYSBwZXJjZXBjacOzbiBkZSB0ZW1wZXJhdHVyYSBkZWwgY3VlcnBvIGh1bWFuby48ZGl2Pjxici8+RXN0ZSDDrW5kaWNlIHB1ZWRlIHJlc3VsdGFyIMO6dGlsIHBhcmEgY2FsY3VsYXIgbG9zIHBlbGlncm9zIHJlbGFjaW9uYWRvcyBjb24gcHJvYmxlbWFzIG3DqWRpY29zIGNvbW8gY2FsYW1icmVzIG11c2N1bGFyZXMsIGRlc2hpZHJhdGFjacOzbiwgYWdvdGFtaWVudG8gcG9yIGNhbG9yIG8gaW5zb2xhY2lvbmVzIGdyYXZlcyBlbiBkw61hcyBjYWx1cm9zb3MgeSBow7ptZWRvcy4gQ3VhbmRvIGxhIGh1bWVkYWQgcmVsYXRpdmEgZXMgYWx0YSwgYXVtZW50YSBsYSBkaWZpY3VsdGFkIGRlIHF1ZSBzZSBldmFwb3JlIGVsIHN1ZG9yIGRlbCBjdWVycG8sIGNvbiBsbyBxdWUgbGFzIHBlcnNvbmFzIHBpZXJkZW4gbGEgY2FwYWNpZGFkIG5hdHVyYWwgZGUgcmVkdWNpciBzdSB0ZW1wZXJhdHVyYS4gTG9zIGF2aXNvcyBvIGFkdmVydGVuY2lhcyBkZSBsb3MgbWFwYXMgZGUgY2Fsb3Igc3VlbGVuIHNlciBlbCByZXN1bHRhZG8gZGUgcmVjbGFzaWZpY2FyIGxvcyByZXN1bHRhZG9zIGRlbCDDrW5kaWNlIGRlIGNhbG9yIGVuIGNsYXNlczsgY3VhbnRvIG1heW9yIGVzIGVsIHZhbG9yIGRlbCDDrW5kaWNlLCBtw6FzIHByb2JhYmxlIGVzIHF1ZSBzZSBjb252aWVydGEgZW4gdW5hIGFkdmVydGVuY2lhIGVuIGx1Z2FyIGRlIHVuIHNpbXBsZSBhdmlzby48L2Rpdj5cIixcblx0XHRoaWxsc2hhZGVOYW1lOiBcIlNvbWJyZWFkb1wiLFxuXHRcdGhpbGxzaGFkZVNuaXA6IFwiQ3JlYSB1bmEgcmVwcmVzZW50YWNpw7NuIDNEIGRlIGxhIHN1cGVyZmljaWUgcXVlIHRpZW5lIGVuIGN1ZW50YSBsYSBwb3NpY2nDs24gcmVsYXRpdmEgZGVsIHNvbCBwYXJhIHNvbWJyZWFyIGxhIGltYWdlbi5cIixcblx0XHRoaWxsc2hhZGVEZXNjOiBcIkxhIGZ1bmNpw7NuIFNvbWJyZWFkbyBwcm9kdWNlIHVuYSByZXByZXNlbnRhY2nDs24gM0QgZW4gZXNjYWxhIGRlIGdyaXNlcyBkZSBsYSBzdXBlcmZpY2llIGRlbCB0ZXJyZW5vLCBxdWUgdGllbmUgZW4gY3VlbnRhIGxhIHBvc2ljacOzbiByZWxhdGl2YSBkZWwgc29sIHBhcmEgc29tYnJlYXIgbGEgaW1hZ2VuLiA8ZGl2Pjxici8+RWwgc29tYnJlYWRvIGVzIHVuYSB0w6ljbmljYSBxdWUgcGVybWl0ZSB2aXN1YWxpemFyIHRlcnJlbm8gZW4gZnVuY2nDs24gZGUgdW5hIGZ1ZW50ZSBkZSBsdXogeSBkZSBsYSBwZW5kaWVudGUgeSBsYSBvcmllbnRhY2nDs24gZGUgbGEgc3VwZXJmaWNpZSBkZSBlbGV2YWNpw7NuLiBFcyB1biBtw6l0b2RvIGN1YWxpdGF0aXZvIHBhcmEgdmlzdWFsaXphciBsYSB0b3BvZ3JhZsOtYSB5IG5vIHByb3BvcmNpb25hIHZhbG9yZXMgZGUgZWxldmFjacOzbiBhYnNvbHV0b3MuIDwvZGl2PlwiLFxuXHRcdGludE5hbWU6IFwiRW50ZXJvXCIsXG5cdFx0aW50U25pcDogXCJDb252aWVydGUgY2FkYSB2YWxvciBkZSBjZWxkYSBkZSB1biByw6FzdGVyIGEgdW4gZW50ZXJvIG1lZGlhbnRlIHRydW5jYW1pZW50by5cIixcblx0XHRpbnREZXNjOiBcIkxhIGZ1bmNpw7NuIEludCBjb252aWVydGUgY2FkYSB2YWxvciBkZSBww614ZWwgZGUgdW4gcsOhc3RlciBhIHVuIGVudGVybyBtZWRpYW50ZSB0cnVuY2FtaWVudG8uXCIsXG5cdFx0aW50ZXJwb2xhdGVJcnJlZ3VsYXJEYXRhTmFtZTogXCJJbnRlcnBvbGFyIGRhdG9zIGlycmVndWxhcmVzXCIsXG5cdFx0aW50ZXJwb2xhdGVJcnJlZ3VsYXJEYXRhU25pcDogXCJJbnRlcnBvbGEgYSBwYXJ0aXIgZGUgbnViZXMgZGUgcHVudG9zIG8gY3VhZHLDrWN1bGFzIGlycmVndWxhcmVzLlwiLFxuXHRcdGludGVycG9sYXRlSXJyZWd1bGFyRGF0YURlc2M6IFwiQWxndW5vcyBkYXRhc2V0cyBkZSBuZXRDREYgbyBIREYgYWxtYWNlbmFuIHN1IGdlb2xvY2FsaXphY2nDs24gY29tbyBtYXRyaWNlcyBkZSBww614ZWxlcyBvIGRhdG9zIGRlIHB1bnRvcyBjb24gZXNwYWNpb3MgaXJyZWd1bGFyZXMuIEFsIGFncmVnYXIgZXN0b3MgZGF0YXNldHMgYSB1biBkYXRhc2V0IGRlIG1vc2FpY28sIGxhIGZ1bmNpw7NuIGRlIGludGVycG9sYXIgZGF0b3MgaXJyZWd1bGFyZXMgdG9tYSBsb3MgZGF0b3MgY3VhZHJpY3VsYWRvcyBpcnJlZ3VsYXJlcyB5IGxvcyByZW11ZXN0cmVhIHBhcmEgY2FkYSBww614ZWwgdGVuZ2EgdW4gdGFtYcOxbyB1bmlmb3JtZSB5IHNlYSBjdWFkcmFkby48ZGl2Pjxici8+QWwgYWdyZWdhciB2YXJpYWJsZXMgZGUgbmV0Q0RGIG8gSERGIGEgdW4gZGF0YXNldCBkZSBtb3NhaWNvLCBjb21wcm9iYXLDoSBhdXRvbcOhdGljYW1lbnRlIHNpIGxvcyBkYXRvcyBlc3TDoW4gZGlzcHVlc3RvcyBlbiBsYSBtYXRyaXogZGUgZm9ybWEgcmVndWxhci4gU2kgbm8gZXMgYXPDrSwgc2UgcHVlZGUgdXRpbGl6YXIgbGEgZnVuY2nDs24gZGUgaW50ZXJwb2xhciBkYXRvcyBpcnJlZ3VsYXJlcyBwYXJhIGNvbnZlcnRpciBsb3MgZGF0b3MgaXJyZWd1bGFyZXMgZW4gdW4gcsOhc3RlciBjdWFkcmljdWxhZG8gcmVndWxhci4gUHVlZGUgY2FtYmlhciBlbCBtw6l0b2RvIGRlIGludGVycG9sYWNpw7NuIHkgZWwgdGFtYcOxbyBkZSBjZWxkYSB1dGlsaXphZG9zIGVuIGxhIGZ1bmNpw7NuIGRlIGludGVycG9sYXIgcsOhc3RlciBkZSBkYXRvcyBpcnJlZ3VsYXJlcy4gUGFyYSBsb3MgZGF0b3MgcsOhc3RlciBjb24gZXNwYWNpb3MgcmVndWxhcmVzLCBubyBzZSBhcGxpY2Fyw6EgbGEgaW50ZXJwb2xhY2nDs24geSBsb3MgZGF0b3Mgc2UgbGVlcsOhbiB0YWwgY3VhbC48L2Rpdj5cIixcblx0XHRpc051bGxOYW1lOiBcIkVzIG51bG9cIixcblx0XHRpc051bGxTbmlwOiBcIkRldGVybWluYSBxdcOpIHZhbG9yZXMgZGUgbG9zIHLDoXN0ZXJlcyBkZSBlbnRyYWRhIHNvbiBOb0RhdGEgYSB0cmF2w6lzIGRlIGNhZGEgY2VsZGEgaW5kaXZpZHVhbC4gRGV2dWVsdmUgdW4gdmFsb3IgZGUgMSBzaSBsb3MgdmFsb3JlcyBkZSBlbnRyYWRhIGVzIE5vRGF0YSB5IDAgcGFyYSBsYXMgY2VsZGFzIHF1ZSBubyBsbyBzb24uXCIsXG5cdFx0aXNOdWxsRGVzYzogXCJMYSBmdW5jacOzbiBFcyBudWxvIGRldGVybWluYSBxdcOpIHZhbG9yZXMgZGVsIHLDoXN0ZXIgZGUgZW50cmFkYSBzb24gTm9EYXRhIHDDrXhlbCBwb3IgcMOteGVsLiBEZXZ1ZWx2ZSB1biB2YWxvciBkZSAxIHNpIGVsIHZhbG9yIGRlIGVudHJhZGEgZXMgTm9EYXRhLCB5IHVuIHZhbG9yIGRlIDAgcGFyYSBsb3MgcMOteGVsZXMgcXVlIG5vIHNlYW4gTm9EYXRhLlwiLFxuXHRcdGtlcm5lbERlbnNpdHlOYW1lOiBcIkRlbnNpZGFkIGtlcm5lbFwiLFxuXHRcdGtlcm5lbERlbnNpdHlTbmlwOiBcIkNhbGN1bGEgdW5hIG1hZ25pdHVkIHBvciB1bmlkYWQgZGUgw6FyZWEgYSBwYXJ0aXIgZGUgZW50aWRhZGVzIGRlIHB1bnRvIG8gcG9saWzDrW5lYSBtZWRpYW50ZSB1bmEgZnVuY2nDs24ga2VybmVsIHBhcmEgYWRhcHRhciB1bmEgc3VwZXJmaWNpZSBzdWF2ZW1lbnRlIGVzdHJlY2hhZGEgYSBjYWRhIHB1bnRvIG8gcG9saWzDrW5lYS5cIixcblx0XHRrZXJuZWxEZW5zaXR5RGVzYzogXCJFc3RhIGZ1bmNpw7NuIGNhbGN1bGEgdW5hIG1hZ25pdHVkIHBvciB1bmlkYWQgZGUgw6FyZWEgYSBwYXJ0aXIgZGUgZW50aWRhZGVzIGRlIHB1bnRvIG8gcG9saWzDrW5lYSBtZWRpYW50ZSB1bmEgZnVuY2nDs24ga2VybmVsIHBhcmEgYWRhcHRhciB1bmEgc3VwZXJmaWNpZSBzdWF2ZW1lbnRlIGVzdHJlY2hhZGEgYSBjYWRhIHB1bnRvIG8gcG9saWzDrW5lYS5cIixcblx0XHRrZXlNZXRhZGF0YU5hbWU6IFwiTWV0YWRhdG9zIGNsYXZlXCIsXG5cdFx0a2V5TWV0YWRhdGFTbmlwOiBcIkludmFsaWRhIG8gaW5zZXJ0YSBtZXRhZGF0b3MgY2xhdmUgZGUgdW4gcsOhc3RlciBlbiB1bmEgY2FkZW5hIGRlIGZ1bmNpw7NuLlwiLFxuXHRcdGtleU1ldGFkYXRhRGVzYzogXCJFc3RhIGZ1bmNpw7NuIGxlIHBlcm1pdGUgaW5zZXJ0YXIgbyBpbnZhbGlkYXIgbWV0YWRhdG9zIGNsYXZlIGRlIHVuIHLDoXN0ZXIuPGRpdj48YnIvPkxhIGluZm9ybWFjacOzbiBkZSBsb3MgbWV0YWRhdG9zIGNsYXZlIHNlIHVzYSBwYXJhIGF5dWRhciBhIGxhIGFwbGljYWNpw7NuIGNvbiBwYXJ0ZSBkZWwgcHJvY2VzYW1pZW50byB5IGxhIHJlcHJlc2VudGFjacOzbiBlbiBwYW50YWxsYSwgaW5jbHV5ZW5kbyBwcm9wb3JjaW9uYXIgaW5mb3JtYWNpw7NuIMO6dGlsIGNvbW8sIHBvciBlamVtcGxvLCBlbCBub21icmUgZGVsIHNlbnNvciwgbG9zIG5vbWJyZXMgZGUgYmFuZGFzIG8gbGEgY29iZXJ0dXJhIGRlIGxhIG51YmUgYXNvY2lhZGEgYSBsYXMgaW3DoWdlbmVzLjwvZGl2PlwiLFxuXHRcdHNob3J0ZXN0UGF0aE5hbWU6IFwiUnV0YSBkZSBtZW5vciBjb3N0ZVwiLFxuXHRcdHNob3J0ZXN0UGF0aFNuaXA6IFwiUmVhbGl6YSB1biBhbsOhbGlzaXMgZGUgY29zdGUtZGlzdGFuY2lhIGNvbiBsYXMgZW50cmFkYXMgZGUgb3JpZ2VuIHkgZGVzdGlubywgcXVlIHNlIHV0aWxpemFuIGEgY29udGludWFjacOzbiBwYXJhIGRldGVybWluYXIgbGEgcnV0YSBkZSBtZW5vciBjb3N0ZSBkZXNkZSB1biBvcmlnZW4gYSB1biBkZXN0aW5vLlwiLFxuXHRcdHNob3J0ZXN0UGF0aERlc2M6IFwiTGEgZnVuY2nDs24gUnV0YSBkZSBtZW5vciBjb3N0ZSBjYWxjdWxhIGxhIHJ1dGEgZGUgbWVub3IgY29zdGUgZGVzZGUgdW4gb3JpZ2VuIGEgdW4gZGVzdGluby4gTGEgZGlzdGFuY2lhIGRlIG1lbm9yIGNvc3RlIGFjdW11bGF0aXZvIHNlIGNhbGN1bGEgcGFyYSBjYWRhIHDDrXhlbCBoYXN0YSBsYSBmdWVudGUgbcOhcyBjZXJjYW5hIHNvYnJlIHVuYSBzdXBlcmZpY2llIGRlIGNvc3RlLiBFc3RvIGdlbmVyYSB1biByw6FzdGVyIGRlIHNhbGlkYSBxdWUgcmVnaXN0cmEgbGEgcnV0YSBvIGxhcyBydXRhcyBkZSBtZW5vciBjb3N0ZSBkZXNkZSBsYXMgdWJpY2FjaW9uZXMgc2VsZWNjaW9uYWRhcyBoYXN0YSBsb3MgcMOteGVsZXMgZGUgb3JpZ2VuIG3DoXMgY2VyY2Fub3MgZGVmaW5pZG9zIGRlbnRybyBkZSBsYSBzdXBlcmZpY2llIGRlIGNvc3RlIGFjdW11bGF0aXZvIGVuIHTDqXJtaW5vcyBkZSBjb3N0ZSBkZSBkaXN0YW5jaWEuPGRpdj48YnIvPkEgY2FkYSBydXRhIGRlIG1lbm9yIGNvc3RlIHNlIGxlIGFzaWduYSB1biB2YWxvciBjdWFuZG8gc2UgZW5jdWVudHJhIGVuIGVsIHByb2Nlc28gZGUgZXNjYW5lYWRvLiBFbCBww614ZWwgZmluYWwgZGVsIFLDoXN0ZXIgZGUgb3JpZ2VuIGRlIHVuYSBydXRhIGRlIGNvc3RlIHJlY2liZSB1biB2YWxvciBpZ3VhbCBhIDEuIExhIHByaW1lcmEgcnV0YSByZWNpYmUgdW4gdmFsb3IgaWd1YWwgYSAzLCBlbCBzZWd1bmRvIGlndWFsIGEgNCB5IGFzw60gc3VjZXNpdmFtZW50ZS4gQ3VhbmRvIHNlIGZ1c2lvbmFuIHZhcmlhcyBydXRhcyB5IHNpZ3VlbiBsYSBkaXN0YW5jaWEgcmVzdGFudGUgaGFzdGEgdW4gb3JpZ2VuIGVuIGxhIG1pc21hIHJ1dGEsIGFsIHNlZ21lbnRvIGVuIGVsIHF1ZSBsYXMgZG9zIHJ1dGFzIHZpYWphbiBqdW50YXMgc2UgbGUgYXNpZ25hIGVsIHZhbG9yIDIuIEEgbGEgcGFydGUgZnVzaW9uYWRhIGRlIGxhIHJ1dGEgbm8gc2UgbGUgcHVlZGUgYXNpZ25hciBlbCB2YWxvciBkZSB1bmEgZGUgbGFzIHJ1dGFzLCB5YSBxdWUgbGEgcGFydGUgZnVzaW9uYWRhIHBlcnRlbmVjZSBhIGFtYmFzIHJ1dGFzLjwvZGl2PlwiLFxuXHRcdGxlc3NUaGFuRXF1YWxOYW1lOiBcIk1lbm9yIG8gaWd1YWwgcXVlXCIsXG5cdFx0bGVzc1RoYW5FcXVhbFNuaXA6IFwiUmVhbGl6YSB1bmEgb3BlcmFjacOzbiByZWxhY2lvbmFsIG1lbm9yIG8gaWd1YWwgcXVlIHNvYnJlIGRvcyBlbnRyYWRhcyBlbiB1bmEgYmFzZSBkZSBjZWxkYSBhIGNlbGRhLiBEZXZ1ZWx2ZSAxIHBhcmEgbGFzIGNlbGRhcyBkb25kZSBlbCBwcmltZXIgcsOhc3RlciBlcyBtZW5vciBvIGlndWFsIHF1ZSBlbCBzZWd1bmRvIHLDoXN0ZXIgeSAwIGRvbmRlIG5vIGxvIGVzLlwiLFxuXHRcdGxlc3NUaGFuRXF1YWxEZXNjOiBcIkxhIGZ1bmNpw7NuIHJlYWxpemEgdW5hIG9wZXJhY2nDs24gcmVsYWNpb25hbCBNZW5vciBvIGlndWFsIHF1ZSBzb2JyZSBkb3MgZW50cmFkYXMgcMOteGVsIHBvciBww614ZWwuIERldnVlbHZlIHVuIHZhbG9yIGRlIDEgcGFyYSBsb3MgcMOteGVsZXMgZW4gbG9zIHF1ZSBlbCBwcmltZXIgcsOhc3RlciBlcyBtZW5vciBvIGlndWFsIHF1ZSBlbCBzZWd1bmRvIHLDoXN0ZXIsIHkgdW4gdmFsb3IgZGUgMCBzaSBubyBlcyBtZW5vciBuaSBpZ3VhbCBxdWUgZWwgc2VndW5kbyByw6FzdGVyLlwiLFxuXHRcdGxlc3NUaGFuTmFtZTogXCJNZW5vciBxdWVcIixcblx0XHRsZXNzVGhhblNuaXA6IFwiUmVhbGl6YSB1bmEgb3BlcmFjacOzbiByZWxhY2lvbmFsIG1lbm9yIHF1ZSBzb2JyZSBkb3MgZW50cmFkYXMgZW4gdW5hIGJhc2UgZGUgY2VsZGEgYSBjZWxkYS4gRGV2dWVsdmUgMSBwYXJhIGxhcyBjZWxkYXMgZG9uZGUgZWwgcHJpbWVyIHLDoXN0ZXIgZXMgbWVub3IgcXVlIGVsIHNlZ3VuZG8gcsOhc3RlciB5IDAgc2kgbm8gbG8gZXMuXCIsXG5cdFx0bGVzc1RoYW5EZXNjOiBcIkxhIGZ1bmNpw7NuIHJlYWxpemEgdW5hIG9wZXJhY2nDs24gcmVsYWNpb25hbCBNZW5vciBxdWUgc29icmUgZG9zIGVudHJhZGFzIHDDrXhlbCBwb3IgcMOteGVsLiBEZXZ1ZWx2ZSB1biB2YWxvciBkZSAxIHBhcmEgbG9zIHDDrXhlbGVzIGVuIGxvcyBxdWUgZWwgcHJpbWVyIHLDoXN0ZXIgZXMgbWVub3IgcXVlIGVsIHNlZ3VuZG8gcsOhc3RlciwgeSB1biB2YWxvciBkZSAwIHNpIG5vIGVzIG1lbm9yIHF1ZSBlbCBzZWd1bmRvIHLDoXN0ZXIuXCIsXG5cdFx0bG5OYW1lOiBcIkxvZ2FyaXRtbyBuZXBlcmlhbm8gKExuKVwiLFxuXHRcdGxuU25pcDogXCJDYWxjdWxhIGVsIGxvZ2FyaXRtbyBuYXR1cmFsIChiYXNlIGUpIGRlIGxhcyBjZWxkYXMgZW4gdW4gcsOhc3Rlci5cIixcblx0XHRsbkRlc2M6IFwiTGEgZnVuY2nDs24gTG4gY2FsY3VsYSBlbCBsb2dhcml0bW8gbmF0dXJhbCAoYmFzZSBlKSBkZSBjYWRhIHDDrXhlbCBkZSB1biByw6FzdGVyLlwiLFxuXHRcdGxvZzEwTmFtZTogXCJMb2dhcml0bW8gZW4gYmFzZSAxMCAoTG9nMTApXCIsXG5cdFx0bG9nMTBTbmlwOiBcIkNhbGN1bGEgZWwgbG9nYXJpdG1vIGJhc2UgMTAgZGUgbGFzIGNlbGRhcyBlbiB1biByw6FzdGVyLlwiLFxuXHRcdGxvZzEwRGVzYzogXCJMYSBmdW5jacOzbiBMb2cxMCBjYWxjdWxhIGVsIGxvZ2FyaXRtbyBlbiBiYXNlIDEwIGRlIGNhZGEgcMOteGVsIGRlIHVuIHLDoXN0ZXIuXCIsXG5cdFx0bG9nMk5hbWU6IFwiTG9nYXJpdG1vIGVuIGJhc2UgMiAoTG9nMilcIixcblx0XHRsb2cyU25pcDogXCJDYWxjdWxhIGVsIGxvZ2FyaXRtbyBiYXNlIDIgZGUgbGFzIGNlbGRhcyBlbiB1biByw6FzdGVyLlwiLFxuXHRcdGxvZzJEZXNjOiBcIkxhIGZ1bmNpw7NuIExvZzIgY2FsY3VsYSBlbCBsb2dhcml0bW8gZW4gYmFzZSAyIGRlIGNhZGEgcMOteGVsIGRlIHVuIHLDoXN0ZXIuXCIsXG5cdFx0bG9va3VwTmFtZTogXCJCw7pzcXVlZGFcIixcblx0XHRsb29rdXBTbmlwOiBcIkNyZWEgdW4gbnVldm8gcsOhc3RlciBhIHBhcnRpciBkZSBsYSBiw7pzcXVlZGEgZGUgdmFsb3JlcyBxdWUgc2UgZW5jdWVudHJhbiBlbiBvdHJvIGNhbXBvIGVuIGxhIHRhYmxhIGRlbCByw6FzdGVyIGRlIGVudHJhZGEuXCIsXG5cdFx0bG9va3VwRGVzYzogXCJMYSBmdW5jacOzbiBjcmVhIHVuIG51ZXZvIHLDoXN0ZXIgYSBwYXJ0aXIgZGUgbGEgYsO6c3F1ZWRhIGRlIHZhbG9yZXMgcXVlIHNlIGVuY3VlbnRyYW4gZW4gb3RybyBjYW1wbyBlbiBsYSB0YWJsYSBkZWwgcsOhc3RlciBkZSBlbnRyYWRhLlwiLFxuXHRcdG1sQ2xhc3NpZnlOYW1lOiBcIkNsYXNpZmljYXIgTUxcIixcblx0XHRtbENsYXNzaWZ5U25pcDogXCJDbGFzaWZpY2EgbGFzIGltw6FnZW5lcyBhcGxpY2FuZG8gdW4gcGxhbnRlYW1pZW50byBkZSBww614ZWwgYSBww614ZWwuIFNlIGFzaWduYW4gcMOteGVsZXMgbWl4dG9zIGEgbGEgZW50aWRhZCBjb24gZWwgcG9yY2VudGFqZSBtw6FzIGFsdG8gZGUgZXNlIHDDrXhlbC5cIixcblx0XHRtbENsYXNzaWZ5RGVzYzogXCJMYSBmdW5jacOzbiBDbGFzaWZpY2FyIE1MIGxlIHBlcm1pdGUgcmVhbGl6YXIgdW5hIGNsYXNpZmljYWNpw7NuIHN1cGVydmlzYWRhIHV0aWxpemFuZG8gZWwgYWxnb3JpdG1vIGRlIGNsYXNpZmljYWNpw7NuIGRlIG3DoXhpbWEgdmVyb3NpbWlsaXR1ZCBzb2JyZSB1biBkYXRhc2V0IHLDoXN0ZXIgbyB1biBkYXRhc2V0IGRlIG1vc2FpY28uIEVzdGEgZnVuY2nDs24gcmVxdWllcmUgdW4gYXJjaGl2byBkZSBmaXJtYSBkZSBjbGFzaWZpY2FjacOzbi5cIixcblx0XHRtYXNrTmFtZTogXCJNw6FzY2FyYVwiLFxuXHRcdG1hc2tTbmlwOiBcIkVzdGFibGVjZSBsb3MgdmFsb3JlcyBxdWUgbm8gcXVpZXJlIG1vc3RyYXIuXCIsXG5cdFx0bWFza0Rlc2M6IFwiRXN0YSBmdW5jacOzbiByw6FzdGVyIGRlZmluZSB2YWxvcmVzIHF1ZSBubyBkZXNlYXLDoSBtb3N0cmFyIGVuIHN1IHLDoXN0ZXIuIENvbiBsYSBmdW5jacOzbiBNw6FzY2FyYSwgZXNwZWNpZmljYXLDoSB1bm8gbyB2YXJpb3MgdmFsb3JlcyBOb0RhdGEgbyB1biByYW5nbyBkZSB2YWxvcmVzIGRlIHDDrXhlbCB2w6FsaWRvLiBcIixcblx0XHRtaW51c05hbWU6IFwiUmVzdGFcIixcblx0XHRtaW51c1NuaXA6IFwiUmVzdGEgZWwgdmFsb3IgZGVsIHNlZ3VuZG8gcsOhc3RlciBkZSBlbnRyYWRhIGFsIHZhbG9yIGRlbCBwcmltZXIgcsOhc3RlciBkZSBlbnRyYWRhIGNlbGRhIHBvciBjZWxkYS5cIixcblx0XHRtaW51c0Rlc2M6IFwiTGEgZnVuY2nDs24gTWVub3MgcmVzdGEgZWwgdmFsb3IgZGVsIHNlZ3VuZG8gcsOhc3RlciBkZSBlbnRyYWRhIGRlbCB2YWxvciBkZWwgcHJpbWVyIHLDoXN0ZXIgZGUgZW50cmFkYSBww614ZWwgcG9yIHDDrXhlbC5cIixcblx0XHRtb2ROYW1lOiBcIk3Ds2R1bG9cIixcblx0XHRtb2RTbmlwOiBcIkRldGVybWluYSBlbCByZXN0byAobcOzZHVsbykgZGVsIHByaW1lciByw6FzdGVyIGN1YW5kbyBzZSBkaXZpZGUgcG9yIGVsIHNlZ3VuZG8gcsOhc3RlciBjZWxkYSBwb3IgY2VsZGEuXCIsXG5cdFx0bW9kRGVzYzogXCJMYSBmdW5jacOzbiBNb2QgZGV0ZXJtaW5hIGVsIHJlc3RvIChtw7NkdWxvKSBkZWwgcHJpbWVyIHLDoXN0ZXIgY3VhbmRvIHNlIGRpdmlkZSBwb3IgZWwgc2VndW5kbyByw6FzdGVyIHDDrXhlbCBwb3IgcMOteGVsLiBFbCBvcmRlbiBkZSBsYXMgZW50cmFkYXMgZXMgaW1wb3J0YW50ZSB5IGFmZWN0YSBhbCByZXN1bHRhZG8gZGUgc2FsaWRhLlwiLFxuXHRcdG1vc2FpY1Jhc3RlcnNOYW1lOiBcIlLDoXN0ZXJlcyBkZSBtb3NhaWNvXCIsXG5cdFx0bW9zYWljUmFzdGVyc1NuaXA6IFwiVW5lIHVuIGNvbmp1bnRvIGRlIGRhdGFzZXRzIHLDoXN0ZXIgcGFyYSBjcmVhciB1biBkYXRhc2V0LlwiLFxuXHRcdG1vc2FpY1Jhc3RlcnNEZXNjOiBcIkxhIGZ1bmNpw7NuIFLDoXN0ZXJlcyBkZSBtb3NhaWNvIGNyZWEgdW5hIGltYWdlbiBkZSBtb3NhaWNvIGEgcGFydGlyIGRlIHZhcmlhcyBpbcOhZ2VuZXMuIFNpIGhheSBzdXBlcnBvc2ljacOzbiBlbnRyZSBsYXMgaW3DoWdlbmVzLCBoYXkgdmFyaW9zIG3DqXRvZG9zIGVudHJlIGxvcyBxdWUgc2UgcHVlZGUgZWxlZ2lyIHBhcmEgZGV0ZXJtaW5hciBxdcOpIGltw6FnZW5lcyBzZSBtdWVzdHJhbi5cIixcblx0XHRuZHZpQ29sb3JpemVkTmFtZTogXCJORFZJIGEgY29sb3JcIixcblx0XHRuZHZpQ29sb3JpemVkU25pcDogXCJDcmVhIHVuIGRhdGFzZXQgbXVsdGliYW5kYSBxdWUgcmVwcmVzZW50YSBsYSBzYWx1ZCBkZSBsYSB2ZWdldGFjacOzbiwgZW4gZnVuY2nDs24gZGUgbGEgZGlmZXJlbmNpYSBlbnRyZSBsYXMgYmFuZGFzIHJvamEgZSBpbmZyYXJyb2phIGNlcmNhbmEuXCIsXG5cdFx0bmR2aUNvbG9yaXplZERlc2M6IFwiTGEgZnVuY2nDs24gTkRWSSBhIGNvbG9yIGFwbGljYSBsYSBmdW5jacOzbiBOVkRJIGEgbGEgaW1hZ2VuIGRlIGVudHJhZGEgeSwgYSBjb250aW51YWNpw7NuLCB1dGlsaXphIHVuIG1hcGEgZGUgY29sb3IgbyB1bmEgcmFtcGEgZGUgY29sb3IgcGFyYSBtb3N0cmFyIGVsIHJlc3VsdGFkby5cIixcblx0XHRuZHZpTmFtZTogXCJORFZJXCIsXG5cdFx0bmR2aVNuaXA6IFwiQ2FsY3VsYSB1biDDjW5kaWNlIGRlIFZlZ2V0YWNpw7NuIGRlIERpZmVyZW5jaWEgTm9ybWFsaXphZGEgKE5EVkkpLlwiLFxuXHRcdG5kdmlEZXNjOiBcIkxhIGZ1bmNpw7NuIE5EVkkgY3JlYSB1biBkYXRhc2V0IGRlIGJhbmRhIMO6bmljYSBxdWUgcmVwcmVzZW50YSBsYSBzYWx1ZCBkZSBsYSB2ZWdldGFjacOzbiwgZW4gZnVuY2nDs24gZGUgbGEgZGlmZXJlbmNpYSBlbnRyZSBsYXMgYmFuZGFzIHJvamEgZSBpbmZyYXJyb2phIGNlcmNhbmEuPGRpdj48YnIvPkVsIE5EVkkgZXMgdW4gw61uZGljZSBub3JtYWxpemFkbyBxdWUgbGUgcGVybWl0ZSBnZW5lcmFyIHVuYSBpbWFnZW4gcXVlIG11ZXN0cmEgZWwgdmVyZG9yLCB0YW1iacOpbiBjb25vY2lkYSBjb21vIGJpb21hc2EgcmVsYXRpdmEuIEVzdGUgw61uZGljZSBhcHJvdmVjaGEgZWwgY29udHJhc3RlIGRlIGNhcmFjdGVyw61zdGljYXMgZW50cmUgZG9zIGJhbmRhcyBkZSB1biBkYXRhc2V0IHLDoXN0ZXIgbXVsdGllc3BlY3RyYWw6IGxhIGFic29yY2nDs24gZGUgcGlnbWVudG8gZGUgY2xvcm9maWxhIGVuIGxhIGJhbmRhIHJvamEgeSBsYSBhbHRhIHJlZmxlY3RpdmlkYWQgZGVsIG1hdGVyaWFsIGRlIGxhcyBwbGFudGFzIGVuIGxhIGJhbmRhIGluZnJhcnJvamEgY2VyY2FuYSAoTklSKS4gTG9zIHZhbG9yZXMgTkRWSSBleHRyZW1hZGFtZW50ZSBiYWpvcyBvIG5lZ2F0aXZvcyByZXByZXNlbnRhbiBhIGxhcyDDoXJlYXMgc2luIG5pbmd1bmEgdmVnZXRhY2nDs24sIHRhbGVzIGNvbW8gbnViZXMsIGFndWEgbyBuaWV2ZS4gTG9zIHZhbG9yZXMgbXV5IGJham9zIHJlcHJlc2VudGFuIGEgw6FyZWFzIGNvbiBtdXkgcG9jYSB2ZWdldGFjacOzbiBvIHNpbiBuaW5ndW5hIHZlZ2V0YWNpw7NuLCB0YWxlcyBjb21vIGhvcm1pZ8OzbiwgcGllZHJhIG8gc3VlbG8gZGVzbnVkby4gTG9zIHZhbG9yZXMgbW9kZXJhZG9zIHJlcHJlc2VudGFuIMOhcmVhcyBkZSBtYXRvcnJhbGVzIHkgcHJhZGVyYXMuIExvcyB2YWxvcmVzIGFsdG9zIHJlcHJlc2VudGFuIGEgbGFzIHpvbmFzIGZvcmVzdGFsZXMgeSBsYSB2ZWdldGFjacOzbiBkZW5zYS48L2Rpdj5cIixcblx0XHRuZWdhdGVOYW1lOiBcIkNhbWJpbyBkZSBzaWdub1wiLFxuXHRcdG5lZ2F0ZVNuaXA6IFwiQ2FtYmlhIGVsIHNpZ25vIChtdWx0aXBsaWNhIHBvciAtMSkgZGUgbG9zIHZhbG9yZXMgZGUgY2VsZGEgZGVsIHLDoXN0ZXIgZGUgZW50cmFkYSBjZWxkYSBwb3IgY2VsZGEuXCIsXG5cdFx0bmVnYXRlRGVzYzogXCJMYSBmdW5jacOzbiBDYW1iaW8gZGUgU2lnbm8gY2FtYmlhIGVsIHNpZ25vIChtdWx0aXBsaWNhIHBvciAtMSkgZGUgbG9zIHZhbG9yZXMgZGUgcMOteGVsIGRlbCByw6FzdGVyIGRlIGVudHJhZGEgZW4gdW4gcMOteGVsLiBcIixcblx0XHRuaWJibGVOYW1lOiBcIk5pYmJsZVwiLFxuXHRcdG5pYmJsZVNuaXA6IFwiUmVlbXBsYXphIGxhcyBjZWxkYXMgZGUgdW4gcsOhc3RlciBxdWUgY29ycmVzcG9uZGVuIGEgdW5hIG3DoXNjYXJhIGNvbiBsb3MgdmFsb3JlcyBkZSBsb3MgdmVjaW5vcyBtw6FzIGNlcmNhbm9zLlwiLFxuXHRcdG5pYmJsZURlc2M6IFwiTGEgZnVuY2nDs24gZ2xvYmFsIE5pYmJsZSBwZXJtaXRlIGFzaWduYXIgYSBsYXMgw6FyZWFzIHNlbGVjY2lvbmFkYXMgZGUgdW4gcsOhc3RlciBlbCB2YWxvciBkZSBzdSB2ZWNpbm8gbcOhcyBjZXJjYW5vLiBSZXN1bHRhIMO6dGlsIHBhcmEgbGEgZWRpY2nDs24gZGUgw6FyZWFzIGRlIHVuIHLDoXN0ZXIgZW4gbGFzIHF1ZSBsb3MgZGF0b3MgcHVlZGVuIHNlciBlcnLDs25lb3MuXCIsXG5cdFx0bm90RXF1YWxOYW1lOiBcIk5vIGlndWFsXCIsXG5cdFx0bm90RXF1YWxTbmlwOiBcIlJlYWxpemEgdW5hIG9wZXJhY2nDs24gcmVsYWNpb25hbCBkZSBkZXNpZ3VhbGRhZCBzb2JyZSBkb3MgZW50cmFkYXMgYSB0cmF2w6lzIGRlIGNhZGEgY2VsZGEgaW5kaXZpZHVhbC4gRGV2dWVsdmUgMSBwYXJhIGxhcyBjZWxkYXMgZG9uZGUgZWwgcHJpbWVyIHLDoXN0ZXIgbm8gZXMgaWd1YWwgYWwgc2VndW5kbyByw6FzdGVyIHkgMCBkb25kZSBlcyBpZ3VhbC5cIixcblx0XHRub3RFcXVhbERlc2M6IFwiTGEgZnVuY2nDs24gcmVhbGl6YSB1bmEgb3BlcmFjacOzbiByZWxhY2lvbmFsIE5vIGlndWFsIHF1ZSBzb2JyZSBkb3MgZW50cmFkYXMgcMOteGVsIHBvciBww614ZWwuIERldnVlbHZlIHVuIHZhbG9yIGRlIDEgcGFyYSBsb3MgcMOteGVsZXMgZW4gbG9zIHF1ZSBlbCBwcmltZXIgcsOhc3RlciBubyBlcyBpZ3VhbCBhbCBzZWd1bmRvIHLDoXN0ZXIsIHkgdW4gdmFsb3IgZGUgMCBwYXJhIGxvcyBww614ZWxlcyBkb25kZSBlcyBpZ3VhbCBhbCBzZWd1bmRvIHLDoXN0ZXIuXCIsXG5cdFx0cGFuc2hhcnBlbmluZ05hbWU6IFwiUmVmaW5hZG8gcGFuY3JvbcOhdGljb1wiLFxuXHRcdHBhbnNoYXJwZW5pbmdTbmlwOiBcIk1lam9yYSBhcnRpZmljaWFsbWVudGUgbGEgcmVzb2x1Y2nDs24gZXNwYWNpYWwgZGUgdW5hIGltYWdlbiBtdWx0aWJhbmRhIG1lZGlhbnRlIHN1IGZ1c2nDs24gY29uIHVuYSBpbWFnZW4gcGFuY3JvbcOhdGljYSBkZSBtYXlvciByZXNvbHVjacOzbi5cIixcblx0XHRwYW5zaGFycGVuaW5nRGVzYzogXCJMYSBmdW5jacOzbiBSZWZpbmFkbyBwYW5jcm9tw6F0aWNvIHV0aWxpemEgdW5hIGltYWdlbiBwYW5jcm9tw6F0aWNhIGRlIG1heW9yIHJlc29sdWNpw7NuIG8gYmFuZGEgZGUgcsOhc3RlciBwYXJhIGZ1c2lvbmFybGEgY29uIHVuIGRhdGFzZXQgcsOhc3RlciBtdWx0aWJhbmRhIGRlIG1lbm9yIHJlc29sdWNpw7NuIHkgYXPDrSBhdW1lbnRhciBsYSByZXNvbHVjacOzbiBlc3BhY2lhbCBkZSBsYSBpbWFnZW4gbXVsdGliYW5kYS48ZGl2Pjxici8+TGEgZmluYWxpZGFkIGRlbCByZWZpbmFkbyBwYW5jcm9tw6F0aWNvIGVzIGNyZWFyIHVuYSBpbWFnZW4gdmlzdWFsIGRlIG1heW9yIGNhbGlkYWQuIERhZG8gcXVlIGxhcyB0w6ljbmljYXMgbW9kaWZpY2FuIGxhcyBjYXJhY3RlcsOtc3RpY2FzIHJhZGlvbcOpdHJpY2FzIHkgZXNwZWN0cmFsZXMgZGUgbGFzIGltw6FnZW5lcyBtdWx0aWJhbmRhLCBsYXMgaW3DoWdlbmVzIGNvbiByZWZpbmFkbyBwYW5jcm9tw6F0aWNvIHNlIGRlYmVuIHVzYXIgY29uIGNhdXRlbGEgcGFyYSBmaW5lcyBkZSB0ZWxlZGV0ZWNjacOzbiBhbmFsw610aWNhLjwvZGl2PlwiLFxuXHRcdHBhdGhBbGxvY2F0aW9uTmFtZTogXCJBc2lnbmFjacOzbiBkZSBsYSBkaXN0YW5jaWEgZGUgcnV0YVwiLFxuXHRcdHBhdGhBbGxvY2F0aW9uU25pcDogXCJDYWxjdWxhIGVsIG9yaWdlbiBkZSBtZW5vciBjb3N0ZSBwYXJhIGNhZGEgY2VsZGEgZW4gZnVuY2nDs24gZGVsIG1lbm9yIGNvc3RlIGFjdW11bGF0aXZvIHBvciB1bmEgc3VwZXJmaWNpZSBkZSBjb3N0ZSB5IHRpZW5lIGVuIGN1ZW50YSBsYSBkaXN0YW5jaWEgZGUgbGEgc3VwZXJmaWNpZSB5IGxvcyBmYWN0b3JlcyBkZSBjb3N0ZSBob3Jpem9udGFsIHkgdmVydGljYWwuXCIsXG5cdFx0cGF0aEFsbG9jYXRpb25EZXNjOiBcIkxhIGZ1bmNpw7NuIEFzaWduYWNpw7NuIGRlIGRpc3RhbmNpYSBkZSBydXRhIGNhbGN1bGEgbGEgZnVlbnRlIG3DoXMgY2VyY2FuYSBhIGNhZGEgY2VsZGEgZW4gZnVuY2nDs24gZGVsIGNvc3RlIGFjdW11bGF0aXZvIGluZmVyaW9yIHNvYnJlIHVuYSBzdXBlcmZpY2llIGRlIGNvc3RlIGEgbGEgdmV6IHF1ZSBzZSB0aWVuZSBlbiBjdWVudGEgbGEgZGlzdGFuY2lhIGRlIGxhIHN1cGVyZmljaWUgeSBsb3MgZmFjdG9yZXMgZGUgY29zdGUgdmVydGljYWwgeSBob3Jpem9udGFsLlwiLFxuXHRcdHBhdGhCYWNrTGlua05hbWU6IFwiVsOtbmN1bG8gZGUgbWVub3IgZGlzdGFuY2lhIGRlIHJ1dGFcIixcblx0XHRwYXRoQmFja0xpbmtTbmlwOiBcIkRlZmluZSBlbCB2ZWNpbm8gcXVlIGVzIGxhIGNlbGRhIHNpZ3VpZW50ZSBlbiBsYSBydXRhIGRlIG1lbm9yIGNvc3RlIGFjdW11bGF0aXZvIGhhc3RhIGVsIG9yaWdlbiBkZSBtZW5vciBjb3N0ZSB5IHRpZW5lIGVuIGN1ZW50YSBsYSBkaXN0YW5jaWEgZGUgbGEgc3VwZXJmaWNpZSB5IGxvcyBmYWN0b3JlcyBkZSBjb3N0ZSBob3Jpem9udGFsIHkgdmVydGljYWwuXCIsXG5cdFx0cGF0aEJhY2tMaW5rRGVzYzogXCJMYSBmdW5jacOzbiBWw61uY3VsbyBkZSBtZW5vciBkaXN0YW5jaWEgZGUgcnV0YSBpZGVudGlmaWNhIGxhIGRpcmVjY2lvbmFsaWRhZCBkZWwgdmVjaW5vIHF1ZSBlcyBsYSBjZWxkYSBzaWd1aWVudGUgZW4gbGEgcnV0YSBkZSBjb3N0ZSBhY3VtdWxhdGl2byBpbmZlcmlvciBhIGxhIGZ1ZW50ZSBtw6FzIGNlcmNhbmEsIGEgbGEgdmV6IHF1ZSBzZSB0aWVuZSBlbiBjdWVudGEgbGEgZGlzdGFuY2lhIGRlIGxhIHN1cGVyZmljaWUgeSBsb3MgZmFjdG9yZXMgZGUgY29zdGUgaG9yaXpvbnRhbCB5IHZlcnRpY2FsLlwiLFxuXHRcdHBhdGhEaXN0YW5jZU5hbWU6IFwiRGlzdGFuY2lhIGRlIHJ1dGFcIixcblx0XHRwYXRoRGlzdGFuY2VTbmlwOiBcIkNhbGN1bGEsIHBhcmEgY2FkYSBjZWxkYSwgZWwgbWVub3IgY29zdGUgZGUgZGlzdGFuY2lhIGFjdW11bGF0aXZvIGRlc2RlIG8gaGFzdGEgZWwgb3JpZ2VuIGRlIG1lbm9yIGNvc3RlIHkgdGllbmUgZW4gY3VlbnRhIGxhIGRpc3RhbmNpYSBkZSBsYSBzdXBlcmZpY2llIHkgbG9zIGZhY3RvcmVzIGRlIGNvc3RlIGhvcml6b250YWwgeSB2ZXJ0aWNhbC5cIixcblx0XHRwYXRoRGlzdGFuY2VEZXNjOiBcIkxhIGZ1bmNpw7NuIERpc3RhbmNpYSBkZSBydXRhIGNhbGN1bGEgcGFyYSBjYWRhIGNlbGRhIGxhIGRpc3RhbmNpYSBkZSBjb3N0ZSBhY3VtdWxhdGl2byBpbmZlcmlvciBhIGxhIGZ1ZW50ZSBtw6FzIGNlcmNhbmEgYSBsYSB2ZXogcXVlIHNlIHRpZW5lIGVuIGN1ZW50YSBsYSBkaXN0YW5jaWEgZGUgbGEgc3VwZXJmaWNpZSB5IGxvcyBmYWN0b3JlcyBkZSBjb3N0ZSB2ZXJ0aWNhbCB5IGhvcml6b250YWwuXCIsXG5cdFx0cGx1c05hbWU6IFwiUGx1c1wiLFxuXHRcdHBsdXNTbmlwOiBcIkFncmVnYSAoc3VtYSkgbG9zIHZhbG9yZXMgZGUgZG9zIHLDoXN0ZXJlcyBjZWxkYSBwb3IgY2VsZGEuXCIsXG5cdFx0cGx1c0Rlc2M6IFwiTGEgZnVuY2nDs24gU3VtYSBhZ3JlZ2EgKHN1bWEpIGxvcyB2YWxvcmVzIGRlIGRvcyByw6FzdGVyZXMgcMOteGVsIHBvciBww614ZWwuXCIsXG5cdFx0cG93ZXJOYW1lOiBcIlBvdGVuY2lhXCIsXG5cdFx0cG93ZXJTbmlwOiBcIkVsZXZhIGxvcyB2YWxvcmVzIGRlIGNlbGRhIGRlIHVuIHLDoXN0ZXIgYSBsYSBwb3RlbmNpYSBkZSBsb3MgdmFsb3JlcyBlbmNvbnRyYWRvcyBlbiBvdHJvIHLDoXN0ZXIuXCIsXG5cdFx0cG93ZXJEZXNjOiBcIkxhIGZ1bmNpw7NuIFBvdGVuY2lhIGVsZXZhIGxvcyB2YWxvcmVzIGRlIHDDrXhlbCBkZSB1biByw6FzdGVyIGEgbGEgcG90ZW5jaWEgZGUgbG9zIHZhbG9yZXMgZW5jb250cmFkb3MgZW4gb3RybyByw6FzdGVyLlwiLFxuXHRcdHJhZGFyQ2FsaWJyYXRpb25OYW1lOiBcIkNhbGlicmFjacOzbiBkZSByYWRhclwiLFxuXHRcdHJhZGFyQ2FsaWJyYXRpb25TbmlwOiBcIkNvbnZpZXJ0ZSBSQURBUlNBVC0yIGEgcmV0cm9kaXNwZXJzacOzbi5cIixcblx0XHRyYWRhckNhbGlicmF0aW9uRGVzYzogXCJFc3RhIGZ1bmNpw7NuIHNlIHV0aWxpemEgcGFyYSBjYWxpYnJhciBpbcOhZ2VuZXMgUkFEQVJTQVQtMiBlbiB1biBkYXRhc2V0IGRlIG1vc2FpY28gbyBjb21vIHByb2R1Y3RvIHLDoXN0ZXIuIExhIGNhbGlicmFjacOzbiBzZSByZWFsaXphIGVuIGxhcyBpbcOhZ2VuZXMgZGUgcmFkYXIgZGUgbWFuZXJhIHF1ZSBsb3MgdmFsb3JlcyBkZSBww614ZWwgc2VhbiB1bmEgcmVwcmVzZW50YWNpw7NuIHZlcmRhZGVyYSBkZSBsYSByZXRyb2Rpc3BlcnNpw7NuIGRlbCByYWRhci5cIixcblx0XHRyYXN0ZXJJbmZvTmFtZTogXCJSYXN0ZXJJbmZvXCIsXG5cdFx0cmFzdGVySW5mb1NuaXA6IFwiTW9kaWZpY2EgbGFzIHByb3BpZWRhZGVzIGRlbCByw6FzdGVyLCBjb21vIGxhIHByb2Z1bmRpZGFkIGRlIGJpdCwgZWwgdmFsb3IgTm9EYXRhLCBlbCB0YW1hw7FvIGRlIGNlbGRhLCBldGMuXCIsXG5cdFx0cmFzdGVySW5mb0Rlc2M6IFwiTGEgSW5mb3JtYWNpw7NuIGRlIHLDoXN0ZXIgYWJyZSB1biBjdWFkcm8gZGUgZGnDoWxvZ28gY29uIHByb3BpZWRhZGVzIGRlbCBkYXRhc2V0IHLDoXN0ZXIsIGNvbW8gZWwgbsO6bWVybyBkZSBjb2x1bW5hcyB5IGZpbGFzLCBlbCBuw7ptZXJvIGRlIGJhbmRhcywgZWwgdGlwbyBkZSBww614ZWwsIGxhIGV4dGVuc2nDs24geSBsYSByZWZlcmVuY2lhIGVzcGFjaWFsLiBQdWVkZSBlZGl0YXIgZXN0YXMgcHJvcGllZGFkZXMgYWwgc2VsZWNjaW9uYXIgdW4gZGF0YXNldCByw6FzdGVyIHBhcmEgdXRpbGl6YXIgY29tbyBwbGFudGlsbGEuIFwiLFxuXHRcdHJhc3Rlcml6ZUF0dHJpYnV0ZXNOYW1lOiBcIlJhc3Rlcml6YXIgYXRyaWJ1dG9zXCIsXG5cdFx0cmFzdGVyaXplQXR0cmlidXRlc1NuaXA6IFwiRW5yaXF1ZWNlIHVuIHLDoXN0ZXIgbWVkaWFudGUgYmFuZGFzIGFkaWNpb25hbGVzIGRlcml2YWRhcyBkZSB2YWxvcmVzIGRlIGF0cmlidXRvcyBlc3BlY2lmaWNhZG9zLCBkZXNkZSB1bmEgdGFibGEgZXh0ZXJuYSBvIHVuIHNlcnZpY2lvIGRlIGVudGlkYWRlcy5cIixcblx0XHRyYXN0ZXJpemVBdHRyaWJ1dGVzRGVzYzogXCJMYSBmdW5jacOzbiBSYXN0ZXJpemFyIGF0cmlidXRvcyBlbnJpcXVlY2UgdW4gcsOhc3RlciBhZ3JlZ2FuZG8gYmFuZGFzIGRlcml2YWRhcyBkZSB2YWxvcmVzIGRlIGF0cmlidXRvcyBlc3BlY2lmaWNhZG9zLCBkZXNkZSB1bmEgdGFibGEgZXh0ZXJuYSBvIHVuIHNlcnZpY2lvIGRlIGVudGlkYWRlcy4gVGFtYmnDqW4gcHVlZGUgZXNwZWNpZmljYXIgdW4gcsOhc3RlciBkZSB6b25hIHkgZWwgYXRyaWJ1dG8gZGUgSWQuIGRlIHpvbmEgYXNvY2lhZG8gcGFyYSBoYWJpbGl0YXIgY29uc3VsdGFzIHJlZ2lvbmFsZXMuXCIsXG5cdFx0cmFzdGVyaXplRmVhdHVyZUNsYXNzTmFtZTogXCJSYXN0ZXJpemFyIGVudGlkYWRlc1wiLFxuXHRcdHJhc3Rlcml6ZUZlYXR1cmVDbGFzc1NuaXA6IFwiQ29udmllcnRlIGVudGlkYWRlcyBlbiB1biByw6FzdGVyLlwiLFxuXHRcdHJhc3Rlcml6ZUZlYXR1cmVDbGFzc0Rlc2M6IFwiRXN0YSBmdW5jacOzbiBjb252aWVydGUgZGF0b3MgZGUgdW5hIGNsYXNlIGRlIGVudGlkYWQgcG9saWdvbmFsLCBkZSBwb2xpbMOtbmVhIHkgZGUgcHVudG8gZW4gdW5hIGNhcGEgcsOhc3Rlci48ZGl2Pjxici8+QSBsYXMgZW50aWRhZGVzIHNlIGxlcyBhc2lnbmFuIHZhbG9yZXMgZGUgcMOteGVsIHNlZ8O6biBlbCBPQkpFQ1RJRCBkZSBsYSBlbnRpZGFkIChwcmVkZXRlcm1pbmFkbykuIE9wY2lvbmFsbWVudGUsIGxvcyB2YWxvcmVzIGRlIHDDrXhlbCBwdWVkZW4gZXN0YXIgYmFzYWRvcyBlbiB1biBjYW1wbyBkZSB2YWxvciBkZWZpbmlkbyBwb3IgZWwgdXN1YXJpbyBlbiBsYSB0YWJsYSBkZSBhdHJpYnV0b3MgZGUgbGEgZW50aWRhZCBkZSBlbnRyYWRhLjwvZGl2PlwiLFxuXHRcdHJlY2FzdE5hbWU6IFwiUmVmb3JtdWxhclwiLFxuXHRcdHJlY2FzdFNuaXA6IFwiTW9kaWZpY2EgbG9zIHBhcsOhbWV0cm9zIGRlIHVuYSBjYWRlbmEgZGUgZnVuY2lvbmVzIGRlIHVuIGRhdGFzZXQgZGUgbW9zYWljbyBvIHVuIHNlcnZpY2lvIGRlIGltw6FnZW5lcy4gU2UgdXRpbGl6YSBjb24gZnJlY3VlbmNpYSBjb24gbG9zIGRhdGFzZXRzIExBUyBwYXJhIGV2aXRhciB0ZW5lciBxdWUgY3JlYXIgdW4gZGF0YXNldCBkZSBtb3NhaWNvIHNlcGFyYWRvIHBhcmEgZGlzdGludGFzIHJlcHJlc2VudGFjaW9uZXMgZGVsIHRlcnJlbm8uXCIsXG5cdFx0cmVjYXN0RGVzYzogXCJMYSBmdW5jacOzbiBSZWZvcm11bGFyIHNlIHV0aWxpemEgcGFyYSBtb2RpZmljYXIgZGluw6FtaWNhbWVudGUgZWwgcGFyw6FtZXRybyBkZSBmdW5jacOzbiBlbXBsZWFkbyBlbiB1biBkYXRhc2V0IGRlIG1vc2FpY28gbyB1biBzZXJ2aWNpbyBkZSBpbcOhZ2VuZXMgc2luIG1hbnRlbmVyIGbDrXNpY2FtZW50ZSBsb3MgY2FtYmlvcy5cIixcblx0XHRyZWdpb25Hcm91cE5hbWU6IFwiR3J1cG8gZGUgcmVnaW9uZXNcIixcblx0XHRyZWdpb25Hcm91cFNuaXA6IFwiUGFyYSBjYWRhIGNlbGRhIGVuIGxhIHNhbGlkYSwgc2UgcmVnaXN0cmEgbGEgaWRlbnRpZGFkIGRlIGxhIHJlZ2nDs24gY29uZWN0YWRhIGEgbGEgcXVlIHBlcnRlbmVjZSBlc2EgY2VsZGEuIFNlIGFzaWduYSB1biBuw7ptZXJvIMO6bmljbyBhIGNhZGEgcmVnacOzbi5cIixcblx0XHRyZWdpb25Hcm91cERlc2M6IFwiTGEgZnVuY2nDs24gR3J1cG8gZGUgcmVnaW9uZXMgcmVnaXN0cmEsIHBhcmEgY2FkYSBjZWxkYSBkZSBsYSBzYWxpZGEsIGxhIGlkZW50aWRhZCBkZSBsYSByZWdpw7NuIGNvbmVjdGFkYSBhIGxhIHF1ZSBwZXJ0ZW5lY2UgbGEgY2VsZGEuIFNlIGFzaWduYSB1biBuw7ptZXJvIMO6bmljbyBhIGNhZGEgcmVnacOzbi48ZGl2Pjxici8+TGEgcHJpbWVyYSByZWdpw7NuIGVzY2FuZWFkYSByZWNpYmUgZWwgdmFsb3IgdW5vLCBsYSBzZWd1bmRhIGRvcywgeSBhc8OtIHN1Y2VzaXZhbWVudGUsIGhhc3RhIHF1ZSBzZSBhc2lnbmEgdW4gdmFsb3IgYSB0b2RhcyBsYXMgcmVnaW9uZXMuIEVsIGVzY2FuZW8gc2UgZGVzcGxhemEgZGUgaXpxdWllcmRhIGEgZGVyZWNoYSwgZGUgYXJyaWJhIGhhY2lhIGFiYWpvLiBMb3MgdmFsb3JlcyBxdWUgc2UgYXNpZ25lbiBhIGxhcyB6b25hcyBkZSBzYWxpZGEgZGVwZW5kZXLDoW4gZGVsIG1vbWVudG8gZW4gcXVlIHNlIGVuY3VlbnRyYW4gZW4gZWwgcHJvY2VzbyBkZSBlc2NhbmVvLjwvZGl2PlwiLFxuXHRcdHJlZ2lvbkdyb3dOYW1lOiBcIkNyZWNpbWllbnRvIGRlIHJlZ2nDs25cIixcblx0XHRyZWdpb25Hcm93U25pcDogXCJIYWNlIGNyZWNlciBsYXMgcmVnaW9uZXMgYSBwYXJ0aXIgZGUgcHVudG9zIHNlbWlsbGEuXCIsXG5cdFx0cmVnaW9uR3Jvd0Rlc2M6IFwiTGEgZnVuY2nDs24gQ3JlY2ltaWVudG8gZGUgcmVnacOzbiBhZ3J1cGEgcMOteGVsZXMgdmVjaW5vcyBlbiBncnVwb3MgZW4gZnVuY2nDs24gZGVsIHJhZGlvIGVzcGVjaWZpY2FkbyByZXNwZWN0byBkZXNkZSBlbCBwdW50byBkZSBzZW1pbGxhLiBTZSBhc2lnbmEgYWwgZ3J1cG8gZGUgcMOteGVsZXMgdSBvYmpldG9zIHVuIHZhbG9yIGRlIHJlbGxlbm8gZXNwZWNpZmljYWRvLlwiLFxuXHRcdHJlbWFwTmFtZTogXCJOdWV2YSByZXByZXNlbnRhY2nDs24gY2FydG9ncsOhZmljYVwiLFxuXHRcdHJlbWFwU25pcDogXCJDYW1iaWEgbG9zIHZhbG9yZXMgZGUgcMOteGVsIGFzaWduYW5kbyBudWV2b3MgdmFsb3JlcyBhIHJhbmdvcyBkZSB2YWxvcmVzIGRlIHDDrXhlbCBvIHVzYW5kbyB1bmEgdGFibGEgZXh0ZXJuYS5cIixcblx0XHRyZW1hcERlc2M6IFwiTGEgZnVuY2nDs24gZGUgbnVldmEgcmVwcmVzZW50YWNpw7NuIGNhcnRvZ3LDoWZpY2EgbGUgcGVybWl0ZSBjYW1iaWFyIG8gcmVjbGFzaWZpY2FyIGxvcyB2YWxvcmVzIGRlIHDDrXhlbCBkZSBsb3MgZGF0b3MgcsOhc3Rlci4gU2UgcHVlZGUgaGFjZXIgZXNwZWNpZmljYW5kbyB1biByYW5nbyBkZSB2YWxvcmVzIGRlIHDDrXhlbCBwYXJhIHJlcHJlc2VudGFyIGNhcnRvZ3LDoWZpY2FtZW50ZSB1biB2YWxvciBkZSBww614ZWwgZGUgc2FsaWRhLCBvIGJpZW4gdXNhbmRvIHVuYSB0YWJsYSBwYXJhIHJlcHJlc2VudGFyIGNhcnRvZ3LDoWZpY2FtZW50ZSBsb3MgdmFsb3JlcyBkZSBww614ZWxlcyBwYXJhIGdlbmVyYXIgZWwgdmFsb3IgZGUgcMOteGVsLlwiLFxuXHRcdHJlcHJvamVjdE5hbWU6IFwiVm9sdmVyIGEgcHJveWVjdGFyXCIsXG5cdFx0cmVwcm9qZWN0U25pcDogXCJNb2RpZmljYSBsYSBwcm95ZWNjacOzbiBkZSB1biBkYXRhc2V0IHLDoXN0ZXIsIGRhdGFzZXQgZGUgbW9zYWljbyBvIGVsZW1lbnRvIGRlIHLDoXN0ZXIgZW4gdW4gZGF0YXNldCBkZSBtb3NhaWNvLiBUYW1iacOpbiBwdWVkZW4gcmVtdWVzdHJlYXIgbG9zIGRhdG9zIHBhcmEgdW4gbnVldm8gdGFtYcOxbyBkZSBjZWxkYSB5IGRlZmluaXIgdW4gb3JpZ2VuLlwiLFxuXHRcdHJlcHJvamVjdERlc2M6IFwiTGEgZnVuY2nDs24gUmVwcm95ZWN0YXIgbW9kaWZpY2EgbGEgcHJveWVjY2nDs24gZGUgdW4gZGF0YXNldCByw6FzdGVyLCBkYXRhc2V0IGRlIG1vc2FpY28gbyBlbGVtZW50byBkZSByw6FzdGVyIGVuIHVuIGRhdGFzZXQgZGUgbW9zYWljby4gVGFtYmnDqW4gcHVlZGVuIHJlbXVlc3RyZWFyIGxvcyBkYXRvcyBwYXJhIHVuIG51ZXZvIHRhbWHDsW8gZGUgY2VsZGEgeSBkZWZpbmlyIHVuIG9yaWdlbi48ZGl2Pjxici8+TGEgZnVuY2nDs24gUmVwcm95ZWN0YXIgc2UgcHVlZGUgdXNhciBhbCBjcmVhciB1bmEgY2FjaMOpIGEgcGFydGlyIGRlIHVuIGRhdGFzZXQgcsOhc3RlciBvIGRlIG1vc2FpY28gcXVlIG5vIHNlIGVuY3VlbnRyYSBlbiBsYSBwcm95ZWNjacOzbiByZXF1ZXJpZGEuIFBvciBlamVtcGxvLCBhbCBjcmVhciB1biBzZXJ2aWNpbyBkZSBpbcOhZ2VuZXMgZW4gY2FjaMOpIHF1ZSBzZSBwdWVkZSBpbnRlZ3JhciBjb24gYXBsaWNhY2lvbmVzIGNvbiBvdHJvcyBzZXJ2aWNpb3MgZW4gY2FjaMOpLCBlcyBpbXBvcnRhbnRlIHF1ZSB0b2RvcyBzZSBlbmN1ZW50cmVuIGVuIGxhIG1pc21hIHByb3llY2Npw7NuLiBDb24gZnJlY3VlbmNpYSBzZSB0cmF0YSBkZSB1bmEgcHJveWVjY2nDs24gV2ViIE1lcmNhdG9yLiBEYWRvIHF1ZSBubyBlcyBwb3NpYmxlIHJlcHJveWVjdGFyIGVsIGRhdGFzZXQgZGUgbW9zYWljbywgZXMgcG9zaWJsZSBoYWNlciB1bmEgZGUgZG9zIGNvc2FzOiBjcmVhciB1biBkYXRhc2V0IGRlIG1vc2FpY28gYWwgcXVlIHNlIGhhY2UgcmVmZXJlbmNpYSBkZXNkZSBzdSBkYXRhc2V0IGRlIG1vc2FpY28gZW4gbGEgcHJveWVjY2nDs24gbmVjZXNhcmlhIG8gYWdyZWdhciBsYSBmdW5jacOzbiBSZXByb3llY3RhciBhIGxhIGNhZGVuYSBkZSBmdW5jaW9uZXMgZGVsIGRhdGFzZXQgZGUgbW9zYWljby4gT3RybyBlamVtcGxvIHVzYSBlc3RhIGZ1bmNpw7NuIGNvbiBlbCBlbGVtZW50byBkZSByw6FzdGVyIGRlIHVuIGRhdGFzZXQgZGUgbW9zYWljby4gQWwgdXRpbGl6YXIgbGEgZnVuY2nDs24gUsOhc3RlciBlbiBjYWNow6ksIHF1aXrDoSBkZXNlZSBpbnNlcnRhciBsYSBmdW5jacOzbiBSZXByb3llY3RhciBkZSBmb3JtYSBxdWUgbGEgY2FjaMOpIHNlIGNyZWUgZW4gbGEgbnVldmEgcHJveWVjY2nDs24uIExvcyBlbGVtZW50b3MgZGUgcsOhc3RlciBlbiB1biBkYXRhc2V0IGRlIG1vc2FpY28gc2UgcHVlZGVuIGFsbWFjZW5hciBlbiBjYWNow6kgY3VhbmRvIGVsIHByb2Nlc2FtaWVudG8gZXMgaW50ZW5zbyB5IGVzdMOhIHRyYXRhbmRvIHB1YmxpY2FyIHVuIHNlcnZpY2lvIGRlIGltw6FnZW5lcyByw6FwaWRvLCBzaW4gZWwgYWxtYWNlbmFyIGVuIGNhY2jDqSB0b2RvIGVsIHNlcnZpY2lvIGRlIGltw6FnZW5lcy48L2Rpdj5cIixcblx0XHRyZXNhbXBsZU5hbWU6IFwiUmVtdWVzdHJlYXJcIixcblx0XHRyZXNhbXBsZVNuaXA6IFwiQ2FtYmlhIGVsIHRhbWHDsW8gZGUgY2VsZGEgZGUgdW4gcsOhc3Rlci5cIixcblx0XHRyZXNhbXBsZURlc2M6IFwiTGEgZnVuY2nDs24gUmVtdWVzdHJlYXIgY2FtYmlhIGVsIHRhbWHDsW8gZGUgY2VsZGEsIGVsIHRpcG8gZGUgcmVtdWVzdHJlbyBvIGFtYm9zLjxkaXY+PGJyLz5MYSBmdW5jacOzbiBSZW11ZXN0cmVhciBzb2xvIHNlIGRlYmVyw61hIHV0aWxpemFyIGNvbiByZXF1aXNpdG9zIGRlIGPDoWxjdWxvIGVzcGVjw61maWNvcywgcG9yIGVqZW1wbG8sIGN1YW5kbyBjYWxjdWxhIGxhIG1hZ25pdHVkLWRpcmVjY2nDs24gZGVsIHZpZW50byBvIGxhIGNvcnJpZW50ZSBxdWUgcmVxdWllcmUgZWwgcmVtdWVzdHJlbyBkZSBsYSByZXNvbHVjacOzbiBkZSBvcmlnZW4uPC9kaXY+XCIsXG5cdFx0cm91bmREb3duTmFtZTogXCJSZWRvbmRlbyBoYWNpYSBhYmFqb1wiLFxuXHRcdHJvdW5kRG93blNuaXA6IFwiRGV2dWVsdmUgZWwgdmFsb3IgZW50ZXJvIGlubWVkaWF0YW1lbnRlIG3DoXMgYmFqbywgcmVwcmVzZW50YWRvIGNvbW8gdW4gcHVudG8gZmxvdGFudGUsIGNvbiBjYWRhIGNlbGRhIGRlIHVuIHLDoXN0ZXIuXCIsXG5cdFx0cm91bmREb3duRGVzYzogXCJMYSBmdW5jacOzbiBSZWRvbmRlbyBoYWNpYSBhYmFqbyBkZXZ1ZWx2ZSBlbCBuw7ptZXJvIGVudGVybyBpbm1lZGlhdGFtZW50ZSBpbmZlcmlvciwgY29tbyB1biB2YWxvciBkZSBwdW50byBmbG90YW50ZSwgcGFyYSBjYWRhIHDDrXhlbCBkZSB1biByw6FzdGVyLlwiLFxuXHRcdHJvdW5kVXBOYW1lOiBcIlJlZG9uZGVvIGhhY2lhIGFycmliYVwiLFxuXHRcdHJvdW5kVXBTbmlwOiBcIkRldnVlbHZlIGVsIHZhbG9yIGVudGVybyBpbm1lZGlhdGFtZW50ZSBtw6FzIGFsdG8sIHJlcHJlc2VudGFkbyBjb21vIHVuIHB1bnRvIGZsb3RhbnRlLCBjb24gY2FkYSBjZWxkYSBkZSB1biByw6FzdGVyLlwiLFxuXHRcdHJvdW5kVXBEZXNjOiBcIlJlZG9uZGVvIGhhY2lhIGFycmliYSBkZXZ1ZWx2ZSBlbCBuw7ptZXJvIGVudGVybyBpbm1lZGlhdGFtZW50ZSBzdXBlcmlvciwgY29tbyB1biB2YWxvciBkZSBwdW50byBmbG90YW50ZSwgcGFyYSBjYWRhIHDDrXhlbCBkZSB1biByw6FzdGVyLlwiLFxuXHRcdHNlZ21lbnRNZWFuU2hpZnROYW1lOiBcIlNlZ21lbnRhY2nDs24gKGRlc3BsYXphbWllbnRvIG1lZGlvKVwiLFxuXHRcdHNlZ21lbnRNZWFuU2hpZnRTbmlwOiBcIkFncnVwYSBsb3MgcMOteGVsZXMgYWR5YWNlbnRlcyBjb24gY2FyYWN0ZXLDrXN0aWNhcyBlc3BlY3RyYWxlcyBzaW1pbGFyZXMgZW4gc2VnbWVudG9zLlwiLFxuXHRcdHNlZ21lbnRNZWFuU2hpZnREZXNjOiBcIkVzdGEgZnVuY2nDs24gaWRlbnRpZmljYSBvYmpldG9zLCBlbnRpZGFkZXMgbyBzZWdtZW50b3MgZW4gc3VzIGltw6FnZW5lcyBhZ3J1cGFuZG8gbG9zIHDDrXhlbGVzIGFkeWFjZW50ZXMgcXVlIHRpZW5lbiBjYXJhY3RlcsOtc3RpY2FzIGVzcGVjdHJhbGVzIHkgZXNwYWNpYWxlcyBzaW1pbGFyZXMuIFB1ZWRlIGNvbnRyb2xhciBsYSBjYW50aWRhZCBkZSBzdWF2aXphZG8gZXNwYWNpYWwgeSBlc3BlY3RyYWwgcGFyYSBheXVkYXJsZSBhIG9idGVuZXIgZW50aWRhZGVzIGRlIGludGVyw6lzLlwiLFxuXHRcdHMxUmFkaW9tZXRyaWNDYWxpYnJhdGlvbk5hbWU6IFwiQ2FsaWJyYWNpw7NuIHJhZGlvbcOpdHJpY2EgZGUgU2VudGluZWwtMVwiLFxuXHRcdHMxUmFkaW9tZXRyaWNDYWxpYnJhdGlvblNuaXA6IFwiUmVhbGl6YSBkaWZlcmVudGVzIHRpcG9zIGRlIGNhbGlicmFjaW9uZXMgcmFkaW9tw6l0cmljYXMgZW4gZGF0b3MgZGUgU2VudGluZWwtMS5cIixcblx0XHRzMVJhZGlvbWV0cmljQ2FsaWJyYXRpb25EZXNjOiBcIkVzdGEgZnVuY2nDs24gcsOhc3RlciByZWFsaXphIHRyZXMgY2FsaWJyYWNpb25lcyBkaWZlcmVudGVzIHBhcmEgZGF0YXNldHMgZGUgU2VudGluZWwtMSwgaW5jbHVpZGFzIGJldGEgY2VybyB5IHNpZ21hIGNlcm8sIHkgZ2VuZXJhIGVsIGRhdGFzZXQgY2FsaWJyYWRvLiBFbCBvYmpldGl2byBkZSBsYSBjYWxpYnJhY2nDs24gZGUgU0FSIGNvbnNpc3RlIGVuIG9mcmVjZXIgaW3DoWdlbmVzIGVuIGxhcyBxdWUgbG9zIHZhbG9yZXMgZGUgcMOteGVsIHNlIHB1ZWRlbiByZWxhY2lvbmFyIGRpcmVjdGFtZW50ZSBjb24gbGEgcmV0cm9kaXNwZXJzacOzbiBkZWwgcmFkYXIgZGUgbGEgZXNjZW5hLiBBdW5xdWUgbGFzIGltw6FnZW5lcyBkZSBTQVIgc2luIGNhbGlicmFyIGJhc3RhbiBwYXJhIHVuIHVzbyBjdWFsaXRhdGl2bywgbGFzIGltw6FnZW5lcyBkZSBTQVIgY2FsaWJyYWRhcyBzb24gcHJpbW9yZGlhbGVzIHBhcmEgdW4gdXNvIGN1YW50aXRhdGl2byBkZSBsb3MgZGF0b3MgZGUgU0FSLjxkaXY+PGJyLz5FbCBwcm9jZXNhbWllbnRvIGhhYml0dWFsIGRlIGxvcyBkYXRvcyBkZSBTQVIsIHF1ZSBnZW5lcmEgaW3DoWdlbmVzIGRlIG5pdmVsIDEsIG5vIGluY2x1eWUgY29ycmVjY2lvbmVzIHJhZGlvbcOpdHJpY2FzIHkgcGVyc2lzdGUgdW5hIGltcG9ydGFudGUgZGVzdmlhY2nDs24gcmFkaW9tw6l0cmljYS4gUG9yIHRhbnRvLCBkZWJlIGFwbGljYXIgY29ycmVjY2lvbmVzIHJhZGlvbcOpdHJpY2FzIGEgbGFzIGltw6FnZW5lcyBkZSBTQVIgcGFyYSBxdWUgbG9zIHZhbG9yZXMgZGUgcMOteGVsIGRlIGxhcyBpbcOhZ2VuZXMgcmVwcmVzZW50ZW4gdmVyZGFkZXJhbWVudGUgbGEgcmV0cm9kaXNwZXJzacOzbiBkZWwgcmFkYXIgZGUgbGEgc3VwZXJmaWNpZSByZWZsZWN0YW50ZS4gTGEgY29ycmVjY2nDs24gcmFkaW9tw6l0cmljYSB0YW1iacOpbiBzZSBuZWNlc2l0YSBwYXJhIGNvbXBhcmFyIGxhcyBpbcOhZ2VuZXMgZGUgU0FSIGFkcXVpcmlkYXMgZGUgc2Vuc29yZXMgZGlzdGludG9zLCBvIGFkcXVpcmlkYXMgZGVsIG1pc21vIHNlbnNvciBhIGhvcmFzIGRpc3RpbnRhcywgZW4gbW9kb3MgZGlzdGludG9zIG8gcHJvY2VzYWRhcyBwb3IgcHJvY2VzYWRvcmVzIGRpc3RpbnRvcy48L2Rpdj5cIixcblx0XHRzMVRoZXJtYWxOb2lzZVJlbW92YWxOYW1lOiBcIkVsaW1pbmFjacOzbiBkZSBydWlkbyB0w6lybWljbyBkZSBTZW50aW5lbC0xXCIsXG5cdFx0czFUaGVybWFsTm9pc2VSZW1vdmFsU25pcDogXCJFbGltaW5hIGVsIHJ1aWRvIHTDqXJtaWNvIGRlIGxvcyBkYXRvcyBkZSBTZW50aW5lbC0xLlwiLFxuXHRcdHMxVGhlcm1hbE5vaXNlUmVtb3ZhbERlc2M6IFwiTGEgY29ycmVjY2nDs24gZGVsIHJ1aWRvIHTDqXJtaWNvIHNlIHB1ZWRlIGFwbGljYXIgYSBsb3MgcHJvZHVjdG9zIFNpbmdsZSBMb29rIENvbXBsZXggKFNMQykgZGUgbml2ZWwgMSB5IGEgbG9zIHByb2R1Y3RvcyBHcm91bmQgUmFuZ2UgRGV0ZWN0aW9uIChHUkQpIGRlIG5pdmVsIDEgZGUgU2VudGluZWwtMSBxdWUgbm8gaGF5YW4gc2lkbyBjb3JyZWdpZG9zLiBFbCBvcGVyYWRvciB0YW1iacOpbiBwdWVkZSBlbGltaW5hciBlc3RhIGNvcnJlY2Npw7NuIGVuIGZ1bmNpw7NuIGRlIGxhcyBhbm90YWNpb25lcyBkZWwgcHJvZHVjdG8gcGFyYSByZWludHJvZHVjaXIgbGEgc2XDsWFsIGRlIHJ1aWRvIGVsaW1pbmFkYSBwYXJhIGdlbmVyYXIgZWwgcHJvZHVjdG8gb3JpZ2luYWwuIExhcyBhbm90YWNpb25lcyBkZSBwcm9kdWN0byBzZSBhY3R1YWxpemFyw6FuIGVuIGNvbnNlY3VlbmNpYSBwYXJhIHBlcm1pdGlyIHF1ZSBzZSB2dWVsdmEgYSBhcGxpY2FyIGxhIGNvcnJlY2Npw7NuLiBcIixcblx0XHRzZXROdWxsTmFtZTogXCJFc3RhYmxlY2VyIG51bG9zXCIsXG5cdFx0c2V0TnVsbFNuaXA6IFwiRXN0YWJsZWNlciBudWxvcyBlc3RhYmxlY2UgbGFzIHViaWNhY2lvbmVzIGRlIGNlbGRhIGlkZW50aWZpY2FkYXMgZW4gTm9EYXRhIHNlZ8O6biBsb3MgY3JpdGVyaW9zIGVzcGVjaWZpY2Fkb3MuIERldnVlbHZlIE5vRGF0YSBzaSB1bmEgZXZhbHVhY2nDs24gY29uZGljaW9uYWwgZXMgdmVyZGFkZXJhIHkgZGV2dWVsdmUgdW4gdmFsb3IgZXNwZWNpZmljYWRvIHBvciBvdHJvIHLDoXN0ZXIgc2kgZXMgZmFsc2EuXCIsXG5cdFx0c2V0TnVsbERlc2M6IFwiTGEgZnVuY2nDs24gRXN0YWJsZWNlciBudWxvcyBkZWZpbmUgbG9zIHDDrXhlbGVzIGlkZW50aWZpY2Fkb3MgY29tbyBOb0RhdGEgc2Vnw7puIGNyaXRlcmlvcyBlc3BlY8OtZmljb3MuIERldnVlbHZlIE5vRGF0YSBzaSB1bmEgZXZhbHVhY2nDs24gY29uZGljaW9uYWwgZXMgdmVyZGFkZXJhICgxKSB5IGRldnVlbHZlIGVsIHZhbG9yIGVzcGVjaWZpY2FkbyBlbiBlbCBSw6FzdGVyIGZhbHNvIHNpIHVuYSBldmFsdWFjacOzbiBjb25kaWNpb25hbCBlcyBmYWxzYSAoMCkuIEVzdGUgY3JpdGVyaW8gdmllbmUgZGV0ZXJtaW5hZG8gcG9yIGxhIHNhbGlkYSBkZSB1bmEgZnVuY2nDs24gbWF0ZW3DoXRpY2EgbMOzZ2ljYSwgcXVlIHNlcsOhIGVsIFLDoXN0ZXIgZGUgZW50cmFkYS5cIixcblx0XHRzaGFkZWRSZWxpZWZOYW1lOiBcIlJlbGlldmUgY29uIHNvbWJyYVwiLFxuXHRcdHNoYWRlZFJlbGllZlNuaXA6IFwiQ3JlYSB1bmEgcmVwcmVzZW50YWNpw7NuIG11bHRpYmFuZGEsIGNvbiBjw7NkaWdvcyBkZSBjb2xvciB5IDNEIGRlIGxhIHN1cGVyZmljaWUsIHRlbmllbmRvIGVuIGN1ZW50YSBsYSBwb3NpY2nDs24gcmVsYXRpdmEgZGVsIHNvbCBwYXJhIHNvbWJyZWFyIGxhIGltYWdlbi5cIixcblx0XHRzaGFkZWRSZWxpZWZEZXNjOiBcIkxhIGZ1bmNpw7NuIFJlbGlldmUgc29tYnJlYWRvIGNyZWEgdW4gbW9kZWxvIGRlIHJlcHJlc2VudGFjacOzbiAzRCBkZWwgdGVycmVubyBlbiBjb2xvciBtZWRpYW50ZSBsYSBmdXNpw7NuIGRlIGltw6FnZW5lcyBhIHBhcnRpciBkZSBsb3MgbcOpdG9kb3MgZGUgY29kaWZpY2FjacOzbiBkZSBlbGV2YWNpw7NuIHkgZGUgc29tYnJlYWRvLiBFc3RhIGZ1bmNpw7NuIHV0aWxpemEgbGFzIHByb3BpZWRhZGVzIGRlIGFsdGl0dWQgeSBhY2ltdXQgcGFyYSBlc3BlY2lmaWNhciBsYSBwb3NpY2nDs24gZGVsIHNvbC48ZGl2Pjxici8+PC9kaXY+XCIsXG5cdFx0c2luSE5hbWU6IFwiU2VubyBoaXBlcmLDs2xpY28gKFNpbkgpXCIsXG5cdFx0c2luSFNuaXA6IFwiQ2FsY3VsYSBlbCBzZW5vIGhpcGVyYsOzbGljbyBkZSBsYXMgY2VsZGFzIGRlIHVuIHLDoXN0ZXIuXCIsXG5cdFx0c2luSERlc2M6IFwiTGEgZnVuY2nDs24gY2FsY3VsYSBlbCBzZW5vIGhpcGVyYsOzbGljbyBkZSBsb3MgcMOteGVsZXMgZGUgdW4gcsOhc3Rlci5cIixcblx0XHRzaW5OYW1lOiBcIlNlbm8gKFNpbilcIixcblx0XHRzaW5TbmlwOiBcIkNhbGN1bGEgZWwgc2VubyBkZSBsYXMgY2VsZGFzIGRlIHVuIHLDoXN0ZXIuXCIsXG5cdFx0c2luRGVzYzogXCJMYSBmdW5jacOzbiBjYWxjdWxhIGVsIHNlbm8gZGUgbG9zIHDDrXhlbGVzIGRlIHVuIHLDoXN0ZXIuXCIsXG5cdFx0c2xvcGVOYW1lOiBcIlBlbmRpZW50ZVwiLFxuXHRcdHNsb3BlU25pcDogXCJDYWxjdWxhIGxhIHRhc2EgZGUgY2FtYmlvIGRlc2RlIHVuIHZhbG9yIGRlIHDDrXhlbCBoYWNpYSBzdXMgdmVjaW5vcy5cIixcblx0XHRzbG9wZURlc2M6IFwiTGEgZnVuY2nDs24gcsOhc3RlciBjYWxjdWxhIGxhIHBlbmRpZW50ZSwgcXVlIGVzIGxhIHRhc2EgZGUgY2FtYmlvIGRlIGVsZXZhY2nDs24gcGFyYSBjYWRhIGNlbGRhIGRlIG1vZGVsbyBkaWdpdGFsIGRlIGVsZXZhY2nDs24gKERFTSkuIEVzIGxhIHByaW1lcmEgZGVyaXZhZGEgZGUgdW4gREVNLjxkaXY+PGJyLz5Fc3RhIGZ1bmNpw7NuIHV0aWxpemEgdW5hIGZ1bmNpw7NuIGF0YW4oKSBhY2VsZXJhZGEuIEVzIHNlaXMgdmVjZXMgbcOhcyByw6FwaWRvLCB5IGVsIGVycm9yIGRlIGFwcm94aW1hY2nDs24gc2llbXByZSBlcyBtZW5vciBkZSAwLjMgZ3JhZG9zLjwvZGl2PlwiLFxuXHRcdHNwZWNrbGVOYW1lOiBcIk1vdGVhZG9cIixcblx0XHRzcGVja2xlU25pcDogXCJQcm9wb3JjaW9uYSBmaWx0cm9zIHBhcmEgcXVpdGFyIHJ1aWRvIGEgZGF0YXNldHMgZGUgcmFkYXIgZGUgYXBlcnR1cmEgc2ludMOpdGljYS5cIixcblx0XHRzcGVja2xlRGVzYzogXCJFbCBtb3RlYWRvIGVzIGVsIHJ1aWRvIGRlIGFsdGEgZnJlY3VlbmNpYSBkZSBsb3MgZGF0b3MgZGUgcmFkYXIuIExhcyBpbcOhZ2VuZXMgZ2VuZXJhZGFzIHBvciBsb3Mgc2lzdGVtYXMgZGUgcmFkYXIgZGUgYXBlcnR1cmEgc2ludMOpdGljYSAoU0FSKSBzb24gbXV5IHByb2NsaXZlcyBhIGNvbnRlbmVyIHJ1aWRvIGRlIG1vdGVhZG8gZGViaWRvIGFsIHByb2Nlc2FtaWVudG8gZGUgc2XDsWFsZXMgZGlzcGVyc2FzIHkgbGEgaW50ZXJmZXJlbmNpYSBkZSBsYXMgb25kYXMgZWxlY3Ryb21hZ27DqXRpY2FzIGRpc3BlcnNhZGFzIHBvciBzdXBlcmZpY2llcyB1IG9iamV0b3MuIEVzdGEgZnVuY2nDs24gZGUgcnVpZG8gZmlsdHJhIGVsIGRhdGFzZXQgZGUgcmFkYXIgY29uIHJ1aWRvIHkgc3Vhdml6YSBlbCBydWlkbyBtaWVudGFzIHJldGllbmUgbG9zIGJvcmRlcyBvIGVudGlkYWRlcyBwcmVjaXNhcyBlbiBsYSBpbWFnZW4uXCIsXG5cdFx0c3BlY3RyYWxDb252ZXJzaW9uTmFtZTogXCJDb252ZXJzacOzbiBlc3BlY3RyYWxcIixcblx0XHRzcGVjdHJhbENvbnZlcnNpb25TbmlwOiBcIkFwbGljYSB1bmEgbWF0cml6IGEgdW5hIGltYWdlbiBtdWx0aWJhbmRhLlwiLFxuXHRcdHNwZWN0cmFsQ29udmVyc2lvbkRlc2M6IFwiTGEgZnVuY2nDs24gQ29udmVyc2nDs24gZXNwZWN0cmFsIGFwbGljYSB1bmEgbWF0cml6IGEgdW5hIGltYWdlbiBtdWx0aWJhbmRhIHBhcmEgaW5mbHVpciBlbiBsb3MgdmFsb3JlcyBkZSBjb2xvciBkZWwgcmVzdWx0YWRvLjxkaXY+PGJyLz5BbGd1bm9zIHNlbnNvcmVzIG5vIHJlY29nZW4gYmFuZGFzIGF6dWxlcyBkZWJpZG8gYSB1bmEgYmFqYSByZWxhY2nDs24gc2XDsWFsLXJ1aWRvLiBTZSBwdWVkZSB1dGlsaXphciwgcG9yIGVqZW1wbG8sIHBhcmEgY29udmVydGlyIHVuYSBpbWFnZW4gZGUgaW5mcmFycm9qb3MgZGUgY29sb3JlcyBmYWxzb3MgZW4gdW5hIGltYWdlbiBlbiBjb2xvciBwc2V1ZG9uYXR1cmFsLjwvZGl2PlwiLFxuXHRcdHNxdWFyZVJvb3ROYW1lOiBcIlJhw616IGN1YWRyYWRhXCIsXG5cdFx0c3F1YXJlUm9vdFNuaXA6IFwiQ2FsY3VsYSBsYSByYcOteiBjdWFkcmFkYSBkZSBsb3MgdmFsb3JlcyBkZSBjZWxkYSBkZSB1biByw6FzdGVyLlwiLFxuXHRcdHNxdWFyZVJvb3REZXNjOiBcIkxhIGZ1bmNpw7NuIFJhw616IGN1YWRyYWRhIGNhbGN1bGEgbGEgcmHDrXogY3VhZHJhZGEgZGUgbG9zIHZhbG9yZXMgZGUgcMOteGVsIGRlIHVuIHLDoXN0ZXIuXCIsXG5cdFx0c3F1YXJlTmFtZTogXCJDdWFkcmFkb1wiLFxuXHRcdHNxdWFyZVNuaXA6IFwiQ2FsY3VsYSBlbCBjdWFkcmFkbyBkZSBsb3MgdmFsb3JlcyBkZSBjZWxkYSBkZSB1biByw6FzdGVyLlwiLFxuXHRcdHNxdWFyZURlc2M6IFwiQ3VhZHJhZG8gY2FsY3VsYSBlbCBjdWFkcmFkbyBkZSBsb3MgdmFsb3JlcyBkZSBww614ZWwgZGUgdW4gcsOhc3Rlci5cIixcblx0XHRzdGF0aXN0aWNzSGlzdG9ncmFtTmFtZTogXCJFc3RhZMOtc3RpY2FzIGUgaGlzdG9ncmFtYVwiLFxuXHRcdHN0YXRpc3RpY3NIaXN0b2dyYW1TbmlwOiBcIkRlZmluaXIgbyBhc29jaWFyIGVzdGFkw61zdGljYXMgZSBoaXN0b2dyYW1hLlwiLFxuXHRcdHN0YXRpc3RpY3NIaXN0b2dyYW1EZXNjOiBcIkxhIGZ1bmNpw7NuIEVzdGFkw61zdGljYXMgZSBoaXN0b2dyYW1hIHNlIHV0aWxpemEgcGFyYSBkZWZpbmlyIGxhcyBlc3RhZMOtc3RpY2FzIHkgZWwgaGlzdG9ncmFtYSBkZSB1biByw6FzdGVyLiBQdWVkZSBpbnNlcnRhciBlc3RhIGZ1bmNpw7NuIGFsIGZpbmFsIGRlIGxhIGNhZGVuYSBkZSBmdW5jaW9uZXMgcGFyYSBkZXNjcmliaXIgbGFzIGVzdGFkw61zdGljYXMgeSBlbCBoaXN0b2dyYW1hIGRlIHVuYSBwbGFudGlsbGEgZGUgZnVuY2nDs24gcsOhc3RlciAoUkZUKS4gUHVlZGUgc2VyIG5lY2VzYXJpbyBoYWNlcmxvIHBhcmEgY29udHJvbGFyIGxhIHZpc3VhbGl6YWNpw7NuIHByZWRldGVybWluYWRhIGRlbCByZXN1bHRhZG8gZGUgcHJvY2VzYW1pZW50bywgZXNwZWNpYWxtZW50ZSBhbCBkZWZpbmlyIHVuYSBjYWRlbmEgZGUgZnVuY2lvbmVzIHF1ZSBjb250aWVuZSBtdWNoYXMgZnVuY2lvbmVzLjxkaXY+PGJyLz5QdWVkZSBkZWZpbmlyIGVzdGFkw61zdGljYXMgZXNjcmliaWVuZG8gbG9zIHZhbG9yZXMgbyBpbXBvcnRhciBkZXNkZSB1biBkYXRhc2V0IHLDoXN0ZXIgbyB1biBhcmNoaXZvIFhNTC4gTG9zIGhpc3RvZ3JhbWFzIHNvbG8gcHVlZGVuIGRlZmluaXJzZSBpbXBvcnRhbmRvIHVuIGFyY2hpdm8uPC9kaXY+XCIsXG5cdFx0c3RhdGlzdGljc05hbWU6IFwiRXN0YWTDrXN0aWNhc1wiLFxuXHRcdHN0YXRpc3RpY3NTbmlwOiBcIkNhbGN1bGEgbGFzIGVzdGFkw61zdGljYXMgZm9jYWxlcyBwYXJhIGNhZGEgcMOteGVsIGRlIHVuYSBpbWFnZW4gYmFzw6FuZG9zZSBlbiB1bmEgdmVjaW5kYWQgZm9jYWwgZGVmaW5pZGEuXCIsXG5cdFx0c3RhdGlzdGljc0Rlc2M6IFwiTGEgZnVuY2nDs24gRXN0YWTDrXN0aWNhcyBjYWxjdWxhIGxhcyBlc3RhZMOtc3RpY2FzIGZvY2FsZXMgcGFyYSBjYWRhIHDDrXhlbCBkZSB1bmEgaW1hZ2VuIGJhc8OhbmRvc2UgZW4gdW5hIHZlY2luZGFkIGZvY2FsIGRlZmluaWRhLjxkaXY+PGJyLz5MYSBmdW5jacOzbiBFc3RhZMOtc3RpY2FzIHNlIHB1ZWRlIHV0aWxpemFyIHBhcmEgcmVsbGVuYXIgbMOtbmVhcyBubyBjb250aW51YXMgZW4gdW5hIGltYWdlbi4gTGFzIGzDrW5lYXMgbm8gY29udGludWFzIGNvbiBmcmVjdWVuY2lhIGxhcyBvY2FzaW9uYW4gbG9zIHByb2JsZW1hcyBlbiBlbCBzZW5zb3IgZG9uZGUgbm8gc2UgcmVjb3BpbGFuIGxvcyBkYXRvcy4gRXN0byBoYSBvY3VycmlkbyBlbiBsb3Mgc2Vuc29yZXMgY29tbyBlbCBpbnN0cnVtZW50byBkZSBhc2lnbmFkb3IgdGVtw6F0aWNvIG1lam9yYWRvIFBsdXMgKEVUTSspIGRlIExhbmRzYXQgNy4gRXN0ZSBkYXRvcyBmYWx0YW50ZXMgb2Nhc2lvbmFuIHByb2JsZW1hcyBwYXJhIGVsIGFuw6FsaXNpcyB5IHRhbWJpw6luIGEgbGEgaG9yYSBkZSBleGFtaW5hciBsYXMgaW3DoWdlbmVzLiBObyBoYXkgbXVjaG8gcXVlIGhhY2VyIGFsIHV0aWxpemFyIGxhcyBpbcOhZ2VuZXMgcGFyYSBlbCBhbsOhbGlzaXM7IHNpbiBlbWJhcmdvLCBzaSBodWJvIGFsZ3VuYSBpbWFnZW4gc3VwZXJwdWVzdGEsIHNlIHBvZHLDrWEgdXRpbGl6YXIgZW4gbHVnYXIgZGVsIGNvbnRlbmlkbyBmYWx0YW50ZS4gTG8gbWlzbW8gc2UgcG9kcsOtYSBoYWNlciBzaSBsYXMgaW3DoWdlbmVzIHNlIHV0aWxpemFuIHBhcmEgdmlzdWFsaXphY2nDs24uIFNpbiBlbWJhcmdvLCBubyBzaWVtcHJlIGhheSB1bmEgaW1hZ2VuIGFkaWNpb25hbCBwYXJhIHJlbGxlbmFyIGVsIGNvbnRlbmlkbyBxdWUgZmFsdGEsIGFzw60gcXVlIHNlIGRlYmUgZGVyaXZhciBkZSBsb3MgZGF0b3MgZXhpc3RlbnRlcy48L2Rpdj5cIixcblx0XHRzdHJlYW1MaW5rTmFtZTogXCJWw61uY3VsbyBkZSBjdXJzbyBkZSBhZ3VhXCIsXG5cdFx0c3RyZWFtTGlua1NuaXA6IFwiQXNpZ25hIHZhbG9yZXMgw7puaWNvcyBhIHNlY2Npb25lcyBkZSB1bmEgcmVkIGxpbmVhbCBkZSByw6FzdGVyIGVudHJlIGludGVyc2VjY2lvbmVzLlwiLFxuXHRcdHN0cmVhbUxpbmtEZXNjOiBcIkxhIGZ1bmNpw7NuIGdsb2JhbCBWw61uY3VsbyBkZSBjdXJzbyBkZSBhZ3VhIGFzaWduYSB2YWxvcmVzIMO6bmljb3MgYSBzZWNjaW9uZXMgZGUgdW5hIHJlZCBkZSByw6FzdGVyIGxpbmVhbCBlbnRyZSBpbnRlcnNlY2Npb25lcy48ZGl2Pjxici8+TG9zIHbDrW5jdWxvcyBzb24gbGFzIHNlY2Npb25lcyBkZSB1biBjYW5hbCBkZSBjdXJzbyBkZSBhZ3VhIHF1ZSBjb25lY3RhIGRvcyBjcnVjZXMgc3VjZXNpdm9zLCB1biBjcnVjZSB5IGxhIHNhbGlkYSBvIHVuIGNydWNlIHkgbGEgZGl2aXNpw7NuIGRlIGRyZW5hamUuIEVuIGhpZHJvbG9nw61hLCBlc3RvcyBzZWdtZW50b3MgZGUgY3Vyc28gZGUgYWd1YSBzZSBsbGFtYW4gYWxjYW5jZXMuIFVuIGNydWNlIHNlIHJlbGFjaW9uYSBjb24gdW4gcHVudG8gZGUgZmx1aWRleiB5IGF5dWRhIGEgZGVsaW5lYXIgZWwgbMOtbWl0ZSBkZSBsYSBzdWJjdWVuY2EgZGUgbGEgY3VlbmNhIGhpZHJvZ3LDoWZpY2EgbyBkZWwgZHJlbmFqZS48L2Rpdj5cIixcblx0XHRzdHJldGNoTmFtZTogXCJFeHRlbnNpw7NuXCIsXG5cdFx0c3RyZXRjaFNuaXA6IFwiTWVqb3JhIHVuYSBpbWFnZW4gYWp1c3RhbmRvIGVsIHJhbmdvIGRlIHZhbG9yZXMgbW9zdHJhZG9zLiBDb24gZWxsbyBubyBzZSBhbHRlcmFuIGxvcyB2YWxvcmVzIGRlIHDDrXhlbCBzdWJ5YWNlbnRlcy4gU2kgdW4gcMOteGVsIHRpZW5lIHVuIHZhbG9yIGFqZW5vIGFsIHJhbmdvIGVzcGVjaWZpY2FkbywgYXBhcmVjZXLDoSBjb21vIGVsIHZhbG9yIG3DrW5pbW8gbyBlbCBtw6F4aW1vLlwiLFxuXHRcdHN0cmV0Y2hEZXNjOiBcIkxhIGZ1bmNpw7NuIEV4dGVuZGVyIG1lam9yYSBsYXMgaW3DoWdlbmVzLCBwYXJhIGVsbG8sIGNhbWJpYSBwcm9waWVkYWRlcyBjb21vIGVsIGJyaWxsbywgZWwgY29udHJhc3RlIHkgZ2FtbWEgYSB0cmF2w6lzIGRlIHZhcmlvcyB0aXBvcyBkZSBleHRlbnNpw7NuLiBFc3RhIGZ1bmNpw7NuIHVzYSBsYXMgZXN0YWTDrXN0aWNhcyBkZSBsb3MgcsOhc3RlcmVzIGRlbCBkYXRhc2V0IGRlIG1vc2FpY287IHBvciB0YW50bywgc2kgdXNhIGVzdGEgZnVuY2nDs24sIGRlYmUgYXNlZ3VyYXJzZSBkZSBxdWUgc2UgaGFuIGNhbGN1bGFkbyBsYXMgZXN0YWTDrXN0aWNhcy48ZGl2Pjxici8+RWwgdGlwbyBkZSBleHRlbnNpw7NuIGRlZmluZSB1bmEgZXh0ZW5zacOzbiBkZWwgaGlzdG9ncmFtYSBxdWUgc2UgdmEgYSBhcGxpY2FyIGEgbG9zIHLDoXN0ZXJlcyBwYXJhIG1lam9yYXIgc3UgYXBhcmllbmNpYS4gTGEgZXh0ZW5zacOzbiBtZWpvcmEgZWwgYXNwZWN0byBkZSBsb3MgZGF0b3MgeWEgcXVlIGV4cGFuZGUgbG9zIHZhbG9yZXMgZGUgcMOteGVsIGVuIHVuIGhpc3RvZ3JhbWEgYSBwYXJ0aXIgZGUgbG9zIHZhbG9yZXMgbcOheGltbyB5IG3DrW5pbW8gcXVlIHNlIGhhbiBkZWZpbmlkbyBzZWfDum4gc3UgcHJvZnVuZGlkYWQgZGUgYml0cy4gPC9kaXY+XCIsXG5cdFx0c3dhdGhOYW1lOiBcIkZyYW5qYVwiLFxuXHRcdHN3YXRoU25pcDogXCJJbnRlcnBvbGEgYSBwYXJ0aXIgZGUgY3VhZHLDrWN1bGFzIGlycmVndWxhcmVzIG8gZGF0b3MgZGUgZnJhbmphcy5cIixcblx0XHRzd2F0aERlc2M6IFwiQWxndW5vcyBkYXRhc2V0cyBkZSBuZXRDREYgbyBIREYgYWxtYWNlbmFuIHN1IGdlb2xvY2FsaXphY2nDs24gY29tbyBtYXRyaWNlcyBjb24gZXNwYWNpb3MgaXJyZWd1bGFyZXMuIEFsIGFncmVnYXIgZXN0b3MgZGF0YXNldHMgYSB1biBkYXRhc2V0IGRlIG1vc2FpY28sIGxhIGZ1bmNpw7NuIGRlIGZyYW5qYSB0b21hIGxvcyBkYXRvcyBjdWFkcmljdWxhZG9zIGlycmVndWxhcmVzIHkgbG9zIHJlbXVlc3RyZWEgcGFyYSBxdWUgY2FkYSBww614ZWwgdGVuZ2EgdW4gdGFtYcOxbyB1bmlmb3JtZSB5IHNlYSBjdWFkcmFkby48ZGl2Pjxici8+QWwgYWdyZWdhciB2YXJpYWJsZXMgZGUgbmV0Q0RGIG8gSERGIGEgdW4gZGF0YXNldCBkZSBtb3NhaWNvLCBjb21wcm9iYXLDoSBhdXRvbcOhdGljYW1lbnRlIHNpIGxvcyBkYXRvcyBlc3TDoW4gZGlzcHVlc3RvcyBlbiBsYSBtYXRyaXogZGUgZm9ybWEgcmVndWxhci4gU2kgbm8gZXMgYXPDrSwgc2UgYXBsaWNhIGF1dG9tw6F0aWNhbWVudGUgbGEgZnVuY2nDs24gZGUgZnJhbmphIHBhcmEgY29udmVydGlyIGxvcyByw6FzdGVyZXMgaXJyZWd1bGFyZXMgZW4gcHVudG9zIHksIGRlc3B1w6lzLCBlbiB1biByw6FzdGVyIGN1YWRyaWN1bGFkbyByZWd1bGFyLiBQdWVkZSBjYW1iaWFyIGVsIG3DqXRvZG8gZGUgaW50ZXJwb2xhY2nDs24geSBlbCB0YW1hw7FvIGRlIGNlbGRhIHV0aWxpemFkb3MgZW4gbGEgZnVuY2nDs24gcsOhc3RlciBkZSBmcmFuamEuIFBhcmEgbG9zIGRhdG9zIHLDoXN0ZXIgY29uIGVzcGFjaW9zIHJlZ3VsYXJlcywgbm8gc2UgYXBsaWNhcsOhIGxhIGludGVycG9sYWNpw7NuIHkgbG9zIGRhdG9zIHNlIGxlZXLDoW4gdGFsIGN1YWwuPC9kaXY+XCIsXG5cdFx0dGFuSE5hbWU6IFwiVGFuZ2VudGUgaGlwZXJiw7NsaWNhIChUYW5IKVwiLFxuXHRcdHRhbkhTbmlwOiBcIkNhbGN1bGEgbGEgdGFuZ2VudGUgaGlwZXJiw7NsaWNhIGRlIGNlbGRhcyBlbiB1biByw6FzdGVyLlwiLFxuXHRcdHRhbkhEZXNjOiBcIkxhIGZ1bmNpw7NuIGNhbGN1bGEgbGEgdGFuZ2VudGUgaGlwZXJiw7NsaWNhIGRlIGxvcyBww614ZWxlcyBkZSB1biByw6FzdGVyLlwiLFxuXHRcdHRhbk5hbWU6IFwiVGFuZ2VudGUgKFRhbilcIixcblx0XHR0YW5TbmlwOiBcIkNhbGN1bGEgbGEgdGFuZ2VudGUgZGUgY2VsZGFzIGVuIHVuIHLDoXN0ZXIuXCIsXG5cdFx0dGFuRGVzYzogXCJMYSBmdW5jacOzbiBjYWxjdWxhIGxhIHRhbmdlbnRlIGRlIGxvcyBww614ZWxlcyBkZSB1biByw6FzdGVyLiBcIixcblx0XHR0YXNzZWxlZENhcE5hbWU6IFwiVGFzc2VsZWQgQ2FwIChLYXV0aC1UaG9tYXMpXCIsXG5cdFx0dGFzc2VsZWRDYXBTbmlwOiBcIkNhbGN1bGEgbG9zIG5pdmVsZXMgZGUgdmVnZXRhY2nDs24sIGxhIGh1bWVkYWQgeSBsYSBsdW1pbm9zaWRhZC4gRXN0YSB0w6ljbmljYSBzZSBiYXNhIGVuIGNvZWZpY2llbnRlcyBxdWUgZGViZW4gY2FsY3VsYXJzZSBlc3BlY8OtZmljYW1lbnRlIHBhcmEgdW4gc2Vuc29yLlwiLFxuXHRcdHRhc3NlbGVkQ2FwRGVzYzogXCJMYSB0cmFuc2Zvcm1hY2nDs24gVGFzc2VsZWQgQ2FwIChLYXV0aC1UaG9tYXMpIGVzdMOhIGRpc2XDsWFkYSBwYXJhIGFuYWxpemFyIHkgcmVwcmVzZW50YXIgZmVub21lbm9sb2fDrWEgZGUgbGEgdmVnZXRhY2nDs24geSBjYW1iaW9zIGRlIGRlc2Fycm9sbG8gdXJiYW5vIGRldGVjdGFkb3MgcG9yIGRpdmVyc29zIHNpc3RlbWFzIGRlIHNlbnNvciBkZSBzYXTDqWxpdGUuIFNlIGNvbm9jZSBjb21vIGxhIHRyYW5zZm9ybWFjacOzbiBUYXNzZWxlZCBDYXAgZGViaWRvIGEgbGEgZm9ybWEgZGUgbGEgZGlzdHJpYnVjacOzbiBncsOhZmljYSBkZSBsb3MgZGF0b3MuIEVzdGEgdHJhbnNmb3JtYWNpw7NuIHByb3BvcmNpb27DsyB1bmEgbMOzZ2ljYSBwYXJhIGxvcyBwYXRyb25lcyBlbmNvbnRyYWRvcyBlbiBsb3MgZGF0b3MgTVNTIExhbmRzYXQgZGUgY2FtcG9zIGFncsOtY29sYXMgY29tbyB1bmEgZnVuY2nDs24gZGVsIGNpY2xvIGRlIHZpZGEgZGVsIGN1bHRpdm8uIEVzZW5jaWFsbWVudGUsIGEgbWVkaWRhIHF1ZSBsb3MgY3VsdGl2b3MgY3JlY2VuIGRlc2RlIGxhIHNlbWlsbGEgaGFzdGEgbGEgbWFkdXJleiwgaGF5IHVuIGF1bWVudG8gbmV0byBkZSBpbmZyYXJyb2pvIGNlcmNhbm8geSB1bmEgZGlzbWludWNpw7NuIGRlIHJlZmxlY3RhbmNpYSByb2phIGNvbiBiYXNlIGVuIGVsIGNvbG9yIGRlbCBzdWVsbzxkaXY+PGJyLz5MYSB1dGlsaWRhZCBkZSBlc3RhIHRyYW5zZm9ybWFjacOzbiBzZSBoYSBhbXBsaWFkbyBkZSBsb3MgY3VsdGl2b3MgZGUgc2VndWltaWVudG8gcGFyYSBhbCBhbsOhbGlzaXMgeSBsYSByZXByZXNlbnRhY2nDs24gY2FydG9ncsOhZmljYSBkZSBsYSB2ZWdldGFjacOzbiBwYXJhIGFwb3lhciB1bmEgdmFyaWVkYWQgZGUgYXBsaWNhY2lvbmVzLCBjb21vIGxhIHNpbHZpY3VsdHVyYSwgbGEgZ2VzdGnDs24gZGUgdmVnZXRhY2nDs24gaW5kdXN0cmlhbCwgbGEgcmVwcmVzZW50YWNpw7NuIGNhcnRvZ3LDoWZpY2EgeSBsYSBnZXN0acOzbiBkZSBlY29zaXN0ZW1hcywgZWwgaW52ZW50YXJpbyB5IGVsIGNvbnRyb2wgZGUgbGEgcmV0ZW5jacOzbiBkZWwgY2FyYm9ubyB5IGxvcyBjcsOpZGl0b3MsIGVsIGRlc2Fycm9sbG8gdXJiYW7DrXN0aWNvLCB5IG11Y2hhcyBtw6FzLiBUYW1iacOpbiBzZSBoYSBhbXBsaWFkbyBzdSBjb21wYXRpYmlsaWRhZCBpbmljaWFsIGNvbiBMYW5kc2F0IE1TUyBwYXJhIGluY2x1aXIgb3Ryb3Mgc2lzdGVtYXMgZGUgc2F0w6lsaXRlIHBvcHVsYXJlcywgY29tbyBMYW5kc2F0IFRNLCBMYW5kc2F0IEVUTSssIExhbmRzYXQgOCwgSUtPTk9TLCBRdWlja0JpcmQsIFdvcmxkVmlldy0yIHkgbG9zIHNlbnNvcmVzIG11bHRpZXNwZWN0cmFsZXMgUmFwaWRFeWUuPC9kaXY+XCIsXG5cdFx0dGltZXNOYW1lOiBcIlRpbWVzXCIsXG5cdFx0dGltZXNTbmlwOiBcIk11bHRpcGxpY2EgbG9zIHZhbG9yZXMgZGUgZG9zIHLDoXN0ZXJlcyBjZWxkYSBwb3IgY2VsZGEuXCIsXG5cdFx0dGltZXNEZXNjOiBcIkxhIGZ1bmNpw7NuIE11bHRpcGxpY2FjacOzbiBtdWx0aXBsaWNhIGxvcyB2YWxvcmVzIGRlIGRvcyByw6FzdGVyZXMgcMOteGVsIHBvciBww614ZWwuXCIsXG5cdFx0dHJhbnNwb3NlQml0c05hbWU6IFwiVHJhbnNwb25lciBiaXRzXCIsXG5cdFx0dHJhbnNwb3NlQml0c1NuaXA6IFwiRGVzZW1wYXF1ZXRhIGxvcyBiaXRzIGRlbCBww614ZWwgZGUgZW50cmFkYSB5IGxvcyBhc2lnbmEgYSBsb3MgYml0cyBlc3BlY2lmaWNhZG9zIGVuIGVsIHDDrXhlbCBkZSBzYWxpZGEuIEVsIG9iamV0aXZvIGRlIGVzdGEgZnVuY2nDs24gZXMgbWFuaXB1bGFyIGJpdHMgZGUgdW4gcGFyIGRlIGVudHJhZGFzLCBjb21vIGxvcyBwcm9kdWN0b3MgZGUgYmFuZGEgZGUgY2FsaWRhZCBkZSBMYW5kc2F0IDguXCIsXG5cdFx0dHJhbnNwb3NlQml0c0Rlc2M6IFwiTGEgZnVuY2nDs24gVHJhbnNwb25lciBiaXRzIGRlc2VtcGFxdWV0YSBsb3MgYml0cyBkZWwgcMOteGVsIGRlIGVudHJhZGEgeSBsb3MgYXNpZ25hIGEgbG9zIGJpdHMgZXNwZWNpZmljYWRvcyBlbiBlbCBww614ZWwgZGUgc2FsaWRhLiBFbCBvYmpldGl2byBkZSBlc3RhIGZ1bmNpw7NuIGVzIG1hbmlwdWxhciBiaXRzIGRlIHVuIHBhciBkZSBlbnRyYWRhcywgY29tbyBsb3MgcHJvZHVjdG9zIGRlIGJhbmRhIGRlIGNhbGlkYWQgZGUgTGFuZHNhdCA4LlwiLFxuXHRcdHVuaXRDb252ZXJzaW9uTmFtZTogXCJDb252ZXJzacOzbiBkZSB1bmlkYWRcIixcblx0XHR1bml0Q29udmVyc2lvblNuaXA6IFwiQ2FtYmlhIGxvcyB2YWxvcmVzIGRlIHVuYSB1bmlkYWQgZGUgbWVkaWRhIGEgb3RyYS5cIixcblx0XHR1bml0Q29udmVyc2lvbkRlc2M6IFwiRXN0YSBmdW5jacOzbiBjb252aWVydGUgcMOteGVsZXMgZGUgdW5hIHVuaWRhZCBhIG90cmEuIEFkbWl0ZSBsYSBjb252ZXJzacOzbiBkZSBkaXN0YW5jaWEsIHZlbG9jaWRhZCB5IHRlbXBlcmF0dXJhLlwiLFxuXHRcdHZlY3RvckZpZWxkTmFtZTogXCJDYW1wbyB2ZWN0b3JpYWxcIixcblx0XHR2ZWN0b3JGaWVsZFNuaXA6IFwiTXVlc3RyYSBkYXRhc2V0cyBjb24gbWFnbml0dWQgKHUpIHkgZGlyZWNjacOzbiAodikgY29tbyBmbGVjaGFzIGN1eW8gdGFtYcOxbyByZXByZXNlbnRhIGxhIG1hZ25pdHVkLCBtaWVudHJhcyBxdWUgZWwgw6FuZ3VsbyByZXByZXNlbnRhIGxhIGRpcmVjY2nDs24uXCIsXG5cdFx0dmVjdG9yRmllbGREZXNjOiBcIkxhIGZ1bmNpw7NuIENhbXBvIGRlIHZlY3RvciBzZSB1dGlsaXphIHBhcmEgY29tYmluYXIgeSBjb252ZXJ0aXIgZG9zIHLDoXN0ZXJlcyBlbiB1biByw6FzdGVyIGRlIGRvcyBiYW5kYXMgcXVlIHNlYSBkZWwgdGlwbyBkZSBkYXRvcyBNYWduaXR1ZC1EaXJlY2Npw7NuIG8gZGVsIHRpcG8gZGUgZGF0b3MgVS1WLjxkaXY+PGJyLz5FbCB2YWxvciBVIGVuIG9jYXNpb25lcyBzZSBjb25vY2UgY29tbyB2ZWxvY2lkYWQgem9uYWwsIHkgZWwgdmFsb3IgViwgY29tbyB2ZWxvY2lkYWQgbWVyaWRpb25hbC48L2Rpdj5cIixcblx0XHR2aWV3c2hlZDJOYW1lOiBcIkN1ZW5jYSB2aXN1YWxcIixcblx0XHR2aWV3c2hlZDJTbmlwOiBcIkRldGVybWluYSBsYXMgdWJpY2FjaW9uZXMgZGUgc3VwZXJmaWNpZSByw6FzdGVyIHZpc2libGVzIHBhcmEgdW4gY29uanVudG8gZGUgZW50aWRhZGVzIGRlIG9ic2VydmFkb3IgdXRpbGl6YW5kbyBtw6l0b2RvcyBnZW9kw6lzaWNvcy5cIixcblx0XHR2aWV3c2hlZDJEZXNjOiBcIkxhIGZ1bmNpw7NuIEN1ZW5jYSB2aXN1YWwgZGV0ZXJtaW5hIGxhcyB1YmljYWNpb25lcyBkZSBzdXBlcmZpY2llIHLDoXN0ZXIgdmlzaWJsZXMgcGFyYSB1biBjb25qdW50byBkZSBlbnRpZGFkZXMgZGUgb2JzZXJ2YWRvciB1dGlsaXphbmRvIG3DqXRvZG9zIGdlb2TDqXNpY29zPGRpdj48YnIvPlVuYSBwcnVlYmEgZGUgbMOtbmVhIGRlIHZpc2nDs24gZW50cmUgZWwgZGVzdGlubyB5IGNhZGEgb2JzZXJ2YWRvciBkZXRlcm1pbmEgbGEgdmlzaWJpbGlkYWQgZGUgY2FkYSBjZW50cm8gZGUgcMOteGVsLiBTaSB1biBvYnNlcnZhZG9yIHB1ZWRlIHZlciBlbCBkZXN0aW5vIGVuIGVsIGNlbnRybyBkZWwgcMOteGVsLCBzZSBjb25zaWRlcmEgcXVlIGVsIHDDrXhlbCBlcyB2aXNpYmxlLiBFc3RhIGhlcnJhbWllbnRhIHNpZW1wcmUgdGllbmUgZW4gY3VlbnRhIGxhIGN1cnZhdHVyYSBkZSBsYSB0aWVycmEgYSBsYSBob3JhIGRlIGRldGVybWluYXIgbGEgdmlzaWJpbGlkYWQuPC9kaXY+XCIsXG5cdFx0d2F0ZXJzaGVkTmFtZTogXCJDdWVuY2EgaGlkcm9ncsOhZmljYVwiLFxuXHRcdHdhdGVyc2hlZFNuaXA6IFwiRGV0ZXJtaW5hIGVsIMOhcmVhIGRlIGNvbnRyaWJ1Y2nDs24gcG9yIHNvYnJlIHVuIGNvbmp1bnRvIGRlIGNlbGRhcyBkZSB1biByw6FzdGVyLlwiLFxuXHRcdHdhdGVyc2hlZERlc2M6IFwiTGEgZnVuY2nDs24gZ2xvYmFsIEN1ZW5jYSBoaWRyb2dyw6FmaWNhIGRldGVybWluYSBlbCDDoXJlYSBkZSBjdWVuY2EgY29udHJpYnV5ZW50ZSBwb3IgZW5jaW1hIGRlIHVuIGNvbmp1bnRvIGRlIHDDrXhlbGVzIGRlIHVuIHLDoXN0ZXIuIExhcyBjdWVuY2FzIGhpZHJvZ3LDoWZpY2FzIHNlIGRlbGluZWFuIGEgcGFydGlyIGRlIHVuIHLDoXN0ZXIgZGUgZGlyZWNjacOzbiBkZSBmbHVqbyBxdWUgaWRlbnRpZmljYSBsYSBkaXJlY2Npw7NuIGRlIGZsdWpvIGRlIGNhZGEgcMOteGVsLlwiLFxuXHRcdHdlaWdodGVkT3ZlcmxheU5hbWU6IFwiU3VwZXJwb3NpY2nDs24gcG9uZGVyYWRhXCIsXG5cdFx0d2VpZ2h0ZWRPdmVybGF5U25pcDogXCJTdXBlcnBvbmUgdmFyaW9zIHLDoXN0ZXJzIGNvbiB1bmEgZXNjYWxhIGRlIG1lZGljacOzbiBjb23Dum4geSBwb25kZXJhIGNhZGEgdW5vIHNlZ8O6biBzdSBpbXBvcnRhbmNpYS5cIixcblx0XHR3ZWlnaHRlZE92ZXJsYXlEZXNjOiBcIkVzdGEgZnVuY2nDs24gcGVybWl0ZSBzdXBlcnBvbmVyIHZhcmlvcyByw6FzdGVyZXMgY29uIHVuYSBlc2NhbGEgZGUgbWVkaWNpw7NuIGNvbcO6biB5IHBvbmRlcmEgY2FkYSB1bm8gc2Vnw7puIHN1IGltcG9ydGFuY2lhLlwiLFxuXHRcdHdlaWdodGVkU3VtTmFtZTogXCJTdW1hIHBvbmRlcmFkYVwiLFxuXHRcdHdlaWdodGVkU3VtU25pcDogXCJQb25kZXJhIHkgYWdyZWdhIHVuIGNvbmp1bnRvIGRlIHLDoXN0ZXJlcyBjZWxkYSBwb3IgY2VsZGEuXCIsXG5cdFx0d2VpZ2h0ZWRTdW1EZXNjOiBcIkxhIGZ1bmNpw7NuIFN1bWEgcG9uZGVyYWRhIHBlcm1pdGUgc3VwZXJwb25lciB2YXJpb3MgcsOhc3RlcmVzIGFsIG11bHRpcGxpY2FyIGNhZGEgdW5vIHBvciBzdSBwZXNvIHkgc3VtYXIgbG9zIHJlc3VsdGFkb3MuXCIsXG5cdFx0d2luZGNoaWxsTmFtZTogXCJTZW5zYWNpw7NuIHTDqXJtaWNhXCIsXG5cdFx0d2luZGNoaWxsU25pcDogXCJDb21iaW5hIGxhIHRlbXBlcmF0dXJhIGFtYmllbnRlIGRlbCBhaXJlIHkgbGEgdmVsb2NpZGFkIGRlbCB2aWVudG8gcGFyYSBjYWxjdWxhciBlbCBmYWN0b3IgZGUgc2Vuc2FjacOzbiB0w6lybWljYS5cIixcblx0XHR3aW5kY2hpbGxEZXNjOiBcIkxhIGZ1bmNpw7NuIGRlIHNlbnNhY2nDs24gdMOpcm1pY2EgcmVzdWx0YSDDunRpbCBwYXJhIGlkZW50aWZpY2FyIGxhcyBjb25kaWNpb25lcyBpbnZlcm5hbGVzIHBlbGlncm9zYXMgcXVlLCBkZXBlbmRpZW5kbyBkZSBsb3MgdGllbXBvcyBkZSBleHBvc2ljacOzbiBhIGxvcyBlbGVtZW50b3MsIHB1ZWRlbiBjYXVzYXIgY29uZ2VsYWNpw7NuIG8gaW5jbHVzbyBoaXBvdGVybWlhLiBMYSBzZW5zYWNpw7NuIHTDqXJtaWNhIGVzIHVuYSBmb3JtYSBkZSBtZWRpciBjdcOhbnRvIGZyw61vIHNpZW50ZSB1bmEgcGVyc29uYSBjdWFuZG8gc2UgdGllbmUgZW4gY3VlbnRhIGVsIHZpZW50byBjb21iaW5hZG8gY29uIHVuYXMgdGVtcGVyYXR1cmFzIHlhIGRlIHBvciBzw60gZnLDrWFzLiBDdWFudG8gbcOhcyByw6FwaWRhIHNlYSBsYSB2ZWxvY2lkYWQgZGVsIHZpZW50bywgbcOhcyByw6FwaWRhIHNlcsOhIGxhIHDDqXJkaWRhIGRlIGNhbG9yIGRlbCBjdWVycG8geSBtw6FzIGZyw61vIHNlIHNlbnRpcsOhLlwiLFxuXHRcdHpvbmFsUmVtYXBOYW1lOiBcIk51ZXZhIHJlcHJlc2VudGFjacOzbiBjYXJ0b2dyw6FmaWNhIHpvbmFsXCIsXG5cdFx0em9uYWxSZW1hcFNuaXA6IFwiU2UgcmVhbGl6YSB1bmEgbnVldmEgcmVwcmVzZW50YWNpw7NuIGNhcnRvZ3LDoWZpY2EgZGUgbG9zIHDDrXhlbGVzIGRlIHVuIHLDoXN0ZXIgYmFzw6FuZG9zZSBlbiBsYXMgem9uYXMgZGVmaW5pZGFzIGVuIG90cm8gcsOhc3RlciB5IGVuIGxhIHJlcHJlc2VudGFjacOzbiBjYXJ0b2dyw6FmaWNhIGRlIGxvcyB2YWxvcmVzIHF1ZSBkZXBlbmRlbiBkZSBsYSB6b25hIHF1ZSBzZSBoYXlhIGRlZmluaWRvIGVuIHVuYSB0YWJsYS5cIixcblx0XHR6b25hbFJlbWFwRGVzYzogXCJFc3RhIGZ1bmNpw7NuIGxlIHBlcm1pdGUgcmVhbGl6YXIgdW5hIG51ZXZhIHJlcHJlc2VudGFjacOzbiBjYXJ0b2dyw6FmaWNhIGRlIGxvcyBww614ZWxlcyBkZSB1biByw6FzdGVyIGJhc8OhbmRvc2UgZW4gbGFzIHpvbmFzIGRlZmluaWRhcyBlbiBvdHJvIHLDoXN0ZXIgeSBlbiBsYSByZXByZXNlbnRhY2nDs24gY2FydG9ncsOhZmljYSBkZSBsb3MgdmFsb3JlcyBxdWUgZGVwZW5kZW4gZGUgbGEgem9uYSBxdWUgc2UgaGF5YSBkZWZpbmlkbyBlbiB1bmEgdGFibGEuXCIsXG5cdFx0em9uYWxTdGF0aXN0aWNzTmFtZTogXCJFc3RhZMOtc3RpY2FzIHpvbmFsZXNcIixcblx0XHR6b25hbFN0YXRpc3RpY3NTbmlwOiBcIkNhbGN1bGEgZXN0YWTDrXN0aWNhcyBzb2JyZSB2YWxvcmVzIGRlIHVuIHLDoXN0ZXIgZGVudHJvIGRlIHpvbmFzIGRlIG90cm8gZGF0YXNldC5cIixcblx0XHR6b25hbFN0YXRpc3RpY3NEZXNjOiBcIkxhIGZ1bmNpw7NuIGNhbGN1bGEgZXN0YWTDrXN0aWNhcyBzb2JyZSB2YWxvcmVzIGRlIHVuIHLDoXN0ZXIgZGVudHJvIGRlIHpvbmFzIGRlIG90cm8gZGF0YXNldC4gVW5hIHpvbmEgc2UgZGVmaW5lIGNvbW8gdG9kYXMgbGFzIMOhcmVhcyBkZSBsYSBlbnRyYWRhIHF1ZSB0aWVuZW4gZWwgbWlzbW8gdmFsb3IuIE5vIGVzIG5lY2VzYXJpbyBxdWUgZXN0YXMgw6FyZWFzIHNlYW4gY29udGlndWFzLiBDdWFuZG8gdGFudG8gbGFzIGVudHJhZGFzIGRlIHpvbmEgY29tbyBsYXMgZGUgdmFsb3Igc29uIHLDoXN0ZXJlcyBkZSBsYSBtaXNtYSByZXNvbHVjacOzbiwgc2UgdXRpbGl6YXLDoW4gZGlyZWN0YW1lbnRlLiBTaSBsYXMgcmVzb2x1Y2lvbmVzIHNvbiBkaWZlcmVudGVzLCBzZSBhcGxpY2EgdW4gcmVtdWVzdHJlbyBpbnRlcm5vIHBhcmEgaGFjZXJsYXMgY29pbmNpZGlyIGFudGVzIGRlIHJlYWxpemFyIGxhIG9wZXJhY2nDs24gem9uYWwuXCIsXG5cdFx0Zmxvd0xlbmd0aE5hbWU6IFwiTG9uZ2l0dWQgZGUgZmx1am9cIixcblx0XHRmbG93TGVuZ3RoU25pcDogXCJDYWxjdWxhIGxhIGRpc3RhbmNpYSBhZ3VhcyBhcnJpYmEgbyBhZ3VhcyBhYmFqbyBvIGxhIGRpc3RhbmNpYSBwb25kZXJhZGEgYSBsbyBsYXJnbyBkZSBsYSBydXRhIGRlIGZsdWpvIHBhcmEgY2FkYSBjZWxkYS5cIixcblx0XHRmbG93TGVuZ3RoRGVzYzogXCJFc3RhIGVzIHVuYSBmdW5jacOzbiByw6FzdGVyIGdsb2JhbC4gRXN0YSBmdW5jacOzbiBjcmVhIHVuYSBjYXBhIHLDoXN0ZXIgZGUgZGlzdGFuY2lhIGFndWFzIGFycmliYSBvIGFndWFzIGFiYWpvLCBvIGRpc3RhbmNpYSBwb25kZXJhZGEsIGEgbG8gbGFyZ28gZGUgbGEgcnV0YSBkZSBmbHVqbyBkZSBjYWRhIGNlbGRhLjxkaXY+PGJyLz5VbiB1c28gcHJpbmNpcGFsIGRlIGxhIGZ1bmNpw7NuIExvbmdpdHVkIGRlIGZsdWpvIGVzIGNhbGN1bGFyIGxhIGxvbmdpdHVkIGRlIGxhIHJ1dGEgZGUgZmx1am8gbcOhcyBsYXJnYSBkZW50cm8gZGUgdW5hIGN1ZW5jYSBkZXRlcm1pbmFkYS4gRXN0YSBtZWRpZGEgc2UgdXRpbGl6YSBnZW5lcmFsbWVudGUgcGFyYSBjYWxjdWxhciBlbCB0aWVtcG8gZGUgY29uY2VudHJhY2nDs24gZGUgdW5hIGN1ZW5jYS4gU2UgcmVhbGl6YSBjb24gbGEgb3BjacOzbiBBZ3VhcyBhcnJpYmEuIExhIGZ1bmNpw7NuIHRhbWJpw6luIHNlIHB1ZWRlIHV0aWxpemFyIHBhcmEgY3JlYXIgZGlhZ3JhbWFzIGRlIGRpc3RhbmNpYS3DoXJlYSBkZSBldmVudG9zIGhpcG90w6l0aWNvcyBkZSBwcmVjaXBpdGFjacOzbiB5IGVzY29ycmVudMOtYSBtZWRpYW50ZSBlbCByw6FzdGVyIGRlIHBlc28sIGNvbW8gdW5hIGltcGVkYW5jaWEgYWwgbW92aW1pZW50byBkZXNjZW5kZW50ZS48L2Rpdj5cIixcblx0XHRzdHJlYW1PcmRlck5hbWU6IFwiQ2xhc2lmaWNhY2nDs24gZGUgYXJyb3lvc1wiLFxuXHRcdHN0cmVhbU9yZGVyU25pcDogXCJBc2lnbmEgdW4gb3JkZW4gbnVtw6lyaWNvIGEgc2VnbWVudG9zIGRlIHVuIHLDoXN0ZXIgcXVlIHJlcHJlc2VudGEgbGFzIHJhbWFzIGRlIHVuYSByZWQgbGluZWFsXCIsXG5cdFx0c3RyZWFtT3JkZXJEZXNjOiBcIkVzdGEgZXMgdW5hIGZ1bmNpw7NuIHLDoXN0ZXIgZ2xvYmFsLiBFc3RhIGZ1bmNpw7NuIGNyZWEgdW5hIGNhcGEgcsOhc3RlciBxdWUgYXNpZ25hIHVuIG9yZGVuIG51bcOpcmljbyBhIGxvcyBzZWdtZW50b3MgZGUgdW4gcsOhc3RlciBxdWUgcmVwcmVzZW50YW4gbGFzIHJhbWFzIGRlIHVuYSByZWQgbGluZWFsLjxkaXY+PGJyLz5MYSBzYWxpZGEgZGUgbGEgZnVuY2nDs24gQ2xhc2lmaWNhY2nDs24gZGUgY3Vyc29zIGRlIGFndWEgc2Vyw6EgZGUgbWF5b3IgY2FsaWRhZCBzaSBsYSBjYXBhIHLDoXN0ZXIgZGUgY3Vyc28gZGUgYWd1YSBkZSBlbnRyYWRhIHkgZWwgcsOhc3RlciBkZSBkaXJlY2Npw7NuIGRlbCBmbHVqbyBkZSBlbnRyYWRhIHNlIGRlcml2YW4gZGUgbGEgbWlzbWEgc3VwZXJmaWNpZS4gU2kgZWwgcsOhc3RlciBkZSBjdXJzbyBkZSBhZ3VhIHNlIGRlcml2YSBkZSB1biBkYXRhc2V0IGRlIGN1cnNvIGRlIGFndWEgcmFzdGVyaXphZG8sIGxhIHNhbGlkYSBwdWVkZSBubyBzZXIgw7p0aWwgcG9ycXVlLCBhIHRyYXbDqXMgZGUgY2FkYSBjZWxkYSBpbmRpdmlkdWFsLCBsYSBkaXJlY2Npw7NuIG5vIGNvcnJlc3BvbmRlcsOhIGNvbiBsYSB1YmljYWNpw7NuIGRlIGxhcyBjZWxkYXMgZGUgY3Vyc28gZGUgYWd1YS4gRWwgcmVzdWx0YWRvIGRlIGxhIGZ1bmNpw7NuIEFjdW11bGFjacOzbiBkZSBmbHVqbyBzZSBwdWVkZSB1c2FyIHBhcmEgY3JlYXIgdW5hIHJlZCBkZSBjdXJzb3MgZGUgYWd1YSBlbiByw6FzdGVyIGFwbGljYW5kbyB1biB2YWxvciBkZSB1bWJyYWwgcGFyYSBzZWxlY2Npb25hciBsYXMgY2VsZGFzIHF1ZSBwcmVzZW50YW4gdW4gZmx1am8gYWN1bXVsYWRvIGVsZXZhZG8uIFBvciBlamVtcGxvLCBsYXMgY2VsZGFzIHF1ZSB0aWVuZW4gbcOhcyBkZSAxMDAgY2VsZGFzIHF1ZSBmbHV5ZW4gaGFjaWEgZWxsYXMgc2UgdXRpbGl6YW4gcGFyYSBkZWZpbmlyIGxhIHJlZCBkZSBjb3JyaWVudGVzLiBVc2UgbGEgZnVuY2nDs24gQ29uIG8gRXN0YWJsZWNlciBudWxvcyBwYXJhIGNyZWFyIHVuIHLDoXN0ZXIgZGUgcmVkIGRlIGN1cnNvcyBkZSBhZ3VhIGVuIGVsIHF1ZSBsb3MgdmFsb3JlcyBkZSBhY3VtdWxhY2nDs24gZGUgZmx1am8gZGUgMTAwIG8gbcOhcyBzZSBjb252aWVydGVuIGVuIHVubyB5IGVsIHJlc3RvIHNlIGRlamFuIGVuIHNlZ3VuZG8gcGxhbm8gKE5vRGF0YSkuIExhIHJlZCBkZSBjdXJzb3MgZGUgYWd1YSByZXN1bHRhbnRlIHB1ZWRlIHVzYXJzZSBlbiBsYSBmdW5jacOzbiBDbGFzaWZpY2FjacOzbiBkZSBjdXJzb3MgZGUgYWd1YS4gRXN0YSBmdW5jacOzbiBzb2xvIGFkbWl0ZSB1bmEgY2FwYSByw6FzdGVyIGRlIGRpcmVjY2nDs24gZGVsIGZsdWpvIGRlIGVudHJhZGEgRDguIFB1ZWRlIGNyZWFyIGRpcmVjY2lvbmVzIGRlIGZsdWpvIEQ4IGNvbiBsYSBmdW5jacOzbiBEaXJlY2Npw7NuIGRlIGZsdWpvIHkgZWplY3V0YXJsYSBjb24gZWwgdGlwbyBkZSBkaXJlY2Npw7NuIGRlIGZsdWpvIHByZWRldGVybWluYWRvLCBEOC48L2Rpdj5cIixcblx0XHRzbmFwUG91clBvaW50TmFtZTogXCJBanVzdGUgZGUgY29ycmllbnRlc1wiLFxuXHRcdHNuYXBQb3VyUG9pbnRTbmlwOiBcIkFqdXN0YSBsYXMgY29ycmllbnRlcyBhIGxhcyBjZWxkYXMgZGUgbGEgYWN1bXVsYWNpw7NuIGRlIGZsdWpvIG3DoXMgYWx0YSBkZW50cm8gZGUgdW5hIGRpc3RhbmNpYSBlc3BlY8OtZmljYVwiLFxuXHRcdHNuYXBQb3VyUG9pbnREZXNjOiBcIkVzdGEgZXMgdW5hIGZ1bmNpw7NuIHLDoXN0ZXIgZ2xvYmFsLiBFc3RhIGZ1bmNpw7NuIGFqdXN0YSBsYXMgY29ycmllbnRlcyBhIGxhcyBjZWxkYXMgZGUgbGEgYWN1bXVsYWNpw7NuIGRlIGZsdWpvIG3DoXMgYWx0YSBkZW50cm8gZGUgdW5hIGRpc3RhbmNpYSBlc3BlY8OtZmljYS48ZGl2Pjxici8+TGEgZnVuY2nDs24gQWxpbmVhciBwdW50byBkZSBmbHVpZGV6IHNlIHV0aWxpemEgcGFyYSBhc2VndXJhciBsYSBzZWxlY2Npw7NuIGRlIHB1bnRvcyBkZSBmbHVqbyBhY3VtdWxhZG8gYWx0byBjdWFuZG8gc2UgZGVsaW5lYW4gY3VlbmNhcyBkZSBkcmVuYWplIGFsIHV0aWxpemFyIGxhIGZ1bmNpw7NuIEN1ZW5jYSBoaWRyb2dyw6FmaWNhLiBBbGluZWFyIHB1bnRvIGRlIGZsdWlkZXogYnVzY2Fyw6EsIGRlbnRybyBkZSB1bmEgZGlzdGFuY2lhIGRlIGFsaW5lYWNpw7NuIGFscmVkZWRvciBkZSBsb3MgcHVudG9zIGRlIGZsdWlkZXogZXNwZWNpZmljYWRvcywgbGEgY2VsZGEgZGUgbWF5b3IgZmx1am8gYWN1bXVsYWRvIHkgbW92ZXLDoSBlbCBwdW50byBkZSBmbHVpZGV6IGEgZXNhIHViaWNhY2nDs24uIExhIHNhbGlkYSBlcyB1bmEgY2FwYSByw6FzdGVyIGRlIHRpcG8gZW50ZXJvIGN1YW5kbyBsYXMgdWJpY2FjaW9uZXMgb3JpZ2luYWxlcyBkZWwgcHVudG8gZGUgZmx1aWRleiBzZSBoYW4gYWxpbmVhZG8gYSB1YmljYWNpb25lcyBkZSBtYXlvciBmbHVqbyBhY3VtdWxhZG8uPC9kaXY+XCIsXG5cdFx0c2lua05hbWU6IFwiU3VtaWRlcm9cIixcblx0XHRzaW5rU25pcDogXCJDcmVhIHVuYSBjYXBhIHLDoXN0ZXIgcXVlIGlkZW50aWZpY2EgdG9kb3MgbG9zIHN1bWlkZXJvcyBvIMOhcmVhcyBkZSBkcmVuYWplIGludGVybm9cIixcblx0XHRzaW5rRGVzYzogXCJFc3RhIGVzIHVuYSBmdW5jacOzbiByw6FzdGVyIGdsb2JhbC4gRXN0YSBmdW5jacOzbiBjcmVhIHVuYSBjYXBhIHLDoXN0ZXIgcXVlIGlkZW50aWZpY2EgdG9kb3MgbG9zIHN1bWlkZXJvcyBvIMOhcmVhcyBkZSBkcmVuYWplIGludGVybm8uIFVuIHN1bWlkZXJvIGVzIHVuYSBjZWxkYSBvIHVuIGNvbmp1bnRvIGRlIGNlbGRhcyBjb25lY3RhZGFzIGVzcGFjaWFsbWVudGUsIGNvbiB1bmEgZGlyZWNjacOzbiBkZSBmbHVqbyBhIGxhIHF1ZSBubyBzZSBsZSBwdWVkZSBhc2lnbmFyIHVubyBkZSBsb3Mgb2NobyB2YWxvcmVzIHbDoWxpZG9zIGVuIHVuIHLDoXN0ZXIgZGUgZGlyZWNjacOzbiBkZSBmbHVqby4gRXN0byBwdWVkZSBvY3VycmlyIGN1YW5kbyB0b2RhcyBsYXMgY2VsZGFzIHZlY2luYXMgc29uIG1heW9yZXMgcXVlIGxhIGNlbGRhIGRlIHByb2Nlc2FtaWVudG8gbyBjdWFuZG8gZG9zIGNlbGRhcyBmbHV5ZW4gZW50cmUgc8OtLCBjcmVhbmRvIHVuIGJ1Y2xlIGRlIGRvcyBjZWxkYXMuPGRpdj48YnIvPkxhIGZ1bmNpw7NuIFN1bWlkZXJvIHNvbG8gYWRtaXRlIHVuYSBjYXBhIHLDoXN0ZXIgZGUgZGlyZWNjacOzbiBkZWwgZmx1am8gZGUgZW50cmFkYSBEOC4gUHVlZGUgY3JlYXIgZGlyZWNjaW9uZXMgZGUgZmx1am8gRDggY29uIGxhIGZ1bmNpw7NuIERpcmVjY2nDs24gZGUgZmx1am8geSBlamVjdXRhcmxhIGNvbiBlbCB0aXBvIGRlIGRpcmVjY2nDs24gZGUgZmx1am8gcHJlZGV0ZXJtaW5hZG8sIEQ4LiBMYSBzYWxpZGEgZGUgbGEgZnVuY2nDs24gU3VtaWRlcm8gZXMgdW4gcsOhc3RlciBlbnRlcm8gZW4gZWwgcXVlIGNhZGEgc3VtaWRlcm8gdGllbmUgYXNpZ25hZG8gdW4gdmFsb3Igw7puaWNvLiBFc3RvcyB2YWxvcmVzIMO6bmljb3MgcHJlc2VudGFuIHVuIHJhbmdvIGVudHJlIHVubyB5IGVsIG7Dum1lcm8gdG90YWwgZGUgc3VtaWRlcm9zLiBQb3IgZWplbXBsbywgc2kgZWwgbsO6bWVybyB0b3RhbCBkZSBzdW1pZGVyb3MgZnVlcmEgMS4wMDAsIGVsIHJhbmdvIGRlIHZhbG9yZXMgw7puaWNvcyBzZXLDrWEgZGUgMSBhIDEuMDAwLjwvZGl2PlwiLFxuXHRcdGFnZ3JlZ2F0ZU5hbWU6IFwiQWdyZWdhclwiLFxuXHRcdGFnZ3JlZ2F0ZVNuaXA6IFwiR2VuZXJhIHVuYSB2ZXJzacOzbiBkZSByZXNvbHVjacOzbiByZWR1Y2lkYSBkZSB1biByw6FzdGVyLlwiLFxuXHRcdGFnZ3JlZ2F0ZURlc2M6IFwiTGEgZnVuY2nDs24gQWdyZWdhciByZW11ZXN0cmVhIHVuIHLDoXN0ZXIgZGUgZW50cmFkYSBhIHVuYSByZXNvbHVjacOzbiBtw6FzIGdydWVzYSBiYXPDoW5kb3NlIGVuIHVuYSBlc3RyYXRlZ2lhIGRlIGFncmVnYWNpw7NuIGVzcGVjaWZpY2FkYS4gQ2FkYSBjZWxkYSBkZSBzYWxpZGEgY29udGllbmUgbGEgU3VtYSwgZWwgTcOtbmltbywgZWwgTcOheGltbywgZWwgVmFsb3IgbWVkaW8gbyBsYSBNZWRpYW5hIGRlIGxhcyBjZWxkYXMgZGUgZW50cmFkYSBhYmFyY2FkYXMgcG9yIGxhIGV4dGVuc2nDs24gZGUgZXNhIGNlbGRhLjxkaXY+PGJyLz5QdWVkZSBlc3BlY2lmaWNhciBlbCBmYWN0b3IgcG9yIGVsIHF1ZSBzZSBtdWx0aXBsaWNhIGVsIHRhbWHDsW8gZGUgY2VsZGEgZGVsIHLDoXN0ZXIgZGUgZW50cmFkYS4gUG9yIGVqZW1wbG8sIHVuIHZhbG9yIGRlIGZhY3RvciBkZSBjZWxkYSBkZSAzIHJlc3VsdGFyw61hIGVuIHVuYSBzYWxpZGEgZG9uZGUgZWwgdGFtYcOxbyBkZSBjZWxkYSBlcyB0cmVzIHZlY2VzIG1heW9yIHF1ZSBlbCBkZWwgcsOhc3RlciBkZSBlbnRyYWRhLiBQdWVkZSBkZWZpbmlyIGPDs21vIHRyYXRhciBsYSBleHRlbnNpw7NuIGRlIGxhIHNhbGlkYSBzaSBlbCBuw7ptZXJvIGRlIGZpbGFzIG8gY29sdW1uYXMgZGUgbGEgZW50cmFkYSBubyBlcyB1biBtw7psdGlwbG8gZXhhY3RvIGRlbCBmYWN0b3IgZGUgY2VsZGEuIFBvciBkZWZlY3RvLCBsb3MgbMOtbWl0ZXMgc3VwZXJpb3IgeSBkZXJlY2hvIHNlIGV4cGFuZGlyw6FuIHBhcmEgY3VicmlyIHVuYSBleHRlbnNpw7NuIGVzcGFjaWFsIG1heW9yIHF1ZSBsYSBkZWwgcsOhc3RlciBkZSBlbnRyYWRhLCBhIGZpbiBkZSBnYXJhbnRpemFyIHF1ZSB0b2RhcyBsYXMgY2VsZGFzIGRlIGVudHJhZGEgc2UgcHJvY2VzZW4uIENvbW8gYWx0ZXJuYXRpdmEsIGxvcyBsw61taXRlcyBzdXBlcmlvciB5IGRlcmVjaG8gc2UgcHVlZGVuIHJlZHVjaXIgcGFyYSBjdWJyaXIgdW5hIGV4dGVuc2nDs24gbWVub3IsIGRlIGZvcm1hIHF1ZSBlbCBuw7ptZXJvIGRlIGZpbGFzIHkgY29sdW1uYXMgcHJvY2VzYWRvIHNlYSB1biBtw7psdGlwbG8gZXhhY3RvIGRlbCBmYWN0b3IgZGUgY2VsZGEuIFB1ZWRlIGRlZmluaXIgY8OzbW8gdmEgYSB0cmF0YXIgZWwgY8OhbGN1bG8gZGUgYWdyZWdhY2nDs24gZGUgbGFzIGNlbGRhcyBOb0RhdGEuIEVsIG1lY2FuaXNtbyBwcmVkZXRlcm1pbmFkbyBlcyBxdWUgbGFzIGNlbGRhcyBOb0RhdGEgZGUgZW50cmFkYSBxdWUgc2UgZW5jdWVudHJlbiBkZW50cm8gZGUgbGEgZXh0ZW5zacOzbiBlc3BhY2lhbCBkZSB1bmEgY2VsZGEgbcOhcyBncmFuZGUgZGVsIHLDoXN0ZXIgZGUgc2FsaWRhIHNlIGlnbm9yYXLDoW4gYWwgZGV0ZXJtaW5hciBlbCB2YWxvciBkZSBlc2EgY2VsZGEgZGUgc2FsaWRhLiBDb21vIGFsdGVybmF0aXZhLCBwdWVkZSBlc3BlY2lmaWNhciBxdWUsIHNpIGV4aXN0ZSBpbmNsdXNvIHVuYSBzb2xhIGNlbGRhIE5vRGF0YSBkZSBlbnRyYWRhIGRlbnRybyBkZSBsYSBleHRlbnNpw7NuIGVzcGFjaWFsIGRlIHVuYSBjZWxkYSBkZSBzYWxpZGEsIGRpY2hhIGNlbGRhIHNlcsOhIE5vRGF0YSBlbiBlbCByw6FzdGVyIGRlIHNhbGlkYS48L2Rpdj5cIixcblx0XHRjY2RjTmFtZTogXCJBbsOhbGlzaXMgQ0NEQ1wiLFxuXHRcdGNjZGNTbmlwOiBcIkV2YWzDumEgbG9zIGNhbWJpb3MgZW4gbG9zIHZhbG9yZXMgZGUgcMOteGVsIGEgbG8gbGFyZ28gZGVsIHRpZW1wbyB1dGlsaXphbmRvIGVsIGFsZ29yaXRtbyBDbGFzaWZpY2FjacOzbiB5IGRldGVjY2nDs24gZGUgY2FtYmlvcyBjb250aW51YXMgKENDREMpIHkgZ2VuZXJhIGxvcyByZXN1bHRhZG9zIGRlbCBtb2RlbG8uXCIsXG5cdFx0Y2NkY0Rlc2M6IFwiTGEgZnVuY2nDs24gQW7DoWxpc2lzIENDREMgZXZhbMO6YSBsb3MgY2FtYmlvcyBlbiBsb3MgdmFsb3JlcyBkZSBww614ZWwgYSBsbyBsYXJnbyBkZWwgdGllbXBvIHV0aWxpemFuZG8gZWwgYWxnb3JpdG1vIENsYXNpZmljYWNpw7NuIHkgZGV0ZWNjacOzbiBkZSBjYW1iaW9zIGNvbnRpbnVhcyAoQ0NEQykgeSBnZW5lcmEgdW4gcsOhc3RlciBtdWx0aWRpbWVuc2lvbmFsIHF1ZSBjb250aWVuZSBsb3MgcmVzdWx0YWRvcyBkZWwgbW9kZWxvLiBTb2xvIHNlIGFkbWl0ZSBqdW50byBjb24gbGEgZnVuY2nDs24gRGV0ZWN0YXIgY2FtYmlvcyBjb24gYW7DoWxpc2lzIGRlIGNhbWJpb3MgZW4gdW5hIHBsYW50aWxsYSBkZSBmdW5jacOzbiByw6FzdGVyLiBQYXJhIGdlbmVyYXIgdW5hIHNhbGlkYSBkZSByw6FzdGVyLCBjb25lY3RlIGxhIGZ1bmNpw7NuIEFuw6FsaXNpcyBDQ0RDIGNvbiBsYSBmdW5jacOzbiBEZXRlY3RhciBjYW1iaW9zIGNvbiBhbsOhbGlzaXMgZGUgY2FtYmlvcywgZ3VhcmRlIGNvbW8gdW5hIHBsYW50aWxsYSBkZSBmdW5jacOzbiByw6FzdGVyIHkgZWplY3V0ZSBBbsOhbGlzaXMgZGUgcsOhc3RlciBjb24gbGEgcGxhbnRpbGxhIGRlIGZ1bmNpw7NuLjxkaXY+PGJyLz5Fc3RhIGZ1bmNpw7NuIHV0aWxpemEgZWwgYWxnb3JpdG1vIENsYXNpZmljYWNpw7NuIHkgZGV0ZWNjacOzbiBkZSBjYW1iaW9zIGNvbnRpbnVhcyAoQ0NEQykgcGFyYSBldmFsdWFyIGxvcyBjYW1iaW9zIGVuIGxvcyB2YWxvcmVzIGRlIHDDrXhlbCBhIGxvIGxhcmdvIGRlbCB0aWVtcG8gcGFyYSB1bmEgcGlsYSBkZSBpbcOhZ2VuZXMuIEVuIHVuYSBzZXJpZSB0ZW1wb3JhbCBkZSBpbcOhZ2VuZXMgw7NwdGljYXMgbyBkZXJpdmFkb3MgZGUgaW3DoWdlbmVzIChwb3IgZWplbXBsbywgTkRWSSksIGxvcyB2YWxvcmVzIGRlIHDDrXhlbCBwdWVkZW4gZmx1Y3R1YXIgcG9yIGRpdmVyc29zIG1vdGl2b3M6IDEuIENhbWJpbyBlc3RhY2lvbmFsOiBsb3MgY2FtYmlvcyBkZSB2YWxvciBkZSBww614ZWwgcmVmbGVqYW4gY2FtYmlvcyBlbiBsYSB2ZWdldGFjacOzbiBkZWJpZG8gYSBsYSB2YXJpYWJpbGlkYWQgZXN0YWNpb25hbCBkZSBsYSB0ZW1wZXJhdHVyYSB5IGxhcyBwcmVjaXBpdGFjaW9uZXMuIEVuIGVsIGhlbWlzZmVyaW8gbm9ydGUsIHBvciBlamVtcGxvLCBzZSBlc3BlcmEgdmVyIHVuYSBtYXlvciBkZW5zaWRhZCBkZSB2ZWdldGFjacOzbiB2ZXJkZSBlbiB2ZXJhbm8gZW4gY29tcGFyYWNpw7NuIGNvbiBlbCBpbnZpZXJuby4gMi4gQ2FtYmlvIGdyYWR1YWw6IGxvcyBjYW1iaW9zIGRlIHZhbG9yIGRlIHDDrXhlbCByZWZsZWphbiBsYXMgdGVuZGVuY2lhcyBkZSBsYSB2ZWdldGFjacOzbiBvIGRlbCBhZ3VhIHN1cGVyZmljaWFsIGRlYmlkbyBhIGxhIHZhcmlhYmlsaWRhZCBjbGltw6F0aWNhIG8gYSBwcsOhY3RpY2FzIGRlIGdlc3Rpw7NuIGRlbCBzdWVsbyBhIGxhcmdvIHBsYXpvLiBQb3IgZWplbXBsbywgZWwgw6FyZWEgZGUgc3VlbG8gZGVzbnVkbyBwb2Ryw61hIGF1bWVudGFyIGdyYWR1YWxtZW50ZSBkZWJpZG8gYSB1bmEgZGlzbWludWNpw7NuIGEgbGFyZ28gcGxhem8gZGUgbGFzIHByZWNpcGl0YWNpb25lcy4gMy4gQ2FtYmlvIGFicnVwdG86IGxvcyBjYW1iaW9zIGRlIHZhbG9yIGRlIHDDrXhlbCByZWZsZWphbiBsb3MgY2FtYmlvcyBkZSBsYSBjb2JlcnR1cmEgZGVsIHN1ZWxvIHF1ZSBvY3VycmVuIHJlcGVudGluYW1lbnRlIGRlYmlkbyBhIGxhIGRlZm9yZXN0YWNpw7NuLCBlbCBkZXNhcnJvbGxvIHVyYmFuw61zdGljbywgY2F0w6FzdHJvZmVzIG5hdHVyYWxlcywgZXRjLiBFbCBhbGdvcml0bW8gQ0NEQyBpZGVudGlmaWNhIGxvcyB0cmVzIHRpcG9zIGRlIGNhbWJpbyBjb24gZWwgZmluIHByaW5jaXBhbCBkZSBpZGVudGlmaWNhciB1biBjYW1iaW8gYWJydXB0by4gTG9zIG1vZGVsb3MgZGUgdGVuZGVuY2lhIHkgcmVncmVzacOzbiBhcm3Ds25pY2FzIHNlIGFqdXN0YW4gYSBsb3MgZGF0b3MgcGFyYSBlc3RpbWFyIHVuIGNhbWJpbyBlc3RhY2lvbmFsIG8gZ3JhZHVhbCwgeSBsYXMgZGVzdmlhY2lvbmVzIHJlcGVudGluYXMgZGUgbG9zIG1vZGVsb3MgZGUgdGVuZGVuY2lhIHNvbiBpbmRpY2FjaW9uZXMgZGUgdW4gY2FtYmlvIGFicnVwdG8uPGRpdj48YnIvPkVsIGFsZ29yaXRtbyBDQ0RDIHNlIGRpc2XDscOzIG9yaWdpbmFsbWVudGUgcGFyYSBkYXRvcyBkZSBUZW1wZXJhdHVyYSBkZSBicmlsbG8gbyBSZWZsZWN0YW5jaWEgZGUgc3VwZXJmaWNpZSBkZSBkYXRvcyBkZSBMYW5kc2F0IFRNLCBMYW5kc2F0IEVUTSsgeSBMYW5kc2F0IE9MSS4gU2luIGVtYmFyZ28sIGxhIGZ1bmNpw7NuIERldGVjdGFyIGNhbWJpb3MgY29uIGFuw6FsaXNpcyBkZSBjYW1iaW9zIGp1bnRvIGNvbiBlc3RhIGZ1bmNpw7NuIGRldGVjdGFyw6EgY2FtYmlvcyBlbiBsYXMgaW3DoWdlbmVzIG11bHRpYmFuZGEgZGUgY3VhbHF1aWVyIHNlbnNvciBhZG1pdGlkbywgYXPDrSBjb21vIGRlcml2YWRvcyBkZSBpbcOhZ2VuZXMgZGUgdW5hIHNvbGEgYmFuZGEgY29tbyDDrW5kaWNlcyBkZSBiYW5kYS4gUG9yIGVqZW1wbG8sIHB1ZWRlIHJlYWxpemFyIHVuYSBkZXRlY2Npw7NuIGRlIGNhbWJpb3MgY29udGludWEgZW4gdW4gcsOhc3RlciBkZSDDjW5kaWNlIGRlIHZlZ2V0YWNpw7NuIGRlIGRpZmVyZW5jaWEgbm9ybWFsaXphZGEgKE5EVkkpLCBwb3JxdWUgbG9zIGNhbWJpb3MgYWJydXB0b3MgZW4gdW4gTkRWSSBwdWVkZW4gc2VyIGluZGljaW8gZGUgZGVmb3Jlc3RhY2nDs24uPC9kaXY+XCIsXG5cdFx0Y29tcHV0ZUNoYW5nZU5hbWU6IFwiQ2FsY3VsYXIgY2FtYmlvXCIsXG5cdFx0Y29tcHV0ZUNoYW5nZVNuaXA6IFwiQ2FsY3VsYSBsYSBkaWZlcmVuY2lhIGVudHJlIGRvcyBkYXRhc2V0cyByw6FzdGVyIGNvbnRpbnVvcyBvIGRlIGNhdGVnb3LDrWFzLlwiLFxuXHRcdGNvbXB1dGVDaGFuZ2VEZXNjOiBcIkxhIGZ1bmNpw7NuIENhbGN1bGFyIGNhbWJpbyBzZSBwdWVkZSB1dGlsaXphciBwYXJhIGVudW1lcmFyIGxhcyBkaWZlcmVuY2lhcyBlbnRyZSBkb3MgcsOhc3RlcmVzIGNsYXNpZmljYWRvcyBwYXJhIGVsIGFuw6FsaXNpcyBkZSBjYW1iaW9zIGRlIGNvYmVydHVyYSBkZSBzdWVsbyBvIHNlIHB1ZWRlIHV0aWxpemFyIHBhcmEgZXhhbWluYXIgbG9zIGNhbWJpb3MgZW50cmUgZG9zIHLDoXN0ZXJlcyBjb250aW51b3MgZGUgdW5hIHNvbGEgYmFuZGEsIHBvciBlamVtcGxvLCBlbGV2YWNpw7NuLCB0ZW1wZXJhdHVyYSwgZXh0ZW5zacOzbiBkZSBjb2JlcnR1cmEsIGV0Yy5cIixcblx0XHRkZXRlY3RDaGFuZ2VOYW1lOiBcIkRldGVjdGFyIGNhbWJpb3MgY29uIGFuw6FsaXNpcyBkZSBjYW1iaW9zXCIsXG5cdFx0ZGV0ZWN0Q2hhbmdlU25pcDogXCJHZW5lcmEgdW5hIGNhcGEgcsOhc3RlciBxdWUgY29udGllbmUgaW5mb3JtYWNpw7NuIGRlIGNhbWJpb3MgZGUgcMOteGVsIGNvbiBlbCByw6FzdGVyIGRlIGFuw6FsaXNpcyBkZSBjYW1iaW9zIGRlIHNhbGlkYS5cIixcblx0XHRkZXRlY3RDaGFuZ2VEZXNjOiBcIjxkaXY+TGEgZnVuY2nDs24gRGV0ZWN0YXIgY2FtYmlvcyBjb24gYW7DoWxpc2lzIGRlIGNhbWJpb3MgZ2VuZXJhIHVuYSBjYXBhIHLDoXN0ZXIgcXVlIGNvbnRpZW5lIGluZm9ybWFjacOzbiBkZSBmZWNoYSBkZSBjYW1iaW8gZGUgcMOteGVsIGNvbiBlbCByw6FzdGVyIGRlIGFuw6FsaXNpcyBkZSBjYW1iaW9zLiBFbCByw6FzdGVyIGRlIGFuw6FsaXNpcyBkZSBjYW1iaW9zIGRlYmUgc2VyIGdlbmVyYWRvIHBvciBsYSBoZXJyYW1pZW50YSBBbmFsaXphciBjYW1iaW9zIHVzYW5kbyBDQ0RDIG8gbGEgaGVycmFtaWVudGEgQW5hbGl6YXIgY2FtYmlvcyBjb24gTGFuZFRyZW5kciwgbyBiaWVuIGxhIGZ1bmNpw7NuIHLDoXN0ZXIgQW7DoWxpc2lzIENDREMgbyBBbsOhbGlzaXMgTGFuZFRyZW5kci48L2Rpdj48YnI+PGRpdj5Fc3RhIGZ1bmNpw7NuIHLDoXN0ZXIgc2UgcHVlZGUgY29tYmluYXIgY29uIGxhcyBmdW5jaW9uZXMgcsOhc3RlciBBbsOhbGlzaXMgQ0NEQyBvIEFuw6FsaXNpcyBMYW5kVHJlbmRyIGVuIHVuYSBwbGFudGlsbGEgZGUgZnVuY2nDs24gcsOhc3Rlci4gUGFyYSBnZW5lcmFyIHVuYSBzYWxpZGEgZGUgcsOhc3RlciBwZXJtYW5lbnRlLCBjb25lY3RlIGxhIGZ1bmNpw7NuIEFuw6FsaXNpcyBDQ0RDIG8gbGEgZnVuY2nDs24gQW7DoWxpc2lzIExhbmRUcmVuZHIgY29uIGxhIGZ1bmNpw7NuIERldGVjdGFyIGNhbWJpb3MgY29uIGFuw6FsaXNpcyBkZSBjYW1iaW9zLCBndWFyZGUgY29tbyB1bmEgcGxhbnRpbGxhIGRlIGZ1bmNpw7NuIHLDoXN0ZXIgeSBlamVjdXRlIEFuw6FsaXNpcyBkZSByw6FzdGVyIGNvbiBsYSBwbGFudGlsbGEuPC9kaXY+PGJyPjxkaXY+RWwgcGFyw6FtZXRybyA8c3Ryb25nPlRpcG8gZGUgY2FtYmlvPC9zdHJvbmc+IGluZGljYSBsYSBpbmZvcm1hY2nDs24gcXVlIHNlIGdlbmVyYS4gTGEgaW5mb3JtYWNpw7NuIHNlIGV4dHJhZSBkZWwgcsOhc3RlciBkZSBhbsOhbGlzaXMgZGUgY2FtYmlvcy4gQ3VhbmRvIHNlIGVqZWN1dGEgZXN0YSBmdW5jacOzbiBlbiBsYSBzYWxpZGEgZGUgbGEgZnVuY2nDs24vaGVycmFtaWVudGEgQ0NEQywgcHVlZGUgZWxlZ2lyIGVudHJlIGxhcyBzaWd1aWVudGVzIG9wY2lvbmVzOjwvZGl2Pjx1bD48bGk+PHN0cm9uZz5Ib3JhIGRlbCDDumx0aW1vIGNhbWJpbzwvc3Ryb25nPjogbGEgZmVjaGEgeSBob3JhIG3DoXMgcmVjaWVudGVzIGVuIGxhcyBxdWUgc2UgbWFyY8OzIHVuIHDDrXhlbCBjb21vIGNhbWJpYWRvLjwvbGk+PGxpPjxzdHJvbmc+SG9yYSBkZWwgY2FtYmlvIG3DoXMgYW50aWd1bzwvc3Ryb25nPjogbGEgZmVjaGEgeSBob3JhIGVuIGxhIHF1ZSBzZSBtYXJjw7MgdW4gcMOteGVsIGNvbW8gY2FtYmlhZG8uPC9saT48bGk+PHN0cm9uZz5Ib3JhIGRlbCBjYW1iaW8gbcOhcyBncmFuZGU8L3N0cm9uZz46IGxhIGZlY2hhIHkgaG9yYSBlbiBsYXMgcXVlIGVsIGNhbWJpbyBjYWxjdWxhZG8gZXJhIGxhIG3DoXMgc2lnbmlmaWNhdGl2YSBwYXJhIHVuIHDDrXhlbC48L2xpPjxsaT4gPHN0cm9uZz5Ow7ptZXJvIGRlIGNhbWJpb3M8L3N0cm9uZz46IGVsIG7Dum1lcm8gdG90YWwgZGUgdmVjZXMgcXVlIGVsIHDDrXhlbCBoYSBjYW1iaWFkby48L2xpPjwvdWw+PGRpdj5BbCBlamVjdXRhciBlc3RhIGZ1bmNpw7NuIGVuIGxhIHNhbGlkYSBkZSBsYSBmdW5jacOzbi9oZXJyYW1pZW50YSBMYW5kVHJlbmRyLCBlc3TDoW4gZGlzcG9uaWJsZXMgbGFzIHNpZ3VpZW50ZXMgb3BjaW9uZXMgYWRpY2lvbmFsZXM6PC9kaXY+PHVsPjxsaT48c3Ryb25nPkhvcmEgZGVsIGNhbWJpbyBtw6FzIGxhcmdvPC9zdHJvbmc+OiBsYSBmZWNoYSBlbiBsYSBxdWUgdW4gcMOteGVsIGZ1ZSBtYXJjYWRvIGNvbW8gY2FtYmlhZG8sIGFsIHByaW5jaXBpbyBvIGFsIGZpbmFsIGRlbCBwZXJpb2RvIGRlIGNhbWJpbyBtw6FzIGxhcmdvLjwvbGk+PGxpPjxzdHJvbmc+SG9yYSBkZWwgY2FtYmlvIG3DoXMgY29ydG88L3N0cm9uZz46IGxhIGZlY2hhIGVuIGxhIHF1ZSB1biBww614ZWwgc2UgbWFyY8OzIGNvbW8gY2FtYmlhZG8sIGFsIHByaW5jaXBpbyBvIGFsIGZpbmFsIGRlbCBwZXJpb2RvIGRlIGNhbWJpbyBtw6FzIGNvcnRvLjwvbGk+PGxpPjxzdHJvbmc+SG9yYSBkZWwgY2FtYmlvIG3DoXMgcsOhcGlkbzwvc3Ryb25nPjogbGEgZmVjaGEgZW4gbGEgcXVlIHVuIHDDrXhlbCBzZSBtYXJjw7MgY29tbyBjYW1iaWFkbywgYWwgcHJpbmNpcGlvIG8gYWwgZmluYWwgZGVsIHBlcmlvZG8gZGUgY2FtYmlvIG3DoXMgcsOhcGlkby48L2xpPjxsaT48c3Ryb25nPkhvcmEgZGVsIGNhbWJpbyBtw6FzIGxlbnRvPC9zdHJvbmc+OiBsYSBmZWNoYSBlbiBsYSBxdWUgdW4gcMOteGVsIHNlIG1hcmPDsyBjb21vIGNhbWJpYWRvLCBhbCBwcmluY2lwaW8gbyBhbCBmaW5hbCBkZWwgcGVyaW9kbyBkZSBjYW1iaW8gbcOhcyBsZW50by48L2xpPjwvdWw+PGRpdj5FbCByw6FzdGVyIGRlIHNhbGlkYSBlcyB1biByw6FzdGVyIG11bHRpYmFuZGEgZW4gZWwgcXVlIGNhZGEgYmFuZGEgY29udGllbmUgaW5mb3JtYWNpw7NuIGRlIGNhbWJpb3MgZW4gZnVuY2nDs24gZGVsIHRpcG8gZGUgY2FtYmlvIHNlbGVjY2lvbmFkbyB5IGRlbCBuw7ptZXJvIG3DoXhpbW8gZGUgY2FtYmlvcyBlc3BlY2lmaWNhZG8uIFBvciBlamVtcGxvLCBzaSA8c3Ryb25nPlRpcG8gZGUgY2FtYmlvPC9zdHJvbmc+IGVzdMOhIGRlZmluaWRvIGNvbW8gPHN0cm9uZz5Ib3JhIGRlbCBjYW1iaW8gbcOhcyB0ZW1wcmFubzwvc3Ryb25nPiB5IDxzdHJvbmc+TsO6bWVybyBtw6F4aW1vIGRlIGNhbWJpb3M8L3N0cm9uZz4gZXN0w6EgZGVmaW5pZG8gY29tbyAyLCBsYSBmdW5jacOzbiBjYWxjdWxhIGxhcyBkb3MgZmVjaGFzIG3DoXMgdGVtcHJhbmFzIGVuIGxhcyBxdWUgc2UgcHJvZHVqZXJvbiBjYW1iaW9zIGR1cmFudGUgdG9kYSBsYSBzZXJpZSB0ZW1wb3JhbCBwYXJhIGNhZGEgcMOteGVsLiBFbCByZXN1bHRhZG8gZXMgdW4gcsOhc3RlciBlbiBlbCBxdWUgbGEgcHJpbWVyYSBiYW5kYSBjb250aWVuZSBsYXMgZmVjaGFzIGRlbCBjYW1iaW8gbcOhcyB0ZW1wcmFubyBwb3IgcMOteGVsIHkgbGEgc2VndW5kYSBiYW5kYSBjb250aWVuZSBsYXMgZmVjaGFzIGRlbCBzZWd1bmRvIGNhbWJpbyBtw6FzIHRlbXByYW5vIHBvciBww614ZWwuPC9kaXY+PGJyPjxkaXY+QWwgYXBsaWNhciBlc3RhIGZ1bmNpw7NuIGVuIGxhIHNhbGlkYSBkZSBsYXMgaGVycmFtaWVudGFzIExhbmRUcmVuZHIsIHB1ZWRlIGVsZWdpciBzaSBkZXNlYSBleHRyYWVyIGxhIGZlY2hhIHF1ZSBtYXJjYSBlbCBpbmljaW8gZGUgdW4gY2FtYmlvIG8gZWwgZmluYWwgZGUgdW4gY2FtYmlvIGNvbiBlbCBwYXLDoW1ldHJvIDxzdHJvbmc+RmVjaGEgZGUgc2VnbWVudG88L3N0cm9uZz4uIFBvciBlamVtcGxvLCBwYXJhIGVudGVuZGVyIGPDs21vIHNlIGluaWNpw7MgZWwgY2FtYmlvIG3DoXMgcmVjaWVudGUgZW4gbGEgc2VyaWUgdGVtcG9yYWwsIGVzdGFibGV6Y2EgZWwgPHN0cm9uZz5UaXBvIGRlIGNhbWJpbzwvc3Ryb25nPiBlbiA8c3Ryb25nPkhvcmEgZGVsIGNhbWJpbyBtw6FzIHJlY2llbnRlPC9zdHJvbmc+IHkgbGEgPHN0cm9uZz5GZWNoYSBkZSBzZWdtZW50bzwvc3Ryb25nPiBlbiA8c3Ryb25nPkluaWNpbyBkZSBzZWdtZW50bzwvc3Ryb25nPi48L2Rpdj48YnI+PGRpdj5VdGlsaWNlIGxvcyBzaWd1aWVudGVzIHBhcsOhbWV0cm9zIGRlIGZpbHRyYWRvIHBhcmEgZXh0cmFlciBmZWNoYXMgZGUgY2FtYmlvIG3DoXMgZXNwZWPDrWZpY2FzIGRlbCByw6FzdGVyIGRlIGFuw6FsaXNpcyBkZSBjYW1iaW9zOjwvZGl2Pjx1bD48bGk+PHN0cm9uZz5GaWx0cmFyIHBvciBhw7FvPC9zdHJvbmc+OiBpZGVudGlmaXF1ZSBsb3MgY2FtYmlvcyBxdWUgc2UgcHJvZHVqZXJvbiBlbiB1biBwZXLDrW9kbyBkZSB0aWVtcG8gZXNwZWPDrWZpY28sIHBvciBlamVtcGxvLCBzaSBlc3TDoSBidXNjYW5kbyBjYW1iaW9zIHF1ZSBzZSBwcm9kdWplcmFuIGVuIHVuIHBhaXNhamUgZHVyYW50ZSBjaW5jbyBhw7FvcyBkZSBzZXF1w61hLjwvbGk+PGxpPjxzdHJvbmc+RmlsdHJhciBwb3IgZHVyYWNpw7NuPC9zdHJvbmc+OiBpZGVudGlmaXF1ZSBsb3MgY2FtYmlvcyBxdWUgc2UgcHJvZHVqZXJvbiBhIGxvIGxhcmdvIGRlIHVuIHJhbmdvIGRldGVybWluYWRvIGRlIGHDsW9zLCBwb3IgZWplbXBsbywgc2kgc29sbyBlc3TDoSBidXNjYW5kbyBjYW1iaW9zIGFicnVwdG9zIHF1ZSBzZSBwcm9kdWplcmFuIGVuIDEgbyAyIGHDsW9zLiBQdWVkZSBjYWxjdWxhciBsYSBkdXJhY2nDs24gcXVlIGxlIGludGVyZXNlIGNvbiBsYSBmw7NybXVsYSA8c3Ryb25nPmHDsW8gZmluYWwgLSBhw7FvIGluaWNpYWwgKzE8L3N0cm9uZz4uIFNlIGluY2x1aXLDoW4gbG9zIGh1ZWNvcyBlbiBsYXMgc2VyaWVzIHRlbXBvcmFsZXMuPC9saT48bGk+PHN0cm9uZz5GaWx0cmFyIHBvciBtYWduaXR1ZDwvc3Ryb25nPjogaWRlbnRpZmlxdWUgbG9zIGNhbWJpb3MgZGUgdW5hIG1hZ25pdHVkIGRldGVybWluYWRhLCBwb3IgZWplbXBsbywgc2kgc29sbyBlc3TDoSBidXNjYW5kbyBjYW1iaW9zIGdyYW5kZXMgZW4gZWwgw61uZGljZSBkZSB2ZWdldGFjacOzbiBORFZJLiBMYSBtYWduaXR1ZCBlcyB1biB2YWxvciBhYnNvbHV0bywgcG9yIGxvIHF1ZSBsb3MgdmFsb3JlcyBtw61uaW1vIHkgbcOheGltbyBubyBwdWVkZW4gc2VyIG5lZ2F0aXZvcy4gUGFyYSBlc3BlY2lmaWNhciBlbCBjYW1iaW8gZGlyZWNjaW9uYWwsIHV0aWxpY2UgZWwgcGFyw6FtZXRybyA8c3Ryb25nPkNhbWJpYXIgZGlyZWNjacOzbjwvc3Ryb25nPi48L2xpPjwvdWw+XCIsXG5cdFx0ZGlzdGFuY2VBY2N1bXVsYXRpb25OYW1lOiBcIkFjdW11bGFjacOzbiBkZSBkaXN0YW5jaWFcIixcblx0XHRkaXN0YW5jZUFjY3VtdWxhdGlvblNuaXA6IFwiQ2FsY3VsYSBsYSBkaXN0YW5jaWEgYWN1bXVsYWRhIHBhcmEgY2FkYSBjZWxkYSBhIGxvcyBvcsOtZ2VuZXMsIHRlbmllbmRvIGVuIGN1ZW50YSBsYSBkaXN0YW5jaWEgZW4gbMOtbmVhIHJlY3RhLCBjb3N0ZS1kaXN0YW5jaWEsIHZlcmRhZGVyYSBkaXN0YW5jaWEgZGUgc3VwZXJmaWNpZSB5IGZhY3RvcmVzIGRlIGNvc3RlIHZlcnRpY2FsIHkgaG9yaXpvbnRhbC5cIixcblx0XHRkaXN0YW5jZUFjY3VtdWxhdGlvbkRlc2M6IFwiQWN1bXVsYWNpw7NuIGRlIGRpc3RhbmNpYSBjYWxjdWxhIGxhIGRpc3RhbmNpYSBkZSBjYWRhIHViaWNhY2nDs24gZGVsIMOhcmVhIGRlIGVzdHVkaW8gYWwgb3JpZ2VuIG3DoXMgY2VyY2FubywgbyBkZSBtZW5vciBjb3N0ZS4gU2kgc29sbyBzZSBwcm9wb3JjaW9uYW4gbG9zIG9yw61nZW5lcyBwYXJhIGxhIGVudHJhZGEsIGVudG9uY2VzIHNlIGNhbGN1bGEgdW5hIGRpc3RhbmNpYSBlbiBsw61uZWEgcmVjdGEgaGFzdGEgY2FkYSB1YmljYWNpw7NuIGRlbCDDoXJlYSBkZSBlc3R1ZGlvLiBTaSBzZSB1dGlsaXphbiBvcsOtZ2VuZXMgeSBiYXJyZXJhcyBjb21vIGVudHJhZGEsIGVudG9uY2VzIEFjdW11bGFjacOzbiBkZSBkaXN0YW5jaWEgY2FsY3VsYSBsYSBkaXN0YW5jaWEgZW4gbMOtbmVhIHJlY3RhIGFscmVkZWRvciBkZSBsYXMgYmFycmVyYXMuIFBhcmEgZWwgcsOhc3RlciBkZSBvcmlnZW4geSBlbCByw6FzdGVyIGRlIGJhcnJlcmEsIGVsIHZhbG9yIGRlIGZvbmRvIGRlYmVyw61hIHNlciBOb0RhdGEsIG1pZW50cmFzIHF1ZSBsb3Mgb3LDrWdlbmVzIHkgbGFzIGJhcnJlcmFzIHNlIHJlcHJlc2VudGFuIGNvbiB2YWxvcmVzIGRlIGNlbGRhIHbDoWxpZG9zLiBFbnRyZSBsb3MgdmFsb3JlcyB2w6FsaWRvcyBzZSBpbmNsdXllIGNlcm8uIDxkaXY+PGJyLz5DdWFuZG8gc2UgcHJvcG9yY2lvbmEgdW4gcsOhc3RlciBkZSBzdXBlcmZpY2llIGNvbW8gZW50cmFkYSwgZW50b25jZXMgc2UgY2FsY3VsYSBsYSBkaXN0YW5jaWEgZGUgc3VwZXJmaWNpZSByZWFsIGVudHJlIGxhcyBjZWxkYXMuIFBhcmEgcmVhbGl6YXIgdW4gYW7DoWxpc2lzIGRlIGNvc3RlIGNvbiBBY3VtdWxhY2nDs24gZGUgZGlzdGFuY2lhLCBzZSBuZWNlc2l0YSB1bmEgc3VwZXJmaWNpZSBkZSBjb3N0ZS4gU2kgc2UgcHJvcG9yY2lvbmEgdW5hIHN1cGVyZmljaWUgZGUgY29zdGUsIGVudG9uY2VzIGVsIHJlc3VsdGFkbyBlcyB1biByw6FzdGVyIGRlIGNvc3RlLWRpc3RhbmNpYSBhY3VtdWxhZG8uIEN1YW5kbyBzZSBwcm9wb3JjaW9uYW4gbG9zIGZhY3RvcmVzIGhvcml6b250YWwgeSB2ZXJ0aWNhbCwgZW50b25jZXMgc2UgYWN1bXVsYSBsYSBkaXJlY2Npb25hbGlkYWQgcXVlIHNlIGNvbnNpZGVyYSBjb21vIGNvc3RlLiBTZSBwdWVkZW4gdXRpbGl6YXIgY3VhdHJvIGNhcmFjdGVyw61zdGljYXMgZGUgb3JpZ2VuLiBFc3RhcyBjYXJhY3RlcsOtc3RpY2FzLCBxdWUgcHVlZGVuIHNlciBkZWwgb3JpZ2VuIG8gZGUgbG9zIGVsZW1lbnRvcyBxdWUgc2UgbXVldmVuIGRlc2RlIGVsIG9yaWdlbiwgc2UgY29udHJvbGFuIHBvciBtZWRpbyBkZSBwYXLDoW1ldHJvcyBlc3BlY8OtZmljb3M6IDEuIEFjdW11bGFjacOzbiBpbmljaWFsOuKAr2RlZmluZSBlbCBjb3N0ZSBpbmljaWFsIGFudGVzIGRlIHF1ZSBzZSBpbmljaWUgZWwgbW92aW1pZW50by4gMi4gQWN1bXVsYWNpw7NuIG3DoXhpbWE64oCvZXNwZWNpZmljYSBlbCBjb3N0ZSBxdWUgcHVlZGUgYWN1bXVsYXIgdW4gb3JpZ2VuIGFudGVzIGRlIGFsY2FuemFyIHN1IGzDrW1pdGUuIDMuIE11bHRpcGxpY2Fkb3IgcGFyYSBhcGxpY2FyIGEgbG9zIGNvc3RlczrigK9lc3BlY2lmaWNhIGVsIG1vZG8gZGUgZGVzcGxhemFtaWVudG8gbyBsYSBtYWduaXR1ZCBlbiBlbCBvcmlnZW4uIDQuIERpcmVjY2nDs24gZGVsIHZpYWplOuKAr2lkZW50aWZpY2Egc2kgZWwgZWxlbWVudG8gcXVlIHNlIG11ZXZlIGNvbWllbnphIGVuIHVuIG9yaWdlbiB5IHNlIG11ZXZlIGEgdWJpY2FjaW9uZXMgZGlzdGludGFzIGRlbCBvcmlnZW4sIG8gY29taWVuemEgZW4gdWJpY2FjaW9uZXMgZGlzdGludGFzIGRlbCBvcmlnZW4geSByZWdyZXNhIGEgdW4gb3JpZ2VuLjxkaXY+PGJyLz5Qb3IgZGVmZWN0bywgZWwgcmVzdWx0YWRvIGRlIEFjdW11bGFjacOzbiBkZSBkaXN0YW5jaWEgZXMgdW5hIGJhbmRhIMO6bmljYSwgcXVlIGVzIGVsIHLDoXN0ZXIgZGUgYWN1bXVsYWNpw7NuIGRlIGRpc3RhbmNpYS4gU2luIGVtYmFyZ28sIHRhbWJpw6luIHNlIHB1ZWRlIGNyZWFyIHVuYSBzZWd1bmRhIGJhbmRhLCBsYSBiYW5kYSBkZSBkaXJlY2Npw7NuIGhhY2lhIGF0csOhcy4gIEVzdGEgYmFuZGEgaW5kaWNhIHBhcmEgY2FkYSB1YmljYWNpw7NuIGRlbCDDoXJlYSBkZSBlc3R1ZGlvIGxhIGRpcmVjY2nDs24gZW4gbGEgcXVlIGlyIHBhcmEgbGxlZ2FyIGFsIG9yaWdlbiBkZSBtZW5vciBjb3N0ZS4gIFNlIG5lY2VzaXRhcsOhbiBhbWJhcyBiYW5kYXMgcGFyYSBkZXRlcm1pbmFyIGxhcyBydXRhcyDDs3B0aW1hcyBkZW50cm8gZGVsIMOhcmVhIGRlIGVzdHVkaW8uIFBhcmEgZ2VuZXJhciB1bmEgcnV0YSwgdXRpbGljZSBwcmltZXJvIGxhIGZ1bmNpw7NuIEV4dHJhZXIgYmFuZGEgcGFyYSBleHRyYWVyIGVsIHLDoXN0ZXIgZGUgYWN1bXVsYWNpw7NuIGRlIGRpc3RhbmNpYSB5IGVsIHLDoXN0ZXIgZGUgZGlyZWNjacOzbiBoYWNpYSBhdHLDoXMuIFV0aWxpY2UgZXN0YXMgY2FwYXMgY29tbyBlbnRyYWRhIGRlIGxhIGZ1bmNpw7NuIFJ1dGEgZGUgY29zdGUuIEVuIGxhIGZ1bmNpw7NuLCB1c2UgZWwgcsOhc3RlciBkZSBhY3VtdWxhY2nDs24gZGUgZGlzdGFuY2lhIGNvbW8gZW50cmFkYSBkZWwgUsOhc3RlciBkZSBjb3N0ZS1kaXN0YW5jaWEgeSBlbCByw6FzdGVyIGRlIGRpcmVjY2nDs24gaGFjaWEgYXRyw6FzIGNvbW8gbGEgZW50cmFkYSBkZWwgUsOhc3RlciBkZSB2w61uY3VsbyBkZSBtZW5vciBjb3N0ZS48L2Rpdj5cIixcblx0XHRkaXN0YW5jZUFsbG9jYXRpb25OYW1lOiBcIkFzaWduYWNpw7NuIGRlIGRpc3RhbmNpYVwiLFxuXHRcdGRpc3RhbmNlQWxsb2NhdGlvblNuaXA6IFwiQ2FsY3VsYSBsYSBhc2lnbmFjacOzbiBkZSBkaXN0YW5jaWEgcGFyYSBjYWRhIGNlbGRhIGEgbG9zIG9yw61nZW5lcyBwcm9wb3JjaW9uYWRvcyBlbiBmdW5jacOzbiBkZSBsYSBkaXN0YW5jaWEgZW4gbMOtbmVhIHJlY3RhLCBjb3N0ZS1kaXN0YW5jaWEsIHZlcmRhZGVyYSBkaXN0YW5jaWEgZGUgc3VwZXJmaWNpZSB5IGZhY3RvcmVzIGRlIGNvc3RlIHZlcnRpY2FsIHkgaG9yaXpvbnRhbC5cIixcblx0XHRkaXN0YW5jZUFsbG9jYXRpb25EZXNjOiBcIkFzaWduYWNpw7NuIGRlIGRpc3RhbmNpYSBjYWxjdWxhIGEgcXXDqSBvcmlnZW4gc2UgYXNpZ25hIGNhZGEgdWJpY2FjacOzbiBkZWwgw6FyZWEgZGUgZXN0dWRpby4gU2kgc29sbyBzZSBwcm9wb3JjaW9uYW4gbG9zIG9yw61nZW5lcyBwYXJhIGxhIGVudHJhZGEsIGVudG9uY2VzIHNlIGFzaWduYW4gbGFzIHViaWNhY2lvbmVzIGNvbiB1bmEgZGlzdGFuY2lhIGVuIGzDrW5lYSByZWN0YSBoYXN0YSBlbCBvcmlnZW4gbcOhcyBjZXJjYW5vLiBTaSBzZSB1dGlsaXphbiBvcsOtZ2VuZXMgeSBiYXJyZXJhcyBjb21vIGVudHJhZGEsIGVudG9uY2VzIEFzaWduYWNpw7NuIGRlIGRpc3RhbmNpYSBjYWxjdWxhIGxhIGRpc3RhbmNpYSBlbiBsw61uZWEgcmVjdGEgYWxyZWRlZG9yIGRlIGxhcyBiYXJyZXJhcyBwYXJhIGRldGVybWluYXIgYSBxdcOpIHViaWNhY2nDs24gc2UgYXNpZ25hIHVuIG9yaWdlbi4gUGFyYSBlbCByw6FzdGVyIGRlIG9yaWdlbiB5IGVsIHLDoXN0ZXIgZGUgYmFycmVyYSwgZWwgdmFsb3IgZGUgZm9uZG8gZGViZXLDrWEgc2VyIE5vRGF0YSwgbWllbnRyYXMgcXVlIGxvcyBvcsOtZ2VuZXMgeSBsYXMgYmFycmVyYXMgc2UgcmVwcmVzZW50YW4gY29uIHZhbG9yZXMgZGUgY2VsZGEgdsOhbGlkb3MuIEVudHJlIGxvcyB2YWxvcmVzIHbDoWxpZG9zIHNlIGluY2x1eWUgY2Vyby48ZGl2Pjxici8+UGFyYSByZWFsaXphciB1biBhbsOhbGlzaXMgZGUgY29zdGUgY29uIEFzaWduYWNpw7NuIGRlIGRpc3RhbmNpYSwgc2UgbmVjZXNpdGEgdW5hIHN1cGVyZmljaWUgZGUgY29zdGUuIFNpIHNlIHByb3BvcmNpb25hIHVuYSBzdXBlcmZpY2llIGRlIGNvc3RlLCBlbnRvbmNlcyBlbCByZXN1bHRhZG8gZXMgdW4gcsOhc3RlciBkZSBhc2lnbmFjacOzbiBiYXNhZG8gZW4gZWwgY29zdGUgYWN1bXVsYXRpdm8sIG5vIGVuIHVuYSBkaXN0YW5jaWEgZW4gbMOtbmVhIHJlY3RhLiBDdWFuZG8gc2UgcHJvcG9yY2lvbmFuIGxvcyBmYWN0b3JlcyBob3Jpem9udGFsIHkgdmVydGljYWwsIGVudG9uY2VzIHNlIGFjdW11bGEgbGEgZGlyZWNjaW9uYWxpZGFkIHF1ZSBzZSBjb25zaWRlcmEgY29tbyBjb3N0ZS4gQ3VhbmRvIHNlIHByb3BvcmNpb25hIHVuIHLDoXN0ZXIgZGUgc3VwZXJmaWNpZSBjb21vIGVudHJhZGEsIGVudG9uY2VzIGxhIGRpc3RhbmNpYSBkZSBzdXBlcmZpY2llIHJlYWwgY3ViaWVydGEgYWwgcGFzYXIgZW50cmUgY2VsZGFzIHNlIGNhbGN1bGEgY3VhbmRvIHNlIGRldGVybWluYSBsYSBhc2lnbmFjacOzbi4gU2UgcHVlZGVuIHV0aWxpemFyIGN1YXRybyBjYXJhY3RlcsOtc3RpY2FzIGRlIG9yaWdlbi4gRXN0YXMgY2FyYWN0ZXLDrXN0aWNhcywgcXVlIHB1ZWRlbiBzZXIgZGVsIG9yaWdlbiBvIGRlIGxvcyBlbGVtZW50b3MgcXVlIHNlIG11ZXZlbiBkZXNkZSBlbCBvcmlnZW4sIHNlIGNvbnRyb2xhbiBwb3IgbWVkaW8gZGUgcGFyw6FtZXRyb3MgZXNwZWPDrWZpY29zOiAxLiBBY3VtdWxhY2nDs24gaW5pY2lhbDrigK9kZWZpbmUgZWwgY29zdGUgaW5pY2lhbCBhbnRlcyBkZSBxdWUgc2UgaW5pY2llIGVsIG1vdmltaWVudG8uIDIuIEFjdW11bGFjacOzbiBtw6F4aW1hOuKAr2VzcGVjaWZpY2EgZWwgY29zdGUgcXVlIHB1ZWRlIGFjdW11bGFyIHVuIG9yaWdlbiBhbnRlcyBkZSBhbGNhbnphciBzdSBsw61taXRlLiAzLiBNdWx0aXBsaWNhZG9yIHBhcmEgYXBsaWNhciBhIGxvcyBjb3N0ZXM64oCvZXNwZWNpZmljYSBlbCBtb2RvIGRlIGRlc3BsYXphbWllbnRvIG8gbGEgbWFnbml0dWQgZW4gZWwgb3JpZ2VuLiA0LiBEaXJlY2Npw7NuIGRlbCB2aWFqZTrigK9pZGVudGlmaWNhIHNpIGVsIGVsZW1lbnRvIHF1ZSBzZSBtdWV2ZSBjb21pZW56YSBlbiB1biBvcmlnZW4geSBzZSBtdWV2ZSBhIHViaWNhY2lvbmVzIGRpc3RpbnRhcyBkZWwgb3JpZ2VuLCBvIGNvbWllbnphIGVuIHViaWNhY2lvbmVzIGRpc3RpbnRhcyBkZWwgb3JpZ2VuIHkgcmVncmVzYSBhIHVuIG9yaWdlbi48ZGl2Pjxici8+UG9yIGRlZmVjdG8sIGVsIHJlc3VsdGFkbyBkZSBBc2lnbmFjacOzbiBkZSBkaXN0YW5jaWEgZXMgdW5hIGJhbmRhIMO6bmljYSwgcXVlIGVzIGVsIHLDoXN0ZXIgZGUgYXNpZ25hY2nDs24gZGUgZGlzdGFuY2lhLiBBbCBhY3RpdmFyIGxhIG9wY2nDs24gYm9vbGVhbmEgR2VuZXJhciBmaWxhIHkgY29sdW1uYSBkZSBvcmlnZW4gY29tbyBiYW5kYXMgYWRpY2lvbmFsZXMgZW4gbGEgc2FsaWRhIHJlc3VsdGFyw6EgZW4gdW4gcsOhc3RlciBtdWx0aWJhbmRhIHF1ZSBjb25zdGEgZGUgdHJlcyBiYW5kYXMuIExhIHByaW1lcmEgYmFuZGEgZXMgbGEgYmFuZGEgZGUgYXNpZ25hY2nDs24gZGUgZGlzdGFuY2lhLCBsYSBzZWd1bmRhIGJhbmRhIGNvbnRpZW5lIHVuIMOtbmRpY2UgZGUgZmlsYSB5IGxhIHRlcmNlcmEgYmFuZGEgY29udGllbmUgdW4gw61uZGljZSBkZSBjb2x1bW5hLiBFc3RvcyDDrW5kaWNlcyBpZGVudGlmaWNhbiBsYSB1YmljYWNpw7NuIGRlIGxhIGNlbGRhIGRlIG9yaWdlbiBtw6FzIGNlcmNhbmEgYWwgbWVub3IgY29zdGUtZGlzdGFuY2lhIGFjdW11bGFkby4gRWwgw61uZGljZSBkZSBmaWxhIGRlIG9yaWdlbiB5IGVsIMOtbmRpY2UgZGUgY29sdW1uYSBkZSBvcmlnZW4gc2UgcHVlZGVuIHV0aWxpemFyIGp1bnRvcyBwYXJhIHJlYWxpemFyIHVuYSByZXByZXNlbnRhY2nDs24gZGUgbGEgaW50ZW5zaWRhZC4gU2kgY29uc3VsdGEgY3VhbHF1aWVyIHViaWNhY2nDs24gZW4gc3Ugw6FyZWEgZGUgZXN0dWRpbyBlbiBsYXMgYmFuZGFzIGRvcyB5IHRyZXMsIHNhYnLDoSBsYSBmaWxhIHkgbGEgY29sdW1uYSBkZWwgb3JpZ2VuIGRlIG1lbm9yIGNvc3RlIHBhcmEgZXNhIHViaWNhY2nDs24uPC9kaXY+XCIsXG5cdFx0ZXVjQmFja0RpcmVjdGlvbk5hbWU6IFwiRGlyZWNjacOzbiBldWNsaWRpYW5hIGhhY2lhIGF0csOhc1wiLFxuXHRcdGV1Y0JhY2tEaXJlY3Rpb25TbmlwOiBcIkNhbGN1bGEgZW4gZ3JhZG9zLCBwYXJhIGNhZGEgY2VsZGEsIGxhIGRpcmVjY2nDs24gYSBsYSBjZWxkYSB2ZWNpbmEgcG9yIGxhIHJ1dGEgbcOhcyBjb3J0YSwgZGUgdnVlbHRhIGFsIG9yaWdlbiBtw6FzIGNlcmNhbm8sIGEgbGEgdmV6IHF1ZSBldml0YSBsYXMgYmFycmVyYXMuXCIsXG5cdFx0ZXVjQmFja0RpcmVjdGlvbkRlc2M6IFwiTGEgZnVuY2nDs24gRGlyZWNjacOzbiBldWNsaWRpYW5hIGhhY2lhIGF0csOhcyByZXN1bHRhIGVuIHVuIHLDoXN0ZXIgZGUgcHVudG8gZmxvdGFudGUgY29udGludW8gcXVlIHJlcHJlc2VudGEgbGEgZGlyZWNjacOzbiBlbiBncmFkb3MgZGUgdnVlbHRhIGFsIG9yaWdlbiBtw6FzIGNlcmNhbm8gYSBsYSB2ZXogcXVlIHNlIGV2aXRhbiBsYXMgYmFycmVyYXMsIHNpIHNlIHByb3BvcmNpb25hbi48ZGl2Pjxici8+TGFzIGVudHJhZGFzIGRlIERpcmVjY2nDs24gZXVjbGlkaWFuYSBoYWNpYSBhdHLDoXMgc29uIGVsIG9yaWdlbiBwYXJhIGVsIHF1ZSBzZSBjYWxjdWxhcsOhIGxhIGRpcmVjY2nDs24uIFVuYSBlbnRyYWRhIG9wY2lvbmFsIGVzIHVuIHLDoXN0ZXIgcXVlIHJlcHJlc2VudGEgYmFycmVyYXMgZGVudHJvIGRlbCDDoXJlYSBkZSBlc3R1ZGlvLiBQYXJhIGVsIHLDoXN0ZXIgZGUgb3JpZ2VuIHkgZWwgcsOhc3RlciBkZSBiYXJyZXJhLCBlbCB2YWxvciBkZSBmb25kbyBkZWJlcsOtYSBzZXIgTm9EYXRhLCBtaWVudHJhcyBxdWUgbG9zIG9yw61nZW5lcyB5IGxhcyBiYXJyZXJhcyBzZSByZXByZXNlbnRhbiBjb24gdmFsb3JlcyB2w6FsaWRvcy4gRW50cmUgbG9zIHZhbG9yZXMgdsOhbGlkb3Mgc2UgaW5jbHV5ZSBjZXJvLiBQb3IgZGVmZWN0bywgZWwgY8OhbGN1bG8gc2UgcHJvY2VzYXLDoSBhIGxhIGV4dGVuc2nDs24gY29tYmluYWRhIGRlIGxvcyBvcsOtZ2VuZXMgeSBiYXJyZXJhcywgYWRlbcOhcyBkZSAyIGZpbGFzIHkgY29sdW1uYXMuIFNpIHNvbG8gc2UgbmVjZXNpdGEgZWwgYW7DoWxpc2lzIGRlbnRybyBkZSB1bmEgZGlzdGFuY2lhIGVzcGVjaWZpY2FkYSBkZSBsb3Mgb3LDrWdlbmVzLCBlbnRvbmNlcyBzZSBwdWVkZSB1c2FyIGVsIHBhcsOhbWV0cm8gRGlzdGFuY2lhIG3DoXhpbWEuIERpcmVjY2nDs24gZXVjbGlkaWFuYSBoYWNpYSBhdHLDoXMgYWRtaXRlIHVuIG3DqXRvZG8gcGxhbmFyIHkgdW4gbcOpdG9kbyBnZW9kw6lzaWNvIGVuIGVsIGPDoWxjdWxvLiBFbCBjw6FsY3VsbyBkZWwgbcOpdG9kbyBwbGFuYXIgc2UgcmVhbGl6YXLDoSBlbiB1biBwbGFubyBsbGFubyBwcm95ZWN0YWRvIGNvbiB1biBzaXN0ZW1hIGRlIGNvb3JkZW5hZGFzIGNhcnRlc2lhbmFzIDJELiBFbCBjw6FsY3VsbyBkZWwgbcOpdG9kbyBnZW9kw6lzaWNvIHNlIHJlYWxpemFyw6EgZW4gZWwgZWxpcHNvaWRlLCBsbyBxdWUgc2lnbmlmaWNhIHF1ZSwgaW5kZXBlbmRpZW50ZW1lbnRlIGRlIGxhIHByb3llY2Npw7NuIGRlIGVudHJhZGEgbyBzYWxpZGEsIGxvcyByZXN1bHRhZG9zIG5vIGNhbWJpYW4uPGRpdj48YnIvPkVsIHJlc3VsdGFkbyBkZSBsYSBmdW5jacOzbiBEaXJlY2Npw7NuIGV1Y2xpZGlhbmEgaGFjaWEgYXRyw6FzIHNlIHB1ZWRlIHV0aWxpemFyIGp1bnRvIGNvbiBlbCByZXN1bHRhZG8gZGUgbGEgZnVuY2nDs24gRGlzdGFuY2lhIGV1Y2xpZGlhbmEgcGFyYSBkZXRlcm1pbmFyIGxhcyBydXRhcyBtw6FzIGNvcnRhcyBkZSBsYXMgdWJpY2FjaW9uZXMgZGVudHJvIGRlbCDDoXJlYSBkZSBlc3R1ZGlvIGhhc3RhIGVsIG9yaWdlbi4gRWwgcmVzdWx0YWRvIGRlIERpcmVjY2nDs24gZXVjbGlkaWFuYSBoYWNpYSBhdHLDoXMgeSBlbCByZXN1bHRhZG8gZGUgRGlzdGFuY2lhIGV1Y2xpZGlhbmEgc2UgdXRpbGl6YW4gZW4gbGEgZnVuY2nDs24gUnV0YSBkZSBjb3N0ZSBqdW50byBjb24gZGVzdGlub3MgcGFyYSBnZW5lcmFyIGxhcyBydXRhcyBtw6FzIGNvcnRhcy48L2Rpdj5cIixcblx0XHRleHBhbmROYW1lOiBcIkV4cGFuZGlyXCIsXG5cdFx0ZXhwYW5kU25pcDogXCJFeHBhbmRlIGxhcyB6b25hcyBzZWxlY2Npb25hZGFzIGRlIHVuIHLDoXN0ZXIgcG9yIHpvbmFzIGVuIHVuYSBjYW50aWRhZCBlc3BlY2lmaWNhZGEgZGUgY2VsZGFzLlwiLFxuXHRcdGV4cGFuZERlc2M6IFwiQ29uIGxhIGZ1bmNpw7NuIGdsb2JhbCBFeHBhbmRpciwgcHVlZGUgZ2VuZXJhbGl6YXIsIG8gc2ltcGxpZmljYXIsIHLDoXN0ZXJlcyBoYWNpZW5kbyBtw6FzIGdyYW5kZXMgZGV0ZXJtaW5hZGFzIHpvbmFzLiBUYW1iacOpbiBwdWVkZSBjb250cm9sYXIgbGEgY2FudGlkYWQgZGUgZ2VuZXJhbGl6YWNpw7NuIHF1ZSBzZSBwcm9kdWNpcsOhLjxkaXY+PGJyLz5MYXMgem9uYXMgcXVlIHNlbGVjY2lvbmUgc2UgaW5jcmVtZW50YXLDoW4gZW4gdGFtYcOxbyBleHBhbmRpw6luZG9zZSBhIG90cmFzIHpvbmFzLiBDb25jZXB0dWFsbWVudGUsIHB1ZWRlIHZpc3VhbGl6YXIgbG9zIFZhbG9yZXMgZGUgem9uYSBzZWxlY2Npb25hZG9zIGNvbW8gem9uYXMgZW4gcHJpbWVyIHBsYW5vLCBtaWVudHJhcyBxdWUgZWwgcmVzdG8gZGUgdmFsb3JlcyBwZXJtYW5lY2VuIGVuIHpvbmFzIGVuIHNlZ3VuZG8gcGxhbm8uIExhcyB6b25hcyBlbiBwcmltZXIgcGxhbm8gc2UgcHVlZGVuIGV4cGFuZGlyIGVuIHpvbmFzIGVuIHNlZ3VuZG8gcGxhbm8uPGRpdj48YnIvPkVzIHBvc2libGUgY29udHJvbGFyIGxhIGNhbnRpZGFkIGRlIGdlbmVyYWxpemFjacOzbiBjb24gZWwgcGFyw6FtZXRybyBOw7ptZXJvIGRlIGNlbGRhcy4gRGUgbWFuZXJhIHByZWRldGVybWluYWRhLCBlc3RlIHZhbG9yIGVzIDEsIHF1ZSBzaWduaWZpY2EgcXVlIGxhcyB6b25hcyBzZWxlY2Npb25hZGFzIHNlIGV4cGFuZGlyw6FuIHNlZ8O6biBsYSBjYW50aWRhZCBxdWUgY29ycmVzcG9uZGEgYWwgdGFtYcOxbyBkZSB1bmEgY2VsZGEuIFBhcmEgYXVtZW50YXIgZWwgZ3JhZG8gZGUgZ2VuZXJhbGl6YWNpw7NuLCBwdWVkZSBlc3BlY2lmaWNhciB1biB2YWxvciBtYXlvciBwYXJhIGVzdGUgcGFyw6FtZXRyby4gQ29uY2VwdHVhbG1lbnRlLCBlcyBjb21vIGVqZWN1dGFyIGxhIGhlcnJhbWllbnRhIHRhbnRhcyB2ZWNlcyBjb21vIGVsIG7Dum1lcm8gZXNwZWNpZmljYWRvLCBzaWVuZG8gbG9zIHJlc3VsdGFkb3MgZGUgbGEgZWplY3VjacOzbiBhbnRlcmlvciBsYSBlbnRyYWRhIGEgbGEgaXRlcmFjacOzbiBzdWJzaWd1aWVudGUuPC9kaXY+XCIsXG5cdFx0dHJlbmRBbmFseXNpc05hbWU6IFwiR2VuZXJhciB0ZW5kZW5jaWFcIixcblx0XHR0cmVuZEFuYWx5c2lzU25pcDogXCJFc3RpbWEgbGEgdGVuZGVuY2lhIGRlIGNhZGEgcMOteGVsIGEgbG8gbGFyZ28gZGUgdW5hIGRpbWVuc2nDs24gcGFyYSB1bmEgbyB2YXJpYXMgdmFyaWFibGVzIGRlIHVuIHLDoXN0ZXIgbXVsdGlkaW1lbnNpb25hbC5cIixcblx0XHR0cmVuZEFuYWx5c2lzRGVzYzogXCI8ZGl2PkVzdGEgZnVuY2nDs24gc2UgcHVlZGUgdXRpbGl6YXIgcGFyYSBhanVzdGFyIGRhdG9zIGEgbG8gbGFyZ28gZGUgdW5hIGzDrW5lYSBkZSB0ZW5kZW5jaWEgbGluZWFsLCBhcm3Ds25pY2EgbyBwb2xpbsOzbWljYSwgbyBzZSBwdWVkZSB1dGlsaXphciBwYXJhIHJlYWxpemFyIGxhIGRldGVjY2nDs24gZGUgdGVuZGVuY2lhcyB1dGlsaXphbmRvIGxhIHBydWViYSBkZSBNYW5uLUtlbmRhbGwgbyBTZWFzb25hbC1LZW5kYWxsLjwvZGl2Pjxicj48ZGl2PkVsIHLDoXN0ZXIgZGUgdGVuZGVuY2lhIGRlIHNhbGlkYSBnZW5lcmFkbyBjb24gZXN0YSBmdW5jacOzbiBzZSB1dGlsaXphIGNvbW8gZW50cmFkYSBwYXJhIGxhIGZ1bmNpw7NuIDxzdHJvbmc+UHJlZGVjaXIgY29uIHRlbmRlbmNpYTwvc3Ryb25nPi48L2Rpdj48YnI+PGRpdj5MYXMgcHJ1ZWJhcyBkZSBNYW5uLUtlbmRhbGwgeSBTZWFzb25hbC1LZW5kYWxsIHNlIHV0aWxpemFuIHBhcmEgZGV0ZXJtaW5hciBzaSBleGlzdGUgdW5hIHRlbmRlbmNpYSBtb25vdMOzbmljYSBlbiBsb3MgZGF0b3MuIFNvbiBubyBwYXJhbcOpdHJpY29zLCBsbyBxdWUgc2lnbmlmaWNhIHF1ZSBubyBhc3VtZW4gdW5hIGRpc3RyaWJ1Y2nDs24gZXNwZWPDrWZpY2EgZGUgbG9zIGRhdG9zLiBMYSBwcnVlYmEgTWFubi1LZW5kYWxsIG5vIGNvbnNpZGVyYSBsYSBjb3JyZWxhY2nDs24gZGUgc2VyaWUgbyBsb3MgZWZlY3RvcyBlc3RhY2lvbmFsZXMuIFNpIGxvcyBkYXRvcyBzb24gZXN0YWNpb25hbGVzLCBsYSBwcnVlYmEgZGUgU2Vhc29uYWwtS2VuZGFsbCBlcyBtw6FzIGFwcm9waWFkYS48L2Rpdj48YnI+PGRpdj5TaSBsYSBoZXJyYW1pZW50YSBzZSB1dGlsaXphIHBhcmEgcmVhbGl6YXIgbGEgcHJ1ZWJhIGRlIE1hbm4tS2VuZGFsbCBvIFNlYXNvbmFsLUtlbmRhbGwsIGxhIHNhbGlkYSBlcyB1biByw6FzdGVyIGRlIGNpbmNvIGJhbmRhcyBjb24gbGEgc2lndWllbnRlIGluZm9ybWFjacOzbjo8L2Rpdj48dWw+PGxpPkJhbmRhIDEgPSBCYW5kYSBkZSBwZW5kaWVudGUgZGUgU2VuPC9saT48bGk+QmFuZGEgMiA9IHZhbG9yIFA8L2xpPjxsaT5CYW5kYSAzID0gUHVudHVhY2nDs24gZGUgTWFubi1LZW5kYWxsIChTKTwvbGk+PGxpPkJhbmRhIDQgPSBWYXJpYW56YSBTPC9saT48bGk+PC9saT48bGk+QmFuZGEgNSA9IFB1bnR1YWNpw7NuIFo8L2xpPjwvdWw+PGRpdj5MYXMgc2FsaWRhcyBkZSBsYXMgcHJ1ZWJhcyBNYW5uLUtlbmRhbGwgbyBTZWFzb25hbC1LZW5kYWxsIHNlIHB1ZWRlbiB1c2FyIHBhcmEgZGV0ZXJtaW5hciBxdcOpIHDDrXhlbGVzIGRlIHN1IHNlcmllIHRlbXBvcmFsIG11bHRpZGltZW5zaW9uYWwgcHJlc2VudGFuIHVuYSB0ZW5kZW5jaWEgZXN0YWTDrXN0aWNhbWVudGUgc2lnbmlmaWNhdGl2YS4gUHVlZGUgdXRpbGl6YXIgZXN0YSBpbmZvcm1hY2nDs24ganVudG8gY29uIGVsIGFuw6FsaXNpcyBkZSB0ZW5kZW5jaWEgbGluZWFsLCBhcm3Ds25pY2EgbyBwb2xpbsOzbWljYSBwYXJhIGV4dHJhZXIgdGVuZGVuY2lhcyBzaWduaWZpY2F0aXZhcyBlbiBzdSBzZXJpZSB0ZW1wb3JhbC4gUHVlZGUgZ2VuZXJhciB1bmEgbcOhc2NhcmEgcXVlIGluY2x1eWEgcMOteGVsZXMgY29uIHZhbG9yZXMgcCBzaWduaWZpY2F0aXZvcywgYXBsaWNhciBsYSBtw6FzY2FyYSBhbCByw6FzdGVyIG11bHRpZGltZW5zaW9uYWwgeSB1dGlsaXphciBlc3RlIHLDoXN0ZXIgbXVsdGlkaW1lbnNpb25hbCBlbm1hc2NhcmFkbyBjb21vIGVudHJhZGEgZGUgbGEgaGVycmFtaWVudGEgcGFyYSByZWFsaXphciB1biBhbsOhbGlzaXMgZGUgdGVuZGVuY2lhIGxpbmVhbCwgbW9ub3TDs25pY2EgbyBwb2xpbsOzbWljYS48L2Rpdj48YnI+PGRpdj5FeGlzdGVuIHRyZXMgb3BjaW9uZXMgZGUgbMOtbmVhIGRlIHRlbmRlbmNpYSBwYXJhIGFqdXN0YXIgdW5hIHRlbmRlbmNpYSBhIGxvcyB2YWxvcmVzIGRlIGxhIHZhcmlhYmxlIGEgbG8gbGFyZ28gZGUgdW5hIGRpbWVuc2nDs246IGxpbmVhbCwgcG9saW7Ds21pY2EgeSBhcm3Ds25pY2EuPC9kaXY+PGJyPjxkaXY+RW4gZWwgY2FzbyBkZWwgYW7DoWxpc2lzIGRlIHRlbmRlbmNpYSBsaW5lYWwsIGxhIHNhbGlkYSBlcyB1biByw6FzdGVyIGRlIHRyZXMgYmFuZGFzLCBkb25kZTo8L2Rpdj48dWw+PGxpPkJhbmRhIDEgPSBQZW5kaWVudGU8L2xpPjxsaT5CYW5kYSAyID0gSW50ZXJjZXB0YXI8L2xpPjxsaT5CYW5kYSAzID0gRXJyb3IgY3VhZHLDoXRpY28gbWVkaW8gKFJNU0UpIG8gZXJyb3IgYWxyZWRlZG9yIGRlIGxhIGzDrW5lYSBkZSBtZWpvciBhanVzdGU8L2xpPjwvdWw+PGRpdj5FbiBlbCBjYXNvIGRlbCBhbsOhbGlzaXMgZGUgdGVuZGVuY2lhIHBvbGluw7NtaWNhLCBlbCBuw7ptZXJvIGRlIGJhbmRhcyBkZSBsYSBzYWxpZGEgZGVwZW5kZSBkZWwgb3JkZW4gcG9saW7Ds21pY28uIFVuIGFqdXN0ZSBwb2xpbsOzbWljbyBkZSBzZWd1bmRvIG9yZGVuIHByb2R1Y2UgdW4gcsOhc3RlciBkZSBjdWF0cm8gYmFuZGFzLCBkb25kZTo8L2Rpdj48dWw+PGxpPkJhbmRhIDEgPSBQb2x5bm9taWFsXzI8L2xpPjxsaT5CYW5kYSAyID0gUG9seW5vbWlhbF8xPC9saT48bGk+QmFuZGEgMyA9IFBvbHlub21pYWxfMDwvbGk+PGxpPkJhbmRhIDQgPSBSTVNFPC9saT48L3VsPjxkaXY+VW4gYWp1c3RlIHBvbGluw7NtaWNvIGRlIHRlcmNlciBvcmRlbiBwcm9kdWNlIHVuIHLDoXN0ZXIgZGUgY2luY28gYmFuZGFzLCBkb25kZTo8L2Rpdj48dWw+PGxpPkJhbmRhIDEgPSBQb2x5bm9taWFsXzM8L2xpPjxsaT5CYW5kYSAyID0gUG9seW5vbWlhbF8yPC9saT48bGk+QmFuZGEgMyA9IFBvbHlub21pYWxfMTwvbGk+PGxpPkJhbmRhIDQgPSBQb2x5bm9taWFsXzA8L2xpPjxsaT5CYW5kYSA1ID0gUk1TRTwvbGk+PC91bD48ZGl2PkVuIGVsIGNhc28gZGVsIGFuw6FsaXNpcyBkZSB0ZW5kZW5jaWEgYXJtw7NuaWNvLCBlbCBuw7ptZXJvIGRlIGJhbmRhcyBkZSBsYSBzYWxpZGEgZGVwZW5kZSBkZSBsYSBmcmVjdWVuY2lhIGFybcOzbmljYS4gU2kgbGEgZnJlY3VlbmNpYSBzZSBlc3RhYmxlY2UgZW4gMSwgbGEgc2FsaWRhIHNlcsOhIHVuIHLDoXN0ZXIgZGUgY2luY28gYmFuZGFzLCBkb25kZTo8L2Rpdj48dWw+PGxpPkJhbmRhIDEgPSBQZW5kaWVudGU8L2xpPjxsaT5CYW5kYSAyID0gSW50ZXJjZXB0YXI8L2xpPjxsaT5CYW5kYSAzID0gSGFybW9uaWNfc2luMTwvbGk+PGxpPkJhbmRhIDQgPSBIYXJtb25pY19jb3MxPC9saT48bGk+QmFuZGEgNSA9IFJNU0U8L2xpPjwvdWw+PGRpdj5TaSBsYSBmcmVjdWVuY2lhIHNlIGVzdGFibGVjZSBlbiAyLCBsYSBzYWxpZGEgc2Vyw6EgdW4gcsOhc3RlciBkZSBzaWV0ZSBiYW5kYXMsIGRvbmRlOjo8L2Rpdj48dWw+PGxpPkJhbmRhIDEgPSBQZW5kaWVudGU8L2xpPjxsaT5CYW5kYSAyID0gSW50ZXJjZXB0YXI8L2xpPjxsaT5CYW5kYSAzID0gSGFybW9uaWNfc2luMTwvbGk+PGxpPkJhbmRhIDQgPSBIYXJtb25pY19jb3MxPC9saT48bGk+QmFuZGEgNSA9IEhhcm1vbmljX3NpbjI8L2xpPjxsaT5CYW5kYSA2ID0gSGFybW9uaWNfY29zMjwvbGk+PGxpPkJhbmRhIDcgPSBSTVNFPC9saT48L3VsPjxkaXY+RWwgcGFyw6FtZXRybyA8c3Ryb25nPkxvbmdpdHVkIGRlbCBjaWNsbzwvc3Ryb25nPiBkZWwgYW7DoWxpc2lzIGRlIHRlbmRlbmNpYSBhcm3Ds25pY28gc2UgdXRpbGl6YSBwYXJhIGluZGljYXIgZWwgbsO6bWVybyB5IGxvbmdpdHVkIGRlIGNpY2xvcyBxdWUgZXNwZXJhIHZlciBlbiBzdXMgZGF0b3MgYSBsbyBsYXJnbyBkZSB1biBkw61hIG8gYcOxby4gUG9yIGVqZW1wbG8sIHNpIGVzcGVyYSBxdWUgc3VzIGRhdG9zIHBhc2VuIGRvcyBjaWNsb3MgZGUgdmFyaWFjacOzbiBlbiB1biBhw7FvLCBsYSBsb25naXR1ZCBkZSBjaWNsbyBzZXLDoSAxODIsNSBkw61hcyBvIDAsNSBhw7Fvcy4gU2kgcmVjb3BpbGEgZGF0b3MgZGUgdGVtcGVyYXR1cmEgY2FkYSB0cmVzIGhvcmFzIHkgaGF5IHVuIGNpY2xvIGRlIHZhcmlhY2nDs24gYWwgZMOtYSwgbGEgbG9uZ2l0dWQgZGUgY2ljbG8gZXMgZGUgdW4gZMOtYS48L2Rpdj48YnI+PGRpdj5FbCBwYXLDoW1ldHJvIDxzdHJvbmc+RnJlY3VlbmNpYSBkZWwgYW7DoWxpc2lzPC9zdHJvbmc+IGRlIHRlbmRlbmNpYSBhcm3Ds25pY28gc2UgdXRpbGl6YSBwYXJhIGRlc2NyaWJpciBlbCBtb2RlbG8gYXJtw7NuaWNvIHF1ZSBzZSBhanVzdGFyw6EgYSBsb3MgZGF0b3MuIFNpIGxhIGZyZWN1ZW5jaWEgc2UgZGVmaW5lIGNvbW8gMSwgc2UgdXRpbGl6YXLDoSB1bmEgY29tYmluYWNpw7NuIGRlIGN1cnZhIGxpbmVhbCB5IGN1cnZhIGFybcOzbmljYSBkZSBwcmltZXIgb3JkZW4gcGFyYSBhanVzdGFyIGVsIG1vZGVsby4gU2kgbGEgZnJlY3VlbmNpYSBlcyAyLCBzZSB1dGlsaXphcsOhIHVuYSBjb21iaW5hY2nDs24gZGUgbGluZWFsLCBjdXJ2YSBhcm3Ds25pY2EgZGUgcHJpbWVyIG9yZGVuIHkgY3VydmEgYXJtw7NuaWNhIGRlIHNlZ3VuZG8gb3JkZW4gcGFyYSBhanVzdGFyIGxvcyBkYXRvcy4gU2kgbGEgZnJlY3VlbmNpYSBlcyAzLCBzZSB1dGlsaXphcsOhIHVuYSBjdXJ2YSBhcm3Ds25pY2EgYWRpY2lvbmFsIGRlIHRlcmNlciBvcmRlbiBwYXJhIG1vZGVsYXIgbG9zIGRhdG9zLCB5IGFzw60gc3VjZXNpdmFtZW50ZS48L2Rpdj48YnI+PGRpdj5TZSBwdWVkZW4gZ2VuZXJhciBlc3RhZMOtc3RpY2FzIGRlIGlkb25laWRhZCBkZSBhanVzdGUgZGVsIG1vZGVsbyBjb21vIHNhbGlkYXMgb3BjaW9uYWxlcy4gU2UgcHVlZGVuIGNhbGN1bGFyIHkgc2ltYm9saXphciBlbCBlcnJvciBjdWFkcsOhdGljbyBtZWRpbyAoUk1TRSksIFIgY3VhZHJhZG8geSBlbCB2YWxvciBQIGRlIHBlbmRpZW50ZSBkZSB0ZW5kZW5jaWEuIFNpbWJvbGljZSBsYSBjYXBhIHLDoXN0ZXIgZGUgdGVuZGVuY2lhIGRlIHNhbGlkYSBtZWRpYW50ZSBsYSBzaW1ib2xvZ8OtYSA8c3Ryb25nPlJHQjwvc3Ryb25nPiB5IGVzcGVjaWZpcXVlIGxhcyBlc3RhZMOtc3RpY2FzIGNvbW8gbGFzIGJhbmRhcyByb2phLCB2ZXJkZSB5IGF6dWwuPC9kaXY+PGJyPlwiLFxuXHRcdHNwZWN0cmFsVW5taXhpbmdOYW1lOiBcIkVzcGVjdHJhbCBsaW5lYWwgc2luIG1lemNsYXNcIixcblx0XHRzcGVjdHJhbFVubWl4aW5nU25pcDogXCJSZWFsaXphIGxhIGNsYXNpZmljYWNpw7NuIHBvciBzdWJww614ZWxlcyB5IGNhbGN1bGEgbGEgYWJ1bmRhbmNpYSBmcmFjY2lvbmFyaWEgZGUgbG9zIGRpZmVyZW50ZXMgdGlwb3MgZGUgY29iZXJ0dXJhIGRlIHN1ZWxvIGRlIGxvcyBww614ZWxlcyBpbmRpdmlkdWFsZXMuXCIsXG5cdFx0c3BlY3RyYWxVbm1peGluZ0Rlc2M6IFwiTGEgZnVuY2nDs24gRXNwZWN0cmFsIGxpbmVhbCBzaW4gbWV6Y2xhcyBjYWxjdWxhIGxhIGNvYmVydHVyYSBmcmFjY2lvbmFsIGRlIHDDrXhlbGVzIGluZGl2aWR1YWxlcyBxdWUgY29udGllbmVuIHZhcmlvcyB0aXBvcyBkZSBjb2JlcnR1cmEgZGUgc3VlbG8uIEdlbmVyYSB1bmEgY2FwYSBtdWx0aWJhbmRhLCBkb25kZSBjYWRhIGJhbmRhIGNvcnJlc3BvbmRlIGEgbGEgYWJ1bmRhbmNpYSBmcmFjY2lvbmFsIGRlIGNhZGEgY2xhc2UgZGUgY29iZXJ0dXJhIGRlIHN1ZWxvLiBQb3IgZWplbXBsbywgcHVlZGUgdXRpbGl6YXJsYSBwYXJhIHJlYWxpemFyIGxhIGNsYXNpZmljYWNpw7NuIGRlIGxhIGNvYmVydHVyYSBkZSBzdWVsbyBlbiB1bmEgaW1hZ2VuIG11bHRpZXNwZWN0cmFsIHBhcmEgaWRlbnRpZmljYXIgbGEgdmVnZXRhY2nDs24gZm90b3NpbnTDqXRpY2EsIGVsIHN1ZWxvIGRlc251ZG8geSB2ZWdldGFjacOzbiBtdWVydGEgbyBubyBmb3Rvc2ludMOpdGljYS48ZGl2Pjxici8+RWwgb3JkZW4gZGVsIHLDoXN0ZXIgbXVsdGliYW5kYSBkZSBzYWxpZGEgc2lndWUgZWwgb3JkZW4gZGVsIHBlcmZpbCBlc3BlY3RyYWwgZGUgZW50cmFkYS4gRWwgbsO6bWVybyBkZSBjbGFzZXMgbm8gcHVlZGUgc2VyIG1heW9yIHF1ZSBlbCBuw7ptZXJvIGRlIGJhbmRhcyBkZWwgcsOhc3RlciBkZSBlbnRyYWRhLiBQb3IgZWplbXBsbywgbm8gcHVlZGUgZXh0cmFlciBpbmZvcm1hY2nDs24gc29icmUgbcOhcyBkZSA4IGNsYXNlcyBkZSB1biByw6FzdGVyIGRlIDggYmFuZGFzLjwvZGl2PlwiLFxuXHRcdG11bHRpZGltZW5zaW9uYWxGaWx0ZXJOYW1lOiBcIkZpbHRybyBtdWx0aWRpbWVuc2lvbmFsXCIsXG5cdFx0aW50ZXJwb2xhdGVSYXN0ZXJCeURpbWVuc2lvbkZ1bmN0aW9uTmFtZTogXCJJbnRlcnBvbGFyIHLDoXN0ZXIgcG9yIGRpbWVuc2nDs25cIixcblx0XHRpbnRlcnBvbGF0ZVJhc3RlckJ5RGltZW5zaW9uRnVuY3Rpb25TbmlwOiBcIkludGVycG9sYSB1biByw6FzdGVyIG11bHRpZGltZW5zaW9uYWwgY29uIHZhbG9yZXMgZGUgZGltZW5zacOzbiBlc3BlY2lmaWNhZG9zIHVzYW5kbyBwb3JjaW9uZXMgYWR5YWNlbnRlcy5cIixcblx0XHRpbnRlcnBvbGF0ZVJhc3RlckJ5RGltZW5zaW9uRnVuY3Rpb25EZXNjOiBcIjxwPkVzdGEgZnVuY2nDs24gbGUgcGVybWl0ZSBlc3RpbWFyIGxvcyB2YWxvcmVzIGRlIHDDrXhlbCBkZSB1bmEgZGl2aXNpw7NuIGRlIGRpbWVuc2nDs24gbm8gZGVmaW5pZGEgZW4gdW4gcsOhc3RlciBtdWx0aWRpbWVuc2lvbmFsLiBQb3IgZWplbXBsbywgc2kgdGllbmUgdW4gZGF0YXNldCBxdWUgY29udGllbmUgbGEgdGVtcGVyYXR1cmEgZGVsIG9jw6lhbm8gZW4gZWwgbml2ZWwgZGUgbGEgc3VwZXJmaWNpZSB5IGEgMTAwIG1ldHJvcyBwb3IgZGViYWpvIGRlbCBuaXZlbCBkZWwgbWFyIHkgZGVzZWEgZXN0aW1hciBsYSB0ZW1wZXJhdHVyYSBhIDUwIG1ldHJvcyBwb3IgZGViYWpvIGRlbCBuaXZlbCBkZWwgbWFyLCBwdWVkZSB1dGlsaXphciBlc3RhIGZ1bmNpw7NuIHBhcmEgb2J0ZW5lciB1bmEgZXN0aW1hY2nDs24gZGUgZXNhIHByb2Z1bmRpZGFkIG1lZGlhbnRlIGxhIGRlZmluaWNpw7NuIGRlIGRpbWVuc2nDs24gUG9yIHZhbG9yZXMuPC9wPjxwPlRhbWJpw6luIHB1ZWRlIHJlZHVjaXIgZWwgdGFtYcOxbyBkZSB1biBkYXRhc2UgbWVuc3VhbCBhbCBkZSB1biBkYXRhc2V0IGRpYXJpbyB1dGlsaXphbmRvIGxhIGRlZmluaWNpw7NuIGRlIGxhIGRpbWVuc2nDs24gUG9yIGludGVydmFsbyB5IGVzcGVjaWZpY2FuZG8gZWwgdmFsb3IgZGVsIHBhcsOhbWV0cm8gUGFzbyBjb21vIDEgeSBlbCB2YWxvciBkZWwgcGFyw6FtZXRybyBVbmlkYWQgY29tbyBEw61hcy48L3A+PHA+VXRpbGljZSBsYSBkZWZpbmljacOzbiBkZSBkaW1lbnNpw7NuIFBvciByw6FzdGVyIGRlIGRlc3Rpbm8gcGFyYSBlc3RpbWFyIGVsIHZhbG9yIGRlbCByw6FzdGVyIGRlIGRlc3Rpbm8uPC9wPlwiLFxuXHRcdG11bHRpZGltZW5zaW9uYWxGaWx0ZXJTbmlwOiBcIkNyZWEgdW5hIGNhcGEgcsOhc3RlciBhIHBhcnRpciBkZSB1biBkYXRhc2V0IHLDoXN0ZXIgbXVsdGlkaW1lbnNpb25hbCBvIHVuYSBjYXBhIHLDoXN0ZXIgbXVsdGlkaW1lbnNpb25hbCBkaXZpZGllbmRvIGxvcyBkYXRvcyBlbiB2YXJpYWJsZXMgeSBkaW1lbnNpb25lcyBkZWZpbmlkYXMuXCIsXG5cdFx0bXVsdGlkaW1lbnNpb25hbEZpbHRlckRlc2M6IFwiRmlsdHJvIG11bHRpZGltZW5zaW9uYWwgY3JlYSB1bmEgY2FwYSByw6FzdGVyIG11bHRpZGltZW5zaW9uYWwgZmlsdHJhbmRvIHkgZXh0cmF5ZW5kbyB1biBzdWJjb25qdW50byBkZSB2YXJpYWJsZXMgZGUgdW4gcsOhc3RlciBtdWx0aWRpbWVuc2lvbmFsLiBQb3IgZWplbXBsbywgdGllbmUgdW4gZGF0YXNldCBtdWx0aWRpbWVuc2lvbmFsIGNvbiAzMCBhw7FvcyBkZSBkYXRvcyBkZSBwcmVjaXBpdGFjaW9uZXMgbWVuc3VhbGVzLCB5IHNvbG8gZGVzZWEgZXh0cmFlciBkYXRvcyBkZSBjYWRhIGVuZXJvIHBhcmEgdmVyIGPDs21vIGhhbiBjYW1iaWFkbyBsYXMgcHJlY2lwaXRhY2lvbmVzIGVzZSBtZXMuPGRpdj48YnIvPlVzZSBlbCBwYXLDoW1ldHJvIERlZmluaWNpw7NuIGRlIGRpbWVuc2nDs24gcGFyYSBkaXZpZGlyIGxhcyBkaW1lbnNpb25lcyBwb3IgdW4gaW50ZXJ2YWxvLCB1biB2YWxvciBvIHVuIHJhbmdvIGRlIHZhbG9yZXMuIFBvciBlamVtcGxvLCBzaSBjdWVudGEgY29uIDEwIGHDsW9zIGRlIGRhdG9zIGRlIHNhbGluaWRhZCBkZWwgb2PDqWFubyBxdWUgc2UgaGFuIHJlY29waWxhZG8gbWVuc3VhbG1lbnRlIHkgYSBjYWRhIDIgbWV0cm9zIGRlIHByb2Z1bmRpZGFkIGhhc3RhIGxsZWdhciBhIGxvcyA1MDAgbWV0cm9zLCBwb2Ryw61hIHVzYXIgbGFzIGRpc3RpbnRhcyBvcGNpb25lcyBkZSBkZWZpbmljacOzbiBkZSBkaW1lbnNpw7NuIGVuIGxvcyBzaWd1aWVudGVzIGVzY2VuYXJpb3MuIEVzY2VuYXJpbyAxOiBleHRyYWVyIGxvcyBkYXRvcyBkZSBzYWxpbmlkYWQgcGFyYSBlbCBtZXMgZGUgZW5lcm8gZHVyYW50ZSBlbCBwZXLDrW9kbyBkZSAxMCBhw7Fvcy4gRWxpamEgUG9yIHZhbG9yZXMsIGNhbWJpZSBEaW1lbnNpw7NuIGEgU3RkVGltZSB5IGNhbWJpZSBWYWxvcmVzIGEgRW5lcm8uIEVzY2VuYXJpbyAyOiBkaXZpZGlyIGxvcyBkYXRvcyBkZSBzYWxpbmlkYWQgZW4gdW4gcmFuZ28gZGUgcHJvZnVuZGlkYWQgZGUgMCBhIDE1MCBtZXRyb3MuIEVsaWphIFBvciByYW5nb3MsIGNhbWJpZSBEaW1lbnNpw7NuIGEgU3RkWiB5IGNhbWJpZSBWYWxvciBtw61uaW1vIGEgLTE1MCB5IFZhbG9yIG3DoXhpbW8gYSAwLiBFc2NlbmFyaW8gMzogZXh0cmFlciBsb3MgZGF0b3MgZGUgc2FsaW5pZGFkIGRlIGxvcyBwcmltZXJvcyAxMCBkw61hcyBkZSBjYWRhIG1lcyBkZSBlbmVybyBkdXJhbnRlIHVuIHBlcsOtb2RvIGRlIDEwIGHDsW9zLiBFbGlqYSBQb3IgaXRlcmFjacOzbiwgY2FtYmllIERpbWVuc2nDs24gYSBTdGRUaW1lLCBjYW1iaWUgSW5pY2lvIGRlIGxhIHByaW1lcmEgaXRlcmFjacOzbiB5IEZpbiBkZSBsYSBwcmltZXJhIGl0ZXJhY2nDs24gcGFyYSBlbCBpbmljaW8geSBlbCBmaW4gY29ycmVzcG9uZGllbnRlcyBkZWwgcGVyaW9kbyBkZSBpdGVyYWNpw7NuLCBjYW1iaWUgUGFzbyBhIDEgeSBjYW1iaWUgVW5pZGFkIGEgQcOxb3MuPC9kaXY+XCIsXG5cdFx0bXVsdGlkaW1lbnNpb25hbFJhc3Rlck5hbWU6IFwiUsOhc3RlciBtdWx0aWRpbWVuc2lvbmFsXCIsXG5cdFx0bXVsdGlkaW1lbnNpb25hbFJhc3RlclNuaXA6IFwiQWdyZWdhIGRhdG9zIG11bHRpZGltZW5zaW9uYWxlcyBhIHVuIG1hcGEgY29tbyBjYXBhIHLDoXN0ZXIgbXVsdGlkaW1lbnNpb25hbC5cIixcblx0XHRtdWx0aWRpbWVuc2lvbmFsUmFzdGVyRGVzYzogXCJMYSBmdW5jacOzbiBSw6FzdGVyIG11bHRpZGltZW5zaW9uYWwgYWdyZWdhIGRhdG9zIG11bHRpZGltZW5zaW9uYWxlcyBhIHVuIG1hcGEgY29tbyBjYXBhIHLDoXN0ZXIgbXVsdGlkaW1lbnNpb25hbC4gRXN0YSBmdW5jacOzbiByZXN1bHRhIMO6dGlsIGFsIHJlYWxpemFyIGZsdWpvcyBkZSB0cmFiYWpvIGRlIGFuw6FsaXNpcyBkZSByw6FzdGVyIGNvbiB1bmEgY2FkZW5hIGRlIGZ1bmNpb25lcy48ZGl2Pjxici8+RW50cmUgbG9zIGRhdGFzZXRzIHLDoXN0ZXIgbXVsdGlkaW1lbnNpb25hbGVzIGFkbWl0aWRvcyBzZSBlbmN1ZW50cmFuIG5ldENERiwgR1JJQiwgSERGIHkgQ1JGIGRlIEVzcmkuIFRhbWJpw6luIHNlIGFkbWl0ZW4gZGF0YXNldHMgZGUgbW9zYWljbyBtdWx0aWRpbWVuc2lvbmFsZXMuPC9kaXY+XCIsXG5cdFx0b3B0aW1hbFBhdGhBc1Jhc3Rlck5hbWU6IFwiUnV0YSDDs3B0aW1hIGNvbW8gcsOhc3RlclwiLFxuXHRcdG9wdGltYWxQYXRoQXNSYXN0ZXJTbmlwOiBcIkNhbGN1bGEgbGEgcnV0YSBkZSBtZW5vciBjb3N0ZSBkZXNkZSB1biBvcmlnZW4gYSBzdSBkZXN0aW5vLlwiLFxuXHRcdG9wdGltYWxQYXRoQXNSYXN0ZXJEZXNjOiBcIkVzdGEgZnVuY2nDs24gZ2xvYmFsIHByb2R1Y2UgdW4gcsOhc3RlciBkZSBzYWxpZGEgcXVlIHJlZ2lzdHJhIGxhIHJ1dGEgbyBsYXMgcnV0YXMgw7NwdGltYXMgZGVzZGUgbGFzIHViaWNhY2lvbmVzIHNlbGVjY2lvbmFkYXMgaGFzdGEgbGEgY2VsZGEgZGUgb3JpZ2VuIG3DoXMgY2VyY2FuYSBkZWZpbmlkYSBkZW50cm8gZGUgbGEgc3VwZXJmaWNpZSBkZSBjb3N0ZSBhY3VtdWxhdGl2bywgZW4gdMOpcm1pbm9zIGRlIGNvc3RlLWRpc3RhbmNpYS48ZGl2Pjxici8+RW4gZ2VuZXJhbCwgc2UgcmVxdWllcmUgcXVlIHNlIGVqZWN1dGVuIHVuYSBvIHZhcmlhcyBkZSBsYXMgZnVuY2lvbmVzIGRlIGNvc3RlIHBvbmRlcmFkbyAoQWN1bXVsYWNpw7NuIGRlIGRpc3RhbmNpYSBvIEFzaWduYWNpw7NuIGRlIGRpc3RhbmNpYSkgYW50ZXMgZGUgZWplY3V0YXIgbGEgZnVuY2nDs24gUnV0YSDDs3B0aW1hIGNvbW8gcsOhc3RlciBwYXJhIGNyZWFyIGxvcyByw6FzdGVyZXMgZGUgYWN1bXVsYWNpw7NuIGRlIGRpc3RhbmNpYSBkZSBlbnRyYWRhIHkgZGlyZWNjacOzbiBoYWNpYSBhdHLDoXMuIFNvbiBjYXBhcyByw6FzdGVyIGRlIGVudHJhZGEgb2JsaWdhdG9yaWFzIHBhcmEgbGEgZnVuY2nDs24gUnV0YSDDs3B0aW1hLiBMb3MgdmFsb3JlcyBkZSBsYSBydXRhIMOzcHRpbWEgZGUgc2FsaWRhIHJlcHJlc2VudGFuIGVsIG7Dum1lcm8gZGUgcnV0YXMgZW4gdW5hIHViaWNhY2nDs24gZGV0ZXJtaW5hZGEuIEVuIG11Y2hvcyBjYXNvcywgbGFzIHbDrWFzIHNpZ3VlbiBsYXMgbWlzbWFzIHJ1dGFzLCBhYmFuZG9uYW4gdW4gb3JpZ2VuIHkgZGl2ZXJnZW4gcGFyYSBpciBhIGRlc3Rpbm9zIGRpZmVyZW50ZXMuIFBvciBlamVtcGxvLCB1biB2YWxvciBkZSB1bm8gaW5kaWNhIHF1ZSBzb2xvIGhheSB1bmEgcnV0YSDDs3B0aW1hIGVuIHVuYSB1YmljYWNpw7NuIGRldGVybWluYWRhLCBtaWVudHJhcyBxdWUgdW4gdmFsb3IgZGUgY2luY28gc2lnbmlmaWNhIHF1ZSBoYXkgY2luY28gcnV0YXMgw7NwdGltYXMgZW4gbGEgdWJpY2FjacOzbiBxdWUgYXRyYXZpZXNhbiBlc2EgY2VsZGEgZW4gZWwgw6FyZWEgZGUgZXN0dWRpby48ZGl2Pjxici8+TG9zIGRhdG9zIGRlIGRlc3Rpbm8gZGUgZW50cmFkYSBkZWJlbiBzZXIgdW5hIGNhcGEgcsOhc3Rlci4gRWwgY29uanVudG8gZGUgY2VsZGFzIGRlIGRlc3Rpbm8gc29uIHRvZGFzIGxhcyBjZWxkYXMgZGVsIHLDoXN0ZXIgZGUgZW50cmFkYSBjb24gdmFsb3JlcyB2w6FsaWRvcy4gTGFzIGNlbGRhcyBzaW4gdmFsb3JlcyBOb0RhdGEgbm8gc2UgaW5jbHV5ZW4gZW4gZWwgY29uanVudG8uIEVsIHZhbG9yIGNlcm8gc2UgY29uc2lkZXJhIHVuIGRlc3Rpbm8gbGVnw610aW1vLiBTZSBwdWVkZSBjcmVhciB1biByw6FzdGVyIGRlIGRlc3Rpbm8gY29uIGxhcyBoZXJyYW1pZW50YXMgZGUgZXh0cmFjY2nDs24uIFNpIHRpZW5lIGVudGlkYWRlcyBkZSBvcmlnZW4gbyBkZXN0aW5vLCBwdWVkZSBjb252ZXJ0aXJsYXMgYSByw6FzdGVyIGNvbiBsYSBmdW5jacOzbiBSYXN0ZXJpemFyIGVudGlkYWRlcy4gVXNlIGVsIHLDoXN0ZXIgZGUgYWN1bXVsYWNpw7NuIGRlIGRpc3RhbmNpYSBvIGRpcmVjY2nDs24gaGFjaWEgYXRyw6FzIGNvbW8gZW50cmFkYSBkZWwgcsOhc3RlciBwYXJhIGxhIGZ1bmNpw7NuIGRlIHJhc3Rlcml6YWNpw7NuLiBEZSBlc3RhIG1hbmVyYSwgc2UgZ2FyYW50aXphIHF1ZSBsYSBlbnRpZGFkIHNlIHJhc3RlcmljZSBjb24gbG9zIG1pc21vcyB2YWxvcmVzIGRlIHRhbWHDsW8gZGUgY2VsZGEsIGV4dGVuc2nDs24geSByZWZlcmVuY2lhIGVzcGFjaWFsIHF1ZSBlbCByZXN0byBkZSByw6FzdGVyZXMgZGUgbGEgZnVuY2nDs24gUnV0YSDDs3B0aW1hIGNvbW8gcsOhc3Rlci4gTGEgZnVuY2nDs24gUnV0YSDDs3B0aW1hIGNvbW8gcsOhc3RlciB0YW1iacOpbiBzZSBwdWVkZSB1dGlsaXphciBwYXJhIGRlcml2YXIgbGEgcnV0YSBkZSBtZW5vciByZXNpc3RlbmNpYSBhIHVuIG1vZGVsbyBkaWdpdGFsIGRlIGVsZXZhY2nDs24gKERFTSkuIEVuIGVzdGUgY2FzbywgdXRpbGljZSBlbCBERU0gcGFyYSBlbCByw6FzdGVyIGRlIGFjdW11bGFjacOzbiBkZSBkaXN0YW5jaWEgZGUgZW50cmFkYSB5IGxhIHNhbGlkYSBkZSBsYSBmdW5jacOzbiBEaXJlY2Npw7NuIGRlIGZsdWpvIHBhcmEgZWwgcsOhc3RlciBkZSBkaXJlY2Npw7NuIGhhY2lhIGF0csOhcy48L2Rpdj5cIixcblx0XHR0cmVuZE5hbWU6IFwiUHJlZGVjaXIgY29uIHRlbmRlbmNpYVwiLFxuXHRcdHRyZW5kU25pcDogXCJDYWxjdWxhIHVuYSBjYXBhIHLDoXN0ZXIgbXVsdGlkaW1lbnNpb25hbCBwcmV2aXN0YSB1dGlsaXphbmRvIGVsIHLDoXN0ZXIgZGUgdGVuZGVuY2lhIGRlIHNhbGlkYSBkZSBsYSBmdW5jacOzbiBHZW5lcmFyIHRlbmRlbmNpYSBvIGxhIGhlcnJhbWllbnRhIGRlIGdlb3Byb2Nlc2FtaWVudG8gR2VuZXJhciByw6FzdGVyIGRlIHRlbmRlbmNpYS5cIixcblx0XHR0cmVuZERlc2M6IFwiTGEgZnVuY2nDs24gUHJlZGVjaXIgY29uIHRlbmRlbmNpYSBjYWxjdWxhIHVuYSBjYXBhIHLDoXN0ZXIgbXVsdGlkaW1lbnNpb25hbCBwcmV2aXN0YSB1dGlsaXphbmRvIGVsIHLDoXN0ZXIgZGUgdGVuZGVuY2lhIGRlIHNhbGlkYSBkZSBsYSBmdW5jacOzbiBHZW5lcmFyIHRlbmRlbmNpYSBvIGxhIGhlcnJhbWllbnRhIGRlIGdlb3Byb2Nlc2FtaWVudG8gR2VuZXJhciByw6FzdGVyIGRlIHRlbmRlbmNpYS5cIixcblx0XHRyYXN0ZXJDb2xsZWN0aW9uTmFtZTogXCJQcm9jZXNhciBjb2xlY2Npw7NuIGRlIHLDoXN0ZXJlc1wiLFxuXHRcdHJhc3RlckNvbGxlY3Rpb25TbmlwOiBcIlByb2Nlc2EgY2FkYSBkaXZpc2nDs24gZGUgdW4gcsOhc3RlciBtdWx0aWRpbWVuc2lvbmFsIG8gY2FkYSBlbGVtZW50byBkZSB1biByw6FzdGVyIGRlIG1vc2FpY28uIEVzdGEgZnVuY2nDs24gdGFtYmnDqW4gcHVlZGUgYWdyZWdhciB2YXJpYXMgZGl2aXNpb25lcyBhIHVuYSDDum5pY2EgZGl2aXNpw7NuLlwiLFxuXHRcdHJhc3RlckNvbGxlY3Rpb25EZXNjOiBcIkxhIGZ1bmNpw7NuIFByb2Nlc2FyIGNvbGVjY2nDs24gZGUgcsOhc3RlcmVzIHByb2Nlc2EgY2FkYSBkaXZpc2nDs24gZGUgdW4gcsOhc3RlciBtdWx0aWRpbWVuc2lvbmFsIG8gY2FkYSBlbGVtZW50byBkZSB1biByw6FzdGVyIGRlIG1vc2FpY28uIEVzdGEgZnVuY2nDs24gdGFtYmnDqW4gcHVlZGUgYWdyZWdhciB2YXJpYXMgZGl2aXNpb25lcyBhIHVuYSDDum5pY2EgZGl2aXNpw7NuLjxkaXY+PGJyLz5Fc3RhIGZ1bmNpw7NuIHByb2Nlc2EgY2FkYSBkaXZpc2nDs24gZGUgdW4gcsOhc3RlciBtdWx0aWRpbWVuc2lvbmFsIG8gcsOhc3RlciBkZSBtb3NhaWNvIGNvbiB1bmEgcGxhbnRpbGxhIGRlIGZ1bmNpw7NuIHLDoXN0ZXIuIEVzdGEgZnVuY2nDs24gYWRtaXRlIGxhcyBzaWd1aWVudGVzIG9wY2lvbmVzOiAxLiBFc3BlY2lmaWNhciB1bmEgcGxhbnRpbGxhIGRlIGZ1bmNpw7NuIHLDoXN0ZXIgcGFyYSBsYSBGdW5jacOzbiBkZSBlbGVtZW50by4gUG9yIGVqZW1wbG8sIHRpZW5lIHVuIGRhdGFzZXQgZGUgbW9zYWljbyBjb24gMjAgYcOxb3MgZGUgaW3DoWdlbmVzIGRlIExhbmRzYXQgeSBkZXNlYSBjYWxjdWxhciBlbCBORFZJIHBhcmEgY2FkYSBlc2NlbmEgZGUgbGEgc2VyaWUgdGVtcG9yYWwuIEVuIEZ1bmNpw7NuIGRlIGVsZW1lbnRvLCBlc3BlY2lmaXF1ZSB1bmEgcGxhbnRpbGxhIGRlIGZ1bmNpw7NuIHLDoXN0ZXIgcXVlIGNvbnRlbmdhIGxhIGZ1bmNpw7NuIHLDoXN0ZXIgTkRWSS4gMi4gRXNwZWNpZmljYXIgdW5hIHBsYW50aWxsYSBkZSBmdW5jacOzbiByw6FzdGVyIHBhcmEgbGEgRnVuY2nDs24gZGUgYWdyZWdhY2nDs24uIFBvciBlamVtcGxvLCB0aWVuZSB1biByw6FzdGVyIG11bHRpZGltZW5zaW9uYWwgY29uIDEwIGHDsW9zIGRlIGRhdG9zIGRlIHRlbXBlcmF0dXJhIGRpYXJpb3MgeSBkZXNlYSBjYWxjdWxhciBsYSB0ZW1wZXJhdHVyYSBtw6F4aW1hIGRlIGNhZGEgYcOxby4gRW4gbGEgRnVuY2nDs24gZGUgYWdyZWdhY2nDs24sIGVzcGVjaWZpcXVlIHVuYSBwbGFudGlsbGEgZGUgZnVuY2nDs24gcsOhc3RlciBxdWUgY29udGVuZ2EgbGEgZnVuY2nDs24gRXN0YWTDrXN0aWNhcyBkZSBjZWxkYXMsIGNvbiBsYSBvcGVyYWNpw7NuIGRlZmluaWRhIGNvbW8gTcOheGltby4gRW4gRGVmaW5pY2nDs24gZGUgYWdyZWdhY2nDs24sIGRlZmluYSBEaW1lbnNpw7NuIGNvbW8gU3RkVGltZSwgVGlwbyBjb21vIFBhbGFicmEgY2xhdmUgZGUgaW50ZXJ2YWxvIGUgSW50ZXJ2YWxvIGRlIHBhbGFicmEgY2xhdmUgY29tbyBBbnVhbG1lbnRlLiBUZW5nYSBlbiBjdWVudGEgcXVlIHNpIGVsIGRhdGFzZXQgZGUgbW9zYWljbyBkZSBlbnRyYWRhIG5vIGVzIG11bHRpZGltZW5zaW9uYWwsIGxhIGZ1bmNpw7NuIGRlIGFncmVnYWNpw7NuIG5vIHJlc3BldGFyw6EgbGEgZGVmaW5pY2nDs24gZGUgYWdyZWdhY2nDs24uIExhIGZ1bmNpw7NuIGRlIGFncmVnYWNpw7NuIGFncmVnYXLDoSB0b2RvcyBsb3MgZWxlbWVudG9zIG8gY2FkYSBncnVwbyBlbiB1bm8gc2kgc2UgZGVmaW5lbiBlbiBsYSBwbGFudGlsbGEgZGUgZnVuY2nDs24gZGUgYWdyZWdhY2nDs24uIFBhcmEgbcOhcyBpbmZvcm1hY2nDs24gc29icmUgZWwgdXNvIGRlIGdydXBvcyBlbiB1biBkYXRhc2V0IGRlIG1vc2FpY28sIGNvbnN1bHRlIFVzYXIgZWxlbWVudG9zIGRlIHVuIGRhdGFzZXQgZGUgbW9zYWljbyBlbiBwbGFudGlsbGFzIGRlIGZ1bmNpw7NuIHLDoXN0ZXIuIDMuIEVzcGVjaWZpY2FyIHVuYSBwbGFudGlsbGEgZGUgZnVuY2nDs24gcsOhc3RlciBwYXJhIGxhIEZ1bmNpw7NuIGRlIHByb2Nlc2FtaWVudG8uIExhIGZ1bmNpw7NuIG8gY2FkZW5hIGRlIGZ1bmNpb25lcyBkZSBlc3RhIHBsYW50aWxsYSBzZSB1dGlsaXphIHBhcmEgdmlzdWFsaXphciBlbCBudWV2byByw6FzdGVyIHByb2Nlc2Fkby4gUG9yIGVqZW1wbG8sIGVzcGVjaWZpcXVlIHVuYSBwbGFudGlsbGEgZGUgZnVuY2nDs24gcsOhc3RlciBjb24gbGEgZnVuY2nDs24gTWFwYSBkZSBjb2xvciBwYXJhIGNhbWJpYXIgbGEgbWFuZXJhIGRlIHZpc3VhbGl6YXIgbGEgY2FwYSByw6FzdGVyIHByb2Nlc2FkYS4gVGVuZ2EgZW4gY3VlbnRhIHF1ZSwgc2kgbGEgZW50cmFkYSBlcyB1biByw6FzdGVyIG11bHRpZGltZW5zaW9uYWwsIHNlIGFwbGljYSBsYSBmdW5jacOzbiBkZSBwcm9jZXNhbWllbnRvIGEgbGEgZGl2aXNpw7NuIGRlIHZpc3VhbGl6YWNpw7NuIGFjdHVhbC4gU2kgbGEgZW50cmFkYSBlcyB1bmEgY2FwYSBkZSBtb3NhaWNvIG8gZGF0YXNldCBkZSBtb3NhaWNvLCBzZSBhcGxpY2EgbGEgZnVuY2nDs24gZGUgcHJvY2VzYW1pZW50byBhbCByw6FzdGVyIGRlIG1vc2FpY28gY29uIGVsIFByaW1lciBtw6l0b2RvIHBhcmEgcmVzb2x2ZXIgc3VwZXJwb3NpY2lvbmVzLiAzLiBFc3BlY2lmaWNhciBwbGFudGlsbGFzIHBhcmEgY3VhbHF1aWVyIGNvbWJpbmFjacOzbiBkZSBsYXMgdHJlcyBmdW5jaW9uZXMuIFBvciBlamVtcGxvLCB0aWVuZSB1biBkYXRhc2V0IGRlIG1vc2FpY28gY29uIGltw6FnZW5lcyBkZSBMYW5kc2F0IGRlIHNlcmllIHRlbXBvcmFsIHkgZGVzZWEgZ2VuZXJhciB1bmEgaW1hZ2VuIGNvbXB1ZXN0YSBkZWwgbcOheGltbyBORFZJLiBFbiBGdW5jacOzbiBkZSBlbGVtZW50bywgZXNwZWNpZmlxdWUgdW5hIHBsYW50aWxsYSBkZSBmdW5jacOzbiByw6FzdGVyIHF1ZSBjb250ZW5nYSBsYSBmdW5jacOzbiByw6FzdGVyIE5EVkkuIEVuIEZ1bmNpw7NuIGRlIGFncmVnYWNpw7NuLCBlc3BlY2lmaXF1ZSB1bmEgcGxhbnRpbGxhIGRlIGZ1bmNpw7NuIHLDoXN0ZXIgcXVlIGNvbnRlbmdhIGxhIGZ1bmNpw7NuIEVzdGFkw61zdGljYXMgZGUgY2VsZGFzLCBjb24gbGEgb3BlcmFjacOzbiBkZWZpbmlkYSBjb21vIE3DoXhpbW8uIEVuIEZ1bmNpw7NuIGRlIHByb2Nlc2FtaWVudG8sIGVzcGVjaWZpcXVlIHVuYSBwbGFudGlsbGEgZGUgZnVuY2nDs24gcsOhc3RlciBxdWUgY29udGVuZ2EgbGEgZnVuY2nDs24gTWFwYSBkZSBjb2xvci4gVGVuZ2EgZW4gY3VlbnRhIHF1ZSBlbCBvcmRlbiBkZSBwcm9jZXNhbWllbnRvIGRlIGxhIGZ1bmNpw7NuIHNpZ3VlIGVsIGRlIGxvcyBwYXLDoW1ldHJvcyBkZSBlbnRyYWRhLiBQb3IgZWplbXBsbywgbGEgRnVuY2nDs24gZGUgZWxlbWVudG8gc2UgcHJvY2VzYXLDoSBwcmltZXJvLjwvZGl2PlwiLFxuXHRcdHJhbmRvbU5hbWU6IFwiQWxlYXRvcmlvXCIsXG5cdFx0cmFuZG9tU25pcDogXCJDcmVhIHVuIHLDoXN0ZXIgY29uIHZhbG9yZXMgZGUgcMOteGVsIGFsZWF0b3Jpb3MgZGlidWphZG9zIGEgcGFydGlyIGRlIHVuYSBkaXN0cmlidWNpw7NuIHBzZXVkb2FsZWF0b3JpYS4gU2UgYWRtaXRlbiB2YXJpYXMgZGlzdHJpYnVjaW9uZXMgeSBnZW5lcmFkb3JlcyBkZSBuw7ptZXJvcyBhbGVhdG9yaW9zLlwiLFxuXHRcdHJhbmRvbURlc2M6IFwiTGEgZnVuY2nDs24gQWxlYXRvcmlvIGNyZWEgdW4gcsOhc3RlciBjb24gdmFsb3JlcyBkZSBww614ZWwgYWxlYXRvcmlvcyBxdWUgc2UgcHVlZGUgdXRpbGl6YXIgZW4gcGxhbnRpbGxhcyBkZSBmdW5jacOzbiByw6FzdGVyIG8gZGF0YXNldHMgZGUgbW9zYWljby48ZGl2Pjxici8+QXVucXVlIG11Y2hhcyBmdW5jaW9uZXMgb3BlcmFuIGVuIHVubyBvIHZhcmlvcyByw6FzdGVyZXMgZGUgZW50cmFkYSwgbGEgZnVuY2nDs24gQWxlYXRvcmlvIG5vIHJlcXVpZXJlIG5pbmfDum4gcsOhc3RlciBkZSBlbnRyYWRhLiBTaWduaWZpY2EgcXVlIHNlIGNvbXBvcnRhIG3DoXMgY29tbyB1biBkYXRhc2V0IHLDoXN0ZXIgcXVlIGNvbW8gdW5hIGZ1bmNpw7NuOyBwb3IgZWxsbywgZGViZSBwcmVzdGFyIGVzcGVjaWFsIGF0ZW5jacOzbiBhbCBhZ3JlZ2FybGEgbyBlbGltaW5hcmxhIGRlIGxhIGNhZGVuYSBkZSBmdW5jaW9uZXMuPC9kaXY+XCIsXG5cdFx0c2hyaW5rTmFtZTogXCJFbmNvZ2VyXCIsXG5cdFx0c2hyaW5rU25pcDogXCJFbmNvZ2UgbGFzIHpvbmFzIHNlbGVjY2lvbmFkYXMgZW4gdW5hIGNhbnRpZGFkIGVzcGVjaWZpY2FkYSBkZSBjZWxkYXMgYWwgcmVlbXBsYXphcmxhcyBjb24gZWwgdmFsb3IgZGUgbGEgY2VsZGEgcXVlIGVzIG3DoXMgZnJlY3VlbnRlIGVuIGxhIHZlY2luZGFkLlwiLFxuXHRcdHNocmlua0Rlc2M6IFwiQ29uIGxhIGZ1bmNpw7NuIGdsb2JhbCBFbmNvZ2VyLCBwdWVkZSBnZW5lcmFsaXphciwgbyBzaW1wbGlmaWNhciwgcsOhc3RlcmVzIGhhY2llbmRvIG3DoXMgcGVxdWXDsWFzIGRldGVybWluYWRhcyB6b25hcy4gVGFtYmnDqW4gcHVlZGUgY29udHJvbGFyIGxhIGNhbnRpZGFkIGRlIGdlbmVyYWxpemFjacOzbiBxdWUgc2UgcHJvZHVjaXLDoS48ZGl2Pjxici8+TGFzIHpvbmFzIHNlbGVjY2lvbmFkYXMgc2UgZW5jb2dlbiwgbyByZWR1Y2VuIHN1IHRhbWHDsW8sIHB1ZXN0byBxdWUgbGFzIGNlbGRhcyB6b25hcyBjaXJjdW5kYW50ZXMgc2UgZXhwYW5kZW4gc29icmUgZWxsYXMuIENvbmNlcHR1YWxtZW50ZSwgcHVlZGUgdmlzdWFsaXphciBsb3MgVmFsb3JlcyBkZSB6b25hIHNlbGVjY2lvbmFkb3MgY29tbyB6b25hcyBlbiBwcmltZXIgcGxhbm8sIG1pZW50cmFzIHF1ZSBlbCByZXN0byBkZSB2YWxvcmVzIHBlcm1hbmVjZW4gZW4gem9uYXMgZW4gc2VndW5kbyBwbGFuby4gTGFzIGNlbGRhcyBkZSBsYXMgem9uYXMgZW4gcHJpbWVyIHBsYW5vIHNlIHB1ZWRlbiBzdXN0aXR1aXIgcG9yIGNlbGRhcyBkZSBsYXMgem9uYXMgZW4gc2VndW5kbyBwbGFuby4gVGFtYmnDqW4gZXMgcHJvYmFibGUgcXVlIHNlIHJlZW1wbGFjZW4gbGFzIGlzbGFzIGZpbmFzIGRlbnRybyBkZSB1bmEgem9uYSwgcXVlIHB1ZWRlbiB2ZXJzZSBjb21vIHF1ZSBjb21wYXJ0ZW4gbMOtbWl0ZXMgY29uIGxhIHpvbmEuPGRpdj48YnIvPkVzIHBvc2libGUgY29udHJvbGFyIGxhIGNhbnRpZGFkIGRlIGdlbmVyYWxpemFjacOzbiBjb24gZWwgcGFyw6FtZXRybyBOw7ptZXJvIGRlIGNlbGRhcy4gRGUgbWFuZXJhIHByZWRldGVybWluYWRhLCBlc3RlIHZhbG9yIGVzIDEsIHF1ZSBzaWduaWZpY2EgcXVlIGxhcyB6b25hcyBzZWxlY2Npb25hZGFzIHNlIGVuY29nZXLDoW4gc2Vnw7puIGxhIGNhbnRpZGFkIHF1ZSBjb3JyZXNwb25kYSBhbCB0YW1hw7FvIGRlIHVuYSBjZWxkYS4gUGFyYSBhdW1lbnRhciBlbCBncmFkbyBkZSBnZW5lcmFsaXphY2nDs24sIHB1ZWRlIGVzcGVjaWZpY2FyIHVuIHZhbG9yIG1heW9yIHBhcmEgZXN0ZSBwYXLDoW1ldHJvLiBDb25jZXB0dWFsbWVudGUsIGVzIGNvbW8gZWplY3V0YXIgbGEgaGVycmFtaWVudGEgdGFudGFzIHZlY2VzIGNvbW8gZWwgbsO6bWVybyBlc3BlY2lmaWNhZG8sIHNpZW5kbyBsb3MgcmVzdWx0YWRvcyBkZSBsYSBlamVjdWNpw7NuIGFudGVyaW9yIGxhIGVudHJhZGEgYSBsYSBpdGVyYWNpw7NuIHN1YnNpZ3VpZW50ZS48L2Rpdj5cIixcblx0XHR0cmVuZFRvUkdCTmFtZTogXCJEZSB0ZW5kZW5jaWEgYSBSR0JcIixcblx0XHR0cmVuZFRvUkdCU25pcDogXCJDb252aWVydGUgdW4gcsOhc3RlciBkZSB0ZW5kZW5jaWEgZW4gdW4gcsOhc3RlciBkZSB0cmVzIGJhbmRhcyAocm9qYSwgdmVyZGUgeSBhenVsKS5cIixcblx0XHR0cmVuZFRvUkdCRGVzYzogXCJMYSBmdW5jacOzbiBEZSB0ZW5kZW5jaWEgYSBSR0IgY29udmllcnRlIHVuIHLDoXN0ZXIgZGUgdGVuZGVuY2lhIGVuIHVuIHLDoXN0ZXIgZGUgdHJlcyBiYW5kYXMgKHJvamEsIHZlcmRlIHkgYXp1bCkuIEVsIHLDoXN0ZXIgZGUgdGVuZGVuY2lhIHNlIGdlbmVyYSBhIHBhcnRpciBkZSBsYSBmdW5jacOzbiByw6FzdGVyIEdlbmVyYXIgdGVuZGVuY2lhIG8gbGEgZnVuY2nDs24gcsOhc3RlciBBbsOhbGlzaXMgQ0NEQy48ZGl2Pjxici8+RXN0YSBmdW5jacOzbiByZXN1bHRhIMO6dGlsIHBhcmEgdmlzdWFsaXphciBsb3MgZGF0b3MgZGUgY29lZmljaWVudGUgZGVsIG1vZGVsbyBkZXNkZSBsYXMgZnVuY2lvbmVzIEdlbmVyYXIgdGVuZGVuY2lhIG8gQW7DoWxpc2lzIENDREMuIEFtYmFzIGZ1bmNpb25lcyBlc3RpbWFuIHRlbmRlbmNpYXMgcGFyYSB2YWxvcmVzIGRlIHDDrXhlbCBjYW1iaWFudGVzLCBwZXJvIGxvcyByZXN1bHRhZG9zIGRlIGxhcyBmdW5jaW9uZXMgc29uIGRpZsOtY2lsZXMgZGUgaW50ZXJwcmV0YXIgZGlyZWN0YW1lbnRlLjxkaXY+PGJyLz5BbCBpZ3VhbCBxdWUgbXVjaGFzIGZ1bmNpb25lcyByw6FzdGVyLCBwdWVkZSBxdWUgbmVjZXNpdGUgdXRpbGl6YXIgQWp1c3RlIGRlIHJhbmdvIGRpbsOhbWljbyAoRFJBKSBwYXJhIHZpc3VhbGl6YXIgbWVqb3IgbG9zIHJlc3VsdGFkb3MgZGUgZXN0YSBmdW5jacOzbi48L2Rpdj5cIixcblx0XHRsYW5kVHJlbmRyTmFtZTogXCJBbsOhbGlzaXMgTGFuZFRyZW5kclwiLFxuXHRcdGxhbmRUcmVuZHJTbmlwOiBcIkV2YWzDumEgbG9zIGNhbWJpb3MgZW4gbG9zIHZhbG9yZXMgZGUgcMOteGVsIGEgbG8gbGFyZ28gZGVsIHRpZW1wbyB1dGlsaXphbmRvIGxhIGRldGVjY2nDs24gZGUgdGVuZGVuY2lhcyBiYXNhZGEgZW4gTGFuZHNhdCBlbiBlbCBtw6l0b2RvIGRlIGFsdGVyYWNpb25lcyB5IHJlY3VwZXJhY2nDs24gKExhbmRUcmVuZHIpIHkgZ2VuZXJhIHVuIHLDoXN0ZXIgZGUgYW7DoWxpc2lzIGRlIGNhbWJpb3MgcXVlIGNvbnRpZW5lIGxvcyByZXN1bHRhZG9zIGRlbCBtb2RlbG8uXCIsXG5cdFx0bGFuZFRyZW5kckRlc2M6IFwiRXN0YSBmdW5jacOzbiByw6FzdGVyIHNvbG8gc2UgcHVlZGUgdXRpbGl6YXIgY29tbyBlbnRyYWRhIHBhcmEgbGEgZnVuY2nDs24gcsOhc3RlciBEZXRlY3RhciBjYW1iaW9zIGNvbiBhbsOhbGlzaXMgZGUgY2FtYmlvcy4gUGFyYSBnZW5lcmFyIHVuYSBzYWxpZGEgZGUgcsOhc3RlciwgY29uZWN0ZSBsYSBmdW5jacOzbiBBbsOhbGlzaXMgTGFuZFRyZW5kciBjb24gbGEgZnVuY2nDs24gRGV0ZWN0YXIgY2FtYmlvcyBjb24gYW7DoWxpc2lzIGRlIGNhbWJpb3MgZW4gdW5hIHBsYW50aWxsYSBkZSBmdW5jacOzbiByw6FzdGVyIHkgdXRpbGljZSBsYSBwbGFudGlsbGEgY29tbyBlbnRyYWRhIGVuIGxhIGhlcnJhbWllbnRhIGRlIGdlb3Byb2Nlc2FtaWVudG8gR2VuZXJhciByw6FzdGVyIGEgcGFydGlyIGRlIGxhIGZ1bmNpw7NuIFLDoXN0ZXIuIEVsIHJlc3VsdGFkbyBlcyB1biByw6FzdGVyIHF1ZSBjb250aWVuZSBpbmZvcm1hY2nDs24gc29icmUgZWwgbW9tZW50byBlbiBlbCBxdWUgY2FtYmlhcm9uIGxvcyB2YWxvcmVzIGRlIHDDrXhlbC48ZGl2Pjxicj5MYSBmaW5hbGlkYWQgZGUgZXN0YSBmdW5jacOzbiBkZSByw6FzdGVyIGNvbnNpc3RlIGVuIGV4dHJhZXIgY2FtYmlvcyBlbiB1bmEgZW50aWRhZCBvYnNlcnZhZGEsIHBvciBsbyBxdWUgbGFzIGltw6FnZW5lcyBtdWx0aWRpbWVuc2lvbmFsZXMgZGUgZW50cmFkYSBpZGVhbGVzIGRlYmVuIGNhcHR1cmFyIHVuYSBvYnNlcnZhY2nDs24gY29uc2lzdGVudGUgYSB0cmF2w6lzIGRlbCB0aWVtcG8geSBubyBkZWJlbiBpbmNsdWlyIGludGVyZmVyZW5jaWEgYXRtb3Nmw6lyaWNhIG8gZGUgc2Vuc29yZXMsIG51YmVzIG5pIHNvbWJyYSBkZSBudWJlcy4gTGEgbWVqb3IgcHLDoWN0aWNhIGNvbnNpc3RlIGVuIHV0aWxpemFyIGRhdG9zIHF1ZSBzZSBoYXlhbiBub3JtYWxpemFkbyB5IHB1ZWRhbiBlbm1hc2NhcmFyc2UgdXNhbmRvIHVuYSBiYW5kYSBkZSBjb250cm9sIGRlIGNhbGlkYWQsIHBvciBlamVtcGxvIHByb2R1Y3RvcyBkZSBSZWZsZWN0YW5jaWEgZGUgc3VwZXJmaWNpZSBkZSBDb2xlY2Npw7NuIGRlIExhbmRzYXQgMSBjb24gdW5hIG3DoXNjYXJhIGRlIG51YmUuPGRpdj48YnI+TGEgZnVuY2nDs24gcmVhbGl6YSBhbsOhbGlzaXMgZW4gdW5hIGltYWdlbiBhbCBhw7FvLCB5IGVsIG7Dum1lcm8gZGUgcGVyaW9kb3MgYW51YWxlcyBkZWJlIHNlciBpZ3VhbCBvIG1heW9yIHF1ZSBlbCB2YWxvciBlc3BlY2lmaWNhZG8gZW4gZWwgcGFyw6FtZXRybyA8c3Ryb25nPkNhbnRpZGFkIG3DrW5pbWEgZGUgb2JzZXJ2YWNpb25lczwvc3Ryb25nPi4gU2UgcmVjb21pZW5kYSBkaXNwb25lciBkZSBhbCBtZW5vcyBzZWlzIGHDsW9zIGRlIGRhdG9zLjxkaXY+PGJyPlNpIHR1dmllcmEgZGF0b3MgbWVuc3VhbGVzLCBzZW1hbmFsZXMgbyBkaWFyaW9zLCBzZSByZWNvbWllbmRhIHNlbGVjY2lvbmFyIHZhcmlhcyBpbcOhZ2VuZXMgZGUgY2FkYSBhw7FvIChwcmVmZXJpYmxlbWVudGUgZGUgbGEgbWlzbWEgZXN0YWNpw7NuKSwgcmV0aXJhciBudWJlcyB5IHNvbWJyYSBkZSBudWJlcywgeSBjb21iaW5hciBsYXMgaW3DoWdlbmVzIHBhcmEgZ2VuZXJhciB1bmEgw7puaWNhIGltYWdlbiBxdWUgY2FwdHVyZSBhZGVjdWFkYW1lbnRlIGxhIG9ic2VydmFjacOzbi4gU2kgc2UgcHJvcG9yY2lvbmFuIGRhdG9zIG1lbnN1YWxtZW50ZSwgc2VtYW5hbG1lbnRlIG8gZGlhcmlhbWVudGUgY29tbyBlbCByw6FzdGVyIG11bHRpZGltZW5zaW9uYWwgZGUgZW50cmFkYSwgbGEgZnVuY2nDs24gaWRlbnRpZmljYXLDoSB1bmEgZGl2aXNpw7NuIHBhcmEgYW7DoWxpc2lzIGJhc2FkYSBlbiBsYSBmZWNoYSBtw6FzIGNlcmNhbmEgcXVlIHNlIHByb3BvcmNpb25hIGVuIGVsIHBhcsOhbWV0cm8gPHN0cm9uZz5GZWNoYSBkZSBhbGluZWFjacOzbjwvc3Ryb25nPi48ZGl2Pjxicj5VbmEgZW50aWRhZCBlbiB1biBwYWlzYWplIHN1ZWxlIHJlcXVlcmlyIHRpZW1wbyBkZSByZWN1cGVyYWNpw7NuIGNvbiByZXNwZWN0byBhIHVuIGNhbWJpbyBubyBwZXJtYW5lbnRlIGNvbW8gcG9yIGVqZW1wbG8gdW4gaW5jZW5kaW8gZm9yZXN0YWwgbyBwbGFnYSBkZSBpbnNlY3Rvcy4gUGFyYSBjb250cm9sYXIgbGEgdmVsb2NpZGFkIGRlIHJlY3VwZXJhY2nDs24gcmVjb25vY2lkYSBwb3IgZWwgbW9kZWxvLCBlc3RhYmxlemNhIGVsIHBhcsOhbWV0cm8gVW1icmFsIGRlIHJlY3VwZXJhY2nDs24uIFVuIHNlZ21lbnRvIGRpc3RpbnRvIG5vIHB1ZWRlIHRlbmVyIHVuYSB2ZWxvY2lkYWQgZGUgcmVjdXBlcmFjacOzbiBxdWUgc2VhIG1heW9yIGRlIDEvdW1icmFsIGRlIHJlY3VwZXJhY2nDs24uPGRpdj48YnI+TGEgcmVjdXBlcmFjacOzbiBkZSB1biBjYW1iaW8gZW4gZWwgcGFpc2FqZSBwdWVkZSBwcm9kdWNpcnNlIGVuIGxhIGRpcmVjY2nDs24gcG9zaXRpdmEgbyBuZWdhdGl2YS4gUG9yIGVqZW1wbG8sIGN1YW5kbyB1biBwYWlzYWplIGV4cGVyaW1lbnRhIHDDqXJkaWRhIGZvcmVzdGFsLCB1bmEgc2VyaWUgdGVtcG9yYWwgZGUgdmFsb3JlcyBkZWwgw61uZGljZSBkZSB2ZWdldGFjacOzbiBtdWVzdHJhIHVuYSBjYcOtZGEgZW4gbG9zIHZhbG9yZXMgZGVsIMOtbmRpY2UsIHkgbGEgcmVjdXBlcmFjacOzbiBtdWVzdHJhIHVuIGluY3JlbWVudG8gZ3JhZHVhbCBlbiBsb3MgdmFsb3JlcyBkZWwgw61uZGljZSBkZSB2ZWdldGFjacOzbiwgbyB1bmEgdGVuZGVuY2lhIGRlIHJlY3VwZXJhY2nDs24gcG9zaXRpdmEuIEVzcGVjaWZpcXVlIGxhIGRpcmVjY2nDs24gZGUgbGEgdGVuZGVuY2lhIGRlIHJlY3VwZXJhY2nDs24gY29uIGVsIHBhcsOhbWV0cm8gPHN0cm9uZz5SZWN1cGVyYWNpw7NuIGNvbiB0ZW5kZW5jaWEgZW4gYXVtZW50bzwvc3Ryb25nPi5cIixcblx0XHRhZ2dyZWdhdGVNdWx0aWRpbWVuc2lvbmFsTmFtZTogXCJBZ3JlZ2FyIG11bHRpZGltZW5zaW9uYWxcIixcblx0XHRhZ2dyZWdhdGVNdWx0aWRpbWVuc2lvbmFsU25pcDogXCJDb21iaW5lIGxvcyBkYXRvcyBkZSB2YXJpYWJsZXMgZGUgcsOhc3RlciBtdWx0aWRpbWVuc2lvbmFsIGV4aXN0ZW50ZXMgYSBsbyBsYXJnbyBkZSB1bmEgZGltZW5zacOzbi5cIixcblx0XHRhZ2dyZWdhdGVNdWx0aWRpbWVuc2lvbmFsRGVzYzogXCJMYSBmdW5jacOzbiBBZ3JlZ2FyIG11bHRpZGltZW5zaW9uYWwgY3JlYSB1bmEgY2FwYSByw6FzdGVyIG11bHRpZGltZW5zaW9uYWwgY29tYmluYW5kbyBsb3MgZGF0b3MgZGUgdmFyaWFibGVzIHLDoXN0ZXIgbXVsdGlkaW1lbnNpb25hbGVzIGV4aXN0ZW50ZXMgYSBsbyBsYXJnbyBkZSB1bmEgZGltZW5zacOzbi48ZGl2Pjxicj5VdGlsaWNlIGVsIHBhcsOhbWV0cm8gPHN0cm9uZz5EZWZpbmljacOzbiBkZSBkaW1lbnNpw7NuPC9zdHJvbmc+IHBhcmEgZmlsdHJhciBwcmltZXJvIGxvcyBkYXRvcyBkZSBlbnRyYWRhIHF1ZSBkZXNlYSBhZ3JlZ2FyLiBQb3IgZWplbXBsbywgc2kgdGllbmUgMzAgYcOxb3MgZGUgZGF0b3MgbWVuc3VhbGVzLCBwZXJvIHNvbG8gZGVzZWEgY3JlYXIgdW5hIGNhcGEgYWdyZWdhZGEgZGUgbG9zIDE1IHByaW1lcm9zIGHDsW9zLCBwdWVkZSB1dGlsaXphciBlbCBwYXLDoW1ldHJvIDxzdHJvbmc+RGVmaW5pY2nDs24gZGUgZGltZW5zacOzbjwvc3Ryb25nPiBwYXJhIGVzcGVjaWZpY2FyIGxvcyBhw7FvcyBxdWUgZGVzZWEgaW5jbHVpciBlbiBlbCBhbsOhbGlzaXMuPGRpdj48YnI+PHVsPjxsaT5FeHRyYWlnYSBsb3MgZGF0b3MgZGUgc2FsaW5pZGFkIHBhcmEgZWwgbWVzIGRlIGVuZXJvIGR1cmFudGUgZWwgcGVyaW9kbyBkZSAxMCBhw7Fvcy4gRWxpamEgPHN0cm9uZz5Qb3IgdmFsb3Jlczwvc3Ryb25nPiwgZGVmaW5hIDxzdHJvbmc+RGltZW5zacOzbjwvc3Ryb25nPiBjb21vIDxzdHJvbmc+U3RkVGltZTwvc3Ryb25nPiB5IGRlZmluYSA8c3Ryb25nPlZhbG9yZXM8L3N0cm9uZz4gY29tbyA8c3Ryb25nPkVuZXJvPC9zdHJvbmc+LjwvbGk+PGxpPkRpdmlkYSBsb3MgZGF0b3MgZGUgc2FsaW5pZGFkIGVuIHVuIHJhbmdvIGRlIHByb2Z1bmRpZGFkIGRlIDAgYSAxNTAgbWV0cm9zLiBFbGlqYSA8c3Ryb25nPlBvciByYW5nb3M8L3N0cm9uZz4sIGRlZmluYSA8c3Ryb25nPkRpbWVuc2nDs248L3N0cm9uZz4gY29tbyA8c3Ryb25nPlN0ZFo8L3N0cm9uZz4geSBkZWZpbmEgPHN0cm9uZz5WYWxvciBtw61uaW1vPC9zdHJvbmc+IGNvbW8gPHN0cm9uZz4tMTUwPC9zdHJvbmc+IHkgPHN0cm9uZz5WYWxvciBtw6F4aW1vPC9zdHJvbmc+IGNvbW8gPHN0cm9uZz4wPC9zdHJvbmc+LjwvbGk+PGxpPkV4dHJhaWdhIGxvcyBkYXRvcyBkZSBzYWxpbmlkYWQgZGUgbG9zIHByaW1lcm9zIDEwIGTDrWFzIGRlIGNhZGEgbWVzIGRlIGVuZXJvIGR1cmFudGUgdW4gcGVyaW9kbyBkZSAxMCBhw7Fvcy4gRWxpamEgPHN0cm9uZz5Qb3IgaXRlcmFjacOzbjwvc3Ryb25nPiwgZGVmaW5hIDxzdHJvbmc+RGltZW5zacOzbjwvc3Ryb25nPiBjb21vIDxzdHJvbmc+U3RkVGltZTwvc3Ryb25nPiwgZGVmaW5hIDxzdHJvbmc+SW5pY2lvIGRlIGxhIHByaW1lcmEgaXRlcmFjacOzbjwvc3Ryb25nPiB5IDxzdHJvbmc+RmluIGRlIGxhIHByaW1lcmEgaXRlcmFjacOzbjwvc3Ryb25nPiBjb21vIGVsIGluaWNpbyB5IGVsIGZpbiBjb3JyZXNwb25kaWVudGVzIGRlbCBwZXJpb2RvIGRlIGl0ZXJhY2nDs24sIGRlZmluYSA8c3Ryb25nPlBhc288L3N0cm9uZz4gY29tbyA8c3Ryb25nPjE8L3N0cm9uZz4geSBkZWZpbmEgPHN0cm9uZz5VbmlkYWQ8L3N0cm9uZz4gY29tbyA8c3Ryb25nPkHDsW9zPC9zdHJvbmc+LjwvbGk+PC91bD48ZGl2Pjxicj5VdGlsaWNlIGxvcyBwYXLDoW1ldHJvcyA8c3Ryb25nPkRlZmluaWNpw7NuIGRlIGFncmVnYWNpw7NuPC9zdHJvbmc+IHBhcmEgZWxlZ2lyIGxhIGRpbWVuc2nDs24gcXVlIHNlIHZhIGEgZXZhbHVhciB5IGVsIGludGVydmFsbyBkZSBhZ3JlZ2FjacOzbiBtZWRpYW50ZSB1bmEgcGFsYWJyYSBjbGF2ZSwgdW4gdmFsb3IgbyB1biByYW5nbyBkZSB2YWxvcmVzLiBQb3IgZWplbXBsbywgc2kgY3VlbnRhIGNvbiAzMCBhw7FvcyBkZSBkYXRvcyBkZSB0ZW1wZXJhdHVyYSBkZSBsYSBzdXBlcmZpY2llIGRlbCBtYXIgcXVlIHNlIGhhbiByZWNvcGlsYWRvIGRpYXJpYW1lbnRlIHkgZW4gY2FkYSA1IG1ldHJvcyBkZSBwcm9mdW5kaWRhZCBoYXN0YSBsbGVnYXIgYSBsb3MgMTAwIG1ldHJvcywgcHVlZGUgdXRpbGl6YXIgbGFzIGRpc3RpbnRhcyBvcGNpb25lcyBkZSBpbnRlcnZhbG9zIGVuIGVzdG9zIGVzY2VuYXJpb3M6PGRpdj48YnI+PHVsPjxsaT5BZ3JlZ3VlIGRhdG9zIGRlIHRlbXBlcmF0dXJhIGRpYXJpb3MgZW4gZGF0b3MgbWVuc3VhbGVzLCBkb25kZSBlbCByZXN1bHRhZG8gZXMgdW4gcsOhc3RlciBtdWx0aWRpbWVuc2lvbmFsIGNvbiAxMiBwZXJpb2RvcyBkZSB0aWVtcG8sIHkgY2FkYSBwZXJpb2RvIGVzIGxhIGFncmVnYWNpw7NuIGRlIGNhZGEgbWVzIGEgbG8gbGFyZ28gZGUgbG9zIGHDsW9zLiBFbGlqYSA8c3Ryb25nPlBhbGFicmEgY2xhdmUgZGUgaW50ZXJ2YWxvPC9zdHJvbmc+IHkgZGVmaW5hIGxhIHBhbGFicmEgY2xhdmUgY29tbyA8c3Ryb25nPlJlY3VycmVudGUgbWVuc3VhbG1lbnRlPC9zdHJvbmc+LjwvbGk+PGxpPkFncmVndWUgZGF0b3MgZGUgdGVtcGVyYXR1cmEgZGlhcmlvcyBlbiBkYXRvcyBtZW5zdWFsZXMsIGRvbmRlIGVsIHJlc3VsdGFkbyBlcyB1biByw6FzdGVyIG11bHRpZGltZW5zaW9uYWwgY29uIDM2MCBwZXJpb2RvcywgbyBiaWVuIDEyIHBlcmlvZG9zIGRlIHRpZW1wbyBwb3IgYcOxbyAoMzAgYcOxb3MgeCAxMiBtZXNlcyA9IDM2MCBwZXJpb2RvcykuIFNlbGVjY2lvbmUgPHN0cm9uZz5QYWxhYnJhIGNsYXZlIGRlIGludGVydmFsbzwvc3Ryb25nPiB5IGRlZmluYSBsYSBwYWxhYnJhIGNsYXZlIGNvbW8gPHN0cm9uZz5NZW5zdWFsbWVudGU8L3N0cm9uZz4uPC9saT48bGk+QWdyZWd1ZSBkYXRvcyBkZSB0ZW1wZXJhdHVyYSBtZW5zdWFsZXMgZW4gaW50ZXJ2YWxvcyBkZSA0IG1lc2VzLiBTZWxlY2Npb25lIDxzdHJvbmc+VmFsb3IgZGUgaW50ZXJ2YWxvPC9zdHJvbmc+LCBkZWZpbmEgPHN0cm9uZz5JbnRlcnZhbG8gZGUgdmFsb3I8L3N0cm9uZz4gY29tbyA0IHkgZGVmaW5hIDxzdHJvbmc+VW5pZGFkPC9zdHJvbmc+IGNvbW8gPHN0cm9uZz5NZXNlczwvc3Ryb25nPi48L2xpPjxsaT5BZ3JlZ3VlIGRhdG9zIGRlIHRlbXBlcmF0dXJhIGRlIDAgYSAyNSBtZXRyb3MsIGRlc3B1w6lzIGRlIDI1IGEgNTAgbWV0cm9zLCBwb3Igw7psdGltbywgZGUgNTAgYSAxMDAgbWV0cm9zLiBTZWxlY2Npb25lIDxzdHJvbmc+UmFuZ29zIGRlIGludGVydmFsb3M8L3N0cm9uZz4geSBlc3BlY2lmaXF1ZSBsYXMgcHJvZnVuZGlkYWRlcyBtw61uaW1hIHkgbcOheGltYSBjb21vIDxzdHJvbmc+MCAyNTsgMjUgNTA7IDUwIDEwMDwvc3Ryb25nPi48L2xpPjwvdWw+XCIsXG5cdFx0bWVyZ2VSYXN0ZXJzTmFtZTogXCJGdXNpb25hciByw6FzdGVyc1wiLFxuXHRcdG1lcmdlUmFzdGVyc1NuaXA6IFwiQ29tYmluYSB2YXJpb3MgZGF0YXNldHMgZGUgcsOhc3RlciBlc3BhY2lhbG1lbnRlLCBvIGEgdHJhdsOpcyBkZSB2YXJpYWJsZXMgeSBkaW1lbnNpb25lcy5cIixcblx0XHRtZXJnZVJhc3RlcnNEZXNjOiBcIkVzdGEgZnVuY2nDs24gY3JlYSB1biByw6FzdGVyIGZ1c2lvbmFkbyBhIHBhcnRpciBkZSB1bmEgbGlzdGEgZGUgcsOhc3RlcmVzLiBQb3IgZWplbXBsbywgc2kgdGllbmUgdW4gZGF0YXNldCBkZSBtb3NhaWNvIGNvbiAzMCBhw7FvcyBkZSBkYXRvcyBkZSBwcmVjaXBpdGFjaW9uZXMgbWVuc3VhbGVzIHkgb3RybyBkYXRhc2V0IGNvbiAxMCBhw7FvcyBkZSBkYXRvcyBkZSB0ZW1wZXJhdHVyYSBtZW5zdWFsZXMsIHB1ZWRlIGNvbWJpbmFybG9zIGVuIHVuIHLDoXN0ZXIgbXVsdGlkaW1lbnNpb25hbCBjb24gYW1iYXMgdmFyaWFibGVzLiA8ZGl2Pjxicj5TaSBsb3MgcsOhc3RlcmVzIG11bHRpZGltZW5zaW9uYWxlcyBkZSBlbnRyYWRhIGNvbnRpZW5lbiBkaWZlcmVudGVzIHZhcmlhYmxlcywgZWwgcsOhc3RlciBtdWx0aWRpbWVuc2lvbmFsIGRlIHNhbGlkYSBjb250ZW5kcsOhIHRvZGFzIGxhcyB2YXJpYWJsZXMuIDxkaXY+PGJyPlNpIGxvcyByw6FzdGVyZXMgbXVsdGlkaW1lbnNpb25hbGVzIGRlIGVudHJhZGEgY29udGllbmVuIGRpZmVyZW50ZXMgZGltZW5zaW9uZXMgbyB2YWxvcmVzIGRlIGRpbWVuc2lvbmVzLCBlbCByw6FzdGVyIG11bHRpZGltZW5zaW9uYWwgaW5jbHVpcsOhIHRvZGFzIGxhcyBkaW1lbnNpb25lcyB5IHZhbG9yZXMgZGUgZGltZW5zaW9uZXMuIDxkaXY+PGJyPlNpIGxvcyByw6FzdGVyZXMgbXVsdGlkaW1lbnNpb25hbGVzIGRlIGVudHJhZGEgY29udGllbmVuIGxhcyBtaXNtYXMgZGltZW5zaW9uZXMgeSB2YXJpYWJsZXMgcGVybyBkaWZlcmVudGVzIGV4dGVuc2lvbmVzIGVzcGFjaWFsZXMsIGVsIHLDoXN0ZXIgbXVsdGlkaW1lbnNpb25hbCBkZSBzYWxpZGEgY29udGVuZHLDoSBsYXMgdmFyaWFibGVzIHkgZGltZW5zaW9uZXMgYSB0cmF2w6lzIGRlIGxhcyBleHRlbnNpb25lcyBlc3BhY2lhbGVzIGZ1c2lvbmFkYXMuPGRpdj48YnI+RXN0YSBmdW5jacOzbiB0YW1iacOpbiBwdWVkZSB1dGlsaXphcnNlIHNpIHRpZW5lIHZhcmlvcyByw6FzdGVyZXMgcXVlIGRlc2VhIHRyYXRhciBjb21vIHVuIMO6bmljbyBlbGVtZW50bywgcG9yIGVqZW1wbG8sIHBhcmEgY2FsY3VsYXIgbGFzIG1pc21hcyBlc3RhZMOtc3RpY2FzIHBhcmEgdG9kb3MsIG8gYWwgcmVhbGl6YXIgdW4gYmFsYW5jZSBkZSBjb2xvciBwYXJhIG5vIHRlbmVyIHF1ZSBoYWNlcmxvIGVuIGNhZGEgaW1hZ2VuIHBvciBzZXBhcmFkby4gUmVzdWx0YSDDunRpbCBhbCB0cmFiYWphciBjb24gaW3DoWdlbmVzIGFsbWFjZW5hZGFzIGNvbW8gdGVzZWxhcyBzZXBhcmFkYXMgZGViaWRvIGEgcmVzdHJpY2Npb25lcyBkZSB0YW1hw7FvIGRlIGFyY2hpdm9zOyBkZSBlc3RhIGZvcm1hLCBsYXMgdGVzZWxhcyBzZSB0cmF0YXLDoW4gY29tbyBwYXJ0ZSBkZSBsYSBtaXNtYSBpbWFnZW4uXCIsXG5cdFx0Ym91bmRhcnlDbGVhbk5hbWU6IFwiUmVmaW5hZG8gZGUgbMOtbWl0ZXNcIixcblx0XHRib3VuZGFyeUNsZWFuU25pcDogXCJTdWF2aXphIGVsIGzDrW1pdGUgZW50cmUgem9uYXMuXCIsXG5cdFx0Ym91bmRhcnlDbGVhbkRlc2M6IFwiPHA+TGEgZnVuY2nDs24gZ2VuZXJhbGl6YSBvIHNpbXBsaWZpY2EgcsOhc3RlcmVzIGFsIHN1YXZpemFyIGxvcyBsw61taXRlcyBlbnRyZSB6b25hcy4gTGEgZnVuY2nDs24gcHJvcG9yY2lvbmEgb3BjaW9uZXMgcGFyYSBjb250cm9sYXIgY8OzbW8gbGFzIGNlbGRhcyBkZSBsYXMgem9uYXMgZGUgbGEgZW50cmFkYSBpbmZsdXllbiBlbiBlbCBzdWF2aXphZG8geSBsYSBjYW50aWRhZCBkZSBzdWF2aXphZG8gcXVlIHNlIGFwbGljYXLDoS4gQ2FkYSBjZWxkYSBkZSBlbnRyYWRhIHNlIGV2YWzDumEgdXRpbGl6YW5kbyBzdXMgb2NobyB2ZWNpbm9zIGlubWVkaWF0b3MuPC9wPjxwPkVsIHByb2Nlc28gZGUgc3Vhdml6YWRvIHByaW1lcm8gb3JkZW5hIGxhcyBjZWxkYXMgdmVjaW5hcyBwb3IgdW5hIHByaW9yaWRhZCBlbiBwYXJ0aWN1bGFyLiBMYSBwcmlvcmlkYWQgZGV0ZXJtaW5hIHF1w6kgem9uYSBkZSBsYXMgY2VsZGFzIHZlY2luYXMgcHVlZGUgcmVlbXBsYXphciBlbCB2YWxvciBkZSBsYSBjZWxkYSBkZSBwcm9jZXNhbWllbnRvIGVuIGxhIHNhbGlkYS48L3A+PHA+TGEgcHJpb3JpZGFkIHB1ZWRlIGJhc2Fyc2UgZW4gZWwgdmFsb3IgbyBlbiBlbCB0YW1hw7FvIGRlIGxhcyB6b25hcy4gRWwgcGFyw6FtZXRybyA8c3Ryb25nPlRpcG8gZGUgb3JkZW5hY2nDs248L3N0cm9uZz4gZGV0ZXJtaW5hIGVsIHRpcG8gZGUgb3JkZW5hY2nDs24gcXVlIHNlIGRlYmUgdXRpbGl6YXIuIDwvcD48cD5MYSBjb25maWd1cmFjacOzbiBwcmVkZXRlcm1pbmFkYSA8c3Ryb25nPk5vIG9yZGVuYXI8L3N0cm9uZz4gZXZhbMO6YSBsYSBwcmlvcmlkYWQgZW4gZnVuY2nDs24gZGVsIHZhbG9yIGRlIGxhcyB6b25hcy4gTGFzIGNlbGRhcyBkZSB6b25hcyBjb24gdmFsb3JlcyBtw6FzIGdyYW5kZXMgdGVuZHLDoW4gbWF5b3IgcHJpb3JpZGFkIHBhcmEgZXhwYW5kaXJzZSBlbiB6b25hcyBjb24gdmFsb3JlcyBtw6FzIHBlcXVlw7Fvcy48L3A+PHA+RWwgdGFtYcOxbyBvIGVsIMOhcmVhIHRvdGFsIGRlIGxhcyB6b25hcyBzZSBwdWVkZSB1dGlsaXphciBwYXJhIG9yZGVuYXIgbGEgcHJpb3JpZGFkLiBDb24gZWwgYWp1c3RlIDxzdHJvbmc+RGVzY2VuZGVudGU8L3N0cm9uZz4sIGxhcyB6b25hcyBzZSBvcmRlbmFuIHBvciB0YW1hw7FvIGVuIG9yZGVuIGRlc2NlbmRlbnRlLiBMYXMgem9uYXMgY29uIMOhcmVhcyB0b3RhbGVzIG3DoXMgZ3JhbmRlcyB0ZW5kcsOhbiBwcmlvcmlkYWQgcGFyYSBleHBhbmRpcnNlIGVuIHpvbmFzIGNvbiDDoXJlYXMgbcOhcyBwZXF1ZcOxYXMuIENvbiBsYSBjb25maWd1cmFjacOzbiA8c3Ryb25nPkFzY2VuZGVudGU8L3N0cm9uZz4gb2N1cnJlIGxvIGNvbnRyYXJpbzogbGFzIHpvbmFzIGNvbiDDoXJlYXMgdG90YWxlcyBtw6FzIHBlcXVlw7FhcyB0ZW5kcsOhbiBwcmlvcmlkYWQgcGFyYSBleHBhbmRpcnNlIGVuIHpvbmFzIGNvbiDDoXJlYXMgdG90YWxlcyBtw6FzIGdyYW5kZXMuPC9wPjxwPkxhIGNhbnRpZGFkIGRlIHN1YXZpemFkbyBzZSBjb250cm9sYSBtZWRpYW50ZSBlbCBwYXLDoW1ldHJvIDxzdHJvbmc+RWplY3V0YXIgZXhwYW5zacOzbiB5IGNvbnRyYWNjacOzbiBkb3MgdmVjZXM8L3N0cm9uZz4sIHF1ZSBkZXRlcm1pbmEgZWwgbsO6bWVybyBkZSB2ZWNlcyBxdWUgc2UgcmVhbGl6YXLDoSBlbCBwcm9jZXNvIGRlIGV4cGFuc2nDs24geSBjb250cmFjY2nDs24uPC9wPjxwPkNvbiBlc3RhIGNvbmZpZ3VyYWNpw7NuIGRlc2FjdGl2YWRhLCBlbCBwcm9jZXNvIGRlIGV4cGFuc2nDs24geSBjb250cmFjY2nDs24gc2UgcmVhbGl6YSB1bmEgdmV6LiBDb24gZXN0YSBjb25maWd1cmFjacOzbiBhY3RpdmFkYSwgZWwgcHJvY2VzbyBkZSBleHBhbnNpw7NuIHkgY29udHJhY2Npw7NuIHNlIHJlYWxpemEgZG9zIHZlY2VzLCBsbyBxdWUgZGEgbHVnYXIgYSB1biBncmFkbyBhZGljaW9uYWwgZGUgc3Vhdml6YWRvIGRlIGxvcyBsw61taXRlcyBkZSBsYSB6b25hLjwvcD48cD5TaSBsb3MgdmFsb3JlcyBkZSBsYXMgb2NobyBjZWxkYXMgdmVjaW5hcyBzb24gbG9zIG1pc21vcyBxdWUgbGEgY2VsZGEgZGUgcHJvY2VzYW1pZW50bywgbGEgY2VsZGEgZGUgc2FsaWRhIGNvbnNlcnZhcsOhIGVsIHZhbG9yIGRlIGxhIGNlbGRhIGRlIGVudHJhZGEuPC9wPlwiLFxuXHRcdHByZWRpY3RVc2luZ1JlZ3Jlc3Npb25OYW1lOiBcIlByZWRlY2lyIGNvbiByZWdyZXNpw7NuXCIsXG5cdFx0cHJlZGljdFVzaW5nUmVncmVzc2lvblNuaXA6IFwiQ2FsY3VsYSB1biByw6FzdGVyIHByZWRpY2hvIGJhc2FkbyBlbiBsYXMgZW50cmFkYXMgZGUgZGF0b3MgZGVsIHLDoXN0ZXIgeSB1biBtb2RlbG8gZGUgcmVncmVzacOzbi4gRWwgbW9kZWxvIGRlIHJlZ3Jlc2nDs24gZXMgZWwgcmVzdWx0YWRvIGRlIGxhIGhlcnJhbWllbnRhIGRlIGdlb3Byb2Nlc2FtaWVudG8gcsOhc3RlciBkZWwgPHN0cm9uZz5tb2RlbG8gZGUgcmVncmVzacOzbiBkZSDDoXJib2xlcyBhbGVhdG9yaW9zPC9zdHJvbmc+LlwiLFxuXHRcdHByZWRpY3RVc2luZ1JlZ3Jlc3Npb25EZXNjOiBcIjxwPkVsIG1vZGVsbyBkZSByZWdyZXNpw7NuIHNlIGRlZmluZSBlbiB1biBhcmNoaXZvIGRlIGRlZmluaWNpw7NuIGRlIHJlZ3Jlc2nDs24gZGUgRXNyaSAoLmVjZCkuIENvbnRpZW5lIHRvZGEgbGEgaW5mb3JtYWNpw7NuIGRlIHVuIGRhdGFzZXQgZXNwZWPDrWZpY28gbyB1biBjb25qdW50byBkZSBkYXRhc2V0cywgYXPDrSBjb21vIGVsIG1vZGVsbyBkZSByZWdyZXNpw7NuLCB5IHNlIGdlbmVyYSBjb24gbGEgaGVycmFtaWVudGEgZGUgZ2VvcHJvY2VzYW1pZW50byByw6FzdGVyIDxzdHJvbmc+RW50cmVuYXIgbW9kZWxvIGRlIHJlZ3Jlc2nDs24gZGUgw6FyYm9sZXMgYWxlYXRvcmlvczwvc3Ryb25nPi48L3A+PHA+RWwgcmVzdWx0YWRvIHB1ZWRlIHNlciB1bmEgc29sYSBiYW5kYSwgdW5hIG11bHRpYmFuZGEsIHVuIHLDoXN0ZXIgbXVsdGlkaW1lbnNpb25hbCBvIHVuYSBsaXN0YSBkZSBlc3RvcyB0aXBvcy4gTG9zIHRpcG9zIGRlIGxvcyByw6FzdGVyZXMgZGUgcmVzdWx0YWRvcyBkZWJlbiBzZXIgZGVsIG1pc21vIHRpcG8gZGUgcsOhc3RlciBlbnRyZW5hZG8gcG9yIGVsIG1vZGVsbyBkZSByZWdyZXNpw7NuLjwvcD48dWw+PGxpPkN1YW5kbyBsYSBlbnRyYWRhIGVzIHVuIHLDoXN0ZXIgbXVsdGliYW5kYSwgc2UgdHJhdGEgYSBjYWRhIGJhbmRhIGNvbW8gdW4gcHJlZGljdG9yIHZhcmlhYmxlLiBMYXMgYmFuZGFzIGRlYmVuIHRlbmVyIGVsIG1pc21vIG9yZGVuIHF1ZSBsYSBlbnRyYWRhIGRlIG11bHRpYmFuZGEgcGFyYSBsYSBoZXJyYW1pZW50YSBkZSBlbnRyZW5hbWllbnRvIGRlbCBtb2RlbG8gZGUgcmVncmVzacOzbi48L2xpPjxsaT5DdWFuZG8gbGEgZW50cmFkYSBlcyB1biByw6FzdGVyIG11bHRpZGltZW5zaW9uYWwsIGNhZGEgdmFyaWFibGUgc2UgdHJhdGEgY29tbyB1bmEgdmFyaWFibGUgZGUgaW5kaWNhZG9yLCB5IGxhIHZhcmlhYmxlIGRlYmUgc2VyIGRlIGJhbmRhIMO6bmljYSB5IGRlYmUgdGVuZXIgdW5hIGRpbWVuc2nDs24gZGUgdGllbXBvLiBFbCBvcmRlbiB5IGxvcyBub21icmVzIGRlIGxhcyB2YXJpYWJsZXMgZGViZW4gc2VyIGxvcyBtaXNtb3MgcXVlIGxvcyBkZSBlbnRyYWRhIGN1YW5kbyBzZSBlbnRyZW7DsyBlbCBtb2RlbG8gZGUgcmVncmVzacOzbi4gRWwgcmVzdWx0YWRvIGVzIHVuIHLDoXN0ZXIgbXVsdGlkaW1lbnNpb25hbC48L2xpPjxsaT5FbCByZXN1bHRhZG8gcHVlZGUgc2VyIHVuYSBsaXN0YSBkZSBlbGVtZW50b3MuIEVsIG7Dum1lcm8gZGUgZWxlbWVudG9zIHkgZWwgb3JkZW4gZGUgbG9zIGVsZW1lbnRvcyBkZWJlbiBjb2luY2lkaXIgY29uIGxvcyBkZSBsYSBlbnRyYWRhIGN1YW5kbyBzZSBlbnRyZW7DsyBlbCBtb2RlbG8gZGUgcmVncmVzacOzbi48L2xpPjwvdWw+XCIsXG5cdFx0ZGltZW5zaW9uYWxNb3ZpbmdTdGF0aXN0aWNzTmFtZTogXCJFc3RhZMOtc3RpY2FzIG3Ds3ZpbGVzIGRpbWVuc2lvbmFsZXNcIixcblx0XHRkaW1lbnNpb25hbE1vdmluZ1N0YXRpc3RpY3NTbmlwOiBcIkNhbGN1bGEgZXN0YWTDrXN0aWNhcyBlbiB1bmEgdmVudGFuYSBtw7N2aWwgZGUgZGF0b3MgbXVsdGlkaW1lbnNpb25hbGVzIGEgbG8gbGFyZ28gZGUgdW5hIGRpbWVuc2nDs24gZXNwZWNpZmljYWRhLlwiLFxuXHRcdGRpbWVuc2lvbmFsTW92aW5nU3RhdGlzdGljc0Rlc2M6IFwiPHA+TGEgZnVuY2nDs24gRXN0YWTDrXN0aWNhIG3Ds3ZpbCBkaW1lbnNpb25hbCBjYWxjdWxhIHZhcmlhcyBlc3RhZMOtc3RpY2FzIGVuIHVuYSB2ZW50YW5hIHByZWRlZmluaWRhIGNvcnJlc3BvbmRpZW50ZSBhIHRvZG9zIGxvcyB2YWxvcmVzIGRlIGRpbWVuc2nDs24gYSBsbyBsYXJnbyBkZSB1bmEgZGltZW5zacOzbi4gRXN0YSBmdW5jacOzbiB0b21hIHVuYSBjYXBhIHLDoXN0ZXIgbXVsdGlkaW1lbnNpb25hbCBjb21vIGVudHJhZGEgeSBjcmVhIHVuYSBjYXBhIHLDoXN0ZXIgbXVsdGlkaW1lbnNpb25hbCBjb21vIHNhbGlkYSBxdWUgdGllbmVuIGVsIG1pc21vIHRhbWHDsW8gZGltZW5zaW9uYWwgcXVlIGxhIGNhcGEgZGUgZW50cmFkYS48L3A+PHA+UHVlZGUgZXNwZWNpZmljYXIgdW5hIGRpbWVuc2nDs24gcGFyYSBsYSBxdWUgc2UgdGllbmVuIGVuIGN1ZW50YSBsb3MgdmFsb3JlcyBkZSBkaW1lbnNpw7NuIGR1cmFudGUgZWwgY8OhbGN1bG8uIERlIGZvcm1hIHByZWRldGVybWluYWRhLCBzZSBjYWxjdWxhIGEgbG8gbGFyZ28gZGUgbGEgcHJpbWVyYSBkaW1lbnNpw7NuIG5vIGVzcGFjaWFsLiBUYW1iacOpbiBwdWVkZSBlc3BlY2lmaWNhciB1biB0YW1hw7FvIGRlIHZlbnRhbmEgZXNwZWNpZmljYW5kbyBsb3MgcGFyw6FtZXRyb3MgVmVudGFuYSByZWdyZXNpdmEgeSBWZW50YW5hIHByb2dyZXNpdmEuPC9wPjxwPkN1YW5kbyBUaXBvIGRlIGVzdGFkw61zdGljYXMgc2UgY29uZmlndXJhIGVuIFBlcmNlbnRpbCwgbG9zIHBhcsOhbWV0cm9zIFZhbG9yIGRlIHBlcmNlbnRpbCB5IFRpcG8gZGUgaW50ZXJwb2xhY2nDs24gZGUgcGVyY2VudGlsIHBhc2FuIGEgZXN0YXIgZGlzcG9uaWJsZXMuIFB1ZWRlIHV0aWxpemFyIGVzdG9zIHBhcsOhbWV0cm9zIHBhcmEgZXNwZWNpZmljYXIgZWwgcGVyY2VudGlsIHBhcmEgY2FsY3VsYXIgeSBlbGVnaXIgcmVzcGVjdGl2YW1lbnRlIGVsIHRpcG8gZGUgaW50ZXJwb2xhY2nDs24gcXVlIHNlIHZhIGEgdXRpbGl6YXIuIEN1YW5kbyBUaXBvIGRlIGVzdGFkw61zdGljYSBzZSBjb25maWd1cmEgZW4gTWVkaWEgY2lyY3VsYXIsIGVsIHBhcsOhbWV0cm8gVmFsb3IgZGUgZW52b2x0dXJhIGNpcmN1bGFyIHBhc2EgYSBlc3RhciBkaXNwb25pYmxlLiBFbCB2YWxvciBkZSBlbnZvbHR1cmEgY2lyY3VsYXIgc2UgdXRpbGl6YSBwYXJhIGNvbnZlcnRpciB1biB2YWxvciBsaW5lYWwgYWwgcmFuZ28gZGUgdW5hIG1lZGlhIGNpcmN1bGFyIGRldGVybWluYWRhLjwvcD5cIixcblx0XHR0ZXJyYWluRmxhdHRlbkZ1bmN0aW9uTmFtZTogXCJBcGxhbmFtaWVudG8gZGVsIHRlcnJlbm9cIixcblx0XHR0ZXJyYWluRmxhdHRlbkZ1bmN0aW9uU25pcDogXCJDb3JyaWdlIGxvcyBkYXRvcyBkZSBlbnRyYWRhIGRlIHJhZGFyIGRlIGFwZXJ0dXJhIHNpbnTDqXRpY2EgKFNBUikgcGFyYSBkZXRlY3RhciBkaXN0b3JzaW9uZXMgcmFkaW9tw6l0cmljYXMgZGViaWRhcyBhIGxhIHRvcG9ncmFmw61hLlwiLFxuXHRcdHRlcnJhaW5GbGF0dGVuRnVuY3Rpb25EZXNjOiBcIjxwPkxhIGZ1bmNpw7NuIHLDoXN0ZXIgQXBsYW5hbWllbnRvIGRlbCB0ZXJyZW5vIGNvcnJpZ2UgbG9zIGRhdG9zIGRlIGVudHJhZGEgZGUgcmFkYXIgZGUgYXBlcnR1cmEgc2ludMOpdGljYSAoU0FSKSBwYXJhIGRldGVjdGFyIGRpc3RvcnNpb25lcyByYWRpb23DqXRyaWNhcyBkZWJpZGFzIGEgbGEgdG9wb2dyYWbDrWEuPC9wPjxwPkxvcyBkYXRvcyBkZSByYWRhciBkZSBlbnRyYWRhIHNlIGRlYmVuIGNhbGlicmFyIHByaW1lcm8gZW4gYmV0YSBjZXJvLiBVdGlsaWNlIGxhIGhlcnJhbWllbnRhIEFwbGljYXIgY2FsaWJyYWNpw7NuIHJhZGlvbcOpdHJpY2EgcGFyYSBjYWxpYnJhciBsb3MgZGF0b3MgZGVsIHJhZGFyIGVuIGJldGEgY2Vyby48L3A+PHA+U2kgZWwgREVNIGRlIGVudHJhZGEgbm8gYWJhcmNhIHRvZG8gZWwgZGF0YXNldCBkZSBTQVIsIGxhIGhlcnJhbWllbnRhIGdlbmVyYXLDoSB2YWxvcmVzIE5vRGF0YSBwYXJhIGxvcyBww614ZWxlcyBmdWVyYSBkZSBsYSBleHRlbnNpw7NuIGRlbCBERU0gcGFyYSBsYXMgc2FsaWRhcyBkZSBnYW1tYSBjZXJvLCBzaWdtYSBjZXJvLCDDoXJlYSBkZSBkaXNwZXJzacOzbiB5IGRpc3RvcnNpw7NuIGdlb23DqXRyaWNhLiBQYXJhIGxhIHNhbGlkYSBkZSBtw6FzY2FyYSBkZSBkaXN0b3JzacOzbiBnZW9tw6l0cmljYSwgbGEgaGVycmFtaWVudGEgZ2VuZXJhcsOhIHZhbG9yZXMgbm8gZGV0ZXJtaW5hZG9zIHBhcmEgbG9zIHDDrXhlbGVzIGZ1ZXJhIGRlIGxhIGV4dGVuc2nDs24gZGVsIERFTS48L3A+PHA+RWwgREVNIGRlIGVudHJhZGEgZGViZSBlc3RhciBlbiBlbCBzaXN0ZW1hIGRlIGNvb3JkZW5hZGFzIGdlb2dyw6FmaWNhcyBXR1MgMTk4NCAoRVBTRzo0MzI2KS48L3A+XCIsXG5cdFx0Y3JlYXRlQ29sb3JDb21wb3NpdGVGdW5jdGlvbk5hbWU6IFwiQ3JlYXIgY29tcG9zaWNpw7NuIGRlIGNvbG9yXCIsXG5cdFx0Y3JlYXRlQ29sb3JDb21wb3NpdGVGdW5jdGlvblNuaXA6IFwiQ3JlYSB1biByw6FzdGVyIGRlIHRyZXMgYmFuZGFzIGEgcGFydGlyIGRlIHVuIGRhdGFzZXQgcsOhc3RlciBtdWx0aWJhbmRhIGVuIGVsIHF1ZSBjYWRhIGJhbmRhIHB1ZWRlIHV0aWxpemFyIHVuIGPDoWxjdWxvIGFsZ2VicmFpY28gZW4gZnVuY2nDs24gZGVsIMOhbGdlYnJhIGRlIGJhbmRhcy5cIixcblx0XHRjcmVhdGVDb2xvckNvbXBvc2l0ZUZ1bmN0aW9uRGVzYzogXCI8cD5MYSBmdW5jacOzbiByw6FzdGVyIENyZWFyIGNvbXBvc2ljacOzbiBkZSBjb2xvciBjcmVhIHVuIHLDoXN0ZXIgZGUgdHJlcyBiYW5kYXMgYSBwYXJ0aXIgZGUgdW4gZGF0YXNldCByw6FzdGVyIG11bHRpYmFuZGEgZW4gZWwgcXVlIGNhZGEgYmFuZGEgcHVlZGUgdXRpbGl6YXIgdW4gY8OhbGN1bG8gYWxnZWJyYWljbyBlbiBmdW5jacOzbiBkZWwgw6FsZ2VicmEgZGUgYmFuZGFzLjwvcD48cD5BbCBkZWZpbmlyIHVuIGFsZ29yaXRtbyBkZSBhcml0bcOpdGljYSBkZSBiYW5kYSwgcHVlZGUgaW50cm9kdWNpciB1bmEgZsOzcm11bGEgYWxnZWJyYWljYSBkZSBsw61uZWEgw7puaWNhIHBhcmEgY2FkYSBleHByZXNpw7NuIGNvbiBlbCBmaW4gZGUgY3JlYXIgdW5hIHNhbGlkYSBtdWx0aWJhbmRhLiBMb3Mgb3BlcmFkb3JlcyBhZG1pdGlkb3Mgc29uIHVuYXJpb3M6IHN1bWEgKCspLCByZXN0YSAoLSksIG11bHRpcGxpY2FjacOzbiAoKikgeSBkaXZpc2nDs24gKC8pLjwvcD48cD5BbCB1dGlsaXphciB1biBJZC4gZGUgYmFuZGEgZW4gdW5hIGV4cHJlc2nDs24sIGlkZW50aWZpcXVlIGxhIGJhbmRhIGFncmVnYW5kbyBlbCBwcmVmaWpvIEIgbyBiIGFsIG7Dum1lcm8gZGUgYmFuZGEuPC9wPjxwPlVuYSBjb21iaW5hY2nDs24gZGUgYmFuZGFzIGhhYml0dWFsIHV0aWxpemFkYSBwYXJhIHJhZGFyIGRlIGFwZXJ0dXJhIHNpbnTDqXRpY2EgKFNBUikgZW4gdW5pZGFkZXMgbGluZWFsZXMgZXMgVlYgcGFyYSByb2pvLCBWSCBwYXJhIHZlcmRlIHkgVlYvVkggcGFyYSBhenVsLiBTaSBsb3MgZGF0b3MgZGUgZW50cmFkYSBlc3TDoW4gZW4gZGVjaWJlbGlvcywgbGEgY29tYmluYWNpw7NuIGRlIGJhbmRhcyBkZWJlIHNlciBWViBwYXJhIHJvam8sIFZIIHBhcmEgdmVyZGUgeSBWVi1WSCBwYXJhIGF6dWwuPC9wPlwiLFxuXHRcdHN1cmZhY2VQYXJhbWV0ZXJzTmFtZTogXCJQYXLDoW1ldHJvcyBkZSBzdXBlcmZpY2llXCIsXG5cdFx0c3VyZmFjZVBhcmFtZXRlcnNTbmlwOiBcIkRldGVybWluYSBsb3MgcGFyw6FtZXRyb3MgZGUgdW4gcsOhc3RlciBkZSBzdXBlcmZpY2llIGNvbW8gbGEgb3JpZW50YWNpw7NuLCBsYSBwZW5kaWVudGUgeSB2YXJpb3MgdGlwb3MgZGUgY3VydmF0dXJhcyB1dGlsaXphbmRvIG3DqXRvZG9zIGdlb2TDqXNpY29zLlwiLFxuXHRcdHN1cmZhY2VQYXJhbWV0ZXJzRGVzYzogXCI8cD5MYSBmdW5jacOzbiBQYXLDoW1ldHJvcyBkZSBzdXBlcmZpY2llIGRldGVybWluYSBsb3MgcGFyw6FtZXRyb3MgZGUgdW4gcsOhc3RlciBkZSBzdXBlcmZpY2llIGNvbW8gbGEgb3JpZW50YWNpw7NuLCBsYSBwZW5kaWVudGUgeSB2YXJpb3MgdGlwb3MgZGUgY3VydmF0dXJhcyB1dGlsaXphbmRvIG3DqXRvZG9zIGdlb2TDqXNpY29zLjwvcD48cD5Fc3RhIGZ1bmNpw7NuIHNlIHB1ZWRlIHV0aWxpemFyIHBhcmEgbGFzIHNpZ3VpZW50ZXMgYXBsaWNhY2lvbmVzOjwvcD48dWw+PGxpPkNhbGN1bGFyIGxhIG9yaWVudGFjacOzbiB5IGxhIHBlbmRpZW50ZSB1dGlsaXphbmRvIG3DqXRvZG9zIGdlb2TDqXNpY29zLjwvbGk+PGxpPkNhbGN1bGFyIGRpc3RpbnRvcyB0aXBvcyBkZSBjdXJ2YXR1cmFzIGEgcGFydGlyIGRlIHVuIHLDoXN0ZXIgZGUgc3VwZXJmaWNpZSBkZSBlbnRyYWRhLCBwb3IgZWplbXBsbywgPHN0cm9uZz5DdXJ2YXR1cmEgdGFuZ2VuY2lhbCAoY3VydmEgZGUgbml2ZWwgbm9ybWFsKSw8L3N0cm9uZz4gcXVlIGNhcmFjdGVyaXphIGxhIGNvbnZlcmdlbmNpYSB0b3BvZ3LDoWZpY2EgeSBsYSBkaXZlcmdlbmNpYSBkZWwgZmx1am8gcG9yIGxhIHN1cGVyZmljaWUuPC9saT48L3VsPlwiLFxuXHRcdGxlYXN0Q29zdENvcnJpZG9yTmFtZTogXCJDb3JyZWRvciBkZSBtZW5vciBjb3N0ZVwiLFxuXHRcdGxlYXN0Q29zdENvcnJpZG9yU25pcDogXCJDYWxjdWxhIGxhIHN1bWEgZGUgZG9zIHLDoXN0ZXJlcyBkZSBjb3N0ZSBkZSBkaXN0YW5jaWEgYWN1bXVsYXRpdm8gY29uIGxhIG9wY2nDs24gZGUgYXBsaWNhciB1biB1bWJyYWwgYmFzYWRvIGVuIHVuIHBvcmNlbnRhamUgbyB1biBjb3N0ZSBhY3VtdWxhdGl2by5cIixcblx0XHRsZWFzdENvc3RDb3JyaWRvckRlc2M6IFwiPHA+TG9zIHLDoXN0ZXJlcyBkZSBlbnRyYWRhIGRlYmVuIHNlciBsYSBzYWxpZGEgZGUgcsOhc3RlcmVzIGRlIGFjdW11bGFjacOzbiBkZSBkaXN0YW5jaWEgeSBkaXJlY2Npw7NuIGhhY2lhIGF0csOhcyBkZXNkZSBsYSBmdW5jacOzbiA8c3Ryb25nPkFjdW11bGFjacOzbiBkZSBkaXN0YW5jaWE8L3N0cm9uZz4gbyA8c3Ryb25nPkFzaWduYWNpw7NuIGRlIGRpc3RhbmNpYTwvc3Ryb25nPi4gRGViZW4gYmFzYXJzZSBlbiBlbCBjb3N0ZS1kaXN0YW5jaWEgeSBzZSBkZWJlIHV0aWxpemFyIGxhIG1pc21hIGNvbmZpZ3VyYWNpw7NuIGRlIHBhcsOhbWV0cm9zIGFsIGNyZWFyIGxhcyBjYXBhcyBwYXJhIGNhZGEgb3JpZ2VuLiBFbiBsYSBjcmVhY2nDs24gZGUgZXN0b3MgcsOhc3RlcmVzIG5vIGRlYmVuIHV0aWxpemFyc2UgcGFyw6FtZXRyb3MgcXVlIGRlcGVuZGFuIGRlIGxhIGRpcmVjY2lvbmFsaWRhZCAoZmFjdG9yIGhvcml6b250YWwsIGZhY3RvciB2ZXJ0aWNhbCB5IGRpcmVjY2nDs24gZGVsIHZpYWplKS48L3A+PHA+TG9zIHZhbG9yZXMgZGVsIHLDoXN0ZXIgZGUgY29ycmVkb3IgZGUgc2FsaWRhIHNvbiBsYSBzdW1hIGRlbCBjb3N0ZSBhY3VtdWxhdGl2byBwYXJhIGFsY2FuemFyIHVuYSB1YmljYWNpw7NuIGRldGVybWluYWRhIGNvbiBsYXMgbWlzbWFzIHVuaWRhZGVzIHF1ZSBsb3MgcsOhc3RlcmVzIGRlIGNvc3RlLWRpc3RhbmNpYSBhY3VtdWxhdGl2byBkZSBlbnRyYWRhLjwvcD48cD5TaSB1biB2YWxvciBkZSA8c3Ryb25nPlVtYnJhbDwvc3Ryb25nPiBlc3BlY2lmaWNhZG8gZXMgbWF5b3IgcXVlIGVsIGNvc3RlIGFjdW11bGF0aXZvIG3DoXhpbW8gY3VhbmRvIHNlIHN1bWFuIGxvcyBkb3MgcsOhc3RlcmVzIGRlIGFjdW11bGFjacOzbiBkZSBkaXN0YW5jaWEsIGVsIHLDoXN0ZXIgZGUgY29ycmVkb3IgZGUgc2FsaWRhIGFiYXJjYXLDoSBsYSBtaXNtYSDDoXJlYSBxdWUgbG9zIHLDoXN0ZXJlcyBhY3VtdWxhdGl2b3MgZGUgZW50cmFkYS48L3A+PHA+U2kgdW4gdmFsb3IgZGUgdW1icmFsIGVzcGVjaWZpY2FkbyBlcyBtZW5vciBxdWUgZWwgdmFsb3IgbcOtbmltbyBkZWwgcsOhc3RlciBkZSBjb3JyZWRvciwgc2UgZGV2dWVsdmUgdW4gbWVuc2FqZSBkZSBhZHZlcnRlbmNpYSB5IGVsIHLDoXN0ZXIgZGUgc2FsaWRhIGVzdGFyw6EgdmFjw61vLjwvcD48cD5FbCByw6FzdGVyIGRlIGNvcnJlZG9yIGRlIHNhbGlkYSBwdWVkZSBjb250ZW5lciBjZWxkYXMgY29uIGNvc3RlcyBhY3VtdWxhdGl2b3MgbGlnZXJhbWVudGUgbWF5b3JlcyBxdWUgZWwgdmFsb3IgZGUgdW1icmFsLiBQcm9jZWRlIGRlIGxvcyByw6FzdGVyZXMgZGUgZGlyZWNjacOzbiBoYWNpYSBhdHLDoXMgcXVlIHV0aWxpemFuIGNlbGRhcyBxdWUgdGllbmVuIGFzaWduYWRvcyBjb3N0ZXMgbGlnZXJhbWVudGUgbWF5b3JlcyBxdWUgZWwgdW1icmFsIHBhcmEgY29uZWN0YXIgY2VsZGFzIGRlc2NvbmVjdGFkYXMgYWwgY29ycmVkb3IuPC9wPlwiLFxuXHRcdGdlb21ldHJpY01lZGlhbk5hbWU6IFwiTWVkaWFuYSBnZW9tw6l0cmljYVwiLFxuXHRcdGdlb21ldHJpY01lZGlhblNuaXA6IFwiTGEgZnVuY2nDs24gTWVkaWFuYSBnZW9tw6l0cmljYSBjYWxjdWxhIGxhIG1lZGlhbmEgZ2VvbcOpdHJpY2EgZW4gbG9zIHDDrXhlbGVzIGRlIHVuYSBzZXJpZSB0ZW1wb3JhbCBkZSBpbcOhZ2VuZXMgbXVsdGliYW5kYS5cIixcblx0XHRnZW9tZXRyaWNNZWRpYW5EZXNjOiBcIjxwPkVzdGEgZnVuY2nDs24gcmVkdWNlIGVsIHJ1aWRvIHkgbG9zIHZhbG9yZXMgYXTDrXBpY29zIGVuIGltw6FnZW5lcyBkZSBzZXJpZSB0ZW1wb3JhbCBjYWxjdWxhbmRvIHVuIHDDrXhlbCBkZSBtZWRpYW5hIGdlb23DqXRyaWNhIHBhcmEgY2FkYSBtYXRyaXogZGUgcMOteGVsZXMgZW4gbGEgcGlsYSBkZSBpbcOhZ2VuZXMuIEVsIGFsZ29yaXRtbyBtYW50aWVuZSBsYXMgcmVsYWNpb25lcyBlc3BlY3RyYWxlcyBlbnRyZSBsYXMgYmFuZGFzIGRlbCBlc3BlY3RybyBkZSBww614ZWxlcywgZGUgbW9kbyBxdWUgbGEgc2FsaWRhIHNlIHB1ZWRlIHV0aWxpemFyIGVuIGFuw6FsaXNpcywgY29tbyBsb3Mgw61uZGljZXMgZGUgdmVnZXRhY2nDs24uPC9wPjxwPkxhcyBudWJlcyB5IHNvbWJyYXMgZGViZW4gZW5tYXNjYXJhcnNlIGNvbiBsYSBiYW5kYSBkZSBRQSBkZWwgZGF0YXNldCBhbnRlcyBkZSBhcGxpY2FyIGVzdGEgZnVuY2nDs24uPC9wPjxwPlNpIGxhIGltYWdlbiBkZSBlbnRyYWRhIGVzIGRlIHB1bnRvIGZsb3RhbnRlLCBjb21vIHVuYSByZWZsZWN0YW5jaWEgZGUgc3VwZXJmaWNpZSBjb24gdmFsb3JlcyBlbnRyZSAwIHkgMSwgdW4gdmFsb3IgZGUgw6lwc2lsb24gZGUgMCwwMDEgZGViZXLDrWEgcHJvZHVjaXIgcmVzdWx0YWRvcyBkZSBjYWxpZGFkLjwvcD5cIlxuXHR9LFxuXHRyZnhBcmdzOiB7XG5cdFx0cmFzdGVyTmFtZTogXCJDYWxjdWxhZG9yYSByw6FzdGVyXCIsXG5cdFx0Y29sb3JTY2hlbWVUeXBlTmFtZTogXCJUaXBvIGRlIGVzcXVlbWEgZGUgY29sb3Jlc1wiLFxuXHRcdGNvbG9ybWFwTmFtZTogXCJNYXBhIGRlIGNvbG9yXCIsXG5cdFx0Y29sb3JtYXBOYW1lTmFtZTogXCJOb21icmUgZGUgbWFwYSBkZSBjb2xvclwiLFxuXHRcdGNvbG9yUmFtcE5hbWU6IFwiUmFtcGEgZGUgY29sb3JcIixcblx0XHRjb250cmFzdE9mZnNldE5hbWU6IFwiRGVzcGxhemFtaWVudG8gZGUgY29udHJhc3RlXCIsXG5cdFx0YnJpZ2h0bmVzc09mZnNldE5hbWU6IFwiRGVzcGxhemFtaWVudG8gZGUgYnJpbGxvXCIsXG5cdFx0bWV0aG9kTmFtZTogXCJNw6l0b2RvXCIsXG5cdFx0YmFuZE5hbWVzTmFtZTogXCJOb21icmVzIGRlIGJhbmRhXCIsXG5cdFx0YmFuZFdhdmVsZW5ndGhzTmFtZTogXCJMb25naXR1ZGVzIGRlIG9uZGEgZGUgYmFuZGFzXCIsXG5cdFx0YmFuZElkc05hbWU6IFwiSWQuIGRlIGJhbmRhXCIsXG5cdFx0bWlzc2luZ0JhbmRBY3Rpb25OYW1lOiBcIkFjY2nDs24gZGUgYmFuZGEgYXVzZW50ZVwiLFxuXHRcdGNvbnZlcnNpb25QYXJhbWV0ZXJzTmFtZTogXCJQYXLDoW1ldHJvcyBkZSBjb252ZXJzacOzblwiLFxuXHRcdGhpbGxzaGFkZVR5cGVOYW1lOiBcIlRpcG8gc29tYnJlYWRvXCIsXG5cdFx0YXppbXV0aE5hbWU6IFwiQWNpbXV0XCIsXG5cdFx0YWx0aXR1ZGVOYW1lOiBcIkFsdGl0dWRcIixcblx0XHRzbG9wZVR5cGVOYW1lOiBcIkVzY2FsYWRvXCIsXG5cdFx0ekZhY3Rvck5hbWU6IFwiRmFjdG9yIFpcIixcblx0XHRQU1Bvd2VyTmFtZTogXCJQb3RlbmNpYSBkZSB0YW1hw7FvIGRlIHDDrXhlbFwiLFxuXHRcdFBTWkZhY3Rvck5hbWU6IFwiRmFjdG9yIGRlIHRhbWHDsW8gZGUgcMOteGVsZXNcIixcblx0XHRyZW1vdmVFZGdlRWZmZWN0TmFtZTogXCJEZXNoYWJpbGl0YXIgaW50ZXJwb2xhY2nDs24gZGUgcMOteGVsZXMgZGUgYm9yZGUgcHJlZGV0ZXJtaW5hZGFcIixcblx0XHRmcm9tVW5pdE5hbWU6IFwiVW5pZGFkIGRlIG9yaWdlblwiLFxuXHRcdHRvVW5pdE5hbWU6IFwiVW5pZGFkIGRlIGRlc3Rpbm9cIixcblx0XHRyYXN0ZXJUeXBlTmFtZTogXCJUaXBvXCIsXG5cdFx0bWluTmFtZTogXCJNw61uaW1vIGRlIHNhbGlkYVwiLFxuXHRcdG1heE5hbWU6IFwiTcOheGltbyBkZSBzYWxpZGFcIixcblx0XHRtaW5QZXJjZW50TmFtZTogXCJNw61uaW1vIGRlIHBvcmNlbnRhamUgZGUgcmVjb3J0ZVwiLFxuXHRcdG1heFBlcmNlbnROYW1lOiBcIk3DoXhpbW8gZGUgcG9yY2VudGFqZSBkZSByZWNvcnRlXCIsXG5cdFx0bnVtYmVyT2ZTdGFuZGFyZERldmlhdGlvbk5hbWU6IFwiTsO6bWVybyBkZSBkZXN2aWFjaW9uZXMgZXN0w6FuZGFyXCIsXG5cdFx0c2lnbW9pZFN0cmVuZ3RoTGV2ZWxOYW1lOiBcIk5pdmVsIGRlIGZ1ZXJ6YSBzaWdtb2lkZWFcIixcblx0XHRlc3RpbWF0ZVN0YXRzSGlzdG9ncmFtTmFtZTogXCJFc3RpbWFyIGVzdGFkw61zdGljYXNcIixcblx0XHREUkFOYW1lOiBcIkFqdXN0ZSBkZSByYW5nbyBkaW7DoW1pY29cIixcblx0XHRzdGF0aXN0aWNzTmFtZTogXCJFc3RhZMOtc3RpY2FzXCIsXG5cdFx0aGlzdG9ncmFtc05hbWU6IFwiSGlzdG9ncmFtYXNcIixcblx0XHRzdGF0aXN0aWNzSGlzdG9ncmFtTmFtZTogXCJEZWZpbmlyIGVzdGFkw61zdGljYXMgZSBoaXN0b2dyYW1hXCIsXG5cdFx0Y29tcHV0ZUdhbW1hTmFtZTogXCJHYW1tYSBhdXRvbcOhdGljb1wiLFxuXHRcdHVzZUdhbW1hTmFtZTogXCJVc2FyIGdhbW1hXCIsXG5cdFx0Z2FtbWFOYW1lOiBcIkdhbW1hXCIsXG5cdFx0aW5wdXROYW1lc05hbWU6IFwiTm9tYnJlc1wiLFxuXHRcdGV4cHJlc3Npb25OYW1lOiBcIkV4cHJlc2nDs25cIixcblx0XHRjZWxsc2l6ZVR5cGVOYW1lOiBcIlRpcG8gZGUgdGFtYcOxbyBkZSBjZWxkYVwiLFxuXHRcdGV4dGVudFR5cGVOYW1lOiBcIlRpcG8gZGUgZXh0ZW5zacOzblwiLFxuXHRcdGNsYXNzaWZpZXJEZWZpbml0aW9uRmlsZU5hbWU6IFwiQXJjaGl2byBkZSBkZWZpbmljacOzbiBkZSBlbnRyYWRhXCIsXG5cdFx0cmFzdGVyMU5hbWU6IFwiUsOhc3RlciAxXCIsXG5cdFx0cmFzdGVyMk5hbWU6IFwiUsOhc3RlciAyXCIsXG5cdFx0cmFzdGVyM05hbWU6IFwiUsOhc3RlciAzXCIsXG5cdFx0dHJ1ZVJhc3Rlck5hbWU6IFwiUsOhc3RlciB2ZXJkYWRlcm9cIixcblx0XHRmYWxzZVJhc3Rlck5hbWU6IFwiUsOhc3RlciBmYWxzb1wiLFxuXHRcdG5vRGF0YUludGVycHJldGF0aW9uTmFtZTogXCJJbnRlcnByZXRhY2nDs24gZGUgTm9EYXRhXCIsXG5cdFx0bm9EYXRhVmFsdWVzTmFtZTogXCJWYWxvcmVzIGRlIE5vRGF0YVwiLFxuXHRcdGluY2x1ZGVkUmFuZ2VzTmFtZTogXCJSYW5nb3MgaW5jbHVpZG9zXCIsXG5cdFx0Y3VydmF0dXJlVHlwZU5hbWU6IFwiVGlwbyBkZSBjdXJ2YXR1cmFcIixcblx0XHRyYXN0ZXJzTmFtZTogXCJSw6FzdGVyZXNcIixcblx0XHRhdHRyaWJ1dGVUYWJsZU5hbWU6IFwiVGFibGFcIixcblx0XHRhdHRyaWJ1dGVUYWJsZVR5cGVOYW1lOiBcIlRpcG8gZGUgdGFibGFcIixcblx0XHRyb3dzTmFtZTogXCJOw7ptZXJvIGRlIGZpbGFzXCIsXG5cdFx0Y29sdW1uc05hbWU6IFwiTsO6bWVybyBkZSBjb2x1bW5hc1wiLFxuXHRcdGtlcm5lbE5hbWU6IFwiS2VybmVsXCIsXG5cdFx0bWlycm9yRWRnZXNOYW1lOiBcIlJlZmxlamFyIGJvcmRlc1wiLFxuXHRcdGluZmx1ZW5jZXNOYW1lOiBcIkluZmx1ZW5jaWFzXCIsXG5cdFx0ZmllbGRzTmFtZTogXCJDYW1wb3NcIixcblx0XHRyZW1hcHNOYW1lOiBcIlZvbHZlciBhIHJlcHJlc2VudGFyIGxhIHRhYmxhXCIsXG5cdFx0ZXZhbEZyb21OYW1lOiBcIkVzY2FsYSBkZSBldmFsdWFjacOzbiBpbmljaWFsXCIsXG5cdFx0ZXZhbFRvTmFtZTogXCJFc2NhbGEgZGUgZXZhbHVhY2nDs24gZmluYWxcIixcblx0XHR3ZWlnaHRzTmFtZTogXCJQZXNvc1wiLFxuXHRcdERFTU5hbWU6IFwiREVNXCIsXG5cdFx0c2hvcnRSYW5nZUlEV1JhZGl1c05hbWU6IFwiUmFkaW8gZGUgSURXIGRlIGNvcnRvIGFsY2FuY2VcIixcblx0XHRtYXhWb2lkV2lkdGhOYW1lOiBcIkFuY2hvIG3DoXguIGRlIHZhY8Otb1wiLFxuXHRcdHNpZ21hR2F1c3NpYW5OYW1lOiBcIkFsaXNhZG8gYWRhcHRhYmxlXCIsXG5cdFx0Y29udG91clR5cGVOYW1lOiBcIlRpcG8gZGUgY3VydmEgZGUgbml2ZWxcIixcblx0XHR6QmFzZU5hbWU6IFwiQmFzZSBaXCIsXG5cdFx0bnVtYmVyT2ZDb250b3Vyc05hbWU6IFwiQ2FudGlkYWQgZGUgY3VydmFzIGRlIG5pdmVsXCIsXG5cdFx0Y29udG91ckludGVydmFsTmFtZTogXCJJbnRlcnZhbG8gZGUgY3VydmFzIGRlIG5pdmVsXCIsXG5cdFx0bnRoQ29udG91ckxpbmVJbkJvbGROYW1lOiBcIkzDrW5lYSBkZSBjb250b3JubyBOIGVuIG5lZ3JpdGFcIixcblx0XHRmZWF0dXJlQ2xhc3NOYW1lOiBcIkVudGlkYWRlcyBkZSBlbnRyYWRhXCIsXG5cdFx0Y2xhc3NJbmRleEZpZWxkTmFtZTogXCJDYW1wb1wiLFxuXHRcdHJlc29sdmVPdmVybGFwTWV0aG9kTmFtZTogXCJNw6l0b2RvIFJlc29sdmVyIHN1cGVycG9zaWNpw7NuXCIsXG5cdFx0cmVzYW1wbGluZ1R5cGVOYW1lOiBcIlRpcG8gZGUgcmVtdWVzdHJlb1wiLFxuXHRcdGlucHV0Q2VsbHNpemVOYW1lOiBcIlRhbWHDsW8gZGUgY2VsZGEgZGUgZW50cmFkYVwiLFxuXHRcdG91dHB1dENlbGxzaXplTmFtZTogXCJUYW1hw7FvIGRlIGNlbGRhIGRlIHNhbGlkYVwiLFxuXHRcdHBvaW50RmVhdHVyZUNsYXNzTmFtZTogXCJQdW50b3MgaW5pY2lhbGVzXCIsXG5cdFx0bWF4R3Jvd3RoUmFkaXVzRmllbGROYW1lOiBcIkNhbXBvIGRlIHJhZGlvIGRlIGNyZWNpbWllbnRvIG3DoXhpbW9cIixcblx0XHRzaW1pbGFyaXR5VGhyZXNob2xkRmllbGROYW1lOiBcIkNhbXBvIGRlIHVtYnJhbCBkZSBzaW1pbGl0dWRcIixcblx0XHRmaWxsVmFsdWVGaWVsZE5hbWU6IFwiQ2FtcG8gZGUgdmFsb3IgZGUgcmVsbGVub1wiLFxuXHRcdHNwZWN0cmFsRGV0YWlsTmFtZTogXCJEZXRhbGxlIGVzcGVjdHJhbCBbMS4uMjBdXCIsXG5cdFx0c3BhdGlhbERldGFpbE5hbWU6IFwiRGV0YWxsZSBlc3BhY2lhbCBbMS4uMjBdXCIsXG5cdFx0bWluTnVtUGl4ZWxzUGVyU2VnbWVudE5hbWU6IFwiVGFtYcOxbyBkZSBzZWdtZW50byBtw61uaW1vIGVuIHDDrXhlbGVzXCIsXG5cdFx0Ym91bmRhcmllc09ubHlOYW1lOiBcIlNvbG8gbMOtbWl0ZXMgZGUgc2VnbWVudG9cIixcblx0XHRzdGF0aXN0aWNzVHlwZU5hbWU6IFwiVGlwbyBkZSBlc3RhZMOtc3RpY2FzXCIsXG5cdFx0ZmlsbE5vRGF0YU9ubHlOYW1lOiBcIlJlbGxlbmFyIHNvbG8gcMOteGVsZXMgTm9EYXRhXCIsXG5cdFx0aW5wdXREYXRhVHlwZU5hbWU6IFwiVGlwbyBkZSBkYXRvcyBkZSBlbnRyYWRhXCIsXG5cdFx0YW5nbGVSZWZlcmVuY2VTeXN0ZW1OYW1lOiBcIlNpc3RlbWEgZGUgcmVmZXJlbmNpYSBhbmd1bGFyXCIsXG5cdFx0b3V0cHV0RGF0YVR5cGVOYW1lOiBcIlRpcG8gZGUgRGF0b3MgZGUgU2FsaWRhXCIsXG5cdFx0aW5wdXRTYW1wbGVQb2ludEZlYXR1cmVDbGFzc05hbWU6IFwiTXVlc3RyYXMgZGUgZW50cmFkYVwiLFxuXHRcdHZhbHVlRmllbGROYW1lOiBcIkNhbXBvIGRlIHZhbG9yXCIsXG5cdFx0cmFzdGVySW5mb05hbWU6IFwiSW5mb3JtYWNpw7NuIGRlIHLDoXN0ZXJcIixcblx0XHRpbnRlcnBvbGF0aW9uTWV0aG9kTmFtZTogXCJNw6l0b2RvIGRlIGludGVycG9sYWNpw7NuXCIsXG5cdFx0cmFkaXVzTmFtZTogXCJSYWRpb1wiLFxuXHRcdHJhZGlhbmNlR2FpblZhbHVlc05hbWU6IFwiR2FuYW5jaWEgZGUgcmFkaWFuY2lhXCIsXG5cdFx0cmFkaWFuY2VCaWFzVmFsdWVzTmFtZTogXCJTZXNnbyBkZSByYWRpYW5jaWFcIixcblx0XHRyZWZsZWN0ZWRHYWluVmFsdWVzTmFtZTogXCJHYW5hbmNpYSBkZSByZWZsZWN0YW5jaWFcIixcblx0XHRyZWZsZWN0ZWRCaWFzVmFsdWVzTmFtZTogXCJTZXNnbyBkZSByZWZsZWN0YW5jaWFcIixcblx0XHRzdW5FbGV2YXRpb25OYW1lOiBcIkVsZXZhY2nDs24gZGVsIHNvbCAoZ3JhZG9zKVwiLFxuXHRcdGFsYmVkb05hbWU6IFwiQWxiZWRvXCIsXG5cdFx0c2NhbGVGYWN0b3JOYW1lOiBcIkZhY3RvciBkZSBlc2NhbGFcIixcblx0XHRvZmZzZXROYW1lOiBcIkRlc3BsYXphbWllbnRvXCIsXG5cdFx0dGhyZXNob2xkVHlwZU5hbWU6IFwiVGlwbyBkZSB1bWJyYWxcIixcblx0XHR0aHJlc2hvbGRzTmFtZTogXCJVbWJyYWxlc1wiLFxuXHRcdHVuZGVmaW5lZENsYXNzTmFtZTogXCJDbGFzZSBzaW4gZGVmaW5pclwiLFxuXHRcdG1pblZhbHVlTmFtZTogXCJNw61uLlwiLFxuXHRcdG1heFZhbHVlTmFtZTogXCJNw6F4LlwiLFxuXHRcdG9wZXJhdGlvbk5hbWU6IFwiT3BlcmFjacOzblwiLFxuXHRcdGNsaXBwaW5nVHlwZU5hbWU6IFwiVGlwbyBkZSBjbGlwcGluZ1wiLFxuXHRcdGNsaXBwaW5nR2VvbWV0cnlOYW1lOiBcIkdlb21ldHLDrWEvcsOhc3RlciBkZSByZWNvcnRlXCIsXG5cdFx0ZXh0ZW50TmFtZTogXCJFeHRlbnNpw7NuIGRlIHNhbGlkYVwiLFxuXHRcdHVzZUlucHV0RmVhdHVyZUdlb21ldHJ5TmFtZTogXCJVdGlsaXphciBlbnRpZGFkZXMgZGUgZW50cmFkYSBwYXJhIHJlY29ydGFyIGdlb21ldHLDrWFcIixcblx0XHRyZW1hcERlZmluaXRpb25UeXBlTmFtZTogXCJUaXBvIGRlIGRlZmluaWNpw7NuIGRlIG51ZXZhIHJlcHJlc2VudGFjacOzbiBjYXJ0b2dyw6FmaWNhXCIsXG5cdFx0aW5wdXRSYW5nZU5hbWU6IFwiUmFuZ29zIGRlIGVudHJhZGFcIixcblx0XHRvdXRwdXRWYWx1ZXNOYW1lOiBcIlZhbG9yZXMgZGUgc2FsaWRhXCIsXG5cdFx0bm9EYXRhUmFuZ2VOYW1lOiBcIlJhbmdvcyBkZSBOb0RhdGFcIixcblx0XHRpbnB1dEZpZWxkTmFtZTogXCJDYW1wbyBkZSBlbnRyYWRhXCIsXG5cdFx0b3V0cHV0RmllbGROYW1lOiBcIkNhbXBvIGRlIHNhbGlkYVwiLFxuXHRcdGlucHV0TWF4RmllbGROYW1lOiBcIkNhbXBvIGRlIG3DoXguIGRlIGVudHJhZGEgKG9wY2lvbmFsKVwiLFxuXHRcdHJlbWFwVGFibGVUeXBlTmFtZTogXCJUaXBvIGRlIHRhYmxhIGRlIG51ZXZhIHJlcHJlc2VudGFjacOzbiBjYXJ0b2dyw6FmaWNhXCIsXG5cdFx0YWxsb3dVbm1hdGNoZWROYW1lOiBcIlBlcm1pdGlyIHZhbG9yZXMgZGUgcMOteGVsIHNpbiBjb25jb3JkYW5jaWFcIixcblx0XHRjaGFuZ2VNaXNzaW5nVmFsdWVzVG9Ob0RhdGFOYW1lOiBcIkNhbWJpYXIgbG9zIHZhbG9yZXMgYXVzZW50ZXMgcG9yIE5vRGF0YVwiLFxuXHRcdHZpc2libGVCYW5kSUROYW1lOiBcIklkLiBkZSBiYW5kYSB2aXNpYmxlXCIsXG5cdFx0aW5mcmFyZWRCYW5kSUROYW1lOiBcIklkLiBkZSBiYW5kYSBpbmZyYXJyb2phXCIsXG5cdFx0c2NpZW50aWZpY091dHB1dE5hbWU6IFwiU2FsaWRhIGNpZW50w61maWNhXCIsXG5cdFx0YmFuZEluZGV4ZXNOYW1lOiBcIsONbmRpY2VzIGRlIGJhbmRhXCIsXG5cdFx0Y29uc3RhbnROYW1lOiBcIkNvbnN0YW50ZVwiLFxuXHRcdHdlaWdodE5hbWU6IFwiUGVzb1wiLFxuXHRcdG1pbmltdW1OYW1lOiBcIk3DrW5pbW9cIixcblx0XHRtYXhpbXVtTmFtZTogXCJNw6F4aW1vXCIsXG5cdFx0c291cmNlRGF0YU5hbWU6IFwiUsOhc3RlciBkZSBvcmlnZW5cIixcblx0XHRzb3VyY2VGaWVsZE5hbWU6IFwiQ2FtcG8gZGUgb3JpZ2VuXCIsXG5cdFx0Y29zdFJhc3Rlck5hbWU6IFwiUsOhc3RlciBkZSBjb3N0ZXNcIixcblx0XHRtYXhEaXN0YW5jZU5hbWU6IFwiRGlzdGFuY2lhIG3DoXhpbWFcIixcblx0XHR2YWx1ZVJhc3Rlck5hbWU6IFwiUsOhc3RlciBkZSB2YWxvclwiLFxuXHRcdGNvc3RNdWx0aXBsaWVyTmFtZTogXCJNdWx0aXBsaWNhZG9yIHBhcmEgYXBsaWNhciBhIGxvcyBjb3N0ZXNcIixcblx0XHRzdGFydENvc3ROYW1lOiBcIkNvc3RlIGluaWNpYWxcIixcblx0XHRhY2N1bUNvc3RSZXNpc3RhbmNlUmF0ZU5hbWU6IFwiVGFzYSBkZSByZXNpc3RlbmNpYSBkZWwgY29zdGUgYWN1bXVsYWRvXCIsXG5cdFx0Y2FwYWNpdHlOYW1lOiBcIkNhcGFjaWRhZFwiLFxuXHRcdHRyYXZlbERpcmVjdGlvbk5hbWU6IFwiRGlyZWNjacOzbiBkZWwgdmlhamVcIixcblx0XHRjZWxsU2l6ZU5hbWU6IFwiVGFtYcOxbyBkZSBjZWxkYVwiLFxuXHRcdHBvcHVsYXRpb25GaWVsZE5hbWU6IFwiQ2FtcG8gZGUgcG9ibGFjacOzblwiLFxuXHRcdGFyZWFVbml0c05hbWU6IFwiVW5pZGFkZXMgZGUgw6FyZWFcIixcblx0XHRvdXRwdXRWYWx1ZVR5cGVOYW1lOiBcIlZhbG9yZXMgZGUgY2VsZGEgZGUgc2FsaWRhXCIsXG5cdFx0YmFycmllcnNOYW1lOiBcIkJhcnJlcmFzIGRlIGVudHJhZGFcIixcblx0XHRkZXN0aW5hdGlvbkRhdGFOYW1lOiBcIlLDoXN0ZXIgZGUgZGVzdGlub1wiLFxuXHRcdGRlc3RpbmF0aW9uRmllbGROYW1lOiBcIkNhbXBvIGRlIGRlc3Rpbm9cIixcblx0XHRwYXRoVHlwZU5hbWU6IFwiVGlwbyBkZSBydXRhXCIsXG5cdFx0b2JzZXJ2ZXJGZWF0dXJlc05hbWU6IFwiRW50aWRhZGVzIGRlIG9ic2VydmFkb3JcIixcblx0XHRhbmFseXNpc01ldGhvZE5hbWU6IFwiTcOpdG9kbyBkZSBhbsOhbGlzaXNcIixcblx0XHRhbmFseXNpc1R5cGVOYW1lOiBcIlRpcG8gZGUgYW7DoWxpc2lzXCIsXG5cdFx0dmVydGljYWxFcnJvck5hbWU6IFwiRXJyb3IgdmVydGljYWxcIixcblx0XHRyZWZyYWN0aXZpdHlDb2VmZmljaWVudE5hbWU6IFwiQ29lZmljaWVudGUgZGUgcmVmcmFjY2nDs25cIixcblx0XHRzdXJmYWNlT2Zmc2V0TmFtZTogXCJEZXNwbGF6YW1pZW50byBkZSBzdXBlcmZpY2llXCIsXG5cdFx0b2JzZXJ2ZXJFbGV2YXRpb25OYW1lOiBcIkVsZXZhY2nDs24gZGUgb2JzZXJ2YWRvclwiLFxuXHRcdG9ic2VydmVyT2Zmc2V0TmFtZTogXCJEZXNwbGF6YW1pZW50byBkZSBvYnNlcnZhZG9yXCIsXG5cdFx0aW5uZXJSYWRpdXNOYW1lOiBcIlJhZGlvIGludGVybm9cIixcblx0XHRpbm5lclJhZGl1c0lzM0REaXN0YW5jZU5hbWU6IFwiRWwgcmFkaW8gaW50ZXJubyBlcyB1bmEgZGlzdGFuY2lhIDNEXCIsXG5cdFx0b3V0ZXJSYWRpdXNOYW1lOiBcIlJhZGlvIGV4dGVybm9cIixcblx0XHRvdXRlclJhZGl1c0lzM0REaXN0YW5jZU5hbWU6IFwiRWwgcmFkaW8gZXh0ZXJubyBlcyB1bmEgZGlzdGFuY2lhIDNEXCIsXG5cdFx0aG9yaXpvbnRhbFN0YXJ0QW5nbGVOYW1lOiBcIsOBbmd1bG8gZGUgaW5pY2lvIGhvcml6b250YWxcIixcblx0XHRob3Jpem9udGFsRW5kQW5nbGVOYW1lOiBcIsOBbmd1bG8gZGUgZmluYWxpemFjacOzbiBob3Jpem9udGFsXCIsXG5cdFx0dmVydGljYWxVcHBlckFuZ2xlTmFtZTogXCLDgW5ndWxvIHN1cGVyaW9yIHZlcnRpY2FsXCIsXG5cdFx0dmVydGljYWxMb3dlckFuZ2xlTmFtZTogXCLDgW5ndWxvIGluZmVyaW9yIHZlcnRpY2FsXCIsXG5cdFx0em9uZURhdGFOYW1lOiBcIlLDoXN0ZXIgZGUgem9uYVwiLFxuXHRcdHpvbmVGaWVsZE5hbWU6IFwiQ2FtcG8gZGUgem9uYVwiLFxuXHRcdGlnbm9yZU5vRGF0YU5hbWU6IFwiSWdub3JhciBsb3MgTm9EYXRhIGVuIGxvcyBjw6FsY3Vsb3NcIixcblx0XHR0ZW1wZXJhdHVyZVJhc3Rlck5hbWU6IFwiUsOhc3RlciBkZSB0ZW1wZXJhdHVyYVwiLFxuXHRcdGluVGVtcGVyYXR1cmVVbml0c05hbWU6IFwiVW5pZGFkZXMgZGUgdGVtcGVyYXR1cmFcIixcblx0XHRvdXRIZWF0SW5kZXhUZW1wZXJhdHVyZVVuaXRzTmFtZTogXCJVbmlkYWRlcyBkZSDDrW5kaWNlIGRlIGNhbG9yXCIsXG5cdFx0cmVsYXRpdmVIdW1pZGl0eVJhc3Rlck5hbWU6IFwiUsOhc3RlciBkZSBodW1lZGFkIHJlbGF0aXZhXCIsXG5cdFx0b3V0V2luZENoaWxsVGVtcGVyYXR1cmVVbml0c05hbWU6IFwiVW5pZGFkZXMgZGUgc2Vuc2FjacOzbiB0w6lybWljYVwiLFxuXHRcdHdpbmRTcGVlZFJhc3Rlck5hbWU6IFwiUsOhc3RlciBkZSB2ZWxvY2lkYWQgZGVsIHZpZW50b1wiLFxuXHRcdGluV2luZFNwZWVkVW5pdHNOYW1lOiBcIlVuaWRhZGVzIGRlIHZlbG9jaWRhZCBkZWwgdmllbnRvXCIsXG5cdFx0dmFsdWVOYW1lOiBcIlZhbG9yXCIsXG5cdFx0cHJvcGVydHlOYW1lOiBcIk5vbWJyZSBkZSBQcm9waWVkYWRlc1wiLFxuXHRcdGpzb25OYW1lOiBcIkpTT04gZGUgbWV0YWRhdG9zXCIsXG5cdFx0em9uZVRhYmxlTmFtZTogXCJUYWJsYSBkZSBhdHJpYnV0b3Mgem9uYWxlc1wiLFxuXHRcdGF0dHJpYnV0ZUZpZWxkTmFtZXM6IFwiTm9tYnJlcyBkZSBjYW1wbyBkZSBhdHJpYnV0b1wiLFxuXHRcdGJhY2tncm91bmROYW1lOiBcIlZhbG9yIGRlIGZvbmRvXCIsXG5cdFx0d2hlcmVDbGF1c2VOYW1lOiBcIkNsw6F1c3VsYSBXaGVyZVwiLFxuXHRcdG1pbmltdW1WYWx1ZUZpZWxkTmFtZTogXCJOb21icmUgZGUgY2FtcG8gZGUgdmFsb3IgbcOtbmltb1wiLFxuXHRcdG1heGltdW1WYWx1ZUZpZWxkTmFtZTogXCJOb21icmUgZGUgY2FtcG8gZGUgdmFsb3IgbcOheGltb1wiLFxuXHRcdG91dFZhbHVlRmllbGROYW1lOiBcIk5vbWJyZSBkZSBjYW1wbyBkZSB2YWxvciBkZSBzYWxpZGFcIixcblx0XHRkZWZhdWx0VmFsdWVOYW1lOiBcIlZhbG9yIGRlIHNhbGlkYSBwcmVkZXRlcm1pbmFkb1wiLFxuXHRcdGNvbnZlcnNpb25NYXRyaXhOYW1lOiBcIk1hdHJpeiBkZSBjb252ZXJzacOzblwiLFxuXHRcdElzUHNldWRvQ29sb3JPdXRwdXROYW1lOiBcIkVzIHVuYSBzYWxpZGEgZW4gcHNldWRvY29sb3JcIixcblx0XHR1bm1hcHBlZEFzUmFuZG9tQ29sb3JOYW1lOiBcIkFzaWduYXIgY29sb3IgYWxlYXRvcmlhbWVudGUgYSBww614ZWxlcyBubyBhc2lnbmFkb3NcIixcblx0XHRkaXN0YW5jZU1ldGhvZE5hbWU6IFwiTcOpdG9kbyBkZSBkaXN0YW5jaWFcIixcblx0XHRmbG93RGlyUmFzdGVyTmFtZTogXCJSw6FzdGVyIGRlIGRpcmVjY2nDs24gZGUgZmx1am9cIixcblx0XHRwb3VyUG9pbnROYW1lOiBcIlLDoXN0ZXIgZGUgcHVudG9zIGRlIGZsdWlkZXpcIixcblx0XHRwb3VyUG9pbnRGaWVsZE5hbWU6IFwiQ2FtcG8gZGUgcHVudG8gZGUgZmx1aWRlelwiLFxuXHRcdGNvbnN0YW50Wk5hbWU6IFwiWiBjb25zdGFudGVcIixcblx0XHR6T2Zmc2V0TmFtZTogXCJEZXNwbGF6YW1pZW50byBaXCIsXG5cdFx0Z2VvSWROYW1lOiBcIkdlb2lkZVwiLFxuXHRcdGNhbGlicmF0aW9uVHlwZU5hbWU6IFwiVGlwbyBkZSBjYWxpYnJhY2nDs25cIixcblx0XHRmaWx0ZXJUeXBlTmFtZTogXCJUaXBvIGRlIGZpbHRyb1wiLFxuXHRcdGZpbHRlclNpemVOYW1lOiBcIlRhbWHDsW8gZGUgZmlsdHJvXCIsXG5cdFx0bm9pc2VNb2RlbE5hbWU6IFwiTW9kZWxvIGRlIHJ1aWRvXCIsXG5cdFx0bm9pc2VWYXJpYW5jZU5hbWU6IFwiVmFyaWFuemEgZGUgcnVpZG9cIixcblx0XHRhZGRpdGl2ZU5vaXNlTWVhbk5hbWU6IFwiTWVkaWEgZGUgcnVpZG8gYWRpdGl2b1wiLFxuXHRcdG11bHRpcGxpY2F0aXZlTm9pc2VNZWFuTmFtZTogXCJNZWRpYSBkZSBydWlkbyBtdWx0aXBsaWNhdGl2b1wiLFxuXHRcdG51bWJlcm9mTG9va3NOYW1lOiBcIkNhbnRpZGFkIGRlIGFzcGVjdG9zXCIsXG5cdFx0ZGFtcGluZ0ZhY3Rvck5hbWU6IFwiRmFjdG9yIGRlIHZhY2lhZG9cIixcblx0XHRtYXNrUmFzdGVyTmFtZTogXCJSw6FzdGVyIGRlIG3DoXNjYXJhXCIsXG5cdFx0bmliYmxlVmFsdWVzTmFtZTogXCJVdGlsaXphciBsb3MgdmFsb3JlcyBOb0RhdGEgc2kgc29uIGxvcyBkZWwgdmVjaW5vIG3DoXMgcHLDs3hpbW8gKG5lYXJlc3QgbmVpZ2hib3IpXCIsXG5cdFx0bmliYmxlTm9EYXRhTmFtZTogXCJDZWxkYXMgTm9EYXRhIGRlIE5pYmJsZVwiLFxuXHRcdHpMaW1pdE5hbWU6IFwiTMOtbWl0ZSBaXCIsXG5cdFx0Zmxvd0RpcmVjdGlvblR5cGVOYW1lOiBcIlRpcG8gZGUgZGlyZWNjacOzbiBkZSBmbHVqb1wiLFxuXHRcdHdlaWdodFJhc3Rlck5hbWU6IFwiUsOhc3RlciBkZSBwZXNvXCIsXG5cdFx0Zm9yY2VFZGdlTmFtZTogXCJGb3J6YXIgdG9kYXMgbGFzIGNlbGRhcyBkZSBlamUgcGFyYSBxdWUgc2UgZGVzcGxhY2VuIGhhY2lhIGZ1ZXJhXCIsXG5cdFx0c3RyZWFtUmFzdGVyTmFtZTogXCJSw6FzdGVyIGRlIGN1cnNvIGRlIGFndWFcIixcblx0XHRzdXJmYWNlUmFzdGVyTmFtZTogXCJSw6FzdGVyIGRlIHN1cGVyZmljaWVcIixcblx0XHRjb252ZXJzaW9uVHlwZTogXCJUaXBvIGRlIGNvbnZlcnNpw7NuXCIsXG5cdFx0ZGlzdGFuY2VSYXN0ZXIxOiBcIlLDoXN0ZXIgZGUgZGlzdGFuY2lhIDFcIixcblx0XHRkaXN0YW5jZVJhc3RlcjI6IFwiUsOhc3RlciBkZSBkaXN0YW5jaWEgMlwiLFxuXHRcdGNvc3REaXN0YW5jZVJhc3RlcjogXCJSw6FzdGVyIGRlIGNvc3RlLWRpc3RhbmNpYVwiLFxuXHRcdGNvc3RCYWNrbGlua1Jhc3RlcjogXCJSw6FzdGVyIGRlIHbDrW5jdWxvIGRlIG1lbm9yIGNvc3RlXCIsXG5cdFx0b3ZlcnJpZGVzTmFtZTogXCJJbnZhbGlkYWNpb25lc1wiLFxuXHRcdGZpZWxkTmFtZTogXCJDYW1wb1wiLFxuXHRcdHNpZ25hdHVyZUZpbGVPclVybDogXCJBcmNoaXZvIGRlIGZpcm1hIG8gVVJMXCIsXG5cdFx0cmVkTmFtZTogXCJSb2pvXCIsXG5cdFx0Z3JlZW5OYW1lOiBcIlZlcmRlXCIsXG5cdFx0Ymx1ZU5hbWU6IFwiQXp1bFwiLFxuXHRcdGluZnJhcmVkTmFtZTogXCJJbmZyYXJyb2pvXCIsXG5cdFx0cGFuY2hyb21hdGljTmFtZTogXCJQYW5jcm9tw6F0aWNvXCIsXG5cdFx0bXVsdGlzcGVjdHJhbE5hbWU6IFwiTXVsdGllc3BlY3RyYWxcIixcblx0XHRwYW5zaGFycGVuaW5nVHlwZTogXCJUaXBvIGRlIHJlZmluYWRvIHBhbmNyb23DoXRpY29cIixcblx0XHRzZW5zb3JOYW1lOiBcIlNlbnNvclwiLFxuXHRcdHNwYXRpYWxSZWZlcmVuY2VOYW1lOiBcIlJlZmVyZW5jaWEgZXNwYWNpYWxcIixcblx0XHR4Q2VsbHNpemVOYW1lOiBcIlRhbWHDsW8gZGUgY2VsZGEgWFwiLFxuXHRcdHlDZWxsc2l6ZU5hbWU6IFwiVGFtYcOxbyBkZSBjZWxkYSBZXCIsXG5cdFx0eE9yaWdpbk5hbWU6IFwiUHVudG8gZGUgcmVnaXN0cm8gWFwiLFxuXHRcdHlPcmlnaW5OYW1lOiBcIlB1bnRvIGRlIHJlZ2lzdHJvIFlcIixcblx0XHRwZXJjZW50aWxlTmFtZTogXCJWYWxvciBkZSBwZXJjZW50aWxcIixcblx0XHRuZWlnaGJvcmhvb2RUeXBlOiBcIlRpcG8gZGUgdmVjaW5kYWRcIixcblx0XHR3aWR0aE5hbWU6IFwiQW5jaG9cIixcblx0XHRoZWlnaHROYW1lOiBcIkFsdHVyYVwiLFxuXHRcdHN0YXJ0QW5nbGVOYW1lOiBcIsOBbmd1bG8gaW5pY2lhbFwiLFxuXHRcdGVuZEFuZ2xlTmFtZTogXCLDgW5ndWxvIGZpbmFsXCIsXG5cdFx0bmVpZ2hib3Job29kVmFsdWVzOiBcIlZhbG9yZXMgdmVjaW5vc1wiLFxuXHRcdGhvcml6b250YWxSYXN0ZXI6IFwiUsOhc3RlciBob3Jpem9udGFsXCIsXG5cdFx0aG9yaXpvbnRhbEZhY3RvcjogXCJGYWN0b3JlcyBob3Jpem9udGFsZXNcIixcblx0XHR2ZXJ0aWNhbFJhc3RlcjogXCJSw6FzdGVyIHZlcnRpY2FsXCIsXG5cdFx0dmVydGljYWxGYWN0b3I6IFwiRmFjdG9yIHZlcnRpY2FsXCIsXG5cdFx0c3RyZWFtUmFzdGVyOiBcIlLDoXN0ZXIgZGUgY3Vyc28gZGUgYWd1YVwiLFxuXHRcdGZsb3dEaXJSYXN0ZXI6IFwiUsOhc3RlciBkZSBkaXJlY2Npw7NuIGRlIGZsdWpvXCIsXG5cdFx0bnVtYmVyTmVpZ2hib3JDZWxsczogXCJDYW50aWRhZCBkZSBjZWxkYXMgdmVjaW5hc1wiLFxuXHRcdHpvbmVDb25uZWN0aXZpdHk6IFwiQ29uZWN0aXZpZGFkIGRlIHpvbmFcIixcblx0XHRhZGRMaW5rQmVoYXZpb3I6IFwiQWdyZWdhciB2w61uY3Vsb1wiLFxuXHRcdGV4Y2x1ZGVkVmFsdWU6IFwiVmFsb3IgZXhjbHVpZG9cIixcblx0XHRjb25zdGFudEZpbGxDaGVjazogXCJHZW5lcmFyIHLDoXN0ZXIgZGUgcmVsbGVubyBhIHBhcnRpciBkZSBjb25zdGFudGVcIixcblx0XHRmaWxsUmFzdGVyOiBcIlLDoXN0ZXIgZGUgcmVsbGVub1wiLFxuXHRcdGNvbnN0YW50RmlsbFZhbHVlOiBcIlZhbG9yIGNvbnN0YW50ZVwiLFxuXHRcdGlucHV0Qml0UG9zaXRpb25zOiBcIkJpdCBkZSBlbnRyYWRhXCIsXG5cdFx0b3V0cHV0Qml0UG9zaXRpb25zOiBcIkJpdCBkZSBzYWxpZGFcIixcblx0XHRkaXN0YW5jZVR5cGVOYW1lOiBcIlRpcG8gZGUgZGlzdGFuY2lhXCIsXG5cdFx0YmFycmllckRhdGFOYW1lOiBcIkJhcnJlcmFzIGRlIHLDoXN0ZXJcIixcblx0XHRwb3VyUG9pbnREYXRhTmFtZTogXCJSw6FzdGVyIGRlIHB1bnRvcyBkZSBmbHVpZGV6XCIsXG5cdFx0YWNjdW11bGF0aW9uUmFzdGVyTmFtZTogXCJSw6FzdGVyIGRlIGFjdW11bGFjacOzbiBkZSBmbHVqb1wiLFxuXHRcdHNuYXBEaXN0YW5jZU5hbWU6IFwiRGlzdGFuY2lhIGRlIGFsaW5lYWNpw7NuXCIsXG5cdFx0b3JkZXJNZXRob2ROYW1lOiBcIk3DqXRvZG8gZGUgb3JkZW5hY2nDs25cIixcblx0XHRkaXJlY3Rpb25NZWFzdXJlbWVudE5hbWU6IFwiRGlyZWNjacOzbiBkZSBtZWRpY2nDs25cIixcblx0XHRwcm9jZXNzQXNNdWx0aWJhbmQ6IFwiUHJvY2VzYXIgY29tbyBtdWx0aWJhbmRhXCIsXG5cdFx0cHJvY2Vzc011bHRpZGltZW5zaW9uYWw6IFwiUHJvY2VzYXIgY29tbyBtdWx0aWRpbWVuc2lvbmFsXCIsXG5cdFx0Zm9yY2VGbG93RGlyZWN0aW9uQ29udmVudGlvbjogXCJGb3J6YXIgY29udmVuY2nDs24gZGUgZGlyZWNjacOzbiBkZWwgZmx1am8gcGFyYSByw6FzdGVyIGRlIHbDrW5jdWxvXCIsXG5cdFx0aW5pdGlhbEFjY3VtdWxhdGlvbjogXCJBY3VtdWxhY2nDs24gaW5pY2lhbFwiLFxuXHRcdG1heGltdW1BY2N1bXVsYXRpb246IFwiQWN1bXVsYWNpw7NuIG3DoXhpbWFcIixcblx0XHRzb3VyY2VMb2NhdGlvbkJhbmRzOiBcIkdlbmVyYXIgZmlsYSB5IGNvbHVtbmEgZGUgb3JpZ2VuIGNvbW8gYmFuZGFzIGFkaWNpb25hbGVzIGVuIGxhIHNhbGlkYVwiLFxuXHRcdGJhY2tEaXJlY3Rpb25CYW5kOiBcIkdlbmVyYXIgZGlyZWNjacOzbiBoYWNpYSBhdHLDoXMgY29tbyBiYW5kYSBhZGljaW9uYWwgZW4gbGEgc2FsaWRhXCIsXG5cdFx0bnVtYmVyT2ZDZWxsczogXCJOw7ptZXJvIGRlIGNlbGRhc1wiLFxuXHRcdHpvbmVWYWx1ZXM6IFwiVmFsb3JlcyBkZSB6b25hXCIsXG5cdFx0c2hyaW5rTWV0aG9kOiBcIk3DqXRvZG8gRW5jb2dlclwiLFxuXHRcdGV4cGFuZE1ldGhvZDogXCJNw6l0b2RvIGRlIGV4cGFuc2nDs25cIixcblx0XHRpbnB1dFNwZWN0cmFsUHJvZmlsZVR5cGU6IFwiVGlwbyBkZSBwZXJmaWwgZXNwZWN0cmFsXCIsXG5cdFx0c3BlY3RyYWxQcm9maWxlRmlsZU5hbWU6IFwiUGVyZmlsIGVzcGVjdHJhbFwiLFxuXHRcdHRyYWluaW5nRmVhdHVyZUZpbGVOYW1lOiBcIkVudGlkYWQgZGUgZW50cmVuYW1pZW50b1wiLFxuXHRcdG5vbk5lZ2F0aXZlOiBcIk5vIG5lZ2F0aXZvXCIsXG5cdFx0c3VtVG9PbmU6IFwiU3VtYXIgdW5vXCIsXG5cdFx0cmFuZG9tRGlzdHJpYnV0aW9uOiBcIkRpc3RyaWJ1Y2nDs25cIixcblx0XHRtZWFuTmFtZTogXCJWYWxvciBtZWRpb1wiLFxuXHRcdHByb2JhYmlsaXR5TmFtZTogXCJQcm9iYWJpbGlkYWRcIixcblx0XHRhbHBoYU5hbWU6IFwiQWxmYVwiLFxuXHRcdGJldGFOYW1lOiBcIkJldGFcIixcblx0XHRyTmFtZTogXCJyXCIsXG5cdFx0bk5hbWU6IFwiTlwiLFxuXHRcdHNlZWQ6IFwiVmFsb3IgZGUgaW5pY2lhbGl6YWNpw7NuXCIsXG5cdFx0cmFuZG9tTnVtYmVyR2VuZXJhdG9yOiBcIkdlbmVyYWRvciBkZSBuw7ptZXJvcyBhbGVhdG9yaW9zXCIsXG5cdFx0Y2VsbEZhY3RvcjogXCJGYWN0b3IgZGUgY2VsZGFcIixcblx0XHRhZ2dyZWdhdGlvblR5cGU6IFwiVMOpY25pY2EgZGUgYWdyZWdhY2nDs25cIixcblx0XHRleHRlbnRIYW5kbGluZzogXCJBbXBsaWFyIGxhIGV4dGVuc2nDs24gc2kgZXMgbmVjZXNhcmlvXCIsXG5cdFx0dHJlbmRBbmFseXNpc0RpbWVuc2lvbk5hbWU6IFwiTm9tYnJlIGRlIGRpbWVuc2nDs25cIixcblx0XHR0cmVuZEFuYWx5c2lzVHlwZTogXCJUaXBvIGRlIHRlbmRlbmNpYVwiLFxuXHRcdGhhcm1vbmljRnJlcXVlbmN5OiBcIkZyZWN1ZW5jaWEgYXJtw7NuaWNhXCIsXG5cdFx0cG9seW5vbWlhbE9yZGVyOiBcIk9yZGVuIHBvbGluw7NtaWNvXCIsXG5cdFx0Y3ljbGVMZW5ndGhOYW1lOiBcIkxvbmdpdHVkIGRlbCBjaWNsb1wiLFxuXHRcdHRyZW5kQW5hbHlzaXNSTVNFOiBcIlJNU0VcIixcblx0XHR0cmVuZEFuYWx5c2lzUjI6IFwiUiBjdWFkcmFkb1wiLFxuXHRcdHRyZW5kQW5hbHlzaXNTbG9wZVBWYWx1ZTogXCJWYWxvciBQIGRlbCBjb2VmaWNpZW50ZSBkZSBwZW5kaWVudGVcIixcblx0XHR0cmVuZEFuYWx5c2lzU2Vhc29uYWxQZXJpb2Q6IFwiUGVyaW9kbyBlc3RhY2lvbmFsXCIsXG5cdFx0Y3ljbGVVbml0TmFtZTogXCJVbmlkYWQgZGUgY2ljbG9cIixcblx0XHRwcmVkaWN0RGltZW5zaW9uVmFsdWVzOiBcIlZhbG9yZXNcIixcblx0XHRkaW1lbnNpb25EZWZpbml0aW9uVHlwZTogXCJEZWZpbmljacOzbiBkZSBkaW1lbnNpw7NuXCIsXG5cdFx0cHJlZGljdERpbWVuc2lvblN0YXJ0OiBcIkNvbWVuemFyXCIsXG5cdFx0cHJlZGljdERpbWVuc2lvbkVuZDogXCJGaW5cIixcblx0XHRwcmVkaWN0RGltZW5zaW9uSW50ZXJ2YWw6IFwiSW50ZXJ2YWxvIGRlIHZhbG9yXCIsXG5cdFx0ZGltZW5zaW9uVW5pdDogXCJVbmlkYWRcIixcblx0XHRpbnRlcnBvbGF0aW9uQ2VsbHNpemVOYW1lOiBcIlRhbWHDsW8gZGUgY2VsZGEgZGUgaW50ZXJwb2xhY2nDs25cIixcblx0XHR2YXJpYWJsZU5hbWU6IFwiVmFyaWFibGVzXCIsXG5cdFx0ZGltZW5zaW9ubGVzc05hbWU6IFwiU2luIGRpbWVuc2nDs25cIixcblx0XHRtZGltRGVmaW5pdGlvbjogXCJEZWZpbmljacOzbiBkZSBkaW1lbnNpw7NuXCIsXG5cdFx0ZGltZW5zaW9uTmFtZTogXCJEaW1lbnNpw7NuXCIsXG5cdFx0aXRlcmF0aW9uU3RhcnQ6IFwiSW5pY2lvIGRlIGxhIHByaW1lcmEgaXRlcmFjacOzblwiLFxuXHRcdGl0ZXJhdGlvbkVuZDogXCJGaW5hbCBkZSBsYSBwcmltZXJhIGl0ZXJhY2nDs25cIixcblx0XHRpbnRlcnZhbFN0YXJ0OiBcIkluaWNpbyBkZSBpbnRlcnZhbG9cIixcblx0XHRpbnRlcnZhbEVuZDogXCJGaW4gZGUgaW50ZXJ2YWxvXCIsXG5cdFx0c3RlcE5hbWU6IFwiUGFzb1wiLFxuXHRcdHJhbmdlc05hbWU6IFwiUmFuZ29zXCIsXG5cdFx0bWluVmFsdWU6IFwiVmFsb3IgbcOtbmltb1wiLFxuXHRcdG1heFZhbHVlOiBcIlZhbG9yIG3DoXhpbW9cIixcblx0XHRjaGFuZ2VBbmFseXNpc1Jhc3Rlck5hbWU6IFwiUsOhc3RlciBkZSBhbsOhbGlzaXMgZGUgY2FtYmlvc1wiLFxuXHRcdGNoYW5nZVR5cGVOYW1lOiBcIkNhbWJpYXIgdGlwb1wiLFxuXHRcdHNlZ21lbnREYXRlOiBcIkZlY2hhIGRlbCBzZWdtZW50b1wiLFxuXHRcdGNoYW5nZURpcmVjdGlvbk5hbWU6IFwiQ2FtYmlhciBkaXJlY2Npw7NuXCIsXG5cdFx0bWF4TnVtQ2hhbmdlc05hbWU6IFwiTsO6bWVybyBtw6F4aW1vIGRlIGNhbWJpb3NcIixcblx0XHRmaWx0ZXJCeVllYXI6IFwiRmlsdHJhciBwb3IgYcOxb1wiLFxuXHRcdG1pbmltdW1ZZWFyOiBcIlZhbG9yIE3DrW5pbW9cIixcblx0XHRtYXhpbXVtWWVhcjogXCJWYWxvciBNw6F4aW1vXCIsXG5cdFx0ZmlsdGVyQnlEdXJhdGlvbjogXCJGaWx0cmFyIHBvciBkdXJhY2nDs25cIixcblx0XHRtaW5pbXVtRHVyYXRpb246IFwiRHVyYWNpw7NuIG3DrW5pbWFcIixcblx0XHRtYXhpbXVtRHVyYXRpb246IFwiRHVyYWNpw7NuIG3DoXhpbWFcIixcblx0XHRmaWx0ZXJCeU1hZ25pdHVkZTogXCJGaWx0cmFyIHBvciBtYWduaXR1ZFwiLFxuXHRcdG1pbmltdW1NYWduaXR1ZGU6IFwiTWFnbml0dWQgbcOtbmltYVwiLFxuXHRcdG1heGltdW1NYWduaXR1ZGU6IFwiTWFnbml0dWQgbcOheGltYVwiLFxuXHRcdGZpbHRlckJ5U3RhcnRWYWx1ZTogXCJGaWx0cmFyIHBvciB2YWxvciBkZSBpbmljaW9cIixcblx0XHRtaW5pbXVtU3RhcnRWYWx1ZTogXCJWYWxvciBkZSBpbmljaW8gbcOtbmltb1wiLFxuXHRcdG1heGltdW1TdGFydFZhbHVlOiBcIlZhbG9yIGRlIGluaWNpbyBtw6F4aW1vXCIsXG5cdFx0ZmlsdGVyQnlFbmRWYWx1ZTogXCJGaWx0cmFyIHBvciB2YWxvciBmaW5hbFwiLFxuXHRcdG1pbmltdW1FbmRWYWx1ZTogXCJWYWxvciBmaW5hbCBtw61uaW1vXCIsXG5cdFx0bWF4aW11bUVuZFZhbHVlOiBcIlZhbG9yIGZpbmFsIG3DoXhpbW9cIixcblx0XHRtb2RlbFR5cGVOYW1lOiBcIlRpcG8gZGUgbW9kZWxvXCIsXG5cdFx0ZnJvbVJhc3Rlck5hbWU6IFwiRGUgcsOhc3RlclwiLFxuXHRcdHRvUmFzdGVyTmFtZTogXCJBIHLDoXN0ZXJcIixcblx0XHRjb21wdXRlQ2hhbmdlTWV0aG9kOiBcIk3DqXRvZG8gZGUgY8OhbGN1bG8gZGVsIGNhbWJpb1wiLFxuXHRcdGZyb21DbGFzc1ZhbHVlczogXCJWYWxvcmVzIGRlIGNsYXNlIGRlc2RlIChFamVtcGxvOiAyIDUpXCIsXG5cdFx0dG9DbGFzc1ZhbHVlczogXCJWYWxvcmVzIGRlIGNsYXNlIGhhc3RhIChFamVtcGxvOiAyIDUpXCIsXG5cdFx0a2VlcE1ldGhvZDogXCJNw6l0b2RvIGRlIGZpbHRyYWRvXCIsXG5cdFx0dXNlQ29sb3JNZXRob2Q6IFwiRGVmaW5pciBjb2xvcmVzIGRlIHRyYW5zaWNpw7NuXCIsXG5cdFx0ZGV0ZWN0Q2hhbmdlQmFuZHM6IFwiQmFuZGFzIHBhcmEgZGV0ZWN0YXIgY2FtYmlvcyAoZW1wZXphciBlbiAwKVwiLFxuXHRcdHRtYXNrQmFuZHM6IFwiQmFuZGFzIHBhcmEgZWwgZW5tYXNjYXJhbWllbnRvIHRlbXBvcmFsIChlbXBlemFyIGVuIDApXCIsXG5cdFx0Y2hpU3F1YXJlZFRocmVzaG9sZDogXCJVbWJyYWwgZGUgY2hpIGN1YWRyYWRvIHBhcmEgZGV0ZWN0YXIgY2FtYmlvc1wiLFxuXHRcdG1pbkFub21hbHk6IFwiT2JzZXJ2YWNpb25lcyBkZSBhbm9tYWzDrWFzIGNvbnNlY3V0aXZhcyBtw61uaW1hc1wiLFxuXHRcdHVwZGF0aW5nRnJlcXVlbmN5OiBcIkFjdHVhbGl6YW5kbyBsYSBmcmVjdWVuY2lhIGRlIGFqdXN0ZSAoZW4gYcOxb3MpXCIsXG5cdFx0ZGlzdGFuY2VBY2N1bXVsYXRpb25SYXN0ZXJOYW1lOiBcIlLDoXN0ZXIgZGUgYWN1bXVsYWNpw7NuIGRlIGRpc3RhbmNpYVwiLFxuXHRcdGNvc3RCYWNrZGlyZWN0aW9uUmFzdGVyTmFtZTogXCJSw6FzdGVyIGRlIGRpcmVjY2nDs24gZGUgZmx1am8gbyBkaXJlY2Npw7NuIGhhY2lhIGF0csOhc1wiLFxuXHRcdHJhc3RlckNvbGxlY3Rpb25OYW1lOiBcIkNvbGVjY2nDs24gZGUgcsOhc3RlcmVzXCIsXG5cdFx0aXRlbUZ1bmN0aW9uTmFtZTogXCJGdW5jacOzbiBkZSBlbGVtZW50b1wiLFxuXHRcdGFnZ3JlZ2F0aW9uRnVuY3Rpb25OYW1lOiBcIkZ1bmNpw7NuIGRlIGNvbnNvbGlkYWNpw7NuXCIsXG5cdFx0cHJvY2Vzc2luZ0Z1bmN0aW9uTmFtZTogXCJGdW5jacOzbiBkZSBwcm9jZXNhbWllbnRvXCIsXG5cdFx0YWdncmVnYXRpb25EZWZpbml0aW9uTmFtZTogXCJEZWZpbmljacOzbiBkZSBhZ3JlZ2FjacOzblwiLFxuXHRcdHF1ZXJ5R2VvbWV0cnlOYW1lOiBcIkdlb21ldHLDrWEgZGUgY29uc3VsdGFzXCIsXG5cdFx0ZmFjdG9yRnVuY3Rpb25aZXJvRmFjdG9yOiBcIkZhY3RvciBjZXJvXCIsXG5cdFx0ZmFjdG9yRnVuY3Rpb25DdXRBbmdsZTogXCLDgW5ndWxvIGRlIGNvcnRlXCIsXG5cdFx0ZmFjdG9yRnVuY3Rpb25TaWRlRmFjdG9yOiBcIkZhY3RvciBkZSBsYWRvXCIsXG5cdFx0ZmFjdG9yRnVuY3Rpb25TbG9wZTogXCJQZW5kaWVudGVcIixcblx0XHRmYWN0b3JGdW5jdGlvbkxvd0N1dEFuZ2xlOiBcIsOBbmd1bG8gZGUgY29ydGUgYmFqb1wiLFxuXHRcdGZhY3RvckZ1bmN0aW9uSGlnaEN1dEFuZ2xlOiBcIsOBbmd1bG8gZGUgY29ydGUgYWx0b1wiLFxuXHRcdGZhY3RvckZ1bmN0aW9uQ29zUG93ZXI6IFwiUG90ZW5jaWEgZGUgY29zZW5vXCIsXG5cdFx0ZmFjdG9yRnVuY3Rpb25TZWNQb3dlcjogXCJQb3RlbmNpYSBkZSBzZWNhbnRlXCIsXG5cdFx0ZmFjdG9yRnVuY3Rpb25UYWJsZVBhdGg6IFwiUnV0YSBkZSB0YWJsYVwiLFxuXHRcdHByb2Nlc3NpbmdCYW5kOiBcIkJhbmRhIGRlIHByb2Nlc2FtaWVudG9cIixcblx0XHRwcm9jZXNzaW5nQmFuZE5hbWU6IFwiTm9tYnJlIGRlIGxhIGJhbmRhIGRlIHByb2Nlc2FtaWVudG9cIixcblx0XHRzbmFwcGluZ0RhdGU6IFwiRmVjaGEgZGUgYWxpbmVhY2nDs25cIixcblx0XHRtYXhOdW1TZWdtZW50czogXCJOw7ptZXJvIG3DoXhpbW8gZGUgc2VnbWVudG9zXCIsXG5cdFx0dmVydGV4Q291bnRPdmVyc2hvb3Q6IFwiQXJjbyBjb2xnYW50ZSBkZSBjb250ZW8gZGUgdsOpcnRpY2VzXCIsXG5cdFx0c3Bpa2VUaHJlc2hvbGQ6IFwiVW1icmFsIGRlIHBpY29cIixcblx0XHRyZWNvdmVyeVRocmVzaG9sZDogXCJVbWJyYWwgZGUgcmVjdXBlcmFjacOzblwiLFxuXHRcdG1pbk51bU9iczogXCJDYW50aWRhZCBtw61uaW1hIGRlIG9ic2VydmFjaW9uZXNcIixcblx0XHRwVmFsdWVUaHJlc2hvbGQ6IFwiVW1icmFsIGRlIHZhbG9yIFBcIixcblx0XHRiZXN0TW9kZWxQcm9wb3J0aW9uOiBcIk1lam9yIHByb3BvcmNpw7NuIGRlIG1vZGVsb1wiLFxuXHRcdHByZXZlbnRPbmVZZWFyUmVjb3Zlcnk6IFwiUHJldmVuaXIgcmVjdXBlcmFjacOzbiBkZSB1biBhw7FvXCIsXG5cdFx0cmVjb3ZlcnlJbmNyZWFzZVRyZW5kOiBcIlJlY3VwZXJhY2nDs24gY29uIHRlbmRlbmNpYSBlbiBhdW1lbnRvXCIsXG5cdFx0b3V0cHV0T3RoZXJCYW5kczogXCJTYWxpZGEgb3RyYXMgYmFuZGFzXCIsXG5cdFx0c29ydFR5cGU6IFwiVGlwbyBkZSBvcmRlbmFjacOzblwiLFxuXHRcdG51bWJlck9mUnVuczogXCJFamVjdXRhciBsYSBleHBhbnNpw7NuIHkgZWwgYWNvcnRhbWllbnRvIGVuIGFtYm9zIHNlbnRpZG9zXCIsXG5cdFx0cGVyY2VudGlsZVZhbHVlOiBcIlZhbG9yIGRlIHBlcmNlbnRpbFwiLFxuXHRcdHBlcmNlbnRpbGVJbnRlcnBvbGF0aW9uVHlwZTogXCJUaXBvIGRlIGludGVycG9sYWNpw7NuIHBlcmNlbnRpbFwiLFxuXHRcdHJhc3RlckluZm9Qcm9wZXJ0eTogXCJQcm9waWVkYWRcIixcblx0XHRyYXN0ZXJJbmZvVmFsdWU6IFwiVmFsb3JcIixcblx0XHRyYXN0ZXJJbmZvQ29sdW1uczogXCJDb2x1bW5hc1wiLFxuXHRcdHJhc3RlckluZm9Sb3dzOiBcIkZpbGFzXCIsXG5cdFx0cmFzdGVySW5mb0JhbmRDb3VudDogXCJOw7ptZXJvIGRlIGJhbmRhc1wiLFxuXHRcdHJhc3RlckluZm9QaXhlbFNpemVYOiBcIlRhbWHDsW8gZGUgY2VsZGEgWFwiLFxuXHRcdHJhc3RlckluZm9QaXhlbFNpemVZOiBcIlRhbWHDsW8gZGUgY2VsZGEgWVwiLFxuXHRcdHJhc3RlckluZm9QaXhlbFR5cGU6IFwiVGlwbyBkZSBww614ZWxcIixcblx0XHRyYXN0ZXJFeHRlbnRUb3A6IFwiQXJyaWJhXCIsXG5cdFx0cmFzdGVyRXh0ZW50Qm90dG9tOiBcIkFiYWpvXCIsXG5cdFx0cmFzdGVyRXh0ZW50TGVmdDogXCJJenF1aWVyZGFcIixcblx0XHRyYXN0ZXJFeHRlbnRSaWdodDogXCJEZXJlY2hhXCIsXG5cdFx0cmFzdGVyU3RhdGlzdGljc05vdENhbGN1bGF0ZWQ6IFwiTm8gc2UgaGFuIGNhbGN1bGFkbyBsYXMgZXN0YWTDrXN0aWNhcy5cIixcblx0XHRzcGF0aWFsUmVmZXJlbmNlUHJvamVjdGlvbjogXCJQcm95ZWNjacOzblwiLFxuXHRcdHNwYXRpYWxSZWZlcmVuY2VXa2lkOiBcIldLSURcIixcblx0XHRzcGF0aWFsUmVmZXJlbmNlTGF0ZXN0V2tpZDogXCJXS0lEIGFudGVyaW9yXCIsXG5cdFx0c3BhdGlhbFJlZmVyZW5jZVdrdDogXCJXS1RcIixcblx0XHRzcGF0aWFsUmVmZXJlbmNlVmNzV2tpZDogXCJWQ1NXS0lEXCIsXG5cdFx0c3BhdGlhbFJlZmVyZW5jZUxhdGVzdFZjc1draWQ6IFwiVkNTV0tJRCBhbnRlcmlvclwiLFxuXHRcdHNwYXRpYWxSZWZlcmVuY2VBdXRob3JpdHk6IFwiQXV0b3JpZGFkXCIsXG5cdFx0c3BhdGlhbFJlZmVyZW5jZUxpbmVhclVuaXQ6IFwiVW5pZGFkIGxpbmVhbFwiLFxuXHRcdHNwYXRpYWxSZWZlcmVuY2VBbmd1bGFyVW5pdDogXCJVbmlkYWQgYW5ndWxhclwiLFxuXHRcdHNwYXRpYWxSZWZlcmVuY2VGYWxzZUVhc3Rpbmc6IFwiRmFsc28gRXN0ZVwiLFxuXHRcdHNwYXRpYWxSZWZlcmVuY2VGYWxzZU5vcnRoaW5nOiBcIkZhbHNvIE5vcnRlXCIsXG5cdFx0c3BhdGlhbFJlZmVyZW5jZUNlbnRyYWxNZXJpZGlhbjogXCJNZXJpZGlhbm8gY2VudHJhbFwiLFxuXHRcdHNwYXRpYWxSZWZlcmVuY2VQcmltZU1lcmlkaWFuOiBcIk1lcmlkaWFubyBiYXNlXCIsXG5cdFx0c3BhdGlhbFJlZmVyZW5jZVN0YW5kYXJkUGFyYWxsZWwxOiBcIlBhcmFsZWxvIGVzdMOhbmRhciAxXCIsXG5cdFx0c3BhdGlhbFJlZmVyZW5jZVN0YW5kYXJkUGFyYWxsZWwyOiBcIlBhcmFsZWxvIGVzdMOhbmRhciAyXCIsXG5cdFx0c3BhdGlhbFJlZmVyZW5jZUxhdGl0dWRlT2ZPcmlnaW46IFwiTGF0aXR1ZCBkZSBvcmlnZW5cIixcblx0XHRzcGF0aWFsUmVmZXJlbmNlQXV4aWxpYXJ5U3BoZXJlVHlwZTogXCJUaXBvIGRlIGVzZmVyYSBhdXhpbGlhclwiLFxuXHRcdHNwYXRpYWxSZWZlcmVuY2VEYXR1bTogXCJEYXR1bVwiLFxuXHRcdHNwYXRpYWxSZWZlcmVuY2VTcGhlcm9pZDogXCJFc2Zlcm9pZGVcIixcblx0XHRzcGF0aWFsUmVmZXJlbmNlU2VtaW1ham9yQXhpczogXCJTZW1pZWplIG1heW9yXCIsXG5cdFx0c3BhdGlhbFJlZmVyZW5jZVNlbWltaW5vckF4aXM6IFwiU2VtaWVqZSBtZW5vclwiLFxuXHRcdHNwYXRpYWxSZWZlcmVuY2VJbnZlcnNlRmxhdHRlbmluZzogXCJBcGxhbmFtaWVudG8gaW52ZXJzb1wiLFxuXHRcdGlucHV0RGVmaW5pdGlvbkZpbGVOYW1lOiBcIkFyY2hpdm8gZGUgZGVmaW5pY2nDs24gZGUgZW50cmFkYVwiLFxuXHRcdGRlbGV0ZU5hbWU6IFwiRWxpbWluYXJcIixcblx0XHRhZGRWYXJpYWJsZU5hbWU6IFwiQWdyZWdhciB2YXJpYWJsZVwiLFxuXHRcdG1heE51bVBpeGVsc1BlclNlZ21lbnQ6IFwiVGFtYcOxbyBkZSBzZWdtZW50byBtw6F4aW1vIGVuIHDDrXhlbGVzXCIsXG5cdFx0Zm9yd2FyZFdpbmRvd05hbWU6IFwiVmVudGFuYSBkZSBhdmFuY2VcIixcblx0XHRiYWNrd2FyZFdpbmRvd05hbWU6IFwiVmVudGFuYSBkZSByZXRyb2Nlc29cIixcblx0XHRub0RhdGFIYW5kbGluZ05hbWU6IFwiTWFuZWpvIGRlIE5vRGF0YVwiLFxuXHRcdGNpcmN1bGFyV3JhcFZhbHVlTmFtZTogXCJWYWxvciBkZSBlbnZvbHR1cmEgY2lyY3VsYXJcIixcblx0XHRmcm9tQ2xhc3NOYW1lRmllbGROYW1lOiBcIk5vbWJyZSBkZSBjYW1wbyBwYXJhIG5vbWJyZXMgZGUgY2xhc2UgZW4gRGVzZGUgcsOhc3RlclwiLFxuXHRcdHRvQ2xhc3NOYW1lRmllbGROYW1lOiBcIk5vbWJyZSBkZSBjYW1wbyBwYXJhIG5vbWJyZXMgZGUgY2xhc2UgZW4gSGFzdGEgcsOhc3RlclwiLFxuXHRcdHRhcmdldFJhc3Rlck5hbWU6IFwiUsOhc3RlciBkZSBkZXN0aW5vXCIsXG5cdFx0Y2lyY3VsYXJXcmFwVmFsdWU6IFwiVmFsb3IgZGUgZW52b2x0dXJhIGNpcmN1bGFyXCIsXG5cdFx0YmFuZEluZGV4ZXNSOiBcIkV4cHJlc2nDs24gcm9qYVwiLFxuXHRcdGJhbmRJbmRleGVzRzogXCJFeHByZXNpw7NuIHZlcmRlXCIsXG5cdFx0YmFuZEluZGV4ZXNCOiBcIkV4cHJlc2nDs24gYXp1bFwiLFxuXHRcdGV4YW1wbGVOYW1lOiBcIkVqZW1wbG9cIixcblx0XHRpbnB1dE5hbWU6IFwiRW50cmFkYVwiLFxuXHRcdG91dHB1dE5hbWU6IFwiU2FsaWRhXCIsXG5cdFx0b3B0aW9uYWxOYW1lOiBcIk9wY2lvbmFsXCIsXG5cdFx0YnJvd3NlRGVmaW5pdGlvbkZpbGU6IFwiRXhhbWluYXIgYXJjaGl2byBkZSBkZWZpbmljacOzblwiLFxuXHRcdHNlbGVjdERlZmluaXRpb25GaWxlOiBcIlNlbGVjY2lvbmFyIGFyY2hpdm8gZGUgZGVmaW5pY2nDs24gZGUgZW50cmFkYVwiLFxuXHRcdGlucHV0RGVmaW5pdGlvblVSTDogXCJVUkwgZGUgYXJjaGl2byBkZSBkZWZpbmljacOzbiBkZSBlbnRyYWRhXCIsXG5cdFx0ZW50ZXJEZWZpbml0aW9uRmlsZVVSTDogXCJJbnRyb2R1Y2lyIGxhIFVSTCBkZWwgYXJjaGl2byBkZSBkZWZpbmljacOzblwiLFxuXHRcdGJyb3dzZVhNTEZpbGU6IFwiRXhhbWluYXIgYXJjaGl2byBYTUxcIixcblx0XHRzZWxlY3RTdGF0c0ZpbGU6IFwiU2VsZWNjaW9uYXIgYXJjaGl2byBkZSBlc3RhZMOtc3RpY2FzIGUgaGlzdG9ncmFtYXNcIixcblx0XHRlbnRlclhNTEZpbGVVUkw6IFwiSW50cm9kdWNpciBsYSBVUkwgZGVsIGFyY2hpdm8gWE1MXCIsXG5cdFx0eG1sRmlsZVVSTDogXCJVUkwgZGUgYXJjaGl2byBYTUxcIixcblx0XHRjaXJjdWxhckNhbGN1bGF0aW9uOiBcIkNhbGN1bGFyIGVzdGFkw61zdGljYXMgY2lyY3VsYXJlc1wiLFxuXHRcdGxvY2FsU3VyZmFjZVR5cGU6IFwiVGlwbyBkZSBzdXBlcmZpY2llIGxvY2FsXCIsXG5cdFx0c3VyZmFjZVBhcmFtZXRlclR5cGU6IFwiVGlwbyBkZSBwYXLDoW1ldHJvXCIsXG5cdFx0bmVpZ2hib3Job29kRGlzdGFuY2U6IFwiRGlzdGFuY2lhIGRlIHZlY2luZGFkXCIsXG5cdFx0dXNlQWRhcHRpdmVOZWlnaGJvcmhvb2Q6IFwiVXRpbGl6YXIgdmVjaW5kYWQgYWRhcHRhYmxlXCIsXG5cdFx0b3V0cHV0U2xvcGVUeXBlOiBcIk1lZGlkYSBkZSBwZW5kaWVudGUgZGUgc2FsaWRhXCIsXG5cdFx0cHJvamVjdEF6aW11dGhzOiBcIkFjaW11dHMgZ2VvZMOpc2ljb3MgZGVsIHByb3llY3RvXCIsXG5cdFx0dXNlRXF1YXRvcmlhbEFzcGVjdDogXCJVdGlsaXphciBvcmllbnRhY2nDs24gZWN1YXRvcmlhbFwiLFxuXHRcdHpVbml0OiBcIlVuaWRhZCB6XCIsXG5cdFx0YW5hbHlzaXNNYXNrOiBcIk3DoXNjYXJhIGRlIGFuw6FsaXNpc1wiLFxuXHRcdHN0ZERldmlhdGlvbjogXCJEZXN2aWFjacOzbiBlc3TDoW5kYXJcIixcblx0XHRcInRydWVcIjogXCJWZXJkYWRlcm9cIixcblx0XHRcImZhbHNlXCI6IFwiRmFsc29cIixcblx0XHRjb3N0RGlzdGFuY2VSYXN0ZXIxOiBcIlLDoXN0ZXIgZGUgZGlzdGFuY2lhIGRlIGNvc3RlIGFjdW11bGF0aXZvIGRlIGVudHJhZGEgMVwiLFxuXHRcdGNvc3REaXN0YW5jZVJhc3RlcjI6IFwiUsOhc3RlciBkZSBkaXN0YW5jaWEgZGUgY29zdGUgYWN1bXVsYXRpdm8gZGUgZW50cmFkYSAyXCIsXG5cdFx0dGhyZXNob2xkOiBcIlVtYnJhbFwiLFxuXHRcdHRocmVzaG9sZE1ldGhvZDogXCJNw6l0b2RvIGRlIHVtYnJhbFwiLFxuXHRcdGRpcmVjdGlvblJhc3RlcjE6IFwiUsOhc3RlciBkZSBkaXJlY2Npw7NuIGhhY2lhIGF0csOhcyBkZSBlbnRyYWRhIDFcIixcblx0XHRkaXJlY3Rpb25SYXN0ZXIyOiBcIlLDoXN0ZXIgZGUgZGlyZWNjacOzbiBoYWNpYSBhdHLDoXMgZGUgZW50cmFkYSAyXCIsXG5cdFx0bWF4SXRlcmF0aW9uczogXCJOw7ptZXJvIG3DoXhpbW8gZGUgaXRlcmFjaW9uZXNcIixcblx0XHRlcHNpbG9uOiBcIsONcHNpbG9uXCJcblx0fSxcblx0ZW51bUxhYmVsczoge1xuXHRcdGF0dHJpYnV0ZVRhYmxlVHlwZU1hbnVhbDogXCJNYW51YWxcIixcblx0XHRhdHRyaWJ1dGVUYWJsZVR5cGVFeHRlcm5hbDogXCJFeHRlcm5vXCIsXG5cdFx0Y2xyU2NoZW1lVHlwZUNvbG9ybWFwOiBcIk1hcGEgZGUgY29sb3JcIixcblx0XHRjbHJTY2hlbWVUeXBlQ29sb3JSYW1wOiBcIlJhbXBhIGRlIGNvbG9yXCIsXG5cdFx0Y29sb3JtYXBUeXBlRWxldmF0aW9uOiBcIkVsZXZhY2nDs25cIixcblx0XHRjb2xvcm1hcFR5cGVHcmF5OiBcIkdyaXNcIixcblx0XHRjb2xvcm1hcFR5cGVORFZJOiBcIk5EVklcIixcblx0XHRjb2xvcm1hcFR5cGVORFZJMjogXCJORFZJMlwiLFxuXHRcdGNvbG9ybWFwVHlwZU5EVkkzOiBcIk5EVkkzXCIsXG5cdFx0Y29sb3JtYXBUeXBlUmFuZG9tOiBcIkFsZWF0b3Jpb1wiLFxuXHRcdG5vbmU6IFwiTmluZ3VuYVwiLFxuXHRcdHNsb3BlVHlwZUFkanVzdGVkOiBcIkFqdXN0YWRvXCIsXG5cdFx0c2xvcGVUeXBlRGVncmVlOiBcIkdyYWRvXCIsXG5cdFx0c2xvcGVUeXBlUGVyY2VudFJpc2U6IFwiRWxldmFjacOzbiBlbiBwb3JjZW50YWplXCIsXG5cdFx0c2xvcGVUeXBlU2NhbGVkOiBcIkVzY2FsYWRvXCIsXG5cdFx0c3RyZXRjaFR5cGVNaW5NYXg6IFwiTWluTWF4XCIsXG5cdFx0c3RyZXRjaFR5cGVQZXJjZW50TWluTWF4OiBcIlBlcmNlbnRNaW5NYXhcIixcblx0XHRzdHJldGNoVHlwZVNpZ21vaWQ6IFwiU2lnbW9pZGVvXCIsXG5cdFx0c3RyZXRjaFR5cGVTdGREZXY6IFwiU3RkRGV2XCIsXG5cdFx0aGlsbHNoYWRlVHlwZVNpbXBsZTogXCJUcmFkaWNpb25hbFwiLFxuXHRcdGhpbGxzaGFkZVR5cGVNdWx0aWRpcmVjdGlvbmFsOiBcIk11bHRpZGlyZWNjaW9uYWxcIixcblx0XHRiYW5kQ29tYm9CeU5hbWVzOiBcIk5vbWJyZXMgZGUgYmFuZGFcIixcblx0XHRiYW5kQ29tYm9CeVdhdmVsZW5ndGg6IFwiTG9uZ2l0dWRlcyBkZSBvbmRhIGRlIGJhbmRhc1wiLFxuXHRcdGJhbmRDb21ib0J5SURzOiBcIklkLiBkZSBiYW5kYVwiLFxuXHRcdG1pc3NpbmdCYW5kQWN0aW9uQmVzdE1hdGNoOiBcIk1lam9yIGNvaW5jaWRlbmNpYVwiLFxuXHRcdG1pc3NpbmdCYW5kQWN0aW9uRmFpbDogXCJFcnJvclwiLFxuXHRcdHVuaXRUeXBlQ2Vsc2l1czogXCJDZW50w61ncmFkb3NcIixcblx0XHR1bml0VHlwZUNlbnRpbWV0ZXJzOiBcIkNlbnTDrW1ldHJvc1wiLFxuXHRcdHVuaXRUeXBlRGVjaW1ldGVyczogXCJEZWPDrW1ldHJvc1wiLFxuXHRcdHVuaXRUeXBlRmFocmVuaGVpdDogXCJGYWhyZW5oZWl0XCIsXG5cdFx0dW5pdFR5cGVGZWV0OiBcIlBpZXNcIixcblx0XHR1bml0VHlwZUZlZXRQZXJTZWM6IFwiUGllcyBwb3Igc2VndW5kbyAocGllcy9zKVwiLFxuXHRcdHVuaXRUeXBlSW5jaGVzOiBcIlB1bGdhZGFzXCIsXG5cdFx0dW5pdFR5cGVLZWx2aW46IFwiS2VsdmluXCIsXG5cdFx0dW5pdFR5cGVLaWxvbWV0ZXJzOiBcIktpbMOzbWV0cm9zXCIsXG5cdFx0dW5pdFR5cGVLbXNQZXJIb3VyOiBcIktpbMOzbWV0cm9zIHBvciBob3JhIChrbS9oKVwiLFxuXHRcdHVuaXRUeXBlS25vdHM6IFwiTnVkb3MgKGtuKVwiLFxuXHRcdHVuaXRUeXBlTWV0ZXJzOiBcIk1ldHJvc1wiLFxuXHRcdHVuaXRUeXBlTWV0ZXJzUGVyU2VjOiBcIk1ldHJvcyBwb3Igc2VndW5kbyAobS9zKVwiLFxuXHRcdHVuaXRUeXBlTWlsZXM6IFwiTWlsbGFzXCIsXG5cdFx0dW5pdFR5cGVNaWxlc1BlckhvdXI6IFwiTWlsbGFzIHBvciBob3JhIChtcGgpXCIsXG5cdFx0dW5pdFR5cGVNaWxsaW1ldGVyczogXCJNaWzDrW1ldHJvc1wiLFxuXHRcdHVuaXRUeXBlTmF1dGljYWxNaWxlczogXCJNaWxsYXMgbsOhdXRpY2FzXCIsXG5cdFx0dW5pdFR5cGVZYXJkczogXCJZYXJkYXNcIixcblx0XHR1bml0VHlwZURlY2ltYWxEZWdyZWVzOiBcIkdyYWRvcyBkZWNpbWFsZXNcIixcblx0XHR1bml0VHlwZVBvaW50czogXCJQdW50b3NcIixcblx0XHR1bml0VHlwZVVua25vd246IFwiRGVzY29ub2NpZG9cIixcblx0XHR1bml0VHlwZVNxTWFwVW5pdHM6IFwiVW5pZGFkZXMgZGUgbWFwYSBDdWFkcmFkYXNcIixcblx0XHR1bml0VHlwZVNxTWlsZXM6IFwiTWlsbGFzIGN1YWRyYWRhc1wiLFxuXHRcdHVuaXRUeXBlU3FLbXM6IFwiS2lsw7NtZXRyb3MgY3VhZHJhZG9zXCIsXG5cdFx0dW5pdFR5cGVBY3JlczogXCJBY3Jlc1wiLFxuXHRcdHVuaXRUeXBlSGVjdGFyZXM6IFwiSGVjdMOhcmVhc1wiLFxuXHRcdHVuaXRUeXBlU3FZYXJkczogXCJZYXJkYXMgY3VhZHJhZGFzXCIsXG5cdFx0dW5pdFR5cGVTcUZ0OiBcIlBpZXMgY3VhZHJhZG9zXCIsXG5cdFx0dW5pdFR5cGVTcUluY2hlczogXCJQdWxnYWRhcyBDdWFkcmFkYXNcIixcblx0XHR1bml0VHlwZVNxTXRzOiBcIk1ldHJvcyBjdWFkcmFkb3NcIixcblx0XHR1bml0VHlwZVNxQ21zOiBcIkNlbnTDrW1ldHJvcyBDdWFkcmFkb3NcIixcblx0XHR1bml0VHlwZVNxTW1zOiBcIk1pbMOtbWV0cm9zIEN1YWRyYWRvc1wiLFxuXHRcdGNlbGxzaXplVHlwZUZpcnN0OiBcIlByaW1lcm8gZGVcIixcblx0XHRjZWxsc2l6ZVR5cGVNaW46IFwiTcOtbmltbyBkZVwiLFxuXHRcdGNlbGxzaXplVHlwZU1heDogXCJNw6F4aW1vIGRlXCIsXG5cdFx0Y2VsbHNpemVUeXBlTWVhbjogXCJWYWxvciBtZWRpbyBkZVwiLFxuXHRcdGNlbGxzaXplVHlwZUxhc3Q6IFwiw5psdGltbyBkZVwiLFxuXHRcdGV4dGVudFR5cGVGaXJzdDogXCJQcmltZXJvIGRlXCIsXG5cdFx0ZXh0ZW50VHlwZUludGVyc2VjdGlvbjogXCJJbnRlcnNlY2Npw7NuIGRlXCIsXG5cdFx0ZXh0ZW50VHlwZVVuaW9uOiBcIkNvbWJpbmFjacOzbiBkZVwiLFxuXHRcdGV4dGVudFR5cGVMYXN0OiBcIsOabHRpbW8gZGVcIixcblx0XHRub0RhdGFJbnRlcnByZXRBbnk6IFwiSGFjZXIgY29pbmNpZGlyIGNvbiBjdWFscXVpZXJhXCIsXG5cdFx0bm9EYXRhSW50ZXJwcmV0QWxsOiBcIkhhY2VyIGNvaW5jaWRpciBjb24gdG9kb3NcIixcblx0XHRjdXJ2YXR1cmVUeXBlU3RhbmRhcmQ6IFwiU3RhbmRhcmRcIixcblx0XHRjdXJ2YXR1cmVUeXBlUHJvZmlsZTogXCJQZXJmaWxcIixcblx0XHRjdXJ2YXR1cmVUeXBlUGxhbmZvcm06IFwiUGxhbm9cIixcblx0XHRmaWx0ZXJUeXBlTGluZURldGVjdGlvbkhvcml6b250YWw6IFwiSG9yaXpvbnRhbCBkZSBkZXRlY2Npw7NuIGRlIGzDrW5lYVwiLFxuXHRcdGZpbHRlclR5cGVMaW5lRGV0ZWN0aW9uVmVydGljYWw6IFwiVmVydGljYWwgZGUgZGV0ZWNjacOzbiBkZSBsw61uZWFcIixcblx0XHRmaWx0ZXJUeXBlTGluZURldGVjdGlvbkxlZnREaWFnb25hbDogXCJEaWFnb25hbCBpenF1aWVyZGEgZGUgZGV0ZWNjacOzbiBkZSBsw61uZWFcIixcblx0XHRmaWx0ZXJUeXBlTGluZURldGVjdGlvblJpZ2h0RGlhZ29uYWw6IFwiRGlhZ29uYWwgZGVyZWNoYSBkZSBkZXRlY2Npw7NuIGRlIGzDrW5lYVwiLFxuXHRcdGZpbHRlclR5cGVHcmFkaWVudE5vcnRoOiBcIkdyYWRpZW50ZSBub3J0ZVwiLFxuXHRcdGZpbHRlclR5cGVHcmFkaWVudFdlc3Q6IFwiR3JhZGllbnRlIG9lc3RlXCIsXG5cdFx0ZmlsdGVyVHlwZUdyYWRpZW50RWFzdDogXCJHcmFkaWVudGUgZXN0ZVwiLFxuXHRcdGZpbHRlclR5cGVHcmFkaWVudFNvdXRoOiBcIkdyYWRpZW50ZSBzdXJcIixcblx0XHRmaWx0ZXJUeXBlR3JhZGllbnROb3J0aEVhc3Q6IFwiR3JhZGllbnRlIG5vcmVzdGVcIixcblx0XHRmaWx0ZXJUeXBlR3JhZGllbnROb3J0aFdlc3Q6IFwiR3JhZGllbnRlIG5vcm9lc3RlXCIsXG5cdFx0ZmlsdGVyVHlwZVNtb290aEFyaXRobWV0aWNNZWFuOiBcIlN1YXZpemFyIHZhbG9yIG1lZGlvIGFyaXRtw6l0aWNvXCIsXG5cdFx0ZmlsdGVyVHlwZVNtb290aGluZzN4MzogXCJTdWF2aXphZG8gM3gzXCIsXG5cdFx0ZmlsdGVyVHlwZVNtb290aGluZzV4NTogXCJTdWF2aXphZG8gNXg1XCIsXG5cdFx0ZmlsdGVyVHlwZVNoYXJwZW5pbmczeDM6IFwiTml0aWRleiAzeDNcIixcblx0XHRmaWx0ZXJUeXBlU2hhcnBlbmluZzV4NTogXCJOaXRpZGV6IDV4NVwiLFxuXHRcdGZpbHRlclR5cGVMYXBsYWNpYW4zeDM6IFwiTGFwbGFjaWFubyAzeDNcIixcblx0XHRmaWx0ZXJUeXBlTGFwbGFjaWFuNXg1OiBcIkxhcGxhY2lhbm8gNXg1XCIsXG5cdFx0ZmlsdGVyVHlwZVNvYmVsSG9yaXpvbnRhbDogXCJIb3Jpem9udGFsIGRlIFNvYmVsXCIsXG5cdFx0ZmlsdGVyVHlwZVNvYmVsVmVydGljYWw6IFwiVmVydGljYWwgZGUgU29iZWxcIixcblx0XHRmaWx0ZXJUeXBlU2hhcnBlbjogXCJSZWZpbmFyXCIsXG5cdFx0ZmlsdGVyVHlwZVNoYXJwZW4yOiBcIlJlZmluYXIgbcOhc1wiLFxuXHRcdGZpbHRlclR5cGVQb2ludFNwcmVhZDogXCJFeHRlbnNpw7NuIGRlIHB1bnRvXCIsXG5cdFx0dXNlckRlZmluZWQ6IFwiRGVmaW5pZG8gcG9yIGVsIHVzdWFyaW9cIixcblx0XHRDb250b3VyVHlwZUxpbmVzOiBcIkzDrW5lYXMgZGUgY3VydmFzIGRlIG5pdmVsXCIsXG5cdFx0Q29udG91clR5cGVGaWxsOiBcIlJlbGxlbm8gZGUgY3VydmFzIGRlIG5pdmVsXCIsXG5cdFx0Q29udG91clR5cGVTbW9vdGhPbmx5OiBcIlN1YXZpemFyIHNvbG8gc3VwZXJmaWNpZVwiLFxuXHRcdHJhc3Rlcml6ZUZpcnN0OiBcIlByaW1lcm9cIixcblx0XHRyYXN0ZXJpemVMYXN0OiBcIsOabHRpbW8oYSlcIixcblx0XHRyYXN0ZXJpemVTbWFsbGVzdDogXCJNw6FzIHBlcXVlw7FvXCIsXG5cdFx0cmFzdGVyaXplTGFyZ2VzdDogXCJNw6FzIGdyYW5kZVwiLFxuXHRcdHJlc2FtcGxpbmdUeXBlTmVhcmVzdDogXCJWZWNpbm8gTcOhcyBQcsOzeGltb1wiLFxuXHRcdHJlc2FtcGxpbmdUeXBlQmlsaW5lYXI6IFwiSW50ZXJwb2xhY2nDs24gYmlsaW5lYWxcIixcblx0XHRyZXNhbXBsaW5nVHlwZUN1YmljOiBcIkNvbnZvbHVjacOzbiBjw7piaWNhXCIsXG5cdFx0cmVzYW1wbGluZ1R5cGVNYWpvcml0eTogXCJNYXlvcsOtYVwiLFxuXHRcdHJlc2FtcGxpbmdUeXBlQmlsaW5lYXJQbHVzOiBcIkludGVycG9sYWNpw7NuIGJpbGluZWFsIHBsdXNcIixcblx0XHRyZXNhbXBsaW5nVHlwZUdhdXNzOiBcIkRlc2VuZm9xdWUgZ2F1c3NpYW5vXCIsXG5cdFx0cmVzYW1wbGluZ1R5cGVHYXVzc1BsdXM6IFwiRGVzZW5mb3F1ZSBnYXVzc2lhbm8gcGx1c1wiLFxuXHRcdHJlc2FtcGxpbmdUeXBlQXZlcmFnZTogXCJNZWRpYVwiLFxuXHRcdHJlc2FtcGxpbmdUeXBlTWluaW11bTogXCJNw61uaW1vXCIsXG5cdFx0cmVzYW1wbGluZ1R5cGVNYXhpbXVtOiBcIk3DoXhpbW9cIixcblx0XHRyZXNhbXBsaW5nVHlwZVZlY3RvckF2ZzogXCJQcm9tZWRpbyB2ZWN0b3JpYWxcIixcblx0XHRtaW5pbXVtOiBcIk3DrW5pbW9cIixcblx0XHRtYXhpbXVtOiBcIk3DoXhpbW9cIixcblx0XHRtZWFuOiBcIlZhbG9yIG1lZGlvXCIsXG5cdFx0c3RkRGV2aWF0aW9uOiBcIkRlc3ZpYWNpw7NuIGVzdMOhbmRhclwiLFxuXHRcdHV2TWFnRGlyVHlwZVVWOiBcIlUtVlwiLFxuXHRcdHV2TWFnRGlyVHlwZU1hZ0RpcjogXCJNYWduaXR1ZC1kaXJlY2Npw7NuXCIsXG5cdFx0dW5rbm93bjogXCJEZXNjb25vY2lkb1wiLFxuXHRcdGFuZ2xlUmVmU3lzR2VvZ3JhcGhpYzogXCJHZW9ncsOhZmljb1wiLFxuXHRcdGFuZ2xlUmVmU3lzQXJpdGhtZXRpYzogXCJBcml0bcOpdGljYVwiLFxuXHRcdGludGVycG9sYXRlSXJyZWd1bGFyRGF0YU5lYXJlc3Q6IFwiVmVjaW5vIE3DoXMgUHLDs3hpbW9cIixcblx0XHRpbnRlcnBvbGF0ZUlycmVndWxhckRhdGFCaWxpbmVhcjogXCJCaWxpbmVhbFwiLFxuXHRcdGludGVycG9sYXRlSXJyZWd1bGFyRGF0YVRpbm5pbmdMaW5lYXI6IFwiU2ltcGxpZmljYWNpw7NuIGxpbmVhbFwiLFxuXHRcdGludGVycG9sYXRlSXJyZWd1bGFyRGF0YVRpbm5pbmdOYXR1cmFsTmVpZ2hib3I6IFwiVmVjaW5vIG5hdHVyYWxcIixcblx0XHRpbnRlcnBvbGF0ZUlycmVndWxhckRhdGFUaW5uaW5nSURXOiBcIkRpc3RhbmNpYSBpbnZlcnNhIHBvbmRlcmFkYVwiLFxuXHRcdGVzcmlSYXN0ZXJUaHJlc2hvbGRUeXBlQ29uc3RhbnQ6IFwiQ29uc3RhbnRlXCIsXG5cdFx0ZXNyaVJhc3RlclRocmVzaG9sZFR5cGVPdHN1OiBcIk90c3VcIixcblx0XHRlc3JpUmFzdGVyVGhyZXNob2xkVHlwZVRzYWk6IFwiVHNhaVwiLFxuXHRcdGVzcmlSYXN0ZXJUaHJlc2hvbGRUeXBlS2FwdXI6IFwiS2FwdXJcIixcblx0XHRlc3JpUmFzdGVyVGhyZXNob2xkVHlwZUtpdHRsZXI6IFwiS2l0dGxlclwiLFxuXHRcdGVzcmlSYXN0ZXJUaHJlc2hvbGRUeXBlUm9zaW46IFwiUm9zaW5cIixcblx0XHRhcmdTdGF0c1R5cGVNYXg6IFwiQXJnIE1heFwiLFxuXHRcdGFyZ1N0YXRzVHlwZU1pbjogXCJBcmcgTWluXCIsXG5cdFx0YXJnU3RhdHNUeXBlTWVkaWFuOiBcIkFyZyBNZWRpb1wiLFxuXHRcdGFyZ1N0YXRzVHlwZUR1cmF0aW9uOiBcIkR1cmFjacOzblwiLFxuXHRcdGFyaXRobWV0aWNPcFBsdXM6IFwiUGx1c1wiLFxuXHRcdGFyaXRobWV0aWNPcE1pbnVzOiBcIlJlc3RhXCIsXG5cdFx0YXJpdGhtZXRpY09wTXVsdGlwbHk6IFwiTXVsdGlwbGljYXJcIixcblx0XHRhcml0aG1ldGljT3BEaXZpZGU6IFwiRGl2aWRpclwiLFxuXHRcdGFyaXRobWV0aWNPcFBvd2VyOiBcIlBvdGVuY2lhXCIsXG5cdFx0YXJpdGhtZXRpY09wTW9kZTogXCJNb2RvXCIsXG5cdFx0Y2xpcFR5cGVPdXRzaWRlOiBcIkNsaXAgZnVlcmFcIixcblx0XHRjbGlwVHlwZUluc2lkZTogXCJDbGlwIGRlbnRyb1wiLFxuXHRcdHllczogXCJTw61cIixcblx0XHRubzogXCJOb1wiLFxuXHRcdGRlbnNpdGllczogXCJEZW5zaWRhZGVzXCIsXG5cdFx0ZXhwZWN0ZWRDb3VudHM6IFwiUmVjdWVudG9zIGVzcGVyYWRvc1wiLFxuXHRcdHBsYW5hcjogXCJQbGFuYXJcIixcblx0XHRnZW9kZXNpYzogXCJHZW9kw6lzaWNvXCIsXG5cdFx0ZWFjaENlbGw6IFwiQ2FkYSBjZWxkYVwiLFxuXHRcdGVhY2hab25lOiBcIkNhZGEgem9uYVwiLFxuXHRcdGJlc3RTaW5nbGU6IFwiTWVqb3IgU2ltcGxlXCIsXG5cdFx0YWxsU2lnaHRsaW5lczogXCJUb2RhcyBsYXMgbMOtbmVhcyBkZSB2aXNpw7NuXCIsXG5cdFx0cGVyaW1ldGVyU2lnaHRsaW5lczogXCJMw61uZWFzIGRlIHZpc2nDs24gZGUgcGVyw61tZXRyb1wiLFxuXHRcdGZyZXF1ZW5jeTogXCJGcmVjdWVuY2lhXCIsXG5cdFx0b2JzZXJ2ZXJzOiBcIk9ic2VydmFkb3Jlc1wiLFxuXHRcdG1ham9yaXR5OiBcIk1heW9yw61hXCIsXG5cdFx0bWVkaWFuOiBcIk1lZGlhbmFcIixcblx0XHRtaW5vcml0eTogXCJNaW5vcsOtYVwiLFxuXHRcdHBlcmNlbnRpbGU6IFwiUGVyY2VudGlsXCIsXG5cdFx0cmFuZ2U6IFwiUmFuZ29cIixcblx0XHRzdW06IFwiU3VtYVwiLFxuXHRcdHZhcmlldHk6IFwiVmFyaWVkYWRcIixcblx0XHRuZHZpOiBcIk5EVklcIixcblx0XHRzYXZpOiBcIlNBVklcIixcblx0XHRiYW5kQXJpdGhtZXRpY01ldGhvZFRTQVZJOiBcIlNBVkkgdHJhbnNmb3JtYWRvXCIsXG5cdFx0YmFuZEFyaXRobWV0aWNNZXRob2RNU0FWSTogXCJTQVZJIG1vZGlmaWNhZG9cIixcblx0XHRiYW5kQXJpdGhtZXRpY01ldGhvZFN1bHRhbjogXCJGw7NybXVsYSBkZSBTdWx0YW5cIixcblx0XHRnZW1pOiBcIkdFTUlcIixcblx0XHRwdmk6IFwiUFZJXCIsXG5cdFx0Z3ZpOiBcIkdWSSAoTGFuZHNhdCBUTSlcIixcblx0XHR2YXJpOiBcIlZBUklcIixcblx0XHRzcjogXCJTUlwiLFxuXHRcdGduZHZpOiBcIkdORFZJXCIsXG5cdFx0bmR2aXJlOiBcIk5EVklyZVwiLFxuXHRcdHNycmU6IFwiU1JyZVwiLFxuXHRcdG10dmkyOiBcIk1UVkkyXCIsXG5cdFx0cnR2aUNvcmU6IFwiUlRWSUNvcmVcIixcblx0XHRjaXJlOiBcIkNJcmVcIixcblx0XHRjaWc6IFwiQ0lnXCIsXG5cdFx0bmR3aTogXCJORFdJXCIsXG5cdFx0ZXZpOiBcIkVWSVwiLFxuXHRcdGlyb25PeGlkZTogXCLDk3hpZG8gZGUgaGllcnJvXCIsXG5cdFx0ZmVycm91c01pbmVyYWxzOiBcIk1pbmVyYWxlcyBmZXJyb3Nvc1wiLFxuXHRcdGNsYXlNaW5lcmFsczogXCJNaW5lcmFsZXMgYXJjaWxsb3Nvc1wiLFxuXHRcdHduZHdpOiBcIldORFdJXCIsXG5cdFx0YmFpOiBcIkJBSVwiLFxuXHRcdG1uZHdpOiBcIk1ORFdJXCIsXG5cdFx0bmJyOiBcIk5CUlwiLFxuXHRcdG5kYmk6IFwiTkRCSVwiLFxuXHRcdG5kbWk6IFwiTkRNSVwiLFxuXHRcdG5kc2k6IFwiTkRTSVwiLFxuXHRcdGxvY2FsU3F1YXJlUm9vdDogXCJSYcOteiBjdWFkcmFkYVwiLFxuXHRcdGxvY2FsQUNvczogXCJBcmNvY29zZW5vIChBQ29zKVwiLFxuXHRcdGxvY2FsQVNpbjogXCJBcmNvc2VubyAoQVNpbilcIixcblx0XHRsb2NhbEFUYW46IFwiQXJjb3RhbmdlbnRlIChBVGFuKVwiLFxuXHRcdGxvY2FsQVRhbkg6IFwiQXJjb3RhbmdlbnRlIGhpcGVyYsOzbGljYSAoQVRhbkgpXCIsXG5cdFx0bG9jYWxBYnM6IFwiVmFsb3IgYWJzb2x1dG9cIixcblx0XHRsb2NhbEJpdHdpc2VOb3Q6IFwiQml0d2lzZSBOb3RcIixcblx0XHRsb2NhbEJvb2xlYW5Ob3Q6IFwiQm9vbGVhbmEgTm90XCIsXG5cdFx0bG9jYWxDb3M6IFwiQ29zZW5vIChDb3MpXCIsXG5cdFx0bG9jYWxDb3NIOiBcIkNvc2VubyBoaXBlcmLDs2xpY28gKENvc0gpXCIsXG5cdFx0bG9jYWxFeHA6IFwiRXhwb25lbmNpYWwgZW4gYmFzZSBlIChFeHApXCIsXG5cdFx0bG9jYWxFeHAxMDogXCJFeHBvbmVuY2lhbCBlbiBiYXNlIDEwIChFeHAxMClcIixcblx0XHRsb2NhbEV4cDI6IFwiRXhwb25lbmNpYWwgZW4gYmFzZSAyIChFeHAyKVwiLFxuXHRcdGxvY2FsSW50OiBcIkVudGVyb1wiLFxuXHRcdGxvY2FsSXNOdWxsOiBcIkVzIG51bG9cIixcblx0XHRsb2NhbEZsb2F0OiBcIkZsb3RhbnRlXCIsXG5cdFx0bG9jYWxMbjogXCJMb2dhcml0bW8gbmVwZXJpYW5vIChMbilcIixcblx0XHRsb2NhbExvZzEwOiBcIkxvZ2FyaXRtbyBlbiBiYXNlIDEwIChMb2cxMClcIixcblx0XHRsb2NhbExvZzI6IFwiTG9nYXJpdG1vIGVuIGJhc2UgMiAoTG9nMilcIixcblx0XHRsb2NhbE5lZ2F0ZTogXCJDYW1iaW8gZGUgc2lnbm9cIixcblx0XHRsb2NhbFJvdW5kRG93bjogXCJSZWRvbmRlbyBoYWNpYSBhYmFqb1wiLFxuXHRcdGxvY2FsUm91bmRVcDogXCJSZWRvbmRlbyBoYWNpYSBhcnJpYmFcIixcblx0XHRsb2NhbFNpbjogXCJTZW5vIChTaW4pXCIsXG5cdFx0bG9jYWxTaW5IOiBcIlNlbm8gaGlwZXJiw7NsaWNvIChTaW5IKVwiLFxuXHRcdGxvY2FsVGFuOiBcIlRhbmdlbnRlIChUYW4pXCIsXG5cdFx0bG9jYWxUYW5IOiBcIlRhbmdlbnRlIGhpcGVyYsOzbGljYSAoVGFuSClcIixcblx0XHRsb2NhbEFDb3NIOiBcIkFyY29jb3Nlbm8gaGlwZXJiw7NsaWNvIChBQ29zSClcIixcblx0XHRsb2NhbEFTaW5IOiBcIkFyY29zZW5vIGhpcGVyYsOzbGljbyAoQVNpbkgpXCIsXG5cdFx0bG9jYWxQbHVzOiBcIlBsdXNcIixcblx0XHRsb2NhbE1pbnVzOiBcIlJlc3RhXCIsXG5cdFx0bG9jYWxUaW1lczogXCJNdWx0aXBsaWNhY2nDs25cIixcblx0XHRsb2NhbFBvd2VyOiBcIlBvdGVuY2lhXCIsXG5cdFx0bG9jYWxCaXR3aXNlQW5kOiBcIkJpdHdpc2UgQW5kXCIsXG5cdFx0bG9jYWxCaXR3aXNlTGVmdFNoaWZ0OiBcIkJpdHdpc2UgTGVmdCBTaGlmdFwiLFxuXHRcdGxvY2FsQml0d2lzZU9yOiBcIkJpdHdpc2UgT3JcIixcblx0XHRsb2NhbEJpdHdpc2VSaWdodFNoaWZ0OiBcIkJpdHdpc2UgUmlnaHQgU2hpZnRcIixcblx0XHRsb2NhbEJpdHdpc2VYb3I6IFwiQml0d2lzZSBYT3JcIixcblx0XHRsb2NhbEJvb2xlYW5BbmQ6IFwiQm9vbGVhbmEgQW5kXCIsXG5cdFx0bG9jYWxCb29sZWFuT3I6IFwiQm9vbGVhbmEgT3JcIixcblx0XHRsb2NhbEJvb2xlYW5Yb3I6IFwiQm9vbGVhbmEgWE9yXCIsXG5cdFx0bG9jYWxEaXZpZGU6IFwiRGl2aWRpclwiLFxuXHRcdGxvY2FsRXF1YWxUbzogXCJJZ3VhbCBhXCIsXG5cdFx0bG9jYWxHcmVhdGVyVGhhbjogXCJNYXlvciBxdWVcIixcblx0XHRsb2NhbEdyZWF0ZXJUaGFuRXF1YWw6IFwiTWF5b3IgbyBpZ3VhbCBxdWVcIixcblx0XHRsb2NhbExlc3NUaGFuOiBcIk1lbm9yIHF1ZVwiLFxuXHRcdGxvY2FsTGVzc1RoYW5FcXVhbDogXCJNZW5vciBvIGlndWFsIHF1ZVwiLFxuXHRcdGxvY2FsTW9kOiBcIk3Ds2R1bG9cIixcblx0XHRsb2NhbE5vdEVxdWFsOiBcIk5vIGlndWFsXCIsXG5cdFx0bG9jYWxBVGFuMjogXCJBcmNvdGFuZ2VudGUgKHgveSkgKEFUYW4yKVwiLFxuXHRcdGxvY2FsU3F1YXJlOiBcIkN1YWRyYWRvXCIsXG5cdFx0bG9jYWxTZXROdWxsOiBcIkVzdGFibGVjZXIgbnVsb3NcIixcblx0XHRyZW1hcERlZlR5cGVMaXN0OiBcIkxpc3RhXCIsXG5cdFx0cmVtYXBEZWZUeXBlVGFibGU6IFwiVGFibGFcIixcblx0XHRyZW1hcFRhYmxlVHlwZVNpbXBsZTogXCJTaW1wbGVcIixcblx0XHRyZW1hcFRhYmxlVHlwZUR5bmFtaWM6IFwiRHluYW1pY1wiLFxuXHRcdHJlbWFwVGFibGVUeXBlUmVhc3NpZ25tZW50OiBcIlJlYXNpZ25hY2nDs25cIixcblx0XHRnZW9tQ29ycmVjdGlvbkJ5Q29uc3RaOiBcIlVzYXIgWiBjb25zdGFudGVcIixcblx0XHRnZW9tQ29ycmVjdGlvbkJ5REVNOiBcIlVzYXIgREVNXCIsXG5cdFx0cmFkYXJDYWxpYkJldGFOb3VnaHQ6IFwiQmV0YSBjZXJvXCIsXG5cdFx0cmFkYXJDYWxpYlNpZ21hTm91Z2h0OiBcIlNpZ21hIGNlcm9cIixcblx0XHRyYWRhckNhbGliR2FtbWFOb3VnaHQ6IFwiR2FtbWEgY2Vyb1wiLFxuXHRcdHNwZWNrbGVGaWx0ZXJUeXBlTGVlOiBcIkZpbHRybyBMZWVcIixcblx0XHRzcGVja2xlRmlsdGVyVHlwZUVuaGFuY2VkTGVlOiBcIkZpbHRybyBMZWUgbWVqb3JhZG9cIixcblx0XHRzcGVja2xlRmlsdGVyVHlwZUZyb3N0OiBcIkZpbHRybyBDb25nZWxhbWllbnRvXCIsXG5cdFx0c3BlY2tsZUZpbHRlclR5cGVLdWFuOiBcIkZpbHRybyBLdWFuXCIsXG5cdFx0c3BlY2tsZU5vaXNlTW9kZWxNdWw6IFwiUnVpZG8gbXVsdGlwbGljYXRpdm9cIixcblx0XHRzcGVja2xlTm9pc2VNb2RlbEFkZDogXCJSdWlkbyBhZGl0aXZvXCIsXG5cdFx0c3BlY2tsZU5vaXNlTW9kZWxBZGRuTXVsOiBcIlJ1aWRvIGFkaXRpdm8geSBtdWx0aXBsaWNhdGl2b1wiLFxuXHRcdG1vc2FpY09wVHlwZUZpcnN0OiBcIlByaW1lcm9cIixcblx0XHRtb3NhaWNPcFR5cGVMYXN0OiBcIsOabHRpbW8oYSlcIixcblx0XHRtb3NhaWNPcFR5cGVNaW46IFwiTcOtbi5cIixcblx0XHRtb3NhaWNPcFR5cGVNYXg6IFwiTcOheC5cIixcblx0XHRtb3NhaWNPcFR5cGVNZWFuOiBcIlZhbG9yIG1lZGlvXCIsXG5cdFx0bW9zYWljT3BUeXBlQmxlbmQ6IFwiQ29tYmluYXJcIixcblx0XHRtb3NhaWNPcFR5cGVTdW06IFwiU3VtYVwiLFxuXHRcdGludGVnZXI6IFwiRW50ZXJvXCIsXG5cdFx0cmZ4RDg6IFwiRDhcIixcblx0XHRyZnhNRkQ6IFwiTUZEXCIsXG5cdFx0ZGluZjogXCJEaW5mXCIsXG5cdFx0dmVydGljYWw6IFwiVmVydGljYWxcIixcblx0XHRob3Jpem9udGFsOiBcIkhvcml6b250YWxcIixcblx0XHRsb2NhbENlbGxTdGF0aXN0aWNzTWFqb3JpdHk6IFwiTWF5b3LDrWFcIixcblx0XHRsb2NhbENlbGxTdGF0aXN0aWNzTWF4OiBcIk3DoXhpbW9cIixcblx0XHRsb2NhbENlbGxTdGF0aXN0aWNzTWVhbjogXCJWYWxvciBtZWRpb1wiLFxuXHRcdGxvY2FsQ2VsbFN0YXRpc3RpY3NNZWRpYW46IFwiTWVkaWFuYVwiLFxuXHRcdGxvY2FsQ2VsbFN0YXRpc3RpY3NNaW46IFwiTcOtbmltb1wiLFxuXHRcdGxvY2FsQ2VsbFN0YXRpc3RpY3NNaW5vcml0eTogXCJNaW5vcsOtYVwiLFxuXHRcdGxvY2FsQ2VsbFN0YXRpc3RpY3NSYW5nZTogXCJSYW5nb1wiLFxuXHRcdGxvY2FsQ2VsbFN0YXRpc3RpY3NTdGREZXY6IFwiRGVzdmlhY2nDs24gZXN0w6FuZGFyXCIsXG5cdFx0bG9jYWxDZWxsU3RhdGlzdGljc1N1bTogXCJTdW1hXCIsXG5cdFx0bG9jYWxDZWxsU3RhdGlzdGljc1ZhcmlldHk6IFwiVmFyaWVkYWRcIixcblx0XHRsb2NhbENlbGxTdGF0aXN0aWNzTWFqb3JpdHlJZ25vcmVORDogXCJNYXlvcsOtYSAoaWdub3JhciBOb0RhdGEpXCIsXG5cdFx0bG9jYWxDZWxsU3RhdGlzdGljc01heElnbm9yZU5EOiBcIk3DoXhpbW8gKGlnbm9yYXIgTm9EYXRhKVwiLFxuXHRcdGxvY2FsQ2VsbFN0YXRpc3RpY3NNZWFuSWdub3JlTkQ6IFwiTWVkaWEgKGlnbm9yYXIgTm9EYXRhKVwiLFxuXHRcdGxvY2FsQ2VsbFN0YXRpc3RpY3NNZWRpYW5JZ25vcmVORDogXCJNZWRpYW5hIChpZ25vcmFyIE5vRGF0YSlcIixcblx0XHRsb2NhbENlbGxTdGF0aXN0aWNzTWluSWdub3JlTkQ6IFwiTcOtbmltbyAoaWdub3JhciBOb0RhdGEpXCIsXG5cdFx0bG9jYWxDZWxsU3RhdGlzdGljc01pbm9yaXR5SWdub3JlTkQ6IFwiTWlub3LDrWEgKGlnbm9yYXIgTm9EYXRhKVwiLFxuXHRcdGxvY2FsQ2VsbFN0YXRpc3RpY3NSYW5nZUlnbm9yZU5EOiBcIlJhbmdvIChpZ25vcmFyIE5vRGF0YSlcIixcblx0XHRsb2NhbENlbGxTdGF0aXN0aWNzU3RkRGV2SWdub3JlTkQ6IFwiRGVzdmlhY2nDs24gZXN0w6FuZGFyIChpZ25vcmFyIE5vRGF0YSlcIixcblx0XHRsb2NhbENlbGxTdGF0aXN0aWNzU3VtSWdub3JlTkQ6IFwiU3VtYSAoaWdub3JhciBOb0RhdGEpXCIsXG5cdFx0bG9jYWxDZWxsU3RhdGlzdGljc1ZhcmlldHlJZ25vcmVORDogXCJWYXJpZWRhZCAoaWdub3JhciBOb0RhdGEpXCIsXG5cdFx0bG9jYWxDZWxsU3RhdGlzdGljc1R5cGVQZXJjZW50aWxlSWdub3JlTkQ6IFwiUGVyY2VudGlsIChpZ25vcmFyIE5vRGF0YSlcIixcblx0XHRmcm9tU291cmNlOiBcIkRlIG9yaWdlblwiLFxuXHRcdHRvU291cmNlOiBcIkEgb3JpZ2VuXCIsXG5cdFx0Y29sb3JzcGFjZUNvbnZlcnNpb25SZ2JUb0hzdjogXCJSR0IgYSBIU1ZcIixcblx0XHRjb2xvcnNwYWNlQ29udmVyc2lvbkhzdlRvUmdiOiBcIkhTViBhIFJHQlwiLFxuXHRcdHBhbnNoYXJwZW5UeXBlSUhTOiBcIklIU1wiLFxuXHRcdHBhbnNoYXJwZW5UeXBlQnJvdmV5OiBcIkJyb3ZleVwiLFxuXHRcdHBhbnNoYXJwZW5UeXBlRXNyaTogXCJFc3JpXCIsXG5cdFx0cGFuc2hhcnBlblR5cGVNZWFuOiBcIlZhbG9yIG1lZGlvXCIsXG5cdFx0cGFuc2hhcnBlblR5cGVHcmFtU2NobWlkdDogXCJHcmFtLVNjaG1pZHRcIixcblx0XHRyZWN0YW5nbGVOZWlnaGJvcmhvb2Q6IFwiUmVjdMOhbmd1bG9cIixcblx0XHRjaXJjbGVOZWlnaGJvcmhvb2Q6IFwiQ8OtcmN1bG9cIixcblx0XHRhbm51bHVzTmVpZ2hib3Job29kOiBcIkFuaWxsb1wiLFxuXHRcdHdlZGdlTmVpZ2hib3Job29kOiBcIlBvcmNpw7NuIGRlIGPDrXJjdWxvXCIsXG5cdFx0aXJyZWd1bGFyTmVpZ2hib3Job29kOiBcIklycmVndWxhclwiLFxuXHRcdHdlaWdodE5laWdoYm9yaG9vZDogXCJQZXNvXCIsXG5cdFx0Zm91cjogXCJDdWF0cm9cIixcblx0XHRlaWdodDogXCJPY2hvXCIsXG5cdFx0d2l0aGluOiBcIkRlbnRybyBkZVwiLFxuXHRcdGNyb3NzOiBcIkNydXpcIixcblx0XHRhZGRMaW5rOiBcIkFncmVnYXIgdsOtbmN1bG9cIixcblx0XHRub0xpbms6IFwiU2luIHbDrW5jdWxvXCIsXG5cdFx0d2VpZ2h0ZWRNZWFuOiBcIk1lZGlhIHBvbmRlcmFkYVwiLFxuXHRcdGxzOFFDQml0UGF0dGVybkNpcnJ1czogXCJMYW5kc2F0IDggQ2lycnVzXCIsXG5cdFx0bHM4UUNCaXRQYXR0ZXJuQ2xvdWQ6IFwiTGFuZHNhdCA4IE51YmVcIixcblx0XHRsczhRQ0JpdFBhdHRlcm5DbG91ZFNoYWRvdzogXCJMYW5kc2F0IDggU29tYnJhIGRlIG51YmVcIixcblx0XHRsczhRQ0JpdFBhdHRlcm5EZXNpZ25hdGVkRmlsbDogXCJMYW5kc2F0IDggUmVsbGVub1wiLFxuXHRcdGxzOFFDQml0UGF0dGVybkRyb3BwZWRGcmFtZTogXCJMYW5kc2F0IDggRHJvcHBlZCBGcmFtZVwiLFxuXHRcdGxzOFFDQml0UGF0dGVyblNub3dJY2U6IFwiTGFuZHNhdCA4IE5pZXZlL0hpZWxvXCIsXG5cdFx0bHM4UUNCaXRQYXR0ZXJuVGVycmFpbk9jY2x1c2lvbjogXCJMYW5kc2F0IDggT2NsdXNpw7NuIGRlbCB0ZXJyZW5vXCIsXG5cdFx0bHM4UUNCaXRQYXR0ZXJuVmVnZXRhdGlvbjogXCJMYW5kc2F0IDggVmVnZXRhY2nDs25cIixcblx0XHRsczhRQ0JpdFBhdHRlcm5XYXRlcjogXCJMYW5kc2F0IDggQWd1YVwiLFxuXHRcdGRvd25TdHJlYW06IFwiQWd1YXMgYWJham9cIixcblx0XHR1cFN0cmVhbTogXCJBZ3VhcyBhcnJpYmFcIixcblx0XHRzdHJhaGxlcjogXCJTVFJBSExFUlwiLFxuXHRcdHNocmV2ZTogXCJTSFJFVkVcIixcblx0XHRjdXJyZW50U2xpY2U6IFwiRGl2aXNpw7NuIGFjdHVhbFwiLFxuXHRcdGFsbFNsaWNlczogXCJUb2RhcyBsYXMgZGl2aXNpb25lc1wiLFxuXHRcdGV4cGFuZERpc3RhbmNlOiBcIkRJU1RBTkNFXCIsXG5cdFx0ZXhwYW5kTW9ycGhvbG9naWNhbDogXCJNT1JGT0zDk0dJQ09cIixcblx0XHRzcGVjdHJhbFByb2ZpbGVGaWxlOiBcIlBlcmZpbCBlc3BlY3RyYWxcIixcblx0XHR0cmFpbmluZ0ZlYXR1cmVGaWxlOiBcIkVudGlkYWQgZGUgZW50cmVuYW1pZW50b1wiLFxuXHRcdHJhbmRvbURpc3RyaWJ1dGlvblR5cGVVbmlmb3JtOiBcIlVuaWZvcm1lXCIsXG5cdFx0cmFuZG9tRGlzdHJpYnV0aW9uVHlwZVVuaWZvcm1JbnRlZ2VyOiBcIkVudGVyb1wiLFxuXHRcdHJhbmRvbURpc3RyaWJ1dGlvblR5cGVOb3JtYWw6IFwiTm9ybWFsXCIsXG5cdFx0cmFuZG9tRGlzdHJpYnV0aW9uVHlwZUV4cG9uZW50aWFsOiBcIkV4cG9uZW5jaWFsXCIsXG5cdFx0cmFuZG9tRGlzdHJpYnV0aW9uVHlwZVBvaXNzb246IFwiUG9pc3NvblwiLFxuXHRcdHJhbmRvbURpc3RyaWJ1dGlvblR5cGVHYW1tYTogXCJHYW1tYVwiLFxuXHRcdHJhbmRvbURpc3RyaWJ1dGlvblR5cGVCaW5vbWlhbDogXCJCaW5vbWlhbFwiLFxuXHRcdHJhbmRvbURpc3RyaWJ1dGlvblR5cGVHZW9tZXRyaWM6IFwiR2VvbcOpdHJpY2FcIixcblx0XHRyYW5kb21EaXN0cmlidXRpb25UeXBlTmVnYXRpdmVCaW5vbWlhbDogXCJCaW5vbWlhbCBuZWdhdGl2YVwiLFxuXHRcdHJhbmRvbUdlbmVyYXRvclR5cGVTdGFuZGFyZENSYW5kOiBcIlJhbmQgQyBlc3TDoW5kYXJcIixcblx0XHRyYW5kb21HZW5lcmF0b3JUeXBlQWxnb3JpdGhtQUNNNTk5OiBcIkFsZ29yaXRtbyA1OTkgY2FwdHVyYWRvIHBvciBBQ01cIixcblx0XHRyYW5kb21HZW5lcmF0b3JUeXBlTWVyc2VubmVUd2lzdGVyOiBcIk1lcnNlbm5lIFR3aXN0ZXJcIixcblx0XHRzdW1OYW1lOiBcIlN1bWFcIixcblx0XHRtZWRhaW5OYW1lOiBcIk1lZGlhbmFcIixcblx0XHR0cmVuZExpbmVhcjogXCJMaW5lYWxcIixcblx0XHR0cmVuZEhhcm1vbmljOiBcIkFybcOzbmljYVwiLFxuXHRcdHRyZW5kUG9seW5vbWlhbDogXCJQb2xpbsOzbWljYVwiLFxuXHRcdHRyZW5kTWFubktlbmRhbGw6IFwiTWFubi1LZW5kYWxsXCIsXG5cdFx0dHJlbmRTZWFzb25hbEtlbmRhbGw6IFwiU2Vhc29uYWwgS2VuZGFsbFwiLFxuXHRcdGRpbWVuc2lvbkJ5VmFsdWU6IFwiUG9yIHZhbG9yXCIsXG5cdFx0ZGltZW5zaW9uQnlJbnRlcnZhbDogXCJQb3IgaW50ZXJ2YWxvXCIsXG5cdFx0bWRpbURlZlR5cGVBbGw6IFwiVG9kb1wiLFxuXHRcdG1kaW1EZWZUeXBlQnlWYWx1ZXM6IFwiUG9yIHZhbG9yZXNcIixcblx0XHRtZGltRGVmVHlwZUJ5UmFuZ2VzOiBcIlBvciByYW5nb3NcIixcblx0XHRtZGltRGVmVHlwZUJ5SXRlcmF0aW9uOiBcIlBvciBpdGVyYWNpw7NuXCIsXG5cdFx0bWRpbURlZlR5cGVCeUludGVydmFsOiBcIlBvciBpbnRlcnZhbG9cIixcblx0XHRtZGltRGVmVHlwZUJ5VGFyZ2V0UmFzdGVyOiBcIlBvciByw6FzdGVyIGRlIGRlc3Rpbm9cIixcblx0XHRlc3JpVGltZVVuaXRzSG91cnM6IFwiSG9yYXNcIixcblx0XHRlc3JpVGltZVVuaXRzRGF5czogXCJEw61hc1wiLFxuXHRcdGVzcmlUaW1lVW5pdHNXZWVrczogXCJTZW1hbmFzXCIsXG5cdFx0ZXNyaVRpbWVVbml0c01vbnRoczogXCJNZXNlc1wiLFxuXHRcdGVzcmlUaW1lVW5pdHNZZWFyczogXCJBw7Fvc1wiLFxuXHRcdGVzcmlUaW1lSW50ZXJ2YWxLZXl3b3JkSG91cmx5OiBcIkNhZGEgaG9yYVwiLFxuXHRcdGVzcmlUaW1lSW50ZXJ2YWxLZXl3b3JkRGFpbHk6IFwiRGlhcmlhbWVudGVcIixcblx0XHRlc3JpVGltZUludGVydmFsS2V5d29yZFdlZWtseTogXCJTZW1hbmFsbWVudGVcIixcblx0XHRlc3JpVGltZUludGVydmFsS2V5d29yZERla2FkbHk6IFwiQ2FkYSBkw6ljYWRhXCIsXG5cdFx0ZXNyaVRpbWVJbnRlcnZhbEtleXdvcmRQZW50YWRseTogXCJDYWRhIGx1c3Ryb1wiLFxuXHRcdGVzcmlUaW1lSW50ZXJ2YWxLZXl3b3JkTW9udGhseTogXCJNZW5zdWFsbWVudGVcIixcblx0XHRlc3JpVGltZUludGVydmFsS2V5d29yZFF1YXJ0ZXJseTogXCJUcmltZXN0cmFsbWVudGVcIixcblx0XHRlc3JpVGltZUludGVydmFsS2V5d29yZFllYXJseTogXCJBbnVhbG1lbnRlXCIsXG5cdFx0ZXNyaVRpbWVJbnRlcnZhbEtleXdvcmRSZWN1cnJpbmdEYWlseTogXCJSZWN1cnJlbnRlIGRpYXJpYW1lbnRlXCIsXG5cdFx0ZXNyaVRpbWVJbnRlcnZhbEtleXdvcmRSZWN1cnJpbmdXZWVrbHk6IFwiUmVjdXJyZW50ZSBzZW1hbmFsbWVudGVcIixcblx0XHRlc3JpVGltZUludGVydmFsS2V5d29yZFJlY3VycmluZ01vbnRobHk6IFwiUmVjdXJyZW50ZSBtZW5zdWFsbWVudGVcIixcblx0XHRlc3JpVGltZUludGVydmFsS2V5d29yZFJlY3VycmluZ1F1YXJ0ZXJseTogXCJSZWN1cnJlbnRlIHRyaW1lc3RyYWxtZW50ZVwiLFxuXHRcdGFnZ0RlZlR5cGVBbGw6IFwiVG9kb1wiLFxuXHRcdGFnZ0RlZlR5cGVJbnRlcnZhbEtleXdvcmQ6IFwiUGFsYWJyYSBjbGF2ZSBkZSBpbnRlcnZhbG9cIixcblx0XHRhZ2dEZWZUeXBlSW50ZXJ2YWxWYWx1ZTogXCJWYWxvciBkZSBpbnRlcnZhbG9cIixcblx0XHRhZ2dEZWZUeXBlSW50ZXJ2YWxSYW5nZXM6IFwiUmFuZ29zIGRlIGludGVydmFsb3NcIixcblx0XHRsYXRlc3RDaGFuZ2U6IFwiSG9yYSBkZWwgY2FtYmlvIG3DoXMgcmVjaWVudGVcIixcblx0XHRlYXJsaWVzdENoYW5nZTogXCJIb3JhIGRlbCBjYW1iaW8gbcOhcyB0ZW1wcmFub1wiLFxuXHRcdGxhcmdlc3RDaGFuZ2U6IFwiSG9yYSBkZWwgY2FtYmlvIG3DoXMgZ3JhbmRlXCIsXG5cdFx0bnVtYmVyT2ZDaGFuZ2VzOiBcIk7Dum1lcm8gZGUgY2FtYmlvc1wiLFxuXHRcdGxvbmdlc3RDaGFuZ2U6IFwiSG9yYSBkZWwgY2FtYmlvIG3DoXMgbGFyZ29cIixcblx0XHRzaG9ydGVzdENoYW5nZTogXCJIb3JhIGRlbCBjYW1iaW8gbcOhcyBjb3J0b1wiLFxuXHRcdGZhc3Rlc3RDaGFuZ2U6IFwiSG9yYSBkZWwgY2FtYmlvIG3DoXMgcsOhcGlkb1wiLFxuXHRcdHNsb3dlc3RDaGFuZ2U6IFwiSG9yYSBkZWwgY2FtYmlvIG3DoXMgbGVudG9cIixcblx0XHRhbGxDaGFuZ2VzOiBcIlRvZG9cIixcblx0XHRpbmNyZWFzZUNoYW5nZXM6IFwiQXVtZW50YXJcIixcblx0XHRkZWNyZWFzZUNoYW5nZXM6IFwiRGlzbWludWlyXCIsXG5cdFx0c2VnbWVudEJlZ2lubmluZzogXCJJbmljaW8gZGVsIHNlZ21lbnRvXCIsXG5cdFx0c2VnbWVudEVuZDogXCJGaW4gZGVsIHNlZ21lbnRvXCIsXG5cdFx0ZXNyaUNvbXB1dGVDaGFuZ2VNZXRob2REaWZmZXJlbmNlOiBcIkRpZmVyZW5jaWFcIixcblx0XHRlc3JpQ29tcHV0ZUNoYW5nZU1ldGhvZFJlbGF0aXZlRGlmZmVyZW5jZTogXCJEaWZlcmVuY2lhIHJlbGF0aXZhXCIsXG5cdFx0ZXNyaUNvbXB1dGVDaGFuZ2VNZXRob2RDYXRlZ29yaWNhbDogXCJEaWZlcmVuY2lhIGRlIGNhdGVnb3LDrWFcIixcblx0XHRlc3JpQ29tcHV0ZUNoYW5nZU1ldGhvZE11bHRpc3BlY3RyYWxFdWNsaWRlYW5EaXN0YW5jZTogXCJEaXN0YW5jaWEgZXVjbGlkaWFuYSBlc3BlY3RyYWxcIixcblx0XHRlc3JpQ29tcHV0ZUNoYW5nZU1ldGhvZE11bHRpc3BlY3RyYWxBbmd1bGFyRGlmZmVyZW5jZTogXCJEaWZlcmVuY2lhIGRlIMOhbmd1bG8gZXNwZWN0cmFsXCIsXG5cdFx0ZXNyaUNvbXB1dGVDaGFuZ2VNZXRob2RNdWx0aXNwZWN0cmFsQXhpc1dpdGhCaWdnZXN0Q2hhbmdlOiBcIkJhbmRhIGNvbiBtw6FzIGNhbWJpb1wiLFxuXHRcdGVzcmlDb21wdXRlQ2hhbmdlS2VlcEFsbDogXCJDb25zZXJ2YXIgdG9kb1wiLFxuXHRcdGVzcmlDb21wdXRlQ2hhbmdlS2VlcENoYW5nZWRPbmx5OiBcIkNvbnNlcnZhciBzb2xvIHDDrXhlbGVzIG1vZGlmaWNhZG9zXCIsXG5cdFx0ZXNyaUNvbXB1dGVDaGFuZ2VLZWVwVW5jaGFuZ2VkT25seTogXCJDb25zZXJ2YXIgc29sbyBww614ZWxlcyBubyBtb2RpZmljYWRvc1wiLFxuXHRcdGVzcmlDb21wdXRlQ2hhbmdlVXNlQ29sb3JBdmVyYWdlOiBcIlByb21lZGlvIGRlIGRlc2RlIHkgaGFzdGEgY29sb3Jlc1wiLFxuXHRcdGVzcmlDb21wdXRlQ2hhbmdlVXNlQ29sb3JGcm9tOiBcIlV0aWxpemFyIGNvbG9yZXMgZGVzZGVcIixcblx0XHRlc3JpQ29tcHV0ZUNoYW5nZVVzZUNvbG9yVG86IFwiVXRpbGl6YXIgY29sb3JlcyBoYXN0YVwiLFxuXHRcdGZhY3RvckZ1bmN0aW9uQmluYXJ5OiBcIkJpbmFyaW9cIixcblx0XHRmYWN0b3JGdW5jdGlvbkZvcndhcmQ6IFwiSGFjaWEgZGVsYW50ZVwiLFxuXHRcdGZhY3RvckZ1bmN0aW9uTGluZWFyOiBcIkxpbmVhbFwiLFxuXHRcdGZhY3RvckZ1bmN0aW9uSW52TGluZWFyOiBcIkxpbmVhbCBpbnZlcnNhXCIsXG5cdFx0ZmFjdG9yRnVuY3Rpb25UYWJsZTogXCJUYWJsYVwiLFxuXHRcdGZhY3RvckZ1bmN0aW9uU3ltTGluZWFyOiBcIkxpbmVhbCBzaW3DqXRyaWNvXCIsXG5cdFx0ZmFjdG9yRnVuY3Rpb25TeW1JbnZMaW5lYXI6IFwiTGluZWFsIGludmVyc28gc2ltw6l0cmljb1wiLFxuXHRcdGZhY3RvckZ1bmN0aW9uQ29zOiBcIkNvc2Vub1wiLFxuXHRcdGZhY3RvckZ1bmN0aW9uU2VjOiBcIlNlY2FudGVcIixcblx0XHRmYWN0b3JGdW5jdGlvbkNvc1NlYzogXCJTZWNhbnRlIGRlIGNvc2Vub1wiLFxuXHRcdGZhY3RvckZ1bmN0aW9uU2VjQ29zOiBcIkNvc2VubyBkZSBzZWNhbnRlXCIsXG5cdFx0bm9Tb3J0OiBcIk5vIG9yZGVuYXJcIixcblx0XHRhc2NlbmQ6IFwiQXNjZW5kZXJcIixcblx0XHRkZXNjZW5kOiBcIkRlc2NlbmRlclwiLFxuXHRcdGF1dG9EZXRlY3Q6IFwiRGV0ZWNjacOzbiBhdXRvbcOhdGljYVwiLFxuXHRcdG5lYXJlc3Q6IFwiTcOhcyBjZXJjYW5vXCIsXG5cdFx0bGluZWFyOiBcIkxpbmVhbFwiLFxuXHRcdGVzcmlNb250aEphbnVhcnk6IFwiRW5lcm9cIixcblx0XHRlc3JpTW9udGhGZWJydWFyeTogXCJGZWJyZXJvXCIsXG5cdFx0ZXNyaU1vbnRoTWFyY2g6IFwiTWFyem9cIixcblx0XHRlc3JpTW9udGhBcHJpbDogXCJBYnJpbFwiLFxuXHRcdGVzcmlNb250aE1heTogXCJNYXlvXCIsXG5cdFx0ZXNyaU1vbnRoSnVuZTogXCJKdW5pb1wiLFxuXHRcdGVzcmlNb250aEp1bHk6IFwiSnVsaW9cIixcblx0XHRlc3JpTW9udGhBdWd1c3Q6IFwiQWdvc3RvXCIsXG5cdFx0ZXNyaU1vbnRoU2VwdGVtYmVyOiBcIlNlcHRpZW1icmVcIixcblx0XHRlc3JpTW9udGhPY3RvYmVyOiBcIk9jdHVicmVcIixcblx0XHRlc3JpTW9udGhOb3ZlbWJlcjogXCJOb3ZpZW1icmVcIixcblx0XHRlc3JpTW9udGhEZWNlbWJlcjogXCJEaWNpZW1icmVcIixcblx0XHRkaW1lbnNpb25hbE1vdmluZ0lnbm9yZU5vRGF0YTogXCJEYXRvc1wiLFxuXHRcdGRpbWVuc2lvbmFsTW92aW5nUHJvcGFnYXRlTm9EYXRhOiBcIk5vRGF0YVwiLFxuXHRcdGRpbWVuc2lvbmFsTW92aW5nRmlsbE9ubHlOb0RhdGE6IFwiUmVsbGVuYXIgTm9EYXRhXCIsXG5cdFx0Y2lyY3VsYXJNZWFuOiBcIlZhbG9yIG1lZGlvIGNpcmN1bGFyXCIsXG5cdFx0Y2lyY3VsYXJOYW1lOiBcIkNpcmN1bGFyXCIsXG5cdFx0YXJpdGhtZXRpY05hbWU6IFwiQXJpdG3DqXRpY2FcIixcblx0XHRzbG9wZU5hbWU6IFwiUGVuZGllbnRlXCIsXG5cdFx0YXNwZWN0TmFtZTogXCJPcmllbnRhY2nDs25cIixcblx0XHRtZWFuQ3VydmF0dXJlOiBcIkN1cnZhdHVyYSBtZWRpYVwiLFxuXHRcdHByb2ZpbGVDdXJ2YXR1cmU6IFwiQ3VydmF0dXJhIGRlIHBlcmZpbCAobMOtbmVhIGRlIHBlbmRpZW50ZSBub3JtYWwpXCIsXG5cdFx0dGFuZ2VudGlhbEN1cnZhdHVyZTogXCJDdXJ2YXR1cmEgdGFuZ2VuY2lhbCAoY3VydmEgZGUgbml2ZWwgbm9ybWFsKVwiLFxuXHRcdHBsYW5DdXJ2YXR1cmU6IFwiQ3VydmF0dXJhIGRlbCBwbGFubyAoY3VydmEgZGUgbml2ZWwgcHJveWVjdGFkYSlcIixcblx0XHRjb250b3VyR2VvZGVzaWNUb3JzaW9uOiBcIlRvcnNpw7NuIGdlb2TDqXNpY2EgZGUgY3VydmFzIGRlIG5pdmVsXCIsXG5cdFx0Z2F1c3NpYW5DdXJ2YXR1cmU6IFwiQ3VydmF0dXJhIGdhdXNzaWFuYVwiLFxuXHRcdGNhc29yYXRpQ3VydmF0dXJlOiBcIkN1cnZhdHVyYSBkZSBDYXNvcmF0aVwiLFxuXHRcdGxvY2FsU3VyZmFjZVR5cGVRdWFkcmF0aWM6IFwiQ3VhZHLDoXRpY2FcIixcblx0XHRsb2NhbFN1cmZhY2VUeXBlQmlxdWFkcmF0aWM6IFwiQmljdWFkcsOhdGljYVwiLFxuXHRcdHRocmVzaG9sZE5vVGhyZXNob2xkOiBcIk5pbmfDum4gdW1icmFsXCIsXG5cdFx0dGhyZXNob2xkUGVyY2VudExlYXN0Q29zdDogXCJQb3JjZW50YWplIGRlbCBtZW5vciBjb3N0ZVwiLFxuXHRcdHRocmVzaG9sZEFjY3VtdWxhdGl2ZUNvc3Q6IFwiQ29zdGUgYWN1bXVsYXRpdm9cIixcblx0XHRjbHJtYXBUeXBlSGlsbHNoYWRlOiBcIlNvbWJyZWFkb1wiXG5cdH0sXG5cdGNhdGVnb3J5TGFiZWxzOiB7XG5cdFx0c291cmNlQ2hhcmFjdGVyaXN0aWNzOiBcIkNhcmFjdGVyw61zdGljYXMgZGUgb3JpZ2VuXCIsXG5cdFx0bmVpZ2hib3Job29kU2V0dGluZ3M6IFwiQ29uZmlndXJhY2nDs24gZGUgdmVjaW5kYWRcIixcblx0XHRzdGF0aXN0aWNzOiBcIkVzdGFkw61zdGljYXNcIixcblx0XHRnYW1tYTogXCJHYW1tYVwiLFxuXHRcdHZpZXdzaGVkUGFyYW1ldGVyczogXCJQYXLDoW1ldHJvcyBkZSBjdWVuY2EgdmlzdWFsXCIsXG5cdFx0b2JzZXJ2ZXJQYXJhbWV0ZXJzOiBcIlBhcsOhbWV0cm9zIGRlIG9ic2VydmFkb3JcIixcblx0XHRpcnJlZ3VsYXJEYXRhSW50ZXJwb2xhdGlvbjogXCJJbnRlcnBvbGFjacOzbiBkZSBkYXRvcyBpcnJlZ3VsYXJlc1wiLFxuXHRcdG1vZGVsU3RhdGlzdGljczogXCJFc3RhZMOtc3RpY2FzIGRlIG1vZGVsb1wiLFxuXHRcdGFnZ3JlZ2F0aW9uRGVmOiBcIkRlZmluaWNpw7NuIGRlIGFncmVnYWNpw7NuXCIsXG5cdFx0ZmlsdGVyQnlBdHRyaWJ1dGVzOiBcIkZpbHRyYXIgcG9yIGF0cmlidXRvc1wiLFxuXHRcdHBlcmNlbnRpbGVOYW1lOiBcIlBlcmNlbnRpbFwiLFxuXHRcdHJhc3RlckluZm86IFwiSW5mb3JtYWNpw7NuIGRlbCByw6FzdGVyXCIsXG5cdFx0ZXh0ZW50OiBcIkV4dGVuc2nDs25cIixcblx0XHRzcGF0aWFsUmVmZXJlbmNlOiBcIlJlZmVyZW5jaWEgZXNwYWNpYWxcIlxuXHR9LFxuXHRvdXRwdXRSYXN0ZXJIZWxwVGV4dHM6IHtcblx0XHRvdXRwdXROYW1lOiBcIjxwPkVsIG5vbWJyZSBkZSBsYSBjYXBhIHF1ZSBzZSBjcmVhcsOhIHkgc2UgYWdyZWdhcsOhIGFsIG1hcGEuPC9wPlwiLFxuXHRcdHJlc3VsdFR5cGU6IFwiPHA+RWwgdGlwbyBkZSBzYWxpZGEgcXVlIHNlIGNyZWFyw6EuIExhcyBzYWxpZGFzIHB1ZWRlbiBzZXIgY2FwYXMgZGUgaW3DoWdlbmVzIGVuIHRlc2VsYXMgbyBjYXBhcyBkZSBpbcOhZ2VuZXMgZGluw6FtaWNhcy48L3A+XCIsXG5cdFx0c2F2ZVJlc3VsdEluOiBcIjxwPkVsIG5vbWJyZSBkZSBsYSBjYXJwZXRhIGRlIDxiPk1pIGNvbnRlbmlkbzwvYj4gZW4gbGEgcXVlIHNlIGd1YXJkYXLDoSBlbCByZXN1bHRhZG8uPC9wPlwiXG5cdH0sXG5cdGFuYWx5c2lzRW52aXJvbm1lbnRzSGVscFRleHRzOiB7XG5cdFx0ZGVzY3JpcHRpb246IFwiPHA+Q29uZmlndXJhY2nDs24gZGVsIGVudG9ybm8gcGFyYSBlbCBhbsOhbGlzaXMgZW4gTWFwIFZpZXdlci4gPC9wPlwiLFxuXHRcdG91dFNSOiBcIjxwPkVzcGVjaWZpY2EgZWwgc2lzdGVtYSBkZSBjb29yZGVuYWRhcyBwYXJhIGVsIGFuw6FsaXNpcyB5IGxhIGNhcGEgZGUgcmVzdWx0YWRvcy48L3A+XCIsXG5cdFx0ZXh0ZW50OiBcIjxwPkVzcGVjaWZpY2EgZWwgw6FyZWEgcXVlIHNlIHZhIGEgdXRpbGl6YXIgcGFyYSBlbCBhbsOhbGlzaXMuPC9wPlwiLFxuXHRcdHNuYXBSYXN0ZXI6IFwiPHA+QWp1c3RhIGxhIGV4dGVuc2nDs24gZGUgbGEgc2FsaWRhIHBhcmEgcXVlIGNvaW5jaWRhIGNvbiBsYSBhbGluZWFjacOzbiBkZSBjZWxkYSBkZSBsYSBjYXBhIHLDoXN0ZXIgZGUgYWxpbmVhY2nDs24gZXNwZWNpZmljYWRhLjwvcD5cIixcblx0XHRjZWxsU2l6ZTogXCI8cD5Fc3BlY2lmaWNhIGVsIHRhbWHDsW8gbyBsYSByZXNvbHVjacOzbiBkZSBjZWxkYSBxdWUgc2UgdXRpbGl6YXLDoSBwYXJhIGNyZWFyIGxhIGNhcGEgcsOhc3RlciBkZSBzYWxpZGEuPC9wPlwiLFxuXHRcdG1hc2s6IFwiPHA+RXNwZWNpZmljYSB1bmEgY2FwYSBkZSBtw6FzY2FyYSwgZW4gbGEgcXVlIHNvbG8gc2UgdXRpbGl6YXLDoW4gcGFyYSBlbCBhbsOhbGlzaXMgbGFzIGNlbGRhcyBxdWUgc2UgZW5jdWVudHJlbiBkZW50cm8gZGVsIMOhcmVhIGRlIGxhIG3DoXNjYXJhLjwvcD5cIixcblx0XHRyZXNhbXBsaW5nTWV0aG9kOiBcIjxwPkVzcGVjaWZpY2EgY8OzbW8gaW50ZXJwb2xhciB2YWxvcmVzIGRlIHDDrXhlbCBjdWFuZG8gbG9zIHLDoXN0ZXJlcyBkZSBlbnRyYWRhIHkgc2FsaWRhIG5vIHNlIGFsaW5lYW4uPC9wPlwiXG5cdH0sXG5cdG1haW5HZW5TdHJpbmdzOiB7XG5cdFx0dW5zdXBwb3J0ZWREYXRhVHlwZTogXCJUaXBvIG5vIGFkbWl0aWRvXCIsXG5cdFx0Y3VycmVudGx5VW5zdXBwb3J0ZWQ6IFwiIEhheSBwZW5kaWVudGUgdW4gZWRpdG9yIHByZWRldGVybWluYWRvIHBhcmEgJHttaXNzaW5nVHlwZX0sIHBlcm8gZXN0YXLDoSBkaXNwb25pYmxlIHByw7N4aW1hbWVudGUuIEN1YWRybyBkZSB0ZXh0byBkZSBtYXJjYWRvciBkZSBwb3NpY2nDs24gdGVtcG9yYWwgcGFyYSBlc3BlY2lmaWNhciBlbnRyYWRhcyBiYXNhZGFzIGVuIGNhZGVuYXMgZGUgY2FyYWN0ZXJlcy5cIixcblx0XHR1bnN1cHBvcnRlZE92ZXJyaWRlV2FybmluZzogXCJIYXkgcGVuZGllbnRlIHVuIGNvbXBvbmVudGUgZGUgZWRpdG9yIGRlIGV4Y2VwY2lvbmVzIHF1ZSBwcm9wb3JjaW9uYSB1bmEgbWVqb3IgZXhwZXJpZW5jaWEgZGUgdXN1YXJpbyBwYXJhIHRyYWJhamFyIGNvbiBsb3Mgc2lndWllbnRlcyBwYXLDoW1ldHJvcywgcGVybyBlc3RhcsOhIGRpc3BvbmlibGUgcHLDs3hpbWFtZW50ZTpcIixcblx0XHRvdmVycmlkZVdpZGdldE1pc3Npbmc6IFwiwqFGYWx0YSBlbCBjb21wb25lbnRlIGRlIGVkaXRvciBkZSBleGNlcGNpb25lcyFcIixcblx0XHR1aUluY29tcGxldGU6IFwiRXJyb3IgYWwgZW52aWFyIHRyYWJham8uIE5vIHNlIHB1ZWRlIGVqZWN1dGFyIGxhIGZ1bmNpw7NuIHBvcnF1ZSBhbGd1bm9zIGRlIGxvcyBjYW1wb3MgcmVxdWVyaWRvcyBlc3TDoW4gaW5jb21wbGV0b3MgbyBmYWx0YW4gZW4gbGEgVUkuXCIsXG5cdFx0Y291bnQ6IFwiUmVjdWVudG9cIixcblx0XHRzZWxlY3RWYXJpYWJsZXM6IFwiU2VsZWNjaW9uYXIgdmFyaWFibGVzXCIsXG5cdFx0c2VsZWN0RmVhdHVyZTogXCJTZWxlY2Npb25hciB1bmEgY2FwYSBkZSBlbnRpZGFkZXNcIixcblx0XHRncmVhdGVyVGhhbkVycm9yTWVzc2FnZTogXCJFbCBuw7ptZXJvIGRlIGVudHJhZGEgZGViZSBzZXIgbWF5b3IgcXVlICR7bWlufVwiLFxuXHRcdGxlc3NlclRoYW5FcnJvck1lc3NhZ2U6IFwiRWwgbsO6bWVybyBkZSBlbnRyYWRhIGRlYmUgc2VyIG1lbm9yIHF1ZSAke21heH1cIixcblx0XHRncmVhdGVyVGhhbk9yRXF1YWxFcnJvck1lc3NhZ2U6IFwiRWwgbsO6bWVybyBkZSBlbnRyYWRhIGRlYmUgc2VyIG1heW9yIG8gaWd1YWwgcXVlICR7bWlufVwiLFxuXHRcdGxlc3NlclRoYW5PckVxdWFsRXJyb3JNZXNzYWdlOiBcIkVsIG7Dum1lcm8gZGUgZW50cmFkYSBkZWJlIHNlciBtZW5vciBvIGlndWFsIHF1ZSAke21heH1cIixcblx0XHRhbGxvd1NjYWxhcjogXCJTZWxlY2Npb25lIHVuYSBjYXBhIG8gaW50cm9kdXpjYSB1bmEgY29uc3RhbnRlXCIsXG5cdFx0c2VsZWN0RmllbGQ6IFwiU2VsZWNjaW9uYXIgY2FtcG9cIixcblx0XHRwYXJhbWV0ZXJSZXF1aXJlZDogXCJFc3RlIHBhcsOhbWV0cm8gZXMgb2JsaWdhdG9yaW8uXCIsXG5cdFx0ZW50ZXJBVmFsdWU6IFwiSW50cm9kdXpjYSB1biB2YWxvci4uLlwiLFxuXHRcdGludmFsaWRJbnB1dDogXCJFbCB2YWxvciBpbnRyb2R1Y2lkbyBubyBlcyB2w6FsaWRvLlwiLFxuXHRcdGl0ZW1Ob3RGb3VuZDogXCJFbCBlbGVtZW50byBubyBleGlzdGUgbyBubyBlcyBhY2Nlc2libGUuXCIsXG5cdFx0aXRlbVBlcm1pc3Npb25EZW5pZWQ6IFwiTm8gdGllbmUgcGVybWlzb3MgcGFyYSBhY2NlZGVyIGEgZXN0ZSBlbGVtZW50by5cIixcblx0XHRsYXllck5vdEF2YWlsYWJsZTogXCJGYWxsbyBhbCBjYXJnYXIgbGEgY2FwYSAke2xheWVyTmFtZX0uXCIsXG5cdFx0bXVsdGlwbGVMYXllcnNOb3RBdmFpbGFibGU6IFwiRXJyb3IgYWwgY2FyZ2FyIGxhIGNhcGEgJHtsYXllck5hbWV9IHkgb3Ryb3MuXCIsXG5cdFx0bGVhcm5Nb3JlTGFiZWw6IFwiTcOhcyBpbmZvcm1hY2nDs25cIixcblx0XHRmaWVsZE5vdEF2YWlsYWJsZTogXCJFcnJvciBhbCBjYXJnYXIgZWwgY2FtcG8uXCIsXG5cdFx0YWxsb3dBbmFseXNpczogXCJObyBzZSBwZXJtaXRlIGVsIGFuw6FsaXNpcyBlbiBlbCBzZXJ2aWNpbyBkZSBpbcOhZ2VuZXMuXCIsXG5cdFx0YWxsb3dBbmFseXNpc1JlYXNvbjogXCJVbmEgbyB2YXJpYXMgY2FwYXMgZGVsIG1hcGEgbm8gZmlndXJhbiBhcXXDrSBwb3JxdWUgbm8gcGVybWl0ZW4gZWwgYW7DoWxpc2lzLlwiLFxuXHRcdGxlYXJuTW9yZVRleHQ6IFwiTcOhcyBpbmZvcm1hY2nDs25cIixcblx0XHRhdExlYXN0T25lUmFzdGVySW5wdXQ6IFwiQWwgbWVub3MgdW5hIGNhcGEgZGUgZW50cmFkYSBkZWJlIHNlciB1bmEgY2FwYSByw6FzdGVyLlwiLFxuXHRcdGJyb3dzZUFuYWx5c2lzTGF5ZXJzOiBcIkV4YW1pbmFyIGNhcGFzXCIsXG5cdFx0YWN0aXZlTWFwVmlld0V4dGVudDogXCJVc2FyIGV4dGVuc2nDs24gZGVsIG1hcGEgYWN0dWFsXCIsXG5cdFx0Y2hvb3NlUmFzdGVyOiBcIkVsZWdpciByw6FzdGVyIGRlIHJlY29ydGVcIixcblx0XHRjaG9vc2VHZW9tZXRyeTogXCJFbGVnaXIgZ2VvbWV0csOtYSBkZSByZWNvcnRlXCIsXG5cdFx0cmVzdWx0VHlwZTogXCJUaXBvIGRlIHJlc3VsdGFkb1wiLFxuXHRcdHNhdmVJbkZvbGRlcjogXCJHdWFyZGFyIGVuIGNhcnBldGFcIixcblx0XHRvdXRwdXROYW1lOiBcIk5vbWJyZSBkZSBzYWxpZGFcIixcblx0XHRvdXRwdXRMYXllclR5cGU6IFwiVGlwbyBkZSBjYXBhIGRlIHNhbGlkYVwiLFxuXHRcdGR5bmFtaWNJbWFnZXJ5TGF5ZXI6IFwiQ2FwYSBkZSBpbcOhZ2VuZXMgZGluw6FtaWNhc1wiLFxuXHRcdHRpbGVkSW1hZ2VyeUxheWVyOiBcIkNhcGEgZGUgaW3DoWdlbmVzIGVuIHRlc2VsYXNcIixcblx0XHRjdXN0b206IFwiUGVyc29uYWxpemFkYVwiLFxuXHRcdGxvYWRpbmc6IFwiQ2FyZ2FuZG8uLi5cIixcblx0XHRsYXllck1pc3Npbmc6IFwiVW5hIG8gdmFyaWFzIGNhcGFzIGRlbCBtYXBhIG5vIGZpZ3VyYW4gYXF1w60gcG9ycXVlIG5vIHBlcm1pdGVuIGVsIGFuw6FsaXNpcy4gTcOhcyBpbmZvcm1hY2nDs24uXCIsXG5cdFx0YnJvd3NlQ29vcmRpbmF0ZVN5c3RlbXM6IFwiRXhhbWluYXIgc2lzdGVtYXMgZGUgY29vcmRlbmFkYXNcIixcblx0XHR1bmFibGVUb1JlcG9wdWxhdGVPdXRTUjogXCJObyBzZSBwdWVkZSBjb21wbGV0YXIgZWwgc2lzdGVtYSBkZSBjb29yZGVuYWRhcyBkZSBzYWxpZGEuXCIsXG5cdFx0ZGVmYXVsdFRpdGxlOiBcIlZlciBtw6FzXCIsXG5cdFx0XCJBUkMgKGVxdWFsIGFyYy1zZWNvbmQpXCI6IFwiQVJDIChhcmNvc2VndW5kbyBlcXVpdmFsZW50ZSlcIixcblx0XHRBZnJpY2E6IFwiw4FmcmljYVwiLFxuXHRcdEFudGFyY3RpY2E6IFwiQW50w6FydGlkYVwiLFxuXHRcdEFyZ2VudGluYTogXCJBcmdlbnRpbmFcIixcblx0XHRBc2lhOiBcIkFzaWFcIixcblx0XHRcIkFzdGVyb2lkIEJlbHRcIjogXCJDaW50dXLDs24gZGUgYXN0ZXJvaWRlc1wiLFxuXHRcdFwiQXRsYW50aWMgT2NlYW5cIjogXCJPY8OpYW5vIEF0bMOhbnRpY29cIixcblx0XHRBdXN0cmFsaWE6IFwiQXVzdHJhbGlhXCIsXG5cdFx0XCJBdXN0cmFsaWEgYW5kIE5ldyBaZWFsYW5kXCI6IFwiQXVzdHJhbGlhIHkgTnVldmEgWmVsYW5kYVwiLFxuXHRcdEF1c3RyaWE6IFwiQXVzdHJpYVwiLFxuXHRcdFwiQkxNIChVUyBGZWV0KVwiOiBcIkJMTSAocGllcyBFRS4gVVUuKVwiLFxuXHRcdEJhbmdsYWRlc2g6IFwiQmFuZ2xhZMOpc1wiLFxuXHRcdFwiQmVpamluZyAxOTU0XCI6IFwiUGVrw61uIDE5NTRcIixcblx0XHRCaHV0YW46IFwiQnV0w6FuXCIsXG5cdFx0Q0dDUzIwMDA6IFwiQ0dDUzIwMDBcIixcblx0XHRDYW5hZGE6IFwiQ2FuYWTDoVwiLFxuXHRcdENhcmliYmVhbjogXCJDYXJpYmVcIixcblx0XHRcIkNhcmliYmVhbiBTZWFcIjogXCJNYXIgQ2FyaWJlXCIsXG5cdFx0XCJDZW50cmFsIEFtZXJpY2FcIjogXCJDZW50cm9hbcOpcmljYVwiLFxuXHRcdFwiQ2VudHJhbCBhbmQgTm9ydGggQW1lcmljYVwiOiBcIk5vcnRlYW3DqXJpY2EgeSBDZW50cm9hbcOpcmljYVwiLFxuXHRcdENvbG9tYmlhOiBcIkNvbG9tYmlhXCIsXG5cdFx0Q29udGluZW50YWw6IFwiQ29udGluZW50YWxcIixcblx0XHRcIkNvdW50eSBTeXN0ZW1zXCI6IFwiU2lzdGVtYXMgZGUgY29uZGFkb1wiLFxuXHRcdFwiRGVtb2NyYXRpYyBSZXB1YmxpYyBvZiB0aGUgQ29uZ29cIjogXCJSZXDDumJsaWNhIERlbW9jcsOhdGljYSBkZWwgQ29uZ29cIixcblx0XHRcIkVQU0cgQXJjdGljXCI6IFwiRVBTRyBBcmN0aWNcIixcblx0XHRFYXJ0aDogXCJUaWVycmFcIixcblx0XHRcIkVsbGlwc29pZGFsLWJhc2VkXCI6IFwiQmFzYWRvIGVuIGVsaXBzb2lkYWxlc1wiLFxuXHRcdEV1cm9wZTogXCJFdXJvcGFcIixcblx0XHRGaW5sYW5kOiBcIkZpbmxhbmRpYVwiLFxuXHRcdEZyYW5jZTogXCJGcmFuY2lhXCIsXG5cdFx0XCJHU0sgMjAxMVwiOiBcIkdTSyAyMDExXCIsXG5cdFx0XCJHYXVzcyBLcnVnZXJcIjogXCJHYXVzcy1LcsO8Z2VyXCIsXG5cdFx0XCJHZW9ncmFwaGljIENvb3JkaW5hdGUgU3lzdGVtc1wiOiBcIlNpc3RlbWFzIGRlIGNvb3JkZW5hZGFzIGdlb2dyw6FmaWNhc1wiLFxuXHRcdEdlcm1hbnk6IFwiQWxlbWFuaWFcIixcblx0XHRcIkdyYXZpdHktcmVsYXRlZFwiOiBcIlJlbGFjaW9uYWRvIGNvbiBncmF2ZWRhZFwiLFxuXHRcdFwiR3JlZW53aWNoLWJhc2VkXCI6IFwiQmFzYWRvIGVuIEdyZWVud2ljaFwiLFxuXHRcdFwiSGlnaHdheXMgRW5nbGFuZFwiOiBcIkhpZ2h3YXlzIEVuZ2xhbmRcIixcblx0XHRJbGxpbm9pczogXCJJbGxpbm9pc1wiLFxuXHRcdFwiSW5kaWFuIE9jZWFuXCI6IFwiT2PDqWFubyDDjW5kaWNvXCIsXG5cdFx0XCJJbmRpYW4gU3ViY29udGluZW50XCI6IFwiU3ViY29udGluZW50ZSBpbmRpb1wiLFxuXHRcdEluZGlhbmE6IFwiSW5kaWFuYVwiLFxuXHRcdEluZG9uZXNpYTogXCJJbmRvbmVzaWFcIixcblx0XHRJb3dhOiBcIklvd2FcIixcblx0XHRcIklyZWxhbmQgYW5kIFVuaXRlZCBLaW5nZG9tXCI6IFwiSXJsYW5kYSB5IFJlaW5vIFVuaWRvXCIsXG5cdFx0SXRhbHk6IFwiSXRhbGlhXCIsXG5cdFx0SmFwYW46IFwiSmFww7NuXCIsXG5cdFx0SnVwaXRlcjogXCJKw7pwaXRlclwiLFxuXHRcdEthbnNhczogXCJLYW5zYXNcIixcblx0XHRcIkxhcyBWZWdhc1wiOiBcIkxhcyBWZWdhc1wiLFxuXHRcdExpYnlhOiBcIkxpYmlhXCIsXG5cdFx0TWFsYXlzaWE6IFwiTWFsYXNpYVwiLFxuXHRcdFwiTWFsYXlzaWEgYW5kIFNpbmdhcG9yZVwiOiBcIk1hbGFzaWEgeSBTaW5nYXB1clwiLFxuXHRcdE1hcnM6IFwiTWFydGVcIixcblx0XHRNZXJjdXJ5OiBcIk1lcmN1cmlvXCIsXG5cdFx0TWlubmVzb3RhOiBcIk1pbm5lc290YVwiLFxuXHRcdE1vbnRhbmE6IFwiTW9udGFuYVwiLFxuXHRcdFwiTkFEIDE5MjdcIjogXCJOQUQgMTkyN1wiLFxuXHRcdFwiTkFEIDE5MjcgKFVTIEZlZXQpXCI6IFwiTkFEIDE5MjcgKHBpZXMgRUUuIFVVLilcIixcblx0XHRcIk5BRCAxOTgzXCI6IFwiTkFEIDE5ODNcIixcblx0XHRcIk5BRCAxOTgzICgyMDExKVwiOiBcIk5BRCAxOTgzICgyMDExKVwiLFxuXHRcdFwiTkFEIDE5ODMgKDIwMTEpIChJbnRsIEZlZXQpXCI6IFwiTkFEIDE5ODMgKDIwMTEpIChwaWVzIGludGVybmFjaW9uYWwpXCIsXG5cdFx0XCJOQUQgMTk4MyAoMjAxMSkgKE1ldGVycylcIjogXCJOQUQgMTk4MyAoMjAxMSkgKG1ldHJvcylcIixcblx0XHRcIk5BRCAxOTgzICgyMDExKSAoVVMgRmVldClcIjogXCJOQUQgMTk4MyAoMjAxMSkgKHBpZXMgRUUuIFVVLilcIixcblx0XHRcIk5BRCAxOTgzIChDT1JTOTYpIChJbnRsIEZlZXQpXCI6IFwiTkFEIDE5ODMgKENPUlM5NikgKHBpZXMgaW50ZXJuYWNpb25hbClcIixcblx0XHRcIk5BRCAxOTgzIChDT1JTOTYpIChNZXRlcnMpXCI6IFwiTkFEIDE5ODMgKENPUlM5NikgKG1ldHJvcylcIixcblx0XHRcIk5BRCAxOTgzIChDT1JTOTYpIChVUyBGZWV0KVwiOiBcIk5BRCAxOTgzIChDT1JTOTYpIChwaWVzIEVFLiBVVS4pXCIsXG5cdFx0XCJOQUQgMTk4MyAoSW50bCBGZWV0KVwiOiBcIk5BRCAxOTgzIChwaWVzIGludGVybmFjaW9uYWwpXCIsXG5cdFx0XCJOQUQgMTk4MyAoTWV0ZXJzKVwiOiBcIk5BRCAxOTgzIChtZXRyb3MpXCIsXG5cdFx0XCJOQUQgMTk4MyAoUEExMSkgKE1ldGVycylcIjogXCJOQUQgMTk4MyAoUEExMSkgKG1ldHJvcylcIixcblx0XHRcIk5BRCAxOTgzIChQQTExKSAoVVMgRmVldClcIjogXCJOQUQgMTk4MyAoUEExMSkgKHBpZXMgRUUuIFVVLilcIixcblx0XHRcIk5BRCAxOTgzIChVUyBGZWV0KVwiOiBcIk5BRCAxOTgzIChwaWVzIEVFLiBVVS4pXCIsXG5cdFx0XCJOQUQgMTk4MyBIQVJOIChJbnRsIEZlZXQpXCI6IFwiTkFEIDE5ODMgSEFSTiAocGllcyBpbnRlcm5hY2lvbmFsKVwiLFxuXHRcdFwiTkFEIDE5ODMgSEFSTiAoTWV0ZXJzKVwiOiBcIk5BRCAxOTgzIEhBUk4gKG1ldHJvcylcIixcblx0XHRcIk5BRCAxOTgzIEhBUk4gKFVTIEZlZXQpXCI6IFwiTkFEIDE5ODMgSEFSTiAocGllcyBFRS4gVVUuKVwiLFxuXHRcdFwiTkFEIDE5ODMgTlNSUzIwMDcgKEludGwgRmVldClcIjogXCJOQUQgMTk4MyBOU1JTMjAwNyAocGllcyBpbnRlcm5hY2lvbmFsKVwiLFxuXHRcdFwiTkFEIDE5ODMgTlNSUzIwMDcgKE1ldGVycylcIjogXCJOQUQgMTk4MyBOU1JTMjAwNyAobWV0cm9zKVwiLFxuXHRcdFwiTkFEIDE5ODMgTlNSUzIwMDcgKFVTIEZlZXQpXCI6IFwiTkFEIDE5ODMgTlNSUzIwMDcgKHBpZXMgRUUuIFVVLilcIixcblx0XHRcIk5hdGlvbmFsIEdyaWRzXCI6IFwiQ3VhZHLDrWN1bGFzIG5hY2lvbmFsZXNcIixcblx0XHROYXZham86IFwiTmF2YWpvXCIsXG5cdFx0TmVwdHVuZTogXCJOZXB0dW5vXCIsXG5cdFx0XCJOZXcgQmVpamluZ1wiOiBcIk51ZXZvIFBla8OtblwiLFxuXHRcdFwiTmV3IFplYWxhbmRcIjogXCJOdWV2YSBaZWxhbmRhXCIsXG5cdFx0XCJOb3J0aCBBbWVyaWNhXCI6IFwiTm9ydGVhbcOpcmljYVwiLFxuXHRcdFwiTm9ydGhlcm4gSGVtaXNwaGVyZVwiOiBcIkhlbWlzZmVyaW8gc2VwdGVudHJpb25hbFwiLFxuXHRcdE5vcndheTogXCJOb3J1ZWdhXCIsXG5cdFx0T2NlYW5zOiBcIk9jw6lhbm9zXCIsXG5cdFx0T3JlZ29uOiBcIk9yZWfDs25cIixcblx0XHRcIk90aGVyIEdDU1wiOiBcIk90cm9zIHNpc3RlbWFzIEdDU1wiLFxuXHRcdFwiUGFjaWZpYyBPY2VhblwiOiBcIk9jw6lhbm8gUGFjw61maWNvXCIsXG5cdFx0UGx1dG86IFwiUGx1dMOzblwiLFxuXHRcdFBvbGFyOiBcIlBvbGFyXCIsXG5cdFx0UG9ydHVnYWw6IFwiUG9ydHVnYWxcIixcblx0XHRcIlByb2plY3RlZCBDb29yZGluYXRlIFN5c3RlbXNcIjogXCJTaXN0ZW1hcyBkZSBjb29yZGVuYWRhcyBwcm95ZWN0YWRhc1wiLFxuXHRcdFwiUHVsa292byAxOTQyXCI6IFwiUHVsa292byAxOTQyXCIsXG5cdFx0XCJQdWxrb3ZvIDE5OTVcIjogXCJQdWxrb3ZvIDE5OTVcIixcblx0XHRSZXBsYWNlZDogXCJTdXN0aXR1aWRvXCIsXG5cdFx0XCJTQUQgMTk2OVwiOiBcIlNBRCAxOTY5XCIsXG5cdFx0U0lSR0FTOiBcIlNJUkdBU1wiLFxuXHRcdFwiU0lSR0FTIDIwMDBcIjogXCJTSVJHQVMgMjAwMFwiLFxuXHRcdFNhdHVybjogXCJTYXR1cm5vXCIsXG5cdFx0XCJTb2xhciBTeXN0ZW1cIjogXCJTaXN0ZW1hIHNvbGFyXCIsXG5cdFx0XCJTb3V0aCBBZnJpY2FcIjogXCJTdWTDoWZyaWNhXCIsXG5cdFx0XCJTb3V0aCBBbWVyaWNhXCI6IFwiU3VkYW3DqXJpY2FcIixcblx0XHRcIlNvdXRoIEtvcmVhXCI6IFwiQ29yZWEgZGVsIFN1clwiLFxuXHRcdFwiU291dGhlcm4gSGVtaXNwaGVyZVwiOiBcIkhlbWlzZmVyaW8gbWVyaWRpb25hbFwiLFxuXHRcdFwiU3BoZXJvaWQtYmFzZWRcIjogXCJCYXNhZG8gZW4gZXNmZXJvaWRlc1wiLFxuXHRcdFwiU3RhdGUgUGxhbmVcIjogXCJQbGFubyBlc3RhdGFsXCIsXG5cdFx0XCJTdGF0ZSBTeXN0ZW1zXCI6IFwiU2lzdGVtYXMgZXN0YXRhbGVzXCIsXG5cdFx0U3dlZGVuOiBcIlN1ZWNpYVwiLFxuXHRcdFwiU3dpdHplcmxhbmQgYW5kIExpZWNodGVuc3RlaW5cIjogXCJTdWl6YSB5IExpZWNodGVuc3RlaW5cIixcblx0XHRUZXhhczogXCJUZXhhc1wiLFxuXHRcdFRyaWJhbDogXCJUcmliYWxcIixcblx0XHRUdXJrZXk6IFwiVHVycXXDrWFcIixcblx0XHRcIlVTIEZlZXRcIjogXCJQaWVzIGRlIEVFLiBVVS5cIixcblx0XHRcIlVTQSBhbmQgdGVycml0b3JpZXNcIjogXCJFc3RhZG9zIFVuaWRvcyB5IHRlcnJpdG9yaW9zXCIsXG5cdFx0VVRNOiBcIlVUTVwiLFxuXHRcdFVrcmFpbmU6IFwiVWNyYW5pYVwiLFxuXHRcdFwiVW5rbm93biBIZWlnaHQgU3lzdGVtc1wiOiBcIlNpc3RlbWFzIGRlIGFsdHVyYSBkZXNjb25vY2lkb3NcIixcblx0XHRVcmFudXM6IFwiVXJhbm9cIixcblx0XHRWZW51czogXCJWZW51c1wiLFxuXHRcdFwiVmVydGljYWwgQ29vcmRpbmF0ZSBTeXN0ZW1zXCI6IFwiU2lzdGVtYXMgZGUgY29vcmRlbmFkYXMgdmVydGljYWxlc1wiLFxuXHRcdFZpZXRuYW06IFwiVmlldG5hbVwiLFxuXHRcdFwiV0dTIDE5NzJcIjogXCJXR1MgMTk3MlwiLFxuXHRcdFwiV0dTIDE5ODRcIjogXCJXR1MgMTk4NFwiLFxuXHRcdFdpc2NvbnNpbjogXCJXaXNjb25zaW5cIixcblx0XHRcIldpc2NvbnNpbiBDUlNcIjogXCJXaXNjb25zaW4gQ1JTXCIsXG5cdFx0V29ybGQ6IFwiTXVuZG9cIixcblx0XHRcIldvcmxkIChTcGhlcmUtYmFzZWQpXCI6IFwiTXVuZG8gKGJhc2FkbyBlbiBTcGhlcmUpXCIsXG5cdFx0V3lvbWluZzogXCJXeW9taW5nXCIsXG5cdFx0XCJYaWFuIDE5ODBcIjogXCJYaWFuIDE5ODBcIixcblx0XHRkb25lOiBcIkxpc3RvXCIsXG5cdFx0bm9SZXN1bHRzOiBcIk5vIHNlIGVuY29udHLDsyBuaW5nw7puIHJlc3VsdGFkb1wiLFxuXHRcdHNlYXJjaFBsYWNlaG9sZGVyOiBcIk5vbWJyZSBlbiBXS0lEXCIsXG5cdFx0YnJvd3NlVGVtcGxhdGU6IFwiRXhhbWluYXIgcGxhbnRpbGxhcyBkZSBmdW5jacOzbiByw6FzdGVyXCIsXG5cdFx0c2F2ZVRlbXBsYXRlOiBcIkd1YXJkYXIgcGxhbnRpbGxhIGRlIGZ1bmNpw7NuIHLDoXN0ZXJcIixcblx0XHRwcmV2aWV3OiBcIlByZXZpc3VhbGl6YWNpw7NuXCIsXG5cdFx0cHJldmlld0Rlc2NyaXB0aW9uOiBcIk9idGVuZ2EgdW5hIHZpc3RhIHByZXZpYSBkZWwgcmVzdWx0YWRvIGFudGVzIGRlIGVqZWN1dGFyIGVsIGFuw6FsaXNpcy5cIixcblx0XHRzaG93UHJldmlldzogXCJNb3N0cmFyIHZpc3RhIHByZXZpYVwiLFxuXHRcdHByZXZpZXdMYXllcjogXCJDYXBhIGRlIHZpc3RhIHByZXZpYSAke251bWJlcn1cIixcblx0XHRuZXdQcmV2aWV3OiBcIk51ZXZhIHZpc3RhIHByZXZpYVwiLFxuXHRcdHByZXZpZXdQb3B1cDogXCJIYWJpbGl0ZSBsYSB2aXN0YSBwcmV2aWEgZGUgbG9zIHJlc3VsdGFkb3MgZGVsIGFuw6FsaXNpcyBzZWfDum4gbG9zIHBhcsOhbWV0cm9zIGRlIGVudHJhZGEuXCIsXG5cdFx0dXBkYXRlUHJldmlld0xheWVyOiBcIkFjdHVhbGl6YXIgbGEgY2FwYSBkZSB2aXN0YSBwcmV2aWEgc2VsZWNjaW9uYWRhXCIsXG5cdFx0Y3JlYXRlUHJldmlld0xheWVyOiBcIkNyZWFyIG51ZXZhIGNhcGEgZGUgdmlzdGEgcHJldmlhXCIsXG5cdFx0bWF4aW11bVByZXZpZXdBbGxvd2VkOiBcIk7Dum1lcm8gbcOheGltbyBkZSBjYXBhcyBkZSB2aXN0YSBwcmV2aWEgcGVybWl0aWRhczogJHttYXhDb3VudH1cIixcblx0XHRwcmV2aWV3RmFpbHVyZTogXCJFc3RhIGNhcGEgZGUgdmlzdGEgcHJldmlhIG5vIGVzdMOhIGRpc3BvbmlibGUuIENvbXBydWViZSBsb3MgcGFyw6FtZXRyb3MgZGUgZW50cmFkYSB5IHZ1ZWx2YSBhIGFjdHVhbGl6YXIgZXN0YSBjYXBhIGRlIHZpc3RhIHByZXZpYS5cIixcblx0XHRoZWFkZXI6IFwiU2VsZWNjaW9uYXIgZWxlbWVudG9cIixcblx0XHRjb250ZW50OiBcIkhheSBjYW1iaW9zIHNpbiBndWFyZGFyIGVuICR7cmZ0VGl0bGV9LiBTaSB2dWVsdmUgYSBlbXBlemFyIGNvbiB1bmEgcGxhbnRpbGxhIG51ZXZhLCBlc29zIGNhbWJpb3Mgc2UgcGVyZGVyw6FuLlwiLFxuXHRcdGRvbnRTYXZlOiBcIk5vIGd1YXJkYXJcIixcblx0XHRcImNvbnRpbnVlXCI6IFwiQ29udGludWFyXCIsXG5cdFx0c3RyZXRjaDogXCJBanVzdGFyIGEgdmVudGFuYVwiLFxuXHRcdHBhbjogXCJEZXNwbGF6YW1pZW50byBwYW5vcsOhbWljb1wiLFxuXHRcdG5ld1RlbXBsYXRlOiBcIkNyZWFyIG51ZXZhIHBsYW50aWxsYVwiLFxuXHRcdG9wZW5UZW1wbGF0ZTogXCJBYnJpciBwbGFudGlsbGFcIixcblx0XHRhZGRGdW5jdGlvbjogXCJBZ3JlZ2FyIGZ1bmNpb25lcyBkZSByw6FzdGVyXCIsXG5cdFx0YWRkQ29uc3RhbnQ6IFwiQWdyZWdhciBjb25zdGFudGVcIixcblx0XHRhZGRSYXN0ZXI6IFwiQWdyZWdhciB2YXJpYWJsZSBkZSByw6FzdGVyXCIsXG5cdFx0bW92ZTogXCJNb3ZlclwiLFxuXHRcdHpvb206IFwiWm9vbVwiLFxuXHRcdHNhdmVBczogXCJHdWFyZGFyIGNvbW9cIixcblx0XHRjbGVhcjogXCJCb3JyYXJcIixcblx0XHRhZGRSYXN0ZXJGdW5jdGlvblRpdGxlOiBcIkFncmVnYXIgZnVuY2lvbmVzIGRlIHLDoXN0ZXJcIixcblx0XHR0ZW1wbGF0ZVByb3BlcnRpZXNUaXRsZTogXCJQcm9waWVkYWRlcyBkZSBwbGFudGlsbGFcIixcblx0XHRicm93c2VSRlQ6IFwiRXhhbWluYXIgcGxhbnRpbGxhcyBkZSBmdW5jacOzbiByw6FzdGVyXCIsXG5cdFx0ZGVmYXVsdFRvb2xEZXNjcmlwdGlvbjogXCJIZXJyYW1pZW50YSBkZSBhbsOhbGlzaXMgJHt0b29sVGl0bGV9LlwiLFxuXHRcdG9wZW5Ub29sVGV4dDogXCJIZXJyYW1pZW50YSBBYnJpclwiLFxuXHRcdHRvb2xEcm9wZG93blRleHQ6IFwiTWVuw7ogZGVzcGxlZ2FibGUgZGUgaGVycmFtaWVudGFzXCIsXG5cdFx0YWRkVG9NYXA6IFwiQ29uZmlybWFyIHkgYWdyZWdhciBhbCBtYXBhXCIsXG5cdFx0Y29uZmlybTogXCJDb25maXJtYXJcIixcblx0XHRzZWxlY3Q6IFwiU2VsZWNjaW9uYXJcIixcblx0XHRzZWxlY3RUYXNrOiBcIlNlbGVjY2lvbmFyIHRhcmVhXCIsXG5cdFx0dW5zdXBwb3J0ZWRMYXllcjogXCJFc3RlIHBhcsOhbWV0cm8gbm8gYWRtaXRlIGxhcyBzaWd1aWVudGVzIGNhcGFzOiAke2xheWVyTmFtZX0uXCIsXG5cdFx0dmlld0RldGFpbHM6IFwiVmVyIHRvZG9zIGxvcyBkZXRhbGxlcyBkZWwgZWxlbWVudG9cIixcblx0XHRyZW5hbWU6IFwiQ2FtYmlhciBub21icmVcIixcblx0XHRkdXBsaWNhdGU6IFwiRHVwbGljYWRhXCIsXG5cdFx0bGF1bmNoOiBcIkFicmlyIHBhcmEgZWplY3V0YXJcIixcblx0XHR0ZW1wbGF0ZUVkaXRvcjogXCJFZGl0b3IgZGUgcGxhbnRpbGxhc1wiLFxuXHRcdGNyZWF0ZUl0ZW06IFwiR3VhcmRhciBwbGFudGlsbGEgZGUgZnVuY2nDs24gcsOhc3RlclwiLFxuXHRcdGFjdGlvbkxhYmVsOiBcIkZpbHRyYXJcIixcblx0XHRmaWx0ZXJQb3BvdmVySGVhZGluZzogXCJGaWx0cmFyIGxhcyBmdW5jaW9uZXNcIixcblx0XHRkZWZhdWx0U2VhcmNoUGxhY2Vob2xkZXI6IFwiQnVzY2FyIHBvciBub21icmVcIixcblx0XHRzZXR0aW5nczogXCJBanVzdGVzXCIsXG5cdFx0c3VtbWFyeTogXCJSZXN1bWVuXCIsXG5cdFx0ZGVmaW5pdGlvblF1ZXJ5OiBcIkNvbnN1bHRhIGRlIGRlZmluaWNpw7NuXCIsXG5cdFx0bWF0Y2hWYXJpYWJsZXM6IFwiVmFyaWFibGVzIGRlIGNvaW5jaWRlbmNpYVwiLFxuXHRcdHVuaW9uRGltZW5zaW9uOiBcIkNvbWJpbmFyIGRpbWVuc2nDs25cIixcblx0XHRuYW1lRWRpdG9yUGxhY2Vob2xkZXI6IFwiSW50cm9kdWNpciB0w610dWxvXCIsXG5cdFx0c3VtbWFyeUVkaXRvclBsYWNlaG9sZGVyOiBcIkludHJvZHV6Y2EgdW5hIGRlc2NyaXBjacOzbiBjb3J0YS5cIixcblx0XHRkZWZpbml0aW9uUXVlcnlQbGFjZWhvbGRlcjogXCJJbnRyb2R1Y2lyLi4uXCIsXG5cdFx0dXBsb2FkOiBcIkNhcmdhclwiLFxuXHRcdGNob29zZUltYWdlOiBcIkhhZ2EgY2xpYyBwYXJhIGVsZWdpciB1biBhcmNoaXZvXCIsXG5cdFx0dXBkYXRlOiBcIkFjdHVhbGl6YXJcIixcblx0XHR0aHVtYm5haWxFcnJvcnM6IHtcblx0XHRcdHdyb25nSW1hZ2VUeXBlOiBcIlRpcG8gZGUgaW1hZ2VuIGluY29ycmVjdG8gc2VsZWNjaW9uYWRvXCIsXG5cdFx0XHRub3RBdmFpbGFibGU6IFwiVmlzdGEgZW4gbWluaWF0dXJhIG5vIGRpc3BvbmlibGVcIixcblx0XHRcdGxvYWRFcnJvcjogXCJObyBzZSBwdWVkZSBjYXJnYXIgbGEgaW1hZ2VuXCIsXG5cdFx0XHRjaG9vc2VGaWxlOiBcIkhhZ2EgY2xpYyBwYXJhIGVsZWdpciBhcmNoaXZvXCJcblx0XHR9XG5cdH1cbn07XG5jb25zdCBjb3B5ID0gXCJDb3BpYXJcIjtcbmNvbnN0IHNhdmUgPSBcIkd1YXJkYXJcIjtcbmNvbnN0IHRpdGxlID0gXCJUw610dWxvXCI7XG5jb25zdCBmb2xkZXIgPSBcIkNhcnBldGFcIjtcbmNvbnN0IHRhZ3MgPSBcIkV0aXF1ZXRhc1wiO1xuY29uc3Qgc2F2aW5nTWVzc2FnZSA9IFwiR3VhcmRhbmRvIGVsZW1lbnRvIGVuXCI7XG5jb25zdCBzaGFyZVdpdGggPSBcIkNvbXBhcnRpciBjb25cIjtcbmNvbnN0IHNoYXJlID0gXCJDb21wYXJ0aXJcIjtcbmNvbnN0IHNldFNoYXJpbmdMZXZlbCA9IFwiRGVmaW5pciBuaXZlbCBkZSB1c28gY29tcGFydGlkb1wiO1xuY29uc3Qgc2V0R3JvdXBTaGFyaW5nID0gXCJEZWZpbmlyIHVzbyBjb21wYXJ0aWRvIGRlIGdydXBvXCI7XG5jb25zdCBvd25lciA9IFwiUHJvcGlldGFyaW9cIjtcbmNvbnN0IG9yZ2FuaXphdGlvbiA9IFwiT3JnYW5pemFjacOzblwiO1xuY29uc3QgZXZlcnlvbmUgPSBcIlRvZG9zIChww7pibGljbylcIjtcbmNvbnN0IGdyb3VwcyA9IFwiR3J1cG9zOlwiO1xuY29uc3QgdHlwZSA9IFwiVGlwb1wiO1xuY29uc3QgbW9zYWljID0gXCJNb3NhaWNvXCI7XG5jb25zdCBpdGVtR3JvdXAgPSBcIkdydXBvIGRlIGVsZW1lbnRvc1wiO1xuY29uc3QgaXRlbSA9IFwiRWxlbWVudG9cIjtcbmNvbnN0IGRlZmluaXRpb25RdWVyeSA9IFwiQ29uc3VsdGEgZGUgZGVmaW5pY2nDs25cIjtcbmNvbnN0IGdyb3VwSXRlbXNCeSA9IFwiQWdydXBhciBlbGVtZW50b3MgcG9yXCI7XG5jb25zdCBncm91cEZpZWxkTmFtZSA9IFwiTm9tYnJlIGRlIGNhbXBvIGRlIGdydXBvXCI7XG5jb25zdCB0YWdGaWVsZE5hbWUgPSBcIk5vbWJyZSBkZSBjYW1wbyBkZSBldGlxdWV0YVwiO1xuY29uc3Qgbm9UaXRsZVRhZ0Vycm9yTXNnID0gXCJEZWJlIHByb3BvcmNpb25hciB1biB0w610dWxvIHBhcmEgc3UgZWxlbWVudG8geSBldGlxdWV0YXMgcGFyYSBxdWUgc3UgbWFwYSBhcGFyZXpjYSBlbiBiw7pzcXVlZGFzLlwiO1xuY29uc3Qgbm9UaXRsZUVycm9yTXNnID0gXCJEZWJlIHByb3BvcmNpb25hciB1biB0w610dWxvIHBhcmEgc3UgZWxlbWVudG8uXCI7XG5jb25zdCBub1RhZ0Vycm9yTXNnID0gXCJEZWJlIHByb3BvcmNpb25hciBhbCBtZW5vcyB1bmEgZXRpcXVldGEgcGFyYSBxdWUgbGFzIHBlcnNvbmFzIHB1ZWRhbiBlbmNvbnRyYXIgc3UgZWxlbWVudG8gZW4gYsO6c3F1ZWRhcy5cIjtcbmNvbnN0IGVycm9yID0gXCJFcnJvclwiO1xuY29uc3Qgd2FybmluZyA9IFwiQWR2ZXJ0ZW5jaWFcIjtcbmNvbnN0IHN1Y2Nlc3MgPSBcIkNvcnJlY3RvXCI7XG5jb25zdCBkZXRhaWxzID0gXCJEZXRhbGxlczpcIjtcbmNvbnN0IHRyeUFnYWluID0gXCJWb2x2ZXIgYSBpbnRlbnRhcmxvXCI7XG5jb25zdCB0b29sTW9kZWxlciA9IHtcblx0c2F2ZTogXCJHdWFyZGFyXCIsXG5cdGVkaXRQcm9wZXJ0aWVzOiBcIkVkaXRhciBwcm9waWVkYWRlc1wiLFxuXHRzYXZlQXM6IFwiR3VhcmRhciBjb21vXCIsXG5cdHNhdmluZ05vdGlmaWNhdGlvbjogXCJHdWFyZGFuZG8gY2FtYmlvcyBlbiBlbCBlbGVtZW50by4uLlwiLFxuXHRzYXZpbmdUaXRsZTogXCJHdWFyZGFuZG9cIixcblx0c2F2ZUZhaWxlZE1lc3NhZ2U6IFwiRXJyb3IgYWwgZ3VhcmRhciBsb3MgY2FtYmlvcy5cIixcblx0c2F2ZVdpdGhFcnJvcnNNZXNzYWdlOiBcIkxvcyBjYW1iaW9zIHNlIGd1YXJkYXJvbiBjb24gbG9zIHNpZ3VpZW50ZXMgZXJyb3Jlcy5cIixcblx0dmlld0l0ZW1NZXNzYWdlOiBcIlZpc3VhbGl6YXIgZWwgZWxlbWVudG8gZ3VhcmRhZG9cIixcblx0aGVyZTogXCJhcXXDrS5cIixcblx0aXRlbUNyZWF0ZWRNZXNzYWdlOiBcIlNlIGhhIGNyZWFkbyB1biBudWV2byBlbGVtZW50by5cIixcblx0Y2xpY2tUb1ZpZXdJdGVtTWVzc2FnZTogXCJIYWdhIGNsaWMgZW4gQWNlcHRhciBwYXJhIHZlciBsYSBww6FnaW5hIGRlIGRldGFsbGVzIGRlbCBlbGVtZW50bzsgaGFnYSBjbGljIGVuIENhbmNlbGFyIHBhcmEgY29udGludWFyLlwiLFxuXHRyZWFkaW5nRmFpbGVkOiBcIkVycm9yIGFsIGNhcmdhciBsYSBwbGFudGlsbGEgZGUgZnVuY2nDs24gcsOhc3RlciBzZWxlY2Npb25hZGEuXCIsXG5cdGZhaWxlZFRvTG9hZFhNTDogXCJFcnJvciBhbCBjYXJnYXIgbGEgcGxhbnRpbGxhIGRlIGZ1bmNpw7NuIHLDoXN0ZXIgc2VsZWNjaW9uYWRhIGVuIGZvcm1hdG8gWE1MLlwiLFxuXHRsZWFybk1vcmU6IFwiTcOhcyBpbmZvcm1hY2nDs25cIixcblx0b3ZlcndyaXRlVGl0bGU6IFwiQ29uZmlybWFyIHNvYnJlc2NyaXR1cmFcIixcblx0b3ZlcndyaXRlTWVzc2FnZTogXCLCv0Rlc2VhIHNvYnJlc2NyaWJpciBlbCBlbGVtZW50byBleGlzdGVudGU/XCIsXG5cdG92ZXJ3cml0ZVN1Y2Nlc3NNZXNzYWdlOiBcIkVsIGVsZW1lbnRvIHNlIGhhIGFjdHVhbGl6YWRvLlwiXG59O1xuY29uc3QgdG9vbEVkaXRvciA9IHtcblx0cnVuOiBcIkVqZWN1dGFyXCIsXG5cdHNhdmU6IFwiR3VhcmRhclwiLFxuXHRkZWxldGVTZWxlY3RlZDogXCJFbGltaW5hciBlbGVtZW50b3Mgc2VsZWNjaW9uYWRvc1wiLFxuXHRhZGRSYXN0ZXI6IFwiQWdyZWdhciByw6FzdGVyXCIsXG5cdGFkZFNjYWxhcjogXCJBZ3JlZ2FyIGVzY2FsYXJcIixcblx0bGF5b3V0OiBcIkRpc2XDsW8gYXV0b23DoXRpY29cIixcblx0ZXJyb3JUaXRsZTogXCJFcnJvclwiLFxuXHRpbnZhbGlkVG9vbE1lc3NhZ2U6IFwiTGEgcGxhbnRpbGxhIGRlIGZ1bmNpw7NuIHLDoXN0ZXIgbm8gZXMgdsOhbGlkYS5cIixcblx0b3V0OiBcIlNhbGlkYVwiLFxuXHR6b29tSW46IFwiQWNlcmNhclwiLFxuXHR6b29tT3V0OiBcIkFsZWphclwiLFxuXHR6b29tVG9GaXQ6IFwiQWp1c3RhciBhIHZlbnRhbmFcIixcblx0cGFuT246IFwiQ2FtYmlhciBhbCBtb2RvIGRlIGRlc3BsYXphbWllbnRvIHBhbm9yw6FtaWNvXCIsXG5cdHBhbk9mZjogXCJEZXNhY3RpdmFyIG1vZG8gZGUgZGVzcGxhemFtaWVudG8gcGFub3LDoW1pY29cIixcblx0ZGVmYXVsdE1vZGVsTmFtZTogXCJNb2RlbG8gZGUgaGVycmFtaWVudGFcIixcblx0ZGVmYXVsdFJhc3Rlck5hbWU6IFwiUsOhc3RlclwiXG59O1xuY29uc3QgdG9vbERldGFpbHNFZGl0b3IgPSB7XG5cdGRlZmF1bHRUb29sTmFtZTogXCJQbGFudGlsbGEgZGUgZnVuY2nDs24gcsOhc3RlclwiLFxuXHRkZWZhdWx0VG9vbERlc2NyaXB0aW9uOiBcIkFncmVndWUgdW4gYnJldmUgcmVzdW1lbiBzb2JyZSBsYSBmdW5jacOzbiByw6FzdGVyLlwiLFxuXHRkZWZhdWx0SGVscFRleHQ6IFwiSGFnYSBjbGljIGVuIGVsIGljb25vIGRlIGF5dWRhIHBhcmEgZWRpdGFyIGVsIHRleHRvIGRlIGF5dWRhXCIsXG5cdGVkaXRIZWxwVGl0bGU6IFwiRWRpdGFyIEF5dWRhXCIsXG5cdHNhdmVMYWJlbDogXCJHdWFyZGFyXCIsXG5cdGNhbmNlbExhYmVsOiBcIkNhbmNlbGFyXCIsXG5cdHRodW1ibmFpbDoge1xuXHRcdHdyb25nSW1hZ2VUeXBlOiBcIlRpcG8gZGUgaW1hZ2VuIGluY29ycmVjdG8gc2VsZWNjaW9uYWRvXCIsXG5cdFx0bm90QXZhaWxhYmxlOiBcIk1pbmlhdHVyYSBubyBkaXNwb25pYmxlXCIsXG5cdFx0bG9hZEVycm9yOiBcIk5vIHNlIHB1ZWRlIGNhcmdhciBsYSBpbWFnZW5cIixcblx0XHRjaG9vc2VGaWxlOiBcIkhhZ2EgY2xpYyBwYXJhIHNlbGVjY2lvbmFyIGVsIGFyY2hpdm9cIlxuXHR9XG59O1xuY29uc3Qgc2F2ZVV0aWxzID0ge1xuXHR0aHVtYm5haWw6IFwiVmlzdGEgZW4gbWluaWF0dXJhXCIsXG5cdHNoYXJpbmc6IFwiQ29tcGFydGlyXCJcbn07XG5jb25zdCBjbG9zZSA9IFwiQ2VycmFyXCI7XG5jb25zdCB1bnNhdmVkV2FybmluZ0V4aXN0aW5nID0gXCLCv0Rlc2VhIGd1YXJkYXIgbG9zIGNhbWJpb3MgZGVsIGVsZW1lbnRvIDxiPiR7aXRlbVRpdGxlfTwvYj4/XCI7XG5jb25zdCB1bnNhdmVkV2FybmluZ05ldyA9IFwiwr9EZXNlYSBndWFyZGFyIGxvcyBjYW1iaW9zP1wiO1xuY29uc3Qgc2F2ZUFzID0gXCJHdWFyZGFyIGNvbW9cIjtcbmNvbnN0IGRvbnRTYXZlID0gXCJObyBndWFyZGFyXCI7XG5jb25zdCB1bnNhdmVkVGl0bGUgPSBcIkNhbWJpb3Mgbm8gZ3VhcmRhZG9zXCI7XG5jb25zdCBpbnZhbGlkUkZUTWVzc2FnZSA9IFwiTGEgcGxhbnRpbGxhIGRlIGZ1bmNpw7NuIHLDoXN0ZXIgY3JlYWRhIG5vIGVzIHbDoWxpZGEuXCI7XG5jb25zdCBlcnJvclRpdGxlID0gXCJFcnJvclwiO1xuY29uc3QgYnJlYWRjcnVtYiA9IFwiRWRpdG9yIGRlIGZ1bmNpb25lcyByw6FzdGVyXCI7XG5jb25zdCBicmVhZGNydW1iRWRpdG9yID0gXCJDb250ZW5pZG8gPiBFZGl0b3IgZGUgZnVuY2lvbmVzIHLDoXN0ZXJcIjtcbmNvbnN0IHZpZXdlck1vZGVUaXRsZSA9IFwiU29sbyBsZWN0dXJhXCI7XG5jb25zdCB2aWV3ZXJNb2RlTWVzc2FnZSA9IFwiRWwgZWxlbWVudG8gZGUgbGEgcGxhbnRpbGxhIGRlIGxhIGZ1bmNpw7NuIHLDoXN0ZXIgZXMgZGUgc29sbyBsZWN0dXJhLiBMb3MgY2FtYmlvcyBubyBzZSBwdWVkZW4gZ3VhcmRhci5cIjtcbmNvbnN0IHVzZXJTdGFydERpcmVjdGlvbiA9IFwiU2VsZWNjaW9uZSB1bmEgZnVuY2nDs24gcGFyYSBlbXBlemFyIGEgY3JlYXIgdW5hIHBsYW50aWxsYSBkZSBmdW5jacOzbiByw6FzdGVyLlwiO1xuY29uc3Qgc2VsZWN0RnVuY3Rpb24gPSBcIkFncmVnYXIgZnVuY2nDs25cIjtcbmNvbnN0IGRlc2VsZWN0RnVuY3Rpb24gPSBcIkVsaW1pbmFyIGZ1bmNpw7NuXCI7XG5jb25zdCBkaWFsb2dUaXRsZSA9IFwiU2lzdGVtYVwiO1xuY29uc3QgY2F0ZWdvcnkgPSBcIkNhdGVnb3LDrWFzXCI7XG5jb25zdCBzZWFyY2ggPSBcIkJ1c2NhciBmdW5jaW9uZXMgcsOhc3RlclwiO1xuY29uc3QgY2F0ZWdvcnlOYW1lcyA9IHtcblx0YW5hbHlzaXM6IFwiQW7DoWxpc2lzXCIsXG5cdGFwcGVhcmFuY2U6IFwiQXBhcmllbmNpYVwiLFxuXHRjbGFzc2lmaWNhdGlvbjogXCJDbGFzaWZpY2FjacOzblwiLFxuXHRjb252ZXJzaW9uOiBcIkNvbnZlcnNpw7NuXCIsXG5cdGNvcnJlY3Rpb246IFwiQ29ycmVjY2nDs25cIixcblx0ZGF0YU1hbmFnZW1lbnQ6IFwiQWRtaW5pc3RyYWNpw7NuIGRlIGRhdG9zXCIsXG5cdGRpc3RhbmNlOiBcIkRpc3RhbmNpYVwiLFxuXHRkaXN0YW5jZUxlZ2FjeTogXCJEaXN0YW5jaWEgKGhlcmVkYWRhKVwiLFxuXHRoeWRyb2xvZ3k6IFwiSGlkcm9sb2fDrWFcIixcblx0bWF0aDogXCJNYXRlbcOhdGljYVwiLFxuXHRtYXRoQ29uZGl0aW9uYWw6IFwiTWF0ZW3DoXRpY2E6IGNvbmRpY2lvbmFsXCIsXG5cdG1hdGhMb2dpY2FsOiBcIk1hdGVtw6F0aWNhOiBsw7NnaWNhXCIsXG5cdG1hdGhUcmlnb25vbWV0cmljOiBcIk1hdGVtw6F0aWNhOiB0cmlnb25vbcOpdHJpY2FcIixcblx0cmVjbGFzczogXCJSZWNsYXNpZmljYXJcIixcblx0c3RhdGlzdGljYWw6IFwiRXN0YWTDrXN0aWNvXCIsXG5cdHN1cmZhY2U6IFwiU3VwZXJmaWNpZVwiXG59O1xuY29uc3QgY29tbW9uU3RyaW5nc19lcyA9IHtcblx0b2s6IG9rLFxuXHRjYW5jZWw6IGNhbmNlbCxcblx0ZW50ZXJVUkw6IGVudGVyVVJMLFxuXHRzZXJ2aWNlVVJMOiBzZXJ2aWNlVVJMLFxuXHRzZWxlY3RSYXN0ZXI6IHNlbGVjdFJhc3Rlcixcblx0ZmFpbGVkVG9Mb2FkTGF5ZXI6IGZhaWxlZFRvTG9hZExheWVyLFxuXHRsb2FkaW5nTGF5ZXI6IGxvYWRpbmdMYXllcixcblx0c2VsZWN0RmVhdHVyZTogc2VsZWN0RmVhdHVyZSxcblx0ZW50ZXJGVVJMOiBlbnRlckZVUkwsXG5cdGFkZFJhc3RlcjogYWRkUmFzdGVyLFxuXHRhZGRTY2FsYXI6IGFkZFNjYWxhcixcblx0cmFzdGVyOiByYXN0ZXIsXG5cdHNjYWxhcjogc2NhbGFyLFxuXHRkZWZhdWx0TW9kZWxOYW1lOiBkZWZhdWx0TW9kZWxOYW1lLFxuXHRnZW5lcmFsOiBnZW5lcmFsLFxuXHRwYXJhbWV0ZXJzOiBwYXJhbWV0ZXJzLFxuXHR2YXJpYWJsZXM6IHZhcmlhYmxlcyxcblx0bmFtZTogbmFtZSxcblx0ZGVzY3JpcHRpb246IGRlc2NyaXB0aW9uLFxuXHRwYXJhbWV0ZXI6IHBhcmFtZXRlcixcblx0aXNQdWJsaWM6IGlzUHVibGljLFxuXHRpc0RhdGFzZXQ6IGlzRGF0YXNldCxcblx0dW5rbm93blBpeGVsVHlwZTogdW5rbm93blBpeGVsVHlwZSxcblx0b3V0cHV0UGl4ZWxUeXBlOiBvdXRwdXRQaXhlbFR5cGUsXG5cdHU4UGl4ZWxUeXBlOiB1OFBpeGVsVHlwZSxcblx0czhQaXhlbFR5cGU6IHM4UGl4ZWxUeXBlLFxuXHR1MTZQaXhlbFR5cGU6IHUxNlBpeGVsVHlwZSxcblx0czE2UGl4ZWxUeXBlOiBzMTZQaXhlbFR5cGUsXG5cdHUzMlBpeGVsVHlwZTogdTMyUGl4ZWxUeXBlLFxuXHRzMzJQaXhlbFR5cGU6IHMzMlBpeGVsVHlwZSxcblx0ZjMyUGl4ZWxUeXBlOiBmMzJQaXhlbFR5cGUsXG5cdGY2NFBpeGVsVHlwZTogZjY0UGl4ZWxUeXBlLFxuXHRwcm9wZXJ0aWVzOiBwcm9wZXJ0aWVzLFxuXHRtdWx0aWRpbWVuc2lvbmFsUnVsZXM6IG11bHRpZGltZW5zaW9uYWxSdWxlcyxcblx0bWF0Y2hWYXJpYWJsZXM6IG1hdGNoVmFyaWFibGVzLFxuXHR1bmlvbkRpbWVuc2lvbnM6IHVuaW9uRGltZW5zaW9ucyxcblx0cmFzdGVyRnVuY3Rpb25FZGl0b3I6IHJhc3RlckZ1bmN0aW9uRWRpdG9yLFxuXHRyZnhMaWNlbnNlSW5mbzogcmZ4TGljZW5zZUluZm8sXG5cdHJhc3RlckZ1bmN0aW9uczogcmFzdGVyRnVuY3Rpb25zLFxuXHRjb3B5OiBjb3B5LFxuXHRzYXZlOiBzYXZlLFxuXHR0aXRsZTogdGl0bGUsXG5cdGZvbGRlcjogZm9sZGVyLFxuXHR0YWdzOiB0YWdzLFxuXHRzYXZpbmdNZXNzYWdlOiBzYXZpbmdNZXNzYWdlLFxuXHRzaGFyZVdpdGg6IHNoYXJlV2l0aCxcblx0c2hhcmU6IHNoYXJlLFxuXHRzZXRTaGFyaW5nTGV2ZWw6IHNldFNoYXJpbmdMZXZlbCxcblx0c2V0R3JvdXBTaGFyaW5nOiBzZXRHcm91cFNoYXJpbmcsXG5cdG93bmVyOiBvd25lcixcblx0b3JnYW5pemF0aW9uOiBvcmdhbml6YXRpb24sXG5cdGV2ZXJ5b25lOiBldmVyeW9uZSxcblx0Z3JvdXBzOiBncm91cHMsXG5cdHR5cGU6IHR5cGUsXG5cdG1vc2FpYzogbW9zYWljLFxuXHRpdGVtR3JvdXA6IGl0ZW1Hcm91cCxcblx0aXRlbTogaXRlbSxcblx0ZGVmaW5pdGlvblF1ZXJ5OiBkZWZpbml0aW9uUXVlcnksXG5cdGdyb3VwSXRlbXNCeTogZ3JvdXBJdGVtc0J5LFxuXHRncm91cEZpZWxkTmFtZTogZ3JvdXBGaWVsZE5hbWUsXG5cdHRhZ0ZpZWxkTmFtZTogdGFnRmllbGROYW1lLFxuXHRub1RpdGxlVGFnRXJyb3JNc2c6IG5vVGl0bGVUYWdFcnJvck1zZyxcblx0bm9UaXRsZUVycm9yTXNnOiBub1RpdGxlRXJyb3JNc2csXG5cdG5vVGFnRXJyb3JNc2c6IG5vVGFnRXJyb3JNc2csXG5cdGVycm9yOiBlcnJvcixcblx0d2FybmluZzogd2FybmluZyxcblx0c3VjY2Vzczogc3VjY2Vzcyxcblx0ZGV0YWlsczogZGV0YWlscyxcblx0dHJ5QWdhaW46IHRyeUFnYWluLFxuXHR0b29sTW9kZWxlcjogdG9vbE1vZGVsZXIsXG5cdHRvb2xFZGl0b3I6IHRvb2xFZGl0b3IsXG5cdHRvb2xEZXRhaWxzRWRpdG9yOiB0b29sRGV0YWlsc0VkaXRvcixcblx0c2F2ZVV0aWxzOiBzYXZlVXRpbHMsXG5cdGNsb3NlOiBjbG9zZSxcblx0dW5zYXZlZFdhcm5pbmdFeGlzdGluZzogdW5zYXZlZFdhcm5pbmdFeGlzdGluZyxcblx0dW5zYXZlZFdhcm5pbmdOZXc6IHVuc2F2ZWRXYXJuaW5nTmV3LFxuXHRzYXZlQXM6IHNhdmVBcyxcblx0ZG9udFNhdmU6IGRvbnRTYXZlLFxuXHR1bnNhdmVkVGl0bGU6IHVuc2F2ZWRUaXRsZSxcblx0aW52YWxpZFJGVE1lc3NhZ2U6IGludmFsaWRSRlRNZXNzYWdlLFxuXHRlcnJvclRpdGxlOiBlcnJvclRpdGxlLFxuXHRicmVhZGNydW1iOiBicmVhZGNydW1iLFxuXHRicmVhZGNydW1iRWRpdG9yOiBicmVhZGNydW1iRWRpdG9yLFxuXHR2aWV3ZXJNb2RlVGl0bGU6IHZpZXdlck1vZGVUaXRsZSxcblx0dmlld2VyTW9kZU1lc3NhZ2U6IHZpZXdlck1vZGVNZXNzYWdlLFxuXHR1c2VyU3RhcnREaXJlY3Rpb246IHVzZXJTdGFydERpcmVjdGlvbixcblx0c2VsZWN0RnVuY3Rpb246IHNlbGVjdEZ1bmN0aW9uLFxuXHRkZXNlbGVjdEZ1bmN0aW9uOiBkZXNlbGVjdEZ1bmN0aW9uLFxuXHRkaWFsb2dUaXRsZTogZGlhbG9nVGl0bGUsXG5cdGNhdGVnb3J5OiBjYXRlZ29yeSxcblx0c2VhcmNoOiBzZWFyY2gsXG5cdGNhdGVnb3J5TmFtZXM6IGNhdGVnb3J5TmFtZXNcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGNvbW1vblN0cmluZ3NfZXM7XG5leHBvcnQgeyBhZGRSYXN0ZXIsIGFkZFNjYWxhciwgYnJlYWRjcnVtYiwgYnJlYWRjcnVtYkVkaXRvciwgY2FuY2VsLCBjYXRlZ29yeSwgY2F0ZWdvcnlOYW1lcywgY2xvc2UsIGNvcHksIGRlZmF1bHRNb2RlbE5hbWUsIGRlZmluaXRpb25RdWVyeSwgZGVzY3JpcHRpb24sIGRlc2VsZWN0RnVuY3Rpb24sIGRldGFpbHMsIGRpYWxvZ1RpdGxlLCBkb250U2F2ZSwgZW50ZXJGVVJMLCBlbnRlclVSTCwgZXJyb3IsIGVycm9yVGl0bGUsIGV2ZXJ5b25lLCBmMzJQaXhlbFR5cGUsIGY2NFBpeGVsVHlwZSwgZmFpbGVkVG9Mb2FkTGF5ZXIsIGZvbGRlciwgZ2VuZXJhbCwgZ3JvdXBGaWVsZE5hbWUsIGdyb3VwSXRlbXNCeSwgZ3JvdXBzLCBpbnZhbGlkUkZUTWVzc2FnZSwgaXNEYXRhc2V0LCBpc1B1YmxpYywgaXRlbSwgaXRlbUdyb3VwLCBsb2FkaW5nTGF5ZXIsIG1hdGNoVmFyaWFibGVzLCBtb3NhaWMsIG11bHRpZGltZW5zaW9uYWxSdWxlcywgbmFtZSwgbm9UYWdFcnJvck1zZywgbm9UaXRsZUVycm9yTXNnLCBub1RpdGxlVGFnRXJyb3JNc2csIG9rLCBvcmdhbml6YXRpb24sIG91dHB1dFBpeGVsVHlwZSwgb3duZXIsIHBhcmFtZXRlciwgcGFyYW1ldGVycywgcHJvcGVydGllcywgcmFzdGVyLCByYXN0ZXJGdW5jdGlvbkVkaXRvciwgcmFzdGVyRnVuY3Rpb25zLCByZnhMaWNlbnNlSW5mbywgczE2UGl4ZWxUeXBlLCBzMzJQaXhlbFR5cGUsIHM4UGl4ZWxUeXBlLCBzYXZlLCBzYXZlQXMsIHNhdmVVdGlscywgc2F2aW5nTWVzc2FnZSwgc2NhbGFyLCBzZWFyY2gsIHNlbGVjdEZlYXR1cmUsIHNlbGVjdEZ1bmN0aW9uLCBzZWxlY3RSYXN0ZXIsIHNlcnZpY2VVUkwsIHNldEdyb3VwU2hhcmluZywgc2V0U2hhcmluZ0xldmVsLCBzaGFyZSwgc2hhcmVXaXRoLCBzdWNjZXNzLCB0YWdGaWVsZE5hbWUsIHRhZ3MsIHRpdGxlLCB0b29sRGV0YWlsc0VkaXRvciwgdG9vbEVkaXRvciwgdG9vbE1vZGVsZXIsIHRyeUFnYWluLCB0eXBlLCB1MTZQaXhlbFR5cGUsIHUzMlBpeGVsVHlwZSwgdThQaXhlbFR5cGUsIHVuaW9uRGltZW5zaW9ucywgdW5rbm93blBpeGVsVHlwZSwgdW5zYXZlZFRpdGxlLCB1bnNhdmVkV2FybmluZ0V4aXN0aW5nLCB1bnNhdmVkV2FybmluZ05ldywgdXNlclN0YXJ0RGlyZWN0aW9uLCB2YXJpYWJsZXMsIHZpZXdlck1vZGVNZXNzYWdlLCB2aWV3ZXJNb2RlVGl0bGUsIHdhcm5pbmcgfTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29tbW9uLXN0cmluZ3MuZXMtYzY1Y2E2NDIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9