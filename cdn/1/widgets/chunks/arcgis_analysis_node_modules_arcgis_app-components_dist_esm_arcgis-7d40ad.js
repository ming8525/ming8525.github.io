"use strict";
(self["webpackChunkexb_client"] = self["webpackChunkexb_client"] || []).push([["vendors-extensions_widgets_arcgis_analysis_node_modules_arcgis_app-components_dist_esm_arcgis-7d40ad"],{

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/arcgis-smart-mapping-raster-slider.entry.js":
/*!*************************************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/arcgis-smart-mapping-raster-slider.entry.js ***!
  \*************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   arcgis_smart_mapping_raster_slider: () => (/* binding */ ArcgisSmartMappingRasterSlider)
/* harmony export */ });
/* harmony import */ var _index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index-e3bf7da7.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/index-e3bf7da7.js");
/* harmony import */ var _raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./raster-unique-value-0976ec7f.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/raster-unique-value-0976ec7f.js");
/* harmony import */ var _loadModules_b4ac1247_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./loadModules-b4ac1247.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/loadModules-b4ac1247.js");
/* harmony import */ var _commonEnums_fcf13661_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./commonEnums-fcf13661.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/commonEnums-fcf13661.js");
/* harmony import */ var _functional_44de8fcf_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./functional-44de8fcf.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/functional-44de8fcf.js");
/* harmony import */ var _languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./languageUtil-ef0e54b2.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/languageUtil-ef0e54b2.js");
/* harmony import */ var _dom_4d367677_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./dom-4d367677.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/dom-4d367677.js");
/* harmony import */ var _locale_050b6db9_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./locale-050b6db9.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/locale-050b6db9.js");
/* harmony import */ var _index_05956cab_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./index-05956cab.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/index-05956cab.js");
/* harmony import */ var _commonFunctions_b0830e9e_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./commonFunctions-b0830e9e.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/commonFunctions-b0830e9e.js");
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v4.0.58
 */











const arcgisSmartMappingRasterSliderCss = ".slider{height:60px;background-color:transparent;position:relative;width:100%;margin:0 auto 0 auto}.esri-slider__content{margin-bottom:40px}.slider-with-thumb{margin-top:10px;width:90%}.slider-bottom-label .esri-slider__max,.slider-bottom-label .esri-slider__min{width:-moz-fit-content;width:fit-content;position:absolute;bottom:8px}.slider-bottom-label .esri-slider__max{right:0;text-align:right}.slider-bottom-label .esri-slider__min{left:0;text-align:left}";

const ArcgisSmartMappingRasterSlider = class {
    constructor(hostRef) {
        (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.r)(this, hostRef);
        this.watchHandles = [];
        this.rendererType = undefined;
        this.type = undefined;
        this.showThumbLabel = false;
        this.editThumbLabel = false;
        this.min = undefined;
        this.max = undefined;
        this.values = undefined;
        this.precision = undefined;
        this.minLabel = undefined;
        this.maxLabel = undefined;
    }
    //--------------------------------------------------------------------------
    //
    //  Lifecycle
    //
    //--------------------------------------------------------------------------
    componentDidLoad() {
        const { config } = _raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_1__.s;
        this.hostElement.shadowRoot.firstElementChild.insertAdjacentHTML("beforebegin", `<link rel="stylesheet" href="${config.jsapiUrl}/themes/light/main.css" />`);
    }
    componentWillUpdate() {
        // fixes issue with trailLength minLabel not rendering appropriately after changing mode
        this.slider.precision = this.precision;
    }
    //--------------------------------------------------------------------------
    //
    // Render Methods
    //
    //--------------------------------------------------------------------------
    render() {
        var _a;
        const { modules } = _raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_1__.s;
        if (!this.slider) {
            const config = {
                min: this.min,
                max: this.max,
                values: this.values,
                precision: this.precision,
                visibleElements: {
                    labels: this.showThumbLabel,
                    rangeLabels: true
                },
                labelInputsEnabled: this.editThumbLabel
            };
            if (this.minLabel && this.maxLabel) {
                config.labelFormatFunction = (value) => {
                    return value === this.min
                        ? this.minLabel
                        : value === this.max
                            ? this.maxLabel
                            : `${value}`;
                };
            }
            (_a = this.watchHandles[0]) === null || _a === void 0 ? void 0 : _a.remove();
            this.watchHandles[0] = undefined;
            this.slider = new modules.Slider(config);
        }
        else {
            let config = {
                min: this.min,
                max: this.max,
                values: this.values,
                precision: this.precision
            };
            if (this.minLabel && this.maxLabel) {
                config.labelFormatFunction = (value) => {
                    return value === this.min
                        ? this.minLabel
                        : value === this.max
                            ? this.maxLabel
                            : `${value}`;
                };
            }
            this.slider.set(config);
        }
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: `slider slider-bottom-label ${this.showThumbLabel ? "slider-with-thumb" : ""}`, ref: (node) => {
                if (node) {
                    this.afterRasterSliderCreate(node);
                }
            } }));
    }
    // -------------------------------------------------------------------
    //
    //  Private methods
    //
    // -------------------------------------------------------------------
    afterRasterSliderCreate(node) {
        if (!this.slider.container) {
            const divNode = document.createElement("div");
            node.append(divNode);
            this.slider.container = divNode;
            this.createRasterSliderChangeEvents();
        }
    }
    createRasterSliderChangeEvents() {
        this.watchHandles.push(this.slider.watch("values", (0,_functional_44de8fcf_js__WEBPACK_IMPORTED_MODULE_4__.d)(() => this.rendererType === "flow"
            ? this.handleFlowSliderValueChange()
            : this.rendererType === "vector-field"
                ? this.handleVectorFieldSliderValueChange()
                : this.handleShadedReliefSliderValueChange(), 300)));
    }
    handleFlowSliderValueChange() {
        const { layer: smLayer } = _raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_1__.s;
        const layer = smLayer;
        const renderer = layer.renderer;
        switch (this.type) {
            case "speed":
                renderer.flowSpeed = Math.max(this.slider.values[0], 0.1);
                break;
            case "density":
                renderer.density = this.slider.values[0];
                break;
            case "trail-length":
                renderer.trailLength = this.slider.values[0] * 0.75;
                break;
        }
        (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_1__.ab)();
    }
    handleVectorFieldSliderValueChange() {
        const { layer: smLayer } = _raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_1__.s;
        const layer = smLayer;
        const renderer = layer.renderer;
        const adjustedSliderValue = this.slider.values[0] / 100;
        renderer.symbolTileSize = Math.floor(1 / adjustedSliderValue);
        (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_1__.ab)();
    }
    handleShadedReliefSliderValueChange() {
        const { layer: smLayer } = _raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_1__.s;
        const layer = smLayer;
        const renderer = layer.renderer;
        renderer[this.type] = this.slider.values[0];
        (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_1__.ab)();
    }
    get hostElement() { return (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.d)(this); }
};
ArcgisSmartMappingRasterSlider.style = arcgisSmartMappingRasterSliderCss;



//# sourceMappingURL=arcgis-smart-mapping-raster-slider.entry.js.map

/***/ }),

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/functional-44de8fcf.js":
/*!****************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/functional-44de8fcf.js ***!
  \****************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   a: () => (/* binding */ arrayToLookupMap),
/* harmony export */   b: () => (/* binding */ unique),
/* harmony export */   c: () => (/* binding */ throttle),
/* harmony export */   d: () => (/* binding */ debounce),
/* harmony export */   e: () => (/* binding */ escapeRegExp),
/* harmony export */   f: () => (/* binding */ arraysAreEquivalent),
/* harmony export */   g: () => (/* binding */ chunk),
/* harmony export */   i: () => (/* binding */ isDefined),
/* harmony export */   m: () => (/* binding */ minDelay),
/* harmony export */   t: () => (/* binding */ timeout),
/* harmony export */   u: () => (/* binding */ uniqueBy)
/* harmony export */ });
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v4.0.58
 */
/**
 * Call a function only after it has not been called for n milliseconds
 * @param fn    - function to call
 * @param delay - delay in milliseconds
 */
const debounce = (fn, delay) => {
    let timeout;
    let status = "idle";
    function flush(...args) {
        status = "flushed";
        return debounced(...args);
    }
    function invoke(...args) {
        status = "invoked";
        return debounced(...args);
    }
    function cancel(...args) {
        status = "cancelled";
        return debounced(...args);
    }
    function getStatus() {
        return status;
    }
    const debounced = (...args) => new Promise((resolve) => {
        switch (status) {
            case "flushed":
                status = "idle";
                if (timeout) {
                    clearTimeout(timeout);
                    resolve(fn(...args));
                }
                else {
                    resolve(null);
                }
                break;
            case "invoked":
                clearTimeout(timeout);
                status = "idle";
                resolve(fn(...args));
                break;
            case "cancelled":
                clearTimeout(timeout);
                status = "idle";
                resolve(null);
                break;
            default:
                if (timeout) {
                    clearTimeout(timeout);
                }
                status = "pending";
                timeout = setTimeout(() => {
                    status = "idle";
                    return resolve(fn(...args));
                }, delay);
                break;
        }
    });
    debounced.flush = flush;
    debounced.invoke = invoke;
    debounced.cancel = cancel;
    debounced.getStatus = getStatus;
    return debounced;
};
/**
 * Call a function only after n milliseconds have elapsed
 * @param fn    - function to call
 * @param delay - delay in milliseconds
 */
const throttle = (fn, delay) => {
    let timeout;
    return (...args) => new Promise((resolve) => {
        if (timeout) {
            return;
        }
        timeout = setTimeout(() => {
            clearTimeout(timeout);
            timeout = undefined;
            resolve(fn(...args));
        }, delay);
    });
};
function escapeRegExp(str) {
    return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"); // $& means the whole matched string
}
function isDefined(value) {
    return value !== undefined && value !== null;
}
/**
 * Set a minimum time for a promise to resolve (useful for preventing flash of loaders)
 */
async function minDelay(promise, minDelay) {
    await Promise.all([promise, timeout(minDelay)]);
    return promise;
}
/**
 * Helper method to inline setTimeout as an await in async functions
 */
function timeout(ms) {
    return new Promise((resolve) => setTimeout(resolve, ms));
}
const arrayToLookupMap = (dataArr, getKeyAndItem) => Object.fromEntries((dataArr || []).map((item) => {
    const { key, data } = getKeyAndItem(item);
    return [key, data];
}));
/**
 * Check whether two arrays have the same number of elements
 * and whether they contain the same elements
 * regardless of order
 */
const arraysAreEquivalent = (arr1, arr2) => arr1.length === arr2.length && arr1.reduce((memo, str) => memo && arr2.indexOf(str) > -1, true);
function uniqueBy(myArr, getItemId) {
    const resultArr = [];
    const lookupMap = {};
    myArr.forEach((item) => {
        const id = getItemId(item);
        if (lookupMap[id] == null) {
            lookupMap[id] = item;
            resultArr.push(item);
        }
    });
    return resultArr;
}
function unique(myArr) {
    const primitives = { boolean: {}, number: {}, string: {} };
    const objs = [];
    return myArr.filter((item) => {
        let type = typeof item;
        if (type in primitives) {
            return primitives[type].hasOwnProperty(item) ? false : (primitives[type][item] = true);
        }
        else {
            return objs.indexOf(item) >= 0 ? false : objs.push(item);
        }
    });
}
const chunk = (arr, size) => [...Array(Math.ceil(arr.length / size))].map((_, i) => arr.slice(size * i, size + size * i));



//# sourceMappingURL=functional-44de8fcf.js.map

/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid2lkZ2V0cy9jaHVua3MvYXJjZ2lzX2FuYWx5c2lzX25vZGVfbW9kdWxlc19hcmNnaXNfYXBwLWNvbXBvbmVudHNfZGlzdF9lc21fYXJjZ2lzLTdkNDBhZC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ2dGO0FBQ2lCO0FBQzlEO0FBQ0E7QUFDc0I7QUFDckI7QUFDVDtBQUNHO0FBQ0Q7QUFDVTs7QUFFdkMsbURBQW1ELFlBQVksNkJBQTZCLGtCQUFrQixXQUFXLHFCQUFxQixzQkFBc0IsbUJBQW1CLG1CQUFtQixnQkFBZ0IsVUFBVSw4RUFBOEUsdUJBQXVCLGtCQUFrQixrQkFBa0IsV0FBVyx1Q0FBdUMsUUFBUSxpQkFBaUIsdUNBQXVDLE9BQU8sZ0JBQWdCOztBQUV0ZjtBQUNBO0FBQ0EsUUFBUSxxREFBZ0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFNBQVMsRUFBRSwrREFBaUI7QUFDNUMsd0hBQXdILGdCQUFnQjtBQUN4STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsVUFBVSxFQUFFLCtEQUFpQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxNQUFNO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLE1BQU07QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IscURBQUMsVUFBVSxxQ0FBcUMsK0NBQStDO0FBQy9HO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsMERBQVE7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGlCQUFpQixFQUFFLCtEQUFpQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsb0VBQWM7QUFDdEI7QUFDQTtBQUNBLGdCQUFnQixpQkFBaUIsRUFBRSwrREFBaUI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLG9FQUFjO0FBQ3RCO0FBQ0E7QUFDQSxnQkFBZ0IsaUJBQWlCLEVBQUUsK0RBQWlCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBLFFBQVEsb0VBQWM7QUFDdEI7QUFDQSx3QkFBd0IsT0FBTyxxREFBVTtBQUN6QztBQUNBOztBQUVnRjs7QUFFaEY7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ2hLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQSxpQ0FBaUMsc0JBQXNCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksWUFBWTtBQUN4QjtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLFdBQVcsWUFBWTtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFaU07O0FBRWpNIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZXhiLWNsaWVudC8uL2V4dGVuc2lvbnMvd2lkZ2V0cy9hcmNnaXMvYW5hbHlzaXMvbm9kZV9tb2R1bGVzL0BhcmNnaXMvYXBwLWNvbXBvbmVudHMvZGlzdC9lc20vYXJjZ2lzLXNtYXJ0LW1hcHBpbmctcmFzdGVyLXNsaWRlci5lbnRyeS5qcyIsIndlYnBhY2s6Ly9leGItY2xpZW50Ly4vZXh0ZW5zaW9ucy93aWRnZXRzL2FyY2dpcy9hbmFseXNpcy9ub2RlX21vZHVsZXMvQGFyY2dpcy9hcHAtY29tcG9uZW50cy9kaXN0L2VzbS9mdW5jdGlvbmFsLTQ0ZGU4ZmNmLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogQWxsIG1hdGVyaWFsIGNvcHlyaWdodCBFU1JJLCBBbGwgUmlnaHRzIFJlc2VydmVkLCB1bmxlc3Mgb3RoZXJ3aXNlIHNwZWNpZmllZC5cbiAqIHY0LjAuNThcbiAqL1xuaW1wb3J0IHsgciBhcyByZWdpc3Rlckluc3RhbmNlLCBoLCBkIGFzIGdldEVsZW1lbnQgfSBmcm9tICcuL2luZGV4LWUzYmY3ZGE3LmpzJztcbmltcG9ydCB7IGFiIGFzIHVwZGF0ZVJlbmRlcmVyLCBzIGFzIHNtYXJ0TWFwcGluZ1N0YXRlIH0gZnJvbSAnLi9yYXN0ZXItdW5pcXVlLXZhbHVlLTA5NzZlYzdmLmpzJztcbmltcG9ydCAnLi9sb2FkTW9kdWxlcy1iNGFjMTI0Ny5qcyc7XG5pbXBvcnQgJy4vY29tbW9uRW51bXMtZmNmMTM2NjEuanMnO1xuaW1wb3J0IHsgZCBhcyBkZWJvdW5jZSB9IGZyb20gJy4vZnVuY3Rpb25hbC00NGRlOGZjZi5qcyc7XG5pbXBvcnQgJy4vbGFuZ3VhZ2VVdGlsLWVmMGU1NGIyLmpzJztcbmltcG9ydCAnLi9kb20tNGQzNjc2NzcuanMnO1xuaW1wb3J0ICcuL2xvY2FsZS0wNTBiNmRiOS5qcyc7XG5pbXBvcnQgJy4vaW5kZXgtMDU5NTZjYWIuanMnO1xuaW1wb3J0ICcuL2NvbW1vbkZ1bmN0aW9ucy1iMDgzMGU5ZS5qcyc7XG5cbmNvbnN0IGFyY2dpc1NtYXJ0TWFwcGluZ1Jhc3RlclNsaWRlckNzcyA9IFwiLnNsaWRlcntoZWlnaHQ6NjBweDtiYWNrZ3JvdW5kLWNvbG9yOnRyYW5zcGFyZW50O3Bvc2l0aW9uOnJlbGF0aXZlO3dpZHRoOjEwMCU7bWFyZ2luOjAgYXV0byAwIGF1dG99LmVzcmktc2xpZGVyX19jb250ZW50e21hcmdpbi1ib3R0b206NDBweH0uc2xpZGVyLXdpdGgtdGh1bWJ7bWFyZ2luLXRvcDoxMHB4O3dpZHRoOjkwJX0uc2xpZGVyLWJvdHRvbS1sYWJlbCAuZXNyaS1zbGlkZXJfX21heCwuc2xpZGVyLWJvdHRvbS1sYWJlbCAuZXNyaS1zbGlkZXJfX21pbnt3aWR0aDotbW96LWZpdC1jb250ZW50O3dpZHRoOmZpdC1jb250ZW50O3Bvc2l0aW9uOmFic29sdXRlO2JvdHRvbTo4cHh9LnNsaWRlci1ib3R0b20tbGFiZWwgLmVzcmktc2xpZGVyX19tYXh7cmlnaHQ6MDt0ZXh0LWFsaWduOnJpZ2h0fS5zbGlkZXItYm90dG9tLWxhYmVsIC5lc3JpLXNsaWRlcl9fbWlue2xlZnQ6MDt0ZXh0LWFsaWduOmxlZnR9XCI7XG5cbmNvbnN0IEFyY2dpc1NtYXJ0TWFwcGluZ1Jhc3RlclNsaWRlciA9IGNsYXNzIHtcbiAgICBjb25zdHJ1Y3Rvcihob3N0UmVmKSB7XG4gICAgICAgIHJlZ2lzdGVySW5zdGFuY2UodGhpcywgaG9zdFJlZik7XG4gICAgICAgIHRoaXMud2F0Y2hIYW5kbGVzID0gW107XG4gICAgICAgIHRoaXMucmVuZGVyZXJUeXBlID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLnR5cGUgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuc2hvd1RodW1iTGFiZWwgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5lZGl0VGh1bWJMYWJlbCA9IGZhbHNlO1xuICAgICAgICB0aGlzLm1pbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5tYXggPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMudmFsdWVzID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLnByZWNpc2lvbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5taW5MYWJlbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5tYXhMYWJlbCA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vXG4gICAgLy8gIExpZmVjeWNsZVxuICAgIC8vXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIGNvbXBvbmVudERpZExvYWQoKSB7XG4gICAgICAgIGNvbnN0IHsgY29uZmlnIH0gPSBzbWFydE1hcHBpbmdTdGF0ZTtcbiAgICAgICAgdGhpcy5ob3N0RWxlbWVudC5zaGFkb3dSb290LmZpcnN0RWxlbWVudENoaWxkLmluc2VydEFkamFjZW50SFRNTChcImJlZm9yZWJlZ2luXCIsIGA8bGluayByZWw9XCJzdHlsZXNoZWV0XCIgaHJlZj1cIiR7Y29uZmlnLmpzYXBpVXJsfS90aGVtZXMvbGlnaHQvbWFpbi5jc3NcIiAvPmApO1xuICAgIH1cbiAgICBjb21wb25lbnRXaWxsVXBkYXRlKCkge1xuICAgICAgICAvLyBmaXhlcyBpc3N1ZSB3aXRoIHRyYWlsTGVuZ3RoIG1pbkxhYmVsIG5vdCByZW5kZXJpbmcgYXBwcm9wcmlhdGVseSBhZnRlciBjaGFuZ2luZyBtb2RlXG4gICAgICAgIHRoaXMuc2xpZGVyLnByZWNpc2lvbiA9IHRoaXMucHJlY2lzaW9uO1xuICAgIH1cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy9cbiAgICAvLyBSZW5kZXIgTWV0aG9kc1xuICAgIC8vXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCB7IG1vZHVsZXMgfSA9IHNtYXJ0TWFwcGluZ1N0YXRlO1xuICAgICAgICBpZiAoIXRoaXMuc2xpZGVyKSB7XG4gICAgICAgICAgICBjb25zdCBjb25maWcgPSB7XG4gICAgICAgICAgICAgICAgbWluOiB0aGlzLm1pbixcbiAgICAgICAgICAgICAgICBtYXg6IHRoaXMubWF4LFxuICAgICAgICAgICAgICAgIHZhbHVlczogdGhpcy52YWx1ZXMsXG4gICAgICAgICAgICAgICAgcHJlY2lzaW9uOiB0aGlzLnByZWNpc2lvbixcbiAgICAgICAgICAgICAgICB2aXNpYmxlRWxlbWVudHM6IHtcbiAgICAgICAgICAgICAgICAgICAgbGFiZWxzOiB0aGlzLnNob3dUaHVtYkxhYmVsLFxuICAgICAgICAgICAgICAgICAgICByYW5nZUxhYmVsczogdHJ1ZVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgbGFiZWxJbnB1dHNFbmFibGVkOiB0aGlzLmVkaXRUaHVtYkxhYmVsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKHRoaXMubWluTGFiZWwgJiYgdGhpcy5tYXhMYWJlbCkge1xuICAgICAgICAgICAgICAgIGNvbmZpZy5sYWJlbEZvcm1hdEZ1bmN0aW9uID0gKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZSA9PT0gdGhpcy5taW5cbiAgICAgICAgICAgICAgICAgICAgICAgID8gdGhpcy5taW5MYWJlbFxuICAgICAgICAgICAgICAgICAgICAgICAgOiB2YWx1ZSA9PT0gdGhpcy5tYXhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHRoaXMubWF4TGFiZWxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGAke3ZhbHVlfWA7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIChfYSA9IHRoaXMud2F0Y2hIYW5kbGVzWzBdKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVtb3ZlKCk7XG4gICAgICAgICAgICB0aGlzLndhdGNoSGFuZGxlc1swXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHRoaXMuc2xpZGVyID0gbmV3IG1vZHVsZXMuU2xpZGVyKGNvbmZpZyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgY29uZmlnID0ge1xuICAgICAgICAgICAgICAgIG1pbjogdGhpcy5taW4sXG4gICAgICAgICAgICAgICAgbWF4OiB0aGlzLm1heCxcbiAgICAgICAgICAgICAgICB2YWx1ZXM6IHRoaXMudmFsdWVzLFxuICAgICAgICAgICAgICAgIHByZWNpc2lvbjogdGhpcy5wcmVjaXNpb25cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAodGhpcy5taW5MYWJlbCAmJiB0aGlzLm1heExhYmVsKSB7XG4gICAgICAgICAgICAgICAgY29uZmlnLmxhYmVsRm9ybWF0RnVuY3Rpb24gPSAodmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlID09PSB0aGlzLm1pblxuICAgICAgICAgICAgICAgICAgICAgICAgPyB0aGlzLm1pbkxhYmVsXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHZhbHVlID09PSB0aGlzLm1heFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gdGhpcy5tYXhMYWJlbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogYCR7dmFsdWV9YDtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zbGlkZXIuc2V0KGNvbmZpZyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChoKFwiZGl2XCIsIHsgY2xhc3M6IGBzbGlkZXIgc2xpZGVyLWJvdHRvbS1sYWJlbCAke3RoaXMuc2hvd1RodW1iTGFiZWwgPyBcInNsaWRlci13aXRoLXRodW1iXCIgOiBcIlwifWAsIHJlZjogKG5vZGUpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFmdGVyUmFzdGVyU2xpZGVyQ3JlYXRlKG5vZGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gfSkpO1xuICAgIH1cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy9cbiAgICAvLyAgUHJpdmF0ZSBtZXRob2RzXG4gICAgLy9cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgYWZ0ZXJSYXN0ZXJTbGlkZXJDcmVhdGUobm9kZSkge1xuICAgICAgICBpZiAoIXRoaXMuc2xpZGVyLmNvbnRhaW5lcikge1xuICAgICAgICAgICAgY29uc3QgZGl2Tm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgICAgICBub2RlLmFwcGVuZChkaXZOb2RlKTtcbiAgICAgICAgICAgIHRoaXMuc2xpZGVyLmNvbnRhaW5lciA9IGRpdk5vZGU7XG4gICAgICAgICAgICB0aGlzLmNyZWF0ZVJhc3RlclNsaWRlckNoYW5nZUV2ZW50cygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNyZWF0ZVJhc3RlclNsaWRlckNoYW5nZUV2ZW50cygpIHtcbiAgICAgICAgdGhpcy53YXRjaEhhbmRsZXMucHVzaCh0aGlzLnNsaWRlci53YXRjaChcInZhbHVlc1wiLCBkZWJvdW5jZSgoKSA9PiB0aGlzLnJlbmRlcmVyVHlwZSA9PT0gXCJmbG93XCJcbiAgICAgICAgICAgID8gdGhpcy5oYW5kbGVGbG93U2xpZGVyVmFsdWVDaGFuZ2UoKVxuICAgICAgICAgICAgOiB0aGlzLnJlbmRlcmVyVHlwZSA9PT0gXCJ2ZWN0b3ItZmllbGRcIlxuICAgICAgICAgICAgICAgID8gdGhpcy5oYW5kbGVWZWN0b3JGaWVsZFNsaWRlclZhbHVlQ2hhbmdlKClcbiAgICAgICAgICAgICAgICA6IHRoaXMuaGFuZGxlU2hhZGVkUmVsaWVmU2xpZGVyVmFsdWVDaGFuZ2UoKSwgMzAwKSkpO1xuICAgIH1cbiAgICBoYW5kbGVGbG93U2xpZGVyVmFsdWVDaGFuZ2UoKSB7XG4gICAgICAgIGNvbnN0IHsgbGF5ZXI6IHNtTGF5ZXIgfSA9IHNtYXJ0TWFwcGluZ1N0YXRlO1xuICAgICAgICBjb25zdCBsYXllciA9IHNtTGF5ZXI7XG4gICAgICAgIGNvbnN0IHJlbmRlcmVyID0gbGF5ZXIucmVuZGVyZXI7XG4gICAgICAgIHN3aXRjaCAodGhpcy50eXBlKSB7XG4gICAgICAgICAgICBjYXNlIFwic3BlZWRcIjpcbiAgICAgICAgICAgICAgICByZW5kZXJlci5mbG93U3BlZWQgPSBNYXRoLm1heCh0aGlzLnNsaWRlci52YWx1ZXNbMF0sIDAuMSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiZGVuc2l0eVwiOlxuICAgICAgICAgICAgICAgIHJlbmRlcmVyLmRlbnNpdHkgPSB0aGlzLnNsaWRlci52YWx1ZXNbMF07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwidHJhaWwtbGVuZ3RoXCI6XG4gICAgICAgICAgICAgICAgcmVuZGVyZXIudHJhaWxMZW5ndGggPSB0aGlzLnNsaWRlci52YWx1ZXNbMF0gKiAwLjc1O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHVwZGF0ZVJlbmRlcmVyKCk7XG4gICAgfVxuICAgIGhhbmRsZVZlY3RvckZpZWxkU2xpZGVyVmFsdWVDaGFuZ2UoKSB7XG4gICAgICAgIGNvbnN0IHsgbGF5ZXI6IHNtTGF5ZXIgfSA9IHNtYXJ0TWFwcGluZ1N0YXRlO1xuICAgICAgICBjb25zdCBsYXllciA9IHNtTGF5ZXI7XG4gICAgICAgIGNvbnN0IHJlbmRlcmVyID0gbGF5ZXIucmVuZGVyZXI7XG4gICAgICAgIGNvbnN0IGFkanVzdGVkU2xpZGVyVmFsdWUgPSB0aGlzLnNsaWRlci52YWx1ZXNbMF0gLyAxMDA7XG4gICAgICAgIHJlbmRlcmVyLnN5bWJvbFRpbGVTaXplID0gTWF0aC5mbG9vcigxIC8gYWRqdXN0ZWRTbGlkZXJWYWx1ZSk7XG4gICAgICAgIHVwZGF0ZVJlbmRlcmVyKCk7XG4gICAgfVxuICAgIGhhbmRsZVNoYWRlZFJlbGllZlNsaWRlclZhbHVlQ2hhbmdlKCkge1xuICAgICAgICBjb25zdCB7IGxheWVyOiBzbUxheWVyIH0gPSBzbWFydE1hcHBpbmdTdGF0ZTtcbiAgICAgICAgY29uc3QgbGF5ZXIgPSBzbUxheWVyO1xuICAgICAgICBjb25zdCByZW5kZXJlciA9IGxheWVyLnJlbmRlcmVyO1xuICAgICAgICByZW5kZXJlclt0aGlzLnR5cGVdID0gdGhpcy5zbGlkZXIudmFsdWVzWzBdO1xuICAgICAgICB1cGRhdGVSZW5kZXJlcigpO1xuICAgIH1cbiAgICBnZXQgaG9zdEVsZW1lbnQoKSB7IHJldHVybiBnZXRFbGVtZW50KHRoaXMpOyB9XG59O1xuQXJjZ2lzU21hcnRNYXBwaW5nUmFzdGVyU2xpZGVyLnN0eWxlID0gYXJjZ2lzU21hcnRNYXBwaW5nUmFzdGVyU2xpZGVyQ3NzO1xuXG5leHBvcnQgeyBBcmNnaXNTbWFydE1hcHBpbmdSYXN0ZXJTbGlkZXIgYXMgYXJjZ2lzX3NtYXJ0X21hcHBpbmdfcmFzdGVyX3NsaWRlciB9O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1hcmNnaXMtc21hcnQtbWFwcGluZy1yYXN0ZXItc2xpZGVyLmVudHJ5LmpzLm1hcCIsIi8qIVxuICogQWxsIG1hdGVyaWFsIGNvcHlyaWdodCBFU1JJLCBBbGwgUmlnaHRzIFJlc2VydmVkLCB1bmxlc3Mgb3RoZXJ3aXNlIHNwZWNpZmllZC5cbiAqIHY0LjAuNThcbiAqL1xuLyoqXG4gKiBDYWxsIGEgZnVuY3Rpb24gb25seSBhZnRlciBpdCBoYXMgbm90IGJlZW4gY2FsbGVkIGZvciBuIG1pbGxpc2Vjb25kc1xuICogQHBhcmFtIGZuICAgIC0gZnVuY3Rpb24gdG8gY2FsbFxuICogQHBhcmFtIGRlbGF5IC0gZGVsYXkgaW4gbWlsbGlzZWNvbmRzXG4gKi9cbmNvbnN0IGRlYm91bmNlID0gKGZuLCBkZWxheSkgPT4ge1xuICAgIGxldCB0aW1lb3V0O1xuICAgIGxldCBzdGF0dXMgPSBcImlkbGVcIjtcbiAgICBmdW5jdGlvbiBmbHVzaCguLi5hcmdzKSB7XG4gICAgICAgIHN0YXR1cyA9IFwiZmx1c2hlZFwiO1xuICAgICAgICByZXR1cm4gZGVib3VuY2VkKC4uLmFyZ3MpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpbnZva2UoLi4uYXJncykge1xuICAgICAgICBzdGF0dXMgPSBcImludm9rZWRcIjtcbiAgICAgICAgcmV0dXJuIGRlYm91bmNlZCguLi5hcmdzKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2FuY2VsKC4uLmFyZ3MpIHtcbiAgICAgICAgc3RhdHVzID0gXCJjYW5jZWxsZWRcIjtcbiAgICAgICAgcmV0dXJuIGRlYm91bmNlZCguLi5hcmdzKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0U3RhdHVzKCkge1xuICAgICAgICByZXR1cm4gc3RhdHVzO1xuICAgIH1cbiAgICBjb25zdCBkZWJvdW5jZWQgPSAoLi4uYXJncykgPT4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgc3dpdGNoIChzdGF0dXMpIHtcbiAgICAgICAgICAgIGNhc2UgXCJmbHVzaGVkXCI6XG4gICAgICAgICAgICAgICAgc3RhdHVzID0gXCJpZGxlXCI7XG4gICAgICAgICAgICAgICAgaWYgKHRpbWVvdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGZuKC4uLmFyZ3MpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUobnVsbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImludm9rZWRcIjpcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgICAgICAgICAgc3RhdHVzID0gXCJpZGxlXCI7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShmbiguLi5hcmdzKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiY2FuY2VsbGVkXCI6XG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICAgICAgICAgIHN0YXR1cyA9IFwiaWRsZVwiO1xuICAgICAgICAgICAgICAgIHJlc29sdmUobnVsbCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGlmICh0aW1lb3V0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3RhdHVzID0gXCJwZW5kaW5nXCI7XG4gICAgICAgICAgICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMgPSBcImlkbGVcIjtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUoZm4oLi4uYXJncykpO1xuICAgICAgICAgICAgICAgIH0sIGRlbGF5KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGRlYm91bmNlZC5mbHVzaCA9IGZsdXNoO1xuICAgIGRlYm91bmNlZC5pbnZva2UgPSBpbnZva2U7XG4gICAgZGVib3VuY2VkLmNhbmNlbCA9IGNhbmNlbDtcbiAgICBkZWJvdW5jZWQuZ2V0U3RhdHVzID0gZ2V0U3RhdHVzO1xuICAgIHJldHVybiBkZWJvdW5jZWQ7XG59O1xuLyoqXG4gKiBDYWxsIGEgZnVuY3Rpb24gb25seSBhZnRlciBuIG1pbGxpc2Vjb25kcyBoYXZlIGVsYXBzZWRcbiAqIEBwYXJhbSBmbiAgICAtIGZ1bmN0aW9uIHRvIGNhbGxcbiAqIEBwYXJhbSBkZWxheSAtIGRlbGF5IGluIG1pbGxpc2Vjb25kc1xuICovXG5jb25zdCB0aHJvdHRsZSA9IChmbiwgZGVsYXkpID0+IHtcbiAgICBsZXQgdGltZW91dDtcbiAgICByZXR1cm4gKC4uLmFyZ3MpID0+IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgIGlmICh0aW1lb3V0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICAgICAgdGltZW91dCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHJlc29sdmUoZm4oLi4uYXJncykpO1xuICAgICAgICB9LCBkZWxheSk7XG4gICAgfSk7XG59O1xuZnVuY3Rpb24gZXNjYXBlUmVnRXhwKHN0cikge1xuICAgIHJldHVybiBzdHIucmVwbGFjZSgvWy4qKz9eJHt9KCl8W1xcXVxcXFxdL2csIFwiXFxcXCQmXCIpOyAvLyAkJiBtZWFucyB0aGUgd2hvbGUgbWF0Y2hlZCBzdHJpbmdcbn1cbmZ1bmN0aW9uIGlzRGVmaW5lZCh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsO1xufVxuLyoqXG4gKiBTZXQgYSBtaW5pbXVtIHRpbWUgZm9yIGEgcHJvbWlzZSB0byByZXNvbHZlICh1c2VmdWwgZm9yIHByZXZlbnRpbmcgZmxhc2ggb2YgbG9hZGVycylcbiAqL1xuYXN5bmMgZnVuY3Rpb24gbWluRGVsYXkocHJvbWlzZSwgbWluRGVsYXkpIHtcbiAgICBhd2FpdCBQcm9taXNlLmFsbChbcHJvbWlzZSwgdGltZW91dChtaW5EZWxheSldKTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbn1cbi8qKlxuICogSGVscGVyIG1ldGhvZCB0byBpbmxpbmUgc2V0VGltZW91dCBhcyBhbiBhd2FpdCBpbiBhc3luYyBmdW5jdGlvbnNcbiAqL1xuZnVuY3Rpb24gdGltZW91dChtcykge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlLCBtcykpO1xufVxuY29uc3QgYXJyYXlUb0xvb2t1cE1hcCA9IChkYXRhQXJyLCBnZXRLZXlBbmRJdGVtKSA9PiBPYmplY3QuZnJvbUVudHJpZXMoKGRhdGFBcnIgfHwgW10pLm1hcCgoaXRlbSkgPT4ge1xuICAgIGNvbnN0IHsga2V5LCBkYXRhIH0gPSBnZXRLZXlBbmRJdGVtKGl0ZW0pO1xuICAgIHJldHVybiBba2V5LCBkYXRhXTtcbn0pKTtcbi8qKlxuICogQ2hlY2sgd2hldGhlciB0d28gYXJyYXlzIGhhdmUgdGhlIHNhbWUgbnVtYmVyIG9mIGVsZW1lbnRzXG4gKiBhbmQgd2hldGhlciB0aGV5IGNvbnRhaW4gdGhlIHNhbWUgZWxlbWVudHNcbiAqIHJlZ2FyZGxlc3Mgb2Ygb3JkZXJcbiAqL1xuY29uc3QgYXJyYXlzQXJlRXF1aXZhbGVudCA9IChhcnIxLCBhcnIyKSA9PiBhcnIxLmxlbmd0aCA9PT0gYXJyMi5sZW5ndGggJiYgYXJyMS5yZWR1Y2UoKG1lbW8sIHN0cikgPT4gbWVtbyAmJiBhcnIyLmluZGV4T2Yoc3RyKSA+IC0xLCB0cnVlKTtcbmZ1bmN0aW9uIHVuaXF1ZUJ5KG15QXJyLCBnZXRJdGVtSWQpIHtcbiAgICBjb25zdCByZXN1bHRBcnIgPSBbXTtcbiAgICBjb25zdCBsb29rdXBNYXAgPSB7fTtcbiAgICBteUFyci5mb3JFYWNoKChpdGVtKSA9PiB7XG4gICAgICAgIGNvbnN0IGlkID0gZ2V0SXRlbUlkKGl0ZW0pO1xuICAgICAgICBpZiAobG9va3VwTWFwW2lkXSA9PSBudWxsKSB7XG4gICAgICAgICAgICBsb29rdXBNYXBbaWRdID0gaXRlbTtcbiAgICAgICAgICAgIHJlc3VsdEFyci5wdXNoKGl0ZW0pO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdEFycjtcbn1cbmZ1bmN0aW9uIHVuaXF1ZShteUFycikge1xuICAgIGNvbnN0IHByaW1pdGl2ZXMgPSB7IGJvb2xlYW46IHt9LCBudW1iZXI6IHt9LCBzdHJpbmc6IHt9IH07XG4gICAgY29uc3Qgb2JqcyA9IFtdO1xuICAgIHJldHVybiBteUFyci5maWx0ZXIoKGl0ZW0pID0+IHtcbiAgICAgICAgbGV0IHR5cGUgPSB0eXBlb2YgaXRlbTtcbiAgICAgICAgaWYgKHR5cGUgaW4gcHJpbWl0aXZlcykge1xuICAgICAgICAgICAgcmV0dXJuIHByaW1pdGl2ZXNbdHlwZV0uaGFzT3duUHJvcGVydHkoaXRlbSkgPyBmYWxzZSA6IChwcmltaXRpdmVzW3R5cGVdW2l0ZW1dID0gdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gb2Jqcy5pbmRleE9mKGl0ZW0pID49IDAgPyBmYWxzZSA6IG9ianMucHVzaChpdGVtKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuY29uc3QgY2h1bmsgPSAoYXJyLCBzaXplKSA9PiBbLi4uQXJyYXkoTWF0aC5jZWlsKGFyci5sZW5ndGggLyBzaXplKSldLm1hcCgoXywgaSkgPT4gYXJyLnNsaWNlKHNpemUgKiBpLCBzaXplICsgc2l6ZSAqIGkpKTtcblxuZXhwb3J0IHsgYXJyYXlUb0xvb2t1cE1hcCBhcyBhLCB1bmlxdWUgYXMgYiwgdGhyb3R0bGUgYXMgYywgZGVib3VuY2UgYXMgZCwgZXNjYXBlUmVnRXhwIGFzIGUsIGFycmF5c0FyZUVxdWl2YWxlbnQgYXMgZiwgY2h1bmsgYXMgZywgaXNEZWZpbmVkIGFzIGksIG1pbkRlbGF5IGFzIG0sIHRpbWVvdXQgYXMgdCwgdW5pcXVlQnkgYXMgdSB9O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1mdW5jdGlvbmFsLTQ0ZGU4ZmNmLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==