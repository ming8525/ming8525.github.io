"use strict";
(self["webpackChunkexb_client"] = self["webpackChunkexb_client"] || []).push([["vendors-extensions_widgets_arcgis_analysis_node_modules_arcgis_arcgis-raster-function-editor_-652b0b"],{

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/arcgis-raster-function-editor/dist/esm/common-strings.fr-f066cbe6.js":
/*!**************************************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/arcgis-raster-function-editor/dist/esm/common-strings.fr-f066cbe6.js ***!
  \**************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   addRaster: () => (/* binding */ addRaster),
/* harmony export */   addScalar: () => (/* binding */ addScalar),
/* harmony export */   breadcrumb: () => (/* binding */ breadcrumb),
/* harmony export */   breadcrumbEditor: () => (/* binding */ breadcrumbEditor),
/* harmony export */   cancel: () => (/* binding */ cancel),
/* harmony export */   category: () => (/* binding */ category),
/* harmony export */   categoryNames: () => (/* binding */ categoryNames),
/* harmony export */   close: () => (/* binding */ close),
/* harmony export */   copy: () => (/* binding */ copy),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   defaultModelName: () => (/* binding */ defaultModelName),
/* harmony export */   definitionQuery: () => (/* binding */ definitionQuery),
/* harmony export */   description: () => (/* binding */ description),
/* harmony export */   deselectFunction: () => (/* binding */ deselectFunction),
/* harmony export */   details: () => (/* binding */ details),
/* harmony export */   dialogTitle: () => (/* binding */ dialogTitle),
/* harmony export */   dontSave: () => (/* binding */ dontSave),
/* harmony export */   enterFURL: () => (/* binding */ enterFURL),
/* harmony export */   enterURL: () => (/* binding */ enterURL),
/* harmony export */   error: () => (/* binding */ error),
/* harmony export */   errorTitle: () => (/* binding */ errorTitle),
/* harmony export */   everyone: () => (/* binding */ everyone),
/* harmony export */   f32PixelType: () => (/* binding */ f32PixelType),
/* harmony export */   f64PixelType: () => (/* binding */ f64PixelType),
/* harmony export */   failedToLoadLayer: () => (/* binding */ failedToLoadLayer),
/* harmony export */   folder: () => (/* binding */ folder),
/* harmony export */   general: () => (/* binding */ general),
/* harmony export */   groupFieldName: () => (/* binding */ groupFieldName),
/* harmony export */   groupItemsBy: () => (/* binding */ groupItemsBy),
/* harmony export */   groups: () => (/* binding */ groups),
/* harmony export */   invalidRFTMessage: () => (/* binding */ invalidRFTMessage),
/* harmony export */   isDataset: () => (/* binding */ isDataset),
/* harmony export */   isPublic: () => (/* binding */ isPublic),
/* harmony export */   item: () => (/* binding */ item),
/* harmony export */   itemGroup: () => (/* binding */ itemGroup),
/* harmony export */   loadingLayer: () => (/* binding */ loadingLayer),
/* harmony export */   matchVariables: () => (/* binding */ matchVariables),
/* harmony export */   mosaic: () => (/* binding */ mosaic),
/* harmony export */   multidimensionalRules: () => (/* binding */ multidimensionalRules),
/* harmony export */   name: () => (/* binding */ name),
/* harmony export */   noTagErrorMsg: () => (/* binding */ noTagErrorMsg),
/* harmony export */   noTitleErrorMsg: () => (/* binding */ noTitleErrorMsg),
/* harmony export */   noTitleTagErrorMsg: () => (/* binding */ noTitleTagErrorMsg),
/* harmony export */   ok: () => (/* binding */ ok),
/* harmony export */   organization: () => (/* binding */ organization),
/* harmony export */   outputPixelType: () => (/* binding */ outputPixelType),
/* harmony export */   owner: () => (/* binding */ owner),
/* harmony export */   parameter: () => (/* binding */ parameter),
/* harmony export */   parameters: () => (/* binding */ parameters),
/* harmony export */   properties: () => (/* binding */ properties),
/* harmony export */   raster: () => (/* binding */ raster),
/* harmony export */   rasterFunctionEditor: () => (/* binding */ rasterFunctionEditor),
/* harmony export */   rasterFunctions: () => (/* binding */ rasterFunctions),
/* harmony export */   rfxLicenseInfo: () => (/* binding */ rfxLicenseInfo),
/* harmony export */   s16PixelType: () => (/* binding */ s16PixelType),
/* harmony export */   s32PixelType: () => (/* binding */ s32PixelType),
/* harmony export */   s8PixelType: () => (/* binding */ s8PixelType),
/* harmony export */   save: () => (/* binding */ save),
/* harmony export */   saveAs: () => (/* binding */ saveAs),
/* harmony export */   saveUtils: () => (/* binding */ saveUtils),
/* harmony export */   savingMessage: () => (/* binding */ savingMessage),
/* harmony export */   scalar: () => (/* binding */ scalar),
/* harmony export */   search: () => (/* binding */ search),
/* harmony export */   selectFeature: () => (/* binding */ selectFeature),
/* harmony export */   selectFunction: () => (/* binding */ selectFunction),
/* harmony export */   selectRaster: () => (/* binding */ selectRaster),
/* harmony export */   serviceURL: () => (/* binding */ serviceURL),
/* harmony export */   setGroupSharing: () => (/* binding */ setGroupSharing),
/* harmony export */   setSharingLevel: () => (/* binding */ setSharingLevel),
/* harmony export */   share: () => (/* binding */ share),
/* harmony export */   shareWith: () => (/* binding */ shareWith),
/* harmony export */   success: () => (/* binding */ success),
/* harmony export */   tagFieldName: () => (/* binding */ tagFieldName),
/* harmony export */   tags: () => (/* binding */ tags),
/* harmony export */   title: () => (/* binding */ title),
/* harmony export */   toolDetailsEditor: () => (/* binding */ toolDetailsEditor),
/* harmony export */   toolEditor: () => (/* binding */ toolEditor),
/* harmony export */   toolModeler: () => (/* binding */ toolModeler),
/* harmony export */   tryAgain: () => (/* binding */ tryAgain),
/* harmony export */   type: () => (/* binding */ type),
/* harmony export */   u16PixelType: () => (/* binding */ u16PixelType),
/* harmony export */   u32PixelType: () => (/* binding */ u32PixelType),
/* harmony export */   u8PixelType: () => (/* binding */ u8PixelType),
/* harmony export */   unionDimensions: () => (/* binding */ unionDimensions),
/* harmony export */   unknownPixelType: () => (/* binding */ unknownPixelType),
/* harmony export */   unsavedTitle: () => (/* binding */ unsavedTitle),
/* harmony export */   unsavedWarningExisting: () => (/* binding */ unsavedWarningExisting),
/* harmony export */   unsavedWarningNew: () => (/* binding */ unsavedWarningNew),
/* harmony export */   userStartDirection: () => (/* binding */ userStartDirection),
/* harmony export */   variables: () => (/* binding */ variables),
/* harmony export */   viewerModeMessage: () => (/* binding */ viewerModeMessage),
/* harmony export */   viewerModeTitle: () => (/* binding */ viewerModeTitle),
/* harmony export */   warning: () => (/* binding */ warning)
/* harmony export */ });
const ok = "OK";
const cancel = "Annuler";
const enterURL = "Saisir l’URL du service d’imagerie";
const serviceURL = "URL du service";
const selectRaster = "Sélectionner un raster";
const failedToLoadLayer = "Échec du chargement de la couche";
const loadingLayer = "Chargement de la couche";
const selectFeature = "Sélectionner une couche d’entités";
const enterFURL = "Saisir l’URL du service d’entités";
const addRaster = "Ajouter une variable raster";
const addScalar = "Ajouter une constante";
const raster = "Raster";
const scalar = "Scalaire";
const defaultModelName = "Modèle de fonction raster";
const general = "Généralités";
const parameters = "Paramètres";
const variables = "Variables";
const name = "Nom";
const description = "Description";
const parameter = "Paramètre";
const isPublic = "EstPublic";
const isDataset = "Jeu de données";
const unknownPixelType = "Inconnu";
const outputPixelType = "Type de pixel en sortie";
const u8PixelType = "Non signé 8 bits";
const s8PixelType = "Signé 8 bits";
const u16PixelType = "Non signé 16 bits";
const s16PixelType = "Signé 16 bits";
const u32PixelType = "Non signé 32 bits";
const s32PixelType = "Signé 32 bits";
const f32PixelType = "Flottant 32 bits";
const f64PixelType = "Double 64 bits";
const properties = "Propriétés";
const multidimensionalRules = "Règles multidimensionnelles";
const matchVariables = "Apparier les variables";
const unionDimensions = "Union des dimensions";
const rasterFunctionEditor = {
	invalidRFTMessage: "Le modèle de fonction raster n’est pas valide.",
	rfxArgsEditor: {
		outputRaster: "Raster en sortie",
		raster: "Raster",
		unsupportedDataTypeWarning: "Les arguments suivants ne sont pas affichés parce qu’ils ne sont pas pris en charge actuellement.",
		unsupportedFunction: "Contient une ou plusieurs fonctions raster actuellement non prises en charge."
	},
	rfxRasterInput: {
		selectLayer: "Sélectionner une couche",
		browseLayers: "Parcourir les couches",
		rfxVariable: "RasterFunctionVariable"
	},
	rfxBandCombinationEditor: {
		methodLabel: "Méthode",
		bandLabel: "Bande",
		combinationLabel: "Combinaison"
	},
	rfxRemapGrid: {
		minimum: "Minimal",
		maximum: "Maximum",
		output: "Sortie",
		noData: "NoData",
		remapValuesLabel: "Valeurs de classification"
	},
	rfxNamedRasterEditor: {
		rasterVariables: "Variables raster",
		deleteSelectedVars: "Supprimer les variables sélectionnées"
	},
	rfxClippingGeometry: {
		clippingLayer: "Couche de découpage",
		clippingRaster: "Découpage du raster",
		clippingGeometry: "Géométrie de découpage",
		customExtent: "Etendue personnalisée",
		outputExtent: "Étendue en sortie",
		currentExtent: "Etendue actuelle de la carte",
		drawLabel: "Dessin"
	},
	rfxCustomExtent: {
		top: "Haut",
		right: "Droite",
		bottom: "Bas",
		left: "Gauche"
	},
	rfxRasterArrayEditor: {
		moveUp: "Monter",
		moveDown: "Descendre",
		remove: "Retirer"
	},
	rfxStatisticsGrid: {
		stdDev: "Écart type",
		min: "Min",
		max: "Max",
		mean: "Moyenne"
	},
	rfxWeightedSumTableEditor: {
		weightedSumTable: "Table de somme pondérée",
		id: "ID",
		layer: "Couche",
		field: "Terrain",
		weight: "Pondération",
		value: "Valeur",
		selectLayer: "Sélectionner une couche"
	},
	rfxWeightedOverlayTableEditor: {
		weightedOverlayTable: "Table de superposition pondérée",
		id: "ID",
		layer: "Couche",
		field: "Terrain",
		influence: "Influence",
		sumOfInfluence: "Somme des influences",
		value: "Valeur",
		remapTable: "Table de classification",
		scale: "Echelle",
		scales: "Échelles",
		selectRaster: "Sélectionner un raster"
	},
	rfxFeatureSelect: {
		addFeatureLayer: "Rechercher une couche d’entités",
		addPointLayer: "Rechercher une couche de points"
	},
	rfxFieldSelect: {
		value: "Valeur",
		count: "Total"
	},
	rfxAttributeTable: {
		tableType: "Type de table",
		manual: "Manuelle",
		external: "Externe",
		minVal: "Valeur minimale",
		maxVal: "Valeur maximale",
		baseClassName: "Nom de base de classe",
		colorScheme: "Combinaison de couleurs",
		defaultClassName: "Etiquette_",
		generateTable: "Générer une table",
		browseTable: "Parcourir la table",
		value: "Valeur",
		classname: "ClassName",
		color: "Couleur"
	},
	rfxFieldNumberSwitchable: {
		number: "Numérique",
		field: "Terrain",
		string: "Chaîne",
		linearUnit: "Unité linéaire"
	},
	rfxPropertySet: {
		name: "Nom",
		value: "Valeur"
	},
	rfxConversionGrid: {
		size: "Taille"
	},
	rfxTransposeBit: {
		bitPattern: "Modèle de bit",
		outputBit: "Bit en sortie",
		inputBit: "Bit en entrée"
	},
	rfxSpatialReference: {
		placeHolder: "Affiner par mot-clé",
		coordinateSystem: "Système de coordonnées",
		gcs: "Système de coordonnées géographiques",
		pcs: "Système de coordonnées projetées",
		vcs: "Système de coordonnées verticales"
	}
};
const rfxLicenseInfo = "Vous pouvez utiliser ce modèle de fonction raster pour traiter votre imagerie à l’aide d’ArcGIS Image Server.";
const rasterFunctions = {
	rfx: {
		aCosHName: "ACosH",
		aCosHSnip: "Calcule le cosinus hyperbolique inverse des cellules d’un raster.",
		aCosHDesc: "La fonction calcule le cosinus hyperbolique inverse des pixels dans un raster.",
		aCosName: "ACos",
		aCosSnip: "Calcule le cosinus inverse des pixels dans un raster.",
		aCosDesc: "Cette fonction raster calcule le cosinus inverse des cellules d’un raster. En mathématiques, toutes les fonctions trigonométriques présentent une plage définie de valeurs en entrée valides, appelée \"domaine\". Les valeurs en sortie de chaque fonction présentent également une plage définie. Pour cet outil, le domaine est [-1, 1] et la plage [0, pi].",
		aSinHName: "ASinH",
		aSinHSnip: "Calcule le sinus hyperbolique inverse des cellules d’un raster.",
		aSinHDesc: "La fonction calcule le sinus hyperbolique inverse des pixels dans un raster.",
		aSinName: "ASin",
		aSinSnip: "Calcule le sinus inverse des cellules d’un raster.",
		aSinDesc: "La fonction calcule le sinus inverse des pixels dans un raster.",
		aTan2Name: "ATan2",
		aTan2Snip: "Calcule la tangente inverse (selon x,y) des cellules d’un raster.",
		aTan2Desc: "La fonction calcule la tangente inverse (selon x,y) des pixels dans un raster.",
		aTanHName: "ATanH",
		aTanHSnip: "Calcule la tangente hyperbolique inverse des cellules d’un raster.",
		aTanHDesc: "La fonction calcule la tangente hyperbolique inverse des pixels dans un raster.",
		aTanName: "ATan",
		aTanSnip: "Calcule la tangente inverse des cellules d’un raster.",
		aTanDesc: "La fonction calcule la tangente inverse des pixels dans un raster.",
		absName: "Abs",
		absSnip: "Calcule la valeur absolue des cellules d’un raster.",
		absDesc: "La fonction Abs calcule la valeur absolue des pixels dans un raster.",
		reflectanceName: "Réflectance apparente",
		reflectanceSnip: "Convertit les images brutes en valeurs de réflectance au sommet de l’atmosphère (TOA, Top of Atmosphere) en tenant compte des caractéristiques du capteur, de la position du soleil et de l’heure d’acquisition.",
		reflectanceDesc: "Cette fonction permet d’ajuster les valeurs de luminosité de l’image pour certains capteurs satellitaires. Les réglages dépendent de l’élévation du soleil, de la date d’acquisition et des propriétés du capteur pour définir le gain et le biais de chaque bande. Cette fonction permet d’ajuster les valeurs de réflectance, ou de luminosité, de certaines images satellite en fonction des paramètres d’éclairage de la scène et de gain du capteur. Les images sont ajustées selon un critère d’éclairage théorique commun en vue de réduire les variations entre les scènes présentant des dates différentes et produites par des capteurs différents. Cela est utile pour la classification des images, l’équilibrage des couleurs et le mosaïquage. Cette fonction peut être utilisée uniquement avec des images spécifiques. Les capteurs Landsat MSS, Landsat TM, Landsat ETM+, Landsat 8, IKONOS, QuickBird, GeoEye-1, RapidEye, DMCii, WorldView-1, WorldView-2, SPOT 6 et Pleiades sont pris en charge.<div><br/>La fonction effectue deux corrections. La première est basée sur les paramètres de gain. Les valeurs de luminosité d’origine sont recréées à partir des valeurs d’image en inversant les équations de gain. La deuxième correction est liée aux différences d’angle du soleil et de luminosité. Les valeurs de luminosité d’origine sont ajustées selon un critère d’éclairage commun en normalisant les scènes capturées dans des conditions d’éclairage variables. En général, bien que le type de données d’image en sortie soit identique au type de données d’image en entrée, les valeurs en sortie sont inférieures aux valeurs en entrée et sont découpées selon la plage de données valide.</div>",
		argStatisticsName: "Statistiques d’argument",
		argStatisticsSnip: "Calcule des statistiques d’argument, dont ArgMax, ArgMin, ArgMedian et Duration.",
		argStatisticsDesc: "La fonction calcule les statistiques d’argument. Quatre méthodes composent la fonction Statistiques d’argument : ArgMax, ArgMin, ArgMedian et Duration.",
		arithmeticName: "Arithmétique",
		arithmeticSnip: "Effectue une opération arithmétique entre deux rasters ou entre un raster et une valeur scalaire.",
		arithmeticDesc: "La fonction Arithmétique effectue une opération arithmétique entre deux rasters ou entre un raster et un scalaire et inversement.",
		aspectSlopeName: "Exposition-Pente",
		aspectSlopeSnip: "Crée un raster qui affiche simultanément l’exposition (direction) et la pente (déclivité) d’une surface continue, comme représenté dans un modèle numérique d’élévation.",
		aspectSlopeDesc: "La fonction Exposition-Pente crée une couche raster qui affiche simultanément l’exposition et la pente d’une surface. L’exposition identifie la direction de pente descendante du taux de variation maximal des valeurs de chaque pixel par rapport aux pixels voisins. L’exposition peut être assimilée à la direction de la pente. Les valeurs du raster en sortie sont la direction au compas de l’exposition, représentées par une teinte (couleur). La pente représente le taux de variation d’élévation pour chaque pixel du modèle numérique d’élévation (MNE). La pente représente la déclivité de la surface et est symbolisée dans trois classes affichées à l’aide de la saturation des couleurs (luminosité).<div><br/>Les valeurs de pixels dans le raster exposition-pente en sortie reflètent une combinaison de l’exposition et de la pente. Les pixels dont les valeurs sont inférieures à 20 sont considérés comme plats et s’affichent en gris. Les valeurs d’exposition-pente égales ou supérieures à 21 s’affichent avec différentes saturations comme suit : de 21 à 30 —Saturation de pente faible, de 31 à 40—Saturation de pente modérée, 41 et valeurs supérieures —Saturation de pente élevée</div>",
		aspectName: "Exposition",
		aspectSnip: "Indique la direction d’un pixel, 0 étant plein nord et les angles augmentant dans le sens horaire jusqu’à 360.",
		aspectDesc: "La fonction Exposition identifie la direction de pente descendante du taux de variation maximal des valeurs de chaque cellule par rapport aux cellules voisines. L’exposition peut être assimilée à la direction de la pente. Les valeurs du raster en sortie sont la direction au compas de l’exposition.<div><br/>L’entrée de cette fonction correspond au raster en entrée. La fonction Exposition est souvent appliquée à un modèle numérique d’élévation (MNE). Par défaut, l’exposition apparaît sous forme d’image en nuances de gris. Vous pouvez ajouter la fonction Palette de couleurs pour spécifier une combinaison de couleurs en particulier ou permettre à l’utilisateur de la mosaïque de modifier la symbologie avec sa propre combinaison de couleurs.</div>",
		tableName: "Table attributaire",
		tableSnip: "Utilise une table pour nommer et symboliser les valeurs dans un jeu de données. Les colonnes de la table sont séparées par des virgules : PixelValue, AttributeName, RedValue, GreenValue, BlueValue.",
		tableDesc: "La fonction Table attributaire vous permet de définir une table attributaire pour symboliser une mosaïque monobande ou un jeu de données raster. <div><br/>Ceci est utile lorsque vous souhaitez présenter des images classées en fonction de l’utilisation du sol, par exemple des forêts, des marécages, des terres cultivables et des zones urbaines. En outre, si votre table contient des champs nommés red (rouge), green (vert) et blue (bleu), les valeurs de ces champs sont utilisées comme une palette de couleurs lors de l’affichage de l’image.</div>",
		bandArithmeticName: "Arithmétique de bande",
		bandArithmeticSnip: "Calcule des indices à l’aide de formules prédéfinies ou d’une expression définie par l’utilisateur.",
		bandArithmeticDesc: "La fonction Arithmétique de bande réalise une opération arithmétique sur les bandes d’un jeu de données raster. Vous pouvez choisir des algorithmes prédéfinis ou saisir votre propre formule uniligne. Les opérateurs pris en charge sont -,+,/,* et - unaire.",
		thresholdName: "Définition d’un seuil binaire",
		thresholdSnip: "Organise les données continues en faisant la distinction entre premier plan et arrière-plan en réduisant la covariance entre les deux classes.",
		thresholdDesc: "Lorsque vous utilisez un jeu de données raster doté d’une distribution bimodale, cette fonction crée un nouveau raster qui divise les données en deux classes distinctes. Elle crée une classe à faible valeur, affichée avec des pixels noirs, et une classe à forte valeur, affichée avec des pixels blancs.",
		bitwiseAndName: "Et bit à bit",
		bitwiseAndSnip: "Effectue une opération Et bit à bit sur les valeurs binaires de deux rasters en entrée.",
		bitwiseAndDesc: "La fonction Et bit à bit effectue une opération Et bit à bit sur les valeurs binaires de deux rasters en entrée.",
		bitwiseLeftShiftName: "Décalage à gauche bit à bit",
		bitwiseLeftShiftSnip: "Effectue une opération de décalage à gauche bit à bit sur les valeurs binaires de deux rasters en entrée.",
		bitwiseLeftShiftDesc: "La fonction Décalage à gauche bit à bit effectue une opération de décalage à gauche bit à bit sur les valeurs binaires de deux rasters en entrée.",
		bitwiseNotName: "Non bit à bit",
		bitwiseNotSnip: "Effectue une opération de complément Non bit à bit sur les valeurs binaires de deux rasters en entrée.",
		bitwiseNotDesc: "La fonction effectue une opération Non bit à bit (de complément) sur la valeur binaire d’un raster en entrée.",
		bitwiseOrName: "Ou bit à bit",
		bitwiseOrSnip: "Effectue une opération Ou bit à bit sur les valeurs binaires de deux rasters en entrée.",
		bitwiseOrDesc: "La fonction effectue une opération Ou bit à bit sur les valeurs binaires de deux rasters en entrée. ",
		bitwiseRightShiftName: "Décalage à droite bit à bit",
		bitwiseRightShiftSnip: "Effectue une opération de décalage à droite bit à bit sur les valeurs binaires de deux rasters en entrée.",
		bitwiseRightShiftDesc: "La fonction effectue une opération Décalage à droite bit à bit sur les valeurs binaires de deux rasters en entrée.",
		bitwiseXorName: "Ou exclusif bit à bit",
		bitwiseXorSnip: "Effectue une opération Ou exclusif bit à bit sur les valeurs binaires de deux rasters en entrée.",
		bitwiseXorDesc: "La fonction effectue une opération Ou exclusif bit à bit sur les valeurs binaires de deux rasters en entrée.",
		booleanAndName: "Et booléen",
		booleanAndSnip: "Effectue une opération Et booléen sur les valeurs de cellules de deux rasters en entrée. Si les deux valeurs en entrée sont vraies (différentes de zéro), la valeur en sortie est égale à 1. Si l’une des valeurs en entrée, ou les deux, sont fausses (égales à zéro), la sortie est égale à 0.",
		booleanAndDesc: "La fonction effectue une opération Et booléen sur les valeurs de pixels de deux entrées. Si les deux valeurs en entrée sont vraies (différentes de zéro), la valeur en sortie est égale à 1. Si l’une des valeurs en entrée, ou les deux, sont fausses (égales à zéro), la valeur en sortie est égale à 0. ",
		booleanNotName: "Non booléen",
		booleanNotSnip: "Effectue une opération de complément Non booléen sur les valeurs de cellules du raster en entrée. Si les valeurs en entrée sont vraies (différentes de zéro), la valeur en sortie est égale à 0. Si les valeurs en entrée sont fausses (égales à zéro), la sortie est égale à 1.",
		booleanNotDesc: "La fonction effectue une opération de complément Non booléen sur les valeurs de pixels du raster en entrée. Si les valeurs en entrée sont vraies (différentes de zéro), la valeur en sortie est égale à 0. Si les valeurs en entrée sont fausses (égales à zéro), la valeur en sortie est égale à 1.",
		booleanOrName: "Ou booléen",
		booleanOrSnip: "Effectue une opération Ou booléen sur les valeurs de cellules des deux rasters en entrée. Si l’une des valeurs en entrée, ou les deux, sont vraies (différentes de zéro), la valeur en sortie est égale à 1. Si les deux valeurs en entrée sont fausses (zéro), la sortie est égale à 0.",
		booleanOrDesc: "La fonction effectue une opération Ou booléen sur les valeurs de cellules de deux rasters en entrée. Si l’une des valeurs en entrée, ou les deux, sont vraies (différentes de zéro), la valeur en sortie est égale à 1. Si les deux valeurs en entrée sont fausses (égales à zéro), la valeur en sortie est égale à 0.",
		booleanXorName: "Ou exclusif booléen",
		booleanXorSnip: "Effectue une opération Ou exclusif booléen sur les valeurs de cellules de deux rasters en entrée. Si une valeur en entrée est vraie (différente de zéro) et que l’autre est fausse (égale à 0), la sortie est égale à 1. Si les deux valeurs en entrée sont vraies ou fausses, la sortie est égale à 0.",
		booleanXorDesc: "La fonction effectue une opération Ou exclusif booléen sur les valeurs de cellule de deux rasters en entrée. Si une valeur en entrée est vraie (différente de zéro) et que l’autre est fausse (égale à 0), la valeur en sortie est égale à 1. Si les deux valeurs en entrée sont vraies ou fausses, la valeur en sortie est égale à 0.",
		bufferedRasterName: "Bufférisé",
		bufferedRasterSnip: "Bufférise les derniers blocs de pixels utilisés.",
		bufferedRasterDesc: "La fonction Bufférisé permet d’optimiser les performances des chaînes de fonctions complexes. Elle stocke la sortie en mémoire de la partie de la chaîne de fonctions qui la précède. <div><br/>Insérez cette fonction dans l’éditeur de fonctions où vous voulez stocker la sortie.</div>",
		rasterCalculatorName: "Calculatrice",
		rasterCalculatorSnip: "Calcule un raster à partir d’une expression mathématique de type raster.",
		rasterCalculatorDesc: "La fonction Calculatrice permet de créer et d’exécuter des expressions afin de les incorporer dans des chaînes de fonctions.",
		cellStatisticsName: "Statistiques de cellule",
		cellStatisticsSnip: "Calcule des statistiques par cellule à partir de plusieurs rasters. Les statistiques disponibles sont les suivantes : Majorité, Maximum, Moyenne, Médiane, Minimum, Minorité, Centile, Plage, Écart type, Somme et Variété.",
		cellStatisticsDesc: "Cette fonction calcule les statistiques de plusieurs rasters, pixel par pixel. Les statistiques disponibles sont les suivantes : majorité, maximum, moyenne, médiane, minimum, minorité, plage, écart type, somme et variété.",
		classifyName: "Classer",
		classifySnip: "Attribue chaque pixel à une classe. Incorporez les données auxiliaires, telles qu’une image segmentée.",
		classifyDesc: "Cette fonction raster classe un jeu de données raster en fonction d’un fichier de définition de classificateur Esri (.ecd) et de jeux de données raster en entrée. Le fichier .ecd utilisé dans la fonction Classifier contient toutes les informations pour un jeu de données et un classificateur spécifiques, et est généré par les outils d’entraînement de classification, tels que Préparer le classificateur de machines à vecteurs de support ou Préparer le classificateur d’arbres aléatoires.",
		clipName: "Découper",
		clipSnip: "Définit l’étendue d’un raster à l’aide de coordonnées ou d’un autre jeu de données.",
		clipDesc: "Cette fonction découpe un raster à l’aide d’une forme rectangulaire selon les étendues définies ou découpe un raster selon la forme d’une classe d’entités surfaciques en entrée. La forme qui définit le découpage peut découper l’étendue du raster ou découper une zone au sein du raster.",
		colorspaceConversionName: "Conversion du modèle de couleur",
		colorspaceConversionSnip: "Convertit un raster de RGB en TSL et inversement.",
		colorspaceConversionDesc: "La fonction de conversion du modèle de couleur convertit le modèle de couleur d’une image de l’espace de couleur TSL (teinte, saturation et luminosité) en RVB (rouge, vert, bleu), ou inversement.<div><br/>Cette fonction peut être utilisée dans un jeu de données mosaïque.</div>",
		colormapToRGBName: "Palette de couleurs vers RVB",
		colormapToRGBSnip: "Convertit un raster monobande en raster à trois bandes (rouge, vert, bleu) à l’aide d’une palette de couleurs.",
		colormapToRGBDesc: "Cette fonction convertit un raster monobande associé à une palette de couleurs en raster à trois bandes (rouge, vert, bleu).<div><br/>Cette fonction est utile pour créer un raster à trois bandes à partir d’un raster monobande à l’aide d’une palette de couleurs associée. Les valeurs de la palette de couleurs serviront à créer chaque bande rouge, verte et bleue. Cette fonction peut être utilisée dans un jeu de données mosaïque.</div>",
		colormapName: "Palette de couleurs",
		colormapSnip: "Modifie les valeurs de pixels pour afficher les données raster soit sous forme d’une image en nuances de gris, soit sous forme d’une image RVB (rouge, vert, bleu), d’après une palette de couleurs ou un dégradé de couleurs.",
		colormapDesc: "La fonction Palette de couleurs est un type de moteur de rendu de données raster. Elle transforme les valeurs de pixels pour afficher les données raster soit sous forme d’une image en nuances de gris, soit sous forme d’une image en couleurs (RVB), en fonction d’une combinaison de couleurs ou des couleurs spécifiques d’un fichier de palette de couleurs. L’utilisation d’une palette de couleurs permet la représentation des données analysées, comme une image classée, ou l’affichage d’une carte topographique (ou d’une image numérisée par couleurs d’index).<div><br/>Les palettes de couleurs contiennent un ensemble de valeurs associées aux couleurs permettant d’afficher de manière cohérente un raster monobande avec ces mêmes couleurs. Chaque valeur de pixel est associée à une couleur, définie comme un ensemble de valeurs RVB (rouge, vert, bleu). Les palettes de couleurs peuvent prendre en charge n’importe quelle valeur de profondeur de couleur, à l’exception des nombres à virgule flottante. Elles prennent également en charge des valeurs positives et négatives et peuvent contenir des valeurs appariées de couleurs manquantes. Lors de l’affichage d’un jeu de données avec une palette de couleurs à laquelle il manque des valeurs, les valeurs manquantes ne sont pas affichées.</div>",
		complexName: "Complexe",
		complexSnip: "Extrait la grandeur de nombres complexes.",
		complexDesc: "Cette fonction calcule une grandeur à partir de valeurs complexes.<div><br/>Cette fonction est généralement utilisée avec l’imagerie RADAR dont le type de données est complexe. Elle peut être utilisée dans un jeu de données mosaïque.</div>",
		compositeBandName: "Bandes composites",
		compositeBandSnip: "Combine plusieurs jeux de données en un seul raster multibande.",
		compositeBandDesc: "La fonction Bandes composites permet de combiner des rasters pour former une image multibande.",
		conName: "Con",
		conSnip: "Effectue une opération conditionnelle If, Then ou Else. Lorsqu’un opérateur Con est utilisé, il doit généralement y avoir deux ou plusieurs fonctions enchaînées ensemble, où une fonction stipule les critères et la seconde fonction est l’opérateur Con qui utilise les critères et dicte quelles sont les sorties vraies ou fausses.",
		conDesc: "La fonction Con définit les pixels dans le raster en sortie en fonction d’une évaluation if\\else de chaque pixel en entrée. Elle renvoie les valeurs de pixels du raster vrai si l’évaluation conditionnelle est vraie (1) ou renvoie les valeurs de pixels du raster faux si l’évaluation conditionnelle est fausse (0). Ce critère est spécifié par la sortie d’une fonction mathématique logique, qui sera le raster en entrée.",
		constantName: "Constante",
		constantSnip: "Crée un raster virtuel avec une seule valeur de pixel.",
		constantDesc: "Cette fonction crée un raster virtuel avec une seule valeur de pixel pouvant être utilisée dans des modèles de fonctions raster et pour traiter un jeu de données mosaïque.<div><br/>La valeur constante est utilisée pour chaque valeur de pixel du raster.</div>",
		contourName: "Isoligne",
		contourSnip: "Crée des isolignes.",
		contourDesc: "La fonction Isoligne génère des isolignes en reliant des points de même élévation à partir d’un jeu de données raster d’élévation. Les isolignes sont créées en tant que rasters pour la visualisation. Les fonctionnalités clés suivantes optimisent la fonction : les isolignes sont générées rapidement et dynamiquement sur des jeux de données très volumineux, tels que World Elevation (élévation mondiale). Les isolignes peuvent être lissées pour offrir une apparence plus satisfaisante sur le plan cartographique tout en conservant leur précision. L’intervalle des isolignes est contrôlé dynamiquement, les options en sortie sont notamment les isolignes, les isolignes d’index et les isolignes remplies.<div><br/>La création d’une couche d’isolignes en tant que produit raster est utile pour une vaste gamme d’applications, car les isolignes peuvent se superposer sur une carte et offrent des informations sur le MNT sans masquer les données sous-jacentes. Elles sont utiles dans de nombreuses applications, telles que le génie civil, l’agriculture et la gestion de l’eau.</div>",
		contrastBrightnessName: "Contraste et luminosité",
		contrastBrightnessSnip: "Ajuste le contraste et la luminosité d’un raster.",
		contrastBrightnessDesc: "La fonction Contraste et luminosité améliore l’apparence des données raster en modifiant la luminosité et le contraste au sein de l’image. La luminosité améliore la clarté globale de l’image—par exemple, pour rendre plus claires des couleurs sombres et pour rendre plus pâles des couleurs claires—tandis que le contraste ajuste la différence entre les couleurs les plus sombres et les couleurs les plus claires.<div><br/>Cette fonction modifie les valeurs des pixels. Utilisez-la lorsque vous souhaitez améliorer l’apparence des données, mais pas si vous souhaitez utiliser les données dans le cadre d’une analyse qui nécessiterait les valeurs de pixels brutes. Cette fonction est utile lorsque vous publiez les données sous la forme d’un service d’imagerie pouvant être utilisé dans des applications sans possibilité de modifier le contraste et la luminosité des images, ou pour vous assurer qu’elles s’affichent avec les paramètres que vous préférez.</div>",
		convolutionName: "Convolution",
		convolutionSnip: "Applique un filtre pour affiner, brouiller, détecter les bords, lisser, ou appliquer un dégradé sur un raster.",
		convolutionDesc: "La fonction Convolution exécute un filtrage sur les valeurs de pixels d’une image, permettant d’affiner une image, de brouiller une image, de détecter des contours dans une image ou d’effectuer d’autres améliorations basées sur le noyau. Les filtres permettent de renforcer la qualité de l’image raster en éliminant des données fictives ou en améliorant la représentation des entités présentes dans les données. Ces filtres de convolution s’appliquent à un noyau superposé en mouvement (fenêtre ou voisinage), par exemple 3 par 3. Les filtres de convolution fonctionnent en calculant la valeur du pixel en fonction de la pondération des pixels voisins.",
		corridorName: "Couloir",
		corridorSnip: "Calcule la somme des coûts cumulés pour deux rasters de coûts cumulés en entrée.",
		corridorDesc: "La fonction Couloir calcule la somme des coûts cumulés pour deux rasters de coûts cumulés en entrée. Vous pouvez employer les deux rasters en entrée, mais si vous souhaitez obtenir un résultat significatif, vous devez utiliser des rasters de coûts cumulés en sortie qui n’ont pas été modifiés. L’ordre des deux entrées n’a pas d’importance.",
		cosHName: "CosH",
		cosHSnip: "Calcule le cosinus hyperbolique des cellules d’un raster.",
		cosHDesc: "La fonction calcule le cosinus hyperbolique des pixels dans un raster.",
		cosName: "Cos",
		cosSnip: "Calcule le cosinus d’une cellule dans un raster.",
		cosDesc: "La fonction calcule le cosinus des pixels dans un raster.",
		costAllocationName: "Allocation de coût",
		costAllocationSnip: "Calcule, pour chaque cellule, sa source de moindre coût à partir du plus faible coût cumulé sur une surface de coût.",
		costAllocationDesc: "La fonction Allocation de coût calcule, pour chaque cellule, sa source de moindre coût à partir du plus faible coût cumulé sur une surface de coût.",
		costBackLinkName: "Antécédence de coût",
		costBackLinkSnip: "Définit le voisin, à savoir la cellule suivante sur le chemin de moindre coût cumulé vers la source de moindre coût.",
		costBackLinkDesc: "La fonction Antécédence de coût définit le voisin, à savoir la cellule suivante sur le chemin de moindre coût cumulé vers la source de moindre coût.<div><br/>Le raster d’antécédence contient des valeurs de zéro à huit qui définissent la direction ou identifient la cellule voisine suivante (la cellule suivante) le long du chemin de moindre coût cumulé à partir d’une cellule pour atteindre sa source de moindre coût. Si le chemin doit passer à l’intérieur du voisin de droite, la cellule se voit attribuer la valeur 1, 2 pour la cellule dans la diagonale inférieure droite, et ainsi de suite dans le sens horaire. La valeur 0 est réservée aux cellules sources.</div>",
		costDistanceName: "Distance de coût",
		costDistanceSnip: "Calcule, pour chaque cellule, la distance de moindre coût cumulé depuis ou vers la source de moindre coût sur une surface de coût.",
		costDistanceDesc: "La fonction Distance de coût calcule la distance de moindre coût cumulé pour chaque cellule depuis ou vers la source de moindre coût sur une surface de coût.",
		costPathName: "Chemin de coût",
		costPathSnip: "Calcule le chemin de moindre coût entre une source et une destination.",
		costPathDesc: "La fonction Chemin de coût calcule le chemin de moindre coût entre une source et une destination.<div><br/>Cette fonction permet d’obtenir un raster en sortie qui enregistre le ou les chemins de moindre coût à partir des emplacements sélectionnés vers la cellule source la plus proche telle que définie dans la surface de coût cumulé (en tenant compte des distances de coût).</div>",
		curvatureName: "Courbure",
		curvatureSnip: "Calcule la courbure d’une surface raster, en incluant éventuellement la courbure longitudinale et transversale.",
		curvatureDesc: "La fonction Courbure affiche la forme ou la courbure de la pente. Une partie d’une surface peut être concave ou convexe. Il est possible de le savoir en consultant la valeur de courbure. La courbure est obtenue en calculant la dérivée seconde de la surface.<div><br/>La sortie générée par la fonction Courbure permet de décrire les caractéristiques physiques d’un bassin de drainage afin de comprendre les processus d’érosion et d’écoulement. La valeur de courbure permet de rechercher les motifs d’érosion du sol, ainsi que la distribution de l’eau sur les terres. La courbure longitudinale affecte l’accélération et la décélération du flux, ce qui influence l’érosion et la sédimentation. La courbure planiforme influence la convergence et la divergence du flux.</div>",
		divideName: "Division",
		divideSnip: "Divise les valeurs de deux rasters, cellule par cellule.",
		divideDesc: "La fonction Division divise les valeurs de deux rasters, pixel par pixel.",
		elevationVoidFillName: "Remplissage des vides d’élévation",
		elevationVoidFillSnip: "Crée des pixels dans les zones comportant des discontinuités dans vos données d’élévation.",
		elevationVoidFillDesc: "La fonction de remplissage des vides d’élévation permet de créer des pixels lorsque des discontinuités sont présentes dans vos données d’élévation.<div><br/>Les vides se produisent lorsqu’aucun point n’est collecté dans la surface représentée par un pixel dans le raster résultant. Les vides sont souvent provoqués par la présence de plans d’eau, ou par la sélection ou l’exclusion de types de classes. Le remplissage des vides est utilisé le plus souvent lors de la génération d’une surface au sol.</div>",
		equalToName: "Égal à",
		equalToSnip: "Effectue une opération relationnelle Égal à sur deux entrées, cellule par cellule. Renvoie la valeur 1 pour les cellules pour lesquelles le premier raster est égal au second raster, et la valeur 0 dans le cas contraire.",
		equalToDesc: "La fonction effectue une opération Égal à sur deux rasters, pixel par pixel. Elle renvoie la valeur 1 pour les pixels pour lesquels le premier raster est égal au second raster, et la valeur 0 dans le cas contraire.",
		eucAllocationName: "Allocation euclidienne",
		eucAllocationSnip: "Calcule, pour chaque cellule, la source la plus proche en fonction de la distance euclidienne.",
		eucAllocationDesc: "La fonction Allocation euclidienne calcule, pour chaque cellule, la source la plus proche en fonction de la distance euclidienne.",
		eucDirectionName: "Direction euclidienne",
		eucDirectionSnip: "Calcule, pour chaque cellule, la direction en degrés par rapport à la source la plus proche.",
		eucDirectionDesc: "La fonction Direction euclidienne calcule, pour chaque cellule, la direction en degrés par rapport à la source la plus proche. <div><br/>La direction est calculée à partir du centre de chaque cellule vers le centre de la cellule source la plus proche. La plage de valeurs s’étend de 0 à 360 degrés, 0 étant réservé aux cellules source. La direction plein est (droite) correspond à 90 et les valeurs augmentent dans le sens horaire (180 correspond au sud, 270 à l’ouest et 360 au nord).</div>",
		eucDistanceName: "Distance euclidienne",
		eucDistanceSnip: "Calcule, pour chaque cellule, la distance euclidienne par rapport à la source la plus proche.",
		eucDistanceDesc: "La fonction Distance euclidienne calcule, pour chaque cellule, la distance euclidienne par rapport à la source la plus proche.",
		exp10Name: "Exp10",
		exp10Snip: "Calcule l’exponentielle de base 10 des cellules d’un raster.",
		exp10Desc: "La fonction Exp 10 calcule l’exponentielle de base 10 des pixels dans un raster.",
		exp2Name: "Exp2",
		exp2Snip: "Calcule l’exponentielle de base 2 des cellules d’un raster.",
		exp2Desc: "Cette fonction calcule l’exponentielle de base 2 des pixels dans un raster.",
		expName: "Exp",
		expSnip: "Calcule l’exponentielle de base e des cellules d’un raster.",
		expDesc: "Cette fonction calcule l’exponentielle de base e des pixels dans un raster.",
		extractBandName: "Extraire les bandes",
		extractBandSnip: "Spécifie les bandes avec lesquelles travailler lors de l’utilisation de jeux de données multibandes.",
		extractBandDesc: " La fonction Extraire les bandes permet d’extraire une ou plusieurs bandes, ou de réorganiser les bandes dans un jeu de données raster multibande.<div><br/>Vous pouvez utiliser la fonction Extraire les bandes avant que d’autres fonctions soient appliquées (Arithmétique, par exemple), pour contrôler les bandes qui sont utilisées en entrée dans la prochaine fonction.</div>",
		fillName: "Remplissage",
		fillSnip: "Remplit les cuvettes d’une surface raster pour supprimer de légères imperfections dans les données.",
		fillDesc: "La fonction globale Remplissage localise et remplit les cuvettes et les pics dans un raster de surface d’élévation afin de supprimer les petites imperfections dans les données. La fonction effectue le remplissage de manière itérative jusqu’à ce que toutes les cuvettes soient remplies dans la limite Z spécifiée.<div><br/>Lorsqu’une surface d’élévation est créée avec des outils d’orthocartographie ou par d’autres moyens, des erreurs (petites, mais notables) apparaissent souvent sous la forme de cuvettes et de pics dans les données. En photogrammétrie, les cuvettes et les pics sont souvent nommés trous et pointes. Comme les données de surface sont souvent utilisées en modélisation (la modélisation hydrologique, par exemple), il est important de corriger ces cuvettes et pics de manière cohérente par rapport aux données environnantes.</div>",
		floatName: "Flottant",
		floatSnip: "Convertit chaque valeur de cellule d’un raster en une représentation en virgule flottante.",
		floatDesc: "La fonction Flottant convertit chaque valeur de pixel d’un raster en une représentation en virgule flottante.",
		flowAccumulationName: "Accumulation de flux",
		flowAccumulationSnip: "Crée un raster de flux cumulé dans chaque cellule. Si besoin, vous pouvez utiliser un facteur de pondération.",
		flowAccumulationDesc: "La fonction globale Accumulation de flux génère un raster de flux cumulé dans chaque pixel, conformément à l’accumulation des pondérations de tous les pixels qui s’écoulent dans les cellules en pente descendante. Si aucun raster de pondération n’est fourni, une pondération de 1 est attribuée à chacun des pixels, et la valeur des pixels du raster en sortie correspond au nombre de pixels qui s’écoulent vers chaque pixel.<div><br/>Les pixels en sortie présentant une accumulation de flux élevée sont des zones de flux concentré qui peuvent être utilisées pour identifier des canaux d’écoulement. Les pixels en sortie présentant une accumulation de flux nulle sont des zones topographiques locales élevées qui peuvent être utilisées pour identifier des crêtes.</div>",
		flowDirectionName: "Direction de flux",
		flowDirectionSnip: "Crée un raster de direction de flux à partir de chaque cellule vers son voisin de plus grande pente descendante.",
		flowDirectionDesc: "L’un des principaux aspects de la dérivation des caractéristiques hydrologiques d’une surface est la capacité à déterminer la direction du flux de chaque pixel d’un raster. La fonction raster Direction de flux prend une surface en entrée et crée un raster de direction de flux à partir de chaque pixel vers son voisin de plus grande pente descendante. La fonction Direction de flux prend en charge trois méthodes de modélisation de flux : D8 (huit directions), MFD (Multiple Flow Direction) et DINF (D-Infinity). ",
		flowDistanceName: "Distance d’écoulement",
		flowDistanceSnip: "Calcule, pour chaque cellule, la distance de pente descendante verticale ou horizontale minimale vers les cellules dans un cours d’eau ou une rivière dans lesquelles elles transitent.",
		flowDistanceDesc: "Pour chaque pixel, la fonction calcule la distance de pente descendante verticale ou horizontale minimale vers le ou les pixels dans un cours d’eau ou une rivière dans lesquels ils transitent. Si un raster de direction de flux facultatif est fourni, les directions de pente descendante seront limitées à celles définies par le raster de direction de flux en entrée. La sortie est un raster de distance d’écoulement.",
		focalName: "Statistiques focales",
		focalSnip: "Calcule les statistiques focales de chaque pixel d’une image en fonction d’un voisinage focal défini.",
		focalDesc: "La fonction Statistiques focales calcule des statistiques focales pour chaque pixel d’une image en fonction d’un voisinage focal défini.",
		geometricName: "Géométrique",
		geometricSnip: "Augmente la précision de position d’un jeu de données en tenant compte de l’élévation.",
		geometricDesc: "La fonction Géométrique produit une image orthorectifiée à partir d’une définition de capteur et d’un MNT. Elle augmente la précision de position d’un jeu de données en tenant compte de l’élévation.",
		grayscaleName: "Nuances de gris",
		grayscaleSnip: "Convertit une image multibande en image monobande en nuances de gris.",
		grayscaleDesc: "Cette fonction convertit une image multibande en image monobande en nuances de gris.<div><br/>Cette fonction applique des pondérations spécifiées à chaque bande en entrée et normalise l’image en sortie. Les pondérations sont souvent appliquées car certaines bandes ont une importance variable en fonction de l’application. Ainsi, la bande bleue contient davantage de bruit que les autres bandes.</div>",
		greaterThanEqualName: "Supérieur ou égal à",
		greaterThanEqualSnip: "Effectue une opération relationnelle Supérieur ou égal à sur deux entrées, cellule par cellule. Renvoie la valeur 1 pour les cellules pour lesquelles le premier raster est supérieur ou égal au second raster, et la valeur 0 dans le cas contraire.",
		greaterThanEqualDesc: "La fonction effectue une opération relationnelle Supérieur ou égal à sur deux entrées, pixel par pixel. Elle renvoie une valeur de 1 pour les pixels pour lesquels le premier raster est supérieur ou égal au second raster, et une valeur de 0 pour les pixels pour lesquels le premier raster n’est pas supérieur ou égal au second raster.",
		greaterThanName: "Supérieur à",
		greaterThanSnip: "Effectue une opération relationnelle Supérieur à sur deux entrées, cellule par cellule. Renvoie la valeur 1 pour les cellules pour lesquelles le premier raster est supérieur au second raster, et la valeur 0 dans le cas contraire.",
		greaterThanDesc: "La fonction effectue une opération relationnelle Supérieur à sur deux entrées, pixel par pixel. Renvoie une valeur de 1 pour les pixels pour lesquels le premier raster est supérieur au second raster, et une valeur de 0 pour les pixels pour lesquels le premier raster n’est pas supérieur au second raster.",
		heatIndexName: "Indice de chaleur",
		heatIndexSnip: "Combine la température ambiante et l’humidité relative pour renvoyer la température apparente.",
		heatIndexDesc: "Cette fonction calcule la température apparente d’après la température ambiante et l’humidité relative. La température apparente est souvent décrite comme la chaleur ressentie par le corps humain.<div><br/>Cet indice peut être utile pour prévoir les problèmes médicaux, tels que les crampes musculaires, la déshydratation, les insolations ou les coups de chaleur plus graves par temps chaud et humide. Lorsque l’humidité relative est élevée, la transpiration corporelle a de plus en plus de mal à s’évaporer, ce qui prive les personnes d’un mode de rafraîchissement naturel. Les cartes des avertissements ou avis de chaleur proviennent souvent de la reclassification de l’indice de chaleur en classes. Plus la valeur de l’indice est élevée et plus il est probable qu’un avertissement soit publié au lieu d’un avis.</div>",
		hillshadeName: "Ombrage",
		hillshadeSnip: "Crée une représentation 3D de la surface qui tient compte de la position relative du soleil pour l’ombrage de l’image.",
		hillshadeDesc: "La fonction Ombrage génère une représentation 3D en nuances de gris de la surface du terrain, avec prise en compte de la position relative du soleil pour l’ombrage de l’image. <div><br/>L’ombrage est une technique de visualisation du MNT déterminée par une source d’éclairage, ainsi que par la pente et l’exposition de la surface d’élévation. Il s’agit d’une méthode qualitative de visualisation de la topographie qui ne génère pas de valeurs d’élévation absolues. </div>",
		intName: "Entier",
		intSnip: "Convertit chaque valeur de cellule d’un raster en nombre entier, par troncation.",
		intDesc: "La fonction Entier convertit chaque valeur de pixel d’un raster en nombre entier, par troncation.",
		interpolateIrregularDataName: "Interpoler les données irrégulières",
		interpolateIrregularDataSnip: "Interpole à partir de nuages de points ou de grilles irrégulières.",
		interpolateIrregularDataDesc: "Certains jeux de données netCDF ou HDF stockent leur géolocalisation sous forme de tableaux irrégulièrement espacés de pixels ou de données ponctuelles. Lors de l’ajout de ces jeux de données à un jeu de données mosaïque, la fonction Interpoler les données irrégulières utilise les données quadrillées de façon irrégulière et les rééchantillonne afin que chaque pixel soit carré et de taille uniforme.<div><br/>Lorsque vous ajoutez les variables d’un fichier netCDF ou HDF à un jeu de données mosaïque, la fonction vérifie automatiquement si les données sont organisées de façon régulière. Si ce n’est pas le cas, la fonction Interpoler les données irrégulières peut servir à convertir les données irrégulières en raster régulier. Vous pouvez changer la méthode d’interpolation et la taille de cellule utilisées dans la fonction raster Interpoler les données irrégulières. Pour les données raster régulièrement espacées, aucune interpolation n’est appliquée et les données sont lues telles quelles.</div>",
		isNullName: "Est nul",
		isNullSnip: "Détermine les valeurs des rasters en entrée qui sont NoData, cellule par cellule. Renvoie la valeur 1 si les valeurs en entrée sont NoData, et la valeur 0 si ce n’est pas le cas.",
		isNullDesc: "La fonction Est nul détermine les valeurs du raster en entrée qui sont NoData, pixel par pixel. Elle renvoie une valeur de 1 si la valeur en entrée est NoData, et une valeur de 0 pour les pixels qui ne sont pas NoData.",
		kernelDensityName: "Densité de noyau",
		kernelDensitySnip: "Calcule une grandeur par unité de carte à partir d’entités ponctuelles ou polylignes à l’aide d’une fonction de noyau pour ajuster une surface régulièrement effilée à chaque point ou polyligne.",
		kernelDensityDesc: "Cette fonction calcule une grandeur par unité de carte à partir d’entités ponctuelles ou polylignes à l’aide d’une fonction de noyau pour ajuster une surface régulièrement effilée à chaque point ou polyligne.",
		keyMetadataName: "Métadonnées clés",
		keyMetadataSnip: "Remplace ou insère les métadonnées clés d’un raster dans une chaîne de fonctions.",
		keyMetadataDesc: "Cette fonction vous permet d’insérer ou de remplacer les métadonnées clés d’un raster.<div><br/>Les informations dans les métadonnées clés permettent de simplifier certaines tâches de traitement et d’affichage de l’application, notamment grâce à certaines informations utiles telles que le nom du capteur, les noms de bandes ou la couverture nuageuse associés à l’image.</div>",
		shortestPathName: "Chemin de moindre coût",
		shortestPathSnip: "Effectue une analyse de distance de coût à l’aide d’une source et d’une destination en entrée. Cette analyse est ensuite utilisée pour déterminer le chemin de moindre coût entre une source et une destination.",
		shortestPathDesc: "La fonction Chemin de moindre coût calcule le chemin de moindre coût entre une source et une destination. Pour chaque pixel, la distance de moindre coût cumulé est calculée vers la source la plus proche sur une surface de coût. Ceci permet d’obtenir un raster en sortie qui enregistre le ou les chemins de moindre coût à partir des emplacements sélectionnés vers les pixels sources les plus proches tels que définis dans la surface de coût cumulé (en tenant compte des distances de coût).<div><br/>Chaque chemin de moindre coût se voit attribuer une valeur issue du processus de numérisation. Le pixel de fin dans le raster source d’un chemin de coût reçoit la valeur 1. Le premier chemin reçoit la valeur 3, le deuxième chemin la valeur 4, et ainsi de suite. Lorsque plusieurs chemins se rejoignent et poursuivent sur la distance restante en revenant vers une source sur le même trajet, le segment sur lequel les deux chemins sont combinés se voit attribuer la valeur 2. Vous ne pouvez pas attribuer la partie combinée du chemin à la valeur de l’un des chemins, car la partie combinée dépend des deux itinéraires.</div>",
		lessThanEqualName: "Inférieur ou égal à",
		lessThanEqualSnip: "Effectue une opération relationnelle Inférieur ou égal à sur deux entrées, cellule par cellule. Renvoie la valeur 1 pour les cellules pour lesquelles le premier raster est inférieur ou égal au second raster, et la valeur 0 dans le cas contraire.",
		lessThanEqualDesc: "La fonction effectue une opération relationnelle Inférieur ou égal à sur deux entrées, pixel par pixel. Elle renvoie une valeur de 1 pour les pixels pour lesquels le premier raster est inférieur ou égal au second raster, et une valeur de 0 si le premier raster n’est pas inférieur ou égal au second raster.",
		lessThanName: "Inférieur à",
		lessThanSnip: "Effectue une opération relationnelle Inférieur à sur deux entrées, cellule par cellule. Renvoie 1 pour les cellules pour lesquelles le premier raster est inférieur au deuxième raster, et 0 dans le cas contraire.",
		lessThanDesc: "La fonction effectue une opération relationnelle Inférieur à sur deux entrées, pixel par pixel. Elle renvoie une valeur de 1 pour les pixels pour lesquels le premier raster est inférieur au deuxième, et une valeur de 0 s’il n’est pas inférieur au deuxième.",
		lnName: "Ln",
		lnSnip: "Calcule le logarithme naturel (base e) des cellules d'un raster.",
		lnDesc: "La fonction Ln calcule le logarithme naturel (base e) de chaque pixel dans un raster.",
		log10Name: "Log10",
		log10Snip: "Calcule le logarithme base 10 des cellules d'un raster.",
		log10Desc: "La fonction Log10 calcule le logarithme de base 10 de chaque pixel dans un raster.",
		log2Name: "Log2",
		log2Snip: "Calcule le logarithme base 2 des cellules d'un raster.",
		log2Desc: "La fonction Log2 calcule le logarithme de base 2 de chaque pixel dans un raster.",
		lookupName: "Correspondance",
		lookupSnip: "Crée un nouveau raster par correspondance des valeurs trouvées dans un autre champ de la table du raster en entrée.",
		lookupDesc: "La fonction crée un nouveau raster par correspondance des valeurs trouvées dans un autre champ de la table du raster en entrée.",
		mlClassifyName: "Classification ML",
		mlClassifySnip: "Classe l’imagerie pixel par pixel. Les pixels mélangés sont attribués à l’entité possédant le pourcentage le plus élevé dans ce pixel.",
		mlClassifyDesc: "La fonction de classification ML vous permet d'effectuer une classification supervisée, à l'aide d'un algorithme de classification de vraisemblance maximale, sur un jeu de données raster ou une mosaïque. Cette fonction nécessite un fichier de signatures de classification.",
		maskName: "Masque",
		maskSnip: "Définit les valeurs que vous ne souhaitez pas afficher.",
		maskDesc: "Cette fonction raster définit les valeurs que vous ne souhaitez pas afficher dans votre raster. La fonction Masque permet de spécifier une ou plusieurs valeurs NoData ou une plage de valeurs de pixels valides. ",
		minusName: "Soustraction",
		minusSnip: "Soustraie la valeur du deuxième raster en entrée de la valeur du premier raster en entrée, cellule par cellule.",
		minusDesc: "La valeur Soustraction soustraie la valeur du deuxième raster en entrée de la valeur du premier raster en entrée, pixel par pixel.",
		modName: "Mod",
		modSnip: "Détermine le reste (modulo) du premier raster après division par le deuxième raster, cellule par cellule.",
		modDesc: "La fonction Mod détermine le reste (modulo) du premier raster après division par le deuxième raster, pixel par pixel. L’ordre des entrées est important et affecte le résultat en sortie.",
		mosaicRastersName: "Mosaïquage de rasters",
		mosaicRastersSnip: "Assemble un jeu de données raster afin de créer un seul jeu de données.",
		mosaicRastersDesc: "La fonction Mosaïquage de rasters crée une image de mosaïque à partir de plusieurs images. Lorsque les images se superposent, plusieurs méthodes permettent de déterminer les images à afficher.",
		ndviColorizedName: "NDVI colorisé",
		ndviColorizedSnip: "Crée un jeu de données monocal représentant l'état sanitaire de la végétation en s'appuyant sur la différence entre les canaux rouge et proche infrarouge.",
		ndviColorizedDesc: "La fonction NDVI colorisé applique la fonction NDVI à l’image en entrée, puis utilise une palette de couleurs ou un dégradé de couleurs pour afficher le résultat.",
		ndviName: "NDVI",
		ndviSnip: "Calcule l’indice de végétation par différence normalisée (NDVI).",
		ndviDesc: "La fonction NDVI crée un jeu de données monocal représentant l’état sanitaire de la végétation en s’appuyant sur la différence entre les canaux rouge et proche infrarouge.<div><br/>NDVI est un indice normalisé qui vous permet de générer une image illustrant la couverture végétale, également connue sous le nom de biomasse relative. Cet indice tire parti du contraste des caractéristiques de deux canaux d’un jeu de données raster multispectral : l’absorption de pigments chlorophylliens dans le canal rouge et la réflectivité élevée des matières végétales dans le canal proche infrarouge (NIR). Les valeurs NDVI négatives ou extrêmement faibles représentent des zones dépourvues de végétation, telles que les nuages, l’eau ou la neige. Les valeurs très faibles représentent des zones sans ou avec peu de végétation, comme le béton, les rochers ou le sol nu. Les valeurs modérées représentent des zones comportant des arbustes et des pâturages. Les valeurs élevées représentent des zones de forêt et une végétation luxuriante.</div>",
		negateName: "Opposé",
		negateSnip: "Change le signe (multiplie par -1) des valeurs de cellules du raster en entrée, cellule par cellule.",
		negateDesc: "La fonction Opposé change le signe (multiplie par -1) des valeurs de pixels du raster en entrée, pixel par pixel. ",
		nibbleName: "Grignotage",
		nibbleSnip: "Remplace les cellules d’un raster correspondant à un masque par les valeurs des voisins les plus proches.",
		nibbleDesc: "La fonction globale Grignotage permet aux zones sélectionnées d’un raster de se voir attribuer la valeur du voisin le plus proche. Cela est utile pour mettre à jour les zones d’un raster pour lequel les données peuvent être erronées.",
		notEqualName: "Différent de",
		notEqualSnip: "Effectue une opération relationnelle Différent de sur deux entrées, cellule par cellule. Renvoie 1 pour les cellules pour lesquelles le premier raster n'est pas égal au deuxième raster et 0 dans le cas contraire.",
		notEqualDesc: "La fonction effectue une opération relationnelle Différent de sur deux entrées, pixel par pixel. Elle renvoie une valeur de 1 pour les pixels pour lesquels le premier raster n’est pas égal au deuxième, et une valeur de 0 pour les pixels pour lesquels il est égal au deuxième.",
		pansharpeningName: "Affinage panchromatique",
		pansharpeningSnip: "Améliore artificiellement la résolution spatiale d’une image multicanal en la fusionnant avec une image panchromatique haute résolution.",
		pansharpeningDesc: "La fonction Affinage panchromatique permet de fusionner une image panchromatique (ou canal raster) de résolution supérieure avec un jeu de données raster multicanal de résolution inférieure afin d’optimiser la résolution spatiale de l’image multicanal.<div><br/>L’objectif de l’amélioration de la netteté panchromatique est de générer une image d’une qualité visuelle supérieure. Comme les techniques utilisées modifient la radiométrie et les caractéristiques spectrales de l’imagerie multicanal, il est recommandé d’utiliser ces images améliorées avec prudence dans les analyses de télédétection.</div>",
		pathAllocationName: "Allocation de distance de chemin",
		pathAllocationSnip: "Calcule la source de moindre coût pour chaque cellule, en fonction du coût cumulé le moins important sur une surface de coût, tout en tenant compte de la distance de surface et des facteurs de coût horizontaux et verticaux.",
		pathAllocationDesc: "La fonction Allocation de distance de chemin calcule pour chaque cellule la source la plus proche en fonction du plus faible coût cumulé sur une surface de coût, tout en tenant compte la distance à la surface et les facteurs de coût horizontaux et verticaux.",
		pathBackLinkName: "Antécédence de distance de chemin",
		pathBackLinkSnip: "Définit le voisin qui est la cellule suivante sur le chemin de plus faible coût cumulé menant à la source de moindre coût, tout en tenant compte de la distance de surface et des facteurs de coût horizontaux et verticaux.",
		pathBackLinkDesc: "La fonction Antécédence de distance de chemin identifie la direction du voisin qui est la cellule suivante sur le chemin de plus faible coût cumulé menant à la source la plus proche, tout en tenant compte de la distance de surface et des facteurs de coût horizontaux et verticaux.",
		pathDistanceName: "Distance de chemin",
		pathDistanceSnip: "Calcule, pour chaque cellule, la distance de plus faible coût cumulé depuis ou vers la source de moindre coût, tout en tenant compte de la distance de surface et des facteurs de coût horizontaux et verticaux.",
		pathDistanceDesc: "La fonction Distance de chemin calcule, pour chaque cellule, la distance de plus faible coût cumulé jusqu’à la source la plus proche, tout en tenant compte de la distance de surface et des facteurs de coût horizontaux et verticaux.",
		plusName: "Plus",
		plusSnip: "Additionne (fait la somme) les valeurs de deux rasters, cellule par cellule.",
		plusDesc: "La fonction Addition ajoute (fait la somme) les valeurs de deux rasters, pixel par pixel.",
		powerName: "Puissance",
		powerSnip: "Elève les valeurs des cellules d’un raster à la puissance des valeurs d’un autre raster.",
		powerDesc: "La fonction Puissance élève les valeurs de pixels d’un raster à la puissance des valeurs d’un autre raster.",
		radarCalibrationName: "Calibrage de radar",
		radarCalibrationSnip: "Convertit des données RADARSAT-2 en données de rétrodiffusion radar.",
		radarCalibrationDesc: "Cette fonction permet de calibrer l’imagerie RADARSAT-2 dans un jeu de données mosaïque ou en tant que produit raster. Le calibrage est exécuté sur les images radar, de telle sorte que les valeurs de pixels sont une véritable représentation de la rétrodiffusion radar.",
		rasterInfoName: "Informations raster",
		rasterInfoSnip: "Modifie les propriétés du raster, telles que la profondeur de couleur, la valeur NoData, la taille de cellule, l'étendue, etc.",
		rasterInfoDesc: "La fonction Informations raster permet d’ouvrir une boîte de dialogue affichant les propriétés du jeu de données raster, telles que le nombre de colonnes et de lignes, le nombre de canaux, le type de pixel, l'étendue et la référence spatiale. Vous pouvez mettre à jour ces propriétés en sélectionnant un jeu de données raster à utiliser comme modèle. ",
		rasterizeAttributesName: "Rastériser les attributs",
		rasterizeAttributesSnip: "Enrichit un raster via des canaux supplémentaires dérivés de valeurs de certains attributs d’une table externe ou d’un service d’entités.",
		rasterizeAttributesDesc: "La fonction Rastériser les attributs raster enrichit un raster en ajoutant des canaux dérivés de valeurs d’attributs spécifiés, à partir d’une table externe ou d’un service d’entités. Vous pouvez spécifier un raster de zones et l’attribut ID de zone associé pour activer la recherche régionale.",
		rasterizeFeatureClassName: "Rasteriser les entités",
		rasterizeFeatureClassSnip: "Convertit les entités en raster.",
		rasterizeFeatureClassDesc: "Cette fonction convertit des données de classes d’entités surfaciques, polylignes et points en couche raster.<div><br/>Des valeurs de pixels sont attribuées aux entités en fonction de l’OBJECTID des entités (par défaut). Les valeurs de pixels peuvent également reposer sur un champ de valeurs définies par l’utilisateur dans la table attributaire des entités en entrée.</div>",
		recastName: "Redéfinir",
		recastSnip: "Modifie les paramètres d’une chaîne de fonctions dans un jeu de données mosaïque ou un service d’imagerie. Cette option est souvent utilisée avec les jeux de données LAS afin d’éviter de créer un jeu de données mosaïque séparé pour différentes représentations d’un terrain.",
		recastDesc: "La fonction Redéfinir est utilisée pour modifier dynamiquement le paramètre de fonction utilisé dans une mosaïque ou un service d'imagerie sans conserver physiquement les modifications.",
		regionGroupName: "Groupes par régions",
		regionGroupSnip: "Pour chaque cellule en sortie, l'identité de la région connectée à laquelle appartient la cellule est enregistrée. Un numéro unique est attribué à chaque région.",
		regionGroupDesc: "La fonction globale Groupes par régions enregistre, pour chaque cellule en sortie, l’identité de la région connectée à laquelle cette cellule appartient. Un numéro unique est attribué à chaque région.<div><br/>La première région analysée reçoit la valeur un, la deuxième, la valeur deux, etc., jusqu’à ce qu’une valeur soit affectée à toutes les régions. Le balayage s'effectue de gauche à droite, de haut en bas. Les valeurs affectées aux zones en sortie dépendent du moment où elles sont détectées par le processus de numérisation.</div>",
		regionGrowName: "Étendre la région",
		regionGrowSnip: "Etend les régions à partir de points d'origine.",
		regionGrowDesc: "La fonction Étendre la région regroupe les pixels voisins en fonction du rayon spécifié par rapport au point d’origine. Une valeur de remplissage spécifique est attribuée au groupe de pixels, ou objet.",
		remapName: "Classification",
		remapSnip: "Change les valeurs des pixels en attribuant de nouvelles valeurs à des plages de valeurs de pixel ou en utilisant une table externe.",
		remapDesc: "La fonction Classification vous permet de modifier ou de reclasser les valeurs des pixels des données raster. Cette opération peut s’effectuer en spécifiant une plage de valeurs de pixels à apparier à une valeur de pixel en sortie ou en utilisant une table pour apparier les valeurs de pixels à une valeur de pixel en sortie.",
		reprojectName: "Reprojeter",
		reprojectSnip: "Modifie la projection d'un jeu de données raster, d'une mosaïque ou d'un élément raster dans une mosaïque. Elle permet également de rééchantillonner les données pour définir une nouvelle taille de cellule et une origine.",
		reprojectDesc: "La fonction de reprojection modifie la projection d’un jeu de données raster, d’un jeu de données mosaïque ou d’un élément raster dans un jeu de données mosaïque. Elle permet également de rééchantillonner les données pour définir une nouvelle taille de cellule et une origine.<div><br/>La fonction Reprojeter peut servir lors de la création d’un cache à partir d’un jeu de données raster ou d’un de données mosaïque qui ne figure pas dans la projection requise. Par exemple, lorsque vous créez un service d’imagerie en cache que des applications peuvent intégrer à d’autres services en cache, il est important qu’ils figurent tous dans la même projection. Il s’agit souvent d’une projection Web Mercator. Comme le jeu de données mosaïque ne peut pas être reprojeté, vous pouvez procéder de l’une des manières suivantes—créez un jeu de données référencé à partir de votre jeu de données mosaïque dans la projection requise ou ajoutez la fonction Reprojeter à la chaîne de fonctions du jeu de données mosaïque. Un autre exemple utilise cette fonction sur l'élément raster d'un jeu de données mosaïque. Lorsque vous faites appel à la fonction Raster mis en cache, vous pouvez insérer la fonction Reprojeter pour créer le cache dans la nouvelle projection. Les éléments raster d'une mosaïque peuvent être mis en cache lorsque le traitement est intense et que vous essayez de publier un service d'imagerie qui est rapide, sans le mettre totalement en cache.</div>",
		resampleName: "Ré-échantillonner",
		resampleSnip: "Modifie la taille de cellule d'un raster.",
		resampleDesc: "La fonction Ré-échantillonner modifie la taille de cellule, le type de rééchantillonnage ou les deux.<div><br/>Elle doit être utilisée uniquement avec des besoins en calcul spécifiques. Par exemple, si vous calculez la grandeur-direction du vent ou du courant qui nécessite un rééchantillonnage à partir de la résolution source.</div>",
		roundDownName: "Arrondi inférieur",
		roundDownSnip: "Renvoie la prochaine valeur entière inférieure, simplement représentée en tant que virgule flottante, pour chaque cellule d’un raster.",
		roundDownDesc: "La fonction Arrondi inférieur renvoie le prochain entier inférieur, en tant que valeur de virgule flottante, pour chaque pixel d’un raster.",
		roundUpName: "Arrondi supérieur",
		roundUpSnip: "Renvoie la prochaine valeur entière supérieure, simplement représentée en tant que virgule flottante, pour chaque cellule d’un raster.",
		roundUpDesc: "La fonction Arrondi supérieur renvoie le prochain entier supérieur, en tant que valeur de virgule flottante, pour chaque pixel d’un raster.",
		segmentMeanShiftName: "Décalage moyen de segment",
		segmentMeanShiftSnip: "Regroupe les pixels adjacents qui présentent des caractéristiques spectrales similaires en segments.",
		segmentMeanShiftDesc: "Cette fonction identifie les objets, entités ou segments dans votre imagerie en regroupant les pixels adjacents qui présentent des caractéristiques spectrales et spatiales similaires. Vous pouvez contrôler la quantité de lissage spatial et spectral pour définir des entités qui vous intéressent.",
		s1RadiometricCalibrationName: "Calibrage radiométrique Sentinel-1",
		s1RadiometricCalibrationSnip: "Effectue différents types de calibrage radiométrique sur les données de Sentinel-1.",
		s1RadiometricCalibrationDesc: "Cette fonction raster effectue trois calibrages différents pour les jeux de données Sentinel 1, notamment Bêta zéro et Gamma, et génère le jeu de données calibré. L’objectif du calibrage SAR est de fournir l’imagerie dans laquelle les valeurs de pixels peuvent être directement associées à la rétrodiffusion radar de la scène. Bien que l’imagerie SAR non calibrée soit suffisante en termes de qualité, les images SAR calibrées sont essentielles à l’utilisation quantitative des données SAR.<div><br/>Le traitement standard des données SAR, qui produit des images de niveau 1, n’inclut pas les corrections radiométriques et il demeure une déformation radiométrique significative. Il est par conséquent nécessaire d’appliquer une correction radiométrique aux images SAR afin que les valeurs de pixels des images représentent réellement la rétrodiffusion radar de la surface réfléchissante. La correction radiométrique est également nécessaire pour comparer des images SAR acquises avec différents capteurs, ou acquises à partir du même capteur mais à différents moments, dans différents modes ou traitées par différents capteurs.</div>",
		s1ThermalNoiseRemovalName: "Suppression de bruit thermique Sentinel-1",
		s1ThermalNoiseRemovalSnip: "Supprime le bruit thermique des données de Sentinel-1.",
		s1ThermalNoiseRemovalDesc: "La correction de bruit thermique peut être appliquée aux produits SLC (Single Look Complex) Sentinel-1 de niveau 1 et GRD (Ground Range Detection) de niveau 1 n’ayant pas déjà été corrigés. L’opérateur peut également éliminer cette correction en fonction des annotations de produit afin de réintroduire le signal de bruit ayant été supprimé pour générer le produit d’origine. Les annotations de produit seront mises à jour conformément pour permettre une nouvelle application de la correction. ",
		setNullName: "SetNull",
		setNullSnip: "L’outil SetNull définit les emplacements de cellule identifiés sur la valeur NoData en fonction des critères indiqués. Il renvoie une valeur NoData si une évaluation conditionnelle est vraie et renvoie la valeur spécifiée par un autre raster si celle-ci est fausse.",
		setNullDesc: "La fonction SetNull définit les pixels identifiés sur la valeur NoData en fonction des critères indiqués. Elle renvoie une valeur NoData si une évaluation conditionnelle est vraie (1) et renvoie la valeur spécifiée dans le raster faux si une évaluation conditionnelle est fausse (0). Ce critère est spécifié par la sortie d’une fonction mathématique logique, qui sera le raster en entrée.",
		shadedReliefName: "Relief ombré",
		shadedReliefSnip: "Crée une représentation 3D multicanal, codée par couleur, de la surface, en tenant compte de la position relative du soleil pour ombrer l'image.",
		shadedReliefDesc: "La fonction Relief ombré crée une représentation 3D en couleur du terrain en combinant les images des méthodes Précodé par altitude et Ombrage. Cette fonction utilise les propriétés d'altitude et d'azimut pour spécifier la position du soleil.<div><br/></div>",
		sinHName: "SinH",
		sinHSnip: "Calcule le sinus hyperbolique des cellules d’un raster.",
		sinHDesc: "La fonction calcule le sinus hyperbolique des pixels dans un raster.",
		sinName: "Sin",
		sinSnip: "Calcule le sinus des cellules d’un raster.",
		sinDesc: "La fonction calcule le sinus des pixels dans un raster.",
		slopeName: "Pente",
		slopeSnip: "Calcule le taux de modification entre la valeur d'un pixel et des pixels adjacents.",
		slopeDesc: "Cette fonction raster calcule la pente, qui correspond au taux de changement d’altitude pour chaque cellule du modèle numérique de terrain (MNE). C'est la première dérivée d'un DME.<div><br/>Cette fonction utilise une fonction atan() accélérée. Elle est six fois plus rapide, et l'erreur d'approximation est toujours inférieure à 0,3 degré.</div>",
		speckleName: "Granularité",
		speckleSnip: "Propose des filtres destinés à réduire le bruit des jeux de données de radar à ouverture synthétique.",
		speckleDesc: "La granularité correspond au bruit haute fréquence des données radar. Les images générées par les systèmes radar d’ouverture synthétique (SAR, Synthetic Aperture Radar) sont fréquemment sujettes aux effets de granularité en raison du traitement des signaux dispersés et de l’interférence des ondes électromagnétiques dispersées à partir des surfaces ou des objets. Cette fonction Granularité filtre le jeu de données radar pour atténuer le bruit tout en conservant les tronçons ou les entités pointues de l’image.",
		spectralConversionName: "Conversion spectrale",
		spectralConversionSnip: "Applique une matrice à une image multicanal.",
		spectralConversionDesc: "La fonction Conversion spectrale applique une matrice à une image multicanal pour affecter les couleurs de la sortie.<div><br/>Certains capteurs ne collectent pas les canaux bleus en raison de la faiblesse du rapport signal/bruit. Elle permet, par exemple, de convertir une image infrarouge de couleurs fausses en une image de couleurs pseudo naturelles.</div>",
		squareRootName: "Racine carrée",
		squareRootSnip: "Calcule la racine carrée des valeurs de cellules d’un raster.",
		squareRootDesc: "La fonction Racine carrée calcule la racine carrée des valeurs de pixels dans un raster.",
		squareName: "Carré",
		squareSnip: "Calcule le carré des valeurs de cellule d’un raster.",
		squareDesc: "La fonction Carré calcule le carré des valeurs de pixels dans un raster.",
		statisticsHistogramName: "Statistiques et histogramme",
		statisticsHistogramSnip: "Définit ou associe des statistiques et un histogramme.",
		statisticsHistogramDesc: "La fonction Statistiques et histogramme permet de définir les statistiques et l'histogramme d'un raster. Vous pouvez insérer cette fonction à la fin de la chaîne de fonctions pour décrire les statistiques et l’histogramme d’un modèle de fonction raster. Cela peut s'avérer nécessaire pour contrôler l'affichage par défaut du résultat du traitement, plus particulièrement lorsque vous définissez une chaîne de fonctions contenant de nombreuses fonctions.<div><br/>Vous pouvez définir les statistiques en saisissant les valeurs ou en les important d’un jeu de données raster ou d’un fichier XML. Les histogrammes peuvent uniquement être définis en important un fichier.</div>",
		statisticsName: "Statistiques",
		statisticsSnip: "Calcule les statistiques focales de chaque pixel d’une image en fonction d’un voisinage focal défini.",
		statisticsDesc: "La fonction Statistiques calcule des statistiques focales pour chaque pixel d'une image, en fonction d'un voisinage focal défini.<div><br/>La fonction Statistique peut être utilisée pour remplir les lignes supprimées dans une image. Les lignes supprimées sont souvent dues à des problèmes de capteur où les données ne sont pas collectées. Cela s’est déjà produit avec le capteur Enhanced Thematic Mapper Plus (ETM+) de Landsat 7, par exemple. Ces données manquantes engendrent des problèmes d'analyse mais aussi d'affichage des images. Il semble qu'il y ait peu de solutions lorsque vous utilisez des images pour analyse ; toutefois, une image superposée peut servir à remplacer le contenu manquant. Vous pouvez procéder de la même manière si l'image est utilisée à des fins de visualisation. Cependant, comme vous ne disposez pas toujours d'une image supplémentaire pour remplir le contenu manquant, vous devez l'obtenir à partir des données existantes.</div>",
		streamLinkName: "Liaison d’écoulement",
		streamLinkSnip: "Attribue des valeurs uniques aux sections d'un réseau linéaire raster entre les intersections.",
		streamLinkDesc: "La fonction globale Liaison d’écoulement attribue des valeurs uniques aux sections d’un réseau linéaire raster entre les intersections.<div><br/>Les liaisons sont des sections d’un canal d’écoulement reliant deux jonctions successives, une jonction et l’orifice ou une jonction et la ligne de partage des eaux. En hydrologie, ces segments de cours d’eau se nomment des sections. Une jonction est liée à un point d’écoulement et permet de délimiter un bassin versant ou un sous-bassin de drainage.</div>",
		stretchName: "Étirer",
		stretchSnip: "Améliore une image en ajustant la plage des valeurs affichées. Cela ne modifie en rien les valeurs de pixels sous-jacentes. Si la valeur d’un pixel ne figure pas dans la plage spécifiée, il apparaît comme la valeur minimale ou maximale.",
		stretchDesc: "La fonction Étirer améliore une image en changeant ses propriétés, telles que la luminosité, le contraste et la valeur gamma par l’intermédiaire de différents types d’étirement. Cette fonction utilise les statistiques des rasters dans le jeu de données mosaïque. Par conséquent, si vous utilisez cette fonction, vous devez vous assurer que les statistiques ont été calculées.<div><br/>Le type d’étirement définit un étirement de l’histogramme à appliquer aux rasters pour améliorer leur apparence. L'étirement améliore l'apparence des données en répartissant les valeurs de pixel le long d'un histogramme à partir des valeurs maximale et minimale définies par leur profondeur de couleur. </div>",
		swathName: "Envelopper",
		swathSnip: "Interpole à partir de grilles irrégulières ou de données d'enveloppe.",
		swathDesc: "Certains jeux de données netCDF ou HDF stockent leur géolocalisation sous forme de tableaux irrégulièrement espacés. Lors de l’ajout de ces jeux de données à un jeu de données mosaïque, la fonction Envelopper utilise les données quadrillées de façon irrégulière pour les rééchantillonner afin que chaque pixel soit carré et de taille uniforme.<div><br/>Lorsque vous ajoutez les variables d’un fichier netCDF ou HDF à un jeu de données mosaïque, la fonction vérifie automatiquement si les données sont organisées de façon régulière. Si ce n'est pas le cas, la fonction Envelopper est appliquée automatiquement pour convertir le raster irrégulier en points, puis en raster quadrillé régulièrement. Vous pouvez changer la méthode d'interpolation et la taille des cellules utilisées dans la fonction raster Envelopper. Pour les données raster régulièrement espacées, aucune interpolation n'est appliquée et les données sont lues telles quelles.</div>",
		tanHName: "TanH",
		tanHSnip: "Calcule la tangente hyperbolique des cellules d'un raster.",
		tanHDesc: "La fonction calcule la tangente hyperbolique des pixels dans un raster.",
		tanName: "Tan",
		tanSnip: "Calcule la tangente des cellules d'un raster.",
		tanDesc: "La fonction calcule la tangente des pixels dans un raster. ",
		tasseledCapName: "Tasseled Cap (Kauth-Thomas)",
		tasseledCapSnip: "Calcule les niveaux de végétation, d’humidité et de luminosité. Cette technique s’appuie sur des coefficients qui doivent être calculés spécifiquement pour un capteur.",
		tasseledCapDesc: "La transformation Tasseled Cap (Kauth-Thomas) est conçue pour analyser et apparier les modifications liées au développement urbain et à la phénoménologie de la végétation détectées par différents capteurs satellitaires. On parle de transformation Tasseled Cap pour faire référence à la forme que prend la répartition graphique des données. Cette transformation a fourni la raison d'être des motifs détectés dans les données Landsat MSS des champs agricoles, en tant que fonction du cycle de vie d'une culture. La tendance principale est la suivante : lors de la croissance d’une plante, du stade de graine jusqu’à sa maturité, on note une augmentation importante des infrarouges proches et une diminution de la réflectance des infrarouges, selon la couleur du sol.<div><br/>L’utilité de cette transformation ne se limite plus à la surveillance des cultures ; on l’applique désormais à l’analyse et à la cartographie de la végétation afin qu’il soit possible de prendre en charge diverses applications (foresterie, gestion des sites industriels, cartographie et gestion de l’écosystème, création d’inventaire et surveillance du stockage de carbone et des crédits, développement urbain, etc.). Elle a également permis d’étendre la prise en charge, qui inclut Landsat MSS ainsi que d’autres systèmes satellite connus, comme les capteurs multispectraux Landsat TM, Landsat ETM+, Landsat 8, IKONOS, QuickBird, WorldView-2 et RapidEye.</div>",
		timesName: "Multiplier",
		timesSnip: "Multiplie les valeurs de deux rasters cellule par cellule.",
		timesDesc: "La fonction Multiplication multiplie la valeur de deux rasters, pixel par pixel.",
		transposeBitsName: "Transposer des bits",
		transposeBitsSnip: "Décompresse les bits du pixel en entrée et les apparie à des bits spécifiés dans le pixel en sortie. L’objectif de cette fonction est de manipuler les bits provenant de certaines entrées, telles que les produits de canaux de qualité Landsat 8.",
		transposeBitsDesc: "La fonction Transposer des bits décompresse les bits du pixel en entrée et les apparie à des bits spécifiés dans le pixel en sortie. L'objectif de cette fonction est de manipuler les bits provenant de certaine entrées, telles que les produits de canaux de qualité Landsat 8.",
		unitConversionName: "Conversion des unités",
		unitConversionSnip: "Modifie les valeurs d'une unité de mesure en une autre.",
		unitConversionDesc: "Cette fonction convertit les pixels d’une unité en une autre. Elle prend en charge la conversion de distances, vitesses et températures.",
		vectorFieldName: "Champ vectoriel",
		vectorFieldSnip: "Affiche les jeux de données avec la grandeur (u) et la direction (v) représentées sous forme de flèches, où la grandeur est représentée par la taille et la direction par l'angle de la flèche.",
		vectorFieldDesc: "La fonction Champ vectoriel permet d’intégrer et de convertir deux rasters dans un raster à deux canaux dont le type de données est Magnitude-Direction ou U-V.<div><br/>La valeur U est parfois appelée vitesse zonale et la valeur V, vitesse méridionale.</div>",
		viewshed2Name: "Viewshed (Champ de vision)",
		viewshed2Snip: "Détermine les emplacements de surfaces raster visibles pour un ensemble d'entités d'observation, à l'aide de méthodes géodésiques.",
		viewshed2Desc: "La fonction Champ de vision détermine les emplacements des surfaces raster visibles pour un ensemble d’entités d’observation, à l’aide de méthodes géodésiques.<div><br/>La visibilité du centre de chaque pixel est déterminée par un test de ligne de visée entre la cible et chaque point d’observation. Si un point d'observation peut voir la cible au centre du pixel, celui-ci est considéré comme visible. Cet outil tient toujours compte de la courbure de la Terre pour déterminer la visibilité.</div>",
		watershedName: "Bassins versants",
		watershedSnip: "Détermine la surface de captation au-dessus d’un ensemble de cellules dans un raster.",
		watershedDesc: "La fonction globale Bassins versants détermine la surface de captation au-dessus d’un ensemble de cellules dans un raster. Les bassins versants sont délimités à partir d’un raster de direction de flux qui identifie la direction de flux à partir de chaque pixel.",
		weightedOverlayName: "Superposition pondérée",
		weightedOverlaySnip: "Superpose plusieurs rasters en utilisant une échelle de mesure commune et les pondère en fonction de leur importance.",
		weightedOverlayDesc: "Cette fonction permet de superposer plusieurs rasters à l'aide d’une échelle de mesure commune et de les pondérer selon leur importance.",
		weightedSumName: "Somme pondérée",
		weightedSumSnip: "Pondère et ajoute une matrice de rasters, cellule par cellule.",
		weightedSumDesc: "La fonction Somme pondérée vous permet de superposer plusieurs rasters, en multipliant chacun par sa pondération donnée et en les additionnant.",
		windchillName: "Température ressentie",
		windchillSnip: "Combine la température de l'air ambiant et la vitesse du vent pour calculer le facteur de température ressentie.",
		windchillDesc: "La fonction de température ressentie est utile pour identifier les conditions hivernales dangereuses qui, selon la durée d’exposition aux éléments, peuvent entraîner des engelures ou même une hypothermie. La température ressentie mesure le niveau de froid ressenti par un individu lorsque le vent est pris en compte avec des températures déjà basses. Plus la vitesse du vent est élevée, plus la chaleur corporelle baisse rapidement et plus le froid est ressenti.",
		zonalRemapName: "Classification zonale",
		zonalRemapSnip: "Classez les pixels dans un raster en fonction des zones définies dans un autre raster et de l'appariement des valeurs dépendant des zones, qui est défini dans une table.",
		zonalRemapDesc: "Cette fonction permet de classer les pixels dans un raster en fonction des zones définies dans un autre raster et de l'appariement des valeurs dépendant des zones, qui est défini dans une table.",
		zonalStatisticsName: "Statistiques zonales",
		zonalStatisticsSnip: "Calcule les statistiques des valeurs d’un raster dans chaque zone d’un autre jeu de données.",
		zonalStatisticsDesc: "La fonction calcule des statistiques sur les valeurs d’un raster dans les zones d’un autre jeu de données. Une zone est définie comme l’ensemble des surfaces en entrée ayant la même valeur. Ces surfaces ne sont pas nécessairement contiguës. Lorsque la zone et la valeur en entrée sont toutes les deux des rasters de même résolution, elles sont utilisées directement. Si les résolutions sont différentes, un rééchantillonnage interne est appliqué pour les faire correspondre avant que l'opération zonale soit effectuée.",
		flowLengthName: "Longueur de l'écoulement",
		flowLengthSnip: "Permet de calculer la distance en amont ou en aval, ou la distance pondérée, le long du chemin de flux pour chaque cellule.",
		flowLengthDesc: "Il s’agit d’une fonction raster globale. Cette fonction crée une couche raster de distance en amont ou en aval, ou de distance pondérée, le long du chemin de flux pour chaque cellule.<div><br/>La fonction Longueur d’écoulement permet essentiellement de calculer la longueur du chemin de flux dans un bassin donné. Cette mesure permet souvent de calculer le temps de concentration d'un bassin. Ceci est effectué à l’aide de l’option Upstream (En amont). Vous pouvez également employer cette fonction pour créer des diagrammes représentant les distances-surfaces relatives aux précipitations et aux écoulements prévisionnels, à l’aide d’un raster de pondération sous la forme d’une impédance en rapport avec le mouvement en aval.</div>",
		streamOrderName: "Ordre d'écoulement",
		streamOrderSnip: "Attribue un ordre numérique aux segments d’un raster représentant les branches d’un réseau linéaire",
		streamOrderDesc: "Il s’agit d’une fonction raster globale. Cette fonction crée une couche raster qui attribue un ordre numérique aux segments d’un raster représentant les branches d’un réseau linéaire.<div><br/>La sortie de l’outil Ordre d’écoulement sera de meilleure qualité si la couche de raster d’écoulement en entrée et la couche de raster de direction de flux en entrée sont dérivées de la même surface. Si le raster d'écoulement est dérivé d'un jeu de données de flux rasterisé, la sortie peut ne pas être utilisable du fait que, cellule par cellule, la direction ne correspondra pas à la localisation des cellules de flux. Les résultats obtenus avec la fonction Accumulation de flux peuvent être utilisés pour créer un raster de réseau hydrographique en fixant un seuil pour sélectionner les cellules avec une accumulation de flux élevée. Par exemple, les cellules dans lesquelles plus de 100 cellules s’écoulent sont utilisées pour définir le réseau hydrographique. Utilisez la fonction Con ou SetNull pour créer un raster de réseau hydrographique où des valeurs d’accumulation de flux de 100 ou plus passent à 1, et le reste est mis à l’arrière-plan (NoData). Le réseau hydrographique obtenu peut être utilisé dans l’outil Ordre d’écoulement. Cette fonction prend uniquement en charge une couche raster de direction de flux en entrée D8. Les directions de flux D8 peuvent être créées à l’aide de la fonction Direction de flux et exécutées avec la direction de flux par défaut de type D8.</div>",
		snapPourPointName: "Capture des points d’écoulement",
		snapPourPointSnip: "Capture les points d’écoulement dans la cellule d’accumulation de flux la plus élevée, selon une distance donnée",
		snapPourPointDesc: "Il s’agit d’une fonction raster globale. Cette fonction capture les points d’écoulement dans la cellule d’accumulation de flux la plus élevée, selon une distance donnée.<div><br/>L’outil Capture des points d’écoulement permet d’établir une sélection de points d’accumulation de flux élevée lorsque vous délimitez des bassins de drainage à l’aide de l’outil Bassins versants. L’outil Capture des points d’écoulement recherche, au sein d’un périmètre de capture autour des points d’écoulement spécifiés, la cellule qui présente l’accumulation de flux la plus élevée et déplace le point d’écoulement à cet endroit. La sortie est une couche raster d’entiers lorsque les localisations de point d’écoulement originales ont été accrochées aux lieux d’accumulation de flux la plus élevée.</div>",
		sinkName: "Cuvettes",
		sinkSnip: "Crée un raster identifiant toutes les cuvettes ou zones de drainage interne",
		sinkDesc: "Il s’agit d’une fonction raster globale. Cette fonction crée une couche raster identifiant toutes les cuvettes ou zones de drainage interne. Une cuvette est une cellule ou un ensemble de cellules limitrophes dont la direction de flux ne peut pas se voir attribuer l'une des huit valeurs valides dans un raster de direction de flux. Cela peut survenir lorsque toutes les cellules voisines sont plus élevées que la cellule de traitement ou lorsque deux cellules s'écoulent en boucle l’une dans l’autre.<div><br/>La fonction Cuvette prend uniquement en charge une couche raster de direction de flux en entrée D8. Les directions de flux D8 peuvent être créées à l’aide de la fonction Direction de flux et exécutées avec le type de direction de flux par défaut D8. La sortie de la fonction Cuvette est un raster d’entiers dans lequel chaque cuvette se voit attribuer une valeur unique. Ces valeurs uniques ont une plage comprise entre un et le nombre total de cuvettes. Par exemple, si le nombre total de cuvettes est 1 000, la plage de valeurs uniques est comprise entre 1 et 1 000.</div>",
		aggregateName: "Agréger",
		aggregateSnip: "Génère une version du raster à une résolution inférieure.",
		aggregateDesc: "L’outil Agréger rééchantillonne un raster en entrée avec une résolution plus grossière s’appuyant sur une stratégie d’agrégation spécifique. Chaque cellule en sortie contient la somme, le minimum, le maximum, la moyenne ou la médiane des cellules en entrée qui figurent dans l'étendue de cette cellule.<div><br/>Vous pouvez spécifiez le facteur de multiplication de la taille de cellule du raster en entrée. Par exemple, une valeur de facteur de cellule de 3 entraîne une taille de cellule en sortie trois fois supérieure à celle du raster en entrée. Vous pouvez définir la manière de traiter l’étendue de la sortie si le nombre de lignes ou de colonnes en entrée n’est pas un multiple du facteur de cellule. Par défaut, les limites supérieure et droite seront repoussées pour couvrir une étendue spatiale plus large que celle du raster en entrée de sorte que toutes les cellules en entrée soient traitées. Les limites supérieure et de droite peuvent également être rapprochées pour couvrir une étendue plus réduite, de sorte que le nombre de lignes ou de colonnes traitées corresponde exactement à un multiple du facteur de cellule. Vous pouvez définir la manière dont les cellules NoData doivent être traitées par le calcul d’agrégation. Le mécanisme par défaut est le suivant : les cellules NoData en entrée comprises dans l’étendue spatiale d’une cellule plus grande dans le raster en sortie seront ignorées lors de la détermination de la valeur de cette cellule en sortie. Vous pouvez également préciser que si une seule cellule NoData est incluse dans l’étendue spatiale d’une cellule en sortie, la valeur de cette cellule dans le raster en sortie est NoData.</div>",
		ccdcName: "Analyse CCDC",
		ccdcSnip: "Évalue les modifications dans les valeurs de pixels au fil du temps à l’aide de l’algorithme CCDC (Continuous Change Detection and Classification) et génère les résultats du modèle.",
		ccdcDesc: "La fonction CCDC évalue les modifications dans les valeurs de pixels au fil du temps à l’aide de l’algorithme CCDC (Continuous Change Detection and Classification) et génère un raster multidimensionnel contenant les résultats du modèle. Elle est prise en charge uniquement avec la fonction de détection des modifications à l’aide du raster d’analyse des changements dans un modèle de fonction raster. Pour produire un raster en sortie, connectez la fonction d’analyse CCDC à la fonction de détection des modifications à l’aide de l’analyse des changements, enregistrez un modèle de fonction raster et exécutez l’analyse raster avec le modèle de fonction.<div><br/>Cette fonction utilise l’algorithme CCDC (Continuous Change Detection and Classification) pour évaluer les modifications dans les valeurs de pixels au fil du temps pour une pile d’images. Dans une série chronologique d’images optiques ou dérivées (NDVI, par exemple), les valeurs de pixels peuvent fluctuer pour diverses raisons : 1. Modifications saisonnières -- Les modifications des valeurs de pixels reflètent les modifications de la végétation liées à la variabilité saisonnière des températures et des précipitations. Dans l’hémisphère Nord, par exemple, il faut s’attendre à observer une densité de végétation verte plus forte pendant l’été par rapport à l’hiver ; 2. Modifications graduelles -- Les modifications des valeurs de pixels reflètent les tendances de la végétation ou de la surface de l’eau liées à la variabilité climatique ou aux pratiques à long terme de la gestion des sols. Ainsi, la superficie d’un sol nu peut augmenter progressivement en raison du déclin à long terme des précipitations ; et 3. Changements abrupts -- Les modifications des valeurs de pixels reflètent des changements de l’occupation du sol liés à des événements soudains, tels que la déforestation, le développement urbain, les catastrophes naturelles, etc. L’algorithme CCDC identifie les trois types de modifications dans le but principal d’identifier des changements abrupts. La régression harmonique et les modèles de tendance sont ajustés aux données pour estimer les modifications saisonnières et les modifications graduelles tandis que les déviations soudaines par rapport aux modèles de tendance sont des indications d’un changement abrupt.<div><br/>À l’origine, l’algorithme CCDC a été conçu pour les données Landsat TM, Landsat ETM+ et Landsat OLI relatives à la réflectance des surfaces ou à la température de brillance. Toutefois, la fonction de détection des modifications à l’aide du raster d’analyse des changements conjuguée à cette fonction détecte les modifications d’images multicanaux à partir de n’importe quel capteur pris en charge, ainsi que les images dérivées monocanales telles que les indices de canaux. Par exemple, vous pouvez effectuer une détection continue des modifications sur un raster d’indice de végétation par différence normalisée (NDVI), car les changements abrupts dans le NDVI peuvent être le signe d’une déforestation.</div>",
		computeChangeName: "Calculer les modifications",
		computeChangeSnip: "Calcule la différence entre deux jeux de données raster catégoriels ou continus.",
		computeChangeDesc: "La fonction Calculer les modifications permet d’énumérer les différences entre deux rasters classifiés en matière d’analyse des modifications de l’occupation du sol ; il permet également d’examiner les modifications entre deux rasters continus monocanaux tels que l’élévation, la température, le couvert forestier, etc.",
		detectChangeName: "Détecter les modifications à l’aide de l’analyse des changements",
		detectChangeSnip: "Génère une couche raster contenant des informations sur les modifications de pixels à l’aide du raster d’analyse des changements en sortie.",
		detectChangeDesc: "<div>La fonction Détecter les changements à l’aide de l’analyse des changements génère une couche raster contenant des informations relatives aux dates de changement des pixels avec le raster d’analyse des changements. Le raster d’analyse des changements doit être généré par l’outil Analyser les modifications avec l’algorithme CCDC ou l’outil Analyser les modifications avec l’algorithme LandTrendr, ou avec la fonction raster Analyse CCDC ou la fonction raster Analyse LandTrendr.</div><br><div>Cette fonction raster peut être associée à la fonction raster Analyse CCDC ou à la fonction raster Analyse LandTrendr dans un modèle de fonction raster. Pour produire une sortie raster permanente, connectez la sortie de la fonction Analyse CCDC ou Analyse LandTrendr à la fonction Détecter les modifications à l’aide du raster d’analyse des changements, enregistrez-les dans un modèle de fonction raster, puis exécutez l’analyse raster avec le modèle.</div><br><div>Le paramètre <strong>Type de changement</strong> indique les informations générées. Les informations sont extraites du raster d’analyse des changements. Lorsque vous exécutez cette fonction sur la sortie de la fonction/l’outil CCDC, vous avez le choix entre les options suivantes :</div><ul><li><strong>Heure du changement le plus récent</strong> : date et heure les plus récentes auxquelles un pixel a été marqué comme modifié.</li><li><strong>Heure du premier changement</strong> : date et heure les plus anciennes auxquelles un pixel a été marqué comme modifié.</li><li><strong>Heure du plus grand changement</strong> : date et heure auxquelles le changement calculé était le plus important pour un pixel.</li><li> <strong>Nombre de changements</strong> : nombre total de fois où le pixel a été modifié.</li></ul><div>Lorsque vous exécutez cette fonction sur la sortie de la fonction/l’outil LandTrendr, les options suivantes supplémentaires sont disponibles :</div><ul><li><strong>Heure du plus long changement</strong> : date à laquelle un pixel a été marqué comme modifié, au début ou à la fin de la plus longue période de changement.</li><li><strong>Heure du plus court changement</strong> : date à laquelle un pixel a été marqué comme modifié, au début ou à la fin de la plus courte période de changement.</li><li><strong>Heure du changement le plus rapide</strong> : date à laquelle un pixel a été marqué comme modifié, au début ou à la fin de la période de changement la plus rapide.</li><li><strong>Heure du changement le plus lent</strong> : date à laquelle un pixel a été marqué comme modifié, au début ou à la fin de la période de changement la plus lente.</li></ul><div>Le raster en sortie est un raster multicanal dans lequel chaque canal contient des informations sur les changements selon le type de changement sélectionné et le nombre maximal de changements spécifié. Par exemple, si <strong>Type de changement</strong> est défini sur <strong>Heure du premier changement</strong> et si <strong>Nombre maximal de changements</strong> est défini sur 2, la fonction calcule les deux dates les plus anciennes du changement tout au long de la série chronologique pour chaque pixel. Le résultat est un raster dans lequel le premier canal contient les dates du premier changement par pixel et le deuxième canal contient les dates du deuxième changement par pixel.</div><br><div>Lors de l’application de cette fonction sur la sortie des outils LandTrendr, vous pouvez choisir d’extraire la date marquant le début d’un changement ou la fin d’un changement à l’aide du paramètre <strong>Date de segment</strong>. Par exemple, pour comprendre comment a débuté le plus récent changement dans la série chronologique, définissez <strong>Type de changement</strong> sur <strong>Heure du changement le plus récent</strong> et <strong>Date du segment</strong> sur <strong>Début du segment</strong>.</div><br><div>Utilisez les paramètres de filtrage suivants pour extraire d’autres dates de changement spécifiques de votre raster d’analyse des changements :</div><ul><li><strong>Filtrer par année</strong> : identifiez les changements survenus au cours d’une période spécifique ; par exemple, lorsque vous recherchez les changements survenus dans un paysage au cours de 5 années de sécheresse.</li><li><strong>Filtrer par durée</strong> : identifiez les changements survenus sur un nombre d’années spécifique ; par exemple, lorsque vous recherchez uniquement les changements soudains survenus sur un ou deux ans. Vous pouvez calculer la durée qui vous intéresse à l’aide de la formule suivante : <strong>année de fin - année de début +1</strong>. Si la série chronologique comporte des discontinuités, elles seront incluses.</li><li><strong>Filtrer par magnitude</strong> : identifiez les changements d’une magnitude donnée ; par exemple, lorsque vous recherchez uniquement des changements importants dans l’indice de végétation NDVI. La magnitude étant une valeur absolue, les valeurs minimale et maximale ne peuvent pas être négatives. Pour spécifier le changement directionnel, utilisez le paramètre <strong>Changer de direction</strong>.</li></ul>",
		distanceAccumulationName: "Accumulation de distance",
		distanceAccumulationSnip: "Calcule la distance accumulée de chaque cellule vers les sources, pour permettre les facteurs de distance en ligne droite, distance de coût et distance de surface véritable, ainsi que les facteurs horizontaux et verticaux de coût.",
		distanceAccumulationDesc: "L’accumulation de distance calcule la distance séparant chaque emplacement de la zone d’étude vers la source la plus proche ou de moindre coût. Si seules les sources sont fournies en entrée, une distance en ligne droite est calculée vers chaque emplacement de la zone d’étude. Si les sources et les interruptions sont utilisées en entrée, l’accumulation de distance calcule la distance en ligne droite au niveau des interruptions. Pour le raster source et le raster d’interruption, la valeur d’arrière-plan doit être NoData, et les sources et les interruptions sont représentées par des valeurs de cellule valides. Zéro figure parmi les valeurs valides. <div><br/>Lorsqu’un raster de surface est spécifié en entrée, la distance de surface réelle entre les cellules est calculée. Pour effectuer une analyse de coût à l’aide de la fonction Accumulation de distance, une surface de coût est nécessaire. Si une surface de coût est indiquée, le résultat est un raster de distance de coût cumulée. Lorsque les facteurs horizontaux et verticaux sont spécifiés, la direction considérée comme un coût est cumulée. Quatre caractéristiques de la source peuvent être utilisées. Ces caractéristiques qui peuvent être soit la source, soit les sujets s’éloignant de la source sont contrôlées par des paramètres spécifiques : 1. Accumulation initiale : définit le coût initial avant le début du déplacement. 2. Accumulation maximale : spécifie le coût qu’une source peut cumuler avant d’atteindre sa limite. 3. Multiplicateur à appliquer aux coûts : spécifie le mode de déplacement ou la magnitude à la source. 4. Sens de déplacement : identifie si le sujet part d’une source et se déplace vers des emplacements non source ou s’il part des emplacements non source et retourne vers une source.<div><br/>Par défaut, le résultat de l’accumulation de distance est un canal unique qui correspond au raster d’accumulation de distance. Toutefois, il est possible de créer un deuxième canal, le canal de direction arrière. Ce canal indique, pour chaque emplacement figurant dans la zone d’étude, la direction à prendre pour parvenir à la source de moindre coût. Les deux canaux seront nécessaires pour déterminer les chemins optimaux au sein de la zone d’étude. Pour générer un chemin, utilisez d’abord la fonction Extraire les canaux pour extraire le raster d’accumulation de distance et le raster de direction arrière. Utilisez ces couches en entrée de la fonction Chemin de moindre coût. Dans la fonction, utilisez le raster d’accumulation de distance comme entrée du raster de distance de coût et le raster de direction arrière comme entrée du raster d’antécédence de coût.</div>",
		distanceAllocationName: "Allocation de distance",
		distanceAllocationSnip: "Calcule l’allocation de distance de chaque cellule vers les sources fournies en fonction des facteurs de distance en ligne droite, distance de coût et distance de surface véritable, ainsi que les facteurs horizontaux et verticaux de coût.",
		distanceAllocationDesc: "L’allocation de distance calcule la source à laquelle chaque emplacement de la zone d’étude est alloué. Si seules les sources sont fournies en entrée, les emplacements sont alloués selon la distance en ligne droite vers la source la plus proche. Si les sources et les interruptions sont utilisées en entrée, l’allocation de distance calcule la distance en ligne droite au niveau des interruptions pour déterminer la source à laquelle l’emplacement est alloué. Pour le raster source et le raster d’interruption, la valeur d’arrière-plan doit être NoData, et les sources et les interruptions sont représentées par des valeurs de cellule valides. Zéro figure parmi les valeurs valides.<div><br/>Pour effectuer une analyse de coût à l’aide de la fonction Allocation de distance, une surface de coût est nécessaire. Si une surface de coût est spécifiée, le résultat désigne un raster d’allocation basé sur un coût cumulé et non une distance en ligne droite. Lorsque les facteurs horizontaux et verticaux sont spécifiés, la direction considérée comme un coût est cumulée. Lorsqu’un raster de surface est spécifié en entrée, la distance de surface réelle couverte par le passage entre les cellules est calculée au moment où l’allocation est déterminée. Quatre caractéristiques de la source peuvent être utilisées. Ces caractéristiques qui peuvent être soit la source, soit les sujets s’éloignant de la source sont contrôlées par des paramètres spécifiques : 1. Accumulation initiale : définit le coût initial avant le début du déplacement. 2. Accumulation maximale : spécifie le coût qu’une source peut cumuler avant d’atteindre sa limite. 3. Multiplicateur à appliquer aux coûts : spécifie le mode de déplacement ou la magnitude à la source. 4. Sens de déplacement : identifie si le sujet part d’une source et se déplace vers des emplacements non source ou s’il part des emplacements non source et retourne vers une source.<div><br/>Par défaut, le résultat de l’allocation de distance est un canal unique qui correspond au raster d’allocation de distance. Cocher l’option booléenne Generate source row and column as additional bands in output (Générer une ligne et une colonne source en tant que canaux supplémentaires en sortie) produira un raster multicanal composé de trois canaux. Le premier canal est le canal d’allocation de distance, le second contient un index de lignes, et le troisième canal un index de colonnes. Ces index identifient l’emplacement de la cellule source qui se trouve à la distance de plus faible coût cumulé. L’index de lignes source et l’index de colonnes source peuvent être utilisés ensemble pour réaliser une cartographie d’intensité. Effectuez une requête sur un emplacement de votre zone d’étude à travers les canaux deux et trois, pour connaître la ligne et la colonne de la source de moindre coût pour cet emplacement.</div>",
		eucBackDirectionName: "Direction arrière euclidienne",
		eucBackDirectionSnip: "Calcule pour chaque cellule la direction (en degrés) vers la cellule voisine le long du chemin le plus court pour revenir à la source la plus proche en évitant les interruptions.",
		eucBackDirectionDesc: "La fonction Direction arrière euclidienne génère un raster continu à virgule flottante représentant la direction en degrés vers la source la plus proche tout en évitant les interruptions, le cas échéant.<div><br/>Les entrées de la fonction Direction arrière euclidienne sont la source dans laquelle la direction sera calculée. Un raster représentant les interruptions dans la zone d’étude est une entrée facultative. Pour le raster source et le raster d’interruption, la valeur d’arrière-plan doit être NoData, et les sources et les interruptions sont représentées par des valeurs valides. Zéro figure parmi les valeurs valides. Par défaut, le calcul effectue le traitement jusqu’à l’étendue combinée des sources et des interruptions, plus 2 lignes et colonnes. Si l’analyse est seulement nécessaire au sein d’une distance spécifiée à partir des sources, le paramètre Distance maximale peut être utilisé. La fonction Direction arrière euclidienne prend en charge une méthode planaire et une méthode géodésique lors du calcul. Le calcul de la méthode planaire est effectué sur une surface plane projetée à l’aide d’un système de coordonnées cartésiennes 2D. Le calcul de la méthode géodésique est effectué sur l’ellipsoïde. En d’autres termes, quelle que soit la projection en entrée ou en sortie, les résultats ne changent pas.<div><br/>Les résultats de la fonction Direction arrière euclidienne peuvent être utilisés avec les résultats de la fonction Distance euclidienne afin de déterminer les chemins les plus courts à partir des emplacements qui se trouvent dans la zone d’étude jusqu’à la source. Les résultats de la direction arrière euclidienne et de la distance euclidienne peuvent être utilisés dans la fonction Chemin de moindre coût ainsi que les destinations pour déterminer les chemins les plus courts.</div>",
		expandName: "Étendre",
		expandSnip: "Étend d’un nombre défini de cellules les zones sélectionnées d’un raster par zones.",
		expandDesc: "Avec la fonction globale Développer, vous pouvez généraliser ou simplifier les rasters en agrandissant des zones particulières. Vous pouvez également contrôler le niveau de généralisation qui aura lieu.<div><br/>La taille des zones sélectionnées augmente en se développant dans d’autres zones. En théorie, les valeurs de zone sélectionnées peuvent être vues comme des zones de premier plan, les autres valeurs restant des zones d’arrière-plan. Les zones de premier plan peuvent être étendues jusqu’aux zones d’arrière-plan.<div><br/>Le niveau de généralisation peut être contrôlé à l’aide du paramètre Number of Cells (Nombre de cellules). Par défaut, ce paramètre a une valeur égale à 1, ce qui signifie que les zones sélectionnées s’agrandiront du volume correspondant à la taille d’une cellule. Pour augmenter le degré de généralisation, vous pouvez spécifier une valeur supérieure pour ce paramètre. Cela revient à utiliser l’outil un nombre de fois équivalant au nombre spécifié, les résultats de l’exécution précédente formant l’entrée de l’itération suivante.</div>",
		trendAnalysisName: "Générer une tendance",
		trendAnalysisSnip: "Estime la tendance de chaque pixel selon une dimension pour une ou plusieurs variables d’un raster multidimensionnel.",
		trendAnalysisDesc: "<div>Cette fonction permet d’ajuster les données sur une courbe de tendance linéaire, harmonique ou polynomiale ou de détecter la tendance au moyen du test de Mann-Kendall ou Kendall saisonnier.</div><br><div>Le raster de tendance en sortie généré avec cette fonction sert en entrée pour la fonction <strong>Prédire à l’aide d’un raster de tendance</strong>.</div><br><div>Les tests de Mann-Kendall et Kendall saisonnier déterminent si les données présentent une tendance monotonique. Ils ne sont pas paramétriques, c’est-à-dire qu’ils ne formulent aucune hypothèse sur la distribution spécifique des données. Le test de Mann-Kendall ne considère pas une corrélation sérielle ou des effets saisonniers. Si les données ont une saisonnalité, le test de Kendall saisonnier est plus adapté.</div><br><div>Si l’outil réalise le test de Mann-Kendall ou Kendall saisonnier, la sortie est un raster à cinq bandes de type suivant :</div><ul><li>Bande 1 = Pente de Sen </li><li>Bande 2 = Valeur de p</li><li>Bande 3 = Score de Mann-Kendall (S)</li><li>Bande 4 = Variance S</li><li>Bande 4 = Variance S</li><li>Bande 5 = Score z</li></ul><div>Les sorties des tests de Mann-Kendall ou Kendall saisonnier permettent de déterminer les pixels de votre série chronologique multidimensionnelle qui présentent une tendance statistiquement significative. Vous pouvez utiliser cette information avec une analyse de tendance linéaire, harmonique ou polynomiale pour extraire les tendances significatives de vos séries temporelles. Vous générez un masque comportant les pixels avec une valeur de p significative, appliquez le masque au raster multidimensionnel et utilisez ce raster multidimensionnel masqué comme entrée de l’outil pour effectuer une analyse de tendance linéaire, harmonique ou polynomiale.</div><br><div>Il existe trois options de ligne de tendance pour ajuster une tendance aux valeurs des variables le long d’une dimension : linéaire, harmonique et polynomiale.</div><br><div>Pour l’analyse de tendance linéaire, la sortie est un raster à trois bandes du type suivant :</div><ul><li>Bande 1 = Pente</li><li>Bande 2 = Ordonnée à l’origine</li><li>Bande 3 = Racine carrée de l’erreur quadratique moyenne (EQM) ou erreur autour de la ligne de compromis</li></ul><div>Pour l’analyse de tendance polynomiale, le nombre de canaux dans la sortie dépend du degré polynomial. Un ajustement polynomial du deuxième degré génère un raster à quatre bandes de type suivant : </div><ul><li>Bande 1 = Polynomial_2</li><li>Bande 2 = Polynomial_1</li><li>Bande 3 = Polynomial_0</li><li>Bande 4 = EQM</li></ul><div>Un ajustement polynomial du troisième degré génère un raster à cinq canaux de type suivant :</div><ul><li>Bande 1 = Polynomial_3</li><li>Bande 2 = Polynomial_2</li><li>Bande 3 = Polynomial_1</li><li>Bande 4 = Polynomial_0</li><li>Bande 5 = EQM</li></ul><div>Pour l’analyse de tendance harmonique, le nombre de canaux dans la sortie dépend de la fréquence harmonique. Si la fréquence est définie sur 1, la sortie est un raster à cinq bandes de type suivant :</div><ul><li>Bande 1 = Pente</li><li>Bande 2 = Ordonnée à l’origine</li><li>Bande 3 = Harmonic_sin1</li><li>Canal 4 = Harmonic_cos1</li><li>Bande 5 = EQM</li></ul><div>Si la fréquence est définie sur 2, la sortie est un raster à sept canaux de type suivant :</div><ul><li>Bande 1 = Pente</li><li>Bande 2 = Ordonnée à l’origine</li><li>Bande 3 = Harmonic_sin1</li><li>Bande 4 = Harmonic_cos1</li><li>Bande 5 = Harmonic_sin2</li><li>Bande 6 = Harmonic_cos2</li><li>Bande 7 = EQM</li></ul><div>Le paramètre <strong>Durée du cycle</strong> pour l’analyse des tendances harmoniques est utilisé pour indiquer le nombre et la durée des cycles que vous vous attendez à voir dans vos données tout au long d’une journée ou d’une année. Si, par exemple, vous prévoyez que vos données connaissent deux cycles de variation dans l’année, la durée du cycle sera de 182,5 jours, soit 0,5 an. Si vous détenez des données de température collectées toutes les trois heures et qu’elles présentent un cycle de variation par jour, la durée du cycle correspond à 1 jour.</div><br><div>Le paramètre <strong>Fréquence</strong> pour l’analyse des tendances harmoniques est utilisé pour décrire le modèle harmonique à ajuster aux données. Si la fréquence est définie sur 1, une combinaison de tendance linéaire et de courbe harmonique de premier degré est utilisée pour ajuster le modèle. Si la fréquence est définie sur 2, une combinaison de tendance linéaire, de courbe harmonique de premier degré linéaire et de courbe harmonique de second degré est utilisée pour ajuster les données. Si la fréquence est 3, une courbe harmonique de troisième degré supplémentaire est utilisée pour modéliser les données et ainsi de suite.</div><br><div>Il est possible de générer des statistiques de qualité de l’ajustement du modèle sous forme de sorties facultatives. L’erreur quadratique moyenne (EQM), la valeur R-carré et la valeur P de pente de la tendance peuvent être calculées et symbolisées. Symbolisez la couche raster de la tendance en sortie à l’aide de la symbologie <strong>RVB</strong> et spécifiez les statistiques sous forme de canaux rouges, verts et bleus.</div><br>",
		spectralUnmixingName: "Démixage spectral linéaire",
		spectralUnmixingSnip: "Effectue une classification inférieure au pixel et calcule l’abondance fractionnelle de différents types d’occupation du sol pour les pixels individuels.",
		spectralUnmixingDesc: "La fonction Démixage spectral linéaire calcule la couverture fractionnelle pour des pixels contenant plusieurs types d’occupation du sol. Elle génère une couche multicanale dans laquelle chaque canal correspond à l’abondance fractionnelle d’une classe d’occupation du sol. Par exemple, vous pouvez l’utiliser pour procéder à la classification des occupations du sol sur une image multispectrale afin d’identifier la végétation photosynthétique, le sol nul, la végétation morte ou non photosynthétique.<div><br/>L’ordre du raster multicanal en sortie reflète l’ordre du profil spectral en entrée. Le nombre de classes ne doit pas dépasser le nombre de canaux du raster en entrée. Par exemple, vous ne pouvez pas extraire des informations sur plus de 8 classes à partir d’un raster à 8 canaux.</div>",
		multidimensionalFilterName: "Filtre multidimensionnel",
		interpolateRasterByDimensionFunctionName: "Interpoler un raster par dimension",
		interpolateRasterByDimensionFunctionSnip: "Interpole un raster multidimensionnel à des valeurs de dimension spécifiées à l’aide des tranches adjacentes.",
		interpolateRasterByDimensionFunctionDesc: "<p>Cette fonction vous permet d’estimer les valeurs en pixels d’une tranche dimensionnelle non définie dans un raster multidimensionnel. Par exemple, si un jeu de données contient la température de l’océan en surface et 100 mètres sous le niveau de la mer et que vous souhaitez estimer la température 50 mètres sous le niveau de la mer, vous pouvez utiliser cette fonction pour obtenir une estimation à cette profondeur à l’aide de la définition de la dimension Par valeurs.</p><p>Vous pouvez également sous-échantillonner un jeu de données mensuel dans un jeu de données quotidien en utilisant la définition de la dimension Par intervalle et en spécifiant la valeur 1 pour le paramètre Étape et la valeur Jours pour le paramètre Unité.</p><p>Utilisez la définition de la dimension Par raster cible pour estimer la valeur de Raster cible.</p>",
		multidimensionalFilterSnip: "Crée une couche raster à partir d’un jeu de données raster multidimensionnelles ou d’une couche raster multidimensionnelle en découpant des tranches de données le long de variables et de dimensions définies.",
		multidimensionalFilterDesc: "Le Filtre multidimensionnel crée une couche raster multimensionnelle en filtrant et extrayant un sous-ensemble de variables à partir d’un raster multimensionnel. Vous pouvez ainsi disposer d’un jeu de données multidimensionnel contenant 30 années de données de précipitations mensuelles et souhaiter extraire uniquement les données de chaque mois de janvier afin d’observer l’évolution des précipitations pour ce mois.<div><br/>Utilisez le paramètre Dimension Definition (Définition de la dimension) pour découper des tranches de dimensions à l’aide d’un intervalle, d’une valeur ou d’une plage de valeurs. Si, par exemple, vous possédez 10 ans de données relatives à la salinité des océans, recueillies mensuellement et tous les 2 mètres de profondeur jusqu’à 500 mètres, vous pouvez utiliser les différentes options de définition de la dimension pour les scénarios suivants. Scénario 1 : Extraire les données relatives à la salinité pour le mois de janvier sur la période de 10 ans. Sélectionnez By Values (Par valeurs), définissez Dimension sur StdTime et Values (Valeurs) sur January (Janvier). Scénario 2 : Découper des tranches de données relatives à la salinité sur une plage de profondeur allant de 0 à 150 mètres. Sélectionnez By Ranges (Par plages), définissez Dimension sur StdZ, Minimum Value (Valeur minimale) sur -150 et Maximum Value (Valeur maximale) sur 0. Scénario 3 : Extraire les données relatives à la salinité pour les 10 premiers jours du mois de janvier sur une période de 10 ans. Sélectionnez By Iteration (Par itération), définissez Dimension sur StdTime, définissez Start of first iteration (Début de la première itération) et End of first iteration (Fin de la première itération) sur le début et la fin correspondants de la période d’itération, définissez Step (Étape) sur 1, puis définissez Unit (Unité) sur Years (Années).</div>",
		multidimensionalRasterName: "Raster multidimensionnel",
		multidimensionalRasterSnip: "Ajoute des données multidimensionnelles à une carte sous forme de couche raster multimensionnelle.",
		multidimensionalRasterDesc: "La fonction Raster multidimensionnel ajoute des données multidimensionnelles sur une carte en tant que couche raster multidimensionnelle. Cette fonction est utile lors de l’exécution de processus d’analyse de raster à l’aide d’une chaîne de fonctions.<div><br/>Les jeux de données raster multidimensionnelles incluent les formats netCDF, GRIB, HDF et CRF d’Esri. Les jeux de données mosaïque multidimensionnelles sont également pris en charge.</div>",
		optimalPathAsRasterName: "Chemin optimal comme raster",
		optimalPathAsRasterSnip: "Calcule le chemin de moindre coût entre une source et une destination.",
		optimalPathAsRasterDesc: "Cette fonction globale permet d’obtenir un raster en sortie qui enregistre le chemin optimal ou les chemins optimaux correspondant aux emplacements sélectionnés par rapport à la cellule source la plus proche que vous avez définie dans la surface de coûts cumulés (nous tenons compte des distances de coût).<div><br/>Une ou plusieurs des fonctions de calcul des coûts pondérés (Accumulation de distance ou Allocation de distance) doivent généralement être exécutées avant de lancer la fonction raster Chemin optimal comme raster pour créer les rasters d’accumulation de distance et de direction arrière en entrée. Ces couches raster en entrée sont obligatoires si vous souhaitez utiliser la fonction Chemin optimal. Les valeurs du chemin optimal en sortie représentent le nombre de chemins à un emplacement donné. Dans de nombreux cas, les chemins suivent le même itinéraire, quittant une source puis divergeant pour se rendre à une destination propre à chacun. Par exemple, la valeur un indique qu’il n’existe qu’un seul chemin optimal à un emplacement donné, tandis que la valeur cinq indique qu’à cet emplacement il existe cinq chemins optimaux traversant cette cellule dans la zone d’étude.<div><br/>Les données de destination en entrée doivent correspondre à une couche raster. L’ensemble des cellules de destination englobe toutes les cellules du raster en entrée comprenant des valeurs autorisées. Les cellules associées à la valeur NoData ne figurent pas dans l’ensemble. La valeur zéro est une destination pertinente. Vous pouvez créer un raster de destination à l’aide des outils d’extraction. Si vous avez des entités source ou de destination, vous pouvez les convertir en raster à l’aide de la fonction Rasteriser les entités. Utilisez le raster d’accumulation de distance ou le raster de direction arrière comme raster en entrée pour la fonction de tramage. Vous aurez ainsi l’assurance que l’entité sera rasterisée avec les mêmes paramètres (étendue des données, référence spatiale et taille de cellule) que les autres rasters traités par la fonction Chemin optimal comme raster. Vous pouvez également utiliser la fonction Chemin optimal comme raster pour obtenir le chemin offrant le moins de résistance sous la forme d’un modèle numérique d’élévation (MNE). Dans ce cas, utilisez le MNE avec le raster d’accumulation de distance en entrée et les résultats obtenus via la fonction Direction de flux pour traiter le raster de direction arrière.</div>",
		trendName: "Predict Using Trend (Prévoir à l’aide d’une tendance)",
		trendSnip: "Calcule une couche raster multidimensionnelle prévue en utilisant le raster de tendance en sortie à partir de la fonction Générer une tendance ou l’outil de géotraitement Générer un raster de tendance.",
		trendDesc: "La fonction Prévoir à l’aide d’une tendance calcule une couche raster multidimensionnelle prévue en utilisant le raster de tendance en sortie à partir de la fonction Générer une tendance ou l’outil de géotraitement Générer un raster de tendance.",
		rasterCollectionName: "Traiter un ensemble de rasters",
		rasterCollectionSnip: "Traite chaque tranche dans un raster multidimensionnel ou chaque élément dans un raster mosaïque. Cette fonction peut également agréger plusieurs tranches en une seule.",
		rasterCollectionDesc: "La fonction Traiter un ensemble de rasters traite chaque tranche dans un raster multidimensionnel ou chaque élément dans un raster mosaïque. Cette fonction peut également agréger plusieurs tranches en une seule.<div><br/>Cette fonction traite chaque tranche dans un raster multidimensionnel ou un raster mosaïque en utilisant un modèle de fonction raster. Cette fonction prend en charge les options suivantes : 1. Spécifier un modèle de fonction raster pour Item Function (Fonction de l’élément). Vous possédez par exemple un jeu de données mosaïque contenant 20 années d’imagerie Landsat et vous souhaitez calculer l’indice NDVI pour chaque scène dans la série chronologique. Pour Item Function (Fonction de l’élément), spécifiez un modèle de fonction raster contenant la fonction raster NDVI. 2. Spécifier un modèle de fonction raster pour Aggregation Function (Fonction d’agrégation). Vous avez, par exemple, un raster multidimensionnel contenant les données de températures journalières sur 10 années et souhaitez calculer la température maximum pour chaque année. Dans Aggregation Function (Fonction d’agrégation), spécifiez un modèle de fonction raster contenant la fonction Cell Statistics (Statistiques de cellule) et définissez Operation (Opération) sur Maximum. Sous la définition de l’agrégation, définissez Dimension sur StdTime, définissez Type sur Interval Keyword (Mot-clé de l’intervalle) et Keyword Interval (Intervalle de mot-clé) sur Yearly (Annuel). Notez que si le jeu de données mosaïque en entrée n’est pas multidimensionnel, la fonction d’agrégation ne respecte pas la définition de l’agrégation. La fonction d’agrégation agrège tous les éléments ou chaque groupe en un seul s’ils sont définis dans le modèle de fonction d’agrégation. Pour en savoir plus sur l’utilisation des groupes dans un jeu de données mosaïque, reportez-vous à la rubrique Utiliser les éléments de jeu de données mosaïque dans les modèles de fonction raster. 3. Spécifier un modèle de fonction raster pour Processing Function (Fonction de traitement). La fonction ou chaîne de fonctions dans ce modèle est utilisée pour afficher le nouveau raster traité. Par exemple, spécifiez un modèle de fonction raster contenant la fonction Colormap pour modifier la façon dont est affichée la couche de raster traitée. Veuillez noter que si l’entrée est un raster multidimensionnel, la fonction de traitement est appliquée à la tranche actuellement affichée. Si l’entrée est une couche de mosaïque ou un jeu de données mosaïque, la fonction de traitement est appliquée au raster mosaïque selon la première méthode pour corriger les superpositions. 3. Spécifiez des modèles pour chaque combinaison des trois fonctions. Vous disposez par exemple d’un jeu de données mosaïque contenant une série chronologique d’imageries Landsat et vous souhaitez générer une image composite d’indice NDVI maximum. Pour Item Function (Fonction de l’élément), spécifiez un modèle de fonction raster contenant la fonction raster NDVI. Pour Aggregation Function (Fonction d’agrégation), spécifiez un modèle de fonction raster contenant la fonction Cell Statistics (Statistiques de cellule) et définissez Operation (Opération) sur Maximum. Pour Processing Function (Fonction de traitement), spécifiez un modèle de fonction raster contenant la fonction Colormap. Notez que l’ordre de traitement de la fonction respecte l’ordre des paramètres en entrée. Ainsi, Item Function (Fonction de l’élément) sera traité en premier.</div>",
		randomName: "Aléatoire",
		randomSnip: "Crée un raster avec des valeurs de pixels aléatoires dessinées à partir d’une distribution pseudo aléatoire. Plusieurs distributions et générateurs de nombres aléatoires sont pris en charge.",
		randomDesc: "La fonction Aléatoire crée un raster avec des valeurs de pixels aléatoires qui peuvent être utilisées dans des modèles de fonctions raster ou des jeux de données mosaïque.<div><br/>Nombre de fonctions utilisent un ou plusieurs rasters en entrée, mais la fonction Aléatoire ne requiert pas de raster en entrée. Cela signifie qu’elle se comporte davantage comme un jeu de données raster qu’une fonction. Vous devez donc être vigilant lorsque vous l’ajoutez à la chaîne de fonctions ou que vous l’en supprimez.</div>",
		shrinkName: "Réduire",
		shrinkSnip: "Réduit la taille des zones sélectionnées selon un nombre de cellules défini, en remplaçant leur valeur par celle de la cellule la plus fréquente dans leur voisinage.",
		shrinkDesc: "Avec la fonction globale Réduire, vous pouvez généraliser ou simplifier les rasters en réduisant des zones particulières. Vous pouvez également contrôler le niveau de généralisation qui aura lieu.<div><br/>Les zones que vous sélectionnez seront réduites, ou diminuent en taille, des cellules des zones alentour se développant en elles. En théorie, les valeurs de zone sélectionnées peuvent être vues comme des zones de premier plan, les autres valeurs restant des zones d’arrière-plan. Les cellules des zones de premier plan peuvent être remplacées par les cellules des zones d’arrière-plan. Les îles fines présentes à l’intérieur d’une zone qui sont susceptibles d’être interprétées comme partageant des limites avec la zone, peuvent également être remplacées.<div><br/>Le niveau de généralisation peut être contrôlé à l’aide du paramètre Number of Cells (Nombre de cellules). Par défaut, ce paramètre a une valeur égale à 1, ce qui signifie que les zones sélectionnées diminueront du volume correspondant à la taille d’une cellule. Pour augmenter le degré de généralisation, vous pouvez spécifier une valeur supérieure pour ce paramètre. Cela revient à utiliser l’outil un nombre de fois équivalant au nombre spécifié, les résultats de l’exécution précédente formant l’entrée de l’itération suivante.</div>",
		trendToRGBName: "Tendance vers RVB",
		trendToRGBSnip: "Convertit un raster de tendance en un raster à trois canaux (rouge, vert et bleu).",
		trendToRGBDesc: "La fonction Tendance vers RVB convertit un raster de tendance en un raster à trois canaux (rouge, vert et bleu). Le raster de tendance est généré par la fonction Générer un raster de tendances ou la fonction raster d’analyse CCDC.<div><br/>Cette fonction est utile pour la visualisation des données de coefficient de modèle à partir de la fonction Générer une tendance ou la fonction d’analyse CCDC. Les deux fonctions estiment les tendances en modifiant les valeurs de pixels, mais l’interprétation directe des résultats des fonctions est difficile.<div><br/>Comme de nombreuses fonctions raster, vous aurez peut-être besoin d’utiliser l’ajustement dynamique de la plage (DRA) pour un meilleur affichage des résultats de cette fonction.</div>",
		landTrendrName: "Analyse LandTrendr",
		landTrendrSnip: "Évaluer les changements des valeurs de pixels au fil du temps à l’aide de la méthode de détection des tendances en matière de perturbation et de récupération des forêts basée sur Landsat (LandTrendr), puis générer un raster d’analyse des changements contenant les résultats du modèle.",
		landTrendrDesc: "Cette fonction raster peut uniquement être utilisée comme entrée pour la fonction raster Détecter les modifications à l’aide de l’analyse des changements. Pour générer une sortie raster, connectez la fonction d’analyse LandTrendr à la fonction Détecter les modifications à l’aide de l’analyse des changements dans un modèle de fonction raster, puis utilisez le modèle comme entrée dans l’outil de géotraitement Générer un raster à partir d’une fonction raster. Le résultat est un raster contenant des informations concernant la date/l’heure à laquelle les valeurs de pixels ont changé.<div><br>Cette fonction raster a pour finalité d’extraire les changements survenus dans une entité observée, de sorte que l’imagerie multidimensionnelle en entrée idéale puisse capturer une observation cohérente au fil du temps et ne puisse pas inclure d’interférences atmosphériques ou liées au capteur, de nuages ou l’ombre des nuages. Une bonne pratique consiste à utiliser des données qui ont été normalisées et qui peuvent être masquées à l’aide d’une bande QA (les produits de réflectance de surface Landsat Collection 1 avec un masque de nuage, par exemple).<div><br>La fonction effectue l’analyse sur une image par an, et le nombre de tranches annuelles doit être supérieur ou égal à la valeur spécifiée dans le paramètre <strong>Nombre minimal d’observations</strong>. Il est recommandé de disposer de données couvrant une période d’au moins six ans.<div><br>Si vous disposez de données mensuelles, hebdomadaires ou quotidiennes, il est recommandé de choisir plusieurs images pour chaque année (de préférence pour la même saison), de retirer les nuages et l’ombre des nuages, et de combiner les images pour générer une seule image qui capture bien l’observation. Si des données mensuelles, hebdomadaires ou quotidiennes sont fournies comme raster multidimensionnel en entrée, la fonction identifie une tranche pour l’analyse en s’appuyant sur la date la plus proche de celle indiquée dans le paramètre <strong>Date de capture</strong>.<div><br>Une entité dans un paysage prend généralement du temps pour récupérer d’un changement non permanent (un incendie de forêt ou une infestation par des insectes, par exemple). Pour contrôler la vitesse de récupération reconnue par le modèle, définissez le paramètre Seuil de récupération. Un segment distinct ne peut pas avoir une vitesse de récupération supérieure à 1/seuil de récupération.<div><br>La récupération après un changement dans un paysage peut se produire dans le sens positif ou négatif. Par exemple, lorsqu’un paysage subit une déforestation, une série temporelle des valeurs d’indice de végétation montre une chute des valeurs d’indice, puis la récupération montre une augmentation progressive des valeurs d’indice de végétation, autrement dit une tendance de récupération positive. Spécifiez le sens de la tendance de récupération avec le paramètre <strong>La tendance de récupération augmente</strong>.",
		aggregateMultidimensionalName: "Agréger un raster multidimensionnel",
		aggregateMultidimensionalSnip: "Associer les variables existantes du raster multidimensionnel le long d’une dimension.",
		aggregateMultidimensionalDesc: "La fonction Agréger un raster multidimensionnel crée une couche raster multidimensionnel en combinant les données des variables existantes du raster multidimensionnel le long d’une dimension.<div><br>Utilisez le paramètre <strong>Définition de la dimension</strong> pour filtrer en premier lieu les données en entrée que vous souhaitez agréger. Par exemple, si vous disposez de données mensuelles couvrant une période de 30 ans, mais que vous souhaitez uniquement créer une couche agrégée pour les 15 premières années, vous pouvez utiliser le paramètre <strong>Définition de la dimension</strong> pour spécifier les années à inclure dans l’analyse.<div><br><ul><li>Extraire les données de salinité pour le mois de janvier sur une période de 10 ans. Sélectionnez <strong>Par valeurs</strong>, définissez <strong>Dimension</strong> sur <strong>StdTime</strong> et <strong>Valeurs</strong> sur <strong>Janvier</strong>.</li><li>Découper les données de salinité sur une plage de profondeurs comprise entre 0 et 150 mètres. Sélectionnez <strong>Par plages</strong>, définissez <strong>Dimension</strong> sur <strong>StdZ</strong>, <strong>Valeur minimale</strong> sur <strong>-150</strong> et <strong>Valeur maximale</strong> sur <strong>0</strong>.</li><li>Extraire les données de salinité pour les 10 premiers jours de chaque mois de janvier sur une période de 10 ans. Sélectionnez <strong>Par itération</strong>, définissez <strong>Dimension</strong> sur <strong>StdTime</strong>, <strong>Début de la première itération</strong> et <strong>Fin de la première itération</strong> sur le début et la fin de la période d’itération correspondante, <strong>Étape</strong> sur <strong>1</strong> et <strong>Unité</strong> sur <strong>Années</strong>.</li></ul><div><br>Utilisez les paramètres <strong>Définition de l’agrégation</strong> pour choisir la dimension à évaluer et l’intervalle d’agrégation à l’aide d’un mot-clé, d’une valeur ou d’une plage de valeurs. Par exemple, si vous disposez de données sur la température de surface de la mer couvrant une période de 30 ans, collectées quotidiennement et tous les 5 mètres de profondeur jusqu’à 100 mètres, vous pouvez utiliser les différentes options d’intervalle pour les scénarios suivants :<div><br><ul><li>Agréger les données de température quotidiennes en données mensuelles, le résultat étant un raster multidimensionnel avec 12 tranches temporelles, chaque tranche étant l’agrégat de chaque mois sur toutes les années. Sélectionnez <strong>Mot-clé de l’intervalle</strong> et définissez le mot-clé sur <strong>Récurrence mensuelle</strong>.</li><li>Agréger les données de température quotidiennes en données mensuelles, le résultat étant un raster multidimensionnel avec 360 tranches ou 12 tranches temporelles par an (30 années x 12 mois = 360 tranches). Sélectionnez <strong>Mot-clé de l’intervalle</strong> et définissez le mot-clé sur <strong>Par mois</strong>.</li><li>Agréger les données de température mensuelles en intervalles de 4 mois. Sélectionnez <strong>Valeur de l’intervalle</strong>, définissez <strong>Valeur de l’intervalle</strong> sur 4 et définissez <strong>Unité</strong> sur <strong>Mois</strong>.</li><li>Agréger les données de température entre 0 et 25 mètres, puis entre 25 et 50 mètres, et enfin entre 50 et 100 mètres. Sélectionnez <strong>Plages d’intervalle</strong> et définissez les profondeurs minimales et maximales sur <strong>0 25; 25 50; 50 100</strong>.</li></ul>",
		mergeRastersName: "Fusionner des rasters",
		mergeRastersSnip: "Combiner plusieurs jeux de données raster spatialement ou selon des variables et des dimensions.",
		mergeRastersDesc: "Cette fonction crée un raster fusionné à partir d’une liste de rasters. Par exemple, si vous disposez d’un jeu de données mosaïque qui contient les relevés mensuels de précipitations sur 30 ans et un autre jeu de données avec les données de température mensuelles sur 10 ans, vous pouvez les associer pour créer un raster multidimensionnel avec les deux variables. <div><br>Si les rasters multidimensionnels en entrée contiennent des variables différentes, le raster multidimensionnel en sortie contient toutes les variables. <div><br>Si les rasters multidimensionnels en entrée contiennent des dimensions ou valeurs de dimension différentes, le raster multidimensionnel en sortie inclut toutes les dimensions et valeurs de dimension. <div><br>Si les rasters multidimensionnels en entrée contiennent les mêmes dimensions et variables, mais des étendues spatiales différentes, le raster multidimensionnel en sortie inclut les variables et les dimensions des étendues spatiales fusionnées.<div><br>Cette fonction peut également être utilisée si vous disposez de plusieurs rasters que vous souhaitez traiter comme un seul élément, par exemple pour calculer les mêmes statistiques pour tous ou pour l’équilibrage des couleurs, de manière à ne pas avoir besoin d’équilibrer les couleurs de chaque image séparément. Cette fonction est utile lorsque vous utilisez des images stockées sous forme de tuiles distinctes en raison de contraintes liées à la taille des fichiers. Les tuiles sont alors considérées comme faisant partie de la même image.",
		boundaryCleanName: "Nettoyage de limites",
		boundaryCleanSnip: "Lisse la limite entre des zones.",
		boundaryCleanDesc: "<p>Cette fonction généralise ou simplifie les rasters en lissant les limites entre les zones. Elle offre des options permettant de contrôler la manière dont les cellules des zones en entrée influencent le lissage et la quantité de lissage qui sera appliquée. Chaque cellule en entrée est évaluée à l’aide de ses huit voisins immédiats.</p><p>Le processus de lissage trie d’abord les cellules voisines selon une priorité particulière. La priorité détermine, parmi les cellules voisines, la zone qui peut remplacer la valeur de la cellule de traitement dans la sortie.</p><p>La priorité peut être basée soit sur la valeur des zones, soit sur la taille des zones. Le paramètre <strong>Type de tri</strong> détermine le type de tri à utiliser. </p><p>Le réglage par défaut <strong>Ne pas trier</strong> évalue la priorité en fonction de la valeur des zones. Les cellules de zones dotées de valeurs plus importantes seront prioritaires pour s’étendre dans des zones à valeurs moindres.</p><p>La taille, ou surface totale, des zones peut être utilisée pour trier la priorité. Si le paramètre est défini sur <strong>Décroissant</strong>, les zones sont triées par ordre de taille décroissant. Les zones dotées de surfaces totales plus importantes seront prioritaires pour s’étendre dans des zones à surfaces totales moindres. Si le paramètre est défini sur <strong>Croissant</strong>, c’est le contraire : les zones à surfaces totales moindres seront prioritaires pour s’étendre dans des zones dotées de surfaces totales plus importantes.</p><p>La quantité de lissage est contrôlée par le paramètre <strong>Exécuter deux fois l’expansion et la contraction</strong>, qui détermine le nombre d’exécutions du processus d’expansion et de contraction.</p><p>Si le paramètre est désélectionné, le processus d’expansion et de contraction est effectué une seule fois. Si le paramètre est coché, le processus d’expansion et de contraction est effectué deux fois, ce qui ajoute un degré supplémentaire de lissage des limites des zones.</p><p>Si les valeurs des huit cellules voisines sont identiques à celles de la cellule de traitement, la cellule en sortie conserve la valeur de la cellule en entrée.</p>",
		predictUsingRegressionName: "Prévoir à l’aide d’une régression",
		predictUsingRegressionSnip: "Calcule un raster prévu en fonction d’entrées de données raster et d’un modèle de régression. Le modèle de régression constitue la sortie de l’outil de géotraitement raster <strong>Entraîner le modèle de régression Arbres aléatoires</strong>.",
		predictUsingRegressionDesc: "<p>Le modèle de régression est défini dans un fichier de définition de régression Esri (.ecd). Ce fichier contient toutes les informations relatives à un jeu de données spécifique ou à un ensemble de jeux de données, ainsi que le modèle de régression. Il est généré par l’outil de géotraitement raster <strong>Entraîner le modèle de régression Arbres aléatoires</strong>.</p><p>L’entrée peut être un raster à une seule bande ou à plusieurs bandes, un raster multidimensionnel ou une liste de ces types. Les types des rasters en entrée doivent être identiques au type du raster entraîné par le modèle de régression.</p><ul><li>Lorsque l’entrée est un raster à plusieurs bandes, chaque bande est traitée comme une variable de prévision. Les bandes doivent être dans le même ordre que dans l’entrée à plusieurs bandes de l’outil d’entraînement du modèle de régression.</li><li>Lorsque l’entrée est un raster multidimensionnel, chaque variable est traitée comme une variable de prévision et doit présenter une seule bande et une dimension temporelle. L’ordre et les noms des variables doivent être les mêmes que ceux de l’entrée lors de l’entraînement du modèle de régression. La sortie est un raster multidimensionnel.</li><li>L’entrée peut être une liste d’éléments. Le nombre d’éléments et leur ordre doivent correspondre à l’entrée lors de l’entraînement du modèle de régression.</li></ul>",
		dimensionalMovingStatisticsName: "Statistiques mobiles dimensionnelles",
		dimensionalMovingStatisticsSnip: "Calcule les statistiques sur une fenêtre de déplacement sur des données multidimensionnelles le long d’une dimension spécifiée.",
		dimensionalMovingStatisticsDesc: "<p>La fonction Statistiques de déplacement dimensionnel calcule diverses statistiques dans une fenêtre prédéfinie pour toutes les valeurs de dimension le long d’une dimension. Cette fonction extrait une couche raster multidimensionnelle en tant qu’entrée et crée une couche raster multidimensionnelle en tant que sortie ayant la même taille de dimension que la couche en entrée.</p><p>Vous pouvez spécifier une dimension dont les valeurs sont considérées lors du calcul. Par défaut, la fonction calcule les valeurs le long de la première dimension non spatiale. Vous pouvez également spécifier une taille de fenêtre en spécifiant les paramètres Fenêtre arrière et Fenêtre avant.</p><p>Lorsque le paramètre Type de statistique est défini sur Centile, les paramètres Valeur de centile et Type d’interpolation de centile deviennent disponibles. Vous pouvez utiliser ces paramètres afin de spécifier le centile à calculer et choisir le type d’interpolation à utiliser, respectivement. Lorsque le paramètre Type de statistique est défini sur Moyenne circulaire, le paramètre Valeur de repli circulaire devient disponible. La valeur de repli circulaire est utilisée pour convertir une valeur linéaire en plage d’une moyenne circulaire donnée</p>.",
		terrainFlattenFunctionName: "Aplanir le terrain",
		terrainFlattenFunctionSnip: "Corrige les distorsions radiométriques, liées à la topographie, des données de radar à synthèse d’ouverture (SAR) en entrée.",
		terrainFlattenFunctionDesc: "<p>La fonction raster Aplanir le terrain corrige les distorsions radiométriques, liées à la topographie, des données de radar à synthèse d’ouverture (SAR) en entrée.</p><p>Les données radar en entrée doivent être calibrées sur bêta zéro. Utilisez l’outil Appliquer le calibrage radiométrique pour calibrer les données radar sur bêta zéro.</p><p>Si le MNE en entrée ne couvre pas l’intégralité du jeu de données SAR, l’outil génère des valeurs NoData pour les pixels en dehors de l’étendue du MNE pour les sorties gamma zéro, sigma zéro, de la surface de dispersion et de la distorsion géométrique. Pour la sortie du masque de distorsion géométrique, l’outil génère des valeurs indéterminées pour les pixels en dehors de l’étendue du MNE.</p><p>Le MNE en entrée doit utiliser le système de coordonnées géographiques WGS 1984 (EPSG:4326).</p>",
		createColorCompositeFunctionName: "Créer une composition colorée",
		createColorCompositeFunctionSnip: "Produit un raster à trois bandes à partir d’un jeu de données raster multibande dans lequel chaque bande utilise un calcul algébrique basé sur l’algèbre des bandes.",
		createColorCompositeFunctionDesc: "<p>La fonction raster Créer une composition colorée produit un raster à trois bandes à partir d’un jeu de données raster multibande dans lequel chaque bande utilise un calcul algébrique basé sur l’algèbre des bandes.</p><p>Lorsque vous définissez un algorithme arithmétique de bande, vous pouvez saisir une formule algébrique uniligne pour chaque expression afin de créer une sortie multibande. Les opérateurs pris en charge sont unaires : addition (+), soustraction (-), multiplication (*) et division (/).</p><p>Lors de l’utilisation d’un identifiant de bande dans une expression, identifiez la bande en ajoutant un préfixe B ou b au numéro de la bande.</p><p>Une combinaison de bandes courante utilisée pour le radar à synthèse d’ouverture (SAR) dans les unités linéaires est VV pour rouge, VH pour vert et VV-VH pour bleu. Si les données en entrée sont exprimées en décibels, la combinaison de bandes doit être VV pour rouge, VH pour vert et VV-VH pour bleu.</p>",
		surfaceParametersName: "Paramètres de surface",
		surfaceParametersSnip: "Détermine les paramètres d’un raster de surface, tels que l’exposition, la pente et plusieurs types de courbures à l’aide de méthodes géodésiques.",
		surfaceParametersDesc: "<p>La fonction Paramètres de surface détermine les paramètres d’un raster de surface, tels que l’exposition, la pente et plusieurs types de courbures à l’aide de méthodes géodésiques.</p><p>Cette fonction peut être utilisée dans les applications suivantes :</p><ul><li>Calculer l’exposition et la pente à l’aide de méthodes géodésiques.</li><li>Calculer différents types de courbures à partir d’un raster de surface en entrée, par exemple, <strong>Courbure tangentielle (isoligne normale)</strong> qui caractérise la convergence et la divergence topographiques du flux sur la surface.</li></ul>",
		leastCostCorridorName: "Couloir de moindre coût",
		leastCostCorridorSnip: "Calcule la somme de deux rasters de distance de coût cumulé avec la possibilité d’appliquer un seuil en fonction du pourcentage ou du coût cumulé.",
		leastCostCorridorDesc: "<p>Les rasters en entrée doivent être des rasters d’accumulation de distance et de direction arrière générés par la fonction <strong>Accumulation de distance</strong> ou <strong>Allocation de distance</strong>. Ils doivent être basés sur la distance de coût et les mêmes paramétrages doivent être utilisés pour la création des couches de chaque source. Aucun paramètre dépendant de la directionnalité (facteur horizontal, facteur vertical et sens de déplacement) ne doit être utilisé pour la création de ces rasters.</p><p>Les valeurs du raster de couloir en sortie correspondent à la somme du coût cumulé pour atteindre un emplacement donné avec les mêmes unités que celles des rasters de distance de coût cumulé en entrée.</p><p>Si une valeur <strong>Seuil</strong> spécifiée est supérieure au coût cumulé maximal lorsque les deux rasters d’accumulation de distance sont additionnés, le raster de couloir en sortie couvre la même zone que les rasters de coût cumulé en entrée.</p><p>Si une valeur de seuil spécifiée est inférieure à la valeur minimale dans le raster de couloir, un message d’avertissement est renvoyé et le raster en sortie est vide.</p><p>Il est possible que le raster de couloir en sortie contienne des cellules avec des coûts cumulés légèrement supérieurs à la valeur de seuil. C’est le cas lorsque les rasters de direction arrière utilisent des cellules auxquelles des coûts légèrement supérieurs au seuil ont été attribués afin de connecter des cellules déconnectées au couloir.</p>",
		geometricMedianName: "Médiane géométrique",
		geometricMedianSnip: "La fonction Médiane géométrique calcule la médiane géométrique des pixels dans une série chronologique d’images multibandes.",
		geometricMedianDesc: "<p>Cette fonction réduit le bruit et les points aberrants dans les images d’une série chronologique en calculant un pixel médian géométrique pour chaque matrice de pixels dans la pile d’images. L’algorithme conserve les relations spectrales entre les bandes dans les spectres des pixels afin que la sortie puisse être utilisée dans une analyse, telle que le calcul des indices de végétation.</p><p>Vous devez masquer les nuages et les ombres à l’aide de la bande d’assurance qualité (QA) du jeu de données avant d’appliquer cette fonction.</p><p>Si l’image en entrée comporte des données à virgule flottante, comme une réflectance de surface avec des valeurs comprises entre 0 et 1, une valeur epsilon de 0,001 produit généralement des résultats de qualité satisfaisante.</p>"
	},
	rfxArgs: {
		rasterName: "Raster",
		colorSchemeTypeName: "Type de combinaison de couleurs",
		colormapName: "Palette de couleurs",
		colormapNameName: "Nom de la palette de couleurs",
		colorRampName: "Dégradé de couleurs",
		contrastOffsetName: "Décalage de contraste",
		brightnessOffsetName: "Décalage de la luminosité",
		methodName: "Méthode",
		bandNamesName: "Noms des canaux",
		bandWavelengthsName: "Longueurs d'ondes des canaux",
		bandIdsName: "Identifiants des canaux",
		missingBandActionName: "Action concernant le canal manquant",
		conversionParametersName: "Paramètres de conversion",
		hillshadeTypeName: "Type d'ombrage",
		azimuthName: "Azimut",
		altitudeName: "Altitude",
		slopeTypeName: "Mise à l’échelle",
		zFactorName: "Facteur Z",
		PSPowerName: "Puissance de la taille de pixel",
		PSZFactorName: "Facteur de taille de pixel",
		removeEdgeEffectName: "Désactiver l'interpolation des pixels de tronçon par défaut",
		fromUnitName: "De l’unité",
		toUnitName: "À l’unité",
		rasterTypeName: "Type",
		minName: "Sortie minimale",
		maxName: "Sortie maximale",
		minPercentName: "Pourcentage de découpe minimal",
		maxPercentName: "Pourcentage de découpe maximal",
		numberOfStandardDeviationName: "Nombre d’écarts types",
		sigmoidStrengthLevelName: "Niveau de force sigmoïde",
		estimateStatsHistogramName: "Estimer les statistiques",
		DRAName: "Ajustement dynamique de la plage",
		statisticsName: "Statistiques",
		histogramsName: "Histogrammes",
		statisticsHistogramName: "Définir des statistiques et un histogramme",
		computeGammaName: "Valeur Gamma automatique",
		useGammaName: "Utiliser la valeur Gamma",
		gammaName: "Gamma",
		inputNamesName: "Noms",
		expressionName: "Expression",
		cellsizeTypeName: "Type de taille de cellule",
		extentTypeName: "Type d’étendue",
		classifierDefinitionFileName: "Fichier de définition en entrée",
		raster1Name: "Raster1",
		raster2Name: "Raster2",
		raster3Name: "Raster3",
		trueRasterName: "Raster vrai",
		falseRasterName: "Raster faux",
		noDataInterpretationName: "Interprétation NoData",
		noDataValuesName: "Valeurs NoData",
		includedRangesName: "Plages incluses",
		curvatureTypeName: "Type de courbure",
		rastersName: "Rasters",
		attributeTableName: "Tableau",
		attributeTableTypeName: "Type de table",
		rowsName: "Nombre de lignes",
		columnsName: "Nombre de colonnes",
		kernelName: "Noyau",
		mirrorEdgesName: "Symétrie des tronçons",
		influencesName: "Influences",
		fieldsName: "Champs",
		remapsName: "Table de classification",
		evalFromName: "Echelle d'évaluation d'origine",
		evalToName: "Echelle d'évaluation de destination",
		weightsName: "Pondérations",
		DEMName: "USGS DEM",
		shortRangeIDWRadiusName: "Rayon IDW de courte portée",
		maxVoidWidthName: "Largeur de vide max",
		sigmaGaussianName: "Lissage adaptatif",
		contourTypeName: "Type d’isoligne",
		zBaseName: "Base Z",
		numberOfContoursName: "Nombre d'isolignes",
		contourIntervalName: "Intervalle des isolignes",
		nthContourLineInBoldName: "Isoligne nord en gras",
		featureClassName: "Entités en entrée",
		classIndexFieldName: "Terrain",
		resolveOverlapMethodName: "Méthode Résoudre la superposition",
		resamplingTypeName: "Type de rééchantillonnage",
		inputCellsizeName: "Taille de cellule en entrée",
		outputCellsizeName: "Taille de cellule en sortie",
		pointFeatureClassName: "Points d'origine",
		maxGrowthRadiusFieldName: "Champ de rayon d'évolution maximale",
		similarityThresholdFieldName: "Champ de seuil de similarité",
		fillValueFieldName: "Champ de valeurs de remplissage",
		spectralDetailName: "Détail spectral [1..20]",
		spatialDetailName: "Détail spatial [1..20]",
		minNumPixelsPerSegmentName: "Taille minimale du segment en pixels",
		boundariesOnlyName: "Limites du segment uniquement",
		statisticsTypeName: "Type de statistique",
		fillNoDataOnlyName: "Remplir uniquement les pixels NoData",
		inputDataTypeName: "Type de données en entrée",
		angleReferenceSystemName: "Système de référence angulaire",
		outputDataTypeName: "Type de données en sortie",
		inputSamplePointFeatureClassName: "Exemples en entrée",
		valueFieldName: "Champ de valeur",
		rasterInfoName: "Informations raster",
		interpolationMethodName: "Méthode d’interpolation",
		radiusName: "Rayon",
		radianceGainValuesName: "Gain de rayonnement",
		radianceBiasValuesName: "Tendance de rayonnement",
		reflectedGainValuesName: "Gain de réflectance",
		reflectedBiasValuesName: "Tendance de réflectance",
		sunElevationName: "Altitude du soleil (degrés)",
		albedoName: "Albédo",
		scaleFactorName: "Facteur d'échelle",
		offsetName: "Décalage",
		thresholdTypeName: "Type de seuil",
		thresholdsName: "Seuils",
		undefinedClassName: "Classe non définie",
		minValueName: "Min",
		maxValueName: "Max",
		operationName: "Opération",
		clippingTypeName: "Type de découpage",
		clippingGeometryName: "Géométrie de découpage / Raster",
		extentName: "Étendue en sortie",
		useInputFeatureGeometryName: "Utiliser les entités en entrée pour la géométrie de découpage",
		remapDefinitionTypeName: "Type de définition de classification",
		inputRangeName: "Plages en entrée",
		outputValuesName: "Valeurs en sortie",
		noDataRangeName: "Plages NoData",
		inputFieldName: "Champ en entrée",
		outputFieldName: "Champ en sortie",
		inputMaxFieldName: "Champ max en entrée (facultatif)",
		remapTableTypeName: "Type de table de classification",
		allowUnmatchedName: "Autoriser les valeurs de pixels non appariées",
		changeMissingValuesToNoDataName: "Remplacer les valeurs manquantes par NoData",
		visibleBandIDName: "ID de canal visible",
		infraredBandIDName: "ID de canal infrarouge",
		scientificOutputName: "Sortie scientifique",
		bandIndexesName: "Index de canaux",
		constantName: "Constante",
		weightName: "Pondération",
		minimumName: "Minimal",
		maximumName: "Maximum",
		sourceDataName: "Raster source",
		sourceFieldName: "Champ source",
		costRasterName: "Raster de coût",
		maxDistanceName: "Echelle minimale",
		valueRasterName: "Raster de valeur",
		costMultiplierName: "Multiplicateur à appliquer aux coûts",
		startCostName: "Coût de début",
		accumCostResistanceRateName: "Taux de résistance du coût cumulé",
		capacityName: "Capacité",
		travelDirectionName: "Sens de déplacement",
		cellSizeName: "Taille de cellule",
		populationFieldName: "Champ de population",
		areaUnitsName: "Unités de surface",
		outputValueTypeName: "Valeurs des cellules en sortie",
		barriersName: "Interruptions en entrée",
		destinationDataName: "Raster de destination",
		destinationFieldName: "Champ de destination",
		pathTypeName: "Type de chemin",
		observerFeaturesName: "Entités points d'observation",
		analysisMethodName: "Méthode d'analyse",
		analysisTypeName: "Type d'analyse",
		verticalErrorName: "Erreur verticale",
		refractivityCoefficientName: "Coefficient de réfraction",
		surfaceOffsetName: "Décalage de la surface",
		observerElevationName: "Altitude du point d'observation",
		observerOffsetName: "Décalage du point d'observation",
		innerRadiusName: "Rayon intérieur",
		innerRadiusIs3DDistanceName: "Le rayon intérieur est une distance 3D",
		outerRadiusName: "Rayon extérieur",
		outerRadiusIs3DDistanceName: "Le rayon extérieur est une distance 3D",
		horizontalStartAngleName: "Angle de départ horizontal",
		horizontalEndAngleName: "Angle de fin horizontal",
		verticalUpperAngleName: "Angle supérieur vertical",
		verticalLowerAngleName: "Angle inférieur vertical",
		zoneDataName: "Raster de zones",
		zoneFieldName: "Champ de zone",
		ignoreNoDataName: "Ignorer NoData dans les calculs",
		temperatureRasterName: "Raster de température",
		inTemperatureUnitsName: "Unités de température",
		outHeatIndexTemperatureUnitsName: "Unités d'indice de chaleur",
		relativeHumidityRasterName: "Raster d'humidité relative",
		outWindChillTemperatureUnitsName: "Unités de température ressentie",
		windSpeedRasterName: "Raster de vitesse du vent",
		inWindSpeedUnitsName: "Unités de vitesse du vent",
		valueName: "Valeur",
		propertyName: "Nom de la propriété",
		jsonName: "Les métadonnées JSON",
		zoneTableName: "Table des attributs zonaux",
		attributeFieldNames: "Noms de champ d'attribut",
		backgroundName: "Valeur d’arrière-plan",
		whereClauseName: "Clause Where",
		minimumValueFieldName: "Nom du champ de la valeur minimale",
		maximumValueFieldName: "Nom du champ de la valeur maximale",
		outValueFieldName: "Nom du champ de la valeur en sortie",
		defaultValueName: "Valeur en sortie par défaut",
		conversionMatrixName: "Matrice de conversion",
		IsPseudoColorOutputName: "Est une pseudo-couleur en sortie",
		unmappedAsRandomColorName: "Couleur attribuée de manière aléatoire aux pixels non appariés",
		distanceMethodName: "Méthode de calcul de distance",
		flowDirRasterName: "Raster de direction de flux",
		pourPointName: "Raster de points d’écoulement",
		pourPointFieldName: "Champ de point d’écoulement",
		constantZName: "Constante Z",
		zOffsetName: "Décalage Z",
		geoIdName: "Géoïde",
		calibrationTypeName: "Type de calibrage",
		filterTypeName: "Type de filtre",
		filterSizeName: "Taille de filtre",
		noiseModelName: "Modèle de bruit",
		noiseVarianceName: "Variance de bruit",
		additiveNoiseMeanName: "Moyenne de bruit additif",
		multiplicativeNoiseMeanName: "Moyenne de bruit multiplicatif",
		numberofLooksName: "Nombre de vues",
		dampingFactorName: "Facteur d’humidité",
		maskRasterName: "Raster de masque",
		nibbleValuesName: "Utiliser les valeurs NoData s’il s’agit du voisin le plus proche",
		nibbleNoDataName: "Grignoter les cellules NoData",
		zLimitName: "Limite Z",
		flowDirectionTypeName: "Type de direction de flux",
		weightRasterName: "Raster de pondération",
		forceEdgeName: "Forcer l’écoulement vers l’extérieur sur les quatre bords",
		streamRasterName: "Raster en mode continu",
		surfaceRasterName: "Surface raster",
		conversionType: "Type de conversion",
		distanceRaster1: "Raster de distance 1",
		distanceRaster2: "Raster de distance 2",
		costDistanceRaster: "Raster de distance de coût",
		costBacklinkRaster: "Raster d’antécédence de coût",
		overridesName: "Débrayages",
		fieldName: "Terrain",
		signatureFileOrUrl: "Fichier de signatures ou URL",
		redName: "Rouge",
		greenName: "Vert",
		blueName: "Bleu",
		infraredName: "Infrarouge",
		panchromaticName: "Panchromatique",
		multispectralName: "Multispectral",
		pansharpeningType: "Type d’affinage panchromatique",
		sensorName: "Capteur",
		spatialReferenceName: "Référence spatiale",
		xCellsizeName: "Taille de cellule X",
		yCellsizeName: "Taille de cellule Y",
		xOriginName: "Point de calage X",
		yOriginName: "Point de calage Y",
		percentileName: "Valeur de pourcentage",
		neighborhoodType: "Type de voisinage",
		widthName: "Largeur",
		heightName: "Hauteur",
		startAngleName: "Angle de départ",
		endAngleName: "Angle d’arrivée",
		neighborhoodValues: "Valeurs voisines",
		horizontalRaster: "Raster horizontal",
		horizontalFactor: "Facteur horizontal",
		verticalRaster: "Raster vertical",
		verticalFactor: "Facteur vertical",
		streamRaster: "Raster en mode continu",
		flowDirRaster: "Raster de direction de flux",
		numberNeighborCells: "Nombre de cellules voisines",
		zoneConnectivity: "Connectivité de zone",
		addLinkBehavior: "Ajouter un lien",
		excludedValue: "Valeur exclue",
		constantFillCheck: "Générer un raster de remplissage à partir d’une constante",
		fillRaster: "Raster de remplissage",
		constantFillValue: "Valeur constante",
		inputBitPositions: "Bit en entrée",
		outputBitPositions: "Bit en sortie",
		distanceTypeName: "Type de distance",
		barrierDataName: "Interruptions du raster",
		pourPointDataName: "Raster de capture des points d'écoulement",
		accumulationRasterName: "Raster d’accumulation de flux",
		snapDistanceName: "Distance de capture",
		orderMethodName: "Méthode de tri",
		directionMeasurementName: "Direction de mesure",
		processAsMultiband: "Traiter comme multibande",
		processMultidimensional: "Traiter comme multidimensionnel",
		forceFlowDirectionConvention: "Forcer la convention de sens de circulation pour le raster d’antécédence",
		initialAccumulation: "Accumulation initiale",
		maximumAccumulation: "Accumulation maximale",
		sourceLocationBands: "Générer la ligne et la colonne sources en tant que bandes supplémentaires dans la sortie",
		backDirectionBand: "Générer la direction arrière en tant que bande supplémentaire dans la sortie",
		numberOfCells: "Nombre de cellules",
		zoneValues: "Valeurs de zone",
		shrinkMethod: "Méthode de réduction",
		expandMethod: "Méthode de développement",
		inputSpectralProfileType: "Type de profil spectral",
		spectralProfileFileName: "Profil spectral",
		trainingFeatureFileName: "Entité d’entraînement",
		nonNegative: "Non négatif",
		sumToOne: "Somme égale à un",
		randomDistribution: "Distribution",
		meanName: "Moyenne",
		probabilityName: "Probabilité",
		alphaName: "Alpha",
		betaName: "Bêta",
		rName: "r",
		nName: "N",
		seed: "Valeur init.",
		randomNumberGenerator: "Générateur de nombres aléatoires",
		cellFactor: "Facteur de cellule",
		aggregationType: "Méthode d’agrégation",
		extentHandling: "Augmenter l’étendue si nécessaire",
		trendAnalysisDimensionName: "Nom de la dimension",
		trendAnalysisType: "Type de tendance",
		harmonicFrequency: "Fréquence harmonique",
		polynomialOrder: "Ordre polynomial",
		cycleLengthName: "Durée du cycle",
		trendAnalysisRMSE: "EQM",
		trendAnalysisR2: "R-carré",
		trendAnalysisSlopePValue: "Valeur P du coefficient de pente",
		trendAnalysisSeasonalPeriod: "Période saisonnière",
		cycleUnitName: "Unité de cycle",
		predictDimensionValues: "Valeurs",
		dimensionDefinitionType: "Définition de la dimension",
		predictDimensionStart: "Début",
		predictDimensionEnd: "Fin",
		predictDimensionInterval: "Valeur de l’intervalle",
		dimensionUnit: "Unité",
		interpolationCellsizeName: "Taille de cellule d’interpolation",
		variableName: "Variables",
		dimensionlessName: "Sans dimension",
		mdimDefinition: "Dimension Definition (Définition de la dimension)",
		dimensionName: "Cotation",
		iterationStart: "Start of first iteration (Début de la première itération)",
		iterationEnd: "End of first iteration (Fin de la première itération)",
		intervalStart: "Début de l’intervalle",
		intervalEnd: "Fin de l’intervalle",
		stepName: "Pas",
		rangesName: "Plages",
		minValue: "Valeur minimale",
		maxValue: "Valeur maximale",
		changeAnalysisRasterName: "Raster d’analyse des changements",
		changeTypeName: "Modifier le type",
		segmentDate: "Date du segment",
		changeDirectionName: "Sens du changement",
		maxNumChangesName: "Nombre maximal de changements",
		filterByYear: "Filtrer par année",
		minimumYear: "Valeur minimale",
		maximumYear: "Valeur maximale",
		filterByDuration: "Filtrer par durée",
		minimumDuration: "Durée minimale",
		maximumDuration: "Durée maximale",
		filterByMagnitude: "Filtrer par magnitude",
		minimumMagnitude: "Magnitude minimale",
		maximumMagnitude: "Magnitude maximale",
		filterByStartValue: "Filtrer par valeur de départ",
		minimumStartValue: "Valeur de départ minimale",
		maximumStartValue: "Valeur de départ maximale",
		filterByEndValue: "Filtrer par valeur de fin",
		minimumEndValue: "Valeur de fin minimale",
		maximumEndValue: "Valeur de fin maximale",
		modelTypeName: "Type de modèle",
		fromRasterName: "Raster d’origine",
		toRasterName: "Raster de destination",
		computeChangeMethod: "Méthode Calculer les modifications",
		fromClassValues: "Valeurs de classe d’origine (exemple : 2 5)",
		toClassValues: "Valeurs de classe de destination (exemple : 2 5)",
		keepMethod: "Méthode de filtrage",
		useColorMethod: "Définir les couleurs de transition",
		detectChangeBands: "Bandes pour la détection des changements (commencent à 0)",
		tmaskBands: "Bandes pour le masquage temporel (commencent à 0)",
		chiSquaredThreshold: "Seuil du khi deux pour la détection des changements",
		minAnomaly: "Observations des anomalies consécutives minimales",
		updatingFrequency: "Mise à jour de la fréquence de pertinence (en années)",
		distanceAccumulationRasterName: "Raster d’accumulation de distance",
		costBackdirectionRasterName: "Raster de direction arrière ou de direction de flux",
		rasterCollectionName: "Ensemble de rasters",
		itemFunctionName: "Fonction de l’élément",
		aggregationFunctionName: "Fonction d’agrégation",
		processingFunctionName: "Fonction de traitement",
		aggregationDefinitionName: "Définition de l’agrégation",
		queryGeometryName: "Requête Géométrie",
		factorFunctionZeroFactor: "Facteur zéro",
		factorFunctionCutAngle: "Angle d’inflexion",
		factorFunctionSideFactor: "Facteur latéral",
		factorFunctionSlope: "Pente",
		factorFunctionLowCutAngle: "Angle d’inflexion inférieur",
		factorFunctionHighCutAngle: "Angle d’inflexion supérieur",
		factorFunctionCosPower: "Puissance de cosinus",
		factorFunctionSecPower: "Puissance de sécante",
		factorFunctionTablePath: "Chemin d’accès à la table",
		processingBand: "Bande de traitement",
		processingBandName: "Nom de la bande de traitement",
		snappingDate: "Date de capture",
		maxNumSegments: "Nombre maximal de segments",
		vertexCountOvershoot: "Dépassement du nombre de sommets",
		spikeThreshold: "Seuil de pic",
		recoveryThreshold: "Seuil de récupération",
		minNumObs: "Nombre minimal d’observations",
		pValueThreshold: "Seuil de la valeur P",
		bestModelProportion: "Proportion de modèle idéale",
		preventOneYearRecovery: "Empêcher la récupération sur un an",
		recoveryIncreaseTrend: "La tendance de récupération augmente",
		outputOtherBands: "Générer d’autres bandes en sortie",
		sortType: "Type de tri",
		numberOfRuns: "Exécuter deux fois l'expansion et la contraction",
		percentileValue: "Valeur du centile",
		percentileInterpolationType: "Percentile interpolation type (Type d’interpolation en centile)",
		rasterInfoProperty: "Propriété",
		rasterInfoValue: "Valeur",
		rasterInfoColumns: "Colonnes",
		rasterInfoRows: "Lignes",
		rasterInfoBandCount: "Nombre de bandes",
		rasterInfoPixelSizeX: "Taille de cellule X",
		rasterInfoPixelSizeY: "Taille de cellule Y",
		rasterInfoPixelType: "Type de pixel",
		rasterExtentTop: "Haut",
		rasterExtentBottom: "Bas",
		rasterExtentLeft: "Gauche",
		rasterExtentRight: "Droite",
		rasterStatisticsNotCalculated: "Les statistiques n’ont pas été calculées.",
		spatialReferenceProjection: "Projection",
		spatialReferenceWkid: "WKID",
		spatialReferenceLatestWkid: "WKID précédent",
		spatialReferenceWkt: "WKT",
		spatialReferenceVcsWkid: "VCSWKID",
		spatialReferenceLatestVcsWkid: "VCSWKID précédent",
		spatialReferenceAuthority: "Autorité",
		spatialReferenceLinearUnit: "Unité linéaire",
		spatialReferenceAngularUnit: "Unité angulaire",
		spatialReferenceFalseEasting: "Abscisse fictive",
		spatialReferenceFalseNorthing: "Ordonnée fictive",
		spatialReferenceCentralMeridian: "Méridien central",
		spatialReferencePrimeMeridian: "Méridien principal",
		spatialReferenceStandardParallel1: "Parallèle de référence 1",
		spatialReferenceStandardParallel2: "Parallèle de référence 2",
		spatialReferenceLatitudeOfOrigin: "Latitude de l’origine",
		spatialReferenceAuxiliarySphereType: "Type de sphère auxiliaire",
		spatialReferenceDatum: "Datum",
		spatialReferenceSpheroid: "Sphéroïde",
		spatialReferenceSemimajorAxis: "Demi-grand axe",
		spatialReferenceSemiminorAxis: "Demi-petit axe",
		spatialReferenceInverseFlattening: "Aplatissement inverse",
		inputDefinitionFileName: "Fichier de définition en entrée",
		deleteName: "Supprimer",
		addVariableName: "Ajouter une variable",
		maxNumPixelsPerSegment: "Taille maximale du segment en pixels",
		forwardWindowName: "Fenêtre avant",
		backwardWindowName: "Fenêtre arrière",
		noDataHandlingName: "Gestion des valeurs NoData",
		circularWrapValueName: "Valeur de repli circulaire",
		fromClassNameFieldName: "Nom de champ pour les noms de classe dans le raster d’origine",
		toClassNameFieldName: "Nom de champ pour les noms de classe dans le raster de destination",
		targetRasterName: "Raster cible",
		circularWrapValue: "Valeur de repli circulaire",
		bandIndexesR: "Expression rouge",
		bandIndexesG: "Expression verte",
		bandIndexesB: "Expression bleue",
		exampleName: "Exemple",
		inputName: "Entrée",
		outputName: "Sortie",
		optionalName: "Facultatif",
		browseDefinitionFile: "Rechercher le fichier de définition",
		selectDefinitionFile: "Sélectionner le fichier de définition en entrée",
		inputDefinitionURL: "URL du fichier de définition en entrée",
		enterDefinitionFileURL: "Saisir l’URL du fichier de définition",
		browseXMLFile: "Rechercher le fichier XML",
		selectStatsFile: "Sélectionner le fichier de statistiques et d’histogrammes",
		enterXMLFileURL: "Saisir l’URL du fichier XML",
		xmlFileURL: "URL du fichier XML",
		circularCalculation: "Calculer les statistiques circulaires",
		localSurfaceType: "Type de surface locale",
		surfaceParameterType: "Type de paramètre",
		neighborhoodDistance: "Distance de voisinage",
		useAdaptiveNeighborhood: "Utiliser le voisinage adaptatif",
		outputSlopeType: "Mesure de pente en sortie",
		projectAzimuths: "Projeter des azimuts géodésiques",
		useEquatorialAspect: "Utiliser l’aspect équatorial",
		zUnit: "Unité Z",
		analysisMask: "Masque d’analyse",
		stdDeviation: "Écart type",
		"true": "Vrai",
		"false": "Faux",
		costDistanceRaster1: "1er raster de distance de coût cumulé en entrée",
		costDistanceRaster2: "2e raster de distance de coût cumulé en entrée",
		threshold: "Seuil",
		thresholdMethod: "Méthode de seuil",
		directionRaster1: "1er raster de direction arrière en entrée",
		directionRaster2: "2e raster de direction arrière en entrée",
		maxIterations: "Nombre maximum d’itérations",
		epsilon: "Epsilon"
	},
	enumLabels: {
		attributeTableTypeManual: "Manuelle",
		attributeTableTypeExternal: "Externe",
		clrSchemeTypeColormap: "Palette de couleurs",
		clrSchemeTypeColorRamp: "Dégradé de couleurs",
		colormapTypeElevation: "Altitude",
		colormapTypeGray: "Gris",
		colormapTypeNDVI: "Indice NDVI",
		colormapTypeNDVI2: "NDVI2",
		colormapTypeNDVI3: "NDVI3",
		colormapTypeRandom: "Aléatoire",
		none: "Aucun",
		slopeTypeAdjusted: "Ajusté",
		slopeTypeDegree: "Degré",
		slopeTypePercentRise: "Pourcentage d’élévation",
		slopeTypeScaled: "Mise à l’échelle",
		stretchTypeMinMax: "MinMax",
		stretchTypePercentMinMax: "PourcentageMinMax",
		stretchTypeSigmoid: "Sigmoïde",
		stretchTypeStdDev: "Ecart type",
		hillshadeTypeSimple: "Traditionnel",
		hillshadeTypeMultidirectional: "Multidirectionnel",
		bandComboByNames: "Noms des canaux",
		bandComboByWavelength: "Longueurs d'ondes des canaux",
		bandComboByIDs: "Identifiants des canaux",
		missingBandActionBestMatch: "Meilleur résultat",
		missingBandActionFail: "Échec",
		unitTypeCelsius: "Celsius",
		unitTypeCentimeters: "Centimètres",
		unitTypeDecimeters: "Décimètres",
		unitTypeFahrenheit: "Fahrenheit",
		unitTypeFeet: "Pieds",
		unitTypeFeetPerSec: "Pieds par seconde (pd/s)",
		unitTypeInches: "Pouces",
		unitTypeKelvin: "Kelvin",
		unitTypeKilometers: "Kilomètres",
		unitTypeKmsPerHour: "Kilomètres par heure (km/h)",
		unitTypeKnots: "Nœuds (nd)",
		unitTypeMeters: "Mètres",
		unitTypeMetersPerSec: "Mètres par seconde (m/s)",
		unitTypeMiles: "Milles",
		unitTypeMilesPerHour: "Miles par heure (mph)",
		unitTypeMillimeters: "Millimètres",
		unitTypeNauticalMiles: "Milles nautiques",
		unitTypeYards: "Yards",
		unitTypeDecimalDegrees: "Degrés décimaux",
		unitTypePoints: "Points",
		unitTypeUnknown: "Inconnu",
		unitTypeSqMapUnits: "Unité de carte au carré",
		unitTypeSqMiles: "Miles carrés",
		unitTypeSqKms: "Kilomètres carrés",
		unitTypeAcres: "Ares",
		unitTypeHectares: "Hectares",
		unitTypeSqYards: "Yards carrés",
		unitTypeSqFt: "Pieds carrés",
		unitTypeSqInches: "Pouces carrés",
		unitTypeSqMts: "Mètres carrés",
		unitTypeSqCms: "Centimètres carrés",
		unitTypeSqMms: "Millimètres carrés",
		cellsizeTypeFirst: "Premier de",
		cellsizeTypeMin: "Mini de",
		cellsizeTypeMax: "Max de",
		cellsizeTypeMean: "Moyenne de",
		cellsizeTypeLast: "Dernier de",
		extentTypeFirst: "Premier de",
		extentTypeIntersection: "Intersection de",
		extentTypeUnion: "Union de",
		extentTypeLast: "Dernier de",
		noDataInterpretAny: "Certains critères",
		noDataInterpretAll: "Tous les critères",
		curvatureTypeStandard: "Standard",
		curvatureTypeProfile: "Profil",
		curvatureTypePlanform: "Planiforme",
		filterTypeLineDetectionHorizontal: "Détection de ligne horizontale",
		filterTypeLineDetectionVertical: "Détection de ligne verticale",
		filterTypeLineDetectionLeftDiagonal: "Détection de ligne diagonale gauche",
		filterTypeLineDetectionRightDiagonal: "Détection de ligne diagonale droite",
		filterTypeGradientNorth: "Dégradé nord",
		filterTypeGradientWest: "Dégradé ouest",
		filterTypeGradientEast: "Dégradé est",
		filterTypeGradientSouth: "Dégradé sud",
		filterTypeGradientNorthEast: "Dégradé nord-est",
		filterTypeGradientNorthWest: "Dégradé nord-ouest",
		filterTypeSmoothArithmeticMean: "Moyenne arithmétique lissée",
		filterTypeSmoothing3x3: "Lissage 3x3",
		filterTypeSmoothing5x5: "Lissage 5x5",
		filterTypeSharpening3x3: "Affinage 3x3",
		filterTypeSharpening5x5: "Affinage 5x5",
		filterTypeLaplacian3x3: "Laplacien 3x3",
		filterTypeLaplacian5x5: "Laplacien 5x5",
		filterTypeSobelHorizontal: "Sobel horizontal",
		filterTypeSobelVertical: "Sobel vertical",
		filterTypeSharpen: "Affinage",
		filterTypeSharpen2: "Affiner davantage",
		filterTypePointSpread: "Dispersion des points",
		userDefined: "Défini par l’utilisateur",
		ContourTypeLines: "Isolignes",
		ContourTypeFill: "Remplissage d’isolignes",
		ContourTypeSmoothOnly: "Surface lisse uniquement",
		rasterizeFirst: "Premier",
		rasterizeLast: "Dernier",
		rasterizeSmallest: "Le plus petit",
		rasterizeLargest: "Le plus grand",
		resamplingTypeNearest: "Voisin le plus proche",
		resamplingTypeBilinear: "Interpolation bilinéaire",
		resamplingTypeCubic: "Convolution cubique",
		resamplingTypeMajority: "Majorité",
		resamplingTypeBilinearPlus: "Interpolation bilinéaire Plus",
		resamplingTypeGauss: "Flou gaussien",
		resamplingTypeGaussPlus: "Flou gaussien Plus",
		resamplingTypeAverage: "Moyenne",
		resamplingTypeMinimum: "Minimal",
		resamplingTypeMaximum: "Maximum",
		resamplingTypeVectorAvg: "Moyenne vectorielle",
		minimum: "Minimal",
		maximum: "Maximum",
		mean: "Moyenne",
		stdDeviation: "Écart type",
		uvMagDirTypeUV: "U-V",
		uvMagDirTypeMagDir: "Magnitude-Direction",
		unknown: "Inconnu",
		angleRefSysGeographic: "Géographique",
		angleRefSysArithmetic: "Arithmétique",
		interpolateIrregularDataNearest: "Voisin le plus proche",
		interpolateIrregularDataBilinear: "Bilinéaire",
		interpolateIrregularDataTinningLinear: "TIN linéaire",
		interpolateIrregularDataTinningNaturalNeighbor: "Voisin naturel",
		interpolateIrregularDataTinningIDW: "Pondération par l'inverse de la distance",
		esriRasterThresholdTypeConstant: "Constante",
		esriRasterThresholdTypeOtsu: "Otsu",
		esriRasterThresholdTypeTsai: "Tsai",
		esriRasterThresholdTypeKapur: "Kapur",
		esriRasterThresholdTypeKittler: "Kittler",
		esriRasterThresholdTypeRosin: "Rosin",
		argStatsTypeMax: "Arg Max",
		argStatsTypeMin: "Arg Min",
		argStatsTypeMedian: "Arg médian",
		argStatsTypeDuration: "Duration",
		arithmeticOpPlus: "Addition",
		arithmeticOpMinus: "Soustraction",
		arithmeticOpMultiply: "Multiplication",
		arithmeticOpDivide: "Division",
		arithmeticOpPower: "Puissance",
		arithmeticOpMode: "Mode",
		clipTypeOutside: "Découpage extérieur",
		clipTypeInside: "Découpage intérieur",
		yes: "Oui",
		no: "Non",
		densities: "Densités",
		expectedCounts: "Volumes attendus",
		planar: "plane",
		geodesic: "Géodésique",
		eachCell: "Chaque cellule",
		eachZone: "Chaque zone",
		bestSingle: "Le moins coûteux",
		allSightlines: "Toutes les lignes de visée",
		perimeterSightlines: "Lignes de visée du périmètre",
		frequency: "Fréquence",
		observers: "Points d'observation",
		majority: "Majorité",
		median: "Médian",
		minority: "Minorité",
		percentile: "Centile",
		range: "Plage",
		sum: "Somme",
		variety: "Variété",
		ndvi: "Indice NDVI",
		savi: "SAVI",
		bandArithmeticMethodTSAVI: "SAVI transformé",
		bandArithmeticMethodMSAVI: "SAVI modifié",
		bandArithmeticMethodSultan: "Formule de Sultan",
		gemi: "GEMI",
		pvi: "PVI",
		gvi: "GVI (Landsat TM)",
		vari: "VARI",
		sr: "SR",
		gndvi: "GNDVI",
		ndvire: "NDVIre",
		srre: "SRre",
		mtvi2: "MTVI2",
		rtviCore: "RTVICore",
		cire: "CIre",
		cig: "CIg",
		ndwi: "NDWI",
		evi: "EVI",
		ironOxide: "Oxyde de fer",
		ferrousMinerals: "Minéraux ferreux",
		clayMinerals: "Minéraux argileux",
		wndwi: "WNDWI",
		bai: "BAI",
		mndwi: "MNDWI",
		nbr: "NBR",
		ndbi: "NDBI",
		ndmi: "NDMI",
		ndsi: "NDSI",
		localSquareRoot: "Racine carrée",
		localACos: "ACos",
		localASin: "ASin",
		localATan: "ATan",
		localATanH: "ATanH",
		localAbs: "Abs",
		localBitwiseNot: "Non bit à bit",
		localBooleanNot: "Non booléen",
		localCos: "Cos",
		localCosH: "CosH",
		localExp: "Exp",
		localExp10: "Exp10",
		localExp2: "Exp2",
		localInt: "Entier",
		localIsNull: "Est nul",
		localFloat: "Flottant",
		localLn: "Ln",
		localLog10: "Log10",
		localLog2: "Log2",
		localNegate: "Opposé",
		localRoundDown: "Arrondi inférieur",
		localRoundUp: "Arrondi supérieur",
		localSin: "Sin",
		localSinH: "SinH",
		localTan: "Tan",
		localTanH: "TanH",
		localACosH: "ACosH",
		localASinH: "ASinH",
		localPlus: "Addition",
		localMinus: "Soustraction",
		localTimes: "Multiplier",
		localPower: "Puissance",
		localBitwiseAnd: "Et bit à bit",
		localBitwiseLeftShift: "Décalage à gauche bit à bit",
		localBitwiseOr: "Ou bit à bit",
		localBitwiseRightShift: "Décalage à droite bit à bit",
		localBitwiseXor: "Ou exclusif bit à bit",
		localBooleanAnd: "Et booléen",
		localBooleanOr: "Ou booléen",
		localBooleanXor: "Ou exclusif booléen",
		localDivide: "Division",
		localEqualTo: "Egal à",
		localGreaterThan: "Supérieur à",
		localGreaterThanEqual: "Supérieur ou égal à",
		localLessThan: "Inférieur à",
		localLessThanEqual: "Inférieur ou égal à",
		localMod: "Mod",
		localNotEqual: "Différent de",
		localATan2: "ATan2",
		localSquare: "Carré",
		localSetNull: "SetNull",
		remapDefTypeList: "Liste",
		remapDefTypeTable: "Tableau",
		remapTableTypeSimple: "Simple",
		remapTableTypeDynamic: "Dynamique",
		remapTableTypeReassignment: "Réaffectation",
		geomCorrectionByConstZ: "Utiliser la constante Z",
		geomCorrectionByDEM: "Utiliser MNA",
		radarCalibBetaNought: "Bêta zéro",
		radarCalibSigmaNought: "Sigma zéro",
		radarCalibGammaNought: "Gamma zéro",
		speckleFilterTypeLee: "Filtre LEE",
		speckleFilterTypeEnhancedLee: "Filtre LEE amélioré",
		speckleFilterTypeFrost: "Filtre de givre",
		speckleFilterTypeKuan: "Filtre Kuan",
		speckleNoiseModelMul: "Bruit multiplicatif",
		speckleNoiseModelAdd: "Bruit additif",
		speckleNoiseModelAddnMul: "Bruit additif et multiplicatif",
		mosaicOpTypeFirst: "Premier",
		mosaicOpTypeLast: "Dernier",
		mosaicOpTypeMin: "Min",
		mosaicOpTypeMax: "Max",
		mosaicOpTypeMean: "Moyenne",
		mosaicOpTypeBlend: "Fusionner",
		mosaicOpTypeSum: "Somme",
		integer: "Entier",
		rfxD8: "D8",
		rfxMFD: "MFD",
		dinf: "Dinf",
		vertical: "Verticale",
		horizontal: "Horizontale",
		localCellStatisticsMajority: "Majorité",
		localCellStatisticsMax: "Maximum",
		localCellStatisticsMean: "Moyenne",
		localCellStatisticsMedian: "Médian",
		localCellStatisticsMin: "Minimal",
		localCellStatisticsMinority: "Minorité",
		localCellStatisticsRange: "Plage",
		localCellStatisticsStdDev: "Écart type",
		localCellStatisticsSum: "Somme",
		localCellStatisticsVariety: "Variété",
		localCellStatisticsMajorityIgnoreND: "Majorité (Ignorer NoData)",
		localCellStatisticsMaxIgnoreND: "Maximum (Ignorer NoData)",
		localCellStatisticsMeanIgnoreND: "Moyenne (Ignorer NoData)",
		localCellStatisticsMedianIgnoreND: "Médiane (Ignorer NoData)",
		localCellStatisticsMinIgnoreND: "Minimum (Ignorer NoData)",
		localCellStatisticsMinorityIgnoreND: "Minorité (Ignorer NoData)",
		localCellStatisticsRangeIgnoreND: "Plage (Ignorer NoData)",
		localCellStatisticsStdDevIgnoreND: "Ecart type (Ignorer NoData)",
		localCellStatisticsSumIgnoreND: "Somme (Ignorer NoData)",
		localCellStatisticsVarietyIgnoreND: "Variété (Ignorer NoData)",
		localCellStatisticsTypePercentileIgnoreND: "Centile (Ignorer les valeurs NoData)",
		fromSource: "À partir de la source",
		toSource: "Vers la source",
		colorspaceConversionRgbToHsv: "RVB vers TSL",
		colorspaceConversionHsvToRgb: "TSL vers RVB",
		pansharpenTypeIHS: "IHS",
		pansharpenTypeBrovey: "Brovey",
		pansharpenTypeEsri: "Esri",
		pansharpenTypeMean: "Moyenne",
		pansharpenTypeGramSchmidt: "Gram-Schmidt",
		rectangleNeighborhood: "Rectangle",
		circleNeighborhood: "Cercle",
		annulusNeighborhood: "Anneau",
		wedgeNeighborhood: "Secteur",
		irregularNeighborhood: "Irrégulière",
		weightNeighborhood: "Pondération",
		four: "Four",
		eight: "Eight",
		within: "Dans",
		cross: "Croiser",
		addLink: "Ajouter un lien",
		noLink: "Aucun lien",
		weightedMean: "Moyenne pondérée",
		ls8QCBitPatternCirrus: "Landsat 8 Cirrus",
		ls8QCBitPatternCloud: "Landsat 8 Nuage",
		ls8QCBitPatternCloudShadow: "Landsat 8 Ombre nuage",
		ls8QCBitPatternDesignatedFill: "Landsat 8 Remplissage désigné",
		ls8QCBitPatternDroppedFrame: "Landsat 8 Image déplacée",
		ls8QCBitPatternSnowIce: "Landsat 8 Neige/glace",
		ls8QCBitPatternTerrainOcclusion: "Landsat 8 Occlusion de terrain",
		ls8QCBitPatternVegetation: "Landsat 8 Végétation",
		ls8QCBitPatternWater: "Landsat 8 Eau",
		downStream: "En aval",
		upStream: "En amont",
		strahler: "STRAHLER",
		shreve: "SHREVE",
		currentSlice: "Coupe actuelle",
		allSlices: "Toutes les coupes",
		expandDistance: "DISTANCE",
		expandMorphological: "MORPHOLOGIQUE",
		spectralProfileFile: "Profil spectral",
		trainingFeatureFile: "Entité d’entraînement",
		randomDistributionTypeUniform: "Uniforme",
		randomDistributionTypeUniformInteger: "Entiers",
		randomDistributionTypeNormal: "Normale",
		randomDistributionTypeExponential: "Exponentielle",
		randomDistributionTypePoisson: "Poisson",
		randomDistributionTypeGamma: "Gamma",
		randomDistributionTypeBinomial: "Binomiale",
		randomDistributionTypeGeometric: "Géométrique",
		randomDistributionTypeNegativeBinomial: "Binomiale négative",
		randomGeneratorTypeStandardCRand: "Standard C Rand",
		randomGeneratorTypeAlgorithmACM599: "Algorithme de collecte ACM 599",
		randomGeneratorTypeMersenneTwister: "Mersenne Twister",
		sumName: "Somme",
		medainName: "Médiane",
		trendLinear: "Linéaire",
		trendHarmonic: "Harmonique",
		trendPolynomial: "Polynomiale",
		trendMannKendall: "Mann-Kendall",
		trendSeasonalKendall: "Kendall saisonnier",
		dimensionByValue: "Par valeur",
		dimensionByInterval: "Par intervalle",
		mdimDefTypeAll: "chacune",
		mdimDefTypeByValues: "By Values (Par valeurs)",
		mdimDefTypeByRanges: "By Ranges (Par plages)",
		mdimDefTypeByIteration: "By Iteration (Par itération)",
		mdimDefTypeByInterval: "Par intervalle",
		mdimDefTypeByTargetRaster: "Par raster cible",
		esriTimeUnitsHours: "Heures",
		esriTimeUnitsDays: "Jours",
		esriTimeUnitsWeeks: "Semaines",
		esriTimeUnitsMonths: "Mois",
		esriTimeUnitsYears: "Années",
		esriTimeIntervalKeywordHourly: "Par heure",
		esriTimeIntervalKeywordDaily: "Par jour",
		esriTimeIntervalKeywordWeekly: "Par semaine",
		esriTimeIntervalKeywordDekadly: "Par 10 jours",
		esriTimeIntervalKeywordPentadly: "Par 5 jours",
		esriTimeIntervalKeywordMonthly: "Par mois",
		esriTimeIntervalKeywordQuarterly: "Par trimestre",
		esriTimeIntervalKeywordYearly: "Par an",
		esriTimeIntervalKeywordRecurringDaily: "Récurrence quotidienne",
		esriTimeIntervalKeywordRecurringWeekly: "Récurrence hebdomadaire",
		esriTimeIntervalKeywordRecurringMonthly: "Récurrence mensuelle",
		esriTimeIntervalKeywordRecurringQuarterly: "Récurrence trimestrielle",
		aggDefTypeAll: "Tout",
		aggDefTypeIntervalKeyword: "Mot-clé de l’intervalle",
		aggDefTypeIntervalValue: "Valeur de l’intervalle",
		aggDefTypeIntervalRanges: "Plages d’intervalle",
		latestChange: "Heure du dernier changement",
		earliestChange: "Heure du premier changement",
		largestChange: "Heure du changement le plus important",
		numberOfChanges: "Nombre de changements",
		longestChange: "Date/heure du plus long changement",
		shortestChange: "Date/heure du plus court changement",
		fastestChange: "Date/heure du changement le plus rapide",
		slowestChange: "Date/heure du changement le plus lent",
		allChanges: "Tout",
		increaseChanges: "Augmenter",
		decreaseChanges: "Diminuer",
		segmentBeginning: "Début du segment",
		segmentEnd: "Fin du segment",
		esriComputeChangeMethodDifference: "Différence",
		esriComputeChangeMethodRelativeDifference: "Différence relative",
		esriComputeChangeMethodCategorical: "Différence catégorielle",
		esriComputeChangeMethodMultispectralEuclideanDistance: "Distance euclidienne spectrale",
		esriComputeChangeMethodMultispectralAngularDifference: "Écart de l’angle spectral",
		esriComputeChangeMethodMultispectralAxisWithBiggestChange: "Bande avec le plus de changements",
		esriComputeChangeKeepAll: "Tout conserver",
		esriComputeChangeKeepChangedOnly: "Conserver uniquement les pixels ayant changé",
		esriComputeChangeKeepUnchangedOnly: "Conserver uniquement les pixels inchangés",
		esriComputeChangeUseColorAverage: "Utiliser la moyenne des couleurs d’origine et de destination",
		esriComputeChangeUseColorFrom: "Utiliser les couleurs d’origine",
		esriComputeChangeUseColorTo: "Utiliser les couleurs de destination",
		factorFunctionBinary: "Binaire",
		factorFunctionForward: "Avant",
		factorFunctionLinear: "Linéaire",
		factorFunctionInvLinear: "Linéaire inverse",
		factorFunctionTable: "Table",
		factorFunctionSymLinear: "Linéaire symétrique",
		factorFunctionSymInvLinear: "Linéaire symétrique inverse",
		factorFunctionCos: "Cosinus",
		factorFunctionSec: "Sécante",
		factorFunctionCosSec: "Cosinus - Sécante",
		factorFunctionSecCos: "Sécante - Cosinus",
		noSort: "Ne pas trier",
		ascend: "Croissant",
		descend: "Décroissant",
		autoDetect: "Détection automatique",
		nearest: "Le plus proche",
		linear: "Linéaire",
		esriMonthJanuary: "Janvier",
		esriMonthFebruary: "Février",
		esriMonthMarch: "Mars",
		esriMonthApril: "Avril",
		esriMonthMay: "Mai",
		esriMonthJune: "Juin",
		esriMonthJuly: "Juillet",
		esriMonthAugust: "Août",
		esriMonthSeptember: "Septembre",
		esriMonthOctober: "Octobre",
		esriMonthNovember: "Novembre",
		esriMonthDecember: "Décembre",
		dimensionalMovingIgnoreNoData: "Données",
		dimensionalMovingPropagateNoData: "NoData",
		dimensionalMovingFillOnlyNoData: "Remplir les valeurs NoData",
		circularMean: "Moyenne circulaire",
		circularName: "Circulaire",
		arithmeticName: "Arithmétique",
		slopeName: "Pente",
		aspectName: "Exposition",
		meanCurvature: "Courbure moyenne",
		profileCurvature: "Courbure longitudinale (ligne de pente normale)",
		tangentialCurvature: "Courbure tangentielle (isoligne normale)",
		planCurvature: "Courbure transversale (isoligne projetée)",
		contourGeodesicTorsion: "Torsion géodésique des isolignes",
		gaussianCurvature: "Courbure gaussienne",
		casoratiCurvature: "Courbure Casorati",
		localSurfaceTypeQuadratic: "Quadratique",
		localSurfaceTypeBiquadratic: "Biquadratique",
		thresholdNoThreshold: "Aucun seuil",
		thresholdPercentLeastCost: "Pourcentage de moindre coût",
		thresholdAccumulativeCost: "Coût cumulé",
		clrmapTypeHillshade: "Ombrage"
	},
	categoryLabels: {
		sourceCharacteristics: "Caractéristiques source",
		neighborhoodSettings: "Paramètres de voisinage",
		statistics: "Statistiques",
		gamma: "Gamma",
		viewshedParameters: "Paramètres du champ de vision",
		observerParameters: "Paramètres du point d'observation",
		irregularDataInterpolation: "Interpolation des données irrégulières",
		modelStatistics: "Statistiques du modèle",
		aggregationDef: "Définition de l’agrégation",
		filterByAttributes: "Filtrer par attributs",
		percentileName: "Centile",
		rasterInfo: "Informations raster",
		extent: "Étendue",
		spatialReference: "Référence spatiale"
	},
	outputRasterHelpTexts: {
		outputName: "<p>Nom de la couche à créer et ajouter à la carte.</p>",
		resultType: "<p>Type de sortie à créer. Les sorties peuvent être des couches d’imagerie tuilée ou des couches d’imagerie dynamique.</p>",
		saveResultIn: "<p>Nom du dossier de <b>Mes contenus</b> dans lequel le résultat sera enregistré.</p>"
	},
	analysisEnvironmentsHelpTexts: {
		description: "<p>Paramètres d’environnement pour l’analyse dans Map Viewer. </p>",
		outSR: "<p>Spécifie le système de coordonnées pour l’analyse et la couche de résultat.</p>",
		extent: "<p>Spécifie la zone à utiliser pour l’analyse.</p>",
		snapRaster: "<p>Ajuste l’étendue de la sortie afin qu’elle corresponde à l’alignement des cellules de la couche de raster de capture spécifiée.</p>",
		cellSize: "<p>Spécifie la taille de cellule ou la résolution à utiliser pour l’analyse et pour créer la couche raster en sortie.</p>",
		mask: "<p>Spécifie une couche de masque dans laquelle seules les cellules qui se trouvent dans la zone de masque sont utilisées pour l’analyse.</p>",
		resamplingMethod: "<p>Indique comment interpoler les valeurs de pixel si les rasters en entrée et en sortie ne correspondent pas.</p>"
	},
	mainGenStrings: {
		unsupportedDataType: "Type non pris en charge",
		currentlyUnsupported: " Un éditeur par défaut pour ${missingType} est en attente, mais sera bientôt disponible. Espace réservé temporaire pour la zone de texte destinée à la spécification des entrées sous forme de chaînes.",
		unsupportedOverrideWarning: "Un composant d’éditeur de remplacement proposant une expérience utilisateur améliorée pour l’utilisation des paramètres suivants est en attente, mais sera bientôt disponible :",
		overrideWidgetMissing: "Composant d’éditeur de remplacement manquant.",
		uiIncomplete: "Échec de l’envoi de la tâche. La fonction ne peut pas s’exécuter car certains champs obligatoires sont incomplets ou manquants dans l’interface utilisateur.",
		count: "Nombre",
		selectVariables: "Sélectionner des variables",
		selectFeature: "Sélectionner une couche d’entités",
		greaterThanErrorMessage: "Le nombre en entrée doit être supérieur à ${min}",
		lesserThanErrorMessage: "Le nombre en entrée doit être inférieur à ${max}",
		greaterThanOrEqualErrorMessage: "Le nombre en entrée doit être supérieur ou égal à ${min}",
		lesserThanOrEqualErrorMessage: "Le nombre en entrée doit être inférieur ou égal à ${max}",
		allowScalar: "Sélectionner une couche ou saisir une constante",
		selectField: "Sélectionner un champ",
		parameterRequired: "Ce paramètre est obligatoire.",
		enterAValue: "Saisir une valeur...",
		invalidInput: "La valeur saisie n’est pas valide.",
		itemNotFound: "L’élément n’existe pas ou est inaccessible.",
		itemPermissionDenied: "Vous n’êtes pas autorisé à accéder à cet élément.",
		layerNotAvailable: "Échec du chargement de la couche ${layerName}.",
		multipleLayersNotAvailable: "Échec du chargement de la couche ${layerName} et d’autres couches.",
		learnMoreLabel: "En savoir plus",
		fieldNotAvailable: "Échec du chargement du champ.",
		allowAnalysis: "L’analyse n’est pas autorisée sur le service d’imagerie.",
		allowAnalysisReason: "Une ou plusieurs couches de la carte ne sont pas répertoriées ici car elles n’autorisent pas l’analyse.",
		learnMoreText: "En savoir plus",
		atLeastOneRasterInput: "Au moins une couche en entrée doit être une couche raster.",
		browseAnalysisLayers: "Rechercher des couches",
		activeMapViewExtent: "Utiliser l’étendue actuelle de la carte",
		chooseRaster: "Choisir le raster de découpage",
		chooseGeometry: "Choisir la géométrie de découpage",
		resultType: "Type de résultat",
		saveInFolder: "Enregistrer dans un dossier",
		outputName: "Nom en sortie",
		outputLayerType: "Type de couche en sortie",
		dynamicImageryLayer: "Couche d’imagerie dynamique",
		tiledImageryLayer: "Couche d’imagerie tuilée",
		custom: "Personnalisé",
		loading: "Chargement...",
		layerMissing: "Une ou plusieurs couches de la carte ne sont pas répertoriées ici car elles n’autorisent pas l’analyse. En savoir plus.",
		browseCoordinateSystems: "Parcourir les systèmes de coordonnées",
		unableToRepopulateOutSR: "Impossible de renseigner le système de coordonnées en sortie.",
		defaultTitle: "Plus",
		"ARC (equal arc-second)": "ARC (Equal Arc-Second)",
		Africa: "Afrique",
		Antarctica: "Antarctique",
		Argentina: "Argentine",
		Asia: "Asie",
		"Asteroid Belt": "Ceinture d’astéroïdes",
		"Atlantic Ocean": "Océan Atlantique",
		Australia: "Australie",
		"Australia and New Zealand": "Australie et Nouvelle-Zélande",
		Austria: "Autriche",
		"BLM (US Feet)": "BLM (Pieds américains)",
		Bangladesh: "Bangladesh",
		"Beijing 1954": "Beijing 1954",
		Bhutan: "Bhoutan",
		CGCS2000: "CGCS2000",
		Canada: "Canada",
		Caribbean: "Caraïbes",
		"Caribbean Sea": "Mer des Caraïbes",
		"Central America": "Amérique centrale",
		"Central and North America": "Amérique centrale et du Nord",
		Colombia: "Colombie",
		Continental: "Continentaux",
		"County Systems": "Systèmes de comtés",
		"Democratic Republic of the Congo": "République démocratique du Congo",
		"EPSG Arctic": "EPSG Arctic",
		Earth: "Terre",
		"Ellipsoidal-based": "Ellipsoïde",
		Europe: "Europe",
		Finland: "Finlande",
		France: "France",
		"GSK 2011": "GSK 2011",
		"Gauss Kruger": "Gauss-Krüger",
		"Geographic Coordinate Systems": "Systèmes de coordonnées géographiques",
		Germany: "Allemagne",
		"Gravity-related": "Gravité",
		"Greenwich-based": "Greenwich",
		"Highways England": "Highways England",
		Illinois: "Illinois",
		"Indian Ocean": "Océan Indien",
		"Indian Subcontinent": "Sous-continent indien",
		Indiana: "Indiana",
		Indonesia: "Indonésie",
		Iowa: "Iowa",
		"Ireland and United Kingdom": "Irlande et Royaume-Uni",
		Italy: "Italie",
		Japan: "Japon",
		Jupiter: "Jupiter",
		Kansas: "Kansas",
		"Las Vegas": "Las Vegas",
		Libya: "Libye",
		Malaysia: "Malaisie",
		"Malaysia and Singapore": "Malaisie et Singapour",
		Mars: "Mars",
		Mercury: "Mercure",
		Minnesota: "Minnesota",
		Montana: "Montana",
		"NAD 1927": "NAD 1927",
		"NAD 1927 (US Feet)": "NAD 1927 (Pieds américains)",
		"NAD 1983": "NAD 1983",
		"NAD 1983 (2011)": "NAD 1983 (2011)",
		"NAD 1983 (2011) (Intl Feet)": "NAD 1983 (2011) (Pieds internationaux)",
		"NAD 1983 (2011) (Meters)": "NAD 1983 (2011) (Mètres)",
		"NAD 1983 (2011) (US Feet)": "NAD 1983 (2011) (Pieds américains)",
		"NAD 1983 (CORS96) (Intl Feet)": "NAD 1983 (CORS96) (Pieds internationaux)",
		"NAD 1983 (CORS96) (Meters)": "NAD 1983 (CORS96) (Mètres)",
		"NAD 1983 (CORS96) (US Feet)": "NAD 1983 (CORS96) (Pieds américains)",
		"NAD 1983 (Intl Feet)": "NAD 1983 (Pieds internationaux)",
		"NAD 1983 (Meters)": "NAD 1983 (Mètres)",
		"NAD 1983 (PA11) (Meters)": "NAD 1983 (PA11) (Mètres)",
		"NAD 1983 (PA11) (US Feet)": "NAD 1983 (PA11) (Pieds américains)",
		"NAD 1983 (US Feet)": "NAD 1983 (Pieds américains)",
		"NAD 1983 HARN (Intl Feet)": "NAD 1983 HARN (Pieds internationaux)",
		"NAD 1983 HARN (Meters)": "NAD 1983 HARN (Mètres)",
		"NAD 1983 HARN (US Feet)": "NAD 1983 HARN (Pieds américains)",
		"NAD 1983 NSRS2007 (Intl Feet)": "NAD 1983 NSRS2007 (Pieds internationaux)",
		"NAD 1983 NSRS2007 (Meters)": "NAD 1983 NSRS2007 (Mètres)",
		"NAD 1983 NSRS2007 (US Feet)": "NAD 1983 NSRS2007 (Pieds américains)",
		"National Grids": "Grilles nationales",
		Navajo: "Navajo",
		Neptune: "Neptune",
		"New Beijing": "New Beijing",
		"New Zealand": "Nouvelle-Zélande",
		"North America": "Amérique du Nord",
		"Northern Hemisphere": "Hémisphère Nord",
		Norway: "Norvège",
		Oceans: "Océans",
		Oregon: "Oregon",
		"Other GCS": "Autre GCS",
		"Pacific Ocean": "Océan Pacifique",
		Pluto: "Pluton",
		Polar: "Polaires",
		Portugal: "Portugal",
		"Projected Coordinate Systems": "Systèmes de coordonnées projetées",
		"Pulkovo 1942": "Pulkovo 1942",
		"Pulkovo 1995": "Pulkovo 1995",
		Replaced: "Remplacés",
		"SAD 1969": "SAD 1969",
		SIRGAS: "SIRGAS",
		"SIRGAS 2000": "SIRGAS 2000",
		Saturn: "Saturne",
		"Solar System": "Système solaire",
		"South Africa": "Afrique du Sud",
		"South America": "Amérique du Sud",
		"South Korea": "Corée du Sud",
		"Southern Hemisphere": "Hémisphère Sud",
		"Spheroid-based": "Basés sur un sphéroïde",
		"State Plane": "State Plane",
		"State Systems": "Systèmes d’État",
		Sweden: "Suède",
		"Switzerland and Liechtenstein": "Suisse et Liechtenstein",
		Texas: "Texas",
		Tribal: "Tribaux",
		Turkey: "Turquie",
		"US Feet": "Pieds américains",
		"USA and territories": "États-Unis et territoires",
		UTM: "UTM",
		Ukraine: "Ukraine",
		"Unknown Height Systems": "Système altimétrique inconnu",
		Uranus: "Uranus",
		Venus: "Vénus",
		"Vertical Coordinate Systems": "Systèmes de coordonnées verticales",
		Vietnam: "Vietnam",
		"WGS 1972": "WGS 1972",
		"WGS 1984": "WGS 1984",
		Wisconsin: "Wisconsin",
		"Wisconsin CRS": "Wisconsin CRS",
		World: "Monde",
		"World (Sphere-based)": "Monde (basés sur une sphère)",
		Wyoming: "Wyoming",
		"Xian 1980": "Xian 1980",
		done: "Terminé",
		noResults: "Aucun résultat trouvé",
		searchPlaceholder: "Nom ou WKID",
		browseTemplate: "Parcourir les modèles de fonction raster",
		saveTemplate: "Enregistrer le modèle de fonction raster",
		preview: "Aperçu",
		previewDescription: "Affichez un aperçu du résultat avant d’exécuter l’analyse.",
		showPreview: "Afficher un aperçu",
		previewLayer: "Couche d’aperçu ${number}",
		newPreview: "Nouvel aperçu",
		previewPopup: "Activer l’affichage d’un aperçu des résultats d’analyse en fonction des paramètres en entrée.",
		updatePreviewLayer: "Mettre à jour la couche d’aperçu sélectionnée",
		createPreviewLayer: "Créer une nouvelle couche d’aperçu",
		maximumPreviewAllowed: "Nombre maximal de couches d’aperçu autorisé : ${maxCount}",
		previewFailure: "Cette couche d’aperçu n’est pas disponible. Vérifiez les paramètres en entrée et procédez à une nouvelle mise à jour de cette couche d’aperçu.",
		header: "Sélectionner un élément",
		content: "Certaines modifications ne sont pas enregistrées dans ${rftTitle}. Si vous recommencez avec un nouveau modèle, ces modifications seront perdues.",
		dontSave: "Ne pas enregistrer",
		"continue": "Continuer",
		stretch: "Ajuster à la fenêtre",
		pan: "Déplacer",
		newTemplate: "Créer un nouveau modèle",
		openTemplate: "Ouvrir un modèle",
		addFunction: "Ajouter des fonctions raster",
		addConstant: "Ajouter une constante",
		addRaster: "Ajouter une variable raster",
		move: "Déplacer",
		zoom: "Zoom",
		saveAs: "Enregistrer sous",
		clear: "Effacer",
		addRasterFunctionTitle: "Ajouter des fonctions raster",
		templatePropertiesTitle: "Propriétés du modèle",
		browseRFT: "Parcourir les modèles de fonction raster",
		defaultToolDescription: "Outil d’analyse ${toolTitle}.",
		openToolText: "Ouvrir l’outil",
		toolDropdownText: "Menu déroulant de l’outil",
		addToMap: "Confirmer et ajouter à la carte",
		confirm: "Confirmer",
		select: "Sélectionner",
		selectTask: "Sélectionner une tâche",
		unsupportedLayer: "Ce paramètre ne prend pas en charge les couches suivantes : ${layerName}.",
		viewDetails: "Afficher les détails complets de l’élément",
		rename: "Renommer",
		duplicate: "Dupliquer",
		launch: "Ouvrir pour exécuter",
		templateEditor: "Éditeur de modèle",
		createItem: "Enregistrer le modèle de fonction raster",
		actionLabel: "Filtrer",
		filterPopoverHeading: "Filtrer les fonctions",
		defaultSearchPlaceholder: "Rechercher par nom",
		settings: "Paramètres",
		summary: "Résumé",
		definitionQuery: "Ensemble de définition",
		matchVariables: "Apparier les variables",
		unionDimension: "Union des dimensions",
		nameEditorPlaceholder: "Saisir un titre",
		summaryEditorPlaceholder: "Saisir une brève description",
		definitionQueryPlaceholder: "Saisir...",
		upload: "Charger",
		chooseImage: "Cliquer pour choisir un fichier",
		update: "Mettre à jour",
		thumbnailErrors: {
			wrongImageType: "Type d’image sélectionné incorrect",
			notAvailable: "Miniature non disponible",
			loadError: "Impossible de charger l’image",
			chooseFile: "Cliquer pour choisir un fichier"
		}
	}
};
const copy = "Copier";
const save = "Enregistrer";
const title = "Titre";
const folder = "Dossier";
const tags = "Balises";
const savingMessage = "Enregistrement de l'élément dans";
const shareWith = "Partager avec";
const share = "Partager";
const setSharingLevel = "Définir le niveau de partage";
const setGroupSharing = "Configurer le partage de groupe";
const owner = "Propriétaire";
const organization = "Organisation";
const everyone = "Tout le monde (public)";
const groups = "Groupes :";
const type = "Type";
const mosaic = "Mosaïque";
const itemGroup = "Groupe d’éléments";
const item = "Elément";
const definitionQuery = "Ensemble de définition";
const groupItemsBy = "Grouper les éléments par";
const groupFieldName = "Nom du champ de groupe";
const tagFieldName = "Nom du champ de balise";
const noTitleTagErrorMsg = "Vous devez attribuer un titre à votre élément et des balises pour que les recherches permettent de trouver la carte.";
const noTitleErrorMsg = "Vous devez fournir un titre pour votre élément.";
const noTagErrorMsg = "Vous devez fournir au moins une balise pour aider les utilisateurs à trouver votre élément au moyen de recherches.";
const error = "Erreur";
const warning = "Avertissement";
const success = "Opération réussie";
const details = "Détails :";
const tryAgain = "Réessayer";
const toolModeler = {
	save: "Enregistrer",
	editProperties: "Mettre à jour les propriétés",
	saveAs: "Enregistrer sous",
	savingNotification: "Enregistrement des modifications apportées à l’élément...",
	savingTitle: "Enregistrement",
	saveFailedMessage: "L'enregistrement des modifications a échoué.",
	saveWithErrorsMessage: "Les modifications ont été enregistrées avec les erreurs suivantes.",
	viewItemMessage: "Afficher l’élément enregistré",
	here: "ici.",
	itemCreatedMessage: "Le nouvel élément a été créé.",
	clickToViewItemMessage: "Cliquez sur OK pour afficher la page des détails de l’élément ou cliquez sur Annuler pour continuer.",
	readingFailed: "Échec du chargement du modèle de fonction raster sélectionné.",
	failedToLoadXML: "Échec du chargement du modèle de fonction raster sélectionné au format XML.",
	learnMore: "En savoir plus",
	overwriteTitle: "Confirmer le remplacement",
	overwriteMessage: "Souhaitez-vous remplacer l’élément existant ?",
	overwriteSuccessMessage: "L’élément a été mis à jour."
};
const toolEditor = {
	run: "Exécuter",
	save: "Enregistrer",
	deleteSelected: "Supprimer les éléments sélectionnés",
	addRaster: "Ajouter un raster",
	addScalar: "Ajouter une valeur scalaire",
	layout: "Mise en page automatique",
	errorTitle: "Erreur",
	invalidToolMessage: "Le modèle de fonction raster n’est pas valide.",
	out: "Dehors",
	zoomIn: "Zoom avant",
	zoomOut: "Zoom arrière",
	zoomToFit: "Ajuster à la fenêtre",
	panOn: "Activer le mode de déplacement",
	panOff: "Désactiver le mode de déplacement",
	defaultModelName: "Modèle d’outil",
	defaultRasterName: "Raster"
};
const toolDetailsEditor = {
	defaultToolName: "Modèle de fonction raster",
	defaultToolDescription: "Ajoutez un bref résumé de la fonction raster.",
	defaultHelpText: "Cliquez sur l’icône d’aide pour mettre à jour le texte d'aide",
	editHelpTitle: "Aide pour la mise à jour",
	saveLabel: "Enregistrer",
	cancelLabel: "Annuler",
	thumbnail: {
		wrongImageType: "Type d’image sélectionné incorrect",
		notAvailable: "Miniature indisponible",
		loadError: "Impossible de charger l’image",
		chooseFile: "Cliquez pour sélectionner un fichier"
	}
};
const saveUtils = {
	thumbnail: "Miniature",
	sharing: "Partage"
};
const close = "Fermer";
const unsavedWarningExisting = "Souhaitez-vous enregistrer les modifications apportées à l’élément <b>${itemTitle}</b> ?";
const unsavedWarningNew = "Souhaitez-vous enregistrer vos modifications ?";
const saveAs = "Enregistrer sous";
const dontSave = "Ne pas enregistrer";
const unsavedTitle = "Modifications non enregistrées";
const invalidRFTMessage = "Le modèle de fonction raster créé n’est pas valide.";
const errorTitle = "Erreur";
const breadcrumb = "Éditeur de fonctions raster";
const breadcrumbEditor = "Contenu > Éditeur de fonctions raster";
const viewerModeTitle = "Lecture seule";
const viewerModeMessage = "L’élément de modèle de fonction raster est en lecture seule. Les modifications ne peuvent pas être enregistrées.";
const userStartDirection = "Sélectionnez une fonction pour commencer à générer un modèle de fonction raster.";
const selectFunction = "Ajouter une fonction";
const deselectFunction = "Supprimer une fonction";
const dialogTitle = "Système";
const category = "Catégories";
const search = "Rechercher les fonctions raster";
const categoryNames = {
	analysis: "Analyse",
	appearance: "Apparence",
	classification: "Classification",
	conversion: "Conversion",
	correction: "Correction",
	dataManagement: "Gestion des données",
	distance: "Distance",
	distanceLegacy: "Distance (existante)",
	hydrology: "Hydrologie",
	math: "Mathématiques",
	mathConditional: "Mathématiques : conditionnelles",
	mathLogical: "Mathématiques : logiques",
	mathTrigonometric: "Mathématiques : trigonométriques",
	reclass: "Reclassement",
	statistical: "Statistique",
	surface: "Surface"
};
const commonStrings_fr = {
	ok: ok,
	cancel: cancel,
	enterURL: enterURL,
	serviceURL: serviceURL,
	selectRaster: selectRaster,
	failedToLoadLayer: failedToLoadLayer,
	loadingLayer: loadingLayer,
	selectFeature: selectFeature,
	enterFURL: enterFURL,
	addRaster: addRaster,
	addScalar: addScalar,
	raster: raster,
	scalar: scalar,
	defaultModelName: defaultModelName,
	general: general,
	parameters: parameters,
	variables: variables,
	name: name,
	description: description,
	parameter: parameter,
	isPublic: isPublic,
	isDataset: isDataset,
	unknownPixelType: unknownPixelType,
	outputPixelType: outputPixelType,
	u8PixelType: u8PixelType,
	s8PixelType: s8PixelType,
	u16PixelType: u16PixelType,
	s16PixelType: s16PixelType,
	u32PixelType: u32PixelType,
	s32PixelType: s32PixelType,
	f32PixelType: f32PixelType,
	f64PixelType: f64PixelType,
	properties: properties,
	multidimensionalRules: multidimensionalRules,
	matchVariables: matchVariables,
	unionDimensions: unionDimensions,
	rasterFunctionEditor: rasterFunctionEditor,
	rfxLicenseInfo: rfxLicenseInfo,
	rasterFunctions: rasterFunctions,
	copy: copy,
	save: save,
	title: title,
	folder: folder,
	tags: tags,
	savingMessage: savingMessage,
	shareWith: shareWith,
	share: share,
	setSharingLevel: setSharingLevel,
	setGroupSharing: setGroupSharing,
	owner: owner,
	organization: organization,
	everyone: everyone,
	groups: groups,
	type: type,
	mosaic: mosaic,
	itemGroup: itemGroup,
	item: item,
	definitionQuery: definitionQuery,
	groupItemsBy: groupItemsBy,
	groupFieldName: groupFieldName,
	tagFieldName: tagFieldName,
	noTitleTagErrorMsg: noTitleTagErrorMsg,
	noTitleErrorMsg: noTitleErrorMsg,
	noTagErrorMsg: noTagErrorMsg,
	error: error,
	warning: warning,
	success: success,
	details: details,
	tryAgain: tryAgain,
	toolModeler: toolModeler,
	toolEditor: toolEditor,
	toolDetailsEditor: toolDetailsEditor,
	saveUtils: saveUtils,
	close: close,
	unsavedWarningExisting: unsavedWarningExisting,
	unsavedWarningNew: unsavedWarningNew,
	saveAs: saveAs,
	dontSave: dontSave,
	unsavedTitle: unsavedTitle,
	invalidRFTMessage: invalidRFTMessage,
	errorTitle: errorTitle,
	breadcrumb: breadcrumb,
	breadcrumbEditor: breadcrumbEditor,
	viewerModeTitle: viewerModeTitle,
	viewerModeMessage: viewerModeMessage,
	userStartDirection: userStartDirection,
	selectFunction: selectFunction,
	deselectFunction: deselectFunction,
	dialogTitle: dialogTitle,
	category: category,
	search: search,
	categoryNames: categoryNames
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (commonStrings_fr);


//# sourceMappingURL=common-strings.fr-f066cbe6.js.map

/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid2lkZ2V0cy9jaHVua3MvYXJjZ2lzX2FuYWx5c2lzX25vZGVfbW9kdWxlc19hcmNnaXNfYXJjZ2lzLXJhc3Rlci1mdW5jdGlvbi1lZGl0b3JfLTY1MmIwYi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa29CQUFrb0I7QUFDbG9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrMkJBQSsyQjtBQUMvMkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHEwQ0FBcTBDLHdWQUF3VjtBQUM3cEQ7QUFDQTtBQUNBLDZMQUE2TDtBQUM3TDtBQUNBO0FBQ0Esc2tJQUFza0ksdU9BQXVPLCtaQUErWjtBQUM1c0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDgzR0FBODNHLE9BQU87QUFDcjRHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSx1REFBdUQsYUFBYTtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RUFBd0UsSUFBSTtBQUM1RSx1RUFBdUUsSUFBSTtBQUMzRSx1RkFBdUYsSUFBSTtBQUMzRixzRkFBc0YsSUFBSTtBQUMxRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxVQUFVO0FBQ25FLGtFQUFrRSxXQUFXO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLE9BQU87QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRUFBMEUsU0FBUztBQUNuRjtBQUNBO0FBQ0Esb0VBQW9FLFNBQVM7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsVUFBVTtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRkFBbUYsVUFBVTtBQUM3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3R0FBd0csVUFBVTtBQUNsSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlFQUFlLGdCQUFnQixFQUFDO0FBQ2lvQzs7QUFFanFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZXhiLWNsaWVudC8uL2V4dGVuc2lvbnMvd2lkZ2V0cy9hcmNnaXMvYW5hbHlzaXMvbm9kZV9tb2R1bGVzL0BhcmNnaXMvYXJjZ2lzLXJhc3Rlci1mdW5jdGlvbi1lZGl0b3IvZGlzdC9lc20vY29tbW9uLXN0cmluZ3MuZnItZjA2NmNiZTYuanMiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3Qgb2sgPSBcIk9LXCI7XG5jb25zdCBjYW5jZWwgPSBcIkFubnVsZXJcIjtcbmNvbnN0IGVudGVyVVJMID0gXCJTYWlzaXIgbOKAmVVSTCBkdSBzZXJ2aWNlIGTigJlpbWFnZXJpZVwiO1xuY29uc3Qgc2VydmljZVVSTCA9IFwiVVJMIGR1IHNlcnZpY2VcIjtcbmNvbnN0IHNlbGVjdFJhc3RlciA9IFwiU8OpbGVjdGlvbm5lciB1biByYXN0ZXJcIjtcbmNvbnN0IGZhaWxlZFRvTG9hZExheWVyID0gXCLDiWNoZWMgZHUgY2hhcmdlbWVudCBkZSBsYSBjb3VjaGVcIjtcbmNvbnN0IGxvYWRpbmdMYXllciA9IFwiQ2hhcmdlbWVudCBkZSBsYSBjb3VjaGVcIjtcbmNvbnN0IHNlbGVjdEZlYXR1cmUgPSBcIlPDqWxlY3Rpb25uZXIgdW5lIGNvdWNoZSBk4oCZZW50aXTDqXNcIjtcbmNvbnN0IGVudGVyRlVSTCA9IFwiU2Fpc2lyIGzigJlVUkwgZHUgc2VydmljZSBk4oCZZW50aXTDqXNcIjtcbmNvbnN0IGFkZFJhc3RlciA9IFwiQWpvdXRlciB1bmUgdmFyaWFibGUgcmFzdGVyXCI7XG5jb25zdCBhZGRTY2FsYXIgPSBcIkFqb3V0ZXIgdW5lIGNvbnN0YW50ZVwiO1xuY29uc3QgcmFzdGVyID0gXCJSYXN0ZXJcIjtcbmNvbnN0IHNjYWxhciA9IFwiU2NhbGFpcmVcIjtcbmNvbnN0IGRlZmF1bHRNb2RlbE5hbWUgPSBcIk1vZMOobGUgZGUgZm9uY3Rpb24gcmFzdGVyXCI7XG5jb25zdCBnZW5lcmFsID0gXCJHw6luw6lyYWxpdMOpc1wiO1xuY29uc3QgcGFyYW1ldGVycyA9IFwiUGFyYW3DqHRyZXNcIjtcbmNvbnN0IHZhcmlhYmxlcyA9IFwiVmFyaWFibGVzXCI7XG5jb25zdCBuYW1lID0gXCJOb21cIjtcbmNvbnN0IGRlc2NyaXB0aW9uID0gXCJEZXNjcmlwdGlvblwiO1xuY29uc3QgcGFyYW1ldGVyID0gXCJQYXJhbcOodHJlXCI7XG5jb25zdCBpc1B1YmxpYyA9IFwiRXN0UHVibGljXCI7XG5jb25zdCBpc0RhdGFzZXQgPSBcIkpldSBkZSBkb25uw6llc1wiO1xuY29uc3QgdW5rbm93blBpeGVsVHlwZSA9IFwiSW5jb25udVwiO1xuY29uc3Qgb3V0cHV0UGl4ZWxUeXBlID0gXCJUeXBlIGRlIHBpeGVsIGVuIHNvcnRpZVwiO1xuY29uc3QgdThQaXhlbFR5cGUgPSBcIk5vbiBzaWduw6kgOCBiaXRzXCI7XG5jb25zdCBzOFBpeGVsVHlwZSA9IFwiU2lnbsOpIDggYml0c1wiO1xuY29uc3QgdTE2UGl4ZWxUeXBlID0gXCJOb24gc2lnbsOpIDE2IGJpdHNcIjtcbmNvbnN0IHMxNlBpeGVsVHlwZSA9IFwiU2lnbsOpIDE2IGJpdHNcIjtcbmNvbnN0IHUzMlBpeGVsVHlwZSA9IFwiTm9uIHNpZ27DqSAzMiBiaXRzXCI7XG5jb25zdCBzMzJQaXhlbFR5cGUgPSBcIlNpZ27DqSAzMiBiaXRzXCI7XG5jb25zdCBmMzJQaXhlbFR5cGUgPSBcIkZsb3R0YW50IDMyIGJpdHNcIjtcbmNvbnN0IGY2NFBpeGVsVHlwZSA9IFwiRG91YmxlIDY0IGJpdHNcIjtcbmNvbnN0IHByb3BlcnRpZXMgPSBcIlByb3ByacOpdMOpc1wiO1xuY29uc3QgbXVsdGlkaW1lbnNpb25hbFJ1bGVzID0gXCJSw6hnbGVzIG11bHRpZGltZW5zaW9ubmVsbGVzXCI7XG5jb25zdCBtYXRjaFZhcmlhYmxlcyA9IFwiQXBwYXJpZXIgbGVzIHZhcmlhYmxlc1wiO1xuY29uc3QgdW5pb25EaW1lbnNpb25zID0gXCJVbmlvbiBkZXMgZGltZW5zaW9uc1wiO1xuY29uc3QgcmFzdGVyRnVuY3Rpb25FZGl0b3IgPSB7XG5cdGludmFsaWRSRlRNZXNzYWdlOiBcIkxlIG1vZMOobGUgZGUgZm9uY3Rpb24gcmFzdGVyIG7igJllc3QgcGFzIHZhbGlkZS5cIixcblx0cmZ4QXJnc0VkaXRvcjoge1xuXHRcdG91dHB1dFJhc3RlcjogXCJSYXN0ZXIgZW4gc29ydGllXCIsXG5cdFx0cmFzdGVyOiBcIlJhc3RlclwiLFxuXHRcdHVuc3VwcG9ydGVkRGF0YVR5cGVXYXJuaW5nOiBcIkxlcyBhcmd1bWVudHMgc3VpdmFudHMgbmUgc29udCBwYXMgYWZmaWNow6lzIHBhcmNlIHF14oCZaWxzIG5lIHNvbnQgcGFzIHByaXMgZW4gY2hhcmdlIGFjdHVlbGxlbWVudC5cIixcblx0XHR1bnN1cHBvcnRlZEZ1bmN0aW9uOiBcIkNvbnRpZW50IHVuZSBvdSBwbHVzaWV1cnMgZm9uY3Rpb25zIHJhc3RlciBhY3R1ZWxsZW1lbnQgbm9uIHByaXNlcyBlbiBjaGFyZ2UuXCJcblx0fSxcblx0cmZ4UmFzdGVySW5wdXQ6IHtcblx0XHRzZWxlY3RMYXllcjogXCJTw6lsZWN0aW9ubmVyIHVuZSBjb3VjaGVcIixcblx0XHRicm93c2VMYXllcnM6IFwiUGFyY291cmlyIGxlcyBjb3VjaGVzXCIsXG5cdFx0cmZ4VmFyaWFibGU6IFwiUmFzdGVyRnVuY3Rpb25WYXJpYWJsZVwiXG5cdH0sXG5cdHJmeEJhbmRDb21iaW5hdGlvbkVkaXRvcjoge1xuXHRcdG1ldGhvZExhYmVsOiBcIk3DqXRob2RlXCIsXG5cdFx0YmFuZExhYmVsOiBcIkJhbmRlXCIsXG5cdFx0Y29tYmluYXRpb25MYWJlbDogXCJDb21iaW5haXNvblwiXG5cdH0sXG5cdHJmeFJlbWFwR3JpZDoge1xuXHRcdG1pbmltdW06IFwiTWluaW1hbFwiLFxuXHRcdG1heGltdW06IFwiTWF4aW11bVwiLFxuXHRcdG91dHB1dDogXCJTb3J0aWVcIixcblx0XHRub0RhdGE6IFwiTm9EYXRhXCIsXG5cdFx0cmVtYXBWYWx1ZXNMYWJlbDogXCJWYWxldXJzIGRlIGNsYXNzaWZpY2F0aW9uXCJcblx0fSxcblx0cmZ4TmFtZWRSYXN0ZXJFZGl0b3I6IHtcblx0XHRyYXN0ZXJWYXJpYWJsZXM6IFwiVmFyaWFibGVzIHJhc3RlclwiLFxuXHRcdGRlbGV0ZVNlbGVjdGVkVmFyczogXCJTdXBwcmltZXIgbGVzIHZhcmlhYmxlcyBzw6lsZWN0aW9ubsOpZXNcIlxuXHR9LFxuXHRyZnhDbGlwcGluZ0dlb21ldHJ5OiB7XG5cdFx0Y2xpcHBpbmdMYXllcjogXCJDb3VjaGUgZGUgZMOpY291cGFnZVwiLFxuXHRcdGNsaXBwaW5nUmFzdGVyOiBcIkTDqWNvdXBhZ2UgZHUgcmFzdGVyXCIsXG5cdFx0Y2xpcHBpbmdHZW9tZXRyeTogXCJHw6lvbcOpdHJpZSBkZSBkw6ljb3VwYWdlXCIsXG5cdFx0Y3VzdG9tRXh0ZW50OiBcIkV0ZW5kdWUgcGVyc29ubmFsaXPDqWVcIixcblx0XHRvdXRwdXRFeHRlbnQ6IFwiw4l0ZW5kdWUgZW4gc29ydGllXCIsXG5cdFx0Y3VycmVudEV4dGVudDogXCJFdGVuZHVlIGFjdHVlbGxlIGRlIGxhIGNhcnRlXCIsXG5cdFx0ZHJhd0xhYmVsOiBcIkRlc3NpblwiXG5cdH0sXG5cdHJmeEN1c3RvbUV4dGVudDoge1xuXHRcdHRvcDogXCJIYXV0XCIsXG5cdFx0cmlnaHQ6IFwiRHJvaXRlXCIsXG5cdFx0Ym90dG9tOiBcIkJhc1wiLFxuXHRcdGxlZnQ6IFwiR2F1Y2hlXCJcblx0fSxcblx0cmZ4UmFzdGVyQXJyYXlFZGl0b3I6IHtcblx0XHRtb3ZlVXA6IFwiTW9udGVyXCIsXG5cdFx0bW92ZURvd246IFwiRGVzY2VuZHJlXCIsXG5cdFx0cmVtb3ZlOiBcIlJldGlyZXJcIlxuXHR9LFxuXHRyZnhTdGF0aXN0aWNzR3JpZDoge1xuXHRcdHN0ZERldjogXCLDiWNhcnQgdHlwZVwiLFxuXHRcdG1pbjogXCJNaW5cIixcblx0XHRtYXg6IFwiTWF4XCIsXG5cdFx0bWVhbjogXCJNb3llbm5lXCJcblx0fSxcblx0cmZ4V2VpZ2h0ZWRTdW1UYWJsZUVkaXRvcjoge1xuXHRcdHdlaWdodGVkU3VtVGFibGU6IFwiVGFibGUgZGUgc29tbWUgcG9uZMOpcsOpZVwiLFxuXHRcdGlkOiBcIklEXCIsXG5cdFx0bGF5ZXI6IFwiQ291Y2hlXCIsXG5cdFx0ZmllbGQ6IFwiVGVycmFpblwiLFxuXHRcdHdlaWdodDogXCJQb25kw6lyYXRpb25cIixcblx0XHR2YWx1ZTogXCJWYWxldXJcIixcblx0XHRzZWxlY3RMYXllcjogXCJTw6lsZWN0aW9ubmVyIHVuZSBjb3VjaGVcIlxuXHR9LFxuXHRyZnhXZWlnaHRlZE92ZXJsYXlUYWJsZUVkaXRvcjoge1xuXHRcdHdlaWdodGVkT3ZlcmxheVRhYmxlOiBcIlRhYmxlIGRlIHN1cGVycG9zaXRpb24gcG9uZMOpcsOpZVwiLFxuXHRcdGlkOiBcIklEXCIsXG5cdFx0bGF5ZXI6IFwiQ291Y2hlXCIsXG5cdFx0ZmllbGQ6IFwiVGVycmFpblwiLFxuXHRcdGluZmx1ZW5jZTogXCJJbmZsdWVuY2VcIixcblx0XHRzdW1PZkluZmx1ZW5jZTogXCJTb21tZSBkZXMgaW5mbHVlbmNlc1wiLFxuXHRcdHZhbHVlOiBcIlZhbGV1clwiLFxuXHRcdHJlbWFwVGFibGU6IFwiVGFibGUgZGUgY2xhc3NpZmljYXRpb25cIixcblx0XHRzY2FsZTogXCJFY2hlbGxlXCIsXG5cdFx0c2NhbGVzOiBcIsOJY2hlbGxlc1wiLFxuXHRcdHNlbGVjdFJhc3RlcjogXCJTw6lsZWN0aW9ubmVyIHVuIHJhc3RlclwiXG5cdH0sXG5cdHJmeEZlYXR1cmVTZWxlY3Q6IHtcblx0XHRhZGRGZWF0dXJlTGF5ZXI6IFwiUmVjaGVyY2hlciB1bmUgY291Y2hlIGTigJllbnRpdMOpc1wiLFxuXHRcdGFkZFBvaW50TGF5ZXI6IFwiUmVjaGVyY2hlciB1bmUgY291Y2hlIGRlIHBvaW50c1wiXG5cdH0sXG5cdHJmeEZpZWxkU2VsZWN0OiB7XG5cdFx0dmFsdWU6IFwiVmFsZXVyXCIsXG5cdFx0Y291bnQ6IFwiVG90YWxcIlxuXHR9LFxuXHRyZnhBdHRyaWJ1dGVUYWJsZToge1xuXHRcdHRhYmxlVHlwZTogXCJUeXBlIGRlIHRhYmxlXCIsXG5cdFx0bWFudWFsOiBcIk1hbnVlbGxlXCIsXG5cdFx0ZXh0ZXJuYWw6IFwiRXh0ZXJuZVwiLFxuXHRcdG1pblZhbDogXCJWYWxldXIgbWluaW1hbGVcIixcblx0XHRtYXhWYWw6IFwiVmFsZXVyIG1heGltYWxlXCIsXG5cdFx0YmFzZUNsYXNzTmFtZTogXCJOb20gZGUgYmFzZSBkZSBjbGFzc2VcIixcblx0XHRjb2xvclNjaGVtZTogXCJDb21iaW5haXNvbiBkZSBjb3VsZXVyc1wiLFxuXHRcdGRlZmF1bHRDbGFzc05hbWU6IFwiRXRpcXVldHRlX1wiLFxuXHRcdGdlbmVyYXRlVGFibGU6IFwiR8OpbsOpcmVyIHVuZSB0YWJsZVwiLFxuXHRcdGJyb3dzZVRhYmxlOiBcIlBhcmNvdXJpciBsYSB0YWJsZVwiLFxuXHRcdHZhbHVlOiBcIlZhbGV1clwiLFxuXHRcdGNsYXNzbmFtZTogXCJDbGFzc05hbWVcIixcblx0XHRjb2xvcjogXCJDb3VsZXVyXCJcblx0fSxcblx0cmZ4RmllbGROdW1iZXJTd2l0Y2hhYmxlOiB7XG5cdFx0bnVtYmVyOiBcIk51bcOpcmlxdWVcIixcblx0XHRmaWVsZDogXCJUZXJyYWluXCIsXG5cdFx0c3RyaW5nOiBcIkNoYcOubmVcIixcblx0XHRsaW5lYXJVbml0OiBcIlVuaXTDqSBsaW7DqWFpcmVcIlxuXHR9LFxuXHRyZnhQcm9wZXJ0eVNldDoge1xuXHRcdG5hbWU6IFwiTm9tXCIsXG5cdFx0dmFsdWU6IFwiVmFsZXVyXCJcblx0fSxcblx0cmZ4Q29udmVyc2lvbkdyaWQ6IHtcblx0XHRzaXplOiBcIlRhaWxsZVwiXG5cdH0sXG5cdHJmeFRyYW5zcG9zZUJpdDoge1xuXHRcdGJpdFBhdHRlcm46IFwiTW9kw6hsZSBkZSBiaXRcIixcblx0XHRvdXRwdXRCaXQ6IFwiQml0IGVuIHNvcnRpZVwiLFxuXHRcdGlucHV0Qml0OiBcIkJpdCBlbiBlbnRyw6llXCJcblx0fSxcblx0cmZ4U3BhdGlhbFJlZmVyZW5jZToge1xuXHRcdHBsYWNlSG9sZGVyOiBcIkFmZmluZXIgcGFyIG1vdC1jbMOpXCIsXG5cdFx0Y29vcmRpbmF0ZVN5c3RlbTogXCJTeXN0w6htZSBkZSBjb29yZG9ubsOpZXNcIixcblx0XHRnY3M6IFwiU3lzdMOobWUgZGUgY29vcmRvbm7DqWVzIGfDqW9ncmFwaGlxdWVzXCIsXG5cdFx0cGNzOiBcIlN5c3TDqG1lIGRlIGNvb3Jkb25uw6llcyBwcm9qZXTDqWVzXCIsXG5cdFx0dmNzOiBcIlN5c3TDqG1lIGRlIGNvb3Jkb25uw6llcyB2ZXJ0aWNhbGVzXCJcblx0fVxufTtcbmNvbnN0IHJmeExpY2Vuc2VJbmZvID0gXCJWb3VzIHBvdXZleiB1dGlsaXNlciBjZSBtb2TDqGxlIGRlIGZvbmN0aW9uIHJhc3RlciBwb3VyIHRyYWl0ZXIgdm90cmUgaW1hZ2VyaWUgw6AgbOKAmWFpZGUgZOKAmUFyY0dJUyBJbWFnZSBTZXJ2ZXIuXCI7XG5jb25zdCByYXN0ZXJGdW5jdGlvbnMgPSB7XG5cdHJmeDoge1xuXHRcdGFDb3NITmFtZTogXCJBQ29zSFwiLFxuXHRcdGFDb3NIU25pcDogXCJDYWxjdWxlIGxlIGNvc2ludXMgaHlwZXJib2xpcXVlIGludmVyc2UgZGVzIGNlbGx1bGVzIGTigJl1biByYXN0ZXIuXCIsXG5cdFx0YUNvc0hEZXNjOiBcIkxhIGZvbmN0aW9uIGNhbGN1bGUgbGUgY29zaW51cyBoeXBlcmJvbGlxdWUgaW52ZXJzZSBkZXMgcGl4ZWxzIGRhbnMgdW4gcmFzdGVyLlwiLFxuXHRcdGFDb3NOYW1lOiBcIkFDb3NcIixcblx0XHRhQ29zU25pcDogXCJDYWxjdWxlIGxlIGNvc2ludXMgaW52ZXJzZSBkZXMgcGl4ZWxzIGRhbnMgdW4gcmFzdGVyLlwiLFxuXHRcdGFDb3NEZXNjOiBcIkNldHRlIGZvbmN0aW9uIHJhc3RlciBjYWxjdWxlIGxlIGNvc2ludXMgaW52ZXJzZSBkZXMgY2VsbHVsZXMgZOKAmXVuIHJhc3Rlci4gRW4gbWF0aMOpbWF0aXF1ZXMsIHRvdXRlcyBsZXMgZm9uY3Rpb25zIHRyaWdvbm9tw6l0cmlxdWVzIHByw6lzZW50ZW50IHVuZSBwbGFnZSBkw6lmaW5pZSBkZSB2YWxldXJzIGVuIGVudHLDqWUgdmFsaWRlcywgYXBwZWzDqWUgXFxcImRvbWFpbmVcXFwiLiBMZXMgdmFsZXVycyBlbiBzb3J0aWUgZGUgY2hhcXVlIGZvbmN0aW9uIHByw6lzZW50ZW50IMOpZ2FsZW1lbnQgdW5lIHBsYWdlIGTDqWZpbmllLiBQb3VyIGNldCBvdXRpbCwgbGUgZG9tYWluZSBlc3QgWy0xLCAxXSBldCBsYSBwbGFnZSBbMCwgcGldLlwiLFxuXHRcdGFTaW5ITmFtZTogXCJBU2luSFwiLFxuXHRcdGFTaW5IU25pcDogXCJDYWxjdWxlIGxlIHNpbnVzIGh5cGVyYm9saXF1ZSBpbnZlcnNlIGRlcyBjZWxsdWxlcyBk4oCZdW4gcmFzdGVyLlwiLFxuXHRcdGFTaW5IRGVzYzogXCJMYSBmb25jdGlvbiBjYWxjdWxlIGxlIHNpbnVzIGh5cGVyYm9saXF1ZSBpbnZlcnNlIGRlcyBwaXhlbHMgZGFucyB1biByYXN0ZXIuXCIsXG5cdFx0YVNpbk5hbWU6IFwiQVNpblwiLFxuXHRcdGFTaW5TbmlwOiBcIkNhbGN1bGUgbGUgc2ludXMgaW52ZXJzZSBkZXMgY2VsbHVsZXMgZOKAmXVuIHJhc3Rlci5cIixcblx0XHRhU2luRGVzYzogXCJMYSBmb25jdGlvbiBjYWxjdWxlIGxlIHNpbnVzIGludmVyc2UgZGVzIHBpeGVscyBkYW5zIHVuIHJhc3Rlci5cIixcblx0XHRhVGFuMk5hbWU6IFwiQVRhbjJcIixcblx0XHRhVGFuMlNuaXA6IFwiQ2FsY3VsZSBsYSB0YW5nZW50ZSBpbnZlcnNlIChzZWxvbiB4LHkpIGRlcyBjZWxsdWxlcyBk4oCZdW4gcmFzdGVyLlwiLFxuXHRcdGFUYW4yRGVzYzogXCJMYSBmb25jdGlvbiBjYWxjdWxlIGxhIHRhbmdlbnRlIGludmVyc2UgKHNlbG9uIHgseSkgZGVzIHBpeGVscyBkYW5zIHVuIHJhc3Rlci5cIixcblx0XHRhVGFuSE5hbWU6IFwiQVRhbkhcIixcblx0XHRhVGFuSFNuaXA6IFwiQ2FsY3VsZSBsYSB0YW5nZW50ZSBoeXBlcmJvbGlxdWUgaW52ZXJzZSBkZXMgY2VsbHVsZXMgZOKAmXVuIHJhc3Rlci5cIixcblx0XHRhVGFuSERlc2M6IFwiTGEgZm9uY3Rpb24gY2FsY3VsZSBsYSB0YW5nZW50ZSBoeXBlcmJvbGlxdWUgaW52ZXJzZSBkZXMgcGl4ZWxzIGRhbnMgdW4gcmFzdGVyLlwiLFxuXHRcdGFUYW5OYW1lOiBcIkFUYW5cIixcblx0XHRhVGFuU25pcDogXCJDYWxjdWxlIGxhIHRhbmdlbnRlIGludmVyc2UgZGVzIGNlbGx1bGVzIGTigJl1biByYXN0ZXIuXCIsXG5cdFx0YVRhbkRlc2M6IFwiTGEgZm9uY3Rpb24gY2FsY3VsZSBsYSB0YW5nZW50ZSBpbnZlcnNlIGRlcyBwaXhlbHMgZGFucyB1biByYXN0ZXIuXCIsXG5cdFx0YWJzTmFtZTogXCJBYnNcIixcblx0XHRhYnNTbmlwOiBcIkNhbGN1bGUgbGEgdmFsZXVyIGFic29sdWUgZGVzIGNlbGx1bGVzIGTigJl1biByYXN0ZXIuXCIsXG5cdFx0YWJzRGVzYzogXCJMYSBmb25jdGlvbiBBYnMgY2FsY3VsZSBsYSB2YWxldXIgYWJzb2x1ZSBkZXMgcGl4ZWxzIGRhbnMgdW4gcmFzdGVyLlwiLFxuXHRcdHJlZmxlY3RhbmNlTmFtZTogXCJSw6lmbGVjdGFuY2UgYXBwYXJlbnRlXCIsXG5cdFx0cmVmbGVjdGFuY2VTbmlwOiBcIkNvbnZlcnRpdCBsZXMgaW1hZ2VzIGJydXRlcyBlbiB2YWxldXJzIGRlIHLDqWZsZWN0YW5jZSBhdSBzb21tZXQgZGUgbOKAmWF0bW9zcGjDqHJlIChUT0EsIFRvcCBvZiBBdG1vc3BoZXJlKSBlbiB0ZW5hbnQgY29tcHRlIGRlcyBjYXJhY3TDqXJpc3RpcXVlcyBkdSBjYXB0ZXVyLCBkZSBsYSBwb3NpdGlvbiBkdSBzb2xlaWwgZXQgZGUgbOKAmWhldXJlIGTigJlhY3F1aXNpdGlvbi5cIixcblx0XHRyZWZsZWN0YW5jZURlc2M6IFwiQ2V0dGUgZm9uY3Rpb24gcGVybWV0IGTigJlhanVzdGVyIGxlcyB2YWxldXJzIGRlIGx1bWlub3NpdMOpIGRlIGzigJlpbWFnZSBwb3VyIGNlcnRhaW5zIGNhcHRldXJzIHNhdGVsbGl0YWlyZXMuIExlcyByw6lnbGFnZXMgZMOpcGVuZGVudCBkZSBs4oCZw6lsw6l2YXRpb24gZHUgc29sZWlsLCBkZSBsYSBkYXRlIGTigJlhY3F1aXNpdGlvbiBldCBkZXMgcHJvcHJpw6l0w6lzIGR1IGNhcHRldXIgcG91ciBkw6lmaW5pciBsZSBnYWluIGV0IGxlIGJpYWlzIGRlIGNoYXF1ZSBiYW5kZS4gQ2V0dGUgZm9uY3Rpb24gcGVybWV0IGTigJlhanVzdGVyIGxlcyB2YWxldXJzIGRlIHLDqWZsZWN0YW5jZSwgb3UgZGUgbHVtaW5vc2l0w6ksIGRlIGNlcnRhaW5lcyBpbWFnZXMgc2F0ZWxsaXRlIGVuIGZvbmN0aW9uIGRlcyBwYXJhbcOodHJlcyBk4oCZw6ljbGFpcmFnZSBkZSBsYSBzY8OobmUgZXQgZGUgZ2FpbiBkdSBjYXB0ZXVyLiBMZXMgaW1hZ2VzIHNvbnQgYWp1c3TDqWVzIHNlbG9uIHVuIGNyaXTDqHJlIGTigJnDqWNsYWlyYWdlIHRow6lvcmlxdWUgY29tbXVuIGVuIHZ1ZSBkZSByw6lkdWlyZSBsZXMgdmFyaWF0aW9ucyBlbnRyZSBsZXMgc2PDqG5lcyBwcsOpc2VudGFudCBkZXMgZGF0ZXMgZGlmZsOpcmVudGVzIGV0IHByb2R1aXRlcyBwYXIgZGVzIGNhcHRldXJzIGRpZmbDqXJlbnRzLiBDZWxhIGVzdCB1dGlsZSBwb3VyIGxhIGNsYXNzaWZpY2F0aW9uIGRlcyBpbWFnZXMsIGzigJnDqXF1aWxpYnJhZ2UgZGVzIGNvdWxldXJzIGV0IGxlIG1vc2HDr3F1YWdlLiBDZXR0ZSBmb25jdGlvbiBwZXV0IMOqdHJlIHV0aWxpc8OpZSB1bmlxdWVtZW50IGF2ZWMgZGVzIGltYWdlcyBzcMOpY2lmaXF1ZXMuIExlcyBjYXB0ZXVycyBMYW5kc2F0IE1TUywgTGFuZHNhdCBUTSwgTGFuZHNhdCBFVE0rLCBMYW5kc2F0IDgsIElLT05PUywgUXVpY2tCaXJkLCBHZW9FeWUtMSwgUmFwaWRFeWUsIERNQ2lpLCBXb3JsZFZpZXctMSwgV29ybGRWaWV3LTIsIFNQT1QgNiBldCBQbGVpYWRlcyBzb250IHByaXMgZW4gY2hhcmdlLjxkaXY+PGJyLz5MYSBmb25jdGlvbiBlZmZlY3R1ZSBkZXV4IGNvcnJlY3Rpb25zLiBMYSBwcmVtacOocmUgZXN0IGJhc8OpZSBzdXIgbGVzIHBhcmFtw6h0cmVzIGRlIGdhaW4uIExlcyB2YWxldXJzIGRlIGx1bWlub3NpdMOpIGTigJlvcmlnaW5lIHNvbnQgcmVjcsOpw6llcyDDoCBwYXJ0aXIgZGVzIHZhbGV1cnMgZOKAmWltYWdlIGVuIGludmVyc2FudCBsZXMgw6lxdWF0aW9ucyBkZSBnYWluLiBMYSBkZXV4acOobWUgY29ycmVjdGlvbiBlc3QgbGnDqWUgYXV4IGRpZmbDqXJlbmNlcyBk4oCZYW5nbGUgZHUgc29sZWlsIGV0IGRlIGx1bWlub3NpdMOpLiBMZXMgdmFsZXVycyBkZSBsdW1pbm9zaXTDqSBk4oCZb3JpZ2luZSBzb250IGFqdXN0w6llcyBzZWxvbiB1biBjcml0w6hyZSBk4oCZw6ljbGFpcmFnZSBjb21tdW4gZW4gbm9ybWFsaXNhbnQgbGVzIHNjw6huZXMgY2FwdHVyw6llcyBkYW5zIGRlcyBjb25kaXRpb25zIGTigJnDqWNsYWlyYWdlIHZhcmlhYmxlcy4gRW4gZ8OpbsOpcmFsLCBiaWVuIHF1ZSBsZSB0eXBlIGRlIGRvbm7DqWVzIGTigJlpbWFnZSBlbiBzb3J0aWUgc29pdCBpZGVudGlxdWUgYXUgdHlwZSBkZSBkb25uw6llcyBk4oCZaW1hZ2UgZW4gZW50csOpZSwgbGVzIHZhbGV1cnMgZW4gc29ydGllIHNvbnQgaW5mw6lyaWV1cmVzIGF1eCB2YWxldXJzIGVuIGVudHLDqWUgZXQgc29udCBkw6ljb3Vww6llcyBzZWxvbiBsYSBwbGFnZSBkZSBkb25uw6llcyB2YWxpZGUuPC9kaXY+XCIsXG5cdFx0YXJnU3RhdGlzdGljc05hbWU6IFwiU3RhdGlzdGlxdWVzIGTigJlhcmd1bWVudFwiLFxuXHRcdGFyZ1N0YXRpc3RpY3NTbmlwOiBcIkNhbGN1bGUgZGVzIHN0YXRpc3RpcXVlcyBk4oCZYXJndW1lbnQsIGRvbnQgQXJnTWF4LCBBcmdNaW4sIEFyZ01lZGlhbiBldCBEdXJhdGlvbi5cIixcblx0XHRhcmdTdGF0aXN0aWNzRGVzYzogXCJMYSBmb25jdGlvbiBjYWxjdWxlIGxlcyBzdGF0aXN0aXF1ZXMgZOKAmWFyZ3VtZW50LiBRdWF0cmUgbcOpdGhvZGVzIGNvbXBvc2VudCBsYSBmb25jdGlvbiBTdGF0aXN0aXF1ZXMgZOKAmWFyZ3VtZW50IDogQXJnTWF4LCBBcmdNaW4sIEFyZ01lZGlhbiBldCBEdXJhdGlvbi5cIixcblx0XHRhcml0aG1ldGljTmFtZTogXCJBcml0aG3DqXRpcXVlXCIsXG5cdFx0YXJpdGhtZXRpY1NuaXA6IFwiRWZmZWN0dWUgdW5lIG9ww6lyYXRpb24gYXJpdGhtw6l0aXF1ZSBlbnRyZSBkZXV4IHJhc3RlcnMgb3UgZW50cmUgdW4gcmFzdGVyIGV0IHVuZSB2YWxldXIgc2NhbGFpcmUuXCIsXG5cdFx0YXJpdGhtZXRpY0Rlc2M6IFwiTGEgZm9uY3Rpb24gQXJpdGhtw6l0aXF1ZSBlZmZlY3R1ZSB1bmUgb3DDqXJhdGlvbiBhcml0aG3DqXRpcXVlIGVudHJlIGRldXggcmFzdGVycyBvdSBlbnRyZSB1biByYXN0ZXIgZXQgdW4gc2NhbGFpcmUgZXQgaW52ZXJzZW1lbnQuXCIsXG5cdFx0YXNwZWN0U2xvcGVOYW1lOiBcIkV4cG9zaXRpb24tUGVudGVcIixcblx0XHRhc3BlY3RTbG9wZVNuaXA6IFwiQ3LDqWUgdW4gcmFzdGVyIHF1aSBhZmZpY2hlIHNpbXVsdGFuw6ltZW50IGzigJlleHBvc2l0aW9uIChkaXJlY3Rpb24pIGV0IGxhIHBlbnRlIChkw6ljbGl2aXTDqSkgZOKAmXVuZSBzdXJmYWNlIGNvbnRpbnVlLCBjb21tZSByZXByw6lzZW50w6kgZGFucyB1biBtb2TDqGxlIG51bcOpcmlxdWUgZOKAmcOpbMOpdmF0aW9uLlwiLFxuXHRcdGFzcGVjdFNsb3BlRGVzYzogXCJMYSBmb25jdGlvbiBFeHBvc2l0aW9uLVBlbnRlIGNyw6llIHVuZSBjb3VjaGUgcmFzdGVyIHF1aSBhZmZpY2hlIHNpbXVsdGFuw6ltZW50IGzigJlleHBvc2l0aW9uIGV0IGxhIHBlbnRlIGTigJl1bmUgc3VyZmFjZS4gTOKAmWV4cG9zaXRpb24gaWRlbnRpZmllIGxhIGRpcmVjdGlvbiBkZSBwZW50ZSBkZXNjZW5kYW50ZSBkdSB0YXV4IGRlIHZhcmlhdGlvbiBtYXhpbWFsIGRlcyB2YWxldXJzIGRlIGNoYXF1ZSBwaXhlbCBwYXIgcmFwcG9ydCBhdXggcGl4ZWxzIHZvaXNpbnMuIEzigJlleHBvc2l0aW9uIHBldXQgw6p0cmUgYXNzaW1pbMOpZSDDoCBsYSBkaXJlY3Rpb24gZGUgbGEgcGVudGUuIExlcyB2YWxldXJzIGR1IHJhc3RlciBlbiBzb3J0aWUgc29udCBsYSBkaXJlY3Rpb24gYXUgY29tcGFzIGRlIGzigJlleHBvc2l0aW9uLCByZXByw6lzZW50w6llcyBwYXIgdW5lIHRlaW50ZSAoY291bGV1cikuIExhIHBlbnRlIHJlcHLDqXNlbnRlIGxlIHRhdXggZGUgdmFyaWF0aW9uIGTigJnDqWzDqXZhdGlvbiBwb3VyIGNoYXF1ZSBwaXhlbCBkdSBtb2TDqGxlIG51bcOpcmlxdWUgZOKAmcOpbMOpdmF0aW9uIChNTkUpLiBMYSBwZW50ZSByZXByw6lzZW50ZSBsYSBkw6ljbGl2aXTDqSBkZSBsYSBzdXJmYWNlIGV0IGVzdCBzeW1ib2xpc8OpZSBkYW5zIHRyb2lzIGNsYXNzZXMgYWZmaWNow6llcyDDoCBs4oCZYWlkZSBkZSBsYSBzYXR1cmF0aW9uIGRlcyBjb3VsZXVycyAobHVtaW5vc2l0w6kpLjxkaXY+PGJyLz5MZXMgdmFsZXVycyBkZSBwaXhlbHMgZGFucyBsZSByYXN0ZXIgZXhwb3NpdGlvbi1wZW50ZSBlbiBzb3J0aWUgcmVmbMOodGVudCB1bmUgY29tYmluYWlzb24gZGUgbOKAmWV4cG9zaXRpb24gZXQgZGUgbGEgcGVudGUuIExlcyBwaXhlbHMgZG9udCBsZXMgdmFsZXVycyBzb250IGluZsOpcmlldXJlcyDDoCAyMCBzb250IGNvbnNpZMOpcsOpcyBjb21tZSBwbGF0cyBldCBz4oCZYWZmaWNoZW50IGVuIGdyaXMuIExlcyB2YWxldXJzIGTigJlleHBvc2l0aW9uLXBlbnRlIMOpZ2FsZXMgb3Ugc3Vww6lyaWV1cmVzIMOgIDIxIHPigJlhZmZpY2hlbnQgYXZlYyBkaWZmw6lyZW50ZXMgc2F0dXJhdGlvbnMgY29tbWUgc3VpdCA6IGRlIDIxIMOgIDMwIOKAlFNhdHVyYXRpb24gZGUgcGVudGUgZmFpYmxlLCBkZSAzMSDDoCA0MOKAlFNhdHVyYXRpb24gZGUgcGVudGUgbW9kw6lyw6llLCA0MSBldCB2YWxldXJzIHN1cMOpcmlldXJlcyDigJRTYXR1cmF0aW9uIGRlIHBlbnRlIMOpbGV2w6llPC9kaXY+XCIsXG5cdFx0YXNwZWN0TmFtZTogXCJFeHBvc2l0aW9uXCIsXG5cdFx0YXNwZWN0U25pcDogXCJJbmRpcXVlIGxhIGRpcmVjdGlvbiBk4oCZdW4gcGl4ZWwsIDAgw6l0YW50IHBsZWluIG5vcmQgZXQgbGVzIGFuZ2xlcyBhdWdtZW50YW50IGRhbnMgbGUgc2VucyBob3JhaXJlIGp1c3F14oCZw6AgMzYwLlwiLFxuXHRcdGFzcGVjdERlc2M6IFwiTGEgZm9uY3Rpb24gRXhwb3NpdGlvbiBpZGVudGlmaWUgbGEgZGlyZWN0aW9uIGRlIHBlbnRlIGRlc2NlbmRhbnRlIGR1IHRhdXggZGUgdmFyaWF0aW9uIG1heGltYWwgZGVzIHZhbGV1cnMgZGUgY2hhcXVlIGNlbGx1bGUgcGFyIHJhcHBvcnQgYXV4IGNlbGx1bGVzIHZvaXNpbmVzLiBM4oCZZXhwb3NpdGlvbiBwZXV0IMOqdHJlIGFzc2ltaWzDqWUgw6AgbGEgZGlyZWN0aW9uIGRlIGxhIHBlbnRlLiBMZXMgdmFsZXVycyBkdSByYXN0ZXIgZW4gc29ydGllIHNvbnQgbGEgZGlyZWN0aW9uIGF1IGNvbXBhcyBkZSBs4oCZZXhwb3NpdGlvbi48ZGl2Pjxici8+TOKAmWVudHLDqWUgZGUgY2V0dGUgZm9uY3Rpb24gY29ycmVzcG9uZCBhdSByYXN0ZXIgZW4gZW50csOpZS4gTGEgZm9uY3Rpb24gRXhwb3NpdGlvbiBlc3Qgc291dmVudCBhcHBsaXF1w6llIMOgIHVuIG1vZMOobGUgbnVtw6lyaXF1ZSBk4oCZw6lsw6l2YXRpb24gKE1ORSkuIFBhciBkw6lmYXV0LCBs4oCZZXhwb3NpdGlvbiBhcHBhcmHDrnQgc291cyBmb3JtZSBk4oCZaW1hZ2UgZW4gbnVhbmNlcyBkZSBncmlzLiBWb3VzIHBvdXZleiBham91dGVyIGxhIGZvbmN0aW9uIFBhbGV0dGUgZGUgY291bGV1cnMgcG91ciBzcMOpY2lmaWVyIHVuZSBjb21iaW5haXNvbiBkZSBjb3VsZXVycyBlbiBwYXJ0aWN1bGllciBvdSBwZXJtZXR0cmUgw6AgbOKAmXV0aWxpc2F0ZXVyIGRlIGxhIG1vc2HDr3F1ZSBkZSBtb2RpZmllciBsYSBzeW1ib2xvZ2llIGF2ZWMgc2EgcHJvcHJlIGNvbWJpbmFpc29uIGRlIGNvdWxldXJzLjwvZGl2PlwiLFxuXHRcdHRhYmxlTmFtZTogXCJUYWJsZSBhdHRyaWJ1dGFpcmVcIixcblx0XHR0YWJsZVNuaXA6IFwiVXRpbGlzZSB1bmUgdGFibGUgcG91ciBub21tZXIgZXQgc3ltYm9saXNlciBsZXMgdmFsZXVycyBkYW5zIHVuIGpldSBkZSBkb25uw6llcy4gTGVzIGNvbG9ubmVzIGRlIGxhIHRhYmxlIHNvbnQgc8OpcGFyw6llcyBwYXIgZGVzIHZpcmd1bGVzIDogUGl4ZWxWYWx1ZSwgQXR0cmlidXRlTmFtZSwgUmVkVmFsdWUsIEdyZWVuVmFsdWUsIEJsdWVWYWx1ZS5cIixcblx0XHR0YWJsZURlc2M6IFwiTGEgZm9uY3Rpb24gVGFibGUgYXR0cmlidXRhaXJlIHZvdXMgcGVybWV0IGRlIGTDqWZpbmlyIHVuZSB0YWJsZSBhdHRyaWJ1dGFpcmUgcG91ciBzeW1ib2xpc2VyIHVuZSBtb3Nhw69xdWUgbW9ub2JhbmRlIG91IHVuIGpldSBkZSBkb25uw6llcyByYXN0ZXIuIDxkaXY+PGJyLz5DZWNpIGVzdCB1dGlsZSBsb3JzcXVlIHZvdXMgc291aGFpdGV6IHByw6lzZW50ZXIgZGVzIGltYWdlcyBjbGFzc8OpZXMgZW4gZm9uY3Rpb24gZGUgbOKAmXV0aWxpc2F0aW9uIGR1IHNvbCwgcGFyIGV4ZW1wbGUgZGVzIGZvcsOqdHMsIGRlcyBtYXLDqWNhZ2VzLCBkZXMgdGVycmVzIGN1bHRpdmFibGVzIGV0IGRlcyB6b25lcyB1cmJhaW5lcy4gRW4gb3V0cmUsIHNpIHZvdHJlIHRhYmxlIGNvbnRpZW50IGRlcyBjaGFtcHMgbm9tbcOpcyByZWQgKHJvdWdlKSwgZ3JlZW4gKHZlcnQpIGV0IGJsdWUgKGJsZXUpLCBsZXMgdmFsZXVycyBkZSBjZXMgY2hhbXBzIHNvbnQgdXRpbGlzw6llcyBjb21tZSB1bmUgcGFsZXR0ZSBkZSBjb3VsZXVycyBsb3JzIGRlIGzigJlhZmZpY2hhZ2UgZGUgbOKAmWltYWdlLjwvZGl2PlwiLFxuXHRcdGJhbmRBcml0aG1ldGljTmFtZTogXCJBcml0aG3DqXRpcXVlIGRlIGJhbmRlXCIsXG5cdFx0YmFuZEFyaXRobWV0aWNTbmlwOiBcIkNhbGN1bGUgZGVzIGluZGljZXMgw6AgbOKAmWFpZGUgZGUgZm9ybXVsZXMgcHLDqWTDqWZpbmllcyBvdSBk4oCZdW5lIGV4cHJlc3Npb24gZMOpZmluaWUgcGFyIGzigJl1dGlsaXNhdGV1ci5cIixcblx0XHRiYW5kQXJpdGhtZXRpY0Rlc2M6IFwiTGEgZm9uY3Rpb24gQXJpdGhtw6l0aXF1ZSBkZSBiYW5kZSByw6lhbGlzZSB1bmUgb3DDqXJhdGlvbiBhcml0aG3DqXRpcXVlIHN1ciBsZXMgYmFuZGVzIGTigJl1biBqZXUgZGUgZG9ubsOpZXMgcmFzdGVyLiBWb3VzIHBvdXZleiBjaG9pc2lyIGRlcyBhbGdvcml0aG1lcyBwcsOpZMOpZmluaXMgb3Ugc2Fpc2lyIHZvdHJlIHByb3ByZSBmb3JtdWxlIHVuaWxpZ25lLiBMZXMgb3DDqXJhdGV1cnMgcHJpcyBlbiBjaGFyZ2Ugc29udCAtLCssLywqIGV0IC0gdW5haXJlLlwiLFxuXHRcdHRocmVzaG9sZE5hbWU6IFwiRMOpZmluaXRpb24gZOKAmXVuIHNldWlsIGJpbmFpcmVcIixcblx0XHR0aHJlc2hvbGRTbmlwOiBcIk9yZ2FuaXNlIGxlcyBkb25uw6llcyBjb250aW51ZXMgZW4gZmFpc2FudCBsYSBkaXN0aW5jdGlvbiBlbnRyZSBwcmVtaWVyIHBsYW4gZXQgYXJyacOocmUtcGxhbiBlbiByw6lkdWlzYW50IGxhIGNvdmFyaWFuY2UgZW50cmUgbGVzIGRldXggY2xhc3Nlcy5cIixcblx0XHR0aHJlc2hvbGREZXNjOiBcIkxvcnNxdWUgdm91cyB1dGlsaXNleiB1biBqZXUgZGUgZG9ubsOpZXMgcmFzdGVyIGRvdMOpIGTigJl1bmUgZGlzdHJpYnV0aW9uIGJpbW9kYWxlLCBjZXR0ZSBmb25jdGlvbiBjcsOpZSB1biBub3V2ZWF1IHJhc3RlciBxdWkgZGl2aXNlIGxlcyBkb25uw6llcyBlbiBkZXV4IGNsYXNzZXMgZGlzdGluY3Rlcy4gRWxsZSBjcsOpZSB1bmUgY2xhc3NlIMOgIGZhaWJsZSB2YWxldXIsIGFmZmljaMOpZSBhdmVjIGRlcyBwaXhlbHMgbm9pcnMsIGV0IHVuZSBjbGFzc2Ugw6AgZm9ydGUgdmFsZXVyLCBhZmZpY2jDqWUgYXZlYyBkZXMgcGl4ZWxzIGJsYW5jcy5cIixcblx0XHRiaXR3aXNlQW5kTmFtZTogXCJFdCBiaXQgw6AgYml0XCIsXG5cdFx0Yml0d2lzZUFuZFNuaXA6IFwiRWZmZWN0dWUgdW5lIG9ww6lyYXRpb24gRXQgYml0IMOgIGJpdCBzdXIgbGVzIHZhbGV1cnMgYmluYWlyZXMgZGUgZGV1eCByYXN0ZXJzIGVuIGVudHLDqWUuXCIsXG5cdFx0Yml0d2lzZUFuZERlc2M6IFwiTGEgZm9uY3Rpb24gRXQgYml0IMOgIGJpdCBlZmZlY3R1ZSB1bmUgb3DDqXJhdGlvbiBFdCBiaXQgw6AgYml0IHN1ciBsZXMgdmFsZXVycyBiaW5haXJlcyBkZSBkZXV4IHJhc3RlcnMgZW4gZW50csOpZS5cIixcblx0XHRiaXR3aXNlTGVmdFNoaWZ0TmFtZTogXCJEw6ljYWxhZ2Ugw6AgZ2F1Y2hlIGJpdCDDoCBiaXRcIixcblx0XHRiaXR3aXNlTGVmdFNoaWZ0U25pcDogXCJFZmZlY3R1ZSB1bmUgb3DDqXJhdGlvbiBkZSBkw6ljYWxhZ2Ugw6AgZ2F1Y2hlIGJpdCDDoCBiaXQgc3VyIGxlcyB2YWxldXJzIGJpbmFpcmVzIGRlIGRldXggcmFzdGVycyBlbiBlbnRyw6llLlwiLFxuXHRcdGJpdHdpc2VMZWZ0U2hpZnREZXNjOiBcIkxhIGZvbmN0aW9uIETDqWNhbGFnZSDDoCBnYXVjaGUgYml0IMOgIGJpdCBlZmZlY3R1ZSB1bmUgb3DDqXJhdGlvbiBkZSBkw6ljYWxhZ2Ugw6AgZ2F1Y2hlIGJpdCDDoCBiaXQgc3VyIGxlcyB2YWxldXJzIGJpbmFpcmVzIGRlIGRldXggcmFzdGVycyBlbiBlbnRyw6llLlwiLFxuXHRcdGJpdHdpc2VOb3ROYW1lOiBcIk5vbiBiaXQgw6AgYml0XCIsXG5cdFx0Yml0d2lzZU5vdFNuaXA6IFwiRWZmZWN0dWUgdW5lIG9ww6lyYXRpb24gZGUgY29tcGzDqW1lbnQgTm9uIGJpdCDDoCBiaXQgc3VyIGxlcyB2YWxldXJzIGJpbmFpcmVzIGRlIGRldXggcmFzdGVycyBlbiBlbnRyw6llLlwiLFxuXHRcdGJpdHdpc2VOb3REZXNjOiBcIkxhIGZvbmN0aW9uIGVmZmVjdHVlIHVuZSBvcMOpcmF0aW9uIE5vbiBiaXQgw6AgYml0IChkZSBjb21wbMOpbWVudCkgc3VyIGxhIHZhbGV1ciBiaW5haXJlIGTigJl1biByYXN0ZXIgZW4gZW50csOpZS5cIixcblx0XHRiaXR3aXNlT3JOYW1lOiBcIk91IGJpdCDDoCBiaXRcIixcblx0XHRiaXR3aXNlT3JTbmlwOiBcIkVmZmVjdHVlIHVuZSBvcMOpcmF0aW9uIE91IGJpdCDDoCBiaXQgc3VyIGxlcyB2YWxldXJzIGJpbmFpcmVzIGRlIGRldXggcmFzdGVycyBlbiBlbnRyw6llLlwiLFxuXHRcdGJpdHdpc2VPckRlc2M6IFwiTGEgZm9uY3Rpb24gZWZmZWN0dWUgdW5lIG9ww6lyYXRpb24gT3UgYml0IMOgIGJpdCBzdXIgbGVzIHZhbGV1cnMgYmluYWlyZXMgZGUgZGV1eCByYXN0ZXJzIGVuIGVudHLDqWUuIFwiLFxuXHRcdGJpdHdpc2VSaWdodFNoaWZ0TmFtZTogXCJEw6ljYWxhZ2Ugw6AgZHJvaXRlIGJpdCDDoCBiaXRcIixcblx0XHRiaXR3aXNlUmlnaHRTaGlmdFNuaXA6IFwiRWZmZWN0dWUgdW5lIG9ww6lyYXRpb24gZGUgZMOpY2FsYWdlIMOgIGRyb2l0ZSBiaXQgw6AgYml0IHN1ciBsZXMgdmFsZXVycyBiaW5haXJlcyBkZSBkZXV4IHJhc3RlcnMgZW4gZW50csOpZS5cIixcblx0XHRiaXR3aXNlUmlnaHRTaGlmdERlc2M6IFwiTGEgZm9uY3Rpb24gZWZmZWN0dWUgdW5lIG9ww6lyYXRpb24gRMOpY2FsYWdlIMOgIGRyb2l0ZSBiaXQgw6AgYml0IHN1ciBsZXMgdmFsZXVycyBiaW5haXJlcyBkZSBkZXV4IHJhc3RlcnMgZW4gZW50csOpZS5cIixcblx0XHRiaXR3aXNlWG9yTmFtZTogXCJPdSBleGNsdXNpZiBiaXQgw6AgYml0XCIsXG5cdFx0Yml0d2lzZVhvclNuaXA6IFwiRWZmZWN0dWUgdW5lIG9ww6lyYXRpb24gT3UgZXhjbHVzaWYgYml0IMOgIGJpdCBzdXIgbGVzIHZhbGV1cnMgYmluYWlyZXMgZGUgZGV1eCByYXN0ZXJzIGVuIGVudHLDqWUuXCIsXG5cdFx0Yml0d2lzZVhvckRlc2M6IFwiTGEgZm9uY3Rpb24gZWZmZWN0dWUgdW5lIG9ww6lyYXRpb24gT3UgZXhjbHVzaWYgYml0IMOgIGJpdCBzdXIgbGVzIHZhbGV1cnMgYmluYWlyZXMgZGUgZGV1eCByYXN0ZXJzIGVuIGVudHLDqWUuXCIsXG5cdFx0Ym9vbGVhbkFuZE5hbWU6IFwiRXQgYm9vbMOpZW5cIixcblx0XHRib29sZWFuQW5kU25pcDogXCJFZmZlY3R1ZSB1bmUgb3DDqXJhdGlvbiBFdCBib29sw6llbiBzdXIgbGVzIHZhbGV1cnMgZGUgY2VsbHVsZXMgZGUgZGV1eCByYXN0ZXJzIGVuIGVudHLDqWUuIFNpIGxlcyBkZXV4IHZhbGV1cnMgZW4gZW50csOpZSBzb250IHZyYWllcyAoZGlmZsOpcmVudGVzIGRlIHrDqXJvKSwgbGEgdmFsZXVyIGVuIHNvcnRpZSBlc3Qgw6lnYWxlIMOgIDEuIFNpIGzigJl1bmUgZGVzIHZhbGV1cnMgZW4gZW50csOpZSwgb3UgbGVzIGRldXgsIHNvbnQgZmF1c3NlcyAow6lnYWxlcyDDoCB6w6lybyksIGxhIHNvcnRpZSBlc3Qgw6lnYWxlIMOgIDAuXCIsXG5cdFx0Ym9vbGVhbkFuZERlc2M6IFwiTGEgZm9uY3Rpb24gZWZmZWN0dWUgdW5lIG9ww6lyYXRpb24gRXQgYm9vbMOpZW4gc3VyIGxlcyB2YWxldXJzIGRlIHBpeGVscyBkZSBkZXV4IGVudHLDqWVzLiBTaSBsZXMgZGV1eCB2YWxldXJzIGVuIGVudHLDqWUgc29udCB2cmFpZXMgKGRpZmbDqXJlbnRlcyBkZSB6w6lybyksIGxhIHZhbGV1ciBlbiBzb3J0aWUgZXN0IMOpZ2FsZSDDoCAxLiBTaSBs4oCZdW5lIGRlcyB2YWxldXJzIGVuIGVudHLDqWUsIG91IGxlcyBkZXV4LCBzb250IGZhdXNzZXMgKMOpZ2FsZXMgw6AgesOpcm8pLCBsYSB2YWxldXIgZW4gc29ydGllIGVzdCDDqWdhbGUgw6AgMC4gXCIsXG5cdFx0Ym9vbGVhbk5vdE5hbWU6IFwiTm9uIGJvb2zDqWVuXCIsXG5cdFx0Ym9vbGVhbk5vdFNuaXA6IFwiRWZmZWN0dWUgdW5lIG9ww6lyYXRpb24gZGUgY29tcGzDqW1lbnQgTm9uIGJvb2zDqWVuIHN1ciBsZXMgdmFsZXVycyBkZSBjZWxsdWxlcyBkdSByYXN0ZXIgZW4gZW50csOpZS4gU2kgbGVzIHZhbGV1cnMgZW4gZW50csOpZSBzb250IHZyYWllcyAoZGlmZsOpcmVudGVzIGRlIHrDqXJvKSwgbGEgdmFsZXVyIGVuIHNvcnRpZSBlc3Qgw6lnYWxlIMOgIDAuIFNpIGxlcyB2YWxldXJzIGVuIGVudHLDqWUgc29udCBmYXVzc2VzICjDqWdhbGVzIMOgIHrDqXJvKSwgbGEgc29ydGllIGVzdCDDqWdhbGUgw6AgMS5cIixcblx0XHRib29sZWFuTm90RGVzYzogXCJMYSBmb25jdGlvbiBlZmZlY3R1ZSB1bmUgb3DDqXJhdGlvbiBkZSBjb21wbMOpbWVudCBOb24gYm9vbMOpZW4gc3VyIGxlcyB2YWxldXJzIGRlIHBpeGVscyBkdSByYXN0ZXIgZW4gZW50csOpZS4gU2kgbGVzIHZhbGV1cnMgZW4gZW50csOpZSBzb250IHZyYWllcyAoZGlmZsOpcmVudGVzIGRlIHrDqXJvKSwgbGEgdmFsZXVyIGVuIHNvcnRpZSBlc3Qgw6lnYWxlIMOgIDAuIFNpIGxlcyB2YWxldXJzIGVuIGVudHLDqWUgc29udCBmYXVzc2VzICjDqWdhbGVzIMOgIHrDqXJvKSwgbGEgdmFsZXVyIGVuIHNvcnRpZSBlc3Qgw6lnYWxlIMOgIDEuXCIsXG5cdFx0Ym9vbGVhbk9yTmFtZTogXCJPdSBib29sw6llblwiLFxuXHRcdGJvb2xlYW5PclNuaXA6IFwiRWZmZWN0dWUgdW5lIG9ww6lyYXRpb24gT3UgYm9vbMOpZW4gc3VyIGxlcyB2YWxldXJzIGRlIGNlbGx1bGVzIGRlcyBkZXV4IHJhc3RlcnMgZW4gZW50csOpZS4gU2kgbOKAmXVuZSBkZXMgdmFsZXVycyBlbiBlbnRyw6llLCBvdSBsZXMgZGV1eCwgc29udCB2cmFpZXMgKGRpZmbDqXJlbnRlcyBkZSB6w6lybyksIGxhIHZhbGV1ciBlbiBzb3J0aWUgZXN0IMOpZ2FsZSDDoCAxLiBTaSBsZXMgZGV1eCB2YWxldXJzIGVuIGVudHLDqWUgc29udCBmYXVzc2VzICh6w6lybyksIGxhIHNvcnRpZSBlc3Qgw6lnYWxlIMOgIDAuXCIsXG5cdFx0Ym9vbGVhbk9yRGVzYzogXCJMYSBmb25jdGlvbiBlZmZlY3R1ZSB1bmUgb3DDqXJhdGlvbiBPdSBib29sw6llbiBzdXIgbGVzIHZhbGV1cnMgZGUgY2VsbHVsZXMgZGUgZGV1eCByYXN0ZXJzIGVuIGVudHLDqWUuIFNpIGzigJl1bmUgZGVzIHZhbGV1cnMgZW4gZW50csOpZSwgb3UgbGVzIGRldXgsIHNvbnQgdnJhaWVzIChkaWZmw6lyZW50ZXMgZGUgesOpcm8pLCBsYSB2YWxldXIgZW4gc29ydGllIGVzdCDDqWdhbGUgw6AgMS4gU2kgbGVzIGRldXggdmFsZXVycyBlbiBlbnRyw6llIHNvbnQgZmF1c3NlcyAow6lnYWxlcyDDoCB6w6lybyksIGxhIHZhbGV1ciBlbiBzb3J0aWUgZXN0IMOpZ2FsZSDDoCAwLlwiLFxuXHRcdGJvb2xlYW5Yb3JOYW1lOiBcIk91IGV4Y2x1c2lmIGJvb2zDqWVuXCIsXG5cdFx0Ym9vbGVhblhvclNuaXA6IFwiRWZmZWN0dWUgdW5lIG9ww6lyYXRpb24gT3UgZXhjbHVzaWYgYm9vbMOpZW4gc3VyIGxlcyB2YWxldXJzIGRlIGNlbGx1bGVzIGRlIGRldXggcmFzdGVycyBlbiBlbnRyw6llLiBTaSB1bmUgdmFsZXVyIGVuIGVudHLDqWUgZXN0IHZyYWllIChkaWZmw6lyZW50ZSBkZSB6w6lybykgZXQgcXVlIGzigJlhdXRyZSBlc3QgZmF1c3NlICjDqWdhbGUgw6AgMCksIGxhIHNvcnRpZSBlc3Qgw6lnYWxlIMOgIDEuIFNpIGxlcyBkZXV4IHZhbGV1cnMgZW4gZW50csOpZSBzb250IHZyYWllcyBvdSBmYXVzc2VzLCBsYSBzb3J0aWUgZXN0IMOpZ2FsZSDDoCAwLlwiLFxuXHRcdGJvb2xlYW5Yb3JEZXNjOiBcIkxhIGZvbmN0aW9uIGVmZmVjdHVlIHVuZSBvcMOpcmF0aW9uIE91IGV4Y2x1c2lmIGJvb2zDqWVuIHN1ciBsZXMgdmFsZXVycyBkZSBjZWxsdWxlIGRlIGRldXggcmFzdGVycyBlbiBlbnRyw6llLiBTaSB1bmUgdmFsZXVyIGVuIGVudHLDqWUgZXN0IHZyYWllIChkaWZmw6lyZW50ZSBkZSB6w6lybykgZXQgcXVlIGzigJlhdXRyZSBlc3QgZmF1c3NlICjDqWdhbGUgw6AgMCksIGxhIHZhbGV1ciBlbiBzb3J0aWUgZXN0IMOpZ2FsZSDDoCAxLiBTaSBsZXMgZGV1eCB2YWxldXJzIGVuIGVudHLDqWUgc29udCB2cmFpZXMgb3UgZmF1c3NlcywgbGEgdmFsZXVyIGVuIHNvcnRpZSBlc3Qgw6lnYWxlIMOgIDAuXCIsXG5cdFx0YnVmZmVyZWRSYXN0ZXJOYW1lOiBcIkJ1ZmbDqXJpc8OpXCIsXG5cdFx0YnVmZmVyZWRSYXN0ZXJTbmlwOiBcIkJ1ZmbDqXJpc2UgbGVzIGRlcm5pZXJzIGJsb2NzIGRlIHBpeGVscyB1dGlsaXPDqXMuXCIsXG5cdFx0YnVmZmVyZWRSYXN0ZXJEZXNjOiBcIkxhIGZvbmN0aW9uIEJ1ZmbDqXJpc8OpIHBlcm1ldCBk4oCZb3B0aW1pc2VyIGxlcyBwZXJmb3JtYW5jZXMgZGVzIGNoYcOubmVzIGRlIGZvbmN0aW9ucyBjb21wbGV4ZXMuIEVsbGUgc3RvY2tlIGxhIHNvcnRpZSBlbiBtw6ltb2lyZSBkZSBsYSBwYXJ0aWUgZGUgbGEgY2hhw65uZSBkZSBmb25jdGlvbnMgcXVpIGxhIHByw6ljw6hkZS4gPGRpdj48YnIvPkluc8OpcmV6IGNldHRlIGZvbmN0aW9uIGRhbnMgbOKAmcOpZGl0ZXVyIGRlIGZvbmN0aW9ucyBvw7kgdm91cyB2b3VsZXogc3RvY2tlciBsYSBzb3J0aWUuPC9kaXY+XCIsXG5cdFx0cmFzdGVyQ2FsY3VsYXRvck5hbWU6IFwiQ2FsY3VsYXRyaWNlXCIsXG5cdFx0cmFzdGVyQ2FsY3VsYXRvclNuaXA6IFwiQ2FsY3VsZSB1biByYXN0ZXIgw6AgcGFydGlyIGTigJl1bmUgZXhwcmVzc2lvbiBtYXRow6ltYXRpcXVlIGRlIHR5cGUgcmFzdGVyLlwiLFxuXHRcdHJhc3RlckNhbGN1bGF0b3JEZXNjOiBcIkxhIGZvbmN0aW9uIENhbGN1bGF0cmljZSBwZXJtZXQgZGUgY3LDqWVyIGV0IGTigJlleMOpY3V0ZXIgZGVzIGV4cHJlc3Npb25zIGFmaW4gZGUgbGVzIGluY29ycG9yZXIgZGFucyBkZXMgY2hhw65uZXMgZGUgZm9uY3Rpb25zLlwiLFxuXHRcdGNlbGxTdGF0aXN0aWNzTmFtZTogXCJTdGF0aXN0aXF1ZXMgZGUgY2VsbHVsZVwiLFxuXHRcdGNlbGxTdGF0aXN0aWNzU25pcDogXCJDYWxjdWxlIGRlcyBzdGF0aXN0aXF1ZXMgcGFyIGNlbGx1bGUgw6AgcGFydGlyIGRlIHBsdXNpZXVycyByYXN0ZXJzLiBMZXMgc3RhdGlzdGlxdWVzIGRpc3BvbmlibGVzIHNvbnQgbGVzIHN1aXZhbnRlc8KgOiBNYWpvcml0w6ksIE1heGltdW0sIE1veWVubmUsIE3DqWRpYW5lLCBNaW5pbXVtLCBNaW5vcml0w6ksIENlbnRpbGUsIFBsYWdlLCDDiWNhcnQgdHlwZSwgU29tbWUgZXQgVmFyacOpdMOpLlwiLFxuXHRcdGNlbGxTdGF0aXN0aWNzRGVzYzogXCJDZXR0ZSBmb25jdGlvbiBjYWxjdWxlIGxlcyBzdGF0aXN0aXF1ZXMgZGUgcGx1c2lldXJzIHJhc3RlcnMsIHBpeGVsIHBhciBwaXhlbC4gTGVzIHN0YXRpc3RpcXVlcyBkaXNwb25pYmxlcyBzb250IGxlcyBzdWl2YW50ZXMgOiBtYWpvcml0w6ksIG1heGltdW0sIG1veWVubmUsIG3DqWRpYW5lLCBtaW5pbXVtLCBtaW5vcml0w6ksIHBsYWdlLCDDqWNhcnQgdHlwZSwgc29tbWUgZXQgdmFyacOpdMOpLlwiLFxuXHRcdGNsYXNzaWZ5TmFtZTogXCJDbGFzc2VyXCIsXG5cdFx0Y2xhc3NpZnlTbmlwOiBcIkF0dHJpYnVlIGNoYXF1ZSBwaXhlbCDDoCB1bmUgY2xhc3NlLiBJbmNvcnBvcmV6IGxlcyBkb25uw6llcyBhdXhpbGlhaXJlcywgdGVsbGVzIHF14oCZdW5lIGltYWdlIHNlZ21lbnTDqWUuXCIsXG5cdFx0Y2xhc3NpZnlEZXNjOiBcIkNldHRlIGZvbmN0aW9uIHJhc3RlciBjbGFzc2UgdW4gamV1IGRlIGRvbm7DqWVzIHJhc3RlciBlbiBmb25jdGlvbiBk4oCZdW4gZmljaGllciBkZSBkw6lmaW5pdGlvbiBkZSBjbGFzc2lmaWNhdGV1ciBFc3JpICguZWNkKSBldCBkZSBqZXV4IGRlIGRvbm7DqWVzIHJhc3RlciBlbiBlbnRyw6llLiBMZSBmaWNoaWVyIC5lY2QgdXRpbGlzw6kgZGFucyBsYSBmb25jdGlvbiBDbGFzc2lmaWVyIGNvbnRpZW50IHRvdXRlcyBsZXMgaW5mb3JtYXRpb25zIHBvdXIgdW4gamV1IGRlIGRvbm7DqWVzIGV0IHVuIGNsYXNzaWZpY2F0ZXVyIHNww6ljaWZpcXVlcywgZXQgZXN0IGfDqW7DqXLDqSBwYXIgbGVzIG91dGlscyBk4oCZZW50cmHDrm5lbWVudCBkZSBjbGFzc2lmaWNhdGlvbiwgdGVscyBxdWUgUHLDqXBhcmVyIGxlIGNsYXNzaWZpY2F0ZXVyIGRlIG1hY2hpbmVzIMOgIHZlY3RldXJzIGRlIHN1cHBvcnQgb3UgUHLDqXBhcmVyIGxlIGNsYXNzaWZpY2F0ZXVyIGTigJlhcmJyZXMgYWzDqWF0b2lyZXMuXCIsXG5cdFx0Y2xpcE5hbWU6IFwiRMOpY291cGVyXCIsXG5cdFx0Y2xpcFNuaXA6IFwiRMOpZmluaXQgbOKAmcOpdGVuZHVlIGTigJl1biByYXN0ZXIgw6AgbOKAmWFpZGUgZGUgY29vcmRvbm7DqWVzIG91IGTigJl1biBhdXRyZSBqZXUgZGUgZG9ubsOpZXMuXCIsXG5cdFx0Y2xpcERlc2M6IFwiQ2V0dGUgZm9uY3Rpb24gZMOpY291cGUgdW4gcmFzdGVyIMOgIGzigJlhaWRlIGTigJl1bmUgZm9ybWUgcmVjdGFuZ3VsYWlyZSBzZWxvbiBsZXMgw6l0ZW5kdWVzIGTDqWZpbmllcyBvdSBkw6ljb3VwZSB1biByYXN0ZXIgc2Vsb24gbGEgZm9ybWUgZOKAmXVuZSBjbGFzc2UgZOKAmWVudGl0w6lzIHN1cmZhY2lxdWVzIGVuIGVudHLDqWUuIExhIGZvcm1lIHF1aSBkw6lmaW5pdCBsZSBkw6ljb3VwYWdlIHBldXQgZMOpY291cGVyIGzigJnDqXRlbmR1ZSBkdSByYXN0ZXIgb3UgZMOpY291cGVyIHVuZSB6b25lIGF1IHNlaW4gZHUgcmFzdGVyLlwiLFxuXHRcdGNvbG9yc3BhY2VDb252ZXJzaW9uTmFtZTogXCJDb252ZXJzaW9uIGR1IG1vZMOobGUgZGUgY291bGV1clwiLFxuXHRcdGNvbG9yc3BhY2VDb252ZXJzaW9uU25pcDogXCJDb252ZXJ0aXQgdW4gcmFzdGVyIGRlIFJHQiBlbiBUU0wgZXQgaW52ZXJzZW1lbnQuXCIsXG5cdFx0Y29sb3JzcGFjZUNvbnZlcnNpb25EZXNjOiBcIkxhIGZvbmN0aW9uIGRlIGNvbnZlcnNpb24gZHUgbW9kw6hsZSBkZSBjb3VsZXVyIGNvbnZlcnRpdCBsZSBtb2TDqGxlIGRlIGNvdWxldXIgZOKAmXVuZSBpbWFnZSBkZSBs4oCZZXNwYWNlIGRlIGNvdWxldXIgVFNMICh0ZWludGUsIHNhdHVyYXRpb24gZXQgbHVtaW5vc2l0w6kpIGVuIFJWQiAocm91Z2UsIHZlcnQsIGJsZXUpLCBvdSBpbnZlcnNlbWVudC48ZGl2Pjxici8+Q2V0dGUgZm9uY3Rpb24gcGV1dCDDqnRyZSB1dGlsaXPDqWUgZGFucyB1biBqZXUgZGUgZG9ubsOpZXMgbW9zYcOvcXVlLjwvZGl2PlwiLFxuXHRcdGNvbG9ybWFwVG9SR0JOYW1lOiBcIlBhbGV0dGUgZGUgY291bGV1cnMgdmVycyBSVkJcIixcblx0XHRjb2xvcm1hcFRvUkdCU25pcDogXCJDb252ZXJ0aXQgdW4gcmFzdGVyIG1vbm9iYW5kZSBlbiByYXN0ZXIgw6AgdHJvaXMgYmFuZGVzIChyb3VnZSwgdmVydCwgYmxldSkgw6AgbOKAmWFpZGUgZOKAmXVuZSBwYWxldHRlIGRlIGNvdWxldXJzLlwiLFxuXHRcdGNvbG9ybWFwVG9SR0JEZXNjOiBcIkNldHRlIGZvbmN0aW9uIGNvbnZlcnRpdCB1biByYXN0ZXIgbW9ub2JhbmRlIGFzc29jacOpIMOgIHVuZSBwYWxldHRlIGRlIGNvdWxldXJzIGVuIHJhc3RlciDDoCB0cm9pcyBiYW5kZXMgKHJvdWdlLCB2ZXJ0LCBibGV1KS48ZGl2Pjxici8+Q2V0dGUgZm9uY3Rpb24gZXN0IHV0aWxlIHBvdXIgY3LDqWVyIHVuIHJhc3RlciDDoCB0cm9pcyBiYW5kZXMgw6AgcGFydGlyIGTigJl1biByYXN0ZXIgbW9ub2JhbmRlIMOgIGzigJlhaWRlIGTigJl1bmUgcGFsZXR0ZSBkZSBjb3VsZXVycyBhc3NvY2nDqWUuIExlcyB2YWxldXJzIGRlIGxhIHBhbGV0dGUgZGUgY291bGV1cnMgc2Vydmlyb250IMOgIGNyw6llciBjaGFxdWUgYmFuZGUgcm91Z2UsIHZlcnRlIGV0IGJsZXVlLiBDZXR0ZSBmb25jdGlvbiBwZXV0IMOqdHJlIHV0aWxpc8OpZSBkYW5zIHVuIGpldSBkZSBkb25uw6llcyBtb3Nhw69xdWUuPC9kaXY+XCIsXG5cdFx0Y29sb3JtYXBOYW1lOiBcIlBhbGV0dGUgZGUgY291bGV1cnNcIixcblx0XHRjb2xvcm1hcFNuaXA6IFwiTW9kaWZpZSBsZXMgdmFsZXVycyBkZSBwaXhlbHMgcG91ciBhZmZpY2hlciBsZXMgZG9ubsOpZXMgcmFzdGVyIHNvaXQgc291cyBmb3JtZSBk4oCZdW5lIGltYWdlIGVuIG51YW5jZXMgZGUgZ3Jpcywgc29pdCBzb3VzIGZvcm1lIGTigJl1bmUgaW1hZ2UgUlZCIChyb3VnZSwgdmVydCwgYmxldSksIGTigJlhcHLDqHMgdW5lIHBhbGV0dGUgZGUgY291bGV1cnMgb3UgdW4gZMOpZ3JhZMOpIGRlIGNvdWxldXJzLlwiLFxuXHRcdGNvbG9ybWFwRGVzYzogXCJMYSBmb25jdGlvbiBQYWxldHRlIGRlIGNvdWxldXJzIGVzdCB1biB0eXBlIGRlIG1vdGV1ciBkZSByZW5kdSBkZSBkb25uw6llcyByYXN0ZXIuIEVsbGUgdHJhbnNmb3JtZSBsZXMgdmFsZXVycyBkZSBwaXhlbHMgcG91ciBhZmZpY2hlciBsZXMgZG9ubsOpZXMgcmFzdGVyIHNvaXQgc291cyBmb3JtZSBk4oCZdW5lIGltYWdlIGVuIG51YW5jZXMgZGUgZ3Jpcywgc29pdCBzb3VzIGZvcm1lIGTigJl1bmUgaW1hZ2UgZW4gY291bGV1cnMgKFJWQiksIGVuIGZvbmN0aW9uIGTigJl1bmUgY29tYmluYWlzb24gZGUgY291bGV1cnMgb3UgZGVzIGNvdWxldXJzIHNww6ljaWZpcXVlcyBk4oCZdW4gZmljaGllciBkZSBwYWxldHRlIGRlIGNvdWxldXJzLiBM4oCZdXRpbGlzYXRpb24gZOKAmXVuZSBwYWxldHRlIGRlIGNvdWxldXJzIHBlcm1ldCBsYSByZXByw6lzZW50YXRpb24gZGVzIGRvbm7DqWVzIGFuYWx5c8OpZXMsIGNvbW1lIHVuZSBpbWFnZSBjbGFzc8OpZSwgb3UgbOKAmWFmZmljaGFnZSBk4oCZdW5lIGNhcnRlIHRvcG9ncmFwaGlxdWUgKG91IGTigJl1bmUgaW1hZ2UgbnVtw6lyaXPDqWUgcGFyIGNvdWxldXJzIGTigJlpbmRleCkuPGRpdj48YnIvPkxlcyBwYWxldHRlcyBkZSBjb3VsZXVycyBjb250aWVubmVudCB1biBlbnNlbWJsZSBkZSB2YWxldXJzIGFzc29jacOpZXMgYXV4IGNvdWxldXJzIHBlcm1ldHRhbnQgZOKAmWFmZmljaGVyIGRlIG1hbmnDqHJlIGNvaMOpcmVudGUgdW4gcmFzdGVyIG1vbm9iYW5kZSBhdmVjIGNlcyBtw6ptZXMgY291bGV1cnMuIENoYXF1ZSB2YWxldXIgZGUgcGl4ZWwgZXN0IGFzc29jacOpZSDDoCB1bmUgY291bGV1ciwgZMOpZmluaWUgY29tbWUgdW4gZW5zZW1ibGUgZGUgdmFsZXVycyBSVkIgKHJvdWdlLCB2ZXJ0LCBibGV1KS4gTGVzIHBhbGV0dGVzIGRlIGNvdWxldXJzIHBldXZlbnQgcHJlbmRyZSBlbiBjaGFyZ2UgbuKAmWltcG9ydGUgcXVlbGxlIHZhbGV1ciBkZSBwcm9mb25kZXVyIGRlIGNvdWxldXIsIMOgIGzigJlleGNlcHRpb24gZGVzIG5vbWJyZXMgw6AgdmlyZ3VsZSBmbG90dGFudGUuIEVsbGVzIHByZW5uZW50IMOpZ2FsZW1lbnQgZW4gY2hhcmdlIGRlcyB2YWxldXJzIHBvc2l0aXZlcyBldCBuw6lnYXRpdmVzIGV0IHBldXZlbnQgY29udGVuaXIgZGVzIHZhbGV1cnMgYXBwYXJpw6llcyBkZSBjb3VsZXVycyBtYW5xdWFudGVzLiBMb3JzIGRlIGzigJlhZmZpY2hhZ2UgZOKAmXVuIGpldSBkZSBkb25uw6llcyBhdmVjIHVuZSBwYWxldHRlIGRlIGNvdWxldXJzIMOgIGxhcXVlbGxlIGlsIG1hbnF1ZSBkZXMgdmFsZXVycywgbGVzIHZhbGV1cnMgbWFucXVhbnRlcyBuZSBzb250IHBhcyBhZmZpY2jDqWVzLjwvZGl2PlwiLFxuXHRcdGNvbXBsZXhOYW1lOiBcIkNvbXBsZXhlXCIsXG5cdFx0Y29tcGxleFNuaXA6IFwiRXh0cmFpdCBsYSBncmFuZGV1ciBkZSBub21icmVzIGNvbXBsZXhlcy5cIixcblx0XHRjb21wbGV4RGVzYzogXCJDZXR0ZSBmb25jdGlvbiBjYWxjdWxlIHVuZSBncmFuZGV1ciDDoCBwYXJ0aXIgZGUgdmFsZXVycyBjb21wbGV4ZXMuPGRpdj48YnIvPkNldHRlIGZvbmN0aW9uIGVzdCBnw6luw6lyYWxlbWVudCB1dGlsaXPDqWUgYXZlYyBs4oCZaW1hZ2VyaWUgUkFEQVIgZG9udCBsZSB0eXBlIGRlIGRvbm7DqWVzIGVzdCBjb21wbGV4ZS4gRWxsZSBwZXV0IMOqdHJlIHV0aWxpc8OpZSBkYW5zIHVuIGpldSBkZSBkb25uw6llcyBtb3Nhw69xdWUuPC9kaXY+XCIsXG5cdFx0Y29tcG9zaXRlQmFuZE5hbWU6IFwiQmFuZGVzIGNvbXBvc2l0ZXNcIixcblx0XHRjb21wb3NpdGVCYW5kU25pcDogXCJDb21iaW5lIHBsdXNpZXVycyBqZXV4IGRlIGRvbm7DqWVzIGVuIHVuIHNldWwgcmFzdGVyIG11bHRpYmFuZGUuXCIsXG5cdFx0Y29tcG9zaXRlQmFuZERlc2M6IFwiTGEgZm9uY3Rpb24gQmFuZGVzIGNvbXBvc2l0ZXMgcGVybWV0IGRlIGNvbWJpbmVyIGRlcyByYXN0ZXJzIHBvdXIgZm9ybWVyIHVuZSBpbWFnZSBtdWx0aWJhbmRlLlwiLFxuXHRcdGNvbk5hbWU6IFwiQ29uXCIsXG5cdFx0Y29uU25pcDogXCJFZmZlY3R1ZSB1bmUgb3DDqXJhdGlvbiBjb25kaXRpb25uZWxsZSBJZiwgVGhlbiBvdSBFbHNlLiBMb3JzcXXigJl1biBvcMOpcmF0ZXVyIENvbiBlc3QgdXRpbGlzw6ksIGlsIGRvaXQgZ8OpbsOpcmFsZW1lbnQgeSBhdm9pciBkZXV4IG91IHBsdXNpZXVycyBmb25jdGlvbnMgZW5jaGHDrm7DqWVzIGVuc2VtYmxlLCBvw7kgdW5lIGZvbmN0aW9uIHN0aXB1bGUgbGVzIGNyaXTDqHJlcyBldCBsYSBzZWNvbmRlIGZvbmN0aW9uIGVzdCBs4oCZb3DDqXJhdGV1ciBDb24gcXVpIHV0aWxpc2UgbGVzIGNyaXTDqHJlcyBldCBkaWN0ZSBxdWVsbGVzIHNvbnQgbGVzIHNvcnRpZXMgdnJhaWVzIG91IGZhdXNzZXMuXCIsXG5cdFx0Y29uRGVzYzogXCJMYSBmb25jdGlvbiBDb24gZMOpZmluaXQgbGVzIHBpeGVscyBkYW5zIGxlIHJhc3RlciBlbiBzb3J0aWUgZW4gZm9uY3Rpb24gZOKAmXVuZSDDqXZhbHVhdGlvbiBpZlxcXFxlbHNlIGRlIGNoYXF1ZSBwaXhlbCBlbiBlbnRyw6llLiBFbGxlIHJlbnZvaWUgbGVzIHZhbGV1cnMgZGUgcGl4ZWxzIGR1IHJhc3RlciB2cmFpIHNpIGzigJnDqXZhbHVhdGlvbiBjb25kaXRpb25uZWxsZSBlc3QgdnJhaWUgKDEpIG91IHJlbnZvaWUgbGVzIHZhbGV1cnMgZGUgcGl4ZWxzIGR1IHJhc3RlciBmYXV4IHNpIGzigJnDqXZhbHVhdGlvbiBjb25kaXRpb25uZWxsZSBlc3QgZmF1c3NlICgwKS4gQ2UgY3JpdMOocmUgZXN0IHNww6ljaWZpw6kgcGFyIGxhIHNvcnRpZSBk4oCZdW5lIGZvbmN0aW9uIG1hdGjDqW1hdGlxdWUgbG9naXF1ZSwgcXVpIHNlcmEgbGUgcmFzdGVyIGVuIGVudHLDqWUuXCIsXG5cdFx0Y29uc3RhbnROYW1lOiBcIkNvbnN0YW50ZVwiLFxuXHRcdGNvbnN0YW50U25pcDogXCJDcsOpZSB1biByYXN0ZXIgdmlydHVlbCBhdmVjIHVuZSBzZXVsZSB2YWxldXIgZGUgcGl4ZWwuXCIsXG5cdFx0Y29uc3RhbnREZXNjOiBcIkNldHRlIGZvbmN0aW9uIGNyw6llIHVuIHJhc3RlciB2aXJ0dWVsIGF2ZWMgdW5lIHNldWxlIHZhbGV1ciBkZSBwaXhlbCBwb3V2YW50IMOqdHJlIHV0aWxpc8OpZSBkYW5zIGRlcyBtb2TDqGxlcyBkZSBmb25jdGlvbnMgcmFzdGVyIGV0IHBvdXIgdHJhaXRlciB1biBqZXUgZGUgZG9ubsOpZXMgbW9zYcOvcXVlLjxkaXY+PGJyLz5MYSB2YWxldXIgY29uc3RhbnRlIGVzdCB1dGlsaXPDqWUgcG91ciBjaGFxdWUgdmFsZXVyIGRlIHBpeGVsIGR1IHJhc3Rlci48L2Rpdj5cIixcblx0XHRjb250b3VyTmFtZTogXCJJc29saWduZVwiLFxuXHRcdGNvbnRvdXJTbmlwOiBcIkNyw6llIGRlcyBpc29saWduZXMuXCIsXG5cdFx0Y29udG91ckRlc2M6IFwiTGEgZm9uY3Rpb24gSXNvbGlnbmUgZ8OpbsOocmUgZGVzIGlzb2xpZ25lcyBlbiByZWxpYW50IGRlcyBwb2ludHMgZGUgbcOqbWUgw6lsw6l2YXRpb24gw6AgcGFydGlyIGTigJl1biBqZXUgZGUgZG9ubsOpZXMgcmFzdGVyIGTigJnDqWzDqXZhdGlvbi4gTGVzIGlzb2xpZ25lcyBzb250IGNyw6nDqWVzIGVuIHRhbnQgcXVlIHJhc3RlcnMgcG91ciBsYSB2aXN1YWxpc2F0aW9uLiBMZXMgZm9uY3Rpb25uYWxpdMOpcyBjbMOpcyBzdWl2YW50ZXMgb3B0aW1pc2VudCBsYSBmb25jdGlvbiA6IGxlcyBpc29saWduZXMgc29udCBnw6luw6lyw6llcyByYXBpZGVtZW50IGV0IGR5bmFtaXF1ZW1lbnQgc3VyIGRlcyBqZXV4IGRlIGRvbm7DqWVzIHRyw6hzIHZvbHVtaW5ldXgsIHRlbHMgcXVlIFdvcmxkIEVsZXZhdGlvbiAow6lsw6l2YXRpb24gbW9uZGlhbGUpLiBMZXMgaXNvbGlnbmVzIHBldXZlbnQgw6p0cmUgbGlzc8OpZXMgcG91ciBvZmZyaXIgdW5lIGFwcGFyZW5jZSBwbHVzIHNhdGlzZmFpc2FudGUgc3VyIGxlIHBsYW4gY2FydG9ncmFwaGlxdWUgdG91dCBlbiBjb25zZXJ2YW50IGxldXIgcHLDqWNpc2lvbi4gTOKAmWludGVydmFsbGUgZGVzIGlzb2xpZ25lcyBlc3QgY29udHLDtGzDqSBkeW5hbWlxdWVtZW50LCBsZXMgb3B0aW9ucyBlbiBzb3J0aWUgc29udCBub3RhbW1lbnQgbGVzIGlzb2xpZ25lcywgbGVzIGlzb2xpZ25lcyBk4oCZaW5kZXggZXQgbGVzIGlzb2xpZ25lcyByZW1wbGllcy48ZGl2Pjxici8+TGEgY3LDqWF0aW9uIGTigJl1bmUgY291Y2hlIGTigJlpc29saWduZXMgZW4gdGFudCBxdWUgcHJvZHVpdCByYXN0ZXIgZXN0IHV0aWxlIHBvdXIgdW5lIHZhc3RlIGdhbW1lIGTigJlhcHBsaWNhdGlvbnMsIGNhciBsZXMgaXNvbGlnbmVzIHBldXZlbnQgc2Ugc3VwZXJwb3NlciBzdXIgdW5lIGNhcnRlIGV0IG9mZnJlbnQgZGVzIGluZm9ybWF0aW9ucyBzdXIgbGUgTU5UIHNhbnMgbWFzcXVlciBsZXMgZG9ubsOpZXMgc291cy1qYWNlbnRlcy4gRWxsZXMgc29udCB1dGlsZXMgZGFucyBkZSBub21icmV1c2VzIGFwcGxpY2F0aW9ucywgdGVsbGVzIHF1ZSBsZSBnw6luaWUgY2l2aWwsIGzigJlhZ3JpY3VsdHVyZSBldCBsYSBnZXN0aW9uIGRlIGzigJllYXUuPC9kaXY+XCIsXG5cdFx0Y29udHJhc3RCcmlnaHRuZXNzTmFtZTogXCJDb250cmFzdGUgZXQgbHVtaW5vc2l0w6lcIixcblx0XHRjb250cmFzdEJyaWdodG5lc3NTbmlwOiBcIkFqdXN0ZSBsZSBjb250cmFzdGUgZXQgbGEgbHVtaW5vc2l0w6kgZOKAmXVuIHJhc3Rlci5cIixcblx0XHRjb250cmFzdEJyaWdodG5lc3NEZXNjOiBcIkxhIGZvbmN0aW9uIENvbnRyYXN0ZSBldCBsdW1pbm9zaXTDqSBhbcOpbGlvcmUgbOKAmWFwcGFyZW5jZSBkZXMgZG9ubsOpZXMgcmFzdGVyIGVuIG1vZGlmaWFudCBsYSBsdW1pbm9zaXTDqSBldCBsZSBjb250cmFzdGUgYXUgc2VpbiBkZSBs4oCZaW1hZ2UuIExhIGx1bWlub3NpdMOpIGFtw6lsaW9yZSBsYSBjbGFydMOpIGdsb2JhbGUgZGUgbOKAmWltYWdl4oCUcGFyIGV4ZW1wbGUsIHBvdXIgcmVuZHJlIHBsdXMgY2xhaXJlcyBkZXMgY291bGV1cnMgc29tYnJlcyBldCBwb3VyIHJlbmRyZSBwbHVzIHDDomxlcyBkZXMgY291bGV1cnMgY2xhaXJlc+KAlHRhbmRpcyBxdWUgbGUgY29udHJhc3RlIGFqdXN0ZSBsYSBkaWZmw6lyZW5jZSBlbnRyZSBsZXMgY291bGV1cnMgbGVzIHBsdXMgc29tYnJlcyBldCBsZXMgY291bGV1cnMgbGVzIHBsdXMgY2xhaXJlcy48ZGl2Pjxici8+Q2V0dGUgZm9uY3Rpb24gbW9kaWZpZSBsZXMgdmFsZXVycyBkZXMgcGl4ZWxzLiBVdGlsaXNlei1sYSBsb3JzcXVlIHZvdXMgc291aGFpdGV6IGFtw6lsaW9yZXIgbOKAmWFwcGFyZW5jZSBkZXMgZG9ubsOpZXMsIG1haXMgcGFzIHNpIHZvdXMgc291aGFpdGV6IHV0aWxpc2VyIGxlcyBkb25uw6llcyBkYW5zIGxlIGNhZHJlIGTigJl1bmUgYW5hbHlzZSBxdWkgbsOpY2Vzc2l0ZXJhaXQgbGVzIHZhbGV1cnMgZGUgcGl4ZWxzIGJydXRlcy4gQ2V0dGUgZm9uY3Rpb24gZXN0IHV0aWxlIGxvcnNxdWUgdm91cyBwdWJsaWV6IGxlcyBkb25uw6llcyBzb3VzIGxhIGZvcm1lIGTigJl1biBzZXJ2aWNlIGTigJlpbWFnZXJpZSBwb3V2YW50IMOqdHJlIHV0aWxpc8OpIGRhbnMgZGVzIGFwcGxpY2F0aW9ucyBzYW5zIHBvc3NpYmlsaXTDqSBkZSBtb2RpZmllciBsZSBjb250cmFzdGUgZXQgbGEgbHVtaW5vc2l0w6kgZGVzIGltYWdlcywgb3UgcG91ciB2b3VzIGFzc3VyZXIgcXXigJllbGxlcyBz4oCZYWZmaWNoZW50IGF2ZWMgbGVzIHBhcmFtw6h0cmVzIHF1ZSB2b3VzIHByw6lmw6lyZXouPC9kaXY+XCIsXG5cdFx0Y29udm9sdXRpb25OYW1lOiBcIkNvbnZvbHV0aW9uXCIsXG5cdFx0Y29udm9sdXRpb25TbmlwOiBcIkFwcGxpcXVlIHVuIGZpbHRyZSBwb3VyIGFmZmluZXIsIGJyb3VpbGxlciwgZMOpdGVjdGVyIGxlcyBib3JkcywgbGlzc2VyLCBvdSBhcHBsaXF1ZXIgdW4gZMOpZ3JhZMOpIHN1ciB1biByYXN0ZXIuXCIsXG5cdFx0Y29udm9sdXRpb25EZXNjOiBcIkxhIGZvbmN0aW9uIENvbnZvbHV0aW9uIGV4w6ljdXRlIHVuIGZpbHRyYWdlIHN1ciBsZXMgdmFsZXVycyBkZSBwaXhlbHMgZOKAmXVuZSBpbWFnZSwgcGVybWV0dGFudCBk4oCZYWZmaW5lciB1bmUgaW1hZ2UsIGRlIGJyb3VpbGxlciB1bmUgaW1hZ2UsIGRlIGTDqXRlY3RlciBkZXMgY29udG91cnMgZGFucyB1bmUgaW1hZ2Ugb3UgZOKAmWVmZmVjdHVlciBk4oCZYXV0cmVzIGFtw6lsaW9yYXRpb25zIGJhc8OpZXMgc3VyIGxlIG5veWF1LiBMZXMgZmlsdHJlcyBwZXJtZXR0ZW50IGRlIHJlbmZvcmNlciBsYSBxdWFsaXTDqSBkZSBs4oCZaW1hZ2UgcmFzdGVyIGVuIMOpbGltaW5hbnQgZGVzIGRvbm7DqWVzIGZpY3RpdmVzIG91IGVuIGFtw6lsaW9yYW50IGxhIHJlcHLDqXNlbnRhdGlvbiBkZXMgZW50aXTDqXMgcHLDqXNlbnRlcyBkYW5zIGxlcyBkb25uw6llcy4gQ2VzIGZpbHRyZXMgZGUgY29udm9sdXRpb24gc+KAmWFwcGxpcXVlbnQgw6AgdW4gbm95YXUgc3VwZXJwb3PDqSBlbiBtb3V2ZW1lbnQgKGZlbsOqdHJlIG91IHZvaXNpbmFnZSksIHBhciBleGVtcGxlIDMgcGFyIDMuIExlcyBmaWx0cmVzIGRlIGNvbnZvbHV0aW9uIGZvbmN0aW9ubmVudCBlbiBjYWxjdWxhbnQgbGEgdmFsZXVyIGR1IHBpeGVsIGVuIGZvbmN0aW9uIGRlIGxhIHBvbmTDqXJhdGlvbiBkZXMgcGl4ZWxzIHZvaXNpbnMuXCIsXG5cdFx0Y29ycmlkb3JOYW1lOiBcIkNvdWxvaXJcIixcblx0XHRjb3JyaWRvclNuaXA6IFwiQ2FsY3VsZSBsYSBzb21tZSBkZXMgY2/Du3RzIGN1bXVsw6lzIHBvdXIgZGV1eCByYXN0ZXJzIGRlIGNvw7t0cyBjdW11bMOpcyBlbiBlbnRyw6llLlwiLFxuXHRcdGNvcnJpZG9yRGVzYzogXCJMYSBmb25jdGlvbiBDb3Vsb2lyIGNhbGN1bGUgbGEgc29tbWUgZGVzIGNvw7t0cyBjdW11bMOpcyBwb3VyIGRldXggcmFzdGVycyBkZSBjb8O7dHMgY3VtdWzDqXMgZW4gZW50csOpZS4gVm91cyBwb3V2ZXogZW1wbG95ZXIgbGVzIGRldXggcmFzdGVycyBlbiBlbnRyw6llLCBtYWlzIHNpIHZvdXMgc291aGFpdGV6IG9idGVuaXIgdW4gcsOpc3VsdGF0IHNpZ25pZmljYXRpZiwgdm91cyBkZXZleiB1dGlsaXNlciBkZXMgcmFzdGVycyBkZSBjb8O7dHMgY3VtdWzDqXMgZW4gc29ydGllIHF1aSBu4oCZb250IHBhcyDDqXTDqSBtb2RpZmnDqXMuIEzigJlvcmRyZSBkZXMgZGV1eCBlbnRyw6llcyBu4oCZYSBwYXMgZOKAmWltcG9ydGFuY2UuXCIsXG5cdFx0Y29zSE5hbWU6IFwiQ29zSFwiLFxuXHRcdGNvc0hTbmlwOiBcIkNhbGN1bGUgbGUgY29zaW51cyBoeXBlcmJvbGlxdWUgZGVzIGNlbGx1bGVzIGTigJl1biByYXN0ZXIuXCIsXG5cdFx0Y29zSERlc2M6IFwiTGEgZm9uY3Rpb24gY2FsY3VsZSBsZSBjb3NpbnVzIGh5cGVyYm9saXF1ZSBkZXMgcGl4ZWxzIGRhbnMgdW4gcmFzdGVyLlwiLFxuXHRcdGNvc05hbWU6IFwiQ29zXCIsXG5cdFx0Y29zU25pcDogXCJDYWxjdWxlIGxlIGNvc2ludXMgZOKAmXVuZSBjZWxsdWxlIGRhbnMgdW4gcmFzdGVyLlwiLFxuXHRcdGNvc0Rlc2M6IFwiTGEgZm9uY3Rpb24gY2FsY3VsZSBsZSBjb3NpbnVzIGRlcyBwaXhlbHMgZGFucyB1biByYXN0ZXIuXCIsXG5cdFx0Y29zdEFsbG9jYXRpb25OYW1lOiBcIkFsbG9jYXRpb24gZGUgY2/Du3RcIixcblx0XHRjb3N0QWxsb2NhdGlvblNuaXA6IFwiQ2FsY3VsZSwgcG91ciBjaGFxdWUgY2VsbHVsZSwgc2Egc291cmNlIGRlIG1vaW5kcmUgY2/Du3Qgw6AgcGFydGlyIGR1IHBsdXMgZmFpYmxlIGNvw7t0IGN1bXVsw6kgc3VyIHVuZSBzdXJmYWNlIGRlIGNvw7t0LlwiLFxuXHRcdGNvc3RBbGxvY2F0aW9uRGVzYzogXCJMYSBmb25jdGlvbiBBbGxvY2F0aW9uIGRlIGNvw7t0IGNhbGN1bGUsIHBvdXIgY2hhcXVlIGNlbGx1bGUsIHNhIHNvdXJjZSBkZSBtb2luZHJlIGNvw7t0IMOgIHBhcnRpciBkdSBwbHVzIGZhaWJsZSBjb8O7dCBjdW11bMOpIHN1ciB1bmUgc3VyZmFjZSBkZSBjb8O7dC5cIixcblx0XHRjb3N0QmFja0xpbmtOYW1lOiBcIkFudMOpY8OpZGVuY2UgZGUgY2/Du3RcIixcblx0XHRjb3N0QmFja0xpbmtTbmlwOiBcIkTDqWZpbml0IGxlIHZvaXNpbiwgw6Agc2F2b2lyIGxhIGNlbGx1bGUgc3VpdmFudGUgc3VyIGxlIGNoZW1pbiBkZSBtb2luZHJlIGNvw7t0IGN1bXVsw6kgdmVycyBsYSBzb3VyY2UgZGUgbW9pbmRyZSBjb8O7dC5cIixcblx0XHRjb3N0QmFja0xpbmtEZXNjOiBcIkxhIGZvbmN0aW9uIEFudMOpY8OpZGVuY2UgZGUgY2/Du3QgZMOpZmluaXQgbGUgdm9pc2luLCDDoCBzYXZvaXIgbGEgY2VsbHVsZSBzdWl2YW50ZSBzdXIgbGUgY2hlbWluIGRlIG1vaW5kcmUgY2/Du3QgY3VtdWzDqSB2ZXJzIGxhIHNvdXJjZSBkZSBtb2luZHJlIGNvw7t0LjxkaXY+PGJyLz5MZSByYXN0ZXIgZOKAmWFudMOpY8OpZGVuY2UgY29udGllbnQgZGVzIHZhbGV1cnMgZGUgesOpcm8gw6AgaHVpdCBxdWkgZMOpZmluaXNzZW50IGxhIGRpcmVjdGlvbiBvdSBpZGVudGlmaWVudCBsYSBjZWxsdWxlIHZvaXNpbmUgc3VpdmFudGUgKGxhIGNlbGx1bGUgc3VpdmFudGUpIGxlIGxvbmcgZHUgY2hlbWluIGRlIG1vaW5kcmUgY2/Du3QgY3VtdWzDqSDDoCBwYXJ0aXIgZOKAmXVuZSBjZWxsdWxlIHBvdXIgYXR0ZWluZHJlIHNhIHNvdXJjZSBkZSBtb2luZHJlIGNvw7t0LiBTaSBsZSBjaGVtaW4gZG9pdCBwYXNzZXIgw6AgbOKAmWludMOpcmlldXIgZHUgdm9pc2luIGRlIGRyb2l0ZSwgbGEgY2VsbHVsZSBzZSB2b2l0IGF0dHJpYnVlciBsYSB2YWxldXIgMSwgMiBwb3VyIGxhIGNlbGx1bGUgZGFucyBsYSBkaWFnb25hbGUgaW5mw6lyaWV1cmUgZHJvaXRlLCBldCBhaW5zaSBkZSBzdWl0ZSBkYW5zIGxlIHNlbnMgaG9yYWlyZS4gTGEgdmFsZXVyIDAgZXN0IHLDqXNlcnbDqWUgYXV4IGNlbGx1bGVzIHNvdXJjZXMuPC9kaXY+XCIsXG5cdFx0Y29zdERpc3RhbmNlTmFtZTogXCJEaXN0YW5jZSBkZSBjb8O7dFwiLFxuXHRcdGNvc3REaXN0YW5jZVNuaXA6IFwiQ2FsY3VsZSwgcG91ciBjaGFxdWUgY2VsbHVsZSwgbGEgZGlzdGFuY2UgZGUgbW9pbmRyZSBjb8O7dCBjdW11bMOpIGRlcHVpcyBvdSB2ZXJzIGxhIHNvdXJjZSBkZSBtb2luZHJlIGNvw7t0IHN1ciB1bmUgc3VyZmFjZSBkZSBjb8O7dC5cIixcblx0XHRjb3N0RGlzdGFuY2VEZXNjOiBcIkxhIGZvbmN0aW9uIERpc3RhbmNlIGRlIGNvw7t0IGNhbGN1bGUgbGEgZGlzdGFuY2UgZGUgbW9pbmRyZSBjb8O7dCBjdW11bMOpIHBvdXIgY2hhcXVlIGNlbGx1bGUgZGVwdWlzIG91IHZlcnMgbGEgc291cmNlIGRlIG1vaW5kcmUgY2/Du3Qgc3VyIHVuZSBzdXJmYWNlIGRlIGNvw7t0LlwiLFxuXHRcdGNvc3RQYXRoTmFtZTogXCJDaGVtaW4gZGUgY2/Du3RcIixcblx0XHRjb3N0UGF0aFNuaXA6IFwiQ2FsY3VsZSBsZSBjaGVtaW4gZGUgbW9pbmRyZSBjb8O7dCBlbnRyZSB1bmUgc291cmNlIGV0IHVuZSBkZXN0aW5hdGlvbi5cIixcblx0XHRjb3N0UGF0aERlc2M6IFwiTGEgZm9uY3Rpb24gQ2hlbWluIGRlIGNvw7t0IGNhbGN1bGUgbGUgY2hlbWluIGRlIG1vaW5kcmUgY2/Du3QgZW50cmUgdW5lIHNvdXJjZSBldCB1bmUgZGVzdGluYXRpb24uPGRpdj48YnIvPkNldHRlIGZvbmN0aW9uIHBlcm1ldCBk4oCZb2J0ZW5pciB1biByYXN0ZXIgZW4gc29ydGllIHF1aSBlbnJlZ2lzdHJlIGxlIG91IGxlcyBjaGVtaW5zIGRlIG1vaW5kcmUgY2/Du3Qgw6AgcGFydGlyIGRlcyBlbXBsYWNlbWVudHMgc8OpbGVjdGlvbm7DqXMgdmVycyBsYSBjZWxsdWxlIHNvdXJjZSBsYSBwbHVzIHByb2NoZSB0ZWxsZSBxdWUgZMOpZmluaWUgZGFucyBsYSBzdXJmYWNlIGRlIGNvw7t0IGN1bXVsw6kgKGVuIHRlbmFudCBjb21wdGUgZGVzIGRpc3RhbmNlcyBkZSBjb8O7dCkuPC9kaXY+XCIsXG5cdFx0Y3VydmF0dXJlTmFtZTogXCJDb3VyYnVyZVwiLFxuXHRcdGN1cnZhdHVyZVNuaXA6IFwiQ2FsY3VsZSBsYSBjb3VyYnVyZSBk4oCZdW5lIHN1cmZhY2UgcmFzdGVyLCBlbiBpbmNsdWFudCDDqXZlbnR1ZWxsZW1lbnQgbGEgY291cmJ1cmUgbG9uZ2l0dWRpbmFsZSBldCB0cmFuc3ZlcnNhbGUuXCIsXG5cdFx0Y3VydmF0dXJlRGVzYzogXCJMYSBmb25jdGlvbiBDb3VyYnVyZSBhZmZpY2hlIGxhIGZvcm1lIG91IGxhIGNvdXJidXJlIGRlIGxhIHBlbnRlLiBVbmUgcGFydGllIGTigJl1bmUgc3VyZmFjZSBwZXV0IMOqdHJlIGNvbmNhdmUgb3UgY29udmV4ZS4gSWwgZXN0IHBvc3NpYmxlIGRlIGxlIHNhdm9pciBlbiBjb25zdWx0YW50IGxhIHZhbGV1ciBkZSBjb3VyYnVyZS4gTGEgY291cmJ1cmUgZXN0IG9idGVudWUgZW4gY2FsY3VsYW50IGxhIGTDqXJpdsOpZSBzZWNvbmRlIGRlIGxhIHN1cmZhY2UuPGRpdj48YnIvPkxhIHNvcnRpZSBnw6luw6lyw6llIHBhciBsYSBmb25jdGlvbiBDb3VyYnVyZSBwZXJtZXQgZGUgZMOpY3JpcmUgbGVzIGNhcmFjdMOpcmlzdGlxdWVzIHBoeXNpcXVlcyBk4oCZdW4gYmFzc2luIGRlIGRyYWluYWdlIGFmaW4gZGUgY29tcHJlbmRyZSBsZXMgcHJvY2Vzc3VzIGTigJnDqXJvc2lvbiBldCBk4oCZw6ljb3VsZW1lbnQuIExhIHZhbGV1ciBkZSBjb3VyYnVyZSBwZXJtZXQgZGUgcmVjaGVyY2hlciBsZXMgbW90aWZzIGTigJnDqXJvc2lvbiBkdSBzb2wsIGFpbnNpIHF1ZSBsYSBkaXN0cmlidXRpb24gZGUgbOKAmWVhdSBzdXIgbGVzIHRlcnJlcy4gTGEgY291cmJ1cmUgbG9uZ2l0dWRpbmFsZSBhZmZlY3RlIGzigJlhY2PDqWzDqXJhdGlvbiBldCBsYSBkw6ljw6lsw6lyYXRpb24gZHUgZmx1eCwgY2UgcXVpIGluZmx1ZW5jZSBs4oCZw6lyb3Npb24gZXQgbGEgc8OpZGltZW50YXRpb24uIExhIGNvdXJidXJlIHBsYW5pZm9ybWUgaW5mbHVlbmNlIGxhIGNvbnZlcmdlbmNlIGV0IGxhIGRpdmVyZ2VuY2UgZHUgZmx1eC48L2Rpdj5cIixcblx0XHRkaXZpZGVOYW1lOiBcIkRpdmlzaW9uXCIsXG5cdFx0ZGl2aWRlU25pcDogXCJEaXZpc2UgbGVzIHZhbGV1cnMgZGUgZGV1eCByYXN0ZXJzLCBjZWxsdWxlIHBhciBjZWxsdWxlLlwiLFxuXHRcdGRpdmlkZURlc2M6IFwiTGEgZm9uY3Rpb24gRGl2aXNpb24gZGl2aXNlIGxlcyB2YWxldXJzIGRlIGRldXggcmFzdGVycywgcGl4ZWwgcGFyIHBpeGVsLlwiLFxuXHRcdGVsZXZhdGlvblZvaWRGaWxsTmFtZTogXCJSZW1wbGlzc2FnZSBkZXMgdmlkZXMgZOKAmcOpbMOpdmF0aW9uXCIsXG5cdFx0ZWxldmF0aW9uVm9pZEZpbGxTbmlwOiBcIkNyw6llIGRlcyBwaXhlbHMgZGFucyBsZXMgem9uZXMgY29tcG9ydGFudCBkZXMgZGlzY29udGludWl0w6lzIGRhbnMgdm9zIGRvbm7DqWVzIGTigJnDqWzDqXZhdGlvbi5cIixcblx0XHRlbGV2YXRpb25Wb2lkRmlsbERlc2M6IFwiTGEgZm9uY3Rpb24gZGUgcmVtcGxpc3NhZ2UgZGVzIHZpZGVzIGTigJnDqWzDqXZhdGlvbiBwZXJtZXQgZGUgY3LDqWVyIGRlcyBwaXhlbHMgbG9yc3F1ZSBkZXMgZGlzY29udGludWl0w6lzIHNvbnQgcHLDqXNlbnRlcyBkYW5zIHZvcyBkb25uw6llcyBk4oCZw6lsw6l2YXRpb24uPGRpdj48YnIvPkxlcyB2aWRlcyBzZSBwcm9kdWlzZW50IGxvcnNxdeKAmWF1Y3VuIHBvaW50IG7igJllc3QgY29sbGVjdMOpIGRhbnMgbGEgc3VyZmFjZSByZXByw6lzZW50w6llIHBhciB1biBwaXhlbCBkYW5zIGxlIHJhc3RlciByw6lzdWx0YW50LiBMZXMgdmlkZXMgc29udCBzb3V2ZW50IHByb3ZvcXXDqXMgcGFyIGxhIHByw6lzZW5jZSBkZSBwbGFucyBk4oCZZWF1LCBvdSBwYXIgbGEgc8OpbGVjdGlvbiBvdSBs4oCZZXhjbHVzaW9uIGRlIHR5cGVzIGRlIGNsYXNzZXMuIExlIHJlbXBsaXNzYWdlIGRlcyB2aWRlcyBlc3QgdXRpbGlzw6kgbGUgcGx1cyBzb3V2ZW50IGxvcnMgZGUgbGEgZ8OpbsOpcmF0aW9uIGTigJl1bmUgc3VyZmFjZSBhdSBzb2wuPC9kaXY+XCIsXG5cdFx0ZXF1YWxUb05hbWU6IFwiw4lnYWwgw6BcIixcblx0XHRlcXVhbFRvU25pcDogXCJFZmZlY3R1ZSB1bmUgb3DDqXJhdGlvbiByZWxhdGlvbm5lbGxlIMOJZ2FsIMOgIHN1ciBkZXV4IGVudHLDqWVzLCBjZWxsdWxlIHBhciBjZWxsdWxlLiBSZW52b2llIGxhIHZhbGV1ciAxIHBvdXIgbGVzIGNlbGx1bGVzIHBvdXIgbGVzcXVlbGxlcyBsZSBwcmVtaWVyIHJhc3RlciBlc3Qgw6lnYWwgYXUgc2Vjb25kIHJhc3RlciwgZXQgbGEgdmFsZXVyIDAgZGFucyBsZSBjYXMgY29udHJhaXJlLlwiLFxuXHRcdGVxdWFsVG9EZXNjOiBcIkxhIGZvbmN0aW9uIGVmZmVjdHVlIHVuZSBvcMOpcmF0aW9uIMOJZ2FsIMOgIHN1ciBkZXV4IHJhc3RlcnMsIHBpeGVsIHBhciBwaXhlbC4gRWxsZSByZW52b2llIGxhIHZhbGV1ciAxIHBvdXIgbGVzIHBpeGVscyBwb3VyIGxlc3F1ZWxzIGxlIHByZW1pZXIgcmFzdGVyIGVzdCDDqWdhbCBhdSBzZWNvbmQgcmFzdGVyLCBldCBsYSB2YWxldXIgMCBkYW5zIGxlIGNhcyBjb250cmFpcmUuXCIsXG5cdFx0ZXVjQWxsb2NhdGlvbk5hbWU6IFwiQWxsb2NhdGlvbiBldWNsaWRpZW5uZVwiLFxuXHRcdGV1Y0FsbG9jYXRpb25TbmlwOiBcIkNhbGN1bGUsIHBvdXIgY2hhcXVlIGNlbGx1bGUsIGxhIHNvdXJjZSBsYSBwbHVzIHByb2NoZSBlbiBmb25jdGlvbiBkZSBsYSBkaXN0YW5jZSBldWNsaWRpZW5uZS5cIixcblx0XHRldWNBbGxvY2F0aW9uRGVzYzogXCJMYSBmb25jdGlvbiBBbGxvY2F0aW9uIGV1Y2xpZGllbm5lIGNhbGN1bGUsIHBvdXIgY2hhcXVlIGNlbGx1bGUsIGxhIHNvdXJjZSBsYSBwbHVzIHByb2NoZSBlbiBmb25jdGlvbiBkZSBsYSBkaXN0YW5jZSBldWNsaWRpZW5uZS5cIixcblx0XHRldWNEaXJlY3Rpb25OYW1lOiBcIkRpcmVjdGlvbiBldWNsaWRpZW5uZVwiLFxuXHRcdGV1Y0RpcmVjdGlvblNuaXA6IFwiQ2FsY3VsZSwgcG91ciBjaGFxdWUgY2VsbHVsZSwgbGEgZGlyZWN0aW9uIGVuIGRlZ3LDqXMgcGFyIHJhcHBvcnQgw6AgbGEgc291cmNlIGxhIHBsdXMgcHJvY2hlLlwiLFxuXHRcdGV1Y0RpcmVjdGlvbkRlc2M6IFwiTGEgZm9uY3Rpb24gRGlyZWN0aW9uIGV1Y2xpZGllbm5lIGNhbGN1bGUsIHBvdXIgY2hhcXVlIGNlbGx1bGUsIGxhIGRpcmVjdGlvbiBlbiBkZWdyw6lzIHBhciByYXBwb3J0IMOgIGxhIHNvdXJjZSBsYSBwbHVzIHByb2NoZS4gPGRpdj48YnIvPkxhIGRpcmVjdGlvbiBlc3QgY2FsY3Vsw6llIMOgIHBhcnRpciBkdSBjZW50cmUgZGUgY2hhcXVlIGNlbGx1bGUgdmVycyBsZSBjZW50cmUgZGUgbGEgY2VsbHVsZSBzb3VyY2UgbGEgcGx1cyBwcm9jaGUuIExhIHBsYWdlIGRlIHZhbGV1cnMgc+KAmcOpdGVuZCBkZSAwIMOgIDM2MCBkZWdyw6lzLCAwIMOpdGFudCByw6lzZXJ2w6kgYXV4IGNlbGx1bGVzIHNvdXJjZS4gTGEgZGlyZWN0aW9uIHBsZWluIGVzdCAoZHJvaXRlKSBjb3JyZXNwb25kIMOgIDkwIGV0IGxlcyB2YWxldXJzIGF1Z21lbnRlbnQgZGFucyBsZSBzZW5zIGhvcmFpcmUgKDE4MCBjb3JyZXNwb25kIGF1IHN1ZCwgMjcwIMOgIGzigJlvdWVzdCBldCAzNjAgYXUgbm9yZCkuPC9kaXY+XCIsXG5cdFx0ZXVjRGlzdGFuY2VOYW1lOiBcIkRpc3RhbmNlIGV1Y2xpZGllbm5lXCIsXG5cdFx0ZXVjRGlzdGFuY2VTbmlwOiBcIkNhbGN1bGUsIHBvdXIgY2hhcXVlIGNlbGx1bGUsIGxhIGRpc3RhbmNlIGV1Y2xpZGllbm5lIHBhciByYXBwb3J0IMOgIGxhIHNvdXJjZSBsYSBwbHVzIHByb2NoZS5cIixcblx0XHRldWNEaXN0YW5jZURlc2M6IFwiTGEgZm9uY3Rpb24gRGlzdGFuY2UgZXVjbGlkaWVubmUgY2FsY3VsZSwgcG91ciBjaGFxdWUgY2VsbHVsZSwgbGEgZGlzdGFuY2UgZXVjbGlkaWVubmUgcGFyIHJhcHBvcnQgw6AgbGEgc291cmNlIGxhIHBsdXMgcHJvY2hlLlwiLFxuXHRcdGV4cDEwTmFtZTogXCJFeHAxMFwiLFxuXHRcdGV4cDEwU25pcDogXCJDYWxjdWxlIGzigJlleHBvbmVudGllbGxlIGRlIGJhc2UgMTAgZGVzIGNlbGx1bGVzIGTigJl1biByYXN0ZXIuXCIsXG5cdFx0ZXhwMTBEZXNjOiBcIkxhIGZvbmN0aW9uIEV4cCAxMCBjYWxjdWxlIGzigJlleHBvbmVudGllbGxlIGRlIGJhc2UgMTAgZGVzIHBpeGVscyBkYW5zIHVuIHJhc3Rlci5cIixcblx0XHRleHAyTmFtZTogXCJFeHAyXCIsXG5cdFx0ZXhwMlNuaXA6IFwiQ2FsY3VsZSBs4oCZZXhwb25lbnRpZWxsZSBkZSBiYXNlIDIgZGVzIGNlbGx1bGVzIGTigJl1biByYXN0ZXIuXCIsXG5cdFx0ZXhwMkRlc2M6IFwiQ2V0dGUgZm9uY3Rpb24gY2FsY3VsZSBs4oCZZXhwb25lbnRpZWxsZSBkZSBiYXNlIDIgZGVzIHBpeGVscyBkYW5zIHVuIHJhc3Rlci5cIixcblx0XHRleHBOYW1lOiBcIkV4cFwiLFxuXHRcdGV4cFNuaXA6IFwiQ2FsY3VsZSBs4oCZZXhwb25lbnRpZWxsZSBkZSBiYXNlIGUgZGVzIGNlbGx1bGVzIGTigJl1biByYXN0ZXIuXCIsXG5cdFx0ZXhwRGVzYzogXCJDZXR0ZSBmb25jdGlvbiBjYWxjdWxlIGzigJlleHBvbmVudGllbGxlIGRlIGJhc2UgZSBkZXMgcGl4ZWxzIGRhbnMgdW4gcmFzdGVyLlwiLFxuXHRcdGV4dHJhY3RCYW5kTmFtZTogXCJFeHRyYWlyZSBsZXMgYmFuZGVzXCIsXG5cdFx0ZXh0cmFjdEJhbmRTbmlwOiBcIlNww6ljaWZpZSBsZXMgYmFuZGVzIGF2ZWMgbGVzcXVlbGxlcyB0cmF2YWlsbGVyIGxvcnMgZGUgbOKAmXV0aWxpc2F0aW9uIGRlIGpldXggZGUgZG9ubsOpZXMgbXVsdGliYW5kZXMuXCIsXG5cdFx0ZXh0cmFjdEJhbmREZXNjOiBcIiBMYSBmb25jdGlvbiBFeHRyYWlyZSBsZXMgYmFuZGVzIHBlcm1ldCBk4oCZZXh0cmFpcmUgdW5lIG91IHBsdXNpZXVycyBiYW5kZXMsIG91IGRlIHLDqW9yZ2FuaXNlciBsZXMgYmFuZGVzIGRhbnMgdW4gamV1IGRlIGRvbm7DqWVzIHJhc3RlciBtdWx0aWJhbmRlLjxkaXY+PGJyLz5Wb3VzIHBvdXZleiB1dGlsaXNlciBsYSBmb25jdGlvbiBFeHRyYWlyZSBsZXMgYmFuZGVzIGF2YW50IHF1ZSBk4oCZYXV0cmVzIGZvbmN0aW9ucyBzb2llbnQgYXBwbGlxdcOpZXMgKEFyaXRobcOpdGlxdWUsIHBhciBleGVtcGxlKSwgcG91ciBjb250csO0bGVyIGxlcyBiYW5kZXMgcXVpIHNvbnQgdXRpbGlzw6llcyBlbiBlbnRyw6llIGRhbnMgbGEgcHJvY2hhaW5lIGZvbmN0aW9uLjwvZGl2PlwiLFxuXHRcdGZpbGxOYW1lOiBcIlJlbXBsaXNzYWdlXCIsXG5cdFx0ZmlsbFNuaXA6IFwiUmVtcGxpdCBsZXMgY3V2ZXR0ZXMgZOKAmXVuZSBzdXJmYWNlIHJhc3RlciBwb3VyIHN1cHByaW1lciBkZSBsw6lnw6hyZXMgaW1wZXJmZWN0aW9ucyBkYW5zIGxlcyBkb25uw6llcy5cIixcblx0XHRmaWxsRGVzYzogXCJMYSBmb25jdGlvbiBnbG9iYWxlIFJlbXBsaXNzYWdlIGxvY2FsaXNlIGV0IHJlbXBsaXQgbGVzIGN1dmV0dGVzIGV0IGxlcyBwaWNzIGRhbnMgdW4gcmFzdGVyIGRlIHN1cmZhY2UgZOKAmcOpbMOpdmF0aW9uIGFmaW4gZGUgc3VwcHJpbWVyIGxlcyBwZXRpdGVzIGltcGVyZmVjdGlvbnMgZGFucyBsZXMgZG9ubsOpZXMuIExhIGZvbmN0aW9uIGVmZmVjdHVlIGxlIHJlbXBsaXNzYWdlIGRlIG1hbmnDqHJlIGl0w6lyYXRpdmUganVzcXXigJnDoCBjZSBxdWUgdG91dGVzIGxlcyBjdXZldHRlcyBzb2llbnQgcmVtcGxpZXMgZGFucyBsYSBsaW1pdGUgWiBzcMOpY2lmacOpZS48ZGl2Pjxici8+TG9yc3F14oCZdW5lIHN1cmZhY2UgZOKAmcOpbMOpdmF0aW9uIGVzdCBjcsOpw6llIGF2ZWMgZGVzIG91dGlscyBk4oCZb3J0aG9jYXJ0b2dyYXBoaWUgb3UgcGFyIGTigJlhdXRyZXMgbW95ZW5zLCBkZXMgZXJyZXVycyAocGV0aXRlcywgbWFpcyBub3RhYmxlcykgYXBwYXJhaXNzZW50IHNvdXZlbnQgc291cyBsYSBmb3JtZSBkZSBjdXZldHRlcyBldCBkZSBwaWNzIGRhbnMgbGVzIGRvbm7DqWVzLiBFbiBwaG90b2dyYW1tw6l0cmllLCBsZXMgY3V2ZXR0ZXMgZXQgbGVzIHBpY3Mgc29udCBzb3V2ZW50IG5vbW3DqXMgdHJvdXMgZXQgcG9pbnRlcy4gQ29tbWUgbGVzIGRvbm7DqWVzIGRlIHN1cmZhY2Ugc29udCBzb3V2ZW50IHV0aWxpc8OpZXMgZW4gbW9kw6lsaXNhdGlvbiAobGEgbW9kw6lsaXNhdGlvbiBoeWRyb2xvZ2lxdWUsIHBhciBleGVtcGxlKSwgaWwgZXN0IGltcG9ydGFudCBkZSBjb3JyaWdlciBjZXMgY3V2ZXR0ZXMgZXQgcGljcyBkZSBtYW5pw6hyZSBjb2jDqXJlbnRlIHBhciByYXBwb3J0IGF1eCBkb25uw6llcyBlbnZpcm9ubmFudGVzLjwvZGl2PlwiLFxuXHRcdGZsb2F0TmFtZTogXCJGbG90dGFudFwiLFxuXHRcdGZsb2F0U25pcDogXCJDb252ZXJ0aXQgY2hhcXVlIHZhbGV1ciBkZSBjZWxsdWxlIGTigJl1biByYXN0ZXIgZW4gdW5lIHJlcHLDqXNlbnRhdGlvbiBlbiB2aXJndWxlIGZsb3R0YW50ZS5cIixcblx0XHRmbG9hdERlc2M6IFwiTGEgZm9uY3Rpb24gRmxvdHRhbnQgY29udmVydGl0IGNoYXF1ZSB2YWxldXIgZGUgcGl4ZWwgZOKAmXVuIHJhc3RlciBlbiB1bmUgcmVwcsOpc2VudGF0aW9uIGVuIHZpcmd1bGUgZmxvdHRhbnRlLlwiLFxuXHRcdGZsb3dBY2N1bXVsYXRpb25OYW1lOiBcIkFjY3VtdWxhdGlvbiBkZSBmbHV4XCIsXG5cdFx0Zmxvd0FjY3VtdWxhdGlvblNuaXA6IFwiQ3LDqWUgdW4gcmFzdGVyIGRlIGZsdXggY3VtdWzDqSBkYW5zIGNoYXF1ZSBjZWxsdWxlLiBTaSBiZXNvaW4sIHZvdXMgcG91dmV6IHV0aWxpc2VyIHVuIGZhY3RldXIgZGUgcG9uZMOpcmF0aW9uLlwiLFxuXHRcdGZsb3dBY2N1bXVsYXRpb25EZXNjOiBcIkxhIGZvbmN0aW9uIGdsb2JhbGUgQWNjdW11bGF0aW9uIGRlIGZsdXggZ8OpbsOocmUgdW4gcmFzdGVyIGRlIGZsdXggY3VtdWzDqSBkYW5zIGNoYXF1ZSBwaXhlbCwgY29uZm9ybcOpbWVudCDDoCBs4oCZYWNjdW11bGF0aW9uIGRlcyBwb25kw6lyYXRpb25zIGRlIHRvdXMgbGVzIHBpeGVscyBxdWkgc+KAmcOpY291bGVudCBkYW5zIGxlcyBjZWxsdWxlcyBlbiBwZW50ZSBkZXNjZW5kYW50ZS4gU2kgYXVjdW4gcmFzdGVyIGRlIHBvbmTDqXJhdGlvbiBu4oCZZXN0IGZvdXJuaSwgdW5lIHBvbmTDqXJhdGlvbiBkZSAxIGVzdCBhdHRyaWJ1w6llIMOgIGNoYWN1biBkZXMgcGl4ZWxzLCBldCBsYSB2YWxldXIgZGVzIHBpeGVscyBkdSByYXN0ZXIgZW4gc29ydGllIGNvcnJlc3BvbmQgYXUgbm9tYnJlIGRlIHBpeGVscyBxdWkgc+KAmcOpY291bGVudCB2ZXJzIGNoYXF1ZSBwaXhlbC48ZGl2Pjxici8+TGVzIHBpeGVscyBlbiBzb3J0aWUgcHLDqXNlbnRhbnQgdW5lIGFjY3VtdWxhdGlvbiBkZSBmbHV4IMOpbGV2w6llIHNvbnQgZGVzIHpvbmVzIGRlIGZsdXggY29uY2VudHLDqSBxdWkgcGV1dmVudCDDqnRyZSB1dGlsaXPDqWVzIHBvdXIgaWRlbnRpZmllciBkZXMgY2FuYXV4IGTigJnDqWNvdWxlbWVudC4gTGVzIHBpeGVscyBlbiBzb3J0aWUgcHLDqXNlbnRhbnQgdW5lIGFjY3VtdWxhdGlvbiBkZSBmbHV4IG51bGxlIHNvbnQgZGVzIHpvbmVzIHRvcG9ncmFwaGlxdWVzIGxvY2FsZXMgw6lsZXbDqWVzIHF1aSBwZXV2ZW50IMOqdHJlIHV0aWxpc8OpZXMgcG91ciBpZGVudGlmaWVyIGRlcyBjcsOqdGVzLjwvZGl2PlwiLFxuXHRcdGZsb3dEaXJlY3Rpb25OYW1lOiBcIkRpcmVjdGlvbiBkZSBmbHV4XCIsXG5cdFx0Zmxvd0RpcmVjdGlvblNuaXA6IFwiQ3LDqWUgdW4gcmFzdGVyIGRlIGRpcmVjdGlvbiBkZSBmbHV4IMOgIHBhcnRpciBkZSBjaGFxdWUgY2VsbHVsZSB2ZXJzIHNvbiB2b2lzaW4gZGUgcGx1cyBncmFuZGUgcGVudGUgZGVzY2VuZGFudGUuXCIsXG5cdFx0Zmxvd0RpcmVjdGlvbkRlc2M6IFwiTOKAmXVuIGRlcyBwcmluY2lwYXV4IGFzcGVjdHMgZGUgbGEgZMOpcml2YXRpb24gZGVzIGNhcmFjdMOpcmlzdGlxdWVzIGh5ZHJvbG9naXF1ZXMgZOKAmXVuZSBzdXJmYWNlIGVzdCBsYSBjYXBhY2l0w6kgw6AgZMOpdGVybWluZXIgbGEgZGlyZWN0aW9uIGR1IGZsdXggZGUgY2hhcXVlIHBpeGVsIGTigJl1biByYXN0ZXIuIExhIGZvbmN0aW9uIHJhc3RlciBEaXJlY3Rpb24gZGUgZmx1eCBwcmVuZCB1bmUgc3VyZmFjZSBlbiBlbnRyw6llIGV0IGNyw6llIHVuIHJhc3RlciBkZSBkaXJlY3Rpb24gZGUgZmx1eCDDoCBwYXJ0aXIgZGUgY2hhcXVlIHBpeGVsIHZlcnMgc29uIHZvaXNpbiBkZSBwbHVzIGdyYW5kZSBwZW50ZSBkZXNjZW5kYW50ZS4gTGEgZm9uY3Rpb24gRGlyZWN0aW9uIGRlIGZsdXggcHJlbmQgZW4gY2hhcmdlIHRyb2lzIG3DqXRob2RlcyBkZSBtb2TDqWxpc2F0aW9uIGRlIGZsdXggOiBEOCAoaHVpdCBkaXJlY3Rpb25zKSwgTUZEIChNdWx0aXBsZSBGbG93IERpcmVjdGlvbikgZXQgRElORiAoRC1JbmZpbml0eSkuIFwiLFxuXHRcdGZsb3dEaXN0YW5jZU5hbWU6IFwiRGlzdGFuY2UgZOKAmcOpY291bGVtZW50XCIsXG5cdFx0Zmxvd0Rpc3RhbmNlU25pcDogXCJDYWxjdWxlLCBwb3VyIGNoYXF1ZSBjZWxsdWxlLCBsYSBkaXN0YW5jZSBkZSBwZW50ZSBkZXNjZW5kYW50ZSB2ZXJ0aWNhbGUgb3UgaG9yaXpvbnRhbGUgbWluaW1hbGUgdmVycyBsZXMgY2VsbHVsZXMgZGFucyB1biBjb3VycyBk4oCZZWF1IG91IHVuZSByaXZpw6hyZSBkYW5zIGxlc3F1ZWxsZXMgZWxsZXMgdHJhbnNpdGVudC5cIixcblx0XHRmbG93RGlzdGFuY2VEZXNjOiBcIlBvdXIgY2hhcXVlIHBpeGVsLCBsYSBmb25jdGlvbiBjYWxjdWxlIGxhIGRpc3RhbmNlIGRlIHBlbnRlIGRlc2NlbmRhbnRlIHZlcnRpY2FsZSBvdSBob3Jpem9udGFsZSBtaW5pbWFsZSB2ZXJzIGxlIG91IGxlcyBwaXhlbHMgZGFucyB1biBjb3VycyBk4oCZZWF1IG91IHVuZSByaXZpw6hyZSBkYW5zIGxlc3F1ZWxzIGlscyB0cmFuc2l0ZW50LiBTaSB1biByYXN0ZXIgZGUgZGlyZWN0aW9uIGRlIGZsdXggZmFjdWx0YXRpZiBlc3QgZm91cm5pLCBsZXMgZGlyZWN0aW9ucyBkZSBwZW50ZSBkZXNjZW5kYW50ZSBzZXJvbnQgbGltaXTDqWVzIMOgIGNlbGxlcyBkw6lmaW5pZXMgcGFyIGxlIHJhc3RlciBkZSBkaXJlY3Rpb24gZGUgZmx1eCBlbiBlbnRyw6llLiBMYSBzb3J0aWUgZXN0IHVuIHJhc3RlciBkZSBkaXN0YW5jZSBk4oCZw6ljb3VsZW1lbnQuXCIsXG5cdFx0Zm9jYWxOYW1lOiBcIlN0YXRpc3RpcXVlcyBmb2NhbGVzXCIsXG5cdFx0Zm9jYWxTbmlwOiBcIkNhbGN1bGUgbGVzIHN0YXRpc3RpcXVlcyBmb2NhbGVzIGRlIGNoYXF1ZSBwaXhlbCBk4oCZdW5lIGltYWdlIGVuIGZvbmN0aW9uIGTigJl1biB2b2lzaW5hZ2UgZm9jYWwgZMOpZmluaS5cIixcblx0XHRmb2NhbERlc2M6IFwiTGEgZm9uY3Rpb24gU3RhdGlzdGlxdWVzIGZvY2FsZXMgY2FsY3VsZSBkZXMgc3RhdGlzdGlxdWVzIGZvY2FsZXMgcG91ciBjaGFxdWUgcGl4ZWwgZOKAmXVuZSBpbWFnZSBlbiBmb25jdGlvbiBk4oCZdW4gdm9pc2luYWdlIGZvY2FsIGTDqWZpbmkuXCIsXG5cdFx0Z2VvbWV0cmljTmFtZTogXCJHw6lvbcOpdHJpcXVlXCIsXG5cdFx0Z2VvbWV0cmljU25pcDogXCJBdWdtZW50ZSBsYSBwcsOpY2lzaW9uIGRlIHBvc2l0aW9uIGTigJl1biBqZXUgZGUgZG9ubsOpZXMgZW4gdGVuYW50IGNvbXB0ZSBkZSBs4oCZw6lsw6l2YXRpb24uXCIsXG5cdFx0Z2VvbWV0cmljRGVzYzogXCJMYSBmb25jdGlvbiBHw6lvbcOpdHJpcXVlIHByb2R1aXQgdW5lIGltYWdlIG9ydGhvcmVjdGlmacOpZSDDoCBwYXJ0aXIgZOKAmXVuZSBkw6lmaW5pdGlvbiBkZSBjYXB0ZXVyIGV0IGTigJl1biBNTlQuIEVsbGUgYXVnbWVudGUgbGEgcHLDqWNpc2lvbiBkZSBwb3NpdGlvbiBk4oCZdW4gamV1IGRlIGRvbm7DqWVzIGVuIHRlbmFudCBjb21wdGUgZGUgbOKAmcOpbMOpdmF0aW9uLlwiLFxuXHRcdGdyYXlzY2FsZU5hbWU6IFwiTnVhbmNlcyBkZSBncmlzXCIsXG5cdFx0Z3JheXNjYWxlU25pcDogXCJDb252ZXJ0aXQgdW5lIGltYWdlIG11bHRpYmFuZGUgZW4gaW1hZ2UgbW9ub2JhbmRlIGVuIG51YW5jZXMgZGUgZ3Jpcy5cIixcblx0XHRncmF5c2NhbGVEZXNjOiBcIkNldHRlIGZvbmN0aW9uIGNvbnZlcnRpdCB1bmUgaW1hZ2UgbXVsdGliYW5kZSBlbiBpbWFnZSBtb25vYmFuZGUgZW4gbnVhbmNlcyBkZSBncmlzLjxkaXY+PGJyLz5DZXR0ZSBmb25jdGlvbiBhcHBsaXF1ZSBkZXMgcG9uZMOpcmF0aW9ucyBzcMOpY2lmacOpZXMgw6AgY2hhcXVlIGJhbmRlIGVuIGVudHLDqWUgZXQgbm9ybWFsaXNlIGzigJlpbWFnZSBlbiBzb3J0aWUuIExlcyBwb25kw6lyYXRpb25zIHNvbnQgc291dmVudCBhcHBsaXF1w6llcyBjYXIgY2VydGFpbmVzIGJhbmRlcyBvbnQgdW5lIGltcG9ydGFuY2UgdmFyaWFibGUgZW4gZm9uY3Rpb24gZGUgbOKAmWFwcGxpY2F0aW9uLiBBaW5zaSwgbGEgYmFuZGUgYmxldWUgY29udGllbnQgZGF2YW50YWdlIGRlIGJydWl0IHF1ZSBsZXMgYXV0cmVzIGJhbmRlcy48L2Rpdj5cIixcblx0XHRncmVhdGVyVGhhbkVxdWFsTmFtZTogXCJTdXDDqXJpZXVyIG91IMOpZ2FsIMOgXCIsXG5cdFx0Z3JlYXRlclRoYW5FcXVhbFNuaXA6IFwiRWZmZWN0dWUgdW5lIG9ww6lyYXRpb24gcmVsYXRpb25uZWxsZSBTdXDDqXJpZXVyIG91IMOpZ2FsIMOgIHN1ciBkZXV4IGVudHLDqWVzLCBjZWxsdWxlIHBhciBjZWxsdWxlLiBSZW52b2llIGxhIHZhbGV1ciAxIHBvdXIgbGVzIGNlbGx1bGVzIHBvdXIgbGVzcXVlbGxlcyBsZSBwcmVtaWVyIHJhc3RlciBlc3Qgc3Vww6lyaWV1ciBvdSDDqWdhbCBhdSBzZWNvbmQgcmFzdGVyLCBldCBsYSB2YWxldXIgMCBkYW5zIGxlIGNhcyBjb250cmFpcmUuXCIsXG5cdFx0Z3JlYXRlclRoYW5FcXVhbERlc2M6IFwiTGEgZm9uY3Rpb24gZWZmZWN0dWUgdW5lIG9ww6lyYXRpb24gcmVsYXRpb25uZWxsZSBTdXDDqXJpZXVyIG91IMOpZ2FsIMOgIHN1ciBkZXV4IGVudHLDqWVzLCBwaXhlbCBwYXIgcGl4ZWwuIEVsbGUgcmVudm9pZSB1bmUgdmFsZXVyIGRlIDEgcG91ciBsZXMgcGl4ZWxzIHBvdXIgbGVzcXVlbHMgbGUgcHJlbWllciByYXN0ZXIgZXN0IHN1cMOpcmlldXIgb3Ugw6lnYWwgYXUgc2Vjb25kIHJhc3RlciwgZXQgdW5lIHZhbGV1ciBkZSAwIHBvdXIgbGVzIHBpeGVscyBwb3VyIGxlc3F1ZWxzIGxlIHByZW1pZXIgcmFzdGVyIG7igJllc3QgcGFzIHN1cMOpcmlldXIgb3Ugw6lnYWwgYXUgc2Vjb25kIHJhc3Rlci5cIixcblx0XHRncmVhdGVyVGhhbk5hbWU6IFwiU3Vww6lyaWV1ciDDoFwiLFxuXHRcdGdyZWF0ZXJUaGFuU25pcDogXCJFZmZlY3R1ZSB1bmUgb3DDqXJhdGlvbiByZWxhdGlvbm5lbGxlIFN1cMOpcmlldXIgw6Agc3VyIGRldXggZW50csOpZXMsIGNlbGx1bGUgcGFyIGNlbGx1bGUuIFJlbnZvaWUgbGEgdmFsZXVyIDEgcG91ciBsZXMgY2VsbHVsZXMgcG91ciBsZXNxdWVsbGVzIGxlIHByZW1pZXIgcmFzdGVyIGVzdCBzdXDDqXJpZXVyIGF1IHNlY29uZCByYXN0ZXIsIGV0IGxhIHZhbGV1ciAwIGRhbnMgbGUgY2FzIGNvbnRyYWlyZS5cIixcblx0XHRncmVhdGVyVGhhbkRlc2M6IFwiTGEgZm9uY3Rpb24gZWZmZWN0dWUgdW5lIG9ww6lyYXRpb24gcmVsYXRpb25uZWxsZSBTdXDDqXJpZXVyIMOgIHN1ciBkZXV4IGVudHLDqWVzLCBwaXhlbCBwYXIgcGl4ZWwuIFJlbnZvaWUgdW5lIHZhbGV1ciBkZSAxIHBvdXIgbGVzIHBpeGVscyBwb3VyIGxlc3F1ZWxzIGxlIHByZW1pZXIgcmFzdGVyIGVzdCBzdXDDqXJpZXVyIGF1IHNlY29uZCByYXN0ZXIsIGV0IHVuZSB2YWxldXIgZGUgMCBwb3VyIGxlcyBwaXhlbHMgcG91ciBsZXNxdWVscyBsZSBwcmVtaWVyIHJhc3RlciBu4oCZZXN0IHBhcyBzdXDDqXJpZXVyIGF1IHNlY29uZCByYXN0ZXIuXCIsXG5cdFx0aGVhdEluZGV4TmFtZTogXCJJbmRpY2UgZGUgY2hhbGV1clwiLFxuXHRcdGhlYXRJbmRleFNuaXA6IFwiQ29tYmluZSBsYSB0ZW1ww6lyYXR1cmUgYW1iaWFudGUgZXQgbOKAmWh1bWlkaXTDqSByZWxhdGl2ZSBwb3VyIHJlbnZveWVyIGxhIHRlbXDDqXJhdHVyZSBhcHBhcmVudGUuXCIsXG5cdFx0aGVhdEluZGV4RGVzYzogXCJDZXR0ZSBmb25jdGlvbiBjYWxjdWxlIGxhIHRlbXDDqXJhdHVyZSBhcHBhcmVudGUgZOKAmWFwcsOocyBsYSB0ZW1ww6lyYXR1cmUgYW1iaWFudGUgZXQgbOKAmWh1bWlkaXTDqSByZWxhdGl2ZS4gTGEgdGVtcMOpcmF0dXJlIGFwcGFyZW50ZSBlc3Qgc291dmVudCBkw6ljcml0ZSBjb21tZSBsYSBjaGFsZXVyIHJlc3NlbnRpZSBwYXIgbGUgY29ycHMgaHVtYWluLjxkaXY+PGJyLz5DZXQgaW5kaWNlIHBldXQgw6p0cmUgdXRpbGUgcG91ciBwcsOpdm9pciBsZXMgcHJvYmzDqG1lcyBtw6lkaWNhdXgsIHRlbHMgcXVlIGxlcyBjcmFtcGVzIG11c2N1bGFpcmVzLCBsYSBkw6lzaHlkcmF0YXRpb24sIGxlcyBpbnNvbGF0aW9ucyBvdSBsZXMgY291cHMgZGUgY2hhbGV1ciBwbHVzIGdyYXZlcyBwYXIgdGVtcHMgY2hhdWQgZXQgaHVtaWRlLiBMb3JzcXVlIGzigJlodW1pZGl0w6kgcmVsYXRpdmUgZXN0IMOpbGV2w6llLCBsYSB0cmFuc3BpcmF0aW9uIGNvcnBvcmVsbGUgYSBkZSBwbHVzIGVuIHBsdXMgZGUgbWFsIMOgIHPigJnDqXZhcG9yZXIsIGNlIHF1aSBwcml2ZSBsZXMgcGVyc29ubmVzIGTigJl1biBtb2RlIGRlIHJhZnJhw65jaGlzc2VtZW50IG5hdHVyZWwuIExlcyBjYXJ0ZXMgZGVzIGF2ZXJ0aXNzZW1lbnRzIG91IGF2aXMgZGUgY2hhbGV1ciBwcm92aWVubmVudCBzb3V2ZW50IGRlIGxhIHJlY2xhc3NpZmljYXRpb24gZGUgbOKAmWluZGljZSBkZSBjaGFsZXVyIGVuIGNsYXNzZXMuIFBsdXMgbGEgdmFsZXVyIGRlIGzigJlpbmRpY2UgZXN0IMOpbGV2w6llIGV0IHBsdXMgaWwgZXN0IHByb2JhYmxlIHF14oCZdW4gYXZlcnRpc3NlbWVudCBzb2l0IHB1Ymxpw6kgYXUgbGlldSBk4oCZdW4gYXZpcy48L2Rpdj5cIixcblx0XHRoaWxsc2hhZGVOYW1lOiBcIk9tYnJhZ2VcIixcblx0XHRoaWxsc2hhZGVTbmlwOiBcIkNyw6llIHVuZSByZXByw6lzZW50YXRpb24gM0QgZGUgbGEgc3VyZmFjZSBxdWkgdGllbnQgY29tcHRlIGRlIGxhIHBvc2l0aW9uIHJlbGF0aXZlIGR1IHNvbGVpbCBwb3VyIGzigJlvbWJyYWdlIGRlIGzigJlpbWFnZS5cIixcblx0XHRoaWxsc2hhZGVEZXNjOiBcIkxhIGZvbmN0aW9uIE9tYnJhZ2UgZ8OpbsOocmUgdW5lIHJlcHLDqXNlbnRhdGlvbiAzRCBlbiBudWFuY2VzIGRlIGdyaXMgZGUgbGEgc3VyZmFjZSBkdSB0ZXJyYWluLCBhdmVjIHByaXNlIGVuIGNvbXB0ZSBkZSBsYSBwb3NpdGlvbiByZWxhdGl2ZSBkdSBzb2xlaWwgcG91ciBs4oCZb21icmFnZSBkZSBs4oCZaW1hZ2UuIDxkaXY+PGJyLz5M4oCZb21icmFnZSBlc3QgdW5lIHRlY2huaXF1ZSBkZSB2aXN1YWxpc2F0aW9uIGR1IE1OVCBkw6l0ZXJtaW7DqWUgcGFyIHVuZSBzb3VyY2UgZOKAmcOpY2xhaXJhZ2UsIGFpbnNpIHF1ZSBwYXIgbGEgcGVudGUgZXQgbOKAmWV4cG9zaXRpb24gZGUgbGEgc3VyZmFjZSBk4oCZw6lsw6l2YXRpb24uIElsIHPigJlhZ2l0IGTigJl1bmUgbcOpdGhvZGUgcXVhbGl0YXRpdmUgZGUgdmlzdWFsaXNhdGlvbiBkZSBsYSB0b3BvZ3JhcGhpZSBxdWkgbmUgZ8OpbsOocmUgcGFzIGRlIHZhbGV1cnMgZOKAmcOpbMOpdmF0aW9uIGFic29sdWVzLiA8L2Rpdj5cIixcblx0XHRpbnROYW1lOiBcIkVudGllclwiLFxuXHRcdGludFNuaXA6IFwiQ29udmVydGl0IGNoYXF1ZSB2YWxldXIgZGUgY2VsbHVsZSBk4oCZdW4gcmFzdGVyIGVuIG5vbWJyZSBlbnRpZXIsIHBhciB0cm9uY2F0aW9uLlwiLFxuXHRcdGludERlc2M6IFwiTGEgZm9uY3Rpb24gRW50aWVyIGNvbnZlcnRpdCBjaGFxdWUgdmFsZXVyIGRlIHBpeGVsIGTigJl1biByYXN0ZXIgZW4gbm9tYnJlIGVudGllciwgcGFyIHRyb25jYXRpb24uXCIsXG5cdFx0aW50ZXJwb2xhdGVJcnJlZ3VsYXJEYXRhTmFtZTogXCJJbnRlcnBvbGVyIGxlcyBkb25uw6llcyBpcnLDqWd1bGnDqHJlc1wiLFxuXHRcdGludGVycG9sYXRlSXJyZWd1bGFyRGF0YVNuaXA6IFwiSW50ZXJwb2xlIMOgIHBhcnRpciBkZSBudWFnZXMgZGUgcG9pbnRzIG91IGRlIGdyaWxsZXMgaXJyw6lndWxpw6hyZXMuXCIsXG5cdFx0aW50ZXJwb2xhdGVJcnJlZ3VsYXJEYXRhRGVzYzogXCJDZXJ0YWlucyBqZXV4IGRlIGRvbm7DqWVzIG5ldENERiBvdSBIREYgc3RvY2tlbnQgbGV1ciBnw6lvbG9jYWxpc2F0aW9uIHNvdXMgZm9ybWUgZGUgdGFibGVhdXggaXJyw6lndWxpw6hyZW1lbnQgZXNwYWPDqXMgZGUgcGl4ZWxzIG91IGRlIGRvbm7DqWVzIHBvbmN0dWVsbGVzLiBMb3JzIGRlIGzigJlham91dCBkZSBjZXMgamV1eCBkZSBkb25uw6llcyDDoCB1biBqZXUgZGUgZG9ubsOpZXMgbW9zYcOvcXVlLCBsYSBmb25jdGlvbiBJbnRlcnBvbGVyIGxlcyBkb25uw6llcyBpcnLDqWd1bGnDqHJlcyB1dGlsaXNlIGxlcyBkb25uw6llcyBxdWFkcmlsbMOpZXMgZGUgZmHDp29uIGlycsOpZ3VsacOocmUgZXQgbGVzIHLDqcOpY2hhbnRpbGxvbm5lIGFmaW4gcXVlIGNoYXF1ZSBwaXhlbCBzb2l0IGNhcnLDqSBldCBkZSB0YWlsbGUgdW5pZm9ybWUuPGRpdj48YnIvPkxvcnNxdWUgdm91cyBham91dGV6IGxlcyB2YXJpYWJsZXMgZOKAmXVuIGZpY2hpZXIgbmV0Q0RGIG91IEhERiDDoCB1biBqZXUgZGUgZG9ubsOpZXMgbW9zYcOvcXVlLCBsYSBmb25jdGlvbiB2w6lyaWZpZSBhdXRvbWF0aXF1ZW1lbnQgc2kgbGVzIGRvbm7DqWVzIHNvbnQgb3JnYW5pc8OpZXMgZGUgZmHDp29uIHLDqWd1bGnDqHJlLiBTaSBjZSBu4oCZZXN0IHBhcyBsZSBjYXMsIGxhIGZvbmN0aW9uIEludGVycG9sZXIgbGVzIGRvbm7DqWVzIGlycsOpZ3VsacOocmVzIHBldXQgc2VydmlyIMOgIGNvbnZlcnRpciBsZXMgZG9ubsOpZXMgaXJyw6lndWxpw6hyZXMgZW4gcmFzdGVyIHLDqWd1bGllci4gVm91cyBwb3V2ZXogY2hhbmdlciBsYSBtw6l0aG9kZSBk4oCZaW50ZXJwb2xhdGlvbiBldCBsYSB0YWlsbGUgZGUgY2VsbHVsZSB1dGlsaXPDqWVzIGRhbnMgbGEgZm9uY3Rpb24gcmFzdGVyIEludGVycG9sZXIgbGVzIGRvbm7DqWVzIGlycsOpZ3VsacOocmVzLiBQb3VyIGxlcyBkb25uw6llcyByYXN0ZXIgcsOpZ3VsacOocmVtZW50IGVzcGFjw6llcywgYXVjdW5lIGludGVycG9sYXRpb24gbuKAmWVzdCBhcHBsaXF1w6llIGV0IGxlcyBkb25uw6llcyBzb250IGx1ZXMgdGVsbGVzIHF1ZWxsZXMuPC9kaXY+XCIsXG5cdFx0aXNOdWxsTmFtZTogXCJFc3QgbnVsXCIsXG5cdFx0aXNOdWxsU25pcDogXCJEw6l0ZXJtaW5lIGxlcyB2YWxldXJzIGRlcyByYXN0ZXJzIGVuIGVudHLDqWUgcXVpIHNvbnQgTm9EYXRhLCBjZWxsdWxlIHBhciBjZWxsdWxlLiBSZW52b2llIGxhIHZhbGV1ciAxIHNpIGxlcyB2YWxldXJzIGVuIGVudHLDqWUgc29udCBOb0RhdGEsIGV0IGxhIHZhbGV1ciAwIHNpIGNlIG7igJllc3QgcGFzIGxlIGNhcy5cIixcblx0XHRpc051bGxEZXNjOiBcIkxhIGZvbmN0aW9uIEVzdCBudWwgZMOpdGVybWluZSBsZXMgdmFsZXVycyBkdSByYXN0ZXIgZW4gZW50csOpZSBxdWkgc29udCBOb0RhdGEsIHBpeGVsIHBhciBwaXhlbC4gRWxsZSByZW52b2llIHVuZSB2YWxldXIgZGUgMSBzaSBsYSB2YWxldXIgZW4gZW50csOpZSBlc3QgTm9EYXRhLCBldCB1bmUgdmFsZXVyIGRlIDAgcG91ciBsZXMgcGl4ZWxzIHF1aSBuZSBzb250IHBhcyBOb0RhdGEuXCIsXG5cdFx0a2VybmVsRGVuc2l0eU5hbWU6IFwiRGVuc2l0w6kgZGUgbm95YXVcIixcblx0XHRrZXJuZWxEZW5zaXR5U25pcDogXCJDYWxjdWxlIHVuZSBncmFuZGV1ciBwYXIgdW5pdMOpIGRlIGNhcnRlIMOgIHBhcnRpciBk4oCZZW50aXTDqXMgcG9uY3R1ZWxsZXMgb3UgcG9seWxpZ25lcyDDoCBs4oCZYWlkZSBk4oCZdW5lIGZvbmN0aW9uIGRlIG5veWF1IHBvdXIgYWp1c3RlciB1bmUgc3VyZmFjZSByw6lndWxpw6hyZW1lbnQgZWZmaWzDqWUgw6AgY2hhcXVlIHBvaW50IG91IHBvbHlsaWduZS5cIixcblx0XHRrZXJuZWxEZW5zaXR5RGVzYzogXCJDZXR0ZSBmb25jdGlvbiBjYWxjdWxlIHVuZSBncmFuZGV1ciBwYXIgdW5pdMOpIGRlIGNhcnRlIMOgIHBhcnRpciBk4oCZZW50aXTDqXMgcG9uY3R1ZWxsZXMgb3UgcG9seWxpZ25lcyDDoCBs4oCZYWlkZSBk4oCZdW5lIGZvbmN0aW9uIGRlIG5veWF1IHBvdXIgYWp1c3RlciB1bmUgc3VyZmFjZSByw6lndWxpw6hyZW1lbnQgZWZmaWzDqWUgw6AgY2hhcXVlIHBvaW50IG91IHBvbHlsaWduZS5cIixcblx0XHRrZXlNZXRhZGF0YU5hbWU6IFwiTcOpdGFkb25uw6llcyBjbMOpc1wiLFxuXHRcdGtleU1ldGFkYXRhU25pcDogXCJSZW1wbGFjZSBvdSBpbnPDqHJlIGxlcyBtw6l0YWRvbm7DqWVzIGNsw6lzIGTigJl1biByYXN0ZXIgZGFucyB1bmUgY2hhw65uZSBkZSBmb25jdGlvbnMuXCIsXG5cdFx0a2V5TWV0YWRhdGFEZXNjOiBcIkNldHRlIGZvbmN0aW9uIHZvdXMgcGVybWV0IGTigJlpbnPDqXJlciBvdSBkZSByZW1wbGFjZXIgbGVzIG3DqXRhZG9ubsOpZXMgY2zDqXMgZOKAmXVuIHJhc3Rlci48ZGl2Pjxici8+TGVzIGluZm9ybWF0aW9ucyBkYW5zIGxlcyBtw6l0YWRvbm7DqWVzIGNsw6lzIHBlcm1ldHRlbnQgZGUgc2ltcGxpZmllciBjZXJ0YWluZXMgdMOiY2hlcyBkZSB0cmFpdGVtZW50IGV0IGTigJlhZmZpY2hhZ2UgZGUgbOKAmWFwcGxpY2F0aW9uLCBub3RhbW1lbnQgZ3LDomNlIMOgIGNlcnRhaW5lcyBpbmZvcm1hdGlvbnMgdXRpbGVzIHRlbGxlcyBxdWUgbGUgbm9tIGR1IGNhcHRldXIsIGxlcyBub21zIGRlIGJhbmRlcyBvdSBsYSBjb3V2ZXJ0dXJlIG51YWdldXNlIGFzc29jacOpcyDDoCBs4oCZaW1hZ2UuPC9kaXY+XCIsXG5cdFx0c2hvcnRlc3RQYXRoTmFtZTogXCJDaGVtaW4gZGUgbW9pbmRyZSBjb8O7dFwiLFxuXHRcdHNob3J0ZXN0UGF0aFNuaXA6IFwiRWZmZWN0dWUgdW5lIGFuYWx5c2UgZGUgZGlzdGFuY2UgZGUgY2/Du3Qgw6AgbOKAmWFpZGUgZOKAmXVuZSBzb3VyY2UgZXQgZOKAmXVuZSBkZXN0aW5hdGlvbiBlbiBlbnRyw6llLiBDZXR0ZSBhbmFseXNlIGVzdCBlbnN1aXRlIHV0aWxpc8OpZSBwb3VyIGTDqXRlcm1pbmVyIGxlIGNoZW1pbiBkZSBtb2luZHJlIGNvw7t0IGVudHJlIHVuZSBzb3VyY2UgZXQgdW5lIGRlc3RpbmF0aW9uLlwiLFxuXHRcdHNob3J0ZXN0UGF0aERlc2M6IFwiTGEgZm9uY3Rpb24gQ2hlbWluIGRlIG1vaW5kcmUgY2/Du3QgY2FsY3VsZSBsZSBjaGVtaW4gZGUgbW9pbmRyZSBjb8O7dCBlbnRyZSB1bmUgc291cmNlIGV0IHVuZSBkZXN0aW5hdGlvbi4gUG91ciBjaGFxdWUgcGl4ZWwsIGxhIGRpc3RhbmNlIGRlIG1vaW5kcmUgY2/Du3QgY3VtdWzDqSBlc3QgY2FsY3Vsw6llIHZlcnMgbGEgc291cmNlIGxhIHBsdXMgcHJvY2hlIHN1ciB1bmUgc3VyZmFjZSBkZSBjb8O7dC4gQ2VjaSBwZXJtZXQgZOKAmW9idGVuaXIgdW4gcmFzdGVyIGVuIHNvcnRpZSBxdWkgZW5yZWdpc3RyZSBsZSBvdSBsZXMgY2hlbWlucyBkZSBtb2luZHJlIGNvw7t0IMOgIHBhcnRpciBkZXMgZW1wbGFjZW1lbnRzIHPDqWxlY3Rpb25uw6lzIHZlcnMgbGVzIHBpeGVscyBzb3VyY2VzIGxlcyBwbHVzIHByb2NoZXMgdGVscyBxdWUgZMOpZmluaXMgZGFucyBsYSBzdXJmYWNlIGRlIGNvw7t0IGN1bXVsw6kgKGVuIHRlbmFudCBjb21wdGUgZGVzIGRpc3RhbmNlcyBkZSBjb8O7dCkuPGRpdj48YnIvPkNoYXF1ZSBjaGVtaW4gZGUgbW9pbmRyZSBjb8O7dCBzZSB2b2l0IGF0dHJpYnVlciB1bmUgdmFsZXVyIGlzc3VlIGR1IHByb2Nlc3N1cyBkZSBudW3DqXJpc2F0aW9uLiBMZSBwaXhlbCBkZSBmaW4gZGFucyBsZSByYXN0ZXIgc291cmNlIGTigJl1biBjaGVtaW4gZGUgY2/Du3QgcmXDp29pdCBsYSB2YWxldXIgMS4gTGUgcHJlbWllciBjaGVtaW4gcmXDp29pdCBsYSB2YWxldXIgMywgbGUgZGV1eGnDqG1lIGNoZW1pbiBsYSB2YWxldXIgNCwgZXQgYWluc2kgZGUgc3VpdGUuIExvcnNxdWUgcGx1c2lldXJzIGNoZW1pbnMgc2UgcmVqb2lnbmVudCBldCBwb3Vyc3VpdmVudCBzdXIgbGEgZGlzdGFuY2UgcmVzdGFudGUgZW4gcmV2ZW5hbnQgdmVycyB1bmUgc291cmNlIHN1ciBsZSBtw6ptZSB0cmFqZXQsIGxlIHNlZ21lbnQgc3VyIGxlcXVlbCBsZXMgZGV1eCBjaGVtaW5zIHNvbnQgY29tYmluw6lzIHNlIHZvaXQgYXR0cmlidWVyIGxhIHZhbGV1ciAyLiBWb3VzIG5lIHBvdXZleiBwYXMgYXR0cmlidWVyIGxhIHBhcnRpZSBjb21iaW7DqWUgZHUgY2hlbWluIMOgIGxhIHZhbGV1ciBkZSBs4oCZdW4gZGVzIGNoZW1pbnMsIGNhciBsYSBwYXJ0aWUgY29tYmluw6llIGTDqXBlbmQgZGVzIGRldXggaXRpbsOpcmFpcmVzLjwvZGl2PlwiLFxuXHRcdGxlc3NUaGFuRXF1YWxOYW1lOiBcIkluZsOpcmlldXIgb3Ugw6lnYWwgw6BcIixcblx0XHRsZXNzVGhhbkVxdWFsU25pcDogXCJFZmZlY3R1ZSB1bmUgb3DDqXJhdGlvbiByZWxhdGlvbm5lbGxlIEluZsOpcmlldXIgb3Ugw6lnYWwgw6Agc3VyIGRldXggZW50csOpZXMsIGNlbGx1bGUgcGFyIGNlbGx1bGUuIFJlbnZvaWUgbGEgdmFsZXVyIDEgcG91ciBsZXMgY2VsbHVsZXMgcG91ciBsZXNxdWVsbGVzIGxlIHByZW1pZXIgcmFzdGVyIGVzdCBpbmbDqXJpZXVyIG91IMOpZ2FsIGF1IHNlY29uZCByYXN0ZXIsIGV0IGxhIHZhbGV1ciAwIGRhbnMgbGUgY2FzIGNvbnRyYWlyZS5cIixcblx0XHRsZXNzVGhhbkVxdWFsRGVzYzogXCJMYSBmb25jdGlvbiBlZmZlY3R1ZSB1bmUgb3DDqXJhdGlvbiByZWxhdGlvbm5lbGxlIEluZsOpcmlldXIgb3Ugw6lnYWwgw6Agc3VyIGRldXggZW50csOpZXMsIHBpeGVsIHBhciBwaXhlbC4gRWxsZSByZW52b2llIHVuZSB2YWxldXIgZGUgMSBwb3VyIGxlcyBwaXhlbHMgcG91ciBsZXNxdWVscyBsZSBwcmVtaWVyIHJhc3RlciBlc3QgaW5mw6lyaWV1ciBvdSDDqWdhbCBhdSBzZWNvbmQgcmFzdGVyLCBldCB1bmUgdmFsZXVyIGRlIDAgc2kgbGUgcHJlbWllciByYXN0ZXIgbuKAmWVzdCBwYXMgaW5mw6lyaWV1ciBvdSDDqWdhbCBhdSBzZWNvbmQgcmFzdGVyLlwiLFxuXHRcdGxlc3NUaGFuTmFtZTogXCJJbmbDqXJpZXVyIMOgXCIsXG5cdFx0bGVzc1RoYW5TbmlwOiBcIkVmZmVjdHVlIHVuZSBvcMOpcmF0aW9uIHJlbGF0aW9ubmVsbGUgSW5mw6lyaWV1ciDDoCBzdXIgZGV1eCBlbnRyw6llcywgY2VsbHVsZSBwYXIgY2VsbHVsZS4gUmVudm9pZSAxIHBvdXIgbGVzIGNlbGx1bGVzIHBvdXIgbGVzcXVlbGxlcyBsZSBwcmVtaWVyIHJhc3RlciBlc3QgaW5mw6lyaWV1ciBhdSBkZXV4acOobWUgcmFzdGVyLCBldCAwIGRhbnMgbGUgY2FzIGNvbnRyYWlyZS5cIixcblx0XHRsZXNzVGhhbkRlc2M6IFwiTGEgZm9uY3Rpb24gZWZmZWN0dWUgdW5lIG9ww6lyYXRpb24gcmVsYXRpb25uZWxsZSBJbmbDqXJpZXVyIMOgIHN1ciBkZXV4IGVudHLDqWVzLCBwaXhlbCBwYXIgcGl4ZWwuIEVsbGUgcmVudm9pZSB1bmUgdmFsZXVyIGRlIDEgcG91ciBsZXMgcGl4ZWxzIHBvdXIgbGVzcXVlbHMgbGUgcHJlbWllciByYXN0ZXIgZXN0IGluZsOpcmlldXIgYXUgZGV1eGnDqG1lLCBldCB1bmUgdmFsZXVyIGRlIDAgc+KAmWlsIG7igJllc3QgcGFzIGluZsOpcmlldXIgYXUgZGV1eGnDqG1lLlwiLFxuXHRcdGxuTmFtZTogXCJMblwiLFxuXHRcdGxuU25pcDogXCJDYWxjdWxlIGxlIGxvZ2FyaXRobWUgbmF0dXJlbCAoYmFzZSBlKSBkZXMgY2VsbHVsZXMgZCd1biByYXN0ZXIuXCIsXG5cdFx0bG5EZXNjOiBcIkxhIGZvbmN0aW9uIExuIGNhbGN1bGUgbGUgbG9nYXJpdGhtZSBuYXR1cmVsIChiYXNlIGUpIGRlIGNoYXF1ZSBwaXhlbCBkYW5zIHVuIHJhc3Rlci5cIixcblx0XHRsb2cxME5hbWU6IFwiTG9nMTBcIixcblx0XHRsb2cxMFNuaXA6IFwiQ2FsY3VsZSBsZSBsb2dhcml0aG1lIGJhc2UgMTAgZGVzIGNlbGx1bGVzIGQndW4gcmFzdGVyLlwiLFxuXHRcdGxvZzEwRGVzYzogXCJMYSBmb25jdGlvbiBMb2cxMCBjYWxjdWxlIGxlIGxvZ2FyaXRobWUgZGUgYmFzZSAxMCBkZSBjaGFxdWUgcGl4ZWwgZGFucyB1biByYXN0ZXIuXCIsXG5cdFx0bG9nMk5hbWU6IFwiTG9nMlwiLFxuXHRcdGxvZzJTbmlwOiBcIkNhbGN1bGUgbGUgbG9nYXJpdGhtZSBiYXNlIDIgZGVzIGNlbGx1bGVzIGQndW4gcmFzdGVyLlwiLFxuXHRcdGxvZzJEZXNjOiBcIkxhIGZvbmN0aW9uIExvZzIgY2FsY3VsZSBsZSBsb2dhcml0aG1lIGRlIGJhc2UgMiBkZSBjaGFxdWUgcGl4ZWwgZGFucyB1biByYXN0ZXIuXCIsXG5cdFx0bG9va3VwTmFtZTogXCJDb3JyZXNwb25kYW5jZVwiLFxuXHRcdGxvb2t1cFNuaXA6IFwiQ3LDqWUgdW4gbm91dmVhdSByYXN0ZXIgcGFyIGNvcnJlc3BvbmRhbmNlIGRlcyB2YWxldXJzIHRyb3V2w6llcyBkYW5zIHVuIGF1dHJlIGNoYW1wIGRlIGxhIHRhYmxlIGR1IHJhc3RlciBlbiBlbnRyw6llLlwiLFxuXHRcdGxvb2t1cERlc2M6IFwiTGEgZm9uY3Rpb24gY3LDqWUgdW4gbm91dmVhdSByYXN0ZXIgcGFyIGNvcnJlc3BvbmRhbmNlIGRlcyB2YWxldXJzIHRyb3V2w6llcyBkYW5zIHVuIGF1dHJlIGNoYW1wIGRlIGxhIHRhYmxlIGR1IHJhc3RlciBlbiBlbnRyw6llLlwiLFxuXHRcdG1sQ2xhc3NpZnlOYW1lOiBcIkNsYXNzaWZpY2F0aW9uIE1MXCIsXG5cdFx0bWxDbGFzc2lmeVNuaXA6IFwiQ2xhc3NlIGzigJlpbWFnZXJpZSBwaXhlbCBwYXIgcGl4ZWwuIExlcyBwaXhlbHMgbcOpbGFuZ8OpcyBzb250IGF0dHJpYnXDqXMgw6AgbOKAmWVudGl0w6kgcG9zc8OpZGFudCBsZSBwb3VyY2VudGFnZSBsZSBwbHVzIMOpbGV2w6kgZGFucyBjZSBwaXhlbC5cIixcblx0XHRtbENsYXNzaWZ5RGVzYzogXCJMYSBmb25jdGlvbiBkZSBjbGFzc2lmaWNhdGlvbiBNTCB2b3VzIHBlcm1ldCBkJ2VmZmVjdHVlciB1bmUgY2xhc3NpZmljYXRpb24gc3VwZXJ2aXPDqWUsIMOgIGwnYWlkZSBkJ3VuIGFsZ29yaXRobWUgZGUgY2xhc3NpZmljYXRpb24gZGUgdnJhaXNlbWJsYW5jZSBtYXhpbWFsZSwgc3VyIHVuIGpldSBkZSBkb25uw6llcyByYXN0ZXIgb3UgdW5lIG1vc2HDr3F1ZS4gQ2V0dGUgZm9uY3Rpb24gbsOpY2Vzc2l0ZSB1biBmaWNoaWVyIGRlIHNpZ25hdHVyZXMgZGUgY2xhc3NpZmljYXRpb24uXCIsXG5cdFx0bWFza05hbWU6IFwiTWFzcXVlXCIsXG5cdFx0bWFza1NuaXA6IFwiRMOpZmluaXQgbGVzIHZhbGV1cnMgcXVlIHZvdXMgbmUgc291aGFpdGV6IHBhcyBhZmZpY2hlci5cIixcblx0XHRtYXNrRGVzYzogXCJDZXR0ZSBmb25jdGlvbiByYXN0ZXIgZMOpZmluaXQgbGVzIHZhbGV1cnMgcXVlIHZvdXMgbmUgc291aGFpdGV6IHBhcyBhZmZpY2hlciBkYW5zIHZvdHJlIHJhc3Rlci4gTGEgZm9uY3Rpb24gTWFzcXVlIHBlcm1ldCBkZSBzcMOpY2lmaWVyIHVuZSBvdSBwbHVzaWV1cnMgdmFsZXVycyBOb0RhdGEgb3UgdW5lIHBsYWdlIGRlIHZhbGV1cnMgZGUgcGl4ZWxzIHZhbGlkZXMuIFwiLFxuXHRcdG1pbnVzTmFtZTogXCJTb3VzdHJhY3Rpb25cIixcblx0XHRtaW51c1NuaXA6IFwiU291c3RyYWllIGxhIHZhbGV1ciBkdSBkZXV4acOobWUgcmFzdGVyIGVuIGVudHLDqWUgZGUgbGEgdmFsZXVyIGR1IHByZW1pZXIgcmFzdGVyIGVuIGVudHLDqWUsIGNlbGx1bGUgcGFyIGNlbGx1bGUuXCIsXG5cdFx0bWludXNEZXNjOiBcIkxhIHZhbGV1ciBTb3VzdHJhY3Rpb24gc291c3RyYWllIGxhIHZhbGV1ciBkdSBkZXV4acOobWUgcmFzdGVyIGVuIGVudHLDqWUgZGUgbGEgdmFsZXVyIGR1IHByZW1pZXIgcmFzdGVyIGVuIGVudHLDqWUsIHBpeGVsIHBhciBwaXhlbC5cIixcblx0XHRtb2ROYW1lOiBcIk1vZFwiLFxuXHRcdG1vZFNuaXA6IFwiRMOpdGVybWluZSBsZSByZXN0ZSAobW9kdWxvKSBkdSBwcmVtaWVyIHJhc3RlciBhcHLDqHMgZGl2aXNpb24gcGFyIGxlIGRldXhpw6htZSByYXN0ZXIsIGNlbGx1bGUgcGFyIGNlbGx1bGUuXCIsXG5cdFx0bW9kRGVzYzogXCJMYSBmb25jdGlvbiBNb2QgZMOpdGVybWluZSBsZSByZXN0ZSAobW9kdWxvKSBkdSBwcmVtaWVyIHJhc3RlciBhcHLDqHMgZGl2aXNpb24gcGFyIGxlIGRldXhpw6htZSByYXN0ZXIsIHBpeGVsIHBhciBwaXhlbC4gTOKAmW9yZHJlIGRlcyBlbnRyw6llcyBlc3QgaW1wb3J0YW50IGV0IGFmZmVjdGUgbGUgcsOpc3VsdGF0IGVuIHNvcnRpZS5cIixcblx0XHRtb3NhaWNSYXN0ZXJzTmFtZTogXCJNb3Nhw69xdWFnZSBkZSByYXN0ZXJzXCIsXG5cdFx0bW9zYWljUmFzdGVyc1NuaXA6IFwiQXNzZW1ibGUgdW4gamV1IGRlIGRvbm7DqWVzIHJhc3RlciBhZmluIGRlIGNyw6llciB1biBzZXVsIGpldSBkZSBkb25uw6llcy5cIixcblx0XHRtb3NhaWNSYXN0ZXJzRGVzYzogXCJMYSBmb25jdGlvbiBNb3Nhw69xdWFnZSBkZSByYXN0ZXJzIGNyw6llIHVuZSBpbWFnZSBkZSBtb3Nhw69xdWUgw6AgcGFydGlyIGRlIHBsdXNpZXVycyBpbWFnZXMuIExvcnNxdWUgbGVzIGltYWdlcyBzZSBzdXBlcnBvc2VudCwgcGx1c2lldXJzIG3DqXRob2RlcyBwZXJtZXR0ZW50IGRlIGTDqXRlcm1pbmVyIGxlcyBpbWFnZXMgw6AgYWZmaWNoZXIuXCIsXG5cdFx0bmR2aUNvbG9yaXplZE5hbWU6IFwiTkRWSSBjb2xvcmlzw6lcIixcblx0XHRuZHZpQ29sb3JpemVkU25pcDogXCJDcsOpZSB1biBqZXUgZGUgZG9ubsOpZXMgbW9ub2NhbCByZXByw6lzZW50YW50IGwnw6l0YXQgc2FuaXRhaXJlIGRlIGxhIHbDqWfDqXRhdGlvbiBlbiBzJ2FwcHV5YW50IHN1ciBsYSBkaWZmw6lyZW5jZSBlbnRyZSBsZXMgY2FuYXV4IHJvdWdlIGV0IHByb2NoZSBpbmZyYXJvdWdlLlwiLFxuXHRcdG5kdmlDb2xvcml6ZWREZXNjOiBcIkxhIGZvbmN0aW9uIE5EVkkgY29sb3Jpc8OpIGFwcGxpcXVlIGxhIGZvbmN0aW9uIE5EVkkgw6AgbOKAmWltYWdlIGVuIGVudHLDqWUsIHB1aXMgdXRpbGlzZSB1bmUgcGFsZXR0ZSBkZSBjb3VsZXVycyBvdSB1biBkw6lncmFkw6kgZGUgY291bGV1cnMgcG91ciBhZmZpY2hlciBsZSByw6lzdWx0YXQuXCIsXG5cdFx0bmR2aU5hbWU6IFwiTkRWSVwiLFxuXHRcdG5kdmlTbmlwOiBcIkNhbGN1bGUgbOKAmWluZGljZSBkZSB2w6lnw6l0YXRpb24gcGFyIGRpZmbDqXJlbmNlIG5vcm1hbGlzw6llIChORFZJKS5cIixcblx0XHRuZHZpRGVzYzogXCJMYSBmb25jdGlvbiBORFZJIGNyw6llIHVuIGpldSBkZSBkb25uw6llcyBtb25vY2FsIHJlcHLDqXNlbnRhbnQgbOKAmcOpdGF0IHNhbml0YWlyZSBkZSBsYSB2w6lnw6l0YXRpb24gZW4gc+KAmWFwcHV5YW50IHN1ciBsYSBkaWZmw6lyZW5jZSBlbnRyZSBsZXMgY2FuYXV4IHJvdWdlIGV0IHByb2NoZSBpbmZyYXJvdWdlLjxkaXY+PGJyLz5ORFZJIGVzdCB1biBpbmRpY2Ugbm9ybWFsaXPDqSBxdWkgdm91cyBwZXJtZXQgZGUgZ8OpbsOpcmVyIHVuZSBpbWFnZSBpbGx1c3RyYW50IGxhIGNvdXZlcnR1cmUgdsOpZ8OpdGFsZSwgw6lnYWxlbWVudCBjb25udWUgc291cyBsZSBub20gZGUgYmlvbWFzc2UgcmVsYXRpdmUuIENldCBpbmRpY2UgdGlyZSBwYXJ0aSBkdSBjb250cmFzdGUgZGVzIGNhcmFjdMOpcmlzdGlxdWVzIGRlIGRldXggY2FuYXV4IGTigJl1biBqZXUgZGUgZG9ubsOpZXMgcmFzdGVyIG11bHRpc3BlY3RyYWwgOiBs4oCZYWJzb3JwdGlvbiBkZSBwaWdtZW50cyBjaGxvcm9waHlsbGllbnMgZGFucyBsZSBjYW5hbCByb3VnZSBldCBsYSByw6lmbGVjdGl2aXTDqSDDqWxldsOpZSBkZXMgbWF0acOocmVzIHbDqWfDqXRhbGVzIGRhbnMgbGUgY2FuYWwgcHJvY2hlIGluZnJhcm91Z2UgKE5JUikuIExlcyB2YWxldXJzIE5EVkkgbsOpZ2F0aXZlcyBvdSBleHRyw6ptZW1lbnQgZmFpYmxlcyByZXByw6lzZW50ZW50IGRlcyB6b25lcyBkw6lwb3VydnVlcyBkZSB2w6lnw6l0YXRpb24sIHRlbGxlcyBxdWUgbGVzIG51YWdlcywgbOKAmWVhdSBvdSBsYSBuZWlnZS4gTGVzIHZhbGV1cnMgdHLDqHMgZmFpYmxlcyByZXByw6lzZW50ZW50IGRlcyB6b25lcyBzYW5zIG91IGF2ZWMgcGV1IGRlIHbDqWfDqXRhdGlvbiwgY29tbWUgbGUgYsOpdG9uLCBsZXMgcm9jaGVycyBvdSBsZSBzb2wgbnUuIExlcyB2YWxldXJzIG1vZMOpcsOpZXMgcmVwcsOpc2VudGVudCBkZXMgem9uZXMgY29tcG9ydGFudCBkZXMgYXJidXN0ZXMgZXQgZGVzIHDDonR1cmFnZXMuIExlcyB2YWxldXJzIMOpbGV2w6llcyByZXByw6lzZW50ZW50IGRlcyB6b25lcyBkZSBmb3LDqnQgZXQgdW5lIHbDqWfDqXRhdGlvbiBsdXh1cmlhbnRlLjwvZGl2PlwiLFxuXHRcdG5lZ2F0ZU5hbWU6IFwiT3Bwb3PDqVwiLFxuXHRcdG5lZ2F0ZVNuaXA6IFwiQ2hhbmdlIGxlIHNpZ25lIChtdWx0aXBsaWUgcGFyIC0xKSBkZXMgdmFsZXVycyBkZSBjZWxsdWxlcyBkdSByYXN0ZXIgZW4gZW50csOpZSwgY2VsbHVsZSBwYXIgY2VsbHVsZS5cIixcblx0XHRuZWdhdGVEZXNjOiBcIkxhIGZvbmN0aW9uIE9wcG9zw6kgY2hhbmdlIGxlIHNpZ25lIChtdWx0aXBsaWUgcGFyIC0xKSBkZXMgdmFsZXVycyBkZSBwaXhlbHMgZHUgcmFzdGVyIGVuIGVudHLDqWUsIHBpeGVsIHBhciBwaXhlbC4gXCIsXG5cdFx0bmliYmxlTmFtZTogXCJHcmlnbm90YWdlXCIsXG5cdFx0bmliYmxlU25pcDogXCJSZW1wbGFjZSBsZXMgY2VsbHVsZXMgZOKAmXVuIHJhc3RlciBjb3JyZXNwb25kYW50IMOgIHVuIG1hc3F1ZSBwYXIgbGVzIHZhbGV1cnMgZGVzIHZvaXNpbnMgbGVzIHBsdXMgcHJvY2hlcy5cIixcblx0XHRuaWJibGVEZXNjOiBcIkxhIGZvbmN0aW9uIGdsb2JhbGUgR3JpZ25vdGFnZSBwZXJtZXQgYXV4IHpvbmVzIHPDqWxlY3Rpb25uw6llcyBk4oCZdW4gcmFzdGVyIGRlIHNlIHZvaXIgYXR0cmlidWVyIGxhIHZhbGV1ciBkdSB2b2lzaW4gbGUgcGx1cyBwcm9jaGUuIENlbGEgZXN0IHV0aWxlIHBvdXIgbWV0dHJlIMOgIGpvdXIgbGVzIHpvbmVzIGTigJl1biByYXN0ZXIgcG91ciBsZXF1ZWwgbGVzIGRvbm7DqWVzIHBldXZlbnQgw6p0cmUgZXJyb27DqWVzLlwiLFxuXHRcdG5vdEVxdWFsTmFtZTogXCJEaWZmw6lyZW50IGRlXCIsXG5cdFx0bm90RXF1YWxTbmlwOiBcIkVmZmVjdHVlIHVuZSBvcMOpcmF0aW9uIHJlbGF0aW9ubmVsbGUgRGlmZsOpcmVudCBkZSBzdXIgZGV1eCBlbnRyw6llcywgY2VsbHVsZSBwYXIgY2VsbHVsZS4gUmVudm9pZSAxIHBvdXIgbGVzIGNlbGx1bGVzIHBvdXIgbGVzcXVlbGxlcyBsZSBwcmVtaWVyIHJhc3RlciBuJ2VzdCBwYXMgw6lnYWwgYXUgZGV1eGnDqG1lIHJhc3RlciBldCAwIGRhbnMgbGUgY2FzIGNvbnRyYWlyZS5cIixcblx0XHRub3RFcXVhbERlc2M6IFwiTGEgZm9uY3Rpb24gZWZmZWN0dWUgdW5lIG9ww6lyYXRpb24gcmVsYXRpb25uZWxsZSBEaWZmw6lyZW50IGRlIHN1ciBkZXV4IGVudHLDqWVzLCBwaXhlbCBwYXIgcGl4ZWwuIEVsbGUgcmVudm9pZSB1bmUgdmFsZXVyIGRlIDEgcG91ciBsZXMgcGl4ZWxzIHBvdXIgbGVzcXVlbHMgbGUgcHJlbWllciByYXN0ZXIgbuKAmWVzdCBwYXMgw6lnYWwgYXUgZGV1eGnDqG1lLCBldCB1bmUgdmFsZXVyIGRlIDAgcG91ciBsZXMgcGl4ZWxzIHBvdXIgbGVzcXVlbHMgaWwgZXN0IMOpZ2FsIGF1IGRldXhpw6htZS5cIixcblx0XHRwYW5zaGFycGVuaW5nTmFtZTogXCJBZmZpbmFnZSBwYW5jaHJvbWF0aXF1ZVwiLFxuXHRcdHBhbnNoYXJwZW5pbmdTbmlwOiBcIkFtw6lsaW9yZSBhcnRpZmljaWVsbGVtZW50IGxhIHLDqXNvbHV0aW9uIHNwYXRpYWxlIGTigJl1bmUgaW1hZ2UgbXVsdGljYW5hbCBlbiBsYSBmdXNpb25uYW50IGF2ZWMgdW5lIGltYWdlIHBhbmNocm9tYXRpcXVlIGhhdXRlIHLDqXNvbHV0aW9uLlwiLFxuXHRcdHBhbnNoYXJwZW5pbmdEZXNjOiBcIkxhIGZvbmN0aW9uIEFmZmluYWdlIHBhbmNocm9tYXRpcXVlIHBlcm1ldCBkZSBmdXNpb25uZXIgdW5lIGltYWdlIHBhbmNocm9tYXRpcXVlIChvdSBjYW5hbCByYXN0ZXIpIGRlIHLDqXNvbHV0aW9uIHN1cMOpcmlldXJlIGF2ZWMgdW4gamV1IGRlIGRvbm7DqWVzIHJhc3RlciBtdWx0aWNhbmFsIGRlIHLDqXNvbHV0aW9uIGluZsOpcmlldXJlIGFmaW4gZOKAmW9wdGltaXNlciBsYSByw6lzb2x1dGlvbiBzcGF0aWFsZSBkZSBs4oCZaW1hZ2UgbXVsdGljYW5hbC48ZGl2Pjxici8+TOKAmW9iamVjdGlmIGRlIGzigJlhbcOpbGlvcmF0aW9uIGRlIGxhIG5ldHRldMOpIHBhbmNocm9tYXRpcXVlIGVzdCBkZSBnw6luw6lyZXIgdW5lIGltYWdlIGTigJl1bmUgcXVhbGl0w6kgdmlzdWVsbGUgc3Vww6lyaWV1cmUuIENvbW1lIGxlcyB0ZWNobmlxdWVzIHV0aWxpc8OpZXMgbW9kaWZpZW50IGxhIHJhZGlvbcOpdHJpZSBldCBsZXMgY2FyYWN0w6lyaXN0aXF1ZXMgc3BlY3RyYWxlcyBkZSBs4oCZaW1hZ2VyaWUgbXVsdGljYW5hbCwgaWwgZXN0IHJlY29tbWFuZMOpIGTigJl1dGlsaXNlciBjZXMgaW1hZ2VzIGFtw6lsaW9yw6llcyBhdmVjIHBydWRlbmNlIGRhbnMgbGVzIGFuYWx5c2VzIGRlIHTDqWzDqWTDqXRlY3Rpb24uPC9kaXY+XCIsXG5cdFx0cGF0aEFsbG9jYXRpb25OYW1lOiBcIkFsbG9jYXRpb24gZGUgZGlzdGFuY2UgZGUgY2hlbWluXCIsXG5cdFx0cGF0aEFsbG9jYXRpb25TbmlwOiBcIkNhbGN1bGUgbGEgc291cmNlIGRlIG1vaW5kcmUgY2/Du3QgcG91ciBjaGFxdWUgY2VsbHVsZSwgZW4gZm9uY3Rpb24gZHUgY2/Du3QgY3VtdWzDqSBsZSBtb2lucyBpbXBvcnRhbnQgc3VyIHVuZSBzdXJmYWNlIGRlIGNvw7t0LCB0b3V0IGVuIHRlbmFudCBjb21wdGUgZGUgbGEgZGlzdGFuY2UgZGUgc3VyZmFjZSBldCBkZXMgZmFjdGV1cnMgZGUgY2/Du3QgaG9yaXpvbnRhdXggZXQgdmVydGljYXV4LlwiLFxuXHRcdHBhdGhBbGxvY2F0aW9uRGVzYzogXCJMYSBmb25jdGlvbiBBbGxvY2F0aW9uIGRlIGRpc3RhbmNlIGRlIGNoZW1pbiBjYWxjdWxlIHBvdXIgY2hhcXVlIGNlbGx1bGUgbGEgc291cmNlIGxhIHBsdXMgcHJvY2hlIGVuIGZvbmN0aW9uIGR1IHBsdXMgZmFpYmxlIGNvw7t0IGN1bXVsw6kgc3VyIHVuZSBzdXJmYWNlIGRlIGNvw7t0LCB0b3V0IGVuIHRlbmFudCBjb21wdGUgbGEgZGlzdGFuY2Ugw6AgbGEgc3VyZmFjZSBldCBsZXMgZmFjdGV1cnMgZGUgY2/Du3QgaG9yaXpvbnRhdXggZXQgdmVydGljYXV4LlwiLFxuXHRcdHBhdGhCYWNrTGlua05hbWU6IFwiQW50w6ljw6lkZW5jZSBkZSBkaXN0YW5jZSBkZSBjaGVtaW5cIixcblx0XHRwYXRoQmFja0xpbmtTbmlwOiBcIkTDqWZpbml0IGxlIHZvaXNpbiBxdWkgZXN0IGxhIGNlbGx1bGUgc3VpdmFudGUgc3VyIGxlIGNoZW1pbiBkZSBwbHVzIGZhaWJsZSBjb8O7dCBjdW11bMOpIG1lbmFudCDDoCBsYSBzb3VyY2UgZGUgbW9pbmRyZSBjb8O7dCwgdG91dCBlbiB0ZW5hbnQgY29tcHRlIGRlIGxhIGRpc3RhbmNlIGRlIHN1cmZhY2UgZXQgZGVzIGZhY3RldXJzIGRlIGNvw7t0IGhvcml6b250YXV4IGV0IHZlcnRpY2F1eC5cIixcblx0XHRwYXRoQmFja0xpbmtEZXNjOiBcIkxhIGZvbmN0aW9uIEFudMOpY8OpZGVuY2UgZGUgZGlzdGFuY2UgZGUgY2hlbWluIGlkZW50aWZpZSBsYSBkaXJlY3Rpb24gZHUgdm9pc2luIHF1aSBlc3QgbGEgY2VsbHVsZSBzdWl2YW50ZSBzdXIgbGUgY2hlbWluIGRlIHBsdXMgZmFpYmxlIGNvw7t0IGN1bXVsw6kgbWVuYW50IMOgIGxhIHNvdXJjZSBsYSBwbHVzIHByb2NoZSwgdG91dCBlbiB0ZW5hbnQgY29tcHRlIGRlIGxhIGRpc3RhbmNlIGRlIHN1cmZhY2UgZXQgZGVzIGZhY3RldXJzIGRlIGNvw7t0IGhvcml6b250YXV4IGV0IHZlcnRpY2F1eC5cIixcblx0XHRwYXRoRGlzdGFuY2VOYW1lOiBcIkRpc3RhbmNlIGRlIGNoZW1pblwiLFxuXHRcdHBhdGhEaXN0YW5jZVNuaXA6IFwiQ2FsY3VsZSwgcG91ciBjaGFxdWUgY2VsbHVsZSwgbGEgZGlzdGFuY2UgZGUgcGx1cyBmYWlibGUgY2/Du3QgY3VtdWzDqSBkZXB1aXMgb3UgdmVycyBsYSBzb3VyY2UgZGUgbW9pbmRyZSBjb8O7dCwgdG91dCBlbiB0ZW5hbnQgY29tcHRlIGRlIGxhIGRpc3RhbmNlIGRlIHN1cmZhY2UgZXQgZGVzIGZhY3RldXJzIGRlIGNvw7t0IGhvcml6b250YXV4IGV0IHZlcnRpY2F1eC5cIixcblx0XHRwYXRoRGlzdGFuY2VEZXNjOiBcIkxhIGZvbmN0aW9uIERpc3RhbmNlIGRlIGNoZW1pbiBjYWxjdWxlLCBwb3VyIGNoYXF1ZSBjZWxsdWxlLCBsYSBkaXN0YW5jZSBkZSBwbHVzIGZhaWJsZSBjb8O7dCBjdW11bMOpIGp1c3F14oCZw6AgbGEgc291cmNlIGxhIHBsdXMgcHJvY2hlLCB0b3V0IGVuIHRlbmFudCBjb21wdGUgZGUgbGEgZGlzdGFuY2UgZGUgc3VyZmFjZSBldCBkZXMgZmFjdGV1cnMgZGUgY2/Du3QgaG9yaXpvbnRhdXggZXQgdmVydGljYXV4LlwiLFxuXHRcdHBsdXNOYW1lOiBcIlBsdXNcIixcblx0XHRwbHVzU25pcDogXCJBZGRpdGlvbm5lIChmYWl0IGxhIHNvbW1lKSBsZXMgdmFsZXVycyBkZSBkZXV4IHJhc3RlcnMsIGNlbGx1bGUgcGFyIGNlbGx1bGUuXCIsXG5cdFx0cGx1c0Rlc2M6IFwiTGEgZm9uY3Rpb24gQWRkaXRpb24gYWpvdXRlIChmYWl0IGxhIHNvbW1lKSBsZXMgdmFsZXVycyBkZSBkZXV4IHJhc3RlcnMsIHBpeGVsIHBhciBwaXhlbC5cIixcblx0XHRwb3dlck5hbWU6IFwiUHVpc3NhbmNlXCIsXG5cdFx0cG93ZXJTbmlwOiBcIkVsw6h2ZSBsZXMgdmFsZXVycyBkZXMgY2VsbHVsZXMgZOKAmXVuIHJhc3RlciDDoCBsYSBwdWlzc2FuY2UgZGVzIHZhbGV1cnMgZOKAmXVuIGF1dHJlIHJhc3Rlci5cIixcblx0XHRwb3dlckRlc2M6IFwiTGEgZm9uY3Rpb24gUHVpc3NhbmNlIMOpbMOodmUgbGVzIHZhbGV1cnMgZGUgcGl4ZWxzIGTigJl1biByYXN0ZXIgw6AgbGEgcHVpc3NhbmNlIGRlcyB2YWxldXJzIGTigJl1biBhdXRyZSByYXN0ZXIuXCIsXG5cdFx0cmFkYXJDYWxpYnJhdGlvbk5hbWU6IFwiQ2FsaWJyYWdlIGRlIHJhZGFyXCIsXG5cdFx0cmFkYXJDYWxpYnJhdGlvblNuaXA6IFwiQ29udmVydGl0IGRlcyBkb25uw6llcyBSQURBUlNBVC0yIGVuIGRvbm7DqWVzIGRlIHLDqXRyb2RpZmZ1c2lvbiByYWRhci5cIixcblx0XHRyYWRhckNhbGlicmF0aW9uRGVzYzogXCJDZXR0ZSBmb25jdGlvbiBwZXJtZXQgZGUgY2FsaWJyZXIgbOKAmWltYWdlcmllIFJBREFSU0FULTIgZGFucyB1biBqZXUgZGUgZG9ubsOpZXMgbW9zYcOvcXVlIG91IGVuIHRhbnQgcXVlIHByb2R1aXQgcmFzdGVyLiBMZSBjYWxpYnJhZ2UgZXN0IGV4w6ljdXTDqSBzdXIgbGVzIGltYWdlcyByYWRhciwgZGUgdGVsbGUgc29ydGUgcXVlIGxlcyB2YWxldXJzIGRlIHBpeGVscyBzb250IHVuZSB2w6lyaXRhYmxlIHJlcHLDqXNlbnRhdGlvbiBkZSBsYSByw6l0cm9kaWZmdXNpb24gcmFkYXIuXCIsXG5cdFx0cmFzdGVySW5mb05hbWU6IFwiSW5mb3JtYXRpb25zIHJhc3RlclwiLFxuXHRcdHJhc3RlckluZm9TbmlwOiBcIk1vZGlmaWUgbGVzIHByb3ByacOpdMOpcyBkdSByYXN0ZXIsIHRlbGxlcyBxdWUgbGEgcHJvZm9uZGV1ciBkZSBjb3VsZXVyLCBsYSB2YWxldXIgTm9EYXRhLCBsYSB0YWlsbGUgZGUgY2VsbHVsZSwgbCfDqXRlbmR1ZSwgZXRjLlwiLFxuXHRcdHJhc3RlckluZm9EZXNjOiBcIkxhIGZvbmN0aW9uIEluZm9ybWF0aW9ucyByYXN0ZXIgcGVybWV0IGTigJlvdXZyaXIgdW5lIGJvw650ZSBkZSBkaWFsb2d1ZSBhZmZpY2hhbnQgbGVzIHByb3ByacOpdMOpcyBkdSBqZXUgZGUgZG9ubsOpZXMgcmFzdGVyLCB0ZWxsZXMgcXVlIGxlIG5vbWJyZSBkZSBjb2xvbm5lcyBldCBkZSBsaWduZXMsIGxlIG5vbWJyZSBkZSBjYW5hdXgsIGxlIHR5cGUgZGUgcGl4ZWwsIGwnw6l0ZW5kdWUgZXQgbGEgcsOpZsOpcmVuY2Ugc3BhdGlhbGUuIFZvdXMgcG91dmV6IG1ldHRyZSDDoCBqb3VyIGNlcyBwcm9wcmnDqXTDqXMgZW4gc8OpbGVjdGlvbm5hbnQgdW4gamV1IGRlIGRvbm7DqWVzIHJhc3RlciDDoCB1dGlsaXNlciBjb21tZSBtb2TDqGxlLiBcIixcblx0XHRyYXN0ZXJpemVBdHRyaWJ1dGVzTmFtZTogXCJSYXN0w6lyaXNlciBsZXMgYXR0cmlidXRzXCIsXG5cdFx0cmFzdGVyaXplQXR0cmlidXRlc1NuaXA6IFwiRW5yaWNoaXQgdW4gcmFzdGVyIHZpYSBkZXMgY2FuYXV4IHN1cHBsw6ltZW50YWlyZXMgZMOpcml2w6lzIGRlIHZhbGV1cnMgZGUgY2VydGFpbnMgYXR0cmlidXRzIGTigJl1bmUgdGFibGUgZXh0ZXJuZSBvdSBk4oCZdW4gc2VydmljZSBk4oCZZW50aXTDqXMuXCIsXG5cdFx0cmFzdGVyaXplQXR0cmlidXRlc0Rlc2M6IFwiTGEgZm9uY3Rpb24gUmFzdMOpcmlzZXIgbGVzIGF0dHJpYnV0cyByYXN0ZXIgZW5yaWNoaXQgdW4gcmFzdGVyIGVuIGFqb3V0YW50IGRlcyBjYW5hdXggZMOpcml2w6lzIGRlIHZhbGV1cnMgZOKAmWF0dHJpYnV0cyBzcMOpY2lmacOpcywgw6AgcGFydGlyIGTigJl1bmUgdGFibGUgZXh0ZXJuZSBvdSBk4oCZdW4gc2VydmljZSBk4oCZZW50aXTDqXMuIFZvdXMgcG91dmV6IHNww6ljaWZpZXIgdW4gcmFzdGVyIGRlIHpvbmVzIGV0IGzigJlhdHRyaWJ1dCBJRCBkZSB6b25lIGFzc29jacOpIHBvdXIgYWN0aXZlciBsYSByZWNoZXJjaGUgcsOpZ2lvbmFsZS5cIixcblx0XHRyYXN0ZXJpemVGZWF0dXJlQ2xhc3NOYW1lOiBcIlJhc3RlcmlzZXIgbGVzIGVudGl0w6lzXCIsXG5cdFx0cmFzdGVyaXplRmVhdHVyZUNsYXNzU25pcDogXCJDb252ZXJ0aXQgbGVzIGVudGl0w6lzIGVuIHJhc3Rlci5cIixcblx0XHRyYXN0ZXJpemVGZWF0dXJlQ2xhc3NEZXNjOiBcIkNldHRlIGZvbmN0aW9uIGNvbnZlcnRpdCBkZXMgZG9ubsOpZXMgZGUgY2xhc3NlcyBk4oCZZW50aXTDqXMgc3VyZmFjaXF1ZXMsIHBvbHlsaWduZXMgZXQgcG9pbnRzIGVuIGNvdWNoZSByYXN0ZXIuPGRpdj48YnIvPkRlcyB2YWxldXJzIGRlIHBpeGVscyBzb250IGF0dHJpYnXDqWVzIGF1eCBlbnRpdMOpcyBlbiBmb25jdGlvbiBkZSBs4oCZT0JKRUNUSUQgZGVzIGVudGl0w6lzIChwYXIgZMOpZmF1dCkuIExlcyB2YWxldXJzIGRlIHBpeGVscyBwZXV2ZW50IMOpZ2FsZW1lbnQgcmVwb3NlciBzdXIgdW4gY2hhbXAgZGUgdmFsZXVycyBkw6lmaW5pZXMgcGFyIGzigJl1dGlsaXNhdGV1ciBkYW5zIGxhIHRhYmxlIGF0dHJpYnV0YWlyZSBkZXMgZW50aXTDqXMgZW4gZW50csOpZS48L2Rpdj5cIixcblx0XHRyZWNhc3ROYW1lOiBcIlJlZMOpZmluaXJcIixcblx0XHRyZWNhc3RTbmlwOiBcIk1vZGlmaWUgbGVzIHBhcmFtw6h0cmVzIGTigJl1bmUgY2hhw65uZSBkZSBmb25jdGlvbnMgZGFucyB1biBqZXUgZGUgZG9ubsOpZXMgbW9zYcOvcXVlIG91IHVuIHNlcnZpY2UgZOKAmWltYWdlcmllLiBDZXR0ZSBvcHRpb24gZXN0IHNvdXZlbnQgdXRpbGlzw6llIGF2ZWMgbGVzIGpldXggZGUgZG9ubsOpZXMgTEFTIGFmaW4gZOKAmcOpdml0ZXIgZGUgY3LDqWVyIHVuIGpldSBkZSBkb25uw6llcyBtb3Nhw69xdWUgc8OpcGFyw6kgcG91ciBkaWZmw6lyZW50ZXMgcmVwcsOpc2VudGF0aW9ucyBk4oCZdW4gdGVycmFpbi5cIixcblx0XHRyZWNhc3REZXNjOiBcIkxhIGZvbmN0aW9uIFJlZMOpZmluaXIgZXN0IHV0aWxpc8OpZSBwb3VyIG1vZGlmaWVyIGR5bmFtaXF1ZW1lbnQgbGUgcGFyYW3DqHRyZSBkZSBmb25jdGlvbiB1dGlsaXPDqSBkYW5zIHVuZSBtb3Nhw69xdWUgb3UgdW4gc2VydmljZSBkJ2ltYWdlcmllIHNhbnMgY29uc2VydmVyIHBoeXNpcXVlbWVudCBsZXMgbW9kaWZpY2F0aW9ucy5cIixcblx0XHRyZWdpb25Hcm91cE5hbWU6IFwiR3JvdXBlcyBwYXIgcsOpZ2lvbnNcIixcblx0XHRyZWdpb25Hcm91cFNuaXA6IFwiUG91ciBjaGFxdWUgY2VsbHVsZSBlbiBzb3J0aWUsIGwnaWRlbnRpdMOpIGRlIGxhIHLDqWdpb24gY29ubmVjdMOpZSDDoCBsYXF1ZWxsZSBhcHBhcnRpZW50IGxhIGNlbGx1bGUgZXN0IGVucmVnaXN0csOpZS4gVW4gbnVtw6lybyB1bmlxdWUgZXN0IGF0dHJpYnXDqSDDoCBjaGFxdWUgcsOpZ2lvbi5cIixcblx0XHRyZWdpb25Hcm91cERlc2M6IFwiTGEgZm9uY3Rpb24gZ2xvYmFsZSBHcm91cGVzIHBhciByw6lnaW9ucyBlbnJlZ2lzdHJlLCBwb3VyIGNoYXF1ZSBjZWxsdWxlIGVuIHNvcnRpZSwgbOKAmWlkZW50aXTDqSBkZSBsYSByw6lnaW9uIGNvbm5lY3TDqWUgw6AgbGFxdWVsbGUgY2V0dGUgY2VsbHVsZSBhcHBhcnRpZW50LiBVbiBudW3DqXJvIHVuaXF1ZSBlc3QgYXR0cmlidcOpIMOgIGNoYXF1ZSByw6lnaW9uLjxkaXY+PGJyLz5MYSBwcmVtacOocmUgcsOpZ2lvbiBhbmFseXPDqWUgcmXDp29pdCBsYSB2YWxldXIgdW4sIGxhIGRldXhpw6htZSwgbGEgdmFsZXVyIGRldXgsIGV0Yy4sIGp1c3F14oCZw6AgY2UgcXXigJl1bmUgdmFsZXVyIHNvaXQgYWZmZWN0w6llIMOgIHRvdXRlcyBsZXMgcsOpZ2lvbnMuIExlIGJhbGF5YWdlIHMnZWZmZWN0dWUgZGUgZ2F1Y2hlIMOgIGRyb2l0ZSwgZGUgaGF1dCBlbiBiYXMuIExlcyB2YWxldXJzIGFmZmVjdMOpZXMgYXV4IHpvbmVzIGVuIHNvcnRpZSBkw6lwZW5kZW50IGR1IG1vbWVudCBvw7kgZWxsZXMgc29udCBkw6l0ZWN0w6llcyBwYXIgbGUgcHJvY2Vzc3VzIGRlIG51bcOpcmlzYXRpb24uPC9kaXY+XCIsXG5cdFx0cmVnaW9uR3Jvd05hbWU6IFwiw4l0ZW5kcmUgbGEgcsOpZ2lvblwiLFxuXHRcdHJlZ2lvbkdyb3dTbmlwOiBcIkV0ZW5kIGxlcyByw6lnaW9ucyDDoCBwYXJ0aXIgZGUgcG9pbnRzIGQnb3JpZ2luZS5cIixcblx0XHRyZWdpb25Hcm93RGVzYzogXCJMYSBmb25jdGlvbiDDiXRlbmRyZSBsYSByw6lnaW9uIHJlZ3JvdXBlIGxlcyBwaXhlbHMgdm9pc2lucyBlbiBmb25jdGlvbiBkdSByYXlvbiBzcMOpY2lmacOpIHBhciByYXBwb3J0IGF1IHBvaW50IGTigJlvcmlnaW5lLiBVbmUgdmFsZXVyIGRlIHJlbXBsaXNzYWdlIHNww6ljaWZpcXVlIGVzdCBhdHRyaWJ1w6llIGF1IGdyb3VwZSBkZSBwaXhlbHMsIG91IG9iamV0LlwiLFxuXHRcdHJlbWFwTmFtZTogXCJDbGFzc2lmaWNhdGlvblwiLFxuXHRcdHJlbWFwU25pcDogXCJDaGFuZ2UgbGVzIHZhbGV1cnMgZGVzIHBpeGVscyBlbiBhdHRyaWJ1YW50IGRlIG5vdXZlbGxlcyB2YWxldXJzIMOgIGRlcyBwbGFnZXMgZGUgdmFsZXVycyBkZSBwaXhlbCBvdSBlbiB1dGlsaXNhbnQgdW5lIHRhYmxlIGV4dGVybmUuXCIsXG5cdFx0cmVtYXBEZXNjOiBcIkxhIGZvbmN0aW9uIENsYXNzaWZpY2F0aW9uIHZvdXMgcGVybWV0IGRlIG1vZGlmaWVyIG91IGRlIHJlY2xhc3NlciBsZXMgdmFsZXVycyBkZXMgcGl4ZWxzIGRlcyBkb25uw6llcyByYXN0ZXIuIENldHRlIG9ww6lyYXRpb24gcGV1dCBz4oCZZWZmZWN0dWVyIGVuIHNww6ljaWZpYW50IHVuZSBwbGFnZSBkZSB2YWxldXJzIGRlIHBpeGVscyDDoCBhcHBhcmllciDDoCB1bmUgdmFsZXVyIGRlIHBpeGVsIGVuIHNvcnRpZSBvdSBlbiB1dGlsaXNhbnQgdW5lIHRhYmxlIHBvdXIgYXBwYXJpZXIgbGVzIHZhbGV1cnMgZGUgcGl4ZWxzIMOgIHVuZSB2YWxldXIgZGUgcGl4ZWwgZW4gc29ydGllLlwiLFxuXHRcdHJlcHJvamVjdE5hbWU6IFwiUmVwcm9qZXRlclwiLFxuXHRcdHJlcHJvamVjdFNuaXA6IFwiTW9kaWZpZSBsYSBwcm9qZWN0aW9uIGQndW4gamV1IGRlIGRvbm7DqWVzIHJhc3RlciwgZCd1bmUgbW9zYcOvcXVlIG91IGQndW4gw6lsw6ltZW50IHJhc3RlciBkYW5zIHVuZSBtb3Nhw69xdWUuIEVsbGUgcGVybWV0IMOpZ2FsZW1lbnQgZGUgcsOpw6ljaGFudGlsbG9ubmVyIGxlcyBkb25uw6llcyBwb3VyIGTDqWZpbmlyIHVuZSBub3V2ZWxsZSB0YWlsbGUgZGUgY2VsbHVsZSBldCB1bmUgb3JpZ2luZS5cIixcblx0XHRyZXByb2plY3REZXNjOiBcIkxhIGZvbmN0aW9uIGRlIHJlcHJvamVjdGlvbiBtb2RpZmllIGxhIHByb2plY3Rpb24gZOKAmXVuIGpldSBkZSBkb25uw6llcyByYXN0ZXIsIGTigJl1biBqZXUgZGUgZG9ubsOpZXMgbW9zYcOvcXVlIG91IGTigJl1biDDqWzDqW1lbnQgcmFzdGVyIGRhbnMgdW4gamV1IGRlIGRvbm7DqWVzIG1vc2HDr3F1ZS4gRWxsZSBwZXJtZXQgw6lnYWxlbWVudCBkZSByw6nDqWNoYW50aWxsb25uZXIgbGVzIGRvbm7DqWVzIHBvdXIgZMOpZmluaXIgdW5lIG5vdXZlbGxlIHRhaWxsZSBkZSBjZWxsdWxlIGV0IHVuZSBvcmlnaW5lLjxkaXY+PGJyLz5MYSBmb25jdGlvbiBSZXByb2pldGVyIHBldXQgc2VydmlyIGxvcnMgZGUgbGEgY3LDqWF0aW9uIGTigJl1biBjYWNoZSDDoCBwYXJ0aXIgZOKAmXVuIGpldSBkZSBkb25uw6llcyByYXN0ZXIgb3UgZOKAmXVuIGRlIGRvbm7DqWVzIG1vc2HDr3F1ZSBxdWkgbmUgZmlndXJlIHBhcyBkYW5zIGxhIHByb2plY3Rpb24gcmVxdWlzZS4gUGFyIGV4ZW1wbGUsIGxvcnNxdWUgdm91cyBjcsOpZXogdW4gc2VydmljZSBk4oCZaW1hZ2VyaWUgZW4gY2FjaGUgcXVlIGRlcyBhcHBsaWNhdGlvbnMgcGV1dmVudCBpbnTDqWdyZXIgw6AgZOKAmWF1dHJlcyBzZXJ2aWNlcyBlbiBjYWNoZSwgaWwgZXN0IGltcG9ydGFudCBxdeKAmWlscyBmaWd1cmVudCB0b3VzIGRhbnMgbGEgbcOqbWUgcHJvamVjdGlvbi4gSWwgc+KAmWFnaXQgc291dmVudCBk4oCZdW5lIHByb2plY3Rpb24gV2ViIE1lcmNhdG9yLiBDb21tZSBsZSBqZXUgZGUgZG9ubsOpZXMgbW9zYcOvcXVlIG5lIHBldXQgcGFzIMOqdHJlIHJlcHJvamV0w6ksIHZvdXMgcG91dmV6IHByb2PDqWRlciBkZSBs4oCZdW5lIGRlcyBtYW5pw6hyZXMgc3VpdmFudGVz4oCUY3LDqWV6IHVuIGpldSBkZSBkb25uw6llcyByw6lmw6lyZW5jw6kgw6AgcGFydGlyIGRlIHZvdHJlIGpldSBkZSBkb25uw6llcyBtb3Nhw69xdWUgZGFucyBsYSBwcm9qZWN0aW9uIHJlcXVpc2Ugb3UgYWpvdXRleiBsYSBmb25jdGlvbiBSZXByb2pldGVyIMOgIGxhIGNoYcOubmUgZGUgZm9uY3Rpb25zIGR1IGpldSBkZSBkb25uw6llcyBtb3Nhw69xdWUuIFVuIGF1dHJlIGV4ZW1wbGUgdXRpbGlzZSBjZXR0ZSBmb25jdGlvbiBzdXIgbCfDqWzDqW1lbnQgcmFzdGVyIGQndW4gamV1IGRlIGRvbm7DqWVzIG1vc2HDr3F1ZS4gTG9yc3F1ZSB2b3VzIGZhaXRlcyBhcHBlbCDDoCBsYSBmb25jdGlvbiBSYXN0ZXIgbWlzIGVuIGNhY2hlLCB2b3VzIHBvdXZleiBpbnPDqXJlciBsYSBmb25jdGlvbiBSZXByb2pldGVyIHBvdXIgY3LDqWVyIGxlIGNhY2hlIGRhbnMgbGEgbm91dmVsbGUgcHJvamVjdGlvbi4gTGVzIMOpbMOpbWVudHMgcmFzdGVyIGQndW5lIG1vc2HDr3F1ZSBwZXV2ZW50IMOqdHJlIG1pcyBlbiBjYWNoZSBsb3JzcXVlIGxlIHRyYWl0ZW1lbnQgZXN0IGludGVuc2UgZXQgcXVlIHZvdXMgZXNzYXlleiBkZSBwdWJsaWVyIHVuIHNlcnZpY2UgZCdpbWFnZXJpZSBxdWkgZXN0IHJhcGlkZSwgc2FucyBsZSBtZXR0cmUgdG90YWxlbWVudCBlbiBjYWNoZS48L2Rpdj5cIixcblx0XHRyZXNhbXBsZU5hbWU6IFwiUsOpLcOpY2hhbnRpbGxvbm5lclwiLFxuXHRcdHJlc2FtcGxlU25pcDogXCJNb2RpZmllIGxhIHRhaWxsZSBkZSBjZWxsdWxlIGQndW4gcmFzdGVyLlwiLFxuXHRcdHJlc2FtcGxlRGVzYzogXCJMYSBmb25jdGlvbiBSw6ktw6ljaGFudGlsbG9ubmVyIG1vZGlmaWUgbGEgdGFpbGxlIGRlIGNlbGx1bGUsIGxlIHR5cGUgZGUgcsOpw6ljaGFudGlsbG9ubmFnZSBvdSBsZXMgZGV1eC48ZGl2Pjxici8+RWxsZSBkb2l0IMOqdHJlIHV0aWxpc8OpZSB1bmlxdWVtZW50IGF2ZWMgZGVzIGJlc29pbnMgZW4gY2FsY3VsIHNww6ljaWZpcXVlcy4gUGFyIGV4ZW1wbGUsIHNpIHZvdXMgY2FsY3VsZXogbGEgZ3JhbmRldXItZGlyZWN0aW9uIGR1IHZlbnQgb3UgZHUgY291cmFudCBxdWkgbsOpY2Vzc2l0ZSB1biByw6nDqWNoYW50aWxsb25uYWdlIMOgIHBhcnRpciBkZSBsYSByw6lzb2x1dGlvbiBzb3VyY2UuPC9kaXY+XCIsXG5cdFx0cm91bmREb3duTmFtZTogXCJBcnJvbmRpIGluZsOpcmlldXJcIixcblx0XHRyb3VuZERvd25TbmlwOiBcIlJlbnZvaWUgbGEgcHJvY2hhaW5lIHZhbGV1ciBlbnRpw6hyZSBpbmbDqXJpZXVyZSwgc2ltcGxlbWVudCByZXByw6lzZW50w6llIGVuIHRhbnQgcXVlIHZpcmd1bGUgZmxvdHRhbnRlLCBwb3VyIGNoYXF1ZSBjZWxsdWxlIGTigJl1biByYXN0ZXIuXCIsXG5cdFx0cm91bmREb3duRGVzYzogXCJMYSBmb25jdGlvbiBBcnJvbmRpIGluZsOpcmlldXIgcmVudm9pZSBsZSBwcm9jaGFpbiBlbnRpZXIgaW5mw6lyaWV1ciwgZW4gdGFudCBxdWUgdmFsZXVyIGRlIHZpcmd1bGUgZmxvdHRhbnRlLCBwb3VyIGNoYXF1ZSBwaXhlbCBk4oCZdW4gcmFzdGVyLlwiLFxuXHRcdHJvdW5kVXBOYW1lOiBcIkFycm9uZGkgc3Vww6lyaWV1clwiLFxuXHRcdHJvdW5kVXBTbmlwOiBcIlJlbnZvaWUgbGEgcHJvY2hhaW5lIHZhbGV1ciBlbnRpw6hyZSBzdXDDqXJpZXVyZSwgc2ltcGxlbWVudCByZXByw6lzZW50w6llIGVuIHRhbnQgcXVlIHZpcmd1bGUgZmxvdHRhbnRlLCBwb3VyIGNoYXF1ZSBjZWxsdWxlIGTigJl1biByYXN0ZXIuXCIsXG5cdFx0cm91bmRVcERlc2M6IFwiTGEgZm9uY3Rpb24gQXJyb25kaSBzdXDDqXJpZXVyIHJlbnZvaWUgbGUgcHJvY2hhaW4gZW50aWVyIHN1cMOpcmlldXIsIGVuIHRhbnQgcXVlIHZhbGV1ciBkZSB2aXJndWxlIGZsb3R0YW50ZSwgcG91ciBjaGFxdWUgcGl4ZWwgZOKAmXVuIHJhc3Rlci5cIixcblx0XHRzZWdtZW50TWVhblNoaWZ0TmFtZTogXCJEw6ljYWxhZ2UgbW95ZW4gZGUgc2VnbWVudFwiLFxuXHRcdHNlZ21lbnRNZWFuU2hpZnRTbmlwOiBcIlJlZ3JvdXBlIGxlcyBwaXhlbHMgYWRqYWNlbnRzIHF1aSBwcsOpc2VudGVudCBkZXMgY2FyYWN0w6lyaXN0aXF1ZXMgc3BlY3RyYWxlcyBzaW1pbGFpcmVzIGVuIHNlZ21lbnRzLlwiLFxuXHRcdHNlZ21lbnRNZWFuU2hpZnREZXNjOiBcIkNldHRlIGZvbmN0aW9uIGlkZW50aWZpZSBsZXMgb2JqZXRzLCBlbnRpdMOpcyBvdSBzZWdtZW50cyBkYW5zIHZvdHJlIGltYWdlcmllIGVuIHJlZ3JvdXBhbnQgbGVzIHBpeGVscyBhZGphY2VudHMgcXVpIHByw6lzZW50ZW50IGRlcyBjYXJhY3TDqXJpc3RpcXVlcyBzcGVjdHJhbGVzIGV0IHNwYXRpYWxlcyBzaW1pbGFpcmVzLiBWb3VzIHBvdXZleiBjb250csO0bGVyIGxhIHF1YW50aXTDqSBkZSBsaXNzYWdlIHNwYXRpYWwgZXQgc3BlY3RyYWwgcG91ciBkw6lmaW5pciBkZXMgZW50aXTDqXMgcXVpIHZvdXMgaW50w6lyZXNzZW50LlwiLFxuXHRcdHMxUmFkaW9tZXRyaWNDYWxpYnJhdGlvbk5hbWU6IFwiQ2FsaWJyYWdlIHJhZGlvbcOpdHJpcXVlIFNlbnRpbmVsLTFcIixcblx0XHRzMVJhZGlvbWV0cmljQ2FsaWJyYXRpb25TbmlwOiBcIkVmZmVjdHVlIGRpZmbDqXJlbnRzIHR5cGVzIGRlIGNhbGlicmFnZSByYWRpb23DqXRyaXF1ZSBzdXIgbGVzIGRvbm7DqWVzIGRlIFNlbnRpbmVsLTEuXCIsXG5cdFx0czFSYWRpb21ldHJpY0NhbGlicmF0aW9uRGVzYzogXCJDZXR0ZSBmb25jdGlvbiByYXN0ZXIgZWZmZWN0dWUgdHJvaXMgY2FsaWJyYWdlcyBkaWZmw6lyZW50cyBwb3VyIGxlcyBqZXV4IGRlIGRvbm7DqWVzIFNlbnRpbmVsIDEsIG5vdGFtbWVudCBCw6p0YSB6w6lybyBldCBHYW1tYSwgZXQgZ8OpbsOocmUgbGUgamV1IGRlIGRvbm7DqWVzIGNhbGlicsOpLiBM4oCZb2JqZWN0aWYgZHUgY2FsaWJyYWdlIFNBUiBlc3QgZGUgZm91cm5pciBs4oCZaW1hZ2VyaWUgZGFucyBsYXF1ZWxsZSBsZXMgdmFsZXVycyBkZSBwaXhlbHMgcGV1dmVudCDDqnRyZSBkaXJlY3RlbWVudCBhc3NvY2nDqWVzIMOgIGxhIHLDqXRyb2RpZmZ1c2lvbiByYWRhciBkZSBsYSBzY8OobmUuIEJpZW4gcXVlIGzigJlpbWFnZXJpZSBTQVIgbm9uIGNhbGlicsOpZSBzb2l0IHN1ZmZpc2FudGUgZW4gdGVybWVzIGRlIHF1YWxpdMOpLCBsZXMgaW1hZ2VzIFNBUiBjYWxpYnLDqWVzIHNvbnQgZXNzZW50aWVsbGVzIMOgIGzigJl1dGlsaXNhdGlvbiBxdWFudGl0YXRpdmUgZGVzIGRvbm7DqWVzIFNBUi48ZGl2Pjxici8+TGUgdHJhaXRlbWVudCBzdGFuZGFyZCBkZXMgZG9ubsOpZXMgU0FSLCBxdWkgcHJvZHVpdCBkZXMgaW1hZ2VzIGRlIG5pdmVhdSAxLCBu4oCZaW5jbHV0IHBhcyBsZXMgY29ycmVjdGlvbnMgcmFkaW9tw6l0cmlxdWVzIGV0IGlsIGRlbWV1cmUgdW5lIGTDqWZvcm1hdGlvbiByYWRpb23DqXRyaXF1ZSBzaWduaWZpY2F0aXZlLiBJbCBlc3QgcGFyIGNvbnPDqXF1ZW50IG7DqWNlc3NhaXJlIGTigJlhcHBsaXF1ZXIgdW5lIGNvcnJlY3Rpb24gcmFkaW9tw6l0cmlxdWUgYXV4IGltYWdlcyBTQVIgYWZpbiBxdWUgbGVzIHZhbGV1cnMgZGUgcGl4ZWxzIGRlcyBpbWFnZXMgcmVwcsOpc2VudGVudCByw6llbGxlbWVudCBsYSByw6l0cm9kaWZmdXNpb24gcmFkYXIgZGUgbGEgc3VyZmFjZSByw6lmbMOpY2hpc3NhbnRlLiBMYSBjb3JyZWN0aW9uIHJhZGlvbcOpdHJpcXVlIGVzdCDDqWdhbGVtZW50IG7DqWNlc3NhaXJlIHBvdXIgY29tcGFyZXIgZGVzIGltYWdlcyBTQVIgYWNxdWlzZXMgYXZlYyBkaWZmw6lyZW50cyBjYXB0ZXVycywgb3UgYWNxdWlzZXMgw6AgcGFydGlyIGR1IG3Dqm1lIGNhcHRldXIgbWFpcyDDoCBkaWZmw6lyZW50cyBtb21lbnRzLCBkYW5zIGRpZmbDqXJlbnRzIG1vZGVzIG91IHRyYWl0w6llcyBwYXIgZGlmZsOpcmVudHMgY2FwdGV1cnMuPC9kaXY+XCIsXG5cdFx0czFUaGVybWFsTm9pc2VSZW1vdmFsTmFtZTogXCJTdXBwcmVzc2lvbiBkZSBicnVpdCB0aGVybWlxdWUgU2VudGluZWwtMVwiLFxuXHRcdHMxVGhlcm1hbE5vaXNlUmVtb3ZhbFNuaXA6IFwiU3VwcHJpbWUgbGUgYnJ1aXQgdGhlcm1pcXVlIGRlcyBkb25uw6llcyBkZSBTZW50aW5lbC0xLlwiLFxuXHRcdHMxVGhlcm1hbE5vaXNlUmVtb3ZhbERlc2M6IFwiTGEgY29ycmVjdGlvbiBkZSBicnVpdCB0aGVybWlxdWUgcGV1dCDDqnRyZSBhcHBsaXF1w6llIGF1eCBwcm9kdWl0cyBTTEMgKFNpbmdsZSBMb29rIENvbXBsZXgpIFNlbnRpbmVsLTEgZGUgbml2ZWF1IDEgZXQgR1JEIChHcm91bmQgUmFuZ2UgRGV0ZWN0aW9uKSBkZSBuaXZlYXUgMSBu4oCZYXlhbnQgcGFzIGTDqWrDoCDDqXTDqSBjb3JyaWfDqXMuIEzigJlvcMOpcmF0ZXVyIHBldXQgw6lnYWxlbWVudCDDqWxpbWluZXIgY2V0dGUgY29ycmVjdGlvbiBlbiBmb25jdGlvbiBkZXMgYW5ub3RhdGlvbnMgZGUgcHJvZHVpdCBhZmluIGRlIHLDqWludHJvZHVpcmUgbGUgc2lnbmFsIGRlIGJydWl0IGF5YW50IMOpdMOpIHN1cHByaW3DqSBwb3VyIGfDqW7DqXJlciBsZSBwcm9kdWl0IGTigJlvcmlnaW5lLiBMZXMgYW5ub3RhdGlvbnMgZGUgcHJvZHVpdCBzZXJvbnQgbWlzZXMgw6Agam91ciBjb25mb3Jtw6ltZW50IHBvdXIgcGVybWV0dHJlIHVuZSBub3V2ZWxsZSBhcHBsaWNhdGlvbiBkZSBsYSBjb3JyZWN0aW9uLiBcIixcblx0XHRzZXROdWxsTmFtZTogXCJTZXROdWxsXCIsXG5cdFx0c2V0TnVsbFNuaXA6IFwiTOKAmW91dGlsIFNldE51bGwgZMOpZmluaXQgbGVzIGVtcGxhY2VtZW50cyBkZSBjZWxsdWxlIGlkZW50aWZpw6lzIHN1ciBsYSB2YWxldXIgTm9EYXRhIGVuIGZvbmN0aW9uIGRlcyBjcml0w6hyZXMgaW5kaXF1w6lzLiBJbCByZW52b2llIHVuZSB2YWxldXIgTm9EYXRhIHNpIHVuZSDDqXZhbHVhdGlvbiBjb25kaXRpb25uZWxsZSBlc3QgdnJhaWUgZXQgcmVudm9pZSBsYSB2YWxldXIgc3DDqWNpZmnDqWUgcGFyIHVuIGF1dHJlIHJhc3RlciBzaSBjZWxsZS1jaSBlc3QgZmF1c3NlLlwiLFxuXHRcdHNldE51bGxEZXNjOiBcIkxhIGZvbmN0aW9uIFNldE51bGwgZMOpZmluaXQgbGVzIHBpeGVscyBpZGVudGlmacOpcyBzdXIgbGEgdmFsZXVyIE5vRGF0YSBlbiBmb25jdGlvbiBkZXMgY3JpdMOocmVzIGluZGlxdcOpcy4gRWxsZSByZW52b2llIHVuZSB2YWxldXIgTm9EYXRhIHNpIHVuZSDDqXZhbHVhdGlvbiBjb25kaXRpb25uZWxsZSBlc3QgdnJhaWUgKDEpIGV0IHJlbnZvaWUgbGEgdmFsZXVyIHNww6ljaWZpw6llIGRhbnMgbGUgcmFzdGVyIGZhdXggc2kgdW5lIMOpdmFsdWF0aW9uIGNvbmRpdGlvbm5lbGxlIGVzdCBmYXVzc2UgKDApLiBDZSBjcml0w6hyZSBlc3Qgc3DDqWNpZmnDqSBwYXIgbGEgc29ydGllIGTigJl1bmUgZm9uY3Rpb24gbWF0aMOpbWF0aXF1ZSBsb2dpcXVlLCBxdWkgc2VyYSBsZSByYXN0ZXIgZW4gZW50csOpZS5cIixcblx0XHRzaGFkZWRSZWxpZWZOYW1lOiBcIlJlbGllZiBvbWJyw6lcIixcblx0XHRzaGFkZWRSZWxpZWZTbmlwOiBcIkNyw6llIHVuZSByZXByw6lzZW50YXRpb24gM0QgbXVsdGljYW5hbCwgY29kw6llIHBhciBjb3VsZXVyLCBkZSBsYSBzdXJmYWNlLCBlbiB0ZW5hbnQgY29tcHRlIGRlIGxhIHBvc2l0aW9uIHJlbGF0aXZlIGR1IHNvbGVpbCBwb3VyIG9tYnJlciBsJ2ltYWdlLlwiLFxuXHRcdHNoYWRlZFJlbGllZkRlc2M6IFwiTGEgZm9uY3Rpb24gUmVsaWVmIG9tYnLDqSBjcsOpZSB1bmUgcmVwcsOpc2VudGF0aW9uIDNEIGVuIGNvdWxldXIgZHUgdGVycmFpbiBlbiBjb21iaW5hbnQgbGVzIGltYWdlcyBkZXMgbcOpdGhvZGVzIFByw6ljb2TDqSBwYXIgYWx0aXR1ZGUgZXQgT21icmFnZS4gQ2V0dGUgZm9uY3Rpb24gdXRpbGlzZSBsZXMgcHJvcHJpw6l0w6lzIGQnYWx0aXR1ZGUgZXQgZCdhemltdXQgcG91ciBzcMOpY2lmaWVyIGxhIHBvc2l0aW9uIGR1IHNvbGVpbC48ZGl2Pjxici8+PC9kaXY+XCIsXG5cdFx0c2luSE5hbWU6IFwiU2luSFwiLFxuXHRcdHNpbkhTbmlwOiBcIkNhbGN1bGUgbGUgc2ludXMgaHlwZXJib2xpcXVlIGRlcyBjZWxsdWxlcyBk4oCZdW4gcmFzdGVyLlwiLFxuXHRcdHNpbkhEZXNjOiBcIkxhIGZvbmN0aW9uIGNhbGN1bGUgbGUgc2ludXMgaHlwZXJib2xpcXVlIGRlcyBwaXhlbHMgZGFucyB1biByYXN0ZXIuXCIsXG5cdFx0c2luTmFtZTogXCJTaW5cIixcblx0XHRzaW5TbmlwOiBcIkNhbGN1bGUgbGUgc2ludXMgZGVzIGNlbGx1bGVzIGTigJl1biByYXN0ZXIuXCIsXG5cdFx0c2luRGVzYzogXCJMYSBmb25jdGlvbiBjYWxjdWxlIGxlIHNpbnVzIGRlcyBwaXhlbHMgZGFucyB1biByYXN0ZXIuXCIsXG5cdFx0c2xvcGVOYW1lOiBcIlBlbnRlXCIsXG5cdFx0c2xvcGVTbmlwOiBcIkNhbGN1bGUgbGUgdGF1eCBkZSBtb2RpZmljYXRpb24gZW50cmUgbGEgdmFsZXVyIGQndW4gcGl4ZWwgZXQgZGVzIHBpeGVscyBhZGphY2VudHMuXCIsXG5cdFx0c2xvcGVEZXNjOiBcIkNldHRlIGZvbmN0aW9uIHJhc3RlciBjYWxjdWxlIGxhIHBlbnRlLCBxdWkgY29ycmVzcG9uZCBhdSB0YXV4IGRlIGNoYW5nZW1lbnQgZOKAmWFsdGl0dWRlIHBvdXIgY2hhcXVlIGNlbGx1bGUgZHUgbW9kw6hsZSBudW3DqXJpcXVlIGRlIHRlcnJhaW4gKE1ORSkuIEMnZXN0IGxhIHByZW1pw6hyZSBkw6lyaXbDqWUgZCd1biBETUUuPGRpdj48YnIvPkNldHRlIGZvbmN0aW9uIHV0aWxpc2UgdW5lIGZvbmN0aW9uIGF0YW4oKSBhY2PDqWzDqXLDqWUuIEVsbGUgZXN0IHNpeCBmb2lzIHBsdXMgcmFwaWRlLCBldCBsJ2VycmV1ciBkJ2FwcHJveGltYXRpb24gZXN0IHRvdWpvdXJzIGluZsOpcmlldXJlIMOgIDAsMyBkZWdyw6kuPC9kaXY+XCIsXG5cdFx0c3BlY2tsZU5hbWU6IFwiR3JhbnVsYXJpdMOpXCIsXG5cdFx0c3BlY2tsZVNuaXA6IFwiUHJvcG9zZSBkZXMgZmlsdHJlcyBkZXN0aW7DqXMgw6AgcsOpZHVpcmUgbGUgYnJ1aXQgZGVzIGpldXggZGUgZG9ubsOpZXMgZGUgcmFkYXIgw6Agb3V2ZXJ0dXJlIHN5bnRow6l0aXF1ZS5cIixcblx0XHRzcGVja2xlRGVzYzogXCJMYSBncmFudWxhcml0w6kgY29ycmVzcG9uZCBhdSBicnVpdCBoYXV0ZSBmcsOpcXVlbmNlIGRlcyBkb25uw6llcyByYWRhci4gTGVzIGltYWdlcyBnw6luw6lyw6llcyBwYXIgbGVzIHN5c3TDqG1lcyByYWRhciBk4oCZb3V2ZXJ0dXJlIHN5bnRow6l0aXF1ZSAoU0FSLCBTeW50aGV0aWMgQXBlcnR1cmUgUmFkYXIpIHNvbnQgZnLDqXF1ZW1tZW50IHN1amV0dGVzIGF1eCBlZmZldHMgZGUgZ3JhbnVsYXJpdMOpIGVuIHJhaXNvbiBkdSB0cmFpdGVtZW50IGRlcyBzaWduYXV4IGRpc3BlcnPDqXMgZXQgZGUgbOKAmWludGVyZsOpcmVuY2UgZGVzIG9uZGVzIMOpbGVjdHJvbWFnbsOpdGlxdWVzIGRpc3BlcnPDqWVzIMOgIHBhcnRpciBkZXMgc3VyZmFjZXMgb3UgZGVzIG9iamV0cy4gQ2V0dGUgZm9uY3Rpb24gR3JhbnVsYXJpdMOpIGZpbHRyZSBsZSBqZXUgZGUgZG9ubsOpZXMgcmFkYXIgcG91ciBhdHTDqW51ZXIgbGUgYnJ1aXQgdG91dCBlbiBjb25zZXJ2YW50IGxlcyB0cm9uw6dvbnMgb3UgbGVzIGVudGl0w6lzIHBvaW50dWVzIGRlIGzigJlpbWFnZS5cIixcblx0XHRzcGVjdHJhbENvbnZlcnNpb25OYW1lOiBcIkNvbnZlcnNpb24gc3BlY3RyYWxlXCIsXG5cdFx0c3BlY3RyYWxDb252ZXJzaW9uU25pcDogXCJBcHBsaXF1ZSB1bmUgbWF0cmljZSDDoCB1bmUgaW1hZ2UgbXVsdGljYW5hbC5cIixcblx0XHRzcGVjdHJhbENvbnZlcnNpb25EZXNjOiBcIkxhIGZvbmN0aW9uIENvbnZlcnNpb24gc3BlY3RyYWxlIGFwcGxpcXVlIHVuZSBtYXRyaWNlIMOgIHVuZSBpbWFnZSBtdWx0aWNhbmFsIHBvdXIgYWZmZWN0ZXIgbGVzIGNvdWxldXJzIGRlIGxhIHNvcnRpZS48ZGl2Pjxici8+Q2VydGFpbnMgY2FwdGV1cnMgbmUgY29sbGVjdGVudCBwYXMgbGVzIGNhbmF1eCBibGV1cyBlbiByYWlzb24gZGUgbGEgZmFpYmxlc3NlIGR1IHJhcHBvcnQgc2lnbmFsL2JydWl0LiBFbGxlIHBlcm1ldCwgcGFyIGV4ZW1wbGUsIGRlIGNvbnZlcnRpciB1bmUgaW1hZ2UgaW5mcmFyb3VnZSBkZSBjb3VsZXVycyBmYXVzc2VzIGVuIHVuZSBpbWFnZSBkZSBjb3VsZXVycyBwc2V1ZG8gbmF0dXJlbGxlcy48L2Rpdj5cIixcblx0XHRzcXVhcmVSb290TmFtZTogXCJSYWNpbmUgY2FycsOpZVwiLFxuXHRcdHNxdWFyZVJvb3RTbmlwOiBcIkNhbGN1bGUgbGEgcmFjaW5lIGNhcnLDqWUgZGVzIHZhbGV1cnMgZGUgY2VsbHVsZXMgZOKAmXVuIHJhc3Rlci5cIixcblx0XHRzcXVhcmVSb290RGVzYzogXCJMYSBmb25jdGlvbiBSYWNpbmUgY2FycsOpZSBjYWxjdWxlIGxhIHJhY2luZSBjYXJyw6llIGRlcyB2YWxldXJzIGRlIHBpeGVscyBkYW5zIHVuIHJhc3Rlci5cIixcblx0XHRzcXVhcmVOYW1lOiBcIkNhcnLDqVwiLFxuXHRcdHNxdWFyZVNuaXA6IFwiQ2FsY3VsZSBsZSBjYXJyw6kgZGVzIHZhbGV1cnMgZGUgY2VsbHVsZSBk4oCZdW4gcmFzdGVyLlwiLFxuXHRcdHNxdWFyZURlc2M6IFwiTGEgZm9uY3Rpb24gQ2FycsOpIGNhbGN1bGUgbGUgY2FycsOpIGRlcyB2YWxldXJzIGRlIHBpeGVscyBkYW5zIHVuIHJhc3Rlci5cIixcblx0XHRzdGF0aXN0aWNzSGlzdG9ncmFtTmFtZTogXCJTdGF0aXN0aXF1ZXMgZXQgaGlzdG9ncmFtbWVcIixcblx0XHRzdGF0aXN0aWNzSGlzdG9ncmFtU25pcDogXCJEw6lmaW5pdCBvdSBhc3NvY2llIGRlcyBzdGF0aXN0aXF1ZXMgZXQgdW4gaGlzdG9ncmFtbWUuXCIsXG5cdFx0c3RhdGlzdGljc0hpc3RvZ3JhbURlc2M6IFwiTGEgZm9uY3Rpb24gU3RhdGlzdGlxdWVzIGV0IGhpc3RvZ3JhbW1lIHBlcm1ldCBkZSBkw6lmaW5pciBsZXMgc3RhdGlzdGlxdWVzIGV0IGwnaGlzdG9ncmFtbWUgZCd1biByYXN0ZXIuIFZvdXMgcG91dmV6IGluc8OpcmVyIGNldHRlIGZvbmN0aW9uIMOgIGxhIGZpbiBkZSBsYSBjaGHDrm5lIGRlIGZvbmN0aW9ucyBwb3VyIGTDqWNyaXJlIGxlcyBzdGF0aXN0aXF1ZXMgZXQgbOKAmWhpc3RvZ3JhbW1lIGTigJl1biBtb2TDqGxlIGRlIGZvbmN0aW9uIHJhc3Rlci4gQ2VsYSBwZXV0IHMnYXbDqXJlciBuw6ljZXNzYWlyZSBwb3VyIGNvbnRyw7RsZXIgbCdhZmZpY2hhZ2UgcGFyIGTDqWZhdXQgZHUgcsOpc3VsdGF0IGR1IHRyYWl0ZW1lbnQsIHBsdXMgcGFydGljdWxpw6hyZW1lbnQgbG9yc3F1ZSB2b3VzIGTDqWZpbmlzc2V6IHVuZSBjaGHDrm5lIGRlIGZvbmN0aW9ucyBjb250ZW5hbnQgZGUgbm9tYnJldXNlcyBmb25jdGlvbnMuPGRpdj48YnIvPlZvdXMgcG91dmV6IGTDqWZpbmlyIGxlcyBzdGF0aXN0aXF1ZXMgZW4gc2Fpc2lzc2FudCBsZXMgdmFsZXVycyBvdSBlbiBsZXMgaW1wb3J0YW50IGTigJl1biBqZXUgZGUgZG9ubsOpZXMgcmFzdGVyIG91IGTigJl1biBmaWNoaWVyIFhNTC4gTGVzIGhpc3RvZ3JhbW1lcyBwZXV2ZW50IHVuaXF1ZW1lbnQgw6p0cmUgZMOpZmluaXMgZW4gaW1wb3J0YW50IHVuIGZpY2hpZXIuPC9kaXY+XCIsXG5cdFx0c3RhdGlzdGljc05hbWU6IFwiU3RhdGlzdGlxdWVzXCIsXG5cdFx0c3RhdGlzdGljc1NuaXA6IFwiQ2FsY3VsZSBsZXMgc3RhdGlzdGlxdWVzIGZvY2FsZXMgZGUgY2hhcXVlIHBpeGVsIGTigJl1bmUgaW1hZ2UgZW4gZm9uY3Rpb24gZOKAmXVuIHZvaXNpbmFnZSBmb2NhbCBkw6lmaW5pLlwiLFxuXHRcdHN0YXRpc3RpY3NEZXNjOiBcIkxhIGZvbmN0aW9uIFN0YXRpc3RpcXVlcyBjYWxjdWxlIGRlcyBzdGF0aXN0aXF1ZXMgZm9jYWxlcyBwb3VyIGNoYXF1ZSBwaXhlbCBkJ3VuZSBpbWFnZSwgZW4gZm9uY3Rpb24gZCd1biB2b2lzaW5hZ2UgZm9jYWwgZMOpZmluaS48ZGl2Pjxici8+TGEgZm9uY3Rpb24gU3RhdGlzdGlxdWUgcGV1dCDDqnRyZSB1dGlsaXPDqWUgcG91ciByZW1wbGlyIGxlcyBsaWduZXMgc3VwcHJpbcOpZXMgZGFucyB1bmUgaW1hZ2UuIExlcyBsaWduZXMgc3VwcHJpbcOpZXMgc29udCBzb3V2ZW50IGR1ZXMgw6AgZGVzIHByb2Jsw6htZXMgZGUgY2FwdGV1ciBvw7kgbGVzIGRvbm7DqWVzIG5lIHNvbnQgcGFzIGNvbGxlY3TDqWVzLiBDZWxhIHPigJllc3QgZMOpasOgIHByb2R1aXQgYXZlYyBsZSBjYXB0ZXVyIEVuaGFuY2VkIFRoZW1hdGljIE1hcHBlciBQbHVzIChFVE0rKSBkZSBMYW5kc2F0IDcsIHBhciBleGVtcGxlLiBDZXMgZG9ubsOpZXMgbWFucXVhbnRlcyBlbmdlbmRyZW50IGRlcyBwcm9ibMOobWVzIGQnYW5hbHlzZSBtYWlzIGF1c3NpIGQnYWZmaWNoYWdlIGRlcyBpbWFnZXMuIElsIHNlbWJsZSBxdSdpbCB5IGFpdCBwZXUgZGUgc29sdXRpb25zIGxvcnNxdWUgdm91cyB1dGlsaXNleiBkZXMgaW1hZ2VzIHBvdXIgYW5hbHlzZSA7IHRvdXRlZm9pcywgdW5lIGltYWdlIHN1cGVycG9zw6llIHBldXQgc2VydmlyIMOgIHJlbXBsYWNlciBsZSBjb250ZW51IG1hbnF1YW50LiBWb3VzIHBvdXZleiBwcm9jw6lkZXIgZGUgbGEgbcOqbWUgbWFuacOocmUgc2kgbCdpbWFnZSBlc3QgdXRpbGlzw6llIMOgIGRlcyBmaW5zIGRlIHZpc3VhbGlzYXRpb24uIENlcGVuZGFudCwgY29tbWUgdm91cyBuZSBkaXNwb3NleiBwYXMgdG91am91cnMgZCd1bmUgaW1hZ2Ugc3VwcGzDqW1lbnRhaXJlIHBvdXIgcmVtcGxpciBsZSBjb250ZW51IG1hbnF1YW50LCB2b3VzIGRldmV6IGwnb2J0ZW5pciDDoCBwYXJ0aXIgZGVzIGRvbm7DqWVzIGV4aXN0YW50ZXMuPC9kaXY+XCIsXG5cdFx0c3RyZWFtTGlua05hbWU6IFwiTGlhaXNvbiBk4oCZw6ljb3VsZW1lbnRcIixcblx0XHRzdHJlYW1MaW5rU25pcDogXCJBdHRyaWJ1ZSBkZXMgdmFsZXVycyB1bmlxdWVzIGF1eCBzZWN0aW9ucyBkJ3VuIHLDqXNlYXUgbGluw6lhaXJlIHJhc3RlciBlbnRyZSBsZXMgaW50ZXJzZWN0aW9ucy5cIixcblx0XHRzdHJlYW1MaW5rRGVzYzogXCJMYSBmb25jdGlvbiBnbG9iYWxlIExpYWlzb24gZOKAmcOpY291bGVtZW50IGF0dHJpYnVlIGRlcyB2YWxldXJzIHVuaXF1ZXMgYXV4IHNlY3Rpb25zIGTigJl1biByw6lzZWF1IGxpbsOpYWlyZSByYXN0ZXIgZW50cmUgbGVzIGludGVyc2VjdGlvbnMuPGRpdj48YnIvPkxlcyBsaWFpc29ucyBzb250IGRlcyBzZWN0aW9ucyBk4oCZdW4gY2FuYWwgZOKAmcOpY291bGVtZW50IHJlbGlhbnQgZGV1eCBqb25jdGlvbnMgc3VjY2Vzc2l2ZXMsIHVuZSBqb25jdGlvbiBldCBs4oCZb3JpZmljZSBvdSB1bmUgam9uY3Rpb24gZXQgbGEgbGlnbmUgZGUgcGFydGFnZSBkZXMgZWF1eC4gRW4gaHlkcm9sb2dpZSwgY2VzIHNlZ21lbnRzIGRlIGNvdXJzIGTigJllYXUgc2Ugbm9tbWVudCBkZXMgc2VjdGlvbnMuIFVuZSBqb25jdGlvbiBlc3QgbGnDqWUgw6AgdW4gcG9pbnQgZOKAmcOpY291bGVtZW50IGV0IHBlcm1ldCBkZSBkw6lsaW1pdGVyIHVuIGJhc3NpbiB2ZXJzYW50IG91IHVuIHNvdXMtYmFzc2luIGRlIGRyYWluYWdlLjwvZGl2PlwiLFxuXHRcdHN0cmV0Y2hOYW1lOiBcIsOJdGlyZXJcIixcblx0XHRzdHJldGNoU25pcDogXCJBbcOpbGlvcmUgdW5lIGltYWdlIGVuIGFqdXN0YW50IGxhIHBsYWdlIGRlcyB2YWxldXJzIGFmZmljaMOpZXMuIENlbGEgbmUgbW9kaWZpZSBlbiByaWVuIGxlcyB2YWxldXJzIGRlIHBpeGVscyBzb3VzLWphY2VudGVzLiBTaSBsYSB2YWxldXIgZOKAmXVuIHBpeGVsIG5lIGZpZ3VyZSBwYXMgZGFucyBsYSBwbGFnZSBzcMOpY2lmacOpZSwgaWwgYXBwYXJhw650IGNvbW1lIGxhIHZhbGV1ciBtaW5pbWFsZSBvdSBtYXhpbWFsZS5cIixcblx0XHRzdHJldGNoRGVzYzogXCJMYSBmb25jdGlvbiDDiXRpcmVyIGFtw6lsaW9yZSB1bmUgaW1hZ2UgZW4gY2hhbmdlYW50IHNlcyBwcm9wcmnDqXTDqXMsIHRlbGxlcyBxdWUgbGEgbHVtaW5vc2l0w6ksIGxlIGNvbnRyYXN0ZSBldCBsYSB2YWxldXIgZ2FtbWEgcGFyIGzigJlpbnRlcm3DqWRpYWlyZSBkZSBkaWZmw6lyZW50cyB0eXBlcyBk4oCZw6l0aXJlbWVudC4gQ2V0dGUgZm9uY3Rpb24gdXRpbGlzZSBsZXMgc3RhdGlzdGlxdWVzIGRlcyByYXN0ZXJzIGRhbnMgbGUgamV1IGRlIGRvbm7DqWVzIG1vc2HDr3F1ZS4gUGFyIGNvbnPDqXF1ZW50LCBzaSB2b3VzIHV0aWxpc2V6IGNldHRlIGZvbmN0aW9uLCB2b3VzIGRldmV6IHZvdXMgYXNzdXJlciBxdWUgbGVzIHN0YXRpc3RpcXVlcyBvbnQgw6l0w6kgY2FsY3Vsw6llcy48ZGl2Pjxici8+TGUgdHlwZSBk4oCZw6l0aXJlbWVudCBkw6lmaW5pdCB1biDDqXRpcmVtZW50IGRlIGzigJloaXN0b2dyYW1tZSDDoCBhcHBsaXF1ZXIgYXV4IHJhc3RlcnMgcG91ciBhbcOpbGlvcmVyIGxldXIgYXBwYXJlbmNlLiBMJ8OpdGlyZW1lbnQgYW3DqWxpb3JlIGwnYXBwYXJlbmNlIGRlcyBkb25uw6llcyBlbiByw6lwYXJ0aXNzYW50IGxlcyB2YWxldXJzIGRlIHBpeGVsIGxlIGxvbmcgZCd1biBoaXN0b2dyYW1tZSDDoCBwYXJ0aXIgZGVzIHZhbGV1cnMgbWF4aW1hbGUgZXQgbWluaW1hbGUgZMOpZmluaWVzIHBhciBsZXVyIHByb2ZvbmRldXIgZGUgY291bGV1ci4gPC9kaXY+XCIsXG5cdFx0c3dhdGhOYW1lOiBcIkVudmVsb3BwZXJcIixcblx0XHRzd2F0aFNuaXA6IFwiSW50ZXJwb2xlIMOgIHBhcnRpciBkZSBncmlsbGVzIGlycsOpZ3VsacOocmVzIG91IGRlIGRvbm7DqWVzIGQnZW52ZWxvcHBlLlwiLFxuXHRcdHN3YXRoRGVzYzogXCJDZXJ0YWlucyBqZXV4IGRlIGRvbm7DqWVzIG5ldENERiBvdSBIREYgc3RvY2tlbnQgbGV1ciBnw6lvbG9jYWxpc2F0aW9uIHNvdXMgZm9ybWUgZGUgdGFibGVhdXggaXJyw6lndWxpw6hyZW1lbnQgZXNwYWPDqXMuIExvcnMgZGUgbOKAmWFqb3V0IGRlIGNlcyBqZXV4IGRlIGRvbm7DqWVzIMOgIHVuIGpldSBkZSBkb25uw6llcyBtb3Nhw69xdWUsIGxhIGZvbmN0aW9uIEVudmVsb3BwZXIgdXRpbGlzZSBsZXMgZG9ubsOpZXMgcXVhZHJpbGzDqWVzIGRlIGZhw6dvbiBpcnLDqWd1bGnDqHJlIHBvdXIgbGVzIHLDqcOpY2hhbnRpbGxvbm5lciBhZmluIHF1ZSBjaGFxdWUgcGl4ZWwgc29pdCBjYXJyw6kgZXQgZGUgdGFpbGxlIHVuaWZvcm1lLjxkaXY+PGJyLz5Mb3JzcXVlIHZvdXMgYWpvdXRleiBsZXMgdmFyaWFibGVzIGTigJl1biBmaWNoaWVyIG5ldENERiBvdSBIREYgw6AgdW4gamV1IGRlIGRvbm7DqWVzIG1vc2HDr3F1ZSwgbGEgZm9uY3Rpb24gdsOpcmlmaWUgYXV0b21hdGlxdWVtZW50IHNpIGxlcyBkb25uw6llcyBzb250IG9yZ2FuaXPDqWVzIGRlIGZhw6dvbiByw6lndWxpw6hyZS4gU2kgY2Ugbidlc3QgcGFzIGxlIGNhcywgbGEgZm9uY3Rpb24gRW52ZWxvcHBlciBlc3QgYXBwbGlxdcOpZSBhdXRvbWF0aXF1ZW1lbnQgcG91ciBjb252ZXJ0aXIgbGUgcmFzdGVyIGlycsOpZ3VsaWVyIGVuIHBvaW50cywgcHVpcyBlbiByYXN0ZXIgcXVhZHJpbGzDqSByw6lndWxpw6hyZW1lbnQuIFZvdXMgcG91dmV6IGNoYW5nZXIgbGEgbcOpdGhvZGUgZCdpbnRlcnBvbGF0aW9uIGV0IGxhIHRhaWxsZSBkZXMgY2VsbHVsZXMgdXRpbGlzw6llcyBkYW5zIGxhIGZvbmN0aW9uIHJhc3RlciBFbnZlbG9wcGVyLiBQb3VyIGxlcyBkb25uw6llcyByYXN0ZXIgcsOpZ3VsacOocmVtZW50IGVzcGFjw6llcywgYXVjdW5lIGludGVycG9sYXRpb24gbidlc3QgYXBwbGlxdcOpZSBldCBsZXMgZG9ubsOpZXMgc29udCBsdWVzIHRlbGxlcyBxdWVsbGVzLjwvZGl2PlwiLFxuXHRcdHRhbkhOYW1lOiBcIlRhbkhcIixcblx0XHR0YW5IU25pcDogXCJDYWxjdWxlIGxhIHRhbmdlbnRlIGh5cGVyYm9saXF1ZSBkZXMgY2VsbHVsZXMgZCd1biByYXN0ZXIuXCIsXG5cdFx0dGFuSERlc2M6IFwiTGEgZm9uY3Rpb24gY2FsY3VsZSBsYSB0YW5nZW50ZSBoeXBlcmJvbGlxdWUgZGVzIHBpeGVscyBkYW5zIHVuIHJhc3Rlci5cIixcblx0XHR0YW5OYW1lOiBcIlRhblwiLFxuXHRcdHRhblNuaXA6IFwiQ2FsY3VsZSBsYSB0YW5nZW50ZSBkZXMgY2VsbHVsZXMgZCd1biByYXN0ZXIuXCIsXG5cdFx0dGFuRGVzYzogXCJMYSBmb25jdGlvbiBjYWxjdWxlIGxhIHRhbmdlbnRlIGRlcyBwaXhlbHMgZGFucyB1biByYXN0ZXIuIFwiLFxuXHRcdHRhc3NlbGVkQ2FwTmFtZTogXCJUYXNzZWxlZCBDYXAgKEthdXRoLVRob21hcylcIixcblx0XHR0YXNzZWxlZENhcFNuaXA6IFwiQ2FsY3VsZSBsZXMgbml2ZWF1eCBkZSB2w6lnw6l0YXRpb24sIGTigJlodW1pZGl0w6kgZXQgZGUgbHVtaW5vc2l0w6kuIENldHRlIHRlY2huaXF1ZSBz4oCZYXBwdWllIHN1ciBkZXMgY29lZmZpY2llbnRzIHF1aSBkb2l2ZW50IMOqdHJlIGNhbGN1bMOpcyBzcMOpY2lmaXF1ZW1lbnQgcG91ciB1biBjYXB0ZXVyLlwiLFxuXHRcdHRhc3NlbGVkQ2FwRGVzYzogXCJMYSB0cmFuc2Zvcm1hdGlvbiBUYXNzZWxlZCBDYXAgKEthdXRoLVRob21hcykgZXN0IGNvbsOndWUgcG91ciBhbmFseXNlciBldCBhcHBhcmllciBsZXMgbW9kaWZpY2F0aW9ucyBsacOpZXMgYXUgZMOpdmVsb3BwZW1lbnQgdXJiYWluIGV0IMOgIGxhIHBow6lub23DqW5vbG9naWUgZGUgbGEgdsOpZ8OpdGF0aW9uIGTDqXRlY3TDqWVzIHBhciBkaWZmw6lyZW50cyBjYXB0ZXVycyBzYXRlbGxpdGFpcmVzLiBPbiBwYXJsZSBkZSB0cmFuc2Zvcm1hdGlvbiBUYXNzZWxlZCBDYXAgcG91ciBmYWlyZSByw6lmw6lyZW5jZSDDoCBsYSBmb3JtZSBxdWUgcHJlbmQgbGEgcsOpcGFydGl0aW9uIGdyYXBoaXF1ZSBkZXMgZG9ubsOpZXMuIENldHRlIHRyYW5zZm9ybWF0aW9uIGEgZm91cm5pIGxhIHJhaXNvbiBkJ8OqdHJlIGRlcyBtb3RpZnMgZMOpdGVjdMOpcyBkYW5zIGxlcyBkb25uw6llcyBMYW5kc2F0IE1TUyBkZXMgY2hhbXBzIGFncmljb2xlcywgZW4gdGFudCBxdWUgZm9uY3Rpb24gZHUgY3ljbGUgZGUgdmllIGQndW5lIGN1bHR1cmUuIExhIHRlbmRhbmNlIHByaW5jaXBhbGUgZXN0IGxhIHN1aXZhbnRlIDogbG9ycyBkZSBsYSBjcm9pc3NhbmNlIGTigJl1bmUgcGxhbnRlLCBkdSBzdGFkZSBkZSBncmFpbmUganVzcXXigJnDoCBzYSBtYXR1cml0w6ksIG9uIG5vdGUgdW5lIGF1Z21lbnRhdGlvbiBpbXBvcnRhbnRlIGRlcyBpbmZyYXJvdWdlcyBwcm9jaGVzIGV0IHVuZSBkaW1pbnV0aW9uIGRlIGxhIHLDqWZsZWN0YW5jZSBkZXMgaW5mcmFyb3VnZXMsIHNlbG9uIGxhIGNvdWxldXIgZHUgc29sLjxkaXY+PGJyLz5M4oCZdXRpbGl0w6kgZGUgY2V0dGUgdHJhbnNmb3JtYXRpb24gbmUgc2UgbGltaXRlIHBsdXMgw6AgbGEgc3VydmVpbGxhbmNlIGRlcyBjdWx0dXJlcyA7IG9uIGzigJlhcHBsaXF1ZSBkw6lzb3JtYWlzIMOgIGzigJlhbmFseXNlIGV0IMOgIGxhIGNhcnRvZ3JhcGhpZSBkZSBsYSB2w6lnw6l0YXRpb24gYWZpbiBxdeKAmWlsIHNvaXQgcG9zc2libGUgZGUgcHJlbmRyZSBlbiBjaGFyZ2UgZGl2ZXJzZXMgYXBwbGljYXRpb25zIChmb3Jlc3RlcmllLCBnZXN0aW9uIGRlcyBzaXRlcyBpbmR1c3RyaWVscywgY2FydG9ncmFwaGllIGV0IGdlc3Rpb24gZGUgbOKAmcOpY29zeXN0w6htZSwgY3LDqWF0aW9uIGTigJlpbnZlbnRhaXJlIGV0IHN1cnZlaWxsYW5jZSBkdSBzdG9ja2FnZSBkZSBjYXJib25lIGV0IGRlcyBjcsOpZGl0cywgZMOpdmVsb3BwZW1lbnQgdXJiYWluLCBldGMuKS4gRWxsZSBhIMOpZ2FsZW1lbnQgcGVybWlzIGTigJnDqXRlbmRyZSBsYSBwcmlzZSBlbiBjaGFyZ2UsIHF1aSBpbmNsdXQgTGFuZHNhdCBNU1MgYWluc2kgcXVlIGTigJlhdXRyZXMgc3lzdMOobWVzIHNhdGVsbGl0ZSBjb25udXMsIGNvbW1lIGxlcyBjYXB0ZXVycyBtdWx0aXNwZWN0cmF1eCBMYW5kc2F0IFRNLCBMYW5kc2F0IEVUTSssIExhbmRzYXQgOCwgSUtPTk9TLCBRdWlja0JpcmQsIFdvcmxkVmlldy0yIGV0IFJhcGlkRXllLjwvZGl2PlwiLFxuXHRcdHRpbWVzTmFtZTogXCJNdWx0aXBsaWVyXCIsXG5cdFx0dGltZXNTbmlwOiBcIk11bHRpcGxpZSBsZXMgdmFsZXVycyBkZSBkZXV4IHJhc3RlcnMgY2VsbHVsZSBwYXIgY2VsbHVsZS5cIixcblx0XHR0aW1lc0Rlc2M6IFwiTGEgZm9uY3Rpb24gTXVsdGlwbGljYXRpb24gbXVsdGlwbGllIGxhIHZhbGV1ciBkZSBkZXV4IHJhc3RlcnMsIHBpeGVsIHBhciBwaXhlbC5cIixcblx0XHR0cmFuc3Bvc2VCaXRzTmFtZTogXCJUcmFuc3Bvc2VyIGRlcyBiaXRzXCIsXG5cdFx0dHJhbnNwb3NlQml0c1NuaXA6IFwiRMOpY29tcHJlc3NlIGxlcyBiaXRzIGR1IHBpeGVsIGVuIGVudHLDqWUgZXQgbGVzIGFwcGFyaWUgw6AgZGVzIGJpdHMgc3DDqWNpZmnDqXMgZGFucyBsZSBwaXhlbCBlbiBzb3J0aWUuIEzigJlvYmplY3RpZiBkZSBjZXR0ZSBmb25jdGlvbiBlc3QgZGUgbWFuaXB1bGVyIGxlcyBiaXRzIHByb3ZlbmFudCBkZSBjZXJ0YWluZXMgZW50csOpZXMsIHRlbGxlcyBxdWUgbGVzIHByb2R1aXRzIGRlIGNhbmF1eCBkZSBxdWFsaXTDqSBMYW5kc2F0IDguXCIsXG5cdFx0dHJhbnNwb3NlQml0c0Rlc2M6IFwiTGEgZm9uY3Rpb24gVHJhbnNwb3NlciBkZXMgYml0cyBkw6ljb21wcmVzc2UgbGVzIGJpdHMgZHUgcGl4ZWwgZW4gZW50csOpZSBldCBsZXMgYXBwYXJpZSDDoCBkZXMgYml0cyBzcMOpY2lmacOpcyBkYW5zIGxlIHBpeGVsIGVuIHNvcnRpZS4gTCdvYmplY3RpZiBkZSBjZXR0ZSBmb25jdGlvbiBlc3QgZGUgbWFuaXB1bGVyIGxlcyBiaXRzIHByb3ZlbmFudCBkZSBjZXJ0YWluZSBlbnRyw6llcywgdGVsbGVzIHF1ZSBsZXMgcHJvZHVpdHMgZGUgY2FuYXV4IGRlIHF1YWxpdMOpIExhbmRzYXQgOC5cIixcblx0XHR1bml0Q29udmVyc2lvbk5hbWU6IFwiQ29udmVyc2lvbiBkZXMgdW5pdMOpc1wiLFxuXHRcdHVuaXRDb252ZXJzaW9uU25pcDogXCJNb2RpZmllIGxlcyB2YWxldXJzIGQndW5lIHVuaXTDqSBkZSBtZXN1cmUgZW4gdW5lIGF1dHJlLlwiLFxuXHRcdHVuaXRDb252ZXJzaW9uRGVzYzogXCJDZXR0ZSBmb25jdGlvbiBjb252ZXJ0aXQgbGVzIHBpeGVscyBk4oCZdW5lIHVuaXTDqSBlbiB1bmUgYXV0cmUuIEVsbGUgcHJlbmQgZW4gY2hhcmdlIGxhIGNvbnZlcnNpb24gZGUgZGlzdGFuY2VzLCB2aXRlc3NlcyBldCB0ZW1ww6lyYXR1cmVzLlwiLFxuXHRcdHZlY3RvckZpZWxkTmFtZTogXCJDaGFtcCB2ZWN0b3JpZWxcIixcblx0XHR2ZWN0b3JGaWVsZFNuaXA6IFwiQWZmaWNoZSBsZXMgamV1eCBkZSBkb25uw6llcyBhdmVjIGxhIGdyYW5kZXVyICh1KSBldCBsYSBkaXJlY3Rpb24gKHYpIHJlcHLDqXNlbnTDqWVzIHNvdXMgZm9ybWUgZGUgZmzDqGNoZXMsIG/DuSBsYSBncmFuZGV1ciBlc3QgcmVwcsOpc2VudMOpZSBwYXIgbGEgdGFpbGxlIGV0IGxhIGRpcmVjdGlvbiBwYXIgbCdhbmdsZSBkZSBsYSBmbMOoY2hlLlwiLFxuXHRcdHZlY3RvckZpZWxkRGVzYzogXCJMYSBmb25jdGlvbiBDaGFtcCB2ZWN0b3JpZWwgcGVybWV0IGTigJlpbnTDqWdyZXIgZXQgZGUgY29udmVydGlyIGRldXggcmFzdGVycyBkYW5zIHVuIHJhc3RlciDDoCBkZXV4IGNhbmF1eCBkb250IGxlIHR5cGUgZGUgZG9ubsOpZXMgZXN0IE1hZ25pdHVkZS1EaXJlY3Rpb24gb3UgVS1WLjxkaXY+PGJyLz5MYSB2YWxldXIgVSBlc3QgcGFyZm9pcyBhcHBlbMOpZSB2aXRlc3NlIHpvbmFsZSBldCBsYSB2YWxldXIgViwgdml0ZXNzZSBtw6lyaWRpb25hbGUuPC9kaXY+XCIsXG5cdFx0dmlld3NoZWQyTmFtZTogXCJWaWV3c2hlZCAoQ2hhbXAgZGUgdmlzaW9uKVwiLFxuXHRcdHZpZXdzaGVkMlNuaXA6IFwiRMOpdGVybWluZSBsZXMgZW1wbGFjZW1lbnRzIGRlIHN1cmZhY2VzIHJhc3RlciB2aXNpYmxlcyBwb3VyIHVuIGVuc2VtYmxlIGQnZW50aXTDqXMgZCdvYnNlcnZhdGlvbiwgw6AgbCdhaWRlIGRlIG3DqXRob2RlcyBnw6lvZMOpc2lxdWVzLlwiLFxuXHRcdHZpZXdzaGVkMkRlc2M6IFwiTGEgZm9uY3Rpb24gQ2hhbXAgZGUgdmlzaW9uIGTDqXRlcm1pbmUgbGVzIGVtcGxhY2VtZW50cyBkZXMgc3VyZmFjZXMgcmFzdGVyIHZpc2libGVzIHBvdXIgdW4gZW5zZW1ibGUgZOKAmWVudGl0w6lzIGTigJlvYnNlcnZhdGlvbiwgw6AgbOKAmWFpZGUgZGUgbcOpdGhvZGVzIGfDqW9kw6lzaXF1ZXMuPGRpdj48YnIvPkxhIHZpc2liaWxpdMOpIGR1IGNlbnRyZSBkZSBjaGFxdWUgcGl4ZWwgZXN0IGTDqXRlcm1pbsOpZSBwYXIgdW4gdGVzdCBkZSBsaWduZSBkZSB2aXPDqWUgZW50cmUgbGEgY2libGUgZXQgY2hhcXVlIHBvaW50IGTigJlvYnNlcnZhdGlvbi4gU2kgdW4gcG9pbnQgZCdvYnNlcnZhdGlvbiBwZXV0IHZvaXIgbGEgY2libGUgYXUgY2VudHJlIGR1IHBpeGVsLCBjZWx1aS1jaSBlc3QgY29uc2lkw6lyw6kgY29tbWUgdmlzaWJsZS4gQ2V0IG91dGlsIHRpZW50IHRvdWpvdXJzIGNvbXB0ZSBkZSBsYSBjb3VyYnVyZSBkZSBsYSBUZXJyZSBwb3VyIGTDqXRlcm1pbmVyIGxhIHZpc2liaWxpdMOpLjwvZGl2PlwiLFxuXHRcdHdhdGVyc2hlZE5hbWU6IFwiQmFzc2lucyB2ZXJzYW50c1wiLFxuXHRcdHdhdGVyc2hlZFNuaXA6IFwiRMOpdGVybWluZSBsYSBzdXJmYWNlIGRlIGNhcHRhdGlvbiBhdS1kZXNzdXMgZOKAmXVuIGVuc2VtYmxlIGRlIGNlbGx1bGVzIGRhbnMgdW4gcmFzdGVyLlwiLFxuXHRcdHdhdGVyc2hlZERlc2M6IFwiTGEgZm9uY3Rpb24gZ2xvYmFsZSBCYXNzaW5zIHZlcnNhbnRzIGTDqXRlcm1pbmUgbGEgc3VyZmFjZSBkZSBjYXB0YXRpb24gYXUtZGVzc3VzIGTigJl1biBlbnNlbWJsZSBkZSBjZWxsdWxlcyBkYW5zIHVuIHJhc3Rlci4gTGVzIGJhc3NpbnMgdmVyc2FudHMgc29udCBkw6lsaW1pdMOpcyDDoCBwYXJ0aXIgZOKAmXVuIHJhc3RlciBkZSBkaXJlY3Rpb24gZGUgZmx1eCBxdWkgaWRlbnRpZmllIGxhIGRpcmVjdGlvbiBkZSBmbHV4IMOgIHBhcnRpciBkZSBjaGFxdWUgcGl4ZWwuXCIsXG5cdFx0d2VpZ2h0ZWRPdmVybGF5TmFtZTogXCJTdXBlcnBvc2l0aW9uIHBvbmTDqXLDqWVcIixcblx0XHR3ZWlnaHRlZE92ZXJsYXlTbmlwOiBcIlN1cGVycG9zZSBwbHVzaWV1cnMgcmFzdGVycyBlbiB1dGlsaXNhbnQgdW5lIMOpY2hlbGxlIGRlIG1lc3VyZSBjb21tdW5lIGV0IGxlcyBwb25kw6hyZSBlbiBmb25jdGlvbiBkZSBsZXVyIGltcG9ydGFuY2UuXCIsXG5cdFx0d2VpZ2h0ZWRPdmVybGF5RGVzYzogXCJDZXR0ZSBmb25jdGlvbiBwZXJtZXQgZGUgc3VwZXJwb3NlciBwbHVzaWV1cnMgcmFzdGVycyDDoCBsJ2FpZGUgZOKAmXVuZSDDqWNoZWxsZSBkZSBtZXN1cmUgY29tbXVuZSBldCBkZSBsZXMgcG9uZMOpcmVyIHNlbG9uIGxldXIgaW1wb3J0YW5jZS5cIixcblx0XHR3ZWlnaHRlZFN1bU5hbWU6IFwiU29tbWUgcG9uZMOpcsOpZVwiLFxuXHRcdHdlaWdodGVkU3VtU25pcDogXCJQb25kw6hyZSBldCBham91dGUgdW5lIG1hdHJpY2UgZGUgcmFzdGVycywgY2VsbHVsZSBwYXIgY2VsbHVsZS5cIixcblx0XHR3ZWlnaHRlZFN1bURlc2M6IFwiTGEgZm9uY3Rpb24gU29tbWUgcG9uZMOpcsOpZSB2b3VzIHBlcm1ldCBkZSBzdXBlcnBvc2VyIHBsdXNpZXVycyByYXN0ZXJzLCBlbiBtdWx0aXBsaWFudCBjaGFjdW4gcGFyIHNhIHBvbmTDqXJhdGlvbiBkb25uw6llIGV0IGVuIGxlcyBhZGRpdGlvbm5hbnQuXCIsXG5cdFx0d2luZGNoaWxsTmFtZTogXCJUZW1ww6lyYXR1cmUgcmVzc2VudGllXCIsXG5cdFx0d2luZGNoaWxsU25pcDogXCJDb21iaW5lIGxhIHRlbXDDqXJhdHVyZSBkZSBsJ2FpciBhbWJpYW50IGV0IGxhIHZpdGVzc2UgZHUgdmVudCBwb3VyIGNhbGN1bGVyIGxlIGZhY3RldXIgZGUgdGVtcMOpcmF0dXJlIHJlc3NlbnRpZS5cIixcblx0XHR3aW5kY2hpbGxEZXNjOiBcIkxhIGZvbmN0aW9uIGRlIHRlbXDDqXJhdHVyZSByZXNzZW50aWUgZXN0IHV0aWxlIHBvdXIgaWRlbnRpZmllciBsZXMgY29uZGl0aW9ucyBoaXZlcm5hbGVzIGRhbmdlcmV1c2VzIHF1aSwgc2Vsb24gbGEgZHVyw6llIGTigJlleHBvc2l0aW9uIGF1eCDDqWzDqW1lbnRzLCBwZXV2ZW50IGVudHJhw65uZXIgZGVzIGVuZ2VsdXJlcyBvdSBtw6ptZSB1bmUgaHlwb3RoZXJtaWUuIExhIHRlbXDDqXJhdHVyZSByZXNzZW50aWUgbWVzdXJlIGxlIG5pdmVhdSBkZSBmcm9pZCByZXNzZW50aSBwYXIgdW4gaW5kaXZpZHUgbG9yc3F1ZSBsZSB2ZW50IGVzdCBwcmlzIGVuIGNvbXB0ZSBhdmVjIGRlcyB0ZW1ww6lyYXR1cmVzIGTDqWrDoCBiYXNzZXMuIFBsdXMgbGEgdml0ZXNzZSBkdSB2ZW50IGVzdCDDqWxldsOpZSwgcGx1cyBsYSBjaGFsZXVyIGNvcnBvcmVsbGUgYmFpc3NlIHJhcGlkZW1lbnQgZXQgcGx1cyBsZSBmcm9pZCBlc3QgcmVzc2VudGkuXCIsXG5cdFx0em9uYWxSZW1hcE5hbWU6IFwiQ2xhc3NpZmljYXRpb24gem9uYWxlXCIsXG5cdFx0em9uYWxSZW1hcFNuaXA6IFwiQ2xhc3NleiBsZXMgcGl4ZWxzIGRhbnMgdW4gcmFzdGVyIGVuIGZvbmN0aW9uIGRlcyB6b25lcyBkw6lmaW5pZXMgZGFucyB1biBhdXRyZSByYXN0ZXIgZXQgZGUgbCdhcHBhcmllbWVudCBkZXMgdmFsZXVycyBkw6lwZW5kYW50IGRlcyB6b25lcywgcXVpIGVzdCBkw6lmaW5pIGRhbnMgdW5lIHRhYmxlLlwiLFxuXHRcdHpvbmFsUmVtYXBEZXNjOiBcIkNldHRlIGZvbmN0aW9uIHBlcm1ldCBkZSBjbGFzc2VyIGxlcyBwaXhlbHMgZGFucyB1biByYXN0ZXIgZW4gZm9uY3Rpb24gZGVzIHpvbmVzIGTDqWZpbmllcyBkYW5zIHVuIGF1dHJlIHJhc3RlciBldCBkZSBsJ2FwcGFyaWVtZW50IGRlcyB2YWxldXJzIGTDqXBlbmRhbnQgZGVzIHpvbmVzLCBxdWkgZXN0IGTDqWZpbmkgZGFucyB1bmUgdGFibGUuXCIsXG5cdFx0em9uYWxTdGF0aXN0aWNzTmFtZTogXCJTdGF0aXN0aXF1ZXMgem9uYWxlc1wiLFxuXHRcdHpvbmFsU3RhdGlzdGljc1NuaXA6IFwiQ2FsY3VsZSBsZXMgc3RhdGlzdGlxdWVzIGRlcyB2YWxldXJzIGTigJl1biByYXN0ZXIgZGFucyBjaGFxdWUgem9uZSBk4oCZdW4gYXV0cmUgamV1IGRlIGRvbm7DqWVzLlwiLFxuXHRcdHpvbmFsU3RhdGlzdGljc0Rlc2M6IFwiTGEgZm9uY3Rpb24gY2FsY3VsZSBkZXMgc3RhdGlzdGlxdWVzIHN1ciBsZXMgdmFsZXVycyBk4oCZdW4gcmFzdGVyIGRhbnMgbGVzIHpvbmVzIGTigJl1biBhdXRyZSBqZXUgZGUgZG9ubsOpZXMuIFVuZSB6b25lIGVzdCBkw6lmaW5pZSBjb21tZSBs4oCZZW5zZW1ibGUgZGVzIHN1cmZhY2VzIGVuIGVudHLDqWUgYXlhbnQgbGEgbcOqbWUgdmFsZXVyLiBDZXMgc3VyZmFjZXMgbmUgc29udCBwYXMgbsOpY2Vzc2FpcmVtZW50IGNvbnRpZ3XDq3MuIExvcnNxdWUgbGEgem9uZSBldCBsYSB2YWxldXIgZW4gZW50csOpZSBzb250IHRvdXRlcyBsZXMgZGV1eCBkZXMgcmFzdGVycyBkZSBtw6ptZSByw6lzb2x1dGlvbiwgZWxsZXMgc29udCB1dGlsaXPDqWVzIGRpcmVjdGVtZW50LiBTaSBsZXMgcsOpc29sdXRpb25zIHNvbnQgZGlmZsOpcmVudGVzLCB1biByw6nDqWNoYW50aWxsb25uYWdlIGludGVybmUgZXN0IGFwcGxpcXXDqSBwb3VyIGxlcyBmYWlyZSBjb3JyZXNwb25kcmUgYXZhbnQgcXVlIGwnb3DDqXJhdGlvbiB6b25hbGUgc29pdCBlZmZlY3R1w6llLlwiLFxuXHRcdGZsb3dMZW5ndGhOYW1lOiBcIkxvbmd1ZXVyIGRlIGwnw6ljb3VsZW1lbnRcIixcblx0XHRmbG93TGVuZ3RoU25pcDogXCJQZXJtZXQgZGUgY2FsY3VsZXIgbGEgZGlzdGFuY2UgZW4gYW1vbnQgb3UgZW4gYXZhbCwgb3UgbGEgZGlzdGFuY2UgcG9uZMOpcsOpZSwgbGUgbG9uZyBkdSBjaGVtaW4gZGUgZmx1eCBwb3VyIGNoYXF1ZSBjZWxsdWxlLlwiLFxuXHRcdGZsb3dMZW5ndGhEZXNjOiBcIklsIHPigJlhZ2l0IGTigJl1bmUgZm9uY3Rpb24gcmFzdGVyIGdsb2JhbGUuIENldHRlIGZvbmN0aW9uIGNyw6llIHVuZSBjb3VjaGUgcmFzdGVyIGRlIGRpc3RhbmNlIGVuIGFtb250IG91IGVuIGF2YWwsIG91IGRlIGRpc3RhbmNlIHBvbmTDqXLDqWUsIGxlIGxvbmcgZHUgY2hlbWluIGRlIGZsdXggcG91ciBjaGFxdWUgY2VsbHVsZS48ZGl2Pjxici8+TGEgZm9uY3Rpb24gTG9uZ3VldXIgZOKAmcOpY291bGVtZW50IHBlcm1ldCBlc3NlbnRpZWxsZW1lbnQgZGUgY2FsY3VsZXIgbGEgbG9uZ3VldXIgZHUgY2hlbWluIGRlIGZsdXggZGFucyB1biBiYXNzaW4gZG9ubsOpLiBDZXR0ZSBtZXN1cmUgcGVybWV0IHNvdXZlbnQgZGUgY2FsY3VsZXIgbGUgdGVtcHMgZGUgY29uY2VudHJhdGlvbiBkJ3VuIGJhc3Npbi4gQ2VjaSBlc3QgZWZmZWN0dcOpIMOgIGzigJlhaWRlIGRlIGzigJlvcHRpb24gVXBzdHJlYW0gKEVuIGFtb250KS4gVm91cyBwb3V2ZXogw6lnYWxlbWVudCBlbXBsb3llciBjZXR0ZSBmb25jdGlvbiBwb3VyIGNyw6llciBkZXMgZGlhZ3JhbW1lcyByZXByw6lzZW50YW50IGxlcyBkaXN0YW5jZXMtc3VyZmFjZXMgcmVsYXRpdmVzIGF1eCBwcsOpY2lwaXRhdGlvbnMgZXQgYXV4IMOpY291bGVtZW50cyBwcsOpdmlzaW9ubmVscywgw6AgbOKAmWFpZGUgZOKAmXVuIHJhc3RlciBkZSBwb25kw6lyYXRpb24gc291cyBsYSBmb3JtZSBk4oCZdW5lIGltcMOpZGFuY2UgZW4gcmFwcG9ydCBhdmVjIGxlIG1vdXZlbWVudCBlbiBhdmFsLjwvZGl2PlwiLFxuXHRcdHN0cmVhbU9yZGVyTmFtZTogXCJPcmRyZSBkJ8OpY291bGVtZW50XCIsXG5cdFx0c3RyZWFtT3JkZXJTbmlwOiBcIkF0dHJpYnVlIHVuIG9yZHJlIG51bcOpcmlxdWUgYXV4IHNlZ21lbnRzIGTigJl1biByYXN0ZXIgcmVwcsOpc2VudGFudCBsZXMgYnJhbmNoZXMgZOKAmXVuIHLDqXNlYXUgbGluw6lhaXJlXCIsXG5cdFx0c3RyZWFtT3JkZXJEZXNjOiBcIklsIHPigJlhZ2l0IGTigJl1bmUgZm9uY3Rpb24gcmFzdGVyIGdsb2JhbGUuIENldHRlIGZvbmN0aW9uIGNyw6llIHVuZSBjb3VjaGUgcmFzdGVyIHF1aSBhdHRyaWJ1ZSB1biBvcmRyZSBudW3DqXJpcXVlIGF1eCBzZWdtZW50cyBk4oCZdW4gcmFzdGVyIHJlcHLDqXNlbnRhbnQgbGVzIGJyYW5jaGVzIGTigJl1biByw6lzZWF1IGxpbsOpYWlyZS48ZGl2Pjxici8+TGEgc29ydGllIGRlIGzigJlvdXRpbCBPcmRyZSBk4oCZw6ljb3VsZW1lbnQgc2VyYSBkZSBtZWlsbGV1cmUgcXVhbGl0w6kgc2kgbGEgY291Y2hlIGRlIHJhc3RlciBk4oCZw6ljb3VsZW1lbnQgZW4gZW50csOpZSBldCBsYSBjb3VjaGUgZGUgcmFzdGVyIGRlIGRpcmVjdGlvbiBkZSBmbHV4IGVuIGVudHLDqWUgc29udCBkw6lyaXbDqWVzIGRlIGxhIG3Dqm1lIHN1cmZhY2UuIFNpIGxlIHJhc3RlciBkJ8OpY291bGVtZW50IGVzdCBkw6lyaXbDqSBkJ3VuIGpldSBkZSBkb25uw6llcyBkZSBmbHV4IHJhc3Rlcmlzw6ksIGxhIHNvcnRpZSBwZXV0IG5lIHBhcyDDqnRyZSB1dGlsaXNhYmxlIGR1IGZhaXQgcXVlLCBjZWxsdWxlIHBhciBjZWxsdWxlLCBsYSBkaXJlY3Rpb24gbmUgY29ycmVzcG9uZHJhIHBhcyDDoCBsYSBsb2NhbGlzYXRpb24gZGVzIGNlbGx1bGVzIGRlIGZsdXguIExlcyByw6lzdWx0YXRzIG9idGVudXMgYXZlYyBsYSBmb25jdGlvbiBBY2N1bXVsYXRpb24gZGUgZmx1eCBwZXV2ZW50IMOqdHJlIHV0aWxpc8OpcyBwb3VyIGNyw6llciB1biByYXN0ZXIgZGUgcsOpc2VhdSBoeWRyb2dyYXBoaXF1ZSBlbiBmaXhhbnQgdW4gc2V1aWwgcG91ciBzw6lsZWN0aW9ubmVyIGxlcyBjZWxsdWxlcyBhdmVjIHVuZSBhY2N1bXVsYXRpb24gZGUgZmx1eCDDqWxldsOpZS4gUGFyIGV4ZW1wbGUsIGxlcyBjZWxsdWxlcyBkYW5zIGxlc3F1ZWxsZXMgcGx1cyBkZSAxMDAgY2VsbHVsZXMgc+KAmcOpY291bGVudCBzb250IHV0aWxpc8OpZXMgcG91ciBkw6lmaW5pciBsZSByw6lzZWF1IGh5ZHJvZ3JhcGhpcXVlLiBVdGlsaXNleiBsYSBmb25jdGlvbiBDb24gb3UgU2V0TnVsbCBwb3VyIGNyw6llciB1biByYXN0ZXIgZGUgcsOpc2VhdSBoeWRyb2dyYXBoaXF1ZSBvw7kgZGVzIHZhbGV1cnMgZOKAmWFjY3VtdWxhdGlvbiBkZSBmbHV4IGRlIDEwMCBvdSBwbHVzIHBhc3NlbnQgw6AgMSwgZXQgbGUgcmVzdGUgZXN0IG1pcyDDoCBs4oCZYXJyacOocmUtcGxhbiAoTm9EYXRhKS4gTGUgcsOpc2VhdSBoeWRyb2dyYXBoaXF1ZSBvYnRlbnUgcGV1dCDDqnRyZSB1dGlsaXPDqSBkYW5zIGzigJlvdXRpbCBPcmRyZSBk4oCZw6ljb3VsZW1lbnQuIENldHRlIGZvbmN0aW9uIHByZW5kIHVuaXF1ZW1lbnQgZW4gY2hhcmdlIHVuZSBjb3VjaGUgcmFzdGVyIGRlIGRpcmVjdGlvbiBkZSBmbHV4IGVuIGVudHLDqWUgRDguIExlcyBkaXJlY3Rpb25zIGRlIGZsdXggRDggcGV1dmVudCDDqnRyZSBjcsOpw6llcyDDoCBs4oCZYWlkZSBkZSBsYSBmb25jdGlvbiBEaXJlY3Rpb24gZGUgZmx1eCBldCBleMOpY3V0w6llcyBhdmVjIGxhIGRpcmVjdGlvbiBkZSBmbHV4IHBhciBkw6lmYXV0IGRlIHR5cGUgRDguPC9kaXY+XCIsXG5cdFx0c25hcFBvdXJQb2ludE5hbWU6IFwiQ2FwdHVyZSBkZXMgcG9pbnRzIGTigJnDqWNvdWxlbWVudFwiLFxuXHRcdHNuYXBQb3VyUG9pbnRTbmlwOiBcIkNhcHR1cmUgbGVzIHBvaW50cyBk4oCZw6ljb3VsZW1lbnQgZGFucyBsYSBjZWxsdWxlIGTigJlhY2N1bXVsYXRpb24gZGUgZmx1eCBsYSBwbHVzIMOpbGV2w6llLCBzZWxvbiB1bmUgZGlzdGFuY2UgZG9ubsOpZVwiLFxuXHRcdHNuYXBQb3VyUG9pbnREZXNjOiBcIklsIHPigJlhZ2l0IGTigJl1bmUgZm9uY3Rpb24gcmFzdGVyIGdsb2JhbGUuIENldHRlIGZvbmN0aW9uIGNhcHR1cmUgbGVzIHBvaW50cyBk4oCZw6ljb3VsZW1lbnQgZGFucyBsYSBjZWxsdWxlIGTigJlhY2N1bXVsYXRpb24gZGUgZmx1eCBsYSBwbHVzIMOpbGV2w6llLCBzZWxvbiB1bmUgZGlzdGFuY2UgZG9ubsOpZS48ZGl2Pjxici8+TOKAmW91dGlsIENhcHR1cmUgZGVzIHBvaW50cyBk4oCZw6ljb3VsZW1lbnQgcGVybWV0IGTigJnDqXRhYmxpciB1bmUgc8OpbGVjdGlvbiBkZSBwb2ludHMgZOKAmWFjY3VtdWxhdGlvbiBkZSBmbHV4IMOpbGV2w6llIGxvcnNxdWUgdm91cyBkw6lsaW1pdGV6IGRlcyBiYXNzaW5zIGRlIGRyYWluYWdlIMOgIGzigJlhaWRlIGRlIGzigJlvdXRpbCBCYXNzaW5zIHZlcnNhbnRzLiBM4oCZb3V0aWwgQ2FwdHVyZSBkZXMgcG9pbnRzIGTigJnDqWNvdWxlbWVudCByZWNoZXJjaGUsIGF1IHNlaW4gZOKAmXVuIHDDqXJpbcOodHJlIGRlIGNhcHR1cmUgYXV0b3VyIGRlcyBwb2ludHMgZOKAmcOpY291bGVtZW50IHNww6ljaWZpw6lzLCBsYSBjZWxsdWxlIHF1aSBwcsOpc2VudGUgbOKAmWFjY3VtdWxhdGlvbiBkZSBmbHV4IGxhIHBsdXMgw6lsZXbDqWUgZXQgZMOpcGxhY2UgbGUgcG9pbnQgZOKAmcOpY291bGVtZW50IMOgIGNldCBlbmRyb2l0LiBMYSBzb3J0aWUgZXN0IHVuZSBjb3VjaGUgcmFzdGVyIGTigJllbnRpZXJzIGxvcnNxdWUgbGVzIGxvY2FsaXNhdGlvbnMgZGUgcG9pbnQgZOKAmcOpY291bGVtZW50IG9yaWdpbmFsZXMgb250IMOpdMOpIGFjY3JvY2jDqWVzIGF1eCBsaWV1eCBk4oCZYWNjdW11bGF0aW9uIGRlIGZsdXggbGEgcGx1cyDDqWxldsOpZS48L2Rpdj5cIixcblx0XHRzaW5rTmFtZTogXCJDdXZldHRlc1wiLFxuXHRcdHNpbmtTbmlwOiBcIkNyw6llIHVuIHJhc3RlciBpZGVudGlmaWFudCB0b3V0ZXMgbGVzIGN1dmV0dGVzIG91IHpvbmVzIGRlIGRyYWluYWdlIGludGVybmVcIixcblx0XHRzaW5rRGVzYzogXCJJbCBz4oCZYWdpdCBk4oCZdW5lIGZvbmN0aW9uIHJhc3RlciBnbG9iYWxlLiBDZXR0ZSBmb25jdGlvbiBjcsOpZSB1bmUgY291Y2hlIHJhc3RlciBpZGVudGlmaWFudCB0b3V0ZXMgbGVzIGN1dmV0dGVzIG91IHpvbmVzIGRlIGRyYWluYWdlIGludGVybmUuIFVuZSBjdXZldHRlIGVzdCB1bmUgY2VsbHVsZSBvdSB1biBlbnNlbWJsZSBkZSBjZWxsdWxlcyBsaW1pdHJvcGhlcyBkb250IGxhIGRpcmVjdGlvbiBkZSBmbHV4IG5lIHBldXQgcGFzIHNlIHZvaXIgYXR0cmlidWVyIGwndW5lIGRlcyBodWl0IHZhbGV1cnMgdmFsaWRlcyBkYW5zIHVuIHJhc3RlciBkZSBkaXJlY3Rpb24gZGUgZmx1eC4gQ2VsYSBwZXV0IHN1cnZlbmlyIGxvcnNxdWUgdG91dGVzIGxlcyBjZWxsdWxlcyB2b2lzaW5lcyBzb250IHBsdXMgw6lsZXbDqWVzIHF1ZSBsYSBjZWxsdWxlIGRlIHRyYWl0ZW1lbnQgb3UgbG9yc3F1ZSBkZXV4IGNlbGx1bGVzIHMnw6ljb3VsZW50IGVuIGJvdWNsZSBs4oCZdW5lIGRhbnMgbOKAmWF1dHJlLjxkaXY+PGJyLz5MYSBmb25jdGlvbiBDdXZldHRlIHByZW5kIHVuaXF1ZW1lbnQgZW4gY2hhcmdlIHVuZSBjb3VjaGUgcmFzdGVyIGRlIGRpcmVjdGlvbiBkZSBmbHV4IGVuIGVudHLDqWUgRDguIExlcyBkaXJlY3Rpb25zIGRlIGZsdXggRDggcGV1dmVudCDDqnRyZSBjcsOpw6llcyDDoCBs4oCZYWlkZSBkZSBsYSBmb25jdGlvbiBEaXJlY3Rpb24gZGUgZmx1eCBldCBleMOpY3V0w6llcyBhdmVjIGxlIHR5cGUgZGUgZGlyZWN0aW9uIGRlIGZsdXggcGFyIGTDqWZhdXQgRDguIExhIHNvcnRpZSBkZSBsYSBmb25jdGlvbiBDdXZldHRlIGVzdCB1biByYXN0ZXIgZOKAmWVudGllcnMgZGFucyBsZXF1ZWwgY2hhcXVlIGN1dmV0dGUgc2Ugdm9pdCBhdHRyaWJ1ZXIgdW5lIHZhbGV1ciB1bmlxdWUuIENlcyB2YWxldXJzIHVuaXF1ZXMgb250IHVuZSBwbGFnZSBjb21wcmlzZSBlbnRyZSB1biBldCBsZSBub21icmUgdG90YWwgZGUgY3V2ZXR0ZXMuIFBhciBleGVtcGxlLCBzaSBsZSBub21icmUgdG90YWwgZGUgY3V2ZXR0ZXMgZXN0IDEgMDAwLCBsYSBwbGFnZSBkZSB2YWxldXJzIHVuaXF1ZXMgZXN0IGNvbXByaXNlIGVudHJlIDEgZXQgMSAwMDAuPC9kaXY+XCIsXG5cdFx0YWdncmVnYXRlTmFtZTogXCJBZ3LDqWdlclwiLFxuXHRcdGFnZ3JlZ2F0ZVNuaXA6IFwiR8OpbsOocmUgdW5lIHZlcnNpb24gZHUgcmFzdGVyIMOgIHVuZSByw6lzb2x1dGlvbiBpbmbDqXJpZXVyZS5cIixcblx0XHRhZ2dyZWdhdGVEZXNjOiBcIkzigJlvdXRpbCBBZ3LDqWdlciByw6nDqWNoYW50aWxsb25uZSB1biByYXN0ZXIgZW4gZW50csOpZSBhdmVjIHVuZSByw6lzb2x1dGlvbiBwbHVzIGdyb3NzacOocmUgc+KAmWFwcHV5YW50IHN1ciB1bmUgc3RyYXTDqWdpZSBk4oCZYWdyw6lnYXRpb24gc3DDqWNpZmlxdWUuIENoYXF1ZSBjZWxsdWxlIGVuIHNvcnRpZSBjb250aWVudCBsYSBzb21tZSwgbGUgbWluaW11bSwgbGUgbWF4aW11bSwgbGEgbW95ZW5uZSBvdSBsYSBtw6lkaWFuZSBkZXMgY2VsbHVsZXMgZW4gZW50csOpZSBxdWkgZmlndXJlbnQgZGFucyBsJ8OpdGVuZHVlIGRlIGNldHRlIGNlbGx1bGUuPGRpdj48YnIvPlZvdXMgcG91dmV6IHNww6ljaWZpZXogbGUgZmFjdGV1ciBkZSBtdWx0aXBsaWNhdGlvbiBkZSBsYSB0YWlsbGUgZGUgY2VsbHVsZSBkdSByYXN0ZXIgZW4gZW50csOpZS4gUGFyIGV4ZW1wbGUsIHVuZSB2YWxldXIgZGUgZmFjdGV1ciBkZSBjZWxsdWxlIGRlIDMgZW50cmHDrm5lIHVuZSB0YWlsbGUgZGUgY2VsbHVsZSBlbiBzb3J0aWUgdHJvaXMgZm9pcyBzdXDDqXJpZXVyZSDDoCBjZWxsZSBkdSByYXN0ZXIgZW4gZW50csOpZS4gVm91cyBwb3V2ZXogZMOpZmluaXIgbGEgbWFuacOocmUgZGUgdHJhaXRlciBs4oCZw6l0ZW5kdWUgZGUgbGEgc29ydGllIHNpIGxlIG5vbWJyZSBkZSBsaWduZXMgb3UgZGUgY29sb25uZXMgZW4gZW50csOpZSBu4oCZZXN0IHBhcyB1biBtdWx0aXBsZSBkdSBmYWN0ZXVyIGRlIGNlbGx1bGUuIFBhciBkw6lmYXV0LCBsZXMgbGltaXRlcyBzdXDDqXJpZXVyZSBldCBkcm9pdGUgc2Vyb250IHJlcG91c3PDqWVzIHBvdXIgY291dnJpciB1bmUgw6l0ZW5kdWUgc3BhdGlhbGUgcGx1cyBsYXJnZSBxdWUgY2VsbGUgZHUgcmFzdGVyIGVuIGVudHLDqWUgZGUgc29ydGUgcXVlIHRvdXRlcyBsZXMgY2VsbHVsZXMgZW4gZW50csOpZSBzb2llbnQgdHJhaXTDqWVzLiBMZXMgbGltaXRlcyBzdXDDqXJpZXVyZSBldCBkZSBkcm9pdGUgcGV1dmVudCDDqWdhbGVtZW50IMOqdHJlIHJhcHByb2Now6llcyBwb3VyIGNvdXZyaXIgdW5lIMOpdGVuZHVlIHBsdXMgcsOpZHVpdGUsIGRlIHNvcnRlIHF1ZSBsZSBub21icmUgZGUgbGlnbmVzIG91IGRlIGNvbG9ubmVzIHRyYWl0w6llcyBjb3JyZXNwb25kZSBleGFjdGVtZW50IMOgIHVuIG11bHRpcGxlIGR1IGZhY3RldXIgZGUgY2VsbHVsZS4gVm91cyBwb3V2ZXogZMOpZmluaXIgbGEgbWFuacOocmUgZG9udCBsZXMgY2VsbHVsZXMgTm9EYXRhIGRvaXZlbnQgw6p0cmUgdHJhaXTDqWVzIHBhciBsZSBjYWxjdWwgZOKAmWFncsOpZ2F0aW9uLiBMZSBtw6ljYW5pc21lIHBhciBkw6lmYXV0IGVzdCBsZSBzdWl2YW50IDogbGVzIGNlbGx1bGVzIE5vRGF0YSBlbiBlbnRyw6llIGNvbXByaXNlcyBkYW5zIGzigJnDqXRlbmR1ZSBzcGF0aWFsZSBk4oCZdW5lIGNlbGx1bGUgcGx1cyBncmFuZGUgZGFucyBsZSByYXN0ZXIgZW4gc29ydGllIHNlcm9udCBpZ25vcsOpZXMgbG9ycyBkZSBsYSBkw6l0ZXJtaW5hdGlvbiBkZSBsYSB2YWxldXIgZGUgY2V0dGUgY2VsbHVsZSBlbiBzb3J0aWUuIFZvdXMgcG91dmV6IMOpZ2FsZW1lbnQgcHLDqWNpc2VyIHF1ZSBzaSB1bmUgc2V1bGUgY2VsbHVsZSBOb0RhdGEgZXN0IGluY2x1c2UgZGFucyBs4oCZw6l0ZW5kdWUgc3BhdGlhbGUgZOKAmXVuZSBjZWxsdWxlIGVuIHNvcnRpZSwgbGEgdmFsZXVyIGRlIGNldHRlIGNlbGx1bGUgZGFucyBsZSByYXN0ZXIgZW4gc29ydGllIGVzdCBOb0RhdGEuPC9kaXY+XCIsXG5cdFx0Y2NkY05hbWU6IFwiQW5hbHlzZSBDQ0RDXCIsXG5cdFx0Y2NkY1NuaXA6IFwiw4l2YWx1ZSBsZXMgbW9kaWZpY2F0aW9ucyBkYW5zIGxlcyB2YWxldXJzIGRlIHBpeGVscyBhdSBmaWwgZHUgdGVtcHMgw6AgbOKAmWFpZGUgZGUgbOKAmWFsZ29yaXRobWUgQ0NEQyAoQ29udGludW91cyBDaGFuZ2UgRGV0ZWN0aW9uIGFuZCBDbGFzc2lmaWNhdGlvbikgZXQgZ8OpbsOocmUgbGVzIHLDqXN1bHRhdHMgZHUgbW9kw6hsZS5cIixcblx0XHRjY2RjRGVzYzogXCJMYSBmb25jdGlvbiBDQ0RDIMOpdmFsdWUgbGVzIG1vZGlmaWNhdGlvbnMgZGFucyBsZXMgdmFsZXVycyBkZSBwaXhlbHMgYXUgZmlsIGR1IHRlbXBzIMOgIGzigJlhaWRlIGRlIGzigJlhbGdvcml0aG1lIENDREMgKENvbnRpbnVvdXMgQ2hhbmdlIERldGVjdGlvbiBhbmQgQ2xhc3NpZmljYXRpb24pIGV0IGfDqW7DqHJlIHVuIHJhc3RlciBtdWx0aWRpbWVuc2lvbm5lbCBjb250ZW5hbnQgbGVzIHLDqXN1bHRhdHMgZHUgbW9kw6hsZS4gRWxsZSBlc3QgcHJpc2UgZW4gY2hhcmdlIHVuaXF1ZW1lbnQgYXZlYyBsYSBmb25jdGlvbiBkZSBkw6l0ZWN0aW9uIGRlcyBtb2RpZmljYXRpb25zIMOgIGzigJlhaWRlIGR1IHJhc3RlciBk4oCZYW5hbHlzZSBkZXMgY2hhbmdlbWVudHMgZGFucyB1biBtb2TDqGxlIGRlIGZvbmN0aW9uIHJhc3Rlci4gUG91ciBwcm9kdWlyZSB1biByYXN0ZXIgZW4gc29ydGllLCBjb25uZWN0ZXogbGEgZm9uY3Rpb24gZOKAmWFuYWx5c2UgQ0NEQyDDoCBsYSBmb25jdGlvbiBkZSBkw6l0ZWN0aW9uIGRlcyBtb2RpZmljYXRpb25zIMOgIGzigJlhaWRlIGRlIGzigJlhbmFseXNlIGRlcyBjaGFuZ2VtZW50cywgZW5yZWdpc3RyZXogdW4gbW9kw6hsZSBkZSBmb25jdGlvbiByYXN0ZXIgZXQgZXjDqWN1dGV6IGzigJlhbmFseXNlIHJhc3RlciBhdmVjIGxlIG1vZMOobGUgZGUgZm9uY3Rpb24uPGRpdj48YnIvPkNldHRlIGZvbmN0aW9uIHV0aWxpc2UgbOKAmWFsZ29yaXRobWUgQ0NEQyAoQ29udGludW91cyBDaGFuZ2UgRGV0ZWN0aW9uIGFuZCBDbGFzc2lmaWNhdGlvbikgcG91ciDDqXZhbHVlciBsZXMgbW9kaWZpY2F0aW9ucyBkYW5zIGxlcyB2YWxldXJzIGRlIHBpeGVscyBhdSBmaWwgZHUgdGVtcHMgcG91ciB1bmUgcGlsZSBk4oCZaW1hZ2VzLiBEYW5zIHVuZSBzw6lyaWUgY2hyb25vbG9naXF1ZSBk4oCZaW1hZ2VzIG9wdGlxdWVzIG91IGTDqXJpdsOpZXMgKE5EVkksIHBhciBleGVtcGxlKSwgbGVzIHZhbGV1cnMgZGUgcGl4ZWxzIHBldXZlbnQgZmx1Y3R1ZXIgcG91ciBkaXZlcnNlcyByYWlzb25zIDogMS4gTW9kaWZpY2F0aW9ucyBzYWlzb25uacOocmVzIC0tIExlcyBtb2RpZmljYXRpb25zIGRlcyB2YWxldXJzIGRlIHBpeGVscyByZWZsw6h0ZW50IGxlcyBtb2RpZmljYXRpb25zIGRlIGxhIHbDqWfDqXRhdGlvbiBsacOpZXMgw6AgbGEgdmFyaWFiaWxpdMOpIHNhaXNvbm5pw6hyZSBkZXMgdGVtcMOpcmF0dXJlcyBldCBkZXMgcHLDqWNpcGl0YXRpb25zLiBEYW5zIGzigJlow6ltaXNwaMOocmUgTm9yZCwgcGFyIGV4ZW1wbGUsIGlsIGZhdXQgc+KAmWF0dGVuZHJlIMOgIG9ic2VydmVyIHVuZSBkZW5zaXTDqSBkZSB2w6lnw6l0YXRpb24gdmVydGUgcGx1cyBmb3J0ZSBwZW5kYW50IGzigJnDqXTDqSBwYXIgcmFwcG9ydCDDoCBs4oCZaGl2ZXIgOyAyLiBNb2RpZmljYXRpb25zIGdyYWR1ZWxsZXMgLS0gTGVzIG1vZGlmaWNhdGlvbnMgZGVzIHZhbGV1cnMgZGUgcGl4ZWxzIHJlZmzDqHRlbnQgbGVzIHRlbmRhbmNlcyBkZSBsYSB2w6lnw6l0YXRpb24gb3UgZGUgbGEgc3VyZmFjZSBkZSBs4oCZZWF1IGxpw6llcyDDoCBsYSB2YXJpYWJpbGl0w6kgY2xpbWF0aXF1ZSBvdSBhdXggcHJhdGlxdWVzIMOgIGxvbmcgdGVybWUgZGUgbGEgZ2VzdGlvbiBkZXMgc29scy4gQWluc2ksIGxhIHN1cGVyZmljaWUgZOKAmXVuIHNvbCBudSBwZXV0IGF1Z21lbnRlciBwcm9ncmVzc2l2ZW1lbnQgZW4gcmFpc29uIGR1IGTDqWNsaW4gw6AgbG9uZyB0ZXJtZSBkZXMgcHLDqWNpcGl0YXRpb25zIDsgZXQgMy4gQ2hhbmdlbWVudHMgYWJydXB0cyAtLSBMZXMgbW9kaWZpY2F0aW9ucyBkZXMgdmFsZXVycyBkZSBwaXhlbHMgcmVmbMOodGVudCBkZXMgY2hhbmdlbWVudHMgZGUgbOKAmW9jY3VwYXRpb24gZHUgc29sIGxpw6lzIMOgIGRlcyDDqXbDqW5lbWVudHMgc291ZGFpbnMsIHRlbHMgcXVlIGxhIGTDqWZvcmVzdGF0aW9uLCBsZSBkw6l2ZWxvcHBlbWVudCB1cmJhaW4sIGxlcyBjYXRhc3Ryb3BoZXMgbmF0dXJlbGxlcywgZXRjLiBM4oCZYWxnb3JpdGhtZSBDQ0RDIGlkZW50aWZpZSBsZXMgdHJvaXMgdHlwZXMgZGUgbW9kaWZpY2F0aW9ucyBkYW5zIGxlIGJ1dCBwcmluY2lwYWwgZOKAmWlkZW50aWZpZXIgZGVzIGNoYW5nZW1lbnRzIGFicnVwdHMuIExhIHLDqWdyZXNzaW9uIGhhcm1vbmlxdWUgZXQgbGVzIG1vZMOobGVzIGRlIHRlbmRhbmNlIHNvbnQgYWp1c3TDqXMgYXV4IGRvbm7DqWVzIHBvdXIgZXN0aW1lciBsZXMgbW9kaWZpY2F0aW9ucyBzYWlzb25uacOocmVzIGV0IGxlcyBtb2RpZmljYXRpb25zIGdyYWR1ZWxsZXMgdGFuZGlzIHF1ZSBsZXMgZMOpdmlhdGlvbnMgc291ZGFpbmVzIHBhciByYXBwb3J0IGF1eCBtb2TDqGxlcyBkZSB0ZW5kYW5jZSBzb250IGRlcyBpbmRpY2F0aW9ucyBk4oCZdW4gY2hhbmdlbWVudCBhYnJ1cHQuPGRpdj48YnIvPsOAIGzigJlvcmlnaW5lLCBs4oCZYWxnb3JpdGhtZSBDQ0RDIGEgw6l0w6kgY29uw6d1IHBvdXIgbGVzIGRvbm7DqWVzIExhbmRzYXQgVE0sIExhbmRzYXQgRVRNKyBldCBMYW5kc2F0IE9MSSByZWxhdGl2ZXMgw6AgbGEgcsOpZmxlY3RhbmNlIGRlcyBzdXJmYWNlcyBvdSDDoCBsYSB0ZW1ww6lyYXR1cmUgZGUgYnJpbGxhbmNlLiBUb3V0ZWZvaXMsIGxhIGZvbmN0aW9uIGRlIGTDqXRlY3Rpb24gZGVzIG1vZGlmaWNhdGlvbnMgw6AgbOKAmWFpZGUgZHUgcmFzdGVyIGTigJlhbmFseXNlIGRlcyBjaGFuZ2VtZW50cyBjb25qdWd1w6llIMOgIGNldHRlIGZvbmN0aW9uIGTDqXRlY3RlIGxlcyBtb2RpZmljYXRpb25zIGTigJlpbWFnZXMgbXVsdGljYW5hdXggw6AgcGFydGlyIGRlIG7igJlpbXBvcnRlIHF1ZWwgY2FwdGV1ciBwcmlzIGVuIGNoYXJnZSwgYWluc2kgcXVlIGxlcyBpbWFnZXMgZMOpcml2w6llcyBtb25vY2FuYWxlcyB0ZWxsZXMgcXVlIGxlcyBpbmRpY2VzIGRlIGNhbmF1eC4gUGFyIGV4ZW1wbGUsIHZvdXMgcG91dmV6IGVmZmVjdHVlciB1bmUgZMOpdGVjdGlvbiBjb250aW51ZSBkZXMgbW9kaWZpY2F0aW9ucyBzdXIgdW4gcmFzdGVyIGTigJlpbmRpY2UgZGUgdsOpZ8OpdGF0aW9uIHBhciBkaWZmw6lyZW5jZSBub3JtYWxpc8OpZSAoTkRWSSksIGNhciBsZXMgY2hhbmdlbWVudHMgYWJydXB0cyBkYW5zIGxlIE5EVkkgcGV1dmVudCDDqnRyZSBsZSBzaWduZSBk4oCZdW5lIGTDqWZvcmVzdGF0aW9uLjwvZGl2PlwiLFxuXHRcdGNvbXB1dGVDaGFuZ2VOYW1lOiBcIkNhbGN1bGVyIGxlcyBtb2RpZmljYXRpb25zXCIsXG5cdFx0Y29tcHV0ZUNoYW5nZVNuaXA6IFwiQ2FsY3VsZSBsYSBkaWZmw6lyZW5jZSBlbnRyZSBkZXV4IGpldXggZGUgZG9ubsOpZXMgcmFzdGVyIGNhdMOpZ29yaWVscyBvdSBjb250aW51cy5cIixcblx0XHRjb21wdXRlQ2hhbmdlRGVzYzogXCJMYSBmb25jdGlvbiBDYWxjdWxlciBsZXMgbW9kaWZpY2F0aW9ucyBwZXJtZXQgZOKAmcOpbnVtw6lyZXIgbGVzIGRpZmbDqXJlbmNlcyBlbnRyZSBkZXV4IHJhc3RlcnMgY2xhc3NpZmnDqXMgZW4gbWF0acOocmUgZOKAmWFuYWx5c2UgZGVzIG1vZGlmaWNhdGlvbnMgZGUgbOKAmW9jY3VwYXRpb24gZHUgc29sIDsgaWwgcGVybWV0IMOpZ2FsZW1lbnQgZOKAmWV4YW1pbmVyIGxlcyBtb2RpZmljYXRpb25zIGVudHJlIGRldXggcmFzdGVycyBjb250aW51cyBtb25vY2FuYXV4IHRlbHMgcXVlIGzigJnDqWzDqXZhdGlvbiwgbGEgdGVtcMOpcmF0dXJlLCBsZSBjb3V2ZXJ0IGZvcmVzdGllciwgZXRjLlwiLFxuXHRcdGRldGVjdENoYW5nZU5hbWU6IFwiRMOpdGVjdGVyIGxlcyBtb2RpZmljYXRpb25zIMOgIGzigJlhaWRlIGRlIGzigJlhbmFseXNlIGRlcyBjaGFuZ2VtZW50c1wiLFxuXHRcdGRldGVjdENoYW5nZVNuaXA6IFwiR8OpbsOocmUgdW5lIGNvdWNoZSByYXN0ZXIgY29udGVuYW50IGRlcyBpbmZvcm1hdGlvbnMgc3VyIGxlcyBtb2RpZmljYXRpb25zIGRlIHBpeGVscyDDoCBs4oCZYWlkZSBkdSByYXN0ZXIgZOKAmWFuYWx5c2UgZGVzIGNoYW5nZW1lbnRzIGVuIHNvcnRpZS5cIixcblx0XHRkZXRlY3RDaGFuZ2VEZXNjOiBcIjxkaXY+TGEgZm9uY3Rpb24gRMOpdGVjdGVyIGxlcyBjaGFuZ2VtZW50cyDDoCBs4oCZYWlkZSBkZSBs4oCZYW5hbHlzZSBkZXMgY2hhbmdlbWVudHMgZ8OpbsOocmUgdW5lIGNvdWNoZSByYXN0ZXIgY29udGVuYW50IGRlcyBpbmZvcm1hdGlvbnMgcmVsYXRpdmVzIGF1eCBkYXRlcyBkZSBjaGFuZ2VtZW50IGRlcyBwaXhlbHMgYXZlYyBsZSByYXN0ZXIgZOKAmWFuYWx5c2UgZGVzIGNoYW5nZW1lbnRzLiBMZSByYXN0ZXIgZOKAmWFuYWx5c2UgZGVzIGNoYW5nZW1lbnRzIGRvaXQgw6p0cmUgZ8OpbsOpcsOpIHBhciBs4oCZb3V0aWwgQW5hbHlzZXIgbGVzIG1vZGlmaWNhdGlvbnMgYXZlYyBs4oCZYWxnb3JpdGhtZSBDQ0RDIG91IGzigJlvdXRpbCBBbmFseXNlciBsZXMgbW9kaWZpY2F0aW9ucyBhdmVjIGzigJlhbGdvcml0aG1lIExhbmRUcmVuZHIsIG91IGF2ZWMgbGEgZm9uY3Rpb24gcmFzdGVyIEFuYWx5c2UgQ0NEQyBvdSBsYSBmb25jdGlvbiByYXN0ZXIgQW5hbHlzZSBMYW5kVHJlbmRyLjwvZGl2Pjxicj48ZGl2PkNldHRlIGZvbmN0aW9uIHJhc3RlciBwZXV0IMOqdHJlIGFzc29jacOpZSDDoCBsYSBmb25jdGlvbiByYXN0ZXIgQW5hbHlzZSBDQ0RDIG91IMOgIGxhIGZvbmN0aW9uIHJhc3RlciBBbmFseXNlIExhbmRUcmVuZHIgZGFucyB1biBtb2TDqGxlIGRlIGZvbmN0aW9uIHJhc3Rlci4gUG91ciBwcm9kdWlyZSB1bmUgc29ydGllIHJhc3RlciBwZXJtYW5lbnRlLCBjb25uZWN0ZXogbGEgc29ydGllIGRlIGxhIGZvbmN0aW9uIEFuYWx5c2UgQ0NEQyBvdSBBbmFseXNlIExhbmRUcmVuZHIgw6AgbGEgZm9uY3Rpb24gRMOpdGVjdGVyIGxlcyBtb2RpZmljYXRpb25zIMOgIGzigJlhaWRlIGR1IHJhc3RlciBk4oCZYW5hbHlzZSBkZXMgY2hhbmdlbWVudHMsIGVucmVnaXN0cmV6LWxlcyBkYW5zIHVuIG1vZMOobGUgZGUgZm9uY3Rpb24gcmFzdGVyLCBwdWlzIGV4w6ljdXRleiBs4oCZYW5hbHlzZSByYXN0ZXIgYXZlYyBsZSBtb2TDqGxlLjwvZGl2Pjxicj48ZGl2PkxlIHBhcmFtw6h0cmUgPHN0cm9uZz5UeXBlIGRlIGNoYW5nZW1lbnQ8L3N0cm9uZz4gaW5kaXF1ZSBsZXMgaW5mb3JtYXRpb25zIGfDqW7DqXLDqWVzLiBMZXMgaW5mb3JtYXRpb25zIHNvbnQgZXh0cmFpdGVzIGR1IHJhc3RlciBk4oCZYW5hbHlzZSBkZXMgY2hhbmdlbWVudHMuIExvcnNxdWUgdm91cyBleMOpY3V0ZXogY2V0dGUgZm9uY3Rpb24gc3VyIGxhIHNvcnRpZSBkZSBsYSBmb25jdGlvbi9s4oCZb3V0aWwgQ0NEQywgdm91cyBhdmV6IGxlIGNob2l4IGVudHJlIGxlcyBvcHRpb25zIHN1aXZhbnRlc8KgOjwvZGl2Pjx1bD48bGk+PHN0cm9uZz5IZXVyZSBkdSBjaGFuZ2VtZW50IGxlIHBsdXMgcsOpY2VudDwvc3Ryb25nPsKgOiBkYXRlIGV0IGhldXJlIGxlcyBwbHVzIHLDqWNlbnRlcyBhdXhxdWVsbGVzIHVuIHBpeGVsIGEgw6l0w6kgbWFycXXDqSBjb21tZSBtb2RpZmnDqS48L2xpPjxsaT48c3Ryb25nPkhldXJlIGR1IHByZW1pZXIgY2hhbmdlbWVudDwvc3Ryb25nPsKgOiBkYXRlIGV0IGhldXJlIGxlcyBwbHVzIGFuY2llbm5lcyBhdXhxdWVsbGVzIHVuIHBpeGVsIGEgw6l0w6kgbWFycXXDqSBjb21tZSBtb2RpZmnDqS48L2xpPjxsaT48c3Ryb25nPkhldXJlIGR1IHBsdXMgZ3JhbmQgY2hhbmdlbWVudDwvc3Ryb25nPsKgOiBkYXRlIGV0IGhldXJlIGF1eHF1ZWxsZXMgbGUgY2hhbmdlbWVudCBjYWxjdWzDqSDDqXRhaXQgbGUgcGx1cyBpbXBvcnRhbnQgcG91ciB1biBwaXhlbC48L2xpPjxsaT4gPHN0cm9uZz5Ob21icmUgZGUgY2hhbmdlbWVudHM8L3N0cm9uZz7CoDogbm9tYnJlIHRvdGFsIGRlIGZvaXMgb8O5IGxlIHBpeGVsIGEgw6l0w6kgbW9kaWZpw6kuPC9saT48L3VsPjxkaXY+TG9yc3F1ZSB2b3VzIGV4w6ljdXRleiBjZXR0ZSBmb25jdGlvbiBzdXIgbGEgc29ydGllIGRlIGxhIGZvbmN0aW9uL2zigJlvdXRpbCBMYW5kVHJlbmRyLCBsZXMgb3B0aW9ucyBzdWl2YW50ZXMgc3VwcGzDqW1lbnRhaXJlcyBzb250IGRpc3BvbmlibGVzwqA6PC9kaXY+PHVsPjxsaT48c3Ryb25nPkhldXJlIGR1IHBsdXMgbG9uZyBjaGFuZ2VtZW50PC9zdHJvbmc+IDogZGF0ZSDDoCBsYXF1ZWxsZSB1biBwaXhlbCBhIMOpdMOpIG1hcnF1w6kgY29tbWUgbW9kaWZpw6ksIGF1IGTDqWJ1dCBvdSDDoCBsYSBmaW4gZGUgbGEgcGx1cyBsb25ndWUgcMOpcmlvZGUgZGUgY2hhbmdlbWVudC48L2xpPjxsaT48c3Ryb25nPkhldXJlIGR1IHBsdXMgY291cnQgY2hhbmdlbWVudDwvc3Ryb25nPsKgOiBkYXRlIMOgIGxhcXVlbGxlIHVuIHBpeGVsIGEgw6l0w6kgbWFycXXDqSBjb21tZSBtb2RpZmnDqSwgYXUgZMOpYnV0IG91IMOgIGxhIGZpbiBkZSBsYSBwbHVzIGNvdXJ0ZSBww6lyaW9kZSBkZSBjaGFuZ2VtZW50LjwvbGk+PGxpPjxzdHJvbmc+SGV1cmUgZHUgY2hhbmdlbWVudCBsZSBwbHVzIHJhcGlkZTwvc3Ryb25nPsKgOiBkYXRlIMOgIGxhcXVlbGxlIHVuIHBpeGVsIGEgw6l0w6kgbWFycXXDqSBjb21tZSBtb2RpZmnDqSwgYXUgZMOpYnV0IG91IMOgIGxhIGZpbiBkZSBsYSBww6lyaW9kZSBkZSBjaGFuZ2VtZW50IGxhIHBsdXMgcmFwaWRlLjwvbGk+PGxpPjxzdHJvbmc+SGV1cmUgZHUgY2hhbmdlbWVudCBsZSBwbHVzIGxlbnQ8L3N0cm9uZz7CoDogZGF0ZSDDoCBsYXF1ZWxsZSB1biBwaXhlbCBhIMOpdMOpIG1hcnF1w6kgY29tbWUgbW9kaWZpw6ksIGF1IGTDqWJ1dCBvdSDDoCBsYSBmaW4gZGUgbGEgcMOpcmlvZGUgZGUgY2hhbmdlbWVudCBsYSBwbHVzIGxlbnRlLjwvbGk+PC91bD48ZGl2PkxlIHJhc3RlciBlbiBzb3J0aWUgZXN0IHVuIHJhc3RlciBtdWx0aWNhbmFsIGRhbnMgbGVxdWVsIGNoYXF1ZSBjYW5hbCBjb250aWVudCBkZXMgaW5mb3JtYXRpb25zIHN1ciBsZXMgY2hhbmdlbWVudHMgc2Vsb24gbGUgdHlwZSBkZSBjaGFuZ2VtZW50IHPDqWxlY3Rpb25uw6kgZXQgbGUgbm9tYnJlIG1heGltYWwgZGUgY2hhbmdlbWVudHMgc3DDqWNpZmnDqS4gUGFyIGV4ZW1wbGUsIHNpIDxzdHJvbmc+VHlwZSBkZSBjaGFuZ2VtZW50PC9zdHJvbmc+IGVzdCBkw6lmaW5pIHN1ciA8c3Ryb25nPkhldXJlIGR1IHByZW1pZXIgY2hhbmdlbWVudDwvc3Ryb25nPiBldCBzaSA8c3Ryb25nPk5vbWJyZSBtYXhpbWFsIGRlIGNoYW5nZW1lbnRzPC9zdHJvbmc+IGVzdCBkw6lmaW5pIHN1ciAyLCBsYSBmb25jdGlvbiBjYWxjdWxlIGxlcyBkZXV4IGRhdGVzIGxlcyBwbHVzIGFuY2llbm5lcyBkdSBjaGFuZ2VtZW50IHRvdXQgYXUgbG9uZyBkZSBsYSBzw6lyaWUgY2hyb25vbG9naXF1ZSBwb3VyIGNoYXF1ZSBwaXhlbC4gTGUgcsOpc3VsdGF0IGVzdCB1biByYXN0ZXIgZGFucyBsZXF1ZWwgbGUgcHJlbWllciBjYW5hbCBjb250aWVudCBsZXMgZGF0ZXMgZHUgcHJlbWllciBjaGFuZ2VtZW50IHBhciBwaXhlbCBldCBsZSBkZXV4acOobWUgY2FuYWwgY29udGllbnQgbGVzIGRhdGVzIGR1IGRldXhpw6htZSBjaGFuZ2VtZW50IHBhciBwaXhlbC48L2Rpdj48YnI+PGRpdj5Mb3JzIGRlIGzigJlhcHBsaWNhdGlvbiBkZSBjZXR0ZSBmb25jdGlvbiBzdXIgbGEgc29ydGllIGRlcyBvdXRpbHMgTGFuZFRyZW5kciwgdm91cyBwb3V2ZXogY2hvaXNpciBk4oCZZXh0cmFpcmUgbGEgZGF0ZSBtYXJxdWFudCBsZSBkw6lidXQgZOKAmXVuIGNoYW5nZW1lbnQgb3UgbGEgZmluIGTigJl1biBjaGFuZ2VtZW50IMOgIGzigJlhaWRlIGR1IHBhcmFtw6h0cmUgPHN0cm9uZz5EYXRlIGRlIHNlZ21lbnQ8L3N0cm9uZz4uIFBhciBleGVtcGxlLCBwb3VyIGNvbXByZW5kcmUgY29tbWVudCBhIGTDqWJ1dMOpIGxlIHBsdXMgcsOpY2VudCBjaGFuZ2VtZW50IGRhbnMgbGEgc8OpcmllIGNocm9ub2xvZ2lxdWUsIGTDqWZpbmlzc2V6IDxzdHJvbmc+VHlwZSBkZSBjaGFuZ2VtZW50PC9zdHJvbmc+IHN1ciA8c3Ryb25nPkhldXJlIGR1IGNoYW5nZW1lbnQgbGUgcGx1cyByw6ljZW50PC9zdHJvbmc+IGV0IDxzdHJvbmc+RGF0ZSBkdSBzZWdtZW50PC9zdHJvbmc+IHN1ciA8c3Ryb25nPkTDqWJ1dCBkdSBzZWdtZW50PC9zdHJvbmc+LjwvZGl2Pjxicj48ZGl2PlV0aWxpc2V6IGxlcyBwYXJhbcOodHJlcyBkZSBmaWx0cmFnZSBzdWl2YW50cyBwb3VyIGV4dHJhaXJlIGTigJlhdXRyZXMgZGF0ZXMgZGUgY2hhbmdlbWVudCBzcMOpY2lmaXF1ZXMgZGUgdm90cmUgcmFzdGVyIGTigJlhbmFseXNlIGRlcyBjaGFuZ2VtZW50c8KgOjwvZGl2Pjx1bD48bGk+PHN0cm9uZz5GaWx0cmVyIHBhciBhbm7DqWU8L3N0cm9uZz7CoDogaWRlbnRpZmlleiBsZXMgY2hhbmdlbWVudHMgc3VydmVudXMgYXUgY291cnMgZOKAmXVuZSBww6lyaW9kZSBzcMOpY2lmaXF1ZcKgOyBwYXIgZXhlbXBsZSwgbG9yc3F1ZSB2b3VzIHJlY2hlcmNoZXogbGVzIGNoYW5nZW1lbnRzIHN1cnZlbnVzIGRhbnMgdW4gcGF5c2FnZSBhdSBjb3VycyBkZSA1wqBhbm7DqWVzIGRlIHPDqWNoZXJlc3NlLjwvbGk+PGxpPjxzdHJvbmc+RmlsdHJlciBwYXIgZHVyw6llPC9zdHJvbmc+wqA6IGlkZW50aWZpZXogbGVzIGNoYW5nZW1lbnRzIHN1cnZlbnVzIHN1ciB1biBub21icmUgZOKAmWFubsOpZXMgc3DDqWNpZmlxdWXCoDsgcGFyIGV4ZW1wbGUsIGxvcnNxdWUgdm91cyByZWNoZXJjaGV6IHVuaXF1ZW1lbnQgbGVzIGNoYW5nZW1lbnRzIHNvdWRhaW5zIHN1cnZlbnVzIHN1ciB1biBvdSBkZXV4IGFucy4gVm91cyBwb3V2ZXogY2FsY3VsZXIgbGEgZHVyw6llIHF1aSB2b3VzIGludMOpcmVzc2Ugw6AgbOKAmWFpZGUgZGUgbGEgZm9ybXVsZSBzdWl2YW50ZcKgOiA8c3Ryb25nPmFubsOpZSBkZSBmaW4gLSBhbm7DqWUgZGUgZMOpYnV0ICsxPC9zdHJvbmc+LiBTaSBsYSBzw6lyaWUgY2hyb25vbG9naXF1ZSBjb21wb3J0ZSBkZXMgZGlzY29udGludWl0w6lzLCBlbGxlcyBzZXJvbnQgaW5jbHVzZXMuPC9saT48bGk+PHN0cm9uZz5GaWx0cmVyIHBhciBtYWduaXR1ZGU8L3N0cm9uZz7CoDogaWRlbnRpZmlleiBsZXMgY2hhbmdlbWVudHMgZOKAmXVuZSBtYWduaXR1ZGUgZG9ubsOpZcKgOyBwYXIgZXhlbXBsZSwgbG9yc3F1ZSB2b3VzIHJlY2hlcmNoZXogdW5pcXVlbWVudCBkZXMgY2hhbmdlbWVudHMgaW1wb3J0YW50cyBkYW5zIGzigJlpbmRpY2UgZGUgdsOpZ8OpdGF0aW9uIE5EVkkuIExhIG1hZ25pdHVkZSDDqXRhbnQgdW5lIHZhbGV1ciBhYnNvbHVlLCBsZXMgdmFsZXVycyBtaW5pbWFsZSBldCBtYXhpbWFsZSBuZSBwZXV2ZW50IHBhcyDDqnRyZSBuw6lnYXRpdmVzLiBQb3VyIHNww6ljaWZpZXIgbGUgY2hhbmdlbWVudCBkaXJlY3Rpb25uZWwsIHV0aWxpc2V6IGxlIHBhcmFtw6h0cmUgPHN0cm9uZz5DaGFuZ2VyIGRlIGRpcmVjdGlvbjwvc3Ryb25nPi48L2xpPjwvdWw+XCIsXG5cdFx0ZGlzdGFuY2VBY2N1bXVsYXRpb25OYW1lOiBcIkFjY3VtdWxhdGlvbiBkZSBkaXN0YW5jZVwiLFxuXHRcdGRpc3RhbmNlQWNjdW11bGF0aW9uU25pcDogXCJDYWxjdWxlIGxhIGRpc3RhbmNlIGFjY3VtdWzDqWUgZGUgY2hhcXVlIGNlbGx1bGUgdmVycyBsZXMgc291cmNlcywgcG91ciBwZXJtZXR0cmUgbGVzIGZhY3RldXJzIGRlIGRpc3RhbmNlIGVuIGxpZ25lIGRyb2l0ZSwgZGlzdGFuY2UgZGUgY2/Du3QgZXQgZGlzdGFuY2UgZGUgc3VyZmFjZSB2w6lyaXRhYmxlLCBhaW5zaSBxdWUgbGVzIGZhY3RldXJzIGhvcml6b250YXV4IGV0IHZlcnRpY2F1eCBkZSBjb8O7dC5cIixcblx0XHRkaXN0YW5jZUFjY3VtdWxhdGlvbkRlc2M6IFwiTOKAmWFjY3VtdWxhdGlvbiBkZSBkaXN0YW5jZSBjYWxjdWxlIGxhIGRpc3RhbmNlIHPDqXBhcmFudCBjaGFxdWUgZW1wbGFjZW1lbnQgZGUgbGEgem9uZSBk4oCZw6l0dWRlIHZlcnMgbGEgc291cmNlIGxhIHBsdXMgcHJvY2hlIG91IGRlIG1vaW5kcmUgY2/Du3QuIFNpIHNldWxlcyBsZXMgc291cmNlcyBzb250IGZvdXJuaWVzIGVuIGVudHLDqWUsIHVuZSBkaXN0YW5jZSBlbiBsaWduZSBkcm9pdGUgZXN0IGNhbGN1bMOpZSB2ZXJzIGNoYXF1ZSBlbXBsYWNlbWVudCBkZSBsYSB6b25lIGTigJnDqXR1ZGUuIFNpIGxlcyBzb3VyY2VzIGV0IGxlcyBpbnRlcnJ1cHRpb25zIHNvbnQgdXRpbGlzw6llcyBlbiBlbnRyw6llLCBs4oCZYWNjdW11bGF0aW9uIGRlIGRpc3RhbmNlIGNhbGN1bGUgbGEgZGlzdGFuY2UgZW4gbGlnbmUgZHJvaXRlIGF1IG5pdmVhdSBkZXMgaW50ZXJydXB0aW9ucy4gUG91ciBsZSByYXN0ZXIgc291cmNlIGV0IGxlIHJhc3RlciBk4oCZaW50ZXJydXB0aW9uLCBsYSB2YWxldXIgZOKAmWFycmnDqHJlLXBsYW4gZG9pdCDDqnRyZSBOb0RhdGEsIGV0IGxlcyBzb3VyY2VzIGV0IGxlcyBpbnRlcnJ1cHRpb25zIHNvbnQgcmVwcsOpc2VudMOpZXMgcGFyIGRlcyB2YWxldXJzIGRlIGNlbGx1bGUgdmFsaWRlcy4gWsOpcm8gZmlndXJlIHBhcm1pIGxlcyB2YWxldXJzIHZhbGlkZXMuIDxkaXY+PGJyLz5Mb3JzcXXigJl1biByYXN0ZXIgZGUgc3VyZmFjZSBlc3Qgc3DDqWNpZmnDqSBlbiBlbnRyw6llLCBsYSBkaXN0YW5jZSBkZSBzdXJmYWNlIHLDqWVsbGUgZW50cmUgbGVzIGNlbGx1bGVzIGVzdCBjYWxjdWzDqWUuIFBvdXIgZWZmZWN0dWVyIHVuZSBhbmFseXNlIGRlIGNvw7t0IMOgIGzigJlhaWRlIGRlIGxhIGZvbmN0aW9uIEFjY3VtdWxhdGlvbiBkZSBkaXN0YW5jZSwgdW5lIHN1cmZhY2UgZGUgY2/Du3QgZXN0IG7DqWNlc3NhaXJlLiBTaSB1bmUgc3VyZmFjZSBkZSBjb8O7dCBlc3QgaW5kaXF1w6llLCBsZSByw6lzdWx0YXQgZXN0IHVuIHJhc3RlciBkZSBkaXN0YW5jZSBkZSBjb8O7dCBjdW11bMOpZS4gTG9yc3F1ZSBsZXMgZmFjdGV1cnMgaG9yaXpvbnRhdXggZXQgdmVydGljYXV4IHNvbnQgc3DDqWNpZmnDqXMsIGxhIGRpcmVjdGlvbiBjb25zaWTDqXLDqWUgY29tbWUgdW4gY2/Du3QgZXN0IGN1bXVsw6llLiBRdWF0cmUgY2FyYWN0w6lyaXN0aXF1ZXMgZGUgbGEgc291cmNlIHBldXZlbnQgw6p0cmUgdXRpbGlzw6llcy4gQ2VzIGNhcmFjdMOpcmlzdGlxdWVzIHF1aSBwZXV2ZW50IMOqdHJlIHNvaXQgbGEgc291cmNlLCBzb2l0IGxlcyBzdWpldHMgc+KAmcOpbG9pZ25hbnQgZGUgbGEgc291cmNlIHNvbnQgY29udHLDtGzDqWVzIHBhciBkZXMgcGFyYW3DqHRyZXMgc3DDqWNpZmlxdWVzIDogMS4gQWNjdW11bGF0aW9uIGluaXRpYWxlIDrigK9kw6lmaW5pdCBsZSBjb8O7dCBpbml0aWFsIGF2YW50IGxlIGTDqWJ1dCBkdSBkw6lwbGFjZW1lbnQuIDIuIEFjY3VtdWxhdGlvbiBtYXhpbWFsZSA64oCvc3DDqWNpZmllIGxlIGNvw7t0IHF14oCZdW5lIHNvdXJjZSBwZXV0IGN1bXVsZXIgYXZhbnQgZOKAmWF0dGVpbmRyZSBzYSBsaW1pdGUuIDMuIE11bHRpcGxpY2F0ZXVyIMOgIGFwcGxpcXVlciBhdXggY2/Du3RzIDrigK9zcMOpY2lmaWUgbGUgbW9kZSBkZSBkw6lwbGFjZW1lbnQgb3UgbGEgbWFnbml0dWRlIMOgIGxhIHNvdXJjZS4gNC4gU2VucyBkZSBkw6lwbGFjZW1lbnQgOuKAr2lkZW50aWZpZSBzaSBsZSBzdWpldCBwYXJ0IGTigJl1bmUgc291cmNlIGV0IHNlIGTDqXBsYWNlIHZlcnMgZGVzIGVtcGxhY2VtZW50cyBub24gc291cmNlIG91IHPigJlpbCBwYXJ0IGRlcyBlbXBsYWNlbWVudHMgbm9uIHNvdXJjZSBldCByZXRvdXJuZSB2ZXJzIHVuZSBzb3VyY2UuPGRpdj48YnIvPlBhciBkw6lmYXV0LCBsZSByw6lzdWx0YXQgZGUgbOKAmWFjY3VtdWxhdGlvbiBkZSBkaXN0YW5jZSBlc3QgdW4gY2FuYWwgdW5pcXVlIHF1aSBjb3JyZXNwb25kIGF1IHJhc3RlciBk4oCZYWNjdW11bGF0aW9uIGRlIGRpc3RhbmNlLiBUb3V0ZWZvaXMsIGlsIGVzdCBwb3NzaWJsZSBkZSBjcsOpZXIgdW4gZGV1eGnDqG1lIGNhbmFsLCBsZSBjYW5hbCBkZSBkaXJlY3Rpb24gYXJyacOocmUuIENlIGNhbmFsIGluZGlxdWUsIHBvdXIgY2hhcXVlIGVtcGxhY2VtZW50IGZpZ3VyYW50IGRhbnMgbGEgem9uZSBk4oCZw6l0dWRlLCBsYSBkaXJlY3Rpb24gw6AgcHJlbmRyZSBwb3VyIHBhcnZlbmlyIMOgIGxhIHNvdXJjZSBkZSBtb2luZHJlIGNvw7t0LiBMZXMgZGV1eCBjYW5hdXggc2Vyb250IG7DqWNlc3NhaXJlcyBwb3VyIGTDqXRlcm1pbmVyIGxlcyBjaGVtaW5zIG9wdGltYXV4IGF1IHNlaW4gZGUgbGEgem9uZSBk4oCZw6l0dWRlLiBQb3VyIGfDqW7DqXJlciB1biBjaGVtaW4sIHV0aWxpc2V6IGTigJlhYm9yZCBsYSBmb25jdGlvbiBFeHRyYWlyZSBsZXMgY2FuYXV4IHBvdXIgZXh0cmFpcmUgbGUgcmFzdGVyIGTigJlhY2N1bXVsYXRpb24gZGUgZGlzdGFuY2UgZXQgbGUgcmFzdGVyIGRlIGRpcmVjdGlvbiBhcnJpw6hyZS4gVXRpbGlzZXogY2VzIGNvdWNoZXMgZW4gZW50csOpZSBkZSBsYSBmb25jdGlvbiBDaGVtaW4gZGUgbW9pbmRyZSBjb8O7dC4gRGFucyBsYSBmb25jdGlvbiwgdXRpbGlzZXogbGUgcmFzdGVyIGTigJlhY2N1bXVsYXRpb24gZGUgZGlzdGFuY2UgY29tbWUgZW50csOpZSBkdSByYXN0ZXIgZGUgZGlzdGFuY2UgZGUgY2/Du3QgZXQgbGUgcmFzdGVyIGRlIGRpcmVjdGlvbiBhcnJpw6hyZSBjb21tZSBlbnRyw6llIGR1IHJhc3RlciBk4oCZYW50w6ljw6lkZW5jZSBkZSBjb8O7dC48L2Rpdj5cIixcblx0XHRkaXN0YW5jZUFsbG9jYXRpb25OYW1lOiBcIkFsbG9jYXRpb24gZGUgZGlzdGFuY2VcIixcblx0XHRkaXN0YW5jZUFsbG9jYXRpb25TbmlwOiBcIkNhbGN1bGUgbOKAmWFsbG9jYXRpb24gZGUgZGlzdGFuY2UgZGUgY2hhcXVlIGNlbGx1bGUgdmVycyBsZXMgc291cmNlcyBmb3VybmllcyBlbiBmb25jdGlvbiBkZXMgZmFjdGV1cnMgZGUgZGlzdGFuY2UgZW4gbGlnbmUgZHJvaXRlLCBkaXN0YW5jZSBkZSBjb8O7dCBldCBkaXN0YW5jZSBkZSBzdXJmYWNlIHbDqXJpdGFibGUsIGFpbnNpIHF1ZSBsZXMgZmFjdGV1cnMgaG9yaXpvbnRhdXggZXQgdmVydGljYXV4IGRlIGNvw7t0LlwiLFxuXHRcdGRpc3RhbmNlQWxsb2NhdGlvbkRlc2M6IFwiTOKAmWFsbG9jYXRpb24gZGUgZGlzdGFuY2UgY2FsY3VsZSBsYSBzb3VyY2Ugw6AgbGFxdWVsbGUgY2hhcXVlIGVtcGxhY2VtZW50IGRlIGxhIHpvbmUgZOKAmcOpdHVkZSBlc3QgYWxsb3XDqS4gU2kgc2V1bGVzIGxlcyBzb3VyY2VzIHNvbnQgZm91cm5pZXMgZW4gZW50csOpZSwgbGVzIGVtcGxhY2VtZW50cyBzb250IGFsbG91w6lzIHNlbG9uIGxhIGRpc3RhbmNlIGVuIGxpZ25lIGRyb2l0ZSB2ZXJzIGxhIHNvdXJjZSBsYSBwbHVzIHByb2NoZS4gU2kgbGVzIHNvdXJjZXMgZXQgbGVzIGludGVycnVwdGlvbnMgc29udCB1dGlsaXPDqWVzIGVuIGVudHLDqWUsIGzigJlhbGxvY2F0aW9uIGRlIGRpc3RhbmNlIGNhbGN1bGUgbGEgZGlzdGFuY2UgZW4gbGlnbmUgZHJvaXRlIGF1IG5pdmVhdSBkZXMgaW50ZXJydXB0aW9ucyBwb3VyIGTDqXRlcm1pbmVyIGxhIHNvdXJjZSDDoCBsYXF1ZWxsZSBs4oCZZW1wbGFjZW1lbnQgZXN0IGFsbG91w6kuIFBvdXIgbGUgcmFzdGVyIHNvdXJjZSBldCBsZSByYXN0ZXIgZOKAmWludGVycnVwdGlvbiwgbGEgdmFsZXVyIGTigJlhcnJpw6hyZS1wbGFuIGRvaXQgw6p0cmUgTm9EYXRhLCBldCBsZXMgc291cmNlcyBldCBsZXMgaW50ZXJydXB0aW9ucyBzb250IHJlcHLDqXNlbnTDqWVzIHBhciBkZXMgdmFsZXVycyBkZSBjZWxsdWxlIHZhbGlkZXMuIFrDqXJvIGZpZ3VyZSBwYXJtaSBsZXMgdmFsZXVycyB2YWxpZGVzLjxkaXY+PGJyLz5Qb3VyIGVmZmVjdHVlciB1bmUgYW5hbHlzZSBkZSBjb8O7dCDDoCBs4oCZYWlkZSBkZSBsYSBmb25jdGlvbiBBbGxvY2F0aW9uIGRlIGRpc3RhbmNlLCB1bmUgc3VyZmFjZSBkZSBjb8O7dCBlc3QgbsOpY2Vzc2FpcmUuIFNpIHVuZSBzdXJmYWNlIGRlIGNvw7t0IGVzdCBzcMOpY2lmacOpZSwgbGUgcsOpc3VsdGF0IGTDqXNpZ25lIHVuIHJhc3RlciBk4oCZYWxsb2NhdGlvbiBiYXPDqSBzdXIgdW4gY2/Du3QgY3VtdWzDqSBldCBub24gdW5lIGRpc3RhbmNlIGVuIGxpZ25lIGRyb2l0ZS4gTG9yc3F1ZSBsZXMgZmFjdGV1cnMgaG9yaXpvbnRhdXggZXQgdmVydGljYXV4IHNvbnQgc3DDqWNpZmnDqXMsIGxhIGRpcmVjdGlvbiBjb25zaWTDqXLDqWUgY29tbWUgdW4gY2/Du3QgZXN0IGN1bXVsw6llLiBMb3JzcXXigJl1biByYXN0ZXIgZGUgc3VyZmFjZSBlc3Qgc3DDqWNpZmnDqSBlbiBlbnRyw6llLCBsYSBkaXN0YW5jZSBkZSBzdXJmYWNlIHLDqWVsbGUgY291dmVydGUgcGFyIGxlIHBhc3NhZ2UgZW50cmUgbGVzIGNlbGx1bGVzIGVzdCBjYWxjdWzDqWUgYXUgbW9tZW50IG/DuSBs4oCZYWxsb2NhdGlvbiBlc3QgZMOpdGVybWluw6llLiBRdWF0cmUgY2FyYWN0w6lyaXN0aXF1ZXMgZGUgbGEgc291cmNlIHBldXZlbnQgw6p0cmUgdXRpbGlzw6llcy4gQ2VzIGNhcmFjdMOpcmlzdGlxdWVzIHF1aSBwZXV2ZW50IMOqdHJlIHNvaXQgbGEgc291cmNlLCBzb2l0IGxlcyBzdWpldHMgc+KAmcOpbG9pZ25hbnQgZGUgbGEgc291cmNlIHNvbnQgY29udHLDtGzDqWVzIHBhciBkZXMgcGFyYW3DqHRyZXMgc3DDqWNpZmlxdWVzIDogMS4gQWNjdW11bGF0aW9uIGluaXRpYWxlIDrigK9kw6lmaW5pdCBsZSBjb8O7dCBpbml0aWFsIGF2YW50IGxlIGTDqWJ1dCBkdSBkw6lwbGFjZW1lbnQuIDIuIEFjY3VtdWxhdGlvbiBtYXhpbWFsZSA64oCvc3DDqWNpZmllIGxlIGNvw7t0IHF14oCZdW5lIHNvdXJjZSBwZXV0IGN1bXVsZXIgYXZhbnQgZOKAmWF0dGVpbmRyZSBzYSBsaW1pdGUuIDMuIE11bHRpcGxpY2F0ZXVyIMOgIGFwcGxpcXVlciBhdXggY2/Du3RzIDrigK9zcMOpY2lmaWUgbGUgbW9kZSBkZSBkw6lwbGFjZW1lbnQgb3UgbGEgbWFnbml0dWRlIMOgIGxhIHNvdXJjZS4gNC4gU2VucyBkZSBkw6lwbGFjZW1lbnQgOuKAr2lkZW50aWZpZSBzaSBsZSBzdWpldCBwYXJ0IGTigJl1bmUgc291cmNlIGV0IHNlIGTDqXBsYWNlIHZlcnMgZGVzIGVtcGxhY2VtZW50cyBub24gc291cmNlIG91IHPigJlpbCBwYXJ0IGRlcyBlbXBsYWNlbWVudHMgbm9uIHNvdXJjZSBldCByZXRvdXJuZSB2ZXJzIHVuZSBzb3VyY2UuPGRpdj48YnIvPlBhciBkw6lmYXV0LCBsZSByw6lzdWx0YXQgZGUgbOKAmWFsbG9jYXRpb24gZGUgZGlzdGFuY2UgZXN0IHVuIGNhbmFsIHVuaXF1ZSBxdWkgY29ycmVzcG9uZCBhdSByYXN0ZXIgZOKAmWFsbG9jYXRpb24gZGUgZGlzdGFuY2UuIENvY2hlciBs4oCZb3B0aW9uIGJvb2zDqWVubmUgR2VuZXJhdGUgc291cmNlIHJvdyBhbmQgY29sdW1uIGFzIGFkZGl0aW9uYWwgYmFuZHMgaW4gb3V0cHV0IChHw6luw6lyZXIgdW5lIGxpZ25lIGV0IHVuZSBjb2xvbm5lIHNvdXJjZSBlbiB0YW50IHF1ZSBjYW5hdXggc3VwcGzDqW1lbnRhaXJlcyBlbiBzb3J0aWUpIHByb2R1aXJhIHVuIHJhc3RlciBtdWx0aWNhbmFsIGNvbXBvc8OpIGRlIHRyb2lzIGNhbmF1eC4gTGUgcHJlbWllciBjYW5hbCBlc3QgbGUgY2FuYWwgZOKAmWFsbG9jYXRpb24gZGUgZGlzdGFuY2UsIGxlIHNlY29uZCBjb250aWVudCB1biBpbmRleCBkZSBsaWduZXMsIGV0IGxlIHRyb2lzacOobWUgY2FuYWwgdW4gaW5kZXggZGUgY29sb25uZXMuIENlcyBpbmRleCBpZGVudGlmaWVudCBs4oCZZW1wbGFjZW1lbnQgZGUgbGEgY2VsbHVsZSBzb3VyY2UgcXVpIHNlIHRyb3V2ZSDDoCBsYSBkaXN0YW5jZSBkZSBwbHVzIGZhaWJsZSBjb8O7dCBjdW11bMOpLiBM4oCZaW5kZXggZGUgbGlnbmVzIHNvdXJjZSBldCBs4oCZaW5kZXggZGUgY29sb25uZXMgc291cmNlIHBldXZlbnQgw6p0cmUgdXRpbGlzw6lzIGVuc2VtYmxlIHBvdXIgcsOpYWxpc2VyIHVuZSBjYXJ0b2dyYXBoaWUgZOKAmWludGVuc2l0w6kuIEVmZmVjdHVleiB1bmUgcmVxdcOqdGUgc3VyIHVuIGVtcGxhY2VtZW50IGRlIHZvdHJlIHpvbmUgZOKAmcOpdHVkZSDDoCB0cmF2ZXJzIGxlcyBjYW5hdXggZGV1eCBldCB0cm9pcywgcG91ciBjb25uYcOudHJlIGxhIGxpZ25lIGV0IGxhIGNvbG9ubmUgZGUgbGEgc291cmNlIGRlIG1vaW5kcmUgY2/Du3QgcG91ciBjZXQgZW1wbGFjZW1lbnQuPC9kaXY+XCIsXG5cdFx0ZXVjQmFja0RpcmVjdGlvbk5hbWU6IFwiRGlyZWN0aW9uIGFycmnDqHJlIGV1Y2xpZGllbm5lXCIsXG5cdFx0ZXVjQmFja0RpcmVjdGlvblNuaXA6IFwiQ2FsY3VsZSBwb3VyIGNoYXF1ZSBjZWxsdWxlIGxhIGRpcmVjdGlvbiAoZW4gZGVncsOpcykgdmVycyBsYSBjZWxsdWxlIHZvaXNpbmUgbGUgbG9uZyBkdSBjaGVtaW4gbGUgcGx1cyBjb3VydCBwb3VyIHJldmVuaXIgw6AgbGEgc291cmNlIGxhIHBsdXMgcHJvY2hlIGVuIMOpdml0YW50IGxlcyBpbnRlcnJ1cHRpb25zLlwiLFxuXHRcdGV1Y0JhY2tEaXJlY3Rpb25EZXNjOiBcIkxhIGZvbmN0aW9uIERpcmVjdGlvbiBhcnJpw6hyZSBldWNsaWRpZW5uZSBnw6luw6hyZSB1biByYXN0ZXIgY29udGludSDDoCB2aXJndWxlIGZsb3R0YW50ZSByZXByw6lzZW50YW50IGxhIGRpcmVjdGlvbiBlbiBkZWdyw6lzIHZlcnMgbGEgc291cmNlIGxhIHBsdXMgcHJvY2hlIHRvdXQgZW4gw6l2aXRhbnQgbGVzIGludGVycnVwdGlvbnMsIGxlIGNhcyDDqWNow6lhbnQuPGRpdj48YnIvPkxlcyBlbnRyw6llcyBkZSBsYSBmb25jdGlvbiBEaXJlY3Rpb24gYXJyacOocmUgZXVjbGlkaWVubmUgc29udCBsYSBzb3VyY2UgZGFucyBsYXF1ZWxsZSBsYSBkaXJlY3Rpb24gc2VyYSBjYWxjdWzDqWUuIFVuIHJhc3RlciByZXByw6lzZW50YW50IGxlcyBpbnRlcnJ1cHRpb25zIGRhbnMgbGEgem9uZSBk4oCZw6l0dWRlIGVzdCB1bmUgZW50csOpZSBmYWN1bHRhdGl2ZS4gUG91ciBsZSByYXN0ZXIgc291cmNlIGV0IGxlIHJhc3RlciBk4oCZaW50ZXJydXB0aW9uLCBsYSB2YWxldXIgZOKAmWFycmnDqHJlLXBsYW4gZG9pdCDDqnRyZSBOb0RhdGEsIGV0IGxlcyBzb3VyY2VzIGV0IGxlcyBpbnRlcnJ1cHRpb25zIHNvbnQgcmVwcsOpc2VudMOpZXMgcGFyIGRlcyB2YWxldXJzIHZhbGlkZXMuIFrDqXJvIGZpZ3VyZSBwYXJtaSBsZXMgdmFsZXVycyB2YWxpZGVzLiBQYXIgZMOpZmF1dCwgbGUgY2FsY3VsIGVmZmVjdHVlIGxlIHRyYWl0ZW1lbnQganVzcXXigJnDoCBs4oCZw6l0ZW5kdWUgY29tYmluw6llIGRlcyBzb3VyY2VzIGV0IGRlcyBpbnRlcnJ1cHRpb25zLCBwbHVzIDIgbGlnbmVzIGV0IGNvbG9ubmVzLiBTaSBs4oCZYW5hbHlzZSBlc3Qgc2V1bGVtZW50IG7DqWNlc3NhaXJlIGF1IHNlaW4gZOKAmXVuZSBkaXN0YW5jZSBzcMOpY2lmacOpZSDDoCBwYXJ0aXIgZGVzIHNvdXJjZXMsIGxlIHBhcmFtw6h0cmUgRGlzdGFuY2UgbWF4aW1hbGUgcGV1dCDDqnRyZSB1dGlsaXPDqS4gTGEgZm9uY3Rpb24gRGlyZWN0aW9uIGFycmnDqHJlIGV1Y2xpZGllbm5lIHByZW5kIGVuIGNoYXJnZSB1bmUgbcOpdGhvZGUgcGxhbmFpcmUgZXQgdW5lIG3DqXRob2RlIGfDqW9kw6lzaXF1ZSBsb3JzIGR1IGNhbGN1bC4gTGUgY2FsY3VsIGRlIGxhIG3DqXRob2RlIHBsYW5haXJlIGVzdCBlZmZlY3R1w6kgc3VyIHVuZSBzdXJmYWNlIHBsYW5lIHByb2pldMOpZSDDoCBs4oCZYWlkZSBk4oCZdW4gc3lzdMOobWUgZGUgY29vcmRvbm7DqWVzIGNhcnTDqXNpZW5uZXMgMkQuIExlIGNhbGN1bCBkZSBsYSBtw6l0aG9kZSBnw6lvZMOpc2lxdWUgZXN0IGVmZmVjdHXDqSBzdXIgbOKAmWVsbGlwc2/Dr2RlLiBFbiBk4oCZYXV0cmVzIHRlcm1lcywgcXVlbGxlIHF1ZSBzb2l0IGxhIHByb2plY3Rpb24gZW4gZW50csOpZSBvdSBlbiBzb3J0aWUsIGxlcyByw6lzdWx0YXRzIG5lIGNoYW5nZW50IHBhcy48ZGl2Pjxici8+TGVzIHLDqXN1bHRhdHMgZGUgbGEgZm9uY3Rpb24gRGlyZWN0aW9uIGFycmnDqHJlIGV1Y2xpZGllbm5lIHBldXZlbnQgw6p0cmUgdXRpbGlzw6lzIGF2ZWMgbGVzIHLDqXN1bHRhdHMgZGUgbGEgZm9uY3Rpb24gRGlzdGFuY2UgZXVjbGlkaWVubmUgYWZpbiBkZSBkw6l0ZXJtaW5lciBsZXMgY2hlbWlucyBsZXMgcGx1cyBjb3VydHMgw6AgcGFydGlyIGRlcyBlbXBsYWNlbWVudHMgcXVpIHNlIHRyb3V2ZW50IGRhbnMgbGEgem9uZSBk4oCZw6l0dWRlIGp1c3F14oCZw6AgbGEgc291cmNlLiBMZXMgcsOpc3VsdGF0cyBkZSBsYSBkaXJlY3Rpb24gYXJyacOocmUgZXVjbGlkaWVubmUgZXQgZGUgbGEgZGlzdGFuY2UgZXVjbGlkaWVubmUgcGV1dmVudCDDqnRyZSB1dGlsaXPDqXMgZGFucyBsYSBmb25jdGlvbiBDaGVtaW4gZGUgbW9pbmRyZSBjb8O7dCBhaW5zaSBxdWUgbGVzIGRlc3RpbmF0aW9ucyBwb3VyIGTDqXRlcm1pbmVyIGxlcyBjaGVtaW5zIGxlcyBwbHVzIGNvdXJ0cy48L2Rpdj5cIixcblx0XHRleHBhbmROYW1lOiBcIsOJdGVuZHJlXCIsXG5cdFx0ZXhwYW5kU25pcDogXCLDiXRlbmQgZOKAmXVuIG5vbWJyZSBkw6lmaW5pIGRlIGNlbGx1bGVzIGxlcyB6b25lcyBzw6lsZWN0aW9ubsOpZXMgZOKAmXVuIHJhc3RlciBwYXIgem9uZXMuXCIsXG5cdFx0ZXhwYW5kRGVzYzogXCJBdmVjIGxhIGZvbmN0aW9uIGdsb2JhbGUgRMOpdmVsb3BwZXIsIHZvdXMgcG91dmV6IGfDqW7DqXJhbGlzZXIgb3Ugc2ltcGxpZmllciBsZXMgcmFzdGVycyBlbiBhZ3JhbmRpc3NhbnQgZGVzIHpvbmVzIHBhcnRpY3VsacOocmVzLiBWb3VzIHBvdXZleiDDqWdhbGVtZW50IGNvbnRyw7RsZXIgbGUgbml2ZWF1IGRlIGfDqW7DqXJhbGlzYXRpb24gcXVpIGF1cmEgbGlldS48ZGl2Pjxici8+TGEgdGFpbGxlIGRlcyB6b25lcyBzw6lsZWN0aW9ubsOpZXMgYXVnbWVudGUgZW4gc2UgZMOpdmVsb3BwYW50IGRhbnMgZOKAmWF1dHJlcyB6b25lcy4gRW4gdGjDqW9yaWUsIGxlcyB2YWxldXJzIGRlIHpvbmUgc8OpbGVjdGlvbm7DqWVzIHBldXZlbnQgw6p0cmUgdnVlcyBjb21tZSBkZXMgem9uZXMgZGUgcHJlbWllciBwbGFuLCBsZXMgYXV0cmVzIHZhbGV1cnMgcmVzdGFudCBkZXMgem9uZXMgZOKAmWFycmnDqHJlLXBsYW4uIExlcyB6b25lcyBkZSBwcmVtaWVyIHBsYW4gcGV1dmVudCDDqnRyZSDDqXRlbmR1ZXMganVzcXXigJlhdXggem9uZXMgZOKAmWFycmnDqHJlLXBsYW4uPGRpdj48YnIvPkxlIG5pdmVhdSBkZSBnw6luw6lyYWxpc2F0aW9uIHBldXQgw6p0cmUgY29udHLDtGzDqSDDoCBs4oCZYWlkZSBkdSBwYXJhbcOodHJlIE51bWJlciBvZiBDZWxscyAoTm9tYnJlIGRlIGNlbGx1bGVzKS4gUGFyIGTDqWZhdXQsIGNlIHBhcmFtw6h0cmUgYSB1bmUgdmFsZXVyIMOpZ2FsZSDDoCAxLCBjZSBxdWkgc2lnbmlmaWUgcXVlIGxlcyB6b25lcyBzw6lsZWN0aW9ubsOpZXMgc+KAmWFncmFuZGlyb250IGR1IHZvbHVtZSBjb3JyZXNwb25kYW50IMOgIGxhIHRhaWxsZSBk4oCZdW5lIGNlbGx1bGUuIFBvdXIgYXVnbWVudGVyIGxlIGRlZ3LDqSBkZSBnw6luw6lyYWxpc2F0aW9uLCB2b3VzIHBvdXZleiBzcMOpY2lmaWVyIHVuZSB2YWxldXIgc3Vww6lyaWV1cmUgcG91ciBjZSBwYXJhbcOodHJlLiBDZWxhIHJldmllbnQgw6AgdXRpbGlzZXIgbOKAmW91dGlsIHVuIG5vbWJyZSBkZSBmb2lzIMOpcXVpdmFsYW50IGF1IG5vbWJyZSBzcMOpY2lmacOpLCBsZXMgcsOpc3VsdGF0cyBkZSBs4oCZZXjDqWN1dGlvbiBwcsOpY8OpZGVudGUgZm9ybWFudCBs4oCZZW50csOpZSBkZSBs4oCZaXTDqXJhdGlvbiBzdWl2YW50ZS48L2Rpdj5cIixcblx0XHR0cmVuZEFuYWx5c2lzTmFtZTogXCJHw6luw6lyZXIgdW5lIHRlbmRhbmNlXCIsXG5cdFx0dHJlbmRBbmFseXNpc1NuaXA6IFwiRXN0aW1lIGxhIHRlbmRhbmNlIGRlIGNoYXF1ZSBwaXhlbCBzZWxvbiB1bmUgZGltZW5zaW9uIHBvdXIgdW5lIG91IHBsdXNpZXVycyB2YXJpYWJsZXMgZOKAmXVuIHJhc3RlciBtdWx0aWRpbWVuc2lvbm5lbC5cIixcblx0XHR0cmVuZEFuYWx5c2lzRGVzYzogXCI8ZGl2PkNldHRlIGZvbmN0aW9uIHBlcm1ldCBk4oCZYWp1c3RlciBsZXMgZG9ubsOpZXMgc3VyIHVuZSBjb3VyYmUgZGUgdGVuZGFuY2UgbGluw6lhaXJlLCBoYXJtb25pcXVlIG91IHBvbHlub21pYWxlIG91IGRlIGTDqXRlY3RlciBsYSB0ZW5kYW5jZSBhdSBtb3llbiBkdSB0ZXN0IGRlIE1hbm4tS2VuZGFsbCBvdSBLZW5kYWxsIHNhaXNvbm5pZXIuPC9kaXY+PGJyPjxkaXY+TGUgcmFzdGVyIGRlIHRlbmRhbmNlIGVuIHNvcnRpZSBnw6luw6lyw6kgYXZlYyBjZXR0ZSBmb25jdGlvbiBzZXJ0IGVuIGVudHLDqWUgcG91ciBsYSBmb25jdGlvbiA8c3Ryb25nPlByw6lkaXJlIMOgIGzigJlhaWRlIGTigJl1biByYXN0ZXIgZGUgdGVuZGFuY2U8L3N0cm9uZz4uPC9kaXY+PGJyPjxkaXY+TGVzIHRlc3RzIGRlIE1hbm4tS2VuZGFsbCBldCBLZW5kYWxsIHNhaXNvbm5pZXIgZMOpdGVybWluZW50IHNpIGxlcyBkb25uw6llcyBwcsOpc2VudGVudCB1bmUgdGVuZGFuY2UgbW9ub3RvbmlxdWUuIElscyBuZSBzb250IHBhcyBwYXJhbcOpdHJpcXVlcywgY+KAmWVzdC3DoC1kaXJlIHF14oCZaWxzIG5lIGZvcm11bGVudCBhdWN1bmUgaHlwb3Row6hzZSBzdXIgbGEgZGlzdHJpYnV0aW9uIHNww6ljaWZpcXVlIGRlcyBkb25uw6llcy4gTGUgdGVzdCBkZSBNYW5uLUtlbmRhbGwgbmUgY29uc2lkw6hyZSBwYXMgdW5lIGNvcnLDqWxhdGlvbiBzw6lyaWVsbGUgb3UgZGVzIGVmZmV0cyBzYWlzb25uaWVycy4gU2kgbGVzIGRvbm7DqWVzIG9udCB1bmUgc2Fpc29ubmFsaXTDqSwgbGUgdGVzdCBkZSBLZW5kYWxsIHNhaXNvbm5pZXIgZXN0IHBsdXMgYWRhcHTDqS48L2Rpdj48YnI+PGRpdj5TaSBs4oCZb3V0aWwgcsOpYWxpc2UgbGUgdGVzdCBkZSBNYW5uLUtlbmRhbGwgb3UgS2VuZGFsbCBzYWlzb25uaWVyLCBsYSBzb3J0aWUgZXN0IHVuIHJhc3RlciDDoCBjaW5xIGJhbmRlcyBkZSB0eXBlIHN1aXZhbnTCoDo8L2Rpdj48dWw+PGxpPkJhbmRlwqAxID0gUGVudGUgZGUgU2VuIDwvbGk+PGxpPkJhbmRlwqAyID0gVmFsZXVyIGRlIHA8L2xpPjxsaT5CYW5kZcKgMyA9IFNjb3JlIGRlIE1hbm4tS2VuZGFsbCAoUyk8L2xpPjxsaT5CYW5kZcKgNMKgPcKgVmFyaWFuY2UgUzwvbGk+PGxpPkJhbmRlwqA0wqA9wqBWYXJpYW5jZSBTPC9saT48bGk+QmFuZGXCoDXCoD3CoFNjb3JlIHo8L2xpPjwvdWw+PGRpdj5MZXMgc29ydGllcyBkZXMgdGVzdHMgZGUgTWFubi1LZW5kYWxsIG91IEtlbmRhbGwgc2Fpc29ubmllciBwZXJtZXR0ZW50IGRlIGTDqXRlcm1pbmVyIGxlcyBwaXhlbHMgZGUgdm90cmUgc8OpcmllIGNocm9ub2xvZ2lxdWUgbXVsdGlkaW1lbnNpb25uZWxsZSBxdWkgcHLDqXNlbnRlbnQgdW5lIHRlbmRhbmNlIHN0YXRpc3RpcXVlbWVudCBzaWduaWZpY2F0aXZlLiBWb3VzIHBvdXZleiB1dGlsaXNlciBjZXR0ZSBpbmZvcm1hdGlvbiBhdmVjIHVuZSBhbmFseXNlIGRlIHRlbmRhbmNlIGxpbsOpYWlyZSwgaGFybW9uaXF1ZSBvdSBwb2x5bm9taWFsZSBwb3VyIGV4dHJhaXJlIGxlcyB0ZW5kYW5jZXMgc2lnbmlmaWNhdGl2ZXMgZGUgdm9zIHPDqXJpZXMgdGVtcG9yZWxsZXMuIFZvdXMgZ8OpbsOpcmV6IHVuIG1hc3F1ZSBjb21wb3J0YW50IGxlcyBwaXhlbHMgYXZlYyB1bmUgdmFsZXVyIGRlIHAgc2lnbmlmaWNhdGl2ZSwgYXBwbGlxdWV6IGxlIG1hc3F1ZSBhdSByYXN0ZXIgbXVsdGlkaW1lbnNpb25uZWwgZXQgdXRpbGlzZXogY2UgcmFzdGVyIG11bHRpZGltZW5zaW9ubmVsIG1hc3F1w6kgY29tbWUgZW50csOpZSBkZSBs4oCZb3V0aWwgcG91ciBlZmZlY3R1ZXIgdW5lIGFuYWx5c2UgZGUgdGVuZGFuY2UgbGluw6lhaXJlLCBoYXJtb25pcXVlIG91IHBvbHlub21pYWxlLjwvZGl2Pjxicj48ZGl2PklsIGV4aXN0ZSB0cm9pcyBvcHRpb25zIGRlIGxpZ25lIGRlIHRlbmRhbmNlIHBvdXIgYWp1c3RlciB1bmUgdGVuZGFuY2UgYXV4IHZhbGV1cnMgZGVzIHZhcmlhYmxlcyBsZSBsb25nIGTigJl1bmUgZGltZW5zaW9uwqA6IGxpbsOpYWlyZSwgaGFybW9uaXF1ZSBldCBwb2x5bm9taWFsZS48L2Rpdj48YnI+PGRpdj5Qb3VyIGzigJlhbmFseXNlIGRlIHRlbmRhbmNlIGxpbsOpYWlyZSwgbGEgc29ydGllIGVzdCB1biByYXN0ZXIgw6AgdHJvaXMgYmFuZGVzwqBkdSB0eXBlIHN1aXZhbnTCoDo8L2Rpdj48dWw+PGxpPkJhbmRlwqAxID0gUGVudGU8L2xpPjxsaT5CYW5kZcKgMiA9IE9yZG9ubsOpZSDDoCBs4oCZb3JpZ2luZTwvbGk+PGxpPkJhbmRlwqAzwqA9wqBSYWNpbmUgY2FycsOpZSBkZSBs4oCZZXJyZXVyIHF1YWRyYXRpcXVlIG1veWVubmUgKEVRTSkgb3UgZXJyZXVyIGF1dG91ciBkZSBsYSBsaWduZSBkZSBjb21wcm9taXM8L2xpPjwvdWw+PGRpdj5Qb3VyIGzigJlhbmFseXNlIGRlIHRlbmRhbmNlIHBvbHlub21pYWxlLCBsZSBub21icmUgZGUgY2FuYXV4IGRhbnMgbGEgc29ydGllIGTDqXBlbmQgZHUgZGVncsOpIHBvbHlub21pYWwuIFVuIGFqdXN0ZW1lbnQgcG9seW5vbWlhbCBkdSBkZXV4acOobWUgZGVncsOpIGfDqW7DqHJlIHVuIHJhc3RlciDDoCBxdWF0cmUgYmFuZGVzIGRlIHR5cGUgc3VpdmFudMKgOiA8L2Rpdj48dWw+PGxpPkJhbmRlwqAxID0gUG9seW5vbWlhbF8yPC9saT48bGk+QmFuZGXCoDIgPSBQb2x5bm9taWFsXzE8L2xpPjxsaT5CYW5kZcKgMyA9IFBvbHlub21pYWxfMDwvbGk+PGxpPkJhbmRlwqA0ID0gRVFNPC9saT48L3VsPjxkaXY+VW4gYWp1c3RlbWVudCBwb2x5bm9taWFsIGR1IHRyb2lzacOobWUgZGVncsOpIGfDqW7DqHJlIHVuIHJhc3RlciDDoCBjaW5xIGNhbmF1eCBkZSB0eXBlIHN1aXZhbnTCoDo8L2Rpdj48dWw+PGxpPkJhbmRlIDEgPSBQb2x5bm9taWFsXzM8L2xpPjxsaT5CYW5kZSAyID0gUG9seW5vbWlhbF8yPC9saT48bGk+QmFuZGUgMyA9IFBvbHlub21pYWxfMTwvbGk+PGxpPkJhbmRlIDQgPSBQb2x5bm9taWFsXzA8L2xpPjxsaT5CYW5kZSA1ID0gRVFNPC9saT48L3VsPjxkaXY+UG91ciBs4oCZYW5hbHlzZSBkZSB0ZW5kYW5jZSBoYXJtb25pcXVlLCBsZSBub21icmUgZGUgY2FuYXV4IGRhbnMgbGEgc29ydGllIGTDqXBlbmQgZGUgbGEgZnLDqXF1ZW5jZSBoYXJtb25pcXVlLiBTaSBsYSBmcsOpcXVlbmNlIGVzdCBkw6lmaW5pZSBzdXLCoDEsIGxhIHNvcnRpZSBlc3QgdW4gcmFzdGVyIMOgIGNpbnEgYmFuZGVzIGRlIHR5cGUgc3VpdmFudMKgOjwvZGl2Pjx1bD48bGk+QmFuZGUgMSA9IFBlbnRlPC9saT48bGk+QmFuZGXCoDIgPSBPcmRvbm7DqWUgw6AgbOKAmW9yaWdpbmU8L2xpPjxsaT5CYW5kZcKgMyA9IEhhcm1vbmljX3NpbjE8L2xpPjxsaT5DYW5hbMKgNCA9IEhhcm1vbmljX2NvczE8L2xpPjxsaT5CYW5kZcKgNSA9IEVRTTwvbGk+PC91bD48ZGl2PlNpIGxhIGZyw6lxdWVuY2UgZXN0IGTDqWZpbmllIHN1csKgMiwgbGEgc29ydGllIGVzdCB1biByYXN0ZXIgw6Agc2VwdCBjYW5hdXggZGUgdHlwZSBzdWl2YW50wqA6PC9kaXY+PHVsPjxsaT5CYW5kZSAxID0gUGVudGU8L2xpPjxsaT5CYW5kZcKgMiA9IE9yZG9ubsOpZSDDoCBs4oCZb3JpZ2luZTwvbGk+PGxpPkJhbmRlIDMgPSBIYXJtb25pY19zaW4xPC9saT48bGk+QmFuZGUgNCA9IEhhcm1vbmljX2NvczE8L2xpPjxsaT5CYW5kZSA1ID0gSGFybW9uaWNfc2luMjwvbGk+PGxpPkJhbmRlIDYgPSBIYXJtb25pY19jb3MyPC9saT48bGk+QmFuZGUgNyA9IEVRTTwvbGk+PC91bD48ZGl2PkxlIHBhcmFtw6h0cmUgPHN0cm9uZz5EdXLDqWUgZHUgY3ljbGU8L3N0cm9uZz4gcG91ciBs4oCZYW5hbHlzZSBkZXMgdGVuZGFuY2VzIGhhcm1vbmlxdWVzIGVzdCB1dGlsaXPDqSBwb3VyIGluZGlxdWVyIGxlIG5vbWJyZSBldCBsYSBkdXLDqWUgZGVzIGN5Y2xlcyBxdWUgdm91cyB2b3VzIGF0dGVuZGV6IMOgIHZvaXIgZGFucyB2b3MgZG9ubsOpZXMgdG91dCBhdSBsb25nIGTigJl1bmUgam91cm7DqWUgb3UgZOKAmXVuZSBhbm7DqWUuIFNpLCBwYXIgZXhlbXBsZSwgdm91cyBwcsOpdm95ZXogcXVlIHZvcyBkb25uw6llcyBjb25uYWlzc2VudCBkZXV4IGN5Y2xlcyBkZSB2YXJpYXRpb24gZGFucyBs4oCZYW5uw6llLCBsYSBkdXLDqWUgZHUgY3ljbGUgc2VyYSBkZSAxODIsNcKgam91cnMsIHNvaXQgMCw1wqBhbi4gU2kgdm91cyBkw6l0ZW5leiBkZXMgZG9ubsOpZXMgZGUgdGVtcMOpcmF0dXJlIGNvbGxlY3TDqWVzIHRvdXRlcyBsZXMgdHJvaXMgaGV1cmVzIGV0IHF14oCZZWxsZXMgcHLDqXNlbnRlbnQgdW4gY3ljbGUgZGUgdmFyaWF0aW9uIHBhciBqb3VyLCBsYSBkdXLDqWUgZHUgY3ljbGUgY29ycmVzcG9uZCDDoCAxwqBqb3VyLjwvZGl2Pjxicj48ZGl2PkxlIHBhcmFtw6h0cmUgPHN0cm9uZz5GcsOpcXVlbmNlPC9zdHJvbmc+IHBvdXIgbOKAmWFuYWx5c2UgZGVzIHRlbmRhbmNlcyBoYXJtb25pcXVlcyBlc3QgdXRpbGlzw6kgcG91ciBkw6ljcmlyZSBsZSBtb2TDqGxlIGhhcm1vbmlxdWUgw6AgYWp1c3RlciBhdXggZG9ubsOpZXMuIFNpIGxhIGZyw6lxdWVuY2UgZXN0IGTDqWZpbmllIHN1ciAxLCB1bmUgY29tYmluYWlzb24gZGUgdGVuZGFuY2UgbGluw6lhaXJlIGV0IGRlIGNvdXJiZSBoYXJtb25pcXVlIGRlIHByZW1pZXIgZGVncsOpIGVzdCB1dGlsaXPDqWUgcG91ciBhanVzdGVyIGxlIG1vZMOobGUuIFNpIGxhIGZyw6lxdWVuY2UgZXN0IGTDqWZpbmllIHN1csKgMiwgdW5lIGNvbWJpbmFpc29uIGRlIHRlbmRhbmNlIGxpbsOpYWlyZSwgZGUgY291cmJlIGhhcm1vbmlxdWUgZGUgcHJlbWllciBkZWdyw6kgbGluw6lhaXJlIGV0IGRlIGNvdXJiZSBoYXJtb25pcXVlIGRlIHNlY29uZCBkZWdyw6kgZXN0IHV0aWxpc8OpZSBwb3VyIGFqdXN0ZXIgbGVzIGRvbm7DqWVzLiBTaSBsYSBmcsOpcXVlbmNlIGVzdCAzLCB1bmUgY291cmJlIGhhcm1vbmlxdWUgZGUgdHJvaXNpw6htZSBkZWdyw6kgc3VwcGzDqW1lbnRhaXJlIGVzdCB1dGlsaXPDqWUgcG91ciBtb2TDqWxpc2VyIGxlcyBkb25uw6llcyBldCBhaW5zaSBkZSBzdWl0ZS48L2Rpdj48YnI+PGRpdj5JbCBlc3QgcG9zc2libGUgZGUgZ8OpbsOpcmVyIGRlcyBzdGF0aXN0aXF1ZXMgZGUgcXVhbGl0w6kgZGUgbOKAmWFqdXN0ZW1lbnQgZHUgbW9kw6hsZSBzb3VzIGZvcm1lIGRlIHNvcnRpZXMgZmFjdWx0YXRpdmVzLiBM4oCZZXJyZXVyIHF1YWRyYXRpcXVlIG1veWVubmUgKEVRTSksIGxhIHZhbGV1ciBSLWNhcnLDqSBldCBsYSB2YWxldXIgUCBkZSBwZW50ZSBkZSBsYSB0ZW5kYW5jZSBwZXV2ZW50IMOqdHJlIGNhbGN1bMOpZXMgZXQgc3ltYm9saXPDqWVzLiBTeW1ib2xpc2V6IGxhIGNvdWNoZSByYXN0ZXIgZGUgbGEgdGVuZGFuY2UgZW4gc29ydGllIMOgIGzigJlhaWRlIGRlIGxhIHN5bWJvbG9naWUgPHN0cm9uZz5SVkI8L3N0cm9uZz4gZXQgc3DDqWNpZmlleiBsZXMgc3RhdGlzdGlxdWVzIHNvdXMgZm9ybWUgZGUgY2FuYXV4IHJvdWdlcywgdmVydHMgZXQgYmxldXMuPC9kaXY+PGJyPlwiLFxuXHRcdHNwZWN0cmFsVW5taXhpbmdOYW1lOiBcIkTDqW1peGFnZSBzcGVjdHJhbCBsaW7DqWFpcmVcIixcblx0XHRzcGVjdHJhbFVubWl4aW5nU25pcDogXCJFZmZlY3R1ZSB1bmUgY2xhc3NpZmljYXRpb24gaW5mw6lyaWV1cmUgYXUgcGl4ZWwgZXQgY2FsY3VsZSBs4oCZYWJvbmRhbmNlIGZyYWN0aW9ubmVsbGUgZGUgZGlmZsOpcmVudHMgdHlwZXMgZOKAmW9jY3VwYXRpb24gZHUgc29sIHBvdXIgbGVzIHBpeGVscyBpbmRpdmlkdWVscy5cIixcblx0XHRzcGVjdHJhbFVubWl4aW5nRGVzYzogXCJMYSBmb25jdGlvbiBEw6ltaXhhZ2Ugc3BlY3RyYWwgbGluw6lhaXJlIGNhbGN1bGUgbGEgY291dmVydHVyZSBmcmFjdGlvbm5lbGxlIHBvdXIgZGVzIHBpeGVscyBjb250ZW5hbnQgcGx1c2lldXJzIHR5cGVzIGTigJlvY2N1cGF0aW9uIGR1IHNvbC4gRWxsZSBnw6luw6hyZSB1bmUgY291Y2hlIG11bHRpY2FuYWxlIGRhbnMgbGFxdWVsbGUgY2hhcXVlIGNhbmFsIGNvcnJlc3BvbmQgw6AgbOKAmWFib25kYW5jZSBmcmFjdGlvbm5lbGxlIGTigJl1bmUgY2xhc3NlIGTigJlvY2N1cGF0aW9uIGR1IHNvbC4gUGFyIGV4ZW1wbGUsIHZvdXMgcG91dmV6IGzigJl1dGlsaXNlciBwb3VyIHByb2PDqWRlciDDoCBsYSBjbGFzc2lmaWNhdGlvbiBkZXMgb2NjdXBhdGlvbnMgZHUgc29sIHN1ciB1bmUgaW1hZ2UgbXVsdGlzcGVjdHJhbGUgYWZpbiBk4oCZaWRlbnRpZmllciBsYSB2w6lnw6l0YXRpb24gcGhvdG9zeW50aMOpdGlxdWUsIGxlIHNvbCBudWwsIGxhIHbDqWfDqXRhdGlvbiBtb3J0ZSBvdSBub24gcGhvdG9zeW50aMOpdGlxdWUuPGRpdj48YnIvPkzigJlvcmRyZSBkdSByYXN0ZXIgbXVsdGljYW5hbCBlbiBzb3J0aWUgcmVmbMOodGUgbOKAmW9yZHJlIGR1IHByb2ZpbCBzcGVjdHJhbCBlbiBlbnRyw6llLiBMZSBub21icmUgZGUgY2xhc3NlcyBuZSBkb2l0IHBhcyBkw6lwYXNzZXIgbGUgbm9tYnJlIGRlIGNhbmF1eCBkdSByYXN0ZXIgZW4gZW50csOpZS4gUGFyIGV4ZW1wbGUsIHZvdXMgbmUgcG91dmV6IHBhcyBleHRyYWlyZSBkZXMgaW5mb3JtYXRpb25zIHN1ciBwbHVzIGRlIDggY2xhc3NlcyDDoCBwYXJ0aXIgZOKAmXVuIHJhc3RlciDDoCA4IGNhbmF1eC48L2Rpdj5cIixcblx0XHRtdWx0aWRpbWVuc2lvbmFsRmlsdGVyTmFtZTogXCJGaWx0cmUgbXVsdGlkaW1lbnNpb25uZWxcIixcblx0XHRpbnRlcnBvbGF0ZVJhc3RlckJ5RGltZW5zaW9uRnVuY3Rpb25OYW1lOiBcIkludGVycG9sZXIgdW4gcmFzdGVyIHBhciBkaW1lbnNpb25cIixcblx0XHRpbnRlcnBvbGF0ZVJhc3RlckJ5RGltZW5zaW9uRnVuY3Rpb25TbmlwOiBcIkludGVycG9sZSB1biByYXN0ZXIgbXVsdGlkaW1lbnNpb25uZWwgw6AgZGVzIHZhbGV1cnMgZGUgZGltZW5zaW9uIHNww6ljaWZpw6llcyDDoCBs4oCZYWlkZSBkZXMgdHJhbmNoZXMgYWRqYWNlbnRlcy5cIixcblx0XHRpbnRlcnBvbGF0ZVJhc3RlckJ5RGltZW5zaW9uRnVuY3Rpb25EZXNjOiBcIjxwPkNldHRlIGZvbmN0aW9uIHZvdXMgcGVybWV0IGTigJllc3RpbWVyIGxlcyB2YWxldXJzIGVuIHBpeGVscyBk4oCZdW5lIHRyYW5jaGUgZGltZW5zaW9ubmVsbGUgbm9uIGTDqWZpbmllIGRhbnMgdW4gcmFzdGVyIG11bHRpZGltZW5zaW9ubmVsLiBQYXIgZXhlbXBsZSwgc2kgdW4gamV1IGRlIGRvbm7DqWVzIGNvbnRpZW50IGxhIHRlbXDDqXJhdHVyZSBkZSBs4oCZb2PDqWFuIGVuIHN1cmZhY2UgZXQgMTAwwqBtw6h0cmVzIHNvdXMgbGUgbml2ZWF1IGRlIGxhIG1lciBldCBxdWUgdm91cyBzb3VoYWl0ZXogZXN0aW1lciBsYSB0ZW1ww6lyYXR1cmUgNTDCoG3DqHRyZXMgc291cyBsZSBuaXZlYXUgZGUgbGEgbWVyLCB2b3VzIHBvdXZleiB1dGlsaXNlciBjZXR0ZSBmb25jdGlvbiBwb3VyIG9idGVuaXIgdW5lIGVzdGltYXRpb24gw6AgY2V0dGUgcHJvZm9uZGV1ciDDoCBs4oCZYWlkZSBkZSBsYSBkw6lmaW5pdGlvbiBkZSBsYSBkaW1lbnNpb24gUGFyIHZhbGV1cnMuPC9wPjxwPlZvdXMgcG91dmV6IMOpZ2FsZW1lbnQgc291cy3DqWNoYW50aWxsb25uZXIgdW4gamV1IGRlIGRvbm7DqWVzIG1lbnN1ZWwgZGFucyB1biBqZXUgZGUgZG9ubsOpZXMgcXVvdGlkaWVuIGVuIHV0aWxpc2FudCBsYSBkw6lmaW5pdGlvbiBkZSBsYSBkaW1lbnNpb24gUGFyIGludGVydmFsbGUgZXQgZW4gc3DDqWNpZmlhbnQgbGEgdmFsZXVywqAxIHBvdXIgbGUgcGFyYW3DqHRyZSDDiXRhcGUgZXQgbGEgdmFsZXVyIEpvdXJzIHBvdXIgbGUgcGFyYW3DqHRyZSBVbml0w6kuPC9wPjxwPlV0aWxpc2V6IGxhIGTDqWZpbml0aW9uIGRlIGxhIGRpbWVuc2lvbiBQYXIgcmFzdGVyIGNpYmxlIHBvdXIgZXN0aW1lciBsYSB2YWxldXIgZGUgUmFzdGVyIGNpYmxlLjwvcD5cIixcblx0XHRtdWx0aWRpbWVuc2lvbmFsRmlsdGVyU25pcDogXCJDcsOpZSB1bmUgY291Y2hlIHJhc3RlciDDoCBwYXJ0aXIgZOKAmXVuIGpldSBkZSBkb25uw6llcyByYXN0ZXIgbXVsdGlkaW1lbnNpb25uZWxsZXMgb3UgZOKAmXVuZSBjb3VjaGUgcmFzdGVyIG11bHRpZGltZW5zaW9ubmVsbGUgZW4gZMOpY291cGFudCBkZXMgdHJhbmNoZXMgZGUgZG9ubsOpZXMgbGUgbG9uZyBkZSB2YXJpYWJsZXMgZXQgZGUgZGltZW5zaW9ucyBkw6lmaW5pZXMuXCIsXG5cdFx0bXVsdGlkaW1lbnNpb25hbEZpbHRlckRlc2M6IFwiTGUgRmlsdHJlIG11bHRpZGltZW5zaW9ubmVsIGNyw6llIHVuZSBjb3VjaGUgcmFzdGVyIG11bHRpbWVuc2lvbm5lbGxlIGVuIGZpbHRyYW50IGV0IGV4dHJheWFudCB1biBzb3VzLWVuc2VtYmxlIGRlIHZhcmlhYmxlcyDDoCBwYXJ0aXIgZOKAmXVuIHJhc3RlciBtdWx0aW1lbnNpb25uZWwuIFZvdXMgcG91dmV6IGFpbnNpIGRpc3Bvc2VyIGTigJl1biBqZXUgZGUgZG9ubsOpZXMgbXVsdGlkaW1lbnNpb25uZWwgY29udGVuYW50IDMwIGFubsOpZXMgZGUgZG9ubsOpZXMgZGUgcHLDqWNpcGl0YXRpb25zIG1lbnN1ZWxsZXMgZXQgc291aGFpdGVyIGV4dHJhaXJlIHVuaXF1ZW1lbnQgbGVzIGRvbm7DqWVzIGRlIGNoYXF1ZSBtb2lzIGRlIGphbnZpZXIgYWZpbiBk4oCZb2JzZXJ2ZXIgbOKAmcOpdm9sdXRpb24gZGVzIHByw6ljaXBpdGF0aW9ucyBwb3VyIGNlIG1vaXMuPGRpdj48YnIvPlV0aWxpc2V6IGxlIHBhcmFtw6h0cmUgRGltZW5zaW9uIERlZmluaXRpb24gKETDqWZpbml0aW9uIGRlIGxhIGRpbWVuc2lvbikgcG91ciBkw6ljb3VwZXIgZGVzIHRyYW5jaGVzIGRlIGRpbWVuc2lvbnMgw6AgbOKAmWFpZGUgZOKAmXVuIGludGVydmFsbGUsIGTigJl1bmUgdmFsZXVyIG91IGTigJl1bmUgcGxhZ2UgZGUgdmFsZXVycy4gU2ksIHBhciBleGVtcGxlLCB2b3VzIHBvc3PDqWRleiAxMCBhbnMgZGUgZG9ubsOpZXMgcmVsYXRpdmVzIMOgIGxhIHNhbGluaXTDqSBkZXMgb2PDqWFucywgcmVjdWVpbGxpZXMgbWVuc3VlbGxlbWVudCBldCB0b3VzIGxlcyAyIG3DqHRyZXMgZGUgcHJvZm9uZGV1ciBqdXNxdeKAmcOgIDUwMCBtw6h0cmVzLCB2b3VzIHBvdXZleiB1dGlsaXNlciBsZXMgZGlmZsOpcmVudGVzIG9wdGlvbnMgZGUgZMOpZmluaXRpb24gZGUgbGEgZGltZW5zaW9uIHBvdXIgbGVzIHNjw6luYXJpb3Mgc3VpdmFudHMuIFNjw6luYXJpbyAxIDogRXh0cmFpcmUgbGVzIGRvbm7DqWVzIHJlbGF0aXZlcyDDoCBsYSBzYWxpbml0w6kgcG91ciBsZSBtb2lzIGRlIGphbnZpZXIgc3VyIGxhIHDDqXJpb2RlIGRlIDEwIGFucy4gU8OpbGVjdGlvbm5leiBCeSBWYWx1ZXMgKFBhciB2YWxldXJzKSwgZMOpZmluaXNzZXogRGltZW5zaW9uIHN1ciBTdGRUaW1lIGV0IFZhbHVlcyAoVmFsZXVycykgc3VyIEphbnVhcnkgKEphbnZpZXIpLiBTY8OpbmFyaW8gMiA6IETDqWNvdXBlciBkZXMgdHJhbmNoZXMgZGUgZG9ubsOpZXMgcmVsYXRpdmVzIMOgIGxhIHNhbGluaXTDqSBzdXIgdW5lIHBsYWdlIGRlIHByb2ZvbmRldXIgYWxsYW50IGRlIDAgw6AgMTUwIG3DqHRyZXMuIFPDqWxlY3Rpb25uZXogQnkgUmFuZ2VzIChQYXIgcGxhZ2VzKSwgZMOpZmluaXNzZXogRGltZW5zaW9uIHN1ciBTdGRaLCBNaW5pbXVtIFZhbHVlIChWYWxldXIgbWluaW1hbGUpIHN1ciAtMTUwIGV0IE1heGltdW0gVmFsdWUgKFZhbGV1ciBtYXhpbWFsZSkgc3VyIDAuIFNjw6luYXJpbyAzIDogRXh0cmFpcmUgbGVzIGRvbm7DqWVzIHJlbGF0aXZlcyDDoCBsYSBzYWxpbml0w6kgcG91ciBsZXMgMTAgcHJlbWllcnMgam91cnMgZHUgbW9pcyBkZSBqYW52aWVyIHN1ciB1bmUgcMOpcmlvZGUgZGUgMTAgYW5zLiBTw6lsZWN0aW9ubmV6IEJ5IEl0ZXJhdGlvbiAoUGFyIGl0w6lyYXRpb24pLCBkw6lmaW5pc3NleiBEaW1lbnNpb24gc3VyIFN0ZFRpbWUsIGTDqWZpbmlzc2V6IFN0YXJ0IG9mIGZpcnN0IGl0ZXJhdGlvbiAoRMOpYnV0IGRlIGxhIHByZW1pw6hyZSBpdMOpcmF0aW9uKSBldCBFbmQgb2YgZmlyc3QgaXRlcmF0aW9uIChGaW4gZGUgbGEgcHJlbWnDqHJlIGl0w6lyYXRpb24pIHN1ciBsZSBkw6lidXQgZXQgbGEgZmluIGNvcnJlc3BvbmRhbnRzIGRlIGxhIHDDqXJpb2RlIGTigJlpdMOpcmF0aW9uLCBkw6lmaW5pc3NleiBTdGVwICjDiXRhcGUpIHN1ciAxLCBwdWlzIGTDqWZpbmlzc2V6IFVuaXQgKFVuaXTDqSkgc3VyIFllYXJzIChBbm7DqWVzKS48L2Rpdj5cIixcblx0XHRtdWx0aWRpbWVuc2lvbmFsUmFzdGVyTmFtZTogXCJSYXN0ZXIgbXVsdGlkaW1lbnNpb25uZWxcIixcblx0XHRtdWx0aWRpbWVuc2lvbmFsUmFzdGVyU25pcDogXCJBam91dGUgZGVzIGRvbm7DqWVzIG11bHRpZGltZW5zaW9ubmVsbGVzIMOgIHVuZSBjYXJ0ZSBzb3VzIGZvcm1lIGRlIGNvdWNoZSByYXN0ZXIgbXVsdGltZW5zaW9ubmVsbGUuXCIsXG5cdFx0bXVsdGlkaW1lbnNpb25hbFJhc3RlckRlc2M6IFwiTGEgZm9uY3Rpb24gUmFzdGVyIG11bHRpZGltZW5zaW9ubmVsIGFqb3V0ZSBkZXMgZG9ubsOpZXMgbXVsdGlkaW1lbnNpb25uZWxsZXMgc3VyIHVuZSBjYXJ0ZSBlbiB0YW50IHF1ZSBjb3VjaGUgcmFzdGVyIG11bHRpZGltZW5zaW9ubmVsbGUuIENldHRlIGZvbmN0aW9uIGVzdCB1dGlsZSBsb3JzIGRlIGzigJlleMOpY3V0aW9uIGRlIHByb2Nlc3N1cyBk4oCZYW5hbHlzZSBkZSByYXN0ZXIgw6AgbOKAmWFpZGUgZOKAmXVuZSBjaGHDrm5lIGRlIGZvbmN0aW9ucy48ZGl2Pjxici8+TGVzIGpldXggZGUgZG9ubsOpZXMgcmFzdGVyIG11bHRpZGltZW5zaW9ubmVsbGVzIGluY2x1ZW50IGxlcyBmb3JtYXRzIG5ldENERiwgR1JJQiwgSERGIGV0IENSRiBk4oCZRXNyaS4gTGVzIGpldXggZGUgZG9ubsOpZXMgbW9zYcOvcXVlIG11bHRpZGltZW5zaW9ubmVsbGVzIHNvbnQgw6lnYWxlbWVudCBwcmlzIGVuIGNoYXJnZS48L2Rpdj5cIixcblx0XHRvcHRpbWFsUGF0aEFzUmFzdGVyTmFtZTogXCJDaGVtaW4gb3B0aW1hbCBjb21tZSByYXN0ZXJcIixcblx0XHRvcHRpbWFsUGF0aEFzUmFzdGVyU25pcDogXCJDYWxjdWxlIGxlIGNoZW1pbiBkZSBtb2luZHJlIGNvw7t0IGVudHJlIHVuZSBzb3VyY2UgZXQgdW5lIGRlc3RpbmF0aW9uLlwiLFxuXHRcdG9wdGltYWxQYXRoQXNSYXN0ZXJEZXNjOiBcIkNldHRlIGZvbmN0aW9uIGdsb2JhbGUgcGVybWV0IGTigJlvYnRlbmlyIHVuIHJhc3RlciBlbiBzb3J0aWUgcXVpIGVucmVnaXN0cmUgbGUgY2hlbWluIG9wdGltYWwgb3UgbGVzIGNoZW1pbnMgb3B0aW1hdXggY29ycmVzcG9uZGFudCBhdXggZW1wbGFjZW1lbnRzIHPDqWxlY3Rpb25uw6lzIHBhciByYXBwb3J0IMOgIGxhIGNlbGx1bGUgc291cmNlIGxhIHBsdXMgcHJvY2hlIHF1ZSB2b3VzIGF2ZXogZMOpZmluaWUgZGFucyBsYSBzdXJmYWNlIGRlIGNvw7t0cyBjdW11bMOpcyAobm91cyB0ZW5vbnMgY29tcHRlIGRlcyBkaXN0YW5jZXMgZGUgY2/Du3QpLjxkaXY+PGJyLz5VbmUgb3UgcGx1c2lldXJzIGRlcyBmb25jdGlvbnMgZGUgY2FsY3VsIGRlcyBjb8O7dHMgcG9uZMOpcsOpcyAoQWNjdW11bGF0aW9uIGRlIGRpc3RhbmNlIG91IEFsbG9jYXRpb24gZGUgZGlzdGFuY2UpIGRvaXZlbnQgZ8OpbsOpcmFsZW1lbnQgw6p0cmUgZXjDqWN1dMOpZXMgYXZhbnQgZGUgbGFuY2VyIGxhIGZvbmN0aW9uIHJhc3RlciBDaGVtaW4gb3B0aW1hbCBjb21tZSByYXN0ZXIgcG91ciBjcsOpZXIgbGVzIHJhc3RlcnMgZOKAmWFjY3VtdWxhdGlvbiBkZSBkaXN0YW5jZSBldCBkZSBkaXJlY3Rpb24gYXJyacOocmUgZW4gZW50csOpZS4gQ2VzIGNvdWNoZXMgcmFzdGVyIGVuIGVudHLDqWUgc29udCBvYmxpZ2F0b2lyZXMgc2kgdm91cyBzb3VoYWl0ZXogdXRpbGlzZXIgbGEgZm9uY3Rpb24gQ2hlbWluIG9wdGltYWwuIExlcyB2YWxldXJzIGR1IGNoZW1pbiBvcHRpbWFsIGVuIHNvcnRpZSByZXByw6lzZW50ZW50IGxlIG5vbWJyZSBkZSBjaGVtaW5zIMOgIHVuIGVtcGxhY2VtZW50IGRvbm7DqS4gRGFucyBkZSBub21icmV1eCBjYXMsIGxlcyBjaGVtaW5zIHN1aXZlbnQgbGUgbcOqbWUgaXRpbsOpcmFpcmUsIHF1aXR0YW50IHVuZSBzb3VyY2UgcHVpcyBkaXZlcmdlYW50IHBvdXIgc2UgcmVuZHJlIMOgIHVuZSBkZXN0aW5hdGlvbiBwcm9wcmUgw6AgY2hhY3VuLiBQYXIgZXhlbXBsZSwgbGEgdmFsZXVyIHVuIGluZGlxdWUgcXXigJlpbCBu4oCZZXhpc3RlIHF14oCZdW4gc2V1bCBjaGVtaW4gb3B0aW1hbCDDoCB1biBlbXBsYWNlbWVudCBkb25uw6ksIHRhbmRpcyBxdWUgbGEgdmFsZXVyIGNpbnEgaW5kaXF1ZSBxdeKAmcOgIGNldCBlbXBsYWNlbWVudCBpbCBleGlzdGUgY2lucSBjaGVtaW5zIG9wdGltYXV4IHRyYXZlcnNhbnQgY2V0dGUgY2VsbHVsZSBkYW5zIGxhIHpvbmUgZOKAmcOpdHVkZS48ZGl2Pjxici8+TGVzIGRvbm7DqWVzIGRlIGRlc3RpbmF0aW9uIGVuIGVudHLDqWUgZG9pdmVudCBjb3JyZXNwb25kcmUgw6AgdW5lIGNvdWNoZSByYXN0ZXIuIEzigJllbnNlbWJsZSBkZXMgY2VsbHVsZXMgZGUgZGVzdGluYXRpb24gZW5nbG9iZSB0b3V0ZXMgbGVzIGNlbGx1bGVzIGR1IHJhc3RlciBlbiBlbnRyw6llIGNvbXByZW5hbnQgZGVzIHZhbGV1cnMgYXV0b3Jpc8OpZXMuIExlcyBjZWxsdWxlcyBhc3NvY2nDqWVzIMOgIGxhIHZhbGV1ciBOb0RhdGEgbmUgZmlndXJlbnQgcGFzIGRhbnMgbOKAmWVuc2VtYmxlLiBMYSB2YWxldXIgesOpcm8gZXN0IHVuZSBkZXN0aW5hdGlvbiBwZXJ0aW5lbnRlLiBWb3VzIHBvdXZleiBjcsOpZXIgdW4gcmFzdGVyIGRlIGRlc3RpbmF0aW9uIMOgIGzigJlhaWRlIGRlcyBvdXRpbHMgZOKAmWV4dHJhY3Rpb24uIFNpIHZvdXMgYXZleiBkZXMgZW50aXTDqXMgc291cmNlIG91IGRlIGRlc3RpbmF0aW9uLCB2b3VzIHBvdXZleiBsZXMgY29udmVydGlyIGVuIHJhc3RlciDDoCBs4oCZYWlkZSBkZSBsYSBmb25jdGlvbiBSYXN0ZXJpc2VyIGxlcyBlbnRpdMOpcy4gVXRpbGlzZXogbGUgcmFzdGVyIGTigJlhY2N1bXVsYXRpb24gZGUgZGlzdGFuY2Ugb3UgbGUgcmFzdGVyIGRlIGRpcmVjdGlvbiBhcnJpw6hyZSBjb21tZSByYXN0ZXIgZW4gZW50csOpZSBwb3VyIGxhIGZvbmN0aW9uIGRlIHRyYW1hZ2UuIFZvdXMgYXVyZXogYWluc2kgbOKAmWFzc3VyYW5jZSBxdWUgbOKAmWVudGl0w6kgc2VyYSByYXN0ZXJpc8OpZSBhdmVjIGxlcyBtw6ptZXMgcGFyYW3DqHRyZXMgKMOpdGVuZHVlIGRlcyBkb25uw6llcywgcsOpZsOpcmVuY2Ugc3BhdGlhbGUgZXQgdGFpbGxlIGRlIGNlbGx1bGUpIHF1ZSBsZXMgYXV0cmVzIHJhc3RlcnMgdHJhaXTDqXMgcGFyIGxhIGZvbmN0aW9uIENoZW1pbiBvcHRpbWFsIGNvbW1lIHJhc3Rlci4gVm91cyBwb3V2ZXogw6lnYWxlbWVudCB1dGlsaXNlciBsYSBmb25jdGlvbiBDaGVtaW4gb3B0aW1hbCBjb21tZSByYXN0ZXIgcG91ciBvYnRlbmlyIGxlIGNoZW1pbiBvZmZyYW50IGxlIG1vaW5zIGRlIHLDqXNpc3RhbmNlIHNvdXMgbGEgZm9ybWUgZOKAmXVuIG1vZMOobGUgbnVtw6lyaXF1ZSBk4oCZw6lsw6l2YXRpb24gKE1ORSkuIERhbnMgY2UgY2FzLCB1dGlsaXNleiBsZSBNTkUgYXZlYyBsZSByYXN0ZXIgZOKAmWFjY3VtdWxhdGlvbiBkZSBkaXN0YW5jZSBlbiBlbnRyw6llIGV0IGxlcyByw6lzdWx0YXRzIG9idGVudXMgdmlhIGxhIGZvbmN0aW9uIERpcmVjdGlvbiBkZSBmbHV4IHBvdXIgdHJhaXRlciBsZSByYXN0ZXIgZGUgZGlyZWN0aW9uIGFycmnDqHJlLjwvZGl2PlwiLFxuXHRcdHRyZW5kTmFtZTogXCJQcmVkaWN0IFVzaW5nIFRyZW5kIChQcsOpdm9pciDDoCBs4oCZYWlkZSBk4oCZdW5lIHRlbmRhbmNlKVwiLFxuXHRcdHRyZW5kU25pcDogXCJDYWxjdWxlIHVuZSBjb3VjaGUgcmFzdGVyIG11bHRpZGltZW5zaW9ubmVsbGUgcHLDqXZ1ZSBlbiB1dGlsaXNhbnQgbGUgcmFzdGVyIGRlIHRlbmRhbmNlIGVuIHNvcnRpZSDDoCBwYXJ0aXIgZGUgbGEgZm9uY3Rpb24gR8OpbsOpcmVyIHVuZSB0ZW5kYW5jZSBvdSBs4oCZb3V0aWwgZGUgZ8Opb3RyYWl0ZW1lbnQgR8OpbsOpcmVyIHVuIHJhc3RlciBkZSB0ZW5kYW5jZS5cIixcblx0XHR0cmVuZERlc2M6IFwiTGEgZm9uY3Rpb24gUHLDqXZvaXIgw6AgbOKAmWFpZGUgZOKAmXVuZSB0ZW5kYW5jZSBjYWxjdWxlIHVuZSBjb3VjaGUgcmFzdGVyIG11bHRpZGltZW5zaW9ubmVsbGUgcHLDqXZ1ZSBlbiB1dGlsaXNhbnQgbGUgcmFzdGVyIGRlIHRlbmRhbmNlIGVuIHNvcnRpZSDDoCBwYXJ0aXIgZGUgbGEgZm9uY3Rpb24gR8OpbsOpcmVyIHVuZSB0ZW5kYW5jZSBvdSBs4oCZb3V0aWwgZGUgZ8Opb3RyYWl0ZW1lbnQgR8OpbsOpcmVyIHVuIHJhc3RlciBkZSB0ZW5kYW5jZS5cIixcblx0XHRyYXN0ZXJDb2xsZWN0aW9uTmFtZTogXCJUcmFpdGVyIHVuIGVuc2VtYmxlIGRlIHJhc3RlcnNcIixcblx0XHRyYXN0ZXJDb2xsZWN0aW9uU25pcDogXCJUcmFpdGUgY2hhcXVlIHRyYW5jaGUgZGFucyB1biByYXN0ZXIgbXVsdGlkaW1lbnNpb25uZWwgb3UgY2hhcXVlIMOpbMOpbWVudCBkYW5zIHVuIHJhc3RlciBtb3Nhw69xdWUuIENldHRlIGZvbmN0aW9uIHBldXQgw6lnYWxlbWVudCBhZ3LDqWdlciBwbHVzaWV1cnMgdHJhbmNoZXMgZW4gdW5lIHNldWxlLlwiLFxuXHRcdHJhc3RlckNvbGxlY3Rpb25EZXNjOiBcIkxhIGZvbmN0aW9uIFRyYWl0ZXIgdW4gZW5zZW1ibGUgZGUgcmFzdGVycyB0cmFpdGUgY2hhcXVlIHRyYW5jaGUgZGFucyB1biByYXN0ZXIgbXVsdGlkaW1lbnNpb25uZWwgb3UgY2hhcXVlIMOpbMOpbWVudCBkYW5zIHVuIHJhc3RlciBtb3Nhw69xdWUuIENldHRlIGZvbmN0aW9uIHBldXQgw6lnYWxlbWVudCBhZ3LDqWdlciBwbHVzaWV1cnMgdHJhbmNoZXMgZW4gdW5lIHNldWxlLjxkaXY+PGJyLz5DZXR0ZSBmb25jdGlvbiB0cmFpdGUgY2hhcXVlIHRyYW5jaGUgZGFucyB1biByYXN0ZXIgbXVsdGlkaW1lbnNpb25uZWwgb3UgdW4gcmFzdGVyIG1vc2HDr3F1ZSBlbiB1dGlsaXNhbnQgdW4gbW9kw6hsZSBkZSBmb25jdGlvbiByYXN0ZXIuIENldHRlIGZvbmN0aW9uIHByZW5kIGVuIGNoYXJnZSBsZXMgb3B0aW9ucyBzdWl2YW50ZXMgOiAxLiBTcMOpY2lmaWVyIHVuIG1vZMOobGUgZGUgZm9uY3Rpb24gcmFzdGVyIHBvdXIgSXRlbSBGdW5jdGlvbiAoRm9uY3Rpb24gZGUgbOKAmcOpbMOpbWVudCkuIFZvdXMgcG9zc8OpZGV6IHBhciBleGVtcGxlIHVuIGpldSBkZSBkb25uw6llcyBtb3Nhw69xdWUgY29udGVuYW50IDIwIGFubsOpZXMgZOKAmWltYWdlcmllIExhbmRzYXQgZXQgdm91cyBzb3VoYWl0ZXogY2FsY3VsZXIgbOKAmWluZGljZSBORFZJIHBvdXIgY2hhcXVlIHNjw6huZSBkYW5zIGxhIHPDqXJpZSBjaHJvbm9sb2dpcXVlLiBQb3VyIEl0ZW0gRnVuY3Rpb24gKEZvbmN0aW9uIGRlIGzigJnDqWzDqW1lbnQpLCBzcMOpY2lmaWV6IHVuIG1vZMOobGUgZGUgZm9uY3Rpb24gcmFzdGVyIGNvbnRlbmFudCBsYSBmb25jdGlvbiByYXN0ZXIgTkRWSS4gMi4gU3DDqWNpZmllciB1biBtb2TDqGxlIGRlIGZvbmN0aW9uIHJhc3RlciBwb3VyIEFnZ3JlZ2F0aW9uIEZ1bmN0aW9uIChGb25jdGlvbiBk4oCZYWdyw6lnYXRpb24pLiBWb3VzIGF2ZXosIHBhciBleGVtcGxlLCB1biByYXN0ZXIgbXVsdGlkaW1lbnNpb25uZWwgY29udGVuYW50IGxlcyBkb25uw6llcyBkZSB0ZW1ww6lyYXR1cmVzIGpvdXJuYWxpw6hyZXMgc3VyIDEwIGFubsOpZXMgZXQgc291aGFpdGV6IGNhbGN1bGVyIGxhIHRlbXDDqXJhdHVyZSBtYXhpbXVtIHBvdXIgY2hhcXVlIGFubsOpZS4gRGFucyBBZ2dyZWdhdGlvbiBGdW5jdGlvbiAoRm9uY3Rpb24gZOKAmWFncsOpZ2F0aW9uKSwgc3DDqWNpZmlleiB1biBtb2TDqGxlIGRlIGZvbmN0aW9uIHJhc3RlciBjb250ZW5hbnQgbGEgZm9uY3Rpb24gQ2VsbCBTdGF0aXN0aWNzIChTdGF0aXN0aXF1ZXMgZGUgY2VsbHVsZSkgZXQgZMOpZmluaXNzZXogT3BlcmF0aW9uIChPcMOpcmF0aW9uKSBzdXIgTWF4aW11bS4gU291cyBsYSBkw6lmaW5pdGlvbiBkZSBs4oCZYWdyw6lnYXRpb24sIGTDqWZpbmlzc2V6IERpbWVuc2lvbiBzdXIgU3RkVGltZSwgZMOpZmluaXNzZXogVHlwZSBzdXIgSW50ZXJ2YWwgS2V5d29yZCAoTW90LWNsw6kgZGUgbOKAmWludGVydmFsbGUpIGV0IEtleXdvcmQgSW50ZXJ2YWwgKEludGVydmFsbGUgZGUgbW90LWNsw6kpIHN1ciBZZWFybHkgKEFubnVlbCkuIE5vdGV6IHF1ZSBzaSBsZSBqZXUgZGUgZG9ubsOpZXMgbW9zYcOvcXVlIGVuIGVudHLDqWUgbuKAmWVzdCBwYXMgbXVsdGlkaW1lbnNpb25uZWwsIGxhIGZvbmN0aW9uIGTigJlhZ3LDqWdhdGlvbiBuZSByZXNwZWN0ZSBwYXMgbGEgZMOpZmluaXRpb24gZGUgbOKAmWFncsOpZ2F0aW9uLiBMYSBmb25jdGlvbiBk4oCZYWdyw6lnYXRpb24gYWdyw6hnZSB0b3VzIGxlcyDDqWzDqW1lbnRzIG91IGNoYXF1ZSBncm91cGUgZW4gdW4gc2V1bCBz4oCZaWxzIHNvbnQgZMOpZmluaXMgZGFucyBsZSBtb2TDqGxlIGRlIGZvbmN0aW9uIGTigJlhZ3LDqWdhdGlvbi4gUG91ciBlbiBzYXZvaXIgcGx1cyBzdXIgbOKAmXV0aWxpc2F0aW9uIGRlcyBncm91cGVzIGRhbnMgdW4gamV1IGRlIGRvbm7DqWVzIG1vc2HDr3F1ZSwgcmVwb3J0ZXotdm91cyDDoCBsYSBydWJyaXF1ZSBVdGlsaXNlciBsZXMgw6lsw6ltZW50cyBkZSBqZXUgZGUgZG9ubsOpZXMgbW9zYcOvcXVlIGRhbnMgbGVzIG1vZMOobGVzIGRlIGZvbmN0aW9uIHJhc3Rlci4gMy4gU3DDqWNpZmllciB1biBtb2TDqGxlIGRlIGZvbmN0aW9uIHJhc3RlciBwb3VyIFByb2Nlc3NpbmcgRnVuY3Rpb24gKEZvbmN0aW9uIGRlIHRyYWl0ZW1lbnQpLiBMYSBmb25jdGlvbiBvdSBjaGHDrm5lIGRlIGZvbmN0aW9ucyBkYW5zIGNlIG1vZMOobGUgZXN0IHV0aWxpc8OpZSBwb3VyIGFmZmljaGVyIGxlIG5vdXZlYXUgcmFzdGVyIHRyYWl0w6kuIFBhciBleGVtcGxlLCBzcMOpY2lmaWV6IHVuIG1vZMOobGUgZGUgZm9uY3Rpb24gcmFzdGVyIGNvbnRlbmFudCBsYSBmb25jdGlvbiBDb2xvcm1hcCBwb3VyIG1vZGlmaWVyIGxhIGZhw6dvbiBkb250IGVzdCBhZmZpY2jDqWUgbGEgY291Y2hlIGRlIHJhc3RlciB0cmFpdMOpZS4gVmV1aWxsZXogbm90ZXIgcXVlIHNpIGzigJllbnRyw6llIGVzdCB1biByYXN0ZXIgbXVsdGlkaW1lbnNpb25uZWwsIGxhIGZvbmN0aW9uIGRlIHRyYWl0ZW1lbnQgZXN0IGFwcGxpcXXDqWUgw6AgbGEgdHJhbmNoZSBhY3R1ZWxsZW1lbnQgYWZmaWNow6llLiBTaSBs4oCZZW50csOpZSBlc3QgdW5lIGNvdWNoZSBkZSBtb3Nhw69xdWUgb3UgdW4gamV1IGRlIGRvbm7DqWVzIG1vc2HDr3F1ZSwgbGEgZm9uY3Rpb24gZGUgdHJhaXRlbWVudCBlc3QgYXBwbGlxdcOpZSBhdSByYXN0ZXIgbW9zYcOvcXVlIHNlbG9uIGxhIHByZW1pw6hyZSBtw6l0aG9kZSBwb3VyIGNvcnJpZ2VyIGxlcyBzdXBlcnBvc2l0aW9ucy4gMy4gU3DDqWNpZmlleiBkZXMgbW9kw6hsZXMgcG91ciBjaGFxdWUgY29tYmluYWlzb24gZGVzIHRyb2lzIGZvbmN0aW9ucy4gVm91cyBkaXNwb3NleiBwYXIgZXhlbXBsZSBk4oCZdW4gamV1IGRlIGRvbm7DqWVzIG1vc2HDr3F1ZSBjb250ZW5hbnQgdW5lIHPDqXJpZSBjaHJvbm9sb2dpcXVlIGTigJlpbWFnZXJpZXMgTGFuZHNhdCBldCB2b3VzIHNvdWhhaXRleiBnw6luw6lyZXIgdW5lIGltYWdlIGNvbXBvc2l0ZSBk4oCZaW5kaWNlIE5EVkkgbWF4aW11bS4gUG91ciBJdGVtIEZ1bmN0aW9uIChGb25jdGlvbiBkZSBs4oCZw6lsw6ltZW50KSwgc3DDqWNpZmlleiB1biBtb2TDqGxlIGRlIGZvbmN0aW9uIHJhc3RlciBjb250ZW5hbnQgbGEgZm9uY3Rpb24gcmFzdGVyIE5EVkkuIFBvdXIgQWdncmVnYXRpb24gRnVuY3Rpb24gKEZvbmN0aW9uIGTigJlhZ3LDqWdhdGlvbiksIHNww6ljaWZpZXogdW4gbW9kw6hsZSBkZSBmb25jdGlvbiByYXN0ZXIgY29udGVuYW50IGxhIGZvbmN0aW9uIENlbGwgU3RhdGlzdGljcyAoU3RhdGlzdGlxdWVzIGRlIGNlbGx1bGUpIGV0IGTDqWZpbmlzc2V6IE9wZXJhdGlvbiAoT3DDqXJhdGlvbikgc3VyIE1heGltdW0uIFBvdXIgUHJvY2Vzc2luZyBGdW5jdGlvbiAoRm9uY3Rpb24gZGUgdHJhaXRlbWVudCksIHNww6ljaWZpZXogdW4gbW9kw6hsZSBkZSBmb25jdGlvbiByYXN0ZXIgY29udGVuYW50IGxhIGZvbmN0aW9uIENvbG9ybWFwLiBOb3RleiBxdWUgbOKAmW9yZHJlIGRlIHRyYWl0ZW1lbnQgZGUgbGEgZm9uY3Rpb24gcmVzcGVjdGUgbOKAmW9yZHJlIGRlcyBwYXJhbcOodHJlcyBlbiBlbnRyw6llLiBBaW5zaSwgSXRlbSBGdW5jdGlvbiAoRm9uY3Rpb24gZGUgbOKAmcOpbMOpbWVudCkgc2VyYSB0cmFpdMOpIGVuIHByZW1pZXIuPC9kaXY+XCIsXG5cdFx0cmFuZG9tTmFtZTogXCJBbMOpYXRvaXJlXCIsXG5cdFx0cmFuZG9tU25pcDogXCJDcsOpZSB1biByYXN0ZXIgYXZlYyBkZXMgdmFsZXVycyBkZSBwaXhlbHMgYWzDqWF0b2lyZXMgZGVzc2luw6llcyDDoCBwYXJ0aXIgZOKAmXVuZSBkaXN0cmlidXRpb24gcHNldWRvIGFsw6lhdG9pcmUuIFBsdXNpZXVycyBkaXN0cmlidXRpb25zIGV0IGfDqW7DqXJhdGV1cnMgZGUgbm9tYnJlcyBhbMOpYXRvaXJlcyBzb250IHByaXMgZW4gY2hhcmdlLlwiLFxuXHRcdHJhbmRvbURlc2M6IFwiTGEgZm9uY3Rpb24gQWzDqWF0b2lyZSBjcsOpZSB1biByYXN0ZXIgYXZlYyBkZXMgdmFsZXVycyBkZSBwaXhlbHMgYWzDqWF0b2lyZXMgcXVpIHBldXZlbnQgw6p0cmUgdXRpbGlzw6llcyBkYW5zIGRlcyBtb2TDqGxlcyBkZSBmb25jdGlvbnMgcmFzdGVyIG91IGRlcyBqZXV4IGRlIGRvbm7DqWVzIG1vc2HDr3F1ZS48ZGl2Pjxici8+Tm9tYnJlIGRlIGZvbmN0aW9ucyB1dGlsaXNlbnQgdW4gb3UgcGx1c2lldXJzIHJhc3RlcnMgZW4gZW50csOpZSwgbWFpcyBsYSBmb25jdGlvbiBBbMOpYXRvaXJlIG5lIHJlcXVpZXJ0IHBhcyBkZSByYXN0ZXIgZW4gZW50csOpZS4gQ2VsYSBzaWduaWZpZSBxdeKAmWVsbGUgc2UgY29tcG9ydGUgZGF2YW50YWdlIGNvbW1lIHVuIGpldSBkZSBkb25uw6llcyByYXN0ZXIgcXXigJl1bmUgZm9uY3Rpb24uIFZvdXMgZGV2ZXogZG9uYyDDqnRyZSB2aWdpbGFudCBsb3JzcXVlIHZvdXMgbOKAmWFqb3V0ZXogw6AgbGEgY2hhw65uZSBkZSBmb25jdGlvbnMgb3UgcXVlIHZvdXMgbOKAmWVuIHN1cHByaW1lei48L2Rpdj5cIixcblx0XHRzaHJpbmtOYW1lOiBcIlLDqWR1aXJlXCIsXG5cdFx0c2hyaW5rU25pcDogXCJSw6lkdWl0IGxhIHRhaWxsZSBkZXMgem9uZXMgc8OpbGVjdGlvbm7DqWVzIHNlbG9uIHVuIG5vbWJyZSBkZSBjZWxsdWxlcyBkw6lmaW5pLCBlbiByZW1wbGHDp2FudCBsZXVyIHZhbGV1ciBwYXIgY2VsbGUgZGUgbGEgY2VsbHVsZSBsYSBwbHVzIGZyw6lxdWVudGUgZGFucyBsZXVyIHZvaXNpbmFnZS5cIixcblx0XHRzaHJpbmtEZXNjOiBcIkF2ZWMgbGEgZm9uY3Rpb24gZ2xvYmFsZSBSw6lkdWlyZSwgdm91cyBwb3V2ZXogZ8OpbsOpcmFsaXNlciBvdSBzaW1wbGlmaWVyIGxlcyByYXN0ZXJzIGVuIHLDqWR1aXNhbnQgZGVzIHpvbmVzIHBhcnRpY3VsacOocmVzLiBWb3VzIHBvdXZleiDDqWdhbGVtZW50IGNvbnRyw7RsZXIgbGUgbml2ZWF1IGRlIGfDqW7DqXJhbGlzYXRpb24gcXVpIGF1cmEgbGlldS48ZGl2Pjxici8+TGVzIHpvbmVzIHF1ZSB2b3VzIHPDqWxlY3Rpb25uZXogc2Vyb250IHLDqWR1aXRlcywgb3UgZGltaW51ZW50IGVuIHRhaWxsZSwgZGVzIGNlbGx1bGVzIGRlcyB6b25lcyBhbGVudG91ciBzZSBkw6l2ZWxvcHBhbnQgZW4gZWxsZXMuIEVuIHRow6lvcmllLCBsZXMgdmFsZXVycyBkZSB6b25lIHPDqWxlY3Rpb25uw6llcyBwZXV2ZW50IMOqdHJlIHZ1ZXMgY29tbWUgZGVzIHpvbmVzIGRlIHByZW1pZXIgcGxhbiwgbGVzIGF1dHJlcyB2YWxldXJzIHJlc3RhbnQgZGVzIHpvbmVzIGTigJlhcnJpw6hyZS1wbGFuLiBMZXMgY2VsbHVsZXMgZGVzIHpvbmVzIGRlIHByZW1pZXIgcGxhbiBwZXV2ZW50IMOqdHJlIHJlbXBsYWPDqWVzIHBhciBsZXMgY2VsbHVsZXMgZGVzIHpvbmVzIGTigJlhcnJpw6hyZS1wbGFuLiBMZXMgw65sZXMgZmluZXMgcHLDqXNlbnRlcyDDoCBs4oCZaW50w6lyaWV1ciBk4oCZdW5lIHpvbmUgcXVpIHNvbnQgc3VzY2VwdGlibGVzIGTigJnDqnRyZSBpbnRlcnByw6l0w6llcyBjb21tZSBwYXJ0YWdlYW50IGRlcyBsaW1pdGVzIGF2ZWMgbGEgem9uZSwgcGV1dmVudCDDqWdhbGVtZW50IMOqdHJlIHJlbXBsYWPDqWVzLjxkaXY+PGJyLz5MZSBuaXZlYXUgZGUgZ8OpbsOpcmFsaXNhdGlvbiBwZXV0IMOqdHJlIGNvbnRyw7Rsw6kgw6AgbOKAmWFpZGUgZHUgcGFyYW3DqHRyZSBOdW1iZXIgb2YgQ2VsbHMgKE5vbWJyZSBkZSBjZWxsdWxlcykuIFBhciBkw6lmYXV0LCBjZSBwYXJhbcOodHJlIGEgdW5lIHZhbGV1ciDDqWdhbGUgw6AgMSwgY2UgcXVpIHNpZ25pZmllIHF1ZSBsZXMgem9uZXMgc8OpbGVjdGlvbm7DqWVzIGRpbWludWVyb250IGR1IHZvbHVtZSBjb3JyZXNwb25kYW50IMOgIGxhIHRhaWxsZSBk4oCZdW5lIGNlbGx1bGUuIFBvdXIgYXVnbWVudGVyIGxlIGRlZ3LDqSBkZSBnw6luw6lyYWxpc2F0aW9uLCB2b3VzIHBvdXZleiBzcMOpY2lmaWVyIHVuZSB2YWxldXIgc3Vww6lyaWV1cmUgcG91ciBjZSBwYXJhbcOodHJlLiBDZWxhIHJldmllbnQgw6AgdXRpbGlzZXIgbOKAmW91dGlsIHVuIG5vbWJyZSBkZSBmb2lzIMOpcXVpdmFsYW50IGF1IG5vbWJyZSBzcMOpY2lmacOpLCBsZXMgcsOpc3VsdGF0cyBkZSBs4oCZZXjDqWN1dGlvbiBwcsOpY8OpZGVudGUgZm9ybWFudCBs4oCZZW50csOpZSBkZSBs4oCZaXTDqXJhdGlvbiBzdWl2YW50ZS48L2Rpdj5cIixcblx0XHR0cmVuZFRvUkdCTmFtZTogXCJUZW5kYW5jZSB2ZXJzIFJWQlwiLFxuXHRcdHRyZW5kVG9SR0JTbmlwOiBcIkNvbnZlcnRpdCB1biByYXN0ZXIgZGUgdGVuZGFuY2UgZW4gdW4gcmFzdGVyIMOgIHRyb2lzIGNhbmF1eCAocm91Z2UsIHZlcnQgZXQgYmxldSkuXCIsXG5cdFx0dHJlbmRUb1JHQkRlc2M6IFwiTGEgZm9uY3Rpb24gVGVuZGFuY2UgdmVycyBSVkIgY29udmVydGl0IHVuIHJhc3RlciBkZSB0ZW5kYW5jZSBlbiB1biByYXN0ZXIgw6AgdHJvaXMgY2FuYXV4IChyb3VnZSwgdmVydCBldCBibGV1KS4gTGUgcmFzdGVyIGRlIHRlbmRhbmNlIGVzdCBnw6luw6lyw6kgcGFyIGxhIGZvbmN0aW9uIEfDqW7DqXJlciB1biByYXN0ZXIgZGUgdGVuZGFuY2VzIG91IGxhIGZvbmN0aW9uIHJhc3RlciBk4oCZYW5hbHlzZSBDQ0RDLjxkaXY+PGJyLz5DZXR0ZSBmb25jdGlvbiBlc3QgdXRpbGUgcG91ciBsYSB2aXN1YWxpc2F0aW9uIGRlcyBkb25uw6llcyBkZSBjb2VmZmljaWVudCBkZSBtb2TDqGxlIMOgIHBhcnRpciBkZSBsYSBmb25jdGlvbiBHw6luw6lyZXIgdW5lIHRlbmRhbmNlIG91IGxhIGZvbmN0aW9uIGTigJlhbmFseXNlIENDREMuIExlcyBkZXV4IGZvbmN0aW9ucyBlc3RpbWVudCBsZXMgdGVuZGFuY2VzIGVuIG1vZGlmaWFudCBsZXMgdmFsZXVycyBkZSBwaXhlbHMsIG1haXMgbOKAmWludGVycHLDqXRhdGlvbiBkaXJlY3RlIGRlcyByw6lzdWx0YXRzIGRlcyBmb25jdGlvbnMgZXN0IGRpZmZpY2lsZS48ZGl2Pjxici8+Q29tbWUgZGUgbm9tYnJldXNlcyBmb25jdGlvbnMgcmFzdGVyLCB2b3VzIGF1cmV6IHBldXQtw6p0cmUgYmVzb2luIGTigJl1dGlsaXNlciBs4oCZYWp1c3RlbWVudCBkeW5hbWlxdWUgZGUgbGEgcGxhZ2UgKERSQSkgcG91ciB1biBtZWlsbGV1ciBhZmZpY2hhZ2UgZGVzIHLDqXN1bHRhdHMgZGUgY2V0dGUgZm9uY3Rpb24uPC9kaXY+XCIsXG5cdFx0bGFuZFRyZW5kck5hbWU6IFwiQW5hbHlzZSBMYW5kVHJlbmRyXCIsXG5cdFx0bGFuZFRyZW5kclNuaXA6IFwiw4l2YWx1ZXIgbGVzIGNoYW5nZW1lbnRzIGRlcyB2YWxldXJzIGRlIHBpeGVscyBhdSBmaWwgZHUgdGVtcHMgw6AgbOKAmWFpZGUgZGUgbGEgbcOpdGhvZGUgZGUgZMOpdGVjdGlvbiBkZXMgdGVuZGFuY2VzIGVuIG1hdGnDqHJlIGRlIHBlcnR1cmJhdGlvbiBldCBkZSByw6ljdXDDqXJhdGlvbiBkZXMgZm9yw6p0cyBiYXPDqWUgc3VyIExhbmRzYXQgKExhbmRUcmVuZHIpLCBwdWlzIGfDqW7DqXJlciB1biByYXN0ZXIgZOKAmWFuYWx5c2UgZGVzIGNoYW5nZW1lbnRzIGNvbnRlbmFudCBsZXMgcsOpc3VsdGF0cyBkdSBtb2TDqGxlLlwiLFxuXHRcdGxhbmRUcmVuZHJEZXNjOiBcIkNldHRlIGZvbmN0aW9uIHJhc3RlciBwZXV0IHVuaXF1ZW1lbnQgw6p0cmUgdXRpbGlzw6llIGNvbW1lIGVudHLDqWUgcG91ciBsYSBmb25jdGlvbiByYXN0ZXIgRMOpdGVjdGVyIGxlcyBtb2RpZmljYXRpb25zIMOgIGzigJlhaWRlIGRlIGzigJlhbmFseXNlIGRlcyBjaGFuZ2VtZW50cy4gUG91ciBnw6luw6lyZXIgdW5lIHNvcnRpZSByYXN0ZXIsIGNvbm5lY3RleiBsYSBmb25jdGlvbiBk4oCZYW5hbHlzZSBMYW5kVHJlbmRyIMOgIGxhIGZvbmN0aW9uIETDqXRlY3RlciBsZXMgbW9kaWZpY2F0aW9ucyDDoCBs4oCZYWlkZSBkZSBs4oCZYW5hbHlzZSBkZXMgY2hhbmdlbWVudHMgZGFucyB1biBtb2TDqGxlIGRlIGZvbmN0aW9uIHJhc3RlciwgcHVpcyB1dGlsaXNleiBsZSBtb2TDqGxlIGNvbW1lIGVudHLDqWUgZGFucyBs4oCZb3V0aWwgZGUgZ8Opb3RyYWl0ZW1lbnQgR8OpbsOpcmVyIHVuIHJhc3RlciDDoCBwYXJ0aXIgZOKAmXVuZSBmb25jdGlvbiByYXN0ZXIuIExlIHLDqXN1bHRhdCBlc3QgdW4gcmFzdGVyIGNvbnRlbmFudCBkZXMgaW5mb3JtYXRpb25zIGNvbmNlcm5hbnQgbGEgZGF0ZS9s4oCZaGV1cmUgw6AgbGFxdWVsbGUgbGVzIHZhbGV1cnMgZGUgcGl4ZWxzIG9udCBjaGFuZ8OpLjxkaXY+PGJyPkNldHRlIGZvbmN0aW9uIHJhc3RlciBhIHBvdXIgZmluYWxpdMOpIGTigJlleHRyYWlyZSBsZXMgY2hhbmdlbWVudHMgc3VydmVudXMgZGFucyB1bmUgZW50aXTDqSBvYnNlcnbDqWUsIGRlIHNvcnRlIHF1ZSBs4oCZaW1hZ2VyaWUgbXVsdGlkaW1lbnNpb25uZWxsZSBlbiBlbnRyw6llIGlkw6lhbGUgcHVpc3NlIGNhcHR1cmVyIHVuZSBvYnNlcnZhdGlvbiBjb2jDqXJlbnRlIGF1IGZpbCBkdSB0ZW1wcyBldCBuZSBwdWlzc2UgcGFzIGluY2x1cmUgZOKAmWludGVyZsOpcmVuY2VzIGF0bW9zcGjDqXJpcXVlcyBvdSBsacOpZXMgYXUgY2FwdGV1ciwgZGUgbnVhZ2VzIG91IGzigJlvbWJyZSBkZXMgbnVhZ2VzLiBVbmUgYm9ubmUgcHJhdGlxdWUgY29uc2lzdGUgw6AgdXRpbGlzZXIgZGVzIGRvbm7DqWVzIHF1aSBvbnQgw6l0w6kgbm9ybWFsaXPDqWVzIGV0IHF1aSBwZXV2ZW50IMOqdHJlIG1hc3F1w6llcyDDoCBs4oCZYWlkZSBk4oCZdW5lIGJhbmRlIFFBIChsZXMgcHJvZHVpdHMgZGUgcsOpZmxlY3RhbmNlIGRlIHN1cmZhY2UgTGFuZHNhdCBDb2xsZWN0aW9uwqAxIGF2ZWMgdW4gbWFzcXVlIGRlIG51YWdlLCBwYXIgZXhlbXBsZSkuPGRpdj48YnI+TGEgZm9uY3Rpb24gZWZmZWN0dWUgbOKAmWFuYWx5c2Ugc3VyIHVuZSBpbWFnZSBwYXIgYW4sIGV0IGxlIG5vbWJyZSBkZSB0cmFuY2hlcyBhbm51ZWxsZXMgZG9pdCDDqnRyZSBzdXDDqXJpZXVyIG91IMOpZ2FsIMOgIGxhIHZhbGV1ciBzcMOpY2lmacOpZSBkYW5zIGxlIHBhcmFtw6h0cmUgPHN0cm9uZz5Ob21icmUgbWluaW1hbCBk4oCZb2JzZXJ2YXRpb25zPC9zdHJvbmc+LiBJbCBlc3QgcmVjb21tYW5kw6kgZGUgZGlzcG9zZXIgZGUgZG9ubsOpZXMgY291dnJhbnQgdW5lIHDDqXJpb2RlIGTigJlhdSBtb2lucyBzaXjCoGFucy48ZGl2Pjxicj5TaSB2b3VzIGRpc3Bvc2V6IGRlIGRvbm7DqWVzIG1lbnN1ZWxsZXMsIGhlYmRvbWFkYWlyZXMgb3UgcXVvdGlkaWVubmVzLCBpbCBlc3QgcmVjb21tYW5kw6kgZGUgY2hvaXNpciBwbHVzaWV1cnMgaW1hZ2VzIHBvdXIgY2hhcXVlIGFubsOpZSAoZGUgcHLDqWbDqXJlbmNlIHBvdXIgbGEgbcOqbWUgc2Fpc29uKSwgZGUgcmV0aXJlciBsZXMgbnVhZ2VzIGV0IGzigJlvbWJyZSBkZXMgbnVhZ2VzLCBldCBkZSBjb21iaW5lciBsZXMgaW1hZ2VzIHBvdXIgZ8OpbsOpcmVyIHVuZSBzZXVsZSBpbWFnZSBxdWkgY2FwdHVyZSBiaWVuIGzigJlvYnNlcnZhdGlvbi4gU2kgZGVzIGRvbm7DqWVzIG1lbnN1ZWxsZXMsIGhlYmRvbWFkYWlyZXMgb3UgcXVvdGlkaWVubmVzIHNvbnQgZm91cm5pZXMgY29tbWUgcmFzdGVyIG11bHRpZGltZW5zaW9ubmVsIGVuIGVudHLDqWUsIGxhIGZvbmN0aW9uIGlkZW50aWZpZSB1bmUgdHJhbmNoZSBwb3VyIGzigJlhbmFseXNlIGVuIHPigJlhcHB1eWFudCBzdXIgbGEgZGF0ZSBsYSBwbHVzIHByb2NoZSBkZSBjZWxsZSBpbmRpcXXDqWUgZGFucyBsZSBwYXJhbcOodHJlIDxzdHJvbmc+RGF0ZSBkZSBjYXB0dXJlPC9zdHJvbmc+LjxkaXY+PGJyPlVuZSBlbnRpdMOpIGRhbnMgdW4gcGF5c2FnZSBwcmVuZCBnw6luw6lyYWxlbWVudCBkdSB0ZW1wcyBwb3VyIHLDqWN1cMOpcmVyIGTigJl1biBjaGFuZ2VtZW50IG5vbiBwZXJtYW5lbnQgKHVuIGluY2VuZGllIGRlIGZvcsOqdCBvdSB1bmUgaW5mZXN0YXRpb24gcGFyIGRlcyBpbnNlY3RlcywgcGFyIGV4ZW1wbGUpLiBQb3VyIGNvbnRyw7RsZXIgbGEgdml0ZXNzZSBkZSByw6ljdXDDqXJhdGlvbiByZWNvbm51ZSBwYXIgbGUgbW9kw6hsZSwgZMOpZmluaXNzZXogbGUgcGFyYW3DqHRyZSBTZXVpbCBkZSByw6ljdXDDqXJhdGlvbi4gVW4gc2VnbWVudCBkaXN0aW5jdCBuZSBwZXV0IHBhcyBhdm9pciB1bmUgdml0ZXNzZSBkZSByw6ljdXDDqXJhdGlvbiBzdXDDqXJpZXVyZSDDoCAxL3NldWlsIGRlIHLDqWN1cMOpcmF0aW9uLjxkaXY+PGJyPkxhIHLDqWN1cMOpcmF0aW9uIGFwcsOocyB1biBjaGFuZ2VtZW50IGRhbnMgdW4gcGF5c2FnZSBwZXV0IHNlIHByb2R1aXJlIGRhbnMgbGUgc2VucyBwb3NpdGlmIG91IG7DqWdhdGlmLiBQYXIgZXhlbXBsZSwgbG9yc3F14oCZdW4gcGF5c2FnZSBzdWJpdCB1bmUgZMOpZm9yZXN0YXRpb24sIHVuZSBzw6lyaWUgdGVtcG9yZWxsZSBkZXMgdmFsZXVycyBk4oCZaW5kaWNlIGRlIHbDqWfDqXRhdGlvbiBtb250cmUgdW5lIGNodXRlIGRlcyB2YWxldXJzIGTigJlpbmRpY2UsIHB1aXMgbGEgcsOpY3Vww6lyYXRpb24gbW9udHJlIHVuZSBhdWdtZW50YXRpb24gcHJvZ3Jlc3NpdmUgZGVzIHZhbGV1cnMgZOKAmWluZGljZSBkZSB2w6lnw6l0YXRpb24sIGF1dHJlbWVudCBkaXQgdW5lIHRlbmRhbmNlIGRlIHLDqWN1cMOpcmF0aW9uIHBvc2l0aXZlLiBTcMOpY2lmaWV6IGxlIHNlbnMgZGUgbGEgdGVuZGFuY2UgZGUgcsOpY3Vww6lyYXRpb24gYXZlYyBsZSBwYXJhbcOodHJlIDxzdHJvbmc+TGEgdGVuZGFuY2UgZGUgcsOpY3Vww6lyYXRpb24gYXVnbWVudGU8L3N0cm9uZz4uXCIsXG5cdFx0YWdncmVnYXRlTXVsdGlkaW1lbnNpb25hbE5hbWU6IFwiQWdyw6lnZXIgdW4gcmFzdGVyIG11bHRpZGltZW5zaW9ubmVsXCIsXG5cdFx0YWdncmVnYXRlTXVsdGlkaW1lbnNpb25hbFNuaXA6IFwiQXNzb2NpZXIgbGVzIHZhcmlhYmxlcyBleGlzdGFudGVzIGR1IHJhc3RlciBtdWx0aWRpbWVuc2lvbm5lbCBsZSBsb25nIGTigJl1bmUgZGltZW5zaW9uLlwiLFxuXHRcdGFnZ3JlZ2F0ZU11bHRpZGltZW5zaW9uYWxEZXNjOiBcIkxhIGZvbmN0aW9uIEFncsOpZ2VyIHVuIHJhc3RlciBtdWx0aWRpbWVuc2lvbm5lbCBjcsOpZSB1bmUgY291Y2hlIHJhc3RlciBtdWx0aWRpbWVuc2lvbm5lbCBlbiBjb21iaW5hbnQgbGVzIGRvbm7DqWVzIGRlcyB2YXJpYWJsZXMgZXhpc3RhbnRlcyBkdSByYXN0ZXIgbXVsdGlkaW1lbnNpb25uZWwgbGUgbG9uZyBk4oCZdW5lIGRpbWVuc2lvbi48ZGl2Pjxicj5VdGlsaXNleiBsZSBwYXJhbcOodHJlwqA8c3Ryb25nPkTDqWZpbml0aW9uIGRlIGxhIGRpbWVuc2lvbjwvc3Ryb25nPiBwb3VyIGZpbHRyZXIgZW4gcHJlbWllciBsaWV1IGxlcyBkb25uw6llcyBlbiBlbnRyw6llIHF1ZSB2b3VzIHNvdWhhaXRleiBhZ3LDqWdlci4gUGFyIGV4ZW1wbGUsIHNpIHZvdXMgZGlzcG9zZXogZGUgZG9ubsOpZXMgbWVuc3VlbGxlcyBjb3V2cmFudCB1bmUgcMOpcmlvZGUgZGUgMzDCoGFucywgbWFpcyBxdWUgdm91cyBzb3VoYWl0ZXogdW5pcXVlbWVudCBjcsOpZXIgdW5lIGNvdWNoZSBhZ3LDqWfDqWUgcG91ciBsZXMgMTXCoHByZW1pw6hyZXMgYW5uw6llcywgdm91cyBwb3V2ZXogdXRpbGlzZXIgbGUgcGFyYW3DqHRyZSA8c3Ryb25nPkTDqWZpbml0aW9uIGRlIGxhIGRpbWVuc2lvbjwvc3Ryb25nPsKgcG91ciBzcMOpY2lmaWVyIGxlcyBhbm7DqWVzIMOgIGluY2x1cmUgZGFucyBs4oCZYW5hbHlzZS48ZGl2Pjxicj48dWw+PGxpPkV4dHJhaXJlIGxlcyBkb25uw6llcyBkZSBzYWxpbml0w6kgcG91ciBsZSBtb2lzIGRlIGphbnZpZXIgc3VyIHVuZSBww6lyaW9kZSBkZSAxMMKgYW5zLiBTw6lsZWN0aW9ubmV6IDxzdHJvbmc+UGFyIHZhbGV1cnM8L3N0cm9uZz4sIGTDqWZpbmlzc2V6IDxzdHJvbmc+RGltZW5zaW9uPC9zdHJvbmc+wqBzdXLCoDxzdHJvbmc+U3RkVGltZTwvc3Ryb25nPiBldCA8c3Ryb25nPlZhbGV1cnM8L3N0cm9uZz7CoHN1ciA8c3Ryb25nPkphbnZpZXI8L3N0cm9uZz4uPC9saT48bGk+RMOpY291cGVyIGxlcyBkb25uw6llcyBkZSBzYWxpbml0w6kgc3VyIHVuZSBwbGFnZSBkZSBwcm9mb25kZXVycyBjb21wcmlzZSBlbnRyZcKgMMKgZXTCoDE1MMKgbcOodHJlcy4gU8OpbGVjdGlvbm5leiA8c3Ryb25nPlBhciBwbGFnZXM8L3N0cm9uZz4sIGTDqWZpbmlzc2V6IDxzdHJvbmc+RGltZW5zaW9uPC9zdHJvbmc+wqBzdXIgPHN0cm9uZz5TdGRaPC9zdHJvbmc+LCA8c3Ryb25nPlZhbGV1ciBtaW5pbWFsZTwvc3Ryb25nPsKgc3VyIDxzdHJvbmc+LTE1MDwvc3Ryb25nPiBldCA8c3Ryb25nPlZhbGV1ciBtYXhpbWFsZTwvc3Ryb25nPsKgc3VyIDxzdHJvbmc+MDwvc3Ryb25nPi48L2xpPjxsaT5FeHRyYWlyZSBsZXMgZG9ubsOpZXMgZGUgc2FsaW5pdMOpIHBvdXIgbGVzwqAxMMKgcHJlbWllcnMgam91cnMgZGUgY2hhcXVlIG1vaXMgZGUgamFudmllciBzdXIgdW5lIHDDqXJpb2RlIGRlIDEwwqBhbnMuIFPDqWxlY3Rpb25uZXogPHN0cm9uZz5QYXIgaXTDqXJhdGlvbjwvc3Ryb25nPiwgZMOpZmluaXNzZXogPHN0cm9uZz5EaW1lbnNpb248L3N0cm9uZz7CoHN1ciA8c3Ryb25nPlN0ZFRpbWU8L3N0cm9uZz4sIDxzdHJvbmc+RMOpYnV0IGRlIGxhIHByZW1pw6hyZSBpdMOpcmF0aW9uPC9zdHJvbmc+wqBldCA8c3Ryb25nPkZpbiBkZSBsYSBwcmVtacOocmUgaXTDqXJhdGlvbjwvc3Ryb25nPsKgc3VyIGxlIGTDqWJ1dCBldCBsYSBmaW4gZGUgbGEgcMOpcmlvZGUgZOKAmWl0w6lyYXRpb24gY29ycmVzcG9uZGFudGUsIDxzdHJvbmc+w4l0YXBlPC9zdHJvbmc+wqBzdXIgPHN0cm9uZz4xPC9zdHJvbmc+IGV0IDxzdHJvbmc+VW5pdMOpPC9zdHJvbmc+wqBzdXIgPHN0cm9uZz5Bbm7DqWVzPC9zdHJvbmc+LjwvbGk+PC91bD48ZGl2Pjxicj5VdGlsaXNleiBsZXMgcGFyYW3DqHRyZXPCoDxzdHJvbmc+RMOpZmluaXRpb24gZGUgbOKAmWFncsOpZ2F0aW9uPC9zdHJvbmc+wqBwb3VyIGNob2lzaXIgbGEgZGltZW5zaW9uIMOgIMOpdmFsdWVyIGV0IGzigJlpbnRlcnZhbGxlIGTigJlhZ3LDqWdhdGlvbiDDoCBs4oCZYWlkZSBk4oCZdW4gbW90LWNsw6ksIGTigJl1bmUgdmFsZXVyIG91IGTigJl1bmUgcGxhZ2UgZGUgdmFsZXVycy4gUGFyIGV4ZW1wbGUsIHNpIHZvdXMgZGlzcG9zZXogZGUgZG9ubsOpZXMgc3VyIGxhIHRlbXDDqXJhdHVyZSBkZSBzdXJmYWNlIGRlIGxhIG1lciBjb3V2cmFudCB1bmUgcMOpcmlvZGUgZGUgMzDCoGFucywgY29sbGVjdMOpZXMgcXVvdGlkaWVubmVtZW50IGV0IHRvdXMgbGVzwqA1wqBtw6h0cmVzIGRlIHByb2ZvbmRldXIganVzcXXigJnDoMKgMTAwwqBtw6h0cmVzLCB2b3VzIHBvdXZleiB1dGlsaXNlciBsZXMgZGlmZsOpcmVudGVzIG9wdGlvbnMgZOKAmWludGVydmFsbGUgcG91ciBsZXMgc2PDqW5hcmlvcyBzdWl2YW50c8KgOjxkaXY+PGJyPjx1bD48bGk+QWdyw6lnZXIgbGVzIGRvbm7DqWVzIGRlIHRlbXDDqXJhdHVyZSBxdW90aWRpZW5uZXMgZW4gZG9ubsOpZXMgbWVuc3VlbGxlcywgbGUgcsOpc3VsdGF0IMOpdGFudCB1biByYXN0ZXIgbXVsdGlkaW1lbnNpb25uZWwgYXZlYyAxMsKgdHJhbmNoZXMgdGVtcG9yZWxsZXMsIGNoYXF1ZSB0cmFuY2hlIMOpdGFudCBs4oCZYWdyw6lnYXQgZGUgY2hhcXVlIG1vaXMgc3VyIHRvdXRlcyBsZXMgYW5uw6llcy4gU8OpbGVjdGlvbm5leiA8c3Ryb25nPk1vdC1jbMOpIGRlIGzigJlpbnRlcnZhbGxlPC9zdHJvbmc+wqBldCBkw6lmaW5pc3NleiBsZSBtb3QtY2zDqSBzdXIgPHN0cm9uZz5Sw6ljdXJyZW5jZSBtZW5zdWVsbGU8L3N0cm9uZz4uPC9saT48bGk+QWdyw6lnZXIgbGVzIGRvbm7DqWVzIGRlIHRlbXDDqXJhdHVyZSBxdW90aWRpZW5uZXMgZW4gZG9ubsOpZXMgbWVuc3VlbGxlcywgbGUgcsOpc3VsdGF0IMOpdGFudCB1biByYXN0ZXIgbXVsdGlkaW1lbnNpb25uZWwgYXZlY8KgMzYwwqB0cmFuY2hlcyBvdcKgMTLCoHRyYW5jaGVzIHRlbXBvcmVsbGVzIHBhciBhbiAoMzDCoGFubsOpZXPCoHjCoDEywqBtb2lzwqA9wqAzNjDCoHRyYW5jaGVzKS4gU8OpbGVjdGlvbm5leiA8c3Ryb25nPk1vdC1jbMOpIGRlIGzigJlpbnRlcnZhbGxlPC9zdHJvbmc+wqBldCBkw6lmaW5pc3NleiBsZSBtb3QtY2zDqSBzdXIgPHN0cm9uZz5QYXIgbW9pczwvc3Ryb25nPi48L2xpPjxsaT5BZ3LDqWdlciBsZXMgZG9ubsOpZXMgZGUgdGVtcMOpcmF0dXJlIG1lbnN1ZWxsZXMgZW4gaW50ZXJ2YWxsZXMgZGXCoDTCoG1vaXMuIFPDqWxlY3Rpb25uZXogPHN0cm9uZz5WYWxldXIgZGUgbOKAmWludGVydmFsbGU8L3N0cm9uZz4sIGTDqWZpbmlzc2V6IDxzdHJvbmc+VmFsZXVyIGRlIGzigJlpbnRlcnZhbGxlPC9zdHJvbmc+wqBzdXLCoDQgZXQgZMOpZmluaXNzZXrCoDxzdHJvbmc+VW5pdMOpPC9zdHJvbmc+wqBzdXLCoDxzdHJvbmc+TW9pczwvc3Ryb25nPi48L2xpPjxsaT5BZ3LDqWdlciBsZXMgZG9ubsOpZXMgZGUgdGVtcMOpcmF0dXJlIGVudHJlwqAwIGV0wqAyNcKgbcOodHJlcywgcHVpcyBlbnRyZcKgMjUgZXTCoDUwwqBtw6h0cmVzLCBldCBlbmZpbiBlbnRyZcKgNTAgZXTCoDEwMMKgbcOodHJlcy4gU8OpbGVjdGlvbm5lesKgPHN0cm9uZz5QbGFnZXMgZOKAmWludGVydmFsbGU8L3N0cm9uZz7CoGV0IGTDqWZpbmlzc2V6IGxlcyBwcm9mb25kZXVycyBtaW5pbWFsZXMgZXQgbWF4aW1hbGVzIHN1csKgPHN0cm9uZz4wIDI1OyAyNSA1MDsgNTAgMTAwPC9zdHJvbmc+LjwvbGk+PC91bD5cIixcblx0XHRtZXJnZVJhc3RlcnNOYW1lOiBcIkZ1c2lvbm5lciBkZXMgcmFzdGVyc1wiLFxuXHRcdG1lcmdlUmFzdGVyc1NuaXA6IFwiQ29tYmluZXIgcGx1c2lldXJzIGpldXggZGUgZG9ubsOpZXMgcmFzdGVyIHNwYXRpYWxlbWVudCBvdSBzZWxvbiBkZXMgdmFyaWFibGVzIGV0IGRlcyBkaW1lbnNpb25zLlwiLFxuXHRcdG1lcmdlUmFzdGVyc0Rlc2M6IFwiQ2V0dGUgZm9uY3Rpb24gY3LDqWUgdW4gcmFzdGVyIGZ1c2lvbm7DqSDDoCBwYXJ0aXIgZOKAmXVuZSBsaXN0ZSBkZSByYXN0ZXJzLiBQYXIgZXhlbXBsZSwgc2kgdm91cyBkaXNwb3NleiBk4oCZdW4gamV1IGRlIGRvbm7DqWVzIG1vc2HDr3F1ZSBxdWkgY29udGllbnQgbGVzIHJlbGV2w6lzIG1lbnN1ZWxzIGRlIHByw6ljaXBpdGF0aW9ucyBzdXIgMzDCoGFucyBldCB1biBhdXRyZSBqZXUgZGUgZG9ubsOpZXMgYXZlYyBsZXMgZG9ubsOpZXMgZGUgdGVtcMOpcmF0dXJlIG1lbnN1ZWxsZXMgc3VyIDEwwqBhbnMsIHZvdXMgcG91dmV6IGxlcyBhc3NvY2llciBwb3VyIGNyw6llciB1biByYXN0ZXIgbXVsdGlkaW1lbnNpb25uZWwgYXZlYyBsZXMgZGV1eCB2YXJpYWJsZXMuIDxkaXY+PGJyPlNpIGxlcyByYXN0ZXJzIG11bHRpZGltZW5zaW9ubmVscyBlbiBlbnRyw6llIGNvbnRpZW5uZW50IGRlcyB2YXJpYWJsZXMgZGlmZsOpcmVudGVzLCBsZSByYXN0ZXIgbXVsdGlkaW1lbnNpb25uZWwgZW4gc29ydGllIGNvbnRpZW50IHRvdXRlcyBsZXMgdmFyaWFibGVzLiA8ZGl2Pjxicj5TaSBsZXMgcmFzdGVycyBtdWx0aWRpbWVuc2lvbm5lbHMgZW4gZW50csOpZSBjb250aWVubmVudCBkZXMgZGltZW5zaW9ucyBvdSB2YWxldXJzIGRlIGRpbWVuc2lvbiBkaWZmw6lyZW50ZXMsIGxlIHJhc3RlciBtdWx0aWRpbWVuc2lvbm5lbCBlbiBzb3J0aWUgaW5jbHV0IHRvdXRlcyBsZXMgZGltZW5zaW9ucyBldCB2YWxldXJzIGRlIGRpbWVuc2lvbi4gPGRpdj48YnI+U2kgbGVzIHJhc3RlcnMgbXVsdGlkaW1lbnNpb25uZWxzIGVuIGVudHLDqWUgY29udGllbm5lbnQgbGVzIG3Dqm1lcyBkaW1lbnNpb25zIGV0IHZhcmlhYmxlcywgbWFpcyBkZXMgw6l0ZW5kdWVzIHNwYXRpYWxlcyBkaWZmw6lyZW50ZXMsIGxlIHJhc3RlciBtdWx0aWRpbWVuc2lvbm5lbCBlbiBzb3J0aWUgaW5jbHV0IGxlcyB2YXJpYWJsZXMgZXQgbGVzIGRpbWVuc2lvbnMgZGVzIMOpdGVuZHVlcyBzcGF0aWFsZXMgZnVzaW9ubsOpZXMuPGRpdj48YnI+Q2V0dGUgZm9uY3Rpb24gcGV1dCDDqWdhbGVtZW50IMOqdHJlIHV0aWxpc8OpZSBzaSB2b3VzIGRpc3Bvc2V6IGRlIHBsdXNpZXVycyByYXN0ZXJzIHF1ZSB2b3VzIHNvdWhhaXRleiB0cmFpdGVyIGNvbW1lIHVuIHNldWwgw6lsw6ltZW50LCBwYXIgZXhlbXBsZSBwb3VyIGNhbGN1bGVyIGxlcyBtw6ptZXMgc3RhdGlzdGlxdWVzIHBvdXIgdG91cyBvdSBwb3VyIGzigJnDqXF1aWxpYnJhZ2UgZGVzIGNvdWxldXJzLCBkZSBtYW5pw6hyZSDDoCBuZSBwYXMgYXZvaXIgYmVzb2luIGTigJnDqXF1aWxpYnJlciBsZXMgY291bGV1cnMgZGUgY2hhcXVlIGltYWdlIHPDqXBhcsOpbWVudC4gQ2V0dGUgZm9uY3Rpb24gZXN0IHV0aWxlIGxvcnNxdWUgdm91cyB1dGlsaXNleiBkZXMgaW1hZ2VzIHN0b2Nrw6llcyBzb3VzIGZvcm1lIGRlIHR1aWxlcyBkaXN0aW5jdGVzIGVuIHJhaXNvbiBkZSBjb250cmFpbnRlcyBsacOpZXMgw6AgbGEgdGFpbGxlIGRlcyBmaWNoaWVycy4gTGVzIHR1aWxlcyBzb250IGFsb3JzIGNvbnNpZMOpcsOpZXMgY29tbWUgZmFpc2FudCBwYXJ0aWUgZGUgbGEgbcOqbWUgaW1hZ2UuXCIsXG5cdFx0Ym91bmRhcnlDbGVhbk5hbWU6IFwiTmV0dG95YWdlIGRlIGxpbWl0ZXNcIixcblx0XHRib3VuZGFyeUNsZWFuU25pcDogXCJMaXNzZSBsYSBsaW1pdGUgZW50cmUgZGVzIHpvbmVzLlwiLFxuXHRcdGJvdW5kYXJ5Q2xlYW5EZXNjOiBcIjxwPkNldHRlIGZvbmN0aW9uIGfDqW7DqXJhbGlzZSBvdSBzaW1wbGlmaWUgbGVzIHJhc3RlcnMgZW4gbGlzc2FudCBsZXMgbGltaXRlcyBlbnRyZSBsZXMgem9uZXMuIEVsbGUgb2ZmcmUgZGVzIG9wdGlvbnMgcGVybWV0dGFudCBkZSBjb250csO0bGVyIGxhIG1hbmnDqHJlIGRvbnQgbGVzIGNlbGx1bGVzIGRlcyB6b25lcyBlbiBlbnRyw6llIGluZmx1ZW5jZW50IGxlIGxpc3NhZ2UgZXQgbGEgcXVhbnRpdMOpIGRlIGxpc3NhZ2UgcXVpIHNlcmEgYXBwbGlxdcOpZS4gQ2hhcXVlIGNlbGx1bGUgZW4gZW50csOpZSBlc3Qgw6l2YWx1w6llIMOgIGzigJlhaWRlIGRlIHNlcyBodWl0IHZvaXNpbnMgaW1tw6lkaWF0cy48L3A+PHA+TGUgcHJvY2Vzc3VzIGRlIGxpc3NhZ2UgdHJpZSBk4oCZYWJvcmQgbGVzIGNlbGx1bGVzIHZvaXNpbmVzIHNlbG9uIHVuZSBwcmlvcml0w6kgcGFydGljdWxpw6hyZS4gTGEgcHJpb3JpdMOpIGTDqXRlcm1pbmUsIHBhcm1pIGxlcyBjZWxsdWxlcyB2b2lzaW5lcywgbGEgem9uZSBxdWkgcGV1dCByZW1wbGFjZXIgbGEgdmFsZXVyIGRlIGxhIGNlbGx1bGUgZGUgdHJhaXRlbWVudCBkYW5zIGxhIHNvcnRpZS48L3A+PHA+TGEgcHJpb3JpdMOpIHBldXQgw6p0cmUgYmFzw6llIHNvaXQgc3VyIGxhIHZhbGV1ciBkZXMgem9uZXMsIHNvaXQgc3VyIGxhIHRhaWxsZSBkZXMgem9uZXMuIExlIHBhcmFtw6h0cmUgPHN0cm9uZz5UeXBlIGRlIHRyaTwvc3Ryb25nPiBkw6l0ZXJtaW5lIGxlIHR5cGUgZGUgdHJpIMOgIHV0aWxpc2VyLiA8L3A+PHA+TGUgcsOpZ2xhZ2UgcGFyIGTDqWZhdXQgPHN0cm9uZz5OZSBwYXMgdHJpZXI8L3N0cm9uZz4gw6l2YWx1ZSBsYSBwcmlvcml0w6kgZW4gZm9uY3Rpb24gZGUgbGEgdmFsZXVyIGRlcyB6b25lcy4gTGVzIGNlbGx1bGVzIGRlIHpvbmVzIGRvdMOpZXMgZGUgdmFsZXVycyBwbHVzIGltcG9ydGFudGVzIHNlcm9udCBwcmlvcml0YWlyZXMgcG91ciBz4oCZw6l0ZW5kcmUgZGFucyBkZXMgem9uZXMgw6AgdmFsZXVycyBtb2luZHJlcy48L3A+PHA+TGEgdGFpbGxlLCBvdSBzdXJmYWNlIHRvdGFsZSwgZGVzIHpvbmVzIHBldXQgw6p0cmUgdXRpbGlzw6llIHBvdXIgdHJpZXIgbGEgcHJpb3JpdMOpLiBTaSBsZSBwYXJhbcOodHJlIGVzdCBkw6lmaW5pIHN1ciA8c3Ryb25nPkTDqWNyb2lzc2FudDwvc3Ryb25nPiwgbGVzIHpvbmVzIHNvbnQgdHJpw6llcyBwYXIgb3JkcmUgZGUgdGFpbGxlIGTDqWNyb2lzc2FudC4gTGVzIHpvbmVzIGRvdMOpZXMgZGUgc3VyZmFjZXMgdG90YWxlcyBwbHVzIGltcG9ydGFudGVzIHNlcm9udCBwcmlvcml0YWlyZXMgcG91ciBz4oCZw6l0ZW5kcmUgZGFucyBkZXMgem9uZXMgw6Agc3VyZmFjZXMgdG90YWxlcyBtb2luZHJlcy4gU2kgbGUgcGFyYW3DqHRyZSBlc3QgZMOpZmluaSBzdXIgPHN0cm9uZz5Dcm9pc3NhbnQ8L3N0cm9uZz4sIGPigJllc3QgbGUgY29udHJhaXJlwqA6IGxlcyB6b25lcyDDoCBzdXJmYWNlcyB0b3RhbGVzIG1vaW5kcmVzIHNlcm9udCBwcmlvcml0YWlyZXMgcG91ciBz4oCZw6l0ZW5kcmUgZGFucyBkZXMgem9uZXMgZG90w6llcyBkZSBzdXJmYWNlcyB0b3RhbGVzIHBsdXMgaW1wb3J0YW50ZXMuPC9wPjxwPkxhIHF1YW50aXTDqSBkZSBsaXNzYWdlIGVzdCBjb250csO0bMOpZSBwYXIgbGUgcGFyYW3DqHRyZSA8c3Ryb25nPkV4w6ljdXRlciBkZXV4IGZvaXMgbOKAmWV4cGFuc2lvbiBldCBsYSBjb250cmFjdGlvbjwvc3Ryb25nPiwgcXVpIGTDqXRlcm1pbmUgbGUgbm9tYnJlIGTigJlleMOpY3V0aW9ucyBkdSBwcm9jZXNzdXMgZOKAmWV4cGFuc2lvbiBldCBkZSBjb250cmFjdGlvbi48L3A+PHA+U2kgbGUgcGFyYW3DqHRyZSBlc3QgZMOpc8OpbGVjdGlvbm7DqSwgbGUgcHJvY2Vzc3VzIGTigJlleHBhbnNpb24gZXQgZGUgY29udHJhY3Rpb24gZXN0IGVmZmVjdHXDqSB1bmUgc2V1bGUgZm9pcy4gU2kgbGUgcGFyYW3DqHRyZSBlc3QgY29jaMOpLCBsZSBwcm9jZXNzdXMgZOKAmWV4cGFuc2lvbiBldCBkZSBjb250cmFjdGlvbiBlc3QgZWZmZWN0dcOpIGRldXggZm9pcywgY2UgcXVpIGFqb3V0ZSB1biBkZWdyw6kgc3VwcGzDqW1lbnRhaXJlIGRlIGxpc3NhZ2UgZGVzIGxpbWl0ZXMgZGVzIHpvbmVzLjwvcD48cD5TaSBsZXMgdmFsZXVycyBkZXMgaHVpdCBjZWxsdWxlcyB2b2lzaW5lcyBzb250IGlkZW50aXF1ZXMgw6AgY2VsbGVzIGRlIGxhIGNlbGx1bGUgZGUgdHJhaXRlbWVudCwgbGEgY2VsbHVsZSBlbiBzb3J0aWUgY29uc2VydmUgbGEgdmFsZXVyIGRlIGxhIGNlbGx1bGUgZW4gZW50csOpZS48L3A+XCIsXG5cdFx0cHJlZGljdFVzaW5nUmVncmVzc2lvbk5hbWU6IFwiUHLDqXZvaXIgw6AgbOKAmWFpZGUgZOKAmXVuZSByw6lncmVzc2lvblwiLFxuXHRcdHByZWRpY3RVc2luZ1JlZ3Jlc3Npb25TbmlwOiBcIkNhbGN1bGUgdW4gcmFzdGVyIHByw6l2dSBlbiBmb25jdGlvbiBk4oCZZW50csOpZXMgZGUgZG9ubsOpZXMgcmFzdGVyIGV0IGTigJl1biBtb2TDqGxlIGRlIHLDqWdyZXNzaW9uLiBMZSBtb2TDqGxlIGRlIHLDqWdyZXNzaW9uIGNvbnN0aXR1ZSBsYSBzb3J0aWUgZGUgbOKAmW91dGlsIGRlIGfDqW90cmFpdGVtZW50IHJhc3RlciA8c3Ryb25nPkVudHJhw65uZXIgbGUgbW9kw6hsZSBkZSByw6lncmVzc2lvbiBBcmJyZXMgYWzDqWF0b2lyZXM8L3N0cm9uZz4uXCIsXG5cdFx0cHJlZGljdFVzaW5nUmVncmVzc2lvbkRlc2M6IFwiPHA+TGUgbW9kw6hsZSBkZSByw6lncmVzc2lvbiBlc3QgZMOpZmluaSBkYW5zIHVuIGZpY2hpZXIgZGUgZMOpZmluaXRpb24gZGUgcsOpZ3Jlc3Npb24gRXNyaSAoLmVjZCkuIENlIGZpY2hpZXIgY29udGllbnQgdG91dGVzIGxlcyBpbmZvcm1hdGlvbnMgcmVsYXRpdmVzIMOgIHVuIGpldSBkZSBkb25uw6llcyBzcMOpY2lmaXF1ZSBvdSDDoCB1biBlbnNlbWJsZSBkZSBqZXV4IGRlIGRvbm7DqWVzLCBhaW5zaSBxdWUgbGUgbW9kw6hsZSBkZSByw6lncmVzc2lvbi4gSWwgZXN0IGfDqW7DqXLDqSBwYXIgbOKAmW91dGlsIGRlIGfDqW90cmFpdGVtZW50IHJhc3RlciA8c3Ryb25nPkVudHJhw65uZXIgbGUgbW9kw6hsZSBkZSByw6lncmVzc2lvbiBBcmJyZXMgYWzDqWF0b2lyZXM8L3N0cm9uZz4uPC9wPjxwPkzigJllbnRyw6llIHBldXQgw6p0cmUgdW4gcmFzdGVyIMOgIHVuZSBzZXVsZSBiYW5kZSBvdSDDoCBwbHVzaWV1cnMgYmFuZGVzLCB1biByYXN0ZXIgbXVsdGlkaW1lbnNpb25uZWwgb3UgdW5lIGxpc3RlIGRlIGNlcyB0eXBlcy4gTGVzIHR5cGVzIGRlcyByYXN0ZXJzIGVuIGVudHLDqWUgZG9pdmVudCDDqnRyZSBpZGVudGlxdWVzIGF1IHR5cGUgZHUgcmFzdGVyIGVudHJhw65uw6kgcGFyIGxlIG1vZMOobGUgZGUgcsOpZ3Jlc3Npb24uPC9wPjx1bD48bGk+TG9yc3F1ZSBs4oCZZW50csOpZSBlc3QgdW4gcmFzdGVyIMOgIHBsdXNpZXVycyBiYW5kZXMsIGNoYXF1ZSBiYW5kZSBlc3QgdHJhaXTDqWUgY29tbWUgdW5lIHZhcmlhYmxlIGRlIHByw6l2aXNpb24uIExlcyBiYW5kZXMgZG9pdmVudCDDqnRyZSBkYW5zIGxlIG3Dqm1lIG9yZHJlIHF1ZSBkYW5zIGzigJllbnRyw6llIMOgIHBsdXNpZXVycyBiYW5kZXMgZGUgbOKAmW91dGlsIGTigJllbnRyYcOubmVtZW50IGR1IG1vZMOobGUgZGUgcsOpZ3Jlc3Npb24uPC9saT48bGk+TG9yc3F1ZSBs4oCZZW50csOpZSBlc3QgdW4gcmFzdGVyIG11bHRpZGltZW5zaW9ubmVsLCBjaGFxdWUgdmFyaWFibGUgZXN0IHRyYWl0w6llIGNvbW1lIHVuZSB2YXJpYWJsZSBkZSBwcsOpdmlzaW9uIGV0IGRvaXQgcHLDqXNlbnRlciB1bmUgc2V1bGUgYmFuZGUgZXQgdW5lIGRpbWVuc2lvbiB0ZW1wb3JlbGxlLiBM4oCZb3JkcmUgZXQgbGVzIG5vbXMgZGVzIHZhcmlhYmxlcyBkb2l2ZW50IMOqdHJlIGxlcyBtw6ptZXMgcXVlIGNldXggZGUgbOKAmWVudHLDqWUgbG9ycyBkZSBs4oCZZW50cmHDrm5lbWVudCBkdSBtb2TDqGxlIGRlIHLDqWdyZXNzaW9uLiBMYSBzb3J0aWUgZXN0IHVuIHJhc3RlciBtdWx0aWRpbWVuc2lvbm5lbC48L2xpPjxsaT5M4oCZZW50csOpZSBwZXV0IMOqdHJlIHVuZSBsaXN0ZSBk4oCZw6lsw6ltZW50cy4gTGUgbm9tYnJlIGTigJnDqWzDqW1lbnRzIGV0IGxldXIgb3JkcmUgZG9pdmVudCBjb3JyZXNwb25kcmUgw6AgbOKAmWVudHLDqWUgbG9ycyBkZSBs4oCZZW50cmHDrm5lbWVudCBkdSBtb2TDqGxlIGRlIHLDqWdyZXNzaW9uLjwvbGk+PC91bD5cIixcblx0XHRkaW1lbnNpb25hbE1vdmluZ1N0YXRpc3RpY3NOYW1lOiBcIlN0YXRpc3RpcXVlcyBtb2JpbGVzIGRpbWVuc2lvbm5lbGxlc1wiLFxuXHRcdGRpbWVuc2lvbmFsTW92aW5nU3RhdGlzdGljc1NuaXA6IFwiQ2FsY3VsZSBsZXMgc3RhdGlzdGlxdWVzIHN1ciB1bmUgZmVuw6p0cmUgZGUgZMOpcGxhY2VtZW50IHN1ciBkZXMgZG9ubsOpZXMgbXVsdGlkaW1lbnNpb25uZWxsZXMgbGUgbG9uZyBk4oCZdW5lIGRpbWVuc2lvbiBzcMOpY2lmacOpZS5cIixcblx0XHRkaW1lbnNpb25hbE1vdmluZ1N0YXRpc3RpY3NEZXNjOiBcIjxwPkxhIGZvbmN0aW9uIFN0YXRpc3RpcXVlcyBkZSBkw6lwbGFjZW1lbnQgZGltZW5zaW9ubmVsIGNhbGN1bGUgZGl2ZXJzZXMgc3RhdGlzdGlxdWVzIGRhbnMgdW5lIGZlbsOqdHJlIHByw6lkw6lmaW5pZSBwb3VyIHRvdXRlcyBsZXMgdmFsZXVycyBkZSBkaW1lbnNpb24gbGUgbG9uZyBk4oCZdW5lIGRpbWVuc2lvbi4gQ2V0dGUgZm9uY3Rpb24gZXh0cmFpdCB1bmUgY291Y2hlIHJhc3RlciBtdWx0aWRpbWVuc2lvbm5lbGxlIGVuIHRhbnQgcXXigJllbnRyw6llIGV0IGNyw6llIHVuZSBjb3VjaGUgcmFzdGVyIG11bHRpZGltZW5zaW9ubmVsbGUgZW4gdGFudCBxdWUgc29ydGllIGF5YW50IGxhIG3Dqm1lIHRhaWxsZSBkZSBkaW1lbnNpb24gcXVlIGxhIGNvdWNoZSBlbiBlbnRyw6llLjwvcD48cD5Wb3VzIHBvdXZleiBzcMOpY2lmaWVyIHVuZSBkaW1lbnNpb24gZG9udCBsZXMgdmFsZXVycyBzb250IGNvbnNpZMOpcsOpZXMgbG9ycyBkdSBjYWxjdWwuIFBhciBkw6lmYXV0LCBsYSBmb25jdGlvbiBjYWxjdWxlIGxlcyB2YWxldXJzIGxlIGxvbmcgZGUgbGEgcHJlbWnDqHJlIGRpbWVuc2lvbiBub24gc3BhdGlhbGUuIFZvdXMgcG91dmV6IMOpZ2FsZW1lbnQgc3DDqWNpZmllciB1bmUgdGFpbGxlIGRlIGZlbsOqdHJlIGVuIHNww6ljaWZpYW50IGxlcyBwYXJhbcOodHJlcyBGZW7DqnRyZSBhcnJpw6hyZSBldCBGZW7DqnRyZSBhdmFudC48L3A+PHA+TG9yc3F1ZSBsZSBwYXJhbcOodHJlIFR5cGUgZGUgc3RhdGlzdGlxdWUgZXN0IGTDqWZpbmkgc3VyIENlbnRpbGUsIGxlcyBwYXJhbcOodHJlcyBWYWxldXIgZGUgY2VudGlsZSBldCBUeXBlIGTigJlpbnRlcnBvbGF0aW9uIGRlIGNlbnRpbGUgZGV2aWVubmVudCBkaXNwb25pYmxlcy4gVm91cyBwb3V2ZXogdXRpbGlzZXIgY2VzIHBhcmFtw6h0cmVzIGFmaW4gZGUgc3DDqWNpZmllciBsZSBjZW50aWxlIMOgIGNhbGN1bGVyIGV0IGNob2lzaXIgbGUgdHlwZSBk4oCZaW50ZXJwb2xhdGlvbiDDoCB1dGlsaXNlciwgcmVzcGVjdGl2ZW1lbnQuIExvcnNxdWUgbGUgcGFyYW3DqHRyZSBUeXBlIGRlIHN0YXRpc3RpcXVlIGVzdCBkw6lmaW5pIHN1ciBNb3llbm5lIGNpcmN1bGFpcmUsIGxlIHBhcmFtw6h0cmUgVmFsZXVyIGRlIHJlcGxpIGNpcmN1bGFpcmUgZGV2aWVudCBkaXNwb25pYmxlLiBMYSB2YWxldXIgZGUgcmVwbGkgY2lyY3VsYWlyZSBlc3QgdXRpbGlzw6llIHBvdXIgY29udmVydGlyIHVuZSB2YWxldXIgbGluw6lhaXJlIGVuIHBsYWdlIGTigJl1bmUgbW95ZW5uZSBjaXJjdWxhaXJlIGRvbm7DqWU8L3A+LlwiLFxuXHRcdHRlcnJhaW5GbGF0dGVuRnVuY3Rpb25OYW1lOiBcIkFwbGFuaXIgbGUgdGVycmFpblwiLFxuXHRcdHRlcnJhaW5GbGF0dGVuRnVuY3Rpb25TbmlwOiBcIkNvcnJpZ2UgbGVzIGRpc3RvcnNpb25zIHJhZGlvbcOpdHJpcXVlcywgbGnDqWVzIMOgIGxhIHRvcG9ncmFwaGllLCBkZXMgZG9ubsOpZXMgZGUgcmFkYXIgw6Agc3ludGjDqHNlIGTigJlvdXZlcnR1cmUgKFNBUikgZW4gZW50csOpZS5cIixcblx0XHR0ZXJyYWluRmxhdHRlbkZ1bmN0aW9uRGVzYzogXCI8cD5MYSBmb25jdGlvbiByYXN0ZXIgQXBsYW5pciBsZSB0ZXJyYWluIGNvcnJpZ2UgbGVzIGRpc3RvcnNpb25zIHJhZGlvbcOpdHJpcXVlcywgbGnDqWVzIMOgIGxhIHRvcG9ncmFwaGllLCBkZXMgZG9ubsOpZXMgZGUgcmFkYXIgw6Agc3ludGjDqHNlIGTigJlvdXZlcnR1cmUgKFNBUikgZW4gZW50csOpZS48L3A+PHA+TGVzIGRvbm7DqWVzIHJhZGFyIGVuIGVudHLDqWUgZG9pdmVudCDDqnRyZSBjYWxpYnLDqWVzIHN1ciBiw6p0YSB6w6lyby4gVXRpbGlzZXogbOKAmW91dGlsIEFwcGxpcXVlciBsZSBjYWxpYnJhZ2UgcmFkaW9tw6l0cmlxdWUgcG91ciBjYWxpYnJlciBsZXMgZG9ubsOpZXMgcmFkYXIgc3VyIGLDqnRhIHrDqXJvLjwvcD48cD5TaSBsZSBNTkUgZW4gZW50csOpZSBuZSBjb3V2cmUgcGFzIGzigJlpbnTDqWdyYWxpdMOpIGR1IGpldSBkZSBkb25uw6llcyBTQVIsIGzigJlvdXRpbCBnw6luw6hyZSBkZXMgdmFsZXVycyBOb0RhdGEgcG91ciBsZXMgcGl4ZWxzIGVuIGRlaG9ycyBkZSBs4oCZw6l0ZW5kdWUgZHUgTU5FIHBvdXIgbGVzIHNvcnRpZXMgZ2FtbWEgesOpcm8sIHNpZ21hIHrDqXJvLCBkZSBsYSBzdXJmYWNlIGRlIGRpc3BlcnNpb24gZXQgZGUgbGEgZGlzdG9yc2lvbiBnw6lvbcOpdHJpcXVlLiBQb3VyIGxhIHNvcnRpZSBkdSBtYXNxdWUgZGUgZGlzdG9yc2lvbiBnw6lvbcOpdHJpcXVlLCBs4oCZb3V0aWwgZ8OpbsOocmUgZGVzIHZhbGV1cnMgaW5kw6l0ZXJtaW7DqWVzIHBvdXIgbGVzIHBpeGVscyBlbiBkZWhvcnMgZGUgbOKAmcOpdGVuZHVlIGR1IE1ORS48L3A+PHA+TGUgTU5FIGVuIGVudHLDqWUgZG9pdCB1dGlsaXNlciBsZSBzeXN0w6htZSBkZSBjb29yZG9ubsOpZXMgZ8Opb2dyYXBoaXF1ZXMgV0dTwqAxOTg0IChFUFNHOjQzMjYpLjwvcD5cIixcblx0XHRjcmVhdGVDb2xvckNvbXBvc2l0ZUZ1bmN0aW9uTmFtZTogXCJDcsOpZXIgdW5lIGNvbXBvc2l0aW9uIGNvbG9yw6llXCIsXG5cdFx0Y3JlYXRlQ29sb3JDb21wb3NpdGVGdW5jdGlvblNuaXA6IFwiUHJvZHVpdCB1biByYXN0ZXIgw6AgdHJvaXMgYmFuZGVzIMOgIHBhcnRpciBk4oCZdW4gamV1IGRlIGRvbm7DqWVzIHJhc3RlciBtdWx0aWJhbmRlIGRhbnMgbGVxdWVsIGNoYXF1ZSBiYW5kZSB1dGlsaXNlIHVuIGNhbGN1bCBhbGfDqWJyaXF1ZSBiYXPDqSBzdXIgbOKAmWFsZ8OoYnJlIGRlcyBiYW5kZXMuXCIsXG5cdFx0Y3JlYXRlQ29sb3JDb21wb3NpdGVGdW5jdGlvbkRlc2M6IFwiPHA+TGEgZm9uY3Rpb24gcmFzdGVyIENyw6llciB1bmUgY29tcG9zaXRpb24gY29sb3LDqWUgcHJvZHVpdCB1biByYXN0ZXIgw6AgdHJvaXMgYmFuZGVzIMOgIHBhcnRpciBk4oCZdW4gamV1IGRlIGRvbm7DqWVzIHJhc3RlciBtdWx0aWJhbmRlIGRhbnMgbGVxdWVsIGNoYXF1ZSBiYW5kZSB1dGlsaXNlIHVuIGNhbGN1bCBhbGfDqWJyaXF1ZSBiYXPDqSBzdXIgbOKAmWFsZ8OoYnJlIGRlcyBiYW5kZXMuPC9wPjxwPkxvcnNxdWUgdm91cyBkw6lmaW5pc3NleiB1biBhbGdvcml0aG1lIGFyaXRobcOpdGlxdWUgZGUgYmFuZGUsIHZvdXMgcG91dmV6IHNhaXNpciB1bmUgZm9ybXVsZSBhbGfDqWJyaXF1ZSB1bmlsaWduZSBwb3VyIGNoYXF1ZSBleHByZXNzaW9uIGFmaW4gZGUgY3LDqWVyIHVuZSBzb3J0aWUgbXVsdGliYW5kZS4gTGVzIG9ww6lyYXRldXJzIHByaXMgZW4gY2hhcmdlIHNvbnQgdW5haXJlc8KgOiBhZGRpdGlvbsKgKCspLCBzb3VzdHJhY3Rpb27CoCgtKSwgbXVsdGlwbGljYXRpb27CoCgqKSBldCBkaXZpc2lvbsKgKC8pLjwvcD48cD5Mb3JzIGRlIGzigJl1dGlsaXNhdGlvbiBk4oCZdW4gaWRlbnRpZmlhbnQgZGUgYmFuZGUgZGFucyB1bmUgZXhwcmVzc2lvbiwgaWRlbnRpZmlleiBsYSBiYW5kZSBlbiBham91dGFudCB1biBwcsOpZml4ZcKgQiBvdcKgYiBhdSBudW3DqXJvIGRlIGxhIGJhbmRlLjwvcD48cD5VbmUgY29tYmluYWlzb24gZGUgYmFuZGVzIGNvdXJhbnRlIHV0aWxpc8OpZSBwb3VyIGxlIHJhZGFyIMOgIHN5bnRow6hzZSBk4oCZb3V2ZXJ0dXJlIChTQVIpIGRhbnMgbGVzIHVuaXTDqXMgbGluw6lhaXJlcyBlc3QgVlYgcG91ciByb3VnZSwgVkggcG91ciB2ZXJ0IGV0IFZWLVZIIHBvdXIgYmxldS4gU2kgbGVzIGRvbm7DqWVzIGVuIGVudHLDqWUgc29udCBleHByaW3DqWVzIGVuIGTDqWNpYmVscywgbGEgY29tYmluYWlzb24gZGUgYmFuZGVzIGRvaXQgw6p0cmUgVlYgcG91ciByb3VnZSwgVkggcG91ciB2ZXJ0IGV0IFZWLVZIIHBvdXIgYmxldS48L3A+XCIsXG5cdFx0c3VyZmFjZVBhcmFtZXRlcnNOYW1lOiBcIlBhcmFtw6h0cmVzIGRlIHN1cmZhY2VcIixcblx0XHRzdXJmYWNlUGFyYW1ldGVyc1NuaXA6IFwiRMOpdGVybWluZSBsZXMgcGFyYW3DqHRyZXMgZOKAmXVuIHJhc3RlciBkZSBzdXJmYWNlLCB0ZWxzIHF1ZSBs4oCZZXhwb3NpdGlvbiwgbGEgcGVudGUgZXQgcGx1c2lldXJzIHR5cGVzIGRlIGNvdXJidXJlcyDDoCBs4oCZYWlkZSBkZSBtw6l0aG9kZXMgZ8Opb2TDqXNpcXVlcy5cIixcblx0XHRzdXJmYWNlUGFyYW1ldGVyc0Rlc2M6IFwiPHA+TGEgZm9uY3Rpb24gUGFyYW3DqHRyZXMgZGUgc3VyZmFjZSBkw6l0ZXJtaW5lIGxlcyBwYXJhbcOodHJlcyBk4oCZdW4gcmFzdGVyIGRlIHN1cmZhY2UsIHRlbHMgcXVlIGzigJlleHBvc2l0aW9uLCBsYSBwZW50ZSBldCBwbHVzaWV1cnMgdHlwZXMgZGUgY291cmJ1cmVzIMOgIGzigJlhaWRlIGRlIG3DqXRob2RlcyBnw6lvZMOpc2lxdWVzLjwvcD48cD5DZXR0ZSBmb25jdGlvbiBwZXV0IMOqdHJlIHV0aWxpc8OpZSBkYW5zIGxlcyBhcHBsaWNhdGlvbnMgc3VpdmFudGVzwqA6PC9wPjx1bD48bGk+Q2FsY3VsZXIgbOKAmWV4cG9zaXRpb24gZXQgbGEgcGVudGUgw6AgbOKAmWFpZGUgZGUgbcOpdGhvZGVzIGfDqW9kw6lzaXF1ZXMuPC9saT48bGk+Q2FsY3VsZXIgZGlmZsOpcmVudHMgdHlwZXMgZGUgY291cmJ1cmVzIMOgIHBhcnRpciBk4oCZdW4gcmFzdGVyIGRlIHN1cmZhY2UgZW4gZW50csOpZSwgcGFyIGV4ZW1wbGUsIDxzdHJvbmc+Q291cmJ1cmUgdGFuZ2VudGllbGxlIChpc29saWduZSBub3JtYWxlKTwvc3Ryb25nPiBxdWkgY2FyYWN0w6lyaXNlIGxhIGNvbnZlcmdlbmNlIGV0IGxhIGRpdmVyZ2VuY2UgdG9wb2dyYXBoaXF1ZXMgZHUgZmx1eCBzdXIgbGEgc3VyZmFjZS48L2xpPjwvdWw+XCIsXG5cdFx0bGVhc3RDb3N0Q29ycmlkb3JOYW1lOiBcIkNvdWxvaXIgZGUgbW9pbmRyZSBjb8O7dFwiLFxuXHRcdGxlYXN0Q29zdENvcnJpZG9yU25pcDogXCJDYWxjdWxlIGxhIHNvbW1lIGRlIGRldXggcmFzdGVycyBkZSBkaXN0YW5jZSBkZSBjb8O7dCBjdW11bMOpIGF2ZWMgbGEgcG9zc2liaWxpdMOpIGTigJlhcHBsaXF1ZXIgdW4gc2V1aWwgZW4gZm9uY3Rpb24gZHUgcG91cmNlbnRhZ2Ugb3UgZHUgY2/Du3QgY3VtdWzDqS5cIixcblx0XHRsZWFzdENvc3RDb3JyaWRvckRlc2M6IFwiPHA+TGVzIHJhc3RlcnMgZW4gZW50csOpZSBkb2l2ZW50IMOqdHJlIGRlcyByYXN0ZXJzIGTigJlhY2N1bXVsYXRpb24gZGUgZGlzdGFuY2UgZXQgZGUgZGlyZWN0aW9uIGFycmnDqHJlIGfDqW7DqXLDqXMgcGFyIGxhIGZvbmN0aW9uIDxzdHJvbmc+QWNjdW11bGF0aW9uIGRlIGRpc3RhbmNlPC9zdHJvbmc+IG91IDxzdHJvbmc+QWxsb2NhdGlvbiBkZSBkaXN0YW5jZTwvc3Ryb25nPi4gSWxzIGRvaXZlbnQgw6p0cmUgYmFzw6lzIHN1ciBsYSBkaXN0YW5jZSBkZSBjb8O7dCBldCBsZXMgbcOqbWVzIHBhcmFtw6l0cmFnZXMgZG9pdmVudCDDqnRyZSB1dGlsaXPDqXMgcG91ciBsYSBjcsOpYXRpb24gZGVzIGNvdWNoZXMgZGUgY2hhcXVlIHNvdXJjZS4gQXVjdW4gcGFyYW3DqHRyZSBkw6lwZW5kYW50IGRlIGxhIGRpcmVjdGlvbm5hbGl0w6kgKGZhY3RldXIgaG9yaXpvbnRhbCwgZmFjdGV1ciB2ZXJ0aWNhbCBldCBzZW5zIGRlIGTDqXBsYWNlbWVudCkgbmUgZG9pdCDDqnRyZSB1dGlsaXPDqSBwb3VyIGxhIGNyw6lhdGlvbiBkZSBjZXMgcmFzdGVycy48L3A+PHA+TGVzIHZhbGV1cnMgZHUgcmFzdGVyIGRlIGNvdWxvaXIgZW4gc29ydGllIGNvcnJlc3BvbmRlbnQgw6AgbGEgc29tbWUgZHUgY2/Du3QgY3VtdWzDqSBwb3VyIGF0dGVpbmRyZSB1biBlbXBsYWNlbWVudCBkb25uw6kgYXZlYyBsZXMgbcOqbWVzIHVuaXTDqXMgcXVlIGNlbGxlcyBkZXMgcmFzdGVycyBkZSBkaXN0YW5jZSBkZSBjb8O7dCBjdW11bMOpIGVuIGVudHLDqWUuPC9wPjxwPlNpIHVuZSB2YWxldXIgPHN0cm9uZz5TZXVpbDwvc3Ryb25nPiBzcMOpY2lmacOpZSBlc3Qgc3Vww6lyaWV1cmUgYXUgY2/Du3QgY3VtdWzDqSBtYXhpbWFsIGxvcnNxdWUgbGVzIGRldXggcmFzdGVycyBk4oCZYWNjdW11bGF0aW9uIGRlIGRpc3RhbmNlIHNvbnQgYWRkaXRpb25uw6lzLCBsZSByYXN0ZXIgZGUgY291bG9pciBlbiBzb3J0aWUgY291dnJlIGxhIG3Dqm1lIHpvbmUgcXVlIGxlcyByYXN0ZXJzIGRlIGNvw7t0IGN1bXVsw6kgZW4gZW50csOpZS48L3A+PHA+U2kgdW5lIHZhbGV1ciBkZSBzZXVpbCBzcMOpY2lmacOpZSBlc3QgaW5mw6lyaWV1cmUgw6AgbGEgdmFsZXVyIG1pbmltYWxlIGRhbnMgbGUgcmFzdGVyIGRlIGNvdWxvaXIsIHVuIG1lc3NhZ2UgZOKAmWF2ZXJ0aXNzZW1lbnQgZXN0IHJlbnZvecOpIGV0IGxlIHJhc3RlciBlbiBzb3J0aWUgZXN0IHZpZGUuPC9wPjxwPklsIGVzdCBwb3NzaWJsZSBxdWUgbGUgcmFzdGVyIGRlIGNvdWxvaXIgZW4gc29ydGllIGNvbnRpZW5uZSBkZXMgY2VsbHVsZXMgYXZlYyBkZXMgY2/Du3RzIGN1bXVsw6lzIGzDqWfDqHJlbWVudCBzdXDDqXJpZXVycyDDoCBsYSB2YWxldXIgZGUgc2V1aWwuIEPigJllc3QgbGUgY2FzIGxvcnNxdWUgbGVzIHJhc3RlcnMgZGUgZGlyZWN0aW9uIGFycmnDqHJlIHV0aWxpc2VudCBkZXMgY2VsbHVsZXMgYXV4cXVlbGxlcyBkZXMgY2/Du3RzIGzDqWfDqHJlbWVudCBzdXDDqXJpZXVycyBhdSBzZXVpbCBvbnQgw6l0w6kgYXR0cmlidcOpcyBhZmluIGRlIGNvbm5lY3RlciBkZXMgY2VsbHVsZXMgZMOpY29ubmVjdMOpZXMgYXUgY291bG9pci48L3A+XCIsXG5cdFx0Z2VvbWV0cmljTWVkaWFuTmFtZTogXCJNw6lkaWFuZSBnw6lvbcOpdHJpcXVlXCIsXG5cdFx0Z2VvbWV0cmljTWVkaWFuU25pcDogXCJMYSBmb25jdGlvbiBNw6lkaWFuZSBnw6lvbcOpdHJpcXVlIGNhbGN1bGUgbGEgbcOpZGlhbmUgZ8Opb23DqXRyaXF1ZSBkZXMgcGl4ZWxzIGRhbnMgdW5lIHPDqXJpZSBjaHJvbm9sb2dpcXVlIGTigJlpbWFnZXMgbXVsdGliYW5kZXMuXCIsXG5cdFx0Z2VvbWV0cmljTWVkaWFuRGVzYzogXCI8cD5DZXR0ZSBmb25jdGlvbiByw6lkdWl0IGxlIGJydWl0IGV0IGxlcyBwb2ludHMgYWJlcnJhbnRzIGRhbnMgbGVzIGltYWdlcyBk4oCZdW5lIHPDqXJpZSBjaHJvbm9sb2dpcXVlIGVuIGNhbGN1bGFudCB1biBwaXhlbCBtw6lkaWFuIGfDqW9tw6l0cmlxdWUgcG91ciBjaGFxdWUgbWF0cmljZSBkZSBwaXhlbHMgZGFucyBsYSBwaWxlIGTigJlpbWFnZXMuIEzigJlhbGdvcml0aG1lIGNvbnNlcnZlIGxlcyByZWxhdGlvbnMgc3BlY3RyYWxlcyBlbnRyZSBsZXMgYmFuZGVzIGRhbnMgbGVzIHNwZWN0cmVzIGRlcyBwaXhlbHMgYWZpbiBxdWUgbGEgc29ydGllIHB1aXNzZSDDqnRyZSB1dGlsaXPDqWUgZGFucyB1bmUgYW5hbHlzZSwgdGVsbGUgcXVlIGxlIGNhbGN1bCBkZXMgaW5kaWNlcyBkZSB2w6lnw6l0YXRpb24uPC9wPjxwPlZvdXMgZGV2ZXogbWFzcXVlciBsZXMgbnVhZ2VzIGV0IGxlcyBvbWJyZXMgw6AgbOKAmWFpZGUgZGUgbGEgYmFuZGUgZOKAmWFzc3VyYW5jZSBxdWFsaXTDqSAoUUEpIGR1IGpldSBkZSBkb25uw6llcyBhdmFudCBk4oCZYXBwbGlxdWVyIGNldHRlIGZvbmN0aW9uLjwvcD48cD5TaSBs4oCZaW1hZ2UgZW4gZW50csOpZSBjb21wb3J0ZSBkZXMgZG9ubsOpZXMgw6AgdmlyZ3VsZSBmbG90dGFudGUsIGNvbW1lIHVuZSByw6lmbGVjdGFuY2UgZGUgc3VyZmFjZSBhdmVjIGRlcyB2YWxldXJzIGNvbXByaXNlcyBlbnRyZcKgMCBldMKgMSwgdW5lIHZhbGV1ciBlcHNpbG9uIGRlwqAwLDAwMSBwcm9kdWl0IGfDqW7DqXJhbGVtZW50IGRlcyByw6lzdWx0YXRzIGRlIHF1YWxpdMOpIHNhdGlzZmFpc2FudGUuPC9wPlwiXG5cdH0sXG5cdHJmeEFyZ3M6IHtcblx0XHRyYXN0ZXJOYW1lOiBcIlJhc3RlclwiLFxuXHRcdGNvbG9yU2NoZW1lVHlwZU5hbWU6IFwiVHlwZSBkZSBjb21iaW5haXNvbiBkZSBjb3VsZXVyc1wiLFxuXHRcdGNvbG9ybWFwTmFtZTogXCJQYWxldHRlIGRlIGNvdWxldXJzXCIsXG5cdFx0Y29sb3JtYXBOYW1lTmFtZTogXCJOb20gZGUgbGEgcGFsZXR0ZSBkZSBjb3VsZXVyc1wiLFxuXHRcdGNvbG9yUmFtcE5hbWU6IFwiRMOpZ3JhZMOpIGRlIGNvdWxldXJzXCIsXG5cdFx0Y29udHJhc3RPZmZzZXROYW1lOiBcIkTDqWNhbGFnZSBkZSBjb250cmFzdGVcIixcblx0XHRicmlnaHRuZXNzT2Zmc2V0TmFtZTogXCJEw6ljYWxhZ2UgZGUgbGEgbHVtaW5vc2l0w6lcIixcblx0XHRtZXRob2ROYW1lOiBcIk3DqXRob2RlXCIsXG5cdFx0YmFuZE5hbWVzTmFtZTogXCJOb21zIGRlcyBjYW5hdXhcIixcblx0XHRiYW5kV2F2ZWxlbmd0aHNOYW1lOiBcIkxvbmd1ZXVycyBkJ29uZGVzIGRlcyBjYW5hdXhcIixcblx0XHRiYW5kSWRzTmFtZTogXCJJZGVudGlmaWFudHMgZGVzIGNhbmF1eFwiLFxuXHRcdG1pc3NpbmdCYW5kQWN0aW9uTmFtZTogXCJBY3Rpb24gY29uY2VybmFudCBsZSBjYW5hbCBtYW5xdWFudFwiLFxuXHRcdGNvbnZlcnNpb25QYXJhbWV0ZXJzTmFtZTogXCJQYXJhbcOodHJlcyBkZSBjb252ZXJzaW9uXCIsXG5cdFx0aGlsbHNoYWRlVHlwZU5hbWU6IFwiVHlwZSBkJ29tYnJhZ2VcIixcblx0XHRhemltdXRoTmFtZTogXCJBemltdXRcIixcblx0XHRhbHRpdHVkZU5hbWU6IFwiQWx0aXR1ZGVcIixcblx0XHRzbG9wZVR5cGVOYW1lOiBcIk1pc2Ugw6AgbOKAmcOpY2hlbGxlXCIsXG5cdFx0ekZhY3Rvck5hbWU6IFwiRmFjdGV1ciBaXCIsXG5cdFx0UFNQb3dlck5hbWU6IFwiUHVpc3NhbmNlIGRlIGxhIHRhaWxsZSBkZSBwaXhlbFwiLFxuXHRcdFBTWkZhY3Rvck5hbWU6IFwiRmFjdGV1ciBkZSB0YWlsbGUgZGUgcGl4ZWxcIixcblx0XHRyZW1vdmVFZGdlRWZmZWN0TmFtZTogXCJEw6lzYWN0aXZlciBsJ2ludGVycG9sYXRpb24gZGVzIHBpeGVscyBkZSB0cm9uw6dvbiBwYXIgZMOpZmF1dFwiLFxuXHRcdGZyb21Vbml0TmFtZTogXCJEZSBs4oCZdW5pdMOpXCIsXG5cdFx0dG9Vbml0TmFtZTogXCLDgCBs4oCZdW5pdMOpXCIsXG5cdFx0cmFzdGVyVHlwZU5hbWU6IFwiVHlwZVwiLFxuXHRcdG1pbk5hbWU6IFwiU29ydGllIG1pbmltYWxlXCIsXG5cdFx0bWF4TmFtZTogXCJTb3J0aWUgbWF4aW1hbGVcIixcblx0XHRtaW5QZXJjZW50TmFtZTogXCJQb3VyY2VudGFnZSBkZSBkw6ljb3VwZSBtaW5pbWFsXCIsXG5cdFx0bWF4UGVyY2VudE5hbWU6IFwiUG91cmNlbnRhZ2UgZGUgZMOpY291cGUgbWF4aW1hbFwiLFxuXHRcdG51bWJlck9mU3RhbmRhcmREZXZpYXRpb25OYW1lOiBcIk5vbWJyZSBk4oCZw6ljYXJ0cyB0eXBlc1wiLFxuXHRcdHNpZ21vaWRTdHJlbmd0aExldmVsTmFtZTogXCJOaXZlYXUgZGUgZm9yY2Ugc2lnbW/Dr2RlXCIsXG5cdFx0ZXN0aW1hdGVTdGF0c0hpc3RvZ3JhbU5hbWU6IFwiRXN0aW1lciBsZXMgc3RhdGlzdGlxdWVzXCIsXG5cdFx0RFJBTmFtZTogXCJBanVzdGVtZW50IGR5bmFtaXF1ZSBkZSBsYSBwbGFnZVwiLFxuXHRcdHN0YXRpc3RpY3NOYW1lOiBcIlN0YXRpc3RpcXVlc1wiLFxuXHRcdGhpc3RvZ3JhbXNOYW1lOiBcIkhpc3RvZ3JhbW1lc1wiLFxuXHRcdHN0YXRpc3RpY3NIaXN0b2dyYW1OYW1lOiBcIkTDqWZpbmlyIGRlcyBzdGF0aXN0aXF1ZXMgZXQgdW4gaGlzdG9ncmFtbWVcIixcblx0XHRjb21wdXRlR2FtbWFOYW1lOiBcIlZhbGV1ciBHYW1tYSBhdXRvbWF0aXF1ZVwiLFxuXHRcdHVzZUdhbW1hTmFtZTogXCJVdGlsaXNlciBsYSB2YWxldXIgR2FtbWFcIixcblx0XHRnYW1tYU5hbWU6IFwiR2FtbWFcIixcblx0XHRpbnB1dE5hbWVzTmFtZTogXCJOb21zXCIsXG5cdFx0ZXhwcmVzc2lvbk5hbWU6IFwiRXhwcmVzc2lvblwiLFxuXHRcdGNlbGxzaXplVHlwZU5hbWU6IFwiVHlwZSBkZSB0YWlsbGUgZGUgY2VsbHVsZVwiLFxuXHRcdGV4dGVudFR5cGVOYW1lOiBcIlR5cGUgZOKAmcOpdGVuZHVlXCIsXG5cdFx0Y2xhc3NpZmllckRlZmluaXRpb25GaWxlTmFtZTogXCJGaWNoaWVyIGRlIGTDqWZpbml0aW9uIGVuIGVudHLDqWVcIixcblx0XHRyYXN0ZXIxTmFtZTogXCJSYXN0ZXIxXCIsXG5cdFx0cmFzdGVyMk5hbWU6IFwiUmFzdGVyMlwiLFxuXHRcdHJhc3RlcjNOYW1lOiBcIlJhc3RlcjNcIixcblx0XHR0cnVlUmFzdGVyTmFtZTogXCJSYXN0ZXIgdnJhaVwiLFxuXHRcdGZhbHNlUmFzdGVyTmFtZTogXCJSYXN0ZXIgZmF1eFwiLFxuXHRcdG5vRGF0YUludGVycHJldGF0aW9uTmFtZTogXCJJbnRlcnByw6l0YXRpb24gTm9EYXRhXCIsXG5cdFx0bm9EYXRhVmFsdWVzTmFtZTogXCJWYWxldXJzIE5vRGF0YVwiLFxuXHRcdGluY2x1ZGVkUmFuZ2VzTmFtZTogXCJQbGFnZXMgaW5jbHVzZXNcIixcblx0XHRjdXJ2YXR1cmVUeXBlTmFtZTogXCJUeXBlIGRlIGNvdXJidXJlXCIsXG5cdFx0cmFzdGVyc05hbWU6IFwiUmFzdGVyc1wiLFxuXHRcdGF0dHJpYnV0ZVRhYmxlTmFtZTogXCJUYWJsZWF1XCIsXG5cdFx0YXR0cmlidXRlVGFibGVUeXBlTmFtZTogXCJUeXBlIGRlIHRhYmxlXCIsXG5cdFx0cm93c05hbWU6IFwiTm9tYnJlIGRlIGxpZ25lc1wiLFxuXHRcdGNvbHVtbnNOYW1lOiBcIk5vbWJyZSBkZSBjb2xvbm5lc1wiLFxuXHRcdGtlcm5lbE5hbWU6IFwiTm95YXVcIixcblx0XHRtaXJyb3JFZGdlc05hbWU6IFwiU3ltw6l0cmllIGRlcyB0cm9uw6dvbnNcIixcblx0XHRpbmZsdWVuY2VzTmFtZTogXCJJbmZsdWVuY2VzXCIsXG5cdFx0ZmllbGRzTmFtZTogXCJDaGFtcHNcIixcblx0XHRyZW1hcHNOYW1lOiBcIlRhYmxlIGRlIGNsYXNzaWZpY2F0aW9uXCIsXG5cdFx0ZXZhbEZyb21OYW1lOiBcIkVjaGVsbGUgZCfDqXZhbHVhdGlvbiBkJ29yaWdpbmVcIixcblx0XHRldmFsVG9OYW1lOiBcIkVjaGVsbGUgZCfDqXZhbHVhdGlvbiBkZSBkZXN0aW5hdGlvblwiLFxuXHRcdHdlaWdodHNOYW1lOiBcIlBvbmTDqXJhdGlvbnNcIixcblx0XHRERU1OYW1lOiBcIlVTR1MgREVNXCIsXG5cdFx0c2hvcnRSYW5nZUlEV1JhZGl1c05hbWU6IFwiUmF5b24gSURXIGRlIGNvdXJ0ZSBwb3J0w6llXCIsXG5cdFx0bWF4Vm9pZFdpZHRoTmFtZTogXCJMYXJnZXVyIGRlIHZpZGUgbWF4XCIsXG5cdFx0c2lnbWFHYXVzc2lhbk5hbWU6IFwiTGlzc2FnZSBhZGFwdGF0aWZcIixcblx0XHRjb250b3VyVHlwZU5hbWU6IFwiVHlwZSBk4oCZaXNvbGlnbmVcIixcblx0XHR6QmFzZU5hbWU6IFwiQmFzZSBaXCIsXG5cdFx0bnVtYmVyT2ZDb250b3Vyc05hbWU6IFwiTm9tYnJlIGQnaXNvbGlnbmVzXCIsXG5cdFx0Y29udG91ckludGVydmFsTmFtZTogXCJJbnRlcnZhbGxlIGRlcyBpc29saWduZXNcIixcblx0XHRudGhDb250b3VyTGluZUluQm9sZE5hbWU6IFwiSXNvbGlnbmUgbm9yZCBlbiBncmFzXCIsXG5cdFx0ZmVhdHVyZUNsYXNzTmFtZTogXCJFbnRpdMOpcyBlbiBlbnRyw6llXCIsXG5cdFx0Y2xhc3NJbmRleEZpZWxkTmFtZTogXCJUZXJyYWluXCIsXG5cdFx0cmVzb2x2ZU92ZXJsYXBNZXRob2ROYW1lOiBcIk3DqXRob2RlIFLDqXNvdWRyZSBsYSBzdXBlcnBvc2l0aW9uXCIsXG5cdFx0cmVzYW1wbGluZ1R5cGVOYW1lOiBcIlR5cGUgZGUgcsOpw6ljaGFudGlsbG9ubmFnZVwiLFxuXHRcdGlucHV0Q2VsbHNpemVOYW1lOiBcIlRhaWxsZSBkZSBjZWxsdWxlIGVuIGVudHLDqWVcIixcblx0XHRvdXRwdXRDZWxsc2l6ZU5hbWU6IFwiVGFpbGxlIGRlIGNlbGx1bGUgZW4gc29ydGllXCIsXG5cdFx0cG9pbnRGZWF0dXJlQ2xhc3NOYW1lOiBcIlBvaW50cyBkJ29yaWdpbmVcIixcblx0XHRtYXhHcm93dGhSYWRpdXNGaWVsZE5hbWU6IFwiQ2hhbXAgZGUgcmF5b24gZCfDqXZvbHV0aW9uIG1heGltYWxlXCIsXG5cdFx0c2ltaWxhcml0eVRocmVzaG9sZEZpZWxkTmFtZTogXCJDaGFtcCBkZSBzZXVpbCBkZSBzaW1pbGFyaXTDqVwiLFxuXHRcdGZpbGxWYWx1ZUZpZWxkTmFtZTogXCJDaGFtcCBkZSB2YWxldXJzIGRlIHJlbXBsaXNzYWdlXCIsXG5cdFx0c3BlY3RyYWxEZXRhaWxOYW1lOiBcIkTDqXRhaWwgc3BlY3RyYWwgWzEuLjIwXVwiLFxuXHRcdHNwYXRpYWxEZXRhaWxOYW1lOiBcIkTDqXRhaWwgc3BhdGlhbCBbMS4uMjBdXCIsXG5cdFx0bWluTnVtUGl4ZWxzUGVyU2VnbWVudE5hbWU6IFwiVGFpbGxlIG1pbmltYWxlIGR1IHNlZ21lbnQgZW4gcGl4ZWxzXCIsXG5cdFx0Ym91bmRhcmllc09ubHlOYW1lOiBcIkxpbWl0ZXMgZHUgc2VnbWVudCB1bmlxdWVtZW50XCIsXG5cdFx0c3RhdGlzdGljc1R5cGVOYW1lOiBcIlR5cGUgZGUgc3RhdGlzdGlxdWVcIixcblx0XHRmaWxsTm9EYXRhT25seU5hbWU6IFwiUmVtcGxpciB1bmlxdWVtZW50IGxlcyBwaXhlbHMgTm9EYXRhXCIsXG5cdFx0aW5wdXREYXRhVHlwZU5hbWU6IFwiVHlwZSBkZSBkb25uw6llcyBlbiBlbnRyw6llXCIsXG5cdFx0YW5nbGVSZWZlcmVuY2VTeXN0ZW1OYW1lOiBcIlN5c3TDqG1lIGRlIHLDqWbDqXJlbmNlIGFuZ3VsYWlyZVwiLFxuXHRcdG91dHB1dERhdGFUeXBlTmFtZTogXCJUeXBlIGRlIGRvbm7DqWVzIGVuIHNvcnRpZVwiLFxuXHRcdGlucHV0U2FtcGxlUG9pbnRGZWF0dXJlQ2xhc3NOYW1lOiBcIkV4ZW1wbGVzIGVuIGVudHLDqWVcIixcblx0XHR2YWx1ZUZpZWxkTmFtZTogXCJDaGFtcCBkZSB2YWxldXJcIixcblx0XHRyYXN0ZXJJbmZvTmFtZTogXCJJbmZvcm1hdGlvbnMgcmFzdGVyXCIsXG5cdFx0aW50ZXJwb2xhdGlvbk1ldGhvZE5hbWU6IFwiTcOpdGhvZGUgZOKAmWludGVycG9sYXRpb25cIixcblx0XHRyYWRpdXNOYW1lOiBcIlJheW9uXCIsXG5cdFx0cmFkaWFuY2VHYWluVmFsdWVzTmFtZTogXCJHYWluIGRlIHJheW9ubmVtZW50XCIsXG5cdFx0cmFkaWFuY2VCaWFzVmFsdWVzTmFtZTogXCJUZW5kYW5jZSBkZSByYXlvbm5lbWVudFwiLFxuXHRcdHJlZmxlY3RlZEdhaW5WYWx1ZXNOYW1lOiBcIkdhaW4gZGUgcsOpZmxlY3RhbmNlXCIsXG5cdFx0cmVmbGVjdGVkQmlhc1ZhbHVlc05hbWU6IFwiVGVuZGFuY2UgZGUgcsOpZmxlY3RhbmNlXCIsXG5cdFx0c3VuRWxldmF0aW9uTmFtZTogXCJBbHRpdHVkZSBkdSBzb2xlaWwgKGRlZ3LDqXMpXCIsXG5cdFx0YWxiZWRvTmFtZTogXCJBbGLDqWRvXCIsXG5cdFx0c2NhbGVGYWN0b3JOYW1lOiBcIkZhY3RldXIgZCfDqWNoZWxsZVwiLFxuXHRcdG9mZnNldE5hbWU6IFwiRMOpY2FsYWdlXCIsXG5cdFx0dGhyZXNob2xkVHlwZU5hbWU6IFwiVHlwZSBkZSBzZXVpbFwiLFxuXHRcdHRocmVzaG9sZHNOYW1lOiBcIlNldWlsc1wiLFxuXHRcdHVuZGVmaW5lZENsYXNzTmFtZTogXCJDbGFzc2Ugbm9uIGTDqWZpbmllXCIsXG5cdFx0bWluVmFsdWVOYW1lOiBcIk1pblwiLFxuXHRcdG1heFZhbHVlTmFtZTogXCJNYXhcIixcblx0XHRvcGVyYXRpb25OYW1lOiBcIk9ww6lyYXRpb25cIixcblx0XHRjbGlwcGluZ1R5cGVOYW1lOiBcIlR5cGUgZGUgZMOpY291cGFnZVwiLFxuXHRcdGNsaXBwaW5nR2VvbWV0cnlOYW1lOiBcIkfDqW9tw6l0cmllIGRlIGTDqWNvdXBhZ2UgLyBSYXN0ZXJcIixcblx0XHRleHRlbnROYW1lOiBcIsOJdGVuZHVlIGVuIHNvcnRpZVwiLFxuXHRcdHVzZUlucHV0RmVhdHVyZUdlb21ldHJ5TmFtZTogXCJVdGlsaXNlciBsZXMgZW50aXTDqXMgZW4gZW50csOpZSBwb3VyIGxhIGfDqW9tw6l0cmllIGRlIGTDqWNvdXBhZ2VcIixcblx0XHRyZW1hcERlZmluaXRpb25UeXBlTmFtZTogXCJUeXBlIGRlIGTDqWZpbml0aW9uIGRlIGNsYXNzaWZpY2F0aW9uXCIsXG5cdFx0aW5wdXRSYW5nZU5hbWU6IFwiUGxhZ2VzIGVuIGVudHLDqWVcIixcblx0XHRvdXRwdXRWYWx1ZXNOYW1lOiBcIlZhbGV1cnMgZW4gc29ydGllXCIsXG5cdFx0bm9EYXRhUmFuZ2VOYW1lOiBcIlBsYWdlcyBOb0RhdGFcIixcblx0XHRpbnB1dEZpZWxkTmFtZTogXCJDaGFtcCBlbiBlbnRyw6llXCIsXG5cdFx0b3V0cHV0RmllbGROYW1lOiBcIkNoYW1wIGVuIHNvcnRpZVwiLFxuXHRcdGlucHV0TWF4RmllbGROYW1lOiBcIkNoYW1wIG1heCBlbiBlbnRyw6llIChmYWN1bHRhdGlmKVwiLFxuXHRcdHJlbWFwVGFibGVUeXBlTmFtZTogXCJUeXBlIGRlIHRhYmxlIGRlIGNsYXNzaWZpY2F0aW9uXCIsXG5cdFx0YWxsb3dVbm1hdGNoZWROYW1lOiBcIkF1dG9yaXNlciBsZXMgdmFsZXVycyBkZSBwaXhlbHMgbm9uIGFwcGFyacOpZXNcIixcblx0XHRjaGFuZ2VNaXNzaW5nVmFsdWVzVG9Ob0RhdGFOYW1lOiBcIlJlbXBsYWNlciBsZXMgdmFsZXVycyBtYW5xdWFudGVzIHBhciBOb0RhdGFcIixcblx0XHR2aXNpYmxlQmFuZElETmFtZTogXCJJRCBkZSBjYW5hbCB2aXNpYmxlXCIsXG5cdFx0aW5mcmFyZWRCYW5kSUROYW1lOiBcIklEIGRlIGNhbmFsIGluZnJhcm91Z2VcIixcblx0XHRzY2llbnRpZmljT3V0cHV0TmFtZTogXCJTb3J0aWUgc2NpZW50aWZpcXVlXCIsXG5cdFx0YmFuZEluZGV4ZXNOYW1lOiBcIkluZGV4IGRlIGNhbmF1eFwiLFxuXHRcdGNvbnN0YW50TmFtZTogXCJDb25zdGFudGVcIixcblx0XHR3ZWlnaHROYW1lOiBcIlBvbmTDqXJhdGlvblwiLFxuXHRcdG1pbmltdW1OYW1lOiBcIk1pbmltYWxcIixcblx0XHRtYXhpbXVtTmFtZTogXCJNYXhpbXVtXCIsXG5cdFx0c291cmNlRGF0YU5hbWU6IFwiUmFzdGVyIHNvdXJjZVwiLFxuXHRcdHNvdXJjZUZpZWxkTmFtZTogXCJDaGFtcCBzb3VyY2VcIixcblx0XHRjb3N0UmFzdGVyTmFtZTogXCJSYXN0ZXIgZGUgY2/Du3RcIixcblx0XHRtYXhEaXN0YW5jZU5hbWU6IFwiRWNoZWxsZSBtaW5pbWFsZVwiLFxuXHRcdHZhbHVlUmFzdGVyTmFtZTogXCJSYXN0ZXIgZGUgdmFsZXVyXCIsXG5cdFx0Y29zdE11bHRpcGxpZXJOYW1lOiBcIk11bHRpcGxpY2F0ZXVyIMOgIGFwcGxpcXVlciBhdXggY2/Du3RzXCIsXG5cdFx0c3RhcnRDb3N0TmFtZTogXCJDb8O7dCBkZSBkw6lidXRcIixcblx0XHRhY2N1bUNvc3RSZXNpc3RhbmNlUmF0ZU5hbWU6IFwiVGF1eCBkZSByw6lzaXN0YW5jZSBkdSBjb8O7dCBjdW11bMOpXCIsXG5cdFx0Y2FwYWNpdHlOYW1lOiBcIkNhcGFjaXTDqVwiLFxuXHRcdHRyYXZlbERpcmVjdGlvbk5hbWU6IFwiU2VucyBkZSBkw6lwbGFjZW1lbnRcIixcblx0XHRjZWxsU2l6ZU5hbWU6IFwiVGFpbGxlIGRlIGNlbGx1bGVcIixcblx0XHRwb3B1bGF0aW9uRmllbGROYW1lOiBcIkNoYW1wIGRlIHBvcHVsYXRpb25cIixcblx0XHRhcmVhVW5pdHNOYW1lOiBcIlVuaXTDqXMgZGUgc3VyZmFjZVwiLFxuXHRcdG91dHB1dFZhbHVlVHlwZU5hbWU6IFwiVmFsZXVycyBkZXMgY2VsbHVsZXMgZW4gc29ydGllXCIsXG5cdFx0YmFycmllcnNOYW1lOiBcIkludGVycnVwdGlvbnMgZW4gZW50csOpZVwiLFxuXHRcdGRlc3RpbmF0aW9uRGF0YU5hbWU6IFwiUmFzdGVyIGRlIGRlc3RpbmF0aW9uXCIsXG5cdFx0ZGVzdGluYXRpb25GaWVsZE5hbWU6IFwiQ2hhbXAgZGUgZGVzdGluYXRpb25cIixcblx0XHRwYXRoVHlwZU5hbWU6IFwiVHlwZSBkZSBjaGVtaW5cIixcblx0XHRvYnNlcnZlckZlYXR1cmVzTmFtZTogXCJFbnRpdMOpcyBwb2ludHMgZCdvYnNlcnZhdGlvblwiLFxuXHRcdGFuYWx5c2lzTWV0aG9kTmFtZTogXCJNw6l0aG9kZSBkJ2FuYWx5c2VcIixcblx0XHRhbmFseXNpc1R5cGVOYW1lOiBcIlR5cGUgZCdhbmFseXNlXCIsXG5cdFx0dmVydGljYWxFcnJvck5hbWU6IFwiRXJyZXVyIHZlcnRpY2FsZVwiLFxuXHRcdHJlZnJhY3Rpdml0eUNvZWZmaWNpZW50TmFtZTogXCJDb2VmZmljaWVudCBkZSByw6lmcmFjdGlvblwiLFxuXHRcdHN1cmZhY2VPZmZzZXROYW1lOiBcIkTDqWNhbGFnZSBkZSBsYSBzdXJmYWNlXCIsXG5cdFx0b2JzZXJ2ZXJFbGV2YXRpb25OYW1lOiBcIkFsdGl0dWRlIGR1IHBvaW50IGQnb2JzZXJ2YXRpb25cIixcblx0XHRvYnNlcnZlck9mZnNldE5hbWU6IFwiRMOpY2FsYWdlIGR1IHBvaW50IGQnb2JzZXJ2YXRpb25cIixcblx0XHRpbm5lclJhZGl1c05hbWU6IFwiUmF5b24gaW50w6lyaWV1clwiLFxuXHRcdGlubmVyUmFkaXVzSXMzRERpc3RhbmNlTmFtZTogXCJMZSByYXlvbiBpbnTDqXJpZXVyIGVzdCB1bmUgZGlzdGFuY2UgM0RcIixcblx0XHRvdXRlclJhZGl1c05hbWU6IFwiUmF5b24gZXh0w6lyaWV1clwiLFxuXHRcdG91dGVyUmFkaXVzSXMzRERpc3RhbmNlTmFtZTogXCJMZSByYXlvbiBleHTDqXJpZXVyIGVzdCB1bmUgZGlzdGFuY2UgM0RcIixcblx0XHRob3Jpem9udGFsU3RhcnRBbmdsZU5hbWU6IFwiQW5nbGUgZGUgZMOpcGFydCBob3Jpem9udGFsXCIsXG5cdFx0aG9yaXpvbnRhbEVuZEFuZ2xlTmFtZTogXCJBbmdsZSBkZSBmaW4gaG9yaXpvbnRhbFwiLFxuXHRcdHZlcnRpY2FsVXBwZXJBbmdsZU5hbWU6IFwiQW5nbGUgc3Vww6lyaWV1ciB2ZXJ0aWNhbFwiLFxuXHRcdHZlcnRpY2FsTG93ZXJBbmdsZU5hbWU6IFwiQW5nbGUgaW5mw6lyaWV1ciB2ZXJ0aWNhbFwiLFxuXHRcdHpvbmVEYXRhTmFtZTogXCJSYXN0ZXIgZGUgem9uZXNcIixcblx0XHR6b25lRmllbGROYW1lOiBcIkNoYW1wIGRlIHpvbmVcIixcblx0XHRpZ25vcmVOb0RhdGFOYW1lOiBcIklnbm9yZXIgTm9EYXRhIGRhbnMgbGVzIGNhbGN1bHNcIixcblx0XHR0ZW1wZXJhdHVyZVJhc3Rlck5hbWU6IFwiUmFzdGVyIGRlIHRlbXDDqXJhdHVyZVwiLFxuXHRcdGluVGVtcGVyYXR1cmVVbml0c05hbWU6IFwiVW5pdMOpcyBkZSB0ZW1ww6lyYXR1cmVcIixcblx0XHRvdXRIZWF0SW5kZXhUZW1wZXJhdHVyZVVuaXRzTmFtZTogXCJVbml0w6lzIGQnaW5kaWNlIGRlIGNoYWxldXJcIixcblx0XHRyZWxhdGl2ZUh1bWlkaXR5UmFzdGVyTmFtZTogXCJSYXN0ZXIgZCdodW1pZGl0w6kgcmVsYXRpdmVcIixcblx0XHRvdXRXaW5kQ2hpbGxUZW1wZXJhdHVyZVVuaXRzTmFtZTogXCJVbml0w6lzIGRlIHRlbXDDqXJhdHVyZSByZXNzZW50aWVcIixcblx0XHR3aW5kU3BlZWRSYXN0ZXJOYW1lOiBcIlJhc3RlciBkZSB2aXRlc3NlIGR1IHZlbnRcIixcblx0XHRpbldpbmRTcGVlZFVuaXRzTmFtZTogXCJVbml0w6lzIGRlIHZpdGVzc2UgZHUgdmVudFwiLFxuXHRcdHZhbHVlTmFtZTogXCJWYWxldXJcIixcblx0XHRwcm9wZXJ0eU5hbWU6IFwiTm9tIGRlIGxhIHByb3ByacOpdMOpXCIsXG5cdFx0anNvbk5hbWU6IFwiTGVzIG3DqXRhZG9ubsOpZXMgSlNPTlwiLFxuXHRcdHpvbmVUYWJsZU5hbWU6IFwiVGFibGUgZGVzIGF0dHJpYnV0cyB6b25hdXhcIixcblx0XHRhdHRyaWJ1dGVGaWVsZE5hbWVzOiBcIk5vbXMgZGUgY2hhbXAgZCdhdHRyaWJ1dFwiLFxuXHRcdGJhY2tncm91bmROYW1lOiBcIlZhbGV1ciBk4oCZYXJyacOocmUtcGxhblwiLFxuXHRcdHdoZXJlQ2xhdXNlTmFtZTogXCJDbGF1c2UgV2hlcmVcIixcblx0XHRtaW5pbXVtVmFsdWVGaWVsZE5hbWU6IFwiTm9tIGR1IGNoYW1wIGRlIGxhIHZhbGV1ciBtaW5pbWFsZVwiLFxuXHRcdG1heGltdW1WYWx1ZUZpZWxkTmFtZTogXCJOb20gZHUgY2hhbXAgZGUgbGEgdmFsZXVyIG1heGltYWxlXCIsXG5cdFx0b3V0VmFsdWVGaWVsZE5hbWU6IFwiTm9tIGR1IGNoYW1wIGRlIGxhIHZhbGV1ciBlbiBzb3J0aWVcIixcblx0XHRkZWZhdWx0VmFsdWVOYW1lOiBcIlZhbGV1ciBlbiBzb3J0aWUgcGFyIGTDqWZhdXRcIixcblx0XHRjb252ZXJzaW9uTWF0cml4TmFtZTogXCJNYXRyaWNlIGRlIGNvbnZlcnNpb25cIixcblx0XHRJc1BzZXVkb0NvbG9yT3V0cHV0TmFtZTogXCJFc3QgdW5lIHBzZXVkby1jb3VsZXVyIGVuIHNvcnRpZVwiLFxuXHRcdHVubWFwcGVkQXNSYW5kb21Db2xvck5hbWU6IFwiQ291bGV1ciBhdHRyaWJ1w6llIGRlIG1hbmnDqHJlIGFsw6lhdG9pcmUgYXV4IHBpeGVscyBub24gYXBwYXJpw6lzXCIsXG5cdFx0ZGlzdGFuY2VNZXRob2ROYW1lOiBcIk3DqXRob2RlIGRlIGNhbGN1bCBkZSBkaXN0YW5jZVwiLFxuXHRcdGZsb3dEaXJSYXN0ZXJOYW1lOiBcIlJhc3RlciBkZSBkaXJlY3Rpb24gZGUgZmx1eFwiLFxuXHRcdHBvdXJQb2ludE5hbWU6IFwiUmFzdGVyIGRlIHBvaW50cyBk4oCZw6ljb3VsZW1lbnRcIixcblx0XHRwb3VyUG9pbnRGaWVsZE5hbWU6IFwiQ2hhbXAgZGUgcG9pbnQgZOKAmcOpY291bGVtZW50XCIsXG5cdFx0Y29uc3RhbnRaTmFtZTogXCJDb25zdGFudGUgWlwiLFxuXHRcdHpPZmZzZXROYW1lOiBcIkTDqWNhbGFnZSBaXCIsXG5cdFx0Z2VvSWROYW1lOiBcIkfDqW/Dr2RlXCIsXG5cdFx0Y2FsaWJyYXRpb25UeXBlTmFtZTogXCJUeXBlIGRlIGNhbGlicmFnZVwiLFxuXHRcdGZpbHRlclR5cGVOYW1lOiBcIlR5cGUgZGUgZmlsdHJlXCIsXG5cdFx0ZmlsdGVyU2l6ZU5hbWU6IFwiVGFpbGxlIGRlIGZpbHRyZVwiLFxuXHRcdG5vaXNlTW9kZWxOYW1lOiBcIk1vZMOobGUgZGUgYnJ1aXRcIixcblx0XHRub2lzZVZhcmlhbmNlTmFtZTogXCJWYXJpYW5jZSBkZSBicnVpdFwiLFxuXHRcdGFkZGl0aXZlTm9pc2VNZWFuTmFtZTogXCJNb3llbm5lIGRlIGJydWl0IGFkZGl0aWZcIixcblx0XHRtdWx0aXBsaWNhdGl2ZU5vaXNlTWVhbk5hbWU6IFwiTW95ZW5uZSBkZSBicnVpdCBtdWx0aXBsaWNhdGlmXCIsXG5cdFx0bnVtYmVyb2ZMb29rc05hbWU6IFwiTm9tYnJlIGRlIHZ1ZXNcIixcblx0XHRkYW1waW5nRmFjdG9yTmFtZTogXCJGYWN0ZXVyIGTigJlodW1pZGl0w6lcIixcblx0XHRtYXNrUmFzdGVyTmFtZTogXCJSYXN0ZXIgZGUgbWFzcXVlXCIsXG5cdFx0bmliYmxlVmFsdWVzTmFtZTogXCJVdGlsaXNlciBsZXMgdmFsZXVycyBOb0RhdGEgc+KAmWlsIHPigJlhZ2l0IGR1IHZvaXNpbiBsZSBwbHVzIHByb2NoZVwiLFxuXHRcdG5pYmJsZU5vRGF0YU5hbWU6IFwiR3JpZ25vdGVyIGxlcyBjZWxsdWxlcyBOb0RhdGFcIixcblx0XHR6TGltaXROYW1lOiBcIkxpbWl0ZSBaXCIsXG5cdFx0Zmxvd0RpcmVjdGlvblR5cGVOYW1lOiBcIlR5cGUgZGUgZGlyZWN0aW9uIGRlIGZsdXhcIixcblx0XHR3ZWlnaHRSYXN0ZXJOYW1lOiBcIlJhc3RlciBkZSBwb25kw6lyYXRpb25cIixcblx0XHRmb3JjZUVkZ2VOYW1lOiBcIkZvcmNlciBs4oCZw6ljb3VsZW1lbnQgdmVycyBs4oCZZXh0w6lyaWV1ciBzdXIgbGVzIHF1YXRyZSBib3Jkc1wiLFxuXHRcdHN0cmVhbVJhc3Rlck5hbWU6IFwiUmFzdGVyIGVuIG1vZGUgY29udGludVwiLFxuXHRcdHN1cmZhY2VSYXN0ZXJOYW1lOiBcIlN1cmZhY2UgcmFzdGVyXCIsXG5cdFx0Y29udmVyc2lvblR5cGU6IFwiVHlwZSBkZSBjb252ZXJzaW9uXCIsXG5cdFx0ZGlzdGFuY2VSYXN0ZXIxOiBcIlJhc3RlciBkZSBkaXN0YW5jZSAxXCIsXG5cdFx0ZGlzdGFuY2VSYXN0ZXIyOiBcIlJhc3RlciBkZSBkaXN0YW5jZSAyXCIsXG5cdFx0Y29zdERpc3RhbmNlUmFzdGVyOiBcIlJhc3RlciBkZSBkaXN0YW5jZSBkZSBjb8O7dFwiLFxuXHRcdGNvc3RCYWNrbGlua1Jhc3RlcjogXCJSYXN0ZXIgZOKAmWFudMOpY8OpZGVuY2UgZGUgY2/Du3RcIixcblx0XHRvdmVycmlkZXNOYW1lOiBcIkTDqWJyYXlhZ2VzXCIsXG5cdFx0ZmllbGROYW1lOiBcIlRlcnJhaW5cIixcblx0XHRzaWduYXR1cmVGaWxlT3JVcmw6IFwiRmljaGllciBkZSBzaWduYXR1cmVzIG91IFVSTFwiLFxuXHRcdHJlZE5hbWU6IFwiUm91Z2VcIixcblx0XHRncmVlbk5hbWU6IFwiVmVydFwiLFxuXHRcdGJsdWVOYW1lOiBcIkJsZXVcIixcblx0XHRpbmZyYXJlZE5hbWU6IFwiSW5mcmFyb3VnZVwiLFxuXHRcdHBhbmNocm9tYXRpY05hbWU6IFwiUGFuY2hyb21hdGlxdWVcIixcblx0XHRtdWx0aXNwZWN0cmFsTmFtZTogXCJNdWx0aXNwZWN0cmFsXCIsXG5cdFx0cGFuc2hhcnBlbmluZ1R5cGU6IFwiVHlwZSBk4oCZYWZmaW5hZ2UgcGFuY2hyb21hdGlxdWVcIixcblx0XHRzZW5zb3JOYW1lOiBcIkNhcHRldXJcIixcblx0XHRzcGF0aWFsUmVmZXJlbmNlTmFtZTogXCJSw6lmw6lyZW5jZSBzcGF0aWFsZVwiLFxuXHRcdHhDZWxsc2l6ZU5hbWU6IFwiVGFpbGxlIGRlIGNlbGx1bGUgWFwiLFxuXHRcdHlDZWxsc2l6ZU5hbWU6IFwiVGFpbGxlIGRlIGNlbGx1bGUgWVwiLFxuXHRcdHhPcmlnaW5OYW1lOiBcIlBvaW50IGRlIGNhbGFnZSBYXCIsXG5cdFx0eU9yaWdpbk5hbWU6IFwiUG9pbnQgZGUgY2FsYWdlIFlcIixcblx0XHRwZXJjZW50aWxlTmFtZTogXCJWYWxldXIgZGUgcG91cmNlbnRhZ2VcIixcblx0XHRuZWlnaGJvcmhvb2RUeXBlOiBcIlR5cGUgZGUgdm9pc2luYWdlXCIsXG5cdFx0d2lkdGhOYW1lOiBcIkxhcmdldXJcIixcblx0XHRoZWlnaHROYW1lOiBcIkhhdXRldXJcIixcblx0XHRzdGFydEFuZ2xlTmFtZTogXCJBbmdsZSBkZSBkw6lwYXJ0XCIsXG5cdFx0ZW5kQW5nbGVOYW1lOiBcIkFuZ2xlIGTigJlhcnJpdsOpZVwiLFxuXHRcdG5laWdoYm9yaG9vZFZhbHVlczogXCJWYWxldXJzIHZvaXNpbmVzXCIsXG5cdFx0aG9yaXpvbnRhbFJhc3RlcjogXCJSYXN0ZXIgaG9yaXpvbnRhbFwiLFxuXHRcdGhvcml6b250YWxGYWN0b3I6IFwiRmFjdGV1ciBob3Jpem9udGFsXCIsXG5cdFx0dmVydGljYWxSYXN0ZXI6IFwiUmFzdGVyIHZlcnRpY2FsXCIsXG5cdFx0dmVydGljYWxGYWN0b3I6IFwiRmFjdGV1ciB2ZXJ0aWNhbFwiLFxuXHRcdHN0cmVhbVJhc3RlcjogXCJSYXN0ZXIgZW4gbW9kZSBjb250aW51XCIsXG5cdFx0Zmxvd0RpclJhc3RlcjogXCJSYXN0ZXIgZGUgZGlyZWN0aW9uIGRlIGZsdXhcIixcblx0XHRudW1iZXJOZWlnaGJvckNlbGxzOiBcIk5vbWJyZSBkZSBjZWxsdWxlcyB2b2lzaW5lc1wiLFxuXHRcdHpvbmVDb25uZWN0aXZpdHk6IFwiQ29ubmVjdGl2aXTDqSBkZSB6b25lXCIsXG5cdFx0YWRkTGlua0JlaGF2aW9yOiBcIkFqb3V0ZXIgdW4gbGllblwiLFxuXHRcdGV4Y2x1ZGVkVmFsdWU6IFwiVmFsZXVyIGV4Y2x1ZVwiLFxuXHRcdGNvbnN0YW50RmlsbENoZWNrOiBcIkfDqW7DqXJlciB1biByYXN0ZXIgZGUgcmVtcGxpc3NhZ2Ugw6AgcGFydGlyIGTigJl1bmUgY29uc3RhbnRlXCIsXG5cdFx0ZmlsbFJhc3RlcjogXCJSYXN0ZXIgZGUgcmVtcGxpc3NhZ2VcIixcblx0XHRjb25zdGFudEZpbGxWYWx1ZTogXCJWYWxldXIgY29uc3RhbnRlXCIsXG5cdFx0aW5wdXRCaXRQb3NpdGlvbnM6IFwiQml0IGVuIGVudHLDqWVcIixcblx0XHRvdXRwdXRCaXRQb3NpdGlvbnM6IFwiQml0IGVuIHNvcnRpZVwiLFxuXHRcdGRpc3RhbmNlVHlwZU5hbWU6IFwiVHlwZSBkZSBkaXN0YW5jZVwiLFxuXHRcdGJhcnJpZXJEYXRhTmFtZTogXCJJbnRlcnJ1cHRpb25zIGR1IHJhc3RlclwiLFxuXHRcdHBvdXJQb2ludERhdGFOYW1lOiBcIlJhc3RlciBkZSBjYXB0dXJlIGRlcyBwb2ludHMgZCfDqWNvdWxlbWVudFwiLFxuXHRcdGFjY3VtdWxhdGlvblJhc3Rlck5hbWU6IFwiUmFzdGVyIGTigJlhY2N1bXVsYXRpb24gZGUgZmx1eFwiLFxuXHRcdHNuYXBEaXN0YW5jZU5hbWU6IFwiRGlzdGFuY2UgZGUgY2FwdHVyZVwiLFxuXHRcdG9yZGVyTWV0aG9kTmFtZTogXCJNw6l0aG9kZSBkZSB0cmlcIixcblx0XHRkaXJlY3Rpb25NZWFzdXJlbWVudE5hbWU6IFwiRGlyZWN0aW9uIGRlIG1lc3VyZVwiLFxuXHRcdHByb2Nlc3NBc011bHRpYmFuZDogXCJUcmFpdGVyIGNvbW1lIG11bHRpYmFuZGVcIixcblx0XHRwcm9jZXNzTXVsdGlkaW1lbnNpb25hbDogXCJUcmFpdGVyIGNvbW1lIG11bHRpZGltZW5zaW9ubmVsXCIsXG5cdFx0Zm9yY2VGbG93RGlyZWN0aW9uQ29udmVudGlvbjogXCJGb3JjZXIgbGEgY29udmVudGlvbiBkZSBzZW5zIGRlIGNpcmN1bGF0aW9uIHBvdXIgbGUgcmFzdGVyIGTigJlhbnTDqWPDqWRlbmNlXCIsXG5cdFx0aW5pdGlhbEFjY3VtdWxhdGlvbjogXCJBY2N1bXVsYXRpb24gaW5pdGlhbGVcIixcblx0XHRtYXhpbXVtQWNjdW11bGF0aW9uOiBcIkFjY3VtdWxhdGlvbiBtYXhpbWFsZVwiLFxuXHRcdHNvdXJjZUxvY2F0aW9uQmFuZHM6IFwiR8OpbsOpcmVyIGxhIGxpZ25lIGV0IGxhIGNvbG9ubmUgc291cmNlcyBlbiB0YW50IHF1ZSBiYW5kZXMgc3VwcGzDqW1lbnRhaXJlcyBkYW5zIGxhIHNvcnRpZVwiLFxuXHRcdGJhY2tEaXJlY3Rpb25CYW5kOiBcIkfDqW7DqXJlciBsYSBkaXJlY3Rpb24gYXJyacOocmUgZW4gdGFudCBxdWUgYmFuZGUgc3VwcGzDqW1lbnRhaXJlIGRhbnMgbGEgc29ydGllXCIsXG5cdFx0bnVtYmVyT2ZDZWxsczogXCJOb21icmUgZGUgY2VsbHVsZXNcIixcblx0XHR6b25lVmFsdWVzOiBcIlZhbGV1cnMgZGUgem9uZVwiLFxuXHRcdHNocmlua01ldGhvZDogXCJNw6l0aG9kZSBkZSByw6lkdWN0aW9uXCIsXG5cdFx0ZXhwYW5kTWV0aG9kOiBcIk3DqXRob2RlIGRlIGTDqXZlbG9wcGVtZW50XCIsXG5cdFx0aW5wdXRTcGVjdHJhbFByb2ZpbGVUeXBlOiBcIlR5cGUgZGUgcHJvZmlsIHNwZWN0cmFsXCIsXG5cdFx0c3BlY3RyYWxQcm9maWxlRmlsZU5hbWU6IFwiUHJvZmlsIHNwZWN0cmFsXCIsXG5cdFx0dHJhaW5pbmdGZWF0dXJlRmlsZU5hbWU6IFwiRW50aXTDqSBk4oCZZW50cmHDrm5lbWVudFwiLFxuXHRcdG5vbk5lZ2F0aXZlOiBcIk5vbiBuw6lnYXRpZlwiLFxuXHRcdHN1bVRvT25lOiBcIlNvbW1lIMOpZ2FsZSDDoCB1blwiLFxuXHRcdHJhbmRvbURpc3RyaWJ1dGlvbjogXCJEaXN0cmlidXRpb25cIixcblx0XHRtZWFuTmFtZTogXCJNb3llbm5lXCIsXG5cdFx0cHJvYmFiaWxpdHlOYW1lOiBcIlByb2JhYmlsaXTDqVwiLFxuXHRcdGFscGhhTmFtZTogXCJBbHBoYVwiLFxuXHRcdGJldGFOYW1lOiBcIkLDqnRhXCIsXG5cdFx0ck5hbWU6IFwiclwiLFxuXHRcdG5OYW1lOiBcIk5cIixcblx0XHRzZWVkOiBcIlZhbGV1ciBpbml0LlwiLFxuXHRcdHJhbmRvbU51bWJlckdlbmVyYXRvcjogXCJHw6luw6lyYXRldXIgZGUgbm9tYnJlcyBhbMOpYXRvaXJlc1wiLFxuXHRcdGNlbGxGYWN0b3I6IFwiRmFjdGV1ciBkZSBjZWxsdWxlXCIsXG5cdFx0YWdncmVnYXRpb25UeXBlOiBcIk3DqXRob2RlIGTigJlhZ3LDqWdhdGlvblwiLFxuXHRcdGV4dGVudEhhbmRsaW5nOiBcIkF1Z21lbnRlciBs4oCZw6l0ZW5kdWUgc2kgbsOpY2Vzc2FpcmVcIixcblx0XHR0cmVuZEFuYWx5c2lzRGltZW5zaW9uTmFtZTogXCJOb20gZGUgbGEgZGltZW5zaW9uXCIsXG5cdFx0dHJlbmRBbmFseXNpc1R5cGU6IFwiVHlwZSBkZSB0ZW5kYW5jZVwiLFxuXHRcdGhhcm1vbmljRnJlcXVlbmN5OiBcIkZyw6lxdWVuY2UgaGFybW9uaXF1ZVwiLFxuXHRcdHBvbHlub21pYWxPcmRlcjogXCJPcmRyZSBwb2x5bm9taWFsXCIsXG5cdFx0Y3ljbGVMZW5ndGhOYW1lOiBcIkR1csOpZSBkdSBjeWNsZVwiLFxuXHRcdHRyZW5kQW5hbHlzaXNSTVNFOiBcIkVRTVwiLFxuXHRcdHRyZW5kQW5hbHlzaXNSMjogXCJSLWNhcnLDqVwiLFxuXHRcdHRyZW5kQW5hbHlzaXNTbG9wZVBWYWx1ZTogXCJWYWxldXIgUCBkdSBjb2VmZmljaWVudCBkZSBwZW50ZVwiLFxuXHRcdHRyZW5kQW5hbHlzaXNTZWFzb25hbFBlcmlvZDogXCJQw6lyaW9kZSBzYWlzb25uacOocmVcIixcblx0XHRjeWNsZVVuaXROYW1lOiBcIlVuaXTDqSBkZSBjeWNsZVwiLFxuXHRcdHByZWRpY3REaW1lbnNpb25WYWx1ZXM6IFwiVmFsZXVyc1wiLFxuXHRcdGRpbWVuc2lvbkRlZmluaXRpb25UeXBlOiBcIkTDqWZpbml0aW9uIGRlIGxhIGRpbWVuc2lvblwiLFxuXHRcdHByZWRpY3REaW1lbnNpb25TdGFydDogXCJEw6lidXRcIixcblx0XHRwcmVkaWN0RGltZW5zaW9uRW5kOiBcIkZpblwiLFxuXHRcdHByZWRpY3REaW1lbnNpb25JbnRlcnZhbDogXCJWYWxldXIgZGUgbOKAmWludGVydmFsbGVcIixcblx0XHRkaW1lbnNpb25Vbml0OiBcIlVuaXTDqVwiLFxuXHRcdGludGVycG9sYXRpb25DZWxsc2l6ZU5hbWU6IFwiVGFpbGxlIGRlIGNlbGx1bGUgZOKAmWludGVycG9sYXRpb25cIixcblx0XHR2YXJpYWJsZU5hbWU6IFwiVmFyaWFibGVzXCIsXG5cdFx0ZGltZW5zaW9ubGVzc05hbWU6IFwiU2FucyBkaW1lbnNpb25cIixcblx0XHRtZGltRGVmaW5pdGlvbjogXCJEaW1lbnNpb24gRGVmaW5pdGlvbiAoRMOpZmluaXRpb24gZGUgbGEgZGltZW5zaW9uKVwiLFxuXHRcdGRpbWVuc2lvbk5hbWU6IFwiQ290YXRpb25cIixcblx0XHRpdGVyYXRpb25TdGFydDogXCJTdGFydCBvZiBmaXJzdCBpdGVyYXRpb24gKETDqWJ1dCBkZSBsYSBwcmVtacOocmUgaXTDqXJhdGlvbilcIixcblx0XHRpdGVyYXRpb25FbmQ6IFwiRW5kIG9mIGZpcnN0IGl0ZXJhdGlvbiAoRmluIGRlIGxhIHByZW1pw6hyZSBpdMOpcmF0aW9uKVwiLFxuXHRcdGludGVydmFsU3RhcnQ6IFwiRMOpYnV0IGRlIGzigJlpbnRlcnZhbGxlXCIsXG5cdFx0aW50ZXJ2YWxFbmQ6IFwiRmluIGRlIGzigJlpbnRlcnZhbGxlXCIsXG5cdFx0c3RlcE5hbWU6IFwiUGFzXCIsXG5cdFx0cmFuZ2VzTmFtZTogXCJQbGFnZXNcIixcblx0XHRtaW5WYWx1ZTogXCJWYWxldXIgbWluaW1hbGVcIixcblx0XHRtYXhWYWx1ZTogXCJWYWxldXIgbWF4aW1hbGVcIixcblx0XHRjaGFuZ2VBbmFseXNpc1Jhc3Rlck5hbWU6IFwiUmFzdGVyIGTigJlhbmFseXNlIGRlcyBjaGFuZ2VtZW50c1wiLFxuXHRcdGNoYW5nZVR5cGVOYW1lOiBcIk1vZGlmaWVyIGxlIHR5cGVcIixcblx0XHRzZWdtZW50RGF0ZTogXCJEYXRlIGR1IHNlZ21lbnRcIixcblx0XHRjaGFuZ2VEaXJlY3Rpb25OYW1lOiBcIlNlbnMgZHUgY2hhbmdlbWVudFwiLFxuXHRcdG1heE51bUNoYW5nZXNOYW1lOiBcIk5vbWJyZSBtYXhpbWFsIGRlIGNoYW5nZW1lbnRzXCIsXG5cdFx0ZmlsdGVyQnlZZWFyOiBcIkZpbHRyZXIgcGFyIGFubsOpZVwiLFxuXHRcdG1pbmltdW1ZZWFyOiBcIlZhbGV1ciBtaW5pbWFsZVwiLFxuXHRcdG1heGltdW1ZZWFyOiBcIlZhbGV1ciBtYXhpbWFsZVwiLFxuXHRcdGZpbHRlckJ5RHVyYXRpb246IFwiRmlsdHJlciBwYXIgZHVyw6llXCIsXG5cdFx0bWluaW11bUR1cmF0aW9uOiBcIkR1csOpZSBtaW5pbWFsZVwiLFxuXHRcdG1heGltdW1EdXJhdGlvbjogXCJEdXLDqWUgbWF4aW1hbGVcIixcblx0XHRmaWx0ZXJCeU1hZ25pdHVkZTogXCJGaWx0cmVyIHBhciBtYWduaXR1ZGVcIixcblx0XHRtaW5pbXVtTWFnbml0dWRlOiBcIk1hZ25pdHVkZSBtaW5pbWFsZVwiLFxuXHRcdG1heGltdW1NYWduaXR1ZGU6IFwiTWFnbml0dWRlIG1heGltYWxlXCIsXG5cdFx0ZmlsdGVyQnlTdGFydFZhbHVlOiBcIkZpbHRyZXIgcGFyIHZhbGV1ciBkZSBkw6lwYXJ0XCIsXG5cdFx0bWluaW11bVN0YXJ0VmFsdWU6IFwiVmFsZXVyIGRlIGTDqXBhcnQgbWluaW1hbGVcIixcblx0XHRtYXhpbXVtU3RhcnRWYWx1ZTogXCJWYWxldXIgZGUgZMOpcGFydCBtYXhpbWFsZVwiLFxuXHRcdGZpbHRlckJ5RW5kVmFsdWU6IFwiRmlsdHJlciBwYXIgdmFsZXVyIGRlIGZpblwiLFxuXHRcdG1pbmltdW1FbmRWYWx1ZTogXCJWYWxldXIgZGUgZmluIG1pbmltYWxlXCIsXG5cdFx0bWF4aW11bUVuZFZhbHVlOiBcIlZhbGV1ciBkZSBmaW4gbWF4aW1hbGVcIixcblx0XHRtb2RlbFR5cGVOYW1lOiBcIlR5cGUgZGUgbW9kw6hsZVwiLFxuXHRcdGZyb21SYXN0ZXJOYW1lOiBcIlJhc3RlciBk4oCZb3JpZ2luZVwiLFxuXHRcdHRvUmFzdGVyTmFtZTogXCJSYXN0ZXIgZGUgZGVzdGluYXRpb25cIixcblx0XHRjb21wdXRlQ2hhbmdlTWV0aG9kOiBcIk3DqXRob2RlIENhbGN1bGVyIGxlcyBtb2RpZmljYXRpb25zXCIsXG5cdFx0ZnJvbUNsYXNzVmFsdWVzOiBcIlZhbGV1cnMgZGUgY2xhc3NlIGTigJlvcmlnaW5lIChleGVtcGxlwqA6IDIgNSlcIixcblx0XHR0b0NsYXNzVmFsdWVzOiBcIlZhbGV1cnMgZGUgY2xhc3NlIGRlIGRlc3RpbmF0aW9uIChleGVtcGxlwqA6IDIgNSlcIixcblx0XHRrZWVwTWV0aG9kOiBcIk3DqXRob2RlIGRlIGZpbHRyYWdlXCIsXG5cdFx0dXNlQ29sb3JNZXRob2Q6IFwiRMOpZmluaXIgbGVzIGNvdWxldXJzIGRlIHRyYW5zaXRpb25cIixcblx0XHRkZXRlY3RDaGFuZ2VCYW5kczogXCJCYW5kZXMgcG91ciBsYSBkw6l0ZWN0aW9uIGRlcyBjaGFuZ2VtZW50cyAoY29tbWVuY2VudCDDoMKgMClcIixcblx0XHR0bWFza0JhbmRzOiBcIkJhbmRlcyBwb3VyIGxlIG1hc3F1YWdlIHRlbXBvcmVsIChjb21tZW5jZW50IMOgwqAwKVwiLFxuXHRcdGNoaVNxdWFyZWRUaHJlc2hvbGQ6IFwiU2V1aWwgZHUga2hpIGRldXggcG91ciBsYSBkw6l0ZWN0aW9uIGRlcyBjaGFuZ2VtZW50c1wiLFxuXHRcdG1pbkFub21hbHk6IFwiT2JzZXJ2YXRpb25zIGRlcyBhbm9tYWxpZXMgY29uc8OpY3V0aXZlcyBtaW5pbWFsZXNcIixcblx0XHR1cGRhdGluZ0ZyZXF1ZW5jeTogXCJNaXNlIMOgIGpvdXIgZGUgbGEgZnLDqXF1ZW5jZSBkZSBwZXJ0aW5lbmNlIChlbiBhbm7DqWVzKVwiLFxuXHRcdGRpc3RhbmNlQWNjdW11bGF0aW9uUmFzdGVyTmFtZTogXCJSYXN0ZXIgZOKAmWFjY3VtdWxhdGlvbiBkZSBkaXN0YW5jZVwiLFxuXHRcdGNvc3RCYWNrZGlyZWN0aW9uUmFzdGVyTmFtZTogXCJSYXN0ZXIgZGUgZGlyZWN0aW9uIGFycmnDqHJlIG91IGRlIGRpcmVjdGlvbiBkZSBmbHV4XCIsXG5cdFx0cmFzdGVyQ29sbGVjdGlvbk5hbWU6IFwiRW5zZW1ibGUgZGUgcmFzdGVyc1wiLFxuXHRcdGl0ZW1GdW5jdGlvbk5hbWU6IFwiRm9uY3Rpb24gZGUgbOKAmcOpbMOpbWVudFwiLFxuXHRcdGFnZ3JlZ2F0aW9uRnVuY3Rpb25OYW1lOiBcIkZvbmN0aW9uIGTigJlhZ3LDqWdhdGlvblwiLFxuXHRcdHByb2Nlc3NpbmdGdW5jdGlvbk5hbWU6IFwiRm9uY3Rpb24gZGUgdHJhaXRlbWVudFwiLFxuXHRcdGFnZ3JlZ2F0aW9uRGVmaW5pdGlvbk5hbWU6IFwiRMOpZmluaXRpb24gZGUgbOKAmWFncsOpZ2F0aW9uXCIsXG5cdFx0cXVlcnlHZW9tZXRyeU5hbWU6IFwiUmVxdcOqdGUgR8Opb23DqXRyaWVcIixcblx0XHRmYWN0b3JGdW5jdGlvblplcm9GYWN0b3I6IFwiRmFjdGV1ciB6w6lyb1wiLFxuXHRcdGZhY3RvckZ1bmN0aW9uQ3V0QW5nbGU6IFwiQW5nbGUgZOKAmWluZmxleGlvblwiLFxuXHRcdGZhY3RvckZ1bmN0aW9uU2lkZUZhY3RvcjogXCJGYWN0ZXVyIGxhdMOpcmFsXCIsXG5cdFx0ZmFjdG9yRnVuY3Rpb25TbG9wZTogXCJQZW50ZVwiLFxuXHRcdGZhY3RvckZ1bmN0aW9uTG93Q3V0QW5nbGU6IFwiQW5nbGUgZOKAmWluZmxleGlvbiBpbmbDqXJpZXVyXCIsXG5cdFx0ZmFjdG9yRnVuY3Rpb25IaWdoQ3V0QW5nbGU6IFwiQW5nbGUgZOKAmWluZmxleGlvbiBzdXDDqXJpZXVyXCIsXG5cdFx0ZmFjdG9yRnVuY3Rpb25Db3NQb3dlcjogXCJQdWlzc2FuY2UgZGUgY29zaW51c1wiLFxuXHRcdGZhY3RvckZ1bmN0aW9uU2VjUG93ZXI6IFwiUHVpc3NhbmNlIGRlIHPDqWNhbnRlXCIsXG5cdFx0ZmFjdG9yRnVuY3Rpb25UYWJsZVBhdGg6IFwiQ2hlbWluIGTigJlhY2PDqHMgw6AgbGEgdGFibGVcIixcblx0XHRwcm9jZXNzaW5nQmFuZDogXCJCYW5kZSBkZSB0cmFpdGVtZW50XCIsXG5cdFx0cHJvY2Vzc2luZ0JhbmROYW1lOiBcIk5vbSBkZSBsYSBiYW5kZSBkZSB0cmFpdGVtZW50XCIsXG5cdFx0c25hcHBpbmdEYXRlOiBcIkRhdGUgZGUgY2FwdHVyZVwiLFxuXHRcdG1heE51bVNlZ21lbnRzOiBcIk5vbWJyZSBtYXhpbWFsIGRlIHNlZ21lbnRzXCIsXG5cdFx0dmVydGV4Q291bnRPdmVyc2hvb3Q6IFwiRMOpcGFzc2VtZW50IGR1IG5vbWJyZSBkZSBzb21tZXRzXCIsXG5cdFx0c3Bpa2VUaHJlc2hvbGQ6IFwiU2V1aWwgZGUgcGljXCIsXG5cdFx0cmVjb3ZlcnlUaHJlc2hvbGQ6IFwiU2V1aWwgZGUgcsOpY3Vww6lyYXRpb25cIixcblx0XHRtaW5OdW1PYnM6IFwiTm9tYnJlIG1pbmltYWwgZOKAmW9ic2VydmF0aW9uc1wiLFxuXHRcdHBWYWx1ZVRocmVzaG9sZDogXCJTZXVpbCBkZSBsYSB2YWxldXLCoFBcIixcblx0XHRiZXN0TW9kZWxQcm9wb3J0aW9uOiBcIlByb3BvcnRpb24gZGUgbW9kw6hsZSBpZMOpYWxlXCIsXG5cdFx0cHJldmVudE9uZVllYXJSZWNvdmVyeTogXCJFbXDDqmNoZXIgbGEgcsOpY3Vww6lyYXRpb24gc3VyIHVuIGFuXCIsXG5cdFx0cmVjb3ZlcnlJbmNyZWFzZVRyZW5kOiBcIkxhIHRlbmRhbmNlIGRlIHLDqWN1cMOpcmF0aW9uIGF1Z21lbnRlXCIsXG5cdFx0b3V0cHV0T3RoZXJCYW5kczogXCJHw6luw6lyZXIgZOKAmWF1dHJlcyBiYW5kZXMgZW4gc29ydGllXCIsXG5cdFx0c29ydFR5cGU6IFwiVHlwZSBkZSB0cmlcIixcblx0XHRudW1iZXJPZlJ1bnM6IFwiRXjDqWN1dGVyIGRldXggZm9pcyBsJ2V4cGFuc2lvbiBldCBsYSBjb250cmFjdGlvblwiLFxuXHRcdHBlcmNlbnRpbGVWYWx1ZTogXCJWYWxldXIgZHUgY2VudGlsZVwiLFxuXHRcdHBlcmNlbnRpbGVJbnRlcnBvbGF0aW9uVHlwZTogXCJQZXJjZW50aWxlIGludGVycG9sYXRpb24gdHlwZSAoVHlwZSBk4oCZaW50ZXJwb2xhdGlvbiBlbiBjZW50aWxlKVwiLFxuXHRcdHJhc3RlckluZm9Qcm9wZXJ0eTogXCJQcm9wcmnDqXTDqVwiLFxuXHRcdHJhc3RlckluZm9WYWx1ZTogXCJWYWxldXJcIixcblx0XHRyYXN0ZXJJbmZvQ29sdW1uczogXCJDb2xvbm5lc1wiLFxuXHRcdHJhc3RlckluZm9Sb3dzOiBcIkxpZ25lc1wiLFxuXHRcdHJhc3RlckluZm9CYW5kQ291bnQ6IFwiTm9tYnJlIGRlIGJhbmRlc1wiLFxuXHRcdHJhc3RlckluZm9QaXhlbFNpemVYOiBcIlRhaWxsZSBkZSBjZWxsdWxlwqBYXCIsXG5cdFx0cmFzdGVySW5mb1BpeGVsU2l6ZVk6IFwiVGFpbGxlIGRlIGNlbGx1bGXCoFlcIixcblx0XHRyYXN0ZXJJbmZvUGl4ZWxUeXBlOiBcIlR5cGUgZGUgcGl4ZWxcIixcblx0XHRyYXN0ZXJFeHRlbnRUb3A6IFwiSGF1dFwiLFxuXHRcdHJhc3RlckV4dGVudEJvdHRvbTogXCJCYXNcIixcblx0XHRyYXN0ZXJFeHRlbnRMZWZ0OiBcIkdhdWNoZVwiLFxuXHRcdHJhc3RlckV4dGVudFJpZ2h0OiBcIkRyb2l0ZVwiLFxuXHRcdHJhc3RlclN0YXRpc3RpY3NOb3RDYWxjdWxhdGVkOiBcIkxlcyBzdGF0aXN0aXF1ZXMgbuKAmW9udCBwYXMgw6l0w6kgY2FsY3Vsw6llcy5cIixcblx0XHRzcGF0aWFsUmVmZXJlbmNlUHJvamVjdGlvbjogXCJQcm9qZWN0aW9uXCIsXG5cdFx0c3BhdGlhbFJlZmVyZW5jZVdraWQ6IFwiV0tJRFwiLFxuXHRcdHNwYXRpYWxSZWZlcmVuY2VMYXRlc3RXa2lkOiBcIldLSUQgcHLDqWPDqWRlbnRcIixcblx0XHRzcGF0aWFsUmVmZXJlbmNlV2t0OiBcIldLVFwiLFxuXHRcdHNwYXRpYWxSZWZlcmVuY2VWY3NXa2lkOiBcIlZDU1dLSURcIixcblx0XHRzcGF0aWFsUmVmZXJlbmNlTGF0ZXN0VmNzV2tpZDogXCJWQ1NXS0lEIHByw6ljw6lkZW50XCIsXG5cdFx0c3BhdGlhbFJlZmVyZW5jZUF1dGhvcml0eTogXCJBdXRvcml0w6lcIixcblx0XHRzcGF0aWFsUmVmZXJlbmNlTGluZWFyVW5pdDogXCJVbml0w6kgbGluw6lhaXJlXCIsXG5cdFx0c3BhdGlhbFJlZmVyZW5jZUFuZ3VsYXJVbml0OiBcIlVuaXTDqSBhbmd1bGFpcmVcIixcblx0XHRzcGF0aWFsUmVmZXJlbmNlRmFsc2VFYXN0aW5nOiBcIkFic2Npc3NlIGZpY3RpdmVcIixcblx0XHRzcGF0aWFsUmVmZXJlbmNlRmFsc2VOb3J0aGluZzogXCJPcmRvbm7DqWUgZmljdGl2ZVwiLFxuXHRcdHNwYXRpYWxSZWZlcmVuY2VDZW50cmFsTWVyaWRpYW46IFwiTcOpcmlkaWVuIGNlbnRyYWxcIixcblx0XHRzcGF0aWFsUmVmZXJlbmNlUHJpbWVNZXJpZGlhbjogXCJNw6lyaWRpZW4gcHJpbmNpcGFsXCIsXG5cdFx0c3BhdGlhbFJlZmVyZW5jZVN0YW5kYXJkUGFyYWxsZWwxOiBcIlBhcmFsbMOobGUgZGUgcsOpZsOpcmVuY2XCoDFcIixcblx0XHRzcGF0aWFsUmVmZXJlbmNlU3RhbmRhcmRQYXJhbGxlbDI6IFwiUGFyYWxsw6hsZSBkZSByw6lmw6lyZW5jZcKgMlwiLFxuXHRcdHNwYXRpYWxSZWZlcmVuY2VMYXRpdHVkZU9mT3JpZ2luOiBcIkxhdGl0dWRlIGRlIGzigJlvcmlnaW5lXCIsXG5cdFx0c3BhdGlhbFJlZmVyZW5jZUF1eGlsaWFyeVNwaGVyZVR5cGU6IFwiVHlwZSBkZSBzcGjDqHJlIGF1eGlsaWFpcmVcIixcblx0XHRzcGF0aWFsUmVmZXJlbmNlRGF0dW06IFwiRGF0dW1cIixcblx0XHRzcGF0aWFsUmVmZXJlbmNlU3BoZXJvaWQ6IFwiU3Bow6lyb8OvZGVcIixcblx0XHRzcGF0aWFsUmVmZXJlbmNlU2VtaW1ham9yQXhpczogXCJEZW1pLWdyYW5kIGF4ZVwiLFxuXHRcdHNwYXRpYWxSZWZlcmVuY2VTZW1pbWlub3JBeGlzOiBcIkRlbWktcGV0aXQgYXhlXCIsXG5cdFx0c3BhdGlhbFJlZmVyZW5jZUludmVyc2VGbGF0dGVuaW5nOiBcIkFwbGF0aXNzZW1lbnQgaW52ZXJzZVwiLFxuXHRcdGlucHV0RGVmaW5pdGlvbkZpbGVOYW1lOiBcIkZpY2hpZXIgZGUgZMOpZmluaXRpb24gZW4gZW50csOpZVwiLFxuXHRcdGRlbGV0ZU5hbWU6IFwiU3VwcHJpbWVyXCIsXG5cdFx0YWRkVmFyaWFibGVOYW1lOiBcIkFqb3V0ZXIgdW5lIHZhcmlhYmxlXCIsXG5cdFx0bWF4TnVtUGl4ZWxzUGVyU2VnbWVudDogXCJUYWlsbGUgbWF4aW1hbGUgZHUgc2VnbWVudCBlbiBwaXhlbHNcIixcblx0XHRmb3J3YXJkV2luZG93TmFtZTogXCJGZW7DqnRyZSBhdmFudFwiLFxuXHRcdGJhY2t3YXJkV2luZG93TmFtZTogXCJGZW7DqnRyZSBhcnJpw6hyZVwiLFxuXHRcdG5vRGF0YUhhbmRsaW5nTmFtZTogXCJHZXN0aW9uIGRlcyB2YWxldXJzIE5vRGF0YVwiLFxuXHRcdGNpcmN1bGFyV3JhcFZhbHVlTmFtZTogXCJWYWxldXIgZGUgcmVwbGkgY2lyY3VsYWlyZVwiLFxuXHRcdGZyb21DbGFzc05hbWVGaWVsZE5hbWU6IFwiTm9tIGRlIGNoYW1wIHBvdXIgbGVzIG5vbXMgZGUgY2xhc3NlIGRhbnMgbGUgcmFzdGVyIGTigJlvcmlnaW5lXCIsXG5cdFx0dG9DbGFzc05hbWVGaWVsZE5hbWU6IFwiTm9tIGRlIGNoYW1wIHBvdXIgbGVzIG5vbXMgZGUgY2xhc3NlIGRhbnMgbGUgcmFzdGVyIGRlIGRlc3RpbmF0aW9uXCIsXG5cdFx0dGFyZ2V0UmFzdGVyTmFtZTogXCJSYXN0ZXIgY2libGVcIixcblx0XHRjaXJjdWxhcldyYXBWYWx1ZTogXCJWYWxldXIgZGUgcmVwbGkgY2lyY3VsYWlyZVwiLFxuXHRcdGJhbmRJbmRleGVzUjogXCJFeHByZXNzaW9uIHJvdWdlXCIsXG5cdFx0YmFuZEluZGV4ZXNHOiBcIkV4cHJlc3Npb24gdmVydGVcIixcblx0XHRiYW5kSW5kZXhlc0I6IFwiRXhwcmVzc2lvbiBibGV1ZVwiLFxuXHRcdGV4YW1wbGVOYW1lOiBcIkV4ZW1wbGVcIixcblx0XHRpbnB1dE5hbWU6IFwiRW50csOpZVwiLFxuXHRcdG91dHB1dE5hbWU6IFwiU29ydGllXCIsXG5cdFx0b3B0aW9uYWxOYW1lOiBcIkZhY3VsdGF0aWZcIixcblx0XHRicm93c2VEZWZpbml0aW9uRmlsZTogXCJSZWNoZXJjaGVyIGxlIGZpY2hpZXIgZGUgZMOpZmluaXRpb25cIixcblx0XHRzZWxlY3REZWZpbml0aW9uRmlsZTogXCJTw6lsZWN0aW9ubmVyIGxlIGZpY2hpZXIgZGUgZMOpZmluaXRpb24gZW4gZW50csOpZVwiLFxuXHRcdGlucHV0RGVmaW5pdGlvblVSTDogXCJVUkwgZHUgZmljaGllciBkZSBkw6lmaW5pdGlvbiBlbiBlbnRyw6llXCIsXG5cdFx0ZW50ZXJEZWZpbml0aW9uRmlsZVVSTDogXCJTYWlzaXIgbOKAmVVSTCBkdSBmaWNoaWVyIGRlIGTDqWZpbml0aW9uXCIsXG5cdFx0YnJvd3NlWE1MRmlsZTogXCJSZWNoZXJjaGVyIGxlIGZpY2hpZXLCoFhNTFwiLFxuXHRcdHNlbGVjdFN0YXRzRmlsZTogXCJTw6lsZWN0aW9ubmVyIGxlIGZpY2hpZXIgZGUgc3RhdGlzdGlxdWVzIGV0IGTigJloaXN0b2dyYW1tZXNcIixcblx0XHRlbnRlclhNTEZpbGVVUkw6IFwiU2Fpc2lyIGzigJlVUkwgZHUgZmljaGllcsKgWE1MXCIsXG5cdFx0eG1sRmlsZVVSTDogXCJVUkwgZHUgZmljaGllcsKgWE1MXCIsXG5cdFx0Y2lyY3VsYXJDYWxjdWxhdGlvbjogXCJDYWxjdWxlciBsZXMgc3RhdGlzdGlxdWVzIGNpcmN1bGFpcmVzXCIsXG5cdFx0bG9jYWxTdXJmYWNlVHlwZTogXCJUeXBlIGRlIHN1cmZhY2UgbG9jYWxlXCIsXG5cdFx0c3VyZmFjZVBhcmFtZXRlclR5cGU6IFwiVHlwZSBkZSBwYXJhbcOodHJlXCIsXG5cdFx0bmVpZ2hib3Job29kRGlzdGFuY2U6IFwiRGlzdGFuY2UgZGUgdm9pc2luYWdlXCIsXG5cdFx0dXNlQWRhcHRpdmVOZWlnaGJvcmhvb2Q6IFwiVXRpbGlzZXIgbGUgdm9pc2luYWdlIGFkYXB0YXRpZlwiLFxuXHRcdG91dHB1dFNsb3BlVHlwZTogXCJNZXN1cmUgZGUgcGVudGUgZW4gc29ydGllXCIsXG5cdFx0cHJvamVjdEF6aW11dGhzOiBcIlByb2pldGVyIGRlcyBhemltdXRzIGfDqW9kw6lzaXF1ZXNcIixcblx0XHR1c2VFcXVhdG9yaWFsQXNwZWN0OiBcIlV0aWxpc2VyIGzigJlhc3BlY3Qgw6lxdWF0b3JpYWxcIixcblx0XHR6VW5pdDogXCJVbml0w6nCoFpcIixcblx0XHRhbmFseXNpc01hc2s6IFwiTWFzcXVlIGTigJlhbmFseXNlXCIsXG5cdFx0c3RkRGV2aWF0aW9uOiBcIsOJY2FydCB0eXBlXCIsXG5cdFx0XCJ0cnVlXCI6IFwiVnJhaVwiLFxuXHRcdFwiZmFsc2VcIjogXCJGYXV4XCIsXG5cdFx0Y29zdERpc3RhbmNlUmFzdGVyMTogXCIxZXLCoHJhc3RlciBkZSBkaXN0YW5jZSBkZSBjb8O7dCBjdW11bMOpIGVuIGVudHLDqWVcIixcblx0XHRjb3N0RGlzdGFuY2VSYXN0ZXIyOiBcIjJlwqByYXN0ZXIgZGUgZGlzdGFuY2UgZGUgY2/Du3QgY3VtdWzDqSBlbiBlbnRyw6llXCIsXG5cdFx0dGhyZXNob2xkOiBcIlNldWlsXCIsXG5cdFx0dGhyZXNob2xkTWV0aG9kOiBcIk3DqXRob2RlIGRlIHNldWlsXCIsXG5cdFx0ZGlyZWN0aW9uUmFzdGVyMTogXCIxZXLCoHJhc3RlciBkZSBkaXJlY3Rpb24gYXJyacOocmUgZW4gZW50csOpZVwiLFxuXHRcdGRpcmVjdGlvblJhc3RlcjI6IFwiMmXCoHJhc3RlciBkZSBkaXJlY3Rpb24gYXJyacOocmUgZW4gZW50csOpZVwiLFxuXHRcdG1heEl0ZXJhdGlvbnM6IFwiTm9tYnJlIG1heGltdW0gZOKAmWl0w6lyYXRpb25zXCIsXG5cdFx0ZXBzaWxvbjogXCJFcHNpbG9uXCJcblx0fSxcblx0ZW51bUxhYmVsczoge1xuXHRcdGF0dHJpYnV0ZVRhYmxlVHlwZU1hbnVhbDogXCJNYW51ZWxsZVwiLFxuXHRcdGF0dHJpYnV0ZVRhYmxlVHlwZUV4dGVybmFsOiBcIkV4dGVybmVcIixcblx0XHRjbHJTY2hlbWVUeXBlQ29sb3JtYXA6IFwiUGFsZXR0ZSBkZSBjb3VsZXVyc1wiLFxuXHRcdGNsclNjaGVtZVR5cGVDb2xvclJhbXA6IFwiRMOpZ3JhZMOpIGRlIGNvdWxldXJzXCIsXG5cdFx0Y29sb3JtYXBUeXBlRWxldmF0aW9uOiBcIkFsdGl0dWRlXCIsXG5cdFx0Y29sb3JtYXBUeXBlR3JheTogXCJHcmlzXCIsXG5cdFx0Y29sb3JtYXBUeXBlTkRWSTogXCJJbmRpY2UgTkRWSVwiLFxuXHRcdGNvbG9ybWFwVHlwZU5EVkkyOiBcIk5EVkkyXCIsXG5cdFx0Y29sb3JtYXBUeXBlTkRWSTM6IFwiTkRWSTNcIixcblx0XHRjb2xvcm1hcFR5cGVSYW5kb206IFwiQWzDqWF0b2lyZVwiLFxuXHRcdG5vbmU6IFwiQXVjdW5cIixcblx0XHRzbG9wZVR5cGVBZGp1c3RlZDogXCJBanVzdMOpXCIsXG5cdFx0c2xvcGVUeXBlRGVncmVlOiBcIkRlZ3LDqVwiLFxuXHRcdHNsb3BlVHlwZVBlcmNlbnRSaXNlOiBcIlBvdXJjZW50YWdlIGTigJnDqWzDqXZhdGlvblwiLFxuXHRcdHNsb3BlVHlwZVNjYWxlZDogXCJNaXNlIMOgIGzigJnDqWNoZWxsZVwiLFxuXHRcdHN0cmV0Y2hUeXBlTWluTWF4OiBcIk1pbk1heFwiLFxuXHRcdHN0cmV0Y2hUeXBlUGVyY2VudE1pbk1heDogXCJQb3VyY2VudGFnZU1pbk1heFwiLFxuXHRcdHN0cmV0Y2hUeXBlU2lnbW9pZDogXCJTaWdtb8OvZGVcIixcblx0XHRzdHJldGNoVHlwZVN0ZERldjogXCJFY2FydCB0eXBlXCIsXG5cdFx0aGlsbHNoYWRlVHlwZVNpbXBsZTogXCJUcmFkaXRpb25uZWxcIixcblx0XHRoaWxsc2hhZGVUeXBlTXVsdGlkaXJlY3Rpb25hbDogXCJNdWx0aWRpcmVjdGlvbm5lbFwiLFxuXHRcdGJhbmRDb21ib0J5TmFtZXM6IFwiTm9tcyBkZXMgY2FuYXV4XCIsXG5cdFx0YmFuZENvbWJvQnlXYXZlbGVuZ3RoOiBcIkxvbmd1ZXVycyBkJ29uZGVzIGRlcyBjYW5hdXhcIixcblx0XHRiYW5kQ29tYm9CeUlEczogXCJJZGVudGlmaWFudHMgZGVzIGNhbmF1eFwiLFxuXHRcdG1pc3NpbmdCYW5kQWN0aW9uQmVzdE1hdGNoOiBcIk1laWxsZXVyIHLDqXN1bHRhdFwiLFxuXHRcdG1pc3NpbmdCYW5kQWN0aW9uRmFpbDogXCLDiWNoZWNcIixcblx0XHR1bml0VHlwZUNlbHNpdXM6IFwiQ2Vsc2l1c1wiLFxuXHRcdHVuaXRUeXBlQ2VudGltZXRlcnM6IFwiQ2VudGltw6h0cmVzXCIsXG5cdFx0dW5pdFR5cGVEZWNpbWV0ZXJzOiBcIkTDqWNpbcOodHJlc1wiLFxuXHRcdHVuaXRUeXBlRmFocmVuaGVpdDogXCJGYWhyZW5oZWl0XCIsXG5cdFx0dW5pdFR5cGVGZWV0OiBcIlBpZWRzXCIsXG5cdFx0dW5pdFR5cGVGZWV0UGVyU2VjOiBcIlBpZWRzIHBhciBzZWNvbmRlIChwZC9zKVwiLFxuXHRcdHVuaXRUeXBlSW5jaGVzOiBcIlBvdWNlc1wiLFxuXHRcdHVuaXRUeXBlS2VsdmluOiBcIktlbHZpblwiLFxuXHRcdHVuaXRUeXBlS2lsb21ldGVyczogXCJLaWxvbcOodHJlc1wiLFxuXHRcdHVuaXRUeXBlS21zUGVySG91cjogXCJLaWxvbcOodHJlcyBwYXIgaGV1cmUgKGttL2gpXCIsXG5cdFx0dW5pdFR5cGVLbm90czogXCJOxZN1ZHMgKG5kKVwiLFxuXHRcdHVuaXRUeXBlTWV0ZXJzOiBcIk3DqHRyZXNcIixcblx0XHR1bml0VHlwZU1ldGVyc1BlclNlYzogXCJNw6h0cmVzIHBhciBzZWNvbmRlIChtL3MpXCIsXG5cdFx0dW5pdFR5cGVNaWxlczogXCJNaWxsZXNcIixcblx0XHR1bml0VHlwZU1pbGVzUGVySG91cjogXCJNaWxlcyBwYXIgaGV1cmUgKG1waClcIixcblx0XHR1bml0VHlwZU1pbGxpbWV0ZXJzOiBcIk1pbGxpbcOodHJlc1wiLFxuXHRcdHVuaXRUeXBlTmF1dGljYWxNaWxlczogXCJNaWxsZXMgbmF1dGlxdWVzXCIsXG5cdFx0dW5pdFR5cGVZYXJkczogXCJZYXJkc1wiLFxuXHRcdHVuaXRUeXBlRGVjaW1hbERlZ3JlZXM6IFwiRGVncsOpcyBkw6ljaW1hdXhcIixcblx0XHR1bml0VHlwZVBvaW50czogXCJQb2ludHNcIixcblx0XHR1bml0VHlwZVVua25vd246IFwiSW5jb25udVwiLFxuXHRcdHVuaXRUeXBlU3FNYXBVbml0czogXCJVbml0w6kgZGUgY2FydGUgYXUgY2FycsOpXCIsXG5cdFx0dW5pdFR5cGVTcU1pbGVzOiBcIk1pbGVzIGNhcnLDqXNcIixcblx0XHR1bml0VHlwZVNxS21zOiBcIktpbG9tw6h0cmVzIGNhcnLDqXNcIixcblx0XHR1bml0VHlwZUFjcmVzOiBcIkFyZXNcIixcblx0XHR1bml0VHlwZUhlY3RhcmVzOiBcIkhlY3RhcmVzXCIsXG5cdFx0dW5pdFR5cGVTcVlhcmRzOiBcIllhcmRzIGNhcnLDqXNcIixcblx0XHR1bml0VHlwZVNxRnQ6IFwiUGllZHMgY2FycsOpc1wiLFxuXHRcdHVuaXRUeXBlU3FJbmNoZXM6IFwiUG91Y2VzIGNhcnLDqXNcIixcblx0XHR1bml0VHlwZVNxTXRzOiBcIk3DqHRyZXMgY2FycsOpc1wiLFxuXHRcdHVuaXRUeXBlU3FDbXM6IFwiQ2VudGltw6h0cmVzIGNhcnLDqXNcIixcblx0XHR1bml0VHlwZVNxTW1zOiBcIk1pbGxpbcOodHJlcyBjYXJyw6lzXCIsXG5cdFx0Y2VsbHNpemVUeXBlRmlyc3Q6IFwiUHJlbWllciBkZVwiLFxuXHRcdGNlbGxzaXplVHlwZU1pbjogXCJNaW5pIGRlXCIsXG5cdFx0Y2VsbHNpemVUeXBlTWF4OiBcIk1heCBkZVwiLFxuXHRcdGNlbGxzaXplVHlwZU1lYW46IFwiTW95ZW5uZSBkZVwiLFxuXHRcdGNlbGxzaXplVHlwZUxhc3Q6IFwiRGVybmllciBkZVwiLFxuXHRcdGV4dGVudFR5cGVGaXJzdDogXCJQcmVtaWVyIGRlXCIsXG5cdFx0ZXh0ZW50VHlwZUludGVyc2VjdGlvbjogXCJJbnRlcnNlY3Rpb24gZGVcIixcblx0XHRleHRlbnRUeXBlVW5pb246IFwiVW5pb24gZGVcIixcblx0XHRleHRlbnRUeXBlTGFzdDogXCJEZXJuaWVyIGRlXCIsXG5cdFx0bm9EYXRhSW50ZXJwcmV0QW55OiBcIkNlcnRhaW5zIGNyaXTDqHJlc1wiLFxuXHRcdG5vRGF0YUludGVycHJldEFsbDogXCJUb3VzIGxlcyBjcml0w6hyZXNcIixcblx0XHRjdXJ2YXR1cmVUeXBlU3RhbmRhcmQ6IFwiU3RhbmRhcmRcIixcblx0XHRjdXJ2YXR1cmVUeXBlUHJvZmlsZTogXCJQcm9maWxcIixcblx0XHRjdXJ2YXR1cmVUeXBlUGxhbmZvcm06IFwiUGxhbmlmb3JtZVwiLFxuXHRcdGZpbHRlclR5cGVMaW5lRGV0ZWN0aW9uSG9yaXpvbnRhbDogXCJEw6l0ZWN0aW9uIGRlIGxpZ25lIGhvcml6b250YWxlXCIsXG5cdFx0ZmlsdGVyVHlwZUxpbmVEZXRlY3Rpb25WZXJ0aWNhbDogXCJEw6l0ZWN0aW9uIGRlIGxpZ25lIHZlcnRpY2FsZVwiLFxuXHRcdGZpbHRlclR5cGVMaW5lRGV0ZWN0aW9uTGVmdERpYWdvbmFsOiBcIkTDqXRlY3Rpb24gZGUgbGlnbmUgZGlhZ29uYWxlIGdhdWNoZVwiLFxuXHRcdGZpbHRlclR5cGVMaW5lRGV0ZWN0aW9uUmlnaHREaWFnb25hbDogXCJEw6l0ZWN0aW9uIGRlIGxpZ25lIGRpYWdvbmFsZSBkcm9pdGVcIixcblx0XHRmaWx0ZXJUeXBlR3JhZGllbnROb3J0aDogXCJEw6lncmFkw6kgbm9yZFwiLFxuXHRcdGZpbHRlclR5cGVHcmFkaWVudFdlc3Q6IFwiRMOpZ3JhZMOpIG91ZXN0XCIsXG5cdFx0ZmlsdGVyVHlwZUdyYWRpZW50RWFzdDogXCJEw6lncmFkw6kgZXN0XCIsXG5cdFx0ZmlsdGVyVHlwZUdyYWRpZW50U291dGg6IFwiRMOpZ3JhZMOpIHN1ZFwiLFxuXHRcdGZpbHRlclR5cGVHcmFkaWVudE5vcnRoRWFzdDogXCJEw6lncmFkw6kgbm9yZC1lc3RcIixcblx0XHRmaWx0ZXJUeXBlR3JhZGllbnROb3J0aFdlc3Q6IFwiRMOpZ3JhZMOpIG5vcmQtb3Vlc3RcIixcblx0XHRmaWx0ZXJUeXBlU21vb3RoQXJpdGhtZXRpY01lYW46IFwiTW95ZW5uZSBhcml0aG3DqXRpcXVlIGxpc3PDqWVcIixcblx0XHRmaWx0ZXJUeXBlU21vb3RoaW5nM3gzOiBcIkxpc3NhZ2UgM3gzXCIsXG5cdFx0ZmlsdGVyVHlwZVNtb290aGluZzV4NTogXCJMaXNzYWdlIDV4NVwiLFxuXHRcdGZpbHRlclR5cGVTaGFycGVuaW5nM3gzOiBcIkFmZmluYWdlIDN4M1wiLFxuXHRcdGZpbHRlclR5cGVTaGFycGVuaW5nNXg1OiBcIkFmZmluYWdlIDV4NVwiLFxuXHRcdGZpbHRlclR5cGVMYXBsYWNpYW4zeDM6IFwiTGFwbGFjaWVuIDN4M1wiLFxuXHRcdGZpbHRlclR5cGVMYXBsYWNpYW41eDU6IFwiTGFwbGFjaWVuIDV4NVwiLFxuXHRcdGZpbHRlclR5cGVTb2JlbEhvcml6b250YWw6IFwiU29iZWwgaG9yaXpvbnRhbFwiLFxuXHRcdGZpbHRlclR5cGVTb2JlbFZlcnRpY2FsOiBcIlNvYmVsIHZlcnRpY2FsXCIsXG5cdFx0ZmlsdGVyVHlwZVNoYXJwZW46IFwiQWZmaW5hZ2VcIixcblx0XHRmaWx0ZXJUeXBlU2hhcnBlbjI6IFwiQWZmaW5lciBkYXZhbnRhZ2VcIixcblx0XHRmaWx0ZXJUeXBlUG9pbnRTcHJlYWQ6IFwiRGlzcGVyc2lvbiBkZXMgcG9pbnRzXCIsXG5cdFx0dXNlckRlZmluZWQ6IFwiRMOpZmluaSBwYXIgbOKAmXV0aWxpc2F0ZXVyXCIsXG5cdFx0Q29udG91clR5cGVMaW5lczogXCJJc29saWduZXNcIixcblx0XHRDb250b3VyVHlwZUZpbGw6IFwiUmVtcGxpc3NhZ2UgZOKAmWlzb2xpZ25lc1wiLFxuXHRcdENvbnRvdXJUeXBlU21vb3RoT25seTogXCJTdXJmYWNlIGxpc3NlIHVuaXF1ZW1lbnRcIixcblx0XHRyYXN0ZXJpemVGaXJzdDogXCJQcmVtaWVyXCIsXG5cdFx0cmFzdGVyaXplTGFzdDogXCJEZXJuaWVyXCIsXG5cdFx0cmFzdGVyaXplU21hbGxlc3Q6IFwiTGUgcGx1cyBwZXRpdFwiLFxuXHRcdHJhc3Rlcml6ZUxhcmdlc3Q6IFwiTGUgcGx1cyBncmFuZFwiLFxuXHRcdHJlc2FtcGxpbmdUeXBlTmVhcmVzdDogXCJWb2lzaW4gbGUgcGx1cyBwcm9jaGVcIixcblx0XHRyZXNhbXBsaW5nVHlwZUJpbGluZWFyOiBcIkludGVycG9sYXRpb24gYmlsaW7DqWFpcmVcIixcblx0XHRyZXNhbXBsaW5nVHlwZUN1YmljOiBcIkNvbnZvbHV0aW9uIGN1YmlxdWVcIixcblx0XHRyZXNhbXBsaW5nVHlwZU1ham9yaXR5OiBcIk1ham9yaXTDqVwiLFxuXHRcdHJlc2FtcGxpbmdUeXBlQmlsaW5lYXJQbHVzOiBcIkludGVycG9sYXRpb24gYmlsaW7DqWFpcmUgUGx1c1wiLFxuXHRcdHJlc2FtcGxpbmdUeXBlR2F1c3M6IFwiRmxvdSBnYXVzc2llblwiLFxuXHRcdHJlc2FtcGxpbmdUeXBlR2F1c3NQbHVzOiBcIkZsb3UgZ2F1c3NpZW4gUGx1c1wiLFxuXHRcdHJlc2FtcGxpbmdUeXBlQXZlcmFnZTogXCJNb3llbm5lXCIsXG5cdFx0cmVzYW1wbGluZ1R5cGVNaW5pbXVtOiBcIk1pbmltYWxcIixcblx0XHRyZXNhbXBsaW5nVHlwZU1heGltdW06IFwiTWF4aW11bVwiLFxuXHRcdHJlc2FtcGxpbmdUeXBlVmVjdG9yQXZnOiBcIk1veWVubmUgdmVjdG9yaWVsbGVcIixcblx0XHRtaW5pbXVtOiBcIk1pbmltYWxcIixcblx0XHRtYXhpbXVtOiBcIk1heGltdW1cIixcblx0XHRtZWFuOiBcIk1veWVubmVcIixcblx0XHRzdGREZXZpYXRpb246IFwiw4ljYXJ0IHR5cGVcIixcblx0XHR1dk1hZ0RpclR5cGVVVjogXCJVLVZcIixcblx0XHR1dk1hZ0RpclR5cGVNYWdEaXI6IFwiTWFnbml0dWRlLURpcmVjdGlvblwiLFxuXHRcdHVua25vd246IFwiSW5jb25udVwiLFxuXHRcdGFuZ2xlUmVmU3lzR2VvZ3JhcGhpYzogXCJHw6lvZ3JhcGhpcXVlXCIsXG5cdFx0YW5nbGVSZWZTeXNBcml0aG1ldGljOiBcIkFyaXRobcOpdGlxdWVcIixcblx0XHRpbnRlcnBvbGF0ZUlycmVndWxhckRhdGFOZWFyZXN0OiBcIlZvaXNpbiBsZSBwbHVzIHByb2NoZVwiLFxuXHRcdGludGVycG9sYXRlSXJyZWd1bGFyRGF0YUJpbGluZWFyOiBcIkJpbGluw6lhaXJlXCIsXG5cdFx0aW50ZXJwb2xhdGVJcnJlZ3VsYXJEYXRhVGlubmluZ0xpbmVhcjogXCJUSU4gbGluw6lhaXJlXCIsXG5cdFx0aW50ZXJwb2xhdGVJcnJlZ3VsYXJEYXRhVGlubmluZ05hdHVyYWxOZWlnaGJvcjogXCJWb2lzaW4gbmF0dXJlbFwiLFxuXHRcdGludGVycG9sYXRlSXJyZWd1bGFyRGF0YVRpbm5pbmdJRFc6IFwiUG9uZMOpcmF0aW9uIHBhciBsJ2ludmVyc2UgZGUgbGEgZGlzdGFuY2VcIixcblx0XHRlc3JpUmFzdGVyVGhyZXNob2xkVHlwZUNvbnN0YW50OiBcIkNvbnN0YW50ZVwiLFxuXHRcdGVzcmlSYXN0ZXJUaHJlc2hvbGRUeXBlT3RzdTogXCJPdHN1XCIsXG5cdFx0ZXNyaVJhc3RlclRocmVzaG9sZFR5cGVUc2FpOiBcIlRzYWlcIixcblx0XHRlc3JpUmFzdGVyVGhyZXNob2xkVHlwZUthcHVyOiBcIkthcHVyXCIsXG5cdFx0ZXNyaVJhc3RlclRocmVzaG9sZFR5cGVLaXR0bGVyOiBcIktpdHRsZXJcIixcblx0XHRlc3JpUmFzdGVyVGhyZXNob2xkVHlwZVJvc2luOiBcIlJvc2luXCIsXG5cdFx0YXJnU3RhdHNUeXBlTWF4OiBcIkFyZyBNYXhcIixcblx0XHRhcmdTdGF0c1R5cGVNaW46IFwiQXJnIE1pblwiLFxuXHRcdGFyZ1N0YXRzVHlwZU1lZGlhbjogXCJBcmcgbcOpZGlhblwiLFxuXHRcdGFyZ1N0YXRzVHlwZUR1cmF0aW9uOiBcIkR1cmF0aW9uXCIsXG5cdFx0YXJpdGhtZXRpY09wUGx1czogXCJBZGRpdGlvblwiLFxuXHRcdGFyaXRobWV0aWNPcE1pbnVzOiBcIlNvdXN0cmFjdGlvblwiLFxuXHRcdGFyaXRobWV0aWNPcE11bHRpcGx5OiBcIk11bHRpcGxpY2F0aW9uXCIsXG5cdFx0YXJpdGhtZXRpY09wRGl2aWRlOiBcIkRpdmlzaW9uXCIsXG5cdFx0YXJpdGhtZXRpY09wUG93ZXI6IFwiUHVpc3NhbmNlXCIsXG5cdFx0YXJpdGhtZXRpY09wTW9kZTogXCJNb2RlXCIsXG5cdFx0Y2xpcFR5cGVPdXRzaWRlOiBcIkTDqWNvdXBhZ2UgZXh0w6lyaWV1clwiLFxuXHRcdGNsaXBUeXBlSW5zaWRlOiBcIkTDqWNvdXBhZ2UgaW50w6lyaWV1clwiLFxuXHRcdHllczogXCJPdWlcIixcblx0XHRubzogXCJOb25cIixcblx0XHRkZW5zaXRpZXM6IFwiRGVuc2l0w6lzXCIsXG5cdFx0ZXhwZWN0ZWRDb3VudHM6IFwiVm9sdW1lcyBhdHRlbmR1c1wiLFxuXHRcdHBsYW5hcjogXCJwbGFuZVwiLFxuXHRcdGdlb2Rlc2ljOiBcIkfDqW9kw6lzaXF1ZVwiLFxuXHRcdGVhY2hDZWxsOiBcIkNoYXF1ZSBjZWxsdWxlXCIsXG5cdFx0ZWFjaFpvbmU6IFwiQ2hhcXVlIHpvbmVcIixcblx0XHRiZXN0U2luZ2xlOiBcIkxlIG1vaW5zIGNvw7t0ZXV4XCIsXG5cdFx0YWxsU2lnaHRsaW5lczogXCJUb3V0ZXMgbGVzIGxpZ25lcyBkZSB2aXPDqWVcIixcblx0XHRwZXJpbWV0ZXJTaWdodGxpbmVzOiBcIkxpZ25lcyBkZSB2aXPDqWUgZHUgcMOpcmltw6h0cmVcIixcblx0XHRmcmVxdWVuY3k6IFwiRnLDqXF1ZW5jZVwiLFxuXHRcdG9ic2VydmVyczogXCJQb2ludHMgZCdvYnNlcnZhdGlvblwiLFxuXHRcdG1ham9yaXR5OiBcIk1ham9yaXTDqVwiLFxuXHRcdG1lZGlhbjogXCJNw6lkaWFuXCIsXG5cdFx0bWlub3JpdHk6IFwiTWlub3JpdMOpXCIsXG5cdFx0cGVyY2VudGlsZTogXCJDZW50aWxlXCIsXG5cdFx0cmFuZ2U6IFwiUGxhZ2VcIixcblx0XHRzdW06IFwiU29tbWVcIixcblx0XHR2YXJpZXR5OiBcIlZhcmnDqXTDqVwiLFxuXHRcdG5kdmk6IFwiSW5kaWNlIE5EVklcIixcblx0XHRzYXZpOiBcIlNBVklcIixcblx0XHRiYW5kQXJpdGhtZXRpY01ldGhvZFRTQVZJOiBcIlNBVkkgdHJhbnNmb3Jtw6lcIixcblx0XHRiYW5kQXJpdGhtZXRpY01ldGhvZE1TQVZJOiBcIlNBVkkgbW9kaWZpw6lcIixcblx0XHRiYW5kQXJpdGhtZXRpY01ldGhvZFN1bHRhbjogXCJGb3JtdWxlIGRlIFN1bHRhblwiLFxuXHRcdGdlbWk6IFwiR0VNSVwiLFxuXHRcdHB2aTogXCJQVklcIixcblx0XHRndmk6IFwiR1ZJIChMYW5kc2F0IFRNKVwiLFxuXHRcdHZhcmk6IFwiVkFSSVwiLFxuXHRcdHNyOiBcIlNSXCIsXG5cdFx0Z25kdmk6IFwiR05EVklcIixcblx0XHRuZHZpcmU6IFwiTkRWSXJlXCIsXG5cdFx0c3JyZTogXCJTUnJlXCIsXG5cdFx0bXR2aTI6IFwiTVRWSTJcIixcblx0XHRydHZpQ29yZTogXCJSVFZJQ29yZVwiLFxuXHRcdGNpcmU6IFwiQ0lyZVwiLFxuXHRcdGNpZzogXCJDSWdcIixcblx0XHRuZHdpOiBcIk5EV0lcIixcblx0XHRldmk6IFwiRVZJXCIsXG5cdFx0aXJvbk94aWRlOiBcIk94eWRlIGRlIGZlclwiLFxuXHRcdGZlcnJvdXNNaW5lcmFsczogXCJNaW7DqXJhdXggZmVycmV1eFwiLFxuXHRcdGNsYXlNaW5lcmFsczogXCJNaW7DqXJhdXggYXJnaWxldXhcIixcblx0XHR3bmR3aTogXCJXTkRXSVwiLFxuXHRcdGJhaTogXCJCQUlcIixcblx0XHRtbmR3aTogXCJNTkRXSVwiLFxuXHRcdG5icjogXCJOQlJcIixcblx0XHRuZGJpOiBcIk5EQklcIixcblx0XHRuZG1pOiBcIk5ETUlcIixcblx0XHRuZHNpOiBcIk5EU0lcIixcblx0XHRsb2NhbFNxdWFyZVJvb3Q6IFwiUmFjaW5lIGNhcnLDqWVcIixcblx0XHRsb2NhbEFDb3M6IFwiQUNvc1wiLFxuXHRcdGxvY2FsQVNpbjogXCJBU2luXCIsXG5cdFx0bG9jYWxBVGFuOiBcIkFUYW5cIixcblx0XHRsb2NhbEFUYW5IOiBcIkFUYW5IXCIsXG5cdFx0bG9jYWxBYnM6IFwiQWJzXCIsXG5cdFx0bG9jYWxCaXR3aXNlTm90OiBcIk5vbiBiaXQgw6AgYml0XCIsXG5cdFx0bG9jYWxCb29sZWFuTm90OiBcIk5vbiBib29sw6llblwiLFxuXHRcdGxvY2FsQ29zOiBcIkNvc1wiLFxuXHRcdGxvY2FsQ29zSDogXCJDb3NIXCIsXG5cdFx0bG9jYWxFeHA6IFwiRXhwXCIsXG5cdFx0bG9jYWxFeHAxMDogXCJFeHAxMFwiLFxuXHRcdGxvY2FsRXhwMjogXCJFeHAyXCIsXG5cdFx0bG9jYWxJbnQ6IFwiRW50aWVyXCIsXG5cdFx0bG9jYWxJc051bGw6IFwiRXN0IG51bFwiLFxuXHRcdGxvY2FsRmxvYXQ6IFwiRmxvdHRhbnRcIixcblx0XHRsb2NhbExuOiBcIkxuXCIsXG5cdFx0bG9jYWxMb2cxMDogXCJMb2cxMFwiLFxuXHRcdGxvY2FsTG9nMjogXCJMb2cyXCIsXG5cdFx0bG9jYWxOZWdhdGU6IFwiT3Bwb3PDqVwiLFxuXHRcdGxvY2FsUm91bmREb3duOiBcIkFycm9uZGkgaW5mw6lyaWV1clwiLFxuXHRcdGxvY2FsUm91bmRVcDogXCJBcnJvbmRpIHN1cMOpcmlldXJcIixcblx0XHRsb2NhbFNpbjogXCJTaW5cIixcblx0XHRsb2NhbFNpbkg6IFwiU2luSFwiLFxuXHRcdGxvY2FsVGFuOiBcIlRhblwiLFxuXHRcdGxvY2FsVGFuSDogXCJUYW5IXCIsXG5cdFx0bG9jYWxBQ29zSDogXCJBQ29zSFwiLFxuXHRcdGxvY2FsQVNpbkg6IFwiQVNpbkhcIixcblx0XHRsb2NhbFBsdXM6IFwiQWRkaXRpb25cIixcblx0XHRsb2NhbE1pbnVzOiBcIlNvdXN0cmFjdGlvblwiLFxuXHRcdGxvY2FsVGltZXM6IFwiTXVsdGlwbGllclwiLFxuXHRcdGxvY2FsUG93ZXI6IFwiUHVpc3NhbmNlXCIsXG5cdFx0bG9jYWxCaXR3aXNlQW5kOiBcIkV0IGJpdCDDoCBiaXRcIixcblx0XHRsb2NhbEJpdHdpc2VMZWZ0U2hpZnQ6IFwiRMOpY2FsYWdlIMOgIGdhdWNoZSBiaXQgw6AgYml0XCIsXG5cdFx0bG9jYWxCaXR3aXNlT3I6IFwiT3UgYml0IMOgIGJpdFwiLFxuXHRcdGxvY2FsQml0d2lzZVJpZ2h0U2hpZnQ6IFwiRMOpY2FsYWdlIMOgIGRyb2l0ZSBiaXQgw6AgYml0XCIsXG5cdFx0bG9jYWxCaXR3aXNlWG9yOiBcIk91IGV4Y2x1c2lmIGJpdCDDoCBiaXRcIixcblx0XHRsb2NhbEJvb2xlYW5BbmQ6IFwiRXQgYm9vbMOpZW5cIixcblx0XHRsb2NhbEJvb2xlYW5PcjogXCJPdSBib29sw6llblwiLFxuXHRcdGxvY2FsQm9vbGVhblhvcjogXCJPdSBleGNsdXNpZiBib29sw6llblwiLFxuXHRcdGxvY2FsRGl2aWRlOiBcIkRpdmlzaW9uXCIsXG5cdFx0bG9jYWxFcXVhbFRvOiBcIkVnYWwgw6BcIixcblx0XHRsb2NhbEdyZWF0ZXJUaGFuOiBcIlN1cMOpcmlldXIgw6BcIixcblx0XHRsb2NhbEdyZWF0ZXJUaGFuRXF1YWw6IFwiU3Vww6lyaWV1ciBvdSDDqWdhbCDDoFwiLFxuXHRcdGxvY2FsTGVzc1RoYW46IFwiSW5mw6lyaWV1ciDDoFwiLFxuXHRcdGxvY2FsTGVzc1RoYW5FcXVhbDogXCJJbmbDqXJpZXVyIG91IMOpZ2FsIMOgXCIsXG5cdFx0bG9jYWxNb2Q6IFwiTW9kXCIsXG5cdFx0bG9jYWxOb3RFcXVhbDogXCJEaWZmw6lyZW50IGRlXCIsXG5cdFx0bG9jYWxBVGFuMjogXCJBVGFuMlwiLFxuXHRcdGxvY2FsU3F1YXJlOiBcIkNhcnLDqVwiLFxuXHRcdGxvY2FsU2V0TnVsbDogXCJTZXROdWxsXCIsXG5cdFx0cmVtYXBEZWZUeXBlTGlzdDogXCJMaXN0ZVwiLFxuXHRcdHJlbWFwRGVmVHlwZVRhYmxlOiBcIlRhYmxlYXVcIixcblx0XHRyZW1hcFRhYmxlVHlwZVNpbXBsZTogXCJTaW1wbGVcIixcblx0XHRyZW1hcFRhYmxlVHlwZUR5bmFtaWM6IFwiRHluYW1pcXVlXCIsXG5cdFx0cmVtYXBUYWJsZVR5cGVSZWFzc2lnbm1lbnQ6IFwiUsOpYWZmZWN0YXRpb25cIixcblx0XHRnZW9tQ29ycmVjdGlvbkJ5Q29uc3RaOiBcIlV0aWxpc2VyIGxhIGNvbnN0YW50ZSBaXCIsXG5cdFx0Z2VvbUNvcnJlY3Rpb25CeURFTTogXCJVdGlsaXNlciBNTkFcIixcblx0XHRyYWRhckNhbGliQmV0YU5vdWdodDogXCJCw6p0YSB6w6lyb1wiLFxuXHRcdHJhZGFyQ2FsaWJTaWdtYU5vdWdodDogXCJTaWdtYSB6w6lyb1wiLFxuXHRcdHJhZGFyQ2FsaWJHYW1tYU5vdWdodDogXCJHYW1tYSB6w6lyb1wiLFxuXHRcdHNwZWNrbGVGaWx0ZXJUeXBlTGVlOiBcIkZpbHRyZSBMRUVcIixcblx0XHRzcGVja2xlRmlsdGVyVHlwZUVuaGFuY2VkTGVlOiBcIkZpbHRyZSBMRUUgYW3DqWxpb3LDqVwiLFxuXHRcdHNwZWNrbGVGaWx0ZXJUeXBlRnJvc3Q6IFwiRmlsdHJlIGRlIGdpdnJlXCIsXG5cdFx0c3BlY2tsZUZpbHRlclR5cGVLdWFuOiBcIkZpbHRyZSBLdWFuXCIsXG5cdFx0c3BlY2tsZU5vaXNlTW9kZWxNdWw6IFwiQnJ1aXQgbXVsdGlwbGljYXRpZlwiLFxuXHRcdHNwZWNrbGVOb2lzZU1vZGVsQWRkOiBcIkJydWl0IGFkZGl0aWZcIixcblx0XHRzcGVja2xlTm9pc2VNb2RlbEFkZG5NdWw6IFwiQnJ1aXQgYWRkaXRpZiBldCBtdWx0aXBsaWNhdGlmXCIsXG5cdFx0bW9zYWljT3BUeXBlRmlyc3Q6IFwiUHJlbWllclwiLFxuXHRcdG1vc2FpY09wVHlwZUxhc3Q6IFwiRGVybmllclwiLFxuXHRcdG1vc2FpY09wVHlwZU1pbjogXCJNaW5cIixcblx0XHRtb3NhaWNPcFR5cGVNYXg6IFwiTWF4XCIsXG5cdFx0bW9zYWljT3BUeXBlTWVhbjogXCJNb3llbm5lXCIsXG5cdFx0bW9zYWljT3BUeXBlQmxlbmQ6IFwiRnVzaW9ubmVyXCIsXG5cdFx0bW9zYWljT3BUeXBlU3VtOiBcIlNvbW1lXCIsXG5cdFx0aW50ZWdlcjogXCJFbnRpZXJcIixcblx0XHRyZnhEODogXCJEOFwiLFxuXHRcdHJmeE1GRDogXCJNRkRcIixcblx0XHRkaW5mOiBcIkRpbmZcIixcblx0XHR2ZXJ0aWNhbDogXCJWZXJ0aWNhbGVcIixcblx0XHRob3Jpem9udGFsOiBcIkhvcml6b250YWxlXCIsXG5cdFx0bG9jYWxDZWxsU3RhdGlzdGljc01ham9yaXR5OiBcIk1ham9yaXTDqVwiLFxuXHRcdGxvY2FsQ2VsbFN0YXRpc3RpY3NNYXg6IFwiTWF4aW11bVwiLFxuXHRcdGxvY2FsQ2VsbFN0YXRpc3RpY3NNZWFuOiBcIk1veWVubmVcIixcblx0XHRsb2NhbENlbGxTdGF0aXN0aWNzTWVkaWFuOiBcIk3DqWRpYW5cIixcblx0XHRsb2NhbENlbGxTdGF0aXN0aWNzTWluOiBcIk1pbmltYWxcIixcblx0XHRsb2NhbENlbGxTdGF0aXN0aWNzTWlub3JpdHk6IFwiTWlub3JpdMOpXCIsXG5cdFx0bG9jYWxDZWxsU3RhdGlzdGljc1JhbmdlOiBcIlBsYWdlXCIsXG5cdFx0bG9jYWxDZWxsU3RhdGlzdGljc1N0ZERldjogXCLDiWNhcnQgdHlwZVwiLFxuXHRcdGxvY2FsQ2VsbFN0YXRpc3RpY3NTdW06IFwiU29tbWVcIixcblx0XHRsb2NhbENlbGxTdGF0aXN0aWNzVmFyaWV0eTogXCJWYXJpw6l0w6lcIixcblx0XHRsb2NhbENlbGxTdGF0aXN0aWNzTWFqb3JpdHlJZ25vcmVORDogXCJNYWpvcml0w6kgKElnbm9yZXIgTm9EYXRhKVwiLFxuXHRcdGxvY2FsQ2VsbFN0YXRpc3RpY3NNYXhJZ25vcmVORDogXCJNYXhpbXVtIChJZ25vcmVyIE5vRGF0YSlcIixcblx0XHRsb2NhbENlbGxTdGF0aXN0aWNzTWVhbklnbm9yZU5EOiBcIk1veWVubmUgKElnbm9yZXIgTm9EYXRhKVwiLFxuXHRcdGxvY2FsQ2VsbFN0YXRpc3RpY3NNZWRpYW5JZ25vcmVORDogXCJNw6lkaWFuZSAoSWdub3JlciBOb0RhdGEpXCIsXG5cdFx0bG9jYWxDZWxsU3RhdGlzdGljc01pbklnbm9yZU5EOiBcIk1pbmltdW0gKElnbm9yZXIgTm9EYXRhKVwiLFxuXHRcdGxvY2FsQ2VsbFN0YXRpc3RpY3NNaW5vcml0eUlnbm9yZU5EOiBcIk1pbm9yaXTDqSAoSWdub3JlciBOb0RhdGEpXCIsXG5cdFx0bG9jYWxDZWxsU3RhdGlzdGljc1JhbmdlSWdub3JlTkQ6IFwiUGxhZ2UgKElnbm9yZXIgTm9EYXRhKVwiLFxuXHRcdGxvY2FsQ2VsbFN0YXRpc3RpY3NTdGREZXZJZ25vcmVORDogXCJFY2FydCB0eXBlIChJZ25vcmVyIE5vRGF0YSlcIixcblx0XHRsb2NhbENlbGxTdGF0aXN0aWNzU3VtSWdub3JlTkQ6IFwiU29tbWUgKElnbm9yZXIgTm9EYXRhKVwiLFxuXHRcdGxvY2FsQ2VsbFN0YXRpc3RpY3NWYXJpZXR5SWdub3JlTkQ6IFwiVmFyacOpdMOpIChJZ25vcmVyIE5vRGF0YSlcIixcblx0XHRsb2NhbENlbGxTdGF0aXN0aWNzVHlwZVBlcmNlbnRpbGVJZ25vcmVORDogXCJDZW50aWxlIChJZ25vcmVyIGxlcyB2YWxldXJzIE5vRGF0YSlcIixcblx0XHRmcm9tU291cmNlOiBcIsOAIHBhcnRpciBkZSBsYSBzb3VyY2VcIixcblx0XHR0b1NvdXJjZTogXCJWZXJzIGxhIHNvdXJjZVwiLFxuXHRcdGNvbG9yc3BhY2VDb252ZXJzaW9uUmdiVG9Ic3Y6IFwiUlZCIHZlcnMgVFNMXCIsXG5cdFx0Y29sb3JzcGFjZUNvbnZlcnNpb25Ic3ZUb1JnYjogXCJUU0wgdmVycyBSVkJcIixcblx0XHRwYW5zaGFycGVuVHlwZUlIUzogXCJJSFNcIixcblx0XHRwYW5zaGFycGVuVHlwZUJyb3ZleTogXCJCcm92ZXlcIixcblx0XHRwYW5zaGFycGVuVHlwZUVzcmk6IFwiRXNyaVwiLFxuXHRcdHBhbnNoYXJwZW5UeXBlTWVhbjogXCJNb3llbm5lXCIsXG5cdFx0cGFuc2hhcnBlblR5cGVHcmFtU2NobWlkdDogXCJHcmFtLVNjaG1pZHRcIixcblx0XHRyZWN0YW5nbGVOZWlnaGJvcmhvb2Q6IFwiUmVjdGFuZ2xlXCIsXG5cdFx0Y2lyY2xlTmVpZ2hib3Job29kOiBcIkNlcmNsZVwiLFxuXHRcdGFubnVsdXNOZWlnaGJvcmhvb2Q6IFwiQW5uZWF1XCIsXG5cdFx0d2VkZ2VOZWlnaGJvcmhvb2Q6IFwiU2VjdGV1clwiLFxuXHRcdGlycmVndWxhck5laWdoYm9yaG9vZDogXCJJcnLDqWd1bGnDqHJlXCIsXG5cdFx0d2VpZ2h0TmVpZ2hib3Job29kOiBcIlBvbmTDqXJhdGlvblwiLFxuXHRcdGZvdXI6IFwiRm91clwiLFxuXHRcdGVpZ2h0OiBcIkVpZ2h0XCIsXG5cdFx0d2l0aGluOiBcIkRhbnNcIixcblx0XHRjcm9zczogXCJDcm9pc2VyXCIsXG5cdFx0YWRkTGluazogXCJBam91dGVyIHVuIGxpZW5cIixcblx0XHRub0xpbms6IFwiQXVjdW4gbGllblwiLFxuXHRcdHdlaWdodGVkTWVhbjogXCJNb3llbm5lIHBvbmTDqXLDqWVcIixcblx0XHRsczhRQ0JpdFBhdHRlcm5DaXJydXM6IFwiTGFuZHNhdCA4IENpcnJ1c1wiLFxuXHRcdGxzOFFDQml0UGF0dGVybkNsb3VkOiBcIkxhbmRzYXQgOCBOdWFnZVwiLFxuXHRcdGxzOFFDQml0UGF0dGVybkNsb3VkU2hhZG93OiBcIkxhbmRzYXQgOCBPbWJyZSBudWFnZVwiLFxuXHRcdGxzOFFDQml0UGF0dGVybkRlc2lnbmF0ZWRGaWxsOiBcIkxhbmRzYXQgOCBSZW1wbGlzc2FnZSBkw6lzaWduw6lcIixcblx0XHRsczhRQ0JpdFBhdHRlcm5Ecm9wcGVkRnJhbWU6IFwiTGFuZHNhdCA4IEltYWdlIGTDqXBsYWPDqWVcIixcblx0XHRsczhRQ0JpdFBhdHRlcm5Tbm93SWNlOiBcIkxhbmRzYXQgOCBOZWlnZS9nbGFjZVwiLFxuXHRcdGxzOFFDQml0UGF0dGVyblRlcnJhaW5PY2NsdXNpb246IFwiTGFuZHNhdCA4IE9jY2x1c2lvbiBkZSB0ZXJyYWluXCIsXG5cdFx0bHM4UUNCaXRQYXR0ZXJuVmVnZXRhdGlvbjogXCJMYW5kc2F0IDggVsOpZ8OpdGF0aW9uXCIsXG5cdFx0bHM4UUNCaXRQYXR0ZXJuV2F0ZXI6IFwiTGFuZHNhdCA4IEVhdVwiLFxuXHRcdGRvd25TdHJlYW06IFwiRW4gYXZhbFwiLFxuXHRcdHVwU3RyZWFtOiBcIkVuIGFtb250XCIsXG5cdFx0c3RyYWhsZXI6IFwiU1RSQUhMRVJcIixcblx0XHRzaHJldmU6IFwiU0hSRVZFXCIsXG5cdFx0Y3VycmVudFNsaWNlOiBcIkNvdXBlIGFjdHVlbGxlXCIsXG5cdFx0YWxsU2xpY2VzOiBcIlRvdXRlcyBsZXMgY291cGVzXCIsXG5cdFx0ZXhwYW5kRGlzdGFuY2U6IFwiRElTVEFOQ0VcIixcblx0XHRleHBhbmRNb3JwaG9sb2dpY2FsOiBcIk1PUlBIT0xPR0lRVUVcIixcblx0XHRzcGVjdHJhbFByb2ZpbGVGaWxlOiBcIlByb2ZpbCBzcGVjdHJhbFwiLFxuXHRcdHRyYWluaW5nRmVhdHVyZUZpbGU6IFwiRW50aXTDqSBk4oCZZW50cmHDrm5lbWVudFwiLFxuXHRcdHJhbmRvbURpc3RyaWJ1dGlvblR5cGVVbmlmb3JtOiBcIlVuaWZvcm1lXCIsXG5cdFx0cmFuZG9tRGlzdHJpYnV0aW9uVHlwZVVuaWZvcm1JbnRlZ2VyOiBcIkVudGllcnNcIixcblx0XHRyYW5kb21EaXN0cmlidXRpb25UeXBlTm9ybWFsOiBcIk5vcm1hbGVcIixcblx0XHRyYW5kb21EaXN0cmlidXRpb25UeXBlRXhwb25lbnRpYWw6IFwiRXhwb25lbnRpZWxsZVwiLFxuXHRcdHJhbmRvbURpc3RyaWJ1dGlvblR5cGVQb2lzc29uOiBcIlBvaXNzb25cIixcblx0XHRyYW5kb21EaXN0cmlidXRpb25UeXBlR2FtbWE6IFwiR2FtbWFcIixcblx0XHRyYW5kb21EaXN0cmlidXRpb25UeXBlQmlub21pYWw6IFwiQmlub21pYWxlXCIsXG5cdFx0cmFuZG9tRGlzdHJpYnV0aW9uVHlwZUdlb21ldHJpYzogXCJHw6lvbcOpdHJpcXVlXCIsXG5cdFx0cmFuZG9tRGlzdHJpYnV0aW9uVHlwZU5lZ2F0aXZlQmlub21pYWw6IFwiQmlub21pYWxlIG7DqWdhdGl2ZVwiLFxuXHRcdHJhbmRvbUdlbmVyYXRvclR5cGVTdGFuZGFyZENSYW5kOiBcIlN0YW5kYXJkIEMgUmFuZFwiLFxuXHRcdHJhbmRvbUdlbmVyYXRvclR5cGVBbGdvcml0aG1BQ001OTk6IFwiQWxnb3JpdGhtZSBkZSBjb2xsZWN0ZSBBQ00gNTk5XCIsXG5cdFx0cmFuZG9tR2VuZXJhdG9yVHlwZU1lcnNlbm5lVHdpc3RlcjogXCJNZXJzZW5uZSBUd2lzdGVyXCIsXG5cdFx0c3VtTmFtZTogXCJTb21tZVwiLFxuXHRcdG1lZGFpbk5hbWU6IFwiTcOpZGlhbmVcIixcblx0XHR0cmVuZExpbmVhcjogXCJMaW7DqWFpcmVcIixcblx0XHR0cmVuZEhhcm1vbmljOiBcIkhhcm1vbmlxdWVcIixcblx0XHR0cmVuZFBvbHlub21pYWw6IFwiUG9seW5vbWlhbGVcIixcblx0XHR0cmVuZE1hbm5LZW5kYWxsOiBcIk1hbm4tS2VuZGFsbFwiLFxuXHRcdHRyZW5kU2Vhc29uYWxLZW5kYWxsOiBcIktlbmRhbGwgc2Fpc29ubmllclwiLFxuXHRcdGRpbWVuc2lvbkJ5VmFsdWU6IFwiUGFyIHZhbGV1clwiLFxuXHRcdGRpbWVuc2lvbkJ5SW50ZXJ2YWw6IFwiUGFyIGludGVydmFsbGVcIixcblx0XHRtZGltRGVmVHlwZUFsbDogXCJjaGFjdW5lXCIsXG5cdFx0bWRpbURlZlR5cGVCeVZhbHVlczogXCJCeSBWYWx1ZXMgKFBhciB2YWxldXJzKVwiLFxuXHRcdG1kaW1EZWZUeXBlQnlSYW5nZXM6IFwiQnkgUmFuZ2VzIChQYXIgcGxhZ2VzKVwiLFxuXHRcdG1kaW1EZWZUeXBlQnlJdGVyYXRpb246IFwiQnkgSXRlcmF0aW9uIChQYXIgaXTDqXJhdGlvbilcIixcblx0XHRtZGltRGVmVHlwZUJ5SW50ZXJ2YWw6IFwiUGFyIGludGVydmFsbGVcIixcblx0XHRtZGltRGVmVHlwZUJ5VGFyZ2V0UmFzdGVyOiBcIlBhciByYXN0ZXIgY2libGVcIixcblx0XHRlc3JpVGltZVVuaXRzSG91cnM6IFwiSGV1cmVzXCIsXG5cdFx0ZXNyaVRpbWVVbml0c0RheXM6IFwiSm91cnNcIixcblx0XHRlc3JpVGltZVVuaXRzV2Vla3M6IFwiU2VtYWluZXNcIixcblx0XHRlc3JpVGltZVVuaXRzTW9udGhzOiBcIk1vaXNcIixcblx0XHRlc3JpVGltZVVuaXRzWWVhcnM6IFwiQW5uw6llc1wiLFxuXHRcdGVzcmlUaW1lSW50ZXJ2YWxLZXl3b3JkSG91cmx5OiBcIlBhciBoZXVyZVwiLFxuXHRcdGVzcmlUaW1lSW50ZXJ2YWxLZXl3b3JkRGFpbHk6IFwiUGFyIGpvdXJcIixcblx0XHRlc3JpVGltZUludGVydmFsS2V5d29yZFdlZWtseTogXCJQYXIgc2VtYWluZVwiLFxuXHRcdGVzcmlUaW1lSW50ZXJ2YWxLZXl3b3JkRGVrYWRseTogXCJQYXIgMTDCoGpvdXJzXCIsXG5cdFx0ZXNyaVRpbWVJbnRlcnZhbEtleXdvcmRQZW50YWRseTogXCJQYXIgNcKgam91cnNcIixcblx0XHRlc3JpVGltZUludGVydmFsS2V5d29yZE1vbnRobHk6IFwiUGFyIG1vaXNcIixcblx0XHRlc3JpVGltZUludGVydmFsS2V5d29yZFF1YXJ0ZXJseTogXCJQYXIgdHJpbWVzdHJlXCIsXG5cdFx0ZXNyaVRpbWVJbnRlcnZhbEtleXdvcmRZZWFybHk6IFwiUGFyIGFuXCIsXG5cdFx0ZXNyaVRpbWVJbnRlcnZhbEtleXdvcmRSZWN1cnJpbmdEYWlseTogXCJSw6ljdXJyZW5jZSBxdW90aWRpZW5uZVwiLFxuXHRcdGVzcmlUaW1lSW50ZXJ2YWxLZXl3b3JkUmVjdXJyaW5nV2Vla2x5OiBcIlLDqWN1cnJlbmNlIGhlYmRvbWFkYWlyZVwiLFxuXHRcdGVzcmlUaW1lSW50ZXJ2YWxLZXl3b3JkUmVjdXJyaW5nTW9udGhseTogXCJSw6ljdXJyZW5jZSBtZW5zdWVsbGVcIixcblx0XHRlc3JpVGltZUludGVydmFsS2V5d29yZFJlY3VycmluZ1F1YXJ0ZXJseTogXCJSw6ljdXJyZW5jZSB0cmltZXN0cmllbGxlXCIsXG5cdFx0YWdnRGVmVHlwZUFsbDogXCJUb3V0XCIsXG5cdFx0YWdnRGVmVHlwZUludGVydmFsS2V5d29yZDogXCJNb3QtY2zDqSBkZSBs4oCZaW50ZXJ2YWxsZVwiLFxuXHRcdGFnZ0RlZlR5cGVJbnRlcnZhbFZhbHVlOiBcIlZhbGV1ciBkZSBs4oCZaW50ZXJ2YWxsZVwiLFxuXHRcdGFnZ0RlZlR5cGVJbnRlcnZhbFJhbmdlczogXCJQbGFnZXMgZOKAmWludGVydmFsbGVcIixcblx0XHRsYXRlc3RDaGFuZ2U6IFwiSGV1cmUgZHUgZGVybmllciBjaGFuZ2VtZW50XCIsXG5cdFx0ZWFybGllc3RDaGFuZ2U6IFwiSGV1cmUgZHUgcHJlbWllciBjaGFuZ2VtZW50XCIsXG5cdFx0bGFyZ2VzdENoYW5nZTogXCJIZXVyZSBkdSBjaGFuZ2VtZW50IGxlIHBsdXMgaW1wb3J0YW50XCIsXG5cdFx0bnVtYmVyT2ZDaGFuZ2VzOiBcIk5vbWJyZSBkZSBjaGFuZ2VtZW50c1wiLFxuXHRcdGxvbmdlc3RDaGFuZ2U6IFwiRGF0ZS9oZXVyZSBkdSBwbHVzIGxvbmcgY2hhbmdlbWVudFwiLFxuXHRcdHNob3J0ZXN0Q2hhbmdlOiBcIkRhdGUvaGV1cmUgZHUgcGx1cyBjb3VydCBjaGFuZ2VtZW50XCIsXG5cdFx0ZmFzdGVzdENoYW5nZTogXCJEYXRlL2hldXJlIGR1IGNoYW5nZW1lbnQgbGUgcGx1cyByYXBpZGVcIixcblx0XHRzbG93ZXN0Q2hhbmdlOiBcIkRhdGUvaGV1cmUgZHUgY2hhbmdlbWVudCBsZSBwbHVzIGxlbnRcIixcblx0XHRhbGxDaGFuZ2VzOiBcIlRvdXRcIixcblx0XHRpbmNyZWFzZUNoYW5nZXM6IFwiQXVnbWVudGVyXCIsXG5cdFx0ZGVjcmVhc2VDaGFuZ2VzOiBcIkRpbWludWVyXCIsXG5cdFx0c2VnbWVudEJlZ2lubmluZzogXCJEw6lidXQgZHUgc2VnbWVudFwiLFxuXHRcdHNlZ21lbnRFbmQ6IFwiRmluIGR1IHNlZ21lbnRcIixcblx0XHRlc3JpQ29tcHV0ZUNoYW5nZU1ldGhvZERpZmZlcmVuY2U6IFwiRGlmZsOpcmVuY2VcIixcblx0XHRlc3JpQ29tcHV0ZUNoYW5nZU1ldGhvZFJlbGF0aXZlRGlmZmVyZW5jZTogXCJEaWZmw6lyZW5jZSByZWxhdGl2ZVwiLFxuXHRcdGVzcmlDb21wdXRlQ2hhbmdlTWV0aG9kQ2F0ZWdvcmljYWw6IFwiRGlmZsOpcmVuY2UgY2F0w6lnb3JpZWxsZVwiLFxuXHRcdGVzcmlDb21wdXRlQ2hhbmdlTWV0aG9kTXVsdGlzcGVjdHJhbEV1Y2xpZGVhbkRpc3RhbmNlOiBcIkRpc3RhbmNlIGV1Y2xpZGllbm5lIHNwZWN0cmFsZVwiLFxuXHRcdGVzcmlDb21wdXRlQ2hhbmdlTWV0aG9kTXVsdGlzcGVjdHJhbEFuZ3VsYXJEaWZmZXJlbmNlOiBcIsOJY2FydCBkZSBs4oCZYW5nbGUgc3BlY3RyYWxcIixcblx0XHRlc3JpQ29tcHV0ZUNoYW5nZU1ldGhvZE11bHRpc3BlY3RyYWxBeGlzV2l0aEJpZ2dlc3RDaGFuZ2U6IFwiQmFuZGUgYXZlYyBsZSBwbHVzIGRlIGNoYW5nZW1lbnRzXCIsXG5cdFx0ZXNyaUNvbXB1dGVDaGFuZ2VLZWVwQWxsOiBcIlRvdXQgY29uc2VydmVyXCIsXG5cdFx0ZXNyaUNvbXB1dGVDaGFuZ2VLZWVwQ2hhbmdlZE9ubHk6IFwiQ29uc2VydmVyIHVuaXF1ZW1lbnQgbGVzIHBpeGVscyBheWFudCBjaGFuZ8OpXCIsXG5cdFx0ZXNyaUNvbXB1dGVDaGFuZ2VLZWVwVW5jaGFuZ2VkT25seTogXCJDb25zZXJ2ZXIgdW5pcXVlbWVudCBsZXMgcGl4ZWxzIGluY2hhbmfDqXNcIixcblx0XHRlc3JpQ29tcHV0ZUNoYW5nZVVzZUNvbG9yQXZlcmFnZTogXCJVdGlsaXNlciBsYSBtb3llbm5lIGRlcyBjb3VsZXVycyBk4oCZb3JpZ2luZSBldCBkZSBkZXN0aW5hdGlvblwiLFxuXHRcdGVzcmlDb21wdXRlQ2hhbmdlVXNlQ29sb3JGcm9tOiBcIlV0aWxpc2VyIGxlcyBjb3VsZXVycyBk4oCZb3JpZ2luZVwiLFxuXHRcdGVzcmlDb21wdXRlQ2hhbmdlVXNlQ29sb3JUbzogXCJVdGlsaXNlciBsZXMgY291bGV1cnMgZGUgZGVzdGluYXRpb25cIixcblx0XHRmYWN0b3JGdW5jdGlvbkJpbmFyeTogXCJCaW5haXJlXCIsXG5cdFx0ZmFjdG9yRnVuY3Rpb25Gb3J3YXJkOiBcIkF2YW50XCIsXG5cdFx0ZmFjdG9yRnVuY3Rpb25MaW5lYXI6IFwiTGluw6lhaXJlXCIsXG5cdFx0ZmFjdG9yRnVuY3Rpb25JbnZMaW5lYXI6IFwiTGluw6lhaXJlIGludmVyc2VcIixcblx0XHRmYWN0b3JGdW5jdGlvblRhYmxlOiBcIlRhYmxlXCIsXG5cdFx0ZmFjdG9yRnVuY3Rpb25TeW1MaW5lYXI6IFwiTGluw6lhaXJlIHN5bcOpdHJpcXVlXCIsXG5cdFx0ZmFjdG9yRnVuY3Rpb25TeW1JbnZMaW5lYXI6IFwiTGluw6lhaXJlIHN5bcOpdHJpcXVlIGludmVyc2VcIixcblx0XHRmYWN0b3JGdW5jdGlvbkNvczogXCJDb3NpbnVzXCIsXG5cdFx0ZmFjdG9yRnVuY3Rpb25TZWM6IFwiU8OpY2FudGVcIixcblx0XHRmYWN0b3JGdW5jdGlvbkNvc1NlYzogXCJDb3NpbnVzIC0gU8OpY2FudGVcIixcblx0XHRmYWN0b3JGdW5jdGlvblNlY0NvczogXCJTw6ljYW50ZSAtIENvc2ludXNcIixcblx0XHRub1NvcnQ6IFwiTmUgcGFzIHRyaWVyXCIsXG5cdFx0YXNjZW5kOiBcIkNyb2lzc2FudFwiLFxuXHRcdGRlc2NlbmQ6IFwiRMOpY3JvaXNzYW50XCIsXG5cdFx0YXV0b0RldGVjdDogXCJEw6l0ZWN0aW9uIGF1dG9tYXRpcXVlXCIsXG5cdFx0bmVhcmVzdDogXCJMZSBwbHVzIHByb2NoZVwiLFxuXHRcdGxpbmVhcjogXCJMaW7DqWFpcmVcIixcblx0XHRlc3JpTW9udGhKYW51YXJ5OiBcIkphbnZpZXJcIixcblx0XHRlc3JpTW9udGhGZWJydWFyeTogXCJGw6l2cmllclwiLFxuXHRcdGVzcmlNb250aE1hcmNoOiBcIk1hcnNcIixcblx0XHRlc3JpTW9udGhBcHJpbDogXCJBdnJpbFwiLFxuXHRcdGVzcmlNb250aE1heTogXCJNYWlcIixcblx0XHRlc3JpTW9udGhKdW5lOiBcIkp1aW5cIixcblx0XHRlc3JpTW9udGhKdWx5OiBcIkp1aWxsZXRcIixcblx0XHRlc3JpTW9udGhBdWd1c3Q6IFwiQW/Du3RcIixcblx0XHRlc3JpTW9udGhTZXB0ZW1iZXI6IFwiU2VwdGVtYnJlXCIsXG5cdFx0ZXNyaU1vbnRoT2N0b2JlcjogXCJPY3RvYnJlXCIsXG5cdFx0ZXNyaU1vbnRoTm92ZW1iZXI6IFwiTm92ZW1icmVcIixcblx0XHRlc3JpTW9udGhEZWNlbWJlcjogXCJEw6ljZW1icmVcIixcblx0XHRkaW1lbnNpb25hbE1vdmluZ0lnbm9yZU5vRGF0YTogXCJEb25uw6llc1wiLFxuXHRcdGRpbWVuc2lvbmFsTW92aW5nUHJvcGFnYXRlTm9EYXRhOiBcIk5vRGF0YVwiLFxuXHRcdGRpbWVuc2lvbmFsTW92aW5nRmlsbE9ubHlOb0RhdGE6IFwiUmVtcGxpciBsZXMgdmFsZXVycyBOb0RhdGFcIixcblx0XHRjaXJjdWxhck1lYW46IFwiTW95ZW5uZSBjaXJjdWxhaXJlXCIsXG5cdFx0Y2lyY3VsYXJOYW1lOiBcIkNpcmN1bGFpcmVcIixcblx0XHRhcml0aG1ldGljTmFtZTogXCJBcml0aG3DqXRpcXVlXCIsXG5cdFx0c2xvcGVOYW1lOiBcIlBlbnRlXCIsXG5cdFx0YXNwZWN0TmFtZTogXCJFeHBvc2l0aW9uXCIsXG5cdFx0bWVhbkN1cnZhdHVyZTogXCJDb3VyYnVyZSBtb3llbm5lXCIsXG5cdFx0cHJvZmlsZUN1cnZhdHVyZTogXCJDb3VyYnVyZSBsb25naXR1ZGluYWxlIChsaWduZSBkZSBwZW50ZSBub3JtYWxlKVwiLFxuXHRcdHRhbmdlbnRpYWxDdXJ2YXR1cmU6IFwiQ291cmJ1cmUgdGFuZ2VudGllbGxlIChpc29saWduZSBub3JtYWxlKVwiLFxuXHRcdHBsYW5DdXJ2YXR1cmU6IFwiQ291cmJ1cmUgdHJhbnN2ZXJzYWxlIChpc29saWduZSBwcm9qZXTDqWUpXCIsXG5cdFx0Y29udG91ckdlb2Rlc2ljVG9yc2lvbjogXCJUb3JzaW9uIGfDqW9kw6lzaXF1ZSBkZXMgaXNvbGlnbmVzXCIsXG5cdFx0Z2F1c3NpYW5DdXJ2YXR1cmU6IFwiQ291cmJ1cmUgZ2F1c3NpZW5uZVwiLFxuXHRcdGNhc29yYXRpQ3VydmF0dXJlOiBcIkNvdXJidXJlIENhc29yYXRpXCIsXG5cdFx0bG9jYWxTdXJmYWNlVHlwZVF1YWRyYXRpYzogXCJRdWFkcmF0aXF1ZVwiLFxuXHRcdGxvY2FsU3VyZmFjZVR5cGVCaXF1YWRyYXRpYzogXCJCaXF1YWRyYXRpcXVlXCIsXG5cdFx0dGhyZXNob2xkTm9UaHJlc2hvbGQ6IFwiQXVjdW4gc2V1aWxcIixcblx0XHR0aHJlc2hvbGRQZXJjZW50TGVhc3RDb3N0OiBcIlBvdXJjZW50YWdlIGRlIG1vaW5kcmUgY2/Du3RcIixcblx0XHR0aHJlc2hvbGRBY2N1bXVsYXRpdmVDb3N0OiBcIkNvw7t0IGN1bXVsw6lcIixcblx0XHRjbHJtYXBUeXBlSGlsbHNoYWRlOiBcIk9tYnJhZ2VcIlxuXHR9LFxuXHRjYXRlZ29yeUxhYmVsczoge1xuXHRcdHNvdXJjZUNoYXJhY3RlcmlzdGljczogXCJDYXJhY3TDqXJpc3RpcXVlcyBzb3VyY2VcIixcblx0XHRuZWlnaGJvcmhvb2RTZXR0aW5nczogXCJQYXJhbcOodHJlcyBkZSB2b2lzaW5hZ2VcIixcblx0XHRzdGF0aXN0aWNzOiBcIlN0YXRpc3RpcXVlc1wiLFxuXHRcdGdhbW1hOiBcIkdhbW1hXCIsXG5cdFx0dmlld3NoZWRQYXJhbWV0ZXJzOiBcIlBhcmFtw6h0cmVzIGR1IGNoYW1wIGRlIHZpc2lvblwiLFxuXHRcdG9ic2VydmVyUGFyYW1ldGVyczogXCJQYXJhbcOodHJlcyBkdSBwb2ludCBkJ29ic2VydmF0aW9uXCIsXG5cdFx0aXJyZWd1bGFyRGF0YUludGVycG9sYXRpb246IFwiSW50ZXJwb2xhdGlvbiBkZXMgZG9ubsOpZXMgaXJyw6lndWxpw6hyZXNcIixcblx0XHRtb2RlbFN0YXRpc3RpY3M6IFwiU3RhdGlzdGlxdWVzIGR1IG1vZMOobGVcIixcblx0XHRhZ2dyZWdhdGlvbkRlZjogXCJEw6lmaW5pdGlvbiBkZSBs4oCZYWdyw6lnYXRpb25cIixcblx0XHRmaWx0ZXJCeUF0dHJpYnV0ZXM6IFwiRmlsdHJlciBwYXIgYXR0cmlidXRzXCIsXG5cdFx0cGVyY2VudGlsZU5hbWU6IFwiQ2VudGlsZVwiLFxuXHRcdHJhc3RlckluZm86IFwiSW5mb3JtYXRpb25zIHJhc3RlclwiLFxuXHRcdGV4dGVudDogXCLDiXRlbmR1ZVwiLFxuXHRcdHNwYXRpYWxSZWZlcmVuY2U6IFwiUsOpZsOpcmVuY2Ugc3BhdGlhbGVcIlxuXHR9LFxuXHRvdXRwdXRSYXN0ZXJIZWxwVGV4dHM6IHtcblx0XHRvdXRwdXROYW1lOiBcIjxwPk5vbSBkZSBsYSBjb3VjaGUgw6AgY3LDqWVyIGV0IGFqb3V0ZXIgw6AgbGEgY2FydGUuPC9wPlwiLFxuXHRcdHJlc3VsdFR5cGU6IFwiPHA+VHlwZSBkZSBzb3J0aWUgw6AgY3LDqWVyLiBMZXMgc29ydGllcyBwZXV2ZW50IMOqdHJlIGRlcyBjb3VjaGVzIGTigJlpbWFnZXJpZSB0dWlsw6llIG91IGRlcyBjb3VjaGVzIGTigJlpbWFnZXJpZSBkeW5hbWlxdWUuPC9wPlwiLFxuXHRcdHNhdmVSZXN1bHRJbjogXCI8cD5Ob20gZHUgZG9zc2llciBkZSA8Yj5NZXMgY29udGVudXM8L2I+IGRhbnMgbGVxdWVsIGxlIHLDqXN1bHRhdCBzZXJhIGVucmVnaXN0csOpLjwvcD5cIlxuXHR9LFxuXHRhbmFseXNpc0Vudmlyb25tZW50c0hlbHBUZXh0czoge1xuXHRcdGRlc2NyaXB0aW9uOiBcIjxwPlBhcmFtw6h0cmVzIGTigJllbnZpcm9ubmVtZW50IHBvdXIgbOKAmWFuYWx5c2UgZGFucyBNYXAgVmlld2VyLiA8L3A+XCIsXG5cdFx0b3V0U1I6IFwiPHA+U3DDqWNpZmllIGxlIHN5c3TDqG1lIGRlIGNvb3Jkb25uw6llcyBwb3VyIGzigJlhbmFseXNlIGV0IGxhIGNvdWNoZSBkZSByw6lzdWx0YXQuPC9wPlwiLFxuXHRcdGV4dGVudDogXCI8cD5TcMOpY2lmaWUgbGEgem9uZSDDoCB1dGlsaXNlciBwb3VyIGzigJlhbmFseXNlLjwvcD5cIixcblx0XHRzbmFwUmFzdGVyOiBcIjxwPkFqdXN0ZSBs4oCZw6l0ZW5kdWUgZGUgbGEgc29ydGllIGFmaW4gcXXigJllbGxlIGNvcnJlc3BvbmRlIMOgIGzigJlhbGlnbmVtZW50IGRlcyBjZWxsdWxlcyBkZSBsYSBjb3VjaGUgZGUgcmFzdGVyIGRlIGNhcHR1cmUgc3DDqWNpZmnDqWUuPC9wPlwiLFxuXHRcdGNlbGxTaXplOiBcIjxwPlNww6ljaWZpZSBsYSB0YWlsbGUgZGUgY2VsbHVsZSBvdSBsYSByw6lzb2x1dGlvbiDDoCB1dGlsaXNlciBwb3VyIGzigJlhbmFseXNlIGV0IHBvdXIgY3LDqWVyIGxhIGNvdWNoZSByYXN0ZXIgZW4gc29ydGllLjwvcD5cIixcblx0XHRtYXNrOiBcIjxwPlNww6ljaWZpZSB1bmUgY291Y2hlIGRlIG1hc3F1ZSBkYW5zIGxhcXVlbGxlIHNldWxlcyBsZXMgY2VsbHVsZXMgcXVpIHNlIHRyb3V2ZW50IGRhbnMgbGEgem9uZSBkZSBtYXNxdWUgc29udCB1dGlsaXPDqWVzIHBvdXIgbOKAmWFuYWx5c2UuPC9wPlwiLFxuXHRcdHJlc2FtcGxpbmdNZXRob2Q6IFwiPHA+SW5kaXF1ZSBjb21tZW50IGludGVycG9sZXIgbGVzIHZhbGV1cnMgZGUgcGl4ZWwgc2kgbGVzIHJhc3RlcnMgZW4gZW50csOpZSBldCBlbiBzb3J0aWUgbmUgY29ycmVzcG9uZGVudCBwYXMuPC9wPlwiXG5cdH0sXG5cdG1haW5HZW5TdHJpbmdzOiB7XG5cdFx0dW5zdXBwb3J0ZWREYXRhVHlwZTogXCJUeXBlIG5vbiBwcmlzIGVuIGNoYXJnZVwiLFxuXHRcdGN1cnJlbnRseVVuc3VwcG9ydGVkOiBcIiBVbiDDqWRpdGV1ciBwYXIgZMOpZmF1dCBwb3VyICR7bWlzc2luZ1R5cGV9IGVzdCBlbiBhdHRlbnRlLCBtYWlzIHNlcmEgYmllbnTDtHQgZGlzcG9uaWJsZS4gRXNwYWNlIHLDqXNlcnbDqSB0ZW1wb3JhaXJlIHBvdXIgbGEgem9uZSBkZSB0ZXh0ZSBkZXN0aW7DqWUgw6AgbGEgc3DDqWNpZmljYXRpb24gZGVzIGVudHLDqWVzIHNvdXMgZm9ybWUgZGUgY2hhw65uZXMuXCIsXG5cdFx0dW5zdXBwb3J0ZWRPdmVycmlkZVdhcm5pbmc6IFwiVW4gY29tcG9zYW50IGTigJnDqWRpdGV1ciBkZSByZW1wbGFjZW1lbnQgcHJvcG9zYW50IHVuZSBleHDDqXJpZW5jZSB1dGlsaXNhdGV1ciBhbcOpbGlvcsOpZSBwb3VyIGzigJl1dGlsaXNhdGlvbiBkZXMgcGFyYW3DqHRyZXMgc3VpdmFudHMgZXN0IGVuIGF0dGVudGUsIG1haXMgc2VyYSBiaWVudMO0dCBkaXNwb25pYmxlwqA6XCIsXG5cdFx0b3ZlcnJpZGVXaWRnZXRNaXNzaW5nOiBcIkNvbXBvc2FudCBk4oCZw6lkaXRldXIgZGUgcmVtcGxhY2VtZW50IG1hbnF1YW50LlwiLFxuXHRcdHVpSW5jb21wbGV0ZTogXCLDiWNoZWMgZGUgbOKAmWVudm9pIGRlIGxhIHTDomNoZS4gTGEgZm9uY3Rpb24gbmUgcGV1dCBwYXMgc+KAmWV4w6ljdXRlciBjYXIgY2VydGFpbnMgY2hhbXBzIG9ibGlnYXRvaXJlcyBzb250IGluY29tcGxldHMgb3UgbWFucXVhbnRzIGRhbnMgbOKAmWludGVyZmFjZSB1dGlsaXNhdGV1ci5cIixcblx0XHRjb3VudDogXCJOb21icmVcIixcblx0XHRzZWxlY3RWYXJpYWJsZXM6IFwiU8OpbGVjdGlvbm5lciBkZXMgdmFyaWFibGVzXCIsXG5cdFx0c2VsZWN0RmVhdHVyZTogXCJTw6lsZWN0aW9ubmVyIHVuZSBjb3VjaGUgZOKAmWVudGl0w6lzXCIsXG5cdFx0Z3JlYXRlclRoYW5FcnJvck1lc3NhZ2U6IFwiTGUgbm9tYnJlIGVuIGVudHLDqWUgZG9pdCDDqnRyZSBzdXDDqXJpZXVyIMOgwqAke21pbn1cIixcblx0XHRsZXNzZXJUaGFuRXJyb3JNZXNzYWdlOiBcIkxlIG5vbWJyZSBlbiBlbnRyw6llIGRvaXQgw6p0cmUgaW5mw6lyaWV1ciDDoMKgJHttYXh9XCIsXG5cdFx0Z3JlYXRlclRoYW5PckVxdWFsRXJyb3JNZXNzYWdlOiBcIkxlIG5vbWJyZSBlbiBlbnRyw6llIGRvaXQgw6p0cmUgc3Vww6lyaWV1ciBvdSDDqWdhbCDDoMKgJHttaW59XCIsXG5cdFx0bGVzc2VyVGhhbk9yRXF1YWxFcnJvck1lc3NhZ2U6IFwiTGUgbm9tYnJlIGVuIGVudHLDqWUgZG9pdCDDqnRyZSBpbmbDqXJpZXVyIG91IMOpZ2FsIMOgwqAke21heH1cIixcblx0XHRhbGxvd1NjYWxhcjogXCJTw6lsZWN0aW9ubmVyIHVuZSBjb3VjaGUgb3Ugc2Fpc2lyIHVuZSBjb25zdGFudGVcIixcblx0XHRzZWxlY3RGaWVsZDogXCJTw6lsZWN0aW9ubmVyIHVuIGNoYW1wXCIsXG5cdFx0cGFyYW1ldGVyUmVxdWlyZWQ6IFwiQ2UgcGFyYW3DqHRyZSBlc3Qgb2JsaWdhdG9pcmUuXCIsXG5cdFx0ZW50ZXJBVmFsdWU6IFwiU2Fpc2lyIHVuZSB2YWxldXIuLi5cIixcblx0XHRpbnZhbGlkSW5wdXQ6IFwiTGEgdmFsZXVyIHNhaXNpZSBu4oCZZXN0IHBhcyB2YWxpZGUuXCIsXG5cdFx0aXRlbU5vdEZvdW5kOiBcIkzigJnDqWzDqW1lbnQgbuKAmWV4aXN0ZSBwYXMgb3UgZXN0IGluYWNjZXNzaWJsZS5cIixcblx0XHRpdGVtUGVybWlzc2lvbkRlbmllZDogXCJWb3VzIG7igJnDqnRlcyBwYXMgYXV0b3Jpc8OpIMOgIGFjY8OpZGVyIMOgIGNldCDDqWzDqW1lbnQuXCIsXG5cdFx0bGF5ZXJOb3RBdmFpbGFibGU6IFwiw4ljaGVjIGR1IGNoYXJnZW1lbnQgZGUgbGEgY291Y2hlICR7bGF5ZXJOYW1lfS5cIixcblx0XHRtdWx0aXBsZUxheWVyc05vdEF2YWlsYWJsZTogXCLDiWNoZWMgZHUgY2hhcmdlbWVudCBkZSBsYSBjb3VjaGUgJHtsYXllck5hbWV9IGV0IGTigJlhdXRyZXMgY291Y2hlcy5cIixcblx0XHRsZWFybk1vcmVMYWJlbDogXCJFbiBzYXZvaXIgcGx1c1wiLFxuXHRcdGZpZWxkTm90QXZhaWxhYmxlOiBcIsOJY2hlYyBkdSBjaGFyZ2VtZW50IGR1IGNoYW1wLlwiLFxuXHRcdGFsbG93QW5hbHlzaXM6IFwiTOKAmWFuYWx5c2UgbuKAmWVzdCBwYXMgYXV0b3Jpc8OpZSBzdXIgbGUgc2VydmljZSBk4oCZaW1hZ2VyaWUuXCIsXG5cdFx0YWxsb3dBbmFseXNpc1JlYXNvbjogXCJVbmUgb3UgcGx1c2lldXJzIGNvdWNoZXMgZGUgbGEgY2FydGUgbmUgc29udCBwYXMgcsOpcGVydG9yacOpZXMgaWNpIGNhciBlbGxlcyBu4oCZYXV0b3Jpc2VudCBwYXMgbOKAmWFuYWx5c2UuXCIsXG5cdFx0bGVhcm5Nb3JlVGV4dDogXCJFbiBzYXZvaXIgcGx1c1wiLFxuXHRcdGF0TGVhc3RPbmVSYXN0ZXJJbnB1dDogXCJBdSBtb2lucyB1bmUgY291Y2hlIGVuIGVudHLDqWUgZG9pdCDDqnRyZSB1bmUgY291Y2hlIHJhc3Rlci5cIixcblx0XHRicm93c2VBbmFseXNpc0xheWVyczogXCJSZWNoZXJjaGVyIGRlcyBjb3VjaGVzXCIsXG5cdFx0YWN0aXZlTWFwVmlld0V4dGVudDogXCJVdGlsaXNlciBs4oCZw6l0ZW5kdWUgYWN0dWVsbGUgZGUgbGEgY2FydGVcIixcblx0XHRjaG9vc2VSYXN0ZXI6IFwiQ2hvaXNpciBsZSByYXN0ZXIgZGUgZMOpY291cGFnZVwiLFxuXHRcdGNob29zZUdlb21ldHJ5OiBcIkNob2lzaXIgbGEgZ8Opb23DqXRyaWUgZGUgZMOpY291cGFnZVwiLFxuXHRcdHJlc3VsdFR5cGU6IFwiVHlwZSBkZSByw6lzdWx0YXRcIixcblx0XHRzYXZlSW5Gb2xkZXI6IFwiRW5yZWdpc3RyZXIgZGFucyB1biBkb3NzaWVyXCIsXG5cdFx0b3V0cHV0TmFtZTogXCJOb20gZW4gc29ydGllXCIsXG5cdFx0b3V0cHV0TGF5ZXJUeXBlOiBcIlR5cGUgZGUgY291Y2hlIGVuIHNvcnRpZVwiLFxuXHRcdGR5bmFtaWNJbWFnZXJ5TGF5ZXI6IFwiQ291Y2hlIGTigJlpbWFnZXJpZSBkeW5hbWlxdWVcIixcblx0XHR0aWxlZEltYWdlcnlMYXllcjogXCJDb3VjaGUgZOKAmWltYWdlcmllIHR1aWzDqWVcIixcblx0XHRjdXN0b206IFwiUGVyc29ubmFsaXPDqVwiLFxuXHRcdGxvYWRpbmc6IFwiQ2hhcmdlbWVudC4uLlwiLFxuXHRcdGxheWVyTWlzc2luZzogXCJVbmUgb3UgcGx1c2lldXJzIGNvdWNoZXMgZGUgbGEgY2FydGUgbmUgc29udCBwYXMgcsOpcGVydG9yacOpZXMgaWNpIGNhciBlbGxlcyBu4oCZYXV0b3Jpc2VudCBwYXMgbOKAmWFuYWx5c2UuIEVuIHNhdm9pciBwbHVzLlwiLFxuXHRcdGJyb3dzZUNvb3JkaW5hdGVTeXN0ZW1zOiBcIlBhcmNvdXJpciBsZXMgc3lzdMOobWVzIGRlIGNvb3Jkb25uw6llc1wiLFxuXHRcdHVuYWJsZVRvUmVwb3B1bGF0ZU91dFNSOiBcIkltcG9zc2libGUgZGUgcmVuc2VpZ25lciBsZSBzeXN0w6htZSBkZSBjb29yZG9ubsOpZXMgZW4gc29ydGllLlwiLFxuXHRcdGRlZmF1bHRUaXRsZTogXCJQbHVzXCIsXG5cdFx0XCJBUkMgKGVxdWFsIGFyYy1zZWNvbmQpXCI6IFwiQVJDIChFcXVhbCBBcmMtU2Vjb25kKVwiLFxuXHRcdEFmcmljYTogXCJBZnJpcXVlXCIsXG5cdFx0QW50YXJjdGljYTogXCJBbnRhcmN0aXF1ZVwiLFxuXHRcdEFyZ2VudGluYTogXCJBcmdlbnRpbmVcIixcblx0XHRBc2lhOiBcIkFzaWVcIixcblx0XHRcIkFzdGVyb2lkIEJlbHRcIjogXCJDZWludHVyZSBk4oCZYXN0w6lyb8OvZGVzXCIsXG5cdFx0XCJBdGxhbnRpYyBPY2VhblwiOiBcIk9jw6lhbiBBdGxhbnRpcXVlXCIsXG5cdFx0QXVzdHJhbGlhOiBcIkF1c3RyYWxpZVwiLFxuXHRcdFwiQXVzdHJhbGlhIGFuZCBOZXcgWmVhbGFuZFwiOiBcIkF1c3RyYWxpZSBldCBOb3V2ZWxsZS1aw6lsYW5kZVwiLFxuXHRcdEF1c3RyaWE6IFwiQXV0cmljaGVcIixcblx0XHRcIkJMTSAoVVMgRmVldClcIjogXCJCTE0gKFBpZWRzIGFtw6lyaWNhaW5zKVwiLFxuXHRcdEJhbmdsYWRlc2g6IFwiQmFuZ2xhZGVzaFwiLFxuXHRcdFwiQmVpamluZyAxOTU0XCI6IFwiQmVpamluZ8KgMTk1NFwiLFxuXHRcdEJodXRhbjogXCJCaG91dGFuXCIsXG5cdFx0Q0dDUzIwMDA6IFwiQ0dDUzIwMDBcIixcblx0XHRDYW5hZGE6IFwiQ2FuYWRhXCIsXG5cdFx0Q2FyaWJiZWFuOiBcIkNhcmHDr2Jlc1wiLFxuXHRcdFwiQ2FyaWJiZWFuIFNlYVwiOiBcIk1lciBkZXMgQ2FyYcOvYmVzXCIsXG5cdFx0XCJDZW50cmFsIEFtZXJpY2FcIjogXCJBbcOpcmlxdWUgY2VudHJhbGVcIixcblx0XHRcIkNlbnRyYWwgYW5kIE5vcnRoIEFtZXJpY2FcIjogXCJBbcOpcmlxdWUgY2VudHJhbGUgZXQgZHUgTm9yZFwiLFxuXHRcdENvbG9tYmlhOiBcIkNvbG9tYmllXCIsXG5cdFx0Q29udGluZW50YWw6IFwiQ29udGluZW50YXV4XCIsXG5cdFx0XCJDb3VudHkgU3lzdGVtc1wiOiBcIlN5c3TDqG1lcyBkZSBjb210w6lzXCIsXG5cdFx0XCJEZW1vY3JhdGljIFJlcHVibGljIG9mIHRoZSBDb25nb1wiOiBcIlLDqXB1YmxpcXVlIGTDqW1vY3JhdGlxdWUgZHUgQ29uZ29cIixcblx0XHRcIkVQU0cgQXJjdGljXCI6IFwiRVBTRyBBcmN0aWNcIixcblx0XHRFYXJ0aDogXCJUZXJyZVwiLFxuXHRcdFwiRWxsaXBzb2lkYWwtYmFzZWRcIjogXCJFbGxpcHNvw69kZVwiLFxuXHRcdEV1cm9wZTogXCJFdXJvcGVcIixcblx0XHRGaW5sYW5kOiBcIkZpbmxhbmRlXCIsXG5cdFx0RnJhbmNlOiBcIkZyYW5jZVwiLFxuXHRcdFwiR1NLIDIwMTFcIjogXCJHU0vCoDIwMTFcIixcblx0XHRcIkdhdXNzIEtydWdlclwiOiBcIkdhdXNzLUtyw7xnZXJcIixcblx0XHRcIkdlb2dyYXBoaWMgQ29vcmRpbmF0ZSBTeXN0ZW1zXCI6IFwiU3lzdMOobWVzIGRlIGNvb3Jkb25uw6llcyBnw6lvZ3JhcGhpcXVlc1wiLFxuXHRcdEdlcm1hbnk6IFwiQWxsZW1hZ25lXCIsXG5cdFx0XCJHcmF2aXR5LXJlbGF0ZWRcIjogXCJHcmF2aXTDqVwiLFxuXHRcdFwiR3JlZW53aWNoLWJhc2VkXCI6IFwiR3JlZW53aWNoXCIsXG5cdFx0XCJIaWdod2F5cyBFbmdsYW5kXCI6IFwiSGlnaHdheXMgRW5nbGFuZFwiLFxuXHRcdElsbGlub2lzOiBcIklsbGlub2lzXCIsXG5cdFx0XCJJbmRpYW4gT2NlYW5cIjogXCJPY8OpYW4gSW5kaWVuXCIsXG5cdFx0XCJJbmRpYW4gU3ViY29udGluZW50XCI6IFwiU291cy1jb250aW5lbnQgaW5kaWVuXCIsXG5cdFx0SW5kaWFuYTogXCJJbmRpYW5hXCIsXG5cdFx0SW5kb25lc2lhOiBcIkluZG9uw6lzaWVcIixcblx0XHRJb3dhOiBcIklvd2FcIixcblx0XHRcIklyZWxhbmQgYW5kIFVuaXRlZCBLaW5nZG9tXCI6IFwiSXJsYW5kZSBldCBSb3lhdW1lLVVuaVwiLFxuXHRcdEl0YWx5OiBcIkl0YWxpZVwiLFxuXHRcdEphcGFuOiBcIkphcG9uXCIsXG5cdFx0SnVwaXRlcjogXCJKdXBpdGVyXCIsXG5cdFx0S2Fuc2FzOiBcIkthbnNhc1wiLFxuXHRcdFwiTGFzIFZlZ2FzXCI6IFwiTGFzIFZlZ2FzXCIsXG5cdFx0TGlieWE6IFwiTGlieWVcIixcblx0XHRNYWxheXNpYTogXCJNYWxhaXNpZVwiLFxuXHRcdFwiTWFsYXlzaWEgYW5kIFNpbmdhcG9yZVwiOiBcIk1hbGFpc2llIGV0IFNpbmdhcG91clwiLFxuXHRcdE1hcnM6IFwiTWFyc1wiLFxuXHRcdE1lcmN1cnk6IFwiTWVyY3VyZVwiLFxuXHRcdE1pbm5lc290YTogXCJNaW5uZXNvdGFcIixcblx0XHRNb250YW5hOiBcIk1vbnRhbmFcIixcblx0XHRcIk5BRCAxOTI3XCI6IFwiTkFEwqAxOTI3XCIsXG5cdFx0XCJOQUQgMTkyNyAoVVMgRmVldClcIjogXCJOQUTCoDE5MjcgKFBpZWRzIGFtw6lyaWNhaW5zKVwiLFxuXHRcdFwiTkFEIDE5ODNcIjogXCJOQUTCoDE5ODNcIixcblx0XHRcIk5BRCAxOTgzICgyMDExKVwiOiBcIk5BRMKgMTk4MyAoMjAxMSlcIixcblx0XHRcIk5BRCAxOTgzICgyMDExKSAoSW50bCBGZWV0KVwiOiBcIk5BRMKgMTk4MyAoMjAxMSkgKFBpZWRzIGludGVybmF0aW9uYXV4KVwiLFxuXHRcdFwiTkFEIDE5ODMgKDIwMTEpIChNZXRlcnMpXCI6IFwiTkFEwqAxOTgzICgyMDExKSAoTcOodHJlcylcIixcblx0XHRcIk5BRCAxOTgzICgyMDExKSAoVVMgRmVldClcIjogXCJOQUTCoDE5ODMgKDIwMTEpIChQaWVkcyBhbcOpcmljYWlucylcIixcblx0XHRcIk5BRCAxOTgzIChDT1JTOTYpIChJbnRsIEZlZXQpXCI6IFwiTkFEwqAxOTgzIChDT1JTOTYpIChQaWVkcyBpbnRlcm5hdGlvbmF1eClcIixcblx0XHRcIk5BRCAxOTgzIChDT1JTOTYpIChNZXRlcnMpXCI6IFwiTkFEwqAxOTgzIChDT1JTOTYpIChNw6h0cmVzKVwiLFxuXHRcdFwiTkFEIDE5ODMgKENPUlM5NikgKFVTIEZlZXQpXCI6IFwiTkFEwqAxOTgzIChDT1JTOTYpIChQaWVkcyBhbcOpcmljYWlucylcIixcblx0XHRcIk5BRCAxOTgzIChJbnRsIEZlZXQpXCI6IFwiTkFEwqAxOTgzIChQaWVkcyBpbnRlcm5hdGlvbmF1eClcIixcblx0XHRcIk5BRCAxOTgzIChNZXRlcnMpXCI6IFwiTkFEwqAxOTgzIChNw6h0cmVzKVwiLFxuXHRcdFwiTkFEIDE5ODMgKFBBMTEpIChNZXRlcnMpXCI6IFwiTkFEwqAxOTgzIChQQTExKSAoTcOodHJlcylcIixcblx0XHRcIk5BRCAxOTgzIChQQTExKSAoVVMgRmVldClcIjogXCJOQUTCoDE5ODMgKFBBMTEpIChQaWVkcyBhbcOpcmljYWlucylcIixcblx0XHRcIk5BRCAxOTgzIChVUyBGZWV0KVwiOiBcIk5BRMKgMTk4MyAoUGllZHMgYW3DqXJpY2FpbnMpXCIsXG5cdFx0XCJOQUQgMTk4MyBIQVJOIChJbnRsIEZlZXQpXCI6IFwiTkFEwqAxOTgzIEhBUk4gKFBpZWRzIGludGVybmF0aW9uYXV4KVwiLFxuXHRcdFwiTkFEIDE5ODMgSEFSTiAoTWV0ZXJzKVwiOiBcIk5BRMKgMTk4MyBIQVJOIChNw6h0cmVzKVwiLFxuXHRcdFwiTkFEIDE5ODMgSEFSTiAoVVMgRmVldClcIjogXCJOQUTCoDE5ODMgSEFSTiAoUGllZHMgYW3DqXJpY2FpbnMpXCIsXG5cdFx0XCJOQUQgMTk4MyBOU1JTMjAwNyAoSW50bCBGZWV0KVwiOiBcIk5BRMKgMTk4MyBOU1JTMjAwNyAoUGllZHMgaW50ZXJuYXRpb25hdXgpXCIsXG5cdFx0XCJOQUQgMTk4MyBOU1JTMjAwNyAoTWV0ZXJzKVwiOiBcIk5BRMKgMTk4MyBOU1JTMjAwNyAoTcOodHJlcylcIixcblx0XHRcIk5BRCAxOTgzIE5TUlMyMDA3IChVUyBGZWV0KVwiOiBcIk5BRMKgMTk4MyBOU1JTMjAwNyAoUGllZHMgYW3DqXJpY2FpbnMpXCIsXG5cdFx0XCJOYXRpb25hbCBHcmlkc1wiOiBcIkdyaWxsZXMgbmF0aW9uYWxlc1wiLFxuXHRcdE5hdmFqbzogXCJOYXZham9cIixcblx0XHROZXB0dW5lOiBcIk5lcHR1bmVcIixcblx0XHRcIk5ldyBCZWlqaW5nXCI6IFwiTmV3IEJlaWppbmdcIixcblx0XHRcIk5ldyBaZWFsYW5kXCI6IFwiTm91dmVsbGUtWsOpbGFuZGVcIixcblx0XHRcIk5vcnRoIEFtZXJpY2FcIjogXCJBbcOpcmlxdWUgZHUgTm9yZFwiLFxuXHRcdFwiTm9ydGhlcm4gSGVtaXNwaGVyZVwiOiBcIkjDqW1pc3Bow6hyZSBOb3JkXCIsXG5cdFx0Tm9yd2F5OiBcIk5vcnbDqGdlXCIsXG5cdFx0T2NlYW5zOiBcIk9jw6lhbnNcIixcblx0XHRPcmVnb246IFwiT3JlZ29uXCIsXG5cdFx0XCJPdGhlciBHQ1NcIjogXCJBdXRyZSBHQ1NcIixcblx0XHRcIlBhY2lmaWMgT2NlYW5cIjogXCJPY8OpYW4gUGFjaWZpcXVlXCIsXG5cdFx0UGx1dG86IFwiUGx1dG9uXCIsXG5cdFx0UG9sYXI6IFwiUG9sYWlyZXNcIixcblx0XHRQb3J0dWdhbDogXCJQb3J0dWdhbFwiLFxuXHRcdFwiUHJvamVjdGVkIENvb3JkaW5hdGUgU3lzdGVtc1wiOiBcIlN5c3TDqG1lcyBkZSBjb29yZG9ubsOpZXMgcHJvamV0w6llc1wiLFxuXHRcdFwiUHVsa292byAxOTQyXCI6IFwiUHVsa292b8KgMTk0MlwiLFxuXHRcdFwiUHVsa292byAxOTk1XCI6IFwiUHVsa292b8KgMTk5NVwiLFxuXHRcdFJlcGxhY2VkOiBcIlJlbXBsYWPDqXNcIixcblx0XHRcIlNBRCAxOTY5XCI6IFwiU0FEwqAxOTY5XCIsXG5cdFx0U0lSR0FTOiBcIlNJUkdBU1wiLFxuXHRcdFwiU0lSR0FTIDIwMDBcIjogXCJTSVJHQVPCoDIwMDBcIixcblx0XHRTYXR1cm46IFwiU2F0dXJuZVwiLFxuXHRcdFwiU29sYXIgU3lzdGVtXCI6IFwiU3lzdMOobWUgc29sYWlyZVwiLFxuXHRcdFwiU291dGggQWZyaWNhXCI6IFwiQWZyaXF1ZSBkdSBTdWRcIixcblx0XHRcIlNvdXRoIEFtZXJpY2FcIjogXCJBbcOpcmlxdWUgZHUgU3VkXCIsXG5cdFx0XCJTb3V0aCBLb3JlYVwiOiBcIkNvcsOpZSBkdSBTdWRcIixcblx0XHRcIlNvdXRoZXJuIEhlbWlzcGhlcmVcIjogXCJIw6ltaXNwaMOocmUgU3VkXCIsXG5cdFx0XCJTcGhlcm9pZC1iYXNlZFwiOiBcIkJhc8OpcyBzdXIgdW4gc3Bow6lyb8OvZGVcIixcblx0XHRcIlN0YXRlIFBsYW5lXCI6IFwiU3RhdGUgUGxhbmVcIixcblx0XHRcIlN0YXRlIFN5c3RlbXNcIjogXCJTeXN0w6htZXMgZOKAmcOJdGF0XCIsXG5cdFx0U3dlZGVuOiBcIlN1w6hkZVwiLFxuXHRcdFwiU3dpdHplcmxhbmQgYW5kIExpZWNodGVuc3RlaW5cIjogXCJTdWlzc2UgZXQgTGllY2h0ZW5zdGVpblwiLFxuXHRcdFRleGFzOiBcIlRleGFzXCIsXG5cdFx0VHJpYmFsOiBcIlRyaWJhdXhcIixcblx0XHRUdXJrZXk6IFwiVHVycXVpZVwiLFxuXHRcdFwiVVMgRmVldFwiOiBcIlBpZWRzIGFtw6lyaWNhaW5zXCIsXG5cdFx0XCJVU0EgYW5kIHRlcnJpdG9yaWVzXCI6IFwiw4l0YXRzLVVuaXMgZXQgdGVycml0b2lyZXNcIixcblx0XHRVVE06IFwiVVRNXCIsXG5cdFx0VWtyYWluZTogXCJVa3JhaW5lXCIsXG5cdFx0XCJVbmtub3duIEhlaWdodCBTeXN0ZW1zXCI6IFwiU3lzdMOobWUgYWx0aW3DqXRyaXF1ZSBpbmNvbm51XCIsXG5cdFx0VXJhbnVzOiBcIlVyYW51c1wiLFxuXHRcdFZlbnVzOiBcIlbDqW51c1wiLFxuXHRcdFwiVmVydGljYWwgQ29vcmRpbmF0ZSBTeXN0ZW1zXCI6IFwiU3lzdMOobWVzIGRlIGNvb3Jkb25uw6llcyB2ZXJ0aWNhbGVzXCIsXG5cdFx0VmlldG5hbTogXCJWaWV0bmFtXCIsXG5cdFx0XCJXR1MgMTk3MlwiOiBcIldHU8KgMTk3MlwiLFxuXHRcdFwiV0dTIDE5ODRcIjogXCJXR1PCoDE5ODRcIixcblx0XHRXaXNjb25zaW46IFwiV2lzY29uc2luXCIsXG5cdFx0XCJXaXNjb25zaW4gQ1JTXCI6IFwiV2lzY29uc2luIENSU1wiLFxuXHRcdFdvcmxkOiBcIk1vbmRlXCIsXG5cdFx0XCJXb3JsZCAoU3BoZXJlLWJhc2VkKVwiOiBcIk1vbmRlIChiYXPDqXMgc3VyIHVuZSBzcGjDqHJlKVwiLFxuXHRcdFd5b21pbmc6IFwiV3lvbWluZ1wiLFxuXHRcdFwiWGlhbiAxOTgwXCI6IFwiWGlhbsKgMTk4MFwiLFxuXHRcdGRvbmU6IFwiVGVybWluw6lcIixcblx0XHRub1Jlc3VsdHM6IFwiQXVjdW4gcsOpc3VsdGF0IHRyb3V2w6lcIixcblx0XHRzZWFyY2hQbGFjZWhvbGRlcjogXCJOb20gb3UgV0tJRFwiLFxuXHRcdGJyb3dzZVRlbXBsYXRlOiBcIlBhcmNvdXJpciBsZXMgbW9kw6hsZXMgZGUgZm9uY3Rpb24gcmFzdGVyXCIsXG5cdFx0c2F2ZVRlbXBsYXRlOiBcIkVucmVnaXN0cmVyIGxlIG1vZMOobGUgZGUgZm9uY3Rpb24gcmFzdGVyXCIsXG5cdFx0cHJldmlldzogXCJBcGVyw6d1XCIsXG5cdFx0cHJldmlld0Rlc2NyaXB0aW9uOiBcIkFmZmljaGV6IHVuIGFwZXLDp3UgZHUgcsOpc3VsdGF0IGF2YW50IGTigJlleMOpY3V0ZXIgbOKAmWFuYWx5c2UuXCIsXG5cdFx0c2hvd1ByZXZpZXc6IFwiQWZmaWNoZXIgdW4gYXBlcsOndVwiLFxuXHRcdHByZXZpZXdMYXllcjogXCJDb3VjaGUgZOKAmWFwZXLDp3XCoCR7bnVtYmVyfVwiLFxuXHRcdG5ld1ByZXZpZXc6IFwiTm91dmVsIGFwZXLDp3VcIixcblx0XHRwcmV2aWV3UG9wdXA6IFwiQWN0aXZlciBs4oCZYWZmaWNoYWdlIGTigJl1biBhcGVyw6d1IGRlcyByw6lzdWx0YXRzIGTigJlhbmFseXNlIGVuIGZvbmN0aW9uIGRlcyBwYXJhbcOodHJlcyBlbiBlbnRyw6llLlwiLFxuXHRcdHVwZGF0ZVByZXZpZXdMYXllcjogXCJNZXR0cmUgw6Agam91ciBsYSBjb3VjaGUgZOKAmWFwZXLDp3Ugc8OpbGVjdGlvbm7DqWVcIixcblx0XHRjcmVhdGVQcmV2aWV3TGF5ZXI6IFwiQ3LDqWVyIHVuZSBub3V2ZWxsZSBjb3VjaGUgZOKAmWFwZXLDp3VcIixcblx0XHRtYXhpbXVtUHJldmlld0FsbG93ZWQ6IFwiTm9tYnJlIG1heGltYWwgZGUgY291Y2hlcyBk4oCZYXBlcsOndSBhdXRvcmlzw6nCoDogJHttYXhDb3VudH1cIixcblx0XHRwcmV2aWV3RmFpbHVyZTogXCJDZXR0ZSBjb3VjaGUgZOKAmWFwZXLDp3UgbuKAmWVzdCBwYXMgZGlzcG9uaWJsZS4gVsOpcmlmaWV6IGxlcyBwYXJhbcOodHJlcyBlbiBlbnRyw6llIGV0IHByb2PDqWRleiDDoCB1bmUgbm91dmVsbGUgbWlzZSDDoCBqb3VyIGRlIGNldHRlIGNvdWNoZSBk4oCZYXBlcsOndS5cIixcblx0XHRoZWFkZXI6IFwiU8OpbGVjdGlvbm5lciB1biDDqWzDqW1lbnRcIixcblx0XHRjb250ZW50OiBcIkNlcnRhaW5lcyBtb2RpZmljYXRpb25zIG5lIHNvbnQgcGFzIGVucmVnaXN0csOpZXMgZGFuc8KgJHtyZnRUaXRsZX0uIFNpIHZvdXMgcmVjb21tZW5jZXogYXZlYyB1biBub3V2ZWF1IG1vZMOobGUsIGNlcyBtb2RpZmljYXRpb25zIHNlcm9udCBwZXJkdWVzLlwiLFxuXHRcdGRvbnRTYXZlOiBcIk5lIHBhcyBlbnJlZ2lzdHJlclwiLFxuXHRcdFwiY29udGludWVcIjogXCJDb250aW51ZXJcIixcblx0XHRzdHJldGNoOiBcIkFqdXN0ZXIgw6AgbGEgZmVuw6p0cmVcIixcblx0XHRwYW46IFwiRMOpcGxhY2VyXCIsXG5cdFx0bmV3VGVtcGxhdGU6IFwiQ3LDqWVyIHVuIG5vdXZlYXUgbW9kw6hsZVwiLFxuXHRcdG9wZW5UZW1wbGF0ZTogXCJPdXZyaXIgdW4gbW9kw6hsZVwiLFxuXHRcdGFkZEZ1bmN0aW9uOiBcIkFqb3V0ZXIgZGVzIGZvbmN0aW9ucyByYXN0ZXJcIixcblx0XHRhZGRDb25zdGFudDogXCJBam91dGVyIHVuZSBjb25zdGFudGVcIixcblx0XHRhZGRSYXN0ZXI6IFwiQWpvdXRlciB1bmUgdmFyaWFibGUgcmFzdGVyXCIsXG5cdFx0bW92ZTogXCJEw6lwbGFjZXJcIixcblx0XHR6b29tOiBcIlpvb21cIixcblx0XHRzYXZlQXM6IFwiRW5yZWdpc3RyZXIgc291c1wiLFxuXHRcdGNsZWFyOiBcIkVmZmFjZXJcIixcblx0XHRhZGRSYXN0ZXJGdW5jdGlvblRpdGxlOiBcIkFqb3V0ZXIgZGVzIGZvbmN0aW9ucyByYXN0ZXJcIixcblx0XHR0ZW1wbGF0ZVByb3BlcnRpZXNUaXRsZTogXCJQcm9wcmnDqXTDqXMgZHUgbW9kw6hsZVwiLFxuXHRcdGJyb3dzZVJGVDogXCJQYXJjb3VyaXIgbGVzIG1vZMOobGVzIGRlIGZvbmN0aW9uIHJhc3RlclwiLFxuXHRcdGRlZmF1bHRUb29sRGVzY3JpcHRpb246IFwiT3V0aWwgZOKAmWFuYWx5c2UgJHt0b29sVGl0bGV9LlwiLFxuXHRcdG9wZW5Ub29sVGV4dDogXCJPdXZyaXIgbOKAmW91dGlsXCIsXG5cdFx0dG9vbERyb3Bkb3duVGV4dDogXCJNZW51IGTDqXJvdWxhbnQgZGUgbOKAmW91dGlsXCIsXG5cdFx0YWRkVG9NYXA6IFwiQ29uZmlybWVyIGV0IGFqb3V0ZXIgw6AgbGEgY2FydGVcIixcblx0XHRjb25maXJtOiBcIkNvbmZpcm1lclwiLFxuXHRcdHNlbGVjdDogXCJTw6lsZWN0aW9ubmVyXCIsXG5cdFx0c2VsZWN0VGFzazogXCJTw6lsZWN0aW9ubmVyIHVuZSB0w6JjaGVcIixcblx0XHR1bnN1cHBvcnRlZExheWVyOiBcIkNlIHBhcmFtw6h0cmUgbmUgcHJlbmQgcGFzIGVuIGNoYXJnZSBsZXMgY291Y2hlcyBzdWl2YW50ZXPCoDogJHtsYXllck5hbWV9LlwiLFxuXHRcdHZpZXdEZXRhaWxzOiBcIkFmZmljaGVyIGxlcyBkw6l0YWlscyBjb21wbGV0cyBkZSBs4oCZw6lsw6ltZW50XCIsXG5cdFx0cmVuYW1lOiBcIlJlbm9tbWVyXCIsXG5cdFx0ZHVwbGljYXRlOiBcIkR1cGxpcXVlclwiLFxuXHRcdGxhdW5jaDogXCJPdXZyaXIgcG91ciBleMOpY3V0ZXJcIixcblx0XHR0ZW1wbGF0ZUVkaXRvcjogXCLDiWRpdGV1ciBkZSBtb2TDqGxlXCIsXG5cdFx0Y3JlYXRlSXRlbTogXCJFbnJlZ2lzdHJlciBsZSBtb2TDqGxlIGRlIGZvbmN0aW9uIHJhc3RlclwiLFxuXHRcdGFjdGlvbkxhYmVsOiBcIkZpbHRyZXJcIixcblx0XHRmaWx0ZXJQb3BvdmVySGVhZGluZzogXCJGaWx0cmVyIGxlcyBmb25jdGlvbnNcIixcblx0XHRkZWZhdWx0U2VhcmNoUGxhY2Vob2xkZXI6IFwiUmVjaGVyY2hlciBwYXIgbm9tXCIsXG5cdFx0c2V0dGluZ3M6IFwiUGFyYW3DqHRyZXNcIixcblx0XHRzdW1tYXJ5OiBcIlLDqXN1bcOpXCIsXG5cdFx0ZGVmaW5pdGlvblF1ZXJ5OiBcIkVuc2VtYmxlIGRlIGTDqWZpbml0aW9uXCIsXG5cdFx0bWF0Y2hWYXJpYWJsZXM6IFwiQXBwYXJpZXIgbGVzIHZhcmlhYmxlc1wiLFxuXHRcdHVuaW9uRGltZW5zaW9uOiBcIlVuaW9uIGRlcyBkaW1lbnNpb25zXCIsXG5cdFx0bmFtZUVkaXRvclBsYWNlaG9sZGVyOiBcIlNhaXNpciB1biB0aXRyZVwiLFxuXHRcdHN1bW1hcnlFZGl0b3JQbGFjZWhvbGRlcjogXCJTYWlzaXIgdW5lIGJyw6h2ZSBkZXNjcmlwdGlvblwiLFxuXHRcdGRlZmluaXRpb25RdWVyeVBsYWNlaG9sZGVyOiBcIlNhaXNpci4uLlwiLFxuXHRcdHVwbG9hZDogXCJDaGFyZ2VyXCIsXG5cdFx0Y2hvb3NlSW1hZ2U6IFwiQ2xpcXVlciBwb3VyIGNob2lzaXIgdW4gZmljaGllclwiLFxuXHRcdHVwZGF0ZTogXCJNZXR0cmUgw6Agam91clwiLFxuXHRcdHRodW1ibmFpbEVycm9yczoge1xuXHRcdFx0d3JvbmdJbWFnZVR5cGU6IFwiVHlwZSBk4oCZaW1hZ2Ugc8OpbGVjdGlvbm7DqSBpbmNvcnJlY3RcIixcblx0XHRcdG5vdEF2YWlsYWJsZTogXCJNaW5pYXR1cmUgbm9uIGRpc3BvbmlibGVcIixcblx0XHRcdGxvYWRFcnJvcjogXCJJbXBvc3NpYmxlIGRlIGNoYXJnZXIgbOKAmWltYWdlXCIsXG5cdFx0XHRjaG9vc2VGaWxlOiBcIkNsaXF1ZXIgcG91ciBjaG9pc2lyIHVuIGZpY2hpZXJcIlxuXHRcdH1cblx0fVxufTtcbmNvbnN0IGNvcHkgPSBcIkNvcGllclwiO1xuY29uc3Qgc2F2ZSA9IFwiRW5yZWdpc3RyZXJcIjtcbmNvbnN0IHRpdGxlID0gXCJUaXRyZVwiO1xuY29uc3QgZm9sZGVyID0gXCJEb3NzaWVyXCI7XG5jb25zdCB0YWdzID0gXCJCYWxpc2VzXCI7XG5jb25zdCBzYXZpbmdNZXNzYWdlID0gXCJFbnJlZ2lzdHJlbWVudCBkZSBsJ8OpbMOpbWVudCBkYW5zXCI7XG5jb25zdCBzaGFyZVdpdGggPSBcIlBhcnRhZ2VyIGF2ZWNcIjtcbmNvbnN0IHNoYXJlID0gXCJQYXJ0YWdlclwiO1xuY29uc3Qgc2V0U2hhcmluZ0xldmVsID0gXCJEw6lmaW5pciBsZSBuaXZlYXUgZGUgcGFydGFnZVwiO1xuY29uc3Qgc2V0R3JvdXBTaGFyaW5nID0gXCJDb25maWd1cmVyIGxlIHBhcnRhZ2UgZGUgZ3JvdXBlXCI7XG5jb25zdCBvd25lciA9IFwiUHJvcHJpw6l0YWlyZVwiO1xuY29uc3Qgb3JnYW5pemF0aW9uID0gXCJPcmdhbmlzYXRpb25cIjtcbmNvbnN0IGV2ZXJ5b25lID0gXCJUb3V0IGxlIG1vbmRlIChwdWJsaWMpXCI7XG5jb25zdCBncm91cHMgPSBcIkdyb3VwZXMgOlwiO1xuY29uc3QgdHlwZSA9IFwiVHlwZVwiO1xuY29uc3QgbW9zYWljID0gXCJNb3Nhw69xdWVcIjtcbmNvbnN0IGl0ZW1Hcm91cCA9IFwiR3JvdXBlIGTigJnDqWzDqW1lbnRzXCI7XG5jb25zdCBpdGVtID0gXCJFbMOpbWVudFwiO1xuY29uc3QgZGVmaW5pdGlvblF1ZXJ5ID0gXCJFbnNlbWJsZSBkZSBkw6lmaW5pdGlvblwiO1xuY29uc3QgZ3JvdXBJdGVtc0J5ID0gXCJHcm91cGVyIGxlcyDDqWzDqW1lbnRzIHBhclwiO1xuY29uc3QgZ3JvdXBGaWVsZE5hbWUgPSBcIk5vbSBkdSBjaGFtcCBkZSBncm91cGVcIjtcbmNvbnN0IHRhZ0ZpZWxkTmFtZSA9IFwiTm9tIGR1IGNoYW1wIGRlIGJhbGlzZVwiO1xuY29uc3Qgbm9UaXRsZVRhZ0Vycm9yTXNnID0gXCJWb3VzIGRldmV6IGF0dHJpYnVlciB1biB0aXRyZSDDoCB2b3RyZSDDqWzDqW1lbnQgZXQgZGVzIGJhbGlzZXMgcG91ciBxdWUgbGVzIHJlY2hlcmNoZXMgcGVybWV0dGVudCBkZSB0cm91dmVyIGxhIGNhcnRlLlwiO1xuY29uc3Qgbm9UaXRsZUVycm9yTXNnID0gXCJWb3VzIGRldmV6IGZvdXJuaXIgdW4gdGl0cmUgcG91ciB2b3RyZSDDqWzDqW1lbnQuXCI7XG5jb25zdCBub1RhZ0Vycm9yTXNnID0gXCJWb3VzIGRldmV6IGZvdXJuaXIgYXUgbW9pbnMgdW5lIGJhbGlzZSBwb3VyIGFpZGVyIGxlcyB1dGlsaXNhdGV1cnMgw6AgdHJvdXZlciB2b3RyZSDDqWzDqW1lbnQgYXUgbW95ZW4gZGUgcmVjaGVyY2hlcy5cIjtcbmNvbnN0IGVycm9yID0gXCJFcnJldXJcIjtcbmNvbnN0IHdhcm5pbmcgPSBcIkF2ZXJ0aXNzZW1lbnRcIjtcbmNvbnN0IHN1Y2Nlc3MgPSBcIk9ww6lyYXRpb24gcsOpdXNzaWVcIjtcbmNvbnN0IGRldGFpbHMgPSBcIkTDqXRhaWxzIDpcIjtcbmNvbnN0IHRyeUFnYWluID0gXCJSw6llc3NheWVyXCI7XG5jb25zdCB0b29sTW9kZWxlciA9IHtcblx0c2F2ZTogXCJFbnJlZ2lzdHJlclwiLFxuXHRlZGl0UHJvcGVydGllczogXCJNZXR0cmUgw6Agam91ciBsZXMgcHJvcHJpw6l0w6lzXCIsXG5cdHNhdmVBczogXCJFbnJlZ2lzdHJlciBzb3VzXCIsXG5cdHNhdmluZ05vdGlmaWNhdGlvbjogXCJFbnJlZ2lzdHJlbWVudCBkZXMgbW9kaWZpY2F0aW9ucyBhcHBvcnTDqWVzIMOgIGzigJnDqWzDqW1lbnQuLi5cIixcblx0c2F2aW5nVGl0bGU6IFwiRW5yZWdpc3RyZW1lbnRcIixcblx0c2F2ZUZhaWxlZE1lc3NhZ2U6IFwiTCdlbnJlZ2lzdHJlbWVudCBkZXMgbW9kaWZpY2F0aW9ucyBhIMOpY2hvdcOpLlwiLFxuXHRzYXZlV2l0aEVycm9yc01lc3NhZ2U6IFwiTGVzIG1vZGlmaWNhdGlvbnMgb250IMOpdMOpIGVucmVnaXN0csOpZXMgYXZlYyBsZXMgZXJyZXVycyBzdWl2YW50ZXMuXCIsXG5cdHZpZXdJdGVtTWVzc2FnZTogXCJBZmZpY2hlciBs4oCZw6lsw6ltZW50IGVucmVnaXN0csOpXCIsXG5cdGhlcmU6IFwiaWNpLlwiLFxuXHRpdGVtQ3JlYXRlZE1lc3NhZ2U6IFwiTGUgbm91dmVsIMOpbMOpbWVudCBhIMOpdMOpIGNyw6nDqS5cIixcblx0Y2xpY2tUb1ZpZXdJdGVtTWVzc2FnZTogXCJDbGlxdWV6IHN1ciBPSyBwb3VyIGFmZmljaGVyIGxhIHBhZ2UgZGVzIGTDqXRhaWxzIGRlIGzigJnDqWzDqW1lbnQgb3UgY2xpcXVleiBzdXIgQW5udWxlciBwb3VyIGNvbnRpbnVlci5cIixcblx0cmVhZGluZ0ZhaWxlZDogXCLDiWNoZWMgZHUgY2hhcmdlbWVudCBkdSBtb2TDqGxlIGRlIGZvbmN0aW9uIHJhc3RlciBzw6lsZWN0aW9ubsOpLlwiLFxuXHRmYWlsZWRUb0xvYWRYTUw6IFwiw4ljaGVjIGR1IGNoYXJnZW1lbnQgZHUgbW9kw6hsZSBkZSBmb25jdGlvbiByYXN0ZXIgc8OpbGVjdGlvbm7DqSBhdSBmb3JtYXQgWE1MLlwiLFxuXHRsZWFybk1vcmU6IFwiRW4gc2F2b2lyIHBsdXNcIixcblx0b3ZlcndyaXRlVGl0bGU6IFwiQ29uZmlybWVyIGxlIHJlbXBsYWNlbWVudFwiLFxuXHRvdmVyd3JpdGVNZXNzYWdlOiBcIlNvdWhhaXRlei12b3VzIHJlbXBsYWNlciBs4oCZw6lsw6ltZW50IGV4aXN0YW50wqA/XCIsXG5cdG92ZXJ3cml0ZVN1Y2Nlc3NNZXNzYWdlOiBcIkzigJnDqWzDqW1lbnQgYSDDqXTDqSBtaXMgw6Agam91ci5cIlxufTtcbmNvbnN0IHRvb2xFZGl0b3IgPSB7XG5cdHJ1bjogXCJFeMOpY3V0ZXJcIixcblx0c2F2ZTogXCJFbnJlZ2lzdHJlclwiLFxuXHRkZWxldGVTZWxlY3RlZDogXCJTdXBwcmltZXIgbGVzIMOpbMOpbWVudHMgc8OpbGVjdGlvbm7DqXNcIixcblx0YWRkUmFzdGVyOiBcIkFqb3V0ZXIgdW4gcmFzdGVyXCIsXG5cdGFkZFNjYWxhcjogXCJBam91dGVyIHVuZSB2YWxldXIgc2NhbGFpcmVcIixcblx0bGF5b3V0OiBcIk1pc2UgZW4gcGFnZSBhdXRvbWF0aXF1ZVwiLFxuXHRlcnJvclRpdGxlOiBcIkVycmV1clwiLFxuXHRpbnZhbGlkVG9vbE1lc3NhZ2U6IFwiTGUgbW9kw6hsZSBkZSBmb25jdGlvbiByYXN0ZXIgbuKAmWVzdCBwYXMgdmFsaWRlLlwiLFxuXHRvdXQ6IFwiRGVob3JzXCIsXG5cdHpvb21JbjogXCJab29tIGF2YW50XCIsXG5cdHpvb21PdXQ6IFwiWm9vbSBhcnJpw6hyZVwiLFxuXHR6b29tVG9GaXQ6IFwiQWp1c3RlciDDoCBsYSBmZW7DqnRyZVwiLFxuXHRwYW5PbjogXCJBY3RpdmVyIGxlIG1vZGUgZGUgZMOpcGxhY2VtZW50XCIsXG5cdHBhbk9mZjogXCJEw6lzYWN0aXZlciBsZSBtb2RlIGRlIGTDqXBsYWNlbWVudFwiLFxuXHRkZWZhdWx0TW9kZWxOYW1lOiBcIk1vZMOobGUgZOKAmW91dGlsXCIsXG5cdGRlZmF1bHRSYXN0ZXJOYW1lOiBcIlJhc3RlclwiXG59O1xuY29uc3QgdG9vbERldGFpbHNFZGl0b3IgPSB7XG5cdGRlZmF1bHRUb29sTmFtZTogXCJNb2TDqGxlIGRlIGZvbmN0aW9uIHJhc3RlclwiLFxuXHRkZWZhdWx0VG9vbERlc2NyaXB0aW9uOiBcIkFqb3V0ZXogdW4gYnJlZiByw6lzdW3DqSBkZSBsYSBmb25jdGlvbiByYXN0ZXIuXCIsXG5cdGRlZmF1bHRIZWxwVGV4dDogXCJDbGlxdWV6IHN1ciBs4oCZaWPDtG5lIGTigJlhaWRlIHBvdXIgbWV0dHJlIMOgIGpvdXIgbGUgdGV4dGUgZCdhaWRlXCIsXG5cdGVkaXRIZWxwVGl0bGU6IFwiQWlkZSBwb3VyIGxhIG1pc2Ugw6Agam91clwiLFxuXHRzYXZlTGFiZWw6IFwiRW5yZWdpc3RyZXJcIixcblx0Y2FuY2VsTGFiZWw6IFwiQW5udWxlclwiLFxuXHR0aHVtYm5haWw6IHtcblx0XHR3cm9uZ0ltYWdlVHlwZTogXCJUeXBlIGTigJlpbWFnZSBzw6lsZWN0aW9ubsOpIGluY29ycmVjdFwiLFxuXHRcdG5vdEF2YWlsYWJsZTogXCJNaW5pYXR1cmUgaW5kaXNwb25pYmxlXCIsXG5cdFx0bG9hZEVycm9yOiBcIkltcG9zc2libGUgZGUgY2hhcmdlciBs4oCZaW1hZ2VcIixcblx0XHRjaG9vc2VGaWxlOiBcIkNsaXF1ZXogcG91ciBzw6lsZWN0aW9ubmVyIHVuIGZpY2hpZXJcIlxuXHR9XG59O1xuY29uc3Qgc2F2ZVV0aWxzID0ge1xuXHR0aHVtYm5haWw6IFwiTWluaWF0dXJlXCIsXG5cdHNoYXJpbmc6IFwiUGFydGFnZVwiXG59O1xuY29uc3QgY2xvc2UgPSBcIkZlcm1lclwiO1xuY29uc3QgdW5zYXZlZFdhcm5pbmdFeGlzdGluZyA9IFwiU291aGFpdGV6LXZvdXMgZW5yZWdpc3RyZXIgbGVzIG1vZGlmaWNhdGlvbnMgYXBwb3J0w6llcyDDoCBs4oCZw6lsw6ltZW50IDxiPiR7aXRlbVRpdGxlfTwvYj4gP1wiO1xuY29uc3QgdW5zYXZlZFdhcm5pbmdOZXcgPSBcIlNvdWhhaXRlei12b3VzIGVucmVnaXN0cmVyIHZvcyBtb2RpZmljYXRpb25zID9cIjtcbmNvbnN0IHNhdmVBcyA9IFwiRW5yZWdpc3RyZXIgc291c1wiO1xuY29uc3QgZG9udFNhdmUgPSBcIk5lIHBhcyBlbnJlZ2lzdHJlclwiO1xuY29uc3QgdW5zYXZlZFRpdGxlID0gXCJNb2RpZmljYXRpb25zIG5vbiBlbnJlZ2lzdHLDqWVzXCI7XG5jb25zdCBpbnZhbGlkUkZUTWVzc2FnZSA9IFwiTGUgbW9kw6hsZSBkZSBmb25jdGlvbiByYXN0ZXIgY3LDqcOpIG7igJllc3QgcGFzIHZhbGlkZS5cIjtcbmNvbnN0IGVycm9yVGl0bGUgPSBcIkVycmV1clwiO1xuY29uc3QgYnJlYWRjcnVtYiA9IFwiw4lkaXRldXIgZGUgZm9uY3Rpb25zIHJhc3RlclwiO1xuY29uc3QgYnJlYWRjcnVtYkVkaXRvciA9IFwiQ29udGVudcKgPsKgw4lkaXRldXIgZGUgZm9uY3Rpb25zIHJhc3RlclwiO1xuY29uc3Qgdmlld2VyTW9kZVRpdGxlID0gXCJMZWN0dXJlIHNldWxlXCI7XG5jb25zdCB2aWV3ZXJNb2RlTWVzc2FnZSA9IFwiTOKAmcOpbMOpbWVudCBkZSBtb2TDqGxlIGRlIGZvbmN0aW9uIHJhc3RlciBlc3QgZW4gbGVjdHVyZSBzZXVsZS4gTGVzIG1vZGlmaWNhdGlvbnMgbmUgcGV1dmVudCBwYXMgw6p0cmUgZW5yZWdpc3Ryw6llcy5cIjtcbmNvbnN0IHVzZXJTdGFydERpcmVjdGlvbiA9IFwiU8OpbGVjdGlvbm5leiB1bmUgZm9uY3Rpb24gcG91ciBjb21tZW5jZXIgw6AgZ8OpbsOpcmVyIHVuIG1vZMOobGUgZGUgZm9uY3Rpb24gcmFzdGVyLlwiO1xuY29uc3Qgc2VsZWN0RnVuY3Rpb24gPSBcIkFqb3V0ZXIgdW5lIGZvbmN0aW9uXCI7XG5jb25zdCBkZXNlbGVjdEZ1bmN0aW9uID0gXCJTdXBwcmltZXIgdW5lIGZvbmN0aW9uXCI7XG5jb25zdCBkaWFsb2dUaXRsZSA9IFwiU3lzdMOobWVcIjtcbmNvbnN0IGNhdGVnb3J5ID0gXCJDYXTDqWdvcmllc1wiO1xuY29uc3Qgc2VhcmNoID0gXCJSZWNoZXJjaGVyIGxlcyBmb25jdGlvbnMgcmFzdGVyXCI7XG5jb25zdCBjYXRlZ29yeU5hbWVzID0ge1xuXHRhbmFseXNpczogXCJBbmFseXNlXCIsXG5cdGFwcGVhcmFuY2U6IFwiQXBwYXJlbmNlXCIsXG5cdGNsYXNzaWZpY2F0aW9uOiBcIkNsYXNzaWZpY2F0aW9uXCIsXG5cdGNvbnZlcnNpb246IFwiQ29udmVyc2lvblwiLFxuXHRjb3JyZWN0aW9uOiBcIkNvcnJlY3Rpb25cIixcblx0ZGF0YU1hbmFnZW1lbnQ6IFwiR2VzdGlvbiBkZXMgZG9ubsOpZXNcIixcblx0ZGlzdGFuY2U6IFwiRGlzdGFuY2VcIixcblx0ZGlzdGFuY2VMZWdhY3k6IFwiRGlzdGFuY2UgKGV4aXN0YW50ZSlcIixcblx0aHlkcm9sb2d5OiBcIkh5ZHJvbG9naWVcIixcblx0bWF0aDogXCJNYXRow6ltYXRpcXVlc1wiLFxuXHRtYXRoQ29uZGl0aW9uYWw6IFwiTWF0aMOpbWF0aXF1ZXMgOiBjb25kaXRpb25uZWxsZXNcIixcblx0bWF0aExvZ2ljYWw6IFwiTWF0aMOpbWF0aXF1ZXMgOiBsb2dpcXVlc1wiLFxuXHRtYXRoVHJpZ29ub21ldHJpYzogXCJNYXRow6ltYXRpcXVlcyA6IHRyaWdvbm9tw6l0cmlxdWVzXCIsXG5cdHJlY2xhc3M6IFwiUmVjbGFzc2VtZW50XCIsXG5cdHN0YXRpc3RpY2FsOiBcIlN0YXRpc3RpcXVlXCIsXG5cdHN1cmZhY2U6IFwiU3VyZmFjZVwiXG59O1xuY29uc3QgY29tbW9uU3RyaW5nc19mciA9IHtcblx0b2s6IG9rLFxuXHRjYW5jZWw6IGNhbmNlbCxcblx0ZW50ZXJVUkw6IGVudGVyVVJMLFxuXHRzZXJ2aWNlVVJMOiBzZXJ2aWNlVVJMLFxuXHRzZWxlY3RSYXN0ZXI6IHNlbGVjdFJhc3Rlcixcblx0ZmFpbGVkVG9Mb2FkTGF5ZXI6IGZhaWxlZFRvTG9hZExheWVyLFxuXHRsb2FkaW5nTGF5ZXI6IGxvYWRpbmdMYXllcixcblx0c2VsZWN0RmVhdHVyZTogc2VsZWN0RmVhdHVyZSxcblx0ZW50ZXJGVVJMOiBlbnRlckZVUkwsXG5cdGFkZFJhc3RlcjogYWRkUmFzdGVyLFxuXHRhZGRTY2FsYXI6IGFkZFNjYWxhcixcblx0cmFzdGVyOiByYXN0ZXIsXG5cdHNjYWxhcjogc2NhbGFyLFxuXHRkZWZhdWx0TW9kZWxOYW1lOiBkZWZhdWx0TW9kZWxOYW1lLFxuXHRnZW5lcmFsOiBnZW5lcmFsLFxuXHRwYXJhbWV0ZXJzOiBwYXJhbWV0ZXJzLFxuXHR2YXJpYWJsZXM6IHZhcmlhYmxlcyxcblx0bmFtZTogbmFtZSxcblx0ZGVzY3JpcHRpb246IGRlc2NyaXB0aW9uLFxuXHRwYXJhbWV0ZXI6IHBhcmFtZXRlcixcblx0aXNQdWJsaWM6IGlzUHVibGljLFxuXHRpc0RhdGFzZXQ6IGlzRGF0YXNldCxcblx0dW5rbm93blBpeGVsVHlwZTogdW5rbm93blBpeGVsVHlwZSxcblx0b3V0cHV0UGl4ZWxUeXBlOiBvdXRwdXRQaXhlbFR5cGUsXG5cdHU4UGl4ZWxUeXBlOiB1OFBpeGVsVHlwZSxcblx0czhQaXhlbFR5cGU6IHM4UGl4ZWxUeXBlLFxuXHR1MTZQaXhlbFR5cGU6IHUxNlBpeGVsVHlwZSxcblx0czE2UGl4ZWxUeXBlOiBzMTZQaXhlbFR5cGUsXG5cdHUzMlBpeGVsVHlwZTogdTMyUGl4ZWxUeXBlLFxuXHRzMzJQaXhlbFR5cGU6IHMzMlBpeGVsVHlwZSxcblx0ZjMyUGl4ZWxUeXBlOiBmMzJQaXhlbFR5cGUsXG5cdGY2NFBpeGVsVHlwZTogZjY0UGl4ZWxUeXBlLFxuXHRwcm9wZXJ0aWVzOiBwcm9wZXJ0aWVzLFxuXHRtdWx0aWRpbWVuc2lvbmFsUnVsZXM6IG11bHRpZGltZW5zaW9uYWxSdWxlcyxcblx0bWF0Y2hWYXJpYWJsZXM6IG1hdGNoVmFyaWFibGVzLFxuXHR1bmlvbkRpbWVuc2lvbnM6IHVuaW9uRGltZW5zaW9ucyxcblx0cmFzdGVyRnVuY3Rpb25FZGl0b3I6IHJhc3RlckZ1bmN0aW9uRWRpdG9yLFxuXHRyZnhMaWNlbnNlSW5mbzogcmZ4TGljZW5zZUluZm8sXG5cdHJhc3RlckZ1bmN0aW9uczogcmFzdGVyRnVuY3Rpb25zLFxuXHRjb3B5OiBjb3B5LFxuXHRzYXZlOiBzYXZlLFxuXHR0aXRsZTogdGl0bGUsXG5cdGZvbGRlcjogZm9sZGVyLFxuXHR0YWdzOiB0YWdzLFxuXHRzYXZpbmdNZXNzYWdlOiBzYXZpbmdNZXNzYWdlLFxuXHRzaGFyZVdpdGg6IHNoYXJlV2l0aCxcblx0c2hhcmU6IHNoYXJlLFxuXHRzZXRTaGFyaW5nTGV2ZWw6IHNldFNoYXJpbmdMZXZlbCxcblx0c2V0R3JvdXBTaGFyaW5nOiBzZXRHcm91cFNoYXJpbmcsXG5cdG93bmVyOiBvd25lcixcblx0b3JnYW5pemF0aW9uOiBvcmdhbml6YXRpb24sXG5cdGV2ZXJ5b25lOiBldmVyeW9uZSxcblx0Z3JvdXBzOiBncm91cHMsXG5cdHR5cGU6IHR5cGUsXG5cdG1vc2FpYzogbW9zYWljLFxuXHRpdGVtR3JvdXA6IGl0ZW1Hcm91cCxcblx0aXRlbTogaXRlbSxcblx0ZGVmaW5pdGlvblF1ZXJ5OiBkZWZpbml0aW9uUXVlcnksXG5cdGdyb3VwSXRlbXNCeTogZ3JvdXBJdGVtc0J5LFxuXHRncm91cEZpZWxkTmFtZTogZ3JvdXBGaWVsZE5hbWUsXG5cdHRhZ0ZpZWxkTmFtZTogdGFnRmllbGROYW1lLFxuXHRub1RpdGxlVGFnRXJyb3JNc2c6IG5vVGl0bGVUYWdFcnJvck1zZyxcblx0bm9UaXRsZUVycm9yTXNnOiBub1RpdGxlRXJyb3JNc2csXG5cdG5vVGFnRXJyb3JNc2c6IG5vVGFnRXJyb3JNc2csXG5cdGVycm9yOiBlcnJvcixcblx0d2FybmluZzogd2FybmluZyxcblx0c3VjY2Vzczogc3VjY2Vzcyxcblx0ZGV0YWlsczogZGV0YWlscyxcblx0dHJ5QWdhaW46IHRyeUFnYWluLFxuXHR0b29sTW9kZWxlcjogdG9vbE1vZGVsZXIsXG5cdHRvb2xFZGl0b3I6IHRvb2xFZGl0b3IsXG5cdHRvb2xEZXRhaWxzRWRpdG9yOiB0b29sRGV0YWlsc0VkaXRvcixcblx0c2F2ZVV0aWxzOiBzYXZlVXRpbHMsXG5cdGNsb3NlOiBjbG9zZSxcblx0dW5zYXZlZFdhcm5pbmdFeGlzdGluZzogdW5zYXZlZFdhcm5pbmdFeGlzdGluZyxcblx0dW5zYXZlZFdhcm5pbmdOZXc6IHVuc2F2ZWRXYXJuaW5nTmV3LFxuXHRzYXZlQXM6IHNhdmVBcyxcblx0ZG9udFNhdmU6IGRvbnRTYXZlLFxuXHR1bnNhdmVkVGl0bGU6IHVuc2F2ZWRUaXRsZSxcblx0aW52YWxpZFJGVE1lc3NhZ2U6IGludmFsaWRSRlRNZXNzYWdlLFxuXHRlcnJvclRpdGxlOiBlcnJvclRpdGxlLFxuXHRicmVhZGNydW1iOiBicmVhZGNydW1iLFxuXHRicmVhZGNydW1iRWRpdG9yOiBicmVhZGNydW1iRWRpdG9yLFxuXHR2aWV3ZXJNb2RlVGl0bGU6IHZpZXdlck1vZGVUaXRsZSxcblx0dmlld2VyTW9kZU1lc3NhZ2U6IHZpZXdlck1vZGVNZXNzYWdlLFxuXHR1c2VyU3RhcnREaXJlY3Rpb246IHVzZXJTdGFydERpcmVjdGlvbixcblx0c2VsZWN0RnVuY3Rpb246IHNlbGVjdEZ1bmN0aW9uLFxuXHRkZXNlbGVjdEZ1bmN0aW9uOiBkZXNlbGVjdEZ1bmN0aW9uLFxuXHRkaWFsb2dUaXRsZTogZGlhbG9nVGl0bGUsXG5cdGNhdGVnb3J5OiBjYXRlZ29yeSxcblx0c2VhcmNoOiBzZWFyY2gsXG5cdGNhdGVnb3J5TmFtZXM6IGNhdGVnb3J5TmFtZXNcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGNvbW1vblN0cmluZ3NfZnI7XG5leHBvcnQgeyBhZGRSYXN0ZXIsIGFkZFNjYWxhciwgYnJlYWRjcnVtYiwgYnJlYWRjcnVtYkVkaXRvciwgY2FuY2VsLCBjYXRlZ29yeSwgY2F0ZWdvcnlOYW1lcywgY2xvc2UsIGNvcHksIGRlZmF1bHRNb2RlbE5hbWUsIGRlZmluaXRpb25RdWVyeSwgZGVzY3JpcHRpb24sIGRlc2VsZWN0RnVuY3Rpb24sIGRldGFpbHMsIGRpYWxvZ1RpdGxlLCBkb250U2F2ZSwgZW50ZXJGVVJMLCBlbnRlclVSTCwgZXJyb3IsIGVycm9yVGl0bGUsIGV2ZXJ5b25lLCBmMzJQaXhlbFR5cGUsIGY2NFBpeGVsVHlwZSwgZmFpbGVkVG9Mb2FkTGF5ZXIsIGZvbGRlciwgZ2VuZXJhbCwgZ3JvdXBGaWVsZE5hbWUsIGdyb3VwSXRlbXNCeSwgZ3JvdXBzLCBpbnZhbGlkUkZUTWVzc2FnZSwgaXNEYXRhc2V0LCBpc1B1YmxpYywgaXRlbSwgaXRlbUdyb3VwLCBsb2FkaW5nTGF5ZXIsIG1hdGNoVmFyaWFibGVzLCBtb3NhaWMsIG11bHRpZGltZW5zaW9uYWxSdWxlcywgbmFtZSwgbm9UYWdFcnJvck1zZywgbm9UaXRsZUVycm9yTXNnLCBub1RpdGxlVGFnRXJyb3JNc2csIG9rLCBvcmdhbml6YXRpb24sIG91dHB1dFBpeGVsVHlwZSwgb3duZXIsIHBhcmFtZXRlciwgcGFyYW1ldGVycywgcHJvcGVydGllcywgcmFzdGVyLCByYXN0ZXJGdW5jdGlvbkVkaXRvciwgcmFzdGVyRnVuY3Rpb25zLCByZnhMaWNlbnNlSW5mbywgczE2UGl4ZWxUeXBlLCBzMzJQaXhlbFR5cGUsIHM4UGl4ZWxUeXBlLCBzYXZlLCBzYXZlQXMsIHNhdmVVdGlscywgc2F2aW5nTWVzc2FnZSwgc2NhbGFyLCBzZWFyY2gsIHNlbGVjdEZlYXR1cmUsIHNlbGVjdEZ1bmN0aW9uLCBzZWxlY3RSYXN0ZXIsIHNlcnZpY2VVUkwsIHNldEdyb3VwU2hhcmluZywgc2V0U2hhcmluZ0xldmVsLCBzaGFyZSwgc2hhcmVXaXRoLCBzdWNjZXNzLCB0YWdGaWVsZE5hbWUsIHRhZ3MsIHRpdGxlLCB0b29sRGV0YWlsc0VkaXRvciwgdG9vbEVkaXRvciwgdG9vbE1vZGVsZXIsIHRyeUFnYWluLCB0eXBlLCB1MTZQaXhlbFR5cGUsIHUzMlBpeGVsVHlwZSwgdThQaXhlbFR5cGUsIHVuaW9uRGltZW5zaW9ucywgdW5rbm93blBpeGVsVHlwZSwgdW5zYXZlZFRpdGxlLCB1bnNhdmVkV2FybmluZ0V4aXN0aW5nLCB1bnNhdmVkV2FybmluZ05ldywgdXNlclN0YXJ0RGlyZWN0aW9uLCB2YXJpYWJsZXMsIHZpZXdlck1vZGVNZXNzYWdlLCB2aWV3ZXJNb2RlVGl0bGUsIHdhcm5pbmcgfTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29tbW9uLXN0cmluZ3MuZnItZjA2NmNiZTYuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9