"use strict";
(self["webpackChunkexb_client"] = self["webpackChunkexb_client"] || []).push([["vendors-extensions_widgets_arcgis_analysis_node_modules_arcgis_arcgis-raster-function-editor_-95eb49"],{

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/arcgis-raster-function-editor/dist/esm/help-texts.en-f9d07fbe.js":
/*!**********************************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/arcgis-raster-function-editor/dist/esm/help-texts.en-f9d07fbe.js ***!
  \**********************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   rfxArgsHelpTexts: () => (/* binding */ rfxArgsHelpTexts)
/* harmony export */ });
const rfxArgsHelpTexts = {
	"@@Abs_Cellsize-Type_tag0@@": "Choose which cell size to use in the output raster. If all the input cell sizes are the same, all the options will yield the same results.",
	"@@Abs_Cellsize-Type_tag1@@": "First Of--Use the first cell size of the input rasters.",
	"@@Abs_Cellsize-Type_tag2@@": "Last Of--Use the last cell size of the input rasters.",
	"@@Abs_Cellsize-Type_tag3@@": "Max Of--Use the largest cell size of all the input rasters. This is the default.",
	"@@Abs_Cellsize-Type_tag4@@": "Mean Of--Use the mean cell size of all the input rasters.",
	"@@Abs_Cellsize-Type_tag5@@": "Min Of--Use the smallest cell size of all the input rasters.",
	"@@Abs_Extent-Type_tag0@@": "Choose which extent should be used in the output raster:",
	"@@Abs_Extent-Type_tag1@@": "First Of--Use the extent of the first input raster to determine the processing extent.",
	"@@Abs_Extent-Type_tag2@@": "Intersection Of--Use the extent of the overlapping pixels to determine the processing extent. This is the default.",
	"@@Abs_Extent-Type_tag3@@": "Last Of--Use the extent of the last input raster to determine the processing extent.",
	"@@Abs_Extent-Type_tag4@@": "Union Of--Use the extent of all the rasters to determine the processing extent.",
	"@@Abs_Raster_tag0@@": "The input raster for which to calculate the absolute values.",
	"@@ACos_Cellsize-Type_tag0@@": "Choose which cell size to use in the output raster. If all the input cell sizes are the same, all the options will yield the same results.",
	"@@ACos_Cellsize-Type_tag1@@": "First Of--Use the first cell size of the input rasters.",
	"@@ACos_Cellsize-Type_tag2@@": "Last Of--Use the last cell size of the input rasters.",
	"@@ACos_Cellsize-Type_tag3@@": "Max Of--Use the largest cell size of all the input rasters. This is the default.",
	"@@ACos_Cellsize-Type_tag4@@": "Mean Of--Use the mean cell size of all the input rasters.",
	"@@ACos_Cellsize-Type_tag5@@": "Min Of--Use the smallest cell size of all the input rasters.",
	"@@ACos_Extent-Type_tag0@@": "Choose which extent should be used in the output raster:",
	"@@ACos_Extent-Type_tag1@@": "First Of--Use the extent of the first input raster to determine the processing extent.",
	"@@ACos_Extent-Type_tag2@@": "Intersection Of--Use the extent of the overlapping pixels to determine the processing extent. This is the default.",
	"@@ACos_Extent-Type_tag3@@": "Last Of--Use the extent of the last input raster to determine the processing extent.",
	"@@ACos_Extent-Type_tag4@@": "Union Of--Use the extent of all the rasters to determine the processing extent.",
	"@@ACos_Raster_tag0@@": "The input for which to calculate the inverse cosine values.",
	"@@ACosH_Cellsize-Type_tag0@@": "Choose which cell size to use in the output raster. If all the input cell sizes are the same, all the options will yield the same results.",
	"@@ACosH_Cellsize-Type_tag1@@": "First Of--Use the first cell size of the input rasters.",
	"@@ACosH_Cellsize-Type_tag2@@": "Last Of--Use the last cell size of the input rasters.",
	"@@ACosH_Cellsize-Type_tag3@@": "Max Of--Use the largest cell size of all the input rasters. This is the default.",
	"@@ACosH_Cellsize-Type_tag4@@": "Mean Of--Use the mean cell size of all the input rasters.",
	"@@ACosH_Cellsize-Type_tag5@@": "Min Of--Use the smallest cell size of all the input rasters.",
	"@@ACosH_Extent-Type_tag0@@": "Choose which extent should be used in the output raster:",
	"@@ACosH_Extent-Type_tag1@@": "First Of--Use the extent of the first input raster to determine the processing extent.",
	"@@ACosH_Extent-Type_tag2@@": "Intersection Of--Use the extent of the overlapping pixels to determine the processing extent. This is the default.",
	"@@ACosH_Extent-Type_tag3@@": "Last Of--Use the extent of the last input raster to determine the processing extent.",
	"@@ACosH_Extent-Type_tag4@@": "Union Of--Use the extent of all the rasters to determine the processing extent.",
	"@@ACosH_Raster_tag0@@": "The input for which to calculate the inverse hyperbolic cosine values.",
	"@@Apparent-Reflectance_Albedo_tag0@@": "The results of the Apparent Reflectance function can also be expressed as albedo, which is the percentage of the available energy reflected by the planetary surface. Albedo data is used by scientific users for complex modeling and technical remote-sensing applications.",
	"@@Apparent-Reflectance_Albedo_tag1@@": "Unchecked--The function returns apparent reflectance values. This is the default.",
	"@@Apparent-Reflectance_Albedo_tag2@@": "Checked--The function returns 32-bit floating-point values, which most commonly are in the range of 0.0 to 1.0. No data clipping is performed if this option is selected.",
	"@@Apparent-Reflectance_Albedo_tag3@@": "Since the output data type for albedo is floating point, you must explicitly set the preferred <strong>Output Pixel Type</strong> to either 32-bit float or 64-bit double. The <strong>Output Pixel Type</strong> parameter is found on the <strong>General</strong> tab in the <strong>Apparent Reflectance</strong> raster function. If the <strong>Output Pixel Type</strong> is not set correctly for the <strong>Albedo</strong> option, the resulting values will be invalid and given a value of 0.",
	"@@Apparent-Reflectance_Offset_tag0@@": "Your scaled albedo value can optionally have an offset value:",
	"@@Apparent-Reflectance_Offset_tag1@@": "For 16-bit unsigned data types, the default scale offset is 5,000.",
	"@@Apparent-Reflectance_Offset_tag2@@": "For 8-bit unsigned data types, the default scale offset is 0.",
	"@@Apparent-Reflectance_Offset_tag3@@": "No scaling is applied when the output is albedo.",
	"@@Apparent-Reflectance_Radiance-Gains-and-Bias-Values-per-Band_tag0@@": "You can manually set or edit this value for each band. The appropriate information can be read from the metadata of the input raster product.",
	"@@Apparent-Reflectance_Raster_tag0@@": "The raster product on which the apparent reflectance will be applied.",
	"@@Apparent-Reflectance_Scale-Factor_tag0@@": "Your apparent reflectance output value can be expressed as an integer. The scaling factor is multiplied by the albedo to convert all floating-point values into integer values.",
	"@@Apparent-Reflectance_Scale-Factor_tag1@@": "If the scale factor is either ${0} or not specified, default scaling will be applied depending on the pixel type of the input data:",
	"@@Apparent-Reflectance_Scale-Factor_tag2@@": "For 16-bit unsigned data types, the default scale factor is 50,000.",
	"@@Apparent-Reflectance_Scale-Factor_tag3@@": "For 8-bit unsigned data types, default scale factor is 255.",
	"@@Apparent-Reflectance_Scale-Factor_tag4@@": "The scaling factor is always applied when the output is apparent reflectance. No scaling is applied when the output is albedo.",
	"@@Apparent-Reflectance_Sun-Elevation_tag0@@": "This is sun elevation value, expressed in degrees. This will be populated by the system if the appropriate information can be read from the metadata. You can manually set or edit this value.",
	"@@ArgStatistics_Max_tag0@@": "The maximum value that you set is the highest value equal to or less than the end of the duration.",
	"@@ArgStatistics_Max_tag1@@": "This input is only applicable when the method is Duration.",
	"@@ArgStatistics_Method_tag0@@": "Select the statistics method to calculate:",
	"@@ArgStatistics_Method_tag1@@": "Arg Max--The argument of the maximum, which returns the ${Band index} for which the given pixel attains its minimum value from all the bands. All raster bands from every input raster are assigned a 0-based incremental band index, which is first ordered by the input raster index, and then by the relative band order within each input raster.",
	"@@ArgStatistics_Method_tag2@@": "Arg Median--The argument of the median, which returns the ${Band index} for which the given pixel attains the median value of values from all bands.",
	"@@ArgStatistics_Method_tag3@@": "Arg Min--The argument of the minimum, which returns the ${Band index} for which the given pixel attains its minimum value from all the bands.",
	"@@ArgStatistics_Method_tag4@@": "Duration--The Duration method finds the longest consecutive elements in the array, where each element has a value greater than or equal to <strong>Min</strong> and less than or equal to <strong>Max</strong>, and then returns its length.",
	"@@ArgStatistics_Min_tag0@@": "The minimum value that you set is the lowest value equal to or greater than the beginning of the duration.",
	"@@ArgStatistics_Min_tag1@@": "This input is only applicable when the method is Duration.",
	"@@ArgStatistics_Rasters_tag0@@": "The input raster that you will perform the various statistical methods upon.",
	"@@ArgStatistics_Undefined-Class_tag0@@": "A constant input that will be returned when no definitive maximum, minimum, or median can be attained. The most common scenario is when the maximum or minimum value occurs more than once among values from all bands. The default value for the undefined constant is 100.",
	"@@ArgStatistics_Undefined-Class_tag1@@": "The undefined class is only applicable when the method is <strong>ArgMax</strong>, <strong>ArgMin</strong>, or <strong>ArgMedian</strong>.",
	"@@ArgStatistics_ignorenodata_tag0@@": "Denotes whether NoData values are ignored in the statistical calculation.",
	"@@ArgStatistics_ignorenodata_tag1@@": "Checked--The analysis will include all valid pixels in the input rasters and ignore any NoData pixels.",
	"@@ArgStatistics_ignorenodata_tag2@@": "Unchecked--The analysis will result in NoData if there are any NoData values for the pixels in the input rasters. This is the default.",
	"@@Arithmetic_Cellsize-Type_tag0@@": "Choose which cell size to use in the output raster. If all the input cell sizes are the same, all the options will yield the same results.",
	"@@Arithmetic_Cellsize-Type_tag1@@": "First Of--Use the first cell size of the input rasters.",
	"@@Arithmetic_Cellsize-Type_tag2@@": "Last Of--Use the last cell size of the input rasters.",
	"@@Arithmetic_Cellsize-Type_tag3@@": "Max Of--Use the largest cell size of all the input rasters. This is the default.",
	"@@Arithmetic_Cellsize-Type_tag4@@": "Mean Of--Use the mean cell size of all the input rasters.",
	"@@Arithmetic_Cellsize-Type_tag5@@": "Min Of--Use the smallest cell size of all the input rasters.",
	"@@Arithmetic_Extent-Type_tag0@@": "Choose which extent should be used in the output raster:",
	"@@Arithmetic_Extent-Type_tag1@@": "First Of--Use the extent of the first input raster to determine the processing extent.",
	"@@Arithmetic_Extent-Type_tag2@@": "Intersection Of--Use the extent of the overlapping pixels to determine the processing extent. This is the default.",
	"@@Arithmetic_Extent-Type_tag3@@": "Last Of--Use the extent of the last input raster to determine the processing extent.",
	"@@Arithmetic_Extent-Type_tag4@@": "Union Of--Use the extent of all the rasters to determine the processing extent.",
	"@@Arithmetic_Operation_tag0@@": "The arithmetic operation to be performed between the two input rasters.",
	"@@Arithmetic_Operation_tag1@@": "The options are as follows:",
	"@@Arithmetic_Operation_tag2@@": "<strong>Divide</strong>--Outputs the divisible result between the corresponding pixel values for each raster.",
	"@@Arithmetic_Operation_tag4@@": "<strong>Minus</strong>--Outputs the difference between the corresponding pixel values for each raster. This can be used to calculate change detection.",
	"@@Arithmetic_Operation_tag6@@": "<strong>Mode</strong>--Outputs the pixel value of all overlapping pixels that occurs the most. For example, if there are six bands in a raster, there will be six overlapping pixels. For the values 4, 5, 6, 4, 7, 9, the mode value is 4.",
	"@@Arithmetic_Operation_tag8@@": "<strong>Multiply</strong>--Outputs the product of the corresponding pixel values for each raster. This can be used to perform some cost functions.",
	"@@Arithmetic_Operation_tag10@@": "<strong>Plus</strong>--Outputs the sum of all the corresponding pixel values for each raster.",
	"@@Arithmetic_Operation_tag12@@": "<strong>Power</strong>--Outputs the product of the corresponding pixel values raised to the power of the input raster or scalar.",
	"@@Arithmetic_Raster_tag0@@": "The first input raster dataset.",
	"@@Arithmetic_Raster2_tag0@@": "The second input raster dataset.",
	"@@ASin_Cellsize-Type_tag0@@": "Choose which cell size to use in the output raster. If all the input cell sizes are the same, all the options will yield the same results.",
	"@@ASin_Cellsize-Type_tag1@@": "First Of--Use the first cell size of the input rasters.",
	"@@ASin_Cellsize-Type_tag2@@": "Last Of--Use the last cell size of the input rasters.",
	"@@ASin_Cellsize-Type_tag3@@": "Max Of--Use the largest cell size of all the input rasters. This is the default.",
	"@@ASin_Cellsize-Type_tag4@@": "Mean Of--Use the mean cell size of all the input rasters.",
	"@@ASin_Cellsize-Type_tag5@@": "Min Of--Use the smallest cell size of all the input rasters.",
	"@@ASin_Extent-Type_tag0@@": "Choose which extent should be used in the output raster:",
	"@@ASin_Extent-Type_tag1@@": "First Of--Use the extent of the first input raster to determine the processing extent.",
	"@@ASin_Extent-Type_tag2@@": "Intersection Of--Use the extent of the overlapping pixels to determine the processing extent. This is the default.",
	"@@ASin_Extent-Type_tag3@@": "Last Of--Use the extent of the last input raster to determine the processing extent.",
	"@@ASin_Extent-Type_tag4@@": "Union Of--Use the extent of all the rasters to determine the processing extent.",
	"@@ASin_Raster_tag0@@": "The input for which to calculate the inverse sine values.",
	"@@ASinH_Cellsize-Type_tag0@@": "Choose which cell size to use in the output raster. If all the input cell sizes are the same, all the options will yield the same results.",
	"@@ASinH_Cellsize-Type_tag1@@": "First Of--Use the first cell size of the input rasters.",
	"@@ASinH_Cellsize-Type_tag2@@": "Last Of--Use the last cell size of the input rasters.",
	"@@ASinH_Cellsize-Type_tag3@@": "Max Of--Use the largest cell size of all the input rasters. This is the default.",
	"@@ASinH_Cellsize-Type_tag4@@": "Mean Of--Use the mean cell size of all the input rasters.",
	"@@ASinH_Cellsize-Type_tag5@@": "Min Of--Use the smallest cell size of all the input rasters.",
	"@@ASinH_Extent-Type_tag0@@": "Choose which extent should be used in the output raster:",
	"@@ASinH_Extent-Type_tag1@@": "First Of--Use the extent of the first input raster to determine the processing extent.",
	"@@ASinH_Extent-Type_tag2@@": "Intersection Of--Use the extent of the overlapping pixels to determine the processing extent. This is the default.",
	"@@ASinH_Extent-Type_tag3@@": "Last Of--Use the extent of the last input raster to determine the processing extent.",
	"@@ASinH_Extent-Type_tag4@@": "Union Of--Use the extent of all the rasters to determine the processing extent.",
	"@@ASinH_Raster_tag0@@": "The input for which to calculate the inverse hyperbolic sine values.",
	"@@Aspect_Raster_tag0@@": "The input DEM used to derive the aspect dataset.",
	"@@Aspect-Slope_Raster_tag0@@": "The input DEM.",
	"@@Aspect-Slope_Z-Factor_tag0@@": "A scaling factor used to convert the elevation values for the following two purposes:",
	"@@Aspect-Slope_Z-Factor_tag1@@": "Convert the elevation units (such as meters or feet) to the horizontal coordinate units of the dataset, which may be feet, meters, or degrees.",
	"@@Aspect-Slope_Z-Factor_tag2@@": "Add vertical exaggeration for visual effect.",
	"@@ATan_Cellsize-Type_tag0@@": "Choose which cell size to use in the output raster. If all the input cell sizes are the same, all the options will yield the same results.",
	"@@ATan_Cellsize-Type_tag1@@": "First Of--Use the first cell size of the input rasters.",
	"@@ATan_Cellsize-Type_tag2@@": "Last Of--Use the last cell size of the input rasters.",
	"@@ATan_Cellsize-Type_tag3@@": "Max Of--Use the largest cell size of all the input rasters. This is the default.",
	"@@ATan_Cellsize-Type_tag4@@": "Mean Of--Use the mean cell size of all the input rasters.",
	"@@ATan_Cellsize-Type_tag5@@": "Min Of--Use the smallest cell size of all the input rasters.",
	"@@ATan_Extent-Type_tag0@@": "Choose which extent should be used in the output raster:",
	"@@ATan_Extent-Type_tag1@@": "First Of--Use the extent of the first input raster to determine the processing extent.",
	"@@ATan_Extent-Type_tag2@@": "Intersection Of--Use the extent of the overlapping pixels to determine the processing extent. This is the default.",
	"@@ATan_Extent-Type_tag3@@": "Last Of--Use the extent of the last input raster to determine the processing extent.",
	"@@ATan_Extent-Type_tag4@@": "Union Of--Use the extent of all the rasters to determine the processing extent.",
	"@@ATan_Raster_tag0@@": "The input for which to calculate the inverse tangent values.",
	"@@ATan2_Cellsize-Type_tag0@@": "Choose which cell size to use in the output raster. If all the input cell sizes are the same, all the options will yield the same results.",
	"@@ATan2_Cellsize-Type_tag1@@": "First Of--Use the first cell size of the input rasters.",
	"@@ATan2_Cellsize-Type_tag2@@": "Last Of--Use the last cell size of the input rasters.",
	"@@ATan2_Cellsize-Type_tag3@@": "Max Of--Use the largest cell size of all the input rasters. This is the default.",
	"@@ATan2_Cellsize-Type_tag4@@": "Mean Of--Use the mean cell size of all the input rasters.",
	"@@ATan2_Cellsize-Type_tag5@@": "Min Of--Use the smallest cell size of all the input rasters.",
	"@@ATan2_Extent-Type_tag0@@": "Choose which extent should be used in the output raster:",
	"@@ATan2_Extent-Type_tag1@@": "First Of--Use the extent of the first input raster to determine the processing extent.",
	"@@ATan2_Extent-Type_tag2@@": "Intersection Of--Use the extent of the overlapping pixels to determine the processing extent. This is the default.",
	"@@ATan2_Extent-Type_tag3@@": "Last Of--Use the extent of the last input raster to determine the processing extent.",
	"@@ATan2_Extent-Type_tag4@@": "Union Of--Use the extent of all the rasters to determine the processing extent.",
	"@@ATan2_Raster_tag0@@": "The input that specifies the numerator, or y value, to use when calculating the inverse tangent.",
	"@@ATan2_Raster2_tag0@@": "The input that specifies the denominator, or x value, to use when calculating the inverse tangent.",
	"@@ATanH_Cellsize-Type_tag0@@": "Choose which cell size to use in the output raster. If all the input cell sizes are the same, all the options will yield the same results.",
	"@@ATanH_Cellsize-Type_tag1@@": "First Of--Use the first cell size of the input rasters.",
	"@@ATanH_Cellsize-Type_tag2@@": "Last Of--Use the last cell size of the input rasters.",
	"@@ATanH_Cellsize-Type_tag3@@": "Max Of--Use the largest cell size of all the input rasters. This is the default.",
	"@@ATanH_Cellsize-Type_tag4@@": "Mean Of--Use the mean cell size of all the input rasters.",
	"@@ATanH_Cellsize-Type_tag5@@": "Min Of--Use the smallest cell size of all the input rasters.",
	"@@ATanH_Extent-Type_tag0@@": "Choose which extent should be used in the output raster:",
	"@@ATanH_Extent-Type_tag1@@": "First Of--Use the extent of the first input raster to determine the processing extent.",
	"@@ATanH_Extent-Type_tag2@@": "Intersection Of--Use the extent of the overlapping pixels to determine the processing extent. This is the default.",
	"@@ATanH_Extent-Type_tag3@@": "Last Of--Use the extent of the last input raster to determine the processing extent.",
	"@@ATanH_Extent-Type_tag4@@": "Union Of--Use the extent of all the rasters to determine the processing extent.",
	"@@ATanH_Raster_tag0@@": "The input for which to calculate the inverse hyperbolic tangent values.",
	"@@Attribute-Table_Raster_tag0@@": "The input raster.",
	"@@Attribute-Table_Table-Type_tag0@@": "The input attribute table can be entered using the <strong>Manual</strong> type where you assign a class name and a color to each value, or you can reference an existing table which comes from a ${.dbf} file.",
	"@@Band-Arithmetic_Band-Indexes_tag0@@": "Define your band arithmetic formula if you chose <strong>User Defined</strong> for your <strong>Method</strong>.",
	"@@Band-Arithmetic_Band-Indexes_tag5@@": "If you chose a predefined index for your <strong>Method</strong>, define the proper bands of your input raster dataset that correspond to the index.",
	"@@Band-Arithmetic_Method_tag0@@": "The type of band arithmetic algorithm you want to deploy. You can define your custom algorithm, or choose a predefined index.",
	"@@Band-Arithmetic_Method_tag1@@": "<strong>BAI</strong>--Burn Area Index",
	"@@Band-Arithmetic_Method_tag2@@": "<strong>CIg</strong>--Chlorophyll Index - Green",
	"@@Band-Arithmetic_Method_tag3@@": "<strong>CIre</strong>--Chlorophyll Index - Red Edge",
	"@@Band-Arithmetic_Method_tag4@@": "<strong>Clay Minerals</strong>--Clay Minerals Ratio",
	"@@Band-Arithmetic_Method_tag5@@": "<strong>EVI</strong>--Enhanced Vegetation Index",
	"@@Band-Arithmetic_Method_tag6@@": "<strong>Ferrous Minerals</strong>--Ferrous Minerals Ratio",
	"@@Band-Arithmetic_Method_tag7@@": "<strong>GEMI</strong>--Global Environmental Monitoring Index",
	"@@Band-Arithmetic_Method_tag8@@": "<strong>GNDVI</strong>--Green Normalized Difference Vegetation Index",
	"@@Band-Arithmetic_Method_tag9@@": "<strong>GVI (Landsat TM)</strong>--Green Vegetation Index Landsat TM",
	"@@Band-Arithmetic_Method_tag10@@": "<strong>Iron Oxide</strong>--Iron Oxide Ratio",
	"@@Band-Arithmetic_Method_tag11@@": "<strong>MNDWI</strong>--Modified Normalized Difference Water Index",
	"@@Band-Arithmetic_Method_tag12@@": "<strong>MTVI2</strong>--Modified Triangulated Vegetation Index (second iteration)",
	"@@Band-Arithmetic_Method_tag13@@": "<strong>Modified SAVI</strong>--Modified Soil Adjusted Vegetation Index",
	"@@Band-Arithmetic_Method_tag14@@": "<strong>NBR</strong>--Normalized Burn Ratio Index",
	"@@Band-Arithmetic_Method_tag15@@": "<strong>NDBI</strong>--Normalized Difference Built-up Index",
	"@@Band-Arithmetic_Method_tag16@@": "<strong>NDMI</strong>--Normalized Difference Moisture Index",
	"@@Band-Arithmetic_Method_tag17@@": "<strong>NDSI</strong>--Normalized Difference Snow Index",
	"@@Band-Arithmetic_Method_tag18@@": "<strong>NDVI</strong>--Normalized Difference Vegetation Index",
	"@@Band-Arithmetic_Method_tag19@@": "<strong>NDVIre</strong>--Red-Edge Normalized Difference Vegetation Index",
	"@@Band-Arithmetic_Method_tag20@@": "<strong>NDWI</strong>--Normalized Difference Water Index",
	"@@Band-Arithmetic_Method_tag21@@": "<strong>PVI</strong>--Perpendicular Vegetation Index",
	"@@Band-Arithmetic_Method_tag22@@": "<strong>RTVICore</strong>--Red-Edge Triangulated Vegetation Index",
	"@@Band-Arithmetic_Method_tag23@@": "<strong>SAVI</strong>--Soil Adjusted Vegetation Index",
	"@@Band-Arithmetic_Method_tag24@@": "<strong>SR</strong>--Simple Ratio",
	"@@Band-Arithmetic_Method_tag25@@": "<strong>SRre</strong>--Red-Edge Simple Ratio",
	"@@Band-Arithmetic_Method_tag26@@": "<strong>Sultan's Formula</strong>--Sultan's Formula",
	"@@Band-Arithmetic_Method_tag27@@": "<strong>Transformed SAVI</strong>--Transformed Soil Adjusted Vegetation Index",
	"@@Band-Arithmetic_Method_tag28@@": "<strong>User Defined</strong>--Allows you to define your custom band arithmetic expression.",
	"@@Band-Arithmetic_Method_tag29@@": "<strong>VARI</strong>--Visible Atmospherically Resistant Index",
	"@@Band-Arithmetic_Method_tag30@@": "<strong>WNDWI</strong>--Weighted Normalized Difference Water Index",
	"@@Band-Arithmetic_Raster_tag0@@": "The input raster.",
	"@@Binary-Thresholding_Raster_tag0@@": "The input raster.",
	"@@Bitwise-And_Cellsize-Type_tag0@@": "Choose which cell size to use in the output raster. If all the input cell sizes are the same, all the options will yield the same results.",
	"@@Bitwise-And_Cellsize-Type_tag1@@": "First Of--Use the first cell size of the input rasters.",
	"@@Bitwise-And_Cellsize-Type_tag2@@": "Last Of--Use the last cell size of the input rasters.",
	"@@Bitwise-And_Cellsize-Type_tag3@@": "Max Of--Use the largest cell size of all the input rasters. This is the default.",
	"@@Bitwise-And_Cellsize-Type_tag4@@": "Mean Of--Use the mean cell size of all the input rasters.",
	"@@Bitwise-And_Cellsize-Type_tag5@@": "Min Of--Use the smallest cell size of all the input rasters.",
	"@@Bitwise-And_Extent-Type_tag0@@": "Choose which extent should be used in the output raster:",
	"@@Bitwise-And_Extent-Type_tag1@@": "First Of--Use the extent of the first input raster to determine the processing extent.",
	"@@Bitwise-And_Extent-Type_tag2@@": "Intersection Of--Use the extent of the overlapping pixels to determine the processing extent. This is the default.",
	"@@Bitwise-And_Extent-Type_tag3@@": "Last Of--Use the extent of the last input raster to determine the processing extent.",
	"@@Bitwise-And_Extent-Type_tag4@@": "Union Of--Use the extent of all the rasters to determine the processing extent.",
	"@@Bitwise-And_Raster_tag0@@": "The first input to use in this bitwise operation.",
	"@@Bitwise-And_Raster_tag1@@": "A constant value can be used as an input for this parameter, provided a raster is specified for the other parameter.",
	"@@Bitwise-And_Raster2_tag0@@": "The second input to use in this bitwise operation.",
	"@@Bitwise-And_Raster2_tag1@@": "A constant value can be used as an input for this parameter, provided a raster is specified for the other parameter.",
	"@@Bitwise-Left-Shift_Cellsize-Type_tag0@@": "Choose which cell size to use in the output raster. If all the input cell sizes are the same, all the options will yield the same results.",
	"@@Bitwise-Left-Shift_Cellsize-Type_tag1@@": "First Of--Use the first cell size of the input rasters.",
	"@@Bitwise-Left-Shift_Cellsize-Type_tag2@@": "Last Of--Use the last cell size of the input rasters.",
	"@@Bitwise-Left-Shift_Cellsize-Type_tag3@@": "Max Of--Use the largest cell size of all the input rasters. This is the default.",
	"@@Bitwise-Left-Shift_Cellsize-Type_tag4@@": "Mean Of--Use the mean cell size of all the input rasters.",
	"@@Bitwise-Left-Shift_Cellsize-Type_tag5@@": "Min Of--Use the smallest cell size of all the input rasters.",
	"@@Bitwise-Left-Shift_Extent-Type_tag0@@": "Choose which extent should be used in the output raster:",
	"@@Bitwise-Left-Shift_Extent-Type_tag1@@": "First Of--Use the extent of the first input raster to determine the processing extent.",
	"@@Bitwise-Left-Shift_Extent-Type_tag2@@": "Intersection Of--Use the extent of the overlapping pixels to determine the processing extent. This is the default.",
	"@@Bitwise-Left-Shift_Extent-Type_tag3@@": "Last Of--Use the extent of the last input raster to determine the processing extent.",
	"@@Bitwise-Left-Shift_Extent-Type_tag4@@": "Union Of--Use the extent of all the rasters to determine the processing extent.",
	"@@Bitwise-Left-Shift_Raster_tag0@@": "The input on which to perform the shift.",
	"@@Bitwise-Left-Shift_Raster_tag1@@": "A constant value can be used as an input for this parameter, provided a raster is specified for the other parameter.",
	"@@Bitwise-Left-Shift_Raster2_tag0@@": "The input defining the number of positions to shift the bits.",
	"@@Bitwise-Left-Shift_Raster2_tag1@@": "A constant value can be used as an input for this parameter, provided a raster is specified for the other parameter.",
	"@@Bitwise-Not_Cellsize-Type_tag0@@": "Choose which cell size to use in the output raster. If all the input cell sizes are the same, all the options will yield the same results.",
	"@@Bitwise-Not_Cellsize-Type_tag1@@": "First Of--Use the first cell size of the input rasters.",
	"@@Bitwise-Not_Cellsize-Type_tag2@@": "Last Of--Use the last cell size of the input rasters.",
	"@@Bitwise-Not_Cellsize-Type_tag3@@": "Max Of--Use the largest cell size of all the input rasters. This is the default.",
	"@@Bitwise-Not_Cellsize-Type_tag4@@": "Mean Of--Use the mean cell size of all the input rasters.",
	"@@Bitwise-Not_Cellsize-Type_tag5@@": "Min Of--Use the smallest cell size of all the input rasters.",
	"@@Bitwise-Not_Extent-Type_tag0@@": "Choose which extent should be used in the output raster:",
	"@@Bitwise-Not_Extent-Type_tag1@@": "First Of--Use the extent of the first input raster to determine the processing extent.",
	"@@Bitwise-Not_Extent-Type_tag2@@": "Intersection Of--Use the extent of the overlapping pixels to determine the processing extent. This is the default.",
	"@@Bitwise-Not_Extent-Type_tag3@@": "Last Of--Use the extent of the last input raster to determine the processing extent.",
	"@@Bitwise-Not_Extent-Type_tag4@@": "Union Of--Use the extent of all the rasters to determine the processing extent.",
	"@@Bitwise-Not_Raster_tag0@@": "The input raster on which to perform the Bitwise Not (complement) operation.",
	"@@Bitwise-Or_Cellsize-Type_tag0@@": "Choose which cell size to use in the output raster. If all the input cell sizes are the same, all the options will yield the same results.",
	"@@Bitwise-Or_Cellsize-Type_tag1@@": "First Of--Use the first cell size of the input rasters.",
	"@@Bitwise-Or_Cellsize-Type_tag2@@": "Last Of--Use the last cell size of the input rasters.",
	"@@Bitwise-Or_Cellsize-Type_tag3@@": "Max Of--Use the largest cell size of all the input rasters. This is the default.",
	"@@Bitwise-Or_Cellsize-Type_tag4@@": "Mean Of--Use the mean cell size of all the input rasters.",
	"@@Bitwise-Or_Cellsize-Type_tag5@@": "Min Of--Use the smallest cell size of all the input rasters.",
	"@@Bitwise-Or_Extent-Type_tag0@@": "Choose which extent should be used in the output raster:",
	"@@Bitwise-Or_Extent-Type_tag1@@": "First Of--Use the extent of the first input raster to determine the processing extent.",
	"@@Bitwise-Or_Extent-Type_tag2@@": "Intersection Of--Use the extent of the overlapping pixels to determine the processing extent. This is the default.",
	"@@Bitwise-Or_Extent-Type_tag3@@": "Last Of--Use the extent of the last input raster to determine the processing extent.",
	"@@Bitwise-Or_Extent-Type_tag4@@": "Union Of--Use the extent of all the rasters to determine the processing extent.",
	"@@Bitwise-Or_Raster_tag0@@": "The first input to use in this bitwise operation.",
	"@@Bitwise-Or_Raster_tag1@@": "A constant value can be used as an input for this parameter, provided a raster is specified for the other parameter.",
	"@@Bitwise-Or_Raster2_tag0@@": "The second input to use in this bitwise operation.",
	"@@Bitwise-Or_Raster2_tag1@@": "A constant value can be used as an input for this parameter, provided a raster is specified for the other parameter.",
	"@@Bitwise-Right-Shift_Cellsize-Type_tag0@@": "Choose which cell size to use in the output raster. If all the input cell sizes are the same, all the options will yield the same results.",
	"@@Bitwise-Right-Shift_Cellsize-Type_tag1@@": "First Of--Use the first cell size of the input rasters.",
	"@@Bitwise-Right-Shift_Cellsize-Type_tag2@@": "Last Of--Use the last cell size of the input rasters.",
	"@@Bitwise-Right-Shift_Cellsize-Type_tag3@@": "Max Of--Use the largest cell size of all the input rasters. This is the default.",
	"@@Bitwise-Right-Shift_Cellsize-Type_tag4@@": "Mean Of--Use the mean cell size of all the input rasters.",
	"@@Bitwise-Right-Shift_Cellsize-Type_tag5@@": "Min Of--Use the smallest cell size of all the input rasters.",
	"@@Bitwise-Right-Shift_Extent-Type_tag0@@": "Choose which extent should be used in the output raster:",
	"@@Bitwise-Right-Shift_Extent-Type_tag1@@": "First Of--Use the extent of the first input raster to determine the processing extent.",
	"@@Bitwise-Right-Shift_Extent-Type_tag2@@": "Intersection Of--Use the extent of the overlapping pixels to determine the processing extent. This is the default.",
	"@@Bitwise-Right-Shift_Extent-Type_tag3@@": "Last Of--Use the extent of the last input raster to determine the processing extent.",
	"@@Bitwise-Right-Shift_Extent-Type_tag4@@": "Union Of--Use the extent of all the rasters to determine the processing extent.",
	"@@Bitwise-Right-Shift_Raster_tag0@@": "The input on which to perform the shift.",
	"@@Bitwise-Right-Shift_Raster_tag1@@": "A constant value can be used as an input for this parameter, provided a raster is specified for the other parameter.",
	"@@Bitwise-Right-Shift_Raster2_tag0@@": "The input defining the number of positions to shift the bits.",
	"@@Bitwise-Right-Shift_Raster2_tag1@@": "A constant value can be used as an input for this parameter, provided a raster is specified for the other parameter.",
	"@@Bitwise-Xor_Cellsize-Type_tag0@@": "Choose which cell size to use in the output raster. If all the input cell sizes are the same, all the options will yield the same results.",
	"@@Bitwise-Xor_Cellsize-Type_tag1@@": "First Of--Use the first cell size of the input rasters.",
	"@@Bitwise-Xor_Cellsize-Type_tag2@@": "Last Of--Use the last cell size of the input rasters.",
	"@@Bitwise-Xor_Cellsize-Type_tag3@@": "Max Of--Use the largest cell size of all the input rasters. This is the default.",
	"@@Bitwise-Xor_Cellsize-Type_tag4@@": "Mean Of--Use the mean cell size of all the input rasters.",
	"@@Bitwise-Xor_Cellsize-Type_tag5@@": "Min Of--Use the smallest cell size of all the input rasters.",
	"@@Bitwise-Xor_Extent-Type_tag0@@": "Choose which extent should be used in the output raster:",
	"@@Bitwise-Xor_Extent-Type_tag1@@": "First Of--Use the extent of the first input raster to determine the processing extent.",
	"@@Bitwise-Xor_Extent-Type_tag2@@": "Intersection Of--Use the extent of the overlapping pixels to determine the processing extent. This is the default.",
	"@@Bitwise-Xor_Extent-Type_tag3@@": "Last Of--Use the extent of the last input raster to determine the processing extent.",
	"@@Bitwise-Xor_Extent-Type_tag4@@": "Union Of--Use the extent of all the rasters to determine the processing extent.",
	"@@Bitwise-Xor_Raster_tag0@@": "The first input to use in this bitwise operation.",
	"@@Bitwise-Xor_Raster_tag1@@": "A constant value can be used as an input for this parameter, provided a raster is specified for the other parameter.",
	"@@Bitwise-Xor_Raster2_tag0@@": "The second input to use in this bitwise operation.",
	"@@Bitwise-Xor_Raster2_tag1@@": "A constant value can be used as an input for this parameter, provided a raster is specified for the other parameter.",
	"@@Boolean-and_Cellsize-Type_tag0@@": "Choose which cell size to use in the output raster. If all the input cell sizes are the same, all the options will yield the same results.",
	"@@Boolean-and_Cellsize-Type_tag1@@": "First Of--Use the first cell size of the input rasters.",
	"@@Boolean-and_Cellsize-Type_tag2@@": "Last Of--Use the last cell size of the input rasters.",
	"@@Boolean-and_Cellsize-Type_tag3@@": "Max Of--Use the largest cell size of all the input rasters. This is the default.",
	"@@Boolean-and_Cellsize-Type_tag4@@": "Mean Of--Use the mean cell size of all the input rasters.",
	"@@Boolean-and_Cellsize-Type_tag5@@": "Min Of--Use the smallest cell size of all the input rasters.",
	"@@Boolean-and_Extent-Type_tag0@@": "Choose which extent should be used in the output raster:",
	"@@Boolean-and_Extent-Type_tag1@@": "First Of--Use the extent of the first input raster to determine the processing extent.",
	"@@Boolean-and_Extent-Type_tag2@@": "Intersection Of--Use the extent of the overlapping pixels to determine the processing extent. This is the default.",
	"@@Boolean-and_Extent-Type_tag3@@": "Last Of--Use the extent of the last input raster to determine the processing extent.",
	"@@Boolean-and_Extent-Type_tag4@@": "Union Of--Use the extent of all the rasters to determine the processing extent.",
	"@@Boolean-and_Raster_tag0@@": "The first input to use in this Boolean operation.",
	"@@Boolean-and_Raster_tag1@@": "A constant value can be used as an input for this parameter, provided a raster is specified for the other parameter.",
	"@@Boolean-and_Raster2_tag0@@": "The second input to use in this Boolean operation.",
	"@@Boolean-and_Raster2_tag1@@": "A constant value can be used as an input for this parameter, provided a raster is specified for the other parameter.",
	"@@Boolean-Not_Cellsize-Type_tag0@@": "Choose which cell size to use in the output raster. If all the input cell sizes are the same, all the options will yield the same results.",
	"@@Boolean-Not_Cellsize-Type_tag1@@": "First Of--Use the first cell size of the input rasters.",
	"@@Boolean-Not_Cellsize-Type_tag2@@": "Last Of--Use the last cell size of the input rasters.",
	"@@Boolean-Not_Cellsize-Type_tag3@@": "Max Of--Use the largest cell size of all the input rasters. This is the default.",
	"@@Boolean-Not_Cellsize-Type_tag4@@": "Mean Of--Use the mean cell size of all the input rasters.",
	"@@Boolean-Not_Cellsize-Type_tag5@@": "Min Of--Use the smallest cell size of all the input rasters.",
	"@@Boolean-Not_Extent-Type_tag0@@": "Choose which extent should be used in the output raster:",
	"@@Boolean-Not_Extent-Type_tag1@@": "First Of--Use the extent of the first input raster to determine the processing extent.",
	"@@Boolean-Not_Extent-Type_tag2@@": "Intersection Of--Use the extent of the overlapping pixels to determine the processing extent. This is the default.",
	"@@Boolean-Not_Extent-Type_tag3@@": "Last Of--Use the extent of the last input raster to determine the processing extent.",
	"@@Boolean-Not_Extent-Type_tag4@@": "Union Of--Use the extent of all the rasters to determine the processing extent.",
	"@@Boolean-Not_Raster_tag0@@": "The first input to use in this Boolean operation.",
	"@@Boolean-Or_Cellsize-Type_tag0@@": "Choose which cell size to use in the output raster. If all the input cell sizes are the same, all the options will yield the same results.",
	"@@Boolean-Or_Cellsize-Type_tag1@@": "First Of--Use the first cell size of the input rasters.",
	"@@Boolean-Or_Cellsize-Type_tag2@@": "Last Of--Use the last cell size of the input rasters.",
	"@@Boolean-Or_Cellsize-Type_tag3@@": "Max Of--Use the largest cell size of all the input rasters. This is the default.",
	"@@Boolean-Or_Cellsize-Type_tag4@@": "Mean Of--Use the mean cell size of all the input rasters.",
	"@@Boolean-Or_Cellsize-Type_tag5@@": "Min Of--Use the smallest cell size of all the input rasters.",
	"@@Boolean-Or_Extent-Type_tag0@@": "Choose which extent should be used in the output raster:",
	"@@Boolean-Or_Extent-Type_tag1@@": "First Of--Use the extent of the first input raster to determine the processing extent.",
	"@@Boolean-Or_Extent-Type_tag2@@": "Intersection Of--Use the extent of the overlapping pixels to determine the processing extent. This is the default.",
	"@@Boolean-Or_Extent-Type_tag3@@": "Last Of--Use the extent of the last input raster to determine the processing extent.",
	"@@Boolean-Or_Extent-Type_tag4@@": "Union Of--Use the extent of all the rasters to determine the processing extent.",
	"@@Boolean-Or_Raster_tag0@@": "The first input to use in this Boolean operation.",
	"@@Boolean-Or_Raster_tag1@@": "A constant value can be used as an input for this parameter, provided a raster is specified for the other parameter.",
	"@@Boolean-Or_Raster2_tag0@@": "The second input to use in this Boolean operation.",
	"@@Boolean-Or_Raster2_tag1@@": "A constant value can be used as an input for this parameter, provided a raster is specified for the other parameter.",
	"@@Boolean-Xor_Cellsize-Type_tag0@@": "Choose which cell size to use in the output raster. If all the input cell sizes are the same, all the options will yield the same results.",
	"@@Boolean-Xor_Cellsize-Type_tag1@@": "First Of--Use the first cell size of the input rasters.",
	"@@Boolean-Xor_Cellsize-Type_tag2@@": "Last Of--Use the last cell size of the input rasters.",
	"@@Boolean-Xor_Cellsize-Type_tag3@@": "Max Of--Use the largest cell size of all the input rasters. This is the default.",
	"@@Boolean-Xor_Cellsize-Type_tag4@@": "Mean Of--Use the mean cell size of all the input rasters.",
	"@@Boolean-Xor_Cellsize-Type_tag5@@": "Min Of--Use the smallest cell size of all the input rasters.",
	"@@Boolean-Xor_Extent-Type_tag0@@": "Choose which extent should be used in the output raster:",
	"@@Boolean-Xor_Extent-Type_tag1@@": "First Of--Use the extent of the first input raster to determine the processing extent.",
	"@@Boolean-Xor_Extent-Type_tag2@@": "Intersection Of--Use the extent of the overlapping pixels to determine the processing extent. This is the default.",
	"@@Boolean-Xor_Extent-Type_tag3@@": "Last Of--Use the extent of the last input raster to determine the processing extent.",
	"@@Boolean-Xor_Extent-Type_tag4@@": "Union Of--Use the extent of all the rasters to determine the processing extent.",
	"@@Boolean-Xor_Raster_tag0@@": "The first input to use in this Boolean operation.",
	"@@Boolean-Xor_Raster_tag1@@": "A constant value can be used as an input for this parameter, provided a raster is specified for the other parameter.",
	"@@Boolean-Xor_Raster2_tag0@@": "The second input to use in this Boolean operation.",
	"@@Boolean-Xor_Raster2_tag1@@": "A constant value can be used as an input for this parameter, provided a raster is specified for the other parameter.",
	"@@Buffered_Raster_tag0@@": "The input raster to be stored in memory.",
	"@@Calculator_Cellsize-Type_tag0@@": "The cell size used to create the output raster.",
	"@@Calculator_Cellsize-Type_tag1@@": "You can choose the output cell size from the following options in the drop down list:",
	"@@Calculator_Cellsize-Type_tag2@@": "<strong>First Of</strong>--The cellsize of the first raster variable.",
	"@@Calculator_Cellsize-Type_tag4@@": "<strong>Min Of</strong>--The minimum cellsize of the input rasters.",
	"@@Calculator_Cellsize-Type_tag6@@": "<strong>Max Of</strong>--The maximum cellsize of the input rasters.",
	"@@Calculator_Cellsize-Type_tag8@@": "<strong>Mean Of</strong>--The average cellsize of the input rasters.",
	"@@Calculator_Cellsize-Type_tag10@@": "<strong>Last Of</strong>--The cellsize of the last raster variable.",
	"@@Calculator_Cellsize-Type_tag12@@": "The default selection is <strong>Max Of</strong>.",
	"@@Calculator_Expression_tag0@@": "Build an algebraic expression to perform spatial analysis on the input raster.",
	"@@Calculator_Expression_tag1@@": "All existing math functions can be called to build the expression. The available operators are listed below.",
	"@@Calculator_Expression_tag2@@": "Arithmetic Operations",
	"@@Calculator_Expression_tag3@@": "Addition: +",
	"@@Calculator_Expression_tag4@@": "Division: /",
	"@@Calculator_Expression_tag5@@": "Modulo: %",
	"@@Calculator_Expression_tag6@@": "Multiplication: *",
	"@@Calculator_Expression_tag7@@": "Power: **",
	"@@Calculator_Expression_tag8@@": "Subtraction: -",
	"@@Calculator_Expression_tag9@@": "Boolean Operations",
	"@@Calculator_Expression_tag10@@": "Boolean And: &&",
	"@@Calculator_Expression_tag11@@": "Boolean Or: ||",
	"@@Calculator_Expression_tag12@@": "Relation Operations",
	"@@Calculator_Expression_tag13@@": "Equal to: ==",
	"@@Calculator_Expression_tag14@@": "Greater than: >",
	"@@Calculator_Expression_tag15@@": "Greater than or Equal to: >=",
	"@@Calculator_Expression_tag16@@": "Less than: <",
	"@@Calculator_Expression_tag17@@": "Less than or Equal to: <=",
	"@@Calculator_Expression_tag18@@": "Not Equal to: !=",
	"@@Calculator_Expression_tag19@@": "Additional Operations",
	"@@Calculator_Expression_tag20@@": "Minimum of two rasters on a per-pixel basis: min(a,b)",
	"@@Calculator_Expression_tag21@@": "Maximum of two rasters on a per-pixel basis: max(a,b)",
	"@@Calculator_Expression_tag22@@": "Here are some examples of expressions:",
	"@@Calculator_Expression_tag23@@": "Simple Conditional Statement: in a raster (denoted by T) find elevation values above 4,000 feet and give these areas a value of 1 and all other areas a value of 0.",
	"@@Calculator_Expression_tag24@@": "Con(T > 4000, 1, 0)",
	"@@Calculator_Expression_tag25@@": "Nested Conditional Statement: find areas where slope (denoted by b1)) is below 10 degrees and NDVI (denoted by b2) is above 0.5, and give these areas a value of 1. For all other areas, assign a value of 2 if slope is above 10 degrees and elevation (denoted by b3) is over 2,500 feet. All other areas are assigned a value of 3.",
	"@@Calculator_Expression_tag26@@": "Con((b1 < 10 && b2 > .5, 1, Con(b1 > 10 && b3 > 2500, 2, 3)))",
	"@@Calculator_extenttype_tag0@@": "<p>Choose which extent should be used in the output raster:</p><ul><li><p>First Of--Use the extent of the first input raster to determine the processing extent.</p></li><li>Intersection Of--Use the extent of the overlapping pixels to determine the processing extent. This is the default.</li><li>Union Of--Use the extent of all the rasters to determine the processing extent.</li><li>Last Of--Use the extent of the last input raster to determine the processing extent.</li></ul>",
	"@@Calculator_Raster-Variables_tag0@@": "The user-defined variable name and the input raster.",
	"@@Classify_Input-Definition-File_tag0@@": "The input Esri Classifier Definition (${.ecd}) file that contains the statistics and other classification information for the specific dataset, classifier, and chosen attributes.",
	"@@Classify_Raster_tag0@@": "The raster dataset you want to classify.",
	"@@Classify_Raster2_tag0@@": "An optional ancillary raster dataset to incorporate into the classifier, such as a segmented image, multispectral image, or elevation data, used to generate a more robust classification definition for your dataset. The raster dataset for this parameter must match the one used to create the input Esri Classifier Definition file.",
	"@@Clip_Clipping-Geometry-or-Raster_tag0@@": "The following can be used to specify the clipping extent:",
	"@@Clip_Clipping-Geometry-or-Raster_tag1@@": "<strong>Clipping Raster</strong>--Extent of the clipping raster",
	"@@Clip_Clipping-Geometry-or-Raster_tag3@@": "<strong>Custom Extent</strong>--X and Y minimum and maximum coordinates",
	"@@Clip_Clipping-Geometry-or-Raster_tag5@@": "<strong>Current Map Extent</strong>--Extent of the current map display",
	"@@Clip_Clipping-Raster_tag0@@": "The raster layer used to clip.",
	"@@Clip_Clipping-Type_tag0@@": "Specify whether you want to retain the area inside or outside your clip geometry.",
	"@@Clip_Clipping-Type_tag1@@": "<strong>Clip Inside</strong>--Imagery inside the clip extents will be removed.",
	"@@Clip_Clipping-Type_tag3@@": "<strong>Clip Outside</strong>--Imagery outside the clip extents will be removed.",
	"@@Clip_Custom-Extent_tag0@@": "Specify the four coordinates that define the extent of the bounding box used to clip the raster.",
	"@@Clip_Output-Extent_tag0@@": "The x and y coordinates of the current clipping extent.",
	"@@Clip_Output-Extent_tag1@@": "The <strong>Capture Current Map Extent</strong> button uses the display extent for the active map.",
	"@@Clip_Raster_tag0@@": "The input raster layer.",
	"@@Clip_Use-Input-Features-for-Clipping-Geometry_tag0@@": "When selected, the data is clipped according to the geometry of the specified feature class.",
	"@@Clip_Use-Input-Features-for-Clipping-Geometry_tag1@@": "Unchecked--The function uses the clip geometry specified by <strong>Rectangle</strong>. This is the default.",
	"@@Clip_Use-Input-Features-for-Clipping-Geometry_tag4@@": "Checked--The function uses the clip geometry defined by a feature class.",
	"@@Color-Model-Conversion_Conversion-Type_tag0@@": "The color conversion type to perform:",
	"@@Color-Model-Conversion_Conversion-Type_tag1@@": "HSV to RGB",
	"@@Color-Model-Conversion_Conversion-Type_tag2@@": "RGB to HSV",
	"@@Color-Model-Conversion_Raster_tag0@@": "The input raster.",
	"@@Colormap_Color-Ramp_tag0@@": "Choose a pre-existing color ramp.",
	"@@Colormap_Color-Scheme-Type_tag0@@": "Choose the type of color scheme to render your input raster",
	"@@Colormap_Color-Scheme-Type_tag1@@": "Color Ramp--Use a color ramp.",
	"@@Colormap_Color-Scheme-Type_tag2@@": "Colormap--Use a pre-existing color map.",
	"@@Colormap_Colormap_tag0@@": "The following default color maps are available from the drop-down list:",
	"@@Colormap_Colormap_tag1@@": "Elevation--A color map that gradually changes from cyan to purple to black.",
	"@@Colormap_Colormap_tag2@@": "Gray--A color map that gradually changes from black to white.",
	"@@Colormap_Colormap_tag7@@": "Hillshade--A greyscale colormap to visualize a 3D representation of the terrain surface, with the sun's relative position taken into account for shading the image.",
	"@@Colormap_Colormap_tag3@@": "NDVI--A colormap to visualize vegetation. Values near zero are blue. Low values are brown. Then the colors gradually change from red, to orange, to yellow, to green, and to black as the vegetation index goes from low to high.",
	"@@Colormap_Colormap_tag4@@": "NDVI2--A colormap to visualize vegetation. Low values range from white to green. Then the colors range from gray, to purple, to violet, to dark blue, and to black as the vegetation index goes from low to high.",
	"@@Colormap_Colormap_tag5@@": "NDVI3--A colormap to visualize vegetation. Values near zero are blue. Then the colors gradually change from red, to orange, and to green as the vegetation index goes from low to high.",
	"@@Colormap_Colormap_tag6@@": "Random--A random colormap.",
	"@@Colormap_Raster_tag0@@": "The input raster.",
	"@@Colormap-To-RGB_Raster_tag0@@": "The input color map raster.",
	"@@Complex_Raster_tag0@@": "The input raster.",
	"@@Composite-Bands_Rasters_tag0@@": "Use the drop-down list or the <strong>Browse</strong> button to choose the raster inputs.",
	"@@Composite-Bands_cellsizetype_tag0@@": "<p>Choose which cell size to use in the output raster.If all the input cell sizes are the same, all the options willyield the same results.</p><ul><li>First Of--Use the first cell size of the input rasters.</li><li>Min Of--Use the smallest cell size of all the input rasters.</li><li>Max Of--Use the largest cell size of all the input rasters. This is the default.</li><li>Mean Of--Use the mean cell size of all the input rasters.</li><li>Last Of--Use the last cell size of the input rasters.</li></ul>",
	"@@Con-function_Cellsize-Type_tag0@@": "Choose which cell size to use in the output raster. If all the input cell sizes are the same, all the options will yield the same results.",
	"@@Con-function_Cellsize-Type_tag1@@": "First Of--Use the first cell size of the input rasters.",
	"@@Con-function_Cellsize-Type_tag2@@": "Last Of--Use the last cell size of the input rasters.",
	"@@Con-function_Cellsize-Type_tag3@@": "Max Of--Use the largest cell size of all the input rasters. This is the default.",
	"@@Con-function_Cellsize-Type_tag4@@": "Mean Of--Use the mean cell size of all the input rasters.",
	"@@Con-function_Cellsize-Type_tag5@@": "Min Of--Use the smallest cell size of all the input rasters.",
	"@@Con_Extent-Type_tag0@@": "Choose which extent should be used in the output raster:",
	"@@Con_Extent-Type_tag1@@": "First Of--Use the extent of the first input raster to determine the processing extent.",
	"@@Con_Extent-Type_tag2@@": "Intersection Of--Use the extent of the overlapping pixels to determine the processing extent. This is the default.",
	"@@Con_Extent-Type_tag3@@": "Last Of--Use the extent of the last input raster to determine the processing extent.",
	"@@Con_Extent-Type_tag4@@": "Union Of--Use the extent of all the rasters to determine the processing extent.",
	"@@Con_False-Raster_tag0@@": "The input whose values will be used as the output pixel values if the condition is false. It can be an integer, a floating-point raster, or a constant value.",
	"@@Con_Raster_tag0@@": "The input raster that represents the Boolean result of a logical math raster function. The values will be either 1 (for true) or 0 (for false). It can be an integer or a floating-point raster.",
	"@@Con_True-Raster_tag0@@": "The input whose values will be used as the output pixel values if the condition is true. It can be an integer, a floating-point raster, or a constant value.",
	"@@Constant_Constant_tag0@@": "The value of the constant to be added to the virtual raster.",
	"@@Constant_Raster-Info_tag0@@": "Use the <strong>Load template raster</strong> button to load a template from a directory or portal.",
	"@@Contour_Adaptive-Smoothing_tag0@@": "The amount of smoothing to apply to the contour line. The default value is 2.5.",
	"@@Contour_Adaptive-Smoothing_tag1@@": "A lower value produces a contour line with more granularity and less smoothing, while a higher value produces a contour line with more smoothing that appears less jagged.",
	"@@Contour_Contour-Interval_tag0@@": "The difference in altitude between contour lines.",
	"@@Contour_Contour-Interval_tag1@@": "A small contour interval is used in relatively flat areas, while larger contour intervals are used in variable or mountainous terrain.",
	"@@Contour_Contour-Type_tag0@@": "The type of contour to be created:",
	"@@Contour_Contour-Type_tag1@@": "<strong>Contour fill</strong>--Fills the area between every contour line with the quantized elevation value.",
	"@@Contour_Contour-Type_tag3@@": "<strong>Contour lines</strong>--Joins points of equal elevation to create a line representing constant elevation.",
	"@@Contour_Contour-Type_tag5@@": "<strong>Smooth surface only</strong>--Smooths the input elevation layer but does not produce contours.",
	"@@Contour_Nth-Contour-Line-In-Bold_tag0@@": "The index contour, which is represented as a bold line.",
	"@@Contour_Nth-Contour-Line-In-Bold_tag1@@": "The default value is 5; thus, every 5th contour line is bold.",
	"@@Contour_Number-Of-Contours_tag0@@": "The number of contours to be generated in the display. This dynamically adjusts the contour interval to fit the terrain in the display while maintaining standardized intervals such as 1, 5, 10, and so on.",
	"@@Contour_Raster_tag0@@": "A single band raster elevation dataset.",
	"@@Contour_Z-Base_tag0@@": "The base contour value. Contours are generated above and below this value as needed to cover the entire value range of the input raster. The default is 0.",
	"@@Contour_Z-Base_tag1@@": "A value of 0 often represents mean sea level, depending on the source elevation dataset.",
	"@@Contour_Z-Factor_tag0@@": "The unit conversion factor used when generating contours. The default value is 1.",
	"@@Contour_Z-Factor_tag1@@": "The contour lines are generated based on the z-values in the input raster, which are often measured in units of meters or feet. With the default value of 1, the contours will be in the same units as the z-values of the input raster. To create contours in a different unit than that of the z-values, set an appropriate value for the z-factor. Note that it is not necessary to have the ground x,y and surface z-units be consistent for this tool.",
	"@@Contour_Z-Factor_tag2@@": "For example, if the elevation values in your input raster are in feet, but you want the contours to be generated based on units of meters, set the z-factor to 0.3048 (since 1 foot =0.3048 meters).",
	"@@Contrast-and-Brightness_Brightness-Offset_tag0@@": "Adjust the brightness of the raster layer.",
	"@@Contrast-and-Brightness_Brightness-Offset_tag1@@": "You can use the slider to modify the brightness offset, or you can type a value.",
	"@@Contrast-and-Brightness_Contrast-Offset_tag0@@": "Adjust the contrast of the raster layer.",
	"@@Contrast-and-Brightness_Contrast-Offset_tag1@@": "You can use the slider to modify the contrast offset, or you can type a value.",
	"@@Contrast-and-Brightness_Raster_tag0@@": "The input raster on which to edit the brightness and contrast.",
	"@@Convolution_kernel_tag0@@": "<p>This table shows how each pixel will be weighted in the filtering process. This table can be edited if you choose<strong>User Defined</strong>as the<strong>Type</strong>.</p>",
	"@@Convolution_Raster_tag0@@": "The input raster dataset.",
	"@@Convolution_Type_tag0@@": "Select the type of filtering you want to perform. There are options for sharpening, blurring, and detecting edges, or you can define your own kernel-based filter",
	"@@Corridor_Distance-Raster-1_tag0@@": "The first input distance raster. It should be an accumulated cost distance output from Cost Distance or Path Distance.",
	"@@Corridor_Distance-Raster-2_tag0@@": "The second input distance raster. It should be an accumulated cost distance output from Cost Distance or Path Distance.",
	"@@Cos_Cellsize-Type_tag0@@": "Choose which cell size to use in the output raster. If all the input cell sizes are the same, all the options will yield the same results.",
	"@@Cos_Cellsize-Type_tag1@@": "First Of--Use the first cell size of the input rasters.",
	"@@Cos_Cellsize-Type_tag2@@": "Last Of--Use the last cell size of the input rasters.",
	"@@Cos_Cellsize-Type_tag3@@": "Max Of--Use the largest cell size of all the input rasters. This is the default.",
	"@@Cos_Cellsize-Type_tag4@@": "Mean Of--Use the mean cell size of all the input rasters.",
	"@@Cos_Cellsize-Type_tag5@@": "Min Of--Use the smallest cell size of all the input rasters.",
	"@@Cos_Extent-Type_tag0@@": "Choose which extent should be used in the output raster:",
	"@@Cos_Extent-Type_tag1@@": "First Of--Use the extent of the first input raster to determine the processing extent.",
	"@@Cos_Extent-Type_tag2@@": "Intersection Of--Use the extent of the overlapping pixels to determine the processing extent. This is the default.",
	"@@Cos_Extent-Type_tag3@@": "Last Of--Use the extent of the last input raster to determine the processing extent.",
	"@@Cos_Extent-Type_tag4@@": "Union Of--Use the extent of all the rasters to determine the processing extent.",
	"@@Cos_Raster_tag0@@": "The input for which to calculate the cosine values.",
	"@@CosH_Cellsize-Type_tag0@@": "Choose which cell size to use in the output raster. If all the input cell sizes are the same, all the options will yield the same results.",
	"@@CosH_Cellsize-Type_tag1@@": "First Of--Use the first cell size of the input rasters.",
	"@@CosH_Cellsize-Type_tag2@@": "Last Of--Use the last cell size of the input rasters.",
	"@@CosH_Cellsize-Type_tag3@@": "Max Of--Use the largest cell size of all the input rasters. This is the default.",
	"@@CosH_Cellsize-Type_tag4@@": "Mean Of--Use the mean cell size of all the input rasters.",
	"@@CosH_Cellsize-Type_tag5@@": "Min Of--Use the smallest cell size of all the input rasters.",
	"@@CosH_Extent-Type_tag0@@": "Choose which extent should be used in the output raster:",
	"@@CosH_Extent-Type_tag1@@": "First Of--Use the extent of the first input raster to determine the processing extent.",
	"@@CosH_Extent-Type_tag2@@": "Intersection Of--Use the extent of the overlapping pixels to determine the processing extent. This is the default.",
	"@@CosH_Extent-Type_tag3@@": "Last Of--Use the extent of the last input raster to determine the processing extent.",
	"@@CosH_Extent-Type_tag4@@": "Union Of--Use the extent of all the rasters to determine the processing extent.",
	"@@CosH_Raster_tag0@@": "The input for which to calculate the hyperbolic cosine values.",
	"@@Cost-Allocation_Accumulative-Cost-Resistance-Rate_tag0@@": "This parameter simulates the increase in the effort to overcome costs as the accumulative cost increases. It is used to model fatigue of the traveler. The growing accumulative cost to reach a cell is multiplied by the resistance rate and added to the cost to move into the subsequent cell.",
	"@@Cost-Allocation_Accumulative-Cost-Resistance-Rate_tag1@@": "It's a modified version of a compound interest rate formula that's used to calculate the apparent cost of moving through a cell. As the value of the resistance rate increases, it increases the cost of the cells that are visited later. The greater the resistance rate, the higher the cost to reach the next cell, which is compounded for each subsequent movement. Since the resistance rate is similar to a compound rate and generally the accumulative cost values are very large, small resistance rates are suggested, such as 0.005 or even smaller, depending on the accumulative cost values.",
	"@@Cost-Allocation_Accumulative-Cost-Resistance-Rate_tag2@@": "The value must be greater than zero. The default capacity is to the edge of the output raster.",
	"@@Cost-Allocation_Accumulative-Cost-Resistance-Rate_tag3@@": "A numeric (double) value or a field from the <strong>Source Raster</strong> can be used for this parameter.",
	"@@Cost-Allocation_Capacity_tag0@@": "Defines the cost capacity for the traveler for a source. The cost calculations continue for each source until the specified capacity is reached.",
	"@@Cost-Allocation_Capacity_tag1@@": "The value must be greater than zero. The default capacity is to the edge of the output raster.",
	"@@Cost-Allocation_Capacity_tag2@@": "A numeric (double) value or a field from the <strong>Source Raster</strong> can be used for this parameter.",
	"@@Cost-Allocation_Cost-Raster_tag0@@": "A required input raster defining the cost or impedance to move planimetrically through each cell. The value at each cell location represents the cost-per-unit distance for moving through it. Each cell location value is multiplied by the cell resolution, and also compensates for diagonal movement to obtain the total cost of passing through the cell.",
	"@@Cost-Allocation_Cost-Raster_tag1@@": "The values of the <strong>Cost Raster</strong> can be integer or floating point, but they cannot be negative or zero.",
	"@@Cost-Allocation_Maximum-Distance_tag0@@": "The threshold that the accumulative cost values cannot exceed. If an accumulative cost distance exceeds this value, the output value for the cell location will be ${NoData}. The maximum distance defines the extent for which the accumulative cost distances are calculated. The default distance is to the extent of the output raster.",
	"@@Cost-Allocation_Multiplier-to-Apply-to-Costs_tag0@@": "A multiplier to apply to the cost values.",
	"@@Cost-Allocation_Multiplier-to-Apply-to-Costs_tag1@@": "This parameter allows for control of the mode of travel or the magnitude at a source. The greater the multiplier, the greater the cost to move through each cell.",
	"@@Cost-Allocation_Multiplier-to-Apply-to-Costs_tag2@@": "The values must be greater than zero. The default is 1.",
	"@@Cost-Allocation_Multiplier-to-Apply-to-Costs_tag3@@": "A numeric (double) value or a field from the <strong>Source Raster</strong> can be used for this parameter.",
	"@@Cost-Allocation_Source-Field_tag0@@": "The field used to assign values to the source locations. It must be an integer type. If the <strong>Value Raster</strong> has been set, the values in that input will take precedence over any setting for the <strong>Source Field</strong>.",
	"@@Cost-Allocation_Source-Raster_tag0@@": "The required input raster of source locations.",
	"@@Cost-Allocation_Source-Raster_tag1@@": "This is a raster that identifies the cells or locations from which the least accumulated cost distance for every output cell location is calculated.",
	"@@Cost-Allocation_Source-Raster_tag2@@": "If the input <strong>Source Raster</strong> is floating point, the <strong>Value Raster</strong> must be set, and it must be an integer. The <strong>Value Raster</strong> will take precedence over any setting of the <strong>Source Field</strong>.",
	"@@Cost-Allocation_Start-Cost_tag0@@": "The starting cost from which to begin the cost calculations. This parameter allows for the specification of the fixed cost associated with a source. Instead of starting at a cost of 0, the cost algorithm will begin with the value specified.",
	"@@Cost-Allocation_Start-Cost_tag1@@": "The value must be zero or greater. The default is 0.",
	"@@Cost-Allocation_Travel-Direction_tag0@@": "Defines the direction of the traveler when applying the source resistance rate and the source starting cost.",
	"@@Cost-Allocation_Travel-Direction_tag1@@": "<strong>From Source</strong>--The source resistance rate and source starting cost will be applied beginning at the input source and moving out to the non-source cells. This is the default.",
	"@@Cost-Allocation_Travel-Direction_tag3@@": "<strong>To Source</strong>--The source resistance rate and source starting cost will be applied beginning at each non-source cell and moving back to the input source.",
	"@@Cost-Allocation_Travel-Direction_tag5@@": "Either specify the <strong>From Source</strong> or <strong>To Source</strong> keyword, which will be applied to all sources, or specify a field in the <strong>Source Raster</strong> that contains the keywords to identify the direction of travel for each source. That field must contain the string ${FROM_SOURCE} or ${TO_SOURCE}.",
	"@@Cost-Allocation_Value-Raster_tag0@@": "The input integer raster that identifies the zone values to be used for each input source location. For each source location cell, the value defined by the <strong>Value Raster</strong> will be assigned to all cells allocated to the source location for the computation. The <strong>Value Raster</strong> will take precedence over any setting for the <strong>Source Field</strong>.",
	"@@Cost-Back-Link_Accumulative-Cost-Resistance-Rate_tag0@@": "This parameter simulates the increase in the effort to overcome costs as the accumulative cost increases. It is used to model fatigue of the traveler. The growing accumulative cost to reach a cell is multiplied by the resistance rate and added to the cost to move into the subsequent cell.",
	"@@Cost-Back-Link_Accumulative-Cost-Resistance-Rate_tag1@@": "It's a modified version of a compound interest rate formula that's used to calculate the apparent cost of moving through a cell. As the value of the resistance rate increases, it increases the cost of the cells that are visited later. The greater the resistance rate, the higher the cost to reach the next cell, which is compounded for each subsequent movement. Since the resistance rate is similar to a compound rate and generally the accumulative cost values are very large, small resistance rates are suggested, such as 0.005 or even smaller, depending on the accumulative cost values.",
	"@@Cost-Back-Link_Accumulative-Cost-Resistance-Rate_tag2@@": "The value must be greater than zero. The default capacity is to the edge of the output raster.",
	"@@Cost-Back-Link_Accumulative-Cost-Resistance-Rate_tag3@@": "A numeric (double) value or a field from the <strong>Source Raster</strong> can be used for this parameter.",
	"@@Cost-Back-Link_Capacity_tag0@@": "Defines the cost capacity for the traveler for a source. The cost calculations continue for each source until the specified capacity is reached.",
	"@@Cost-Back-Link_Capacity_tag1@@": "The value must be greater than zero. The default capacity is to the edge of the output raster.",
	"@@Cost-Back-Link_Capacity_tag2@@": "A numeric (double) value or a field from the <strong>Source Raster</strong> can be used for this parameter.",
	"@@Cost-Back-Link_Cost-Raster_tag0@@": "A required input raster defining the cost or impedance to move planimetrically through each cell. The value at each cell location represents the cost-per-unit distance for moving through it. Each cell location value is multiplied by the cell resolution, and also compensates for diagonal movement to obtain the total cost of passing through the cell.",
	"@@Cost-Back-Link_Cost-Raster_tag1@@": "The values of the <strong>Cost Raster</strong> can be integer or floating point, but they cannot be negative or zero.",
	"@@Cost-Back-Link_Maximum-Distance_tag0@@": "The threshold that the accumulative cost values cannot exceed. If an accumulative cost distance exceeds this value, the output value for the cell location will be NoData. The maximum distance defines the extent for which the accumulative cost distances are calculated. The default distance is to the extent of the output raster.",
	"@@Cost-Back-Link_Multiplier-to-Apply-to-Costs_tag0@@": "A multiplier to apply to the cost values.",
	"@@Cost-Back-Link_Multiplier-to-Apply-to-Costs_tag1@@": "This parameter allows for control of the mode of travel or the magnitude at a source. The greater the multiplier, the greater the cost to move through each cell.",
	"@@Cost-Back-Link_Multiplier-to-Apply-to-Costs_tag2@@": "The values must be greater than zero. The default is 1.",
	"@@Cost-Back-Link_Multiplier-to-Apply-to-Costs_tag3@@": "A numeric (double) value or a field from the <strong>Source Raster</strong> can be used for this parameter.",
	"@@Cost-Back-Link_Source-Raster_tag0@@": "The required input raster of source locations.",
	"@@Cost-Back-Link_Source-Raster_tag1@@": "This is a raster that identifies the cells or locations from which the least accumulated cost distance for every output cell location is calculated.",
	"@@Cost-Back-Link_Start-Cost_tag0@@": "The starting cost from which to begin the cost calculations. This parameter allows for the specification of the fixed cost associated with a source. Instead of starting at a cost of 0, the cost algorithm will begin with the value specified.",
	"@@Cost-Back-Link_Start-Cost_tag1@@": "The value must be zero or greater. The default is 0.",
	"@@Cost-Back-Link_Travel-Direction_tag0@@": "Defines the direction of the traveler when applying the source resistance rate and the source starting cost.",
	"@@Cost-Back-Link_Travel-Direction_tag1@@": "<strong>From Source</strong>--The source resistance rate and source starting cost will be applied beginning at the input source and moving out to the non-source cells. This is the default.",
	"@@Cost-Back-Link_Travel-Direction_tag3@@": "<strong>To Source</strong>--The source resistance rate and source starting cost will be applied beginning at each non-source cell and moving back to the input source.",
	"@@Cost-Back-Link_Travel-Direction_tag5@@": "Either specify the <strong>From Source</strong> or <strong>To Source</strong> keyword, which will be applied to all sources, or specify a field in the <strong>Source Raster</strong> that contains the keywords to identify the direction of travel for each source. That field must contain the string ${FROM_SOURCE} or ${TO_SOURCE}.",
	"@@Cost-Distance_Accumulative-Cost-Resistance-Rate_tag0@@": "This parameter simulates the increase in the effort to overcome costs as the accumulative cost increases. It is used to model fatigue of the traveler. The growing accumulative cost to reach a cell is multiplied by the resistance rate and added to the cost to move into the subsequent cell.",
	"@@Cost-Distance_Accumulative-Cost-Resistance-Rate_tag1@@": "It's a modified version of a compound interest rate formula that's used to calculate the apparent cost of moving through a cell. As the value of the resistance rate increases, it increases the cost of the cells that are visited later. The greater the resistance rate, the higher the cost to reach the next cell, which is compounded for each subsequent movement. Since the resistance rate is similar to a compound rate and generally the accumulative cost values are very large, small resistance rates are suggested, such as 0.005 or even smaller, depending on the accumulative cost values.",
	"@@Cost-Distance_Accumulative-Cost-Resistance-Rate_tag2@@": "The value must be greater than zero. The default capacity is to the edge of the output raster.",
	"@@Cost-Distance_Accumulative-Cost-Resistance-Rate_tag3@@": "A numeric (double) value or a field from the <strong>Source Raster</strong> can be used for this parameter.",
	"@@Cost-Distance_Capacity_tag0@@": "Defines the cost capacity for the traveler for a source. The cost calculations continue for each source until the specified capacity is reached.",
	"@@Cost-Distance_Capacity_tag1@@": "The value must be greater than zero. The default capacity is to the edge of the output raster.",
	"@@Cost-Distance_Capacity_tag2@@": "A numeric (double) value or a field from the <strong>Source Raster</strong> can be used for this parameter.",
	"@@Cost-Distance_Cost-Raster_tag0@@": "A required input raster defining the cost or impedance to move planimetrically through each cell. The value at each cell location represents the cost-per-unit distance for moving through it. Each cell location value is multiplied by the cell resolution, and also compensates for diagonal movement to obtain the total cost of passing through the cell.",
	"@@Cost-Distance_Cost-Raster_tag1@@": "The values of the <strong>Cost Raster</strong> can be integer or floating point, but they cannot be negative or zero.",
	"@@Cost-Distance_Maximum-Distance_tag0@@": "The threshold that the accumulative cost values cannot exceed. If an accumulative cost distance exceeds this value, the output value for the cell location will be NoData. The maximum distance defines the extent for which the accumulative cost distances are calculated. The default distance is to the extent of the output raster.",
	"@@Cost-Distance_Multiplier-to-Apply-to-Costs_tag0@@": "A multiplier to apply to the cost values.",
	"@@Cost-Distance_Multiplier-to-Apply-to-Costs_tag1@@": "This parameter allows for control of the mode of travel or the magnitude at a source. The greater the multiplier, the greater the cost to move through each cell.",
	"@@Cost-Distance_Multiplier-to-Apply-to-Costs_tag2@@": "The values must be greater than zero. The default is 1.",
	"@@Cost-Distance_Multiplier-to-Apply-to-Costs_tag3@@": "A numeric (double) value or a field from the <strong>Source Raster</strong> can be used for this parameter.",
	"@@Cost-Distance_Source-Raster_tag0@@": "The required input raster of source locations.",
	"@@Cost-Distance_Source-Raster_tag1@@": "This is a raster that identifies the cells or locations from which the least accumulated cost distance for every output cell location is calculated.",
	"@@Cost-Distance_Start-Cost_tag0@@": "The starting cost from which to begin the cost calculations. This parameter allows for the specification of the fixed cost associated with a source. Instead of starting at a cost of 0, the cost algorithm will begin with the value specified.",
	"@@Cost-Distance_Start-Cost_tag1@@": "The value must be zero or greater. The default is 0.",
	"@@Cost-Distance_Travel-Direction_tag0@@": "Defines the direction of the traveler when applying the source resistance rate and the source starting cost.",
	"@@Cost-Distance_Travel-Direction_tag1@@": "<strong>From Source</strong>--The source resistance rate and source starting cost will be applied beginning at the input source and moving out to the non-source cells. This is the default.",
	"@@Cost-Distance_Travel-Direction_tag3@@": "<strong>To Source</strong>--The source resistance rate and source starting cost will be applied beginning at each non-source cell and moving back to the input source.",
	"@@Cost-Distance_Travel-Direction_tag5@@": "Either specify the <strong>From Source</strong> or <strong>To Source</strong> keyword, which will be applied to all sources, or specify a field in the <strong>Source Raster</strong> that contains the keywords to identify the direction of travel for each source. That field must contain the string ${FROM_SOURCE} or ${TO_SOURCE}.",
	"@@Curvature_Curvature-Type_tag0@@": "The curvature type accentuates different aspects of the slope. There are three curvature options:",
	"@@Curvature_Curvature-Type_tag1@@": "Planform--Is perpendicular to the direction of the maximum slope. It affects the convergence and divergence of flow across a surface.",
	"@@Curvature_Curvature-Type_tag2@@": "Profile--Is parallel to the slope and indicates the direction of maximum slope. It affects the acceleration and deceleration of flow across the surface.",
	"@@Curvature_Curvature-Type_tag3@@": "Standard--Combines both the <strong>Profile</strong> and <strong>Planform</strong> curvatures.",
	"@@Curvature_DEM_tag0@@": "A digital elevation model (DEM) raster.",
	"@@Curvature_Z-Factor_tag0@@": "The z-factor adjusts the units of measure for the z units when they are different from the x,y units of the input surface. If the x,y units and z units are in the same units of measure, the z-factor should be set to 1. The z-values of the input surface are multiplied by the z-factor when calculating the final output surface. For example, if your z units are feet and your x,y units are meters, you would use a z-factor of 0.3048 to convert your z units from feet to meters, since 1 foot = 0.3048 meters.",
	"@@Divide_Cellsize-Type_tag0@@": "Choose which cell size to use in the output raster. If all the input cell sizes are the same, all the options will yield the same results.",
	"@@Divide_Cellsize-Type_tag1@@": "First Of--Use the first cell size of the input rasters.",
	"@@Divide_Cellsize-Type_tag2@@": "Last Of--Use the last cell size of the input rasters.",
	"@@Divide_Cellsize-Type_tag3@@": "Max Of--Use the largest cell size of all the input rasters. This is the default.",
	"@@Divide_Cellsize-Type_tag4@@": "Mean Of--Use the mean cell size of all the input rasters.",
	"@@Divide_Cellsize-Type_tag5@@": "Min Of--Use the smallest cell size of all the input rasters.",
	"@@Divide_Extent-Type_tag0@@": "Choose which extent should be used in the output raster:",
	"@@Divide_Extent-Type_tag1@@": "First Of--Use the extent of the first input raster to determine the processing extent.",
	"@@Divide_Extent-Type_tag2@@": "Intersection Of--Use the extent of the overlapping pixels to determine the processing extent. This is the default.",
	"@@Divide_Extent-Type_tag3@@": "Last Of--Use the extent of the last input raster to determine the processing extent.",
	"@@Divide_Extent-Type_tag4@@": "Union Of--Use the extent of all the rasters to determine the processing extent.",
	"@@Divide_Raster_tag0@@": "The input whose value will be divided by the second input.",
	"@@Divide_Raster_tag1@@": "A number can be used as an input for this parameter, provided a raster is specified for ${Raster2}.",
	"@@Divide_Raster2_tag0@@": "The input whose value the first input will be divided by.",
	"@@Divide_Raster2_tag1@@": "A number can be used as an input for this parameter, provided a raster is specified for ${Raster}.",
	"@@Elevation-Void-Fill_DEM_tag0@@": "The input DEM.",
	"@@Elevation-Void-Fill_Max-Void-Width_tag0@@": "The maximum void width value is used to specify the largest size of a void that you want to fill. If the width or height of the bounding box around the void is larger than the maximum void width value, the void is not filled. The units of this parameter are the same as the units used in your data's spatial reference system.",
	"@@Elevation-Void-Fill_Max-Void-Width_tag1@@": "If this parameter is blank or has a value of ${0}, no maximum width will be used, and all voids will be filled. A value of ${-1} means that no void filling will occur.",
	"@@Elevation-Void-Fill_Short-Range-IDW-Radius_tag0@@": "The maximum search radius that will be used for void filling. A void that is further away, from any valid pixel, than this threshold value will remain as a void. The units of this parameter are the same as the units used in your data's spatial reference system.",
	"@@Elevation-Void-Fill_Short-Range-IDW-Radius_tag1@@": "If the value of this parameter is blank, ${0}, or ${-1} this parameter will not be used.",
	"@@Equal-to_Cellsize-Type_tag0@@": "Choose which cell size to use in the output raster. If all the input cell sizes are the same, all the options will yield the same results.",
	"@@Equal-to_Cellsize-Type_tag1@@": "First Of--Use the first cell size of the input rasters.",
	"@@Equal-to_Cellsize-Type_tag2@@": "Last Of--Use the last cell size of the input rasters.",
	"@@Equal-to_Cellsize-Type_tag3@@": "Max Of--Use the largest cell size of all the input rasters. This is the default.",
	"@@Equal-to_Cellsize-Type_tag4@@": "Mean Of--Use the mean cell size of all the input rasters.",
	"@@Equal-to_Cellsize-Type_tag5@@": "Min Of--Use the smallest cell size of all the input rasters.",
	"@@Equal-to_Extent-Type_tag0@@": "Choose which extent should be used in the output raster:",
	"@@Equal-to_Extent-Type_tag1@@": "First Of--Use the extent of the first input raster to determine the processing extent.",
	"@@Equal-to_Extent-Type_tag2@@": "Intersection Of--Use the extent of the overlapping pixels to determine the processing extent. This is the default.",
	"@@Equal-to_Extent-Type_tag3@@": "Last Of--Use the extent of the last input raster to determine the processing extent.",
	"@@Equal-to_Extent-Type_tag4@@": "Union Of--Use the extent of all the rasters to determine the processing extent.",
	"@@Equal-to_Raster_tag0@@": "The input that will be used for comparison for equality by the second input.",
	"@@Equal-to_Raster_tag1@@": "A constant value can be used as an input for this parameter, provided a raster is specified for the other parameter.",
	"@@Equal-to_Raster2_tag0@@": "The input that will be used for comparison for equality by the first input.",
	"@@Equal-to_Raster2_tag1@@": "A constant value can be used as an input for this parameter, provided a raster is specified for the other parameter.",
	"@@Euclidean-Allocation_Cellsize_tag0@@": "The cell size at which the output raster will be created.",
	"@@Euclidean-Allocation_Cellsize_tag1@@": "If the cell size was explicitly set in <strong>Analysis Environments</strong> , that will be the default cell size. If it was not set, the output cell size will be the same as the <strong>Source Raster</strong>.",
	"@@Euclidean-Allocation_Distance-Method_tag0@@": "Determines whether to calculate the distance using a planar (flat earth) or a geodesic (ellipsoid) method.",
	"@@Euclidean-Allocation_Distance-Method_tag1@@": "Geodesic--The shortest line between two points on the earth's surface on a spheroid (ellipsoid). Therefore, regardless of input or output projection, the results do not change. One use for a geodesic line is when you want to determine the shortest distance between two cities for an airplane's flight path. This is also known as a great circle line if based on a sphere rather than an ellipsoid.",
	"@@Euclidean-Allocation_Distance-Method_tag2@@": "Planar--Planar measurements use 2D Cartesian mathematics to calculate length and area. The option is only available when measuring in a projected coordinate system and the 2D plane of that coordinate system will be used as the basis for the measurements.",
	"@@Euclidean-Allocation_Maximum-Distance_tag0@@": "Defines the threshold distance within which the nearest source will be determined. If the distance to the nearest source exceeds this, the output for that cell will be ${NoData}.",
	"@@Euclidean-Allocation_Maximum-Distance_tag1@@": "The default distance is to the extent of the output raster.",
	"@@Euclidean-Allocation_Raster-Barriers_tag0@@": "The raster that defines the barriers.",
	"@@Euclidean-Allocation_Raster-Barriers_tag1@@": "The dataset must contain ${NoData} where there are no barriers. Barriers are represented by valid values including zero.",
	"@@Euclidean-Allocation_Raster-Barriers_tag2@@": "The barriers can be defined by an integer or a floating-point raster.",
	"@@Euclidean-Allocation_Source-Field_tag0@@": "The field used to assign values to the source locations. It must be an integer type. If the <strong>Value Raster</strong> has been set, the values in that input will take precedence over any setting for the <strong>Source Field</strong>.",
	"@@Euclidean-Allocation_Source-Raster_tag0@@": "A required input raster that identifies the source locations. Based on Euclidean distance, the nearest source will be determined for each cell in the output",
	"@@Euclidean-Allocation_Source-Raster_tag1@@": "The input type can be an integer or a floating-point type.",
	"@@Euclidean-Allocation_Value-Raster_tag0@@": "The input integer raster that identifies the zone values to be used for each input source location. For each source location cell, the value defined by the <strong>Value Raster</strong> will be assigned to all cells allocated to the source location for the computation. The <strong>Value Raster</strong> will take precedence over any setting for the <strong>Source Field</strong>.",
	"@@Euclidean-Direction_Cellsize_tag0@@": "The cell size at which the output raster will be created.",
	"@@Euclidean-Direction_Cellsize_tag1@@": "If the cell size was explicitly set in <strong>Analysis Environments</strong> , that will be the default cell size. If it was not set, the output cell size will be the same as the <strong>Source Raster</strong>.",
	"@@Euclidean-Direction_Distance-Method_tag0@@": "Determines whether to calculate the distance using a planar (flat earth) or a geodesic (ellipsoid) method.",
	"@@Euclidean-Direction_Distance-Method_tag1@@": "Geodesic--The shortest line between two points on the earth's surface on a spheroid (ellipsoid). Therefore, regardless of input or output projection, the results do not change. One use for a geodesic line is when you want to determine the shortest distance between two cities for an airplane's flight path. This is also known as a great circle line if based on a sphere rather than an ellipsoid.",
	"@@Euclidean-Direction_Distance-Method_tag2@@": "Planar--Planar measurements use 2D Cartesian mathematics to calculate length and area. The option is only available when measuring in a projected coordinate system and the 2D plane of that coordinate system will be used as the basis for the measurements.",
	"@@Euclidean-Direction_Maximum-Distance_tag0@@": "Defines the threshold distance within which the direction to the closest source will be calculated. If the distance to the nearest source exceeds this, the output for that cell will be ${NoData}.",
	"@@Euclidean-Direction_Maximum-Distance_tag1@@": "The default distance is to the extent of the output raster.",
	"@@Euclidean-Direction_Raster-Barriers_tag0@@": "The raster that defines the barriers.",
	"@@Euclidean-Direction_Raster-Barriers_tag1@@": "The dataset must contain NoData where there are no barriers. Barriers are represented by valid values including zero.",
	"@@Euclidean-Direction_Raster-Barriers_tag2@@": "The barriers can be defined by an integer or a floating-point raster.",
	"@@Euclidean-Direction_Source-Raster_tag0@@": "A required input raster that identifies the cells or locations to which the Euclidean direction for every output cell location is calculated.",
	"@@Euclidean-Direction_Source-Raster_tag1@@": "The input type can be an integer or a floating-point type.",
	"@@Euclidean-Distance_Cellsize_tag0@@": "The cell size at which the output raster will be created.",
	"@@Euclidean-Distance_Cellsize_tag1@@": "If the cell size was explicitly set in <strong>Analysis Environments</strong> , that will be the default cell size. If it was not set, the output cell size will be the same as the <strong>Source Raster</strong>.",
	"@@Euclidean-Distance_Distance-Method_tag0@@": "Determines whether to calculate the distance using a planar (flat earth) or a geodesic (ellipsoid) method.",
	"@@Euclidean-Distance_Distance-Method_tag1@@": "Geodesic--The shortest line between two points on the earth's surface on a spheroid (ellipsoid). Therefore, regardless of input or output projection, the results do not change. One use for a geodesic line is when you want to determine the shortest distance between two cities for an airplane's flight path. This is also known as a great circle line if based on a sphere rather than an ellipsoid.",
	"@@Euclidean-Distance_Distance-Method_tag2@@": "Planar--Planar measurements use 2D Cartesian mathematics to calculate length and area. The option is only available when measuring in a projected coordinate system and the 2D plane of that coordinate system will be used as the basis for the measurements.",
	"@@Euclidean-Distance_Maximum-Distance_tag0@@": "The threshold that the accumulative distance values cannot exceed. If an accumulative Euclidean distance exceeds this value, the output value for the cell location will be NoData.",
	"@@Euclidean-Distance_Maximum-Distance_tag1@@": "The default distance is to the extent of the output raster.",
	"@@Euclidean-Distance_Raster-Barriers_tag0@@": "The raster that defines the barriers.",
	"@@Euclidean-Distance_Raster-Barriers_tag1@@": "The dataset must contain ${NoData} where there are no barriers. Barriers are represented by valid values including zero.",
	"@@Euclidean-Distance_Raster-Barriers_tag2@@": "The barriers can be defined by an integer or a floating-point raster.",
	"@@Euclidean-Distance_Source-Raster_tag0@@": "The required input raster that identifies the cells or locations to which the Euclidean distance for every output cell location is calculated.",
	"@@Euclidean-Distance_Source-Raster_tag1@@": "The input type can be an integer or a floating-point type.",
	"@@Exp_Cellsize-Type_tag0@@": "Choose which cell size to use in the output raster. If all the input cell sizes are the same, all the options will yield the same results.",
	"@@Exp_Cellsize-Type_tag1@@": "First Of--Use the first cell size of the input rasters.",
	"@@Exp_Cellsize-Type_tag2@@": "Last Of--Use the last cell size of the input rasters.",
	"@@Exp_Cellsize-Type_tag3@@": "Max Of--Use the largest cell size of all the input rasters. This is the default.",
	"@@Exp_Cellsize-Type_tag4@@": "Mean Of--Use the mean cell size of all the input rasters.",
	"@@Exp_Cellsize-Type_tag5@@": "Min Of--Use the smallest cell size of all the input rasters.",
	"@@Exp_Extent-Type_tag0@@": "Choose which extent should be used in the output raster:",
	"@@Exp_Extent-Type_tag1@@": "First Of--Use the extent of the first input raster to determine the processing extent.",
	"@@Exp_Extent-Type_tag2@@": "Intersection Of--Use the extent of the overlapping pixels to determine the processing extent. This is the default.",
	"@@Exp_Extent-Type_tag3@@": "Last Of--Use the extent of the last input raster to determine the processing extent.",
	"@@Exp_Extent-Type_tag4@@": "Union Of--Use the extent of all the rasters to determine the processing extent.",
	"@@Exp_Raster_tag0@@": "The input values for which to find the base e exponential.",
	"@@Exp10_Cellsize-Type_tag0@@": "Choose which cell size to use in the output raster. If all the input cell sizes are the same, all the options will yield the same results.",
	"@@Exp10_Cellsize-Type_tag1@@": "First Of--Use the first cell size of the input rasters.",
	"@@Exp10_Cellsize-Type_tag2@@": "Last Of--Use the last cell size of the input rasters.",
	"@@Exp10_Cellsize-Type_tag3@@": "Max Of--Use the largest cell size of all the input rasters. This is the default.",
	"@@Exp10_Cellsize-Type_tag4@@": "Mean Of--Use the mean cell size of all the input rasters.",
	"@@Exp10_Cellsize-Type_tag5@@": "Min Of--Use the smallest cell size of all the input rasters.",
	"@@Exp10_Extent-Type_tag0@@": "Choose which extent should be used in the output raster:",
	"@@Exp10_Extent-Type_tag1@@": "First Of--Use the extent of the first input raster to determine the processing extent.",
	"@@Exp10_Extent-Type_tag2@@": "Intersection Of--Use the extent of the overlapping pixels to determine the processing extent. This is the default.",
	"@@Exp10_Extent-Type_tag3@@": "Last Of--Use the extent of the last input raster to determine the processing extent.",
	"@@Exp10_Extent-Type_tag4@@": "Union Of--Use the extent of all the rasters to determine the processing extent.",
	"@@Exp10_Raster_tag0@@": "The input values for which to find the base 10 exponential.",
	"@@Exp2_Cellsize-Type_tag0@@": "Choose which cell size to use in the output raster. If all the input cell sizes are the same, all the options will yield the same results.",
	"@@Exp2_Cellsize-Type_tag1@@": "First Of--Use the first cell size of the input rasters.",
	"@@Exp2_Cellsize-Type_tag2@@": "Last Of--Use the last cell size of the input rasters.",
	"@@Exp2_Cellsize-Type_tag3@@": "Max Of--Use the largest cell size of all the input rasters. This is the default.",
	"@@Exp2_Cellsize-Type_tag4@@": "Mean Of--Use the mean cell size of all the input rasters.",
	"@@Exp2_Cellsize-Type_tag5@@": "Min Of--Use the smallest cell size of all the input rasters.",
	"@@Exp2_Extent-Type_tag0@@": "Choose which extent should be used in the output raster:",
	"@@Exp2_Extent-Type_tag1@@": "First Of--Use the extent of the first input raster to determine the processing extent.",
	"@@Exp2_Extent-Type_tag2@@": "Intersection Of--Use the extent of the overlapping pixels to determine the processing extent. This is the default.",
	"@@Exp2_Extent-Type_tag3@@": "Last Of--Use the extent of the last input raster to determine the processing extent.",
	"@@Exp2_Extent-Type_tag4@@": "Union Of--Use the extent of all the rasters to determine the processing extent.",
	"@@Exp2_Raster_tag0@@": "The input values for which to find the base 2 exponential.",
	"@@Extract-Bands_Band_tag0@@": "Select the bands to extract from a list based on the <strong>Method</strong> parameter option used.",
	"@@Extract-Bands_Combination_tag0@@": "The band combination or band order. The selection list depends on the <strong>Method</strong> option specified. For example, if <strong>Method</strong> is <strong>Band Names</strong> , you can select a Blue, Green, and Red combination to extract a natural color image.",
	"@@Extract-Bands_Method_tag0@@": "Select one of the following methods for extracting bands:",
	"@@Extract-Bands_Method_tag1@@": "<strong>Band IDs</strong>--The band designation or number, which is unique for each sensor. These can be identical to the <strong>Band Names</strong>.",
	"@@Extract-Bands_Method_tag4@@": "<strong>Band Names</strong>--Uses the band name representing the wavelength interval on the electromagnetic spectrum (Red, Near Infrared, Thermal Infrared, for example). This can also be designated as a band number ID.",
	"@@Extract-Bands_Method_tag6@@": "<strong>Band Wavelengths</strong>--The wavelength on the electromagnetic spectrum.",
	"@@Extract-Bands_Missing-Band-Action_tag0@@": "Specify the action that will occur when a band within the extract band list is not available.",
	"@@Extract-Bands_Missing-Band-Action_tag1@@": "<strong>Best Match</strong>--Finds the best available band to use in place of the missing band based on wavelength, so that the function will not fail",
	"@@Extract-Bands_Missing-Band-Action_tag3@@": "<strong>Fail</strong>--If the input dataset is missing any band specified in the <strong>Band</strong> parameter, the function will fail.",
	"@@Extract-Bands_Raster_tag0@@": "The raster product from which the band or bands will be extracted.",
	"@@Fill_Raster_tag0@@": "A single band elevation raster.",
	"@@Fill_Z-Limit_tag0@@": "The maximum elevation difference between a sink and its pour point to be filled.",
	"@@Fill_Z-Limit_tag1@@": "Unless a value is specified for this parameter, all sinks will be filled, regardless of depth.",
	"@@Fill_Z-Limit_tag2@@": "The value for <strong>Z Limit</strong> must be greater than zero.",
	"@@Float_Cellsize-Type_tag0@@": "Choose which cell size to use in the output raster. If all the input cell sizes are the same, all the options will yield the same results.",
	"@@Float_Cellsize-Type_tag1@@": "First Of--Use the first cell size of the input rasters.",
	"@@Float_Cellsize-Type_tag2@@": "Last Of--Use the last cell size of the input rasters.",
	"@@Float_Cellsize-Type_tag3@@": "Max Of--Use the largest cell size of all the input rasters. This is the default.",
	"@@Float_Cellsize-Type_tag4@@": "Mean Of--Use the mean cell size of all the input rasters.",
	"@@Float_Cellsize-Type_tag5@@": "Min Of--Use the smallest cell size of all the input rasters.",
	"@@Float_Extent-Type_tag0@@": "Choose which extent should be used in the output raster:",
	"@@Float_Extent-Type_tag1@@": "First Of--Use the extent of the first input raster to determine the processing extent.",
	"@@Float_Extent-Type_tag2@@": "Intersection Of--Use the extent of the overlapping pixels to determine the processing extent. This is the default.",
	"@@Float_Extent-Type_tag3@@": "Last Of--Use the extent of the last input raster to determine the processing extent.",
	"@@Float_Extent-Type_tag4@@": "Union Of--Use the extent of all the rasters to determine the processing extent.",
	"@@Float_Raster_tag0@@": "The input raster to be converted to floating point.",
	"@@Flow-Accumulation_Flow-Direction-Raster_tag0@@": "The input raster that shows the direction of flow out of each cell.",
	"@@Flow-Accumulation_Flow-Direction-Raster_tag1@@": "The flow direction raster can be created by running the <strong>Flow Direction</strong> function.",
	"@@Flow-Accumulation_Flow-Direction-Type_tag0@@": "Defines the type of the input flow direction raster.",
	"@@Flow-Accumulation_Flow-Direction-Type_tag1@@": "<strong>D8</strong>--The input flow direction raster is of type D8. This is the default.",
	"@@Flow-Accumulation_Flow-Direction-Type_tag3@@": "<strong>DINF</strong>--The input flow direction raster is of type D-Infinity (DINF).",
	"@@Flow-Accumulation_Flow-Direction-Type_tag5@@": "<strong>MFD</strong>--The input flow direction raster is of type Multi Flow Direction (MFD).",
	"@@Flow-Accumulation_Output-Data-Type_tag0@@": "The output accumulation raster can be integer or floating point type.",
	"@@Flow-Accumulation_Output-Data-Type_tag1@@": "<strong>Float</strong>--The output raster will be floating point type. This is the default.",
	"@@Flow-Accumulation_Output-Data-Type_tag3@@": "<strong>Integer</strong>--The output raster will be integer type.",
	"@@Flow-Accumulation_Weight-Raster_tag0@@": "An optional input raster for applying a weight to each pixel.",
	"@@Flow-Accumulation_Weight-Raster_tag1@@": "If no weight raster is specified, a default weight of 1 will be applied to each pixel.",
	"@@Flow-Direction_Flow-Direction-Type_tag0@@": "Defines the type of the input flow direction raster.",
	"@@Flow-Direction_Flow-Direction-Type_tag1@@": "<strong>D8</strong>--The input flow direction raster is of type D8. This is the default.",
	"@@Flow-Direction_Flow-Direction-Type_tag3@@": "<strong>DINF</strong>--The input flow direction raster is of type D-Infinity (DINF).",
	"@@Flow-Direction_Flow-Direction-Type_tag5@@": "<strong>MFD</strong>--The input flow direction raster is of type Multi Flow Direction (MFD).",
	"@@Flow-Direction_Force-all-edge-cells-to-flow-outward_tag0@@": "Specifies if edge pixels will always flow outward or follow normal flow rules.",
	"@@Flow-Direction_Force-all-edge-cells-to-flow-outward_tag1@@": "<strong>No</strong>--If the maximum drop on the inside of an edge pixel is greater than zero, the flow direction will be determined as usual; otherwise, the flow direction will be towards the edge. Pixels that should flow from the edge of the surface raster inward will do so. This is the default.",
	"@@Flow-Direction_Force-all-edge-cells-to-flow-outward_tag3@@": "<strong>Yes</strong>--All the pixels at the edge of the surface raster will flow outward from the surface raster.",
	"@@Flow-Direction_Raster_tag0@@": "The input raster representing a continuous elevation surface.",
	"@@Flow-Distance_Distance-Type_tag0@@": "Determines if the vertical or horizontal component of flow distance is calculated.",
	"@@Flow-Distance_Distance-Type_tag1@@": "<strong>Horizontal</strong>--The flow distance calculations represent the horizontal component of flow distance from each pixel in the domain to the pixel(s) on the stream into which they flow.",
	"@@Flow-Distance_Distance-Type_tag3@@": "<strong>Vertical</strong>--The flow distance calculations represent the vertical component of flow distance from each pixel in the domain to the pixel(s) on the stream into which they flow. This is the default.",
	"@@Flow-Distance_Flow-Direction-Raster_tag0@@": "The input raster that shows the direction of flow out of each pixel.",
	"@@Flow-Distance_Flow-Direction-Raster_tag1@@": "When a flow direction raster is provided, the down slope direction(s) will be limited to those defined by the input flow directions.",
	"@@Flow-Distance_Flow-Direction-Raster_tag2@@": "The flow direction raster can be created using the Flow Direction function.",
	"@@Flow-Distance_Flow-Direction-Type_tag0@@": "Defines the type of the input flow direction raster.",
	"@@Flow-Distance_Flow-Direction-Type_tag1@@": "<strong>D8</strong>--The input flow direction raster is of type D8. This is the default.",
	"@@Flow-Distance_Flow-Direction-Type_tag3@@": "<strong>DINF</strong>--The input flow direction raster is of type D-Infinity (DINF).",
	"@@Flow-Distance_Flow-Direction-Type_tag5@@": "<strong>MFD</strong>--The input flow direction raster is of type Multi Flow Direction (MFD).",
	"@@Flow-Distance_Statistics-Type_tag0@@": "Determines the statistics type used to compute flow distance over multiple flow paths. If there is only a single flow path from each cell to a cell on the stream, all statistics types produce the same result.",
	"@@Flow-Distance_Statistics-Type_tag1@@": "<strong>Minimum</strong>--Where multiple flow paths exist, minimum flow distance in computed. This is the default.",
	"@@Flow-Distance_Statistics-Type_tag3@@": "<strong>Weighted Mean</strong>--Where multiple flow paths exist, a weighted mean of flow distance is computed. Flow proportion from a cell to its downstream neighboring cells are used as weights for computing weighted mean.",
	"@@Flow-Distance_Statistics-Type_tag5@@": "<strong>Maximum</strong>--When multiple flow paths exist, maximum flow distance is computed.",
	"@@Flow-Distance_Stream-Raster_tag0@@": "An input stream raster that represents a linear stream network.",
	"@@Flow-Distance_Surface-Raster_tag0@@": "The input raster representing a continuous elevation surface.",
	"@@Flow-Length_Direction-of-Measurement_tag0@@": "The direction of measurement along the flow path.",
	"@@Flow-Length_Direction-of-Measurement_tag1@@": "<strong>Downstream</strong>--Calculates the downslope distance along the flow path, from each cell to a sink or outlet on the edge of the raster.",
	"@@Flow-Length_Direction-of-Measurement_tag3@@": "<strong>Upstream</strong>--Calculates the longest upslope distance along the flow path, from each cell to the top of the drainage divide.",
	"@@Flow-Length_Flow-Direction-Raster_tag0@@": "The input raster that shows the direction of flow out of each cell.",
	"@@Flow-Length_Flow-Direction-Raster_tag1@@": "The flow direction raster can be created by running the <strong>Flow Direction</strong> function.",
	"@@Flow-Length_Weight-Raster_tag0@@": "An optional input raster for applying a weight to each cell.",
	"@@Flow-Length_Weight-Raster_tag1@@": "If no weight raster is specified, a default weight of 1 will be applied to each cell.",
	"@@Focal-Statistics_Ignore-NoData-in-calculations_tag0@@": "Denotes whether ${NoData} values are ignored by the statistic calculation.",
	"@@Focal-Statistics_Ignore-NoData-in-calculations_tag1@@": "<strong>Checked</strong>--Specifies that if a ${NoData} value exists within a neighborhood, the ${NoData} value will be ignored. Only cells within the neighborhood that have data values will be used in determining the output value. This is the default.",
	"@@Focal-Statistics_Ignore-NoData-in-calculations_tag3@@": "<strong>Unchecked</strong>--Specifies that if any cell in a neighborhood has a value of ${NoData}, the output for the processing cell will be ${NoData}.",
	"@@Focal-Statistics_Neighborhood_tag0@@": "The shape of the area around each cell used to calculate the statistic.",
	"@@Focal-Statistics_Neighborhood_tag1@@": "Each neighborhood have additional parameters with which to define the shape.",
	"@@Focal-Statistics_Neighborhood_tag2@@": "Annulus, Inner Radius, Outer Radius",
	"@@Focal-Statistics_Neighborhood_tag3@@": "Circle, Radius",
	"@@Focal-Statistics_Neighborhood_tag4@@": "Irregular, Width, Height, Neighborhood values",
	"@@Focal-Statistics_Neighborhood_tag5@@": "Rectangle, Width, Height",
	"@@Focal-Statistics_Neighborhood_tag6@@": "Wedge, Radius, Start angle, End angle",
	"@@Focal-Statistics_Neighborhood_tag7@@": "Weight, Width, Height, Neighborhood values",
	"@@Focal-Statistics_Neighborhood_tag8@@": "The Irregular neighborhood allows you to specify an irregularly shaped neighborhood around the processing cell. Use the Neighborhood values table to define the shape of the neighborhood kernel. A value of 0 for a cell position indicates that the cell is not part of the neighborhood, and will not be used for processing. A value of 1 indicates that its corresponding cell (and value) is a member of the neighborhood.",
	"@@Focal-Statistics_Neighborhood_tag9@@": "The Weight neighborhood is similar to the irregular neighborhood type, in that it allows you to define an irregular neighborhood around the processing cell, but it additionally allows you to apply weights to the input values. The values in the weight kernel specifies which cell positions should be included within the neighborhood and the weights by which they will be multiplied. Use a value of 0 to exclude a cell from processing. Positive, negative, and decimal values are all valid options to use as a weight. For the Weight neighborhood type, only the Mean, Standard Deviation, or Sum statistics are supported.",
	"@@Focal-Statistics_Percentile-Value_tag0@@": "Denotes which percentile to calculate when <strong>Percentile</strong> is selected as the statistics type. The default is 90, for the 90th percentile.",
	"@@Focal-Statistics_Percentile-Value_tag3@@": "The values can range from 0 to 100. The 0th percentile is essentially equivalent to the Minimum statistic, and the 100th percentile equivalent to Maximum, with the exception that the result will be floating point. A value of 50 will essentially produce the same result as the Median statistic.",
	"@@Focal-Statistics_Raster_tag0@@": "The required input raster.",
	"@@Focal-Statistics_Statistics-Type_tag0@@": "The statistic type to be calculated.",
	"@@Focal-Statistics_Statistics-Type_tag1@@": "<strong>Majority</strong>--Calculates the majority (value that occurs most often) of the cells in the neighborhood.",
	"@@Focal-Statistics_Statistics-Type_tag3@@": "<strong>Maximum</strong>--Calculates the maximum (largest value) of the cells in the neighborhood.",
	"@@Focal-Statistics_Statistics-Type_tag5@@": "<strong>Mean</strong>--Calculates the mean (average value) of the cells in the neighborhood.",
	"@@Focal-Statistics_Statistics-Type_tag7@@": "<strong>Median</strong>--Calculates the median of the cells in the neighborhood.",
	"@@Focal-Statistics_Statistics-Type_tag9@@": "<strong>Minimum</strong>--Calculates the minimum (smallest value) of the cells in the neighborhood.",
	"@@Focal-Statistics_Statistics-Type_tag11@@": "<strong>Minority</strong>--Calculates the minority (value that occurs least often) of the cells in the neighborhood.",
	"@@Focal-Statistics_Statistics-Type_tag13@@": "<strong>Percentile</strong>--Calculates a percentile of the cells in the neighborhood. You can determine which percentile to calculate with the <strong>Percentile Value</strong> parameter.",
	"@@Focal-Statistics_Statistics-Type_tag17@@": "<strong>Range</strong>--Calculates the range (difference between largest and smallest value) of the cells in the neighborhood.",
	"@@Focal-Statistics_Statistics-Type_tag19@@": "<strong>Standard Deviation</strong>--Calculates the standard deviation of the cells in the neighborhood.",
	"@@Focal-Statistics_Statistics-Type_tag21@@": "<strong>Sum</strong>--Calculates the sum (total of all values) of the cells in the neighborhood.",
	"@@Focal-Statistics_Statistics-Type_tag23@@": "<strong>Variety</strong>--Calculates the variety (the number of unique values) of the cells in the neighborhood.",
	"@@Focal-Statistics_Statistics-Type_tag25@@": "If the input raster is floating point, only the Mean, Maximum, Median, Minimum, Percentile, Range, Standard Deviation, and Sum statistic types are available.",
	"@@Focal-Statistics_Statistics-Type_tag26@@": "For Mean, Median, Percentile, and Standard Deviation, the output is always floating point.",
	"@@Focal-Statistics_Statistics-Type_tag27@@": "The default statistic type is Mean.",
	"@@Geometric_Constant-Z_tag0@@": "Specify a constant elevation to use for the Geometric function.",
	"@@Geometric_DEM_tag0@@": "Specify the DEM to use for the Geometric function. You can use a DEM contained in the mosaic dataset as a raster dataset or as a mosaic dataset whose output is a DEM.",
	"@@Geometric_Geoid_tag0@@": "Most elevation datasets, such as USGS NED or ArcGIS Online World Elevation, are orthometric heights, so it is necessary to select the Geoid correction for compatibility with satellite RPCs, which require ellipsoidal heights. Check the <strong>Geoid</strong> check box to apply the geoid (EGM96) correction to the z-values, unless your DEM is already referenced to ellipsoidal heights.",
	"@@Geometric_Method_tag0@@": "Choose the elevation method for the geometric function:",
	"@@Geometric_Method_tag1@@": "Use Constant Z--Specify a constant elevation to perform the Geometric function.",
	"@@Geometric_Method_tag2@@": "Use DEM--Specify a DEM to perform the Geometric function.",
	"@@Geometric_Raster_tag0@@": "The input raster.",
	"@@Geometric_Z-Factor_tag0@@": "Satellite rational polynomial coefficients (RPCs) are scaled for elevation datasets with vertical units in meters. If your elevation uses other vertical units, enter a <strong>Z Factor</strong> to rescale to meters. For example, if your elevation units are in feet, you would use a value of 0.3048 to convert your elevation units from feet to meters.",
	"@@Geometric_Z-Offset_tag0@@": "The base value to be added to the elevation value in the DEM. This could be used to offset elevation values that do not start at sea level.",
	"@@Geometric_Tolerance_tag0@@": "Specify the maximum tolerable error in the geometric function, given in number of pixels. The default for the NITF (NCDRD) raster type is two.",
	"@@Grayscale_Raster_tag0@@": "The input raster.",
	"@@Grayscale_Conversion-Parameters_tag0@@": "The weights for each of the bands comprising the input raster.",
	"@@Greater-Than_Cellsize-Type_tag0@@": "Choose which cell size to use in the output raster. If all the input cell sizes are the same, all the options will yield the same results.",
	"@@Greater-Than_Cellsize-Type_tag1@@": "First Of--Use the first cell size of the input rasters.",
	"@@Greater-Than_Cellsize-Type_tag2@@": "Last Of--Use the last cell size of the input rasters.",
	"@@Greater-Than_Cellsize-Type_tag3@@": "Max Of--Use the largest cell size of all the input rasters. This is the default.",
	"@@Greater-Than_Cellsize-Type_tag4@@": "Mean Of--Use the mean cell size of all the input rasters.",
	"@@Greater-Than_Cellsize-Type_tag5@@": "Min Of--Use the smallest cell size of all the input rasters.",
	"@@Greater-Than_Extent-Type_tag0@@": "Choose which extent should be used in the output raster:",
	"@@Greater-Than_Extent-Type_tag1@@": "First Of--Use the extent of the first input raster to determine the processing extent.",
	"@@Greater-Than_Extent-Type_tag2@@": "Intersection Of--Use the extent of the overlapping pixels to determine the processing extent. This is the default.",
	"@@Greater-Than_Extent-Type_tag3@@": "Last Of--Use the extent of the last input raster to determine the processing extent.",
	"@@Greater-Than_Extent-Type_tag4@@": "Union Of--Use the extent of all the rasters to determine the processing extent.",
	"@@Greater-Than_Raster_tag0@@": "The input being tested to determine if it is greater than the second input.",
	"@@Greater-Than_Raster_tag1@@": "A constant value can be used as an input for this parameter, provided a raster is specified for the other parameter.",
	"@@Greater-Than_Raster2_tag0@@": "The input against which the first input is tested to be greater than.",
	"@@Greater-Than_Raster2_tag1@@": "A constant value can be used as an input for this parameter, provided a raster is specified for the other parameter.",
	"@@Greater-Than-Equal_Cellsize-Type_tag0@@": "Choose which cell size to use in the output raster. If all the input cell sizes are the same, all the options will yield the same results.",
	"@@Greater-Than-Equal_Cellsize-Type_tag1@@": "First Of--Use the first cell size of the input rasters.",
	"@@Greater-Than-Equal_Cellsize-Type_tag2@@": "Last Of--Use the last cell size of the input rasters.",
	"@@Greater-Than-Equal_Cellsize-Type_tag3@@": "Max Of--Use the largest cell size of all the input rasters. This is the default.",
	"@@Greater-Than-Equal_Cellsize-Type_tag4@@": "Mean Of--Use the mean cell size of all the input rasters.",
	"@@Greater-Than-Equal_Cellsize-Type_tag5@@": "Min Of--Use the smallest cell size of all the input rasters.",
	"@@Greater-Than-Equal_Extent-Type_tag0@@": "Choose which extent should be used in the output raster:",
	"@@Greater-Than-Equal_Extent-Type_tag1@@": "First Of--Use the extent of the first input raster to determine the processing extent.",
	"@@Greater-Than-Equal_Extent-Type_tag2@@": "Intersection Of--Use the extent of the overlapping pixels to determine the processing extent. This is the default.",
	"@@Greater-Than-Equal_Extent-Type_tag3@@": "Last Of--Use the extent of the last input raster to determine the processing extent.",
	"@@Greater-Than-Equal_Extent-Type_tag4@@": "Union Of--Use the extent of all the rasters to determine the processing extent.",
	"@@Greater-Than-Equal_Raster_tag0@@": "The input being tested to determine if it is greater than or equal to the second input.",
	"@@Greater-Than-Equal_Raster_tag1@@": "A constant value can be used as an input for this parameter, provided a raster is specified for the other parameter.",
	"@@Greater-Than-Equal_Raster2_tag0@@": "The input against which the first input is tested to be greater than or equal to.",
	"@@Greater-Than-Equal_Raster2_tag1@@": "A constant value can be used as an input for this parameter, provided a raster is specified for the other parameter.",
	"@@Heat-Index_Heat-Index-Units_tag0@@": "The unit of measurement associated with the output raster. Available output units are Celsius, Fahrenheit, and Kelvin.",
	"@@Heat-Index_Relative-Humidity-Raster_tag0@@": "A single-band raster where pixel values represent relative humidity as a percentage value between 0 and 100.",
	"@@Heat-Index_Temperature-Raster_tag0@@": "A single-band raster where pixel values represent ambient air temperature.",
	"@@Heat-Index_Temperature-Units_tag0@@": "The unit of measurement associated with the input temperature raster. Available input units are Celsius, Fahrenheit, and Kelvin.",
	"@@Hillshade_Altitude_tag0@@": "Altitude is the sun's angle of elevation above the horizon and ranges from 0 to 90 degrees. A value of 0 degrees indicates that the sun is on the horizon, that is, on the same horizontal plane as the frame of reference. A value of 90 degrees indicates that the sun is directly overhead.",
	"@@Hillshade_Altitude_tag1@@": "This parameter is only valid when <strong>Hillshade Type</strong> is <strong>Traditional</strong> . The default is 45 degrees above the horizon.",
	"@@Hillshade_Azimuth_tag0@@": "Azimuth is the sun's relative position along the horizon (in degrees). This position is indicated by the angle of the sun measured clockwise from due north. An azimuth of 0 degrees indicates north, east is 90 degrees, south is 180 degrees, and west is 270 degrees.",
	"@@Hillshade_Azimuth_tag1@@": "This parameter is only valid when <strong>Hillshade Type</strong> is <strong>Traditional</strong> . The default is 315 degrees, which is from the northwest.",
	"@@Hillshade_Disable-default-edge-pixel-interpolation_tag0@@": "Using this option avoids any resampling artifacts that may occur along the edges of a raster. The output pixels along the edge of a raster or beside NoData pixels will be populated with NoData; therefore, it is recommended that this parameter is only used with elevation mosaic datasets that have overlap. When overlapping pixels are available, the areas of NoData will display the overlapping pixel values instead of blank pixels.",
	"@@Hillshade_Disable-default-edge-pixel-interpolation_tag1@@": "Unchecked--Bilinear resampling will be applied uniformly to resample your hillshade. Use this option when the mosaic dataset containing your elevation raster data is butt joined. This is the default.",
	"@@Hillshade_Disable-default-edge-pixel-interpolation_tag2@@": "Checked--Bilinear resampling will be used within the hillshade except along the edges of the rasters or beside pixels of NoData. These pixels will be populated with NoData and display the overlapping pixel values, thereby reducing any sharp edge effects that may otherwise occur. Use this option when the mosaic dataset containing your elevation raster data consists of overlapping items or tiles.",
	"@@Hillshade_Disable-default-edge-pixel-interpolation_tag3@@": "The results from the function can be data dependent. If you observe tile boundary artifacts in your output, select the alternate condition of the check box.",
	"@@Hillshade_Hillshade-Type_tag0@@": "Controls the illumination source for the hillshade:",
	"@@Hillshade_Hillshade-Type_tag1@@": "Traditional--Calculates hillshade from a single illumination direction. This is the default. You can set the <strong>Azimuth</strong> and <strong>Altitude</strong> to control the location of the light source.",
	"@@Hillshade_Hillshade-Type_tag6@@": "Multidirectional--Combines light from multiple sources to represent an enhanced visualization of the terrain.",
	"@@Hillshade_Pixel-Size-Factor_tag0@@": "Pixel Size Factor accounts for changes in scale as the viewer zooms in and out on the map display. It controls the rate at which the <strong>Z Factor</strong> changes.",
	"@@Hillshade_Pixel-Size-Factor_tag3@@": "This parameter is only valid when the <strong>Scaling</strong> type is <strong>Adjusted</strong>. The default value is 0.024.",
	"@@Hillshade_Pixel-Size-Power_tag0@@": "Pixel Size Power accounts for the altitude changes (or scale) as the viewer zooms in and out on the map display. It is the exponent applied to the pixel size term in the equation that controls the rate at which the <strong>Z Factor</strong> changes to avoid significant loss of relief.",
	"@@Hillshade_Pixel-Size-Power_tag3@@": "This parameter is only valid when the <strong>Scaling</strong> type is <strong>Adjusted</strong>. The default value is 0.664.",
	"@@Hillshade_Raster_tag0@@": "The input elevation dataset.",
	"@@Hillshade_Scaling_tag0@@": "The shaded result is scaled dynamically by adjusting the z-factor using one of two options:",
	"@@Hillshade_Scaling_tag1@@": "Adjusted--This applies a nonlinear adjustment using the default <strong>Pixel Size Power</strong> and <strong>Pixel Size Factor</strong> values, which accommodate a wide variety of altitude changes (scale) as the viewer zooms in and out. The <strong>Adjusted</strong> parameter setting is recommended when using a worldwide dataset.",
	"@@Hillshade_Scaling_tag8@@": "None--No scaling is applied. This is ideal for a single raster dataset covering a local area. This is not recommended for worldwide datasets with large variations in elevation or multiscale maps as it will produce terrain relief with little variation at small scales.",
	"@@Hillshade_Z-Factor_tag0@@": "The z-factor is a scaling factor used to convert the elevation values for two purposes:",
	"@@Hillshade_Z-Factor_tag1@@": "Convert the elevation units (such as meters or feet) to the horizontal coordinate units of the dataset, which may be feet, meters, or degrees.",
	"@@Hillshade_Z-Factor_tag2@@": "Add vertical exaggeration for visual effect.",
	"@@Int_Cellsize-Type_tag0@@": "Choose which cell size to use in the output raster. If all the input cell sizes are the same, all the options will yield the same results.",
	"@@Int_Cellsize-Type_tag1@@": "First Of--Use the first cell size of the input rasters.",
	"@@Int_Cellsize-Type_tag2@@": "Last Of--Use the last cell size of the input rasters.",
	"@@Int_Cellsize-Type_tag3@@": "Max Of--Use the largest cell size of all the input rasters. This is the default.",
	"@@Int_Cellsize-Type_tag4@@": "Mean Of--Use the mean cell size of all the input rasters.",
	"@@Int_Cellsize-Type_tag5@@": "Min Of--Use the smallest cell size of all the input rasters.",
	"@@Int_Extent-Type_tag0@@": "Choose which extent should be used in the output raster:",
	"@@Int_Extent-Type_tag1@@": "First Of--Use the extent of the first input raster to determine the processing extent.",
	"@@Int_Extent-Type_tag2@@": "Intersection Of--Use the extent of the overlapping pixels to determine the processing extent. This is the default.",
	"@@Int_Extent-Type_tag3@@": "Last Of--Use the extent of the last input raster to determine the processing extent.",
	"@@Int_Extent-Type_tag4@@": "Union Of--Use the extent of all the rasters to determine the processing extent.",
	"@@Int_Raster_tag0@@": "The input raster to be converted to integer.",
	"@@Interpolate-Irregular-Data_Cellsize_tag0@@": "The cell size for the output raster will be automatically detected; however, you can change this. While the cell size can be changed, the extent of the raster dataset will remain the same.",
	"@@Interpolate-Irregular-Data_Input-Samples_tag0@@": "The input points data.",
	"@@Interpolate-Irregular-Data_Interpolation-Method_tag0@@": "There are four resampling methods for this function:",
	"@@Interpolate-Irregular-Data_Interpolation-Method_tag1@@": "<strong>Inverse Distance Weighted</strong>--Determines cell values using a linearly weighted combination of a set of sample points or cells. The weight is a function of the inverse of the distance from the known points or cells.",
	"@@Interpolate-Irregular-Data_Interpolation-Method_tag3@@": "<strong>Linear Tinning</strong>--Uses a triangular irregular network from the center points of each cell in the irregular raster to interpolate a surface that is then converted to a regular raster.",
	"@@Interpolate-Irregular-Data_Interpolation-Method_tag5@@": "<strong>Natural Neighbor</strong>--Finds the closest subset of input samples to a query point and applies weights to them based on proportionate areas to interpolate a value.",
	"@@Interpolate-Irregular-Data_Interpolation-Method_tag7@@": "<strong>Nearest Neighbor</strong>--Calculates pixel value using the nearest pixel. If no source pixel exists, no new pixel can be created in the output. This is the default.",
	"@@Interpolate-Irregular-Data_Search-Radius_tag0@@": "Identifies the number of pixels to be included for the selected resampling method. The default value is ${3} pixels.",
	"@@Interpolate-Irregular-Data_Value-Field_tag0@@": "If you select a point feature class as the input, you will need to identify the field in the attribute table with the value of the points",
	"@@Is-Null_Cellsize-Type_tag0@@": "Choose which cell size to use in the output raster. If all the input cell sizes are the same, all the options will yield the same results.",
	"@@Is-Null_Cellsize-Type_tag1@@": "First Of--Use the first cell size of the input rasters.",
	"@@Is-Null_Cellsize-Type_tag2@@": "Last Of--Use the last cell size of the input rasters.",
	"@@Is-Null_Cellsize-Type_tag3@@": "Max Of--Use the largest cell size of all the input rasters. This is the default.",
	"@@Is-Null_Cellsize-Type_tag4@@": "Mean Of--Use the mean cell size of all the input rasters.",
	"@@Is-Null_Cellsize-Type_tag5@@": "Min Of--Use the smallest cell size of all the input rasters.",
	"@@Is-Null_Extent-Type_tag0@@": "Choose which extent should be used in the output raster:",
	"@@Is-Null_Extent-Type_tag1@@": "First Of--Use the extent of the first input raster to determine the processing extent.",
	"@@Is-Null_Extent-Type_tag2@@": "Intersection Of--Use the extent of the overlapping pixels to determine the processing extent. This is the default.",
	"@@Is-Null_Extent-Type_tag3@@": "Last Of--Use the extent of the last input raster to determine the processing extent.",
	"@@Is-Null_Extent-Type_tag4@@": "Union Of--Use the extent of all the rasters to determine the processing extent.",
	"@@Is-Null_Raster_tag0@@": "The input raster being tested to identify the cells that are ${NoData} (null).",
	"@@Is-Null_Raster_tag1@@": "The input can be either integer or floating-point type.",
	"@@Key-Metadata_Band-Names_tag0@@": "This is used to override the band names of a raster. It is a comma-separated string representing updated band names.",
	"@@Key-Metadata_Band-Names_tag1@@": "This parameter is optional.",
	"@@Key-Metadata_Metadata-JSON_tag0@@": "Key metadata to be injected into the outgoing raster described as a JSON string representing a collection of key-value pairs. The following is an example of a JSON string that can be used as an input to this function. All inputs for this parameter should follow the same format.",
	"@@Key-Metadata_Metadata-JSON_tag1@@": "JSON string representing key metadata",
	"@@Key-Metadata_Metadata-JSON_tag2@@": "{ \"CloudCover\": 4, \"BandProperties\":[ { \"BandName\": \"Blue\", \"WavelengthMin\": 445, \"WavelengthMax\": 516 }, { \"BandName\": \"Green\", \"WavelengthMin\": 506, \"WavelengthMax\": 595 }, ]}",
	"@@Key-Metadata_Property-Name_tag0@@": "The name of the dataset-level key property to override.",
	"@@Key-Metadata_Raster_tag0@@": "The raster or mosaic dataset containing key metadata that you would like to insert or overwrite.",
	"@@Key-Metadata_Value_tag0@@": "The overriding value of the dataset-level key property that you want to set.",
	"@@Least-Cost-Path_Accumulative-Cost-Resistance-Rate_tag0@@": "This parameter simulates the increase in the effort to overcome costs as the accumulative cost increases. It is used to model fatigue of the traveler. The growing accumulative cost to reach a cell is multiplied by the resistance rate and added to the cost to move into the subsequent cell.",
	"@@Least-Cost-Path_Accumulative-Cost-Resistance-Rate_tag1@@": "It's a modified version of a compound interest rate formula that's used to calculate the apparent cost of moving through a cell. As the value of the resistance rate increases, it increases the cost of the cells that are visited later. The greater the resistance rate, the higher the cost to reach the next cell, which is compounded for each subsequent movement. Since the resistance rate is similar to a compound rate and generally the accumulative cost values are very large, small resistance rates are suggested, such as 0.005 or even smaller, depending on the accumulative cost values.",
	"@@Least-Cost-Path_Accumulative-Cost-Resistance-Rate_tag2@@": "The value must be greater than zero. The default capacity is to the edge of the output raster.",
	"@@Least-Cost-Path_Capacity_tag0@@": "Defines the cost capacity for the traveler for a source. The cost calculations continue for each source until the specified capacity is reached.",
	"@@Least-Cost-Path_Capacity_tag1@@": "The value must be greater than zero. The default capacity is to the edge of the output raster.",
	"@@Least-Cost-Path_Cost-Raster_tag0@@": "A required input raster defining the cost or impedance to move planimetrically through each cell. The value at each cell location represents the cost-per-unit distance for moving through it. Each cell location value is multiplied by the cell resolution, and also compensates for diagonal movement to obtain the total cost of passing through the cell.",
	"@@Least-Cost-Path_Cost-Raster_tag1@@": "The values of the <strong>Cost Raster</strong> can be integer or floating point, but they cannot be negative or zero.",
	"@@Least-Cost-Path_Destination-Field_tag0@@": "The field used to obtain values for the destination locations.",
	"@@Least-Cost-Path_Destination-Raster_tag0@@": "A required input raster that identifies the pixels from which the least-cost path is determined to the least costly source. This input consists of pixels that have valid values, and the remaining pixels must be assigned ${NoData}. Values of 0 are valid.",
	"@@Least-Cost-Path_Maximum-Distance_tag0@@": "The threshold that the accumulative cost values cannot exceed. If an accumulative cost distance exceeds this value, the output value for the cell location will be ${NoData}. The maximum distance defines the extent for which the accumulative cost distances are calculated. The default distance is to the extent of the output raster.",
	"@@Least-Cost-Path_Multiplier-to-Apply-to-Costs_tag0@@": "This parameter allows for control of the mode of travel or the magnitude at a source. The greater the multiplier, the greater the cost to move through each cell.",
	"@@Least-Cost-Path_Multiplier-to-Apply-to-Costs_tag1@@": "The values must be greater than zero. The default is 1.",
	"@@Least-Cost-Path_Path-Type_tag0@@": "A keyword defining the manner in which the values and zones on the input destination data will be interpreted in the cost path calculations:",
	"@@Least-Cost-Path_Path-Type_tag1@@": "<strong>Best Single</strong>--For all pixels on the input destination data, the least-cost path is derived from the pixel with the minimum of the least-cost paths to source cells.",
	"@@Least-Cost-Path_Path-Type_tag3@@": "<strong>Each Cell</strong>--A least-cost path is determined for each pixel with valid values on the input destination data, and saved on the output raster. Each cell of the input destination data is treated separately, and a least-cost path is determined for each from cell.",
	"@@Least-Cost-Path_Path-Type_tag5@@": "<strong>Each Zone</strong>--A least-cost path is determined for each zone on the input destination data and saved on the output raster. The least-cost path for each zone begins at the pixel with the lowest cost distance weighting in the zone.",
	"@@Least-Cost-Path_Source-Raster_tag0@@": "This is a required input raster that identifies the cells or locations from which the least accumulated cost distance for every output cell location is calculated.",
	"@@Least-Cost-Path_Start-Cost_tag0@@": "The starting cost from which to begin the cost calculations. This parameter allows for the specification of the fixed cost associated with a source. Instead of starting at a cost of 0, the cost algorithm will begin with the value specified.",
	"@@Least-Cost-Path_Start-Cost_tag1@@": "The value must be zero or greater. The default is 0.",
	"@@Least-Cost-Path_Travel-Direction_tag0@@": "Defines the direction of the traveler when applying the source resistance rate and the source starting cost.",
	"@@Least-Cost-Path_Travel-Direction_tag1@@": "<strong>From Source</strong>--The source resistance rate and source starting cost will be applied beginning at the input source and moving out to the non-source cells. This is the default.",
	"@@Least-Cost-Path_Travel-Direction_tag3@@": "<strong>To Source</strong>--The source resistance rate and source starting cost will be applied beginning at each non-source cell and moving back to the input source.",
	"@@Least-Cost-Path_Travel-Direction_tag5@@": "Either specify the <strong>From Source</strong> or <strong>To Source</strong> keyword, which will be applied to all sources, or specify a field in the <strong>Source Raster</strong> that contains the keywords to identify the direction of travel for each source. That field must contain the string ${FROM_SOURCE} or ${TO_SOURCE}.",
	"@@Less-Than_Cellsize-Type_tag0@@": "Choose which cell size to use in the output raster. If all the input cell sizes are the same, all the options will yield the same results.",
	"@@Less-Than_Cellsize-Type_tag1@@": "First Of--Use the first cell size of the input rasters.",
	"@@Less-Than_Cellsize-Type_tag2@@": "Last Of--Use the last cell size of the input rasters.",
	"@@Less-Than_Cellsize-Type_tag3@@": "Max Of--Use the largest cell size of all the input rasters. This is the default.",
	"@@Less-Than_Cellsize-Type_tag4@@": "Mean Of--Use the mean cell size of all the input rasters.",
	"@@Less-Than_Cellsize-Type_tag5@@": "Min Of--Use the smallest cell size of all the input rasters.",
	"@@Less-Than_Extent-Type_tag0@@": "Choose which extent should be used in the output raster:",
	"@@Less-Than_Extent-Type_tag1@@": "First Of--Use the extent of the first input raster to determine the processing extent.",
	"@@Less-Than_Extent-Type_tag2@@": "Intersection Of--Use the extent of the overlapping pixels to determine the processing extent. This is the default.",
	"@@Less-Than_Extent-Type_tag3@@": "Last Of--Use the extent of the last input raster to determine the processing extent.",
	"@@Less-Than_Extent-Type_tag4@@": "Union Of--Use the extent of all the rasters to determine the processing extent.",
	"@@Less-Than_Raster_tag0@@": "The input being tested to determine if it is less than the second input.",
	"@@Less-Than_Raster_tag1@@": "A constant value can be used as an input for this parameter, provided a raster is specified for the other parameter.",
	"@@Less-Than_Raster2_tag0@@": "The input against which the first input is tested to be less than.",
	"@@Less-Than_Raster2_tag1@@": "A constant value can be used as an input for this parameter, provided a raster is specified for the other parameter.",
	"@@Less-Than-Equal_Cellsize-Type_tag0@@": "Choose which cell size to use in the output raster. If all the input cell sizes are the same, all the options will yield the same results.",
	"@@Less-Than-Equal_Cellsize-Type_tag1@@": "First Of--Use the first cell size of the input rasters.",
	"@@Less-Than-Equal_Cellsize-Type_tag2@@": "Last Of--Use the last cell size of the input rasters.",
	"@@Less-Than-Equal_Cellsize-Type_tag3@@": "Max Of--Use the largest cell size of all the input rasters. This is the default.",
	"@@Less-Than-Equal_Cellsize-Type_tag4@@": "Mean Of--Use the mean cell size of all the input rasters.",
	"@@Less-Than-Equal_Cellsize-Type_tag5@@": "Min Of--Use the smallest cell size of all the input rasters.",
	"@@Less-Than-Equal_Extent-Type_tag0@@": "Choose which extent should be used in the output raster:",
	"@@Less-Than-Equal_Extent-Type_tag1@@": "First Of--Use the extent of the first input raster to determine the processing extent.",
	"@@Less-Than-Equal_Extent-Type_tag2@@": "Intersection Of--Use the extent of the overlapping pixels to determine the processing extent. This is the default.",
	"@@Less-Than-Equal_Extent-Type_tag3@@": "Last Of--Use the extent of the last input raster to determine the processing extent.",
	"@@Less-Than-Equal_Extent-Type_tag4@@": "Union Of--Use the extent of all the rasters to determine the processing extent.",
	"@@Less-Than-Equal_Raster_tag0@@": "The input being tested to determine if it is less than or equal to the second input.",
	"@@Less-Than-Equal_Raster_tag1@@": "A constant value can be used as an input for this parameter, provided a raster is specified for the other parameter.",
	"@@Less-Than-Equal_Raster2_tag0@@": "The input against which the first input is tested to be less than or equal to.",
	"@@Less-Than-Equal_Raster2_tag1@@": "A constant value can be used as an input for this parameter, provided a raster is specified for the other parameter.",
	"@@Ln_Cellsize-Type_tag0@@": "Choose which cell size to use in the output raster. If all the input cell sizes are the same, all the options will yield the same results.",
	"@@Ln_Cellsize-Type_tag1@@": "First Of--Use the first cell size of the input rasters.",
	"@@Ln_Cellsize-Type_tag2@@": "Last Of--Use the last cell size of the input rasters.",
	"@@Ln_Cellsize-Type_tag3@@": "Max Of--Use the largest cell size of all the input rasters. This is the default.",
	"@@Ln_Cellsize-Type_tag4@@": "Mean Of--Use the mean cell size of all the input rasters.",
	"@@Ln_Cellsize-Type_tag5@@": "Min Of--Use the smallest cell size of all the input rasters.",
	"@@Ln_Extent-Type_tag0@@": "Choose which extent should be used in the output raster:",
	"@@Ln_Extent-Type_tag1@@": "First Of--Use the extent of the first input raster to determine the processing extent.",
	"@@Ln_Extent-Type_tag2@@": "Intersection Of--Use the extent of the overlapping pixels to determine the processing extent. This is the default.",
	"@@Ln_Extent-Type_tag3@@": "Last Of--Use the extent of the last input raster to determine the processing extent.",
	"@@Ln_Extent-Type_tag4@@": "Union Of--Use the extent of all the rasters to determine the processing extent.",
	"@@Ln_Raster_tag0@@": "Input values for which to find the natural logarithm (Ln).",
	"@@Log10_Cellsize-Type_tag0@@": "Choose which cell size to use in the output raster. If all the input cell sizes are the same, all the options will yield the same results.",
	"@@Log10_Cellsize-Type_tag1@@": "First Of--Use the first cell size of the input rasters.",
	"@@Log10_Cellsize-Type_tag2@@": "Last Of--Use the last cell size of the input rasters.",
	"@@Log10_Cellsize-Type_tag3@@": "Max Of--Use the largest cell size of all the input rasters. This is the default.",
	"@@Log10_Cellsize-Type_tag4@@": "Mean Of--Use the mean cell size of all the input rasters.",
	"@@Log10_Cellsize-Type_tag5@@": "Min Of--Use the smallest cell size of all the input rasters.",
	"@@Log10_Extent-Type_tag0@@": "Choose which extent should be used in the output raster:",
	"@@Log10_Extent-Type_tag1@@": "First Of--Use the extent of the first input raster to determine the processing extent.",
	"@@Log10_Extent-Type_tag2@@": "Intersection Of--Use the extent of the overlapping pixels to determine the processing extent. This is the default.",
	"@@Log10_Extent-Type_tag3@@": "Last Of--Use the extent of the last input raster to determine the processing extent.",
	"@@Log10_Extent-Type_tag4@@": "Union Of--Use the extent of all the rasters to determine the processing extent.",
	"@@Log10_Raster_tag0@@": "Input values for which to find the base 10 logarithm.",
	"@@Log2_Cellsize-Type_tag0@@": "Choose which cell size to use in the output raster. If all the input cell sizes are the same, all the options will yield the same results.",
	"@@Log2_Cellsize-Type_tag1@@": "First Of--Use the first cell size of the input rasters.",
	"@@Log2_Cellsize-Type_tag2@@": "Last Of--Use the last cell size of the input rasters.",
	"@@Log2_Cellsize-Type_tag3@@": "Max Of--Use the largest cell size of all the input rasters. This is the default.",
	"@@Log2_Cellsize-Type_tag4@@": "Mean Of--Use the mean cell size of all the input rasters.",
	"@@Log2_Cellsize-Type_tag5@@": "Min Of--Use the smallest cell size of all the input rasters.",
	"@@Log2_Extent-Type_tag0@@": "Choose which extent should be used in the output raster:",
	"@@Log2_Extent-Type_tag1@@": "First Of--Use the extent of the first input raster to determine the processing extent.",
	"@@Log2_Extent-Type_tag2@@": "Intersection Of--Use the extent of the overlapping pixels to determine the processing extent. This is the default.",
	"@@Log2_Extent-Type_tag3@@": "Last Of--Use the extent of the last input raster to determine the processing extent.",
	"@@Log2_Extent-Type_tag4@@": "Union Of--Use the extent of all the rasters to determine the processing extent.",
	"@@Log2_Raster_tag0@@": "Input values for which to find the base 2 logarithm.",
	"@@Lookup_Field_tag0@@": "Field containing the desired values for the new raster.",
	"@@Lookup_Field_tag1@@": "It has to be a numeric type.",
	"@@Lookup_Raster_tag0@@": "The input raster that contains a field from which to create a new raster.",
	"@@Lookup_Raster_tag1@@": "It can be either integer or floating-point type.",
	"@@Mask_Included-Ranges_tag0@@": "The included ranges can be specified for each band by specifying a minimum and maximum value; any values outside the range will be returned as ${NoData}. A pixel is included if the pixel's value falls within any of the ranges specified. Therefore, if band 1 has a range of 5-10 and band 2 has a range of 15-20, and the pixel value for band 1 is 8, this pixel will not be masked.",
	"@@Mask_NoData-Interpretation_tag0@@": "This refers to how <strong>${NoData} Values</strong> will impact the output image.",
	"@@Mask_NoData-Interpretation_tag3@@": "You can select from the following two options:",
	"@@Mask_NoData-Interpretation_tag4@@": "<strong>Match All</strong>--The ${NoData} values you specify for each band must occur in the same pixel for the output image to contain the ${NoData} pixel.",
	"@@Mask_NoData-Interpretation_tag6@@": "<strong>Match Any</strong>--If the ${NoData} value you specify occurs for a pixel in a specified band, that pixel in the output image will be ${NoData}. This is the default.",
	"@@Mask_NoData-Values_tag0@@": "The NoData values can be specified for each band. You can specify more than one value by entering a space-delimited list.",
	"@@Mask_Raster_tag0@@": "The input raster.",
	"@@Minus_Cellsize-Type_tag0@@": "Choose which cell size to use in the output raster. If all the input cell sizes are the same, all the options will yield the same results.",
	"@@Minus_Cellsize-Type_tag1@@": "First Of--Use the first cell size of the input rasters.",
	"@@Minus_Cellsize-Type_tag2@@": "Last Of--Use the last cell size of the input rasters.",
	"@@Minus_Cellsize-Type_tag3@@": "Max Of--Use the largest cell size of all the input rasters. This is the default.",
	"@@Minus_Cellsize-Type_tag4@@": "Mean Of--Use the mean cell size of all the input rasters.",
	"@@Minus_Cellsize-Type_tag5@@": "Min Of--Use the smallest cell size of all the input rasters.",
	"@@Minus_Extent-Type_tag0@@": "Choose which extent should be used in the output raster:",
	"@@Minus_Extent-Type_tag1@@": "First Of--Use the extent of the first input raster to determine the processing extent.",
	"@@Minus_Extent-Type_tag2@@": "Intersection Of--Use the extent of the overlapping pixels to determine the processing extent. This is the default.",
	"@@Minus_Extent-Type_tag3@@": "Last Of--Use the extent of the last input raster to determine the processing extent.",
	"@@Minus_Extent-Type_tag4@@": "Union Of--Use the extent of all the rasters to determine the processing extent.",
	"@@Minus_Raster_tag0@@": "The input from which to subtract the values of the second input.",
	"@@Minus_Raster_tag1@@": "A constant value can be used as an input for this parameter, provided a raster is specified for the other parameter.",
	"@@Minus_Raster2_tag0@@": "The input values to subtract from the values of the first input.",
	"@@Minus_Raster2_tag1@@": "A constant value can be used as an input for this parameter, provided a raster is specified for the other parameter.",
	"@@ML-Classify_Raster_tag0@@": "The input raster to classify using the maximum likelihood classification algorithm.",
	"@@ML-Classify_Signature-File-or-URL_tag0@@": "The ${.gsg} signature file.",
	"@@Mod_Cellsize-Type_tag0@@": "Choose which cell size to use in the output raster. If all the input cell sizes are the same, all the options will yield the same results.",
	"@@Mod_Cellsize-Type_tag1@@": "First Of--Use the first cell size of the input rasters.",
	"@@Mod_Cellsize-Type_tag2@@": "Last Of--Use the last cell size of the input rasters.",
	"@@Mod_Cellsize-Type_tag3@@": "Max Of--Use the largest cell size of all the input rasters. This is the default.",
	"@@Mod_Cellsize-Type_tag4@@": "Mean Of--Use the mean cell size of all the input rasters.",
	"@@Mod_Cellsize-Type_tag5@@": "Min Of--Use the smallest cell size of all the input rasters.",
	"@@Mod_Extent-Type_tag0@@": "Choose which extent should be used in the output raster:",
	"@@Mod_Extent-Type_tag1@@": "First Of--Use the extent of the first input raster to determine the processing extent.",
	"@@Mod_Extent-Type_tag2@@": "Intersection Of--Use the extent of the overlapping pixels to determine the processing extent. This is the default.",
	"@@Mod_Extent-Type_tag3@@": "Last Of--Use the extent of the last input raster to determine the processing extent.",
	"@@Mod_Extent-Type_tag4@@": "Union Of--Use the extent of all the rasters to determine the processing extent.",
	"@@Mod_Raster_tag0@@": "The numerator input.",
	"@@Mod_Raster_tag1@@": "A constant value can be used as an input for this parameter, provided a raster is specified for the other parameter.",
	"@@Mod_Raster2_tag0@@": "The denominator input.",
	"@@Mod_Raster2_tag1@@": "A constant value can be used as an input for this parameter, provided a raster is specified for the other parameter.",
	"@@Mosaic-Rasters_Operation_tag0@@": "Resolve any conflict when you have parts of two or more images that overlap. The options include the following:",
	"@@Mosaic-Rasters_Operation_tag1@@": "<strong>Blend</strong>--Calculate and display an average of the overlapping pixels by giving more weight to pixels that are closer to neighboring images so the output is a smoother image. This is the default.",
	"@@Mosaic-Rasters_Operation_tag3@@": "<strong>First</strong>--Display the pixels from the first image in the list of images overlapping a given area.",
	"@@Mosaic-Rasters_Operation_tag5@@": "<strong>Last</strong>--Display the pixels from the last image in the list of images overlapping a given area.",
	"@@Mosaic-Rasters_Operation_tag7@@": "<strong>Max</strong>--Display the highest valued pixel of all the overlapping layers. With this option, you have no guarantee of displaying the pixels of just one image in the overlapping area but rather a combination of all potential layers.",
	"@@Mosaic-Rasters_Operation_tag9@@": "<strong>Mean</strong>--Calculate and display an average of the overlapping pixels.",
	"@@Mosaic-Rasters_Operation_tag11@@": "<strong>Min</strong>--Display the lowest valued pixel of all the overlapping layers. With this option, you have no guarantee of displaying the pixels of just one image in the overlapping area but rather a combination of all potential layers.",
	"@@Mosaic-Rasters_Rasters_tag0@@": "Select the rasters you want to mosaic together to form one image.",
	"@@NDVI_Infrared-Band-ID_tag0@@": "Specifies the band ID that represents the near-infrared part of the electromagnetic spectrum.",
	"@@NDVI_Raster_tag0@@": "The input multispectral raster.",
	"@@NDVI_Scientific-Output_tag0@@": "The output values will range from -1.0 to 1.0, which is used in many scientific applications.",
	"@@NDVI_Visible-Band-ID_tag0@@": "Specifies the band ID that represents the red part of the electromagnetic spectrum.",
	"@@NDVI-Colorized_Color-Ramp_tag0@@": "Choose a predefined color scheme from the drop down list.",
	"@@NDVI-Colorized_Color-Scheme-Type_tag0@@": "Chose which type of color scheme to colorize the NDVI output:",
	"@@NDVI-Colorized_Color-Scheme-Type_tag1@@": "Colormap--Choose a predefined color map from the drop down list. Alternatively, you can browse to a persisted color map file that exists.",
	"@@NDVI-Colorized_Color-Scheme-Type_tag2@@": "Color Ramp--Choose a predefined color scheme from the drop down list.",
	"@@NDVI-Colorized_Colormap_tag0@@": "Choose a predefined color map from the drop down list. Alternatively, you can browse to an existing color map file.",
	"@@NDVI-Colorized_Infrared-Band-ID_tag0@@": "Specifies the band ID that represents the near-infrared part of the electromagnetic spectrum.",
	"@@NDVI-Colorized_Raster_tag0@@": "The input multispectral raster.",
	"@@NDVI-Colorized_Scientific-Output_tag0@@": "The output values will range from -1.0 to 1.0, which is used in many scientific applications.",
	"@@NDVI-Colorized_Visible-Band-ID_tag0@@": "Specifies the band ID that represents the red part of the electromagnetic spectrum.",
	"@@Negate_Cellsize-Type_tag0@@": "Choose which cell size to use in the output raster. If all the input cell sizes are the same, all the options will yield the same results.",
	"@@Negate_Cellsize-Type_tag1@@": "First Of--Use the first cell size of the input rasters.",
	"@@Negate_Cellsize-Type_tag2@@": "Last Of--Use the last cell size of the input rasters.",
	"@@Negate_Cellsize-Type_tag3@@": "Max Of--Use the largest cell size of all the input rasters. This is the default.",
	"@@Negate_Cellsize-Type_tag4@@": "Mean Of--Use the mean cell size of all the input rasters.",
	"@@Negate_Cellsize-Type_tag5@@": "Min Of--Use the smallest cell size of all the input rasters.",
	"@@Negate_Extent-Type_tag0@@": "Choose which extent should be used in the output raster:",
	"@@Negate_Extent-Type_tag1@@": "First Of--Use the extent of the first input raster to determine the processing extent.",
	"@@Negate_Extent-Type_tag2@@": "Intersection Of--Use the extent of the overlapping pixels to determine the processing extent. This is the default.",
	"@@Negate_Extent-Type_tag3@@": "Last Of--Use the extent of the last input raster to determine the processing extent.",
	"@@Negate_Extent-Type_tag4@@": "Union Of--Use the extent of all the rasters to determine the processing extent.",
	"@@Negate_Raster_tag0@@": "The input raster to be negated (multiplied by -1).",
	"@@Nibble_Mask-Raster_tag0@@": "The required input raster used as the mask.",
	"@@Nibble_Mask-Raster_tag1@@": "Cells with NoData as their value will be nibbled in the input <strong>Raster</strong>.",
	"@@Nibble_Mask-Raster_tag4@@": "The mask raster can be an integer or a floating-point type.",
	"@@Nibble_Nibble-NoData-cells_tag0@@": "Defines if NoData cells in the input raster will remain NoData in the output raster.",
	"@@Nibble_Nibble-NoData-cells_tag1@@": "<strong>No</strong>--Specifies that NoData cells in the input raster will remain NoData in the output. This is the default.",
	"@@Nibble_Nibble-NoData-cells_tag3@@": "<strong>Yes</strong>--Specifies that NoData cells in the input raster and within the mask can be nibbled into valid output cell values.",
	"@@Nibble_Raster_tag0@@": "The required input raster that will be nibbled.",
	"@@Nibble_Raster_tag1@@": "The input raster can be an integer or a floating-point type.",
	"@@Nibble_Use-NoData-values-if-they-are-the-nearest-neighbor_tag0@@": "Defines if ${NoData} values in the input raster are allowed to nibble into the area defined by the mask raster.",
	"@@Nibble_Use-NoData-values-if-they-are-the-nearest-neighbor_tag1@@": "<strong>Yes</strong>--Specifies that the nearest neighbor value will be used whether it is ${NoData} or another data value in the input raster. ${NoData} values in the input raster are free to nibble into areas defined in the mask if they are the nearest neighbor. This is the default.",
	"@@Nibble_Use-NoData-values-if-they-are-the-nearest-neighbor_tag3@@": "<strong>No</strong>--Specifies that only data values are free to nibble into areas defined in the mask raster. ${NoData} values in the input raster are not allowed to nibble into areas defined in the mask raster even if they are the nearest neighbor.",
	"@@Nibble_Zone-Raster_tag0@@": "The input zone raster.",
	"@@Nibble_Zone-Raster_tag1@@": "A zone is all the cells in a raster that have the same value, whether or not they are contiguous. The input zone layer defines the shape, values, and locations of the zones. The zone raster can be either integer or floating point type.",
	"@@Not-Equal_Cellsize-Type_tag0@@": "Choose which cell size to use in the output raster. If all the input cell sizes are the same, all the options will yield the same results.",
	"@@Not-Equal_Cellsize-Type_tag1@@": "First Of--Use the first cell size of the input rasters.",
	"@@Not-Equal_Cellsize-Type_tag2@@": "Last Of--Use the last cell size of the input rasters.",
	"@@Not-Equal_Cellsize-Type_tag3@@": "Max Of--Use the largest cell size of all the input rasters. This is the default.",
	"@@Not-Equal_Cellsize-Type_tag4@@": "Mean Of--Use the mean cell size of all the input rasters.",
	"@@Not-Equal_Cellsize-Type_tag5@@": "Min Of--Use the smallest cell size of all the input rasters.",
	"@@Not-Equal_Extent-Type_tag0@@": "Choose which extent should be used in the output raster:",
	"@@Not-Equal_Extent-Type_tag1@@": "First Of--Use the extent of the first input raster to determine the processing extent.",
	"@@Not-Equal_Extent-Type_tag2@@": "Intersection Of--Use the extent of the overlapping pixels to determine the processing extent. This is the default.",
	"@@Not-Equal_Extent-Type_tag3@@": "Last Of--Use the extent of the last input raster to determine the processing extent.",
	"@@Not-Equal_Extent-Type_tag4@@": "Union Of--Use the extent of all the rasters to determine the processing extent.",
	"@@Not-Equal_Raster_tag0@@": "The input that will be compared to for inequality by the second input.",
	"@@Not-Equal_Raster_tag1@@": "A constant value can be used as an input for this parameter, provided a raster is specified for the other parameter.",
	"@@Not-Equal_Raster2_tag0@@": "The input that will be compared to the first input for inequality.",
	"@@Not-Equal_Raster2_tag1@@": "A constant value can be used as an input for this parameter, provided a raster is specified for the other parameter.",
	"@@Pansharpening_Multispectral_tag0@@": "The multispectral raster that you want to sharpen using the panchromatic band.",
	"@@Pansharpening_Panchromatic_tag0@@": "The high-resolution, single-band raster that will be used to pan sharpen the lower-resolution multispectral raster.",
	"@@Pansharpening_Pansharpening-Type_tag0@@": "Choose the pan sharpening algorithm you want to use.",
	"@@Pansharpening_Pansharpening-Type_tag1@@": "Brovey--Uses the Brovey algorithm based on spectral modeling for data fusion.",
	"@@Pansharpening_Pansharpening-Type_tag2@@": "Esri--Uses the Esri algorithm based on spectral modeling for data fusion.",
	"@@Pansharpening_Pansharpening-Type_tag3@@": "Gram-Schmidt--Uses the Gram-Schmidt spectral-sharpening algorithm to sharpen multispectral data.",
	"@@Pansharpening_Pansharpening-Type_tag4@@": "IHS--Uses Intensity, Hue, and Saturation color space for data fusion.",
	"@@Pansharpening_Pansharpening-Type_tag5@@": "Mean--Uses the averaged value between the red, green, and blue values and the panchromatic pixel value.",
	"@@Pansharpening_Weights_tag0@@": "Specify the weights for the red, green, blue, and infrared bands. All values should be within the range of 0 to 1.",
	"@@Path-Distance_Accumulative-Cost-Resistance-Rate_tag0@@": "This parameter simulates the increase in the effort to overcome costs as the accumulative cost increases. It is used to model fatigue of the traveler. The growing accumulative cost to reach a cell is multiplied by the resistance rate and added to the cost to move into the subsequent cell.",
	"@@Path-Distance_Accumulative-Cost-Resistance-Rate_tag1@@": "It's a modified version of a compound interest rate formula that's used to calculate the apparent cost of moving through a cell. As the value of the resistance rate increases, it increases the cost of the cells that are visited later. The greater the resistance rate, the higher the cost to reach the next cell, which is compounded for each subsequent movement. Since the resistance rate is similar to a compound rate and generally the accumulative cost values are very large, small resistance rates are suggested, such as 0.005 or even smaller, depending on the accumulative cost values.",
	"@@Path-Distance_Accumulative-Cost-Resistance-Rate_tag2@@": "The value must be greater than zero. The default capacity is to the edge of the output raster.",
	"@@Path-Distance_Capacity_tag0@@": "Defines the cost capacity for the traveler for a source. The cost calculations continue for each source until the specified capacity is reached.",
	"@@Path-Distance_Capacity_tag1@@": "The value must be greater than zero. The default capacity is to the edge of the output raster.",
	"@@Path-Distance_Cost-Raster_tag0@@": "A required input raster defining the cost or impedance to move planimetrically through each cell. The value at each cell location represents the cost-per-unit distance for moving through it. Each cell location value is multiplied by the cell resolution, and also compensates for diagonal movement to obtain the total cost of passing through the cell.",
	"@@Path-Distance_Cost-Raster_tag1@@": "The values of the <strong>Cost Raster</strong> can be integer or floating point, but they cannot be negative or zero.",
	"@@Path-Distance_horizontalfactor_tag0@@": "<p>Defines the relationship between the horizontal cost factor and the horizontal relative moving angle (HRMA).</p><p>There are several factors with modifiers that identify a defined vertical factor graph. Additionally, a table can be used to create a custom graph. The graphs are used to identify the vertical factor used in calculating the total cost of moving into a neighboring cell.</p><p>In the explanations below, two acronyms are used: HF and HRMA. HF stands for horizontal factor, which defines the horizontal difficulty encountered when moving from one cell to the next. HRMA stands for horizontal relative moving angle, which identifies the angle between the horizontal direction from a cell and the moving direction.</p><p><strong>Horizontal factor</strong>types include the following:</p><ul><li><strong>Binary</strong>--Indicates that if the HRMA is less than the cut angle, the HF is set to the value associated with the zero factor; otherwise, it is infinity.</li><li><strong>Forward</strong>--Establishes that only forward movement is allowed. The HRMA must be greater than or equal to 0 and less than 90 degrees (0 &lt;= HRMA &lt; 90). If the HRMA is greater than 0 and less than 45 degrees, the HF for the cell is set to the value associated with the zero factor. If the HRMA is greater than or equal to 45 degrees, the side value modifier value is used. The HF for any HRMA value equal to or greater than 90 degrees is set to infinity.</li><li><strong>Linear</strong>--Specifies that the HF is a linear function of the HRMA.</li><li><strong>Inverse Linear</strong>--Specifies that the HF is an inverse linear function of the HRMA.</li><li><strong>Table</strong>--Identifies that a table file will be used to define the horizontal factor graph used to determine the HFs.</li></ul><p>Modifiers to the horizontal factors include the following:</p><ul><li><strong>Zero factor</strong>--The horizontal factor to be used when the HRMA is zero. This factor positions the y-intercept for any of the horizontal factor functions.</li><li><strong>Cut angle</strong>--Defines the HRMA angle beyond which the HF will be set to infinity.</li><li><strong>Slope</strong>--Establishes the slope of the straight line used with the<strong>Linear</strong>and<strong>Inverse Linear</strong>horizontal factor keywords. The slope is specified as a fraction of rise over run (for example, 45 percent slope is 1/45, which is input as 0.02222).</li><li><strong>Side value</strong>--Establishes the HF when the HRMA is greater than or equal to 45 degrees and less than 90 degrees when the<strong>Forward</strong>horizontal factor keyword is specified.</li><li><strong>Table name</strong>--Identifies the name of the table defining the HF.</li></ul>",
	"@@Path-Distance_Horizontal-Raster_tag0@@": "A raster defining the horizontal direction at each cell.",
	"@@Path-Distance_Horizontal-Raster_tag1@@": "The values on the raster must be integers ranging from 0 to 360, with 0 degrees being north, or toward the top of the screen, and increasing clockwise. Flat areas should be given a value of -1. The values at each location will be used in conjunction with the <strong>Horizontal factor</strong> to determine the horizontal cost incurred when moving from a cell to its neighbors.",
	"@@Path-Distance_Maximum-Distance_tag0@@": "The threshold that the accumulative cost values cannot exceed. If an accumulative cost distance exceeds this value, the output value for the cell location will be NoData. The maximum distance defines the extent for which the accumulative cost distances are calculated. The default distance is to the extent of the output raster.",
	"@@Path-Distance_Multiplier-to-Apply-to-Costs_tag0@@": "A multiplier to apply to the cost values.",
	"@@Path-Distance_Multiplier-to-Apply-to-Costs_tag1@@": "This parameter allows for control of the mode of travel or the magnitude at a source. The greater the multiplier, the greater the cost to move through each cell.",
	"@@Path-Distance_Multiplier-to-Apply-to-Costs_tag2@@": "The values must be greater than zero. The default is 1.",
	"@@Path-Distance_Multiplier-to-Apply-to-Costs_tag3@@": "A numeric (double) value or a field from the <strong>Source Raster</strong> can be used for this parameter.",
	"@@Path-Distance_Source-Raster_tag0@@": "The required input raster of source locations.",
	"@@Path-Distance_Source-Raster_tag1@@": "This is a raster that identifies the cells or locations from which the least accumulated cost distance for every output cell location is calculated.",
	"@@Path-Distance_Source-Raster_tag2@@": "It can be an integer or a floating-point type.",
	"@@Path-Distance_Start-Cost_tag0@@": "The starting cost from which to begin the cost calculations. This parameter allows for the specification of the fixed cost associated with a source. Instead of starting at a cost of 0, the cost algorithm will begin with the value specified.",
	"@@Path-Distance_Start-Cost_tag1@@": "The value must be zero or greater. The default is 0.",
	"@@Path-Distance_Surface-Raster_tag0@@": "A raster defining the elevation values at each cell location.",
	"@@Path-Distance_Surface-Raster_tag1@@": "The values are used to calculate the actual surface distance covered when passing between cells.",
	"@@Path-Distance_Travel-Direction_tag0@@": "Defines the direction of the traveler when applying the source resistance rate and the source starting cost.",
	"@@Path-Distance_Travel-Direction_tag1@@": "<strong>From Source</strong>--The source resistance rate and source starting cost will be applied beginning at the input source and moving out to the non-source cells. This is the default.",
	"@@Path-Distance_Travel-Direction_tag3@@": "<strong>To Source</strong>--The source resistance rate and source starting cost will be applied beginning at each non-source cell and moving back to the input source.",
	"@@Path-Distance_Travel-Direction_tag5@@": "Either specify the <strong>From Source</strong> or <strong>To Source</strong> keyword, which will be applied to all sources, or specify a field in the <strong>Source Raster</strong> that contains the keywords to identify the direction of travel for each source. That field must contain the string ${FROM_SOURCE} or ${TO_SOURCE}.",
	"@@Path-Distance_verticalfactor_tag0@@": "<p>Defines the relationship between the vertical cost factor and the vertical relative moving angle (VRMA).</p><p>There are several factors with modifiers that identify a defined vertical factor graph. Additionally, a table can be used to create a custom graph. The graphs are used to identify the vertical factor used in calculating the total cost of moving into a neighboring cell.</p><p>In the explanations below, two acronyms are used: VF and VRMA. VF stands for vertical factor, which defines the vertical difficulty encountered in moving from one cell to the next. VRMA stands for vertical relative moving angle, which identifies the slope angle between the FROM, or processing, cell and the TO cell.</p><p><strong>Vertical factor</strong>types include the following:</p><ul><li><strong>Binary</strong>--Specifies that if the VRMA is greater than the low-cut angle and less than the high-cut angle, the VF is set to the value associated with the zero factor; otherwise, it is infinity.</li><li><strong>Linear</strong>--Indicates that the VF is a linear function of the VRMA.</li><li><strong>Symmetric Linear</strong>--Specifies that the VF is a linear function of the VRMA in either the negative or positive side of the VRMA, respectively, and the two linear functions are symmetrical with respect to the VF (y) axis.</li><li><strong>Inverse Linear</strong>--Indicates that the VF is an inverse linear function of the VRMA.</li><li><strong>Symmetric Inverse Linear</strong>--Specifies that the VF is an inverse linear function of the VRMA in either the negative or positive side of the VRMA, respectively, and the two linear functions are symmetrical with respect to the VF (y) axis.</li><li><strong>Cos</strong>--Identifies the VF as the cosine-based function of the VRMA.</li><li><strong>Sec</strong>--Identifies the VF as the secant-based function of the VRMA.</li><li><strong>Cos-Sec</strong>--Specifies that the VF is the cosine-based function of the VRMA when the VRMA is negative and the secant-based function of the VRMA when the VRMA is not negative.</li><li><strong>Sec-Cos</strong>--Specifies that the VF is the secant-based function of the VRMA when the VRMA is negative and the cosine-based function of the VRMA when the VRMA is not negative.</li><li><strong>Table</strong>--Identifies that a table file will be used to define the vertical-factor graph that is used to determine the VFs.</li></ul><p>Modifiers to the vertical keywords include the following:</p><ul><li><strong>Zero factor</strong>--Establishes the vertical factor used when the VRMA is zero. This factor positions the y-intercept of the specified function. By definition, the zero factor is not applicable to any of the trigonometric vertical functions (COS, SEC, COS-SEC, or SEC-COS). The y-intercept is defined by these functions.</li><li><strong>Low Cut angle</strong>--Defines the VRMA angle below which the VF will be set to infinity.</li><li><strong>High Cut angle</strong>--Defines the VRMA angle above which the VF will be set to infinity.</li><li><strong>Slope</strong>--Establishes the slope of the straight line used with the<strong>Linear</strong>and<strong>Inverse Linear</strong>vertical-factor keywords. The slope is specified as a fraction of rise over run (for example, 45 percent slope is 1/45, which is input as 0.02222).</li><li><strong>Table name</strong>--Identifies the name of the table defining the VF.</li></ul>",
	"@@Path-Distance_Vertical-Raster_tag0@@": "Defines the relationship between the vertical cost factor and the vertical relative moving angle (VRMA).",
	"@@Path-Distance_Vertical-Raster_tag1@@": "The values are used for calculating the slope used to identify the vertical factor incurred when moving from one cell to another.",
	"@@Path-Distance-Allocation_Accumulative-Cost-Resistance-Rate_tag0@@": "This parameter simulates the increase in the effort to overcome costs as the accumulative cost increases. It is used to model fatigue of the traveler. The growing accumulative cost to reach a cell is multiplied by the resistance rate and added to the cost to move into the subsequent cell.",
	"@@Path-Distance-Allocation_Accumulative-Cost-Resistance-Rate_tag1@@": "It's a modified version of a compound interest rate formula that's used to calculate the apparent cost of moving through a cell. As the value of the resistance rate increases, it increases the cost of the cells that are visited later. The greater the resistance rate, the higher the cost to reach the next cell, which is compounded for each subsequent movement. Since the resistance rate is similar to a compound rate and generally the accumulative cost values are very large, small resistance rates are suggested, such as 0.005 or even smaller, depending on the accumulative cost values.",
	"@@Path-Distance-Allocation_Accumulative-Cost-Resistance-Rate_tag2@@": "The value must be greater than zero. The default capacity is to the edge of the output raster.",
	"@@Path-Distance-Allocation_Capacity_tag0@@": "Defines the cost capacity for the traveler for a source. The cost calculations continue for each source until the specified capacity is reached.",
	"@@Path-Distance-Allocation_Capacity_tag1@@": "The value must be greater than zero. The default capacity is to the edge of the output raster.",
	"@@Path-Distance-Allocation_Cost-Raster_tag0@@": "A required input raster defining the cost or impedance to move planimetrically through each cell. The value at each cell location represents the cost-per-unit distance for moving through it. Each cell location value is multiplied by the cell resolution, and also compensates for diagonal movement to obtain the total cost of passing through the cell.",
	"@@Path-Distance-Allocation_Cost-Raster_tag1@@": "The values of the <strong>Cost Raster</strong> can be integer or floating point, but they cannot be negative or zero.",
	"@@Path-Distance-Allocation_horizontalfactor_tag0@@": "<p>Defines the relationship between the horizontal cost factor and the horizontal relative moving angle (HRMA).</p><p>There are several factors with modifiers that identify a defined vertical factor graph. Additionally, a table can be used to create a custom graph. The graphs are used to identify the vertical factor used in calculating the total cost of moving into a neighboring cell.</p><p>In the explanations below, two acronyms are used: HF and HRMA. HF stands for horizontal factor, which defines the horizontal difficulty encountered when moving from one cell to the next. HRMA stands for horizontal relative moving angle, which identifies the angle between the horizontal direction from a cell and the moving direction.</p><p><strong>Horizontal factor</strong>types include the following:</p><ul><li><strong>Binary</strong>--Indicates that if the HRMA is less than the cut angle, the HF is set to the value associated with the zero factor; otherwise, it is infinity.</li><li><strong>Forward</strong>--Establishes that only forward movement is allowed. The HRMA must be greater than or equal to 0 and less than 90 degrees (0 &lt;= HRMA &lt; 90). If the HRMA is greater than 0 and less than 45 degrees, the HF for the cell is set to the value associated with the zero factor. If the HRMA is greater than or equal to 45 degrees, the side value modifier value is used. The HF for any HRMA value equal to or greater than 90 degrees is set to infinity.</li><li><strong>Linear</strong>--Specifies that the HF is a linear function of the HRMA.</li><li><strong>Inverse Linear</strong>--Specifies that the HF is an inverse linear function of the HRMA.</li><li><strong>Table</strong>--Identifies that a table file will be used to define the horizontal factor graph used to determine the HFs.</li></ul><p>Modifiers to the horizontal factors include the following:</p><ul><li><strong>Zero factor</strong>--The horizontal factor to be used when the HRMA is zero. This factor positions the y-intercept for any of the horizontal factor functions.</li><li><strong>Cut angle</strong>--Defines the HRMA angle beyond which the HF will be set to infinity.</li><li><strong>Slope</strong>--Establishes the slope of the straight line used with the<strong>Linear</strong>and<strong>Inverse Linear</strong>horizontal factor keywords. The slope is specified as a fraction of rise over run (for example, 45 percent slope is 1/45, which is input as 0.02222).</li><li><strong>Side value</strong>--Establishes the HF when the HRMA is greater than or equal to 45 degrees and less than 90 degrees when the<strong>Forward</strong>horizontal factor keyword is specified.</li><li><strong>Table name</strong>--Identifies the name of the table defining the HF.</li></ul>",
	"@@Path-Distance-Allocation_Horizontal-Raster_tag0@@": "A raster defining the horizontal direction at each cell.",
	"@@Path-Distance-Allocation_Horizontal-Raster_tag1@@": "The values on the raster must be integers ranging from 0 to 360, with 0 degrees being north, or toward the top of the screen, and increasing clockwise. Flat areas should be given a value of -1. The values at each location will be used in conjunction with the <strong>Horizontal factor</strong> to determine the horizontal cost incurred when moving from a cell to its neighbors.",
	"@@Path-Distance-Allocation_Maximum-Distance_tag0@@": "The threshold that the accumulative cost values cannot exceed. If an accumulative cost distance exceeds this value, the output value for the cell location will be NoData. The maximum distance defines the extent for which the accumulative cost distances are calculated. The default distance is to the extent of the output raster.",
	"@@Path-Distance-Allocation_Multiplier-to-Apply-to-Costs_tag0@@": "A multiplier to apply to the cost values.",
	"@@Path-Distance-Allocation_Multiplier-to-Apply-to-Costs_tag1@@": "This parameter allows for control of the mode of travel or the magnitude at a source. The greater the multiplier, the greater the cost to move through each cell.",
	"@@Path-Distance-Allocation_Multiplier-to-Apply-to-Costs_tag2@@": "The values must be greater than zero. The default is 1.",
	"@@Path-Distance-Allocation_Multiplier-to-Apply-to-Costs_tag3@@": "A numeric (double) value or a field from the <strong>Source Raster</strong> can be used for this parameter.",
	"@@Path-Distance-Allocation_Source-Field_tag0@@": "The field used to assign values to the source locations. It must be an integer type. If the <strong>Value Raster</strong> has been set, the values in that input will take precedence over any setting for the <strong>Source Field</strong>.",
	"@@Path-Distance-Allocation_Source-Raster_tag0@@": "The required input raster of source locations.",
	"@@Path-Distance-Allocation_Source-Raster_tag1@@": "This is a raster that identifies the cells or locations from which the least accumulated cost distance for every output cell location is calculated.",
	"@@Path-Distance-Allocation_Source-Raster_tag2@@": "It can be an integer or a floating-point type.",
	"@@Path-Distance-Allocation_Start-Cost_tag0@@": "The starting cost from which to begin the cost calculations. This parameter allows for the specification of the fixed cost associated with a source. Instead of starting at a cost of 0, the cost algorithm will begin with the value specified.",
	"@@Path-Distance-Allocation_Start-Cost_tag1@@": "The value must be zero or greater. The default is 0.",
	"@@Path-Distance-Allocation_Surface-Raster_tag0@@": "A raster defining the elevation values at each cell location.",
	"@@Path-Distance-Allocation_Surface-Raster_tag1@@": "The values are used to calculate the actual surface distance covered when passing between cells.",
	"@@Path-Distance-Allocation_Travel-Direction_tag0@@": "Defines the direction of the traveler when applying the source resistance rate and the source starting cost.",
	"@@Path-Distance-Allocation_Travel-Direction_tag1@@": "<strong>From Source</strong>--The source resistance rate and source starting cost will be applied beginning at the input source and moving out to the non-source cells. This is the default.",
	"@@Path-Distance-Allocation_Travel-Direction_tag3@@": "<strong>To Source</strong>--The source resistance rate and source starting cost will be applied beginning at each non-source cell and moving back to the input source.",
	"@@Path-Distance-Allocation_Travel-Direction_tag5@@": "Either specify the <strong>From Source</strong> or <strong>To Source</strong> keyword, which will be applied to all sources, or specify a field in the <strong>Source Raster</strong> that contains the keywords to identify the direction of travel for each source. That field must contain the string ${FROM_SOURCE} or ${TO_SOURCE}.",
	"@@Path-Distance-Allocation_Value-Raster_tag0@@": "The input integer raster that identifies the zone values to be used for each input source location. For each source location cell, the value defined by the <strong>Value Raster</strong> will be assigned to all cells allocated to the source location for the computation. The <strong>Value Raster</strong> will take precedence over any setting for the <strong>Source Field</strong>.",
	"@@Path-Distance-Allocation_verticalfactor_tag0@@": "<p>Defines the relationship between the vertical cost factor and the vertical relative moving angle (VRMA).</p><p>There are several factors with modifiers that identify a defined vertical factor graph. Additionally, a table can be used to create a custom graph. The graphs are used to identify the vertical factor used in calculating the total cost of moving into a neighboring cell.</p><p>In the explanations below, two acronyms are used: VF and VRMA. VF stands for vertical factor, which defines the vertical difficulty encountered in moving from one cell to the next. VRMA stands for vertical relative moving angle, which identifies the slope angle between the FROM, or processing, cell and the TO cell.</p><p><strong>Vertical factor</strong>types include the following:</p><ul><li><strong>Binary</strong>--Specifies that if the VRMA is greater than the low-cut angle and less than the high-cut angle, the VF is set to the value associated with the zero factor; otherwise, it is infinity.</li><li><strong>Linear</strong>--Indicates that the VF is a linear function of the VRMA.</li><li><strong>Symmetric Linear</strong>--Specifies that the VF is a linear function of the VRMA in either the negative or positive side of the VRMA, respectively, and the two linear functions are symmetrical with respect to the VF (y) axis.</li><li><strong>Inverse Linear</strong>--Indicates that the VF is an inverse linear function of the VRMA.</li><li><strong>Symmetric Inverse Linear</strong>--Specifies that the VF is an inverse linear function of the VRMA in either the negative or positive side of the VRMA, respectively, and the two linear functions are symmetrical with respect to the VF (y) axis.</li><li><strong>Cos</strong>--Identifies the VF as the cosine-based function of the VRMA.</li><li><strong>Sec</strong>--Identifies the VF as the secant-based function of the VRMA.</li><li><strong>Cos-Sec</strong>--Specifies that the VF is the cosine-based function of the VRMA when the VRMA is negative and the secant-based function of the VRMA when the VRMA is not negative.</li><li><strong>Sec-Cos</strong>--Specifies that the VF is the secant-based function of the VRMA when the VRMA is negative and the cosine-based function of the VRMA when the VRMA is not negative.</li><li><strong>Table</strong>--Identifies that a table file will be used to define the vertical-factor graph that is used to determine the VFs.</li></ul><p>Modifiers to the vertical keywords include the following:</p><ul><li><strong>Zero factor</strong>--Establishes the vertical factor used when the VRMA is zero. This factor positions the y-intercept of the specified function. By definition, the zero factor is not applicable to any of the trigonometric vertical functions (COS, SEC, COS-SEC, or SEC-COS). The y-intercept is defined by these functions.</li><li><strong>Low Cut angle</strong>--Defines the VRMA angle below which the VF will be set to infinity.</li><li><strong>High Cut angle</strong>--Defines the VRMA angle above which the VF will be set to infinity.</li><li><strong>Slope</strong>--Establishes the slope of the straight line used with the<strong>Linear</strong>and<strong>Inverse Linear</strong>vertical-factor keywords. The slope is specified as a fraction of rise over run (for example, 45 percent slope is 1/45, which is input as 0.02222).</li><li><strong>Table name</strong>--Identifies the name of the table defining the VF.</li></ul>",
	"@@Path-Distance-Allocation_Vertical-Raster_tag0@@": "Defines the relationship between the vertical cost factor and the vertical relative moving angle (VRMA).",
	"@@Path-Distance-Allocation_Vertical-Raster_tag1@@": "The values are used for calculating the slope used to identify the vertical factor incurred when moving from one cell to another.",
	"@@Path-Distance-Back-Link_Accumulative-Cost-Resistance-Rate_tag0@@": "This parameter simulates the increase in the effort to overcome costs as the accumulative cost increases. It is used to model fatigue of the traveler. The growing accumulative cost to reach a cell is multiplied by the resistance rate and added to the cost to move into the subsequent cell.",
	"@@Path-Distance-Back-Link_Accumulative-Cost-Resistance-Rate_tag1@@": "It's a modified version of a compound interest rate formula that's used to calculate the apparent cost of moving through a cell. As the value of the resistance rate increases, it increases the cost of the cells that are visited later. The greater the resistance rate, the higher the cost to reach the next cell, which is compounded for each subsequent movement. Since the resistance rate is similar to a compound rate and generally the accumulative cost values are very large, small resistance rates are suggested, such as 0.005 or even smaller, depending on the accumulative cost values.",
	"@@Path-Distance-Back-Link_Accumulative-Cost-Resistance-Rate_tag2@@": "The value must be greater than zero. The default capacity is to the edge of the output raster.",
	"@@Path-Distance-Back-Link_Capacity_tag0@@": "Defines the cost capacity for the traveler for a source. The cost calculations continue for each source until the specified capacity is reached.",
	"@@Path-Distance-Back-Link_Capacity_tag1@@": "The value must be greater than zero. The default capacity is to the edge of the output raster.",
	"@@Path-Distance-Back-Link_Cost-Raster_tag0@@": "A required input raster defining the cost or impedance to move planimetrically through each cell. The value at each cell location represents the cost-per-unit distance for moving through it. Each cell location value is multiplied by the cell resolution, and also compensates for diagonal movement to obtain the total cost of passing through the cell.",
	"@@Path-Distance-Back-Link_Cost-Raster_tag1@@": "The values of the <strong>Cost Raster</strong> can be integer or floating point, but they cannot be negative or zero.",
	"@@Path-Distance-Back-Link_horizontalfactor_tag0@@": "<p>Defines the relationship between the horizontal cost factor and the horizontal relative moving angle (HRMA).</p><p>There are several factors with modifiers that identify a defined vertical factor graph. Additionally, a table can be used to create a custom graph. The graphs are used to identify the vertical factor used in calculating the total cost of moving into a neighboring cell.</p><p>In the explanations below, two acronyms are used: HF and HRMA. HF stands for horizontal factor, which defines the horizontal difficulty encountered when moving from one cell to the next. HRMA stands for horizontal relative moving angle, which identifies the angle between the horizontal direction from a cell and the moving direction.</p><p><strong>Horizontal factor</strong>types include the following:</p><ul><li><strong>Binary</strong>--Indicates that if the HRMA is less than the cut angle, the HF is set to the value associated with the zero factor; otherwise, it is infinity.</li><li><strong>Forward</strong>--Establishes that only forward movement is allowed. The HRMA must be greater than or equal to 0 and less than 90 degrees (0 &lt;= HRMA &lt; 90). If the HRMA is greater than 0 and less than 45 degrees, the HF for the cell is set to the value associated with the zero factor. If the HRMA is greater than or equal to 45 degrees, the side value modifier value is used. The HF for any HRMA value equal to or greater than 90 degrees is set to infinity.</li><li><strong>Linear</strong>--Specifies that the HF is a linear function of the HRMA.</li><li><strong>Inverse Linear</strong>--Specifies that the HF is an inverse linear function of the HRMA.</li><li><strong>Table</strong>--Identifies that a table file will be used to define the horizontal factor graph used to determine the HFs.</li></ul><p>Modifiers to the horizontal factors include the following:</p><ul><li><strong>Zero factor</strong>--The horizontal factor to be used when the HRMA is zero. This factor positions the y-intercept for any of the horizontal factor functions.</li><li><strong>Cut angle</strong>--Defines the HRMA angle beyond which the HF will be set to infinity.</li><li><strong>Slope</strong>--Establishes the slope of the straight line used with the<strong>Linear</strong>and<strong>Inverse Linear</strong>horizontal factor keywords. The slope is specified as a fraction of rise over run (for example, 45 percent slope is 1/45, which is input as 0.02222).</li><li><strong>Side value</strong>--Establishes the HF when the HRMA is greater than or equal to 45 degrees and less than 90 degrees when the<strong>Forward</strong>horizontal factor keyword is specified.</li><li><strong>Table name</strong>--Identifies the name of the table defining the HF.</li></ul>",
	"@@Path-Distance-Back-Link_Horizontal-Raster_tag0@@": "A raster defining the horizontal direction at each cell.",
	"@@Path-Distance-Back-Link_Horizontal-Raster_tag1@@": "The values on the raster must be integers ranging from 0 to 360, with 0 degrees being north, or toward the top of the screen, and increasing clockwise. Flat areas should be given a value of -1. The values at each location will be used in conjunction with the <strong>Horizontal factor</strong> to determine the horizontal cost incurred when moving from a cell to its neighbors.",
	"@@Path-Distance-Back-Link_Maximum-Distance_tag0@@": "The threshold that the accumulative cost values cannot exceed. If an accumulative cost distance exceeds this value, the output value for the cell location will be NoData. The maximum distance defines the extent for which the accumulative cost distances are calculated. The default distance is to the extent of the output raster.",
	"@@Path-Distance-Back-Link_Multiplier-to-Apply-to-Costs_tag0@@": "A multiplier to apply to the cost values.",
	"@@Path-Distance-Back-Link_Multiplier-to-Apply-to-Costs_tag1@@": "This parameter allows for control of the mode of travel or the magnitude at a source. The greater the multiplier, the greater the cost to move through each cell.",
	"@@Path-Distance-Back-Link_Multiplier-to-Apply-to-Costs_tag2@@": "The values must be greater than zero. The default is 1.",
	"@@Path-Distance-Back-Link_Multiplier-to-Apply-to-Costs_tag3@@": "A numeric (double) value or a field from the <strong>Source Raster</strong> can be used for this parameter.",
	"@@Path-Distance-Back-Link_Source-Raster_tag0@@": "The required input raster of source locations.",
	"@@Path-Distance-Back-Link_Source-Raster_tag1@@": "This is a raster that identifies the cells or locations from which the least accumulated cost distance for every output cell location is calculated.",
	"@@Path-Distance-Back-Link_Source-Raster_tag2@@": "It can be an integer or a floating-point type.",
	"@@Path-Distance-Back-Link_Start-Cost_tag0@@": "The starting cost from which to begin the cost calculations. This parameter allows for the specification of the fixed cost associated with a source. Instead of starting at a cost of 0, the cost algorithm will begin with the value specified.",
	"@@Path-Distance-Back-Link_Start-Cost_tag1@@": "The value must be zero or greater. The default is 0.",
	"@@Path-Distance-Back-Link_Surface-Raster_tag0@@": "A raster defining the elevation values at each cell location.",
	"@@Path-Distance-Back-Link_Surface-Raster_tag1@@": "The values are used to calculate the actual surface distance covered when passing between cells.",
	"@@Path-Distance-Back-Link_Travel-Direction_tag0@@": "Defines the direction of the traveler when applying the source resistance rate and the source starting cost.",
	"@@Path-Distance-Back-Link_Travel-Direction_tag1@@": "<strong>From Source</strong>--The source resistance rate and source starting cost will be applied beginning at the input source and moving out to the non-source cells. This is the default.",
	"@@Path-Distance-Back-Link_Travel-Direction_tag3@@": "<strong>To Source</strong>--The source resistance rate and source starting cost will be applied beginning at each non-source cell and moving back to the input source.",
	"@@Path-Distance-Back-Link_Travel-Direction_tag5@@": "Either specify the <strong>From Source</strong> or <strong>To Source</strong> keyword, which will be applied to all sources, or specify a field in the <strong>Source Raster</strong> that contains the keywords to identify the direction of travel for each source. That field must contain the string ${FROM_SOURCE} or ${TO_SOURCE}.",
	"@@Path-Distance-Back-Link_verticalfactor_tag0@@": "<p>Defines the relationship between the vertical cost factor and the vertical relative moving angle (VRMA).</p><p>There are several factors with modifiers that identify a defined vertical factor graph. Additionally, a table can be used to create a custom graph. The graphs are used to identify the vertical factor used in calculating the total cost of moving into a neighboring cell.</p><p>In the explanations below, two acronyms are used: VF and VRMA. VF stands for vertical factor, which defines the vertical difficulty encountered in moving from one cell to the next. VRMA stands for vertical relative moving angle, which identifies the slope angle between the FROM, or processing, cell and the TO cell.</p><p><strong>Vertical factor</strong>types include the following:</p><ul><li><strong>Binary</strong>--Specifies that if the VRMA is greater than the low-cut angle and less than the high-cut angle, the VF is set to the value associated with the zero factor; otherwise, it is infinity.</li><li><strong>Linear</strong>--Indicates that the VF is a linear function of the VRMA.</li><li><strong>Symmetric Linear</strong>--Specifies that the VF is a linear function of the VRMA in either the negative or positive side of the VRMA, respectively, and the two linear functions are symmetrical with respect to the VF (y) axis.</li><li><strong>Inverse Linear</strong>--Indicates that the VF is an inverse linear function of the VRMA.</li><li><strong>Symmetric Inverse Linear</strong>--Specifies that the VF is an inverse linear function of the VRMA in either the negative or positive side of the VRMA, respectively, and the two linear functions are symmetrical with respect to the VF (y) axis.</li><li><strong>Cos</strong>--Identifies the VF as the cosine-based function of the VRMA.</li><li><strong>Sec</strong>--Identifies the VF as the secant-based function of the VRMA.</li><li><strong>Cos-Sec</strong>--Specifies that the VF is the cosine-based function of the VRMA when the VRMA is negative and the secant-based function of the VRMA when the VRMA is not negative.</li><li><strong>Sec-Cos</strong>--Specifies that the VF is the secant-based function of the VRMA when the VRMA is negative and the cosine-based function of the VRMA when the VRMA is not negative.</li><li><strong>Table</strong>--Identifies that a table file will be used to define the vertical-factor graph that is used to determine the VFs.</li></ul><p>Modifiers to the vertical keywords include the following:</p><ul><li><strong>Zero factor</strong>--Establishes the vertical factor used when the VRMA is zero. This factor positions the y-intercept of the specified function. By definition, the zero factor is not applicable to any of the trigonometric vertical functions (COS, SEC, COS-SEC, or SEC-COS). The y-intercept is defined by these functions.</li><li><strong>Low Cut angle</strong>--Defines the VRMA angle below which the VF will be set to infinity.</li><li><strong>High Cut angle</strong>--Defines the VRMA angle above which the VF will be set to infinity.</li><li><strong>Slope</strong>--Establishes the slope of the straight line used with the<strong>Linear</strong>and<strong>Inverse Linear</strong>vertical-factor keywords. The slope is specified as a fraction of rise over run (for example, 45 percent slope is 1/45, which is input as 0.02222).</li><li><strong>Table name</strong>--Identifies the name of the table defining the VF.</li></ul>",
	"@@Path-Distance-Back-Link_Vertical-Raster_tag0@@": "Defines the relationship between the vertical cost factor and the vertical relative moving angle (VRMA).",
	"@@Path-Distance-Back-Link_Vertical-Raster_tag1@@": "The values are used for calculating the slope used to identify the vertical factor incurred when moving from one cell to another.",
	"@@Plus_Cellsize-Type_tag0@@": "Choose which cell size to use in the output raster. If all the input cell sizes are the same, all the options will yield the same results.",
	"@@Plus_Cellsize-Type_tag1@@": "First Of--Use the first cell size of the input rasters.",
	"@@Plus_Cellsize-Type_tag2@@": "Last Of--Use the last cell size of the input rasters.",
	"@@Plus_Cellsize-Type_tag3@@": "Max Of--Use the largest cell size of all the input rasters. This is the default.",
	"@@Plus_Cellsize-Type_tag4@@": "Mean Of--Use the mean cell size of all the input rasters.",
	"@@Plus_Cellsize-Type_tag5@@": "Min Of--Use the smallest cell size of all the input rasters.",
	"@@Plus_Extent-Type_tag0@@": "Choose which extent should be used in the output raster:",
	"@@Plus_Extent-Type_tag1@@": "First Of--Use the extent of the first input raster to determine the processing extent.",
	"@@Plus_Extent-Type_tag2@@": "Intersection Of--Use the extent of the overlapping pixels to determine the processing extent. This is the default.",
	"@@Plus_Extent-Type_tag3@@": "Last Of--Use the extent of the last input raster to determine the processing extent.",
	"@@Plus_Extent-Type_tag4@@": "Union Of--Use the extent of all the rasters to determine the processing extent.",
	"@@Plus_Raster_tag0@@": "The input whose values will be added to.",
	"@@Plus_Raster_tag1@@": "A constant value can be used as an input for this parameter, provided a raster is specified for the other parameter.",
	"@@Plus_Raster2_tag0@@": "The input whose values will be added to the first input.",
	"@@Plus_Raster2_tag1@@": "A constant value can be used as an input for this parameter, provided a raster is specified for the other parameter.",
	"@@Local_Cellsize-Type_tag0@@": "Choose which cell size to use in the output raster. If all the input cell sizes are the same, all the options will yield the same results.",
	"@@Local_Cellsize-Type_tag1@@": "First Of--Use the first cell size of the input rasters.",
	"@@Local_Cellsize-Type_tag2@@": "Last Of--Use the last cell size of the input rasters.",
	"@@Local_Cellsize-Type_tag3@@": "Max Of--Use the largest cell size of all the input rasters. This is the default.",
	"@@Local_Cellsize-Type_tag4@@": "Mean Of--Use the mean cell size of all the input rasters.",
	"@@Local_Cellsize-Type_tag5@@": "Min Of--Use the smallest cell size of all the input rasters.",
	"@@Local_Extent-Type_tag0@@": "Choose which extent should be used in the output raster:",
	"@@Local_Extent-Type_tag1@@": "First Of--Use the extent of the first input raster to determine the processing extent.",
	"@@Local_Extent-Type_tag2@@": "Intersection Of--Use the extent of the overlapping pixels to determine the processing extent. This is the default.",
	"@@Local_Extent-Type_tag3@@": "Last Of--Use the extent of the last input raster to determine the processing extent.",
	"@@Local_Extent-Type_tag4@@": "Union Of--Use the extent of all the rasters to determine the processing extent.",
	"@@Local_Raster_tag0@@": "The input whose values will be added to.",
	"@@Local_Raster_tag1@@": "A constant value can be used as an input for this parameter, provided a raster is specified for the other parameter.",
	"@@Local_Raster2_tag0@@": "The input whose values will be added to the first input.",
	"@@Local_Raster2_tag1@@": "A constant value can be used as an input for this parameter, provided a raster is specified for the other parameter.",
	"@@Local_False-Raster_tag0@@": "The input whose values will be used as the output pixel values if the condition is false. It can be an integer, a floating-point raster, or a constant value.",
	"@@Local_True-Raster_tag0@@": "The input whose values will be used as the output pixel values if the condition is true. It can be an integer, a floating-point raster, or a constant value.",
	"@@Power_Cellsize-Type_tag0@@": "Choose which cell size to use in the output raster. If all the input cell sizes are the same, all the options will yield the same results.",
	"@@Power_Cellsize-Type_tag1@@": "First Of--Use the first cell size of the input rasters.",
	"@@Power_Cellsize-Type_tag2@@": "Last Of--Use the last cell size of the input rasters.",
	"@@Power_Cellsize-Type_tag3@@": "Max Of--Use the largest cell size of all the input rasters. This is the default.",
	"@@Power_Cellsize-Type_tag4@@": "Mean Of--Use the mean cell size of all the input rasters.",
	"@@Power_Cellsize-Type_tag5@@": "Min Of--Use the smallest cell size of all the input rasters.",
	"@@Power_Extent-Type_tag0@@": "Choose which extent should be used in the output raster:",
	"@@Power_Extent-Type_tag1@@": "First Of--Use the extent of the first input raster to determine the processing extent.",
	"@@Power_Extent-Type_tag2@@": "Intersection Of--Use the extent of the overlapping pixels to determine the processing extent. This is the default.",
	"@@Power_Extent-Type_tag3@@": "Last Of--Use the extent of the last input raster to determine the processing extent.",
	"@@Power_Extent-Type_tag4@@": "Union Of--Use the extent of all the rasters to determine the processing extent.",
	"@@Power_Raster_tag0@@": "The input values to be raised to the power defined by <strong>Raster2</strong>.",
	"@@Power_Raster_tag3@@": "A constant value can be used as an input for this parameter, provided a raster is specified for the other parameter.",
	"@@Power_Raster2_tag0@@": "The input that determines the power to which the values of <strong>Raster</strong> will be raised.",
	"@@Power_Raster2_tag3@@": "A constant value can be used as an input for this parameter, provided a raster is specified for the other parameter.",
	"@@Radar-Calibration_Calibration-Type_tag0@@": "The type of calibration to be performed.",
	"@@Radar-Calibration_Calibration-Type_tag1@@": "Beta-nought--The function returns the radar reflectivity per unit area in slant range. This is the default calibration type.",
	"@@Radar-Calibration_Calibration-Type_tag2@@": "Sigma-nought--The function returns the radar reflectivity per unit area in ground range. Results are 32-bit floating-point values commonly in the range of 0.0 to 1.0. No data clipping is performed if this option is selected.",
	"@@Radar-Calibration_Calibration-Type_tag3@@": "Gamma--The function returns the radar reflectivity per unit area in the plane perpendicular to the direction of measurement.",
	"@@Radar-Calibration_Calibration-Type_tag4@@": "None",
	"@@Radar-Calibration_Raster_tag0@@": "The input raster.",
	"@@RasterInfo_Raster-Info_tag0@@": "Select a raster dataset to use as a template",
	"@@RasterInfo_Raster_tag0@@": "The input raster.",
	"@@Rasterize-Attributes_Attribute-Field-Names_tag0@@": "A list of fields in the <strong>Zonal Attributes Table</strong> , where each field is separated by a comma. Values in each field will be represented by a band in the output raster.",
	"@@Rasterize-Attributes_Background-Value_tag0@@": "The initial pixel value of the output bands in a raster, before being remapped.",
	"@@Rasterize-Attributes_Background-Value_tag1@@": "If a pixel does not fall within a zone, it will remain as the background value.",
	"@@Rasterize-Attributes_Value-Raster_tag0@@": "The required input raster.",
	"@@Rasterize-Attributes_Value-Raster_tag1@@": "The input should be a single-band raster. If a multiband raster is used, only the first band will be used.",
	"@@Rasterize-Attributes_Where-Clause_tag0@@": "An optional additional query applied on the <strong>Zonal Attributes Table</strong>.",
	"@@Rasterize-Attributes_Where-Clause_tag3@@": "If you were using the table above as an example, the query would be ${Variable1 = 'bare earth'}.",
	"@@Rasterize-Attributes_Zonal-Attributes-Table_tag0@@": "The zonal attributes specified as a path to a local feature class, the path to a table, the URL to a feature service layer, or a JSON string.",
	"@@Rasterize-Attributes_Zonal-Attributes-Table_tag1@@": "In JSON, it is described as a collection of mapping from zone IDs to an array of integers. ${{ zoneId:[f1,f2,...,fn], ... } }",
	"@@Rasterize-Attributes_Zone-Field_tag0@@": "The field name containing the zone ID values.",
	"@@Rasterize-Attributes_Zone-Raster_tag0@@": "An optional single-band raster where each pixel contains the zone ID associated with the location. The zone ID is used for looking up rows in the zonal attributes table for zone-specific ingestion.",
	"@@Rasterize-Attributes_Zone-Raster_tag1@@": "Leave this parameter unspecified if you only want to import the attribute.",
	"@@Rasterize-Features_Field_tag0@@": "Select the field to use to identify each feature.",
	"@@Rasterize-Features_Input-Features_tag0@@": "Select the feature class to convert to raster format.",
	"@@Rasterize-Features_Raster_tag0@@": "Select a raster to define the cell size and extent for the feature conversion.",
	"@@Rasterize-Features_Resolve-Overlap-Method_tag0@@": "Determine how to manage features that overlap:",
	"@@Rasterize-Features_Resolve-Overlap-Method_tag1@@": "<strong>First</strong>--The overlapping areas will be assigned a value from the first dataset listed.",
	"@@Rasterize-Features_Resolve-Overlap-Method_tag3@@": "<strong>Last</strong>--The overlapping areas will be assigned a value from the last dataset listed.",
	"@@Rasterize-Features_Resolve-Overlap-Method_tag5@@": "<strong>Smallest</strong>--The overlapping areas will be assigned a value from the smaller of the features.",
	"@@Rasterize-Features_Resolve-Overlap-Method_tag7@@": "<strong>Largest</strong>--The overlapping areas will be assigned a value from the larger of the features.",
	"@@Recast_Overrides_tag0@@": "A table of variable names and user-defined values used to modify a mosaic dataset.",
	"@@Recast_Raster_tag0@@": "The raster product to which the Recast function will be applied.",
	"@@Region-Group_Add-Link_tag0@@": "Specifies whether a link field is added to the table of the output.",
	"@@Region-Group_Add-Link_tag1@@": "<strong>Add Link</strong>--An item ${LINK} item will be added to the table of the output raster.",
	"@@Region-Group_Add-Link_tag3@@": "<strong>No Link</strong>--The attribute table for the output raster will only contain the ${Value} and ${Count} items.",
	"@@Region-Group_Excluded-Value_tag0@@": "Identifies a value such that if a cell location contains the value, no spatial connectivity will be evaluated regardless how the number of neighbors is specified (FOUR or EIGHT).",
	"@@Region-Group_Excluded-Value_tag1@@": "Cells with the excluded value will be treated as NoData and are eliminated from calculations. Cell locations that contain the excluded value will receive 0 on the output raster.",
	"@@Region-Group_Excluded-Value_tag2@@": "The excluded value is similar to the concept of a background value, or having a mask applied. A value must be specified for this parameter if the <strong>${CROSS}</strong> parameter is specified.",
	"@@Region-Group_Number-of-Neighbor-Cells_tag0@@": "The number of neighboring cells to use in evaluating connectivity between cells.",
	"@@Region-Group_Number-of-Neighbor-Cells_tag1@@": "<strong>FOUR</strong>--Defines connectivity between cells of the same value only if the cells are directly to the left, right, above, or below each of the four nearest neighbors. This is the default.",
	"@@Region-Group_Number-of-Neighbor-Cells_tag3@@": "<strong>EIGHT</strong>--Defines connectivity between cells of the same value if they are within the immediate eight-cell neighborhood of each other. This includes to the right, left, above, or diagonal to each other.",
	"@@Region-Group_Zone-Connectivity_tag0@@": "Defines which cell values should be considered when testing for connectivity.",
	"@@Region-Group_Zone-Connectivity_tag1@@": "<strong>WITHIN</strong>--Tests connectivity between input values that are the same within the same zone. This is the default.",
	"@@Region-Group_Zone-Connectivity_tag3@@": "The only cells that can be grouped are cells from the same zone (value) that meet the spatial requirements of connectivity specified by the <strong>Number of neighbors</strong> parameter (four-way or eight-way).",
	"@@Region-Group_Zone-Connectivity_tag6@@": "<strong>CROSS</strong>--Tests connectivity by the spatial requirements specified by the number of neighbors parameter between cells with any values, except for the value identified to be excluded by the excluded value parameter.",
	"@@Region-Group_Zone-Connectivity_tag8@@": "When this option is used, a value for the <strong>Excluded value</strong> parameter must be specified.",
	"@@Region-Group_Zone-Raster_tag0@@": "The required input raster whose unique connected regions will be identified.",
	"@@Region-Group_Zone-Raster_tag1@@": "It must be of integer type.",
	"@@Region-Grow_Fill-Value-Field_tag0@@": "The field in the attribute table that defines the fill value for the group of pixels. In a multiband image, all bands will be assigned this value.",
	"@@Region-Grow_Max-Growth-Radius-Field_tag0@@": "The field in the attribute table that defines the maximum growth radius, in the image's spatial reference units.",
	"@@Region-Grow_Raster_tag0@@": "The raster that you want to perform this function on.",
	"@@Region-Grow_Seed-Points_tag0@@": "A point feature class, serving as the initial seeds for the algorithm. Each seed point corresponds to one entry in the attribute table, which carries the maximum growth radius, similarity threshold, and fill value information.",
	"@@Region-Grow_Similarity-Threshold-Field_tag0@@": "The field in the attribute table that defines the similarity threshold, as Euclidean distance in spectral space.",
	"@@Remap_Allow-Unmatched-Pixel-Values_tag0@@": "Missing values in the reclass table can retain their value or be remapped to NoData.",
	"@@Remap_Allow-Unmatched-Pixel-Values_tag1@@": "Unchecked--Any pixel from the input raster that does not get reclassed in a remap table will retain its value and be written for its location to the output raster. This is the default.",
	"@@Remap_Allow-Unmatched-Pixel-Values_tag2@@": "Checked--Any pixel from the input raster that does not get reclassed in a remap table will have its value remapped to NoData for its location to the output raster.",
	"@@Remap_Input-Field_tag0@@": "Choose the field that specifies the input pixel value that will be remapped.",
	"@@Remap_Input-Field_tag1@@": "If your table has a value range, this will be the minimum value field, and the <strong>Input Max Field</strong> parameter needs to be specified as well.",
	"@@Remap_Input-Max-Field_tag0@@": "Choose the maximum value field if your table specifies a value range.",
	"@@Remap_List_tag0@@": "Specify the map values and specify the minimum and maximum value range and the new remap values. In addition, the value range can be set as NoData pixels.",
	"@@Remap_Output-Field_tag0@@": "Choose the field that will be used as the output remapped value.",
	"@@Remap_Raster_tag0@@": "The input raster.",
	"@@Remap_Remap-Definition-Type_tag0@@": "Choose the option you want to use to set the remap values:",
	"@@Remap_Remap-Definition-Type_tag1@@": "List--Specify a range of pixel values to map to an output pixel value",
	"@@Remap_Remap-Table-Type_tag0@@": "Choose the type of table you'll use to remap your input raster:",
	"@@Remap_Remap-Table-Type_tag1@@": "Simple--Uses the <strong>Remap Table</strong> input to remap the <strong>Input Field</strong> pixel values to the corresponding value in the <strong>Output Field</strong> parameter. This method caches the remap table so that it can perform faster.",
	"@@Remap_Remap-Table-Type_tag8@@": "Dynamic--This method does not cache the remap table and will make a query each time a request is made (pan, zoom, or refresh). If the table changes, the next request can dynamically remap the values accordingly.",
	"@@Remap_Remap-Table-Type_tag9@@": "Reassignment--A specific table used for the reclassification process, where each row in the table will only remap based on each feature boundary.",
	"@@Remap_Remap-Table_tag0@@": "Browse to the table that sets your remap values.",
	"@@Reproject_Raster_tag0@@": "The raster dataset to be reprojected or resampled.",
	"@@Reproject_Spatial-Reference_tag0@@": "The coordinate system used to reproject the data.",
	"@@Reproject_X-Cellsize_tag0@@": "The x-dimension to which the data should be resampled. This is optional. If the value is 0 or less, the output envelope (extent and cell sizes) is calculated from the input raster.",
	"@@Reproject_X-Registration-Point_tag0@@": "The x-coordinate used to define the upper left corner of the dataset. This coordinate must be defined in the units of the new spatial reference. If both the <strong>X Cellsize</strong> and <strong>Y Cellsize</strong> parameters are greater than 0, they are used along with the <strong>X Registration Point</strong> and <strong>Y Registration Point</strong> parameters to define the output envelope.",
	"@@Reproject_Y-Cellsize_tag0@@": "The y-dimension to which the data should be resampled. This is optional. If the value is 0 or less, the output envelope (extent and cell sizes) is calculated from the input raster.",
	"@@Reproject_Y-Registration-Point_tag0@@": "The y-coordinate used to define the upper left corner of the dataset. This coordinate must be defined in the units of the new spatial reference. If both the <strong>X Cellsize</strong> and <strong>Y Cellsize</strong> parameters are greater than 0, they are used along with the <strong>X Registration Point</strong> and <strong>Y Registration Point</strong> parameters to define the output envelope.",
	"@@Resample_Input-Cellsize_tag0@@": "The pixel cell size of the input raster.",
	"@@Resample_Output-Cellsize_tag0@@": "The pixel cell size of the output raster. The cell size can be changed, but the extent of the raster dataset will remain the same. Resampling from a user-defined cell size can be much slower than the system default, since the system default resampling processes the minimum amount of data from the closest possible resolution.",
	"@@Resample_Raster_tag0@@": "The input raster to be resampled.",
	"@@Resample_Resampling-Type_tag0@@": "<strong>Nearest Neighbor</strong>--Calculates the output pixel value using the nearest input pixel. NoData pixels will remain unchanged in the output raster dataset. This the default.",
	"@@Resample_Resampling-Type_tag2@@": "<strong>Bilinear Interpolation</strong>--Calculates the pixel value using the distance-weighted value of the four nearest pixels. This method is computationally efficient to process.",
	"@@Resample_Resampling-Type_tag4@@": "<strong>Cubic Convolution</strong>--Determines the new value of a pixel based on fitting a smooth curve through the 16 nearest input pixel centers.",
	"@@Resample_Resampling-Type_tag6@@": "<strong>Majority</strong>--Calculates pixel value using the majority pixel value in the 16 nearest pixels. NoData pixels will remain unchanged in the output raster dataset.",
	"@@Resample_Resampling-Type_tag8@@": "<strong>Bilinear Interpolation Plus</strong>--Uses <strong>Bilinear Interpolation</strong>, except the pixels along the edges are defined as NoData and are not replicated or considered in the calculation. Use <strong>Bilinear Interpolation Plus</strong> for tiled data because the edges will match better.",
	"@@Resample_Resampling-Type_tag14@@": "<strong>Gauss Blur</strong>--Applies a Gaussian convolution to the source raster and calculates pixel value using the distance-weighted value of four nearest pixels from the blurred raster. It is appropriate for removing noise in resampled data and for down-sampling to a larger pixel size.",
	"@@Resample_Resampling-Type_tag16@@": "<strong>Gauss Blur Plus</strong>--Uses the same method as <strong>Gauss Blur</strong> , except the pixels along the edges are defined as NoData and are not replicated or considered in the calculation. Use <strong>Gauss Blur Plus</strong> for tiled data because the edges will match better.",
	"@@Resample_Resampling-Type_tag22@@": "<strong>Average</strong>--Calculates pixel values using the average value of all overlapping pixels, for each target pixel.",
	"@@Resample_Resampling-Type_tag24@@": "<strong>Minimum</strong>--Calculates pixel value using the minimum value of all overlapping pixels. NoData pixels will remain unchanged in the output raster dataset.",
	"@@Resample_Resampling-Type_tag26@@": "<strong>Maximum</strong>--Appropriate for continuous data, it produces a smoother output image than the Nearest Neighbor resampling method.",
	"@@Resample_Resampling-Type_tag28@@": "<strong>Vector Average</strong>--Calculates vector average of magnitude-direction using all involved pixels. This method is only applicable for two band rasters that represent magnitude and direction. It first converts magnitude-direction into U-V, and then it takes the arithmetic average across all involved pixels to get the U-V of the target pixel and converts it back to magnitude-direction.",
	"@@Round-Down_Cellsize-Type_tag0@@": "Choose which cell size to use in the output raster. If all the input cell sizes are the same, all the options will yield the same results.",
	"@@Round-Down_Cellsize-Type_tag1@@": "First Of--Use the first cell size of the input rasters.",
	"@@Round-Down_Cellsize-Type_tag2@@": "Last Of--Use the last cell size of the input rasters.",
	"@@Round-Down_Cellsize-Type_tag3@@": "Max Of--Use the largest cell size of all the input rasters. This is the default.",
	"@@Round-Down_Cellsize-Type_tag4@@": "Mean Of--Use the mean cell size of all the input rasters.",
	"@@Round-Down_Cellsize-Type_tag5@@": "Min Of--Use the smallest cell size of all the input rasters.",
	"@@Round-Down_Extent-Type_tag0@@": "Choose which extent should be used in the output raster:",
	"@@Round-Down_Extent-Type_tag1@@": "First Of--Use the extent of the first input raster to determine the processing extent.",
	"@@Round-Down_Extent-Type_tag2@@": "Intersection Of--Use the extent of the overlapping pixels to determine the processing extent. This is the default.",
	"@@Round-Down_Extent-Type_tag3@@": "Last Of--Use the extent of the last input raster to determine the processing extent.",
	"@@Round-Down_Extent-Type_tag4@@": "Union Of--Use the extent of all the rasters to determine the processing extent.",
	"@@Round-Down_Raster_tag0@@": "The input values to be rounded down.",
	"@@Round-Up_Cellsize-Type_tag0@@": "Choose which cell size to use in the output raster. If all the input cell sizes are the same, all the options will yield the same results.",
	"@@Round-Up_Cellsize-Type_tag1@@": "First Of--Use the first cell size of the input rasters.",
	"@@Round-Up_Cellsize-Type_tag2@@": "Last Of--Use the last cell size of the input rasters.",
	"@@Round-Up_Cellsize-Type_tag3@@": "Max Of--Use the largest cell size of all the input rasters. This is the default.",
	"@@Round-Up_Cellsize-Type_tag4@@": "Mean Of--Use the mean cell size of all the input rasters.",
	"@@Round-Up_Cellsize-Type_tag5@@": "Min Of--Use the smallest cell size of all the input rasters.",
	"@@Round-Up_Extent-Type_tag0@@": "Choose which extent should be used in the output raster:",
	"@@Round-Up_Extent-Type_tag1@@": "First Of--Use the extent of the first input raster to determine the processing extent.",
	"@@Round-Up_Extent-Type_tag2@@": "Intersection Of--Use the extent of the overlapping pixels to determine the processing extent. This is the default.",
	"@@Round-Up_Extent-Type_tag3@@": "Last Of--Use the extent of the last input raster to determine the processing extent.",
	"@@Round-Up_Extent-Type_tag4@@": "Union Of--Use the extent of all the rasters to determine the processing extent.",
	"@@Round-Up_Raster_tag0@@": "The input values to be rounded up.",
	"@@Segment-Mean-Shift_Minimum-Segment-Size-in-Pixels_tag0@@": "The minimum segment size, measured in pixels. This value is related to your minimum mapping unit, and will filter out smaller blocks of pixels. All segments that are smaller than the specified value will merge the smaller segments with their best fitting neighbor segment.",
	"@@Segment-Mean-Shift_Raster_tag0@@": "The input raster to be segmented.",
	"@@Segment-Mean-Shift_Segment-boundaries-only_tag0@@": "The segment boundaries draw as a black contour line around each segment. This is helpful so you can distinguish adjacent segments that have similar colors.",
	"@@Segment-Mean-Shift_Segment-boundaries-only_tag1@@": "Unchecked--The segment boundaries are not displayed. This is the default.",
	"@@Segment-Mean-Shift_Segment-boundaries-only_tag2@@": "Checked--The segment boundaries are displayed with black contour lines around each segment.",
	"@@Segment-Mean-Shift_Spatial-Detail_tag0@@": "The relative importance of separating objects based on spatial characteristics.",
	"@@Segment-Mean-Shift_Spatial-Detail_tag1@@": "Valid integer values range from 1 to 20. Smaller values result in broad classes and more smoothing. A higher value is appropriate for discriminating between features that are spatially small and clustered together. For example, in an urban scene, you could classify general impervious surface features using a smaller spatial detail value, or you could classify buildings and roads as separate classes using a higher spatial detail value.",
	"@@Segment-Mean-Shift_Spectral-Detail_tag0@@": "The relative importance of separating objects based on color characteristics.",
	"@@Segment-Mean-Shift_Spectral-Detail_tag1@@": "Valid floating-point values range from 1.0 to 20.0. Smaller values result in broad classes and more smoothing. A higher value is appropriate when you want to discriminate between features having somewhat similar spectral characteristics. For example, using a higher spectral detail value in a forested scene allows you to better distinguish the different tree species.",
	"@@Segment-Mean-Shift_maximumsegmentsizeinpixels_tag0@@": "<p>The maximum size of a segment. Segments that are larger than the specified size will be divided. Use this parameter to prevent artifacts in the output layer resulting from large segments. The default is -1.</p>",
	"@@Sentinel-1-Radiometric-Calibration_Calibration-Type_tag0@@": "Select one of four calibration types:",
	"@@Sentinel-1-Radiometric-Calibration_Calibration-Type_tag1@@": "<strong>Beta nought</strong>--produces an output containing the radar brightness coefficient.",
	"@@Sentinel-1-Radiometric-Calibration_Calibration-Type_tag3@@": "<strong>Sigma nought</strong>--the backscatter returned to the antenna from a unit area on the ground, related to ground range.",
	"@@Sentinel-1-Radiometric-Calibration_Calibration-Type_tag5@@": "<strong>Gamma</strong>--measurement of emitted and returned energy useful for determining antenna patterns.",
	"@@Sentinel-1-Radiometric-Calibration_Calibration-Type_tag7@@": "<strong>None</strong>--do not apply a correction. This is the default.",
	"@@Sentinel-1-Radiometric-Calibration_Raster_tag0@@": "The Sentinel-1 Level-1 GRD or SLC input raster you want to process.",
	"@@Sentinel-1-Radiometric-Calibration_Raster_tag1@@": "The function will use the LUT file either to apply the thermal correction or to remove the correction, depending on the contents of the LUT.",
	"@@Sentinel-1-Thermal-Noise-Removal_Raster_tag0@@": "The Sentinel-1 input raster you want to process.",
	"@@Sentinel-1-Thermal-Noise-Removal_Raster_tag1@@": "The function will use the LUT file to either apply the thermal correction or remove the correction depending on the contents of the LUT.",
	"@@Set-Null_Cellsize-Type_tag0@@": "Choose which cell size to use in the output raster. If all the input cell sizes are the same, all the options will yield the same results.",
	"@@Set-Null_Cellsize-Type_tag1@@": "First Of--Use the first cell size of the input rasters.",
	"@@Set-Null_Cellsize-Type_tag2@@": "Last Of--Use the last cell size of the input rasters.",
	"@@Set-Null_Cellsize-Type_tag3@@": "Max Of--Use the largest cell size of all the input rasters. This is the default.",
	"@@Set-Null_Cellsize-Type_tag4@@": "Mean Of--Use the mean cell size of all the input rasters.",
	"@@Set-Null_Cellsize-Type_tag5@@": "Min Of--Use the smallest cell size of all the input rasters.",
	"@@Set-Null_Extent-Type_tag0@@": "Choose which extent should be used in the output raster:",
	"@@Set-Null_Extent-Type_tag1@@": "First Of--Use the extent of the first input raster to determine the processing extent.",
	"@@Set-Null_Extent-Type_tag2@@": "Intersection Of--Use the extent of the overlapping pixels to determine the processing extent. This is the default.",
	"@@Set-Null_Extent-Type_tag3@@": "Last Of--Use the extent of the last input raster to determine the processing extent.",
	"@@Set-Null_Extent-Type_tag4@@": "Union Of--Use the extent of all the rasters to determine the processing extent.",
	"@@Set-Null_False-Raster_tag0@@": "The input whose values will be used as the output pixel values if the condition is false. It can be an integer, a floating-point raster, or a constant value.",
	"@@Set-Null_Raster_tag0@@": "The input raster that represents the Boolean result of a logical math raster function. The values will be either 1 (for true) or 0 (for false). It can be an integer or a floating-point raster.",
	"@@Shaded-Relief_Altitude_tag0@@": "Altitude is the sun's angle of elevation above the horizon and ranges from 0 to 90 degrees. A value of 0 degrees indicates that the sun is on the horizon, that is, on the same horizontal plane as the frame of reference. A value of 90 degrees indicates that the sun is directly overhead. The default is 45 degrees above the horizon.",
	"@@Shaded-Relief_Azimuth_tag0@@": "Azimuth is the sun's relative position along the horizon (in degrees). This position is indicated by the angle of the sun measured clockwise from due north. An azimuth of 0 degrees indicates north, east is 90 degrees, south is 180 degrees, and west is 270 degrees.",
	"@@Shaded-Relief_Color-Scheme-Type_tag0@@": "Specify whether a color ramp or a color map will be used to display the shaded relief.",
	"@@Shaded-Relief_Color-Scheme-Type_tag1@@": "<strong>Color Ramp</strong>--When you choose <strong>Color Ramp</strong>, you will be prompted to select an appropriate color ramp.",
	"@@Shaded-Relief_Color-Scheme-Type_tag5@@": "<strong>Colormap</strong>--When you choose <strong>Colormap</strong> , you will be prompted to specify the color map file to use.",
	"@@Shaded-Relief_Disable-default-edge-pixel-interpolation_tag0@@": "Specify whether the default edge pixel interpolation with be disabled.",
	"@@Shaded-Relief_Disable-default-edge-pixel-interpolation_tag1@@": "Unchecked--Bilinear resampling will be applied uniformly to resample the shaded relief. This is the default.",
	"@@Shaded-Relief_Disable-default-edge-pixel-interpolation_tag2@@": "Checked--Bilinear resampling will be used within the shaded relief, except along the edges of the rasters or next to pixels of NoData. These pixels will be populated with NoData, since it will reduce any sharp edge effects that may occur.",
	"@@Shaded-Relief_Disable-default-edge-pixel-interpolation_tag3@@": "Using this option will avoid any resampling artifacts that may occur along the edges of a raster. The output pixels along the edge of a raster or beside pixels without a value will be populated with NoData; therefore, it is recommended that this option be used only when there are other rasters with overlapping pixels available. When overlapping pixels are available, these areas of NoData will display the overlapping pixel values instead of being blank.",
	"@@Shaded-Relief_Raster_tag0@@": "The input elevation raster.",
	"@@Shaded-Relief_Scaling_tag0@@": "The shaded result is scaled dynamically by adjusting the z-factor using one of two options:",
	"@@Shaded-Relief_Scaling_tag1@@": "<strong>None</strong>--No scaling is applied. This is ideal for a single raster dataset covering a local area. This is not recommended for worldwide datasets with large variations in elevation or multiscale maps, as it will produce terrain relief with little variation at small scales.",
	"@@Shaded-Relief_Scaling_tag3@@": "<strong>Adjusted</strong>--A nonlinear adjustment is applied using the default <strong>Pixel Size Power</strong> and <strong>Pixel Size Factor</strong> values, which accommodate a wide variety of altitude changes (scale) as the viewer zooms in and out. The <strong>Adjusted</strong> option is recommended when using a worldwide dataset.",
	"@@Shaded-Relief_Z-Factor_tag0@@": "The z-factor is a scaling factor used to convert the elevation values for two purposes:",
	"@@Shaded-Relief_Z-Factor_tag1@@": "To convert the elevation units (such as meters or feet) to the horizontal coordinate units of the dataset, which may be feet, meters, or degrees",
	"@@Shaded-Relief_Z-Factor_tag2@@": "To add vertical exaggeration for visual effect",
	"@@Shaded-Relief_Z-Factor_tag3@@": "The shaded result is scaled dynamically by adjusting the z-factor using one of two options:",
	"@@Shaded-Relief_Z-Factor_tag4@@": "<strong>None</strong>--No scaling is applied. This is ideal for a single raster dataset covering a local area. This is not recommended for worldwide datasets with large variations in elevation or multiscale maps, as it will produce terrain relief with little variation at small scales.",
	"@@Shaded-Relief_Z-Factor_tag6@@": "<strong>Adjusted</strong>--A nonlinear adjustment is applied using the default <strong>Pixel Size Power</strong> and <strong>Pixel Size Factor</strong> values, which accommodate a wide variety of altitude changes (scale) as the viewer zooms in and out. The <strong>Adjusted</strong> option is recommended when using a worldwide dataset.",
	"@@Shaded-Relief_hillshadetype_tag0@@": "Controls the illumination source for the hillshade.",
	"@@Shaded-Relief_hillshadetype_tag1@@": "<strong>Traditional</strong>--Calculates hillshade from a single illumination direction. You can set the <strong>Azimuth</strong> and <strong>Altitude</strong> options to control the location of the light source. This is the default.",
	"@@Shaded-Relief_hillshadetype_tag2@@": "<strong>Multidirectional</strong>--Combines light from multiple sources to represent an enhanced visualization of the terrain.",
	"@@Shaded-Relief_PSPower_tag0@@": "<strong>Pixel Size Power</strong> accounts for the altitude changes (or scale) as the viewer zooms in and out on the map display. It is the exponent applied to the pixel size term in the equation that controls the rate at which the <strong>Z Factor</strong> changes to avoid significant loss of relief.",
	"@@Shaded-Relief_PSPower_tag1@@": "This parameter is only valid when the <strong>Scaling</strong> type is <strong>Adjusted</strong>. The default value is 0.664.",
	"@@Shaded-Relief_PSZFactor_tag0@@": "<strong>Pixel Size Factor</strong> accounts for changes in scale as the viewer zooms in and out on the map display. It controls the rate at which the <strong>Z Factor</strong> changes.",
	"@@Shaded-Relief_PSZFactor_tag1@@": "This parameter is only valid when the <strong>Scaling</strong> type is <strong>Adjusted</strong>. The default value is 0.024.",
	"@@Sin_Cellsize-Type_tag0@@": "Choose which cell size to use in the output raster. If all the input cell sizes are the same, all the options will yield the same results.",
	"@@Sin_Cellsize-Type_tag1@@": "First Of--Use the first cell size of the input rasters.",
	"@@Sin_Cellsize-Type_tag2@@": "Last Of--Use the last cell size of the input rasters.",
	"@@Sin_Cellsize-Type_tag3@@": "Max Of--Use the largest cell size of all the input rasters. This is the default.",
	"@@Sin_Cellsize-Type_tag4@@": "Mean Of--Use the mean cell size of all the input rasters.",
	"@@Sin_Cellsize-Type_tag5@@": "Min Of--Use the smallest cell size of all the input rasters.",
	"@@Sin_Extent-Type_tag0@@": "Choose which extent should be used in the output raster:",
	"@@Sin_Extent-Type_tag1@@": "First Of--Use the extent of the first input raster to determine the processing extent.",
	"@@Sin_Extent-Type_tag2@@": "Intersection Of--Use the extent of the overlapping pixels to determine the processing extent. This is the default.",
	"@@Sin_Extent-Type_tag3@@": "Last Of--Use the extent of the last input raster to determine the processing extent.",
	"@@Sin_Extent-Type_tag4@@": "Union Of--Use the extent of all the rasters to determine the processing extent.",
	"@@Sin_Raster_tag0@@": "The input for which to calculate the sine values.",
	"@@SinH_Cellsize-Type_tag0@@": "Choose which cell size to use in the output raster. If all the input cell sizes are the same, all the options will yield the same results.",
	"@@SinH_Cellsize-Type_tag1@@": "First Of--Use the first cell size of the input rasters.",
	"@@SinH_Cellsize-Type_tag2@@": "Last Of--Use the last cell size of the input rasters.",
	"@@SinH_Cellsize-Type_tag3@@": "Max Of--Use the largest cell size of all the input rasters. This is the default.",
	"@@SinH_Cellsize-Type_tag4@@": "Mean Of--Use the mean cell size of all the input rasters.",
	"@@SinH_Cellsize-Type_tag5@@": "Min Of--Use the smallest cell size of all the input rasters.",
	"@@SinH_Extent-Type_tag0@@": "Choose which extent should be used in the output raster:",
	"@@SinH_Extent-Type_tag1@@": "First Of--Use the extent of the first input raster to determine the processing extent.",
	"@@SinH_Extent-Type_tag2@@": "Intersection Of--Use the extent of the overlapping pixels to determine the processing extent. This is the default.",
	"@@SinH_Extent-Type_tag3@@": "Last Of--Use the extent of the last input raster to determine the processing extent.",
	"@@SinH_Extent-Type_tag4@@": "Union Of--Use the extent of all the rasters to determine the processing extent.",
	"@@SinH_Raster_tag0@@": "The input for which to calculate the hyperbolic sine values.",
	"@@Sink_Flow-Direction-Raster_tag0@@": "The input raster that shows the direction of flow out of each cell.",
	"@@Sink_Flow-Direction-Raster_tag1@@": "The flow direction raster can be created by running the <strong>Flow Direction</strong> function.",
	"@@Slope_DEM_tag0@@": "The input elevation raster.",
	"@@Slope_Disable-default-edge-pixel-interpolation_tag0@@": "Using this option will avoid any resampling artifacts that may occur along the edges of a raster. The output pixels along the edge of a raster or beside pixels without a value will be populated with NoData; therefore, it is recommended that this option be used only when there are other rasters with overlapping pixels available. When overlapping pixels are available, these areas of NoData will display the overlapping pixel values instead of being blank.",
	"@@Slope_Disable-default-edge-pixel-interpolation_tag1@@": "Unchecked--Bilinear resampling will be applied uniformly to resample your slope. This is the default.",
	"@@Slope_Disable-default-edge-pixel-interpolation_tag2@@": "Checked--Bilinear resampling will be used within the slope, except along the edges of the rasters or beside pixels of NoData. These pixels will be populated with NoData, since it will reduce any sharp edge effects that may occur.",
	"@@Slope_Scaling_tag0@@": "The inclination of slope can be output as either a value in degrees, or percent rise. There are three options for the <strong>Scaling</strong>:",
	"@@Slope_Scaling_tag3@@": "<strong>Degree</strong>--The inclination of slope is calculated in degrees. The values range from 0 to 90.",
	"@@Slope_Scaling_tag5@@": "<strong>Percent_Rise</strong>--The inclination of slope is calculated as percentage values. The values range from 0 to infinity. A flat surface is 0 percent rise, whereas a 45-degree surface is 100 percent rise. As the surface becomes more vertical, the percent rise becomes increasingly larger.",
	"@@Slope_Scaling_tag7@@": "<strong>Scaled</strong>--The inclination of slope is calculated the same as DEGREE, but the z-factor is adjusted for scale. It uses the <strong>Pixel Size Power</strong> and <strong>Pixel Size Factor</strong> values, which account for the resolution changes (scale) as the viewer zooms in and out. This is recommended when using worldwide datasets--particularly when using slope as a surface for visualization.",
	"@@Slope_Scaling_tag13@@": "The z-factor is adjusted using the following equation:",
	"@@Slope_Scaling_tag14@@": "Adjusted Z Factor = (Z Factor) + (Pixel Size)",
	"@@Slope_Scaling_tag15@@": " (Pixel Size Factor)",
	"@@Slope_Scaling_tag16@@": "Pixel Size Power",
	"@@Slope_Z-Factor_tag0@@": "The <strong>Z Factor</strong> is a scaling factor used to convert the elevation values for two purposes:",
	"@@Slope_Z-Factor_tag3@@": "To convert the elevation units (such as meters or feet) to the horizontal coordinate units of the dataset, which may be feet, meters, or degrees",
	"@@Slope_Z-Factor_tag4@@": "To add vertical exaggeration for visual effect",
	"@@Slope_PSPower_tag0@@": "<strong>Pixel Size Power</strong> accounts for the altitude changes (or scale) as the viewer zooms in and out on the map display. It is the exponent applied to the pixel size term in the equation that controls the rate at which the <strong>Z Factor</strong> changes to avoid significant loss of relief.",
	"@@Slope_PSPower_tag1@@": "This parameter is only valid when the <strong>Scaling</strong> type is <strong>Scaled</strong>. The default value is 0.664.",
	"@@Slope_PSZFactor_tag0@@": "<strong>Pixel Size Factor</strong> accounts for changes in scale as the viewer zooms in and out on the map display. It controls the rate at which the <strong>Z Factor</strong> changes.",
	"@@Slope_PSZFactor_tag1@@": "This parameter is only valid when the <strong>Scaling</strong> type is <strong>Scaled</strong>. The default value is 0.024.",
	"@@Snap-Pour-Point_Flow-Accumulation-Raster_tag0@@": "The input flow accumulation raster layer.",
	"@@Snap-Pour-Point_Flow-Accumulation-Raster_tag1@@": "This can be created with the <strong>Flow Accumulation</strong> function.",
	"@@Snap-Pour-Point_Pour-Point-Field_tag0@@": "Field used to assign values to the pour point locations.",
	"@@Snap-Pour-Point_Pour-Point-Raster_tag0@@": "The input pour point locations that are to be snapped.",
	"@@Snap-Pour-Point_Pour-Point-Raster_tag1@@": "For an input raster layer, all cells that are not NoData (that is, have a value) will be considered pour points and will be snapped.",
	"@@Snap-Pour-Point_Snap-Distance_tag0@@": "The maximum distance, in map units, to search for a cell of higher accumulated flow.",
	"@@Speckle_Additive-Noise-Mean_tag0@@": "Specifies the mean value of additive noise. A larger noise mean value will produce less smoothing, while a smaller value results in more smoothing.",
	"@@Speckle_Additive-Noise-Mean_tag1@@": "This parameter is only valid when the <strong>Filter Type</strong> is <strong>Lee Filter</strong> and the <strong>Noise Model</strong> is <strong>Additive Noise</strong> or <strong>Additive and Multiplicative Noise</strong>. The default value is 0.",
	"@@Speckle_Damping-Factor_tag0@@": "Specifies the extent of exponential damping effect on filtering. A larger damping value preserves edges better but smooths less, while a smaller value produces more smoothing. A value of 0 results in the same output as a low-pass filter.",
	"@@Speckle_Damping-Factor_tag1@@": "This parameter is only valid when the <strong>Filter Type</strong> is <strong>Enhanced Lee Filter</strong> or <strong>Frost Filter</strong>. The default value is 1.",
	"@@Speckle_Filter-Size_tag0@@": "Specifies the size of the pixel window used to filter noise:",
	"@@Speckle_Filter-Size_tag1@@": "3x3",
	"@@Speckle_Filter-Size_tag2@@": "5x5",
	"@@Speckle_Filter-Size_tag3@@": "7x7",
	"@@Speckle_Filter-Size_tag4@@": "9x9",
	"@@Speckle_Filter-Size_tag5@@": "11x11",
	"@@Speckle_Filter-Type_tag0@@": "Specifies the filter type to be used in the smoothing algorithm to remove speckle noise:",
	"@@Speckle_Filter-Type_tag1@@": "<strong>Lee Filter</strong>--Reduces the speckle noise by applying a spatial filter to each pixel in an image, which filters the data based on local statistics calculated within a square window. This filter is useful when you want to smooth speckled data that has an additive or multiplicative component. This is the default.",
	"@@Speckle_Filter-Type_tag3@@": "<strong>Enhanced Lee Filter</strong>--An adapted version of the Lee filter that includes <strong>Damping Factor</strong> and <strong>Number of Looks</strong>. This filter is useful when you want to reduce speckle while preserving texture information.",
	"@@Speckle_Filter-Type_tag9@@": "<strong>Frost Filter</strong>--Reduces speckle noise with an exponentially damped circularly symmetric filter that uses local statistics within individual filter windows. This filter is useful when you want to reduce speckle while preserving edges in radar images.",
	"@@Speckle_Filter-Type_tag11@@": "<strong>Kuan Filter</strong>--Similar to the Lee filter, this filter applies a spatial filter to each pixel in an image and filters the data based on local statistics calculated within a square window. This filter is useful when you want to reduce speckle while preserving edges in radar images.",
	"@@Speckle_Multiplicative-Noise-Mean_tag0@@": "Specifies the mean value of multiplicative noise. A larger noise mean value will produce less smoothing, while a smaller value results in more smoothing.",
	"@@Speckle_Multiplicative-Noise-Mean_tag1@@": "This parameter is only valid when the <strong>Filter Type</strong> is <strong>Lee Filter</strong> and the <strong>Noise Model</strong> is <strong>Additive Noise</strong> or <strong>Additive and Multiplicative Noise</strong>. The default value is 1.",
	"@@Speckle_Noise-Model_tag0@@": "Specifies the type of noise that is reducing the quality of the radar image:",
	"@@Speckle_Noise-Model_tag1@@": "<strong>Multiplicative Noise</strong>--Random signal noise that is multiplied into the relevant signal during capture or transmission",
	"@@Speckle_Noise-Model_tag3@@": "<strong>Additive Noise</strong>--Random signal noise that is added into the relevant signal during capture or transmission",
	"@@Speckle_Noise-Model_tag5@@": "<strong>Additive and Multiplicative Noise</strong>--Both noise models",
	"@@Speckle_Noise-Variance_tag0@@": "Specifies the noise variance of the radar image.",
	"@@Speckle_Noise-Variance_tag1@@": "This parameter is only valid when the <strong>Filter Type</strong> is <strong>Lee Filter</strong> and the <strong>Noise Model</strong> is <strong>Additive Noise</strong> or <strong>Additive and Multiplicative Noise</strong>. The default value is 0.25.",
	"@@Speckle_Number-of-Looks_tag0@@": "Specifies the number of looks of the image, which controls image smoothing and estimates noise variance. A smaller value results in more smoothing, while a larger value retains more image features.",
	"@@Speckle_Number-of-Looks_tag1@@": "This parameter is only valid when the <strong>Filter Type</strong> is <strong>Lee Filter</strong> and the <strong>Noise Model</strong> is <strong>Multiplicative Noise</strong> , or when the <strong>Filter Type</strong> is <strong>Kuan Filter</strong>. The default value is 1.",
	"@@Speckle_Raster_tag0@@": "The input raster.",
	"@@Spectral-Conversion_Conversion-Matrix_tag0@@": "The matrix used to convert the input raster.",
	"@@Spectral-Conversion_Conversion-Matrix_tag1@@": "The equation used to perform this conversion is:",
	"@@Spectral-Conversion_Conversion-Matrix_tag2@@": "Output Band_R = Weight_P * Band_C",
	"@@Spectral-Conversion_Conversion-Matrix_tag3@@": "where:",
	"@@Spectral-Conversion_Conversion-Matrix_tag4@@": "Band_R is an output band, where R is a number from 1 to the number of output bands.",
	"@@Spectral-Conversion_Conversion-Matrix_tag5@@": "Weight_P is a comma-delimited list of weights, 1 for each input band. The sum of the weights for each band should equal 1.",
	"@@Spectral-Conversion_Conversion-Matrix_tag6@@": "Band_C is the input image, where C is a number from 1 to the number of bands of the input image.",
	"@@Spectral-Conversion_Raster_tag0@@": "The input raster.",
	"@@Spectral-Conversion_Raster_tag1@@": "This can be a raster dataset, a mosaic dataset or an image service.",
	"@@Spectral-Conversion_Size_tag0@@": "The number of rows and columns in the <strong>Conversion Matrix</strong>.",
	"@@Square_Cellsize-Type_tag0@@": "Choose which cell size to use in the output raster. If all the input cell sizes are the same, all the options will yield the same results.",
	"@@Square_Cellsize-Type_tag1@@": "First Of--Use the first cell size of the input rasters.",
	"@@Square_Cellsize-Type_tag2@@": "Last Of--Use the last cell size of the input rasters.",
	"@@Square_Cellsize-Type_tag3@@": "Max Of--Use the largest cell size of all the input rasters. This is the default.",
	"@@Square_Cellsize-Type_tag4@@": "Mean Of--Use the mean cell size of all the input rasters.",
	"@@Square_Cellsize-Type_tag5@@": "Min Of--Use the smallest cell size of all the input rasters.",
	"@@Square_Extent-Type_tag0@@": "Choose which extent should be used in the output raster:",
	"@@Square_Extent-Type_tag1@@": "First Of--Use the extent of the first input raster to determine the processing extent.",
	"@@Square_Extent-Type_tag2@@": "Intersection Of--Use the extent of the overlapping pixels to determine the processing extent. This is the default.",
	"@@Square_Extent-Type_tag3@@": "Last Of--Use the extent of the last input raster to determine the processing extent.",
	"@@Square_Extent-Type_tag4@@": "Union Of--Use the extent of all the rasters to determine the processing extent.",
	"@@Square_Raster_tag0@@": "The input values to be squared.",
	"@@Square-Root_Cellsize-Type_tag0@@": "Choose which cell size to use in the output raster. If all the input cell sizes are the same, all the options will yield the same results.",
	"@@Square-Root_Cellsize-Type_tag1@@": "First Of--Use the first cell size of the input rasters.",
	"@@Square-Root_Cellsize-Type_tag2@@": "Last Of--Use the last cell size of the input rasters.",
	"@@Square-Root_Cellsize-Type_tag3@@": "Max Of--Use the largest cell size of all the input rasters. This is the default.",
	"@@Square-Root_Cellsize-Type_tag4@@": "Mean Of--Use the mean cell size of all the input rasters.",
	"@@Square-Root_Cellsize-Type_tag5@@": "Min Of--Use the smallest cell size of all the input rasters.",
	"@@Square-Root_Extent-Type_tag0@@": "Choose which extent should be used in the output raster:",
	"@@Square-Root_Extent-Type_tag1@@": "First Of--Use the extent of the first input raster to determine the processing extent.",
	"@@Square-Root_Extent-Type_tag2@@": "Intersection Of--Use the extent of the overlapping pixels to determine the processing extent. This is the default.",
	"@@Square-Root_Extent-Type_tag3@@": "Last Of--Use the extent of the last input raster to determine the processing extent.",
	"@@Square-Root_Extent-Type_tag4@@": "Union Of--Use the extent of all the rasters to determine the processing extent.",
	"@@Square-Root_Raster_tag0@@": "The input values used to find the square root.",
	"@@Statistics-and-Histogram_Define-Statistics-and-Histogram_tag0@@": "Set the statistics values for each band.",
	"@@Statistics-and-Histogram_Define-Statistics-and-Histogram_tag1@@": "The ${Histogram} column is a read-only field that can be populated using the <strong>Import</strong> parameter. If you import a histogram file, the ${Histogram} column will be marked as <strong>Defined</strong>.",
	"@@Statistics-and-Histogram_Import_tag0@@": "Import the statistics and histogram information from an existing raster or XML file.",
	"@@Statistics-and-Histogram_Raster_tag0@@": "The input raster that requires the statistics and histogram to be set.",
	"@@Statistics-and-Histogram_Statistics_tag0@@": "Set the statistics values for each band.",
	"@@Stream-Link_Flow-Direction-Raster_tag0@@": "The input raster that shows the direction of flow out of each cell.",
	"@@Stream-Link_Flow-Direction-Raster_tag1@@": "The flow direction raster can be created by running the <strong>Flow Direction</strong> function.",
	"@@Stream-Link_Stream-Raster_tag0@@": "The input raster that represents a linear stream network.",
	"@@Stream-Order_Flow-Direction-Raster_tag0@@": "The input raster that shows the direction of flow out of each cell.",
	"@@Stream-Order_Flow-Direction-Raster_tag1@@": "The flow direction raster can be created by running the <strong>Flow Direction</strong> function.",
	"@@Stream-Order_Order-Method_tag0@@": "The method used for assigning stream order.",
	"@@Stream-Order_Order-Method_tag1@@": "<strong>STRAHLER</strong>--The method of stream ordering proposed by Strahler in 1952. Stream order only increases when streams of the same order intersect. The intersection of a first-order and second-order link will remain a second-order link, rather than creating a third-order link. This is the default.",
	"@@Stream-Order_Order-Method_tag3@@": "<strong>SHREVE</strong>--The method of stream ordering by magnitude, proposed by Shreve in 1967. All links with no tributaries are assigned a magnitude (order) of one. Magnitudes are additive downslope. When two links intersect, their magnitudes are added and assigned to the downslope link.",
	"@@Stream-Order_Stream-Raster_tag0@@": "An input stream raster that represents a linear stream network.",
	"@@Stretch_Auto-Gamma_tag0@@": "Use <strong>Auto Gamma</strong> to calculate gamma from the statistics and histogram of the dataset. The statistics can be the estimated stats by the function itself, or the statistics can be estimated by the software if you chose a layer.",
	"@@Stretch_Dynamic-Range-Adjustment_tag0@@": "Check the <strong>Dynamic Range Adjustment</strong> check box if you want the statistics calculated from only the pixels displayed on your screen. This option is generally applied when the image will be published and used in a web app that cannot perform this type of stretch.",
	"@@Stretch_Estimate-Statistics_tag0@@": "Check the <strong>Estimate Statistics</strong> check box if you want to estimate your statistics. The estimated statistics are calculated from a 1000 by 1000 sampling from the center of the raster and used by the stretch.",
	"@@Stretch_Estimate-Statistics_tag3@@": "If this is checked and the raster has statistics, or you've entered values in the <strong>Statistics</strong> table, they will be used instead of estimating, unless the stretch requires a histogram. If the stretch requires a histogram that doesn't exist, it will be estimated.",
	"@@Stretch_Gamma_tag0@@": "Use the slider bar to manually set the <strong>Gamma</strong> value.",
	"@@Stretch_Number-Of-Standard-Deviations_tag0@@": "Specify the n value for the number of standard deviations to use. This method is used to emphasize how much feature values vary from the mean value; it is best when used on normally distributed data.",
	"@@Stretch_Output-Maximum_tag0@@": "Set the highest pixel value for the histogram.",
	"@@Stretch_Output-Maximum_tag1@@": "The <strong>Output Minimum</strong> and <strong>Output Maximum</strong> will set the range of values that will then be linearly contrast stretched.",
	"@@Stretch_Output-Minimum_tag0@@": "Set the lowest pixel value for the histogram.",
	"@@Stretch_Output-Minimum_tag1@@": "The <strong>Output Minimum</strong> and <strong>Output Maximum</strong> will set the range of values that will then be linearly contrast stretched.",
	"@@Stretch_Percent-Clip-Maximum_tag0@@": "Specify the percentage of the high values to exclude from the stretch.",
	"@@Stretch_Percent-Clip-Maximum_tag1@@": "Valid values range from 0 to 99.",
	"@@Stretch_Percent-Clip-Minimum_tag0@@": "Specify the percentage of the low values to exclude from the stretch.",
	"@@Stretch_Percent-Clip-Minimum_tag1@@": "Valid values range from 0 to 99.",
	"@@Stretch_Raster_tag0@@": "The input raster to contrast stretch.",
	"@@Stretch_Sigmoid-Strength-Level_tag0@@": "The <strong>Strength Level</strong> determines how much of the sigmoidal function will be used in the stretch. A low value such as 1 will only use the middle portion of the curve, which tends to produce dull and faint colors. A high value such as 6 will use the entire curve, which tends to produce bold and sharp colors.",
	"@@Stretch_Statistics_tag0@@": "You can enter your own statistics on the dialog box. By default, the statistics are retrieved from the data; however, any values you enter in this parameter will be used instead.",
	"@@Stretch_Type_tag0@@": "Choose the stretch type method:",
	"@@Stretch_Type_tag1@@": "None--No contrast stretch",
	"@@Stretch_Type_tag2@@": "StdDev--Standard deviation stretch",
	"@@Stretch_Type_tag3@@": "MinMax--Minimum-Maximum stretch",
	"@@Stretch_Type_tag4@@": "PercentMinMax--Percent clip stretch",
	"@@Stretch_Type_tag5@@": "Sigmoid--Sigmoid stretch",
	"@@Stretch_Use-Gamma_tag0@@": "Check the <strong>Use Gamma</strong> check box if you want to apply a gamma stretch.",
	"@@Swath_Cellsize_tag0@@": "The cell size for the output raster will be automatically detected; however, you can change this if you want to. The cell size can be changed, but the extent of the raster dataset will remain the same.",
	"@@Swath_Interpolation-Method_tag0@@": "There are four resampling methods for this function:",
	"@@Swath_Interpolation-Method_tag1@@": "<strong>Nearest Neighbor</strong>--Calculates pixel value using the nearest pixel. If no source pixel exists, no new pixel can be created in the output.",
	"@@Swath_Interpolation-Method_tag3@@": "<strong>Bilinear</strong>--Calculates pixel value using the distance-weighted value of four nearest pixels.",
	"@@Swath_Interpolation-Method_tag5@@": "<strong>Linear Tinning</strong>--Uses a triangulated irregular network from the center points of each cell in the irregular raster to interpolate a surface that is then converted to a regular raster.",
	"@@Swath_Interpolation-Method_tag7@@": "<strong>Natural Neighbor</strong>--Performs a nearest neighbor assignment, is the fastest of the interpolation methods. It is used primarily for discrete data, such as a land-use classification, since it will not change the values of the cells. The maximum spatial error will be one-half the cell size.",
	"@@Swath_Raster_tag0@@": "The irregularly gridded raster to be resampled.",
	"@@Tan_Cellsize-Type_tag0@@": "Choose which cell size to use in the output raster. If all the input cell sizes are the same, all the options will yield the same results.",
	"@@Tan_Cellsize-Type_tag1@@": "First Of--Use the first cell size of the input rasters.",
	"@@Tan_Cellsize-Type_tag2@@": "Last Of--Use the last cell size of the input rasters.",
	"@@Tan_Cellsize-Type_tag3@@": "Max Of--Use the largest cell size of all the input rasters. This is the default.",
	"@@Tan_Cellsize-Type_tag4@@": "Mean Of--Use the mean cell size of all the input rasters.",
	"@@Tan_Cellsize-Type_tag5@@": "Min Of--Use the smallest cell size of all the input rasters.",
	"@@Tan_Extent-Type_tag0@@": "Choose which extent should be used in the output raster:",
	"@@Tan_Extent-Type_tag1@@": "First Of--Use the extent of the first input raster to determine the processing extent.",
	"@@Tan_Extent-Type_tag2@@": "Intersection Of--Use the extent of the overlapping pixels to determine the processing extent. This is the default.",
	"@@Tan_Extent-Type_tag3@@": "Last Of--Use the extent of the last input raster to determine the processing extent.",
	"@@Tan_Extent-Type_tag4@@": "Union Of--Use the extent of all the rasters to determine the processing extent.",
	"@@Tan_Raster_tag0@@": "The input for which to calculate the tangent values.",
	"@@TanH_Cellsize-Type_tag0@@": "Choose which cell size to use in the output raster. If all the input cell sizes are the same, all the options will yield the same results.",
	"@@TanH_Cellsize-Type_tag1@@": "First Of--Use the first cell size of the input rasters.",
	"@@TanH_Cellsize-Type_tag2@@": "Last Of--Use the last cell size of the input rasters.",
	"@@TanH_Cellsize-Type_tag3@@": "Max Of--Use the largest cell size of all the input rasters. This is the default.",
	"@@TanH_Cellsize-Type_tag4@@": "Mean Of--Use the mean cell size of all the input rasters.",
	"@@TanH_Cellsize-Type_tag5@@": "Min Of--Use the smallest cell size of all the input rasters.",
	"@@TanH_Extent-Type_tag0@@": "Choose which extent should be used in the output raster:",
	"@@TanH_Extent-Type_tag1@@": "First Of--Use the extent of the first input raster to determine the processing extent.",
	"@@TanH_Extent-Type_tag2@@": "Intersection Of--Use the extent of the overlapping pixels to determine the processing extent. This is the default.",
	"@@TanH_Extent-Type_tag3@@": "Last Of--Use the extent of the last input raster to determine the processing extent.",
	"@@TanH_Extent-Type_tag4@@": "Union Of--Use the extent of all the rasters to determine the processing extent.",
	"@@TanH_Raster_tag0@@": "The input for which to calculate the hyperbolic tangent values.",
	"@@Tasseled-Cap_Raster_tag0@@": "The input raster to perform the Tasseled Cap transformation on.",
	"@@Times_Cellsize-Type_tag0@@": "Choose which cell size to use in the output raster. If all the input cell sizes are the same, all the options will yield the same results.",
	"@@Times_Cellsize-Type_tag1@@": "First Of--Use the first cell size of the input rasters.",
	"@@Times_Cellsize-Type_tag2@@": "Last Of--Use the last cell size of the input rasters.",
	"@@Times_Cellsize-Type_tag3@@": "Max Of--Use the largest cell size of all the input rasters. This is the default.",
	"@@Times_Cellsize-Type_tag4@@": "Mean Of--Use the mean cell size of all the input rasters.",
	"@@Times_Cellsize-Type_tag5@@": "Min Of--Use the smallest cell size of all the input rasters.",
	"@@Times_Extent-Type_tag0@@": "Choose which extent should be used in the output raster:",
	"@@Times_Extent-Type_tag1@@": "First Of--Use the extent of the first input raster to determine the processing extent.",
	"@@Times_Extent-Type_tag2@@": "Intersection Of--Use the extent of the overlapping pixels to determine the processing extent. This is the default.",
	"@@Times_Extent-Type_tag3@@": "Last Of--Use the extent of the last input raster to determine the processing extent.",
	"@@Times_Extent-Type_tag4@@": "Union Of--Use the extent of all the rasters to determine the processing extent.",
	"@@Times_Raster_tag0@@": "The input containing the values to be multiplied.",
	"@@Times_Raster_tag1@@": "A constant value can be used as an input for this parameter, provided a raster is specified for the other parameter.",
	"@@Times_Raster2_tag0@@": "The input containing the values by which the first input will be multiplied.",
	"@@Times_Raster2_tag1@@": "A constant value can be used as an input for this parameter, provided a raster is specified for the other parameter.",
	"@@Transpose-Bits_Bit-Pattern_tag0@@": "Choose the type of transpose to perform or specify a custom one:",
	"@@Transpose-Bits_Bit-Pattern_tag1@@": "Landsat 8 Cirrus",
	"@@Transpose-Bits_Bit-Pattern_tag2@@": "Landsat 8 Cloud",
	"@@Transpose-Bits_Bit-Pattern_tag3@@": "Landsat 8 Cloud Shadow",
	"@@Transpose-Bits_Bit-Pattern_tag4@@": "Landsat 8 Designated Fill",
	"@@Transpose-Bits_Bit-Pattern_tag5@@": "Landsat 8 Dropped Frame",
	"@@Transpose-Bits_Bit-Pattern_tag6@@": "Landsat 8 Snow/Ice",
	"@@Transpose-Bits_Bit-Pattern_tag7@@": "Landsat 8 Terrain Occlusion",
	"@@Transpose-Bits_Bit-Pattern_tag8@@": "Landsat 8 Vegetation",
	"@@Transpose-Bits_Bit-Pattern_tag9@@": "Landsat 8 Water",
	"@@Transpose-Bits_Bit-Pattern_tag10@@": "User Defined",
	"@@Transpose-Bits_Constant-Value_tag0@@": "An optional value that will be used to fill in all bits that are not involved in the transpose. This parameter is exposed when the <strong>Generate Fill Raster from Constant</strong> parameter is set to <strong>Yes</strong>.",
	"@@Transpose-Bits_Fill-Raster_tag0@@": "Specify a raster dataset to be used to fill in all bits that are not involved in the transpose. This parameter is exposed when the <strong>Generate Fill Raster from Constant</strong> parameter is set to <strong>No</strong>.",
	"@@Transpose-Bits_Generate-Fill-Raster-from-Constant_tag0@@": "Generate a fill raster using a constant value:",
	"@@Transpose-Bits_Generate-Fill-Raster-from-Constant_tag1@@": "<strong>Yes</strong>--A raster will be generated using a constant value to fill in the bits not involved in the transpose. This is the default.",
	"@@Transpose-Bits_Generate-Fill-Raster-from-Constant_tag3@@": "<strong>No</strong>--A raster will be generated using pixel values from an existing raster dataset to fill in the bits not involved in the transpose.",
	"@@Transpose-Bits_Output-Bit-and-Input-Bit_tag0@@": "A read-only table that shows the output bits and the inputs that will be in their place.",
	"@@Transpose-Bits_Raster_tag0@@": "The input raster to unpack and remap.",
	"@@Unit-Conversion_From-Unit_tag0@@": "The original unit type of the pixels.",
	"@@Unit-Conversion_Raster_tag0@@": "The input raster that will contain the converted units.",
	"@@Unit-Conversion_To-Unit_tag0@@": "The converted unit type of the pixels.",
	"@@Vector-Field_Angle-Reference-System_tag0@@": "Specifies how the direction component was measured.",
	"@@Vector-Field_Angle-Reference-System_tag1@@": "Geographic--0 points due north, and 90 points due east",
	"@@Vector-Field_Angle-Reference-System_tag2@@": "Arithmetic--0 points due east, and 90 points due north",
	"@@Vector-Field_Input-Data-Type_tag0@@": "The type of vector field your inputs represent.",
	"@@Vector-Field_Input-Data-Type_tag1@@": "Unknown--It is unknown whether the inputs represent U-V or Magnitude-Direction.",
	"@@Vector-Field_Input-Data-Type_tag2@@": "U-V--Input data represents U and V components.",
	"@@Vector-Field_Input-Data-Type_tag3@@": "Magnitude-Direction--Input data represents magnitude and direction.",
	"@@Vector-Field_Output-Data-Type_tag0@@": "Specifies the type of vector field your output will represent.",
	"@@Vector-Field_Output-Data-Type_tag1@@": "Magnitude-Direction--Output data represents magnitude and direction.",
	"@@Vector-Field_Output-Data-Type_tag2@@": "U-V--Output data represents U and V components.",
	"@@Vector-Field_Raster1_tag0@@": "The first input raster.",
	"@@Vector-Field_Raster1_tag1@@": "This will either be the U value or the magnitude.",
	"@@Vector-Field_Raster2_tag0@@": "The second input raster.",
	"@@Vector-Field_Raster2_tag1@@": "This will either be the V value or the direction.",
	"@@Viewshed_Analysis-Method_tag0@@": "Choose the method by which the visibility will be calculated. This option allows you to trade some accuracy for increased performance.",
	"@@Viewshed_Analysis-Method_tag1@@": "All Sightlines--A sightline is performed on every pixel in the raster in order to establish visible areas. This is the default method.",
	"@@Viewshed_Analysis-Method_tag2@@": "Perimeter Sightlines--Sightlines are only performed to the pixels on the perimeter of the visible areas in order to establish visibility areas. This method has a better performance than the <strong>All Sightlines</strong> method since less sightlines are in the calculation.",
	"@@Viewshed_Analysis-Type_tag0@@": "Choose which type of visibility analysis you wish to perform, either determining how visible each cell is to the observers, or identifying for each surface location which observers are visible.",
	"@@Viewshed_Analysis-Type_tag1@@": "Frequency--The number of times that each pixel location in the input surface raster can be seen by the input observation locations (as points or as vertices for polyline observer features). This is the default.",
	"@@Viewshed_Analysis-Type_tag2@@": "Observers--The output identifies exactly which observer points are visible from each raster surface location. The allowed maximum number of input observers is 32 with this analysis type.",
	"@@Viewshed_Horizontal-End-Angle_tag0@@": "This value defines the end angle of the horizontal scan range. The value should be specified in degrees from 0 to 360.0, where 0 is oriented to north. The default value is 360.0.",
	"@@Viewshed_Horizontal-End-Angle_tag1@@": "It can be a field in the input <strong>Observer Features</strong> dataset or a numerical value. If this parameter is set to a value, that value will be applied to all the observers. To specify different values for each observer, set this parameter to a field in the <strong>Observer Features</strong> dataset.",
	"@@Viewshed_Horizontal-Start-Angle_tag0@@": "This value defines the start angle of the horizontal scan range. The value should be specified in degrees from 0 to 360.0, where 0 is oriented to north. The default value is 0.",
	"@@Viewshed_Horizontal-Start-Angle_tag1@@": "It can be a field in the input <strong>Observer Features</strong> dataset or a numerical value. If this parameter is set to a value, that value will be applied to all the observers. To specify different values for each observer, set this parameter to a field in the <strong>Observer Features</strong> dataset.",
	"@@Viewshed_Inner-Radius-is-3D-Distance_tag0@@": "Type of distance for the inner radius parameter.",
	"@@Viewshed_Inner-Radius-is-3D-Distance_tag1@@": "Unchecked--<strong>Inner Radius</strong> is to be interpreted as a 2D distance. This is the default.",
	"@@Viewshed_Inner-Radius-is-3D-Distance_tag4@@": "Checked--<strong>Inner Radius</strong> is to be interpreted as a 3D distance.",
	"@@Viewshed_Inner-Radius_tag0@@": "This value defines the start (minimum) distance from which visibility is determined. Pixels closer than this distance are considered not visible in the output but can still block visibility of the pixels between the <strong>Inner Radius</strong> and the <strong>Outer Radius</strong>. The default value is 0.",
	"@@Viewshed_Inner-Radius_tag5@@": "It can be a field in the input <strong>Observer Features</strong> dataset or a numerical value. If this parameter is set to a value, that value will be applied to all the observers. To specify different values for each observer, set this parameter to a field in the <strong>Observer Features</strong> dataset.",
	"@@Viewshed_Observer-Elevation_tag0@@": "This value is used to define the surface elevations of the observer points or vertices.",
	"@@Viewshed_Observer-Elevation_tag1@@": "It can be a field in the input <strong>Observer Features</strong> dataset or a numerical value. If this parameter is not specified, the observer elevation will be obtained from the surface raster using bilinear interpolation. If this parameter is set to a value, then that value will be applied to all the observers. To specify different values for each observer, set this parameter to a field in the <strong>Observer Features</strong> dataset.",
	"@@Viewshed_Observer-Features_tag0@@": "The required input feature class that identifies the observer locations. It can be point, multipoint, or polyline features.",
	"@@Viewshed_Observer-Features_tag1@@": "The input feature class is transformed into a 3D geocentric coordinate system during the visibility calculation. Observers outside of the extent of the surface raster, or located on NoData cells, will be ignored in the calculation.",
	"@@Viewshed_Observer-Offset_tag0@@": "This value indicates a vertical distance (in surface units) to be added to observer elevation. It should be a positive integer or floating-point value.",
	"@@Viewshed_Observer-Offset_tag1@@": "It can be a field in the input <strong>Observer Features</strong> dataset or a numerical value. If this parameter is set to a value, that value will be applied to all the observers. To specify different values for each observer, set this parameter to a field in the <strong>Observer Features</strong> dataset.",
	"@@Viewshed_Outer-Radius-is-3D-Distance_tag0@@": "Type of distance for the outer radius parameter.",
	"@@Viewshed_Outer-Radius-is-3D-Distance_tag1@@": "Unchecked--<strong>Outer Radius</strong> is to be interpreted as a 2D distance. This is the default.",
	"@@Viewshed_Outer-Radius-is-3D-Distance_tag4@@": "Checked--<strong>Outer Radius</strong> is to be interpreted as a 3D distance.",
	"@@Viewshed_Outer-Radius_tag0@@": "This value defines the maximum distance from which visibility is determined. Pixels beyond this distance are excluded from the analysis.",
	"@@Viewshed_Outer-Radius_tag1@@": "It can be a field in the input <strong>Observer Features</strong> dataset or a numerical value. If this parameter is set to a value, that value will be applied to all the observers. To specify different values for each observer, set this parameter to a field in the <strong>Observer Features</strong> dataset.",
	"@@Viewshed_Raster_tag0@@": "The required input surface raster. It can be an integer or a floating-point raster.",
	"@@Viewshed_Raster_tag1@@": "The input is transformed into a 3D geocentric coordinate system during the visibility calculation. NoData cells on the input raster do not block the visibility determination.",
	"@@Viewshed_Refractive-Coefficient_tag0@@": "Coefficient of the refraction of visible light in air.",
	"@@Viewshed_Refractive-Coefficient_tag1@@": "The default value is 0.13.",
	"@@Viewshed_Surface-Offset_tag0@@": "This value indicates a vertical distance (in surface units) to be added to the z-value of each target pixel as it is considered for visibility. It should be a positive integer or floating-point value.",
	"@@Viewshed_Surface-Offset_tag1@@": "It can be a field in the input <strong>Observer Features</strong> dataset or a numerical value. If this parameter is set to a value, that value will be applied to all the observers. To specify different values for each observer, set this parameter to a field in the <strong>Observer Features</strong> dataset.",
	"@@Viewshed_Vertical-Error_tag0@@": "The amount of uncertainty, measured as Root Mean Square error (RMSE), in the surface elevation values. It is a floating-point value representing the expected error of the input elevation values. When this parameter is assigned a value greater than 0, the output visibility raster will be floating point. In this case, each pixel value on the output visibility raster represents the sum of probabilities that the cell is visible to any of the observers.",
	"@@Viewshed_Vertical-Error_tag1@@": "When the <strong>Analysis Type</strong> is <strong>Observers</strong> or the <strong>Analysis Method</strong> is <strong>Perimeter Sightlines</strong>, this parameter is disabled.",
	"@@Viewshed_Vertical-Lower-Angle_tag0@@": "This value defines the lower vertical angle limit of the scan below a horizontal plane. The value should be specified in degrees from -90.0 to 0, which can be integer or floating point. The default value is -90.0.",
	"@@Viewshed_Vertical-Lower-Angle_tag1@@": "It can be a field in the input <strong>Observer Features</strong> dataset or a numerical value. If this parameter is set to a value, that value will be applied to all the observers. To specify different values for each observer, set this parameter to a field in the <strong>Observer Features</strong> dataset.",
	"@@Viewshed_Vertical-Upper-Angle_tag0@@": "This value defines the upper vertical angle limit of the scan above a horizontal plane. The value should be specified in degrees from 0 to 90.0, which can be integer or floating point. The default value is 90.0.",
	"@@Viewshed_Vertical-Upper-Angle_tag1@@": "It can be a field in the input <strong>Observer Features</strong> dataset or a numerical value. If this parameter is set to a value, that value will be applied to all the observers. To specify different values for each observer, set this parameter to a field in the <strong>Observer Features</strong> dataset.",
	"@@Watershed_Flow-Direction-Raster_tag0@@": "The input raster that shows the direction of flow out of each cell.",
	"@@Watershed_Flow-Direction-Raster_tag1@@": "The flow direction raster can be created by running the <strong>Flow Direction</strong> function.",
	"@@Watershed_Pour-Point(s)-Raster_tag0@@": "The input pour point locations.",
	"@@Watershed_Pour-Point(s)-Raster_tag1@@": "This raster represents cells above which the contributing area, or catchment, will be determined. All cells that are not NoData will be used as source cells.",
	"@@Watershed_Pour-Point-Field_tag0@@": "Field used to assign values to the pour point locations.",
	"@@Watershed_Pour-Point-Field_tag1@@": "For a raster pour point dataset, ${Value} is used by default.",
	"@@Weighted-Overlay_Cellsize-Type_tag0@@": "Choose which cell size to use in the output raster. If all the input cell sizes are the same, all the options will yield the same results.",
	"@@Weighted-Overlay_Cellsize-Type_tag1@@": "First Of--Use the first cell size of the input rasters.",
	"@@Weighted-Overlay_Cellsize-Type_tag2@@": "Min Of--Use the smallest cell size of all the input rasters.",
	"@@Weighted-Overlay_Cellsize-Type_tag3@@": "Max Of--Use the largest cell size of all the input rasters. This is the default.",
	"@@Weighted-Overlay_Cellsize-Type_tag4@@": "Mean Of--Use the mean cell size of all the input rasters.",
	"@@Weighted-Overlay_Cellsize-Type_tag5@@": "Last Of--Use the last cell size of the input rasters.",
	"@@Weighted-Overlay_Extent-Type_tag0@@": "Choose which extent should be used in the output raster:",
	"@@Weighted-Overlay_Extent-Type_tag1@@": "First Of--Use the extent of the first input raster to determine the processing extent.",
	"@@Weighted-Overlay_Extent-Type_tag2@@": "Intersection Of--Use the extent of the overlapping pixels to determine the processing extent. This is the default.",
	"@@Weighted-Overlay_Extent-Type_tag3@@": "Union Of--Use the extent of all the rasters to determine the processing extent.",
	"@@Weighted-Overlay_Extent-Type_tag4@@": "Last Of--Use the extent of the last input raster to determine the processing extent.",
	"@@Weighted-Overlay_Scales_tag0@@": "The range for the new values by which to remap the old values.",
	"@@Weighted-Overlay_Weighted-Overlay-Table_tag0@@": "The weighted overlay table consists of four parts:",
	"@@Weighted-Overlay_Weighted-Overlay-Table_tag1@@": "Layer--All input rasters must be of type integer.",
	"@@Weighted-Overlay_Weighted-Overlay-Table_tag2@@": "Influence--Each input raster is weighted according to its importance, or its influence, as a relative percentage. The sum of the percent influence weights must equal 100, and each weight must be specified by integer values.",
	"@@Weighted-Overlay_Weighted-Overlay-Table_tag3@@": "Field--An integer or string field on the input raster to use for weighting.",
	"@@Weighted-Overlay_Weighted-Overlay-Table_tag4@@": "Remap Table--Each value in an input raster is assigned a new scale value based on the remap table. The scale value can be a valid value or a NoData value.",
	"@@Weighted-Sum_Cellsize-Type_tag0@@": "Choose which cell size to use in the output raster. If all the input cell sizes are the same, all the options will yield the same results.",
	"@@Weighted-Sum_Cellsize-Type_tag1@@": "First Of--Use the first cell size of the input rasters.",
	"@@Weighted-Sum_Cellsize-Type_tag2@@": "Last Of--Use the last cell size of the input rasters.",
	"@@Weighted-Sum_Cellsize-Type_tag3@@": "Max Of--Use the largest cell size of all the input rasters. This is the default.",
	"@@Weighted-Sum_Cellsize-Type_tag4@@": "Mean Of--Use the mean cell size of all the input rasters.",
	"@@Weighted-Sum_Cellsize-Type_tag5@@": "Min Of--Use the smallest cell size of all the input rasters.",
	"@@Weighted-Sum_Extent-Type_tag0@@": "Choose which extent should be used in the output raster:",
	"@@Weighted-Sum_Extent-Type_tag1@@": "First Of--Use the extent of the first input raster to determine the processing extent.",
	"@@Weighted-Sum_Extent-Type_tag2@@": "Intersection Of--Use the extent of the overlapping pixels to determine the processing extent. This is the default.",
	"@@Weighted-Sum_Extent-Type_tag3@@": "Last Of--Use the extent of the last input raster to determine the processing extent.",
	"@@Weighted-Sum_Extent-Type_tag4@@": "Union Of--Use the extent of all the rasters to determine the processing extent.",
	"@@Weighted-Sum_Weighted-Sum-Table_tag0@@": "The weighted sum table is defined by three properties:",
	"@@Weighted-Sum_Weighted-Sum-Table_tag1@@": "Layer--The raster being weighted.",
	"@@Weighted-Sum_Weighted-Sum-Table_tag2@@": "Field--The field of the raster to use for weighting.",
	"@@Weighted-Sum_Weighted-Sum-Table_tag3@@": "Weight--The weight value by which to multiply the raster. It can be any positive or negative decimal value.",
	"@@Wind-Chill_Temperature-Raster_tag0@@": "A single-band raster where pixel values represent ambient air temperature.",
	"@@Wind-Chill_Temperature-Units_tag0@@": "The unit of measurement associated with the input temperature raster. Available input units are Celsius, Fahrenheit, and Kelvin.",
	"@@Wind-Chill_Wind-Chill-Units_tag0@@": "The unit of measurement associated with the output raster. Available output units are Celsius, Fahrenheit, and Kelvin.",
	"@@Wind-Chill_Wind-Speed-Raster_tag0@@": "A single-band raster where pixel values represent wind speed.",
	"@@Wind-Chill_Wind-Speed-Units_tag0@@": "Defines the unit of measurement for the wind-speed raster:",
	"@@Wind-Chill_Wind-Speed-Units_tag1@@": "Miles Per Hour (mph)",
	"@@Wind-Chill_Wind-Speed-Units_tag2@@": "Kilometers Per Hour (km/h)",
	"@@Wind-Chill_Wind-Speed-Units_tag3@@": "Meters Per Second (m/s)",
	"@@Wind-Chill_Wind-Speed-Units_tag4@@": "Feet Per Second (ft/s)",
	"@@Wind-Chill_Wind-Speed-Units_tag5@@": "Knots (kn)",
	"@@Zonal-Remap_Background-Value_tag0@@": "The initial pixel value of the output raster, before input pixels are remapped.",
	"@@Zonal-Remap_Default-Output-Value_tag0@@": "The value that will be assigned to a pixel that does not satisfy any of the conditions set in the <strong>Zonal Attributes Table</strong>.",
	"@@Zonal-Remap_Default-Output-Value_tag3@@": "This will also be the value of the output pixel if either the <strong>Output Value Field Name</strong> parameter is left unspecified or the output value of the corresponding zonal threshold is left unspecified in the <strong>Zonal Attributes Table</strong>.",
	"@@Zonal-Remap_Maximum-Value-Field-Name_tag0@@": "The field name containing the maximum value below which an input pixel is remapped.",
	"@@Zonal-Remap_Maximum-Value-Field-Name_tag1@@": "If left unspecified, or if the field value is null, pixel values are not tested for maximum.",
	"@@Zonal-Remap_Minimum-Value-Field-Name_tag0@@": "The field name containing the minimum value above which an input pixel is remapped.",
	"@@Zonal-Remap_Minimum-Value-Field-Name_tag1@@": "If left unspecified, or if the field value is null, pixel values are not tested for minimum.",
	"@@Zonal-Remap_Output-Value-Field-Name_tag0@@": "The field name containing the target value to which an input pixel is remapped.",
	"@@Zonal-Remap_Output-Value-Field-Name_tag1@@": "If left unspecified, or if the field value is null, remapped pixel values are set to <strong>Default Output Value</strong>.",
	"@@Zonal-Remap_Value-Raster_tag0@@": "A required single-band raster input containing pixel values to remap.",
	"@@Zonal-Remap_Where-Clause_tag0@@": "An optional query applied on the <strong>Zonal Attributes Table</strong>.",
	"@@Zonal-Remap_Where-Clause_tag3@@": "If you were using the table above as an example, the query would be ${Variable1 = 'bare earth' AND Variable2 = 'California'}.",
	"@@Zonal-Remap_Zonal-Attributes-Table_tag0@@": "A required input table containing at least three fields. It must have a minimum threshold value, maximum threshold value, and target value. The target value is the field that will contain the remapped value.",
	"@@Zonal-Remap_Zonal-Attributes-Table_tag1@@": "The format of the file can be a feature class, feature service, or any table type that ArcGIS supports.",
	"@@Zonal-Remap_Zone-Field_tag0@@": "The field name in the <strong>Zonal Attributes Table</strong> that contains the zone ID values.",
	"@@Zonal-Remap_Zone-Field_tag3@@": "The zone ID values are directly tied to the zone IDs in your zonal raster. They provide another level of filtering while remapping. If there is no zone ID associated with a particular record in the table, it will not participate in the remapping.",
	"@@Zonal-Remap_Zone-Raster_tag0@@": "A single-band raster where each pixel defines zones associated with a particular location. A zone is defined as all areas in the input that have the same value. The areas do not have to be contiguous.",
	"@@Predict-Using-Trend_dimensiondefinition_tag0@@": "Specifies the method used to provide prediction dimension values.",
	"@@Predict-Using-Trend_dimensiondefinition_tag1@@": "<strong>By Value</strong>--The prediction will be calculated for a single dimension value . For example, you want to predict yearly precipitation for the years 2050, 2100, and 2150. This is the default.",
	"@@Predict-Using-Trend_dimensiondefinition_tag2@@": "<strong>By Interval</strong>--The prediction will be calculated for an interval of the dimension defined by a start and an end value. For example, you want to predict yearly precipitation for every year between 2050 and 2150.",
	"@@Predict-Using-Trend_end_tag0@@": "The end date, height, or depth of the dimension interval to be used in the prediction.",
	"@@Predict-Using-Trend_end_tag1@@": "This parameter is required when the <strong>Dimension Definition</strong> parameter is set to <strong>By Interval</strong>.",
	"@@Predict-Using-Trend_raster_tag0@@": "The input multidimensional trend raster from the <strong>Generate Trend</strong> function.",
	"@@Predict-Using-Trend_start_tag0@@": "The start date, height, or depth of the dimension interval to be used in the prediction.",
	"@@Predict-Using-Trend_start_tag1@@": "This parameter is required when the <strong>Dimension Definition</strong> parameter is set to <strong>By Interval</strong>.",
	"@@Predict-Using-Trend_unit_tag0@@": "The unit that will be used for the value interval. This parameter only applies when the dimension of analysis is a time dimension.",
	"@@Predict-Using-Trend_unit_tag1@@": "<strong>Hours</strong>--The prediction will be calculated for each hour in the range of time described by the <strong>Start</strong>, <strong>End</strong>, and <strong>Value Interval</strong> parameters.",
	"@@Predict-Using-Trend_unit_tag2@@": "<strong>Days</strong>--The prediction will be calculated for each day in the range of time described by the <strong>Start</strong>, <strong>End</strong>, and <strong>Value Interval</strong> parameters.",
	"@@Predict-Using-Trend_unit_tag3@@": "<strong>Weeks</strong>--The prediction will be calculated for each week in the range of time described by the <strong>Start</strong>, <strong>End</strong>, and <strong>Value Interval</strong> parameters.",
	"@@Predict-Using-Trend_unit_tag4@@": "<strong>Months</strong>--The prediction will be calculated for each month in the range of time described by the <strong>Start</strong>, <strong>End</strong>, and <strong>Value Interval</strong> parameters.",
	"@@Predict-Using-Trend_unit_tag5@@": "<strong>Years</strong>--The prediction will be calculated for each year in the range of time described by the <strong>Start</strong>, <strong>End</strong>, and <strong>Value Interval</strong> parameters.",
	"@@Predict-Using-Trend_valueinterval_tag0@@": "The number of steps between two dimension values to be included in the prediction. The default value is 1.",
	"@@Predict-Using-Trend_valueinterval_tag1@@": "This parameter is required when the <strong>Dimension Definition</strong> parameter is set to <strong>By Interval</strong>.",
	"@@Predict-Using-Trend_values_tag0@@": "The dimension value or values to be used in the prediction.",
	"@@Predict-Using-Trend_values_tag1@@": "The format of the time, depth, and height values must match the format of the dimension values used to generate the trend raster. If the trend raster was generated for the StdTime dimension, the format should be YYYY-MM-DDTHH:MM:SS, for example, 2050-01-01T00:00:00. Multiple values are separated with a semicolon.",
	"@@Process-Raster-Collection_aggregationfunction_tag0@@": "Specify the raster function template used to aggregate multiple slices into fewer slices or a single slice.",
	"@@Process-Raster-Collection_dimension_tag0@@": "The aggregation dimension. This is the dimension along which the variables will be aggregated.",
	"@@Process-Raster-Collection_itemfunction_tag0@@": "Specify the raster function template used to process each slice or item in the input raster collection.",
	"@@Process-Raster-Collection_keywordinterval_tag0@@": "Specifies the keyword interval that will be used when aggregating along the dimension. This parameter is required when the <strong>Type</strong> is set to <strong>Interval Keyword</strong>, and the aggregation must be across time.",
	"@@Process-Raster-Collection_keywordinterval_tag1@@": "<strong>Hourly</strong>--The data values will be aggregated into hourly time steps, and the result will include every hour in the time series.",
	"@@Process-Raster-Collection_keywordinterval_tag2@@": "<strong>Daily</strong>--The data values will be aggregated into daily time steps, and the result will include every day in the time series.",
	"@@Process-Raster-Collection_keywordinterval_tag3@@": "<strong>Weekly</strong>--The data values will be aggregated into weekly time steps, and the result will include every week in the time series.",
	"@@Process-Raster-Collection_keywordinterval_tag4@@": "<strong>Dekadly</strong>--The data values will be aggregated into 3 periods of 10 days each. The last period might contain more or fewer than 10 days. The output will include 3 slices for each month.",
	"@@Process-Raster-Collection_keywordinterval_tag5@@": "<strong>Pentadly</strong>--The data values will be aggregated into 6 periods of 5 days each. The last period might contain more or fewer than 5 days. The output will include 6 slices for each month.",
	"@@Process-Raster-Collection_keywordinterval_tag6@@": "<strong>Monthly</strong>--The data values will be aggregated into monthly time steps, and the result will include every month in the time series.",
	"@@Process-Raster-Collection_keywordinterval_tag7@@": "<strong>Quarterly</strong>--The data values will be aggregated into quarterly time steps, and the result will include every quarter in the time series.",
	"@@Process-Raster-Collection_keywordinterval_tag8@@": "<strong>Yearly</strong>--The data values will be aggregated into yearly time steps, and the result will include every year in the time series.",
	"@@Process-Raster-Collection_keywordinterval_tag9@@": "<strong>Recurring daily</strong>--The data values will be aggregated into daily time steps, and the result will include one aggregated value per Julian day. The output will include, at most, 366 daily time slices.",
	"@@Process-Raster-Collection_keywordinterval_tag10@@": "<strong>Recurring weekly</strong>--The data values will be aggregated into weekly time steps, and the result will include one aggregated value per week. The output will include, at most, 53 weekly time slices.",
	"@@Process-Raster-Collection_keywordinterval_tag11@@": "<strong>Recurring monthly</strong>--The data values will be aggregated into monthly time steps, and the result will include one aggregated value per month. The output will include, at most, 12 monthly time slices.",
	"@@Process-Raster-Collection_keywordinterval_tag12@@": "<strong>Recurring quarterly</strong>--The data values will be aggregated into quarterly time steps, and the result will include one aggregated value per quarter. The output will include, at most, 4 quarterly time slices.",
	"@@Process-Raster-Collection_maximumvalue_tag0@@": "The maximum value for a range.",
	"@@Process-Raster-Collection_maximumvalue_tag1@@": "This parameter is required when the <strong>Type</strong> parameter is set to <strong>Interval Ranges</strong>.",
	"@@Process-Raster-Collection_minimumvalue_tag0@@": "The minimum value for a range.",
	"@@Process-Raster-Collection_minimumvalue_tag1@@": "This parameter is required when the <strong>Type</strong> parameter is set to <strong>Interval Ranges</strong>.",
	"@@Process-Raster-Collection_processingfunction_tag0@@": "Specify the raster function template used to display the processed raster layer.",
	"@@Process-Raster-Collection_rastercollection_tag0@@": "The input multidimensional raster, mosaic layer, or mosaic dataset.",
	"@@Process-Raster-Collection_type_tag0@@": "Specifies the dimension interval for which the data will be aggregated.",
	"@@Process-Raster-Collection_type_tag1@@": "<strong>All</strong>--The data values will be aggregated across all slices. This is the default.",
	"@@Process-Raster-Collection_type_tag2@@": "<strong>Interval Keyword</strong>--The variable data will be aggregated using a commonly known interval.",
	"@@Process-Raster-Collection_type_tag3@@": "<strong>Interval Ranges</strong>--The variable data will be aggregated between specified pairs of values or dates.",
	"@@Process-Raster-Collection_type_tag4@@": "<strong>Interval Values</strong>--The variable data will be aggregated using a user-specified interval and unit.",
	"@@Process-Raster-Collection_unit_tag0@@": "The unit that will be used for the interval value. This parameter is required when the <strong>Dimension</strong> is a time field and the <strong>Type</strong> parameter is set to <strong>Interval Value</strong>.",
	"@@Process-Raster-Collection_unit_tag1@@": "If you are aggregating over anything other than time, this option will not be available and the unit for the interval value will match the variable unit of the input multidimensional raster data.",
	"@@Process-Raster-Collection_unit_tag2@@": "<strong>Hours</strong>--The data values will be aggregated into hourly time slices at the interval provided.",
	"@@Process-Raster-Collection_unit_tag3@@": "<strong>Days</strong>--The data values will be aggregated into daily time slices at the interval provided.",
	"@@Process-Raster-Collection_unit_tag4@@": "<strong>Weeks</strong>--The data values will be aggregated into weekly time slices at the interval provided.",
	"@@Process-Raster-Collection_unit_tag5@@": "<strong>Months</strong>--The data values will be aggregated into monthly time slices at the interval provided.",
	"@@Process-Raster-Collection_unit_tag6@@": "<strong>Years</strong>--The data values will be aggregated into yearly time slices at the interval provided.",
	"@@Process-Raster-Collection_valueinterval_tag0@@": "The size of the interval that will be used for the aggregation. This parameter is required when the <strong>Type</strong> parameter is set to <strong>Interval Value</strong>.",
	"@@Process-Raster-Collection_valueinterval_tag1@@": "For example, to aggregate 30 years of monthly temperature data into 5-year increments, enter 5 as the <strong>Value Interval</strong>, and specify <strong>Unit</strong> as <strong>Years</strong>.",
	"@@Linear-Spectral-Unmixing_non-negative_tag0@@": "Specifies the options to define the output pixel values.",
	"@@Linear-Spectral-Unmixing_non-negative_tag1@@": "Checked--There will be no negative output values.",
	"@@Linear-Spectral-Unmixing_non-negative_tag2@@": "Unchecked--There can be negative values of fractional land cover.",
	"@@Linear-Spectral-Unmixing_raster_tag0@@": "The input raster.",
	"@@Linear-Spectral-Unmixing_spectralprofile_tag0@@": "The input spectral profile file.",
	"@@Linear-Spectral-Unmixing_spectralprofiletype_tag0@@": "The spectral information for the different land cover classes.",
	"@@Linear-Spectral-Unmixing_spectralprofiletype_tag1@@": "<strong>Spectral Profile</strong>--A classifier definition file (${.ecd}), generated from the <strong><strong>Train Maximum Likelihood Classifier</strong></strong> tool, or a JavaScript Object Notation file (${.json}) that contains the class spectral profiles.",
	"@@Linear-Spectral-Unmixing_spectralprofiletype_tag2@@": "<strong>Training Feature</strong>--Polygon features or a training sample feature class, generated from the <strong>Training Samples Manager</strong>.",
	"@@Linear-Spectral-Unmixing_sumtoone_tag0@@": "Specifies the options to define the output pixel values.",
	"@@Linear-Spectral-Unmixing_sumtoone_tag1@@": "Checked--Class values for each pixel are provided in decimal format with the sum of all classes equal to 1. For example, Class1 = 0.16; Class2 = 0.24; Class3 = 0.60.",
	"@@Linear-Spectral-Unmixing_sumtoone_tag2@@": "Unchecked--The sum of all classes in a pixel can exceed 1.",
	"@@Linear-Spectral-Unmixing_trainingfeature_tag0@@": "The input training feature file.",
	"@@Aggregate_aggregationtechnique_tag0@@": "The method used for aggregation. The values of the input cells encompassed by the coarser output cells are aggregated by one of the following statistics:",
	"@@Aggregate_aggregationtechnique_tag1@@": "<strong>Sum</strong>--The total of the input cells. This is the default.",
	"@@Aggregate_aggregationtechnique_tag2@@": "<strong>Maximum</strong>--The largest value of the input cells.",
	"@@Aggregate_aggregationtechnique_tag3@@": "<strong>Mean</strong>--The average value of the input cells.",
	"@@Aggregate_aggregationtechnique_tag4@@": "<strong>Median</strong>--The median value of the input cells.",
	"@@Aggregate_aggregationtechnique_tag5@@": "<strong>Minimum</strong>--The smallest value of the input cells.",
	"@@Aggregate_cellfactor_tag0@@": "The factor by which to multiply the cell size of the input raster.",
	"@@Aggregate_cellfactor_tag1@@": "For example, a cell factor value of three would result in an output cell size three times larger than that of the input raster.",
	"@@Aggregate_expandextentifneeded_tag0@@": "Defines how to handle the boundaries of the input raster when its rows or columns are not a multiple of the cell factor.",
	"@@Aggregate_expandextentifneeded_tag1@@": "Checked--Expands the top or right boundaries of the input raster so the total number of cells in a row or column is a multiple of the cell factor. With this option, the output raster can cover a larger spatial extent than the input raster. This is the default.",
	"@@Aggregate_expandextentifneeded_tag2@@": "Unchecked--Reduces the number of rows or columns in the output raster. This truncates the remaining cells on the top or right boundaries of the input raster, making the number of rows or columns in the input raster a multiple of the cell factor. With this option, the output raster can cover a smaller spatial extent than the input raster.",
	"@@Aggregate_ignorenodataincalculations_tag0@@": "Denotes whether ${NoData} values are ignored by the aggregation calculation.",
	"@@Aggregate_ignorenodataincalculations_tag1@@": "Checked--Specifies that if ${NoData} values exist for any of the cells that fall within the spatial extent of a larger cell on the output raster, the ${NoData} values will be ignored when determining the value for output cell locations. Only input cells within the extent of the output cell that have data values will be used in determining the value of the output cell. This is the default.",
	"@@Aggregate_ignorenodataincalculations_tag2@@": "Unchecked--Specifies that if any cell that falls within the spatial extent of a larger cell on the output raster has a value of ${NoData}, the value for that output cell location will be ${NoData}. When the this option is used, it is implied that when cells within an aggregation contain the ${NoData} value, there is insufficient information to perform the specified calculations necessary to determine an output value.",
	"@@Aggregate_raster_tag0@@": "The input raster to be aggregated.",
	"@@Expand_numberofcells_tag0@@": "The number of cells to expand by.",
	"@@Expand_numberofcells_tag1@@": "The value must be integer, and can be 1 or greater.",
	"@@Expand_raster_tag0@@": "The input raster for which the identified zones are to be expanded.",
	"@@Expand_raster_tag1@@": "It must be of integer type.",
	"@@Expand_zonevalues_tag0@@": "The list of zones to expand.",
	"@@Expand_zonevalues_tag1@@": "The zone values must be integer, and they can be in any order.",
	"@@Expand_zonevalues_tag2@@": "To specify multiple zones, use a space to separate the zone values.",
	"@@Multidimensional-Filter_dimension_tag0@@": "The dimension to extract variables from.",
	"@@Multidimensional-Filter_dimensiondefinition_tag0@@": "Specifies the method that will be used to slice the dimension.",
	"@@Multidimensional-Filter_dimensiondefinition_tag1@@": "<strong>All</strong>--The full range for each dimension will be used. This is the default.",
	"@@Multidimensional-Filter_dimensiondefinition_tag2@@": "<strong>By Values</strong>--The dimension will be sliced using a dimension value or list of values.",
	"@@Multidimensional-Filter_dimensiondefinition_tag3@@": "<strong>By Ranges</strong>--The dimension will be sliced using a range or a list of ranges.",
	"@@Multidimensional-Filter_dimensiondefinition_tag4@@": "<strong>By Iteration</strong>--The dimension will be sliced over a specified interval size.",
	"@@Multidimensional-Filter_endoffirstiteration_tag0@@": "The end of the first interval. This interval is used to iterate through the dataset.This parameter is required when the <strong>Dimension Definition</strong> parameter is set to <strong>By Iteration</strong>.",
	"@@Multidimensional-Filter_maximumvalue_tag0@@": "The maximum value for the range. This parameter is required when the <strong>Dimension Definition</strong> parameter is set to <strong>By Ranges</strong>.",
	"@@Multidimensional-Filter_minimumvalue_tag0@@": "The minimum value for the range. This parameter is required when the <strong>Dimension Definition</strong> parameter is set to <strong>By Ranges</strong>.",
	"@@Multidimensional-Filter_raster_tag0@@": "The input multidimensional raster.",
	"@@Multidimensional-Filter_ranges_tag0@@": "<p>Interval ranges specified in a table are used to aggregate groups of values. The minimum and maximum values specify the range to be included.</p><p>This parameter is required when the<strong>Type</strong>parameter is set to<strong>Interval Ranges</strong>.</p>",
	"@@Multidimensional-Filter_startoffirstiteration_tag0@@": "The beginning of the first interval. This interval is used to iterate through the dataset.This parameter is required when the <strong>Dimension Definition</strong> parameter is set to <strong>By Iteration</strong>.",
	"@@Multidimensional-Filter_step_tag0@@": "The frequency with which the data will be sliced.This parameter is required when the <strong>Dimension Definition</strong> parameter is set to <strong>By Iteration</strong>. The default is 3.",
	"@@Multidimensional-Filter_unit_tag0@@": "Specifies the iteration unit. This parameter is required when the <strong>Dimension Definition</strong> parameter is set to <strong>By Iteration</strong> and the <strong>Dimension</strong> parameter is set to <strong>StdTime</strong>.",
	"@@Multidimensional-Filter_value_tag0@@": "The value for the specified dimension. This parameter is required when the <strong>Dimension Definition</strong> parameter is set to <strong>By Values</strong>.",
	"@@Multidimensional-Filter_variables_tag0@@": "The variables that will be included in the output multidimensional raster layer. If no variable is specified, the first variable will be used.",
	"@@Multidimensional-Filter_dimensionless_tag0@@": "Specifies whether the layer should have dimension values. This option is only available if a single slice is selected to create a layer.",
	"@@Multidimensional-Filter_dimensionless_tag1@@": "Checked--The layer will not have dimension values.",
	"@@Multidimensional-Filter_dimensionless_tag2@@": "Unchecked--The layer will have a dimension value. This is the default.",
	"@@Multidimensional-Raster_interpolationcellsize_tag0@@": "The cell size of the interpolated raster. The default value is ${1}.",
	"@@Multidimensional-Raster_interpolationmethod_tag0@@": "The resampling method used to interpolate irregular data.",
	"@@Multidimensional-Raster_interpolationmethod_tag1@@": "<strong>Nearest Neighbor</strong>--Calculates the output pixel value using the nearest input pixel. If no source pixel exists, no new pixel can be created in the output. This is the default.",
	"@@Multidimensional-Raster_interpolationmethod_tag2@@": "<strong>Linear Tinning</strong>--Uses a triangulated irregular network from the center point of each pixel in the irregular raster to interpolate a surface that is then converted to a regular raster.",
	"@@Multidimensional-Raster_interpolationmethod_tag3@@": "<strong>Natural Neighbor</strong>--Finds the closest subset of input samples to a query point and applies weights to them, based on proportionate areas, to interpolate a value.",
	"@@Multidimensional-Raster_interpolationmethod_tag4@@": "<strong>Inverse Distance Weighting</strong>--Determines pixel values using a linearly weighted combination of a set of sample points or pixels. The weight is a function of the inverse of the distance from the known points or pixels.",
	"@@Multidimensional-Raster_raster_tag0@@": "The input multidimensional raster.",
	"@@Multidimensional-Raster_variables_tag0@@": "The variable or variables to be included in the multidimensional raster layer.",
	"@@Random_distribution_tag0@@": "Specify the random value distribution method to use.",
	"@@Random_distribution_tag1@@": "<strong>Uniform</strong> (Minimum, Maximum)--A uniform distribution with a defined range. The default values are 0 for Minimum and 1 for Maximum. This is the default.",
	"@@Random_distribution_tag2@@": "<strong>Integer</strong> (Minimum, Maximum)--An integer distribution with a defined range. The default values are 1 for Minimum and 10 for Maximum.",
	"@@Random_distribution_tag3@@": "<strong>Normal</strong> (Mean, Standard Deviation)--A normal distribution with a defined mean and standard deviation. The default values are 0 for Mean and 1 for Standard Deviation.",
	"@@Random_distribution_tag4@@": "<strong>Exponential</strong> (Mean)--An exponential distribution with a defined mean. The default value is 1.",
	"@@Random_distribution_tag5@@": "<strong>Poisson</strong> (Mean)--A Poisson distribution with a defined mean. The default value is 1.",
	"@@Random_distribution_tag6@@": "<strong>Gamma</strong> (Alpha, Beta)--A gamma distribution with a defined alpha and beta. The default values are 1 for Alpha and 1 for Beta.",
	"@@Random_distribution_tag7@@": "<strong>Binomial</strong> (N, Probability)--A binomial distribution with a defined N and probability. The default values are 10 for N and 0.5 for Probability.",
	"@@Random_distribution_tag8@@": "<strong>Geometric</strong> (Probability)--A geometric distribution with a defined probability. The default value is 0.5.",
	"@@Random_distribution_tag9@@": "<strong>Negative Binomial</strong> (r, Probability)--A Pascal distribution with a defined r and probability. The default values are 10.0 for r and 0.5 for Probability.",
	"@@Random_randomnumbergenerator_tag0@@": "Specify the random generator algorithm that uses the seed and distribution to produce a sequence of random numbers. The available options are as follows:",
	"@@Random_randomnumbergenerator_tag1@@": "Standard C Rand",
	"@@Random_randomnumbergenerator_tag2@@": "ACM collected algorithm 599",
	"@@Random_randomnumbergenerator_tag3@@": "Mersenne Twister",
	"@@Random_randomnumbergenerator_tag4@@": "The default value is Mersenne Twister.",
	"@@Random_rasterinfo_tag0@@": "Use the <strong>Load template raster</strong> button to load a template from a directory or portal.",
	"@@Random_seed_tag0@@": "The seed is an integer value and is used to initiate the random number generator. The default value is 1.",
	"@@Shrink_numberofcells_tag0@@": "The number of cells by which to shrink each specified zone.",
	"@@Shrink_numberofcells_tag1@@": "The value must be integer, and can be 1 or greater.",
	"@@Shrink_raster_tag0@@": "The input raster for which the identified zones are to be shrunk.",
	"@@Shrink_raster_tag1@@": "It must be of integer type.",
	"@@Shrink_zonevalues_tag0@@": "The list of zones to shrink.",
	"@@Shrink_zonevalues_tag1@@": "The zone values must be integer, and they can be in any order.",
	"@@Shrink_zonevalues_tag2@@": "To specify multiple zones, use a space to separate the zone values.",
	"@@Distance-Accumulation_costraster_tag0@@": "A raster defining the cost or impedance to move planimetrically through each cell. The value at each cell location represents the cost-per-unit distance for moving through it. Each cell location value is multiplied by the cell resolution, and also compensates for diagonal movement to obtain the total cost of passing through the cell.",
	"@@Distance-Accumulation_costraster_tag1@@": "The values of the <strong>Cost Raster</strong> can be integer or floating point, but they cannot be negative or zero.",
	"@@Distance-Accumulation_distancemethod_tag0@@": "Determines whether to calculate the distance using a planar (flat earth) or a geodesic (ellipsoid) method.",
	"@@Distance-Accumulation_distancemethod_tag1@@": "Planar--Planar measurements use 2D Cartesian mathematics to calculate length and area. The option is only available when measuring in a projected coordinate system and the 2D plane of that coordinate system will be used as the basis for the measurements.",
	"@@Distance-Accumulation_distancemethod_tag2@@": "Geodesic--The shortest line between two points on the earth's surface on a spheroid (ellipsoid). Therefore, regardless of input or output projection, the results do not change.",
	"@@Distance-Accumulation_distancemethod_tag3@@": "<strong>Note:</strong> one use for a geodesic line is when you want to determine the shortest distance between two cities for an airplane's flight path. This is also known as a great circle line if based on a sphere rather than an ellipsoid.",
	"@@Distance-Accumulation_generatebackdirectionbandasadditionalbandinoutput_tag0@@": "Determines whether only the distance accumulation raster is created or a multiband raster consisting of both the distance accumulation raster and the back direction raster is created.",
	"@@Distance-Accumulation_generatebackdirectionbandasadditionalbandinoutput_tag1@@": "Unchecked--The result is the distance accumulation raster. This is a single-band result. This is the default.",
	"@@Distance-Accumulation_generatebackdirectionbandasadditionalbandinoutput_tag2@@": "Checked--A multiband result is created. The first band is the distance accumulation raster and the second band is the back direction raster.",
	"@@Distance-Accumulation_generatebackdirectionbandasadditionalbandinoutput_tag3@@": "The back direction raster calculates, for each cell, the direction, in degrees, to the neighboring cell along the shortest path back to the closest source while avoiding barriers.",
	"@@Distance-Accumulation_horizontalfactor_tag0@@": "<p>Defines the relationship between the horizontal cost factor and the horizontal relative moving angle (HRMA).</p><p>There are several factors with modifiers that identify a defined vertical factor graph. Additionally, a table can be used to create a custom graph. The graphs are used to identify the vertical factor used in calculating the total cost of moving into a neighboring cell.</p><p>In the explanations below, two acronyms are used: HF and HRMA. HF stands for horizontal factor, which defines the horizontal difficulty encountered when moving from one cell to the next. HRMA stands for horizontal relative moving angle, which identifies the angle between the horizontal direction from a cell and the moving direction.</p><p><strong>Horizontal factor</strong>types include the following:</p><ul><li><strong>Binary</strong>--Indicates that if the HRMA is less than the cut angle, the HF is set to the value associated with the zero factor; otherwise, it is infinity.</li><li><strong>Forward</strong>--Establishes that only forward movement is allowed. The HRMA must be greater than or equal to 0 and less than 90 degrees (0 &lt;= HRMA &lt; 90). If the HRMA is greater than 0 and less than 45 degrees, the HF for the cell is set to the value associated with the zero factor. If the HRMA is greater than or equal to 45 degrees, the side value modifier value is used. The HF for any HRMA value equal to or greater than 90 degrees is set to infinity.</li><li><strong>Linear</strong>--Specifies that the HF is a linear function of the HRMA.</li><li><strong>Inverse Linear</strong>--Specifies that the HF is an inverse linear function of the HRMA.</li><li><strong>Table</strong>--Identifies that a table file will be used to define the horizontal factor graph used to determine the HFs.</li></ul><p>Modifiers to the horizontal factors include the following:</p><ul><li><strong>Zero factor</strong>--The horizontal factor to be used when the HRMA is zero. This factor positions the y-intercept for any of the horizontal factor functions.</li><li><strong>Cut angle</strong>--Defines the HRMA angle beyond which the HF will be set to infinity.</li><li><strong>Slope</strong>--Establishes the slope of the straight line used with the<strong>Linear</strong>and<strong>Inverse Linear</strong>horizontal factor keywords. The slope is specified as a fraction of rise over run (for example, 45 percent slope is 1/45, which is input as 0.02222).</li><li><strong>Side value</strong>--Establishes the HF when the HRMA is greater than or equal to 45 degrees and less than 90 degrees when the<strong>Forward</strong>horizontal factor keyword is specified.</li><li><strong>Table name</strong>--Identifies the name of the table defining the HF.</li></ul>",
	"@@Distance-Accumulation_horizontalraster_tag0@@": "A raster defining the horizontal direction at each cell.",
	"@@Distance-Accumulation_horizontalraster_tag1@@": "The values on the raster must be integers ranging from 0 to 360, with 0 degrees being north, or toward the top of the screen, and increasing clockwise. Flat areas should be given a value of -1. The values at each location will be used in conjunction with the <strong>Horizontal factor</strong> to determine the horizontal cost incurred when moving from a cell to its neighbors.",
	"@@Distance-Accumulation_initialaccumulation_tag0@@": "The initial accumulative cost to begin the cost calculation. This parameter allows for the specification of the fixed cost associated with a source. Instead of starting at a cost of 0, the cost algorithm will begin with the value specified.",
	"@@Distance-Accumulation_initialaccumulation_tag1@@": "A numeric (double) value or a field from the <strong>Source Raster</strong> can be used for this parameter.",
	"@@Distance-Accumulation_initialaccumulation_tag2@@": "The value must be zero or greater. The default is 0.",
	"@@Distance-Accumulation_maximumaccumulation_tag0@@": "Defines the maximum accumulative cost for the traveler for a source. The cost calculations continue for each source until the specified capacity is reached.",
	"@@Distance-Accumulation_maximumaccumulation_tag1@@": "A numeric (double) value or a field from the <strong>Source Raster</strong> can be used for this parameter.",
	"@@Distance-Accumulation_maximumaccumulation_tag2@@": "The value must be greater than zero. The default capacity is to the edge of the output raster.",
	"@@Distance-Accumulation_multipliertoapplytocosts_tag0@@": "A multiplier to apply to the cost values.",
	"@@Distance-Accumulation_multipliertoapplytocosts_tag1@@": "This parameter allows for control of the mode of travel or the magnitude at a source. The greater the multiplier, the greater the cost to move through each cell.",
	"@@Distance-Accumulation_multipliertoapplytocosts_tag2@@": "A numeric (double) value or a field from the <strong>Source Raster</strong> can be used for this parameter.",
	"@@Distance-Accumulation_multipliertoapplytocosts_tag3@@": "The values must be greater than zero. The default is 1.",
	"@@Distance-Accumulation_rasterbarriers_tag0@@": "The raster that defines the barriers.",
	"@@Distance-Accumulation_rasterbarriers_tag1@@": "The dataset must contain NoData where there are no barriers. Barriers are represented by valid values including zero.",
	"@@Distance-Accumulation_rasterbarriers_tag2@@": "The barriers can be defined by an integer or a floating-point raster.",
	"@@Distance-Accumulation_sourceraster_tag0@@": "The input source locations.",
	"@@Distance-Accumulation_sourceraster_tag1@@": "This is a raster dataset that identifies the cells or locations from which the least accumulated cost distance for every output cell location is calculated.",
	"@@Distance-Accumulation_sourceraster_tag2@@": "It can be an integer or a floating-point type.",
	"@@Distance-Accumulation_surfaceraster_tag0@@": "A raster defining the elevation values at each cell location.",
	"@@Distance-Accumulation_surfaceraster_tag1@@": "The values are used to calculate the actual surface distance covered when passing between cells.",
	"@@Distance-Accumulation_traveldirection_tag0@@": "Defines the direction of the traveler when applying vertical factor, horizontal factor and the source resistance rate.",
	"@@Distance-Accumulation_traveldirection_tag1@@": "<strong>From Source</strong>--The vertical factor, horizontal factor and source resistance rate will be applied beginning at the input source and moving out to the non-source cells. This is the default.",
	"@@Distance-Accumulation_traveldirection_tag2@@": "<strong>To Source</strong>--The vertical factor, horizontal factor and source resistance rate will be applied beginning at each non-source cell and moving back to the input source.",
	"@@Distance-Accumulation_traveldirection_tag3@@": "Either specify the <strong>From Source</strong> or <strong>To Source</strong> keyword, which will be applied to all sources, or specify a field in the <strong>Source Raster</strong> that contains the keywords to identify the direction of travel for each source. That field must contain the string ${FROM_SOURCE} or ${TO_SOURCE}.",
	"@@Distance-Accumulation_verticalfactor_tag0@@": "<p>Defines the relationship between the vertical cost factor and the vertical relative moving angle (VRMA).</p><p>There are several factors with modifiers that identify a defined vertical factor graph. Additionally, a table can be used to create a custom graph. The graphs are used to identify the vertical factor used in calculating the total cost of moving into a neighboring cell.</p><p>In the explanations below, two acronyms are used: VF and VRMA. VF stands for vertical factor, which defines the vertical difficulty encountered in moving from one cell to the next. VRMA stands for vertical relative moving angle, which identifies the slope angle between the FROM, or processing, cell and the TO cell.</p><p><strong>Vertical factor</strong>types include the following:</p><ul><li><strong>Binary</strong>--Specifies that if the VRMA is greater than the low-cut angle and less than the high-cut angle, the VF is set to the value associated with the zero factor; otherwise, it is infinity.</li><li><strong>Linear</strong>--Indicates that the VF is a linear function of the VRMA.</li><li><strong>Symmetric Linear</strong>--Specifies that the VF is a linear function of the VRMA in either the negative or positive side of the VRMA, respectively, and the two linear functions are symmetrical with respect to the VF (y) axis.</li><li><strong>Inverse Linear</strong>--Indicates that the VF is an inverse linear function of the VRMA.</li><li><strong>Symmetric Inverse Linear</strong>--Specifies that the VF is an inverse linear function of the VRMA in either the negative or positive side of the VRMA, respectively, and the two linear functions are symmetrical with respect to the VF (y) axis.</li><li><strong>Cos</strong>--Identifies the VF as the cosine-based function of the VRMA.</li><li><strong>Sec</strong>--Identifies the VF as the secant-based function of the VRMA.</li><li><strong>Cos-Sec</strong>--Specifies that the VF is the cosine-based function of the VRMA when the VRMA is negative and the secant-based function of the VRMA when the VRMA is not negative.</li><li><strong>Sec-Cos</strong>--Specifies that the VF is the secant-based function of the VRMA when the VRMA is negative and the cosine-based function of the VRMA when the VRMA is not negative.</li><li><strong>Table</strong>--Identifies that a table file will be used to define the vertical-factor graph that is used to determine the VFs.</li></ul><p>Modifiers to the vertical keywords include the following:</p><ul><li><strong>Zero factor</strong>--Establishes the vertical factor used when the VRMA is zero. This factor positions the y-intercept of the specified function. By definition, the zero factor is not applicable to any of the trigonometric vertical functions (COS, SEC, COS-SEC, or SEC-COS). The y-intercept is defined by these functions.</li><li><strong>Low Cut angle</strong>--Defines the VRMA angle below which the VF will be set to infinity.</li><li><strong>High Cut angle</strong>--Defines the VRMA angle above which the VF will be set to infinity.</li><li><strong>Slope</strong>--Establishes the slope of the straight line used with the<strong>Linear</strong>and<strong>Inverse Linear</strong>vertical-factor keywords. The slope is specified as a fraction of rise over run (for example, 45 percent slope is 1/45, which is input as 0.02222).</li><li><strong>Table name</strong>--Identifies the name of the table defining the VF.</li></ul>",
	"@@Distance-Accumulation_verticalraster_tag0@@": "Defines the relationship between the vertical cost factor and the vertical relative moving angle (VRMA).",
	"@@Distance-Accumulation_verticalraster_tag1@@": "The values are used for calculating the slope used to identify the vertical factor incurred when moving from one cell to another.",
	"@@Distance-Allocation_costraster_tag0@@": "A raster defining the cost or impedance to move planimetrically through each cell. The value at each cell location represents the cost-per-unit distance for moving through it. Each cell location value is multiplied by the cell resolution, and also compensates for diagonal movement to obtain the total cost of passing through the cell.",
	"@@Distance-Allocation_costraster_tag1@@": "The values of the <strong>Cost Raster</strong> can be integer or floating point, but they cannot be negative or zero.",
	"@@Distance-Allocation_distancemethod_tag0@@": "Determines whether to calculate the distance using a planar (flat earth) or a geodesic (ellipsoid) method.",
	"@@Distance-Allocation_distancemethod_tag1@@": "Planar--Planar measurements use 2D Cartesian mathematics to calculate length and area. The option is only available when measuring in a projected coordinate system and the 2D plane of that coordinate system will be used as the basis for the measurements.",
	"@@Distance-Allocation_distancemethod_tag2@@": "Geodesic--The shortest line between two points on the earth's surface on a spheroid (ellipsoid). Therefore, regardless of input or output projection, the results do not change.",
	"@@Distance-Allocation_distancemethod_tag3@@": "<strong>Note:</strong> one use for a geodesic line is when you want to determine the shortest distance between two cities for an airplane's flight path. This is also known as a great circle line if based on a sphere rather than an ellipsoid.",
	"@@Distance-Allocation_horizontalfactor_tag0@@": "<p>Defines the relationship between the horizontal cost factor and the horizontal relative moving angle (HRMA).</p><p>There are several factors with modifiers that identify a defined vertical factor graph. Additionally, a table can be used to create a custom graph. The graphs are used to identify the vertical factor used in calculating the total cost of moving into a neighboring cell.</p><p>In the explanations below, two acronyms are used: HF and HRMA. HF stands for horizontal factor, which defines the horizontal difficulty encountered when moving from one cell to the next. HRMA stands for horizontal relative moving angle, which identifies the angle between the horizontal direction from a cell and the moving direction.</p><p><strong>Horizontal factor</strong>types include the following:</p><ul><li><strong>Binary</strong>--Indicates that if the HRMA is less than the cut angle, the HF is set to the value associated with the zero factor; otherwise, it is infinity.</li><li><strong>Forward</strong>--Establishes that only forward movement is allowed. The HRMA must be greater than or equal to 0 and less than 90 degrees (0 &lt;= HRMA &lt; 90). If the HRMA is greater than 0 and less than 45 degrees, the HF for the cell is set to the value associated with the zero factor. If the HRMA is greater than or equal to 45 degrees, the side value modifier value is used. The HF for any HRMA value equal to or greater than 90 degrees is set to infinity.</li><li><strong>Linear</strong>--Specifies that the HF is a linear function of the HRMA.</li><li><strong>Inverse Linear</strong>--Specifies that the HF is an inverse linear function of the HRMA.</li><li><strong>Table</strong>--Identifies that a table file will be used to define the horizontal factor graph used to determine the HFs.</li></ul><p>Modifiers to the horizontal factors include the following:</p><ul><li><strong>Zero factor</strong>--The horizontal factor to be used when the HRMA is zero. This factor positions the y-intercept for any of the horizontal factor functions.</li><li><strong>Cut angle</strong>--Defines the HRMA angle beyond which the HF will be set to infinity.</li><li><strong>Slope</strong>--Establishes the slope of the straight line used with the<strong>Linear</strong>and<strong>Inverse Linear</strong>horizontal factor keywords. The slope is specified as a fraction of rise over run (for example, 45 percent slope is 1/45, which is input as 0.02222).</li><li><strong>Side value</strong>--Establishes the HF when the HRMA is greater than or equal to 45 degrees and less than 90 degrees when the<strong>Forward</strong>horizontal factor keyword is specified.</li><li><strong>Table name</strong>--Identifies the name of the table defining the HF.</li></ul>",
	"@@Distance-Allocation_horizontalraster_tag0@@": "A raster defining the horizontal direction at each cell.",
	"@@Distance-Allocation_horizontalraster_tag1@@": "The values on the raster must be integers ranging from 0 to 360, with 0 degrees being north, or toward the top of the screen, and increasing clockwise. Flat areas should be given a value of -1. The values at each location will be used in conjunction with the <strong>Horizontal factor</strong> to determine the horizontal cost incurred when moving from a cell to its neighbors.",
	"@@Distance-Allocation_initialaccumulation_tag0@@": "The initial accumulative cost to begin the cost calculation. This parameter allows for the specification of the fixed cost associated with a source. Instead of starting at a cost of 0, the cost algorithm will begin with the value specified.",
	"@@Distance-Allocation_initialaccumulation_tag1@@": "A numeric (double) value or a field from the <strong>Source Raster</strong> can be used for this parameter.",
	"@@Distance-Allocation_initialaccumulation_tag2@@": "The value must be zero or greater. The default is 0.",
	"@@Distance-Allocation_maximumaccumulation_tag0@@": "Defines the maximum accumulative cost for the traveler for a source. The cost calculations continue for each source until the specified capacity is reached.",
	"@@Distance-Allocation_maximumaccumulation_tag1@@": "A numeric (double) value or a field from the <strong>Source Raster</strong> can be used for this parameter.",
	"@@Distance-Allocation_maximumaccumulation_tag2@@": "The value must be greater than zero. The default capacity is to the edge of the output raster.",
	"@@Distance-Allocation_multipliertoapplytocosts_tag0@@": "A multiplier to apply to the cost values.",
	"@@Distance-Allocation_multipliertoapplytocosts_tag1@@": "This parameter allows for control of the mode of travel or the magnitude at a source. The greater the multiplier, the greater the cost to move through each cell.",
	"@@Distance-Allocation_multipliertoapplytocosts_tag2@@": "The values must be greater than zero. The default is 1.",
	"@@Distance-Allocation_multipliertoapplytocosts_tag3@@": "A numeric (double) value or a field from the <strong>Source Raster</strong> can be used for this parameter.",
	"@@Distance-Allocation_rasterbarriers_tag0@@": "The raster that defines the barriers.",
	"@@Distance-Allocation_rasterbarriers_tag1@@": "The dataset must contain NoData where there are no barriers. Barriers are represented by valid values including zero.",
	"@@Distance-Allocation_rasterbarriers_tag2@@": "The barriers can be defined by an integer or a floating-point raster.",
	"@@Distance-Allocation_sourcefield_tag0@@": "The field used to assign values to the source locations. It must be an integer type.",
	"@@Distance-Allocation_sourceraster_tag0@@": "The input source locations.",
	"@@Distance-Allocation_sourceraster_tag1@@": "This is a raster dataset that identifies the cells or locations from which the least accumulated cost distance for every output cell location is calculated.",
	"@@Distance-Allocation_sourcerowandcolumnbands_tag0@@": "Determines whether only the allocation raster is created or if a multiband result is created.",
	"@@Distance-Allocation_sourcerowandcolumnbands_tag1@@": "Unchecked--The result is the distance allocation raster. This is a single-band result. This is the default.",
	"@@Distance-Allocation_sourcerowandcolumnbands_tag2@@": "Checked--A multiband raster is created. The first band is the distance allocation raster, the second band contains a row index and the third band contains a column index. These indices identify the location of the source cell that is the least accumulated cost distance away.",
	"@@Distance-Allocation_surfaceraster_tag0@@": "A raster defining the elevation values at each cell location.",
	"@@Distance-Allocation_surfaceraster_tag1@@": "The values are used to calculate the actual surface distance covered when passing between cells.",
	"@@Distance-Allocation_traveldirection_tag0@@": "Defines the direction of the traveler when applying vertical factor, horizontal factor and the source resistance rate.",
	"@@Distance-Allocation_traveldirection_tag1@@": "<strong>From Source</strong>--The vertical factor, horizontal factor and source resistance rate will be applied beginning at the input source and moving out to the non-source cells. This is the default.",
	"@@Distance-Allocation_traveldirection_tag2@@": "<strong>To Source</strong>--The vertical factor, horizontal factor and source resistance rate will be applied beginning at each non-source cell and moving back to the input source.",
	"@@Distance-Allocation_traveldirection_tag3@@": "Either specify the <strong>From Source</strong> or <strong>To Source</strong> keyword, which will be applied to all sources, or specify a field in the <strong>Source Raster</strong> that contains the keywords to identify the direction of travel for each source. That field must contain the string ${FROM_SOURCE} or ${TO_SOURCE}.",
	"@@Distance-Allocation_verticalfactor_tag0@@": "<p>Defines the relationship between the vertical cost factor and the vertical relative moving angle (VRMA).</p><p>There are several factors with modifiers that identify a defined vertical factor graph. Additionally, a table can be used to create a custom graph. The graphs are used to identify the vertical factor used in calculating the total cost of moving into a neighboring cell.</p><p>In the explanations below, two acronyms are used: VF and VRMA. VF stands for vertical factor, which defines the vertical difficulty encountered in moving from one cell to the next. VRMA stands for vertical relative moving angle, which identifies the slope angle between the FROM, or processing, cell and the TO cell.</p><p><strong>Vertical factor</strong>types include the following:</p><ul><li><strong>Binary</strong>--Specifies that if the VRMA is greater than the low-cut angle and less than the high-cut angle, the VF is set to the value associated with the zero factor; otherwise, it is infinity.</li><li><strong>Linear</strong>--Indicates that the VF is a linear function of the VRMA.</li><li><strong>Symmetric Linear</strong>--Specifies that the VF is a linear function of the VRMA in either the negative or positive side of the VRMA, respectively, and the two linear functions are symmetrical with respect to the VF (y) axis.</li><li><strong>Inverse Linear</strong>--Indicates that the VF is an inverse linear function of the VRMA.</li><li><strong>Symmetric Inverse Linear</strong>--Specifies that the VF is an inverse linear function of the VRMA in either the negative or positive side of the VRMA, respectively, and the two linear functions are symmetrical with respect to the VF (y) axis.</li><li><strong>Cos</strong>--Identifies the VF as the cosine-based function of the VRMA.</li><li><strong>Sec</strong>--Identifies the VF as the secant-based function of the VRMA.</li><li><strong>Cos-Sec</strong>--Specifies that the VF is the cosine-based function of the VRMA when the VRMA is negative and the secant-based function of the VRMA when the VRMA is not negative.</li><li><strong>Sec-Cos</strong>--Specifies that the VF is the secant-based function of the VRMA when the VRMA is negative and the cosine-based function of the VRMA when the VRMA is not negative.</li><li><strong>Table</strong>--Identifies that a table file will be used to define the vertical-factor graph that is used to determine the VFs.</li></ul><p>Modifiers to the vertical keywords include the following:</p><ul><li><strong>Zero factor</strong>--Establishes the vertical factor used when the VRMA is zero. This factor positions the y-intercept of the specified function. By definition, the zero factor is not applicable to any of the trigonometric vertical functions (COS, SEC, COS-SEC, or SEC-COS). The y-intercept is defined by these functions.</li><li><strong>Low Cut angle</strong>--Defines the VRMA angle below which the VF will be set to infinity.</li><li><strong>High Cut angle</strong>--Defines the VRMA angle above which the VF will be set to infinity.</li><li><strong>Slope</strong>--Establishes the slope of the straight line used with the<strong>Linear</strong>and<strong>Inverse Linear</strong>vertical-factor keywords. The slope is specified as a fraction of rise over run (for example, 45 percent slope is 1/45, which is input as 0.02222).</li><li><strong>Table name</strong>--Identifies the name of the table defining the VF.</li></ul>",
	"@@Distance-Allocation_verticalraster_tag0@@": "Defines the relationship between the vertical cost factor and the vertical relative moving angle (VRMA).",
	"@@Distance-Allocation_verticalraster_tag1@@": "The values are used for calculating the slope used to identify the vertical factor incurred when moving from one cell to another.",
	"@@Euclidean-Back-Direction_cellsize_tag0@@": "The cell size at which the output raster will be created.",
	"@@Euclidean-Back-Direction_cellsize_tag1@@": "If the cell size was explicitly set in <strong>Environments</strong>, that will be the default cell size. If it was not set, the output cell size will be the same as the <strong>Source Raster</strong>.",
	"@@Euclidean-Back-Direction_distancemethod_tag0@@": "Determines whether to calculate the distance using a planar (flat earth) or a geodesic (ellipsoid) method.",
	"@@Euclidean-Back-Direction_distancemethod_tag1@@": "Planar--Planar measurements use 2D Cartesian mathematics to calculate length and area. The option is only available when measuring in a projected coordinate system and the 2D plane of that coordinate system will be used as the basis for the measurements.",
	"@@Euclidean-Back-Direction_distancemethod_tag2@@": "Geodesic--The shortest line between two points on the earth's surface on a spheroid (ellipsoid). Therefore, regardless of input or output projection, the results do not change.",
	"@@Euclidean-Back-Direction_distancemethod_tag3@@": "<strong>Note:</strong> one use for a geodesic line is when you want to determine the shortest distance between two cities for an airplane's flight path. This is also known as a great circle line if based on a sphere rather than an ellipsoid.",
	"@@Euclidean-Back-Direction_maximumdistance_tag0@@": "Defines the threshold distance within which the direction to the closest source will be calculated. If the distance to the nearest source exceeds this, the output for that cell will be NoData.",
	"@@Euclidean-Back-Direction_maximumdistance_tag1@@": "The default distance is to the extent of the output raster.",
	"@@Euclidean-Back-Direction_rasterbarriers_tag0@@": "The raster that defines the barriers.",
	"@@Euclidean-Back-Direction_rasterbarriers_tag1@@": "The dataset must contain NoData where there are no barriers. Barriers are represented by valid values including zero.",
	"@@Euclidean-Back-Direction_rasterbarriers_tag2@@": "The barriers can be defined by an integer or a floating-point raster.",
	"@@Euclidean-Back-Direction_sourceraster_tag0@@": "A raster dataset that identifies the cells or locations to which the Euclidean direction for every output cell location is calculated.",
	"@@Euclidean-Back-Direction_sourceraster_tag1@@": "The input type can be an integer or a floating-point type.",
	"@@Cost-Path_costbacklinkraster_tag0@@": "The name of a cost backlink raster layer used to determine the path to return to a source via the least-cost path.",
	"@@Cost-Path_costbacklinkraster_tag1@@": "For each cell in the backlink raster, a value identifies the neighbor that's the next cell on the least accumulative cost path from the cell to a single source cell or set of source cells.",
	"@@Cost-Path_costdistanceraster_tag0@@": "The name of a cost distance raster to be used to determine the least-cost path from the destination locations to a source.",
	"@@Cost-Path_costdistanceraster_tag1@@": "The cost distance raster is usually created with the Cost Distance, Cost Allocation, or Cost Back Link function. The cost distance raster layer stores, for each cell, the minimum accumulative cost distance over a cost surface from each cell to a set of source cells.",
	"@@Cost-Path_destinationfield_tag0@@": "The field used to obtain values for the destination locations. Input feature data must contain at least one valid field.",
	"@@Cost-Path_destinationraster_tag0@@": "A raster dataset layer that identifies those cells from which the least-cost path is determined to the least costly source.",
	"@@Cost-Path_destinationraster_tag1@@": "The input raster layer consists of cells that have valid values (zero is a valid value), and the remaining cells must be assigned NoData.",
	"@@Cost-Path_forceflowdirectionconventionforbacklinkraster_tag0@@": "Forces the function to treat the input backlink raster as a flow direction raster. Flow direction rasters can have integer with values from 0-255.",
	"@@Cost-Path_forceflowdirectionconventionforbacklinkraster_tag1@@": "Unchecked--If the values of the of the specified backlink raster are integers in the range of 0-8, the dataset will be treated as a cost backlink raster. If the values are from 0-255, the input will be treated as a flow direction raster. If the values are from 0-360 and floating point, the input will be treated as a back direction raster.",
	"@@Cost-Path_forceflowdirectionconventionforbacklinkraster_tag2@@": "Checked--The raster supplied for the backlink raster will be treated as a flow direction raster. Use this option of the flow direction raster happens to have a maximum value of 8 or less.",
	"@@Cost-Path_pathtype_tag0@@": "A keyword defining the manner in which the values and zones on the input destination data will be interpreted in the cost path calculations. The options are as follows:",
	"@@Cost-Path_pathtype_tag1@@": "<strong>Each Cell</strong>--For each cell with valid values on the input destination data, a least-cost path is determined and saved on the output raster. With this option, each cell of the input destination data is treated separately, and a least-cost path is determined for each cell.",
	"@@Cost-Path_pathtype_tag2@@": "<strong>Each Zone</strong>--For each zone on the input destination data, a least-cost path is determined and saved on the output raster. With this option, the least-cost path for each zone begins at the cell with the lowest cost distance weighting in the zone.",
	"@@Cost-Path_pathtype_tag3@@": "<strong>Best Single</strong>--For all cells on the input destination data, the least-cost path is derived from the cell with the minimum of the least-cost paths to source cells.",
	"@@Cell-Statistics_cellsizetype_tag0@@": "Choose which cell size to use in the output raster. If all the input cell sizes are the same, all the options will yield the same results.",
	"@@Cell-Statistics_cellsizetype_tag1@@": "First Of--Use the first cell size of the input rasters.",
	"@@Cell-Statistics_cellsizetype_tag2@@": "Min Of--Use the smallest cell size of all the input rasters.",
	"@@Cell-Statistics_cellsizetype_tag3@@": "Max Of--Use the largest cell size of all the input rasters. This is the default.",
	"@@Cell-Statistics_cellsizetype_tag4@@": "Mean Of--Use the mean cell size of all the input rasters.",
	"@@Cell-Statistics_cellsizetype_tag5@@": "Last Of--Use the last cell size of the input rasters.",
	"@@Cell-Statistics_extenttype_tag0@@": "Choose which extent should be used in the output raster:",
	"@@Cell-Statistics_extenttype_tag1@@": "First Of--Use the extent of the first input raster to determine the processing extent.",
	"@@Cell-Statistics_extenttype_tag2@@": "Intersection Of--Use the extent of the overlapping pixels to determine the processing extent. This is the default.",
	"@@Cell-Statistics_extenttype_tag3@@": "Union Of--Use the extent of all the rasters to determine the processing extent.",
	"@@Cell-Statistics_extenttype_tag4@@": "Last Of--Use the extent of the last input raster to determine the processing extent.",
	"@@Cell-Statistics_processasmultiband_tag0@@": "Determines how the input rasters bands are processed.",
	"@@Cell-Statistics_processasmultiband_tag1@@": "Unchecked--All multiband inputs will be processed as single bands. This is the default.",
	"@@Cell-Statistics_processasmultiband_tag2@@": "Checked--All multiband inputs will be processed as multiband.",
	"@@Cell-Statistics_rasters_tag0@@": "The list of rasters from which to calculate statistics, on a pixel-by-pixel basis.",
	"@@Cell-Statistics_percentileinterpolationtype_tag0@@": "<p>Specifies the method of interpolation to be used when the specified percentile value lies between two input cell values.</p><ul><li><strong>Auto-detect</strong>--If the input rasters are of integer pixel type, the<strong>Nearest</strong>method is used. If the input raster is of floating point pixel type, then the<strong>Linear</strong>method is used. This is the default.</li><li><strong>Nearest</strong>--The nearest available value to the desired percentile is used. In this case, the output pixel type is the same as that of the input value rasters.</li><li><strong>Linear</strong>--The weighted average of the two surrounding values from the desired percentile is used. In this case, the output pixel type is floating point.</li></ul><p>This option is only available if the<strong>Operation</strong>type parameter is set to<strong>Median</strong>or<strong>Percentile</strong>.</p>",
	"@@Cell-Statistics_percentilevalue_tag0@@": "<p>The percentile to calculate. The default is 90, for the 90th percentile.</p><p>The values can range from 0 through 100. The 0th percentile is essentially equivalent to the minimum statistic, and the 100th percentile is equivalent to maximum. A value of 50 will produce essentially the same result as the median statistic.</p><p>This option is only available if the<strong>Operation</strong>parameter is set to<strong>Percentile</strong>.</p>",
	"@@Optimal-Path-As-Raster_backdirectionrasterorflowdirectionraster_tag0@@": "The back direction raster contains calculated directions in degrees. The direction identifies the next cell along the optimal path back to the least accumulative cost source while avoiding barriers.",
	"@@Optimal-Path-As-Raster_backdirectionrasterorflowdirectionraster_tag1@@": "The range of values is from 0 degrees to 360 degrees, with 0 reserved for the source cells. Due east (right) is 90, and the values increase clockwise (180 is south, 270 is west, and 360 is north).",
	"@@Optimal-Path-As-Raster_destinationfield_tag0@@": "The field used to obtain values for the destination locations.",
	"@@Optimal-Path-As-Raster_destinationraster_tag0@@": "A raster dataset layer that identifies those cells from which the optimum path is determined to the least costly source. This input is required.",
	"@@Optimal-Path-As-Raster_destinationraster_tag1@@": "The input raster layer consists of cells that have valid values (zero is a valid value), and the remaining cells must be assigned NoData.",
	"@@Optimal-Path-As-Raster_distanceaccumulationraster_tag0@@": "The distance accumulation raster is used to determine the optimal path from the destinations to the sources. The distance accumulation raster is usuallycreated with the <strong>Distance Accumulation</strong> function. Each cell in the distance accumulationraster represents the minimum accumulative cost distance over asurface from each cell to a set of source cells.",
	"@@Optimal-Path-As-Raster_pathtype_tag0@@": "Specifies a keyword defining the manner in which the values and zones on the input destination data will be interpreted in the cost path calculations.",
	"@@Optimal-Path-As-Raster_pathtype_tag1@@": "<strong>Each Zone</strong>--For each zone on the input destination data, a least-cost path is determined and saved on the output raster. With this option, the optimal path for each zone begins at the cell with the lowest cost distance weighting in the zone.",
	"@@Optimal-Path-As-Raster_pathtype_tag2@@": "<strong>Best Single</strong>--For all cells on the input destination data, the optimal path is derived from the cell with the minimum of the least-cost paths to source cells.",
	"@@Optimal-Path-As-Raster_pathtype_tag3@@": "<strong>Each Cell</strong>--For each cell with valid values on the input destination data, an optimal path is determined. With this option, each cell of the input destination data is treated separately, and an optimal path is determined for each cell.",
	"@@CCDC-Analysis_bandsfordetectingchange_tag0@@": "The band IDs to use for change detection. If no band IDs are provided, all the bands from the input raster dataset will be used.",
	"@@CCDC-Analysis_bandsfordetectingchange_tag1@@": "The ID values should be integers separated by spaces.",
	"@@CCDC-Analysis_bandsfortemporalmasking_tag0@@": "The band IDs of the green band and the SWIR band, to be used to mask for cloud, cloud shadow and snow. If no band IDs are provided, masking will not occur.",
	"@@CCDC-Analysis_bandsfortemporalmasking_tag1@@": "The ID values should be integers separated by spaces.",
	"@@CCDC-Analysis_bandsfortemporalmasking_tag2@@": "This parameter specifies the bands to use for cloud, cloud shadow, and snow masking. Because cloud shadow and snow show up very dark in the shortwave infrared (SWIR) band, and clouds and snow are very bright in the green band, it is recommended that the band indexes for the SWIR and green bands are masked.",
	"@@CCDC-Analysis_chi-squaredthresholdfordetectchange_tag0@@": "The chi-square change probability threshold. If an observation has a calculated change probability that is above this threshold, it is flagged as an anomaly, which is a potential change event. The default value is 0.99.",
	"@@CCDC-Analysis_minimumconsecutiveanomalyobservations_tag0@@": "The minimum number of consecutive anomaly observations that must occur before an event is considered a change. A pixel must be flagged as an anomaly for the specified number of consecutive time slices before it is considered a true change. The default is 6.",
	"@@CCDC-Analysis_raster_tag0@@": "The input multidimensional raster layer.",
	"@@CCDC-Analysis_updatingfittingfrequency(inyears)_tag0@@": "The frequency at which to update the time series model with new observations. The default is to update the model every 1 year.",
	"@@CCDC-Analysis_updatingfittingfrequency(inyears)_tag1@@": "This parameter defines how often the time series model will be updated with new observations. Updating a model frequently can be computationally costly and the benefit can be minimal. For example, if there are 365 slices or clear observations per year in the multidimensional raster, and the updating frequency is for every observation, the processing will be 365 times more computationally expensive compared to updating once per year, but the accuracy may not be higher.",
	"@@Trend-To-RGB_modeltype_tag0@@": "The type of model information to convert to RGB.",
	"@@Trend-To-RGB_modeltype_tag1@@": "Linear--Linear trend information will be converted to RGB. This is the default.",
	"@@Trend-To-RGB_modeltype_tag2@@": "Harmonic--Harmonic trend information will be converted to RGB.",
	"@@Trend-To-RGB_raster_tag0@@": "The input trend raster.",
	"@@LandTrendr-Analysis_bestmodelproportion_tag0@@": "<p>The best model proportion value. During the model selection process, the tool will calculate the p-value for each model and select a model that has the most vertices while maintaining the smallest (most significant) p-value based on this proportion value. A value of 1 means the model has the lowest p-value but may not have a high number of vertices. The default is 1.25.</p>",
	"@@LandTrendr-Analysis_maximumnumberofsegments_tag0@@": "<p>The maximum number of segments to be fitted to the time series for each pixel. The default is 5.</p>",
	"@@LandTrendr-Analysis_minimumnumberofobservations_tag0@@": "<p>The minimum number of valid observations required to perform fitting. The number of years in the input multidimensional dataset must be equal to or greater than this value. The default is 6.</p>",
	"@@LandTrendr-Analysis_outputotherbands_tag0@@": "<p>Specifies whether other bands will be included in the results.</p><ul><li>Checked--Other bands will be included in the results. The segmentation and vertices information from the initial segmentation band specified in the<strong>Processing Band</strong>parameter will also be fitted to the remaining bands in the multiband images. The model results will include the segmentation band first, then the remaining bands.</li><li>Unchecked--Other bands will not be included. This is the default.</li></ul>",
	"@@LandTrendr-Analysis_preventoneyearrecovery_tag0@@": "<p>Specifies whether segments that exhibit a one year recovery will be excluded.</p><ul><li>Checked--Segments that exhibit a one year recovery will be excluded. This is the default.</li><li>Unchecked--Segments that exhibit a one year recovery will be not be excluded.</li></ul>",
	"@@LandTrendr-Analysis_processingband_tag0@@": "<p>The band to use for segmenting the pixel value trajectories over time. Choose the band that will best capture the changes in the feature you want to observe.</p>",
	"@@LandTrendr-Analysis_p-valuethreshold_tag0@@": "<p>The p-value thresholdfor a model to be selected. After the vertices are detected in the initial stage of the model fitting, the tool will fit each segment and calculate the p-value to determine the significance of the model. On the next iteration, the model will decrease the number of segments by one and recalculate the p-value. This will continue and, if the p-value is smaller than the value specified in this parameter, the model will be selected and the tool will stop searching for a better model. If no such model is selected, the tool will select a model with a p-value smaller than the<strong>lowest p-value  best model proportion value</strong>. The default is 0.01.</p>",
	"@@LandTrendr-Analysis_raster_tag0@@": "<p>The input Landsat multidimensional raster layer.</p>",
	"@@LandTrendr-Analysis_recoveryhasincreasetrend_tag0@@": "<p>Specifies whether the recovery has an increasing (positive) trend.</p><ul><li>Checked--The recovery has an increasing trend. This is the default.</li><li>Unchecked--The recovery has a decreasing trend.</li></ul>",
	"@@LandTrendr-Analysis_recoverythreshold_tag0@@": "<p>The recovery threshold value, in years. If a segment has a recovery rate that is faster than<strong>1/recovery threshold</strong>, the segment is discarded and not included in the time series model. The value must range between 0 and 1. The default is 0.25.</p>",
	"@@LandTrendr-Analysis_snappingdate_tag0@@": "<p>The date used to select a slice for each year in the input multidimensional dataset. The slice with the date closest to the snapping date will be selected. This parameter is required if the input dataset contains sub-yearly data.</p>",
	"@@LandTrendr-Analysis_spikethreshold_tag0@@": "<p>The threshold to use for dampening spikes or anomalies in the pixel value trajectory. The value must range between 0 and 1, where 1 means no dampening. The default is 0.9.</p>",
	"@@LandTrendr-Analysis_vertexcountovershoot_tag0@@": "<p>The number of additional vertices beyond<strong>max_num_segments + 1</strong>that can be used to fit the model during the initial stage of identifying vertices. Later in the modeling process, the number of additional vertices will be reduced to<strong>max_num_segments + 1</strong>. The default is 2.</p>",
	"@@Merge-Rasters_rasters_tag0@@": "<p>The input raster datasets or multidimensional raster datasets to merge.</p>",
	"@@Merge-Rasters_resolveoverlapmethod_tag0@@": "<p>Specifies the method to use to resolve overlapping pixels in the combined datasets.</p><ul><li><strong>First</strong>--The pixel value in the overlapping areas is the value from the first raster in the list of input rasters. This is the default.</li><li><strong>Last</strong>--The pixel value in the overlapping areas is the value from the last raster in the list of input rasters.</li><li><strong>Min</strong>--The pixel value in the overlapping areas is the minimum value of the overlapping pixels.</li><li><strong>Max</strong>--The pixel value in the overlapping areas is the maximum value of the overlapping pixels.</li><li><strong>Mean</strong>--The pixel value in the overlapping areas is the average of the overlapping pixels.</li><li><strong>Sum</strong>--The pixel value in the overlapping areas is the total sum of the overlapping pixels.</li></ul>",
	"@@Generate-Trend_cycleunit_tag0@@": "<p>Specifies the time unit to be used for the length of a harmonic cycle.</p><ul><li><strong>Days</strong>--The unit for the length of the harmonic cycle is days.</li><li><strong>Years</strong>--The unit for the length of the harmonic cycle is years. This is the default.</li></ul>",
	"@@Generate-Trend_dimensionname_tag0@@": "<p>The dimension along which a trend will be extracted for the variable or variables selected in the analysis.</p>",
	"@@Generate-Trend_harmonicfrequency_tag0@@": "<p>The frequency number to use in the trend fitting. This parameter specifies the frequency of cycles in a year. The default value is 1, or one harmonic cycle per year.</p><p>This parameter is only included in the trend analysis for a harmonic regression.</p>",
	"@@Generate-Trend_ignorenodata_tag0@@": "<p>Specifies whether NoData values are ignored in the analysis.</p><ul><li>Checked--The analysis will include all valid pixels along a given dimension and ignore any NoData pixels. This is the default.</li><li>Unchecked--The analysis will result in NoData if there are any NoData values for the pixels along the given dimension.</li></ul>",
	"@@Generate-Trend_lengthofcycle_tag0@@": "<p>The length of periodic variation to model. The unit is days, regardless of the time unit of the input data. For example, leaf greenness often has one strong cycle of variation in a single year, so the cycle length is 365.25, even if the input data is monthly greenness. Hourly temperature data has one strong cycle of variation throughout a single day, so the cycle length is 1.</p><p>The default length is 365.25 days for data that varies on an annual cycle.</p>",
	"@@Generate-Trend_p-valueofslopecoefficient_tag0@@": "<p>Specifies whether to calculate the p-value statistic for the slope coefficient of the trend line.</p><ul><li>Checked--The p-value will be calculated and displayed in the details when the function completes.</li><li>Unchecked--The p-value will not be calculated. This is the default.</li></ul>",
	"@@Generate-Trend_polynomialorder_tag0@@": "<p>The polynomial order number to use in the trend fitting. This parameter specifies the polynomial order. The default value is 2, or second-order polynomial.</p><p>This parameter is only included in the trend analysis for a polynomial regression.</p>",
	"@@Generate-Trend_r-squared_tag0@@": "<p>Specifies whether to calculate the R-squared goodness-of-fit statistic for the trend fit line.</p><ul><li>Checked--The R-squared will be calculated and displayed in the details when the function is completed.</li><li>Unchecked--The R-squared will not be calculated. This is the default.</li></ul>",
	"@@Generate-Trend_raster_tag0@@": "<p>The input multidimensional raster.</p>",
	"@@Generate-Trend_rmse_tag0@@": "<p>Specifies whether to generate the root mean square error (RMSE) of the trend fit line.</p><ul><li>Checked--The RMSE will be calculated and displayed in the details when the function is completed. This is the default.</li><li>Unchecked--The RMSE will not be calculated.</li></ul>",
	"@@Generate-Trend_seasonalperiod_tag0@@": "<p>Specifies the time unit to be used for the length of a seasonal period when performing the Seasonal-Kendall test.</p><ul><li>Days--The unit for the length of the seasonal period is days. This is the default.</li><li>Months--The unit for the length of the seasonal period is months.</li></ul>",
	"@@Generate-Trend_trendtype_tag0@@": "<p>Specifies the type of line to be used to fit to the pixel values along a dimension.</p><ul><li><strong>Linear</strong>--Fits the pixel values for a variable along a linear trend line. This is the default.</li><li><strong>Harmonic</strong>--Fits the pixel values for a variable along a harmonic trend line.</li><li><strong>Polynomial</strong>--Fits the pixel values for a variable along a second-order polynomial trend line.</li><li><strong>Mann-Kendall</strong>--Variable pixel values will be evaluated using the Mann-Kendall trend test.</li><li><strong>Seasonal Kendall</strong>--Variable pixel values will be evaluated using the Seasonal-Kendall trend test.</li></ul>",
	"@@Compute-Change_cellsizetype_tag0@@": "<p>Choose which cell size to use in the output raster. If all the input cell sizes are the same, all the options will yield the same results.</p><ul><li>First Of--Use the first cell size of the input rasters.</li><li>Min Of--Use the smallest cell size of all the input rasters.</li><li>Max Of--Use the largest cell size of all the input rasters. This is the default.</li><li>Mean Of--Use the mean cell size of all the input rasters.</li><li>Last Of--Use the last cell size of the input rasters.</li></ul>",
	"@@Compute-Change_computechangemethod_tag0@@": "<p>The method used for computation.</p><ul><li><strong>Difference</strong>--The mathematical difference, or subtraction, between the pixel values in the input rasters will be calculated. This is the default.</li><li><strong>Relative Difference</strong>--The difference in pixel values, accounting for the magnitudes of the values being compared, will be calculated.</li><li><strong>Categorical Difference</strong>--The difference between two categorical or thematic rasters will be calculated, where the output contains class transitions that occurred between the two rasters.</li><li><strong>Spectral Euclidean Distance</strong>--The Euclidean distance between the pixel values of two multiband rasters will be calculated.</li><li><strong>Spectral Angle Difference</strong>--The spectral angle between the pixel values of two multiband rasters will be calculated. The output is in radians.</li><li><strong>Band With Most Change</strong>--The band that accounts for the most change in each pixel between two multiband rasters will be calculated.</li></ul><p>If the<strong>Compute Change Method</strong>is set to<strong>Categorical Difference</strong>and one of the inputs is not categorical, a simple difference will be calculated.</p>",
	"@@Compute-Change_definetransitioncolors_tag0@@": "<p>Specify the method to use for symbolizing the pixels that have changed classes.</p><ul><li><strong>Average From And To Colors</strong>--The color of the pixel will be the average of the color of its original class and the color of its final class.</li><li><strong>Use From Colors</strong>--The color of the pixel will be the color of its original class.</li><li><strong>Use To Colors</strong>--The color of the pixel will be the color of its final class.</li></ul>",
	"@@Compute-Change_extenttype_tag0@@": "<p>Choose which extent should be used in the output raster:</p><ul><li>First Of--Use the extent of the first input raster to determine the processing extent.</li><li>Intersection Of--Use the extent of the overlapping pixels to determine the processing extent. This is the default.</li><li>Union Of--Use the extent of all the rasters to determine the processing extent.</li><li>Last Of--Use the extent of the last input raster to determine the processing extent.</li></ul>",
	"@@Compute-Change_filtermethod_tag0@@": "<p>Choose the filter method for categorical change computation.</p><ul><li><strong>Keep All</strong>--All classes are included in the output, and no filtering will occur. Choose this option to see change and persistence in a single dataset.</li><li><strong>Keep Changed Pixels Only</strong>--Only the classes that have changed from one class type to another class type are included in the output. Choose this option is you are only interested in change.</li><li><strong>Keep Unchanged Pixels Only</strong>--Only the classes that have not changed are included in the output. Choose this option if you are only interested in persistence.</li></ul>",
	"@@Compute-Change_fromclassvalues_tag0@@": "<p>The class values from the<strong>From Raster</strong>to be included in the computation, if comparing two categorical rasters. This is a space-delimited list of integer values corresponding to the<strong>ClassValue</strong>field in your input raster dataset.</p>",
	"@@Compute-Change_fromraster_tag0@@": "<p>The first raster to be used in the computation. To evaluate change from time 1 (earlier) to time 2 (later), enter the time 1 raster here.</p>",
	"@@Compute-Change_toclassvalues_tag0@@": "<p>The class values from the<strong>To Raster</strong>to be included in the computation, if comparing two categorical rasters. This is a space-delimited list of integer values corresponding to the<strong>ClassValue</strong>field in your input raster dataset.</p>",
	"@@Compute-Change_toraster_tag0@@": "<p>The second raster to be used in the computation. To evaluate change from time 1 (earlier) to time 2 (later), enter the time 2 raster.</p>",
	"@@Compute-Change_usecolormethod_tag0@@": "<p>Specify the method to use for symbolizing the pixels that have changed classes.</p><ul><li><strong>Average From And To Colors</strong>--The color of the pixel will be the average of the color of its original class and the color of its final class.</li><li><strong>Use From Colors</strong>--The color of the pixel will be the color of its original class.</li><li><strong>Use To Colors</strong>--The color of the pixel will be the color of its final class.</li></ul>",
	"@@Compute-Change_fieldnameforclassnamesinfromraster_tag0@@": "<p>A field that stores class names in the<strong>From Raster</strong>input. The tool automatically searches for<strong>ClassName</strong>field or<strong>Class_Name</strong>field to use.</p><p>Use this option if the input does not contain these standard field names.</p>",
	"@@Compute-Change_fieldnameforclassnamesintoraster_tag0@@": "<p>A field that stores class names in the<strong>To Raster</strong>input. The tool will automatically search for<strong>ClassName</strong>field or<strong>Class_Name</strong>field to use.</p><p>Use this option if the input does not contain these standard field names.</p>",
	"@@Statistics_numberofcolumns_tag0@@": "<p>The number of pixel columns to use in a focal neighborhood dimension.</p>",
	"@@Statistics_numberofrows_tag0@@": "<p>The number of pixel rows to use in a focal neighborhood dimension.</p>",
	"@@Statistics_onlyfillnodatapixels_tag0@@": "<p>Fills in NoData gaps in the output. This is useful when your imagery may have dropped lines.</p>",
	"@@Statistics_raster_tag0@@": "<p>The input raster to perform focal statistics on.</p>",
	"@@Statistics_statisticstype_tag0@@": "<p>The following are the seven types of focal statistical functions:</p><ul><li>Minimum--Calculates the minimum value of the pixels within the neighborhood.</li><li>Maximum--Calculates the maximum value of the pixels within the neighborhood.</li><li>Mean--Calculates the average value of the pixels within the neighborhood. This is the default.</li><li>Standard Deviation--Calculates the standard deviation value of the pixels within the neighborhood.</li><li>Median--Calculates the median value of pixels within the neighborhood.</li><li>Majority--Calculates the majority value, or the value that occurs most frequently, of the pixels within the neighborhood.</li><li>Minority--Calculates the minority value, or the value that occurs least frequently, of the pixels within the neighborhood.</li></ul>",
	"@@Detect-Change-Using-Change-Analysis_changedirection_tag0@@": "<p>Specifies the direction of change to be included in the analysis.</p><p>This parameter is available only when the input change analysis raster is the output from the LandTrendr tools.</p><ul><li><strong>All directions</strong>--All change directions are included in the output. This is the default.</li><li><strong>Increasing</strong>--Only change in the positive or increasing direction is included in the output.</li><li><strong>Decreasing</strong>--Only change in the negative or decreasing direction is included in the output.</li></ul>",
	"@@Detect-Change-Using-Change-Analysis_changetype_tag0@@": "<p>Specifies the change information to calculate.</p><ul><li><strong>Time of Latest Change</strong>--Each pixel contains the date of the most recent change for that pixel in the time series. This is the default.</li><li><strong>Time of Earliest Change</strong>--Each pixel contains the date of the earliest change for that pixel in the time series.</li><li><strong>Time of Largest Change</strong>--Each pixel contains the date of the most significant change for that pixel in the time series.</li><li><strong>Number of Changes</strong>--Each pixel contains the total number of times the pixel changed in the time series.</li><li><strong>Time of Longest Change</strong>--Each pixel contains the date of change at the end of the longest transition segment in the time series.</li><li><strong>Time of Shortest Change</strong>--Each pixel contains the date of change at the end of the shortest transition segment in the time series.</li><li><strong>Time of Fastest Change</strong>--Each pixel contains the date of change at the end of the transition that occurred most quickly.</li><li><strong>Time of Slowest Change</strong>--Each pixel contains the date of change at the end of the transition that occurred most slowly.</li></ul>",
	"@@Detect-Change-Using-Change-Analysis_filterbyduration_tag0@@": "<p>Specifies whether to filter by the change duration.</p><p></p><ul><li>Checked--Filter results by duration so that only the changes that lasted a given amount of time are included in the output.</li><li>Unchecked--Do not filter results by duration. This is the default.</li></ul><p>This parameter is available only when the input change analysis raster is the output from the LandTrendr tools.</p><p>If this parameter is checked, you must set the<strong>Minimum Duration</strong>and<strong>Maximum Duration</strong>parameters for filtering.</p>",
	"@@Detect-Change-Using-Change-Analysis_filterbymagnitude_tag0@@": "<p>Specifies whether to filter by change magnitude.</p><ul><li>Checked--Filter results by magnitude so that only the changes of a given magnitude are included in the output.</li><li>Unchecked--Do not filter results by magnitude. This is the default.</li></ul><p>This parameter is available only when the input change analysis raster is the output from the LandTrendr tools.</p><p>If this parameter is checked, you must set the<strong>Minimum Magnitude</strong>and<strong>Maximum Magnitude</strong>parameters for filtering.</p>",
	"@@Detect-Change-Using-Change-Analysis_filterbyyear_tag0@@": "<p>Specifies whether to limit the output by a range of years.</p><ul><li>Checked--Filter results so that only changes that occurred within a specific range of years are included in the output.</li><li>Unchecked--Do not filter results by year. This is the default.</li></ul><p>If this parameter is checked, you must set the<strong>Minimum Value</strong>and<strong>Maximum Value</strong>parameters for filtering.</p>",
	"@@Detect-Change-Using-Change-Analysis_filterbystartvalue_tag0@@": "<p>Filter results by start value so that only the changes of a given start value are included in the output.</p>",
	"@@Detect-Change-Using-Change-Analysis_filterbyendvalue_tag0@@": "<p>Filter results by end value so that only the changes of a given end value are included in the output.</p>",
	"@@Detect-Change-Using-Change-Analysis_maximumnumberofchanges_tag0@@": "<p>The maximum number of changes per pixel to be calculated. The number entered corresponds to the number of bands in the output raster. The default is 1, meaning only one change date is calculated, and the output raster contains only one band.</p><p>This parameter is not available when the<strong>Change Type</strong>parameter is set to<strong>Number of changes</strong>.</p>",
	"@@Detect-Change-Using-Change-Analysis_raster_tag0@@": "<p>The input change analysis raster.</p>",
	"@@Detect-Change-Using-Change-Analysis_segmentdate_tag0@@": "<p>Specifies whether to extract the date at the beginning of a change segment, or the end.</p><p>This parameter is available only when the input change analysis raster is the output from the LandTrendr tools.</p><ul><li><strong>Beginning of segment</strong>--Extract the date at the beginning of a change segment. This is the default.</li><li><strong>End of segment</strong>--Extract the date at the end of a change segment.</li></ul>",
	"@@Kernel-Density_areaunits_tag0@@": "<p>The area units of the output density values.</p><ul><li>Square Map Units--For the square of the linear units of the output spatial reference.</li><li>Square Miles--For (U.S.) miles.</li><li>Square Kilometers--For kilometers.</li><li>Acres--For (U.S.) acres.</li><li>Hectares--For hectares.</li><li>Square Meters--For meters.</li><li>Square Yards--For (U.S.) yards.</li><li>Square Feet--For (U.S.) feet.</li><li>Square Inches--For (U.S.) inches.</li><li>Square Centimeters--For centimeters.</li><li>Square Millimeters--For millimeters.</li></ul>",
	"@@Kernel-Density_cellsize_tag0@@": "<p>The pixel size for the output raster dataset. If the<strong>Cellsize</strong>value has been set in the geoprocessing environments, it is the default.</p>",
	"@@Kernel-Density_inputbarriers_tag0@@": "<p>The dataset that defines the barriers.</p><p>The barriers can be a feature layer of polyline or polygon features.</p>",
	"@@Kernel-Density_inputfeatures_tag0@@": "<p>The input point or line features for which to calculate the density.</p>",
	"@@Kernel-Density_method_tag0@@": "<p>Determines whether to use a shortest path on a spheroid (geodesic) or a flat earth (planar) method.</p><ul><li><strong>Planar</strong>--Uses planar distances between the features. This is the default.</li><li><strong>Geodesic</strong>--Uses geodesic distances between features. This method takes into account the curvature of the spheroid and correctly deals with data near the poles and the international dateline.</li></ul><p>It is recommended that you use the<strong>Geodesic</strong>method with data stored in a coordinate system that is not appropriate for distance measurements and any analysis that spans a large geographic area. For example, Web Mercator or any geographic coordinate system should use the<strong>Geodesic</strong>method.</p>",
	"@@Kernel-Density_outputcellvalues_tag0@@": "<p>Determines what the values in the output raster represent.</p><ul><li><strong>Densities</strong>--The output values represent the predicted density value. This is the default.</li><li><strong>Expected Counts</strong>--The output values represent the predicted amount of the phenomenon within each pixel. Since the pixel value is linked to the specified<strong>Cellsize</strong>value, the resulting raster cannot be resampled to a different pixel size and still represent the amount of the phenomenon.</li></ul>",
	"@@Kernel-Density_populationfield_tag0@@": "<p>Field denoting population values for each feature. The<strong>Population Field</strong>value is the count or quantity to be spread across the landscape to create a continuous surface. Values in the<strong>Population Field</strong>may be integer or floating point.</p><p>The options and default behaviors for the field are listed below in the order of priority.</p><ul><li>Use<strong>None</strong>if no item or special value will be used and each feature will be counted once.</li><li>Use<strong>Shape</strong>if the input features contain Z.</li><li>Otherwise, the default field is<strong>POPULATION</strong>, or any acceptable derivative of population:<ul><li><strong>POPULATIONxxxx</strong>where<strong>xxxx</strong>can be any valid character, such as<strong>POPULATION6</strong>,<strong>POPULATION1974</strong>, or<strong>POPULATIONROADTYPE</strong>.</li><li><strong>POP</strong>.</li><li><strong>POPxxxx</strong>.</li><li>If none of the above apply, the default is<strong>None</strong>.</li></ul></li></ul>",
	"@@Kernel-Density_searchradius_tag0@@": "<p>The search radius within which to calculate density. Units are based on the linear unit of the projection.</p><p>For example, if the units are in meters--to include all features within a one-mile neighborhood--set the search radius equal to 1609.344 (since 1 mile is 1609.344 meters).</p>",
	"@@Zonal-Statistics_ignorenodataincalculations_tag0@@": "<p>Denotes whether<strong>NoData</strong>values in the<strong>Value Raster</strong>will influence the results of the zone that they fall within.</p><ul><li><strong>Yes</strong>--Within any particular zone, only pixels that have a value in the<strong>Value Raster</strong>will be used in determining the output value for that zone.<strong>NoData</strong>pixels in the<strong>Value Raster</strong>will be ignored in the statistic calculation. This is the default.</li><li><strong>No</strong>--Within any particular zone, if any<strong>NoData</strong>pixels exist in the<strong>Value Raster</strong>, it is deemed that there is insufficient information to perform statistical calculations for all the pixels in that zone; therefore, the entire zone will receive the<strong>NoData</strong>value on the output raster.</li></ul>",
	"@@Zonal-Statistics_percentileinterpolationtype_tag0@@": "<p>Determines the method of percentile interpolation to be used when the number of values from the input raster to be calculated are even.</p><ul><li><strong>Auto-detect</strong>--If the input value raster is of integer pixel type, the<strong>Nearest</strong>method is used. If the input value raster is of floating point pixel type, then the<strong>Linear</strong>method is used. This is the default.</li><li><strong>Nearest</strong>--The nearest available value to the desired percentile is used. In this case, the output pixel type is the same as that of the input value raster.</li><li><strong>Linear</strong>--The weighted average of the two surrounding values from the desired percentile is used. In this case, the output pixel type is floating point.</li></ul>",
	"@@Zonal-Statistics_percentilevalue_tag0@@": "<p>The percentile to calculate. The default is 90, for the 90th percentile.</p><p>The values can range from 0 through 100. The 0th percentile is essentially equivalent to the Minimum statistic, and the 100th percentile is equivalent to Maximum. A value of 50 will produce essentially the same result as the Median statistic.</p>",
	"@@Zonal-Statistics_processasmultidimensional_tag0@@": "<p>Determines how the input multidimensional value raster is processed.</p><ul><li><strong>Current Slice</strong>--Statistics will be calculated from the current slice of a multidimensional dataset. This is the default.</li><li><strong>All Slices</strong>--Statistics will be calculated for all dimensions (such as time or depth) of a multidimensional dataset.</li></ul>",
	"@@Zonal-Statistics_statisticstype_tag0@@": "<p>Statistic type to be calculated.</p><ul><li><strong>Mean</strong>--Calculates the average of all pixels in the<strong>Value Raster</strong>that belong to the same zone as the output pixel.</li><li><strong>Majority</strong>--Determines the value that occurs most often of all pixels in the<strong>Value Raster</strong>that belong to the same zone as the output pixel.</li><li><strong>Maximum</strong>--Determines the largest value of all pixels in the<strong>Value Raster</strong>that belong to the same zone as the output pixel.</li><li><strong>Median</strong>--Determines the median value of all pixels in the<strong>Value Raster</strong>that belong to the same zone as the output pixel.</li><li><strong>Minimum</strong>--Determines the smallest value of all pixels in the<strong>Value Raster</strong>that belong to the same zone as the output pixel.</li><li><strong>Minority</strong>--Determines the value that occurs least often of all pixels in the<strong>Value Raster</strong>that belong to the same zone as the output pixel.</li><li><strong>Percentile</strong>--Calculates a percentile of all pixels in the<strong>Value Raster</strong>that belong to the same zone as the output pixel. The 90th percentile is calculated by default. You can determine which percentile to calculate with the<strong>Percentile Value</strong>parameter.</li><li><strong>Range</strong>--Calculates the difference between the largest and smallest value of all pixels in the<strong>Value Raster</strong>that belong to the same zone as the output pixel.</li><li><strong>Standard Deviation</strong>--Calculates the standard deviation of all pixels in the<strong>Value Raster</strong>that belong to the same zone as the output pixel.</li><li><strong>Sum</strong>--Calculates the total value of all pixels in the<strong>Value Raster</strong>that belong to the same zone as the output pixel.</li><li><strong>Variety</strong>--Calculates the number of unique values for all pixels in the<strong>Value Raster</strong>that belong to the same zone as the output pixel.</li></ul>",
	"@@Zonal-Statistics_valueraster_tag0@@": "<p>Raster that contains the values on which to calculate a statistic.</p>",
	"@@Zonal-Statistics_zonefield_tag0@@": "<p>Field that holds the values that define each zone. It can be an integer or a string field of the zone raster.</p>",
	"@@Zonal-Statistics_zoneraster_tag0@@": "<p>Dataset that defines the zones. The zones can be defined by an integer raster.</p>",
	"@@Zonal-Statistics_calculatecircularstatistics_tag0@@": "<p>Specifies how the statistics type will be calculated.</p><ul><li><strong>Arithmetic</strong>--Calculates arithmetic statistics. This is the default.</li><li><strong>Circular</strong>--Calculates circular statistics that are appropriate for cyclic quantities, such as compass direction in degrees, daytimes, and fractional parts of real numbers.</li></ul>",
	"@@Zonal-Statistics_circularwrapvalue_tag0@@": "<p>The highest possible value (upper bound) in the cyclic data. It is a positive number, with a default value of 360. This value also represents the same quantity as the lowest possible value (lower bound).</p><p>This parameter is applicable only when circular statistics is calculated.</p>",
	"@@Boundary-Clean-function_inputraster_tag0@@": "<p>The input raster for which the boundary between zones will be smoothed.</p><p>It must be of integer type.</p>",
	"@@Boundary-Clean-function_runexpansionandshrinkingtwice_tag0@@": "<p>Specifies the number of times the smoothing process will occur, twice or once.</p><ul><li><p><strong>Checked</strong>--Performs an expansion and shrinking operation two times. For the first time, the operation is performed according to the specified sorting type. Then an additional expansion and shrinking operation is performed with the priority reversed. This is the default.</p></li><li><p><strong>Unchecked</strong>--Performs the expansion and shrinking operation once according to the sorting type.</p></li></ul>",
	"@@Boundary-Clean-function_sorttype_tag0@@": "<p>Specifies the type of sorting to use in the smoothing process. The sorting determines the priority by which cells can expand into their neighbors.</p><p>The sorting can be done based on zone value or zone area.</p><ul><li><p><strong>Do not sort</strong>--The zones are not sorted by size. Zones with larger values have a higher priority to expand into zones with smaller values in the smoothed output. This is the default.</p></li><li><p><strong>Descending</strong>--Sorts zones in descending order by size. Zones with larger total areas have a higher priority to expand into zones with smaller total areas. This option tends to eliminate or reduce the prevalence of cells from smaller zones in the smoothed output.</p></li><li><p><strong>Ascending</strong>--Sorts zones in ascending order by size. Zones with smaller total areas have a higher priority to expand into zones with larger total areas. This option tends to preserve or increase the prevalence of cells from smaller zones in the smoothed output.</p></li></ul>",
	"@@Aggregate-Multidimensional_dimension_tag0@@": "<p>The aggregation dimension. This is the dimension along which the variables will be aggregated.</p>",
	"@@Aggregate-Multidimensional_dimensiondefinition_tag0@@": "<p>Specifies the method to use to filter the input multidimensional data before performing the aggregation.</p><ul><li><strong>All</strong>--The full range for each dimension will be used. This is the default.</li><li><strong>By Values</strong>--The dimension will be sliced using a dimension value or list of values.</li><li><strong>By Ranges</strong>--The dimension will be sliced using a range or a list of ranges.</li><li><strong>By Iteration</strong>--The dimension will be sliced over a specified interval size.</li></ul>",
	"@@Aggregate-Multidimensional_iterationdefinitionparameters_tag0@@": "<p>The Iteration Definition parameters allow you to define the dimension values to use to filter the input multidimensional data for analysis when the<strong>Dimension Definition</strong>parameter is set to<strong>By Iteration</strong>.</p><ul><li><strong>Dimension</strong>--The dimension to use for filtering.</li><li><strong>Start of first iteration</strong>--The beginning of the first interval. This interval is used to iterate through the dataset.</li><li><strong>End of first iteration</strong>--The end of the first interval. This interval is used to iterate through the dataset.</li><li><strong>Step</strong>--The frequency with which the data will be sliced.</li><li><strong>Unit</strong>--The iteration unit.</li></ul>",
	"@@Aggregate-Multidimensional_keywordinterval_tag0@@": "<p>Specifies the keyword interval that will be used when aggregating along the dimension.</p><p>This parameter is required when the<strong>Type</strong>parameter is set to<strong>Interval Keyword</strong>.</p><ul><li><strong>Hourly</strong>--The data values are aggregated into hourly time steps, and the result includes every hour in the time series. This is the default.</li><li><strong>Daily</strong>--The data values are aggregated into daily time steps, and the result includes every day in the time series.</li><li><strong>Weekly</strong>--The data values are aggregated into weekly time steps, and the result includes every week in the time series.</li><li><strong>Dekadly</strong>--The data values are aggregated into 3 periods of 10 days each. The last period can contain more or fewer than 10 days. The output includes 3 slices for each month.</li><li><strong>Pentadly</strong>--The data values are aggregated into 6 periods of 5 days each. The last period can contain more or fewer than 5 days. The output includes 6 slices for each month.</li><li><strong>Monthly</strong>--The data values are aggregated into monthly time steps, and the result includes every month in the time series.</li><li><strong>Quarterly</strong>--The data values are aggregated into quarterly time steps, and the result includes every quarter in the time series.</li><li><strong>Yearly</strong>--The data values are aggregated into yearly time steps, and the result includes every year in the time series.</li><li><strong>Recurring daily</strong>--The data values are aggregated into daily time steps, and the result includes one aggregated value per Julian day. The output includes, at most, 366 daily time slices.</li><li><strong>Recurring weekly</strong>--The data values are aggregated into weekly time steps, and the result includes one aggregated value per week. The output includes, at most, 53 weekly time slices.</li><li><strong>Recurring monthly</strong>--The data values are aggregated into monthly time steps, and the result includes one aggregated value per month. The output includes, at most, 12 monthly time slices.</li><li><strong>Recurring quarterly</strong>--The data values are aggregated into quarterly time steps, and the results include one aggregated value per quarter. The output includes, at most, 4 quarterly time slices.</li></ul>",
	"@@Aggregate-Multidimensional_operation_tag0@@": "<p>Specifies the mathematical method that will be used to combine the aggregated slices in an interval.</p><ul><li><strong>Majority</strong>--The pixel value that occurred most frequently will be calculated across all slices in the interval.</li><li><strong>Maximum</strong>--The maximum value of a pixel will be calculated across all slices in the interval.</li><li><strong>Mean</strong>--The mean of a pixel's values will be calculated across all slices in the interval. This is the default.</li><li><strong>Median</strong>--The median value of a pixel will be calculated across all slices in the interval.</li><li><strong>Minimum</strong>--The minimum value of a pixel will be calculated across all slices in the interval.</li><li><strong>Minority</strong>--The pixel value that occurred least frequently will be calculated across all slices in the interval.</li><li><strong>Range</strong>--The range of values for a pixel will be calculated across all slices in the interval.</li><li><strong>Standard Deviation</strong>--The standard deviation of a pixel's values will be calculated across all slices in the interval.</li><li><strong>Sum</strong>--The sum of a pixel's values will be calculated across all slices in the interval.</li><li><strong>Variety</strong>--The number of unique pixel values will be calculated across all slices in the interval.</li></ul><p>All options also have an equivalent with an Ignore NoData option. These will perform the mathematical operation on all valid pixels along the dimension and ignore any NoData pixels.</p>",
	"@@Aggregate-Multidimensional_ranges_tag0@@": "<p>Interval ranges specified in a table are used to aggregate groups of values. The minimum and maximum values specify the range to be included.</p><p>This parameter is required when the<strong>Type</strong>parameter is set to<strong>Interval Ranges</strong>.</p>",
	"@@Aggregate-Multidimensional_raster_tag0@@": "<p>The input multidimensional raster.</p>",
	"@@Aggregate-Multidimensional_type_tag0@@": "<p>Specifies the dimension interval for which the data will be aggregated.</p><ul><li><strong>All</strong>--The variable data will be aggregated across all slices. This is the default.</li><li><strong>Interval Keyword</strong>--The variable data will be aggregated using a commonly known interval.</li><li><strong>Interval Value</strong>--The variable data will be aggregated using a user-specified interval and unit.</li><li><strong>Interval Ranges</strong>--The variable data will be aggregated between specified pairs of values or dates.</li></ul>",
	"@@Aggregate-Multidimensional_valueinterval_tag0@@": "<p>The size of the interval used for the aggregation.</p><p>This parameter is required when the<strong>Type</strong>parameter is set to<strong>Interval Value</strong>.</p>",
	"@@Aggregate-Multidimensional_values_tag0@@": "<p>The dimension values to use to filter the input multidimensional data for analysis. This parameter is required when the<strong>Dimension Definition</strong>parameter is set to<strong>By Values</strong>.</p>",
	"@@Aggregate-Multidimensional_variables_tag0@@": "<p>The variable or variables that will be aggregated along the given dimension.</p>",
	"@@Predict-Using-Regression_inputdefinitionfile_tag0@@": "<p>The input Esri regression definition (<strong>.ecd</strong>) file that contains the statistics and information for the specific dataset, regression model, and chosen attributes.</p>",
	"@@Predict-Using-Regression_rasters_tag0@@": "<p>The raster dataset or datasets representing the predictor variables. It can be a single-band raster, multiple-band raster, multidimensional raster, mosaic dataset, or a raster collection.</p>",
	"@@Cell-Statistics_operation_tag0@@": "<p>The type of statistical calculation that you want to perform.</p><p>The available statistics are<strong>Majority</strong>,<strong>Maximum</strong>,<strong>Mean</strong>,<strong>Median</strong>,<strong>Minimum</strong>,<strong>Minority</strong>,<strong>Percentile</strong>,<strong>Range</strong>,<strong>Standard Deviation</strong>,<strong>Sum</strong>, and<strong>Variety</strong>.</p><p>The default is<strong>Mean</strong>.</p>",
	"@@Colormap-To-RGB_randomlyassigncolortounmappedpixels_tag0@@": "<p>Colors are randomly assigned to pixels that are not included in the color map.</p><ul><li>Unchecked--Unmapped pixels are not assigned a color. This is the default.</li><li>Checked--Unmapped pixels are assigned a color.</li></ul>",
	"@@Pansharpen_sensor_tag0@@": "<p>When the Gram-Schmidt algorithm is chosen, you can also specify the sensor that collected the multiband raster input. Choosing the sensor type will set appropriate band weights.</p>",
	"@@Dimensional-Moving-Statistics_backwardwindow_tag0@@": "<p>The value of how many slices before or above to be included in the defined window. The value must be a positive integer from 1 to 100. The default value is 1.</p><p>The unit of this parameter is slice.</p>",
	"@@Dimensional-Moving-Statistics_circularwrapvalue_tag0@@": "<p>The value that will be used to round a linear value to the range of a given circular mean.</p><p>Its value must be positive. The default value is 360 degrees.</p>",
	"@@Dimensional-Moving-Statistics_dimension_tag0@@": "<p>The name of the dimension along which the window will move.</p><p>The default value is the first dimension other than x,y found in the input multidimensional raster.</p>",
	"@@Dimensional-Moving-Statistics_forwardwindow_tag0@@": "<p>The value of how many slices after or below to be included in the defined window. The value must be a positive integer from 1 to 100. The default value is 1.</p><p>The unit of this parameter is slice.</p>",
	"@@Dimensional-Moving-Statistics_inputraster_tag0@@": "<p>The input raster can only be a multidimensional raster in Cloud Raster Format (<strong>.crf</strong>file).</p>",
	"@@Dimensional-Moving-Statistics_nodatahandling_tag0@@": "<p>Specifies how NoData values will be handled by the statistic calculation.</p><ul><li><strong>Data</strong>--NoData values in the value input will be ignored in the results of the defined window that they fall within. This is the default.</li><li><strong>NoData</strong>--Output values will be NoData if any NoData values exist in the input within the defined window.</li><li><strong>Fill NoData</strong>--NoData cell values will be replaced using the selected statistic within the defined window.</li></ul>",
	"@@Dimensional-Moving-Statistics_percentileinterpolationtype_tag0@@": "<p>Specifies the method of interpolation that will be used when the percentile value falls between two cell values.</p><ul><li><strong>Auto-detect</strong>--If the input raster is of integer pixel type, the<strong>Nearest</strong>method will be used. If the input raster is of float pixel type, the<strong>Linear</strong>method will be used. This is the default.</li><li><strong>Nearest</strong>--The nearest available value to the percentile will be used. In this case, the output pixel type will be the same as that of the input value raster.</li><li><strong>Linear</strong>--The weighted average of the two surrounding values from the percentile will be used. In this case, the output pixel type will be floating point.</li></ul>",
	"@@Dimensional-Moving-Statistics_percentilevalue_tag0@@": "<p>The percentile that will be calculated when<strong>Percentile</strong>is selected as the statistics type. The default is 90, for the 90th percentile.</p><p>The values can range from 0 through 100. The 0th percentile is essentially equivalent to the minimum statistic, and the 100th percentile is equivalent to the maximum statistic, with the exception that the result will be floating point. A value of 50 will produce the same result as the median statistic.</p>",
	"@@Dimensional-Moving-Statistics_statisticstype_tag0@@": "<p>Specifies the statistic type to be calculated.</p><p></p><ul><li><strong>Mean</strong>--The mean (average value) of the cells in the defined window will be calculated. This is the default.</li><li><strong>Circular Mean</strong>--The circular mean of the cells in the defined window will be calculated. When this statistics type is selected, the<strong>Circular Wrap Value</strong>parameter becomes available.</li><li><strong>Majority</strong>--The majority (value that occurs most often) of the cells in the defined window will be identified.</li><li><strong>Maximum</strong>--The maximum (largest value) of the cells in the defined window will be identified.</li><li><strong>Median</strong>--The median of the cells in the neighborhood will be identified.</li><li><strong>Minimum</strong>--The minimum (smallest value) of the cells in the neighborhood will be identified.</li><li><strong>Percentile</strong>--A percentile of the cells in the neighborhood will be calculated. When this statistics type is selected, the<strong>Percentile Value</strong>and<strong>Percentile Interpolation Type</strong>parameters become available. Use these new parameters to designate the percentile to calculate and choose the interpolation type to use, respectively.</li></ul>",
	"@@Interpolate-Raster-By-Dimension_dimension_tag0@@": "<p>The dimension to use for interpolation.</p><p>This parameter is required when the<strong>Dimension Definition</strong>parameter is set to<strong>By Interval</strong>.</p>",
	"@@Interpolate-Raster-By-Dimension_dimensiondefinition_tag0@@": "<p>Specifies the method that will be used to filter the input multidimensional data before performing the interpolation.</p><ul><li><strong>By Values</strong>--The dimension will be sliced using a dimension value or list of values.</li><li><strong>By Interval</strong>--The dimension will be sliced using a range or a list of ranges.</li><li><strong>By Target Raster</strong>--The dimension will be sliced using a specific target multidimensional raster.</li></ul>",
	"@@Interpolate-Raster-By-Dimension_endofinterval_tag0@@": "<p>The end of the interval, which is used to iterate through the dataset.</p><p>This parameter is required when the<strong>Dimension Definition</strong>parameter is set to<strong>By Interval</strong>.</p>",
	"@@Interpolate-Raster-By-Dimension_ignorenodata_tag0@@": "<p>Specifies whether NoData values will be ignored in the analysis.</p><ul><li>Unchecked--The analysis will result in NoData if there are NoData values in adjacent slices. This is the default.</li><li>Checked--The analysis will only use slices that have valid pixels and will ignore NoData slices.</li></ul>",
	"@@Interpolate-Raster-By-Dimension_interpolationmethod_tag0@@": "<p>Specifies the method that will be used to interpolate the raster.</p><ul><li><strong>Linear</strong>--The output will be interpolated linearly using the adjacent slices. This is the default.</li><li><strong>Nearest Neighbor</strong>--The output will use the nearest adjacent slice.</li></ul>",
	"@@Interpolate-Raster-By-Dimension_raster_tag0@@": "<p>The input multidimensional raster.</p>",
	"@@Interpolate-Raster-By-Dimension_startofinterval_tag0@@": "<p>The beginning of the interval, which is used to iterate through the dataset.</p><p>This parameter is required when the<strong>Dimension Definition</strong>parameter is set to<strong>By Interval</strong>.</p>",
	"@@Interpolate-Raster-By-Dimension_step_tag0@@": "<p>The frequency with which the data will be interpolated.</p><p>This parameter is required when the<strong>Dimension Definition</strong>parameter is set to<strong>By Interval</strong>.</p>",
	"@@Interpolate-Raster-By-Dimension_targetraster_tag0@@": "<p>The target raster specified by the dimension definition.</p><p>This parameter is required when the<strong>Dimension Definition</strong>parameter is set to<strong>By Target Raster</strong>.</p>",
	"@@Interpolate-Raster-By-Dimension_unit_tag0@@": "<p>The interval unit.</p><p>This parameter is required when the<strong>Dimension Definition</strong>parameter is set to<strong>By Interval</strong>.</p>",
	"@@Interpolate-Raster-By-Dimension_values_tag0@@": "<p>The dimensional values to use to filter the input multidimensional data for analysis.</p><p>This parameter is required when the<strong>Dimension Definition</strong>parameter is set to<strong>By Values</strong>.</p>",
	"@@Interpolate-Raster-By-Dimension_variables_tag0@@": "<p>The variable or variables that will be interpolated by the dimension definition.</p>",
	"@@Terrain-Flatten_calibrationtype_tag0@@": "<p>Specifies whether the output will be terrain flattened using<strong>Sigma nought</strong>or<strong>Gamma nought</strong>.</p><ul><li><strong>Gamma nought</strong>--The beta nought backscatter will be normalized using the unit area of a plane locally tangent to the DEM, commonly known as the local incidence angle. This is the default.</li><li><strong>Sigma nought</strong>--The beta nought backscatter will be normalized using a DEM to compute the area.</li></ul>",
	"@@Terrain-Flatten_dem_tag0@@": "<p>The input DEM.</p><p>The DEM is used to estimate the local illuminated area.</p>",
	"@@Terrain-Flatten_geoid_tag0@@": "<p>Specifies whether the vertical reference system of the input DEM will be transformed to ellipsoidal height. Most elevation datasets are referenced to sea level orthometric height, so a correction is required in these cases to convert to ellipsoidal height.</p><ul><li>Checked--A geoid correction will be made to convert orthometric height to ellipsoidal height (based on EGM96 geoid). This is the default.</li><li>Unchecked--No geoid correction will be made. Use this option only if the DEM is expressed in ellipsoidal height.</li></ul>",
	"@@Terrain-Flatten_raster_tag0@@": "<p>The input radar data.</p><p>This raster must first be radiometrically calibrated to beta nought.</p>",
	"@@Create-Color-Composite_blueexpression_tag0@@": "<p>The calculation assigned to the third band.</p><p>A band name, band ID, or an algebraic expression using the bands.</p><p>The supported operators are unary: plus (+), minus (-), times (*), and divide (/).</p>",
	"@@Create-Color-Composite_greenexpression_tag0@@": "<p>The calculation assigned to the second band.</p><p>A band name, band ID, or an algebraic expression using the bands.</p><p>The supported operators are unary: plus (+), minus (-), times (*), and divide (/).</p>",
	"@@Create-Color-Composite_inputraster_tag0@@": "<p>The input multiband raster data.</p>",
	"@@Create-Color-Composite_method_tag0@@": "<p>Specifies themethod that will be used to extract bands.</p><ul><li>Band Names--The band name representing the wavelengthinterval on the electromagnetic spectrum (such as Red, Near Infrared,or Thermal Infrared) or the polarization (such as VH, VV, HH,or HV) will be used. This is the default.</li><li>Band IDs--The band number (such as B1, B2, or B3) will be used.</li></ul>",
	"@@Create-Color-Composite_redexpression_tag0@@": "<p>The calculation assigned to the first band.</p><p>A band name, band ID, or an algebraic expression using the bands.</p><p>The supported operators are unary: plus (+), minus (-), times (*), and divide (/).</p>",
	"@@Surface-Parameters_localsurfacetype_tag0@@": "<p>Choose the type of surface function that will be fitted around the target cell.</p><ul><li>Quadratic--A quadratic surface function will be fitted to the neighborhood cells. This is the default type.</li><li>Biquadratic--A biquadratic surface function will be fitted to the neighborhood cells.</li></ul>",
	"@@Surface-Parameters_neighborhooddistance_tag0@@": "<p>The output will be calculated over this distance from the target cell center. It determines the neighborhood size. The default value is the input raster cell size, resulting in a 3 by 3 neighborhood.</p>",
	"@@Surface-Parameters_outputslopemeasurement_tag0@@": "<p>The measurement units (degrees or percentages) that will be used for the output slope raster. This parameter is only active when<strong>Parameter type</strong>is<strong>Slope</strong>.</p><ul><li>Degree--The inclination of slope will be calculated in degrees. This is the default.</li><li>Percent rise--The inclination of slope will be calculated as percent rise, also referred to as the percent slope.</li></ul>",
	"@@Surface-Parameters_parametertype_tag0@@": "<p>Specifies the output surface parameter type that will be computed.</p><ul><li>Slope--The rate of change in elevation will be computed. This is the default.</li><li>Aspect--The downslope direction of the maximum rate of change for each cell will be computed.</li><li>Mean Curvature--The overall curvature of the surface will be measured. It is computed as the average of the minimum and maximum curvature. This curvature describes the intrinsic convexity or concavity of the surface, independent of direction or gravity influence.</li><li>Tangential (normal contour) Curvature--The geometric normal curvature perpendicular to the slope line, tangent to the contour line will be measured. This curvature is typically applied to characterize the convergence or divergence of flow across the surface.</li><li>Profile (normal slope line) Curvature--The geometric normal curvature along the slope line will be measured. This curvature is typically applied to characterize the acceleration and deceleration of flow down the surface.</li><li>Plan (projected contour) Curvature--The curvature along contour lines will be measured.</li><li>Contour Geodesic Torsion--The rate of change in slope angle along contour lines will be measured.</li><li>Gaussian Curvature--The overall curvature of the surface will be measured. It is computed as the product of the minimum and maximum curvature.</li><li>Casorati Curvature--The general curvature of the surface will be measured. It can be zero or any other positive number.</li></ul>",
	"@@Surface-Parameters_projectgeodesicazimuths_tag0@@": "<p>Specifies whether geodesic azimuths will be projected to correct the angle distortion caused by the output spatial reference.This parameter is only active when<strong>Parameter type</strong>is<strong>Aspect</strong>.</p><ul><li>Unchecked--Geodesic azimuths will not be projected. This is the default.</li><li>Checked--Geodesic azimuths will be projected.</li></ul>",
	"@@Surface-Parameters_raster_tag0@@": "<p>The input surface raster. It can be an integer or a floating-point raster.</p>",
	"@@Surface-Parameters_useadaptiveneighborhood_tag0@@": "<p>Specifies whether neighborhood distance will vary with landscape changes (adaptive). The maximum distance is determined by the neighborhood distance. The minimum distance is the input raster cell size.</p><ul><li>Unchecked--A single (fixed) neighborhood distance will be used at all locations. This is the default.</li><li>Checked--An adaptive neighborhood distance will be used at all locations.</li></ul>",
	"@@Surface-Parameters_useequatorialaspect_tag0@@": "<p>Specifies whether aspect will be measured from a point on the equator or from the north pole.This parameter is only active when<strong>Parameter type</strong>is<strong>Aspect</strong>.</p><ul><li>Unchecked--Aspect will be measured from the north pole. This is the default.</li><li>Checked--Aspect will be measured from a point on the equator.</li></ul>",
	"@@Surface-Parameters_zunit_tag0@@": "<p>The linear unit of vertical z-values.</p><p>It is defined by a vertical coordinate system if it exists. If a vertical coordinate system does not exist, the z-unit should be defined from the unit list, to ensure correct geodesic computation.</p><ul><li>Inch--The linear unit will be inches.</li><li>Foot--The linear unit will be feet.</li><li>Yard--The linear unit will be yards.</li><li>Mile US--The linear unit will be miles.</li><li>Nautical mile--The linear unit will be nautical miles.</li><li>Millimeter--The linear unit will be millimeters.</li><li>Centimeter--The linear unit will be centimeters.</li><li>Meter--The linear unit will be meters. This is the default.</li><li>Kilometer--The linear unit will be kilometers.</li><li>Decimeter--The linear unit will be decimeters.</li></ul>",
	"@@Surface-Parameters_analysismask_tag0@@": "<p>A raster that specifies the locations where the analysis will occur.</p><p>The raster can be integer or floating point type.</p><p>All cells with a valid value, including zero, will compose the mask. Cells that are NoData in the mask input will be NoData in the output.</p>",
	"@@Geometric-Median_cellsizetype_tag0@@": "<p>Choose which cell size to use in the output raster. If all the input cell sizes are the same, all the options will yield the same results.</p><ul><li>First Of--Use the first cell size of the input rasters.</li><li>Min Of--Use the smallest cell size of all the input rasters.</li><li>Max Of--Use the largest cell size of all the input rasters. This is the default.</li><li>Mean Of--Use the mean cell size of all the input rasters.</li><li>Last Of--Use the last cell size of the input rasters.</li></ul>",
	"@@Geometric-Median_epsilon_tag0@@": "<p>Specifies the convergence value between two consecutive iterations. When epsilon is less than or equal to the specified value, the iteration stops, and the result of the last iteration is used.</p>",
	"@@Geometric-Median_extenttype_tag0@@": "<p>Choose which extent should be used in the output raster:</p><ul><li><p>First Of--Use the extent of the first input raster to determine the processing extent.</p></li><li>Intersection Of--Use the extent of the overlapping pixels to determine the processing extent. This is the default.</li><li>Union Of--Use the extent of all the rasters to determine the processing extent.</li><li>Last Of--Use the extent of the last input raster to determine the processing extent.</li></ul>",
	"@@Geometric-Median_maximumnumberofiterations_tag0@@": "<p>Specifies the maximum number of iterations to complete. The computation ends when this value is reached, regardless of the<strong>Epsilon</strong>setting.</p>",
	"@@Geometric-Median_rasters_tag0@@": "<p>The input multiband rasters.</p>",
	"@@Least-Cost-Corridor_inputaccumulativecostdistanceraster1_tag0@@": "<p>The input raster representing accumulative cost distance from the first source.</p><p>It should be an accumulated cost distance output from the<strong>Distance Accumulation</strong>or<strong>Distance Allocation</strong>function.</p>",
	"@@Least-Cost-Corridor_inputaccumulativecostdistanceraster2_tag0@@": "<p>The input raster representing accumulative cost distance from the second source.</p><p>It should be an accumulated cost distance output from the<strong>Distance Accumulation</strong>or<strong>Distance Allocation</strong>function.</p>",
	"@@Least-Cost-Corridor_inputbackdirectionraster1_tag0@@": "<p>The input back direction raster from the first source.</p><p>This is a raster dataset identifying the direction of the next cell along the least-cost path back to the first source. This is output from the<strong>Distance Accumulation</strong>or<strong>Distance Allocation</strong>function.</p>",
	"@@Least-Cost-Corridor_inputbackdirectionraster2_tag0@@": "<p>The input back direction raster from the second source.</p><p>This is a raster dataset identifying the direction of the next cell along the least-cost path back to the first source. This is output from the<strong>Distance Accumulation</strong>or<strong>Distance Allocation</strong>function.</p>",
	"@@Least-Cost-Corridor_threshold_tag0@@": "<p>A percent or accumulative cost threshold that will determine whether a given cell will be included in the output corridor raster.</p><p>When the<strong>Threshold method</strong>parameter is set to<strong>Percent of least cost</strong>, the specified value indicates the percent increase to apply from the minimum value of the summed accumulative cost distance rasters. When the<strong>Threshold method</strong>parameter is set to<strong>Accumulative cost</strong>, the value indicates cells that have a summed accumulative cost equal to or below the value that will be included in the corridor.</p><p>This parameter is only active if the<strong>Threshold method</strong>parameter is set to<strong>Percent of least cost</strong>or<strong>Accumulative cost</strong>.</p>",
	"@@Least-Cost-Corridor_thresholdmethod_tag0@@": "<p>Specifies how the threshold will be defined.</p><p></p><ul><li><strong>No Threshold</strong>--No threshold will be applied, and the resulting corridor will cover the full extent of the input rasters. This is the default.</li><li><strong>Percent of Least Cost</strong>--The threshold will be defined as a percent of the minimum value of the summed accumulative cost distance rasters.</li><li><strong>Accumulative Cost</strong>--The threshold will be defined in accumulative cost distance units.</li></ul>"
};
const helpTexts_en = {
	rfxArgsHelpTexts: rfxArgsHelpTexts
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (helpTexts_en);


//# sourceMappingURL=help-texts.en-f9d07fbe.js.map

/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid2lkZ2V0cy9jaHVua3MvYXJjZ2lzX2FuYWx5c2lzX25vZGVfbW9kdWxlc19hcmNnaXNfYXJjZ2lzLXJhc3Rlci1mdW5jdGlvbi1lZGl0b3JfLTk1ZWI0OS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdGQUFnRixHQUFHO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkZBQTZGLFlBQVk7QUFDekcsK0ZBQStGLFlBQVk7QUFDM0csNkZBQTZGLFlBQVk7QUFDekc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4T0FBOE8sTUFBTTtBQUNwUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFGQUFxRixLQUFLO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RTtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb05BQW9OLE9BQU87QUFDM047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwVkFBMFYsYUFBYSxLQUFLLFVBQVU7QUFDdFg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5VkFBeVYsYUFBYSxLQUFLLFVBQVU7QUFDclg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd1ZBQXdWLGFBQWEsS0FBSyxVQUFVO0FBQ3BYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNIQUFzSCxRQUFRO0FBQzlIO0FBQ0EsdUhBQXVILE9BQU87QUFDOUg7QUFDQTtBQUNBLGdHQUFnRyxFQUFFLDRFQUE0RSxJQUFJO0FBQ2xMO0FBQ0Esb0dBQW9HLEVBQUUsT0FBTyxJQUFJO0FBQ2pIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4TkFBOE4sT0FBTztBQUNyTztBQUNBO0FBQ0EsOEVBQThFLFFBQVE7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4T0FBOE8sT0FBTztBQUNyUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEVBQTRFLFFBQVE7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ05BQWdOO0FBQ2hOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0VBQStFLFFBQVE7QUFDdkYsNkdBQTZHLFFBQVEsMENBQTBDLFFBQVE7QUFDdkssdUpBQXVKLE9BQU8sK0NBQStDLE9BQU87QUFDcE47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbVFBQW1RO0FBQ25RO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzSEFBc0g7QUFDdEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUtBQWlLLEdBQUc7QUFDcEs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEZBQTRGLFFBQVE7QUFDcEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQywwQ0FBMEMsd0VBQXdFLElBQUkseUVBQXlFLElBQUk7QUFDOU87QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtRQUErUSxPQUFPO0FBQ3RSLG9OQUFvTixPQUFPO0FBQzNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBWQUEwVixhQUFhLEtBQUssVUFBVTtBQUN0WDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlJQUFpSSxtREFBbUQsT0FBTztBQUMzTCxzRUFBc0UsUUFBUTtBQUM5RTtBQUNBLDJFQUEyRSxRQUFRLG9HQUFvRyxRQUFRO0FBQy9MLDhFQUE4RSxRQUFRLG1HQUFtRyxPQUFPO0FBQ2hNO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxNQUFNO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRkFBcUYsUUFBUTtBQUM3RixxS0FBcUssUUFBUSw2Q0FBNkMsUUFBUTtBQUNsTyx5TEFBeUwsUUFBUTtBQUNqTTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrK0JBQWsrQiw0TEFBNEwsWUFBWTtBQUMxcUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdWQUF3VixhQUFhLEtBQUssVUFBVTtBQUNwWCxnL0JBQWcvQjtBQUNoL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNitCQUE2K0IsNExBQTRMLFlBQVk7QUFDcnJDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1XQUFtVyxhQUFhLEtBQUssVUFBVTtBQUMvWDtBQUNBLDIvQkFBMi9CO0FBQzMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0K0JBQTQrQiw0TEFBNEwsWUFBWTtBQUNwckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtXQUFrVyxhQUFhLEtBQUssVUFBVTtBQUM5WCwwL0JBQTAvQjtBQUMxL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0hBQXNILHlCQUF5QjtBQUMvSTtBQUNBLHlKQUF5Siw4QkFBOEI7QUFDdkw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RSxNQUFNO0FBQy9FLGdJQUFnSSxPQUFPLE1BQU0sT0FBTztBQUNwSjtBQUNBO0FBQ0Esc01BQXNNLE1BQU07QUFDNU07QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvUkFBb1I7QUFDcFI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRRQUE0UTtBQUM1UTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RUFBNkUsV0FBVyxxSUFBcUksV0FBVztBQUN4TztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseU1BQXlNO0FBQ3pNO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOElBQThJO0FBQzlJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUdBQWlHO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEVBQTRFLE9BQU87QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZHQUE2RyxzREFBc0Q7QUFDbks7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhIQUE4SCxLQUFLLDBJQUEwSSxNQUFNO0FBQ25SO0FBQ0E7QUFDQSx3TEFBd0wsZUFBZTtBQUN2TTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRSxRQUFRO0FBQzdFLGdGQUFnRixRQUFRLG1IQUFtSCxRQUFRO0FBQ25OLHFMQUFxTCxPQUFPLG9EQUFvRCxPQUFPLGtHQUFrRyxRQUFRO0FBQ2pXO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZIQUE2SCxFQUFFO0FBQy9IO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwK0JBQTArQiw0TEFBNEwsWUFBWTtBQUNsckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtWQUErVixhQUFhLEtBQUssVUFBVTtBQUMzWCx3L0JBQXcvQjtBQUN4L0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHcrQkFBdytCLDRMQUE0TCxZQUFZO0FBQ2hyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNlZBQTZWLGFBQWEsS0FBSyxVQUFVO0FBQ3pYLHMvQkFBcy9CO0FBQ3QvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5d0JBQXl3QjtBQUN6d0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpRUFBZSxZQUFZLEVBQUM7QUFDQTs7QUFFNUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9leGItY2xpZW50Ly4vZXh0ZW5zaW9ucy93aWRnZXRzL2FyY2dpcy9hbmFseXNpcy9ub2RlX21vZHVsZXMvQGFyY2dpcy9hcmNnaXMtcmFzdGVyLWZ1bmN0aW9uLWVkaXRvci9kaXN0L2VzbS9oZWxwLXRleHRzLmVuLWY5ZDA3ZmJlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IHJmeEFyZ3NIZWxwVGV4dHMgPSB7XG5cdFwiQEBBYnNfQ2VsbHNpemUtVHlwZV90YWcwQEBcIjogXCJDaG9vc2Ugd2hpY2ggY2VsbCBzaXplIHRvIHVzZSBpbiB0aGUgb3V0cHV0IHJhc3Rlci4gSWYgYWxsIHRoZSBpbnB1dCBjZWxsIHNpemVzIGFyZSB0aGUgc2FtZSwgYWxsIHRoZSBvcHRpb25zIHdpbGwgeWllbGQgdGhlIHNhbWUgcmVzdWx0cy5cIixcblx0XCJAQEFic19DZWxsc2l6ZS1UeXBlX3RhZzFAQFwiOiBcIkZpcnN0IE9mLS1Vc2UgdGhlIGZpcnN0IGNlbGwgc2l6ZSBvZiB0aGUgaW5wdXQgcmFzdGVycy5cIixcblx0XCJAQEFic19DZWxsc2l6ZS1UeXBlX3RhZzJAQFwiOiBcIkxhc3QgT2YtLVVzZSB0aGUgbGFzdCBjZWxsIHNpemUgb2YgdGhlIGlucHV0IHJhc3RlcnMuXCIsXG5cdFwiQEBBYnNfQ2VsbHNpemUtVHlwZV90YWczQEBcIjogXCJNYXggT2YtLVVzZSB0aGUgbGFyZ2VzdCBjZWxsIHNpemUgb2YgYWxsIHRoZSBpbnB1dCByYXN0ZXJzLiBUaGlzIGlzIHRoZSBkZWZhdWx0LlwiLFxuXHRcIkBAQWJzX0NlbGxzaXplLVR5cGVfdGFnNEBAXCI6IFwiTWVhbiBPZi0tVXNlIHRoZSBtZWFuIGNlbGwgc2l6ZSBvZiBhbGwgdGhlIGlucHV0IHJhc3RlcnMuXCIsXG5cdFwiQEBBYnNfQ2VsbHNpemUtVHlwZV90YWc1QEBcIjogXCJNaW4gT2YtLVVzZSB0aGUgc21hbGxlc3QgY2VsbCBzaXplIG9mIGFsbCB0aGUgaW5wdXQgcmFzdGVycy5cIixcblx0XCJAQEFic19FeHRlbnQtVHlwZV90YWcwQEBcIjogXCJDaG9vc2Ugd2hpY2ggZXh0ZW50IHNob3VsZCBiZSB1c2VkIGluIHRoZSBvdXRwdXQgcmFzdGVyOlwiLFxuXHRcIkBAQWJzX0V4dGVudC1UeXBlX3RhZzFAQFwiOiBcIkZpcnN0IE9mLS1Vc2UgdGhlIGV4dGVudCBvZiB0aGUgZmlyc3QgaW5wdXQgcmFzdGVyIHRvIGRldGVybWluZSB0aGUgcHJvY2Vzc2luZyBleHRlbnQuXCIsXG5cdFwiQEBBYnNfRXh0ZW50LVR5cGVfdGFnMkBAXCI6IFwiSW50ZXJzZWN0aW9uIE9mLS1Vc2UgdGhlIGV4dGVudCBvZiB0aGUgb3ZlcmxhcHBpbmcgcGl4ZWxzIHRvIGRldGVybWluZSB0aGUgcHJvY2Vzc2luZyBleHRlbnQuIFRoaXMgaXMgdGhlIGRlZmF1bHQuXCIsXG5cdFwiQEBBYnNfRXh0ZW50LVR5cGVfdGFnM0BAXCI6IFwiTGFzdCBPZi0tVXNlIHRoZSBleHRlbnQgb2YgdGhlIGxhc3QgaW5wdXQgcmFzdGVyIHRvIGRldGVybWluZSB0aGUgcHJvY2Vzc2luZyBleHRlbnQuXCIsXG5cdFwiQEBBYnNfRXh0ZW50LVR5cGVfdGFnNEBAXCI6IFwiVW5pb24gT2YtLVVzZSB0aGUgZXh0ZW50IG9mIGFsbCB0aGUgcmFzdGVycyB0byBkZXRlcm1pbmUgdGhlIHByb2Nlc3NpbmcgZXh0ZW50LlwiLFxuXHRcIkBAQWJzX1Jhc3Rlcl90YWcwQEBcIjogXCJUaGUgaW5wdXQgcmFzdGVyIGZvciB3aGljaCB0byBjYWxjdWxhdGUgdGhlIGFic29sdXRlIHZhbHVlcy5cIixcblx0XCJAQEFDb3NfQ2VsbHNpemUtVHlwZV90YWcwQEBcIjogXCJDaG9vc2Ugd2hpY2ggY2VsbCBzaXplIHRvIHVzZSBpbiB0aGUgb3V0cHV0IHJhc3Rlci4gSWYgYWxsIHRoZSBpbnB1dCBjZWxsIHNpemVzIGFyZSB0aGUgc2FtZSwgYWxsIHRoZSBvcHRpb25zIHdpbGwgeWllbGQgdGhlIHNhbWUgcmVzdWx0cy5cIixcblx0XCJAQEFDb3NfQ2VsbHNpemUtVHlwZV90YWcxQEBcIjogXCJGaXJzdCBPZi0tVXNlIHRoZSBmaXJzdCBjZWxsIHNpemUgb2YgdGhlIGlucHV0IHJhc3RlcnMuXCIsXG5cdFwiQEBBQ29zX0NlbGxzaXplLVR5cGVfdGFnMkBAXCI6IFwiTGFzdCBPZi0tVXNlIHRoZSBsYXN0IGNlbGwgc2l6ZSBvZiB0aGUgaW5wdXQgcmFzdGVycy5cIixcblx0XCJAQEFDb3NfQ2VsbHNpemUtVHlwZV90YWczQEBcIjogXCJNYXggT2YtLVVzZSB0aGUgbGFyZ2VzdCBjZWxsIHNpemUgb2YgYWxsIHRoZSBpbnB1dCByYXN0ZXJzLiBUaGlzIGlzIHRoZSBkZWZhdWx0LlwiLFxuXHRcIkBAQUNvc19DZWxsc2l6ZS1UeXBlX3RhZzRAQFwiOiBcIk1lYW4gT2YtLVVzZSB0aGUgbWVhbiBjZWxsIHNpemUgb2YgYWxsIHRoZSBpbnB1dCByYXN0ZXJzLlwiLFxuXHRcIkBAQUNvc19DZWxsc2l6ZS1UeXBlX3RhZzVAQFwiOiBcIk1pbiBPZi0tVXNlIHRoZSBzbWFsbGVzdCBjZWxsIHNpemUgb2YgYWxsIHRoZSBpbnB1dCByYXN0ZXJzLlwiLFxuXHRcIkBAQUNvc19FeHRlbnQtVHlwZV90YWcwQEBcIjogXCJDaG9vc2Ugd2hpY2ggZXh0ZW50IHNob3VsZCBiZSB1c2VkIGluIHRoZSBvdXRwdXQgcmFzdGVyOlwiLFxuXHRcIkBAQUNvc19FeHRlbnQtVHlwZV90YWcxQEBcIjogXCJGaXJzdCBPZi0tVXNlIHRoZSBleHRlbnQgb2YgdGhlIGZpcnN0IGlucHV0IHJhc3RlciB0byBkZXRlcm1pbmUgdGhlIHByb2Nlc3NpbmcgZXh0ZW50LlwiLFxuXHRcIkBAQUNvc19FeHRlbnQtVHlwZV90YWcyQEBcIjogXCJJbnRlcnNlY3Rpb24gT2YtLVVzZSB0aGUgZXh0ZW50IG9mIHRoZSBvdmVybGFwcGluZyBwaXhlbHMgdG8gZGV0ZXJtaW5lIHRoZSBwcm9jZXNzaW5nIGV4dGVudC4gVGhpcyBpcyB0aGUgZGVmYXVsdC5cIixcblx0XCJAQEFDb3NfRXh0ZW50LVR5cGVfdGFnM0BAXCI6IFwiTGFzdCBPZi0tVXNlIHRoZSBleHRlbnQgb2YgdGhlIGxhc3QgaW5wdXQgcmFzdGVyIHRvIGRldGVybWluZSB0aGUgcHJvY2Vzc2luZyBleHRlbnQuXCIsXG5cdFwiQEBBQ29zX0V4dGVudC1UeXBlX3RhZzRAQFwiOiBcIlVuaW9uIE9mLS1Vc2UgdGhlIGV4dGVudCBvZiBhbGwgdGhlIHJhc3RlcnMgdG8gZGV0ZXJtaW5lIHRoZSBwcm9jZXNzaW5nIGV4dGVudC5cIixcblx0XCJAQEFDb3NfUmFzdGVyX3RhZzBAQFwiOiBcIlRoZSBpbnB1dCBmb3Igd2hpY2ggdG8gY2FsY3VsYXRlIHRoZSBpbnZlcnNlIGNvc2luZSB2YWx1ZXMuXCIsXG5cdFwiQEBBQ29zSF9DZWxsc2l6ZS1UeXBlX3RhZzBAQFwiOiBcIkNob29zZSB3aGljaCBjZWxsIHNpemUgdG8gdXNlIGluIHRoZSBvdXRwdXQgcmFzdGVyLiBJZiBhbGwgdGhlIGlucHV0IGNlbGwgc2l6ZXMgYXJlIHRoZSBzYW1lLCBhbGwgdGhlIG9wdGlvbnMgd2lsbCB5aWVsZCB0aGUgc2FtZSByZXN1bHRzLlwiLFxuXHRcIkBAQUNvc0hfQ2VsbHNpemUtVHlwZV90YWcxQEBcIjogXCJGaXJzdCBPZi0tVXNlIHRoZSBmaXJzdCBjZWxsIHNpemUgb2YgdGhlIGlucHV0IHJhc3RlcnMuXCIsXG5cdFwiQEBBQ29zSF9DZWxsc2l6ZS1UeXBlX3RhZzJAQFwiOiBcIkxhc3QgT2YtLVVzZSB0aGUgbGFzdCBjZWxsIHNpemUgb2YgdGhlIGlucHV0IHJhc3RlcnMuXCIsXG5cdFwiQEBBQ29zSF9DZWxsc2l6ZS1UeXBlX3RhZzNAQFwiOiBcIk1heCBPZi0tVXNlIHRoZSBsYXJnZXN0IGNlbGwgc2l6ZSBvZiBhbGwgdGhlIGlucHV0IHJhc3RlcnMuIFRoaXMgaXMgdGhlIGRlZmF1bHQuXCIsXG5cdFwiQEBBQ29zSF9DZWxsc2l6ZS1UeXBlX3RhZzRAQFwiOiBcIk1lYW4gT2YtLVVzZSB0aGUgbWVhbiBjZWxsIHNpemUgb2YgYWxsIHRoZSBpbnB1dCByYXN0ZXJzLlwiLFxuXHRcIkBAQUNvc0hfQ2VsbHNpemUtVHlwZV90YWc1QEBcIjogXCJNaW4gT2YtLVVzZSB0aGUgc21hbGxlc3QgY2VsbCBzaXplIG9mIGFsbCB0aGUgaW5wdXQgcmFzdGVycy5cIixcblx0XCJAQEFDb3NIX0V4dGVudC1UeXBlX3RhZzBAQFwiOiBcIkNob29zZSB3aGljaCBleHRlbnQgc2hvdWxkIGJlIHVzZWQgaW4gdGhlIG91dHB1dCByYXN0ZXI6XCIsXG5cdFwiQEBBQ29zSF9FeHRlbnQtVHlwZV90YWcxQEBcIjogXCJGaXJzdCBPZi0tVXNlIHRoZSBleHRlbnQgb2YgdGhlIGZpcnN0IGlucHV0IHJhc3RlciB0byBkZXRlcm1pbmUgdGhlIHByb2Nlc3NpbmcgZXh0ZW50LlwiLFxuXHRcIkBAQUNvc0hfRXh0ZW50LVR5cGVfdGFnMkBAXCI6IFwiSW50ZXJzZWN0aW9uIE9mLS1Vc2UgdGhlIGV4dGVudCBvZiB0aGUgb3ZlcmxhcHBpbmcgcGl4ZWxzIHRvIGRldGVybWluZSB0aGUgcHJvY2Vzc2luZyBleHRlbnQuIFRoaXMgaXMgdGhlIGRlZmF1bHQuXCIsXG5cdFwiQEBBQ29zSF9FeHRlbnQtVHlwZV90YWczQEBcIjogXCJMYXN0IE9mLS1Vc2UgdGhlIGV4dGVudCBvZiB0aGUgbGFzdCBpbnB1dCByYXN0ZXIgdG8gZGV0ZXJtaW5lIHRoZSBwcm9jZXNzaW5nIGV4dGVudC5cIixcblx0XCJAQEFDb3NIX0V4dGVudC1UeXBlX3RhZzRAQFwiOiBcIlVuaW9uIE9mLS1Vc2UgdGhlIGV4dGVudCBvZiBhbGwgdGhlIHJhc3RlcnMgdG8gZGV0ZXJtaW5lIHRoZSBwcm9jZXNzaW5nIGV4dGVudC5cIixcblx0XCJAQEFDb3NIX1Jhc3Rlcl90YWcwQEBcIjogXCJUaGUgaW5wdXQgZm9yIHdoaWNoIHRvIGNhbGN1bGF0ZSB0aGUgaW52ZXJzZSBoeXBlcmJvbGljIGNvc2luZSB2YWx1ZXMuXCIsXG5cdFwiQEBBcHBhcmVudC1SZWZsZWN0YW5jZV9BbGJlZG9fdGFnMEBAXCI6IFwiVGhlIHJlc3VsdHMgb2YgdGhlIEFwcGFyZW50IFJlZmxlY3RhbmNlIGZ1bmN0aW9uIGNhbiBhbHNvIGJlIGV4cHJlc3NlZCBhcyBhbGJlZG8sIHdoaWNoIGlzIHRoZSBwZXJjZW50YWdlIG9mIHRoZSBhdmFpbGFibGUgZW5lcmd5IHJlZmxlY3RlZCBieSB0aGUgcGxhbmV0YXJ5IHN1cmZhY2UuIEFsYmVkbyBkYXRhIGlzIHVzZWQgYnkgc2NpZW50aWZpYyB1c2VycyBmb3IgY29tcGxleCBtb2RlbGluZyBhbmQgdGVjaG5pY2FsIHJlbW90ZS1zZW5zaW5nIGFwcGxpY2F0aW9ucy5cIixcblx0XCJAQEFwcGFyZW50LVJlZmxlY3RhbmNlX0FsYmVkb190YWcxQEBcIjogXCJVbmNoZWNrZWQtLVRoZSBmdW5jdGlvbiByZXR1cm5zIGFwcGFyZW50IHJlZmxlY3RhbmNlIHZhbHVlcy4gVGhpcyBpcyB0aGUgZGVmYXVsdC5cIixcblx0XCJAQEFwcGFyZW50LVJlZmxlY3RhbmNlX0FsYmVkb190YWcyQEBcIjogXCJDaGVja2VkLS1UaGUgZnVuY3Rpb24gcmV0dXJucyAzMi1iaXQgZmxvYXRpbmctcG9pbnQgdmFsdWVzLCB3aGljaCBtb3N0IGNvbW1vbmx5IGFyZSBpbiB0aGUgcmFuZ2Ugb2YgMC4wIHRvIDEuMC4gTm8gZGF0YSBjbGlwcGluZyBpcyBwZXJmb3JtZWQgaWYgdGhpcyBvcHRpb24gaXMgc2VsZWN0ZWQuXCIsXG5cdFwiQEBBcHBhcmVudC1SZWZsZWN0YW5jZV9BbGJlZG9fdGFnM0BAXCI6IFwiU2luY2UgdGhlIG91dHB1dCBkYXRhIHR5cGUgZm9yIGFsYmVkbyBpcyBmbG9hdGluZyBwb2ludCwgeW91IG11c3QgZXhwbGljaXRseSBzZXQgdGhlIHByZWZlcnJlZCA8c3Ryb25nPk91dHB1dCBQaXhlbCBUeXBlPC9zdHJvbmc+IHRvIGVpdGhlciAzMi1iaXQgZmxvYXQgb3IgNjQtYml0IGRvdWJsZS4gVGhlIDxzdHJvbmc+T3V0cHV0IFBpeGVsIFR5cGU8L3N0cm9uZz4gcGFyYW1ldGVyIGlzIGZvdW5kIG9uIHRoZSA8c3Ryb25nPkdlbmVyYWw8L3N0cm9uZz4gdGFiIGluIHRoZSA8c3Ryb25nPkFwcGFyZW50IFJlZmxlY3RhbmNlPC9zdHJvbmc+IHJhc3RlciBmdW5jdGlvbi4gSWYgdGhlIDxzdHJvbmc+T3V0cHV0IFBpeGVsIFR5cGU8L3N0cm9uZz4gaXMgbm90IHNldCBjb3JyZWN0bHkgZm9yIHRoZSA8c3Ryb25nPkFsYmVkbzwvc3Ryb25nPiBvcHRpb24sIHRoZSByZXN1bHRpbmcgdmFsdWVzIHdpbGwgYmUgaW52YWxpZCBhbmQgZ2l2ZW4gYSB2YWx1ZSBvZiAwLlwiLFxuXHRcIkBAQXBwYXJlbnQtUmVmbGVjdGFuY2VfT2Zmc2V0X3RhZzBAQFwiOiBcIllvdXIgc2NhbGVkIGFsYmVkbyB2YWx1ZSBjYW4gb3B0aW9uYWxseSBoYXZlIGFuIG9mZnNldCB2YWx1ZTpcIixcblx0XCJAQEFwcGFyZW50LVJlZmxlY3RhbmNlX09mZnNldF90YWcxQEBcIjogXCJGb3IgMTYtYml0IHVuc2lnbmVkIGRhdGEgdHlwZXMsIHRoZSBkZWZhdWx0IHNjYWxlIG9mZnNldCBpcyA1LDAwMC5cIixcblx0XCJAQEFwcGFyZW50LVJlZmxlY3RhbmNlX09mZnNldF90YWcyQEBcIjogXCJGb3IgOC1iaXQgdW5zaWduZWQgZGF0YSB0eXBlcywgdGhlIGRlZmF1bHQgc2NhbGUgb2Zmc2V0IGlzIDAuXCIsXG5cdFwiQEBBcHBhcmVudC1SZWZsZWN0YW5jZV9PZmZzZXRfdGFnM0BAXCI6IFwiTm8gc2NhbGluZyBpcyBhcHBsaWVkIHdoZW4gdGhlIG91dHB1dCBpcyBhbGJlZG8uXCIsXG5cdFwiQEBBcHBhcmVudC1SZWZsZWN0YW5jZV9SYWRpYW5jZS1HYWlucy1hbmQtQmlhcy1WYWx1ZXMtcGVyLUJhbmRfdGFnMEBAXCI6IFwiWW91IGNhbiBtYW51YWxseSBzZXQgb3IgZWRpdCB0aGlzIHZhbHVlIGZvciBlYWNoIGJhbmQuIFRoZSBhcHByb3ByaWF0ZSBpbmZvcm1hdGlvbiBjYW4gYmUgcmVhZCBmcm9tIHRoZSBtZXRhZGF0YSBvZiB0aGUgaW5wdXQgcmFzdGVyIHByb2R1Y3QuXCIsXG5cdFwiQEBBcHBhcmVudC1SZWZsZWN0YW5jZV9SYXN0ZXJfdGFnMEBAXCI6IFwiVGhlIHJhc3RlciBwcm9kdWN0IG9uIHdoaWNoIHRoZSBhcHBhcmVudCByZWZsZWN0YW5jZSB3aWxsIGJlIGFwcGxpZWQuXCIsXG5cdFwiQEBBcHBhcmVudC1SZWZsZWN0YW5jZV9TY2FsZS1GYWN0b3JfdGFnMEBAXCI6IFwiWW91ciBhcHBhcmVudCByZWZsZWN0YW5jZSBvdXRwdXQgdmFsdWUgY2FuIGJlIGV4cHJlc3NlZCBhcyBhbiBpbnRlZ2VyLiBUaGUgc2NhbGluZyBmYWN0b3IgaXMgbXVsdGlwbGllZCBieSB0aGUgYWxiZWRvIHRvIGNvbnZlcnQgYWxsIGZsb2F0aW5nLXBvaW50IHZhbHVlcyBpbnRvIGludGVnZXIgdmFsdWVzLlwiLFxuXHRcIkBAQXBwYXJlbnQtUmVmbGVjdGFuY2VfU2NhbGUtRmFjdG9yX3RhZzFAQFwiOiBcIklmIHRoZSBzY2FsZSBmYWN0b3IgaXMgZWl0aGVyICR7MH0gb3Igbm90IHNwZWNpZmllZCwgZGVmYXVsdCBzY2FsaW5nIHdpbGwgYmUgYXBwbGllZCBkZXBlbmRpbmcgb24gdGhlIHBpeGVsIHR5cGUgb2YgdGhlIGlucHV0IGRhdGE6XCIsXG5cdFwiQEBBcHBhcmVudC1SZWZsZWN0YW5jZV9TY2FsZS1GYWN0b3JfdGFnMkBAXCI6IFwiRm9yIDE2LWJpdCB1bnNpZ25lZCBkYXRhIHR5cGVzLCB0aGUgZGVmYXVsdCBzY2FsZSBmYWN0b3IgaXMgNTAsMDAwLlwiLFxuXHRcIkBAQXBwYXJlbnQtUmVmbGVjdGFuY2VfU2NhbGUtRmFjdG9yX3RhZzNAQFwiOiBcIkZvciA4LWJpdCB1bnNpZ25lZCBkYXRhIHR5cGVzLCBkZWZhdWx0IHNjYWxlIGZhY3RvciBpcyAyNTUuXCIsXG5cdFwiQEBBcHBhcmVudC1SZWZsZWN0YW5jZV9TY2FsZS1GYWN0b3JfdGFnNEBAXCI6IFwiVGhlIHNjYWxpbmcgZmFjdG9yIGlzIGFsd2F5cyBhcHBsaWVkIHdoZW4gdGhlIG91dHB1dCBpcyBhcHBhcmVudCByZWZsZWN0YW5jZS4gTm8gc2NhbGluZyBpcyBhcHBsaWVkIHdoZW4gdGhlIG91dHB1dCBpcyBhbGJlZG8uXCIsXG5cdFwiQEBBcHBhcmVudC1SZWZsZWN0YW5jZV9TdW4tRWxldmF0aW9uX3RhZzBAQFwiOiBcIlRoaXMgaXMgc3VuIGVsZXZhdGlvbiB2YWx1ZSwgZXhwcmVzc2VkIGluIGRlZ3JlZXMuIFRoaXMgd2lsbCBiZSBwb3B1bGF0ZWQgYnkgdGhlIHN5c3RlbSBpZiB0aGUgYXBwcm9wcmlhdGUgaW5mb3JtYXRpb24gY2FuIGJlIHJlYWQgZnJvbSB0aGUgbWV0YWRhdGEuIFlvdSBjYW4gbWFudWFsbHkgc2V0IG9yIGVkaXQgdGhpcyB2YWx1ZS5cIixcblx0XCJAQEFyZ1N0YXRpc3RpY3NfTWF4X3RhZzBAQFwiOiBcIlRoZSBtYXhpbXVtIHZhbHVlIHRoYXQgeW91IHNldCBpcyB0aGUgaGlnaGVzdCB2YWx1ZSBlcXVhbCB0byBvciBsZXNzIHRoYW4gdGhlIGVuZCBvZiB0aGUgZHVyYXRpb24uXCIsXG5cdFwiQEBBcmdTdGF0aXN0aWNzX01heF90YWcxQEBcIjogXCJUaGlzIGlucHV0IGlzIG9ubHkgYXBwbGljYWJsZSB3aGVuIHRoZSBtZXRob2QgaXMgRHVyYXRpb24uXCIsXG5cdFwiQEBBcmdTdGF0aXN0aWNzX01ldGhvZF90YWcwQEBcIjogXCJTZWxlY3QgdGhlIHN0YXRpc3RpY3MgbWV0aG9kIHRvIGNhbGN1bGF0ZTpcIixcblx0XCJAQEFyZ1N0YXRpc3RpY3NfTWV0aG9kX3RhZzFAQFwiOiBcIkFyZyBNYXgtLVRoZSBhcmd1bWVudCBvZiB0aGUgbWF4aW11bSwgd2hpY2ggcmV0dXJucyB0aGUgJHtCYW5kIGluZGV4fSBmb3Igd2hpY2ggdGhlIGdpdmVuIHBpeGVsIGF0dGFpbnMgaXRzIG1pbmltdW0gdmFsdWUgZnJvbSBhbGwgdGhlIGJhbmRzLiBBbGwgcmFzdGVyIGJhbmRzIGZyb20gZXZlcnkgaW5wdXQgcmFzdGVyIGFyZSBhc3NpZ25lZCBhIDAtYmFzZWQgaW5jcmVtZW50YWwgYmFuZCBpbmRleCwgd2hpY2ggaXMgZmlyc3Qgb3JkZXJlZCBieSB0aGUgaW5wdXQgcmFzdGVyIGluZGV4LCBhbmQgdGhlbiBieSB0aGUgcmVsYXRpdmUgYmFuZCBvcmRlciB3aXRoaW4gZWFjaCBpbnB1dCByYXN0ZXIuXCIsXG5cdFwiQEBBcmdTdGF0aXN0aWNzX01ldGhvZF90YWcyQEBcIjogXCJBcmcgTWVkaWFuLS1UaGUgYXJndW1lbnQgb2YgdGhlIG1lZGlhbiwgd2hpY2ggcmV0dXJucyB0aGUgJHtCYW5kIGluZGV4fSBmb3Igd2hpY2ggdGhlIGdpdmVuIHBpeGVsIGF0dGFpbnMgdGhlIG1lZGlhbiB2YWx1ZSBvZiB2YWx1ZXMgZnJvbSBhbGwgYmFuZHMuXCIsXG5cdFwiQEBBcmdTdGF0aXN0aWNzX01ldGhvZF90YWczQEBcIjogXCJBcmcgTWluLS1UaGUgYXJndW1lbnQgb2YgdGhlIG1pbmltdW0sIHdoaWNoIHJldHVybnMgdGhlICR7QmFuZCBpbmRleH0gZm9yIHdoaWNoIHRoZSBnaXZlbiBwaXhlbCBhdHRhaW5zIGl0cyBtaW5pbXVtIHZhbHVlIGZyb20gYWxsIHRoZSBiYW5kcy5cIixcblx0XCJAQEFyZ1N0YXRpc3RpY3NfTWV0aG9kX3RhZzRAQFwiOiBcIkR1cmF0aW9uLS1UaGUgRHVyYXRpb24gbWV0aG9kIGZpbmRzIHRoZSBsb25nZXN0IGNvbnNlY3V0aXZlIGVsZW1lbnRzIGluIHRoZSBhcnJheSwgd2hlcmUgZWFjaCBlbGVtZW50IGhhcyBhIHZhbHVlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byA8c3Ryb25nPk1pbjwvc3Ryb25nPiBhbmQgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIDxzdHJvbmc+TWF4PC9zdHJvbmc+LCBhbmQgdGhlbiByZXR1cm5zIGl0cyBsZW5ndGguXCIsXG5cdFwiQEBBcmdTdGF0aXN0aWNzX01pbl90YWcwQEBcIjogXCJUaGUgbWluaW11bSB2YWx1ZSB0aGF0IHlvdSBzZXQgaXMgdGhlIGxvd2VzdCB2YWx1ZSBlcXVhbCB0byBvciBncmVhdGVyIHRoYW4gdGhlIGJlZ2lubmluZyBvZiB0aGUgZHVyYXRpb24uXCIsXG5cdFwiQEBBcmdTdGF0aXN0aWNzX01pbl90YWcxQEBcIjogXCJUaGlzIGlucHV0IGlzIG9ubHkgYXBwbGljYWJsZSB3aGVuIHRoZSBtZXRob2QgaXMgRHVyYXRpb24uXCIsXG5cdFwiQEBBcmdTdGF0aXN0aWNzX1Jhc3RlcnNfdGFnMEBAXCI6IFwiVGhlIGlucHV0IHJhc3RlciB0aGF0IHlvdSB3aWxsIHBlcmZvcm0gdGhlIHZhcmlvdXMgc3RhdGlzdGljYWwgbWV0aG9kcyB1cG9uLlwiLFxuXHRcIkBAQXJnU3RhdGlzdGljc19VbmRlZmluZWQtQ2xhc3NfdGFnMEBAXCI6IFwiQSBjb25zdGFudCBpbnB1dCB0aGF0IHdpbGwgYmUgcmV0dXJuZWQgd2hlbiBubyBkZWZpbml0aXZlIG1heGltdW0sIG1pbmltdW0sIG9yIG1lZGlhbiBjYW4gYmUgYXR0YWluZWQuIFRoZSBtb3N0IGNvbW1vbiBzY2VuYXJpbyBpcyB3aGVuIHRoZSBtYXhpbXVtIG9yIG1pbmltdW0gdmFsdWUgb2NjdXJzIG1vcmUgdGhhbiBvbmNlIGFtb25nIHZhbHVlcyBmcm9tIGFsbCBiYW5kcy4gVGhlIGRlZmF1bHQgdmFsdWUgZm9yIHRoZSB1bmRlZmluZWQgY29uc3RhbnQgaXMgMTAwLlwiLFxuXHRcIkBAQXJnU3RhdGlzdGljc19VbmRlZmluZWQtQ2xhc3NfdGFnMUBAXCI6IFwiVGhlIHVuZGVmaW5lZCBjbGFzcyBpcyBvbmx5IGFwcGxpY2FibGUgd2hlbiB0aGUgbWV0aG9kIGlzIDxzdHJvbmc+QXJnTWF4PC9zdHJvbmc+LCA8c3Ryb25nPkFyZ01pbjwvc3Ryb25nPiwgb3IgPHN0cm9uZz5BcmdNZWRpYW48L3N0cm9uZz4uXCIsXG5cdFwiQEBBcmdTdGF0aXN0aWNzX2lnbm9yZW5vZGF0YV90YWcwQEBcIjogXCJEZW5vdGVzIHdoZXRoZXIgTm9EYXRhIHZhbHVlcyBhcmUgaWdub3JlZCBpbiB0aGUgc3RhdGlzdGljYWwgY2FsY3VsYXRpb24uXCIsXG5cdFwiQEBBcmdTdGF0aXN0aWNzX2lnbm9yZW5vZGF0YV90YWcxQEBcIjogXCJDaGVja2VkLS1UaGUgYW5hbHlzaXMgd2lsbCBpbmNsdWRlIGFsbCB2YWxpZCBwaXhlbHMgaW4gdGhlIGlucHV0IHJhc3RlcnMgYW5kIGlnbm9yZSBhbnkgTm9EYXRhIHBpeGVscy5cIixcblx0XCJAQEFyZ1N0YXRpc3RpY3NfaWdub3Jlbm9kYXRhX3RhZzJAQFwiOiBcIlVuY2hlY2tlZC0tVGhlIGFuYWx5c2lzIHdpbGwgcmVzdWx0IGluIE5vRGF0YSBpZiB0aGVyZSBhcmUgYW55IE5vRGF0YSB2YWx1ZXMgZm9yIHRoZSBwaXhlbHMgaW4gdGhlIGlucHV0IHJhc3RlcnMuIFRoaXMgaXMgdGhlIGRlZmF1bHQuXCIsXG5cdFwiQEBBcml0aG1ldGljX0NlbGxzaXplLVR5cGVfdGFnMEBAXCI6IFwiQ2hvb3NlIHdoaWNoIGNlbGwgc2l6ZSB0byB1c2UgaW4gdGhlIG91dHB1dCByYXN0ZXIuIElmIGFsbCB0aGUgaW5wdXQgY2VsbCBzaXplcyBhcmUgdGhlIHNhbWUsIGFsbCB0aGUgb3B0aW9ucyB3aWxsIHlpZWxkIHRoZSBzYW1lIHJlc3VsdHMuXCIsXG5cdFwiQEBBcml0aG1ldGljX0NlbGxzaXplLVR5cGVfdGFnMUBAXCI6IFwiRmlyc3QgT2YtLVVzZSB0aGUgZmlyc3QgY2VsbCBzaXplIG9mIHRoZSBpbnB1dCByYXN0ZXJzLlwiLFxuXHRcIkBAQXJpdGhtZXRpY19DZWxsc2l6ZS1UeXBlX3RhZzJAQFwiOiBcIkxhc3QgT2YtLVVzZSB0aGUgbGFzdCBjZWxsIHNpemUgb2YgdGhlIGlucHV0IHJhc3RlcnMuXCIsXG5cdFwiQEBBcml0aG1ldGljX0NlbGxzaXplLVR5cGVfdGFnM0BAXCI6IFwiTWF4IE9mLS1Vc2UgdGhlIGxhcmdlc3QgY2VsbCBzaXplIG9mIGFsbCB0aGUgaW5wdXQgcmFzdGVycy4gVGhpcyBpcyB0aGUgZGVmYXVsdC5cIixcblx0XCJAQEFyaXRobWV0aWNfQ2VsbHNpemUtVHlwZV90YWc0QEBcIjogXCJNZWFuIE9mLS1Vc2UgdGhlIG1lYW4gY2VsbCBzaXplIG9mIGFsbCB0aGUgaW5wdXQgcmFzdGVycy5cIixcblx0XCJAQEFyaXRobWV0aWNfQ2VsbHNpemUtVHlwZV90YWc1QEBcIjogXCJNaW4gT2YtLVVzZSB0aGUgc21hbGxlc3QgY2VsbCBzaXplIG9mIGFsbCB0aGUgaW5wdXQgcmFzdGVycy5cIixcblx0XCJAQEFyaXRobWV0aWNfRXh0ZW50LVR5cGVfdGFnMEBAXCI6IFwiQ2hvb3NlIHdoaWNoIGV4dGVudCBzaG91bGQgYmUgdXNlZCBpbiB0aGUgb3V0cHV0IHJhc3RlcjpcIixcblx0XCJAQEFyaXRobWV0aWNfRXh0ZW50LVR5cGVfdGFnMUBAXCI6IFwiRmlyc3QgT2YtLVVzZSB0aGUgZXh0ZW50IG9mIHRoZSBmaXJzdCBpbnB1dCByYXN0ZXIgdG8gZGV0ZXJtaW5lIHRoZSBwcm9jZXNzaW5nIGV4dGVudC5cIixcblx0XCJAQEFyaXRobWV0aWNfRXh0ZW50LVR5cGVfdGFnMkBAXCI6IFwiSW50ZXJzZWN0aW9uIE9mLS1Vc2UgdGhlIGV4dGVudCBvZiB0aGUgb3ZlcmxhcHBpbmcgcGl4ZWxzIHRvIGRldGVybWluZSB0aGUgcHJvY2Vzc2luZyBleHRlbnQuIFRoaXMgaXMgdGhlIGRlZmF1bHQuXCIsXG5cdFwiQEBBcml0aG1ldGljX0V4dGVudC1UeXBlX3RhZzNAQFwiOiBcIkxhc3QgT2YtLVVzZSB0aGUgZXh0ZW50IG9mIHRoZSBsYXN0IGlucHV0IHJhc3RlciB0byBkZXRlcm1pbmUgdGhlIHByb2Nlc3NpbmcgZXh0ZW50LlwiLFxuXHRcIkBAQXJpdGhtZXRpY19FeHRlbnQtVHlwZV90YWc0QEBcIjogXCJVbmlvbiBPZi0tVXNlIHRoZSBleHRlbnQgb2YgYWxsIHRoZSByYXN0ZXJzIHRvIGRldGVybWluZSB0aGUgcHJvY2Vzc2luZyBleHRlbnQuXCIsXG5cdFwiQEBBcml0aG1ldGljX09wZXJhdGlvbl90YWcwQEBcIjogXCJUaGUgYXJpdGhtZXRpYyBvcGVyYXRpb24gdG8gYmUgcGVyZm9ybWVkIGJldHdlZW4gdGhlIHR3byBpbnB1dCByYXN0ZXJzLlwiLFxuXHRcIkBAQXJpdGhtZXRpY19PcGVyYXRpb25fdGFnMUBAXCI6IFwiVGhlIG9wdGlvbnMgYXJlIGFzIGZvbGxvd3M6XCIsXG5cdFwiQEBBcml0aG1ldGljX09wZXJhdGlvbl90YWcyQEBcIjogXCI8c3Ryb25nPkRpdmlkZTwvc3Ryb25nPi0tT3V0cHV0cyB0aGUgZGl2aXNpYmxlIHJlc3VsdCBiZXR3ZWVuIHRoZSBjb3JyZXNwb25kaW5nIHBpeGVsIHZhbHVlcyBmb3IgZWFjaCByYXN0ZXIuXCIsXG5cdFwiQEBBcml0aG1ldGljX09wZXJhdGlvbl90YWc0QEBcIjogXCI8c3Ryb25nPk1pbnVzPC9zdHJvbmc+LS1PdXRwdXRzIHRoZSBkaWZmZXJlbmNlIGJldHdlZW4gdGhlIGNvcnJlc3BvbmRpbmcgcGl4ZWwgdmFsdWVzIGZvciBlYWNoIHJhc3Rlci4gVGhpcyBjYW4gYmUgdXNlZCB0byBjYWxjdWxhdGUgY2hhbmdlIGRldGVjdGlvbi5cIixcblx0XCJAQEFyaXRobWV0aWNfT3BlcmF0aW9uX3RhZzZAQFwiOiBcIjxzdHJvbmc+TW9kZTwvc3Ryb25nPi0tT3V0cHV0cyB0aGUgcGl4ZWwgdmFsdWUgb2YgYWxsIG92ZXJsYXBwaW5nIHBpeGVscyB0aGF0IG9jY3VycyB0aGUgbW9zdC4gRm9yIGV4YW1wbGUsIGlmIHRoZXJlIGFyZSBzaXggYmFuZHMgaW4gYSByYXN0ZXIsIHRoZXJlIHdpbGwgYmUgc2l4IG92ZXJsYXBwaW5nIHBpeGVscy4gRm9yIHRoZSB2YWx1ZXMgNCwgNSwgNiwgNCwgNywgOSwgdGhlIG1vZGUgdmFsdWUgaXMgNC5cIixcblx0XCJAQEFyaXRobWV0aWNfT3BlcmF0aW9uX3RhZzhAQFwiOiBcIjxzdHJvbmc+TXVsdGlwbHk8L3N0cm9uZz4tLU91dHB1dHMgdGhlIHByb2R1Y3Qgb2YgdGhlIGNvcnJlc3BvbmRpbmcgcGl4ZWwgdmFsdWVzIGZvciBlYWNoIHJhc3Rlci4gVGhpcyBjYW4gYmUgdXNlZCB0byBwZXJmb3JtIHNvbWUgY29zdCBmdW5jdGlvbnMuXCIsXG5cdFwiQEBBcml0aG1ldGljX09wZXJhdGlvbl90YWcxMEBAXCI6IFwiPHN0cm9uZz5QbHVzPC9zdHJvbmc+LS1PdXRwdXRzIHRoZSBzdW0gb2YgYWxsIHRoZSBjb3JyZXNwb25kaW5nIHBpeGVsIHZhbHVlcyBmb3IgZWFjaCByYXN0ZXIuXCIsXG5cdFwiQEBBcml0aG1ldGljX09wZXJhdGlvbl90YWcxMkBAXCI6IFwiPHN0cm9uZz5Qb3dlcjwvc3Ryb25nPi0tT3V0cHV0cyB0aGUgcHJvZHVjdCBvZiB0aGUgY29ycmVzcG9uZGluZyBwaXhlbCB2YWx1ZXMgcmFpc2VkIHRvIHRoZSBwb3dlciBvZiB0aGUgaW5wdXQgcmFzdGVyIG9yIHNjYWxhci5cIixcblx0XCJAQEFyaXRobWV0aWNfUmFzdGVyX3RhZzBAQFwiOiBcIlRoZSBmaXJzdCBpbnB1dCByYXN0ZXIgZGF0YXNldC5cIixcblx0XCJAQEFyaXRobWV0aWNfUmFzdGVyMl90YWcwQEBcIjogXCJUaGUgc2Vjb25kIGlucHV0IHJhc3RlciBkYXRhc2V0LlwiLFxuXHRcIkBAQVNpbl9DZWxsc2l6ZS1UeXBlX3RhZzBAQFwiOiBcIkNob29zZSB3aGljaCBjZWxsIHNpemUgdG8gdXNlIGluIHRoZSBvdXRwdXQgcmFzdGVyLiBJZiBhbGwgdGhlIGlucHV0IGNlbGwgc2l6ZXMgYXJlIHRoZSBzYW1lLCBhbGwgdGhlIG9wdGlvbnMgd2lsbCB5aWVsZCB0aGUgc2FtZSByZXN1bHRzLlwiLFxuXHRcIkBAQVNpbl9DZWxsc2l6ZS1UeXBlX3RhZzFAQFwiOiBcIkZpcnN0IE9mLS1Vc2UgdGhlIGZpcnN0IGNlbGwgc2l6ZSBvZiB0aGUgaW5wdXQgcmFzdGVycy5cIixcblx0XCJAQEFTaW5fQ2VsbHNpemUtVHlwZV90YWcyQEBcIjogXCJMYXN0IE9mLS1Vc2UgdGhlIGxhc3QgY2VsbCBzaXplIG9mIHRoZSBpbnB1dCByYXN0ZXJzLlwiLFxuXHRcIkBAQVNpbl9DZWxsc2l6ZS1UeXBlX3RhZzNAQFwiOiBcIk1heCBPZi0tVXNlIHRoZSBsYXJnZXN0IGNlbGwgc2l6ZSBvZiBhbGwgdGhlIGlucHV0IHJhc3RlcnMuIFRoaXMgaXMgdGhlIGRlZmF1bHQuXCIsXG5cdFwiQEBBU2luX0NlbGxzaXplLVR5cGVfdGFnNEBAXCI6IFwiTWVhbiBPZi0tVXNlIHRoZSBtZWFuIGNlbGwgc2l6ZSBvZiBhbGwgdGhlIGlucHV0IHJhc3RlcnMuXCIsXG5cdFwiQEBBU2luX0NlbGxzaXplLVR5cGVfdGFnNUBAXCI6IFwiTWluIE9mLS1Vc2UgdGhlIHNtYWxsZXN0IGNlbGwgc2l6ZSBvZiBhbGwgdGhlIGlucHV0IHJhc3RlcnMuXCIsXG5cdFwiQEBBU2luX0V4dGVudC1UeXBlX3RhZzBAQFwiOiBcIkNob29zZSB3aGljaCBleHRlbnQgc2hvdWxkIGJlIHVzZWQgaW4gdGhlIG91dHB1dCByYXN0ZXI6XCIsXG5cdFwiQEBBU2luX0V4dGVudC1UeXBlX3RhZzFAQFwiOiBcIkZpcnN0IE9mLS1Vc2UgdGhlIGV4dGVudCBvZiB0aGUgZmlyc3QgaW5wdXQgcmFzdGVyIHRvIGRldGVybWluZSB0aGUgcHJvY2Vzc2luZyBleHRlbnQuXCIsXG5cdFwiQEBBU2luX0V4dGVudC1UeXBlX3RhZzJAQFwiOiBcIkludGVyc2VjdGlvbiBPZi0tVXNlIHRoZSBleHRlbnQgb2YgdGhlIG92ZXJsYXBwaW5nIHBpeGVscyB0byBkZXRlcm1pbmUgdGhlIHByb2Nlc3NpbmcgZXh0ZW50LiBUaGlzIGlzIHRoZSBkZWZhdWx0LlwiLFxuXHRcIkBAQVNpbl9FeHRlbnQtVHlwZV90YWczQEBcIjogXCJMYXN0IE9mLS1Vc2UgdGhlIGV4dGVudCBvZiB0aGUgbGFzdCBpbnB1dCByYXN0ZXIgdG8gZGV0ZXJtaW5lIHRoZSBwcm9jZXNzaW5nIGV4dGVudC5cIixcblx0XCJAQEFTaW5fRXh0ZW50LVR5cGVfdGFnNEBAXCI6IFwiVW5pb24gT2YtLVVzZSB0aGUgZXh0ZW50IG9mIGFsbCB0aGUgcmFzdGVycyB0byBkZXRlcm1pbmUgdGhlIHByb2Nlc3NpbmcgZXh0ZW50LlwiLFxuXHRcIkBAQVNpbl9SYXN0ZXJfdGFnMEBAXCI6IFwiVGhlIGlucHV0IGZvciB3aGljaCB0byBjYWxjdWxhdGUgdGhlIGludmVyc2Ugc2luZSB2YWx1ZXMuXCIsXG5cdFwiQEBBU2luSF9DZWxsc2l6ZS1UeXBlX3RhZzBAQFwiOiBcIkNob29zZSB3aGljaCBjZWxsIHNpemUgdG8gdXNlIGluIHRoZSBvdXRwdXQgcmFzdGVyLiBJZiBhbGwgdGhlIGlucHV0IGNlbGwgc2l6ZXMgYXJlIHRoZSBzYW1lLCBhbGwgdGhlIG9wdGlvbnMgd2lsbCB5aWVsZCB0aGUgc2FtZSByZXN1bHRzLlwiLFxuXHRcIkBAQVNpbkhfQ2VsbHNpemUtVHlwZV90YWcxQEBcIjogXCJGaXJzdCBPZi0tVXNlIHRoZSBmaXJzdCBjZWxsIHNpemUgb2YgdGhlIGlucHV0IHJhc3RlcnMuXCIsXG5cdFwiQEBBU2luSF9DZWxsc2l6ZS1UeXBlX3RhZzJAQFwiOiBcIkxhc3QgT2YtLVVzZSB0aGUgbGFzdCBjZWxsIHNpemUgb2YgdGhlIGlucHV0IHJhc3RlcnMuXCIsXG5cdFwiQEBBU2luSF9DZWxsc2l6ZS1UeXBlX3RhZzNAQFwiOiBcIk1heCBPZi0tVXNlIHRoZSBsYXJnZXN0IGNlbGwgc2l6ZSBvZiBhbGwgdGhlIGlucHV0IHJhc3RlcnMuIFRoaXMgaXMgdGhlIGRlZmF1bHQuXCIsXG5cdFwiQEBBU2luSF9DZWxsc2l6ZS1UeXBlX3RhZzRAQFwiOiBcIk1lYW4gT2YtLVVzZSB0aGUgbWVhbiBjZWxsIHNpemUgb2YgYWxsIHRoZSBpbnB1dCByYXN0ZXJzLlwiLFxuXHRcIkBAQVNpbkhfQ2VsbHNpemUtVHlwZV90YWc1QEBcIjogXCJNaW4gT2YtLVVzZSB0aGUgc21hbGxlc3QgY2VsbCBzaXplIG9mIGFsbCB0aGUgaW5wdXQgcmFzdGVycy5cIixcblx0XCJAQEFTaW5IX0V4dGVudC1UeXBlX3RhZzBAQFwiOiBcIkNob29zZSB3aGljaCBleHRlbnQgc2hvdWxkIGJlIHVzZWQgaW4gdGhlIG91dHB1dCByYXN0ZXI6XCIsXG5cdFwiQEBBU2luSF9FeHRlbnQtVHlwZV90YWcxQEBcIjogXCJGaXJzdCBPZi0tVXNlIHRoZSBleHRlbnQgb2YgdGhlIGZpcnN0IGlucHV0IHJhc3RlciB0byBkZXRlcm1pbmUgdGhlIHByb2Nlc3NpbmcgZXh0ZW50LlwiLFxuXHRcIkBAQVNpbkhfRXh0ZW50LVR5cGVfdGFnMkBAXCI6IFwiSW50ZXJzZWN0aW9uIE9mLS1Vc2UgdGhlIGV4dGVudCBvZiB0aGUgb3ZlcmxhcHBpbmcgcGl4ZWxzIHRvIGRldGVybWluZSB0aGUgcHJvY2Vzc2luZyBleHRlbnQuIFRoaXMgaXMgdGhlIGRlZmF1bHQuXCIsXG5cdFwiQEBBU2luSF9FeHRlbnQtVHlwZV90YWczQEBcIjogXCJMYXN0IE9mLS1Vc2UgdGhlIGV4dGVudCBvZiB0aGUgbGFzdCBpbnB1dCByYXN0ZXIgdG8gZGV0ZXJtaW5lIHRoZSBwcm9jZXNzaW5nIGV4dGVudC5cIixcblx0XCJAQEFTaW5IX0V4dGVudC1UeXBlX3RhZzRAQFwiOiBcIlVuaW9uIE9mLS1Vc2UgdGhlIGV4dGVudCBvZiBhbGwgdGhlIHJhc3RlcnMgdG8gZGV0ZXJtaW5lIHRoZSBwcm9jZXNzaW5nIGV4dGVudC5cIixcblx0XCJAQEFTaW5IX1Jhc3Rlcl90YWcwQEBcIjogXCJUaGUgaW5wdXQgZm9yIHdoaWNoIHRvIGNhbGN1bGF0ZSB0aGUgaW52ZXJzZSBoeXBlcmJvbGljIHNpbmUgdmFsdWVzLlwiLFxuXHRcIkBAQXNwZWN0X1Jhc3Rlcl90YWcwQEBcIjogXCJUaGUgaW5wdXQgREVNIHVzZWQgdG8gZGVyaXZlIHRoZSBhc3BlY3QgZGF0YXNldC5cIixcblx0XCJAQEFzcGVjdC1TbG9wZV9SYXN0ZXJfdGFnMEBAXCI6IFwiVGhlIGlucHV0IERFTS5cIixcblx0XCJAQEFzcGVjdC1TbG9wZV9aLUZhY3Rvcl90YWcwQEBcIjogXCJBIHNjYWxpbmcgZmFjdG9yIHVzZWQgdG8gY29udmVydCB0aGUgZWxldmF0aW9uIHZhbHVlcyBmb3IgdGhlIGZvbGxvd2luZyB0d28gcHVycG9zZXM6XCIsXG5cdFwiQEBBc3BlY3QtU2xvcGVfWi1GYWN0b3JfdGFnMUBAXCI6IFwiQ29udmVydCB0aGUgZWxldmF0aW9uIHVuaXRzIChzdWNoIGFzIG1ldGVycyBvciBmZWV0KSB0byB0aGUgaG9yaXpvbnRhbCBjb29yZGluYXRlIHVuaXRzIG9mIHRoZSBkYXRhc2V0LCB3aGljaCBtYXkgYmUgZmVldCwgbWV0ZXJzLCBvciBkZWdyZWVzLlwiLFxuXHRcIkBAQXNwZWN0LVNsb3BlX1otRmFjdG9yX3RhZzJAQFwiOiBcIkFkZCB2ZXJ0aWNhbCBleGFnZ2VyYXRpb24gZm9yIHZpc3VhbCBlZmZlY3QuXCIsXG5cdFwiQEBBVGFuX0NlbGxzaXplLVR5cGVfdGFnMEBAXCI6IFwiQ2hvb3NlIHdoaWNoIGNlbGwgc2l6ZSB0byB1c2UgaW4gdGhlIG91dHB1dCByYXN0ZXIuIElmIGFsbCB0aGUgaW5wdXQgY2VsbCBzaXplcyBhcmUgdGhlIHNhbWUsIGFsbCB0aGUgb3B0aW9ucyB3aWxsIHlpZWxkIHRoZSBzYW1lIHJlc3VsdHMuXCIsXG5cdFwiQEBBVGFuX0NlbGxzaXplLVR5cGVfdGFnMUBAXCI6IFwiRmlyc3QgT2YtLVVzZSB0aGUgZmlyc3QgY2VsbCBzaXplIG9mIHRoZSBpbnB1dCByYXN0ZXJzLlwiLFxuXHRcIkBAQVRhbl9DZWxsc2l6ZS1UeXBlX3RhZzJAQFwiOiBcIkxhc3QgT2YtLVVzZSB0aGUgbGFzdCBjZWxsIHNpemUgb2YgdGhlIGlucHV0IHJhc3RlcnMuXCIsXG5cdFwiQEBBVGFuX0NlbGxzaXplLVR5cGVfdGFnM0BAXCI6IFwiTWF4IE9mLS1Vc2UgdGhlIGxhcmdlc3QgY2VsbCBzaXplIG9mIGFsbCB0aGUgaW5wdXQgcmFzdGVycy4gVGhpcyBpcyB0aGUgZGVmYXVsdC5cIixcblx0XCJAQEFUYW5fQ2VsbHNpemUtVHlwZV90YWc0QEBcIjogXCJNZWFuIE9mLS1Vc2UgdGhlIG1lYW4gY2VsbCBzaXplIG9mIGFsbCB0aGUgaW5wdXQgcmFzdGVycy5cIixcblx0XCJAQEFUYW5fQ2VsbHNpemUtVHlwZV90YWc1QEBcIjogXCJNaW4gT2YtLVVzZSB0aGUgc21hbGxlc3QgY2VsbCBzaXplIG9mIGFsbCB0aGUgaW5wdXQgcmFzdGVycy5cIixcblx0XCJAQEFUYW5fRXh0ZW50LVR5cGVfdGFnMEBAXCI6IFwiQ2hvb3NlIHdoaWNoIGV4dGVudCBzaG91bGQgYmUgdXNlZCBpbiB0aGUgb3V0cHV0IHJhc3RlcjpcIixcblx0XCJAQEFUYW5fRXh0ZW50LVR5cGVfdGFnMUBAXCI6IFwiRmlyc3QgT2YtLVVzZSB0aGUgZXh0ZW50IG9mIHRoZSBmaXJzdCBpbnB1dCByYXN0ZXIgdG8gZGV0ZXJtaW5lIHRoZSBwcm9jZXNzaW5nIGV4dGVudC5cIixcblx0XCJAQEFUYW5fRXh0ZW50LVR5cGVfdGFnMkBAXCI6IFwiSW50ZXJzZWN0aW9uIE9mLS1Vc2UgdGhlIGV4dGVudCBvZiB0aGUgb3ZlcmxhcHBpbmcgcGl4ZWxzIHRvIGRldGVybWluZSB0aGUgcHJvY2Vzc2luZyBleHRlbnQuIFRoaXMgaXMgdGhlIGRlZmF1bHQuXCIsXG5cdFwiQEBBVGFuX0V4dGVudC1UeXBlX3RhZzNAQFwiOiBcIkxhc3QgT2YtLVVzZSB0aGUgZXh0ZW50IG9mIHRoZSBsYXN0IGlucHV0IHJhc3RlciB0byBkZXRlcm1pbmUgdGhlIHByb2Nlc3NpbmcgZXh0ZW50LlwiLFxuXHRcIkBAQVRhbl9FeHRlbnQtVHlwZV90YWc0QEBcIjogXCJVbmlvbiBPZi0tVXNlIHRoZSBleHRlbnQgb2YgYWxsIHRoZSByYXN0ZXJzIHRvIGRldGVybWluZSB0aGUgcHJvY2Vzc2luZyBleHRlbnQuXCIsXG5cdFwiQEBBVGFuX1Jhc3Rlcl90YWcwQEBcIjogXCJUaGUgaW5wdXQgZm9yIHdoaWNoIHRvIGNhbGN1bGF0ZSB0aGUgaW52ZXJzZSB0YW5nZW50IHZhbHVlcy5cIixcblx0XCJAQEFUYW4yX0NlbGxzaXplLVR5cGVfdGFnMEBAXCI6IFwiQ2hvb3NlIHdoaWNoIGNlbGwgc2l6ZSB0byB1c2UgaW4gdGhlIG91dHB1dCByYXN0ZXIuIElmIGFsbCB0aGUgaW5wdXQgY2VsbCBzaXplcyBhcmUgdGhlIHNhbWUsIGFsbCB0aGUgb3B0aW9ucyB3aWxsIHlpZWxkIHRoZSBzYW1lIHJlc3VsdHMuXCIsXG5cdFwiQEBBVGFuMl9DZWxsc2l6ZS1UeXBlX3RhZzFAQFwiOiBcIkZpcnN0IE9mLS1Vc2UgdGhlIGZpcnN0IGNlbGwgc2l6ZSBvZiB0aGUgaW5wdXQgcmFzdGVycy5cIixcblx0XCJAQEFUYW4yX0NlbGxzaXplLVR5cGVfdGFnMkBAXCI6IFwiTGFzdCBPZi0tVXNlIHRoZSBsYXN0IGNlbGwgc2l6ZSBvZiB0aGUgaW5wdXQgcmFzdGVycy5cIixcblx0XCJAQEFUYW4yX0NlbGxzaXplLVR5cGVfdGFnM0BAXCI6IFwiTWF4IE9mLS1Vc2UgdGhlIGxhcmdlc3QgY2VsbCBzaXplIG9mIGFsbCB0aGUgaW5wdXQgcmFzdGVycy4gVGhpcyBpcyB0aGUgZGVmYXVsdC5cIixcblx0XCJAQEFUYW4yX0NlbGxzaXplLVR5cGVfdGFnNEBAXCI6IFwiTWVhbiBPZi0tVXNlIHRoZSBtZWFuIGNlbGwgc2l6ZSBvZiBhbGwgdGhlIGlucHV0IHJhc3RlcnMuXCIsXG5cdFwiQEBBVGFuMl9DZWxsc2l6ZS1UeXBlX3RhZzVAQFwiOiBcIk1pbiBPZi0tVXNlIHRoZSBzbWFsbGVzdCBjZWxsIHNpemUgb2YgYWxsIHRoZSBpbnB1dCByYXN0ZXJzLlwiLFxuXHRcIkBAQVRhbjJfRXh0ZW50LVR5cGVfdGFnMEBAXCI6IFwiQ2hvb3NlIHdoaWNoIGV4dGVudCBzaG91bGQgYmUgdXNlZCBpbiB0aGUgb3V0cHV0IHJhc3RlcjpcIixcblx0XCJAQEFUYW4yX0V4dGVudC1UeXBlX3RhZzFAQFwiOiBcIkZpcnN0IE9mLS1Vc2UgdGhlIGV4dGVudCBvZiB0aGUgZmlyc3QgaW5wdXQgcmFzdGVyIHRvIGRldGVybWluZSB0aGUgcHJvY2Vzc2luZyBleHRlbnQuXCIsXG5cdFwiQEBBVGFuMl9FeHRlbnQtVHlwZV90YWcyQEBcIjogXCJJbnRlcnNlY3Rpb24gT2YtLVVzZSB0aGUgZXh0ZW50IG9mIHRoZSBvdmVybGFwcGluZyBwaXhlbHMgdG8gZGV0ZXJtaW5lIHRoZSBwcm9jZXNzaW5nIGV4dGVudC4gVGhpcyBpcyB0aGUgZGVmYXVsdC5cIixcblx0XCJAQEFUYW4yX0V4dGVudC1UeXBlX3RhZzNAQFwiOiBcIkxhc3QgT2YtLVVzZSB0aGUgZXh0ZW50IG9mIHRoZSBsYXN0IGlucHV0IHJhc3RlciB0byBkZXRlcm1pbmUgdGhlIHByb2Nlc3NpbmcgZXh0ZW50LlwiLFxuXHRcIkBAQVRhbjJfRXh0ZW50LVR5cGVfdGFnNEBAXCI6IFwiVW5pb24gT2YtLVVzZSB0aGUgZXh0ZW50IG9mIGFsbCB0aGUgcmFzdGVycyB0byBkZXRlcm1pbmUgdGhlIHByb2Nlc3NpbmcgZXh0ZW50LlwiLFxuXHRcIkBAQVRhbjJfUmFzdGVyX3RhZzBAQFwiOiBcIlRoZSBpbnB1dCB0aGF0IHNwZWNpZmllcyB0aGUgbnVtZXJhdG9yLCBvciB5IHZhbHVlLCB0byB1c2Ugd2hlbiBjYWxjdWxhdGluZyB0aGUgaW52ZXJzZSB0YW5nZW50LlwiLFxuXHRcIkBAQVRhbjJfUmFzdGVyMl90YWcwQEBcIjogXCJUaGUgaW5wdXQgdGhhdCBzcGVjaWZpZXMgdGhlIGRlbm9taW5hdG9yLCBvciB4IHZhbHVlLCB0byB1c2Ugd2hlbiBjYWxjdWxhdGluZyB0aGUgaW52ZXJzZSB0YW5nZW50LlwiLFxuXHRcIkBAQVRhbkhfQ2VsbHNpemUtVHlwZV90YWcwQEBcIjogXCJDaG9vc2Ugd2hpY2ggY2VsbCBzaXplIHRvIHVzZSBpbiB0aGUgb3V0cHV0IHJhc3Rlci4gSWYgYWxsIHRoZSBpbnB1dCBjZWxsIHNpemVzIGFyZSB0aGUgc2FtZSwgYWxsIHRoZSBvcHRpb25zIHdpbGwgeWllbGQgdGhlIHNhbWUgcmVzdWx0cy5cIixcblx0XCJAQEFUYW5IX0NlbGxzaXplLVR5cGVfdGFnMUBAXCI6IFwiRmlyc3QgT2YtLVVzZSB0aGUgZmlyc3QgY2VsbCBzaXplIG9mIHRoZSBpbnB1dCByYXN0ZXJzLlwiLFxuXHRcIkBAQVRhbkhfQ2VsbHNpemUtVHlwZV90YWcyQEBcIjogXCJMYXN0IE9mLS1Vc2UgdGhlIGxhc3QgY2VsbCBzaXplIG9mIHRoZSBpbnB1dCByYXN0ZXJzLlwiLFxuXHRcIkBAQVRhbkhfQ2VsbHNpemUtVHlwZV90YWczQEBcIjogXCJNYXggT2YtLVVzZSB0aGUgbGFyZ2VzdCBjZWxsIHNpemUgb2YgYWxsIHRoZSBpbnB1dCByYXN0ZXJzLiBUaGlzIGlzIHRoZSBkZWZhdWx0LlwiLFxuXHRcIkBAQVRhbkhfQ2VsbHNpemUtVHlwZV90YWc0QEBcIjogXCJNZWFuIE9mLS1Vc2UgdGhlIG1lYW4gY2VsbCBzaXplIG9mIGFsbCB0aGUgaW5wdXQgcmFzdGVycy5cIixcblx0XCJAQEFUYW5IX0NlbGxzaXplLVR5cGVfdGFnNUBAXCI6IFwiTWluIE9mLS1Vc2UgdGhlIHNtYWxsZXN0IGNlbGwgc2l6ZSBvZiBhbGwgdGhlIGlucHV0IHJhc3RlcnMuXCIsXG5cdFwiQEBBVGFuSF9FeHRlbnQtVHlwZV90YWcwQEBcIjogXCJDaG9vc2Ugd2hpY2ggZXh0ZW50IHNob3VsZCBiZSB1c2VkIGluIHRoZSBvdXRwdXQgcmFzdGVyOlwiLFxuXHRcIkBAQVRhbkhfRXh0ZW50LVR5cGVfdGFnMUBAXCI6IFwiRmlyc3QgT2YtLVVzZSB0aGUgZXh0ZW50IG9mIHRoZSBmaXJzdCBpbnB1dCByYXN0ZXIgdG8gZGV0ZXJtaW5lIHRoZSBwcm9jZXNzaW5nIGV4dGVudC5cIixcblx0XCJAQEFUYW5IX0V4dGVudC1UeXBlX3RhZzJAQFwiOiBcIkludGVyc2VjdGlvbiBPZi0tVXNlIHRoZSBleHRlbnQgb2YgdGhlIG92ZXJsYXBwaW5nIHBpeGVscyB0byBkZXRlcm1pbmUgdGhlIHByb2Nlc3NpbmcgZXh0ZW50LiBUaGlzIGlzIHRoZSBkZWZhdWx0LlwiLFxuXHRcIkBAQVRhbkhfRXh0ZW50LVR5cGVfdGFnM0BAXCI6IFwiTGFzdCBPZi0tVXNlIHRoZSBleHRlbnQgb2YgdGhlIGxhc3QgaW5wdXQgcmFzdGVyIHRvIGRldGVybWluZSB0aGUgcHJvY2Vzc2luZyBleHRlbnQuXCIsXG5cdFwiQEBBVGFuSF9FeHRlbnQtVHlwZV90YWc0QEBcIjogXCJVbmlvbiBPZi0tVXNlIHRoZSBleHRlbnQgb2YgYWxsIHRoZSByYXN0ZXJzIHRvIGRldGVybWluZSB0aGUgcHJvY2Vzc2luZyBleHRlbnQuXCIsXG5cdFwiQEBBVGFuSF9SYXN0ZXJfdGFnMEBAXCI6IFwiVGhlIGlucHV0IGZvciB3aGljaCB0byBjYWxjdWxhdGUgdGhlIGludmVyc2UgaHlwZXJib2xpYyB0YW5nZW50IHZhbHVlcy5cIixcblx0XCJAQEF0dHJpYnV0ZS1UYWJsZV9SYXN0ZXJfdGFnMEBAXCI6IFwiVGhlIGlucHV0IHJhc3Rlci5cIixcblx0XCJAQEF0dHJpYnV0ZS1UYWJsZV9UYWJsZS1UeXBlX3RhZzBAQFwiOiBcIlRoZSBpbnB1dCBhdHRyaWJ1dGUgdGFibGUgY2FuIGJlIGVudGVyZWQgdXNpbmcgdGhlIDxzdHJvbmc+TWFudWFsPC9zdHJvbmc+IHR5cGUgd2hlcmUgeW91IGFzc2lnbiBhIGNsYXNzIG5hbWUgYW5kIGEgY29sb3IgdG8gZWFjaCB2YWx1ZSwgb3IgeW91IGNhbiByZWZlcmVuY2UgYW4gZXhpc3RpbmcgdGFibGUgd2hpY2ggY29tZXMgZnJvbSBhICR7LmRiZn0gZmlsZS5cIixcblx0XCJAQEJhbmQtQXJpdGhtZXRpY19CYW5kLUluZGV4ZXNfdGFnMEBAXCI6IFwiRGVmaW5lIHlvdXIgYmFuZCBhcml0aG1ldGljIGZvcm11bGEgaWYgeW91IGNob3NlIDxzdHJvbmc+VXNlciBEZWZpbmVkPC9zdHJvbmc+IGZvciB5b3VyIDxzdHJvbmc+TWV0aG9kPC9zdHJvbmc+LlwiLFxuXHRcIkBAQmFuZC1Bcml0aG1ldGljX0JhbmQtSW5kZXhlc190YWc1QEBcIjogXCJJZiB5b3UgY2hvc2UgYSBwcmVkZWZpbmVkIGluZGV4IGZvciB5b3VyIDxzdHJvbmc+TWV0aG9kPC9zdHJvbmc+LCBkZWZpbmUgdGhlIHByb3BlciBiYW5kcyBvZiB5b3VyIGlucHV0IHJhc3RlciBkYXRhc2V0IHRoYXQgY29ycmVzcG9uZCB0byB0aGUgaW5kZXguXCIsXG5cdFwiQEBCYW5kLUFyaXRobWV0aWNfTWV0aG9kX3RhZzBAQFwiOiBcIlRoZSB0eXBlIG9mIGJhbmQgYXJpdGhtZXRpYyBhbGdvcml0aG0geW91IHdhbnQgdG8gZGVwbG95LiBZb3UgY2FuIGRlZmluZSB5b3VyIGN1c3RvbSBhbGdvcml0aG0sIG9yIGNob29zZSBhIHByZWRlZmluZWQgaW5kZXguXCIsXG5cdFwiQEBCYW5kLUFyaXRobWV0aWNfTWV0aG9kX3RhZzFAQFwiOiBcIjxzdHJvbmc+QkFJPC9zdHJvbmc+LS1CdXJuIEFyZWEgSW5kZXhcIixcblx0XCJAQEJhbmQtQXJpdGhtZXRpY19NZXRob2RfdGFnMkBAXCI6IFwiPHN0cm9uZz5DSWc8L3N0cm9uZz4tLUNobG9yb3BoeWxsIEluZGV4IC0gR3JlZW5cIixcblx0XCJAQEJhbmQtQXJpdGhtZXRpY19NZXRob2RfdGFnM0BAXCI6IFwiPHN0cm9uZz5DSXJlPC9zdHJvbmc+LS1DaGxvcm9waHlsbCBJbmRleCAtIFJlZCBFZGdlXCIsXG5cdFwiQEBCYW5kLUFyaXRobWV0aWNfTWV0aG9kX3RhZzRAQFwiOiBcIjxzdHJvbmc+Q2xheSBNaW5lcmFsczwvc3Ryb25nPi0tQ2xheSBNaW5lcmFscyBSYXRpb1wiLFxuXHRcIkBAQmFuZC1Bcml0aG1ldGljX01ldGhvZF90YWc1QEBcIjogXCI8c3Ryb25nPkVWSTwvc3Ryb25nPi0tRW5oYW5jZWQgVmVnZXRhdGlvbiBJbmRleFwiLFxuXHRcIkBAQmFuZC1Bcml0aG1ldGljX01ldGhvZF90YWc2QEBcIjogXCI8c3Ryb25nPkZlcnJvdXMgTWluZXJhbHM8L3N0cm9uZz4tLUZlcnJvdXMgTWluZXJhbHMgUmF0aW9cIixcblx0XCJAQEJhbmQtQXJpdGhtZXRpY19NZXRob2RfdGFnN0BAXCI6IFwiPHN0cm9uZz5HRU1JPC9zdHJvbmc+LS1HbG9iYWwgRW52aXJvbm1lbnRhbCBNb25pdG9yaW5nIEluZGV4XCIsXG5cdFwiQEBCYW5kLUFyaXRobWV0aWNfTWV0aG9kX3RhZzhAQFwiOiBcIjxzdHJvbmc+R05EVkk8L3N0cm9uZz4tLUdyZWVuIE5vcm1hbGl6ZWQgRGlmZmVyZW5jZSBWZWdldGF0aW9uIEluZGV4XCIsXG5cdFwiQEBCYW5kLUFyaXRobWV0aWNfTWV0aG9kX3RhZzlAQFwiOiBcIjxzdHJvbmc+R1ZJIChMYW5kc2F0IFRNKTwvc3Ryb25nPi0tR3JlZW4gVmVnZXRhdGlvbiBJbmRleCBMYW5kc2F0IFRNXCIsXG5cdFwiQEBCYW5kLUFyaXRobWV0aWNfTWV0aG9kX3RhZzEwQEBcIjogXCI8c3Ryb25nPklyb24gT3hpZGU8L3N0cm9uZz4tLUlyb24gT3hpZGUgUmF0aW9cIixcblx0XCJAQEJhbmQtQXJpdGhtZXRpY19NZXRob2RfdGFnMTFAQFwiOiBcIjxzdHJvbmc+TU5EV0k8L3N0cm9uZz4tLU1vZGlmaWVkIE5vcm1hbGl6ZWQgRGlmZmVyZW5jZSBXYXRlciBJbmRleFwiLFxuXHRcIkBAQmFuZC1Bcml0aG1ldGljX01ldGhvZF90YWcxMkBAXCI6IFwiPHN0cm9uZz5NVFZJMjwvc3Ryb25nPi0tTW9kaWZpZWQgVHJpYW5ndWxhdGVkIFZlZ2V0YXRpb24gSW5kZXggKHNlY29uZCBpdGVyYXRpb24pXCIsXG5cdFwiQEBCYW5kLUFyaXRobWV0aWNfTWV0aG9kX3RhZzEzQEBcIjogXCI8c3Ryb25nPk1vZGlmaWVkIFNBVkk8L3N0cm9uZz4tLU1vZGlmaWVkIFNvaWwgQWRqdXN0ZWQgVmVnZXRhdGlvbiBJbmRleFwiLFxuXHRcIkBAQmFuZC1Bcml0aG1ldGljX01ldGhvZF90YWcxNEBAXCI6IFwiPHN0cm9uZz5OQlI8L3N0cm9uZz4tLU5vcm1hbGl6ZWQgQnVybiBSYXRpbyBJbmRleFwiLFxuXHRcIkBAQmFuZC1Bcml0aG1ldGljX01ldGhvZF90YWcxNUBAXCI6IFwiPHN0cm9uZz5OREJJPC9zdHJvbmc+LS1Ob3JtYWxpemVkIERpZmZlcmVuY2UgQnVpbHQtdXAgSW5kZXhcIixcblx0XCJAQEJhbmQtQXJpdGhtZXRpY19NZXRob2RfdGFnMTZAQFwiOiBcIjxzdHJvbmc+TkRNSTwvc3Ryb25nPi0tTm9ybWFsaXplZCBEaWZmZXJlbmNlIE1vaXN0dXJlIEluZGV4XCIsXG5cdFwiQEBCYW5kLUFyaXRobWV0aWNfTWV0aG9kX3RhZzE3QEBcIjogXCI8c3Ryb25nPk5EU0k8L3N0cm9uZz4tLU5vcm1hbGl6ZWQgRGlmZmVyZW5jZSBTbm93IEluZGV4XCIsXG5cdFwiQEBCYW5kLUFyaXRobWV0aWNfTWV0aG9kX3RhZzE4QEBcIjogXCI8c3Ryb25nPk5EVkk8L3N0cm9uZz4tLU5vcm1hbGl6ZWQgRGlmZmVyZW5jZSBWZWdldGF0aW9uIEluZGV4XCIsXG5cdFwiQEBCYW5kLUFyaXRobWV0aWNfTWV0aG9kX3RhZzE5QEBcIjogXCI8c3Ryb25nPk5EVklyZTwvc3Ryb25nPi0tUmVkLUVkZ2UgTm9ybWFsaXplZCBEaWZmZXJlbmNlIFZlZ2V0YXRpb24gSW5kZXhcIixcblx0XCJAQEJhbmQtQXJpdGhtZXRpY19NZXRob2RfdGFnMjBAQFwiOiBcIjxzdHJvbmc+TkRXSTwvc3Ryb25nPi0tTm9ybWFsaXplZCBEaWZmZXJlbmNlIFdhdGVyIEluZGV4XCIsXG5cdFwiQEBCYW5kLUFyaXRobWV0aWNfTWV0aG9kX3RhZzIxQEBcIjogXCI8c3Ryb25nPlBWSTwvc3Ryb25nPi0tUGVycGVuZGljdWxhciBWZWdldGF0aW9uIEluZGV4XCIsXG5cdFwiQEBCYW5kLUFyaXRobWV0aWNfTWV0aG9kX3RhZzIyQEBcIjogXCI8c3Ryb25nPlJUVklDb3JlPC9zdHJvbmc+LS1SZWQtRWRnZSBUcmlhbmd1bGF0ZWQgVmVnZXRhdGlvbiBJbmRleFwiLFxuXHRcIkBAQmFuZC1Bcml0aG1ldGljX01ldGhvZF90YWcyM0BAXCI6IFwiPHN0cm9uZz5TQVZJPC9zdHJvbmc+LS1Tb2lsIEFkanVzdGVkIFZlZ2V0YXRpb24gSW5kZXhcIixcblx0XCJAQEJhbmQtQXJpdGhtZXRpY19NZXRob2RfdGFnMjRAQFwiOiBcIjxzdHJvbmc+U1I8L3N0cm9uZz4tLVNpbXBsZSBSYXRpb1wiLFxuXHRcIkBAQmFuZC1Bcml0aG1ldGljX01ldGhvZF90YWcyNUBAXCI6IFwiPHN0cm9uZz5TUnJlPC9zdHJvbmc+LS1SZWQtRWRnZSBTaW1wbGUgUmF0aW9cIixcblx0XCJAQEJhbmQtQXJpdGhtZXRpY19NZXRob2RfdGFnMjZAQFwiOiBcIjxzdHJvbmc+U3VsdGFuJ3MgRm9ybXVsYTwvc3Ryb25nPi0tU3VsdGFuJ3MgRm9ybXVsYVwiLFxuXHRcIkBAQmFuZC1Bcml0aG1ldGljX01ldGhvZF90YWcyN0BAXCI6IFwiPHN0cm9uZz5UcmFuc2Zvcm1lZCBTQVZJPC9zdHJvbmc+LS1UcmFuc2Zvcm1lZCBTb2lsIEFkanVzdGVkIFZlZ2V0YXRpb24gSW5kZXhcIixcblx0XCJAQEJhbmQtQXJpdGhtZXRpY19NZXRob2RfdGFnMjhAQFwiOiBcIjxzdHJvbmc+VXNlciBEZWZpbmVkPC9zdHJvbmc+LS1BbGxvd3MgeW91IHRvIGRlZmluZSB5b3VyIGN1c3RvbSBiYW5kIGFyaXRobWV0aWMgZXhwcmVzc2lvbi5cIixcblx0XCJAQEJhbmQtQXJpdGhtZXRpY19NZXRob2RfdGFnMjlAQFwiOiBcIjxzdHJvbmc+VkFSSTwvc3Ryb25nPi0tVmlzaWJsZSBBdG1vc3BoZXJpY2FsbHkgUmVzaXN0YW50IEluZGV4XCIsXG5cdFwiQEBCYW5kLUFyaXRobWV0aWNfTWV0aG9kX3RhZzMwQEBcIjogXCI8c3Ryb25nPldORFdJPC9zdHJvbmc+LS1XZWlnaHRlZCBOb3JtYWxpemVkIERpZmZlcmVuY2UgV2F0ZXIgSW5kZXhcIixcblx0XCJAQEJhbmQtQXJpdGhtZXRpY19SYXN0ZXJfdGFnMEBAXCI6IFwiVGhlIGlucHV0IHJhc3Rlci5cIixcblx0XCJAQEJpbmFyeS1UaHJlc2hvbGRpbmdfUmFzdGVyX3RhZzBAQFwiOiBcIlRoZSBpbnB1dCByYXN0ZXIuXCIsXG5cdFwiQEBCaXR3aXNlLUFuZF9DZWxsc2l6ZS1UeXBlX3RhZzBAQFwiOiBcIkNob29zZSB3aGljaCBjZWxsIHNpemUgdG8gdXNlIGluIHRoZSBvdXRwdXQgcmFzdGVyLiBJZiBhbGwgdGhlIGlucHV0IGNlbGwgc2l6ZXMgYXJlIHRoZSBzYW1lLCBhbGwgdGhlIG9wdGlvbnMgd2lsbCB5aWVsZCB0aGUgc2FtZSByZXN1bHRzLlwiLFxuXHRcIkBAQml0d2lzZS1BbmRfQ2VsbHNpemUtVHlwZV90YWcxQEBcIjogXCJGaXJzdCBPZi0tVXNlIHRoZSBmaXJzdCBjZWxsIHNpemUgb2YgdGhlIGlucHV0IHJhc3RlcnMuXCIsXG5cdFwiQEBCaXR3aXNlLUFuZF9DZWxsc2l6ZS1UeXBlX3RhZzJAQFwiOiBcIkxhc3QgT2YtLVVzZSB0aGUgbGFzdCBjZWxsIHNpemUgb2YgdGhlIGlucHV0IHJhc3RlcnMuXCIsXG5cdFwiQEBCaXR3aXNlLUFuZF9DZWxsc2l6ZS1UeXBlX3RhZzNAQFwiOiBcIk1heCBPZi0tVXNlIHRoZSBsYXJnZXN0IGNlbGwgc2l6ZSBvZiBhbGwgdGhlIGlucHV0IHJhc3RlcnMuIFRoaXMgaXMgdGhlIGRlZmF1bHQuXCIsXG5cdFwiQEBCaXR3aXNlLUFuZF9DZWxsc2l6ZS1UeXBlX3RhZzRAQFwiOiBcIk1lYW4gT2YtLVVzZSB0aGUgbWVhbiBjZWxsIHNpemUgb2YgYWxsIHRoZSBpbnB1dCByYXN0ZXJzLlwiLFxuXHRcIkBAQml0d2lzZS1BbmRfQ2VsbHNpemUtVHlwZV90YWc1QEBcIjogXCJNaW4gT2YtLVVzZSB0aGUgc21hbGxlc3QgY2VsbCBzaXplIG9mIGFsbCB0aGUgaW5wdXQgcmFzdGVycy5cIixcblx0XCJAQEJpdHdpc2UtQW5kX0V4dGVudC1UeXBlX3RhZzBAQFwiOiBcIkNob29zZSB3aGljaCBleHRlbnQgc2hvdWxkIGJlIHVzZWQgaW4gdGhlIG91dHB1dCByYXN0ZXI6XCIsXG5cdFwiQEBCaXR3aXNlLUFuZF9FeHRlbnQtVHlwZV90YWcxQEBcIjogXCJGaXJzdCBPZi0tVXNlIHRoZSBleHRlbnQgb2YgdGhlIGZpcnN0IGlucHV0IHJhc3RlciB0byBkZXRlcm1pbmUgdGhlIHByb2Nlc3NpbmcgZXh0ZW50LlwiLFxuXHRcIkBAQml0d2lzZS1BbmRfRXh0ZW50LVR5cGVfdGFnMkBAXCI6IFwiSW50ZXJzZWN0aW9uIE9mLS1Vc2UgdGhlIGV4dGVudCBvZiB0aGUgb3ZlcmxhcHBpbmcgcGl4ZWxzIHRvIGRldGVybWluZSB0aGUgcHJvY2Vzc2luZyBleHRlbnQuIFRoaXMgaXMgdGhlIGRlZmF1bHQuXCIsXG5cdFwiQEBCaXR3aXNlLUFuZF9FeHRlbnQtVHlwZV90YWczQEBcIjogXCJMYXN0IE9mLS1Vc2UgdGhlIGV4dGVudCBvZiB0aGUgbGFzdCBpbnB1dCByYXN0ZXIgdG8gZGV0ZXJtaW5lIHRoZSBwcm9jZXNzaW5nIGV4dGVudC5cIixcblx0XCJAQEJpdHdpc2UtQW5kX0V4dGVudC1UeXBlX3RhZzRAQFwiOiBcIlVuaW9uIE9mLS1Vc2UgdGhlIGV4dGVudCBvZiBhbGwgdGhlIHJhc3RlcnMgdG8gZGV0ZXJtaW5lIHRoZSBwcm9jZXNzaW5nIGV4dGVudC5cIixcblx0XCJAQEJpdHdpc2UtQW5kX1Jhc3Rlcl90YWcwQEBcIjogXCJUaGUgZmlyc3QgaW5wdXQgdG8gdXNlIGluIHRoaXMgYml0d2lzZSBvcGVyYXRpb24uXCIsXG5cdFwiQEBCaXR3aXNlLUFuZF9SYXN0ZXJfdGFnMUBAXCI6IFwiQSBjb25zdGFudCB2YWx1ZSBjYW4gYmUgdXNlZCBhcyBhbiBpbnB1dCBmb3IgdGhpcyBwYXJhbWV0ZXIsIHByb3ZpZGVkIGEgcmFzdGVyIGlzIHNwZWNpZmllZCBmb3IgdGhlIG90aGVyIHBhcmFtZXRlci5cIixcblx0XCJAQEJpdHdpc2UtQW5kX1Jhc3RlcjJfdGFnMEBAXCI6IFwiVGhlIHNlY29uZCBpbnB1dCB0byB1c2UgaW4gdGhpcyBiaXR3aXNlIG9wZXJhdGlvbi5cIixcblx0XCJAQEJpdHdpc2UtQW5kX1Jhc3RlcjJfdGFnMUBAXCI6IFwiQSBjb25zdGFudCB2YWx1ZSBjYW4gYmUgdXNlZCBhcyBhbiBpbnB1dCBmb3IgdGhpcyBwYXJhbWV0ZXIsIHByb3ZpZGVkIGEgcmFzdGVyIGlzIHNwZWNpZmllZCBmb3IgdGhlIG90aGVyIHBhcmFtZXRlci5cIixcblx0XCJAQEJpdHdpc2UtTGVmdC1TaGlmdF9DZWxsc2l6ZS1UeXBlX3RhZzBAQFwiOiBcIkNob29zZSB3aGljaCBjZWxsIHNpemUgdG8gdXNlIGluIHRoZSBvdXRwdXQgcmFzdGVyLiBJZiBhbGwgdGhlIGlucHV0IGNlbGwgc2l6ZXMgYXJlIHRoZSBzYW1lLCBhbGwgdGhlIG9wdGlvbnMgd2lsbCB5aWVsZCB0aGUgc2FtZSByZXN1bHRzLlwiLFxuXHRcIkBAQml0d2lzZS1MZWZ0LVNoaWZ0X0NlbGxzaXplLVR5cGVfdGFnMUBAXCI6IFwiRmlyc3QgT2YtLVVzZSB0aGUgZmlyc3QgY2VsbCBzaXplIG9mIHRoZSBpbnB1dCByYXN0ZXJzLlwiLFxuXHRcIkBAQml0d2lzZS1MZWZ0LVNoaWZ0X0NlbGxzaXplLVR5cGVfdGFnMkBAXCI6IFwiTGFzdCBPZi0tVXNlIHRoZSBsYXN0IGNlbGwgc2l6ZSBvZiB0aGUgaW5wdXQgcmFzdGVycy5cIixcblx0XCJAQEJpdHdpc2UtTGVmdC1TaGlmdF9DZWxsc2l6ZS1UeXBlX3RhZzNAQFwiOiBcIk1heCBPZi0tVXNlIHRoZSBsYXJnZXN0IGNlbGwgc2l6ZSBvZiBhbGwgdGhlIGlucHV0IHJhc3RlcnMuIFRoaXMgaXMgdGhlIGRlZmF1bHQuXCIsXG5cdFwiQEBCaXR3aXNlLUxlZnQtU2hpZnRfQ2VsbHNpemUtVHlwZV90YWc0QEBcIjogXCJNZWFuIE9mLS1Vc2UgdGhlIG1lYW4gY2VsbCBzaXplIG9mIGFsbCB0aGUgaW5wdXQgcmFzdGVycy5cIixcblx0XCJAQEJpdHdpc2UtTGVmdC1TaGlmdF9DZWxsc2l6ZS1UeXBlX3RhZzVAQFwiOiBcIk1pbiBPZi0tVXNlIHRoZSBzbWFsbGVzdCBjZWxsIHNpemUgb2YgYWxsIHRoZSBpbnB1dCByYXN0ZXJzLlwiLFxuXHRcIkBAQml0d2lzZS1MZWZ0LVNoaWZ0X0V4dGVudC1UeXBlX3RhZzBAQFwiOiBcIkNob29zZSB3aGljaCBleHRlbnQgc2hvdWxkIGJlIHVzZWQgaW4gdGhlIG91dHB1dCByYXN0ZXI6XCIsXG5cdFwiQEBCaXR3aXNlLUxlZnQtU2hpZnRfRXh0ZW50LVR5cGVfdGFnMUBAXCI6IFwiRmlyc3QgT2YtLVVzZSB0aGUgZXh0ZW50IG9mIHRoZSBmaXJzdCBpbnB1dCByYXN0ZXIgdG8gZGV0ZXJtaW5lIHRoZSBwcm9jZXNzaW5nIGV4dGVudC5cIixcblx0XCJAQEJpdHdpc2UtTGVmdC1TaGlmdF9FeHRlbnQtVHlwZV90YWcyQEBcIjogXCJJbnRlcnNlY3Rpb24gT2YtLVVzZSB0aGUgZXh0ZW50IG9mIHRoZSBvdmVybGFwcGluZyBwaXhlbHMgdG8gZGV0ZXJtaW5lIHRoZSBwcm9jZXNzaW5nIGV4dGVudC4gVGhpcyBpcyB0aGUgZGVmYXVsdC5cIixcblx0XCJAQEJpdHdpc2UtTGVmdC1TaGlmdF9FeHRlbnQtVHlwZV90YWczQEBcIjogXCJMYXN0IE9mLS1Vc2UgdGhlIGV4dGVudCBvZiB0aGUgbGFzdCBpbnB1dCByYXN0ZXIgdG8gZGV0ZXJtaW5lIHRoZSBwcm9jZXNzaW5nIGV4dGVudC5cIixcblx0XCJAQEJpdHdpc2UtTGVmdC1TaGlmdF9FeHRlbnQtVHlwZV90YWc0QEBcIjogXCJVbmlvbiBPZi0tVXNlIHRoZSBleHRlbnQgb2YgYWxsIHRoZSByYXN0ZXJzIHRvIGRldGVybWluZSB0aGUgcHJvY2Vzc2luZyBleHRlbnQuXCIsXG5cdFwiQEBCaXR3aXNlLUxlZnQtU2hpZnRfUmFzdGVyX3RhZzBAQFwiOiBcIlRoZSBpbnB1dCBvbiB3aGljaCB0byBwZXJmb3JtIHRoZSBzaGlmdC5cIixcblx0XCJAQEJpdHdpc2UtTGVmdC1TaGlmdF9SYXN0ZXJfdGFnMUBAXCI6IFwiQSBjb25zdGFudCB2YWx1ZSBjYW4gYmUgdXNlZCBhcyBhbiBpbnB1dCBmb3IgdGhpcyBwYXJhbWV0ZXIsIHByb3ZpZGVkIGEgcmFzdGVyIGlzIHNwZWNpZmllZCBmb3IgdGhlIG90aGVyIHBhcmFtZXRlci5cIixcblx0XCJAQEJpdHdpc2UtTGVmdC1TaGlmdF9SYXN0ZXIyX3RhZzBAQFwiOiBcIlRoZSBpbnB1dCBkZWZpbmluZyB0aGUgbnVtYmVyIG9mIHBvc2l0aW9ucyB0byBzaGlmdCB0aGUgYml0cy5cIixcblx0XCJAQEJpdHdpc2UtTGVmdC1TaGlmdF9SYXN0ZXIyX3RhZzFAQFwiOiBcIkEgY29uc3RhbnQgdmFsdWUgY2FuIGJlIHVzZWQgYXMgYW4gaW5wdXQgZm9yIHRoaXMgcGFyYW1ldGVyLCBwcm92aWRlZCBhIHJhc3RlciBpcyBzcGVjaWZpZWQgZm9yIHRoZSBvdGhlciBwYXJhbWV0ZXIuXCIsXG5cdFwiQEBCaXR3aXNlLU5vdF9DZWxsc2l6ZS1UeXBlX3RhZzBAQFwiOiBcIkNob29zZSB3aGljaCBjZWxsIHNpemUgdG8gdXNlIGluIHRoZSBvdXRwdXQgcmFzdGVyLiBJZiBhbGwgdGhlIGlucHV0IGNlbGwgc2l6ZXMgYXJlIHRoZSBzYW1lLCBhbGwgdGhlIG9wdGlvbnMgd2lsbCB5aWVsZCB0aGUgc2FtZSByZXN1bHRzLlwiLFxuXHRcIkBAQml0d2lzZS1Ob3RfQ2VsbHNpemUtVHlwZV90YWcxQEBcIjogXCJGaXJzdCBPZi0tVXNlIHRoZSBmaXJzdCBjZWxsIHNpemUgb2YgdGhlIGlucHV0IHJhc3RlcnMuXCIsXG5cdFwiQEBCaXR3aXNlLU5vdF9DZWxsc2l6ZS1UeXBlX3RhZzJAQFwiOiBcIkxhc3QgT2YtLVVzZSB0aGUgbGFzdCBjZWxsIHNpemUgb2YgdGhlIGlucHV0IHJhc3RlcnMuXCIsXG5cdFwiQEBCaXR3aXNlLU5vdF9DZWxsc2l6ZS1UeXBlX3RhZzNAQFwiOiBcIk1heCBPZi0tVXNlIHRoZSBsYXJnZXN0IGNlbGwgc2l6ZSBvZiBhbGwgdGhlIGlucHV0IHJhc3RlcnMuIFRoaXMgaXMgdGhlIGRlZmF1bHQuXCIsXG5cdFwiQEBCaXR3aXNlLU5vdF9DZWxsc2l6ZS1UeXBlX3RhZzRAQFwiOiBcIk1lYW4gT2YtLVVzZSB0aGUgbWVhbiBjZWxsIHNpemUgb2YgYWxsIHRoZSBpbnB1dCByYXN0ZXJzLlwiLFxuXHRcIkBAQml0d2lzZS1Ob3RfQ2VsbHNpemUtVHlwZV90YWc1QEBcIjogXCJNaW4gT2YtLVVzZSB0aGUgc21hbGxlc3QgY2VsbCBzaXplIG9mIGFsbCB0aGUgaW5wdXQgcmFzdGVycy5cIixcblx0XCJAQEJpdHdpc2UtTm90X0V4dGVudC1UeXBlX3RhZzBAQFwiOiBcIkNob29zZSB3aGljaCBleHRlbnQgc2hvdWxkIGJlIHVzZWQgaW4gdGhlIG91dHB1dCByYXN0ZXI6XCIsXG5cdFwiQEBCaXR3aXNlLU5vdF9FeHRlbnQtVHlwZV90YWcxQEBcIjogXCJGaXJzdCBPZi0tVXNlIHRoZSBleHRlbnQgb2YgdGhlIGZpcnN0IGlucHV0IHJhc3RlciB0byBkZXRlcm1pbmUgdGhlIHByb2Nlc3NpbmcgZXh0ZW50LlwiLFxuXHRcIkBAQml0d2lzZS1Ob3RfRXh0ZW50LVR5cGVfdGFnMkBAXCI6IFwiSW50ZXJzZWN0aW9uIE9mLS1Vc2UgdGhlIGV4dGVudCBvZiB0aGUgb3ZlcmxhcHBpbmcgcGl4ZWxzIHRvIGRldGVybWluZSB0aGUgcHJvY2Vzc2luZyBleHRlbnQuIFRoaXMgaXMgdGhlIGRlZmF1bHQuXCIsXG5cdFwiQEBCaXR3aXNlLU5vdF9FeHRlbnQtVHlwZV90YWczQEBcIjogXCJMYXN0IE9mLS1Vc2UgdGhlIGV4dGVudCBvZiB0aGUgbGFzdCBpbnB1dCByYXN0ZXIgdG8gZGV0ZXJtaW5lIHRoZSBwcm9jZXNzaW5nIGV4dGVudC5cIixcblx0XCJAQEJpdHdpc2UtTm90X0V4dGVudC1UeXBlX3RhZzRAQFwiOiBcIlVuaW9uIE9mLS1Vc2UgdGhlIGV4dGVudCBvZiBhbGwgdGhlIHJhc3RlcnMgdG8gZGV0ZXJtaW5lIHRoZSBwcm9jZXNzaW5nIGV4dGVudC5cIixcblx0XCJAQEJpdHdpc2UtTm90X1Jhc3Rlcl90YWcwQEBcIjogXCJUaGUgaW5wdXQgcmFzdGVyIG9uIHdoaWNoIHRvIHBlcmZvcm0gdGhlIEJpdHdpc2UgTm90IChjb21wbGVtZW50KSBvcGVyYXRpb24uXCIsXG5cdFwiQEBCaXR3aXNlLU9yX0NlbGxzaXplLVR5cGVfdGFnMEBAXCI6IFwiQ2hvb3NlIHdoaWNoIGNlbGwgc2l6ZSB0byB1c2UgaW4gdGhlIG91dHB1dCByYXN0ZXIuIElmIGFsbCB0aGUgaW5wdXQgY2VsbCBzaXplcyBhcmUgdGhlIHNhbWUsIGFsbCB0aGUgb3B0aW9ucyB3aWxsIHlpZWxkIHRoZSBzYW1lIHJlc3VsdHMuXCIsXG5cdFwiQEBCaXR3aXNlLU9yX0NlbGxzaXplLVR5cGVfdGFnMUBAXCI6IFwiRmlyc3QgT2YtLVVzZSB0aGUgZmlyc3QgY2VsbCBzaXplIG9mIHRoZSBpbnB1dCByYXN0ZXJzLlwiLFxuXHRcIkBAQml0d2lzZS1Pcl9DZWxsc2l6ZS1UeXBlX3RhZzJAQFwiOiBcIkxhc3QgT2YtLVVzZSB0aGUgbGFzdCBjZWxsIHNpemUgb2YgdGhlIGlucHV0IHJhc3RlcnMuXCIsXG5cdFwiQEBCaXR3aXNlLU9yX0NlbGxzaXplLVR5cGVfdGFnM0BAXCI6IFwiTWF4IE9mLS1Vc2UgdGhlIGxhcmdlc3QgY2VsbCBzaXplIG9mIGFsbCB0aGUgaW5wdXQgcmFzdGVycy4gVGhpcyBpcyB0aGUgZGVmYXVsdC5cIixcblx0XCJAQEJpdHdpc2UtT3JfQ2VsbHNpemUtVHlwZV90YWc0QEBcIjogXCJNZWFuIE9mLS1Vc2UgdGhlIG1lYW4gY2VsbCBzaXplIG9mIGFsbCB0aGUgaW5wdXQgcmFzdGVycy5cIixcblx0XCJAQEJpdHdpc2UtT3JfQ2VsbHNpemUtVHlwZV90YWc1QEBcIjogXCJNaW4gT2YtLVVzZSB0aGUgc21hbGxlc3QgY2VsbCBzaXplIG9mIGFsbCB0aGUgaW5wdXQgcmFzdGVycy5cIixcblx0XCJAQEJpdHdpc2UtT3JfRXh0ZW50LVR5cGVfdGFnMEBAXCI6IFwiQ2hvb3NlIHdoaWNoIGV4dGVudCBzaG91bGQgYmUgdXNlZCBpbiB0aGUgb3V0cHV0IHJhc3RlcjpcIixcblx0XCJAQEJpdHdpc2UtT3JfRXh0ZW50LVR5cGVfdGFnMUBAXCI6IFwiRmlyc3QgT2YtLVVzZSB0aGUgZXh0ZW50IG9mIHRoZSBmaXJzdCBpbnB1dCByYXN0ZXIgdG8gZGV0ZXJtaW5lIHRoZSBwcm9jZXNzaW5nIGV4dGVudC5cIixcblx0XCJAQEJpdHdpc2UtT3JfRXh0ZW50LVR5cGVfdGFnMkBAXCI6IFwiSW50ZXJzZWN0aW9uIE9mLS1Vc2UgdGhlIGV4dGVudCBvZiB0aGUgb3ZlcmxhcHBpbmcgcGl4ZWxzIHRvIGRldGVybWluZSB0aGUgcHJvY2Vzc2luZyBleHRlbnQuIFRoaXMgaXMgdGhlIGRlZmF1bHQuXCIsXG5cdFwiQEBCaXR3aXNlLU9yX0V4dGVudC1UeXBlX3RhZzNAQFwiOiBcIkxhc3QgT2YtLVVzZSB0aGUgZXh0ZW50IG9mIHRoZSBsYXN0IGlucHV0IHJhc3RlciB0byBkZXRlcm1pbmUgdGhlIHByb2Nlc3NpbmcgZXh0ZW50LlwiLFxuXHRcIkBAQml0d2lzZS1Pcl9FeHRlbnQtVHlwZV90YWc0QEBcIjogXCJVbmlvbiBPZi0tVXNlIHRoZSBleHRlbnQgb2YgYWxsIHRoZSByYXN0ZXJzIHRvIGRldGVybWluZSB0aGUgcHJvY2Vzc2luZyBleHRlbnQuXCIsXG5cdFwiQEBCaXR3aXNlLU9yX1Jhc3Rlcl90YWcwQEBcIjogXCJUaGUgZmlyc3QgaW5wdXQgdG8gdXNlIGluIHRoaXMgYml0d2lzZSBvcGVyYXRpb24uXCIsXG5cdFwiQEBCaXR3aXNlLU9yX1Jhc3Rlcl90YWcxQEBcIjogXCJBIGNvbnN0YW50IHZhbHVlIGNhbiBiZSB1c2VkIGFzIGFuIGlucHV0IGZvciB0aGlzIHBhcmFtZXRlciwgcHJvdmlkZWQgYSByYXN0ZXIgaXMgc3BlY2lmaWVkIGZvciB0aGUgb3RoZXIgcGFyYW1ldGVyLlwiLFxuXHRcIkBAQml0d2lzZS1Pcl9SYXN0ZXIyX3RhZzBAQFwiOiBcIlRoZSBzZWNvbmQgaW5wdXQgdG8gdXNlIGluIHRoaXMgYml0d2lzZSBvcGVyYXRpb24uXCIsXG5cdFwiQEBCaXR3aXNlLU9yX1Jhc3RlcjJfdGFnMUBAXCI6IFwiQSBjb25zdGFudCB2YWx1ZSBjYW4gYmUgdXNlZCBhcyBhbiBpbnB1dCBmb3IgdGhpcyBwYXJhbWV0ZXIsIHByb3ZpZGVkIGEgcmFzdGVyIGlzIHNwZWNpZmllZCBmb3IgdGhlIG90aGVyIHBhcmFtZXRlci5cIixcblx0XCJAQEJpdHdpc2UtUmlnaHQtU2hpZnRfQ2VsbHNpemUtVHlwZV90YWcwQEBcIjogXCJDaG9vc2Ugd2hpY2ggY2VsbCBzaXplIHRvIHVzZSBpbiB0aGUgb3V0cHV0IHJhc3Rlci4gSWYgYWxsIHRoZSBpbnB1dCBjZWxsIHNpemVzIGFyZSB0aGUgc2FtZSwgYWxsIHRoZSBvcHRpb25zIHdpbGwgeWllbGQgdGhlIHNhbWUgcmVzdWx0cy5cIixcblx0XCJAQEJpdHdpc2UtUmlnaHQtU2hpZnRfQ2VsbHNpemUtVHlwZV90YWcxQEBcIjogXCJGaXJzdCBPZi0tVXNlIHRoZSBmaXJzdCBjZWxsIHNpemUgb2YgdGhlIGlucHV0IHJhc3RlcnMuXCIsXG5cdFwiQEBCaXR3aXNlLVJpZ2h0LVNoaWZ0X0NlbGxzaXplLVR5cGVfdGFnMkBAXCI6IFwiTGFzdCBPZi0tVXNlIHRoZSBsYXN0IGNlbGwgc2l6ZSBvZiB0aGUgaW5wdXQgcmFzdGVycy5cIixcblx0XCJAQEJpdHdpc2UtUmlnaHQtU2hpZnRfQ2VsbHNpemUtVHlwZV90YWczQEBcIjogXCJNYXggT2YtLVVzZSB0aGUgbGFyZ2VzdCBjZWxsIHNpemUgb2YgYWxsIHRoZSBpbnB1dCByYXN0ZXJzLiBUaGlzIGlzIHRoZSBkZWZhdWx0LlwiLFxuXHRcIkBAQml0d2lzZS1SaWdodC1TaGlmdF9DZWxsc2l6ZS1UeXBlX3RhZzRAQFwiOiBcIk1lYW4gT2YtLVVzZSB0aGUgbWVhbiBjZWxsIHNpemUgb2YgYWxsIHRoZSBpbnB1dCByYXN0ZXJzLlwiLFxuXHRcIkBAQml0d2lzZS1SaWdodC1TaGlmdF9DZWxsc2l6ZS1UeXBlX3RhZzVAQFwiOiBcIk1pbiBPZi0tVXNlIHRoZSBzbWFsbGVzdCBjZWxsIHNpemUgb2YgYWxsIHRoZSBpbnB1dCByYXN0ZXJzLlwiLFxuXHRcIkBAQml0d2lzZS1SaWdodC1TaGlmdF9FeHRlbnQtVHlwZV90YWcwQEBcIjogXCJDaG9vc2Ugd2hpY2ggZXh0ZW50IHNob3VsZCBiZSB1c2VkIGluIHRoZSBvdXRwdXQgcmFzdGVyOlwiLFxuXHRcIkBAQml0d2lzZS1SaWdodC1TaGlmdF9FeHRlbnQtVHlwZV90YWcxQEBcIjogXCJGaXJzdCBPZi0tVXNlIHRoZSBleHRlbnQgb2YgdGhlIGZpcnN0IGlucHV0IHJhc3RlciB0byBkZXRlcm1pbmUgdGhlIHByb2Nlc3NpbmcgZXh0ZW50LlwiLFxuXHRcIkBAQml0d2lzZS1SaWdodC1TaGlmdF9FeHRlbnQtVHlwZV90YWcyQEBcIjogXCJJbnRlcnNlY3Rpb24gT2YtLVVzZSB0aGUgZXh0ZW50IG9mIHRoZSBvdmVybGFwcGluZyBwaXhlbHMgdG8gZGV0ZXJtaW5lIHRoZSBwcm9jZXNzaW5nIGV4dGVudC4gVGhpcyBpcyB0aGUgZGVmYXVsdC5cIixcblx0XCJAQEJpdHdpc2UtUmlnaHQtU2hpZnRfRXh0ZW50LVR5cGVfdGFnM0BAXCI6IFwiTGFzdCBPZi0tVXNlIHRoZSBleHRlbnQgb2YgdGhlIGxhc3QgaW5wdXQgcmFzdGVyIHRvIGRldGVybWluZSB0aGUgcHJvY2Vzc2luZyBleHRlbnQuXCIsXG5cdFwiQEBCaXR3aXNlLVJpZ2h0LVNoaWZ0X0V4dGVudC1UeXBlX3RhZzRAQFwiOiBcIlVuaW9uIE9mLS1Vc2UgdGhlIGV4dGVudCBvZiBhbGwgdGhlIHJhc3RlcnMgdG8gZGV0ZXJtaW5lIHRoZSBwcm9jZXNzaW5nIGV4dGVudC5cIixcblx0XCJAQEJpdHdpc2UtUmlnaHQtU2hpZnRfUmFzdGVyX3RhZzBAQFwiOiBcIlRoZSBpbnB1dCBvbiB3aGljaCB0byBwZXJmb3JtIHRoZSBzaGlmdC5cIixcblx0XCJAQEJpdHdpc2UtUmlnaHQtU2hpZnRfUmFzdGVyX3RhZzFAQFwiOiBcIkEgY29uc3RhbnQgdmFsdWUgY2FuIGJlIHVzZWQgYXMgYW4gaW5wdXQgZm9yIHRoaXMgcGFyYW1ldGVyLCBwcm92aWRlZCBhIHJhc3RlciBpcyBzcGVjaWZpZWQgZm9yIHRoZSBvdGhlciBwYXJhbWV0ZXIuXCIsXG5cdFwiQEBCaXR3aXNlLVJpZ2h0LVNoaWZ0X1Jhc3RlcjJfdGFnMEBAXCI6IFwiVGhlIGlucHV0IGRlZmluaW5nIHRoZSBudW1iZXIgb2YgcG9zaXRpb25zIHRvIHNoaWZ0IHRoZSBiaXRzLlwiLFxuXHRcIkBAQml0d2lzZS1SaWdodC1TaGlmdF9SYXN0ZXIyX3RhZzFAQFwiOiBcIkEgY29uc3RhbnQgdmFsdWUgY2FuIGJlIHVzZWQgYXMgYW4gaW5wdXQgZm9yIHRoaXMgcGFyYW1ldGVyLCBwcm92aWRlZCBhIHJhc3RlciBpcyBzcGVjaWZpZWQgZm9yIHRoZSBvdGhlciBwYXJhbWV0ZXIuXCIsXG5cdFwiQEBCaXR3aXNlLVhvcl9DZWxsc2l6ZS1UeXBlX3RhZzBAQFwiOiBcIkNob29zZSB3aGljaCBjZWxsIHNpemUgdG8gdXNlIGluIHRoZSBvdXRwdXQgcmFzdGVyLiBJZiBhbGwgdGhlIGlucHV0IGNlbGwgc2l6ZXMgYXJlIHRoZSBzYW1lLCBhbGwgdGhlIG9wdGlvbnMgd2lsbCB5aWVsZCB0aGUgc2FtZSByZXN1bHRzLlwiLFxuXHRcIkBAQml0d2lzZS1Yb3JfQ2VsbHNpemUtVHlwZV90YWcxQEBcIjogXCJGaXJzdCBPZi0tVXNlIHRoZSBmaXJzdCBjZWxsIHNpemUgb2YgdGhlIGlucHV0IHJhc3RlcnMuXCIsXG5cdFwiQEBCaXR3aXNlLVhvcl9DZWxsc2l6ZS1UeXBlX3RhZzJAQFwiOiBcIkxhc3QgT2YtLVVzZSB0aGUgbGFzdCBjZWxsIHNpemUgb2YgdGhlIGlucHV0IHJhc3RlcnMuXCIsXG5cdFwiQEBCaXR3aXNlLVhvcl9DZWxsc2l6ZS1UeXBlX3RhZzNAQFwiOiBcIk1heCBPZi0tVXNlIHRoZSBsYXJnZXN0IGNlbGwgc2l6ZSBvZiBhbGwgdGhlIGlucHV0IHJhc3RlcnMuIFRoaXMgaXMgdGhlIGRlZmF1bHQuXCIsXG5cdFwiQEBCaXR3aXNlLVhvcl9DZWxsc2l6ZS1UeXBlX3RhZzRAQFwiOiBcIk1lYW4gT2YtLVVzZSB0aGUgbWVhbiBjZWxsIHNpemUgb2YgYWxsIHRoZSBpbnB1dCByYXN0ZXJzLlwiLFxuXHRcIkBAQml0d2lzZS1Yb3JfQ2VsbHNpemUtVHlwZV90YWc1QEBcIjogXCJNaW4gT2YtLVVzZSB0aGUgc21hbGxlc3QgY2VsbCBzaXplIG9mIGFsbCB0aGUgaW5wdXQgcmFzdGVycy5cIixcblx0XCJAQEJpdHdpc2UtWG9yX0V4dGVudC1UeXBlX3RhZzBAQFwiOiBcIkNob29zZSB3aGljaCBleHRlbnQgc2hvdWxkIGJlIHVzZWQgaW4gdGhlIG91dHB1dCByYXN0ZXI6XCIsXG5cdFwiQEBCaXR3aXNlLVhvcl9FeHRlbnQtVHlwZV90YWcxQEBcIjogXCJGaXJzdCBPZi0tVXNlIHRoZSBleHRlbnQgb2YgdGhlIGZpcnN0IGlucHV0IHJhc3RlciB0byBkZXRlcm1pbmUgdGhlIHByb2Nlc3NpbmcgZXh0ZW50LlwiLFxuXHRcIkBAQml0d2lzZS1Yb3JfRXh0ZW50LVR5cGVfdGFnMkBAXCI6IFwiSW50ZXJzZWN0aW9uIE9mLS1Vc2UgdGhlIGV4dGVudCBvZiB0aGUgb3ZlcmxhcHBpbmcgcGl4ZWxzIHRvIGRldGVybWluZSB0aGUgcHJvY2Vzc2luZyBleHRlbnQuIFRoaXMgaXMgdGhlIGRlZmF1bHQuXCIsXG5cdFwiQEBCaXR3aXNlLVhvcl9FeHRlbnQtVHlwZV90YWczQEBcIjogXCJMYXN0IE9mLS1Vc2UgdGhlIGV4dGVudCBvZiB0aGUgbGFzdCBpbnB1dCByYXN0ZXIgdG8gZGV0ZXJtaW5lIHRoZSBwcm9jZXNzaW5nIGV4dGVudC5cIixcblx0XCJAQEJpdHdpc2UtWG9yX0V4dGVudC1UeXBlX3RhZzRAQFwiOiBcIlVuaW9uIE9mLS1Vc2UgdGhlIGV4dGVudCBvZiBhbGwgdGhlIHJhc3RlcnMgdG8gZGV0ZXJtaW5lIHRoZSBwcm9jZXNzaW5nIGV4dGVudC5cIixcblx0XCJAQEJpdHdpc2UtWG9yX1Jhc3Rlcl90YWcwQEBcIjogXCJUaGUgZmlyc3QgaW5wdXQgdG8gdXNlIGluIHRoaXMgYml0d2lzZSBvcGVyYXRpb24uXCIsXG5cdFwiQEBCaXR3aXNlLVhvcl9SYXN0ZXJfdGFnMUBAXCI6IFwiQSBjb25zdGFudCB2YWx1ZSBjYW4gYmUgdXNlZCBhcyBhbiBpbnB1dCBmb3IgdGhpcyBwYXJhbWV0ZXIsIHByb3ZpZGVkIGEgcmFzdGVyIGlzIHNwZWNpZmllZCBmb3IgdGhlIG90aGVyIHBhcmFtZXRlci5cIixcblx0XCJAQEJpdHdpc2UtWG9yX1Jhc3RlcjJfdGFnMEBAXCI6IFwiVGhlIHNlY29uZCBpbnB1dCB0byB1c2UgaW4gdGhpcyBiaXR3aXNlIG9wZXJhdGlvbi5cIixcblx0XCJAQEJpdHdpc2UtWG9yX1Jhc3RlcjJfdGFnMUBAXCI6IFwiQSBjb25zdGFudCB2YWx1ZSBjYW4gYmUgdXNlZCBhcyBhbiBpbnB1dCBmb3IgdGhpcyBwYXJhbWV0ZXIsIHByb3ZpZGVkIGEgcmFzdGVyIGlzIHNwZWNpZmllZCBmb3IgdGhlIG90aGVyIHBhcmFtZXRlci5cIixcblx0XCJAQEJvb2xlYW4tYW5kX0NlbGxzaXplLVR5cGVfdGFnMEBAXCI6IFwiQ2hvb3NlIHdoaWNoIGNlbGwgc2l6ZSB0byB1c2UgaW4gdGhlIG91dHB1dCByYXN0ZXIuIElmIGFsbCB0aGUgaW5wdXQgY2VsbCBzaXplcyBhcmUgdGhlIHNhbWUsIGFsbCB0aGUgb3B0aW9ucyB3aWxsIHlpZWxkIHRoZSBzYW1lIHJlc3VsdHMuXCIsXG5cdFwiQEBCb29sZWFuLWFuZF9DZWxsc2l6ZS1UeXBlX3RhZzFAQFwiOiBcIkZpcnN0IE9mLS1Vc2UgdGhlIGZpcnN0IGNlbGwgc2l6ZSBvZiB0aGUgaW5wdXQgcmFzdGVycy5cIixcblx0XCJAQEJvb2xlYW4tYW5kX0NlbGxzaXplLVR5cGVfdGFnMkBAXCI6IFwiTGFzdCBPZi0tVXNlIHRoZSBsYXN0IGNlbGwgc2l6ZSBvZiB0aGUgaW5wdXQgcmFzdGVycy5cIixcblx0XCJAQEJvb2xlYW4tYW5kX0NlbGxzaXplLVR5cGVfdGFnM0BAXCI6IFwiTWF4IE9mLS1Vc2UgdGhlIGxhcmdlc3QgY2VsbCBzaXplIG9mIGFsbCB0aGUgaW5wdXQgcmFzdGVycy4gVGhpcyBpcyB0aGUgZGVmYXVsdC5cIixcblx0XCJAQEJvb2xlYW4tYW5kX0NlbGxzaXplLVR5cGVfdGFnNEBAXCI6IFwiTWVhbiBPZi0tVXNlIHRoZSBtZWFuIGNlbGwgc2l6ZSBvZiBhbGwgdGhlIGlucHV0IHJhc3RlcnMuXCIsXG5cdFwiQEBCb29sZWFuLWFuZF9DZWxsc2l6ZS1UeXBlX3RhZzVAQFwiOiBcIk1pbiBPZi0tVXNlIHRoZSBzbWFsbGVzdCBjZWxsIHNpemUgb2YgYWxsIHRoZSBpbnB1dCByYXN0ZXJzLlwiLFxuXHRcIkBAQm9vbGVhbi1hbmRfRXh0ZW50LVR5cGVfdGFnMEBAXCI6IFwiQ2hvb3NlIHdoaWNoIGV4dGVudCBzaG91bGQgYmUgdXNlZCBpbiB0aGUgb3V0cHV0IHJhc3RlcjpcIixcblx0XCJAQEJvb2xlYW4tYW5kX0V4dGVudC1UeXBlX3RhZzFAQFwiOiBcIkZpcnN0IE9mLS1Vc2UgdGhlIGV4dGVudCBvZiB0aGUgZmlyc3QgaW5wdXQgcmFzdGVyIHRvIGRldGVybWluZSB0aGUgcHJvY2Vzc2luZyBleHRlbnQuXCIsXG5cdFwiQEBCb29sZWFuLWFuZF9FeHRlbnQtVHlwZV90YWcyQEBcIjogXCJJbnRlcnNlY3Rpb24gT2YtLVVzZSB0aGUgZXh0ZW50IG9mIHRoZSBvdmVybGFwcGluZyBwaXhlbHMgdG8gZGV0ZXJtaW5lIHRoZSBwcm9jZXNzaW5nIGV4dGVudC4gVGhpcyBpcyB0aGUgZGVmYXVsdC5cIixcblx0XCJAQEJvb2xlYW4tYW5kX0V4dGVudC1UeXBlX3RhZzNAQFwiOiBcIkxhc3QgT2YtLVVzZSB0aGUgZXh0ZW50IG9mIHRoZSBsYXN0IGlucHV0IHJhc3RlciB0byBkZXRlcm1pbmUgdGhlIHByb2Nlc3NpbmcgZXh0ZW50LlwiLFxuXHRcIkBAQm9vbGVhbi1hbmRfRXh0ZW50LVR5cGVfdGFnNEBAXCI6IFwiVW5pb24gT2YtLVVzZSB0aGUgZXh0ZW50IG9mIGFsbCB0aGUgcmFzdGVycyB0byBkZXRlcm1pbmUgdGhlIHByb2Nlc3NpbmcgZXh0ZW50LlwiLFxuXHRcIkBAQm9vbGVhbi1hbmRfUmFzdGVyX3RhZzBAQFwiOiBcIlRoZSBmaXJzdCBpbnB1dCB0byB1c2UgaW4gdGhpcyBCb29sZWFuIG9wZXJhdGlvbi5cIixcblx0XCJAQEJvb2xlYW4tYW5kX1Jhc3Rlcl90YWcxQEBcIjogXCJBIGNvbnN0YW50IHZhbHVlIGNhbiBiZSB1c2VkIGFzIGFuIGlucHV0IGZvciB0aGlzIHBhcmFtZXRlciwgcHJvdmlkZWQgYSByYXN0ZXIgaXMgc3BlY2lmaWVkIGZvciB0aGUgb3RoZXIgcGFyYW1ldGVyLlwiLFxuXHRcIkBAQm9vbGVhbi1hbmRfUmFzdGVyMl90YWcwQEBcIjogXCJUaGUgc2Vjb25kIGlucHV0IHRvIHVzZSBpbiB0aGlzIEJvb2xlYW4gb3BlcmF0aW9uLlwiLFxuXHRcIkBAQm9vbGVhbi1hbmRfUmFzdGVyMl90YWcxQEBcIjogXCJBIGNvbnN0YW50IHZhbHVlIGNhbiBiZSB1c2VkIGFzIGFuIGlucHV0IGZvciB0aGlzIHBhcmFtZXRlciwgcHJvdmlkZWQgYSByYXN0ZXIgaXMgc3BlY2lmaWVkIGZvciB0aGUgb3RoZXIgcGFyYW1ldGVyLlwiLFxuXHRcIkBAQm9vbGVhbi1Ob3RfQ2VsbHNpemUtVHlwZV90YWcwQEBcIjogXCJDaG9vc2Ugd2hpY2ggY2VsbCBzaXplIHRvIHVzZSBpbiB0aGUgb3V0cHV0IHJhc3Rlci4gSWYgYWxsIHRoZSBpbnB1dCBjZWxsIHNpemVzIGFyZSB0aGUgc2FtZSwgYWxsIHRoZSBvcHRpb25zIHdpbGwgeWllbGQgdGhlIHNhbWUgcmVzdWx0cy5cIixcblx0XCJAQEJvb2xlYW4tTm90X0NlbGxzaXplLVR5cGVfdGFnMUBAXCI6IFwiRmlyc3QgT2YtLVVzZSB0aGUgZmlyc3QgY2VsbCBzaXplIG9mIHRoZSBpbnB1dCByYXN0ZXJzLlwiLFxuXHRcIkBAQm9vbGVhbi1Ob3RfQ2VsbHNpemUtVHlwZV90YWcyQEBcIjogXCJMYXN0IE9mLS1Vc2UgdGhlIGxhc3QgY2VsbCBzaXplIG9mIHRoZSBpbnB1dCByYXN0ZXJzLlwiLFxuXHRcIkBAQm9vbGVhbi1Ob3RfQ2VsbHNpemUtVHlwZV90YWczQEBcIjogXCJNYXggT2YtLVVzZSB0aGUgbGFyZ2VzdCBjZWxsIHNpemUgb2YgYWxsIHRoZSBpbnB1dCByYXN0ZXJzLiBUaGlzIGlzIHRoZSBkZWZhdWx0LlwiLFxuXHRcIkBAQm9vbGVhbi1Ob3RfQ2VsbHNpemUtVHlwZV90YWc0QEBcIjogXCJNZWFuIE9mLS1Vc2UgdGhlIG1lYW4gY2VsbCBzaXplIG9mIGFsbCB0aGUgaW5wdXQgcmFzdGVycy5cIixcblx0XCJAQEJvb2xlYW4tTm90X0NlbGxzaXplLVR5cGVfdGFnNUBAXCI6IFwiTWluIE9mLS1Vc2UgdGhlIHNtYWxsZXN0IGNlbGwgc2l6ZSBvZiBhbGwgdGhlIGlucHV0IHJhc3RlcnMuXCIsXG5cdFwiQEBCb29sZWFuLU5vdF9FeHRlbnQtVHlwZV90YWcwQEBcIjogXCJDaG9vc2Ugd2hpY2ggZXh0ZW50IHNob3VsZCBiZSB1c2VkIGluIHRoZSBvdXRwdXQgcmFzdGVyOlwiLFxuXHRcIkBAQm9vbGVhbi1Ob3RfRXh0ZW50LVR5cGVfdGFnMUBAXCI6IFwiRmlyc3QgT2YtLVVzZSB0aGUgZXh0ZW50IG9mIHRoZSBmaXJzdCBpbnB1dCByYXN0ZXIgdG8gZGV0ZXJtaW5lIHRoZSBwcm9jZXNzaW5nIGV4dGVudC5cIixcblx0XCJAQEJvb2xlYW4tTm90X0V4dGVudC1UeXBlX3RhZzJAQFwiOiBcIkludGVyc2VjdGlvbiBPZi0tVXNlIHRoZSBleHRlbnQgb2YgdGhlIG92ZXJsYXBwaW5nIHBpeGVscyB0byBkZXRlcm1pbmUgdGhlIHByb2Nlc3NpbmcgZXh0ZW50LiBUaGlzIGlzIHRoZSBkZWZhdWx0LlwiLFxuXHRcIkBAQm9vbGVhbi1Ob3RfRXh0ZW50LVR5cGVfdGFnM0BAXCI6IFwiTGFzdCBPZi0tVXNlIHRoZSBleHRlbnQgb2YgdGhlIGxhc3QgaW5wdXQgcmFzdGVyIHRvIGRldGVybWluZSB0aGUgcHJvY2Vzc2luZyBleHRlbnQuXCIsXG5cdFwiQEBCb29sZWFuLU5vdF9FeHRlbnQtVHlwZV90YWc0QEBcIjogXCJVbmlvbiBPZi0tVXNlIHRoZSBleHRlbnQgb2YgYWxsIHRoZSByYXN0ZXJzIHRvIGRldGVybWluZSB0aGUgcHJvY2Vzc2luZyBleHRlbnQuXCIsXG5cdFwiQEBCb29sZWFuLU5vdF9SYXN0ZXJfdGFnMEBAXCI6IFwiVGhlIGZpcnN0IGlucHV0IHRvIHVzZSBpbiB0aGlzIEJvb2xlYW4gb3BlcmF0aW9uLlwiLFxuXHRcIkBAQm9vbGVhbi1Pcl9DZWxsc2l6ZS1UeXBlX3RhZzBAQFwiOiBcIkNob29zZSB3aGljaCBjZWxsIHNpemUgdG8gdXNlIGluIHRoZSBvdXRwdXQgcmFzdGVyLiBJZiBhbGwgdGhlIGlucHV0IGNlbGwgc2l6ZXMgYXJlIHRoZSBzYW1lLCBhbGwgdGhlIG9wdGlvbnMgd2lsbCB5aWVsZCB0aGUgc2FtZSByZXN1bHRzLlwiLFxuXHRcIkBAQm9vbGVhbi1Pcl9DZWxsc2l6ZS1UeXBlX3RhZzFAQFwiOiBcIkZpcnN0IE9mLS1Vc2UgdGhlIGZpcnN0IGNlbGwgc2l6ZSBvZiB0aGUgaW5wdXQgcmFzdGVycy5cIixcblx0XCJAQEJvb2xlYW4tT3JfQ2VsbHNpemUtVHlwZV90YWcyQEBcIjogXCJMYXN0IE9mLS1Vc2UgdGhlIGxhc3QgY2VsbCBzaXplIG9mIHRoZSBpbnB1dCByYXN0ZXJzLlwiLFxuXHRcIkBAQm9vbGVhbi1Pcl9DZWxsc2l6ZS1UeXBlX3RhZzNAQFwiOiBcIk1heCBPZi0tVXNlIHRoZSBsYXJnZXN0IGNlbGwgc2l6ZSBvZiBhbGwgdGhlIGlucHV0IHJhc3RlcnMuIFRoaXMgaXMgdGhlIGRlZmF1bHQuXCIsXG5cdFwiQEBCb29sZWFuLU9yX0NlbGxzaXplLVR5cGVfdGFnNEBAXCI6IFwiTWVhbiBPZi0tVXNlIHRoZSBtZWFuIGNlbGwgc2l6ZSBvZiBhbGwgdGhlIGlucHV0IHJhc3RlcnMuXCIsXG5cdFwiQEBCb29sZWFuLU9yX0NlbGxzaXplLVR5cGVfdGFnNUBAXCI6IFwiTWluIE9mLS1Vc2UgdGhlIHNtYWxsZXN0IGNlbGwgc2l6ZSBvZiBhbGwgdGhlIGlucHV0IHJhc3RlcnMuXCIsXG5cdFwiQEBCb29sZWFuLU9yX0V4dGVudC1UeXBlX3RhZzBAQFwiOiBcIkNob29zZSB3aGljaCBleHRlbnQgc2hvdWxkIGJlIHVzZWQgaW4gdGhlIG91dHB1dCByYXN0ZXI6XCIsXG5cdFwiQEBCb29sZWFuLU9yX0V4dGVudC1UeXBlX3RhZzFAQFwiOiBcIkZpcnN0IE9mLS1Vc2UgdGhlIGV4dGVudCBvZiB0aGUgZmlyc3QgaW5wdXQgcmFzdGVyIHRvIGRldGVybWluZSB0aGUgcHJvY2Vzc2luZyBleHRlbnQuXCIsXG5cdFwiQEBCb29sZWFuLU9yX0V4dGVudC1UeXBlX3RhZzJAQFwiOiBcIkludGVyc2VjdGlvbiBPZi0tVXNlIHRoZSBleHRlbnQgb2YgdGhlIG92ZXJsYXBwaW5nIHBpeGVscyB0byBkZXRlcm1pbmUgdGhlIHByb2Nlc3NpbmcgZXh0ZW50LiBUaGlzIGlzIHRoZSBkZWZhdWx0LlwiLFxuXHRcIkBAQm9vbGVhbi1Pcl9FeHRlbnQtVHlwZV90YWczQEBcIjogXCJMYXN0IE9mLS1Vc2UgdGhlIGV4dGVudCBvZiB0aGUgbGFzdCBpbnB1dCByYXN0ZXIgdG8gZGV0ZXJtaW5lIHRoZSBwcm9jZXNzaW5nIGV4dGVudC5cIixcblx0XCJAQEJvb2xlYW4tT3JfRXh0ZW50LVR5cGVfdGFnNEBAXCI6IFwiVW5pb24gT2YtLVVzZSB0aGUgZXh0ZW50IG9mIGFsbCB0aGUgcmFzdGVycyB0byBkZXRlcm1pbmUgdGhlIHByb2Nlc3NpbmcgZXh0ZW50LlwiLFxuXHRcIkBAQm9vbGVhbi1Pcl9SYXN0ZXJfdGFnMEBAXCI6IFwiVGhlIGZpcnN0IGlucHV0IHRvIHVzZSBpbiB0aGlzIEJvb2xlYW4gb3BlcmF0aW9uLlwiLFxuXHRcIkBAQm9vbGVhbi1Pcl9SYXN0ZXJfdGFnMUBAXCI6IFwiQSBjb25zdGFudCB2YWx1ZSBjYW4gYmUgdXNlZCBhcyBhbiBpbnB1dCBmb3IgdGhpcyBwYXJhbWV0ZXIsIHByb3ZpZGVkIGEgcmFzdGVyIGlzIHNwZWNpZmllZCBmb3IgdGhlIG90aGVyIHBhcmFtZXRlci5cIixcblx0XCJAQEJvb2xlYW4tT3JfUmFzdGVyMl90YWcwQEBcIjogXCJUaGUgc2Vjb25kIGlucHV0IHRvIHVzZSBpbiB0aGlzIEJvb2xlYW4gb3BlcmF0aW9uLlwiLFxuXHRcIkBAQm9vbGVhbi1Pcl9SYXN0ZXIyX3RhZzFAQFwiOiBcIkEgY29uc3RhbnQgdmFsdWUgY2FuIGJlIHVzZWQgYXMgYW4gaW5wdXQgZm9yIHRoaXMgcGFyYW1ldGVyLCBwcm92aWRlZCBhIHJhc3RlciBpcyBzcGVjaWZpZWQgZm9yIHRoZSBvdGhlciBwYXJhbWV0ZXIuXCIsXG5cdFwiQEBCb29sZWFuLVhvcl9DZWxsc2l6ZS1UeXBlX3RhZzBAQFwiOiBcIkNob29zZSB3aGljaCBjZWxsIHNpemUgdG8gdXNlIGluIHRoZSBvdXRwdXQgcmFzdGVyLiBJZiBhbGwgdGhlIGlucHV0IGNlbGwgc2l6ZXMgYXJlIHRoZSBzYW1lLCBhbGwgdGhlIG9wdGlvbnMgd2lsbCB5aWVsZCB0aGUgc2FtZSByZXN1bHRzLlwiLFxuXHRcIkBAQm9vbGVhbi1Yb3JfQ2VsbHNpemUtVHlwZV90YWcxQEBcIjogXCJGaXJzdCBPZi0tVXNlIHRoZSBmaXJzdCBjZWxsIHNpemUgb2YgdGhlIGlucHV0IHJhc3RlcnMuXCIsXG5cdFwiQEBCb29sZWFuLVhvcl9DZWxsc2l6ZS1UeXBlX3RhZzJAQFwiOiBcIkxhc3QgT2YtLVVzZSB0aGUgbGFzdCBjZWxsIHNpemUgb2YgdGhlIGlucHV0IHJhc3RlcnMuXCIsXG5cdFwiQEBCb29sZWFuLVhvcl9DZWxsc2l6ZS1UeXBlX3RhZzNAQFwiOiBcIk1heCBPZi0tVXNlIHRoZSBsYXJnZXN0IGNlbGwgc2l6ZSBvZiBhbGwgdGhlIGlucHV0IHJhc3RlcnMuIFRoaXMgaXMgdGhlIGRlZmF1bHQuXCIsXG5cdFwiQEBCb29sZWFuLVhvcl9DZWxsc2l6ZS1UeXBlX3RhZzRAQFwiOiBcIk1lYW4gT2YtLVVzZSB0aGUgbWVhbiBjZWxsIHNpemUgb2YgYWxsIHRoZSBpbnB1dCByYXN0ZXJzLlwiLFxuXHRcIkBAQm9vbGVhbi1Yb3JfQ2VsbHNpemUtVHlwZV90YWc1QEBcIjogXCJNaW4gT2YtLVVzZSB0aGUgc21hbGxlc3QgY2VsbCBzaXplIG9mIGFsbCB0aGUgaW5wdXQgcmFzdGVycy5cIixcblx0XCJAQEJvb2xlYW4tWG9yX0V4dGVudC1UeXBlX3RhZzBAQFwiOiBcIkNob29zZSB3aGljaCBleHRlbnQgc2hvdWxkIGJlIHVzZWQgaW4gdGhlIG91dHB1dCByYXN0ZXI6XCIsXG5cdFwiQEBCb29sZWFuLVhvcl9FeHRlbnQtVHlwZV90YWcxQEBcIjogXCJGaXJzdCBPZi0tVXNlIHRoZSBleHRlbnQgb2YgdGhlIGZpcnN0IGlucHV0IHJhc3RlciB0byBkZXRlcm1pbmUgdGhlIHByb2Nlc3NpbmcgZXh0ZW50LlwiLFxuXHRcIkBAQm9vbGVhbi1Yb3JfRXh0ZW50LVR5cGVfdGFnMkBAXCI6IFwiSW50ZXJzZWN0aW9uIE9mLS1Vc2UgdGhlIGV4dGVudCBvZiB0aGUgb3ZlcmxhcHBpbmcgcGl4ZWxzIHRvIGRldGVybWluZSB0aGUgcHJvY2Vzc2luZyBleHRlbnQuIFRoaXMgaXMgdGhlIGRlZmF1bHQuXCIsXG5cdFwiQEBCb29sZWFuLVhvcl9FeHRlbnQtVHlwZV90YWczQEBcIjogXCJMYXN0IE9mLS1Vc2UgdGhlIGV4dGVudCBvZiB0aGUgbGFzdCBpbnB1dCByYXN0ZXIgdG8gZGV0ZXJtaW5lIHRoZSBwcm9jZXNzaW5nIGV4dGVudC5cIixcblx0XCJAQEJvb2xlYW4tWG9yX0V4dGVudC1UeXBlX3RhZzRAQFwiOiBcIlVuaW9uIE9mLS1Vc2UgdGhlIGV4dGVudCBvZiBhbGwgdGhlIHJhc3RlcnMgdG8gZGV0ZXJtaW5lIHRoZSBwcm9jZXNzaW5nIGV4dGVudC5cIixcblx0XCJAQEJvb2xlYW4tWG9yX1Jhc3Rlcl90YWcwQEBcIjogXCJUaGUgZmlyc3QgaW5wdXQgdG8gdXNlIGluIHRoaXMgQm9vbGVhbiBvcGVyYXRpb24uXCIsXG5cdFwiQEBCb29sZWFuLVhvcl9SYXN0ZXJfdGFnMUBAXCI6IFwiQSBjb25zdGFudCB2YWx1ZSBjYW4gYmUgdXNlZCBhcyBhbiBpbnB1dCBmb3IgdGhpcyBwYXJhbWV0ZXIsIHByb3ZpZGVkIGEgcmFzdGVyIGlzIHNwZWNpZmllZCBmb3IgdGhlIG90aGVyIHBhcmFtZXRlci5cIixcblx0XCJAQEJvb2xlYW4tWG9yX1Jhc3RlcjJfdGFnMEBAXCI6IFwiVGhlIHNlY29uZCBpbnB1dCB0byB1c2UgaW4gdGhpcyBCb29sZWFuIG9wZXJhdGlvbi5cIixcblx0XCJAQEJvb2xlYW4tWG9yX1Jhc3RlcjJfdGFnMUBAXCI6IFwiQSBjb25zdGFudCB2YWx1ZSBjYW4gYmUgdXNlZCBhcyBhbiBpbnB1dCBmb3IgdGhpcyBwYXJhbWV0ZXIsIHByb3ZpZGVkIGEgcmFzdGVyIGlzIHNwZWNpZmllZCBmb3IgdGhlIG90aGVyIHBhcmFtZXRlci5cIixcblx0XCJAQEJ1ZmZlcmVkX1Jhc3Rlcl90YWcwQEBcIjogXCJUaGUgaW5wdXQgcmFzdGVyIHRvIGJlIHN0b3JlZCBpbiBtZW1vcnkuXCIsXG5cdFwiQEBDYWxjdWxhdG9yX0NlbGxzaXplLVR5cGVfdGFnMEBAXCI6IFwiVGhlIGNlbGwgc2l6ZSB1c2VkIHRvIGNyZWF0ZSB0aGUgb3V0cHV0IHJhc3Rlci5cIixcblx0XCJAQENhbGN1bGF0b3JfQ2VsbHNpemUtVHlwZV90YWcxQEBcIjogXCJZb3UgY2FuIGNob29zZSB0aGUgb3V0cHV0IGNlbGwgc2l6ZSBmcm9tIHRoZSBmb2xsb3dpbmcgb3B0aW9ucyBpbiB0aGUgZHJvcCBkb3duIGxpc3Q6XCIsXG5cdFwiQEBDYWxjdWxhdG9yX0NlbGxzaXplLVR5cGVfdGFnMkBAXCI6IFwiPHN0cm9uZz5GaXJzdCBPZjwvc3Ryb25nPi0tVGhlIGNlbGxzaXplIG9mIHRoZSBmaXJzdCByYXN0ZXIgdmFyaWFibGUuXCIsXG5cdFwiQEBDYWxjdWxhdG9yX0NlbGxzaXplLVR5cGVfdGFnNEBAXCI6IFwiPHN0cm9uZz5NaW4gT2Y8L3N0cm9uZz4tLVRoZSBtaW5pbXVtIGNlbGxzaXplIG9mIHRoZSBpbnB1dCByYXN0ZXJzLlwiLFxuXHRcIkBAQ2FsY3VsYXRvcl9DZWxsc2l6ZS1UeXBlX3RhZzZAQFwiOiBcIjxzdHJvbmc+TWF4IE9mPC9zdHJvbmc+LS1UaGUgbWF4aW11bSBjZWxsc2l6ZSBvZiB0aGUgaW5wdXQgcmFzdGVycy5cIixcblx0XCJAQENhbGN1bGF0b3JfQ2VsbHNpemUtVHlwZV90YWc4QEBcIjogXCI8c3Ryb25nPk1lYW4gT2Y8L3N0cm9uZz4tLVRoZSBhdmVyYWdlIGNlbGxzaXplIG9mIHRoZSBpbnB1dCByYXN0ZXJzLlwiLFxuXHRcIkBAQ2FsY3VsYXRvcl9DZWxsc2l6ZS1UeXBlX3RhZzEwQEBcIjogXCI8c3Ryb25nPkxhc3QgT2Y8L3N0cm9uZz4tLVRoZSBjZWxsc2l6ZSBvZiB0aGUgbGFzdCByYXN0ZXIgdmFyaWFibGUuXCIsXG5cdFwiQEBDYWxjdWxhdG9yX0NlbGxzaXplLVR5cGVfdGFnMTJAQFwiOiBcIlRoZSBkZWZhdWx0IHNlbGVjdGlvbiBpcyA8c3Ryb25nPk1heCBPZjwvc3Ryb25nPi5cIixcblx0XCJAQENhbGN1bGF0b3JfRXhwcmVzc2lvbl90YWcwQEBcIjogXCJCdWlsZCBhbiBhbGdlYnJhaWMgZXhwcmVzc2lvbiB0byBwZXJmb3JtIHNwYXRpYWwgYW5hbHlzaXMgb24gdGhlIGlucHV0IHJhc3Rlci5cIixcblx0XCJAQENhbGN1bGF0b3JfRXhwcmVzc2lvbl90YWcxQEBcIjogXCJBbGwgZXhpc3RpbmcgbWF0aCBmdW5jdGlvbnMgY2FuIGJlIGNhbGxlZCB0byBidWlsZCB0aGUgZXhwcmVzc2lvbi4gVGhlIGF2YWlsYWJsZSBvcGVyYXRvcnMgYXJlIGxpc3RlZCBiZWxvdy5cIixcblx0XCJAQENhbGN1bGF0b3JfRXhwcmVzc2lvbl90YWcyQEBcIjogXCJBcml0aG1ldGljIE9wZXJhdGlvbnNcIixcblx0XCJAQENhbGN1bGF0b3JfRXhwcmVzc2lvbl90YWczQEBcIjogXCJBZGRpdGlvbjogK1wiLFxuXHRcIkBAQ2FsY3VsYXRvcl9FeHByZXNzaW9uX3RhZzRAQFwiOiBcIkRpdmlzaW9uOiAvXCIsXG5cdFwiQEBDYWxjdWxhdG9yX0V4cHJlc3Npb25fdGFnNUBAXCI6IFwiTW9kdWxvOiAlXCIsXG5cdFwiQEBDYWxjdWxhdG9yX0V4cHJlc3Npb25fdGFnNkBAXCI6IFwiTXVsdGlwbGljYXRpb246ICpcIixcblx0XCJAQENhbGN1bGF0b3JfRXhwcmVzc2lvbl90YWc3QEBcIjogXCJQb3dlcjogKipcIixcblx0XCJAQENhbGN1bGF0b3JfRXhwcmVzc2lvbl90YWc4QEBcIjogXCJTdWJ0cmFjdGlvbjogLVwiLFxuXHRcIkBAQ2FsY3VsYXRvcl9FeHByZXNzaW9uX3RhZzlAQFwiOiBcIkJvb2xlYW4gT3BlcmF0aW9uc1wiLFxuXHRcIkBAQ2FsY3VsYXRvcl9FeHByZXNzaW9uX3RhZzEwQEBcIjogXCJCb29sZWFuIEFuZDogJiZcIixcblx0XCJAQENhbGN1bGF0b3JfRXhwcmVzc2lvbl90YWcxMUBAXCI6IFwiQm9vbGVhbiBPcjogfHxcIixcblx0XCJAQENhbGN1bGF0b3JfRXhwcmVzc2lvbl90YWcxMkBAXCI6IFwiUmVsYXRpb24gT3BlcmF0aW9uc1wiLFxuXHRcIkBAQ2FsY3VsYXRvcl9FeHByZXNzaW9uX3RhZzEzQEBcIjogXCJFcXVhbCB0bzogPT1cIixcblx0XCJAQENhbGN1bGF0b3JfRXhwcmVzc2lvbl90YWcxNEBAXCI6IFwiR3JlYXRlciB0aGFuOiA+XCIsXG5cdFwiQEBDYWxjdWxhdG9yX0V4cHJlc3Npb25fdGFnMTVAQFwiOiBcIkdyZWF0ZXIgdGhhbiBvciBFcXVhbCB0bzogPj1cIixcblx0XCJAQENhbGN1bGF0b3JfRXhwcmVzc2lvbl90YWcxNkBAXCI6IFwiTGVzcyB0aGFuOiA8XCIsXG5cdFwiQEBDYWxjdWxhdG9yX0V4cHJlc3Npb25fdGFnMTdAQFwiOiBcIkxlc3MgdGhhbiBvciBFcXVhbCB0bzogPD1cIixcblx0XCJAQENhbGN1bGF0b3JfRXhwcmVzc2lvbl90YWcxOEBAXCI6IFwiTm90IEVxdWFsIHRvOiAhPVwiLFxuXHRcIkBAQ2FsY3VsYXRvcl9FeHByZXNzaW9uX3RhZzE5QEBcIjogXCJBZGRpdGlvbmFsIE9wZXJhdGlvbnNcIixcblx0XCJAQENhbGN1bGF0b3JfRXhwcmVzc2lvbl90YWcyMEBAXCI6IFwiTWluaW11bSBvZiB0d28gcmFzdGVycyBvbiBhIHBlci1waXhlbCBiYXNpczogbWluKGEsYilcIixcblx0XCJAQENhbGN1bGF0b3JfRXhwcmVzc2lvbl90YWcyMUBAXCI6IFwiTWF4aW11bSBvZiB0d28gcmFzdGVycyBvbiBhIHBlci1waXhlbCBiYXNpczogbWF4KGEsYilcIixcblx0XCJAQENhbGN1bGF0b3JfRXhwcmVzc2lvbl90YWcyMkBAXCI6IFwiSGVyZSBhcmUgc29tZSBleGFtcGxlcyBvZiBleHByZXNzaW9uczpcIixcblx0XCJAQENhbGN1bGF0b3JfRXhwcmVzc2lvbl90YWcyM0BAXCI6IFwiU2ltcGxlIENvbmRpdGlvbmFsIFN0YXRlbWVudDogaW4gYSByYXN0ZXIgKGRlbm90ZWQgYnkgVCkgZmluZCBlbGV2YXRpb24gdmFsdWVzIGFib3ZlIDQsMDAwIGZlZXQgYW5kIGdpdmUgdGhlc2UgYXJlYXMgYSB2YWx1ZSBvZiAxIGFuZCBhbGwgb3RoZXIgYXJlYXMgYSB2YWx1ZSBvZiAwLlwiLFxuXHRcIkBAQ2FsY3VsYXRvcl9FeHByZXNzaW9uX3RhZzI0QEBcIjogXCJDb24oVCA+IDQwMDAsIDEsIDApXCIsXG5cdFwiQEBDYWxjdWxhdG9yX0V4cHJlc3Npb25fdGFnMjVAQFwiOiBcIk5lc3RlZCBDb25kaXRpb25hbCBTdGF0ZW1lbnQ6IGZpbmQgYXJlYXMgd2hlcmUgc2xvcGUgKGRlbm90ZWQgYnkgYjEpKSBpcyBiZWxvdyAxMCBkZWdyZWVzIGFuZCBORFZJIChkZW5vdGVkIGJ5IGIyKSBpcyBhYm92ZSAwLjUsIGFuZCBnaXZlIHRoZXNlIGFyZWFzIGEgdmFsdWUgb2YgMS4gRm9yIGFsbCBvdGhlciBhcmVhcywgYXNzaWduIGEgdmFsdWUgb2YgMiBpZiBzbG9wZSBpcyBhYm92ZSAxMCBkZWdyZWVzIGFuZCBlbGV2YXRpb24gKGRlbm90ZWQgYnkgYjMpIGlzIG92ZXIgMiw1MDAgZmVldC4gQWxsIG90aGVyIGFyZWFzIGFyZSBhc3NpZ25lZCBhIHZhbHVlIG9mIDMuXCIsXG5cdFwiQEBDYWxjdWxhdG9yX0V4cHJlc3Npb25fdGFnMjZAQFwiOiBcIkNvbigoYjEgPCAxMCAmJiBiMiA+IC41LCAxLCBDb24oYjEgPiAxMCAmJiBiMyA+IDI1MDAsIDIsIDMpKSlcIixcblx0XCJAQENhbGN1bGF0b3JfZXh0ZW50dHlwZV90YWcwQEBcIjogXCI8cD5DaG9vc2Ugd2hpY2ggZXh0ZW50IHNob3VsZCBiZSB1c2VkIGluIHRoZSBvdXRwdXQgcmFzdGVyOjwvcD48dWw+PGxpPjxwPkZpcnN0IE9mLS1Vc2UgdGhlIGV4dGVudCBvZiB0aGUgZmlyc3QgaW5wdXQgcmFzdGVyIHRvIGRldGVybWluZSB0aGUgcHJvY2Vzc2luZyBleHRlbnQuPC9wPjwvbGk+PGxpPkludGVyc2VjdGlvbiBPZi0tVXNlIHRoZSBleHRlbnQgb2YgdGhlIG92ZXJsYXBwaW5nIHBpeGVscyB0byBkZXRlcm1pbmUgdGhlIHByb2Nlc3NpbmcgZXh0ZW50LiBUaGlzIGlzIHRoZSBkZWZhdWx0LjwvbGk+PGxpPlVuaW9uIE9mLS1Vc2UgdGhlIGV4dGVudCBvZiBhbGwgdGhlIHJhc3RlcnMgdG8gZGV0ZXJtaW5lIHRoZSBwcm9jZXNzaW5nIGV4dGVudC48L2xpPjxsaT5MYXN0IE9mLS1Vc2UgdGhlIGV4dGVudCBvZiB0aGUgbGFzdCBpbnB1dCByYXN0ZXIgdG8gZGV0ZXJtaW5lIHRoZSBwcm9jZXNzaW5nIGV4dGVudC48L2xpPjwvdWw+XCIsXG5cdFwiQEBDYWxjdWxhdG9yX1Jhc3Rlci1WYXJpYWJsZXNfdGFnMEBAXCI6IFwiVGhlIHVzZXItZGVmaW5lZCB2YXJpYWJsZSBuYW1lIGFuZCB0aGUgaW5wdXQgcmFzdGVyLlwiLFxuXHRcIkBAQ2xhc3NpZnlfSW5wdXQtRGVmaW5pdGlvbi1GaWxlX3RhZzBAQFwiOiBcIlRoZSBpbnB1dCBFc3JpIENsYXNzaWZpZXIgRGVmaW5pdGlvbiAoJHsuZWNkfSkgZmlsZSB0aGF0IGNvbnRhaW5zIHRoZSBzdGF0aXN0aWNzIGFuZCBvdGhlciBjbGFzc2lmaWNhdGlvbiBpbmZvcm1hdGlvbiBmb3IgdGhlIHNwZWNpZmljIGRhdGFzZXQsIGNsYXNzaWZpZXIsIGFuZCBjaG9zZW4gYXR0cmlidXRlcy5cIixcblx0XCJAQENsYXNzaWZ5X1Jhc3Rlcl90YWcwQEBcIjogXCJUaGUgcmFzdGVyIGRhdGFzZXQgeW91IHdhbnQgdG8gY2xhc3NpZnkuXCIsXG5cdFwiQEBDbGFzc2lmeV9SYXN0ZXIyX3RhZzBAQFwiOiBcIkFuIG9wdGlvbmFsIGFuY2lsbGFyeSByYXN0ZXIgZGF0YXNldCB0byBpbmNvcnBvcmF0ZSBpbnRvIHRoZSBjbGFzc2lmaWVyLCBzdWNoIGFzIGEgc2VnbWVudGVkIGltYWdlLCBtdWx0aXNwZWN0cmFsIGltYWdlLCBvciBlbGV2YXRpb24gZGF0YSwgdXNlZCB0byBnZW5lcmF0ZSBhIG1vcmUgcm9idXN0IGNsYXNzaWZpY2F0aW9uIGRlZmluaXRpb24gZm9yIHlvdXIgZGF0YXNldC4gVGhlIHJhc3RlciBkYXRhc2V0IGZvciB0aGlzIHBhcmFtZXRlciBtdXN0IG1hdGNoIHRoZSBvbmUgdXNlZCB0byBjcmVhdGUgdGhlIGlucHV0IEVzcmkgQ2xhc3NpZmllciBEZWZpbml0aW9uIGZpbGUuXCIsXG5cdFwiQEBDbGlwX0NsaXBwaW5nLUdlb21ldHJ5LW9yLVJhc3Rlcl90YWcwQEBcIjogXCJUaGUgZm9sbG93aW5nIGNhbiBiZSB1c2VkIHRvIHNwZWNpZnkgdGhlIGNsaXBwaW5nIGV4dGVudDpcIixcblx0XCJAQENsaXBfQ2xpcHBpbmctR2VvbWV0cnktb3ItUmFzdGVyX3RhZzFAQFwiOiBcIjxzdHJvbmc+Q2xpcHBpbmcgUmFzdGVyPC9zdHJvbmc+LS1FeHRlbnQgb2YgdGhlIGNsaXBwaW5nIHJhc3RlclwiLFxuXHRcIkBAQ2xpcF9DbGlwcGluZy1HZW9tZXRyeS1vci1SYXN0ZXJfdGFnM0BAXCI6IFwiPHN0cm9uZz5DdXN0b20gRXh0ZW50PC9zdHJvbmc+LS1YIGFuZCBZIG1pbmltdW0gYW5kIG1heGltdW0gY29vcmRpbmF0ZXNcIixcblx0XCJAQENsaXBfQ2xpcHBpbmctR2VvbWV0cnktb3ItUmFzdGVyX3RhZzVAQFwiOiBcIjxzdHJvbmc+Q3VycmVudCBNYXAgRXh0ZW50PC9zdHJvbmc+LS1FeHRlbnQgb2YgdGhlIGN1cnJlbnQgbWFwIGRpc3BsYXlcIixcblx0XCJAQENsaXBfQ2xpcHBpbmctUmFzdGVyX3RhZzBAQFwiOiBcIlRoZSByYXN0ZXIgbGF5ZXIgdXNlZCB0byBjbGlwLlwiLFxuXHRcIkBAQ2xpcF9DbGlwcGluZy1UeXBlX3RhZzBAQFwiOiBcIlNwZWNpZnkgd2hldGhlciB5b3Ugd2FudCB0byByZXRhaW4gdGhlIGFyZWEgaW5zaWRlIG9yIG91dHNpZGUgeW91ciBjbGlwIGdlb21ldHJ5LlwiLFxuXHRcIkBAQ2xpcF9DbGlwcGluZy1UeXBlX3RhZzFAQFwiOiBcIjxzdHJvbmc+Q2xpcCBJbnNpZGU8L3N0cm9uZz4tLUltYWdlcnkgaW5zaWRlIHRoZSBjbGlwIGV4dGVudHMgd2lsbCBiZSByZW1vdmVkLlwiLFxuXHRcIkBAQ2xpcF9DbGlwcGluZy1UeXBlX3RhZzNAQFwiOiBcIjxzdHJvbmc+Q2xpcCBPdXRzaWRlPC9zdHJvbmc+LS1JbWFnZXJ5IG91dHNpZGUgdGhlIGNsaXAgZXh0ZW50cyB3aWxsIGJlIHJlbW92ZWQuXCIsXG5cdFwiQEBDbGlwX0N1c3RvbS1FeHRlbnRfdGFnMEBAXCI6IFwiU3BlY2lmeSB0aGUgZm91ciBjb29yZGluYXRlcyB0aGF0IGRlZmluZSB0aGUgZXh0ZW50IG9mIHRoZSBib3VuZGluZyBib3ggdXNlZCB0byBjbGlwIHRoZSByYXN0ZXIuXCIsXG5cdFwiQEBDbGlwX091dHB1dC1FeHRlbnRfdGFnMEBAXCI6IFwiVGhlIHggYW5kIHkgY29vcmRpbmF0ZXMgb2YgdGhlIGN1cnJlbnQgY2xpcHBpbmcgZXh0ZW50LlwiLFxuXHRcIkBAQ2xpcF9PdXRwdXQtRXh0ZW50X3RhZzFAQFwiOiBcIlRoZSA8c3Ryb25nPkNhcHR1cmUgQ3VycmVudCBNYXAgRXh0ZW50PC9zdHJvbmc+IGJ1dHRvbiB1c2VzIHRoZSBkaXNwbGF5IGV4dGVudCBmb3IgdGhlIGFjdGl2ZSBtYXAuXCIsXG5cdFwiQEBDbGlwX1Jhc3Rlcl90YWcwQEBcIjogXCJUaGUgaW5wdXQgcmFzdGVyIGxheWVyLlwiLFxuXHRcIkBAQ2xpcF9Vc2UtSW5wdXQtRmVhdHVyZXMtZm9yLUNsaXBwaW5nLUdlb21ldHJ5X3RhZzBAQFwiOiBcIldoZW4gc2VsZWN0ZWQsIHRoZSBkYXRhIGlzIGNsaXBwZWQgYWNjb3JkaW5nIHRvIHRoZSBnZW9tZXRyeSBvZiB0aGUgc3BlY2lmaWVkIGZlYXR1cmUgY2xhc3MuXCIsXG5cdFwiQEBDbGlwX1VzZS1JbnB1dC1GZWF0dXJlcy1mb3ItQ2xpcHBpbmctR2VvbWV0cnlfdGFnMUBAXCI6IFwiVW5jaGVja2VkLS1UaGUgZnVuY3Rpb24gdXNlcyB0aGUgY2xpcCBnZW9tZXRyeSBzcGVjaWZpZWQgYnkgPHN0cm9uZz5SZWN0YW5nbGU8L3N0cm9uZz4uIFRoaXMgaXMgdGhlIGRlZmF1bHQuXCIsXG5cdFwiQEBDbGlwX1VzZS1JbnB1dC1GZWF0dXJlcy1mb3ItQ2xpcHBpbmctR2VvbWV0cnlfdGFnNEBAXCI6IFwiQ2hlY2tlZC0tVGhlIGZ1bmN0aW9uIHVzZXMgdGhlIGNsaXAgZ2VvbWV0cnkgZGVmaW5lZCBieSBhIGZlYXR1cmUgY2xhc3MuXCIsXG5cdFwiQEBDb2xvci1Nb2RlbC1Db252ZXJzaW9uX0NvbnZlcnNpb24tVHlwZV90YWcwQEBcIjogXCJUaGUgY29sb3IgY29udmVyc2lvbiB0eXBlIHRvIHBlcmZvcm06XCIsXG5cdFwiQEBDb2xvci1Nb2RlbC1Db252ZXJzaW9uX0NvbnZlcnNpb24tVHlwZV90YWcxQEBcIjogXCJIU1YgdG8gUkdCXCIsXG5cdFwiQEBDb2xvci1Nb2RlbC1Db252ZXJzaW9uX0NvbnZlcnNpb24tVHlwZV90YWcyQEBcIjogXCJSR0IgdG8gSFNWXCIsXG5cdFwiQEBDb2xvci1Nb2RlbC1Db252ZXJzaW9uX1Jhc3Rlcl90YWcwQEBcIjogXCJUaGUgaW5wdXQgcmFzdGVyLlwiLFxuXHRcIkBAQ29sb3JtYXBfQ29sb3ItUmFtcF90YWcwQEBcIjogXCJDaG9vc2UgYSBwcmUtZXhpc3RpbmcgY29sb3IgcmFtcC5cIixcblx0XCJAQENvbG9ybWFwX0NvbG9yLVNjaGVtZS1UeXBlX3RhZzBAQFwiOiBcIkNob29zZSB0aGUgdHlwZSBvZiBjb2xvciBzY2hlbWUgdG8gcmVuZGVyIHlvdXIgaW5wdXQgcmFzdGVyXCIsXG5cdFwiQEBDb2xvcm1hcF9Db2xvci1TY2hlbWUtVHlwZV90YWcxQEBcIjogXCJDb2xvciBSYW1wLS1Vc2UgYSBjb2xvciByYW1wLlwiLFxuXHRcIkBAQ29sb3JtYXBfQ29sb3ItU2NoZW1lLVR5cGVfdGFnMkBAXCI6IFwiQ29sb3JtYXAtLVVzZSBhIHByZS1leGlzdGluZyBjb2xvciBtYXAuXCIsXG5cdFwiQEBDb2xvcm1hcF9Db2xvcm1hcF90YWcwQEBcIjogXCJUaGUgZm9sbG93aW5nIGRlZmF1bHQgY29sb3IgbWFwcyBhcmUgYXZhaWxhYmxlIGZyb20gdGhlIGRyb3AtZG93biBsaXN0OlwiLFxuXHRcIkBAQ29sb3JtYXBfQ29sb3JtYXBfdGFnMUBAXCI6IFwiRWxldmF0aW9uLS1BIGNvbG9yIG1hcCB0aGF0IGdyYWR1YWxseSBjaGFuZ2VzIGZyb20gY3lhbiB0byBwdXJwbGUgdG8gYmxhY2suXCIsXG5cdFwiQEBDb2xvcm1hcF9Db2xvcm1hcF90YWcyQEBcIjogXCJHcmF5LS1BIGNvbG9yIG1hcCB0aGF0IGdyYWR1YWxseSBjaGFuZ2VzIGZyb20gYmxhY2sgdG8gd2hpdGUuXCIsXG5cdFwiQEBDb2xvcm1hcF9Db2xvcm1hcF90YWc3QEBcIjogXCJIaWxsc2hhZGUtLUEgZ3JleXNjYWxlIGNvbG9ybWFwIHRvIHZpc3VhbGl6ZSBhIDNEIHJlcHJlc2VudGF0aW9uIG9mIHRoZSB0ZXJyYWluIHN1cmZhY2UsIHdpdGggdGhlIHN1bidzIHJlbGF0aXZlIHBvc2l0aW9uIHRha2VuIGludG8gYWNjb3VudCBmb3Igc2hhZGluZyB0aGUgaW1hZ2UuXCIsXG5cdFwiQEBDb2xvcm1hcF9Db2xvcm1hcF90YWczQEBcIjogXCJORFZJLS1BIGNvbG9ybWFwIHRvIHZpc3VhbGl6ZSB2ZWdldGF0aW9uLiBWYWx1ZXMgbmVhciB6ZXJvIGFyZSBibHVlLiBMb3cgdmFsdWVzIGFyZSBicm93bi4gVGhlbiB0aGUgY29sb3JzIGdyYWR1YWxseSBjaGFuZ2UgZnJvbSByZWQsIHRvIG9yYW5nZSwgdG8geWVsbG93LCB0byBncmVlbiwgYW5kIHRvIGJsYWNrIGFzIHRoZSB2ZWdldGF0aW9uIGluZGV4IGdvZXMgZnJvbSBsb3cgdG8gaGlnaC5cIixcblx0XCJAQENvbG9ybWFwX0NvbG9ybWFwX3RhZzRAQFwiOiBcIk5EVkkyLS1BIGNvbG9ybWFwIHRvIHZpc3VhbGl6ZSB2ZWdldGF0aW9uLiBMb3cgdmFsdWVzIHJhbmdlIGZyb20gd2hpdGUgdG8gZ3JlZW4uIFRoZW4gdGhlIGNvbG9ycyByYW5nZSBmcm9tIGdyYXksIHRvIHB1cnBsZSwgdG8gdmlvbGV0LCB0byBkYXJrIGJsdWUsIGFuZCB0byBibGFjayBhcyB0aGUgdmVnZXRhdGlvbiBpbmRleCBnb2VzIGZyb20gbG93IHRvIGhpZ2guXCIsXG5cdFwiQEBDb2xvcm1hcF9Db2xvcm1hcF90YWc1QEBcIjogXCJORFZJMy0tQSBjb2xvcm1hcCB0byB2aXN1YWxpemUgdmVnZXRhdGlvbi4gVmFsdWVzIG5lYXIgemVybyBhcmUgYmx1ZS4gVGhlbiB0aGUgY29sb3JzIGdyYWR1YWxseSBjaGFuZ2UgZnJvbSByZWQsIHRvIG9yYW5nZSwgYW5kIHRvIGdyZWVuIGFzIHRoZSB2ZWdldGF0aW9uIGluZGV4IGdvZXMgZnJvbSBsb3cgdG8gaGlnaC5cIixcblx0XCJAQENvbG9ybWFwX0NvbG9ybWFwX3RhZzZAQFwiOiBcIlJhbmRvbS0tQSByYW5kb20gY29sb3JtYXAuXCIsXG5cdFwiQEBDb2xvcm1hcF9SYXN0ZXJfdGFnMEBAXCI6IFwiVGhlIGlucHV0IHJhc3Rlci5cIixcblx0XCJAQENvbG9ybWFwLVRvLVJHQl9SYXN0ZXJfdGFnMEBAXCI6IFwiVGhlIGlucHV0IGNvbG9yIG1hcCByYXN0ZXIuXCIsXG5cdFwiQEBDb21wbGV4X1Jhc3Rlcl90YWcwQEBcIjogXCJUaGUgaW5wdXQgcmFzdGVyLlwiLFxuXHRcIkBAQ29tcG9zaXRlLUJhbmRzX1Jhc3RlcnNfdGFnMEBAXCI6IFwiVXNlIHRoZSBkcm9wLWRvd24gbGlzdCBvciB0aGUgPHN0cm9uZz5Ccm93c2U8L3N0cm9uZz4gYnV0dG9uIHRvIGNob29zZSB0aGUgcmFzdGVyIGlucHV0cy5cIixcblx0XCJAQENvbXBvc2l0ZS1CYW5kc19jZWxsc2l6ZXR5cGVfdGFnMEBAXCI6IFwiPHA+Q2hvb3NlIHdoaWNoIGNlbGwgc2l6ZSB0byB1c2UgaW4gdGhlIG91dHB1dCByYXN0ZXIuSWYgYWxsIHRoZSBpbnB1dCBjZWxsIHNpemVzIGFyZSB0aGUgc2FtZSwgYWxsIHRoZSBvcHRpb25zIHdpbGx5aWVsZCB0aGUgc2FtZSByZXN1bHRzLjwvcD48dWw+PGxpPkZpcnN0IE9mLS1Vc2UgdGhlIGZpcnN0IGNlbGwgc2l6ZSBvZiB0aGUgaW5wdXQgcmFzdGVycy48L2xpPjxsaT5NaW4gT2YtLVVzZSB0aGUgc21hbGxlc3QgY2VsbCBzaXplIG9mIGFsbCB0aGUgaW5wdXQgcmFzdGVycy48L2xpPjxsaT5NYXggT2YtLVVzZSB0aGUgbGFyZ2VzdCBjZWxsIHNpemUgb2YgYWxsIHRoZSBpbnB1dCByYXN0ZXJzLiBUaGlzIGlzIHRoZSBkZWZhdWx0LjwvbGk+PGxpPk1lYW4gT2YtLVVzZSB0aGUgbWVhbiBjZWxsIHNpemUgb2YgYWxsIHRoZSBpbnB1dCByYXN0ZXJzLjwvbGk+PGxpPkxhc3QgT2YtLVVzZSB0aGUgbGFzdCBjZWxsIHNpemUgb2YgdGhlIGlucHV0IHJhc3RlcnMuPC9saT48L3VsPlwiLFxuXHRcIkBAQ29uLWZ1bmN0aW9uX0NlbGxzaXplLVR5cGVfdGFnMEBAXCI6IFwiQ2hvb3NlIHdoaWNoIGNlbGwgc2l6ZSB0byB1c2UgaW4gdGhlIG91dHB1dCByYXN0ZXIuIElmIGFsbCB0aGUgaW5wdXQgY2VsbCBzaXplcyBhcmUgdGhlIHNhbWUsIGFsbCB0aGUgb3B0aW9ucyB3aWxsIHlpZWxkIHRoZSBzYW1lIHJlc3VsdHMuXCIsXG5cdFwiQEBDb24tZnVuY3Rpb25fQ2VsbHNpemUtVHlwZV90YWcxQEBcIjogXCJGaXJzdCBPZi0tVXNlIHRoZSBmaXJzdCBjZWxsIHNpemUgb2YgdGhlIGlucHV0IHJhc3RlcnMuXCIsXG5cdFwiQEBDb24tZnVuY3Rpb25fQ2VsbHNpemUtVHlwZV90YWcyQEBcIjogXCJMYXN0IE9mLS1Vc2UgdGhlIGxhc3QgY2VsbCBzaXplIG9mIHRoZSBpbnB1dCByYXN0ZXJzLlwiLFxuXHRcIkBAQ29uLWZ1bmN0aW9uX0NlbGxzaXplLVR5cGVfdGFnM0BAXCI6IFwiTWF4IE9mLS1Vc2UgdGhlIGxhcmdlc3QgY2VsbCBzaXplIG9mIGFsbCB0aGUgaW5wdXQgcmFzdGVycy4gVGhpcyBpcyB0aGUgZGVmYXVsdC5cIixcblx0XCJAQENvbi1mdW5jdGlvbl9DZWxsc2l6ZS1UeXBlX3RhZzRAQFwiOiBcIk1lYW4gT2YtLVVzZSB0aGUgbWVhbiBjZWxsIHNpemUgb2YgYWxsIHRoZSBpbnB1dCByYXN0ZXJzLlwiLFxuXHRcIkBAQ29uLWZ1bmN0aW9uX0NlbGxzaXplLVR5cGVfdGFnNUBAXCI6IFwiTWluIE9mLS1Vc2UgdGhlIHNtYWxsZXN0IGNlbGwgc2l6ZSBvZiBhbGwgdGhlIGlucHV0IHJhc3RlcnMuXCIsXG5cdFwiQEBDb25fRXh0ZW50LVR5cGVfdGFnMEBAXCI6IFwiQ2hvb3NlIHdoaWNoIGV4dGVudCBzaG91bGQgYmUgdXNlZCBpbiB0aGUgb3V0cHV0IHJhc3RlcjpcIixcblx0XCJAQENvbl9FeHRlbnQtVHlwZV90YWcxQEBcIjogXCJGaXJzdCBPZi0tVXNlIHRoZSBleHRlbnQgb2YgdGhlIGZpcnN0IGlucHV0IHJhc3RlciB0byBkZXRlcm1pbmUgdGhlIHByb2Nlc3NpbmcgZXh0ZW50LlwiLFxuXHRcIkBAQ29uX0V4dGVudC1UeXBlX3RhZzJAQFwiOiBcIkludGVyc2VjdGlvbiBPZi0tVXNlIHRoZSBleHRlbnQgb2YgdGhlIG92ZXJsYXBwaW5nIHBpeGVscyB0byBkZXRlcm1pbmUgdGhlIHByb2Nlc3NpbmcgZXh0ZW50LiBUaGlzIGlzIHRoZSBkZWZhdWx0LlwiLFxuXHRcIkBAQ29uX0V4dGVudC1UeXBlX3RhZzNAQFwiOiBcIkxhc3QgT2YtLVVzZSB0aGUgZXh0ZW50IG9mIHRoZSBsYXN0IGlucHV0IHJhc3RlciB0byBkZXRlcm1pbmUgdGhlIHByb2Nlc3NpbmcgZXh0ZW50LlwiLFxuXHRcIkBAQ29uX0V4dGVudC1UeXBlX3RhZzRAQFwiOiBcIlVuaW9uIE9mLS1Vc2UgdGhlIGV4dGVudCBvZiBhbGwgdGhlIHJhc3RlcnMgdG8gZGV0ZXJtaW5lIHRoZSBwcm9jZXNzaW5nIGV4dGVudC5cIixcblx0XCJAQENvbl9GYWxzZS1SYXN0ZXJfdGFnMEBAXCI6IFwiVGhlIGlucHV0IHdob3NlIHZhbHVlcyB3aWxsIGJlIHVzZWQgYXMgdGhlIG91dHB1dCBwaXhlbCB2YWx1ZXMgaWYgdGhlIGNvbmRpdGlvbiBpcyBmYWxzZS4gSXQgY2FuIGJlIGFuIGludGVnZXIsIGEgZmxvYXRpbmctcG9pbnQgcmFzdGVyLCBvciBhIGNvbnN0YW50IHZhbHVlLlwiLFxuXHRcIkBAQ29uX1Jhc3Rlcl90YWcwQEBcIjogXCJUaGUgaW5wdXQgcmFzdGVyIHRoYXQgcmVwcmVzZW50cyB0aGUgQm9vbGVhbiByZXN1bHQgb2YgYSBsb2dpY2FsIG1hdGggcmFzdGVyIGZ1bmN0aW9uLiBUaGUgdmFsdWVzIHdpbGwgYmUgZWl0aGVyIDEgKGZvciB0cnVlKSBvciAwIChmb3IgZmFsc2UpLiBJdCBjYW4gYmUgYW4gaW50ZWdlciBvciBhIGZsb2F0aW5nLXBvaW50IHJhc3Rlci5cIixcblx0XCJAQENvbl9UcnVlLVJhc3Rlcl90YWcwQEBcIjogXCJUaGUgaW5wdXQgd2hvc2UgdmFsdWVzIHdpbGwgYmUgdXNlZCBhcyB0aGUgb3V0cHV0IHBpeGVsIHZhbHVlcyBpZiB0aGUgY29uZGl0aW9uIGlzIHRydWUuIEl0IGNhbiBiZSBhbiBpbnRlZ2VyLCBhIGZsb2F0aW5nLXBvaW50IHJhc3Rlciwgb3IgYSBjb25zdGFudCB2YWx1ZS5cIixcblx0XCJAQENvbnN0YW50X0NvbnN0YW50X3RhZzBAQFwiOiBcIlRoZSB2YWx1ZSBvZiB0aGUgY29uc3RhbnQgdG8gYmUgYWRkZWQgdG8gdGhlIHZpcnR1YWwgcmFzdGVyLlwiLFxuXHRcIkBAQ29uc3RhbnRfUmFzdGVyLUluZm9fdGFnMEBAXCI6IFwiVXNlIHRoZSA8c3Ryb25nPkxvYWQgdGVtcGxhdGUgcmFzdGVyPC9zdHJvbmc+IGJ1dHRvbiB0byBsb2FkIGEgdGVtcGxhdGUgZnJvbSBhIGRpcmVjdG9yeSBvciBwb3J0YWwuXCIsXG5cdFwiQEBDb250b3VyX0FkYXB0aXZlLVNtb290aGluZ190YWcwQEBcIjogXCJUaGUgYW1vdW50IG9mIHNtb290aGluZyB0byBhcHBseSB0byB0aGUgY29udG91ciBsaW5lLiBUaGUgZGVmYXVsdCB2YWx1ZSBpcyAyLjUuXCIsXG5cdFwiQEBDb250b3VyX0FkYXB0aXZlLVNtb290aGluZ190YWcxQEBcIjogXCJBIGxvd2VyIHZhbHVlIHByb2R1Y2VzIGEgY29udG91ciBsaW5lIHdpdGggbW9yZSBncmFudWxhcml0eSBhbmQgbGVzcyBzbW9vdGhpbmcsIHdoaWxlIGEgaGlnaGVyIHZhbHVlIHByb2R1Y2VzIGEgY29udG91ciBsaW5lIHdpdGggbW9yZSBzbW9vdGhpbmcgdGhhdCBhcHBlYXJzIGxlc3MgamFnZ2VkLlwiLFxuXHRcIkBAQ29udG91cl9Db250b3VyLUludGVydmFsX3RhZzBAQFwiOiBcIlRoZSBkaWZmZXJlbmNlIGluIGFsdGl0dWRlIGJldHdlZW4gY29udG91ciBsaW5lcy5cIixcblx0XCJAQENvbnRvdXJfQ29udG91ci1JbnRlcnZhbF90YWcxQEBcIjogXCJBIHNtYWxsIGNvbnRvdXIgaW50ZXJ2YWwgaXMgdXNlZCBpbiByZWxhdGl2ZWx5IGZsYXQgYXJlYXMsIHdoaWxlIGxhcmdlciBjb250b3VyIGludGVydmFscyBhcmUgdXNlZCBpbiB2YXJpYWJsZSBvciBtb3VudGFpbm91cyB0ZXJyYWluLlwiLFxuXHRcIkBAQ29udG91cl9Db250b3VyLVR5cGVfdGFnMEBAXCI6IFwiVGhlIHR5cGUgb2YgY29udG91ciB0byBiZSBjcmVhdGVkOlwiLFxuXHRcIkBAQ29udG91cl9Db250b3VyLVR5cGVfdGFnMUBAXCI6IFwiPHN0cm9uZz5Db250b3VyIGZpbGw8L3N0cm9uZz4tLUZpbGxzIHRoZSBhcmVhIGJldHdlZW4gZXZlcnkgY29udG91ciBsaW5lIHdpdGggdGhlIHF1YW50aXplZCBlbGV2YXRpb24gdmFsdWUuXCIsXG5cdFwiQEBDb250b3VyX0NvbnRvdXItVHlwZV90YWczQEBcIjogXCI8c3Ryb25nPkNvbnRvdXIgbGluZXM8L3N0cm9uZz4tLUpvaW5zIHBvaW50cyBvZiBlcXVhbCBlbGV2YXRpb24gdG8gY3JlYXRlIGEgbGluZSByZXByZXNlbnRpbmcgY29uc3RhbnQgZWxldmF0aW9uLlwiLFxuXHRcIkBAQ29udG91cl9Db250b3VyLVR5cGVfdGFnNUBAXCI6IFwiPHN0cm9uZz5TbW9vdGggc3VyZmFjZSBvbmx5PC9zdHJvbmc+LS1TbW9vdGhzIHRoZSBpbnB1dCBlbGV2YXRpb24gbGF5ZXIgYnV0IGRvZXMgbm90IHByb2R1Y2UgY29udG91cnMuXCIsXG5cdFwiQEBDb250b3VyX050aC1Db250b3VyLUxpbmUtSW4tQm9sZF90YWcwQEBcIjogXCJUaGUgaW5kZXggY29udG91ciwgd2hpY2ggaXMgcmVwcmVzZW50ZWQgYXMgYSBib2xkIGxpbmUuXCIsXG5cdFwiQEBDb250b3VyX050aC1Db250b3VyLUxpbmUtSW4tQm9sZF90YWcxQEBcIjogXCJUaGUgZGVmYXVsdCB2YWx1ZSBpcyA1OyB0aHVzLCBldmVyeSA1dGggY29udG91ciBsaW5lIGlzIGJvbGQuXCIsXG5cdFwiQEBDb250b3VyX051bWJlci1PZi1Db250b3Vyc190YWcwQEBcIjogXCJUaGUgbnVtYmVyIG9mIGNvbnRvdXJzIHRvIGJlIGdlbmVyYXRlZCBpbiB0aGUgZGlzcGxheS4gVGhpcyBkeW5hbWljYWxseSBhZGp1c3RzIHRoZSBjb250b3VyIGludGVydmFsIHRvIGZpdCB0aGUgdGVycmFpbiBpbiB0aGUgZGlzcGxheSB3aGlsZSBtYWludGFpbmluZyBzdGFuZGFyZGl6ZWQgaW50ZXJ2YWxzIHN1Y2ggYXMgMSwgNSwgMTAsIGFuZCBzbyBvbi5cIixcblx0XCJAQENvbnRvdXJfUmFzdGVyX3RhZzBAQFwiOiBcIkEgc2luZ2xlIGJhbmQgcmFzdGVyIGVsZXZhdGlvbiBkYXRhc2V0LlwiLFxuXHRcIkBAQ29udG91cl9aLUJhc2VfdGFnMEBAXCI6IFwiVGhlIGJhc2UgY29udG91ciB2YWx1ZS4gQ29udG91cnMgYXJlIGdlbmVyYXRlZCBhYm92ZSBhbmQgYmVsb3cgdGhpcyB2YWx1ZSBhcyBuZWVkZWQgdG8gY292ZXIgdGhlIGVudGlyZSB2YWx1ZSByYW5nZSBvZiB0aGUgaW5wdXQgcmFzdGVyLiBUaGUgZGVmYXVsdCBpcyAwLlwiLFxuXHRcIkBAQ29udG91cl9aLUJhc2VfdGFnMUBAXCI6IFwiQSB2YWx1ZSBvZiAwIG9mdGVuIHJlcHJlc2VudHMgbWVhbiBzZWEgbGV2ZWwsIGRlcGVuZGluZyBvbiB0aGUgc291cmNlIGVsZXZhdGlvbiBkYXRhc2V0LlwiLFxuXHRcIkBAQ29udG91cl9aLUZhY3Rvcl90YWcwQEBcIjogXCJUaGUgdW5pdCBjb252ZXJzaW9uIGZhY3RvciB1c2VkIHdoZW4gZ2VuZXJhdGluZyBjb250b3Vycy4gVGhlIGRlZmF1bHQgdmFsdWUgaXMgMS5cIixcblx0XCJAQENvbnRvdXJfWi1GYWN0b3JfdGFnMUBAXCI6IFwiVGhlIGNvbnRvdXIgbGluZXMgYXJlIGdlbmVyYXRlZCBiYXNlZCBvbiB0aGUgei12YWx1ZXMgaW4gdGhlIGlucHV0IHJhc3Rlciwgd2hpY2ggYXJlIG9mdGVuIG1lYXN1cmVkIGluIHVuaXRzIG9mIG1ldGVycyBvciBmZWV0LiBXaXRoIHRoZSBkZWZhdWx0IHZhbHVlIG9mIDEsIHRoZSBjb250b3VycyB3aWxsIGJlIGluIHRoZSBzYW1lIHVuaXRzIGFzIHRoZSB6LXZhbHVlcyBvZiB0aGUgaW5wdXQgcmFzdGVyLiBUbyBjcmVhdGUgY29udG91cnMgaW4gYSBkaWZmZXJlbnQgdW5pdCB0aGFuIHRoYXQgb2YgdGhlIHotdmFsdWVzLCBzZXQgYW4gYXBwcm9wcmlhdGUgdmFsdWUgZm9yIHRoZSB6LWZhY3Rvci4gTm90ZSB0aGF0IGl0IGlzIG5vdCBuZWNlc3NhcnkgdG8gaGF2ZSB0aGUgZ3JvdW5kIHgseSBhbmQgc3VyZmFjZSB6LXVuaXRzIGJlIGNvbnNpc3RlbnQgZm9yIHRoaXMgdG9vbC5cIixcblx0XCJAQENvbnRvdXJfWi1GYWN0b3JfdGFnMkBAXCI6IFwiRm9yIGV4YW1wbGUsIGlmIHRoZSBlbGV2YXRpb24gdmFsdWVzIGluIHlvdXIgaW5wdXQgcmFzdGVyIGFyZSBpbiBmZWV0LCBidXQgeW91IHdhbnQgdGhlIGNvbnRvdXJzIHRvIGJlIGdlbmVyYXRlZCBiYXNlZCBvbiB1bml0cyBvZiBtZXRlcnMsIHNldCB0aGUgei1mYWN0b3IgdG8gMC4zMDQ4IChzaW5jZSAxIGZvb3QgPTAuMzA0OCBtZXRlcnMpLlwiLFxuXHRcIkBAQ29udHJhc3QtYW5kLUJyaWdodG5lc3NfQnJpZ2h0bmVzcy1PZmZzZXRfdGFnMEBAXCI6IFwiQWRqdXN0IHRoZSBicmlnaHRuZXNzIG9mIHRoZSByYXN0ZXIgbGF5ZXIuXCIsXG5cdFwiQEBDb250cmFzdC1hbmQtQnJpZ2h0bmVzc19CcmlnaHRuZXNzLU9mZnNldF90YWcxQEBcIjogXCJZb3UgY2FuIHVzZSB0aGUgc2xpZGVyIHRvIG1vZGlmeSB0aGUgYnJpZ2h0bmVzcyBvZmZzZXQsIG9yIHlvdSBjYW4gdHlwZSBhIHZhbHVlLlwiLFxuXHRcIkBAQ29udHJhc3QtYW5kLUJyaWdodG5lc3NfQ29udHJhc3QtT2Zmc2V0X3RhZzBAQFwiOiBcIkFkanVzdCB0aGUgY29udHJhc3Qgb2YgdGhlIHJhc3RlciBsYXllci5cIixcblx0XCJAQENvbnRyYXN0LWFuZC1CcmlnaHRuZXNzX0NvbnRyYXN0LU9mZnNldF90YWcxQEBcIjogXCJZb3UgY2FuIHVzZSB0aGUgc2xpZGVyIHRvIG1vZGlmeSB0aGUgY29udHJhc3Qgb2Zmc2V0LCBvciB5b3UgY2FuIHR5cGUgYSB2YWx1ZS5cIixcblx0XCJAQENvbnRyYXN0LWFuZC1CcmlnaHRuZXNzX1Jhc3Rlcl90YWcwQEBcIjogXCJUaGUgaW5wdXQgcmFzdGVyIG9uIHdoaWNoIHRvIGVkaXQgdGhlIGJyaWdodG5lc3MgYW5kIGNvbnRyYXN0LlwiLFxuXHRcIkBAQ29udm9sdXRpb25fa2VybmVsX3RhZzBAQFwiOiBcIjxwPlRoaXMgdGFibGUgc2hvd3MgaG93IGVhY2ggcGl4ZWwgd2lsbCBiZSB3ZWlnaHRlZCBpbiB0aGUgZmlsdGVyaW5nIHByb2Nlc3MuIFRoaXMgdGFibGUgY2FuIGJlIGVkaXRlZCBpZiB5b3UgY2hvb3NlPHN0cm9uZz5Vc2VyIERlZmluZWQ8L3N0cm9uZz5hcyB0aGU8c3Ryb25nPlR5cGU8L3N0cm9uZz4uPC9wPlwiLFxuXHRcIkBAQ29udm9sdXRpb25fUmFzdGVyX3RhZzBAQFwiOiBcIlRoZSBpbnB1dCByYXN0ZXIgZGF0YXNldC5cIixcblx0XCJAQENvbnZvbHV0aW9uX1R5cGVfdGFnMEBAXCI6IFwiU2VsZWN0IHRoZSB0eXBlIG9mIGZpbHRlcmluZyB5b3Ugd2FudCB0byBwZXJmb3JtLiBUaGVyZSBhcmUgb3B0aW9ucyBmb3Igc2hhcnBlbmluZywgYmx1cnJpbmcsIGFuZCBkZXRlY3RpbmcgZWRnZXMsIG9yIHlvdSBjYW4gZGVmaW5lIHlvdXIgb3duIGtlcm5lbC1iYXNlZCBmaWx0ZXJcIixcblx0XCJAQENvcnJpZG9yX0Rpc3RhbmNlLVJhc3Rlci0xX3RhZzBAQFwiOiBcIlRoZSBmaXJzdCBpbnB1dCBkaXN0YW5jZSByYXN0ZXIuIEl0IHNob3VsZCBiZSBhbiBhY2N1bXVsYXRlZCBjb3N0IGRpc3RhbmNlIG91dHB1dCBmcm9tIENvc3QgRGlzdGFuY2Ugb3IgUGF0aCBEaXN0YW5jZS5cIixcblx0XCJAQENvcnJpZG9yX0Rpc3RhbmNlLVJhc3Rlci0yX3RhZzBAQFwiOiBcIlRoZSBzZWNvbmQgaW5wdXQgZGlzdGFuY2UgcmFzdGVyLiBJdCBzaG91bGQgYmUgYW4gYWNjdW11bGF0ZWQgY29zdCBkaXN0YW5jZSBvdXRwdXQgZnJvbSBDb3N0IERpc3RhbmNlIG9yIFBhdGggRGlzdGFuY2UuXCIsXG5cdFwiQEBDb3NfQ2VsbHNpemUtVHlwZV90YWcwQEBcIjogXCJDaG9vc2Ugd2hpY2ggY2VsbCBzaXplIHRvIHVzZSBpbiB0aGUgb3V0cHV0IHJhc3Rlci4gSWYgYWxsIHRoZSBpbnB1dCBjZWxsIHNpemVzIGFyZSB0aGUgc2FtZSwgYWxsIHRoZSBvcHRpb25zIHdpbGwgeWllbGQgdGhlIHNhbWUgcmVzdWx0cy5cIixcblx0XCJAQENvc19DZWxsc2l6ZS1UeXBlX3RhZzFAQFwiOiBcIkZpcnN0IE9mLS1Vc2UgdGhlIGZpcnN0IGNlbGwgc2l6ZSBvZiB0aGUgaW5wdXQgcmFzdGVycy5cIixcblx0XCJAQENvc19DZWxsc2l6ZS1UeXBlX3RhZzJAQFwiOiBcIkxhc3QgT2YtLVVzZSB0aGUgbGFzdCBjZWxsIHNpemUgb2YgdGhlIGlucHV0IHJhc3RlcnMuXCIsXG5cdFwiQEBDb3NfQ2VsbHNpemUtVHlwZV90YWczQEBcIjogXCJNYXggT2YtLVVzZSB0aGUgbGFyZ2VzdCBjZWxsIHNpemUgb2YgYWxsIHRoZSBpbnB1dCByYXN0ZXJzLiBUaGlzIGlzIHRoZSBkZWZhdWx0LlwiLFxuXHRcIkBAQ29zX0NlbGxzaXplLVR5cGVfdGFnNEBAXCI6IFwiTWVhbiBPZi0tVXNlIHRoZSBtZWFuIGNlbGwgc2l6ZSBvZiBhbGwgdGhlIGlucHV0IHJhc3RlcnMuXCIsXG5cdFwiQEBDb3NfQ2VsbHNpemUtVHlwZV90YWc1QEBcIjogXCJNaW4gT2YtLVVzZSB0aGUgc21hbGxlc3QgY2VsbCBzaXplIG9mIGFsbCB0aGUgaW5wdXQgcmFzdGVycy5cIixcblx0XCJAQENvc19FeHRlbnQtVHlwZV90YWcwQEBcIjogXCJDaG9vc2Ugd2hpY2ggZXh0ZW50IHNob3VsZCBiZSB1c2VkIGluIHRoZSBvdXRwdXQgcmFzdGVyOlwiLFxuXHRcIkBAQ29zX0V4dGVudC1UeXBlX3RhZzFAQFwiOiBcIkZpcnN0IE9mLS1Vc2UgdGhlIGV4dGVudCBvZiB0aGUgZmlyc3QgaW5wdXQgcmFzdGVyIHRvIGRldGVybWluZSB0aGUgcHJvY2Vzc2luZyBleHRlbnQuXCIsXG5cdFwiQEBDb3NfRXh0ZW50LVR5cGVfdGFnMkBAXCI6IFwiSW50ZXJzZWN0aW9uIE9mLS1Vc2UgdGhlIGV4dGVudCBvZiB0aGUgb3ZlcmxhcHBpbmcgcGl4ZWxzIHRvIGRldGVybWluZSB0aGUgcHJvY2Vzc2luZyBleHRlbnQuIFRoaXMgaXMgdGhlIGRlZmF1bHQuXCIsXG5cdFwiQEBDb3NfRXh0ZW50LVR5cGVfdGFnM0BAXCI6IFwiTGFzdCBPZi0tVXNlIHRoZSBleHRlbnQgb2YgdGhlIGxhc3QgaW5wdXQgcmFzdGVyIHRvIGRldGVybWluZSB0aGUgcHJvY2Vzc2luZyBleHRlbnQuXCIsXG5cdFwiQEBDb3NfRXh0ZW50LVR5cGVfdGFnNEBAXCI6IFwiVW5pb24gT2YtLVVzZSB0aGUgZXh0ZW50IG9mIGFsbCB0aGUgcmFzdGVycyB0byBkZXRlcm1pbmUgdGhlIHByb2Nlc3NpbmcgZXh0ZW50LlwiLFxuXHRcIkBAQ29zX1Jhc3Rlcl90YWcwQEBcIjogXCJUaGUgaW5wdXQgZm9yIHdoaWNoIHRvIGNhbGN1bGF0ZSB0aGUgY29zaW5lIHZhbHVlcy5cIixcblx0XCJAQENvc0hfQ2VsbHNpemUtVHlwZV90YWcwQEBcIjogXCJDaG9vc2Ugd2hpY2ggY2VsbCBzaXplIHRvIHVzZSBpbiB0aGUgb3V0cHV0IHJhc3Rlci4gSWYgYWxsIHRoZSBpbnB1dCBjZWxsIHNpemVzIGFyZSB0aGUgc2FtZSwgYWxsIHRoZSBvcHRpb25zIHdpbGwgeWllbGQgdGhlIHNhbWUgcmVzdWx0cy5cIixcblx0XCJAQENvc0hfQ2VsbHNpemUtVHlwZV90YWcxQEBcIjogXCJGaXJzdCBPZi0tVXNlIHRoZSBmaXJzdCBjZWxsIHNpemUgb2YgdGhlIGlucHV0IHJhc3RlcnMuXCIsXG5cdFwiQEBDb3NIX0NlbGxzaXplLVR5cGVfdGFnMkBAXCI6IFwiTGFzdCBPZi0tVXNlIHRoZSBsYXN0IGNlbGwgc2l6ZSBvZiB0aGUgaW5wdXQgcmFzdGVycy5cIixcblx0XCJAQENvc0hfQ2VsbHNpemUtVHlwZV90YWczQEBcIjogXCJNYXggT2YtLVVzZSB0aGUgbGFyZ2VzdCBjZWxsIHNpemUgb2YgYWxsIHRoZSBpbnB1dCByYXN0ZXJzLiBUaGlzIGlzIHRoZSBkZWZhdWx0LlwiLFxuXHRcIkBAQ29zSF9DZWxsc2l6ZS1UeXBlX3RhZzRAQFwiOiBcIk1lYW4gT2YtLVVzZSB0aGUgbWVhbiBjZWxsIHNpemUgb2YgYWxsIHRoZSBpbnB1dCByYXN0ZXJzLlwiLFxuXHRcIkBAQ29zSF9DZWxsc2l6ZS1UeXBlX3RhZzVAQFwiOiBcIk1pbiBPZi0tVXNlIHRoZSBzbWFsbGVzdCBjZWxsIHNpemUgb2YgYWxsIHRoZSBpbnB1dCByYXN0ZXJzLlwiLFxuXHRcIkBAQ29zSF9FeHRlbnQtVHlwZV90YWcwQEBcIjogXCJDaG9vc2Ugd2hpY2ggZXh0ZW50IHNob3VsZCBiZSB1c2VkIGluIHRoZSBvdXRwdXQgcmFzdGVyOlwiLFxuXHRcIkBAQ29zSF9FeHRlbnQtVHlwZV90YWcxQEBcIjogXCJGaXJzdCBPZi0tVXNlIHRoZSBleHRlbnQgb2YgdGhlIGZpcnN0IGlucHV0IHJhc3RlciB0byBkZXRlcm1pbmUgdGhlIHByb2Nlc3NpbmcgZXh0ZW50LlwiLFxuXHRcIkBAQ29zSF9FeHRlbnQtVHlwZV90YWcyQEBcIjogXCJJbnRlcnNlY3Rpb24gT2YtLVVzZSB0aGUgZXh0ZW50IG9mIHRoZSBvdmVybGFwcGluZyBwaXhlbHMgdG8gZGV0ZXJtaW5lIHRoZSBwcm9jZXNzaW5nIGV4dGVudC4gVGhpcyBpcyB0aGUgZGVmYXVsdC5cIixcblx0XCJAQENvc0hfRXh0ZW50LVR5cGVfdGFnM0BAXCI6IFwiTGFzdCBPZi0tVXNlIHRoZSBleHRlbnQgb2YgdGhlIGxhc3QgaW5wdXQgcmFzdGVyIHRvIGRldGVybWluZSB0aGUgcHJvY2Vzc2luZyBleHRlbnQuXCIsXG5cdFwiQEBDb3NIX0V4dGVudC1UeXBlX3RhZzRAQFwiOiBcIlVuaW9uIE9mLS1Vc2UgdGhlIGV4dGVudCBvZiBhbGwgdGhlIHJhc3RlcnMgdG8gZGV0ZXJtaW5lIHRoZSBwcm9jZXNzaW5nIGV4dGVudC5cIixcblx0XCJAQENvc0hfUmFzdGVyX3RhZzBAQFwiOiBcIlRoZSBpbnB1dCBmb3Igd2hpY2ggdG8gY2FsY3VsYXRlIHRoZSBoeXBlcmJvbGljIGNvc2luZSB2YWx1ZXMuXCIsXG5cdFwiQEBDb3N0LUFsbG9jYXRpb25fQWNjdW11bGF0aXZlLUNvc3QtUmVzaXN0YW5jZS1SYXRlX3RhZzBAQFwiOiBcIlRoaXMgcGFyYW1ldGVyIHNpbXVsYXRlcyB0aGUgaW5jcmVhc2UgaW4gdGhlIGVmZm9ydCB0byBvdmVyY29tZSBjb3N0cyBhcyB0aGUgYWNjdW11bGF0aXZlIGNvc3QgaW5jcmVhc2VzLiBJdCBpcyB1c2VkIHRvIG1vZGVsIGZhdGlndWUgb2YgdGhlIHRyYXZlbGVyLiBUaGUgZ3Jvd2luZyBhY2N1bXVsYXRpdmUgY29zdCB0byByZWFjaCBhIGNlbGwgaXMgbXVsdGlwbGllZCBieSB0aGUgcmVzaXN0YW5jZSByYXRlIGFuZCBhZGRlZCB0byB0aGUgY29zdCB0byBtb3ZlIGludG8gdGhlIHN1YnNlcXVlbnQgY2VsbC5cIixcblx0XCJAQENvc3QtQWxsb2NhdGlvbl9BY2N1bXVsYXRpdmUtQ29zdC1SZXNpc3RhbmNlLVJhdGVfdGFnMUBAXCI6IFwiSXQncyBhIG1vZGlmaWVkIHZlcnNpb24gb2YgYSBjb21wb3VuZCBpbnRlcmVzdCByYXRlIGZvcm11bGEgdGhhdCdzIHVzZWQgdG8gY2FsY3VsYXRlIHRoZSBhcHBhcmVudCBjb3N0IG9mIG1vdmluZyB0aHJvdWdoIGEgY2VsbC4gQXMgdGhlIHZhbHVlIG9mIHRoZSByZXNpc3RhbmNlIHJhdGUgaW5jcmVhc2VzLCBpdCBpbmNyZWFzZXMgdGhlIGNvc3Qgb2YgdGhlIGNlbGxzIHRoYXQgYXJlIHZpc2l0ZWQgbGF0ZXIuIFRoZSBncmVhdGVyIHRoZSByZXNpc3RhbmNlIHJhdGUsIHRoZSBoaWdoZXIgdGhlIGNvc3QgdG8gcmVhY2ggdGhlIG5leHQgY2VsbCwgd2hpY2ggaXMgY29tcG91bmRlZCBmb3IgZWFjaCBzdWJzZXF1ZW50IG1vdmVtZW50LiBTaW5jZSB0aGUgcmVzaXN0YW5jZSByYXRlIGlzIHNpbWlsYXIgdG8gYSBjb21wb3VuZCByYXRlIGFuZCBnZW5lcmFsbHkgdGhlIGFjY3VtdWxhdGl2ZSBjb3N0IHZhbHVlcyBhcmUgdmVyeSBsYXJnZSwgc21hbGwgcmVzaXN0YW5jZSByYXRlcyBhcmUgc3VnZ2VzdGVkLCBzdWNoIGFzIDAuMDA1IG9yIGV2ZW4gc21hbGxlciwgZGVwZW5kaW5nIG9uIHRoZSBhY2N1bXVsYXRpdmUgY29zdCB2YWx1ZXMuXCIsXG5cdFwiQEBDb3N0LUFsbG9jYXRpb25fQWNjdW11bGF0aXZlLUNvc3QtUmVzaXN0YW5jZS1SYXRlX3RhZzJAQFwiOiBcIlRoZSB2YWx1ZSBtdXN0IGJlIGdyZWF0ZXIgdGhhbiB6ZXJvLiBUaGUgZGVmYXVsdCBjYXBhY2l0eSBpcyB0byB0aGUgZWRnZSBvZiB0aGUgb3V0cHV0IHJhc3Rlci5cIixcblx0XCJAQENvc3QtQWxsb2NhdGlvbl9BY2N1bXVsYXRpdmUtQ29zdC1SZXNpc3RhbmNlLVJhdGVfdGFnM0BAXCI6IFwiQSBudW1lcmljIChkb3VibGUpIHZhbHVlIG9yIGEgZmllbGQgZnJvbSB0aGUgPHN0cm9uZz5Tb3VyY2UgUmFzdGVyPC9zdHJvbmc+IGNhbiBiZSB1c2VkIGZvciB0aGlzIHBhcmFtZXRlci5cIixcblx0XCJAQENvc3QtQWxsb2NhdGlvbl9DYXBhY2l0eV90YWcwQEBcIjogXCJEZWZpbmVzIHRoZSBjb3N0IGNhcGFjaXR5IGZvciB0aGUgdHJhdmVsZXIgZm9yIGEgc291cmNlLiBUaGUgY29zdCBjYWxjdWxhdGlvbnMgY29udGludWUgZm9yIGVhY2ggc291cmNlIHVudGlsIHRoZSBzcGVjaWZpZWQgY2FwYWNpdHkgaXMgcmVhY2hlZC5cIixcblx0XCJAQENvc3QtQWxsb2NhdGlvbl9DYXBhY2l0eV90YWcxQEBcIjogXCJUaGUgdmFsdWUgbXVzdCBiZSBncmVhdGVyIHRoYW4gemVyby4gVGhlIGRlZmF1bHQgY2FwYWNpdHkgaXMgdG8gdGhlIGVkZ2Ugb2YgdGhlIG91dHB1dCByYXN0ZXIuXCIsXG5cdFwiQEBDb3N0LUFsbG9jYXRpb25fQ2FwYWNpdHlfdGFnMkBAXCI6IFwiQSBudW1lcmljIChkb3VibGUpIHZhbHVlIG9yIGEgZmllbGQgZnJvbSB0aGUgPHN0cm9uZz5Tb3VyY2UgUmFzdGVyPC9zdHJvbmc+IGNhbiBiZSB1c2VkIGZvciB0aGlzIHBhcmFtZXRlci5cIixcblx0XCJAQENvc3QtQWxsb2NhdGlvbl9Db3N0LVJhc3Rlcl90YWcwQEBcIjogXCJBIHJlcXVpcmVkIGlucHV0IHJhc3RlciBkZWZpbmluZyB0aGUgY29zdCBvciBpbXBlZGFuY2UgdG8gbW92ZSBwbGFuaW1ldHJpY2FsbHkgdGhyb3VnaCBlYWNoIGNlbGwuIFRoZSB2YWx1ZSBhdCBlYWNoIGNlbGwgbG9jYXRpb24gcmVwcmVzZW50cyB0aGUgY29zdC1wZXItdW5pdCBkaXN0YW5jZSBmb3IgbW92aW5nIHRocm91Z2ggaXQuIEVhY2ggY2VsbCBsb2NhdGlvbiB2YWx1ZSBpcyBtdWx0aXBsaWVkIGJ5IHRoZSBjZWxsIHJlc29sdXRpb24sIGFuZCBhbHNvIGNvbXBlbnNhdGVzIGZvciBkaWFnb25hbCBtb3ZlbWVudCB0byBvYnRhaW4gdGhlIHRvdGFsIGNvc3Qgb2YgcGFzc2luZyB0aHJvdWdoIHRoZSBjZWxsLlwiLFxuXHRcIkBAQ29zdC1BbGxvY2F0aW9uX0Nvc3QtUmFzdGVyX3RhZzFAQFwiOiBcIlRoZSB2YWx1ZXMgb2YgdGhlIDxzdHJvbmc+Q29zdCBSYXN0ZXI8L3N0cm9uZz4gY2FuIGJlIGludGVnZXIgb3IgZmxvYXRpbmcgcG9pbnQsIGJ1dCB0aGV5IGNhbm5vdCBiZSBuZWdhdGl2ZSBvciB6ZXJvLlwiLFxuXHRcIkBAQ29zdC1BbGxvY2F0aW9uX01heGltdW0tRGlzdGFuY2VfdGFnMEBAXCI6IFwiVGhlIHRocmVzaG9sZCB0aGF0IHRoZSBhY2N1bXVsYXRpdmUgY29zdCB2YWx1ZXMgY2Fubm90IGV4Y2VlZC4gSWYgYW4gYWNjdW11bGF0aXZlIGNvc3QgZGlzdGFuY2UgZXhjZWVkcyB0aGlzIHZhbHVlLCB0aGUgb3V0cHV0IHZhbHVlIGZvciB0aGUgY2VsbCBsb2NhdGlvbiB3aWxsIGJlICR7Tm9EYXRhfS4gVGhlIG1heGltdW0gZGlzdGFuY2UgZGVmaW5lcyB0aGUgZXh0ZW50IGZvciB3aGljaCB0aGUgYWNjdW11bGF0aXZlIGNvc3QgZGlzdGFuY2VzIGFyZSBjYWxjdWxhdGVkLiBUaGUgZGVmYXVsdCBkaXN0YW5jZSBpcyB0byB0aGUgZXh0ZW50IG9mIHRoZSBvdXRwdXQgcmFzdGVyLlwiLFxuXHRcIkBAQ29zdC1BbGxvY2F0aW9uX011bHRpcGxpZXItdG8tQXBwbHktdG8tQ29zdHNfdGFnMEBAXCI6IFwiQSBtdWx0aXBsaWVyIHRvIGFwcGx5IHRvIHRoZSBjb3N0IHZhbHVlcy5cIixcblx0XCJAQENvc3QtQWxsb2NhdGlvbl9NdWx0aXBsaWVyLXRvLUFwcGx5LXRvLUNvc3RzX3RhZzFAQFwiOiBcIlRoaXMgcGFyYW1ldGVyIGFsbG93cyBmb3IgY29udHJvbCBvZiB0aGUgbW9kZSBvZiB0cmF2ZWwgb3IgdGhlIG1hZ25pdHVkZSBhdCBhIHNvdXJjZS4gVGhlIGdyZWF0ZXIgdGhlIG11bHRpcGxpZXIsIHRoZSBncmVhdGVyIHRoZSBjb3N0IHRvIG1vdmUgdGhyb3VnaCBlYWNoIGNlbGwuXCIsXG5cdFwiQEBDb3N0LUFsbG9jYXRpb25fTXVsdGlwbGllci10by1BcHBseS10by1Db3N0c190YWcyQEBcIjogXCJUaGUgdmFsdWVzIG11c3QgYmUgZ3JlYXRlciB0aGFuIHplcm8uIFRoZSBkZWZhdWx0IGlzIDEuXCIsXG5cdFwiQEBDb3N0LUFsbG9jYXRpb25fTXVsdGlwbGllci10by1BcHBseS10by1Db3N0c190YWczQEBcIjogXCJBIG51bWVyaWMgKGRvdWJsZSkgdmFsdWUgb3IgYSBmaWVsZCBmcm9tIHRoZSA8c3Ryb25nPlNvdXJjZSBSYXN0ZXI8L3N0cm9uZz4gY2FuIGJlIHVzZWQgZm9yIHRoaXMgcGFyYW1ldGVyLlwiLFxuXHRcIkBAQ29zdC1BbGxvY2F0aW9uX1NvdXJjZS1GaWVsZF90YWcwQEBcIjogXCJUaGUgZmllbGQgdXNlZCB0byBhc3NpZ24gdmFsdWVzIHRvIHRoZSBzb3VyY2UgbG9jYXRpb25zLiBJdCBtdXN0IGJlIGFuIGludGVnZXIgdHlwZS4gSWYgdGhlIDxzdHJvbmc+VmFsdWUgUmFzdGVyPC9zdHJvbmc+IGhhcyBiZWVuIHNldCwgdGhlIHZhbHVlcyBpbiB0aGF0IGlucHV0IHdpbGwgdGFrZSBwcmVjZWRlbmNlIG92ZXIgYW55IHNldHRpbmcgZm9yIHRoZSA8c3Ryb25nPlNvdXJjZSBGaWVsZDwvc3Ryb25nPi5cIixcblx0XCJAQENvc3QtQWxsb2NhdGlvbl9Tb3VyY2UtUmFzdGVyX3RhZzBAQFwiOiBcIlRoZSByZXF1aXJlZCBpbnB1dCByYXN0ZXIgb2Ygc291cmNlIGxvY2F0aW9ucy5cIixcblx0XCJAQENvc3QtQWxsb2NhdGlvbl9Tb3VyY2UtUmFzdGVyX3RhZzFAQFwiOiBcIlRoaXMgaXMgYSByYXN0ZXIgdGhhdCBpZGVudGlmaWVzIHRoZSBjZWxscyBvciBsb2NhdGlvbnMgZnJvbSB3aGljaCB0aGUgbGVhc3QgYWNjdW11bGF0ZWQgY29zdCBkaXN0YW5jZSBmb3IgZXZlcnkgb3V0cHV0IGNlbGwgbG9jYXRpb24gaXMgY2FsY3VsYXRlZC5cIixcblx0XCJAQENvc3QtQWxsb2NhdGlvbl9Tb3VyY2UtUmFzdGVyX3RhZzJAQFwiOiBcIklmIHRoZSBpbnB1dCA8c3Ryb25nPlNvdXJjZSBSYXN0ZXI8L3N0cm9uZz4gaXMgZmxvYXRpbmcgcG9pbnQsIHRoZSA8c3Ryb25nPlZhbHVlIFJhc3Rlcjwvc3Ryb25nPiBtdXN0IGJlIHNldCwgYW5kIGl0IG11c3QgYmUgYW4gaW50ZWdlci4gVGhlIDxzdHJvbmc+VmFsdWUgUmFzdGVyPC9zdHJvbmc+IHdpbGwgdGFrZSBwcmVjZWRlbmNlIG92ZXIgYW55IHNldHRpbmcgb2YgdGhlIDxzdHJvbmc+U291cmNlIEZpZWxkPC9zdHJvbmc+LlwiLFxuXHRcIkBAQ29zdC1BbGxvY2F0aW9uX1N0YXJ0LUNvc3RfdGFnMEBAXCI6IFwiVGhlIHN0YXJ0aW5nIGNvc3QgZnJvbSB3aGljaCB0byBiZWdpbiB0aGUgY29zdCBjYWxjdWxhdGlvbnMuIFRoaXMgcGFyYW1ldGVyIGFsbG93cyBmb3IgdGhlIHNwZWNpZmljYXRpb24gb2YgdGhlIGZpeGVkIGNvc3QgYXNzb2NpYXRlZCB3aXRoIGEgc291cmNlLiBJbnN0ZWFkIG9mIHN0YXJ0aW5nIGF0IGEgY29zdCBvZiAwLCB0aGUgY29zdCBhbGdvcml0aG0gd2lsbCBiZWdpbiB3aXRoIHRoZSB2YWx1ZSBzcGVjaWZpZWQuXCIsXG5cdFwiQEBDb3N0LUFsbG9jYXRpb25fU3RhcnQtQ29zdF90YWcxQEBcIjogXCJUaGUgdmFsdWUgbXVzdCBiZSB6ZXJvIG9yIGdyZWF0ZXIuIFRoZSBkZWZhdWx0IGlzIDAuXCIsXG5cdFwiQEBDb3N0LUFsbG9jYXRpb25fVHJhdmVsLURpcmVjdGlvbl90YWcwQEBcIjogXCJEZWZpbmVzIHRoZSBkaXJlY3Rpb24gb2YgdGhlIHRyYXZlbGVyIHdoZW4gYXBwbHlpbmcgdGhlIHNvdXJjZSByZXNpc3RhbmNlIHJhdGUgYW5kIHRoZSBzb3VyY2Ugc3RhcnRpbmcgY29zdC5cIixcblx0XCJAQENvc3QtQWxsb2NhdGlvbl9UcmF2ZWwtRGlyZWN0aW9uX3RhZzFAQFwiOiBcIjxzdHJvbmc+RnJvbSBTb3VyY2U8L3N0cm9uZz4tLVRoZSBzb3VyY2UgcmVzaXN0YW5jZSByYXRlIGFuZCBzb3VyY2Ugc3RhcnRpbmcgY29zdCB3aWxsIGJlIGFwcGxpZWQgYmVnaW5uaW5nIGF0IHRoZSBpbnB1dCBzb3VyY2UgYW5kIG1vdmluZyBvdXQgdG8gdGhlIG5vbi1zb3VyY2UgY2VsbHMuIFRoaXMgaXMgdGhlIGRlZmF1bHQuXCIsXG5cdFwiQEBDb3N0LUFsbG9jYXRpb25fVHJhdmVsLURpcmVjdGlvbl90YWczQEBcIjogXCI8c3Ryb25nPlRvIFNvdXJjZTwvc3Ryb25nPi0tVGhlIHNvdXJjZSByZXNpc3RhbmNlIHJhdGUgYW5kIHNvdXJjZSBzdGFydGluZyBjb3N0IHdpbGwgYmUgYXBwbGllZCBiZWdpbm5pbmcgYXQgZWFjaCBub24tc291cmNlIGNlbGwgYW5kIG1vdmluZyBiYWNrIHRvIHRoZSBpbnB1dCBzb3VyY2UuXCIsXG5cdFwiQEBDb3N0LUFsbG9jYXRpb25fVHJhdmVsLURpcmVjdGlvbl90YWc1QEBcIjogXCJFaXRoZXIgc3BlY2lmeSB0aGUgPHN0cm9uZz5Gcm9tIFNvdXJjZTwvc3Ryb25nPiBvciA8c3Ryb25nPlRvIFNvdXJjZTwvc3Ryb25nPiBrZXl3b3JkLCB3aGljaCB3aWxsIGJlIGFwcGxpZWQgdG8gYWxsIHNvdXJjZXMsIG9yIHNwZWNpZnkgYSBmaWVsZCBpbiB0aGUgPHN0cm9uZz5Tb3VyY2UgUmFzdGVyPC9zdHJvbmc+IHRoYXQgY29udGFpbnMgdGhlIGtleXdvcmRzIHRvIGlkZW50aWZ5IHRoZSBkaXJlY3Rpb24gb2YgdHJhdmVsIGZvciBlYWNoIHNvdXJjZS4gVGhhdCBmaWVsZCBtdXN0IGNvbnRhaW4gdGhlIHN0cmluZyAke0ZST01fU09VUkNFfSBvciAke1RPX1NPVVJDRX0uXCIsXG5cdFwiQEBDb3N0LUFsbG9jYXRpb25fVmFsdWUtUmFzdGVyX3RhZzBAQFwiOiBcIlRoZSBpbnB1dCBpbnRlZ2VyIHJhc3RlciB0aGF0IGlkZW50aWZpZXMgdGhlIHpvbmUgdmFsdWVzIHRvIGJlIHVzZWQgZm9yIGVhY2ggaW5wdXQgc291cmNlIGxvY2F0aW9uLiBGb3IgZWFjaCBzb3VyY2UgbG9jYXRpb24gY2VsbCwgdGhlIHZhbHVlIGRlZmluZWQgYnkgdGhlIDxzdHJvbmc+VmFsdWUgUmFzdGVyPC9zdHJvbmc+IHdpbGwgYmUgYXNzaWduZWQgdG8gYWxsIGNlbGxzIGFsbG9jYXRlZCB0byB0aGUgc291cmNlIGxvY2F0aW9uIGZvciB0aGUgY29tcHV0YXRpb24uIFRoZSA8c3Ryb25nPlZhbHVlIFJhc3Rlcjwvc3Ryb25nPiB3aWxsIHRha2UgcHJlY2VkZW5jZSBvdmVyIGFueSBzZXR0aW5nIGZvciB0aGUgPHN0cm9uZz5Tb3VyY2UgRmllbGQ8L3N0cm9uZz4uXCIsXG5cdFwiQEBDb3N0LUJhY2stTGlua19BY2N1bXVsYXRpdmUtQ29zdC1SZXNpc3RhbmNlLVJhdGVfdGFnMEBAXCI6IFwiVGhpcyBwYXJhbWV0ZXIgc2ltdWxhdGVzIHRoZSBpbmNyZWFzZSBpbiB0aGUgZWZmb3J0IHRvIG92ZXJjb21lIGNvc3RzIGFzIHRoZSBhY2N1bXVsYXRpdmUgY29zdCBpbmNyZWFzZXMuIEl0IGlzIHVzZWQgdG8gbW9kZWwgZmF0aWd1ZSBvZiB0aGUgdHJhdmVsZXIuIFRoZSBncm93aW5nIGFjY3VtdWxhdGl2ZSBjb3N0IHRvIHJlYWNoIGEgY2VsbCBpcyBtdWx0aXBsaWVkIGJ5IHRoZSByZXNpc3RhbmNlIHJhdGUgYW5kIGFkZGVkIHRvIHRoZSBjb3N0IHRvIG1vdmUgaW50byB0aGUgc3Vic2VxdWVudCBjZWxsLlwiLFxuXHRcIkBAQ29zdC1CYWNrLUxpbmtfQWNjdW11bGF0aXZlLUNvc3QtUmVzaXN0YW5jZS1SYXRlX3RhZzFAQFwiOiBcIkl0J3MgYSBtb2RpZmllZCB2ZXJzaW9uIG9mIGEgY29tcG91bmQgaW50ZXJlc3QgcmF0ZSBmb3JtdWxhIHRoYXQncyB1c2VkIHRvIGNhbGN1bGF0ZSB0aGUgYXBwYXJlbnQgY29zdCBvZiBtb3ZpbmcgdGhyb3VnaCBhIGNlbGwuIEFzIHRoZSB2YWx1ZSBvZiB0aGUgcmVzaXN0YW5jZSByYXRlIGluY3JlYXNlcywgaXQgaW5jcmVhc2VzIHRoZSBjb3N0IG9mIHRoZSBjZWxscyB0aGF0IGFyZSB2aXNpdGVkIGxhdGVyLiBUaGUgZ3JlYXRlciB0aGUgcmVzaXN0YW5jZSByYXRlLCB0aGUgaGlnaGVyIHRoZSBjb3N0IHRvIHJlYWNoIHRoZSBuZXh0IGNlbGwsIHdoaWNoIGlzIGNvbXBvdW5kZWQgZm9yIGVhY2ggc3Vic2VxdWVudCBtb3ZlbWVudC4gU2luY2UgdGhlIHJlc2lzdGFuY2UgcmF0ZSBpcyBzaW1pbGFyIHRvIGEgY29tcG91bmQgcmF0ZSBhbmQgZ2VuZXJhbGx5IHRoZSBhY2N1bXVsYXRpdmUgY29zdCB2YWx1ZXMgYXJlIHZlcnkgbGFyZ2UsIHNtYWxsIHJlc2lzdGFuY2UgcmF0ZXMgYXJlIHN1Z2dlc3RlZCwgc3VjaCBhcyAwLjAwNSBvciBldmVuIHNtYWxsZXIsIGRlcGVuZGluZyBvbiB0aGUgYWNjdW11bGF0aXZlIGNvc3QgdmFsdWVzLlwiLFxuXHRcIkBAQ29zdC1CYWNrLUxpbmtfQWNjdW11bGF0aXZlLUNvc3QtUmVzaXN0YW5jZS1SYXRlX3RhZzJAQFwiOiBcIlRoZSB2YWx1ZSBtdXN0IGJlIGdyZWF0ZXIgdGhhbiB6ZXJvLiBUaGUgZGVmYXVsdCBjYXBhY2l0eSBpcyB0byB0aGUgZWRnZSBvZiB0aGUgb3V0cHV0IHJhc3Rlci5cIixcblx0XCJAQENvc3QtQmFjay1MaW5rX0FjY3VtdWxhdGl2ZS1Db3N0LVJlc2lzdGFuY2UtUmF0ZV90YWczQEBcIjogXCJBIG51bWVyaWMgKGRvdWJsZSkgdmFsdWUgb3IgYSBmaWVsZCBmcm9tIHRoZSA8c3Ryb25nPlNvdXJjZSBSYXN0ZXI8L3N0cm9uZz4gY2FuIGJlIHVzZWQgZm9yIHRoaXMgcGFyYW1ldGVyLlwiLFxuXHRcIkBAQ29zdC1CYWNrLUxpbmtfQ2FwYWNpdHlfdGFnMEBAXCI6IFwiRGVmaW5lcyB0aGUgY29zdCBjYXBhY2l0eSBmb3IgdGhlIHRyYXZlbGVyIGZvciBhIHNvdXJjZS4gVGhlIGNvc3QgY2FsY3VsYXRpb25zIGNvbnRpbnVlIGZvciBlYWNoIHNvdXJjZSB1bnRpbCB0aGUgc3BlY2lmaWVkIGNhcGFjaXR5IGlzIHJlYWNoZWQuXCIsXG5cdFwiQEBDb3N0LUJhY2stTGlua19DYXBhY2l0eV90YWcxQEBcIjogXCJUaGUgdmFsdWUgbXVzdCBiZSBncmVhdGVyIHRoYW4gemVyby4gVGhlIGRlZmF1bHQgY2FwYWNpdHkgaXMgdG8gdGhlIGVkZ2Ugb2YgdGhlIG91dHB1dCByYXN0ZXIuXCIsXG5cdFwiQEBDb3N0LUJhY2stTGlua19DYXBhY2l0eV90YWcyQEBcIjogXCJBIG51bWVyaWMgKGRvdWJsZSkgdmFsdWUgb3IgYSBmaWVsZCBmcm9tIHRoZSA8c3Ryb25nPlNvdXJjZSBSYXN0ZXI8L3N0cm9uZz4gY2FuIGJlIHVzZWQgZm9yIHRoaXMgcGFyYW1ldGVyLlwiLFxuXHRcIkBAQ29zdC1CYWNrLUxpbmtfQ29zdC1SYXN0ZXJfdGFnMEBAXCI6IFwiQSByZXF1aXJlZCBpbnB1dCByYXN0ZXIgZGVmaW5pbmcgdGhlIGNvc3Qgb3IgaW1wZWRhbmNlIHRvIG1vdmUgcGxhbmltZXRyaWNhbGx5IHRocm91Z2ggZWFjaCBjZWxsLiBUaGUgdmFsdWUgYXQgZWFjaCBjZWxsIGxvY2F0aW9uIHJlcHJlc2VudHMgdGhlIGNvc3QtcGVyLXVuaXQgZGlzdGFuY2UgZm9yIG1vdmluZyB0aHJvdWdoIGl0LiBFYWNoIGNlbGwgbG9jYXRpb24gdmFsdWUgaXMgbXVsdGlwbGllZCBieSB0aGUgY2VsbCByZXNvbHV0aW9uLCBhbmQgYWxzbyBjb21wZW5zYXRlcyBmb3IgZGlhZ29uYWwgbW92ZW1lbnQgdG8gb2J0YWluIHRoZSB0b3RhbCBjb3N0IG9mIHBhc3NpbmcgdGhyb3VnaCB0aGUgY2VsbC5cIixcblx0XCJAQENvc3QtQmFjay1MaW5rX0Nvc3QtUmFzdGVyX3RhZzFAQFwiOiBcIlRoZSB2YWx1ZXMgb2YgdGhlIDxzdHJvbmc+Q29zdCBSYXN0ZXI8L3N0cm9uZz4gY2FuIGJlIGludGVnZXIgb3IgZmxvYXRpbmcgcG9pbnQsIGJ1dCB0aGV5IGNhbm5vdCBiZSBuZWdhdGl2ZSBvciB6ZXJvLlwiLFxuXHRcIkBAQ29zdC1CYWNrLUxpbmtfTWF4aW11bS1EaXN0YW5jZV90YWcwQEBcIjogXCJUaGUgdGhyZXNob2xkIHRoYXQgdGhlIGFjY3VtdWxhdGl2ZSBjb3N0IHZhbHVlcyBjYW5ub3QgZXhjZWVkLiBJZiBhbiBhY2N1bXVsYXRpdmUgY29zdCBkaXN0YW5jZSBleGNlZWRzIHRoaXMgdmFsdWUsIHRoZSBvdXRwdXQgdmFsdWUgZm9yIHRoZSBjZWxsIGxvY2F0aW9uIHdpbGwgYmUgTm9EYXRhLiBUaGUgbWF4aW11bSBkaXN0YW5jZSBkZWZpbmVzIHRoZSBleHRlbnQgZm9yIHdoaWNoIHRoZSBhY2N1bXVsYXRpdmUgY29zdCBkaXN0YW5jZXMgYXJlIGNhbGN1bGF0ZWQuIFRoZSBkZWZhdWx0IGRpc3RhbmNlIGlzIHRvIHRoZSBleHRlbnQgb2YgdGhlIG91dHB1dCByYXN0ZXIuXCIsXG5cdFwiQEBDb3N0LUJhY2stTGlua19NdWx0aXBsaWVyLXRvLUFwcGx5LXRvLUNvc3RzX3RhZzBAQFwiOiBcIkEgbXVsdGlwbGllciB0byBhcHBseSB0byB0aGUgY29zdCB2YWx1ZXMuXCIsXG5cdFwiQEBDb3N0LUJhY2stTGlua19NdWx0aXBsaWVyLXRvLUFwcGx5LXRvLUNvc3RzX3RhZzFAQFwiOiBcIlRoaXMgcGFyYW1ldGVyIGFsbG93cyBmb3IgY29udHJvbCBvZiB0aGUgbW9kZSBvZiB0cmF2ZWwgb3IgdGhlIG1hZ25pdHVkZSBhdCBhIHNvdXJjZS4gVGhlIGdyZWF0ZXIgdGhlIG11bHRpcGxpZXIsIHRoZSBncmVhdGVyIHRoZSBjb3N0IHRvIG1vdmUgdGhyb3VnaCBlYWNoIGNlbGwuXCIsXG5cdFwiQEBDb3N0LUJhY2stTGlua19NdWx0aXBsaWVyLXRvLUFwcGx5LXRvLUNvc3RzX3RhZzJAQFwiOiBcIlRoZSB2YWx1ZXMgbXVzdCBiZSBncmVhdGVyIHRoYW4gemVyby4gVGhlIGRlZmF1bHQgaXMgMS5cIixcblx0XCJAQENvc3QtQmFjay1MaW5rX011bHRpcGxpZXItdG8tQXBwbHktdG8tQ29zdHNfdGFnM0BAXCI6IFwiQSBudW1lcmljIChkb3VibGUpIHZhbHVlIG9yIGEgZmllbGQgZnJvbSB0aGUgPHN0cm9uZz5Tb3VyY2UgUmFzdGVyPC9zdHJvbmc+IGNhbiBiZSB1c2VkIGZvciB0aGlzIHBhcmFtZXRlci5cIixcblx0XCJAQENvc3QtQmFjay1MaW5rX1NvdXJjZS1SYXN0ZXJfdGFnMEBAXCI6IFwiVGhlIHJlcXVpcmVkIGlucHV0IHJhc3RlciBvZiBzb3VyY2UgbG9jYXRpb25zLlwiLFxuXHRcIkBAQ29zdC1CYWNrLUxpbmtfU291cmNlLVJhc3Rlcl90YWcxQEBcIjogXCJUaGlzIGlzIGEgcmFzdGVyIHRoYXQgaWRlbnRpZmllcyB0aGUgY2VsbHMgb3IgbG9jYXRpb25zIGZyb20gd2hpY2ggdGhlIGxlYXN0IGFjY3VtdWxhdGVkIGNvc3QgZGlzdGFuY2UgZm9yIGV2ZXJ5IG91dHB1dCBjZWxsIGxvY2F0aW9uIGlzIGNhbGN1bGF0ZWQuXCIsXG5cdFwiQEBDb3N0LUJhY2stTGlua19TdGFydC1Db3N0X3RhZzBAQFwiOiBcIlRoZSBzdGFydGluZyBjb3N0IGZyb20gd2hpY2ggdG8gYmVnaW4gdGhlIGNvc3QgY2FsY3VsYXRpb25zLiBUaGlzIHBhcmFtZXRlciBhbGxvd3MgZm9yIHRoZSBzcGVjaWZpY2F0aW9uIG9mIHRoZSBmaXhlZCBjb3N0IGFzc29jaWF0ZWQgd2l0aCBhIHNvdXJjZS4gSW5zdGVhZCBvZiBzdGFydGluZyBhdCBhIGNvc3Qgb2YgMCwgdGhlIGNvc3QgYWxnb3JpdGhtIHdpbGwgYmVnaW4gd2l0aCB0aGUgdmFsdWUgc3BlY2lmaWVkLlwiLFxuXHRcIkBAQ29zdC1CYWNrLUxpbmtfU3RhcnQtQ29zdF90YWcxQEBcIjogXCJUaGUgdmFsdWUgbXVzdCBiZSB6ZXJvIG9yIGdyZWF0ZXIuIFRoZSBkZWZhdWx0IGlzIDAuXCIsXG5cdFwiQEBDb3N0LUJhY2stTGlua19UcmF2ZWwtRGlyZWN0aW9uX3RhZzBAQFwiOiBcIkRlZmluZXMgdGhlIGRpcmVjdGlvbiBvZiB0aGUgdHJhdmVsZXIgd2hlbiBhcHBseWluZyB0aGUgc291cmNlIHJlc2lzdGFuY2UgcmF0ZSBhbmQgdGhlIHNvdXJjZSBzdGFydGluZyBjb3N0LlwiLFxuXHRcIkBAQ29zdC1CYWNrLUxpbmtfVHJhdmVsLURpcmVjdGlvbl90YWcxQEBcIjogXCI8c3Ryb25nPkZyb20gU291cmNlPC9zdHJvbmc+LS1UaGUgc291cmNlIHJlc2lzdGFuY2UgcmF0ZSBhbmQgc291cmNlIHN0YXJ0aW5nIGNvc3Qgd2lsbCBiZSBhcHBsaWVkIGJlZ2lubmluZyBhdCB0aGUgaW5wdXQgc291cmNlIGFuZCBtb3Zpbmcgb3V0IHRvIHRoZSBub24tc291cmNlIGNlbGxzLiBUaGlzIGlzIHRoZSBkZWZhdWx0LlwiLFxuXHRcIkBAQ29zdC1CYWNrLUxpbmtfVHJhdmVsLURpcmVjdGlvbl90YWczQEBcIjogXCI8c3Ryb25nPlRvIFNvdXJjZTwvc3Ryb25nPi0tVGhlIHNvdXJjZSByZXNpc3RhbmNlIHJhdGUgYW5kIHNvdXJjZSBzdGFydGluZyBjb3N0IHdpbGwgYmUgYXBwbGllZCBiZWdpbm5pbmcgYXQgZWFjaCBub24tc291cmNlIGNlbGwgYW5kIG1vdmluZyBiYWNrIHRvIHRoZSBpbnB1dCBzb3VyY2UuXCIsXG5cdFwiQEBDb3N0LUJhY2stTGlua19UcmF2ZWwtRGlyZWN0aW9uX3RhZzVAQFwiOiBcIkVpdGhlciBzcGVjaWZ5IHRoZSA8c3Ryb25nPkZyb20gU291cmNlPC9zdHJvbmc+IG9yIDxzdHJvbmc+VG8gU291cmNlPC9zdHJvbmc+IGtleXdvcmQsIHdoaWNoIHdpbGwgYmUgYXBwbGllZCB0byBhbGwgc291cmNlcywgb3Igc3BlY2lmeSBhIGZpZWxkIGluIHRoZSA8c3Ryb25nPlNvdXJjZSBSYXN0ZXI8L3N0cm9uZz4gdGhhdCBjb250YWlucyB0aGUga2V5d29yZHMgdG8gaWRlbnRpZnkgdGhlIGRpcmVjdGlvbiBvZiB0cmF2ZWwgZm9yIGVhY2ggc291cmNlLiBUaGF0IGZpZWxkIG11c3QgY29udGFpbiB0aGUgc3RyaW5nICR7RlJPTV9TT1VSQ0V9IG9yICR7VE9fU09VUkNFfS5cIixcblx0XCJAQENvc3QtRGlzdGFuY2VfQWNjdW11bGF0aXZlLUNvc3QtUmVzaXN0YW5jZS1SYXRlX3RhZzBAQFwiOiBcIlRoaXMgcGFyYW1ldGVyIHNpbXVsYXRlcyB0aGUgaW5jcmVhc2UgaW4gdGhlIGVmZm9ydCB0byBvdmVyY29tZSBjb3N0cyBhcyB0aGUgYWNjdW11bGF0aXZlIGNvc3QgaW5jcmVhc2VzLiBJdCBpcyB1c2VkIHRvIG1vZGVsIGZhdGlndWUgb2YgdGhlIHRyYXZlbGVyLiBUaGUgZ3Jvd2luZyBhY2N1bXVsYXRpdmUgY29zdCB0byByZWFjaCBhIGNlbGwgaXMgbXVsdGlwbGllZCBieSB0aGUgcmVzaXN0YW5jZSByYXRlIGFuZCBhZGRlZCB0byB0aGUgY29zdCB0byBtb3ZlIGludG8gdGhlIHN1YnNlcXVlbnQgY2VsbC5cIixcblx0XCJAQENvc3QtRGlzdGFuY2VfQWNjdW11bGF0aXZlLUNvc3QtUmVzaXN0YW5jZS1SYXRlX3RhZzFAQFwiOiBcIkl0J3MgYSBtb2RpZmllZCB2ZXJzaW9uIG9mIGEgY29tcG91bmQgaW50ZXJlc3QgcmF0ZSBmb3JtdWxhIHRoYXQncyB1c2VkIHRvIGNhbGN1bGF0ZSB0aGUgYXBwYXJlbnQgY29zdCBvZiBtb3ZpbmcgdGhyb3VnaCBhIGNlbGwuIEFzIHRoZSB2YWx1ZSBvZiB0aGUgcmVzaXN0YW5jZSByYXRlIGluY3JlYXNlcywgaXQgaW5jcmVhc2VzIHRoZSBjb3N0IG9mIHRoZSBjZWxscyB0aGF0IGFyZSB2aXNpdGVkIGxhdGVyLiBUaGUgZ3JlYXRlciB0aGUgcmVzaXN0YW5jZSByYXRlLCB0aGUgaGlnaGVyIHRoZSBjb3N0IHRvIHJlYWNoIHRoZSBuZXh0IGNlbGwsIHdoaWNoIGlzIGNvbXBvdW5kZWQgZm9yIGVhY2ggc3Vic2VxdWVudCBtb3ZlbWVudC4gU2luY2UgdGhlIHJlc2lzdGFuY2UgcmF0ZSBpcyBzaW1pbGFyIHRvIGEgY29tcG91bmQgcmF0ZSBhbmQgZ2VuZXJhbGx5IHRoZSBhY2N1bXVsYXRpdmUgY29zdCB2YWx1ZXMgYXJlIHZlcnkgbGFyZ2UsIHNtYWxsIHJlc2lzdGFuY2UgcmF0ZXMgYXJlIHN1Z2dlc3RlZCwgc3VjaCBhcyAwLjAwNSBvciBldmVuIHNtYWxsZXIsIGRlcGVuZGluZyBvbiB0aGUgYWNjdW11bGF0aXZlIGNvc3QgdmFsdWVzLlwiLFxuXHRcIkBAQ29zdC1EaXN0YW5jZV9BY2N1bXVsYXRpdmUtQ29zdC1SZXNpc3RhbmNlLVJhdGVfdGFnMkBAXCI6IFwiVGhlIHZhbHVlIG11c3QgYmUgZ3JlYXRlciB0aGFuIHplcm8uIFRoZSBkZWZhdWx0IGNhcGFjaXR5IGlzIHRvIHRoZSBlZGdlIG9mIHRoZSBvdXRwdXQgcmFzdGVyLlwiLFxuXHRcIkBAQ29zdC1EaXN0YW5jZV9BY2N1bXVsYXRpdmUtQ29zdC1SZXNpc3RhbmNlLVJhdGVfdGFnM0BAXCI6IFwiQSBudW1lcmljIChkb3VibGUpIHZhbHVlIG9yIGEgZmllbGQgZnJvbSB0aGUgPHN0cm9uZz5Tb3VyY2UgUmFzdGVyPC9zdHJvbmc+IGNhbiBiZSB1c2VkIGZvciB0aGlzIHBhcmFtZXRlci5cIixcblx0XCJAQENvc3QtRGlzdGFuY2VfQ2FwYWNpdHlfdGFnMEBAXCI6IFwiRGVmaW5lcyB0aGUgY29zdCBjYXBhY2l0eSBmb3IgdGhlIHRyYXZlbGVyIGZvciBhIHNvdXJjZS4gVGhlIGNvc3QgY2FsY3VsYXRpb25zIGNvbnRpbnVlIGZvciBlYWNoIHNvdXJjZSB1bnRpbCB0aGUgc3BlY2lmaWVkIGNhcGFjaXR5IGlzIHJlYWNoZWQuXCIsXG5cdFwiQEBDb3N0LURpc3RhbmNlX0NhcGFjaXR5X3RhZzFAQFwiOiBcIlRoZSB2YWx1ZSBtdXN0IGJlIGdyZWF0ZXIgdGhhbiB6ZXJvLiBUaGUgZGVmYXVsdCBjYXBhY2l0eSBpcyB0byB0aGUgZWRnZSBvZiB0aGUgb3V0cHV0IHJhc3Rlci5cIixcblx0XCJAQENvc3QtRGlzdGFuY2VfQ2FwYWNpdHlfdGFnMkBAXCI6IFwiQSBudW1lcmljIChkb3VibGUpIHZhbHVlIG9yIGEgZmllbGQgZnJvbSB0aGUgPHN0cm9uZz5Tb3VyY2UgUmFzdGVyPC9zdHJvbmc+IGNhbiBiZSB1c2VkIGZvciB0aGlzIHBhcmFtZXRlci5cIixcblx0XCJAQENvc3QtRGlzdGFuY2VfQ29zdC1SYXN0ZXJfdGFnMEBAXCI6IFwiQSByZXF1aXJlZCBpbnB1dCByYXN0ZXIgZGVmaW5pbmcgdGhlIGNvc3Qgb3IgaW1wZWRhbmNlIHRvIG1vdmUgcGxhbmltZXRyaWNhbGx5IHRocm91Z2ggZWFjaCBjZWxsLiBUaGUgdmFsdWUgYXQgZWFjaCBjZWxsIGxvY2F0aW9uIHJlcHJlc2VudHMgdGhlIGNvc3QtcGVyLXVuaXQgZGlzdGFuY2UgZm9yIG1vdmluZyB0aHJvdWdoIGl0LiBFYWNoIGNlbGwgbG9jYXRpb24gdmFsdWUgaXMgbXVsdGlwbGllZCBieSB0aGUgY2VsbCByZXNvbHV0aW9uLCBhbmQgYWxzbyBjb21wZW5zYXRlcyBmb3IgZGlhZ29uYWwgbW92ZW1lbnQgdG8gb2J0YWluIHRoZSB0b3RhbCBjb3N0IG9mIHBhc3NpbmcgdGhyb3VnaCB0aGUgY2VsbC5cIixcblx0XCJAQENvc3QtRGlzdGFuY2VfQ29zdC1SYXN0ZXJfdGFnMUBAXCI6IFwiVGhlIHZhbHVlcyBvZiB0aGUgPHN0cm9uZz5Db3N0IFJhc3Rlcjwvc3Ryb25nPiBjYW4gYmUgaW50ZWdlciBvciBmbG9hdGluZyBwb2ludCwgYnV0IHRoZXkgY2Fubm90IGJlIG5lZ2F0aXZlIG9yIHplcm8uXCIsXG5cdFwiQEBDb3N0LURpc3RhbmNlX01heGltdW0tRGlzdGFuY2VfdGFnMEBAXCI6IFwiVGhlIHRocmVzaG9sZCB0aGF0IHRoZSBhY2N1bXVsYXRpdmUgY29zdCB2YWx1ZXMgY2Fubm90IGV4Y2VlZC4gSWYgYW4gYWNjdW11bGF0aXZlIGNvc3QgZGlzdGFuY2UgZXhjZWVkcyB0aGlzIHZhbHVlLCB0aGUgb3V0cHV0IHZhbHVlIGZvciB0aGUgY2VsbCBsb2NhdGlvbiB3aWxsIGJlIE5vRGF0YS4gVGhlIG1heGltdW0gZGlzdGFuY2UgZGVmaW5lcyB0aGUgZXh0ZW50IGZvciB3aGljaCB0aGUgYWNjdW11bGF0aXZlIGNvc3QgZGlzdGFuY2VzIGFyZSBjYWxjdWxhdGVkLiBUaGUgZGVmYXVsdCBkaXN0YW5jZSBpcyB0byB0aGUgZXh0ZW50IG9mIHRoZSBvdXRwdXQgcmFzdGVyLlwiLFxuXHRcIkBAQ29zdC1EaXN0YW5jZV9NdWx0aXBsaWVyLXRvLUFwcGx5LXRvLUNvc3RzX3RhZzBAQFwiOiBcIkEgbXVsdGlwbGllciB0byBhcHBseSB0byB0aGUgY29zdCB2YWx1ZXMuXCIsXG5cdFwiQEBDb3N0LURpc3RhbmNlX011bHRpcGxpZXItdG8tQXBwbHktdG8tQ29zdHNfdGFnMUBAXCI6IFwiVGhpcyBwYXJhbWV0ZXIgYWxsb3dzIGZvciBjb250cm9sIG9mIHRoZSBtb2RlIG9mIHRyYXZlbCBvciB0aGUgbWFnbml0dWRlIGF0IGEgc291cmNlLiBUaGUgZ3JlYXRlciB0aGUgbXVsdGlwbGllciwgdGhlIGdyZWF0ZXIgdGhlIGNvc3QgdG8gbW92ZSB0aHJvdWdoIGVhY2ggY2VsbC5cIixcblx0XCJAQENvc3QtRGlzdGFuY2VfTXVsdGlwbGllci10by1BcHBseS10by1Db3N0c190YWcyQEBcIjogXCJUaGUgdmFsdWVzIG11c3QgYmUgZ3JlYXRlciB0aGFuIHplcm8uIFRoZSBkZWZhdWx0IGlzIDEuXCIsXG5cdFwiQEBDb3N0LURpc3RhbmNlX011bHRpcGxpZXItdG8tQXBwbHktdG8tQ29zdHNfdGFnM0BAXCI6IFwiQSBudW1lcmljIChkb3VibGUpIHZhbHVlIG9yIGEgZmllbGQgZnJvbSB0aGUgPHN0cm9uZz5Tb3VyY2UgUmFzdGVyPC9zdHJvbmc+IGNhbiBiZSB1c2VkIGZvciB0aGlzIHBhcmFtZXRlci5cIixcblx0XCJAQENvc3QtRGlzdGFuY2VfU291cmNlLVJhc3Rlcl90YWcwQEBcIjogXCJUaGUgcmVxdWlyZWQgaW5wdXQgcmFzdGVyIG9mIHNvdXJjZSBsb2NhdGlvbnMuXCIsXG5cdFwiQEBDb3N0LURpc3RhbmNlX1NvdXJjZS1SYXN0ZXJfdGFnMUBAXCI6IFwiVGhpcyBpcyBhIHJhc3RlciB0aGF0IGlkZW50aWZpZXMgdGhlIGNlbGxzIG9yIGxvY2F0aW9ucyBmcm9tIHdoaWNoIHRoZSBsZWFzdCBhY2N1bXVsYXRlZCBjb3N0IGRpc3RhbmNlIGZvciBldmVyeSBvdXRwdXQgY2VsbCBsb2NhdGlvbiBpcyBjYWxjdWxhdGVkLlwiLFxuXHRcIkBAQ29zdC1EaXN0YW5jZV9TdGFydC1Db3N0X3RhZzBAQFwiOiBcIlRoZSBzdGFydGluZyBjb3N0IGZyb20gd2hpY2ggdG8gYmVnaW4gdGhlIGNvc3QgY2FsY3VsYXRpb25zLiBUaGlzIHBhcmFtZXRlciBhbGxvd3MgZm9yIHRoZSBzcGVjaWZpY2F0aW9uIG9mIHRoZSBmaXhlZCBjb3N0IGFzc29jaWF0ZWQgd2l0aCBhIHNvdXJjZS4gSW5zdGVhZCBvZiBzdGFydGluZyBhdCBhIGNvc3Qgb2YgMCwgdGhlIGNvc3QgYWxnb3JpdGhtIHdpbGwgYmVnaW4gd2l0aCB0aGUgdmFsdWUgc3BlY2lmaWVkLlwiLFxuXHRcIkBAQ29zdC1EaXN0YW5jZV9TdGFydC1Db3N0X3RhZzFAQFwiOiBcIlRoZSB2YWx1ZSBtdXN0IGJlIHplcm8gb3IgZ3JlYXRlci4gVGhlIGRlZmF1bHQgaXMgMC5cIixcblx0XCJAQENvc3QtRGlzdGFuY2VfVHJhdmVsLURpcmVjdGlvbl90YWcwQEBcIjogXCJEZWZpbmVzIHRoZSBkaXJlY3Rpb24gb2YgdGhlIHRyYXZlbGVyIHdoZW4gYXBwbHlpbmcgdGhlIHNvdXJjZSByZXNpc3RhbmNlIHJhdGUgYW5kIHRoZSBzb3VyY2Ugc3RhcnRpbmcgY29zdC5cIixcblx0XCJAQENvc3QtRGlzdGFuY2VfVHJhdmVsLURpcmVjdGlvbl90YWcxQEBcIjogXCI8c3Ryb25nPkZyb20gU291cmNlPC9zdHJvbmc+LS1UaGUgc291cmNlIHJlc2lzdGFuY2UgcmF0ZSBhbmQgc291cmNlIHN0YXJ0aW5nIGNvc3Qgd2lsbCBiZSBhcHBsaWVkIGJlZ2lubmluZyBhdCB0aGUgaW5wdXQgc291cmNlIGFuZCBtb3Zpbmcgb3V0IHRvIHRoZSBub24tc291cmNlIGNlbGxzLiBUaGlzIGlzIHRoZSBkZWZhdWx0LlwiLFxuXHRcIkBAQ29zdC1EaXN0YW5jZV9UcmF2ZWwtRGlyZWN0aW9uX3RhZzNAQFwiOiBcIjxzdHJvbmc+VG8gU291cmNlPC9zdHJvbmc+LS1UaGUgc291cmNlIHJlc2lzdGFuY2UgcmF0ZSBhbmQgc291cmNlIHN0YXJ0aW5nIGNvc3Qgd2lsbCBiZSBhcHBsaWVkIGJlZ2lubmluZyBhdCBlYWNoIG5vbi1zb3VyY2UgY2VsbCBhbmQgbW92aW5nIGJhY2sgdG8gdGhlIGlucHV0IHNvdXJjZS5cIixcblx0XCJAQENvc3QtRGlzdGFuY2VfVHJhdmVsLURpcmVjdGlvbl90YWc1QEBcIjogXCJFaXRoZXIgc3BlY2lmeSB0aGUgPHN0cm9uZz5Gcm9tIFNvdXJjZTwvc3Ryb25nPiBvciA8c3Ryb25nPlRvIFNvdXJjZTwvc3Ryb25nPiBrZXl3b3JkLCB3aGljaCB3aWxsIGJlIGFwcGxpZWQgdG8gYWxsIHNvdXJjZXMsIG9yIHNwZWNpZnkgYSBmaWVsZCBpbiB0aGUgPHN0cm9uZz5Tb3VyY2UgUmFzdGVyPC9zdHJvbmc+IHRoYXQgY29udGFpbnMgdGhlIGtleXdvcmRzIHRvIGlkZW50aWZ5IHRoZSBkaXJlY3Rpb24gb2YgdHJhdmVsIGZvciBlYWNoIHNvdXJjZS4gVGhhdCBmaWVsZCBtdXN0IGNvbnRhaW4gdGhlIHN0cmluZyAke0ZST01fU09VUkNFfSBvciAke1RPX1NPVVJDRX0uXCIsXG5cdFwiQEBDdXJ2YXR1cmVfQ3VydmF0dXJlLVR5cGVfdGFnMEBAXCI6IFwiVGhlIGN1cnZhdHVyZSB0eXBlIGFjY2VudHVhdGVzIGRpZmZlcmVudCBhc3BlY3RzIG9mIHRoZSBzbG9wZS4gVGhlcmUgYXJlIHRocmVlIGN1cnZhdHVyZSBvcHRpb25zOlwiLFxuXHRcIkBAQ3VydmF0dXJlX0N1cnZhdHVyZS1UeXBlX3RhZzFAQFwiOiBcIlBsYW5mb3JtLS1JcyBwZXJwZW5kaWN1bGFyIHRvIHRoZSBkaXJlY3Rpb24gb2YgdGhlIG1heGltdW0gc2xvcGUuIEl0IGFmZmVjdHMgdGhlIGNvbnZlcmdlbmNlIGFuZCBkaXZlcmdlbmNlIG9mIGZsb3cgYWNyb3NzIGEgc3VyZmFjZS5cIixcblx0XCJAQEN1cnZhdHVyZV9DdXJ2YXR1cmUtVHlwZV90YWcyQEBcIjogXCJQcm9maWxlLS1JcyBwYXJhbGxlbCB0byB0aGUgc2xvcGUgYW5kIGluZGljYXRlcyB0aGUgZGlyZWN0aW9uIG9mIG1heGltdW0gc2xvcGUuIEl0IGFmZmVjdHMgdGhlIGFjY2VsZXJhdGlvbiBhbmQgZGVjZWxlcmF0aW9uIG9mIGZsb3cgYWNyb3NzIHRoZSBzdXJmYWNlLlwiLFxuXHRcIkBAQ3VydmF0dXJlX0N1cnZhdHVyZS1UeXBlX3RhZzNAQFwiOiBcIlN0YW5kYXJkLS1Db21iaW5lcyBib3RoIHRoZSA8c3Ryb25nPlByb2ZpbGU8L3N0cm9uZz4gYW5kIDxzdHJvbmc+UGxhbmZvcm08L3N0cm9uZz4gY3VydmF0dXJlcy5cIixcblx0XCJAQEN1cnZhdHVyZV9ERU1fdGFnMEBAXCI6IFwiQSBkaWdpdGFsIGVsZXZhdGlvbiBtb2RlbCAoREVNKSByYXN0ZXIuXCIsXG5cdFwiQEBDdXJ2YXR1cmVfWi1GYWN0b3JfdGFnMEBAXCI6IFwiVGhlIHotZmFjdG9yIGFkanVzdHMgdGhlIHVuaXRzIG9mIG1lYXN1cmUgZm9yIHRoZSB6IHVuaXRzIHdoZW4gdGhleSBhcmUgZGlmZmVyZW50IGZyb20gdGhlIHgseSB1bml0cyBvZiB0aGUgaW5wdXQgc3VyZmFjZS4gSWYgdGhlIHgseSB1bml0cyBhbmQgeiB1bml0cyBhcmUgaW4gdGhlIHNhbWUgdW5pdHMgb2YgbWVhc3VyZSwgdGhlIHotZmFjdG9yIHNob3VsZCBiZSBzZXQgdG8gMS4gVGhlIHotdmFsdWVzIG9mIHRoZSBpbnB1dCBzdXJmYWNlIGFyZSBtdWx0aXBsaWVkIGJ5IHRoZSB6LWZhY3RvciB3aGVuIGNhbGN1bGF0aW5nIHRoZSBmaW5hbCBvdXRwdXQgc3VyZmFjZS4gRm9yIGV4YW1wbGUsIGlmIHlvdXIgeiB1bml0cyBhcmUgZmVldCBhbmQgeW91ciB4LHkgdW5pdHMgYXJlIG1ldGVycywgeW91IHdvdWxkIHVzZSBhIHotZmFjdG9yIG9mIDAuMzA0OCB0byBjb252ZXJ0IHlvdXIgeiB1bml0cyBmcm9tIGZlZXQgdG8gbWV0ZXJzLCBzaW5jZSAxIGZvb3QgPSAwLjMwNDggbWV0ZXJzLlwiLFxuXHRcIkBARGl2aWRlX0NlbGxzaXplLVR5cGVfdGFnMEBAXCI6IFwiQ2hvb3NlIHdoaWNoIGNlbGwgc2l6ZSB0byB1c2UgaW4gdGhlIG91dHB1dCByYXN0ZXIuIElmIGFsbCB0aGUgaW5wdXQgY2VsbCBzaXplcyBhcmUgdGhlIHNhbWUsIGFsbCB0aGUgb3B0aW9ucyB3aWxsIHlpZWxkIHRoZSBzYW1lIHJlc3VsdHMuXCIsXG5cdFwiQEBEaXZpZGVfQ2VsbHNpemUtVHlwZV90YWcxQEBcIjogXCJGaXJzdCBPZi0tVXNlIHRoZSBmaXJzdCBjZWxsIHNpemUgb2YgdGhlIGlucHV0IHJhc3RlcnMuXCIsXG5cdFwiQEBEaXZpZGVfQ2VsbHNpemUtVHlwZV90YWcyQEBcIjogXCJMYXN0IE9mLS1Vc2UgdGhlIGxhc3QgY2VsbCBzaXplIG9mIHRoZSBpbnB1dCByYXN0ZXJzLlwiLFxuXHRcIkBARGl2aWRlX0NlbGxzaXplLVR5cGVfdGFnM0BAXCI6IFwiTWF4IE9mLS1Vc2UgdGhlIGxhcmdlc3QgY2VsbCBzaXplIG9mIGFsbCB0aGUgaW5wdXQgcmFzdGVycy4gVGhpcyBpcyB0aGUgZGVmYXVsdC5cIixcblx0XCJAQERpdmlkZV9DZWxsc2l6ZS1UeXBlX3RhZzRAQFwiOiBcIk1lYW4gT2YtLVVzZSB0aGUgbWVhbiBjZWxsIHNpemUgb2YgYWxsIHRoZSBpbnB1dCByYXN0ZXJzLlwiLFxuXHRcIkBARGl2aWRlX0NlbGxzaXplLVR5cGVfdGFnNUBAXCI6IFwiTWluIE9mLS1Vc2UgdGhlIHNtYWxsZXN0IGNlbGwgc2l6ZSBvZiBhbGwgdGhlIGlucHV0IHJhc3RlcnMuXCIsXG5cdFwiQEBEaXZpZGVfRXh0ZW50LVR5cGVfdGFnMEBAXCI6IFwiQ2hvb3NlIHdoaWNoIGV4dGVudCBzaG91bGQgYmUgdXNlZCBpbiB0aGUgb3V0cHV0IHJhc3RlcjpcIixcblx0XCJAQERpdmlkZV9FeHRlbnQtVHlwZV90YWcxQEBcIjogXCJGaXJzdCBPZi0tVXNlIHRoZSBleHRlbnQgb2YgdGhlIGZpcnN0IGlucHV0IHJhc3RlciB0byBkZXRlcm1pbmUgdGhlIHByb2Nlc3NpbmcgZXh0ZW50LlwiLFxuXHRcIkBARGl2aWRlX0V4dGVudC1UeXBlX3RhZzJAQFwiOiBcIkludGVyc2VjdGlvbiBPZi0tVXNlIHRoZSBleHRlbnQgb2YgdGhlIG92ZXJsYXBwaW5nIHBpeGVscyB0byBkZXRlcm1pbmUgdGhlIHByb2Nlc3NpbmcgZXh0ZW50LiBUaGlzIGlzIHRoZSBkZWZhdWx0LlwiLFxuXHRcIkBARGl2aWRlX0V4dGVudC1UeXBlX3RhZzNAQFwiOiBcIkxhc3QgT2YtLVVzZSB0aGUgZXh0ZW50IG9mIHRoZSBsYXN0IGlucHV0IHJhc3RlciB0byBkZXRlcm1pbmUgdGhlIHByb2Nlc3NpbmcgZXh0ZW50LlwiLFxuXHRcIkBARGl2aWRlX0V4dGVudC1UeXBlX3RhZzRAQFwiOiBcIlVuaW9uIE9mLS1Vc2UgdGhlIGV4dGVudCBvZiBhbGwgdGhlIHJhc3RlcnMgdG8gZGV0ZXJtaW5lIHRoZSBwcm9jZXNzaW5nIGV4dGVudC5cIixcblx0XCJAQERpdmlkZV9SYXN0ZXJfdGFnMEBAXCI6IFwiVGhlIGlucHV0IHdob3NlIHZhbHVlIHdpbGwgYmUgZGl2aWRlZCBieSB0aGUgc2Vjb25kIGlucHV0LlwiLFxuXHRcIkBARGl2aWRlX1Jhc3Rlcl90YWcxQEBcIjogXCJBIG51bWJlciBjYW4gYmUgdXNlZCBhcyBhbiBpbnB1dCBmb3IgdGhpcyBwYXJhbWV0ZXIsIHByb3ZpZGVkIGEgcmFzdGVyIGlzIHNwZWNpZmllZCBmb3IgJHtSYXN0ZXIyfS5cIixcblx0XCJAQERpdmlkZV9SYXN0ZXIyX3RhZzBAQFwiOiBcIlRoZSBpbnB1dCB3aG9zZSB2YWx1ZSB0aGUgZmlyc3QgaW5wdXQgd2lsbCBiZSBkaXZpZGVkIGJ5LlwiLFxuXHRcIkBARGl2aWRlX1Jhc3RlcjJfdGFnMUBAXCI6IFwiQSBudW1iZXIgY2FuIGJlIHVzZWQgYXMgYW4gaW5wdXQgZm9yIHRoaXMgcGFyYW1ldGVyLCBwcm92aWRlZCBhIHJhc3RlciBpcyBzcGVjaWZpZWQgZm9yICR7UmFzdGVyfS5cIixcblx0XCJAQEVsZXZhdGlvbi1Wb2lkLUZpbGxfREVNX3RhZzBAQFwiOiBcIlRoZSBpbnB1dCBERU0uXCIsXG5cdFwiQEBFbGV2YXRpb24tVm9pZC1GaWxsX01heC1Wb2lkLVdpZHRoX3RhZzBAQFwiOiBcIlRoZSBtYXhpbXVtIHZvaWQgd2lkdGggdmFsdWUgaXMgdXNlZCB0byBzcGVjaWZ5IHRoZSBsYXJnZXN0IHNpemUgb2YgYSB2b2lkIHRoYXQgeW91IHdhbnQgdG8gZmlsbC4gSWYgdGhlIHdpZHRoIG9yIGhlaWdodCBvZiB0aGUgYm91bmRpbmcgYm94IGFyb3VuZCB0aGUgdm9pZCBpcyBsYXJnZXIgdGhhbiB0aGUgbWF4aW11bSB2b2lkIHdpZHRoIHZhbHVlLCB0aGUgdm9pZCBpcyBub3QgZmlsbGVkLiBUaGUgdW5pdHMgb2YgdGhpcyBwYXJhbWV0ZXIgYXJlIHRoZSBzYW1lIGFzIHRoZSB1bml0cyB1c2VkIGluIHlvdXIgZGF0YSdzIHNwYXRpYWwgcmVmZXJlbmNlIHN5c3RlbS5cIixcblx0XCJAQEVsZXZhdGlvbi1Wb2lkLUZpbGxfTWF4LVZvaWQtV2lkdGhfdGFnMUBAXCI6IFwiSWYgdGhpcyBwYXJhbWV0ZXIgaXMgYmxhbmsgb3IgaGFzIGEgdmFsdWUgb2YgJHswfSwgbm8gbWF4aW11bSB3aWR0aCB3aWxsIGJlIHVzZWQsIGFuZCBhbGwgdm9pZHMgd2lsbCBiZSBmaWxsZWQuIEEgdmFsdWUgb2YgJHstMX0gbWVhbnMgdGhhdCBubyB2b2lkIGZpbGxpbmcgd2lsbCBvY2N1ci5cIixcblx0XCJAQEVsZXZhdGlvbi1Wb2lkLUZpbGxfU2hvcnQtUmFuZ2UtSURXLVJhZGl1c190YWcwQEBcIjogXCJUaGUgbWF4aW11bSBzZWFyY2ggcmFkaXVzIHRoYXQgd2lsbCBiZSB1c2VkIGZvciB2b2lkIGZpbGxpbmcuIEEgdm9pZCB0aGF0IGlzIGZ1cnRoZXIgYXdheSwgZnJvbSBhbnkgdmFsaWQgcGl4ZWwsIHRoYW4gdGhpcyB0aHJlc2hvbGQgdmFsdWUgd2lsbCByZW1haW4gYXMgYSB2b2lkLiBUaGUgdW5pdHMgb2YgdGhpcyBwYXJhbWV0ZXIgYXJlIHRoZSBzYW1lIGFzIHRoZSB1bml0cyB1c2VkIGluIHlvdXIgZGF0YSdzIHNwYXRpYWwgcmVmZXJlbmNlIHN5c3RlbS5cIixcblx0XCJAQEVsZXZhdGlvbi1Wb2lkLUZpbGxfU2hvcnQtUmFuZ2UtSURXLVJhZGl1c190YWcxQEBcIjogXCJJZiB0aGUgdmFsdWUgb2YgdGhpcyBwYXJhbWV0ZXIgaXMgYmxhbmssICR7MH0sIG9yICR7LTF9IHRoaXMgcGFyYW1ldGVyIHdpbGwgbm90IGJlIHVzZWQuXCIsXG5cdFwiQEBFcXVhbC10b19DZWxsc2l6ZS1UeXBlX3RhZzBAQFwiOiBcIkNob29zZSB3aGljaCBjZWxsIHNpemUgdG8gdXNlIGluIHRoZSBvdXRwdXQgcmFzdGVyLiBJZiBhbGwgdGhlIGlucHV0IGNlbGwgc2l6ZXMgYXJlIHRoZSBzYW1lLCBhbGwgdGhlIG9wdGlvbnMgd2lsbCB5aWVsZCB0aGUgc2FtZSByZXN1bHRzLlwiLFxuXHRcIkBARXF1YWwtdG9fQ2VsbHNpemUtVHlwZV90YWcxQEBcIjogXCJGaXJzdCBPZi0tVXNlIHRoZSBmaXJzdCBjZWxsIHNpemUgb2YgdGhlIGlucHV0IHJhc3RlcnMuXCIsXG5cdFwiQEBFcXVhbC10b19DZWxsc2l6ZS1UeXBlX3RhZzJAQFwiOiBcIkxhc3QgT2YtLVVzZSB0aGUgbGFzdCBjZWxsIHNpemUgb2YgdGhlIGlucHV0IHJhc3RlcnMuXCIsXG5cdFwiQEBFcXVhbC10b19DZWxsc2l6ZS1UeXBlX3RhZzNAQFwiOiBcIk1heCBPZi0tVXNlIHRoZSBsYXJnZXN0IGNlbGwgc2l6ZSBvZiBhbGwgdGhlIGlucHV0IHJhc3RlcnMuIFRoaXMgaXMgdGhlIGRlZmF1bHQuXCIsXG5cdFwiQEBFcXVhbC10b19DZWxsc2l6ZS1UeXBlX3RhZzRAQFwiOiBcIk1lYW4gT2YtLVVzZSB0aGUgbWVhbiBjZWxsIHNpemUgb2YgYWxsIHRoZSBpbnB1dCByYXN0ZXJzLlwiLFxuXHRcIkBARXF1YWwtdG9fQ2VsbHNpemUtVHlwZV90YWc1QEBcIjogXCJNaW4gT2YtLVVzZSB0aGUgc21hbGxlc3QgY2VsbCBzaXplIG9mIGFsbCB0aGUgaW5wdXQgcmFzdGVycy5cIixcblx0XCJAQEVxdWFsLXRvX0V4dGVudC1UeXBlX3RhZzBAQFwiOiBcIkNob29zZSB3aGljaCBleHRlbnQgc2hvdWxkIGJlIHVzZWQgaW4gdGhlIG91dHB1dCByYXN0ZXI6XCIsXG5cdFwiQEBFcXVhbC10b19FeHRlbnQtVHlwZV90YWcxQEBcIjogXCJGaXJzdCBPZi0tVXNlIHRoZSBleHRlbnQgb2YgdGhlIGZpcnN0IGlucHV0IHJhc3RlciB0byBkZXRlcm1pbmUgdGhlIHByb2Nlc3NpbmcgZXh0ZW50LlwiLFxuXHRcIkBARXF1YWwtdG9fRXh0ZW50LVR5cGVfdGFnMkBAXCI6IFwiSW50ZXJzZWN0aW9uIE9mLS1Vc2UgdGhlIGV4dGVudCBvZiB0aGUgb3ZlcmxhcHBpbmcgcGl4ZWxzIHRvIGRldGVybWluZSB0aGUgcHJvY2Vzc2luZyBleHRlbnQuIFRoaXMgaXMgdGhlIGRlZmF1bHQuXCIsXG5cdFwiQEBFcXVhbC10b19FeHRlbnQtVHlwZV90YWczQEBcIjogXCJMYXN0IE9mLS1Vc2UgdGhlIGV4dGVudCBvZiB0aGUgbGFzdCBpbnB1dCByYXN0ZXIgdG8gZGV0ZXJtaW5lIHRoZSBwcm9jZXNzaW5nIGV4dGVudC5cIixcblx0XCJAQEVxdWFsLXRvX0V4dGVudC1UeXBlX3RhZzRAQFwiOiBcIlVuaW9uIE9mLS1Vc2UgdGhlIGV4dGVudCBvZiBhbGwgdGhlIHJhc3RlcnMgdG8gZGV0ZXJtaW5lIHRoZSBwcm9jZXNzaW5nIGV4dGVudC5cIixcblx0XCJAQEVxdWFsLXRvX1Jhc3Rlcl90YWcwQEBcIjogXCJUaGUgaW5wdXQgdGhhdCB3aWxsIGJlIHVzZWQgZm9yIGNvbXBhcmlzb24gZm9yIGVxdWFsaXR5IGJ5IHRoZSBzZWNvbmQgaW5wdXQuXCIsXG5cdFwiQEBFcXVhbC10b19SYXN0ZXJfdGFnMUBAXCI6IFwiQSBjb25zdGFudCB2YWx1ZSBjYW4gYmUgdXNlZCBhcyBhbiBpbnB1dCBmb3IgdGhpcyBwYXJhbWV0ZXIsIHByb3ZpZGVkIGEgcmFzdGVyIGlzIHNwZWNpZmllZCBmb3IgdGhlIG90aGVyIHBhcmFtZXRlci5cIixcblx0XCJAQEVxdWFsLXRvX1Jhc3RlcjJfdGFnMEBAXCI6IFwiVGhlIGlucHV0IHRoYXQgd2lsbCBiZSB1c2VkIGZvciBjb21wYXJpc29uIGZvciBlcXVhbGl0eSBieSB0aGUgZmlyc3QgaW5wdXQuXCIsXG5cdFwiQEBFcXVhbC10b19SYXN0ZXIyX3RhZzFAQFwiOiBcIkEgY29uc3RhbnQgdmFsdWUgY2FuIGJlIHVzZWQgYXMgYW4gaW5wdXQgZm9yIHRoaXMgcGFyYW1ldGVyLCBwcm92aWRlZCBhIHJhc3RlciBpcyBzcGVjaWZpZWQgZm9yIHRoZSBvdGhlciBwYXJhbWV0ZXIuXCIsXG5cdFwiQEBFdWNsaWRlYW4tQWxsb2NhdGlvbl9DZWxsc2l6ZV90YWcwQEBcIjogXCJUaGUgY2VsbCBzaXplIGF0IHdoaWNoIHRoZSBvdXRwdXQgcmFzdGVyIHdpbGwgYmUgY3JlYXRlZC5cIixcblx0XCJAQEV1Y2xpZGVhbi1BbGxvY2F0aW9uX0NlbGxzaXplX3RhZzFAQFwiOiBcIklmIHRoZSBjZWxsIHNpemUgd2FzIGV4cGxpY2l0bHkgc2V0IGluIDxzdHJvbmc+QW5hbHlzaXMgRW52aXJvbm1lbnRzPC9zdHJvbmc+ICwgdGhhdCB3aWxsIGJlIHRoZSBkZWZhdWx0IGNlbGwgc2l6ZS4gSWYgaXQgd2FzIG5vdCBzZXQsIHRoZSBvdXRwdXQgY2VsbCBzaXplIHdpbGwgYmUgdGhlIHNhbWUgYXMgdGhlIDxzdHJvbmc+U291cmNlIFJhc3Rlcjwvc3Ryb25nPi5cIixcblx0XCJAQEV1Y2xpZGVhbi1BbGxvY2F0aW9uX0Rpc3RhbmNlLU1ldGhvZF90YWcwQEBcIjogXCJEZXRlcm1pbmVzIHdoZXRoZXIgdG8gY2FsY3VsYXRlIHRoZSBkaXN0YW5jZSB1c2luZyBhIHBsYW5hciAoZmxhdCBlYXJ0aCkgb3IgYSBnZW9kZXNpYyAoZWxsaXBzb2lkKSBtZXRob2QuXCIsXG5cdFwiQEBFdWNsaWRlYW4tQWxsb2NhdGlvbl9EaXN0YW5jZS1NZXRob2RfdGFnMUBAXCI6IFwiR2VvZGVzaWMtLVRoZSBzaG9ydGVzdCBsaW5lIGJldHdlZW4gdHdvIHBvaW50cyBvbiB0aGUgZWFydGgncyBzdXJmYWNlIG9uIGEgc3BoZXJvaWQgKGVsbGlwc29pZCkuIFRoZXJlZm9yZSwgcmVnYXJkbGVzcyBvZiBpbnB1dCBvciBvdXRwdXQgcHJvamVjdGlvbiwgdGhlIHJlc3VsdHMgZG8gbm90IGNoYW5nZS4gT25lIHVzZSBmb3IgYSBnZW9kZXNpYyBsaW5lIGlzIHdoZW4geW91IHdhbnQgdG8gZGV0ZXJtaW5lIHRoZSBzaG9ydGVzdCBkaXN0YW5jZSBiZXR3ZWVuIHR3byBjaXRpZXMgZm9yIGFuIGFpcnBsYW5lJ3MgZmxpZ2h0IHBhdGguIFRoaXMgaXMgYWxzbyBrbm93biBhcyBhIGdyZWF0IGNpcmNsZSBsaW5lIGlmIGJhc2VkIG9uIGEgc3BoZXJlIHJhdGhlciB0aGFuIGFuIGVsbGlwc29pZC5cIixcblx0XCJAQEV1Y2xpZGVhbi1BbGxvY2F0aW9uX0Rpc3RhbmNlLU1ldGhvZF90YWcyQEBcIjogXCJQbGFuYXItLVBsYW5hciBtZWFzdXJlbWVudHMgdXNlIDJEIENhcnRlc2lhbiBtYXRoZW1hdGljcyB0byBjYWxjdWxhdGUgbGVuZ3RoIGFuZCBhcmVhLiBUaGUgb3B0aW9uIGlzIG9ubHkgYXZhaWxhYmxlIHdoZW4gbWVhc3VyaW5nIGluIGEgcHJvamVjdGVkIGNvb3JkaW5hdGUgc3lzdGVtIGFuZCB0aGUgMkQgcGxhbmUgb2YgdGhhdCBjb29yZGluYXRlIHN5c3RlbSB3aWxsIGJlIHVzZWQgYXMgdGhlIGJhc2lzIGZvciB0aGUgbWVhc3VyZW1lbnRzLlwiLFxuXHRcIkBARXVjbGlkZWFuLUFsbG9jYXRpb25fTWF4aW11bS1EaXN0YW5jZV90YWcwQEBcIjogXCJEZWZpbmVzIHRoZSB0aHJlc2hvbGQgZGlzdGFuY2Ugd2l0aGluIHdoaWNoIHRoZSBuZWFyZXN0IHNvdXJjZSB3aWxsIGJlIGRldGVybWluZWQuIElmIHRoZSBkaXN0YW5jZSB0byB0aGUgbmVhcmVzdCBzb3VyY2UgZXhjZWVkcyB0aGlzLCB0aGUgb3V0cHV0IGZvciB0aGF0IGNlbGwgd2lsbCBiZSAke05vRGF0YX0uXCIsXG5cdFwiQEBFdWNsaWRlYW4tQWxsb2NhdGlvbl9NYXhpbXVtLURpc3RhbmNlX3RhZzFAQFwiOiBcIlRoZSBkZWZhdWx0IGRpc3RhbmNlIGlzIHRvIHRoZSBleHRlbnQgb2YgdGhlIG91dHB1dCByYXN0ZXIuXCIsXG5cdFwiQEBFdWNsaWRlYW4tQWxsb2NhdGlvbl9SYXN0ZXItQmFycmllcnNfdGFnMEBAXCI6IFwiVGhlIHJhc3RlciB0aGF0IGRlZmluZXMgdGhlIGJhcnJpZXJzLlwiLFxuXHRcIkBARXVjbGlkZWFuLUFsbG9jYXRpb25fUmFzdGVyLUJhcnJpZXJzX3RhZzFAQFwiOiBcIlRoZSBkYXRhc2V0IG11c3QgY29udGFpbiAke05vRGF0YX0gd2hlcmUgdGhlcmUgYXJlIG5vIGJhcnJpZXJzLiBCYXJyaWVycyBhcmUgcmVwcmVzZW50ZWQgYnkgdmFsaWQgdmFsdWVzIGluY2x1ZGluZyB6ZXJvLlwiLFxuXHRcIkBARXVjbGlkZWFuLUFsbG9jYXRpb25fUmFzdGVyLUJhcnJpZXJzX3RhZzJAQFwiOiBcIlRoZSBiYXJyaWVycyBjYW4gYmUgZGVmaW5lZCBieSBhbiBpbnRlZ2VyIG9yIGEgZmxvYXRpbmctcG9pbnQgcmFzdGVyLlwiLFxuXHRcIkBARXVjbGlkZWFuLUFsbG9jYXRpb25fU291cmNlLUZpZWxkX3RhZzBAQFwiOiBcIlRoZSBmaWVsZCB1c2VkIHRvIGFzc2lnbiB2YWx1ZXMgdG8gdGhlIHNvdXJjZSBsb2NhdGlvbnMuIEl0IG11c3QgYmUgYW4gaW50ZWdlciB0eXBlLiBJZiB0aGUgPHN0cm9uZz5WYWx1ZSBSYXN0ZXI8L3N0cm9uZz4gaGFzIGJlZW4gc2V0LCB0aGUgdmFsdWVzIGluIHRoYXQgaW5wdXQgd2lsbCB0YWtlIHByZWNlZGVuY2Ugb3ZlciBhbnkgc2V0dGluZyBmb3IgdGhlIDxzdHJvbmc+U291cmNlIEZpZWxkPC9zdHJvbmc+LlwiLFxuXHRcIkBARXVjbGlkZWFuLUFsbG9jYXRpb25fU291cmNlLVJhc3Rlcl90YWcwQEBcIjogXCJBIHJlcXVpcmVkIGlucHV0IHJhc3RlciB0aGF0IGlkZW50aWZpZXMgdGhlIHNvdXJjZSBsb2NhdGlvbnMuIEJhc2VkIG9uIEV1Y2xpZGVhbiBkaXN0YW5jZSwgdGhlIG5lYXJlc3Qgc291cmNlIHdpbGwgYmUgZGV0ZXJtaW5lZCBmb3IgZWFjaCBjZWxsIGluIHRoZSBvdXRwdXRcIixcblx0XCJAQEV1Y2xpZGVhbi1BbGxvY2F0aW9uX1NvdXJjZS1SYXN0ZXJfdGFnMUBAXCI6IFwiVGhlIGlucHV0IHR5cGUgY2FuIGJlIGFuIGludGVnZXIgb3IgYSBmbG9hdGluZy1wb2ludCB0eXBlLlwiLFxuXHRcIkBARXVjbGlkZWFuLUFsbG9jYXRpb25fVmFsdWUtUmFzdGVyX3RhZzBAQFwiOiBcIlRoZSBpbnB1dCBpbnRlZ2VyIHJhc3RlciB0aGF0IGlkZW50aWZpZXMgdGhlIHpvbmUgdmFsdWVzIHRvIGJlIHVzZWQgZm9yIGVhY2ggaW5wdXQgc291cmNlIGxvY2F0aW9uLiBGb3IgZWFjaCBzb3VyY2UgbG9jYXRpb24gY2VsbCwgdGhlIHZhbHVlIGRlZmluZWQgYnkgdGhlIDxzdHJvbmc+VmFsdWUgUmFzdGVyPC9zdHJvbmc+IHdpbGwgYmUgYXNzaWduZWQgdG8gYWxsIGNlbGxzIGFsbG9jYXRlZCB0byB0aGUgc291cmNlIGxvY2F0aW9uIGZvciB0aGUgY29tcHV0YXRpb24uIFRoZSA8c3Ryb25nPlZhbHVlIFJhc3Rlcjwvc3Ryb25nPiB3aWxsIHRha2UgcHJlY2VkZW5jZSBvdmVyIGFueSBzZXR0aW5nIGZvciB0aGUgPHN0cm9uZz5Tb3VyY2UgRmllbGQ8L3N0cm9uZz4uXCIsXG5cdFwiQEBFdWNsaWRlYW4tRGlyZWN0aW9uX0NlbGxzaXplX3RhZzBAQFwiOiBcIlRoZSBjZWxsIHNpemUgYXQgd2hpY2ggdGhlIG91dHB1dCByYXN0ZXIgd2lsbCBiZSBjcmVhdGVkLlwiLFxuXHRcIkBARXVjbGlkZWFuLURpcmVjdGlvbl9DZWxsc2l6ZV90YWcxQEBcIjogXCJJZiB0aGUgY2VsbCBzaXplIHdhcyBleHBsaWNpdGx5IHNldCBpbiA8c3Ryb25nPkFuYWx5c2lzIEVudmlyb25tZW50czwvc3Ryb25nPiAsIHRoYXQgd2lsbCBiZSB0aGUgZGVmYXVsdCBjZWxsIHNpemUuIElmIGl0IHdhcyBub3Qgc2V0LCB0aGUgb3V0cHV0IGNlbGwgc2l6ZSB3aWxsIGJlIHRoZSBzYW1lIGFzIHRoZSA8c3Ryb25nPlNvdXJjZSBSYXN0ZXI8L3N0cm9uZz4uXCIsXG5cdFwiQEBFdWNsaWRlYW4tRGlyZWN0aW9uX0Rpc3RhbmNlLU1ldGhvZF90YWcwQEBcIjogXCJEZXRlcm1pbmVzIHdoZXRoZXIgdG8gY2FsY3VsYXRlIHRoZSBkaXN0YW5jZSB1c2luZyBhIHBsYW5hciAoZmxhdCBlYXJ0aCkgb3IgYSBnZW9kZXNpYyAoZWxsaXBzb2lkKSBtZXRob2QuXCIsXG5cdFwiQEBFdWNsaWRlYW4tRGlyZWN0aW9uX0Rpc3RhbmNlLU1ldGhvZF90YWcxQEBcIjogXCJHZW9kZXNpYy0tVGhlIHNob3J0ZXN0IGxpbmUgYmV0d2VlbiB0d28gcG9pbnRzIG9uIHRoZSBlYXJ0aCdzIHN1cmZhY2Ugb24gYSBzcGhlcm9pZCAoZWxsaXBzb2lkKS4gVGhlcmVmb3JlLCByZWdhcmRsZXNzIG9mIGlucHV0IG9yIG91dHB1dCBwcm9qZWN0aW9uLCB0aGUgcmVzdWx0cyBkbyBub3QgY2hhbmdlLiBPbmUgdXNlIGZvciBhIGdlb2Rlc2ljIGxpbmUgaXMgd2hlbiB5b3Ugd2FudCB0byBkZXRlcm1pbmUgdGhlIHNob3J0ZXN0IGRpc3RhbmNlIGJldHdlZW4gdHdvIGNpdGllcyBmb3IgYW4gYWlycGxhbmUncyBmbGlnaHQgcGF0aC4gVGhpcyBpcyBhbHNvIGtub3duIGFzIGEgZ3JlYXQgY2lyY2xlIGxpbmUgaWYgYmFzZWQgb24gYSBzcGhlcmUgcmF0aGVyIHRoYW4gYW4gZWxsaXBzb2lkLlwiLFxuXHRcIkBARXVjbGlkZWFuLURpcmVjdGlvbl9EaXN0YW5jZS1NZXRob2RfdGFnMkBAXCI6IFwiUGxhbmFyLS1QbGFuYXIgbWVhc3VyZW1lbnRzIHVzZSAyRCBDYXJ0ZXNpYW4gbWF0aGVtYXRpY3MgdG8gY2FsY3VsYXRlIGxlbmd0aCBhbmQgYXJlYS4gVGhlIG9wdGlvbiBpcyBvbmx5IGF2YWlsYWJsZSB3aGVuIG1lYXN1cmluZyBpbiBhIHByb2plY3RlZCBjb29yZGluYXRlIHN5c3RlbSBhbmQgdGhlIDJEIHBsYW5lIG9mIHRoYXQgY29vcmRpbmF0ZSBzeXN0ZW0gd2lsbCBiZSB1c2VkIGFzIHRoZSBiYXNpcyBmb3IgdGhlIG1lYXN1cmVtZW50cy5cIixcblx0XCJAQEV1Y2xpZGVhbi1EaXJlY3Rpb25fTWF4aW11bS1EaXN0YW5jZV90YWcwQEBcIjogXCJEZWZpbmVzIHRoZSB0aHJlc2hvbGQgZGlzdGFuY2Ugd2l0aGluIHdoaWNoIHRoZSBkaXJlY3Rpb24gdG8gdGhlIGNsb3Nlc3Qgc291cmNlIHdpbGwgYmUgY2FsY3VsYXRlZC4gSWYgdGhlIGRpc3RhbmNlIHRvIHRoZSBuZWFyZXN0IHNvdXJjZSBleGNlZWRzIHRoaXMsIHRoZSBvdXRwdXQgZm9yIHRoYXQgY2VsbCB3aWxsIGJlICR7Tm9EYXRhfS5cIixcblx0XCJAQEV1Y2xpZGVhbi1EaXJlY3Rpb25fTWF4aW11bS1EaXN0YW5jZV90YWcxQEBcIjogXCJUaGUgZGVmYXVsdCBkaXN0YW5jZSBpcyB0byB0aGUgZXh0ZW50IG9mIHRoZSBvdXRwdXQgcmFzdGVyLlwiLFxuXHRcIkBARXVjbGlkZWFuLURpcmVjdGlvbl9SYXN0ZXItQmFycmllcnNfdGFnMEBAXCI6IFwiVGhlIHJhc3RlciB0aGF0IGRlZmluZXMgdGhlIGJhcnJpZXJzLlwiLFxuXHRcIkBARXVjbGlkZWFuLURpcmVjdGlvbl9SYXN0ZXItQmFycmllcnNfdGFnMUBAXCI6IFwiVGhlIGRhdGFzZXQgbXVzdCBjb250YWluIE5vRGF0YSB3aGVyZSB0aGVyZSBhcmUgbm8gYmFycmllcnMuIEJhcnJpZXJzIGFyZSByZXByZXNlbnRlZCBieSB2YWxpZCB2YWx1ZXMgaW5jbHVkaW5nIHplcm8uXCIsXG5cdFwiQEBFdWNsaWRlYW4tRGlyZWN0aW9uX1Jhc3Rlci1CYXJyaWVyc190YWcyQEBcIjogXCJUaGUgYmFycmllcnMgY2FuIGJlIGRlZmluZWQgYnkgYW4gaW50ZWdlciBvciBhIGZsb2F0aW5nLXBvaW50IHJhc3Rlci5cIixcblx0XCJAQEV1Y2xpZGVhbi1EaXJlY3Rpb25fU291cmNlLVJhc3Rlcl90YWcwQEBcIjogXCJBIHJlcXVpcmVkIGlucHV0IHJhc3RlciB0aGF0IGlkZW50aWZpZXMgdGhlIGNlbGxzIG9yIGxvY2F0aW9ucyB0byB3aGljaCB0aGUgRXVjbGlkZWFuIGRpcmVjdGlvbiBmb3IgZXZlcnkgb3V0cHV0IGNlbGwgbG9jYXRpb24gaXMgY2FsY3VsYXRlZC5cIixcblx0XCJAQEV1Y2xpZGVhbi1EaXJlY3Rpb25fU291cmNlLVJhc3Rlcl90YWcxQEBcIjogXCJUaGUgaW5wdXQgdHlwZSBjYW4gYmUgYW4gaW50ZWdlciBvciBhIGZsb2F0aW5nLXBvaW50IHR5cGUuXCIsXG5cdFwiQEBFdWNsaWRlYW4tRGlzdGFuY2VfQ2VsbHNpemVfdGFnMEBAXCI6IFwiVGhlIGNlbGwgc2l6ZSBhdCB3aGljaCB0aGUgb3V0cHV0IHJhc3RlciB3aWxsIGJlIGNyZWF0ZWQuXCIsXG5cdFwiQEBFdWNsaWRlYW4tRGlzdGFuY2VfQ2VsbHNpemVfdGFnMUBAXCI6IFwiSWYgdGhlIGNlbGwgc2l6ZSB3YXMgZXhwbGljaXRseSBzZXQgaW4gPHN0cm9uZz5BbmFseXNpcyBFbnZpcm9ubWVudHM8L3N0cm9uZz4gLCB0aGF0IHdpbGwgYmUgdGhlIGRlZmF1bHQgY2VsbCBzaXplLiBJZiBpdCB3YXMgbm90IHNldCwgdGhlIG91dHB1dCBjZWxsIHNpemUgd2lsbCBiZSB0aGUgc2FtZSBhcyB0aGUgPHN0cm9uZz5Tb3VyY2UgUmFzdGVyPC9zdHJvbmc+LlwiLFxuXHRcIkBARXVjbGlkZWFuLURpc3RhbmNlX0Rpc3RhbmNlLU1ldGhvZF90YWcwQEBcIjogXCJEZXRlcm1pbmVzIHdoZXRoZXIgdG8gY2FsY3VsYXRlIHRoZSBkaXN0YW5jZSB1c2luZyBhIHBsYW5hciAoZmxhdCBlYXJ0aCkgb3IgYSBnZW9kZXNpYyAoZWxsaXBzb2lkKSBtZXRob2QuXCIsXG5cdFwiQEBFdWNsaWRlYW4tRGlzdGFuY2VfRGlzdGFuY2UtTWV0aG9kX3RhZzFAQFwiOiBcIkdlb2Rlc2ljLS1UaGUgc2hvcnRlc3QgbGluZSBiZXR3ZWVuIHR3byBwb2ludHMgb24gdGhlIGVhcnRoJ3Mgc3VyZmFjZSBvbiBhIHNwaGVyb2lkIChlbGxpcHNvaWQpLiBUaGVyZWZvcmUsIHJlZ2FyZGxlc3Mgb2YgaW5wdXQgb3Igb3V0cHV0IHByb2plY3Rpb24sIHRoZSByZXN1bHRzIGRvIG5vdCBjaGFuZ2UuIE9uZSB1c2UgZm9yIGEgZ2VvZGVzaWMgbGluZSBpcyB3aGVuIHlvdSB3YW50IHRvIGRldGVybWluZSB0aGUgc2hvcnRlc3QgZGlzdGFuY2UgYmV0d2VlbiB0d28gY2l0aWVzIGZvciBhbiBhaXJwbGFuZSdzIGZsaWdodCBwYXRoLiBUaGlzIGlzIGFsc28ga25vd24gYXMgYSBncmVhdCBjaXJjbGUgbGluZSBpZiBiYXNlZCBvbiBhIHNwaGVyZSByYXRoZXIgdGhhbiBhbiBlbGxpcHNvaWQuXCIsXG5cdFwiQEBFdWNsaWRlYW4tRGlzdGFuY2VfRGlzdGFuY2UtTWV0aG9kX3RhZzJAQFwiOiBcIlBsYW5hci0tUGxhbmFyIG1lYXN1cmVtZW50cyB1c2UgMkQgQ2FydGVzaWFuIG1hdGhlbWF0aWNzIHRvIGNhbGN1bGF0ZSBsZW5ndGggYW5kIGFyZWEuIFRoZSBvcHRpb24gaXMgb25seSBhdmFpbGFibGUgd2hlbiBtZWFzdXJpbmcgaW4gYSBwcm9qZWN0ZWQgY29vcmRpbmF0ZSBzeXN0ZW0gYW5kIHRoZSAyRCBwbGFuZSBvZiB0aGF0IGNvb3JkaW5hdGUgc3lzdGVtIHdpbGwgYmUgdXNlZCBhcyB0aGUgYmFzaXMgZm9yIHRoZSBtZWFzdXJlbWVudHMuXCIsXG5cdFwiQEBFdWNsaWRlYW4tRGlzdGFuY2VfTWF4aW11bS1EaXN0YW5jZV90YWcwQEBcIjogXCJUaGUgdGhyZXNob2xkIHRoYXQgdGhlIGFjY3VtdWxhdGl2ZSBkaXN0YW5jZSB2YWx1ZXMgY2Fubm90IGV4Y2VlZC4gSWYgYW4gYWNjdW11bGF0aXZlIEV1Y2xpZGVhbiBkaXN0YW5jZSBleGNlZWRzIHRoaXMgdmFsdWUsIHRoZSBvdXRwdXQgdmFsdWUgZm9yIHRoZSBjZWxsIGxvY2F0aW9uIHdpbGwgYmUgTm9EYXRhLlwiLFxuXHRcIkBARXVjbGlkZWFuLURpc3RhbmNlX01heGltdW0tRGlzdGFuY2VfdGFnMUBAXCI6IFwiVGhlIGRlZmF1bHQgZGlzdGFuY2UgaXMgdG8gdGhlIGV4dGVudCBvZiB0aGUgb3V0cHV0IHJhc3Rlci5cIixcblx0XCJAQEV1Y2xpZGVhbi1EaXN0YW5jZV9SYXN0ZXItQmFycmllcnNfdGFnMEBAXCI6IFwiVGhlIHJhc3RlciB0aGF0IGRlZmluZXMgdGhlIGJhcnJpZXJzLlwiLFxuXHRcIkBARXVjbGlkZWFuLURpc3RhbmNlX1Jhc3Rlci1CYXJyaWVyc190YWcxQEBcIjogXCJUaGUgZGF0YXNldCBtdXN0IGNvbnRhaW4gJHtOb0RhdGF9IHdoZXJlIHRoZXJlIGFyZSBubyBiYXJyaWVycy4gQmFycmllcnMgYXJlIHJlcHJlc2VudGVkIGJ5IHZhbGlkIHZhbHVlcyBpbmNsdWRpbmcgemVyby5cIixcblx0XCJAQEV1Y2xpZGVhbi1EaXN0YW5jZV9SYXN0ZXItQmFycmllcnNfdGFnMkBAXCI6IFwiVGhlIGJhcnJpZXJzIGNhbiBiZSBkZWZpbmVkIGJ5IGFuIGludGVnZXIgb3IgYSBmbG9hdGluZy1wb2ludCByYXN0ZXIuXCIsXG5cdFwiQEBFdWNsaWRlYW4tRGlzdGFuY2VfU291cmNlLVJhc3Rlcl90YWcwQEBcIjogXCJUaGUgcmVxdWlyZWQgaW5wdXQgcmFzdGVyIHRoYXQgaWRlbnRpZmllcyB0aGUgY2VsbHMgb3IgbG9jYXRpb25zIHRvIHdoaWNoIHRoZSBFdWNsaWRlYW4gZGlzdGFuY2UgZm9yIGV2ZXJ5IG91dHB1dCBjZWxsIGxvY2F0aW9uIGlzIGNhbGN1bGF0ZWQuXCIsXG5cdFwiQEBFdWNsaWRlYW4tRGlzdGFuY2VfU291cmNlLVJhc3Rlcl90YWcxQEBcIjogXCJUaGUgaW5wdXQgdHlwZSBjYW4gYmUgYW4gaW50ZWdlciBvciBhIGZsb2F0aW5nLXBvaW50IHR5cGUuXCIsXG5cdFwiQEBFeHBfQ2VsbHNpemUtVHlwZV90YWcwQEBcIjogXCJDaG9vc2Ugd2hpY2ggY2VsbCBzaXplIHRvIHVzZSBpbiB0aGUgb3V0cHV0IHJhc3Rlci4gSWYgYWxsIHRoZSBpbnB1dCBjZWxsIHNpemVzIGFyZSB0aGUgc2FtZSwgYWxsIHRoZSBvcHRpb25zIHdpbGwgeWllbGQgdGhlIHNhbWUgcmVzdWx0cy5cIixcblx0XCJAQEV4cF9DZWxsc2l6ZS1UeXBlX3RhZzFAQFwiOiBcIkZpcnN0IE9mLS1Vc2UgdGhlIGZpcnN0IGNlbGwgc2l6ZSBvZiB0aGUgaW5wdXQgcmFzdGVycy5cIixcblx0XCJAQEV4cF9DZWxsc2l6ZS1UeXBlX3RhZzJAQFwiOiBcIkxhc3QgT2YtLVVzZSB0aGUgbGFzdCBjZWxsIHNpemUgb2YgdGhlIGlucHV0IHJhc3RlcnMuXCIsXG5cdFwiQEBFeHBfQ2VsbHNpemUtVHlwZV90YWczQEBcIjogXCJNYXggT2YtLVVzZSB0aGUgbGFyZ2VzdCBjZWxsIHNpemUgb2YgYWxsIHRoZSBpbnB1dCByYXN0ZXJzLiBUaGlzIGlzIHRoZSBkZWZhdWx0LlwiLFxuXHRcIkBARXhwX0NlbGxzaXplLVR5cGVfdGFnNEBAXCI6IFwiTWVhbiBPZi0tVXNlIHRoZSBtZWFuIGNlbGwgc2l6ZSBvZiBhbGwgdGhlIGlucHV0IHJhc3RlcnMuXCIsXG5cdFwiQEBFeHBfQ2VsbHNpemUtVHlwZV90YWc1QEBcIjogXCJNaW4gT2YtLVVzZSB0aGUgc21hbGxlc3QgY2VsbCBzaXplIG9mIGFsbCB0aGUgaW5wdXQgcmFzdGVycy5cIixcblx0XCJAQEV4cF9FeHRlbnQtVHlwZV90YWcwQEBcIjogXCJDaG9vc2Ugd2hpY2ggZXh0ZW50IHNob3VsZCBiZSB1c2VkIGluIHRoZSBvdXRwdXQgcmFzdGVyOlwiLFxuXHRcIkBARXhwX0V4dGVudC1UeXBlX3RhZzFAQFwiOiBcIkZpcnN0IE9mLS1Vc2UgdGhlIGV4dGVudCBvZiB0aGUgZmlyc3QgaW5wdXQgcmFzdGVyIHRvIGRldGVybWluZSB0aGUgcHJvY2Vzc2luZyBleHRlbnQuXCIsXG5cdFwiQEBFeHBfRXh0ZW50LVR5cGVfdGFnMkBAXCI6IFwiSW50ZXJzZWN0aW9uIE9mLS1Vc2UgdGhlIGV4dGVudCBvZiB0aGUgb3ZlcmxhcHBpbmcgcGl4ZWxzIHRvIGRldGVybWluZSB0aGUgcHJvY2Vzc2luZyBleHRlbnQuIFRoaXMgaXMgdGhlIGRlZmF1bHQuXCIsXG5cdFwiQEBFeHBfRXh0ZW50LVR5cGVfdGFnM0BAXCI6IFwiTGFzdCBPZi0tVXNlIHRoZSBleHRlbnQgb2YgdGhlIGxhc3QgaW5wdXQgcmFzdGVyIHRvIGRldGVybWluZSB0aGUgcHJvY2Vzc2luZyBleHRlbnQuXCIsXG5cdFwiQEBFeHBfRXh0ZW50LVR5cGVfdGFnNEBAXCI6IFwiVW5pb24gT2YtLVVzZSB0aGUgZXh0ZW50IG9mIGFsbCB0aGUgcmFzdGVycyB0byBkZXRlcm1pbmUgdGhlIHByb2Nlc3NpbmcgZXh0ZW50LlwiLFxuXHRcIkBARXhwX1Jhc3Rlcl90YWcwQEBcIjogXCJUaGUgaW5wdXQgdmFsdWVzIGZvciB3aGljaCB0byBmaW5kIHRoZSBiYXNlIGUgZXhwb25lbnRpYWwuXCIsXG5cdFwiQEBFeHAxMF9DZWxsc2l6ZS1UeXBlX3RhZzBAQFwiOiBcIkNob29zZSB3aGljaCBjZWxsIHNpemUgdG8gdXNlIGluIHRoZSBvdXRwdXQgcmFzdGVyLiBJZiBhbGwgdGhlIGlucHV0IGNlbGwgc2l6ZXMgYXJlIHRoZSBzYW1lLCBhbGwgdGhlIG9wdGlvbnMgd2lsbCB5aWVsZCB0aGUgc2FtZSByZXN1bHRzLlwiLFxuXHRcIkBARXhwMTBfQ2VsbHNpemUtVHlwZV90YWcxQEBcIjogXCJGaXJzdCBPZi0tVXNlIHRoZSBmaXJzdCBjZWxsIHNpemUgb2YgdGhlIGlucHV0IHJhc3RlcnMuXCIsXG5cdFwiQEBFeHAxMF9DZWxsc2l6ZS1UeXBlX3RhZzJAQFwiOiBcIkxhc3QgT2YtLVVzZSB0aGUgbGFzdCBjZWxsIHNpemUgb2YgdGhlIGlucHV0IHJhc3RlcnMuXCIsXG5cdFwiQEBFeHAxMF9DZWxsc2l6ZS1UeXBlX3RhZzNAQFwiOiBcIk1heCBPZi0tVXNlIHRoZSBsYXJnZXN0IGNlbGwgc2l6ZSBvZiBhbGwgdGhlIGlucHV0IHJhc3RlcnMuIFRoaXMgaXMgdGhlIGRlZmF1bHQuXCIsXG5cdFwiQEBFeHAxMF9DZWxsc2l6ZS1UeXBlX3RhZzRAQFwiOiBcIk1lYW4gT2YtLVVzZSB0aGUgbWVhbiBjZWxsIHNpemUgb2YgYWxsIHRoZSBpbnB1dCByYXN0ZXJzLlwiLFxuXHRcIkBARXhwMTBfQ2VsbHNpemUtVHlwZV90YWc1QEBcIjogXCJNaW4gT2YtLVVzZSB0aGUgc21hbGxlc3QgY2VsbCBzaXplIG9mIGFsbCB0aGUgaW5wdXQgcmFzdGVycy5cIixcblx0XCJAQEV4cDEwX0V4dGVudC1UeXBlX3RhZzBAQFwiOiBcIkNob29zZSB3aGljaCBleHRlbnQgc2hvdWxkIGJlIHVzZWQgaW4gdGhlIG91dHB1dCByYXN0ZXI6XCIsXG5cdFwiQEBFeHAxMF9FeHRlbnQtVHlwZV90YWcxQEBcIjogXCJGaXJzdCBPZi0tVXNlIHRoZSBleHRlbnQgb2YgdGhlIGZpcnN0IGlucHV0IHJhc3RlciB0byBkZXRlcm1pbmUgdGhlIHByb2Nlc3NpbmcgZXh0ZW50LlwiLFxuXHRcIkBARXhwMTBfRXh0ZW50LVR5cGVfdGFnMkBAXCI6IFwiSW50ZXJzZWN0aW9uIE9mLS1Vc2UgdGhlIGV4dGVudCBvZiB0aGUgb3ZlcmxhcHBpbmcgcGl4ZWxzIHRvIGRldGVybWluZSB0aGUgcHJvY2Vzc2luZyBleHRlbnQuIFRoaXMgaXMgdGhlIGRlZmF1bHQuXCIsXG5cdFwiQEBFeHAxMF9FeHRlbnQtVHlwZV90YWczQEBcIjogXCJMYXN0IE9mLS1Vc2UgdGhlIGV4dGVudCBvZiB0aGUgbGFzdCBpbnB1dCByYXN0ZXIgdG8gZGV0ZXJtaW5lIHRoZSBwcm9jZXNzaW5nIGV4dGVudC5cIixcblx0XCJAQEV4cDEwX0V4dGVudC1UeXBlX3RhZzRAQFwiOiBcIlVuaW9uIE9mLS1Vc2UgdGhlIGV4dGVudCBvZiBhbGwgdGhlIHJhc3RlcnMgdG8gZGV0ZXJtaW5lIHRoZSBwcm9jZXNzaW5nIGV4dGVudC5cIixcblx0XCJAQEV4cDEwX1Jhc3Rlcl90YWcwQEBcIjogXCJUaGUgaW5wdXQgdmFsdWVzIGZvciB3aGljaCB0byBmaW5kIHRoZSBiYXNlIDEwIGV4cG9uZW50aWFsLlwiLFxuXHRcIkBARXhwMl9DZWxsc2l6ZS1UeXBlX3RhZzBAQFwiOiBcIkNob29zZSB3aGljaCBjZWxsIHNpemUgdG8gdXNlIGluIHRoZSBvdXRwdXQgcmFzdGVyLiBJZiBhbGwgdGhlIGlucHV0IGNlbGwgc2l6ZXMgYXJlIHRoZSBzYW1lLCBhbGwgdGhlIG9wdGlvbnMgd2lsbCB5aWVsZCB0aGUgc2FtZSByZXN1bHRzLlwiLFxuXHRcIkBARXhwMl9DZWxsc2l6ZS1UeXBlX3RhZzFAQFwiOiBcIkZpcnN0IE9mLS1Vc2UgdGhlIGZpcnN0IGNlbGwgc2l6ZSBvZiB0aGUgaW5wdXQgcmFzdGVycy5cIixcblx0XCJAQEV4cDJfQ2VsbHNpemUtVHlwZV90YWcyQEBcIjogXCJMYXN0IE9mLS1Vc2UgdGhlIGxhc3QgY2VsbCBzaXplIG9mIHRoZSBpbnB1dCByYXN0ZXJzLlwiLFxuXHRcIkBARXhwMl9DZWxsc2l6ZS1UeXBlX3RhZzNAQFwiOiBcIk1heCBPZi0tVXNlIHRoZSBsYXJnZXN0IGNlbGwgc2l6ZSBvZiBhbGwgdGhlIGlucHV0IHJhc3RlcnMuIFRoaXMgaXMgdGhlIGRlZmF1bHQuXCIsXG5cdFwiQEBFeHAyX0NlbGxzaXplLVR5cGVfdGFnNEBAXCI6IFwiTWVhbiBPZi0tVXNlIHRoZSBtZWFuIGNlbGwgc2l6ZSBvZiBhbGwgdGhlIGlucHV0IHJhc3RlcnMuXCIsXG5cdFwiQEBFeHAyX0NlbGxzaXplLVR5cGVfdGFnNUBAXCI6IFwiTWluIE9mLS1Vc2UgdGhlIHNtYWxsZXN0IGNlbGwgc2l6ZSBvZiBhbGwgdGhlIGlucHV0IHJhc3RlcnMuXCIsXG5cdFwiQEBFeHAyX0V4dGVudC1UeXBlX3RhZzBAQFwiOiBcIkNob29zZSB3aGljaCBleHRlbnQgc2hvdWxkIGJlIHVzZWQgaW4gdGhlIG91dHB1dCByYXN0ZXI6XCIsXG5cdFwiQEBFeHAyX0V4dGVudC1UeXBlX3RhZzFAQFwiOiBcIkZpcnN0IE9mLS1Vc2UgdGhlIGV4dGVudCBvZiB0aGUgZmlyc3QgaW5wdXQgcmFzdGVyIHRvIGRldGVybWluZSB0aGUgcHJvY2Vzc2luZyBleHRlbnQuXCIsXG5cdFwiQEBFeHAyX0V4dGVudC1UeXBlX3RhZzJAQFwiOiBcIkludGVyc2VjdGlvbiBPZi0tVXNlIHRoZSBleHRlbnQgb2YgdGhlIG92ZXJsYXBwaW5nIHBpeGVscyB0byBkZXRlcm1pbmUgdGhlIHByb2Nlc3NpbmcgZXh0ZW50LiBUaGlzIGlzIHRoZSBkZWZhdWx0LlwiLFxuXHRcIkBARXhwMl9FeHRlbnQtVHlwZV90YWczQEBcIjogXCJMYXN0IE9mLS1Vc2UgdGhlIGV4dGVudCBvZiB0aGUgbGFzdCBpbnB1dCByYXN0ZXIgdG8gZGV0ZXJtaW5lIHRoZSBwcm9jZXNzaW5nIGV4dGVudC5cIixcblx0XCJAQEV4cDJfRXh0ZW50LVR5cGVfdGFnNEBAXCI6IFwiVW5pb24gT2YtLVVzZSB0aGUgZXh0ZW50IG9mIGFsbCB0aGUgcmFzdGVycyB0byBkZXRlcm1pbmUgdGhlIHByb2Nlc3NpbmcgZXh0ZW50LlwiLFxuXHRcIkBARXhwMl9SYXN0ZXJfdGFnMEBAXCI6IFwiVGhlIGlucHV0IHZhbHVlcyBmb3Igd2hpY2ggdG8gZmluZCB0aGUgYmFzZSAyIGV4cG9uZW50aWFsLlwiLFxuXHRcIkBARXh0cmFjdC1CYW5kc19CYW5kX3RhZzBAQFwiOiBcIlNlbGVjdCB0aGUgYmFuZHMgdG8gZXh0cmFjdCBmcm9tIGEgbGlzdCBiYXNlZCBvbiB0aGUgPHN0cm9uZz5NZXRob2Q8L3N0cm9uZz4gcGFyYW1ldGVyIG9wdGlvbiB1c2VkLlwiLFxuXHRcIkBARXh0cmFjdC1CYW5kc19Db21iaW5hdGlvbl90YWcwQEBcIjogXCJUaGUgYmFuZCBjb21iaW5hdGlvbiBvciBiYW5kIG9yZGVyLiBUaGUgc2VsZWN0aW9uIGxpc3QgZGVwZW5kcyBvbiB0aGUgPHN0cm9uZz5NZXRob2Q8L3N0cm9uZz4gb3B0aW9uIHNwZWNpZmllZC4gRm9yIGV4YW1wbGUsIGlmIDxzdHJvbmc+TWV0aG9kPC9zdHJvbmc+IGlzIDxzdHJvbmc+QmFuZCBOYW1lczwvc3Ryb25nPiAsIHlvdSBjYW4gc2VsZWN0IGEgQmx1ZSwgR3JlZW4sIGFuZCBSZWQgY29tYmluYXRpb24gdG8gZXh0cmFjdCBhIG5hdHVyYWwgY29sb3IgaW1hZ2UuXCIsXG5cdFwiQEBFeHRyYWN0LUJhbmRzX01ldGhvZF90YWcwQEBcIjogXCJTZWxlY3Qgb25lIG9mIHRoZSBmb2xsb3dpbmcgbWV0aG9kcyBmb3IgZXh0cmFjdGluZyBiYW5kczpcIixcblx0XCJAQEV4dHJhY3QtQmFuZHNfTWV0aG9kX3RhZzFAQFwiOiBcIjxzdHJvbmc+QmFuZCBJRHM8L3N0cm9uZz4tLVRoZSBiYW5kIGRlc2lnbmF0aW9uIG9yIG51bWJlciwgd2hpY2ggaXMgdW5pcXVlIGZvciBlYWNoIHNlbnNvci4gVGhlc2UgY2FuIGJlIGlkZW50aWNhbCB0byB0aGUgPHN0cm9uZz5CYW5kIE5hbWVzPC9zdHJvbmc+LlwiLFxuXHRcIkBARXh0cmFjdC1CYW5kc19NZXRob2RfdGFnNEBAXCI6IFwiPHN0cm9uZz5CYW5kIE5hbWVzPC9zdHJvbmc+LS1Vc2VzIHRoZSBiYW5kIG5hbWUgcmVwcmVzZW50aW5nIHRoZSB3YXZlbGVuZ3RoIGludGVydmFsIG9uIHRoZSBlbGVjdHJvbWFnbmV0aWMgc3BlY3RydW0gKFJlZCwgTmVhciBJbmZyYXJlZCwgVGhlcm1hbCBJbmZyYXJlZCwgZm9yIGV4YW1wbGUpLiBUaGlzIGNhbiBhbHNvIGJlIGRlc2lnbmF0ZWQgYXMgYSBiYW5kIG51bWJlciBJRC5cIixcblx0XCJAQEV4dHJhY3QtQmFuZHNfTWV0aG9kX3RhZzZAQFwiOiBcIjxzdHJvbmc+QmFuZCBXYXZlbGVuZ3Roczwvc3Ryb25nPi0tVGhlIHdhdmVsZW5ndGggb24gdGhlIGVsZWN0cm9tYWduZXRpYyBzcGVjdHJ1bS5cIixcblx0XCJAQEV4dHJhY3QtQmFuZHNfTWlzc2luZy1CYW5kLUFjdGlvbl90YWcwQEBcIjogXCJTcGVjaWZ5IHRoZSBhY3Rpb24gdGhhdCB3aWxsIG9jY3VyIHdoZW4gYSBiYW5kIHdpdGhpbiB0aGUgZXh0cmFjdCBiYW5kIGxpc3QgaXMgbm90IGF2YWlsYWJsZS5cIixcblx0XCJAQEV4dHJhY3QtQmFuZHNfTWlzc2luZy1CYW5kLUFjdGlvbl90YWcxQEBcIjogXCI8c3Ryb25nPkJlc3QgTWF0Y2g8L3N0cm9uZz4tLUZpbmRzIHRoZSBiZXN0IGF2YWlsYWJsZSBiYW5kIHRvIHVzZSBpbiBwbGFjZSBvZiB0aGUgbWlzc2luZyBiYW5kIGJhc2VkIG9uIHdhdmVsZW5ndGgsIHNvIHRoYXQgdGhlIGZ1bmN0aW9uIHdpbGwgbm90IGZhaWxcIixcblx0XCJAQEV4dHJhY3QtQmFuZHNfTWlzc2luZy1CYW5kLUFjdGlvbl90YWczQEBcIjogXCI8c3Ryb25nPkZhaWw8L3N0cm9uZz4tLUlmIHRoZSBpbnB1dCBkYXRhc2V0IGlzIG1pc3NpbmcgYW55IGJhbmQgc3BlY2lmaWVkIGluIHRoZSA8c3Ryb25nPkJhbmQ8L3N0cm9uZz4gcGFyYW1ldGVyLCB0aGUgZnVuY3Rpb24gd2lsbCBmYWlsLlwiLFxuXHRcIkBARXh0cmFjdC1CYW5kc19SYXN0ZXJfdGFnMEBAXCI6IFwiVGhlIHJhc3RlciBwcm9kdWN0IGZyb20gd2hpY2ggdGhlIGJhbmQgb3IgYmFuZHMgd2lsbCBiZSBleHRyYWN0ZWQuXCIsXG5cdFwiQEBGaWxsX1Jhc3Rlcl90YWcwQEBcIjogXCJBIHNpbmdsZSBiYW5kIGVsZXZhdGlvbiByYXN0ZXIuXCIsXG5cdFwiQEBGaWxsX1otTGltaXRfdGFnMEBAXCI6IFwiVGhlIG1heGltdW0gZWxldmF0aW9uIGRpZmZlcmVuY2UgYmV0d2VlbiBhIHNpbmsgYW5kIGl0cyBwb3VyIHBvaW50IHRvIGJlIGZpbGxlZC5cIixcblx0XCJAQEZpbGxfWi1MaW1pdF90YWcxQEBcIjogXCJVbmxlc3MgYSB2YWx1ZSBpcyBzcGVjaWZpZWQgZm9yIHRoaXMgcGFyYW1ldGVyLCBhbGwgc2lua3Mgd2lsbCBiZSBmaWxsZWQsIHJlZ2FyZGxlc3Mgb2YgZGVwdGguXCIsXG5cdFwiQEBGaWxsX1otTGltaXRfdGFnMkBAXCI6IFwiVGhlIHZhbHVlIGZvciA8c3Ryb25nPlogTGltaXQ8L3N0cm9uZz4gbXVzdCBiZSBncmVhdGVyIHRoYW4gemVyby5cIixcblx0XCJAQEZsb2F0X0NlbGxzaXplLVR5cGVfdGFnMEBAXCI6IFwiQ2hvb3NlIHdoaWNoIGNlbGwgc2l6ZSB0byB1c2UgaW4gdGhlIG91dHB1dCByYXN0ZXIuIElmIGFsbCB0aGUgaW5wdXQgY2VsbCBzaXplcyBhcmUgdGhlIHNhbWUsIGFsbCB0aGUgb3B0aW9ucyB3aWxsIHlpZWxkIHRoZSBzYW1lIHJlc3VsdHMuXCIsXG5cdFwiQEBGbG9hdF9DZWxsc2l6ZS1UeXBlX3RhZzFAQFwiOiBcIkZpcnN0IE9mLS1Vc2UgdGhlIGZpcnN0IGNlbGwgc2l6ZSBvZiB0aGUgaW5wdXQgcmFzdGVycy5cIixcblx0XCJAQEZsb2F0X0NlbGxzaXplLVR5cGVfdGFnMkBAXCI6IFwiTGFzdCBPZi0tVXNlIHRoZSBsYXN0IGNlbGwgc2l6ZSBvZiB0aGUgaW5wdXQgcmFzdGVycy5cIixcblx0XCJAQEZsb2F0X0NlbGxzaXplLVR5cGVfdGFnM0BAXCI6IFwiTWF4IE9mLS1Vc2UgdGhlIGxhcmdlc3QgY2VsbCBzaXplIG9mIGFsbCB0aGUgaW5wdXQgcmFzdGVycy4gVGhpcyBpcyB0aGUgZGVmYXVsdC5cIixcblx0XCJAQEZsb2F0X0NlbGxzaXplLVR5cGVfdGFnNEBAXCI6IFwiTWVhbiBPZi0tVXNlIHRoZSBtZWFuIGNlbGwgc2l6ZSBvZiBhbGwgdGhlIGlucHV0IHJhc3RlcnMuXCIsXG5cdFwiQEBGbG9hdF9DZWxsc2l6ZS1UeXBlX3RhZzVAQFwiOiBcIk1pbiBPZi0tVXNlIHRoZSBzbWFsbGVzdCBjZWxsIHNpemUgb2YgYWxsIHRoZSBpbnB1dCByYXN0ZXJzLlwiLFxuXHRcIkBARmxvYXRfRXh0ZW50LVR5cGVfdGFnMEBAXCI6IFwiQ2hvb3NlIHdoaWNoIGV4dGVudCBzaG91bGQgYmUgdXNlZCBpbiB0aGUgb3V0cHV0IHJhc3RlcjpcIixcblx0XCJAQEZsb2F0X0V4dGVudC1UeXBlX3RhZzFAQFwiOiBcIkZpcnN0IE9mLS1Vc2UgdGhlIGV4dGVudCBvZiB0aGUgZmlyc3QgaW5wdXQgcmFzdGVyIHRvIGRldGVybWluZSB0aGUgcHJvY2Vzc2luZyBleHRlbnQuXCIsXG5cdFwiQEBGbG9hdF9FeHRlbnQtVHlwZV90YWcyQEBcIjogXCJJbnRlcnNlY3Rpb24gT2YtLVVzZSB0aGUgZXh0ZW50IG9mIHRoZSBvdmVybGFwcGluZyBwaXhlbHMgdG8gZGV0ZXJtaW5lIHRoZSBwcm9jZXNzaW5nIGV4dGVudC4gVGhpcyBpcyB0aGUgZGVmYXVsdC5cIixcblx0XCJAQEZsb2F0X0V4dGVudC1UeXBlX3RhZzNAQFwiOiBcIkxhc3QgT2YtLVVzZSB0aGUgZXh0ZW50IG9mIHRoZSBsYXN0IGlucHV0IHJhc3RlciB0byBkZXRlcm1pbmUgdGhlIHByb2Nlc3NpbmcgZXh0ZW50LlwiLFxuXHRcIkBARmxvYXRfRXh0ZW50LVR5cGVfdGFnNEBAXCI6IFwiVW5pb24gT2YtLVVzZSB0aGUgZXh0ZW50IG9mIGFsbCB0aGUgcmFzdGVycyB0byBkZXRlcm1pbmUgdGhlIHByb2Nlc3NpbmcgZXh0ZW50LlwiLFxuXHRcIkBARmxvYXRfUmFzdGVyX3RhZzBAQFwiOiBcIlRoZSBpbnB1dCByYXN0ZXIgdG8gYmUgY29udmVydGVkIHRvIGZsb2F0aW5nIHBvaW50LlwiLFxuXHRcIkBARmxvdy1BY2N1bXVsYXRpb25fRmxvdy1EaXJlY3Rpb24tUmFzdGVyX3RhZzBAQFwiOiBcIlRoZSBpbnB1dCByYXN0ZXIgdGhhdCBzaG93cyB0aGUgZGlyZWN0aW9uIG9mIGZsb3cgb3V0IG9mIGVhY2ggY2VsbC5cIixcblx0XCJAQEZsb3ctQWNjdW11bGF0aW9uX0Zsb3ctRGlyZWN0aW9uLVJhc3Rlcl90YWcxQEBcIjogXCJUaGUgZmxvdyBkaXJlY3Rpb24gcmFzdGVyIGNhbiBiZSBjcmVhdGVkIGJ5IHJ1bm5pbmcgdGhlIDxzdHJvbmc+RmxvdyBEaXJlY3Rpb248L3N0cm9uZz4gZnVuY3Rpb24uXCIsXG5cdFwiQEBGbG93LUFjY3VtdWxhdGlvbl9GbG93LURpcmVjdGlvbi1UeXBlX3RhZzBAQFwiOiBcIkRlZmluZXMgdGhlIHR5cGUgb2YgdGhlIGlucHV0IGZsb3cgZGlyZWN0aW9uIHJhc3Rlci5cIixcblx0XCJAQEZsb3ctQWNjdW11bGF0aW9uX0Zsb3ctRGlyZWN0aW9uLVR5cGVfdGFnMUBAXCI6IFwiPHN0cm9uZz5EODwvc3Ryb25nPi0tVGhlIGlucHV0IGZsb3cgZGlyZWN0aW9uIHJhc3RlciBpcyBvZiB0eXBlIEQ4LiBUaGlzIGlzIHRoZSBkZWZhdWx0LlwiLFxuXHRcIkBARmxvdy1BY2N1bXVsYXRpb25fRmxvdy1EaXJlY3Rpb24tVHlwZV90YWczQEBcIjogXCI8c3Ryb25nPkRJTkY8L3N0cm9uZz4tLVRoZSBpbnB1dCBmbG93IGRpcmVjdGlvbiByYXN0ZXIgaXMgb2YgdHlwZSBELUluZmluaXR5IChESU5GKS5cIixcblx0XCJAQEZsb3ctQWNjdW11bGF0aW9uX0Zsb3ctRGlyZWN0aW9uLVR5cGVfdGFnNUBAXCI6IFwiPHN0cm9uZz5NRkQ8L3N0cm9uZz4tLVRoZSBpbnB1dCBmbG93IGRpcmVjdGlvbiByYXN0ZXIgaXMgb2YgdHlwZSBNdWx0aSBGbG93IERpcmVjdGlvbiAoTUZEKS5cIixcblx0XCJAQEZsb3ctQWNjdW11bGF0aW9uX091dHB1dC1EYXRhLVR5cGVfdGFnMEBAXCI6IFwiVGhlIG91dHB1dCBhY2N1bXVsYXRpb24gcmFzdGVyIGNhbiBiZSBpbnRlZ2VyIG9yIGZsb2F0aW5nIHBvaW50IHR5cGUuXCIsXG5cdFwiQEBGbG93LUFjY3VtdWxhdGlvbl9PdXRwdXQtRGF0YS1UeXBlX3RhZzFAQFwiOiBcIjxzdHJvbmc+RmxvYXQ8L3N0cm9uZz4tLVRoZSBvdXRwdXQgcmFzdGVyIHdpbGwgYmUgZmxvYXRpbmcgcG9pbnQgdHlwZS4gVGhpcyBpcyB0aGUgZGVmYXVsdC5cIixcblx0XCJAQEZsb3ctQWNjdW11bGF0aW9uX091dHB1dC1EYXRhLVR5cGVfdGFnM0BAXCI6IFwiPHN0cm9uZz5JbnRlZ2VyPC9zdHJvbmc+LS1UaGUgb3V0cHV0IHJhc3RlciB3aWxsIGJlIGludGVnZXIgdHlwZS5cIixcblx0XCJAQEZsb3ctQWNjdW11bGF0aW9uX1dlaWdodC1SYXN0ZXJfdGFnMEBAXCI6IFwiQW4gb3B0aW9uYWwgaW5wdXQgcmFzdGVyIGZvciBhcHBseWluZyBhIHdlaWdodCB0byBlYWNoIHBpeGVsLlwiLFxuXHRcIkBARmxvdy1BY2N1bXVsYXRpb25fV2VpZ2h0LVJhc3Rlcl90YWcxQEBcIjogXCJJZiBubyB3ZWlnaHQgcmFzdGVyIGlzIHNwZWNpZmllZCwgYSBkZWZhdWx0IHdlaWdodCBvZiAxIHdpbGwgYmUgYXBwbGllZCB0byBlYWNoIHBpeGVsLlwiLFxuXHRcIkBARmxvdy1EaXJlY3Rpb25fRmxvdy1EaXJlY3Rpb24tVHlwZV90YWcwQEBcIjogXCJEZWZpbmVzIHRoZSB0eXBlIG9mIHRoZSBpbnB1dCBmbG93IGRpcmVjdGlvbiByYXN0ZXIuXCIsXG5cdFwiQEBGbG93LURpcmVjdGlvbl9GbG93LURpcmVjdGlvbi1UeXBlX3RhZzFAQFwiOiBcIjxzdHJvbmc+RDg8L3N0cm9uZz4tLVRoZSBpbnB1dCBmbG93IGRpcmVjdGlvbiByYXN0ZXIgaXMgb2YgdHlwZSBEOC4gVGhpcyBpcyB0aGUgZGVmYXVsdC5cIixcblx0XCJAQEZsb3ctRGlyZWN0aW9uX0Zsb3ctRGlyZWN0aW9uLVR5cGVfdGFnM0BAXCI6IFwiPHN0cm9uZz5ESU5GPC9zdHJvbmc+LS1UaGUgaW5wdXQgZmxvdyBkaXJlY3Rpb24gcmFzdGVyIGlzIG9mIHR5cGUgRC1JbmZpbml0eSAoRElORikuXCIsXG5cdFwiQEBGbG93LURpcmVjdGlvbl9GbG93LURpcmVjdGlvbi1UeXBlX3RhZzVAQFwiOiBcIjxzdHJvbmc+TUZEPC9zdHJvbmc+LS1UaGUgaW5wdXQgZmxvdyBkaXJlY3Rpb24gcmFzdGVyIGlzIG9mIHR5cGUgTXVsdGkgRmxvdyBEaXJlY3Rpb24gKE1GRCkuXCIsXG5cdFwiQEBGbG93LURpcmVjdGlvbl9Gb3JjZS1hbGwtZWRnZS1jZWxscy10by1mbG93LW91dHdhcmRfdGFnMEBAXCI6IFwiU3BlY2lmaWVzIGlmIGVkZ2UgcGl4ZWxzIHdpbGwgYWx3YXlzIGZsb3cgb3V0d2FyZCBvciBmb2xsb3cgbm9ybWFsIGZsb3cgcnVsZXMuXCIsXG5cdFwiQEBGbG93LURpcmVjdGlvbl9Gb3JjZS1hbGwtZWRnZS1jZWxscy10by1mbG93LW91dHdhcmRfdGFnMUBAXCI6IFwiPHN0cm9uZz5Obzwvc3Ryb25nPi0tSWYgdGhlIG1heGltdW0gZHJvcCBvbiB0aGUgaW5zaWRlIG9mIGFuIGVkZ2UgcGl4ZWwgaXMgZ3JlYXRlciB0aGFuIHplcm8sIHRoZSBmbG93IGRpcmVjdGlvbiB3aWxsIGJlIGRldGVybWluZWQgYXMgdXN1YWw7IG90aGVyd2lzZSwgdGhlIGZsb3cgZGlyZWN0aW9uIHdpbGwgYmUgdG93YXJkcyB0aGUgZWRnZS4gUGl4ZWxzIHRoYXQgc2hvdWxkIGZsb3cgZnJvbSB0aGUgZWRnZSBvZiB0aGUgc3VyZmFjZSByYXN0ZXIgaW53YXJkIHdpbGwgZG8gc28uIFRoaXMgaXMgdGhlIGRlZmF1bHQuXCIsXG5cdFwiQEBGbG93LURpcmVjdGlvbl9Gb3JjZS1hbGwtZWRnZS1jZWxscy10by1mbG93LW91dHdhcmRfdGFnM0BAXCI6IFwiPHN0cm9uZz5ZZXM8L3N0cm9uZz4tLUFsbCB0aGUgcGl4ZWxzIGF0IHRoZSBlZGdlIG9mIHRoZSBzdXJmYWNlIHJhc3RlciB3aWxsIGZsb3cgb3V0d2FyZCBmcm9tIHRoZSBzdXJmYWNlIHJhc3Rlci5cIixcblx0XCJAQEZsb3ctRGlyZWN0aW9uX1Jhc3Rlcl90YWcwQEBcIjogXCJUaGUgaW5wdXQgcmFzdGVyIHJlcHJlc2VudGluZyBhIGNvbnRpbnVvdXMgZWxldmF0aW9uIHN1cmZhY2UuXCIsXG5cdFwiQEBGbG93LURpc3RhbmNlX0Rpc3RhbmNlLVR5cGVfdGFnMEBAXCI6IFwiRGV0ZXJtaW5lcyBpZiB0aGUgdmVydGljYWwgb3IgaG9yaXpvbnRhbCBjb21wb25lbnQgb2YgZmxvdyBkaXN0YW5jZSBpcyBjYWxjdWxhdGVkLlwiLFxuXHRcIkBARmxvdy1EaXN0YW5jZV9EaXN0YW5jZS1UeXBlX3RhZzFAQFwiOiBcIjxzdHJvbmc+SG9yaXpvbnRhbDwvc3Ryb25nPi0tVGhlIGZsb3cgZGlzdGFuY2UgY2FsY3VsYXRpb25zIHJlcHJlc2VudCB0aGUgaG9yaXpvbnRhbCBjb21wb25lbnQgb2YgZmxvdyBkaXN0YW5jZSBmcm9tIGVhY2ggcGl4ZWwgaW4gdGhlIGRvbWFpbiB0byB0aGUgcGl4ZWwocykgb24gdGhlIHN0cmVhbSBpbnRvIHdoaWNoIHRoZXkgZmxvdy5cIixcblx0XCJAQEZsb3ctRGlzdGFuY2VfRGlzdGFuY2UtVHlwZV90YWczQEBcIjogXCI8c3Ryb25nPlZlcnRpY2FsPC9zdHJvbmc+LS1UaGUgZmxvdyBkaXN0YW5jZSBjYWxjdWxhdGlvbnMgcmVwcmVzZW50IHRoZSB2ZXJ0aWNhbCBjb21wb25lbnQgb2YgZmxvdyBkaXN0YW5jZSBmcm9tIGVhY2ggcGl4ZWwgaW4gdGhlIGRvbWFpbiB0byB0aGUgcGl4ZWwocykgb24gdGhlIHN0cmVhbSBpbnRvIHdoaWNoIHRoZXkgZmxvdy4gVGhpcyBpcyB0aGUgZGVmYXVsdC5cIixcblx0XCJAQEZsb3ctRGlzdGFuY2VfRmxvdy1EaXJlY3Rpb24tUmFzdGVyX3RhZzBAQFwiOiBcIlRoZSBpbnB1dCByYXN0ZXIgdGhhdCBzaG93cyB0aGUgZGlyZWN0aW9uIG9mIGZsb3cgb3V0IG9mIGVhY2ggcGl4ZWwuXCIsXG5cdFwiQEBGbG93LURpc3RhbmNlX0Zsb3ctRGlyZWN0aW9uLVJhc3Rlcl90YWcxQEBcIjogXCJXaGVuIGEgZmxvdyBkaXJlY3Rpb24gcmFzdGVyIGlzIHByb3ZpZGVkLCB0aGUgZG93biBzbG9wZSBkaXJlY3Rpb24ocykgd2lsbCBiZSBsaW1pdGVkIHRvIHRob3NlIGRlZmluZWQgYnkgdGhlIGlucHV0IGZsb3cgZGlyZWN0aW9ucy5cIixcblx0XCJAQEZsb3ctRGlzdGFuY2VfRmxvdy1EaXJlY3Rpb24tUmFzdGVyX3RhZzJAQFwiOiBcIlRoZSBmbG93IGRpcmVjdGlvbiByYXN0ZXIgY2FuIGJlIGNyZWF0ZWQgdXNpbmcgdGhlIEZsb3cgRGlyZWN0aW9uIGZ1bmN0aW9uLlwiLFxuXHRcIkBARmxvdy1EaXN0YW5jZV9GbG93LURpcmVjdGlvbi1UeXBlX3RhZzBAQFwiOiBcIkRlZmluZXMgdGhlIHR5cGUgb2YgdGhlIGlucHV0IGZsb3cgZGlyZWN0aW9uIHJhc3Rlci5cIixcblx0XCJAQEZsb3ctRGlzdGFuY2VfRmxvdy1EaXJlY3Rpb24tVHlwZV90YWcxQEBcIjogXCI8c3Ryb25nPkQ4PC9zdHJvbmc+LS1UaGUgaW5wdXQgZmxvdyBkaXJlY3Rpb24gcmFzdGVyIGlzIG9mIHR5cGUgRDguIFRoaXMgaXMgdGhlIGRlZmF1bHQuXCIsXG5cdFwiQEBGbG93LURpc3RhbmNlX0Zsb3ctRGlyZWN0aW9uLVR5cGVfdGFnM0BAXCI6IFwiPHN0cm9uZz5ESU5GPC9zdHJvbmc+LS1UaGUgaW5wdXQgZmxvdyBkaXJlY3Rpb24gcmFzdGVyIGlzIG9mIHR5cGUgRC1JbmZpbml0eSAoRElORikuXCIsXG5cdFwiQEBGbG93LURpc3RhbmNlX0Zsb3ctRGlyZWN0aW9uLVR5cGVfdGFnNUBAXCI6IFwiPHN0cm9uZz5NRkQ8L3N0cm9uZz4tLVRoZSBpbnB1dCBmbG93IGRpcmVjdGlvbiByYXN0ZXIgaXMgb2YgdHlwZSBNdWx0aSBGbG93IERpcmVjdGlvbiAoTUZEKS5cIixcblx0XCJAQEZsb3ctRGlzdGFuY2VfU3RhdGlzdGljcy1UeXBlX3RhZzBAQFwiOiBcIkRldGVybWluZXMgdGhlIHN0YXRpc3RpY3MgdHlwZSB1c2VkIHRvIGNvbXB1dGUgZmxvdyBkaXN0YW5jZSBvdmVyIG11bHRpcGxlIGZsb3cgcGF0aHMuIElmIHRoZXJlIGlzIG9ubHkgYSBzaW5nbGUgZmxvdyBwYXRoIGZyb20gZWFjaCBjZWxsIHRvIGEgY2VsbCBvbiB0aGUgc3RyZWFtLCBhbGwgc3RhdGlzdGljcyB0eXBlcyBwcm9kdWNlIHRoZSBzYW1lIHJlc3VsdC5cIixcblx0XCJAQEZsb3ctRGlzdGFuY2VfU3RhdGlzdGljcy1UeXBlX3RhZzFAQFwiOiBcIjxzdHJvbmc+TWluaW11bTwvc3Ryb25nPi0tV2hlcmUgbXVsdGlwbGUgZmxvdyBwYXRocyBleGlzdCwgbWluaW11bSBmbG93IGRpc3RhbmNlIGluIGNvbXB1dGVkLiBUaGlzIGlzIHRoZSBkZWZhdWx0LlwiLFxuXHRcIkBARmxvdy1EaXN0YW5jZV9TdGF0aXN0aWNzLVR5cGVfdGFnM0BAXCI6IFwiPHN0cm9uZz5XZWlnaHRlZCBNZWFuPC9zdHJvbmc+LS1XaGVyZSBtdWx0aXBsZSBmbG93IHBhdGhzIGV4aXN0LCBhIHdlaWdodGVkIG1lYW4gb2YgZmxvdyBkaXN0YW5jZSBpcyBjb21wdXRlZC4gRmxvdyBwcm9wb3J0aW9uIGZyb20gYSBjZWxsIHRvIGl0cyBkb3duc3RyZWFtIG5laWdoYm9yaW5nIGNlbGxzIGFyZSB1c2VkIGFzIHdlaWdodHMgZm9yIGNvbXB1dGluZyB3ZWlnaHRlZCBtZWFuLlwiLFxuXHRcIkBARmxvdy1EaXN0YW5jZV9TdGF0aXN0aWNzLVR5cGVfdGFnNUBAXCI6IFwiPHN0cm9uZz5NYXhpbXVtPC9zdHJvbmc+LS1XaGVuIG11bHRpcGxlIGZsb3cgcGF0aHMgZXhpc3QsIG1heGltdW0gZmxvdyBkaXN0YW5jZSBpcyBjb21wdXRlZC5cIixcblx0XCJAQEZsb3ctRGlzdGFuY2VfU3RyZWFtLVJhc3Rlcl90YWcwQEBcIjogXCJBbiBpbnB1dCBzdHJlYW0gcmFzdGVyIHRoYXQgcmVwcmVzZW50cyBhIGxpbmVhciBzdHJlYW0gbmV0d29yay5cIixcblx0XCJAQEZsb3ctRGlzdGFuY2VfU3VyZmFjZS1SYXN0ZXJfdGFnMEBAXCI6IFwiVGhlIGlucHV0IHJhc3RlciByZXByZXNlbnRpbmcgYSBjb250aW51b3VzIGVsZXZhdGlvbiBzdXJmYWNlLlwiLFxuXHRcIkBARmxvdy1MZW5ndGhfRGlyZWN0aW9uLW9mLU1lYXN1cmVtZW50X3RhZzBAQFwiOiBcIlRoZSBkaXJlY3Rpb24gb2YgbWVhc3VyZW1lbnQgYWxvbmcgdGhlIGZsb3cgcGF0aC5cIixcblx0XCJAQEZsb3ctTGVuZ3RoX0RpcmVjdGlvbi1vZi1NZWFzdXJlbWVudF90YWcxQEBcIjogXCI8c3Ryb25nPkRvd25zdHJlYW08L3N0cm9uZz4tLUNhbGN1bGF0ZXMgdGhlIGRvd25zbG9wZSBkaXN0YW5jZSBhbG9uZyB0aGUgZmxvdyBwYXRoLCBmcm9tIGVhY2ggY2VsbCB0byBhIHNpbmsgb3Igb3V0bGV0IG9uIHRoZSBlZGdlIG9mIHRoZSByYXN0ZXIuXCIsXG5cdFwiQEBGbG93LUxlbmd0aF9EaXJlY3Rpb24tb2YtTWVhc3VyZW1lbnRfdGFnM0BAXCI6IFwiPHN0cm9uZz5VcHN0cmVhbTwvc3Ryb25nPi0tQ2FsY3VsYXRlcyB0aGUgbG9uZ2VzdCB1cHNsb3BlIGRpc3RhbmNlIGFsb25nIHRoZSBmbG93IHBhdGgsIGZyb20gZWFjaCBjZWxsIHRvIHRoZSB0b3Agb2YgdGhlIGRyYWluYWdlIGRpdmlkZS5cIixcblx0XCJAQEZsb3ctTGVuZ3RoX0Zsb3ctRGlyZWN0aW9uLVJhc3Rlcl90YWcwQEBcIjogXCJUaGUgaW5wdXQgcmFzdGVyIHRoYXQgc2hvd3MgdGhlIGRpcmVjdGlvbiBvZiBmbG93IG91dCBvZiBlYWNoIGNlbGwuXCIsXG5cdFwiQEBGbG93LUxlbmd0aF9GbG93LURpcmVjdGlvbi1SYXN0ZXJfdGFnMUBAXCI6IFwiVGhlIGZsb3cgZGlyZWN0aW9uIHJhc3RlciBjYW4gYmUgY3JlYXRlZCBieSBydW5uaW5nIHRoZSA8c3Ryb25nPkZsb3cgRGlyZWN0aW9uPC9zdHJvbmc+IGZ1bmN0aW9uLlwiLFxuXHRcIkBARmxvdy1MZW5ndGhfV2VpZ2h0LVJhc3Rlcl90YWcwQEBcIjogXCJBbiBvcHRpb25hbCBpbnB1dCByYXN0ZXIgZm9yIGFwcGx5aW5nIGEgd2VpZ2h0IHRvIGVhY2ggY2VsbC5cIixcblx0XCJAQEZsb3ctTGVuZ3RoX1dlaWdodC1SYXN0ZXJfdGFnMUBAXCI6IFwiSWYgbm8gd2VpZ2h0IHJhc3RlciBpcyBzcGVjaWZpZWQsIGEgZGVmYXVsdCB3ZWlnaHQgb2YgMSB3aWxsIGJlIGFwcGxpZWQgdG8gZWFjaCBjZWxsLlwiLFxuXHRcIkBARm9jYWwtU3RhdGlzdGljc19JZ25vcmUtTm9EYXRhLWluLWNhbGN1bGF0aW9uc190YWcwQEBcIjogXCJEZW5vdGVzIHdoZXRoZXIgJHtOb0RhdGF9IHZhbHVlcyBhcmUgaWdub3JlZCBieSB0aGUgc3RhdGlzdGljIGNhbGN1bGF0aW9uLlwiLFxuXHRcIkBARm9jYWwtU3RhdGlzdGljc19JZ25vcmUtTm9EYXRhLWluLWNhbGN1bGF0aW9uc190YWcxQEBcIjogXCI8c3Ryb25nPkNoZWNrZWQ8L3N0cm9uZz4tLVNwZWNpZmllcyB0aGF0IGlmIGEgJHtOb0RhdGF9IHZhbHVlIGV4aXN0cyB3aXRoaW4gYSBuZWlnaGJvcmhvb2QsIHRoZSAke05vRGF0YX0gdmFsdWUgd2lsbCBiZSBpZ25vcmVkLiBPbmx5IGNlbGxzIHdpdGhpbiB0aGUgbmVpZ2hib3Job29kIHRoYXQgaGF2ZSBkYXRhIHZhbHVlcyB3aWxsIGJlIHVzZWQgaW4gZGV0ZXJtaW5pbmcgdGhlIG91dHB1dCB2YWx1ZS4gVGhpcyBpcyB0aGUgZGVmYXVsdC5cIixcblx0XCJAQEZvY2FsLVN0YXRpc3RpY3NfSWdub3JlLU5vRGF0YS1pbi1jYWxjdWxhdGlvbnNfdGFnM0BAXCI6IFwiPHN0cm9uZz5VbmNoZWNrZWQ8L3N0cm9uZz4tLVNwZWNpZmllcyB0aGF0IGlmIGFueSBjZWxsIGluIGEgbmVpZ2hib3Job29kIGhhcyBhIHZhbHVlIG9mICR7Tm9EYXRhfSwgdGhlIG91dHB1dCBmb3IgdGhlIHByb2Nlc3NpbmcgY2VsbCB3aWxsIGJlICR7Tm9EYXRhfS5cIixcblx0XCJAQEZvY2FsLVN0YXRpc3RpY3NfTmVpZ2hib3Job29kX3RhZzBAQFwiOiBcIlRoZSBzaGFwZSBvZiB0aGUgYXJlYSBhcm91bmQgZWFjaCBjZWxsIHVzZWQgdG8gY2FsY3VsYXRlIHRoZSBzdGF0aXN0aWMuXCIsXG5cdFwiQEBGb2NhbC1TdGF0aXN0aWNzX05laWdoYm9yaG9vZF90YWcxQEBcIjogXCJFYWNoIG5laWdoYm9yaG9vZCBoYXZlIGFkZGl0aW9uYWwgcGFyYW1ldGVycyB3aXRoIHdoaWNoIHRvIGRlZmluZSB0aGUgc2hhcGUuXCIsXG5cdFwiQEBGb2NhbC1TdGF0aXN0aWNzX05laWdoYm9yaG9vZF90YWcyQEBcIjogXCJBbm51bHVzLCBJbm5lciBSYWRpdXMsIE91dGVyIFJhZGl1c1wiLFxuXHRcIkBARm9jYWwtU3RhdGlzdGljc19OZWlnaGJvcmhvb2RfdGFnM0BAXCI6IFwiQ2lyY2xlLCBSYWRpdXNcIixcblx0XCJAQEZvY2FsLVN0YXRpc3RpY3NfTmVpZ2hib3Job29kX3RhZzRAQFwiOiBcIklycmVndWxhciwgV2lkdGgsIEhlaWdodCwgTmVpZ2hib3Job29kIHZhbHVlc1wiLFxuXHRcIkBARm9jYWwtU3RhdGlzdGljc19OZWlnaGJvcmhvb2RfdGFnNUBAXCI6IFwiUmVjdGFuZ2xlLCBXaWR0aCwgSGVpZ2h0XCIsXG5cdFwiQEBGb2NhbC1TdGF0aXN0aWNzX05laWdoYm9yaG9vZF90YWc2QEBcIjogXCJXZWRnZSwgUmFkaXVzLCBTdGFydCBhbmdsZSwgRW5kIGFuZ2xlXCIsXG5cdFwiQEBGb2NhbC1TdGF0aXN0aWNzX05laWdoYm9yaG9vZF90YWc3QEBcIjogXCJXZWlnaHQsIFdpZHRoLCBIZWlnaHQsIE5laWdoYm9yaG9vZCB2YWx1ZXNcIixcblx0XCJAQEZvY2FsLVN0YXRpc3RpY3NfTmVpZ2hib3Job29kX3RhZzhAQFwiOiBcIlRoZSBJcnJlZ3VsYXIgbmVpZ2hib3Job29kIGFsbG93cyB5b3UgdG8gc3BlY2lmeSBhbiBpcnJlZ3VsYXJseSBzaGFwZWQgbmVpZ2hib3Job29kIGFyb3VuZCB0aGUgcHJvY2Vzc2luZyBjZWxsLiBVc2UgdGhlIE5laWdoYm9yaG9vZCB2YWx1ZXMgdGFibGUgdG8gZGVmaW5lIHRoZSBzaGFwZSBvZiB0aGUgbmVpZ2hib3Job29kIGtlcm5lbC4gQSB2YWx1ZSBvZiAwIGZvciBhIGNlbGwgcG9zaXRpb24gaW5kaWNhdGVzIHRoYXQgdGhlIGNlbGwgaXMgbm90IHBhcnQgb2YgdGhlIG5laWdoYm9yaG9vZCwgYW5kIHdpbGwgbm90IGJlIHVzZWQgZm9yIHByb2Nlc3NpbmcuIEEgdmFsdWUgb2YgMSBpbmRpY2F0ZXMgdGhhdCBpdHMgY29ycmVzcG9uZGluZyBjZWxsIChhbmQgdmFsdWUpIGlzIGEgbWVtYmVyIG9mIHRoZSBuZWlnaGJvcmhvb2QuXCIsXG5cdFwiQEBGb2NhbC1TdGF0aXN0aWNzX05laWdoYm9yaG9vZF90YWc5QEBcIjogXCJUaGUgV2VpZ2h0IG5laWdoYm9yaG9vZCBpcyBzaW1pbGFyIHRvIHRoZSBpcnJlZ3VsYXIgbmVpZ2hib3Job29kIHR5cGUsIGluIHRoYXQgaXQgYWxsb3dzIHlvdSB0byBkZWZpbmUgYW4gaXJyZWd1bGFyIG5laWdoYm9yaG9vZCBhcm91bmQgdGhlIHByb2Nlc3NpbmcgY2VsbCwgYnV0IGl0IGFkZGl0aW9uYWxseSBhbGxvd3MgeW91IHRvIGFwcGx5IHdlaWdodHMgdG8gdGhlIGlucHV0IHZhbHVlcy4gVGhlIHZhbHVlcyBpbiB0aGUgd2VpZ2h0IGtlcm5lbCBzcGVjaWZpZXMgd2hpY2ggY2VsbCBwb3NpdGlvbnMgc2hvdWxkIGJlIGluY2x1ZGVkIHdpdGhpbiB0aGUgbmVpZ2hib3Job29kIGFuZCB0aGUgd2VpZ2h0cyBieSB3aGljaCB0aGV5IHdpbGwgYmUgbXVsdGlwbGllZC4gVXNlIGEgdmFsdWUgb2YgMCB0byBleGNsdWRlIGEgY2VsbCBmcm9tIHByb2Nlc3NpbmcuIFBvc2l0aXZlLCBuZWdhdGl2ZSwgYW5kIGRlY2ltYWwgdmFsdWVzIGFyZSBhbGwgdmFsaWQgb3B0aW9ucyB0byB1c2UgYXMgYSB3ZWlnaHQuIEZvciB0aGUgV2VpZ2h0IG5laWdoYm9yaG9vZCB0eXBlLCBvbmx5IHRoZSBNZWFuLCBTdGFuZGFyZCBEZXZpYXRpb24sIG9yIFN1bSBzdGF0aXN0aWNzIGFyZSBzdXBwb3J0ZWQuXCIsXG5cdFwiQEBGb2NhbC1TdGF0aXN0aWNzX1BlcmNlbnRpbGUtVmFsdWVfdGFnMEBAXCI6IFwiRGVub3RlcyB3aGljaCBwZXJjZW50aWxlIHRvIGNhbGN1bGF0ZSB3aGVuIDxzdHJvbmc+UGVyY2VudGlsZTwvc3Ryb25nPiBpcyBzZWxlY3RlZCBhcyB0aGUgc3RhdGlzdGljcyB0eXBlLiBUaGUgZGVmYXVsdCBpcyA5MCwgZm9yIHRoZSA5MHRoIHBlcmNlbnRpbGUuXCIsXG5cdFwiQEBGb2NhbC1TdGF0aXN0aWNzX1BlcmNlbnRpbGUtVmFsdWVfdGFnM0BAXCI6IFwiVGhlIHZhbHVlcyBjYW4gcmFuZ2UgZnJvbSAwIHRvIDEwMC4gVGhlIDB0aCBwZXJjZW50aWxlIGlzIGVzc2VudGlhbGx5IGVxdWl2YWxlbnQgdG8gdGhlIE1pbmltdW0gc3RhdGlzdGljLCBhbmQgdGhlIDEwMHRoIHBlcmNlbnRpbGUgZXF1aXZhbGVudCB0byBNYXhpbXVtLCB3aXRoIHRoZSBleGNlcHRpb24gdGhhdCB0aGUgcmVzdWx0IHdpbGwgYmUgZmxvYXRpbmcgcG9pbnQuIEEgdmFsdWUgb2YgNTAgd2lsbCBlc3NlbnRpYWxseSBwcm9kdWNlIHRoZSBzYW1lIHJlc3VsdCBhcyB0aGUgTWVkaWFuIHN0YXRpc3RpYy5cIixcblx0XCJAQEZvY2FsLVN0YXRpc3RpY3NfUmFzdGVyX3RhZzBAQFwiOiBcIlRoZSByZXF1aXJlZCBpbnB1dCByYXN0ZXIuXCIsXG5cdFwiQEBGb2NhbC1TdGF0aXN0aWNzX1N0YXRpc3RpY3MtVHlwZV90YWcwQEBcIjogXCJUaGUgc3RhdGlzdGljIHR5cGUgdG8gYmUgY2FsY3VsYXRlZC5cIixcblx0XCJAQEZvY2FsLVN0YXRpc3RpY3NfU3RhdGlzdGljcy1UeXBlX3RhZzFAQFwiOiBcIjxzdHJvbmc+TWFqb3JpdHk8L3N0cm9uZz4tLUNhbGN1bGF0ZXMgdGhlIG1ham9yaXR5ICh2YWx1ZSB0aGF0IG9jY3VycyBtb3N0IG9mdGVuKSBvZiB0aGUgY2VsbHMgaW4gdGhlIG5laWdoYm9yaG9vZC5cIixcblx0XCJAQEZvY2FsLVN0YXRpc3RpY3NfU3RhdGlzdGljcy1UeXBlX3RhZzNAQFwiOiBcIjxzdHJvbmc+TWF4aW11bTwvc3Ryb25nPi0tQ2FsY3VsYXRlcyB0aGUgbWF4aW11bSAobGFyZ2VzdCB2YWx1ZSkgb2YgdGhlIGNlbGxzIGluIHRoZSBuZWlnaGJvcmhvb2QuXCIsXG5cdFwiQEBGb2NhbC1TdGF0aXN0aWNzX1N0YXRpc3RpY3MtVHlwZV90YWc1QEBcIjogXCI8c3Ryb25nPk1lYW48L3N0cm9uZz4tLUNhbGN1bGF0ZXMgdGhlIG1lYW4gKGF2ZXJhZ2UgdmFsdWUpIG9mIHRoZSBjZWxscyBpbiB0aGUgbmVpZ2hib3Job29kLlwiLFxuXHRcIkBARm9jYWwtU3RhdGlzdGljc19TdGF0aXN0aWNzLVR5cGVfdGFnN0BAXCI6IFwiPHN0cm9uZz5NZWRpYW48L3N0cm9uZz4tLUNhbGN1bGF0ZXMgdGhlIG1lZGlhbiBvZiB0aGUgY2VsbHMgaW4gdGhlIG5laWdoYm9yaG9vZC5cIixcblx0XCJAQEZvY2FsLVN0YXRpc3RpY3NfU3RhdGlzdGljcy1UeXBlX3RhZzlAQFwiOiBcIjxzdHJvbmc+TWluaW11bTwvc3Ryb25nPi0tQ2FsY3VsYXRlcyB0aGUgbWluaW11bSAoc21hbGxlc3QgdmFsdWUpIG9mIHRoZSBjZWxscyBpbiB0aGUgbmVpZ2hib3Job29kLlwiLFxuXHRcIkBARm9jYWwtU3RhdGlzdGljc19TdGF0aXN0aWNzLVR5cGVfdGFnMTFAQFwiOiBcIjxzdHJvbmc+TWlub3JpdHk8L3N0cm9uZz4tLUNhbGN1bGF0ZXMgdGhlIG1pbm9yaXR5ICh2YWx1ZSB0aGF0IG9jY3VycyBsZWFzdCBvZnRlbikgb2YgdGhlIGNlbGxzIGluIHRoZSBuZWlnaGJvcmhvb2QuXCIsXG5cdFwiQEBGb2NhbC1TdGF0aXN0aWNzX1N0YXRpc3RpY3MtVHlwZV90YWcxM0BAXCI6IFwiPHN0cm9uZz5QZXJjZW50aWxlPC9zdHJvbmc+LS1DYWxjdWxhdGVzIGEgcGVyY2VudGlsZSBvZiB0aGUgY2VsbHMgaW4gdGhlIG5laWdoYm9yaG9vZC4gWW91IGNhbiBkZXRlcm1pbmUgd2hpY2ggcGVyY2VudGlsZSB0byBjYWxjdWxhdGUgd2l0aCB0aGUgPHN0cm9uZz5QZXJjZW50aWxlIFZhbHVlPC9zdHJvbmc+IHBhcmFtZXRlci5cIixcblx0XCJAQEZvY2FsLVN0YXRpc3RpY3NfU3RhdGlzdGljcy1UeXBlX3RhZzE3QEBcIjogXCI8c3Ryb25nPlJhbmdlPC9zdHJvbmc+LS1DYWxjdWxhdGVzIHRoZSByYW5nZSAoZGlmZmVyZW5jZSBiZXR3ZWVuIGxhcmdlc3QgYW5kIHNtYWxsZXN0IHZhbHVlKSBvZiB0aGUgY2VsbHMgaW4gdGhlIG5laWdoYm9yaG9vZC5cIixcblx0XCJAQEZvY2FsLVN0YXRpc3RpY3NfU3RhdGlzdGljcy1UeXBlX3RhZzE5QEBcIjogXCI8c3Ryb25nPlN0YW5kYXJkIERldmlhdGlvbjwvc3Ryb25nPi0tQ2FsY3VsYXRlcyB0aGUgc3RhbmRhcmQgZGV2aWF0aW9uIG9mIHRoZSBjZWxscyBpbiB0aGUgbmVpZ2hib3Job29kLlwiLFxuXHRcIkBARm9jYWwtU3RhdGlzdGljc19TdGF0aXN0aWNzLVR5cGVfdGFnMjFAQFwiOiBcIjxzdHJvbmc+U3VtPC9zdHJvbmc+LS1DYWxjdWxhdGVzIHRoZSBzdW0gKHRvdGFsIG9mIGFsbCB2YWx1ZXMpIG9mIHRoZSBjZWxscyBpbiB0aGUgbmVpZ2hib3Job29kLlwiLFxuXHRcIkBARm9jYWwtU3RhdGlzdGljc19TdGF0aXN0aWNzLVR5cGVfdGFnMjNAQFwiOiBcIjxzdHJvbmc+VmFyaWV0eTwvc3Ryb25nPi0tQ2FsY3VsYXRlcyB0aGUgdmFyaWV0eSAodGhlIG51bWJlciBvZiB1bmlxdWUgdmFsdWVzKSBvZiB0aGUgY2VsbHMgaW4gdGhlIG5laWdoYm9yaG9vZC5cIixcblx0XCJAQEZvY2FsLVN0YXRpc3RpY3NfU3RhdGlzdGljcy1UeXBlX3RhZzI1QEBcIjogXCJJZiB0aGUgaW5wdXQgcmFzdGVyIGlzIGZsb2F0aW5nIHBvaW50LCBvbmx5IHRoZSBNZWFuLCBNYXhpbXVtLCBNZWRpYW4sIE1pbmltdW0sIFBlcmNlbnRpbGUsIFJhbmdlLCBTdGFuZGFyZCBEZXZpYXRpb24sIGFuZCBTdW0gc3RhdGlzdGljIHR5cGVzIGFyZSBhdmFpbGFibGUuXCIsXG5cdFwiQEBGb2NhbC1TdGF0aXN0aWNzX1N0YXRpc3RpY3MtVHlwZV90YWcyNkBAXCI6IFwiRm9yIE1lYW4sIE1lZGlhbiwgUGVyY2VudGlsZSwgYW5kIFN0YW5kYXJkIERldmlhdGlvbiwgdGhlIG91dHB1dCBpcyBhbHdheXMgZmxvYXRpbmcgcG9pbnQuXCIsXG5cdFwiQEBGb2NhbC1TdGF0aXN0aWNzX1N0YXRpc3RpY3MtVHlwZV90YWcyN0BAXCI6IFwiVGhlIGRlZmF1bHQgc3RhdGlzdGljIHR5cGUgaXMgTWVhbi5cIixcblx0XCJAQEdlb21ldHJpY19Db25zdGFudC1aX3RhZzBAQFwiOiBcIlNwZWNpZnkgYSBjb25zdGFudCBlbGV2YXRpb24gdG8gdXNlIGZvciB0aGUgR2VvbWV0cmljIGZ1bmN0aW9uLlwiLFxuXHRcIkBAR2VvbWV0cmljX0RFTV90YWcwQEBcIjogXCJTcGVjaWZ5IHRoZSBERU0gdG8gdXNlIGZvciB0aGUgR2VvbWV0cmljIGZ1bmN0aW9uLiBZb3UgY2FuIHVzZSBhIERFTSBjb250YWluZWQgaW4gdGhlIG1vc2FpYyBkYXRhc2V0IGFzIGEgcmFzdGVyIGRhdGFzZXQgb3IgYXMgYSBtb3NhaWMgZGF0YXNldCB3aG9zZSBvdXRwdXQgaXMgYSBERU0uXCIsXG5cdFwiQEBHZW9tZXRyaWNfR2VvaWRfdGFnMEBAXCI6IFwiTW9zdCBlbGV2YXRpb24gZGF0YXNldHMsIHN1Y2ggYXMgVVNHUyBORUQgb3IgQXJjR0lTIE9ubGluZSBXb3JsZCBFbGV2YXRpb24sIGFyZSBvcnRob21ldHJpYyBoZWlnaHRzLCBzbyBpdCBpcyBuZWNlc3NhcnkgdG8gc2VsZWN0IHRoZSBHZW9pZCBjb3JyZWN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggc2F0ZWxsaXRlIFJQQ3MsIHdoaWNoIHJlcXVpcmUgZWxsaXBzb2lkYWwgaGVpZ2h0cy4gQ2hlY2sgdGhlIDxzdHJvbmc+R2VvaWQ8L3N0cm9uZz4gY2hlY2sgYm94IHRvIGFwcGx5IHRoZSBnZW9pZCAoRUdNOTYpIGNvcnJlY3Rpb24gdG8gdGhlIHotdmFsdWVzLCB1bmxlc3MgeW91ciBERU0gaXMgYWxyZWFkeSByZWZlcmVuY2VkIHRvIGVsbGlwc29pZGFsIGhlaWdodHMuXCIsXG5cdFwiQEBHZW9tZXRyaWNfTWV0aG9kX3RhZzBAQFwiOiBcIkNob29zZSB0aGUgZWxldmF0aW9uIG1ldGhvZCBmb3IgdGhlIGdlb21ldHJpYyBmdW5jdGlvbjpcIixcblx0XCJAQEdlb21ldHJpY19NZXRob2RfdGFnMUBAXCI6IFwiVXNlIENvbnN0YW50IFotLVNwZWNpZnkgYSBjb25zdGFudCBlbGV2YXRpb24gdG8gcGVyZm9ybSB0aGUgR2VvbWV0cmljIGZ1bmN0aW9uLlwiLFxuXHRcIkBAR2VvbWV0cmljX01ldGhvZF90YWcyQEBcIjogXCJVc2UgREVNLS1TcGVjaWZ5IGEgREVNIHRvIHBlcmZvcm0gdGhlIEdlb21ldHJpYyBmdW5jdGlvbi5cIixcblx0XCJAQEdlb21ldHJpY19SYXN0ZXJfdGFnMEBAXCI6IFwiVGhlIGlucHV0IHJhc3Rlci5cIixcblx0XCJAQEdlb21ldHJpY19aLUZhY3Rvcl90YWcwQEBcIjogXCJTYXRlbGxpdGUgcmF0aW9uYWwgcG9seW5vbWlhbCBjb2VmZmljaWVudHMgKFJQQ3MpIGFyZSBzY2FsZWQgZm9yIGVsZXZhdGlvbiBkYXRhc2V0cyB3aXRoIHZlcnRpY2FsIHVuaXRzIGluIG1ldGVycy4gSWYgeW91ciBlbGV2YXRpb24gdXNlcyBvdGhlciB2ZXJ0aWNhbCB1bml0cywgZW50ZXIgYSA8c3Ryb25nPlogRmFjdG9yPC9zdHJvbmc+IHRvIHJlc2NhbGUgdG8gbWV0ZXJzLiBGb3IgZXhhbXBsZSwgaWYgeW91ciBlbGV2YXRpb24gdW5pdHMgYXJlIGluIGZlZXQsIHlvdSB3b3VsZCB1c2UgYSB2YWx1ZSBvZiAwLjMwNDggdG8gY29udmVydCB5b3VyIGVsZXZhdGlvbiB1bml0cyBmcm9tIGZlZXQgdG8gbWV0ZXJzLlwiLFxuXHRcIkBAR2VvbWV0cmljX1otT2Zmc2V0X3RhZzBAQFwiOiBcIlRoZSBiYXNlIHZhbHVlIHRvIGJlIGFkZGVkIHRvIHRoZSBlbGV2YXRpb24gdmFsdWUgaW4gdGhlIERFTS4gVGhpcyBjb3VsZCBiZSB1c2VkIHRvIG9mZnNldCBlbGV2YXRpb24gdmFsdWVzIHRoYXQgZG8gbm90IHN0YXJ0IGF0IHNlYSBsZXZlbC5cIixcblx0XCJAQEdlb21ldHJpY19Ub2xlcmFuY2VfdGFnMEBAXCI6IFwiU3BlY2lmeSB0aGUgbWF4aW11bSB0b2xlcmFibGUgZXJyb3IgaW4gdGhlIGdlb21ldHJpYyBmdW5jdGlvbiwgZ2l2ZW4gaW4gbnVtYmVyIG9mIHBpeGVscy4gVGhlIGRlZmF1bHQgZm9yIHRoZSBOSVRGIChOQ0RSRCkgcmFzdGVyIHR5cGUgaXMgdHdvLlwiLFxuXHRcIkBAR3JheXNjYWxlX1Jhc3Rlcl90YWcwQEBcIjogXCJUaGUgaW5wdXQgcmFzdGVyLlwiLFxuXHRcIkBAR3JheXNjYWxlX0NvbnZlcnNpb24tUGFyYW1ldGVyc190YWcwQEBcIjogXCJUaGUgd2VpZ2h0cyBmb3IgZWFjaCBvZiB0aGUgYmFuZHMgY29tcHJpc2luZyB0aGUgaW5wdXQgcmFzdGVyLlwiLFxuXHRcIkBAR3JlYXRlci1UaGFuX0NlbGxzaXplLVR5cGVfdGFnMEBAXCI6IFwiQ2hvb3NlIHdoaWNoIGNlbGwgc2l6ZSB0byB1c2UgaW4gdGhlIG91dHB1dCByYXN0ZXIuIElmIGFsbCB0aGUgaW5wdXQgY2VsbCBzaXplcyBhcmUgdGhlIHNhbWUsIGFsbCB0aGUgb3B0aW9ucyB3aWxsIHlpZWxkIHRoZSBzYW1lIHJlc3VsdHMuXCIsXG5cdFwiQEBHcmVhdGVyLVRoYW5fQ2VsbHNpemUtVHlwZV90YWcxQEBcIjogXCJGaXJzdCBPZi0tVXNlIHRoZSBmaXJzdCBjZWxsIHNpemUgb2YgdGhlIGlucHV0IHJhc3RlcnMuXCIsXG5cdFwiQEBHcmVhdGVyLVRoYW5fQ2VsbHNpemUtVHlwZV90YWcyQEBcIjogXCJMYXN0IE9mLS1Vc2UgdGhlIGxhc3QgY2VsbCBzaXplIG9mIHRoZSBpbnB1dCByYXN0ZXJzLlwiLFxuXHRcIkBAR3JlYXRlci1UaGFuX0NlbGxzaXplLVR5cGVfdGFnM0BAXCI6IFwiTWF4IE9mLS1Vc2UgdGhlIGxhcmdlc3QgY2VsbCBzaXplIG9mIGFsbCB0aGUgaW5wdXQgcmFzdGVycy4gVGhpcyBpcyB0aGUgZGVmYXVsdC5cIixcblx0XCJAQEdyZWF0ZXItVGhhbl9DZWxsc2l6ZS1UeXBlX3RhZzRAQFwiOiBcIk1lYW4gT2YtLVVzZSB0aGUgbWVhbiBjZWxsIHNpemUgb2YgYWxsIHRoZSBpbnB1dCByYXN0ZXJzLlwiLFxuXHRcIkBAR3JlYXRlci1UaGFuX0NlbGxzaXplLVR5cGVfdGFnNUBAXCI6IFwiTWluIE9mLS1Vc2UgdGhlIHNtYWxsZXN0IGNlbGwgc2l6ZSBvZiBhbGwgdGhlIGlucHV0IHJhc3RlcnMuXCIsXG5cdFwiQEBHcmVhdGVyLVRoYW5fRXh0ZW50LVR5cGVfdGFnMEBAXCI6IFwiQ2hvb3NlIHdoaWNoIGV4dGVudCBzaG91bGQgYmUgdXNlZCBpbiB0aGUgb3V0cHV0IHJhc3RlcjpcIixcblx0XCJAQEdyZWF0ZXItVGhhbl9FeHRlbnQtVHlwZV90YWcxQEBcIjogXCJGaXJzdCBPZi0tVXNlIHRoZSBleHRlbnQgb2YgdGhlIGZpcnN0IGlucHV0IHJhc3RlciB0byBkZXRlcm1pbmUgdGhlIHByb2Nlc3NpbmcgZXh0ZW50LlwiLFxuXHRcIkBAR3JlYXRlci1UaGFuX0V4dGVudC1UeXBlX3RhZzJAQFwiOiBcIkludGVyc2VjdGlvbiBPZi0tVXNlIHRoZSBleHRlbnQgb2YgdGhlIG92ZXJsYXBwaW5nIHBpeGVscyB0byBkZXRlcm1pbmUgdGhlIHByb2Nlc3NpbmcgZXh0ZW50LiBUaGlzIGlzIHRoZSBkZWZhdWx0LlwiLFxuXHRcIkBAR3JlYXRlci1UaGFuX0V4dGVudC1UeXBlX3RhZzNAQFwiOiBcIkxhc3QgT2YtLVVzZSB0aGUgZXh0ZW50IG9mIHRoZSBsYXN0IGlucHV0IHJhc3RlciB0byBkZXRlcm1pbmUgdGhlIHByb2Nlc3NpbmcgZXh0ZW50LlwiLFxuXHRcIkBAR3JlYXRlci1UaGFuX0V4dGVudC1UeXBlX3RhZzRAQFwiOiBcIlVuaW9uIE9mLS1Vc2UgdGhlIGV4dGVudCBvZiBhbGwgdGhlIHJhc3RlcnMgdG8gZGV0ZXJtaW5lIHRoZSBwcm9jZXNzaW5nIGV4dGVudC5cIixcblx0XCJAQEdyZWF0ZXItVGhhbl9SYXN0ZXJfdGFnMEBAXCI6IFwiVGhlIGlucHV0IGJlaW5nIHRlc3RlZCB0byBkZXRlcm1pbmUgaWYgaXQgaXMgZ3JlYXRlciB0aGFuIHRoZSBzZWNvbmQgaW5wdXQuXCIsXG5cdFwiQEBHcmVhdGVyLVRoYW5fUmFzdGVyX3RhZzFAQFwiOiBcIkEgY29uc3RhbnQgdmFsdWUgY2FuIGJlIHVzZWQgYXMgYW4gaW5wdXQgZm9yIHRoaXMgcGFyYW1ldGVyLCBwcm92aWRlZCBhIHJhc3RlciBpcyBzcGVjaWZpZWQgZm9yIHRoZSBvdGhlciBwYXJhbWV0ZXIuXCIsXG5cdFwiQEBHcmVhdGVyLVRoYW5fUmFzdGVyMl90YWcwQEBcIjogXCJUaGUgaW5wdXQgYWdhaW5zdCB3aGljaCB0aGUgZmlyc3QgaW5wdXQgaXMgdGVzdGVkIHRvIGJlIGdyZWF0ZXIgdGhhbi5cIixcblx0XCJAQEdyZWF0ZXItVGhhbl9SYXN0ZXIyX3RhZzFAQFwiOiBcIkEgY29uc3RhbnQgdmFsdWUgY2FuIGJlIHVzZWQgYXMgYW4gaW5wdXQgZm9yIHRoaXMgcGFyYW1ldGVyLCBwcm92aWRlZCBhIHJhc3RlciBpcyBzcGVjaWZpZWQgZm9yIHRoZSBvdGhlciBwYXJhbWV0ZXIuXCIsXG5cdFwiQEBHcmVhdGVyLVRoYW4tRXF1YWxfQ2VsbHNpemUtVHlwZV90YWcwQEBcIjogXCJDaG9vc2Ugd2hpY2ggY2VsbCBzaXplIHRvIHVzZSBpbiB0aGUgb3V0cHV0IHJhc3Rlci4gSWYgYWxsIHRoZSBpbnB1dCBjZWxsIHNpemVzIGFyZSB0aGUgc2FtZSwgYWxsIHRoZSBvcHRpb25zIHdpbGwgeWllbGQgdGhlIHNhbWUgcmVzdWx0cy5cIixcblx0XCJAQEdyZWF0ZXItVGhhbi1FcXVhbF9DZWxsc2l6ZS1UeXBlX3RhZzFAQFwiOiBcIkZpcnN0IE9mLS1Vc2UgdGhlIGZpcnN0IGNlbGwgc2l6ZSBvZiB0aGUgaW5wdXQgcmFzdGVycy5cIixcblx0XCJAQEdyZWF0ZXItVGhhbi1FcXVhbF9DZWxsc2l6ZS1UeXBlX3RhZzJAQFwiOiBcIkxhc3QgT2YtLVVzZSB0aGUgbGFzdCBjZWxsIHNpemUgb2YgdGhlIGlucHV0IHJhc3RlcnMuXCIsXG5cdFwiQEBHcmVhdGVyLVRoYW4tRXF1YWxfQ2VsbHNpemUtVHlwZV90YWczQEBcIjogXCJNYXggT2YtLVVzZSB0aGUgbGFyZ2VzdCBjZWxsIHNpemUgb2YgYWxsIHRoZSBpbnB1dCByYXN0ZXJzLiBUaGlzIGlzIHRoZSBkZWZhdWx0LlwiLFxuXHRcIkBAR3JlYXRlci1UaGFuLUVxdWFsX0NlbGxzaXplLVR5cGVfdGFnNEBAXCI6IFwiTWVhbiBPZi0tVXNlIHRoZSBtZWFuIGNlbGwgc2l6ZSBvZiBhbGwgdGhlIGlucHV0IHJhc3RlcnMuXCIsXG5cdFwiQEBHcmVhdGVyLVRoYW4tRXF1YWxfQ2VsbHNpemUtVHlwZV90YWc1QEBcIjogXCJNaW4gT2YtLVVzZSB0aGUgc21hbGxlc3QgY2VsbCBzaXplIG9mIGFsbCB0aGUgaW5wdXQgcmFzdGVycy5cIixcblx0XCJAQEdyZWF0ZXItVGhhbi1FcXVhbF9FeHRlbnQtVHlwZV90YWcwQEBcIjogXCJDaG9vc2Ugd2hpY2ggZXh0ZW50IHNob3VsZCBiZSB1c2VkIGluIHRoZSBvdXRwdXQgcmFzdGVyOlwiLFxuXHRcIkBAR3JlYXRlci1UaGFuLUVxdWFsX0V4dGVudC1UeXBlX3RhZzFAQFwiOiBcIkZpcnN0IE9mLS1Vc2UgdGhlIGV4dGVudCBvZiB0aGUgZmlyc3QgaW5wdXQgcmFzdGVyIHRvIGRldGVybWluZSB0aGUgcHJvY2Vzc2luZyBleHRlbnQuXCIsXG5cdFwiQEBHcmVhdGVyLVRoYW4tRXF1YWxfRXh0ZW50LVR5cGVfdGFnMkBAXCI6IFwiSW50ZXJzZWN0aW9uIE9mLS1Vc2UgdGhlIGV4dGVudCBvZiB0aGUgb3ZlcmxhcHBpbmcgcGl4ZWxzIHRvIGRldGVybWluZSB0aGUgcHJvY2Vzc2luZyBleHRlbnQuIFRoaXMgaXMgdGhlIGRlZmF1bHQuXCIsXG5cdFwiQEBHcmVhdGVyLVRoYW4tRXF1YWxfRXh0ZW50LVR5cGVfdGFnM0BAXCI6IFwiTGFzdCBPZi0tVXNlIHRoZSBleHRlbnQgb2YgdGhlIGxhc3QgaW5wdXQgcmFzdGVyIHRvIGRldGVybWluZSB0aGUgcHJvY2Vzc2luZyBleHRlbnQuXCIsXG5cdFwiQEBHcmVhdGVyLVRoYW4tRXF1YWxfRXh0ZW50LVR5cGVfdGFnNEBAXCI6IFwiVW5pb24gT2YtLVVzZSB0aGUgZXh0ZW50IG9mIGFsbCB0aGUgcmFzdGVycyB0byBkZXRlcm1pbmUgdGhlIHByb2Nlc3NpbmcgZXh0ZW50LlwiLFxuXHRcIkBAR3JlYXRlci1UaGFuLUVxdWFsX1Jhc3Rlcl90YWcwQEBcIjogXCJUaGUgaW5wdXQgYmVpbmcgdGVzdGVkIHRvIGRldGVybWluZSBpZiBpdCBpcyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gdGhlIHNlY29uZCBpbnB1dC5cIixcblx0XCJAQEdyZWF0ZXItVGhhbi1FcXVhbF9SYXN0ZXJfdGFnMUBAXCI6IFwiQSBjb25zdGFudCB2YWx1ZSBjYW4gYmUgdXNlZCBhcyBhbiBpbnB1dCBmb3IgdGhpcyBwYXJhbWV0ZXIsIHByb3ZpZGVkIGEgcmFzdGVyIGlzIHNwZWNpZmllZCBmb3IgdGhlIG90aGVyIHBhcmFtZXRlci5cIixcblx0XCJAQEdyZWF0ZXItVGhhbi1FcXVhbF9SYXN0ZXIyX3RhZzBAQFwiOiBcIlRoZSBpbnB1dCBhZ2FpbnN0IHdoaWNoIHRoZSBmaXJzdCBpbnB1dCBpcyB0ZXN0ZWQgdG8gYmUgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvLlwiLFxuXHRcIkBAR3JlYXRlci1UaGFuLUVxdWFsX1Jhc3RlcjJfdGFnMUBAXCI6IFwiQSBjb25zdGFudCB2YWx1ZSBjYW4gYmUgdXNlZCBhcyBhbiBpbnB1dCBmb3IgdGhpcyBwYXJhbWV0ZXIsIHByb3ZpZGVkIGEgcmFzdGVyIGlzIHNwZWNpZmllZCBmb3IgdGhlIG90aGVyIHBhcmFtZXRlci5cIixcblx0XCJAQEhlYXQtSW5kZXhfSGVhdC1JbmRleC1Vbml0c190YWcwQEBcIjogXCJUaGUgdW5pdCBvZiBtZWFzdXJlbWVudCBhc3NvY2lhdGVkIHdpdGggdGhlIG91dHB1dCByYXN0ZXIuIEF2YWlsYWJsZSBvdXRwdXQgdW5pdHMgYXJlIENlbHNpdXMsIEZhaHJlbmhlaXQsIGFuZCBLZWx2aW4uXCIsXG5cdFwiQEBIZWF0LUluZGV4X1JlbGF0aXZlLUh1bWlkaXR5LVJhc3Rlcl90YWcwQEBcIjogXCJBIHNpbmdsZS1iYW5kIHJhc3RlciB3aGVyZSBwaXhlbCB2YWx1ZXMgcmVwcmVzZW50IHJlbGF0aXZlIGh1bWlkaXR5IGFzIGEgcGVyY2VudGFnZSB2YWx1ZSBiZXR3ZWVuIDAgYW5kIDEwMC5cIixcblx0XCJAQEhlYXQtSW5kZXhfVGVtcGVyYXR1cmUtUmFzdGVyX3RhZzBAQFwiOiBcIkEgc2luZ2xlLWJhbmQgcmFzdGVyIHdoZXJlIHBpeGVsIHZhbHVlcyByZXByZXNlbnQgYW1iaWVudCBhaXIgdGVtcGVyYXR1cmUuXCIsXG5cdFwiQEBIZWF0LUluZGV4X1RlbXBlcmF0dXJlLVVuaXRzX3RhZzBAQFwiOiBcIlRoZSB1bml0IG9mIG1lYXN1cmVtZW50IGFzc29jaWF0ZWQgd2l0aCB0aGUgaW5wdXQgdGVtcGVyYXR1cmUgcmFzdGVyLiBBdmFpbGFibGUgaW5wdXQgdW5pdHMgYXJlIENlbHNpdXMsIEZhaHJlbmhlaXQsIGFuZCBLZWx2aW4uXCIsXG5cdFwiQEBIaWxsc2hhZGVfQWx0aXR1ZGVfdGFnMEBAXCI6IFwiQWx0aXR1ZGUgaXMgdGhlIHN1bidzIGFuZ2xlIG9mIGVsZXZhdGlvbiBhYm92ZSB0aGUgaG9yaXpvbiBhbmQgcmFuZ2VzIGZyb20gMCB0byA5MCBkZWdyZWVzLiBBIHZhbHVlIG9mIDAgZGVncmVlcyBpbmRpY2F0ZXMgdGhhdCB0aGUgc3VuIGlzIG9uIHRoZSBob3Jpem9uLCB0aGF0IGlzLCBvbiB0aGUgc2FtZSBob3Jpem9udGFsIHBsYW5lIGFzIHRoZSBmcmFtZSBvZiByZWZlcmVuY2UuIEEgdmFsdWUgb2YgOTAgZGVncmVlcyBpbmRpY2F0ZXMgdGhhdCB0aGUgc3VuIGlzIGRpcmVjdGx5IG92ZXJoZWFkLlwiLFxuXHRcIkBASGlsbHNoYWRlX0FsdGl0dWRlX3RhZzFAQFwiOiBcIlRoaXMgcGFyYW1ldGVyIGlzIG9ubHkgdmFsaWQgd2hlbiA8c3Ryb25nPkhpbGxzaGFkZSBUeXBlPC9zdHJvbmc+IGlzIDxzdHJvbmc+VHJhZGl0aW9uYWw8L3N0cm9uZz4gLiBUaGUgZGVmYXVsdCBpcyA0NSBkZWdyZWVzIGFib3ZlIHRoZSBob3Jpem9uLlwiLFxuXHRcIkBASGlsbHNoYWRlX0F6aW11dGhfdGFnMEBAXCI6IFwiQXppbXV0aCBpcyB0aGUgc3VuJ3MgcmVsYXRpdmUgcG9zaXRpb24gYWxvbmcgdGhlIGhvcml6b24gKGluIGRlZ3JlZXMpLiBUaGlzIHBvc2l0aW9uIGlzIGluZGljYXRlZCBieSB0aGUgYW5nbGUgb2YgdGhlIHN1biBtZWFzdXJlZCBjbG9ja3dpc2UgZnJvbSBkdWUgbm9ydGguIEFuIGF6aW11dGggb2YgMCBkZWdyZWVzIGluZGljYXRlcyBub3J0aCwgZWFzdCBpcyA5MCBkZWdyZWVzLCBzb3V0aCBpcyAxODAgZGVncmVlcywgYW5kIHdlc3QgaXMgMjcwIGRlZ3JlZXMuXCIsXG5cdFwiQEBIaWxsc2hhZGVfQXppbXV0aF90YWcxQEBcIjogXCJUaGlzIHBhcmFtZXRlciBpcyBvbmx5IHZhbGlkIHdoZW4gPHN0cm9uZz5IaWxsc2hhZGUgVHlwZTwvc3Ryb25nPiBpcyA8c3Ryb25nPlRyYWRpdGlvbmFsPC9zdHJvbmc+IC4gVGhlIGRlZmF1bHQgaXMgMzE1IGRlZ3JlZXMsIHdoaWNoIGlzIGZyb20gdGhlIG5vcnRod2VzdC5cIixcblx0XCJAQEhpbGxzaGFkZV9EaXNhYmxlLWRlZmF1bHQtZWRnZS1waXhlbC1pbnRlcnBvbGF0aW9uX3RhZzBAQFwiOiBcIlVzaW5nIHRoaXMgb3B0aW9uIGF2b2lkcyBhbnkgcmVzYW1wbGluZyBhcnRpZmFjdHMgdGhhdCBtYXkgb2NjdXIgYWxvbmcgdGhlIGVkZ2VzIG9mIGEgcmFzdGVyLiBUaGUgb3V0cHV0IHBpeGVscyBhbG9uZyB0aGUgZWRnZSBvZiBhIHJhc3RlciBvciBiZXNpZGUgTm9EYXRhIHBpeGVscyB3aWxsIGJlIHBvcHVsYXRlZCB3aXRoIE5vRGF0YTsgdGhlcmVmb3JlLCBpdCBpcyByZWNvbW1lbmRlZCB0aGF0IHRoaXMgcGFyYW1ldGVyIGlzIG9ubHkgdXNlZCB3aXRoIGVsZXZhdGlvbiBtb3NhaWMgZGF0YXNldHMgdGhhdCBoYXZlIG92ZXJsYXAuIFdoZW4gb3ZlcmxhcHBpbmcgcGl4ZWxzIGFyZSBhdmFpbGFibGUsIHRoZSBhcmVhcyBvZiBOb0RhdGEgd2lsbCBkaXNwbGF5IHRoZSBvdmVybGFwcGluZyBwaXhlbCB2YWx1ZXMgaW5zdGVhZCBvZiBibGFuayBwaXhlbHMuXCIsXG5cdFwiQEBIaWxsc2hhZGVfRGlzYWJsZS1kZWZhdWx0LWVkZ2UtcGl4ZWwtaW50ZXJwb2xhdGlvbl90YWcxQEBcIjogXCJVbmNoZWNrZWQtLUJpbGluZWFyIHJlc2FtcGxpbmcgd2lsbCBiZSBhcHBsaWVkIHVuaWZvcm1seSB0byByZXNhbXBsZSB5b3VyIGhpbGxzaGFkZS4gVXNlIHRoaXMgb3B0aW9uIHdoZW4gdGhlIG1vc2FpYyBkYXRhc2V0IGNvbnRhaW5pbmcgeW91ciBlbGV2YXRpb24gcmFzdGVyIGRhdGEgaXMgYnV0dCBqb2luZWQuIFRoaXMgaXMgdGhlIGRlZmF1bHQuXCIsXG5cdFwiQEBIaWxsc2hhZGVfRGlzYWJsZS1kZWZhdWx0LWVkZ2UtcGl4ZWwtaW50ZXJwb2xhdGlvbl90YWcyQEBcIjogXCJDaGVja2VkLS1CaWxpbmVhciByZXNhbXBsaW5nIHdpbGwgYmUgdXNlZCB3aXRoaW4gdGhlIGhpbGxzaGFkZSBleGNlcHQgYWxvbmcgdGhlIGVkZ2VzIG9mIHRoZSByYXN0ZXJzIG9yIGJlc2lkZSBwaXhlbHMgb2YgTm9EYXRhLiBUaGVzZSBwaXhlbHMgd2lsbCBiZSBwb3B1bGF0ZWQgd2l0aCBOb0RhdGEgYW5kIGRpc3BsYXkgdGhlIG92ZXJsYXBwaW5nIHBpeGVsIHZhbHVlcywgdGhlcmVieSByZWR1Y2luZyBhbnkgc2hhcnAgZWRnZSBlZmZlY3RzIHRoYXQgbWF5IG90aGVyd2lzZSBvY2N1ci4gVXNlIHRoaXMgb3B0aW9uIHdoZW4gdGhlIG1vc2FpYyBkYXRhc2V0IGNvbnRhaW5pbmcgeW91ciBlbGV2YXRpb24gcmFzdGVyIGRhdGEgY29uc2lzdHMgb2Ygb3ZlcmxhcHBpbmcgaXRlbXMgb3IgdGlsZXMuXCIsXG5cdFwiQEBIaWxsc2hhZGVfRGlzYWJsZS1kZWZhdWx0LWVkZ2UtcGl4ZWwtaW50ZXJwb2xhdGlvbl90YWczQEBcIjogXCJUaGUgcmVzdWx0cyBmcm9tIHRoZSBmdW5jdGlvbiBjYW4gYmUgZGF0YSBkZXBlbmRlbnQuIElmIHlvdSBvYnNlcnZlIHRpbGUgYm91bmRhcnkgYXJ0aWZhY3RzIGluIHlvdXIgb3V0cHV0LCBzZWxlY3QgdGhlIGFsdGVybmF0ZSBjb25kaXRpb24gb2YgdGhlIGNoZWNrIGJveC5cIixcblx0XCJAQEhpbGxzaGFkZV9IaWxsc2hhZGUtVHlwZV90YWcwQEBcIjogXCJDb250cm9scyB0aGUgaWxsdW1pbmF0aW9uIHNvdXJjZSBmb3IgdGhlIGhpbGxzaGFkZTpcIixcblx0XCJAQEhpbGxzaGFkZV9IaWxsc2hhZGUtVHlwZV90YWcxQEBcIjogXCJUcmFkaXRpb25hbC0tQ2FsY3VsYXRlcyBoaWxsc2hhZGUgZnJvbSBhIHNpbmdsZSBpbGx1bWluYXRpb24gZGlyZWN0aW9uLiBUaGlzIGlzIHRoZSBkZWZhdWx0LiBZb3UgY2FuIHNldCB0aGUgPHN0cm9uZz5BemltdXRoPC9zdHJvbmc+IGFuZCA8c3Ryb25nPkFsdGl0dWRlPC9zdHJvbmc+IHRvIGNvbnRyb2wgdGhlIGxvY2F0aW9uIG9mIHRoZSBsaWdodCBzb3VyY2UuXCIsXG5cdFwiQEBIaWxsc2hhZGVfSGlsbHNoYWRlLVR5cGVfdGFnNkBAXCI6IFwiTXVsdGlkaXJlY3Rpb25hbC0tQ29tYmluZXMgbGlnaHQgZnJvbSBtdWx0aXBsZSBzb3VyY2VzIHRvIHJlcHJlc2VudCBhbiBlbmhhbmNlZCB2aXN1YWxpemF0aW9uIG9mIHRoZSB0ZXJyYWluLlwiLFxuXHRcIkBASGlsbHNoYWRlX1BpeGVsLVNpemUtRmFjdG9yX3RhZzBAQFwiOiBcIlBpeGVsIFNpemUgRmFjdG9yIGFjY291bnRzIGZvciBjaGFuZ2VzIGluIHNjYWxlIGFzIHRoZSB2aWV3ZXIgem9vbXMgaW4gYW5kIG91dCBvbiB0aGUgbWFwIGRpc3BsYXkuIEl0IGNvbnRyb2xzIHRoZSByYXRlIGF0IHdoaWNoIHRoZSA8c3Ryb25nPlogRmFjdG9yPC9zdHJvbmc+IGNoYW5nZXMuXCIsXG5cdFwiQEBIaWxsc2hhZGVfUGl4ZWwtU2l6ZS1GYWN0b3JfdGFnM0BAXCI6IFwiVGhpcyBwYXJhbWV0ZXIgaXMgb25seSB2YWxpZCB3aGVuIHRoZSA8c3Ryb25nPlNjYWxpbmc8L3N0cm9uZz4gdHlwZSBpcyA8c3Ryb25nPkFkanVzdGVkPC9zdHJvbmc+LiBUaGUgZGVmYXVsdCB2YWx1ZSBpcyAwLjAyNC5cIixcblx0XCJAQEhpbGxzaGFkZV9QaXhlbC1TaXplLVBvd2VyX3RhZzBAQFwiOiBcIlBpeGVsIFNpemUgUG93ZXIgYWNjb3VudHMgZm9yIHRoZSBhbHRpdHVkZSBjaGFuZ2VzIChvciBzY2FsZSkgYXMgdGhlIHZpZXdlciB6b29tcyBpbiBhbmQgb3V0IG9uIHRoZSBtYXAgZGlzcGxheS4gSXQgaXMgdGhlIGV4cG9uZW50IGFwcGxpZWQgdG8gdGhlIHBpeGVsIHNpemUgdGVybSBpbiB0aGUgZXF1YXRpb24gdGhhdCBjb250cm9scyB0aGUgcmF0ZSBhdCB3aGljaCB0aGUgPHN0cm9uZz5aIEZhY3Rvcjwvc3Ryb25nPiBjaGFuZ2VzIHRvIGF2b2lkIHNpZ25pZmljYW50IGxvc3Mgb2YgcmVsaWVmLlwiLFxuXHRcIkBASGlsbHNoYWRlX1BpeGVsLVNpemUtUG93ZXJfdGFnM0BAXCI6IFwiVGhpcyBwYXJhbWV0ZXIgaXMgb25seSB2YWxpZCB3aGVuIHRoZSA8c3Ryb25nPlNjYWxpbmc8L3N0cm9uZz4gdHlwZSBpcyA8c3Ryb25nPkFkanVzdGVkPC9zdHJvbmc+LiBUaGUgZGVmYXVsdCB2YWx1ZSBpcyAwLjY2NC5cIixcblx0XCJAQEhpbGxzaGFkZV9SYXN0ZXJfdGFnMEBAXCI6IFwiVGhlIGlucHV0IGVsZXZhdGlvbiBkYXRhc2V0LlwiLFxuXHRcIkBASGlsbHNoYWRlX1NjYWxpbmdfdGFnMEBAXCI6IFwiVGhlIHNoYWRlZCByZXN1bHQgaXMgc2NhbGVkIGR5bmFtaWNhbGx5IGJ5IGFkanVzdGluZyB0aGUgei1mYWN0b3IgdXNpbmcgb25lIG9mIHR3byBvcHRpb25zOlwiLFxuXHRcIkBASGlsbHNoYWRlX1NjYWxpbmdfdGFnMUBAXCI6IFwiQWRqdXN0ZWQtLVRoaXMgYXBwbGllcyBhIG5vbmxpbmVhciBhZGp1c3RtZW50IHVzaW5nIHRoZSBkZWZhdWx0IDxzdHJvbmc+UGl4ZWwgU2l6ZSBQb3dlcjwvc3Ryb25nPiBhbmQgPHN0cm9uZz5QaXhlbCBTaXplIEZhY3Rvcjwvc3Ryb25nPiB2YWx1ZXMsIHdoaWNoIGFjY29tbW9kYXRlIGEgd2lkZSB2YXJpZXR5IG9mIGFsdGl0dWRlIGNoYW5nZXMgKHNjYWxlKSBhcyB0aGUgdmlld2VyIHpvb21zIGluIGFuZCBvdXQuIFRoZSA8c3Ryb25nPkFkanVzdGVkPC9zdHJvbmc+IHBhcmFtZXRlciBzZXR0aW5nIGlzIHJlY29tbWVuZGVkIHdoZW4gdXNpbmcgYSB3b3JsZHdpZGUgZGF0YXNldC5cIixcblx0XCJAQEhpbGxzaGFkZV9TY2FsaW5nX3RhZzhAQFwiOiBcIk5vbmUtLU5vIHNjYWxpbmcgaXMgYXBwbGllZC4gVGhpcyBpcyBpZGVhbCBmb3IgYSBzaW5nbGUgcmFzdGVyIGRhdGFzZXQgY292ZXJpbmcgYSBsb2NhbCBhcmVhLiBUaGlzIGlzIG5vdCByZWNvbW1lbmRlZCBmb3Igd29ybGR3aWRlIGRhdGFzZXRzIHdpdGggbGFyZ2UgdmFyaWF0aW9ucyBpbiBlbGV2YXRpb24gb3IgbXVsdGlzY2FsZSBtYXBzIGFzIGl0IHdpbGwgcHJvZHVjZSB0ZXJyYWluIHJlbGllZiB3aXRoIGxpdHRsZSB2YXJpYXRpb24gYXQgc21hbGwgc2NhbGVzLlwiLFxuXHRcIkBASGlsbHNoYWRlX1otRmFjdG9yX3RhZzBAQFwiOiBcIlRoZSB6LWZhY3RvciBpcyBhIHNjYWxpbmcgZmFjdG9yIHVzZWQgdG8gY29udmVydCB0aGUgZWxldmF0aW9uIHZhbHVlcyBmb3IgdHdvIHB1cnBvc2VzOlwiLFxuXHRcIkBASGlsbHNoYWRlX1otRmFjdG9yX3RhZzFAQFwiOiBcIkNvbnZlcnQgdGhlIGVsZXZhdGlvbiB1bml0cyAoc3VjaCBhcyBtZXRlcnMgb3IgZmVldCkgdG8gdGhlIGhvcml6b250YWwgY29vcmRpbmF0ZSB1bml0cyBvZiB0aGUgZGF0YXNldCwgd2hpY2ggbWF5IGJlIGZlZXQsIG1ldGVycywgb3IgZGVncmVlcy5cIixcblx0XCJAQEhpbGxzaGFkZV9aLUZhY3Rvcl90YWcyQEBcIjogXCJBZGQgdmVydGljYWwgZXhhZ2dlcmF0aW9uIGZvciB2aXN1YWwgZWZmZWN0LlwiLFxuXHRcIkBASW50X0NlbGxzaXplLVR5cGVfdGFnMEBAXCI6IFwiQ2hvb3NlIHdoaWNoIGNlbGwgc2l6ZSB0byB1c2UgaW4gdGhlIG91dHB1dCByYXN0ZXIuIElmIGFsbCB0aGUgaW5wdXQgY2VsbCBzaXplcyBhcmUgdGhlIHNhbWUsIGFsbCB0aGUgb3B0aW9ucyB3aWxsIHlpZWxkIHRoZSBzYW1lIHJlc3VsdHMuXCIsXG5cdFwiQEBJbnRfQ2VsbHNpemUtVHlwZV90YWcxQEBcIjogXCJGaXJzdCBPZi0tVXNlIHRoZSBmaXJzdCBjZWxsIHNpemUgb2YgdGhlIGlucHV0IHJhc3RlcnMuXCIsXG5cdFwiQEBJbnRfQ2VsbHNpemUtVHlwZV90YWcyQEBcIjogXCJMYXN0IE9mLS1Vc2UgdGhlIGxhc3QgY2VsbCBzaXplIG9mIHRoZSBpbnB1dCByYXN0ZXJzLlwiLFxuXHRcIkBASW50X0NlbGxzaXplLVR5cGVfdGFnM0BAXCI6IFwiTWF4IE9mLS1Vc2UgdGhlIGxhcmdlc3QgY2VsbCBzaXplIG9mIGFsbCB0aGUgaW5wdXQgcmFzdGVycy4gVGhpcyBpcyB0aGUgZGVmYXVsdC5cIixcblx0XCJAQEludF9DZWxsc2l6ZS1UeXBlX3RhZzRAQFwiOiBcIk1lYW4gT2YtLVVzZSB0aGUgbWVhbiBjZWxsIHNpemUgb2YgYWxsIHRoZSBpbnB1dCByYXN0ZXJzLlwiLFxuXHRcIkBASW50X0NlbGxzaXplLVR5cGVfdGFnNUBAXCI6IFwiTWluIE9mLS1Vc2UgdGhlIHNtYWxsZXN0IGNlbGwgc2l6ZSBvZiBhbGwgdGhlIGlucHV0IHJhc3RlcnMuXCIsXG5cdFwiQEBJbnRfRXh0ZW50LVR5cGVfdGFnMEBAXCI6IFwiQ2hvb3NlIHdoaWNoIGV4dGVudCBzaG91bGQgYmUgdXNlZCBpbiB0aGUgb3V0cHV0IHJhc3RlcjpcIixcblx0XCJAQEludF9FeHRlbnQtVHlwZV90YWcxQEBcIjogXCJGaXJzdCBPZi0tVXNlIHRoZSBleHRlbnQgb2YgdGhlIGZpcnN0IGlucHV0IHJhc3RlciB0byBkZXRlcm1pbmUgdGhlIHByb2Nlc3NpbmcgZXh0ZW50LlwiLFxuXHRcIkBASW50X0V4dGVudC1UeXBlX3RhZzJAQFwiOiBcIkludGVyc2VjdGlvbiBPZi0tVXNlIHRoZSBleHRlbnQgb2YgdGhlIG92ZXJsYXBwaW5nIHBpeGVscyB0byBkZXRlcm1pbmUgdGhlIHByb2Nlc3NpbmcgZXh0ZW50LiBUaGlzIGlzIHRoZSBkZWZhdWx0LlwiLFxuXHRcIkBASW50X0V4dGVudC1UeXBlX3RhZzNAQFwiOiBcIkxhc3QgT2YtLVVzZSB0aGUgZXh0ZW50IG9mIHRoZSBsYXN0IGlucHV0IHJhc3RlciB0byBkZXRlcm1pbmUgdGhlIHByb2Nlc3NpbmcgZXh0ZW50LlwiLFxuXHRcIkBASW50X0V4dGVudC1UeXBlX3RhZzRAQFwiOiBcIlVuaW9uIE9mLS1Vc2UgdGhlIGV4dGVudCBvZiBhbGwgdGhlIHJhc3RlcnMgdG8gZGV0ZXJtaW5lIHRoZSBwcm9jZXNzaW5nIGV4dGVudC5cIixcblx0XCJAQEludF9SYXN0ZXJfdGFnMEBAXCI6IFwiVGhlIGlucHV0IHJhc3RlciB0byBiZSBjb252ZXJ0ZWQgdG8gaW50ZWdlci5cIixcblx0XCJAQEludGVycG9sYXRlLUlycmVndWxhci1EYXRhX0NlbGxzaXplX3RhZzBAQFwiOiBcIlRoZSBjZWxsIHNpemUgZm9yIHRoZSBvdXRwdXQgcmFzdGVyIHdpbGwgYmUgYXV0b21hdGljYWxseSBkZXRlY3RlZDsgaG93ZXZlciwgeW91IGNhbiBjaGFuZ2UgdGhpcy4gV2hpbGUgdGhlIGNlbGwgc2l6ZSBjYW4gYmUgY2hhbmdlZCwgdGhlIGV4dGVudCBvZiB0aGUgcmFzdGVyIGRhdGFzZXQgd2lsbCByZW1haW4gdGhlIHNhbWUuXCIsXG5cdFwiQEBJbnRlcnBvbGF0ZS1JcnJlZ3VsYXItRGF0YV9JbnB1dC1TYW1wbGVzX3RhZzBAQFwiOiBcIlRoZSBpbnB1dCBwb2ludHMgZGF0YS5cIixcblx0XCJAQEludGVycG9sYXRlLUlycmVndWxhci1EYXRhX0ludGVycG9sYXRpb24tTWV0aG9kX3RhZzBAQFwiOiBcIlRoZXJlIGFyZSBmb3VyIHJlc2FtcGxpbmcgbWV0aG9kcyBmb3IgdGhpcyBmdW5jdGlvbjpcIixcblx0XCJAQEludGVycG9sYXRlLUlycmVndWxhci1EYXRhX0ludGVycG9sYXRpb24tTWV0aG9kX3RhZzFAQFwiOiBcIjxzdHJvbmc+SW52ZXJzZSBEaXN0YW5jZSBXZWlnaHRlZDwvc3Ryb25nPi0tRGV0ZXJtaW5lcyBjZWxsIHZhbHVlcyB1c2luZyBhIGxpbmVhcmx5IHdlaWdodGVkIGNvbWJpbmF0aW9uIG9mIGEgc2V0IG9mIHNhbXBsZSBwb2ludHMgb3IgY2VsbHMuIFRoZSB3ZWlnaHQgaXMgYSBmdW5jdGlvbiBvZiB0aGUgaW52ZXJzZSBvZiB0aGUgZGlzdGFuY2UgZnJvbSB0aGUga25vd24gcG9pbnRzIG9yIGNlbGxzLlwiLFxuXHRcIkBASW50ZXJwb2xhdGUtSXJyZWd1bGFyLURhdGFfSW50ZXJwb2xhdGlvbi1NZXRob2RfdGFnM0BAXCI6IFwiPHN0cm9uZz5MaW5lYXIgVGlubmluZzwvc3Ryb25nPi0tVXNlcyBhIHRyaWFuZ3VsYXIgaXJyZWd1bGFyIG5ldHdvcmsgZnJvbSB0aGUgY2VudGVyIHBvaW50cyBvZiBlYWNoIGNlbGwgaW4gdGhlIGlycmVndWxhciByYXN0ZXIgdG8gaW50ZXJwb2xhdGUgYSBzdXJmYWNlIHRoYXQgaXMgdGhlbiBjb252ZXJ0ZWQgdG8gYSByZWd1bGFyIHJhc3Rlci5cIixcblx0XCJAQEludGVycG9sYXRlLUlycmVndWxhci1EYXRhX0ludGVycG9sYXRpb24tTWV0aG9kX3RhZzVAQFwiOiBcIjxzdHJvbmc+TmF0dXJhbCBOZWlnaGJvcjwvc3Ryb25nPi0tRmluZHMgdGhlIGNsb3Nlc3Qgc3Vic2V0IG9mIGlucHV0IHNhbXBsZXMgdG8gYSBxdWVyeSBwb2ludCBhbmQgYXBwbGllcyB3ZWlnaHRzIHRvIHRoZW0gYmFzZWQgb24gcHJvcG9ydGlvbmF0ZSBhcmVhcyB0byBpbnRlcnBvbGF0ZSBhIHZhbHVlLlwiLFxuXHRcIkBASW50ZXJwb2xhdGUtSXJyZWd1bGFyLURhdGFfSW50ZXJwb2xhdGlvbi1NZXRob2RfdGFnN0BAXCI6IFwiPHN0cm9uZz5OZWFyZXN0IE5laWdoYm9yPC9zdHJvbmc+LS1DYWxjdWxhdGVzIHBpeGVsIHZhbHVlIHVzaW5nIHRoZSBuZWFyZXN0IHBpeGVsLiBJZiBubyBzb3VyY2UgcGl4ZWwgZXhpc3RzLCBubyBuZXcgcGl4ZWwgY2FuIGJlIGNyZWF0ZWQgaW4gdGhlIG91dHB1dC4gVGhpcyBpcyB0aGUgZGVmYXVsdC5cIixcblx0XCJAQEludGVycG9sYXRlLUlycmVndWxhci1EYXRhX1NlYXJjaC1SYWRpdXNfdGFnMEBAXCI6IFwiSWRlbnRpZmllcyB0aGUgbnVtYmVyIG9mIHBpeGVscyB0byBiZSBpbmNsdWRlZCBmb3IgdGhlIHNlbGVjdGVkIHJlc2FtcGxpbmcgbWV0aG9kLiBUaGUgZGVmYXVsdCB2YWx1ZSBpcyAkezN9IHBpeGVscy5cIixcblx0XCJAQEludGVycG9sYXRlLUlycmVndWxhci1EYXRhX1ZhbHVlLUZpZWxkX3RhZzBAQFwiOiBcIklmIHlvdSBzZWxlY3QgYSBwb2ludCBmZWF0dXJlIGNsYXNzIGFzIHRoZSBpbnB1dCwgeW91IHdpbGwgbmVlZCB0byBpZGVudGlmeSB0aGUgZmllbGQgaW4gdGhlIGF0dHJpYnV0ZSB0YWJsZSB3aXRoIHRoZSB2YWx1ZSBvZiB0aGUgcG9pbnRzXCIsXG5cdFwiQEBJcy1OdWxsX0NlbGxzaXplLVR5cGVfdGFnMEBAXCI6IFwiQ2hvb3NlIHdoaWNoIGNlbGwgc2l6ZSB0byB1c2UgaW4gdGhlIG91dHB1dCByYXN0ZXIuIElmIGFsbCB0aGUgaW5wdXQgY2VsbCBzaXplcyBhcmUgdGhlIHNhbWUsIGFsbCB0aGUgb3B0aW9ucyB3aWxsIHlpZWxkIHRoZSBzYW1lIHJlc3VsdHMuXCIsXG5cdFwiQEBJcy1OdWxsX0NlbGxzaXplLVR5cGVfdGFnMUBAXCI6IFwiRmlyc3QgT2YtLVVzZSB0aGUgZmlyc3QgY2VsbCBzaXplIG9mIHRoZSBpbnB1dCByYXN0ZXJzLlwiLFxuXHRcIkBASXMtTnVsbF9DZWxsc2l6ZS1UeXBlX3RhZzJAQFwiOiBcIkxhc3QgT2YtLVVzZSB0aGUgbGFzdCBjZWxsIHNpemUgb2YgdGhlIGlucHV0IHJhc3RlcnMuXCIsXG5cdFwiQEBJcy1OdWxsX0NlbGxzaXplLVR5cGVfdGFnM0BAXCI6IFwiTWF4IE9mLS1Vc2UgdGhlIGxhcmdlc3QgY2VsbCBzaXplIG9mIGFsbCB0aGUgaW5wdXQgcmFzdGVycy4gVGhpcyBpcyB0aGUgZGVmYXVsdC5cIixcblx0XCJAQElzLU51bGxfQ2VsbHNpemUtVHlwZV90YWc0QEBcIjogXCJNZWFuIE9mLS1Vc2UgdGhlIG1lYW4gY2VsbCBzaXplIG9mIGFsbCB0aGUgaW5wdXQgcmFzdGVycy5cIixcblx0XCJAQElzLU51bGxfQ2VsbHNpemUtVHlwZV90YWc1QEBcIjogXCJNaW4gT2YtLVVzZSB0aGUgc21hbGxlc3QgY2VsbCBzaXplIG9mIGFsbCB0aGUgaW5wdXQgcmFzdGVycy5cIixcblx0XCJAQElzLU51bGxfRXh0ZW50LVR5cGVfdGFnMEBAXCI6IFwiQ2hvb3NlIHdoaWNoIGV4dGVudCBzaG91bGQgYmUgdXNlZCBpbiB0aGUgb3V0cHV0IHJhc3RlcjpcIixcblx0XCJAQElzLU51bGxfRXh0ZW50LVR5cGVfdGFnMUBAXCI6IFwiRmlyc3QgT2YtLVVzZSB0aGUgZXh0ZW50IG9mIHRoZSBmaXJzdCBpbnB1dCByYXN0ZXIgdG8gZGV0ZXJtaW5lIHRoZSBwcm9jZXNzaW5nIGV4dGVudC5cIixcblx0XCJAQElzLU51bGxfRXh0ZW50LVR5cGVfdGFnMkBAXCI6IFwiSW50ZXJzZWN0aW9uIE9mLS1Vc2UgdGhlIGV4dGVudCBvZiB0aGUgb3ZlcmxhcHBpbmcgcGl4ZWxzIHRvIGRldGVybWluZSB0aGUgcHJvY2Vzc2luZyBleHRlbnQuIFRoaXMgaXMgdGhlIGRlZmF1bHQuXCIsXG5cdFwiQEBJcy1OdWxsX0V4dGVudC1UeXBlX3RhZzNAQFwiOiBcIkxhc3QgT2YtLVVzZSB0aGUgZXh0ZW50IG9mIHRoZSBsYXN0IGlucHV0IHJhc3RlciB0byBkZXRlcm1pbmUgdGhlIHByb2Nlc3NpbmcgZXh0ZW50LlwiLFxuXHRcIkBASXMtTnVsbF9FeHRlbnQtVHlwZV90YWc0QEBcIjogXCJVbmlvbiBPZi0tVXNlIHRoZSBleHRlbnQgb2YgYWxsIHRoZSByYXN0ZXJzIHRvIGRldGVybWluZSB0aGUgcHJvY2Vzc2luZyBleHRlbnQuXCIsXG5cdFwiQEBJcy1OdWxsX1Jhc3Rlcl90YWcwQEBcIjogXCJUaGUgaW5wdXQgcmFzdGVyIGJlaW5nIHRlc3RlZCB0byBpZGVudGlmeSB0aGUgY2VsbHMgdGhhdCBhcmUgJHtOb0RhdGF9IChudWxsKS5cIixcblx0XCJAQElzLU51bGxfUmFzdGVyX3RhZzFAQFwiOiBcIlRoZSBpbnB1dCBjYW4gYmUgZWl0aGVyIGludGVnZXIgb3IgZmxvYXRpbmctcG9pbnQgdHlwZS5cIixcblx0XCJAQEtleS1NZXRhZGF0YV9CYW5kLU5hbWVzX3RhZzBAQFwiOiBcIlRoaXMgaXMgdXNlZCB0byBvdmVycmlkZSB0aGUgYmFuZCBuYW1lcyBvZiBhIHJhc3Rlci4gSXQgaXMgYSBjb21tYS1zZXBhcmF0ZWQgc3RyaW5nIHJlcHJlc2VudGluZyB1cGRhdGVkIGJhbmQgbmFtZXMuXCIsXG5cdFwiQEBLZXktTWV0YWRhdGFfQmFuZC1OYW1lc190YWcxQEBcIjogXCJUaGlzIHBhcmFtZXRlciBpcyBvcHRpb25hbC5cIixcblx0XCJAQEtleS1NZXRhZGF0YV9NZXRhZGF0YS1KU09OX3RhZzBAQFwiOiBcIktleSBtZXRhZGF0YSB0byBiZSBpbmplY3RlZCBpbnRvIHRoZSBvdXRnb2luZyByYXN0ZXIgZGVzY3JpYmVkIGFzIGEgSlNPTiBzdHJpbmcgcmVwcmVzZW50aW5nIGEgY29sbGVjdGlvbiBvZiBrZXktdmFsdWUgcGFpcnMuIFRoZSBmb2xsb3dpbmcgaXMgYW4gZXhhbXBsZSBvZiBhIEpTT04gc3RyaW5nIHRoYXQgY2FuIGJlIHVzZWQgYXMgYW4gaW5wdXQgdG8gdGhpcyBmdW5jdGlvbi4gQWxsIGlucHV0cyBmb3IgdGhpcyBwYXJhbWV0ZXIgc2hvdWxkIGZvbGxvdyB0aGUgc2FtZSBmb3JtYXQuXCIsXG5cdFwiQEBLZXktTWV0YWRhdGFfTWV0YWRhdGEtSlNPTl90YWcxQEBcIjogXCJKU09OIHN0cmluZyByZXByZXNlbnRpbmcga2V5IG1ldGFkYXRhXCIsXG5cdFwiQEBLZXktTWV0YWRhdGFfTWV0YWRhdGEtSlNPTl90YWcyQEBcIjogXCJ7IFxcXCJDbG91ZENvdmVyXFxcIjogNCwgXFxcIkJhbmRQcm9wZXJ0aWVzXFxcIjpbIHsgXFxcIkJhbmROYW1lXFxcIjogXFxcIkJsdWVcXFwiLCBcXFwiV2F2ZWxlbmd0aE1pblxcXCI6IDQ0NSwgXFxcIldhdmVsZW5ndGhNYXhcXFwiOiA1MTYgfSwgeyBcXFwiQmFuZE5hbWVcXFwiOiBcXFwiR3JlZW5cXFwiLCBcXFwiV2F2ZWxlbmd0aE1pblxcXCI6IDUwNiwgXFxcIldhdmVsZW5ndGhNYXhcXFwiOiA1OTUgfSwgXX1cIixcblx0XCJAQEtleS1NZXRhZGF0YV9Qcm9wZXJ0eS1OYW1lX3RhZzBAQFwiOiBcIlRoZSBuYW1lIG9mIHRoZSBkYXRhc2V0LWxldmVsIGtleSBwcm9wZXJ0eSB0byBvdmVycmlkZS5cIixcblx0XCJAQEtleS1NZXRhZGF0YV9SYXN0ZXJfdGFnMEBAXCI6IFwiVGhlIHJhc3RlciBvciBtb3NhaWMgZGF0YXNldCBjb250YWluaW5nIGtleSBtZXRhZGF0YSB0aGF0IHlvdSB3b3VsZCBsaWtlIHRvIGluc2VydCBvciBvdmVyd3JpdGUuXCIsXG5cdFwiQEBLZXktTWV0YWRhdGFfVmFsdWVfdGFnMEBAXCI6IFwiVGhlIG92ZXJyaWRpbmcgdmFsdWUgb2YgdGhlIGRhdGFzZXQtbGV2ZWwga2V5IHByb3BlcnR5IHRoYXQgeW91IHdhbnQgdG8gc2V0LlwiLFxuXHRcIkBATGVhc3QtQ29zdC1QYXRoX0FjY3VtdWxhdGl2ZS1Db3N0LVJlc2lzdGFuY2UtUmF0ZV90YWcwQEBcIjogXCJUaGlzIHBhcmFtZXRlciBzaW11bGF0ZXMgdGhlIGluY3JlYXNlIGluIHRoZSBlZmZvcnQgdG8gb3ZlcmNvbWUgY29zdHMgYXMgdGhlIGFjY3VtdWxhdGl2ZSBjb3N0IGluY3JlYXNlcy4gSXQgaXMgdXNlZCB0byBtb2RlbCBmYXRpZ3VlIG9mIHRoZSB0cmF2ZWxlci4gVGhlIGdyb3dpbmcgYWNjdW11bGF0aXZlIGNvc3QgdG8gcmVhY2ggYSBjZWxsIGlzIG11bHRpcGxpZWQgYnkgdGhlIHJlc2lzdGFuY2UgcmF0ZSBhbmQgYWRkZWQgdG8gdGhlIGNvc3QgdG8gbW92ZSBpbnRvIHRoZSBzdWJzZXF1ZW50IGNlbGwuXCIsXG5cdFwiQEBMZWFzdC1Db3N0LVBhdGhfQWNjdW11bGF0aXZlLUNvc3QtUmVzaXN0YW5jZS1SYXRlX3RhZzFAQFwiOiBcIkl0J3MgYSBtb2RpZmllZCB2ZXJzaW9uIG9mIGEgY29tcG91bmQgaW50ZXJlc3QgcmF0ZSBmb3JtdWxhIHRoYXQncyB1c2VkIHRvIGNhbGN1bGF0ZSB0aGUgYXBwYXJlbnQgY29zdCBvZiBtb3ZpbmcgdGhyb3VnaCBhIGNlbGwuIEFzIHRoZSB2YWx1ZSBvZiB0aGUgcmVzaXN0YW5jZSByYXRlIGluY3JlYXNlcywgaXQgaW5jcmVhc2VzIHRoZSBjb3N0IG9mIHRoZSBjZWxscyB0aGF0IGFyZSB2aXNpdGVkIGxhdGVyLiBUaGUgZ3JlYXRlciB0aGUgcmVzaXN0YW5jZSByYXRlLCB0aGUgaGlnaGVyIHRoZSBjb3N0IHRvIHJlYWNoIHRoZSBuZXh0IGNlbGwsIHdoaWNoIGlzIGNvbXBvdW5kZWQgZm9yIGVhY2ggc3Vic2VxdWVudCBtb3ZlbWVudC4gU2luY2UgdGhlIHJlc2lzdGFuY2UgcmF0ZSBpcyBzaW1pbGFyIHRvIGEgY29tcG91bmQgcmF0ZSBhbmQgZ2VuZXJhbGx5IHRoZSBhY2N1bXVsYXRpdmUgY29zdCB2YWx1ZXMgYXJlIHZlcnkgbGFyZ2UsIHNtYWxsIHJlc2lzdGFuY2UgcmF0ZXMgYXJlIHN1Z2dlc3RlZCwgc3VjaCBhcyAwLjAwNSBvciBldmVuIHNtYWxsZXIsIGRlcGVuZGluZyBvbiB0aGUgYWNjdW11bGF0aXZlIGNvc3QgdmFsdWVzLlwiLFxuXHRcIkBATGVhc3QtQ29zdC1QYXRoX0FjY3VtdWxhdGl2ZS1Db3N0LVJlc2lzdGFuY2UtUmF0ZV90YWcyQEBcIjogXCJUaGUgdmFsdWUgbXVzdCBiZSBncmVhdGVyIHRoYW4gemVyby4gVGhlIGRlZmF1bHQgY2FwYWNpdHkgaXMgdG8gdGhlIGVkZ2Ugb2YgdGhlIG91dHB1dCByYXN0ZXIuXCIsXG5cdFwiQEBMZWFzdC1Db3N0LVBhdGhfQ2FwYWNpdHlfdGFnMEBAXCI6IFwiRGVmaW5lcyB0aGUgY29zdCBjYXBhY2l0eSBmb3IgdGhlIHRyYXZlbGVyIGZvciBhIHNvdXJjZS4gVGhlIGNvc3QgY2FsY3VsYXRpb25zIGNvbnRpbnVlIGZvciBlYWNoIHNvdXJjZSB1bnRpbCB0aGUgc3BlY2lmaWVkIGNhcGFjaXR5IGlzIHJlYWNoZWQuXCIsXG5cdFwiQEBMZWFzdC1Db3N0LVBhdGhfQ2FwYWNpdHlfdGFnMUBAXCI6IFwiVGhlIHZhbHVlIG11c3QgYmUgZ3JlYXRlciB0aGFuIHplcm8uIFRoZSBkZWZhdWx0IGNhcGFjaXR5IGlzIHRvIHRoZSBlZGdlIG9mIHRoZSBvdXRwdXQgcmFzdGVyLlwiLFxuXHRcIkBATGVhc3QtQ29zdC1QYXRoX0Nvc3QtUmFzdGVyX3RhZzBAQFwiOiBcIkEgcmVxdWlyZWQgaW5wdXQgcmFzdGVyIGRlZmluaW5nIHRoZSBjb3N0IG9yIGltcGVkYW5jZSB0byBtb3ZlIHBsYW5pbWV0cmljYWxseSB0aHJvdWdoIGVhY2ggY2VsbC4gVGhlIHZhbHVlIGF0IGVhY2ggY2VsbCBsb2NhdGlvbiByZXByZXNlbnRzIHRoZSBjb3N0LXBlci11bml0IGRpc3RhbmNlIGZvciBtb3ZpbmcgdGhyb3VnaCBpdC4gRWFjaCBjZWxsIGxvY2F0aW9uIHZhbHVlIGlzIG11bHRpcGxpZWQgYnkgdGhlIGNlbGwgcmVzb2x1dGlvbiwgYW5kIGFsc28gY29tcGVuc2F0ZXMgZm9yIGRpYWdvbmFsIG1vdmVtZW50IHRvIG9idGFpbiB0aGUgdG90YWwgY29zdCBvZiBwYXNzaW5nIHRocm91Z2ggdGhlIGNlbGwuXCIsXG5cdFwiQEBMZWFzdC1Db3N0LVBhdGhfQ29zdC1SYXN0ZXJfdGFnMUBAXCI6IFwiVGhlIHZhbHVlcyBvZiB0aGUgPHN0cm9uZz5Db3N0IFJhc3Rlcjwvc3Ryb25nPiBjYW4gYmUgaW50ZWdlciBvciBmbG9hdGluZyBwb2ludCwgYnV0IHRoZXkgY2Fubm90IGJlIG5lZ2F0aXZlIG9yIHplcm8uXCIsXG5cdFwiQEBMZWFzdC1Db3N0LVBhdGhfRGVzdGluYXRpb24tRmllbGRfdGFnMEBAXCI6IFwiVGhlIGZpZWxkIHVzZWQgdG8gb2J0YWluIHZhbHVlcyBmb3IgdGhlIGRlc3RpbmF0aW9uIGxvY2F0aW9ucy5cIixcblx0XCJAQExlYXN0LUNvc3QtUGF0aF9EZXN0aW5hdGlvbi1SYXN0ZXJfdGFnMEBAXCI6IFwiQSByZXF1aXJlZCBpbnB1dCByYXN0ZXIgdGhhdCBpZGVudGlmaWVzIHRoZSBwaXhlbHMgZnJvbSB3aGljaCB0aGUgbGVhc3QtY29zdCBwYXRoIGlzIGRldGVybWluZWQgdG8gdGhlIGxlYXN0IGNvc3RseSBzb3VyY2UuIFRoaXMgaW5wdXQgY29uc2lzdHMgb2YgcGl4ZWxzIHRoYXQgaGF2ZSB2YWxpZCB2YWx1ZXMsIGFuZCB0aGUgcmVtYWluaW5nIHBpeGVscyBtdXN0IGJlIGFzc2lnbmVkICR7Tm9EYXRhfS4gVmFsdWVzIG9mIDAgYXJlIHZhbGlkLlwiLFxuXHRcIkBATGVhc3QtQ29zdC1QYXRoX01heGltdW0tRGlzdGFuY2VfdGFnMEBAXCI6IFwiVGhlIHRocmVzaG9sZCB0aGF0IHRoZSBhY2N1bXVsYXRpdmUgY29zdCB2YWx1ZXMgY2Fubm90IGV4Y2VlZC4gSWYgYW4gYWNjdW11bGF0aXZlIGNvc3QgZGlzdGFuY2UgZXhjZWVkcyB0aGlzIHZhbHVlLCB0aGUgb3V0cHV0IHZhbHVlIGZvciB0aGUgY2VsbCBsb2NhdGlvbiB3aWxsIGJlICR7Tm9EYXRhfS4gVGhlIG1heGltdW0gZGlzdGFuY2UgZGVmaW5lcyB0aGUgZXh0ZW50IGZvciB3aGljaCB0aGUgYWNjdW11bGF0aXZlIGNvc3QgZGlzdGFuY2VzIGFyZSBjYWxjdWxhdGVkLiBUaGUgZGVmYXVsdCBkaXN0YW5jZSBpcyB0byB0aGUgZXh0ZW50IG9mIHRoZSBvdXRwdXQgcmFzdGVyLlwiLFxuXHRcIkBATGVhc3QtQ29zdC1QYXRoX011bHRpcGxpZXItdG8tQXBwbHktdG8tQ29zdHNfdGFnMEBAXCI6IFwiVGhpcyBwYXJhbWV0ZXIgYWxsb3dzIGZvciBjb250cm9sIG9mIHRoZSBtb2RlIG9mIHRyYXZlbCBvciB0aGUgbWFnbml0dWRlIGF0IGEgc291cmNlLiBUaGUgZ3JlYXRlciB0aGUgbXVsdGlwbGllciwgdGhlIGdyZWF0ZXIgdGhlIGNvc3QgdG8gbW92ZSB0aHJvdWdoIGVhY2ggY2VsbC5cIixcblx0XCJAQExlYXN0LUNvc3QtUGF0aF9NdWx0aXBsaWVyLXRvLUFwcGx5LXRvLUNvc3RzX3RhZzFAQFwiOiBcIlRoZSB2YWx1ZXMgbXVzdCBiZSBncmVhdGVyIHRoYW4gemVyby4gVGhlIGRlZmF1bHQgaXMgMS5cIixcblx0XCJAQExlYXN0LUNvc3QtUGF0aF9QYXRoLVR5cGVfdGFnMEBAXCI6IFwiQSBrZXl3b3JkIGRlZmluaW5nIHRoZSBtYW5uZXIgaW4gd2hpY2ggdGhlIHZhbHVlcyBhbmQgem9uZXMgb24gdGhlIGlucHV0IGRlc3RpbmF0aW9uIGRhdGEgd2lsbCBiZSBpbnRlcnByZXRlZCBpbiB0aGUgY29zdCBwYXRoIGNhbGN1bGF0aW9uczpcIixcblx0XCJAQExlYXN0LUNvc3QtUGF0aF9QYXRoLVR5cGVfdGFnMUBAXCI6IFwiPHN0cm9uZz5CZXN0IFNpbmdsZTwvc3Ryb25nPi0tRm9yIGFsbCBwaXhlbHMgb24gdGhlIGlucHV0IGRlc3RpbmF0aW9uIGRhdGEsIHRoZSBsZWFzdC1jb3N0IHBhdGggaXMgZGVyaXZlZCBmcm9tIHRoZSBwaXhlbCB3aXRoIHRoZSBtaW5pbXVtIG9mIHRoZSBsZWFzdC1jb3N0IHBhdGhzIHRvIHNvdXJjZSBjZWxscy5cIixcblx0XCJAQExlYXN0LUNvc3QtUGF0aF9QYXRoLVR5cGVfdGFnM0BAXCI6IFwiPHN0cm9uZz5FYWNoIENlbGw8L3N0cm9uZz4tLUEgbGVhc3QtY29zdCBwYXRoIGlzIGRldGVybWluZWQgZm9yIGVhY2ggcGl4ZWwgd2l0aCB2YWxpZCB2YWx1ZXMgb24gdGhlIGlucHV0IGRlc3RpbmF0aW9uIGRhdGEsIGFuZCBzYXZlZCBvbiB0aGUgb3V0cHV0IHJhc3Rlci4gRWFjaCBjZWxsIG9mIHRoZSBpbnB1dCBkZXN0aW5hdGlvbiBkYXRhIGlzIHRyZWF0ZWQgc2VwYXJhdGVseSwgYW5kIGEgbGVhc3QtY29zdCBwYXRoIGlzIGRldGVybWluZWQgZm9yIGVhY2ggZnJvbSBjZWxsLlwiLFxuXHRcIkBATGVhc3QtQ29zdC1QYXRoX1BhdGgtVHlwZV90YWc1QEBcIjogXCI8c3Ryb25nPkVhY2ggWm9uZTwvc3Ryb25nPi0tQSBsZWFzdC1jb3N0IHBhdGggaXMgZGV0ZXJtaW5lZCBmb3IgZWFjaCB6b25lIG9uIHRoZSBpbnB1dCBkZXN0aW5hdGlvbiBkYXRhIGFuZCBzYXZlZCBvbiB0aGUgb3V0cHV0IHJhc3Rlci4gVGhlIGxlYXN0LWNvc3QgcGF0aCBmb3IgZWFjaCB6b25lIGJlZ2lucyBhdCB0aGUgcGl4ZWwgd2l0aCB0aGUgbG93ZXN0IGNvc3QgZGlzdGFuY2Ugd2VpZ2h0aW5nIGluIHRoZSB6b25lLlwiLFxuXHRcIkBATGVhc3QtQ29zdC1QYXRoX1NvdXJjZS1SYXN0ZXJfdGFnMEBAXCI6IFwiVGhpcyBpcyBhIHJlcXVpcmVkIGlucHV0IHJhc3RlciB0aGF0IGlkZW50aWZpZXMgdGhlIGNlbGxzIG9yIGxvY2F0aW9ucyBmcm9tIHdoaWNoIHRoZSBsZWFzdCBhY2N1bXVsYXRlZCBjb3N0IGRpc3RhbmNlIGZvciBldmVyeSBvdXRwdXQgY2VsbCBsb2NhdGlvbiBpcyBjYWxjdWxhdGVkLlwiLFxuXHRcIkBATGVhc3QtQ29zdC1QYXRoX1N0YXJ0LUNvc3RfdGFnMEBAXCI6IFwiVGhlIHN0YXJ0aW5nIGNvc3QgZnJvbSB3aGljaCB0byBiZWdpbiB0aGUgY29zdCBjYWxjdWxhdGlvbnMuIFRoaXMgcGFyYW1ldGVyIGFsbG93cyBmb3IgdGhlIHNwZWNpZmljYXRpb24gb2YgdGhlIGZpeGVkIGNvc3QgYXNzb2NpYXRlZCB3aXRoIGEgc291cmNlLiBJbnN0ZWFkIG9mIHN0YXJ0aW5nIGF0IGEgY29zdCBvZiAwLCB0aGUgY29zdCBhbGdvcml0aG0gd2lsbCBiZWdpbiB3aXRoIHRoZSB2YWx1ZSBzcGVjaWZpZWQuXCIsXG5cdFwiQEBMZWFzdC1Db3N0LVBhdGhfU3RhcnQtQ29zdF90YWcxQEBcIjogXCJUaGUgdmFsdWUgbXVzdCBiZSB6ZXJvIG9yIGdyZWF0ZXIuIFRoZSBkZWZhdWx0IGlzIDAuXCIsXG5cdFwiQEBMZWFzdC1Db3N0LVBhdGhfVHJhdmVsLURpcmVjdGlvbl90YWcwQEBcIjogXCJEZWZpbmVzIHRoZSBkaXJlY3Rpb24gb2YgdGhlIHRyYXZlbGVyIHdoZW4gYXBwbHlpbmcgdGhlIHNvdXJjZSByZXNpc3RhbmNlIHJhdGUgYW5kIHRoZSBzb3VyY2Ugc3RhcnRpbmcgY29zdC5cIixcblx0XCJAQExlYXN0LUNvc3QtUGF0aF9UcmF2ZWwtRGlyZWN0aW9uX3RhZzFAQFwiOiBcIjxzdHJvbmc+RnJvbSBTb3VyY2U8L3N0cm9uZz4tLVRoZSBzb3VyY2UgcmVzaXN0YW5jZSByYXRlIGFuZCBzb3VyY2Ugc3RhcnRpbmcgY29zdCB3aWxsIGJlIGFwcGxpZWQgYmVnaW5uaW5nIGF0IHRoZSBpbnB1dCBzb3VyY2UgYW5kIG1vdmluZyBvdXQgdG8gdGhlIG5vbi1zb3VyY2UgY2VsbHMuIFRoaXMgaXMgdGhlIGRlZmF1bHQuXCIsXG5cdFwiQEBMZWFzdC1Db3N0LVBhdGhfVHJhdmVsLURpcmVjdGlvbl90YWczQEBcIjogXCI8c3Ryb25nPlRvIFNvdXJjZTwvc3Ryb25nPi0tVGhlIHNvdXJjZSByZXNpc3RhbmNlIHJhdGUgYW5kIHNvdXJjZSBzdGFydGluZyBjb3N0IHdpbGwgYmUgYXBwbGllZCBiZWdpbm5pbmcgYXQgZWFjaCBub24tc291cmNlIGNlbGwgYW5kIG1vdmluZyBiYWNrIHRvIHRoZSBpbnB1dCBzb3VyY2UuXCIsXG5cdFwiQEBMZWFzdC1Db3N0LVBhdGhfVHJhdmVsLURpcmVjdGlvbl90YWc1QEBcIjogXCJFaXRoZXIgc3BlY2lmeSB0aGUgPHN0cm9uZz5Gcm9tIFNvdXJjZTwvc3Ryb25nPiBvciA8c3Ryb25nPlRvIFNvdXJjZTwvc3Ryb25nPiBrZXl3b3JkLCB3aGljaCB3aWxsIGJlIGFwcGxpZWQgdG8gYWxsIHNvdXJjZXMsIG9yIHNwZWNpZnkgYSBmaWVsZCBpbiB0aGUgPHN0cm9uZz5Tb3VyY2UgUmFzdGVyPC9zdHJvbmc+IHRoYXQgY29udGFpbnMgdGhlIGtleXdvcmRzIHRvIGlkZW50aWZ5IHRoZSBkaXJlY3Rpb24gb2YgdHJhdmVsIGZvciBlYWNoIHNvdXJjZS4gVGhhdCBmaWVsZCBtdXN0IGNvbnRhaW4gdGhlIHN0cmluZyAke0ZST01fU09VUkNFfSBvciAke1RPX1NPVVJDRX0uXCIsXG5cdFwiQEBMZXNzLVRoYW5fQ2VsbHNpemUtVHlwZV90YWcwQEBcIjogXCJDaG9vc2Ugd2hpY2ggY2VsbCBzaXplIHRvIHVzZSBpbiB0aGUgb3V0cHV0IHJhc3Rlci4gSWYgYWxsIHRoZSBpbnB1dCBjZWxsIHNpemVzIGFyZSB0aGUgc2FtZSwgYWxsIHRoZSBvcHRpb25zIHdpbGwgeWllbGQgdGhlIHNhbWUgcmVzdWx0cy5cIixcblx0XCJAQExlc3MtVGhhbl9DZWxsc2l6ZS1UeXBlX3RhZzFAQFwiOiBcIkZpcnN0IE9mLS1Vc2UgdGhlIGZpcnN0IGNlbGwgc2l6ZSBvZiB0aGUgaW5wdXQgcmFzdGVycy5cIixcblx0XCJAQExlc3MtVGhhbl9DZWxsc2l6ZS1UeXBlX3RhZzJAQFwiOiBcIkxhc3QgT2YtLVVzZSB0aGUgbGFzdCBjZWxsIHNpemUgb2YgdGhlIGlucHV0IHJhc3RlcnMuXCIsXG5cdFwiQEBMZXNzLVRoYW5fQ2VsbHNpemUtVHlwZV90YWczQEBcIjogXCJNYXggT2YtLVVzZSB0aGUgbGFyZ2VzdCBjZWxsIHNpemUgb2YgYWxsIHRoZSBpbnB1dCByYXN0ZXJzLiBUaGlzIGlzIHRoZSBkZWZhdWx0LlwiLFxuXHRcIkBATGVzcy1UaGFuX0NlbGxzaXplLVR5cGVfdGFnNEBAXCI6IFwiTWVhbiBPZi0tVXNlIHRoZSBtZWFuIGNlbGwgc2l6ZSBvZiBhbGwgdGhlIGlucHV0IHJhc3RlcnMuXCIsXG5cdFwiQEBMZXNzLVRoYW5fQ2VsbHNpemUtVHlwZV90YWc1QEBcIjogXCJNaW4gT2YtLVVzZSB0aGUgc21hbGxlc3QgY2VsbCBzaXplIG9mIGFsbCB0aGUgaW5wdXQgcmFzdGVycy5cIixcblx0XCJAQExlc3MtVGhhbl9FeHRlbnQtVHlwZV90YWcwQEBcIjogXCJDaG9vc2Ugd2hpY2ggZXh0ZW50IHNob3VsZCBiZSB1c2VkIGluIHRoZSBvdXRwdXQgcmFzdGVyOlwiLFxuXHRcIkBATGVzcy1UaGFuX0V4dGVudC1UeXBlX3RhZzFAQFwiOiBcIkZpcnN0IE9mLS1Vc2UgdGhlIGV4dGVudCBvZiB0aGUgZmlyc3QgaW5wdXQgcmFzdGVyIHRvIGRldGVybWluZSB0aGUgcHJvY2Vzc2luZyBleHRlbnQuXCIsXG5cdFwiQEBMZXNzLVRoYW5fRXh0ZW50LVR5cGVfdGFnMkBAXCI6IFwiSW50ZXJzZWN0aW9uIE9mLS1Vc2UgdGhlIGV4dGVudCBvZiB0aGUgb3ZlcmxhcHBpbmcgcGl4ZWxzIHRvIGRldGVybWluZSB0aGUgcHJvY2Vzc2luZyBleHRlbnQuIFRoaXMgaXMgdGhlIGRlZmF1bHQuXCIsXG5cdFwiQEBMZXNzLVRoYW5fRXh0ZW50LVR5cGVfdGFnM0BAXCI6IFwiTGFzdCBPZi0tVXNlIHRoZSBleHRlbnQgb2YgdGhlIGxhc3QgaW5wdXQgcmFzdGVyIHRvIGRldGVybWluZSB0aGUgcHJvY2Vzc2luZyBleHRlbnQuXCIsXG5cdFwiQEBMZXNzLVRoYW5fRXh0ZW50LVR5cGVfdGFnNEBAXCI6IFwiVW5pb24gT2YtLVVzZSB0aGUgZXh0ZW50IG9mIGFsbCB0aGUgcmFzdGVycyB0byBkZXRlcm1pbmUgdGhlIHByb2Nlc3NpbmcgZXh0ZW50LlwiLFxuXHRcIkBATGVzcy1UaGFuX1Jhc3Rlcl90YWcwQEBcIjogXCJUaGUgaW5wdXQgYmVpbmcgdGVzdGVkIHRvIGRldGVybWluZSBpZiBpdCBpcyBsZXNzIHRoYW4gdGhlIHNlY29uZCBpbnB1dC5cIixcblx0XCJAQExlc3MtVGhhbl9SYXN0ZXJfdGFnMUBAXCI6IFwiQSBjb25zdGFudCB2YWx1ZSBjYW4gYmUgdXNlZCBhcyBhbiBpbnB1dCBmb3IgdGhpcyBwYXJhbWV0ZXIsIHByb3ZpZGVkIGEgcmFzdGVyIGlzIHNwZWNpZmllZCBmb3IgdGhlIG90aGVyIHBhcmFtZXRlci5cIixcblx0XCJAQExlc3MtVGhhbl9SYXN0ZXIyX3RhZzBAQFwiOiBcIlRoZSBpbnB1dCBhZ2FpbnN0IHdoaWNoIHRoZSBmaXJzdCBpbnB1dCBpcyB0ZXN0ZWQgdG8gYmUgbGVzcyB0aGFuLlwiLFxuXHRcIkBATGVzcy1UaGFuX1Jhc3RlcjJfdGFnMUBAXCI6IFwiQSBjb25zdGFudCB2YWx1ZSBjYW4gYmUgdXNlZCBhcyBhbiBpbnB1dCBmb3IgdGhpcyBwYXJhbWV0ZXIsIHByb3ZpZGVkIGEgcmFzdGVyIGlzIHNwZWNpZmllZCBmb3IgdGhlIG90aGVyIHBhcmFtZXRlci5cIixcblx0XCJAQExlc3MtVGhhbi1FcXVhbF9DZWxsc2l6ZS1UeXBlX3RhZzBAQFwiOiBcIkNob29zZSB3aGljaCBjZWxsIHNpemUgdG8gdXNlIGluIHRoZSBvdXRwdXQgcmFzdGVyLiBJZiBhbGwgdGhlIGlucHV0IGNlbGwgc2l6ZXMgYXJlIHRoZSBzYW1lLCBhbGwgdGhlIG9wdGlvbnMgd2lsbCB5aWVsZCB0aGUgc2FtZSByZXN1bHRzLlwiLFxuXHRcIkBATGVzcy1UaGFuLUVxdWFsX0NlbGxzaXplLVR5cGVfdGFnMUBAXCI6IFwiRmlyc3QgT2YtLVVzZSB0aGUgZmlyc3QgY2VsbCBzaXplIG9mIHRoZSBpbnB1dCByYXN0ZXJzLlwiLFxuXHRcIkBATGVzcy1UaGFuLUVxdWFsX0NlbGxzaXplLVR5cGVfdGFnMkBAXCI6IFwiTGFzdCBPZi0tVXNlIHRoZSBsYXN0IGNlbGwgc2l6ZSBvZiB0aGUgaW5wdXQgcmFzdGVycy5cIixcblx0XCJAQExlc3MtVGhhbi1FcXVhbF9DZWxsc2l6ZS1UeXBlX3RhZzNAQFwiOiBcIk1heCBPZi0tVXNlIHRoZSBsYXJnZXN0IGNlbGwgc2l6ZSBvZiBhbGwgdGhlIGlucHV0IHJhc3RlcnMuIFRoaXMgaXMgdGhlIGRlZmF1bHQuXCIsXG5cdFwiQEBMZXNzLVRoYW4tRXF1YWxfQ2VsbHNpemUtVHlwZV90YWc0QEBcIjogXCJNZWFuIE9mLS1Vc2UgdGhlIG1lYW4gY2VsbCBzaXplIG9mIGFsbCB0aGUgaW5wdXQgcmFzdGVycy5cIixcblx0XCJAQExlc3MtVGhhbi1FcXVhbF9DZWxsc2l6ZS1UeXBlX3RhZzVAQFwiOiBcIk1pbiBPZi0tVXNlIHRoZSBzbWFsbGVzdCBjZWxsIHNpemUgb2YgYWxsIHRoZSBpbnB1dCByYXN0ZXJzLlwiLFxuXHRcIkBATGVzcy1UaGFuLUVxdWFsX0V4dGVudC1UeXBlX3RhZzBAQFwiOiBcIkNob29zZSB3aGljaCBleHRlbnQgc2hvdWxkIGJlIHVzZWQgaW4gdGhlIG91dHB1dCByYXN0ZXI6XCIsXG5cdFwiQEBMZXNzLVRoYW4tRXF1YWxfRXh0ZW50LVR5cGVfdGFnMUBAXCI6IFwiRmlyc3QgT2YtLVVzZSB0aGUgZXh0ZW50IG9mIHRoZSBmaXJzdCBpbnB1dCByYXN0ZXIgdG8gZGV0ZXJtaW5lIHRoZSBwcm9jZXNzaW5nIGV4dGVudC5cIixcblx0XCJAQExlc3MtVGhhbi1FcXVhbF9FeHRlbnQtVHlwZV90YWcyQEBcIjogXCJJbnRlcnNlY3Rpb24gT2YtLVVzZSB0aGUgZXh0ZW50IG9mIHRoZSBvdmVybGFwcGluZyBwaXhlbHMgdG8gZGV0ZXJtaW5lIHRoZSBwcm9jZXNzaW5nIGV4dGVudC4gVGhpcyBpcyB0aGUgZGVmYXVsdC5cIixcblx0XCJAQExlc3MtVGhhbi1FcXVhbF9FeHRlbnQtVHlwZV90YWczQEBcIjogXCJMYXN0IE9mLS1Vc2UgdGhlIGV4dGVudCBvZiB0aGUgbGFzdCBpbnB1dCByYXN0ZXIgdG8gZGV0ZXJtaW5lIHRoZSBwcm9jZXNzaW5nIGV4dGVudC5cIixcblx0XCJAQExlc3MtVGhhbi1FcXVhbF9FeHRlbnQtVHlwZV90YWc0QEBcIjogXCJVbmlvbiBPZi0tVXNlIHRoZSBleHRlbnQgb2YgYWxsIHRoZSByYXN0ZXJzIHRvIGRldGVybWluZSB0aGUgcHJvY2Vzc2luZyBleHRlbnQuXCIsXG5cdFwiQEBMZXNzLVRoYW4tRXF1YWxfUmFzdGVyX3RhZzBAQFwiOiBcIlRoZSBpbnB1dCBiZWluZyB0ZXN0ZWQgdG8gZGV0ZXJtaW5lIGlmIGl0IGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0byB0aGUgc2Vjb25kIGlucHV0LlwiLFxuXHRcIkBATGVzcy1UaGFuLUVxdWFsX1Jhc3Rlcl90YWcxQEBcIjogXCJBIGNvbnN0YW50IHZhbHVlIGNhbiBiZSB1c2VkIGFzIGFuIGlucHV0IGZvciB0aGlzIHBhcmFtZXRlciwgcHJvdmlkZWQgYSByYXN0ZXIgaXMgc3BlY2lmaWVkIGZvciB0aGUgb3RoZXIgcGFyYW1ldGVyLlwiLFxuXHRcIkBATGVzcy1UaGFuLUVxdWFsX1Jhc3RlcjJfdGFnMEBAXCI6IFwiVGhlIGlucHV0IGFnYWluc3Qgd2hpY2ggdGhlIGZpcnN0IGlucHV0IGlzIHRlc3RlZCB0byBiZSBsZXNzIHRoYW4gb3IgZXF1YWwgdG8uXCIsXG5cdFwiQEBMZXNzLVRoYW4tRXF1YWxfUmFzdGVyMl90YWcxQEBcIjogXCJBIGNvbnN0YW50IHZhbHVlIGNhbiBiZSB1c2VkIGFzIGFuIGlucHV0IGZvciB0aGlzIHBhcmFtZXRlciwgcHJvdmlkZWQgYSByYXN0ZXIgaXMgc3BlY2lmaWVkIGZvciB0aGUgb3RoZXIgcGFyYW1ldGVyLlwiLFxuXHRcIkBATG5fQ2VsbHNpemUtVHlwZV90YWcwQEBcIjogXCJDaG9vc2Ugd2hpY2ggY2VsbCBzaXplIHRvIHVzZSBpbiB0aGUgb3V0cHV0IHJhc3Rlci4gSWYgYWxsIHRoZSBpbnB1dCBjZWxsIHNpemVzIGFyZSB0aGUgc2FtZSwgYWxsIHRoZSBvcHRpb25zIHdpbGwgeWllbGQgdGhlIHNhbWUgcmVzdWx0cy5cIixcblx0XCJAQExuX0NlbGxzaXplLVR5cGVfdGFnMUBAXCI6IFwiRmlyc3QgT2YtLVVzZSB0aGUgZmlyc3QgY2VsbCBzaXplIG9mIHRoZSBpbnB1dCByYXN0ZXJzLlwiLFxuXHRcIkBATG5fQ2VsbHNpemUtVHlwZV90YWcyQEBcIjogXCJMYXN0IE9mLS1Vc2UgdGhlIGxhc3QgY2VsbCBzaXplIG9mIHRoZSBpbnB1dCByYXN0ZXJzLlwiLFxuXHRcIkBATG5fQ2VsbHNpemUtVHlwZV90YWczQEBcIjogXCJNYXggT2YtLVVzZSB0aGUgbGFyZ2VzdCBjZWxsIHNpemUgb2YgYWxsIHRoZSBpbnB1dCByYXN0ZXJzLiBUaGlzIGlzIHRoZSBkZWZhdWx0LlwiLFxuXHRcIkBATG5fQ2VsbHNpemUtVHlwZV90YWc0QEBcIjogXCJNZWFuIE9mLS1Vc2UgdGhlIG1lYW4gY2VsbCBzaXplIG9mIGFsbCB0aGUgaW5wdXQgcmFzdGVycy5cIixcblx0XCJAQExuX0NlbGxzaXplLVR5cGVfdGFnNUBAXCI6IFwiTWluIE9mLS1Vc2UgdGhlIHNtYWxsZXN0IGNlbGwgc2l6ZSBvZiBhbGwgdGhlIGlucHV0IHJhc3RlcnMuXCIsXG5cdFwiQEBMbl9FeHRlbnQtVHlwZV90YWcwQEBcIjogXCJDaG9vc2Ugd2hpY2ggZXh0ZW50IHNob3VsZCBiZSB1c2VkIGluIHRoZSBvdXRwdXQgcmFzdGVyOlwiLFxuXHRcIkBATG5fRXh0ZW50LVR5cGVfdGFnMUBAXCI6IFwiRmlyc3QgT2YtLVVzZSB0aGUgZXh0ZW50IG9mIHRoZSBmaXJzdCBpbnB1dCByYXN0ZXIgdG8gZGV0ZXJtaW5lIHRoZSBwcm9jZXNzaW5nIGV4dGVudC5cIixcblx0XCJAQExuX0V4dGVudC1UeXBlX3RhZzJAQFwiOiBcIkludGVyc2VjdGlvbiBPZi0tVXNlIHRoZSBleHRlbnQgb2YgdGhlIG92ZXJsYXBwaW5nIHBpeGVscyB0byBkZXRlcm1pbmUgdGhlIHByb2Nlc3NpbmcgZXh0ZW50LiBUaGlzIGlzIHRoZSBkZWZhdWx0LlwiLFxuXHRcIkBATG5fRXh0ZW50LVR5cGVfdGFnM0BAXCI6IFwiTGFzdCBPZi0tVXNlIHRoZSBleHRlbnQgb2YgdGhlIGxhc3QgaW5wdXQgcmFzdGVyIHRvIGRldGVybWluZSB0aGUgcHJvY2Vzc2luZyBleHRlbnQuXCIsXG5cdFwiQEBMbl9FeHRlbnQtVHlwZV90YWc0QEBcIjogXCJVbmlvbiBPZi0tVXNlIHRoZSBleHRlbnQgb2YgYWxsIHRoZSByYXN0ZXJzIHRvIGRldGVybWluZSB0aGUgcHJvY2Vzc2luZyBleHRlbnQuXCIsXG5cdFwiQEBMbl9SYXN0ZXJfdGFnMEBAXCI6IFwiSW5wdXQgdmFsdWVzIGZvciB3aGljaCB0byBmaW5kIHRoZSBuYXR1cmFsIGxvZ2FyaXRobSAoTG4pLlwiLFxuXHRcIkBATG9nMTBfQ2VsbHNpemUtVHlwZV90YWcwQEBcIjogXCJDaG9vc2Ugd2hpY2ggY2VsbCBzaXplIHRvIHVzZSBpbiB0aGUgb3V0cHV0IHJhc3Rlci4gSWYgYWxsIHRoZSBpbnB1dCBjZWxsIHNpemVzIGFyZSB0aGUgc2FtZSwgYWxsIHRoZSBvcHRpb25zIHdpbGwgeWllbGQgdGhlIHNhbWUgcmVzdWx0cy5cIixcblx0XCJAQExvZzEwX0NlbGxzaXplLVR5cGVfdGFnMUBAXCI6IFwiRmlyc3QgT2YtLVVzZSB0aGUgZmlyc3QgY2VsbCBzaXplIG9mIHRoZSBpbnB1dCByYXN0ZXJzLlwiLFxuXHRcIkBATG9nMTBfQ2VsbHNpemUtVHlwZV90YWcyQEBcIjogXCJMYXN0IE9mLS1Vc2UgdGhlIGxhc3QgY2VsbCBzaXplIG9mIHRoZSBpbnB1dCByYXN0ZXJzLlwiLFxuXHRcIkBATG9nMTBfQ2VsbHNpemUtVHlwZV90YWczQEBcIjogXCJNYXggT2YtLVVzZSB0aGUgbGFyZ2VzdCBjZWxsIHNpemUgb2YgYWxsIHRoZSBpbnB1dCByYXN0ZXJzLiBUaGlzIGlzIHRoZSBkZWZhdWx0LlwiLFxuXHRcIkBATG9nMTBfQ2VsbHNpemUtVHlwZV90YWc0QEBcIjogXCJNZWFuIE9mLS1Vc2UgdGhlIG1lYW4gY2VsbCBzaXplIG9mIGFsbCB0aGUgaW5wdXQgcmFzdGVycy5cIixcblx0XCJAQExvZzEwX0NlbGxzaXplLVR5cGVfdGFnNUBAXCI6IFwiTWluIE9mLS1Vc2UgdGhlIHNtYWxsZXN0IGNlbGwgc2l6ZSBvZiBhbGwgdGhlIGlucHV0IHJhc3RlcnMuXCIsXG5cdFwiQEBMb2cxMF9FeHRlbnQtVHlwZV90YWcwQEBcIjogXCJDaG9vc2Ugd2hpY2ggZXh0ZW50IHNob3VsZCBiZSB1c2VkIGluIHRoZSBvdXRwdXQgcmFzdGVyOlwiLFxuXHRcIkBATG9nMTBfRXh0ZW50LVR5cGVfdGFnMUBAXCI6IFwiRmlyc3QgT2YtLVVzZSB0aGUgZXh0ZW50IG9mIHRoZSBmaXJzdCBpbnB1dCByYXN0ZXIgdG8gZGV0ZXJtaW5lIHRoZSBwcm9jZXNzaW5nIGV4dGVudC5cIixcblx0XCJAQExvZzEwX0V4dGVudC1UeXBlX3RhZzJAQFwiOiBcIkludGVyc2VjdGlvbiBPZi0tVXNlIHRoZSBleHRlbnQgb2YgdGhlIG92ZXJsYXBwaW5nIHBpeGVscyB0byBkZXRlcm1pbmUgdGhlIHByb2Nlc3NpbmcgZXh0ZW50LiBUaGlzIGlzIHRoZSBkZWZhdWx0LlwiLFxuXHRcIkBATG9nMTBfRXh0ZW50LVR5cGVfdGFnM0BAXCI6IFwiTGFzdCBPZi0tVXNlIHRoZSBleHRlbnQgb2YgdGhlIGxhc3QgaW5wdXQgcmFzdGVyIHRvIGRldGVybWluZSB0aGUgcHJvY2Vzc2luZyBleHRlbnQuXCIsXG5cdFwiQEBMb2cxMF9FeHRlbnQtVHlwZV90YWc0QEBcIjogXCJVbmlvbiBPZi0tVXNlIHRoZSBleHRlbnQgb2YgYWxsIHRoZSByYXN0ZXJzIHRvIGRldGVybWluZSB0aGUgcHJvY2Vzc2luZyBleHRlbnQuXCIsXG5cdFwiQEBMb2cxMF9SYXN0ZXJfdGFnMEBAXCI6IFwiSW5wdXQgdmFsdWVzIGZvciB3aGljaCB0byBmaW5kIHRoZSBiYXNlIDEwIGxvZ2FyaXRobS5cIixcblx0XCJAQExvZzJfQ2VsbHNpemUtVHlwZV90YWcwQEBcIjogXCJDaG9vc2Ugd2hpY2ggY2VsbCBzaXplIHRvIHVzZSBpbiB0aGUgb3V0cHV0IHJhc3Rlci4gSWYgYWxsIHRoZSBpbnB1dCBjZWxsIHNpemVzIGFyZSB0aGUgc2FtZSwgYWxsIHRoZSBvcHRpb25zIHdpbGwgeWllbGQgdGhlIHNhbWUgcmVzdWx0cy5cIixcblx0XCJAQExvZzJfQ2VsbHNpemUtVHlwZV90YWcxQEBcIjogXCJGaXJzdCBPZi0tVXNlIHRoZSBmaXJzdCBjZWxsIHNpemUgb2YgdGhlIGlucHV0IHJhc3RlcnMuXCIsXG5cdFwiQEBMb2cyX0NlbGxzaXplLVR5cGVfdGFnMkBAXCI6IFwiTGFzdCBPZi0tVXNlIHRoZSBsYXN0IGNlbGwgc2l6ZSBvZiB0aGUgaW5wdXQgcmFzdGVycy5cIixcblx0XCJAQExvZzJfQ2VsbHNpemUtVHlwZV90YWczQEBcIjogXCJNYXggT2YtLVVzZSB0aGUgbGFyZ2VzdCBjZWxsIHNpemUgb2YgYWxsIHRoZSBpbnB1dCByYXN0ZXJzLiBUaGlzIGlzIHRoZSBkZWZhdWx0LlwiLFxuXHRcIkBATG9nMl9DZWxsc2l6ZS1UeXBlX3RhZzRAQFwiOiBcIk1lYW4gT2YtLVVzZSB0aGUgbWVhbiBjZWxsIHNpemUgb2YgYWxsIHRoZSBpbnB1dCByYXN0ZXJzLlwiLFxuXHRcIkBATG9nMl9DZWxsc2l6ZS1UeXBlX3RhZzVAQFwiOiBcIk1pbiBPZi0tVXNlIHRoZSBzbWFsbGVzdCBjZWxsIHNpemUgb2YgYWxsIHRoZSBpbnB1dCByYXN0ZXJzLlwiLFxuXHRcIkBATG9nMl9FeHRlbnQtVHlwZV90YWcwQEBcIjogXCJDaG9vc2Ugd2hpY2ggZXh0ZW50IHNob3VsZCBiZSB1c2VkIGluIHRoZSBvdXRwdXQgcmFzdGVyOlwiLFxuXHRcIkBATG9nMl9FeHRlbnQtVHlwZV90YWcxQEBcIjogXCJGaXJzdCBPZi0tVXNlIHRoZSBleHRlbnQgb2YgdGhlIGZpcnN0IGlucHV0IHJhc3RlciB0byBkZXRlcm1pbmUgdGhlIHByb2Nlc3NpbmcgZXh0ZW50LlwiLFxuXHRcIkBATG9nMl9FeHRlbnQtVHlwZV90YWcyQEBcIjogXCJJbnRlcnNlY3Rpb24gT2YtLVVzZSB0aGUgZXh0ZW50IG9mIHRoZSBvdmVybGFwcGluZyBwaXhlbHMgdG8gZGV0ZXJtaW5lIHRoZSBwcm9jZXNzaW5nIGV4dGVudC4gVGhpcyBpcyB0aGUgZGVmYXVsdC5cIixcblx0XCJAQExvZzJfRXh0ZW50LVR5cGVfdGFnM0BAXCI6IFwiTGFzdCBPZi0tVXNlIHRoZSBleHRlbnQgb2YgdGhlIGxhc3QgaW5wdXQgcmFzdGVyIHRvIGRldGVybWluZSB0aGUgcHJvY2Vzc2luZyBleHRlbnQuXCIsXG5cdFwiQEBMb2cyX0V4dGVudC1UeXBlX3RhZzRAQFwiOiBcIlVuaW9uIE9mLS1Vc2UgdGhlIGV4dGVudCBvZiBhbGwgdGhlIHJhc3RlcnMgdG8gZGV0ZXJtaW5lIHRoZSBwcm9jZXNzaW5nIGV4dGVudC5cIixcblx0XCJAQExvZzJfUmFzdGVyX3RhZzBAQFwiOiBcIklucHV0IHZhbHVlcyBmb3Igd2hpY2ggdG8gZmluZCB0aGUgYmFzZSAyIGxvZ2FyaXRobS5cIixcblx0XCJAQExvb2t1cF9GaWVsZF90YWcwQEBcIjogXCJGaWVsZCBjb250YWluaW5nIHRoZSBkZXNpcmVkIHZhbHVlcyBmb3IgdGhlIG5ldyByYXN0ZXIuXCIsXG5cdFwiQEBMb29rdXBfRmllbGRfdGFnMUBAXCI6IFwiSXQgaGFzIHRvIGJlIGEgbnVtZXJpYyB0eXBlLlwiLFxuXHRcIkBATG9va3VwX1Jhc3Rlcl90YWcwQEBcIjogXCJUaGUgaW5wdXQgcmFzdGVyIHRoYXQgY29udGFpbnMgYSBmaWVsZCBmcm9tIHdoaWNoIHRvIGNyZWF0ZSBhIG5ldyByYXN0ZXIuXCIsXG5cdFwiQEBMb29rdXBfUmFzdGVyX3RhZzFAQFwiOiBcIkl0IGNhbiBiZSBlaXRoZXIgaW50ZWdlciBvciBmbG9hdGluZy1wb2ludCB0eXBlLlwiLFxuXHRcIkBATWFza19JbmNsdWRlZC1SYW5nZXNfdGFnMEBAXCI6IFwiVGhlIGluY2x1ZGVkIHJhbmdlcyBjYW4gYmUgc3BlY2lmaWVkIGZvciBlYWNoIGJhbmQgYnkgc3BlY2lmeWluZyBhIG1pbmltdW0gYW5kIG1heGltdW0gdmFsdWU7IGFueSB2YWx1ZXMgb3V0c2lkZSB0aGUgcmFuZ2Ugd2lsbCBiZSByZXR1cm5lZCBhcyAke05vRGF0YX0uIEEgcGl4ZWwgaXMgaW5jbHVkZWQgaWYgdGhlIHBpeGVsJ3MgdmFsdWUgZmFsbHMgd2l0aGluIGFueSBvZiB0aGUgcmFuZ2VzIHNwZWNpZmllZC4gVGhlcmVmb3JlLCBpZiBiYW5kIDEgaGFzIGEgcmFuZ2Ugb2YgNS0xMCBhbmQgYmFuZCAyIGhhcyBhIHJhbmdlIG9mIDE1LTIwLCBhbmQgdGhlIHBpeGVsIHZhbHVlIGZvciBiYW5kIDEgaXMgOCwgdGhpcyBwaXhlbCB3aWxsIG5vdCBiZSBtYXNrZWQuXCIsXG5cdFwiQEBNYXNrX05vRGF0YS1JbnRlcnByZXRhdGlvbl90YWcwQEBcIjogXCJUaGlzIHJlZmVycyB0byBob3cgPHN0cm9uZz4ke05vRGF0YX0gVmFsdWVzPC9zdHJvbmc+IHdpbGwgaW1wYWN0IHRoZSBvdXRwdXQgaW1hZ2UuXCIsXG5cdFwiQEBNYXNrX05vRGF0YS1JbnRlcnByZXRhdGlvbl90YWczQEBcIjogXCJZb3UgY2FuIHNlbGVjdCBmcm9tIHRoZSBmb2xsb3dpbmcgdHdvIG9wdGlvbnM6XCIsXG5cdFwiQEBNYXNrX05vRGF0YS1JbnRlcnByZXRhdGlvbl90YWc0QEBcIjogXCI8c3Ryb25nPk1hdGNoIEFsbDwvc3Ryb25nPi0tVGhlICR7Tm9EYXRhfSB2YWx1ZXMgeW91IHNwZWNpZnkgZm9yIGVhY2ggYmFuZCBtdXN0IG9jY3VyIGluIHRoZSBzYW1lIHBpeGVsIGZvciB0aGUgb3V0cHV0IGltYWdlIHRvIGNvbnRhaW4gdGhlICR7Tm9EYXRhfSBwaXhlbC5cIixcblx0XCJAQE1hc2tfTm9EYXRhLUludGVycHJldGF0aW9uX3RhZzZAQFwiOiBcIjxzdHJvbmc+TWF0Y2ggQW55PC9zdHJvbmc+LS1JZiB0aGUgJHtOb0RhdGF9IHZhbHVlIHlvdSBzcGVjaWZ5IG9jY3VycyBmb3IgYSBwaXhlbCBpbiBhIHNwZWNpZmllZCBiYW5kLCB0aGF0IHBpeGVsIGluIHRoZSBvdXRwdXQgaW1hZ2Ugd2lsbCBiZSAke05vRGF0YX0uIFRoaXMgaXMgdGhlIGRlZmF1bHQuXCIsXG5cdFwiQEBNYXNrX05vRGF0YS1WYWx1ZXNfdGFnMEBAXCI6IFwiVGhlIE5vRGF0YSB2YWx1ZXMgY2FuIGJlIHNwZWNpZmllZCBmb3IgZWFjaCBiYW5kLiBZb3UgY2FuIHNwZWNpZnkgbW9yZSB0aGFuIG9uZSB2YWx1ZSBieSBlbnRlcmluZyBhIHNwYWNlLWRlbGltaXRlZCBsaXN0LlwiLFxuXHRcIkBATWFza19SYXN0ZXJfdGFnMEBAXCI6IFwiVGhlIGlucHV0IHJhc3Rlci5cIixcblx0XCJAQE1pbnVzX0NlbGxzaXplLVR5cGVfdGFnMEBAXCI6IFwiQ2hvb3NlIHdoaWNoIGNlbGwgc2l6ZSB0byB1c2UgaW4gdGhlIG91dHB1dCByYXN0ZXIuIElmIGFsbCB0aGUgaW5wdXQgY2VsbCBzaXplcyBhcmUgdGhlIHNhbWUsIGFsbCB0aGUgb3B0aW9ucyB3aWxsIHlpZWxkIHRoZSBzYW1lIHJlc3VsdHMuXCIsXG5cdFwiQEBNaW51c19DZWxsc2l6ZS1UeXBlX3RhZzFAQFwiOiBcIkZpcnN0IE9mLS1Vc2UgdGhlIGZpcnN0IGNlbGwgc2l6ZSBvZiB0aGUgaW5wdXQgcmFzdGVycy5cIixcblx0XCJAQE1pbnVzX0NlbGxzaXplLVR5cGVfdGFnMkBAXCI6IFwiTGFzdCBPZi0tVXNlIHRoZSBsYXN0IGNlbGwgc2l6ZSBvZiB0aGUgaW5wdXQgcmFzdGVycy5cIixcblx0XCJAQE1pbnVzX0NlbGxzaXplLVR5cGVfdGFnM0BAXCI6IFwiTWF4IE9mLS1Vc2UgdGhlIGxhcmdlc3QgY2VsbCBzaXplIG9mIGFsbCB0aGUgaW5wdXQgcmFzdGVycy4gVGhpcyBpcyB0aGUgZGVmYXVsdC5cIixcblx0XCJAQE1pbnVzX0NlbGxzaXplLVR5cGVfdGFnNEBAXCI6IFwiTWVhbiBPZi0tVXNlIHRoZSBtZWFuIGNlbGwgc2l6ZSBvZiBhbGwgdGhlIGlucHV0IHJhc3RlcnMuXCIsXG5cdFwiQEBNaW51c19DZWxsc2l6ZS1UeXBlX3RhZzVAQFwiOiBcIk1pbiBPZi0tVXNlIHRoZSBzbWFsbGVzdCBjZWxsIHNpemUgb2YgYWxsIHRoZSBpbnB1dCByYXN0ZXJzLlwiLFxuXHRcIkBATWludXNfRXh0ZW50LVR5cGVfdGFnMEBAXCI6IFwiQ2hvb3NlIHdoaWNoIGV4dGVudCBzaG91bGQgYmUgdXNlZCBpbiB0aGUgb3V0cHV0IHJhc3RlcjpcIixcblx0XCJAQE1pbnVzX0V4dGVudC1UeXBlX3RhZzFAQFwiOiBcIkZpcnN0IE9mLS1Vc2UgdGhlIGV4dGVudCBvZiB0aGUgZmlyc3QgaW5wdXQgcmFzdGVyIHRvIGRldGVybWluZSB0aGUgcHJvY2Vzc2luZyBleHRlbnQuXCIsXG5cdFwiQEBNaW51c19FeHRlbnQtVHlwZV90YWcyQEBcIjogXCJJbnRlcnNlY3Rpb24gT2YtLVVzZSB0aGUgZXh0ZW50IG9mIHRoZSBvdmVybGFwcGluZyBwaXhlbHMgdG8gZGV0ZXJtaW5lIHRoZSBwcm9jZXNzaW5nIGV4dGVudC4gVGhpcyBpcyB0aGUgZGVmYXVsdC5cIixcblx0XCJAQE1pbnVzX0V4dGVudC1UeXBlX3RhZzNAQFwiOiBcIkxhc3QgT2YtLVVzZSB0aGUgZXh0ZW50IG9mIHRoZSBsYXN0IGlucHV0IHJhc3RlciB0byBkZXRlcm1pbmUgdGhlIHByb2Nlc3NpbmcgZXh0ZW50LlwiLFxuXHRcIkBATWludXNfRXh0ZW50LVR5cGVfdGFnNEBAXCI6IFwiVW5pb24gT2YtLVVzZSB0aGUgZXh0ZW50IG9mIGFsbCB0aGUgcmFzdGVycyB0byBkZXRlcm1pbmUgdGhlIHByb2Nlc3NpbmcgZXh0ZW50LlwiLFxuXHRcIkBATWludXNfUmFzdGVyX3RhZzBAQFwiOiBcIlRoZSBpbnB1dCBmcm9tIHdoaWNoIHRvIHN1YnRyYWN0IHRoZSB2YWx1ZXMgb2YgdGhlIHNlY29uZCBpbnB1dC5cIixcblx0XCJAQE1pbnVzX1Jhc3Rlcl90YWcxQEBcIjogXCJBIGNvbnN0YW50IHZhbHVlIGNhbiBiZSB1c2VkIGFzIGFuIGlucHV0IGZvciB0aGlzIHBhcmFtZXRlciwgcHJvdmlkZWQgYSByYXN0ZXIgaXMgc3BlY2lmaWVkIGZvciB0aGUgb3RoZXIgcGFyYW1ldGVyLlwiLFxuXHRcIkBATWludXNfUmFzdGVyMl90YWcwQEBcIjogXCJUaGUgaW5wdXQgdmFsdWVzIHRvIHN1YnRyYWN0IGZyb20gdGhlIHZhbHVlcyBvZiB0aGUgZmlyc3QgaW5wdXQuXCIsXG5cdFwiQEBNaW51c19SYXN0ZXIyX3RhZzFAQFwiOiBcIkEgY29uc3RhbnQgdmFsdWUgY2FuIGJlIHVzZWQgYXMgYW4gaW5wdXQgZm9yIHRoaXMgcGFyYW1ldGVyLCBwcm92aWRlZCBhIHJhc3RlciBpcyBzcGVjaWZpZWQgZm9yIHRoZSBvdGhlciBwYXJhbWV0ZXIuXCIsXG5cdFwiQEBNTC1DbGFzc2lmeV9SYXN0ZXJfdGFnMEBAXCI6IFwiVGhlIGlucHV0IHJhc3RlciB0byBjbGFzc2lmeSB1c2luZyB0aGUgbWF4aW11bSBsaWtlbGlob29kIGNsYXNzaWZpY2F0aW9uIGFsZ29yaXRobS5cIixcblx0XCJAQE1MLUNsYXNzaWZ5X1NpZ25hdHVyZS1GaWxlLW9yLVVSTF90YWcwQEBcIjogXCJUaGUgJHsuZ3NnfSBzaWduYXR1cmUgZmlsZS5cIixcblx0XCJAQE1vZF9DZWxsc2l6ZS1UeXBlX3RhZzBAQFwiOiBcIkNob29zZSB3aGljaCBjZWxsIHNpemUgdG8gdXNlIGluIHRoZSBvdXRwdXQgcmFzdGVyLiBJZiBhbGwgdGhlIGlucHV0IGNlbGwgc2l6ZXMgYXJlIHRoZSBzYW1lLCBhbGwgdGhlIG9wdGlvbnMgd2lsbCB5aWVsZCB0aGUgc2FtZSByZXN1bHRzLlwiLFxuXHRcIkBATW9kX0NlbGxzaXplLVR5cGVfdGFnMUBAXCI6IFwiRmlyc3QgT2YtLVVzZSB0aGUgZmlyc3QgY2VsbCBzaXplIG9mIHRoZSBpbnB1dCByYXN0ZXJzLlwiLFxuXHRcIkBATW9kX0NlbGxzaXplLVR5cGVfdGFnMkBAXCI6IFwiTGFzdCBPZi0tVXNlIHRoZSBsYXN0IGNlbGwgc2l6ZSBvZiB0aGUgaW5wdXQgcmFzdGVycy5cIixcblx0XCJAQE1vZF9DZWxsc2l6ZS1UeXBlX3RhZzNAQFwiOiBcIk1heCBPZi0tVXNlIHRoZSBsYXJnZXN0IGNlbGwgc2l6ZSBvZiBhbGwgdGhlIGlucHV0IHJhc3RlcnMuIFRoaXMgaXMgdGhlIGRlZmF1bHQuXCIsXG5cdFwiQEBNb2RfQ2VsbHNpemUtVHlwZV90YWc0QEBcIjogXCJNZWFuIE9mLS1Vc2UgdGhlIG1lYW4gY2VsbCBzaXplIG9mIGFsbCB0aGUgaW5wdXQgcmFzdGVycy5cIixcblx0XCJAQE1vZF9DZWxsc2l6ZS1UeXBlX3RhZzVAQFwiOiBcIk1pbiBPZi0tVXNlIHRoZSBzbWFsbGVzdCBjZWxsIHNpemUgb2YgYWxsIHRoZSBpbnB1dCByYXN0ZXJzLlwiLFxuXHRcIkBATW9kX0V4dGVudC1UeXBlX3RhZzBAQFwiOiBcIkNob29zZSB3aGljaCBleHRlbnQgc2hvdWxkIGJlIHVzZWQgaW4gdGhlIG91dHB1dCByYXN0ZXI6XCIsXG5cdFwiQEBNb2RfRXh0ZW50LVR5cGVfdGFnMUBAXCI6IFwiRmlyc3QgT2YtLVVzZSB0aGUgZXh0ZW50IG9mIHRoZSBmaXJzdCBpbnB1dCByYXN0ZXIgdG8gZGV0ZXJtaW5lIHRoZSBwcm9jZXNzaW5nIGV4dGVudC5cIixcblx0XCJAQE1vZF9FeHRlbnQtVHlwZV90YWcyQEBcIjogXCJJbnRlcnNlY3Rpb24gT2YtLVVzZSB0aGUgZXh0ZW50IG9mIHRoZSBvdmVybGFwcGluZyBwaXhlbHMgdG8gZGV0ZXJtaW5lIHRoZSBwcm9jZXNzaW5nIGV4dGVudC4gVGhpcyBpcyB0aGUgZGVmYXVsdC5cIixcblx0XCJAQE1vZF9FeHRlbnQtVHlwZV90YWczQEBcIjogXCJMYXN0IE9mLS1Vc2UgdGhlIGV4dGVudCBvZiB0aGUgbGFzdCBpbnB1dCByYXN0ZXIgdG8gZGV0ZXJtaW5lIHRoZSBwcm9jZXNzaW5nIGV4dGVudC5cIixcblx0XCJAQE1vZF9FeHRlbnQtVHlwZV90YWc0QEBcIjogXCJVbmlvbiBPZi0tVXNlIHRoZSBleHRlbnQgb2YgYWxsIHRoZSByYXN0ZXJzIHRvIGRldGVybWluZSB0aGUgcHJvY2Vzc2luZyBleHRlbnQuXCIsXG5cdFwiQEBNb2RfUmFzdGVyX3RhZzBAQFwiOiBcIlRoZSBudW1lcmF0b3IgaW5wdXQuXCIsXG5cdFwiQEBNb2RfUmFzdGVyX3RhZzFAQFwiOiBcIkEgY29uc3RhbnQgdmFsdWUgY2FuIGJlIHVzZWQgYXMgYW4gaW5wdXQgZm9yIHRoaXMgcGFyYW1ldGVyLCBwcm92aWRlZCBhIHJhc3RlciBpcyBzcGVjaWZpZWQgZm9yIHRoZSBvdGhlciBwYXJhbWV0ZXIuXCIsXG5cdFwiQEBNb2RfUmFzdGVyMl90YWcwQEBcIjogXCJUaGUgZGVub21pbmF0b3IgaW5wdXQuXCIsXG5cdFwiQEBNb2RfUmFzdGVyMl90YWcxQEBcIjogXCJBIGNvbnN0YW50IHZhbHVlIGNhbiBiZSB1c2VkIGFzIGFuIGlucHV0IGZvciB0aGlzIHBhcmFtZXRlciwgcHJvdmlkZWQgYSByYXN0ZXIgaXMgc3BlY2lmaWVkIGZvciB0aGUgb3RoZXIgcGFyYW1ldGVyLlwiLFxuXHRcIkBATW9zYWljLVJhc3RlcnNfT3BlcmF0aW9uX3RhZzBAQFwiOiBcIlJlc29sdmUgYW55IGNvbmZsaWN0IHdoZW4geW91IGhhdmUgcGFydHMgb2YgdHdvIG9yIG1vcmUgaW1hZ2VzIHRoYXQgb3ZlcmxhcC4gVGhlIG9wdGlvbnMgaW5jbHVkZSB0aGUgZm9sbG93aW5nOlwiLFxuXHRcIkBATW9zYWljLVJhc3RlcnNfT3BlcmF0aW9uX3RhZzFAQFwiOiBcIjxzdHJvbmc+QmxlbmQ8L3N0cm9uZz4tLUNhbGN1bGF0ZSBhbmQgZGlzcGxheSBhbiBhdmVyYWdlIG9mIHRoZSBvdmVybGFwcGluZyBwaXhlbHMgYnkgZ2l2aW5nIG1vcmUgd2VpZ2h0IHRvIHBpeGVscyB0aGF0IGFyZSBjbG9zZXIgdG8gbmVpZ2hib3JpbmcgaW1hZ2VzIHNvIHRoZSBvdXRwdXQgaXMgYSBzbW9vdGhlciBpbWFnZS4gVGhpcyBpcyB0aGUgZGVmYXVsdC5cIixcblx0XCJAQE1vc2FpYy1SYXN0ZXJzX09wZXJhdGlvbl90YWczQEBcIjogXCI8c3Ryb25nPkZpcnN0PC9zdHJvbmc+LS1EaXNwbGF5IHRoZSBwaXhlbHMgZnJvbSB0aGUgZmlyc3QgaW1hZ2UgaW4gdGhlIGxpc3Qgb2YgaW1hZ2VzIG92ZXJsYXBwaW5nIGEgZ2l2ZW4gYXJlYS5cIixcblx0XCJAQE1vc2FpYy1SYXN0ZXJzX09wZXJhdGlvbl90YWc1QEBcIjogXCI8c3Ryb25nPkxhc3Q8L3N0cm9uZz4tLURpc3BsYXkgdGhlIHBpeGVscyBmcm9tIHRoZSBsYXN0IGltYWdlIGluIHRoZSBsaXN0IG9mIGltYWdlcyBvdmVybGFwcGluZyBhIGdpdmVuIGFyZWEuXCIsXG5cdFwiQEBNb3NhaWMtUmFzdGVyc19PcGVyYXRpb25fdGFnN0BAXCI6IFwiPHN0cm9uZz5NYXg8L3N0cm9uZz4tLURpc3BsYXkgdGhlIGhpZ2hlc3QgdmFsdWVkIHBpeGVsIG9mIGFsbCB0aGUgb3ZlcmxhcHBpbmcgbGF5ZXJzLiBXaXRoIHRoaXMgb3B0aW9uLCB5b3UgaGF2ZSBubyBndWFyYW50ZWUgb2YgZGlzcGxheWluZyB0aGUgcGl4ZWxzIG9mIGp1c3Qgb25lIGltYWdlIGluIHRoZSBvdmVybGFwcGluZyBhcmVhIGJ1dCByYXRoZXIgYSBjb21iaW5hdGlvbiBvZiBhbGwgcG90ZW50aWFsIGxheWVycy5cIixcblx0XCJAQE1vc2FpYy1SYXN0ZXJzX09wZXJhdGlvbl90YWc5QEBcIjogXCI8c3Ryb25nPk1lYW48L3N0cm9uZz4tLUNhbGN1bGF0ZSBhbmQgZGlzcGxheSBhbiBhdmVyYWdlIG9mIHRoZSBvdmVybGFwcGluZyBwaXhlbHMuXCIsXG5cdFwiQEBNb3NhaWMtUmFzdGVyc19PcGVyYXRpb25fdGFnMTFAQFwiOiBcIjxzdHJvbmc+TWluPC9zdHJvbmc+LS1EaXNwbGF5IHRoZSBsb3dlc3QgdmFsdWVkIHBpeGVsIG9mIGFsbCB0aGUgb3ZlcmxhcHBpbmcgbGF5ZXJzLiBXaXRoIHRoaXMgb3B0aW9uLCB5b3UgaGF2ZSBubyBndWFyYW50ZWUgb2YgZGlzcGxheWluZyB0aGUgcGl4ZWxzIG9mIGp1c3Qgb25lIGltYWdlIGluIHRoZSBvdmVybGFwcGluZyBhcmVhIGJ1dCByYXRoZXIgYSBjb21iaW5hdGlvbiBvZiBhbGwgcG90ZW50aWFsIGxheWVycy5cIixcblx0XCJAQE1vc2FpYy1SYXN0ZXJzX1Jhc3RlcnNfdGFnMEBAXCI6IFwiU2VsZWN0IHRoZSByYXN0ZXJzIHlvdSB3YW50IHRvIG1vc2FpYyB0b2dldGhlciB0byBmb3JtIG9uZSBpbWFnZS5cIixcblx0XCJAQE5EVklfSW5mcmFyZWQtQmFuZC1JRF90YWcwQEBcIjogXCJTcGVjaWZpZXMgdGhlIGJhbmQgSUQgdGhhdCByZXByZXNlbnRzIHRoZSBuZWFyLWluZnJhcmVkIHBhcnQgb2YgdGhlIGVsZWN0cm9tYWduZXRpYyBzcGVjdHJ1bS5cIixcblx0XCJAQE5EVklfUmFzdGVyX3RhZzBAQFwiOiBcIlRoZSBpbnB1dCBtdWx0aXNwZWN0cmFsIHJhc3Rlci5cIixcblx0XCJAQE5EVklfU2NpZW50aWZpYy1PdXRwdXRfdGFnMEBAXCI6IFwiVGhlIG91dHB1dCB2YWx1ZXMgd2lsbCByYW5nZSBmcm9tIC0xLjAgdG8gMS4wLCB3aGljaCBpcyB1c2VkIGluIG1hbnkgc2NpZW50aWZpYyBhcHBsaWNhdGlvbnMuXCIsXG5cdFwiQEBORFZJX1Zpc2libGUtQmFuZC1JRF90YWcwQEBcIjogXCJTcGVjaWZpZXMgdGhlIGJhbmQgSUQgdGhhdCByZXByZXNlbnRzIHRoZSByZWQgcGFydCBvZiB0aGUgZWxlY3Ryb21hZ25ldGljIHNwZWN0cnVtLlwiLFxuXHRcIkBATkRWSS1Db2xvcml6ZWRfQ29sb3ItUmFtcF90YWcwQEBcIjogXCJDaG9vc2UgYSBwcmVkZWZpbmVkIGNvbG9yIHNjaGVtZSBmcm9tIHRoZSBkcm9wIGRvd24gbGlzdC5cIixcblx0XCJAQE5EVkktQ29sb3JpemVkX0NvbG9yLVNjaGVtZS1UeXBlX3RhZzBAQFwiOiBcIkNob3NlIHdoaWNoIHR5cGUgb2YgY29sb3Igc2NoZW1lIHRvIGNvbG9yaXplIHRoZSBORFZJIG91dHB1dDpcIixcblx0XCJAQE5EVkktQ29sb3JpemVkX0NvbG9yLVNjaGVtZS1UeXBlX3RhZzFAQFwiOiBcIkNvbG9ybWFwLS1DaG9vc2UgYSBwcmVkZWZpbmVkIGNvbG9yIG1hcCBmcm9tIHRoZSBkcm9wIGRvd24gbGlzdC4gQWx0ZXJuYXRpdmVseSwgeW91IGNhbiBicm93c2UgdG8gYSBwZXJzaXN0ZWQgY29sb3IgbWFwIGZpbGUgdGhhdCBleGlzdHMuXCIsXG5cdFwiQEBORFZJLUNvbG9yaXplZF9Db2xvci1TY2hlbWUtVHlwZV90YWcyQEBcIjogXCJDb2xvciBSYW1wLS1DaG9vc2UgYSBwcmVkZWZpbmVkIGNvbG9yIHNjaGVtZSBmcm9tIHRoZSBkcm9wIGRvd24gbGlzdC5cIixcblx0XCJAQE5EVkktQ29sb3JpemVkX0NvbG9ybWFwX3RhZzBAQFwiOiBcIkNob29zZSBhIHByZWRlZmluZWQgY29sb3IgbWFwIGZyb20gdGhlIGRyb3AgZG93biBsaXN0LiBBbHRlcm5hdGl2ZWx5LCB5b3UgY2FuIGJyb3dzZSB0byBhbiBleGlzdGluZyBjb2xvciBtYXAgZmlsZS5cIixcblx0XCJAQE5EVkktQ29sb3JpemVkX0luZnJhcmVkLUJhbmQtSURfdGFnMEBAXCI6IFwiU3BlY2lmaWVzIHRoZSBiYW5kIElEIHRoYXQgcmVwcmVzZW50cyB0aGUgbmVhci1pbmZyYXJlZCBwYXJ0IG9mIHRoZSBlbGVjdHJvbWFnbmV0aWMgc3BlY3RydW0uXCIsXG5cdFwiQEBORFZJLUNvbG9yaXplZF9SYXN0ZXJfdGFnMEBAXCI6IFwiVGhlIGlucHV0IG11bHRpc3BlY3RyYWwgcmFzdGVyLlwiLFxuXHRcIkBATkRWSS1Db2xvcml6ZWRfU2NpZW50aWZpYy1PdXRwdXRfdGFnMEBAXCI6IFwiVGhlIG91dHB1dCB2YWx1ZXMgd2lsbCByYW5nZSBmcm9tIC0xLjAgdG8gMS4wLCB3aGljaCBpcyB1c2VkIGluIG1hbnkgc2NpZW50aWZpYyBhcHBsaWNhdGlvbnMuXCIsXG5cdFwiQEBORFZJLUNvbG9yaXplZF9WaXNpYmxlLUJhbmQtSURfdGFnMEBAXCI6IFwiU3BlY2lmaWVzIHRoZSBiYW5kIElEIHRoYXQgcmVwcmVzZW50cyB0aGUgcmVkIHBhcnQgb2YgdGhlIGVsZWN0cm9tYWduZXRpYyBzcGVjdHJ1bS5cIixcblx0XCJAQE5lZ2F0ZV9DZWxsc2l6ZS1UeXBlX3RhZzBAQFwiOiBcIkNob29zZSB3aGljaCBjZWxsIHNpemUgdG8gdXNlIGluIHRoZSBvdXRwdXQgcmFzdGVyLiBJZiBhbGwgdGhlIGlucHV0IGNlbGwgc2l6ZXMgYXJlIHRoZSBzYW1lLCBhbGwgdGhlIG9wdGlvbnMgd2lsbCB5aWVsZCB0aGUgc2FtZSByZXN1bHRzLlwiLFxuXHRcIkBATmVnYXRlX0NlbGxzaXplLVR5cGVfdGFnMUBAXCI6IFwiRmlyc3QgT2YtLVVzZSB0aGUgZmlyc3QgY2VsbCBzaXplIG9mIHRoZSBpbnB1dCByYXN0ZXJzLlwiLFxuXHRcIkBATmVnYXRlX0NlbGxzaXplLVR5cGVfdGFnMkBAXCI6IFwiTGFzdCBPZi0tVXNlIHRoZSBsYXN0IGNlbGwgc2l6ZSBvZiB0aGUgaW5wdXQgcmFzdGVycy5cIixcblx0XCJAQE5lZ2F0ZV9DZWxsc2l6ZS1UeXBlX3RhZzNAQFwiOiBcIk1heCBPZi0tVXNlIHRoZSBsYXJnZXN0IGNlbGwgc2l6ZSBvZiBhbGwgdGhlIGlucHV0IHJhc3RlcnMuIFRoaXMgaXMgdGhlIGRlZmF1bHQuXCIsXG5cdFwiQEBOZWdhdGVfQ2VsbHNpemUtVHlwZV90YWc0QEBcIjogXCJNZWFuIE9mLS1Vc2UgdGhlIG1lYW4gY2VsbCBzaXplIG9mIGFsbCB0aGUgaW5wdXQgcmFzdGVycy5cIixcblx0XCJAQE5lZ2F0ZV9DZWxsc2l6ZS1UeXBlX3RhZzVAQFwiOiBcIk1pbiBPZi0tVXNlIHRoZSBzbWFsbGVzdCBjZWxsIHNpemUgb2YgYWxsIHRoZSBpbnB1dCByYXN0ZXJzLlwiLFxuXHRcIkBATmVnYXRlX0V4dGVudC1UeXBlX3RhZzBAQFwiOiBcIkNob29zZSB3aGljaCBleHRlbnQgc2hvdWxkIGJlIHVzZWQgaW4gdGhlIG91dHB1dCByYXN0ZXI6XCIsXG5cdFwiQEBOZWdhdGVfRXh0ZW50LVR5cGVfdGFnMUBAXCI6IFwiRmlyc3QgT2YtLVVzZSB0aGUgZXh0ZW50IG9mIHRoZSBmaXJzdCBpbnB1dCByYXN0ZXIgdG8gZGV0ZXJtaW5lIHRoZSBwcm9jZXNzaW5nIGV4dGVudC5cIixcblx0XCJAQE5lZ2F0ZV9FeHRlbnQtVHlwZV90YWcyQEBcIjogXCJJbnRlcnNlY3Rpb24gT2YtLVVzZSB0aGUgZXh0ZW50IG9mIHRoZSBvdmVybGFwcGluZyBwaXhlbHMgdG8gZGV0ZXJtaW5lIHRoZSBwcm9jZXNzaW5nIGV4dGVudC4gVGhpcyBpcyB0aGUgZGVmYXVsdC5cIixcblx0XCJAQE5lZ2F0ZV9FeHRlbnQtVHlwZV90YWczQEBcIjogXCJMYXN0IE9mLS1Vc2UgdGhlIGV4dGVudCBvZiB0aGUgbGFzdCBpbnB1dCByYXN0ZXIgdG8gZGV0ZXJtaW5lIHRoZSBwcm9jZXNzaW5nIGV4dGVudC5cIixcblx0XCJAQE5lZ2F0ZV9FeHRlbnQtVHlwZV90YWc0QEBcIjogXCJVbmlvbiBPZi0tVXNlIHRoZSBleHRlbnQgb2YgYWxsIHRoZSByYXN0ZXJzIHRvIGRldGVybWluZSB0aGUgcHJvY2Vzc2luZyBleHRlbnQuXCIsXG5cdFwiQEBOZWdhdGVfUmFzdGVyX3RhZzBAQFwiOiBcIlRoZSBpbnB1dCByYXN0ZXIgdG8gYmUgbmVnYXRlZCAobXVsdGlwbGllZCBieSAtMSkuXCIsXG5cdFwiQEBOaWJibGVfTWFzay1SYXN0ZXJfdGFnMEBAXCI6IFwiVGhlIHJlcXVpcmVkIGlucHV0IHJhc3RlciB1c2VkIGFzIHRoZSBtYXNrLlwiLFxuXHRcIkBATmliYmxlX01hc2stUmFzdGVyX3RhZzFAQFwiOiBcIkNlbGxzIHdpdGggTm9EYXRhIGFzIHRoZWlyIHZhbHVlIHdpbGwgYmUgbmliYmxlZCBpbiB0aGUgaW5wdXQgPHN0cm9uZz5SYXN0ZXI8L3N0cm9uZz4uXCIsXG5cdFwiQEBOaWJibGVfTWFzay1SYXN0ZXJfdGFnNEBAXCI6IFwiVGhlIG1hc2sgcmFzdGVyIGNhbiBiZSBhbiBpbnRlZ2VyIG9yIGEgZmxvYXRpbmctcG9pbnQgdHlwZS5cIixcblx0XCJAQE5pYmJsZV9OaWJibGUtTm9EYXRhLWNlbGxzX3RhZzBAQFwiOiBcIkRlZmluZXMgaWYgTm9EYXRhIGNlbGxzIGluIHRoZSBpbnB1dCByYXN0ZXIgd2lsbCByZW1haW4gTm9EYXRhIGluIHRoZSBvdXRwdXQgcmFzdGVyLlwiLFxuXHRcIkBATmliYmxlX05pYmJsZS1Ob0RhdGEtY2VsbHNfdGFnMUBAXCI6IFwiPHN0cm9uZz5Obzwvc3Ryb25nPi0tU3BlY2lmaWVzIHRoYXQgTm9EYXRhIGNlbGxzIGluIHRoZSBpbnB1dCByYXN0ZXIgd2lsbCByZW1haW4gTm9EYXRhIGluIHRoZSBvdXRwdXQuIFRoaXMgaXMgdGhlIGRlZmF1bHQuXCIsXG5cdFwiQEBOaWJibGVfTmliYmxlLU5vRGF0YS1jZWxsc190YWczQEBcIjogXCI8c3Ryb25nPlllczwvc3Ryb25nPi0tU3BlY2lmaWVzIHRoYXQgTm9EYXRhIGNlbGxzIGluIHRoZSBpbnB1dCByYXN0ZXIgYW5kIHdpdGhpbiB0aGUgbWFzayBjYW4gYmUgbmliYmxlZCBpbnRvIHZhbGlkIG91dHB1dCBjZWxsIHZhbHVlcy5cIixcblx0XCJAQE5pYmJsZV9SYXN0ZXJfdGFnMEBAXCI6IFwiVGhlIHJlcXVpcmVkIGlucHV0IHJhc3RlciB0aGF0IHdpbGwgYmUgbmliYmxlZC5cIixcblx0XCJAQE5pYmJsZV9SYXN0ZXJfdGFnMUBAXCI6IFwiVGhlIGlucHV0IHJhc3RlciBjYW4gYmUgYW4gaW50ZWdlciBvciBhIGZsb2F0aW5nLXBvaW50IHR5cGUuXCIsXG5cdFwiQEBOaWJibGVfVXNlLU5vRGF0YS12YWx1ZXMtaWYtdGhleS1hcmUtdGhlLW5lYXJlc3QtbmVpZ2hib3JfdGFnMEBAXCI6IFwiRGVmaW5lcyBpZiAke05vRGF0YX0gdmFsdWVzIGluIHRoZSBpbnB1dCByYXN0ZXIgYXJlIGFsbG93ZWQgdG8gbmliYmxlIGludG8gdGhlIGFyZWEgZGVmaW5lZCBieSB0aGUgbWFzayByYXN0ZXIuXCIsXG5cdFwiQEBOaWJibGVfVXNlLU5vRGF0YS12YWx1ZXMtaWYtdGhleS1hcmUtdGhlLW5lYXJlc3QtbmVpZ2hib3JfdGFnMUBAXCI6IFwiPHN0cm9uZz5ZZXM8L3N0cm9uZz4tLVNwZWNpZmllcyB0aGF0IHRoZSBuZWFyZXN0IG5laWdoYm9yIHZhbHVlIHdpbGwgYmUgdXNlZCB3aGV0aGVyIGl0IGlzICR7Tm9EYXRhfSBvciBhbm90aGVyIGRhdGEgdmFsdWUgaW4gdGhlIGlucHV0IHJhc3Rlci4gJHtOb0RhdGF9IHZhbHVlcyBpbiB0aGUgaW5wdXQgcmFzdGVyIGFyZSBmcmVlIHRvIG5pYmJsZSBpbnRvIGFyZWFzIGRlZmluZWQgaW4gdGhlIG1hc2sgaWYgdGhleSBhcmUgdGhlIG5lYXJlc3QgbmVpZ2hib3IuIFRoaXMgaXMgdGhlIGRlZmF1bHQuXCIsXG5cdFwiQEBOaWJibGVfVXNlLU5vRGF0YS12YWx1ZXMtaWYtdGhleS1hcmUtdGhlLW5lYXJlc3QtbmVpZ2hib3JfdGFnM0BAXCI6IFwiPHN0cm9uZz5Obzwvc3Ryb25nPi0tU3BlY2lmaWVzIHRoYXQgb25seSBkYXRhIHZhbHVlcyBhcmUgZnJlZSB0byBuaWJibGUgaW50byBhcmVhcyBkZWZpbmVkIGluIHRoZSBtYXNrIHJhc3Rlci4gJHtOb0RhdGF9IHZhbHVlcyBpbiB0aGUgaW5wdXQgcmFzdGVyIGFyZSBub3QgYWxsb3dlZCB0byBuaWJibGUgaW50byBhcmVhcyBkZWZpbmVkIGluIHRoZSBtYXNrIHJhc3RlciBldmVuIGlmIHRoZXkgYXJlIHRoZSBuZWFyZXN0IG5laWdoYm9yLlwiLFxuXHRcIkBATmliYmxlX1pvbmUtUmFzdGVyX3RhZzBAQFwiOiBcIlRoZSBpbnB1dCB6b25lIHJhc3Rlci5cIixcblx0XCJAQE5pYmJsZV9ab25lLVJhc3Rlcl90YWcxQEBcIjogXCJBIHpvbmUgaXMgYWxsIHRoZSBjZWxscyBpbiBhIHJhc3RlciB0aGF0IGhhdmUgdGhlIHNhbWUgdmFsdWUsIHdoZXRoZXIgb3Igbm90IHRoZXkgYXJlIGNvbnRpZ3VvdXMuIFRoZSBpbnB1dCB6b25lIGxheWVyIGRlZmluZXMgdGhlIHNoYXBlLCB2YWx1ZXMsIGFuZCBsb2NhdGlvbnMgb2YgdGhlIHpvbmVzLiBUaGUgem9uZSByYXN0ZXIgY2FuIGJlIGVpdGhlciBpbnRlZ2VyIG9yIGZsb2F0aW5nIHBvaW50IHR5cGUuXCIsXG5cdFwiQEBOb3QtRXF1YWxfQ2VsbHNpemUtVHlwZV90YWcwQEBcIjogXCJDaG9vc2Ugd2hpY2ggY2VsbCBzaXplIHRvIHVzZSBpbiB0aGUgb3V0cHV0IHJhc3Rlci4gSWYgYWxsIHRoZSBpbnB1dCBjZWxsIHNpemVzIGFyZSB0aGUgc2FtZSwgYWxsIHRoZSBvcHRpb25zIHdpbGwgeWllbGQgdGhlIHNhbWUgcmVzdWx0cy5cIixcblx0XCJAQE5vdC1FcXVhbF9DZWxsc2l6ZS1UeXBlX3RhZzFAQFwiOiBcIkZpcnN0IE9mLS1Vc2UgdGhlIGZpcnN0IGNlbGwgc2l6ZSBvZiB0aGUgaW5wdXQgcmFzdGVycy5cIixcblx0XCJAQE5vdC1FcXVhbF9DZWxsc2l6ZS1UeXBlX3RhZzJAQFwiOiBcIkxhc3QgT2YtLVVzZSB0aGUgbGFzdCBjZWxsIHNpemUgb2YgdGhlIGlucHV0IHJhc3RlcnMuXCIsXG5cdFwiQEBOb3QtRXF1YWxfQ2VsbHNpemUtVHlwZV90YWczQEBcIjogXCJNYXggT2YtLVVzZSB0aGUgbGFyZ2VzdCBjZWxsIHNpemUgb2YgYWxsIHRoZSBpbnB1dCByYXN0ZXJzLiBUaGlzIGlzIHRoZSBkZWZhdWx0LlwiLFxuXHRcIkBATm90LUVxdWFsX0NlbGxzaXplLVR5cGVfdGFnNEBAXCI6IFwiTWVhbiBPZi0tVXNlIHRoZSBtZWFuIGNlbGwgc2l6ZSBvZiBhbGwgdGhlIGlucHV0IHJhc3RlcnMuXCIsXG5cdFwiQEBOb3QtRXF1YWxfQ2VsbHNpemUtVHlwZV90YWc1QEBcIjogXCJNaW4gT2YtLVVzZSB0aGUgc21hbGxlc3QgY2VsbCBzaXplIG9mIGFsbCB0aGUgaW5wdXQgcmFzdGVycy5cIixcblx0XCJAQE5vdC1FcXVhbF9FeHRlbnQtVHlwZV90YWcwQEBcIjogXCJDaG9vc2Ugd2hpY2ggZXh0ZW50IHNob3VsZCBiZSB1c2VkIGluIHRoZSBvdXRwdXQgcmFzdGVyOlwiLFxuXHRcIkBATm90LUVxdWFsX0V4dGVudC1UeXBlX3RhZzFAQFwiOiBcIkZpcnN0IE9mLS1Vc2UgdGhlIGV4dGVudCBvZiB0aGUgZmlyc3QgaW5wdXQgcmFzdGVyIHRvIGRldGVybWluZSB0aGUgcHJvY2Vzc2luZyBleHRlbnQuXCIsXG5cdFwiQEBOb3QtRXF1YWxfRXh0ZW50LVR5cGVfdGFnMkBAXCI6IFwiSW50ZXJzZWN0aW9uIE9mLS1Vc2UgdGhlIGV4dGVudCBvZiB0aGUgb3ZlcmxhcHBpbmcgcGl4ZWxzIHRvIGRldGVybWluZSB0aGUgcHJvY2Vzc2luZyBleHRlbnQuIFRoaXMgaXMgdGhlIGRlZmF1bHQuXCIsXG5cdFwiQEBOb3QtRXF1YWxfRXh0ZW50LVR5cGVfdGFnM0BAXCI6IFwiTGFzdCBPZi0tVXNlIHRoZSBleHRlbnQgb2YgdGhlIGxhc3QgaW5wdXQgcmFzdGVyIHRvIGRldGVybWluZSB0aGUgcHJvY2Vzc2luZyBleHRlbnQuXCIsXG5cdFwiQEBOb3QtRXF1YWxfRXh0ZW50LVR5cGVfdGFnNEBAXCI6IFwiVW5pb24gT2YtLVVzZSB0aGUgZXh0ZW50IG9mIGFsbCB0aGUgcmFzdGVycyB0byBkZXRlcm1pbmUgdGhlIHByb2Nlc3NpbmcgZXh0ZW50LlwiLFxuXHRcIkBATm90LUVxdWFsX1Jhc3Rlcl90YWcwQEBcIjogXCJUaGUgaW5wdXQgdGhhdCB3aWxsIGJlIGNvbXBhcmVkIHRvIGZvciBpbmVxdWFsaXR5IGJ5IHRoZSBzZWNvbmQgaW5wdXQuXCIsXG5cdFwiQEBOb3QtRXF1YWxfUmFzdGVyX3RhZzFAQFwiOiBcIkEgY29uc3RhbnQgdmFsdWUgY2FuIGJlIHVzZWQgYXMgYW4gaW5wdXQgZm9yIHRoaXMgcGFyYW1ldGVyLCBwcm92aWRlZCBhIHJhc3RlciBpcyBzcGVjaWZpZWQgZm9yIHRoZSBvdGhlciBwYXJhbWV0ZXIuXCIsXG5cdFwiQEBOb3QtRXF1YWxfUmFzdGVyMl90YWcwQEBcIjogXCJUaGUgaW5wdXQgdGhhdCB3aWxsIGJlIGNvbXBhcmVkIHRvIHRoZSBmaXJzdCBpbnB1dCBmb3IgaW5lcXVhbGl0eS5cIixcblx0XCJAQE5vdC1FcXVhbF9SYXN0ZXIyX3RhZzFAQFwiOiBcIkEgY29uc3RhbnQgdmFsdWUgY2FuIGJlIHVzZWQgYXMgYW4gaW5wdXQgZm9yIHRoaXMgcGFyYW1ldGVyLCBwcm92aWRlZCBhIHJhc3RlciBpcyBzcGVjaWZpZWQgZm9yIHRoZSBvdGhlciBwYXJhbWV0ZXIuXCIsXG5cdFwiQEBQYW5zaGFycGVuaW5nX011bHRpc3BlY3RyYWxfdGFnMEBAXCI6IFwiVGhlIG11bHRpc3BlY3RyYWwgcmFzdGVyIHRoYXQgeW91IHdhbnQgdG8gc2hhcnBlbiB1c2luZyB0aGUgcGFuY2hyb21hdGljIGJhbmQuXCIsXG5cdFwiQEBQYW5zaGFycGVuaW5nX1BhbmNocm9tYXRpY190YWcwQEBcIjogXCJUaGUgaGlnaC1yZXNvbHV0aW9uLCBzaW5nbGUtYmFuZCByYXN0ZXIgdGhhdCB3aWxsIGJlIHVzZWQgdG8gcGFuIHNoYXJwZW4gdGhlIGxvd2VyLXJlc29sdXRpb24gbXVsdGlzcGVjdHJhbCByYXN0ZXIuXCIsXG5cdFwiQEBQYW5zaGFycGVuaW5nX1BhbnNoYXJwZW5pbmctVHlwZV90YWcwQEBcIjogXCJDaG9vc2UgdGhlIHBhbiBzaGFycGVuaW5nIGFsZ29yaXRobSB5b3Ugd2FudCB0byB1c2UuXCIsXG5cdFwiQEBQYW5zaGFycGVuaW5nX1BhbnNoYXJwZW5pbmctVHlwZV90YWcxQEBcIjogXCJCcm92ZXktLVVzZXMgdGhlIEJyb3ZleSBhbGdvcml0aG0gYmFzZWQgb24gc3BlY3RyYWwgbW9kZWxpbmcgZm9yIGRhdGEgZnVzaW9uLlwiLFxuXHRcIkBAUGFuc2hhcnBlbmluZ19QYW5zaGFycGVuaW5nLVR5cGVfdGFnMkBAXCI6IFwiRXNyaS0tVXNlcyB0aGUgRXNyaSBhbGdvcml0aG0gYmFzZWQgb24gc3BlY3RyYWwgbW9kZWxpbmcgZm9yIGRhdGEgZnVzaW9uLlwiLFxuXHRcIkBAUGFuc2hhcnBlbmluZ19QYW5zaGFycGVuaW5nLVR5cGVfdGFnM0BAXCI6IFwiR3JhbS1TY2htaWR0LS1Vc2VzIHRoZSBHcmFtLVNjaG1pZHQgc3BlY3RyYWwtc2hhcnBlbmluZyBhbGdvcml0aG0gdG8gc2hhcnBlbiBtdWx0aXNwZWN0cmFsIGRhdGEuXCIsXG5cdFwiQEBQYW5zaGFycGVuaW5nX1BhbnNoYXJwZW5pbmctVHlwZV90YWc0QEBcIjogXCJJSFMtLVVzZXMgSW50ZW5zaXR5LCBIdWUsIGFuZCBTYXR1cmF0aW9uIGNvbG9yIHNwYWNlIGZvciBkYXRhIGZ1c2lvbi5cIixcblx0XCJAQFBhbnNoYXJwZW5pbmdfUGFuc2hhcnBlbmluZy1UeXBlX3RhZzVAQFwiOiBcIk1lYW4tLVVzZXMgdGhlIGF2ZXJhZ2VkIHZhbHVlIGJldHdlZW4gdGhlIHJlZCwgZ3JlZW4sIGFuZCBibHVlIHZhbHVlcyBhbmQgdGhlIHBhbmNocm9tYXRpYyBwaXhlbCB2YWx1ZS5cIixcblx0XCJAQFBhbnNoYXJwZW5pbmdfV2VpZ2h0c190YWcwQEBcIjogXCJTcGVjaWZ5IHRoZSB3ZWlnaHRzIGZvciB0aGUgcmVkLCBncmVlbiwgYmx1ZSwgYW5kIGluZnJhcmVkIGJhbmRzLiBBbGwgdmFsdWVzIHNob3VsZCBiZSB3aXRoaW4gdGhlIHJhbmdlIG9mIDAgdG8gMS5cIixcblx0XCJAQFBhdGgtRGlzdGFuY2VfQWNjdW11bGF0aXZlLUNvc3QtUmVzaXN0YW5jZS1SYXRlX3RhZzBAQFwiOiBcIlRoaXMgcGFyYW1ldGVyIHNpbXVsYXRlcyB0aGUgaW5jcmVhc2UgaW4gdGhlIGVmZm9ydCB0byBvdmVyY29tZSBjb3N0cyBhcyB0aGUgYWNjdW11bGF0aXZlIGNvc3QgaW5jcmVhc2VzLiBJdCBpcyB1c2VkIHRvIG1vZGVsIGZhdGlndWUgb2YgdGhlIHRyYXZlbGVyLiBUaGUgZ3Jvd2luZyBhY2N1bXVsYXRpdmUgY29zdCB0byByZWFjaCBhIGNlbGwgaXMgbXVsdGlwbGllZCBieSB0aGUgcmVzaXN0YW5jZSByYXRlIGFuZCBhZGRlZCB0byB0aGUgY29zdCB0byBtb3ZlIGludG8gdGhlIHN1YnNlcXVlbnQgY2VsbC5cIixcblx0XCJAQFBhdGgtRGlzdGFuY2VfQWNjdW11bGF0aXZlLUNvc3QtUmVzaXN0YW5jZS1SYXRlX3RhZzFAQFwiOiBcIkl0J3MgYSBtb2RpZmllZCB2ZXJzaW9uIG9mIGEgY29tcG91bmQgaW50ZXJlc3QgcmF0ZSBmb3JtdWxhIHRoYXQncyB1c2VkIHRvIGNhbGN1bGF0ZSB0aGUgYXBwYXJlbnQgY29zdCBvZiBtb3ZpbmcgdGhyb3VnaCBhIGNlbGwuIEFzIHRoZSB2YWx1ZSBvZiB0aGUgcmVzaXN0YW5jZSByYXRlIGluY3JlYXNlcywgaXQgaW5jcmVhc2VzIHRoZSBjb3N0IG9mIHRoZSBjZWxscyB0aGF0IGFyZSB2aXNpdGVkIGxhdGVyLiBUaGUgZ3JlYXRlciB0aGUgcmVzaXN0YW5jZSByYXRlLCB0aGUgaGlnaGVyIHRoZSBjb3N0IHRvIHJlYWNoIHRoZSBuZXh0IGNlbGwsIHdoaWNoIGlzIGNvbXBvdW5kZWQgZm9yIGVhY2ggc3Vic2VxdWVudCBtb3ZlbWVudC4gU2luY2UgdGhlIHJlc2lzdGFuY2UgcmF0ZSBpcyBzaW1pbGFyIHRvIGEgY29tcG91bmQgcmF0ZSBhbmQgZ2VuZXJhbGx5IHRoZSBhY2N1bXVsYXRpdmUgY29zdCB2YWx1ZXMgYXJlIHZlcnkgbGFyZ2UsIHNtYWxsIHJlc2lzdGFuY2UgcmF0ZXMgYXJlIHN1Z2dlc3RlZCwgc3VjaCBhcyAwLjAwNSBvciBldmVuIHNtYWxsZXIsIGRlcGVuZGluZyBvbiB0aGUgYWNjdW11bGF0aXZlIGNvc3QgdmFsdWVzLlwiLFxuXHRcIkBAUGF0aC1EaXN0YW5jZV9BY2N1bXVsYXRpdmUtQ29zdC1SZXNpc3RhbmNlLVJhdGVfdGFnMkBAXCI6IFwiVGhlIHZhbHVlIG11c3QgYmUgZ3JlYXRlciB0aGFuIHplcm8uIFRoZSBkZWZhdWx0IGNhcGFjaXR5IGlzIHRvIHRoZSBlZGdlIG9mIHRoZSBvdXRwdXQgcmFzdGVyLlwiLFxuXHRcIkBAUGF0aC1EaXN0YW5jZV9DYXBhY2l0eV90YWcwQEBcIjogXCJEZWZpbmVzIHRoZSBjb3N0IGNhcGFjaXR5IGZvciB0aGUgdHJhdmVsZXIgZm9yIGEgc291cmNlLiBUaGUgY29zdCBjYWxjdWxhdGlvbnMgY29udGludWUgZm9yIGVhY2ggc291cmNlIHVudGlsIHRoZSBzcGVjaWZpZWQgY2FwYWNpdHkgaXMgcmVhY2hlZC5cIixcblx0XCJAQFBhdGgtRGlzdGFuY2VfQ2FwYWNpdHlfdGFnMUBAXCI6IFwiVGhlIHZhbHVlIG11c3QgYmUgZ3JlYXRlciB0aGFuIHplcm8uIFRoZSBkZWZhdWx0IGNhcGFjaXR5IGlzIHRvIHRoZSBlZGdlIG9mIHRoZSBvdXRwdXQgcmFzdGVyLlwiLFxuXHRcIkBAUGF0aC1EaXN0YW5jZV9Db3N0LVJhc3Rlcl90YWcwQEBcIjogXCJBIHJlcXVpcmVkIGlucHV0IHJhc3RlciBkZWZpbmluZyB0aGUgY29zdCBvciBpbXBlZGFuY2UgdG8gbW92ZSBwbGFuaW1ldHJpY2FsbHkgdGhyb3VnaCBlYWNoIGNlbGwuIFRoZSB2YWx1ZSBhdCBlYWNoIGNlbGwgbG9jYXRpb24gcmVwcmVzZW50cyB0aGUgY29zdC1wZXItdW5pdCBkaXN0YW5jZSBmb3IgbW92aW5nIHRocm91Z2ggaXQuIEVhY2ggY2VsbCBsb2NhdGlvbiB2YWx1ZSBpcyBtdWx0aXBsaWVkIGJ5IHRoZSBjZWxsIHJlc29sdXRpb24sIGFuZCBhbHNvIGNvbXBlbnNhdGVzIGZvciBkaWFnb25hbCBtb3ZlbWVudCB0byBvYnRhaW4gdGhlIHRvdGFsIGNvc3Qgb2YgcGFzc2luZyB0aHJvdWdoIHRoZSBjZWxsLlwiLFxuXHRcIkBAUGF0aC1EaXN0YW5jZV9Db3N0LVJhc3Rlcl90YWcxQEBcIjogXCJUaGUgdmFsdWVzIG9mIHRoZSA8c3Ryb25nPkNvc3QgUmFzdGVyPC9zdHJvbmc+IGNhbiBiZSBpbnRlZ2VyIG9yIGZsb2F0aW5nIHBvaW50LCBidXQgdGhleSBjYW5ub3QgYmUgbmVnYXRpdmUgb3IgemVyby5cIixcblx0XCJAQFBhdGgtRGlzdGFuY2VfaG9yaXpvbnRhbGZhY3Rvcl90YWcwQEBcIjogXCI8cD5EZWZpbmVzIHRoZSByZWxhdGlvbnNoaXAgYmV0d2VlbiB0aGUgaG9yaXpvbnRhbCBjb3N0IGZhY3RvciBhbmQgdGhlIGhvcml6b250YWwgcmVsYXRpdmUgbW92aW5nIGFuZ2xlIChIUk1BKS48L3A+PHA+VGhlcmUgYXJlIHNldmVyYWwgZmFjdG9ycyB3aXRoIG1vZGlmaWVycyB0aGF0IGlkZW50aWZ5IGEgZGVmaW5lZCB2ZXJ0aWNhbCBmYWN0b3IgZ3JhcGguIEFkZGl0aW9uYWxseSwgYSB0YWJsZSBjYW4gYmUgdXNlZCB0byBjcmVhdGUgYSBjdXN0b20gZ3JhcGguIFRoZSBncmFwaHMgYXJlIHVzZWQgdG8gaWRlbnRpZnkgdGhlIHZlcnRpY2FsIGZhY3RvciB1c2VkIGluIGNhbGN1bGF0aW5nIHRoZSB0b3RhbCBjb3N0IG9mIG1vdmluZyBpbnRvIGEgbmVpZ2hib3JpbmcgY2VsbC48L3A+PHA+SW4gdGhlIGV4cGxhbmF0aW9ucyBiZWxvdywgdHdvIGFjcm9ueW1zIGFyZSB1c2VkOiBIRiBhbmQgSFJNQS4gSEYgc3RhbmRzIGZvciBob3Jpem9udGFsIGZhY3Rvciwgd2hpY2ggZGVmaW5lcyB0aGUgaG9yaXpvbnRhbCBkaWZmaWN1bHR5IGVuY291bnRlcmVkIHdoZW4gbW92aW5nIGZyb20gb25lIGNlbGwgdG8gdGhlIG5leHQuIEhSTUEgc3RhbmRzIGZvciBob3Jpem9udGFsIHJlbGF0aXZlIG1vdmluZyBhbmdsZSwgd2hpY2ggaWRlbnRpZmllcyB0aGUgYW5nbGUgYmV0d2VlbiB0aGUgaG9yaXpvbnRhbCBkaXJlY3Rpb24gZnJvbSBhIGNlbGwgYW5kIHRoZSBtb3ZpbmcgZGlyZWN0aW9uLjwvcD48cD48c3Ryb25nPkhvcml6b250YWwgZmFjdG9yPC9zdHJvbmc+dHlwZXMgaW5jbHVkZSB0aGUgZm9sbG93aW5nOjwvcD48dWw+PGxpPjxzdHJvbmc+QmluYXJ5PC9zdHJvbmc+LS1JbmRpY2F0ZXMgdGhhdCBpZiB0aGUgSFJNQSBpcyBsZXNzIHRoYW4gdGhlIGN1dCBhbmdsZSwgdGhlIEhGIGlzIHNldCB0byB0aGUgdmFsdWUgYXNzb2NpYXRlZCB3aXRoIHRoZSB6ZXJvIGZhY3Rvcjsgb3RoZXJ3aXNlLCBpdCBpcyBpbmZpbml0eS48L2xpPjxsaT48c3Ryb25nPkZvcndhcmQ8L3N0cm9uZz4tLUVzdGFibGlzaGVzIHRoYXQgb25seSBmb3J3YXJkIG1vdmVtZW50IGlzIGFsbG93ZWQuIFRoZSBIUk1BIG11c3QgYmUgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIDAgYW5kIGxlc3MgdGhhbiA5MCBkZWdyZWVzICgwICZsdDs9IEhSTUEgJmx0OyA5MCkuIElmIHRoZSBIUk1BIGlzIGdyZWF0ZXIgdGhhbiAwIGFuZCBsZXNzIHRoYW4gNDUgZGVncmVlcywgdGhlIEhGIGZvciB0aGUgY2VsbCBpcyBzZXQgdG8gdGhlIHZhbHVlIGFzc29jaWF0ZWQgd2l0aCB0aGUgemVybyBmYWN0b3IuIElmIHRoZSBIUk1BIGlzIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byA0NSBkZWdyZWVzLCB0aGUgc2lkZSB2YWx1ZSBtb2RpZmllciB2YWx1ZSBpcyB1c2VkLiBUaGUgSEYgZm9yIGFueSBIUk1BIHZhbHVlIGVxdWFsIHRvIG9yIGdyZWF0ZXIgdGhhbiA5MCBkZWdyZWVzIGlzIHNldCB0byBpbmZpbml0eS48L2xpPjxsaT48c3Ryb25nPkxpbmVhcjwvc3Ryb25nPi0tU3BlY2lmaWVzIHRoYXQgdGhlIEhGIGlzIGEgbGluZWFyIGZ1bmN0aW9uIG9mIHRoZSBIUk1BLjwvbGk+PGxpPjxzdHJvbmc+SW52ZXJzZSBMaW5lYXI8L3N0cm9uZz4tLVNwZWNpZmllcyB0aGF0IHRoZSBIRiBpcyBhbiBpbnZlcnNlIGxpbmVhciBmdW5jdGlvbiBvZiB0aGUgSFJNQS48L2xpPjxsaT48c3Ryb25nPlRhYmxlPC9zdHJvbmc+LS1JZGVudGlmaWVzIHRoYXQgYSB0YWJsZSBmaWxlIHdpbGwgYmUgdXNlZCB0byBkZWZpbmUgdGhlIGhvcml6b250YWwgZmFjdG9yIGdyYXBoIHVzZWQgdG8gZGV0ZXJtaW5lIHRoZSBIRnMuPC9saT48L3VsPjxwPk1vZGlmaWVycyB0byB0aGUgaG9yaXpvbnRhbCBmYWN0b3JzIGluY2x1ZGUgdGhlIGZvbGxvd2luZzo8L3A+PHVsPjxsaT48c3Ryb25nPlplcm8gZmFjdG9yPC9zdHJvbmc+LS1UaGUgaG9yaXpvbnRhbCBmYWN0b3IgdG8gYmUgdXNlZCB3aGVuIHRoZSBIUk1BIGlzIHplcm8uIFRoaXMgZmFjdG9yIHBvc2l0aW9ucyB0aGUgeS1pbnRlcmNlcHQgZm9yIGFueSBvZiB0aGUgaG9yaXpvbnRhbCBmYWN0b3IgZnVuY3Rpb25zLjwvbGk+PGxpPjxzdHJvbmc+Q3V0IGFuZ2xlPC9zdHJvbmc+LS1EZWZpbmVzIHRoZSBIUk1BIGFuZ2xlIGJleW9uZCB3aGljaCB0aGUgSEYgd2lsbCBiZSBzZXQgdG8gaW5maW5pdHkuPC9saT48bGk+PHN0cm9uZz5TbG9wZTwvc3Ryb25nPi0tRXN0YWJsaXNoZXMgdGhlIHNsb3BlIG9mIHRoZSBzdHJhaWdodCBsaW5lIHVzZWQgd2l0aCB0aGU8c3Ryb25nPkxpbmVhcjwvc3Ryb25nPmFuZDxzdHJvbmc+SW52ZXJzZSBMaW5lYXI8L3N0cm9uZz5ob3Jpem9udGFsIGZhY3RvciBrZXl3b3Jkcy4gVGhlIHNsb3BlIGlzIHNwZWNpZmllZCBhcyBhIGZyYWN0aW9uIG9mIHJpc2Ugb3ZlciBydW4gKGZvciBleGFtcGxlLCA0NSBwZXJjZW50IHNsb3BlIGlzIDEvNDUsIHdoaWNoIGlzIGlucHV0IGFzIDAuMDIyMjIpLjwvbGk+PGxpPjxzdHJvbmc+U2lkZSB2YWx1ZTwvc3Ryb25nPi0tRXN0YWJsaXNoZXMgdGhlIEhGIHdoZW4gdGhlIEhSTUEgaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIDQ1IGRlZ3JlZXMgYW5kIGxlc3MgdGhhbiA5MCBkZWdyZWVzIHdoZW4gdGhlPHN0cm9uZz5Gb3J3YXJkPC9zdHJvbmc+aG9yaXpvbnRhbCBmYWN0b3Iga2V5d29yZCBpcyBzcGVjaWZpZWQuPC9saT48bGk+PHN0cm9uZz5UYWJsZSBuYW1lPC9zdHJvbmc+LS1JZGVudGlmaWVzIHRoZSBuYW1lIG9mIHRoZSB0YWJsZSBkZWZpbmluZyB0aGUgSEYuPC9saT48L3VsPlwiLFxuXHRcIkBAUGF0aC1EaXN0YW5jZV9Ib3Jpem9udGFsLVJhc3Rlcl90YWcwQEBcIjogXCJBIHJhc3RlciBkZWZpbmluZyB0aGUgaG9yaXpvbnRhbCBkaXJlY3Rpb24gYXQgZWFjaCBjZWxsLlwiLFxuXHRcIkBAUGF0aC1EaXN0YW5jZV9Ib3Jpem9udGFsLVJhc3Rlcl90YWcxQEBcIjogXCJUaGUgdmFsdWVzIG9uIHRoZSByYXN0ZXIgbXVzdCBiZSBpbnRlZ2VycyByYW5naW5nIGZyb20gMCB0byAzNjAsIHdpdGggMCBkZWdyZWVzIGJlaW5nIG5vcnRoLCBvciB0b3dhcmQgdGhlIHRvcCBvZiB0aGUgc2NyZWVuLCBhbmQgaW5jcmVhc2luZyBjbG9ja3dpc2UuIEZsYXQgYXJlYXMgc2hvdWxkIGJlIGdpdmVuIGEgdmFsdWUgb2YgLTEuIFRoZSB2YWx1ZXMgYXQgZWFjaCBsb2NhdGlvbiB3aWxsIGJlIHVzZWQgaW4gY29uanVuY3Rpb24gd2l0aCB0aGUgPHN0cm9uZz5Ib3Jpem9udGFsIGZhY3Rvcjwvc3Ryb25nPiB0byBkZXRlcm1pbmUgdGhlIGhvcml6b250YWwgY29zdCBpbmN1cnJlZCB3aGVuIG1vdmluZyBmcm9tIGEgY2VsbCB0byBpdHMgbmVpZ2hib3JzLlwiLFxuXHRcIkBAUGF0aC1EaXN0YW5jZV9NYXhpbXVtLURpc3RhbmNlX3RhZzBAQFwiOiBcIlRoZSB0aHJlc2hvbGQgdGhhdCB0aGUgYWNjdW11bGF0aXZlIGNvc3QgdmFsdWVzIGNhbm5vdCBleGNlZWQuIElmIGFuIGFjY3VtdWxhdGl2ZSBjb3N0IGRpc3RhbmNlIGV4Y2VlZHMgdGhpcyB2YWx1ZSwgdGhlIG91dHB1dCB2YWx1ZSBmb3IgdGhlIGNlbGwgbG9jYXRpb24gd2lsbCBiZSBOb0RhdGEuIFRoZSBtYXhpbXVtIGRpc3RhbmNlIGRlZmluZXMgdGhlIGV4dGVudCBmb3Igd2hpY2ggdGhlIGFjY3VtdWxhdGl2ZSBjb3N0IGRpc3RhbmNlcyBhcmUgY2FsY3VsYXRlZC4gVGhlIGRlZmF1bHQgZGlzdGFuY2UgaXMgdG8gdGhlIGV4dGVudCBvZiB0aGUgb3V0cHV0IHJhc3Rlci5cIixcblx0XCJAQFBhdGgtRGlzdGFuY2VfTXVsdGlwbGllci10by1BcHBseS10by1Db3N0c190YWcwQEBcIjogXCJBIG11bHRpcGxpZXIgdG8gYXBwbHkgdG8gdGhlIGNvc3QgdmFsdWVzLlwiLFxuXHRcIkBAUGF0aC1EaXN0YW5jZV9NdWx0aXBsaWVyLXRvLUFwcGx5LXRvLUNvc3RzX3RhZzFAQFwiOiBcIlRoaXMgcGFyYW1ldGVyIGFsbG93cyBmb3IgY29udHJvbCBvZiB0aGUgbW9kZSBvZiB0cmF2ZWwgb3IgdGhlIG1hZ25pdHVkZSBhdCBhIHNvdXJjZS4gVGhlIGdyZWF0ZXIgdGhlIG11bHRpcGxpZXIsIHRoZSBncmVhdGVyIHRoZSBjb3N0IHRvIG1vdmUgdGhyb3VnaCBlYWNoIGNlbGwuXCIsXG5cdFwiQEBQYXRoLURpc3RhbmNlX011bHRpcGxpZXItdG8tQXBwbHktdG8tQ29zdHNfdGFnMkBAXCI6IFwiVGhlIHZhbHVlcyBtdXN0IGJlIGdyZWF0ZXIgdGhhbiB6ZXJvLiBUaGUgZGVmYXVsdCBpcyAxLlwiLFxuXHRcIkBAUGF0aC1EaXN0YW5jZV9NdWx0aXBsaWVyLXRvLUFwcGx5LXRvLUNvc3RzX3RhZzNAQFwiOiBcIkEgbnVtZXJpYyAoZG91YmxlKSB2YWx1ZSBvciBhIGZpZWxkIGZyb20gdGhlIDxzdHJvbmc+U291cmNlIFJhc3Rlcjwvc3Ryb25nPiBjYW4gYmUgdXNlZCBmb3IgdGhpcyBwYXJhbWV0ZXIuXCIsXG5cdFwiQEBQYXRoLURpc3RhbmNlX1NvdXJjZS1SYXN0ZXJfdGFnMEBAXCI6IFwiVGhlIHJlcXVpcmVkIGlucHV0IHJhc3RlciBvZiBzb3VyY2UgbG9jYXRpb25zLlwiLFxuXHRcIkBAUGF0aC1EaXN0YW5jZV9Tb3VyY2UtUmFzdGVyX3RhZzFAQFwiOiBcIlRoaXMgaXMgYSByYXN0ZXIgdGhhdCBpZGVudGlmaWVzIHRoZSBjZWxscyBvciBsb2NhdGlvbnMgZnJvbSB3aGljaCB0aGUgbGVhc3QgYWNjdW11bGF0ZWQgY29zdCBkaXN0YW5jZSBmb3IgZXZlcnkgb3V0cHV0IGNlbGwgbG9jYXRpb24gaXMgY2FsY3VsYXRlZC5cIixcblx0XCJAQFBhdGgtRGlzdGFuY2VfU291cmNlLVJhc3Rlcl90YWcyQEBcIjogXCJJdCBjYW4gYmUgYW4gaW50ZWdlciBvciBhIGZsb2F0aW5nLXBvaW50IHR5cGUuXCIsXG5cdFwiQEBQYXRoLURpc3RhbmNlX1N0YXJ0LUNvc3RfdGFnMEBAXCI6IFwiVGhlIHN0YXJ0aW5nIGNvc3QgZnJvbSB3aGljaCB0byBiZWdpbiB0aGUgY29zdCBjYWxjdWxhdGlvbnMuIFRoaXMgcGFyYW1ldGVyIGFsbG93cyBmb3IgdGhlIHNwZWNpZmljYXRpb24gb2YgdGhlIGZpeGVkIGNvc3QgYXNzb2NpYXRlZCB3aXRoIGEgc291cmNlLiBJbnN0ZWFkIG9mIHN0YXJ0aW5nIGF0IGEgY29zdCBvZiAwLCB0aGUgY29zdCBhbGdvcml0aG0gd2lsbCBiZWdpbiB3aXRoIHRoZSB2YWx1ZSBzcGVjaWZpZWQuXCIsXG5cdFwiQEBQYXRoLURpc3RhbmNlX1N0YXJ0LUNvc3RfdGFnMUBAXCI6IFwiVGhlIHZhbHVlIG11c3QgYmUgemVybyBvciBncmVhdGVyLiBUaGUgZGVmYXVsdCBpcyAwLlwiLFxuXHRcIkBAUGF0aC1EaXN0YW5jZV9TdXJmYWNlLVJhc3Rlcl90YWcwQEBcIjogXCJBIHJhc3RlciBkZWZpbmluZyB0aGUgZWxldmF0aW9uIHZhbHVlcyBhdCBlYWNoIGNlbGwgbG9jYXRpb24uXCIsXG5cdFwiQEBQYXRoLURpc3RhbmNlX1N1cmZhY2UtUmFzdGVyX3RhZzFAQFwiOiBcIlRoZSB2YWx1ZXMgYXJlIHVzZWQgdG8gY2FsY3VsYXRlIHRoZSBhY3R1YWwgc3VyZmFjZSBkaXN0YW5jZSBjb3ZlcmVkIHdoZW4gcGFzc2luZyBiZXR3ZWVuIGNlbGxzLlwiLFxuXHRcIkBAUGF0aC1EaXN0YW5jZV9UcmF2ZWwtRGlyZWN0aW9uX3RhZzBAQFwiOiBcIkRlZmluZXMgdGhlIGRpcmVjdGlvbiBvZiB0aGUgdHJhdmVsZXIgd2hlbiBhcHBseWluZyB0aGUgc291cmNlIHJlc2lzdGFuY2UgcmF0ZSBhbmQgdGhlIHNvdXJjZSBzdGFydGluZyBjb3N0LlwiLFxuXHRcIkBAUGF0aC1EaXN0YW5jZV9UcmF2ZWwtRGlyZWN0aW9uX3RhZzFAQFwiOiBcIjxzdHJvbmc+RnJvbSBTb3VyY2U8L3N0cm9uZz4tLVRoZSBzb3VyY2UgcmVzaXN0YW5jZSByYXRlIGFuZCBzb3VyY2Ugc3RhcnRpbmcgY29zdCB3aWxsIGJlIGFwcGxpZWQgYmVnaW5uaW5nIGF0IHRoZSBpbnB1dCBzb3VyY2UgYW5kIG1vdmluZyBvdXQgdG8gdGhlIG5vbi1zb3VyY2UgY2VsbHMuIFRoaXMgaXMgdGhlIGRlZmF1bHQuXCIsXG5cdFwiQEBQYXRoLURpc3RhbmNlX1RyYXZlbC1EaXJlY3Rpb25fdGFnM0BAXCI6IFwiPHN0cm9uZz5UbyBTb3VyY2U8L3N0cm9uZz4tLVRoZSBzb3VyY2UgcmVzaXN0YW5jZSByYXRlIGFuZCBzb3VyY2Ugc3RhcnRpbmcgY29zdCB3aWxsIGJlIGFwcGxpZWQgYmVnaW5uaW5nIGF0IGVhY2ggbm9uLXNvdXJjZSBjZWxsIGFuZCBtb3ZpbmcgYmFjayB0byB0aGUgaW5wdXQgc291cmNlLlwiLFxuXHRcIkBAUGF0aC1EaXN0YW5jZV9UcmF2ZWwtRGlyZWN0aW9uX3RhZzVAQFwiOiBcIkVpdGhlciBzcGVjaWZ5IHRoZSA8c3Ryb25nPkZyb20gU291cmNlPC9zdHJvbmc+IG9yIDxzdHJvbmc+VG8gU291cmNlPC9zdHJvbmc+IGtleXdvcmQsIHdoaWNoIHdpbGwgYmUgYXBwbGllZCB0byBhbGwgc291cmNlcywgb3Igc3BlY2lmeSBhIGZpZWxkIGluIHRoZSA8c3Ryb25nPlNvdXJjZSBSYXN0ZXI8L3N0cm9uZz4gdGhhdCBjb250YWlucyB0aGUga2V5d29yZHMgdG8gaWRlbnRpZnkgdGhlIGRpcmVjdGlvbiBvZiB0cmF2ZWwgZm9yIGVhY2ggc291cmNlLiBUaGF0IGZpZWxkIG11c3QgY29udGFpbiB0aGUgc3RyaW5nICR7RlJPTV9TT1VSQ0V9IG9yICR7VE9fU09VUkNFfS5cIixcblx0XCJAQFBhdGgtRGlzdGFuY2VfdmVydGljYWxmYWN0b3JfdGFnMEBAXCI6IFwiPHA+RGVmaW5lcyB0aGUgcmVsYXRpb25zaGlwIGJldHdlZW4gdGhlIHZlcnRpY2FsIGNvc3QgZmFjdG9yIGFuZCB0aGUgdmVydGljYWwgcmVsYXRpdmUgbW92aW5nIGFuZ2xlIChWUk1BKS48L3A+PHA+VGhlcmUgYXJlIHNldmVyYWwgZmFjdG9ycyB3aXRoIG1vZGlmaWVycyB0aGF0IGlkZW50aWZ5IGEgZGVmaW5lZCB2ZXJ0aWNhbCBmYWN0b3IgZ3JhcGguIEFkZGl0aW9uYWxseSwgYSB0YWJsZSBjYW4gYmUgdXNlZCB0byBjcmVhdGUgYSBjdXN0b20gZ3JhcGguIFRoZSBncmFwaHMgYXJlIHVzZWQgdG8gaWRlbnRpZnkgdGhlIHZlcnRpY2FsIGZhY3RvciB1c2VkIGluIGNhbGN1bGF0aW5nIHRoZSB0b3RhbCBjb3N0IG9mIG1vdmluZyBpbnRvIGEgbmVpZ2hib3JpbmcgY2VsbC48L3A+PHA+SW4gdGhlIGV4cGxhbmF0aW9ucyBiZWxvdywgdHdvIGFjcm9ueW1zIGFyZSB1c2VkOiBWRiBhbmQgVlJNQS4gVkYgc3RhbmRzIGZvciB2ZXJ0aWNhbCBmYWN0b3IsIHdoaWNoIGRlZmluZXMgdGhlIHZlcnRpY2FsIGRpZmZpY3VsdHkgZW5jb3VudGVyZWQgaW4gbW92aW5nIGZyb20gb25lIGNlbGwgdG8gdGhlIG5leHQuIFZSTUEgc3RhbmRzIGZvciB2ZXJ0aWNhbCByZWxhdGl2ZSBtb3ZpbmcgYW5nbGUsIHdoaWNoIGlkZW50aWZpZXMgdGhlIHNsb3BlIGFuZ2xlIGJldHdlZW4gdGhlIEZST00sIG9yIHByb2Nlc3NpbmcsIGNlbGwgYW5kIHRoZSBUTyBjZWxsLjwvcD48cD48c3Ryb25nPlZlcnRpY2FsIGZhY3Rvcjwvc3Ryb25nPnR5cGVzIGluY2x1ZGUgdGhlIGZvbGxvd2luZzo8L3A+PHVsPjxsaT48c3Ryb25nPkJpbmFyeTwvc3Ryb25nPi0tU3BlY2lmaWVzIHRoYXQgaWYgdGhlIFZSTUEgaXMgZ3JlYXRlciB0aGFuIHRoZSBsb3ctY3V0IGFuZ2xlIGFuZCBsZXNzIHRoYW4gdGhlIGhpZ2gtY3V0IGFuZ2xlLCB0aGUgVkYgaXMgc2V0IHRvIHRoZSB2YWx1ZSBhc3NvY2lhdGVkIHdpdGggdGhlIHplcm8gZmFjdG9yOyBvdGhlcndpc2UsIGl0IGlzIGluZmluaXR5LjwvbGk+PGxpPjxzdHJvbmc+TGluZWFyPC9zdHJvbmc+LS1JbmRpY2F0ZXMgdGhhdCB0aGUgVkYgaXMgYSBsaW5lYXIgZnVuY3Rpb24gb2YgdGhlIFZSTUEuPC9saT48bGk+PHN0cm9uZz5TeW1tZXRyaWMgTGluZWFyPC9zdHJvbmc+LS1TcGVjaWZpZXMgdGhhdCB0aGUgVkYgaXMgYSBsaW5lYXIgZnVuY3Rpb24gb2YgdGhlIFZSTUEgaW4gZWl0aGVyIHRoZSBuZWdhdGl2ZSBvciBwb3NpdGl2ZSBzaWRlIG9mIHRoZSBWUk1BLCByZXNwZWN0aXZlbHksIGFuZCB0aGUgdHdvIGxpbmVhciBmdW5jdGlvbnMgYXJlIHN5bW1ldHJpY2FsIHdpdGggcmVzcGVjdCB0byB0aGUgVkYgKHkpIGF4aXMuPC9saT48bGk+PHN0cm9uZz5JbnZlcnNlIExpbmVhcjwvc3Ryb25nPi0tSW5kaWNhdGVzIHRoYXQgdGhlIFZGIGlzIGFuIGludmVyc2UgbGluZWFyIGZ1bmN0aW9uIG9mIHRoZSBWUk1BLjwvbGk+PGxpPjxzdHJvbmc+U3ltbWV0cmljIEludmVyc2UgTGluZWFyPC9zdHJvbmc+LS1TcGVjaWZpZXMgdGhhdCB0aGUgVkYgaXMgYW4gaW52ZXJzZSBsaW5lYXIgZnVuY3Rpb24gb2YgdGhlIFZSTUEgaW4gZWl0aGVyIHRoZSBuZWdhdGl2ZSBvciBwb3NpdGl2ZSBzaWRlIG9mIHRoZSBWUk1BLCByZXNwZWN0aXZlbHksIGFuZCB0aGUgdHdvIGxpbmVhciBmdW5jdGlvbnMgYXJlIHN5bW1ldHJpY2FsIHdpdGggcmVzcGVjdCB0byB0aGUgVkYgKHkpIGF4aXMuPC9saT48bGk+PHN0cm9uZz5Db3M8L3N0cm9uZz4tLUlkZW50aWZpZXMgdGhlIFZGIGFzIHRoZSBjb3NpbmUtYmFzZWQgZnVuY3Rpb24gb2YgdGhlIFZSTUEuPC9saT48bGk+PHN0cm9uZz5TZWM8L3N0cm9uZz4tLUlkZW50aWZpZXMgdGhlIFZGIGFzIHRoZSBzZWNhbnQtYmFzZWQgZnVuY3Rpb24gb2YgdGhlIFZSTUEuPC9saT48bGk+PHN0cm9uZz5Db3MtU2VjPC9zdHJvbmc+LS1TcGVjaWZpZXMgdGhhdCB0aGUgVkYgaXMgdGhlIGNvc2luZS1iYXNlZCBmdW5jdGlvbiBvZiB0aGUgVlJNQSB3aGVuIHRoZSBWUk1BIGlzIG5lZ2F0aXZlIGFuZCB0aGUgc2VjYW50LWJhc2VkIGZ1bmN0aW9uIG9mIHRoZSBWUk1BIHdoZW4gdGhlIFZSTUEgaXMgbm90IG5lZ2F0aXZlLjwvbGk+PGxpPjxzdHJvbmc+U2VjLUNvczwvc3Ryb25nPi0tU3BlY2lmaWVzIHRoYXQgdGhlIFZGIGlzIHRoZSBzZWNhbnQtYmFzZWQgZnVuY3Rpb24gb2YgdGhlIFZSTUEgd2hlbiB0aGUgVlJNQSBpcyBuZWdhdGl2ZSBhbmQgdGhlIGNvc2luZS1iYXNlZCBmdW5jdGlvbiBvZiB0aGUgVlJNQSB3aGVuIHRoZSBWUk1BIGlzIG5vdCBuZWdhdGl2ZS48L2xpPjxsaT48c3Ryb25nPlRhYmxlPC9zdHJvbmc+LS1JZGVudGlmaWVzIHRoYXQgYSB0YWJsZSBmaWxlIHdpbGwgYmUgdXNlZCB0byBkZWZpbmUgdGhlIHZlcnRpY2FsLWZhY3RvciBncmFwaCB0aGF0IGlzIHVzZWQgdG8gZGV0ZXJtaW5lIHRoZSBWRnMuPC9saT48L3VsPjxwPk1vZGlmaWVycyB0byB0aGUgdmVydGljYWwga2V5d29yZHMgaW5jbHVkZSB0aGUgZm9sbG93aW5nOjwvcD48dWw+PGxpPjxzdHJvbmc+WmVybyBmYWN0b3I8L3N0cm9uZz4tLUVzdGFibGlzaGVzIHRoZSB2ZXJ0aWNhbCBmYWN0b3IgdXNlZCB3aGVuIHRoZSBWUk1BIGlzIHplcm8uIFRoaXMgZmFjdG9yIHBvc2l0aW9ucyB0aGUgeS1pbnRlcmNlcHQgb2YgdGhlIHNwZWNpZmllZCBmdW5jdGlvbi4gQnkgZGVmaW5pdGlvbiwgdGhlIHplcm8gZmFjdG9yIGlzIG5vdCBhcHBsaWNhYmxlIHRvIGFueSBvZiB0aGUgdHJpZ29ub21ldHJpYyB2ZXJ0aWNhbCBmdW5jdGlvbnMgKENPUywgU0VDLCBDT1MtU0VDLCBvciBTRUMtQ09TKS4gVGhlIHktaW50ZXJjZXB0IGlzIGRlZmluZWQgYnkgdGhlc2UgZnVuY3Rpb25zLjwvbGk+PGxpPjxzdHJvbmc+TG93IEN1dCBhbmdsZTwvc3Ryb25nPi0tRGVmaW5lcyB0aGUgVlJNQSBhbmdsZSBiZWxvdyB3aGljaCB0aGUgVkYgd2lsbCBiZSBzZXQgdG8gaW5maW5pdHkuPC9saT48bGk+PHN0cm9uZz5IaWdoIEN1dCBhbmdsZTwvc3Ryb25nPi0tRGVmaW5lcyB0aGUgVlJNQSBhbmdsZSBhYm92ZSB3aGljaCB0aGUgVkYgd2lsbCBiZSBzZXQgdG8gaW5maW5pdHkuPC9saT48bGk+PHN0cm9uZz5TbG9wZTwvc3Ryb25nPi0tRXN0YWJsaXNoZXMgdGhlIHNsb3BlIG9mIHRoZSBzdHJhaWdodCBsaW5lIHVzZWQgd2l0aCB0aGU8c3Ryb25nPkxpbmVhcjwvc3Ryb25nPmFuZDxzdHJvbmc+SW52ZXJzZSBMaW5lYXI8L3N0cm9uZz52ZXJ0aWNhbC1mYWN0b3Iga2V5d29yZHMuIFRoZSBzbG9wZSBpcyBzcGVjaWZpZWQgYXMgYSBmcmFjdGlvbiBvZiByaXNlIG92ZXIgcnVuIChmb3IgZXhhbXBsZSwgNDUgcGVyY2VudCBzbG9wZSBpcyAxLzQ1LCB3aGljaCBpcyBpbnB1dCBhcyAwLjAyMjIyKS48L2xpPjxsaT48c3Ryb25nPlRhYmxlIG5hbWU8L3N0cm9uZz4tLUlkZW50aWZpZXMgdGhlIG5hbWUgb2YgdGhlIHRhYmxlIGRlZmluaW5nIHRoZSBWRi48L2xpPjwvdWw+XCIsXG5cdFwiQEBQYXRoLURpc3RhbmNlX1ZlcnRpY2FsLVJhc3Rlcl90YWcwQEBcIjogXCJEZWZpbmVzIHRoZSByZWxhdGlvbnNoaXAgYmV0d2VlbiB0aGUgdmVydGljYWwgY29zdCBmYWN0b3IgYW5kIHRoZSB2ZXJ0aWNhbCByZWxhdGl2ZSBtb3ZpbmcgYW5nbGUgKFZSTUEpLlwiLFxuXHRcIkBAUGF0aC1EaXN0YW5jZV9WZXJ0aWNhbC1SYXN0ZXJfdGFnMUBAXCI6IFwiVGhlIHZhbHVlcyBhcmUgdXNlZCBmb3IgY2FsY3VsYXRpbmcgdGhlIHNsb3BlIHVzZWQgdG8gaWRlbnRpZnkgdGhlIHZlcnRpY2FsIGZhY3RvciBpbmN1cnJlZCB3aGVuIG1vdmluZyBmcm9tIG9uZSBjZWxsIHRvIGFub3RoZXIuXCIsXG5cdFwiQEBQYXRoLURpc3RhbmNlLUFsbG9jYXRpb25fQWNjdW11bGF0aXZlLUNvc3QtUmVzaXN0YW5jZS1SYXRlX3RhZzBAQFwiOiBcIlRoaXMgcGFyYW1ldGVyIHNpbXVsYXRlcyB0aGUgaW5jcmVhc2UgaW4gdGhlIGVmZm9ydCB0byBvdmVyY29tZSBjb3N0cyBhcyB0aGUgYWNjdW11bGF0aXZlIGNvc3QgaW5jcmVhc2VzLiBJdCBpcyB1c2VkIHRvIG1vZGVsIGZhdGlndWUgb2YgdGhlIHRyYXZlbGVyLiBUaGUgZ3Jvd2luZyBhY2N1bXVsYXRpdmUgY29zdCB0byByZWFjaCBhIGNlbGwgaXMgbXVsdGlwbGllZCBieSB0aGUgcmVzaXN0YW5jZSByYXRlIGFuZCBhZGRlZCB0byB0aGUgY29zdCB0byBtb3ZlIGludG8gdGhlIHN1YnNlcXVlbnQgY2VsbC5cIixcblx0XCJAQFBhdGgtRGlzdGFuY2UtQWxsb2NhdGlvbl9BY2N1bXVsYXRpdmUtQ29zdC1SZXNpc3RhbmNlLVJhdGVfdGFnMUBAXCI6IFwiSXQncyBhIG1vZGlmaWVkIHZlcnNpb24gb2YgYSBjb21wb3VuZCBpbnRlcmVzdCByYXRlIGZvcm11bGEgdGhhdCdzIHVzZWQgdG8gY2FsY3VsYXRlIHRoZSBhcHBhcmVudCBjb3N0IG9mIG1vdmluZyB0aHJvdWdoIGEgY2VsbC4gQXMgdGhlIHZhbHVlIG9mIHRoZSByZXNpc3RhbmNlIHJhdGUgaW5jcmVhc2VzLCBpdCBpbmNyZWFzZXMgdGhlIGNvc3Qgb2YgdGhlIGNlbGxzIHRoYXQgYXJlIHZpc2l0ZWQgbGF0ZXIuIFRoZSBncmVhdGVyIHRoZSByZXNpc3RhbmNlIHJhdGUsIHRoZSBoaWdoZXIgdGhlIGNvc3QgdG8gcmVhY2ggdGhlIG5leHQgY2VsbCwgd2hpY2ggaXMgY29tcG91bmRlZCBmb3IgZWFjaCBzdWJzZXF1ZW50IG1vdmVtZW50LiBTaW5jZSB0aGUgcmVzaXN0YW5jZSByYXRlIGlzIHNpbWlsYXIgdG8gYSBjb21wb3VuZCByYXRlIGFuZCBnZW5lcmFsbHkgdGhlIGFjY3VtdWxhdGl2ZSBjb3N0IHZhbHVlcyBhcmUgdmVyeSBsYXJnZSwgc21hbGwgcmVzaXN0YW5jZSByYXRlcyBhcmUgc3VnZ2VzdGVkLCBzdWNoIGFzIDAuMDA1IG9yIGV2ZW4gc21hbGxlciwgZGVwZW5kaW5nIG9uIHRoZSBhY2N1bXVsYXRpdmUgY29zdCB2YWx1ZXMuXCIsXG5cdFwiQEBQYXRoLURpc3RhbmNlLUFsbG9jYXRpb25fQWNjdW11bGF0aXZlLUNvc3QtUmVzaXN0YW5jZS1SYXRlX3RhZzJAQFwiOiBcIlRoZSB2YWx1ZSBtdXN0IGJlIGdyZWF0ZXIgdGhhbiB6ZXJvLiBUaGUgZGVmYXVsdCBjYXBhY2l0eSBpcyB0byB0aGUgZWRnZSBvZiB0aGUgb3V0cHV0IHJhc3Rlci5cIixcblx0XCJAQFBhdGgtRGlzdGFuY2UtQWxsb2NhdGlvbl9DYXBhY2l0eV90YWcwQEBcIjogXCJEZWZpbmVzIHRoZSBjb3N0IGNhcGFjaXR5IGZvciB0aGUgdHJhdmVsZXIgZm9yIGEgc291cmNlLiBUaGUgY29zdCBjYWxjdWxhdGlvbnMgY29udGludWUgZm9yIGVhY2ggc291cmNlIHVudGlsIHRoZSBzcGVjaWZpZWQgY2FwYWNpdHkgaXMgcmVhY2hlZC5cIixcblx0XCJAQFBhdGgtRGlzdGFuY2UtQWxsb2NhdGlvbl9DYXBhY2l0eV90YWcxQEBcIjogXCJUaGUgdmFsdWUgbXVzdCBiZSBncmVhdGVyIHRoYW4gemVyby4gVGhlIGRlZmF1bHQgY2FwYWNpdHkgaXMgdG8gdGhlIGVkZ2Ugb2YgdGhlIG91dHB1dCByYXN0ZXIuXCIsXG5cdFwiQEBQYXRoLURpc3RhbmNlLUFsbG9jYXRpb25fQ29zdC1SYXN0ZXJfdGFnMEBAXCI6IFwiQSByZXF1aXJlZCBpbnB1dCByYXN0ZXIgZGVmaW5pbmcgdGhlIGNvc3Qgb3IgaW1wZWRhbmNlIHRvIG1vdmUgcGxhbmltZXRyaWNhbGx5IHRocm91Z2ggZWFjaCBjZWxsLiBUaGUgdmFsdWUgYXQgZWFjaCBjZWxsIGxvY2F0aW9uIHJlcHJlc2VudHMgdGhlIGNvc3QtcGVyLXVuaXQgZGlzdGFuY2UgZm9yIG1vdmluZyB0aHJvdWdoIGl0LiBFYWNoIGNlbGwgbG9jYXRpb24gdmFsdWUgaXMgbXVsdGlwbGllZCBieSB0aGUgY2VsbCByZXNvbHV0aW9uLCBhbmQgYWxzbyBjb21wZW5zYXRlcyBmb3IgZGlhZ29uYWwgbW92ZW1lbnQgdG8gb2J0YWluIHRoZSB0b3RhbCBjb3N0IG9mIHBhc3NpbmcgdGhyb3VnaCB0aGUgY2VsbC5cIixcblx0XCJAQFBhdGgtRGlzdGFuY2UtQWxsb2NhdGlvbl9Db3N0LVJhc3Rlcl90YWcxQEBcIjogXCJUaGUgdmFsdWVzIG9mIHRoZSA8c3Ryb25nPkNvc3QgUmFzdGVyPC9zdHJvbmc+IGNhbiBiZSBpbnRlZ2VyIG9yIGZsb2F0aW5nIHBvaW50LCBidXQgdGhleSBjYW5ub3QgYmUgbmVnYXRpdmUgb3IgemVyby5cIixcblx0XCJAQFBhdGgtRGlzdGFuY2UtQWxsb2NhdGlvbl9ob3Jpem9udGFsZmFjdG9yX3RhZzBAQFwiOiBcIjxwPkRlZmluZXMgdGhlIHJlbGF0aW9uc2hpcCBiZXR3ZWVuIHRoZSBob3Jpem9udGFsIGNvc3QgZmFjdG9yIGFuZCB0aGUgaG9yaXpvbnRhbCByZWxhdGl2ZSBtb3ZpbmcgYW5nbGUgKEhSTUEpLjwvcD48cD5UaGVyZSBhcmUgc2V2ZXJhbCBmYWN0b3JzIHdpdGggbW9kaWZpZXJzIHRoYXQgaWRlbnRpZnkgYSBkZWZpbmVkIHZlcnRpY2FsIGZhY3RvciBncmFwaC4gQWRkaXRpb25hbGx5LCBhIHRhYmxlIGNhbiBiZSB1c2VkIHRvIGNyZWF0ZSBhIGN1c3RvbSBncmFwaC4gVGhlIGdyYXBocyBhcmUgdXNlZCB0byBpZGVudGlmeSB0aGUgdmVydGljYWwgZmFjdG9yIHVzZWQgaW4gY2FsY3VsYXRpbmcgdGhlIHRvdGFsIGNvc3Qgb2YgbW92aW5nIGludG8gYSBuZWlnaGJvcmluZyBjZWxsLjwvcD48cD5JbiB0aGUgZXhwbGFuYXRpb25zIGJlbG93LCB0d28gYWNyb255bXMgYXJlIHVzZWQ6IEhGIGFuZCBIUk1BLiBIRiBzdGFuZHMgZm9yIGhvcml6b250YWwgZmFjdG9yLCB3aGljaCBkZWZpbmVzIHRoZSBob3Jpem9udGFsIGRpZmZpY3VsdHkgZW5jb3VudGVyZWQgd2hlbiBtb3ZpbmcgZnJvbSBvbmUgY2VsbCB0byB0aGUgbmV4dC4gSFJNQSBzdGFuZHMgZm9yIGhvcml6b250YWwgcmVsYXRpdmUgbW92aW5nIGFuZ2xlLCB3aGljaCBpZGVudGlmaWVzIHRoZSBhbmdsZSBiZXR3ZWVuIHRoZSBob3Jpem9udGFsIGRpcmVjdGlvbiBmcm9tIGEgY2VsbCBhbmQgdGhlIG1vdmluZyBkaXJlY3Rpb24uPC9wPjxwPjxzdHJvbmc+SG9yaXpvbnRhbCBmYWN0b3I8L3N0cm9uZz50eXBlcyBpbmNsdWRlIHRoZSBmb2xsb3dpbmc6PC9wPjx1bD48bGk+PHN0cm9uZz5CaW5hcnk8L3N0cm9uZz4tLUluZGljYXRlcyB0aGF0IGlmIHRoZSBIUk1BIGlzIGxlc3MgdGhhbiB0aGUgY3V0IGFuZ2xlLCB0aGUgSEYgaXMgc2V0IHRvIHRoZSB2YWx1ZSBhc3NvY2lhdGVkIHdpdGggdGhlIHplcm8gZmFjdG9yOyBvdGhlcndpc2UsIGl0IGlzIGluZmluaXR5LjwvbGk+PGxpPjxzdHJvbmc+Rm9yd2FyZDwvc3Ryb25nPi0tRXN0YWJsaXNoZXMgdGhhdCBvbmx5IGZvcndhcmQgbW92ZW1lbnQgaXMgYWxsb3dlZC4gVGhlIEhSTUEgbXVzdCBiZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gMCBhbmQgbGVzcyB0aGFuIDkwIGRlZ3JlZXMgKDAgJmx0Oz0gSFJNQSAmbHQ7IDkwKS4gSWYgdGhlIEhSTUEgaXMgZ3JlYXRlciB0aGFuIDAgYW5kIGxlc3MgdGhhbiA0NSBkZWdyZWVzLCB0aGUgSEYgZm9yIHRoZSBjZWxsIGlzIHNldCB0byB0aGUgdmFsdWUgYXNzb2NpYXRlZCB3aXRoIHRoZSB6ZXJvIGZhY3Rvci4gSWYgdGhlIEhSTUEgaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIDQ1IGRlZ3JlZXMsIHRoZSBzaWRlIHZhbHVlIG1vZGlmaWVyIHZhbHVlIGlzIHVzZWQuIFRoZSBIRiBmb3IgYW55IEhSTUEgdmFsdWUgZXF1YWwgdG8gb3IgZ3JlYXRlciB0aGFuIDkwIGRlZ3JlZXMgaXMgc2V0IHRvIGluZmluaXR5LjwvbGk+PGxpPjxzdHJvbmc+TGluZWFyPC9zdHJvbmc+LS1TcGVjaWZpZXMgdGhhdCB0aGUgSEYgaXMgYSBsaW5lYXIgZnVuY3Rpb24gb2YgdGhlIEhSTUEuPC9saT48bGk+PHN0cm9uZz5JbnZlcnNlIExpbmVhcjwvc3Ryb25nPi0tU3BlY2lmaWVzIHRoYXQgdGhlIEhGIGlzIGFuIGludmVyc2UgbGluZWFyIGZ1bmN0aW9uIG9mIHRoZSBIUk1BLjwvbGk+PGxpPjxzdHJvbmc+VGFibGU8L3N0cm9uZz4tLUlkZW50aWZpZXMgdGhhdCBhIHRhYmxlIGZpbGUgd2lsbCBiZSB1c2VkIHRvIGRlZmluZSB0aGUgaG9yaXpvbnRhbCBmYWN0b3IgZ3JhcGggdXNlZCB0byBkZXRlcm1pbmUgdGhlIEhGcy48L2xpPjwvdWw+PHA+TW9kaWZpZXJzIHRvIHRoZSBob3Jpem9udGFsIGZhY3RvcnMgaW5jbHVkZSB0aGUgZm9sbG93aW5nOjwvcD48dWw+PGxpPjxzdHJvbmc+WmVybyBmYWN0b3I8L3N0cm9uZz4tLVRoZSBob3Jpem9udGFsIGZhY3RvciB0byBiZSB1c2VkIHdoZW4gdGhlIEhSTUEgaXMgemVyby4gVGhpcyBmYWN0b3IgcG9zaXRpb25zIHRoZSB5LWludGVyY2VwdCBmb3IgYW55IG9mIHRoZSBob3Jpem9udGFsIGZhY3RvciBmdW5jdGlvbnMuPC9saT48bGk+PHN0cm9uZz5DdXQgYW5nbGU8L3N0cm9uZz4tLURlZmluZXMgdGhlIEhSTUEgYW5nbGUgYmV5b25kIHdoaWNoIHRoZSBIRiB3aWxsIGJlIHNldCB0byBpbmZpbml0eS48L2xpPjxsaT48c3Ryb25nPlNsb3BlPC9zdHJvbmc+LS1Fc3RhYmxpc2hlcyB0aGUgc2xvcGUgb2YgdGhlIHN0cmFpZ2h0IGxpbmUgdXNlZCB3aXRoIHRoZTxzdHJvbmc+TGluZWFyPC9zdHJvbmc+YW5kPHN0cm9uZz5JbnZlcnNlIExpbmVhcjwvc3Ryb25nPmhvcml6b250YWwgZmFjdG9yIGtleXdvcmRzLiBUaGUgc2xvcGUgaXMgc3BlY2lmaWVkIGFzIGEgZnJhY3Rpb24gb2YgcmlzZSBvdmVyIHJ1biAoZm9yIGV4YW1wbGUsIDQ1IHBlcmNlbnQgc2xvcGUgaXMgMS80NSwgd2hpY2ggaXMgaW5wdXQgYXMgMC4wMjIyMikuPC9saT48bGk+PHN0cm9uZz5TaWRlIHZhbHVlPC9zdHJvbmc+LS1Fc3RhYmxpc2hlcyB0aGUgSEYgd2hlbiB0aGUgSFJNQSBpcyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gNDUgZGVncmVlcyBhbmQgbGVzcyB0aGFuIDkwIGRlZ3JlZXMgd2hlbiB0aGU8c3Ryb25nPkZvcndhcmQ8L3N0cm9uZz5ob3Jpem9udGFsIGZhY3RvciBrZXl3b3JkIGlzIHNwZWNpZmllZC48L2xpPjxsaT48c3Ryb25nPlRhYmxlIG5hbWU8L3N0cm9uZz4tLUlkZW50aWZpZXMgdGhlIG5hbWUgb2YgdGhlIHRhYmxlIGRlZmluaW5nIHRoZSBIRi48L2xpPjwvdWw+XCIsXG5cdFwiQEBQYXRoLURpc3RhbmNlLUFsbG9jYXRpb25fSG9yaXpvbnRhbC1SYXN0ZXJfdGFnMEBAXCI6IFwiQSByYXN0ZXIgZGVmaW5pbmcgdGhlIGhvcml6b250YWwgZGlyZWN0aW9uIGF0IGVhY2ggY2VsbC5cIixcblx0XCJAQFBhdGgtRGlzdGFuY2UtQWxsb2NhdGlvbl9Ib3Jpem9udGFsLVJhc3Rlcl90YWcxQEBcIjogXCJUaGUgdmFsdWVzIG9uIHRoZSByYXN0ZXIgbXVzdCBiZSBpbnRlZ2VycyByYW5naW5nIGZyb20gMCB0byAzNjAsIHdpdGggMCBkZWdyZWVzIGJlaW5nIG5vcnRoLCBvciB0b3dhcmQgdGhlIHRvcCBvZiB0aGUgc2NyZWVuLCBhbmQgaW5jcmVhc2luZyBjbG9ja3dpc2UuIEZsYXQgYXJlYXMgc2hvdWxkIGJlIGdpdmVuIGEgdmFsdWUgb2YgLTEuIFRoZSB2YWx1ZXMgYXQgZWFjaCBsb2NhdGlvbiB3aWxsIGJlIHVzZWQgaW4gY29uanVuY3Rpb24gd2l0aCB0aGUgPHN0cm9uZz5Ib3Jpem9udGFsIGZhY3Rvcjwvc3Ryb25nPiB0byBkZXRlcm1pbmUgdGhlIGhvcml6b250YWwgY29zdCBpbmN1cnJlZCB3aGVuIG1vdmluZyBmcm9tIGEgY2VsbCB0byBpdHMgbmVpZ2hib3JzLlwiLFxuXHRcIkBAUGF0aC1EaXN0YW5jZS1BbGxvY2F0aW9uX01heGltdW0tRGlzdGFuY2VfdGFnMEBAXCI6IFwiVGhlIHRocmVzaG9sZCB0aGF0IHRoZSBhY2N1bXVsYXRpdmUgY29zdCB2YWx1ZXMgY2Fubm90IGV4Y2VlZC4gSWYgYW4gYWNjdW11bGF0aXZlIGNvc3QgZGlzdGFuY2UgZXhjZWVkcyB0aGlzIHZhbHVlLCB0aGUgb3V0cHV0IHZhbHVlIGZvciB0aGUgY2VsbCBsb2NhdGlvbiB3aWxsIGJlIE5vRGF0YS4gVGhlIG1heGltdW0gZGlzdGFuY2UgZGVmaW5lcyB0aGUgZXh0ZW50IGZvciB3aGljaCB0aGUgYWNjdW11bGF0aXZlIGNvc3QgZGlzdGFuY2VzIGFyZSBjYWxjdWxhdGVkLiBUaGUgZGVmYXVsdCBkaXN0YW5jZSBpcyB0byB0aGUgZXh0ZW50IG9mIHRoZSBvdXRwdXQgcmFzdGVyLlwiLFxuXHRcIkBAUGF0aC1EaXN0YW5jZS1BbGxvY2F0aW9uX011bHRpcGxpZXItdG8tQXBwbHktdG8tQ29zdHNfdGFnMEBAXCI6IFwiQSBtdWx0aXBsaWVyIHRvIGFwcGx5IHRvIHRoZSBjb3N0IHZhbHVlcy5cIixcblx0XCJAQFBhdGgtRGlzdGFuY2UtQWxsb2NhdGlvbl9NdWx0aXBsaWVyLXRvLUFwcGx5LXRvLUNvc3RzX3RhZzFAQFwiOiBcIlRoaXMgcGFyYW1ldGVyIGFsbG93cyBmb3IgY29udHJvbCBvZiB0aGUgbW9kZSBvZiB0cmF2ZWwgb3IgdGhlIG1hZ25pdHVkZSBhdCBhIHNvdXJjZS4gVGhlIGdyZWF0ZXIgdGhlIG11bHRpcGxpZXIsIHRoZSBncmVhdGVyIHRoZSBjb3N0IHRvIG1vdmUgdGhyb3VnaCBlYWNoIGNlbGwuXCIsXG5cdFwiQEBQYXRoLURpc3RhbmNlLUFsbG9jYXRpb25fTXVsdGlwbGllci10by1BcHBseS10by1Db3N0c190YWcyQEBcIjogXCJUaGUgdmFsdWVzIG11c3QgYmUgZ3JlYXRlciB0aGFuIHplcm8uIFRoZSBkZWZhdWx0IGlzIDEuXCIsXG5cdFwiQEBQYXRoLURpc3RhbmNlLUFsbG9jYXRpb25fTXVsdGlwbGllci10by1BcHBseS10by1Db3N0c190YWczQEBcIjogXCJBIG51bWVyaWMgKGRvdWJsZSkgdmFsdWUgb3IgYSBmaWVsZCBmcm9tIHRoZSA8c3Ryb25nPlNvdXJjZSBSYXN0ZXI8L3N0cm9uZz4gY2FuIGJlIHVzZWQgZm9yIHRoaXMgcGFyYW1ldGVyLlwiLFxuXHRcIkBAUGF0aC1EaXN0YW5jZS1BbGxvY2F0aW9uX1NvdXJjZS1GaWVsZF90YWcwQEBcIjogXCJUaGUgZmllbGQgdXNlZCB0byBhc3NpZ24gdmFsdWVzIHRvIHRoZSBzb3VyY2UgbG9jYXRpb25zLiBJdCBtdXN0IGJlIGFuIGludGVnZXIgdHlwZS4gSWYgdGhlIDxzdHJvbmc+VmFsdWUgUmFzdGVyPC9zdHJvbmc+IGhhcyBiZWVuIHNldCwgdGhlIHZhbHVlcyBpbiB0aGF0IGlucHV0IHdpbGwgdGFrZSBwcmVjZWRlbmNlIG92ZXIgYW55IHNldHRpbmcgZm9yIHRoZSA8c3Ryb25nPlNvdXJjZSBGaWVsZDwvc3Ryb25nPi5cIixcblx0XCJAQFBhdGgtRGlzdGFuY2UtQWxsb2NhdGlvbl9Tb3VyY2UtUmFzdGVyX3RhZzBAQFwiOiBcIlRoZSByZXF1aXJlZCBpbnB1dCByYXN0ZXIgb2Ygc291cmNlIGxvY2F0aW9ucy5cIixcblx0XCJAQFBhdGgtRGlzdGFuY2UtQWxsb2NhdGlvbl9Tb3VyY2UtUmFzdGVyX3RhZzFAQFwiOiBcIlRoaXMgaXMgYSByYXN0ZXIgdGhhdCBpZGVudGlmaWVzIHRoZSBjZWxscyBvciBsb2NhdGlvbnMgZnJvbSB3aGljaCB0aGUgbGVhc3QgYWNjdW11bGF0ZWQgY29zdCBkaXN0YW5jZSBmb3IgZXZlcnkgb3V0cHV0IGNlbGwgbG9jYXRpb24gaXMgY2FsY3VsYXRlZC5cIixcblx0XCJAQFBhdGgtRGlzdGFuY2UtQWxsb2NhdGlvbl9Tb3VyY2UtUmFzdGVyX3RhZzJAQFwiOiBcIkl0IGNhbiBiZSBhbiBpbnRlZ2VyIG9yIGEgZmxvYXRpbmctcG9pbnQgdHlwZS5cIixcblx0XCJAQFBhdGgtRGlzdGFuY2UtQWxsb2NhdGlvbl9TdGFydC1Db3N0X3RhZzBAQFwiOiBcIlRoZSBzdGFydGluZyBjb3N0IGZyb20gd2hpY2ggdG8gYmVnaW4gdGhlIGNvc3QgY2FsY3VsYXRpb25zLiBUaGlzIHBhcmFtZXRlciBhbGxvd3MgZm9yIHRoZSBzcGVjaWZpY2F0aW9uIG9mIHRoZSBmaXhlZCBjb3N0IGFzc29jaWF0ZWQgd2l0aCBhIHNvdXJjZS4gSW5zdGVhZCBvZiBzdGFydGluZyBhdCBhIGNvc3Qgb2YgMCwgdGhlIGNvc3QgYWxnb3JpdGhtIHdpbGwgYmVnaW4gd2l0aCB0aGUgdmFsdWUgc3BlY2lmaWVkLlwiLFxuXHRcIkBAUGF0aC1EaXN0YW5jZS1BbGxvY2F0aW9uX1N0YXJ0LUNvc3RfdGFnMUBAXCI6IFwiVGhlIHZhbHVlIG11c3QgYmUgemVybyBvciBncmVhdGVyLiBUaGUgZGVmYXVsdCBpcyAwLlwiLFxuXHRcIkBAUGF0aC1EaXN0YW5jZS1BbGxvY2F0aW9uX1N1cmZhY2UtUmFzdGVyX3RhZzBAQFwiOiBcIkEgcmFzdGVyIGRlZmluaW5nIHRoZSBlbGV2YXRpb24gdmFsdWVzIGF0IGVhY2ggY2VsbCBsb2NhdGlvbi5cIixcblx0XCJAQFBhdGgtRGlzdGFuY2UtQWxsb2NhdGlvbl9TdXJmYWNlLVJhc3Rlcl90YWcxQEBcIjogXCJUaGUgdmFsdWVzIGFyZSB1c2VkIHRvIGNhbGN1bGF0ZSB0aGUgYWN0dWFsIHN1cmZhY2UgZGlzdGFuY2UgY292ZXJlZCB3aGVuIHBhc3NpbmcgYmV0d2VlbiBjZWxscy5cIixcblx0XCJAQFBhdGgtRGlzdGFuY2UtQWxsb2NhdGlvbl9UcmF2ZWwtRGlyZWN0aW9uX3RhZzBAQFwiOiBcIkRlZmluZXMgdGhlIGRpcmVjdGlvbiBvZiB0aGUgdHJhdmVsZXIgd2hlbiBhcHBseWluZyB0aGUgc291cmNlIHJlc2lzdGFuY2UgcmF0ZSBhbmQgdGhlIHNvdXJjZSBzdGFydGluZyBjb3N0LlwiLFxuXHRcIkBAUGF0aC1EaXN0YW5jZS1BbGxvY2F0aW9uX1RyYXZlbC1EaXJlY3Rpb25fdGFnMUBAXCI6IFwiPHN0cm9uZz5Gcm9tIFNvdXJjZTwvc3Ryb25nPi0tVGhlIHNvdXJjZSByZXNpc3RhbmNlIHJhdGUgYW5kIHNvdXJjZSBzdGFydGluZyBjb3N0IHdpbGwgYmUgYXBwbGllZCBiZWdpbm5pbmcgYXQgdGhlIGlucHV0IHNvdXJjZSBhbmQgbW92aW5nIG91dCB0byB0aGUgbm9uLXNvdXJjZSBjZWxscy4gVGhpcyBpcyB0aGUgZGVmYXVsdC5cIixcblx0XCJAQFBhdGgtRGlzdGFuY2UtQWxsb2NhdGlvbl9UcmF2ZWwtRGlyZWN0aW9uX3RhZzNAQFwiOiBcIjxzdHJvbmc+VG8gU291cmNlPC9zdHJvbmc+LS1UaGUgc291cmNlIHJlc2lzdGFuY2UgcmF0ZSBhbmQgc291cmNlIHN0YXJ0aW5nIGNvc3Qgd2lsbCBiZSBhcHBsaWVkIGJlZ2lubmluZyBhdCBlYWNoIG5vbi1zb3VyY2UgY2VsbCBhbmQgbW92aW5nIGJhY2sgdG8gdGhlIGlucHV0IHNvdXJjZS5cIixcblx0XCJAQFBhdGgtRGlzdGFuY2UtQWxsb2NhdGlvbl9UcmF2ZWwtRGlyZWN0aW9uX3RhZzVAQFwiOiBcIkVpdGhlciBzcGVjaWZ5IHRoZSA8c3Ryb25nPkZyb20gU291cmNlPC9zdHJvbmc+IG9yIDxzdHJvbmc+VG8gU291cmNlPC9zdHJvbmc+IGtleXdvcmQsIHdoaWNoIHdpbGwgYmUgYXBwbGllZCB0byBhbGwgc291cmNlcywgb3Igc3BlY2lmeSBhIGZpZWxkIGluIHRoZSA8c3Ryb25nPlNvdXJjZSBSYXN0ZXI8L3N0cm9uZz4gdGhhdCBjb250YWlucyB0aGUga2V5d29yZHMgdG8gaWRlbnRpZnkgdGhlIGRpcmVjdGlvbiBvZiB0cmF2ZWwgZm9yIGVhY2ggc291cmNlLiBUaGF0IGZpZWxkIG11c3QgY29udGFpbiB0aGUgc3RyaW5nICR7RlJPTV9TT1VSQ0V9IG9yICR7VE9fU09VUkNFfS5cIixcblx0XCJAQFBhdGgtRGlzdGFuY2UtQWxsb2NhdGlvbl9WYWx1ZS1SYXN0ZXJfdGFnMEBAXCI6IFwiVGhlIGlucHV0IGludGVnZXIgcmFzdGVyIHRoYXQgaWRlbnRpZmllcyB0aGUgem9uZSB2YWx1ZXMgdG8gYmUgdXNlZCBmb3IgZWFjaCBpbnB1dCBzb3VyY2UgbG9jYXRpb24uIEZvciBlYWNoIHNvdXJjZSBsb2NhdGlvbiBjZWxsLCB0aGUgdmFsdWUgZGVmaW5lZCBieSB0aGUgPHN0cm9uZz5WYWx1ZSBSYXN0ZXI8L3N0cm9uZz4gd2lsbCBiZSBhc3NpZ25lZCB0byBhbGwgY2VsbHMgYWxsb2NhdGVkIHRvIHRoZSBzb3VyY2UgbG9jYXRpb24gZm9yIHRoZSBjb21wdXRhdGlvbi4gVGhlIDxzdHJvbmc+VmFsdWUgUmFzdGVyPC9zdHJvbmc+IHdpbGwgdGFrZSBwcmVjZWRlbmNlIG92ZXIgYW55IHNldHRpbmcgZm9yIHRoZSA8c3Ryb25nPlNvdXJjZSBGaWVsZDwvc3Ryb25nPi5cIixcblx0XCJAQFBhdGgtRGlzdGFuY2UtQWxsb2NhdGlvbl92ZXJ0aWNhbGZhY3Rvcl90YWcwQEBcIjogXCI8cD5EZWZpbmVzIHRoZSByZWxhdGlvbnNoaXAgYmV0d2VlbiB0aGUgdmVydGljYWwgY29zdCBmYWN0b3IgYW5kIHRoZSB2ZXJ0aWNhbCByZWxhdGl2ZSBtb3ZpbmcgYW5nbGUgKFZSTUEpLjwvcD48cD5UaGVyZSBhcmUgc2V2ZXJhbCBmYWN0b3JzIHdpdGggbW9kaWZpZXJzIHRoYXQgaWRlbnRpZnkgYSBkZWZpbmVkIHZlcnRpY2FsIGZhY3RvciBncmFwaC4gQWRkaXRpb25hbGx5LCBhIHRhYmxlIGNhbiBiZSB1c2VkIHRvIGNyZWF0ZSBhIGN1c3RvbSBncmFwaC4gVGhlIGdyYXBocyBhcmUgdXNlZCB0byBpZGVudGlmeSB0aGUgdmVydGljYWwgZmFjdG9yIHVzZWQgaW4gY2FsY3VsYXRpbmcgdGhlIHRvdGFsIGNvc3Qgb2YgbW92aW5nIGludG8gYSBuZWlnaGJvcmluZyBjZWxsLjwvcD48cD5JbiB0aGUgZXhwbGFuYXRpb25zIGJlbG93LCB0d28gYWNyb255bXMgYXJlIHVzZWQ6IFZGIGFuZCBWUk1BLiBWRiBzdGFuZHMgZm9yIHZlcnRpY2FsIGZhY3Rvciwgd2hpY2ggZGVmaW5lcyB0aGUgdmVydGljYWwgZGlmZmljdWx0eSBlbmNvdW50ZXJlZCBpbiBtb3ZpbmcgZnJvbSBvbmUgY2VsbCB0byB0aGUgbmV4dC4gVlJNQSBzdGFuZHMgZm9yIHZlcnRpY2FsIHJlbGF0aXZlIG1vdmluZyBhbmdsZSwgd2hpY2ggaWRlbnRpZmllcyB0aGUgc2xvcGUgYW5nbGUgYmV0d2VlbiB0aGUgRlJPTSwgb3IgcHJvY2Vzc2luZywgY2VsbCBhbmQgdGhlIFRPIGNlbGwuPC9wPjxwPjxzdHJvbmc+VmVydGljYWwgZmFjdG9yPC9zdHJvbmc+dHlwZXMgaW5jbHVkZSB0aGUgZm9sbG93aW5nOjwvcD48dWw+PGxpPjxzdHJvbmc+QmluYXJ5PC9zdHJvbmc+LS1TcGVjaWZpZXMgdGhhdCBpZiB0aGUgVlJNQSBpcyBncmVhdGVyIHRoYW4gdGhlIGxvdy1jdXQgYW5nbGUgYW5kIGxlc3MgdGhhbiB0aGUgaGlnaC1jdXQgYW5nbGUsIHRoZSBWRiBpcyBzZXQgdG8gdGhlIHZhbHVlIGFzc29jaWF0ZWQgd2l0aCB0aGUgemVybyBmYWN0b3I7IG90aGVyd2lzZSwgaXQgaXMgaW5maW5pdHkuPC9saT48bGk+PHN0cm9uZz5MaW5lYXI8L3N0cm9uZz4tLUluZGljYXRlcyB0aGF0IHRoZSBWRiBpcyBhIGxpbmVhciBmdW5jdGlvbiBvZiB0aGUgVlJNQS48L2xpPjxsaT48c3Ryb25nPlN5bW1ldHJpYyBMaW5lYXI8L3N0cm9uZz4tLVNwZWNpZmllcyB0aGF0IHRoZSBWRiBpcyBhIGxpbmVhciBmdW5jdGlvbiBvZiB0aGUgVlJNQSBpbiBlaXRoZXIgdGhlIG5lZ2F0aXZlIG9yIHBvc2l0aXZlIHNpZGUgb2YgdGhlIFZSTUEsIHJlc3BlY3RpdmVseSwgYW5kIHRoZSB0d28gbGluZWFyIGZ1bmN0aW9ucyBhcmUgc3ltbWV0cmljYWwgd2l0aCByZXNwZWN0IHRvIHRoZSBWRiAoeSkgYXhpcy48L2xpPjxsaT48c3Ryb25nPkludmVyc2UgTGluZWFyPC9zdHJvbmc+LS1JbmRpY2F0ZXMgdGhhdCB0aGUgVkYgaXMgYW4gaW52ZXJzZSBsaW5lYXIgZnVuY3Rpb24gb2YgdGhlIFZSTUEuPC9saT48bGk+PHN0cm9uZz5TeW1tZXRyaWMgSW52ZXJzZSBMaW5lYXI8L3N0cm9uZz4tLVNwZWNpZmllcyB0aGF0IHRoZSBWRiBpcyBhbiBpbnZlcnNlIGxpbmVhciBmdW5jdGlvbiBvZiB0aGUgVlJNQSBpbiBlaXRoZXIgdGhlIG5lZ2F0aXZlIG9yIHBvc2l0aXZlIHNpZGUgb2YgdGhlIFZSTUEsIHJlc3BlY3RpdmVseSwgYW5kIHRoZSB0d28gbGluZWFyIGZ1bmN0aW9ucyBhcmUgc3ltbWV0cmljYWwgd2l0aCByZXNwZWN0IHRvIHRoZSBWRiAoeSkgYXhpcy48L2xpPjxsaT48c3Ryb25nPkNvczwvc3Ryb25nPi0tSWRlbnRpZmllcyB0aGUgVkYgYXMgdGhlIGNvc2luZS1iYXNlZCBmdW5jdGlvbiBvZiB0aGUgVlJNQS48L2xpPjxsaT48c3Ryb25nPlNlYzwvc3Ryb25nPi0tSWRlbnRpZmllcyB0aGUgVkYgYXMgdGhlIHNlY2FudC1iYXNlZCBmdW5jdGlvbiBvZiB0aGUgVlJNQS48L2xpPjxsaT48c3Ryb25nPkNvcy1TZWM8L3N0cm9uZz4tLVNwZWNpZmllcyB0aGF0IHRoZSBWRiBpcyB0aGUgY29zaW5lLWJhc2VkIGZ1bmN0aW9uIG9mIHRoZSBWUk1BIHdoZW4gdGhlIFZSTUEgaXMgbmVnYXRpdmUgYW5kIHRoZSBzZWNhbnQtYmFzZWQgZnVuY3Rpb24gb2YgdGhlIFZSTUEgd2hlbiB0aGUgVlJNQSBpcyBub3QgbmVnYXRpdmUuPC9saT48bGk+PHN0cm9uZz5TZWMtQ29zPC9zdHJvbmc+LS1TcGVjaWZpZXMgdGhhdCB0aGUgVkYgaXMgdGhlIHNlY2FudC1iYXNlZCBmdW5jdGlvbiBvZiB0aGUgVlJNQSB3aGVuIHRoZSBWUk1BIGlzIG5lZ2F0aXZlIGFuZCB0aGUgY29zaW5lLWJhc2VkIGZ1bmN0aW9uIG9mIHRoZSBWUk1BIHdoZW4gdGhlIFZSTUEgaXMgbm90IG5lZ2F0aXZlLjwvbGk+PGxpPjxzdHJvbmc+VGFibGU8L3N0cm9uZz4tLUlkZW50aWZpZXMgdGhhdCBhIHRhYmxlIGZpbGUgd2lsbCBiZSB1c2VkIHRvIGRlZmluZSB0aGUgdmVydGljYWwtZmFjdG9yIGdyYXBoIHRoYXQgaXMgdXNlZCB0byBkZXRlcm1pbmUgdGhlIFZGcy48L2xpPjwvdWw+PHA+TW9kaWZpZXJzIHRvIHRoZSB2ZXJ0aWNhbCBrZXl3b3JkcyBpbmNsdWRlIHRoZSBmb2xsb3dpbmc6PC9wPjx1bD48bGk+PHN0cm9uZz5aZXJvIGZhY3Rvcjwvc3Ryb25nPi0tRXN0YWJsaXNoZXMgdGhlIHZlcnRpY2FsIGZhY3RvciB1c2VkIHdoZW4gdGhlIFZSTUEgaXMgemVyby4gVGhpcyBmYWN0b3IgcG9zaXRpb25zIHRoZSB5LWludGVyY2VwdCBvZiB0aGUgc3BlY2lmaWVkIGZ1bmN0aW9uLiBCeSBkZWZpbml0aW9uLCB0aGUgemVybyBmYWN0b3IgaXMgbm90IGFwcGxpY2FibGUgdG8gYW55IG9mIHRoZSB0cmlnb25vbWV0cmljIHZlcnRpY2FsIGZ1bmN0aW9ucyAoQ09TLCBTRUMsIENPUy1TRUMsIG9yIFNFQy1DT1MpLiBUaGUgeS1pbnRlcmNlcHQgaXMgZGVmaW5lZCBieSB0aGVzZSBmdW5jdGlvbnMuPC9saT48bGk+PHN0cm9uZz5Mb3cgQ3V0IGFuZ2xlPC9zdHJvbmc+LS1EZWZpbmVzIHRoZSBWUk1BIGFuZ2xlIGJlbG93IHdoaWNoIHRoZSBWRiB3aWxsIGJlIHNldCB0byBpbmZpbml0eS48L2xpPjxsaT48c3Ryb25nPkhpZ2ggQ3V0IGFuZ2xlPC9zdHJvbmc+LS1EZWZpbmVzIHRoZSBWUk1BIGFuZ2xlIGFib3ZlIHdoaWNoIHRoZSBWRiB3aWxsIGJlIHNldCB0byBpbmZpbml0eS48L2xpPjxsaT48c3Ryb25nPlNsb3BlPC9zdHJvbmc+LS1Fc3RhYmxpc2hlcyB0aGUgc2xvcGUgb2YgdGhlIHN0cmFpZ2h0IGxpbmUgdXNlZCB3aXRoIHRoZTxzdHJvbmc+TGluZWFyPC9zdHJvbmc+YW5kPHN0cm9uZz5JbnZlcnNlIExpbmVhcjwvc3Ryb25nPnZlcnRpY2FsLWZhY3RvciBrZXl3b3Jkcy4gVGhlIHNsb3BlIGlzIHNwZWNpZmllZCBhcyBhIGZyYWN0aW9uIG9mIHJpc2Ugb3ZlciBydW4gKGZvciBleGFtcGxlLCA0NSBwZXJjZW50IHNsb3BlIGlzIDEvNDUsIHdoaWNoIGlzIGlucHV0IGFzIDAuMDIyMjIpLjwvbGk+PGxpPjxzdHJvbmc+VGFibGUgbmFtZTwvc3Ryb25nPi0tSWRlbnRpZmllcyB0aGUgbmFtZSBvZiB0aGUgdGFibGUgZGVmaW5pbmcgdGhlIFZGLjwvbGk+PC91bD5cIixcblx0XCJAQFBhdGgtRGlzdGFuY2UtQWxsb2NhdGlvbl9WZXJ0aWNhbC1SYXN0ZXJfdGFnMEBAXCI6IFwiRGVmaW5lcyB0aGUgcmVsYXRpb25zaGlwIGJldHdlZW4gdGhlIHZlcnRpY2FsIGNvc3QgZmFjdG9yIGFuZCB0aGUgdmVydGljYWwgcmVsYXRpdmUgbW92aW5nIGFuZ2xlIChWUk1BKS5cIixcblx0XCJAQFBhdGgtRGlzdGFuY2UtQWxsb2NhdGlvbl9WZXJ0aWNhbC1SYXN0ZXJfdGFnMUBAXCI6IFwiVGhlIHZhbHVlcyBhcmUgdXNlZCBmb3IgY2FsY3VsYXRpbmcgdGhlIHNsb3BlIHVzZWQgdG8gaWRlbnRpZnkgdGhlIHZlcnRpY2FsIGZhY3RvciBpbmN1cnJlZCB3aGVuIG1vdmluZyBmcm9tIG9uZSBjZWxsIHRvIGFub3RoZXIuXCIsXG5cdFwiQEBQYXRoLURpc3RhbmNlLUJhY2stTGlua19BY2N1bXVsYXRpdmUtQ29zdC1SZXNpc3RhbmNlLVJhdGVfdGFnMEBAXCI6IFwiVGhpcyBwYXJhbWV0ZXIgc2ltdWxhdGVzIHRoZSBpbmNyZWFzZSBpbiB0aGUgZWZmb3J0IHRvIG92ZXJjb21lIGNvc3RzIGFzIHRoZSBhY2N1bXVsYXRpdmUgY29zdCBpbmNyZWFzZXMuIEl0IGlzIHVzZWQgdG8gbW9kZWwgZmF0aWd1ZSBvZiB0aGUgdHJhdmVsZXIuIFRoZSBncm93aW5nIGFjY3VtdWxhdGl2ZSBjb3N0IHRvIHJlYWNoIGEgY2VsbCBpcyBtdWx0aXBsaWVkIGJ5IHRoZSByZXNpc3RhbmNlIHJhdGUgYW5kIGFkZGVkIHRvIHRoZSBjb3N0IHRvIG1vdmUgaW50byB0aGUgc3Vic2VxdWVudCBjZWxsLlwiLFxuXHRcIkBAUGF0aC1EaXN0YW5jZS1CYWNrLUxpbmtfQWNjdW11bGF0aXZlLUNvc3QtUmVzaXN0YW5jZS1SYXRlX3RhZzFAQFwiOiBcIkl0J3MgYSBtb2RpZmllZCB2ZXJzaW9uIG9mIGEgY29tcG91bmQgaW50ZXJlc3QgcmF0ZSBmb3JtdWxhIHRoYXQncyB1c2VkIHRvIGNhbGN1bGF0ZSB0aGUgYXBwYXJlbnQgY29zdCBvZiBtb3ZpbmcgdGhyb3VnaCBhIGNlbGwuIEFzIHRoZSB2YWx1ZSBvZiB0aGUgcmVzaXN0YW5jZSByYXRlIGluY3JlYXNlcywgaXQgaW5jcmVhc2VzIHRoZSBjb3N0IG9mIHRoZSBjZWxscyB0aGF0IGFyZSB2aXNpdGVkIGxhdGVyLiBUaGUgZ3JlYXRlciB0aGUgcmVzaXN0YW5jZSByYXRlLCB0aGUgaGlnaGVyIHRoZSBjb3N0IHRvIHJlYWNoIHRoZSBuZXh0IGNlbGwsIHdoaWNoIGlzIGNvbXBvdW5kZWQgZm9yIGVhY2ggc3Vic2VxdWVudCBtb3ZlbWVudC4gU2luY2UgdGhlIHJlc2lzdGFuY2UgcmF0ZSBpcyBzaW1pbGFyIHRvIGEgY29tcG91bmQgcmF0ZSBhbmQgZ2VuZXJhbGx5IHRoZSBhY2N1bXVsYXRpdmUgY29zdCB2YWx1ZXMgYXJlIHZlcnkgbGFyZ2UsIHNtYWxsIHJlc2lzdGFuY2UgcmF0ZXMgYXJlIHN1Z2dlc3RlZCwgc3VjaCBhcyAwLjAwNSBvciBldmVuIHNtYWxsZXIsIGRlcGVuZGluZyBvbiB0aGUgYWNjdW11bGF0aXZlIGNvc3QgdmFsdWVzLlwiLFxuXHRcIkBAUGF0aC1EaXN0YW5jZS1CYWNrLUxpbmtfQWNjdW11bGF0aXZlLUNvc3QtUmVzaXN0YW5jZS1SYXRlX3RhZzJAQFwiOiBcIlRoZSB2YWx1ZSBtdXN0IGJlIGdyZWF0ZXIgdGhhbiB6ZXJvLiBUaGUgZGVmYXVsdCBjYXBhY2l0eSBpcyB0byB0aGUgZWRnZSBvZiB0aGUgb3V0cHV0IHJhc3Rlci5cIixcblx0XCJAQFBhdGgtRGlzdGFuY2UtQmFjay1MaW5rX0NhcGFjaXR5X3RhZzBAQFwiOiBcIkRlZmluZXMgdGhlIGNvc3QgY2FwYWNpdHkgZm9yIHRoZSB0cmF2ZWxlciBmb3IgYSBzb3VyY2UuIFRoZSBjb3N0IGNhbGN1bGF0aW9ucyBjb250aW51ZSBmb3IgZWFjaCBzb3VyY2UgdW50aWwgdGhlIHNwZWNpZmllZCBjYXBhY2l0eSBpcyByZWFjaGVkLlwiLFxuXHRcIkBAUGF0aC1EaXN0YW5jZS1CYWNrLUxpbmtfQ2FwYWNpdHlfdGFnMUBAXCI6IFwiVGhlIHZhbHVlIG11c3QgYmUgZ3JlYXRlciB0aGFuIHplcm8uIFRoZSBkZWZhdWx0IGNhcGFjaXR5IGlzIHRvIHRoZSBlZGdlIG9mIHRoZSBvdXRwdXQgcmFzdGVyLlwiLFxuXHRcIkBAUGF0aC1EaXN0YW5jZS1CYWNrLUxpbmtfQ29zdC1SYXN0ZXJfdGFnMEBAXCI6IFwiQSByZXF1aXJlZCBpbnB1dCByYXN0ZXIgZGVmaW5pbmcgdGhlIGNvc3Qgb3IgaW1wZWRhbmNlIHRvIG1vdmUgcGxhbmltZXRyaWNhbGx5IHRocm91Z2ggZWFjaCBjZWxsLiBUaGUgdmFsdWUgYXQgZWFjaCBjZWxsIGxvY2F0aW9uIHJlcHJlc2VudHMgdGhlIGNvc3QtcGVyLXVuaXQgZGlzdGFuY2UgZm9yIG1vdmluZyB0aHJvdWdoIGl0LiBFYWNoIGNlbGwgbG9jYXRpb24gdmFsdWUgaXMgbXVsdGlwbGllZCBieSB0aGUgY2VsbCByZXNvbHV0aW9uLCBhbmQgYWxzbyBjb21wZW5zYXRlcyBmb3IgZGlhZ29uYWwgbW92ZW1lbnQgdG8gb2J0YWluIHRoZSB0b3RhbCBjb3N0IG9mIHBhc3NpbmcgdGhyb3VnaCB0aGUgY2VsbC5cIixcblx0XCJAQFBhdGgtRGlzdGFuY2UtQmFjay1MaW5rX0Nvc3QtUmFzdGVyX3RhZzFAQFwiOiBcIlRoZSB2YWx1ZXMgb2YgdGhlIDxzdHJvbmc+Q29zdCBSYXN0ZXI8L3N0cm9uZz4gY2FuIGJlIGludGVnZXIgb3IgZmxvYXRpbmcgcG9pbnQsIGJ1dCB0aGV5IGNhbm5vdCBiZSBuZWdhdGl2ZSBvciB6ZXJvLlwiLFxuXHRcIkBAUGF0aC1EaXN0YW5jZS1CYWNrLUxpbmtfaG9yaXpvbnRhbGZhY3Rvcl90YWcwQEBcIjogXCI8cD5EZWZpbmVzIHRoZSByZWxhdGlvbnNoaXAgYmV0d2VlbiB0aGUgaG9yaXpvbnRhbCBjb3N0IGZhY3RvciBhbmQgdGhlIGhvcml6b250YWwgcmVsYXRpdmUgbW92aW5nIGFuZ2xlIChIUk1BKS48L3A+PHA+VGhlcmUgYXJlIHNldmVyYWwgZmFjdG9ycyB3aXRoIG1vZGlmaWVycyB0aGF0IGlkZW50aWZ5IGEgZGVmaW5lZCB2ZXJ0aWNhbCBmYWN0b3IgZ3JhcGguIEFkZGl0aW9uYWxseSwgYSB0YWJsZSBjYW4gYmUgdXNlZCB0byBjcmVhdGUgYSBjdXN0b20gZ3JhcGguIFRoZSBncmFwaHMgYXJlIHVzZWQgdG8gaWRlbnRpZnkgdGhlIHZlcnRpY2FsIGZhY3RvciB1c2VkIGluIGNhbGN1bGF0aW5nIHRoZSB0b3RhbCBjb3N0IG9mIG1vdmluZyBpbnRvIGEgbmVpZ2hib3JpbmcgY2VsbC48L3A+PHA+SW4gdGhlIGV4cGxhbmF0aW9ucyBiZWxvdywgdHdvIGFjcm9ueW1zIGFyZSB1c2VkOiBIRiBhbmQgSFJNQS4gSEYgc3RhbmRzIGZvciBob3Jpem9udGFsIGZhY3Rvciwgd2hpY2ggZGVmaW5lcyB0aGUgaG9yaXpvbnRhbCBkaWZmaWN1bHR5IGVuY291bnRlcmVkIHdoZW4gbW92aW5nIGZyb20gb25lIGNlbGwgdG8gdGhlIG5leHQuIEhSTUEgc3RhbmRzIGZvciBob3Jpem9udGFsIHJlbGF0aXZlIG1vdmluZyBhbmdsZSwgd2hpY2ggaWRlbnRpZmllcyB0aGUgYW5nbGUgYmV0d2VlbiB0aGUgaG9yaXpvbnRhbCBkaXJlY3Rpb24gZnJvbSBhIGNlbGwgYW5kIHRoZSBtb3ZpbmcgZGlyZWN0aW9uLjwvcD48cD48c3Ryb25nPkhvcml6b250YWwgZmFjdG9yPC9zdHJvbmc+dHlwZXMgaW5jbHVkZSB0aGUgZm9sbG93aW5nOjwvcD48dWw+PGxpPjxzdHJvbmc+QmluYXJ5PC9zdHJvbmc+LS1JbmRpY2F0ZXMgdGhhdCBpZiB0aGUgSFJNQSBpcyBsZXNzIHRoYW4gdGhlIGN1dCBhbmdsZSwgdGhlIEhGIGlzIHNldCB0byB0aGUgdmFsdWUgYXNzb2NpYXRlZCB3aXRoIHRoZSB6ZXJvIGZhY3Rvcjsgb3RoZXJ3aXNlLCBpdCBpcyBpbmZpbml0eS48L2xpPjxsaT48c3Ryb25nPkZvcndhcmQ8L3N0cm9uZz4tLUVzdGFibGlzaGVzIHRoYXQgb25seSBmb3J3YXJkIG1vdmVtZW50IGlzIGFsbG93ZWQuIFRoZSBIUk1BIG11c3QgYmUgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIDAgYW5kIGxlc3MgdGhhbiA5MCBkZWdyZWVzICgwICZsdDs9IEhSTUEgJmx0OyA5MCkuIElmIHRoZSBIUk1BIGlzIGdyZWF0ZXIgdGhhbiAwIGFuZCBsZXNzIHRoYW4gNDUgZGVncmVlcywgdGhlIEhGIGZvciB0aGUgY2VsbCBpcyBzZXQgdG8gdGhlIHZhbHVlIGFzc29jaWF0ZWQgd2l0aCB0aGUgemVybyBmYWN0b3IuIElmIHRoZSBIUk1BIGlzIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byA0NSBkZWdyZWVzLCB0aGUgc2lkZSB2YWx1ZSBtb2RpZmllciB2YWx1ZSBpcyB1c2VkLiBUaGUgSEYgZm9yIGFueSBIUk1BIHZhbHVlIGVxdWFsIHRvIG9yIGdyZWF0ZXIgdGhhbiA5MCBkZWdyZWVzIGlzIHNldCB0byBpbmZpbml0eS48L2xpPjxsaT48c3Ryb25nPkxpbmVhcjwvc3Ryb25nPi0tU3BlY2lmaWVzIHRoYXQgdGhlIEhGIGlzIGEgbGluZWFyIGZ1bmN0aW9uIG9mIHRoZSBIUk1BLjwvbGk+PGxpPjxzdHJvbmc+SW52ZXJzZSBMaW5lYXI8L3N0cm9uZz4tLVNwZWNpZmllcyB0aGF0IHRoZSBIRiBpcyBhbiBpbnZlcnNlIGxpbmVhciBmdW5jdGlvbiBvZiB0aGUgSFJNQS48L2xpPjxsaT48c3Ryb25nPlRhYmxlPC9zdHJvbmc+LS1JZGVudGlmaWVzIHRoYXQgYSB0YWJsZSBmaWxlIHdpbGwgYmUgdXNlZCB0byBkZWZpbmUgdGhlIGhvcml6b250YWwgZmFjdG9yIGdyYXBoIHVzZWQgdG8gZGV0ZXJtaW5lIHRoZSBIRnMuPC9saT48L3VsPjxwPk1vZGlmaWVycyB0byB0aGUgaG9yaXpvbnRhbCBmYWN0b3JzIGluY2x1ZGUgdGhlIGZvbGxvd2luZzo8L3A+PHVsPjxsaT48c3Ryb25nPlplcm8gZmFjdG9yPC9zdHJvbmc+LS1UaGUgaG9yaXpvbnRhbCBmYWN0b3IgdG8gYmUgdXNlZCB3aGVuIHRoZSBIUk1BIGlzIHplcm8uIFRoaXMgZmFjdG9yIHBvc2l0aW9ucyB0aGUgeS1pbnRlcmNlcHQgZm9yIGFueSBvZiB0aGUgaG9yaXpvbnRhbCBmYWN0b3IgZnVuY3Rpb25zLjwvbGk+PGxpPjxzdHJvbmc+Q3V0IGFuZ2xlPC9zdHJvbmc+LS1EZWZpbmVzIHRoZSBIUk1BIGFuZ2xlIGJleW9uZCB3aGljaCB0aGUgSEYgd2lsbCBiZSBzZXQgdG8gaW5maW5pdHkuPC9saT48bGk+PHN0cm9uZz5TbG9wZTwvc3Ryb25nPi0tRXN0YWJsaXNoZXMgdGhlIHNsb3BlIG9mIHRoZSBzdHJhaWdodCBsaW5lIHVzZWQgd2l0aCB0aGU8c3Ryb25nPkxpbmVhcjwvc3Ryb25nPmFuZDxzdHJvbmc+SW52ZXJzZSBMaW5lYXI8L3N0cm9uZz5ob3Jpem9udGFsIGZhY3RvciBrZXl3b3Jkcy4gVGhlIHNsb3BlIGlzIHNwZWNpZmllZCBhcyBhIGZyYWN0aW9uIG9mIHJpc2Ugb3ZlciBydW4gKGZvciBleGFtcGxlLCA0NSBwZXJjZW50IHNsb3BlIGlzIDEvNDUsIHdoaWNoIGlzIGlucHV0IGFzIDAuMDIyMjIpLjwvbGk+PGxpPjxzdHJvbmc+U2lkZSB2YWx1ZTwvc3Ryb25nPi0tRXN0YWJsaXNoZXMgdGhlIEhGIHdoZW4gdGhlIEhSTUEgaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIDQ1IGRlZ3JlZXMgYW5kIGxlc3MgdGhhbiA5MCBkZWdyZWVzIHdoZW4gdGhlPHN0cm9uZz5Gb3J3YXJkPC9zdHJvbmc+aG9yaXpvbnRhbCBmYWN0b3Iga2V5d29yZCBpcyBzcGVjaWZpZWQuPC9saT48bGk+PHN0cm9uZz5UYWJsZSBuYW1lPC9zdHJvbmc+LS1JZGVudGlmaWVzIHRoZSBuYW1lIG9mIHRoZSB0YWJsZSBkZWZpbmluZyB0aGUgSEYuPC9saT48L3VsPlwiLFxuXHRcIkBAUGF0aC1EaXN0YW5jZS1CYWNrLUxpbmtfSG9yaXpvbnRhbC1SYXN0ZXJfdGFnMEBAXCI6IFwiQSByYXN0ZXIgZGVmaW5pbmcgdGhlIGhvcml6b250YWwgZGlyZWN0aW9uIGF0IGVhY2ggY2VsbC5cIixcblx0XCJAQFBhdGgtRGlzdGFuY2UtQmFjay1MaW5rX0hvcml6b250YWwtUmFzdGVyX3RhZzFAQFwiOiBcIlRoZSB2YWx1ZXMgb24gdGhlIHJhc3RlciBtdXN0IGJlIGludGVnZXJzIHJhbmdpbmcgZnJvbSAwIHRvIDM2MCwgd2l0aCAwIGRlZ3JlZXMgYmVpbmcgbm9ydGgsIG9yIHRvd2FyZCB0aGUgdG9wIG9mIHRoZSBzY3JlZW4sIGFuZCBpbmNyZWFzaW5nIGNsb2Nrd2lzZS4gRmxhdCBhcmVhcyBzaG91bGQgYmUgZ2l2ZW4gYSB2YWx1ZSBvZiAtMS4gVGhlIHZhbHVlcyBhdCBlYWNoIGxvY2F0aW9uIHdpbGwgYmUgdXNlZCBpbiBjb25qdW5jdGlvbiB3aXRoIHRoZSA8c3Ryb25nPkhvcml6b250YWwgZmFjdG9yPC9zdHJvbmc+IHRvIGRldGVybWluZSB0aGUgaG9yaXpvbnRhbCBjb3N0IGluY3VycmVkIHdoZW4gbW92aW5nIGZyb20gYSBjZWxsIHRvIGl0cyBuZWlnaGJvcnMuXCIsXG5cdFwiQEBQYXRoLURpc3RhbmNlLUJhY2stTGlua19NYXhpbXVtLURpc3RhbmNlX3RhZzBAQFwiOiBcIlRoZSB0aHJlc2hvbGQgdGhhdCB0aGUgYWNjdW11bGF0aXZlIGNvc3QgdmFsdWVzIGNhbm5vdCBleGNlZWQuIElmIGFuIGFjY3VtdWxhdGl2ZSBjb3N0IGRpc3RhbmNlIGV4Y2VlZHMgdGhpcyB2YWx1ZSwgdGhlIG91dHB1dCB2YWx1ZSBmb3IgdGhlIGNlbGwgbG9jYXRpb24gd2lsbCBiZSBOb0RhdGEuIFRoZSBtYXhpbXVtIGRpc3RhbmNlIGRlZmluZXMgdGhlIGV4dGVudCBmb3Igd2hpY2ggdGhlIGFjY3VtdWxhdGl2ZSBjb3N0IGRpc3RhbmNlcyBhcmUgY2FsY3VsYXRlZC4gVGhlIGRlZmF1bHQgZGlzdGFuY2UgaXMgdG8gdGhlIGV4dGVudCBvZiB0aGUgb3V0cHV0IHJhc3Rlci5cIixcblx0XCJAQFBhdGgtRGlzdGFuY2UtQmFjay1MaW5rX011bHRpcGxpZXItdG8tQXBwbHktdG8tQ29zdHNfdGFnMEBAXCI6IFwiQSBtdWx0aXBsaWVyIHRvIGFwcGx5IHRvIHRoZSBjb3N0IHZhbHVlcy5cIixcblx0XCJAQFBhdGgtRGlzdGFuY2UtQmFjay1MaW5rX011bHRpcGxpZXItdG8tQXBwbHktdG8tQ29zdHNfdGFnMUBAXCI6IFwiVGhpcyBwYXJhbWV0ZXIgYWxsb3dzIGZvciBjb250cm9sIG9mIHRoZSBtb2RlIG9mIHRyYXZlbCBvciB0aGUgbWFnbml0dWRlIGF0IGEgc291cmNlLiBUaGUgZ3JlYXRlciB0aGUgbXVsdGlwbGllciwgdGhlIGdyZWF0ZXIgdGhlIGNvc3QgdG8gbW92ZSB0aHJvdWdoIGVhY2ggY2VsbC5cIixcblx0XCJAQFBhdGgtRGlzdGFuY2UtQmFjay1MaW5rX011bHRpcGxpZXItdG8tQXBwbHktdG8tQ29zdHNfdGFnMkBAXCI6IFwiVGhlIHZhbHVlcyBtdXN0IGJlIGdyZWF0ZXIgdGhhbiB6ZXJvLiBUaGUgZGVmYXVsdCBpcyAxLlwiLFxuXHRcIkBAUGF0aC1EaXN0YW5jZS1CYWNrLUxpbmtfTXVsdGlwbGllci10by1BcHBseS10by1Db3N0c190YWczQEBcIjogXCJBIG51bWVyaWMgKGRvdWJsZSkgdmFsdWUgb3IgYSBmaWVsZCBmcm9tIHRoZSA8c3Ryb25nPlNvdXJjZSBSYXN0ZXI8L3N0cm9uZz4gY2FuIGJlIHVzZWQgZm9yIHRoaXMgcGFyYW1ldGVyLlwiLFxuXHRcIkBAUGF0aC1EaXN0YW5jZS1CYWNrLUxpbmtfU291cmNlLVJhc3Rlcl90YWcwQEBcIjogXCJUaGUgcmVxdWlyZWQgaW5wdXQgcmFzdGVyIG9mIHNvdXJjZSBsb2NhdGlvbnMuXCIsXG5cdFwiQEBQYXRoLURpc3RhbmNlLUJhY2stTGlua19Tb3VyY2UtUmFzdGVyX3RhZzFAQFwiOiBcIlRoaXMgaXMgYSByYXN0ZXIgdGhhdCBpZGVudGlmaWVzIHRoZSBjZWxscyBvciBsb2NhdGlvbnMgZnJvbSB3aGljaCB0aGUgbGVhc3QgYWNjdW11bGF0ZWQgY29zdCBkaXN0YW5jZSBmb3IgZXZlcnkgb3V0cHV0IGNlbGwgbG9jYXRpb24gaXMgY2FsY3VsYXRlZC5cIixcblx0XCJAQFBhdGgtRGlzdGFuY2UtQmFjay1MaW5rX1NvdXJjZS1SYXN0ZXJfdGFnMkBAXCI6IFwiSXQgY2FuIGJlIGFuIGludGVnZXIgb3IgYSBmbG9hdGluZy1wb2ludCB0eXBlLlwiLFxuXHRcIkBAUGF0aC1EaXN0YW5jZS1CYWNrLUxpbmtfU3RhcnQtQ29zdF90YWcwQEBcIjogXCJUaGUgc3RhcnRpbmcgY29zdCBmcm9tIHdoaWNoIHRvIGJlZ2luIHRoZSBjb3N0IGNhbGN1bGF0aW9ucy4gVGhpcyBwYXJhbWV0ZXIgYWxsb3dzIGZvciB0aGUgc3BlY2lmaWNhdGlvbiBvZiB0aGUgZml4ZWQgY29zdCBhc3NvY2lhdGVkIHdpdGggYSBzb3VyY2UuIEluc3RlYWQgb2Ygc3RhcnRpbmcgYXQgYSBjb3N0IG9mIDAsIHRoZSBjb3N0IGFsZ29yaXRobSB3aWxsIGJlZ2luIHdpdGggdGhlIHZhbHVlIHNwZWNpZmllZC5cIixcblx0XCJAQFBhdGgtRGlzdGFuY2UtQmFjay1MaW5rX1N0YXJ0LUNvc3RfdGFnMUBAXCI6IFwiVGhlIHZhbHVlIG11c3QgYmUgemVybyBvciBncmVhdGVyLiBUaGUgZGVmYXVsdCBpcyAwLlwiLFxuXHRcIkBAUGF0aC1EaXN0YW5jZS1CYWNrLUxpbmtfU3VyZmFjZS1SYXN0ZXJfdGFnMEBAXCI6IFwiQSByYXN0ZXIgZGVmaW5pbmcgdGhlIGVsZXZhdGlvbiB2YWx1ZXMgYXQgZWFjaCBjZWxsIGxvY2F0aW9uLlwiLFxuXHRcIkBAUGF0aC1EaXN0YW5jZS1CYWNrLUxpbmtfU3VyZmFjZS1SYXN0ZXJfdGFnMUBAXCI6IFwiVGhlIHZhbHVlcyBhcmUgdXNlZCB0byBjYWxjdWxhdGUgdGhlIGFjdHVhbCBzdXJmYWNlIGRpc3RhbmNlIGNvdmVyZWQgd2hlbiBwYXNzaW5nIGJldHdlZW4gY2VsbHMuXCIsXG5cdFwiQEBQYXRoLURpc3RhbmNlLUJhY2stTGlua19UcmF2ZWwtRGlyZWN0aW9uX3RhZzBAQFwiOiBcIkRlZmluZXMgdGhlIGRpcmVjdGlvbiBvZiB0aGUgdHJhdmVsZXIgd2hlbiBhcHBseWluZyB0aGUgc291cmNlIHJlc2lzdGFuY2UgcmF0ZSBhbmQgdGhlIHNvdXJjZSBzdGFydGluZyBjb3N0LlwiLFxuXHRcIkBAUGF0aC1EaXN0YW5jZS1CYWNrLUxpbmtfVHJhdmVsLURpcmVjdGlvbl90YWcxQEBcIjogXCI8c3Ryb25nPkZyb20gU291cmNlPC9zdHJvbmc+LS1UaGUgc291cmNlIHJlc2lzdGFuY2UgcmF0ZSBhbmQgc291cmNlIHN0YXJ0aW5nIGNvc3Qgd2lsbCBiZSBhcHBsaWVkIGJlZ2lubmluZyBhdCB0aGUgaW5wdXQgc291cmNlIGFuZCBtb3Zpbmcgb3V0IHRvIHRoZSBub24tc291cmNlIGNlbGxzLiBUaGlzIGlzIHRoZSBkZWZhdWx0LlwiLFxuXHRcIkBAUGF0aC1EaXN0YW5jZS1CYWNrLUxpbmtfVHJhdmVsLURpcmVjdGlvbl90YWczQEBcIjogXCI8c3Ryb25nPlRvIFNvdXJjZTwvc3Ryb25nPi0tVGhlIHNvdXJjZSByZXNpc3RhbmNlIHJhdGUgYW5kIHNvdXJjZSBzdGFydGluZyBjb3N0IHdpbGwgYmUgYXBwbGllZCBiZWdpbm5pbmcgYXQgZWFjaCBub24tc291cmNlIGNlbGwgYW5kIG1vdmluZyBiYWNrIHRvIHRoZSBpbnB1dCBzb3VyY2UuXCIsXG5cdFwiQEBQYXRoLURpc3RhbmNlLUJhY2stTGlua19UcmF2ZWwtRGlyZWN0aW9uX3RhZzVAQFwiOiBcIkVpdGhlciBzcGVjaWZ5IHRoZSA8c3Ryb25nPkZyb20gU291cmNlPC9zdHJvbmc+IG9yIDxzdHJvbmc+VG8gU291cmNlPC9zdHJvbmc+IGtleXdvcmQsIHdoaWNoIHdpbGwgYmUgYXBwbGllZCB0byBhbGwgc291cmNlcywgb3Igc3BlY2lmeSBhIGZpZWxkIGluIHRoZSA8c3Ryb25nPlNvdXJjZSBSYXN0ZXI8L3N0cm9uZz4gdGhhdCBjb250YWlucyB0aGUga2V5d29yZHMgdG8gaWRlbnRpZnkgdGhlIGRpcmVjdGlvbiBvZiB0cmF2ZWwgZm9yIGVhY2ggc291cmNlLiBUaGF0IGZpZWxkIG11c3QgY29udGFpbiB0aGUgc3RyaW5nICR7RlJPTV9TT1VSQ0V9IG9yICR7VE9fU09VUkNFfS5cIixcblx0XCJAQFBhdGgtRGlzdGFuY2UtQmFjay1MaW5rX3ZlcnRpY2FsZmFjdG9yX3RhZzBAQFwiOiBcIjxwPkRlZmluZXMgdGhlIHJlbGF0aW9uc2hpcCBiZXR3ZWVuIHRoZSB2ZXJ0aWNhbCBjb3N0IGZhY3RvciBhbmQgdGhlIHZlcnRpY2FsIHJlbGF0aXZlIG1vdmluZyBhbmdsZSAoVlJNQSkuPC9wPjxwPlRoZXJlIGFyZSBzZXZlcmFsIGZhY3RvcnMgd2l0aCBtb2RpZmllcnMgdGhhdCBpZGVudGlmeSBhIGRlZmluZWQgdmVydGljYWwgZmFjdG9yIGdyYXBoLiBBZGRpdGlvbmFsbHksIGEgdGFibGUgY2FuIGJlIHVzZWQgdG8gY3JlYXRlIGEgY3VzdG9tIGdyYXBoLiBUaGUgZ3JhcGhzIGFyZSB1c2VkIHRvIGlkZW50aWZ5IHRoZSB2ZXJ0aWNhbCBmYWN0b3IgdXNlZCBpbiBjYWxjdWxhdGluZyB0aGUgdG90YWwgY29zdCBvZiBtb3ZpbmcgaW50byBhIG5laWdoYm9yaW5nIGNlbGwuPC9wPjxwPkluIHRoZSBleHBsYW5hdGlvbnMgYmVsb3csIHR3byBhY3JvbnltcyBhcmUgdXNlZDogVkYgYW5kIFZSTUEuIFZGIHN0YW5kcyBmb3IgdmVydGljYWwgZmFjdG9yLCB3aGljaCBkZWZpbmVzIHRoZSB2ZXJ0aWNhbCBkaWZmaWN1bHR5IGVuY291bnRlcmVkIGluIG1vdmluZyBmcm9tIG9uZSBjZWxsIHRvIHRoZSBuZXh0LiBWUk1BIHN0YW5kcyBmb3IgdmVydGljYWwgcmVsYXRpdmUgbW92aW5nIGFuZ2xlLCB3aGljaCBpZGVudGlmaWVzIHRoZSBzbG9wZSBhbmdsZSBiZXR3ZWVuIHRoZSBGUk9NLCBvciBwcm9jZXNzaW5nLCBjZWxsIGFuZCB0aGUgVE8gY2VsbC48L3A+PHA+PHN0cm9uZz5WZXJ0aWNhbCBmYWN0b3I8L3N0cm9uZz50eXBlcyBpbmNsdWRlIHRoZSBmb2xsb3dpbmc6PC9wPjx1bD48bGk+PHN0cm9uZz5CaW5hcnk8L3N0cm9uZz4tLVNwZWNpZmllcyB0aGF0IGlmIHRoZSBWUk1BIGlzIGdyZWF0ZXIgdGhhbiB0aGUgbG93LWN1dCBhbmdsZSBhbmQgbGVzcyB0aGFuIHRoZSBoaWdoLWN1dCBhbmdsZSwgdGhlIFZGIGlzIHNldCB0byB0aGUgdmFsdWUgYXNzb2NpYXRlZCB3aXRoIHRoZSB6ZXJvIGZhY3Rvcjsgb3RoZXJ3aXNlLCBpdCBpcyBpbmZpbml0eS48L2xpPjxsaT48c3Ryb25nPkxpbmVhcjwvc3Ryb25nPi0tSW5kaWNhdGVzIHRoYXQgdGhlIFZGIGlzIGEgbGluZWFyIGZ1bmN0aW9uIG9mIHRoZSBWUk1BLjwvbGk+PGxpPjxzdHJvbmc+U3ltbWV0cmljIExpbmVhcjwvc3Ryb25nPi0tU3BlY2lmaWVzIHRoYXQgdGhlIFZGIGlzIGEgbGluZWFyIGZ1bmN0aW9uIG9mIHRoZSBWUk1BIGluIGVpdGhlciB0aGUgbmVnYXRpdmUgb3IgcG9zaXRpdmUgc2lkZSBvZiB0aGUgVlJNQSwgcmVzcGVjdGl2ZWx5LCBhbmQgdGhlIHR3byBsaW5lYXIgZnVuY3Rpb25zIGFyZSBzeW1tZXRyaWNhbCB3aXRoIHJlc3BlY3QgdG8gdGhlIFZGICh5KSBheGlzLjwvbGk+PGxpPjxzdHJvbmc+SW52ZXJzZSBMaW5lYXI8L3N0cm9uZz4tLUluZGljYXRlcyB0aGF0IHRoZSBWRiBpcyBhbiBpbnZlcnNlIGxpbmVhciBmdW5jdGlvbiBvZiB0aGUgVlJNQS48L2xpPjxsaT48c3Ryb25nPlN5bW1ldHJpYyBJbnZlcnNlIExpbmVhcjwvc3Ryb25nPi0tU3BlY2lmaWVzIHRoYXQgdGhlIFZGIGlzIGFuIGludmVyc2UgbGluZWFyIGZ1bmN0aW9uIG9mIHRoZSBWUk1BIGluIGVpdGhlciB0aGUgbmVnYXRpdmUgb3IgcG9zaXRpdmUgc2lkZSBvZiB0aGUgVlJNQSwgcmVzcGVjdGl2ZWx5LCBhbmQgdGhlIHR3byBsaW5lYXIgZnVuY3Rpb25zIGFyZSBzeW1tZXRyaWNhbCB3aXRoIHJlc3BlY3QgdG8gdGhlIFZGICh5KSBheGlzLjwvbGk+PGxpPjxzdHJvbmc+Q29zPC9zdHJvbmc+LS1JZGVudGlmaWVzIHRoZSBWRiBhcyB0aGUgY29zaW5lLWJhc2VkIGZ1bmN0aW9uIG9mIHRoZSBWUk1BLjwvbGk+PGxpPjxzdHJvbmc+U2VjPC9zdHJvbmc+LS1JZGVudGlmaWVzIHRoZSBWRiBhcyB0aGUgc2VjYW50LWJhc2VkIGZ1bmN0aW9uIG9mIHRoZSBWUk1BLjwvbGk+PGxpPjxzdHJvbmc+Q29zLVNlYzwvc3Ryb25nPi0tU3BlY2lmaWVzIHRoYXQgdGhlIFZGIGlzIHRoZSBjb3NpbmUtYmFzZWQgZnVuY3Rpb24gb2YgdGhlIFZSTUEgd2hlbiB0aGUgVlJNQSBpcyBuZWdhdGl2ZSBhbmQgdGhlIHNlY2FudC1iYXNlZCBmdW5jdGlvbiBvZiB0aGUgVlJNQSB3aGVuIHRoZSBWUk1BIGlzIG5vdCBuZWdhdGl2ZS48L2xpPjxsaT48c3Ryb25nPlNlYy1Db3M8L3N0cm9uZz4tLVNwZWNpZmllcyB0aGF0IHRoZSBWRiBpcyB0aGUgc2VjYW50LWJhc2VkIGZ1bmN0aW9uIG9mIHRoZSBWUk1BIHdoZW4gdGhlIFZSTUEgaXMgbmVnYXRpdmUgYW5kIHRoZSBjb3NpbmUtYmFzZWQgZnVuY3Rpb24gb2YgdGhlIFZSTUEgd2hlbiB0aGUgVlJNQSBpcyBub3QgbmVnYXRpdmUuPC9saT48bGk+PHN0cm9uZz5UYWJsZTwvc3Ryb25nPi0tSWRlbnRpZmllcyB0aGF0IGEgdGFibGUgZmlsZSB3aWxsIGJlIHVzZWQgdG8gZGVmaW5lIHRoZSB2ZXJ0aWNhbC1mYWN0b3IgZ3JhcGggdGhhdCBpcyB1c2VkIHRvIGRldGVybWluZSB0aGUgVkZzLjwvbGk+PC91bD48cD5Nb2RpZmllcnMgdG8gdGhlIHZlcnRpY2FsIGtleXdvcmRzIGluY2x1ZGUgdGhlIGZvbGxvd2luZzo8L3A+PHVsPjxsaT48c3Ryb25nPlplcm8gZmFjdG9yPC9zdHJvbmc+LS1Fc3RhYmxpc2hlcyB0aGUgdmVydGljYWwgZmFjdG9yIHVzZWQgd2hlbiB0aGUgVlJNQSBpcyB6ZXJvLiBUaGlzIGZhY3RvciBwb3NpdGlvbnMgdGhlIHktaW50ZXJjZXB0IG9mIHRoZSBzcGVjaWZpZWQgZnVuY3Rpb24uIEJ5IGRlZmluaXRpb24sIHRoZSB6ZXJvIGZhY3RvciBpcyBub3QgYXBwbGljYWJsZSB0byBhbnkgb2YgdGhlIHRyaWdvbm9tZXRyaWMgdmVydGljYWwgZnVuY3Rpb25zIChDT1MsIFNFQywgQ09TLVNFQywgb3IgU0VDLUNPUykuIFRoZSB5LWludGVyY2VwdCBpcyBkZWZpbmVkIGJ5IHRoZXNlIGZ1bmN0aW9ucy48L2xpPjxsaT48c3Ryb25nPkxvdyBDdXQgYW5nbGU8L3N0cm9uZz4tLURlZmluZXMgdGhlIFZSTUEgYW5nbGUgYmVsb3cgd2hpY2ggdGhlIFZGIHdpbGwgYmUgc2V0IHRvIGluZmluaXR5LjwvbGk+PGxpPjxzdHJvbmc+SGlnaCBDdXQgYW5nbGU8L3N0cm9uZz4tLURlZmluZXMgdGhlIFZSTUEgYW5nbGUgYWJvdmUgd2hpY2ggdGhlIFZGIHdpbGwgYmUgc2V0IHRvIGluZmluaXR5LjwvbGk+PGxpPjxzdHJvbmc+U2xvcGU8L3N0cm9uZz4tLUVzdGFibGlzaGVzIHRoZSBzbG9wZSBvZiB0aGUgc3RyYWlnaHQgbGluZSB1c2VkIHdpdGggdGhlPHN0cm9uZz5MaW5lYXI8L3N0cm9uZz5hbmQ8c3Ryb25nPkludmVyc2UgTGluZWFyPC9zdHJvbmc+dmVydGljYWwtZmFjdG9yIGtleXdvcmRzLiBUaGUgc2xvcGUgaXMgc3BlY2lmaWVkIGFzIGEgZnJhY3Rpb24gb2YgcmlzZSBvdmVyIHJ1biAoZm9yIGV4YW1wbGUsIDQ1IHBlcmNlbnQgc2xvcGUgaXMgMS80NSwgd2hpY2ggaXMgaW5wdXQgYXMgMC4wMjIyMikuPC9saT48bGk+PHN0cm9uZz5UYWJsZSBuYW1lPC9zdHJvbmc+LS1JZGVudGlmaWVzIHRoZSBuYW1lIG9mIHRoZSB0YWJsZSBkZWZpbmluZyB0aGUgVkYuPC9saT48L3VsPlwiLFxuXHRcIkBAUGF0aC1EaXN0YW5jZS1CYWNrLUxpbmtfVmVydGljYWwtUmFzdGVyX3RhZzBAQFwiOiBcIkRlZmluZXMgdGhlIHJlbGF0aW9uc2hpcCBiZXR3ZWVuIHRoZSB2ZXJ0aWNhbCBjb3N0IGZhY3RvciBhbmQgdGhlIHZlcnRpY2FsIHJlbGF0aXZlIG1vdmluZyBhbmdsZSAoVlJNQSkuXCIsXG5cdFwiQEBQYXRoLURpc3RhbmNlLUJhY2stTGlua19WZXJ0aWNhbC1SYXN0ZXJfdGFnMUBAXCI6IFwiVGhlIHZhbHVlcyBhcmUgdXNlZCBmb3IgY2FsY3VsYXRpbmcgdGhlIHNsb3BlIHVzZWQgdG8gaWRlbnRpZnkgdGhlIHZlcnRpY2FsIGZhY3RvciBpbmN1cnJlZCB3aGVuIG1vdmluZyBmcm9tIG9uZSBjZWxsIHRvIGFub3RoZXIuXCIsXG5cdFwiQEBQbHVzX0NlbGxzaXplLVR5cGVfdGFnMEBAXCI6IFwiQ2hvb3NlIHdoaWNoIGNlbGwgc2l6ZSB0byB1c2UgaW4gdGhlIG91dHB1dCByYXN0ZXIuIElmIGFsbCB0aGUgaW5wdXQgY2VsbCBzaXplcyBhcmUgdGhlIHNhbWUsIGFsbCB0aGUgb3B0aW9ucyB3aWxsIHlpZWxkIHRoZSBzYW1lIHJlc3VsdHMuXCIsXG5cdFwiQEBQbHVzX0NlbGxzaXplLVR5cGVfdGFnMUBAXCI6IFwiRmlyc3QgT2YtLVVzZSB0aGUgZmlyc3QgY2VsbCBzaXplIG9mIHRoZSBpbnB1dCByYXN0ZXJzLlwiLFxuXHRcIkBAUGx1c19DZWxsc2l6ZS1UeXBlX3RhZzJAQFwiOiBcIkxhc3QgT2YtLVVzZSB0aGUgbGFzdCBjZWxsIHNpemUgb2YgdGhlIGlucHV0IHJhc3RlcnMuXCIsXG5cdFwiQEBQbHVzX0NlbGxzaXplLVR5cGVfdGFnM0BAXCI6IFwiTWF4IE9mLS1Vc2UgdGhlIGxhcmdlc3QgY2VsbCBzaXplIG9mIGFsbCB0aGUgaW5wdXQgcmFzdGVycy4gVGhpcyBpcyB0aGUgZGVmYXVsdC5cIixcblx0XCJAQFBsdXNfQ2VsbHNpemUtVHlwZV90YWc0QEBcIjogXCJNZWFuIE9mLS1Vc2UgdGhlIG1lYW4gY2VsbCBzaXplIG9mIGFsbCB0aGUgaW5wdXQgcmFzdGVycy5cIixcblx0XCJAQFBsdXNfQ2VsbHNpemUtVHlwZV90YWc1QEBcIjogXCJNaW4gT2YtLVVzZSB0aGUgc21hbGxlc3QgY2VsbCBzaXplIG9mIGFsbCB0aGUgaW5wdXQgcmFzdGVycy5cIixcblx0XCJAQFBsdXNfRXh0ZW50LVR5cGVfdGFnMEBAXCI6IFwiQ2hvb3NlIHdoaWNoIGV4dGVudCBzaG91bGQgYmUgdXNlZCBpbiB0aGUgb3V0cHV0IHJhc3RlcjpcIixcblx0XCJAQFBsdXNfRXh0ZW50LVR5cGVfdGFnMUBAXCI6IFwiRmlyc3QgT2YtLVVzZSB0aGUgZXh0ZW50IG9mIHRoZSBmaXJzdCBpbnB1dCByYXN0ZXIgdG8gZGV0ZXJtaW5lIHRoZSBwcm9jZXNzaW5nIGV4dGVudC5cIixcblx0XCJAQFBsdXNfRXh0ZW50LVR5cGVfdGFnMkBAXCI6IFwiSW50ZXJzZWN0aW9uIE9mLS1Vc2UgdGhlIGV4dGVudCBvZiB0aGUgb3ZlcmxhcHBpbmcgcGl4ZWxzIHRvIGRldGVybWluZSB0aGUgcHJvY2Vzc2luZyBleHRlbnQuIFRoaXMgaXMgdGhlIGRlZmF1bHQuXCIsXG5cdFwiQEBQbHVzX0V4dGVudC1UeXBlX3RhZzNAQFwiOiBcIkxhc3QgT2YtLVVzZSB0aGUgZXh0ZW50IG9mIHRoZSBsYXN0IGlucHV0IHJhc3RlciB0byBkZXRlcm1pbmUgdGhlIHByb2Nlc3NpbmcgZXh0ZW50LlwiLFxuXHRcIkBAUGx1c19FeHRlbnQtVHlwZV90YWc0QEBcIjogXCJVbmlvbiBPZi0tVXNlIHRoZSBleHRlbnQgb2YgYWxsIHRoZSByYXN0ZXJzIHRvIGRldGVybWluZSB0aGUgcHJvY2Vzc2luZyBleHRlbnQuXCIsXG5cdFwiQEBQbHVzX1Jhc3Rlcl90YWcwQEBcIjogXCJUaGUgaW5wdXQgd2hvc2UgdmFsdWVzIHdpbGwgYmUgYWRkZWQgdG8uXCIsXG5cdFwiQEBQbHVzX1Jhc3Rlcl90YWcxQEBcIjogXCJBIGNvbnN0YW50IHZhbHVlIGNhbiBiZSB1c2VkIGFzIGFuIGlucHV0IGZvciB0aGlzIHBhcmFtZXRlciwgcHJvdmlkZWQgYSByYXN0ZXIgaXMgc3BlY2lmaWVkIGZvciB0aGUgb3RoZXIgcGFyYW1ldGVyLlwiLFxuXHRcIkBAUGx1c19SYXN0ZXIyX3RhZzBAQFwiOiBcIlRoZSBpbnB1dCB3aG9zZSB2YWx1ZXMgd2lsbCBiZSBhZGRlZCB0byB0aGUgZmlyc3QgaW5wdXQuXCIsXG5cdFwiQEBQbHVzX1Jhc3RlcjJfdGFnMUBAXCI6IFwiQSBjb25zdGFudCB2YWx1ZSBjYW4gYmUgdXNlZCBhcyBhbiBpbnB1dCBmb3IgdGhpcyBwYXJhbWV0ZXIsIHByb3ZpZGVkIGEgcmFzdGVyIGlzIHNwZWNpZmllZCBmb3IgdGhlIG90aGVyIHBhcmFtZXRlci5cIixcblx0XCJAQExvY2FsX0NlbGxzaXplLVR5cGVfdGFnMEBAXCI6IFwiQ2hvb3NlIHdoaWNoIGNlbGwgc2l6ZSB0byB1c2UgaW4gdGhlIG91dHB1dCByYXN0ZXIuIElmIGFsbCB0aGUgaW5wdXQgY2VsbCBzaXplcyBhcmUgdGhlIHNhbWUsIGFsbCB0aGUgb3B0aW9ucyB3aWxsIHlpZWxkIHRoZSBzYW1lIHJlc3VsdHMuXCIsXG5cdFwiQEBMb2NhbF9DZWxsc2l6ZS1UeXBlX3RhZzFAQFwiOiBcIkZpcnN0IE9mLS1Vc2UgdGhlIGZpcnN0IGNlbGwgc2l6ZSBvZiB0aGUgaW5wdXQgcmFzdGVycy5cIixcblx0XCJAQExvY2FsX0NlbGxzaXplLVR5cGVfdGFnMkBAXCI6IFwiTGFzdCBPZi0tVXNlIHRoZSBsYXN0IGNlbGwgc2l6ZSBvZiB0aGUgaW5wdXQgcmFzdGVycy5cIixcblx0XCJAQExvY2FsX0NlbGxzaXplLVR5cGVfdGFnM0BAXCI6IFwiTWF4IE9mLS1Vc2UgdGhlIGxhcmdlc3QgY2VsbCBzaXplIG9mIGFsbCB0aGUgaW5wdXQgcmFzdGVycy4gVGhpcyBpcyB0aGUgZGVmYXVsdC5cIixcblx0XCJAQExvY2FsX0NlbGxzaXplLVR5cGVfdGFnNEBAXCI6IFwiTWVhbiBPZi0tVXNlIHRoZSBtZWFuIGNlbGwgc2l6ZSBvZiBhbGwgdGhlIGlucHV0IHJhc3RlcnMuXCIsXG5cdFwiQEBMb2NhbF9DZWxsc2l6ZS1UeXBlX3RhZzVAQFwiOiBcIk1pbiBPZi0tVXNlIHRoZSBzbWFsbGVzdCBjZWxsIHNpemUgb2YgYWxsIHRoZSBpbnB1dCByYXN0ZXJzLlwiLFxuXHRcIkBATG9jYWxfRXh0ZW50LVR5cGVfdGFnMEBAXCI6IFwiQ2hvb3NlIHdoaWNoIGV4dGVudCBzaG91bGQgYmUgdXNlZCBpbiB0aGUgb3V0cHV0IHJhc3RlcjpcIixcblx0XCJAQExvY2FsX0V4dGVudC1UeXBlX3RhZzFAQFwiOiBcIkZpcnN0IE9mLS1Vc2UgdGhlIGV4dGVudCBvZiB0aGUgZmlyc3QgaW5wdXQgcmFzdGVyIHRvIGRldGVybWluZSB0aGUgcHJvY2Vzc2luZyBleHRlbnQuXCIsXG5cdFwiQEBMb2NhbF9FeHRlbnQtVHlwZV90YWcyQEBcIjogXCJJbnRlcnNlY3Rpb24gT2YtLVVzZSB0aGUgZXh0ZW50IG9mIHRoZSBvdmVybGFwcGluZyBwaXhlbHMgdG8gZGV0ZXJtaW5lIHRoZSBwcm9jZXNzaW5nIGV4dGVudC4gVGhpcyBpcyB0aGUgZGVmYXVsdC5cIixcblx0XCJAQExvY2FsX0V4dGVudC1UeXBlX3RhZzNAQFwiOiBcIkxhc3QgT2YtLVVzZSB0aGUgZXh0ZW50IG9mIHRoZSBsYXN0IGlucHV0IHJhc3RlciB0byBkZXRlcm1pbmUgdGhlIHByb2Nlc3NpbmcgZXh0ZW50LlwiLFxuXHRcIkBATG9jYWxfRXh0ZW50LVR5cGVfdGFnNEBAXCI6IFwiVW5pb24gT2YtLVVzZSB0aGUgZXh0ZW50IG9mIGFsbCB0aGUgcmFzdGVycyB0byBkZXRlcm1pbmUgdGhlIHByb2Nlc3NpbmcgZXh0ZW50LlwiLFxuXHRcIkBATG9jYWxfUmFzdGVyX3RhZzBAQFwiOiBcIlRoZSBpbnB1dCB3aG9zZSB2YWx1ZXMgd2lsbCBiZSBhZGRlZCB0by5cIixcblx0XCJAQExvY2FsX1Jhc3Rlcl90YWcxQEBcIjogXCJBIGNvbnN0YW50IHZhbHVlIGNhbiBiZSB1c2VkIGFzIGFuIGlucHV0IGZvciB0aGlzIHBhcmFtZXRlciwgcHJvdmlkZWQgYSByYXN0ZXIgaXMgc3BlY2lmaWVkIGZvciB0aGUgb3RoZXIgcGFyYW1ldGVyLlwiLFxuXHRcIkBATG9jYWxfUmFzdGVyMl90YWcwQEBcIjogXCJUaGUgaW5wdXQgd2hvc2UgdmFsdWVzIHdpbGwgYmUgYWRkZWQgdG8gdGhlIGZpcnN0IGlucHV0LlwiLFxuXHRcIkBATG9jYWxfUmFzdGVyMl90YWcxQEBcIjogXCJBIGNvbnN0YW50IHZhbHVlIGNhbiBiZSB1c2VkIGFzIGFuIGlucHV0IGZvciB0aGlzIHBhcmFtZXRlciwgcHJvdmlkZWQgYSByYXN0ZXIgaXMgc3BlY2lmaWVkIGZvciB0aGUgb3RoZXIgcGFyYW1ldGVyLlwiLFxuXHRcIkBATG9jYWxfRmFsc2UtUmFzdGVyX3RhZzBAQFwiOiBcIlRoZSBpbnB1dCB3aG9zZSB2YWx1ZXMgd2lsbCBiZSB1c2VkIGFzIHRoZSBvdXRwdXQgcGl4ZWwgdmFsdWVzIGlmIHRoZSBjb25kaXRpb24gaXMgZmFsc2UuIEl0IGNhbiBiZSBhbiBpbnRlZ2VyLCBhIGZsb2F0aW5nLXBvaW50IHJhc3Rlciwgb3IgYSBjb25zdGFudCB2YWx1ZS5cIixcblx0XCJAQExvY2FsX1RydWUtUmFzdGVyX3RhZzBAQFwiOiBcIlRoZSBpbnB1dCB3aG9zZSB2YWx1ZXMgd2lsbCBiZSB1c2VkIGFzIHRoZSBvdXRwdXQgcGl4ZWwgdmFsdWVzIGlmIHRoZSBjb25kaXRpb24gaXMgdHJ1ZS4gSXQgY2FuIGJlIGFuIGludGVnZXIsIGEgZmxvYXRpbmctcG9pbnQgcmFzdGVyLCBvciBhIGNvbnN0YW50IHZhbHVlLlwiLFxuXHRcIkBAUG93ZXJfQ2VsbHNpemUtVHlwZV90YWcwQEBcIjogXCJDaG9vc2Ugd2hpY2ggY2VsbCBzaXplIHRvIHVzZSBpbiB0aGUgb3V0cHV0IHJhc3Rlci4gSWYgYWxsIHRoZSBpbnB1dCBjZWxsIHNpemVzIGFyZSB0aGUgc2FtZSwgYWxsIHRoZSBvcHRpb25zIHdpbGwgeWllbGQgdGhlIHNhbWUgcmVzdWx0cy5cIixcblx0XCJAQFBvd2VyX0NlbGxzaXplLVR5cGVfdGFnMUBAXCI6IFwiRmlyc3QgT2YtLVVzZSB0aGUgZmlyc3QgY2VsbCBzaXplIG9mIHRoZSBpbnB1dCByYXN0ZXJzLlwiLFxuXHRcIkBAUG93ZXJfQ2VsbHNpemUtVHlwZV90YWcyQEBcIjogXCJMYXN0IE9mLS1Vc2UgdGhlIGxhc3QgY2VsbCBzaXplIG9mIHRoZSBpbnB1dCByYXN0ZXJzLlwiLFxuXHRcIkBAUG93ZXJfQ2VsbHNpemUtVHlwZV90YWczQEBcIjogXCJNYXggT2YtLVVzZSB0aGUgbGFyZ2VzdCBjZWxsIHNpemUgb2YgYWxsIHRoZSBpbnB1dCByYXN0ZXJzLiBUaGlzIGlzIHRoZSBkZWZhdWx0LlwiLFxuXHRcIkBAUG93ZXJfQ2VsbHNpemUtVHlwZV90YWc0QEBcIjogXCJNZWFuIE9mLS1Vc2UgdGhlIG1lYW4gY2VsbCBzaXplIG9mIGFsbCB0aGUgaW5wdXQgcmFzdGVycy5cIixcblx0XCJAQFBvd2VyX0NlbGxzaXplLVR5cGVfdGFnNUBAXCI6IFwiTWluIE9mLS1Vc2UgdGhlIHNtYWxsZXN0IGNlbGwgc2l6ZSBvZiBhbGwgdGhlIGlucHV0IHJhc3RlcnMuXCIsXG5cdFwiQEBQb3dlcl9FeHRlbnQtVHlwZV90YWcwQEBcIjogXCJDaG9vc2Ugd2hpY2ggZXh0ZW50IHNob3VsZCBiZSB1c2VkIGluIHRoZSBvdXRwdXQgcmFzdGVyOlwiLFxuXHRcIkBAUG93ZXJfRXh0ZW50LVR5cGVfdGFnMUBAXCI6IFwiRmlyc3QgT2YtLVVzZSB0aGUgZXh0ZW50IG9mIHRoZSBmaXJzdCBpbnB1dCByYXN0ZXIgdG8gZGV0ZXJtaW5lIHRoZSBwcm9jZXNzaW5nIGV4dGVudC5cIixcblx0XCJAQFBvd2VyX0V4dGVudC1UeXBlX3RhZzJAQFwiOiBcIkludGVyc2VjdGlvbiBPZi0tVXNlIHRoZSBleHRlbnQgb2YgdGhlIG92ZXJsYXBwaW5nIHBpeGVscyB0byBkZXRlcm1pbmUgdGhlIHByb2Nlc3NpbmcgZXh0ZW50LiBUaGlzIGlzIHRoZSBkZWZhdWx0LlwiLFxuXHRcIkBAUG93ZXJfRXh0ZW50LVR5cGVfdGFnM0BAXCI6IFwiTGFzdCBPZi0tVXNlIHRoZSBleHRlbnQgb2YgdGhlIGxhc3QgaW5wdXQgcmFzdGVyIHRvIGRldGVybWluZSB0aGUgcHJvY2Vzc2luZyBleHRlbnQuXCIsXG5cdFwiQEBQb3dlcl9FeHRlbnQtVHlwZV90YWc0QEBcIjogXCJVbmlvbiBPZi0tVXNlIHRoZSBleHRlbnQgb2YgYWxsIHRoZSByYXN0ZXJzIHRvIGRldGVybWluZSB0aGUgcHJvY2Vzc2luZyBleHRlbnQuXCIsXG5cdFwiQEBQb3dlcl9SYXN0ZXJfdGFnMEBAXCI6IFwiVGhlIGlucHV0IHZhbHVlcyB0byBiZSByYWlzZWQgdG8gdGhlIHBvd2VyIGRlZmluZWQgYnkgPHN0cm9uZz5SYXN0ZXIyPC9zdHJvbmc+LlwiLFxuXHRcIkBAUG93ZXJfUmFzdGVyX3RhZzNAQFwiOiBcIkEgY29uc3RhbnQgdmFsdWUgY2FuIGJlIHVzZWQgYXMgYW4gaW5wdXQgZm9yIHRoaXMgcGFyYW1ldGVyLCBwcm92aWRlZCBhIHJhc3RlciBpcyBzcGVjaWZpZWQgZm9yIHRoZSBvdGhlciBwYXJhbWV0ZXIuXCIsXG5cdFwiQEBQb3dlcl9SYXN0ZXIyX3RhZzBAQFwiOiBcIlRoZSBpbnB1dCB0aGF0IGRldGVybWluZXMgdGhlIHBvd2VyIHRvIHdoaWNoIHRoZSB2YWx1ZXMgb2YgPHN0cm9uZz5SYXN0ZXI8L3N0cm9uZz4gd2lsbCBiZSByYWlzZWQuXCIsXG5cdFwiQEBQb3dlcl9SYXN0ZXIyX3RhZzNAQFwiOiBcIkEgY29uc3RhbnQgdmFsdWUgY2FuIGJlIHVzZWQgYXMgYW4gaW5wdXQgZm9yIHRoaXMgcGFyYW1ldGVyLCBwcm92aWRlZCBhIHJhc3RlciBpcyBzcGVjaWZpZWQgZm9yIHRoZSBvdGhlciBwYXJhbWV0ZXIuXCIsXG5cdFwiQEBSYWRhci1DYWxpYnJhdGlvbl9DYWxpYnJhdGlvbi1UeXBlX3RhZzBAQFwiOiBcIlRoZSB0eXBlIG9mIGNhbGlicmF0aW9uIHRvIGJlIHBlcmZvcm1lZC5cIixcblx0XCJAQFJhZGFyLUNhbGlicmF0aW9uX0NhbGlicmF0aW9uLVR5cGVfdGFnMUBAXCI6IFwiQmV0YS1ub3VnaHQtLVRoZSBmdW5jdGlvbiByZXR1cm5zIHRoZSByYWRhciByZWZsZWN0aXZpdHkgcGVyIHVuaXQgYXJlYSBpbiBzbGFudCByYW5nZS4gVGhpcyBpcyB0aGUgZGVmYXVsdCBjYWxpYnJhdGlvbiB0eXBlLlwiLFxuXHRcIkBAUmFkYXItQ2FsaWJyYXRpb25fQ2FsaWJyYXRpb24tVHlwZV90YWcyQEBcIjogXCJTaWdtYS1ub3VnaHQtLVRoZSBmdW5jdGlvbiByZXR1cm5zIHRoZSByYWRhciByZWZsZWN0aXZpdHkgcGVyIHVuaXQgYXJlYSBpbiBncm91bmQgcmFuZ2UuIFJlc3VsdHMgYXJlIDMyLWJpdCBmbG9hdGluZy1wb2ludCB2YWx1ZXMgY29tbW9ubHkgaW4gdGhlIHJhbmdlIG9mIDAuMCB0byAxLjAuIE5vIGRhdGEgY2xpcHBpbmcgaXMgcGVyZm9ybWVkIGlmIHRoaXMgb3B0aW9uIGlzIHNlbGVjdGVkLlwiLFxuXHRcIkBAUmFkYXItQ2FsaWJyYXRpb25fQ2FsaWJyYXRpb24tVHlwZV90YWczQEBcIjogXCJHYW1tYS0tVGhlIGZ1bmN0aW9uIHJldHVybnMgdGhlIHJhZGFyIHJlZmxlY3Rpdml0eSBwZXIgdW5pdCBhcmVhIGluIHRoZSBwbGFuZSBwZXJwZW5kaWN1bGFyIHRvIHRoZSBkaXJlY3Rpb24gb2YgbWVhc3VyZW1lbnQuXCIsXG5cdFwiQEBSYWRhci1DYWxpYnJhdGlvbl9DYWxpYnJhdGlvbi1UeXBlX3RhZzRAQFwiOiBcIk5vbmVcIixcblx0XCJAQFJhZGFyLUNhbGlicmF0aW9uX1Jhc3Rlcl90YWcwQEBcIjogXCJUaGUgaW5wdXQgcmFzdGVyLlwiLFxuXHRcIkBAUmFzdGVySW5mb19SYXN0ZXItSW5mb190YWcwQEBcIjogXCJTZWxlY3QgYSByYXN0ZXIgZGF0YXNldCB0byB1c2UgYXMgYSB0ZW1wbGF0ZVwiLFxuXHRcIkBAUmFzdGVySW5mb19SYXN0ZXJfdGFnMEBAXCI6IFwiVGhlIGlucHV0IHJhc3Rlci5cIixcblx0XCJAQFJhc3Rlcml6ZS1BdHRyaWJ1dGVzX0F0dHJpYnV0ZS1GaWVsZC1OYW1lc190YWcwQEBcIjogXCJBIGxpc3Qgb2YgZmllbGRzIGluIHRoZSA8c3Ryb25nPlpvbmFsIEF0dHJpYnV0ZXMgVGFibGU8L3N0cm9uZz4gLCB3aGVyZSBlYWNoIGZpZWxkIGlzIHNlcGFyYXRlZCBieSBhIGNvbW1hLiBWYWx1ZXMgaW4gZWFjaCBmaWVsZCB3aWxsIGJlIHJlcHJlc2VudGVkIGJ5IGEgYmFuZCBpbiB0aGUgb3V0cHV0IHJhc3Rlci5cIixcblx0XCJAQFJhc3Rlcml6ZS1BdHRyaWJ1dGVzX0JhY2tncm91bmQtVmFsdWVfdGFnMEBAXCI6IFwiVGhlIGluaXRpYWwgcGl4ZWwgdmFsdWUgb2YgdGhlIG91dHB1dCBiYW5kcyBpbiBhIHJhc3RlciwgYmVmb3JlIGJlaW5nIHJlbWFwcGVkLlwiLFxuXHRcIkBAUmFzdGVyaXplLUF0dHJpYnV0ZXNfQmFja2dyb3VuZC1WYWx1ZV90YWcxQEBcIjogXCJJZiBhIHBpeGVsIGRvZXMgbm90IGZhbGwgd2l0aGluIGEgem9uZSwgaXQgd2lsbCByZW1haW4gYXMgdGhlIGJhY2tncm91bmQgdmFsdWUuXCIsXG5cdFwiQEBSYXN0ZXJpemUtQXR0cmlidXRlc19WYWx1ZS1SYXN0ZXJfdGFnMEBAXCI6IFwiVGhlIHJlcXVpcmVkIGlucHV0IHJhc3Rlci5cIixcblx0XCJAQFJhc3Rlcml6ZS1BdHRyaWJ1dGVzX1ZhbHVlLVJhc3Rlcl90YWcxQEBcIjogXCJUaGUgaW5wdXQgc2hvdWxkIGJlIGEgc2luZ2xlLWJhbmQgcmFzdGVyLiBJZiBhIG11bHRpYmFuZCByYXN0ZXIgaXMgdXNlZCwgb25seSB0aGUgZmlyc3QgYmFuZCB3aWxsIGJlIHVzZWQuXCIsXG5cdFwiQEBSYXN0ZXJpemUtQXR0cmlidXRlc19XaGVyZS1DbGF1c2VfdGFnMEBAXCI6IFwiQW4gb3B0aW9uYWwgYWRkaXRpb25hbCBxdWVyeSBhcHBsaWVkIG9uIHRoZSA8c3Ryb25nPlpvbmFsIEF0dHJpYnV0ZXMgVGFibGU8L3N0cm9uZz4uXCIsXG5cdFwiQEBSYXN0ZXJpemUtQXR0cmlidXRlc19XaGVyZS1DbGF1c2VfdGFnM0BAXCI6IFwiSWYgeW91IHdlcmUgdXNpbmcgdGhlIHRhYmxlIGFib3ZlIGFzIGFuIGV4YW1wbGUsIHRoZSBxdWVyeSB3b3VsZCBiZSAke1ZhcmlhYmxlMSA9ICdiYXJlIGVhcnRoJ30uXCIsXG5cdFwiQEBSYXN0ZXJpemUtQXR0cmlidXRlc19ab25hbC1BdHRyaWJ1dGVzLVRhYmxlX3RhZzBAQFwiOiBcIlRoZSB6b25hbCBhdHRyaWJ1dGVzIHNwZWNpZmllZCBhcyBhIHBhdGggdG8gYSBsb2NhbCBmZWF0dXJlIGNsYXNzLCB0aGUgcGF0aCB0byBhIHRhYmxlLCB0aGUgVVJMIHRvIGEgZmVhdHVyZSBzZXJ2aWNlIGxheWVyLCBvciBhIEpTT04gc3RyaW5nLlwiLFxuXHRcIkBAUmFzdGVyaXplLUF0dHJpYnV0ZXNfWm9uYWwtQXR0cmlidXRlcy1UYWJsZV90YWcxQEBcIjogXCJJbiBKU09OLCBpdCBpcyBkZXNjcmliZWQgYXMgYSBjb2xsZWN0aW9uIG9mIG1hcHBpbmcgZnJvbSB6b25lIElEcyB0byBhbiBhcnJheSBvZiBpbnRlZ2Vycy4gJHt7IHpvbmVJZDpbZjEsZjIsLi4uLGZuXSwgLi4uIH0gfVwiLFxuXHRcIkBAUmFzdGVyaXplLUF0dHJpYnV0ZXNfWm9uZS1GaWVsZF90YWcwQEBcIjogXCJUaGUgZmllbGQgbmFtZSBjb250YWluaW5nIHRoZSB6b25lIElEIHZhbHVlcy5cIixcblx0XCJAQFJhc3Rlcml6ZS1BdHRyaWJ1dGVzX1pvbmUtUmFzdGVyX3RhZzBAQFwiOiBcIkFuIG9wdGlvbmFsIHNpbmdsZS1iYW5kIHJhc3RlciB3aGVyZSBlYWNoIHBpeGVsIGNvbnRhaW5zIHRoZSB6b25lIElEIGFzc29jaWF0ZWQgd2l0aCB0aGUgbG9jYXRpb24uIFRoZSB6b25lIElEIGlzIHVzZWQgZm9yIGxvb2tpbmcgdXAgcm93cyBpbiB0aGUgem9uYWwgYXR0cmlidXRlcyB0YWJsZSBmb3Igem9uZS1zcGVjaWZpYyBpbmdlc3Rpb24uXCIsXG5cdFwiQEBSYXN0ZXJpemUtQXR0cmlidXRlc19ab25lLVJhc3Rlcl90YWcxQEBcIjogXCJMZWF2ZSB0aGlzIHBhcmFtZXRlciB1bnNwZWNpZmllZCBpZiB5b3Ugb25seSB3YW50IHRvIGltcG9ydCB0aGUgYXR0cmlidXRlLlwiLFxuXHRcIkBAUmFzdGVyaXplLUZlYXR1cmVzX0ZpZWxkX3RhZzBAQFwiOiBcIlNlbGVjdCB0aGUgZmllbGQgdG8gdXNlIHRvIGlkZW50aWZ5IGVhY2ggZmVhdHVyZS5cIixcblx0XCJAQFJhc3Rlcml6ZS1GZWF0dXJlc19JbnB1dC1GZWF0dXJlc190YWcwQEBcIjogXCJTZWxlY3QgdGhlIGZlYXR1cmUgY2xhc3MgdG8gY29udmVydCB0byByYXN0ZXIgZm9ybWF0LlwiLFxuXHRcIkBAUmFzdGVyaXplLUZlYXR1cmVzX1Jhc3Rlcl90YWcwQEBcIjogXCJTZWxlY3QgYSByYXN0ZXIgdG8gZGVmaW5lIHRoZSBjZWxsIHNpemUgYW5kIGV4dGVudCBmb3IgdGhlIGZlYXR1cmUgY29udmVyc2lvbi5cIixcblx0XCJAQFJhc3Rlcml6ZS1GZWF0dXJlc19SZXNvbHZlLU92ZXJsYXAtTWV0aG9kX3RhZzBAQFwiOiBcIkRldGVybWluZSBob3cgdG8gbWFuYWdlIGZlYXR1cmVzIHRoYXQgb3ZlcmxhcDpcIixcblx0XCJAQFJhc3Rlcml6ZS1GZWF0dXJlc19SZXNvbHZlLU92ZXJsYXAtTWV0aG9kX3RhZzFAQFwiOiBcIjxzdHJvbmc+Rmlyc3Q8L3N0cm9uZz4tLVRoZSBvdmVybGFwcGluZyBhcmVhcyB3aWxsIGJlIGFzc2lnbmVkIGEgdmFsdWUgZnJvbSB0aGUgZmlyc3QgZGF0YXNldCBsaXN0ZWQuXCIsXG5cdFwiQEBSYXN0ZXJpemUtRmVhdHVyZXNfUmVzb2x2ZS1PdmVybGFwLU1ldGhvZF90YWczQEBcIjogXCI8c3Ryb25nPkxhc3Q8L3N0cm9uZz4tLVRoZSBvdmVybGFwcGluZyBhcmVhcyB3aWxsIGJlIGFzc2lnbmVkIGEgdmFsdWUgZnJvbSB0aGUgbGFzdCBkYXRhc2V0IGxpc3RlZC5cIixcblx0XCJAQFJhc3Rlcml6ZS1GZWF0dXJlc19SZXNvbHZlLU92ZXJsYXAtTWV0aG9kX3RhZzVAQFwiOiBcIjxzdHJvbmc+U21hbGxlc3Q8L3N0cm9uZz4tLVRoZSBvdmVybGFwcGluZyBhcmVhcyB3aWxsIGJlIGFzc2lnbmVkIGEgdmFsdWUgZnJvbSB0aGUgc21hbGxlciBvZiB0aGUgZmVhdHVyZXMuXCIsXG5cdFwiQEBSYXN0ZXJpemUtRmVhdHVyZXNfUmVzb2x2ZS1PdmVybGFwLU1ldGhvZF90YWc3QEBcIjogXCI8c3Ryb25nPkxhcmdlc3Q8L3N0cm9uZz4tLVRoZSBvdmVybGFwcGluZyBhcmVhcyB3aWxsIGJlIGFzc2lnbmVkIGEgdmFsdWUgZnJvbSB0aGUgbGFyZ2VyIG9mIHRoZSBmZWF0dXJlcy5cIixcblx0XCJAQFJlY2FzdF9PdmVycmlkZXNfdGFnMEBAXCI6IFwiQSB0YWJsZSBvZiB2YXJpYWJsZSBuYW1lcyBhbmQgdXNlci1kZWZpbmVkIHZhbHVlcyB1c2VkIHRvIG1vZGlmeSBhIG1vc2FpYyBkYXRhc2V0LlwiLFxuXHRcIkBAUmVjYXN0X1Jhc3Rlcl90YWcwQEBcIjogXCJUaGUgcmFzdGVyIHByb2R1Y3QgdG8gd2hpY2ggdGhlIFJlY2FzdCBmdW5jdGlvbiB3aWxsIGJlIGFwcGxpZWQuXCIsXG5cdFwiQEBSZWdpb24tR3JvdXBfQWRkLUxpbmtfdGFnMEBAXCI6IFwiU3BlY2lmaWVzIHdoZXRoZXIgYSBsaW5rIGZpZWxkIGlzIGFkZGVkIHRvIHRoZSB0YWJsZSBvZiB0aGUgb3V0cHV0LlwiLFxuXHRcIkBAUmVnaW9uLUdyb3VwX0FkZC1MaW5rX3RhZzFAQFwiOiBcIjxzdHJvbmc+QWRkIExpbms8L3N0cm9uZz4tLUFuIGl0ZW0gJHtMSU5LfSBpdGVtIHdpbGwgYmUgYWRkZWQgdG8gdGhlIHRhYmxlIG9mIHRoZSBvdXRwdXQgcmFzdGVyLlwiLFxuXHRcIkBAUmVnaW9uLUdyb3VwX0FkZC1MaW5rX3RhZzNAQFwiOiBcIjxzdHJvbmc+Tm8gTGluazwvc3Ryb25nPi0tVGhlIGF0dHJpYnV0ZSB0YWJsZSBmb3IgdGhlIG91dHB1dCByYXN0ZXIgd2lsbCBvbmx5IGNvbnRhaW4gdGhlICR7VmFsdWV9IGFuZCAke0NvdW50fSBpdGVtcy5cIixcblx0XCJAQFJlZ2lvbi1Hcm91cF9FeGNsdWRlZC1WYWx1ZV90YWcwQEBcIjogXCJJZGVudGlmaWVzIGEgdmFsdWUgc3VjaCB0aGF0IGlmIGEgY2VsbCBsb2NhdGlvbiBjb250YWlucyB0aGUgdmFsdWUsIG5vIHNwYXRpYWwgY29ubmVjdGl2aXR5IHdpbGwgYmUgZXZhbHVhdGVkIHJlZ2FyZGxlc3MgaG93IHRoZSBudW1iZXIgb2YgbmVpZ2hib3JzIGlzIHNwZWNpZmllZCAoRk9VUiBvciBFSUdIVCkuXCIsXG5cdFwiQEBSZWdpb24tR3JvdXBfRXhjbHVkZWQtVmFsdWVfdGFnMUBAXCI6IFwiQ2VsbHMgd2l0aCB0aGUgZXhjbHVkZWQgdmFsdWUgd2lsbCBiZSB0cmVhdGVkIGFzIE5vRGF0YSBhbmQgYXJlIGVsaW1pbmF0ZWQgZnJvbSBjYWxjdWxhdGlvbnMuIENlbGwgbG9jYXRpb25zIHRoYXQgY29udGFpbiB0aGUgZXhjbHVkZWQgdmFsdWUgd2lsbCByZWNlaXZlIDAgb24gdGhlIG91dHB1dCByYXN0ZXIuXCIsXG5cdFwiQEBSZWdpb24tR3JvdXBfRXhjbHVkZWQtVmFsdWVfdGFnMkBAXCI6IFwiVGhlIGV4Y2x1ZGVkIHZhbHVlIGlzIHNpbWlsYXIgdG8gdGhlIGNvbmNlcHQgb2YgYSBiYWNrZ3JvdW5kIHZhbHVlLCBvciBoYXZpbmcgYSBtYXNrIGFwcGxpZWQuIEEgdmFsdWUgbXVzdCBiZSBzcGVjaWZpZWQgZm9yIHRoaXMgcGFyYW1ldGVyIGlmIHRoZSA8c3Ryb25nPiR7Q1JPU1N9PC9zdHJvbmc+IHBhcmFtZXRlciBpcyBzcGVjaWZpZWQuXCIsXG5cdFwiQEBSZWdpb24tR3JvdXBfTnVtYmVyLW9mLU5laWdoYm9yLUNlbGxzX3RhZzBAQFwiOiBcIlRoZSBudW1iZXIgb2YgbmVpZ2hib3JpbmcgY2VsbHMgdG8gdXNlIGluIGV2YWx1YXRpbmcgY29ubmVjdGl2aXR5IGJldHdlZW4gY2VsbHMuXCIsXG5cdFwiQEBSZWdpb24tR3JvdXBfTnVtYmVyLW9mLU5laWdoYm9yLUNlbGxzX3RhZzFAQFwiOiBcIjxzdHJvbmc+Rk9VUjwvc3Ryb25nPi0tRGVmaW5lcyBjb25uZWN0aXZpdHkgYmV0d2VlbiBjZWxscyBvZiB0aGUgc2FtZSB2YWx1ZSBvbmx5IGlmIHRoZSBjZWxscyBhcmUgZGlyZWN0bHkgdG8gdGhlIGxlZnQsIHJpZ2h0LCBhYm92ZSwgb3IgYmVsb3cgZWFjaCBvZiB0aGUgZm91ciBuZWFyZXN0IG5laWdoYm9ycy4gVGhpcyBpcyB0aGUgZGVmYXVsdC5cIixcblx0XCJAQFJlZ2lvbi1Hcm91cF9OdW1iZXItb2YtTmVpZ2hib3ItQ2VsbHNfdGFnM0BAXCI6IFwiPHN0cm9uZz5FSUdIVDwvc3Ryb25nPi0tRGVmaW5lcyBjb25uZWN0aXZpdHkgYmV0d2VlbiBjZWxscyBvZiB0aGUgc2FtZSB2YWx1ZSBpZiB0aGV5IGFyZSB3aXRoaW4gdGhlIGltbWVkaWF0ZSBlaWdodC1jZWxsIG5laWdoYm9yaG9vZCBvZiBlYWNoIG90aGVyLiBUaGlzIGluY2x1ZGVzIHRvIHRoZSByaWdodCwgbGVmdCwgYWJvdmUsIG9yIGRpYWdvbmFsIHRvIGVhY2ggb3RoZXIuXCIsXG5cdFwiQEBSZWdpb24tR3JvdXBfWm9uZS1Db25uZWN0aXZpdHlfdGFnMEBAXCI6IFwiRGVmaW5lcyB3aGljaCBjZWxsIHZhbHVlcyBzaG91bGQgYmUgY29uc2lkZXJlZCB3aGVuIHRlc3RpbmcgZm9yIGNvbm5lY3Rpdml0eS5cIixcblx0XCJAQFJlZ2lvbi1Hcm91cF9ab25lLUNvbm5lY3Rpdml0eV90YWcxQEBcIjogXCI8c3Ryb25nPldJVEhJTjwvc3Ryb25nPi0tVGVzdHMgY29ubmVjdGl2aXR5IGJldHdlZW4gaW5wdXQgdmFsdWVzIHRoYXQgYXJlIHRoZSBzYW1lIHdpdGhpbiB0aGUgc2FtZSB6b25lLiBUaGlzIGlzIHRoZSBkZWZhdWx0LlwiLFxuXHRcIkBAUmVnaW9uLUdyb3VwX1pvbmUtQ29ubmVjdGl2aXR5X3RhZzNAQFwiOiBcIlRoZSBvbmx5IGNlbGxzIHRoYXQgY2FuIGJlIGdyb3VwZWQgYXJlIGNlbGxzIGZyb20gdGhlIHNhbWUgem9uZSAodmFsdWUpIHRoYXQgbWVldCB0aGUgc3BhdGlhbCByZXF1aXJlbWVudHMgb2YgY29ubmVjdGl2aXR5IHNwZWNpZmllZCBieSB0aGUgPHN0cm9uZz5OdW1iZXIgb2YgbmVpZ2hib3JzPC9zdHJvbmc+IHBhcmFtZXRlciAoZm91ci13YXkgb3IgZWlnaHQtd2F5KS5cIixcblx0XCJAQFJlZ2lvbi1Hcm91cF9ab25lLUNvbm5lY3Rpdml0eV90YWc2QEBcIjogXCI8c3Ryb25nPkNST1NTPC9zdHJvbmc+LS1UZXN0cyBjb25uZWN0aXZpdHkgYnkgdGhlIHNwYXRpYWwgcmVxdWlyZW1lbnRzIHNwZWNpZmllZCBieSB0aGUgbnVtYmVyIG9mIG5laWdoYm9ycyBwYXJhbWV0ZXIgYmV0d2VlbiBjZWxscyB3aXRoIGFueSB2YWx1ZXMsIGV4Y2VwdCBmb3IgdGhlIHZhbHVlIGlkZW50aWZpZWQgdG8gYmUgZXhjbHVkZWQgYnkgdGhlIGV4Y2x1ZGVkIHZhbHVlIHBhcmFtZXRlci5cIixcblx0XCJAQFJlZ2lvbi1Hcm91cF9ab25lLUNvbm5lY3Rpdml0eV90YWc4QEBcIjogXCJXaGVuIHRoaXMgb3B0aW9uIGlzIHVzZWQsIGEgdmFsdWUgZm9yIHRoZSA8c3Ryb25nPkV4Y2x1ZGVkIHZhbHVlPC9zdHJvbmc+IHBhcmFtZXRlciBtdXN0IGJlIHNwZWNpZmllZC5cIixcblx0XCJAQFJlZ2lvbi1Hcm91cF9ab25lLVJhc3Rlcl90YWcwQEBcIjogXCJUaGUgcmVxdWlyZWQgaW5wdXQgcmFzdGVyIHdob3NlIHVuaXF1ZSBjb25uZWN0ZWQgcmVnaW9ucyB3aWxsIGJlIGlkZW50aWZpZWQuXCIsXG5cdFwiQEBSZWdpb24tR3JvdXBfWm9uZS1SYXN0ZXJfdGFnMUBAXCI6IFwiSXQgbXVzdCBiZSBvZiBpbnRlZ2VyIHR5cGUuXCIsXG5cdFwiQEBSZWdpb24tR3Jvd19GaWxsLVZhbHVlLUZpZWxkX3RhZzBAQFwiOiBcIlRoZSBmaWVsZCBpbiB0aGUgYXR0cmlidXRlIHRhYmxlIHRoYXQgZGVmaW5lcyB0aGUgZmlsbCB2YWx1ZSBmb3IgdGhlIGdyb3VwIG9mIHBpeGVscy4gSW4gYSBtdWx0aWJhbmQgaW1hZ2UsIGFsbCBiYW5kcyB3aWxsIGJlIGFzc2lnbmVkIHRoaXMgdmFsdWUuXCIsXG5cdFwiQEBSZWdpb24tR3Jvd19NYXgtR3Jvd3RoLVJhZGl1cy1GaWVsZF90YWcwQEBcIjogXCJUaGUgZmllbGQgaW4gdGhlIGF0dHJpYnV0ZSB0YWJsZSB0aGF0IGRlZmluZXMgdGhlIG1heGltdW0gZ3Jvd3RoIHJhZGl1cywgaW4gdGhlIGltYWdlJ3Mgc3BhdGlhbCByZWZlcmVuY2UgdW5pdHMuXCIsXG5cdFwiQEBSZWdpb24tR3Jvd19SYXN0ZXJfdGFnMEBAXCI6IFwiVGhlIHJhc3RlciB0aGF0IHlvdSB3YW50IHRvIHBlcmZvcm0gdGhpcyBmdW5jdGlvbiBvbi5cIixcblx0XCJAQFJlZ2lvbi1Hcm93X1NlZWQtUG9pbnRzX3RhZzBAQFwiOiBcIkEgcG9pbnQgZmVhdHVyZSBjbGFzcywgc2VydmluZyBhcyB0aGUgaW5pdGlhbCBzZWVkcyBmb3IgdGhlIGFsZ29yaXRobS4gRWFjaCBzZWVkIHBvaW50IGNvcnJlc3BvbmRzIHRvIG9uZSBlbnRyeSBpbiB0aGUgYXR0cmlidXRlIHRhYmxlLCB3aGljaCBjYXJyaWVzIHRoZSBtYXhpbXVtIGdyb3d0aCByYWRpdXMsIHNpbWlsYXJpdHkgdGhyZXNob2xkLCBhbmQgZmlsbCB2YWx1ZSBpbmZvcm1hdGlvbi5cIixcblx0XCJAQFJlZ2lvbi1Hcm93X1NpbWlsYXJpdHktVGhyZXNob2xkLUZpZWxkX3RhZzBAQFwiOiBcIlRoZSBmaWVsZCBpbiB0aGUgYXR0cmlidXRlIHRhYmxlIHRoYXQgZGVmaW5lcyB0aGUgc2ltaWxhcml0eSB0aHJlc2hvbGQsIGFzIEV1Y2xpZGVhbiBkaXN0YW5jZSBpbiBzcGVjdHJhbCBzcGFjZS5cIixcblx0XCJAQFJlbWFwX0FsbG93LVVubWF0Y2hlZC1QaXhlbC1WYWx1ZXNfdGFnMEBAXCI6IFwiTWlzc2luZyB2YWx1ZXMgaW4gdGhlIHJlY2xhc3MgdGFibGUgY2FuIHJldGFpbiB0aGVpciB2YWx1ZSBvciBiZSByZW1hcHBlZCB0byBOb0RhdGEuXCIsXG5cdFwiQEBSZW1hcF9BbGxvdy1Vbm1hdGNoZWQtUGl4ZWwtVmFsdWVzX3RhZzFAQFwiOiBcIlVuY2hlY2tlZC0tQW55IHBpeGVsIGZyb20gdGhlIGlucHV0IHJhc3RlciB0aGF0IGRvZXMgbm90IGdldCByZWNsYXNzZWQgaW4gYSByZW1hcCB0YWJsZSB3aWxsIHJldGFpbiBpdHMgdmFsdWUgYW5kIGJlIHdyaXR0ZW4gZm9yIGl0cyBsb2NhdGlvbiB0byB0aGUgb3V0cHV0IHJhc3Rlci4gVGhpcyBpcyB0aGUgZGVmYXVsdC5cIixcblx0XCJAQFJlbWFwX0FsbG93LVVubWF0Y2hlZC1QaXhlbC1WYWx1ZXNfdGFnMkBAXCI6IFwiQ2hlY2tlZC0tQW55IHBpeGVsIGZyb20gdGhlIGlucHV0IHJhc3RlciB0aGF0IGRvZXMgbm90IGdldCByZWNsYXNzZWQgaW4gYSByZW1hcCB0YWJsZSB3aWxsIGhhdmUgaXRzIHZhbHVlIHJlbWFwcGVkIHRvIE5vRGF0YSBmb3IgaXRzIGxvY2F0aW9uIHRvIHRoZSBvdXRwdXQgcmFzdGVyLlwiLFxuXHRcIkBAUmVtYXBfSW5wdXQtRmllbGRfdGFnMEBAXCI6IFwiQ2hvb3NlIHRoZSBmaWVsZCB0aGF0IHNwZWNpZmllcyB0aGUgaW5wdXQgcGl4ZWwgdmFsdWUgdGhhdCB3aWxsIGJlIHJlbWFwcGVkLlwiLFxuXHRcIkBAUmVtYXBfSW5wdXQtRmllbGRfdGFnMUBAXCI6IFwiSWYgeW91ciB0YWJsZSBoYXMgYSB2YWx1ZSByYW5nZSwgdGhpcyB3aWxsIGJlIHRoZSBtaW5pbXVtIHZhbHVlIGZpZWxkLCBhbmQgdGhlIDxzdHJvbmc+SW5wdXQgTWF4IEZpZWxkPC9zdHJvbmc+IHBhcmFtZXRlciBuZWVkcyB0byBiZSBzcGVjaWZpZWQgYXMgd2VsbC5cIixcblx0XCJAQFJlbWFwX0lucHV0LU1heC1GaWVsZF90YWcwQEBcIjogXCJDaG9vc2UgdGhlIG1heGltdW0gdmFsdWUgZmllbGQgaWYgeW91ciB0YWJsZSBzcGVjaWZpZXMgYSB2YWx1ZSByYW5nZS5cIixcblx0XCJAQFJlbWFwX0xpc3RfdGFnMEBAXCI6IFwiU3BlY2lmeSB0aGUgbWFwIHZhbHVlcyBhbmQgc3BlY2lmeSB0aGUgbWluaW11bSBhbmQgbWF4aW11bSB2YWx1ZSByYW5nZSBhbmQgdGhlIG5ldyByZW1hcCB2YWx1ZXMuIEluIGFkZGl0aW9uLCB0aGUgdmFsdWUgcmFuZ2UgY2FuIGJlIHNldCBhcyBOb0RhdGEgcGl4ZWxzLlwiLFxuXHRcIkBAUmVtYXBfT3V0cHV0LUZpZWxkX3RhZzBAQFwiOiBcIkNob29zZSB0aGUgZmllbGQgdGhhdCB3aWxsIGJlIHVzZWQgYXMgdGhlIG91dHB1dCByZW1hcHBlZCB2YWx1ZS5cIixcblx0XCJAQFJlbWFwX1Jhc3Rlcl90YWcwQEBcIjogXCJUaGUgaW5wdXQgcmFzdGVyLlwiLFxuXHRcIkBAUmVtYXBfUmVtYXAtRGVmaW5pdGlvbi1UeXBlX3RhZzBAQFwiOiBcIkNob29zZSB0aGUgb3B0aW9uIHlvdSB3YW50IHRvIHVzZSB0byBzZXQgdGhlIHJlbWFwIHZhbHVlczpcIixcblx0XCJAQFJlbWFwX1JlbWFwLURlZmluaXRpb24tVHlwZV90YWcxQEBcIjogXCJMaXN0LS1TcGVjaWZ5IGEgcmFuZ2Ugb2YgcGl4ZWwgdmFsdWVzIHRvIG1hcCB0byBhbiBvdXRwdXQgcGl4ZWwgdmFsdWVcIixcblx0XCJAQFJlbWFwX1JlbWFwLVRhYmxlLVR5cGVfdGFnMEBAXCI6IFwiQ2hvb3NlIHRoZSB0eXBlIG9mIHRhYmxlIHlvdSdsbCB1c2UgdG8gcmVtYXAgeW91ciBpbnB1dCByYXN0ZXI6XCIsXG5cdFwiQEBSZW1hcF9SZW1hcC1UYWJsZS1UeXBlX3RhZzFAQFwiOiBcIlNpbXBsZS0tVXNlcyB0aGUgPHN0cm9uZz5SZW1hcCBUYWJsZTwvc3Ryb25nPiBpbnB1dCB0byByZW1hcCB0aGUgPHN0cm9uZz5JbnB1dCBGaWVsZDwvc3Ryb25nPiBwaXhlbCB2YWx1ZXMgdG8gdGhlIGNvcnJlc3BvbmRpbmcgdmFsdWUgaW4gdGhlIDxzdHJvbmc+T3V0cHV0IEZpZWxkPC9zdHJvbmc+IHBhcmFtZXRlci4gVGhpcyBtZXRob2QgY2FjaGVzIHRoZSByZW1hcCB0YWJsZSBzbyB0aGF0IGl0IGNhbiBwZXJmb3JtIGZhc3Rlci5cIixcblx0XCJAQFJlbWFwX1JlbWFwLVRhYmxlLVR5cGVfdGFnOEBAXCI6IFwiRHluYW1pYy0tVGhpcyBtZXRob2QgZG9lcyBub3QgY2FjaGUgdGhlIHJlbWFwIHRhYmxlIGFuZCB3aWxsIG1ha2UgYSBxdWVyeSBlYWNoIHRpbWUgYSByZXF1ZXN0IGlzIG1hZGUgKHBhbiwgem9vbSwgb3IgcmVmcmVzaCkuIElmIHRoZSB0YWJsZSBjaGFuZ2VzLCB0aGUgbmV4dCByZXF1ZXN0IGNhbiBkeW5hbWljYWxseSByZW1hcCB0aGUgdmFsdWVzIGFjY29yZGluZ2x5LlwiLFxuXHRcIkBAUmVtYXBfUmVtYXAtVGFibGUtVHlwZV90YWc5QEBcIjogXCJSZWFzc2lnbm1lbnQtLUEgc3BlY2lmaWMgdGFibGUgdXNlZCBmb3IgdGhlIHJlY2xhc3NpZmljYXRpb24gcHJvY2Vzcywgd2hlcmUgZWFjaCByb3cgaW4gdGhlIHRhYmxlIHdpbGwgb25seSByZW1hcCBiYXNlZCBvbiBlYWNoIGZlYXR1cmUgYm91bmRhcnkuXCIsXG5cdFwiQEBSZW1hcF9SZW1hcC1UYWJsZV90YWcwQEBcIjogXCJCcm93c2UgdG8gdGhlIHRhYmxlIHRoYXQgc2V0cyB5b3VyIHJlbWFwIHZhbHVlcy5cIixcblx0XCJAQFJlcHJvamVjdF9SYXN0ZXJfdGFnMEBAXCI6IFwiVGhlIHJhc3RlciBkYXRhc2V0IHRvIGJlIHJlcHJvamVjdGVkIG9yIHJlc2FtcGxlZC5cIixcblx0XCJAQFJlcHJvamVjdF9TcGF0aWFsLVJlZmVyZW5jZV90YWcwQEBcIjogXCJUaGUgY29vcmRpbmF0ZSBzeXN0ZW0gdXNlZCB0byByZXByb2plY3QgdGhlIGRhdGEuXCIsXG5cdFwiQEBSZXByb2plY3RfWC1DZWxsc2l6ZV90YWcwQEBcIjogXCJUaGUgeC1kaW1lbnNpb24gdG8gd2hpY2ggdGhlIGRhdGEgc2hvdWxkIGJlIHJlc2FtcGxlZC4gVGhpcyBpcyBvcHRpb25hbC4gSWYgdGhlIHZhbHVlIGlzIDAgb3IgbGVzcywgdGhlIG91dHB1dCBlbnZlbG9wZSAoZXh0ZW50IGFuZCBjZWxsIHNpemVzKSBpcyBjYWxjdWxhdGVkIGZyb20gdGhlIGlucHV0IHJhc3Rlci5cIixcblx0XCJAQFJlcHJvamVjdF9YLVJlZ2lzdHJhdGlvbi1Qb2ludF90YWcwQEBcIjogXCJUaGUgeC1jb29yZGluYXRlIHVzZWQgdG8gZGVmaW5lIHRoZSB1cHBlciBsZWZ0IGNvcm5lciBvZiB0aGUgZGF0YXNldC4gVGhpcyBjb29yZGluYXRlIG11c3QgYmUgZGVmaW5lZCBpbiB0aGUgdW5pdHMgb2YgdGhlIG5ldyBzcGF0aWFsIHJlZmVyZW5jZS4gSWYgYm90aCB0aGUgPHN0cm9uZz5YIENlbGxzaXplPC9zdHJvbmc+IGFuZCA8c3Ryb25nPlkgQ2VsbHNpemU8L3N0cm9uZz4gcGFyYW1ldGVycyBhcmUgZ3JlYXRlciB0aGFuIDAsIHRoZXkgYXJlIHVzZWQgYWxvbmcgd2l0aCB0aGUgPHN0cm9uZz5YIFJlZ2lzdHJhdGlvbiBQb2ludDwvc3Ryb25nPiBhbmQgPHN0cm9uZz5ZIFJlZ2lzdHJhdGlvbiBQb2ludDwvc3Ryb25nPiBwYXJhbWV0ZXJzIHRvIGRlZmluZSB0aGUgb3V0cHV0IGVudmVsb3BlLlwiLFxuXHRcIkBAUmVwcm9qZWN0X1ktQ2VsbHNpemVfdGFnMEBAXCI6IFwiVGhlIHktZGltZW5zaW9uIHRvIHdoaWNoIHRoZSBkYXRhIHNob3VsZCBiZSByZXNhbXBsZWQuIFRoaXMgaXMgb3B0aW9uYWwuIElmIHRoZSB2YWx1ZSBpcyAwIG9yIGxlc3MsIHRoZSBvdXRwdXQgZW52ZWxvcGUgKGV4dGVudCBhbmQgY2VsbCBzaXplcykgaXMgY2FsY3VsYXRlZCBmcm9tIHRoZSBpbnB1dCByYXN0ZXIuXCIsXG5cdFwiQEBSZXByb2plY3RfWS1SZWdpc3RyYXRpb24tUG9pbnRfdGFnMEBAXCI6IFwiVGhlIHktY29vcmRpbmF0ZSB1c2VkIHRvIGRlZmluZSB0aGUgdXBwZXIgbGVmdCBjb3JuZXIgb2YgdGhlIGRhdGFzZXQuIFRoaXMgY29vcmRpbmF0ZSBtdXN0IGJlIGRlZmluZWQgaW4gdGhlIHVuaXRzIG9mIHRoZSBuZXcgc3BhdGlhbCByZWZlcmVuY2UuIElmIGJvdGggdGhlIDxzdHJvbmc+WCBDZWxsc2l6ZTwvc3Ryb25nPiBhbmQgPHN0cm9uZz5ZIENlbGxzaXplPC9zdHJvbmc+IHBhcmFtZXRlcnMgYXJlIGdyZWF0ZXIgdGhhbiAwLCB0aGV5IGFyZSB1c2VkIGFsb25nIHdpdGggdGhlIDxzdHJvbmc+WCBSZWdpc3RyYXRpb24gUG9pbnQ8L3N0cm9uZz4gYW5kIDxzdHJvbmc+WSBSZWdpc3RyYXRpb24gUG9pbnQ8L3N0cm9uZz4gcGFyYW1ldGVycyB0byBkZWZpbmUgdGhlIG91dHB1dCBlbnZlbG9wZS5cIixcblx0XCJAQFJlc2FtcGxlX0lucHV0LUNlbGxzaXplX3RhZzBAQFwiOiBcIlRoZSBwaXhlbCBjZWxsIHNpemUgb2YgdGhlIGlucHV0IHJhc3Rlci5cIixcblx0XCJAQFJlc2FtcGxlX091dHB1dC1DZWxsc2l6ZV90YWcwQEBcIjogXCJUaGUgcGl4ZWwgY2VsbCBzaXplIG9mIHRoZSBvdXRwdXQgcmFzdGVyLiBUaGUgY2VsbCBzaXplIGNhbiBiZSBjaGFuZ2VkLCBidXQgdGhlIGV4dGVudCBvZiB0aGUgcmFzdGVyIGRhdGFzZXQgd2lsbCByZW1haW4gdGhlIHNhbWUuIFJlc2FtcGxpbmcgZnJvbSBhIHVzZXItZGVmaW5lZCBjZWxsIHNpemUgY2FuIGJlIG11Y2ggc2xvd2VyIHRoYW4gdGhlIHN5c3RlbSBkZWZhdWx0LCBzaW5jZSB0aGUgc3lzdGVtIGRlZmF1bHQgcmVzYW1wbGluZyBwcm9jZXNzZXMgdGhlIG1pbmltdW0gYW1vdW50IG9mIGRhdGEgZnJvbSB0aGUgY2xvc2VzdCBwb3NzaWJsZSByZXNvbHV0aW9uLlwiLFxuXHRcIkBAUmVzYW1wbGVfUmFzdGVyX3RhZzBAQFwiOiBcIlRoZSBpbnB1dCByYXN0ZXIgdG8gYmUgcmVzYW1wbGVkLlwiLFxuXHRcIkBAUmVzYW1wbGVfUmVzYW1wbGluZy1UeXBlX3RhZzBAQFwiOiBcIjxzdHJvbmc+TmVhcmVzdCBOZWlnaGJvcjwvc3Ryb25nPi0tQ2FsY3VsYXRlcyB0aGUgb3V0cHV0IHBpeGVsIHZhbHVlIHVzaW5nIHRoZSBuZWFyZXN0IGlucHV0IHBpeGVsLiBOb0RhdGEgcGl4ZWxzIHdpbGwgcmVtYWluIHVuY2hhbmdlZCBpbiB0aGUgb3V0cHV0IHJhc3RlciBkYXRhc2V0LiBUaGlzIHRoZSBkZWZhdWx0LlwiLFxuXHRcIkBAUmVzYW1wbGVfUmVzYW1wbGluZy1UeXBlX3RhZzJAQFwiOiBcIjxzdHJvbmc+QmlsaW5lYXIgSW50ZXJwb2xhdGlvbjwvc3Ryb25nPi0tQ2FsY3VsYXRlcyB0aGUgcGl4ZWwgdmFsdWUgdXNpbmcgdGhlIGRpc3RhbmNlLXdlaWdodGVkIHZhbHVlIG9mIHRoZSBmb3VyIG5lYXJlc3QgcGl4ZWxzLiBUaGlzIG1ldGhvZCBpcyBjb21wdXRhdGlvbmFsbHkgZWZmaWNpZW50IHRvIHByb2Nlc3MuXCIsXG5cdFwiQEBSZXNhbXBsZV9SZXNhbXBsaW5nLVR5cGVfdGFnNEBAXCI6IFwiPHN0cm9uZz5DdWJpYyBDb252b2x1dGlvbjwvc3Ryb25nPi0tRGV0ZXJtaW5lcyB0aGUgbmV3IHZhbHVlIG9mIGEgcGl4ZWwgYmFzZWQgb24gZml0dGluZyBhIHNtb290aCBjdXJ2ZSB0aHJvdWdoIHRoZSAxNiBuZWFyZXN0IGlucHV0IHBpeGVsIGNlbnRlcnMuXCIsXG5cdFwiQEBSZXNhbXBsZV9SZXNhbXBsaW5nLVR5cGVfdGFnNkBAXCI6IFwiPHN0cm9uZz5NYWpvcml0eTwvc3Ryb25nPi0tQ2FsY3VsYXRlcyBwaXhlbCB2YWx1ZSB1c2luZyB0aGUgbWFqb3JpdHkgcGl4ZWwgdmFsdWUgaW4gdGhlIDE2IG5lYXJlc3QgcGl4ZWxzLiBOb0RhdGEgcGl4ZWxzIHdpbGwgcmVtYWluIHVuY2hhbmdlZCBpbiB0aGUgb3V0cHV0IHJhc3RlciBkYXRhc2V0LlwiLFxuXHRcIkBAUmVzYW1wbGVfUmVzYW1wbGluZy1UeXBlX3RhZzhAQFwiOiBcIjxzdHJvbmc+QmlsaW5lYXIgSW50ZXJwb2xhdGlvbiBQbHVzPC9zdHJvbmc+LS1Vc2VzIDxzdHJvbmc+QmlsaW5lYXIgSW50ZXJwb2xhdGlvbjwvc3Ryb25nPiwgZXhjZXB0IHRoZSBwaXhlbHMgYWxvbmcgdGhlIGVkZ2VzIGFyZSBkZWZpbmVkIGFzIE5vRGF0YSBhbmQgYXJlIG5vdCByZXBsaWNhdGVkIG9yIGNvbnNpZGVyZWQgaW4gdGhlIGNhbGN1bGF0aW9uLiBVc2UgPHN0cm9uZz5CaWxpbmVhciBJbnRlcnBvbGF0aW9uIFBsdXM8L3N0cm9uZz4gZm9yIHRpbGVkIGRhdGEgYmVjYXVzZSB0aGUgZWRnZXMgd2lsbCBtYXRjaCBiZXR0ZXIuXCIsXG5cdFwiQEBSZXNhbXBsZV9SZXNhbXBsaW5nLVR5cGVfdGFnMTRAQFwiOiBcIjxzdHJvbmc+R2F1c3MgQmx1cjwvc3Ryb25nPi0tQXBwbGllcyBhIEdhdXNzaWFuIGNvbnZvbHV0aW9uIHRvIHRoZSBzb3VyY2UgcmFzdGVyIGFuZCBjYWxjdWxhdGVzIHBpeGVsIHZhbHVlIHVzaW5nIHRoZSBkaXN0YW5jZS13ZWlnaHRlZCB2YWx1ZSBvZiBmb3VyIG5lYXJlc3QgcGl4ZWxzIGZyb20gdGhlIGJsdXJyZWQgcmFzdGVyLiBJdCBpcyBhcHByb3ByaWF0ZSBmb3IgcmVtb3Zpbmcgbm9pc2UgaW4gcmVzYW1wbGVkIGRhdGEgYW5kIGZvciBkb3duLXNhbXBsaW5nIHRvIGEgbGFyZ2VyIHBpeGVsIHNpemUuXCIsXG5cdFwiQEBSZXNhbXBsZV9SZXNhbXBsaW5nLVR5cGVfdGFnMTZAQFwiOiBcIjxzdHJvbmc+R2F1c3MgQmx1ciBQbHVzPC9zdHJvbmc+LS1Vc2VzIHRoZSBzYW1lIG1ldGhvZCBhcyA8c3Ryb25nPkdhdXNzIEJsdXI8L3N0cm9uZz4gLCBleGNlcHQgdGhlIHBpeGVscyBhbG9uZyB0aGUgZWRnZXMgYXJlIGRlZmluZWQgYXMgTm9EYXRhIGFuZCBhcmUgbm90IHJlcGxpY2F0ZWQgb3IgY29uc2lkZXJlZCBpbiB0aGUgY2FsY3VsYXRpb24uIFVzZSA8c3Ryb25nPkdhdXNzIEJsdXIgUGx1czwvc3Ryb25nPiBmb3IgdGlsZWQgZGF0YSBiZWNhdXNlIHRoZSBlZGdlcyB3aWxsIG1hdGNoIGJldHRlci5cIixcblx0XCJAQFJlc2FtcGxlX1Jlc2FtcGxpbmctVHlwZV90YWcyMkBAXCI6IFwiPHN0cm9uZz5BdmVyYWdlPC9zdHJvbmc+LS1DYWxjdWxhdGVzIHBpeGVsIHZhbHVlcyB1c2luZyB0aGUgYXZlcmFnZSB2YWx1ZSBvZiBhbGwgb3ZlcmxhcHBpbmcgcGl4ZWxzLCBmb3IgZWFjaCB0YXJnZXQgcGl4ZWwuXCIsXG5cdFwiQEBSZXNhbXBsZV9SZXNhbXBsaW5nLVR5cGVfdGFnMjRAQFwiOiBcIjxzdHJvbmc+TWluaW11bTwvc3Ryb25nPi0tQ2FsY3VsYXRlcyBwaXhlbCB2YWx1ZSB1c2luZyB0aGUgbWluaW11bSB2YWx1ZSBvZiBhbGwgb3ZlcmxhcHBpbmcgcGl4ZWxzLiBOb0RhdGEgcGl4ZWxzIHdpbGwgcmVtYWluIHVuY2hhbmdlZCBpbiB0aGUgb3V0cHV0IHJhc3RlciBkYXRhc2V0LlwiLFxuXHRcIkBAUmVzYW1wbGVfUmVzYW1wbGluZy1UeXBlX3RhZzI2QEBcIjogXCI8c3Ryb25nPk1heGltdW08L3N0cm9uZz4tLUFwcHJvcHJpYXRlIGZvciBjb250aW51b3VzIGRhdGEsIGl0IHByb2R1Y2VzIGEgc21vb3RoZXIgb3V0cHV0IGltYWdlIHRoYW4gdGhlIE5lYXJlc3QgTmVpZ2hib3IgcmVzYW1wbGluZyBtZXRob2QuXCIsXG5cdFwiQEBSZXNhbXBsZV9SZXNhbXBsaW5nLVR5cGVfdGFnMjhAQFwiOiBcIjxzdHJvbmc+VmVjdG9yIEF2ZXJhZ2U8L3N0cm9uZz4tLUNhbGN1bGF0ZXMgdmVjdG9yIGF2ZXJhZ2Ugb2YgbWFnbml0dWRlLWRpcmVjdGlvbiB1c2luZyBhbGwgaW52b2x2ZWQgcGl4ZWxzLiBUaGlzIG1ldGhvZCBpcyBvbmx5IGFwcGxpY2FibGUgZm9yIHR3byBiYW5kIHJhc3RlcnMgdGhhdCByZXByZXNlbnQgbWFnbml0dWRlIGFuZCBkaXJlY3Rpb24uIEl0IGZpcnN0IGNvbnZlcnRzIG1hZ25pdHVkZS1kaXJlY3Rpb24gaW50byBVLVYsIGFuZCB0aGVuIGl0IHRha2VzIHRoZSBhcml0aG1ldGljIGF2ZXJhZ2UgYWNyb3NzIGFsbCBpbnZvbHZlZCBwaXhlbHMgdG8gZ2V0IHRoZSBVLVYgb2YgdGhlIHRhcmdldCBwaXhlbCBhbmQgY29udmVydHMgaXQgYmFjayB0byBtYWduaXR1ZGUtZGlyZWN0aW9uLlwiLFxuXHRcIkBAUm91bmQtRG93bl9DZWxsc2l6ZS1UeXBlX3RhZzBAQFwiOiBcIkNob29zZSB3aGljaCBjZWxsIHNpemUgdG8gdXNlIGluIHRoZSBvdXRwdXQgcmFzdGVyLiBJZiBhbGwgdGhlIGlucHV0IGNlbGwgc2l6ZXMgYXJlIHRoZSBzYW1lLCBhbGwgdGhlIG9wdGlvbnMgd2lsbCB5aWVsZCB0aGUgc2FtZSByZXN1bHRzLlwiLFxuXHRcIkBAUm91bmQtRG93bl9DZWxsc2l6ZS1UeXBlX3RhZzFAQFwiOiBcIkZpcnN0IE9mLS1Vc2UgdGhlIGZpcnN0IGNlbGwgc2l6ZSBvZiB0aGUgaW5wdXQgcmFzdGVycy5cIixcblx0XCJAQFJvdW5kLURvd25fQ2VsbHNpemUtVHlwZV90YWcyQEBcIjogXCJMYXN0IE9mLS1Vc2UgdGhlIGxhc3QgY2VsbCBzaXplIG9mIHRoZSBpbnB1dCByYXN0ZXJzLlwiLFxuXHRcIkBAUm91bmQtRG93bl9DZWxsc2l6ZS1UeXBlX3RhZzNAQFwiOiBcIk1heCBPZi0tVXNlIHRoZSBsYXJnZXN0IGNlbGwgc2l6ZSBvZiBhbGwgdGhlIGlucHV0IHJhc3RlcnMuIFRoaXMgaXMgdGhlIGRlZmF1bHQuXCIsXG5cdFwiQEBSb3VuZC1Eb3duX0NlbGxzaXplLVR5cGVfdGFnNEBAXCI6IFwiTWVhbiBPZi0tVXNlIHRoZSBtZWFuIGNlbGwgc2l6ZSBvZiBhbGwgdGhlIGlucHV0IHJhc3RlcnMuXCIsXG5cdFwiQEBSb3VuZC1Eb3duX0NlbGxzaXplLVR5cGVfdGFnNUBAXCI6IFwiTWluIE9mLS1Vc2UgdGhlIHNtYWxsZXN0IGNlbGwgc2l6ZSBvZiBhbGwgdGhlIGlucHV0IHJhc3RlcnMuXCIsXG5cdFwiQEBSb3VuZC1Eb3duX0V4dGVudC1UeXBlX3RhZzBAQFwiOiBcIkNob29zZSB3aGljaCBleHRlbnQgc2hvdWxkIGJlIHVzZWQgaW4gdGhlIG91dHB1dCByYXN0ZXI6XCIsXG5cdFwiQEBSb3VuZC1Eb3duX0V4dGVudC1UeXBlX3RhZzFAQFwiOiBcIkZpcnN0IE9mLS1Vc2UgdGhlIGV4dGVudCBvZiB0aGUgZmlyc3QgaW5wdXQgcmFzdGVyIHRvIGRldGVybWluZSB0aGUgcHJvY2Vzc2luZyBleHRlbnQuXCIsXG5cdFwiQEBSb3VuZC1Eb3duX0V4dGVudC1UeXBlX3RhZzJAQFwiOiBcIkludGVyc2VjdGlvbiBPZi0tVXNlIHRoZSBleHRlbnQgb2YgdGhlIG92ZXJsYXBwaW5nIHBpeGVscyB0byBkZXRlcm1pbmUgdGhlIHByb2Nlc3NpbmcgZXh0ZW50LiBUaGlzIGlzIHRoZSBkZWZhdWx0LlwiLFxuXHRcIkBAUm91bmQtRG93bl9FeHRlbnQtVHlwZV90YWczQEBcIjogXCJMYXN0IE9mLS1Vc2UgdGhlIGV4dGVudCBvZiB0aGUgbGFzdCBpbnB1dCByYXN0ZXIgdG8gZGV0ZXJtaW5lIHRoZSBwcm9jZXNzaW5nIGV4dGVudC5cIixcblx0XCJAQFJvdW5kLURvd25fRXh0ZW50LVR5cGVfdGFnNEBAXCI6IFwiVW5pb24gT2YtLVVzZSB0aGUgZXh0ZW50IG9mIGFsbCB0aGUgcmFzdGVycyB0byBkZXRlcm1pbmUgdGhlIHByb2Nlc3NpbmcgZXh0ZW50LlwiLFxuXHRcIkBAUm91bmQtRG93bl9SYXN0ZXJfdGFnMEBAXCI6IFwiVGhlIGlucHV0IHZhbHVlcyB0byBiZSByb3VuZGVkIGRvd24uXCIsXG5cdFwiQEBSb3VuZC1VcF9DZWxsc2l6ZS1UeXBlX3RhZzBAQFwiOiBcIkNob29zZSB3aGljaCBjZWxsIHNpemUgdG8gdXNlIGluIHRoZSBvdXRwdXQgcmFzdGVyLiBJZiBhbGwgdGhlIGlucHV0IGNlbGwgc2l6ZXMgYXJlIHRoZSBzYW1lLCBhbGwgdGhlIG9wdGlvbnMgd2lsbCB5aWVsZCB0aGUgc2FtZSByZXN1bHRzLlwiLFxuXHRcIkBAUm91bmQtVXBfQ2VsbHNpemUtVHlwZV90YWcxQEBcIjogXCJGaXJzdCBPZi0tVXNlIHRoZSBmaXJzdCBjZWxsIHNpemUgb2YgdGhlIGlucHV0IHJhc3RlcnMuXCIsXG5cdFwiQEBSb3VuZC1VcF9DZWxsc2l6ZS1UeXBlX3RhZzJAQFwiOiBcIkxhc3QgT2YtLVVzZSB0aGUgbGFzdCBjZWxsIHNpemUgb2YgdGhlIGlucHV0IHJhc3RlcnMuXCIsXG5cdFwiQEBSb3VuZC1VcF9DZWxsc2l6ZS1UeXBlX3RhZzNAQFwiOiBcIk1heCBPZi0tVXNlIHRoZSBsYXJnZXN0IGNlbGwgc2l6ZSBvZiBhbGwgdGhlIGlucHV0IHJhc3RlcnMuIFRoaXMgaXMgdGhlIGRlZmF1bHQuXCIsXG5cdFwiQEBSb3VuZC1VcF9DZWxsc2l6ZS1UeXBlX3RhZzRAQFwiOiBcIk1lYW4gT2YtLVVzZSB0aGUgbWVhbiBjZWxsIHNpemUgb2YgYWxsIHRoZSBpbnB1dCByYXN0ZXJzLlwiLFxuXHRcIkBAUm91bmQtVXBfQ2VsbHNpemUtVHlwZV90YWc1QEBcIjogXCJNaW4gT2YtLVVzZSB0aGUgc21hbGxlc3QgY2VsbCBzaXplIG9mIGFsbCB0aGUgaW5wdXQgcmFzdGVycy5cIixcblx0XCJAQFJvdW5kLVVwX0V4dGVudC1UeXBlX3RhZzBAQFwiOiBcIkNob29zZSB3aGljaCBleHRlbnQgc2hvdWxkIGJlIHVzZWQgaW4gdGhlIG91dHB1dCByYXN0ZXI6XCIsXG5cdFwiQEBSb3VuZC1VcF9FeHRlbnQtVHlwZV90YWcxQEBcIjogXCJGaXJzdCBPZi0tVXNlIHRoZSBleHRlbnQgb2YgdGhlIGZpcnN0IGlucHV0IHJhc3RlciB0byBkZXRlcm1pbmUgdGhlIHByb2Nlc3NpbmcgZXh0ZW50LlwiLFxuXHRcIkBAUm91bmQtVXBfRXh0ZW50LVR5cGVfdGFnMkBAXCI6IFwiSW50ZXJzZWN0aW9uIE9mLS1Vc2UgdGhlIGV4dGVudCBvZiB0aGUgb3ZlcmxhcHBpbmcgcGl4ZWxzIHRvIGRldGVybWluZSB0aGUgcHJvY2Vzc2luZyBleHRlbnQuIFRoaXMgaXMgdGhlIGRlZmF1bHQuXCIsXG5cdFwiQEBSb3VuZC1VcF9FeHRlbnQtVHlwZV90YWczQEBcIjogXCJMYXN0IE9mLS1Vc2UgdGhlIGV4dGVudCBvZiB0aGUgbGFzdCBpbnB1dCByYXN0ZXIgdG8gZGV0ZXJtaW5lIHRoZSBwcm9jZXNzaW5nIGV4dGVudC5cIixcblx0XCJAQFJvdW5kLVVwX0V4dGVudC1UeXBlX3RhZzRAQFwiOiBcIlVuaW9uIE9mLS1Vc2UgdGhlIGV4dGVudCBvZiBhbGwgdGhlIHJhc3RlcnMgdG8gZGV0ZXJtaW5lIHRoZSBwcm9jZXNzaW5nIGV4dGVudC5cIixcblx0XCJAQFJvdW5kLVVwX1Jhc3Rlcl90YWcwQEBcIjogXCJUaGUgaW5wdXQgdmFsdWVzIHRvIGJlIHJvdW5kZWQgdXAuXCIsXG5cdFwiQEBTZWdtZW50LU1lYW4tU2hpZnRfTWluaW11bS1TZWdtZW50LVNpemUtaW4tUGl4ZWxzX3RhZzBAQFwiOiBcIlRoZSBtaW5pbXVtIHNlZ21lbnQgc2l6ZSwgbWVhc3VyZWQgaW4gcGl4ZWxzLiBUaGlzIHZhbHVlIGlzIHJlbGF0ZWQgdG8geW91ciBtaW5pbXVtIG1hcHBpbmcgdW5pdCwgYW5kIHdpbGwgZmlsdGVyIG91dCBzbWFsbGVyIGJsb2NrcyBvZiBwaXhlbHMuIEFsbCBzZWdtZW50cyB0aGF0IGFyZSBzbWFsbGVyIHRoYW4gdGhlIHNwZWNpZmllZCB2YWx1ZSB3aWxsIG1lcmdlIHRoZSBzbWFsbGVyIHNlZ21lbnRzIHdpdGggdGhlaXIgYmVzdCBmaXR0aW5nIG5laWdoYm9yIHNlZ21lbnQuXCIsXG5cdFwiQEBTZWdtZW50LU1lYW4tU2hpZnRfUmFzdGVyX3RhZzBAQFwiOiBcIlRoZSBpbnB1dCByYXN0ZXIgdG8gYmUgc2VnbWVudGVkLlwiLFxuXHRcIkBAU2VnbWVudC1NZWFuLVNoaWZ0X1NlZ21lbnQtYm91bmRhcmllcy1vbmx5X3RhZzBAQFwiOiBcIlRoZSBzZWdtZW50IGJvdW5kYXJpZXMgZHJhdyBhcyBhIGJsYWNrIGNvbnRvdXIgbGluZSBhcm91bmQgZWFjaCBzZWdtZW50LiBUaGlzIGlzIGhlbHBmdWwgc28geW91IGNhbiBkaXN0aW5ndWlzaCBhZGphY2VudCBzZWdtZW50cyB0aGF0IGhhdmUgc2ltaWxhciBjb2xvcnMuXCIsXG5cdFwiQEBTZWdtZW50LU1lYW4tU2hpZnRfU2VnbWVudC1ib3VuZGFyaWVzLW9ubHlfdGFnMUBAXCI6IFwiVW5jaGVja2VkLS1UaGUgc2VnbWVudCBib3VuZGFyaWVzIGFyZSBub3QgZGlzcGxheWVkLiBUaGlzIGlzIHRoZSBkZWZhdWx0LlwiLFxuXHRcIkBAU2VnbWVudC1NZWFuLVNoaWZ0X1NlZ21lbnQtYm91bmRhcmllcy1vbmx5X3RhZzJAQFwiOiBcIkNoZWNrZWQtLVRoZSBzZWdtZW50IGJvdW5kYXJpZXMgYXJlIGRpc3BsYXllZCB3aXRoIGJsYWNrIGNvbnRvdXIgbGluZXMgYXJvdW5kIGVhY2ggc2VnbWVudC5cIixcblx0XCJAQFNlZ21lbnQtTWVhbi1TaGlmdF9TcGF0aWFsLURldGFpbF90YWcwQEBcIjogXCJUaGUgcmVsYXRpdmUgaW1wb3J0YW5jZSBvZiBzZXBhcmF0aW5nIG9iamVjdHMgYmFzZWQgb24gc3BhdGlhbCBjaGFyYWN0ZXJpc3RpY3MuXCIsXG5cdFwiQEBTZWdtZW50LU1lYW4tU2hpZnRfU3BhdGlhbC1EZXRhaWxfdGFnMUBAXCI6IFwiVmFsaWQgaW50ZWdlciB2YWx1ZXMgcmFuZ2UgZnJvbSAxIHRvIDIwLiBTbWFsbGVyIHZhbHVlcyByZXN1bHQgaW4gYnJvYWQgY2xhc3NlcyBhbmQgbW9yZSBzbW9vdGhpbmcuIEEgaGlnaGVyIHZhbHVlIGlzIGFwcHJvcHJpYXRlIGZvciBkaXNjcmltaW5hdGluZyBiZXR3ZWVuIGZlYXR1cmVzIHRoYXQgYXJlIHNwYXRpYWxseSBzbWFsbCBhbmQgY2x1c3RlcmVkIHRvZ2V0aGVyLiBGb3IgZXhhbXBsZSwgaW4gYW4gdXJiYW4gc2NlbmUsIHlvdSBjb3VsZCBjbGFzc2lmeSBnZW5lcmFsIGltcGVydmlvdXMgc3VyZmFjZSBmZWF0dXJlcyB1c2luZyBhIHNtYWxsZXIgc3BhdGlhbCBkZXRhaWwgdmFsdWUsIG9yIHlvdSBjb3VsZCBjbGFzc2lmeSBidWlsZGluZ3MgYW5kIHJvYWRzIGFzIHNlcGFyYXRlIGNsYXNzZXMgdXNpbmcgYSBoaWdoZXIgc3BhdGlhbCBkZXRhaWwgdmFsdWUuXCIsXG5cdFwiQEBTZWdtZW50LU1lYW4tU2hpZnRfU3BlY3RyYWwtRGV0YWlsX3RhZzBAQFwiOiBcIlRoZSByZWxhdGl2ZSBpbXBvcnRhbmNlIG9mIHNlcGFyYXRpbmcgb2JqZWN0cyBiYXNlZCBvbiBjb2xvciBjaGFyYWN0ZXJpc3RpY3MuXCIsXG5cdFwiQEBTZWdtZW50LU1lYW4tU2hpZnRfU3BlY3RyYWwtRGV0YWlsX3RhZzFAQFwiOiBcIlZhbGlkIGZsb2F0aW5nLXBvaW50IHZhbHVlcyByYW5nZSBmcm9tIDEuMCB0byAyMC4wLiBTbWFsbGVyIHZhbHVlcyByZXN1bHQgaW4gYnJvYWQgY2xhc3NlcyBhbmQgbW9yZSBzbW9vdGhpbmcuIEEgaGlnaGVyIHZhbHVlIGlzIGFwcHJvcHJpYXRlIHdoZW4geW91IHdhbnQgdG8gZGlzY3JpbWluYXRlIGJldHdlZW4gZmVhdHVyZXMgaGF2aW5nIHNvbWV3aGF0IHNpbWlsYXIgc3BlY3RyYWwgY2hhcmFjdGVyaXN0aWNzLiBGb3IgZXhhbXBsZSwgdXNpbmcgYSBoaWdoZXIgc3BlY3RyYWwgZGV0YWlsIHZhbHVlIGluIGEgZm9yZXN0ZWQgc2NlbmUgYWxsb3dzIHlvdSB0byBiZXR0ZXIgZGlzdGluZ3Vpc2ggdGhlIGRpZmZlcmVudCB0cmVlIHNwZWNpZXMuXCIsXG5cdFwiQEBTZWdtZW50LU1lYW4tU2hpZnRfbWF4aW11bXNlZ21lbnRzaXplaW5waXhlbHNfdGFnMEBAXCI6IFwiPHA+VGhlIG1heGltdW0gc2l6ZSBvZiBhIHNlZ21lbnQuIFNlZ21lbnRzIHRoYXQgYXJlIGxhcmdlciB0aGFuIHRoZSBzcGVjaWZpZWQgc2l6ZSB3aWxsIGJlIGRpdmlkZWQuIFVzZSB0aGlzIHBhcmFtZXRlciB0byBwcmV2ZW50IGFydGlmYWN0cyBpbiB0aGUgb3V0cHV0IGxheWVyIHJlc3VsdGluZyBmcm9tIGxhcmdlIHNlZ21lbnRzLiBUaGUgZGVmYXVsdCBpcyAtMS48L3A+XCIsXG5cdFwiQEBTZW50aW5lbC0xLVJhZGlvbWV0cmljLUNhbGlicmF0aW9uX0NhbGlicmF0aW9uLVR5cGVfdGFnMEBAXCI6IFwiU2VsZWN0IG9uZSBvZiBmb3VyIGNhbGlicmF0aW9uIHR5cGVzOlwiLFxuXHRcIkBAU2VudGluZWwtMS1SYWRpb21ldHJpYy1DYWxpYnJhdGlvbl9DYWxpYnJhdGlvbi1UeXBlX3RhZzFAQFwiOiBcIjxzdHJvbmc+QmV0YSBub3VnaHQ8L3N0cm9uZz4tLXByb2R1Y2VzIGFuIG91dHB1dCBjb250YWluaW5nIHRoZSByYWRhciBicmlnaHRuZXNzIGNvZWZmaWNpZW50LlwiLFxuXHRcIkBAU2VudGluZWwtMS1SYWRpb21ldHJpYy1DYWxpYnJhdGlvbl9DYWxpYnJhdGlvbi1UeXBlX3RhZzNAQFwiOiBcIjxzdHJvbmc+U2lnbWEgbm91Z2h0PC9zdHJvbmc+LS10aGUgYmFja3NjYXR0ZXIgcmV0dXJuZWQgdG8gdGhlIGFudGVubmEgZnJvbSBhIHVuaXQgYXJlYSBvbiB0aGUgZ3JvdW5kLCByZWxhdGVkIHRvIGdyb3VuZCByYW5nZS5cIixcblx0XCJAQFNlbnRpbmVsLTEtUmFkaW9tZXRyaWMtQ2FsaWJyYXRpb25fQ2FsaWJyYXRpb24tVHlwZV90YWc1QEBcIjogXCI8c3Ryb25nPkdhbW1hPC9zdHJvbmc+LS1tZWFzdXJlbWVudCBvZiBlbWl0dGVkIGFuZCByZXR1cm5lZCBlbmVyZ3kgdXNlZnVsIGZvciBkZXRlcm1pbmluZyBhbnRlbm5hIHBhdHRlcm5zLlwiLFxuXHRcIkBAU2VudGluZWwtMS1SYWRpb21ldHJpYy1DYWxpYnJhdGlvbl9DYWxpYnJhdGlvbi1UeXBlX3RhZzdAQFwiOiBcIjxzdHJvbmc+Tm9uZTwvc3Ryb25nPi0tZG8gbm90IGFwcGx5IGEgY29ycmVjdGlvbi4gVGhpcyBpcyB0aGUgZGVmYXVsdC5cIixcblx0XCJAQFNlbnRpbmVsLTEtUmFkaW9tZXRyaWMtQ2FsaWJyYXRpb25fUmFzdGVyX3RhZzBAQFwiOiBcIlRoZSBTZW50aW5lbC0xIExldmVsLTEgR1JEIG9yIFNMQyBpbnB1dCByYXN0ZXIgeW91IHdhbnQgdG8gcHJvY2Vzcy5cIixcblx0XCJAQFNlbnRpbmVsLTEtUmFkaW9tZXRyaWMtQ2FsaWJyYXRpb25fUmFzdGVyX3RhZzFAQFwiOiBcIlRoZSBmdW5jdGlvbiB3aWxsIHVzZSB0aGUgTFVUIGZpbGUgZWl0aGVyIHRvIGFwcGx5IHRoZSB0aGVybWFsIGNvcnJlY3Rpb24gb3IgdG8gcmVtb3ZlIHRoZSBjb3JyZWN0aW9uLCBkZXBlbmRpbmcgb24gdGhlIGNvbnRlbnRzIG9mIHRoZSBMVVQuXCIsXG5cdFwiQEBTZW50aW5lbC0xLVRoZXJtYWwtTm9pc2UtUmVtb3ZhbF9SYXN0ZXJfdGFnMEBAXCI6IFwiVGhlIFNlbnRpbmVsLTEgaW5wdXQgcmFzdGVyIHlvdSB3YW50IHRvIHByb2Nlc3MuXCIsXG5cdFwiQEBTZW50aW5lbC0xLVRoZXJtYWwtTm9pc2UtUmVtb3ZhbF9SYXN0ZXJfdGFnMUBAXCI6IFwiVGhlIGZ1bmN0aW9uIHdpbGwgdXNlIHRoZSBMVVQgZmlsZSB0byBlaXRoZXIgYXBwbHkgdGhlIHRoZXJtYWwgY29ycmVjdGlvbiBvciByZW1vdmUgdGhlIGNvcnJlY3Rpb24gZGVwZW5kaW5nIG9uIHRoZSBjb250ZW50cyBvZiB0aGUgTFVULlwiLFxuXHRcIkBAU2V0LU51bGxfQ2VsbHNpemUtVHlwZV90YWcwQEBcIjogXCJDaG9vc2Ugd2hpY2ggY2VsbCBzaXplIHRvIHVzZSBpbiB0aGUgb3V0cHV0IHJhc3Rlci4gSWYgYWxsIHRoZSBpbnB1dCBjZWxsIHNpemVzIGFyZSB0aGUgc2FtZSwgYWxsIHRoZSBvcHRpb25zIHdpbGwgeWllbGQgdGhlIHNhbWUgcmVzdWx0cy5cIixcblx0XCJAQFNldC1OdWxsX0NlbGxzaXplLVR5cGVfdGFnMUBAXCI6IFwiRmlyc3QgT2YtLVVzZSB0aGUgZmlyc3QgY2VsbCBzaXplIG9mIHRoZSBpbnB1dCByYXN0ZXJzLlwiLFxuXHRcIkBAU2V0LU51bGxfQ2VsbHNpemUtVHlwZV90YWcyQEBcIjogXCJMYXN0IE9mLS1Vc2UgdGhlIGxhc3QgY2VsbCBzaXplIG9mIHRoZSBpbnB1dCByYXN0ZXJzLlwiLFxuXHRcIkBAU2V0LU51bGxfQ2VsbHNpemUtVHlwZV90YWczQEBcIjogXCJNYXggT2YtLVVzZSB0aGUgbGFyZ2VzdCBjZWxsIHNpemUgb2YgYWxsIHRoZSBpbnB1dCByYXN0ZXJzLiBUaGlzIGlzIHRoZSBkZWZhdWx0LlwiLFxuXHRcIkBAU2V0LU51bGxfQ2VsbHNpemUtVHlwZV90YWc0QEBcIjogXCJNZWFuIE9mLS1Vc2UgdGhlIG1lYW4gY2VsbCBzaXplIG9mIGFsbCB0aGUgaW5wdXQgcmFzdGVycy5cIixcblx0XCJAQFNldC1OdWxsX0NlbGxzaXplLVR5cGVfdGFnNUBAXCI6IFwiTWluIE9mLS1Vc2UgdGhlIHNtYWxsZXN0IGNlbGwgc2l6ZSBvZiBhbGwgdGhlIGlucHV0IHJhc3RlcnMuXCIsXG5cdFwiQEBTZXQtTnVsbF9FeHRlbnQtVHlwZV90YWcwQEBcIjogXCJDaG9vc2Ugd2hpY2ggZXh0ZW50IHNob3VsZCBiZSB1c2VkIGluIHRoZSBvdXRwdXQgcmFzdGVyOlwiLFxuXHRcIkBAU2V0LU51bGxfRXh0ZW50LVR5cGVfdGFnMUBAXCI6IFwiRmlyc3QgT2YtLVVzZSB0aGUgZXh0ZW50IG9mIHRoZSBmaXJzdCBpbnB1dCByYXN0ZXIgdG8gZGV0ZXJtaW5lIHRoZSBwcm9jZXNzaW5nIGV4dGVudC5cIixcblx0XCJAQFNldC1OdWxsX0V4dGVudC1UeXBlX3RhZzJAQFwiOiBcIkludGVyc2VjdGlvbiBPZi0tVXNlIHRoZSBleHRlbnQgb2YgdGhlIG92ZXJsYXBwaW5nIHBpeGVscyB0byBkZXRlcm1pbmUgdGhlIHByb2Nlc3NpbmcgZXh0ZW50LiBUaGlzIGlzIHRoZSBkZWZhdWx0LlwiLFxuXHRcIkBAU2V0LU51bGxfRXh0ZW50LVR5cGVfdGFnM0BAXCI6IFwiTGFzdCBPZi0tVXNlIHRoZSBleHRlbnQgb2YgdGhlIGxhc3QgaW5wdXQgcmFzdGVyIHRvIGRldGVybWluZSB0aGUgcHJvY2Vzc2luZyBleHRlbnQuXCIsXG5cdFwiQEBTZXQtTnVsbF9FeHRlbnQtVHlwZV90YWc0QEBcIjogXCJVbmlvbiBPZi0tVXNlIHRoZSBleHRlbnQgb2YgYWxsIHRoZSByYXN0ZXJzIHRvIGRldGVybWluZSB0aGUgcHJvY2Vzc2luZyBleHRlbnQuXCIsXG5cdFwiQEBTZXQtTnVsbF9GYWxzZS1SYXN0ZXJfdGFnMEBAXCI6IFwiVGhlIGlucHV0IHdob3NlIHZhbHVlcyB3aWxsIGJlIHVzZWQgYXMgdGhlIG91dHB1dCBwaXhlbCB2YWx1ZXMgaWYgdGhlIGNvbmRpdGlvbiBpcyBmYWxzZS4gSXQgY2FuIGJlIGFuIGludGVnZXIsIGEgZmxvYXRpbmctcG9pbnQgcmFzdGVyLCBvciBhIGNvbnN0YW50IHZhbHVlLlwiLFxuXHRcIkBAU2V0LU51bGxfUmFzdGVyX3RhZzBAQFwiOiBcIlRoZSBpbnB1dCByYXN0ZXIgdGhhdCByZXByZXNlbnRzIHRoZSBCb29sZWFuIHJlc3VsdCBvZiBhIGxvZ2ljYWwgbWF0aCByYXN0ZXIgZnVuY3Rpb24uIFRoZSB2YWx1ZXMgd2lsbCBiZSBlaXRoZXIgMSAoZm9yIHRydWUpIG9yIDAgKGZvciBmYWxzZSkuIEl0IGNhbiBiZSBhbiBpbnRlZ2VyIG9yIGEgZmxvYXRpbmctcG9pbnQgcmFzdGVyLlwiLFxuXHRcIkBAU2hhZGVkLVJlbGllZl9BbHRpdHVkZV90YWcwQEBcIjogXCJBbHRpdHVkZSBpcyB0aGUgc3VuJ3MgYW5nbGUgb2YgZWxldmF0aW9uIGFib3ZlIHRoZSBob3Jpem9uIGFuZCByYW5nZXMgZnJvbSAwIHRvIDkwIGRlZ3JlZXMuIEEgdmFsdWUgb2YgMCBkZWdyZWVzIGluZGljYXRlcyB0aGF0IHRoZSBzdW4gaXMgb24gdGhlIGhvcml6b24sIHRoYXQgaXMsIG9uIHRoZSBzYW1lIGhvcml6b250YWwgcGxhbmUgYXMgdGhlIGZyYW1lIG9mIHJlZmVyZW5jZS4gQSB2YWx1ZSBvZiA5MCBkZWdyZWVzIGluZGljYXRlcyB0aGF0IHRoZSBzdW4gaXMgZGlyZWN0bHkgb3ZlcmhlYWQuIFRoZSBkZWZhdWx0IGlzIDQ1IGRlZ3JlZXMgYWJvdmUgdGhlIGhvcml6b24uXCIsXG5cdFwiQEBTaGFkZWQtUmVsaWVmX0F6aW11dGhfdGFnMEBAXCI6IFwiQXppbXV0aCBpcyB0aGUgc3VuJ3MgcmVsYXRpdmUgcG9zaXRpb24gYWxvbmcgdGhlIGhvcml6b24gKGluIGRlZ3JlZXMpLiBUaGlzIHBvc2l0aW9uIGlzIGluZGljYXRlZCBieSB0aGUgYW5nbGUgb2YgdGhlIHN1biBtZWFzdXJlZCBjbG9ja3dpc2UgZnJvbSBkdWUgbm9ydGguIEFuIGF6aW11dGggb2YgMCBkZWdyZWVzIGluZGljYXRlcyBub3J0aCwgZWFzdCBpcyA5MCBkZWdyZWVzLCBzb3V0aCBpcyAxODAgZGVncmVlcywgYW5kIHdlc3QgaXMgMjcwIGRlZ3JlZXMuXCIsXG5cdFwiQEBTaGFkZWQtUmVsaWVmX0NvbG9yLVNjaGVtZS1UeXBlX3RhZzBAQFwiOiBcIlNwZWNpZnkgd2hldGhlciBhIGNvbG9yIHJhbXAgb3IgYSBjb2xvciBtYXAgd2lsbCBiZSB1c2VkIHRvIGRpc3BsYXkgdGhlIHNoYWRlZCByZWxpZWYuXCIsXG5cdFwiQEBTaGFkZWQtUmVsaWVmX0NvbG9yLVNjaGVtZS1UeXBlX3RhZzFAQFwiOiBcIjxzdHJvbmc+Q29sb3IgUmFtcDwvc3Ryb25nPi0tV2hlbiB5b3UgY2hvb3NlIDxzdHJvbmc+Q29sb3IgUmFtcDwvc3Ryb25nPiwgeW91IHdpbGwgYmUgcHJvbXB0ZWQgdG8gc2VsZWN0IGFuIGFwcHJvcHJpYXRlIGNvbG9yIHJhbXAuXCIsXG5cdFwiQEBTaGFkZWQtUmVsaWVmX0NvbG9yLVNjaGVtZS1UeXBlX3RhZzVAQFwiOiBcIjxzdHJvbmc+Q29sb3JtYXA8L3N0cm9uZz4tLVdoZW4geW91IGNob29zZSA8c3Ryb25nPkNvbG9ybWFwPC9zdHJvbmc+ICwgeW91IHdpbGwgYmUgcHJvbXB0ZWQgdG8gc3BlY2lmeSB0aGUgY29sb3IgbWFwIGZpbGUgdG8gdXNlLlwiLFxuXHRcIkBAU2hhZGVkLVJlbGllZl9EaXNhYmxlLWRlZmF1bHQtZWRnZS1waXhlbC1pbnRlcnBvbGF0aW9uX3RhZzBAQFwiOiBcIlNwZWNpZnkgd2hldGhlciB0aGUgZGVmYXVsdCBlZGdlIHBpeGVsIGludGVycG9sYXRpb24gd2l0aCBiZSBkaXNhYmxlZC5cIixcblx0XCJAQFNoYWRlZC1SZWxpZWZfRGlzYWJsZS1kZWZhdWx0LWVkZ2UtcGl4ZWwtaW50ZXJwb2xhdGlvbl90YWcxQEBcIjogXCJVbmNoZWNrZWQtLUJpbGluZWFyIHJlc2FtcGxpbmcgd2lsbCBiZSBhcHBsaWVkIHVuaWZvcm1seSB0byByZXNhbXBsZSB0aGUgc2hhZGVkIHJlbGllZi4gVGhpcyBpcyB0aGUgZGVmYXVsdC5cIixcblx0XCJAQFNoYWRlZC1SZWxpZWZfRGlzYWJsZS1kZWZhdWx0LWVkZ2UtcGl4ZWwtaW50ZXJwb2xhdGlvbl90YWcyQEBcIjogXCJDaGVja2VkLS1CaWxpbmVhciByZXNhbXBsaW5nIHdpbGwgYmUgdXNlZCB3aXRoaW4gdGhlIHNoYWRlZCByZWxpZWYsIGV4Y2VwdCBhbG9uZyB0aGUgZWRnZXMgb2YgdGhlIHJhc3RlcnMgb3IgbmV4dCB0byBwaXhlbHMgb2YgTm9EYXRhLiBUaGVzZSBwaXhlbHMgd2lsbCBiZSBwb3B1bGF0ZWQgd2l0aCBOb0RhdGEsIHNpbmNlIGl0IHdpbGwgcmVkdWNlIGFueSBzaGFycCBlZGdlIGVmZmVjdHMgdGhhdCBtYXkgb2NjdXIuXCIsXG5cdFwiQEBTaGFkZWQtUmVsaWVmX0Rpc2FibGUtZGVmYXVsdC1lZGdlLXBpeGVsLWludGVycG9sYXRpb25fdGFnM0BAXCI6IFwiVXNpbmcgdGhpcyBvcHRpb24gd2lsbCBhdm9pZCBhbnkgcmVzYW1wbGluZyBhcnRpZmFjdHMgdGhhdCBtYXkgb2NjdXIgYWxvbmcgdGhlIGVkZ2VzIG9mIGEgcmFzdGVyLiBUaGUgb3V0cHV0IHBpeGVscyBhbG9uZyB0aGUgZWRnZSBvZiBhIHJhc3RlciBvciBiZXNpZGUgcGl4ZWxzIHdpdGhvdXQgYSB2YWx1ZSB3aWxsIGJlIHBvcHVsYXRlZCB3aXRoIE5vRGF0YTsgdGhlcmVmb3JlLCBpdCBpcyByZWNvbW1lbmRlZCB0aGF0IHRoaXMgb3B0aW9uIGJlIHVzZWQgb25seSB3aGVuIHRoZXJlIGFyZSBvdGhlciByYXN0ZXJzIHdpdGggb3ZlcmxhcHBpbmcgcGl4ZWxzIGF2YWlsYWJsZS4gV2hlbiBvdmVybGFwcGluZyBwaXhlbHMgYXJlIGF2YWlsYWJsZSwgdGhlc2UgYXJlYXMgb2YgTm9EYXRhIHdpbGwgZGlzcGxheSB0aGUgb3ZlcmxhcHBpbmcgcGl4ZWwgdmFsdWVzIGluc3RlYWQgb2YgYmVpbmcgYmxhbmsuXCIsXG5cdFwiQEBTaGFkZWQtUmVsaWVmX1Jhc3Rlcl90YWcwQEBcIjogXCJUaGUgaW5wdXQgZWxldmF0aW9uIHJhc3Rlci5cIixcblx0XCJAQFNoYWRlZC1SZWxpZWZfU2NhbGluZ190YWcwQEBcIjogXCJUaGUgc2hhZGVkIHJlc3VsdCBpcyBzY2FsZWQgZHluYW1pY2FsbHkgYnkgYWRqdXN0aW5nIHRoZSB6LWZhY3RvciB1c2luZyBvbmUgb2YgdHdvIG9wdGlvbnM6XCIsXG5cdFwiQEBTaGFkZWQtUmVsaWVmX1NjYWxpbmdfdGFnMUBAXCI6IFwiPHN0cm9uZz5Ob25lPC9zdHJvbmc+LS1ObyBzY2FsaW5nIGlzIGFwcGxpZWQuIFRoaXMgaXMgaWRlYWwgZm9yIGEgc2luZ2xlIHJhc3RlciBkYXRhc2V0IGNvdmVyaW5nIGEgbG9jYWwgYXJlYS4gVGhpcyBpcyBub3QgcmVjb21tZW5kZWQgZm9yIHdvcmxkd2lkZSBkYXRhc2V0cyB3aXRoIGxhcmdlIHZhcmlhdGlvbnMgaW4gZWxldmF0aW9uIG9yIG11bHRpc2NhbGUgbWFwcywgYXMgaXQgd2lsbCBwcm9kdWNlIHRlcnJhaW4gcmVsaWVmIHdpdGggbGl0dGxlIHZhcmlhdGlvbiBhdCBzbWFsbCBzY2FsZXMuXCIsXG5cdFwiQEBTaGFkZWQtUmVsaWVmX1NjYWxpbmdfdGFnM0BAXCI6IFwiPHN0cm9uZz5BZGp1c3RlZDwvc3Ryb25nPi0tQSBub25saW5lYXIgYWRqdXN0bWVudCBpcyBhcHBsaWVkIHVzaW5nIHRoZSBkZWZhdWx0IDxzdHJvbmc+UGl4ZWwgU2l6ZSBQb3dlcjwvc3Ryb25nPiBhbmQgPHN0cm9uZz5QaXhlbCBTaXplIEZhY3Rvcjwvc3Ryb25nPiB2YWx1ZXMsIHdoaWNoIGFjY29tbW9kYXRlIGEgd2lkZSB2YXJpZXR5IG9mIGFsdGl0dWRlIGNoYW5nZXMgKHNjYWxlKSBhcyB0aGUgdmlld2VyIHpvb21zIGluIGFuZCBvdXQuIFRoZSA8c3Ryb25nPkFkanVzdGVkPC9zdHJvbmc+IG9wdGlvbiBpcyByZWNvbW1lbmRlZCB3aGVuIHVzaW5nIGEgd29ybGR3aWRlIGRhdGFzZXQuXCIsXG5cdFwiQEBTaGFkZWQtUmVsaWVmX1otRmFjdG9yX3RhZzBAQFwiOiBcIlRoZSB6LWZhY3RvciBpcyBhIHNjYWxpbmcgZmFjdG9yIHVzZWQgdG8gY29udmVydCB0aGUgZWxldmF0aW9uIHZhbHVlcyBmb3IgdHdvIHB1cnBvc2VzOlwiLFxuXHRcIkBAU2hhZGVkLVJlbGllZl9aLUZhY3Rvcl90YWcxQEBcIjogXCJUbyBjb252ZXJ0IHRoZSBlbGV2YXRpb24gdW5pdHMgKHN1Y2ggYXMgbWV0ZXJzIG9yIGZlZXQpIHRvIHRoZSBob3Jpem9udGFsIGNvb3JkaW5hdGUgdW5pdHMgb2YgdGhlIGRhdGFzZXQsIHdoaWNoIG1heSBiZSBmZWV0LCBtZXRlcnMsIG9yIGRlZ3JlZXNcIixcblx0XCJAQFNoYWRlZC1SZWxpZWZfWi1GYWN0b3JfdGFnMkBAXCI6IFwiVG8gYWRkIHZlcnRpY2FsIGV4YWdnZXJhdGlvbiBmb3IgdmlzdWFsIGVmZmVjdFwiLFxuXHRcIkBAU2hhZGVkLVJlbGllZl9aLUZhY3Rvcl90YWczQEBcIjogXCJUaGUgc2hhZGVkIHJlc3VsdCBpcyBzY2FsZWQgZHluYW1pY2FsbHkgYnkgYWRqdXN0aW5nIHRoZSB6LWZhY3RvciB1c2luZyBvbmUgb2YgdHdvIG9wdGlvbnM6XCIsXG5cdFwiQEBTaGFkZWQtUmVsaWVmX1otRmFjdG9yX3RhZzRAQFwiOiBcIjxzdHJvbmc+Tm9uZTwvc3Ryb25nPi0tTm8gc2NhbGluZyBpcyBhcHBsaWVkLiBUaGlzIGlzIGlkZWFsIGZvciBhIHNpbmdsZSByYXN0ZXIgZGF0YXNldCBjb3ZlcmluZyBhIGxvY2FsIGFyZWEuIFRoaXMgaXMgbm90IHJlY29tbWVuZGVkIGZvciB3b3JsZHdpZGUgZGF0YXNldHMgd2l0aCBsYXJnZSB2YXJpYXRpb25zIGluIGVsZXZhdGlvbiBvciBtdWx0aXNjYWxlIG1hcHMsIGFzIGl0IHdpbGwgcHJvZHVjZSB0ZXJyYWluIHJlbGllZiB3aXRoIGxpdHRsZSB2YXJpYXRpb24gYXQgc21hbGwgc2NhbGVzLlwiLFxuXHRcIkBAU2hhZGVkLVJlbGllZl9aLUZhY3Rvcl90YWc2QEBcIjogXCI8c3Ryb25nPkFkanVzdGVkPC9zdHJvbmc+LS1BIG5vbmxpbmVhciBhZGp1c3RtZW50IGlzIGFwcGxpZWQgdXNpbmcgdGhlIGRlZmF1bHQgPHN0cm9uZz5QaXhlbCBTaXplIFBvd2VyPC9zdHJvbmc+IGFuZCA8c3Ryb25nPlBpeGVsIFNpemUgRmFjdG9yPC9zdHJvbmc+IHZhbHVlcywgd2hpY2ggYWNjb21tb2RhdGUgYSB3aWRlIHZhcmlldHkgb2YgYWx0aXR1ZGUgY2hhbmdlcyAoc2NhbGUpIGFzIHRoZSB2aWV3ZXIgem9vbXMgaW4gYW5kIG91dC4gVGhlIDxzdHJvbmc+QWRqdXN0ZWQ8L3N0cm9uZz4gb3B0aW9uIGlzIHJlY29tbWVuZGVkIHdoZW4gdXNpbmcgYSB3b3JsZHdpZGUgZGF0YXNldC5cIixcblx0XCJAQFNoYWRlZC1SZWxpZWZfaGlsbHNoYWRldHlwZV90YWcwQEBcIjogXCJDb250cm9scyB0aGUgaWxsdW1pbmF0aW9uIHNvdXJjZSBmb3IgdGhlIGhpbGxzaGFkZS5cIixcblx0XCJAQFNoYWRlZC1SZWxpZWZfaGlsbHNoYWRldHlwZV90YWcxQEBcIjogXCI8c3Ryb25nPlRyYWRpdGlvbmFsPC9zdHJvbmc+LS1DYWxjdWxhdGVzIGhpbGxzaGFkZSBmcm9tIGEgc2luZ2xlIGlsbHVtaW5hdGlvbiBkaXJlY3Rpb24uIFlvdSBjYW4gc2V0IHRoZSA8c3Ryb25nPkF6aW11dGg8L3N0cm9uZz4gYW5kIDxzdHJvbmc+QWx0aXR1ZGU8L3N0cm9uZz4gb3B0aW9ucyB0byBjb250cm9sIHRoZSBsb2NhdGlvbiBvZiB0aGUgbGlnaHQgc291cmNlLiBUaGlzIGlzIHRoZSBkZWZhdWx0LlwiLFxuXHRcIkBAU2hhZGVkLVJlbGllZl9oaWxsc2hhZGV0eXBlX3RhZzJAQFwiOiBcIjxzdHJvbmc+TXVsdGlkaXJlY3Rpb25hbDwvc3Ryb25nPi0tQ29tYmluZXMgbGlnaHQgZnJvbSBtdWx0aXBsZSBzb3VyY2VzIHRvIHJlcHJlc2VudCBhbiBlbmhhbmNlZCB2aXN1YWxpemF0aW9uIG9mIHRoZSB0ZXJyYWluLlwiLFxuXHRcIkBAU2hhZGVkLVJlbGllZl9QU1Bvd2VyX3RhZzBAQFwiOiBcIjxzdHJvbmc+UGl4ZWwgU2l6ZSBQb3dlcjwvc3Ryb25nPiBhY2NvdW50cyBmb3IgdGhlIGFsdGl0dWRlIGNoYW5nZXMgKG9yIHNjYWxlKSBhcyB0aGUgdmlld2VyIHpvb21zIGluIGFuZCBvdXQgb24gdGhlIG1hcCBkaXNwbGF5LiBJdCBpcyB0aGUgZXhwb25lbnQgYXBwbGllZCB0byB0aGUgcGl4ZWwgc2l6ZSB0ZXJtIGluIHRoZSBlcXVhdGlvbiB0aGF0IGNvbnRyb2xzIHRoZSByYXRlIGF0IHdoaWNoIHRoZSA8c3Ryb25nPlogRmFjdG9yPC9zdHJvbmc+IGNoYW5nZXMgdG8gYXZvaWQgc2lnbmlmaWNhbnQgbG9zcyBvZiByZWxpZWYuXCIsXG5cdFwiQEBTaGFkZWQtUmVsaWVmX1BTUG93ZXJfdGFnMUBAXCI6IFwiVGhpcyBwYXJhbWV0ZXIgaXMgb25seSB2YWxpZCB3aGVuIHRoZSA8c3Ryb25nPlNjYWxpbmc8L3N0cm9uZz4gdHlwZSBpcyA8c3Ryb25nPkFkanVzdGVkPC9zdHJvbmc+LiBUaGUgZGVmYXVsdCB2YWx1ZSBpcyAwLjY2NC5cIixcblx0XCJAQFNoYWRlZC1SZWxpZWZfUFNaRmFjdG9yX3RhZzBAQFwiOiBcIjxzdHJvbmc+UGl4ZWwgU2l6ZSBGYWN0b3I8L3N0cm9uZz4gYWNjb3VudHMgZm9yIGNoYW5nZXMgaW4gc2NhbGUgYXMgdGhlIHZpZXdlciB6b29tcyBpbiBhbmQgb3V0IG9uIHRoZSBtYXAgZGlzcGxheS4gSXQgY29udHJvbHMgdGhlIHJhdGUgYXQgd2hpY2ggdGhlIDxzdHJvbmc+WiBGYWN0b3I8L3N0cm9uZz4gY2hhbmdlcy5cIixcblx0XCJAQFNoYWRlZC1SZWxpZWZfUFNaRmFjdG9yX3RhZzFAQFwiOiBcIlRoaXMgcGFyYW1ldGVyIGlzIG9ubHkgdmFsaWQgd2hlbiB0aGUgPHN0cm9uZz5TY2FsaW5nPC9zdHJvbmc+IHR5cGUgaXMgPHN0cm9uZz5BZGp1c3RlZDwvc3Ryb25nPi4gVGhlIGRlZmF1bHQgdmFsdWUgaXMgMC4wMjQuXCIsXG5cdFwiQEBTaW5fQ2VsbHNpemUtVHlwZV90YWcwQEBcIjogXCJDaG9vc2Ugd2hpY2ggY2VsbCBzaXplIHRvIHVzZSBpbiB0aGUgb3V0cHV0IHJhc3Rlci4gSWYgYWxsIHRoZSBpbnB1dCBjZWxsIHNpemVzIGFyZSB0aGUgc2FtZSwgYWxsIHRoZSBvcHRpb25zIHdpbGwgeWllbGQgdGhlIHNhbWUgcmVzdWx0cy5cIixcblx0XCJAQFNpbl9DZWxsc2l6ZS1UeXBlX3RhZzFAQFwiOiBcIkZpcnN0IE9mLS1Vc2UgdGhlIGZpcnN0IGNlbGwgc2l6ZSBvZiB0aGUgaW5wdXQgcmFzdGVycy5cIixcblx0XCJAQFNpbl9DZWxsc2l6ZS1UeXBlX3RhZzJAQFwiOiBcIkxhc3QgT2YtLVVzZSB0aGUgbGFzdCBjZWxsIHNpemUgb2YgdGhlIGlucHV0IHJhc3RlcnMuXCIsXG5cdFwiQEBTaW5fQ2VsbHNpemUtVHlwZV90YWczQEBcIjogXCJNYXggT2YtLVVzZSB0aGUgbGFyZ2VzdCBjZWxsIHNpemUgb2YgYWxsIHRoZSBpbnB1dCByYXN0ZXJzLiBUaGlzIGlzIHRoZSBkZWZhdWx0LlwiLFxuXHRcIkBAU2luX0NlbGxzaXplLVR5cGVfdGFnNEBAXCI6IFwiTWVhbiBPZi0tVXNlIHRoZSBtZWFuIGNlbGwgc2l6ZSBvZiBhbGwgdGhlIGlucHV0IHJhc3RlcnMuXCIsXG5cdFwiQEBTaW5fQ2VsbHNpemUtVHlwZV90YWc1QEBcIjogXCJNaW4gT2YtLVVzZSB0aGUgc21hbGxlc3QgY2VsbCBzaXplIG9mIGFsbCB0aGUgaW5wdXQgcmFzdGVycy5cIixcblx0XCJAQFNpbl9FeHRlbnQtVHlwZV90YWcwQEBcIjogXCJDaG9vc2Ugd2hpY2ggZXh0ZW50IHNob3VsZCBiZSB1c2VkIGluIHRoZSBvdXRwdXQgcmFzdGVyOlwiLFxuXHRcIkBAU2luX0V4dGVudC1UeXBlX3RhZzFAQFwiOiBcIkZpcnN0IE9mLS1Vc2UgdGhlIGV4dGVudCBvZiB0aGUgZmlyc3QgaW5wdXQgcmFzdGVyIHRvIGRldGVybWluZSB0aGUgcHJvY2Vzc2luZyBleHRlbnQuXCIsXG5cdFwiQEBTaW5fRXh0ZW50LVR5cGVfdGFnMkBAXCI6IFwiSW50ZXJzZWN0aW9uIE9mLS1Vc2UgdGhlIGV4dGVudCBvZiB0aGUgb3ZlcmxhcHBpbmcgcGl4ZWxzIHRvIGRldGVybWluZSB0aGUgcHJvY2Vzc2luZyBleHRlbnQuIFRoaXMgaXMgdGhlIGRlZmF1bHQuXCIsXG5cdFwiQEBTaW5fRXh0ZW50LVR5cGVfdGFnM0BAXCI6IFwiTGFzdCBPZi0tVXNlIHRoZSBleHRlbnQgb2YgdGhlIGxhc3QgaW5wdXQgcmFzdGVyIHRvIGRldGVybWluZSB0aGUgcHJvY2Vzc2luZyBleHRlbnQuXCIsXG5cdFwiQEBTaW5fRXh0ZW50LVR5cGVfdGFnNEBAXCI6IFwiVW5pb24gT2YtLVVzZSB0aGUgZXh0ZW50IG9mIGFsbCB0aGUgcmFzdGVycyB0byBkZXRlcm1pbmUgdGhlIHByb2Nlc3NpbmcgZXh0ZW50LlwiLFxuXHRcIkBAU2luX1Jhc3Rlcl90YWcwQEBcIjogXCJUaGUgaW5wdXQgZm9yIHdoaWNoIHRvIGNhbGN1bGF0ZSB0aGUgc2luZSB2YWx1ZXMuXCIsXG5cdFwiQEBTaW5IX0NlbGxzaXplLVR5cGVfdGFnMEBAXCI6IFwiQ2hvb3NlIHdoaWNoIGNlbGwgc2l6ZSB0byB1c2UgaW4gdGhlIG91dHB1dCByYXN0ZXIuIElmIGFsbCB0aGUgaW5wdXQgY2VsbCBzaXplcyBhcmUgdGhlIHNhbWUsIGFsbCB0aGUgb3B0aW9ucyB3aWxsIHlpZWxkIHRoZSBzYW1lIHJlc3VsdHMuXCIsXG5cdFwiQEBTaW5IX0NlbGxzaXplLVR5cGVfdGFnMUBAXCI6IFwiRmlyc3QgT2YtLVVzZSB0aGUgZmlyc3QgY2VsbCBzaXplIG9mIHRoZSBpbnB1dCByYXN0ZXJzLlwiLFxuXHRcIkBAU2luSF9DZWxsc2l6ZS1UeXBlX3RhZzJAQFwiOiBcIkxhc3QgT2YtLVVzZSB0aGUgbGFzdCBjZWxsIHNpemUgb2YgdGhlIGlucHV0IHJhc3RlcnMuXCIsXG5cdFwiQEBTaW5IX0NlbGxzaXplLVR5cGVfdGFnM0BAXCI6IFwiTWF4IE9mLS1Vc2UgdGhlIGxhcmdlc3QgY2VsbCBzaXplIG9mIGFsbCB0aGUgaW5wdXQgcmFzdGVycy4gVGhpcyBpcyB0aGUgZGVmYXVsdC5cIixcblx0XCJAQFNpbkhfQ2VsbHNpemUtVHlwZV90YWc0QEBcIjogXCJNZWFuIE9mLS1Vc2UgdGhlIG1lYW4gY2VsbCBzaXplIG9mIGFsbCB0aGUgaW5wdXQgcmFzdGVycy5cIixcblx0XCJAQFNpbkhfQ2VsbHNpemUtVHlwZV90YWc1QEBcIjogXCJNaW4gT2YtLVVzZSB0aGUgc21hbGxlc3QgY2VsbCBzaXplIG9mIGFsbCB0aGUgaW5wdXQgcmFzdGVycy5cIixcblx0XCJAQFNpbkhfRXh0ZW50LVR5cGVfdGFnMEBAXCI6IFwiQ2hvb3NlIHdoaWNoIGV4dGVudCBzaG91bGQgYmUgdXNlZCBpbiB0aGUgb3V0cHV0IHJhc3RlcjpcIixcblx0XCJAQFNpbkhfRXh0ZW50LVR5cGVfdGFnMUBAXCI6IFwiRmlyc3QgT2YtLVVzZSB0aGUgZXh0ZW50IG9mIHRoZSBmaXJzdCBpbnB1dCByYXN0ZXIgdG8gZGV0ZXJtaW5lIHRoZSBwcm9jZXNzaW5nIGV4dGVudC5cIixcblx0XCJAQFNpbkhfRXh0ZW50LVR5cGVfdGFnMkBAXCI6IFwiSW50ZXJzZWN0aW9uIE9mLS1Vc2UgdGhlIGV4dGVudCBvZiB0aGUgb3ZlcmxhcHBpbmcgcGl4ZWxzIHRvIGRldGVybWluZSB0aGUgcHJvY2Vzc2luZyBleHRlbnQuIFRoaXMgaXMgdGhlIGRlZmF1bHQuXCIsXG5cdFwiQEBTaW5IX0V4dGVudC1UeXBlX3RhZzNAQFwiOiBcIkxhc3QgT2YtLVVzZSB0aGUgZXh0ZW50IG9mIHRoZSBsYXN0IGlucHV0IHJhc3RlciB0byBkZXRlcm1pbmUgdGhlIHByb2Nlc3NpbmcgZXh0ZW50LlwiLFxuXHRcIkBAU2luSF9FeHRlbnQtVHlwZV90YWc0QEBcIjogXCJVbmlvbiBPZi0tVXNlIHRoZSBleHRlbnQgb2YgYWxsIHRoZSByYXN0ZXJzIHRvIGRldGVybWluZSB0aGUgcHJvY2Vzc2luZyBleHRlbnQuXCIsXG5cdFwiQEBTaW5IX1Jhc3Rlcl90YWcwQEBcIjogXCJUaGUgaW5wdXQgZm9yIHdoaWNoIHRvIGNhbGN1bGF0ZSB0aGUgaHlwZXJib2xpYyBzaW5lIHZhbHVlcy5cIixcblx0XCJAQFNpbmtfRmxvdy1EaXJlY3Rpb24tUmFzdGVyX3RhZzBAQFwiOiBcIlRoZSBpbnB1dCByYXN0ZXIgdGhhdCBzaG93cyB0aGUgZGlyZWN0aW9uIG9mIGZsb3cgb3V0IG9mIGVhY2ggY2VsbC5cIixcblx0XCJAQFNpbmtfRmxvdy1EaXJlY3Rpb24tUmFzdGVyX3RhZzFAQFwiOiBcIlRoZSBmbG93IGRpcmVjdGlvbiByYXN0ZXIgY2FuIGJlIGNyZWF0ZWQgYnkgcnVubmluZyB0aGUgPHN0cm9uZz5GbG93IERpcmVjdGlvbjwvc3Ryb25nPiBmdW5jdGlvbi5cIixcblx0XCJAQFNsb3BlX0RFTV90YWcwQEBcIjogXCJUaGUgaW5wdXQgZWxldmF0aW9uIHJhc3Rlci5cIixcblx0XCJAQFNsb3BlX0Rpc2FibGUtZGVmYXVsdC1lZGdlLXBpeGVsLWludGVycG9sYXRpb25fdGFnMEBAXCI6IFwiVXNpbmcgdGhpcyBvcHRpb24gd2lsbCBhdm9pZCBhbnkgcmVzYW1wbGluZyBhcnRpZmFjdHMgdGhhdCBtYXkgb2NjdXIgYWxvbmcgdGhlIGVkZ2VzIG9mIGEgcmFzdGVyLiBUaGUgb3V0cHV0IHBpeGVscyBhbG9uZyB0aGUgZWRnZSBvZiBhIHJhc3RlciBvciBiZXNpZGUgcGl4ZWxzIHdpdGhvdXQgYSB2YWx1ZSB3aWxsIGJlIHBvcHVsYXRlZCB3aXRoIE5vRGF0YTsgdGhlcmVmb3JlLCBpdCBpcyByZWNvbW1lbmRlZCB0aGF0IHRoaXMgb3B0aW9uIGJlIHVzZWQgb25seSB3aGVuIHRoZXJlIGFyZSBvdGhlciByYXN0ZXJzIHdpdGggb3ZlcmxhcHBpbmcgcGl4ZWxzIGF2YWlsYWJsZS4gV2hlbiBvdmVybGFwcGluZyBwaXhlbHMgYXJlIGF2YWlsYWJsZSwgdGhlc2UgYXJlYXMgb2YgTm9EYXRhIHdpbGwgZGlzcGxheSB0aGUgb3ZlcmxhcHBpbmcgcGl4ZWwgdmFsdWVzIGluc3RlYWQgb2YgYmVpbmcgYmxhbmsuXCIsXG5cdFwiQEBTbG9wZV9EaXNhYmxlLWRlZmF1bHQtZWRnZS1waXhlbC1pbnRlcnBvbGF0aW9uX3RhZzFAQFwiOiBcIlVuY2hlY2tlZC0tQmlsaW5lYXIgcmVzYW1wbGluZyB3aWxsIGJlIGFwcGxpZWQgdW5pZm9ybWx5IHRvIHJlc2FtcGxlIHlvdXIgc2xvcGUuIFRoaXMgaXMgdGhlIGRlZmF1bHQuXCIsXG5cdFwiQEBTbG9wZV9EaXNhYmxlLWRlZmF1bHQtZWRnZS1waXhlbC1pbnRlcnBvbGF0aW9uX3RhZzJAQFwiOiBcIkNoZWNrZWQtLUJpbGluZWFyIHJlc2FtcGxpbmcgd2lsbCBiZSB1c2VkIHdpdGhpbiB0aGUgc2xvcGUsIGV4Y2VwdCBhbG9uZyB0aGUgZWRnZXMgb2YgdGhlIHJhc3RlcnMgb3IgYmVzaWRlIHBpeGVscyBvZiBOb0RhdGEuIFRoZXNlIHBpeGVscyB3aWxsIGJlIHBvcHVsYXRlZCB3aXRoIE5vRGF0YSwgc2luY2UgaXQgd2lsbCByZWR1Y2UgYW55IHNoYXJwIGVkZ2UgZWZmZWN0cyB0aGF0IG1heSBvY2N1ci5cIixcblx0XCJAQFNsb3BlX1NjYWxpbmdfdGFnMEBAXCI6IFwiVGhlIGluY2xpbmF0aW9uIG9mIHNsb3BlIGNhbiBiZSBvdXRwdXQgYXMgZWl0aGVyIGEgdmFsdWUgaW4gZGVncmVlcywgb3IgcGVyY2VudCByaXNlLiBUaGVyZSBhcmUgdGhyZWUgb3B0aW9ucyBmb3IgdGhlIDxzdHJvbmc+U2NhbGluZzwvc3Ryb25nPjpcIixcblx0XCJAQFNsb3BlX1NjYWxpbmdfdGFnM0BAXCI6IFwiPHN0cm9uZz5EZWdyZWU8L3N0cm9uZz4tLVRoZSBpbmNsaW5hdGlvbiBvZiBzbG9wZSBpcyBjYWxjdWxhdGVkIGluIGRlZ3JlZXMuIFRoZSB2YWx1ZXMgcmFuZ2UgZnJvbSAwIHRvIDkwLlwiLFxuXHRcIkBAU2xvcGVfU2NhbGluZ190YWc1QEBcIjogXCI8c3Ryb25nPlBlcmNlbnRfUmlzZTwvc3Ryb25nPi0tVGhlIGluY2xpbmF0aW9uIG9mIHNsb3BlIGlzIGNhbGN1bGF0ZWQgYXMgcGVyY2VudGFnZSB2YWx1ZXMuIFRoZSB2YWx1ZXMgcmFuZ2UgZnJvbSAwIHRvIGluZmluaXR5LiBBIGZsYXQgc3VyZmFjZSBpcyAwIHBlcmNlbnQgcmlzZSwgd2hlcmVhcyBhIDQ1LWRlZ3JlZSBzdXJmYWNlIGlzIDEwMCBwZXJjZW50IHJpc2UuIEFzIHRoZSBzdXJmYWNlIGJlY29tZXMgbW9yZSB2ZXJ0aWNhbCwgdGhlIHBlcmNlbnQgcmlzZSBiZWNvbWVzIGluY3JlYXNpbmdseSBsYXJnZXIuXCIsXG5cdFwiQEBTbG9wZV9TY2FsaW5nX3RhZzdAQFwiOiBcIjxzdHJvbmc+U2NhbGVkPC9zdHJvbmc+LS1UaGUgaW5jbGluYXRpb24gb2Ygc2xvcGUgaXMgY2FsY3VsYXRlZCB0aGUgc2FtZSBhcyBERUdSRUUsIGJ1dCB0aGUgei1mYWN0b3IgaXMgYWRqdXN0ZWQgZm9yIHNjYWxlLiBJdCB1c2VzIHRoZSA8c3Ryb25nPlBpeGVsIFNpemUgUG93ZXI8L3N0cm9uZz4gYW5kIDxzdHJvbmc+UGl4ZWwgU2l6ZSBGYWN0b3I8L3N0cm9uZz4gdmFsdWVzLCB3aGljaCBhY2NvdW50IGZvciB0aGUgcmVzb2x1dGlvbiBjaGFuZ2VzIChzY2FsZSkgYXMgdGhlIHZpZXdlciB6b29tcyBpbiBhbmQgb3V0LiBUaGlzIGlzIHJlY29tbWVuZGVkIHdoZW4gdXNpbmcgd29ybGR3aWRlIGRhdGFzZXRzLS1wYXJ0aWN1bGFybHkgd2hlbiB1c2luZyBzbG9wZSBhcyBhIHN1cmZhY2UgZm9yIHZpc3VhbGl6YXRpb24uXCIsXG5cdFwiQEBTbG9wZV9TY2FsaW5nX3RhZzEzQEBcIjogXCJUaGUgei1mYWN0b3IgaXMgYWRqdXN0ZWQgdXNpbmcgdGhlIGZvbGxvd2luZyBlcXVhdGlvbjpcIixcblx0XCJAQFNsb3BlX1NjYWxpbmdfdGFnMTRAQFwiOiBcIkFkanVzdGVkIFogRmFjdG9yID0gKFogRmFjdG9yKSArIChQaXhlbCBTaXplKVwiLFxuXHRcIkBAU2xvcGVfU2NhbGluZ190YWcxNUBAXCI6IFwiw5cgKFBpeGVsIFNpemUgRmFjdG9yKVwiLFxuXHRcIkBAU2xvcGVfU2NhbGluZ190YWcxNkBAXCI6IFwiUGl4ZWwgU2l6ZSBQb3dlclwiLFxuXHRcIkBAU2xvcGVfWi1GYWN0b3JfdGFnMEBAXCI6IFwiVGhlIDxzdHJvbmc+WiBGYWN0b3I8L3N0cm9uZz4gaXMgYSBzY2FsaW5nIGZhY3RvciB1c2VkIHRvIGNvbnZlcnQgdGhlIGVsZXZhdGlvbiB2YWx1ZXMgZm9yIHR3byBwdXJwb3NlczpcIixcblx0XCJAQFNsb3BlX1otRmFjdG9yX3RhZzNAQFwiOiBcIlRvIGNvbnZlcnQgdGhlIGVsZXZhdGlvbiB1bml0cyAoc3VjaCBhcyBtZXRlcnMgb3IgZmVldCkgdG8gdGhlIGhvcml6b250YWwgY29vcmRpbmF0ZSB1bml0cyBvZiB0aGUgZGF0YXNldCwgd2hpY2ggbWF5IGJlIGZlZXQsIG1ldGVycywgb3IgZGVncmVlc1wiLFxuXHRcIkBAU2xvcGVfWi1GYWN0b3JfdGFnNEBAXCI6IFwiVG8gYWRkIHZlcnRpY2FsIGV4YWdnZXJhdGlvbiBmb3IgdmlzdWFsIGVmZmVjdFwiLFxuXHRcIkBAU2xvcGVfUFNQb3dlcl90YWcwQEBcIjogXCI8c3Ryb25nPlBpeGVsIFNpemUgUG93ZXI8L3N0cm9uZz4gYWNjb3VudHMgZm9yIHRoZSBhbHRpdHVkZSBjaGFuZ2VzIChvciBzY2FsZSkgYXMgdGhlIHZpZXdlciB6b29tcyBpbiBhbmQgb3V0IG9uIHRoZSBtYXAgZGlzcGxheS4gSXQgaXMgdGhlIGV4cG9uZW50IGFwcGxpZWQgdG8gdGhlIHBpeGVsIHNpemUgdGVybSBpbiB0aGUgZXF1YXRpb24gdGhhdCBjb250cm9scyB0aGUgcmF0ZSBhdCB3aGljaCB0aGUgPHN0cm9uZz5aIEZhY3Rvcjwvc3Ryb25nPiBjaGFuZ2VzIHRvIGF2b2lkIHNpZ25pZmljYW50IGxvc3Mgb2YgcmVsaWVmLlwiLFxuXHRcIkBAU2xvcGVfUFNQb3dlcl90YWcxQEBcIjogXCJUaGlzIHBhcmFtZXRlciBpcyBvbmx5IHZhbGlkIHdoZW4gdGhlIDxzdHJvbmc+U2NhbGluZzwvc3Ryb25nPiB0eXBlIGlzIDxzdHJvbmc+U2NhbGVkPC9zdHJvbmc+LiBUaGUgZGVmYXVsdCB2YWx1ZSBpcyAwLjY2NC5cIixcblx0XCJAQFNsb3BlX1BTWkZhY3Rvcl90YWcwQEBcIjogXCI8c3Ryb25nPlBpeGVsIFNpemUgRmFjdG9yPC9zdHJvbmc+IGFjY291bnRzIGZvciBjaGFuZ2VzIGluIHNjYWxlIGFzIHRoZSB2aWV3ZXIgem9vbXMgaW4gYW5kIG91dCBvbiB0aGUgbWFwIGRpc3BsYXkuIEl0IGNvbnRyb2xzIHRoZSByYXRlIGF0IHdoaWNoIHRoZSA8c3Ryb25nPlogRmFjdG9yPC9zdHJvbmc+IGNoYW5nZXMuXCIsXG5cdFwiQEBTbG9wZV9QU1pGYWN0b3JfdGFnMUBAXCI6IFwiVGhpcyBwYXJhbWV0ZXIgaXMgb25seSB2YWxpZCB3aGVuIHRoZSA8c3Ryb25nPlNjYWxpbmc8L3N0cm9uZz4gdHlwZSBpcyA8c3Ryb25nPlNjYWxlZDwvc3Ryb25nPi4gVGhlIGRlZmF1bHQgdmFsdWUgaXMgMC4wMjQuXCIsXG5cdFwiQEBTbmFwLVBvdXItUG9pbnRfRmxvdy1BY2N1bXVsYXRpb24tUmFzdGVyX3RhZzBAQFwiOiBcIlRoZSBpbnB1dCBmbG93IGFjY3VtdWxhdGlvbiByYXN0ZXIgbGF5ZXIuXCIsXG5cdFwiQEBTbmFwLVBvdXItUG9pbnRfRmxvdy1BY2N1bXVsYXRpb24tUmFzdGVyX3RhZzFAQFwiOiBcIlRoaXMgY2FuIGJlIGNyZWF0ZWQgd2l0aCB0aGUgPHN0cm9uZz5GbG93IEFjY3VtdWxhdGlvbjwvc3Ryb25nPiBmdW5jdGlvbi5cIixcblx0XCJAQFNuYXAtUG91ci1Qb2ludF9Qb3VyLVBvaW50LUZpZWxkX3RhZzBAQFwiOiBcIkZpZWxkIHVzZWQgdG8gYXNzaWduIHZhbHVlcyB0byB0aGUgcG91ciBwb2ludCBsb2NhdGlvbnMuXCIsXG5cdFwiQEBTbmFwLVBvdXItUG9pbnRfUG91ci1Qb2ludC1SYXN0ZXJfdGFnMEBAXCI6IFwiVGhlIGlucHV0IHBvdXIgcG9pbnQgbG9jYXRpb25zIHRoYXQgYXJlIHRvIGJlIHNuYXBwZWQuXCIsXG5cdFwiQEBTbmFwLVBvdXItUG9pbnRfUG91ci1Qb2ludC1SYXN0ZXJfdGFnMUBAXCI6IFwiRm9yIGFuIGlucHV0IHJhc3RlciBsYXllciwgYWxsIGNlbGxzIHRoYXQgYXJlIG5vdCBOb0RhdGEgKHRoYXQgaXMsIGhhdmUgYSB2YWx1ZSkgd2lsbCBiZSBjb25zaWRlcmVkIHBvdXIgcG9pbnRzIGFuZCB3aWxsIGJlIHNuYXBwZWQuXCIsXG5cdFwiQEBTbmFwLVBvdXItUG9pbnRfU25hcC1EaXN0YW5jZV90YWcwQEBcIjogXCJUaGUgbWF4aW11bSBkaXN0YW5jZSwgaW4gbWFwIHVuaXRzLCB0byBzZWFyY2ggZm9yIGEgY2VsbCBvZiBoaWdoZXIgYWNjdW11bGF0ZWQgZmxvdy5cIixcblx0XCJAQFNwZWNrbGVfQWRkaXRpdmUtTm9pc2UtTWVhbl90YWcwQEBcIjogXCJTcGVjaWZpZXMgdGhlIG1lYW4gdmFsdWUgb2YgYWRkaXRpdmUgbm9pc2UuIEEgbGFyZ2VyIG5vaXNlIG1lYW4gdmFsdWUgd2lsbCBwcm9kdWNlIGxlc3Mgc21vb3RoaW5nLCB3aGlsZSBhIHNtYWxsZXIgdmFsdWUgcmVzdWx0cyBpbiBtb3JlIHNtb290aGluZy5cIixcblx0XCJAQFNwZWNrbGVfQWRkaXRpdmUtTm9pc2UtTWVhbl90YWcxQEBcIjogXCJUaGlzIHBhcmFtZXRlciBpcyBvbmx5IHZhbGlkIHdoZW4gdGhlIDxzdHJvbmc+RmlsdGVyIFR5cGU8L3N0cm9uZz4gaXMgPHN0cm9uZz5MZWUgRmlsdGVyPC9zdHJvbmc+IGFuZCB0aGUgPHN0cm9uZz5Ob2lzZSBNb2RlbDwvc3Ryb25nPiBpcyA8c3Ryb25nPkFkZGl0aXZlIE5vaXNlPC9zdHJvbmc+IG9yIDxzdHJvbmc+QWRkaXRpdmUgYW5kIE11bHRpcGxpY2F0aXZlIE5vaXNlPC9zdHJvbmc+LiBUaGUgZGVmYXVsdCB2YWx1ZSBpcyAwLlwiLFxuXHRcIkBAU3BlY2tsZV9EYW1waW5nLUZhY3Rvcl90YWcwQEBcIjogXCJTcGVjaWZpZXMgdGhlIGV4dGVudCBvZiBleHBvbmVudGlhbCBkYW1waW5nIGVmZmVjdCBvbiBmaWx0ZXJpbmcuIEEgbGFyZ2VyIGRhbXBpbmcgdmFsdWUgcHJlc2VydmVzIGVkZ2VzIGJldHRlciBidXQgc21vb3RocyBsZXNzLCB3aGlsZSBhIHNtYWxsZXIgdmFsdWUgcHJvZHVjZXMgbW9yZSBzbW9vdGhpbmcuIEEgdmFsdWUgb2YgMCByZXN1bHRzIGluIHRoZSBzYW1lIG91dHB1dCBhcyBhIGxvdy1wYXNzIGZpbHRlci5cIixcblx0XCJAQFNwZWNrbGVfRGFtcGluZy1GYWN0b3JfdGFnMUBAXCI6IFwiVGhpcyBwYXJhbWV0ZXIgaXMgb25seSB2YWxpZCB3aGVuIHRoZSA8c3Ryb25nPkZpbHRlciBUeXBlPC9zdHJvbmc+IGlzIDxzdHJvbmc+RW5oYW5jZWQgTGVlIEZpbHRlcjwvc3Ryb25nPiBvciA8c3Ryb25nPkZyb3N0IEZpbHRlcjwvc3Ryb25nPi4gVGhlIGRlZmF1bHQgdmFsdWUgaXMgMS5cIixcblx0XCJAQFNwZWNrbGVfRmlsdGVyLVNpemVfdGFnMEBAXCI6IFwiU3BlY2lmaWVzIHRoZSBzaXplIG9mIHRoZSBwaXhlbCB3aW5kb3cgdXNlZCB0byBmaWx0ZXIgbm9pc2U6XCIsXG5cdFwiQEBTcGVja2xlX0ZpbHRlci1TaXplX3RhZzFAQFwiOiBcIjN4M1wiLFxuXHRcIkBAU3BlY2tsZV9GaWx0ZXItU2l6ZV90YWcyQEBcIjogXCI1eDVcIixcblx0XCJAQFNwZWNrbGVfRmlsdGVyLVNpemVfdGFnM0BAXCI6IFwiN3g3XCIsXG5cdFwiQEBTcGVja2xlX0ZpbHRlci1TaXplX3RhZzRAQFwiOiBcIjl4OVwiLFxuXHRcIkBAU3BlY2tsZV9GaWx0ZXItU2l6ZV90YWc1QEBcIjogXCIxMXgxMVwiLFxuXHRcIkBAU3BlY2tsZV9GaWx0ZXItVHlwZV90YWcwQEBcIjogXCJTcGVjaWZpZXMgdGhlIGZpbHRlciB0eXBlIHRvIGJlIHVzZWQgaW4gdGhlIHNtb290aGluZyBhbGdvcml0aG0gdG8gcmVtb3ZlIHNwZWNrbGUgbm9pc2U6XCIsXG5cdFwiQEBTcGVja2xlX0ZpbHRlci1UeXBlX3RhZzFAQFwiOiBcIjxzdHJvbmc+TGVlIEZpbHRlcjwvc3Ryb25nPi0tUmVkdWNlcyB0aGUgc3BlY2tsZSBub2lzZSBieSBhcHBseWluZyBhIHNwYXRpYWwgZmlsdGVyIHRvIGVhY2ggcGl4ZWwgaW4gYW4gaW1hZ2UsIHdoaWNoIGZpbHRlcnMgdGhlIGRhdGEgYmFzZWQgb24gbG9jYWwgc3RhdGlzdGljcyBjYWxjdWxhdGVkIHdpdGhpbiBhIHNxdWFyZSB3aW5kb3cuIFRoaXMgZmlsdGVyIGlzIHVzZWZ1bCB3aGVuIHlvdSB3YW50IHRvIHNtb290aCBzcGVja2xlZCBkYXRhIHRoYXQgaGFzIGFuIGFkZGl0aXZlIG9yIG11bHRpcGxpY2F0aXZlIGNvbXBvbmVudC4gVGhpcyBpcyB0aGUgZGVmYXVsdC5cIixcblx0XCJAQFNwZWNrbGVfRmlsdGVyLVR5cGVfdGFnM0BAXCI6IFwiPHN0cm9uZz5FbmhhbmNlZCBMZWUgRmlsdGVyPC9zdHJvbmc+LS1BbiBhZGFwdGVkIHZlcnNpb24gb2YgdGhlIExlZSBmaWx0ZXIgdGhhdCBpbmNsdWRlcyA8c3Ryb25nPkRhbXBpbmcgRmFjdG9yPC9zdHJvbmc+IGFuZCA8c3Ryb25nPk51bWJlciBvZiBMb29rczwvc3Ryb25nPi4gVGhpcyBmaWx0ZXIgaXMgdXNlZnVsIHdoZW4geW91IHdhbnQgdG8gcmVkdWNlIHNwZWNrbGUgd2hpbGUgcHJlc2VydmluZyB0ZXh0dXJlIGluZm9ybWF0aW9uLlwiLFxuXHRcIkBAU3BlY2tsZV9GaWx0ZXItVHlwZV90YWc5QEBcIjogXCI8c3Ryb25nPkZyb3N0IEZpbHRlcjwvc3Ryb25nPi0tUmVkdWNlcyBzcGVja2xlIG5vaXNlIHdpdGggYW4gZXhwb25lbnRpYWxseSBkYW1wZWQgY2lyY3VsYXJseSBzeW1tZXRyaWMgZmlsdGVyIHRoYXQgdXNlcyBsb2NhbCBzdGF0aXN0aWNzIHdpdGhpbiBpbmRpdmlkdWFsIGZpbHRlciB3aW5kb3dzLiBUaGlzIGZpbHRlciBpcyB1c2VmdWwgd2hlbiB5b3Ugd2FudCB0byByZWR1Y2Ugc3BlY2tsZSB3aGlsZSBwcmVzZXJ2aW5nIGVkZ2VzIGluIHJhZGFyIGltYWdlcy5cIixcblx0XCJAQFNwZWNrbGVfRmlsdGVyLVR5cGVfdGFnMTFAQFwiOiBcIjxzdHJvbmc+S3VhbiBGaWx0ZXI8L3N0cm9uZz4tLVNpbWlsYXIgdG8gdGhlIExlZSBmaWx0ZXIsIHRoaXMgZmlsdGVyIGFwcGxpZXMgYSBzcGF0aWFsIGZpbHRlciB0byBlYWNoIHBpeGVsIGluIGFuIGltYWdlIGFuZCBmaWx0ZXJzIHRoZSBkYXRhIGJhc2VkIG9uIGxvY2FsIHN0YXRpc3RpY3MgY2FsY3VsYXRlZCB3aXRoaW4gYSBzcXVhcmUgd2luZG93LiBUaGlzIGZpbHRlciBpcyB1c2VmdWwgd2hlbiB5b3Ugd2FudCB0byByZWR1Y2Ugc3BlY2tsZSB3aGlsZSBwcmVzZXJ2aW5nIGVkZ2VzIGluIHJhZGFyIGltYWdlcy5cIixcblx0XCJAQFNwZWNrbGVfTXVsdGlwbGljYXRpdmUtTm9pc2UtTWVhbl90YWcwQEBcIjogXCJTcGVjaWZpZXMgdGhlIG1lYW4gdmFsdWUgb2YgbXVsdGlwbGljYXRpdmUgbm9pc2UuIEEgbGFyZ2VyIG5vaXNlIG1lYW4gdmFsdWUgd2lsbCBwcm9kdWNlIGxlc3Mgc21vb3RoaW5nLCB3aGlsZSBhIHNtYWxsZXIgdmFsdWUgcmVzdWx0cyBpbiBtb3JlIHNtb290aGluZy5cIixcblx0XCJAQFNwZWNrbGVfTXVsdGlwbGljYXRpdmUtTm9pc2UtTWVhbl90YWcxQEBcIjogXCJUaGlzIHBhcmFtZXRlciBpcyBvbmx5IHZhbGlkIHdoZW4gdGhlIDxzdHJvbmc+RmlsdGVyIFR5cGU8L3N0cm9uZz4gaXMgPHN0cm9uZz5MZWUgRmlsdGVyPC9zdHJvbmc+IGFuZCB0aGUgPHN0cm9uZz5Ob2lzZSBNb2RlbDwvc3Ryb25nPiBpcyA8c3Ryb25nPkFkZGl0aXZlIE5vaXNlPC9zdHJvbmc+IG9yIDxzdHJvbmc+QWRkaXRpdmUgYW5kIE11bHRpcGxpY2F0aXZlIE5vaXNlPC9zdHJvbmc+LiBUaGUgZGVmYXVsdCB2YWx1ZSBpcyAxLlwiLFxuXHRcIkBAU3BlY2tsZV9Ob2lzZS1Nb2RlbF90YWcwQEBcIjogXCJTcGVjaWZpZXMgdGhlIHR5cGUgb2Ygbm9pc2UgdGhhdCBpcyByZWR1Y2luZyB0aGUgcXVhbGl0eSBvZiB0aGUgcmFkYXIgaW1hZ2U6XCIsXG5cdFwiQEBTcGVja2xlX05vaXNlLU1vZGVsX3RhZzFAQFwiOiBcIjxzdHJvbmc+TXVsdGlwbGljYXRpdmUgTm9pc2U8L3N0cm9uZz4tLVJhbmRvbSBzaWduYWwgbm9pc2UgdGhhdCBpcyBtdWx0aXBsaWVkIGludG8gdGhlIHJlbGV2YW50IHNpZ25hbCBkdXJpbmcgY2FwdHVyZSBvciB0cmFuc21pc3Npb25cIixcblx0XCJAQFNwZWNrbGVfTm9pc2UtTW9kZWxfdGFnM0BAXCI6IFwiPHN0cm9uZz5BZGRpdGl2ZSBOb2lzZTwvc3Ryb25nPi0tUmFuZG9tIHNpZ25hbCBub2lzZSB0aGF0IGlzIGFkZGVkIGludG8gdGhlIHJlbGV2YW50IHNpZ25hbCBkdXJpbmcgY2FwdHVyZSBvciB0cmFuc21pc3Npb25cIixcblx0XCJAQFNwZWNrbGVfTm9pc2UtTW9kZWxfdGFnNUBAXCI6IFwiPHN0cm9uZz5BZGRpdGl2ZSBhbmQgTXVsdGlwbGljYXRpdmUgTm9pc2U8L3N0cm9uZz4tLUJvdGggbm9pc2UgbW9kZWxzXCIsXG5cdFwiQEBTcGVja2xlX05vaXNlLVZhcmlhbmNlX3RhZzBAQFwiOiBcIlNwZWNpZmllcyB0aGUgbm9pc2UgdmFyaWFuY2Ugb2YgdGhlIHJhZGFyIGltYWdlLlwiLFxuXHRcIkBAU3BlY2tsZV9Ob2lzZS1WYXJpYW5jZV90YWcxQEBcIjogXCJUaGlzIHBhcmFtZXRlciBpcyBvbmx5IHZhbGlkIHdoZW4gdGhlIDxzdHJvbmc+RmlsdGVyIFR5cGU8L3N0cm9uZz4gaXMgPHN0cm9uZz5MZWUgRmlsdGVyPC9zdHJvbmc+IGFuZCB0aGUgPHN0cm9uZz5Ob2lzZSBNb2RlbDwvc3Ryb25nPiBpcyA8c3Ryb25nPkFkZGl0aXZlIE5vaXNlPC9zdHJvbmc+IG9yIDxzdHJvbmc+QWRkaXRpdmUgYW5kIE11bHRpcGxpY2F0aXZlIE5vaXNlPC9zdHJvbmc+LiBUaGUgZGVmYXVsdCB2YWx1ZSBpcyAwLjI1LlwiLFxuXHRcIkBAU3BlY2tsZV9OdW1iZXItb2YtTG9va3NfdGFnMEBAXCI6IFwiU3BlY2lmaWVzIHRoZSBudW1iZXIgb2YgbG9va3Mgb2YgdGhlIGltYWdlLCB3aGljaCBjb250cm9scyBpbWFnZSBzbW9vdGhpbmcgYW5kIGVzdGltYXRlcyBub2lzZSB2YXJpYW5jZS4gQSBzbWFsbGVyIHZhbHVlIHJlc3VsdHMgaW4gbW9yZSBzbW9vdGhpbmcsIHdoaWxlIGEgbGFyZ2VyIHZhbHVlIHJldGFpbnMgbW9yZSBpbWFnZSBmZWF0dXJlcy5cIixcblx0XCJAQFNwZWNrbGVfTnVtYmVyLW9mLUxvb2tzX3RhZzFAQFwiOiBcIlRoaXMgcGFyYW1ldGVyIGlzIG9ubHkgdmFsaWQgd2hlbiB0aGUgPHN0cm9uZz5GaWx0ZXIgVHlwZTwvc3Ryb25nPiBpcyA8c3Ryb25nPkxlZSBGaWx0ZXI8L3N0cm9uZz4gYW5kIHRoZSA8c3Ryb25nPk5vaXNlIE1vZGVsPC9zdHJvbmc+IGlzIDxzdHJvbmc+TXVsdGlwbGljYXRpdmUgTm9pc2U8L3N0cm9uZz4gLCBvciB3aGVuIHRoZSA8c3Ryb25nPkZpbHRlciBUeXBlPC9zdHJvbmc+IGlzIDxzdHJvbmc+S3VhbiBGaWx0ZXI8L3N0cm9uZz4uIFRoZSBkZWZhdWx0IHZhbHVlIGlzIDEuXCIsXG5cdFwiQEBTcGVja2xlX1Jhc3Rlcl90YWcwQEBcIjogXCJUaGUgaW5wdXQgcmFzdGVyLlwiLFxuXHRcIkBAU3BlY3RyYWwtQ29udmVyc2lvbl9Db252ZXJzaW9uLU1hdHJpeF90YWcwQEBcIjogXCJUaGUgbWF0cml4IHVzZWQgdG8gY29udmVydCB0aGUgaW5wdXQgcmFzdGVyLlwiLFxuXHRcIkBAU3BlY3RyYWwtQ29udmVyc2lvbl9Db252ZXJzaW9uLU1hdHJpeF90YWcxQEBcIjogXCJUaGUgZXF1YXRpb24gdXNlZCB0byBwZXJmb3JtIHRoaXMgY29udmVyc2lvbiBpczpcIixcblx0XCJAQFNwZWN0cmFsLUNvbnZlcnNpb25fQ29udmVyc2lvbi1NYXRyaXhfdGFnMkBAXCI6IFwiT3V0cHV0IEJhbmRfUiA9IFdlaWdodF9QICogQmFuZF9DXCIsXG5cdFwiQEBTcGVjdHJhbC1Db252ZXJzaW9uX0NvbnZlcnNpb24tTWF0cml4X3RhZzNAQFwiOiBcIndoZXJlOlwiLFxuXHRcIkBAU3BlY3RyYWwtQ29udmVyc2lvbl9Db252ZXJzaW9uLU1hdHJpeF90YWc0QEBcIjogXCJCYW5kX1IgaXMgYW4gb3V0cHV0IGJhbmQsIHdoZXJlIFIgaXMgYSBudW1iZXIgZnJvbSAxIHRvIHRoZSBudW1iZXIgb2Ygb3V0cHV0IGJhbmRzLlwiLFxuXHRcIkBAU3BlY3RyYWwtQ29udmVyc2lvbl9Db252ZXJzaW9uLU1hdHJpeF90YWc1QEBcIjogXCJXZWlnaHRfUCBpcyBhIGNvbW1hLWRlbGltaXRlZCBsaXN0IG9mIHdlaWdodHMsIDEgZm9yIGVhY2ggaW5wdXQgYmFuZC4gVGhlIHN1bSBvZiB0aGUgd2VpZ2h0cyBmb3IgZWFjaCBiYW5kIHNob3VsZCBlcXVhbCAxLlwiLFxuXHRcIkBAU3BlY3RyYWwtQ29udmVyc2lvbl9Db252ZXJzaW9uLU1hdHJpeF90YWc2QEBcIjogXCJCYW5kX0MgaXMgdGhlIGlucHV0IGltYWdlLCB3aGVyZSBDIGlzIGEgbnVtYmVyIGZyb20gMSB0byB0aGUgbnVtYmVyIG9mIGJhbmRzIG9mIHRoZSBpbnB1dCBpbWFnZS5cIixcblx0XCJAQFNwZWN0cmFsLUNvbnZlcnNpb25fUmFzdGVyX3RhZzBAQFwiOiBcIlRoZSBpbnB1dCByYXN0ZXIuXCIsXG5cdFwiQEBTcGVjdHJhbC1Db252ZXJzaW9uX1Jhc3Rlcl90YWcxQEBcIjogXCJUaGlzIGNhbiBiZSBhIHJhc3RlciBkYXRhc2V0LCBhIG1vc2FpYyBkYXRhc2V0IG9yIGFuIGltYWdlIHNlcnZpY2UuXCIsXG5cdFwiQEBTcGVjdHJhbC1Db252ZXJzaW9uX1NpemVfdGFnMEBAXCI6IFwiVGhlIG51bWJlciBvZiByb3dzIGFuZCBjb2x1bW5zIGluIHRoZSA8c3Ryb25nPkNvbnZlcnNpb24gTWF0cml4PC9zdHJvbmc+LlwiLFxuXHRcIkBAU3F1YXJlX0NlbGxzaXplLVR5cGVfdGFnMEBAXCI6IFwiQ2hvb3NlIHdoaWNoIGNlbGwgc2l6ZSB0byB1c2UgaW4gdGhlIG91dHB1dCByYXN0ZXIuIElmIGFsbCB0aGUgaW5wdXQgY2VsbCBzaXplcyBhcmUgdGhlIHNhbWUsIGFsbCB0aGUgb3B0aW9ucyB3aWxsIHlpZWxkIHRoZSBzYW1lIHJlc3VsdHMuXCIsXG5cdFwiQEBTcXVhcmVfQ2VsbHNpemUtVHlwZV90YWcxQEBcIjogXCJGaXJzdCBPZi0tVXNlIHRoZSBmaXJzdCBjZWxsIHNpemUgb2YgdGhlIGlucHV0IHJhc3RlcnMuXCIsXG5cdFwiQEBTcXVhcmVfQ2VsbHNpemUtVHlwZV90YWcyQEBcIjogXCJMYXN0IE9mLS1Vc2UgdGhlIGxhc3QgY2VsbCBzaXplIG9mIHRoZSBpbnB1dCByYXN0ZXJzLlwiLFxuXHRcIkBAU3F1YXJlX0NlbGxzaXplLVR5cGVfdGFnM0BAXCI6IFwiTWF4IE9mLS1Vc2UgdGhlIGxhcmdlc3QgY2VsbCBzaXplIG9mIGFsbCB0aGUgaW5wdXQgcmFzdGVycy4gVGhpcyBpcyB0aGUgZGVmYXVsdC5cIixcblx0XCJAQFNxdWFyZV9DZWxsc2l6ZS1UeXBlX3RhZzRAQFwiOiBcIk1lYW4gT2YtLVVzZSB0aGUgbWVhbiBjZWxsIHNpemUgb2YgYWxsIHRoZSBpbnB1dCByYXN0ZXJzLlwiLFxuXHRcIkBAU3F1YXJlX0NlbGxzaXplLVR5cGVfdGFnNUBAXCI6IFwiTWluIE9mLS1Vc2UgdGhlIHNtYWxsZXN0IGNlbGwgc2l6ZSBvZiBhbGwgdGhlIGlucHV0IHJhc3RlcnMuXCIsXG5cdFwiQEBTcXVhcmVfRXh0ZW50LVR5cGVfdGFnMEBAXCI6IFwiQ2hvb3NlIHdoaWNoIGV4dGVudCBzaG91bGQgYmUgdXNlZCBpbiB0aGUgb3V0cHV0IHJhc3RlcjpcIixcblx0XCJAQFNxdWFyZV9FeHRlbnQtVHlwZV90YWcxQEBcIjogXCJGaXJzdCBPZi0tVXNlIHRoZSBleHRlbnQgb2YgdGhlIGZpcnN0IGlucHV0IHJhc3RlciB0byBkZXRlcm1pbmUgdGhlIHByb2Nlc3NpbmcgZXh0ZW50LlwiLFxuXHRcIkBAU3F1YXJlX0V4dGVudC1UeXBlX3RhZzJAQFwiOiBcIkludGVyc2VjdGlvbiBPZi0tVXNlIHRoZSBleHRlbnQgb2YgdGhlIG92ZXJsYXBwaW5nIHBpeGVscyB0byBkZXRlcm1pbmUgdGhlIHByb2Nlc3NpbmcgZXh0ZW50LiBUaGlzIGlzIHRoZSBkZWZhdWx0LlwiLFxuXHRcIkBAU3F1YXJlX0V4dGVudC1UeXBlX3RhZzNAQFwiOiBcIkxhc3QgT2YtLVVzZSB0aGUgZXh0ZW50IG9mIHRoZSBsYXN0IGlucHV0IHJhc3RlciB0byBkZXRlcm1pbmUgdGhlIHByb2Nlc3NpbmcgZXh0ZW50LlwiLFxuXHRcIkBAU3F1YXJlX0V4dGVudC1UeXBlX3RhZzRAQFwiOiBcIlVuaW9uIE9mLS1Vc2UgdGhlIGV4dGVudCBvZiBhbGwgdGhlIHJhc3RlcnMgdG8gZGV0ZXJtaW5lIHRoZSBwcm9jZXNzaW5nIGV4dGVudC5cIixcblx0XCJAQFNxdWFyZV9SYXN0ZXJfdGFnMEBAXCI6IFwiVGhlIGlucHV0IHZhbHVlcyB0byBiZSBzcXVhcmVkLlwiLFxuXHRcIkBAU3F1YXJlLVJvb3RfQ2VsbHNpemUtVHlwZV90YWcwQEBcIjogXCJDaG9vc2Ugd2hpY2ggY2VsbCBzaXplIHRvIHVzZSBpbiB0aGUgb3V0cHV0IHJhc3Rlci4gSWYgYWxsIHRoZSBpbnB1dCBjZWxsIHNpemVzIGFyZSB0aGUgc2FtZSwgYWxsIHRoZSBvcHRpb25zIHdpbGwgeWllbGQgdGhlIHNhbWUgcmVzdWx0cy5cIixcblx0XCJAQFNxdWFyZS1Sb290X0NlbGxzaXplLVR5cGVfdGFnMUBAXCI6IFwiRmlyc3QgT2YtLVVzZSB0aGUgZmlyc3QgY2VsbCBzaXplIG9mIHRoZSBpbnB1dCByYXN0ZXJzLlwiLFxuXHRcIkBAU3F1YXJlLVJvb3RfQ2VsbHNpemUtVHlwZV90YWcyQEBcIjogXCJMYXN0IE9mLS1Vc2UgdGhlIGxhc3QgY2VsbCBzaXplIG9mIHRoZSBpbnB1dCByYXN0ZXJzLlwiLFxuXHRcIkBAU3F1YXJlLVJvb3RfQ2VsbHNpemUtVHlwZV90YWczQEBcIjogXCJNYXggT2YtLVVzZSB0aGUgbGFyZ2VzdCBjZWxsIHNpemUgb2YgYWxsIHRoZSBpbnB1dCByYXN0ZXJzLiBUaGlzIGlzIHRoZSBkZWZhdWx0LlwiLFxuXHRcIkBAU3F1YXJlLVJvb3RfQ2VsbHNpemUtVHlwZV90YWc0QEBcIjogXCJNZWFuIE9mLS1Vc2UgdGhlIG1lYW4gY2VsbCBzaXplIG9mIGFsbCB0aGUgaW5wdXQgcmFzdGVycy5cIixcblx0XCJAQFNxdWFyZS1Sb290X0NlbGxzaXplLVR5cGVfdGFnNUBAXCI6IFwiTWluIE9mLS1Vc2UgdGhlIHNtYWxsZXN0IGNlbGwgc2l6ZSBvZiBhbGwgdGhlIGlucHV0IHJhc3RlcnMuXCIsXG5cdFwiQEBTcXVhcmUtUm9vdF9FeHRlbnQtVHlwZV90YWcwQEBcIjogXCJDaG9vc2Ugd2hpY2ggZXh0ZW50IHNob3VsZCBiZSB1c2VkIGluIHRoZSBvdXRwdXQgcmFzdGVyOlwiLFxuXHRcIkBAU3F1YXJlLVJvb3RfRXh0ZW50LVR5cGVfdGFnMUBAXCI6IFwiRmlyc3QgT2YtLVVzZSB0aGUgZXh0ZW50IG9mIHRoZSBmaXJzdCBpbnB1dCByYXN0ZXIgdG8gZGV0ZXJtaW5lIHRoZSBwcm9jZXNzaW5nIGV4dGVudC5cIixcblx0XCJAQFNxdWFyZS1Sb290X0V4dGVudC1UeXBlX3RhZzJAQFwiOiBcIkludGVyc2VjdGlvbiBPZi0tVXNlIHRoZSBleHRlbnQgb2YgdGhlIG92ZXJsYXBwaW5nIHBpeGVscyB0byBkZXRlcm1pbmUgdGhlIHByb2Nlc3NpbmcgZXh0ZW50LiBUaGlzIGlzIHRoZSBkZWZhdWx0LlwiLFxuXHRcIkBAU3F1YXJlLVJvb3RfRXh0ZW50LVR5cGVfdGFnM0BAXCI6IFwiTGFzdCBPZi0tVXNlIHRoZSBleHRlbnQgb2YgdGhlIGxhc3QgaW5wdXQgcmFzdGVyIHRvIGRldGVybWluZSB0aGUgcHJvY2Vzc2luZyBleHRlbnQuXCIsXG5cdFwiQEBTcXVhcmUtUm9vdF9FeHRlbnQtVHlwZV90YWc0QEBcIjogXCJVbmlvbiBPZi0tVXNlIHRoZSBleHRlbnQgb2YgYWxsIHRoZSByYXN0ZXJzIHRvIGRldGVybWluZSB0aGUgcHJvY2Vzc2luZyBleHRlbnQuXCIsXG5cdFwiQEBTcXVhcmUtUm9vdF9SYXN0ZXJfdGFnMEBAXCI6IFwiVGhlIGlucHV0IHZhbHVlcyB1c2VkIHRvIGZpbmQgdGhlIHNxdWFyZSByb290LlwiLFxuXHRcIkBAU3RhdGlzdGljcy1hbmQtSGlzdG9ncmFtX0RlZmluZS1TdGF0aXN0aWNzLWFuZC1IaXN0b2dyYW1fdGFnMEBAXCI6IFwiU2V0IHRoZSBzdGF0aXN0aWNzIHZhbHVlcyBmb3IgZWFjaCBiYW5kLlwiLFxuXHRcIkBAU3RhdGlzdGljcy1hbmQtSGlzdG9ncmFtX0RlZmluZS1TdGF0aXN0aWNzLWFuZC1IaXN0b2dyYW1fdGFnMUBAXCI6IFwiVGhlICR7SGlzdG9ncmFtfSBjb2x1bW4gaXMgYSByZWFkLW9ubHkgZmllbGQgdGhhdCBjYW4gYmUgcG9wdWxhdGVkIHVzaW5nIHRoZSA8c3Ryb25nPkltcG9ydDwvc3Ryb25nPiBwYXJhbWV0ZXIuIElmIHlvdSBpbXBvcnQgYSBoaXN0b2dyYW0gZmlsZSwgdGhlICR7SGlzdG9ncmFtfSBjb2x1bW4gd2lsbCBiZSBtYXJrZWQgYXMgPHN0cm9uZz5EZWZpbmVkPC9zdHJvbmc+LlwiLFxuXHRcIkBAU3RhdGlzdGljcy1hbmQtSGlzdG9ncmFtX0ltcG9ydF90YWcwQEBcIjogXCJJbXBvcnQgdGhlIHN0YXRpc3RpY3MgYW5kIGhpc3RvZ3JhbSBpbmZvcm1hdGlvbiBmcm9tIGFuIGV4aXN0aW5nIHJhc3RlciBvciBYTUwgZmlsZS5cIixcblx0XCJAQFN0YXRpc3RpY3MtYW5kLUhpc3RvZ3JhbV9SYXN0ZXJfdGFnMEBAXCI6IFwiVGhlIGlucHV0IHJhc3RlciB0aGF0IHJlcXVpcmVzIHRoZSBzdGF0aXN0aWNzIGFuZCBoaXN0b2dyYW0gdG8gYmUgc2V0LlwiLFxuXHRcIkBAU3RhdGlzdGljcy1hbmQtSGlzdG9ncmFtX1N0YXRpc3RpY3NfdGFnMEBAXCI6IFwiU2V0IHRoZSBzdGF0aXN0aWNzIHZhbHVlcyBmb3IgZWFjaCBiYW5kLlwiLFxuXHRcIkBAU3RyZWFtLUxpbmtfRmxvdy1EaXJlY3Rpb24tUmFzdGVyX3RhZzBAQFwiOiBcIlRoZSBpbnB1dCByYXN0ZXIgdGhhdCBzaG93cyB0aGUgZGlyZWN0aW9uIG9mIGZsb3cgb3V0IG9mIGVhY2ggY2VsbC5cIixcblx0XCJAQFN0cmVhbS1MaW5rX0Zsb3ctRGlyZWN0aW9uLVJhc3Rlcl90YWcxQEBcIjogXCJUaGUgZmxvdyBkaXJlY3Rpb24gcmFzdGVyIGNhbiBiZSBjcmVhdGVkIGJ5IHJ1bm5pbmcgdGhlIDxzdHJvbmc+RmxvdyBEaXJlY3Rpb248L3N0cm9uZz4gZnVuY3Rpb24uXCIsXG5cdFwiQEBTdHJlYW0tTGlua19TdHJlYW0tUmFzdGVyX3RhZzBAQFwiOiBcIlRoZSBpbnB1dCByYXN0ZXIgdGhhdCByZXByZXNlbnRzIGEgbGluZWFyIHN0cmVhbSBuZXR3b3JrLlwiLFxuXHRcIkBAU3RyZWFtLU9yZGVyX0Zsb3ctRGlyZWN0aW9uLVJhc3Rlcl90YWcwQEBcIjogXCJUaGUgaW5wdXQgcmFzdGVyIHRoYXQgc2hvd3MgdGhlIGRpcmVjdGlvbiBvZiBmbG93IG91dCBvZiBlYWNoIGNlbGwuXCIsXG5cdFwiQEBTdHJlYW0tT3JkZXJfRmxvdy1EaXJlY3Rpb24tUmFzdGVyX3RhZzFAQFwiOiBcIlRoZSBmbG93IGRpcmVjdGlvbiByYXN0ZXIgY2FuIGJlIGNyZWF0ZWQgYnkgcnVubmluZyB0aGUgPHN0cm9uZz5GbG93IERpcmVjdGlvbjwvc3Ryb25nPiBmdW5jdGlvbi5cIixcblx0XCJAQFN0cmVhbS1PcmRlcl9PcmRlci1NZXRob2RfdGFnMEBAXCI6IFwiVGhlIG1ldGhvZCB1c2VkIGZvciBhc3NpZ25pbmcgc3RyZWFtIG9yZGVyLlwiLFxuXHRcIkBAU3RyZWFtLU9yZGVyX09yZGVyLU1ldGhvZF90YWcxQEBcIjogXCI8c3Ryb25nPlNUUkFITEVSPC9zdHJvbmc+LS1UaGUgbWV0aG9kIG9mIHN0cmVhbSBvcmRlcmluZyBwcm9wb3NlZCBieSBTdHJhaGxlciBpbiAxOTUyLiBTdHJlYW0gb3JkZXIgb25seSBpbmNyZWFzZXMgd2hlbiBzdHJlYW1zIG9mIHRoZSBzYW1lIG9yZGVyIGludGVyc2VjdC4gVGhlIGludGVyc2VjdGlvbiBvZiBhIGZpcnN0LW9yZGVyIGFuZCBzZWNvbmQtb3JkZXIgbGluayB3aWxsIHJlbWFpbiBhIHNlY29uZC1vcmRlciBsaW5rLCByYXRoZXIgdGhhbiBjcmVhdGluZyBhIHRoaXJkLW9yZGVyIGxpbmsuIFRoaXMgaXMgdGhlIGRlZmF1bHQuXCIsXG5cdFwiQEBTdHJlYW0tT3JkZXJfT3JkZXItTWV0aG9kX3RhZzNAQFwiOiBcIjxzdHJvbmc+U0hSRVZFPC9zdHJvbmc+LS1UaGUgbWV0aG9kIG9mIHN0cmVhbSBvcmRlcmluZyBieSBtYWduaXR1ZGUsIHByb3Bvc2VkIGJ5IFNocmV2ZSBpbiAxOTY3LiBBbGwgbGlua3Mgd2l0aCBubyB0cmlidXRhcmllcyBhcmUgYXNzaWduZWQgYSBtYWduaXR1ZGUgKG9yZGVyKSBvZiBvbmUuIE1hZ25pdHVkZXMgYXJlIGFkZGl0aXZlIGRvd25zbG9wZS4gV2hlbiB0d28gbGlua3MgaW50ZXJzZWN0LCB0aGVpciBtYWduaXR1ZGVzIGFyZSBhZGRlZCBhbmQgYXNzaWduZWQgdG8gdGhlIGRvd25zbG9wZSBsaW5rLlwiLFxuXHRcIkBAU3RyZWFtLU9yZGVyX1N0cmVhbS1SYXN0ZXJfdGFnMEBAXCI6IFwiQW4gaW5wdXQgc3RyZWFtIHJhc3RlciB0aGF0IHJlcHJlc2VudHMgYSBsaW5lYXIgc3RyZWFtIG5ldHdvcmsuXCIsXG5cdFwiQEBTdHJldGNoX0F1dG8tR2FtbWFfdGFnMEBAXCI6IFwiVXNlIDxzdHJvbmc+QXV0byBHYW1tYTwvc3Ryb25nPiB0byBjYWxjdWxhdGUgZ2FtbWEgZnJvbSB0aGUgc3RhdGlzdGljcyBhbmQgaGlzdG9ncmFtIG9mIHRoZSBkYXRhc2V0LiBUaGUgc3RhdGlzdGljcyBjYW4gYmUgdGhlIGVzdGltYXRlZCBzdGF0cyBieSB0aGUgZnVuY3Rpb24gaXRzZWxmLCBvciB0aGUgc3RhdGlzdGljcyBjYW4gYmUgZXN0aW1hdGVkIGJ5IHRoZSBzb2Z0d2FyZSBpZiB5b3UgY2hvc2UgYSBsYXllci5cIixcblx0XCJAQFN0cmV0Y2hfRHluYW1pYy1SYW5nZS1BZGp1c3RtZW50X3RhZzBAQFwiOiBcIkNoZWNrIHRoZSA8c3Ryb25nPkR5bmFtaWMgUmFuZ2UgQWRqdXN0bWVudDwvc3Ryb25nPiBjaGVjayBib3ggaWYgeW91IHdhbnQgdGhlIHN0YXRpc3RpY3MgY2FsY3VsYXRlZCBmcm9tIG9ubHkgdGhlIHBpeGVscyBkaXNwbGF5ZWQgb24geW91ciBzY3JlZW4uIFRoaXMgb3B0aW9uIGlzIGdlbmVyYWxseSBhcHBsaWVkIHdoZW4gdGhlIGltYWdlIHdpbGwgYmUgcHVibGlzaGVkIGFuZCB1c2VkIGluIGEgd2ViIGFwcCB0aGF0IGNhbm5vdCBwZXJmb3JtIHRoaXMgdHlwZSBvZiBzdHJldGNoLlwiLFxuXHRcIkBAU3RyZXRjaF9Fc3RpbWF0ZS1TdGF0aXN0aWNzX3RhZzBAQFwiOiBcIkNoZWNrIHRoZSA8c3Ryb25nPkVzdGltYXRlIFN0YXRpc3RpY3M8L3N0cm9uZz4gY2hlY2sgYm94IGlmIHlvdSB3YW50IHRvIGVzdGltYXRlIHlvdXIgc3RhdGlzdGljcy4gVGhlIGVzdGltYXRlZCBzdGF0aXN0aWNzIGFyZSBjYWxjdWxhdGVkIGZyb20gYSAxMDAwIGJ5IDEwMDAgc2FtcGxpbmcgZnJvbSB0aGUgY2VudGVyIG9mIHRoZSByYXN0ZXIgYW5kIHVzZWQgYnkgdGhlIHN0cmV0Y2guXCIsXG5cdFwiQEBTdHJldGNoX0VzdGltYXRlLVN0YXRpc3RpY3NfdGFnM0BAXCI6IFwiSWYgdGhpcyBpcyBjaGVja2VkIGFuZCB0aGUgcmFzdGVyIGhhcyBzdGF0aXN0aWNzLCBvciB5b3UndmUgZW50ZXJlZCB2YWx1ZXMgaW4gdGhlIDxzdHJvbmc+U3RhdGlzdGljczwvc3Ryb25nPiB0YWJsZSwgdGhleSB3aWxsIGJlIHVzZWQgaW5zdGVhZCBvZiBlc3RpbWF0aW5nLCB1bmxlc3MgdGhlIHN0cmV0Y2ggcmVxdWlyZXMgYSBoaXN0b2dyYW0uIElmIHRoZSBzdHJldGNoIHJlcXVpcmVzIGEgaGlzdG9ncmFtIHRoYXQgZG9lc24ndCBleGlzdCwgaXQgd2lsbCBiZSBlc3RpbWF0ZWQuXCIsXG5cdFwiQEBTdHJldGNoX0dhbW1hX3RhZzBAQFwiOiBcIlVzZSB0aGUgc2xpZGVyIGJhciB0byBtYW51YWxseSBzZXQgdGhlIDxzdHJvbmc+R2FtbWE8L3N0cm9uZz4gdmFsdWUuXCIsXG5cdFwiQEBTdHJldGNoX051bWJlci1PZi1TdGFuZGFyZC1EZXZpYXRpb25zX3RhZzBAQFwiOiBcIlNwZWNpZnkgdGhlIG4gdmFsdWUgZm9yIHRoZSBudW1iZXIgb2Ygc3RhbmRhcmQgZGV2aWF0aW9ucyB0byB1c2UuIFRoaXMgbWV0aG9kIGlzIHVzZWQgdG8gZW1waGFzaXplIGhvdyBtdWNoIGZlYXR1cmUgdmFsdWVzIHZhcnkgZnJvbSB0aGUgbWVhbiB2YWx1ZTsgaXQgaXMgYmVzdCB3aGVuIHVzZWQgb24gbm9ybWFsbHkgZGlzdHJpYnV0ZWQgZGF0YS5cIixcblx0XCJAQFN0cmV0Y2hfT3V0cHV0LU1heGltdW1fdGFnMEBAXCI6IFwiU2V0IHRoZSBoaWdoZXN0IHBpeGVsIHZhbHVlIGZvciB0aGUgaGlzdG9ncmFtLlwiLFxuXHRcIkBAU3RyZXRjaF9PdXRwdXQtTWF4aW11bV90YWcxQEBcIjogXCJUaGUgPHN0cm9uZz5PdXRwdXQgTWluaW11bTwvc3Ryb25nPiBhbmQgPHN0cm9uZz5PdXRwdXQgTWF4aW11bTwvc3Ryb25nPiB3aWxsIHNldCB0aGUgcmFuZ2Ugb2YgdmFsdWVzIHRoYXQgd2lsbCB0aGVuIGJlIGxpbmVhcmx5IGNvbnRyYXN0IHN0cmV0Y2hlZC5cIixcblx0XCJAQFN0cmV0Y2hfT3V0cHV0LU1pbmltdW1fdGFnMEBAXCI6IFwiU2V0IHRoZSBsb3dlc3QgcGl4ZWwgdmFsdWUgZm9yIHRoZSBoaXN0b2dyYW0uXCIsXG5cdFwiQEBTdHJldGNoX091dHB1dC1NaW5pbXVtX3RhZzFAQFwiOiBcIlRoZSA8c3Ryb25nPk91dHB1dCBNaW5pbXVtPC9zdHJvbmc+IGFuZCA8c3Ryb25nPk91dHB1dCBNYXhpbXVtPC9zdHJvbmc+IHdpbGwgc2V0IHRoZSByYW5nZSBvZiB2YWx1ZXMgdGhhdCB3aWxsIHRoZW4gYmUgbGluZWFybHkgY29udHJhc3Qgc3RyZXRjaGVkLlwiLFxuXHRcIkBAU3RyZXRjaF9QZXJjZW50LUNsaXAtTWF4aW11bV90YWcwQEBcIjogXCJTcGVjaWZ5IHRoZSBwZXJjZW50YWdlIG9mIHRoZSBoaWdoIHZhbHVlcyB0byBleGNsdWRlIGZyb20gdGhlIHN0cmV0Y2guXCIsXG5cdFwiQEBTdHJldGNoX1BlcmNlbnQtQ2xpcC1NYXhpbXVtX3RhZzFAQFwiOiBcIlZhbGlkIHZhbHVlcyByYW5nZSBmcm9tIDAgdG8gOTkuXCIsXG5cdFwiQEBTdHJldGNoX1BlcmNlbnQtQ2xpcC1NaW5pbXVtX3RhZzBAQFwiOiBcIlNwZWNpZnkgdGhlIHBlcmNlbnRhZ2Ugb2YgdGhlIGxvdyB2YWx1ZXMgdG8gZXhjbHVkZSBmcm9tIHRoZSBzdHJldGNoLlwiLFxuXHRcIkBAU3RyZXRjaF9QZXJjZW50LUNsaXAtTWluaW11bV90YWcxQEBcIjogXCJWYWxpZCB2YWx1ZXMgcmFuZ2UgZnJvbSAwIHRvIDk5LlwiLFxuXHRcIkBAU3RyZXRjaF9SYXN0ZXJfdGFnMEBAXCI6IFwiVGhlIGlucHV0IHJhc3RlciB0byBjb250cmFzdCBzdHJldGNoLlwiLFxuXHRcIkBAU3RyZXRjaF9TaWdtb2lkLVN0cmVuZ3RoLUxldmVsX3RhZzBAQFwiOiBcIlRoZSA8c3Ryb25nPlN0cmVuZ3RoIExldmVsPC9zdHJvbmc+IGRldGVybWluZXMgaG93IG11Y2ggb2YgdGhlIHNpZ21vaWRhbCBmdW5jdGlvbiB3aWxsIGJlIHVzZWQgaW4gdGhlIHN0cmV0Y2guIEEgbG93IHZhbHVlIHN1Y2ggYXMgMSB3aWxsIG9ubHkgdXNlIHRoZSBtaWRkbGUgcG9ydGlvbiBvZiB0aGUgY3VydmUsIHdoaWNoIHRlbmRzIHRvIHByb2R1Y2UgZHVsbCBhbmQgZmFpbnQgY29sb3JzLiBBIGhpZ2ggdmFsdWUgc3VjaCBhcyA2IHdpbGwgdXNlIHRoZSBlbnRpcmUgY3VydmUsIHdoaWNoIHRlbmRzIHRvIHByb2R1Y2UgYm9sZCBhbmQgc2hhcnAgY29sb3JzLlwiLFxuXHRcIkBAU3RyZXRjaF9TdGF0aXN0aWNzX3RhZzBAQFwiOiBcIllvdSBjYW4gZW50ZXIgeW91ciBvd24gc3RhdGlzdGljcyBvbiB0aGUgZGlhbG9nIGJveC4gQnkgZGVmYXVsdCwgdGhlIHN0YXRpc3RpY3MgYXJlIHJldHJpZXZlZCBmcm9tIHRoZSBkYXRhOyBob3dldmVyLCBhbnkgdmFsdWVzIHlvdSBlbnRlciBpbiB0aGlzIHBhcmFtZXRlciB3aWxsIGJlIHVzZWQgaW5zdGVhZC5cIixcblx0XCJAQFN0cmV0Y2hfVHlwZV90YWcwQEBcIjogXCJDaG9vc2UgdGhlIHN0cmV0Y2ggdHlwZSBtZXRob2Q6XCIsXG5cdFwiQEBTdHJldGNoX1R5cGVfdGFnMUBAXCI6IFwiTm9uZS0tTm8gY29udHJhc3Qgc3RyZXRjaFwiLFxuXHRcIkBAU3RyZXRjaF9UeXBlX3RhZzJAQFwiOiBcIlN0ZERldi0tU3RhbmRhcmQgZGV2aWF0aW9uIHN0cmV0Y2hcIixcblx0XCJAQFN0cmV0Y2hfVHlwZV90YWczQEBcIjogXCJNaW5NYXgtLU1pbmltdW0tTWF4aW11bSBzdHJldGNoXCIsXG5cdFwiQEBTdHJldGNoX1R5cGVfdGFnNEBAXCI6IFwiUGVyY2VudE1pbk1heC0tUGVyY2VudCBjbGlwIHN0cmV0Y2hcIixcblx0XCJAQFN0cmV0Y2hfVHlwZV90YWc1QEBcIjogXCJTaWdtb2lkLS1TaWdtb2lkIHN0cmV0Y2hcIixcblx0XCJAQFN0cmV0Y2hfVXNlLUdhbW1hX3RhZzBAQFwiOiBcIkNoZWNrIHRoZSA8c3Ryb25nPlVzZSBHYW1tYTwvc3Ryb25nPiBjaGVjayBib3ggaWYgeW91IHdhbnQgdG8gYXBwbHkgYSBnYW1tYSBzdHJldGNoLlwiLFxuXHRcIkBAU3dhdGhfQ2VsbHNpemVfdGFnMEBAXCI6IFwiVGhlIGNlbGwgc2l6ZSBmb3IgdGhlIG91dHB1dCByYXN0ZXIgd2lsbCBiZSBhdXRvbWF0aWNhbGx5IGRldGVjdGVkOyBob3dldmVyLCB5b3UgY2FuIGNoYW5nZSB0aGlzIGlmIHlvdSB3YW50IHRvLiBUaGUgY2VsbCBzaXplIGNhbiBiZSBjaGFuZ2VkLCBidXQgdGhlIGV4dGVudCBvZiB0aGUgcmFzdGVyIGRhdGFzZXQgd2lsbCByZW1haW4gdGhlIHNhbWUuXCIsXG5cdFwiQEBTd2F0aF9JbnRlcnBvbGF0aW9uLU1ldGhvZF90YWcwQEBcIjogXCJUaGVyZSBhcmUgZm91ciByZXNhbXBsaW5nIG1ldGhvZHMgZm9yIHRoaXMgZnVuY3Rpb246XCIsXG5cdFwiQEBTd2F0aF9JbnRlcnBvbGF0aW9uLU1ldGhvZF90YWcxQEBcIjogXCI8c3Ryb25nPk5lYXJlc3QgTmVpZ2hib3I8L3N0cm9uZz4tLUNhbGN1bGF0ZXMgcGl4ZWwgdmFsdWUgdXNpbmcgdGhlIG5lYXJlc3QgcGl4ZWwuIElmIG5vIHNvdXJjZSBwaXhlbCBleGlzdHMsIG5vIG5ldyBwaXhlbCBjYW4gYmUgY3JlYXRlZCBpbiB0aGUgb3V0cHV0LlwiLFxuXHRcIkBAU3dhdGhfSW50ZXJwb2xhdGlvbi1NZXRob2RfdGFnM0BAXCI6IFwiPHN0cm9uZz5CaWxpbmVhcjwvc3Ryb25nPi0tQ2FsY3VsYXRlcyBwaXhlbCB2YWx1ZSB1c2luZyB0aGUgZGlzdGFuY2Utd2VpZ2h0ZWQgdmFsdWUgb2YgZm91ciBuZWFyZXN0IHBpeGVscy5cIixcblx0XCJAQFN3YXRoX0ludGVycG9sYXRpb24tTWV0aG9kX3RhZzVAQFwiOiBcIjxzdHJvbmc+TGluZWFyIFRpbm5pbmc8L3N0cm9uZz4tLVVzZXMgYSB0cmlhbmd1bGF0ZWQgaXJyZWd1bGFyIG5ldHdvcmsgZnJvbSB0aGUgY2VudGVyIHBvaW50cyBvZiBlYWNoIGNlbGwgaW4gdGhlIGlycmVndWxhciByYXN0ZXIgdG8gaW50ZXJwb2xhdGUgYSBzdXJmYWNlIHRoYXQgaXMgdGhlbiBjb252ZXJ0ZWQgdG8gYSByZWd1bGFyIHJhc3Rlci5cIixcblx0XCJAQFN3YXRoX0ludGVycG9sYXRpb24tTWV0aG9kX3RhZzdAQFwiOiBcIjxzdHJvbmc+TmF0dXJhbCBOZWlnaGJvcjwvc3Ryb25nPi0tUGVyZm9ybXMgYSBuZWFyZXN0IG5laWdoYm9yIGFzc2lnbm1lbnQsIGlzIHRoZSBmYXN0ZXN0IG9mIHRoZSBpbnRlcnBvbGF0aW9uIG1ldGhvZHMuIEl0IGlzIHVzZWQgcHJpbWFyaWx5IGZvciBkaXNjcmV0ZSBkYXRhLCBzdWNoIGFzIGEgbGFuZC11c2UgY2xhc3NpZmljYXRpb24sIHNpbmNlIGl0IHdpbGwgbm90IGNoYW5nZSB0aGUgdmFsdWVzIG9mIHRoZSBjZWxscy4gVGhlIG1heGltdW0gc3BhdGlhbCBlcnJvciB3aWxsIGJlIG9uZS1oYWxmIHRoZSBjZWxsIHNpemUuXCIsXG5cdFwiQEBTd2F0aF9SYXN0ZXJfdGFnMEBAXCI6IFwiVGhlIGlycmVndWxhcmx5IGdyaWRkZWQgcmFzdGVyIHRvIGJlIHJlc2FtcGxlZC5cIixcblx0XCJAQFRhbl9DZWxsc2l6ZS1UeXBlX3RhZzBAQFwiOiBcIkNob29zZSB3aGljaCBjZWxsIHNpemUgdG8gdXNlIGluIHRoZSBvdXRwdXQgcmFzdGVyLiBJZiBhbGwgdGhlIGlucHV0IGNlbGwgc2l6ZXMgYXJlIHRoZSBzYW1lLCBhbGwgdGhlIG9wdGlvbnMgd2lsbCB5aWVsZCB0aGUgc2FtZSByZXN1bHRzLlwiLFxuXHRcIkBAVGFuX0NlbGxzaXplLVR5cGVfdGFnMUBAXCI6IFwiRmlyc3QgT2YtLVVzZSB0aGUgZmlyc3QgY2VsbCBzaXplIG9mIHRoZSBpbnB1dCByYXN0ZXJzLlwiLFxuXHRcIkBAVGFuX0NlbGxzaXplLVR5cGVfdGFnMkBAXCI6IFwiTGFzdCBPZi0tVXNlIHRoZSBsYXN0IGNlbGwgc2l6ZSBvZiB0aGUgaW5wdXQgcmFzdGVycy5cIixcblx0XCJAQFRhbl9DZWxsc2l6ZS1UeXBlX3RhZzNAQFwiOiBcIk1heCBPZi0tVXNlIHRoZSBsYXJnZXN0IGNlbGwgc2l6ZSBvZiBhbGwgdGhlIGlucHV0IHJhc3RlcnMuIFRoaXMgaXMgdGhlIGRlZmF1bHQuXCIsXG5cdFwiQEBUYW5fQ2VsbHNpemUtVHlwZV90YWc0QEBcIjogXCJNZWFuIE9mLS1Vc2UgdGhlIG1lYW4gY2VsbCBzaXplIG9mIGFsbCB0aGUgaW5wdXQgcmFzdGVycy5cIixcblx0XCJAQFRhbl9DZWxsc2l6ZS1UeXBlX3RhZzVAQFwiOiBcIk1pbiBPZi0tVXNlIHRoZSBzbWFsbGVzdCBjZWxsIHNpemUgb2YgYWxsIHRoZSBpbnB1dCByYXN0ZXJzLlwiLFxuXHRcIkBAVGFuX0V4dGVudC1UeXBlX3RhZzBAQFwiOiBcIkNob29zZSB3aGljaCBleHRlbnQgc2hvdWxkIGJlIHVzZWQgaW4gdGhlIG91dHB1dCByYXN0ZXI6XCIsXG5cdFwiQEBUYW5fRXh0ZW50LVR5cGVfdGFnMUBAXCI6IFwiRmlyc3QgT2YtLVVzZSB0aGUgZXh0ZW50IG9mIHRoZSBmaXJzdCBpbnB1dCByYXN0ZXIgdG8gZGV0ZXJtaW5lIHRoZSBwcm9jZXNzaW5nIGV4dGVudC5cIixcblx0XCJAQFRhbl9FeHRlbnQtVHlwZV90YWcyQEBcIjogXCJJbnRlcnNlY3Rpb24gT2YtLVVzZSB0aGUgZXh0ZW50IG9mIHRoZSBvdmVybGFwcGluZyBwaXhlbHMgdG8gZGV0ZXJtaW5lIHRoZSBwcm9jZXNzaW5nIGV4dGVudC4gVGhpcyBpcyB0aGUgZGVmYXVsdC5cIixcblx0XCJAQFRhbl9FeHRlbnQtVHlwZV90YWczQEBcIjogXCJMYXN0IE9mLS1Vc2UgdGhlIGV4dGVudCBvZiB0aGUgbGFzdCBpbnB1dCByYXN0ZXIgdG8gZGV0ZXJtaW5lIHRoZSBwcm9jZXNzaW5nIGV4dGVudC5cIixcblx0XCJAQFRhbl9FeHRlbnQtVHlwZV90YWc0QEBcIjogXCJVbmlvbiBPZi0tVXNlIHRoZSBleHRlbnQgb2YgYWxsIHRoZSByYXN0ZXJzIHRvIGRldGVybWluZSB0aGUgcHJvY2Vzc2luZyBleHRlbnQuXCIsXG5cdFwiQEBUYW5fUmFzdGVyX3RhZzBAQFwiOiBcIlRoZSBpbnB1dCBmb3Igd2hpY2ggdG8gY2FsY3VsYXRlIHRoZSB0YW5nZW50IHZhbHVlcy5cIixcblx0XCJAQFRhbkhfQ2VsbHNpemUtVHlwZV90YWcwQEBcIjogXCJDaG9vc2Ugd2hpY2ggY2VsbCBzaXplIHRvIHVzZSBpbiB0aGUgb3V0cHV0IHJhc3Rlci4gSWYgYWxsIHRoZSBpbnB1dCBjZWxsIHNpemVzIGFyZSB0aGUgc2FtZSwgYWxsIHRoZSBvcHRpb25zIHdpbGwgeWllbGQgdGhlIHNhbWUgcmVzdWx0cy5cIixcblx0XCJAQFRhbkhfQ2VsbHNpemUtVHlwZV90YWcxQEBcIjogXCJGaXJzdCBPZi0tVXNlIHRoZSBmaXJzdCBjZWxsIHNpemUgb2YgdGhlIGlucHV0IHJhc3RlcnMuXCIsXG5cdFwiQEBUYW5IX0NlbGxzaXplLVR5cGVfdGFnMkBAXCI6IFwiTGFzdCBPZi0tVXNlIHRoZSBsYXN0IGNlbGwgc2l6ZSBvZiB0aGUgaW5wdXQgcmFzdGVycy5cIixcblx0XCJAQFRhbkhfQ2VsbHNpemUtVHlwZV90YWczQEBcIjogXCJNYXggT2YtLVVzZSB0aGUgbGFyZ2VzdCBjZWxsIHNpemUgb2YgYWxsIHRoZSBpbnB1dCByYXN0ZXJzLiBUaGlzIGlzIHRoZSBkZWZhdWx0LlwiLFxuXHRcIkBAVGFuSF9DZWxsc2l6ZS1UeXBlX3RhZzRAQFwiOiBcIk1lYW4gT2YtLVVzZSB0aGUgbWVhbiBjZWxsIHNpemUgb2YgYWxsIHRoZSBpbnB1dCByYXN0ZXJzLlwiLFxuXHRcIkBAVGFuSF9DZWxsc2l6ZS1UeXBlX3RhZzVAQFwiOiBcIk1pbiBPZi0tVXNlIHRoZSBzbWFsbGVzdCBjZWxsIHNpemUgb2YgYWxsIHRoZSBpbnB1dCByYXN0ZXJzLlwiLFxuXHRcIkBAVGFuSF9FeHRlbnQtVHlwZV90YWcwQEBcIjogXCJDaG9vc2Ugd2hpY2ggZXh0ZW50IHNob3VsZCBiZSB1c2VkIGluIHRoZSBvdXRwdXQgcmFzdGVyOlwiLFxuXHRcIkBAVGFuSF9FeHRlbnQtVHlwZV90YWcxQEBcIjogXCJGaXJzdCBPZi0tVXNlIHRoZSBleHRlbnQgb2YgdGhlIGZpcnN0IGlucHV0IHJhc3RlciB0byBkZXRlcm1pbmUgdGhlIHByb2Nlc3NpbmcgZXh0ZW50LlwiLFxuXHRcIkBAVGFuSF9FeHRlbnQtVHlwZV90YWcyQEBcIjogXCJJbnRlcnNlY3Rpb24gT2YtLVVzZSB0aGUgZXh0ZW50IG9mIHRoZSBvdmVybGFwcGluZyBwaXhlbHMgdG8gZGV0ZXJtaW5lIHRoZSBwcm9jZXNzaW5nIGV4dGVudC4gVGhpcyBpcyB0aGUgZGVmYXVsdC5cIixcblx0XCJAQFRhbkhfRXh0ZW50LVR5cGVfdGFnM0BAXCI6IFwiTGFzdCBPZi0tVXNlIHRoZSBleHRlbnQgb2YgdGhlIGxhc3QgaW5wdXQgcmFzdGVyIHRvIGRldGVybWluZSB0aGUgcHJvY2Vzc2luZyBleHRlbnQuXCIsXG5cdFwiQEBUYW5IX0V4dGVudC1UeXBlX3RhZzRAQFwiOiBcIlVuaW9uIE9mLS1Vc2UgdGhlIGV4dGVudCBvZiBhbGwgdGhlIHJhc3RlcnMgdG8gZGV0ZXJtaW5lIHRoZSBwcm9jZXNzaW5nIGV4dGVudC5cIixcblx0XCJAQFRhbkhfUmFzdGVyX3RhZzBAQFwiOiBcIlRoZSBpbnB1dCBmb3Igd2hpY2ggdG8gY2FsY3VsYXRlIHRoZSBoeXBlcmJvbGljIHRhbmdlbnQgdmFsdWVzLlwiLFxuXHRcIkBAVGFzc2VsZWQtQ2FwX1Jhc3Rlcl90YWcwQEBcIjogXCJUaGUgaW5wdXQgcmFzdGVyIHRvIHBlcmZvcm0gdGhlIFRhc3NlbGVkIENhcCB0cmFuc2Zvcm1hdGlvbiBvbi5cIixcblx0XCJAQFRpbWVzX0NlbGxzaXplLVR5cGVfdGFnMEBAXCI6IFwiQ2hvb3NlIHdoaWNoIGNlbGwgc2l6ZSB0byB1c2UgaW4gdGhlIG91dHB1dCByYXN0ZXIuIElmIGFsbCB0aGUgaW5wdXQgY2VsbCBzaXplcyBhcmUgdGhlIHNhbWUsIGFsbCB0aGUgb3B0aW9ucyB3aWxsIHlpZWxkIHRoZSBzYW1lIHJlc3VsdHMuXCIsXG5cdFwiQEBUaW1lc19DZWxsc2l6ZS1UeXBlX3RhZzFAQFwiOiBcIkZpcnN0IE9mLS1Vc2UgdGhlIGZpcnN0IGNlbGwgc2l6ZSBvZiB0aGUgaW5wdXQgcmFzdGVycy5cIixcblx0XCJAQFRpbWVzX0NlbGxzaXplLVR5cGVfdGFnMkBAXCI6IFwiTGFzdCBPZi0tVXNlIHRoZSBsYXN0IGNlbGwgc2l6ZSBvZiB0aGUgaW5wdXQgcmFzdGVycy5cIixcblx0XCJAQFRpbWVzX0NlbGxzaXplLVR5cGVfdGFnM0BAXCI6IFwiTWF4IE9mLS1Vc2UgdGhlIGxhcmdlc3QgY2VsbCBzaXplIG9mIGFsbCB0aGUgaW5wdXQgcmFzdGVycy4gVGhpcyBpcyB0aGUgZGVmYXVsdC5cIixcblx0XCJAQFRpbWVzX0NlbGxzaXplLVR5cGVfdGFnNEBAXCI6IFwiTWVhbiBPZi0tVXNlIHRoZSBtZWFuIGNlbGwgc2l6ZSBvZiBhbGwgdGhlIGlucHV0IHJhc3RlcnMuXCIsXG5cdFwiQEBUaW1lc19DZWxsc2l6ZS1UeXBlX3RhZzVAQFwiOiBcIk1pbiBPZi0tVXNlIHRoZSBzbWFsbGVzdCBjZWxsIHNpemUgb2YgYWxsIHRoZSBpbnB1dCByYXN0ZXJzLlwiLFxuXHRcIkBAVGltZXNfRXh0ZW50LVR5cGVfdGFnMEBAXCI6IFwiQ2hvb3NlIHdoaWNoIGV4dGVudCBzaG91bGQgYmUgdXNlZCBpbiB0aGUgb3V0cHV0IHJhc3RlcjpcIixcblx0XCJAQFRpbWVzX0V4dGVudC1UeXBlX3RhZzFAQFwiOiBcIkZpcnN0IE9mLS1Vc2UgdGhlIGV4dGVudCBvZiB0aGUgZmlyc3QgaW5wdXQgcmFzdGVyIHRvIGRldGVybWluZSB0aGUgcHJvY2Vzc2luZyBleHRlbnQuXCIsXG5cdFwiQEBUaW1lc19FeHRlbnQtVHlwZV90YWcyQEBcIjogXCJJbnRlcnNlY3Rpb24gT2YtLVVzZSB0aGUgZXh0ZW50IG9mIHRoZSBvdmVybGFwcGluZyBwaXhlbHMgdG8gZGV0ZXJtaW5lIHRoZSBwcm9jZXNzaW5nIGV4dGVudC4gVGhpcyBpcyB0aGUgZGVmYXVsdC5cIixcblx0XCJAQFRpbWVzX0V4dGVudC1UeXBlX3RhZzNAQFwiOiBcIkxhc3QgT2YtLVVzZSB0aGUgZXh0ZW50IG9mIHRoZSBsYXN0IGlucHV0IHJhc3RlciB0byBkZXRlcm1pbmUgdGhlIHByb2Nlc3NpbmcgZXh0ZW50LlwiLFxuXHRcIkBAVGltZXNfRXh0ZW50LVR5cGVfdGFnNEBAXCI6IFwiVW5pb24gT2YtLVVzZSB0aGUgZXh0ZW50IG9mIGFsbCB0aGUgcmFzdGVycyB0byBkZXRlcm1pbmUgdGhlIHByb2Nlc3NpbmcgZXh0ZW50LlwiLFxuXHRcIkBAVGltZXNfUmFzdGVyX3RhZzBAQFwiOiBcIlRoZSBpbnB1dCBjb250YWluaW5nIHRoZSB2YWx1ZXMgdG8gYmUgbXVsdGlwbGllZC5cIixcblx0XCJAQFRpbWVzX1Jhc3Rlcl90YWcxQEBcIjogXCJBIGNvbnN0YW50IHZhbHVlIGNhbiBiZSB1c2VkIGFzIGFuIGlucHV0IGZvciB0aGlzIHBhcmFtZXRlciwgcHJvdmlkZWQgYSByYXN0ZXIgaXMgc3BlY2lmaWVkIGZvciB0aGUgb3RoZXIgcGFyYW1ldGVyLlwiLFxuXHRcIkBAVGltZXNfUmFzdGVyMl90YWcwQEBcIjogXCJUaGUgaW5wdXQgY29udGFpbmluZyB0aGUgdmFsdWVzIGJ5IHdoaWNoIHRoZSBmaXJzdCBpbnB1dCB3aWxsIGJlIG11bHRpcGxpZWQuXCIsXG5cdFwiQEBUaW1lc19SYXN0ZXIyX3RhZzFAQFwiOiBcIkEgY29uc3RhbnQgdmFsdWUgY2FuIGJlIHVzZWQgYXMgYW4gaW5wdXQgZm9yIHRoaXMgcGFyYW1ldGVyLCBwcm92aWRlZCBhIHJhc3RlciBpcyBzcGVjaWZpZWQgZm9yIHRoZSBvdGhlciBwYXJhbWV0ZXIuXCIsXG5cdFwiQEBUcmFuc3Bvc2UtQml0c19CaXQtUGF0dGVybl90YWcwQEBcIjogXCJDaG9vc2UgdGhlIHR5cGUgb2YgdHJhbnNwb3NlIHRvIHBlcmZvcm0gb3Igc3BlY2lmeSBhIGN1c3RvbSBvbmU6XCIsXG5cdFwiQEBUcmFuc3Bvc2UtQml0c19CaXQtUGF0dGVybl90YWcxQEBcIjogXCJMYW5kc2F0IDggQ2lycnVzXCIsXG5cdFwiQEBUcmFuc3Bvc2UtQml0c19CaXQtUGF0dGVybl90YWcyQEBcIjogXCJMYW5kc2F0IDggQ2xvdWRcIixcblx0XCJAQFRyYW5zcG9zZS1CaXRzX0JpdC1QYXR0ZXJuX3RhZzNAQFwiOiBcIkxhbmRzYXQgOCBDbG91ZCBTaGFkb3dcIixcblx0XCJAQFRyYW5zcG9zZS1CaXRzX0JpdC1QYXR0ZXJuX3RhZzRAQFwiOiBcIkxhbmRzYXQgOCBEZXNpZ25hdGVkIEZpbGxcIixcblx0XCJAQFRyYW5zcG9zZS1CaXRzX0JpdC1QYXR0ZXJuX3RhZzVAQFwiOiBcIkxhbmRzYXQgOCBEcm9wcGVkIEZyYW1lXCIsXG5cdFwiQEBUcmFuc3Bvc2UtQml0c19CaXQtUGF0dGVybl90YWc2QEBcIjogXCJMYW5kc2F0IDggU25vdy9JY2VcIixcblx0XCJAQFRyYW5zcG9zZS1CaXRzX0JpdC1QYXR0ZXJuX3RhZzdAQFwiOiBcIkxhbmRzYXQgOCBUZXJyYWluIE9jY2x1c2lvblwiLFxuXHRcIkBAVHJhbnNwb3NlLUJpdHNfQml0LVBhdHRlcm5fdGFnOEBAXCI6IFwiTGFuZHNhdCA4IFZlZ2V0YXRpb25cIixcblx0XCJAQFRyYW5zcG9zZS1CaXRzX0JpdC1QYXR0ZXJuX3RhZzlAQFwiOiBcIkxhbmRzYXQgOCBXYXRlclwiLFxuXHRcIkBAVHJhbnNwb3NlLUJpdHNfQml0LVBhdHRlcm5fdGFnMTBAQFwiOiBcIlVzZXIgRGVmaW5lZFwiLFxuXHRcIkBAVHJhbnNwb3NlLUJpdHNfQ29uc3RhbnQtVmFsdWVfdGFnMEBAXCI6IFwiQW4gb3B0aW9uYWwgdmFsdWUgdGhhdCB3aWxsIGJlIHVzZWQgdG8gZmlsbCBpbiBhbGwgYml0cyB0aGF0IGFyZSBub3QgaW52b2x2ZWQgaW4gdGhlIHRyYW5zcG9zZS4gVGhpcyBwYXJhbWV0ZXIgaXMgZXhwb3NlZCB3aGVuIHRoZSA8c3Ryb25nPkdlbmVyYXRlIEZpbGwgUmFzdGVyIGZyb20gQ29uc3RhbnQ8L3N0cm9uZz4gcGFyYW1ldGVyIGlzIHNldCB0byA8c3Ryb25nPlllczwvc3Ryb25nPi5cIixcblx0XCJAQFRyYW5zcG9zZS1CaXRzX0ZpbGwtUmFzdGVyX3RhZzBAQFwiOiBcIlNwZWNpZnkgYSByYXN0ZXIgZGF0YXNldCB0byBiZSB1c2VkIHRvIGZpbGwgaW4gYWxsIGJpdHMgdGhhdCBhcmUgbm90IGludm9sdmVkIGluIHRoZSB0cmFuc3Bvc2UuIFRoaXMgcGFyYW1ldGVyIGlzIGV4cG9zZWQgd2hlbiB0aGUgPHN0cm9uZz5HZW5lcmF0ZSBGaWxsIFJhc3RlciBmcm9tIENvbnN0YW50PC9zdHJvbmc+IHBhcmFtZXRlciBpcyBzZXQgdG8gPHN0cm9uZz5Obzwvc3Ryb25nPi5cIixcblx0XCJAQFRyYW5zcG9zZS1CaXRzX0dlbmVyYXRlLUZpbGwtUmFzdGVyLWZyb20tQ29uc3RhbnRfdGFnMEBAXCI6IFwiR2VuZXJhdGUgYSBmaWxsIHJhc3RlciB1c2luZyBhIGNvbnN0YW50IHZhbHVlOlwiLFxuXHRcIkBAVHJhbnNwb3NlLUJpdHNfR2VuZXJhdGUtRmlsbC1SYXN0ZXItZnJvbS1Db25zdGFudF90YWcxQEBcIjogXCI8c3Ryb25nPlllczwvc3Ryb25nPi0tQSByYXN0ZXIgd2lsbCBiZSBnZW5lcmF0ZWQgdXNpbmcgYSBjb25zdGFudCB2YWx1ZSB0byBmaWxsIGluIHRoZSBiaXRzIG5vdCBpbnZvbHZlZCBpbiB0aGUgdHJhbnNwb3NlLiBUaGlzIGlzIHRoZSBkZWZhdWx0LlwiLFxuXHRcIkBAVHJhbnNwb3NlLUJpdHNfR2VuZXJhdGUtRmlsbC1SYXN0ZXItZnJvbS1Db25zdGFudF90YWczQEBcIjogXCI8c3Ryb25nPk5vPC9zdHJvbmc+LS1BIHJhc3RlciB3aWxsIGJlIGdlbmVyYXRlZCB1c2luZyBwaXhlbCB2YWx1ZXMgZnJvbSBhbiBleGlzdGluZyByYXN0ZXIgZGF0YXNldCB0byBmaWxsIGluIHRoZSBiaXRzIG5vdCBpbnZvbHZlZCBpbiB0aGUgdHJhbnNwb3NlLlwiLFxuXHRcIkBAVHJhbnNwb3NlLUJpdHNfT3V0cHV0LUJpdC1hbmQtSW5wdXQtQml0X3RhZzBAQFwiOiBcIkEgcmVhZC1vbmx5IHRhYmxlIHRoYXQgc2hvd3MgdGhlIG91dHB1dCBiaXRzIGFuZCB0aGUgaW5wdXRzIHRoYXQgd2lsbCBiZSBpbiB0aGVpciBwbGFjZS5cIixcblx0XCJAQFRyYW5zcG9zZS1CaXRzX1Jhc3Rlcl90YWcwQEBcIjogXCJUaGUgaW5wdXQgcmFzdGVyIHRvIHVucGFjayBhbmQgcmVtYXAuXCIsXG5cdFwiQEBVbml0LUNvbnZlcnNpb25fRnJvbS1Vbml0X3RhZzBAQFwiOiBcIlRoZSBvcmlnaW5hbCB1bml0IHR5cGUgb2YgdGhlIHBpeGVscy5cIixcblx0XCJAQFVuaXQtQ29udmVyc2lvbl9SYXN0ZXJfdGFnMEBAXCI6IFwiVGhlIGlucHV0IHJhc3RlciB0aGF0IHdpbGwgY29udGFpbiB0aGUgY29udmVydGVkIHVuaXRzLlwiLFxuXHRcIkBAVW5pdC1Db252ZXJzaW9uX1RvLVVuaXRfdGFnMEBAXCI6IFwiVGhlIGNvbnZlcnRlZCB1bml0IHR5cGUgb2YgdGhlIHBpeGVscy5cIixcblx0XCJAQFZlY3Rvci1GaWVsZF9BbmdsZS1SZWZlcmVuY2UtU3lzdGVtX3RhZzBAQFwiOiBcIlNwZWNpZmllcyBob3cgdGhlIGRpcmVjdGlvbiBjb21wb25lbnQgd2FzIG1lYXN1cmVkLlwiLFxuXHRcIkBAVmVjdG9yLUZpZWxkX0FuZ2xlLVJlZmVyZW5jZS1TeXN0ZW1fdGFnMUBAXCI6IFwiR2VvZ3JhcGhpYy0tMMKwIHBvaW50cyBkdWUgbm9ydGgsIGFuZCA5MMKwIHBvaW50cyBkdWUgZWFzdFwiLFxuXHRcIkBAVmVjdG9yLUZpZWxkX0FuZ2xlLVJlZmVyZW5jZS1TeXN0ZW1fdGFnMkBAXCI6IFwiQXJpdGhtZXRpYy0tMMKwIHBvaW50cyBkdWUgZWFzdCwgYW5kIDkwwrAgcG9pbnRzIGR1ZSBub3J0aFwiLFxuXHRcIkBAVmVjdG9yLUZpZWxkX0lucHV0LURhdGEtVHlwZV90YWcwQEBcIjogXCJUaGUgdHlwZSBvZiB2ZWN0b3IgZmllbGQgeW91ciBpbnB1dHMgcmVwcmVzZW50LlwiLFxuXHRcIkBAVmVjdG9yLUZpZWxkX0lucHV0LURhdGEtVHlwZV90YWcxQEBcIjogXCJVbmtub3duLS1JdCBpcyB1bmtub3duIHdoZXRoZXIgdGhlIGlucHV0cyByZXByZXNlbnQgVS1WIG9yIE1hZ25pdHVkZS1EaXJlY3Rpb24uXCIsXG5cdFwiQEBWZWN0b3ItRmllbGRfSW5wdXQtRGF0YS1UeXBlX3RhZzJAQFwiOiBcIlUtVi0tSW5wdXQgZGF0YSByZXByZXNlbnRzIFUgYW5kIFYgY29tcG9uZW50cy5cIixcblx0XCJAQFZlY3Rvci1GaWVsZF9JbnB1dC1EYXRhLVR5cGVfdGFnM0BAXCI6IFwiTWFnbml0dWRlLURpcmVjdGlvbi0tSW5wdXQgZGF0YSByZXByZXNlbnRzIG1hZ25pdHVkZSBhbmQgZGlyZWN0aW9uLlwiLFxuXHRcIkBAVmVjdG9yLUZpZWxkX091dHB1dC1EYXRhLVR5cGVfdGFnMEBAXCI6IFwiU3BlY2lmaWVzIHRoZSB0eXBlIG9mIHZlY3RvciBmaWVsZCB5b3VyIG91dHB1dCB3aWxsIHJlcHJlc2VudC5cIixcblx0XCJAQFZlY3Rvci1GaWVsZF9PdXRwdXQtRGF0YS1UeXBlX3RhZzFAQFwiOiBcIk1hZ25pdHVkZS1EaXJlY3Rpb24tLU91dHB1dCBkYXRhIHJlcHJlc2VudHMgbWFnbml0dWRlIGFuZCBkaXJlY3Rpb24uXCIsXG5cdFwiQEBWZWN0b3ItRmllbGRfT3V0cHV0LURhdGEtVHlwZV90YWcyQEBcIjogXCJVLVYtLU91dHB1dCBkYXRhIHJlcHJlc2VudHMgVSBhbmQgViBjb21wb25lbnRzLlwiLFxuXHRcIkBAVmVjdG9yLUZpZWxkX1Jhc3RlcjFfdGFnMEBAXCI6IFwiVGhlIGZpcnN0IGlucHV0IHJhc3Rlci5cIixcblx0XCJAQFZlY3Rvci1GaWVsZF9SYXN0ZXIxX3RhZzFAQFwiOiBcIlRoaXMgd2lsbCBlaXRoZXIgYmUgdGhlIFUgdmFsdWUgb3IgdGhlIG1hZ25pdHVkZS5cIixcblx0XCJAQFZlY3Rvci1GaWVsZF9SYXN0ZXIyX3RhZzBAQFwiOiBcIlRoZSBzZWNvbmQgaW5wdXQgcmFzdGVyLlwiLFxuXHRcIkBAVmVjdG9yLUZpZWxkX1Jhc3RlcjJfdGFnMUBAXCI6IFwiVGhpcyB3aWxsIGVpdGhlciBiZSB0aGUgViB2YWx1ZSBvciB0aGUgZGlyZWN0aW9uLlwiLFxuXHRcIkBAVmlld3NoZWRfQW5hbHlzaXMtTWV0aG9kX3RhZzBAQFwiOiBcIkNob29zZSB0aGUgbWV0aG9kIGJ5IHdoaWNoIHRoZSB2aXNpYmlsaXR5IHdpbGwgYmUgY2FsY3VsYXRlZC4gVGhpcyBvcHRpb24gYWxsb3dzIHlvdSB0byB0cmFkZSBzb21lIGFjY3VyYWN5IGZvciBpbmNyZWFzZWQgcGVyZm9ybWFuY2UuXCIsXG5cdFwiQEBWaWV3c2hlZF9BbmFseXNpcy1NZXRob2RfdGFnMUBAXCI6IFwiQWxsIFNpZ2h0bGluZXMtLUEgc2lnaHRsaW5lIGlzIHBlcmZvcm1lZCBvbiBldmVyeSBwaXhlbCBpbiB0aGUgcmFzdGVyIGluIG9yZGVyIHRvIGVzdGFibGlzaCB2aXNpYmxlIGFyZWFzLiBUaGlzIGlzIHRoZSBkZWZhdWx0IG1ldGhvZC5cIixcblx0XCJAQFZpZXdzaGVkX0FuYWx5c2lzLU1ldGhvZF90YWcyQEBcIjogXCJQZXJpbWV0ZXIgU2lnaHRsaW5lcy0tU2lnaHRsaW5lcyBhcmUgb25seSBwZXJmb3JtZWQgdG8gdGhlIHBpeGVscyBvbiB0aGUgcGVyaW1ldGVyIG9mIHRoZSB2aXNpYmxlIGFyZWFzIGluIG9yZGVyIHRvIGVzdGFibGlzaCB2aXNpYmlsaXR5IGFyZWFzLiBUaGlzIG1ldGhvZCBoYXMgYSBiZXR0ZXIgcGVyZm9ybWFuY2UgdGhhbiB0aGUgPHN0cm9uZz5BbGwgU2lnaHRsaW5lczwvc3Ryb25nPiBtZXRob2Qgc2luY2UgbGVzcyBzaWdodGxpbmVzIGFyZSBpbiB0aGUgY2FsY3VsYXRpb24uXCIsXG5cdFwiQEBWaWV3c2hlZF9BbmFseXNpcy1UeXBlX3RhZzBAQFwiOiBcIkNob29zZSB3aGljaCB0eXBlIG9mIHZpc2liaWxpdHkgYW5hbHlzaXMgeW91IHdpc2ggdG8gcGVyZm9ybSwgZWl0aGVyIGRldGVybWluaW5nIGhvdyB2aXNpYmxlIGVhY2ggY2VsbCBpcyB0byB0aGUgb2JzZXJ2ZXJzLCBvciBpZGVudGlmeWluZyBmb3IgZWFjaCBzdXJmYWNlIGxvY2F0aW9uIHdoaWNoIG9ic2VydmVycyBhcmUgdmlzaWJsZS5cIixcblx0XCJAQFZpZXdzaGVkX0FuYWx5c2lzLVR5cGVfdGFnMUBAXCI6IFwiRnJlcXVlbmN5LS1UaGUgbnVtYmVyIG9mIHRpbWVzIHRoYXQgZWFjaCBwaXhlbCBsb2NhdGlvbiBpbiB0aGUgaW5wdXQgc3VyZmFjZSByYXN0ZXIgY2FuIGJlIHNlZW4gYnkgdGhlIGlucHV0IG9ic2VydmF0aW9uIGxvY2F0aW9ucyAoYXMgcG9pbnRzIG9yIGFzIHZlcnRpY2VzIGZvciBwb2x5bGluZSBvYnNlcnZlciBmZWF0dXJlcykuIFRoaXMgaXMgdGhlIGRlZmF1bHQuXCIsXG5cdFwiQEBWaWV3c2hlZF9BbmFseXNpcy1UeXBlX3RhZzJAQFwiOiBcIk9ic2VydmVycy0tVGhlIG91dHB1dCBpZGVudGlmaWVzIGV4YWN0bHkgd2hpY2ggb2JzZXJ2ZXIgcG9pbnRzIGFyZSB2aXNpYmxlIGZyb20gZWFjaCByYXN0ZXIgc3VyZmFjZSBsb2NhdGlvbi4gVGhlIGFsbG93ZWQgbWF4aW11bSBudW1iZXIgb2YgaW5wdXQgb2JzZXJ2ZXJzIGlzIDMyIHdpdGggdGhpcyBhbmFseXNpcyB0eXBlLlwiLFxuXHRcIkBAVmlld3NoZWRfSG9yaXpvbnRhbC1FbmQtQW5nbGVfdGFnMEBAXCI6IFwiVGhpcyB2YWx1ZSBkZWZpbmVzIHRoZSBlbmQgYW5nbGUgb2YgdGhlIGhvcml6b250YWwgc2NhbiByYW5nZS4gVGhlIHZhbHVlIHNob3VsZCBiZSBzcGVjaWZpZWQgaW4gZGVncmVlcyBmcm9tIDAgdG8gMzYwLjAsIHdoZXJlIDAgaXMgb3JpZW50ZWQgdG8gbm9ydGguIFRoZSBkZWZhdWx0IHZhbHVlIGlzIDM2MC4wLlwiLFxuXHRcIkBAVmlld3NoZWRfSG9yaXpvbnRhbC1FbmQtQW5nbGVfdGFnMUBAXCI6IFwiSXQgY2FuIGJlIGEgZmllbGQgaW4gdGhlIGlucHV0IDxzdHJvbmc+T2JzZXJ2ZXIgRmVhdHVyZXM8L3N0cm9uZz4gZGF0YXNldCBvciBhIG51bWVyaWNhbCB2YWx1ZS4gSWYgdGhpcyBwYXJhbWV0ZXIgaXMgc2V0IHRvIGEgdmFsdWUsIHRoYXQgdmFsdWUgd2lsbCBiZSBhcHBsaWVkIHRvIGFsbCB0aGUgb2JzZXJ2ZXJzLiBUbyBzcGVjaWZ5IGRpZmZlcmVudCB2YWx1ZXMgZm9yIGVhY2ggb2JzZXJ2ZXIsIHNldCB0aGlzIHBhcmFtZXRlciB0byBhIGZpZWxkIGluIHRoZSA8c3Ryb25nPk9ic2VydmVyIEZlYXR1cmVzPC9zdHJvbmc+IGRhdGFzZXQuXCIsXG5cdFwiQEBWaWV3c2hlZF9Ib3Jpem9udGFsLVN0YXJ0LUFuZ2xlX3RhZzBAQFwiOiBcIlRoaXMgdmFsdWUgZGVmaW5lcyB0aGUgc3RhcnQgYW5nbGUgb2YgdGhlIGhvcml6b250YWwgc2NhbiByYW5nZS4gVGhlIHZhbHVlIHNob3VsZCBiZSBzcGVjaWZpZWQgaW4gZGVncmVlcyBmcm9tIDAgdG8gMzYwLjAsIHdoZXJlIDAgaXMgb3JpZW50ZWQgdG8gbm9ydGguIFRoZSBkZWZhdWx0IHZhbHVlIGlzIDAuXCIsXG5cdFwiQEBWaWV3c2hlZF9Ib3Jpem9udGFsLVN0YXJ0LUFuZ2xlX3RhZzFAQFwiOiBcIkl0IGNhbiBiZSBhIGZpZWxkIGluIHRoZSBpbnB1dCA8c3Ryb25nPk9ic2VydmVyIEZlYXR1cmVzPC9zdHJvbmc+IGRhdGFzZXQgb3IgYSBudW1lcmljYWwgdmFsdWUuIElmIHRoaXMgcGFyYW1ldGVyIGlzIHNldCB0byBhIHZhbHVlLCB0aGF0IHZhbHVlIHdpbGwgYmUgYXBwbGllZCB0byBhbGwgdGhlIG9ic2VydmVycy4gVG8gc3BlY2lmeSBkaWZmZXJlbnQgdmFsdWVzIGZvciBlYWNoIG9ic2VydmVyLCBzZXQgdGhpcyBwYXJhbWV0ZXIgdG8gYSBmaWVsZCBpbiB0aGUgPHN0cm9uZz5PYnNlcnZlciBGZWF0dXJlczwvc3Ryb25nPiBkYXRhc2V0LlwiLFxuXHRcIkBAVmlld3NoZWRfSW5uZXItUmFkaXVzLWlzLTNELURpc3RhbmNlX3RhZzBAQFwiOiBcIlR5cGUgb2YgZGlzdGFuY2UgZm9yIHRoZSBpbm5lciByYWRpdXMgcGFyYW1ldGVyLlwiLFxuXHRcIkBAVmlld3NoZWRfSW5uZXItUmFkaXVzLWlzLTNELURpc3RhbmNlX3RhZzFAQFwiOiBcIlVuY2hlY2tlZC0tPHN0cm9uZz5Jbm5lciBSYWRpdXM8L3N0cm9uZz4gaXMgdG8gYmUgaW50ZXJwcmV0ZWQgYXMgYSAyRCBkaXN0YW5jZS4gVGhpcyBpcyB0aGUgZGVmYXVsdC5cIixcblx0XCJAQFZpZXdzaGVkX0lubmVyLVJhZGl1cy1pcy0zRC1EaXN0YW5jZV90YWc0QEBcIjogXCJDaGVja2VkLS08c3Ryb25nPklubmVyIFJhZGl1czwvc3Ryb25nPiBpcyB0byBiZSBpbnRlcnByZXRlZCBhcyBhIDNEIGRpc3RhbmNlLlwiLFxuXHRcIkBAVmlld3NoZWRfSW5uZXItUmFkaXVzX3RhZzBAQFwiOiBcIlRoaXMgdmFsdWUgZGVmaW5lcyB0aGUgc3RhcnQgKG1pbmltdW0pIGRpc3RhbmNlIGZyb20gd2hpY2ggdmlzaWJpbGl0eSBpcyBkZXRlcm1pbmVkLiBQaXhlbHMgY2xvc2VyIHRoYW4gdGhpcyBkaXN0YW5jZSBhcmUgY29uc2lkZXJlZCBub3QgdmlzaWJsZSBpbiB0aGUgb3V0cHV0IGJ1dCBjYW4gc3RpbGwgYmxvY2sgdmlzaWJpbGl0eSBvZiB0aGUgcGl4ZWxzIGJldHdlZW4gdGhlIDxzdHJvbmc+SW5uZXIgUmFkaXVzPC9zdHJvbmc+IGFuZCB0aGUgPHN0cm9uZz5PdXRlciBSYWRpdXM8L3N0cm9uZz4uIFRoZSBkZWZhdWx0IHZhbHVlIGlzIDAuXCIsXG5cdFwiQEBWaWV3c2hlZF9Jbm5lci1SYWRpdXNfdGFnNUBAXCI6IFwiSXQgY2FuIGJlIGEgZmllbGQgaW4gdGhlIGlucHV0IDxzdHJvbmc+T2JzZXJ2ZXIgRmVhdHVyZXM8L3N0cm9uZz4gZGF0YXNldCBvciBhIG51bWVyaWNhbCB2YWx1ZS4gSWYgdGhpcyBwYXJhbWV0ZXIgaXMgc2V0IHRvIGEgdmFsdWUsIHRoYXQgdmFsdWUgd2lsbCBiZSBhcHBsaWVkIHRvIGFsbCB0aGUgb2JzZXJ2ZXJzLiBUbyBzcGVjaWZ5IGRpZmZlcmVudCB2YWx1ZXMgZm9yIGVhY2ggb2JzZXJ2ZXIsIHNldCB0aGlzIHBhcmFtZXRlciB0byBhIGZpZWxkIGluIHRoZSA8c3Ryb25nPk9ic2VydmVyIEZlYXR1cmVzPC9zdHJvbmc+IGRhdGFzZXQuXCIsXG5cdFwiQEBWaWV3c2hlZF9PYnNlcnZlci1FbGV2YXRpb25fdGFnMEBAXCI6IFwiVGhpcyB2YWx1ZSBpcyB1c2VkIHRvIGRlZmluZSB0aGUgc3VyZmFjZSBlbGV2YXRpb25zIG9mIHRoZSBvYnNlcnZlciBwb2ludHMgb3IgdmVydGljZXMuXCIsXG5cdFwiQEBWaWV3c2hlZF9PYnNlcnZlci1FbGV2YXRpb25fdGFnMUBAXCI6IFwiSXQgY2FuIGJlIGEgZmllbGQgaW4gdGhlIGlucHV0IDxzdHJvbmc+T2JzZXJ2ZXIgRmVhdHVyZXM8L3N0cm9uZz4gZGF0YXNldCBvciBhIG51bWVyaWNhbCB2YWx1ZS4gSWYgdGhpcyBwYXJhbWV0ZXIgaXMgbm90IHNwZWNpZmllZCwgdGhlIG9ic2VydmVyIGVsZXZhdGlvbiB3aWxsIGJlIG9idGFpbmVkIGZyb20gdGhlIHN1cmZhY2UgcmFzdGVyIHVzaW5nIGJpbGluZWFyIGludGVycG9sYXRpb24uIElmIHRoaXMgcGFyYW1ldGVyIGlzIHNldCB0byBhIHZhbHVlLCB0aGVuIHRoYXQgdmFsdWUgd2lsbCBiZSBhcHBsaWVkIHRvIGFsbCB0aGUgb2JzZXJ2ZXJzLiBUbyBzcGVjaWZ5IGRpZmZlcmVudCB2YWx1ZXMgZm9yIGVhY2ggb2JzZXJ2ZXIsIHNldCB0aGlzIHBhcmFtZXRlciB0byBhIGZpZWxkIGluIHRoZSA8c3Ryb25nPk9ic2VydmVyIEZlYXR1cmVzPC9zdHJvbmc+IGRhdGFzZXQuXCIsXG5cdFwiQEBWaWV3c2hlZF9PYnNlcnZlci1GZWF0dXJlc190YWcwQEBcIjogXCJUaGUgcmVxdWlyZWQgaW5wdXQgZmVhdHVyZSBjbGFzcyB0aGF0IGlkZW50aWZpZXMgdGhlIG9ic2VydmVyIGxvY2F0aW9ucy4gSXQgY2FuIGJlIHBvaW50LCBtdWx0aXBvaW50LCBvciBwb2x5bGluZSBmZWF0dXJlcy5cIixcblx0XCJAQFZpZXdzaGVkX09ic2VydmVyLUZlYXR1cmVzX3RhZzFAQFwiOiBcIlRoZSBpbnB1dCBmZWF0dXJlIGNsYXNzIGlzIHRyYW5zZm9ybWVkIGludG8gYSAzRCBnZW9jZW50cmljIGNvb3JkaW5hdGUgc3lzdGVtIGR1cmluZyB0aGUgdmlzaWJpbGl0eSBjYWxjdWxhdGlvbi4gT2JzZXJ2ZXJzIG91dHNpZGUgb2YgdGhlIGV4dGVudCBvZiB0aGUgc3VyZmFjZSByYXN0ZXIsIG9yIGxvY2F0ZWQgb24gTm9EYXRhIGNlbGxzLCB3aWxsIGJlIGlnbm9yZWQgaW4gdGhlIGNhbGN1bGF0aW9uLlwiLFxuXHRcIkBAVmlld3NoZWRfT2JzZXJ2ZXItT2Zmc2V0X3RhZzBAQFwiOiBcIlRoaXMgdmFsdWUgaW5kaWNhdGVzIGEgdmVydGljYWwgZGlzdGFuY2UgKGluIHN1cmZhY2UgdW5pdHMpIHRvIGJlIGFkZGVkIHRvIG9ic2VydmVyIGVsZXZhdGlvbi4gSXQgc2hvdWxkIGJlIGEgcG9zaXRpdmUgaW50ZWdlciBvciBmbG9hdGluZy1wb2ludCB2YWx1ZS5cIixcblx0XCJAQFZpZXdzaGVkX09ic2VydmVyLU9mZnNldF90YWcxQEBcIjogXCJJdCBjYW4gYmUgYSBmaWVsZCBpbiB0aGUgaW5wdXQgPHN0cm9uZz5PYnNlcnZlciBGZWF0dXJlczwvc3Ryb25nPiBkYXRhc2V0IG9yIGEgbnVtZXJpY2FsIHZhbHVlLiBJZiB0aGlzIHBhcmFtZXRlciBpcyBzZXQgdG8gYSB2YWx1ZSwgdGhhdCB2YWx1ZSB3aWxsIGJlIGFwcGxpZWQgdG8gYWxsIHRoZSBvYnNlcnZlcnMuIFRvIHNwZWNpZnkgZGlmZmVyZW50IHZhbHVlcyBmb3IgZWFjaCBvYnNlcnZlciwgc2V0IHRoaXMgcGFyYW1ldGVyIHRvIGEgZmllbGQgaW4gdGhlIDxzdHJvbmc+T2JzZXJ2ZXIgRmVhdHVyZXM8L3N0cm9uZz4gZGF0YXNldC5cIixcblx0XCJAQFZpZXdzaGVkX091dGVyLVJhZGl1cy1pcy0zRC1EaXN0YW5jZV90YWcwQEBcIjogXCJUeXBlIG9mIGRpc3RhbmNlIGZvciB0aGUgb3V0ZXIgcmFkaXVzIHBhcmFtZXRlci5cIixcblx0XCJAQFZpZXdzaGVkX091dGVyLVJhZGl1cy1pcy0zRC1EaXN0YW5jZV90YWcxQEBcIjogXCJVbmNoZWNrZWQtLTxzdHJvbmc+T3V0ZXIgUmFkaXVzPC9zdHJvbmc+IGlzIHRvIGJlIGludGVycHJldGVkIGFzIGEgMkQgZGlzdGFuY2UuIFRoaXMgaXMgdGhlIGRlZmF1bHQuXCIsXG5cdFwiQEBWaWV3c2hlZF9PdXRlci1SYWRpdXMtaXMtM0QtRGlzdGFuY2VfdGFnNEBAXCI6IFwiQ2hlY2tlZC0tPHN0cm9uZz5PdXRlciBSYWRpdXM8L3N0cm9uZz4gaXMgdG8gYmUgaW50ZXJwcmV0ZWQgYXMgYSAzRCBkaXN0YW5jZS5cIixcblx0XCJAQFZpZXdzaGVkX091dGVyLVJhZGl1c190YWcwQEBcIjogXCJUaGlzIHZhbHVlIGRlZmluZXMgdGhlIG1heGltdW0gZGlzdGFuY2UgZnJvbSB3aGljaCB2aXNpYmlsaXR5IGlzIGRldGVybWluZWQuIFBpeGVscyBiZXlvbmQgdGhpcyBkaXN0YW5jZSBhcmUgZXhjbHVkZWQgZnJvbSB0aGUgYW5hbHlzaXMuXCIsXG5cdFwiQEBWaWV3c2hlZF9PdXRlci1SYWRpdXNfdGFnMUBAXCI6IFwiSXQgY2FuIGJlIGEgZmllbGQgaW4gdGhlIGlucHV0IDxzdHJvbmc+T2JzZXJ2ZXIgRmVhdHVyZXM8L3N0cm9uZz4gZGF0YXNldCBvciBhIG51bWVyaWNhbCB2YWx1ZS4gSWYgdGhpcyBwYXJhbWV0ZXIgaXMgc2V0IHRvIGEgdmFsdWUsIHRoYXQgdmFsdWUgd2lsbCBiZSBhcHBsaWVkIHRvIGFsbCB0aGUgb2JzZXJ2ZXJzLiBUbyBzcGVjaWZ5IGRpZmZlcmVudCB2YWx1ZXMgZm9yIGVhY2ggb2JzZXJ2ZXIsIHNldCB0aGlzIHBhcmFtZXRlciB0byBhIGZpZWxkIGluIHRoZSA8c3Ryb25nPk9ic2VydmVyIEZlYXR1cmVzPC9zdHJvbmc+IGRhdGFzZXQuXCIsXG5cdFwiQEBWaWV3c2hlZF9SYXN0ZXJfdGFnMEBAXCI6IFwiVGhlIHJlcXVpcmVkIGlucHV0IHN1cmZhY2UgcmFzdGVyLiBJdCBjYW4gYmUgYW4gaW50ZWdlciBvciBhIGZsb2F0aW5nLXBvaW50IHJhc3Rlci5cIixcblx0XCJAQFZpZXdzaGVkX1Jhc3Rlcl90YWcxQEBcIjogXCJUaGUgaW5wdXQgaXMgdHJhbnNmb3JtZWQgaW50byBhIDNEIGdlb2NlbnRyaWMgY29vcmRpbmF0ZSBzeXN0ZW0gZHVyaW5nIHRoZSB2aXNpYmlsaXR5IGNhbGN1bGF0aW9uLiBOb0RhdGEgY2VsbHMgb24gdGhlIGlucHV0IHJhc3RlciBkbyBub3QgYmxvY2sgdGhlIHZpc2liaWxpdHkgZGV0ZXJtaW5hdGlvbi5cIixcblx0XCJAQFZpZXdzaGVkX1JlZnJhY3RpdmUtQ29lZmZpY2llbnRfdGFnMEBAXCI6IFwiQ29lZmZpY2llbnQgb2YgdGhlIHJlZnJhY3Rpb24gb2YgdmlzaWJsZSBsaWdodCBpbiBhaXIuXCIsXG5cdFwiQEBWaWV3c2hlZF9SZWZyYWN0aXZlLUNvZWZmaWNpZW50X3RhZzFAQFwiOiBcIlRoZSBkZWZhdWx0IHZhbHVlIGlzIDAuMTMuXCIsXG5cdFwiQEBWaWV3c2hlZF9TdXJmYWNlLU9mZnNldF90YWcwQEBcIjogXCJUaGlzIHZhbHVlIGluZGljYXRlcyBhIHZlcnRpY2FsIGRpc3RhbmNlIChpbiBzdXJmYWNlIHVuaXRzKSB0byBiZSBhZGRlZCB0byB0aGUgei12YWx1ZSBvZiBlYWNoIHRhcmdldCBwaXhlbCBhcyBpdCBpcyBjb25zaWRlcmVkIGZvciB2aXNpYmlsaXR5LiBJdCBzaG91bGQgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyIG9yIGZsb2F0aW5nLXBvaW50IHZhbHVlLlwiLFxuXHRcIkBAVmlld3NoZWRfU3VyZmFjZS1PZmZzZXRfdGFnMUBAXCI6IFwiSXQgY2FuIGJlIGEgZmllbGQgaW4gdGhlIGlucHV0IDxzdHJvbmc+T2JzZXJ2ZXIgRmVhdHVyZXM8L3N0cm9uZz4gZGF0YXNldCBvciBhIG51bWVyaWNhbCB2YWx1ZS4gSWYgdGhpcyBwYXJhbWV0ZXIgaXMgc2V0IHRvIGEgdmFsdWUsIHRoYXQgdmFsdWUgd2lsbCBiZSBhcHBsaWVkIHRvIGFsbCB0aGUgb2JzZXJ2ZXJzLiBUbyBzcGVjaWZ5IGRpZmZlcmVudCB2YWx1ZXMgZm9yIGVhY2ggb2JzZXJ2ZXIsIHNldCB0aGlzIHBhcmFtZXRlciB0byBhIGZpZWxkIGluIHRoZSA8c3Ryb25nPk9ic2VydmVyIEZlYXR1cmVzPC9zdHJvbmc+IGRhdGFzZXQuXCIsXG5cdFwiQEBWaWV3c2hlZF9WZXJ0aWNhbC1FcnJvcl90YWcwQEBcIjogXCJUaGUgYW1vdW50IG9mIHVuY2VydGFpbnR5LCBtZWFzdXJlZCBhcyBSb290IE1lYW4gU3F1YXJlIGVycm9yIChSTVNFKSwgaW4gdGhlIHN1cmZhY2UgZWxldmF0aW9uIHZhbHVlcy4gSXQgaXMgYSBmbG9hdGluZy1wb2ludCB2YWx1ZSByZXByZXNlbnRpbmcgdGhlIGV4cGVjdGVkIGVycm9yIG9mIHRoZSBpbnB1dCBlbGV2YXRpb24gdmFsdWVzLiBXaGVuIHRoaXMgcGFyYW1ldGVyIGlzIGFzc2lnbmVkIGEgdmFsdWUgZ3JlYXRlciB0aGFuIDAsIHRoZSBvdXRwdXQgdmlzaWJpbGl0eSByYXN0ZXIgd2lsbCBiZSBmbG9hdGluZyBwb2ludC4gSW4gdGhpcyBjYXNlLCBlYWNoIHBpeGVsIHZhbHVlIG9uIHRoZSBvdXRwdXQgdmlzaWJpbGl0eSByYXN0ZXIgcmVwcmVzZW50cyB0aGUgc3VtIG9mIHByb2JhYmlsaXRpZXMgdGhhdCB0aGUgY2VsbCBpcyB2aXNpYmxlIHRvIGFueSBvZiB0aGUgb2JzZXJ2ZXJzLlwiLFxuXHRcIkBAVmlld3NoZWRfVmVydGljYWwtRXJyb3JfdGFnMUBAXCI6IFwiV2hlbiB0aGUgPHN0cm9uZz5BbmFseXNpcyBUeXBlPC9zdHJvbmc+IGlzIDxzdHJvbmc+T2JzZXJ2ZXJzPC9zdHJvbmc+IG9yIHRoZSA8c3Ryb25nPkFuYWx5c2lzIE1ldGhvZDwvc3Ryb25nPiBpcyA8c3Ryb25nPlBlcmltZXRlciBTaWdodGxpbmVzPC9zdHJvbmc+LCB0aGlzIHBhcmFtZXRlciBpcyBkaXNhYmxlZC5cIixcblx0XCJAQFZpZXdzaGVkX1ZlcnRpY2FsLUxvd2VyLUFuZ2xlX3RhZzBAQFwiOiBcIlRoaXMgdmFsdWUgZGVmaW5lcyB0aGUgbG93ZXIgdmVydGljYWwgYW5nbGUgbGltaXQgb2YgdGhlIHNjYW4gYmVsb3cgYSBob3Jpem9udGFsIHBsYW5lLiBUaGUgdmFsdWUgc2hvdWxkIGJlIHNwZWNpZmllZCBpbiBkZWdyZWVzIGZyb20gLTkwLjAgdG8gMCwgd2hpY2ggY2FuIGJlIGludGVnZXIgb3IgZmxvYXRpbmcgcG9pbnQuIFRoZSBkZWZhdWx0IHZhbHVlIGlzIC05MC4wLlwiLFxuXHRcIkBAVmlld3NoZWRfVmVydGljYWwtTG93ZXItQW5nbGVfdGFnMUBAXCI6IFwiSXQgY2FuIGJlIGEgZmllbGQgaW4gdGhlIGlucHV0IDxzdHJvbmc+T2JzZXJ2ZXIgRmVhdHVyZXM8L3N0cm9uZz4gZGF0YXNldCBvciBhIG51bWVyaWNhbCB2YWx1ZS4gSWYgdGhpcyBwYXJhbWV0ZXIgaXMgc2V0IHRvIGEgdmFsdWUsIHRoYXQgdmFsdWUgd2lsbCBiZSBhcHBsaWVkIHRvIGFsbCB0aGUgb2JzZXJ2ZXJzLiBUbyBzcGVjaWZ5IGRpZmZlcmVudCB2YWx1ZXMgZm9yIGVhY2ggb2JzZXJ2ZXIsIHNldCB0aGlzIHBhcmFtZXRlciB0byBhIGZpZWxkIGluIHRoZSA8c3Ryb25nPk9ic2VydmVyIEZlYXR1cmVzPC9zdHJvbmc+IGRhdGFzZXQuXCIsXG5cdFwiQEBWaWV3c2hlZF9WZXJ0aWNhbC1VcHBlci1BbmdsZV90YWcwQEBcIjogXCJUaGlzIHZhbHVlIGRlZmluZXMgdGhlIHVwcGVyIHZlcnRpY2FsIGFuZ2xlIGxpbWl0IG9mIHRoZSBzY2FuIGFib3ZlIGEgaG9yaXpvbnRhbCBwbGFuZS4gVGhlIHZhbHVlIHNob3VsZCBiZSBzcGVjaWZpZWQgaW4gZGVncmVlcyBmcm9tIDAgdG8gOTAuMCwgd2hpY2ggY2FuIGJlIGludGVnZXIgb3IgZmxvYXRpbmcgcG9pbnQuIFRoZSBkZWZhdWx0IHZhbHVlIGlzIDkwLjAuXCIsXG5cdFwiQEBWaWV3c2hlZF9WZXJ0aWNhbC1VcHBlci1BbmdsZV90YWcxQEBcIjogXCJJdCBjYW4gYmUgYSBmaWVsZCBpbiB0aGUgaW5wdXQgPHN0cm9uZz5PYnNlcnZlciBGZWF0dXJlczwvc3Ryb25nPiBkYXRhc2V0IG9yIGEgbnVtZXJpY2FsIHZhbHVlLiBJZiB0aGlzIHBhcmFtZXRlciBpcyBzZXQgdG8gYSB2YWx1ZSwgdGhhdCB2YWx1ZSB3aWxsIGJlIGFwcGxpZWQgdG8gYWxsIHRoZSBvYnNlcnZlcnMuIFRvIHNwZWNpZnkgZGlmZmVyZW50IHZhbHVlcyBmb3IgZWFjaCBvYnNlcnZlciwgc2V0IHRoaXMgcGFyYW1ldGVyIHRvIGEgZmllbGQgaW4gdGhlIDxzdHJvbmc+T2JzZXJ2ZXIgRmVhdHVyZXM8L3N0cm9uZz4gZGF0YXNldC5cIixcblx0XCJAQFdhdGVyc2hlZF9GbG93LURpcmVjdGlvbi1SYXN0ZXJfdGFnMEBAXCI6IFwiVGhlIGlucHV0IHJhc3RlciB0aGF0IHNob3dzIHRoZSBkaXJlY3Rpb24gb2YgZmxvdyBvdXQgb2YgZWFjaCBjZWxsLlwiLFxuXHRcIkBAV2F0ZXJzaGVkX0Zsb3ctRGlyZWN0aW9uLVJhc3Rlcl90YWcxQEBcIjogXCJUaGUgZmxvdyBkaXJlY3Rpb24gcmFzdGVyIGNhbiBiZSBjcmVhdGVkIGJ5IHJ1bm5pbmcgdGhlIDxzdHJvbmc+RmxvdyBEaXJlY3Rpb248L3N0cm9uZz4gZnVuY3Rpb24uXCIsXG5cdFwiQEBXYXRlcnNoZWRfUG91ci1Qb2ludChzKS1SYXN0ZXJfdGFnMEBAXCI6IFwiVGhlIGlucHV0IHBvdXIgcG9pbnQgbG9jYXRpb25zLlwiLFxuXHRcIkBAV2F0ZXJzaGVkX1BvdXItUG9pbnQocyktUmFzdGVyX3RhZzFAQFwiOiBcIlRoaXMgcmFzdGVyIHJlcHJlc2VudHMgY2VsbHMgYWJvdmUgd2hpY2ggdGhlIGNvbnRyaWJ1dGluZyBhcmVhLCBvciBjYXRjaG1lbnQsIHdpbGwgYmUgZGV0ZXJtaW5lZC4gQWxsIGNlbGxzIHRoYXQgYXJlIG5vdCBOb0RhdGEgd2lsbCBiZSB1c2VkIGFzIHNvdXJjZSBjZWxscy5cIixcblx0XCJAQFdhdGVyc2hlZF9Qb3VyLVBvaW50LUZpZWxkX3RhZzBAQFwiOiBcIkZpZWxkIHVzZWQgdG8gYXNzaWduIHZhbHVlcyB0byB0aGUgcG91ciBwb2ludCBsb2NhdGlvbnMuXCIsXG5cdFwiQEBXYXRlcnNoZWRfUG91ci1Qb2ludC1GaWVsZF90YWcxQEBcIjogXCJGb3IgYSByYXN0ZXIgcG91ciBwb2ludCBkYXRhc2V0LCAke1ZhbHVlfSBpcyB1c2VkIGJ5IGRlZmF1bHQuXCIsXG5cdFwiQEBXZWlnaHRlZC1PdmVybGF5X0NlbGxzaXplLVR5cGVfdGFnMEBAXCI6IFwiQ2hvb3NlIHdoaWNoIGNlbGwgc2l6ZSB0byB1c2UgaW4gdGhlIG91dHB1dCByYXN0ZXIuIElmIGFsbCB0aGUgaW5wdXQgY2VsbCBzaXplcyBhcmUgdGhlIHNhbWUsIGFsbCB0aGUgb3B0aW9ucyB3aWxsIHlpZWxkIHRoZSBzYW1lIHJlc3VsdHMuXCIsXG5cdFwiQEBXZWlnaHRlZC1PdmVybGF5X0NlbGxzaXplLVR5cGVfdGFnMUBAXCI6IFwiRmlyc3QgT2YtLVVzZSB0aGUgZmlyc3QgY2VsbCBzaXplIG9mIHRoZSBpbnB1dCByYXN0ZXJzLlwiLFxuXHRcIkBAV2VpZ2h0ZWQtT3ZlcmxheV9DZWxsc2l6ZS1UeXBlX3RhZzJAQFwiOiBcIk1pbiBPZi0tVXNlIHRoZSBzbWFsbGVzdCBjZWxsIHNpemUgb2YgYWxsIHRoZSBpbnB1dCByYXN0ZXJzLlwiLFxuXHRcIkBAV2VpZ2h0ZWQtT3ZlcmxheV9DZWxsc2l6ZS1UeXBlX3RhZzNAQFwiOiBcIk1heCBPZi0tVXNlIHRoZSBsYXJnZXN0IGNlbGwgc2l6ZSBvZiBhbGwgdGhlIGlucHV0IHJhc3RlcnMuIFRoaXMgaXMgdGhlIGRlZmF1bHQuXCIsXG5cdFwiQEBXZWlnaHRlZC1PdmVybGF5X0NlbGxzaXplLVR5cGVfdGFnNEBAXCI6IFwiTWVhbiBPZi0tVXNlIHRoZSBtZWFuIGNlbGwgc2l6ZSBvZiBhbGwgdGhlIGlucHV0IHJhc3RlcnMuXCIsXG5cdFwiQEBXZWlnaHRlZC1PdmVybGF5X0NlbGxzaXplLVR5cGVfdGFnNUBAXCI6IFwiTGFzdCBPZi0tVXNlIHRoZSBsYXN0IGNlbGwgc2l6ZSBvZiB0aGUgaW5wdXQgcmFzdGVycy5cIixcblx0XCJAQFdlaWdodGVkLU92ZXJsYXlfRXh0ZW50LVR5cGVfdGFnMEBAXCI6IFwiQ2hvb3NlIHdoaWNoIGV4dGVudCBzaG91bGQgYmUgdXNlZCBpbiB0aGUgb3V0cHV0IHJhc3RlcjpcIixcblx0XCJAQFdlaWdodGVkLU92ZXJsYXlfRXh0ZW50LVR5cGVfdGFnMUBAXCI6IFwiRmlyc3QgT2YtLVVzZSB0aGUgZXh0ZW50IG9mIHRoZSBmaXJzdCBpbnB1dCByYXN0ZXIgdG8gZGV0ZXJtaW5lIHRoZSBwcm9jZXNzaW5nIGV4dGVudC5cIixcblx0XCJAQFdlaWdodGVkLU92ZXJsYXlfRXh0ZW50LVR5cGVfdGFnMkBAXCI6IFwiSW50ZXJzZWN0aW9uIE9mLS1Vc2UgdGhlIGV4dGVudCBvZiB0aGUgb3ZlcmxhcHBpbmcgcGl4ZWxzIHRvIGRldGVybWluZSB0aGUgcHJvY2Vzc2luZyBleHRlbnQuIFRoaXMgaXMgdGhlIGRlZmF1bHQuXCIsXG5cdFwiQEBXZWlnaHRlZC1PdmVybGF5X0V4dGVudC1UeXBlX3RhZzNAQFwiOiBcIlVuaW9uIE9mLS1Vc2UgdGhlIGV4dGVudCBvZiBhbGwgdGhlIHJhc3RlcnMgdG8gZGV0ZXJtaW5lIHRoZSBwcm9jZXNzaW5nIGV4dGVudC5cIixcblx0XCJAQFdlaWdodGVkLU92ZXJsYXlfRXh0ZW50LVR5cGVfdGFnNEBAXCI6IFwiTGFzdCBPZi0tVXNlIHRoZSBleHRlbnQgb2YgdGhlIGxhc3QgaW5wdXQgcmFzdGVyIHRvIGRldGVybWluZSB0aGUgcHJvY2Vzc2luZyBleHRlbnQuXCIsXG5cdFwiQEBXZWlnaHRlZC1PdmVybGF5X1NjYWxlc190YWcwQEBcIjogXCJUaGUgcmFuZ2UgZm9yIHRoZSBuZXcgdmFsdWVzIGJ5IHdoaWNoIHRvIHJlbWFwIHRoZSBvbGQgdmFsdWVzLlwiLFxuXHRcIkBAV2VpZ2h0ZWQtT3ZlcmxheV9XZWlnaHRlZC1PdmVybGF5LVRhYmxlX3RhZzBAQFwiOiBcIlRoZSB3ZWlnaHRlZCBvdmVybGF5IHRhYmxlIGNvbnNpc3RzIG9mIGZvdXIgcGFydHM6XCIsXG5cdFwiQEBXZWlnaHRlZC1PdmVybGF5X1dlaWdodGVkLU92ZXJsYXktVGFibGVfdGFnMUBAXCI6IFwiTGF5ZXItLUFsbCBpbnB1dCByYXN0ZXJzIG11c3QgYmUgb2YgdHlwZSBpbnRlZ2VyLlwiLFxuXHRcIkBAV2VpZ2h0ZWQtT3ZlcmxheV9XZWlnaHRlZC1PdmVybGF5LVRhYmxlX3RhZzJAQFwiOiBcIkluZmx1ZW5jZS0tRWFjaCBpbnB1dCByYXN0ZXIgaXMgd2VpZ2h0ZWQgYWNjb3JkaW5nIHRvIGl0cyBpbXBvcnRhbmNlLCBvciBpdHMgaW5mbHVlbmNlLCBhcyBhIHJlbGF0aXZlIHBlcmNlbnRhZ2UuIFRoZSBzdW0gb2YgdGhlIHBlcmNlbnQgaW5mbHVlbmNlIHdlaWdodHMgbXVzdCBlcXVhbCAxMDAsIGFuZCBlYWNoIHdlaWdodCBtdXN0IGJlIHNwZWNpZmllZCBieSBpbnRlZ2VyIHZhbHVlcy5cIixcblx0XCJAQFdlaWdodGVkLU92ZXJsYXlfV2VpZ2h0ZWQtT3ZlcmxheS1UYWJsZV90YWczQEBcIjogXCJGaWVsZC0tQW4gaW50ZWdlciBvciBzdHJpbmcgZmllbGQgb24gdGhlIGlucHV0IHJhc3RlciB0byB1c2UgZm9yIHdlaWdodGluZy5cIixcblx0XCJAQFdlaWdodGVkLU92ZXJsYXlfV2VpZ2h0ZWQtT3ZlcmxheS1UYWJsZV90YWc0QEBcIjogXCJSZW1hcCBUYWJsZS0tRWFjaCB2YWx1ZSBpbiBhbiBpbnB1dCByYXN0ZXIgaXMgYXNzaWduZWQgYSBuZXcgc2NhbGUgdmFsdWUgYmFzZWQgb24gdGhlIHJlbWFwIHRhYmxlLiBUaGUgc2NhbGUgdmFsdWUgY2FuIGJlIGEgdmFsaWQgdmFsdWUgb3IgYSBOb0RhdGEgdmFsdWUuXCIsXG5cdFwiQEBXZWlnaHRlZC1TdW1fQ2VsbHNpemUtVHlwZV90YWcwQEBcIjogXCJDaG9vc2Ugd2hpY2ggY2VsbCBzaXplIHRvIHVzZSBpbiB0aGUgb3V0cHV0IHJhc3Rlci4gSWYgYWxsIHRoZSBpbnB1dCBjZWxsIHNpemVzIGFyZSB0aGUgc2FtZSwgYWxsIHRoZSBvcHRpb25zIHdpbGwgeWllbGQgdGhlIHNhbWUgcmVzdWx0cy5cIixcblx0XCJAQFdlaWdodGVkLVN1bV9DZWxsc2l6ZS1UeXBlX3RhZzFAQFwiOiBcIkZpcnN0IE9mLS1Vc2UgdGhlIGZpcnN0IGNlbGwgc2l6ZSBvZiB0aGUgaW5wdXQgcmFzdGVycy5cIixcblx0XCJAQFdlaWdodGVkLVN1bV9DZWxsc2l6ZS1UeXBlX3RhZzJAQFwiOiBcIkxhc3QgT2YtLVVzZSB0aGUgbGFzdCBjZWxsIHNpemUgb2YgdGhlIGlucHV0IHJhc3RlcnMuXCIsXG5cdFwiQEBXZWlnaHRlZC1TdW1fQ2VsbHNpemUtVHlwZV90YWczQEBcIjogXCJNYXggT2YtLVVzZSB0aGUgbGFyZ2VzdCBjZWxsIHNpemUgb2YgYWxsIHRoZSBpbnB1dCByYXN0ZXJzLiBUaGlzIGlzIHRoZSBkZWZhdWx0LlwiLFxuXHRcIkBAV2VpZ2h0ZWQtU3VtX0NlbGxzaXplLVR5cGVfdGFnNEBAXCI6IFwiTWVhbiBPZi0tVXNlIHRoZSBtZWFuIGNlbGwgc2l6ZSBvZiBhbGwgdGhlIGlucHV0IHJhc3RlcnMuXCIsXG5cdFwiQEBXZWlnaHRlZC1TdW1fQ2VsbHNpemUtVHlwZV90YWc1QEBcIjogXCJNaW4gT2YtLVVzZSB0aGUgc21hbGxlc3QgY2VsbCBzaXplIG9mIGFsbCB0aGUgaW5wdXQgcmFzdGVycy5cIixcblx0XCJAQFdlaWdodGVkLVN1bV9FeHRlbnQtVHlwZV90YWcwQEBcIjogXCJDaG9vc2Ugd2hpY2ggZXh0ZW50IHNob3VsZCBiZSB1c2VkIGluIHRoZSBvdXRwdXQgcmFzdGVyOlwiLFxuXHRcIkBAV2VpZ2h0ZWQtU3VtX0V4dGVudC1UeXBlX3RhZzFAQFwiOiBcIkZpcnN0IE9mLS1Vc2UgdGhlIGV4dGVudCBvZiB0aGUgZmlyc3QgaW5wdXQgcmFzdGVyIHRvIGRldGVybWluZSB0aGUgcHJvY2Vzc2luZyBleHRlbnQuXCIsXG5cdFwiQEBXZWlnaHRlZC1TdW1fRXh0ZW50LVR5cGVfdGFnMkBAXCI6IFwiSW50ZXJzZWN0aW9uIE9mLS1Vc2UgdGhlIGV4dGVudCBvZiB0aGUgb3ZlcmxhcHBpbmcgcGl4ZWxzIHRvIGRldGVybWluZSB0aGUgcHJvY2Vzc2luZyBleHRlbnQuIFRoaXMgaXMgdGhlIGRlZmF1bHQuXCIsXG5cdFwiQEBXZWlnaHRlZC1TdW1fRXh0ZW50LVR5cGVfdGFnM0BAXCI6IFwiTGFzdCBPZi0tVXNlIHRoZSBleHRlbnQgb2YgdGhlIGxhc3QgaW5wdXQgcmFzdGVyIHRvIGRldGVybWluZSB0aGUgcHJvY2Vzc2luZyBleHRlbnQuXCIsXG5cdFwiQEBXZWlnaHRlZC1TdW1fRXh0ZW50LVR5cGVfdGFnNEBAXCI6IFwiVW5pb24gT2YtLVVzZSB0aGUgZXh0ZW50IG9mIGFsbCB0aGUgcmFzdGVycyB0byBkZXRlcm1pbmUgdGhlIHByb2Nlc3NpbmcgZXh0ZW50LlwiLFxuXHRcIkBAV2VpZ2h0ZWQtU3VtX1dlaWdodGVkLVN1bS1UYWJsZV90YWcwQEBcIjogXCJUaGUgd2VpZ2h0ZWQgc3VtIHRhYmxlIGlzIGRlZmluZWQgYnkgdGhyZWUgcHJvcGVydGllczpcIixcblx0XCJAQFdlaWdodGVkLVN1bV9XZWlnaHRlZC1TdW0tVGFibGVfdGFnMUBAXCI6IFwiTGF5ZXItLVRoZSByYXN0ZXIgYmVpbmcgd2VpZ2h0ZWQuXCIsXG5cdFwiQEBXZWlnaHRlZC1TdW1fV2VpZ2h0ZWQtU3VtLVRhYmxlX3RhZzJAQFwiOiBcIkZpZWxkLS1UaGUgZmllbGQgb2YgdGhlIHJhc3RlciB0byB1c2UgZm9yIHdlaWdodGluZy5cIixcblx0XCJAQFdlaWdodGVkLVN1bV9XZWlnaHRlZC1TdW0tVGFibGVfdGFnM0BAXCI6IFwiV2VpZ2h0LS1UaGUgd2VpZ2h0IHZhbHVlIGJ5IHdoaWNoIHRvIG11bHRpcGx5IHRoZSByYXN0ZXIuIEl0IGNhbiBiZSBhbnkgcG9zaXRpdmUgb3IgbmVnYXRpdmUgZGVjaW1hbCB2YWx1ZS5cIixcblx0XCJAQFdpbmQtQ2hpbGxfVGVtcGVyYXR1cmUtUmFzdGVyX3RhZzBAQFwiOiBcIkEgc2luZ2xlLWJhbmQgcmFzdGVyIHdoZXJlIHBpeGVsIHZhbHVlcyByZXByZXNlbnQgYW1iaWVudCBhaXIgdGVtcGVyYXR1cmUuXCIsXG5cdFwiQEBXaW5kLUNoaWxsX1RlbXBlcmF0dXJlLVVuaXRzX3RhZzBAQFwiOiBcIlRoZSB1bml0IG9mIG1lYXN1cmVtZW50IGFzc29jaWF0ZWQgd2l0aCB0aGUgaW5wdXQgdGVtcGVyYXR1cmUgcmFzdGVyLiBBdmFpbGFibGUgaW5wdXQgdW5pdHMgYXJlIENlbHNpdXMsIEZhaHJlbmhlaXQsIGFuZCBLZWx2aW4uXCIsXG5cdFwiQEBXaW5kLUNoaWxsX1dpbmQtQ2hpbGwtVW5pdHNfdGFnMEBAXCI6IFwiVGhlIHVuaXQgb2YgbWVhc3VyZW1lbnQgYXNzb2NpYXRlZCB3aXRoIHRoZSBvdXRwdXQgcmFzdGVyLiBBdmFpbGFibGUgb3V0cHV0IHVuaXRzIGFyZSBDZWxzaXVzLCBGYWhyZW5oZWl0LCBhbmQgS2VsdmluLlwiLFxuXHRcIkBAV2luZC1DaGlsbF9XaW5kLVNwZWVkLVJhc3Rlcl90YWcwQEBcIjogXCJBIHNpbmdsZS1iYW5kIHJhc3RlciB3aGVyZSBwaXhlbCB2YWx1ZXMgcmVwcmVzZW50IHdpbmQgc3BlZWQuXCIsXG5cdFwiQEBXaW5kLUNoaWxsX1dpbmQtU3BlZWQtVW5pdHNfdGFnMEBAXCI6IFwiRGVmaW5lcyB0aGUgdW5pdCBvZiBtZWFzdXJlbWVudCBmb3IgdGhlIHdpbmQtc3BlZWQgcmFzdGVyOlwiLFxuXHRcIkBAV2luZC1DaGlsbF9XaW5kLVNwZWVkLVVuaXRzX3RhZzFAQFwiOiBcIk1pbGVzIFBlciBIb3VyIChtcGgpXCIsXG5cdFwiQEBXaW5kLUNoaWxsX1dpbmQtU3BlZWQtVW5pdHNfdGFnMkBAXCI6IFwiS2lsb21ldGVycyBQZXIgSG91ciAoa20vaClcIixcblx0XCJAQFdpbmQtQ2hpbGxfV2luZC1TcGVlZC1Vbml0c190YWczQEBcIjogXCJNZXRlcnMgUGVyIFNlY29uZCAobS9zKVwiLFxuXHRcIkBAV2luZC1DaGlsbF9XaW5kLVNwZWVkLVVuaXRzX3RhZzRAQFwiOiBcIkZlZXQgUGVyIFNlY29uZCAoZnQvcylcIixcblx0XCJAQFdpbmQtQ2hpbGxfV2luZC1TcGVlZC1Vbml0c190YWc1QEBcIjogXCJLbm90cyAoa24pXCIsXG5cdFwiQEBab25hbC1SZW1hcF9CYWNrZ3JvdW5kLVZhbHVlX3RhZzBAQFwiOiBcIlRoZSBpbml0aWFsIHBpeGVsIHZhbHVlIG9mIHRoZSBvdXRwdXQgcmFzdGVyLCBiZWZvcmUgaW5wdXQgcGl4ZWxzIGFyZSByZW1hcHBlZC5cIixcblx0XCJAQFpvbmFsLVJlbWFwX0RlZmF1bHQtT3V0cHV0LVZhbHVlX3RhZzBAQFwiOiBcIlRoZSB2YWx1ZSB0aGF0IHdpbGwgYmUgYXNzaWduZWQgdG8gYSBwaXhlbCB0aGF0IGRvZXMgbm90IHNhdGlzZnkgYW55IG9mIHRoZSBjb25kaXRpb25zIHNldCBpbiB0aGUgPHN0cm9uZz5ab25hbCBBdHRyaWJ1dGVzIFRhYmxlPC9zdHJvbmc+LlwiLFxuXHRcIkBAWm9uYWwtUmVtYXBfRGVmYXVsdC1PdXRwdXQtVmFsdWVfdGFnM0BAXCI6IFwiVGhpcyB3aWxsIGFsc28gYmUgdGhlIHZhbHVlIG9mIHRoZSBvdXRwdXQgcGl4ZWwgaWYgZWl0aGVyIHRoZSA8c3Ryb25nPk91dHB1dCBWYWx1ZSBGaWVsZCBOYW1lPC9zdHJvbmc+IHBhcmFtZXRlciBpcyBsZWZ0IHVuc3BlY2lmaWVkIG9yIHRoZSBvdXRwdXQgdmFsdWUgb2YgdGhlIGNvcnJlc3BvbmRpbmcgem9uYWwgdGhyZXNob2xkIGlzIGxlZnQgdW5zcGVjaWZpZWQgaW4gdGhlIDxzdHJvbmc+Wm9uYWwgQXR0cmlidXRlcyBUYWJsZTwvc3Ryb25nPi5cIixcblx0XCJAQFpvbmFsLVJlbWFwX01heGltdW0tVmFsdWUtRmllbGQtTmFtZV90YWcwQEBcIjogXCJUaGUgZmllbGQgbmFtZSBjb250YWluaW5nIHRoZSBtYXhpbXVtIHZhbHVlIGJlbG93IHdoaWNoIGFuIGlucHV0IHBpeGVsIGlzIHJlbWFwcGVkLlwiLFxuXHRcIkBAWm9uYWwtUmVtYXBfTWF4aW11bS1WYWx1ZS1GaWVsZC1OYW1lX3RhZzFAQFwiOiBcIklmIGxlZnQgdW5zcGVjaWZpZWQsIG9yIGlmIHRoZSBmaWVsZCB2YWx1ZSBpcyBudWxsLCBwaXhlbCB2YWx1ZXMgYXJlIG5vdCB0ZXN0ZWQgZm9yIG1heGltdW0uXCIsXG5cdFwiQEBab25hbC1SZW1hcF9NaW5pbXVtLVZhbHVlLUZpZWxkLU5hbWVfdGFnMEBAXCI6IFwiVGhlIGZpZWxkIG5hbWUgY29udGFpbmluZyB0aGUgbWluaW11bSB2YWx1ZSBhYm92ZSB3aGljaCBhbiBpbnB1dCBwaXhlbCBpcyByZW1hcHBlZC5cIixcblx0XCJAQFpvbmFsLVJlbWFwX01pbmltdW0tVmFsdWUtRmllbGQtTmFtZV90YWcxQEBcIjogXCJJZiBsZWZ0IHVuc3BlY2lmaWVkLCBvciBpZiB0aGUgZmllbGQgdmFsdWUgaXMgbnVsbCwgcGl4ZWwgdmFsdWVzIGFyZSBub3QgdGVzdGVkIGZvciBtaW5pbXVtLlwiLFxuXHRcIkBAWm9uYWwtUmVtYXBfT3V0cHV0LVZhbHVlLUZpZWxkLU5hbWVfdGFnMEBAXCI6IFwiVGhlIGZpZWxkIG5hbWUgY29udGFpbmluZyB0aGUgdGFyZ2V0IHZhbHVlIHRvIHdoaWNoIGFuIGlucHV0IHBpeGVsIGlzIHJlbWFwcGVkLlwiLFxuXHRcIkBAWm9uYWwtUmVtYXBfT3V0cHV0LVZhbHVlLUZpZWxkLU5hbWVfdGFnMUBAXCI6IFwiSWYgbGVmdCB1bnNwZWNpZmllZCwgb3IgaWYgdGhlIGZpZWxkIHZhbHVlIGlzIG51bGwsIHJlbWFwcGVkIHBpeGVsIHZhbHVlcyBhcmUgc2V0IHRvIDxzdHJvbmc+RGVmYXVsdCBPdXRwdXQgVmFsdWU8L3N0cm9uZz4uXCIsXG5cdFwiQEBab25hbC1SZW1hcF9WYWx1ZS1SYXN0ZXJfdGFnMEBAXCI6IFwiQSByZXF1aXJlZCBzaW5nbGUtYmFuZCByYXN0ZXIgaW5wdXQgY29udGFpbmluZyBwaXhlbCB2YWx1ZXMgdG8gcmVtYXAuXCIsXG5cdFwiQEBab25hbC1SZW1hcF9XaGVyZS1DbGF1c2VfdGFnMEBAXCI6IFwiQW4gb3B0aW9uYWwgcXVlcnkgYXBwbGllZCBvbiB0aGUgPHN0cm9uZz5ab25hbCBBdHRyaWJ1dGVzIFRhYmxlPC9zdHJvbmc+LlwiLFxuXHRcIkBAWm9uYWwtUmVtYXBfV2hlcmUtQ2xhdXNlX3RhZzNAQFwiOiBcIklmIHlvdSB3ZXJlIHVzaW5nIHRoZSB0YWJsZSBhYm92ZSBhcyBhbiBleGFtcGxlLCB0aGUgcXVlcnkgd291bGQgYmUgJHtWYXJpYWJsZTEgPSAnYmFyZSBlYXJ0aCcgQU5EIFZhcmlhYmxlMiA9ICdDYWxpZm9ybmlhJ30uXCIsXG5cdFwiQEBab25hbC1SZW1hcF9ab25hbC1BdHRyaWJ1dGVzLVRhYmxlX3RhZzBAQFwiOiBcIkEgcmVxdWlyZWQgaW5wdXQgdGFibGUgY29udGFpbmluZyBhdCBsZWFzdCB0aHJlZSBmaWVsZHMuIEl0IG11c3QgaGF2ZSBhIG1pbmltdW0gdGhyZXNob2xkIHZhbHVlLCBtYXhpbXVtIHRocmVzaG9sZCB2YWx1ZSwgYW5kIHRhcmdldCB2YWx1ZS4gVGhlIHRhcmdldCB2YWx1ZSBpcyB0aGUgZmllbGQgdGhhdCB3aWxsIGNvbnRhaW4gdGhlIHJlbWFwcGVkIHZhbHVlLlwiLFxuXHRcIkBAWm9uYWwtUmVtYXBfWm9uYWwtQXR0cmlidXRlcy1UYWJsZV90YWcxQEBcIjogXCJUaGUgZm9ybWF0IG9mIHRoZSBmaWxlIGNhbiBiZSBhIGZlYXR1cmUgY2xhc3MsIGZlYXR1cmUgc2VydmljZSwgb3IgYW55IHRhYmxlIHR5cGUgdGhhdCBBcmNHSVMgc3VwcG9ydHMuXCIsXG5cdFwiQEBab25hbC1SZW1hcF9ab25lLUZpZWxkX3RhZzBAQFwiOiBcIlRoZSBmaWVsZCBuYW1lIGluIHRoZSA8c3Ryb25nPlpvbmFsIEF0dHJpYnV0ZXMgVGFibGU8L3N0cm9uZz4gdGhhdCBjb250YWlucyB0aGUgem9uZSBJRCB2YWx1ZXMuXCIsXG5cdFwiQEBab25hbC1SZW1hcF9ab25lLUZpZWxkX3RhZzNAQFwiOiBcIlRoZSB6b25lIElEIHZhbHVlcyBhcmUgZGlyZWN0bHkgdGllZCB0byB0aGUgem9uZSBJRHMgaW4geW91ciB6b25hbCByYXN0ZXIuIFRoZXkgcHJvdmlkZSBhbm90aGVyIGxldmVsIG9mIGZpbHRlcmluZyB3aGlsZSByZW1hcHBpbmcuIElmIHRoZXJlIGlzIG5vIHpvbmUgSUQgYXNzb2NpYXRlZCB3aXRoIGEgcGFydGljdWxhciByZWNvcmQgaW4gdGhlIHRhYmxlLCBpdCB3aWxsIG5vdCBwYXJ0aWNpcGF0ZSBpbiB0aGUgcmVtYXBwaW5nLlwiLFxuXHRcIkBAWm9uYWwtUmVtYXBfWm9uZS1SYXN0ZXJfdGFnMEBAXCI6IFwiQSBzaW5nbGUtYmFuZCByYXN0ZXIgd2hlcmUgZWFjaCBwaXhlbCBkZWZpbmVzIHpvbmVzIGFzc29jaWF0ZWQgd2l0aCBhIHBhcnRpY3VsYXIgbG9jYXRpb24uIEEgem9uZSBpcyBkZWZpbmVkIGFzIGFsbCBhcmVhcyBpbiB0aGUgaW5wdXQgdGhhdCBoYXZlIHRoZSBzYW1lIHZhbHVlLiBUaGUgYXJlYXMgZG8gbm90IGhhdmUgdG8gYmUgY29udGlndW91cy5cIixcblx0XCJAQFByZWRpY3QtVXNpbmctVHJlbmRfZGltZW5zaW9uZGVmaW5pdGlvbl90YWcwQEBcIjogXCJTcGVjaWZpZXMgdGhlIG1ldGhvZCB1c2VkIHRvIHByb3ZpZGUgcHJlZGljdGlvbiBkaW1lbnNpb24gdmFsdWVzLlwiLFxuXHRcIkBAUHJlZGljdC1Vc2luZy1UcmVuZF9kaW1lbnNpb25kZWZpbml0aW9uX3RhZzFAQFwiOiBcIjxzdHJvbmc+QnkgVmFsdWU8L3N0cm9uZz4tLVRoZSBwcmVkaWN0aW9uIHdpbGwgYmUgY2FsY3VsYXRlZCBmb3IgYSBzaW5nbGUgZGltZW5zaW9uIHZhbHVlIC4gRm9yIGV4YW1wbGUsIHlvdSB3YW50IHRvIHByZWRpY3QgeWVhcmx5IHByZWNpcGl0YXRpb24gZm9yIHRoZSB5ZWFycyAyMDUwLCAyMTAwLCBhbmQgMjE1MC4gVGhpcyBpcyB0aGUgZGVmYXVsdC5cIixcblx0XCJAQFByZWRpY3QtVXNpbmctVHJlbmRfZGltZW5zaW9uZGVmaW5pdGlvbl90YWcyQEBcIjogXCI8c3Ryb25nPkJ5IEludGVydmFsPC9zdHJvbmc+LS1UaGUgcHJlZGljdGlvbiB3aWxsIGJlIGNhbGN1bGF0ZWQgZm9yIGFuIGludGVydmFsIG9mIHRoZSBkaW1lbnNpb24gZGVmaW5lZCBieSBhIHN0YXJ0IGFuZCBhbiBlbmQgdmFsdWUuIEZvciBleGFtcGxlLCB5b3Ugd2FudCB0byBwcmVkaWN0IHllYXJseSBwcmVjaXBpdGF0aW9uIGZvciBldmVyeSB5ZWFyIGJldHdlZW4gMjA1MCBhbmQgMjE1MC5cIixcblx0XCJAQFByZWRpY3QtVXNpbmctVHJlbmRfZW5kX3RhZzBAQFwiOiBcIlRoZSBlbmQgZGF0ZSwgaGVpZ2h0LCBvciBkZXB0aCBvZiB0aGUgZGltZW5zaW9uIGludGVydmFsIHRvIGJlIHVzZWQgaW4gdGhlIHByZWRpY3Rpb24uXCIsXG5cdFwiQEBQcmVkaWN0LVVzaW5nLVRyZW5kX2VuZF90YWcxQEBcIjogXCJUaGlzIHBhcmFtZXRlciBpcyByZXF1aXJlZCB3aGVuIHRoZSA8c3Ryb25nPkRpbWVuc2lvbiBEZWZpbml0aW9uPC9zdHJvbmc+IHBhcmFtZXRlciBpcyBzZXQgdG8gPHN0cm9uZz5CeSBJbnRlcnZhbDwvc3Ryb25nPi5cIixcblx0XCJAQFByZWRpY3QtVXNpbmctVHJlbmRfcmFzdGVyX3RhZzBAQFwiOiBcIlRoZSBpbnB1dCBtdWx0aWRpbWVuc2lvbmFsIHRyZW5kIHJhc3RlciBmcm9tIHRoZSA8c3Ryb25nPkdlbmVyYXRlIFRyZW5kPC9zdHJvbmc+IGZ1bmN0aW9uLlwiLFxuXHRcIkBAUHJlZGljdC1Vc2luZy1UcmVuZF9zdGFydF90YWcwQEBcIjogXCJUaGUgc3RhcnQgZGF0ZSwgaGVpZ2h0LCBvciBkZXB0aCBvZiB0aGUgZGltZW5zaW9uIGludGVydmFsIHRvIGJlIHVzZWQgaW4gdGhlIHByZWRpY3Rpb24uXCIsXG5cdFwiQEBQcmVkaWN0LVVzaW5nLVRyZW5kX3N0YXJ0X3RhZzFAQFwiOiBcIlRoaXMgcGFyYW1ldGVyIGlzIHJlcXVpcmVkIHdoZW4gdGhlIDxzdHJvbmc+RGltZW5zaW9uIERlZmluaXRpb248L3N0cm9uZz4gcGFyYW1ldGVyIGlzIHNldCB0byA8c3Ryb25nPkJ5IEludGVydmFsPC9zdHJvbmc+LlwiLFxuXHRcIkBAUHJlZGljdC1Vc2luZy1UcmVuZF91bml0X3RhZzBAQFwiOiBcIlRoZSB1bml0IHRoYXQgd2lsbCBiZSB1c2VkIGZvciB0aGUgdmFsdWUgaW50ZXJ2YWwuIFRoaXMgcGFyYW1ldGVyIG9ubHkgYXBwbGllcyB3aGVuIHRoZSBkaW1lbnNpb24gb2YgYW5hbHlzaXMgaXMgYSB0aW1lIGRpbWVuc2lvbi5cIixcblx0XCJAQFByZWRpY3QtVXNpbmctVHJlbmRfdW5pdF90YWcxQEBcIjogXCI8c3Ryb25nPkhvdXJzPC9zdHJvbmc+LS1UaGUgcHJlZGljdGlvbiB3aWxsIGJlIGNhbGN1bGF0ZWQgZm9yIGVhY2ggaG91ciBpbiB0aGUgcmFuZ2Ugb2YgdGltZSBkZXNjcmliZWQgYnkgdGhlIDxzdHJvbmc+U3RhcnQ8L3N0cm9uZz4sIDxzdHJvbmc+RW5kPC9zdHJvbmc+LCBhbmQgPHN0cm9uZz5WYWx1ZSBJbnRlcnZhbDwvc3Ryb25nPiBwYXJhbWV0ZXJzLlwiLFxuXHRcIkBAUHJlZGljdC1Vc2luZy1UcmVuZF91bml0X3RhZzJAQFwiOiBcIjxzdHJvbmc+RGF5czwvc3Ryb25nPi0tVGhlIHByZWRpY3Rpb24gd2lsbCBiZSBjYWxjdWxhdGVkIGZvciBlYWNoIGRheSBpbiB0aGUgcmFuZ2Ugb2YgdGltZSBkZXNjcmliZWQgYnkgdGhlIDxzdHJvbmc+U3RhcnQ8L3N0cm9uZz4sIDxzdHJvbmc+RW5kPC9zdHJvbmc+LCBhbmQgPHN0cm9uZz5WYWx1ZSBJbnRlcnZhbDwvc3Ryb25nPiBwYXJhbWV0ZXJzLlwiLFxuXHRcIkBAUHJlZGljdC1Vc2luZy1UcmVuZF91bml0X3RhZzNAQFwiOiBcIjxzdHJvbmc+V2Vla3M8L3N0cm9uZz4tLVRoZSBwcmVkaWN0aW9uIHdpbGwgYmUgY2FsY3VsYXRlZCBmb3IgZWFjaCB3ZWVrIGluIHRoZSByYW5nZSBvZiB0aW1lIGRlc2NyaWJlZCBieSB0aGUgPHN0cm9uZz5TdGFydDwvc3Ryb25nPiwgPHN0cm9uZz5FbmQ8L3N0cm9uZz4sIGFuZCA8c3Ryb25nPlZhbHVlIEludGVydmFsPC9zdHJvbmc+IHBhcmFtZXRlcnMuXCIsXG5cdFwiQEBQcmVkaWN0LVVzaW5nLVRyZW5kX3VuaXRfdGFnNEBAXCI6IFwiPHN0cm9uZz5Nb250aHM8L3N0cm9uZz4tLVRoZSBwcmVkaWN0aW9uIHdpbGwgYmUgY2FsY3VsYXRlZCBmb3IgZWFjaCBtb250aCBpbiB0aGUgcmFuZ2Ugb2YgdGltZSBkZXNjcmliZWQgYnkgdGhlIDxzdHJvbmc+U3RhcnQ8L3N0cm9uZz4sIDxzdHJvbmc+RW5kPC9zdHJvbmc+LCBhbmQgPHN0cm9uZz5WYWx1ZSBJbnRlcnZhbDwvc3Ryb25nPiBwYXJhbWV0ZXJzLlwiLFxuXHRcIkBAUHJlZGljdC1Vc2luZy1UcmVuZF91bml0X3RhZzVAQFwiOiBcIjxzdHJvbmc+WWVhcnM8L3N0cm9uZz4tLVRoZSBwcmVkaWN0aW9uIHdpbGwgYmUgY2FsY3VsYXRlZCBmb3IgZWFjaCB5ZWFyIGluIHRoZSByYW5nZSBvZiB0aW1lIGRlc2NyaWJlZCBieSB0aGUgPHN0cm9uZz5TdGFydDwvc3Ryb25nPiwgPHN0cm9uZz5FbmQ8L3N0cm9uZz4sIGFuZCA8c3Ryb25nPlZhbHVlIEludGVydmFsPC9zdHJvbmc+IHBhcmFtZXRlcnMuXCIsXG5cdFwiQEBQcmVkaWN0LVVzaW5nLVRyZW5kX3ZhbHVlaW50ZXJ2YWxfdGFnMEBAXCI6IFwiVGhlIG51bWJlciBvZiBzdGVwcyBiZXR3ZWVuIHR3byBkaW1lbnNpb24gdmFsdWVzIHRvIGJlIGluY2x1ZGVkIGluIHRoZSBwcmVkaWN0aW9uLiBUaGUgZGVmYXVsdCB2YWx1ZSBpcyAxLlwiLFxuXHRcIkBAUHJlZGljdC1Vc2luZy1UcmVuZF92YWx1ZWludGVydmFsX3RhZzFAQFwiOiBcIlRoaXMgcGFyYW1ldGVyIGlzIHJlcXVpcmVkIHdoZW4gdGhlIDxzdHJvbmc+RGltZW5zaW9uIERlZmluaXRpb248L3N0cm9uZz4gcGFyYW1ldGVyIGlzIHNldCB0byA8c3Ryb25nPkJ5IEludGVydmFsPC9zdHJvbmc+LlwiLFxuXHRcIkBAUHJlZGljdC1Vc2luZy1UcmVuZF92YWx1ZXNfdGFnMEBAXCI6IFwiVGhlIGRpbWVuc2lvbiB2YWx1ZSBvciB2YWx1ZXMgdG8gYmUgdXNlZCBpbiB0aGUgcHJlZGljdGlvbi5cIixcblx0XCJAQFByZWRpY3QtVXNpbmctVHJlbmRfdmFsdWVzX3RhZzFAQFwiOiBcIlRoZSBmb3JtYXQgb2YgdGhlIHRpbWUsIGRlcHRoLCBhbmQgaGVpZ2h0IHZhbHVlcyBtdXN0IG1hdGNoIHRoZSBmb3JtYXQgb2YgdGhlIGRpbWVuc2lvbiB2YWx1ZXMgdXNlZCB0byBnZW5lcmF0ZSB0aGUgdHJlbmQgcmFzdGVyLiBJZiB0aGUgdHJlbmQgcmFzdGVyIHdhcyBnZW5lcmF0ZWQgZm9yIHRoZSBTdGRUaW1lIGRpbWVuc2lvbiwgdGhlIGZvcm1hdCBzaG91bGQgYmUgWVlZWS1NTS1ERFRISDpNTTpTUywgZm9yIGV4YW1wbGUsIDIwNTAtMDEtMDFUMDA6MDA6MDAuIE11bHRpcGxlIHZhbHVlcyBhcmUgc2VwYXJhdGVkIHdpdGggYSBzZW1pY29sb24uXCIsXG5cdFwiQEBQcm9jZXNzLVJhc3Rlci1Db2xsZWN0aW9uX2FnZ3JlZ2F0aW9uZnVuY3Rpb25fdGFnMEBAXCI6IFwiU3BlY2lmeSB0aGUgcmFzdGVyIGZ1bmN0aW9uIHRlbXBsYXRlIHVzZWQgdG8gYWdncmVnYXRlIG11bHRpcGxlIHNsaWNlcyBpbnRvIGZld2VyIHNsaWNlcyBvciBhIHNpbmdsZSBzbGljZS5cIixcblx0XCJAQFByb2Nlc3MtUmFzdGVyLUNvbGxlY3Rpb25fZGltZW5zaW9uX3RhZzBAQFwiOiBcIlRoZSBhZ2dyZWdhdGlvbiBkaW1lbnNpb24uIFRoaXMgaXMgdGhlIGRpbWVuc2lvbiBhbG9uZyB3aGljaCB0aGUgdmFyaWFibGVzIHdpbGwgYmUgYWdncmVnYXRlZC5cIixcblx0XCJAQFByb2Nlc3MtUmFzdGVyLUNvbGxlY3Rpb25faXRlbWZ1bmN0aW9uX3RhZzBAQFwiOiBcIlNwZWNpZnkgdGhlIHJhc3RlciBmdW5jdGlvbiB0ZW1wbGF0ZSB1c2VkIHRvIHByb2Nlc3MgZWFjaCBzbGljZSBvciBpdGVtIGluIHRoZSBpbnB1dCByYXN0ZXIgY29sbGVjdGlvbi5cIixcblx0XCJAQFByb2Nlc3MtUmFzdGVyLUNvbGxlY3Rpb25fa2V5d29yZGludGVydmFsX3RhZzBAQFwiOiBcIlNwZWNpZmllcyB0aGUga2V5d29yZCBpbnRlcnZhbCB0aGF0IHdpbGwgYmUgdXNlZCB3aGVuIGFnZ3JlZ2F0aW5nIGFsb25nIHRoZSBkaW1lbnNpb24uIFRoaXMgcGFyYW1ldGVyIGlzIHJlcXVpcmVkIHdoZW4gdGhlIDxzdHJvbmc+VHlwZTwvc3Ryb25nPiBpcyBzZXQgdG8gPHN0cm9uZz5JbnRlcnZhbCBLZXl3b3JkPC9zdHJvbmc+LCBhbmQgdGhlIGFnZ3JlZ2F0aW9uIG11c3QgYmUgYWNyb3NzIHRpbWUuXCIsXG5cdFwiQEBQcm9jZXNzLVJhc3Rlci1Db2xsZWN0aW9uX2tleXdvcmRpbnRlcnZhbF90YWcxQEBcIjogXCI8c3Ryb25nPkhvdXJseTwvc3Ryb25nPi0tVGhlIGRhdGEgdmFsdWVzIHdpbGwgYmUgYWdncmVnYXRlZCBpbnRvIGhvdXJseSB0aW1lIHN0ZXBzLCBhbmQgdGhlIHJlc3VsdCB3aWxsIGluY2x1ZGUgZXZlcnkgaG91ciBpbiB0aGUgdGltZSBzZXJpZXMuXCIsXG5cdFwiQEBQcm9jZXNzLVJhc3Rlci1Db2xsZWN0aW9uX2tleXdvcmRpbnRlcnZhbF90YWcyQEBcIjogXCI8c3Ryb25nPkRhaWx5PC9zdHJvbmc+LS1UaGUgZGF0YSB2YWx1ZXMgd2lsbCBiZSBhZ2dyZWdhdGVkIGludG8gZGFpbHkgdGltZSBzdGVwcywgYW5kIHRoZSByZXN1bHQgd2lsbCBpbmNsdWRlIGV2ZXJ5IGRheSBpbiB0aGUgdGltZSBzZXJpZXMuXCIsXG5cdFwiQEBQcm9jZXNzLVJhc3Rlci1Db2xsZWN0aW9uX2tleXdvcmRpbnRlcnZhbF90YWczQEBcIjogXCI8c3Ryb25nPldlZWtseTwvc3Ryb25nPi0tVGhlIGRhdGEgdmFsdWVzIHdpbGwgYmUgYWdncmVnYXRlZCBpbnRvIHdlZWtseSB0aW1lIHN0ZXBzLCBhbmQgdGhlIHJlc3VsdCB3aWxsIGluY2x1ZGUgZXZlcnkgd2VlayBpbiB0aGUgdGltZSBzZXJpZXMuXCIsXG5cdFwiQEBQcm9jZXNzLVJhc3Rlci1Db2xsZWN0aW9uX2tleXdvcmRpbnRlcnZhbF90YWc0QEBcIjogXCI8c3Ryb25nPkRla2FkbHk8L3N0cm9uZz4tLVRoZSBkYXRhIHZhbHVlcyB3aWxsIGJlIGFnZ3JlZ2F0ZWQgaW50byAzIHBlcmlvZHMgb2YgMTAgZGF5cyBlYWNoLiBUaGUgbGFzdCBwZXJpb2QgbWlnaHQgY29udGFpbiBtb3JlIG9yIGZld2VyIHRoYW4gMTAgZGF5cy4gVGhlIG91dHB1dCB3aWxsIGluY2x1ZGUgMyBzbGljZXMgZm9yIGVhY2ggbW9udGguXCIsXG5cdFwiQEBQcm9jZXNzLVJhc3Rlci1Db2xsZWN0aW9uX2tleXdvcmRpbnRlcnZhbF90YWc1QEBcIjogXCI8c3Ryb25nPlBlbnRhZGx5PC9zdHJvbmc+LS1UaGUgZGF0YSB2YWx1ZXMgd2lsbCBiZSBhZ2dyZWdhdGVkIGludG8gNiBwZXJpb2RzIG9mIDUgZGF5cyBlYWNoLiBUaGUgbGFzdCBwZXJpb2QgbWlnaHQgY29udGFpbiBtb3JlIG9yIGZld2VyIHRoYW4gNSBkYXlzLiBUaGUgb3V0cHV0IHdpbGwgaW5jbHVkZSA2IHNsaWNlcyBmb3IgZWFjaCBtb250aC5cIixcblx0XCJAQFByb2Nlc3MtUmFzdGVyLUNvbGxlY3Rpb25fa2V5d29yZGludGVydmFsX3RhZzZAQFwiOiBcIjxzdHJvbmc+TW9udGhseTwvc3Ryb25nPi0tVGhlIGRhdGEgdmFsdWVzIHdpbGwgYmUgYWdncmVnYXRlZCBpbnRvIG1vbnRobHkgdGltZSBzdGVwcywgYW5kIHRoZSByZXN1bHQgd2lsbCBpbmNsdWRlIGV2ZXJ5IG1vbnRoIGluIHRoZSB0aW1lIHNlcmllcy5cIixcblx0XCJAQFByb2Nlc3MtUmFzdGVyLUNvbGxlY3Rpb25fa2V5d29yZGludGVydmFsX3RhZzdAQFwiOiBcIjxzdHJvbmc+UXVhcnRlcmx5PC9zdHJvbmc+LS1UaGUgZGF0YSB2YWx1ZXMgd2lsbCBiZSBhZ2dyZWdhdGVkIGludG8gcXVhcnRlcmx5IHRpbWUgc3RlcHMsIGFuZCB0aGUgcmVzdWx0IHdpbGwgaW5jbHVkZSBldmVyeSBxdWFydGVyIGluIHRoZSB0aW1lIHNlcmllcy5cIixcblx0XCJAQFByb2Nlc3MtUmFzdGVyLUNvbGxlY3Rpb25fa2V5d29yZGludGVydmFsX3RhZzhAQFwiOiBcIjxzdHJvbmc+WWVhcmx5PC9zdHJvbmc+LS1UaGUgZGF0YSB2YWx1ZXMgd2lsbCBiZSBhZ2dyZWdhdGVkIGludG8geWVhcmx5IHRpbWUgc3RlcHMsIGFuZCB0aGUgcmVzdWx0IHdpbGwgaW5jbHVkZSBldmVyeSB5ZWFyIGluIHRoZSB0aW1lIHNlcmllcy5cIixcblx0XCJAQFByb2Nlc3MtUmFzdGVyLUNvbGxlY3Rpb25fa2V5d29yZGludGVydmFsX3RhZzlAQFwiOiBcIjxzdHJvbmc+UmVjdXJyaW5nIGRhaWx5PC9zdHJvbmc+LS1UaGUgZGF0YSB2YWx1ZXMgd2lsbCBiZSBhZ2dyZWdhdGVkIGludG8gZGFpbHkgdGltZSBzdGVwcywgYW5kIHRoZSByZXN1bHQgd2lsbCBpbmNsdWRlIG9uZSBhZ2dyZWdhdGVkIHZhbHVlIHBlciBKdWxpYW4gZGF5LiBUaGUgb3V0cHV0IHdpbGwgaW5jbHVkZSwgYXQgbW9zdCwgMzY2IGRhaWx5IHRpbWUgc2xpY2VzLlwiLFxuXHRcIkBAUHJvY2Vzcy1SYXN0ZXItQ29sbGVjdGlvbl9rZXl3b3JkaW50ZXJ2YWxfdGFnMTBAQFwiOiBcIjxzdHJvbmc+UmVjdXJyaW5nIHdlZWtseTwvc3Ryb25nPi0tVGhlIGRhdGEgdmFsdWVzIHdpbGwgYmUgYWdncmVnYXRlZCBpbnRvIHdlZWtseSB0aW1lIHN0ZXBzLCBhbmQgdGhlIHJlc3VsdCB3aWxsIGluY2x1ZGUgb25lIGFnZ3JlZ2F0ZWQgdmFsdWUgcGVyIHdlZWsuIFRoZSBvdXRwdXQgd2lsbCBpbmNsdWRlLCBhdCBtb3N0LCA1MyB3ZWVrbHkgdGltZSBzbGljZXMuXCIsXG5cdFwiQEBQcm9jZXNzLVJhc3Rlci1Db2xsZWN0aW9uX2tleXdvcmRpbnRlcnZhbF90YWcxMUBAXCI6IFwiPHN0cm9uZz5SZWN1cnJpbmcgbW9udGhseTwvc3Ryb25nPi0tVGhlIGRhdGEgdmFsdWVzIHdpbGwgYmUgYWdncmVnYXRlZCBpbnRvIG1vbnRobHkgdGltZSBzdGVwcywgYW5kIHRoZSByZXN1bHQgd2lsbCBpbmNsdWRlIG9uZSBhZ2dyZWdhdGVkIHZhbHVlIHBlciBtb250aC4gVGhlIG91dHB1dCB3aWxsIGluY2x1ZGUsIGF0IG1vc3QsIDEyIG1vbnRobHkgdGltZSBzbGljZXMuXCIsXG5cdFwiQEBQcm9jZXNzLVJhc3Rlci1Db2xsZWN0aW9uX2tleXdvcmRpbnRlcnZhbF90YWcxMkBAXCI6IFwiPHN0cm9uZz5SZWN1cnJpbmcgcXVhcnRlcmx5PC9zdHJvbmc+LS1UaGUgZGF0YSB2YWx1ZXMgd2lsbCBiZSBhZ2dyZWdhdGVkIGludG8gcXVhcnRlcmx5IHRpbWUgc3RlcHMsIGFuZCB0aGUgcmVzdWx0IHdpbGwgaW5jbHVkZSBvbmUgYWdncmVnYXRlZCB2YWx1ZSBwZXIgcXVhcnRlci4gVGhlIG91dHB1dCB3aWxsIGluY2x1ZGUsIGF0IG1vc3QsIDQgcXVhcnRlcmx5IHRpbWUgc2xpY2VzLlwiLFxuXHRcIkBAUHJvY2Vzcy1SYXN0ZXItQ29sbGVjdGlvbl9tYXhpbXVtdmFsdWVfdGFnMEBAXCI6IFwiVGhlIG1heGltdW0gdmFsdWUgZm9yIGEgcmFuZ2UuXCIsXG5cdFwiQEBQcm9jZXNzLVJhc3Rlci1Db2xsZWN0aW9uX21heGltdW12YWx1ZV90YWcxQEBcIjogXCJUaGlzIHBhcmFtZXRlciBpcyByZXF1aXJlZCB3aGVuIHRoZSA8c3Ryb25nPlR5cGU8L3N0cm9uZz4gcGFyYW1ldGVyIGlzIHNldCB0byA8c3Ryb25nPkludGVydmFsIFJhbmdlczwvc3Ryb25nPi5cIixcblx0XCJAQFByb2Nlc3MtUmFzdGVyLUNvbGxlY3Rpb25fbWluaW11bXZhbHVlX3RhZzBAQFwiOiBcIlRoZSBtaW5pbXVtIHZhbHVlIGZvciBhIHJhbmdlLlwiLFxuXHRcIkBAUHJvY2Vzcy1SYXN0ZXItQ29sbGVjdGlvbl9taW5pbXVtdmFsdWVfdGFnMUBAXCI6IFwiVGhpcyBwYXJhbWV0ZXIgaXMgcmVxdWlyZWQgd2hlbiB0aGUgPHN0cm9uZz5UeXBlPC9zdHJvbmc+IHBhcmFtZXRlciBpcyBzZXQgdG8gPHN0cm9uZz5JbnRlcnZhbCBSYW5nZXM8L3N0cm9uZz4uXCIsXG5cdFwiQEBQcm9jZXNzLVJhc3Rlci1Db2xsZWN0aW9uX3Byb2Nlc3NpbmdmdW5jdGlvbl90YWcwQEBcIjogXCJTcGVjaWZ5IHRoZSByYXN0ZXIgZnVuY3Rpb24gdGVtcGxhdGUgdXNlZCB0byBkaXNwbGF5IHRoZSBwcm9jZXNzZWQgcmFzdGVyIGxheWVyLlwiLFxuXHRcIkBAUHJvY2Vzcy1SYXN0ZXItQ29sbGVjdGlvbl9yYXN0ZXJjb2xsZWN0aW9uX3RhZzBAQFwiOiBcIlRoZSBpbnB1dCBtdWx0aWRpbWVuc2lvbmFsIHJhc3RlciwgbW9zYWljIGxheWVyLCBvciBtb3NhaWMgZGF0YXNldC5cIixcblx0XCJAQFByb2Nlc3MtUmFzdGVyLUNvbGxlY3Rpb25fdHlwZV90YWcwQEBcIjogXCJTcGVjaWZpZXMgdGhlIGRpbWVuc2lvbiBpbnRlcnZhbCBmb3Igd2hpY2ggdGhlIGRhdGEgd2lsbCBiZSBhZ2dyZWdhdGVkLlwiLFxuXHRcIkBAUHJvY2Vzcy1SYXN0ZXItQ29sbGVjdGlvbl90eXBlX3RhZzFAQFwiOiBcIjxzdHJvbmc+QWxsPC9zdHJvbmc+LS1UaGUgZGF0YSB2YWx1ZXMgd2lsbCBiZSBhZ2dyZWdhdGVkIGFjcm9zcyBhbGwgc2xpY2VzLiBUaGlzIGlzIHRoZSBkZWZhdWx0LlwiLFxuXHRcIkBAUHJvY2Vzcy1SYXN0ZXItQ29sbGVjdGlvbl90eXBlX3RhZzJAQFwiOiBcIjxzdHJvbmc+SW50ZXJ2YWwgS2V5d29yZDwvc3Ryb25nPi0tVGhlIHZhcmlhYmxlIGRhdGEgd2lsbCBiZSBhZ2dyZWdhdGVkIHVzaW5nIGEgY29tbW9ubHkga25vd24gaW50ZXJ2YWwuXCIsXG5cdFwiQEBQcm9jZXNzLVJhc3Rlci1Db2xsZWN0aW9uX3R5cGVfdGFnM0BAXCI6IFwiPHN0cm9uZz5JbnRlcnZhbCBSYW5nZXM8L3N0cm9uZz4tLVRoZSB2YXJpYWJsZSBkYXRhIHdpbGwgYmUgYWdncmVnYXRlZCBiZXR3ZWVuIHNwZWNpZmllZCBwYWlycyBvZiB2YWx1ZXMgb3IgZGF0ZXMuXCIsXG5cdFwiQEBQcm9jZXNzLVJhc3Rlci1Db2xsZWN0aW9uX3R5cGVfdGFnNEBAXCI6IFwiPHN0cm9uZz5JbnRlcnZhbCBWYWx1ZXM8L3N0cm9uZz4tLVRoZSB2YXJpYWJsZSBkYXRhIHdpbGwgYmUgYWdncmVnYXRlZCB1c2luZyBhIHVzZXItc3BlY2lmaWVkIGludGVydmFsIGFuZCB1bml0LlwiLFxuXHRcIkBAUHJvY2Vzcy1SYXN0ZXItQ29sbGVjdGlvbl91bml0X3RhZzBAQFwiOiBcIlRoZSB1bml0IHRoYXQgd2lsbCBiZSB1c2VkIGZvciB0aGUgaW50ZXJ2YWwgdmFsdWUuIFRoaXMgcGFyYW1ldGVyIGlzIHJlcXVpcmVkIHdoZW4gdGhlIDxzdHJvbmc+RGltZW5zaW9uPC9zdHJvbmc+IGlzIGEgdGltZSBmaWVsZCBhbmQgdGhlIDxzdHJvbmc+VHlwZTwvc3Ryb25nPiBwYXJhbWV0ZXIgaXMgc2V0IHRvIDxzdHJvbmc+SW50ZXJ2YWwgVmFsdWU8L3N0cm9uZz4uXCIsXG5cdFwiQEBQcm9jZXNzLVJhc3Rlci1Db2xsZWN0aW9uX3VuaXRfdGFnMUBAXCI6IFwiSWYgeW91IGFyZSBhZ2dyZWdhdGluZyBvdmVyIGFueXRoaW5nIG90aGVyIHRoYW4gdGltZSwgdGhpcyBvcHRpb24gd2lsbCBub3QgYmUgYXZhaWxhYmxlIGFuZCB0aGUgdW5pdCBmb3IgdGhlIGludGVydmFsIHZhbHVlIHdpbGwgbWF0Y2ggdGhlIHZhcmlhYmxlIHVuaXQgb2YgdGhlIGlucHV0IG11bHRpZGltZW5zaW9uYWwgcmFzdGVyIGRhdGEuXCIsXG5cdFwiQEBQcm9jZXNzLVJhc3Rlci1Db2xsZWN0aW9uX3VuaXRfdGFnMkBAXCI6IFwiPHN0cm9uZz5Ib3Vyczwvc3Ryb25nPi0tVGhlIGRhdGEgdmFsdWVzIHdpbGwgYmUgYWdncmVnYXRlZCBpbnRvIGhvdXJseSB0aW1lIHNsaWNlcyBhdCB0aGUgaW50ZXJ2YWwgcHJvdmlkZWQuXCIsXG5cdFwiQEBQcm9jZXNzLVJhc3Rlci1Db2xsZWN0aW9uX3VuaXRfdGFnM0BAXCI6IFwiPHN0cm9uZz5EYXlzPC9zdHJvbmc+LS1UaGUgZGF0YSB2YWx1ZXMgd2lsbCBiZSBhZ2dyZWdhdGVkIGludG8gZGFpbHkgdGltZSBzbGljZXMgYXQgdGhlIGludGVydmFsIHByb3ZpZGVkLlwiLFxuXHRcIkBAUHJvY2Vzcy1SYXN0ZXItQ29sbGVjdGlvbl91bml0X3RhZzRAQFwiOiBcIjxzdHJvbmc+V2Vla3M8L3N0cm9uZz4tLVRoZSBkYXRhIHZhbHVlcyB3aWxsIGJlIGFnZ3JlZ2F0ZWQgaW50byB3ZWVrbHkgdGltZSBzbGljZXMgYXQgdGhlIGludGVydmFsIHByb3ZpZGVkLlwiLFxuXHRcIkBAUHJvY2Vzcy1SYXN0ZXItQ29sbGVjdGlvbl91bml0X3RhZzVAQFwiOiBcIjxzdHJvbmc+TW9udGhzPC9zdHJvbmc+LS1UaGUgZGF0YSB2YWx1ZXMgd2lsbCBiZSBhZ2dyZWdhdGVkIGludG8gbW9udGhseSB0aW1lIHNsaWNlcyBhdCB0aGUgaW50ZXJ2YWwgcHJvdmlkZWQuXCIsXG5cdFwiQEBQcm9jZXNzLVJhc3Rlci1Db2xsZWN0aW9uX3VuaXRfdGFnNkBAXCI6IFwiPHN0cm9uZz5ZZWFyczwvc3Ryb25nPi0tVGhlIGRhdGEgdmFsdWVzIHdpbGwgYmUgYWdncmVnYXRlZCBpbnRvIHllYXJseSB0aW1lIHNsaWNlcyBhdCB0aGUgaW50ZXJ2YWwgcHJvdmlkZWQuXCIsXG5cdFwiQEBQcm9jZXNzLVJhc3Rlci1Db2xsZWN0aW9uX3ZhbHVlaW50ZXJ2YWxfdGFnMEBAXCI6IFwiVGhlIHNpemUgb2YgdGhlIGludGVydmFsIHRoYXQgd2lsbCBiZSB1c2VkIGZvciB0aGUgYWdncmVnYXRpb24uIFRoaXMgcGFyYW1ldGVyIGlzIHJlcXVpcmVkIHdoZW4gdGhlIDxzdHJvbmc+VHlwZTwvc3Ryb25nPiBwYXJhbWV0ZXIgaXMgc2V0IHRvIDxzdHJvbmc+SW50ZXJ2YWwgVmFsdWU8L3N0cm9uZz4uXCIsXG5cdFwiQEBQcm9jZXNzLVJhc3Rlci1Db2xsZWN0aW9uX3ZhbHVlaW50ZXJ2YWxfdGFnMUBAXCI6IFwiRm9yIGV4YW1wbGUsIHRvIGFnZ3JlZ2F0ZSAzMCB5ZWFycyBvZiBtb250aGx5IHRlbXBlcmF0dXJlIGRhdGEgaW50byA1LXllYXIgaW5jcmVtZW50cywgZW50ZXIgNSBhcyB0aGUgPHN0cm9uZz5WYWx1ZSBJbnRlcnZhbDwvc3Ryb25nPiwgYW5kIHNwZWNpZnkgPHN0cm9uZz5Vbml0PC9zdHJvbmc+IGFzIDxzdHJvbmc+WWVhcnM8L3N0cm9uZz4uXCIsXG5cdFwiQEBMaW5lYXItU3BlY3RyYWwtVW5taXhpbmdfbm9uLW5lZ2F0aXZlX3RhZzBAQFwiOiBcIlNwZWNpZmllcyB0aGUgb3B0aW9ucyB0byBkZWZpbmUgdGhlIG91dHB1dCBwaXhlbCB2YWx1ZXMuXCIsXG5cdFwiQEBMaW5lYXItU3BlY3RyYWwtVW5taXhpbmdfbm9uLW5lZ2F0aXZlX3RhZzFAQFwiOiBcIkNoZWNrZWQtLVRoZXJlIHdpbGwgYmUgbm8gbmVnYXRpdmUgb3V0cHV0IHZhbHVlcy5cIixcblx0XCJAQExpbmVhci1TcGVjdHJhbC1Vbm1peGluZ19ub24tbmVnYXRpdmVfdGFnMkBAXCI6IFwiVW5jaGVja2VkLS1UaGVyZSBjYW4gYmUgbmVnYXRpdmUgdmFsdWVzIG9mIGZyYWN0aW9uYWwgbGFuZCBjb3Zlci5cIixcblx0XCJAQExpbmVhci1TcGVjdHJhbC1Vbm1peGluZ19yYXN0ZXJfdGFnMEBAXCI6IFwiVGhlIGlucHV0IHJhc3Rlci5cIixcblx0XCJAQExpbmVhci1TcGVjdHJhbC1Vbm1peGluZ19zcGVjdHJhbHByb2ZpbGVfdGFnMEBAXCI6IFwiVGhlIGlucHV0IHNwZWN0cmFsIHByb2ZpbGUgZmlsZS5cIixcblx0XCJAQExpbmVhci1TcGVjdHJhbC1Vbm1peGluZ19zcGVjdHJhbHByb2ZpbGV0eXBlX3RhZzBAQFwiOiBcIlRoZSBzcGVjdHJhbCBpbmZvcm1hdGlvbiBmb3IgdGhlIGRpZmZlcmVudCBsYW5kIGNvdmVyIGNsYXNzZXMuXCIsXG5cdFwiQEBMaW5lYXItU3BlY3RyYWwtVW5taXhpbmdfc3BlY3RyYWxwcm9maWxldHlwZV90YWcxQEBcIjogXCI8c3Ryb25nPlNwZWN0cmFsIFByb2ZpbGU8L3N0cm9uZz4tLUEgY2xhc3NpZmllciBkZWZpbml0aW9uIGZpbGUgKCR7LmVjZH0pLCBnZW5lcmF0ZWQgZnJvbSB0aGUgPHN0cm9uZz48c3Ryb25nPlRyYWluIE1heGltdW0gTGlrZWxpaG9vZCBDbGFzc2lmaWVyPC9zdHJvbmc+PC9zdHJvbmc+IHRvb2wsIG9yIGEgSmF2YVNjcmlwdCBPYmplY3QgTm90YXRpb24gZmlsZSAoJHsuanNvbn0pIHRoYXQgY29udGFpbnMgdGhlIGNsYXNzIHNwZWN0cmFsIHByb2ZpbGVzLlwiLFxuXHRcIkBATGluZWFyLVNwZWN0cmFsLVVubWl4aW5nX3NwZWN0cmFscHJvZmlsZXR5cGVfdGFnMkBAXCI6IFwiPHN0cm9uZz5UcmFpbmluZyBGZWF0dXJlPC9zdHJvbmc+LS1Qb2x5Z29uIGZlYXR1cmVzIG9yIGEgdHJhaW5pbmcgc2FtcGxlIGZlYXR1cmUgY2xhc3MsIGdlbmVyYXRlZCBmcm9tIHRoZSA8c3Ryb25nPlRyYWluaW5nIFNhbXBsZXMgTWFuYWdlcjwvc3Ryb25nPi5cIixcblx0XCJAQExpbmVhci1TcGVjdHJhbC1Vbm1peGluZ19zdW10b29uZV90YWcwQEBcIjogXCJTcGVjaWZpZXMgdGhlIG9wdGlvbnMgdG8gZGVmaW5lIHRoZSBvdXRwdXQgcGl4ZWwgdmFsdWVzLlwiLFxuXHRcIkBATGluZWFyLVNwZWN0cmFsLVVubWl4aW5nX3N1bXRvb25lX3RhZzFAQFwiOiBcIkNoZWNrZWQtLUNsYXNzIHZhbHVlcyBmb3IgZWFjaCBwaXhlbCBhcmUgcHJvdmlkZWQgaW4gZGVjaW1hbCBmb3JtYXQgd2l0aCB0aGUgc3VtIG9mIGFsbCBjbGFzc2VzIGVxdWFsIHRvIDEuIEZvciBleGFtcGxlLCBDbGFzczEgPSAwLjE2OyBDbGFzczIgPSAwLjI0OyBDbGFzczMgPSAwLjYwLlwiLFxuXHRcIkBATGluZWFyLVNwZWN0cmFsLVVubWl4aW5nX3N1bXRvb25lX3RhZzJAQFwiOiBcIlVuY2hlY2tlZC0tVGhlIHN1bSBvZiBhbGwgY2xhc3NlcyBpbiBhIHBpeGVsIGNhbiBleGNlZWQgMS5cIixcblx0XCJAQExpbmVhci1TcGVjdHJhbC1Vbm1peGluZ190cmFpbmluZ2ZlYXR1cmVfdGFnMEBAXCI6IFwiVGhlIGlucHV0IHRyYWluaW5nIGZlYXR1cmUgZmlsZS5cIixcblx0XCJAQEFnZ3JlZ2F0ZV9hZ2dyZWdhdGlvbnRlY2huaXF1ZV90YWcwQEBcIjogXCJUaGUgbWV0aG9kIHVzZWQgZm9yIGFnZ3JlZ2F0aW9uLiBUaGUgdmFsdWVzIG9mIHRoZSBpbnB1dCBjZWxscyBlbmNvbXBhc3NlZCBieSB0aGUgY29hcnNlciBvdXRwdXQgY2VsbHMgYXJlIGFnZ3JlZ2F0ZWQgYnkgb25lIG9mIHRoZSBmb2xsb3dpbmcgc3RhdGlzdGljczpcIixcblx0XCJAQEFnZ3JlZ2F0ZV9hZ2dyZWdhdGlvbnRlY2huaXF1ZV90YWcxQEBcIjogXCI8c3Ryb25nPlN1bTwvc3Ryb25nPi0tVGhlIHRvdGFsIG9mIHRoZSBpbnB1dCBjZWxscy4gVGhpcyBpcyB0aGUgZGVmYXVsdC5cIixcblx0XCJAQEFnZ3JlZ2F0ZV9hZ2dyZWdhdGlvbnRlY2huaXF1ZV90YWcyQEBcIjogXCI8c3Ryb25nPk1heGltdW08L3N0cm9uZz4tLVRoZSBsYXJnZXN0IHZhbHVlIG9mIHRoZSBpbnB1dCBjZWxscy5cIixcblx0XCJAQEFnZ3JlZ2F0ZV9hZ2dyZWdhdGlvbnRlY2huaXF1ZV90YWczQEBcIjogXCI8c3Ryb25nPk1lYW48L3N0cm9uZz4tLVRoZSBhdmVyYWdlIHZhbHVlIG9mIHRoZSBpbnB1dCBjZWxscy5cIixcblx0XCJAQEFnZ3JlZ2F0ZV9hZ2dyZWdhdGlvbnRlY2huaXF1ZV90YWc0QEBcIjogXCI8c3Ryb25nPk1lZGlhbjwvc3Ryb25nPi0tVGhlIG1lZGlhbiB2YWx1ZSBvZiB0aGUgaW5wdXQgY2VsbHMuXCIsXG5cdFwiQEBBZ2dyZWdhdGVfYWdncmVnYXRpb250ZWNobmlxdWVfdGFnNUBAXCI6IFwiPHN0cm9uZz5NaW5pbXVtPC9zdHJvbmc+LS1UaGUgc21hbGxlc3QgdmFsdWUgb2YgdGhlIGlucHV0IGNlbGxzLlwiLFxuXHRcIkBAQWdncmVnYXRlX2NlbGxmYWN0b3JfdGFnMEBAXCI6IFwiVGhlIGZhY3RvciBieSB3aGljaCB0byBtdWx0aXBseSB0aGUgY2VsbCBzaXplIG9mIHRoZSBpbnB1dCByYXN0ZXIuXCIsXG5cdFwiQEBBZ2dyZWdhdGVfY2VsbGZhY3Rvcl90YWcxQEBcIjogXCJGb3IgZXhhbXBsZSwgYSBjZWxsIGZhY3RvciB2YWx1ZSBvZiB0aHJlZSB3b3VsZCByZXN1bHQgaW4gYW4gb3V0cHV0IGNlbGwgc2l6ZSB0aHJlZSB0aW1lcyBsYXJnZXIgdGhhbiB0aGF0IG9mIHRoZSBpbnB1dCByYXN0ZXIuXCIsXG5cdFwiQEBBZ2dyZWdhdGVfZXhwYW5kZXh0ZW50aWZuZWVkZWRfdGFnMEBAXCI6IFwiRGVmaW5lcyBob3cgdG8gaGFuZGxlIHRoZSBib3VuZGFyaWVzIG9mIHRoZSBpbnB1dCByYXN0ZXIgd2hlbiBpdHMgcm93cyBvciBjb2x1bW5zIGFyZSBub3QgYSBtdWx0aXBsZSBvZiB0aGUgY2VsbCBmYWN0b3IuXCIsXG5cdFwiQEBBZ2dyZWdhdGVfZXhwYW5kZXh0ZW50aWZuZWVkZWRfdGFnMUBAXCI6IFwiQ2hlY2tlZC0tRXhwYW5kcyB0aGUgdG9wIG9yIHJpZ2h0IGJvdW5kYXJpZXMgb2YgdGhlIGlucHV0IHJhc3RlciBzbyB0aGUgdG90YWwgbnVtYmVyIG9mIGNlbGxzIGluIGEgcm93IG9yIGNvbHVtbiBpcyBhIG11bHRpcGxlIG9mIHRoZSBjZWxsIGZhY3Rvci4gV2l0aCB0aGlzIG9wdGlvbiwgdGhlIG91dHB1dCByYXN0ZXIgY2FuIGNvdmVyIGEgbGFyZ2VyIHNwYXRpYWwgZXh0ZW50IHRoYW4gdGhlIGlucHV0IHJhc3Rlci4gVGhpcyBpcyB0aGUgZGVmYXVsdC5cIixcblx0XCJAQEFnZ3JlZ2F0ZV9leHBhbmRleHRlbnRpZm5lZWRlZF90YWcyQEBcIjogXCJVbmNoZWNrZWQtLVJlZHVjZXMgdGhlIG51bWJlciBvZiByb3dzIG9yIGNvbHVtbnMgaW4gdGhlIG91dHB1dCByYXN0ZXIuIFRoaXMgdHJ1bmNhdGVzIHRoZSByZW1haW5pbmcgY2VsbHMgb24gdGhlIHRvcCBvciByaWdodCBib3VuZGFyaWVzIG9mIHRoZSBpbnB1dCByYXN0ZXIsIG1ha2luZyB0aGUgbnVtYmVyIG9mIHJvd3Mgb3IgY29sdW1ucyBpbiB0aGUgaW5wdXQgcmFzdGVyIGEgbXVsdGlwbGUgb2YgdGhlIGNlbGwgZmFjdG9yLiBXaXRoIHRoaXMgb3B0aW9uLCB0aGUgb3V0cHV0IHJhc3RlciBjYW4gY292ZXIgYSBzbWFsbGVyIHNwYXRpYWwgZXh0ZW50IHRoYW4gdGhlIGlucHV0IHJhc3Rlci5cIixcblx0XCJAQEFnZ3JlZ2F0ZV9pZ25vcmVub2RhdGFpbmNhbGN1bGF0aW9uc190YWcwQEBcIjogXCJEZW5vdGVzIHdoZXRoZXIgJHtOb0RhdGF9IHZhbHVlcyBhcmUgaWdub3JlZCBieSB0aGUgYWdncmVnYXRpb24gY2FsY3VsYXRpb24uXCIsXG5cdFwiQEBBZ2dyZWdhdGVfaWdub3Jlbm9kYXRhaW5jYWxjdWxhdGlvbnNfdGFnMUBAXCI6IFwiQ2hlY2tlZC0tU3BlY2lmaWVzIHRoYXQgaWYgJHtOb0RhdGF9IHZhbHVlcyBleGlzdCBmb3IgYW55IG9mIHRoZSBjZWxscyB0aGF0IGZhbGwgd2l0aGluIHRoZSBzcGF0aWFsIGV4dGVudCBvZiBhIGxhcmdlciBjZWxsIG9uIHRoZSBvdXRwdXQgcmFzdGVyLCB0aGUgJHtOb0RhdGF9IHZhbHVlcyB3aWxsIGJlIGlnbm9yZWQgd2hlbiBkZXRlcm1pbmluZyB0aGUgdmFsdWUgZm9yIG91dHB1dCBjZWxsIGxvY2F0aW9ucy4gT25seSBpbnB1dCBjZWxscyB3aXRoaW4gdGhlIGV4dGVudCBvZiB0aGUgb3V0cHV0IGNlbGwgdGhhdCBoYXZlIGRhdGEgdmFsdWVzIHdpbGwgYmUgdXNlZCBpbiBkZXRlcm1pbmluZyB0aGUgdmFsdWUgb2YgdGhlIG91dHB1dCBjZWxsLiBUaGlzIGlzIHRoZSBkZWZhdWx0LlwiLFxuXHRcIkBAQWdncmVnYXRlX2lnbm9yZW5vZGF0YWluY2FsY3VsYXRpb25zX3RhZzJAQFwiOiBcIlVuY2hlY2tlZC0tU3BlY2lmaWVzIHRoYXQgaWYgYW55IGNlbGwgdGhhdCBmYWxscyB3aXRoaW4gdGhlIHNwYXRpYWwgZXh0ZW50IG9mIGEgbGFyZ2VyIGNlbGwgb24gdGhlIG91dHB1dCByYXN0ZXIgaGFzIGEgdmFsdWUgb2YgJHtOb0RhdGF9LCB0aGUgdmFsdWUgZm9yIHRoYXQgb3V0cHV0IGNlbGwgbG9jYXRpb24gd2lsbCBiZSAke05vRGF0YX0uIFdoZW4gdGhlIHRoaXMgb3B0aW9uIGlzIHVzZWQsIGl0IGlzIGltcGxpZWQgdGhhdCB3aGVuIGNlbGxzIHdpdGhpbiBhbiBhZ2dyZWdhdGlvbiBjb250YWluIHRoZSAke05vRGF0YX0gdmFsdWUsIHRoZXJlIGlzIGluc3VmZmljaWVudCBpbmZvcm1hdGlvbiB0byBwZXJmb3JtIHRoZSBzcGVjaWZpZWQgY2FsY3VsYXRpb25zIG5lY2Vzc2FyeSB0byBkZXRlcm1pbmUgYW4gb3V0cHV0IHZhbHVlLlwiLFxuXHRcIkBAQWdncmVnYXRlX3Jhc3Rlcl90YWcwQEBcIjogXCJUaGUgaW5wdXQgcmFzdGVyIHRvIGJlIGFnZ3JlZ2F0ZWQuXCIsXG5cdFwiQEBFeHBhbmRfbnVtYmVyb2ZjZWxsc190YWcwQEBcIjogXCJUaGUgbnVtYmVyIG9mIGNlbGxzIHRvIGV4cGFuZCBieS5cIixcblx0XCJAQEV4cGFuZF9udW1iZXJvZmNlbGxzX3RhZzFAQFwiOiBcIlRoZSB2YWx1ZSBtdXN0IGJlIGludGVnZXIsIGFuZCBjYW4gYmUgMSBvciBncmVhdGVyLlwiLFxuXHRcIkBARXhwYW5kX3Jhc3Rlcl90YWcwQEBcIjogXCJUaGUgaW5wdXQgcmFzdGVyIGZvciB3aGljaCB0aGUgaWRlbnRpZmllZCB6b25lcyBhcmUgdG8gYmUgZXhwYW5kZWQuXCIsXG5cdFwiQEBFeHBhbmRfcmFzdGVyX3RhZzFAQFwiOiBcIkl0IG11c3QgYmUgb2YgaW50ZWdlciB0eXBlLlwiLFxuXHRcIkBARXhwYW5kX3pvbmV2YWx1ZXNfdGFnMEBAXCI6IFwiVGhlIGxpc3Qgb2Ygem9uZXMgdG8gZXhwYW5kLlwiLFxuXHRcIkBARXhwYW5kX3pvbmV2YWx1ZXNfdGFnMUBAXCI6IFwiVGhlIHpvbmUgdmFsdWVzIG11c3QgYmUgaW50ZWdlciwgYW5kIHRoZXkgY2FuIGJlIGluIGFueSBvcmRlci5cIixcblx0XCJAQEV4cGFuZF96b25ldmFsdWVzX3RhZzJAQFwiOiBcIlRvIHNwZWNpZnkgbXVsdGlwbGUgem9uZXMsIHVzZSBhIHNwYWNlIHRvIHNlcGFyYXRlIHRoZSB6b25lIHZhbHVlcy5cIixcblx0XCJAQE11bHRpZGltZW5zaW9uYWwtRmlsdGVyX2RpbWVuc2lvbl90YWcwQEBcIjogXCJUaGUgZGltZW5zaW9uIHRvIGV4dHJhY3QgdmFyaWFibGVzIGZyb20uXCIsXG5cdFwiQEBNdWx0aWRpbWVuc2lvbmFsLUZpbHRlcl9kaW1lbnNpb25kZWZpbml0aW9uX3RhZzBAQFwiOiBcIlNwZWNpZmllcyB0aGUgbWV0aG9kIHRoYXQgd2lsbCBiZSB1c2VkIHRvIHNsaWNlIHRoZSBkaW1lbnNpb24uXCIsXG5cdFwiQEBNdWx0aWRpbWVuc2lvbmFsLUZpbHRlcl9kaW1lbnNpb25kZWZpbml0aW9uX3RhZzFAQFwiOiBcIjxzdHJvbmc+QWxsPC9zdHJvbmc+LS1UaGUgZnVsbCByYW5nZSBmb3IgZWFjaCBkaW1lbnNpb24gd2lsbCBiZSB1c2VkLiBUaGlzIGlzIHRoZSBkZWZhdWx0LlwiLFxuXHRcIkBATXVsdGlkaW1lbnNpb25hbC1GaWx0ZXJfZGltZW5zaW9uZGVmaW5pdGlvbl90YWcyQEBcIjogXCI8c3Ryb25nPkJ5IFZhbHVlczwvc3Ryb25nPi0tVGhlIGRpbWVuc2lvbiB3aWxsIGJlIHNsaWNlZCB1c2luZyBhIGRpbWVuc2lvbiB2YWx1ZSBvciBsaXN0IG9mIHZhbHVlcy5cIixcblx0XCJAQE11bHRpZGltZW5zaW9uYWwtRmlsdGVyX2RpbWVuc2lvbmRlZmluaXRpb25fdGFnM0BAXCI6IFwiPHN0cm9uZz5CeSBSYW5nZXM8L3N0cm9uZz4tLVRoZSBkaW1lbnNpb24gd2lsbCBiZSBzbGljZWQgdXNpbmcgYSByYW5nZSBvciBhIGxpc3Qgb2YgcmFuZ2VzLlwiLFxuXHRcIkBATXVsdGlkaW1lbnNpb25hbC1GaWx0ZXJfZGltZW5zaW9uZGVmaW5pdGlvbl90YWc0QEBcIjogXCI8c3Ryb25nPkJ5IEl0ZXJhdGlvbjwvc3Ryb25nPi0tVGhlIGRpbWVuc2lvbiB3aWxsIGJlIHNsaWNlZCBvdmVyIGEgc3BlY2lmaWVkIGludGVydmFsIHNpemUuXCIsXG5cdFwiQEBNdWx0aWRpbWVuc2lvbmFsLUZpbHRlcl9lbmRvZmZpcnN0aXRlcmF0aW9uX3RhZzBAQFwiOiBcIlRoZSBlbmQgb2YgdGhlIGZpcnN0IGludGVydmFsLiBUaGlzIGludGVydmFsIGlzIHVzZWQgdG8gaXRlcmF0ZSB0aHJvdWdoIHRoZSBkYXRhc2V0LlRoaXMgcGFyYW1ldGVyIGlzIHJlcXVpcmVkIHdoZW4gdGhlIDxzdHJvbmc+RGltZW5zaW9uIERlZmluaXRpb248L3N0cm9uZz4gcGFyYW1ldGVyIGlzIHNldCB0byA8c3Ryb25nPkJ5IEl0ZXJhdGlvbjwvc3Ryb25nPi5cIixcblx0XCJAQE11bHRpZGltZW5zaW9uYWwtRmlsdGVyX21heGltdW12YWx1ZV90YWcwQEBcIjogXCJUaGUgbWF4aW11bSB2YWx1ZSBmb3IgdGhlIHJhbmdlLiBUaGlzIHBhcmFtZXRlciBpcyByZXF1aXJlZCB3aGVuIHRoZSA8c3Ryb25nPkRpbWVuc2lvbiBEZWZpbml0aW9uPC9zdHJvbmc+IHBhcmFtZXRlciBpcyBzZXQgdG8gPHN0cm9uZz5CeSBSYW5nZXM8L3N0cm9uZz4uXCIsXG5cdFwiQEBNdWx0aWRpbWVuc2lvbmFsLUZpbHRlcl9taW5pbXVtdmFsdWVfdGFnMEBAXCI6IFwiVGhlIG1pbmltdW0gdmFsdWUgZm9yIHRoZSByYW5nZS4gVGhpcyBwYXJhbWV0ZXIgaXMgcmVxdWlyZWQgd2hlbiB0aGUgPHN0cm9uZz5EaW1lbnNpb24gRGVmaW5pdGlvbjwvc3Ryb25nPiBwYXJhbWV0ZXIgaXMgc2V0IHRvIDxzdHJvbmc+QnkgUmFuZ2VzPC9zdHJvbmc+LlwiLFxuXHRcIkBATXVsdGlkaW1lbnNpb25hbC1GaWx0ZXJfcmFzdGVyX3RhZzBAQFwiOiBcIlRoZSBpbnB1dCBtdWx0aWRpbWVuc2lvbmFsIHJhc3Rlci5cIixcblx0XCJAQE11bHRpZGltZW5zaW9uYWwtRmlsdGVyX3Jhbmdlc190YWcwQEBcIjogXCI8cD5JbnRlcnZhbCByYW5nZXMgc3BlY2lmaWVkIGluIGEgdGFibGUgYXJlIHVzZWQgdG8gYWdncmVnYXRlIGdyb3VwcyBvZiB2YWx1ZXMuIFRoZSBtaW5pbXVtIGFuZCBtYXhpbXVtIHZhbHVlcyBzcGVjaWZ5IHRoZSByYW5nZSB0byBiZSBpbmNsdWRlZC48L3A+PHA+VGhpcyBwYXJhbWV0ZXIgaXMgcmVxdWlyZWQgd2hlbiB0aGU8c3Ryb25nPlR5cGU8L3N0cm9uZz5wYXJhbWV0ZXIgaXMgc2V0IHRvPHN0cm9uZz5JbnRlcnZhbCBSYW5nZXM8L3N0cm9uZz4uPC9wPlwiLFxuXHRcIkBATXVsdGlkaW1lbnNpb25hbC1GaWx0ZXJfc3RhcnRvZmZpcnN0aXRlcmF0aW9uX3RhZzBAQFwiOiBcIlRoZSBiZWdpbm5pbmcgb2YgdGhlIGZpcnN0IGludGVydmFsLiBUaGlzIGludGVydmFsIGlzIHVzZWQgdG8gaXRlcmF0ZSB0aHJvdWdoIHRoZSBkYXRhc2V0LlRoaXMgcGFyYW1ldGVyIGlzIHJlcXVpcmVkIHdoZW4gdGhlIDxzdHJvbmc+RGltZW5zaW9uIERlZmluaXRpb248L3N0cm9uZz4gcGFyYW1ldGVyIGlzIHNldCB0byA8c3Ryb25nPkJ5IEl0ZXJhdGlvbjwvc3Ryb25nPi5cIixcblx0XCJAQE11bHRpZGltZW5zaW9uYWwtRmlsdGVyX3N0ZXBfdGFnMEBAXCI6IFwiVGhlIGZyZXF1ZW5jeSB3aXRoIHdoaWNoIHRoZSBkYXRhIHdpbGwgYmUgc2xpY2VkLlRoaXMgcGFyYW1ldGVyIGlzIHJlcXVpcmVkIHdoZW4gdGhlIDxzdHJvbmc+RGltZW5zaW9uIERlZmluaXRpb248L3N0cm9uZz4gcGFyYW1ldGVyIGlzIHNldCB0byA8c3Ryb25nPkJ5IEl0ZXJhdGlvbjwvc3Ryb25nPi4gVGhlIGRlZmF1bHQgaXMgMy5cIixcblx0XCJAQE11bHRpZGltZW5zaW9uYWwtRmlsdGVyX3VuaXRfdGFnMEBAXCI6IFwiU3BlY2lmaWVzIHRoZSBpdGVyYXRpb24gdW5pdC4gVGhpcyBwYXJhbWV0ZXIgaXMgcmVxdWlyZWQgd2hlbiB0aGUgPHN0cm9uZz5EaW1lbnNpb24gRGVmaW5pdGlvbjwvc3Ryb25nPiBwYXJhbWV0ZXIgaXMgc2V0IHRvIDxzdHJvbmc+QnkgSXRlcmF0aW9uPC9zdHJvbmc+IGFuZCB0aGUgPHN0cm9uZz5EaW1lbnNpb248L3N0cm9uZz4gcGFyYW1ldGVyIGlzIHNldCB0byA8c3Ryb25nPlN0ZFRpbWU8L3N0cm9uZz4uXCIsXG5cdFwiQEBNdWx0aWRpbWVuc2lvbmFsLUZpbHRlcl92YWx1ZV90YWcwQEBcIjogXCJUaGUgdmFsdWUgZm9yIHRoZSBzcGVjaWZpZWQgZGltZW5zaW9uLiBUaGlzIHBhcmFtZXRlciBpcyByZXF1aXJlZCB3aGVuIHRoZSA8c3Ryb25nPkRpbWVuc2lvbiBEZWZpbml0aW9uPC9zdHJvbmc+IHBhcmFtZXRlciBpcyBzZXQgdG8gPHN0cm9uZz5CeSBWYWx1ZXM8L3N0cm9uZz4uXCIsXG5cdFwiQEBNdWx0aWRpbWVuc2lvbmFsLUZpbHRlcl92YXJpYWJsZXNfdGFnMEBAXCI6IFwiVGhlIHZhcmlhYmxlcyB0aGF0IHdpbGwgYmUgaW5jbHVkZWQgaW4gdGhlIG91dHB1dCBtdWx0aWRpbWVuc2lvbmFsIHJhc3RlciBsYXllci4gSWYgbm8gdmFyaWFibGUgaXMgc3BlY2lmaWVkLCB0aGUgZmlyc3QgdmFyaWFibGUgd2lsbCBiZSB1c2VkLlwiLFxuXHRcIkBATXVsdGlkaW1lbnNpb25hbC1GaWx0ZXJfZGltZW5zaW9ubGVzc190YWcwQEBcIjogXCJTcGVjaWZpZXMgd2hldGhlciB0aGUgbGF5ZXIgc2hvdWxkIGhhdmUgZGltZW5zaW9uIHZhbHVlcy4gVGhpcyBvcHRpb24gaXMgb25seSBhdmFpbGFibGUgaWYgYSBzaW5nbGUgc2xpY2UgaXMgc2VsZWN0ZWQgdG8gY3JlYXRlIGEgbGF5ZXIuXCIsXG5cdFwiQEBNdWx0aWRpbWVuc2lvbmFsLUZpbHRlcl9kaW1lbnNpb25sZXNzX3RhZzFAQFwiOiBcIkNoZWNrZWQtLVRoZSBsYXllciB3aWxsIG5vdCBoYXZlIGRpbWVuc2lvbiB2YWx1ZXMuXCIsXG5cdFwiQEBNdWx0aWRpbWVuc2lvbmFsLUZpbHRlcl9kaW1lbnNpb25sZXNzX3RhZzJAQFwiOiBcIlVuY2hlY2tlZC0tVGhlIGxheWVyIHdpbGwgaGF2ZSBhIGRpbWVuc2lvbiB2YWx1ZS4gVGhpcyBpcyB0aGUgZGVmYXVsdC5cIixcblx0XCJAQE11bHRpZGltZW5zaW9uYWwtUmFzdGVyX2ludGVycG9sYXRpb25jZWxsc2l6ZV90YWcwQEBcIjogXCJUaGUgY2VsbCBzaXplIG9mIHRoZSBpbnRlcnBvbGF0ZWQgcmFzdGVyLiBUaGUgZGVmYXVsdCB2YWx1ZSBpcyAkezF9LlwiLFxuXHRcIkBATXVsdGlkaW1lbnNpb25hbC1SYXN0ZXJfaW50ZXJwb2xhdGlvbm1ldGhvZF90YWcwQEBcIjogXCJUaGUgcmVzYW1wbGluZyBtZXRob2QgdXNlZCB0byBpbnRlcnBvbGF0ZSBpcnJlZ3VsYXIgZGF0YS5cIixcblx0XCJAQE11bHRpZGltZW5zaW9uYWwtUmFzdGVyX2ludGVycG9sYXRpb25tZXRob2RfdGFnMUBAXCI6IFwiPHN0cm9uZz5OZWFyZXN0IE5laWdoYm9yPC9zdHJvbmc+LS1DYWxjdWxhdGVzIHRoZSBvdXRwdXQgcGl4ZWwgdmFsdWUgdXNpbmcgdGhlIG5lYXJlc3QgaW5wdXQgcGl4ZWwuIElmIG5vIHNvdXJjZSBwaXhlbCBleGlzdHMsIG5vIG5ldyBwaXhlbCBjYW4gYmUgY3JlYXRlZCBpbiB0aGUgb3V0cHV0LiBUaGlzIGlzIHRoZSBkZWZhdWx0LlwiLFxuXHRcIkBATXVsdGlkaW1lbnNpb25hbC1SYXN0ZXJfaW50ZXJwb2xhdGlvbm1ldGhvZF90YWcyQEBcIjogXCI8c3Ryb25nPkxpbmVhciBUaW5uaW5nPC9zdHJvbmc+LS1Vc2VzIGEgdHJpYW5ndWxhdGVkIGlycmVndWxhciBuZXR3b3JrIGZyb20gdGhlIGNlbnRlciBwb2ludCBvZiBlYWNoIHBpeGVsIGluIHRoZSBpcnJlZ3VsYXIgcmFzdGVyIHRvIGludGVycG9sYXRlIGEgc3VyZmFjZSB0aGF0IGlzIHRoZW4gY29udmVydGVkIHRvIGEgcmVndWxhciByYXN0ZXIuXCIsXG5cdFwiQEBNdWx0aWRpbWVuc2lvbmFsLVJhc3Rlcl9pbnRlcnBvbGF0aW9ubWV0aG9kX3RhZzNAQFwiOiBcIjxzdHJvbmc+TmF0dXJhbCBOZWlnaGJvcjwvc3Ryb25nPi0tRmluZHMgdGhlIGNsb3Nlc3Qgc3Vic2V0IG9mIGlucHV0IHNhbXBsZXMgdG8gYSBxdWVyeSBwb2ludCBhbmQgYXBwbGllcyB3ZWlnaHRzIHRvIHRoZW0sIGJhc2VkIG9uIHByb3BvcnRpb25hdGUgYXJlYXMsIHRvIGludGVycG9sYXRlIGEgdmFsdWUuXCIsXG5cdFwiQEBNdWx0aWRpbWVuc2lvbmFsLVJhc3Rlcl9pbnRlcnBvbGF0aW9ubWV0aG9kX3RhZzRAQFwiOiBcIjxzdHJvbmc+SW52ZXJzZSBEaXN0YW5jZSBXZWlnaHRpbmc8L3N0cm9uZz4tLURldGVybWluZXMgcGl4ZWwgdmFsdWVzIHVzaW5nIGEgbGluZWFybHkgd2VpZ2h0ZWQgY29tYmluYXRpb24gb2YgYSBzZXQgb2Ygc2FtcGxlIHBvaW50cyBvciBwaXhlbHMuIFRoZSB3ZWlnaHQgaXMgYSBmdW5jdGlvbiBvZiB0aGUgaW52ZXJzZSBvZiB0aGUgZGlzdGFuY2UgZnJvbSB0aGUga25vd24gcG9pbnRzIG9yIHBpeGVscy5cIixcblx0XCJAQE11bHRpZGltZW5zaW9uYWwtUmFzdGVyX3Jhc3Rlcl90YWcwQEBcIjogXCJUaGUgaW5wdXQgbXVsdGlkaW1lbnNpb25hbCByYXN0ZXIuXCIsXG5cdFwiQEBNdWx0aWRpbWVuc2lvbmFsLVJhc3Rlcl92YXJpYWJsZXNfdGFnMEBAXCI6IFwiVGhlIHZhcmlhYmxlIG9yIHZhcmlhYmxlcyB0byBiZSBpbmNsdWRlZCBpbiB0aGUgbXVsdGlkaW1lbnNpb25hbCByYXN0ZXIgbGF5ZXIuXCIsXG5cdFwiQEBSYW5kb21fZGlzdHJpYnV0aW9uX3RhZzBAQFwiOiBcIlNwZWNpZnkgdGhlIHJhbmRvbSB2YWx1ZSBkaXN0cmlidXRpb24gbWV0aG9kIHRvIHVzZS5cIixcblx0XCJAQFJhbmRvbV9kaXN0cmlidXRpb25fdGFnMUBAXCI6IFwiPHN0cm9uZz5Vbmlmb3JtPC9zdHJvbmc+IChNaW5pbXVtLCBNYXhpbXVtKS0tQSB1bmlmb3JtIGRpc3RyaWJ1dGlvbiB3aXRoIGEgZGVmaW5lZCByYW5nZS4gVGhlIGRlZmF1bHQgdmFsdWVzIGFyZSAwIGZvciBNaW5pbXVtIGFuZCAxIGZvciBNYXhpbXVtLiBUaGlzIGlzIHRoZSBkZWZhdWx0LlwiLFxuXHRcIkBAUmFuZG9tX2Rpc3RyaWJ1dGlvbl90YWcyQEBcIjogXCI8c3Ryb25nPkludGVnZXI8L3N0cm9uZz4gKE1pbmltdW0sIE1heGltdW0pLS1BbiBpbnRlZ2VyIGRpc3RyaWJ1dGlvbiB3aXRoIGEgZGVmaW5lZCByYW5nZS4gVGhlIGRlZmF1bHQgdmFsdWVzIGFyZSAxIGZvciBNaW5pbXVtIGFuZCAxMCBmb3IgTWF4aW11bS5cIixcblx0XCJAQFJhbmRvbV9kaXN0cmlidXRpb25fdGFnM0BAXCI6IFwiPHN0cm9uZz5Ob3JtYWw8L3N0cm9uZz4gKE1lYW4sIFN0YW5kYXJkIERldmlhdGlvbiktLUEgbm9ybWFsIGRpc3RyaWJ1dGlvbiB3aXRoIGEgZGVmaW5lZCBtZWFuIGFuZCBzdGFuZGFyZCBkZXZpYXRpb24uIFRoZSBkZWZhdWx0IHZhbHVlcyBhcmUgMCBmb3IgTWVhbiBhbmQgMSBmb3IgU3RhbmRhcmQgRGV2aWF0aW9uLlwiLFxuXHRcIkBAUmFuZG9tX2Rpc3RyaWJ1dGlvbl90YWc0QEBcIjogXCI8c3Ryb25nPkV4cG9uZW50aWFsPC9zdHJvbmc+IChNZWFuKS0tQW4gZXhwb25lbnRpYWwgZGlzdHJpYnV0aW9uIHdpdGggYSBkZWZpbmVkIG1lYW4uIFRoZSBkZWZhdWx0IHZhbHVlIGlzIDEuXCIsXG5cdFwiQEBSYW5kb21fZGlzdHJpYnV0aW9uX3RhZzVAQFwiOiBcIjxzdHJvbmc+UG9pc3Nvbjwvc3Ryb25nPiAoTWVhbiktLUEgUG9pc3NvbiBkaXN0cmlidXRpb24gd2l0aCBhIGRlZmluZWQgbWVhbi4gVGhlIGRlZmF1bHQgdmFsdWUgaXMgMS5cIixcblx0XCJAQFJhbmRvbV9kaXN0cmlidXRpb25fdGFnNkBAXCI6IFwiPHN0cm9uZz5HYW1tYTwvc3Ryb25nPiAoQWxwaGEsIEJldGEpLS1BIGdhbW1hIGRpc3RyaWJ1dGlvbiB3aXRoIGEgZGVmaW5lZCBhbHBoYSBhbmQgYmV0YS4gVGhlIGRlZmF1bHQgdmFsdWVzIGFyZSAxIGZvciBBbHBoYSBhbmQgMSBmb3IgQmV0YS5cIixcblx0XCJAQFJhbmRvbV9kaXN0cmlidXRpb25fdGFnN0BAXCI6IFwiPHN0cm9uZz5CaW5vbWlhbDwvc3Ryb25nPiAoTiwgUHJvYmFiaWxpdHkpLS1BIGJpbm9taWFsIGRpc3RyaWJ1dGlvbiB3aXRoIGEgZGVmaW5lZCBOIGFuZCBwcm9iYWJpbGl0eS4gVGhlIGRlZmF1bHQgdmFsdWVzIGFyZSAxMCBmb3IgTiBhbmQgMC41IGZvciBQcm9iYWJpbGl0eS5cIixcblx0XCJAQFJhbmRvbV9kaXN0cmlidXRpb25fdGFnOEBAXCI6IFwiPHN0cm9uZz5HZW9tZXRyaWM8L3N0cm9uZz4gKFByb2JhYmlsaXR5KS0tQSBnZW9tZXRyaWMgZGlzdHJpYnV0aW9uIHdpdGggYSBkZWZpbmVkIHByb2JhYmlsaXR5LiBUaGUgZGVmYXVsdCB2YWx1ZSBpcyAwLjUuXCIsXG5cdFwiQEBSYW5kb21fZGlzdHJpYnV0aW9uX3RhZzlAQFwiOiBcIjxzdHJvbmc+TmVnYXRpdmUgQmlub21pYWw8L3N0cm9uZz4gKHIsIFByb2JhYmlsaXR5KS0tQSBQYXNjYWwgZGlzdHJpYnV0aW9uIHdpdGggYSBkZWZpbmVkIHIgYW5kIHByb2JhYmlsaXR5LiBUaGUgZGVmYXVsdCB2YWx1ZXMgYXJlIDEwLjAgZm9yIHIgYW5kIDAuNSBmb3IgUHJvYmFiaWxpdHkuXCIsXG5cdFwiQEBSYW5kb21fcmFuZG9tbnVtYmVyZ2VuZXJhdG9yX3RhZzBAQFwiOiBcIlNwZWNpZnkgdGhlIHJhbmRvbSBnZW5lcmF0b3IgYWxnb3JpdGhtIHRoYXQgdXNlcyB0aGUgc2VlZCBhbmQgZGlzdHJpYnV0aW9uIHRvIHByb2R1Y2UgYSBzZXF1ZW5jZSBvZiByYW5kb20gbnVtYmVycy4gVGhlIGF2YWlsYWJsZSBvcHRpb25zIGFyZSBhcyBmb2xsb3dzOlwiLFxuXHRcIkBAUmFuZG9tX3JhbmRvbW51bWJlcmdlbmVyYXRvcl90YWcxQEBcIjogXCJTdGFuZGFyZCBDIFJhbmRcIixcblx0XCJAQFJhbmRvbV9yYW5kb21udW1iZXJnZW5lcmF0b3JfdGFnMkBAXCI6IFwiQUNNIGNvbGxlY3RlZCBhbGdvcml0aG0gNTk5XCIsXG5cdFwiQEBSYW5kb21fcmFuZG9tbnVtYmVyZ2VuZXJhdG9yX3RhZzNAQFwiOiBcIk1lcnNlbm5lIFR3aXN0ZXJcIixcblx0XCJAQFJhbmRvbV9yYW5kb21udW1iZXJnZW5lcmF0b3JfdGFnNEBAXCI6IFwiVGhlIGRlZmF1bHQgdmFsdWUgaXMgTWVyc2VubmUgVHdpc3Rlci5cIixcblx0XCJAQFJhbmRvbV9yYXN0ZXJpbmZvX3RhZzBAQFwiOiBcIlVzZSB0aGUgPHN0cm9uZz5Mb2FkIHRlbXBsYXRlIHJhc3Rlcjwvc3Ryb25nPiBidXR0b24gdG8gbG9hZCBhIHRlbXBsYXRlIGZyb20gYSBkaXJlY3Rvcnkgb3IgcG9ydGFsLlwiLFxuXHRcIkBAUmFuZG9tX3NlZWRfdGFnMEBAXCI6IFwiVGhlIHNlZWQgaXMgYW4gaW50ZWdlciB2YWx1ZSBhbmQgaXMgdXNlZCB0byBpbml0aWF0ZSB0aGUgcmFuZG9tIG51bWJlciBnZW5lcmF0b3IuIFRoZSBkZWZhdWx0IHZhbHVlIGlzIDEuXCIsXG5cdFwiQEBTaHJpbmtfbnVtYmVyb2ZjZWxsc190YWcwQEBcIjogXCJUaGUgbnVtYmVyIG9mIGNlbGxzIGJ5IHdoaWNoIHRvIHNocmluayBlYWNoIHNwZWNpZmllZCB6b25lLlwiLFxuXHRcIkBAU2hyaW5rX251bWJlcm9mY2VsbHNfdGFnMUBAXCI6IFwiVGhlIHZhbHVlIG11c3QgYmUgaW50ZWdlciwgYW5kIGNhbiBiZSAxIG9yIGdyZWF0ZXIuXCIsXG5cdFwiQEBTaHJpbmtfcmFzdGVyX3RhZzBAQFwiOiBcIlRoZSBpbnB1dCByYXN0ZXIgZm9yIHdoaWNoIHRoZSBpZGVudGlmaWVkIHpvbmVzIGFyZSB0byBiZSBzaHJ1bmsuXCIsXG5cdFwiQEBTaHJpbmtfcmFzdGVyX3RhZzFAQFwiOiBcIkl0IG11c3QgYmUgb2YgaW50ZWdlciB0eXBlLlwiLFxuXHRcIkBAU2hyaW5rX3pvbmV2YWx1ZXNfdGFnMEBAXCI6IFwiVGhlIGxpc3Qgb2Ygem9uZXMgdG8gc2hyaW5rLlwiLFxuXHRcIkBAU2hyaW5rX3pvbmV2YWx1ZXNfdGFnMUBAXCI6IFwiVGhlIHpvbmUgdmFsdWVzIG11c3QgYmUgaW50ZWdlciwgYW5kIHRoZXkgY2FuIGJlIGluIGFueSBvcmRlci5cIixcblx0XCJAQFNocmlua196b25ldmFsdWVzX3RhZzJAQFwiOiBcIlRvIHNwZWNpZnkgbXVsdGlwbGUgem9uZXMsIHVzZSBhIHNwYWNlIHRvIHNlcGFyYXRlIHRoZSB6b25lIHZhbHVlcy5cIixcblx0XCJAQERpc3RhbmNlLUFjY3VtdWxhdGlvbl9jb3N0cmFzdGVyX3RhZzBAQFwiOiBcIkEgcmFzdGVyIGRlZmluaW5nIHRoZSBjb3N0IG9yIGltcGVkYW5jZSB0byBtb3ZlIHBsYW5pbWV0cmljYWxseSB0aHJvdWdoIGVhY2ggY2VsbC4gVGhlIHZhbHVlIGF0IGVhY2ggY2VsbCBsb2NhdGlvbiByZXByZXNlbnRzIHRoZSBjb3N0LXBlci11bml0IGRpc3RhbmNlIGZvciBtb3ZpbmcgdGhyb3VnaCBpdC4gRWFjaCBjZWxsIGxvY2F0aW9uIHZhbHVlIGlzIG11bHRpcGxpZWQgYnkgdGhlIGNlbGwgcmVzb2x1dGlvbiwgYW5kIGFsc28gY29tcGVuc2F0ZXMgZm9yIGRpYWdvbmFsIG1vdmVtZW50IHRvIG9idGFpbiB0aGUgdG90YWwgY29zdCBvZiBwYXNzaW5nIHRocm91Z2ggdGhlIGNlbGwuXCIsXG5cdFwiQEBEaXN0YW5jZS1BY2N1bXVsYXRpb25fY29zdHJhc3Rlcl90YWcxQEBcIjogXCJUaGUgdmFsdWVzIG9mIHRoZSA8c3Ryb25nPkNvc3QgUmFzdGVyPC9zdHJvbmc+IGNhbiBiZSBpbnRlZ2VyIG9yIGZsb2F0aW5nIHBvaW50LCBidXQgdGhleSBjYW5ub3QgYmUgbmVnYXRpdmUgb3IgemVyby5cIixcblx0XCJAQERpc3RhbmNlLUFjY3VtdWxhdGlvbl9kaXN0YW5jZW1ldGhvZF90YWcwQEBcIjogXCJEZXRlcm1pbmVzIHdoZXRoZXIgdG8gY2FsY3VsYXRlIHRoZSBkaXN0YW5jZSB1c2luZyBhIHBsYW5hciAoZmxhdCBlYXJ0aCkgb3IgYSBnZW9kZXNpYyAoZWxsaXBzb2lkKSBtZXRob2QuXCIsXG5cdFwiQEBEaXN0YW5jZS1BY2N1bXVsYXRpb25fZGlzdGFuY2VtZXRob2RfdGFnMUBAXCI6IFwiUGxhbmFyLS1QbGFuYXIgbWVhc3VyZW1lbnRzIHVzZSAyRCBDYXJ0ZXNpYW4gbWF0aGVtYXRpY3MgdG8gY2FsY3VsYXRlIGxlbmd0aCBhbmQgYXJlYS4gVGhlIG9wdGlvbiBpcyBvbmx5IGF2YWlsYWJsZSB3aGVuIG1lYXN1cmluZyBpbiBhIHByb2plY3RlZCBjb29yZGluYXRlIHN5c3RlbSBhbmQgdGhlIDJEIHBsYW5lIG9mIHRoYXQgY29vcmRpbmF0ZSBzeXN0ZW0gd2lsbCBiZSB1c2VkIGFzIHRoZSBiYXNpcyBmb3IgdGhlIG1lYXN1cmVtZW50cy5cIixcblx0XCJAQERpc3RhbmNlLUFjY3VtdWxhdGlvbl9kaXN0YW5jZW1ldGhvZF90YWcyQEBcIjogXCJHZW9kZXNpYy0tVGhlIHNob3J0ZXN0IGxpbmUgYmV0d2VlbiB0d28gcG9pbnRzIG9uIHRoZSBlYXJ0aCdzIHN1cmZhY2Ugb24gYSBzcGhlcm9pZCAoZWxsaXBzb2lkKS4gVGhlcmVmb3JlLCByZWdhcmRsZXNzIG9mIGlucHV0IG9yIG91dHB1dCBwcm9qZWN0aW9uLCB0aGUgcmVzdWx0cyBkbyBub3QgY2hhbmdlLlwiLFxuXHRcIkBARGlzdGFuY2UtQWNjdW11bGF0aW9uX2Rpc3RhbmNlbWV0aG9kX3RhZzNAQFwiOiBcIjxzdHJvbmc+Tm90ZTo8L3N0cm9uZz4gb25lIHVzZSBmb3IgYSBnZW9kZXNpYyBsaW5lIGlzIHdoZW4geW91IHdhbnQgdG8gZGV0ZXJtaW5lIHRoZSBzaG9ydGVzdCBkaXN0YW5jZSBiZXR3ZWVuIHR3byBjaXRpZXMgZm9yIGFuIGFpcnBsYW5lJ3MgZmxpZ2h0IHBhdGguIFRoaXMgaXMgYWxzbyBrbm93biBhcyBhIGdyZWF0IGNpcmNsZSBsaW5lIGlmIGJhc2VkIG9uIGEgc3BoZXJlIHJhdGhlciB0aGFuIGFuIGVsbGlwc29pZC5cIixcblx0XCJAQERpc3RhbmNlLUFjY3VtdWxhdGlvbl9nZW5lcmF0ZWJhY2tkaXJlY3Rpb25iYW5kYXNhZGRpdGlvbmFsYmFuZGlub3V0cHV0X3RhZzBAQFwiOiBcIkRldGVybWluZXMgd2hldGhlciBvbmx5IHRoZSBkaXN0YW5jZSBhY2N1bXVsYXRpb24gcmFzdGVyIGlzIGNyZWF0ZWQgb3IgYSBtdWx0aWJhbmQgcmFzdGVyIGNvbnNpc3Rpbmcgb2YgYm90aCB0aGUgZGlzdGFuY2UgYWNjdW11bGF0aW9uIHJhc3RlciBhbmQgdGhlIGJhY2sgZGlyZWN0aW9uIHJhc3RlciBpcyBjcmVhdGVkLlwiLFxuXHRcIkBARGlzdGFuY2UtQWNjdW11bGF0aW9uX2dlbmVyYXRlYmFja2RpcmVjdGlvbmJhbmRhc2FkZGl0aW9uYWxiYW5kaW5vdXRwdXRfdGFnMUBAXCI6IFwiVW5jaGVja2VkLS1UaGUgcmVzdWx0IGlzIHRoZSBkaXN0YW5jZSBhY2N1bXVsYXRpb24gcmFzdGVyLiBUaGlzIGlzIGEgc2luZ2xlLWJhbmQgcmVzdWx0LiBUaGlzIGlzIHRoZSBkZWZhdWx0LlwiLFxuXHRcIkBARGlzdGFuY2UtQWNjdW11bGF0aW9uX2dlbmVyYXRlYmFja2RpcmVjdGlvbmJhbmRhc2FkZGl0aW9uYWxiYW5kaW5vdXRwdXRfdGFnMkBAXCI6IFwiQ2hlY2tlZC0tQSBtdWx0aWJhbmQgcmVzdWx0IGlzIGNyZWF0ZWQuIFRoZSBmaXJzdCBiYW5kIGlzIHRoZSBkaXN0YW5jZSBhY2N1bXVsYXRpb24gcmFzdGVyIGFuZCB0aGUgc2Vjb25kIGJhbmQgaXMgdGhlIGJhY2sgZGlyZWN0aW9uIHJhc3Rlci5cIixcblx0XCJAQERpc3RhbmNlLUFjY3VtdWxhdGlvbl9nZW5lcmF0ZWJhY2tkaXJlY3Rpb25iYW5kYXNhZGRpdGlvbmFsYmFuZGlub3V0cHV0X3RhZzNAQFwiOiBcIlRoZSBiYWNrIGRpcmVjdGlvbiByYXN0ZXIgY2FsY3VsYXRlcywgZm9yIGVhY2ggY2VsbCwgdGhlIGRpcmVjdGlvbiwgaW4gZGVncmVlcywgdG8gdGhlIG5laWdoYm9yaW5nIGNlbGwgYWxvbmcgdGhlIHNob3J0ZXN0IHBhdGggYmFjayB0byB0aGUgY2xvc2VzdCBzb3VyY2Ugd2hpbGUgYXZvaWRpbmcgYmFycmllcnMuXCIsXG5cdFwiQEBEaXN0YW5jZS1BY2N1bXVsYXRpb25faG9yaXpvbnRhbGZhY3Rvcl90YWcwQEBcIjogXCI8cD5EZWZpbmVzIHRoZSByZWxhdGlvbnNoaXAgYmV0d2VlbiB0aGUgaG9yaXpvbnRhbCBjb3N0IGZhY3RvciBhbmQgdGhlIGhvcml6b250YWwgcmVsYXRpdmUgbW92aW5nIGFuZ2xlIChIUk1BKS48L3A+PHA+VGhlcmUgYXJlIHNldmVyYWwgZmFjdG9ycyB3aXRoIG1vZGlmaWVycyB0aGF0IGlkZW50aWZ5IGEgZGVmaW5lZCB2ZXJ0aWNhbCBmYWN0b3IgZ3JhcGguIEFkZGl0aW9uYWxseSwgYSB0YWJsZSBjYW4gYmUgdXNlZCB0byBjcmVhdGUgYSBjdXN0b20gZ3JhcGguIFRoZSBncmFwaHMgYXJlIHVzZWQgdG8gaWRlbnRpZnkgdGhlIHZlcnRpY2FsIGZhY3RvciB1c2VkIGluIGNhbGN1bGF0aW5nIHRoZSB0b3RhbCBjb3N0IG9mIG1vdmluZyBpbnRvIGEgbmVpZ2hib3JpbmcgY2VsbC48L3A+PHA+SW4gdGhlIGV4cGxhbmF0aW9ucyBiZWxvdywgdHdvIGFjcm9ueW1zIGFyZSB1c2VkOiBIRiBhbmQgSFJNQS4gSEYgc3RhbmRzIGZvciBob3Jpem9udGFsIGZhY3Rvciwgd2hpY2ggZGVmaW5lcyB0aGUgaG9yaXpvbnRhbCBkaWZmaWN1bHR5IGVuY291bnRlcmVkIHdoZW4gbW92aW5nIGZyb20gb25lIGNlbGwgdG8gdGhlIG5leHQuIEhSTUEgc3RhbmRzIGZvciBob3Jpem9udGFsIHJlbGF0aXZlIG1vdmluZyBhbmdsZSwgd2hpY2ggaWRlbnRpZmllcyB0aGUgYW5nbGUgYmV0d2VlbiB0aGUgaG9yaXpvbnRhbCBkaXJlY3Rpb24gZnJvbSBhIGNlbGwgYW5kIHRoZSBtb3ZpbmcgZGlyZWN0aW9uLjwvcD48cD48c3Ryb25nPkhvcml6b250YWwgZmFjdG9yPC9zdHJvbmc+dHlwZXMgaW5jbHVkZSB0aGUgZm9sbG93aW5nOjwvcD48dWw+PGxpPjxzdHJvbmc+QmluYXJ5PC9zdHJvbmc+LS1JbmRpY2F0ZXMgdGhhdCBpZiB0aGUgSFJNQSBpcyBsZXNzIHRoYW4gdGhlIGN1dCBhbmdsZSwgdGhlIEhGIGlzIHNldCB0byB0aGUgdmFsdWUgYXNzb2NpYXRlZCB3aXRoIHRoZSB6ZXJvIGZhY3Rvcjsgb3RoZXJ3aXNlLCBpdCBpcyBpbmZpbml0eS48L2xpPjxsaT48c3Ryb25nPkZvcndhcmQ8L3N0cm9uZz4tLUVzdGFibGlzaGVzIHRoYXQgb25seSBmb3J3YXJkIG1vdmVtZW50IGlzIGFsbG93ZWQuIFRoZSBIUk1BIG11c3QgYmUgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIDAgYW5kIGxlc3MgdGhhbiA5MCBkZWdyZWVzICgwICZsdDs9IEhSTUEgJmx0OyA5MCkuIElmIHRoZSBIUk1BIGlzIGdyZWF0ZXIgdGhhbiAwIGFuZCBsZXNzIHRoYW4gNDUgZGVncmVlcywgdGhlIEhGIGZvciB0aGUgY2VsbCBpcyBzZXQgdG8gdGhlIHZhbHVlIGFzc29jaWF0ZWQgd2l0aCB0aGUgemVybyBmYWN0b3IuIElmIHRoZSBIUk1BIGlzIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byA0NSBkZWdyZWVzLCB0aGUgc2lkZSB2YWx1ZSBtb2RpZmllciB2YWx1ZSBpcyB1c2VkLiBUaGUgSEYgZm9yIGFueSBIUk1BIHZhbHVlIGVxdWFsIHRvIG9yIGdyZWF0ZXIgdGhhbiA5MCBkZWdyZWVzIGlzIHNldCB0byBpbmZpbml0eS48L2xpPjxsaT48c3Ryb25nPkxpbmVhcjwvc3Ryb25nPi0tU3BlY2lmaWVzIHRoYXQgdGhlIEhGIGlzIGEgbGluZWFyIGZ1bmN0aW9uIG9mIHRoZSBIUk1BLjwvbGk+PGxpPjxzdHJvbmc+SW52ZXJzZSBMaW5lYXI8L3N0cm9uZz4tLVNwZWNpZmllcyB0aGF0IHRoZSBIRiBpcyBhbiBpbnZlcnNlIGxpbmVhciBmdW5jdGlvbiBvZiB0aGUgSFJNQS48L2xpPjxsaT48c3Ryb25nPlRhYmxlPC9zdHJvbmc+LS1JZGVudGlmaWVzIHRoYXQgYSB0YWJsZSBmaWxlIHdpbGwgYmUgdXNlZCB0byBkZWZpbmUgdGhlIGhvcml6b250YWwgZmFjdG9yIGdyYXBoIHVzZWQgdG8gZGV0ZXJtaW5lIHRoZSBIRnMuPC9saT48L3VsPjxwPk1vZGlmaWVycyB0byB0aGUgaG9yaXpvbnRhbCBmYWN0b3JzIGluY2x1ZGUgdGhlIGZvbGxvd2luZzo8L3A+PHVsPjxsaT48c3Ryb25nPlplcm8gZmFjdG9yPC9zdHJvbmc+LS1UaGUgaG9yaXpvbnRhbCBmYWN0b3IgdG8gYmUgdXNlZCB3aGVuIHRoZSBIUk1BIGlzIHplcm8uIFRoaXMgZmFjdG9yIHBvc2l0aW9ucyB0aGUgeS1pbnRlcmNlcHQgZm9yIGFueSBvZiB0aGUgaG9yaXpvbnRhbCBmYWN0b3IgZnVuY3Rpb25zLjwvbGk+PGxpPjxzdHJvbmc+Q3V0IGFuZ2xlPC9zdHJvbmc+LS1EZWZpbmVzIHRoZSBIUk1BIGFuZ2xlIGJleW9uZCB3aGljaCB0aGUgSEYgd2lsbCBiZSBzZXQgdG8gaW5maW5pdHkuPC9saT48bGk+PHN0cm9uZz5TbG9wZTwvc3Ryb25nPi0tRXN0YWJsaXNoZXMgdGhlIHNsb3BlIG9mIHRoZSBzdHJhaWdodCBsaW5lIHVzZWQgd2l0aCB0aGU8c3Ryb25nPkxpbmVhcjwvc3Ryb25nPmFuZDxzdHJvbmc+SW52ZXJzZSBMaW5lYXI8L3N0cm9uZz5ob3Jpem9udGFsIGZhY3RvciBrZXl3b3Jkcy4gVGhlIHNsb3BlIGlzIHNwZWNpZmllZCBhcyBhIGZyYWN0aW9uIG9mIHJpc2Ugb3ZlciBydW4gKGZvciBleGFtcGxlLCA0NSBwZXJjZW50IHNsb3BlIGlzIDEvNDUsIHdoaWNoIGlzIGlucHV0IGFzIDAuMDIyMjIpLjwvbGk+PGxpPjxzdHJvbmc+U2lkZSB2YWx1ZTwvc3Ryb25nPi0tRXN0YWJsaXNoZXMgdGhlIEhGIHdoZW4gdGhlIEhSTUEgaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIDQ1IGRlZ3JlZXMgYW5kIGxlc3MgdGhhbiA5MCBkZWdyZWVzIHdoZW4gdGhlPHN0cm9uZz5Gb3J3YXJkPC9zdHJvbmc+aG9yaXpvbnRhbCBmYWN0b3Iga2V5d29yZCBpcyBzcGVjaWZpZWQuPC9saT48bGk+PHN0cm9uZz5UYWJsZSBuYW1lPC9zdHJvbmc+LS1JZGVudGlmaWVzIHRoZSBuYW1lIG9mIHRoZSB0YWJsZSBkZWZpbmluZyB0aGUgSEYuPC9saT48L3VsPlwiLFxuXHRcIkBARGlzdGFuY2UtQWNjdW11bGF0aW9uX2hvcml6b250YWxyYXN0ZXJfdGFnMEBAXCI6IFwiQSByYXN0ZXIgZGVmaW5pbmcgdGhlIGhvcml6b250YWwgZGlyZWN0aW9uIGF0IGVhY2ggY2VsbC5cIixcblx0XCJAQERpc3RhbmNlLUFjY3VtdWxhdGlvbl9ob3Jpem9udGFscmFzdGVyX3RhZzFAQFwiOiBcIlRoZSB2YWx1ZXMgb24gdGhlIHJhc3RlciBtdXN0IGJlIGludGVnZXJzIHJhbmdpbmcgZnJvbSAwIHRvIDM2MCwgd2l0aCAwIGRlZ3JlZXMgYmVpbmcgbm9ydGgsIG9yIHRvd2FyZCB0aGUgdG9wIG9mIHRoZSBzY3JlZW4sIGFuZCBpbmNyZWFzaW5nIGNsb2Nrd2lzZS4gRmxhdCBhcmVhcyBzaG91bGQgYmUgZ2l2ZW4gYSB2YWx1ZSBvZiAtMS4gVGhlIHZhbHVlcyBhdCBlYWNoIGxvY2F0aW9uIHdpbGwgYmUgdXNlZCBpbiBjb25qdW5jdGlvbiB3aXRoIHRoZSA8c3Ryb25nPkhvcml6b250YWwgZmFjdG9yPC9zdHJvbmc+IHRvIGRldGVybWluZSB0aGUgaG9yaXpvbnRhbCBjb3N0IGluY3VycmVkIHdoZW4gbW92aW5nIGZyb20gYSBjZWxsIHRvIGl0cyBuZWlnaGJvcnMuXCIsXG5cdFwiQEBEaXN0YW5jZS1BY2N1bXVsYXRpb25faW5pdGlhbGFjY3VtdWxhdGlvbl90YWcwQEBcIjogXCJUaGUgaW5pdGlhbCBhY2N1bXVsYXRpdmUgY29zdCB0byBiZWdpbiB0aGUgY29zdCBjYWxjdWxhdGlvbi4gVGhpcyBwYXJhbWV0ZXIgYWxsb3dzIGZvciB0aGUgc3BlY2lmaWNhdGlvbiBvZiB0aGUgZml4ZWQgY29zdCBhc3NvY2lhdGVkIHdpdGggYSBzb3VyY2UuIEluc3RlYWQgb2Ygc3RhcnRpbmcgYXQgYSBjb3N0IG9mIDAsIHRoZSBjb3N0IGFsZ29yaXRobSB3aWxsIGJlZ2luIHdpdGggdGhlIHZhbHVlIHNwZWNpZmllZC5cIixcblx0XCJAQERpc3RhbmNlLUFjY3VtdWxhdGlvbl9pbml0aWFsYWNjdW11bGF0aW9uX3RhZzFAQFwiOiBcIkEgbnVtZXJpYyAoZG91YmxlKSB2YWx1ZSBvciBhIGZpZWxkIGZyb20gdGhlIDxzdHJvbmc+U291cmNlIFJhc3Rlcjwvc3Ryb25nPiBjYW4gYmUgdXNlZCBmb3IgdGhpcyBwYXJhbWV0ZXIuXCIsXG5cdFwiQEBEaXN0YW5jZS1BY2N1bXVsYXRpb25faW5pdGlhbGFjY3VtdWxhdGlvbl90YWcyQEBcIjogXCJUaGUgdmFsdWUgbXVzdCBiZSB6ZXJvIG9yIGdyZWF0ZXIuIFRoZSBkZWZhdWx0IGlzIDAuXCIsXG5cdFwiQEBEaXN0YW5jZS1BY2N1bXVsYXRpb25fbWF4aW11bWFjY3VtdWxhdGlvbl90YWcwQEBcIjogXCJEZWZpbmVzIHRoZSBtYXhpbXVtIGFjY3VtdWxhdGl2ZSBjb3N0IGZvciB0aGUgdHJhdmVsZXIgZm9yIGEgc291cmNlLiBUaGUgY29zdCBjYWxjdWxhdGlvbnMgY29udGludWUgZm9yIGVhY2ggc291cmNlIHVudGlsIHRoZSBzcGVjaWZpZWQgY2FwYWNpdHkgaXMgcmVhY2hlZC5cIixcblx0XCJAQERpc3RhbmNlLUFjY3VtdWxhdGlvbl9tYXhpbXVtYWNjdW11bGF0aW9uX3RhZzFAQFwiOiBcIkEgbnVtZXJpYyAoZG91YmxlKSB2YWx1ZSBvciBhIGZpZWxkIGZyb20gdGhlIDxzdHJvbmc+U291cmNlIFJhc3Rlcjwvc3Ryb25nPiBjYW4gYmUgdXNlZCBmb3IgdGhpcyBwYXJhbWV0ZXIuXCIsXG5cdFwiQEBEaXN0YW5jZS1BY2N1bXVsYXRpb25fbWF4aW11bWFjY3VtdWxhdGlvbl90YWcyQEBcIjogXCJUaGUgdmFsdWUgbXVzdCBiZSBncmVhdGVyIHRoYW4gemVyby4gVGhlIGRlZmF1bHQgY2FwYWNpdHkgaXMgdG8gdGhlIGVkZ2Ugb2YgdGhlIG91dHB1dCByYXN0ZXIuXCIsXG5cdFwiQEBEaXN0YW5jZS1BY2N1bXVsYXRpb25fbXVsdGlwbGllcnRvYXBwbHl0b2Nvc3RzX3RhZzBAQFwiOiBcIkEgbXVsdGlwbGllciB0byBhcHBseSB0byB0aGUgY29zdCB2YWx1ZXMuXCIsXG5cdFwiQEBEaXN0YW5jZS1BY2N1bXVsYXRpb25fbXVsdGlwbGllcnRvYXBwbHl0b2Nvc3RzX3RhZzFAQFwiOiBcIlRoaXMgcGFyYW1ldGVyIGFsbG93cyBmb3IgY29udHJvbCBvZiB0aGUgbW9kZSBvZiB0cmF2ZWwgb3IgdGhlIG1hZ25pdHVkZSBhdCBhIHNvdXJjZS4gVGhlIGdyZWF0ZXIgdGhlIG11bHRpcGxpZXIsIHRoZSBncmVhdGVyIHRoZSBjb3N0IHRvIG1vdmUgdGhyb3VnaCBlYWNoIGNlbGwuXCIsXG5cdFwiQEBEaXN0YW5jZS1BY2N1bXVsYXRpb25fbXVsdGlwbGllcnRvYXBwbHl0b2Nvc3RzX3RhZzJAQFwiOiBcIkEgbnVtZXJpYyAoZG91YmxlKSB2YWx1ZSBvciBhIGZpZWxkIGZyb20gdGhlIDxzdHJvbmc+U291cmNlIFJhc3Rlcjwvc3Ryb25nPiBjYW4gYmUgdXNlZCBmb3IgdGhpcyBwYXJhbWV0ZXIuXCIsXG5cdFwiQEBEaXN0YW5jZS1BY2N1bXVsYXRpb25fbXVsdGlwbGllcnRvYXBwbHl0b2Nvc3RzX3RhZzNAQFwiOiBcIlRoZSB2YWx1ZXMgbXVzdCBiZSBncmVhdGVyIHRoYW4gemVyby4gVGhlIGRlZmF1bHQgaXMgMS5cIixcblx0XCJAQERpc3RhbmNlLUFjY3VtdWxhdGlvbl9yYXN0ZXJiYXJyaWVyc190YWcwQEBcIjogXCJUaGUgcmFzdGVyIHRoYXQgZGVmaW5lcyB0aGUgYmFycmllcnMuXCIsXG5cdFwiQEBEaXN0YW5jZS1BY2N1bXVsYXRpb25fcmFzdGVyYmFycmllcnNfdGFnMUBAXCI6IFwiVGhlIGRhdGFzZXQgbXVzdCBjb250YWluIE5vRGF0YSB3aGVyZSB0aGVyZSBhcmUgbm8gYmFycmllcnMuIEJhcnJpZXJzIGFyZSByZXByZXNlbnRlZCBieSB2YWxpZCB2YWx1ZXMgaW5jbHVkaW5nIHplcm8uXCIsXG5cdFwiQEBEaXN0YW5jZS1BY2N1bXVsYXRpb25fcmFzdGVyYmFycmllcnNfdGFnMkBAXCI6IFwiVGhlIGJhcnJpZXJzIGNhbiBiZSBkZWZpbmVkIGJ5IGFuIGludGVnZXIgb3IgYSBmbG9hdGluZy1wb2ludCByYXN0ZXIuXCIsXG5cdFwiQEBEaXN0YW5jZS1BY2N1bXVsYXRpb25fc291cmNlcmFzdGVyX3RhZzBAQFwiOiBcIlRoZSBpbnB1dCBzb3VyY2UgbG9jYXRpb25zLlwiLFxuXHRcIkBARGlzdGFuY2UtQWNjdW11bGF0aW9uX3NvdXJjZXJhc3Rlcl90YWcxQEBcIjogXCJUaGlzIGlzIGEgcmFzdGVyIGRhdGFzZXQgdGhhdCBpZGVudGlmaWVzIHRoZSBjZWxscyBvciBsb2NhdGlvbnMgZnJvbSB3aGljaCB0aGUgbGVhc3QgYWNjdW11bGF0ZWQgY29zdCBkaXN0YW5jZSBmb3IgZXZlcnkgb3V0cHV0IGNlbGwgbG9jYXRpb24gaXMgY2FsY3VsYXRlZC5cIixcblx0XCJAQERpc3RhbmNlLUFjY3VtdWxhdGlvbl9zb3VyY2VyYXN0ZXJfdGFnMkBAXCI6IFwiSXQgY2FuIGJlIGFuIGludGVnZXIgb3IgYSBmbG9hdGluZy1wb2ludCB0eXBlLlwiLFxuXHRcIkBARGlzdGFuY2UtQWNjdW11bGF0aW9uX3N1cmZhY2VyYXN0ZXJfdGFnMEBAXCI6IFwiQSByYXN0ZXIgZGVmaW5pbmcgdGhlIGVsZXZhdGlvbiB2YWx1ZXMgYXQgZWFjaCBjZWxsIGxvY2F0aW9uLlwiLFxuXHRcIkBARGlzdGFuY2UtQWNjdW11bGF0aW9uX3N1cmZhY2VyYXN0ZXJfdGFnMUBAXCI6IFwiVGhlIHZhbHVlcyBhcmUgdXNlZCB0byBjYWxjdWxhdGUgdGhlIGFjdHVhbCBzdXJmYWNlIGRpc3RhbmNlIGNvdmVyZWQgd2hlbiBwYXNzaW5nIGJldHdlZW4gY2VsbHMuXCIsXG5cdFwiQEBEaXN0YW5jZS1BY2N1bXVsYXRpb25fdHJhdmVsZGlyZWN0aW9uX3RhZzBAQFwiOiBcIkRlZmluZXMgdGhlIGRpcmVjdGlvbiBvZiB0aGUgdHJhdmVsZXIgd2hlbiBhcHBseWluZyB2ZXJ0aWNhbCBmYWN0b3IsIGhvcml6b250YWwgZmFjdG9yIGFuZCB0aGUgc291cmNlIHJlc2lzdGFuY2UgcmF0ZS5cIixcblx0XCJAQERpc3RhbmNlLUFjY3VtdWxhdGlvbl90cmF2ZWxkaXJlY3Rpb25fdGFnMUBAXCI6IFwiPHN0cm9uZz5Gcm9tIFNvdXJjZTwvc3Ryb25nPi0tVGhlIHZlcnRpY2FsIGZhY3RvciwgaG9yaXpvbnRhbCBmYWN0b3IgYW5kIHNvdXJjZSByZXNpc3RhbmNlIHJhdGUgd2lsbCBiZSBhcHBsaWVkIGJlZ2lubmluZyBhdCB0aGUgaW5wdXQgc291cmNlIGFuZCBtb3Zpbmcgb3V0IHRvIHRoZSBub24tc291cmNlIGNlbGxzLiBUaGlzIGlzIHRoZSBkZWZhdWx0LlwiLFxuXHRcIkBARGlzdGFuY2UtQWNjdW11bGF0aW9uX3RyYXZlbGRpcmVjdGlvbl90YWcyQEBcIjogXCI8c3Ryb25nPlRvIFNvdXJjZTwvc3Ryb25nPi0tVGhlIHZlcnRpY2FsIGZhY3RvciwgaG9yaXpvbnRhbCBmYWN0b3IgYW5kIHNvdXJjZSByZXNpc3RhbmNlIHJhdGUgd2lsbCBiZSBhcHBsaWVkIGJlZ2lubmluZyBhdCBlYWNoIG5vbi1zb3VyY2UgY2VsbCBhbmQgbW92aW5nIGJhY2sgdG8gdGhlIGlucHV0IHNvdXJjZS5cIixcblx0XCJAQERpc3RhbmNlLUFjY3VtdWxhdGlvbl90cmF2ZWxkaXJlY3Rpb25fdGFnM0BAXCI6IFwiRWl0aGVyIHNwZWNpZnkgdGhlIDxzdHJvbmc+RnJvbSBTb3VyY2U8L3N0cm9uZz4gb3IgPHN0cm9uZz5UbyBTb3VyY2U8L3N0cm9uZz4ga2V5d29yZCwgd2hpY2ggd2lsbCBiZSBhcHBsaWVkIHRvIGFsbCBzb3VyY2VzLCBvciBzcGVjaWZ5IGEgZmllbGQgaW4gdGhlIDxzdHJvbmc+U291cmNlIFJhc3Rlcjwvc3Ryb25nPiB0aGF0IGNvbnRhaW5zIHRoZSBrZXl3b3JkcyB0byBpZGVudGlmeSB0aGUgZGlyZWN0aW9uIG9mIHRyYXZlbCBmb3IgZWFjaCBzb3VyY2UuIFRoYXQgZmllbGQgbXVzdCBjb250YWluIHRoZSBzdHJpbmcgJHtGUk9NX1NPVVJDRX0gb3IgJHtUT19TT1VSQ0V9LlwiLFxuXHRcIkBARGlzdGFuY2UtQWNjdW11bGF0aW9uX3ZlcnRpY2FsZmFjdG9yX3RhZzBAQFwiOiBcIjxwPkRlZmluZXMgdGhlIHJlbGF0aW9uc2hpcCBiZXR3ZWVuIHRoZSB2ZXJ0aWNhbCBjb3N0IGZhY3RvciBhbmQgdGhlIHZlcnRpY2FsIHJlbGF0aXZlIG1vdmluZyBhbmdsZSAoVlJNQSkuPC9wPjxwPlRoZXJlIGFyZSBzZXZlcmFsIGZhY3RvcnMgd2l0aCBtb2RpZmllcnMgdGhhdCBpZGVudGlmeSBhIGRlZmluZWQgdmVydGljYWwgZmFjdG9yIGdyYXBoLiBBZGRpdGlvbmFsbHksIGEgdGFibGUgY2FuIGJlIHVzZWQgdG8gY3JlYXRlIGEgY3VzdG9tIGdyYXBoLiBUaGUgZ3JhcGhzIGFyZSB1c2VkIHRvIGlkZW50aWZ5IHRoZSB2ZXJ0aWNhbCBmYWN0b3IgdXNlZCBpbiBjYWxjdWxhdGluZyB0aGUgdG90YWwgY29zdCBvZiBtb3ZpbmcgaW50byBhIG5laWdoYm9yaW5nIGNlbGwuPC9wPjxwPkluIHRoZSBleHBsYW5hdGlvbnMgYmVsb3csIHR3byBhY3JvbnltcyBhcmUgdXNlZDogVkYgYW5kIFZSTUEuIFZGIHN0YW5kcyBmb3IgdmVydGljYWwgZmFjdG9yLCB3aGljaCBkZWZpbmVzIHRoZSB2ZXJ0aWNhbCBkaWZmaWN1bHR5IGVuY291bnRlcmVkIGluIG1vdmluZyBmcm9tIG9uZSBjZWxsIHRvIHRoZSBuZXh0LiBWUk1BIHN0YW5kcyBmb3IgdmVydGljYWwgcmVsYXRpdmUgbW92aW5nIGFuZ2xlLCB3aGljaCBpZGVudGlmaWVzIHRoZSBzbG9wZSBhbmdsZSBiZXR3ZWVuIHRoZSBGUk9NLCBvciBwcm9jZXNzaW5nLCBjZWxsIGFuZCB0aGUgVE8gY2VsbC48L3A+PHA+PHN0cm9uZz5WZXJ0aWNhbCBmYWN0b3I8L3N0cm9uZz50eXBlcyBpbmNsdWRlIHRoZSBmb2xsb3dpbmc6PC9wPjx1bD48bGk+PHN0cm9uZz5CaW5hcnk8L3N0cm9uZz4tLVNwZWNpZmllcyB0aGF0IGlmIHRoZSBWUk1BIGlzIGdyZWF0ZXIgdGhhbiB0aGUgbG93LWN1dCBhbmdsZSBhbmQgbGVzcyB0aGFuIHRoZSBoaWdoLWN1dCBhbmdsZSwgdGhlIFZGIGlzIHNldCB0byB0aGUgdmFsdWUgYXNzb2NpYXRlZCB3aXRoIHRoZSB6ZXJvIGZhY3Rvcjsgb3RoZXJ3aXNlLCBpdCBpcyBpbmZpbml0eS48L2xpPjxsaT48c3Ryb25nPkxpbmVhcjwvc3Ryb25nPi0tSW5kaWNhdGVzIHRoYXQgdGhlIFZGIGlzIGEgbGluZWFyIGZ1bmN0aW9uIG9mIHRoZSBWUk1BLjwvbGk+PGxpPjxzdHJvbmc+U3ltbWV0cmljIExpbmVhcjwvc3Ryb25nPi0tU3BlY2lmaWVzIHRoYXQgdGhlIFZGIGlzIGEgbGluZWFyIGZ1bmN0aW9uIG9mIHRoZSBWUk1BIGluIGVpdGhlciB0aGUgbmVnYXRpdmUgb3IgcG9zaXRpdmUgc2lkZSBvZiB0aGUgVlJNQSwgcmVzcGVjdGl2ZWx5LCBhbmQgdGhlIHR3byBsaW5lYXIgZnVuY3Rpb25zIGFyZSBzeW1tZXRyaWNhbCB3aXRoIHJlc3BlY3QgdG8gdGhlIFZGICh5KSBheGlzLjwvbGk+PGxpPjxzdHJvbmc+SW52ZXJzZSBMaW5lYXI8L3N0cm9uZz4tLUluZGljYXRlcyB0aGF0IHRoZSBWRiBpcyBhbiBpbnZlcnNlIGxpbmVhciBmdW5jdGlvbiBvZiB0aGUgVlJNQS48L2xpPjxsaT48c3Ryb25nPlN5bW1ldHJpYyBJbnZlcnNlIExpbmVhcjwvc3Ryb25nPi0tU3BlY2lmaWVzIHRoYXQgdGhlIFZGIGlzIGFuIGludmVyc2UgbGluZWFyIGZ1bmN0aW9uIG9mIHRoZSBWUk1BIGluIGVpdGhlciB0aGUgbmVnYXRpdmUgb3IgcG9zaXRpdmUgc2lkZSBvZiB0aGUgVlJNQSwgcmVzcGVjdGl2ZWx5LCBhbmQgdGhlIHR3byBsaW5lYXIgZnVuY3Rpb25zIGFyZSBzeW1tZXRyaWNhbCB3aXRoIHJlc3BlY3QgdG8gdGhlIFZGICh5KSBheGlzLjwvbGk+PGxpPjxzdHJvbmc+Q29zPC9zdHJvbmc+LS1JZGVudGlmaWVzIHRoZSBWRiBhcyB0aGUgY29zaW5lLWJhc2VkIGZ1bmN0aW9uIG9mIHRoZSBWUk1BLjwvbGk+PGxpPjxzdHJvbmc+U2VjPC9zdHJvbmc+LS1JZGVudGlmaWVzIHRoZSBWRiBhcyB0aGUgc2VjYW50LWJhc2VkIGZ1bmN0aW9uIG9mIHRoZSBWUk1BLjwvbGk+PGxpPjxzdHJvbmc+Q29zLVNlYzwvc3Ryb25nPi0tU3BlY2lmaWVzIHRoYXQgdGhlIFZGIGlzIHRoZSBjb3NpbmUtYmFzZWQgZnVuY3Rpb24gb2YgdGhlIFZSTUEgd2hlbiB0aGUgVlJNQSBpcyBuZWdhdGl2ZSBhbmQgdGhlIHNlY2FudC1iYXNlZCBmdW5jdGlvbiBvZiB0aGUgVlJNQSB3aGVuIHRoZSBWUk1BIGlzIG5vdCBuZWdhdGl2ZS48L2xpPjxsaT48c3Ryb25nPlNlYy1Db3M8L3N0cm9uZz4tLVNwZWNpZmllcyB0aGF0IHRoZSBWRiBpcyB0aGUgc2VjYW50LWJhc2VkIGZ1bmN0aW9uIG9mIHRoZSBWUk1BIHdoZW4gdGhlIFZSTUEgaXMgbmVnYXRpdmUgYW5kIHRoZSBjb3NpbmUtYmFzZWQgZnVuY3Rpb24gb2YgdGhlIFZSTUEgd2hlbiB0aGUgVlJNQSBpcyBub3QgbmVnYXRpdmUuPC9saT48bGk+PHN0cm9uZz5UYWJsZTwvc3Ryb25nPi0tSWRlbnRpZmllcyB0aGF0IGEgdGFibGUgZmlsZSB3aWxsIGJlIHVzZWQgdG8gZGVmaW5lIHRoZSB2ZXJ0aWNhbC1mYWN0b3IgZ3JhcGggdGhhdCBpcyB1c2VkIHRvIGRldGVybWluZSB0aGUgVkZzLjwvbGk+PC91bD48cD5Nb2RpZmllcnMgdG8gdGhlIHZlcnRpY2FsIGtleXdvcmRzIGluY2x1ZGUgdGhlIGZvbGxvd2luZzo8L3A+PHVsPjxsaT48c3Ryb25nPlplcm8gZmFjdG9yPC9zdHJvbmc+LS1Fc3RhYmxpc2hlcyB0aGUgdmVydGljYWwgZmFjdG9yIHVzZWQgd2hlbiB0aGUgVlJNQSBpcyB6ZXJvLiBUaGlzIGZhY3RvciBwb3NpdGlvbnMgdGhlIHktaW50ZXJjZXB0IG9mIHRoZSBzcGVjaWZpZWQgZnVuY3Rpb24uIEJ5IGRlZmluaXRpb24sIHRoZSB6ZXJvIGZhY3RvciBpcyBub3QgYXBwbGljYWJsZSB0byBhbnkgb2YgdGhlIHRyaWdvbm9tZXRyaWMgdmVydGljYWwgZnVuY3Rpb25zIChDT1MsIFNFQywgQ09TLVNFQywgb3IgU0VDLUNPUykuIFRoZSB5LWludGVyY2VwdCBpcyBkZWZpbmVkIGJ5IHRoZXNlIGZ1bmN0aW9ucy48L2xpPjxsaT48c3Ryb25nPkxvdyBDdXQgYW5nbGU8L3N0cm9uZz4tLURlZmluZXMgdGhlIFZSTUEgYW5nbGUgYmVsb3cgd2hpY2ggdGhlIFZGIHdpbGwgYmUgc2V0IHRvIGluZmluaXR5LjwvbGk+PGxpPjxzdHJvbmc+SGlnaCBDdXQgYW5nbGU8L3N0cm9uZz4tLURlZmluZXMgdGhlIFZSTUEgYW5nbGUgYWJvdmUgd2hpY2ggdGhlIFZGIHdpbGwgYmUgc2V0IHRvIGluZmluaXR5LjwvbGk+PGxpPjxzdHJvbmc+U2xvcGU8L3N0cm9uZz4tLUVzdGFibGlzaGVzIHRoZSBzbG9wZSBvZiB0aGUgc3RyYWlnaHQgbGluZSB1c2VkIHdpdGggdGhlPHN0cm9uZz5MaW5lYXI8L3N0cm9uZz5hbmQ8c3Ryb25nPkludmVyc2UgTGluZWFyPC9zdHJvbmc+dmVydGljYWwtZmFjdG9yIGtleXdvcmRzLiBUaGUgc2xvcGUgaXMgc3BlY2lmaWVkIGFzIGEgZnJhY3Rpb24gb2YgcmlzZSBvdmVyIHJ1biAoZm9yIGV4YW1wbGUsIDQ1IHBlcmNlbnQgc2xvcGUgaXMgMS80NSwgd2hpY2ggaXMgaW5wdXQgYXMgMC4wMjIyMikuPC9saT48bGk+PHN0cm9uZz5UYWJsZSBuYW1lPC9zdHJvbmc+LS1JZGVudGlmaWVzIHRoZSBuYW1lIG9mIHRoZSB0YWJsZSBkZWZpbmluZyB0aGUgVkYuPC9saT48L3VsPlwiLFxuXHRcIkBARGlzdGFuY2UtQWNjdW11bGF0aW9uX3ZlcnRpY2FscmFzdGVyX3RhZzBAQFwiOiBcIkRlZmluZXMgdGhlIHJlbGF0aW9uc2hpcCBiZXR3ZWVuIHRoZSB2ZXJ0aWNhbCBjb3N0IGZhY3RvciBhbmQgdGhlIHZlcnRpY2FsIHJlbGF0aXZlIG1vdmluZyBhbmdsZSAoVlJNQSkuXCIsXG5cdFwiQEBEaXN0YW5jZS1BY2N1bXVsYXRpb25fdmVydGljYWxyYXN0ZXJfdGFnMUBAXCI6IFwiVGhlIHZhbHVlcyBhcmUgdXNlZCBmb3IgY2FsY3VsYXRpbmcgdGhlIHNsb3BlIHVzZWQgdG8gaWRlbnRpZnkgdGhlIHZlcnRpY2FsIGZhY3RvciBpbmN1cnJlZCB3aGVuIG1vdmluZyBmcm9tIG9uZSBjZWxsIHRvIGFub3RoZXIuXCIsXG5cdFwiQEBEaXN0YW5jZS1BbGxvY2F0aW9uX2Nvc3RyYXN0ZXJfdGFnMEBAXCI6IFwiQSByYXN0ZXIgZGVmaW5pbmcgdGhlIGNvc3Qgb3IgaW1wZWRhbmNlIHRvIG1vdmUgcGxhbmltZXRyaWNhbGx5IHRocm91Z2ggZWFjaCBjZWxsLiBUaGUgdmFsdWUgYXQgZWFjaCBjZWxsIGxvY2F0aW9uIHJlcHJlc2VudHMgdGhlIGNvc3QtcGVyLXVuaXQgZGlzdGFuY2UgZm9yIG1vdmluZyB0aHJvdWdoIGl0LiBFYWNoIGNlbGwgbG9jYXRpb24gdmFsdWUgaXMgbXVsdGlwbGllZCBieSB0aGUgY2VsbCByZXNvbHV0aW9uLCBhbmQgYWxzbyBjb21wZW5zYXRlcyBmb3IgZGlhZ29uYWwgbW92ZW1lbnQgdG8gb2J0YWluIHRoZSB0b3RhbCBjb3N0IG9mIHBhc3NpbmcgdGhyb3VnaCB0aGUgY2VsbC5cIixcblx0XCJAQERpc3RhbmNlLUFsbG9jYXRpb25fY29zdHJhc3Rlcl90YWcxQEBcIjogXCJUaGUgdmFsdWVzIG9mIHRoZSA8c3Ryb25nPkNvc3QgUmFzdGVyPC9zdHJvbmc+IGNhbiBiZSBpbnRlZ2VyIG9yIGZsb2F0aW5nIHBvaW50LCBidXQgdGhleSBjYW5ub3QgYmUgbmVnYXRpdmUgb3IgemVyby5cIixcblx0XCJAQERpc3RhbmNlLUFsbG9jYXRpb25fZGlzdGFuY2VtZXRob2RfdGFnMEBAXCI6IFwiRGV0ZXJtaW5lcyB3aGV0aGVyIHRvIGNhbGN1bGF0ZSB0aGUgZGlzdGFuY2UgdXNpbmcgYSBwbGFuYXIgKGZsYXQgZWFydGgpIG9yIGEgZ2VvZGVzaWMgKGVsbGlwc29pZCkgbWV0aG9kLlwiLFxuXHRcIkBARGlzdGFuY2UtQWxsb2NhdGlvbl9kaXN0YW5jZW1ldGhvZF90YWcxQEBcIjogXCJQbGFuYXItLVBsYW5hciBtZWFzdXJlbWVudHMgdXNlIDJEIENhcnRlc2lhbiBtYXRoZW1hdGljcyB0byBjYWxjdWxhdGUgbGVuZ3RoIGFuZCBhcmVhLiBUaGUgb3B0aW9uIGlzIG9ubHkgYXZhaWxhYmxlIHdoZW4gbWVhc3VyaW5nIGluIGEgcHJvamVjdGVkIGNvb3JkaW5hdGUgc3lzdGVtIGFuZCB0aGUgMkQgcGxhbmUgb2YgdGhhdCBjb29yZGluYXRlIHN5c3RlbSB3aWxsIGJlIHVzZWQgYXMgdGhlIGJhc2lzIGZvciB0aGUgbWVhc3VyZW1lbnRzLlwiLFxuXHRcIkBARGlzdGFuY2UtQWxsb2NhdGlvbl9kaXN0YW5jZW1ldGhvZF90YWcyQEBcIjogXCJHZW9kZXNpYy0tVGhlIHNob3J0ZXN0IGxpbmUgYmV0d2VlbiB0d28gcG9pbnRzIG9uIHRoZSBlYXJ0aCdzIHN1cmZhY2Ugb24gYSBzcGhlcm9pZCAoZWxsaXBzb2lkKS4gVGhlcmVmb3JlLCByZWdhcmRsZXNzIG9mIGlucHV0IG9yIG91dHB1dCBwcm9qZWN0aW9uLCB0aGUgcmVzdWx0cyBkbyBub3QgY2hhbmdlLlwiLFxuXHRcIkBARGlzdGFuY2UtQWxsb2NhdGlvbl9kaXN0YW5jZW1ldGhvZF90YWczQEBcIjogXCI8c3Ryb25nPk5vdGU6PC9zdHJvbmc+IG9uZSB1c2UgZm9yIGEgZ2VvZGVzaWMgbGluZSBpcyB3aGVuIHlvdSB3YW50IHRvIGRldGVybWluZSB0aGUgc2hvcnRlc3QgZGlzdGFuY2UgYmV0d2VlbiB0d28gY2l0aWVzIGZvciBhbiBhaXJwbGFuZSdzIGZsaWdodCBwYXRoLiBUaGlzIGlzIGFsc28ga25vd24gYXMgYSBncmVhdCBjaXJjbGUgbGluZSBpZiBiYXNlZCBvbiBhIHNwaGVyZSByYXRoZXIgdGhhbiBhbiBlbGxpcHNvaWQuXCIsXG5cdFwiQEBEaXN0YW5jZS1BbGxvY2F0aW9uX2hvcml6b250YWxmYWN0b3JfdGFnMEBAXCI6IFwiPHA+RGVmaW5lcyB0aGUgcmVsYXRpb25zaGlwIGJldHdlZW4gdGhlIGhvcml6b250YWwgY29zdCBmYWN0b3IgYW5kIHRoZSBob3Jpem9udGFsIHJlbGF0aXZlIG1vdmluZyBhbmdsZSAoSFJNQSkuPC9wPjxwPlRoZXJlIGFyZSBzZXZlcmFsIGZhY3RvcnMgd2l0aCBtb2RpZmllcnMgdGhhdCBpZGVudGlmeSBhIGRlZmluZWQgdmVydGljYWwgZmFjdG9yIGdyYXBoLiBBZGRpdGlvbmFsbHksIGEgdGFibGUgY2FuIGJlIHVzZWQgdG8gY3JlYXRlIGEgY3VzdG9tIGdyYXBoLiBUaGUgZ3JhcGhzIGFyZSB1c2VkIHRvIGlkZW50aWZ5IHRoZSB2ZXJ0aWNhbCBmYWN0b3IgdXNlZCBpbiBjYWxjdWxhdGluZyB0aGUgdG90YWwgY29zdCBvZiBtb3ZpbmcgaW50byBhIG5laWdoYm9yaW5nIGNlbGwuPC9wPjxwPkluIHRoZSBleHBsYW5hdGlvbnMgYmVsb3csIHR3byBhY3JvbnltcyBhcmUgdXNlZDogSEYgYW5kIEhSTUEuIEhGIHN0YW5kcyBmb3IgaG9yaXpvbnRhbCBmYWN0b3IsIHdoaWNoIGRlZmluZXMgdGhlIGhvcml6b250YWwgZGlmZmljdWx0eSBlbmNvdW50ZXJlZCB3aGVuIG1vdmluZyBmcm9tIG9uZSBjZWxsIHRvIHRoZSBuZXh0LiBIUk1BIHN0YW5kcyBmb3IgaG9yaXpvbnRhbCByZWxhdGl2ZSBtb3ZpbmcgYW5nbGUsIHdoaWNoIGlkZW50aWZpZXMgdGhlIGFuZ2xlIGJldHdlZW4gdGhlIGhvcml6b250YWwgZGlyZWN0aW9uIGZyb20gYSBjZWxsIGFuZCB0aGUgbW92aW5nIGRpcmVjdGlvbi48L3A+PHA+PHN0cm9uZz5Ib3Jpem9udGFsIGZhY3Rvcjwvc3Ryb25nPnR5cGVzIGluY2x1ZGUgdGhlIGZvbGxvd2luZzo8L3A+PHVsPjxsaT48c3Ryb25nPkJpbmFyeTwvc3Ryb25nPi0tSW5kaWNhdGVzIHRoYXQgaWYgdGhlIEhSTUEgaXMgbGVzcyB0aGFuIHRoZSBjdXQgYW5nbGUsIHRoZSBIRiBpcyBzZXQgdG8gdGhlIHZhbHVlIGFzc29jaWF0ZWQgd2l0aCB0aGUgemVybyBmYWN0b3I7IG90aGVyd2lzZSwgaXQgaXMgaW5maW5pdHkuPC9saT48bGk+PHN0cm9uZz5Gb3J3YXJkPC9zdHJvbmc+LS1Fc3RhYmxpc2hlcyB0aGF0IG9ubHkgZm9yd2FyZCBtb3ZlbWVudCBpcyBhbGxvd2VkLiBUaGUgSFJNQSBtdXN0IGJlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAwIGFuZCBsZXNzIHRoYW4gOTAgZGVncmVlcyAoMCAmbHQ7PSBIUk1BICZsdDsgOTApLiBJZiB0aGUgSFJNQSBpcyBncmVhdGVyIHRoYW4gMCBhbmQgbGVzcyB0aGFuIDQ1IGRlZ3JlZXMsIHRoZSBIRiBmb3IgdGhlIGNlbGwgaXMgc2V0IHRvIHRoZSB2YWx1ZSBhc3NvY2lhdGVkIHdpdGggdGhlIHplcm8gZmFjdG9yLiBJZiB0aGUgSFJNQSBpcyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gNDUgZGVncmVlcywgdGhlIHNpZGUgdmFsdWUgbW9kaWZpZXIgdmFsdWUgaXMgdXNlZC4gVGhlIEhGIGZvciBhbnkgSFJNQSB2YWx1ZSBlcXVhbCB0byBvciBncmVhdGVyIHRoYW4gOTAgZGVncmVlcyBpcyBzZXQgdG8gaW5maW5pdHkuPC9saT48bGk+PHN0cm9uZz5MaW5lYXI8L3N0cm9uZz4tLVNwZWNpZmllcyB0aGF0IHRoZSBIRiBpcyBhIGxpbmVhciBmdW5jdGlvbiBvZiB0aGUgSFJNQS48L2xpPjxsaT48c3Ryb25nPkludmVyc2UgTGluZWFyPC9zdHJvbmc+LS1TcGVjaWZpZXMgdGhhdCB0aGUgSEYgaXMgYW4gaW52ZXJzZSBsaW5lYXIgZnVuY3Rpb24gb2YgdGhlIEhSTUEuPC9saT48bGk+PHN0cm9uZz5UYWJsZTwvc3Ryb25nPi0tSWRlbnRpZmllcyB0aGF0IGEgdGFibGUgZmlsZSB3aWxsIGJlIHVzZWQgdG8gZGVmaW5lIHRoZSBob3Jpem9udGFsIGZhY3RvciBncmFwaCB1c2VkIHRvIGRldGVybWluZSB0aGUgSEZzLjwvbGk+PC91bD48cD5Nb2RpZmllcnMgdG8gdGhlIGhvcml6b250YWwgZmFjdG9ycyBpbmNsdWRlIHRoZSBmb2xsb3dpbmc6PC9wPjx1bD48bGk+PHN0cm9uZz5aZXJvIGZhY3Rvcjwvc3Ryb25nPi0tVGhlIGhvcml6b250YWwgZmFjdG9yIHRvIGJlIHVzZWQgd2hlbiB0aGUgSFJNQSBpcyB6ZXJvLiBUaGlzIGZhY3RvciBwb3NpdGlvbnMgdGhlIHktaW50ZXJjZXB0IGZvciBhbnkgb2YgdGhlIGhvcml6b250YWwgZmFjdG9yIGZ1bmN0aW9ucy48L2xpPjxsaT48c3Ryb25nPkN1dCBhbmdsZTwvc3Ryb25nPi0tRGVmaW5lcyB0aGUgSFJNQSBhbmdsZSBiZXlvbmQgd2hpY2ggdGhlIEhGIHdpbGwgYmUgc2V0IHRvIGluZmluaXR5LjwvbGk+PGxpPjxzdHJvbmc+U2xvcGU8L3N0cm9uZz4tLUVzdGFibGlzaGVzIHRoZSBzbG9wZSBvZiB0aGUgc3RyYWlnaHQgbGluZSB1c2VkIHdpdGggdGhlPHN0cm9uZz5MaW5lYXI8L3N0cm9uZz5hbmQ8c3Ryb25nPkludmVyc2UgTGluZWFyPC9zdHJvbmc+aG9yaXpvbnRhbCBmYWN0b3Iga2V5d29yZHMuIFRoZSBzbG9wZSBpcyBzcGVjaWZpZWQgYXMgYSBmcmFjdGlvbiBvZiByaXNlIG92ZXIgcnVuIChmb3IgZXhhbXBsZSwgNDUgcGVyY2VudCBzbG9wZSBpcyAxLzQ1LCB3aGljaCBpcyBpbnB1dCBhcyAwLjAyMjIyKS48L2xpPjxsaT48c3Ryb25nPlNpZGUgdmFsdWU8L3N0cm9uZz4tLUVzdGFibGlzaGVzIHRoZSBIRiB3aGVuIHRoZSBIUk1BIGlzIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byA0NSBkZWdyZWVzIGFuZCBsZXNzIHRoYW4gOTAgZGVncmVlcyB3aGVuIHRoZTxzdHJvbmc+Rm9yd2FyZDwvc3Ryb25nPmhvcml6b250YWwgZmFjdG9yIGtleXdvcmQgaXMgc3BlY2lmaWVkLjwvbGk+PGxpPjxzdHJvbmc+VGFibGUgbmFtZTwvc3Ryb25nPi0tSWRlbnRpZmllcyB0aGUgbmFtZSBvZiB0aGUgdGFibGUgZGVmaW5pbmcgdGhlIEhGLjwvbGk+PC91bD5cIixcblx0XCJAQERpc3RhbmNlLUFsbG9jYXRpb25faG9yaXpvbnRhbHJhc3Rlcl90YWcwQEBcIjogXCJBIHJhc3RlciBkZWZpbmluZyB0aGUgaG9yaXpvbnRhbCBkaXJlY3Rpb24gYXQgZWFjaCBjZWxsLlwiLFxuXHRcIkBARGlzdGFuY2UtQWxsb2NhdGlvbl9ob3Jpem9udGFscmFzdGVyX3RhZzFAQFwiOiBcIlRoZSB2YWx1ZXMgb24gdGhlIHJhc3RlciBtdXN0IGJlIGludGVnZXJzIHJhbmdpbmcgZnJvbSAwIHRvIDM2MCwgd2l0aCAwIGRlZ3JlZXMgYmVpbmcgbm9ydGgsIG9yIHRvd2FyZCB0aGUgdG9wIG9mIHRoZSBzY3JlZW4sIGFuZCBpbmNyZWFzaW5nIGNsb2Nrd2lzZS4gRmxhdCBhcmVhcyBzaG91bGQgYmUgZ2l2ZW4gYSB2YWx1ZSBvZiAtMS4gVGhlIHZhbHVlcyBhdCBlYWNoIGxvY2F0aW9uIHdpbGwgYmUgdXNlZCBpbiBjb25qdW5jdGlvbiB3aXRoIHRoZSA8c3Ryb25nPkhvcml6b250YWwgZmFjdG9yPC9zdHJvbmc+IHRvIGRldGVybWluZSB0aGUgaG9yaXpvbnRhbCBjb3N0IGluY3VycmVkIHdoZW4gbW92aW5nIGZyb20gYSBjZWxsIHRvIGl0cyBuZWlnaGJvcnMuXCIsXG5cdFwiQEBEaXN0YW5jZS1BbGxvY2F0aW9uX2luaXRpYWxhY2N1bXVsYXRpb25fdGFnMEBAXCI6IFwiVGhlIGluaXRpYWwgYWNjdW11bGF0aXZlIGNvc3QgdG8gYmVnaW4gdGhlIGNvc3QgY2FsY3VsYXRpb24uIFRoaXMgcGFyYW1ldGVyIGFsbG93cyBmb3IgdGhlIHNwZWNpZmljYXRpb24gb2YgdGhlIGZpeGVkIGNvc3QgYXNzb2NpYXRlZCB3aXRoIGEgc291cmNlLiBJbnN0ZWFkIG9mIHN0YXJ0aW5nIGF0IGEgY29zdCBvZiAwLCB0aGUgY29zdCBhbGdvcml0aG0gd2lsbCBiZWdpbiB3aXRoIHRoZSB2YWx1ZSBzcGVjaWZpZWQuXCIsXG5cdFwiQEBEaXN0YW5jZS1BbGxvY2F0aW9uX2luaXRpYWxhY2N1bXVsYXRpb25fdGFnMUBAXCI6IFwiQSBudW1lcmljIChkb3VibGUpIHZhbHVlIG9yIGEgZmllbGQgZnJvbSB0aGUgPHN0cm9uZz5Tb3VyY2UgUmFzdGVyPC9zdHJvbmc+IGNhbiBiZSB1c2VkIGZvciB0aGlzIHBhcmFtZXRlci5cIixcblx0XCJAQERpc3RhbmNlLUFsbG9jYXRpb25faW5pdGlhbGFjY3VtdWxhdGlvbl90YWcyQEBcIjogXCJUaGUgdmFsdWUgbXVzdCBiZSB6ZXJvIG9yIGdyZWF0ZXIuIFRoZSBkZWZhdWx0IGlzIDAuXCIsXG5cdFwiQEBEaXN0YW5jZS1BbGxvY2F0aW9uX21heGltdW1hY2N1bXVsYXRpb25fdGFnMEBAXCI6IFwiRGVmaW5lcyB0aGUgbWF4aW11bSBhY2N1bXVsYXRpdmUgY29zdCBmb3IgdGhlIHRyYXZlbGVyIGZvciBhIHNvdXJjZS4gVGhlIGNvc3QgY2FsY3VsYXRpb25zIGNvbnRpbnVlIGZvciBlYWNoIHNvdXJjZSB1bnRpbCB0aGUgc3BlY2lmaWVkIGNhcGFjaXR5IGlzIHJlYWNoZWQuXCIsXG5cdFwiQEBEaXN0YW5jZS1BbGxvY2F0aW9uX21heGltdW1hY2N1bXVsYXRpb25fdGFnMUBAXCI6IFwiQSBudW1lcmljIChkb3VibGUpIHZhbHVlIG9yIGEgZmllbGQgZnJvbSB0aGUgPHN0cm9uZz5Tb3VyY2UgUmFzdGVyPC9zdHJvbmc+IGNhbiBiZSB1c2VkIGZvciB0aGlzIHBhcmFtZXRlci5cIixcblx0XCJAQERpc3RhbmNlLUFsbG9jYXRpb25fbWF4aW11bWFjY3VtdWxhdGlvbl90YWcyQEBcIjogXCJUaGUgdmFsdWUgbXVzdCBiZSBncmVhdGVyIHRoYW4gemVyby4gVGhlIGRlZmF1bHQgY2FwYWNpdHkgaXMgdG8gdGhlIGVkZ2Ugb2YgdGhlIG91dHB1dCByYXN0ZXIuXCIsXG5cdFwiQEBEaXN0YW5jZS1BbGxvY2F0aW9uX211bHRpcGxpZXJ0b2FwcGx5dG9jb3N0c190YWcwQEBcIjogXCJBIG11bHRpcGxpZXIgdG8gYXBwbHkgdG8gdGhlIGNvc3QgdmFsdWVzLlwiLFxuXHRcIkBARGlzdGFuY2UtQWxsb2NhdGlvbl9tdWx0aXBsaWVydG9hcHBseXRvY29zdHNfdGFnMUBAXCI6IFwiVGhpcyBwYXJhbWV0ZXIgYWxsb3dzIGZvciBjb250cm9sIG9mIHRoZSBtb2RlIG9mIHRyYXZlbCBvciB0aGUgbWFnbml0dWRlIGF0IGEgc291cmNlLiBUaGUgZ3JlYXRlciB0aGUgbXVsdGlwbGllciwgdGhlIGdyZWF0ZXIgdGhlIGNvc3QgdG8gbW92ZSB0aHJvdWdoIGVhY2ggY2VsbC5cIixcblx0XCJAQERpc3RhbmNlLUFsbG9jYXRpb25fbXVsdGlwbGllcnRvYXBwbHl0b2Nvc3RzX3RhZzJAQFwiOiBcIlRoZSB2YWx1ZXMgbXVzdCBiZSBncmVhdGVyIHRoYW4gemVyby4gVGhlIGRlZmF1bHQgaXMgMS5cIixcblx0XCJAQERpc3RhbmNlLUFsbG9jYXRpb25fbXVsdGlwbGllcnRvYXBwbHl0b2Nvc3RzX3RhZzNAQFwiOiBcIkEgbnVtZXJpYyAoZG91YmxlKSB2YWx1ZSBvciBhIGZpZWxkIGZyb20gdGhlIDxzdHJvbmc+U291cmNlIFJhc3Rlcjwvc3Ryb25nPiBjYW4gYmUgdXNlZCBmb3IgdGhpcyBwYXJhbWV0ZXIuXCIsXG5cdFwiQEBEaXN0YW5jZS1BbGxvY2F0aW9uX3Jhc3RlcmJhcnJpZXJzX3RhZzBAQFwiOiBcIlRoZSByYXN0ZXIgdGhhdCBkZWZpbmVzIHRoZSBiYXJyaWVycy5cIixcblx0XCJAQERpc3RhbmNlLUFsbG9jYXRpb25fcmFzdGVyYmFycmllcnNfdGFnMUBAXCI6IFwiVGhlIGRhdGFzZXQgbXVzdCBjb250YWluIE5vRGF0YSB3aGVyZSB0aGVyZSBhcmUgbm8gYmFycmllcnMuIEJhcnJpZXJzIGFyZSByZXByZXNlbnRlZCBieSB2YWxpZCB2YWx1ZXMgaW5jbHVkaW5nIHplcm8uXCIsXG5cdFwiQEBEaXN0YW5jZS1BbGxvY2F0aW9uX3Jhc3RlcmJhcnJpZXJzX3RhZzJAQFwiOiBcIlRoZSBiYXJyaWVycyBjYW4gYmUgZGVmaW5lZCBieSBhbiBpbnRlZ2VyIG9yIGEgZmxvYXRpbmctcG9pbnQgcmFzdGVyLlwiLFxuXHRcIkBARGlzdGFuY2UtQWxsb2NhdGlvbl9zb3VyY2VmaWVsZF90YWcwQEBcIjogXCJUaGUgZmllbGQgdXNlZCB0byBhc3NpZ24gdmFsdWVzIHRvIHRoZSBzb3VyY2UgbG9jYXRpb25zLiBJdCBtdXN0IGJlIGFuIGludGVnZXIgdHlwZS5cIixcblx0XCJAQERpc3RhbmNlLUFsbG9jYXRpb25fc291cmNlcmFzdGVyX3RhZzBAQFwiOiBcIlRoZSBpbnB1dCBzb3VyY2UgbG9jYXRpb25zLlwiLFxuXHRcIkBARGlzdGFuY2UtQWxsb2NhdGlvbl9zb3VyY2VyYXN0ZXJfdGFnMUBAXCI6IFwiVGhpcyBpcyBhIHJhc3RlciBkYXRhc2V0IHRoYXQgaWRlbnRpZmllcyB0aGUgY2VsbHMgb3IgbG9jYXRpb25zIGZyb20gd2hpY2ggdGhlIGxlYXN0IGFjY3VtdWxhdGVkIGNvc3QgZGlzdGFuY2UgZm9yIGV2ZXJ5IG91dHB1dCBjZWxsIGxvY2F0aW9uIGlzIGNhbGN1bGF0ZWQuXCIsXG5cdFwiQEBEaXN0YW5jZS1BbGxvY2F0aW9uX3NvdXJjZXJvd2FuZGNvbHVtbmJhbmRzX3RhZzBAQFwiOiBcIkRldGVybWluZXMgd2hldGhlciBvbmx5IHRoZSBhbGxvY2F0aW9uIHJhc3RlciBpcyBjcmVhdGVkIG9yIGlmIGEgbXVsdGliYW5kIHJlc3VsdCBpcyBjcmVhdGVkLlwiLFxuXHRcIkBARGlzdGFuY2UtQWxsb2NhdGlvbl9zb3VyY2Vyb3dhbmRjb2x1bW5iYW5kc190YWcxQEBcIjogXCJVbmNoZWNrZWQtLVRoZSByZXN1bHQgaXMgdGhlIGRpc3RhbmNlIGFsbG9jYXRpb24gcmFzdGVyLiBUaGlzIGlzIGEgc2luZ2xlLWJhbmQgcmVzdWx0LiBUaGlzIGlzIHRoZSBkZWZhdWx0LlwiLFxuXHRcIkBARGlzdGFuY2UtQWxsb2NhdGlvbl9zb3VyY2Vyb3dhbmRjb2x1bW5iYW5kc190YWcyQEBcIjogXCJDaGVja2VkLS1BIG11bHRpYmFuZCByYXN0ZXIgaXMgY3JlYXRlZC4gVGhlIGZpcnN0IGJhbmQgaXMgdGhlIGRpc3RhbmNlIGFsbG9jYXRpb24gcmFzdGVyLCB0aGUgc2Vjb25kIGJhbmQgY29udGFpbnMgYSByb3cgaW5kZXggYW5kIHRoZSB0aGlyZCBiYW5kIGNvbnRhaW5zIGEgY29sdW1uIGluZGV4LiBUaGVzZSBpbmRpY2VzIGlkZW50aWZ5IHRoZSBsb2NhdGlvbiBvZiB0aGUgc291cmNlIGNlbGwgdGhhdCBpcyB0aGUgbGVhc3QgYWNjdW11bGF0ZWQgY29zdCBkaXN0YW5jZSBhd2F5LlwiLFxuXHRcIkBARGlzdGFuY2UtQWxsb2NhdGlvbl9zdXJmYWNlcmFzdGVyX3RhZzBAQFwiOiBcIkEgcmFzdGVyIGRlZmluaW5nIHRoZSBlbGV2YXRpb24gdmFsdWVzIGF0IGVhY2ggY2VsbCBsb2NhdGlvbi5cIixcblx0XCJAQERpc3RhbmNlLUFsbG9jYXRpb25fc3VyZmFjZXJhc3Rlcl90YWcxQEBcIjogXCJUaGUgdmFsdWVzIGFyZSB1c2VkIHRvIGNhbGN1bGF0ZSB0aGUgYWN0dWFsIHN1cmZhY2UgZGlzdGFuY2UgY292ZXJlZCB3aGVuIHBhc3NpbmcgYmV0d2VlbiBjZWxscy5cIixcblx0XCJAQERpc3RhbmNlLUFsbG9jYXRpb25fdHJhdmVsZGlyZWN0aW9uX3RhZzBAQFwiOiBcIkRlZmluZXMgdGhlIGRpcmVjdGlvbiBvZiB0aGUgdHJhdmVsZXIgd2hlbiBhcHBseWluZyB2ZXJ0aWNhbCBmYWN0b3IsIGhvcml6b250YWwgZmFjdG9yIGFuZCB0aGUgc291cmNlIHJlc2lzdGFuY2UgcmF0ZS5cIixcblx0XCJAQERpc3RhbmNlLUFsbG9jYXRpb25fdHJhdmVsZGlyZWN0aW9uX3RhZzFAQFwiOiBcIjxzdHJvbmc+RnJvbSBTb3VyY2U8L3N0cm9uZz4tLVRoZSB2ZXJ0aWNhbCBmYWN0b3IsIGhvcml6b250YWwgZmFjdG9yIGFuZCBzb3VyY2UgcmVzaXN0YW5jZSByYXRlIHdpbGwgYmUgYXBwbGllZCBiZWdpbm5pbmcgYXQgdGhlIGlucHV0IHNvdXJjZSBhbmQgbW92aW5nIG91dCB0byB0aGUgbm9uLXNvdXJjZSBjZWxscy4gVGhpcyBpcyB0aGUgZGVmYXVsdC5cIixcblx0XCJAQERpc3RhbmNlLUFsbG9jYXRpb25fdHJhdmVsZGlyZWN0aW9uX3RhZzJAQFwiOiBcIjxzdHJvbmc+VG8gU291cmNlPC9zdHJvbmc+LS1UaGUgdmVydGljYWwgZmFjdG9yLCBob3Jpem9udGFsIGZhY3RvciBhbmQgc291cmNlIHJlc2lzdGFuY2UgcmF0ZSB3aWxsIGJlIGFwcGxpZWQgYmVnaW5uaW5nIGF0IGVhY2ggbm9uLXNvdXJjZSBjZWxsIGFuZCBtb3ZpbmcgYmFjayB0byB0aGUgaW5wdXQgc291cmNlLlwiLFxuXHRcIkBARGlzdGFuY2UtQWxsb2NhdGlvbl90cmF2ZWxkaXJlY3Rpb25fdGFnM0BAXCI6IFwiRWl0aGVyIHNwZWNpZnkgdGhlIDxzdHJvbmc+RnJvbSBTb3VyY2U8L3N0cm9uZz4gb3IgPHN0cm9uZz5UbyBTb3VyY2U8L3N0cm9uZz4ga2V5d29yZCwgd2hpY2ggd2lsbCBiZSBhcHBsaWVkIHRvIGFsbCBzb3VyY2VzLCBvciBzcGVjaWZ5IGEgZmllbGQgaW4gdGhlIDxzdHJvbmc+U291cmNlIFJhc3Rlcjwvc3Ryb25nPiB0aGF0IGNvbnRhaW5zIHRoZSBrZXl3b3JkcyB0byBpZGVudGlmeSB0aGUgZGlyZWN0aW9uIG9mIHRyYXZlbCBmb3IgZWFjaCBzb3VyY2UuIFRoYXQgZmllbGQgbXVzdCBjb250YWluIHRoZSBzdHJpbmcgJHtGUk9NX1NPVVJDRX0gb3IgJHtUT19TT1VSQ0V9LlwiLFxuXHRcIkBARGlzdGFuY2UtQWxsb2NhdGlvbl92ZXJ0aWNhbGZhY3Rvcl90YWcwQEBcIjogXCI8cD5EZWZpbmVzIHRoZSByZWxhdGlvbnNoaXAgYmV0d2VlbiB0aGUgdmVydGljYWwgY29zdCBmYWN0b3IgYW5kIHRoZSB2ZXJ0aWNhbCByZWxhdGl2ZSBtb3ZpbmcgYW5nbGUgKFZSTUEpLjwvcD48cD5UaGVyZSBhcmUgc2V2ZXJhbCBmYWN0b3JzIHdpdGggbW9kaWZpZXJzIHRoYXQgaWRlbnRpZnkgYSBkZWZpbmVkIHZlcnRpY2FsIGZhY3RvciBncmFwaC4gQWRkaXRpb25hbGx5LCBhIHRhYmxlIGNhbiBiZSB1c2VkIHRvIGNyZWF0ZSBhIGN1c3RvbSBncmFwaC4gVGhlIGdyYXBocyBhcmUgdXNlZCB0byBpZGVudGlmeSB0aGUgdmVydGljYWwgZmFjdG9yIHVzZWQgaW4gY2FsY3VsYXRpbmcgdGhlIHRvdGFsIGNvc3Qgb2YgbW92aW5nIGludG8gYSBuZWlnaGJvcmluZyBjZWxsLjwvcD48cD5JbiB0aGUgZXhwbGFuYXRpb25zIGJlbG93LCB0d28gYWNyb255bXMgYXJlIHVzZWQ6IFZGIGFuZCBWUk1BLiBWRiBzdGFuZHMgZm9yIHZlcnRpY2FsIGZhY3Rvciwgd2hpY2ggZGVmaW5lcyB0aGUgdmVydGljYWwgZGlmZmljdWx0eSBlbmNvdW50ZXJlZCBpbiBtb3ZpbmcgZnJvbSBvbmUgY2VsbCB0byB0aGUgbmV4dC4gVlJNQSBzdGFuZHMgZm9yIHZlcnRpY2FsIHJlbGF0aXZlIG1vdmluZyBhbmdsZSwgd2hpY2ggaWRlbnRpZmllcyB0aGUgc2xvcGUgYW5nbGUgYmV0d2VlbiB0aGUgRlJPTSwgb3IgcHJvY2Vzc2luZywgY2VsbCBhbmQgdGhlIFRPIGNlbGwuPC9wPjxwPjxzdHJvbmc+VmVydGljYWwgZmFjdG9yPC9zdHJvbmc+dHlwZXMgaW5jbHVkZSB0aGUgZm9sbG93aW5nOjwvcD48dWw+PGxpPjxzdHJvbmc+QmluYXJ5PC9zdHJvbmc+LS1TcGVjaWZpZXMgdGhhdCBpZiB0aGUgVlJNQSBpcyBncmVhdGVyIHRoYW4gdGhlIGxvdy1jdXQgYW5nbGUgYW5kIGxlc3MgdGhhbiB0aGUgaGlnaC1jdXQgYW5nbGUsIHRoZSBWRiBpcyBzZXQgdG8gdGhlIHZhbHVlIGFzc29jaWF0ZWQgd2l0aCB0aGUgemVybyBmYWN0b3I7IG90aGVyd2lzZSwgaXQgaXMgaW5maW5pdHkuPC9saT48bGk+PHN0cm9uZz5MaW5lYXI8L3N0cm9uZz4tLUluZGljYXRlcyB0aGF0IHRoZSBWRiBpcyBhIGxpbmVhciBmdW5jdGlvbiBvZiB0aGUgVlJNQS48L2xpPjxsaT48c3Ryb25nPlN5bW1ldHJpYyBMaW5lYXI8L3N0cm9uZz4tLVNwZWNpZmllcyB0aGF0IHRoZSBWRiBpcyBhIGxpbmVhciBmdW5jdGlvbiBvZiB0aGUgVlJNQSBpbiBlaXRoZXIgdGhlIG5lZ2F0aXZlIG9yIHBvc2l0aXZlIHNpZGUgb2YgdGhlIFZSTUEsIHJlc3BlY3RpdmVseSwgYW5kIHRoZSB0d28gbGluZWFyIGZ1bmN0aW9ucyBhcmUgc3ltbWV0cmljYWwgd2l0aCByZXNwZWN0IHRvIHRoZSBWRiAoeSkgYXhpcy48L2xpPjxsaT48c3Ryb25nPkludmVyc2UgTGluZWFyPC9zdHJvbmc+LS1JbmRpY2F0ZXMgdGhhdCB0aGUgVkYgaXMgYW4gaW52ZXJzZSBsaW5lYXIgZnVuY3Rpb24gb2YgdGhlIFZSTUEuPC9saT48bGk+PHN0cm9uZz5TeW1tZXRyaWMgSW52ZXJzZSBMaW5lYXI8L3N0cm9uZz4tLVNwZWNpZmllcyB0aGF0IHRoZSBWRiBpcyBhbiBpbnZlcnNlIGxpbmVhciBmdW5jdGlvbiBvZiB0aGUgVlJNQSBpbiBlaXRoZXIgdGhlIG5lZ2F0aXZlIG9yIHBvc2l0aXZlIHNpZGUgb2YgdGhlIFZSTUEsIHJlc3BlY3RpdmVseSwgYW5kIHRoZSB0d28gbGluZWFyIGZ1bmN0aW9ucyBhcmUgc3ltbWV0cmljYWwgd2l0aCByZXNwZWN0IHRvIHRoZSBWRiAoeSkgYXhpcy48L2xpPjxsaT48c3Ryb25nPkNvczwvc3Ryb25nPi0tSWRlbnRpZmllcyB0aGUgVkYgYXMgdGhlIGNvc2luZS1iYXNlZCBmdW5jdGlvbiBvZiB0aGUgVlJNQS48L2xpPjxsaT48c3Ryb25nPlNlYzwvc3Ryb25nPi0tSWRlbnRpZmllcyB0aGUgVkYgYXMgdGhlIHNlY2FudC1iYXNlZCBmdW5jdGlvbiBvZiB0aGUgVlJNQS48L2xpPjxsaT48c3Ryb25nPkNvcy1TZWM8L3N0cm9uZz4tLVNwZWNpZmllcyB0aGF0IHRoZSBWRiBpcyB0aGUgY29zaW5lLWJhc2VkIGZ1bmN0aW9uIG9mIHRoZSBWUk1BIHdoZW4gdGhlIFZSTUEgaXMgbmVnYXRpdmUgYW5kIHRoZSBzZWNhbnQtYmFzZWQgZnVuY3Rpb24gb2YgdGhlIFZSTUEgd2hlbiB0aGUgVlJNQSBpcyBub3QgbmVnYXRpdmUuPC9saT48bGk+PHN0cm9uZz5TZWMtQ29zPC9zdHJvbmc+LS1TcGVjaWZpZXMgdGhhdCB0aGUgVkYgaXMgdGhlIHNlY2FudC1iYXNlZCBmdW5jdGlvbiBvZiB0aGUgVlJNQSB3aGVuIHRoZSBWUk1BIGlzIG5lZ2F0aXZlIGFuZCB0aGUgY29zaW5lLWJhc2VkIGZ1bmN0aW9uIG9mIHRoZSBWUk1BIHdoZW4gdGhlIFZSTUEgaXMgbm90IG5lZ2F0aXZlLjwvbGk+PGxpPjxzdHJvbmc+VGFibGU8L3N0cm9uZz4tLUlkZW50aWZpZXMgdGhhdCBhIHRhYmxlIGZpbGUgd2lsbCBiZSB1c2VkIHRvIGRlZmluZSB0aGUgdmVydGljYWwtZmFjdG9yIGdyYXBoIHRoYXQgaXMgdXNlZCB0byBkZXRlcm1pbmUgdGhlIFZGcy48L2xpPjwvdWw+PHA+TW9kaWZpZXJzIHRvIHRoZSB2ZXJ0aWNhbCBrZXl3b3JkcyBpbmNsdWRlIHRoZSBmb2xsb3dpbmc6PC9wPjx1bD48bGk+PHN0cm9uZz5aZXJvIGZhY3Rvcjwvc3Ryb25nPi0tRXN0YWJsaXNoZXMgdGhlIHZlcnRpY2FsIGZhY3RvciB1c2VkIHdoZW4gdGhlIFZSTUEgaXMgemVyby4gVGhpcyBmYWN0b3IgcG9zaXRpb25zIHRoZSB5LWludGVyY2VwdCBvZiB0aGUgc3BlY2lmaWVkIGZ1bmN0aW9uLiBCeSBkZWZpbml0aW9uLCB0aGUgemVybyBmYWN0b3IgaXMgbm90IGFwcGxpY2FibGUgdG8gYW55IG9mIHRoZSB0cmlnb25vbWV0cmljIHZlcnRpY2FsIGZ1bmN0aW9ucyAoQ09TLCBTRUMsIENPUy1TRUMsIG9yIFNFQy1DT1MpLiBUaGUgeS1pbnRlcmNlcHQgaXMgZGVmaW5lZCBieSB0aGVzZSBmdW5jdGlvbnMuPC9saT48bGk+PHN0cm9uZz5Mb3cgQ3V0IGFuZ2xlPC9zdHJvbmc+LS1EZWZpbmVzIHRoZSBWUk1BIGFuZ2xlIGJlbG93IHdoaWNoIHRoZSBWRiB3aWxsIGJlIHNldCB0byBpbmZpbml0eS48L2xpPjxsaT48c3Ryb25nPkhpZ2ggQ3V0IGFuZ2xlPC9zdHJvbmc+LS1EZWZpbmVzIHRoZSBWUk1BIGFuZ2xlIGFib3ZlIHdoaWNoIHRoZSBWRiB3aWxsIGJlIHNldCB0byBpbmZpbml0eS48L2xpPjxsaT48c3Ryb25nPlNsb3BlPC9zdHJvbmc+LS1Fc3RhYmxpc2hlcyB0aGUgc2xvcGUgb2YgdGhlIHN0cmFpZ2h0IGxpbmUgdXNlZCB3aXRoIHRoZTxzdHJvbmc+TGluZWFyPC9zdHJvbmc+YW5kPHN0cm9uZz5JbnZlcnNlIExpbmVhcjwvc3Ryb25nPnZlcnRpY2FsLWZhY3RvciBrZXl3b3Jkcy4gVGhlIHNsb3BlIGlzIHNwZWNpZmllZCBhcyBhIGZyYWN0aW9uIG9mIHJpc2Ugb3ZlciBydW4gKGZvciBleGFtcGxlLCA0NSBwZXJjZW50IHNsb3BlIGlzIDEvNDUsIHdoaWNoIGlzIGlucHV0IGFzIDAuMDIyMjIpLjwvbGk+PGxpPjxzdHJvbmc+VGFibGUgbmFtZTwvc3Ryb25nPi0tSWRlbnRpZmllcyB0aGUgbmFtZSBvZiB0aGUgdGFibGUgZGVmaW5pbmcgdGhlIFZGLjwvbGk+PC91bD5cIixcblx0XCJAQERpc3RhbmNlLUFsbG9jYXRpb25fdmVydGljYWxyYXN0ZXJfdGFnMEBAXCI6IFwiRGVmaW5lcyB0aGUgcmVsYXRpb25zaGlwIGJldHdlZW4gdGhlIHZlcnRpY2FsIGNvc3QgZmFjdG9yIGFuZCB0aGUgdmVydGljYWwgcmVsYXRpdmUgbW92aW5nIGFuZ2xlIChWUk1BKS5cIixcblx0XCJAQERpc3RhbmNlLUFsbG9jYXRpb25fdmVydGljYWxyYXN0ZXJfdGFnMUBAXCI6IFwiVGhlIHZhbHVlcyBhcmUgdXNlZCBmb3IgY2FsY3VsYXRpbmcgdGhlIHNsb3BlIHVzZWQgdG8gaWRlbnRpZnkgdGhlIHZlcnRpY2FsIGZhY3RvciBpbmN1cnJlZCB3aGVuIG1vdmluZyBmcm9tIG9uZSBjZWxsIHRvIGFub3RoZXIuXCIsXG5cdFwiQEBFdWNsaWRlYW4tQmFjay1EaXJlY3Rpb25fY2VsbHNpemVfdGFnMEBAXCI6IFwiVGhlIGNlbGwgc2l6ZSBhdCB3aGljaCB0aGUgb3V0cHV0IHJhc3RlciB3aWxsIGJlIGNyZWF0ZWQuXCIsXG5cdFwiQEBFdWNsaWRlYW4tQmFjay1EaXJlY3Rpb25fY2VsbHNpemVfdGFnMUBAXCI6IFwiSWYgdGhlIGNlbGwgc2l6ZSB3YXMgZXhwbGljaXRseSBzZXQgaW4gPHN0cm9uZz5FbnZpcm9ubWVudHM8L3N0cm9uZz4sIHRoYXQgd2lsbCBiZSB0aGUgZGVmYXVsdCBjZWxsIHNpemUuIElmIGl0IHdhcyBub3Qgc2V0LCB0aGUgb3V0cHV0IGNlbGwgc2l6ZSB3aWxsIGJlIHRoZSBzYW1lIGFzIHRoZSA8c3Ryb25nPlNvdXJjZSBSYXN0ZXI8L3N0cm9uZz4uXCIsXG5cdFwiQEBFdWNsaWRlYW4tQmFjay1EaXJlY3Rpb25fZGlzdGFuY2VtZXRob2RfdGFnMEBAXCI6IFwiRGV0ZXJtaW5lcyB3aGV0aGVyIHRvIGNhbGN1bGF0ZSB0aGUgZGlzdGFuY2UgdXNpbmcgYSBwbGFuYXIgKGZsYXQgZWFydGgpIG9yIGEgZ2VvZGVzaWMgKGVsbGlwc29pZCkgbWV0aG9kLlwiLFxuXHRcIkBARXVjbGlkZWFuLUJhY2stRGlyZWN0aW9uX2Rpc3RhbmNlbWV0aG9kX3RhZzFAQFwiOiBcIlBsYW5hci0tUGxhbmFyIG1lYXN1cmVtZW50cyB1c2UgMkQgQ2FydGVzaWFuIG1hdGhlbWF0aWNzIHRvIGNhbGN1bGF0ZSBsZW5ndGggYW5kIGFyZWEuIFRoZSBvcHRpb24gaXMgb25seSBhdmFpbGFibGUgd2hlbiBtZWFzdXJpbmcgaW4gYSBwcm9qZWN0ZWQgY29vcmRpbmF0ZSBzeXN0ZW0gYW5kIHRoZSAyRCBwbGFuZSBvZiB0aGF0IGNvb3JkaW5hdGUgc3lzdGVtIHdpbGwgYmUgdXNlZCBhcyB0aGUgYmFzaXMgZm9yIHRoZSBtZWFzdXJlbWVudHMuXCIsXG5cdFwiQEBFdWNsaWRlYW4tQmFjay1EaXJlY3Rpb25fZGlzdGFuY2VtZXRob2RfdGFnMkBAXCI6IFwiR2VvZGVzaWMtLVRoZSBzaG9ydGVzdCBsaW5lIGJldHdlZW4gdHdvIHBvaW50cyBvbiB0aGUgZWFydGgncyBzdXJmYWNlIG9uIGEgc3BoZXJvaWQgKGVsbGlwc29pZCkuIFRoZXJlZm9yZSwgcmVnYXJkbGVzcyBvZiBpbnB1dCBvciBvdXRwdXQgcHJvamVjdGlvbiwgdGhlIHJlc3VsdHMgZG8gbm90IGNoYW5nZS5cIixcblx0XCJAQEV1Y2xpZGVhbi1CYWNrLURpcmVjdGlvbl9kaXN0YW5jZW1ldGhvZF90YWczQEBcIjogXCI8c3Ryb25nPk5vdGU6PC9zdHJvbmc+IG9uZSB1c2UgZm9yIGEgZ2VvZGVzaWMgbGluZSBpcyB3aGVuIHlvdSB3YW50IHRvIGRldGVybWluZSB0aGUgc2hvcnRlc3QgZGlzdGFuY2UgYmV0d2VlbiB0d28gY2l0aWVzIGZvciBhbiBhaXJwbGFuZSdzIGZsaWdodCBwYXRoLiBUaGlzIGlzIGFsc28ga25vd24gYXMgYSBncmVhdCBjaXJjbGUgbGluZSBpZiBiYXNlZCBvbiBhIHNwaGVyZSByYXRoZXIgdGhhbiBhbiBlbGxpcHNvaWQuXCIsXG5cdFwiQEBFdWNsaWRlYW4tQmFjay1EaXJlY3Rpb25fbWF4aW11bWRpc3RhbmNlX3RhZzBAQFwiOiBcIkRlZmluZXMgdGhlIHRocmVzaG9sZCBkaXN0YW5jZSB3aXRoaW4gd2hpY2ggdGhlIGRpcmVjdGlvbiB0byB0aGUgY2xvc2VzdCBzb3VyY2Ugd2lsbCBiZSBjYWxjdWxhdGVkLiBJZiB0aGUgZGlzdGFuY2UgdG8gdGhlIG5lYXJlc3Qgc291cmNlIGV4Y2VlZHMgdGhpcywgdGhlIG91dHB1dCBmb3IgdGhhdCBjZWxsIHdpbGwgYmUgTm9EYXRhLlwiLFxuXHRcIkBARXVjbGlkZWFuLUJhY2stRGlyZWN0aW9uX21heGltdW1kaXN0YW5jZV90YWcxQEBcIjogXCJUaGUgZGVmYXVsdCBkaXN0YW5jZSBpcyB0byB0aGUgZXh0ZW50IG9mIHRoZSBvdXRwdXQgcmFzdGVyLlwiLFxuXHRcIkBARXVjbGlkZWFuLUJhY2stRGlyZWN0aW9uX3Jhc3RlcmJhcnJpZXJzX3RhZzBAQFwiOiBcIlRoZSByYXN0ZXIgdGhhdCBkZWZpbmVzIHRoZSBiYXJyaWVycy5cIixcblx0XCJAQEV1Y2xpZGVhbi1CYWNrLURpcmVjdGlvbl9yYXN0ZXJiYXJyaWVyc190YWcxQEBcIjogXCJUaGUgZGF0YXNldCBtdXN0IGNvbnRhaW4gTm9EYXRhIHdoZXJlIHRoZXJlIGFyZSBubyBiYXJyaWVycy4gQmFycmllcnMgYXJlIHJlcHJlc2VudGVkIGJ5IHZhbGlkIHZhbHVlcyBpbmNsdWRpbmcgemVyby5cIixcblx0XCJAQEV1Y2xpZGVhbi1CYWNrLURpcmVjdGlvbl9yYXN0ZXJiYXJyaWVyc190YWcyQEBcIjogXCJUaGUgYmFycmllcnMgY2FuIGJlIGRlZmluZWQgYnkgYW4gaW50ZWdlciBvciBhIGZsb2F0aW5nLXBvaW50IHJhc3Rlci5cIixcblx0XCJAQEV1Y2xpZGVhbi1CYWNrLURpcmVjdGlvbl9zb3VyY2VyYXN0ZXJfdGFnMEBAXCI6IFwiQSByYXN0ZXIgZGF0YXNldCB0aGF0IGlkZW50aWZpZXMgdGhlIGNlbGxzIG9yIGxvY2F0aW9ucyB0byB3aGljaCB0aGUgRXVjbGlkZWFuIGRpcmVjdGlvbiBmb3IgZXZlcnkgb3V0cHV0IGNlbGwgbG9jYXRpb24gaXMgY2FsY3VsYXRlZC5cIixcblx0XCJAQEV1Y2xpZGVhbi1CYWNrLURpcmVjdGlvbl9zb3VyY2VyYXN0ZXJfdGFnMUBAXCI6IFwiVGhlIGlucHV0IHR5cGUgY2FuIGJlIGFuIGludGVnZXIgb3IgYSBmbG9hdGluZy1wb2ludCB0eXBlLlwiLFxuXHRcIkBAQ29zdC1QYXRoX2Nvc3RiYWNrbGlua3Jhc3Rlcl90YWcwQEBcIjogXCJUaGUgbmFtZSBvZiBhIGNvc3QgYmFja2xpbmsgcmFzdGVyIGxheWVyIHVzZWQgdG8gZGV0ZXJtaW5lIHRoZSBwYXRoIHRvIHJldHVybiB0byBhIHNvdXJjZSB2aWEgdGhlIGxlYXN0LWNvc3QgcGF0aC5cIixcblx0XCJAQENvc3QtUGF0aF9jb3N0YmFja2xpbmtyYXN0ZXJfdGFnMUBAXCI6IFwiRm9yIGVhY2ggY2VsbCBpbiB0aGUgYmFja2xpbmsgcmFzdGVyLCBhIHZhbHVlIGlkZW50aWZpZXMgdGhlIG5laWdoYm9yIHRoYXQncyB0aGUgbmV4dCBjZWxsIG9uIHRoZSBsZWFzdCBhY2N1bXVsYXRpdmUgY29zdCBwYXRoIGZyb20gdGhlIGNlbGwgdG8gYSBzaW5nbGUgc291cmNlIGNlbGwgb3Igc2V0IG9mIHNvdXJjZSBjZWxscy5cIixcblx0XCJAQENvc3QtUGF0aF9jb3N0ZGlzdGFuY2VyYXN0ZXJfdGFnMEBAXCI6IFwiVGhlIG5hbWUgb2YgYSBjb3N0IGRpc3RhbmNlIHJhc3RlciB0byBiZSB1c2VkIHRvIGRldGVybWluZSB0aGUgbGVhc3QtY29zdCBwYXRoIGZyb20gdGhlIGRlc3RpbmF0aW9uIGxvY2F0aW9ucyB0byBhIHNvdXJjZS5cIixcblx0XCJAQENvc3QtUGF0aF9jb3N0ZGlzdGFuY2VyYXN0ZXJfdGFnMUBAXCI6IFwiVGhlIGNvc3QgZGlzdGFuY2UgcmFzdGVyIGlzIHVzdWFsbHkgY3JlYXRlZCB3aXRoIHRoZSBDb3N0IERpc3RhbmNlLCBDb3N0IEFsbG9jYXRpb24sIG9yIENvc3QgQmFjayBMaW5rIGZ1bmN0aW9uLiBUaGUgY29zdCBkaXN0YW5jZSByYXN0ZXIgbGF5ZXIgc3RvcmVzLCBmb3IgZWFjaCBjZWxsLCB0aGUgbWluaW11bSBhY2N1bXVsYXRpdmUgY29zdCBkaXN0YW5jZSBvdmVyIGEgY29zdCBzdXJmYWNlIGZyb20gZWFjaCBjZWxsIHRvIGEgc2V0IG9mIHNvdXJjZSBjZWxscy5cIixcblx0XCJAQENvc3QtUGF0aF9kZXN0aW5hdGlvbmZpZWxkX3RhZzBAQFwiOiBcIlRoZSBmaWVsZCB1c2VkIHRvIG9idGFpbiB2YWx1ZXMgZm9yIHRoZSBkZXN0aW5hdGlvbiBsb2NhdGlvbnMuIElucHV0IGZlYXR1cmUgZGF0YSBtdXN0IGNvbnRhaW4gYXQgbGVhc3Qgb25lIHZhbGlkIGZpZWxkLlwiLFxuXHRcIkBAQ29zdC1QYXRoX2Rlc3RpbmF0aW9ucmFzdGVyX3RhZzBAQFwiOiBcIkEgcmFzdGVyIGRhdGFzZXQgbGF5ZXIgdGhhdCBpZGVudGlmaWVzIHRob3NlIGNlbGxzIGZyb20gd2hpY2ggdGhlIGxlYXN0LWNvc3QgcGF0aCBpcyBkZXRlcm1pbmVkIHRvIHRoZSBsZWFzdCBjb3N0bHkgc291cmNlLlwiLFxuXHRcIkBAQ29zdC1QYXRoX2Rlc3RpbmF0aW9ucmFzdGVyX3RhZzFAQFwiOiBcIlRoZSBpbnB1dCByYXN0ZXIgbGF5ZXIgY29uc2lzdHMgb2YgY2VsbHMgdGhhdCBoYXZlIHZhbGlkIHZhbHVlcyAoemVybyBpcyBhIHZhbGlkIHZhbHVlKSwgYW5kIHRoZSByZW1haW5pbmcgY2VsbHMgbXVzdCBiZSBhc3NpZ25lZCBOb0RhdGEuXCIsXG5cdFwiQEBDb3N0LVBhdGhfZm9yY2VmbG93ZGlyZWN0aW9uY29udmVudGlvbmZvcmJhY2tsaW5rcmFzdGVyX3RhZzBAQFwiOiBcIkZvcmNlcyB0aGUgZnVuY3Rpb24gdG8gdHJlYXQgdGhlIGlucHV0IGJhY2tsaW5rIHJhc3RlciBhcyBhIGZsb3cgZGlyZWN0aW9uIHJhc3Rlci4gRmxvdyBkaXJlY3Rpb24gcmFzdGVycyBjYW4gaGF2ZSBpbnRlZ2VyIHdpdGggdmFsdWVzIGZyb20gMC0yNTUuXCIsXG5cdFwiQEBDb3N0LVBhdGhfZm9yY2VmbG93ZGlyZWN0aW9uY29udmVudGlvbmZvcmJhY2tsaW5rcmFzdGVyX3RhZzFAQFwiOiBcIlVuY2hlY2tlZC0tSWYgdGhlIHZhbHVlcyBvZiB0aGUgb2YgdGhlIHNwZWNpZmllZCBiYWNrbGluayByYXN0ZXIgYXJlIGludGVnZXJzIGluIHRoZSByYW5nZSBvZiAwLTgsIHRoZSBkYXRhc2V0IHdpbGwgYmUgdHJlYXRlZCBhcyBhIGNvc3QgYmFja2xpbmsgcmFzdGVyLiBJZiB0aGUgdmFsdWVzIGFyZSBmcm9tIDAtMjU1LCB0aGUgaW5wdXQgd2lsbCBiZSB0cmVhdGVkIGFzIGEgZmxvdyBkaXJlY3Rpb24gcmFzdGVyLiBJZiB0aGUgdmFsdWVzIGFyZSBmcm9tIDAtMzYwIGFuZCBmbG9hdGluZyBwb2ludCwgdGhlIGlucHV0IHdpbGwgYmUgdHJlYXRlZCBhcyBhIGJhY2sgZGlyZWN0aW9uIHJhc3Rlci5cIixcblx0XCJAQENvc3QtUGF0aF9mb3JjZWZsb3dkaXJlY3Rpb25jb252ZW50aW9uZm9yYmFja2xpbmtyYXN0ZXJfdGFnMkBAXCI6IFwiQ2hlY2tlZC0tVGhlIHJhc3RlciBzdXBwbGllZCBmb3IgdGhlIGJhY2tsaW5rIHJhc3RlciB3aWxsIGJlIHRyZWF0ZWQgYXMgYSBmbG93IGRpcmVjdGlvbiByYXN0ZXIuIFVzZSB0aGlzIG9wdGlvbiBvZiB0aGUgZmxvdyBkaXJlY3Rpb24gcmFzdGVyIGhhcHBlbnMgdG8gaGF2ZSBhIG1heGltdW0gdmFsdWUgb2YgOCBvciBsZXNzLlwiLFxuXHRcIkBAQ29zdC1QYXRoX3BhdGh0eXBlX3RhZzBAQFwiOiBcIkEga2V5d29yZCBkZWZpbmluZyB0aGUgbWFubmVyIGluIHdoaWNoIHRoZSB2YWx1ZXMgYW5kIHpvbmVzIG9uIHRoZSBpbnB1dCBkZXN0aW5hdGlvbiBkYXRhIHdpbGwgYmUgaW50ZXJwcmV0ZWQgaW4gdGhlIGNvc3QgcGF0aCBjYWxjdWxhdGlvbnMuIFRoZSBvcHRpb25zIGFyZSBhcyBmb2xsb3dzOlwiLFxuXHRcIkBAQ29zdC1QYXRoX3BhdGh0eXBlX3RhZzFAQFwiOiBcIjxzdHJvbmc+RWFjaCBDZWxsPC9zdHJvbmc+LS1Gb3IgZWFjaCBjZWxsIHdpdGggdmFsaWQgdmFsdWVzIG9uIHRoZSBpbnB1dCBkZXN0aW5hdGlvbiBkYXRhLCBhIGxlYXN0LWNvc3QgcGF0aCBpcyBkZXRlcm1pbmVkIGFuZCBzYXZlZCBvbiB0aGUgb3V0cHV0IHJhc3Rlci4gV2l0aCB0aGlzIG9wdGlvbiwgZWFjaCBjZWxsIG9mIHRoZSBpbnB1dCBkZXN0aW5hdGlvbiBkYXRhIGlzIHRyZWF0ZWQgc2VwYXJhdGVseSwgYW5kIGEgbGVhc3QtY29zdCBwYXRoIGlzIGRldGVybWluZWQgZm9yIGVhY2ggY2VsbC5cIixcblx0XCJAQENvc3QtUGF0aF9wYXRodHlwZV90YWcyQEBcIjogXCI8c3Ryb25nPkVhY2ggWm9uZTwvc3Ryb25nPi0tRm9yIGVhY2ggem9uZSBvbiB0aGUgaW5wdXQgZGVzdGluYXRpb24gZGF0YSwgYSBsZWFzdC1jb3N0IHBhdGggaXMgZGV0ZXJtaW5lZCBhbmQgc2F2ZWQgb24gdGhlIG91dHB1dCByYXN0ZXIuIFdpdGggdGhpcyBvcHRpb24sIHRoZSBsZWFzdC1jb3N0IHBhdGggZm9yIGVhY2ggem9uZSBiZWdpbnMgYXQgdGhlIGNlbGwgd2l0aCB0aGUgbG93ZXN0IGNvc3QgZGlzdGFuY2Ugd2VpZ2h0aW5nIGluIHRoZSB6b25lLlwiLFxuXHRcIkBAQ29zdC1QYXRoX3BhdGh0eXBlX3RhZzNAQFwiOiBcIjxzdHJvbmc+QmVzdCBTaW5nbGU8L3N0cm9uZz4tLUZvciBhbGwgY2VsbHMgb24gdGhlIGlucHV0IGRlc3RpbmF0aW9uIGRhdGEsIHRoZSBsZWFzdC1jb3N0IHBhdGggaXMgZGVyaXZlZCBmcm9tIHRoZSBjZWxsIHdpdGggdGhlIG1pbmltdW0gb2YgdGhlIGxlYXN0LWNvc3QgcGF0aHMgdG8gc291cmNlIGNlbGxzLlwiLFxuXHRcIkBAQ2VsbC1TdGF0aXN0aWNzX2NlbGxzaXpldHlwZV90YWcwQEBcIjogXCJDaG9vc2Ugd2hpY2ggY2VsbCBzaXplIHRvIHVzZSBpbiB0aGUgb3V0cHV0IHJhc3Rlci4gSWYgYWxsIHRoZSBpbnB1dCBjZWxsIHNpemVzIGFyZSB0aGUgc2FtZSwgYWxsIHRoZSBvcHRpb25zIHdpbGwgeWllbGQgdGhlIHNhbWUgcmVzdWx0cy5cIixcblx0XCJAQENlbGwtU3RhdGlzdGljc19jZWxsc2l6ZXR5cGVfdGFnMUBAXCI6IFwiRmlyc3QgT2YtLVVzZSB0aGUgZmlyc3QgY2VsbCBzaXplIG9mIHRoZSBpbnB1dCByYXN0ZXJzLlwiLFxuXHRcIkBAQ2VsbC1TdGF0aXN0aWNzX2NlbGxzaXpldHlwZV90YWcyQEBcIjogXCJNaW4gT2YtLVVzZSB0aGUgc21hbGxlc3QgY2VsbCBzaXplIG9mIGFsbCB0aGUgaW5wdXQgcmFzdGVycy5cIixcblx0XCJAQENlbGwtU3RhdGlzdGljc19jZWxsc2l6ZXR5cGVfdGFnM0BAXCI6IFwiTWF4IE9mLS1Vc2UgdGhlIGxhcmdlc3QgY2VsbCBzaXplIG9mIGFsbCB0aGUgaW5wdXQgcmFzdGVycy4gVGhpcyBpcyB0aGUgZGVmYXVsdC5cIixcblx0XCJAQENlbGwtU3RhdGlzdGljc19jZWxsc2l6ZXR5cGVfdGFnNEBAXCI6IFwiTWVhbiBPZi0tVXNlIHRoZSBtZWFuIGNlbGwgc2l6ZSBvZiBhbGwgdGhlIGlucHV0IHJhc3RlcnMuXCIsXG5cdFwiQEBDZWxsLVN0YXRpc3RpY3NfY2VsbHNpemV0eXBlX3RhZzVAQFwiOiBcIkxhc3QgT2YtLVVzZSB0aGUgbGFzdCBjZWxsIHNpemUgb2YgdGhlIGlucHV0IHJhc3RlcnMuXCIsXG5cdFwiQEBDZWxsLVN0YXRpc3RpY3NfZXh0ZW50dHlwZV90YWcwQEBcIjogXCJDaG9vc2Ugd2hpY2ggZXh0ZW50IHNob3VsZCBiZSB1c2VkIGluIHRoZSBvdXRwdXQgcmFzdGVyOlwiLFxuXHRcIkBAQ2VsbC1TdGF0aXN0aWNzX2V4dGVudHR5cGVfdGFnMUBAXCI6IFwiRmlyc3QgT2YtLVVzZSB0aGUgZXh0ZW50IG9mIHRoZSBmaXJzdCBpbnB1dCByYXN0ZXIgdG8gZGV0ZXJtaW5lIHRoZSBwcm9jZXNzaW5nIGV4dGVudC5cIixcblx0XCJAQENlbGwtU3RhdGlzdGljc19leHRlbnR0eXBlX3RhZzJAQFwiOiBcIkludGVyc2VjdGlvbiBPZi0tVXNlIHRoZSBleHRlbnQgb2YgdGhlIG92ZXJsYXBwaW5nIHBpeGVscyB0byBkZXRlcm1pbmUgdGhlIHByb2Nlc3NpbmcgZXh0ZW50LiBUaGlzIGlzIHRoZSBkZWZhdWx0LlwiLFxuXHRcIkBAQ2VsbC1TdGF0aXN0aWNzX2V4dGVudHR5cGVfdGFnM0BAXCI6IFwiVW5pb24gT2YtLVVzZSB0aGUgZXh0ZW50IG9mIGFsbCB0aGUgcmFzdGVycyB0byBkZXRlcm1pbmUgdGhlIHByb2Nlc3NpbmcgZXh0ZW50LlwiLFxuXHRcIkBAQ2VsbC1TdGF0aXN0aWNzX2V4dGVudHR5cGVfdGFnNEBAXCI6IFwiTGFzdCBPZi0tVXNlIHRoZSBleHRlbnQgb2YgdGhlIGxhc3QgaW5wdXQgcmFzdGVyIHRvIGRldGVybWluZSB0aGUgcHJvY2Vzc2luZyBleHRlbnQuXCIsXG5cdFwiQEBDZWxsLVN0YXRpc3RpY3NfcHJvY2Vzc2FzbXVsdGliYW5kX3RhZzBAQFwiOiBcIkRldGVybWluZXMgaG93IHRoZSBpbnB1dCByYXN0ZXJzIGJhbmRzIGFyZSBwcm9jZXNzZWQuXCIsXG5cdFwiQEBDZWxsLVN0YXRpc3RpY3NfcHJvY2Vzc2FzbXVsdGliYW5kX3RhZzFAQFwiOiBcIlVuY2hlY2tlZC0tQWxsIG11bHRpYmFuZCBpbnB1dHMgd2lsbCBiZSBwcm9jZXNzZWQgYXMgc2luZ2xlIGJhbmRzLiBUaGlzIGlzIHRoZSBkZWZhdWx0LlwiLFxuXHRcIkBAQ2VsbC1TdGF0aXN0aWNzX3Byb2Nlc3Nhc211bHRpYmFuZF90YWcyQEBcIjogXCJDaGVja2VkLS1BbGwgbXVsdGliYW5kIGlucHV0cyB3aWxsIGJlIHByb2Nlc3NlZCBhcyBtdWx0aWJhbmQuXCIsXG5cdFwiQEBDZWxsLVN0YXRpc3RpY3NfcmFzdGVyc190YWcwQEBcIjogXCJUaGUgbGlzdCBvZiByYXN0ZXJzIGZyb20gd2hpY2ggdG8gY2FsY3VsYXRlIHN0YXRpc3RpY3MsIG9uIGEgcGl4ZWwtYnktcGl4ZWwgYmFzaXMuXCIsXG5cdFwiQEBDZWxsLVN0YXRpc3RpY3NfcGVyY2VudGlsZWludGVycG9sYXRpb250eXBlX3RhZzBAQFwiOiBcIjxwPlNwZWNpZmllcyB0aGUgbWV0aG9kIG9mIGludGVycG9sYXRpb24gdG8gYmUgdXNlZCB3aGVuIHRoZSBzcGVjaWZpZWQgcGVyY2VudGlsZSB2YWx1ZSBsaWVzIGJldHdlZW4gdHdvIGlucHV0IGNlbGwgdmFsdWVzLjwvcD48dWw+PGxpPjxzdHJvbmc+QXV0by1kZXRlY3Q8L3N0cm9uZz4tLUlmIHRoZSBpbnB1dCByYXN0ZXJzIGFyZSBvZiBpbnRlZ2VyIHBpeGVsIHR5cGUsIHRoZTxzdHJvbmc+TmVhcmVzdDwvc3Ryb25nPm1ldGhvZCBpcyB1c2VkLiBJZiB0aGUgaW5wdXQgcmFzdGVyIGlzIG9mIGZsb2F0aW5nIHBvaW50IHBpeGVsIHR5cGUsIHRoZW4gdGhlPHN0cm9uZz5MaW5lYXI8L3N0cm9uZz5tZXRob2QgaXMgdXNlZC4gVGhpcyBpcyB0aGUgZGVmYXVsdC48L2xpPjxsaT48c3Ryb25nPk5lYXJlc3Q8L3N0cm9uZz4tLVRoZSBuZWFyZXN0IGF2YWlsYWJsZSB2YWx1ZSB0byB0aGUgZGVzaXJlZCBwZXJjZW50aWxlIGlzIHVzZWQuIEluIHRoaXMgY2FzZSwgdGhlIG91dHB1dCBwaXhlbCB0eXBlIGlzIHRoZSBzYW1lIGFzIHRoYXQgb2YgdGhlIGlucHV0IHZhbHVlIHJhc3RlcnMuPC9saT48bGk+PHN0cm9uZz5MaW5lYXI8L3N0cm9uZz4tLVRoZSB3ZWlnaHRlZCBhdmVyYWdlIG9mIHRoZSB0d28gc3Vycm91bmRpbmcgdmFsdWVzIGZyb20gdGhlIGRlc2lyZWQgcGVyY2VudGlsZSBpcyB1c2VkLiBJbiB0aGlzIGNhc2UsIHRoZSBvdXRwdXQgcGl4ZWwgdHlwZSBpcyBmbG9hdGluZyBwb2ludC48L2xpPjwvdWw+PHA+VGhpcyBvcHRpb24gaXMgb25seSBhdmFpbGFibGUgaWYgdGhlPHN0cm9uZz5PcGVyYXRpb248L3N0cm9uZz50eXBlIHBhcmFtZXRlciBpcyBzZXQgdG88c3Ryb25nPk1lZGlhbjwvc3Ryb25nPm9yPHN0cm9uZz5QZXJjZW50aWxlPC9zdHJvbmc+LjwvcD5cIixcblx0XCJAQENlbGwtU3RhdGlzdGljc19wZXJjZW50aWxldmFsdWVfdGFnMEBAXCI6IFwiPHA+VGhlIHBlcmNlbnRpbGUgdG8gY2FsY3VsYXRlLiBUaGUgZGVmYXVsdCBpcyA5MCwgZm9yIHRoZSA5MHRoIHBlcmNlbnRpbGUuPC9wPjxwPlRoZSB2YWx1ZXMgY2FuIHJhbmdlIGZyb20gMCB0aHJvdWdoIDEwMC4gVGhlIDB0aCBwZXJjZW50aWxlIGlzIGVzc2VudGlhbGx5IGVxdWl2YWxlbnQgdG8gdGhlIG1pbmltdW0gc3RhdGlzdGljLCBhbmQgdGhlIDEwMHRoIHBlcmNlbnRpbGUgaXMgZXF1aXZhbGVudCB0byBtYXhpbXVtLiBBIHZhbHVlIG9mIDUwIHdpbGwgcHJvZHVjZSBlc3NlbnRpYWxseSB0aGUgc2FtZSByZXN1bHQgYXMgdGhlIG1lZGlhbiBzdGF0aXN0aWMuPC9wPjxwPlRoaXMgb3B0aW9uIGlzIG9ubHkgYXZhaWxhYmxlIGlmIHRoZTxzdHJvbmc+T3BlcmF0aW9uPC9zdHJvbmc+cGFyYW1ldGVyIGlzIHNldCB0bzxzdHJvbmc+UGVyY2VudGlsZTwvc3Ryb25nPi48L3A+XCIsXG5cdFwiQEBPcHRpbWFsLVBhdGgtQXMtUmFzdGVyX2JhY2tkaXJlY3Rpb25yYXN0ZXJvcmZsb3dkaXJlY3Rpb25yYXN0ZXJfdGFnMEBAXCI6IFwiVGhlIGJhY2sgZGlyZWN0aW9uIHJhc3RlciBjb250YWlucyBjYWxjdWxhdGVkIGRpcmVjdGlvbnMgaW4gZGVncmVlcy4gVGhlIGRpcmVjdGlvbiBpZGVudGlmaWVzIHRoZSBuZXh0IGNlbGwgYWxvbmcgdGhlIG9wdGltYWwgcGF0aCBiYWNrIHRvIHRoZSBsZWFzdCBhY2N1bXVsYXRpdmUgY29zdCBzb3VyY2Ugd2hpbGUgYXZvaWRpbmcgYmFycmllcnMuXCIsXG5cdFwiQEBPcHRpbWFsLVBhdGgtQXMtUmFzdGVyX2JhY2tkaXJlY3Rpb25yYXN0ZXJvcmZsb3dkaXJlY3Rpb25yYXN0ZXJfdGFnMUBAXCI6IFwiVGhlIHJhbmdlIG9mIHZhbHVlcyBpcyBmcm9tIDAgZGVncmVlcyB0byAzNjAgZGVncmVlcywgd2l0aCAwIHJlc2VydmVkIGZvciB0aGUgc291cmNlIGNlbGxzLiBEdWUgZWFzdCAocmlnaHQpIGlzIDkwLCBhbmQgdGhlIHZhbHVlcyBpbmNyZWFzZSBjbG9ja3dpc2UgKDE4MCBpcyBzb3V0aCwgMjcwIGlzIHdlc3QsIGFuZCAzNjAgaXMgbm9ydGgpLlwiLFxuXHRcIkBAT3B0aW1hbC1QYXRoLUFzLVJhc3Rlcl9kZXN0aW5hdGlvbmZpZWxkX3RhZzBAQFwiOiBcIlRoZSBmaWVsZCB1c2VkIHRvIG9idGFpbiB2YWx1ZXMgZm9yIHRoZSBkZXN0aW5hdGlvbiBsb2NhdGlvbnMuXCIsXG5cdFwiQEBPcHRpbWFsLVBhdGgtQXMtUmFzdGVyX2Rlc3RpbmF0aW9ucmFzdGVyX3RhZzBAQFwiOiBcIkEgcmFzdGVyIGRhdGFzZXQgbGF5ZXIgdGhhdCBpZGVudGlmaWVzIHRob3NlIGNlbGxzIGZyb20gd2hpY2ggdGhlIG9wdGltdW0gcGF0aCBpcyBkZXRlcm1pbmVkIHRvIHRoZSBsZWFzdCBjb3N0bHkgc291cmNlLiBUaGlzIGlucHV0IGlzIHJlcXVpcmVkLlwiLFxuXHRcIkBAT3B0aW1hbC1QYXRoLUFzLVJhc3Rlcl9kZXN0aW5hdGlvbnJhc3Rlcl90YWcxQEBcIjogXCJUaGUgaW5wdXQgcmFzdGVyIGxheWVyIGNvbnNpc3RzIG9mIGNlbGxzIHRoYXQgaGF2ZSB2YWxpZCB2YWx1ZXMgKHplcm8gaXMgYSB2YWxpZCB2YWx1ZSksIGFuZCB0aGUgcmVtYWluaW5nIGNlbGxzIG11c3QgYmUgYXNzaWduZWQgTm9EYXRhLlwiLFxuXHRcIkBAT3B0aW1hbC1QYXRoLUFzLVJhc3Rlcl9kaXN0YW5jZWFjY3VtdWxhdGlvbnJhc3Rlcl90YWcwQEBcIjogXCJUaGUgZGlzdGFuY2UgYWNjdW11bGF0aW9uIHJhc3RlciBpcyB1c2VkIHRvIGRldGVybWluZSB0aGUgb3B0aW1hbCBwYXRoIGZyb20gdGhlIGRlc3RpbmF0aW9ucyB0byB0aGUgc291cmNlcy4gVGhlIGRpc3RhbmNlIGFjY3VtdWxhdGlvbiByYXN0ZXIgaXMgdXN1YWxseWNyZWF0ZWQgd2l0aCB0aGUgPHN0cm9uZz5EaXN0YW5jZSBBY2N1bXVsYXRpb248L3N0cm9uZz4gZnVuY3Rpb24uIEVhY2ggY2VsbCBpbiB0aGUgZGlzdGFuY2UgYWNjdW11bGF0aW9ucmFzdGVyIHJlcHJlc2VudHMgdGhlIG1pbmltdW0gYWNjdW11bGF0aXZlIGNvc3QgZGlzdGFuY2Ugb3ZlciBhc3VyZmFjZSBmcm9tIGVhY2ggY2VsbCB0byBhIHNldCBvZiBzb3VyY2UgY2VsbHMuXCIsXG5cdFwiQEBPcHRpbWFsLVBhdGgtQXMtUmFzdGVyX3BhdGh0eXBlX3RhZzBAQFwiOiBcIlNwZWNpZmllcyBhIGtleXdvcmQgZGVmaW5pbmcgdGhlIG1hbm5lciBpbiB3aGljaCB0aGUgdmFsdWVzIGFuZCB6b25lcyBvbiB0aGUgaW5wdXQgZGVzdGluYXRpb24gZGF0YSB3aWxsIGJlIGludGVycHJldGVkIGluIHRoZSBjb3N0IHBhdGggY2FsY3VsYXRpb25zLlwiLFxuXHRcIkBAT3B0aW1hbC1QYXRoLUFzLVJhc3Rlcl9wYXRodHlwZV90YWcxQEBcIjogXCI8c3Ryb25nPkVhY2ggWm9uZTwvc3Ryb25nPi0tRm9yIGVhY2ggem9uZSBvbiB0aGUgaW5wdXQgZGVzdGluYXRpb24gZGF0YSwgYSBsZWFzdC1jb3N0IHBhdGggaXMgZGV0ZXJtaW5lZCBhbmQgc2F2ZWQgb24gdGhlIG91dHB1dCByYXN0ZXIuIFdpdGggdGhpcyBvcHRpb24sIHRoZSBvcHRpbWFsIHBhdGggZm9yIGVhY2ggem9uZSBiZWdpbnMgYXQgdGhlIGNlbGwgd2l0aCB0aGUgbG93ZXN0IGNvc3QgZGlzdGFuY2Ugd2VpZ2h0aW5nIGluIHRoZSB6b25lLlwiLFxuXHRcIkBAT3B0aW1hbC1QYXRoLUFzLVJhc3Rlcl9wYXRodHlwZV90YWcyQEBcIjogXCI8c3Ryb25nPkJlc3QgU2luZ2xlPC9zdHJvbmc+LS1Gb3IgYWxsIGNlbGxzIG9uIHRoZSBpbnB1dCBkZXN0aW5hdGlvbiBkYXRhLCB0aGUgb3B0aW1hbCBwYXRoIGlzIGRlcml2ZWQgZnJvbSB0aGUgY2VsbCB3aXRoIHRoZSBtaW5pbXVtIG9mIHRoZSBsZWFzdC1jb3N0IHBhdGhzIHRvIHNvdXJjZSBjZWxscy5cIixcblx0XCJAQE9wdGltYWwtUGF0aC1Bcy1SYXN0ZXJfcGF0aHR5cGVfdGFnM0BAXCI6IFwiPHN0cm9uZz5FYWNoIENlbGw8L3N0cm9uZz4tLUZvciBlYWNoIGNlbGwgd2l0aCB2YWxpZCB2YWx1ZXMgb24gdGhlIGlucHV0IGRlc3RpbmF0aW9uIGRhdGEsIGFuIG9wdGltYWwgcGF0aCBpcyBkZXRlcm1pbmVkLiBXaXRoIHRoaXMgb3B0aW9uLCBlYWNoIGNlbGwgb2YgdGhlIGlucHV0IGRlc3RpbmF0aW9uIGRhdGEgaXMgdHJlYXRlZCBzZXBhcmF0ZWx5LCBhbmQgYW4gb3B0aW1hbCBwYXRoIGlzIGRldGVybWluZWQgZm9yIGVhY2ggY2VsbC5cIixcblx0XCJAQENDREMtQW5hbHlzaXNfYmFuZHNmb3JkZXRlY3RpbmdjaGFuZ2VfdGFnMEBAXCI6IFwiVGhlIGJhbmQgSURzIHRvIHVzZSBmb3IgY2hhbmdlIGRldGVjdGlvbi4gSWYgbm8gYmFuZCBJRHMgYXJlIHByb3ZpZGVkLCBhbGwgdGhlIGJhbmRzIGZyb20gdGhlIGlucHV0IHJhc3RlciBkYXRhc2V0IHdpbGwgYmUgdXNlZC5cIixcblx0XCJAQENDREMtQW5hbHlzaXNfYmFuZHNmb3JkZXRlY3RpbmdjaGFuZ2VfdGFnMUBAXCI6IFwiVGhlIElEIHZhbHVlcyBzaG91bGQgYmUgaW50ZWdlcnMgc2VwYXJhdGVkIGJ5IHNwYWNlcy5cIixcblx0XCJAQENDREMtQW5hbHlzaXNfYmFuZHNmb3J0ZW1wb3JhbG1hc2tpbmdfdGFnMEBAXCI6IFwiVGhlIGJhbmQgSURzIG9mIHRoZSBncmVlbiBiYW5kIGFuZCB0aGUgU1dJUiBiYW5kLCB0byBiZSB1c2VkIHRvIG1hc2sgZm9yIGNsb3VkLCBjbG91ZCBzaGFkb3cgYW5kIHNub3cuIElmIG5vIGJhbmQgSURzIGFyZSBwcm92aWRlZCwgbWFza2luZyB3aWxsIG5vdCBvY2N1ci5cIixcblx0XCJAQENDREMtQW5hbHlzaXNfYmFuZHNmb3J0ZW1wb3JhbG1hc2tpbmdfdGFnMUBAXCI6IFwiVGhlIElEIHZhbHVlcyBzaG91bGQgYmUgaW50ZWdlcnMgc2VwYXJhdGVkIGJ5IHNwYWNlcy5cIixcblx0XCJAQENDREMtQW5hbHlzaXNfYmFuZHNmb3J0ZW1wb3JhbG1hc2tpbmdfdGFnMkBAXCI6IFwiVGhpcyBwYXJhbWV0ZXIgc3BlY2lmaWVzIHRoZSBiYW5kcyB0byB1c2UgZm9yIGNsb3VkLCBjbG91ZCBzaGFkb3csIGFuZCBzbm93IG1hc2tpbmcuIEJlY2F1c2UgY2xvdWQgc2hhZG93IGFuZCBzbm93IHNob3cgdXAgdmVyeSBkYXJrIGluIHRoZSBzaG9ydHdhdmUgaW5mcmFyZWQgKFNXSVIpIGJhbmQsIGFuZCBjbG91ZHMgYW5kIHNub3cgYXJlIHZlcnkgYnJpZ2h0IGluIHRoZSBncmVlbiBiYW5kLCBpdCBpcyByZWNvbW1lbmRlZCB0aGF0IHRoZSBiYW5kIGluZGV4ZXMgZm9yIHRoZSBTV0lSIGFuZCBncmVlbiBiYW5kcyBhcmUgbWFza2VkLlwiLFxuXHRcIkBAQ0NEQy1BbmFseXNpc19jaGktc3F1YXJlZHRocmVzaG9sZGZvcmRldGVjdGNoYW5nZV90YWcwQEBcIjogXCJUaGUgY2hpLXNxdWFyZSBjaGFuZ2UgcHJvYmFiaWxpdHkgdGhyZXNob2xkLiBJZiBhbiBvYnNlcnZhdGlvbiBoYXMgYSBjYWxjdWxhdGVkIGNoYW5nZSBwcm9iYWJpbGl0eSB0aGF0IGlzIGFib3ZlIHRoaXMgdGhyZXNob2xkLCBpdCBpcyBmbGFnZ2VkIGFzIGFuIGFub21hbHksIHdoaWNoIGlzIGEgcG90ZW50aWFsIGNoYW5nZSBldmVudC4gVGhlIGRlZmF1bHQgdmFsdWUgaXMgMC45OS5cIixcblx0XCJAQENDREMtQW5hbHlzaXNfbWluaW11bWNvbnNlY3V0aXZlYW5vbWFseW9ic2VydmF0aW9uc190YWcwQEBcIjogXCJUaGUgbWluaW11bSBudW1iZXIgb2YgY29uc2VjdXRpdmUgYW5vbWFseSBvYnNlcnZhdGlvbnMgdGhhdCBtdXN0IG9jY3VyIGJlZm9yZSBhbiBldmVudCBpcyBjb25zaWRlcmVkIGEgY2hhbmdlLiBBIHBpeGVsIG11c3QgYmUgZmxhZ2dlZCBhcyBhbiBhbm9tYWx5IGZvciB0aGUgc3BlY2lmaWVkIG51bWJlciBvZiBjb25zZWN1dGl2ZSB0aW1lIHNsaWNlcyBiZWZvcmUgaXQgaXMgY29uc2lkZXJlZCBhIHRydWUgY2hhbmdlLiBUaGUgZGVmYXVsdCBpcyA2LlwiLFxuXHRcIkBAQ0NEQy1BbmFseXNpc19yYXN0ZXJfdGFnMEBAXCI6IFwiVGhlIGlucHV0IG11bHRpZGltZW5zaW9uYWwgcmFzdGVyIGxheWVyLlwiLFxuXHRcIkBAQ0NEQy1BbmFseXNpc191cGRhdGluZ2ZpdHRpbmdmcmVxdWVuY3koaW55ZWFycylfdGFnMEBAXCI6IFwiVGhlIGZyZXF1ZW5jeSBhdCB3aGljaCB0byB1cGRhdGUgdGhlIHRpbWUgc2VyaWVzIG1vZGVsIHdpdGggbmV3IG9ic2VydmF0aW9ucy4gVGhlIGRlZmF1bHQgaXMgdG8gdXBkYXRlIHRoZSBtb2RlbCBldmVyeSAxIHllYXIuXCIsXG5cdFwiQEBDQ0RDLUFuYWx5c2lzX3VwZGF0aW5nZml0dGluZ2ZyZXF1ZW5jeShpbnllYXJzKV90YWcxQEBcIjogXCJUaGlzIHBhcmFtZXRlciBkZWZpbmVzIGhvdyBvZnRlbiB0aGUgdGltZSBzZXJpZXMgbW9kZWwgd2lsbCBiZSB1cGRhdGVkIHdpdGggbmV3IG9ic2VydmF0aW9ucy4gVXBkYXRpbmcgYSBtb2RlbCBmcmVxdWVudGx5IGNhbiBiZSBjb21wdXRhdGlvbmFsbHkgY29zdGx5IGFuZCB0aGUgYmVuZWZpdCBjYW4gYmUgbWluaW1hbC4gRm9yIGV4YW1wbGUsIGlmIHRoZXJlIGFyZSAzNjUgc2xpY2VzIG9yIGNsZWFyIG9ic2VydmF0aW9ucyBwZXIgeWVhciBpbiB0aGUgbXVsdGlkaW1lbnNpb25hbCByYXN0ZXIsIGFuZCB0aGUgdXBkYXRpbmcgZnJlcXVlbmN5IGlzIGZvciBldmVyeSBvYnNlcnZhdGlvbiwgdGhlIHByb2Nlc3Npbmcgd2lsbCBiZSAzNjUgdGltZXMgbW9yZSBjb21wdXRhdGlvbmFsbHkgZXhwZW5zaXZlIGNvbXBhcmVkIHRvIHVwZGF0aW5nIG9uY2UgcGVyIHllYXIsIGJ1dCB0aGUgYWNjdXJhY3kgbWF5IG5vdCBiZSBoaWdoZXIuXCIsXG5cdFwiQEBUcmVuZC1Uby1SR0JfbW9kZWx0eXBlX3RhZzBAQFwiOiBcIlRoZSB0eXBlIG9mIG1vZGVsIGluZm9ybWF0aW9uIHRvIGNvbnZlcnQgdG8gUkdCLlwiLFxuXHRcIkBAVHJlbmQtVG8tUkdCX21vZGVsdHlwZV90YWcxQEBcIjogXCJMaW5lYXItLUxpbmVhciB0cmVuZCBpbmZvcm1hdGlvbiB3aWxsIGJlIGNvbnZlcnRlZCB0byBSR0IuIFRoaXMgaXMgdGhlIGRlZmF1bHQuXCIsXG5cdFwiQEBUcmVuZC1Uby1SR0JfbW9kZWx0eXBlX3RhZzJAQFwiOiBcIkhhcm1vbmljLS1IYXJtb25pYyB0cmVuZCBpbmZvcm1hdGlvbiB3aWxsIGJlIGNvbnZlcnRlZCB0byBSR0IuXCIsXG5cdFwiQEBUcmVuZC1Uby1SR0JfcmFzdGVyX3RhZzBAQFwiOiBcIlRoZSBpbnB1dCB0cmVuZCByYXN0ZXIuXCIsXG5cdFwiQEBMYW5kVHJlbmRyLUFuYWx5c2lzX2Jlc3Rtb2RlbHByb3BvcnRpb25fdGFnMEBAXCI6IFwiPHA+VGhlIGJlc3QgbW9kZWwgcHJvcG9ydGlvbiB2YWx1ZS4gRHVyaW5nIHRoZSBtb2RlbCBzZWxlY3Rpb24gcHJvY2VzcywgdGhlIHRvb2wgd2lsbCBjYWxjdWxhdGUgdGhlIHAtdmFsdWUgZm9yIGVhY2ggbW9kZWwgYW5kIHNlbGVjdCBhIG1vZGVsIHRoYXQgaGFzIHRoZSBtb3N0IHZlcnRpY2VzIHdoaWxlIG1haW50YWluaW5nIHRoZSBzbWFsbGVzdCAobW9zdCBzaWduaWZpY2FudCkgcC12YWx1ZSBiYXNlZCBvbiB0aGlzIHByb3BvcnRpb24gdmFsdWUuIEEgdmFsdWUgb2YgMSBtZWFucyB0aGUgbW9kZWwgaGFzIHRoZSBsb3dlc3QgcC12YWx1ZSBidXQgbWF5IG5vdCBoYXZlIGEgaGlnaCBudW1iZXIgb2YgdmVydGljZXMuIFRoZSBkZWZhdWx0IGlzIDEuMjUuPC9wPlwiLFxuXHRcIkBATGFuZFRyZW5kci1BbmFseXNpc19tYXhpbXVtbnVtYmVyb2ZzZWdtZW50c190YWcwQEBcIjogXCI8cD5UaGUgbWF4aW11bSBudW1iZXIgb2Ygc2VnbWVudHMgdG8gYmUgZml0dGVkIHRvIHRoZSB0aW1lIHNlcmllcyBmb3IgZWFjaCBwaXhlbC4gVGhlIGRlZmF1bHQgaXMgNS48L3A+XCIsXG5cdFwiQEBMYW5kVHJlbmRyLUFuYWx5c2lzX21pbmltdW1udW1iZXJvZm9ic2VydmF0aW9uc190YWcwQEBcIjogXCI8cD5UaGUgbWluaW11bSBudW1iZXIgb2YgdmFsaWQgb2JzZXJ2YXRpb25zIHJlcXVpcmVkIHRvIHBlcmZvcm0gZml0dGluZy4gVGhlIG51bWJlciBvZiB5ZWFycyBpbiB0aGUgaW5wdXQgbXVsdGlkaW1lbnNpb25hbCBkYXRhc2V0IG11c3QgYmUgZXF1YWwgdG8gb3IgZ3JlYXRlciB0aGFuIHRoaXMgdmFsdWUuIFRoZSBkZWZhdWx0IGlzIDYuPC9wPlwiLFxuXHRcIkBATGFuZFRyZW5kci1BbmFseXNpc19vdXRwdXRvdGhlcmJhbmRzX3RhZzBAQFwiOiBcIjxwPlNwZWNpZmllcyB3aGV0aGVyIG90aGVyIGJhbmRzIHdpbGwgYmUgaW5jbHVkZWQgaW4gdGhlIHJlc3VsdHMuPC9wPjx1bD48bGk+Q2hlY2tlZC0tT3RoZXIgYmFuZHMgd2lsbCBiZSBpbmNsdWRlZCBpbiB0aGUgcmVzdWx0cy4gVGhlIHNlZ21lbnRhdGlvbiBhbmQgdmVydGljZXMgaW5mb3JtYXRpb24gZnJvbSB0aGUgaW5pdGlhbCBzZWdtZW50YXRpb24gYmFuZCBzcGVjaWZpZWQgaW4gdGhlPHN0cm9uZz5Qcm9jZXNzaW5nIEJhbmQ8L3N0cm9uZz5wYXJhbWV0ZXIgd2lsbCBhbHNvIGJlIGZpdHRlZCB0byB0aGUgcmVtYWluaW5nIGJhbmRzIGluIHRoZSBtdWx0aWJhbmQgaW1hZ2VzLiBUaGUgbW9kZWwgcmVzdWx0cyB3aWxsIGluY2x1ZGUgdGhlIHNlZ21lbnRhdGlvbiBiYW5kIGZpcnN0LCB0aGVuIHRoZSByZW1haW5pbmcgYmFuZHMuPC9saT48bGk+VW5jaGVja2VkLS1PdGhlciBiYW5kcyB3aWxsIG5vdCBiZSBpbmNsdWRlZC4gVGhpcyBpcyB0aGUgZGVmYXVsdC48L2xpPjwvdWw+XCIsXG5cdFwiQEBMYW5kVHJlbmRyLUFuYWx5c2lzX3ByZXZlbnRvbmV5ZWFycmVjb3ZlcnlfdGFnMEBAXCI6IFwiPHA+U3BlY2lmaWVzIHdoZXRoZXIgc2VnbWVudHMgdGhhdCBleGhpYml0IGEgb25lIHllYXIgcmVjb3Zlcnkgd2lsbCBiZSBleGNsdWRlZC48L3A+PHVsPjxsaT5DaGVja2VkLS1TZWdtZW50cyB0aGF0IGV4aGliaXQgYSBvbmUgeWVhciByZWNvdmVyeSB3aWxsIGJlIGV4Y2x1ZGVkLiBUaGlzIGlzIHRoZSBkZWZhdWx0LjwvbGk+PGxpPlVuY2hlY2tlZC0tU2VnbWVudHMgdGhhdCBleGhpYml0IGEgb25lIHllYXIgcmVjb3Zlcnkgd2lsbCBiZSBub3QgYmUgZXhjbHVkZWQuPC9saT48L3VsPlwiLFxuXHRcIkBATGFuZFRyZW5kci1BbmFseXNpc19wcm9jZXNzaW5nYmFuZF90YWcwQEBcIjogXCI8cD5UaGUgYmFuZCB0byB1c2UgZm9yIHNlZ21lbnRpbmcgdGhlIHBpeGVsIHZhbHVlIHRyYWplY3RvcmllcyBvdmVyIHRpbWUuIENob29zZSB0aGUgYmFuZCB0aGF0IHdpbGwgYmVzdCBjYXB0dXJlIHRoZSBjaGFuZ2VzIGluIHRoZSBmZWF0dXJlIHlvdSB3YW50IHRvIG9ic2VydmUuPC9wPlwiLFxuXHRcIkBATGFuZFRyZW5kci1BbmFseXNpc19wLXZhbHVldGhyZXNob2xkX3RhZzBAQFwiOiBcIjxwPlRoZSBwLXZhbHVlIHRocmVzaG9sZGZvciBhIG1vZGVsIHRvIGJlIHNlbGVjdGVkLiBBZnRlciB0aGUgdmVydGljZXMgYXJlIGRldGVjdGVkIGluIHRoZSBpbml0aWFsIHN0YWdlIG9mIHRoZSBtb2RlbCBmaXR0aW5nLCB0aGUgdG9vbCB3aWxsIGZpdCBlYWNoIHNlZ21lbnQgYW5kIGNhbGN1bGF0ZSB0aGUgcC12YWx1ZSB0byBkZXRlcm1pbmUgdGhlIHNpZ25pZmljYW5jZSBvZiB0aGUgbW9kZWwuIE9uIHRoZSBuZXh0IGl0ZXJhdGlvbiwgdGhlIG1vZGVsIHdpbGwgZGVjcmVhc2UgdGhlIG51bWJlciBvZiBzZWdtZW50cyBieSBvbmUgYW5kIHJlY2FsY3VsYXRlIHRoZSBwLXZhbHVlLiBUaGlzIHdpbGwgY29udGludWUgYW5kLCBpZiB0aGUgcC12YWx1ZSBpcyBzbWFsbGVyIHRoYW4gdGhlIHZhbHVlIHNwZWNpZmllZCBpbiB0aGlzIHBhcmFtZXRlciwgdGhlIG1vZGVsIHdpbGwgYmUgc2VsZWN0ZWQgYW5kIHRoZSB0b29sIHdpbGwgc3RvcCBzZWFyY2hpbmcgZm9yIGEgYmV0dGVyIG1vZGVsLiBJZiBubyBzdWNoIG1vZGVsIGlzIHNlbGVjdGVkLCB0aGUgdG9vbCB3aWxsIHNlbGVjdCBhIG1vZGVsIHdpdGggYSBwLXZhbHVlIHNtYWxsZXIgdGhhbiB0aGU8c3Ryb25nPmxvd2VzdCBwLXZhbHVlIMOXIGJlc3QgbW9kZWwgcHJvcG9ydGlvbiB2YWx1ZTwvc3Ryb25nPi4gVGhlIGRlZmF1bHQgaXMgMC4wMS48L3A+XCIsXG5cdFwiQEBMYW5kVHJlbmRyLUFuYWx5c2lzX3Jhc3Rlcl90YWcwQEBcIjogXCI8cD5UaGUgaW5wdXQgTGFuZHNhdCBtdWx0aWRpbWVuc2lvbmFsIHJhc3RlciBsYXllci48L3A+XCIsXG5cdFwiQEBMYW5kVHJlbmRyLUFuYWx5c2lzX3JlY292ZXJ5aGFzaW5jcmVhc2V0cmVuZF90YWcwQEBcIjogXCI8cD5TcGVjaWZpZXMgd2hldGhlciB0aGUgcmVjb3ZlcnkgaGFzIGFuIGluY3JlYXNpbmcgKHBvc2l0aXZlKSB0cmVuZC48L3A+PHVsPjxsaT5DaGVja2VkLS1UaGUgcmVjb3ZlcnkgaGFzIGFuIGluY3JlYXNpbmcgdHJlbmQuIFRoaXMgaXMgdGhlIGRlZmF1bHQuPC9saT48bGk+VW5jaGVja2VkLS1UaGUgcmVjb3ZlcnkgaGFzIGEgZGVjcmVhc2luZyB0cmVuZC48L2xpPjwvdWw+XCIsXG5cdFwiQEBMYW5kVHJlbmRyLUFuYWx5c2lzX3JlY292ZXJ5dGhyZXNob2xkX3RhZzBAQFwiOiBcIjxwPlRoZSByZWNvdmVyeSB0aHJlc2hvbGQgdmFsdWUsIGluIHllYXJzLiBJZiBhIHNlZ21lbnQgaGFzIGEgcmVjb3ZlcnkgcmF0ZSB0aGF0IGlzIGZhc3RlciB0aGFuPHN0cm9uZz4xL3JlY292ZXJ5IHRocmVzaG9sZDwvc3Ryb25nPiwgdGhlIHNlZ21lbnQgaXMgZGlzY2FyZGVkIGFuZCBub3QgaW5jbHVkZWQgaW4gdGhlIHRpbWUgc2VyaWVzIG1vZGVsLiBUaGUgdmFsdWUgbXVzdCByYW5nZSBiZXR3ZWVuIDAgYW5kIDEuIFRoZSBkZWZhdWx0IGlzIDAuMjUuPC9wPlwiLFxuXHRcIkBATGFuZFRyZW5kci1BbmFseXNpc19zbmFwcGluZ2RhdGVfdGFnMEBAXCI6IFwiPHA+VGhlIGRhdGUgdXNlZCB0byBzZWxlY3QgYSBzbGljZSBmb3IgZWFjaCB5ZWFyIGluIHRoZSBpbnB1dCBtdWx0aWRpbWVuc2lvbmFsIGRhdGFzZXQuIFRoZSBzbGljZSB3aXRoIHRoZSBkYXRlIGNsb3Nlc3QgdG8gdGhlIHNuYXBwaW5nIGRhdGUgd2lsbCBiZSBzZWxlY3RlZC4gVGhpcyBwYXJhbWV0ZXIgaXMgcmVxdWlyZWQgaWYgdGhlIGlucHV0IGRhdGFzZXQgY29udGFpbnMgc3ViLXllYXJseSBkYXRhLjwvcD5cIixcblx0XCJAQExhbmRUcmVuZHItQW5hbHlzaXNfc3Bpa2V0aHJlc2hvbGRfdGFnMEBAXCI6IFwiPHA+VGhlIHRocmVzaG9sZCB0byB1c2UgZm9yIGRhbXBlbmluZyBzcGlrZXMgb3IgYW5vbWFsaWVzIGluIHRoZSBwaXhlbCB2YWx1ZSB0cmFqZWN0b3J5LiBUaGUgdmFsdWUgbXVzdCByYW5nZSBiZXR3ZWVuIDAgYW5kIDEsIHdoZXJlIDEgbWVhbnMgbm8gZGFtcGVuaW5nLiBUaGUgZGVmYXVsdCBpcyAwLjkuPC9wPlwiLFxuXHRcIkBATGFuZFRyZW5kci1BbmFseXNpc192ZXJ0ZXhjb3VudG92ZXJzaG9vdF90YWcwQEBcIjogXCI8cD5UaGUgbnVtYmVyIG9mIGFkZGl0aW9uYWwgdmVydGljZXMgYmV5b25kPHN0cm9uZz5tYXhfbnVtX3NlZ21lbnRzICsgMTwvc3Ryb25nPnRoYXQgY2FuIGJlIHVzZWQgdG8gZml0IHRoZSBtb2RlbCBkdXJpbmcgdGhlIGluaXRpYWwgc3RhZ2Ugb2YgaWRlbnRpZnlpbmcgdmVydGljZXMuIExhdGVyIGluIHRoZSBtb2RlbGluZyBwcm9jZXNzLCB0aGUgbnVtYmVyIG9mIGFkZGl0aW9uYWwgdmVydGljZXMgd2lsbCBiZSByZWR1Y2VkIHRvPHN0cm9uZz5tYXhfbnVtX3NlZ21lbnRzICsgMTwvc3Ryb25nPi4gVGhlIGRlZmF1bHQgaXMgMi48L3A+XCIsXG5cdFwiQEBNZXJnZS1SYXN0ZXJzX3Jhc3RlcnNfdGFnMEBAXCI6IFwiPHA+VGhlIGlucHV0IHJhc3RlciBkYXRhc2V0cyBvciBtdWx0aWRpbWVuc2lvbmFsIHJhc3RlciBkYXRhc2V0cyB0byBtZXJnZS48L3A+XCIsXG5cdFwiQEBNZXJnZS1SYXN0ZXJzX3Jlc29sdmVvdmVybGFwbWV0aG9kX3RhZzBAQFwiOiBcIjxwPlNwZWNpZmllcyB0aGUgbWV0aG9kIHRvIHVzZSB0byByZXNvbHZlIG92ZXJsYXBwaW5nIHBpeGVscyBpbiB0aGUgY29tYmluZWQgZGF0YXNldHMuPC9wPjx1bD48bGk+PHN0cm9uZz5GaXJzdDwvc3Ryb25nPi0tVGhlIHBpeGVsIHZhbHVlIGluIHRoZSBvdmVybGFwcGluZyBhcmVhcyBpcyB0aGUgdmFsdWUgZnJvbSB0aGUgZmlyc3QgcmFzdGVyIGluIHRoZSBsaXN0IG9mIGlucHV0IHJhc3RlcnMuIFRoaXMgaXMgdGhlIGRlZmF1bHQuPC9saT48bGk+PHN0cm9uZz5MYXN0PC9zdHJvbmc+LS1UaGUgcGl4ZWwgdmFsdWUgaW4gdGhlIG92ZXJsYXBwaW5nIGFyZWFzIGlzIHRoZSB2YWx1ZSBmcm9tIHRoZSBsYXN0IHJhc3RlciBpbiB0aGUgbGlzdCBvZiBpbnB1dCByYXN0ZXJzLjwvbGk+PGxpPjxzdHJvbmc+TWluPC9zdHJvbmc+LS1UaGUgcGl4ZWwgdmFsdWUgaW4gdGhlIG92ZXJsYXBwaW5nIGFyZWFzIGlzIHRoZSBtaW5pbXVtIHZhbHVlIG9mIHRoZSBvdmVybGFwcGluZyBwaXhlbHMuPC9saT48bGk+PHN0cm9uZz5NYXg8L3N0cm9uZz4tLVRoZSBwaXhlbCB2YWx1ZSBpbiB0aGUgb3ZlcmxhcHBpbmcgYXJlYXMgaXMgdGhlIG1heGltdW0gdmFsdWUgb2YgdGhlIG92ZXJsYXBwaW5nIHBpeGVscy48L2xpPjxsaT48c3Ryb25nPk1lYW48L3N0cm9uZz4tLVRoZSBwaXhlbCB2YWx1ZSBpbiB0aGUgb3ZlcmxhcHBpbmcgYXJlYXMgaXMgdGhlIGF2ZXJhZ2Ugb2YgdGhlIG92ZXJsYXBwaW5nIHBpeGVscy48L2xpPjxsaT48c3Ryb25nPlN1bTwvc3Ryb25nPi0tVGhlIHBpeGVsIHZhbHVlIGluIHRoZSBvdmVybGFwcGluZyBhcmVhcyBpcyB0aGUgdG90YWwgc3VtIG9mIHRoZSBvdmVybGFwcGluZyBwaXhlbHMuPC9saT48L3VsPlwiLFxuXHRcIkBAR2VuZXJhdGUtVHJlbmRfY3ljbGV1bml0X3RhZzBAQFwiOiBcIjxwPlNwZWNpZmllcyB0aGUgdGltZSB1bml0IHRvIGJlIHVzZWQgZm9yIHRoZSBsZW5ndGggb2YgYSBoYXJtb25pYyBjeWNsZS48L3A+PHVsPjxsaT48c3Ryb25nPkRheXM8L3N0cm9uZz4tLVRoZSB1bml0IGZvciB0aGUgbGVuZ3RoIG9mIHRoZSBoYXJtb25pYyBjeWNsZSBpcyBkYXlzLjwvbGk+PGxpPjxzdHJvbmc+WWVhcnM8L3N0cm9uZz4tLVRoZSB1bml0IGZvciB0aGUgbGVuZ3RoIG9mIHRoZSBoYXJtb25pYyBjeWNsZSBpcyB5ZWFycy4gVGhpcyBpcyB0aGUgZGVmYXVsdC48L2xpPjwvdWw+XCIsXG5cdFwiQEBHZW5lcmF0ZS1UcmVuZF9kaW1lbnNpb25uYW1lX3RhZzBAQFwiOiBcIjxwPlRoZSBkaW1lbnNpb24gYWxvbmcgd2hpY2ggYSB0cmVuZCB3aWxsIGJlIGV4dHJhY3RlZCBmb3IgdGhlIHZhcmlhYmxlIG9yIHZhcmlhYmxlcyBzZWxlY3RlZCBpbiB0aGUgYW5hbHlzaXMuPC9wPlwiLFxuXHRcIkBAR2VuZXJhdGUtVHJlbmRfaGFybW9uaWNmcmVxdWVuY3lfdGFnMEBAXCI6IFwiPHA+VGhlIGZyZXF1ZW5jeSBudW1iZXIgdG8gdXNlIGluIHRoZSB0cmVuZCBmaXR0aW5nLiBUaGlzIHBhcmFtZXRlciBzcGVjaWZpZXMgdGhlIGZyZXF1ZW5jeSBvZiBjeWNsZXMgaW4gYSB5ZWFyLiBUaGUgZGVmYXVsdCB2YWx1ZSBpcyAxLCBvciBvbmUgaGFybW9uaWMgY3ljbGUgcGVyIHllYXIuPC9wPjxwPlRoaXMgcGFyYW1ldGVyIGlzIG9ubHkgaW5jbHVkZWQgaW4gdGhlIHRyZW5kIGFuYWx5c2lzIGZvciBhIGhhcm1vbmljIHJlZ3Jlc3Npb24uPC9wPlwiLFxuXHRcIkBAR2VuZXJhdGUtVHJlbmRfaWdub3Jlbm9kYXRhX3RhZzBAQFwiOiBcIjxwPlNwZWNpZmllcyB3aGV0aGVyIE5vRGF0YSB2YWx1ZXMgYXJlIGlnbm9yZWQgaW4gdGhlIGFuYWx5c2lzLjwvcD48dWw+PGxpPkNoZWNrZWQtLVRoZSBhbmFseXNpcyB3aWxsIGluY2x1ZGUgYWxsIHZhbGlkIHBpeGVscyBhbG9uZyBhIGdpdmVuIGRpbWVuc2lvbiBhbmQgaWdub3JlIGFueSBOb0RhdGEgcGl4ZWxzLiBUaGlzIGlzIHRoZSBkZWZhdWx0LjwvbGk+PGxpPlVuY2hlY2tlZC0tVGhlIGFuYWx5c2lzIHdpbGwgcmVzdWx0IGluIE5vRGF0YSBpZiB0aGVyZSBhcmUgYW55IE5vRGF0YSB2YWx1ZXMgZm9yIHRoZSBwaXhlbHMgYWxvbmcgdGhlIGdpdmVuIGRpbWVuc2lvbi48L2xpPjwvdWw+XCIsXG5cdFwiQEBHZW5lcmF0ZS1UcmVuZF9sZW5ndGhvZmN5Y2xlX3RhZzBAQFwiOiBcIjxwPlRoZSBsZW5ndGggb2YgcGVyaW9kaWMgdmFyaWF0aW9uIHRvIG1vZGVsLiBUaGUgdW5pdCBpcyBkYXlzLCByZWdhcmRsZXNzIG9mIHRoZSB0aW1lIHVuaXQgb2YgdGhlIGlucHV0IGRhdGEuIEZvciBleGFtcGxlLCBsZWFmIGdyZWVubmVzcyBvZnRlbiBoYXMgb25lIHN0cm9uZyBjeWNsZSBvZiB2YXJpYXRpb24gaW4gYSBzaW5nbGUgeWVhciwgc28gdGhlIGN5Y2xlIGxlbmd0aCBpcyAzNjUuMjUsIGV2ZW4gaWYgdGhlIGlucHV0IGRhdGEgaXMgbW9udGhseSBncmVlbm5lc3MuIEhvdXJseSB0ZW1wZXJhdHVyZSBkYXRhIGhhcyBvbmUgc3Ryb25nIGN5Y2xlIG9mIHZhcmlhdGlvbiB0aHJvdWdob3V0IGEgc2luZ2xlIGRheSwgc28gdGhlIGN5Y2xlIGxlbmd0aCBpcyAxLjwvcD48cD5UaGUgZGVmYXVsdCBsZW5ndGggaXMgMzY1LjI1IGRheXMgZm9yIGRhdGEgdGhhdCB2YXJpZXMgb24gYW4gYW5udWFsIGN5Y2xlLjwvcD5cIixcblx0XCJAQEdlbmVyYXRlLVRyZW5kX3AtdmFsdWVvZnNsb3BlY29lZmZpY2llbnRfdGFnMEBAXCI6IFwiPHA+U3BlY2lmaWVzIHdoZXRoZXIgdG8gY2FsY3VsYXRlIHRoZSBwLXZhbHVlIHN0YXRpc3RpYyBmb3IgdGhlIHNsb3BlIGNvZWZmaWNpZW50IG9mIHRoZSB0cmVuZCBsaW5lLjwvcD48dWw+PGxpPkNoZWNrZWQtLVRoZSBwLXZhbHVlIHdpbGwgYmUgY2FsY3VsYXRlZCBhbmQgZGlzcGxheWVkIGluIHRoZSBkZXRhaWxzIHdoZW4gdGhlIGZ1bmN0aW9uIGNvbXBsZXRlcy48L2xpPjxsaT5VbmNoZWNrZWQtLVRoZSBwLXZhbHVlIHdpbGwgbm90IGJlIGNhbGN1bGF0ZWQuIFRoaXMgaXMgdGhlIGRlZmF1bHQuPC9saT48L3VsPlwiLFxuXHRcIkBAR2VuZXJhdGUtVHJlbmRfcG9seW5vbWlhbG9yZGVyX3RhZzBAQFwiOiBcIjxwPlRoZSBwb2x5bm9taWFsIG9yZGVyIG51bWJlciB0byB1c2UgaW4gdGhlIHRyZW5kIGZpdHRpbmcuIFRoaXMgcGFyYW1ldGVyIHNwZWNpZmllcyB0aGUgcG9seW5vbWlhbCBvcmRlci4gVGhlIGRlZmF1bHQgdmFsdWUgaXMgMiwgb3Igc2Vjb25kLW9yZGVyIHBvbHlub21pYWwuPC9wPjxwPlRoaXMgcGFyYW1ldGVyIGlzIG9ubHkgaW5jbHVkZWQgaW4gdGhlIHRyZW5kIGFuYWx5c2lzIGZvciBhIHBvbHlub21pYWwgcmVncmVzc2lvbi48L3A+XCIsXG5cdFwiQEBHZW5lcmF0ZS1UcmVuZF9yLXNxdWFyZWRfdGFnMEBAXCI6IFwiPHA+U3BlY2lmaWVzIHdoZXRoZXIgdG8gY2FsY3VsYXRlIHRoZSBSLXNxdWFyZWQgZ29vZG5lc3Mtb2YtZml0IHN0YXRpc3RpYyBmb3IgdGhlIHRyZW5kIGZpdCBsaW5lLjwvcD48dWw+PGxpPkNoZWNrZWQtLVRoZSBSLXNxdWFyZWQgd2lsbCBiZSBjYWxjdWxhdGVkIGFuZCBkaXNwbGF5ZWQgaW4gdGhlIGRldGFpbHMgd2hlbiB0aGUgZnVuY3Rpb24gaXMgY29tcGxldGVkLjwvbGk+PGxpPlVuY2hlY2tlZC0tVGhlIFItc3F1YXJlZCB3aWxsIG5vdCBiZSBjYWxjdWxhdGVkLiBUaGlzIGlzIHRoZSBkZWZhdWx0LjwvbGk+PC91bD5cIixcblx0XCJAQEdlbmVyYXRlLVRyZW5kX3Jhc3Rlcl90YWcwQEBcIjogXCI8cD5UaGUgaW5wdXQgbXVsdGlkaW1lbnNpb25hbCByYXN0ZXIuPC9wPlwiLFxuXHRcIkBAR2VuZXJhdGUtVHJlbmRfcm1zZV90YWcwQEBcIjogXCI8cD5TcGVjaWZpZXMgd2hldGhlciB0byBnZW5lcmF0ZSB0aGUgcm9vdCBtZWFuIHNxdWFyZSBlcnJvciAoUk1TRSkgb2YgdGhlIHRyZW5kIGZpdCBsaW5lLjwvcD48dWw+PGxpPkNoZWNrZWQtLVRoZSBSTVNFIHdpbGwgYmUgY2FsY3VsYXRlZCBhbmQgZGlzcGxheWVkIGluIHRoZSBkZXRhaWxzIHdoZW4gdGhlIGZ1bmN0aW9uIGlzIGNvbXBsZXRlZC4gVGhpcyBpcyB0aGUgZGVmYXVsdC48L2xpPjxsaT5VbmNoZWNrZWQtLVRoZSBSTVNFIHdpbGwgbm90IGJlIGNhbGN1bGF0ZWQuPC9saT48L3VsPlwiLFxuXHRcIkBAR2VuZXJhdGUtVHJlbmRfc2Vhc29uYWxwZXJpb2RfdGFnMEBAXCI6IFwiPHA+U3BlY2lmaWVzIHRoZSB0aW1lIHVuaXQgdG8gYmUgdXNlZCBmb3IgdGhlIGxlbmd0aCBvZiBhIHNlYXNvbmFsIHBlcmlvZCB3aGVuIHBlcmZvcm1pbmcgdGhlIFNlYXNvbmFsLUtlbmRhbGwgdGVzdC48L3A+PHVsPjxsaT5EYXlzLS1UaGUgdW5pdCBmb3IgdGhlIGxlbmd0aCBvZiB0aGUgc2Vhc29uYWwgcGVyaW9kIGlzIGRheXMuIFRoaXMgaXMgdGhlIGRlZmF1bHQuPC9saT48bGk+TW9udGhzLS1UaGUgdW5pdCBmb3IgdGhlIGxlbmd0aCBvZiB0aGUgc2Vhc29uYWwgcGVyaW9kIGlzIG1vbnRocy48L2xpPjwvdWw+XCIsXG5cdFwiQEBHZW5lcmF0ZS1UcmVuZF90cmVuZHR5cGVfdGFnMEBAXCI6IFwiPHA+U3BlY2lmaWVzIHRoZSB0eXBlIG9mIGxpbmUgdG8gYmUgdXNlZCB0byBmaXQgdG8gdGhlIHBpeGVsIHZhbHVlcyBhbG9uZyBhIGRpbWVuc2lvbi48L3A+PHVsPjxsaT48c3Ryb25nPkxpbmVhcjwvc3Ryb25nPi0tRml0cyB0aGUgcGl4ZWwgdmFsdWVzIGZvciBhIHZhcmlhYmxlIGFsb25nIGEgbGluZWFyIHRyZW5kIGxpbmUuIFRoaXMgaXMgdGhlIGRlZmF1bHQuPC9saT48bGk+PHN0cm9uZz5IYXJtb25pYzwvc3Ryb25nPi0tRml0cyB0aGUgcGl4ZWwgdmFsdWVzIGZvciBhIHZhcmlhYmxlIGFsb25nIGEgaGFybW9uaWMgdHJlbmQgbGluZS48L2xpPjxsaT48c3Ryb25nPlBvbHlub21pYWw8L3N0cm9uZz4tLUZpdHMgdGhlIHBpeGVsIHZhbHVlcyBmb3IgYSB2YXJpYWJsZSBhbG9uZyBhIHNlY29uZC1vcmRlciBwb2x5bm9taWFsIHRyZW5kIGxpbmUuPC9saT48bGk+PHN0cm9uZz5NYW5uLUtlbmRhbGw8L3N0cm9uZz4tLVZhcmlhYmxlIHBpeGVsIHZhbHVlcyB3aWxsIGJlIGV2YWx1YXRlZCB1c2luZyB0aGUgTWFubi1LZW5kYWxsIHRyZW5kIHRlc3QuPC9saT48bGk+PHN0cm9uZz5TZWFzb25hbCBLZW5kYWxsPC9zdHJvbmc+LS1WYXJpYWJsZSBwaXhlbCB2YWx1ZXMgd2lsbCBiZSBldmFsdWF0ZWQgdXNpbmcgdGhlIFNlYXNvbmFsLUtlbmRhbGwgdHJlbmQgdGVzdC48L2xpPjwvdWw+XCIsXG5cdFwiQEBDb21wdXRlLUNoYW5nZV9jZWxsc2l6ZXR5cGVfdGFnMEBAXCI6IFwiPHA+Q2hvb3NlIHdoaWNoIGNlbGwgc2l6ZSB0byB1c2UgaW4gdGhlIG91dHB1dCByYXN0ZXIuIElmIGFsbCB0aGUgaW5wdXQgY2VsbCBzaXplcyBhcmUgdGhlIHNhbWUsIGFsbCB0aGUgb3B0aW9ucyB3aWxsIHlpZWxkIHRoZSBzYW1lIHJlc3VsdHMuPC9wPjx1bD48bGk+Rmlyc3QgT2YtLVVzZSB0aGUgZmlyc3QgY2VsbCBzaXplIG9mIHRoZSBpbnB1dCByYXN0ZXJzLjwvbGk+PGxpPk1pbiBPZi0tVXNlIHRoZSBzbWFsbGVzdCBjZWxsIHNpemUgb2YgYWxsIHRoZSBpbnB1dCByYXN0ZXJzLjwvbGk+PGxpPk1heCBPZi0tVXNlIHRoZSBsYXJnZXN0IGNlbGwgc2l6ZSBvZiBhbGwgdGhlIGlucHV0IHJhc3RlcnMuIFRoaXMgaXMgdGhlIGRlZmF1bHQuPC9saT48bGk+TWVhbiBPZi0tVXNlIHRoZSBtZWFuIGNlbGwgc2l6ZSBvZiBhbGwgdGhlIGlucHV0IHJhc3RlcnMuPC9saT48bGk+TGFzdCBPZi0tVXNlIHRoZSBsYXN0IGNlbGwgc2l6ZSBvZiB0aGUgaW5wdXQgcmFzdGVycy48L2xpPjwvdWw+XCIsXG5cdFwiQEBDb21wdXRlLUNoYW5nZV9jb21wdXRlY2hhbmdlbWV0aG9kX3RhZzBAQFwiOiBcIjxwPlRoZSBtZXRob2QgdXNlZCBmb3IgY29tcHV0YXRpb24uPC9wPjx1bD48bGk+PHN0cm9uZz5EaWZmZXJlbmNlPC9zdHJvbmc+LS1UaGUgbWF0aGVtYXRpY2FsIGRpZmZlcmVuY2UsIG9yIHN1YnRyYWN0aW9uLCBiZXR3ZWVuIHRoZSBwaXhlbCB2YWx1ZXMgaW4gdGhlIGlucHV0IHJhc3RlcnMgd2lsbCBiZSBjYWxjdWxhdGVkLiBUaGlzIGlzIHRoZSBkZWZhdWx0LjwvbGk+PGxpPjxzdHJvbmc+UmVsYXRpdmUgRGlmZmVyZW5jZTwvc3Ryb25nPi0tVGhlIGRpZmZlcmVuY2UgaW4gcGl4ZWwgdmFsdWVzLCBhY2NvdW50aW5nIGZvciB0aGUgbWFnbml0dWRlcyBvZiB0aGUgdmFsdWVzIGJlaW5nIGNvbXBhcmVkLCB3aWxsIGJlIGNhbGN1bGF0ZWQuPC9saT48bGk+PHN0cm9uZz5DYXRlZ29yaWNhbCBEaWZmZXJlbmNlPC9zdHJvbmc+LS1UaGUgZGlmZmVyZW5jZSBiZXR3ZWVuIHR3byBjYXRlZ29yaWNhbCBvciB0aGVtYXRpYyByYXN0ZXJzIHdpbGwgYmUgY2FsY3VsYXRlZCwgd2hlcmUgdGhlIG91dHB1dCBjb250YWlucyBjbGFzcyB0cmFuc2l0aW9ucyB0aGF0IG9jY3VycmVkIGJldHdlZW4gdGhlIHR3byByYXN0ZXJzLjwvbGk+PGxpPjxzdHJvbmc+U3BlY3RyYWwgRXVjbGlkZWFuIERpc3RhbmNlPC9zdHJvbmc+LS1UaGUgRXVjbGlkZWFuIGRpc3RhbmNlIGJldHdlZW4gdGhlIHBpeGVsIHZhbHVlcyBvZiB0d28gbXVsdGliYW5kIHJhc3RlcnMgd2lsbCBiZSBjYWxjdWxhdGVkLjwvbGk+PGxpPjxzdHJvbmc+U3BlY3RyYWwgQW5nbGUgRGlmZmVyZW5jZTwvc3Ryb25nPi0tVGhlIHNwZWN0cmFsIGFuZ2xlIGJldHdlZW4gdGhlIHBpeGVsIHZhbHVlcyBvZiB0d28gbXVsdGliYW5kIHJhc3RlcnMgd2lsbCBiZSBjYWxjdWxhdGVkLiBUaGUgb3V0cHV0IGlzIGluIHJhZGlhbnMuPC9saT48bGk+PHN0cm9uZz5CYW5kIFdpdGggTW9zdCBDaGFuZ2U8L3N0cm9uZz4tLVRoZSBiYW5kIHRoYXQgYWNjb3VudHMgZm9yIHRoZSBtb3N0IGNoYW5nZSBpbiBlYWNoIHBpeGVsIGJldHdlZW4gdHdvIG11bHRpYmFuZCByYXN0ZXJzIHdpbGwgYmUgY2FsY3VsYXRlZC48L2xpPjwvdWw+PHA+SWYgdGhlPHN0cm9uZz5Db21wdXRlIENoYW5nZSBNZXRob2Q8L3N0cm9uZz5pcyBzZXQgdG88c3Ryb25nPkNhdGVnb3JpY2FsIERpZmZlcmVuY2U8L3N0cm9uZz5hbmQgb25lIG9mIHRoZSBpbnB1dHMgaXMgbm90IGNhdGVnb3JpY2FsLCBhIHNpbXBsZSBkaWZmZXJlbmNlIHdpbGwgYmUgY2FsY3VsYXRlZC48L3A+XCIsXG5cdFwiQEBDb21wdXRlLUNoYW5nZV9kZWZpbmV0cmFuc2l0aW9uY29sb3JzX3RhZzBAQFwiOiBcIjxwPlNwZWNpZnkgdGhlIG1ldGhvZCB0byB1c2UgZm9yIHN5bWJvbGl6aW5nIHRoZSBwaXhlbHMgdGhhdCBoYXZlIGNoYW5nZWQgY2xhc3Nlcy48L3A+PHVsPjxsaT48c3Ryb25nPkF2ZXJhZ2UgRnJvbSBBbmQgVG8gQ29sb3JzPC9zdHJvbmc+LS1UaGUgY29sb3Igb2YgdGhlIHBpeGVsIHdpbGwgYmUgdGhlIGF2ZXJhZ2Ugb2YgdGhlIGNvbG9yIG9mIGl0cyBvcmlnaW5hbCBjbGFzcyBhbmQgdGhlIGNvbG9yIG9mIGl0cyBmaW5hbCBjbGFzcy48L2xpPjxsaT48c3Ryb25nPlVzZSBGcm9tIENvbG9yczwvc3Ryb25nPi0tVGhlIGNvbG9yIG9mIHRoZSBwaXhlbCB3aWxsIGJlIHRoZSBjb2xvciBvZiBpdHMgb3JpZ2luYWwgY2xhc3MuPC9saT48bGk+PHN0cm9uZz5Vc2UgVG8gQ29sb3JzPC9zdHJvbmc+LS1UaGUgY29sb3Igb2YgdGhlIHBpeGVsIHdpbGwgYmUgdGhlIGNvbG9yIG9mIGl0cyBmaW5hbCBjbGFzcy48L2xpPjwvdWw+XCIsXG5cdFwiQEBDb21wdXRlLUNoYW5nZV9leHRlbnR0eXBlX3RhZzBAQFwiOiBcIjxwPkNob29zZSB3aGljaCBleHRlbnQgc2hvdWxkIGJlIHVzZWQgaW4gdGhlIG91dHB1dCByYXN0ZXI6PC9wPjx1bD48bGk+Rmlyc3QgT2YtLVVzZSB0aGUgZXh0ZW50IG9mIHRoZSBmaXJzdCBpbnB1dCByYXN0ZXIgdG8gZGV0ZXJtaW5lIHRoZSBwcm9jZXNzaW5nIGV4dGVudC48L2xpPjxsaT5JbnRlcnNlY3Rpb24gT2YtLVVzZSB0aGUgZXh0ZW50IG9mIHRoZSBvdmVybGFwcGluZyBwaXhlbHMgdG8gZGV0ZXJtaW5lIHRoZSBwcm9jZXNzaW5nIGV4dGVudC4gVGhpcyBpcyB0aGUgZGVmYXVsdC48L2xpPjxsaT5VbmlvbiBPZi0tVXNlIHRoZSBleHRlbnQgb2YgYWxsIHRoZSByYXN0ZXJzIHRvIGRldGVybWluZSB0aGUgcHJvY2Vzc2luZyBleHRlbnQuPC9saT48bGk+TGFzdCBPZi0tVXNlIHRoZSBleHRlbnQgb2YgdGhlIGxhc3QgaW5wdXQgcmFzdGVyIHRvIGRldGVybWluZSB0aGUgcHJvY2Vzc2luZyBleHRlbnQuPC9saT48L3VsPlwiLFxuXHRcIkBAQ29tcHV0ZS1DaGFuZ2VfZmlsdGVybWV0aG9kX3RhZzBAQFwiOiBcIjxwPkNob29zZSB0aGUgZmlsdGVyIG1ldGhvZCBmb3IgY2F0ZWdvcmljYWwgY2hhbmdlIGNvbXB1dGF0aW9uLjwvcD48dWw+PGxpPjxzdHJvbmc+S2VlcCBBbGw8L3N0cm9uZz4tLUFsbCBjbGFzc2VzIGFyZSBpbmNsdWRlZCBpbiB0aGUgb3V0cHV0LCBhbmQgbm8gZmlsdGVyaW5nIHdpbGwgb2NjdXIuIENob29zZSB0aGlzIG9wdGlvbiB0byBzZWUgY2hhbmdlIGFuZCBwZXJzaXN0ZW5jZSBpbiBhIHNpbmdsZSBkYXRhc2V0LjwvbGk+PGxpPjxzdHJvbmc+S2VlcCBDaGFuZ2VkIFBpeGVscyBPbmx5PC9zdHJvbmc+LS1Pbmx5IHRoZSBjbGFzc2VzIHRoYXQgaGF2ZSBjaGFuZ2VkIGZyb20gb25lIGNsYXNzIHR5cGUgdG8gYW5vdGhlciBjbGFzcyB0eXBlIGFyZSBpbmNsdWRlZCBpbiB0aGUgb3V0cHV0LiBDaG9vc2UgdGhpcyBvcHRpb24gaXMgeW91IGFyZSBvbmx5IGludGVyZXN0ZWQgaW4gY2hhbmdlLjwvbGk+PGxpPjxzdHJvbmc+S2VlcCBVbmNoYW5nZWQgUGl4ZWxzIE9ubHk8L3N0cm9uZz4tLU9ubHkgdGhlIGNsYXNzZXMgdGhhdCBoYXZlIG5vdCBjaGFuZ2VkIGFyZSBpbmNsdWRlZCBpbiB0aGUgb3V0cHV0LiBDaG9vc2UgdGhpcyBvcHRpb24gaWYgeW91IGFyZSBvbmx5IGludGVyZXN0ZWQgaW4gcGVyc2lzdGVuY2UuPC9saT48L3VsPlwiLFxuXHRcIkBAQ29tcHV0ZS1DaGFuZ2VfZnJvbWNsYXNzdmFsdWVzX3RhZzBAQFwiOiBcIjxwPlRoZSBjbGFzcyB2YWx1ZXMgZnJvbSB0aGU8c3Ryb25nPkZyb20gUmFzdGVyPC9zdHJvbmc+dG8gYmUgaW5jbHVkZWQgaW4gdGhlIGNvbXB1dGF0aW9uLCBpZiBjb21wYXJpbmcgdHdvIGNhdGVnb3JpY2FsIHJhc3RlcnMuIFRoaXMgaXMgYSBzcGFjZS1kZWxpbWl0ZWQgbGlzdCBvZiBpbnRlZ2VyIHZhbHVlcyBjb3JyZXNwb25kaW5nIHRvIHRoZTxzdHJvbmc+Q2xhc3NWYWx1ZTwvc3Ryb25nPmZpZWxkIGluIHlvdXIgaW5wdXQgcmFzdGVyIGRhdGFzZXQuPC9wPlwiLFxuXHRcIkBAQ29tcHV0ZS1DaGFuZ2VfZnJvbXJhc3Rlcl90YWcwQEBcIjogXCI8cD5UaGUgZmlyc3QgcmFzdGVyIHRvIGJlIHVzZWQgaW4gdGhlIGNvbXB1dGF0aW9uLiBUbyBldmFsdWF0ZSBjaGFuZ2UgZnJvbSB0aW1lIDEgKGVhcmxpZXIpIHRvIHRpbWUgMiAobGF0ZXIpLCBlbnRlciB0aGUgdGltZSAxIHJhc3RlciBoZXJlLjwvcD5cIixcblx0XCJAQENvbXB1dGUtQ2hhbmdlX3RvY2xhc3N2YWx1ZXNfdGFnMEBAXCI6IFwiPHA+VGhlIGNsYXNzIHZhbHVlcyBmcm9tIHRoZTxzdHJvbmc+VG8gUmFzdGVyPC9zdHJvbmc+dG8gYmUgaW5jbHVkZWQgaW4gdGhlIGNvbXB1dGF0aW9uLCBpZiBjb21wYXJpbmcgdHdvIGNhdGVnb3JpY2FsIHJhc3RlcnMuIFRoaXMgaXMgYSBzcGFjZS1kZWxpbWl0ZWQgbGlzdCBvZiBpbnRlZ2VyIHZhbHVlcyBjb3JyZXNwb25kaW5nIHRvIHRoZTxzdHJvbmc+Q2xhc3NWYWx1ZTwvc3Ryb25nPmZpZWxkIGluIHlvdXIgaW5wdXQgcmFzdGVyIGRhdGFzZXQuPC9wPlwiLFxuXHRcIkBAQ29tcHV0ZS1DaGFuZ2VfdG9yYXN0ZXJfdGFnMEBAXCI6IFwiPHA+VGhlIHNlY29uZCByYXN0ZXIgdG8gYmUgdXNlZCBpbiB0aGUgY29tcHV0YXRpb24uIFRvIGV2YWx1YXRlIGNoYW5nZSBmcm9tIHRpbWUgMSAoZWFybGllcikgdG8gdGltZSAyIChsYXRlciksIGVudGVyIHRoZSB0aW1lIDIgcmFzdGVyLjwvcD5cIixcblx0XCJAQENvbXB1dGUtQ2hhbmdlX3VzZWNvbG9ybWV0aG9kX3RhZzBAQFwiOiBcIjxwPlNwZWNpZnkgdGhlIG1ldGhvZCB0byB1c2UgZm9yIHN5bWJvbGl6aW5nIHRoZSBwaXhlbHMgdGhhdCBoYXZlIGNoYW5nZWQgY2xhc3Nlcy48L3A+PHVsPjxsaT48c3Ryb25nPkF2ZXJhZ2UgRnJvbSBBbmQgVG8gQ29sb3JzPC9zdHJvbmc+LS1UaGUgY29sb3Igb2YgdGhlIHBpeGVsIHdpbGwgYmUgdGhlIGF2ZXJhZ2Ugb2YgdGhlIGNvbG9yIG9mIGl0cyBvcmlnaW5hbCBjbGFzcyBhbmQgdGhlIGNvbG9yIG9mIGl0cyBmaW5hbCBjbGFzcy48L2xpPjxsaT48c3Ryb25nPlVzZSBGcm9tIENvbG9yczwvc3Ryb25nPi0tVGhlIGNvbG9yIG9mIHRoZSBwaXhlbCB3aWxsIGJlIHRoZSBjb2xvciBvZiBpdHMgb3JpZ2luYWwgY2xhc3MuPC9saT48bGk+PHN0cm9uZz5Vc2UgVG8gQ29sb3JzPC9zdHJvbmc+LS1UaGUgY29sb3Igb2YgdGhlIHBpeGVsIHdpbGwgYmUgdGhlIGNvbG9yIG9mIGl0cyBmaW5hbCBjbGFzcy48L2xpPjwvdWw+XCIsXG5cdFwiQEBDb21wdXRlLUNoYW5nZV9maWVsZG5hbWVmb3JjbGFzc25hbWVzaW5mcm9tcmFzdGVyX3RhZzBAQFwiOiBcIjxwPkEgZmllbGQgdGhhdCBzdG9yZXMgY2xhc3MgbmFtZXMgaW4gdGhlPHN0cm9uZz5Gcm9tIFJhc3Rlcjwvc3Ryb25nPmlucHV0LiBUaGUgdG9vbCBhdXRvbWF0aWNhbGx5IHNlYXJjaGVzIGZvcjxzdHJvbmc+Q2xhc3NOYW1lPC9zdHJvbmc+ZmllbGQgb3I8c3Ryb25nPkNsYXNzX05hbWU8L3N0cm9uZz5maWVsZCB0byB1c2UuPC9wPjxwPlVzZSB0aGlzIG9wdGlvbiBpZiB0aGUgaW5wdXQgZG9lcyBub3QgY29udGFpbiB0aGVzZSBzdGFuZGFyZCBmaWVsZCBuYW1lcy48L3A+XCIsXG5cdFwiQEBDb21wdXRlLUNoYW5nZV9maWVsZG5hbWVmb3JjbGFzc25hbWVzaW50b3Jhc3Rlcl90YWcwQEBcIjogXCI8cD5BIGZpZWxkIHRoYXQgc3RvcmVzIGNsYXNzIG5hbWVzIGluIHRoZTxzdHJvbmc+VG8gUmFzdGVyPC9zdHJvbmc+aW5wdXQuIFRoZSB0b29sIHdpbGwgYXV0b21hdGljYWxseSBzZWFyY2ggZm9yPHN0cm9uZz5DbGFzc05hbWU8L3N0cm9uZz5maWVsZCBvcjxzdHJvbmc+Q2xhc3NfTmFtZTwvc3Ryb25nPmZpZWxkIHRvIHVzZS48L3A+PHA+VXNlIHRoaXMgb3B0aW9uIGlmIHRoZSBpbnB1dCBkb2VzIG5vdCBjb250YWluIHRoZXNlIHN0YW5kYXJkIGZpZWxkIG5hbWVzLjwvcD5cIixcblx0XCJAQFN0YXRpc3RpY3NfbnVtYmVyb2Zjb2x1bW5zX3RhZzBAQFwiOiBcIjxwPlRoZSBudW1iZXIgb2YgcGl4ZWwgY29sdW1ucyB0byB1c2UgaW4gYSBmb2NhbCBuZWlnaGJvcmhvb2QgZGltZW5zaW9uLjwvcD5cIixcblx0XCJAQFN0YXRpc3RpY3NfbnVtYmVyb2Zyb3dzX3RhZzBAQFwiOiBcIjxwPlRoZSBudW1iZXIgb2YgcGl4ZWwgcm93cyB0byB1c2UgaW4gYSBmb2NhbCBuZWlnaGJvcmhvb2QgZGltZW5zaW9uLjwvcD5cIixcblx0XCJAQFN0YXRpc3RpY3Nfb25seWZpbGxub2RhdGFwaXhlbHNfdGFnMEBAXCI6IFwiPHA+RmlsbHMgaW4gTm9EYXRhIGdhcHMgaW4gdGhlIG91dHB1dC4gVGhpcyBpcyB1c2VmdWwgd2hlbiB5b3VyIGltYWdlcnkgbWF5IGhhdmUgZHJvcHBlZCBsaW5lcy48L3A+XCIsXG5cdFwiQEBTdGF0aXN0aWNzX3Jhc3Rlcl90YWcwQEBcIjogXCI8cD5UaGUgaW5wdXQgcmFzdGVyIHRvIHBlcmZvcm0gZm9jYWwgc3RhdGlzdGljcyBvbi48L3A+XCIsXG5cdFwiQEBTdGF0aXN0aWNzX3N0YXRpc3RpY3N0eXBlX3RhZzBAQFwiOiBcIjxwPlRoZSBmb2xsb3dpbmcgYXJlIHRoZSBzZXZlbiB0eXBlcyBvZiBmb2NhbCBzdGF0aXN0aWNhbCBmdW5jdGlvbnM6PC9wPjx1bD48bGk+TWluaW11bS0tQ2FsY3VsYXRlcyB0aGUgbWluaW11bSB2YWx1ZSBvZiB0aGUgcGl4ZWxzIHdpdGhpbiB0aGUgbmVpZ2hib3Job29kLjwvbGk+PGxpPk1heGltdW0tLUNhbGN1bGF0ZXMgdGhlIG1heGltdW0gdmFsdWUgb2YgdGhlIHBpeGVscyB3aXRoaW4gdGhlIG5laWdoYm9yaG9vZC48L2xpPjxsaT5NZWFuLS1DYWxjdWxhdGVzIHRoZSBhdmVyYWdlIHZhbHVlIG9mIHRoZSBwaXhlbHMgd2l0aGluIHRoZSBuZWlnaGJvcmhvb2QuIFRoaXMgaXMgdGhlIGRlZmF1bHQuPC9saT48bGk+U3RhbmRhcmQgRGV2aWF0aW9uLS1DYWxjdWxhdGVzIHRoZSBzdGFuZGFyZCBkZXZpYXRpb24gdmFsdWUgb2YgdGhlIHBpeGVscyB3aXRoaW4gdGhlIG5laWdoYm9yaG9vZC48L2xpPjxsaT5NZWRpYW4tLUNhbGN1bGF0ZXMgdGhlIG1lZGlhbiB2YWx1ZSBvZiBwaXhlbHMgd2l0aGluIHRoZSBuZWlnaGJvcmhvb2QuPC9saT48bGk+TWFqb3JpdHktLUNhbGN1bGF0ZXMgdGhlIG1ham9yaXR5IHZhbHVlLCBvciB0aGUgdmFsdWUgdGhhdCBvY2N1cnMgbW9zdCBmcmVxdWVudGx5LCBvZiB0aGUgcGl4ZWxzIHdpdGhpbiB0aGUgbmVpZ2hib3Job29kLjwvbGk+PGxpPk1pbm9yaXR5LS1DYWxjdWxhdGVzIHRoZSBtaW5vcml0eSB2YWx1ZSwgb3IgdGhlIHZhbHVlIHRoYXQgb2NjdXJzIGxlYXN0IGZyZXF1ZW50bHksIG9mIHRoZSBwaXhlbHMgd2l0aGluIHRoZSBuZWlnaGJvcmhvb2QuPC9saT48L3VsPlwiLFxuXHRcIkBARGV0ZWN0LUNoYW5nZS1Vc2luZy1DaGFuZ2UtQW5hbHlzaXNfY2hhbmdlZGlyZWN0aW9uX3RhZzBAQFwiOiBcIjxwPlNwZWNpZmllcyB0aGUgZGlyZWN0aW9uIG9mIGNoYW5nZSB0byBiZSBpbmNsdWRlZCBpbiB0aGUgYW5hbHlzaXMuPC9wPjxwPlRoaXMgcGFyYW1ldGVyIGlzIGF2YWlsYWJsZSBvbmx5IHdoZW4gdGhlIGlucHV0IGNoYW5nZSBhbmFseXNpcyByYXN0ZXIgaXMgdGhlIG91dHB1dCBmcm9tIHRoZSBMYW5kVHJlbmRyIHRvb2xzLjwvcD48dWw+PGxpPjxzdHJvbmc+QWxsIGRpcmVjdGlvbnM8L3N0cm9uZz4tLUFsbCBjaGFuZ2UgZGlyZWN0aW9ucyBhcmUgaW5jbHVkZWQgaW4gdGhlIG91dHB1dC4gVGhpcyBpcyB0aGUgZGVmYXVsdC48L2xpPjxsaT48c3Ryb25nPkluY3JlYXNpbmc8L3N0cm9uZz4tLU9ubHkgY2hhbmdlIGluIHRoZSBwb3NpdGl2ZSBvciBpbmNyZWFzaW5nIGRpcmVjdGlvbiBpcyBpbmNsdWRlZCBpbiB0aGUgb3V0cHV0LjwvbGk+PGxpPjxzdHJvbmc+RGVjcmVhc2luZzwvc3Ryb25nPi0tT25seSBjaGFuZ2UgaW4gdGhlIG5lZ2F0aXZlIG9yIGRlY3JlYXNpbmcgZGlyZWN0aW9uIGlzIGluY2x1ZGVkIGluIHRoZSBvdXRwdXQuPC9saT48L3VsPlwiLFxuXHRcIkBARGV0ZWN0LUNoYW5nZS1Vc2luZy1DaGFuZ2UtQW5hbHlzaXNfY2hhbmdldHlwZV90YWcwQEBcIjogXCI8cD5TcGVjaWZpZXMgdGhlIGNoYW5nZSBpbmZvcm1hdGlvbiB0byBjYWxjdWxhdGUuPC9wPjx1bD48bGk+PHN0cm9uZz5UaW1lIG9mIExhdGVzdCBDaGFuZ2U8L3N0cm9uZz4tLUVhY2ggcGl4ZWwgY29udGFpbnMgdGhlIGRhdGUgb2YgdGhlIG1vc3QgcmVjZW50IGNoYW5nZSBmb3IgdGhhdCBwaXhlbCBpbiB0aGUgdGltZSBzZXJpZXMuIFRoaXMgaXMgdGhlIGRlZmF1bHQuPC9saT48bGk+PHN0cm9uZz5UaW1lIG9mIEVhcmxpZXN0IENoYW5nZTwvc3Ryb25nPi0tRWFjaCBwaXhlbCBjb250YWlucyB0aGUgZGF0ZSBvZiB0aGUgZWFybGllc3QgY2hhbmdlIGZvciB0aGF0IHBpeGVsIGluIHRoZSB0aW1lIHNlcmllcy48L2xpPjxsaT48c3Ryb25nPlRpbWUgb2YgTGFyZ2VzdCBDaGFuZ2U8L3N0cm9uZz4tLUVhY2ggcGl4ZWwgY29udGFpbnMgdGhlIGRhdGUgb2YgdGhlIG1vc3Qgc2lnbmlmaWNhbnQgY2hhbmdlIGZvciB0aGF0IHBpeGVsIGluIHRoZSB0aW1lIHNlcmllcy48L2xpPjxsaT48c3Ryb25nPk51bWJlciBvZiBDaGFuZ2VzPC9zdHJvbmc+LS1FYWNoIHBpeGVsIGNvbnRhaW5zIHRoZSB0b3RhbCBudW1iZXIgb2YgdGltZXMgdGhlIHBpeGVsIGNoYW5nZWQgaW4gdGhlIHRpbWUgc2VyaWVzLjwvbGk+PGxpPjxzdHJvbmc+VGltZSBvZiBMb25nZXN0IENoYW5nZTwvc3Ryb25nPi0tRWFjaCBwaXhlbCBjb250YWlucyB0aGUgZGF0ZSBvZiBjaGFuZ2UgYXQgdGhlIGVuZCBvZiB0aGUgbG9uZ2VzdCB0cmFuc2l0aW9uIHNlZ21lbnQgaW4gdGhlIHRpbWUgc2VyaWVzLjwvbGk+PGxpPjxzdHJvbmc+VGltZSBvZiBTaG9ydGVzdCBDaGFuZ2U8L3N0cm9uZz4tLUVhY2ggcGl4ZWwgY29udGFpbnMgdGhlIGRhdGUgb2YgY2hhbmdlIGF0IHRoZSBlbmQgb2YgdGhlIHNob3J0ZXN0IHRyYW5zaXRpb24gc2VnbWVudCBpbiB0aGUgdGltZSBzZXJpZXMuPC9saT48bGk+PHN0cm9uZz5UaW1lIG9mIEZhc3Rlc3QgQ2hhbmdlPC9zdHJvbmc+LS1FYWNoIHBpeGVsIGNvbnRhaW5zIHRoZSBkYXRlIG9mIGNoYW5nZSBhdCB0aGUgZW5kIG9mIHRoZSB0cmFuc2l0aW9uIHRoYXQgb2NjdXJyZWQgbW9zdCBxdWlja2x5LjwvbGk+PGxpPjxzdHJvbmc+VGltZSBvZiBTbG93ZXN0IENoYW5nZTwvc3Ryb25nPi0tRWFjaCBwaXhlbCBjb250YWlucyB0aGUgZGF0ZSBvZiBjaGFuZ2UgYXQgdGhlIGVuZCBvZiB0aGUgdHJhbnNpdGlvbiB0aGF0IG9jY3VycmVkIG1vc3Qgc2xvd2x5LjwvbGk+PC91bD5cIixcblx0XCJAQERldGVjdC1DaGFuZ2UtVXNpbmctQ2hhbmdlLUFuYWx5c2lzX2ZpbHRlcmJ5ZHVyYXRpb25fdGFnMEBAXCI6IFwiPHA+U3BlY2lmaWVzIHdoZXRoZXIgdG8gZmlsdGVyIGJ5IHRoZSBjaGFuZ2UgZHVyYXRpb24uPC9wPjxwPjwvcD48dWw+PGxpPkNoZWNrZWQtLUZpbHRlciByZXN1bHRzIGJ5IGR1cmF0aW9uIHNvIHRoYXQgb25seSB0aGUgY2hhbmdlcyB0aGF0IGxhc3RlZCBhIGdpdmVuIGFtb3VudCBvZiB0aW1lIGFyZSBpbmNsdWRlZCBpbiB0aGUgb3V0cHV0LjwvbGk+PGxpPlVuY2hlY2tlZC0tRG8gbm90IGZpbHRlciByZXN1bHRzIGJ5IGR1cmF0aW9uLiBUaGlzIGlzIHRoZSBkZWZhdWx0LjwvbGk+PC91bD48cD5UaGlzIHBhcmFtZXRlciBpcyBhdmFpbGFibGUgb25seSB3aGVuIHRoZSBpbnB1dCBjaGFuZ2UgYW5hbHlzaXMgcmFzdGVyIGlzIHRoZSBvdXRwdXQgZnJvbSB0aGUgTGFuZFRyZW5kciB0b29scy48L3A+PHA+SWYgdGhpcyBwYXJhbWV0ZXIgaXMgY2hlY2tlZCwgeW91IG11c3Qgc2V0IHRoZTxzdHJvbmc+TWluaW11bSBEdXJhdGlvbjwvc3Ryb25nPmFuZDxzdHJvbmc+TWF4aW11bSBEdXJhdGlvbjwvc3Ryb25nPnBhcmFtZXRlcnMgZm9yIGZpbHRlcmluZy48L3A+XCIsXG5cdFwiQEBEZXRlY3QtQ2hhbmdlLVVzaW5nLUNoYW5nZS1BbmFseXNpc19maWx0ZXJieW1hZ25pdHVkZV90YWcwQEBcIjogXCI8cD5TcGVjaWZpZXMgd2hldGhlciB0byBmaWx0ZXIgYnkgY2hhbmdlIG1hZ25pdHVkZS48L3A+PHVsPjxsaT5DaGVja2VkLS1GaWx0ZXIgcmVzdWx0cyBieSBtYWduaXR1ZGUgc28gdGhhdCBvbmx5IHRoZSBjaGFuZ2VzIG9mIGEgZ2l2ZW4gbWFnbml0dWRlIGFyZSBpbmNsdWRlZCBpbiB0aGUgb3V0cHV0LjwvbGk+PGxpPlVuY2hlY2tlZC0tRG8gbm90IGZpbHRlciByZXN1bHRzIGJ5IG1hZ25pdHVkZS4gVGhpcyBpcyB0aGUgZGVmYXVsdC48L2xpPjwvdWw+PHA+VGhpcyBwYXJhbWV0ZXIgaXMgYXZhaWxhYmxlIG9ubHkgd2hlbiB0aGUgaW5wdXQgY2hhbmdlIGFuYWx5c2lzIHJhc3RlciBpcyB0aGUgb3V0cHV0IGZyb20gdGhlIExhbmRUcmVuZHIgdG9vbHMuPC9wPjxwPklmIHRoaXMgcGFyYW1ldGVyIGlzIGNoZWNrZWQsIHlvdSBtdXN0IHNldCB0aGU8c3Ryb25nPk1pbmltdW0gTWFnbml0dWRlPC9zdHJvbmc+YW5kPHN0cm9uZz5NYXhpbXVtIE1hZ25pdHVkZTwvc3Ryb25nPnBhcmFtZXRlcnMgZm9yIGZpbHRlcmluZy48L3A+XCIsXG5cdFwiQEBEZXRlY3QtQ2hhbmdlLVVzaW5nLUNoYW5nZS1BbmFseXNpc19maWx0ZXJieXllYXJfdGFnMEBAXCI6IFwiPHA+U3BlY2lmaWVzIHdoZXRoZXIgdG8gbGltaXQgdGhlIG91dHB1dCBieSBhIHJhbmdlIG9mIHllYXJzLjwvcD48dWw+PGxpPkNoZWNrZWQtLUZpbHRlciByZXN1bHRzIHNvIHRoYXQgb25seSBjaGFuZ2VzIHRoYXQgb2NjdXJyZWQgd2l0aGluIGEgc3BlY2lmaWMgcmFuZ2Ugb2YgeWVhcnMgYXJlIGluY2x1ZGVkIGluIHRoZSBvdXRwdXQuPC9saT48bGk+VW5jaGVja2VkLS1EbyBub3QgZmlsdGVyIHJlc3VsdHMgYnkgeWVhci4gVGhpcyBpcyB0aGUgZGVmYXVsdC48L2xpPjwvdWw+PHA+SWYgdGhpcyBwYXJhbWV0ZXIgaXMgY2hlY2tlZCwgeW91IG11c3Qgc2V0IHRoZTxzdHJvbmc+TWluaW11bSBWYWx1ZTwvc3Ryb25nPmFuZDxzdHJvbmc+TWF4aW11bSBWYWx1ZTwvc3Ryb25nPnBhcmFtZXRlcnMgZm9yIGZpbHRlcmluZy48L3A+XCIsXG5cdFwiQEBEZXRlY3QtQ2hhbmdlLVVzaW5nLUNoYW5nZS1BbmFseXNpc19maWx0ZXJieXN0YXJ0dmFsdWVfdGFnMEBAXCI6IFwiPHA+RmlsdGVyIHJlc3VsdHMgYnkgc3RhcnQgdmFsdWUgc28gdGhhdCBvbmx5IHRoZSBjaGFuZ2VzIG9mIGEgZ2l2ZW4gc3RhcnQgdmFsdWUgYXJlIGluY2x1ZGVkIGluIHRoZSBvdXRwdXQuPC9wPlwiLFxuXHRcIkBARGV0ZWN0LUNoYW5nZS1Vc2luZy1DaGFuZ2UtQW5hbHlzaXNfZmlsdGVyYnllbmR2YWx1ZV90YWcwQEBcIjogXCI8cD5GaWx0ZXIgcmVzdWx0cyBieSBlbmQgdmFsdWUgc28gdGhhdCBvbmx5IHRoZSBjaGFuZ2VzIG9mIGEgZ2l2ZW4gZW5kIHZhbHVlIGFyZSBpbmNsdWRlZCBpbiB0aGUgb3V0cHV0LjwvcD5cIixcblx0XCJAQERldGVjdC1DaGFuZ2UtVXNpbmctQ2hhbmdlLUFuYWx5c2lzX21heGltdW1udW1iZXJvZmNoYW5nZXNfdGFnMEBAXCI6IFwiPHA+VGhlIG1heGltdW0gbnVtYmVyIG9mIGNoYW5nZXMgcGVyIHBpeGVsIHRvIGJlIGNhbGN1bGF0ZWQuIFRoZSBudW1iZXIgZW50ZXJlZCBjb3JyZXNwb25kcyB0byB0aGUgbnVtYmVyIG9mIGJhbmRzIGluIHRoZSBvdXRwdXQgcmFzdGVyLiBUaGUgZGVmYXVsdCBpcyAxLCBtZWFuaW5nIG9ubHkgb25lIGNoYW5nZSBkYXRlIGlzIGNhbGN1bGF0ZWQsIGFuZCB0aGUgb3V0cHV0IHJhc3RlciBjb250YWlucyBvbmx5IG9uZSBiYW5kLjwvcD48cD5UaGlzIHBhcmFtZXRlciBpcyBub3QgYXZhaWxhYmxlIHdoZW4gdGhlPHN0cm9uZz5DaGFuZ2UgVHlwZTwvc3Ryb25nPnBhcmFtZXRlciBpcyBzZXQgdG88c3Ryb25nPk51bWJlciBvZiBjaGFuZ2VzPC9zdHJvbmc+LjwvcD5cIixcblx0XCJAQERldGVjdC1DaGFuZ2UtVXNpbmctQ2hhbmdlLUFuYWx5c2lzX3Jhc3Rlcl90YWcwQEBcIjogXCI8cD5UaGUgaW5wdXQgY2hhbmdlIGFuYWx5c2lzIHJhc3Rlci48L3A+XCIsXG5cdFwiQEBEZXRlY3QtQ2hhbmdlLVVzaW5nLUNoYW5nZS1BbmFseXNpc19zZWdtZW50ZGF0ZV90YWcwQEBcIjogXCI8cD5TcGVjaWZpZXMgd2hldGhlciB0byBleHRyYWN0IHRoZSBkYXRlIGF0IHRoZSBiZWdpbm5pbmcgb2YgYSBjaGFuZ2Ugc2VnbWVudCwgb3IgdGhlIGVuZC48L3A+PHA+VGhpcyBwYXJhbWV0ZXIgaXMgYXZhaWxhYmxlIG9ubHkgd2hlbiB0aGUgaW5wdXQgY2hhbmdlIGFuYWx5c2lzIHJhc3RlciBpcyB0aGUgb3V0cHV0IGZyb20gdGhlIExhbmRUcmVuZHIgdG9vbHMuPC9wPjx1bD48bGk+PHN0cm9uZz5CZWdpbm5pbmcgb2Ygc2VnbWVudDwvc3Ryb25nPi0tRXh0cmFjdCB0aGUgZGF0ZSBhdCB0aGUgYmVnaW5uaW5nIG9mIGEgY2hhbmdlIHNlZ21lbnQuIFRoaXMgaXMgdGhlIGRlZmF1bHQuPC9saT48bGk+PHN0cm9uZz5FbmQgb2Ygc2VnbWVudDwvc3Ryb25nPi0tRXh0cmFjdCB0aGUgZGF0ZSBhdCB0aGUgZW5kIG9mIGEgY2hhbmdlIHNlZ21lbnQuPC9saT48L3VsPlwiLFxuXHRcIkBAS2VybmVsLURlbnNpdHlfYXJlYXVuaXRzX3RhZzBAQFwiOiBcIjxwPlRoZSBhcmVhIHVuaXRzIG9mIHRoZSBvdXRwdXQgZGVuc2l0eSB2YWx1ZXMuPC9wPjx1bD48bGk+U3F1YXJlIE1hcCBVbml0cy0tRm9yIHRoZSBzcXVhcmUgb2YgdGhlIGxpbmVhciB1bml0cyBvZiB0aGUgb3V0cHV0IHNwYXRpYWwgcmVmZXJlbmNlLjwvbGk+PGxpPlNxdWFyZSBNaWxlcy0tRm9yIChVLlMuKSBtaWxlcy48L2xpPjxsaT5TcXVhcmUgS2lsb21ldGVycy0tRm9yIGtpbG9tZXRlcnMuPC9saT48bGk+QWNyZXMtLUZvciAoVS5TLikgYWNyZXMuPC9saT48bGk+SGVjdGFyZXMtLUZvciBoZWN0YXJlcy48L2xpPjxsaT5TcXVhcmUgTWV0ZXJzLS1Gb3IgbWV0ZXJzLjwvbGk+PGxpPlNxdWFyZSBZYXJkcy0tRm9yIChVLlMuKSB5YXJkcy48L2xpPjxsaT5TcXVhcmUgRmVldC0tRm9yIChVLlMuKSBmZWV0LjwvbGk+PGxpPlNxdWFyZSBJbmNoZXMtLUZvciAoVS5TLikgaW5jaGVzLjwvbGk+PGxpPlNxdWFyZSBDZW50aW1ldGVycy0tRm9yIGNlbnRpbWV0ZXJzLjwvbGk+PGxpPlNxdWFyZSBNaWxsaW1ldGVycy0tRm9yIG1pbGxpbWV0ZXJzLjwvbGk+PC91bD5cIixcblx0XCJAQEtlcm5lbC1EZW5zaXR5X2NlbGxzaXplX3RhZzBAQFwiOiBcIjxwPlRoZSBwaXhlbCBzaXplIGZvciB0aGUgb3V0cHV0IHJhc3RlciBkYXRhc2V0LiBJZiB0aGU8c3Ryb25nPkNlbGxzaXplPC9zdHJvbmc+dmFsdWUgaGFzIGJlZW4gc2V0IGluIHRoZSBnZW9wcm9jZXNzaW5nIGVudmlyb25tZW50cywgaXQgaXMgdGhlIGRlZmF1bHQuPC9wPlwiLFxuXHRcIkBAS2VybmVsLURlbnNpdHlfaW5wdXRiYXJyaWVyc190YWcwQEBcIjogXCI8cD5UaGUgZGF0YXNldCB0aGF0IGRlZmluZXMgdGhlIGJhcnJpZXJzLjwvcD48cD5UaGUgYmFycmllcnMgY2FuIGJlIGEgZmVhdHVyZSBsYXllciBvZiBwb2x5bGluZSBvciBwb2x5Z29uIGZlYXR1cmVzLjwvcD5cIixcblx0XCJAQEtlcm5lbC1EZW5zaXR5X2lucHV0ZmVhdHVyZXNfdGFnMEBAXCI6IFwiPHA+VGhlIGlucHV0IHBvaW50IG9yIGxpbmUgZmVhdHVyZXMgZm9yIHdoaWNoIHRvIGNhbGN1bGF0ZSB0aGUgZGVuc2l0eS48L3A+XCIsXG5cdFwiQEBLZXJuZWwtRGVuc2l0eV9tZXRob2RfdGFnMEBAXCI6IFwiPHA+RGV0ZXJtaW5lcyB3aGV0aGVyIHRvIHVzZSBhIHNob3J0ZXN0IHBhdGggb24gYSBzcGhlcm9pZCAoZ2VvZGVzaWMpIG9yIGEgZmxhdCBlYXJ0aCAocGxhbmFyKSBtZXRob2QuPC9wPjx1bD48bGk+PHN0cm9uZz5QbGFuYXI8L3N0cm9uZz4tLVVzZXMgcGxhbmFyIGRpc3RhbmNlcyBiZXR3ZWVuIHRoZSBmZWF0dXJlcy4gVGhpcyBpcyB0aGUgZGVmYXVsdC48L2xpPjxsaT48c3Ryb25nPkdlb2Rlc2ljPC9zdHJvbmc+LS1Vc2VzIGdlb2Rlc2ljIGRpc3RhbmNlcyBiZXR3ZWVuIGZlYXR1cmVzLiBUaGlzIG1ldGhvZCB0YWtlcyBpbnRvIGFjY291bnQgdGhlIGN1cnZhdHVyZSBvZiB0aGUgc3BoZXJvaWQgYW5kIGNvcnJlY3RseSBkZWFscyB3aXRoIGRhdGEgbmVhciB0aGUgcG9sZXMgYW5kIHRoZSBpbnRlcm5hdGlvbmFsIGRhdGVsaW5lLjwvbGk+PC91bD48cD5JdCBpcyByZWNvbW1lbmRlZCB0aGF0IHlvdSB1c2UgdGhlPHN0cm9uZz5HZW9kZXNpYzwvc3Ryb25nPm1ldGhvZCB3aXRoIGRhdGEgc3RvcmVkIGluIGEgY29vcmRpbmF0ZSBzeXN0ZW0gdGhhdCBpcyBub3QgYXBwcm9wcmlhdGUgZm9yIGRpc3RhbmNlIG1lYXN1cmVtZW50cyBhbmQgYW55IGFuYWx5c2lzIHRoYXQgc3BhbnMgYSBsYXJnZSBnZW9ncmFwaGljIGFyZWEuIEZvciBleGFtcGxlLCBXZWIgTWVyY2F0b3Igb3IgYW55IGdlb2dyYXBoaWMgY29vcmRpbmF0ZSBzeXN0ZW0gc2hvdWxkIHVzZSB0aGU8c3Ryb25nPkdlb2Rlc2ljPC9zdHJvbmc+bWV0aG9kLjwvcD5cIixcblx0XCJAQEtlcm5lbC1EZW5zaXR5X291dHB1dGNlbGx2YWx1ZXNfdGFnMEBAXCI6IFwiPHA+RGV0ZXJtaW5lcyB3aGF0IHRoZSB2YWx1ZXMgaW4gdGhlIG91dHB1dCByYXN0ZXIgcmVwcmVzZW50LjwvcD48dWw+PGxpPjxzdHJvbmc+RGVuc2l0aWVzPC9zdHJvbmc+LS1UaGUgb3V0cHV0IHZhbHVlcyByZXByZXNlbnQgdGhlIHByZWRpY3RlZCBkZW5zaXR5IHZhbHVlLiBUaGlzIGlzIHRoZSBkZWZhdWx0LjwvbGk+PGxpPjxzdHJvbmc+RXhwZWN0ZWQgQ291bnRzPC9zdHJvbmc+LS1UaGUgb3V0cHV0IHZhbHVlcyByZXByZXNlbnQgdGhlIHByZWRpY3RlZCBhbW91bnQgb2YgdGhlIHBoZW5vbWVub24gd2l0aGluIGVhY2ggcGl4ZWwuIFNpbmNlIHRoZSBwaXhlbCB2YWx1ZSBpcyBsaW5rZWQgdG8gdGhlIHNwZWNpZmllZDxzdHJvbmc+Q2VsbHNpemU8L3N0cm9uZz52YWx1ZSwgdGhlIHJlc3VsdGluZyByYXN0ZXIgY2Fubm90IGJlIHJlc2FtcGxlZCB0byBhIGRpZmZlcmVudCBwaXhlbCBzaXplIGFuZCBzdGlsbCByZXByZXNlbnQgdGhlIGFtb3VudCBvZiB0aGUgcGhlbm9tZW5vbi48L2xpPjwvdWw+XCIsXG5cdFwiQEBLZXJuZWwtRGVuc2l0eV9wb3B1bGF0aW9uZmllbGRfdGFnMEBAXCI6IFwiPHA+RmllbGQgZGVub3RpbmcgcG9wdWxhdGlvbiB2YWx1ZXMgZm9yIGVhY2ggZmVhdHVyZS4gVGhlPHN0cm9uZz5Qb3B1bGF0aW9uIEZpZWxkPC9zdHJvbmc+dmFsdWUgaXMgdGhlIGNvdW50IG9yIHF1YW50aXR5IHRvIGJlIHNwcmVhZCBhY3Jvc3MgdGhlIGxhbmRzY2FwZSB0byBjcmVhdGUgYSBjb250aW51b3VzIHN1cmZhY2UuIFZhbHVlcyBpbiB0aGU8c3Ryb25nPlBvcHVsYXRpb24gRmllbGQ8L3N0cm9uZz5tYXkgYmUgaW50ZWdlciBvciBmbG9hdGluZyBwb2ludC48L3A+PHA+VGhlIG9wdGlvbnMgYW5kIGRlZmF1bHQgYmVoYXZpb3JzIGZvciB0aGUgZmllbGQgYXJlIGxpc3RlZCBiZWxvdyBpbiB0aGUgb3JkZXIgb2YgcHJpb3JpdHkuPC9wPjx1bD48bGk+VXNlPHN0cm9uZz5Ob25lPC9zdHJvbmc+aWYgbm8gaXRlbSBvciBzcGVjaWFsIHZhbHVlIHdpbGwgYmUgdXNlZCBhbmQgZWFjaCBmZWF0dXJlIHdpbGwgYmUgY291bnRlZCBvbmNlLjwvbGk+PGxpPlVzZTxzdHJvbmc+U2hhcGU8L3N0cm9uZz5pZiB0aGUgaW5wdXQgZmVhdHVyZXMgY29udGFpbiBaLjwvbGk+PGxpPk90aGVyd2lzZSwgdGhlIGRlZmF1bHQgZmllbGQgaXM8c3Ryb25nPlBPUFVMQVRJT048L3N0cm9uZz4sIG9yIGFueSBhY2NlcHRhYmxlIGRlcml2YXRpdmUgb2YgcG9wdWxhdGlvbjo8dWw+PGxpPjxzdHJvbmc+UE9QVUxBVElPTnh4eHg8L3N0cm9uZz53aGVyZTxzdHJvbmc+eHh4eDwvc3Ryb25nPmNhbiBiZSBhbnkgdmFsaWQgY2hhcmFjdGVyLCBzdWNoIGFzPHN0cm9uZz5QT1BVTEFUSU9ONjwvc3Ryb25nPiw8c3Ryb25nPlBPUFVMQVRJT04xOTc0PC9zdHJvbmc+LCBvcjxzdHJvbmc+UE9QVUxBVElPTlJPQURUWVBFPC9zdHJvbmc+LjwvbGk+PGxpPjxzdHJvbmc+UE9QPC9zdHJvbmc+LjwvbGk+PGxpPjxzdHJvbmc+UE9QeHh4eDwvc3Ryb25nPi48L2xpPjxsaT5JZiBub25lIG9mIHRoZSBhYm92ZSBhcHBseSwgdGhlIGRlZmF1bHQgaXM8c3Ryb25nPk5vbmU8L3N0cm9uZz4uPC9saT48L3VsPjwvbGk+PC91bD5cIixcblx0XCJAQEtlcm5lbC1EZW5zaXR5X3NlYXJjaHJhZGl1c190YWcwQEBcIjogXCI8cD5UaGUgc2VhcmNoIHJhZGl1cyB3aXRoaW4gd2hpY2ggdG8gY2FsY3VsYXRlIGRlbnNpdHkuIFVuaXRzIGFyZSBiYXNlZCBvbiB0aGUgbGluZWFyIHVuaXQgb2YgdGhlIHByb2plY3Rpb24uPC9wPjxwPkZvciBleGFtcGxlLCBpZiB0aGUgdW5pdHMgYXJlIGluIG1ldGVycy0tdG8gaW5jbHVkZSBhbGwgZmVhdHVyZXMgd2l0aGluIGEgb25lLW1pbGUgbmVpZ2hib3Job29kLS1zZXQgdGhlIHNlYXJjaCByYWRpdXMgZXF1YWwgdG8gMTYwOS4zNDQgKHNpbmNlIDEgbWlsZSBpcyAxNjA5LjM0NCBtZXRlcnMpLjwvcD5cIixcblx0XCJAQFpvbmFsLVN0YXRpc3RpY3NfaWdub3Jlbm9kYXRhaW5jYWxjdWxhdGlvbnNfdGFnMEBAXCI6IFwiPHA+RGVub3RlcyB3aGV0aGVyPHN0cm9uZz5Ob0RhdGE8L3N0cm9uZz52YWx1ZXMgaW4gdGhlPHN0cm9uZz5WYWx1ZSBSYXN0ZXI8L3N0cm9uZz53aWxsIGluZmx1ZW5jZSB0aGUgcmVzdWx0cyBvZiB0aGUgem9uZSB0aGF0IHRoZXkgZmFsbCB3aXRoaW4uPC9wPjx1bD48bGk+PHN0cm9uZz5ZZXM8L3N0cm9uZz4tLVdpdGhpbiBhbnkgcGFydGljdWxhciB6b25lLCBvbmx5IHBpeGVscyB0aGF0IGhhdmUgYSB2YWx1ZSBpbiB0aGU8c3Ryb25nPlZhbHVlIFJhc3Rlcjwvc3Ryb25nPndpbGwgYmUgdXNlZCBpbiBkZXRlcm1pbmluZyB0aGUgb3V0cHV0IHZhbHVlIGZvciB0aGF0IHpvbmUuPHN0cm9uZz5Ob0RhdGE8L3N0cm9uZz5waXhlbHMgaW4gdGhlPHN0cm9uZz5WYWx1ZSBSYXN0ZXI8L3N0cm9uZz53aWxsIGJlIGlnbm9yZWQgaW4gdGhlIHN0YXRpc3RpYyBjYWxjdWxhdGlvbi4gVGhpcyBpcyB0aGUgZGVmYXVsdC48L2xpPjxsaT48c3Ryb25nPk5vPC9zdHJvbmc+LS1XaXRoaW4gYW55IHBhcnRpY3VsYXIgem9uZSwgaWYgYW55PHN0cm9uZz5Ob0RhdGE8L3N0cm9uZz5waXhlbHMgZXhpc3QgaW4gdGhlPHN0cm9uZz5WYWx1ZSBSYXN0ZXI8L3N0cm9uZz4sIGl0IGlzIGRlZW1lZCB0aGF0IHRoZXJlIGlzIGluc3VmZmljaWVudCBpbmZvcm1hdGlvbiB0byBwZXJmb3JtIHN0YXRpc3RpY2FsIGNhbGN1bGF0aW9ucyBmb3IgYWxsIHRoZSBwaXhlbHMgaW4gdGhhdCB6b25lOyB0aGVyZWZvcmUsIHRoZSBlbnRpcmUgem9uZSB3aWxsIHJlY2VpdmUgdGhlPHN0cm9uZz5Ob0RhdGE8L3N0cm9uZz52YWx1ZSBvbiB0aGUgb3V0cHV0IHJhc3Rlci48L2xpPjwvdWw+XCIsXG5cdFwiQEBab25hbC1TdGF0aXN0aWNzX3BlcmNlbnRpbGVpbnRlcnBvbGF0aW9udHlwZV90YWcwQEBcIjogXCI8cD5EZXRlcm1pbmVzIHRoZSBtZXRob2Qgb2YgcGVyY2VudGlsZSBpbnRlcnBvbGF0aW9uIHRvIGJlIHVzZWQgd2hlbiB0aGUgbnVtYmVyIG9mIHZhbHVlcyBmcm9tIHRoZSBpbnB1dCByYXN0ZXIgdG8gYmUgY2FsY3VsYXRlZCBhcmUgZXZlbi48L3A+PHVsPjxsaT48c3Ryb25nPkF1dG8tZGV0ZWN0PC9zdHJvbmc+LS1JZiB0aGUgaW5wdXQgdmFsdWUgcmFzdGVyIGlzIG9mIGludGVnZXIgcGl4ZWwgdHlwZSwgdGhlPHN0cm9uZz5OZWFyZXN0PC9zdHJvbmc+bWV0aG9kIGlzIHVzZWQuIElmIHRoZSBpbnB1dCB2YWx1ZSByYXN0ZXIgaXMgb2YgZmxvYXRpbmcgcG9pbnQgcGl4ZWwgdHlwZSwgdGhlbiB0aGU8c3Ryb25nPkxpbmVhcjwvc3Ryb25nPm1ldGhvZCBpcyB1c2VkLiBUaGlzIGlzIHRoZSBkZWZhdWx0LjwvbGk+PGxpPjxzdHJvbmc+TmVhcmVzdDwvc3Ryb25nPi0tVGhlIG5lYXJlc3QgYXZhaWxhYmxlIHZhbHVlIHRvIHRoZSBkZXNpcmVkIHBlcmNlbnRpbGUgaXMgdXNlZC4gSW4gdGhpcyBjYXNlLCB0aGUgb3V0cHV0IHBpeGVsIHR5cGUgaXMgdGhlIHNhbWUgYXMgdGhhdCBvZiB0aGUgaW5wdXQgdmFsdWUgcmFzdGVyLjwvbGk+PGxpPjxzdHJvbmc+TGluZWFyPC9zdHJvbmc+LS1UaGUgd2VpZ2h0ZWQgYXZlcmFnZSBvZiB0aGUgdHdvIHN1cnJvdW5kaW5nIHZhbHVlcyBmcm9tIHRoZSBkZXNpcmVkIHBlcmNlbnRpbGUgaXMgdXNlZC4gSW4gdGhpcyBjYXNlLCB0aGUgb3V0cHV0IHBpeGVsIHR5cGUgaXMgZmxvYXRpbmcgcG9pbnQuPC9saT48L3VsPlwiLFxuXHRcIkBAWm9uYWwtU3RhdGlzdGljc19wZXJjZW50aWxldmFsdWVfdGFnMEBAXCI6IFwiPHA+VGhlIHBlcmNlbnRpbGUgdG8gY2FsY3VsYXRlLiBUaGUgZGVmYXVsdCBpcyA5MCwgZm9yIHRoZSA5MHRoIHBlcmNlbnRpbGUuPC9wPjxwPlRoZSB2YWx1ZXMgY2FuIHJhbmdlIGZyb20gMCB0aHJvdWdoIDEwMC4gVGhlIDB0aCBwZXJjZW50aWxlIGlzIGVzc2VudGlhbGx5IGVxdWl2YWxlbnQgdG8gdGhlIE1pbmltdW0gc3RhdGlzdGljLCBhbmQgdGhlIDEwMHRoIHBlcmNlbnRpbGUgaXMgZXF1aXZhbGVudCB0byBNYXhpbXVtLiBBIHZhbHVlIG9mIDUwIHdpbGwgcHJvZHVjZSBlc3NlbnRpYWxseSB0aGUgc2FtZSByZXN1bHQgYXMgdGhlIE1lZGlhbiBzdGF0aXN0aWMuPC9wPlwiLFxuXHRcIkBAWm9uYWwtU3RhdGlzdGljc19wcm9jZXNzYXNtdWx0aWRpbWVuc2lvbmFsX3RhZzBAQFwiOiBcIjxwPkRldGVybWluZXMgaG93IHRoZSBpbnB1dCBtdWx0aWRpbWVuc2lvbmFsIHZhbHVlIHJhc3RlciBpcyBwcm9jZXNzZWQuPC9wPjx1bD48bGk+PHN0cm9uZz5DdXJyZW50IFNsaWNlPC9zdHJvbmc+LS1TdGF0aXN0aWNzIHdpbGwgYmUgY2FsY3VsYXRlZCBmcm9tIHRoZSBjdXJyZW50IHNsaWNlIG9mIGEgbXVsdGlkaW1lbnNpb25hbCBkYXRhc2V0LiBUaGlzIGlzIHRoZSBkZWZhdWx0LjwvbGk+PGxpPjxzdHJvbmc+QWxsIFNsaWNlczwvc3Ryb25nPi0tU3RhdGlzdGljcyB3aWxsIGJlIGNhbGN1bGF0ZWQgZm9yIGFsbCBkaW1lbnNpb25zIChzdWNoIGFzIHRpbWUgb3IgZGVwdGgpIG9mIGEgbXVsdGlkaW1lbnNpb25hbCBkYXRhc2V0LjwvbGk+PC91bD5cIixcblx0XCJAQFpvbmFsLVN0YXRpc3RpY3Nfc3RhdGlzdGljc3R5cGVfdGFnMEBAXCI6IFwiPHA+U3RhdGlzdGljIHR5cGUgdG8gYmUgY2FsY3VsYXRlZC48L3A+PHVsPjxsaT48c3Ryb25nPk1lYW48L3N0cm9uZz4tLUNhbGN1bGF0ZXMgdGhlIGF2ZXJhZ2Ugb2YgYWxsIHBpeGVscyBpbiB0aGU8c3Ryb25nPlZhbHVlIFJhc3Rlcjwvc3Ryb25nPnRoYXQgYmVsb25nIHRvIHRoZSBzYW1lIHpvbmUgYXMgdGhlIG91dHB1dCBwaXhlbC48L2xpPjxsaT48c3Ryb25nPk1ham9yaXR5PC9zdHJvbmc+LS1EZXRlcm1pbmVzIHRoZSB2YWx1ZSB0aGF0IG9jY3VycyBtb3N0IG9mdGVuIG9mIGFsbCBwaXhlbHMgaW4gdGhlPHN0cm9uZz5WYWx1ZSBSYXN0ZXI8L3N0cm9uZz50aGF0IGJlbG9uZyB0byB0aGUgc2FtZSB6b25lIGFzIHRoZSBvdXRwdXQgcGl4ZWwuPC9saT48bGk+PHN0cm9uZz5NYXhpbXVtPC9zdHJvbmc+LS1EZXRlcm1pbmVzIHRoZSBsYXJnZXN0IHZhbHVlIG9mIGFsbCBwaXhlbHMgaW4gdGhlPHN0cm9uZz5WYWx1ZSBSYXN0ZXI8L3N0cm9uZz50aGF0IGJlbG9uZyB0byB0aGUgc2FtZSB6b25lIGFzIHRoZSBvdXRwdXQgcGl4ZWwuPC9saT48bGk+PHN0cm9uZz5NZWRpYW48L3N0cm9uZz4tLURldGVybWluZXMgdGhlIG1lZGlhbiB2YWx1ZSBvZiBhbGwgcGl4ZWxzIGluIHRoZTxzdHJvbmc+VmFsdWUgUmFzdGVyPC9zdHJvbmc+dGhhdCBiZWxvbmcgdG8gdGhlIHNhbWUgem9uZSBhcyB0aGUgb3V0cHV0IHBpeGVsLjwvbGk+PGxpPjxzdHJvbmc+TWluaW11bTwvc3Ryb25nPi0tRGV0ZXJtaW5lcyB0aGUgc21hbGxlc3QgdmFsdWUgb2YgYWxsIHBpeGVscyBpbiB0aGU8c3Ryb25nPlZhbHVlIFJhc3Rlcjwvc3Ryb25nPnRoYXQgYmVsb25nIHRvIHRoZSBzYW1lIHpvbmUgYXMgdGhlIG91dHB1dCBwaXhlbC48L2xpPjxsaT48c3Ryb25nPk1pbm9yaXR5PC9zdHJvbmc+LS1EZXRlcm1pbmVzIHRoZSB2YWx1ZSB0aGF0IG9jY3VycyBsZWFzdCBvZnRlbiBvZiBhbGwgcGl4ZWxzIGluIHRoZTxzdHJvbmc+VmFsdWUgUmFzdGVyPC9zdHJvbmc+dGhhdCBiZWxvbmcgdG8gdGhlIHNhbWUgem9uZSBhcyB0aGUgb3V0cHV0IHBpeGVsLjwvbGk+PGxpPjxzdHJvbmc+UGVyY2VudGlsZTwvc3Ryb25nPi0tQ2FsY3VsYXRlcyBhIHBlcmNlbnRpbGUgb2YgYWxsIHBpeGVscyBpbiB0aGU8c3Ryb25nPlZhbHVlIFJhc3Rlcjwvc3Ryb25nPnRoYXQgYmVsb25nIHRvIHRoZSBzYW1lIHpvbmUgYXMgdGhlIG91dHB1dCBwaXhlbC4gVGhlIDkwdGggcGVyY2VudGlsZSBpcyBjYWxjdWxhdGVkIGJ5IGRlZmF1bHQuIFlvdSBjYW4gZGV0ZXJtaW5lIHdoaWNoIHBlcmNlbnRpbGUgdG8gY2FsY3VsYXRlIHdpdGggdGhlPHN0cm9uZz5QZXJjZW50aWxlIFZhbHVlPC9zdHJvbmc+cGFyYW1ldGVyLjwvbGk+PGxpPjxzdHJvbmc+UmFuZ2U8L3N0cm9uZz4tLUNhbGN1bGF0ZXMgdGhlIGRpZmZlcmVuY2UgYmV0d2VlbiB0aGUgbGFyZ2VzdCBhbmQgc21hbGxlc3QgdmFsdWUgb2YgYWxsIHBpeGVscyBpbiB0aGU8c3Ryb25nPlZhbHVlIFJhc3Rlcjwvc3Ryb25nPnRoYXQgYmVsb25nIHRvIHRoZSBzYW1lIHpvbmUgYXMgdGhlIG91dHB1dCBwaXhlbC48L2xpPjxsaT48c3Ryb25nPlN0YW5kYXJkIERldmlhdGlvbjwvc3Ryb25nPi0tQ2FsY3VsYXRlcyB0aGUgc3RhbmRhcmQgZGV2aWF0aW9uIG9mIGFsbCBwaXhlbHMgaW4gdGhlPHN0cm9uZz5WYWx1ZSBSYXN0ZXI8L3N0cm9uZz50aGF0IGJlbG9uZyB0byB0aGUgc2FtZSB6b25lIGFzIHRoZSBvdXRwdXQgcGl4ZWwuPC9saT48bGk+PHN0cm9uZz5TdW08L3N0cm9uZz4tLUNhbGN1bGF0ZXMgdGhlIHRvdGFsIHZhbHVlIG9mIGFsbCBwaXhlbHMgaW4gdGhlPHN0cm9uZz5WYWx1ZSBSYXN0ZXI8L3N0cm9uZz50aGF0IGJlbG9uZyB0byB0aGUgc2FtZSB6b25lIGFzIHRoZSBvdXRwdXQgcGl4ZWwuPC9saT48bGk+PHN0cm9uZz5WYXJpZXR5PC9zdHJvbmc+LS1DYWxjdWxhdGVzIHRoZSBudW1iZXIgb2YgdW5pcXVlIHZhbHVlcyBmb3IgYWxsIHBpeGVscyBpbiB0aGU8c3Ryb25nPlZhbHVlIFJhc3Rlcjwvc3Ryb25nPnRoYXQgYmVsb25nIHRvIHRoZSBzYW1lIHpvbmUgYXMgdGhlIG91dHB1dCBwaXhlbC48L2xpPjwvdWw+XCIsXG5cdFwiQEBab25hbC1TdGF0aXN0aWNzX3ZhbHVlcmFzdGVyX3RhZzBAQFwiOiBcIjxwPlJhc3RlciB0aGF0IGNvbnRhaW5zIHRoZSB2YWx1ZXMgb24gd2hpY2ggdG8gY2FsY3VsYXRlIGEgc3RhdGlzdGljLjwvcD5cIixcblx0XCJAQFpvbmFsLVN0YXRpc3RpY3Nfem9uZWZpZWxkX3RhZzBAQFwiOiBcIjxwPkZpZWxkIHRoYXQgaG9sZHMgdGhlIHZhbHVlcyB0aGF0IGRlZmluZSBlYWNoIHpvbmUuIEl0IGNhbiBiZSBhbiBpbnRlZ2VyIG9yIGEgc3RyaW5nIGZpZWxkIG9mIHRoZSB6b25lIHJhc3Rlci48L3A+XCIsXG5cdFwiQEBab25hbC1TdGF0aXN0aWNzX3pvbmVyYXN0ZXJfdGFnMEBAXCI6IFwiPHA+RGF0YXNldCB0aGF0IGRlZmluZXMgdGhlIHpvbmVzLiBUaGUgem9uZXMgY2FuIGJlIGRlZmluZWQgYnkgYW4gaW50ZWdlciByYXN0ZXIuPC9wPlwiLFxuXHRcIkBAWm9uYWwtU3RhdGlzdGljc19jYWxjdWxhdGVjaXJjdWxhcnN0YXRpc3RpY3NfdGFnMEBAXCI6IFwiPHA+U3BlY2lmaWVzIGhvdyB0aGUgc3RhdGlzdGljcyB0eXBlIHdpbGwgYmUgY2FsY3VsYXRlZC48L3A+PHVsPjxsaT48c3Ryb25nPkFyaXRobWV0aWM8L3N0cm9uZz4tLUNhbGN1bGF0ZXMgYXJpdGhtZXRpYyBzdGF0aXN0aWNzLiBUaGlzIGlzIHRoZSBkZWZhdWx0LjwvbGk+PGxpPjxzdHJvbmc+Q2lyY3VsYXI8L3N0cm9uZz4tLUNhbGN1bGF0ZXMgY2lyY3VsYXIgc3RhdGlzdGljcyB0aGF0IGFyZSBhcHByb3ByaWF0ZSBmb3IgY3ljbGljIHF1YW50aXRpZXMsIHN1Y2ggYXMgY29tcGFzcyBkaXJlY3Rpb24gaW4gZGVncmVlcywgZGF5dGltZXMsIGFuZCBmcmFjdGlvbmFsIHBhcnRzIG9mIHJlYWwgbnVtYmVycy48L2xpPjwvdWw+XCIsXG5cdFwiQEBab25hbC1TdGF0aXN0aWNzX2NpcmN1bGFyd3JhcHZhbHVlX3RhZzBAQFwiOiBcIjxwPlRoZSBoaWdoZXN0IHBvc3NpYmxlIHZhbHVlICh1cHBlciBib3VuZCkgaW4gdGhlIGN5Y2xpYyBkYXRhLiBJdCBpcyBhIHBvc2l0aXZlIG51bWJlciwgd2l0aCBhIGRlZmF1bHQgdmFsdWUgb2YgMzYwLiBUaGlzIHZhbHVlIGFsc28gcmVwcmVzZW50cyB0aGUgc2FtZSBxdWFudGl0eSBhcyB0aGUgbG93ZXN0IHBvc3NpYmxlIHZhbHVlIChsb3dlciBib3VuZCkuPC9wPjxwPlRoaXMgcGFyYW1ldGVyIGlzIGFwcGxpY2FibGUgb25seSB3aGVuIGNpcmN1bGFyIHN0YXRpc3RpY3MgaXMgY2FsY3VsYXRlZC48L3A+XCIsXG5cdFwiQEBCb3VuZGFyeS1DbGVhbi1mdW5jdGlvbl9pbnB1dHJhc3Rlcl90YWcwQEBcIjogXCI8cD5UaGUgaW5wdXQgcmFzdGVyIGZvciB3aGljaCB0aGUgYm91bmRhcnkgYmV0d2VlbiB6b25lcyB3aWxsIGJlIHNtb290aGVkLjwvcD48cD5JdCBtdXN0IGJlIG9mIGludGVnZXIgdHlwZS48L3A+XCIsXG5cdFwiQEBCb3VuZGFyeS1DbGVhbi1mdW5jdGlvbl9ydW5leHBhbnNpb25hbmRzaHJpbmtpbmd0d2ljZV90YWcwQEBcIjogXCI8cD5TcGVjaWZpZXMgdGhlIG51bWJlciBvZiB0aW1lcyB0aGUgc21vb3RoaW5nIHByb2Nlc3Mgd2lsbCBvY2N1ciwgdHdpY2Ugb3Igb25jZS48L3A+PHVsPjxsaT48cD48c3Ryb25nPkNoZWNrZWQ8L3N0cm9uZz4tLVBlcmZvcm1zIGFuIGV4cGFuc2lvbiBhbmQgc2hyaW5raW5nIG9wZXJhdGlvbiB0d28gdGltZXMuIEZvciB0aGUgZmlyc3QgdGltZSwgdGhlIG9wZXJhdGlvbiBpcyBwZXJmb3JtZWQgYWNjb3JkaW5nIHRvIHRoZSBzcGVjaWZpZWQgc29ydGluZyB0eXBlLiBUaGVuIGFuIGFkZGl0aW9uYWwgZXhwYW5zaW9uIGFuZCBzaHJpbmtpbmcgb3BlcmF0aW9uIGlzIHBlcmZvcm1lZCB3aXRoIHRoZSBwcmlvcml0eSByZXZlcnNlZC4gVGhpcyBpcyB0aGUgZGVmYXVsdC48L3A+PC9saT48bGk+PHA+PHN0cm9uZz5VbmNoZWNrZWQ8L3N0cm9uZz4tLVBlcmZvcm1zIHRoZSBleHBhbnNpb24gYW5kIHNocmlua2luZyBvcGVyYXRpb24gb25jZSBhY2NvcmRpbmcgdG8gdGhlIHNvcnRpbmcgdHlwZS48L3A+PC9saT48L3VsPlwiLFxuXHRcIkBAQm91bmRhcnktQ2xlYW4tZnVuY3Rpb25fc29ydHR5cGVfdGFnMEBAXCI6IFwiPHA+U3BlY2lmaWVzIHRoZSB0eXBlIG9mIHNvcnRpbmcgdG8gdXNlIGluIHRoZSBzbW9vdGhpbmcgcHJvY2Vzcy4gVGhlIHNvcnRpbmcgZGV0ZXJtaW5lcyB0aGUgcHJpb3JpdHkgYnkgd2hpY2ggY2VsbHMgY2FuIGV4cGFuZCBpbnRvIHRoZWlyIG5laWdoYm9ycy48L3A+PHA+VGhlIHNvcnRpbmcgY2FuIGJlIGRvbmUgYmFzZWQgb24gem9uZSB2YWx1ZSBvciB6b25lIGFyZWEuPC9wPjx1bD48bGk+PHA+PHN0cm9uZz5EbyBub3Qgc29ydDwvc3Ryb25nPi0tVGhlIHpvbmVzIGFyZSBub3Qgc29ydGVkIGJ5IHNpemUuIFpvbmVzIHdpdGggbGFyZ2VyIHZhbHVlcyBoYXZlIGEgaGlnaGVyIHByaW9yaXR5IHRvIGV4cGFuZCBpbnRvIHpvbmVzIHdpdGggc21hbGxlciB2YWx1ZXMgaW4gdGhlIHNtb290aGVkIG91dHB1dC4gVGhpcyBpcyB0aGUgZGVmYXVsdC48L3A+PC9saT48bGk+PHA+PHN0cm9uZz5EZXNjZW5kaW5nPC9zdHJvbmc+LS1Tb3J0cyB6b25lcyBpbiBkZXNjZW5kaW5nIG9yZGVyIGJ5IHNpemUuIFpvbmVzIHdpdGggbGFyZ2VyIHRvdGFsIGFyZWFzIGhhdmUgYSBoaWdoZXIgcHJpb3JpdHkgdG8gZXhwYW5kIGludG8gem9uZXMgd2l0aCBzbWFsbGVyIHRvdGFsIGFyZWFzLiBUaGlzIG9wdGlvbiB0ZW5kcyB0byBlbGltaW5hdGUgb3IgcmVkdWNlIHRoZSBwcmV2YWxlbmNlIG9mIGNlbGxzIGZyb20gc21hbGxlciB6b25lcyBpbiB0aGUgc21vb3RoZWQgb3V0cHV0LjwvcD48L2xpPjxsaT48cD48c3Ryb25nPkFzY2VuZGluZzwvc3Ryb25nPi0tU29ydHMgem9uZXMgaW4gYXNjZW5kaW5nIG9yZGVyIGJ5IHNpemUuIFpvbmVzIHdpdGggc21hbGxlciB0b3RhbCBhcmVhcyBoYXZlIGEgaGlnaGVyIHByaW9yaXR5IHRvIGV4cGFuZCBpbnRvIHpvbmVzIHdpdGggbGFyZ2VyIHRvdGFsIGFyZWFzLiBUaGlzIG9wdGlvbiB0ZW5kcyB0byBwcmVzZXJ2ZSBvciBpbmNyZWFzZSB0aGUgcHJldmFsZW5jZSBvZiBjZWxscyBmcm9tIHNtYWxsZXIgem9uZXMgaW4gdGhlIHNtb290aGVkIG91dHB1dC48L3A+PC9saT48L3VsPlwiLFxuXHRcIkBAQWdncmVnYXRlLU11bHRpZGltZW5zaW9uYWxfZGltZW5zaW9uX3RhZzBAQFwiOiBcIjxwPlRoZSBhZ2dyZWdhdGlvbiBkaW1lbnNpb24uIFRoaXMgaXMgdGhlIGRpbWVuc2lvbiBhbG9uZyB3aGljaCB0aGUgdmFyaWFibGVzIHdpbGwgYmUgYWdncmVnYXRlZC48L3A+XCIsXG5cdFwiQEBBZ2dyZWdhdGUtTXVsdGlkaW1lbnNpb25hbF9kaW1lbnNpb25kZWZpbml0aW9uX3RhZzBAQFwiOiBcIjxwPlNwZWNpZmllcyB0aGUgbWV0aG9kIHRvIHVzZSB0byBmaWx0ZXIgdGhlIGlucHV0IG11bHRpZGltZW5zaW9uYWwgZGF0YSBiZWZvcmUgcGVyZm9ybWluZyB0aGUgYWdncmVnYXRpb24uPC9wPjx1bD48bGk+PHN0cm9uZz5BbGw8L3N0cm9uZz4tLVRoZSBmdWxsIHJhbmdlIGZvciBlYWNoIGRpbWVuc2lvbiB3aWxsIGJlIHVzZWQuIFRoaXMgaXMgdGhlIGRlZmF1bHQuPC9saT48bGk+PHN0cm9uZz5CeSBWYWx1ZXM8L3N0cm9uZz4tLVRoZSBkaW1lbnNpb24gd2lsbCBiZSBzbGljZWQgdXNpbmcgYSBkaW1lbnNpb24gdmFsdWUgb3IgbGlzdCBvZiB2YWx1ZXMuPC9saT48bGk+PHN0cm9uZz5CeSBSYW5nZXM8L3N0cm9uZz4tLVRoZSBkaW1lbnNpb24gd2lsbCBiZSBzbGljZWQgdXNpbmcgYSByYW5nZSBvciBhIGxpc3Qgb2YgcmFuZ2VzLjwvbGk+PGxpPjxzdHJvbmc+QnkgSXRlcmF0aW9uPC9zdHJvbmc+LS1UaGUgZGltZW5zaW9uIHdpbGwgYmUgc2xpY2VkIG92ZXIgYSBzcGVjaWZpZWQgaW50ZXJ2YWwgc2l6ZS48L2xpPjwvdWw+XCIsXG5cdFwiQEBBZ2dyZWdhdGUtTXVsdGlkaW1lbnNpb25hbF9pdGVyYXRpb25kZWZpbml0aW9ucGFyYW1ldGVyc190YWcwQEBcIjogXCI8cD5UaGUgSXRlcmF0aW9uIERlZmluaXRpb24gcGFyYW1ldGVycyBhbGxvdyB5b3UgdG8gZGVmaW5lIHRoZSBkaW1lbnNpb24gdmFsdWVzIHRvIHVzZSB0byBmaWx0ZXIgdGhlIGlucHV0IG11bHRpZGltZW5zaW9uYWwgZGF0YSBmb3IgYW5hbHlzaXMgd2hlbiB0aGU8c3Ryb25nPkRpbWVuc2lvbiBEZWZpbml0aW9uPC9zdHJvbmc+cGFyYW1ldGVyIGlzIHNldCB0bzxzdHJvbmc+QnkgSXRlcmF0aW9uPC9zdHJvbmc+LjwvcD48dWw+PGxpPjxzdHJvbmc+RGltZW5zaW9uPC9zdHJvbmc+LS1UaGUgZGltZW5zaW9uIHRvIHVzZSBmb3IgZmlsdGVyaW5nLjwvbGk+PGxpPjxzdHJvbmc+U3RhcnQgb2YgZmlyc3QgaXRlcmF0aW9uPC9zdHJvbmc+LS1UaGUgYmVnaW5uaW5nIG9mIHRoZSBmaXJzdCBpbnRlcnZhbC4gVGhpcyBpbnRlcnZhbCBpcyB1c2VkIHRvIGl0ZXJhdGUgdGhyb3VnaCB0aGUgZGF0YXNldC48L2xpPjxsaT48c3Ryb25nPkVuZCBvZiBmaXJzdCBpdGVyYXRpb248L3N0cm9uZz4tLVRoZSBlbmQgb2YgdGhlIGZpcnN0IGludGVydmFsLiBUaGlzIGludGVydmFsIGlzIHVzZWQgdG8gaXRlcmF0ZSB0aHJvdWdoIHRoZSBkYXRhc2V0LjwvbGk+PGxpPjxzdHJvbmc+U3RlcDwvc3Ryb25nPi0tVGhlIGZyZXF1ZW5jeSB3aXRoIHdoaWNoIHRoZSBkYXRhIHdpbGwgYmUgc2xpY2VkLjwvbGk+PGxpPjxzdHJvbmc+VW5pdDwvc3Ryb25nPi0tVGhlIGl0ZXJhdGlvbiB1bml0LjwvbGk+PC91bD5cIixcblx0XCJAQEFnZ3JlZ2F0ZS1NdWx0aWRpbWVuc2lvbmFsX2tleXdvcmRpbnRlcnZhbF90YWcwQEBcIjogXCI8cD5TcGVjaWZpZXMgdGhlIGtleXdvcmQgaW50ZXJ2YWwgdGhhdCB3aWxsIGJlIHVzZWQgd2hlbiBhZ2dyZWdhdGluZyBhbG9uZyB0aGUgZGltZW5zaW9uLjwvcD48cD5UaGlzIHBhcmFtZXRlciBpcyByZXF1aXJlZCB3aGVuIHRoZTxzdHJvbmc+VHlwZTwvc3Ryb25nPnBhcmFtZXRlciBpcyBzZXQgdG88c3Ryb25nPkludGVydmFsIEtleXdvcmQ8L3N0cm9uZz4uPC9wPjx1bD48bGk+PHN0cm9uZz5Ib3VybHk8L3N0cm9uZz4tLVRoZSBkYXRhIHZhbHVlcyBhcmUgYWdncmVnYXRlZCBpbnRvIGhvdXJseSB0aW1lIHN0ZXBzLCBhbmQgdGhlIHJlc3VsdCBpbmNsdWRlcyBldmVyeSBob3VyIGluIHRoZSB0aW1lIHNlcmllcy4gVGhpcyBpcyB0aGUgZGVmYXVsdC48L2xpPjxsaT48c3Ryb25nPkRhaWx5PC9zdHJvbmc+LS1UaGUgZGF0YSB2YWx1ZXMgYXJlIGFnZ3JlZ2F0ZWQgaW50byBkYWlseSB0aW1lIHN0ZXBzLCBhbmQgdGhlIHJlc3VsdCBpbmNsdWRlcyBldmVyeSBkYXkgaW4gdGhlIHRpbWUgc2VyaWVzLjwvbGk+PGxpPjxzdHJvbmc+V2Vla2x5PC9zdHJvbmc+LS1UaGUgZGF0YSB2YWx1ZXMgYXJlIGFnZ3JlZ2F0ZWQgaW50byB3ZWVrbHkgdGltZSBzdGVwcywgYW5kIHRoZSByZXN1bHQgaW5jbHVkZXMgZXZlcnkgd2VlayBpbiB0aGUgdGltZSBzZXJpZXMuPC9saT48bGk+PHN0cm9uZz5EZWthZGx5PC9zdHJvbmc+LS1UaGUgZGF0YSB2YWx1ZXMgYXJlIGFnZ3JlZ2F0ZWQgaW50byAzIHBlcmlvZHMgb2YgMTAgZGF5cyBlYWNoLiBUaGUgbGFzdCBwZXJpb2QgY2FuIGNvbnRhaW4gbW9yZSBvciBmZXdlciB0aGFuIDEwIGRheXMuIFRoZSBvdXRwdXQgaW5jbHVkZXMgMyBzbGljZXMgZm9yIGVhY2ggbW9udGguPC9saT48bGk+PHN0cm9uZz5QZW50YWRseTwvc3Ryb25nPi0tVGhlIGRhdGEgdmFsdWVzIGFyZSBhZ2dyZWdhdGVkIGludG8gNiBwZXJpb2RzIG9mIDUgZGF5cyBlYWNoLiBUaGUgbGFzdCBwZXJpb2QgY2FuIGNvbnRhaW4gbW9yZSBvciBmZXdlciB0aGFuIDUgZGF5cy4gVGhlIG91dHB1dCBpbmNsdWRlcyA2IHNsaWNlcyBmb3IgZWFjaCBtb250aC48L2xpPjxsaT48c3Ryb25nPk1vbnRobHk8L3N0cm9uZz4tLVRoZSBkYXRhIHZhbHVlcyBhcmUgYWdncmVnYXRlZCBpbnRvIG1vbnRobHkgdGltZSBzdGVwcywgYW5kIHRoZSByZXN1bHQgaW5jbHVkZXMgZXZlcnkgbW9udGggaW4gdGhlIHRpbWUgc2VyaWVzLjwvbGk+PGxpPjxzdHJvbmc+UXVhcnRlcmx5PC9zdHJvbmc+LS1UaGUgZGF0YSB2YWx1ZXMgYXJlIGFnZ3JlZ2F0ZWQgaW50byBxdWFydGVybHkgdGltZSBzdGVwcywgYW5kIHRoZSByZXN1bHQgaW5jbHVkZXMgZXZlcnkgcXVhcnRlciBpbiB0aGUgdGltZSBzZXJpZXMuPC9saT48bGk+PHN0cm9uZz5ZZWFybHk8L3N0cm9uZz4tLVRoZSBkYXRhIHZhbHVlcyBhcmUgYWdncmVnYXRlZCBpbnRvIHllYXJseSB0aW1lIHN0ZXBzLCBhbmQgdGhlIHJlc3VsdCBpbmNsdWRlcyBldmVyeSB5ZWFyIGluIHRoZSB0aW1lIHNlcmllcy48L2xpPjxsaT48c3Ryb25nPlJlY3VycmluZyBkYWlseTwvc3Ryb25nPi0tVGhlIGRhdGEgdmFsdWVzIGFyZSBhZ2dyZWdhdGVkIGludG8gZGFpbHkgdGltZSBzdGVwcywgYW5kIHRoZSByZXN1bHQgaW5jbHVkZXMgb25lIGFnZ3JlZ2F0ZWQgdmFsdWUgcGVyIEp1bGlhbiBkYXkuIFRoZSBvdXRwdXQgaW5jbHVkZXMsIGF0IG1vc3QsIDM2NiBkYWlseSB0aW1lIHNsaWNlcy48L2xpPjxsaT48c3Ryb25nPlJlY3VycmluZyB3ZWVrbHk8L3N0cm9uZz4tLVRoZSBkYXRhIHZhbHVlcyBhcmUgYWdncmVnYXRlZCBpbnRvIHdlZWtseSB0aW1lIHN0ZXBzLCBhbmQgdGhlIHJlc3VsdCBpbmNsdWRlcyBvbmUgYWdncmVnYXRlZCB2YWx1ZSBwZXIgd2Vlay4gVGhlIG91dHB1dCBpbmNsdWRlcywgYXQgbW9zdCwgNTMgd2Vla2x5IHRpbWUgc2xpY2VzLjwvbGk+PGxpPjxzdHJvbmc+UmVjdXJyaW5nIG1vbnRobHk8L3N0cm9uZz4tLVRoZSBkYXRhIHZhbHVlcyBhcmUgYWdncmVnYXRlZCBpbnRvIG1vbnRobHkgdGltZSBzdGVwcywgYW5kIHRoZSByZXN1bHQgaW5jbHVkZXMgb25lIGFnZ3JlZ2F0ZWQgdmFsdWUgcGVyIG1vbnRoLiBUaGUgb3V0cHV0IGluY2x1ZGVzLCBhdCBtb3N0LCAxMiBtb250aGx5IHRpbWUgc2xpY2VzLjwvbGk+PGxpPjxzdHJvbmc+UmVjdXJyaW5nIHF1YXJ0ZXJseTwvc3Ryb25nPi0tVGhlIGRhdGEgdmFsdWVzIGFyZSBhZ2dyZWdhdGVkIGludG8gcXVhcnRlcmx5IHRpbWUgc3RlcHMsIGFuZCB0aGUgcmVzdWx0cyBpbmNsdWRlIG9uZSBhZ2dyZWdhdGVkIHZhbHVlIHBlciBxdWFydGVyLiBUaGUgb3V0cHV0IGluY2x1ZGVzLCBhdCBtb3N0LCA0IHF1YXJ0ZXJseSB0aW1lIHNsaWNlcy48L2xpPjwvdWw+XCIsXG5cdFwiQEBBZ2dyZWdhdGUtTXVsdGlkaW1lbnNpb25hbF9vcGVyYXRpb25fdGFnMEBAXCI6IFwiPHA+U3BlY2lmaWVzIHRoZSBtYXRoZW1hdGljYWwgbWV0aG9kIHRoYXQgd2lsbCBiZSB1c2VkIHRvIGNvbWJpbmUgdGhlIGFnZ3JlZ2F0ZWQgc2xpY2VzIGluIGFuIGludGVydmFsLjwvcD48dWw+PGxpPjxzdHJvbmc+TWFqb3JpdHk8L3N0cm9uZz4tLVRoZSBwaXhlbCB2YWx1ZSB0aGF0IG9jY3VycmVkIG1vc3QgZnJlcXVlbnRseSB3aWxsIGJlIGNhbGN1bGF0ZWQgYWNyb3NzIGFsbCBzbGljZXMgaW4gdGhlIGludGVydmFsLjwvbGk+PGxpPjxzdHJvbmc+TWF4aW11bTwvc3Ryb25nPi0tVGhlIG1heGltdW0gdmFsdWUgb2YgYSBwaXhlbCB3aWxsIGJlIGNhbGN1bGF0ZWQgYWNyb3NzIGFsbCBzbGljZXMgaW4gdGhlIGludGVydmFsLjwvbGk+PGxpPjxzdHJvbmc+TWVhbjwvc3Ryb25nPi0tVGhlIG1lYW4gb2YgYSBwaXhlbCdzIHZhbHVlcyB3aWxsIGJlIGNhbGN1bGF0ZWQgYWNyb3NzIGFsbCBzbGljZXMgaW4gdGhlIGludGVydmFsLiBUaGlzIGlzIHRoZSBkZWZhdWx0LjwvbGk+PGxpPjxzdHJvbmc+TWVkaWFuPC9zdHJvbmc+LS1UaGUgbWVkaWFuIHZhbHVlIG9mIGEgcGl4ZWwgd2lsbCBiZSBjYWxjdWxhdGVkIGFjcm9zcyBhbGwgc2xpY2VzIGluIHRoZSBpbnRlcnZhbC48L2xpPjxsaT48c3Ryb25nPk1pbmltdW08L3N0cm9uZz4tLVRoZSBtaW5pbXVtIHZhbHVlIG9mIGEgcGl4ZWwgd2lsbCBiZSBjYWxjdWxhdGVkIGFjcm9zcyBhbGwgc2xpY2VzIGluIHRoZSBpbnRlcnZhbC48L2xpPjxsaT48c3Ryb25nPk1pbm9yaXR5PC9zdHJvbmc+LS1UaGUgcGl4ZWwgdmFsdWUgdGhhdCBvY2N1cnJlZCBsZWFzdCBmcmVxdWVudGx5IHdpbGwgYmUgY2FsY3VsYXRlZCBhY3Jvc3MgYWxsIHNsaWNlcyBpbiB0aGUgaW50ZXJ2YWwuPC9saT48bGk+PHN0cm9uZz5SYW5nZTwvc3Ryb25nPi0tVGhlIHJhbmdlIG9mIHZhbHVlcyBmb3IgYSBwaXhlbCB3aWxsIGJlIGNhbGN1bGF0ZWQgYWNyb3NzIGFsbCBzbGljZXMgaW4gdGhlIGludGVydmFsLjwvbGk+PGxpPjxzdHJvbmc+U3RhbmRhcmQgRGV2aWF0aW9uPC9zdHJvbmc+LS1UaGUgc3RhbmRhcmQgZGV2aWF0aW9uIG9mIGEgcGl4ZWwncyB2YWx1ZXMgd2lsbCBiZSBjYWxjdWxhdGVkIGFjcm9zcyBhbGwgc2xpY2VzIGluIHRoZSBpbnRlcnZhbC48L2xpPjxsaT48c3Ryb25nPlN1bTwvc3Ryb25nPi0tVGhlIHN1bSBvZiBhIHBpeGVsJ3MgdmFsdWVzIHdpbGwgYmUgY2FsY3VsYXRlZCBhY3Jvc3MgYWxsIHNsaWNlcyBpbiB0aGUgaW50ZXJ2YWwuPC9saT48bGk+PHN0cm9uZz5WYXJpZXR5PC9zdHJvbmc+LS1UaGUgbnVtYmVyIG9mIHVuaXF1ZSBwaXhlbCB2YWx1ZXMgd2lsbCBiZSBjYWxjdWxhdGVkIGFjcm9zcyBhbGwgc2xpY2VzIGluIHRoZSBpbnRlcnZhbC48L2xpPjwvdWw+PHA+QWxsIG9wdGlvbnMgYWxzbyBoYXZlIGFuIGVxdWl2YWxlbnQgd2l0aCBhbiBJZ25vcmUgTm9EYXRhIG9wdGlvbi4gVGhlc2Ugd2lsbCBwZXJmb3JtIHRoZSBtYXRoZW1hdGljYWwgb3BlcmF0aW9uIG9uIGFsbCB2YWxpZCBwaXhlbHMgYWxvbmcgdGhlIGRpbWVuc2lvbiBhbmQgaWdub3JlIGFueSBOb0RhdGEgcGl4ZWxzLjwvcD5cIixcblx0XCJAQEFnZ3JlZ2F0ZS1NdWx0aWRpbWVuc2lvbmFsX3Jhbmdlc190YWcwQEBcIjogXCI8cD5JbnRlcnZhbCByYW5nZXMgc3BlY2lmaWVkIGluIGEgdGFibGUgYXJlIHVzZWQgdG8gYWdncmVnYXRlIGdyb3VwcyBvZiB2YWx1ZXMuIFRoZSBtaW5pbXVtIGFuZCBtYXhpbXVtIHZhbHVlcyBzcGVjaWZ5IHRoZSByYW5nZSB0byBiZSBpbmNsdWRlZC48L3A+PHA+VGhpcyBwYXJhbWV0ZXIgaXMgcmVxdWlyZWQgd2hlbiB0aGU8c3Ryb25nPlR5cGU8L3N0cm9uZz5wYXJhbWV0ZXIgaXMgc2V0IHRvPHN0cm9uZz5JbnRlcnZhbCBSYW5nZXM8L3N0cm9uZz4uPC9wPlwiLFxuXHRcIkBAQWdncmVnYXRlLU11bHRpZGltZW5zaW9uYWxfcmFzdGVyX3RhZzBAQFwiOiBcIjxwPlRoZSBpbnB1dCBtdWx0aWRpbWVuc2lvbmFsIHJhc3Rlci48L3A+XCIsXG5cdFwiQEBBZ2dyZWdhdGUtTXVsdGlkaW1lbnNpb25hbF90eXBlX3RhZzBAQFwiOiBcIjxwPlNwZWNpZmllcyB0aGUgZGltZW5zaW9uIGludGVydmFsIGZvciB3aGljaCB0aGUgZGF0YSB3aWxsIGJlIGFnZ3JlZ2F0ZWQuPC9wPjx1bD48bGk+PHN0cm9uZz5BbGw8L3N0cm9uZz4tLVRoZSB2YXJpYWJsZSBkYXRhIHdpbGwgYmUgYWdncmVnYXRlZCBhY3Jvc3MgYWxsIHNsaWNlcy4gVGhpcyBpcyB0aGUgZGVmYXVsdC48L2xpPjxsaT48c3Ryb25nPkludGVydmFsIEtleXdvcmQ8L3N0cm9uZz4tLVRoZSB2YXJpYWJsZSBkYXRhIHdpbGwgYmUgYWdncmVnYXRlZCB1c2luZyBhIGNvbW1vbmx5IGtub3duIGludGVydmFsLjwvbGk+PGxpPjxzdHJvbmc+SW50ZXJ2YWwgVmFsdWU8L3N0cm9uZz4tLVRoZSB2YXJpYWJsZSBkYXRhIHdpbGwgYmUgYWdncmVnYXRlZCB1c2luZyBhIHVzZXItc3BlY2lmaWVkIGludGVydmFsIGFuZCB1bml0LjwvbGk+PGxpPjxzdHJvbmc+SW50ZXJ2YWwgUmFuZ2VzPC9zdHJvbmc+LS1UaGUgdmFyaWFibGUgZGF0YSB3aWxsIGJlIGFnZ3JlZ2F0ZWQgYmV0d2VlbiBzcGVjaWZpZWQgcGFpcnMgb2YgdmFsdWVzIG9yIGRhdGVzLjwvbGk+PC91bD5cIixcblx0XCJAQEFnZ3JlZ2F0ZS1NdWx0aWRpbWVuc2lvbmFsX3ZhbHVlaW50ZXJ2YWxfdGFnMEBAXCI6IFwiPHA+VGhlIHNpemUgb2YgdGhlIGludGVydmFsIHVzZWQgZm9yIHRoZSBhZ2dyZWdhdGlvbi48L3A+PHA+VGhpcyBwYXJhbWV0ZXIgaXMgcmVxdWlyZWQgd2hlbiB0aGU8c3Ryb25nPlR5cGU8L3N0cm9uZz5wYXJhbWV0ZXIgaXMgc2V0IHRvPHN0cm9uZz5JbnRlcnZhbCBWYWx1ZTwvc3Ryb25nPi48L3A+XCIsXG5cdFwiQEBBZ2dyZWdhdGUtTXVsdGlkaW1lbnNpb25hbF92YWx1ZXNfdGFnMEBAXCI6IFwiPHA+VGhlIGRpbWVuc2lvbiB2YWx1ZXMgdG8gdXNlIHRvIGZpbHRlciB0aGUgaW5wdXQgbXVsdGlkaW1lbnNpb25hbCBkYXRhIGZvciBhbmFseXNpcy4gVGhpcyBwYXJhbWV0ZXIgaXMgcmVxdWlyZWQgd2hlbiB0aGU8c3Ryb25nPkRpbWVuc2lvbiBEZWZpbml0aW9uPC9zdHJvbmc+cGFyYW1ldGVyIGlzIHNldCB0bzxzdHJvbmc+QnkgVmFsdWVzPC9zdHJvbmc+LjwvcD5cIixcblx0XCJAQEFnZ3JlZ2F0ZS1NdWx0aWRpbWVuc2lvbmFsX3ZhcmlhYmxlc190YWcwQEBcIjogXCI8cD5UaGUgdmFyaWFibGUgb3IgdmFyaWFibGVzIHRoYXQgd2lsbCBiZSBhZ2dyZWdhdGVkIGFsb25nIHRoZSBnaXZlbiBkaW1lbnNpb24uPC9wPlwiLFxuXHRcIkBAUHJlZGljdC1Vc2luZy1SZWdyZXNzaW9uX2lucHV0ZGVmaW5pdGlvbmZpbGVfdGFnMEBAXCI6IFwiPHA+VGhlIGlucHV0IEVzcmkgcmVncmVzc2lvbiBkZWZpbml0aW9uICg8c3Ryb25nPi5lY2Q8L3N0cm9uZz4pIGZpbGUgdGhhdCBjb250YWlucyB0aGUgc3RhdGlzdGljcyBhbmQgaW5mb3JtYXRpb24gZm9yIHRoZSBzcGVjaWZpYyBkYXRhc2V0LCByZWdyZXNzaW9uIG1vZGVsLCBhbmQgY2hvc2VuIGF0dHJpYnV0ZXMuPC9wPlwiLFxuXHRcIkBAUHJlZGljdC1Vc2luZy1SZWdyZXNzaW9uX3Jhc3RlcnNfdGFnMEBAXCI6IFwiPHA+VGhlIHJhc3RlciBkYXRhc2V0IG9yIGRhdGFzZXRzIHJlcHJlc2VudGluZyB0aGUgcHJlZGljdG9yIHZhcmlhYmxlcy4gSXQgY2FuIGJlIGEgc2luZ2xlLWJhbmQgcmFzdGVyLCBtdWx0aXBsZS1iYW5kIHJhc3RlciwgbXVsdGlkaW1lbnNpb25hbCByYXN0ZXIsIG1vc2FpYyBkYXRhc2V0LCBvciBhIHJhc3RlciBjb2xsZWN0aW9uLjwvcD5cIixcblx0XCJAQENlbGwtU3RhdGlzdGljc19vcGVyYXRpb25fdGFnMEBAXCI6IFwiPHA+VGhlIHR5cGUgb2Ygc3RhdGlzdGljYWwgY2FsY3VsYXRpb24gdGhhdCB5b3Ugd2FudCB0byBwZXJmb3JtLjwvcD48cD5UaGUgYXZhaWxhYmxlIHN0YXRpc3RpY3MgYXJlPHN0cm9uZz5NYWpvcml0eTwvc3Ryb25nPiw8c3Ryb25nPk1heGltdW08L3N0cm9uZz4sPHN0cm9uZz5NZWFuPC9zdHJvbmc+LDxzdHJvbmc+TWVkaWFuPC9zdHJvbmc+LDxzdHJvbmc+TWluaW11bTwvc3Ryb25nPiw8c3Ryb25nPk1pbm9yaXR5PC9zdHJvbmc+LDxzdHJvbmc+UGVyY2VudGlsZTwvc3Ryb25nPiw8c3Ryb25nPlJhbmdlPC9zdHJvbmc+LDxzdHJvbmc+U3RhbmRhcmQgRGV2aWF0aW9uPC9zdHJvbmc+LDxzdHJvbmc+U3VtPC9zdHJvbmc+LCBhbmQ8c3Ryb25nPlZhcmlldHk8L3N0cm9uZz4uPC9wPjxwPlRoZSBkZWZhdWx0IGlzPHN0cm9uZz5NZWFuPC9zdHJvbmc+LjwvcD5cIixcblx0XCJAQENvbG9ybWFwLVRvLVJHQl9yYW5kb21seWFzc2lnbmNvbG9ydG91bm1hcHBlZHBpeGVsc190YWcwQEBcIjogXCI8cD5Db2xvcnMgYXJlIHJhbmRvbWx5IGFzc2lnbmVkIHRvIHBpeGVscyB0aGF0IGFyZSBub3QgaW5jbHVkZWQgaW4gdGhlIGNvbG9yIG1hcC48L3A+PHVsPjxsaT5VbmNoZWNrZWQtLVVubWFwcGVkIHBpeGVscyBhcmUgbm90IGFzc2lnbmVkIGEgY29sb3IuIFRoaXMgaXMgdGhlIGRlZmF1bHQuPC9saT48bGk+Q2hlY2tlZC0tVW5tYXBwZWQgcGl4ZWxzIGFyZSBhc3NpZ25lZCBhIGNvbG9yLjwvbGk+PC91bD5cIixcblx0XCJAQFBhbnNoYXJwZW5fc2Vuc29yX3RhZzBAQFwiOiBcIjxwPldoZW4gdGhlIEdyYW0tU2NobWlkdCBhbGdvcml0aG0gaXMgY2hvc2VuLCB5b3UgY2FuIGFsc28gc3BlY2lmeSB0aGUgc2Vuc29yIHRoYXQgY29sbGVjdGVkIHRoZSBtdWx0aWJhbmQgcmFzdGVyIGlucHV0LiBDaG9vc2luZyB0aGUgc2Vuc29yIHR5cGUgd2lsbCBzZXQgYXBwcm9wcmlhdGUgYmFuZCB3ZWlnaHRzLjwvcD5cIixcblx0XCJAQERpbWVuc2lvbmFsLU1vdmluZy1TdGF0aXN0aWNzX2JhY2t3YXJkd2luZG93X3RhZzBAQFwiOiBcIjxwPlRoZSB2YWx1ZSBvZiBob3cgbWFueSBzbGljZXMgYmVmb3JlIG9yIGFib3ZlIHRvIGJlIGluY2x1ZGVkIGluIHRoZSBkZWZpbmVkIHdpbmRvdy4gVGhlIHZhbHVlIG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyIGZyb20gMSB0byAxMDAuIFRoZSBkZWZhdWx0IHZhbHVlIGlzIDEuPC9wPjxwPlRoZSB1bml0IG9mIHRoaXMgcGFyYW1ldGVyIGlzIHNsaWNlLjwvcD5cIixcblx0XCJAQERpbWVuc2lvbmFsLU1vdmluZy1TdGF0aXN0aWNzX2NpcmN1bGFyd3JhcHZhbHVlX3RhZzBAQFwiOiBcIjxwPlRoZSB2YWx1ZSB0aGF0IHdpbGwgYmUgdXNlZCB0byByb3VuZCBhIGxpbmVhciB2YWx1ZSB0byB0aGUgcmFuZ2Ugb2YgYSBnaXZlbiBjaXJjdWxhciBtZWFuLjwvcD48cD5JdHMgdmFsdWUgbXVzdCBiZSBwb3NpdGl2ZS4gVGhlIGRlZmF1bHQgdmFsdWUgaXMgMzYwIGRlZ3JlZXMuPC9wPlwiLFxuXHRcIkBARGltZW5zaW9uYWwtTW92aW5nLVN0YXRpc3RpY3NfZGltZW5zaW9uX3RhZzBAQFwiOiBcIjxwPlRoZSBuYW1lIG9mIHRoZSBkaW1lbnNpb24gYWxvbmcgd2hpY2ggdGhlIHdpbmRvdyB3aWxsIG1vdmUuPC9wPjxwPlRoZSBkZWZhdWx0IHZhbHVlIGlzIHRoZSBmaXJzdCBkaW1lbnNpb24gb3RoZXIgdGhhbiB4LHkgZm91bmQgaW4gdGhlIGlucHV0IG11bHRpZGltZW5zaW9uYWwgcmFzdGVyLjwvcD5cIixcblx0XCJAQERpbWVuc2lvbmFsLU1vdmluZy1TdGF0aXN0aWNzX2ZvcndhcmR3aW5kb3dfdGFnMEBAXCI6IFwiPHA+VGhlIHZhbHVlIG9mIGhvdyBtYW55IHNsaWNlcyBhZnRlciBvciBiZWxvdyB0byBiZSBpbmNsdWRlZCBpbiB0aGUgZGVmaW5lZCB3aW5kb3cuIFRoZSB2YWx1ZSBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlciBmcm9tIDEgdG8gMTAwLiBUaGUgZGVmYXVsdCB2YWx1ZSBpcyAxLjwvcD48cD5UaGUgdW5pdCBvZiB0aGlzIHBhcmFtZXRlciBpcyBzbGljZS48L3A+XCIsXG5cdFwiQEBEaW1lbnNpb25hbC1Nb3ZpbmctU3RhdGlzdGljc19pbnB1dHJhc3Rlcl90YWcwQEBcIjogXCI8cD5UaGUgaW5wdXQgcmFzdGVyIGNhbiBvbmx5IGJlIGEgbXVsdGlkaW1lbnNpb25hbCByYXN0ZXIgaW4gQ2xvdWQgUmFzdGVyIEZvcm1hdCAoPHN0cm9uZz4uY3JmPC9zdHJvbmc+ZmlsZSkuPC9wPlwiLFxuXHRcIkBARGltZW5zaW9uYWwtTW92aW5nLVN0YXRpc3RpY3Nfbm9kYXRhaGFuZGxpbmdfdGFnMEBAXCI6IFwiPHA+U3BlY2lmaWVzIGhvdyBOb0RhdGEgdmFsdWVzIHdpbGwgYmUgaGFuZGxlZCBieSB0aGUgc3RhdGlzdGljIGNhbGN1bGF0aW9uLjwvcD48dWw+PGxpPjxzdHJvbmc+RGF0YTwvc3Ryb25nPi0tTm9EYXRhIHZhbHVlcyBpbiB0aGUgdmFsdWUgaW5wdXQgd2lsbCBiZSBpZ25vcmVkIGluIHRoZSByZXN1bHRzIG9mIHRoZSBkZWZpbmVkIHdpbmRvdyB0aGF0IHRoZXkgZmFsbCB3aXRoaW4uIFRoaXMgaXMgdGhlIGRlZmF1bHQuPC9saT48bGk+PHN0cm9uZz5Ob0RhdGE8L3N0cm9uZz4tLU91dHB1dCB2YWx1ZXMgd2lsbCBiZSBOb0RhdGEgaWYgYW55IE5vRGF0YSB2YWx1ZXMgZXhpc3QgaW4gdGhlIGlucHV0IHdpdGhpbiB0aGUgZGVmaW5lZCB3aW5kb3cuPC9saT48bGk+PHN0cm9uZz5GaWxsIE5vRGF0YTwvc3Ryb25nPi0tTm9EYXRhIGNlbGwgdmFsdWVzIHdpbGwgYmUgcmVwbGFjZWQgdXNpbmcgdGhlIHNlbGVjdGVkIHN0YXRpc3RpYyB3aXRoaW4gdGhlIGRlZmluZWQgd2luZG93LjwvbGk+PC91bD5cIixcblx0XCJAQERpbWVuc2lvbmFsLU1vdmluZy1TdGF0aXN0aWNzX3BlcmNlbnRpbGVpbnRlcnBvbGF0aW9udHlwZV90YWcwQEBcIjogXCI8cD5TcGVjaWZpZXMgdGhlIG1ldGhvZCBvZiBpbnRlcnBvbGF0aW9uIHRoYXQgd2lsbCBiZSB1c2VkIHdoZW4gdGhlIHBlcmNlbnRpbGUgdmFsdWUgZmFsbHMgYmV0d2VlbiB0d28gY2VsbCB2YWx1ZXMuPC9wPjx1bD48bGk+PHN0cm9uZz5BdXRvLWRldGVjdDwvc3Ryb25nPi0tSWYgdGhlIGlucHV0IHJhc3RlciBpcyBvZiBpbnRlZ2VyIHBpeGVsIHR5cGUsIHRoZTxzdHJvbmc+TmVhcmVzdDwvc3Ryb25nPm1ldGhvZCB3aWxsIGJlIHVzZWQuIElmIHRoZSBpbnB1dCByYXN0ZXIgaXMgb2YgZmxvYXQgcGl4ZWwgdHlwZSwgdGhlPHN0cm9uZz5MaW5lYXI8L3N0cm9uZz5tZXRob2Qgd2lsbCBiZSB1c2VkLiBUaGlzIGlzIHRoZSBkZWZhdWx0LjwvbGk+PGxpPjxzdHJvbmc+TmVhcmVzdDwvc3Ryb25nPi0tVGhlIG5lYXJlc3QgYXZhaWxhYmxlIHZhbHVlIHRvIHRoZSBwZXJjZW50aWxlIHdpbGwgYmUgdXNlZC4gSW4gdGhpcyBjYXNlLCB0aGUgb3V0cHV0IHBpeGVsIHR5cGUgd2lsbCBiZSB0aGUgc2FtZSBhcyB0aGF0IG9mIHRoZSBpbnB1dCB2YWx1ZSByYXN0ZXIuPC9saT48bGk+PHN0cm9uZz5MaW5lYXI8L3N0cm9uZz4tLVRoZSB3ZWlnaHRlZCBhdmVyYWdlIG9mIHRoZSB0d28gc3Vycm91bmRpbmcgdmFsdWVzIGZyb20gdGhlIHBlcmNlbnRpbGUgd2lsbCBiZSB1c2VkLiBJbiB0aGlzIGNhc2UsIHRoZSBvdXRwdXQgcGl4ZWwgdHlwZSB3aWxsIGJlIGZsb2F0aW5nIHBvaW50LjwvbGk+PC91bD5cIixcblx0XCJAQERpbWVuc2lvbmFsLU1vdmluZy1TdGF0aXN0aWNzX3BlcmNlbnRpbGV2YWx1ZV90YWcwQEBcIjogXCI8cD5UaGUgcGVyY2VudGlsZSB0aGF0IHdpbGwgYmUgY2FsY3VsYXRlZCB3aGVuPHN0cm9uZz5QZXJjZW50aWxlPC9zdHJvbmc+aXMgc2VsZWN0ZWQgYXMgdGhlIHN0YXRpc3RpY3MgdHlwZS4gVGhlIGRlZmF1bHQgaXMgOTAsIGZvciB0aGUgOTB0aCBwZXJjZW50aWxlLjwvcD48cD5UaGUgdmFsdWVzIGNhbiByYW5nZSBmcm9tIDAgdGhyb3VnaCAxMDAuIFRoZSAwdGggcGVyY2VudGlsZSBpcyBlc3NlbnRpYWxseSBlcXVpdmFsZW50IHRvIHRoZSBtaW5pbXVtIHN0YXRpc3RpYywgYW5kIHRoZSAxMDB0aCBwZXJjZW50aWxlIGlzIGVxdWl2YWxlbnQgdG8gdGhlIG1heGltdW0gc3RhdGlzdGljLCB3aXRoIHRoZSBleGNlcHRpb24gdGhhdCB0aGUgcmVzdWx0IHdpbGwgYmUgZmxvYXRpbmcgcG9pbnQuIEEgdmFsdWUgb2YgNTAgd2lsbCBwcm9kdWNlIHRoZSBzYW1lIHJlc3VsdCBhcyB0aGUgbWVkaWFuIHN0YXRpc3RpYy48L3A+XCIsXG5cdFwiQEBEaW1lbnNpb25hbC1Nb3ZpbmctU3RhdGlzdGljc19zdGF0aXN0aWNzdHlwZV90YWcwQEBcIjogXCI8cD5TcGVjaWZpZXMgdGhlIHN0YXRpc3RpYyB0eXBlIHRvIGJlIGNhbGN1bGF0ZWQuPC9wPjxwPjwvcD48dWw+PGxpPjxzdHJvbmc+TWVhbjwvc3Ryb25nPi0tVGhlIG1lYW4gKGF2ZXJhZ2UgdmFsdWUpIG9mIHRoZSBjZWxscyBpbiB0aGUgZGVmaW5lZCB3aW5kb3cgd2lsbCBiZSBjYWxjdWxhdGVkLiBUaGlzIGlzIHRoZSBkZWZhdWx0LjwvbGk+PGxpPjxzdHJvbmc+Q2lyY3VsYXIgTWVhbjwvc3Ryb25nPi0tVGhlIGNpcmN1bGFyIG1lYW4gb2YgdGhlIGNlbGxzIGluIHRoZSBkZWZpbmVkIHdpbmRvdyB3aWxsIGJlIGNhbGN1bGF0ZWQuIFdoZW4gdGhpcyBzdGF0aXN0aWNzIHR5cGUgaXMgc2VsZWN0ZWQsIHRoZTxzdHJvbmc+Q2lyY3VsYXIgV3JhcCBWYWx1ZTwvc3Ryb25nPnBhcmFtZXRlciBiZWNvbWVzIGF2YWlsYWJsZS48L2xpPjxsaT48c3Ryb25nPk1ham9yaXR5PC9zdHJvbmc+LS1UaGUgbWFqb3JpdHkgKHZhbHVlIHRoYXQgb2NjdXJzIG1vc3Qgb2Z0ZW4pIG9mIHRoZSBjZWxscyBpbiB0aGUgZGVmaW5lZCB3aW5kb3cgd2lsbCBiZSBpZGVudGlmaWVkLjwvbGk+PGxpPjxzdHJvbmc+TWF4aW11bTwvc3Ryb25nPi0tVGhlIG1heGltdW0gKGxhcmdlc3QgdmFsdWUpIG9mIHRoZSBjZWxscyBpbiB0aGUgZGVmaW5lZCB3aW5kb3cgd2lsbCBiZSBpZGVudGlmaWVkLjwvbGk+PGxpPjxzdHJvbmc+TWVkaWFuPC9zdHJvbmc+LS1UaGUgbWVkaWFuIG9mIHRoZSBjZWxscyBpbiB0aGUgbmVpZ2hib3Job29kIHdpbGwgYmUgaWRlbnRpZmllZC48L2xpPjxsaT48c3Ryb25nPk1pbmltdW08L3N0cm9uZz4tLVRoZSBtaW5pbXVtIChzbWFsbGVzdCB2YWx1ZSkgb2YgdGhlIGNlbGxzIGluIHRoZSBuZWlnaGJvcmhvb2Qgd2lsbCBiZSBpZGVudGlmaWVkLjwvbGk+PGxpPjxzdHJvbmc+UGVyY2VudGlsZTwvc3Ryb25nPi0tQSBwZXJjZW50aWxlIG9mIHRoZSBjZWxscyBpbiB0aGUgbmVpZ2hib3Job29kIHdpbGwgYmUgY2FsY3VsYXRlZC4gV2hlbiB0aGlzIHN0YXRpc3RpY3MgdHlwZSBpcyBzZWxlY3RlZCwgdGhlPHN0cm9uZz5QZXJjZW50aWxlIFZhbHVlPC9zdHJvbmc+YW5kPHN0cm9uZz5QZXJjZW50aWxlIEludGVycG9sYXRpb24gVHlwZTwvc3Ryb25nPnBhcmFtZXRlcnMgYmVjb21lIGF2YWlsYWJsZS4gVXNlIHRoZXNlIG5ldyBwYXJhbWV0ZXJzIHRvIGRlc2lnbmF0ZSB0aGUgcGVyY2VudGlsZSB0byBjYWxjdWxhdGUgYW5kIGNob29zZSB0aGUgaW50ZXJwb2xhdGlvbiB0eXBlIHRvIHVzZSwgcmVzcGVjdGl2ZWx5LjwvbGk+PC91bD5cIixcblx0XCJAQEludGVycG9sYXRlLVJhc3Rlci1CeS1EaW1lbnNpb25fZGltZW5zaW9uX3RhZzBAQFwiOiBcIjxwPlRoZSBkaW1lbnNpb24gdG8gdXNlIGZvciBpbnRlcnBvbGF0aW9uLjwvcD48cD5UaGlzIHBhcmFtZXRlciBpcyByZXF1aXJlZCB3aGVuIHRoZTxzdHJvbmc+RGltZW5zaW9uIERlZmluaXRpb248L3N0cm9uZz5wYXJhbWV0ZXIgaXMgc2V0IHRvPHN0cm9uZz5CeSBJbnRlcnZhbDwvc3Ryb25nPi48L3A+XCIsXG5cdFwiQEBJbnRlcnBvbGF0ZS1SYXN0ZXItQnktRGltZW5zaW9uX2RpbWVuc2lvbmRlZmluaXRpb25fdGFnMEBAXCI6IFwiPHA+U3BlY2lmaWVzIHRoZSBtZXRob2QgdGhhdCB3aWxsIGJlIHVzZWQgdG8gZmlsdGVyIHRoZSBpbnB1dCBtdWx0aWRpbWVuc2lvbmFsIGRhdGEgYmVmb3JlIHBlcmZvcm1pbmcgdGhlIGludGVycG9sYXRpb24uPC9wPjx1bD48bGk+PHN0cm9uZz5CeSBWYWx1ZXM8L3N0cm9uZz4tLVRoZSBkaW1lbnNpb24gd2lsbCBiZSBzbGljZWQgdXNpbmcgYSBkaW1lbnNpb24gdmFsdWUgb3IgbGlzdCBvZiB2YWx1ZXMuPC9saT48bGk+PHN0cm9uZz5CeSBJbnRlcnZhbDwvc3Ryb25nPi0tVGhlIGRpbWVuc2lvbiB3aWxsIGJlIHNsaWNlZCB1c2luZyBhIHJhbmdlIG9yIGEgbGlzdCBvZiByYW5nZXMuPC9saT48bGk+PHN0cm9uZz5CeSBUYXJnZXQgUmFzdGVyPC9zdHJvbmc+LS1UaGUgZGltZW5zaW9uIHdpbGwgYmUgc2xpY2VkIHVzaW5nIGEgc3BlY2lmaWMgdGFyZ2V0IG11bHRpZGltZW5zaW9uYWwgcmFzdGVyLjwvbGk+PC91bD5cIixcblx0XCJAQEludGVycG9sYXRlLVJhc3Rlci1CeS1EaW1lbnNpb25fZW5kb2ZpbnRlcnZhbF90YWcwQEBcIjogXCI8cD5UaGUgZW5kIG9mIHRoZSBpbnRlcnZhbCwgd2hpY2ggaXMgdXNlZCB0byBpdGVyYXRlIHRocm91Z2ggdGhlIGRhdGFzZXQuPC9wPjxwPlRoaXMgcGFyYW1ldGVyIGlzIHJlcXVpcmVkIHdoZW4gdGhlPHN0cm9uZz5EaW1lbnNpb24gRGVmaW5pdGlvbjwvc3Ryb25nPnBhcmFtZXRlciBpcyBzZXQgdG88c3Ryb25nPkJ5IEludGVydmFsPC9zdHJvbmc+LjwvcD5cIixcblx0XCJAQEludGVycG9sYXRlLVJhc3Rlci1CeS1EaW1lbnNpb25faWdub3Jlbm9kYXRhX3RhZzBAQFwiOiBcIjxwPlNwZWNpZmllcyB3aGV0aGVyIE5vRGF0YSB2YWx1ZXMgd2lsbCBiZSBpZ25vcmVkIGluIHRoZSBhbmFseXNpcy48L3A+PHVsPjxsaT5VbmNoZWNrZWQtLVRoZSBhbmFseXNpcyB3aWxsIHJlc3VsdCBpbiBOb0RhdGEgaWYgdGhlcmUgYXJlIE5vRGF0YSB2YWx1ZXMgaW4gYWRqYWNlbnQgc2xpY2VzLiBUaGlzIGlzIHRoZSBkZWZhdWx0LjwvbGk+PGxpPkNoZWNrZWQtLVRoZSBhbmFseXNpcyB3aWxsIG9ubHkgdXNlIHNsaWNlcyB0aGF0IGhhdmUgdmFsaWQgcGl4ZWxzIGFuZCB3aWxsIGlnbm9yZSBOb0RhdGEgc2xpY2VzLjwvbGk+PC91bD5cIixcblx0XCJAQEludGVycG9sYXRlLVJhc3Rlci1CeS1EaW1lbnNpb25faW50ZXJwb2xhdGlvbm1ldGhvZF90YWcwQEBcIjogXCI8cD5TcGVjaWZpZXMgdGhlIG1ldGhvZCB0aGF0IHdpbGwgYmUgdXNlZCB0byBpbnRlcnBvbGF0ZSB0aGUgcmFzdGVyLjwvcD48dWw+PGxpPjxzdHJvbmc+TGluZWFyPC9zdHJvbmc+LS1UaGUgb3V0cHV0IHdpbGwgYmUgaW50ZXJwb2xhdGVkIGxpbmVhcmx5IHVzaW5nIHRoZSBhZGphY2VudCBzbGljZXMuIFRoaXMgaXMgdGhlIGRlZmF1bHQuPC9saT48bGk+PHN0cm9uZz5OZWFyZXN0IE5laWdoYm9yPC9zdHJvbmc+LS1UaGUgb3V0cHV0IHdpbGwgdXNlIHRoZSBuZWFyZXN0IGFkamFjZW50IHNsaWNlLjwvbGk+PC91bD5cIixcblx0XCJAQEludGVycG9sYXRlLVJhc3Rlci1CeS1EaW1lbnNpb25fcmFzdGVyX3RhZzBAQFwiOiBcIjxwPlRoZSBpbnB1dCBtdWx0aWRpbWVuc2lvbmFsIHJhc3Rlci48L3A+XCIsXG5cdFwiQEBJbnRlcnBvbGF0ZS1SYXN0ZXItQnktRGltZW5zaW9uX3N0YXJ0b2ZpbnRlcnZhbF90YWcwQEBcIjogXCI8cD5UaGUgYmVnaW5uaW5nIG9mIHRoZSBpbnRlcnZhbCwgd2hpY2ggaXMgdXNlZCB0byBpdGVyYXRlIHRocm91Z2ggdGhlIGRhdGFzZXQuPC9wPjxwPlRoaXMgcGFyYW1ldGVyIGlzIHJlcXVpcmVkIHdoZW4gdGhlPHN0cm9uZz5EaW1lbnNpb24gRGVmaW5pdGlvbjwvc3Ryb25nPnBhcmFtZXRlciBpcyBzZXQgdG88c3Ryb25nPkJ5IEludGVydmFsPC9zdHJvbmc+LjwvcD5cIixcblx0XCJAQEludGVycG9sYXRlLVJhc3Rlci1CeS1EaW1lbnNpb25fc3RlcF90YWcwQEBcIjogXCI8cD5UaGUgZnJlcXVlbmN5IHdpdGggd2hpY2ggdGhlIGRhdGEgd2lsbCBiZSBpbnRlcnBvbGF0ZWQuPC9wPjxwPlRoaXMgcGFyYW1ldGVyIGlzIHJlcXVpcmVkIHdoZW4gdGhlPHN0cm9uZz5EaW1lbnNpb24gRGVmaW5pdGlvbjwvc3Ryb25nPnBhcmFtZXRlciBpcyBzZXQgdG88c3Ryb25nPkJ5IEludGVydmFsPC9zdHJvbmc+LjwvcD5cIixcblx0XCJAQEludGVycG9sYXRlLVJhc3Rlci1CeS1EaW1lbnNpb25fdGFyZ2V0cmFzdGVyX3RhZzBAQFwiOiBcIjxwPlRoZSB0YXJnZXQgcmFzdGVyIHNwZWNpZmllZCBieSB0aGUgZGltZW5zaW9uIGRlZmluaXRpb24uPC9wPjxwPlRoaXMgcGFyYW1ldGVyIGlzIHJlcXVpcmVkIHdoZW4gdGhlPHN0cm9uZz5EaW1lbnNpb24gRGVmaW5pdGlvbjwvc3Ryb25nPnBhcmFtZXRlciBpcyBzZXQgdG88c3Ryb25nPkJ5IFRhcmdldCBSYXN0ZXI8L3N0cm9uZz4uPC9wPlwiLFxuXHRcIkBASW50ZXJwb2xhdGUtUmFzdGVyLUJ5LURpbWVuc2lvbl91bml0X3RhZzBAQFwiOiBcIjxwPlRoZSBpbnRlcnZhbCB1bml0LjwvcD48cD5UaGlzIHBhcmFtZXRlciBpcyByZXF1aXJlZCB3aGVuIHRoZTxzdHJvbmc+RGltZW5zaW9uIERlZmluaXRpb248L3N0cm9uZz5wYXJhbWV0ZXIgaXMgc2V0IHRvPHN0cm9uZz5CeSBJbnRlcnZhbDwvc3Ryb25nPi48L3A+XCIsXG5cdFwiQEBJbnRlcnBvbGF0ZS1SYXN0ZXItQnktRGltZW5zaW9uX3ZhbHVlc190YWcwQEBcIjogXCI8cD5UaGUgZGltZW5zaW9uYWwgdmFsdWVzIHRvIHVzZSB0byBmaWx0ZXIgdGhlIGlucHV0IG11bHRpZGltZW5zaW9uYWwgZGF0YSBmb3IgYW5hbHlzaXMuPC9wPjxwPlRoaXMgcGFyYW1ldGVyIGlzIHJlcXVpcmVkIHdoZW4gdGhlPHN0cm9uZz5EaW1lbnNpb24gRGVmaW5pdGlvbjwvc3Ryb25nPnBhcmFtZXRlciBpcyBzZXQgdG88c3Ryb25nPkJ5IFZhbHVlczwvc3Ryb25nPi48L3A+XCIsXG5cdFwiQEBJbnRlcnBvbGF0ZS1SYXN0ZXItQnktRGltZW5zaW9uX3ZhcmlhYmxlc190YWcwQEBcIjogXCI8cD5UaGUgdmFyaWFibGUgb3IgdmFyaWFibGVzIHRoYXQgd2lsbCBiZSBpbnRlcnBvbGF0ZWQgYnkgdGhlIGRpbWVuc2lvbiBkZWZpbml0aW9uLjwvcD5cIixcblx0XCJAQFRlcnJhaW4tRmxhdHRlbl9jYWxpYnJhdGlvbnR5cGVfdGFnMEBAXCI6IFwiPHA+U3BlY2lmaWVzIHdoZXRoZXIgdGhlIG91dHB1dCB3aWxsIGJlIHRlcnJhaW4gZmxhdHRlbmVkIHVzaW5nPHN0cm9uZz5TaWdtYSBub3VnaHQ8L3N0cm9uZz5vcjxzdHJvbmc+R2FtbWEgbm91Z2h0PC9zdHJvbmc+LjwvcD48dWw+PGxpPjxzdHJvbmc+R2FtbWEgbm91Z2h0PC9zdHJvbmc+LS1UaGUgYmV0YSBub3VnaHQgYmFja3NjYXR0ZXIgd2lsbCBiZSBub3JtYWxpemVkIHVzaW5nIHRoZSB1bml0IGFyZWEgb2YgYSBwbGFuZSBsb2NhbGx5IHRhbmdlbnQgdG8gdGhlIERFTSwgY29tbW9ubHkga25vd24gYXMgdGhlIGxvY2FsIGluY2lkZW5jZSBhbmdsZS4gVGhpcyBpcyB0aGUgZGVmYXVsdC48L2xpPjxsaT48c3Ryb25nPlNpZ21hIG5vdWdodDwvc3Ryb25nPi0tVGhlIGJldGEgbm91Z2h0IGJhY2tzY2F0dGVyIHdpbGwgYmUgbm9ybWFsaXplZCB1c2luZyBhIERFTSB0byBjb21wdXRlIHRoZSBhcmVhLjwvbGk+PC91bD5cIixcblx0XCJAQFRlcnJhaW4tRmxhdHRlbl9kZW1fdGFnMEBAXCI6IFwiPHA+VGhlIGlucHV0IERFTS48L3A+PHA+VGhlIERFTSBpcyB1c2VkIHRvIGVzdGltYXRlIHRoZSBsb2NhbCBpbGx1bWluYXRlZCBhcmVhLjwvcD5cIixcblx0XCJAQFRlcnJhaW4tRmxhdHRlbl9nZW9pZF90YWcwQEBcIjogXCI8cD5TcGVjaWZpZXMgd2hldGhlciB0aGUgdmVydGljYWwgcmVmZXJlbmNlIHN5c3RlbSBvZiB0aGUgaW5wdXQgREVNIHdpbGwgYmUgdHJhbnNmb3JtZWQgdG8gZWxsaXBzb2lkYWwgaGVpZ2h0LiBNb3N0IGVsZXZhdGlvbiBkYXRhc2V0cyBhcmUgcmVmZXJlbmNlZCB0byBzZWEgbGV2ZWwgb3J0aG9tZXRyaWMgaGVpZ2h0LCBzbyBhIGNvcnJlY3Rpb24gaXMgcmVxdWlyZWQgaW4gdGhlc2UgY2FzZXMgdG8gY29udmVydCB0byBlbGxpcHNvaWRhbCBoZWlnaHQuPC9wPjx1bD48bGk+Q2hlY2tlZC0tQSBnZW9pZCBjb3JyZWN0aW9uIHdpbGwgYmUgbWFkZSB0byBjb252ZXJ0IG9ydGhvbWV0cmljIGhlaWdodCB0byBlbGxpcHNvaWRhbCBoZWlnaHQgKGJhc2VkIG9uIEVHTTk2IGdlb2lkKS4gVGhpcyBpcyB0aGUgZGVmYXVsdC48L2xpPjxsaT5VbmNoZWNrZWQtLU5vIGdlb2lkIGNvcnJlY3Rpb24gd2lsbCBiZSBtYWRlLiBVc2UgdGhpcyBvcHRpb24gb25seSBpZiB0aGUgREVNIGlzIGV4cHJlc3NlZCBpbiBlbGxpcHNvaWRhbCBoZWlnaHQuPC9saT48L3VsPlwiLFxuXHRcIkBAVGVycmFpbi1GbGF0dGVuX3Jhc3Rlcl90YWcwQEBcIjogXCI8cD5UaGUgaW5wdXQgcmFkYXIgZGF0YS48L3A+PHA+VGhpcyByYXN0ZXIgbXVzdCBmaXJzdCBiZSByYWRpb21ldHJpY2FsbHkgY2FsaWJyYXRlZCB0byBiZXRhIG5vdWdodC48L3A+XCIsXG5cdFwiQEBDcmVhdGUtQ29sb3ItQ29tcG9zaXRlX2JsdWVleHByZXNzaW9uX3RhZzBAQFwiOiBcIjxwPlRoZSBjYWxjdWxhdGlvbiBhc3NpZ25lZCB0byB0aGUgdGhpcmQgYmFuZC48L3A+PHA+QSBiYW5kIG5hbWUsIGJhbmQgSUQsIG9yIGFuIGFsZ2VicmFpYyBleHByZXNzaW9uIHVzaW5nIHRoZSBiYW5kcy48L3A+PHA+VGhlIHN1cHBvcnRlZCBvcGVyYXRvcnMgYXJlIHVuYXJ5OiBwbHVzICgrKSwgbWludXMgKC0pLCB0aW1lcyAoKiksIGFuZCBkaXZpZGUgKC8pLjwvcD5cIixcblx0XCJAQENyZWF0ZS1Db2xvci1Db21wb3NpdGVfZ3JlZW5leHByZXNzaW9uX3RhZzBAQFwiOiBcIjxwPlRoZSBjYWxjdWxhdGlvbiBhc3NpZ25lZCB0byB0aGUgc2Vjb25kIGJhbmQuPC9wPjxwPkEgYmFuZCBuYW1lLCBiYW5kIElELCBvciBhbiBhbGdlYnJhaWMgZXhwcmVzc2lvbiB1c2luZyB0aGUgYmFuZHMuPC9wPjxwPlRoZSBzdXBwb3J0ZWQgb3BlcmF0b3JzIGFyZSB1bmFyeTogcGx1cyAoKyksIG1pbnVzICgtKSwgdGltZXMgKCopLCBhbmQgZGl2aWRlICgvKS48L3A+XCIsXG5cdFwiQEBDcmVhdGUtQ29sb3ItQ29tcG9zaXRlX2lucHV0cmFzdGVyX3RhZzBAQFwiOiBcIjxwPlRoZSBpbnB1dCBtdWx0aWJhbmQgcmFzdGVyIGRhdGEuPC9wPlwiLFxuXHRcIkBAQ3JlYXRlLUNvbG9yLUNvbXBvc2l0ZV9tZXRob2RfdGFnMEBAXCI6IFwiPHA+U3BlY2lmaWVzIHRoZW1ldGhvZCB0aGF0IHdpbGwgYmUgdXNlZCB0byBleHRyYWN0IGJhbmRzLjwvcD48dWw+PGxpPkJhbmQgTmFtZXMtLVRoZSBiYW5kIG5hbWUgcmVwcmVzZW50aW5nIHRoZSB3YXZlbGVuZ3RoaW50ZXJ2YWwgb24gdGhlIGVsZWN0cm9tYWduZXRpYyBzcGVjdHJ1bSAoc3VjaCBhcyBSZWQsIE5lYXIgSW5mcmFyZWQsb3IgVGhlcm1hbCBJbmZyYXJlZCkgb3IgdGhlIHBvbGFyaXphdGlvbiAoc3VjaCBhcyBWSCwgVlYsIEhILG9yIEhWKSB3aWxsIGJlIHVzZWQuIFRoaXMgaXMgdGhlIGRlZmF1bHQuPC9saT48bGk+QmFuZCBJRHMtLVRoZSBiYW5kIG51bWJlciAoc3VjaCBhcyBCMSwgQjIsIG9yIEIzKSB3aWxsIGJlIHVzZWQuPC9saT48L3VsPlwiLFxuXHRcIkBAQ3JlYXRlLUNvbG9yLUNvbXBvc2l0ZV9yZWRleHByZXNzaW9uX3RhZzBAQFwiOiBcIjxwPlRoZSBjYWxjdWxhdGlvbiBhc3NpZ25lZCB0byB0aGUgZmlyc3QgYmFuZC48L3A+PHA+QSBiYW5kIG5hbWUsIGJhbmQgSUQsIG9yIGFuIGFsZ2VicmFpYyBleHByZXNzaW9uIHVzaW5nIHRoZSBiYW5kcy48L3A+PHA+VGhlIHN1cHBvcnRlZCBvcGVyYXRvcnMgYXJlIHVuYXJ5OiBwbHVzICgrKSwgbWludXMgKC0pLCB0aW1lcyAoKiksIGFuZCBkaXZpZGUgKC8pLjwvcD5cIixcblx0XCJAQFN1cmZhY2UtUGFyYW1ldGVyc19sb2NhbHN1cmZhY2V0eXBlX3RhZzBAQFwiOiBcIjxwPkNob29zZSB0aGUgdHlwZSBvZiBzdXJmYWNlIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBmaXR0ZWQgYXJvdW5kIHRoZSB0YXJnZXQgY2VsbC48L3A+PHVsPjxsaT5RdWFkcmF0aWMtLUEgcXVhZHJhdGljIHN1cmZhY2UgZnVuY3Rpb24gd2lsbCBiZSBmaXR0ZWQgdG8gdGhlIG5laWdoYm9yaG9vZCBjZWxscy4gVGhpcyBpcyB0aGUgZGVmYXVsdCB0eXBlLjwvbGk+PGxpPkJpcXVhZHJhdGljLS1BIGJpcXVhZHJhdGljIHN1cmZhY2UgZnVuY3Rpb24gd2lsbCBiZSBmaXR0ZWQgdG8gdGhlIG5laWdoYm9yaG9vZCBjZWxscy48L2xpPjwvdWw+XCIsXG5cdFwiQEBTdXJmYWNlLVBhcmFtZXRlcnNfbmVpZ2hib3Job29kZGlzdGFuY2VfdGFnMEBAXCI6IFwiPHA+VGhlIG91dHB1dCB3aWxsIGJlIGNhbGN1bGF0ZWQgb3ZlciB0aGlzIGRpc3RhbmNlIGZyb20gdGhlIHRhcmdldCBjZWxsIGNlbnRlci4gSXQgZGV0ZXJtaW5lcyB0aGUgbmVpZ2hib3Job29kIHNpemUuIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHRoZSBpbnB1dCByYXN0ZXIgY2VsbCBzaXplLCByZXN1bHRpbmcgaW4gYSAzIGJ5IDMgbmVpZ2hib3Job29kLjwvcD5cIixcblx0XCJAQFN1cmZhY2UtUGFyYW1ldGVyc19vdXRwdXRzbG9wZW1lYXN1cmVtZW50X3RhZzBAQFwiOiBcIjxwPlRoZSBtZWFzdXJlbWVudCB1bml0cyAoZGVncmVlcyBvciBwZXJjZW50YWdlcykgdGhhdCB3aWxsIGJlIHVzZWQgZm9yIHRoZSBvdXRwdXQgc2xvcGUgcmFzdGVyLiBUaGlzIHBhcmFtZXRlciBpcyBvbmx5IGFjdGl2ZSB3aGVuPHN0cm9uZz5QYXJhbWV0ZXIgdHlwZTwvc3Ryb25nPmlzPHN0cm9uZz5TbG9wZTwvc3Ryb25nPi48L3A+PHVsPjxsaT5EZWdyZWUtLVRoZSBpbmNsaW5hdGlvbiBvZiBzbG9wZSB3aWxsIGJlIGNhbGN1bGF0ZWQgaW4gZGVncmVlcy4gVGhpcyBpcyB0aGUgZGVmYXVsdC48L2xpPjxsaT5QZXJjZW50IHJpc2UtLVRoZSBpbmNsaW5hdGlvbiBvZiBzbG9wZSB3aWxsIGJlIGNhbGN1bGF0ZWQgYXMgcGVyY2VudCByaXNlLCBhbHNvIHJlZmVycmVkIHRvIGFzIHRoZSBwZXJjZW50IHNsb3BlLjwvbGk+PC91bD5cIixcblx0XCJAQFN1cmZhY2UtUGFyYW1ldGVyc19wYXJhbWV0ZXJ0eXBlX3RhZzBAQFwiOiBcIjxwPlNwZWNpZmllcyB0aGUgb3V0cHV0IHN1cmZhY2UgcGFyYW1ldGVyIHR5cGUgdGhhdCB3aWxsIGJlIGNvbXB1dGVkLjwvcD48dWw+PGxpPlNsb3BlLS1UaGUgcmF0ZSBvZiBjaGFuZ2UgaW4gZWxldmF0aW9uIHdpbGwgYmUgY29tcHV0ZWQuIFRoaXMgaXMgdGhlIGRlZmF1bHQuPC9saT48bGk+QXNwZWN0LS1UaGUgZG93bnNsb3BlIGRpcmVjdGlvbiBvZiB0aGUgbWF4aW11bSByYXRlIG9mIGNoYW5nZSBmb3IgZWFjaCBjZWxsIHdpbGwgYmUgY29tcHV0ZWQuPC9saT48bGk+TWVhbiBDdXJ2YXR1cmUtLVRoZSBvdmVyYWxsIGN1cnZhdHVyZSBvZiB0aGUgc3VyZmFjZSB3aWxsIGJlIG1lYXN1cmVkLiBJdCBpcyBjb21wdXRlZCBhcyB0aGUgYXZlcmFnZSBvZiB0aGUgbWluaW11bSBhbmQgbWF4aW11bSBjdXJ2YXR1cmUuIFRoaXMgY3VydmF0dXJlIGRlc2NyaWJlcyB0aGUgaW50cmluc2ljIGNvbnZleGl0eSBvciBjb25jYXZpdHkgb2YgdGhlIHN1cmZhY2UsIGluZGVwZW5kZW50IG9mIGRpcmVjdGlvbiBvciBncmF2aXR5IGluZmx1ZW5jZS48L2xpPjxsaT5UYW5nZW50aWFsIChub3JtYWwgY29udG91cikgQ3VydmF0dXJlLS1UaGUgZ2VvbWV0cmljIG5vcm1hbCBjdXJ2YXR1cmUgcGVycGVuZGljdWxhciB0byB0aGUgc2xvcGUgbGluZSwgdGFuZ2VudCB0byB0aGUgY29udG91ciBsaW5lIHdpbGwgYmUgbWVhc3VyZWQuIFRoaXMgY3VydmF0dXJlIGlzIHR5cGljYWxseSBhcHBsaWVkIHRvIGNoYXJhY3Rlcml6ZSB0aGUgY29udmVyZ2VuY2Ugb3IgZGl2ZXJnZW5jZSBvZiBmbG93IGFjcm9zcyB0aGUgc3VyZmFjZS48L2xpPjxsaT5Qcm9maWxlIChub3JtYWwgc2xvcGUgbGluZSkgQ3VydmF0dXJlLS1UaGUgZ2VvbWV0cmljIG5vcm1hbCBjdXJ2YXR1cmUgYWxvbmcgdGhlIHNsb3BlIGxpbmUgd2lsbCBiZSBtZWFzdXJlZC4gVGhpcyBjdXJ2YXR1cmUgaXMgdHlwaWNhbGx5IGFwcGxpZWQgdG8gY2hhcmFjdGVyaXplIHRoZSBhY2NlbGVyYXRpb24gYW5kIGRlY2VsZXJhdGlvbiBvZiBmbG93IGRvd24gdGhlIHN1cmZhY2UuPC9saT48bGk+UGxhbiAocHJvamVjdGVkIGNvbnRvdXIpIEN1cnZhdHVyZS0tVGhlIGN1cnZhdHVyZSBhbG9uZyBjb250b3VyIGxpbmVzIHdpbGwgYmUgbWVhc3VyZWQuPC9saT48bGk+Q29udG91ciBHZW9kZXNpYyBUb3JzaW9uLS1UaGUgcmF0ZSBvZiBjaGFuZ2UgaW4gc2xvcGUgYW5nbGUgYWxvbmcgY29udG91ciBsaW5lcyB3aWxsIGJlIG1lYXN1cmVkLjwvbGk+PGxpPkdhdXNzaWFuIEN1cnZhdHVyZS0tVGhlIG92ZXJhbGwgY3VydmF0dXJlIG9mIHRoZSBzdXJmYWNlIHdpbGwgYmUgbWVhc3VyZWQuIEl0IGlzIGNvbXB1dGVkIGFzIHRoZSBwcm9kdWN0IG9mIHRoZSBtaW5pbXVtIGFuZCBtYXhpbXVtIGN1cnZhdHVyZS48L2xpPjxsaT5DYXNvcmF0aSBDdXJ2YXR1cmUtLVRoZSBnZW5lcmFsIGN1cnZhdHVyZSBvZiB0aGUgc3VyZmFjZSB3aWxsIGJlIG1lYXN1cmVkLiBJdCBjYW4gYmUgemVybyBvciBhbnkgb3RoZXIgcG9zaXRpdmUgbnVtYmVyLjwvbGk+PC91bD5cIixcblx0XCJAQFN1cmZhY2UtUGFyYW1ldGVyc19wcm9qZWN0Z2VvZGVzaWNhemltdXRoc190YWcwQEBcIjogXCI8cD5TcGVjaWZpZXMgd2hldGhlciBnZW9kZXNpYyBhemltdXRocyB3aWxsIGJlIHByb2plY3RlZCB0byBjb3JyZWN0IHRoZSBhbmdsZSBkaXN0b3J0aW9uIGNhdXNlZCBieSB0aGUgb3V0cHV0IHNwYXRpYWwgcmVmZXJlbmNlLlRoaXMgcGFyYW1ldGVyIGlzIG9ubHkgYWN0aXZlIHdoZW48c3Ryb25nPlBhcmFtZXRlciB0eXBlPC9zdHJvbmc+aXM8c3Ryb25nPkFzcGVjdDwvc3Ryb25nPi48L3A+PHVsPjxsaT5VbmNoZWNrZWQtLUdlb2Rlc2ljIGF6aW11dGhzIHdpbGwgbm90IGJlIHByb2plY3RlZC4gVGhpcyBpcyB0aGUgZGVmYXVsdC48L2xpPjxsaT5DaGVja2VkLS1HZW9kZXNpYyBhemltdXRocyB3aWxsIGJlIHByb2plY3RlZC48L2xpPjwvdWw+XCIsXG5cdFwiQEBTdXJmYWNlLVBhcmFtZXRlcnNfcmFzdGVyX3RhZzBAQFwiOiBcIjxwPlRoZSBpbnB1dCBzdXJmYWNlIHJhc3Rlci4gSXQgY2FuIGJlIGFuIGludGVnZXIgb3IgYSBmbG9hdGluZy1wb2ludCByYXN0ZXIuPC9wPlwiLFxuXHRcIkBAU3VyZmFjZS1QYXJhbWV0ZXJzX3VzZWFkYXB0aXZlbmVpZ2hib3Job29kX3RhZzBAQFwiOiBcIjxwPlNwZWNpZmllcyB3aGV0aGVyIG5laWdoYm9yaG9vZCBkaXN0YW5jZSB3aWxsIHZhcnkgd2l0aCBsYW5kc2NhcGUgY2hhbmdlcyAoYWRhcHRpdmUpLiBUaGUgbWF4aW11bSBkaXN0YW5jZSBpcyBkZXRlcm1pbmVkIGJ5IHRoZSBuZWlnaGJvcmhvb2QgZGlzdGFuY2UuIFRoZSBtaW5pbXVtIGRpc3RhbmNlIGlzIHRoZSBpbnB1dCByYXN0ZXIgY2VsbCBzaXplLjwvcD48dWw+PGxpPlVuY2hlY2tlZC0tQSBzaW5nbGUgKGZpeGVkKSBuZWlnaGJvcmhvb2QgZGlzdGFuY2Ugd2lsbCBiZSB1c2VkIGF0IGFsbCBsb2NhdGlvbnMuIFRoaXMgaXMgdGhlIGRlZmF1bHQuPC9saT48bGk+Q2hlY2tlZC0tQW4gYWRhcHRpdmUgbmVpZ2hib3Job29kIGRpc3RhbmNlIHdpbGwgYmUgdXNlZCBhdCBhbGwgbG9jYXRpb25zLjwvbGk+PC91bD5cIixcblx0XCJAQFN1cmZhY2UtUGFyYW1ldGVyc191c2VlcXVhdG9yaWFsYXNwZWN0X3RhZzBAQFwiOiBcIjxwPlNwZWNpZmllcyB3aGV0aGVyIGFzcGVjdCB3aWxsIGJlIG1lYXN1cmVkIGZyb20gYSBwb2ludCBvbiB0aGUgZXF1YXRvciBvciBmcm9tIHRoZSBub3J0aCBwb2xlLlRoaXMgcGFyYW1ldGVyIGlzIG9ubHkgYWN0aXZlIHdoZW48c3Ryb25nPlBhcmFtZXRlciB0eXBlPC9zdHJvbmc+aXM8c3Ryb25nPkFzcGVjdDwvc3Ryb25nPi48L3A+PHVsPjxsaT5VbmNoZWNrZWQtLUFzcGVjdCB3aWxsIGJlIG1lYXN1cmVkIGZyb20gdGhlIG5vcnRoIHBvbGUuIFRoaXMgaXMgdGhlIGRlZmF1bHQuPC9saT48bGk+Q2hlY2tlZC0tQXNwZWN0IHdpbGwgYmUgbWVhc3VyZWQgZnJvbSBhIHBvaW50IG9uIHRoZSBlcXVhdG9yLjwvbGk+PC91bD5cIixcblx0XCJAQFN1cmZhY2UtUGFyYW1ldGVyc196dW5pdF90YWcwQEBcIjogXCI8cD5UaGUgbGluZWFyIHVuaXQgb2YgdmVydGljYWwgei12YWx1ZXMuPC9wPjxwPkl0IGlzIGRlZmluZWQgYnkgYSB2ZXJ0aWNhbCBjb29yZGluYXRlIHN5c3RlbSBpZiBpdCBleGlzdHMuIElmIGEgdmVydGljYWwgY29vcmRpbmF0ZSBzeXN0ZW0gZG9lcyBub3QgZXhpc3QsIHRoZSB6LXVuaXQgc2hvdWxkIGJlIGRlZmluZWQgZnJvbSB0aGUgdW5pdCBsaXN0LCB0byBlbnN1cmUgY29ycmVjdCBnZW9kZXNpYyBjb21wdXRhdGlvbi48L3A+PHVsPjxsaT5JbmNoLS1UaGUgbGluZWFyIHVuaXQgd2lsbCBiZSBpbmNoZXMuPC9saT48bGk+Rm9vdC0tVGhlIGxpbmVhciB1bml0IHdpbGwgYmUgZmVldC48L2xpPjxsaT5ZYXJkLS1UaGUgbGluZWFyIHVuaXQgd2lsbCBiZSB5YXJkcy48L2xpPjxsaT5NaWxlIFVTLS1UaGUgbGluZWFyIHVuaXQgd2lsbCBiZSBtaWxlcy48L2xpPjxsaT5OYXV0aWNhbCBtaWxlLS1UaGUgbGluZWFyIHVuaXQgd2lsbCBiZSBuYXV0aWNhbCBtaWxlcy48L2xpPjxsaT5NaWxsaW1ldGVyLS1UaGUgbGluZWFyIHVuaXQgd2lsbCBiZSBtaWxsaW1ldGVycy48L2xpPjxsaT5DZW50aW1ldGVyLS1UaGUgbGluZWFyIHVuaXQgd2lsbCBiZSBjZW50aW1ldGVycy48L2xpPjxsaT5NZXRlci0tVGhlIGxpbmVhciB1bml0IHdpbGwgYmUgbWV0ZXJzLiBUaGlzIGlzIHRoZSBkZWZhdWx0LjwvbGk+PGxpPktpbG9tZXRlci0tVGhlIGxpbmVhciB1bml0IHdpbGwgYmUga2lsb21ldGVycy48L2xpPjxsaT5EZWNpbWV0ZXItLVRoZSBsaW5lYXIgdW5pdCB3aWxsIGJlIGRlY2ltZXRlcnMuPC9saT48L3VsPlwiLFxuXHRcIkBAU3VyZmFjZS1QYXJhbWV0ZXJzX2FuYWx5c2lzbWFza190YWcwQEBcIjogXCI8cD5BIHJhc3RlciB0aGF0IHNwZWNpZmllcyB0aGUgbG9jYXRpb25zIHdoZXJlIHRoZSBhbmFseXNpcyB3aWxsIG9jY3VyLjwvcD48cD5UaGUgcmFzdGVyIGNhbiBiZSBpbnRlZ2VyIG9yIGZsb2F0aW5nIHBvaW50IHR5cGUuPC9wPjxwPkFsbCBjZWxscyB3aXRoIGEgdmFsaWQgdmFsdWUsIGluY2x1ZGluZyB6ZXJvLCB3aWxsIGNvbXBvc2UgdGhlIG1hc2suIENlbGxzIHRoYXQgYXJlIE5vRGF0YSBpbiB0aGUgbWFzayBpbnB1dCB3aWxsIGJlIE5vRGF0YSBpbiB0aGUgb3V0cHV0LjwvcD5cIixcblx0XCJAQEdlb21ldHJpYy1NZWRpYW5fY2VsbHNpemV0eXBlX3RhZzBAQFwiOiBcIjxwPkNob29zZSB3aGljaCBjZWxsIHNpemUgdG8gdXNlIGluIHRoZSBvdXRwdXQgcmFzdGVyLiBJZiBhbGwgdGhlIGlucHV0IGNlbGwgc2l6ZXMgYXJlIHRoZSBzYW1lLCBhbGwgdGhlIG9wdGlvbnMgd2lsbCB5aWVsZCB0aGUgc2FtZSByZXN1bHRzLjwvcD48dWw+PGxpPkZpcnN0IE9mLS1Vc2UgdGhlIGZpcnN0IGNlbGwgc2l6ZSBvZiB0aGUgaW5wdXQgcmFzdGVycy48L2xpPjxsaT5NaW4gT2YtLVVzZSB0aGUgc21hbGxlc3QgY2VsbCBzaXplIG9mIGFsbCB0aGUgaW5wdXQgcmFzdGVycy48L2xpPjxsaT5NYXggT2YtLVVzZSB0aGUgbGFyZ2VzdCBjZWxsIHNpemUgb2YgYWxsIHRoZSBpbnB1dCByYXN0ZXJzLiBUaGlzIGlzIHRoZSBkZWZhdWx0LjwvbGk+PGxpPk1lYW4gT2YtLVVzZSB0aGUgbWVhbiBjZWxsIHNpemUgb2YgYWxsIHRoZSBpbnB1dCByYXN0ZXJzLjwvbGk+PGxpPkxhc3QgT2YtLVVzZSB0aGUgbGFzdCBjZWxsIHNpemUgb2YgdGhlIGlucHV0IHJhc3RlcnMuPC9saT48L3VsPlwiLFxuXHRcIkBAR2VvbWV0cmljLU1lZGlhbl9lcHNpbG9uX3RhZzBAQFwiOiBcIjxwPlNwZWNpZmllcyB0aGUgY29udmVyZ2VuY2UgdmFsdWUgYmV0d2VlbiB0d28gY29uc2VjdXRpdmUgaXRlcmF0aW9ucy4gV2hlbiBlcHNpbG9uIGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0byB0aGUgc3BlY2lmaWVkIHZhbHVlLCB0aGUgaXRlcmF0aW9uIHN0b3BzLCBhbmQgdGhlIHJlc3VsdCBvZiB0aGUgbGFzdCBpdGVyYXRpb24gaXMgdXNlZC48L3A+XCIsXG5cdFwiQEBHZW9tZXRyaWMtTWVkaWFuX2V4dGVudHR5cGVfdGFnMEBAXCI6IFwiPHA+Q2hvb3NlIHdoaWNoIGV4dGVudCBzaG91bGQgYmUgdXNlZCBpbiB0aGUgb3V0cHV0IHJhc3Rlcjo8L3A+PHVsPjxsaT48cD5GaXJzdCBPZi0tVXNlIHRoZSBleHRlbnQgb2YgdGhlIGZpcnN0IGlucHV0IHJhc3RlciB0byBkZXRlcm1pbmUgdGhlIHByb2Nlc3NpbmcgZXh0ZW50LjwvcD48L2xpPjxsaT5JbnRlcnNlY3Rpb24gT2YtLVVzZSB0aGUgZXh0ZW50IG9mIHRoZSBvdmVybGFwcGluZyBwaXhlbHMgdG8gZGV0ZXJtaW5lIHRoZSBwcm9jZXNzaW5nIGV4dGVudC4gVGhpcyBpcyB0aGUgZGVmYXVsdC48L2xpPjxsaT5VbmlvbiBPZi0tVXNlIHRoZSBleHRlbnQgb2YgYWxsIHRoZSByYXN0ZXJzIHRvIGRldGVybWluZSB0aGUgcHJvY2Vzc2luZyBleHRlbnQuPC9saT48bGk+TGFzdCBPZi0tVXNlIHRoZSBleHRlbnQgb2YgdGhlIGxhc3QgaW5wdXQgcmFzdGVyIHRvIGRldGVybWluZSB0aGUgcHJvY2Vzc2luZyBleHRlbnQuPC9saT48L3VsPlwiLFxuXHRcIkBAR2VvbWV0cmljLU1lZGlhbl9tYXhpbXVtbnVtYmVyb2ZpdGVyYXRpb25zX3RhZzBAQFwiOiBcIjxwPlNwZWNpZmllcyB0aGUgbWF4aW11bSBudW1iZXIgb2YgaXRlcmF0aW9ucyB0byBjb21wbGV0ZS4gVGhlIGNvbXB1dGF0aW9uIGVuZHMgd2hlbiB0aGlzIHZhbHVlIGlzIHJlYWNoZWQsIHJlZ2FyZGxlc3Mgb2YgdGhlPHN0cm9uZz5FcHNpbG9uPC9zdHJvbmc+c2V0dGluZy48L3A+XCIsXG5cdFwiQEBHZW9tZXRyaWMtTWVkaWFuX3Jhc3RlcnNfdGFnMEBAXCI6IFwiPHA+VGhlIGlucHV0IG11bHRpYmFuZCByYXN0ZXJzLjwvcD5cIixcblx0XCJAQExlYXN0LUNvc3QtQ29ycmlkb3JfaW5wdXRhY2N1bXVsYXRpdmVjb3N0ZGlzdGFuY2VyYXN0ZXIxX3RhZzBAQFwiOiBcIjxwPlRoZSBpbnB1dCByYXN0ZXIgcmVwcmVzZW50aW5nIGFjY3VtdWxhdGl2ZSBjb3N0IGRpc3RhbmNlIGZyb20gdGhlIGZpcnN0IHNvdXJjZS48L3A+PHA+SXQgc2hvdWxkIGJlIGFuIGFjY3VtdWxhdGVkIGNvc3QgZGlzdGFuY2Ugb3V0cHV0IGZyb20gdGhlPHN0cm9uZz5EaXN0YW5jZSBBY2N1bXVsYXRpb248L3N0cm9uZz5vcjxzdHJvbmc+RGlzdGFuY2UgQWxsb2NhdGlvbjwvc3Ryb25nPmZ1bmN0aW9uLjwvcD5cIixcblx0XCJAQExlYXN0LUNvc3QtQ29ycmlkb3JfaW5wdXRhY2N1bXVsYXRpdmVjb3N0ZGlzdGFuY2VyYXN0ZXIyX3RhZzBAQFwiOiBcIjxwPlRoZSBpbnB1dCByYXN0ZXIgcmVwcmVzZW50aW5nIGFjY3VtdWxhdGl2ZSBjb3N0IGRpc3RhbmNlIGZyb20gdGhlIHNlY29uZCBzb3VyY2UuPC9wPjxwPkl0IHNob3VsZCBiZSBhbiBhY2N1bXVsYXRlZCBjb3N0IGRpc3RhbmNlIG91dHB1dCBmcm9tIHRoZTxzdHJvbmc+RGlzdGFuY2UgQWNjdW11bGF0aW9uPC9zdHJvbmc+b3I8c3Ryb25nPkRpc3RhbmNlIEFsbG9jYXRpb248L3N0cm9uZz5mdW5jdGlvbi48L3A+XCIsXG5cdFwiQEBMZWFzdC1Db3N0LUNvcnJpZG9yX2lucHV0YmFja2RpcmVjdGlvbnJhc3RlcjFfdGFnMEBAXCI6IFwiPHA+VGhlIGlucHV0IGJhY2sgZGlyZWN0aW9uIHJhc3RlciBmcm9tIHRoZSBmaXJzdCBzb3VyY2UuPC9wPjxwPlRoaXMgaXMgYSByYXN0ZXIgZGF0YXNldCBpZGVudGlmeWluZyB0aGUgZGlyZWN0aW9uIG9mIHRoZSBuZXh0IGNlbGwgYWxvbmcgdGhlIGxlYXN0LWNvc3QgcGF0aCBiYWNrIHRvIHRoZSBmaXJzdCBzb3VyY2UuIFRoaXMgaXMgb3V0cHV0IGZyb20gdGhlPHN0cm9uZz5EaXN0YW5jZSBBY2N1bXVsYXRpb248L3N0cm9uZz5vcjxzdHJvbmc+RGlzdGFuY2UgQWxsb2NhdGlvbjwvc3Ryb25nPmZ1bmN0aW9uLjwvcD5cIixcblx0XCJAQExlYXN0LUNvc3QtQ29ycmlkb3JfaW5wdXRiYWNrZGlyZWN0aW9ucmFzdGVyMl90YWcwQEBcIjogXCI8cD5UaGUgaW5wdXQgYmFjayBkaXJlY3Rpb24gcmFzdGVyIGZyb20gdGhlIHNlY29uZCBzb3VyY2UuPC9wPjxwPlRoaXMgaXMgYSByYXN0ZXIgZGF0YXNldCBpZGVudGlmeWluZyB0aGUgZGlyZWN0aW9uIG9mIHRoZSBuZXh0IGNlbGwgYWxvbmcgdGhlIGxlYXN0LWNvc3QgcGF0aCBiYWNrIHRvIHRoZSBmaXJzdCBzb3VyY2UuIFRoaXMgaXMgb3V0cHV0IGZyb20gdGhlPHN0cm9uZz5EaXN0YW5jZSBBY2N1bXVsYXRpb248L3N0cm9uZz5vcjxzdHJvbmc+RGlzdGFuY2UgQWxsb2NhdGlvbjwvc3Ryb25nPmZ1bmN0aW9uLjwvcD5cIixcblx0XCJAQExlYXN0LUNvc3QtQ29ycmlkb3JfdGhyZXNob2xkX3RhZzBAQFwiOiBcIjxwPkEgcGVyY2VudCBvciBhY2N1bXVsYXRpdmUgY29zdCB0aHJlc2hvbGQgdGhhdCB3aWxsIGRldGVybWluZSB3aGV0aGVyIGEgZ2l2ZW4gY2VsbCB3aWxsIGJlIGluY2x1ZGVkIGluIHRoZSBvdXRwdXQgY29ycmlkb3IgcmFzdGVyLjwvcD48cD5XaGVuIHRoZTxzdHJvbmc+VGhyZXNob2xkIG1ldGhvZDwvc3Ryb25nPnBhcmFtZXRlciBpcyBzZXQgdG88c3Ryb25nPlBlcmNlbnQgb2YgbGVhc3QgY29zdDwvc3Ryb25nPiwgdGhlIHNwZWNpZmllZCB2YWx1ZSBpbmRpY2F0ZXMgdGhlIHBlcmNlbnQgaW5jcmVhc2UgdG8gYXBwbHkgZnJvbSB0aGUgbWluaW11bSB2YWx1ZSBvZiB0aGUgc3VtbWVkIGFjY3VtdWxhdGl2ZSBjb3N0IGRpc3RhbmNlIHJhc3RlcnMuIFdoZW4gdGhlPHN0cm9uZz5UaHJlc2hvbGQgbWV0aG9kPC9zdHJvbmc+cGFyYW1ldGVyIGlzIHNldCB0bzxzdHJvbmc+QWNjdW11bGF0aXZlIGNvc3Q8L3N0cm9uZz4sIHRoZSB2YWx1ZSBpbmRpY2F0ZXMgY2VsbHMgdGhhdCBoYXZlIGEgc3VtbWVkIGFjY3VtdWxhdGl2ZSBjb3N0IGVxdWFsIHRvIG9yIGJlbG93IHRoZSB2YWx1ZSB0aGF0IHdpbGwgYmUgaW5jbHVkZWQgaW4gdGhlIGNvcnJpZG9yLjwvcD48cD5UaGlzIHBhcmFtZXRlciBpcyBvbmx5IGFjdGl2ZSBpZiB0aGU8c3Ryb25nPlRocmVzaG9sZCBtZXRob2Q8L3N0cm9uZz5wYXJhbWV0ZXIgaXMgc2V0IHRvPHN0cm9uZz5QZXJjZW50IG9mIGxlYXN0IGNvc3Q8L3N0cm9uZz5vcjxzdHJvbmc+QWNjdW11bGF0aXZlIGNvc3Q8L3N0cm9uZz4uPC9wPlwiLFxuXHRcIkBATGVhc3QtQ29zdC1Db3JyaWRvcl90aHJlc2hvbGRtZXRob2RfdGFnMEBAXCI6IFwiPHA+U3BlY2lmaWVzIGhvdyB0aGUgdGhyZXNob2xkIHdpbGwgYmUgZGVmaW5lZC48L3A+PHA+PC9wPjx1bD48bGk+PHN0cm9uZz5ObyBUaHJlc2hvbGQ8L3N0cm9uZz4tLU5vIHRocmVzaG9sZCB3aWxsIGJlIGFwcGxpZWQsIGFuZCB0aGUgcmVzdWx0aW5nIGNvcnJpZG9yIHdpbGwgY292ZXIgdGhlIGZ1bGwgZXh0ZW50IG9mIHRoZSBpbnB1dCByYXN0ZXJzLiBUaGlzIGlzIHRoZSBkZWZhdWx0LjwvbGk+PGxpPjxzdHJvbmc+UGVyY2VudCBvZiBMZWFzdCBDb3N0PC9zdHJvbmc+LS1UaGUgdGhyZXNob2xkIHdpbGwgYmUgZGVmaW5lZCBhcyBhIHBlcmNlbnQgb2YgdGhlIG1pbmltdW0gdmFsdWUgb2YgdGhlIHN1bW1lZCBhY2N1bXVsYXRpdmUgY29zdCBkaXN0YW5jZSByYXN0ZXJzLjwvbGk+PGxpPjxzdHJvbmc+QWNjdW11bGF0aXZlIENvc3Q8L3N0cm9uZz4tLVRoZSB0aHJlc2hvbGQgd2lsbCBiZSBkZWZpbmVkIGluIGFjY3VtdWxhdGl2ZSBjb3N0IGRpc3RhbmNlIHVuaXRzLjwvbGk+PC91bD5cIlxufTtcbmNvbnN0IGhlbHBUZXh0c19lbiA9IHtcblx0cmZ4QXJnc0hlbHBUZXh0czogcmZ4QXJnc0hlbHBUZXh0c1xufTtcblxuZXhwb3J0IGRlZmF1bHQgaGVscFRleHRzX2VuO1xuZXhwb3J0IHsgcmZ4QXJnc0hlbHBUZXh0cyB9O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1oZWxwLXRleHRzLmVuLWY5ZDA3ZmJlLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==