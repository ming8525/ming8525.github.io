"use strict";
(self["webpackChunkexb_client"] = self["webpackChunkexb_client"] || []).push([["vendors-extensions_widgets_arcgis_analysis_node_modules_arcgis_arcgis-raster-function-editor_-b251eb"],{

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/arcgis-raster-function-editor/dist/esm/rfx-cte-dimensionless-editor-07d385f3.js":
/*!*************************************************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/arcgis-raster-function-editor/dist/esm/rfx-cte-dimensionless-editor-07d385f3.js ***!
  \*************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   R: () => (/* binding */ RfxCteDimensionlessEditor)
/* harmony export */ });
/* harmony import */ var _index_da1b7138_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index-da1b7138.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/arcgis-raster-function-editor/dist/esm/index-da1b7138.js");
/* harmony import */ var _arcgis_core_core_lang_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @arcgis/core/core/lang.js */ "@arcgis/core/core/lang.js");
/* harmony import */ var _type_gaurds_1840747f_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./type-gaurds-1840747f.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/arcgis-raster-function-editor/dist/esm/type-gaurds-1840747f.js");
/* harmony import */ var _ui_utils_928a4096_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ui-utils-928a4096.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/arcgis-raster-function-editor/dist/esm/ui-utils-928a4096.js");
/* harmony import */ var _arcgis_core_identity_IdentityManager_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @arcgis/core/identity/IdentityManager.js */ "@arcgis/core/identity/IdentityManager.js");
/* harmony import */ var _arcgis_core_core_urlUtils_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @arcgis/core/core/urlUtils.js */ "@arcgis/core/core/urlUtils.js");
/* harmony import */ var _arcgis_core_layers_Layer_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @arcgis/core/layers/Layer.js */ "@arcgis/core/layers/Layer.js");
/* harmony import */ var _arcgis_core_layers_ImageryLayer_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @arcgis/core/layers/ImageryLayer.js */ "@arcgis/core/layers/ImageryLayer.js");
/* harmony import */ var _arcgis_core_smartMapping_raster_renderers_stretch_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @arcgis/core/smartMapping/raster/renderers/stretch.js */ "@arcgis/core/smartMapping/raster/renderers/stretch.js");
/* harmony import */ var _arcgis_core_request_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @arcgis/core/request.js */ "@arcgis/core/request.js");
/* harmony import */ var _arcgis_core_rest_support_AlgorithmicColorRamp_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @arcgis/core/rest/support/AlgorithmicColorRamp.js */ "@arcgis/core/rest/support/AlgorithmicColorRamp.js");
/* harmony import */ var _arcgis_core_rest_support_MultipartColorRamp_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @arcgis/core/rest/support/MultipartColorRamp.js */ "@arcgis/core/rest/support/MultipartColorRamp.js");
/* harmony import */ var _arcgis_core_Color_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @arcgis/core/Color.js */ "@arcgis/core/Color.js");
/* harmony import */ var _colorRampUtils_8bdd46c5_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./colorRampUtils-8bdd46c5.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/arcgis-raster-function-editor/dist/esm/colorRampUtils-8bdd46c5.js");
/* harmony import */ var _arcgis_core_rest_geoprocessor_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! @arcgis/core/rest/geoprocessor.js */ "@arcgis/core/rest/geoprocessor.js");
/* harmony import */ var _arcgis_core_portal_PortalItem_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! @arcgis/core/portal/PortalItem.js */ "@arcgis/core/portal/PortalItem.js");
/* harmony import */ var _multidimensional_helper_fc8fbe0e_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./multidimensional-helper-fc8fbe0e.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/arcgis-raster-function-editor/dist/esm/multidimensional-helper-fc8fbe0e.js");


















const HelpClickHandlerKeys = {
    inputArgHelpClickHandler: "inputArgHelpClickHandler"
};

const rfxCteDimensionlessEditorCss = "";

const RfxCteDimensionlessEditor = class {
    constructor(hostRef) {
        (0,_index_da1b7138_js__WEBPACK_IMPORTED_MODULE_0__.r)(this, hostRef);
        this.rfxArgumentChange = (0,_index_da1b7138_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, "rfxArgumentChange", 7);
        this.showDimensionLessCheckbox = true;
        /**
         * Stores event handlers for help action click, stored in connected callback to avoid
         * fetching function on each render ( to avoid common bad practice )
         */
        this.helpActionClickEventHandlers = new Map();
        /**
         * function to handle raster change
         * check if layer has only 1 variable & all dimensions have 1 value
         * if so, show dimensionless arg
         */
        this.evaluateFilterTriggerArg = async (data) => {
            const mdimDefLeadsToSingleSlice = await this.isMultidimensionalDefinitionAppliedSingleSlice(data);
            // a reset is done as sometimes the value doesn't change but a rerender is necessary
            this.mdimDefLeadsToSingleSlice = undefined;
            this.mdimDefLeadsToSingleSlice = mdimDefLeadsToSingleSlice;
        };
        this.evaluateRasterTriggerArg = async () => {
            const rasterTriggerArg = this.widgetArgs.triggerArgs.Raster;
            const inputWidget = rasterTriggerArg?.input;
            const layer = await inputWidget.getSelectedLayer();
            if (layer) {
                const isRasterSingleSlice = this.checkIfRasterIsSingleSlice(layer);
                this.isRasterSingleSlice = isRasterSingleSlice;
            }
            else {
                // handles case where the raster is removed.
                this.mdimDefLeadsToSingleSlice = false;
            }
        };
        this.isRasterSingleSlice = false;
        this.mdimDefLeadsToSingleSlice = false;
        this.widgetArgs = undefined;
    }
    //--------------------------------------------------------------------------
    //
    //  Lifecycle
    //
    //--------------------------------------------------------------------------
    connectedCallback() {
        this.processWidgetArgs(this.widgetArgs);
    }
    async componentWillLoad() {
        await this.setupInitialState(this.widgetArgs);
    }
    componentWillRender() {
        const isSingleSlice = this.isRasterSingleSlice || this.mdimDefLeadsToSingleSlice;
        const input = this.widgetArgs.triggerArgs.Raster?.input;
        const isValuePresent = Boolean(input?.value);
        // If no input "uncheck" checkbox and show UI
        const showDimensionLessCheckbox = isValuePresent === false || isSingleSlice;
        this.showDimensionLessCheckbox = showDimensionLessCheckbox;
    }
    componentDidLoad() {
        this.attachHelpClickEventHandlers();
    }
    //--------------------------------------------------------------------------
    //
    //  Private Methods
    //
    //--------------------------------------------------------------------------
    /**
     * All validation logic of widgetArgs -> mainly the inputArgs and triggerAttributes
     * goes here
     */
    processWidgetArgs({ inputArgs, triggerArgs }) {
        // should have only one inputArg
        Object.keys(inputArgs).forEach((_inputArg) => {
            const rfxArg = inputArgs[_inputArg];
            this.inputArg = rfxArg;
            rfxArg.input = this.hostElement;
        });
        // has 2 trigger args
        const rasterTriggerArg = triggerArgs.Raster;
        rasterTriggerArg?.input?.addEventListener("rfxArgumentChange", () => {
            this.evaluateRasterTriggerArg();
        });
        const filterTriggerArg = triggerArgs.Filter;
        filterTriggerArg?.input?.addEventListener("rfxArgumentChange", ({ detail: { value } }) => {
            this.evaluateFilterTriggerArg(value);
        });
    }
    async setupInitialState({ triggerArgs }) {
        const input = triggerArgs.Raster?.input;
        if (!input || !input.value) {
            this.isRasterSingleSlice = false;
            this.mdimDefLeadsToSingleSlice = false;
            return;
        }
        await this.evaluateRasterTriggerArg();
        // check and set if filter config leads to single slice
        const filterInput = triggerArgs.Filter?.input;
        const filterValue = filterInput.value || triggerArgs.Filter.value;
        if (!filterInput || !filterValue) {
            this.mdimDefLeadsToSingleSlice = false;
        }
        else {
            this.evaluateFilterTriggerArg(filterValue);
        }
    }
    attachHelpClickEventHandlers() {
        const inputArgHelpClickHandler = this.widgetArgs.onHelpActionClick({
            heading: this.inputArg.displayName,
            referenceElement: this.widgetContainer,
            helpTextID: this.inputArg?.helpTextID
        });
        this.helpActionClickEventHandlers.set(HelpClickHandlerKeys.inputArgHelpClickHandler, inputArgHelpClickHandler);
    }
    /**
     * function to check if raster layer is a single slice
     * meaning it has only 1 variable and each dimension has only 1 value
     * @param {RasterLayer} layer
     * @returns boolean
     */
    checkIfRasterIsSingleSlice(layer) {
        const multidimensionalInfo = layer.multidimensionalInfo;
        const mDimVariables = multidimensionalInfo && multidimensionalInfo.variables;
        if (!multidimensionalInfo || !mDimVariables || mDimVariables.length !== 1) {
            return false;
        }
        const mDimVariableDimensions = mDimVariables[0].dimensions;
        // iterate over each dimension and verify each dimension has single value.
        const dimensionsHaveSingleValue = mDimVariableDimensions.every((dimension) => {
            const dimensionValues = dimension && dimension.values;
            return dimensionValues && dimensionValues.length === 1;
        });
        return dimensionsHaveSingleValue;
    }
    /**
     * Function is responsible to find whether the definition
     * leads to a single slice
     * @param {} mdimDefinition
     * returns boolean
     */
    async isMultidimensionalDefinitionAppliedSingleSlice(mdimDefinition) {
        if (typeof mdimDefinition === "string") {
            mdimDefinition = JSON.parse(mdimDefinition);
        }
        const input = this.widgetArgs.triggerArgs.Raster?.input;
        if (!input.value) {
            return false;
        }
        const layer = await input.getSelectedLayer();
        if ((0,_type_gaurds_1840747f_js__WEBPACK_IMPORTED_MODULE_2__.i)(layer)) {
            return;
        }
        const mutlidimensionalInfo = layer.type === "imagery-tile"
            ? layer.rasterInfo.multidimensionalInfo
            : layer.multidimensionalInfo;
        const isMultidimensionalDefinitionAppliedSingleSlice = (0,_multidimensional_helper_fc8fbe0e_js__WEBPACK_IMPORTED_MODULE_16__.m)(mdimDefinition, (0,_multidimensional_helper_fc8fbe0e_js__WEBPACK_IMPORTED_MODULE_16__.c)(mutlidimensionalInfo));
        return isMultidimensionalDefinitionAppliedSingleSlice;
    }
    render() {
        return ((0,_index_da1b7138_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", null, this.showDimensionLessCheckbox ? ((0,_index_da1b7138_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", { alignment: "start", scale: _ui_utils_928a4096_js__WEBPACK_IMPORTED_MODULE_3__.U.Scale, layout: "inline-space-between", ref: (e) => {
                this.widgetContainer = e;
            } }, (0,_index_da1b7138_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-checkbox", { checked: this.inputArg.value, onCalciteCheckboxChange: (e) => {
                const element = e.target;
                const value = element.checked;
                this.inputArg.value = value;
            } }), (0,_index_da1b7138_js__WEBPACK_IMPORTED_MODULE_0__.h)("rfx-label", { label: this.inputArg.displayName, onRfxLabelHelpActionClick: () => this.helpActionClickEventHandlers?.get(HelpClickHandlerKeys.inputArgHelpClickHandler)() }))) : null));
    }
    get hostElement() { return (0,_index_da1b7138_js__WEBPACK_IMPORTED_MODULE_0__.a)(this); }
};
RfxCteDimensionlessEditor.style = rfxCteDimensionlessEditorCss;



//# sourceMappingURL=rfx-cte-dimensionless-editor-07d385f3.js.map

/***/ }),

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/arcgis-raster-function-editor/dist/esm/rfx-cte-dimensionless-editor.entry.js":
/*!**********************************************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/arcgis-raster-function-editor/dist/esm/rfx-cte-dimensionless-editor.entry.js ***!
  \**********************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   rfx_cte_dimensionless_editor: () => (/* reexport safe */ _rfx_cte_dimensionless_editor_07d385f3_js__WEBPACK_IMPORTED_MODULE_0__.R)
/* harmony export */ });
/* harmony import */ var _rfx_cte_dimensionless_editor_07d385f3_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./rfx-cte-dimensionless-editor-07d385f3.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/arcgis-raster-function-editor/dist/esm/rfx-cte-dimensionless-editor-07d385f3.js");
/* harmony import */ var _index_da1b7138_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index-da1b7138.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/arcgis-raster-function-editor/dist/esm/index-da1b7138.js");
/* harmony import */ var _arcgis_core_core_lang_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @arcgis/core/core/lang.js */ "@arcgis/core/core/lang.js");
/* harmony import */ var _type_gaurds_1840747f_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./type-gaurds-1840747f.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/arcgis-raster-function-editor/dist/esm/type-gaurds-1840747f.js");
/* harmony import */ var _getTag_96af029d_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./_getTag-96af029d.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/arcgis-raster-function-editor/dist/esm/_getTag-96af029d.js");
/* harmony import */ var _ui_utils_928a4096_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./ui-utils-928a4096.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/arcgis-raster-function-editor/dist/esm/ui-utils-928a4096.js");
/* harmony import */ var _arcgis_core_identity_IdentityManager_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @arcgis/core/identity/IdentityManager.js */ "@arcgis/core/identity/IdentityManager.js");
/* harmony import */ var _arcgis_core_core_urlUtils_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @arcgis/core/core/urlUtils.js */ "@arcgis/core/core/urlUtils.js");
/* harmony import */ var _arcgis_core_layers_Layer_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @arcgis/core/layers/Layer.js */ "@arcgis/core/layers/Layer.js");
/* harmony import */ var _arcgis_core_layers_ImageryLayer_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @arcgis/core/layers/ImageryLayer.js */ "@arcgis/core/layers/ImageryLayer.js");
/* harmony import */ var _arcgis_core_smartMapping_raster_renderers_stretch_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @arcgis/core/smartMapping/raster/renderers/stretch.js */ "@arcgis/core/smartMapping/raster/renderers/stretch.js");
/* harmony import */ var _arcgis_core_request_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @arcgis/core/request.js */ "@arcgis/core/request.js");
/* harmony import */ var _arcgis_core_rest_support_AlgorithmicColorRamp_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @arcgis/core/rest/support/AlgorithmicColorRamp.js */ "@arcgis/core/rest/support/AlgorithmicColorRamp.js");
/* harmony import */ var _arcgis_core_rest_support_MultipartColorRamp_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! @arcgis/core/rest/support/MultipartColorRamp.js */ "@arcgis/core/rest/support/MultipartColorRamp.js");
/* harmony import */ var _arcgis_core_Color_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! @arcgis/core/Color.js */ "@arcgis/core/Color.js");
/* harmony import */ var _colorRampUtils_8bdd46c5_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./colorRampUtils-8bdd46c5.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/arcgis-raster-function-editor/dist/esm/colorRampUtils-8bdd46c5.js");
/* harmony import */ var _arcgis_core_rest_geoprocessor_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! @arcgis/core/rest/geoprocessor.js */ "@arcgis/core/rest/geoprocessor.js");
/* harmony import */ var _arcgis_core_portal_PortalItem_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! @arcgis/core/portal/PortalItem.js */ "@arcgis/core/portal/PortalItem.js");
/* harmony import */ var _multidimensional_helper_fc8fbe0e_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./multidimensional-helper-fc8fbe0e.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/arcgis-raster-function-editor/dist/esm/multidimensional-helper-fc8fbe0e.js");
/* harmony import */ var _Uint8Array_68e1e3f9_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./_Uint8Array-68e1e3f9.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/arcgis-raster-function-editor/dist/esm/_Uint8Array-68e1e3f9.js");





















//# sourceMappingURL=rfx-cte-dimensionless-editor.entry.js.map

/***/ }),

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/arcgis-raster-function-editor/dist/esm/type-gaurds-1840747f.js":
/*!********************************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/arcgis-raster-function-editor/dist/esm/type-gaurds-1840747f.js ***!
  \********************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ ARGS_KEYWORD),
/* harmony export */   F: () => (/* binding */ FUNCTION_KEYWORD),
/* harmony export */   R: () => (/* binding */ RFV_TYPE),
/* harmony export */   T: () => (/* binding */ TYPE_KEYWORD),
/* harmony export */   a: () => (/* binding */ isRFxArg),
/* harmony export */   b: () => (/* binding */ RFT_TYPE),
/* harmony export */   c: () => (/* binding */ isReferencedObject),
/* harmony export */   d: () => (/* binding */ isNumber),
/* harmony export */   e: () => (/* binding */ isWidgetValueBoolean),
/* harmony export */   f: () => (/* binding */ isColorRamp),
/* harmony export */   g: () => (/* binding */ isRecordSet),
/* harmony export */   h: () => (/* binding */ isFeatureLayer),
/* harmony export */   i: () => (/* binding */ isEmptyDataItem),
/* harmony export */   j: () => (/* binding */ isTileLayer),
/* harmony export */   k: () => (/* binding */ isDynamicImageryLayer),
/* harmony export */   l: () => (/* binding */ isImageryLayer),
/* harmony export */   m: () => (/* binding */ isImageryTileLayer)
/* harmony export */ });
/* harmony import */ var _getTag_96af029d_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_getTag-96af029d.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/arcgis-raster-function-editor/dist/esm/_getTag-96af029d.js");


/** `Object#toString` result references. */
var mapTag = '[object Map]',
    setTag = '[object Set]';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Checks if `value` is an empty object, collection, map, or set.
 *
 * Objects are considered empty if they have no own enumerable string keyed
 * properties.
 *
 * Array-like values such as `arguments` objects, arrays, buffers, strings, or
 * jQuery-like collections are considered empty if they have a `length` of `0`.
 * Similarly, maps and sets are considered empty if they have a `size` of `0`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is empty, else `false`.
 * @example
 *
 * _.isEmpty(null);
 * // => true
 *
 * _.isEmpty(true);
 * // => true
 *
 * _.isEmpty(1);
 * // => true
 *
 * _.isEmpty([1, 2, 3]);
 * // => false
 *
 * _.isEmpty({ 'a': 1 });
 * // => false
 */
function isEmpty(value) {
  if (value == null) {
    return true;
  }
  if ((0,_getTag_96af029d_js__WEBPACK_IMPORTED_MODULE_0__.i)(value) &&
      ((0,_getTag_96af029d_js__WEBPACK_IMPORTED_MODULE_0__.a)(value) || typeof value == 'string' || typeof value.splice == 'function' ||
        (0,_getTag_96af029d_js__WEBPACK_IMPORTED_MODULE_0__.b)(value) || (0,_getTag_96af029d_js__WEBPACK_IMPORTED_MODULE_0__.c)(value) || (0,_getTag_96af029d_js__WEBPACK_IMPORTED_MODULE_0__.d)(value))) {
    return !value.length;
  }
  var tag = (0,_getTag_96af029d_js__WEBPACK_IMPORTED_MODULE_0__.g)(value);
  if (tag == mapTag || tag == setTag) {
    return !value.size;
  }
  if ((0,_getTag_96af029d_js__WEBPACK_IMPORTED_MODULE_0__.e)(value)) {
    return !(0,_getTag_96af029d_js__WEBPACK_IMPORTED_MODULE_0__.f)(value).length;
  }
  for (var key in value) {
    if (hasOwnProperty.call(value, key)) {
      return false;
    }
  }
  return true;
}

const RFT_TYPE = "RasterFunctionTemplate";
const TYPE_KEYWORD = "type";
const RFV_TYPE = "RasterFunctionVariable";
const ARGS_KEYWORD = "arguments";
const FUNCTION_KEYWORD = "function";
function isReferencedObject(obj) {
    if (!obj) {
        return false;
    }
    if (obj._object_ref_id != null) {
        return true;
    }
    return false;
}
function isNumber(x) {
    x = String(x).trim();
    if (x === "") {
        return false;
    }
    return /^[+-]?(\d+)?(\.\d+)?$/.test(x);
}
function isWidgetValueBoolean(x) {
    x = String(x).trim();
    return ["true", "false"].indexOf(x) >= 0;
}
function isColorRamp(rfxArg) {
    if (!rfxArg) {
        return false;
    }
    if (rfxArg.type && rfxArg.type.toLowerCase().indexOf("colorramp") >= 0) {
        return true;
    }
    if (rfxArg.value && rfxArg.value.type && rfxArg.value.type.toLowerCase().indexOf("colorramp") >= 0) {
        return true;
    }
    return false;
}
function isRecordSet(rfxArg) {
    return rfxArg.type && rfxArg.type.toLowerCase().indexOf("recordset") >= 0;
}
/**
 * Determines whether the given RFT element is an RFx argument.
 *
 * @param {any} rftElement - The RFT element to check.
 * @returns {boolean} `true` if the given element is RasterFunctionTemplate,
 * RasterFunctionVariable, isColorRamp, isRecordSet; `false` otherwise.
 */
function isRFxArg(rftElement) {
    if (!rftElement) {
        return false;
    }
    const type = rftElement.type;
    return [RFT_TYPE, RFV_TYPE].indexOf(type) >= 0 || isColorRamp(rftElement) || isRecordSet(rftElement);
}
/**
 * Determines if the input is a FeatureLayer
 * @param {__esri.Layer} layer the layer to check the type of
 * @returns {layer is __esri.FeatureLayer} layer is a FeatureLayer
 */
function isFeatureLayer(layer) {
    return layer.type === "feature";
}
/**
 * Determines if the input is a TileLayer
 * @param {__esri.Layer} layer the layer to check the type of
 * @returns {layer is __esri.TileLayer} layer is a TileLayer
 */
function isTileLayer(layer) {
    return layer.type === "tile";
}
/**
 * Determines if the input is a ImageryTileLayer
 * @param {__esri.Layer} layer the layer to check the type of
 * @returns {layer is __esri.ImageryLayer} layer is a ImageryLayer
 */
function isDynamicImageryLayer(layer) {
    return (layer.type === "imagery-tile" &&
        layer.sourceJSON.capabilities.toLowerCase().indexOf("tilesonly") < 0);
}
/**
 * Determines if the input is a ImageryLayer
 * @param {__esri.Layer} layer the layer to check the type of
 * @returns {layer is __esri.ImageryLayer} layer is a ImageryLayer
 */
function isImageryLayer(layer) {
    return layer.type === "imagery" || isDynamicImageryLayer(layer);
}
/**
 * Determines if the input is a ImageryTileLayer
 * @param {__esri.Layer} layer the layer to check the type of
 * @returns {layer is __esri.ImageryTileLayer} layer is a ImageryTileLayer
 */
function isImageryTileLayer(layer) {
    return layer.type === "imagery-tile" && !isDynamicImageryLayer(layer);
}
function isEveryPropertyEmpty(value) {
    let isAllPropsEmpty = true;
    if (typeof value === "object" && (0,_getTag_96af029d_js__WEBPACK_IMPORTED_MODULE_0__.a)(value) === false) {
        // using for-in as it will work with objects with properties that set via accessors as well
        for (const prop in value) {
            // This will tell the TypeScript compiler that the obj object has a string index signature,
            // and will allow to access its properties using a string index without getting the "Element implicitly has an 'any' type" error.
            const propValue = value?.[prop];
            if (value.hasOwnProperty(prop) === true && propValue !== undefined && propValue !== null && propValue !== "") {
                isAllPropsEmpty = false;
                break;
            }
        }
    }
    return isAllPropsEmpty;
}
/**
 * Check for an empty value for data items like GPString and Field.
 * @param value data item value.
 * @returns whether the value is considered empty.
 */
function isEmptyDataItem(value) {
    return (value === undefined ||
        value === null ||
        // single-select, "" is a special case for strings
        (typeof value === "string" && value === "") ||
        // single-select, empty objects are a special case for nested values
        ((0,_getTag_96af029d_js__WEBPACK_IMPORTED_MODULE_0__.h)(value) && isEmpty(value)) ||
        // multi-select
        (Array.isArray(value) && value.length < 1) ||
        // only testing objects which are not arrays
        // TODO: combine isEveryPropertyEmpty and isEmptyDataItem to single function
        (typeof value === "object" && (0,_getTag_96af029d_js__WEBPACK_IMPORTED_MODULE_0__.a)(value) === false && isEveryPropertyEmpty(value)));
}



//# sourceMappingURL=type-gaurds-1840747f.js.map

/***/ }),

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/arcgis-raster-function-editor/dist/esm/ui-utils-928a4096.js":
/*!*****************************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/arcgis-raster-function-editor/dist/esm/ui-utils-928a4096.js ***!
  \*****************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   C: () => (/* binding */ CalciteScale),
/* harmony export */   U: () => (/* binding */ UIDefaults),
/* harmony export */   a: () => (/* binding */ CalciteOverlayPositioning)
/* harmony export */ });
const UIDefaults = {
    Scale: "s",
    PopoverTimer: 60
};
const CalciteScale = {
    s: "s",
    m: "m"
};
const CalciteOverlayPositioning = {
    absolute: "absolute",
    fixed: "fixed"
};



//# sourceMappingURL=ui-utils-928a4096.js.map

/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid2lkZ2V0cy9jaHVua3MvYXJjZ2lzX2FuYWx5c2lzX25vZGVfbW9kdWxlc19hcmNnaXNfYXJjZ2lzLXJhc3Rlci1mdW5jdGlvbi1lZGl0b3JfLWIyNTFlYi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBa0c7QUFDL0Q7QUFDOEI7QUFDUjtBQUNQO0FBQ1g7QUFDRDtBQUNPO0FBQ2tCO0FBQzlCO0FBQzBCO0FBQ0Y7QUFDMUI7QUFDTztBQUNLO0FBQ0E7QUFDbUU7O0FBRTlHO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUSxxREFBZ0I7QUFDeEIsaUNBQWlDLHFEQUFXO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isd0JBQXdCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSwwRUFBMEUsVUFBVSxTQUFTO0FBQzdGO0FBQ0EsU0FBUztBQUNUO0FBQ0EsOEJBQThCLGFBQWE7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsc0RBQWE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0Msc0RBQU87QUFDN0M7O0FBRWtXOztBQUVsVzs7Ozs7Ozs7Ozs7Ozs7OztBQ3pNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRThFOztBQUU5RSIsInNvdXJjZXMiOlsid2VicGFjazovL2V4Yi1jbGllbnQvLi9leHRlbnNpb25zL3dpZGdldHMvYXJjZ2lzL2FuYWx5c2lzL25vZGVfbW9kdWxlcy9AYXJjZ2lzL2FyY2dpcy1yYXN0ZXItZnVuY3Rpb24tZWRpdG9yL2Rpc3QvZXNtL3JmeC1jdGUtZGltZW5zaW9ubGVzcy1lZGl0b3ItMDdkMzg1ZjMuanMiLCJ3ZWJwYWNrOi8vZXhiLWNsaWVudC8uL2V4dGVuc2lvbnMvd2lkZ2V0cy9hcmNnaXMvYW5hbHlzaXMvbm9kZV9tb2R1bGVzL0BhcmNnaXMvYXJjZ2lzLXJhc3Rlci1mdW5jdGlvbi1lZGl0b3IvZGlzdC9lc20vcmZ4LWN0ZS1kaW1lbnNpb25sZXNzLWVkaXRvci5lbnRyeS5qcyIsIndlYnBhY2s6Ly9leGItY2xpZW50Ly4vZXh0ZW5zaW9ucy93aWRnZXRzL2FyY2dpcy9hbmFseXNpcy9ub2RlX21vZHVsZXMvQGFyY2dpcy9hcmNnaXMtcmFzdGVyLWZ1bmN0aW9uLWVkaXRvci9kaXN0L2VzbS90eXBlLWdhdXJkcy0xODQwNzQ3Zi5qcyIsIndlYnBhY2s6Ly9leGItY2xpZW50Ly4vZXh0ZW5zaW9ucy93aWRnZXRzL2FyY2dpcy9hbmFseXNpcy9ub2RlX21vZHVsZXMvQGFyY2dpcy9hcmNnaXMtcmFzdGVyLWZ1bmN0aW9uLWVkaXRvci9kaXN0L2VzbS91aS11dGlscy05MjhhNDA5Ni5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyByIGFzIHJlZ2lzdGVySW5zdGFuY2UsIGMgYXMgY3JlYXRlRXZlbnQsIGgsIGEgYXMgZ2V0RWxlbWVudCB9IGZyb20gJy4vaW5kZXgtZGExYjcxMzguanMnO1xuaW1wb3J0ICdAYXJjZ2lzL2NvcmUvY29yZS9sYW5nLmpzJztcbmltcG9ydCB7IGkgYXMgaXNFbXB0eURhdGFJdGVtIH0gZnJvbSAnLi90eXBlLWdhdXJkcy0xODQwNzQ3Zi5qcyc7XG5pbXBvcnQgeyBVIGFzIFVJRGVmYXVsdHMgfSBmcm9tICcuL3VpLXV0aWxzLTkyOGE0MDk2LmpzJztcbmltcG9ydCAnQGFyY2dpcy9jb3JlL2lkZW50aXR5L0lkZW50aXR5TWFuYWdlci5qcyc7XG5pbXBvcnQgJ0BhcmNnaXMvY29yZS9jb3JlL3VybFV0aWxzLmpzJztcbmltcG9ydCAnQGFyY2dpcy9jb3JlL2xheWVycy9MYXllci5qcyc7XG5pbXBvcnQgJ0BhcmNnaXMvY29yZS9sYXllcnMvSW1hZ2VyeUxheWVyLmpzJztcbmltcG9ydCAnQGFyY2dpcy9jb3JlL3NtYXJ0TWFwcGluZy9yYXN0ZXIvcmVuZGVyZXJzL3N0cmV0Y2guanMnO1xuaW1wb3J0ICdAYXJjZ2lzL2NvcmUvcmVxdWVzdC5qcyc7XG5pbXBvcnQgJ0BhcmNnaXMvY29yZS9yZXN0L3N1cHBvcnQvQWxnb3JpdGhtaWNDb2xvclJhbXAuanMnO1xuaW1wb3J0ICdAYXJjZ2lzL2NvcmUvcmVzdC9zdXBwb3J0L011bHRpcGFydENvbG9yUmFtcC5qcyc7XG5pbXBvcnQgJ0BhcmNnaXMvY29yZS9Db2xvci5qcyc7XG5pbXBvcnQgJy4vY29sb3JSYW1wVXRpbHMtOGJkZDQ2YzUuanMnO1xuaW1wb3J0ICdAYXJjZ2lzL2NvcmUvcmVzdC9nZW9wcm9jZXNzb3IuanMnO1xuaW1wb3J0ICdAYXJjZ2lzL2NvcmUvcG9ydGFsL1BvcnRhbEl0ZW0uanMnO1xuaW1wb3J0IHsgbSBhcyBtdWx0aWRpbWVuc2lvbmFsRGVmaW5pdGlvblBhcnNlciwgYyBhcyBjbG9uZURhdGEgfSBmcm9tICcuL211bHRpZGltZW5zaW9uYWwtaGVscGVyLWZjOGZiZTBlLmpzJztcblxuY29uc3QgSGVscENsaWNrSGFuZGxlcktleXMgPSB7XG4gICAgaW5wdXRBcmdIZWxwQ2xpY2tIYW5kbGVyOiBcImlucHV0QXJnSGVscENsaWNrSGFuZGxlclwiXG59O1xuXG5jb25zdCByZnhDdGVEaW1lbnNpb25sZXNzRWRpdG9yQ3NzID0gXCJcIjtcblxuY29uc3QgUmZ4Q3RlRGltZW5zaW9ubGVzc0VkaXRvciA9IGNsYXNzIHtcbiAgICBjb25zdHJ1Y3Rvcihob3N0UmVmKSB7XG4gICAgICAgIHJlZ2lzdGVySW5zdGFuY2UodGhpcywgaG9zdFJlZik7XG4gICAgICAgIHRoaXMucmZ4QXJndW1lbnRDaGFuZ2UgPSBjcmVhdGVFdmVudCh0aGlzLCBcInJmeEFyZ3VtZW50Q2hhbmdlXCIsIDcpO1xuICAgICAgICB0aGlzLnNob3dEaW1lbnNpb25MZXNzQ2hlY2tib3ggPSB0cnVlO1xuICAgICAgICAvKipcbiAgICAgICAgICogU3RvcmVzIGV2ZW50IGhhbmRsZXJzIGZvciBoZWxwIGFjdGlvbiBjbGljaywgc3RvcmVkIGluIGNvbm5lY3RlZCBjYWxsYmFjayB0byBhdm9pZFxuICAgICAgICAgKiBmZXRjaGluZyBmdW5jdGlvbiBvbiBlYWNoIHJlbmRlciAoIHRvIGF2b2lkIGNvbW1vbiBiYWQgcHJhY3RpY2UgKVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5oZWxwQWN0aW9uQ2xpY2tFdmVudEhhbmRsZXJzID0gbmV3IE1hcCgpO1xuICAgICAgICAvKipcbiAgICAgICAgICogZnVuY3Rpb24gdG8gaGFuZGxlIHJhc3RlciBjaGFuZ2VcbiAgICAgICAgICogY2hlY2sgaWYgbGF5ZXIgaGFzIG9ubHkgMSB2YXJpYWJsZSAmIGFsbCBkaW1lbnNpb25zIGhhdmUgMSB2YWx1ZVxuICAgICAgICAgKiBpZiBzbywgc2hvdyBkaW1lbnNpb25sZXNzIGFyZ1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5ldmFsdWF0ZUZpbHRlclRyaWdnZXJBcmcgPSBhc3luYyAoZGF0YSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbWRpbURlZkxlYWRzVG9TaW5nbGVTbGljZSA9IGF3YWl0IHRoaXMuaXNNdWx0aWRpbWVuc2lvbmFsRGVmaW5pdGlvbkFwcGxpZWRTaW5nbGVTbGljZShkYXRhKTtcbiAgICAgICAgICAgIC8vIGEgcmVzZXQgaXMgZG9uZSBhcyBzb21ldGltZXMgdGhlIHZhbHVlIGRvZXNuJ3QgY2hhbmdlIGJ1dCBhIHJlcmVuZGVyIGlzIG5lY2Vzc2FyeVxuICAgICAgICAgICAgdGhpcy5tZGltRGVmTGVhZHNUb1NpbmdsZVNsaWNlID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdGhpcy5tZGltRGVmTGVhZHNUb1NpbmdsZVNsaWNlID0gbWRpbURlZkxlYWRzVG9TaW5nbGVTbGljZTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5ldmFsdWF0ZVJhc3RlclRyaWdnZXJBcmcgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCByYXN0ZXJUcmlnZ2VyQXJnID0gdGhpcy53aWRnZXRBcmdzLnRyaWdnZXJBcmdzLlJhc3RlcjtcbiAgICAgICAgICAgIGNvbnN0IGlucHV0V2lkZ2V0ID0gcmFzdGVyVHJpZ2dlckFyZz8uaW5wdXQ7XG4gICAgICAgICAgICBjb25zdCBsYXllciA9IGF3YWl0IGlucHV0V2lkZ2V0LmdldFNlbGVjdGVkTGF5ZXIoKTtcbiAgICAgICAgICAgIGlmIChsYXllcikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGlzUmFzdGVyU2luZ2xlU2xpY2UgPSB0aGlzLmNoZWNrSWZSYXN0ZXJJc1NpbmdsZVNsaWNlKGxheWVyKTtcbiAgICAgICAgICAgICAgICB0aGlzLmlzUmFzdGVyU2luZ2xlU2xpY2UgPSBpc1Jhc3RlclNpbmdsZVNsaWNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gaGFuZGxlcyBjYXNlIHdoZXJlIHRoZSByYXN0ZXIgaXMgcmVtb3ZlZC5cbiAgICAgICAgICAgICAgICB0aGlzLm1kaW1EZWZMZWFkc1RvU2luZ2xlU2xpY2UgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5pc1Jhc3RlclNpbmdsZVNsaWNlID0gZmFsc2U7XG4gICAgICAgIHRoaXMubWRpbURlZkxlYWRzVG9TaW5nbGVTbGljZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLndpZGdldEFyZ3MgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvL1xuICAgIC8vICBMaWZlY3ljbGVcbiAgICAvL1xuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICAgICAgdGhpcy5wcm9jZXNzV2lkZ2V0QXJncyh0aGlzLndpZGdldEFyZ3MpO1xuICAgIH1cbiAgICBhc3luYyBjb21wb25lbnRXaWxsTG9hZCgpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5zZXR1cEluaXRpYWxTdGF0ZSh0aGlzLndpZGdldEFyZ3MpO1xuICAgIH1cbiAgICBjb21wb25lbnRXaWxsUmVuZGVyKCkge1xuICAgICAgICBjb25zdCBpc1NpbmdsZVNsaWNlID0gdGhpcy5pc1Jhc3RlclNpbmdsZVNsaWNlIHx8IHRoaXMubWRpbURlZkxlYWRzVG9TaW5nbGVTbGljZTtcbiAgICAgICAgY29uc3QgaW5wdXQgPSB0aGlzLndpZGdldEFyZ3MudHJpZ2dlckFyZ3MuUmFzdGVyPy5pbnB1dDtcbiAgICAgICAgY29uc3QgaXNWYWx1ZVByZXNlbnQgPSBCb29sZWFuKGlucHV0Py52YWx1ZSk7XG4gICAgICAgIC8vIElmIG5vIGlucHV0IFwidW5jaGVja1wiIGNoZWNrYm94IGFuZCBzaG93IFVJXG4gICAgICAgIGNvbnN0IHNob3dEaW1lbnNpb25MZXNzQ2hlY2tib3ggPSBpc1ZhbHVlUHJlc2VudCA9PT0gZmFsc2UgfHwgaXNTaW5nbGVTbGljZTtcbiAgICAgICAgdGhpcy5zaG93RGltZW5zaW9uTGVzc0NoZWNrYm94ID0gc2hvd0RpbWVuc2lvbkxlc3NDaGVja2JveDtcbiAgICB9XG4gICAgY29tcG9uZW50RGlkTG9hZCgpIHtcbiAgICAgICAgdGhpcy5hdHRhY2hIZWxwQ2xpY2tFdmVudEhhbmRsZXJzKCk7XG4gICAgfVxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvL1xuICAgIC8vICBQcml2YXRlIE1ldGhvZHNcbiAgICAvL1xuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvKipcbiAgICAgKiBBbGwgdmFsaWRhdGlvbiBsb2dpYyBvZiB3aWRnZXRBcmdzIC0+IG1haW5seSB0aGUgaW5wdXRBcmdzIGFuZCB0cmlnZ2VyQXR0cmlidXRlc1xuICAgICAqIGdvZXMgaGVyZVxuICAgICAqL1xuICAgIHByb2Nlc3NXaWRnZXRBcmdzKHsgaW5wdXRBcmdzLCB0cmlnZ2VyQXJncyB9KSB7XG4gICAgICAgIC8vIHNob3VsZCBoYXZlIG9ubHkgb25lIGlucHV0QXJnXG4gICAgICAgIE9iamVjdC5rZXlzKGlucHV0QXJncykuZm9yRWFjaCgoX2lucHV0QXJnKSA9PiB7XG4gICAgICAgICAgICBjb25zdCByZnhBcmcgPSBpbnB1dEFyZ3NbX2lucHV0QXJnXTtcbiAgICAgICAgICAgIHRoaXMuaW5wdXRBcmcgPSByZnhBcmc7XG4gICAgICAgICAgICByZnhBcmcuaW5wdXQgPSB0aGlzLmhvc3RFbGVtZW50O1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gaGFzIDIgdHJpZ2dlciBhcmdzXG4gICAgICAgIGNvbnN0IHJhc3RlclRyaWdnZXJBcmcgPSB0cmlnZ2VyQXJncy5SYXN0ZXI7XG4gICAgICAgIHJhc3RlclRyaWdnZXJBcmc/LmlucHV0Py5hZGRFdmVudExpc3RlbmVyKFwicmZ4QXJndW1lbnRDaGFuZ2VcIiwgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5ldmFsdWF0ZVJhc3RlclRyaWdnZXJBcmcoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGZpbHRlclRyaWdnZXJBcmcgPSB0cmlnZ2VyQXJncy5GaWx0ZXI7XG4gICAgICAgIGZpbHRlclRyaWdnZXJBcmc/LmlucHV0Py5hZGRFdmVudExpc3RlbmVyKFwicmZ4QXJndW1lbnRDaGFuZ2VcIiwgKHsgZGV0YWlsOiB7IHZhbHVlIH0gfSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5ldmFsdWF0ZUZpbHRlclRyaWdnZXJBcmcodmFsdWUpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgc2V0dXBJbml0aWFsU3RhdGUoeyB0cmlnZ2VyQXJncyB9KSB7XG4gICAgICAgIGNvbnN0IGlucHV0ID0gdHJpZ2dlckFyZ3MuUmFzdGVyPy5pbnB1dDtcbiAgICAgICAgaWYgKCFpbnB1dCB8fCAhaW5wdXQudmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuaXNSYXN0ZXJTaW5nbGVTbGljZSA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5tZGltRGVmTGVhZHNUb1NpbmdsZVNsaWNlID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgdGhpcy5ldmFsdWF0ZVJhc3RlclRyaWdnZXJBcmcoKTtcbiAgICAgICAgLy8gY2hlY2sgYW5kIHNldCBpZiBmaWx0ZXIgY29uZmlnIGxlYWRzIHRvIHNpbmdsZSBzbGljZVxuICAgICAgICBjb25zdCBmaWx0ZXJJbnB1dCA9IHRyaWdnZXJBcmdzLkZpbHRlcj8uaW5wdXQ7XG4gICAgICAgIGNvbnN0IGZpbHRlclZhbHVlID0gZmlsdGVySW5wdXQudmFsdWUgfHwgdHJpZ2dlckFyZ3MuRmlsdGVyLnZhbHVlO1xuICAgICAgICBpZiAoIWZpbHRlcklucHV0IHx8ICFmaWx0ZXJWYWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5tZGltRGVmTGVhZHNUb1NpbmdsZVNsaWNlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmV2YWx1YXRlRmlsdGVyVHJpZ2dlckFyZyhmaWx0ZXJWYWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXR0YWNoSGVscENsaWNrRXZlbnRIYW5kbGVycygpIHtcbiAgICAgICAgY29uc3QgaW5wdXRBcmdIZWxwQ2xpY2tIYW5kbGVyID0gdGhpcy53aWRnZXRBcmdzLm9uSGVscEFjdGlvbkNsaWNrKHtcbiAgICAgICAgICAgIGhlYWRpbmc6IHRoaXMuaW5wdXRBcmcuZGlzcGxheU5hbWUsXG4gICAgICAgICAgICByZWZlcmVuY2VFbGVtZW50OiB0aGlzLndpZGdldENvbnRhaW5lcixcbiAgICAgICAgICAgIGhlbHBUZXh0SUQ6IHRoaXMuaW5wdXRBcmc/LmhlbHBUZXh0SURcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuaGVscEFjdGlvbkNsaWNrRXZlbnRIYW5kbGVycy5zZXQoSGVscENsaWNrSGFuZGxlcktleXMuaW5wdXRBcmdIZWxwQ2xpY2tIYW5kbGVyLCBpbnB1dEFyZ0hlbHBDbGlja0hhbmRsZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBmdW5jdGlvbiB0byBjaGVjayBpZiByYXN0ZXIgbGF5ZXIgaXMgYSBzaW5nbGUgc2xpY2VcbiAgICAgKiBtZWFuaW5nIGl0IGhhcyBvbmx5IDEgdmFyaWFibGUgYW5kIGVhY2ggZGltZW5zaW9uIGhhcyBvbmx5IDEgdmFsdWVcbiAgICAgKiBAcGFyYW0ge1Jhc3RlckxheWVyfSBsYXllclxuICAgICAqIEByZXR1cm5zIGJvb2xlYW5cbiAgICAgKi9cbiAgICBjaGVja0lmUmFzdGVySXNTaW5nbGVTbGljZShsYXllcikge1xuICAgICAgICBjb25zdCBtdWx0aWRpbWVuc2lvbmFsSW5mbyA9IGxheWVyLm11bHRpZGltZW5zaW9uYWxJbmZvO1xuICAgICAgICBjb25zdCBtRGltVmFyaWFibGVzID0gbXVsdGlkaW1lbnNpb25hbEluZm8gJiYgbXVsdGlkaW1lbnNpb25hbEluZm8udmFyaWFibGVzO1xuICAgICAgICBpZiAoIW11bHRpZGltZW5zaW9uYWxJbmZvIHx8ICFtRGltVmFyaWFibGVzIHx8IG1EaW1WYXJpYWJsZXMubGVuZ3RoICE9PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbURpbVZhcmlhYmxlRGltZW5zaW9ucyA9IG1EaW1WYXJpYWJsZXNbMF0uZGltZW5zaW9ucztcbiAgICAgICAgLy8gaXRlcmF0ZSBvdmVyIGVhY2ggZGltZW5zaW9uIGFuZCB2ZXJpZnkgZWFjaCBkaW1lbnNpb24gaGFzIHNpbmdsZSB2YWx1ZS5cbiAgICAgICAgY29uc3QgZGltZW5zaW9uc0hhdmVTaW5nbGVWYWx1ZSA9IG1EaW1WYXJpYWJsZURpbWVuc2lvbnMuZXZlcnkoKGRpbWVuc2lvbikgPT4ge1xuICAgICAgICAgICAgY29uc3QgZGltZW5zaW9uVmFsdWVzID0gZGltZW5zaW9uICYmIGRpbWVuc2lvbi52YWx1ZXM7XG4gICAgICAgICAgICByZXR1cm4gZGltZW5zaW9uVmFsdWVzICYmIGRpbWVuc2lvblZhbHVlcy5sZW5ndGggPT09IDE7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZGltZW5zaW9uc0hhdmVTaW5nbGVWYWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRnVuY3Rpb24gaXMgcmVzcG9uc2libGUgdG8gZmluZCB3aGV0aGVyIHRoZSBkZWZpbml0aW9uXG4gICAgICogbGVhZHMgdG8gYSBzaW5nbGUgc2xpY2VcbiAgICAgKiBAcGFyYW0ge30gbWRpbURlZmluaXRpb25cbiAgICAgKiByZXR1cm5zIGJvb2xlYW5cbiAgICAgKi9cbiAgICBhc3luYyBpc011bHRpZGltZW5zaW9uYWxEZWZpbml0aW9uQXBwbGllZFNpbmdsZVNsaWNlKG1kaW1EZWZpbml0aW9uKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbWRpbURlZmluaXRpb24gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIG1kaW1EZWZpbml0aW9uID0gSlNPTi5wYXJzZShtZGltRGVmaW5pdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaW5wdXQgPSB0aGlzLndpZGdldEFyZ3MudHJpZ2dlckFyZ3MuUmFzdGVyPy5pbnB1dDtcbiAgICAgICAgaWYgKCFpbnB1dC52YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxheWVyID0gYXdhaXQgaW5wdXQuZ2V0U2VsZWN0ZWRMYXllcigpO1xuICAgICAgICBpZiAoaXNFbXB0eURhdGFJdGVtKGxheWVyKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG11dGxpZGltZW5zaW9uYWxJbmZvID0gbGF5ZXIudHlwZSA9PT0gXCJpbWFnZXJ5LXRpbGVcIlxuICAgICAgICAgICAgPyBsYXllci5yYXN0ZXJJbmZvLm11bHRpZGltZW5zaW9uYWxJbmZvXG4gICAgICAgICAgICA6IGxheWVyLm11bHRpZGltZW5zaW9uYWxJbmZvO1xuICAgICAgICBjb25zdCBpc011bHRpZGltZW5zaW9uYWxEZWZpbml0aW9uQXBwbGllZFNpbmdsZVNsaWNlID0gbXVsdGlkaW1lbnNpb25hbERlZmluaXRpb25QYXJzZXIobWRpbURlZmluaXRpb24sIGNsb25lRGF0YShtdXRsaWRpbWVuc2lvbmFsSW5mbykpO1xuICAgICAgICByZXR1cm4gaXNNdWx0aWRpbWVuc2lvbmFsRGVmaW5pdGlvbkFwcGxpZWRTaW5nbGVTbGljZTtcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICByZXR1cm4gKGgoXCJkaXZcIiwgbnVsbCwgdGhpcy5zaG93RGltZW5zaW9uTGVzc0NoZWNrYm94ID8gKGgoXCJjYWxjaXRlLWxhYmVsXCIsIHsgYWxpZ25tZW50OiBcInN0YXJ0XCIsIHNjYWxlOiBVSURlZmF1bHRzLlNjYWxlLCBsYXlvdXQ6IFwiaW5saW5lLXNwYWNlLWJldHdlZW5cIiwgcmVmOiAoZSkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMud2lkZ2V0Q29udGFpbmVyID0gZTtcbiAgICAgICAgICAgIH0gfSwgaChcImNhbGNpdGUtY2hlY2tib3hcIiwgeyBjaGVja2VkOiB0aGlzLmlucHV0QXJnLnZhbHVlLCBvbkNhbGNpdGVDaGVja2JveENoYW5nZTogKGUpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBlbGVtZW50ID0gZS50YXJnZXQ7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBlbGVtZW50LmNoZWNrZWQ7XG4gICAgICAgICAgICAgICAgdGhpcy5pbnB1dEFyZy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgfSB9KSwgaChcInJmeC1sYWJlbFwiLCB7IGxhYmVsOiB0aGlzLmlucHV0QXJnLmRpc3BsYXlOYW1lLCBvblJmeExhYmVsSGVscEFjdGlvbkNsaWNrOiAoKSA9PiB0aGlzLmhlbHBBY3Rpb25DbGlja0V2ZW50SGFuZGxlcnM/LmdldChIZWxwQ2xpY2tIYW5kbGVyS2V5cy5pbnB1dEFyZ0hlbHBDbGlja0hhbmRsZXIpKCkgfSkpKSA6IG51bGwpKTtcbiAgICB9XG4gICAgZ2V0IGhvc3RFbGVtZW50KCkgeyByZXR1cm4gZ2V0RWxlbWVudCh0aGlzKTsgfVxufTtcblJmeEN0ZURpbWVuc2lvbmxlc3NFZGl0b3Iuc3R5bGUgPSByZnhDdGVEaW1lbnNpb25sZXNzRWRpdG9yQ3NzO1xuXG5leHBvcnQgeyBSZnhDdGVEaW1lbnNpb25sZXNzRWRpdG9yIGFzIFIgfTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmZ4LWN0ZS1kaW1lbnNpb25sZXNzLWVkaXRvci0wN2QzODVmMy5qcy5tYXAiLCJleHBvcnQgeyBSIGFzIHJmeF9jdGVfZGltZW5zaW9ubGVzc19lZGl0b3IgfSBmcm9tICcuL3JmeC1jdGUtZGltZW5zaW9ubGVzcy1lZGl0b3ItMDdkMzg1ZjMuanMnO1xuaW1wb3J0ICcuL2luZGV4LWRhMWI3MTM4LmpzJztcbmltcG9ydCAnQGFyY2dpcy9jb3JlL2NvcmUvbGFuZy5qcyc7XG5pbXBvcnQgJy4vdHlwZS1nYXVyZHMtMTg0MDc0N2YuanMnO1xuaW1wb3J0ICcuL19nZXRUYWctOTZhZjAyOWQuanMnO1xuaW1wb3J0ICcuL3VpLXV0aWxzLTkyOGE0MDk2LmpzJztcbmltcG9ydCAnQGFyY2dpcy9jb3JlL2lkZW50aXR5L0lkZW50aXR5TWFuYWdlci5qcyc7XG5pbXBvcnQgJ0BhcmNnaXMvY29yZS9jb3JlL3VybFV0aWxzLmpzJztcbmltcG9ydCAnQGFyY2dpcy9jb3JlL2xheWVycy9MYXllci5qcyc7XG5pbXBvcnQgJ0BhcmNnaXMvY29yZS9sYXllcnMvSW1hZ2VyeUxheWVyLmpzJztcbmltcG9ydCAnQGFyY2dpcy9jb3JlL3NtYXJ0TWFwcGluZy9yYXN0ZXIvcmVuZGVyZXJzL3N0cmV0Y2guanMnO1xuaW1wb3J0ICdAYXJjZ2lzL2NvcmUvcmVxdWVzdC5qcyc7XG5pbXBvcnQgJ0BhcmNnaXMvY29yZS9yZXN0L3N1cHBvcnQvQWxnb3JpdGhtaWNDb2xvclJhbXAuanMnO1xuaW1wb3J0ICdAYXJjZ2lzL2NvcmUvcmVzdC9zdXBwb3J0L011bHRpcGFydENvbG9yUmFtcC5qcyc7XG5pbXBvcnQgJ0BhcmNnaXMvY29yZS9Db2xvci5qcyc7XG5pbXBvcnQgJy4vY29sb3JSYW1wVXRpbHMtOGJkZDQ2YzUuanMnO1xuaW1wb3J0ICdAYXJjZ2lzL2NvcmUvcmVzdC9nZW9wcm9jZXNzb3IuanMnO1xuaW1wb3J0ICdAYXJjZ2lzL2NvcmUvcG9ydGFsL1BvcnRhbEl0ZW0uanMnO1xuaW1wb3J0ICcuL211bHRpZGltZW5zaW9uYWwtaGVscGVyLWZjOGZiZTBlLmpzJztcbmltcG9ydCAnLi9fVWludDhBcnJheS02OGUxZTNmOS5qcyc7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJmeC1jdGUtZGltZW5zaW9ubGVzcy1lZGl0b3IuZW50cnkuanMubWFwIiwiaW1wb3J0IHsgaSBhcyBpc0FycmF5TGlrZSwgYSBhcyBpc0FycmF5LCBiIGFzIGlzQnVmZmVyLCBjIGFzIGlzVHlwZWRBcnJheSwgZCBhcyBpc0FyZ3VtZW50cywgZyBhcyBnZXRUYWcsIGUgYXMgaXNQcm90b3R5cGUsIGYgYXMgYmFzZUtleXMsIGggYXMgaXNQbGFpbk9iamVjdCB9IGZyb20gJy4vX2dldFRhZy05NmFmMDI5ZC5qcyc7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBtYXBUYWcgPSAnW29iamVjdCBNYXBdJyxcbiAgICBzZXRUYWcgPSAnW29iamVjdCBTZXRdJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhbiBlbXB0eSBvYmplY3QsIGNvbGxlY3Rpb24sIG1hcCwgb3Igc2V0LlxuICpcbiAqIE9iamVjdHMgYXJlIGNvbnNpZGVyZWQgZW1wdHkgaWYgdGhleSBoYXZlIG5vIG93biBlbnVtZXJhYmxlIHN0cmluZyBrZXllZFxuICogcHJvcGVydGllcy5cbiAqXG4gKiBBcnJheS1saWtlIHZhbHVlcyBzdWNoIGFzIGBhcmd1bWVudHNgIG9iamVjdHMsIGFycmF5cywgYnVmZmVycywgc3RyaW5ncywgb3JcbiAqIGpRdWVyeS1saWtlIGNvbGxlY3Rpb25zIGFyZSBjb25zaWRlcmVkIGVtcHR5IGlmIHRoZXkgaGF2ZSBhIGBsZW5ndGhgIG9mIGAwYC5cbiAqIFNpbWlsYXJseSwgbWFwcyBhbmQgc2V0cyBhcmUgY29uc2lkZXJlZCBlbXB0eSBpZiB0aGV5IGhhdmUgYSBgc2l6ZWAgb2YgYDBgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGVtcHR5LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNFbXB0eShudWxsKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzRW1wdHkodHJ1ZSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0VtcHR5KDEpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNFbXB0eShbMSwgMiwgM10pO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzRW1wdHkoeyAnYSc6IDEgfSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0VtcHR5KHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKGlzQXJyYXlMaWtlKHZhbHVlKSAmJlxuICAgICAgKGlzQXJyYXkodmFsdWUpIHx8IHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJyB8fCB0eXBlb2YgdmFsdWUuc3BsaWNlID09ICdmdW5jdGlvbicgfHxcbiAgICAgICAgaXNCdWZmZXIodmFsdWUpIHx8IGlzVHlwZWRBcnJheSh2YWx1ZSkgfHwgaXNBcmd1bWVudHModmFsdWUpKSkge1xuICAgIHJldHVybiAhdmFsdWUubGVuZ3RoO1xuICB9XG4gIHZhciB0YWcgPSBnZXRUYWcodmFsdWUpO1xuICBpZiAodGFnID09IG1hcFRhZyB8fCB0YWcgPT0gc2V0VGFnKSB7XG4gICAgcmV0dXJuICF2YWx1ZS5zaXplO1xuICB9XG4gIGlmIChpc1Byb3RvdHlwZSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gIWJhc2VLZXlzKHZhbHVlKS5sZW5ndGg7XG4gIH1cbiAgZm9yICh2YXIga2V5IGluIHZhbHVlKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIGtleSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbmNvbnN0IFJGVF9UWVBFID0gXCJSYXN0ZXJGdW5jdGlvblRlbXBsYXRlXCI7XG5jb25zdCBUWVBFX0tFWVdPUkQgPSBcInR5cGVcIjtcbmNvbnN0IFJGVl9UWVBFID0gXCJSYXN0ZXJGdW5jdGlvblZhcmlhYmxlXCI7XG5jb25zdCBBUkdTX0tFWVdPUkQgPSBcImFyZ3VtZW50c1wiO1xuY29uc3QgRlVOQ1RJT05fS0VZV09SRCA9IFwiZnVuY3Rpb25cIjtcbmZ1bmN0aW9uIGlzUmVmZXJlbmNlZE9iamVjdChvYmopIHtcbiAgICBpZiAoIW9iaikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChvYmouX29iamVjdF9yZWZfaWQgIT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gaXNOdW1iZXIoeCkge1xuICAgIHggPSBTdHJpbmcoeCkudHJpbSgpO1xuICAgIGlmICh4ID09PSBcIlwiKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIC9eWystXT8oXFxkKyk/KFxcLlxcZCspPyQvLnRlc3QoeCk7XG59XG5mdW5jdGlvbiBpc1dpZGdldFZhbHVlQm9vbGVhbih4KSB7XG4gICAgeCA9IFN0cmluZyh4KS50cmltKCk7XG4gICAgcmV0dXJuIFtcInRydWVcIiwgXCJmYWxzZVwiXS5pbmRleE9mKHgpID49IDA7XG59XG5mdW5jdGlvbiBpc0NvbG9yUmFtcChyZnhBcmcpIHtcbiAgICBpZiAoIXJmeEFyZykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChyZnhBcmcudHlwZSAmJiByZnhBcmcudHlwZS50b0xvd2VyQ2FzZSgpLmluZGV4T2YoXCJjb2xvcnJhbXBcIikgPj0gMCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHJmeEFyZy52YWx1ZSAmJiByZnhBcmcudmFsdWUudHlwZSAmJiByZnhBcmcudmFsdWUudHlwZS50b0xvd2VyQ2FzZSgpLmluZGV4T2YoXCJjb2xvcnJhbXBcIikgPj0gMCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gaXNSZWNvcmRTZXQocmZ4QXJnKSB7XG4gICAgcmV0dXJuIHJmeEFyZy50eXBlICYmIHJmeEFyZy50eXBlLnRvTG93ZXJDYXNlKCkuaW5kZXhPZihcInJlY29yZHNldFwiKSA+PSAwO1xufVxuLyoqXG4gKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIGdpdmVuIFJGVCBlbGVtZW50IGlzIGFuIFJGeCBhcmd1bWVudC5cbiAqXG4gKiBAcGFyYW0ge2FueX0gcmZ0RWxlbWVudCAtIFRoZSBSRlQgZWxlbWVudCB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBgdHJ1ZWAgaWYgdGhlIGdpdmVuIGVsZW1lbnQgaXMgUmFzdGVyRnVuY3Rpb25UZW1wbGF0ZSxcbiAqIFJhc3RlckZ1bmN0aW9uVmFyaWFibGUsIGlzQ29sb3JSYW1wLCBpc1JlY29yZFNldDsgYGZhbHNlYCBvdGhlcndpc2UuXG4gKi9cbmZ1bmN0aW9uIGlzUkZ4QXJnKHJmdEVsZW1lbnQpIHtcbiAgICBpZiAoIXJmdEVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCB0eXBlID0gcmZ0RWxlbWVudC50eXBlO1xuICAgIHJldHVybiBbUkZUX1RZUEUsIFJGVl9UWVBFXS5pbmRleE9mKHR5cGUpID49IDAgfHwgaXNDb2xvclJhbXAocmZ0RWxlbWVudCkgfHwgaXNSZWNvcmRTZXQocmZ0RWxlbWVudCk7XG59XG4vKipcbiAqIERldGVybWluZXMgaWYgdGhlIGlucHV0IGlzIGEgRmVhdHVyZUxheWVyXG4gKiBAcGFyYW0ge19fZXNyaS5MYXllcn0gbGF5ZXIgdGhlIGxheWVyIHRvIGNoZWNrIHRoZSB0eXBlIG9mXG4gKiBAcmV0dXJucyB7bGF5ZXIgaXMgX19lc3JpLkZlYXR1cmVMYXllcn0gbGF5ZXIgaXMgYSBGZWF0dXJlTGF5ZXJcbiAqL1xuZnVuY3Rpb24gaXNGZWF0dXJlTGF5ZXIobGF5ZXIpIHtcbiAgICByZXR1cm4gbGF5ZXIudHlwZSA9PT0gXCJmZWF0dXJlXCI7XG59XG4vKipcbiAqIERldGVybWluZXMgaWYgdGhlIGlucHV0IGlzIGEgVGlsZUxheWVyXG4gKiBAcGFyYW0ge19fZXNyaS5MYXllcn0gbGF5ZXIgdGhlIGxheWVyIHRvIGNoZWNrIHRoZSB0eXBlIG9mXG4gKiBAcmV0dXJucyB7bGF5ZXIgaXMgX19lc3JpLlRpbGVMYXllcn0gbGF5ZXIgaXMgYSBUaWxlTGF5ZXJcbiAqL1xuZnVuY3Rpb24gaXNUaWxlTGF5ZXIobGF5ZXIpIHtcbiAgICByZXR1cm4gbGF5ZXIudHlwZSA9PT0gXCJ0aWxlXCI7XG59XG4vKipcbiAqIERldGVybWluZXMgaWYgdGhlIGlucHV0IGlzIGEgSW1hZ2VyeVRpbGVMYXllclxuICogQHBhcmFtIHtfX2VzcmkuTGF5ZXJ9IGxheWVyIHRoZSBsYXllciB0byBjaGVjayB0aGUgdHlwZSBvZlxuICogQHJldHVybnMge2xheWVyIGlzIF9fZXNyaS5JbWFnZXJ5TGF5ZXJ9IGxheWVyIGlzIGEgSW1hZ2VyeUxheWVyXG4gKi9cbmZ1bmN0aW9uIGlzRHluYW1pY0ltYWdlcnlMYXllcihsYXllcikge1xuICAgIHJldHVybiAobGF5ZXIudHlwZSA9PT0gXCJpbWFnZXJ5LXRpbGVcIiAmJlxuICAgICAgICBsYXllci5zb3VyY2VKU09OLmNhcGFiaWxpdGllcy50b0xvd2VyQ2FzZSgpLmluZGV4T2YoXCJ0aWxlc29ubHlcIikgPCAwKTtcbn1cbi8qKlxuICogRGV0ZXJtaW5lcyBpZiB0aGUgaW5wdXQgaXMgYSBJbWFnZXJ5TGF5ZXJcbiAqIEBwYXJhbSB7X19lc3JpLkxheWVyfSBsYXllciB0aGUgbGF5ZXIgdG8gY2hlY2sgdGhlIHR5cGUgb2ZcbiAqIEByZXR1cm5zIHtsYXllciBpcyBfX2VzcmkuSW1hZ2VyeUxheWVyfSBsYXllciBpcyBhIEltYWdlcnlMYXllclxuICovXG5mdW5jdGlvbiBpc0ltYWdlcnlMYXllcihsYXllcikge1xuICAgIHJldHVybiBsYXllci50eXBlID09PSBcImltYWdlcnlcIiB8fCBpc0R5bmFtaWNJbWFnZXJ5TGF5ZXIobGF5ZXIpO1xufVxuLyoqXG4gKiBEZXRlcm1pbmVzIGlmIHRoZSBpbnB1dCBpcyBhIEltYWdlcnlUaWxlTGF5ZXJcbiAqIEBwYXJhbSB7X19lc3JpLkxheWVyfSBsYXllciB0aGUgbGF5ZXIgdG8gY2hlY2sgdGhlIHR5cGUgb2ZcbiAqIEByZXR1cm5zIHtsYXllciBpcyBfX2VzcmkuSW1hZ2VyeVRpbGVMYXllcn0gbGF5ZXIgaXMgYSBJbWFnZXJ5VGlsZUxheWVyXG4gKi9cbmZ1bmN0aW9uIGlzSW1hZ2VyeVRpbGVMYXllcihsYXllcikge1xuICAgIHJldHVybiBsYXllci50eXBlID09PSBcImltYWdlcnktdGlsZVwiICYmICFpc0R5bmFtaWNJbWFnZXJ5TGF5ZXIobGF5ZXIpO1xufVxuZnVuY3Rpb24gaXNFdmVyeVByb3BlcnR5RW1wdHkodmFsdWUpIHtcbiAgICBsZXQgaXNBbGxQcm9wc0VtcHR5ID0gdHJ1ZTtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmIGlzQXJyYXkodmFsdWUpID09PSBmYWxzZSkge1xuICAgICAgICAvLyB1c2luZyBmb3ItaW4gYXMgaXQgd2lsbCB3b3JrIHdpdGggb2JqZWN0cyB3aXRoIHByb3BlcnRpZXMgdGhhdCBzZXQgdmlhIGFjY2Vzc29ycyBhcyB3ZWxsXG4gICAgICAgIGZvciAoY29uc3QgcHJvcCBpbiB2YWx1ZSkge1xuICAgICAgICAgICAgLy8gVGhpcyB3aWxsIHRlbGwgdGhlIFR5cGVTY3JpcHQgY29tcGlsZXIgdGhhdCB0aGUgb2JqIG9iamVjdCBoYXMgYSBzdHJpbmcgaW5kZXggc2lnbmF0dXJlLFxuICAgICAgICAgICAgLy8gYW5kIHdpbGwgYWxsb3cgdG8gYWNjZXNzIGl0cyBwcm9wZXJ0aWVzIHVzaW5nIGEgc3RyaW5nIGluZGV4IHdpdGhvdXQgZ2V0dGluZyB0aGUgXCJFbGVtZW50IGltcGxpY2l0bHkgaGFzIGFuICdhbnknIHR5cGVcIiBlcnJvci5cbiAgICAgICAgICAgIGNvbnN0IHByb3BWYWx1ZSA9IHZhbHVlPy5bcHJvcF07XG4gICAgICAgICAgICBpZiAodmFsdWUuaGFzT3duUHJvcGVydHkocHJvcCkgPT09IHRydWUgJiYgcHJvcFZhbHVlICE9PSB1bmRlZmluZWQgJiYgcHJvcFZhbHVlICE9PSBudWxsICYmIHByb3BWYWx1ZSAhPT0gXCJcIikge1xuICAgICAgICAgICAgICAgIGlzQWxsUHJvcHNFbXB0eSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBpc0FsbFByb3BzRW1wdHk7XG59XG4vKipcbiAqIENoZWNrIGZvciBhbiBlbXB0eSB2YWx1ZSBmb3IgZGF0YSBpdGVtcyBsaWtlIEdQU3RyaW5nIGFuZCBGaWVsZC5cbiAqIEBwYXJhbSB2YWx1ZSBkYXRhIGl0ZW0gdmFsdWUuXG4gKiBAcmV0dXJucyB3aGV0aGVyIHRoZSB2YWx1ZSBpcyBjb25zaWRlcmVkIGVtcHR5LlxuICovXG5mdW5jdGlvbiBpc0VtcHR5RGF0YUl0ZW0odmFsdWUpIHtcbiAgICByZXR1cm4gKHZhbHVlID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgdmFsdWUgPT09IG51bGwgfHxcbiAgICAgICAgLy8gc2luZ2xlLXNlbGVjdCwgXCJcIiBpcyBhIHNwZWNpYWwgY2FzZSBmb3Igc3RyaW5nc1xuICAgICAgICAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiICYmIHZhbHVlID09PSBcIlwiKSB8fFxuICAgICAgICAvLyBzaW5nbGUtc2VsZWN0LCBlbXB0eSBvYmplY3RzIGFyZSBhIHNwZWNpYWwgY2FzZSBmb3IgbmVzdGVkIHZhbHVlc1xuICAgICAgICAoaXNQbGFpbk9iamVjdCh2YWx1ZSkgJiYgaXNFbXB0eSh2YWx1ZSkpIHx8XG4gICAgICAgIC8vIG11bHRpLXNlbGVjdFxuICAgICAgICAoQXJyYXkuaXNBcnJheSh2YWx1ZSkgJiYgdmFsdWUubGVuZ3RoIDwgMSkgfHxcbiAgICAgICAgLy8gb25seSB0ZXN0aW5nIG9iamVjdHMgd2hpY2ggYXJlIG5vdCBhcnJheXNcbiAgICAgICAgLy8gVE9ETzogY29tYmluZSBpc0V2ZXJ5UHJvcGVydHlFbXB0eSBhbmQgaXNFbXB0eURhdGFJdGVtIHRvIHNpbmdsZSBmdW5jdGlvblxuICAgICAgICAodHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmIGlzQXJyYXkodmFsdWUpID09PSBmYWxzZSAmJiBpc0V2ZXJ5UHJvcGVydHlFbXB0eSh2YWx1ZSkpKTtcbn1cblxuZXhwb3J0IHsgQVJHU19LRVlXT1JEIGFzIEEsIEZVTkNUSU9OX0tFWVdPUkQgYXMgRiwgUkZWX1RZUEUgYXMgUiwgVFlQRV9LRVlXT1JEIGFzIFQsIGlzUkZ4QXJnIGFzIGEsIFJGVF9UWVBFIGFzIGIsIGlzUmVmZXJlbmNlZE9iamVjdCBhcyBjLCBpc051bWJlciBhcyBkLCBpc1dpZGdldFZhbHVlQm9vbGVhbiBhcyBlLCBpc0NvbG9yUmFtcCBhcyBmLCBpc1JlY29yZFNldCBhcyBnLCBpc0ZlYXR1cmVMYXllciBhcyBoLCBpc0VtcHR5RGF0YUl0ZW0gYXMgaSwgaXNUaWxlTGF5ZXIgYXMgaiwgaXNEeW5hbWljSW1hZ2VyeUxheWVyIGFzIGssIGlzSW1hZ2VyeUxheWVyIGFzIGwsIGlzSW1hZ2VyeVRpbGVMYXllciBhcyBtIH07XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXR5cGUtZ2F1cmRzLTE4NDA3NDdmLmpzLm1hcCIsImNvbnN0IFVJRGVmYXVsdHMgPSB7XG4gICAgU2NhbGU6IFwic1wiLFxuICAgIFBvcG92ZXJUaW1lcjogNjBcbn07XG5jb25zdCBDYWxjaXRlU2NhbGUgPSB7XG4gICAgczogXCJzXCIsXG4gICAgbTogXCJtXCJcbn07XG5jb25zdCBDYWxjaXRlT3ZlcmxheVBvc2l0aW9uaW5nID0ge1xuICAgIGFic29sdXRlOiBcImFic29sdXRlXCIsXG4gICAgZml4ZWQ6IFwiZml4ZWRcIlxufTtcblxuZXhwb3J0IHsgQ2FsY2l0ZVNjYWxlIGFzIEMsIFVJRGVmYXVsdHMgYXMgVSwgQ2FsY2l0ZU92ZXJsYXlQb3NpdGlvbmluZyBhcyBhIH07XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVpLXV0aWxzLTkyOGE0MDk2LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==