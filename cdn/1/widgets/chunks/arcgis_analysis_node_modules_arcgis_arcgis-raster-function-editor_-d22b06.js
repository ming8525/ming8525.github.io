"use strict";
(self["webpackChunkexb_client"] = self["webpackChunkexb_client"] || []).push([["vendors-extensions_widgets_arcgis_analysis_node_modules_arcgis_arcgis-raster-function-editor_-d22b06"],{

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/arcgis-raster-function-editor/dist/esm/interfaces-d0c68944.js":
/*!*******************************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/arcgis-raster-function-editor/dist/esm/interfaces-d0c68944.js ***!
  \*******************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ ARGUMENT_WIDGETS),
/* harmony export */   G: () => (/* binding */ GridColumn),
/* harmony export */   J: () => (/* binding */ JSON_TYPES),
/* harmony export */   M: () => (/* binding */ MULTIDIMENSIONAL_RULES),
/* harmony export */   P: () => (/* binding */ PreviewStatus),
/* harmony export */   U: () => (/* binding */ UIInputStatus),
/* harmony export */   a: () => (/* binding */ Mode),
/* harmony export */   c: () => (/* binding */ convertRFTToolName),
/* harmony export */   d: () => (/* binding */ defaultRasterNodeProps)
/* harmony export */ });
const UIInputStatus = {
    IDLE: "idle",
    VALID: "valid",
    INVALID: "invalid"
};
const JSON_TYPES = {
    RASTER_FUNCTION_TEMPLATE: "RasterFunctionTemplate",
    RASTER_FUNCTION_VARIABLE: "RasterFunctionVariable",
    ARGUMENT_ARRAY: "ArgumentArray",
    RECORD_SET: "RecordSet",
    ECD_FILE: "ECDFile"
};
const convertRFTToolName = "ConvertRasterFunctionTemplate";
const MULTIDIMENSIONAL_RULES = {
    MATCH_VARIABLE: "MatchVariable",
    UNION_DIMENSION: "UnionDimension"
};
const defaultRasterNodeProps = {
    name: "Raster",
    isDataset: true,
    isPublic: false,
    type: JSON_TYPES.RASTER_FUNCTION_VARIABLE
};
const ARGUMENT_WIDGETS = {
    RFX_DTEX_COMMON_SELECT: "RFX-DTEX-COMMON-SELECT",
    RFX_DTE_COMMON_CHECKBOX: "CALCITE-CHECKBOX",
    RFX_DTE_COMMON_TEXTINPUT: "CALCITE-INPUT-TEXT",
    RFX_DTE_COMMON_NUMBERINPUT: "CALCITE-INPUT-NUMBER",
    RFX_DTE_RASTER_INPUT: "RFX-DTE-RASTER-INPUT",
    RFX_DTE_FEATURE_SELECT: "RFX-DTE-FEATURE-SELECT",
    RFX_DTEX_RASTER_VARIABLES_LIST: "RFX-DTEX-RASTER-VARIABLES-LIST",
    RFX_CTE_RANGED_VALUE_EDITOR: "RFX-CTE-RANGED-VALUE-EDITOR",
    RFX_CTE_GAMMA_EDITOR: "RFX-CTE-GAMMA-EDITOR",
    RFX_DTE_COLOR_RAMP_SELECTOR: "RFX-DTE-COLOR-RAMP-SELECTOR",
    RFX_DTE_EXTENT: "RFX-DTE-EXTENT",
    RFX_DTE_JSON_FILE_UPLOADER: "RFX-DTE-JSON-FILE-UPLOADER",
    RFX_CTE_FACTOR_FUNCTION_EDITOR: "RFX-CTE-FACTOR-FUNCTION-EDITOR",
    RFX_CTE_NEIGHBORHOOD_VALUES: "RFX-CTE-NEIGHBORHOOD-VALUES"
};
const Mode = {
    ANALYSIS: "analysis",
    EDITOR: "editor"
};
const GridColumn = {
    textInput: "text-input",
    text: "text",
    raster: "raster-input",
    number: "number-input",
    boolean: "check-box",
    switch: "switch",
    field: "field-select",
    color: "color-input",
    select: "select",
    icon: "icon"
};
const PreviewStatus = {
    loading: "loading",
    success: "success",
    error: "error"
};



//# sourceMappingURL=interfaces-d0c68944.js.map

/***/ }),

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/arcgis-raster-function-editor/dist/esm/localization-helper-4819b67d.js":
/*!****************************************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/arcgis-raster-function-editor/dist/esm/localization-helper-4819b67d.js ***!
  \****************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   D: () => (/* binding */ DefaultLocale),
/* harmony export */   S: () => (/* binding */ SupportedLocales),
/* harmony export */   a: () => (/* binding */ getDirectionBasedOnRTL),
/* harmony export */   b: () => (/* binding */ fetchComponentLocaleStrings),
/* harmony export */   f: () => (/* binding */ formatLocalizedHelpUrl),
/* harmony export */   g: () => (/* binding */ getLocaleInfo)
/* harmony export */ });
/**
 * Locale list reference [JSAPI](https://devtopia.esri.com/WebGIS/arcgis-js-api/tree/master/esri/nls)
 * also has Hindi: "hi"
 */
const SupportedLocales = {
    Arabic: "ar",
    Bosnian: "bs",
    Bulgarian: "bg",
    Catalan: "ca",
    Czech: "cs",
    Danish: "da",
    German: "de",
    Greek: "el",
    English: "en",
    EnglishUSA: "en-US",
    Spanish: "es",
    Estonian: "et",
    Finnish: "fi",
    French: "fr",
    Hebrew: "he",
    Hindi: "hi",
    Croatian: "hr",
    Hungarian: "hu",
    Indonesian: "id",
    Italian: "it",
    Japanese: "ja",
    Korean: "ko",
    Lithuanian: "lt",
    Latvian: "lv",
    NorwegianBokml: "nb",
    Dutch: "nl",
    Polish: "pl",
    PortugueseBrazil: "pt-BR",
    PortuguesePortugal: "pt-PT",
    Romanian: "ro",
    Russian: "ru",
    Serbian: "sr",
    Slovenian: "sl",
    Slovak: "sk",
    Swedish: "sv",
    Thai: "th",
    Turkish: "tr",
    Ukrainian: "uk",
    Vietnamese: "vi",
    ChineseChina: "zh-CN",
    ChineseHongKong: "zh-HK",
    ChineseTaiwan: "zh-TW"
};
const SupportedOnlineHelpLocales = ["ar", "de", "es", "fr", "it", "ja", "ko", "ru", "pl", "pt-br", "zh-cn"];
const LocaleMap = {
    "en-AU": "en",
    "en-CA": "en",
    "en-GB": "en",
    "en-US": "en",
    "es-ES": "es",
    "es-MX": "es",
    "de-CH": "de",
    "de-AT": "de",
    "de-DE": "de",
    "fr-CH": "fr",
    "fr-FR": "fr",
    "it-CH": "it",
    "it-IT": "it",
    ind: "id",
    ukr: "uk"
};
/**
 * List of supported locales that are RTL
 * reference: https://devtopia.esri.com/WebGIS/arcgis-js-api/blob/4master/esri/intl/locale.ts
 */
const RTLLocales = [SupportedLocales.Arabic, SupportedLocales.Hebrew];
const DefaultLocale = SupportedLocales.English;
/**
 * Utility to centralize logic, and return "rtl" or "rtl" depending on rtl boolean
 * @param {boolean} rtl whether locale is in Right to Left direction
 * @returns {"ltr" | "rtl"} codes that can be passed to "dir" prop of a component.
 */
function getDirectionBasedOnRTL(rtl) {
    return rtl === true ? "rtl" : "ltr";
}
/**
 * Helper function to find the closest element crossing multiple (parent) shadowDOM boundaries.
 * The implementation is based on [this](https://stackoverflow.com/questions/54520554/custom-element-getrootnode-closest-function-crossing-multiple-parent-shadowd) solution.
 *
 * @param {string} selector
 * @param {Element} base
 */
function getClosestElement(selector, base) {
    function closestFrom(el) {
        let element;
        if (el === undefined || el === document || el === window)
            element = null;
        else {
            const found = el.closest(selector);
            element = found || closestFrom(el.getRootNode().host);
        }
        return element;
    }
    return closestFrom(base);
}
/**
 * Converts the given locale to a supported locale using the provided locale map.
 *
 * @param {string | undefined} locale - The locale to be converted.
 * @param {object} localeMap - A map of locales to supported locales.
 * @returns {string} - The supported locale.
 */
function convertToSupportedLocale(locale, localeMap) {
    const defaultLocale = DefaultLocale;
    let localeSanitized = locale?.toLowerCase();
    if (localeSanitized !== undefined && localeSanitized.indexOf("-") !== -1) {
        const [lang, region] = localeSanitized.split("-");
        localeSanitized = `${lang}-${region.toUpperCase()}`;
    }
    if (!localeSanitized) {
        return defaultLocale;
    }
    const localeMapKeys = Object.keys(LocaleMap);
    if (localeMapKeys.includes(localeSanitized) === true) {
        return localeMap[localeSanitized];
    }
    return localeSanitized;
}
/**
 * Retrieves locale information; In the case of Regional codes (en-au) it is converted to a supported locale (en).
 *
 * @param {Element} [element=document.documentElement] - The element to search for locale information.
 * @returns {Object} An object containing the locale information.
 * @property {string} locale - The locale code.
 * @property {boolean} rtl - A flag indicating whether the locale is right-to-left.
 */
function getLocaleInfo(element = document.documentElement) {
    // Gets the closest element with a lang attribute and falls back to navigator.language if not found
    const closestElement = getClosestElement("[lang]", element);
    const locale = closestElement?.lang ?? window.navigator.language;
    const supportedLocales = Object.values(SupportedLocales);
    const defaultLocale = DefaultLocale;
    const convertedLocale = convertToSupportedLocale(locale, LocaleMap);
    const isSupportedLocale = supportedLocales.includes(convertedLocale);
    return {
        locale: isSupportedLocale ? convertedLocale : defaultLocale,
        rtl: RTLLocales.includes(locale)
    };
}
/**
 * Fetches the locale file of the given component; defaults to `"en"` locale
 * @param componentName
 * @param props
 * @param locale
 * @param resourcesUrl
 * @param props.path
 * @param props.locale
 * @param props.baseURL
 */
async function fetchLocaleStrings(props) {
    const { path, locale, baseURL } = props;
    // Using the getPublicPath method that leverages `data-resources-url` currently this is not working.
    // const rUrl = getPublicPath(componentName) || resourcesUrl;
    let localeData = {};
    try {
        const response = await fetch(`${baseURL}t9n/${path}.t9n.${locale}.json`);
        localeData = await response.json();
    }
    catch (e) {
        const defaultResponse = await fetch(`${baseURL}t9n/${path}.t9n.${DefaultLocale}.json`);
        localeData = await defaultResponse.json();
    }
    return localeData;
}
async function fetchComponentLocaleStrings(element, baseURL) {
    const componentName = element.tagName.toLowerCase();
    const { locale, rtl } = getLocaleInfo(element);
    const strings = await fetchLocaleStrings({ path: componentName, locale, baseURL });
    return { strings, dir: getDirectionBasedOnRTL(rtl), locale: locale };
}
/**
 * Formats a URL to link to
 * @param {string} url the url string from after the locale
 * @param {string} basePath the base path from the signed in portal object.
 * @param {string} locale the locale abbreviation for the browser.
 * @returns {string} the formatted url.
 */
function formatLocalizedHelpUrl(url, basePath, locale = "en") {
    let localeSanitized = locale;
    const localeMapKeys = Object.keys(LocaleMap);
    if (localeMapKeys.includes(locale) === true) {
        localeSanitized = LocaleMap[locale];
    }
    const localeInLowerCase = localeSanitized.toLocaleLowerCase();
    if (SupportedOnlineHelpLocales.includes(localeInLowerCase) === true) {
        // following regex tests /en/ is present in url and replaces it with the locale
        // https://docdev.arcgis.com/en/arcgis-online/analyze/aggregate-points-mv.htm
        // self Response only provides with `en` locale not as per the user locale or current app locale
        // so we need this replace call.
        basePath = basePath.replace(/^https?:\/\/[^/]+\/en/, (match) => match.replace("en", localeInLowerCase));
    }
    const learnMoreUrl = `${basePath}analyze/${url}`;
    return learnMoreUrl;
}



//# sourceMappingURL=localization-helper-4819b67d.js.map

/***/ }),

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/arcgis-raster-function-editor/dist/esm/type-gaurds-1840747f.js":
/*!********************************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/arcgis-raster-function-editor/dist/esm/type-gaurds-1840747f.js ***!
  \********************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ ARGS_KEYWORD),
/* harmony export */   F: () => (/* binding */ FUNCTION_KEYWORD),
/* harmony export */   R: () => (/* binding */ RFV_TYPE),
/* harmony export */   T: () => (/* binding */ TYPE_KEYWORD),
/* harmony export */   a: () => (/* binding */ isRFxArg),
/* harmony export */   b: () => (/* binding */ RFT_TYPE),
/* harmony export */   c: () => (/* binding */ isReferencedObject),
/* harmony export */   d: () => (/* binding */ isNumber),
/* harmony export */   e: () => (/* binding */ isWidgetValueBoolean),
/* harmony export */   f: () => (/* binding */ isColorRamp),
/* harmony export */   g: () => (/* binding */ isRecordSet),
/* harmony export */   h: () => (/* binding */ isFeatureLayer),
/* harmony export */   i: () => (/* binding */ isEmptyDataItem),
/* harmony export */   j: () => (/* binding */ isTileLayer),
/* harmony export */   k: () => (/* binding */ isDynamicImageryLayer),
/* harmony export */   l: () => (/* binding */ isImageryLayer),
/* harmony export */   m: () => (/* binding */ isImageryTileLayer)
/* harmony export */ });
/* harmony import */ var _getTag_96af029d_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_getTag-96af029d.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/arcgis-raster-function-editor/dist/esm/_getTag-96af029d.js");


/** `Object#toString` result references. */
var mapTag = '[object Map]',
    setTag = '[object Set]';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Checks if `value` is an empty object, collection, map, or set.
 *
 * Objects are considered empty if they have no own enumerable string keyed
 * properties.
 *
 * Array-like values such as `arguments` objects, arrays, buffers, strings, or
 * jQuery-like collections are considered empty if they have a `length` of `0`.
 * Similarly, maps and sets are considered empty if they have a `size` of `0`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is empty, else `false`.
 * @example
 *
 * _.isEmpty(null);
 * // => true
 *
 * _.isEmpty(true);
 * // => true
 *
 * _.isEmpty(1);
 * // => true
 *
 * _.isEmpty([1, 2, 3]);
 * // => false
 *
 * _.isEmpty({ 'a': 1 });
 * // => false
 */
function isEmpty(value) {
  if (value == null) {
    return true;
  }
  if ((0,_getTag_96af029d_js__WEBPACK_IMPORTED_MODULE_0__.i)(value) &&
      ((0,_getTag_96af029d_js__WEBPACK_IMPORTED_MODULE_0__.a)(value) || typeof value == 'string' || typeof value.splice == 'function' ||
        (0,_getTag_96af029d_js__WEBPACK_IMPORTED_MODULE_0__.b)(value) || (0,_getTag_96af029d_js__WEBPACK_IMPORTED_MODULE_0__.c)(value) || (0,_getTag_96af029d_js__WEBPACK_IMPORTED_MODULE_0__.d)(value))) {
    return !value.length;
  }
  var tag = (0,_getTag_96af029d_js__WEBPACK_IMPORTED_MODULE_0__.g)(value);
  if (tag == mapTag || tag == setTag) {
    return !value.size;
  }
  if ((0,_getTag_96af029d_js__WEBPACK_IMPORTED_MODULE_0__.e)(value)) {
    return !(0,_getTag_96af029d_js__WEBPACK_IMPORTED_MODULE_0__.f)(value).length;
  }
  for (var key in value) {
    if (hasOwnProperty.call(value, key)) {
      return false;
    }
  }
  return true;
}

const RFT_TYPE = "RasterFunctionTemplate";
const TYPE_KEYWORD = "type";
const RFV_TYPE = "RasterFunctionVariable";
const ARGS_KEYWORD = "arguments";
const FUNCTION_KEYWORD = "function";
function isReferencedObject(obj) {
    if (!obj) {
        return false;
    }
    if (obj._object_ref_id != null) {
        return true;
    }
    return false;
}
function isNumber(x) {
    x = String(x).trim();
    if (x === "") {
        return false;
    }
    return /^[+-]?(\d+)?(\.\d+)?$/.test(x);
}
function isWidgetValueBoolean(x) {
    x = String(x).trim();
    return ["true", "false"].indexOf(x) >= 0;
}
function isColorRamp(rfxArg) {
    if (!rfxArg) {
        return false;
    }
    if (rfxArg.type && rfxArg.type.toLowerCase().indexOf("colorramp") >= 0) {
        return true;
    }
    if (rfxArg.value && rfxArg.value.type && rfxArg.value.type.toLowerCase().indexOf("colorramp") >= 0) {
        return true;
    }
    return false;
}
function isRecordSet(rfxArg) {
    return rfxArg.type && rfxArg.type.toLowerCase().indexOf("recordset") >= 0;
}
/**
 * Determines whether the given RFT element is an RFx argument.
 *
 * @param {any} rftElement - The RFT element to check.
 * @returns {boolean} `true` if the given element is RasterFunctionTemplate,
 * RasterFunctionVariable, isColorRamp, isRecordSet; `false` otherwise.
 */
function isRFxArg(rftElement) {
    if (!rftElement) {
        return false;
    }
    const type = rftElement.type;
    return [RFT_TYPE, RFV_TYPE].indexOf(type) >= 0 || isColorRamp(rftElement) || isRecordSet(rftElement);
}
/**
 * Determines if the input is a FeatureLayer
 * @param {__esri.Layer} layer the layer to check the type of
 * @returns {layer is __esri.FeatureLayer} layer is a FeatureLayer
 */
function isFeatureLayer(layer) {
    return layer.type === "feature";
}
/**
 * Determines if the input is a TileLayer
 * @param {__esri.Layer} layer the layer to check the type of
 * @returns {layer is __esri.TileLayer} layer is a TileLayer
 */
function isTileLayer(layer) {
    return layer.type === "tile";
}
/**
 * Determines if the input is a ImageryTileLayer
 * @param {__esri.Layer} layer the layer to check the type of
 * @returns {layer is __esri.ImageryLayer} layer is a ImageryLayer
 */
function isDynamicImageryLayer(layer) {
    return (layer.type === "imagery-tile" &&
        layer.sourceJSON.capabilities.toLowerCase().indexOf("tilesonly") < 0);
}
/**
 * Determines if the input is a ImageryLayer
 * @param {__esri.Layer} layer the layer to check the type of
 * @returns {layer is __esri.ImageryLayer} layer is a ImageryLayer
 */
function isImageryLayer(layer) {
    return layer.type === "imagery" || isDynamicImageryLayer(layer);
}
/**
 * Determines if the input is a ImageryTileLayer
 * @param {__esri.Layer} layer the layer to check the type of
 * @returns {layer is __esri.ImageryTileLayer} layer is a ImageryTileLayer
 */
function isImageryTileLayer(layer) {
    return layer.type === "imagery-tile" && !isDynamicImageryLayer(layer);
}
function isEveryPropertyEmpty(value) {
    let isAllPropsEmpty = true;
    if (typeof value === "object" && (0,_getTag_96af029d_js__WEBPACK_IMPORTED_MODULE_0__.a)(value) === false) {
        // using for-in as it will work with objects with properties that set via accessors as well
        for (const prop in value) {
            // This will tell the TypeScript compiler that the obj object has a string index signature,
            // and will allow to access its properties using a string index without getting the "Element implicitly has an 'any' type" error.
            const propValue = value?.[prop];
            if (value.hasOwnProperty(prop) === true && propValue !== undefined && propValue !== null && propValue !== "") {
                isAllPropsEmpty = false;
                break;
            }
        }
    }
    return isAllPropsEmpty;
}
/**
 * Check for an empty value for data items like GPString and Field.
 * @param value data item value.
 * @returns whether the value is considered empty.
 */
function isEmptyDataItem(value) {
    return (value === undefined ||
        value === null ||
        // single-select, "" is a special case for strings
        (typeof value === "string" && value === "") ||
        // single-select, empty objects are a special case for nested values
        ((0,_getTag_96af029d_js__WEBPACK_IMPORTED_MODULE_0__.h)(value) && isEmpty(value)) ||
        // multi-select
        (Array.isArray(value) && value.length < 1) ||
        // only testing objects which are not arrays
        // TODO: combine isEveryPropertyEmpty and isEmptyDataItem to single function
        (typeof value === "object" && (0,_getTag_96af029d_js__WEBPACK_IMPORTED_MODULE_0__.a)(value) === false && isEveryPropertyEmpty(value)));
}



//# sourceMappingURL=type-gaurds-1840747f.js.map

/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid2lkZ2V0cy9jaHVua3MvYXJjZ2lzX2FuYWx5c2lzX25vZGVfbW9kdWxlc19hcmNnaXNfYXJjZ2lzLXJhc3Rlci1mdW5jdGlvbi1lZGl0b3JfLWQyMmIwNi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRXlNOztBQUV6TTs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQy9EQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLGFBQWEsZUFBZTtBQUM1QjtBQUNBO0FBQ0E7QUFD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YztBQUN6QixhQUFhLDJCQUEyQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGNBQWM7QUFDekIsYUFBYSw4QkFBOEI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGNBQWM7QUFDekIsYUFBYSw4QkFBOEI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxjQUFjO0FBQ3pCLGFBQWEsa0NBQWtDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxzREFBTztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLHNEQUFhO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLHNEQUFPO0FBQzdDOztBQUVrVzs7QUFFbFciLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9leGItY2xpZW50Ly4vZXh0ZW5zaW9ucy93aWRnZXRzL2FyY2dpcy9hbmFseXNpcy9ub2RlX21vZHVsZXMvQGFyY2dpcy9hcmNnaXMtcmFzdGVyLWZ1bmN0aW9uLWVkaXRvci9kaXN0L2VzbS9pbnRlcmZhY2VzLWQwYzY4OTQ0LmpzIiwid2VicGFjazovL2V4Yi1jbGllbnQvLi9leHRlbnNpb25zL3dpZGdldHMvYXJjZ2lzL2FuYWx5c2lzL25vZGVfbW9kdWxlcy9AYXJjZ2lzL2FyY2dpcy1yYXN0ZXItZnVuY3Rpb24tZWRpdG9yL2Rpc3QvZXNtL2xvY2FsaXphdGlvbi1oZWxwZXItNDgxOWI2N2QuanMiLCJ3ZWJwYWNrOi8vZXhiLWNsaWVudC8uL2V4dGVuc2lvbnMvd2lkZ2V0cy9hcmNnaXMvYW5hbHlzaXMvbm9kZV9tb2R1bGVzL0BhcmNnaXMvYXJjZ2lzLXJhc3Rlci1mdW5jdGlvbi1lZGl0b3IvZGlzdC9lc20vdHlwZS1nYXVyZHMtMTg0MDc0N2YuanMiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgVUlJbnB1dFN0YXR1cyA9IHtcbiAgICBJRExFOiBcImlkbGVcIixcbiAgICBWQUxJRDogXCJ2YWxpZFwiLFxuICAgIElOVkFMSUQ6IFwiaW52YWxpZFwiXG59O1xuY29uc3QgSlNPTl9UWVBFUyA9IHtcbiAgICBSQVNURVJfRlVOQ1RJT05fVEVNUExBVEU6IFwiUmFzdGVyRnVuY3Rpb25UZW1wbGF0ZVwiLFxuICAgIFJBU1RFUl9GVU5DVElPTl9WQVJJQUJMRTogXCJSYXN0ZXJGdW5jdGlvblZhcmlhYmxlXCIsXG4gICAgQVJHVU1FTlRfQVJSQVk6IFwiQXJndW1lbnRBcnJheVwiLFxuICAgIFJFQ09SRF9TRVQ6IFwiUmVjb3JkU2V0XCIsXG4gICAgRUNEX0ZJTEU6IFwiRUNERmlsZVwiXG59O1xuY29uc3QgY29udmVydFJGVFRvb2xOYW1lID0gXCJDb252ZXJ0UmFzdGVyRnVuY3Rpb25UZW1wbGF0ZVwiO1xuY29uc3QgTVVMVElESU1FTlNJT05BTF9SVUxFUyA9IHtcbiAgICBNQVRDSF9WQVJJQUJMRTogXCJNYXRjaFZhcmlhYmxlXCIsXG4gICAgVU5JT05fRElNRU5TSU9OOiBcIlVuaW9uRGltZW5zaW9uXCJcbn07XG5jb25zdCBkZWZhdWx0UmFzdGVyTm9kZVByb3BzID0ge1xuICAgIG5hbWU6IFwiUmFzdGVyXCIsXG4gICAgaXNEYXRhc2V0OiB0cnVlLFxuICAgIGlzUHVibGljOiBmYWxzZSxcbiAgICB0eXBlOiBKU09OX1RZUEVTLlJBU1RFUl9GVU5DVElPTl9WQVJJQUJMRVxufTtcbmNvbnN0IEFSR1VNRU5UX1dJREdFVFMgPSB7XG4gICAgUkZYX0RURVhfQ09NTU9OX1NFTEVDVDogXCJSRlgtRFRFWC1DT01NT04tU0VMRUNUXCIsXG4gICAgUkZYX0RURV9DT01NT05fQ0hFQ0tCT1g6IFwiQ0FMQ0lURS1DSEVDS0JPWFwiLFxuICAgIFJGWF9EVEVfQ09NTU9OX1RFWFRJTlBVVDogXCJDQUxDSVRFLUlOUFVULVRFWFRcIixcbiAgICBSRlhfRFRFX0NPTU1PTl9OVU1CRVJJTlBVVDogXCJDQUxDSVRFLUlOUFVULU5VTUJFUlwiLFxuICAgIFJGWF9EVEVfUkFTVEVSX0lOUFVUOiBcIlJGWC1EVEUtUkFTVEVSLUlOUFVUXCIsXG4gICAgUkZYX0RURV9GRUFUVVJFX1NFTEVDVDogXCJSRlgtRFRFLUZFQVRVUkUtU0VMRUNUXCIsXG4gICAgUkZYX0RURVhfUkFTVEVSX1ZBUklBQkxFU19MSVNUOiBcIlJGWC1EVEVYLVJBU1RFUi1WQVJJQUJMRVMtTElTVFwiLFxuICAgIFJGWF9DVEVfUkFOR0VEX1ZBTFVFX0VESVRPUjogXCJSRlgtQ1RFLVJBTkdFRC1WQUxVRS1FRElUT1JcIixcbiAgICBSRlhfQ1RFX0dBTU1BX0VESVRPUjogXCJSRlgtQ1RFLUdBTU1BLUVESVRPUlwiLFxuICAgIFJGWF9EVEVfQ09MT1JfUkFNUF9TRUxFQ1RPUjogXCJSRlgtRFRFLUNPTE9SLVJBTVAtU0VMRUNUT1JcIixcbiAgICBSRlhfRFRFX0VYVEVOVDogXCJSRlgtRFRFLUVYVEVOVFwiLFxuICAgIFJGWF9EVEVfSlNPTl9GSUxFX1VQTE9BREVSOiBcIlJGWC1EVEUtSlNPTi1GSUxFLVVQTE9BREVSXCIsXG4gICAgUkZYX0NURV9GQUNUT1JfRlVOQ1RJT05fRURJVE9SOiBcIlJGWC1DVEUtRkFDVE9SLUZVTkNUSU9OLUVESVRPUlwiLFxuICAgIFJGWF9DVEVfTkVJR0hCT1JIT09EX1ZBTFVFUzogXCJSRlgtQ1RFLU5FSUdIQk9SSE9PRC1WQUxVRVNcIlxufTtcbmNvbnN0IE1vZGUgPSB7XG4gICAgQU5BTFlTSVM6IFwiYW5hbHlzaXNcIixcbiAgICBFRElUT1I6IFwiZWRpdG9yXCJcbn07XG5jb25zdCBHcmlkQ29sdW1uID0ge1xuICAgIHRleHRJbnB1dDogXCJ0ZXh0LWlucHV0XCIsXG4gICAgdGV4dDogXCJ0ZXh0XCIsXG4gICAgcmFzdGVyOiBcInJhc3Rlci1pbnB1dFwiLFxuICAgIG51bWJlcjogXCJudW1iZXItaW5wdXRcIixcbiAgICBib29sZWFuOiBcImNoZWNrLWJveFwiLFxuICAgIHN3aXRjaDogXCJzd2l0Y2hcIixcbiAgICBmaWVsZDogXCJmaWVsZC1zZWxlY3RcIixcbiAgICBjb2xvcjogXCJjb2xvci1pbnB1dFwiLFxuICAgIHNlbGVjdDogXCJzZWxlY3RcIixcbiAgICBpY29uOiBcImljb25cIlxufTtcbmNvbnN0IFByZXZpZXdTdGF0dXMgPSB7XG4gICAgbG9hZGluZzogXCJsb2FkaW5nXCIsXG4gICAgc3VjY2VzczogXCJzdWNjZXNzXCIsXG4gICAgZXJyb3I6IFwiZXJyb3JcIlxufTtcblxuZXhwb3J0IHsgQVJHVU1FTlRfV0lER0VUUyBhcyBBLCBHcmlkQ29sdW1uIGFzIEcsIEpTT05fVFlQRVMgYXMgSiwgTVVMVElESU1FTlNJT05BTF9SVUxFUyBhcyBNLCBQcmV2aWV3U3RhdHVzIGFzIFAsIFVJSW5wdXRTdGF0dXMgYXMgVSwgTW9kZSBhcyBhLCBjb252ZXJ0UkZUVG9vbE5hbWUgYXMgYywgZGVmYXVsdFJhc3Rlck5vZGVQcm9wcyBhcyBkIH07XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWludGVyZmFjZXMtZDBjNjg5NDQuanMubWFwIiwiLyoqXG4gKiBMb2NhbGUgbGlzdCByZWZlcmVuY2UgW0pTQVBJXShodHRwczovL2RldnRvcGlhLmVzcmkuY29tL1dlYkdJUy9hcmNnaXMtanMtYXBpL3RyZWUvbWFzdGVyL2VzcmkvbmxzKVxuICogYWxzbyBoYXMgSGluZGk6IFwiaGlcIlxuICovXG5jb25zdCBTdXBwb3J0ZWRMb2NhbGVzID0ge1xuICAgIEFyYWJpYzogXCJhclwiLFxuICAgIEJvc25pYW46IFwiYnNcIixcbiAgICBCdWxnYXJpYW46IFwiYmdcIixcbiAgICBDYXRhbGFuOiBcImNhXCIsXG4gICAgQ3plY2g6IFwiY3NcIixcbiAgICBEYW5pc2g6IFwiZGFcIixcbiAgICBHZXJtYW46IFwiZGVcIixcbiAgICBHcmVlazogXCJlbFwiLFxuICAgIEVuZ2xpc2g6IFwiZW5cIixcbiAgICBFbmdsaXNoVVNBOiBcImVuLVVTXCIsXG4gICAgU3BhbmlzaDogXCJlc1wiLFxuICAgIEVzdG9uaWFuOiBcImV0XCIsXG4gICAgRmlubmlzaDogXCJmaVwiLFxuICAgIEZyZW5jaDogXCJmclwiLFxuICAgIEhlYnJldzogXCJoZVwiLFxuICAgIEhpbmRpOiBcImhpXCIsXG4gICAgQ3JvYXRpYW46IFwiaHJcIixcbiAgICBIdW5nYXJpYW46IFwiaHVcIixcbiAgICBJbmRvbmVzaWFuOiBcImlkXCIsXG4gICAgSXRhbGlhbjogXCJpdFwiLFxuICAgIEphcGFuZXNlOiBcImphXCIsXG4gICAgS29yZWFuOiBcImtvXCIsXG4gICAgTGl0aHVhbmlhbjogXCJsdFwiLFxuICAgIExhdHZpYW46IFwibHZcIixcbiAgICBOb3J3ZWdpYW5Cb2ttbDogXCJuYlwiLFxuICAgIER1dGNoOiBcIm5sXCIsXG4gICAgUG9saXNoOiBcInBsXCIsXG4gICAgUG9ydHVndWVzZUJyYXppbDogXCJwdC1CUlwiLFxuICAgIFBvcnR1Z3Vlc2VQb3J0dWdhbDogXCJwdC1QVFwiLFxuICAgIFJvbWFuaWFuOiBcInJvXCIsXG4gICAgUnVzc2lhbjogXCJydVwiLFxuICAgIFNlcmJpYW46IFwic3JcIixcbiAgICBTbG92ZW5pYW46IFwic2xcIixcbiAgICBTbG92YWs6IFwic2tcIixcbiAgICBTd2VkaXNoOiBcInN2XCIsXG4gICAgVGhhaTogXCJ0aFwiLFxuICAgIFR1cmtpc2g6IFwidHJcIixcbiAgICBVa3JhaW5pYW46IFwidWtcIixcbiAgICBWaWV0bmFtZXNlOiBcInZpXCIsXG4gICAgQ2hpbmVzZUNoaW5hOiBcInpoLUNOXCIsXG4gICAgQ2hpbmVzZUhvbmdLb25nOiBcInpoLUhLXCIsXG4gICAgQ2hpbmVzZVRhaXdhbjogXCJ6aC1UV1wiXG59O1xuY29uc3QgU3VwcG9ydGVkT25saW5lSGVscExvY2FsZXMgPSBbXCJhclwiLCBcImRlXCIsIFwiZXNcIiwgXCJmclwiLCBcIml0XCIsIFwiamFcIiwgXCJrb1wiLCBcInJ1XCIsIFwicGxcIiwgXCJwdC1iclwiLCBcInpoLWNuXCJdO1xuY29uc3QgTG9jYWxlTWFwID0ge1xuICAgIFwiZW4tQVVcIjogXCJlblwiLFxuICAgIFwiZW4tQ0FcIjogXCJlblwiLFxuICAgIFwiZW4tR0JcIjogXCJlblwiLFxuICAgIFwiZW4tVVNcIjogXCJlblwiLFxuICAgIFwiZXMtRVNcIjogXCJlc1wiLFxuICAgIFwiZXMtTVhcIjogXCJlc1wiLFxuICAgIFwiZGUtQ0hcIjogXCJkZVwiLFxuICAgIFwiZGUtQVRcIjogXCJkZVwiLFxuICAgIFwiZGUtREVcIjogXCJkZVwiLFxuICAgIFwiZnItQ0hcIjogXCJmclwiLFxuICAgIFwiZnItRlJcIjogXCJmclwiLFxuICAgIFwiaXQtQ0hcIjogXCJpdFwiLFxuICAgIFwiaXQtSVRcIjogXCJpdFwiLFxuICAgIGluZDogXCJpZFwiLFxuICAgIHVrcjogXCJ1a1wiXG59O1xuLyoqXG4gKiBMaXN0IG9mIHN1cHBvcnRlZCBsb2NhbGVzIHRoYXQgYXJlIFJUTFxuICogcmVmZXJlbmNlOiBodHRwczovL2RldnRvcGlhLmVzcmkuY29tL1dlYkdJUy9hcmNnaXMtanMtYXBpL2Jsb2IvNG1hc3Rlci9lc3JpL2ludGwvbG9jYWxlLnRzXG4gKi9cbmNvbnN0IFJUTExvY2FsZXMgPSBbU3VwcG9ydGVkTG9jYWxlcy5BcmFiaWMsIFN1cHBvcnRlZExvY2FsZXMuSGVicmV3XTtcbmNvbnN0IERlZmF1bHRMb2NhbGUgPSBTdXBwb3J0ZWRMb2NhbGVzLkVuZ2xpc2g7XG4vKipcbiAqIFV0aWxpdHkgdG8gY2VudHJhbGl6ZSBsb2dpYywgYW5kIHJldHVybiBcInJ0bFwiIG9yIFwicnRsXCIgZGVwZW5kaW5nIG9uIHJ0bCBib29sZWFuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHJ0bCB3aGV0aGVyIGxvY2FsZSBpcyBpbiBSaWdodCB0byBMZWZ0IGRpcmVjdGlvblxuICogQHJldHVybnMge1wibHRyXCIgfCBcInJ0bFwifSBjb2RlcyB0aGF0IGNhbiBiZSBwYXNzZWQgdG8gXCJkaXJcIiBwcm9wIG9mIGEgY29tcG9uZW50LlxuICovXG5mdW5jdGlvbiBnZXREaXJlY3Rpb25CYXNlZE9uUlRMKHJ0bCkge1xuICAgIHJldHVybiBydGwgPT09IHRydWUgPyBcInJ0bFwiIDogXCJsdHJcIjtcbn1cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRvIGZpbmQgdGhlIGNsb3Nlc3QgZWxlbWVudCBjcm9zc2luZyBtdWx0aXBsZSAocGFyZW50KSBzaGFkb3dET00gYm91bmRhcmllcy5cbiAqIFRoZSBpbXBsZW1lbnRhdGlvbiBpcyBiYXNlZCBvbiBbdGhpc10oaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNTQ1MjA1NTQvY3VzdG9tLWVsZW1lbnQtZ2V0cm9vdG5vZGUtY2xvc2VzdC1mdW5jdGlvbi1jcm9zc2luZy1tdWx0aXBsZS1wYXJlbnQtc2hhZG93ZCkgc29sdXRpb24uXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHNlbGVjdG9yXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGJhc2VcbiAqL1xuZnVuY3Rpb24gZ2V0Q2xvc2VzdEVsZW1lbnQoc2VsZWN0b3IsIGJhc2UpIHtcbiAgICBmdW5jdGlvbiBjbG9zZXN0RnJvbShlbCkge1xuICAgICAgICBsZXQgZWxlbWVudDtcbiAgICAgICAgaWYgKGVsID09PSB1bmRlZmluZWQgfHwgZWwgPT09IGRvY3VtZW50IHx8IGVsID09PSB3aW5kb3cpXG4gICAgICAgICAgICBlbGVtZW50ID0gbnVsbDtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBmb3VuZCA9IGVsLmNsb3Nlc3Qoc2VsZWN0b3IpO1xuICAgICAgICAgICAgZWxlbWVudCA9IGZvdW5kIHx8IGNsb3Nlc3RGcm9tKGVsLmdldFJvb3ROb2RlKCkuaG9zdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgfVxuICAgIHJldHVybiBjbG9zZXN0RnJvbShiYXNlKTtcbn1cbi8qKlxuICogQ29udmVydHMgdGhlIGdpdmVuIGxvY2FsZSB0byBhIHN1cHBvcnRlZCBsb2NhbGUgdXNpbmcgdGhlIHByb3ZpZGVkIGxvY2FsZSBtYXAuXG4gKlxuICogQHBhcmFtIHtzdHJpbmcgfCB1bmRlZmluZWR9IGxvY2FsZSAtIFRoZSBsb2NhbGUgdG8gYmUgY29udmVydGVkLlxuICogQHBhcmFtIHtvYmplY3R9IGxvY2FsZU1hcCAtIEEgbWFwIG9mIGxvY2FsZXMgdG8gc3VwcG9ydGVkIGxvY2FsZXMuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSAtIFRoZSBzdXBwb3J0ZWQgbG9jYWxlLlxuICovXG5mdW5jdGlvbiBjb252ZXJ0VG9TdXBwb3J0ZWRMb2NhbGUobG9jYWxlLCBsb2NhbGVNYXApIHtcbiAgICBjb25zdCBkZWZhdWx0TG9jYWxlID0gRGVmYXVsdExvY2FsZTtcbiAgICBsZXQgbG9jYWxlU2FuaXRpemVkID0gbG9jYWxlPy50b0xvd2VyQ2FzZSgpO1xuICAgIGlmIChsb2NhbGVTYW5pdGl6ZWQgIT09IHVuZGVmaW5lZCAmJiBsb2NhbGVTYW5pdGl6ZWQuaW5kZXhPZihcIi1cIikgIT09IC0xKSB7XG4gICAgICAgIGNvbnN0IFtsYW5nLCByZWdpb25dID0gbG9jYWxlU2FuaXRpemVkLnNwbGl0KFwiLVwiKTtcbiAgICAgICAgbG9jYWxlU2FuaXRpemVkID0gYCR7bGFuZ30tJHtyZWdpb24udG9VcHBlckNhc2UoKX1gO1xuICAgIH1cbiAgICBpZiAoIWxvY2FsZVNhbml0aXplZCkge1xuICAgICAgICByZXR1cm4gZGVmYXVsdExvY2FsZTtcbiAgICB9XG4gICAgY29uc3QgbG9jYWxlTWFwS2V5cyA9IE9iamVjdC5rZXlzKExvY2FsZU1hcCk7XG4gICAgaWYgKGxvY2FsZU1hcEtleXMuaW5jbHVkZXMobG9jYWxlU2FuaXRpemVkKSA9PT0gdHJ1ZSkge1xuICAgICAgICByZXR1cm4gbG9jYWxlTWFwW2xvY2FsZVNhbml0aXplZF07XG4gICAgfVxuICAgIHJldHVybiBsb2NhbGVTYW5pdGl6ZWQ7XG59XG4vKipcbiAqIFJldHJpZXZlcyBsb2NhbGUgaW5mb3JtYXRpb247IEluIHRoZSBjYXNlIG9mIFJlZ2lvbmFsIGNvZGVzIChlbi1hdSkgaXQgaXMgY29udmVydGVkIHRvIGEgc3VwcG9ydGVkIGxvY2FsZSAoZW4pLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gW2VsZW1lbnQ9ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50XSAtIFRoZSBlbGVtZW50IHRvIHNlYXJjaCBmb3IgbG9jYWxlIGluZm9ybWF0aW9uLlxuICogQHJldHVybnMge09iamVjdH0gQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGxvY2FsZSBpbmZvcm1hdGlvbi5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBsb2NhbGUgLSBUaGUgbG9jYWxlIGNvZGUuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IHJ0bCAtIEEgZmxhZyBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIGxvY2FsZSBpcyByaWdodC10by1sZWZ0LlxuICovXG5mdW5jdGlvbiBnZXRMb2NhbGVJbmZvKGVsZW1lbnQgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpIHtcbiAgICAvLyBHZXRzIHRoZSBjbG9zZXN0IGVsZW1lbnQgd2l0aCBhIGxhbmcgYXR0cmlidXRlIGFuZCBmYWxscyBiYWNrIHRvIG5hdmlnYXRvci5sYW5ndWFnZSBpZiBub3QgZm91bmRcbiAgICBjb25zdCBjbG9zZXN0RWxlbWVudCA9IGdldENsb3Nlc3RFbGVtZW50KFwiW2xhbmddXCIsIGVsZW1lbnQpO1xuICAgIGNvbnN0IGxvY2FsZSA9IGNsb3Nlc3RFbGVtZW50Py5sYW5nID8/IHdpbmRvdy5uYXZpZ2F0b3IubGFuZ3VhZ2U7XG4gICAgY29uc3Qgc3VwcG9ydGVkTG9jYWxlcyA9IE9iamVjdC52YWx1ZXMoU3VwcG9ydGVkTG9jYWxlcyk7XG4gICAgY29uc3QgZGVmYXVsdExvY2FsZSA9IERlZmF1bHRMb2NhbGU7XG4gICAgY29uc3QgY29udmVydGVkTG9jYWxlID0gY29udmVydFRvU3VwcG9ydGVkTG9jYWxlKGxvY2FsZSwgTG9jYWxlTWFwKTtcbiAgICBjb25zdCBpc1N1cHBvcnRlZExvY2FsZSA9IHN1cHBvcnRlZExvY2FsZXMuaW5jbHVkZXMoY29udmVydGVkTG9jYWxlKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBsb2NhbGU6IGlzU3VwcG9ydGVkTG9jYWxlID8gY29udmVydGVkTG9jYWxlIDogZGVmYXVsdExvY2FsZSxcbiAgICAgICAgcnRsOiBSVExMb2NhbGVzLmluY2x1ZGVzKGxvY2FsZSlcbiAgICB9O1xufVxuLyoqXG4gKiBGZXRjaGVzIHRoZSBsb2NhbGUgZmlsZSBvZiB0aGUgZ2l2ZW4gY29tcG9uZW50OyBkZWZhdWx0cyB0byBgXCJlblwiYCBsb2NhbGVcbiAqIEBwYXJhbSBjb21wb25lbnROYW1lXG4gKiBAcGFyYW0gcHJvcHNcbiAqIEBwYXJhbSBsb2NhbGVcbiAqIEBwYXJhbSByZXNvdXJjZXNVcmxcbiAqIEBwYXJhbSBwcm9wcy5wYXRoXG4gKiBAcGFyYW0gcHJvcHMubG9jYWxlXG4gKiBAcGFyYW0gcHJvcHMuYmFzZVVSTFxuICovXG5hc3luYyBmdW5jdGlvbiBmZXRjaExvY2FsZVN0cmluZ3MocHJvcHMpIHtcbiAgICBjb25zdCB7IHBhdGgsIGxvY2FsZSwgYmFzZVVSTCB9ID0gcHJvcHM7XG4gICAgLy8gVXNpbmcgdGhlIGdldFB1YmxpY1BhdGggbWV0aG9kIHRoYXQgbGV2ZXJhZ2VzIGBkYXRhLXJlc291cmNlcy11cmxgIGN1cnJlbnRseSB0aGlzIGlzIG5vdCB3b3JraW5nLlxuICAgIC8vIGNvbnN0IHJVcmwgPSBnZXRQdWJsaWNQYXRoKGNvbXBvbmVudE5hbWUpIHx8IHJlc291cmNlc1VybDtcbiAgICBsZXQgbG9jYWxlRGF0YSA9IHt9O1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7YmFzZVVSTH10OW4vJHtwYXRofS50OW4uJHtsb2NhbGV9Lmpzb25gKTtcbiAgICAgICAgbG9jYWxlRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgY29uc3QgZGVmYXVsdFJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7YmFzZVVSTH10OW4vJHtwYXRofS50OW4uJHtEZWZhdWx0TG9jYWxlfS5qc29uYCk7XG4gICAgICAgIGxvY2FsZURhdGEgPSBhd2FpdCBkZWZhdWx0UmVzcG9uc2UuanNvbigpO1xuICAgIH1cbiAgICByZXR1cm4gbG9jYWxlRGF0YTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGZldGNoQ29tcG9uZW50TG9jYWxlU3RyaW5ncyhlbGVtZW50LCBiYXNlVVJMKSB7XG4gICAgY29uc3QgY29tcG9uZW50TmFtZSA9IGVsZW1lbnQudGFnTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIGNvbnN0IHsgbG9jYWxlLCBydGwgfSA9IGdldExvY2FsZUluZm8oZWxlbWVudCk7XG4gICAgY29uc3Qgc3RyaW5ncyA9IGF3YWl0IGZldGNoTG9jYWxlU3RyaW5ncyh7IHBhdGg6IGNvbXBvbmVudE5hbWUsIGxvY2FsZSwgYmFzZVVSTCB9KTtcbiAgICByZXR1cm4geyBzdHJpbmdzLCBkaXI6IGdldERpcmVjdGlvbkJhc2VkT25SVEwocnRsKSwgbG9jYWxlOiBsb2NhbGUgfTtcbn1cbi8qKlxuICogRm9ybWF0cyBhIFVSTCB0byBsaW5rIHRvXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsIHRoZSB1cmwgc3RyaW5nIGZyb20gYWZ0ZXIgdGhlIGxvY2FsZVxuICogQHBhcmFtIHtzdHJpbmd9IGJhc2VQYXRoIHRoZSBiYXNlIHBhdGggZnJvbSB0aGUgc2lnbmVkIGluIHBvcnRhbCBvYmplY3QuXG4gKiBAcGFyYW0ge3N0cmluZ30gbG9jYWxlIHRoZSBsb2NhbGUgYWJicmV2aWF0aW9uIGZvciB0aGUgYnJvd3Nlci5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IHRoZSBmb3JtYXR0ZWQgdXJsLlxuICovXG5mdW5jdGlvbiBmb3JtYXRMb2NhbGl6ZWRIZWxwVXJsKHVybCwgYmFzZVBhdGgsIGxvY2FsZSA9IFwiZW5cIikge1xuICAgIGxldCBsb2NhbGVTYW5pdGl6ZWQgPSBsb2NhbGU7XG4gICAgY29uc3QgbG9jYWxlTWFwS2V5cyA9IE9iamVjdC5rZXlzKExvY2FsZU1hcCk7XG4gICAgaWYgKGxvY2FsZU1hcEtleXMuaW5jbHVkZXMobG9jYWxlKSA9PT0gdHJ1ZSkge1xuICAgICAgICBsb2NhbGVTYW5pdGl6ZWQgPSBMb2NhbGVNYXBbbG9jYWxlXTtcbiAgICB9XG4gICAgY29uc3QgbG9jYWxlSW5Mb3dlckNhc2UgPSBsb2NhbGVTYW5pdGl6ZWQudG9Mb2NhbGVMb3dlckNhc2UoKTtcbiAgICBpZiAoU3VwcG9ydGVkT25saW5lSGVscExvY2FsZXMuaW5jbHVkZXMobG9jYWxlSW5Mb3dlckNhc2UpID09PSB0cnVlKSB7XG4gICAgICAgIC8vIGZvbGxvd2luZyByZWdleCB0ZXN0cyAvZW4vIGlzIHByZXNlbnQgaW4gdXJsIGFuZCByZXBsYWNlcyBpdCB3aXRoIHRoZSBsb2NhbGVcbiAgICAgICAgLy8gaHR0cHM6Ly9kb2NkZXYuYXJjZ2lzLmNvbS9lbi9hcmNnaXMtb25saW5lL2FuYWx5emUvYWdncmVnYXRlLXBvaW50cy1tdi5odG1cbiAgICAgICAgLy8gc2VsZiBSZXNwb25zZSBvbmx5IHByb3ZpZGVzIHdpdGggYGVuYCBsb2NhbGUgbm90IGFzIHBlciB0aGUgdXNlciBsb2NhbGUgb3IgY3VycmVudCBhcHAgbG9jYWxlXG4gICAgICAgIC8vIHNvIHdlIG5lZWQgdGhpcyByZXBsYWNlIGNhbGwuXG4gICAgICAgIGJhc2VQYXRoID0gYmFzZVBhdGgucmVwbGFjZSgvXmh0dHBzPzpcXC9cXC9bXi9dK1xcL2VuLywgKG1hdGNoKSA9PiBtYXRjaC5yZXBsYWNlKFwiZW5cIiwgbG9jYWxlSW5Mb3dlckNhc2UpKTtcbiAgICB9XG4gICAgY29uc3QgbGVhcm5Nb3JlVXJsID0gYCR7YmFzZVBhdGh9YW5hbHl6ZS8ke3VybH1gO1xuICAgIHJldHVybiBsZWFybk1vcmVVcmw7XG59XG5cbmV4cG9ydCB7IERlZmF1bHRMb2NhbGUgYXMgRCwgU3VwcG9ydGVkTG9jYWxlcyBhcyBTLCBnZXREaXJlY3Rpb25CYXNlZE9uUlRMIGFzIGEsIGZldGNoQ29tcG9uZW50TG9jYWxlU3RyaW5ncyBhcyBiLCBmb3JtYXRMb2NhbGl6ZWRIZWxwVXJsIGFzIGYsIGdldExvY2FsZUluZm8gYXMgZyB9O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1sb2NhbGl6YXRpb24taGVscGVyLTQ4MTliNjdkLmpzLm1hcCIsImltcG9ydCB7IGkgYXMgaXNBcnJheUxpa2UsIGEgYXMgaXNBcnJheSwgYiBhcyBpc0J1ZmZlciwgYyBhcyBpc1R5cGVkQXJyYXksIGQgYXMgaXNBcmd1bWVudHMsIGcgYXMgZ2V0VGFnLCBlIGFzIGlzUHJvdG90eXBlLCBmIGFzIGJhc2VLZXlzLCBoIGFzIGlzUGxhaW5PYmplY3QgfSBmcm9tICcuL19nZXRUYWctOTZhZjAyOWQuanMnO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgbWFwVGFnID0gJ1tvYmplY3QgTWFwXScsXG4gICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XSc7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYW4gZW1wdHkgb2JqZWN0LCBjb2xsZWN0aW9uLCBtYXAsIG9yIHNldC5cbiAqXG4gKiBPYmplY3RzIGFyZSBjb25zaWRlcmVkIGVtcHR5IGlmIHRoZXkgaGF2ZSBubyBvd24gZW51bWVyYWJsZSBzdHJpbmcga2V5ZWRcbiAqIHByb3BlcnRpZXMuXG4gKlxuICogQXJyYXktbGlrZSB2YWx1ZXMgc3VjaCBhcyBgYXJndW1lbnRzYCBvYmplY3RzLCBhcnJheXMsIGJ1ZmZlcnMsIHN0cmluZ3MsIG9yXG4gKiBqUXVlcnktbGlrZSBjb2xsZWN0aW9ucyBhcmUgY29uc2lkZXJlZCBlbXB0eSBpZiB0aGV5IGhhdmUgYSBgbGVuZ3RoYCBvZiBgMGAuXG4gKiBTaW1pbGFybHksIG1hcHMgYW5kIHNldHMgYXJlIGNvbnNpZGVyZWQgZW1wdHkgaWYgdGhleSBoYXZlIGEgYHNpemVgIG9mIGAwYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBlbXB0eSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzRW1wdHkobnVsbCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0VtcHR5KHRydWUpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNFbXB0eSgxKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzRW1wdHkoWzEsIDIsIDNdKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0VtcHR5KHsgJ2EnOiAxIH0pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNFbXB0eSh2YWx1ZSkge1xuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChpc0FycmF5TGlrZSh2YWx1ZSkgJiZcbiAgICAgIChpc0FycmF5KHZhbHVlKSB8fCB0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycgfHwgdHlwZW9mIHZhbHVlLnNwbGljZSA9PSAnZnVuY3Rpb24nIHx8XG4gICAgICAgIGlzQnVmZmVyKHZhbHVlKSB8fCBpc1R5cGVkQXJyYXkodmFsdWUpIHx8IGlzQXJndW1lbnRzKHZhbHVlKSkpIHtcbiAgICByZXR1cm4gIXZhbHVlLmxlbmd0aDtcbiAgfVxuICB2YXIgdGFnID0gZ2V0VGFnKHZhbHVlKTtcbiAgaWYgKHRhZyA9PSBtYXBUYWcgfHwgdGFnID09IHNldFRhZykge1xuICAgIHJldHVybiAhdmFsdWUuc2l6ZTtcbiAgfVxuICBpZiAoaXNQcm90b3R5cGUodmFsdWUpKSB7XG4gICAgcmV0dXJuICFiYXNlS2V5cyh2YWx1ZSkubGVuZ3RoO1xuICB9XG4gIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBrZXkpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG5jb25zdCBSRlRfVFlQRSA9IFwiUmFzdGVyRnVuY3Rpb25UZW1wbGF0ZVwiO1xuY29uc3QgVFlQRV9LRVlXT1JEID0gXCJ0eXBlXCI7XG5jb25zdCBSRlZfVFlQRSA9IFwiUmFzdGVyRnVuY3Rpb25WYXJpYWJsZVwiO1xuY29uc3QgQVJHU19LRVlXT1JEID0gXCJhcmd1bWVudHNcIjtcbmNvbnN0IEZVTkNUSU9OX0tFWVdPUkQgPSBcImZ1bmN0aW9uXCI7XG5mdW5jdGlvbiBpc1JlZmVyZW5jZWRPYmplY3Qob2JqKSB7XG4gICAgaWYgKCFvYmopIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAob2JqLl9vYmplY3RfcmVmX2lkICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGlzTnVtYmVyKHgpIHtcbiAgICB4ID0gU3RyaW5nKHgpLnRyaW0oKTtcbiAgICBpZiAoeCA9PT0gXCJcIikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiAvXlsrLV0/KFxcZCspPyhcXC5cXGQrKT8kLy50ZXN0KHgpO1xufVxuZnVuY3Rpb24gaXNXaWRnZXRWYWx1ZUJvb2xlYW4oeCkge1xuICAgIHggPSBTdHJpbmcoeCkudHJpbSgpO1xuICAgIHJldHVybiBbXCJ0cnVlXCIsIFwiZmFsc2VcIl0uaW5kZXhPZih4KSA+PSAwO1xufVxuZnVuY3Rpb24gaXNDb2xvclJhbXAocmZ4QXJnKSB7XG4gICAgaWYgKCFyZnhBcmcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAocmZ4QXJnLnR5cGUgJiYgcmZ4QXJnLnR5cGUudG9Mb3dlckNhc2UoKS5pbmRleE9mKFwiY29sb3JyYW1wXCIpID49IDApIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChyZnhBcmcudmFsdWUgJiYgcmZ4QXJnLnZhbHVlLnR5cGUgJiYgcmZ4QXJnLnZhbHVlLnR5cGUudG9Mb3dlckNhc2UoKS5pbmRleE9mKFwiY29sb3JyYW1wXCIpID49IDApIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGlzUmVjb3JkU2V0KHJmeEFyZykge1xuICAgIHJldHVybiByZnhBcmcudHlwZSAmJiByZnhBcmcudHlwZS50b0xvd2VyQ2FzZSgpLmluZGV4T2YoXCJyZWNvcmRzZXRcIikgPj0gMDtcbn1cbi8qKlxuICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBnaXZlbiBSRlQgZWxlbWVudCBpcyBhbiBSRnggYXJndW1lbnQuXG4gKlxuICogQHBhcmFtIHthbnl9IHJmdEVsZW1lbnQgLSBUaGUgUkZUIGVsZW1lbnQgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIGlmIHRoZSBnaXZlbiBlbGVtZW50IGlzIFJhc3RlckZ1bmN0aW9uVGVtcGxhdGUsXG4gKiBSYXN0ZXJGdW5jdGlvblZhcmlhYmxlLCBpc0NvbG9yUmFtcCwgaXNSZWNvcmRTZXQ7IGBmYWxzZWAgb3RoZXJ3aXNlLlxuICovXG5mdW5jdGlvbiBpc1JGeEFyZyhyZnRFbGVtZW50KSB7XG4gICAgaWYgKCFyZnRFbGVtZW50KSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgdHlwZSA9IHJmdEVsZW1lbnQudHlwZTtcbiAgICByZXR1cm4gW1JGVF9UWVBFLCBSRlZfVFlQRV0uaW5kZXhPZih0eXBlKSA+PSAwIHx8IGlzQ29sb3JSYW1wKHJmdEVsZW1lbnQpIHx8IGlzUmVjb3JkU2V0KHJmdEVsZW1lbnQpO1xufVxuLyoqXG4gKiBEZXRlcm1pbmVzIGlmIHRoZSBpbnB1dCBpcyBhIEZlYXR1cmVMYXllclxuICogQHBhcmFtIHtfX2VzcmkuTGF5ZXJ9IGxheWVyIHRoZSBsYXllciB0byBjaGVjayB0aGUgdHlwZSBvZlxuICogQHJldHVybnMge2xheWVyIGlzIF9fZXNyaS5GZWF0dXJlTGF5ZXJ9IGxheWVyIGlzIGEgRmVhdHVyZUxheWVyXG4gKi9cbmZ1bmN0aW9uIGlzRmVhdHVyZUxheWVyKGxheWVyKSB7XG4gICAgcmV0dXJuIGxheWVyLnR5cGUgPT09IFwiZmVhdHVyZVwiO1xufVxuLyoqXG4gKiBEZXRlcm1pbmVzIGlmIHRoZSBpbnB1dCBpcyBhIFRpbGVMYXllclxuICogQHBhcmFtIHtfX2VzcmkuTGF5ZXJ9IGxheWVyIHRoZSBsYXllciB0byBjaGVjayB0aGUgdHlwZSBvZlxuICogQHJldHVybnMge2xheWVyIGlzIF9fZXNyaS5UaWxlTGF5ZXJ9IGxheWVyIGlzIGEgVGlsZUxheWVyXG4gKi9cbmZ1bmN0aW9uIGlzVGlsZUxheWVyKGxheWVyKSB7XG4gICAgcmV0dXJuIGxheWVyLnR5cGUgPT09IFwidGlsZVwiO1xufVxuLyoqXG4gKiBEZXRlcm1pbmVzIGlmIHRoZSBpbnB1dCBpcyBhIEltYWdlcnlUaWxlTGF5ZXJcbiAqIEBwYXJhbSB7X19lc3JpLkxheWVyfSBsYXllciB0aGUgbGF5ZXIgdG8gY2hlY2sgdGhlIHR5cGUgb2ZcbiAqIEByZXR1cm5zIHtsYXllciBpcyBfX2VzcmkuSW1hZ2VyeUxheWVyfSBsYXllciBpcyBhIEltYWdlcnlMYXllclxuICovXG5mdW5jdGlvbiBpc0R5bmFtaWNJbWFnZXJ5TGF5ZXIobGF5ZXIpIHtcbiAgICByZXR1cm4gKGxheWVyLnR5cGUgPT09IFwiaW1hZ2VyeS10aWxlXCIgJiZcbiAgICAgICAgbGF5ZXIuc291cmNlSlNPTi5jYXBhYmlsaXRpZXMudG9Mb3dlckNhc2UoKS5pbmRleE9mKFwidGlsZXNvbmx5XCIpIDwgMCk7XG59XG4vKipcbiAqIERldGVybWluZXMgaWYgdGhlIGlucHV0IGlzIGEgSW1hZ2VyeUxheWVyXG4gKiBAcGFyYW0ge19fZXNyaS5MYXllcn0gbGF5ZXIgdGhlIGxheWVyIHRvIGNoZWNrIHRoZSB0eXBlIG9mXG4gKiBAcmV0dXJucyB7bGF5ZXIgaXMgX19lc3JpLkltYWdlcnlMYXllcn0gbGF5ZXIgaXMgYSBJbWFnZXJ5TGF5ZXJcbiAqL1xuZnVuY3Rpb24gaXNJbWFnZXJ5TGF5ZXIobGF5ZXIpIHtcbiAgICByZXR1cm4gbGF5ZXIudHlwZSA9PT0gXCJpbWFnZXJ5XCIgfHwgaXNEeW5hbWljSW1hZ2VyeUxheWVyKGxheWVyKTtcbn1cbi8qKlxuICogRGV0ZXJtaW5lcyBpZiB0aGUgaW5wdXQgaXMgYSBJbWFnZXJ5VGlsZUxheWVyXG4gKiBAcGFyYW0ge19fZXNyaS5MYXllcn0gbGF5ZXIgdGhlIGxheWVyIHRvIGNoZWNrIHRoZSB0eXBlIG9mXG4gKiBAcmV0dXJucyB7bGF5ZXIgaXMgX19lc3JpLkltYWdlcnlUaWxlTGF5ZXJ9IGxheWVyIGlzIGEgSW1hZ2VyeVRpbGVMYXllclxuICovXG5mdW5jdGlvbiBpc0ltYWdlcnlUaWxlTGF5ZXIobGF5ZXIpIHtcbiAgICByZXR1cm4gbGF5ZXIudHlwZSA9PT0gXCJpbWFnZXJ5LXRpbGVcIiAmJiAhaXNEeW5hbWljSW1hZ2VyeUxheWVyKGxheWVyKTtcbn1cbmZ1bmN0aW9uIGlzRXZlcnlQcm9wZXJ0eUVtcHR5KHZhbHVlKSB7XG4gICAgbGV0IGlzQWxsUHJvcHNFbXB0eSA9IHRydWU7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJiBpc0FycmF5KHZhbHVlKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgLy8gdXNpbmcgZm9yLWluIGFzIGl0IHdpbGwgd29yayB3aXRoIG9iamVjdHMgd2l0aCBwcm9wZXJ0aWVzIHRoYXQgc2V0IHZpYSBhY2Nlc3NvcnMgYXMgd2VsbFxuICAgICAgICBmb3IgKGNvbnN0IHByb3AgaW4gdmFsdWUpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgd2lsbCB0ZWxsIHRoZSBUeXBlU2NyaXB0IGNvbXBpbGVyIHRoYXQgdGhlIG9iaiBvYmplY3QgaGFzIGEgc3RyaW5nIGluZGV4IHNpZ25hdHVyZSxcbiAgICAgICAgICAgIC8vIGFuZCB3aWxsIGFsbG93IHRvIGFjY2VzcyBpdHMgcHJvcGVydGllcyB1c2luZyBhIHN0cmluZyBpbmRleCB3aXRob3V0IGdldHRpbmcgdGhlIFwiRWxlbWVudCBpbXBsaWNpdGx5IGhhcyBhbiAnYW55JyB0eXBlXCIgZXJyb3IuXG4gICAgICAgICAgICBjb25zdCBwcm9wVmFsdWUgPSB2YWx1ZT8uW3Byb3BdO1xuICAgICAgICAgICAgaWYgKHZhbHVlLmhhc093blByb3BlcnR5KHByb3ApID09PSB0cnVlICYmIHByb3BWYWx1ZSAhPT0gdW5kZWZpbmVkICYmIHByb3BWYWx1ZSAhPT0gbnVsbCAmJiBwcm9wVmFsdWUgIT09IFwiXCIpIHtcbiAgICAgICAgICAgICAgICBpc0FsbFByb3BzRW1wdHkgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaXNBbGxQcm9wc0VtcHR5O1xufVxuLyoqXG4gKiBDaGVjayBmb3IgYW4gZW1wdHkgdmFsdWUgZm9yIGRhdGEgaXRlbXMgbGlrZSBHUFN0cmluZyBhbmQgRmllbGQuXG4gKiBAcGFyYW0gdmFsdWUgZGF0YSBpdGVtIHZhbHVlLlxuICogQHJldHVybnMgd2hldGhlciB0aGUgdmFsdWUgaXMgY29uc2lkZXJlZCBlbXB0eS5cbiAqL1xuZnVuY3Rpb24gaXNFbXB0eURhdGFJdGVtKHZhbHVlKSB7XG4gICAgcmV0dXJuICh2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgIHZhbHVlID09PSBudWxsIHx8XG4gICAgICAgIC8vIHNpbmdsZS1zZWxlY3QsIFwiXCIgaXMgYSBzcGVjaWFsIGNhc2UgZm9yIHN0cmluZ3NcbiAgICAgICAgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJiB2YWx1ZSA9PT0gXCJcIikgfHxcbiAgICAgICAgLy8gc2luZ2xlLXNlbGVjdCwgZW1wdHkgb2JqZWN0cyBhcmUgYSBzcGVjaWFsIGNhc2UgZm9yIG5lc3RlZCB2YWx1ZXNcbiAgICAgICAgKGlzUGxhaW5PYmplY3QodmFsdWUpICYmIGlzRW1wdHkodmFsdWUpKSB8fFxuICAgICAgICAvLyBtdWx0aS1zZWxlY3RcbiAgICAgICAgKEFycmF5LmlzQXJyYXkodmFsdWUpICYmIHZhbHVlLmxlbmd0aCA8IDEpIHx8XG4gICAgICAgIC8vIG9ubHkgdGVzdGluZyBvYmplY3RzIHdoaWNoIGFyZSBub3QgYXJyYXlzXG4gICAgICAgIC8vIFRPRE86IGNvbWJpbmUgaXNFdmVyeVByb3BlcnR5RW1wdHkgYW5kIGlzRW1wdHlEYXRhSXRlbSB0byBzaW5nbGUgZnVuY3Rpb25cbiAgICAgICAgKHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJiBpc0FycmF5KHZhbHVlKSA9PT0gZmFsc2UgJiYgaXNFdmVyeVByb3BlcnR5RW1wdHkodmFsdWUpKSk7XG59XG5cbmV4cG9ydCB7IEFSR1NfS0VZV09SRCBhcyBBLCBGVU5DVElPTl9LRVlXT1JEIGFzIEYsIFJGVl9UWVBFIGFzIFIsIFRZUEVfS0VZV09SRCBhcyBULCBpc1JGeEFyZyBhcyBhLCBSRlRfVFlQRSBhcyBiLCBpc1JlZmVyZW5jZWRPYmplY3QgYXMgYywgaXNOdW1iZXIgYXMgZCwgaXNXaWRnZXRWYWx1ZUJvb2xlYW4gYXMgZSwgaXNDb2xvclJhbXAgYXMgZiwgaXNSZWNvcmRTZXQgYXMgZywgaXNGZWF0dXJlTGF5ZXIgYXMgaCwgaXNFbXB0eURhdGFJdGVtIGFzIGksIGlzVGlsZUxheWVyIGFzIGosIGlzRHluYW1pY0ltYWdlcnlMYXllciBhcyBrLCBpc0ltYWdlcnlMYXllciBhcyBsLCBpc0ltYWdlcnlUaWxlTGF5ZXIgYXMgbSB9O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD10eXBlLWdhdXJkcy0xODQwNzQ3Zi5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=