"use strict";
(self["webpackChunkexb_client"] = self["webpackChunkexb_client"] || []).push([["vendors-extensions_widgets_arcgis_analysis_node_modules_arcgis_arcgis-raster-function-editor_-320569"],{

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/arcgis-raster-function-editor/dist/esm/color-ramp-8935ed29.js":
/*!*******************************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/arcgis-raster-function-editor/dist/esm/color-ramp-8935ed29.js ***!
  \*******************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   C: () => (/* binding */ COLOR_RAMP_TYPES),
/* harmony export */   a: () => (/* binding */ getRasterSymbolStylerProps),
/* harmony export */   b: () => (/* binding */ getRFxArgColorRampValue),
/* harmony export */   c: () => (/* binding */ convertColorRampToColors),
/* harmony export */   d: () => (/* binding */ createColorRamp),
/* harmony export */   e: () => (/* binding */ getColormapFromColorRamp),
/* harmony export */   f: () => (/* binding */ getDefaultColorRamp),
/* harmony export */   g: () => (/* binding */ getColorRampColors)
/* harmony export */ });
/* harmony import */ var _arcgis_core_rest_support_AlgorithmicColorRamp_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @arcgis/core/rest/support/AlgorithmicColorRamp.js */ "@arcgis/core/rest/support/AlgorithmicColorRamp.js");
/* harmony import */ var _arcgis_core_rest_support_MultipartColorRamp_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @arcgis/core/rest/support/MultipartColorRamp.js */ "@arcgis/core/rest/support/MultipartColorRamp.js");
/* harmony import */ var _arcgis_core_Color_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @arcgis/core/Color.js */ "@arcgis/core/Color.js");
/* harmony import */ var _colorRampUtils_8bdd46c5_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./colorRampUtils-8bdd46c5.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/arcgis-raster-function-editor/dist/esm/colorRampUtils-8bdd46c5.js");
/* harmony import */ var _type_gaurds_1840747f_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./type-gaurds-1840747f.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/arcgis-raster-function-editor/dist/esm/type-gaurds-1840747f.js");






/* eslint-disable @typescript-eslint/restrict-plus-operands */
const COLOR_RAMP_TYPES = {
    ALGORITHMIC_COLOR_RAMP: "AlgorithmicColorRamp",
    MULTIPART_COLOR_RAMP: "MultiPartColorRamp"
};
// Ported from https://devtopia.esri.com/WebGIS/arcgis-js-api/blob/13c39065cc0917772e9db5aed74ab60367317a17/esri/core/colorUtils.ts#L196
function hsv2rgb(color) {
    //handling case where h is negative, computing value between 0-360
    const h = ((color.h + 360) % 360) / 60; //0-6
    const s = color.s / 100; //0-1
    const v = (color.v / 100) * 255; //0-255 (v is max color)
    const c = v * s; //chroma max-min
    const x = c * (1 - Math.abs((h % 2) - 1));
    let rgb;
    switch (Math.floor(h)) {
        case 0:
            rgb = { r: c, g: x, b: 0 };
            break;
        case 1:
            rgb = { r: x, g: c, b: 0 };
            break;
        case 2:
            rgb = { r: 0, g: c, b: x };
            break;
        case 3:
            rgb = { r: 0, g: x, b: c };
            break;
        case 4:
            rgb = { r: x, g: 0, b: c };
            break;
        case 5:
        case 6:
            rgb = { r: c, g: 0, b: x };
            break;
        default:
            rgb = { r: 0, g: 0, b: 0 };
    }
    rgb.r = Math.round(rgb.r + v - c);
    rgb.g = Math.round(rgb.g + v - c);
    rgb.b = Math.round(rgb.b + v - c);
    return rgb;
}
// ported from: https://devtopia.esri.com/WebGIS/arcgis-js-api/blob/7162aee51c2f6d4f011e8b62bbc5a3e858476b75/esri/layers/support/rasterFunctions/rasterFunctionHelper.ts#L362-L375
function convertAlgorithmColorRamp(ramp) {
    // looks like this is always hsv
    const algorithm = ramp.algorithm ?? "esriHSVAlgorithm";
    let { FromColor: fromColor, ToColor: toColor } = ramp;
    if (!Array.isArray(fromColor)) {
        const { r, g, b } = hsv2rgb({ h: fromColor.Hue, s: fromColor.Saturation, v: fromColor.Value });
        fromColor = [r, g, b, fromColor.AlphaValue];
    }
    if (!Array.isArray(toColor)) {
        const { r, g, b } = hsv2rgb({ h: toColor.Hue, s: toColor.Saturation, v: toColor.Value });
        toColor = [r, g, b, toColor.AlphaValue];
    }
    return { type: "algorithmic", algorithm, fromColor, toColor };
}
/**
 * Returns an array of color values from a given color ramp object.
 * @param {any} colorRamp - The color ramp object to extract colors from.
 * @returns {number[][]} An array of color values.
 */
function getColorRampColors(colorRamp) {
    // type === "multipart" from jsapi
    // type === COLOR_RAMP_TYPES.MULTIPART_COLOR_RAMP from persistence
    if (colorRamp?.type === "multipart") {
        const colorRamps = colorRamp.colorRamps;
        const colors = colorRamps.map((_colorRamp) => _colorRamp.fromColor);
        colors.push(colorRamps[colorRamps.length - 1].toColor);
        return colors;
    }
    else {
        return [colorRamp.fromColor, colorRamp.toColor];
    }
}
/**
 * Formats an array of colors to RGBA format.
 * @param {number[][]} colors - The array of colors to format.
 * @returns {Object[]} - The formatted colors in RGBA format.
 */
function formatColorsToRGBA(colors) {
    if (!Array.isArray(colors)) {
        return colors;
    }
    // check if color is already RGBA
    const invalidColors = colors.some((color) => !(0,_type_gaurds_1840747f_js__WEBPACK_IMPORTED_MODULE_4__.i)(color.r) && !(0,_type_gaurds_1840747f_js__WEBPACK_IMPORTED_MODULE_4__.i)(color.g) && !(0,_type_gaurds_1840747f_js__WEBPACK_IMPORTED_MODULE_4__.i)(color.b));
    if (invalidColors) {
        return colors;
    }
    // TODO: Alpha (a) is set to 1, as transparency cannot be modified
    return colors.map((color) => ({ r: color[0], g: color[1], b: color[2], a: 1 }));
}
/**
 * Function is used to convert colorramp object which has "ArrayOfColorRamp",
 * "FromColor", "ToColor" to a colorramp with "fromColor", "toColor", "colorramps"
 * @param colorRamp
 * @returns
 */
function normalizeColorRamp(colorRamp) {
    if ((0,_type_gaurds_1840747f_js__WEBPACK_IMPORTED_MODULE_4__.i)(colorRamp)) {
        return;
    }
    const isNormalized = !(0,_type_gaurds_1840747f_js__WEBPACK_IMPORTED_MODULE_4__.i)(colorRamp.colorRamps) ||
        (!(0,_type_gaurds_1840747f_js__WEBPACK_IMPORTED_MODULE_4__.i)(colorRamp.toColor) && !(0,_type_gaurds_1840747f_js__WEBPACK_IMPORTED_MODULE_4__.i)(colorRamp.fromColor));
    if (isNormalized) {
        return colorRamp;
    }
    const colorRampType = colorRamp?.type === COLOR_RAMP_TYPES.MULTIPART_COLOR_RAMP ? "multipart" : "algorithmic";
    const colorRamps = colorRampType === "multipart"
        ? colorRamp.ArrayOfColorRamp.map((colorramp) => {
            return convertAlgorithmColorRamp(colorramp);
        })
        : undefined;
    const algorithmicColorRamp = colorRampType === "algorithmic" ? convertAlgorithmColorRamp(colorRamp) : undefined;
    const normalizedColorRamp = {
        type: colorRampType,
        colorRamps: colorRamps,
        fromColor: algorithmicColorRamp?.fromColor,
        toColor: algorithmicColorRamp?.toColor
    };
    return normalizedColorRamp;
}
/**
 * TODO: Make function typesafe when jsapi is updated
 * Converts a color ramp to colors array. (Used to persist colorramps)
 * @param {Object} colorRamp - The color ramp to convert.
 * @returns {Object} - The converted color ramp with colors array.
 */
function convertColorRampToColors(colorRamp) {
    const normalizedColorRamp = normalizeColorRamp(colorRamp);
    const rgbColors = getColorRampColors(normalizedColorRamp);
    return formatColorsToRGBA(rgbColors);
}
/**
 * Returns an array of formatted color ramp objects for getRasterSymbolStylerProps.
 * @returns {ColorRamp[]} An array of formatted color ramp objects.
 */
function getRasterColorRamps() {
    const formattedColorRamps = [];
    _colorRampUtils_8bdd46c5_js__WEBPACK_IMPORTED_MODULE_3__.P.forEach((jsonRamp) => {
        // colorRampUtils.PREDEFINED_JSON_COLOR_RAMPS.forEach((jsonRamp) => {
        formattedColorRamps.push({
            name: _colorRampUtils_8bdd46c5_js__WEBPACK_IMPORTED_MODULE_3__.a.toJSON(jsonRamp.id),
            // name: colorRampUtils.colorRampDict.toJSON(jsonRamp.id),
            stops: getColorRampColors(jsonRamp)
                .reverse()
                .map((stop) => new _arcgis_core_Color_js__WEBPACK_IMPORTED_MODULE_2__["default"](stop)),
            tags: ["raster"]
        });
    });
    return formattedColorRamps;
}
/**
 * Returns an object containing symbol styling properties for raster symbols.
 * @param {any} props - The props object.
 * @param {any} options - The options object.
 * @returns {any} An object containing symbol styling properties.
 */
function getRasterSymbolStylerProps(props, options) {
    const { portal } = props;
    const { extraColorRamps = [], defaultColors } = options;
    //fill
    const fill = {
        color: defaultColors || [new _arcgis_core_Color_js__WEBPACK_IMPORTED_MODULE_2__["default"]([0, 0, 0, 1]), new _arcgis_core_Color_js__WEBPACK_IMPORTED_MODULE_2__["default"]([255, 255, 255, 1])]
    };
    //stroke
    const stroke = {
        color: new _arcgis_core_Color_js__WEBPACK_IMPORTED_MODULE_2__["default"]([0, 0, 0, 0.5]),
        size: 1,
        style: "solid"
    };
    // add raster color schemes
    const colorRamps = getRasterColorRamps();
    colorRamps.push(...extraColorRamps);
    colorRamps.sort((a) => (a.tags.indexOf("raster") > -1 ? -1 : 1));
    return {
        portal,
        sections: {
            marker: {
                parts: {
                    preview: false,
                    rotation: false,
                    size: false
                }
            },
            fill: {
                type: "color-ramp",
                style: "continuous",
                colorRamps: colorRamps,
                open: true,
                colorRampsOpen: true,
                transparencyOpen: false,
                parts: {
                    colorRamps: true,
                    transparency: false
                },
                extraParts: {
                    autoStrokeAdjust: false,
                    width: true
                }
            }
        },
        stroke: {
            ...stroke,
            color: [
                new _arcgis_core_Color_js__WEBPACK_IMPORTED_MODULE_2__["default"]([13, 38, 68, 1]),
                new _arcgis_core_Color_js__WEBPACK_IMPORTED_MODULE_2__["default"]([56, 98, 122, 1]),
                new _arcgis_core_Color_js__WEBPACK_IMPORTED_MODULE_2__["default"]([98, 158, 176, 1]),
                new _arcgis_core_Color_js__WEBPACK_IMPORTED_MODULE_2__["default"]([177, 205, 194, 1]),
                new _arcgis_core_Color_js__WEBPACK_IMPORTED_MODULE_2__["default"]([255, 252, 212, 1])
            ]
        },
        fill
    };
}
/**
 * Returns the value of a color ramp object as an RFX argument.
 * @param {MultipartColorRamp | AlgorithmicColorRamp} colorramp - The color ramp object to convert.
 * @returns {any} The value of the color ramp object as an RFX argument.
 */
function getRFxArgColorRampValue(colorramp) {
    const normalizedColorRamp = normalizeColorRamp(colorramp);
    if ((0,_type_gaurds_1840747f_js__WEBPACK_IMPORTED_MODULE_4__.i)(normalizedColorRamp)) {
        return;
    }
    // if colorRamp doesn't have clone method, it breaks workflow
    const isColorrampObject = (0,_type_gaurds_1840747f_js__WEBPACK_IMPORTED_MODULE_4__.i)(normalizedColorRamp?.clone);
    const isMultipart = colorramp?.type === "multipart" || colorramp?.type === COLOR_RAMP_TYPES.MULTIPART_COLOR_RAMP;
    const colorRampObject = isColorrampObject
        ? isMultipart
            ? _arcgis_core_rest_support_MultipartColorRamp_js__WEBPACK_IMPORTED_MODULE_1__["default"].fromJSON(normalizedColorRamp)
            : _arcgis_core_rest_support_AlgorithmicColorRamp_js__WEBPACK_IMPORTED_MODULE_0__["default"].fromJSON(normalizedColorRamp)
        : normalizedColorRamp;
    return (0,_colorRampUtils_8bdd46c5_js__WEBPACK_IMPORTED_MODULE_3__.g)(colorRampObject);
    // return colorRampUtils.getRFxArgColorRampValue(colorRampObject);
}
/**
 * create a colorramp from array of colors;
 * required before passing to getRFxArgColorRampValue
 */
function createColorRamp(colors) {
    const rampColors = [];
    for (let i = 0; i < colors.length - 1; i++) {
        rampColors[i] = new _arcgis_core_rest_support_AlgorithmicColorRamp_js__WEBPACK_IMPORTED_MODULE_0__["default"]({
            algorithm: "hsv",
            fromColor: colors[i],
            toColor: colors[i + 1] || new _arcgis_core_Color_js__WEBPACK_IMPORTED_MODULE_2__["default"]({ r: 255, g: 255, b: 255, a: 1 })
        });
    }
    if (colors.length > 2) {
        const colorRamp = new _arcgis_core_rest_support_MultipartColorRamp_js__WEBPACK_IMPORTED_MODULE_1__["default"]({
            colorRamps: rampColors
        });
        return colorRamp;
    }
    return rampColors[0];
}
/**
 * convert a ColorRamp object/json to a raster colormap. Default colormap size is 256.
 */
function getColormapFromColorRamp(colorRamp, numColors) {
    return (0,_colorRampUtils_8bdd46c5_js__WEBPACK_IMPORTED_MODULE_3__.c)(colorRamp, { numColors });
    // return colorRampUtils.convertColorRampToColormap(colorRamp, { numColors });
}
function getDefaultColorRamp() {
    const fistColorramp = _colorRampUtils_8bdd46c5_js__WEBPACK_IMPORTED_MODULE_3__.P[0];
    // const fistColorramp = colorRampUtils.PREDEFINED_JSON_COLOR_RAMPS[0];
    return _arcgis_core_rest_support_MultipartColorRamp_js__WEBPACK_IMPORTED_MODULE_1__["default"].fromJSON(fistColorramp);
}



//# sourceMappingURL=color-ramp-8935ed29.js.map

/***/ }),

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/arcgis-raster-function-editor/dist/esm/ui-utils-928a4096.js":
/*!*****************************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/arcgis-raster-function-editor/dist/esm/ui-utils-928a4096.js ***!
  \*****************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   C: () => (/* binding */ CalciteScale),
/* harmony export */   U: () => (/* binding */ UIDefaults),
/* harmony export */   a: () => (/* binding */ CalciteOverlayPositioning)
/* harmony export */ });
const UIDefaults = {
    Scale: "s",
    PopoverTimer: 60
};
const CalciteScale = {
    s: "s",
    m: "m"
};
const CalciteOverlayPositioning = {
    absolute: "absolute",
    fixed: "fixed"
};



//# sourceMappingURL=ui-utils-928a4096.js.map

/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid2lkZ2V0cy9jaHVua3MvYXJjZ2lzX2FuYWx5c2lzX25vZGVfbW9kdWxlc19hcmNnaXNfYXJjZ2lzLXJhc3Rlci1mdW5jdGlvbi1lZGl0b3JfLTMyMDU2OS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQXFGO0FBQ0o7QUFDbkM7QUFDdUg7QUFDcEc7O0FBRWpFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUMsNkJBQTZCO0FBQzdCLHFDQUFxQztBQUNyQyxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUseUNBQXlDO0FBQ25EO0FBQ0EsZ0JBQWdCLFVBQVUsWUFBWSwrREFBK0Q7QUFDckc7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFVBQVUsWUFBWSx5REFBeUQ7QUFDL0Y7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsYUFBYSxZQUFZO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCLGFBQWEsVUFBVTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsMkRBQWUsY0FBYywyREFBZSxjQUFjLDJEQUFlO0FBQzNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLDZDQUE2QztBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSwyREFBZTtBQUN2QjtBQUNBO0FBQ0EsMEJBQTBCLDJEQUFlO0FBQ3pDLFVBQVUsMkRBQWUsd0JBQXdCLDJEQUFlO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxhQUFhO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLElBQUksMERBQTJCO0FBQy9CO0FBQ0E7QUFDQSxrQkFBa0IsMERBQWE7QUFDL0I7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLDZEQUFTO0FBQzVDO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQSxZQUFZLFNBQVM7QUFDckIsWUFBWSxzQ0FBc0M7QUFDbEQ7QUFDQTtBQUNBLHFDQUFxQyw2REFBUyxvQkFBb0IsNkRBQVM7QUFDM0U7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDZEQUFTO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDZEQUFTO0FBQzdCLG9CQUFvQiw2REFBUztBQUM3QixvQkFBb0IsNkRBQVM7QUFDN0Isb0JBQW9CLDZEQUFTO0FBQzdCLG9CQUFvQiw2REFBUztBQUM3QjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVywyQ0FBMkM7QUFDdEQsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLFFBQVEsMkRBQWU7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLDJEQUFlO0FBQzdDO0FBQ0E7QUFDQTtBQUNBLGNBQWMsZ0dBQTJCO0FBQ3pDLGNBQWMsa0dBQTZCO0FBQzNDO0FBQ0EsV0FBVyw4REFBeUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix1QkFBdUI7QUFDM0MsNEJBQTRCLHlGQUFvQjtBQUNoRDtBQUNBO0FBQ0EsMENBQTBDLDZEQUFTLEdBQUcsOEJBQThCO0FBQ3BGLFNBQVM7QUFDVDtBQUNBO0FBQ0EsOEJBQThCLHVGQUFrQjtBQUNoRDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyw4REFBMEIsY0FBYyxXQUFXO0FBQzlELHFFQUFxRSxXQUFXO0FBQ2hGO0FBQ0E7QUFDQSwwQkFBMEIsMERBQTJCO0FBQ3JEO0FBQ0EsV0FBVyxnR0FBMkI7QUFDdEM7O0FBRXVPOztBQUV2Tzs7Ozs7Ozs7Ozs7Ozs7OztBQ3RSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRThFOztBQUU5RSIsInNvdXJjZXMiOlsid2VicGFjazovL2V4Yi1jbGllbnQvLi9leHRlbnNpb25zL3dpZGdldHMvYXJjZ2lzL2FuYWx5c2lzL25vZGVfbW9kdWxlcy9AYXJjZ2lzL2FyY2dpcy1yYXN0ZXItZnVuY3Rpb24tZWRpdG9yL2Rpc3QvZXNtL2NvbG9yLXJhbXAtODkzNWVkMjkuanMiLCJ3ZWJwYWNrOi8vZXhiLWNsaWVudC8uL2V4dGVuc2lvbnMvd2lkZ2V0cy9hcmNnaXMvYW5hbHlzaXMvbm9kZV9tb2R1bGVzL0BhcmNnaXMvYXJjZ2lzLXJhc3Rlci1mdW5jdGlvbi1lZGl0b3IvZGlzdC9lc20vdWktdXRpbHMtOTI4YTQwOTYuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IEFsZ29yaXRobWljQ29sb3JSYW1wIGZyb20gJ0BhcmNnaXMvY29yZS9yZXN0L3N1cHBvcnQvQWxnb3JpdGhtaWNDb2xvclJhbXAuanMnO1xuaW1wb3J0IE11bHRpcGFydENvbG9yUmFtcCBmcm9tICdAYXJjZ2lzL2NvcmUvcmVzdC9zdXBwb3J0L011bHRpcGFydENvbG9yUmFtcC5qcyc7XG5pbXBvcnQgZXNyaUNvbG9yIGZyb20gJ0BhcmNnaXMvY29yZS9Db2xvci5qcyc7XG5pbXBvcnQgeyBnIGFzIGdldFJGeEFyZ0NvbG9yUmFtcFZhbHVlJDEsIGMgYXMgY29udmVydENvbG9yUmFtcFRvQ29sb3JtYXAsIFAgYXMgUFJFREVGSU5FRF9KU09OX0NPTE9SX1JBTVBTLCBhIGFzIGNvbG9yUmFtcERpY3QgfSBmcm9tICcuL2NvbG9yUmFtcFV0aWxzLThiZGQ0NmM1LmpzJztcbmltcG9ydCB7IGkgYXMgaXNFbXB0eURhdGFJdGVtIH0gZnJvbSAnLi90eXBlLWdhdXJkcy0xODQwNzQ3Zi5qcyc7XG5cbi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9yZXN0cmljdC1wbHVzLW9wZXJhbmRzICovXG5jb25zdCBDT0xPUl9SQU1QX1RZUEVTID0ge1xuICAgIEFMR09SSVRITUlDX0NPTE9SX1JBTVA6IFwiQWxnb3JpdGhtaWNDb2xvclJhbXBcIixcbiAgICBNVUxUSVBBUlRfQ09MT1JfUkFNUDogXCJNdWx0aVBhcnRDb2xvclJhbXBcIlxufTtcbi8vIFBvcnRlZCBmcm9tIGh0dHBzOi8vZGV2dG9waWEuZXNyaS5jb20vV2ViR0lTL2FyY2dpcy1qcy1hcGkvYmxvYi8xM2MzOTA2NWNjMDkxNzc3MmU5ZGI1YWVkNzRhYjYwMzY3MzE3YTE3L2VzcmkvY29yZS9jb2xvclV0aWxzLnRzI0wxOTZcbmZ1bmN0aW9uIGhzdjJyZ2IoY29sb3IpIHtcbiAgICAvL2hhbmRsaW5nIGNhc2Ugd2hlcmUgaCBpcyBuZWdhdGl2ZSwgY29tcHV0aW5nIHZhbHVlIGJldHdlZW4gMC0zNjBcbiAgICBjb25zdCBoID0gKChjb2xvci5oICsgMzYwKSAlIDM2MCkgLyA2MDsgLy8wLTZcbiAgICBjb25zdCBzID0gY29sb3IucyAvIDEwMDsgLy8wLTFcbiAgICBjb25zdCB2ID0gKGNvbG9yLnYgLyAxMDApICogMjU1OyAvLzAtMjU1ICh2IGlzIG1heCBjb2xvcilcbiAgICBjb25zdCBjID0gdiAqIHM7IC8vY2hyb21hIG1heC1taW5cbiAgICBjb25zdCB4ID0gYyAqICgxIC0gTWF0aC5hYnMoKGggJSAyKSAtIDEpKTtcbiAgICBsZXQgcmdiO1xuICAgIHN3aXRjaCAoTWF0aC5mbG9vcihoKSkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICByZ2IgPSB7IHI6IGMsIGc6IHgsIGI6IDAgfTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICByZ2IgPSB7IHI6IHgsIGc6IGMsIGI6IDAgfTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICByZ2IgPSB7IHI6IDAsIGc6IGMsIGI6IHggfTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICByZ2IgPSB7IHI6IDAsIGc6IHgsIGI6IGMgfTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICByZ2IgPSB7IHI6IHgsIGc6IDAsIGI6IGMgfTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDU6XG4gICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgIHJnYiA9IHsgcjogYywgZzogMCwgYjogeCB9O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZ2IgPSB7IHI6IDAsIGc6IDAsIGI6IDAgfTtcbiAgICB9XG4gICAgcmdiLnIgPSBNYXRoLnJvdW5kKHJnYi5yICsgdiAtIGMpO1xuICAgIHJnYi5nID0gTWF0aC5yb3VuZChyZ2IuZyArIHYgLSBjKTtcbiAgICByZ2IuYiA9IE1hdGgucm91bmQocmdiLmIgKyB2IC0gYyk7XG4gICAgcmV0dXJuIHJnYjtcbn1cbi8vIHBvcnRlZCBmcm9tOiBodHRwczovL2RldnRvcGlhLmVzcmkuY29tL1dlYkdJUy9hcmNnaXMtanMtYXBpL2Jsb2IvNzE2MmFlZTUxYzJmNmQ0ZjAxMWU4YjYyYmJjNWEzZTg1ODQ3NmI3NS9lc3JpL2xheWVycy9zdXBwb3J0L3Jhc3RlckZ1bmN0aW9ucy9yYXN0ZXJGdW5jdGlvbkhlbHBlci50cyNMMzYyLUwzNzVcbmZ1bmN0aW9uIGNvbnZlcnRBbGdvcml0aG1Db2xvclJhbXAocmFtcCkge1xuICAgIC8vIGxvb2tzIGxpa2UgdGhpcyBpcyBhbHdheXMgaHN2XG4gICAgY29uc3QgYWxnb3JpdGhtID0gcmFtcC5hbGdvcml0aG0gPz8gXCJlc3JpSFNWQWxnb3JpdGhtXCI7XG4gICAgbGV0IHsgRnJvbUNvbG9yOiBmcm9tQ29sb3IsIFRvQ29sb3I6IHRvQ29sb3IgfSA9IHJhbXA7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGZyb21Db2xvcikpIHtcbiAgICAgICAgY29uc3QgeyByLCBnLCBiIH0gPSBoc3YycmdiKHsgaDogZnJvbUNvbG9yLkh1ZSwgczogZnJvbUNvbG9yLlNhdHVyYXRpb24sIHY6IGZyb21Db2xvci5WYWx1ZSB9KTtcbiAgICAgICAgZnJvbUNvbG9yID0gW3IsIGcsIGIsIGZyb21Db2xvci5BbHBoYVZhbHVlXTtcbiAgICB9XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHRvQ29sb3IpKSB7XG4gICAgICAgIGNvbnN0IHsgciwgZywgYiB9ID0gaHN2MnJnYih7IGg6IHRvQ29sb3IuSHVlLCBzOiB0b0NvbG9yLlNhdHVyYXRpb24sIHY6IHRvQ29sb3IuVmFsdWUgfSk7XG4gICAgICAgIHRvQ29sb3IgPSBbciwgZywgYiwgdG9Db2xvci5BbHBoYVZhbHVlXTtcbiAgICB9XG4gICAgcmV0dXJuIHsgdHlwZTogXCJhbGdvcml0aG1pY1wiLCBhbGdvcml0aG0sIGZyb21Db2xvciwgdG9Db2xvciB9O1xufVxuLyoqXG4gKiBSZXR1cm5zIGFuIGFycmF5IG9mIGNvbG9yIHZhbHVlcyBmcm9tIGEgZ2l2ZW4gY29sb3IgcmFtcCBvYmplY3QuXG4gKiBAcGFyYW0ge2FueX0gY29sb3JSYW1wIC0gVGhlIGNvbG9yIHJhbXAgb2JqZWN0IHRvIGV4dHJhY3QgY29sb3JzIGZyb20uXG4gKiBAcmV0dXJucyB7bnVtYmVyW11bXX0gQW4gYXJyYXkgb2YgY29sb3IgdmFsdWVzLlxuICovXG5mdW5jdGlvbiBnZXRDb2xvclJhbXBDb2xvcnMoY29sb3JSYW1wKSB7XG4gICAgLy8gdHlwZSA9PT0gXCJtdWx0aXBhcnRcIiBmcm9tIGpzYXBpXG4gICAgLy8gdHlwZSA9PT0gQ09MT1JfUkFNUF9UWVBFUy5NVUxUSVBBUlRfQ09MT1JfUkFNUCBmcm9tIHBlcnNpc3RlbmNlXG4gICAgaWYgKGNvbG9yUmFtcD8udHlwZSA9PT0gXCJtdWx0aXBhcnRcIikge1xuICAgICAgICBjb25zdCBjb2xvclJhbXBzID0gY29sb3JSYW1wLmNvbG9yUmFtcHM7XG4gICAgICAgIGNvbnN0IGNvbG9ycyA9IGNvbG9yUmFtcHMubWFwKChfY29sb3JSYW1wKSA9PiBfY29sb3JSYW1wLmZyb21Db2xvcik7XG4gICAgICAgIGNvbG9ycy5wdXNoKGNvbG9yUmFtcHNbY29sb3JSYW1wcy5sZW5ndGggLSAxXS50b0NvbG9yKTtcbiAgICAgICAgcmV0dXJuIGNvbG9ycztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBbY29sb3JSYW1wLmZyb21Db2xvciwgY29sb3JSYW1wLnRvQ29sb3JdO1xuICAgIH1cbn1cbi8qKlxuICogRm9ybWF0cyBhbiBhcnJheSBvZiBjb2xvcnMgdG8gUkdCQSBmb3JtYXQuXG4gKiBAcGFyYW0ge251bWJlcltdW119IGNvbG9ycyAtIFRoZSBhcnJheSBvZiBjb2xvcnMgdG8gZm9ybWF0LlxuICogQHJldHVybnMge09iamVjdFtdfSAtIFRoZSBmb3JtYXR0ZWQgY29sb3JzIGluIFJHQkEgZm9ybWF0LlxuICovXG5mdW5jdGlvbiBmb3JtYXRDb2xvcnNUb1JHQkEoY29sb3JzKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGNvbG9ycykpIHtcbiAgICAgICAgcmV0dXJuIGNvbG9ycztcbiAgICB9XG4gICAgLy8gY2hlY2sgaWYgY29sb3IgaXMgYWxyZWFkeSBSR0JBXG4gICAgY29uc3QgaW52YWxpZENvbG9ycyA9IGNvbG9ycy5zb21lKChjb2xvcikgPT4gIWlzRW1wdHlEYXRhSXRlbShjb2xvci5yKSAmJiAhaXNFbXB0eURhdGFJdGVtKGNvbG9yLmcpICYmICFpc0VtcHR5RGF0YUl0ZW0oY29sb3IuYikpO1xuICAgIGlmIChpbnZhbGlkQ29sb3JzKSB7XG4gICAgICAgIHJldHVybiBjb2xvcnM7XG4gICAgfVxuICAgIC8vIFRPRE86IEFscGhhIChhKSBpcyBzZXQgdG8gMSwgYXMgdHJhbnNwYXJlbmN5IGNhbm5vdCBiZSBtb2RpZmllZFxuICAgIHJldHVybiBjb2xvcnMubWFwKChjb2xvcikgPT4gKHsgcjogY29sb3JbMF0sIGc6IGNvbG9yWzFdLCBiOiBjb2xvclsyXSwgYTogMSB9KSk7XG59XG4vKipcbiAqIEZ1bmN0aW9uIGlzIHVzZWQgdG8gY29udmVydCBjb2xvcnJhbXAgb2JqZWN0IHdoaWNoIGhhcyBcIkFycmF5T2ZDb2xvclJhbXBcIixcbiAqIFwiRnJvbUNvbG9yXCIsIFwiVG9Db2xvclwiIHRvIGEgY29sb3JyYW1wIHdpdGggXCJmcm9tQ29sb3JcIiwgXCJ0b0NvbG9yXCIsIFwiY29sb3JyYW1wc1wiXG4gKiBAcGFyYW0gY29sb3JSYW1wXG4gKiBAcmV0dXJuc1xuICovXG5mdW5jdGlvbiBub3JtYWxpemVDb2xvclJhbXAoY29sb3JSYW1wKSB7XG4gICAgaWYgKGlzRW1wdHlEYXRhSXRlbShjb2xvclJhbXApKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgaXNOb3JtYWxpemVkID0gIWlzRW1wdHlEYXRhSXRlbShjb2xvclJhbXAuY29sb3JSYW1wcykgfHxcbiAgICAgICAgKCFpc0VtcHR5RGF0YUl0ZW0oY29sb3JSYW1wLnRvQ29sb3IpICYmICFpc0VtcHR5RGF0YUl0ZW0oY29sb3JSYW1wLmZyb21Db2xvcikpO1xuICAgIGlmIChpc05vcm1hbGl6ZWQpIHtcbiAgICAgICAgcmV0dXJuIGNvbG9yUmFtcDtcbiAgICB9XG4gICAgY29uc3QgY29sb3JSYW1wVHlwZSA9IGNvbG9yUmFtcD8udHlwZSA9PT0gQ09MT1JfUkFNUF9UWVBFUy5NVUxUSVBBUlRfQ09MT1JfUkFNUCA/IFwibXVsdGlwYXJ0XCIgOiBcImFsZ29yaXRobWljXCI7XG4gICAgY29uc3QgY29sb3JSYW1wcyA9IGNvbG9yUmFtcFR5cGUgPT09IFwibXVsdGlwYXJ0XCJcbiAgICAgICAgPyBjb2xvclJhbXAuQXJyYXlPZkNvbG9yUmFtcC5tYXAoKGNvbG9ycmFtcCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGNvbnZlcnRBbGdvcml0aG1Db2xvclJhbXAoY29sb3JyYW1wKTtcbiAgICAgICAgfSlcbiAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgY29uc3QgYWxnb3JpdGhtaWNDb2xvclJhbXAgPSBjb2xvclJhbXBUeXBlID09PSBcImFsZ29yaXRobWljXCIgPyBjb252ZXJ0QWxnb3JpdGhtQ29sb3JSYW1wKGNvbG9yUmFtcCkgOiB1bmRlZmluZWQ7XG4gICAgY29uc3Qgbm9ybWFsaXplZENvbG9yUmFtcCA9IHtcbiAgICAgICAgdHlwZTogY29sb3JSYW1wVHlwZSxcbiAgICAgICAgY29sb3JSYW1wczogY29sb3JSYW1wcyxcbiAgICAgICAgZnJvbUNvbG9yOiBhbGdvcml0aG1pY0NvbG9yUmFtcD8uZnJvbUNvbG9yLFxuICAgICAgICB0b0NvbG9yOiBhbGdvcml0aG1pY0NvbG9yUmFtcD8udG9Db2xvclxuICAgIH07XG4gICAgcmV0dXJuIG5vcm1hbGl6ZWRDb2xvclJhbXA7XG59XG4vKipcbiAqIFRPRE86IE1ha2UgZnVuY3Rpb24gdHlwZXNhZmUgd2hlbiBqc2FwaSBpcyB1cGRhdGVkXG4gKiBDb252ZXJ0cyBhIGNvbG9yIHJhbXAgdG8gY29sb3JzIGFycmF5LiAoVXNlZCB0byBwZXJzaXN0IGNvbG9ycmFtcHMpXG4gKiBAcGFyYW0ge09iamVjdH0gY29sb3JSYW1wIC0gVGhlIGNvbG9yIHJhbXAgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IC0gVGhlIGNvbnZlcnRlZCBjb2xvciByYW1wIHdpdGggY29sb3JzIGFycmF5LlxuICovXG5mdW5jdGlvbiBjb252ZXJ0Q29sb3JSYW1wVG9Db2xvcnMoY29sb3JSYW1wKSB7XG4gICAgY29uc3Qgbm9ybWFsaXplZENvbG9yUmFtcCA9IG5vcm1hbGl6ZUNvbG9yUmFtcChjb2xvclJhbXApO1xuICAgIGNvbnN0IHJnYkNvbG9ycyA9IGdldENvbG9yUmFtcENvbG9ycyhub3JtYWxpemVkQ29sb3JSYW1wKTtcbiAgICByZXR1cm4gZm9ybWF0Q29sb3JzVG9SR0JBKHJnYkNvbG9ycyk7XG59XG4vKipcbiAqIFJldHVybnMgYW4gYXJyYXkgb2YgZm9ybWF0dGVkIGNvbG9yIHJhbXAgb2JqZWN0cyBmb3IgZ2V0UmFzdGVyU3ltYm9sU3R5bGVyUHJvcHMuXG4gKiBAcmV0dXJucyB7Q29sb3JSYW1wW119IEFuIGFycmF5IG9mIGZvcm1hdHRlZCBjb2xvciByYW1wIG9iamVjdHMuXG4gKi9cbmZ1bmN0aW9uIGdldFJhc3RlckNvbG9yUmFtcHMoKSB7XG4gICAgY29uc3QgZm9ybWF0dGVkQ29sb3JSYW1wcyA9IFtdO1xuICAgIFBSRURFRklORURfSlNPTl9DT0xPUl9SQU1QUy5mb3JFYWNoKChqc29uUmFtcCkgPT4ge1xuICAgICAgICAvLyBjb2xvclJhbXBVdGlscy5QUkVERUZJTkVEX0pTT05fQ09MT1JfUkFNUFMuZm9yRWFjaCgoanNvblJhbXApID0+IHtcbiAgICAgICAgZm9ybWF0dGVkQ29sb3JSYW1wcy5wdXNoKHtcbiAgICAgICAgICAgIG5hbWU6IGNvbG9yUmFtcERpY3QudG9KU09OKGpzb25SYW1wLmlkKSxcbiAgICAgICAgICAgIC8vIG5hbWU6IGNvbG9yUmFtcFV0aWxzLmNvbG9yUmFtcERpY3QudG9KU09OKGpzb25SYW1wLmlkKSxcbiAgICAgICAgICAgIHN0b3BzOiBnZXRDb2xvclJhbXBDb2xvcnMoanNvblJhbXApXG4gICAgICAgICAgICAgICAgLnJldmVyc2UoKVxuICAgICAgICAgICAgICAgIC5tYXAoKHN0b3ApID0+IG5ldyBlc3JpQ29sb3Ioc3RvcCkpLFxuICAgICAgICAgICAgdGFnczogW1wicmFzdGVyXCJdXG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiBmb3JtYXR0ZWRDb2xvclJhbXBzO1xufVxuLyoqXG4gKiBSZXR1cm5zIGFuIG9iamVjdCBjb250YWluaW5nIHN5bWJvbCBzdHlsaW5nIHByb3BlcnRpZXMgZm9yIHJhc3RlciBzeW1ib2xzLlxuICogQHBhcmFtIHthbnl9IHByb3BzIC0gVGhlIHByb3BzIG9iamVjdC5cbiAqIEBwYXJhbSB7YW55fSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgb2JqZWN0LlxuICogQHJldHVybnMge2FueX0gQW4gb2JqZWN0IGNvbnRhaW5pbmcgc3ltYm9sIHN0eWxpbmcgcHJvcGVydGllcy5cbiAqL1xuZnVuY3Rpb24gZ2V0UmFzdGVyU3ltYm9sU3R5bGVyUHJvcHMocHJvcHMsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IHBvcnRhbCB9ID0gcHJvcHM7XG4gICAgY29uc3QgeyBleHRyYUNvbG9yUmFtcHMgPSBbXSwgZGVmYXVsdENvbG9ycyB9ID0gb3B0aW9ucztcbiAgICAvL2ZpbGxcbiAgICBjb25zdCBmaWxsID0ge1xuICAgICAgICBjb2xvcjogZGVmYXVsdENvbG9ycyB8fCBbbmV3IGVzcmlDb2xvcihbMCwgMCwgMCwgMV0pLCBuZXcgZXNyaUNvbG9yKFsyNTUsIDI1NSwgMjU1LCAxXSldXG4gICAgfTtcbiAgICAvL3N0cm9rZVxuICAgIGNvbnN0IHN0cm9rZSA9IHtcbiAgICAgICAgY29sb3I6IG5ldyBlc3JpQ29sb3IoWzAsIDAsIDAsIDAuNV0pLFxuICAgICAgICBzaXplOiAxLFxuICAgICAgICBzdHlsZTogXCJzb2xpZFwiXG4gICAgfTtcbiAgICAvLyBhZGQgcmFzdGVyIGNvbG9yIHNjaGVtZXNcbiAgICBjb25zdCBjb2xvclJhbXBzID0gZ2V0UmFzdGVyQ29sb3JSYW1wcygpO1xuICAgIGNvbG9yUmFtcHMucHVzaCguLi5leHRyYUNvbG9yUmFtcHMpO1xuICAgIGNvbG9yUmFtcHMuc29ydCgoYSkgPT4gKGEudGFncy5pbmRleE9mKFwicmFzdGVyXCIpID4gLTEgPyAtMSA6IDEpKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBwb3J0YWwsXG4gICAgICAgIHNlY3Rpb25zOiB7XG4gICAgICAgICAgICBtYXJrZXI6IHtcbiAgICAgICAgICAgICAgICBwYXJ0czoge1xuICAgICAgICAgICAgICAgICAgICBwcmV2aWV3OiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgcm90YXRpb246IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBzaXplOiBmYWxzZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmaWxsOiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJjb2xvci1yYW1wXCIsXG4gICAgICAgICAgICAgICAgc3R5bGU6IFwiY29udGludW91c1wiLFxuICAgICAgICAgICAgICAgIGNvbG9yUmFtcHM6IGNvbG9yUmFtcHMsXG4gICAgICAgICAgICAgICAgb3BlbjogdHJ1ZSxcbiAgICAgICAgICAgICAgICBjb2xvclJhbXBzT3BlbjogdHJ1ZSxcbiAgICAgICAgICAgICAgICB0cmFuc3BhcmVuY3lPcGVuOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBwYXJ0czoge1xuICAgICAgICAgICAgICAgICAgICBjb2xvclJhbXBzOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICB0cmFuc3BhcmVuY3k6IGZhbHNlXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBleHRyYVBhcnRzOiB7XG4gICAgICAgICAgICAgICAgICAgIGF1dG9TdHJva2VBZGp1c3Q6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICB3aWR0aDogdHJ1ZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgc3Ryb2tlOiB7XG4gICAgICAgICAgICAuLi5zdHJva2UsXG4gICAgICAgICAgICBjb2xvcjogW1xuICAgICAgICAgICAgICAgIG5ldyBlc3JpQ29sb3IoWzEzLCAzOCwgNjgsIDFdKSxcbiAgICAgICAgICAgICAgICBuZXcgZXNyaUNvbG9yKFs1NiwgOTgsIDEyMiwgMV0pLFxuICAgICAgICAgICAgICAgIG5ldyBlc3JpQ29sb3IoWzk4LCAxNTgsIDE3NiwgMV0pLFxuICAgICAgICAgICAgICAgIG5ldyBlc3JpQ29sb3IoWzE3NywgMjA1LCAxOTQsIDFdKSxcbiAgICAgICAgICAgICAgICBuZXcgZXNyaUNvbG9yKFsyNTUsIDI1MiwgMjEyLCAxXSlcbiAgICAgICAgICAgIF1cbiAgICAgICAgfSxcbiAgICAgICAgZmlsbFxuICAgIH07XG59XG4vKipcbiAqIFJldHVybnMgdGhlIHZhbHVlIG9mIGEgY29sb3IgcmFtcCBvYmplY3QgYXMgYW4gUkZYIGFyZ3VtZW50LlxuICogQHBhcmFtIHtNdWx0aXBhcnRDb2xvclJhbXAgfCBBbGdvcml0aG1pY0NvbG9yUmFtcH0gY29sb3JyYW1wIC0gVGhlIGNvbG9yIHJhbXAgb2JqZWN0IHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7YW55fSBUaGUgdmFsdWUgb2YgdGhlIGNvbG9yIHJhbXAgb2JqZWN0IGFzIGFuIFJGWCBhcmd1bWVudC5cbiAqL1xuZnVuY3Rpb24gZ2V0UkZ4QXJnQ29sb3JSYW1wVmFsdWUoY29sb3JyYW1wKSB7XG4gICAgY29uc3Qgbm9ybWFsaXplZENvbG9yUmFtcCA9IG5vcm1hbGl6ZUNvbG9yUmFtcChjb2xvcnJhbXApO1xuICAgIGlmIChpc0VtcHR5RGF0YUl0ZW0obm9ybWFsaXplZENvbG9yUmFtcCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBpZiBjb2xvclJhbXAgZG9lc24ndCBoYXZlIGNsb25lIG1ldGhvZCwgaXQgYnJlYWtzIHdvcmtmbG93XG4gICAgY29uc3QgaXNDb2xvcnJhbXBPYmplY3QgPSBpc0VtcHR5RGF0YUl0ZW0obm9ybWFsaXplZENvbG9yUmFtcD8uY2xvbmUpO1xuICAgIGNvbnN0IGlzTXVsdGlwYXJ0ID0gY29sb3JyYW1wPy50eXBlID09PSBcIm11bHRpcGFydFwiIHx8IGNvbG9ycmFtcD8udHlwZSA9PT0gQ09MT1JfUkFNUF9UWVBFUy5NVUxUSVBBUlRfQ09MT1JfUkFNUDtcbiAgICBjb25zdCBjb2xvclJhbXBPYmplY3QgPSBpc0NvbG9ycmFtcE9iamVjdFxuICAgICAgICA/IGlzTXVsdGlwYXJ0XG4gICAgICAgICAgICA/IE11bHRpcGFydENvbG9yUmFtcC5mcm9tSlNPTihub3JtYWxpemVkQ29sb3JSYW1wKVxuICAgICAgICAgICAgOiBBbGdvcml0aG1pY0NvbG9yUmFtcC5mcm9tSlNPTihub3JtYWxpemVkQ29sb3JSYW1wKVxuICAgICAgICA6IG5vcm1hbGl6ZWRDb2xvclJhbXA7XG4gICAgcmV0dXJuIGdldFJGeEFyZ0NvbG9yUmFtcFZhbHVlJDEoY29sb3JSYW1wT2JqZWN0KTtcbiAgICAvLyByZXR1cm4gY29sb3JSYW1wVXRpbHMuZ2V0UkZ4QXJnQ29sb3JSYW1wVmFsdWUoY29sb3JSYW1wT2JqZWN0KTtcbn1cbi8qKlxuICogY3JlYXRlIGEgY29sb3JyYW1wIGZyb20gYXJyYXkgb2YgY29sb3JzO1xuICogcmVxdWlyZWQgYmVmb3JlIHBhc3NpbmcgdG8gZ2V0UkZ4QXJnQ29sb3JSYW1wVmFsdWVcbiAqL1xuZnVuY3Rpb24gY3JlYXRlQ29sb3JSYW1wKGNvbG9ycykge1xuICAgIGNvbnN0IHJhbXBDb2xvcnMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbG9ycy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgcmFtcENvbG9yc1tpXSA9IG5ldyBBbGdvcml0aG1pY0NvbG9yUmFtcCh7XG4gICAgICAgICAgICBhbGdvcml0aG06IFwiaHN2XCIsXG4gICAgICAgICAgICBmcm9tQ29sb3I6IGNvbG9yc1tpXSxcbiAgICAgICAgICAgIHRvQ29sb3I6IGNvbG9yc1tpICsgMV0gfHwgbmV3IGVzcmlDb2xvcih7IHI6IDI1NSwgZzogMjU1LCBiOiAyNTUsIGE6IDEgfSlcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChjb2xvcnMubGVuZ3RoID4gMikge1xuICAgICAgICBjb25zdCBjb2xvclJhbXAgPSBuZXcgTXVsdGlwYXJ0Q29sb3JSYW1wKHtcbiAgICAgICAgICAgIGNvbG9yUmFtcHM6IHJhbXBDb2xvcnNcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBjb2xvclJhbXA7XG4gICAgfVxuICAgIHJldHVybiByYW1wQ29sb3JzWzBdO1xufVxuLyoqXG4gKiBjb252ZXJ0IGEgQ29sb3JSYW1wIG9iamVjdC9qc29uIHRvIGEgcmFzdGVyIGNvbG9ybWFwLiBEZWZhdWx0IGNvbG9ybWFwIHNpemUgaXMgMjU2LlxuICovXG5mdW5jdGlvbiBnZXRDb2xvcm1hcEZyb21Db2xvclJhbXAoY29sb3JSYW1wLCBudW1Db2xvcnMpIHtcbiAgICByZXR1cm4gY29udmVydENvbG9yUmFtcFRvQ29sb3JtYXAoY29sb3JSYW1wLCB7IG51bUNvbG9ycyB9KTtcbiAgICAvLyByZXR1cm4gY29sb3JSYW1wVXRpbHMuY29udmVydENvbG9yUmFtcFRvQ29sb3JtYXAoY29sb3JSYW1wLCB7IG51bUNvbG9ycyB9KTtcbn1cbmZ1bmN0aW9uIGdldERlZmF1bHRDb2xvclJhbXAoKSB7XG4gICAgY29uc3QgZmlzdENvbG9ycmFtcCA9IFBSRURFRklORURfSlNPTl9DT0xPUl9SQU1QU1swXTtcbiAgICAvLyBjb25zdCBmaXN0Q29sb3JyYW1wID0gY29sb3JSYW1wVXRpbHMuUFJFREVGSU5FRF9KU09OX0NPTE9SX1JBTVBTWzBdO1xuICAgIHJldHVybiBNdWx0aXBhcnRDb2xvclJhbXAuZnJvbUpTT04oZmlzdENvbG9ycmFtcCk7XG59XG5cbmV4cG9ydCB7IENPTE9SX1JBTVBfVFlQRVMgYXMgQywgZ2V0UmFzdGVyU3ltYm9sU3R5bGVyUHJvcHMgYXMgYSwgZ2V0UkZ4QXJnQ29sb3JSYW1wVmFsdWUgYXMgYiwgY29udmVydENvbG9yUmFtcFRvQ29sb3JzIGFzIGMsIGNyZWF0ZUNvbG9yUmFtcCBhcyBkLCBnZXRDb2xvcm1hcEZyb21Db2xvclJhbXAgYXMgZSwgZ2V0RGVmYXVsdENvbG9yUmFtcCBhcyBmLCBnZXRDb2xvclJhbXBDb2xvcnMgYXMgZyB9O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb2xvci1yYW1wLTg5MzVlZDI5LmpzLm1hcCIsImNvbnN0IFVJRGVmYXVsdHMgPSB7XG4gICAgU2NhbGU6IFwic1wiLFxuICAgIFBvcG92ZXJUaW1lcjogNjBcbn07XG5jb25zdCBDYWxjaXRlU2NhbGUgPSB7XG4gICAgczogXCJzXCIsXG4gICAgbTogXCJtXCJcbn07XG5jb25zdCBDYWxjaXRlT3ZlcmxheVBvc2l0aW9uaW5nID0ge1xuICAgIGFic29sdXRlOiBcImFic29sdXRlXCIsXG4gICAgZml4ZWQ6IFwiZml4ZWRcIlxufTtcblxuZXhwb3J0IHsgQ2FsY2l0ZVNjYWxlIGFzIEMsIFVJRGVmYXVsdHMgYXMgVSwgQ2FsY2l0ZU92ZXJsYXlQb3NpdGlvbmluZyBhcyBhIH07XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVpLXV0aWxzLTkyOGE0MDk2LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==