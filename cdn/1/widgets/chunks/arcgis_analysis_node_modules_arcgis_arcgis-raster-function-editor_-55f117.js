"use strict";
(self["webpackChunkexb_client"] = self["webpackChunkexb_client"] || []).push([["vendors-extensions_widgets_arcgis_analysis_node_modules_arcgis_arcgis-raster-function-editor_-55f117"],{

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/arcgis-raster-function-editor/dist/esm/common-strings.ca-ada3d60c.js":
/*!**************************************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/arcgis-raster-function-editor/dist/esm/common-strings.ca-ada3d60c.js ***!
  \**************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   addRaster: () => (/* binding */ addRaster),
/* harmony export */   addScalar: () => (/* binding */ addScalar),
/* harmony export */   breadcrumb: () => (/* binding */ breadcrumb),
/* harmony export */   breadcrumbEditor: () => (/* binding */ breadcrumbEditor),
/* harmony export */   cancel: () => (/* binding */ cancel),
/* harmony export */   category: () => (/* binding */ category),
/* harmony export */   categoryNames: () => (/* binding */ categoryNames),
/* harmony export */   close: () => (/* binding */ close),
/* harmony export */   copy: () => (/* binding */ copy),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   defaultModelName: () => (/* binding */ defaultModelName),
/* harmony export */   definitionQuery: () => (/* binding */ definitionQuery),
/* harmony export */   description: () => (/* binding */ description),
/* harmony export */   deselectFunction: () => (/* binding */ deselectFunction),
/* harmony export */   details: () => (/* binding */ details),
/* harmony export */   dialogTitle: () => (/* binding */ dialogTitle),
/* harmony export */   dontSave: () => (/* binding */ dontSave),
/* harmony export */   enterFURL: () => (/* binding */ enterFURL),
/* harmony export */   enterURL: () => (/* binding */ enterURL),
/* harmony export */   error: () => (/* binding */ error),
/* harmony export */   errorTitle: () => (/* binding */ errorTitle),
/* harmony export */   everyone: () => (/* binding */ everyone),
/* harmony export */   f32PixelType: () => (/* binding */ f32PixelType),
/* harmony export */   f64PixelType: () => (/* binding */ f64PixelType),
/* harmony export */   failedToLoadLayer: () => (/* binding */ failedToLoadLayer),
/* harmony export */   folder: () => (/* binding */ folder),
/* harmony export */   general: () => (/* binding */ general),
/* harmony export */   groupFieldName: () => (/* binding */ groupFieldName),
/* harmony export */   groupItemsBy: () => (/* binding */ groupItemsBy),
/* harmony export */   groups: () => (/* binding */ groups),
/* harmony export */   invalidRFTMessage: () => (/* binding */ invalidRFTMessage),
/* harmony export */   isDataset: () => (/* binding */ isDataset),
/* harmony export */   isPublic: () => (/* binding */ isPublic),
/* harmony export */   item: () => (/* binding */ item),
/* harmony export */   itemGroup: () => (/* binding */ itemGroup),
/* harmony export */   loadingLayer: () => (/* binding */ loadingLayer),
/* harmony export */   matchVariables: () => (/* binding */ matchVariables),
/* harmony export */   mosaic: () => (/* binding */ mosaic),
/* harmony export */   multidimensionalRules: () => (/* binding */ multidimensionalRules),
/* harmony export */   name: () => (/* binding */ name),
/* harmony export */   noTagErrorMsg: () => (/* binding */ noTagErrorMsg),
/* harmony export */   noTitleErrorMsg: () => (/* binding */ noTitleErrorMsg),
/* harmony export */   noTitleTagErrorMsg: () => (/* binding */ noTitleTagErrorMsg),
/* harmony export */   ok: () => (/* binding */ ok),
/* harmony export */   organization: () => (/* binding */ organization),
/* harmony export */   outputPixelType: () => (/* binding */ outputPixelType),
/* harmony export */   owner: () => (/* binding */ owner),
/* harmony export */   parameter: () => (/* binding */ parameter),
/* harmony export */   parameters: () => (/* binding */ parameters),
/* harmony export */   properties: () => (/* binding */ properties),
/* harmony export */   raster: () => (/* binding */ raster),
/* harmony export */   rasterFunctionEditor: () => (/* binding */ rasterFunctionEditor),
/* harmony export */   rasterFunctions: () => (/* binding */ rasterFunctions),
/* harmony export */   rfxLicenseInfo: () => (/* binding */ rfxLicenseInfo),
/* harmony export */   s16PixelType: () => (/* binding */ s16PixelType),
/* harmony export */   s32PixelType: () => (/* binding */ s32PixelType),
/* harmony export */   s8PixelType: () => (/* binding */ s8PixelType),
/* harmony export */   save: () => (/* binding */ save),
/* harmony export */   saveAs: () => (/* binding */ saveAs),
/* harmony export */   saveUtils: () => (/* binding */ saveUtils),
/* harmony export */   savingMessage: () => (/* binding */ savingMessage),
/* harmony export */   scalar: () => (/* binding */ scalar),
/* harmony export */   search: () => (/* binding */ search),
/* harmony export */   selectFeature: () => (/* binding */ selectFeature),
/* harmony export */   selectFunction: () => (/* binding */ selectFunction),
/* harmony export */   selectRaster: () => (/* binding */ selectRaster),
/* harmony export */   serviceURL: () => (/* binding */ serviceURL),
/* harmony export */   setGroupSharing: () => (/* binding */ setGroupSharing),
/* harmony export */   setSharingLevel: () => (/* binding */ setSharingLevel),
/* harmony export */   share: () => (/* binding */ share),
/* harmony export */   shareWith: () => (/* binding */ shareWith),
/* harmony export */   success: () => (/* binding */ success),
/* harmony export */   tagFieldName: () => (/* binding */ tagFieldName),
/* harmony export */   tags: () => (/* binding */ tags),
/* harmony export */   title: () => (/* binding */ title),
/* harmony export */   toolDetailsEditor: () => (/* binding */ toolDetailsEditor),
/* harmony export */   toolEditor: () => (/* binding */ toolEditor),
/* harmony export */   toolModeler: () => (/* binding */ toolModeler),
/* harmony export */   tryAgain: () => (/* binding */ tryAgain),
/* harmony export */   type: () => (/* binding */ type),
/* harmony export */   u16PixelType: () => (/* binding */ u16PixelType),
/* harmony export */   u32PixelType: () => (/* binding */ u32PixelType),
/* harmony export */   u8PixelType: () => (/* binding */ u8PixelType),
/* harmony export */   unionDimensions: () => (/* binding */ unionDimensions),
/* harmony export */   unknownPixelType: () => (/* binding */ unknownPixelType),
/* harmony export */   unsavedTitle: () => (/* binding */ unsavedTitle),
/* harmony export */   unsavedWarningExisting: () => (/* binding */ unsavedWarningExisting),
/* harmony export */   unsavedWarningNew: () => (/* binding */ unsavedWarningNew),
/* harmony export */   userStartDirection: () => (/* binding */ userStartDirection),
/* harmony export */   variables: () => (/* binding */ variables),
/* harmony export */   viewerModeMessage: () => (/* binding */ viewerModeMessage),
/* harmony export */   viewerModeTitle: () => (/* binding */ viewerModeTitle),
/* harmony export */   warning: () => (/* binding */ warning)
/* harmony export */ });
const ok = "D'acord";
const cancel = "Cancel·la";
const enterURL = "Introduïu la URL del servei d'imatges";
const serviceURL = "URL del servei";
const selectRaster = "Seleccioneu un ràster";
const failedToLoadLayer = "No s'ha pogut carregar la capa";
const loadingLayer = "S'està carregant la capa";
const selectFeature = "Seleccioneu la capa d'entitats";
const enterFURL = "Introduïu l'URL del servei d'entitats";
const addRaster = "Afegeix una variable de ràster";
const addScalar = "Afegeix una constant";
const raster = "Ràster";
const scalar = "Escalar";
const defaultModelName = "Plantilla de funció de ràster";
const general = "General";
const parameters = "Paràmetres";
const variables = "Variables";
const name = "Nom";
const description = "Descripció";
const parameter = "Paràmetre";
const isPublic = "IsPublic";
const isDataset = "IsDataset";
const unknownPixelType = "Desconegut";
const outputPixelType = "Tipus de píxel de sortida";
const u8PixelType = "8 bits sense signar";
const s8PixelType = "8 bits signat";
const u16PixelType = "16 bits sense signar";
const s16PixelType = "16 bits signat";
const u32PixelType = "32 bits sense signar";
const s32PixelType = "32 bits signat";
const f32PixelType = "32 bits flotant";
const f64PixelType = "64 bits doble";
const properties = "Propietats";
const multidimensionalRules = "Regles multidimensionals";
const matchVariables = "Variables de coincidència";
const unionDimensions = "Dimensions d'unió";
const rasterFunctionEditor = {
	invalidRFTMessage: "La plantilla de funció de ràster no és vàlida.",
	rfxArgsEditor: {
		outputRaster: "OutputRaster",
		raster: "Ràster",
		unsupportedDataTypeWarning: "Els arguments següents no es mostren perquè actualment no són compatibles.",
		unsupportedFunction: "Conté funcions de ràster no admeses actualment."
	},
	rfxRasterInput: {
		selectLayer: "Seleccioneu la capa",
		browseLayers: "Examina les capes",
		rfxVariable: "RasterFunctionVariable"
	},
	rfxBandCombinationEditor: {
		methodLabel: "Mètode",
		bandLabel: "Banda",
		combinationLabel: "Combinació"
	},
	rfxRemapGrid: {
		minimum: "Mínim",
		maximum: "Màxim",
		output: "Sortida",
		noData: "NoData",
		remapValuesLabel: "Nova representació cartogràfica de valors"
	},
	rfxNamedRasterEditor: {
		rasterVariables: "Variables de ràster",
		deleteSelectedVars: "Elimina les variables seleccionades"
	},
	rfxClippingGeometry: {
		clippingLayer: "Capa de retalls",
		clippingRaster: "S'està retallant el ràster",
		clippingGeometry: "S'està retallant la geometria",
		customExtent: "Extensió personalitzada",
		outputExtent: "Extensió de sortida",
		currentExtent: "Extensió de mapa actual",
		drawLabel: "Dibuixa"
	},
	rfxCustomExtent: {
		top: "Superior",
		right: "Dret",
		bottom: "Inferior",
		left: "Esquerre"
	},
	rfxRasterArrayEditor: {
		moveUp: "Mou cap amunt",
		moveDown: "Mou cap avall",
		remove: "Elimina"
	},
	rfxStatisticsGrid: {
		stdDev: "Desv. estàndard",
		min: "Mín.",
		max: "Màx.",
		mean: "Mitja"
	},
	rfxWeightedSumTableEditor: {
		weightedSumTable: "Taula de sumes ponderades",
		id: "ID",
		layer: "Capa",
		field: "Camp",
		weight: "Pes",
		value: "Valor",
		selectLayer: "Seleccioneu la capa"
	},
	rfxWeightedOverlayTableEditor: {
		weightedOverlayTable: "Taula de superposició ponderada",
		id: "ID",
		layer: "Capa",
		field: "Camp",
		influence: "Influència",
		sumOfInfluence: "Suma d'influència",
		value: "Valor",
		remapTable: "Taula de nova representació geogràfica",
		scale: "Escala",
		scales: "Escales",
		selectRaster: "Seleccioneu un ràster"
	},
	rfxFeatureSelect: {
		addFeatureLayer: "Cerca una capa d'entitats",
		addPointLayer: "Cerca una capa de punts"
	},
	rfxFieldSelect: {
		value: "Valor",
		count: "Recompte"
	},
	rfxAttributeTable: {
		tableType: "Tipus de taula",
		manual: "Manual",
		external: "Extern",
		minVal: "Valor mínim",
		maxVal: "Valor màxim",
		baseClassName: "Nom de base de la classe",
		colorScheme: "Esquema de colors",
		defaultClassName: "Label_",
		generateTable: "Genera la taula",
		browseTable: "Navegueu per la taula",
		value: "Valor",
		classname: "ClassName",
		color: "Color"
	},
	rfxFieldNumberSwitchable: {
		number: "Numèric",
		field: "Camp",
		string: "Cadena",
		linearUnit: "Unitat lineal"
	},
	rfxPropertySet: {
		name: "Nom",
		value: "Valor"
	},
	rfxConversionGrid: {
		size: "Mida"
	},
	rfxTransposeBit: {
		bitPattern: "Patró de bits",
		outputBit: "Bit de sortida",
		inputBit: "Bit d'entrada"
	},
	rfxSpatialReference: {
		placeHolder: "Refina per paraula clau",
		coordinateSystem: "Sistema de coordenades",
		gcs: "Sistema de coordenades geogràfiques",
		pcs: "Sistema de coordenades projectades",
		vcs: "Sistema de coordenades verticals"
	}
};
const rfxLicenseInfo = "Aquesta plantilla de funció de ràster es pot utilitzar per processar les imatges mitjançant l'ArcGIS Image Server.";
const rasterFunctions = {
	rfx: {
		aCosHName: "Arc cosinus hiperbòlic (ACosH)",
		aCosHSnip: "Calcula el cosinus hiperbòlic invers de les cel·les d'un ràster.",
		aCosHDesc: "La funció calcula el cosinus hiperbòlic invers dels píxels d'un ràster.",
		aCosName: "Arc cosinus (ACos)",
		aCosSnip: "Calcula el cosinus invers dels píxels d'un ràster.",
		aCosDesc: "Aquesta funció de ràster calcula el cosinus invers de les cel·les d'un ràster. En matemàtiques, totes les funcions trigonomètriques tenen un interval definit de valors d'entrada vàlids, que es coneixen com el domini. Els valor de sortida de cada funció també té un interval definit. Per a aquesta eina, el domini és [-1, 1] i l'interval és [0, pi].",
		aSinHName: "Arc sinus hiperbòlic (ASinH)",
		aSinHSnip: "Calcula el sinus hiperbòlic invers de les cel·les d'un ràster.",
		aSinHDesc: "La funció calcula el sinus hiperbòlic invers dels píxels d'un ràster.",
		aSinName: "Arc sinus (ASin)",
		aSinSnip: "Calcula el sinus invers de les cel·les d'un ràster.",
		aSinDesc: "La funció calcula el sinus invers dels píxels d'un ràster.",
		aTan2Name: "Arc tangent (ATan2)",
		aTan2Snip: "Calcula la tangent inversa (basada en x,y) de les cel·les d'un ràster.",
		aTan2Desc: "La funció calcula la tangent inversa (basada en x,y) dels píxels d'un ràster.",
		aTanHName: "Arc tangent hiperbòlica (ATanH)",
		aTanHSnip: "Calcula la tangent hiperbòlica inversa de les cel·les d'un ràster.",
		aTanHDesc: "La funció calcula la tangent hiperbòlica inversa dels píxels d'un ràster.",
		aTanName: "Arc tangent (ATan)",
		aTanSnip: "Calcula la tangent inversa de les cel·les d'un ràster.",
		aTanDesc: "La funció calcula la tangent inversa dels píxels d'un ràster.",
		absName: "Valor absolut",
		absSnip: "Calcula el valor absolut de les cel·les d'un ràster.",
		absDesc: "La funció Valor absolut calcula el valor absolut dels píxels d'un ràster.",
		reflectanceName: "Reflectància aparent",
		reflectanceSnip: "Converteix les imatges sense processar en valors de sostre de l'atmosfera (TOA). Per fer-ho, té en compte les característiques del sensor, la posició del sol i el temps d'adquisició.",
		reflectanceDesc: "Aquesta funció ajusta els valors de nombre digital (DN) de brillantor de la imatge per a alguns sensors de satèl·lit. Aquests ajusts es basen en les propietats d'elevació del sol, de data d'adquisició i del sensor per definir el guany i el biaix de cada banda. Aquesta funció s'utilitza per ajustar els valors de reflectància, o brillantor, d'algunes imatges de satèl·lit en funció de la il·luminació de l'escena i la configuració de guany del sensor. Les imatges s'ajusten a una condició d'il·luminació teòricament comuna i, per tant, hi hauria d'haver menys variació entre les escenes de dates i sensors diferents. Això pot resultar útil per a la classificació d'imatges, l'ajust del color i la creació de mosaics. Aquesta funció només es pot utilitzar amb imatges específiques. Els sensors aplicables són Landsat MSS, Landsat TM, Landsat ETM+, Landsat 8, IKONOS, QuickBird, GeoEye-1, RapidEye, DMCii, WorldView-1, WorldView-2, SPOT 6 i Pleiades.<div><br/>La funció realitza dues correccions. La primera es basa en la configuració de guany. Els valors de brillantor originals es tornen a crear a partir dels valors d'imatge. Per fer-ho, s'inverteixen les equacions de guany. La segona correcció té a veure amb les diferències en l'angle i la brillantor del sol. Els valors de brillantor originals s'ajusten a una condició d'il·luminació comuna mitjançant la normalització de les escenes capturades en condicions d'il·luminació variables. En general, tot i que el tipus de dades d'imatge de sortida és el mateix que el d'entrada, els valors de sortida són més baixos que els d'entrada i es retallen per ajustar-los a l'interval de dades vàlid.</div>",
		argStatisticsName: "ArgStatistics",
		argStatisticsSnip: "Calcula les estadístiques arg, que inclouen Arg Max, Arg Min, Arg Median i Duration.",
		argStatisticsDesc: "La funció calcula les estadístiques arg. La funció ArgStatistics presenta quatre mètodes: ArgMax, ArgMin, ArgMedian i Duration.",
		arithmeticName: "Aritmètic",
		arithmeticSnip: "Realitza una operació aritmètica entre dos ràsters o un ràster i un escalar.",
		arithmeticDesc: "La funció aritmètica realitza una operació aritmètica entre dos ràsters o un ràster i un escalar i viceversa.",
		aspectSlopeName: "Orientació-pendent",
		aspectSlopeSnip: "Crea un ràster que mostra simultàniament l'orientació (direcció) i el pendent (inclinació) d'una superfície contínua, tal com es representa en un model d'elevació digital.",
		aspectSlopeDesc: "La funció Orientació-pendent crea una capa de ràster que mostra simultàniament l'orientació i el pendent d'una superfície. L'orientació identifica la direcció descendent de la velocitat màxima de canvi del valor des de cada píxel als píxels veïns. L'orientació es pot considerar la direcció del pendent. Els valors del ràster de sortida seran la direcció de brúixola de l'orientació, representada amb un to (color). El pendent representa l'índex de canvi d'elevació de cada píxel del model d'elevació digital (DEM). El pendent representa la inclinació de la superfície i se simbolitza en tres classes que es mostren mitjançant la saturació del color (brillantor).<div><br/>Els valors de píxel del ràster d'orientació-pendent de sortida reflecteixen una combinació d'orientació i pendent. Els píxels amb valors inferiors a 20 es consideren plans i es mostren grisos. Els valors d'orientació-pendent de 21 i superiors es mostraran amb saturacions variables de la manera següent: de 21 a 30, saturació de pendent baix; de 31 a 40, saturació de pendent moderat; 41 i superiors, saturació de pendent alt</div>",
		aspectName: "Orientació",
		aspectSnip: "Mostra quina direcció segueix un píxel, on 0 fa referència al nord i els angles augmenten en el sentit de les agulles del rellotge fins a 360.",
		aspectDesc: "La funció Orientació identifica la direcció descendent de la velocitat màxima de canvi del valor des de cada cel·la a les cel·les veïnes. L'orientació es pot considerar la direcció del pendent. Els valors del ràster de sortida seran la direcció de brúixola de l'orientació.<div><br/>L'entrada d'aquesta funció és Ràster d'entrada. La funció Orientació s'aplica sovint a un model d'elevació digital (DEM). Per defecte, l'orientació es mostra com una imatge en escala de grisos. Podeu afegir la funció Mapa de color per especificar un esquema de colors específic o permetre que la persona que visualitza el mosaic modifiqui la simbologia amb el seu propi esquema de colors.</div>",
		tableName: "Taula d'atributs",
		tableSnip: "Utilitza una taula per anomenar i simbolitzar els valors d'un dataset. Les columnes de la taula estan delimitades per comes: PixelValue, AttributeName, RedValue, GreenValue, BlueValue.",
		tableDesc: "La funció Taula d'atributs us permet definir una taula d'atributs per simbolitzar un dataset ràster o un dataset de mosaic d'una banda. <div><br/>Resulta útil si voleu presentar imatges que s'han sotmès a classificació per a ús del sòl, com ara terreny forestal, zones humides, terres de cultiu i zones urbanes. Tanmateix, si la taula conté camps anomenats vermell, verd i blau, els valors d'aquests camps s'utilitzaran com un mapa de color quan es representi la imatge.</div>",
		bandArithmeticName: "Aritmètica de banda",
		bandArithmeticSnip: "Calcula els índexs mitjançant fórmules predefinides o una expressió definida per l'usuari.",
		bandArithmeticDesc: "La funció Aritmètica de banda realitza una operació aritmètica sobre les bandes d'un dataset ràster. Podeu triar algoritmes predefinits o introduir la vostra pròpia fórmula d'una línia. Els operadors admesos són -, +, /, * i - unari.",
		thresholdName: "Definició de llindar binari",
		thresholdSnip: "Organitza les dades contínues en primer pla i en segon terme. Per fer-ho, minimitza la covariància entre les dues classes.",
		thresholdDesc: "Quan un dataset ràster té una distribució bimodal, aquesta funció crea un ràster nou que divideix les dades en dues classes diferents. Crea una classe de valors baixos que es mostra amb píxels negres i una classe de valors alts que es mostra amb píxels blancs.",
		bitwiseAndName: "Bitwise And",
		bitwiseAndSnip: "Realitza una operació Bitwise And als valors binaris dels dos ràsters d'entrada.",
		bitwiseAndDesc: "Bitwise And realitza una operació Bitwise And als valors binaris dels dos ràsters d'entrada",
		bitwiseLeftShiftName: "Bitwise Left Shift",
		bitwiseLeftShiftSnip: "Realitza una operació Bitwise Left Shift als valors binaris dels dos ràsters d'entrada.",
		bitwiseLeftShiftDesc: "Bitwise Left Shift realitza una operació Bitwise Left Shift als valors binaris dels dos ràsters d'entrada",
		bitwiseNotName: "Bitwise Not",
		bitwiseNotSnip: "Realitza una operació Bitwise Not (complement) als valors binaris dels dos ràsters d'entrada.",
		bitwiseNotDesc: "La funció realitza una operació Bitwise Not (complement) al valor binari d'un ràster d'entrada.",
		bitwiseOrName: "Bitwise Or",
		bitwiseOrSnip: "Realitza una operació Bitwise Or als valors binaris dels dos ràsters d'entrada.",
		bitwiseOrDesc: "La funció realitza una operació Bitwise Or als valors binaris dels dos ràsters d'entrada. ",
		bitwiseRightShiftName: "Bitwise Right Shift",
		bitwiseRightShiftSnip: "Realitza una operació Bitwise Right Shift als valors binaris dels dos ràsters d'entrada.",
		bitwiseRightShiftDesc: "La funció realitza una operació Bitwise Right Shift als valors binaris dels dos ràsters d'entrada.",
		bitwiseXorName: "Bitwise Xor",
		bitwiseXorSnip: "Realitza una operació Bitwise eXclusive Or als valors binaris dels dos ràsters d'entrada.",
		bitwiseXorDesc: "La funció realitza una operació Bitwise eXclusive Or als valors binaris dels dos ràsters d'entrada",
		booleanAndName: "Booleana And",
		booleanAndSnip: "Realitza una operació Booleana And als valors de cel·la dels dos ràsters d'entrada. Si ambdós valors d'entrada són certs (no zero), el valor de sortida és 1. Si una de les entrades o totes dues són falses (zero), el valor de sortida és 0.",
		booleanAndDesc: "La funció realitza una operació Booleana And als valors de píxel de les dues entrades. Si ambdós valors d'entrada són certs (no zero), el valor de sortida és 1. Si un dels valors d'entrada o tots dos són falsos (zero), el valor de sortida és 0. ",
		booleanNotName: "Booleana Not",
		booleanNotSnip: "Realitza una operació Booleana Not (complement) als valors de cel·la del ràster d'entrada. Si els valors d'entrada són certs (no zero), el valor de sortida és 0. Si els valors d'entrada són falsos (zero), la sortida és 1.",
		booleanNotDesc: "La funció realitza una operació Booleana Not (complement) als valors de píxel del ràster d'entrada. Si els valors d'entrada són certs (no zero), el valor de sortida és 0. Si els valors d'entrada són falsos (zero), el valor de sortida és 1.",
		booleanOrName: "Booleana Or",
		booleanOrSnip: "Realitza una operació Booleana Or als valors de cel·la dels dos ràsters d'entrada. Si un dels valors d'entrada o tots dos són certs (no zero), el valor de sortida és 1. Si ambdós valors d'entrada són falsos (zero), la sortida és 0.",
		booleanOrDesc: "La funció realitza una operació Booleana Or als valors de cel·la dels dos ràsters d'entrada. Si un dels valors d'entrada o tots dos són certs (no zero), el valor de sortida és 1. Si ambdós valors d'entrada són falsos (zero), el valor de sortida és 0.",
		booleanXorName: "Booleana Xor",
		booleanXorSnip: "Realitza una operació Booleana eXclusive Or als valors de cel·la dels dos ràsters d'entrada. Si un dels valors d'entrada és cert (no zero) i l'altre és fals (zero), la sortida és 1. Si ambdós valors d'entrada són certs o ambdós són falsos, la sortida és 0.",
		booleanXorDesc: "La funció realitza una operació Booleana eXclusive Or als valors de cel·la dels dos ràsters d'entrada. Si un dels valors d'entrada és cert (no zero) i l'altre és fals (zero), el valor de sortida és 1. Si ambdós valors d'entrada són certs o ambdós són falsos, el valor de sortida és 0.",
		bufferedRasterName: "En àrea d'influència",
		bufferedRasterSnip: "Crea àrees d'influència dels últims blocs que píxels als quals s'ha accedit.",
		bufferedRasterDesc: "La funció En àrea d'influència s'utilitza per optimitzar el rendiment de les cadenes de funcions complexes. Emmagatzema la sortida a la memòria de la part de la cadena de funcions que la precedeix. <div><br/>Inseriu aquesta funció a l'Editor de funció on voleu emmagatzemar la sortida.</div>",
		rasterCalculatorName: "Calculadora",
		rasterCalculatorSnip: "Calcula un ràster a partir d'una expressió matemàtica basada en ràster.",
		rasterCalculatorDesc: "La funció Calculadora us permet crear i executar expressions i incorporar-les a les cadenes de funcions.",
		cellStatisticsName: "Estadístiques de la cel·la",
		cellStatisticsSnip: "Calcula estadístiques per cel·la de diversos ràsters. Les estadístiques disponibles són Majoria, Màxim, Mitja, Mitjana, Mínim, Minoria, Interval, Desviació Estàndard, Suma i Varietat.",
		cellStatisticsDesc: "Aquesta funció calcula les estadístiques a partir de diversos ràsters, píxel per píxel. Les estadístiques disponibles són majoria, màxim, mitja, mitjana, mínim, minoria, interval, desviació estàndard, suma i varietat.",
		classifyName: "Classifica",
		classifySnip: "Assigna cada píxel a una classe. Incorporeu les dades auxiliars, com ara una imatge segmentada.",
		classifyDesc: "Aquesta funció de ràster classifica un dataset ràster en funció d'un fitxer de definició de classificador d'Esri (.ecd) i de les entrades de dataset ràster. El fitxer .ecd utilitzat a la funció Classifica conté tota la informació d'un dataset i un classificador específics, i es genera mitjançant eines de preparació de classificació, com ara Preparar classificador de màquina de vectors de suport o Preparar classificador d'arbres aleatoris.",
		clipName: "Retalla",
		clipSnip: "Defineix l'extensió d'un ràster mitjançant coordenades o un altre dataset.",
		clipDesc: "Aquesta funció retalla un ràster mitjançant una forma rectangular d'acord amb les extensions definides, o bé el retalla amb la forma d'una classe d'entitat de polígon d'entrada. La forma que defineix el retall pot retallar l'extensió del ràster o bé retallar una àrea dins del ràster.",
		colorspaceConversionName: "Conversió del model de color",
		colorspaceConversionSnip: "Converteix un ràster d'RGB a HSV i viceversa.",
		colorspaceConversionDesc: "La funció Conversió del model de color converteix el model de color d'una imatge des de l'espai de color de to, saturació i valor (HSV) al de vermell, verd i blau (RGB) o viceversa.<div><br/>Aquesta funció es pot utilitzar en un dataset de mosaic.</div>",
		colormapToRGBName: "Mapa de color a RGB",
		colormapToRGBSnip: "Converteix un ràster d'una banda amb un mapa de color en un ràster de tres bandes (vermella, verda i blava).",
		colormapToRGBDesc: "Aquesta funció converteix un ràster d'una banda amb un mapa de color en un ràster de tres bandes (vermella, verda i blava).<div><br/>Aquesta funció resulta útil si necessiteu crear un ràster de tres bandes a partir d'un ràster d'una banda amb un mapa de color associat. Els valors del mapa de color s'utilitzaran per crear cadascuna de les bandes vermella, verda i blava. Aquesta funció es pot utilitzar en un dataset de mosaic.</div>",
		colormapName: "Mapa de color",
		colormapSnip: "Canvia els valors de píxel per mostrar les dades de ràster com una imatge en escala de grisos o una imatge vermella, verda i blava (RGB), basada en un mapa de color o una rampa de color.",
		colormapDesc: "La funció Mapa de color és un tipus de renderitzador de dades de ràster. Transforma els valors de píxel per mostrar les dades de ràster com una imatge en escala de grisos o una imatge en color RGB basada en un esquema de color o en colors específics d'un fitxer de mapa de color. Podeu utilitzar un mapa de color per representar les dades analitzades, com ara una imatge classificada o quan visualitzeu un mapa topogràfic (o una imatge d'índex escanejada en color).<div><br/>Els mapes de color contenen un conjunt de valors associats als colors que s'utilitzen per mostrar un ràster d'una banda de manera coherent amb els mateixos colors. Cada valor de píxel està associat a un color, definit com un conjunt de valors RGB. Els mapes de color poden admetre qualsevol profunditat de bits, excepte la de punt flotant. També admeten valors positius i negatius i poden contenir valors assignats de colors que faltin. En visualitzar un dataset amb un mapa de color que contingui valors que falten, els píxels amb aquests valors que falten no es mostraran.</div>",
		complexName: "Complex",
		complexSnip: "Extreu la magnitud dels nombres complexos.",
		complexDesc: "Aquesta funció calcula la magnitud dels valors complexos.<div><br/>Aquesta funció s'utilitza habitualment amb imatges RADAR que tenen un tipus de dades complex. Es pot utilitzar en un dataset de mosaic.</div>",
		compositeBandName: "Bandes compostes",
		compositeBandSnip: "Combina diversos datasets en un ràster multibanda.",
		compositeBandDesc: "La funció Bandes compostes us permet combinar ràsters per formar una imatge multibanda.",
		conName: "Condicional",
		conSnip: "Realitza una operació If, Then, Else condicional. Si s'utilitza un operador Condicional, generalment cal que dues o més funcions estiguin encadenades, una de les quals indica els criteris i l'altra és l'operador Condicional que utilitza els criteris i dicta quines han de ser les sortides certes i falses.",
		conDesc: "La funció Condicional defineix els píxels del ràster de sortida segons una avaluació if\\else de cada píxel d'entrada. Retorna els valors de píxel del ràster cert si l'avaluació condicional és certa (1), o bé retorna els valors de píxel del ràster fals si l'avaluació condicional és falsa (0). Aquest criteri l'especifica la sortida d'una funció matemàtica lògica, que serà el ràster d'entrada.",
		constantName: "Constant",
		constantSnip: "Crea un ràster virtual amb un sol valor de píxel.",
		constantDesc: "Aquesta funció crea un ràster virtual amb un sol valor de píxel que es pot utilitzar en plantilles de funció de ràster i per processar un dataset de mosaic.<div><br/>El valor constant s'utilitza per a cada valor de píxel del ràster.</div>",
		contourName: "Corba de nivell",
		contourSnip: "Crea línies de corba de nivell.",
		contourDesc: "La funció Corba de nivell genera línies de corba de nivell mitjançant la unió de punts amb la mateixa elevació d'un dataset d'elevació de ràster. Les corbes de nivell són isolínies creades com ràsters per a la visualització. Les següents característiques clau fan que aquesta funció sigui molt eficaç: les corbes de nivell es generen de manera ràpida i dinàmica en datasets molt grans, com ara World Elevation; les corbes de nivell es poden suavitzar per proporcionar una aparença cartogràficament més agradable i, alhora, mantenir-ne la precisió; es proporciona control dinàmic sobre l'interval de corbes de nivell; les opcions de sortida inclouen línies de corbes de nivell, corbes de nivell mestres i corbes de nivell plenes.<div><br/>La creació d'una capa de corba de nivell com un producte ràster resulta útil per a una gran varietat d'aplicacions, ja que les corbes de nivell es poden superposar en un mapa i proporcionen informació sobre el terreny sense amagar les dades subjacents. Resulten útils en aplicacions, com ara d'enginyeria, agricultura i gestió de recursos hídrics.</div>",
		contrastBrightnessName: "Contrast i brillantor",
		contrastBrightnessSnip: "Ajusta el contrast i la brillantor d'un ràster.",
		contrastBrightnessDesc: "La funció Contrast i brillantor millora l'aparença de les dades de ràster mitjançant la modificació de la brillantor i el contrast a la imatge. La brillantor augmenta la il·luminació general de la imatge (per exemple, aclareix els colors foscos i fa que els colors clars siguin més blancs), mentre que el contrast ajusta la diferència entre els colors més foscos i més clars.<div><br/>La utilització d'aquesta funció altera els valors de píxel; per tant, aquesta funció s'ha d'utilitzar quan es vol millorar l'aparença de les dades, però no si la intenció és utilitzar les dades com a part d'una anàlisi que exigiria valors de píxel sense processar. Aquesta funció resulta útil quan es publiquen les dades com un servei d'imatges que es pot utilitzar en aplicacions sense la capacitat d'alterar el contrast i la brillantor de les imatges, o de garantir la visualització amb la vostra configuració preferida.</div>",
		convolutionName: "Convolució",
		convolutionSnip: "Aplica un filtre per enfocar, difuminar, detectar vores o suavitzar la imatge, o bé un gradient en un ràster.",
		convolutionDesc: "La funció Convolució realitza el filtratge als valors de píxel d'una imatge, que es pot utilitzar per enfocar o difuminar una imatge, detectar les vores d'una imatge o altres millores basades en el nucli. Els filtres s'utilitzen per millorar la qualitat de la imatge de ràster. Per aconseguir-ho elimina les dades falses o millora les característiques de les dades. Aquests filtres de convolució s'apliquen en un nucli mòbil superposat (finestra o veïnat), com ara 3 per 3. Els filtres de convolució funcionen calculant el valor de píxel en funció de la ponderació dels seus veïns.",
		corridorName: "Corredor",
		corridorSnip: "Calcula la suma dels costos acumulatius de dos ràsters acumulatius d'entrada.",
		corridorDesc: "La funció Corredor calcula la suma dels costos acumulatius de dos ràsters de cost acumulatiu d'entrada. Tot i que es poden utilitzar dos ràsters qualsevol per a l'entrada, per obtenir un resultat significatiu han de ser ràsters de sortida de cost acumulatiu sense alterar. L'ordre de les dues entrades és irrellevant.",
		cosHName: "Cosinus hiperbòlic (CosH)",
		cosHSnip: "Calcula el cosinus hiperbòlic de les cel·les d'un ràster.",
		cosHDesc: "La funció calcula el cosinus hiperbòlic dels píxels d'un ràster.",
		cosName: "Cosinus (Cos)",
		cosSnip: "Calcula el cosinus d'una cel·la del ràster.",
		cosDesc: "La funció calcula el cosinus dels píxels d'un ràster.",
		costAllocationName: "Assignació de costos",
		costAllocationSnip: "Calcula, per a cada cel·la, l'origen de menor cost en funció del cost acumulatiu més baix en una superfície de cost.",
		costAllocationDesc: "La funció Assignació de costos calcula, per a cada cel·la, l'origen de menor cost en funció del cost acumulatiu més baix en una superfície de cost.",
		costBackLinkName: "Enllaç de menor cost",
		costBackLinkSnip: "Defineix el veí que és la cel·la següent a la ruta de menor cost acumulatiu a l'origen de menor cost.",
		costBackLinkDesc: "La funció Enllaç de menor cost defineix el veí que és la cel·la següent a la ruta de menor cost acumulatiu a l'origen de menor cost.<div><br/>El ràster d'enllaç de menor cost conté valors de zero a vuit, que defineixen la direcció o identifiquen la cel·la veïna següent (la cel·la posterior) al llarg de la ruta de menor cost acumulatiu des d'una cel·la per arribar a l'origen de menor cost. Si la ruta ha de passar al veí de la dreta, s'assignarà el valor 1 a la cel·la, 2 per a la cel·la diagonal dreta inferior, i així successivament en el sentit de les agulles del rellotge. El valor 0 es reserva per a les cel·les d'origen.</div>",
		costDistanceName: "Cost en pla",
		costDistanceSnip: "Calcula la distància de menor cost acumulatiu de cada cel·la des de o cap a l'origen de menor cost sobre una superfície de cost.",
		costDistanceDesc: "La funció Cost en pla calcula la distància de menor cost acumulatiu de cada cel·la des de o cap a l'origen de menor cost sobre una superfície de cost.",
		costPathName: "Ruta de cost",
		costPathSnip: "Calcula la ruta de menor cost des d'un origen fins a una destinació.",
		costPathDesc: "La funció Ruta de cost global calcula la ruta de menor cost des d'un origen fins a una destinació.<div><br/>Aquesta funció genera un ràster de sortida que registra la ruta o les rutes de menor cost des de les ubicacions seleccionades fins a la cel·la d'origen més propera definida a la superfície de cost acumulatiu, en termes de cost en pla.</div>",
		curvatureName: "Curvatura",
		curvatureSnip: "Calcula la curvatura d'una superfície de ràster, que pot incloure la curvatura del perfil i del pla.",
		curvatureDesc: "La funció Curvatura mostra la forma o la curvatura del pendent. Una part d'una superfície pot ser còncava o convexa; per saber-ho, observeu el valor de curvatura. Per obtenir la curvatura es calcula la segona derivada de la superfície.<div><br/>La sortida de la funció Curvatura es pot utilitzar per descriure les característiques físiques d'una conca de drenatge per intentar entendre els processos d'erosió i escolament. El valor de curvatura es pot utilitzar per cercar patrons d'erosió del sòl, així com la distribució d'aigua al terreny. La curvatura del perfil afecta l'acceleració i desacceleració del flux i, per tant, influeix en l'erosió i la deposició. La curvatura de la planta influeix en la convergència i la divergència del flux.</div>",
		divideName: "Divisió",
		divideSnip: "Divideix els valors de dos ràsters píxel per píxel.",
		divideDesc: "La funció Divisió divideix els valors de dos ràsters píxel per píxel.",
		elevationVoidFillName: "Emplenament de buits d'elevació",
		elevationVoidFillSnip: "Crea píxels allà on les dades d'elevació presenten forats.",
		elevationVoidFillDesc: "La funció Emplenament de buits d'elevació s'utilitza per crear píxels allà on l'elevació presenta forats.<div><br/>Els buits es produeixen quan no s'han recopilat punts en una àrea representada per un píxel al ràster resultant. Les causes dels buits solen ser les masses d'aigua, la selecció del tipus de classe o l'exclusió. L'emplenament de buits s'utilitza principalment quan es genera una superfície de terreny.</div>",
		equalToName: "Igual que",
		equalToSnip: "Realitza una operació d'igualtat relacional en dues entrades cel·la per cel·la. Retorna el valor 1 per a les cel·les on el primer ràster és igual que el segon i el valor 0 per a les cel·les quan els ràsters no són iguals.",
		equalToDesc: "La funció realitza una operació d'igualtat en dos ràsters píxel per píxel. Retorna el valor 1 per als píxels on el primer ràster és igual que el segon i el valor 0 per als píxels on els ràsters no són iguals.",
		eucAllocationName: "Assignació euclidiana",
		eucAllocationSnip: "Calcula, per a cada cel·la, l'origen més proper basat en la distància euclidiana.",
		eucAllocationDesc: "La funció Assignació euclidiana calcula, per a cada cel·la, l'origen més proper basat en la distància euclidiana.",
		eucDirectionName: "Direcció euclidiana",
		eucDirectionSnip: "Calcula, per a cada cel·la, la direcció, en graus, a l'origen més proper.",
		eucDirectionDesc: "La funció Direcció euclidiana calcula, per a cada cel·la, la direcció, en graus, a l'origen més proper. <div><br/>La direcció es calcula des del centre de cada cel·la fins al centre de la cel·la d'origen més propera. L'interval de valors és de 0 a 360 graus, amb el valor 0 reservat per a les cel·les d'origen. Cap a l'est (dreta) és 90 i els valors augmenten en el sentit de les agulles del rellotge (180 és el sud, 270 és l'oest i 360 és el nord).</div>",
		eucDistanceName: "Distància euclidiana",
		eucDistanceSnip: "Calcula, per a cada cel·la, la distància euclidiana a l'origen més proper.",
		eucDistanceDesc: "La funció Distància euclidiana calcula, per a cada cel·la, la distància euclidiana a l'origen més proper.",
		exp10Name: "Exponencial en base 10 (Exp10)",
		exp10Snip: "Calcula l'exponencial en base 10 de les cel·les d'un ràster.",
		exp10Desc: "La funció Exponencial en base 10 calcula l'exponencial en base 10 dels píxels d'un ràster.",
		exp2Name: "Exponencial en base 2 (Exp2)",
		exp2Snip: "Calcula l'exponencial en base 2 de les cel·les d'un ràster.",
		exp2Desc: "Aquesta funció calcula l'exponencial en base 2 dels píxels d'un ràster.",
		expName: "Exponencial en base e (Exp)",
		expSnip: "Calcula l'exponencial en base e de les cel·les d'un ràster.",
		expDesc: "Aquesta funció calcula l'exponencial en base e dels píxels d'un ràster.",
		extractBandName: "Extreu les bandes",
		extractBandSnip: "Especifica amb quines bandes cal treballar quan s'utilitzen datasets multibanda.",
		extractBandDesc: " La funció Extreu les bandes us permet extreure una o més bandes d'un dataset ràster multibanda, o bé reordenar-ne les bandes.<div><br/>Podeu utilitzar la funció Extreu les bandes abans que altres funcions, com ara Aritmètica, per controlar quines bandes s'utilitzaran com a entrada a la funció següent.</div>",
		fillName: "Emplena",
		fillSnip: "Emplena els embornals d'un ràster de superfície per eliminar petites imperfeccions de les dades.",
		fillDesc: "La funció Emplenament global localitza i emplena embornals i pics en un ràster de superfície d'elevació per eliminar petites imperfeccions de les dades. La funció realitzarà l'emplenament en un procés iteratiu fins que tots els embornals s'hagin emplenat dins del límit Z especificat.<div><br/>Quan es crea una superfície d'elevació amb les eines de representació cartogràfica d'ortofotos o per altres mitjans, acostumen a produir-se errors menors, però significatius, en la forma dels embornals i pics de les dades. En l'àmbit de la fotogrametria, els embornals i pics s'acostumen a anomenar \"forats i pics\". Atès que les dades de superfície s'acostumen a utilitzar per a la modelització, com ara la modelització hidrològica, és important corregir aquests errors d'embornals i pics de manera coherent amb les dades de l'entorn.</div>",
		floatName: "Punt flotant",
		floatSnip: "Converteix cada valor de cel·la d'un ràster en una representació de punt flotant.",
		floatDesc: "La funció Punt flotant converteix cada valor de píxel d'un ràster en una representació de punt flotant.",
		flowAccumulationName: "Acumulació de flux",
		flowAccumulationSnip: "Crea un ràster de flux acumulat a cada cel·la. De manera opcional, es pot aplicar un factor de ponderació.",
		flowAccumulationDesc: "La funció Acumulació de flux global crea un ràster del flux acumulat en cada píxel, tal com determina l'acumulació de la ponderació de tots els píxels que flueixen a cada píxel de pendent descendent. Si no es proporciona cap ràster de ponderació, s'aplicarà una ponderació d'1 a cada píxel, i el valor dels píxels del ràster de sortida serà el nombre de píxels que flueixen a cada píxel.<div><br/>Els píxels de sortida amb una acumulació de flux alta són àrees de flux concentrat i es poden utilitzar per identificar canals de corrent. Els píxels de sortida amb una acumulació de flux alta són àrees de flux concentrat i es poden utilitzar per identificar canals de corrent.</div>",
		flowDirectionName: "Direcció del flux",
		flowDirectionSnip: "Crea un ràster de direcció del flux des de cada cel·la fins al veí de pendent descendent més pronunciat.",
		flowDirectionDesc: "Una de les claus per derivar característiques hidrològiques d'una superfície és la possibilitat de determina la direcció del flux des de cada píxel del ràster. La funció de ràster Direcció del flux pren una superfície com a entrada i crea un ràster de direcció del flux des de cada píxel fins al veí de pendent descendent més pronunciat. La funció Direcció del flux admet tres mètodes de modelització de flux: D8 (vuit direccions), Direcció del flux múltiple (MFD) i D-Infinity (DINF). ",
		flowDistanceName: "Distància del flux",
		flowDistanceSnip: "Calcula, per a cada cel·la, la distància horitzontal o vertical mínima del pendent descendent a les cel·les en un riu o un corrent al qual flueixen.",
		flowDistanceDesc: "Per a cada píxel, la funció calcularà la distància horitzontal o vertical mínima del pendent descendent als píxels en un riu o un corrent al qual flueixen. Si es proporciona un ràster de direcció del flux opcional, les direccions del pendent descendent es limitaran a les definides pel ràster de direcció del flux d'entrada. La sortida és un ràster de distància del flux.",
		focalName: "Estadístiques focals",
		focalSnip: "Calcula les estadístiques focals de cada píxel d'una imatge en funció del veïnat focal definit.",
		focalDesc: "La funció Estadístiques focals calcula les estadístiques focals de cada píxel d'una imatge en funció del veïnat focal definit.",
		geometricName: "Geomètrica",
		geometricSnip: "Augmenta la precisió de la posició d'un dataset en tenir en compte l'elevació.",
		geometricDesc: "La funció Geomètrica genera una imatge ortorectificada basada en una definició de sensor i un model de terreny. Augmenta la precisió de la posició d'un dataset en tenir en compte l'elevació.",
		grayscaleName: "Escala de grisos",
		grayscaleSnip: "Converteix una imatge multibanda en una imatge en escala de grisos d'una banda.",
		grayscaleDesc: "Aquesta funció converteix una imatge multibanda en una imatge en escala de grisos d'una banda.<div><br/>Aquesta funció aplica ponderacions especificades a cadascuna de les bandes d'entrada i normalitza la imatge de sortida. Les ponderacions s'acostumen a aplicar perquè algunes bandes tenen una importància variable segons l'aplicació. Per exemple, la banda blava acostuma a contenir més soroll que les altres.</div>",
		greaterThanEqualName: "Major o igual que",
		greaterThanEqualSnip: "Realitza una operació de superioritat o igualtat relacional en dues entrades cel·la per cel·la. Retorna el valor 1 per a les cel·les on el primer ràster és major o igual que el segon i el valor 0 si no ho és.",
		greaterThanEqualDesc: "La funció realitza una operació de superioritat o igualtat relacional en dues entrades píxel per píxel. Retorna un valor d'1 per als píxels on el primer ràster és major o igual que el segon i un valor de 0 per als píxels on el primer ràster no és major ni igual que el segon.",
		greaterThanName: "Major que",
		greaterThanSnip: "Realitza una operació de superioritat relacional en dues entrades cel·la per cel·la. Retorna el valor 1 per a les cel·les on el primer ràster és major que el segon i el valor 0 si no ho és.",
		greaterThanDesc: "La funció realitza una operació de superioritat relacional en dues entrades píxel per píxel. Retorna un valor d'1 per als píxels on el primer ràster és major que el segon i un valor de 0 per als píxels on el primer ràster no és major que el segon.",
		heatIndexName: "Índex de calor",
		heatIndexSnip: "Combina la temperatura ambient de l'aire i la humitat relativa per retornar la temperatura aparent.",
		heatIndexDesc: "Aquesta funció calcula la temperatura aparent en funció de la temperatura ambient i la humitat relativa. La temperatura aparent s'acostuma a descriure com a sensació tèrmica.<div><br/>Aquest índex pot resultar útil per calcular els perills relacionats amb problemes mèdics, com ara rampes, deshidratació, insolacions o cops de calor greus en dies càlids i humits. Si la humitat relativa és alta, cada cop es fa més difícil per al cos evaporar la suor, i les persones perden la seva capacitat natural per baixar la temperatura corporal de manera eficaç. Els mapes de consells o avisos d'altes temperatures acostumen a ser un mètode per organitzar el resultat d'índex de calor en classes. Com més alt és el valor d'índex, més probable és que esdevingui un avís que no pas un consell.</div>",
		hillshadeName: "Ombreig",
		hillshadeSnip: "Crea una representació 3D de la superfície, tenint en compte la posició relativa del sol per ombrejar la imatge",
		hillshadeDesc: "La funció Ombreig genera una representació 3D en escala de grisos de la superfície del terreny, tenint en compte la posició relativa del sol per ombrejar la imatge. <div><br/>L'ombreig és una tècnica per visualitzar terreny determinada per una font d'il·luminació i pel pendent i l'orientació de la superfície d'elevació. És un mètode qualitatiu per visualitzar topografia, que no proporciona valors d'elevació absoluts. </div>",
		intName: "Enter",
		intSnip: "Converteix cada valor de cel·la d'un ràster en un enter per truncament.",
		intDesc: "La funció Enter converteix cada valor de píxel d'un ràster en un enter mitjançant el truncament.",
		interpolateIrregularDataName: "Interpola dades irregulars",
		interpolateIrregularDataSnip: "Realitza la interpolació des de núvols de punts o quadrícules irregulars.",
		interpolateIrregularDataDesc: "Alguns datasets de netCDF o HDF emmagatzemen la seva geolocalització com a matrius de píxels o dades de punts amb espais irregulars. En afegir aquests datasets a un dataset de mosaic, la funció Interpola dades irregulars pren les dades quadriculades irregulars i les torna a mostrejar perquè cada píxel tingui una mida uniforme i sigui quadrat.<div><br/>En afegir variables de netCDF o HDF a un dataset de mosaic, es verificarà automàticament si les dades s'han disposat a la matriu correctament. En cas contrari, la funció Interpola dades irregulars s'utilitzarà per convertir les dades irregulars en un ràster quadriculat regular. Podeu canviar el mètode d'interpolació i la mida de la cel·la que s'utilitzen a la funció de ràster Interpola dades irregulars. En el cas de les dades de ràster amb espais regulars, no s'aplicarà cap interpolació i les dades es llegiran tal qual.</div>",
		isNullName: "És nul",
		isNullSnip: "Determina quins valors dels ràsters d'entrada són NoData cel·la per cel·la. Retorna un valor d'1 si els valors d'entrada són NoData i de 0 per a les cel·les que no presenten aquest valor.",
		isNullDesc: "La funció És nul determina quins valors del ràster d'entrada són NoData píxel per píxel. Retorna un valor d'1 si el valor d'entrada és NoData i un valor de 0 per als píxels que no són NoData.",
		kernelDensityName: "Densitat del nucli",
		kernelDensitySnip: "Aquesta funció calcula una àrea de magnitud per unitat des de les entitats de punt o polilínia mitjançant una funció de nucli per ajustar una superfície suaument estreta a cada punt o polilínia.",
		kernelDensityDesc: "Aquesta funció calcula una àrea de magnitud per unitat des de les entitats de punt o polilínia mitjançant una funció de nucli per ajustar una superfície suaument estreta a cada punt o polilínia.",
		keyMetadataName: "Metadades clau",
		keyMetadataSnip: "Invalida o insereix metadades clau d'un ràster en una cadena de funcions.",
		keyMetadataDesc: "Aquesta funció us permet inserir o invalidar metadades clau d'un ràster.<div><br/>La informació de les metadades clau s'utilitza per ajudar l'aplicació amb algunes tasques de processament i representació, inclòs el subministrament d'algunes dades útils, com ara el nom del sensor, els noms de les bandes o la cobertura del núvol, associades a les imatges.</div>",
		shortestPathName: "Ruta de menor cost",
		shortestPathSnip: "Realitza una anàlisi de cost de distància mitjançant les entrades d'origen i destinació, que s'utilitzarà posteriorment per determinar la ruta de menor cost des d'un origen fins a una destinació.",
		shortestPathDesc: "La funció Ruta de menor cost calcula la ruta de menor cost des d'un origen fins a una destinació. La distància de menor cost acumulatiu es calcula per a cada píxel sobre una superfície de cost, fins a l'origen més proper. Genera un ràster de sortida que registra la ruta o les rutes de menor cost des de les ubicacions seleccionades fins als píxels d'origen més propers definits a la superfície de cost acumulatiu, en termes de cost en pla.<div><br/>S'assigna un valor a cada ruta de menor cost quan es troba al procés d'escaneig. El píxel final del ràster d'origen d'una ruta de cost rep un valor d'1. La primera ruta rep un valor de 3, la segona rep un valor de 4 i així successivament. Quan diverses rutes es fusionen i segueixen la distància restant fins a un origen de la mateixa ruta, al segment on les dues rutes viatgen juntes se li assigna un valor de 2. A la part fusionada de la ruta no se li pot assignar el valor d'una de les rutes perquè aquesta part pertany a ambdues rutes.</div>",
		lessThanEqualName: "Menor o igual que",
		lessThanEqualSnip: "Realitza una operació d'inferioritat o igualtat relacional en dues entrades cel·la per cel·la. Retorna el valor 1 per a les cel·les on el primer ràster és menor o igual que el segon i el valor 0 si no ho és.",
		lessThanEqualDesc: "La funció realitza una operació d'inferioritat o igualtat relacional en dues entrades píxel per píxel. Retorna un valor d'1 per als píxels on el primer ràster és menor o igual que el segon i un valor de 0 per als píxels on el primer ràster no és menor ni igual que el segon.",
		lessThanName: "Menor que",
		lessThanSnip: "Realitza una operació d'inferioritat relacional en dues entrades cel·la per cel·la. Retorna el valor 1 per a les cel·les on el primer ràster és menor que el segon i el valor 0 si no ho és.",
		lessThanDesc: "La funció realitza una operació d'inferioritat relacional en dues entrades píxel per píxel. Retorna un valor d'1 per als píxels on el primer ràster és menor que el segon i un valor de 0 per als píxels on el primer ràster no és menor que el segon.",
		lnName: "Logaritme neperià (Ln)",
		lnSnip: "Calcula el logaritme natural (base e) de les cel·les d'un ràster.",
		lnDesc: "La funció Logaritme neperià (Ln) calcula el logaritme natural (base e) de cada píxel d'un ràster.",
		log10Name: "Logaritme en base 10 (Log10)",
		log10Snip: "Calcula el logaritme en base 10 de les cel·les d'un ràster.",
		log10Desc: "La funció Logaritme en base 10 (Log10) calcula el logaritme en base 10 de cada píxel d'un ràster.",
		log2Name: "Logaritme en base 2 (log2)",
		log2Snip: "Calcula el logaritme en base 2 de les cel·les d'un ràster.",
		log2Desc: "La funció Logaritme en base 2 (log2) calcula el logaritme en base 2 de cada píxel d'un ràster.",
		lookupName: "Cerca",
		lookupSnip: "Crea un nou ràster mitjançant la cerca dels valors que es troben en un altre camp de la taula del ràster d'entrada.",
		lookupDesc: "La funció crea un nou ràster mitjançant la cerca dels valors que es troben en un altre camp de la taula del ràster d'entrada.",
		mlClassifyName: "Classificació ML",
		mlClassifySnip: "Classifica les imatges mitjançant un plantejament per píxel. Els píxels combinats s'assignen a l'entitat amb el percentatge més alt del píxel.",
		mlClassifyDesc: "La funció Classificació ML us permet realitzar una classificació supervisada, mitjançant l'algoritme de classificació de màxima versemblança, en un dataset de ràster o un dataset de mosaic. Aquesta funció necessita un fitxer de signatura de classificació.",
		maskName: "Màscara",
		maskSnip: "Defineix els valors que no voleu mostrar.",
		maskDesc: "Aquesta funció de ràster defineix els valors que no voleu mostrar al vostre ràster. Amb la funció Màscara, especificareu un o diversos valors NoData, o bé un interval de valors de píxel vàlids. ",
		minusName: "Resta",
		minusSnip: "Resta el valor del segon ràster d'entrada del valor del primer ràster d'entrada píxel per píxel.",
		minusDesc: "La funció Resta sostreu el valor del segon ràster d'entrada del valor del primer ràster d'entrada píxel per píxel.",
		modName: "Mòdul",
		modSnip: "Cerca la resta (mòdul) del primer ràster quan es divideix pel segon ràster cel·la per cel·la.",
		modDesc: "La funció Mòdul cerca la resta (mòdul) del primer ràster quan es divideix pel segon ràster píxel per píxel. L'ordre de les entrades és important i afecta el resultat de sortida.",
		mosaicRastersName: "Ràsters de mosaic",
		mosaicRastersSnip: "Uneix un conjunt de datasets de ràster per crear un dataset.",
		mosaicRastersDesc: "La funció Ràsters de mosaic crea una imatge de mosaic a partir de diverses imatges. Si hi ha superposició entre les imatges, podeu triar entre diversos mètodes per determinar quines es mostraran.",
		ndviColorizedName: "NDVI en color",
		ndviColorizedSnip: "Crea un dataset multibanda que representa l'estat de la vegetació segons la diferència entre la banda d'infrarojos vermella i les properes.",
		ndviColorizedDesc: "La funció NDVI en color aplica la funció NDVI a la imatge d'entrada i, a continuació, utilitza un mapa de color o una rampa de color per mostrar el resultat.",
		ndviName: "NDVI",
		ndviSnip: "Calcula l'índex de vegetació amb diferència normalitzada (NDVI).",
		ndviDesc: "La funció NDVI crea un dataset d'una banda que representa l'estat de la vegetació segons la diferència entre la banda vermella i la d'infraroig proper.<div><br/>NDVI és un índex estandarditzat que us permet generar una imatge que mostri la verdor, també coneguda com biomassa relativa. Aquest índex aprofita el contrast de les característiques entre dues bandes d'un dataset ràster multiespectral: l'absorció de pigment de clorofil·la de la banda vermella i l'altra reflectivitat del material de les plantes de la banda d'infraroig proper (NIR). Els valors d'NDVI extremadament baixos o negatius representen les àrees sense res de vegetació, com ara núvols, aigua o neu. Els valors molt baixos representen àrees sense vegetació o amb vegetació escassa, com ara ciment, roques o sòl nu. Els valors moderats representen zones d'arbustos i prats. Els valors alts representen àrees forestals i vegetació abundant.</div>",
		negateName: "Canvi de signe",
		negateSnip: "Canvia el signe (multiplica per -1) dels valors de cel·la del ràster d'entrada cel·la per cel·la.",
		negateDesc: "La funció Canvi de signe canvia el signe (multiplica per -1) dels valors de píxel del ràster d'entrada en un píxel ",
		nibbleName: "Nibble",
		nibbleSnip: "Substitueix les cel·les d'un ràster corresponent a una màscara amb els valors dels veïns més propers.",
		nibbleDesc: "La funció Nibble global permet assignar a les àrees seleccionades d'un ràster el valor del veí més proper. Resulta útil per editar les àrees d'un ràster on les dades poden ser errònies.",
		notEqualName: "No igual",
		notEqualSnip: "Realitza una operació de desigualtat relacional en dues entrades cel·la per cel·la. Retorna el valor 1 per a les cel·les on el primer ràster no és igual que el segon i el valor 0 on sí que ho és.",
		notEqualDesc: "La funció realitza una operació de desigualtat relacional en dues entrades píxel per píxel. Retorna un valor d'1 per als píxels on el primer ràster no és igual que el segon i un valor de 0 per als píxels on el primer ràster és igual que el segon.",
		pansharpeningName: "Enfocament pancromàtic",
		pansharpeningSnip: "Millora de manera artificial la resolució espacial d'una imatge multibanda fusionant-la amb una imatge pancromàtica de resolució superior.",
		pansharpeningDesc: "La funció Enfocament pancromàtic utilitza una imatge pancromàtica d'alta resolució o una banda de ràster per fusionar-la amb un dataset ràster multibanda de baixa resolució a fi d'augmentar la resolució espacial de la imatge multibanda.<div><br/>La finalitat de l'enfocament pancromàtic és crear una imatge visual de qualitat superior. Atès que les tècniques alteren la radiometria i les característiques espectrals de les imatges multibanda, les imatges amb enfocament pancromàtic s'han d'utilitzar amb precaució per a les finalitats de teledetecció analítica.</div>",
		pathAllocationName: "Assignació de distància de ruta",
		pathAllocationSnip: "La funció Assignació de distància de ruta calcula l'origen més proper per a cada cel·la en funció del menor cost acumulatiu sobre una superfície de cost, alhora que té en compte la distància de superfície i els factors de cost horitzontal i vertical.",
		pathAllocationDesc: "La funció Assignació de distància de ruta calcula l'origen més proper per a cada cel·la en funció del menor cost acumulatiu sobre una superfície de cost, alhora que té en compte la distància de superfície i els factors de cost horitzontal i vertical.",
		pathBackLinkName: "Enllaç de menor distància de ruta",
		pathBackLinkSnip: "Defineix el veí que és la cel·la següent a la ruta de menor cost acumulatiu a l'origen de menor cost, alhora que té en compte la distància de superfície, juntament amb els factors de cost horitzontal i vertical.",
		pathBackLinkDesc: "La funció Enllaç de menor distància de ruta identifica la direccionalitat del veí que és la cel·la següent a la ruta de menor cost acumulatiu a l'origen més proper, alhora que té en compte la distància de superfície i els factors de cost horitzontal i vertical.",
		pathDistanceName: "Distància de ruta",
		pathDistanceSnip: "Calcula, per a cada cel·la, la distància de menor cost acumulatiu des de o fins a l'origen de menor cost, alhora que té en compte la distància de superfície, juntament amb els factors de cost horitzontal i vertical.",
		pathDistanceDesc: "La funció Distància de ruta calcula, per a cada cel·la, la distància de menor cost acumulatiu a l'origen més proper, alhora que té en compte la distància de superfície i els factors de cost horitzontal i vertical.",
		plusName: "Plus",
		plusSnip: "Afegeix (suma) els valors de dos ràsters cel·la per cel·la.",
		plusDesc: "La funció Suma afegeix els valors de dos ràsters píxel per píxel.",
		powerName: "Potència",
		powerSnip: "Eleva els valors de cel·la d'un ràster a la potència dels valors que es troben en un altre ràster.",
		powerDesc: "La funció Potència eleva els valors de píxel d'un ràster a la potència dels valors que es troben en un altre ràster.",
		radarCalibrationName: "Calibratge de radar",
		radarCalibrationSnip: "Converteix la retrodispersió de RADARSAT-2.",
		radarCalibrationDesc: "Aquesta funció es pot utilitzar per calibrar imatges RADARSDAT-2 en un dataset de mosaic o com un producte ràster. El calibratge es realitza en imatges de radar perquè els valors de píxel siguin una representació real de la retrodispersió de radar.",
		rasterInfoName: "Informació del ràster",
		rasterInfoSnip: "Modifica les propietats del ràster, com ara la profunditat de bits, el valor NoData, la mida de la cel·la, etc.",
		rasterInfoDesc: "La funció Informació del ràster obre un quadre de diàleg amb propietats del dataset ràster, com ara el nombre de columnes i files, el nombre de bandes, el tipus de píxel, l'extensió i la referència espacial. Per editar aquestes propietats, podeu seleccionar un dataset ràster per utilitzar-lo com una plantilla. ",
		rasterizeAttributesName: "Rasteritza atributs",
		rasterizeAttributesSnip: "Enriqueix un ràster mitjançant bandes addicionals derivades dels valors dels atributs especificats d'una taula externa o un servei d'entitats.",
		rasterizeAttributesDesc: "La funció Rasteritza atributs enriqueix un ràster mitjançant l'addició de bandes derivades dels valors dels atributs especificats d'una taula externa o un servei d'entitats. També podeu especificar un ràster de zona i l'atribut d'ID de zona associat per activar la cerca basada en la regió.",
		rasterizeFeatureClassName: "Rasteritza entitats",
		rasterizeFeatureClassSnip: "Converteix entitats en ràsters.",
		rasterizeFeatureClassDesc: "Aquesta funció converteix les dades de les classes d'entitats de polígons, polilínies i punts en una capa de ràster.<div><br/>S'assignen valors de píxel a les entitats basats en el valor del camp OBJECTID de les entitats (per defecte). De manera opcional, els valors de píxel es poden basar en un camp de valor definit per l'usuari de la taula d'atributs de l'entitat d'entrada.</div>",
		recastName: "Reformula",
		recastSnip: "Modifica els paràmetres d'una cadena de funcions en un dataset de mosaic o un servei d'imatges. S'acostuma a utilitzar amb datasets LAS per evitar haver de crear un dataset de mosaic independent per a les diferents representacions del terreny.",
		recastDesc: "La funció Reformula s'utilitza per modificar de manera dinàmica el paràmetre de funció utilitzat en un dataset de mosaic o un servei d'imatges sense mantenir els canvis físicament.",
		regionGroupName: "Grup de regions",
		regionGroupSnip: "Per a cada cel·la de la sortida, es registra la identitat de la regió connectada a la qual pertany la cel·la. S'assigna un nombre únic a cada regió.",
		regionGroupDesc: "La funció Grup de regions global registra, per a cada cel·la de la sortida, la identitat de la regió connectada a la qual pertany la cel·la. S'assigna un nombre únic a cada regió.<div><br/>La primera regió escanejada rep el valor u, la segona rep el dos i així successivament, fins que totes les regions tenen un valor assignat. L'escaneig es mou d'esquerra a dreta i de dalt a baix. Els valors assignats a les zones de sortida es basen en el moment en què es troben al procés d'escaneig.</div>",
		regionGrowName: "Creixement de regió",
		regionGrowSnip: "Fa créixer les regions des dels punts d'origen.",
		regionGrowDesc: "La funció Creixement de regió agrupa els píxels veïns en funció del radi especificat des del punt d'origen. S'assigna un valor d'emplenament especificat al grup de píxels o l'objecte.",
		remapName: "Nova representació cartogràfica",
		remapSnip: "Canvia els valors de píxel mitjançant l'assignació de nous valors a intervals de valors de píxel o bé a través d'una taula externa.",
		remapDesc: "La funció Nova representació cartogràfica permet canviar o tornar a classificar els valors de píxel de les dades del ràster. Aquesta acció es pot realitzar especificant un interval de valors de píxel per assignar a un valor de píxel de sortida, o bé mitjançant una taula per assignar els valors de píxel a un valor de píxel de sortida.",
		reprojectName: "Reprojecta",
		reprojectSnip: "Modifica la projecció d'un dataset ràster, un dataset de mosaic o un element de ràster d'un dataset de mosaic. També pot remostrejar les dades a una mida de cel·la nova i definir un origen.",
		reprojectDesc: "La funció Reprojecta modifica la projecció d'un dataset ràster, un dataset de mosaic o un element de ràster d'un dataset de mosaic. També pot remostrejar les dades a una mida de cel·la nova i definir un origen.<div><br/>La funció Reprojecta es pot utilitzar en crear una memòria cau a partir d'un dataset ràster o de mosaic que no es troba a la projecció necessària. Per exemple, en crear un servei d'imatges emmagatzemat a la memòria cau que podria estar integrat per altres amb altres serveis emmagatzemats a la memòria cau, és important que tots estiguin a la mateixa projecció. Acostuma a ser una projecció del Web Mercator. Atès que el dataset de mosaic no es pot reprojectar, podeu realitzar una de les accions següents: crear un dataset de mosaic de referència a partir del vostre dataset de mosaic de la projecció necessària o afegir la funció Reprojecta a la cadena de funcions del dataset de mosaic. Un altre exemple utilitza aquesta funció a l'element de ràster d'un dataset de mosaic. Quan utilitzeu la funció Ràster emmagatzemat a la memòria cau, podeu inserir la funció Reprojecta perquè la memòria cau es creï a la projecció nova. Els elements de ràster d'un dataset de mosaic es poden emmagatzemar a la memòria cau quan el processament és intens i intenteu publicar un servei d'imatges d'alta velocitat, sense emmagatzemar tot el servei d'imatges a la memòria cau.</div>",
		resampleName: "Remostreja",
		resampleSnip: "Canvia la mida de la cel·la d'un ràster.",
		resampleDesc: "La funció Remostreja canvia la mida de la cel·la, el tipus de remostreig o ambdues coses.<div><br/>La funció Remostreja només s'ha d'utilitzar per a requisits de càlcul específics; per exemple, quan calculeu la magnitud-direcció del vent o el corrent que requereix el remostreig de la resolució d'origen.</div>",
		roundDownName: "Arrodoniment a la baixa",
		roundDownSnip: "Retorna el següent valor enter més baix, representat com un valor de punt flotant, de cada cel·la d'un ràster.",
		roundDownDesc: "La funció Arrodoniment a la baixa retorna el següent enter més baix, com un valor de punt flotant, de cada píxel d'un ràster.",
		roundUpName: "Arrodoniment a l'alça",
		roundUpSnip: "Retorna el següent valor enter més alt, representat com un valor de punt flotant, de cada cel·la d'un ràster.",
		roundUpDesc: "La funció Arrodoniment a l'alça retorna el següent enter més alt, com un valor de punt flotant, de cada píxel d'un ràster.",
		segmentMeanShiftName: "Desplaçament mitjà de segment",
		segmentMeanShiftSnip: "Agrupa els píxels veïns amb característiques espectrals similars en segments.",
		segmentMeanShiftDesc: "Aquesta funció identifica objectes, entitats o segments de les imatges mitjançant l'agrupació dels píxels adjacents que tenen característiques espectrals i espacials similars. Podeu controlar la quantitat de suavització espacial i espectral per ajudar a derivar entitats d'interès.",
		s1RadiometricCalibrationName: "Calibratge radiomètric de Sentinel-1",
		s1RadiometricCalibrationSnip: "Realitza diferents tipus de calibratge radiomètric a les dades de Sentinel-1.",
		s1RadiometricCalibrationDesc: "Aquesta funció de ràster realitza tres calibratges diferents per als datasets de Sentinel 1, inclosos beta zero i gamma, i genera el dataset calibrat. L'objectiu del calibratge de SAR és proporcionar imatges en què els valors de píxel es pugui relacionar directament a la retrodispersió del radar de l'escena. Malgrat que les imatges de SAR sense calibrar són suficients per a un ús qualitatiu, les imatges de SAR calibrades són essencials per a l'ús quantitatiu de les dades de SAR.<div><br/>El processament habitual de les dades de SAR, que produeix imatges de nivell 1, no inclou correccions radiomètriques i es manté un biaix radiomètric considerable. Per tant, és necessari aplicar la correcció radiomètrica a les imatges de SAR perquè els valors de píxel de les imatges representin realment la retrodispersió del radar de la superfície reflectora. La correcció radiomètrica també és necessària per a la comparació de les imatges de SAR adquirides amb sensors diferents o adquirides des del mateix sensor en moments diferents, adquirides en modes diferents o processades per processadors diferents.</div>",
		s1ThermalNoiseRemovalName: "Eliminació de soroll tèrmic de Sentinel-1",
		s1ThermalNoiseRemovalSnip: "Elimina el soroll tèrmic de les dades de Sentinel-1.",
		s1ThermalNoiseRemovalDesc: "La correcció de soroll tèrmic es pot aplicar als productes Single Look Complex (SLC) de nivell 1 i als productes Level-1 Ground Range Detection (GRD) de Sentinel-1 que encara no s'han corregit. L'operador també pot eliminar aquesta correcció d'acord amb les anotacions del producte per tornar a introduir el senyal de soroll que s'ha eliminat per produir el producte original. Les anotacions del producte s'actualitzaran en conseqüència per tornar a aplicar la correcció. ",
		setNullName: "Defineix nuls",
		setNullSnip: "La funció Defineix nuls estableix les ubicacions de cel·la identificades en NoData en funció d'uns criteris especificats. Retorna NoData si una avaluació condicional és certa i retorna el valor especificat per un altre ràster si és falsa.",
		setNullDesc: "La funció Defineix nuls estableix els píxels identificats en NoData, segons els criteris específics. Retorna NoData si una avaluació condicional és certa (1) i retorna el valor especificat al ràster fals si una avaluació condicional és falsa (0). Aquest criteri l'especifica la sortida d'una funció matemàtica lògica, que serà el ràster d'entrada.",
		shadedReliefName: "Relleu ombrejat",
		shadedReliefSnip: "Crea una representació 3D de la superfície multibanda amb codificació de color, tenint en compte la posició relativa del sol per ombrejar la imatge.",
		shadedReliefDesc: "La funció Relleu ombrejat crea una representació 3D en color del terreny mitjançant la fusió de les imatges a partir dels mètodes de codificació d'elevació i ombreig. Aquesta funció utilitza les propietats d'altitud i d'azimut per especificar la posició del sol.<div><br/></div>",
		sinHName: "Sinus hiperbòlic (SinH)",
		sinHSnip: "Calcula el sinus hiperbòlic de les cel·les d'un ràster.",
		sinHDesc: "La funció calcula el sinus hiperbòlic dels píxels d'un ràster.",
		sinName: "Sinus (Sin)",
		sinSnip: "Calcula el sinus de les cel·les d'un ràster.",
		sinDesc: "La funció calcula el sinus dels píxels d'un ràster.",
		slopeName: "Pendent",
		slopeSnip: "Calcula l'índex de canvi d'un valor de píxel respecte als seus veïns.",
		slopeDesc: "Aquesta funció de ràster calcula el pendent, que és l'índex de canvi d'elevació de cada cel·la del model d'elevació digital (DEM). És la primera derivada d'un DEM.<div><br/>Aquesta funció utilitza una funció atan() accelerada. És sis vegades més ràpida i l'error d'aproximació sempre és inferior a 0,3 graus.</div>",
		speckleName: "Pigallat",
		speckleSnip: "Proporciona filtres per eliminar el soroll dels datasets de radar d'obertura sintètica.",
		speckleDesc: "El pigallat és el soroll d'alta freqüència a les dades d'un radar. Les imatges que generen els sistemes de radar d'apertura sintètica (SAR) estan extremadament sotmesos als efectes del pigallat a causa del processament de senyals dispersos i de la interferència d'ones electromagnètiques dispersades des de superfícies o objectes. La funció Pigallat filtra el dataset de radar amb pigallat i suavitza el soroll mentre manté les vores o les entitats precises de la imatge.",
		spectralConversionName: "Conversió espectral",
		spectralConversionSnip: "Aplica una matriu a una imatge multibanda.",
		spectralConversionDesc: "La funció Conversió espectral aplica una matriu a una imatge multibanda per alterar els valors de color de la sortida.<div><br/>Alguns sensors no reben les bandes blaves a causa d'una relació senyal-soroll baixa. Per exemple, es pot utilitzar per convertir una imatge infraroja de colors falsos en una imatge de colors pseudonaturals.</div>",
		squareRootName: "Arrel quadrada",
		squareRootSnip: "Calcula l'arrel quadrada dels valors de cel·la d'un ràster.",
		squareRootDesc: "La funció Arrel quadrada calcula l'arrel quadrada dels valors de píxel d'un ràster.",
		squareName: "Quadrada",
		squareSnip: "Calcula el quadrat dels valors de cel·la d'un ràster.",
		squareDesc: "La funció Quadrat calcula el quadrat dels valors de píxel d'un ràster.",
		statisticsHistogramName: "Estadístiques i histograma",
		statisticsHistogramSnip: "Definiu o associeu les estadístiques i l'histograma.",
		statisticsHistogramDesc: "La funció Estadístiques i histograma s'utilitza per definir les estadístiques i l'histograma d'un ràster. Podeu inserir aquesta funció al final de la cadena de funcions per descriure les estadístiques i l'histograma d'una plantilla de funció de ràster (RFT). Pot ser necessari per controlar la visualització per defecte del resultat del processament, especialment en definir una cadena de funcions que conté moltes funcions.<div><br/>Per definir les estadístiques, podeu escriure els valors o importar-los d'un dataset ràster o un fitxer XML. Els histogrames només es poden definir important un fitxer.</div>",
		statisticsName: "Estadístiques",
		statisticsSnip: "Calcula les estadístiques focals de cada píxel d'una imatge en funció del veïnat focal definit.",
		statisticsDesc: "La funció Estadístiques calcula les estadístiques focals de cada píxel d'una imatge en funció del veïnat focal definit.<div><br/>La funció Estadístiques es pot utilitzar per emplenar línies no contínues en una imatge. Les línies no contínues les acostumen a causar problemes al sensor on no es recopilen dades. Això ha passat en sensors com ara l'Enhanced Thematic Mapper Plus (ETM+) de Landsat 7. Aquestes dades que falten provoquen problemes a l'anàlisi i també en l'observació de les imatges. Hi ha poca cosa a fer quan s'utilitzen les imatges per a l'anàlisi; això no obstant, si hi ha una imatge superposada, es pot utilitzar en lloc del contingut que falta. El mateix es pot fer si les imatges s'utilitzen per a la visualització. Però no sempre hi ha una imatge addicional per emplenar el contingut que falta i, aleshores, s'ha de derivar de les dades existents.</div>",
		streamLinkName: "Enllaç de corrent",
		streamLinkSnip: "Assigna valors únics a les seccions d'una xarxa de ràster lineal entre interseccions.",
		streamLinkDesc: "La funció Enllaç de corrent global assigna valors únics a les seccions d'una xarxa de ràster lineal entre interseccions.<div><br/>Els enllaços són les seccions d'un canal de corrent que connecta dos encreuaments successius, un encreuament i la sortida o un encreuament i la divisió de drenatge. En el camp de la hidrologia, aquests segments de corrent s'anomenen cursos. Un encreuament es relaciona amb un punt de fluïdesa i ajuda de delinear el límit de la subconca de la conca hidrogràfica o del drenatge.</div>",
		stretchName: "Estira",
		stretchSnip: "Ajusta l'interval de valors que es mostra per millorar una imatge. Això no altera els valors de píxel subjacents. Si el valor d'un píxel es troba fora de l'interval especificat, es mostrarà com el valor mínim o màxim.",
		stretchDesc: "La funció Estira modifica les propietats d'una imatge per millorar-la, com ara les de brillantor, contrast i gamma, mitjançant diversos tipus d'extensió. Aquesta funció utilitza les estadístiques dels ràsters del dataset de mosaic; per tant, si la utilitzeu, heu d'assegurar-vos que s'hagin calculat les estadístiques.<div><br/>El tipus d'extensió defineix una extensió d'histograma que s'aplicarà als ràsters per millorar-ne l'aparença. L'extensió millora l'aparença de les dades, ja que expandeix els valors de píxel en un histograma a partir dels valors mínim i màxim definits per la seva profunditat de bits. </div>",
		swathName: "Dallada",
		swathSnip: "Realitza la interpolació des de quadrícules o dades de dallada irregulars.",
		swathDesc: "Alguns datasets de netCDF o HDF emmagatzemen la seva geolocalització com a matrius amb espais irregulars. En afegir aquests datasets a un dataset de mosaic, la funció Dallada pren les dades quadriculades irregulars i les torna a mostrejar perquè cada píxel tingui una mida uniforme i sigui quadrat.<div><br/>En afegir variables de netCDF o HDF a un dataset de mosaic, es verificarà automàticament si les dades s'han disposat a la matriu correctament. En cas contrari, la funció Dallada s'aplica automàticament per convertir el ràster irregular en punts i, a continuació, en un ràster quadriculat regular. Podeu canviar el mètode d'interpolació i la mida de la cel·la que s'utilitzen a la funció de ràster Dallada. En el cas de les dades de ràster amb espais regulars, no s'aplicarà cap interpolació i les dades es llegiran tal qual.</div>",
		tanHName: "Tangent hiperbòlica (TanH)",
		tanHSnip: "Calcula la tangent hiperbòlica de les cel·les d'un ràster.",
		tanHDesc: "La funció calcula la tangent hiperbòlica dels píxels d'un ràster.",
		tanName: "Tangent (Tan)",
		tanSnip: "Calcula la tangent de les cel·les d'un ràster.",
		tanDesc: "La funció calcula la tangent dels píxels d'un ràster. ",
		tasseledCapName: "Tasseled Cap (Kauth-Thomas)",
		tasseledCapSnip: "Calcula els nivells de vegetació, humitat i brillantor. Aquesta tècnica depèn de coeficients que s'han de calcular específicament per a un sensor.",
		tasseledCapDesc: "La transformació Tasseled Cap (Kauth-Thomas) s'ha dissenyat per analitzar i assignar fenomenologia de la vegetació i canvis de desenvolupament urbà a través de diversos sistemes de sensors satel·litals. Es coneix com a transformació Tasseled Cap a causa de la forma de la distribució gràfica de les dades. La transformació va proporcionar una lògica per als patrons trobats a les dades MSS Landsat de camps agrícoles com una funció del cicle de vida del cultiu. Essencialment, a mesura que els cultius creixen des de la llavor fins a la maduresa, hi ha un augment net de l'infraroig vermell i una reducció de la reflectància vermella en base al color del sòl<div><br/>La utilitat d'aquesta transformació s'ha ampliat des de la supervisió dels cultius fins a l'anàlisi i l'assignació de vegetació per donar suport a una àmplia varietat d'aplicacions, com ara la silvicultura, la gestió de la vegetació industrial, la representació cartogràfica i la gestió dels ecosistemes, l'inventari i el control de l'aïllament del carboni i els crèdits, el desenvolupament urbà, etc. També s'ha ampliat de la compatibilitat amb MSS Landsat per incloure altres sistemes de satèl·lit populars, com ara Landsat TM, Landsat ETM+, Landsat 8, IKONOS, QuickBird, WorldView-2 i els sensors multiespectrals RapidEye.</div>",
		timesName: "Multiplicació",
		timesSnip: "Multiplica els valors de dos ràsters cel·la per cel·la.",
		timesDesc: "La funció Multiplicació multiplica els valors de dos ràsters píxel per píxel.",
		transposeBitsName: "Transposa els bits",
		transposeBitsSnip: "Desempaqueta els bits del píxel d'entrada i els assigna als bits especificats del píxel de sortida. La finalitat d'aquesta funció és manipular els bits d'un parell d'entrades, com ara els productes de banda de qualitat de Landsat 8.",
		transposeBitsDesc: "La funció Transposa els bits desempaqueta els bits del píxel d'entrada i els assigna als bits especificats del píxel de sortida. La finalitat d'aquesta funció és manipular els bits d'un parell d'entrades, com ara els productes de banda de qualitat de Landsat 8.",
		unitConversionName: "Conversió d'unitats",
		unitConversionSnip: "Canvia els valors d'una unitat de mesura a una altra.",
		unitConversionDesc: "Aquesta funció converteix els píxels d'una unitat a una altra. Admet la conversió de distància, velocitat i temperatura.",
		vectorFieldName: "Camp vectorial",
		vectorFieldSnip: "Mostra els datasets amb els valors de magnitud (u) i direcció (v) com fletxes on la magnitud es representa per la mida de la fletxa i la direcció, pel seu angle.",
		vectorFieldDesc: "La funció Camp vectorial s'utilitza per compondre i convertir dos ràsters en un ràster de dues bandes, que sigui del tipus de dades magnitud-direcció o U-V.<div><br/>De vegades, ens referim al valor U com a velocitat zonal i al valor V, com a velocitat meridional.</div>",
		viewshed2Name: "Conca visual",
		viewshed2Snip: "Determina les ubicacions en una superfície de ràster que són visibles per a un conjunt d'entitats d'observador mitjançant mètodes geodèsics.",
		viewshed2Desc: "La funció Conca visual determina les ubicacions en una superfície de ràster que són visibles per a un conjunt d'entitats d'observador mitjançant mètodes geodèsics<div><br/>La visibilitat de cada centre del píxel ve determinada per una prova de línia de visió entre l'objectiu i cada observador. Si un observador pot veure l'objectiu al centre del píxel, el píxel es considera visible. Aquesta eina sempre considera la curvatura de la Terra quan es determina la visibilitat.</div>",
		watershedName: "Conca hidrogràfica",
		watershedSnip: "Determina l'àrea de contribució sobre un conjunt de cel·les d'un ràster",
		watershedDesc: "La funció Conca hidrogràfica global determina l'àrea de contribució sobre un conjunt de píxels d'un ràster. Les conques hidrogràfiques es delineen a partir d'un ràster de direcció del flux que identifica la direcció del flux de cada píxel.",
		weightedOverlayName: "Superposició ponderada",
		weightedOverlaySnip: "Superposa diversos ràsters mitjançant una escala de mesura comuna i pondera cadascun segons la seva importància.",
		weightedOverlayDesc: "Aquesta funció us permet superposar diversos ràsters mitjançant una escala de mesura comuna i pondera cadascun segons la seva importància.",
		weightedSumName: "Suma ponderada",
		weightedSumSnip: "Pondera i afegeix una matriu de ràsters cel·la per cel·la.",
		weightedSumDesc: "La funció Suma ponderada us permet superposar diversos ràsters. Multiplica cadascun d'aquests ràsters pel pes especificat i fa la suma de tots els valors.",
		windchillName: "Sensació tèrmica",
		windchillSnip: "Combina la temperatura ambient de l'aire amb la velocitat del vent per calcular el factor de sensació tèrmica.",
		windchillDesc: "La funció Sensació tèrmica resulta útil per identificar condicions hivernals perilloses que, en funció del temps d'exposició als elements, pot produir congelació o fins i tot hipotèrmia. La sensació tèrmica és una manera de mesurar el fred que sent una persona tenint en compte el vent quan les temperatures ja són fredes. Com més alta sigui la velocitat del vent, més ràpida serà la pèrdua de calor i més fred sentirà la persona.",
		zonalRemapName: "Nova representació cartogràfica zonal",
		zonalRemapSnip: "Feu una nova representació cartogràfica dels píxels d'un ràster segons les zones definides en un altre ràster i de l'assignació del valor dependent de la zona definit en una taula.",
		zonalRemapDesc: "Aquesta funció us permet fer una nova representació cartogràfica dels píxels d'un ràster segons les zones definides en un altre ràster i de l'assignació del valor dependent de la zona definit en una taula.",
		zonalStatisticsName: "Estadístiques zonals",
		zonalStatisticsSnip: "Calcula estadístiques sobre els valors d'un ràster dins de les zones d'un altre dataset.",
		zonalStatisticsDesc: "La funció calcula estadístiques sobre els valors d'un ràster dins de les zones d'un altre dataset. Una zona es defineix com totes les àrees de l'entrada que tenen el mateix valor. No és necessari que aquestes àrees siguin contigües. Si ambdues entrades de zona i valor són ràsters de la mateixa resolució, s'utilitzaran directament. Si les resolucions són diferents, s'aplica un remostreig intern per fer que les resolucions coincideixin abans de realitzar l'operació zonal.",
		flowLengthName: "Longitud del flux",
		flowLengthSnip: "Calcula la distància ascendent o descendent, o bé la distància ponderada, juntament amb el recorregut del flux de cada cel·la.",
		flowLengthDesc: "Aquesta és una funció de ràster global. Aquesta funció crea una capa ràster de distància ascendent o descendent, o bé de distància ponderada, juntament amb el recorregut del flux de cada cel·la.<div><br/>Un ús primari de la funció Longitud del flux és el càlcul de la longitud del recorregut del flux més llarg en una conca determinada. Normalment, aquesta mesura s'utilitza per calcular el temps de concentració d'una conca. El càlcul es fa amb l'opció Ascendent. La funció també es pot utilitzar per crear diagrames de distància-àrea d'esdeveniments de cabal i precipitació hipotètics mitjançant el ràster de ponderació com a impedància per al pendent descendent del moviment.</div>",
		streamOrderName: "Ordre de transmissió",
		streamOrderSnip: "Assigna un ordre numèric als segments d'un ràster que representa les bifurcacions d'una xarxa lineal",
		streamOrderDesc: "Aquesta és una funció de ràster global. Aquesta funció crea una capa ràster que assigna un ordre numèric als segments d'un ràster que representa les bifurcacions d'una xarxa lineal.<div><br/>La sortida de la funció Ordre de transmissió tindrà més qualitat si la capa ràster de transmissió d'entrada i la capa ràster de direcció del flux d'entrada es deriven de la mateixa superfície. Si el ràster de transmissió es deriva d'un dataset de transmissions rasteritzades, pot ser que la sortida no es pugui utilitzar. El motiu serà que la direcció de les cel·les individuals no es correspondrà amb la ubicació de les cel·les de la transmissió. Els resultats de la funció Acumulació de flux es poden utilitzar per crear una xarxa de transmissió de ràster. Per fer-ho, caldrà aplicar un llindar per seleccionar les cel·les amb un flux acumulat alt. Per exemple, les cel·les que tinguin més de 100 cel·les que hi flueixin s'utilitzaran per definir la xarxa de transmissió. Utilitzeu la funció Condicional o Defineix nuls per crear un ràster de xarxa de transmissió on els valors d'acumulació de flux de 100 o més s'adrecin a una, i la resta es deixin en segon terme (NoData). La xarxa de transmissió resultant es pot utilitzar a la funció Ordre de transmissió. Aquesta funció només admet una capa ràster de direcció del flux d'entrada D8. Les direccions del flux es poden crear mitjançant l'eina Direcció del flux i executar-se mitjançant el tipus de direcció del flux per defecte D8.</div>",
		snapPourPointName: "Ajusta el punt de fluïdesa",
		snapPourPointSnip: "Ajusta els punts de fluïdesa a la cel·la amb l'acumulació de flux més alta dins d'una distància especificada",
		snapPourPointDesc: "Aquesta és una funció de ràster global. Aquesta funció ajusta els punts de fluïdesa a la cel·la amb una acumulació de flux més alta dins d'una distància especificada.<div><br/>La funció Ajusta el punt de fluïdesa s'utilitza per garantir la selecció de punts amb un flux acumulat alt en delinear les conques de drenatge mitjançant la funció Conca hidrogràfica. La funció Ajusta el punt de fluïdesa farà una cerca dins d'una distància d'alineació al voltant dels punts de fluïdesa especificats de la cel·la amb el flux acumulat més alt i mourà el punt de fluïdesa a aquesta ubicació. La sortida és una capa ràster d'enter si les ubicacions dels punts de fluïdesa originals s'han ajustat a les ubicacions amb un flux acumulat més alt.</div>",
		sinkName: "Embornal",
		sinkSnip: "Crea un ràster que identifica tots els embornals o les àrees de drenatge intern",
		sinkDesc: "Aquesta és una funció de ràster global. Aquesta funció crea una capa ràster que identifica tots els embornals o les àrees de drenatge intern. Un embornal és una cel·la o un conjunt de cel·la connectades de manera espacial amb una direcció del flux a la qual no es pot assignar un dels vuit valors vàlids d'un ràster de direcció del flux. Això pot passar si totes les cel·les veïnes són més altes que la cel·la de processament o si dues cel·la flueixen d'una a l'altra i creen un bucle de dues cel·les.<div><br/>La funció Embornal només admet una capa ràster de direcció del flux d'entrada D8. Les direccions del flux es poden crear mitjançant l'eina Direcció del flux i executar-se mitjançant el tipus de direcció del flux per defecte D8. La sortida de la funció Embornal és un ràster d'enter, on s'assigna un valor únic a cada embornal. Aquests valors únics tenen un interval entre un i el nombre total d'embornals. Per exemple, si el nombre total d'embornals fos 1000, l'interval de valors únics seria d'1 a 1000.</div>",
		aggregateName: "Agrega",
		aggregateSnip: "Genera una versió de resolució reduïda d'un ràster.",
		aggregateDesc: "La funció Agrega torna a mostrejar un ràster d'entrada amb una resolució més baixa en funció d'una estratègia d'agregació especificada. Cada cel·la de sortida conté la suma, el mínim, el màxim, la mitjana o la mediana de les cel·les d'entrada compreses en l'extensió d'aquesta cel·la.<div><br/>Podeu especificar el factor pel que es multiplicarà la mida de cel·la del ràster d'entrada. Per exemple, un valor de factor de cel·la de 3 tindrà com a resultat una mida de cel·la de sortida tres vegades superior a la del ràster d'entrada. Podeu definir com es gestiona l'extensió de la sortida si el nombre de files o de columnes de la sortida no és un múltiple exacte del factor de cel·la. Per defecte, els límits superior i dret s'expandiran per cobrir una extensió espacial més gran que la del ràster d'entrada per assegurar que es processen totes les cel·les d'entrada. També es poden reduir els límits superior i dret per cobrir una extensió més petita, de manera que el nombre de files i de columnes que es processi sigui un múltiple exacte del factor de cel·la. Podeu definir com s'han de gestionar les cel·les NoData amb el càlcul d'agregació. El mecanisme per defecte és que les cel·les NoData d'entrada que es trobin dins de l'extensió espacial d'una cel·la més gran del ràster de sortida s'ignoraran en determinar el valor de la cel·la de sortida. També podeu especificar que, si hi ha alguna cel·la NoData d'entrada a l'extensió espacial d'una cel·la de sortida, la cel·la serà NoData al ràster de sortida.</div>",
		ccdcName: "Anàlisi de CCDC",
		ccdcSnip: "Avalua els canvis en els valors de píxel al llarg del temps mitjançant l'algoritme Detecció i classificació contínues dels canvis (CCDC) i genera resultats dels models.",
		ccdcDesc: "La funció Anàlisi de CCDC avalua els canvis en els valors de píxel al llarg del temps mitjançant l'algoritme Detecció i classificació contínues dels canvis (CCDC) i genera un ràster multidimensional amb els resultats dels models. Només s'admet juntament amb la funció Detecta els canvis a partir de l'anàlisi de canvis en una plantilla de funció de ràster. Per produir un ràster de sortida, connecteu la funció Anàlisi de CCDC amb la funció Detecta els canvis a partir de l'anàlisi de canvis, deseu-ho com a plantilla de funció de ràster i executeu l'anàlisi de ràster amb la plantilla de funció.<div><br/>Aquesta funció utilitza l'algoritme Detecció i classificació contínues dels canvis (CCDC) per avaluar els canvis en els valors de píxel al llarg del temps per a un conjunt d'imatges. En una sèrie temporal d'imatges òptiques o de derivats d'imatges (per exemple, un NDVI), els valors de píxel poden fluctuar per diversos motius: 1. Canvi estacional: els canvis de valors de píxel reflecteixen els canvis en la vegetació a causa de la variabilitat estacional de la temperatura i les precipitacions. Per exemple, a l'hemisferi nord s'espera una major densitat de vegetació verda a l'estiu que a l'hivern. 2. Canvi gradual: els canvis en els valors de píxel reflecteixen les tendències en la vegetació o l'aigua superficial a causa de la variabilitat climàtica o les pràctiques de gestió del sòl a llarg termini. Per exemple, el sòl nu pot augmentar gradualment en una zona a causa d'una davallada a llarg termini de les precipitacions. 3. Canvi abrupte: els canvis en els valors de píxel poden reflectir canvis en la cobertura del sòl que poden produir-se de sobte a causa de la desforestació, el desenvolupament urbà, desastres naturals, etc. L'algoritme CCDC identifica tots tres tipus de canvis amb l'objectiu principal d'identificar un canvi abrupte. La regressió harmònica i els models de tendència s'ajusten a les dades per estimar un canvi estacional i gradual, i les desviacions sobtades dels models de tendència són indicacions d'un canvi abrupte.<div><br/>L'algoritme CCDC es va dissenyar originalment per a dades del Landsat TM, el Landsat ETM+ i el Landsat OLI de reflectància de la superfície o de temperatura de brillantor. Tanmateix, la funció Detecta els canvis a partir de l'anàlisi de canvis juntament amb aquesta funció detectaran els canvis de les imatges multibanda de qualsevol sensor compatible, així com dels derivats d'imatges d'una banda com ara els índex de banda. Per exemple, podeu dur a terme una detecció contínua de canvis en un ràster d'índex de vegetació amb diferència normalitzada (NDVI), ja que els canvis a l'NDVI poden indicar una desforestació.</div>",
		computeChangeName: "Calcula el canvi",
		computeChangeSnip: "Calcula la diferència entre dos datasets ràster continus o categòrics.",
		computeChangeDesc: "La funció Calcula el canvi es pot utilitzar per enumerar les diferències entre dos ràsters classificats per a l'anàlisi de canvis en la cobertura de sòl, o bé per examinar els canvis entre dos ràsters continus d'una banda com ara l'elevació, la temperatura, la coberta vegetal, etc.",
		detectChangeName: "Detecta els canvis a partir de l'anàlisi de canvis",
		detectChangeSnip: "Genera una capa ràster amb informació sobre els canvis dels píxels mitjançant el ràster d'anàlisi de canvis de sortida.",
		detectChangeDesc: "<div>La funció Detecta els canvis a partir de l'anàlisi de canvis genera una capa ràster amb informació de la data dels canvis dels píxels mitjançant el ràster d'anàlisi de canvis. El ràster d'anàlisi de canvis s'ha de generar amb l'eina Analitza els canvis amb CCDC, l'eina Analitza els canvis amb LandTrendr, la funció de ràster Anàlisi de CCDC o la funció de ràster Anàlisi de LandTrendr.</div><br><div>Aquesta funció de ràster es pot combinar amb la funció de ràster Anàlisi de CCDC o la funció de ràster Anàlisi de LandTrendr en una plantilla de funció de ràster. Per produir un ràster de sortida permanent, connecteu la sortida de les funcions Anàlisi de CCDC o Anàlisi de LandTrendr amb la funció Detecta els canvis a partir de l'anàlisi de canvis, deseu-ho com a plantilla de funció de ràster i executeu l'anàlisi de ràster amb la plantilla.</div><br><div>El paràmetre <strong>Tipus de canvi</strong> indica la informació que es genera. La informació s'extreu del ràster d'anàlisi de canvis. En executar aquesta funció a la sortida de la funció o l'eina de CCDC, podeu triar una d'aquestes opcions:</div><ul><li><strong>Hora de l'últim canvi</strong>: data i hora més recent en què un píxel es va marcar com a canviat.</li><li><strong>Hora del primer canvi</strong>: data i hora més antigues en què el píxel es va marcar com a canviat.</li><li><strong>Hora del canvi més gran</strong>: data i hora en què el canvi calculat era més significant per a un píxel.</li><li> <strong>Nombre de canvis</strong>: nombre total de vegades que el píxel ha canviat.</li></ul><div>En executar aquesta funció a la sortida de la funció o l'eina de LandTrendr, hi ha disponibles aquestes opcions addicionals:</div><ul><li><strong>Temps del canvi més llarg</strong>: data en què un píxel es va marcar com a canviat, al principi o al final del període de canvi més llarg.</li><li><strong>Temps del canvi més curt</strong>: data en què un píxel es va marcar com a canviat, al principi o al final del període de canvi més curt.</li><li><strong>Temps del canvi més ràpid</strong>: data en què un píxel es va marcar com a canviat, al principi o al final del període de canvi més ràpid.</li><li><strong>Temps del canvi més lent</strong>: data en què un píxel es va marcar com a canviat, al principi o al final del període de canvi més lent.</li></ul><div>El ràster de sortida és un ràster multibanda en què cada banda conté informació sobre els canvis en funció del tipus de canvi seleccionat i el nombre màxim de canvis especificat. Per exemple, si <strong>Tipus de canvi</strong> s'ha definit com a <strong>Hora del primer canvi</strong> i <strong>Nombre màxim de canvis</strong> s'ha definit com a 2, la funció calcula les dues primeres dates en què s'han produït canvis a la sèrie temporal de cada píxel. El resultat és un ràster en què la primera banda conté les dates del primer canvi per píxel i la segona banda conté les dates del segon canvi per píxel.</div><br><div>En aplicar aquesta funció a la sortida de les eines de LandTrendr, pots triar si vols extreure la data que marca el principi d'un canvi o el seu final amb el paràmetre <strong>Data del segment</strong>. Per exemple, per entendre com va començar el canvi més recent d'una sèrie temporal, definiu <strong>Tipus de canvi</strong> com a <strong>Hora de l'últim canvi</strong> i <strong>Data del segment</strong> com a <strong>Inici del segment</strong>.</div><br><div>Feu servir els paràmetres de filtratge següents per extreure dates de canvi més concretes del ràster d'anàlisi de canvis:</div><ul><li><strong>Filtra per l'any</strong>: identifiqueu canvis que s'han produït en un període de temps concret, per exemple si cerqueu canvis que s'han produït en un paisatge durant cinc anys de sequera.</li><li><strong>Filtra per la durada</strong>: identifiqueu els canvis que s'han produït durant un interval d'anys especificat, per exemple si només cerqueu els canvis abruptes que han tingut lloc durant 1 o 2 anys. Podeu calcular la durada que us interessi amb la fórmula <strong>any de finalització - any d'inici + 1</strong>. S'inclouran les separacions en les sèries temporals.</li><li><strong>Filtra per la magnitud</strong>: identifiqueu els canvis d'una magnitud especificada, per exemple si només cerqueu grans canvis en l'índex de vegetació NDVI. La magnitud és un valor absolut, de manera que els valors mínims i màxims no poden ser negatius. Per especificar un canvi direccional, feu servir el paràmetre <strong>Direcció del canvi</strong>.</li></ul>",
		distanceAccumulationName: "Acumulació de distància",
		distanceAccumulationSnip: "Calcula la distància acumulada per a cada cel·la als orígens, tenint en compte la distància en línia recta, el cost en pla, la distància de superfície real i els factors de cost horitzontal i vertical.",
		distanceAccumulationDesc: "La funció Acumulació de distància calcula la distància de cada ubicació de l'àrea d'estudi a l'origen més proper o de menor cost. Si a l'entrada només es proporcionen els orígens, es calcula una distància en línia recta a cada ubicació de l'àrea d'estudi. Si com a entrada s'utilitzen tant orígens com barreres, la funció Acumulació de distància calcula la distància en línia recta al voltant de les barreres. Tant per al ràster d'origen com per al ràster de barrera, el valor de fons ha de ser NoData, mentre que els orígens i les barreres es representen amb valors de cel·la vàlids. Els valors vàlids inclouen el zero. <div><br/>Quan es proporciona un ràster de superfície com a entrada, es calcula la distància de superfície real entre les cel·les. Per fer una anàlisi de costos amb la funció Acumulació de distància, es necessita una superfície de cost. Si es proporciona una superfície de cost, el resultat és un ràster de cost en pla acumulat. Quan es proporcionen factors horitzontals i verticals, s'acumula la direccionalitat considerada com a cost. Es poden utilitzar quatre característiques d'origen. Aquestes característiques, que poden ser de l'origen o dels element en moviment de l'origen, es controlen amb paràmetres concrets: 1. Acumulació inicial: defineix el cost inicial abans que comenci el moviment. 2. Acumulació màxima: especifica quin cost pot acumular un origen abans d'arribar al límit. 3. Multiplicador per aplicar als costos: especifica el mode de viatge o la magnitud a l'origen. 4. Direcció del desplaçament: identifica si l'element en moviment comença a l'origen i es mou a ubicacions que no són les d'origen, o bé si comença en ubicacions que no són les d'origen i torna a l'origen.<div><br/>Per defecte, el resultat de l'Acumulació de distància és una banda, que és el ràster d'acumulació de distància. Tanmateix, també es pot crear una segona banda: la banda de direcció inversa. Aquesta banda indica cap a quina direcció s'ha d'anar des de cada ubicació de l'àrea d'estudi per obtenir l'origen de menor cost. Totes dues bandes es necessiten per determinar rutes òptimes a l'àrea d'estudi. Per generar una ruta, primer feu servir la funció Extreu les bandes per extreure el ràster d'acumulació de distància i el ràster de direcció inversa. Utilitzeu aquestes capes com a entrada de la funció Ruta de cost. En aquesta funció, utilitzeu el ràster d'acumulació de distància com a entrada del ràster de cost en pla, i el ràster de direcció inversa com a entrada de ràster d'enllaç de menor cost.</div>",
		distanceAllocationName: "Assignació de distància",
		distanceAllocationSnip: "Calcula l'assignació de distància per a cada cel·la als orígens proporcionats, en funció de la distància en línia recta, el cost en pla, la distància de superfície real i els factors de cost horitzontal i vertical.",
		distanceAllocationDesc: "La funció Assignació de distància calcula a quin origen està assignada cada ubicació de l'àrea d'estudi. Si per a l'entrada només es proporcionen orígens, les ubicacions s'assignen mitjançant una distància en línia recta a l'origen més proper. Si com a entrada s'utilitzen tant orígens com barreres, la funció Assignació de distància calcula la distància en línia recta al voltant de les barreres per determinar a quin origen s'assigna una ubicació. Tant per al ràster d'origen com per al ràster de barrera, el valor de fons ha de ser NoData, mentre que els orígens i les barreres es representen amb valors de cel·la vàlids. Els valors vàlids inclouen el zero.<div><br/>Per fer una anàlisi de costos amb la funció Assignació de distància, es necessita una superfície de cost. Si es proporciona una superfície de cost, el resultat és un ràster d'assignació basat en el cost acumulatiu, no en la distància en línia recta. Quan es proporcionen factors horitzontals i verticals, s'acumula la direccionalitat considerada com a cost. Quan es proporciona un ràster de superfície com a entrada, es calcula la distància de superfície real coberta en passar entre les cel·les quan es determina l'assignació. Es poden utilitzar quatre característiques d'origen. Aquestes característiques, que poden ser de l'origen o dels element en moviment de l'origen, es controlen amb paràmetres concrets: 1. Acumulació inicial: defineix el cost inicial abans que comenci el moviment. 2. Acumulació màxima: especifica quin cost pot acumular un origen abans d'arribar al límit. 3. Multiplicador per aplicar als costos: especifica el mode de viatge o la magnitud a l'origen. 4. Direcció del desplaçament: identifica si l'element en moviment comença a l'origen i es mou a ubicacions que no són les d'origen, o bé si comença en ubicacions que no són les d'origen i torna a l'origen.<div><br/>Per defecte, el resultat de l'Assignació de distància és una banda, que és el ràster d'assignació de distància. Si es marca l'opció booleana Genera una fila i una columna d'origen com a bandes addicionals a la sortida, el resultat serà un ràster multibanda de tres bandes. La primera banda és el ràster d'assignació de distància, la segona banda conté un índex de files i la tercera banda conté un índex de columnes. Aquests índex identifiquen la ubicació de la cel·la d'origen amb la menor distància de cost acumulat. L'índex de fila d'origen i l'índex de columna d'origen es poden utilitzar conjuntament per representar cartogràficament la intensitat. Si consulteu qualsevol ubicació de l'àrea d'estudi a les bandes dos i tres, sabreu la fila i la columna de l'origen de menor cost per a la ubicació.</div>",
		eucBackDirectionName: "Direcció inversa euclidiana",
		eucBackDirectionSnip: "Calcula per a cada cel·la la direcció en graus a la cel·la veïna, a més de la ruta més curta de tornada a l'origen més proper, a la vegada que evita les barreres.",
		eucBackDirectionDesc: "La funció Direcció inversa euclidiana té com a resultat un ràster de punt flotant continu que representa la direcció en graus de tornada a l'origen més proper, a la vegada que evita les barreres, si se n'han proporcionat.<div><br/>Les entrades de la funció Direcció inversa euclidiana són l'origen cap al qual es calcularà la direcció. Com a entrada opcional, es pot proporcionar un ràster que representi les barreres de l'àrea d'estudi. Tant per al ràster d'origen com per al ràster de barrera, el valor de fons ha de ser NoData, mentre que els orígens i les barreres es representen amb valors vàlids. Els valors vàlids inclouen el zero. Per defecte, el càlcul processarà l'extensió combinada d'orígens i barreres, a més de dues files i columnes. Si l'anàlisi només es necessita en una distància especificada dels orígens, es pot utilitzar el paràmetre Distància màxima. La funció Direcció inversa euclidiana admet tant el mètode Pla com el mètode Geodèsic al càlcul. El mètode de càlcul Pla es realitzarà en un terreny pla projectat mitjançant un sistema de coordenades cartesianes 2D. El mètode de càlcul Geodèsic es realitzarà en un el·lipsoide, és a dir, que independentment de la projecció d'entrada i de sortida, els resultats no canviaran.<div><br/>El resultat de la funció Direcció inversa euclidiana es pot utilitzar juntament amb el resultat de la funció Distància euclidiana per determinar les rutes més curtes des de les ubicacions de l'àrea d'estudi fins a l'origen. Tant el resultat de la funció Direcció inversa euclidiana com el resultat de la Distància euclidiana s'utilitzen a la funció Ruta de cost juntament amb les destinacions per generar les rutes més curtes.</div>",
		expandName: "Expandeix",
		expandSnip: "Expandeix les zones seleccionades d'un ràster en un nombre especificat de cel·les.",
		expandDesc: "Amb la funció global Expandeix, podeu generalitzar o simplificar ràsters fent que zones concretes siguin més grans. També podeu controlar la quantitat de generalització que es produirà.<div><br/>Les zones que seleccioneu augmentaran de mida expandint-se a altres zones. Conceptualment, els valors de zona seleccionats es poden veure com a zones en primer pla, mentre que els altres valors continuaran sent zones de fons. Les zones en primer pla es poden expandir a les zones de fons.<div><br/>La quantitat de generalització es pot controlar amb el paràmetre Nombre de cel·les. Per defecte, el valor és 1, cosa que vol dir que les zones seleccionades s'expandiran la quantitat corresponent a la mida d'una cel·la. Per incrementar el grau de generalització, podeu especificar un valor més gran per a aquest paràmetre. Conceptualment, és com executar l'eina les mateixes vegades que el nombre especificat, utilitzant els valors de l'execució anterior com a entrada a la iteració posterior.</div>",
		trendAnalysisName: "Genera la tendència",
		trendAnalysisSnip: "Estima la tendència de cada píxel en una dimensió per a una o diverses variables d'un ràster multidimensional.",
		trendAnalysisDesc: "<div>Aquesta funció es pot fer servir per ajustar les dades al llarg d'una línia de tendència lineal, harmònica o polinòmica, o bé per detectar la tendència amb la prova de Mann-Kendall o estacional de Kendall.</div><br><div>El ràster de tendència de sortida generat amb aquesta funció s'utilitza com a entrada de la funció <strong>Prediu mitjançant la tendència</strong>.</div><br><div>Les proves de Mann-Kendall i estacional de Kendall es fan servir per determinar si hi ha una tendència monòtona a les dades. No són paramètriques, cosa que significa que no donen per fet una distribució concreta de les dades. La prova de Mann-Kendall no considera una correlació de sèrie ni efectes estacionals. Si les dades són estacionals, la prova estacional de Kendall és més adient.</div><br><div>Si l'eina es fa servir per dur a terme una prova de Mann-Kendall o una prova estacional de Kendall, la sortida és un ràster de cinc bandes, tal com s'indica a continuació:</div><ul><li>Banda 1 = pendent de Sen</li><li>Banda 2 = valor p</li><li>Banda 3 = puntuació de Mann-Kendall (S)</li><li>Banda 4 = variància S</li><li>Banda 4 = variància S</li><li>Banda 5 = puntuació Z</li></ul><div>Si les sortides de la prova de Mann-Kendall o Kendall estacional es poden fer servir per determinar quins píxels de la sèrie temporal multidimensional tenen una tendència estadísticament significativa. Podeu fer servir aquesta informació juntament amb l'anàlisi de tendència lineal, harmònica o polinòmica per extreure tendències significatives de la sèrie temporal. Podeu generar una màscara que inclogui els píxels amb valors p significatius, aplicar la màscara al ràster multidimensional i fer servir aquest ràster multidimensional amb màscara com a entrada de l'eina per fer anàlisis de tendència lineal, harmònica o polinòmica.</div><br><div>Hi ha tres opcions de línia de tendència per ajustar una tendència als valors variables d'una dimensió: lineal, polinòmica i harmònica.</div><br><div>Per a l'anàlisi de tendència lineal, la sortida és un ràster de tres bandes, tal com s'indica a continuació:</div><ul><li>Banda 1 = pendent</li><li>Banda 2 = intercepció</li><li>Banda 3 = error quadràtic mitjà (RMSE) o l'error al voltant de la línia de millor ajust</li></ul><div>Per a anàlisis de tendència polinòmica, el nombre de bandes de la sortida depèn de l'ordre polinòmic. L'ajust polinòmic de segon ordre produeix un ràster de quatre bandes, tal com s'indica a continuació:</div><ul><li>Banda 1 = Polynomial_2</li><li>Banda 2 = Polynomial_1</li><li>Banda 3 = Polynomial_0</li><li>Banda 4 = RMSE</li></ul><div>L'ajust polinòmic de tercer ordre produeix un ràster de cinc bandes, tal com s'indica a continuació:</div><ul><li>Banda 1 = Polynomial_3</li><li>Banda 2 = Polynomial_2</li><li>Banda 3 = Polynomial_1</li><li>Banda 4 = Polynomial_0</li><li>Banda 5 = RMSE</li></ul><div>En el cas de les anàlisis de tendència harmònica, el nombre de bandes de la sortida depèn de la freqüència harmònica. Quan la freqüència es defineix com a 1, la sortida és un ràster de cinc bandes, tal com s'indica a continuació:</div><ul><li>Banda 1 = pendent</li><li>Banda 2 = intercepció</li><li>Banda 3 = Harmonic_sin1</li><li>Banda 4 = Harmonic_cos1</li><li>Banda 5 = RMSE</li></ul><div>Quan la freqüència es defineix com a 2, la sortida és un ràster de set bandes, tal com s'indica a continuació:</div><ul><li>Banda 1 = pendent</li><li>Banda 2 = intercepció</li><li>Banda 3 = Harmonic_sin1</li><li>Banda 4 = Harmonic_cos1</li><li>Banda 5 = Harmonic_sin2</li><li>Banda 6 = Harmonic_cos2</li><li>Banda 7 = RMSE</li></ul><div>El paràmetre <strong>Durada del cicle</strong> per a anàlisis de tendència harmònica es fa servir per indicar el nombre i la durada dels cicles que espereu veure a les dades al llarg d'un dia o d'un any. Per exemple, si espereu que les dades passin per dos cicles de variació en un any, la durada del cicle és de 182,5 dies o 0,5 anys. Si heu recopilat dades de temperatura cada tres hores i hi ha un cicle de variació per dia, la durada del cicle és d'un dia.</div><br><div>El paràmetre <strong>Freqüència</strong> per a anàlisis de tendència harmònica es fa servir per descriure el model harmònic a què s'ajustaran les dades. Si la freqüència es defineix com a 1, es farà servir una combinació de lineal i corba harmònica de primer ordre per ajustar el model. Si la freqüència es defineix com a 2, es farà servir una combinació de lineal, corba harmònica de primer ordre i corba harmònica de segon ordre per ajustar les dades. Si la freqüència és 3, a més es farà servir una corba harmònica de tercer ordre per modelar les dades, etc.</div><br><div>Les estadístiques de bondat d'ajust del model es poden generar com a sortides opcionals. L'error quadràtic mitjà (RMSE), l'R quadrat i el valor p del pendent de tendència es poden calcular i simbolitzar. Simbolitzeu la capa ràster de tendència de sortida amb simbologia <strong>RGB</strong> i especifiqueu les estadístiques com a bandes de vermell, verd i blau.</div><br>",
		spectralUnmixingName: "Anàlisi lineal de mescles espectrals",
		spectralUnmixingSnip: "Realitza una classificació per subpíxels i calcula l'abundància fraccionària de diferents tipus de cobertura de sòl de píxels individuals.",
		spectralUnmixingDesc: "La funció Anàlisi lineal de mescles espectrals calcula la cobertura fraccionària de píxels individuals que contenen diversos tipus de cobertura de sòl. Genera una capa multibanda en què cada banda correspon a l'abundància fraccionària de cada classe de cobertura de sòl. Per exemple, la podeu utilitzar per fer una classificació de la cobertura de sòl en una imatge multiespectral per identificar la vegetació fotosintètica, el sòl nu i la vegetació morta o no fotosintètica.<div><br/>L'ordre del ràster multibanda de sortida segueix l'ordre del perfil espectral d'entrada. El nombre de classes no pot superar el nombre de bandes del ràster d'entrada. Per exemple, no podeu extreure informació sobre més de 8 classes d'un ràster de 8 bandes.</div>",
		multidimensionalFilterName: "Filtre multidimensional",
		interpolateRasterByDimensionFunctionName: "Interpola ràster per dimensió",
		interpolateRasterByDimensionFunctionSnip: "Interpola un ràster multidimensional a uns valors de dimensió especificats mitjançant sectors adjacents.",
		interpolateRasterByDimensionFunctionDesc: "<p>Aquesta funció permet calcular valors de píxels per a un sector de dimensió sense definir d'un ràster multidimensional. Per exemple, si teniu un dataset que contingui la temperatura de l'oceà al nivell de superfície i a 100 metres per sota del nivell del mar i voleu calcular la temperatura a 50 metres per sota del nivell del mar, podeu fer servir aquesta funció per obtenir una estimació a aquesta profunditat mitjançant la definició de la dimensió Per valors.</p><p>També podeu obtenir una submostra d'un dataset diari a partir d'un dataset mensual mitjançant la definició de la dimensió Per interval i definint el valor del paràmetre Pas en 1 i el valor del paràmetre Unitat en Dies.</p><p>Feu servir la definició de la dimensió Per ràster de destinació per calcular el valor del ràster de destinació.</p>",
		multidimensionalFilterSnip: "Crea una capa ràster a partir d'un dataset ràster multidimensional o una capa ràster multidimensional segmentant les dades segons les variables i les dimensions definides.",
		multidimensionalFilterDesc: "La funció Filtre multidimensional crea una capa ràster multidimensional filtrant i extraient un subconjunt de variables d'un ràster multidimensional. Per exemple, teniu un dataset multidimensional que conté 30 anys de dades de precipitacions mensuals i només voleu extreure les dades de cada gener per veure com les precipitacions han canviat aquest mes.<div><br/>Utilitzeu el paràmetre Definició de la dimensió per segmentar les dimensions a partir d'un interval, un valor o un interval de valors. Per exemple, si teniu 10 anys de dades de salinitat de l'oceà, recopilades mensualment a cada dos metres de profunditat fins als 500 metres, podeu utilitzar diferents opcions de definició de la dimensió per als casos següents. Cas 1: extraieu les dades de salinitat del mes de gener en un període de 10 anys. Trieu Per valors, definiu Dimensió en StdTime i definiu Valors en Gener. Cas 2: segmenteu les dades de salinitat en un interval de profunditat de 0 a 150 metres. Trieu Per intervals, definiu Dimensió en StdZ i definiu Valor mínim en -150 i Valor màxim en 0. Cas 3: extraieu les dades de salinitat dels primers 10 dies de cada gener en un període de 10 anys. Trieu Per iteració, definiu Dimensió en StdTime, definiu Inici de la primera iteració i Final de la primera iteració en l'inici i el final corresponents al període d'iteració, definiu Pas en 1 i definiu Unitat en Anys.</div>",
		multidimensionalRasterName: "Ráster multidimensional",
		multidimensionalRasterSnip: "Afegeix dades multidimensionals a un mapa com una capa de ràster multidimensional.",
		multidimensionalRasterDesc: "La funció Ràster multidimensional afegeix dades multidimensionals a un mapa com una capa de ràster multidimensional. Aquesta funció és útil en executar fluxos de treball d'anàlisi de ràster amb una cadena de funcions.<div><br/>Entre els datasets ràster multidimensionals admesos hi ha netCDF, GRIB, HDF i CRF d'Esri. Els datasets de mosaic multidimensionals també s'admeten.</div>",
		optimalPathAsRasterName: "Ruta òptima com a ràster",
		optimalPathAsRasterSnip: "Calcula la ruta de menor cost des d'un origen fins a una destinació.",
		optimalPathAsRasterDesc: "Aquesta funció global genera un ràster de sortida que registra la ruta o les rutes òptimes des de les ubicacions seleccionades fins a la cel·la d'origen més propera definida a la superfície de cost acumulatiu, en termes de cost en pla.<div><br/>Normalment s'han d'executar una o diverses de les funcions de cost ponderat (Acumulació de distància o Assignació de distància) abans d'executar la funció Ruta òptima com a ràster per crear l'acumulació de distància d'entrada i els ràsters de direcció inversa. Aquestes són capes ràster d'entrada obligatòries per a la funció Ruta òptima. Els valors de la ruta òptima de sortida representen el nombre de rutes a una ubicació determinada. En molts casos, les rutes segueixen el mateix camí, surten d'un origen i es desvien per anar a diferents destinacions. Per exemple, un valor d'u indica que només hi ha una ruta òptima en una ubicació determinada, mentre que un valor de cinc significa que a la ubicació hi ha cinc rutes òptimes que passen per aquesta cel·la de l'àrea d'estudi.<div><br/>Les dades de destinació d'entrada han de ser una capa ràster. El conjunt de cel·les de destinació consisteix en totes les cel·les del ràster d'entrada que tenen valors vàlids. Les cel·les amb valors NoData no s'inclouen al conjunt. El valor zero es considera una destinació legítima. Un ràster de destinació es pot crear amb eines d'extracció. Si teniu entitats de destinació o d'origen, podeu convertir-les en ràster amb la funció Rasteritza entitats. Utilitzeu el ràster d'acumulació de distància o de direcció inversa com a entrada de ràster a la funció de rasterització. D'aquesta manera, l'entitat es rasteritza amb la mateixa mida de cel·la, la mateixa extensió i la mateixa referència espacial que els altres ràsters que s'inclouran a la funció Ruta òptima com a ràster. La funció Ruta òptima com a ràster també es pot utilitzar per derivar la ruta de menys resistència a un model d'elevació digital (DEM). En aquest cas, utilitzeu el DEM per al ràster d'acumulació de distància d'entrada i la sortida de la funció Direcció del flux per al ràster de direcció inversa.</div>",
		trendName: "Prediu mitjançant la tendència",
		trendSnip: "Calcula una capa ràster multidimensional prevista mitjançant el ràster de tendència de sortida des de la funció Genera la tendència o l'eina de geoprocessament Genera el ràster de tendència.",
		trendDesc: "La funció Prediu mitjançant la tendència calcula una capa ràster multidimensional prevista mitjançant el ràster de tendència de sortida des de la funció Genera la tendència o l'eina de geoprocessament Genera el ràster de tendència.",
		rasterCollectionName: "Processa la col·lecció de ràster",
		rasterCollectionSnip: "Processa cada sector d'un ràster multidimensional o cada element d'un ràster de mosaic. Aquesta funció també pot agregar diversos sectors en un sol sector.",
		rasterCollectionDesc: "La funció Processa la col·lecció de ràster processa cada sector d'un ràster multidimensional o cada element d'un ràster de mosaic. Aquesta funció també pot agregar diversos sectors en un sol sector.<div><br/>Aquesta funció processa cada sector d'un ràster multidimensional o ràster de mosaic amb una plantilla de funció de ràster. Aquesta funció admet les opcions següents: 1. Especificar una plantilla de funció de ràster per a Funció d'element. Per exemple, teniu un dataset de mosaic que conté 20 anys d'imatges del Landsat i voleu calcular l'NDVI de cada escena en una sèrie temporal. Per a Funció d'element, especifiqueu una plantilla de funció de ràster que contingui la funció de ràster de l'NDVI. 2. Especificar una plantilla de funció de ràster per a Funció d'agregació. Per exemple, teniu un ràster multidimensional que conté 10 anys de dades de temperatura diàries i voleu calcular la temperatura màxima de cada any. A Funció d'agregació, especifiqueu una plantilla de funció de ràster que contingui la funció Estadístiques de la cel·la, amb l'operació definida com a Màxim. A Definició de l'agregació, definiu Dimensió en StdTime, definiu Tipus en Paraula clau de l'interval i definiu Interval de paraules clau en Anual. Tingueu en compte que si el dataset de mosaic d'entrada no és multidimensional, la funció d'agregació no respectarà la definició d'agregació. La funció d'agregació agregarà tots els elements o cada grup en un si estan definits a la plantilla de funció d'agregació. Per obtenir més informació sobre l'ús dels grups en un dataset de mosaic, consulteu Utilitzar elements de dataset de mosaic en plantilles de funció de ràster. 3. Especificar una plantilla de funció de ràster per a Funció de processament. La funció o la cadena de funcions d'aquesta plantilla s'utilitza per mostrar el nou ràster processat. Per exemple, especifiqueu una plantilla de funció ràster que contingui la funció Mapa de color per canviar com es mostra la capa ràster processada. Tingueu en compte que si l'entrada és un ràster multidimensional, la funció de processament s'aplica al sector que es mostra actualment. Si l'entrada és una capa de mosaic o un dataset de mosaic, la funció de processament s'aplica al ràster de mosaic amb el mètode Primer per resoldre les superposicions. 3. Especificar les plantilles per a qualsevol combinació de totes tres funcions. Per exemple, teniu un dataset de mosaic que conté imatges del Landsat de sèries temporals i voleu generar una imatge composta amb un NDVI màxim. Per a Funció d'element, especifiqueu una plantilla de funció de ràster que contingui la funció de ràster de l'NDVI. Per a Funció d'agregació, especifiqueu una plantilla de funció de ràster que contingui la funció Estadístiques de la cel·la, amb l'operació definida com a Màxim. Per a Funció de processament, especifiqueu una plantilla de funció de ràster que contingui la funció Mapa de color. Tingueu en compte que l'ordre de la funció de processament segueix l'ordre dels paràmetres d'entrada. Per exemple, Funció d'element es processarà primer.</div>",
		randomName: "Aleatori",
		randomSnip: "Crea un ràster amb valors de píxel aleatoris extrets d'una distribució pseudoaleatòria. S'admeten diverses distribucions i generadors de nombres aleatoris.",
		randomDesc: "La funció Aleatori crea un ràster amb valors de píxel aleatoris que es poden utilitzar a les plantilles de funció de ràster o als datasets de mosaic,.<div><br/>Tot i que moltes funcions s'apliquen a un o diversos ràsters d'entrada, la funció Aleatori no en necessita cap. Això vol dir que funciona més com un dataset de ràster que com una funció, així que cal anar amb compte en afegir-la o eliminar-la de la cadena de funcions.</div>",
		shrinkName: "Redueix",
		shrinkSnip: "Redueix les zones seleccionades en un nombre especificat de cel·les substituint-les amb el valor de la cel·la que és més freqüent al veïnat.",
		shrinkDesc: "Amb la funció global Redueix, podeu generalitzar o simplificar ràsters fent que zones concretes siguin més petites. També podeu controlar la quantitat de generalització que es produirà.<div><br/>Les zones que seleccioneu es reduiran, o en disminuirà la mida, en expandir-s'hi les zones dels voltants. Conceptualment, els valors de zona seleccionats es poden veure com a zones en primer pla, mentre que els altres valors continuaran sent zones de fons. Les cel·les de les zones en primer pla es poden substituir per cel·les de les zones de fons. També es poden substituir petites illes dins d'una zona, que es poden veure com a límits compartits amb la zona.<div><br/>La quantitat de generalització es pot controlar amb el paràmetre Nombre de cel·les. Per defecte, el valor és 1, cosa que vol dir que les zones seleccionades es reduiran la quantitat corresponent a la mida d'una cel·la. Per incrementar el grau de generalització, podeu especificar un valor més gran per a aquest paràmetre. Conceptualment, és com executar l'eina les mateixes vegades que el nombre especificat, utilitzant els valors de l'execució anterior com a entrada a la iteració posterior.</div>",
		trendToRGBName: "Tendència a RGB",
		trendToRGBSnip: "Converteix un ràster de tendència en un ràster de tres bandes (vermell, verd i blau).",
		trendToRGBDesc: "La funció Tendència a RGB converteix un ràster de tendència en un ràster de tres bandes (vermell, verd i blau). El ràster de tendència es genera a partir de la funció de ràster Genera la tendència o la funció de ràster Anàlisi de CCDC.<div><br/>Aquesta funció és útil per visualitzar dades de coeficient del model a partir de la funció Genera la tendència o la funció Anàlisi de CCDC. Totes dues funcions estimen tendències en valors de píxel canviants, però els resultats de les funcions són difícils d'interpretar directament.<div><br/>Com en el cas de moltes funcions de ràster, és possible que hàgiu d'utilitzar l'ajust de marge dinàmic (DRA) per mostrar millor els resultats d'aquesta funció.</div>",
		landTrendrName: "Anàlisi LandTrendr",
		landTrendrSnip: "Avalua canvis en valors de píxels al llarg del temps utilitzant la detecció basada en Landsat de tendències en el mètode de pertorbació i recuperació (LandTrendr) i genera un ràster d’anàlisi de canvis amb els resultats del model.",
		landTrendrDesc: "Aquesta funció de ràster només pot es utilitzar com a entrada a la funció de ràster de Detecta canvi amb anàlisi de canvi. Per generar un resultat de ràster, connecteu la funció Anàlisi de LandTrendr a la funció Detecta canvi amb anàlisi de canvi en una plantilla de funcions de ràster, i utilitzeu la plantilla com a entrada en l’eina de geoprocessament Genera ràster a partir de la funció de ràster. El resultat es un ràster que conté informació respecte al moment en què han canviat el valors dels píxels.<div><br>La finalitat d’aquesta funció de ràster és extreure canvis en una característica observada, de forma que les imatges multidimensionals d’entrada idònies haurien de capturar una observació coherent al llarg del temps i no haurien d’incloure interferències atmosfèriques, núvols o l’ombra dels núvols. La millor pràctica és utilitzar dades que hagin estat normalitzades i puguin ser emmascarades fent servir una banda QA, per exemple, productes Landsat Collection 1 Surface Reflectance amb una màscara de núvols.<div><br>La funció executa una anàlisi sobre una imatge per any, i el nombre de particions anuals ha de ser igual o més gran que el valor especificat en el paràmetre <strong>Minimum Number of Observations</strong>. És recomanable tenir, com a mínim, sis anys de dades.<div><br>Si teniu dades mensuals, setmanals o diàries, és recomanable seleccionar diverses imatges de cada any (preferentment de la mateixa estació de l’any), elimineu els núvols i l’ombra dels núvols, i uniu les imatges per generar una única imatge que capturi bé l’observació. Si es faciliten dades mensuals, setmanals o diàries com a ràster multidimensional d’entrada, la funció identificarà una partició per a l’anàlisi basada en la data més propera a la proporcionada en el paràmetre <strong>Snapping Date</strong>.<div><br>Una característica en un paisatge sovint trigarà temps a recuperar-se d’un canvi no permanent com pot ser un incendi forestal o un plaga d’insectes. Per controlar l’índex de recuperació reconegut pel model, establiu el paràmetre Límit de recuperació. Un segment singular no pot tenir un índex de recuperació més ràpid que 1 / límit de recuperació.<div><br>En un paisatge, la recuperació d’un canvi es pot donar de manera positiva o negativa. Per exemple, quan un paisatge experimenta un pèrdua de boscos, una sèrie temporal de valors d’índex de vegetació mostra una caiguda en els valors d’índex, i la recuperació mostra un increment gradual en valors d’índex de vegetació, o una tendència de recuperació positiva. Especifiqueu la direcció de la tendència de recuperació amb el paràmetre <strong>Recovery Has Increasing Trend</strong>.",
		aggregateMultidimensionalName: "Multidimensional agregat",
		aggregateMultidimensionalSnip: "Combina dades de variables de ràster multidimensional ja existents juntament amb una dimensió.",
		aggregateMultidimensionalDesc: "La funció Agrega multidimensional crea una capa de ràsters multidimensionals combinant dades de variables de ràsters multidimensionals amb una dimensió.<div><br>Utilitzeu el paràmetre <strong>Definició de la dimensió</strong> per filtrar primer les dades d’entrada que voleu agregar. Per exemple, si teniu 30 anys de dades mensuals, però només voleu crear una capa agregada per als primers 15 anys, podeu fer servir el paràmetre <strong>Definició de la dimensió</strong> per especificar els anys que s’han d’incloure a l’anàlisi.<div><br><ul><li>Extreure dades de salinitat per al mes de gener al llarg d’un període de 10 anys. Trieu <strong>Per valors</strong>, definiu <strong>Dimensió</strong> amb el valor <strong>StdTime</strong> i <strong>Valors</strong> amb el valor <strong>Gener</strong>.</li><li>Fragment de dades de salinitat amb un interval de profunditat de 0 a 15 metres. Trieu <strong>Per rangs</strong>, establiu <strong>Dimensió</strong> amb el valor <strong>StdZ</strong>, <strong>Valor mínim</strong> amb el valor <strong>-150</strong> i <strong>Valor màxim</strong> amb el valor <strong>0</strong>.</li><li>Extreure dades de salinitat per als primers 10 dies de cada mes de gener durant un període de 10 anys. Trieu <strong>Per iteració</strong>, definiu <strong>Dimensió</strong> amb el valor <strong>StdTime</strong>, <strong>Inici de la primera iteració</strong> i <strong>Final de la primera iteració</strong> amb l'inici i final corresponents del període d'iteració, <strong>Pas</strong> amb el valor <strong>1</strong> i <strong>Unitat</strong> amb el valor <strong>Anys</strong>.</li></ul><div><br>Utilitzeu els paràmetres <strong>Definició de l'agregació</strong> per triar la dimensió que cal avaluar i l'interval d'agregació mitjançant una paraula clau, un valor o un interval de valors. Per exemple, si teniu 30 anys de dades de temperatura del mar, recopilades diàriament i a cada 5 metres de profunditat fins als 100 metres, podeu utilitzar les diferents opcions d’intervals per als següents escenaris:<div><br><ul><li>Agrega dades de temperatura diària a les dades mensuals, on el resultat és un ràster multidimensional amb 12 particions de temps, i cada partició és l’agregat de cada mes al llarg de tots els anys. Trieu <strong>Paraula clau d'interval</strong> i establiu la paraula clau a <strong>Amb recurrència mensual</strong>.</li><li>Afegiu dades de temperatura diària en dades mensuals, on el resultat és un ràster multidimensional amb 360 particions, o 12 particions de temps per any (30 anys 5 × 12 mesos = 360 particions). Trieu <strong>Paraula clau de l'interval</strong> i definiu la paraula clau <strong>Mensualment</strong>.</li><li>Afegiu dades de temperatura mensuals en intervals de 4 mesos. Trieu <strong>Valor de l'interval</strong>, definiu <strong>Interval de valors</strong> en 4, i definiu <strong>Unitat</strong> en <strong>Mesos</strong>.</li><li>Afegiu les dades de temperatura de 0 a 25 metres, després de 25 a 50 metres i després de 50 a 100 metres. Trieu <strong>Rangs de l'interval</strong> i especifiqueu les profunditats mínima i màxima com a <strong>0 25; 25 50; 50 100</strong>.</li></ul>",
		mergeRastersName: "Fusionar ràsters",
		mergeRastersSnip: "Combina múltiples conjunts de dades de ràsters espacialment, o entre variables i dimensions.",
		mergeRastersDesc: "Aquesta funció crea un ràster fusionat a partir d’una llista de ràsters. Per exemple, si teniu un conjunt de dades de mosaic que conté 30 anys de dades de precipitació mensual i un altre conjunt de dades amb 10 anys de dades de temperatures mensuals, podeu combinar-les en un ràster multidimensional amb ambdues variables. <div><br>Si els ràsters multidimensionals d’entrada contenen diferent variables, el ràster multidimensional de sortida inclourà totes les variables. <div><br>Si els ràsters multidimensionals d’entrada contenen diferents dimensions o valors de dimensions, el ràster multidimensional de sortida inclourà totes les dimensions i valors de dimensions. <div><br>Si els ràsters multidimensionals d’entrada contenen les mateixes dimensions i variables però diferents extensions espacials, el ràster multidimensional de sortida inclourà les variables i dimensions d’entre les extensions espacials fusionades.<div><br>Aquesta funció també es pot utilitzar quan teniu múltiples ràsters que voleu tractar com a un element únic, com ara calculant les mateixes estadístiques per a tots, o quan es fa equilibri de color, de manera que no necessiteu fer equilibri de color separadament per a cada imatge. Això resulta d’utilitat quan es treballa amb imatges emmagatzemades com a lloses separades degut a limitacions en la mida dels arxius; d’aquesta manera es tractarà les lloses com a part de la mateixa imatge.",
		boundaryCleanName: "Refinament de límits",
		boundaryCleanSnip: "Suavitza els límits entre zones.",
		boundaryCleanDesc: "<p>Aquesta funció generalitza o simplifica els ràsters suavitzant els límits entre zones. Aquesta funció proporciona opcions per controlar com les cel·les de les zones de l'entrada influencien la suavització i la quantitat de suavització que s'aplicarà. Cada cel·la d'entrada s'avalua a partir dels seus vuit veïns immediats.</p><p>El procés de suavització primer ordena les cel·les veïnes amb una prioritat concreta. La prioritat determina quina zona de les cel·les veïnes pot substituir el valor de la cel·la de processament a la sortida.</p><p>La prioritat es pot basar en el valor de les zones o en la mida de les zones. El paràmetre <strong>Tipus d'ordenació</strong> determina el tipus d'ordenació que es farà servir. </p><p>La configuració per defecte <strong>No ho ordenis</strong> avalua la prioritat en funció del valor de les zones. Les cel·les de les zones amb valors més grans tindran més prioritat per expandir-se a zones amb valors més petits.</p><p>La mida o l'àrea total de les zones es pot fer servir per ordenar la prioritat. Amb la configuració <strong>Descendent</strong>, les zones s'ordenen per mida en ordre descendent. Les zones amb àrees totals més grans tindran prioritat per expandir-se a zones amb àrees més petites. Amb la configuració <strong>Ascendent</strong> passa el contrari: les zones amb àrees totals més petites tindran prioritat per expandir-se a zones amb àrees totals més grans.</p><p>La quantitat de suavització es controla amb el paràmetre <strong>Executa l'expansió i la reducció dues vegades</strong>, que determina el nombre de vegades que es durà a terme el procés d'expansió i reducció.</p><p>Si aquesta configuració està desactivada, el procés d'expansió i reducció només es durà a terme una vegada. Si aquesta configuració està activada, el procés d'expansió i de reducció es realitzarà dues vegades, de manera que els límits de les zones se suavitzaran més.</p><p>Si els valors de les vuit cel·les veïnes són iguals que els de la cel·la que es processa, la cel·la de sortida conservarà el valor de la cel·la d'entrada.</p>",
		predictUsingRegressionName: "Prediu mitjançant regressió",
		predictUsingRegressionSnip: "Calcula un ràster predit basat en entrades de dades de ràsters i un model de regressió. El model de regressió és la producció de l'eina de geoprocessament ràster <strong>Train Random Trees Regression Model</strong>",
		predictUsingRegressionDesc: "<p>El model de regressió es defineix en un fitxer de definició de regressió Esri (.ecd). Conté tota la informació per a un conjunt de dades específic o un conjunt de conjunts de dades, a més del model de regressió, i és generat per <strong></strong>l'eina de geoprocessament ràster </p>Train Random Trees Regression Model.<p> L'entrada pot ser una sola banda, una multibanda o un ràster multidimensional o una llista d'aquests tipus. Els tipus de ràsters d’entrada han de ser el mateixos que els entrenats pel model de regressió.</p><ul><li>Quan l’entrada és un ràster multibanda, cada banda es tracta com una variable predictora. Les bandes han d'estar en el mateix ordre que l'entrada multibanda per a l'eina d'entrenament del model de regressió.</li><li>Quan l’entrada és un ràster multidimensional, cada variable es tracta com una variable predictora i la variable ha de ser de banda única i tenir una dimensió de temps. L'ordre i els noms de les variables han de ser els mateixos que els d'entrada quan es va entrenar el model de regressió. La sortida és un ràster multidimensional.</li><li>L'entrada pot ser una llista d'elements. El nombre i l'ordre dels ítems han de coincidir amb l'entrada quan es va entrenar el model de regressió.</li></ul>",
		dimensionalMovingStatisticsName: "Estadístiques mòbils dimensionals",
		dimensionalMovingStatisticsSnip: "Calcula les estadístiques en una finestra mòbil sobre dades multidimensionals en una dimensió especificada.",
		dimensionalMovingStatisticsDesc: "<p>La funció Estadístiques mòbils dimensionals calcula diverses estadístiques en una finestra predefinida per a tots els valors d'una dimensió. Aquesta funció agafa una capa ràster multidimensional com a entrada i crea una capa ràster multidimensional com a sortida que té la mateixa mida dimensional que la capa d'entrada.</p><p>Podeu especificar una dimensió els valors de la qual es tindran en compte durant el càlcul. Per defecte, el càlcul es fa a partir de la primera dimensió no espacial. També podeu especificar una mida de finestra amb els paràmetres Finestra Enrere i Finestra Endavant.</p><p>Quan Tipus d'estadística s'estableix en Percentil, els paràmetres Valor de percentil i Tipus d'interpolació del percentil estan disponibles. Podeu fer servir aquests paràmetres per especificar el percentil que voleu calcular i triar el tipus d'interpolació que voleu fer servir, respectivament. Quan el tipus d'estadístiques s'estableix en Mitjana circular, el paràmetre Valor d'ajust circular està disponible. El valor d'ajust circular s'utilitza per convertir un valor lineal en l'interval d'una mitjana circular determinada.</p>",
		terrainFlattenFunctionName: "Aplana un terreny",
		terrainFlattenFunctionSnip: "Corregeix les dades d'entrada del radar d'obertura sintètica (SAR) per a les distorsions radiomètriques per causa de la topografia.",
		terrainFlattenFunctionDesc: "<p>La funció de ràster Aplana el terreny corregeix les dades d'entrada del radar d'obertura sintètica (SAR) per a les distorsions radiomètriques per causa de la topografia.</p><p>En primer lloc cal calibrar les dades d'entrada del radar en beta zero. Utilitzeu l'eina Aplica calibratge radiomètric per calibrar les dades del radar en beta zero.</p><p>Si el DEM d'entrada no abraça tot el dataset de SAR, l'eina generarà valors NoData per als píxels que quedin fora de l'extensió DEM per a les sortides de gamma zero, sigma zero, àrea de dispersió i distorsió geomètrica. Per a la sortida de la màscara de distorsió geomètrica, l'eina generarà valors indeterminats per als píxels que quedin fora de l'extensió DEM.</p><p>El DEM d'entrada ha de ser al sistema de coordenades geogràfiques WGS 1984 (EPSG:4326).</p>",
		createColorCompositeFunctionName: "Crea una composició de color",
		createColorCompositeFunctionSnip: "Crea un ràster de tres bandes a partir d'un dataset ràster multibanda en el qual cada banda pot utilitzar un càlcul algebraic basat en àlgebra de bandes.",
		createColorCompositeFunctionDesc: "<p>La funció de ràster \"Crea una composició de color\" crea un ràster de tres bandes a partir d'un dataset ràster en el qual cada banda pot utilitzar un càlcul algebraic basat en àlgebra de bandes.</p><p>Quan definiu un algoritme aritmètic de bandes, podeu introduir una fórmula algebraica d'una sola línia per a cada expressió per crear una sortida multibanda. Els operadors admesos són unaris: suma (+), resta (-), multiplicació (*) i divisió (/).</p><p>Si utilitzeu un Id. de banda en una expressió, heu d'especificar el prefix B o b com a prefix del número de banda per tal d'identificar la banda.</p><p>Una de les combinacions de banda que s'utilitza sovint per al radar d'obertura sintètica (SAR) a les unitats lineals és VV per al vermell, VH per al verd i VV/VH per al blau. Si les dades d'entrada són en decibels, la combinació de banda ha de ser VV per al vermell, VH per al verd i VV-VH per al blau.</p>",
		surfaceParametersName: "Paràmetres de superfície",
		surfaceParametersSnip: "Determina els paràmetres d'un ràster de superfície com ara l'aspecte, el pendent i diversos tipus de curvatures mitjançant mètodes geodèsics.",
		surfaceParametersDesc: "<p>La funció Paràmetres de superfície determina els paràmetres d'un ràster de superfície com ara l'aspecte, el pendent i diversos tipus de curvatures mitjançant mètodes geodèsics.</p><p>Aquesta funció té les aplicacions següents:</p><ul><li>Calcular l'aspecte i el pendent mitjançant mètodes geodèsics.</li><li>Calcular diferents tipus de curvatures d'un ràster de superfície d'entrada, per exemple, <strong>Curvatura tangencial (contorn normal)</strong>, que caracteritza la convergència i la divergència topogràfica del flux per la superfície.</li></ul>",
		leastCostCorridorName: "Corredor de menor cost",
		leastCostCorridorSnip: "Calcula la suma de dos ràsters de distància de cost acumulatiu amb l'opció d'aplicar un llindar en funció d'un percentatge o cost acumulatiu.",
		leastCostCorridorDesc: "<p>Els ràsters d'entrada han de ser la sortida de ràsters d'acumulació de distància i de direcció inversa de la funció <strong>Acumulació de distància</strong> o <strong>Assignació de distància</strong>. S'han de basar en la distància de costos i cal que s'utilitzi la mateixa configuració de paràmetres en crear les capes per a cada font. No s'han d'utilitzar paràmetres que depenguin de la direccionalitat (factor horitzontal, factor vertical i direcció del viatge) en crear aquests ràsters.</p><p>Els valors del ràster de corredor de sortida són la suma del cost acumulatiu per arribar a una ubicació determinada amb les mateixes unitats que els ràsters de distància de cost acumulatiu d'entrada.</p><p>Si un valor <strong>Llindar</strong> especificat és superior al cost acumulatiu màxim quan se sumen dos ràsters d'acumulació de distància, el ràster de corredor de sortida cobrirà la mateixa àrea que els ràsters acumulatius d'entrada.</p><p>Si un valor de llindar especificat és inferior al valor mínim del ràster de corredor, es retornarà un missatge d'avís i el ràster de sortida estarà buit.</p><p>El ràster de corredor de sortida pot contenir cel·les amb costos acumulatius lleugerament superiors al valor del llindar. Això es deu als ràsters de direcció inversa que utilitzen cel·les que tenen assignats costos lleugerament superiors al llindar per connectar cel·les desconnectades al corredor.</p>",
		geometricMedianName: "Mitjana geomètrica",
		geometricMedianSnip: "La funció Mediana geomètrica calcula la mediana geomètrica dels píxels en una sèrie temporal d'imatges multibanda.",
		geometricMedianDesc: "<p>Aquesta funció redueix el soroll i els valors atípics en imatges de sèrie temporal calculant un píxel de mediana geomètrica per a cada matriu de píxels de la pila d'imatges. L'algoritme manté les relacions espectrals entre les bandes dels espectres de píxels per poder utilitzar la sortida en anàlisis, com ara índexs de vegetació.</p><p>Els núvols i les ombres s'han d'emmascarar mitjançant la banda de QA del dataset abans d'aplicar aquesta funció.</p><p>Si la imatge d'entrada és un punt flotant, com ara la reflectància de superfície amb valors entre 0 i 1, un valor èpsilon de 0,001 ha de generar resultats de qualitat.</p>"
	},
	rfxArgs: {
		rasterName: "Ràster",
		colorSchemeTypeName: "Tipus d'esquema de colors",
		colormapName: "Mapa de color",
		colormapNameName: "Nom del mapa de color",
		colorRampName: "Rampa de color",
		contrastOffsetName: "Desplaçament del contrast",
		brightnessOffsetName: "Desplaçament de la brillantor",
		methodName: "Mètode",
		bandNamesName: "Noms de banda",
		bandWavelengthsName: "Longituds d'ona de bandes",
		bandIdsName: "ID de banda",
		missingBandActionName: "Falta l'acció de banda",
		conversionParametersName: "Paràmetres de conversió",
		hillshadeTypeName: "Tipus d'ombra",
		azimuthName: "Azimut",
		altitudeName: "Altitud",
		slopeTypeName: "Escala",
		zFactorName: "Factor Z",
		PSPowerName: "Potència de mida de píxel",
		PSZFactorName: "Factor de mida de píxel",
		removeEdgeEffectName: "Deshabilita la interpolació de píxels de vora per defecte",
		fromUnitName: "Des de la unitat",
		toUnitName: "Fins a la unitat",
		rasterTypeName: "Tipus",
		minName: "Sortida mínima",
		maxName: "Sortida màxima",
		minPercentName: "Percentatge de retall mínim",
		maxPercentName: "Percentatge de retall màxim",
		numberOfStandardDeviationName: "Nombre de desviacions estàndard",
		sigmoidStrengthLevelName: "Nivell de resistència sigmoide",
		estimateStatsHistogramName: "Calcula les estadístiques",
		DRAName: "Ajust de marge dinàmic",
		statisticsName: "Estadístiques",
		histogramsName: "Histogrames",
		statisticsHistogramName: "Defineix les estadístiques i l'histograma",
		computeGammaName: "Gamma automàtic",
		useGammaName: "Utilitza el gamma",
		gammaName: "Gamma",
		inputNamesName: "Noms",
		expressionName: "Expressió",
		cellsizeTypeName: "Tipus de mida de cel·la",
		extentTypeName: "Tipus d'extensió",
		classifierDefinitionFileName: "Fitxer de definició d'entrada",
		raster1Name: "Ràster1",
		raster2Name: "Ràster2",
		raster3Name: "Ràster3",
		trueRasterName: "Ràster cert",
		falseRasterName: "Ràster fals",
		noDataInterpretationName: "Interpretació de NoData",
		noDataValuesName: "Valors NoData",
		includedRangesName: "Intervals inclosos",
		curvatureTypeName: "Tipus de curvatura",
		rastersName: "Ràsters",
		attributeTableName: "Taula",
		attributeTableTypeName: "Tipus de taula",
		rowsName: "Nombre de files",
		columnsName: "Nombre de columnes",
		kernelName: "Nucli",
		mirrorEdgesName: "Vores mirall",
		influencesName: "Influències",
		fieldsName: "Camps",
		remapsName: "Taula de nova representació geogràfica",
		evalFromName: "Escala d'avaluació inicial",
		evalToName: "Escala d'avaluació final",
		weightsName: "Pesos",
		DEMName: "DEM",
		shortRangeIDWRadiusName: "Radi IDW d'interval curt",
		maxVoidWidthName: "Amplada buida màxima",
		sigmaGaussianName: "Suavització adaptativa",
		contourTypeName: "Tipus de corba de nivell",
		zBaseName: "Base Z",
		numberOfContoursName: "Nombre de corbes de nivell",
		contourIntervalName: "Interval de corbes de nivell",
		nthContourLineInBoldName: "Línia de corba de nivell N en negreta",
		featureClassName: "Entitats d'entrada",
		classIndexFieldName: "Camp",
		resolveOverlapMethodName: "Mètode de resolució de superposició",
		resamplingTypeName: "Tipus de mostreig nou",
		inputCellsizeName: "Mida de cel·la d'entrada",
		outputCellsizeName: "Mida de cel·la de sortida",
		pointFeatureClassName: "Punt d'origen",
		maxGrowthRadiusFieldName: "Camp del radi de creixement màxim",
		similarityThresholdFieldName: "Camp del llindar de similitud",
		fillValueFieldName: "Camp del valor d'emplenament",
		spectralDetailName: "Detall espectral [1..20]",
		spatialDetailName: "Detall espacial [1..20]",
		minNumPixelsPerSegmentName: "Mida de segment mínima en píxels",
		boundariesOnlyName: "Només límits de segment",
		statisticsTypeName: "Tipus d'estadístiques",
		fillNoDataOnlyName: "Només emplenar píxels NoData",
		inputDataTypeName: "Tipus de dades d'entrada",
		angleReferenceSystemName: "Sistema de referència d'angles",
		outputDataTypeName: "Tipus de dades de sortida",
		inputSamplePointFeatureClassName: "Mostres d'entrada",
		valueFieldName: "Camp de valor",
		rasterInfoName: "Informació del ràster",
		interpolationMethodName: "Mètode d'interpolació",
		radiusName: "Radi",
		radianceGainValuesName: "Guany de radiància",
		radianceBiasValuesName: "Biaix de radiància",
		reflectedGainValuesName: "Guany de reflectància",
		reflectedBiasValuesName: "Biaix de reflectància",
		sunElevationName: "Elevació del sol (graus)",
		albedoName: "Albedo",
		scaleFactorName: "Factor d'escala",
		offsetName: "Desplaçament",
		thresholdTypeName: "Tipus de llindar",
		thresholdsName: "Llindars",
		undefinedClassName: "Classe sense definir",
		minValueName: "Mín.",
		maxValueName: "Màx.",
		operationName: "Operació",
		clippingTypeName: "Tipus de retall",
		clippingGeometryName: "Geometria/ràster de retall",
		extentName: "Extensió de sortida",
		useInputFeatureGeometryName: "Utilitza entitats d'entrada per retallar la geometria",
		remapDefinitionTypeName: "Tipus de definició de nova representació geogràfica",
		inputRangeName: "Intervals d'entrada",
		outputValuesName: "Valors de sortida",
		noDataRangeName: "Intervals NoData",
		inputFieldName: "Camp d'entrada",
		outputFieldName: "Camp de sortida",
		inputMaxFieldName: "Camp d'entrada màx. (opcional)",
		remapTableTypeName: "Tipus de taula de nova representació geogràfica",
		allowUnmatchedName: "Permet valors de píxel sense coincidència",
		changeMissingValuesToNoDataName: "Canvia els valors que falten a NoData",
		visibleBandIDName: "ID de banda visible",
		infraredBandIDName: "ID de banda infraroja",
		scientificOutputName: "Sortida científica",
		bandIndexesName: "Índexs de banda",
		constantName: "Constant",
		weightName: "Pes",
		minimumName: "Mínim",
		maximumName: "Màxim",
		sourceDataName: "Ràster d'origen",
		sourceFieldName: "Camp d'origen",
		costRasterName: "Ràster de costos",
		maxDistanceName: "Distància màxima",
		valueRasterName: "Ràster de valor",
		costMultiplierName: "Multiplicador per aplicar als costos",
		startCostName: "Cost inicial",
		accumCostResistanceRateName: "Taxa de resistència del cost acumulat",
		capacityName: "Capacitat",
		travelDirectionName: "Direcció del desplaçament",
		cellSizeName: "Mida de cel·la",
		populationFieldName: "Camp de població",
		areaUnitsName: "Unitats d'àrea",
		outputValueTypeName: "Valors de cel·la de sortida",
		barriersName: "Barreres d’entrada",
		destinationDataName: "Ràster de destinació",
		destinationFieldName: "Camp de destinació",
		pathTypeName: "Tipus de ruta",
		observerFeaturesName: "Entitats d'observador",
		analysisMethodName: "Mètode d'anàlisi",
		analysisTypeName: "Tipus d'anàlisi",
		verticalErrorName: "Error vertical",
		refractivityCoefficientName: "Coeficient de refracció",
		surfaceOffsetName: "Desplaçament de superfície",
		observerElevationName: "Elevació de l'observador",
		observerOffsetName: "Desplaçament de l'observador",
		innerRadiusName: "Radi intern",
		innerRadiusIs3DDistanceName: "El radi intern és la distància 3D",
		outerRadiusName: "Radi extern",
		outerRadiusIs3DDistanceName: "El radi extern és la distància 3D",
		horizontalStartAngleName: "Angle d'inici horitzontal",
		horizontalEndAngleName: "Angle de finalització horitzontal",
		verticalUpperAngleName: "Angle superior vertical",
		verticalLowerAngleName: "Angle inferior vertical",
		zoneDataName: "Ràster de zona",
		zoneFieldName: "Camp de zona",
		ignoreNoDataName: "Ignora NoData als càlculs",
		temperatureRasterName: "Ràster de temperatura",
		inTemperatureUnitsName: "Unitats de temperatura",
		outHeatIndexTemperatureUnitsName: "Unitats d'índex de calor",
		relativeHumidityRasterName: "Ràster d'humitat relativa",
		outWindChillTemperatureUnitsName: "Unitat de sensació tèrmica",
		windSpeedRasterName: "Ràster de velocitat del vent",
		inWindSpeedUnitsName: "Unitats de velocitat del vent",
		valueName: "Valor",
		propertyName: "Nom de propietat",
		jsonName: "JSON de metadades",
		zoneTableName: "Taula d'atributs zonal",
		attributeFieldNames: "Noms de camp d'atribut",
		backgroundName: "Valor de fons",
		whereClauseName: "Clàusula Where",
		minimumValueFieldName: "Nom de camp de valor mínim",
		maximumValueFieldName: "Nom de camp de valor màxim",
		outValueFieldName: "Nom de camp de valor de sortida",
		defaultValueName: "Valor de sortida per defecte",
		conversionMatrixName: "Matriu de conversió",
		IsPseudoColorOutputName: "És una pseudosortida de color",
		unmappedAsRandomColorName: "Assigna un color de manera aleatòria als píxels sense assignar",
		distanceMethodName: "Mètode de distància",
		flowDirRasterName: "Ràster de direcció del flux",
		pourPointName: "Ràster de punts de fluïdesa",
		pourPointFieldName: "Camp de punt de fluïdesa",
		constantZName: "Z constant",
		zOffsetName: "Desplaçament de Z",
		geoIdName: "Geoide",
		calibrationTypeName: "Tipus de calibratge",
		filterTypeName: "Tipus de filtre",
		filterSizeName: "Mida del filtre",
		noiseModelName: "Model de soroll",
		noiseVarianceName: "Variància del soroll",
		additiveNoiseMeanName: "Mitja de soroll additiu",
		multiplicativeNoiseMeanName: "Mitja de soroll multiplicatiu",
		numberofLooksName: "Nombre d'observacions",
		dampingFactorName: "Factor d'amortiment",
		maskRasterName: "Ràster de màscara",
		nibbleValuesName: "Utilitzeu valors NoData si són el veí més proper",
		nibbleNoDataName: "Assigna cel·les NoData",
		zLimitName: "Límit de Z",
		flowDirectionTypeName: "Tipus de direcció del flux",
		weightRasterName: "Ràster de pes",
		forceEdgeName: "Força que totes les cel·les de vores flueixin enfora",
		streamRasterName: "Ràster de transmissió",
		surfaceRasterName: "Ràster de superfície",
		conversionType: "Tipus de conversió",
		distanceRaster1: "Ràster de distància 1",
		distanceRaster2: "Ràster de distància 2",
		costDistanceRaster: "Ràster de cost en pla",
		costBacklinkRaster: "Ràster d'enllaç de menor cost",
		overridesName: "Invalidacions",
		fieldName: "Camp",
		signatureFileOrUrl: "URL o fitxer de signatura",
		redName: "Vermell",
		greenName: "Verd",
		blueName: "Blau",
		infraredName: "Infraroig",
		panchromaticName: "Pancromàtic",
		multispectralName: "Multiespectral",
		pansharpeningType: "Tipus d'enfocament pancromàtic",
		sensorName: "Sensor",
		spatialReferenceName: "Referència espacial",
		xCellsizeName: "Mida de cel·la X",
		yCellsizeName: "Mida de cel·la Y",
		xOriginName: "Punt de registre X",
		yOriginName: "Punt de registre Y",
		percentileName: "Valor de percentil",
		neighborhoodType: "Tipus de veïnat",
		widthName: "Amplada",
		heightName: "Altura",
		startAngleName: "Angle d'inici",
		endAngleName: "Angle de finalització",
		neighborhoodValues: "Valors de veïnat",
		horizontalRaster: "Ràster horitzontal",
		horizontalFactor: "Factor horitzontal",
		verticalRaster: "Ràster vertical",
		verticalFactor: "Factor vertical",
		streamRaster: "Ràster de transmissió",
		flowDirRaster: "Ràster de direcció del flux",
		numberNeighborCells: "Nombre de cel·les veïnes",
		zoneConnectivity: "Connectivitat de la zona",
		addLinkBehavior: "Afegeix un enllaç",
		excludedValue: "Valor exclòs",
		constantFillCheck: "Genera un ràster d'emplenament a partir de la constant",
		fillRaster: "Ràster d'emplenament",
		constantFillValue: "Valor constant",
		inputBitPositions: "Bit d'entrada",
		outputBitPositions: "Bit de sortida",
		distanceTypeName: "Tipus de distància",
		barrierDataName: "Barreres de ràster",
		pourPointDataName: "Ràster de punts de fluïdesa",
		accumulationRasterName: "Ràster d'acumulació de flux",
		snapDistanceName: "Distància d'alineació",
		orderMethodName: "Mètode d'ordenació",
		directionMeasurementName: "Direcció de mesura",
		processAsMultiband: "Processa com a multibanda",
		processMultidimensional: "Processa com a multidimensional",
		forceFlowDirectionConvention: "Força la convenció de la direcció del flux per al ràster d'enllaç de menor cost",
		initialAccumulation: "Acumulació inicial",
		maximumAccumulation: "Acumulació màxima",
		sourceLocationBands: "Genera una fila i una columna d'origen com a bandes originals a la sortida",
		backDirectionBand: "Genera la direcció inversa com a banda original a la sortida",
		numberOfCells: "Nombre de cel·les",
		zoneValues: "Valors de zona",
		shrinkMethod: "Mètode de reducció",
		expandMethod: "Mètode d'expansió",
		inputSpectralProfileType: "Tipus de perfil espectral",
		spectralProfileFileName: "Perfil espectral",
		trainingFeatureFileName: "Entitat de formació",
		nonNegative: "No negatiu",
		sumToOne: "Suma u",
		randomDistribution: "Distribució",
		meanName: "Mitja",
		probabilityName: "Probabilitat",
		alphaName: "Alfa",
		betaName: "Beta",
		rName: "r",
		nName: "N",
		seed: "Origina",
		randomNumberGenerator: "Generador de números aleatorios",
		cellFactor: "Factor de cel·la",
		aggregationType: "Técnica de agregación",
		extentHandling: "Ampliar la extensión si es necesario",
		trendAnalysisDimensionName: "Nom de la dimensió",
		trendAnalysisType: "Tipus de tendència",
		harmonicFrequency: "Freqüència harmònica",
		polynomialOrder: "Ordre polinòmic",
		cycleLengthName: "Durada del cicle",
		trendAnalysisRMSE: "RMSE",
		trendAnalysisR2: "R quadrat",
		trendAnalysisSlopePValue: "Valor P del coeficient de pendent",
		trendAnalysisSeasonalPeriod: "Període estacional",
		cycleUnitName: "Unitat del cicle",
		predictDimensionValues: "Valors",
		dimensionDefinitionType: "Definició de la dimensió",
		predictDimensionStart: "Principi",
		predictDimensionEnd: "Final",
		predictDimensionInterval: "Interval de valors",
		dimensionUnit: "Unitat",
		interpolationCellsizeName: "Mida de cel·la de la interpolació",
		variableName: "Variables",
		dimensionlessName: "Adimensional",
		mdimDefinition: "Definició de la dimensió",
		dimensionName: "Dimensió",
		iterationStart: "Inici de la primera iteració",
		iterationEnd: "Final de la primera iteració",
		intervalStart: "Inici de l'interval",
		intervalEnd: "Final de l'interval",
		stepName: "Pas",
		rangesName: "Intervals",
		minValue: "Valor mínim",
		maxValue: "Valor màxim",
		changeAnalysisRasterName: "Ràster d’anàlisi de canvis",
		changeTypeName: "Canvia el tipus",
		segmentDate: "Data de segment",
		changeDirectionName: "Direcció de canvi",
		maxNumChangesName: "Nombre màxim de canvis",
		filterByYear: "Filtra per any",
		minimumYear: "Valor mínim",
		maximumYear: "Valor màxim",
		filterByDuration: "Filtra per durada",
		minimumDuration: "Durada mínima",
		maximumDuration: "Durada màxima",
		filterByMagnitude: "Filtra per magnitud",
		minimumMagnitude: "Magnitud mínima",
		maximumMagnitude: "Magnitud màxima",
		filterByStartValue: "Filtra per valor inicial",
		minimumStartValue: "Valor inicial mínim",
		maximumStartValue: "Valor inicial màxim",
		filterByEndValue: "Filtra per valor final",
		minimumEndValue: "Valor final mínim",
		maximumEndValue: "Valor final màxim",
		modelTypeName: "Tipus de model",
		fromRasterName: "De ráster",
		toRasterName: "A ráster",
		computeChangeMethod: "Calcula el mètode de canvi",
		fromClassValues: "Des de valors de classe (Exemple: 2 5)",
		toClassValues: "Fins a valors de classe (Example: 2 5)",
		keepMethod: "Mètode de filtratge",
		useColorMethod: "Defineix colors de transició",
		detectChangeBands: "Bandes per detectar canvis (comença al 0)",
		tmaskBands: "Bandes d'emmascarament temporal (comença al 0)",
		chiSquaredThreshold: "Llindar de khi quadrat per detectar canvis",
		minAnomaly: "Observacions d'anomalies consecutives mínimes",
		updatingFrequency: "Actualitzant la freqüència d'ajustament (en anys)",
		distanceAccumulationRasterName: "Ràster d'acumulació de distància",
		costBackdirectionRasterName: "Ràster de direcció del flux o de direcció inversa",
		rasterCollectionName: "Captura de ràsters",
		itemFunctionName: "Funció d'element",
		aggregationFunctionName: "Funció d'agregació",
		processingFunctionName: "Funció de processament",
		aggregationDefinitionName: "Definició d'agregació",
		queryGeometryName: "Consulta la geometria",
		factorFunctionZeroFactor: "Factor zero",
		factorFunctionCutAngle: "Angle de tall",
		factorFunctionSideFactor: "Factor lateral",
		factorFunctionSlope: "Pendent",
		factorFunctionLowCutAngle: "Angle de tall baix",
		factorFunctionHighCutAngle: "Angle de tall alt",
		factorFunctionCosPower: "Potència del cosinus",
		factorFunctionSecPower: "Potència de la secant",
		factorFunctionTablePath: "Ruta de la taula",
		processingBand: "Banda de processament",
		processingBandName: "Nom de la banda de processament",
		snappingDate: "Data instantània",
		maxNumSegments: "Nombre màxim de segments",
		vertexCountOvershoot: "Overshoot de recompte de vèrtex",
		spikeThreshold: "Límit de punta",
		recoveryThreshold: "Límit de recuperació",
		minNumObs: "Cantidad mínima de observaciones",
		pValueThreshold: "Límit de P-Value",
		bestModelProportion: "Millor proporció de model",
		preventOneYearRecovery: "Evitar recuperació d’un any",
		recoveryIncreaseTrend: "La recuperació té tendència creixent",
		outputOtherBands: "Resultat altres bandes",
		sortType: "Tipus d'ordenació",
		numberOfRuns: "Executa l'expansió i la reducció dues vegades",
		percentileValue: "Valor de percentil",
		percentileInterpolationType: "Tipus d'interpolació del percentil",
		rasterInfoProperty: "Propietat",
		rasterInfoValue: "Valor",
		rasterInfoColumns: "Columnes",
		rasterInfoRows: "Files",
		rasterInfoBandCount: "Nombre de bandes",
		rasterInfoPixelSizeX: "Mida X de la cel·la",
		rasterInfoPixelSizeY: "Mida Y de la cel·la",
		rasterInfoPixelType: "Tipus de píxel",
		rasterExtentTop: "Superior",
		rasterExtentBottom: "Inferior",
		rasterExtentLeft: "Esquerra",
		rasterExtentRight: "Dreta",
		rasterStatisticsNotCalculated: "No s'han calculat les estadístiques.",
		spatialReferenceProjection: "Projecció",
		spatialReferenceWkid: "WKID",
		spatialReferenceLatestWkid: "WKID anterior",
		spatialReferenceWkt: "WKT",
		spatialReferenceVcsWkid: "VCSWKID",
		spatialReferenceLatestVcsWkid: "VCSWKID anterior",
		spatialReferenceAuthority: "Autoritat",
		spatialReferenceLinearUnit: "Unitat lineal",
		spatialReferenceAngularUnit: "Unitat angular",
		spatialReferenceFalseEasting: "Fals est",
		spatialReferenceFalseNorthing: "Fals nord",
		spatialReferenceCentralMeridian: "Meridià central",
		spatialReferencePrimeMeridian: "Meridià inicial",
		spatialReferenceStandardParallel1: "Paral·lel estàndard 1",
		spatialReferenceStandardParallel2: "Paral·lel estàndard 2",
		spatialReferenceLatitudeOfOrigin: "Latitud de l'origen",
		spatialReferenceAuxiliarySphereType: "Tipus d'esfera auxiliar",
		spatialReferenceDatum: "Datum",
		spatialReferenceSpheroid: "Esferoide",
		spatialReferenceSemimajorAxis: "Semieix major",
		spatialReferenceSemiminorAxis: "Semieix menor",
		spatialReferenceInverseFlattening: "Aplatament invers",
		inputDefinitionFileName: "Fitxer de definició d'entrada",
		deleteName: "Suprimeix",
		addVariableName: "Agregar variable",
		maxNumPixelsPerSegment: "Mida de segment màxima en píxels",
		forwardWindowName: "Finestra Endavant",
		backwardWindowName: "Finestra Enrere",
		noDataHandlingName: "Tractament de NoData",
		circularWrapValueName: "Valor d'ajust circular",
		fromClassNameFieldName: "Nom de camp per a noms de classes al ràster d'origen",
		toClassNameFieldName: "Nom de camp per a noms de classes al ràster de destinació",
		targetRasterName: "Ràster de destinació",
		circularWrapValue: "Valor d'ajust circular",
		bandIndexesR: "Expressió en vermell",
		bandIndexesG: "Expressió en verd",
		bandIndexesB: "Expressió en blau",
		exampleName: "Exemple",
		inputName: "Entrada",
		outputName: "Sortida",
		optionalName: "Opcional",
		browseDefinitionFile: "Navega al fitxer de definició",
		selectDefinitionFile: "Seleccioneu el fitxer de definició d'entrada",
		inputDefinitionURL: "URL del fitxer de definició d'entrada",
		enterDefinitionFileURL: "Introduïu l'URL del fitxer de definició",
		browseXMLFile: "Navega al fitxer XML",
		selectStatsFile: "Seleccioneu el fitxer d'estadístiques i d'histogrames",
		enterXMLFileURL: "Introduïu l'URL del fitxer XML",
		xmlFileURL: "URL del fitxer XML",
		circularCalculation: "Calcula les estadístiques circulars",
		localSurfaceType: "Tipus de superfície local",
		surfaceParameterType: "Tipus de paràmetre",
		neighborhoodDistance: "Distància de veïnatge",
		useAdaptiveNeighborhood: "Utilitza veïnatge adaptatiu",
		outputSlopeType: "Mesura del pendent de sortida",
		projectAzimuths: "Projecte d'azimuts geodèsics",
		useEquatorialAspect: "Utilitza la projecció equatorial",
		zUnit: "Unitat Z",
		analysisMask: "Màscara d'anàlisi",
		stdDeviation: "Desviació estàndard",
		"true": "Cert",
		"false": "Fals",
		costDistanceRaster1: "Ràster de distància de cost acumulatiu d'entrada 1",
		costDistanceRaster2: "Ràster de distància de cost acumulatiu d'entrada 2",
		threshold: "Llindar",
		thresholdMethod: "Mètode de llindar",
		directionRaster1: "Ràster de direcció inversa d'entrada 1",
		directionRaster2: "Ràster de direcció inversa d'entrada 2",
		maxIterations: "Nombre màxim d'iteracions",
		epsilon: "Èpsilon"
	},
	enumLabels: {
		attributeTableTypeManual: "Manual",
		attributeTableTypeExternal: "Extern",
		clrSchemeTypeColormap: "Mapa de color",
		clrSchemeTypeColorRamp: "Rampa de color",
		colormapTypeElevation: "Elevació",
		colormapTypeGray: "Gris",
		colormapTypeNDVI: "NDVI",
		colormapTypeNDVI2: "NDVI2",
		colormapTypeNDVI3: "NDVI3",
		colormapTypeRandom: "Aleatori",
		none: "Cap",
		slopeTypeAdjusted: "Ajustat",
		slopeTypeDegree: "Grau",
		slopeTypePercentRise: "PercentRise",
		slopeTypeScaled: "Escalat",
		stretchTypeMinMax: "MinMax",
		stretchTypePercentMinMax: "PercentMinMax",
		stretchTypeSigmoid: "Sigmoide",
		stretchTypeStdDev: "Desv. est.",
		hillshadeTypeSimple: "Tradicional",
		hillshadeTypeMultidirectional: "Multidireccional",
		bandComboByNames: "Noms de banda",
		bandComboByWavelength: "Longituds d'ona de bandes",
		bandComboByIDs: "ID de banda",
		missingBandActionBestMatch: "Millor coincidència",
		missingBandActionFail: "Error",
		unitTypeCelsius: "Celsius",
		unitTypeCentimeters: "Centímetres",
		unitTypeDecimeters: "Decímetres",
		unitTypeFahrenheit: "Fahrenheit",
		unitTypeFeet: "Peus",
		unitTypeFeetPerSec: "Peus per segon (ft/s)",
		unitTypeInches: "Polzades",
		unitTypeKelvin: "Kelvin",
		unitTypeKilometers: "Quilòmetres",
		unitTypeKmsPerHour: "Quilòmetres per hora (km/h)",
		unitTypeKnots: "Nusos (kn)",
		unitTypeMeters: "Metres",
		unitTypeMetersPerSec: "Metres per segon (m/s)",
		unitTypeMiles: "Milles",
		unitTypeMilesPerHour: "Milles per hora (mph)",
		unitTypeMillimeters: "Mil·límetres",
		unitTypeNauticalMiles: "Milles nàutiques",
		unitTypeYards: "Iardes",
		unitTypeDecimalDegrees: "Graus decimals",
		unitTypePoints: "Punts",
		unitTypeUnknown: "Desconegut",
		unitTypeSqMapUnits: "Unitats de mapa quadrades",
		unitTypeSqMiles: "Milles quadrades",
		unitTypeSqKms: "Quilòmetres quadrats",
		unitTypeAcres: "Acres",
		unitTypeHectares: "Hectàrees",
		unitTypeSqYards: "Iardes quadrades",
		unitTypeSqFt: "Peus quadrats",
		unitTypeSqInches: "Polzades quadrades",
		unitTypeSqMts: "Metres quadrats",
		unitTypeSqCms: "Centímetres quadrats",
		unitTypeSqMms: "Mil·límetres quadrats",
		cellsizeTypeFirst: "Primer de",
		cellsizeTypeMin: "Mínim de",
		cellsizeTypeMax: "Màxim de",
		cellsizeTypeMean: "Mitja de",
		cellsizeTypeLast: "Últim de",
		extentTypeFirst: "Primer de",
		extentTypeIntersection: "Intersecció de",
		extentTypeUnion: "Unió de",
		extentTypeLast: "Últim de",
		noDataInterpretAny: "Coincideix amb qualsevol",
		noDataInterpretAll: "Coincideix amb tots",
		curvatureTypeStandard: "Estàndard",
		curvatureTypeProfile: "Perfil",
		curvatureTypePlanform: "Pla",
		filterTypeLineDetectionHorizontal: "Detecció de línia horitzontal",
		filterTypeLineDetectionVertical: "Detecció de línia vertical",
		filterTypeLineDetectionLeftDiagonal: "Detecció de línia diagonal cap a l'esquerra",
		filterTypeLineDetectionRightDiagonal: "Detecció de línia diagonal cap a la dreta",
		filterTypeGradientNorth: "Gradient nord",
		filterTypeGradientWest: "Gradient oest",
		filterTypeGradientEast: "Gradient est",
		filterTypeGradientSouth: "Gradient sud",
		filterTypeGradientNorthEast: "Gradient nord-est",
		filterTypeGradientNorthWest: "Gradient nord-oest",
		filterTypeSmoothArithmeticMean: "Mitja aritmètica de suavització",
		filterTypeSmoothing3x3: "Suavització 3×3",
		filterTypeSmoothing5x5: "Suavització 5×5",
		filterTypeSharpening3x3: "Enfocament 3×3",
		filterTypeSharpening5x5: "Enfocament 5×5",
		filterTypeLaplacian3x3: "Laplacià 3×3",
		filterTypeLaplacian5x5: "Laplacià 5×5",
		filterTypeSobelHorizontal: "Sobel horitzontal",
		filterTypeSobelVertical: "Sobel vertical",
		filterTypeSharpen: "Enfoca",
		filterTypeSharpen2: "Enfoca més",
		filterTypePointSpread: "Dispersió del punt",
		userDefined: "Definit per l'usuari",
		ContourTypeLines: "Línies de corba de nivell",
		ContourTypeFill: "Emplenament de la corba de nivell",
		ContourTypeSmoothOnly: "Suavitza només la superfície",
		rasterizeFirst: "Primer",
		rasterizeLast: "Últim",
		rasterizeSmallest: "Més petit",
		rasterizeLargest: "Més gran",
		resamplingTypeNearest: "Veí més proper",
		resamplingTypeBilinear: "Interpolació bilineal",
		resamplingTypeCubic: "Convolució cúbica",
		resamplingTypeMajority: "Majoria",
		resamplingTypeBilinearPlus: "Suma d'interpolació bilineal",
		resamplingTypeGauss: "Desenfocament gaussià",
		resamplingTypeGaussPlus: "Suma de desenfocament gaussià",
		resamplingTypeAverage: "Mig",
		resamplingTypeMinimum: "Mínim",
		resamplingTypeMaximum: "Màxim",
		resamplingTypeVectorAvg: "Mitjana del vector",
		minimum: "Mínim",
		maximum: "Màxim",
		mean: "Mitja",
		stdDeviation: "Desviació estàndard",
		uvMagDirTypeUV: "U-V",
		uvMagDirTypeMagDir: "Magnitud-direcció",
		unknown: "Desconegut",
		angleRefSysGeographic: "Geogràfic",
		angleRefSysArithmetic: "Aritmètic",
		interpolateIrregularDataNearest: "Veí més proper",
		interpolateIrregularDataBilinear: "Bilineal",
		interpolateIrregularDataTinningLinear: "Simplificació lineal",
		interpolateIrregularDataTinningNaturalNeighbor: "Veí natural",
		interpolateIrregularDataTinningIDW: "Distància inversa ponderada",
		esriRasterThresholdTypeConstant: "Constant",
		esriRasterThresholdTypeOtsu: "Otsu",
		esriRasterThresholdTypeTsai: "Tsai",
		esriRasterThresholdTypeKapur: "Kapur",
		esriRasterThresholdTypeKittler: "Kittler",
		esriRasterThresholdTypeRosin: "Rosin",
		argStatsTypeMax: "Arg Max",
		argStatsTypeMin: "Arg Min",
		argStatsTypeMedian: "Arg Median",
		argStatsTypeDuration: "Duration",
		arithmeticOpPlus: "Suma",
		arithmeticOpMinus: "Resta",
		arithmeticOpMultiply: "Multiplicació",
		arithmeticOpDivide: "Divisió",
		arithmeticOpPower: "Potència",
		arithmeticOpMode: "Mode",
		clipTypeOutside: "Retall exterior",
		clipTypeInside: "Retall interior",
		yes: "Sí",
		no: "No",
		densities: "Densitats",
		expectedCounts: "Recomptes esperats",
		planar: "Pla",
		geodesic: "Geodèsic",
		eachCell: "Cada cel·la",
		eachZone: "Cada zona",
		bestSingle: "L'únic millor",
		allSightlines: "Totes les línies de visió",
		perimeterSightlines: "Línies de visió de perímetre",
		frequency: "Freqüència",
		observers: "Observadors",
		majority: "Majoria",
		median: "Mitjana",
		minority: "Minoria",
		percentile: "Percentil",
		range: "Interval",
		sum: "Suma",
		variety: "Varietat",
		ndvi: "NDVI",
		savi: "SAVI",
		bandArithmeticMethodTSAVI: "SAVI transformat",
		bandArithmeticMethodMSAVI: "SAVI modificat",
		bandArithmeticMethodSultan: "Fórmula de Sultan",
		gemi: "GEMI",
		pvi: "PVI",
		gvi: "GVI (Landsat TM)",
		vari: "VARI",
		sr: "SR",
		gndvi: "GNDVI",
		ndvire: "NDVIre",
		srre: "SRre",
		mtvi2: "MTVI2",
		rtviCore: "RTVICore",
		cire: "CIre",
		cig: "CIg",
		ndwi: "NDWI",
		evi: "EVI",
		ironOxide: "Òxid de ferro",
		ferrousMinerals: "Minerals ferrosos",
		clayMinerals: "Minerals argilosos",
		wndwi: "WNDWI",
		bai: "BAI",
		mndwi: "MNDWI",
		nbr: "NBR",
		ndbi: "NDBI",
		ndmi: "NDMI",
		ndsi: "NDSI",
		localSquareRoot: "Arrel quadrada",
		localACos: "Arc cosinus (ACos)",
		localASin: "Arc sinus (ASin)",
		localATan: "Arc tangent (ATan)",
		localATanH: "Arc tangent hiperbòlica (ATanH)",
		localAbs: "Valor absolut",
		localBitwiseNot: "Bitwise Not",
		localBooleanNot: "Booleana Not",
		localCos: "Cosinus (Cos)",
		localCosH: "Cosinus hiperbòlic (CosH)",
		localExp: "Exponencial en base e (Exp)",
		localExp10: "Exponencial en base 10 (Exp10)",
		localExp2: "Exponencial en base 2 (Exp2)",
		localInt: "Enter",
		localIsNull: "És nul",
		localFloat: "Punt flotant",
		localLn: "Logaritme neperià (Ln)",
		localLog10: "Logaritme en base 10 (Log10)",
		localLog2: "Logaritme en base 2 (log2)",
		localNegate: "Canvi de signe",
		localRoundDown: "Arrodoniment a la baixa",
		localRoundUp: "Arrodoniment a l'alça",
		localSin: "Sinus (Sin)",
		localSinH: "Sinus hiperbòlic (SinH)",
		localTan: "Tangent (Tan)",
		localTanH: "Tangent hiperbòlica (TanH)",
		localACosH: "Arc cosinus hiperbòlic (ACosH)",
		localASinH: "Arc sinus hiperbòlic (ASinH)",
		localPlus: "Suma",
		localMinus: "Resta",
		localTimes: "Multiplicació",
		localPower: "Potència",
		localBitwiseAnd: "Bitwise And",
		localBitwiseLeftShift: "Bitwise Left Shift",
		localBitwiseOr: "Bitwise Or",
		localBitwiseRightShift: "Bitwise Right Shift",
		localBitwiseXor: "Bitwise Xor",
		localBooleanAnd: "Booleana And",
		localBooleanOr: "Booleana Or",
		localBooleanXor: "Booleana Xor",
		localDivide: "Divisió",
		localEqualTo: "Igual que",
		localGreaterThan: "Major que",
		localGreaterThanEqual: "Major o igual que",
		localLessThan: "Menor que",
		localLessThanEqual: "Menor o igual que",
		localMod: "Mòdul",
		localNotEqual: "No igual",
		localATan2: "Arc tangent (ATan2)",
		localSquare: "Quadrada",
		localSetNull: "Defineix nuls",
		remapDefTypeList: "Llista",
		remapDefTypeTable: "Taula",
		remapTableTypeSimple: "Simple",
		remapTableTypeDynamic: "Dinàmic",
		remapTableTypeReassignment: "Reassignació",
		geomCorrectionByConstZ: "Utilitza Z constant",
		geomCorrectionByDEM: "Utilitza DEM",
		radarCalibBetaNought: "Beta zero",
		radarCalibSigmaNought: "Sigma zero",
		radarCalibGammaNought: "Gamma zero",
		speckleFilterTypeLee: "Filtre de Lee",
		speckleFilterTypeEnhancedLee: "Filtre de Lee millorat",
		speckleFilterTypeFrost: "Filtre de Frost",
		speckleFilterTypeKuan: "Filtre de Kuan",
		speckleNoiseModelMul: "Soroll multiplicatiu",
		speckleNoiseModelAdd: "Soroll additiu",
		speckleNoiseModelAddnMul: "Soroll additiu i multiplicatiu",
		mosaicOpTypeFirst: "Primer",
		mosaicOpTypeLast: "Últim",
		mosaicOpTypeMin: "Mín.",
		mosaicOpTypeMax: "Màx.",
		mosaicOpTypeMean: "Mitja",
		mosaicOpTypeBlend: "Combinació",
		mosaicOpTypeSum: "Suma",
		integer: "Enter",
		rfxD8: "D8",
		rfxMFD: "MFD",
		dinf: "Dinf",
		vertical: "Vertical",
		horizontal: "Horitzontal",
		localCellStatisticsMajority: "Majoria",
		localCellStatisticsMax: "Màxim",
		localCellStatisticsMean: "Mitja",
		localCellStatisticsMedian: "Mitjana",
		localCellStatisticsMin: "Mínim",
		localCellStatisticsMinority: "Minoria",
		localCellStatisticsRange: "Interval",
		localCellStatisticsStdDev: "Desviació estàndard",
		localCellStatisticsSum: "Suma",
		localCellStatisticsVariety: "Varietat",
		localCellStatisticsMajorityIgnoreND: "Majoria (ignora els elements NoData)",
		localCellStatisticsMaxIgnoreND: "Màxim (ignora els elements NoData)",
		localCellStatisticsMeanIgnoreND: "Mitja (ignora els elements NoData)",
		localCellStatisticsMedianIgnoreND: "Mitjana (ignora els elements NoData)",
		localCellStatisticsMinIgnoreND: "Mínim (ignora els elements NoData)",
		localCellStatisticsMinorityIgnoreND: "Minoria (ignora els elements NoData)",
		localCellStatisticsRangeIgnoreND: "Interval (ignora els elements NoData)",
		localCellStatisticsStdDevIgnoreND: "Desviació estàndard (ignora els elements NoData)",
		localCellStatisticsSumIgnoreND: "Suma (ignora els elements NoData)",
		localCellStatisticsVarietyIgnoreND: "Varietat (ignora els elements NoData)",
		localCellStatisticsTypePercentileIgnoreND: "Percentil (ignora els elements NoData)",
		fromSource: "Des de l'origen",
		toSource: "Fins a l'origen",
		colorspaceConversionRgbToHsv: "RGB a HSV",
		colorspaceConversionHsvToRgb: "HSV a RGB",
		pansharpenTypeIHS: "IHS",
		pansharpenTypeBrovey: "Brovey",
		pansharpenTypeEsri: "Esri",
		pansharpenTypeMean: "Mitja",
		pansharpenTypeGramSchmidt: "Gram-Schmidt",
		rectangleNeighborhood: "Rectangle",
		circleNeighborhood: "Cercle",
		annulusNeighborhood: "Corona circular",
		wedgeNeighborhood: "Falca",
		irregularNeighborhood: "Irregular",
		weightNeighborhood: "Pes",
		four: "Quatre",
		eight: "Vuit",
		within: "Dins",
		cross: "Creu",
		addLink: "Afegeix un enllaç",
		noLink: "Sense enllaç",
		weightedMean: "Mitjana ponderada",
		ls8QCBitPatternCirrus: "Landsat 8 Cirrus",
		ls8QCBitPatternCloud: "Landsat 8 Cloud",
		ls8QCBitPatternCloudShadow: "Landsat 8 Cloud Shadow",
		ls8QCBitPatternDesignatedFill: "Landsat 8 Designated Fill",
		ls8QCBitPatternDroppedFrame: "Landsat 8 Dropped Frame",
		ls8QCBitPatternSnowIce: "Landsat 8 Snow/Ice",
		ls8QCBitPatternTerrainOcclusion: "Landsat 8 Terrain Occlusion",
		ls8QCBitPatternVegetation: "Landsat 8 Vegetation",
		ls8QCBitPatternWater: "Landsat 8 Water",
		downStream: "Descendent",
		upStream: "Ascendent",
		strahler: "STRAHLER",
		shreve: "SHREVE",
		currentSlice: "Sector actual",
		allSlices: "Tots els sectors",
		expandDistance: "DISTÀNCIA",
		expandMorphological: "MORFOLÒGIC",
		spectralProfileFile: "Perfil espectral",
		trainingFeatureFile: "Entitat de formació",
		randomDistributionTypeUniform: "Uniforme",
		randomDistributionTypeUniformInteger: "Enter",
		randomDistributionTypeNormal: "Normal",
		randomDistributionTypeExponential: "Exponencial",
		randomDistributionTypePoisson: "Poisson",
		randomDistributionTypeGamma: "Gamma",
		randomDistributionTypeBinomial: "Binomial",
		randomDistributionTypeGeometric: "Geomètrica",
		randomDistributionTypeNegativeBinomial: "Binomial negatiu",
		randomGeneratorTypeStandardCRand: "Rand C estándar",
		randomGeneratorTypeAlgorithmACM599: "Algoritmo 599 capturado por ACM",
		randomGeneratorTypeMersenneTwister: "Mersenne Twister",
		sumName: "Suma",
		medainName: "Mitjana",
		trendLinear: "Lineal",
		trendHarmonic: "Harmònic",
		trendPolynomial: "Polinomial",
		trendMannKendall: "Mann-Kendall",
		trendSeasonalKendall: "Kendall estacional",
		dimensionByValue: "Per valor",
		dimensionByInterval: "Per interval",
		mdimDefTypeAll: "Tots",
		mdimDefTypeByValues: "Per valors",
		mdimDefTypeByRanges: "Per intervals",
		mdimDefTypeByIteration: "Per iteració",
		mdimDefTypeByInterval: "Per interval",
		mdimDefTypeByTargetRaster: "Per ràster de destinació",
		esriTimeUnitsHours: "Hores",
		esriTimeUnitsDays: "Dies",
		esriTimeUnitsWeeks: "Setmanes",
		esriTimeUnitsMonths: "Mesos",
		esriTimeUnitsYears: "Anys",
		esriTimeIntervalKeywordHourly: "Cada hora",
		esriTimeIntervalKeywordDaily: "Diària",
		esriTimeIntervalKeywordWeekly: "Setmanal",
		esriTimeIntervalKeywordDekadly: "Cada dècada",
		esriTimeIntervalKeywordPentadly: "Cada cinc anys",
		esriTimeIntervalKeywordMonthly: "Mensualment",
		esriTimeIntervalKeywordQuarterly: "Trimestralment",
		esriTimeIntervalKeywordYearly: "Anualment",
		esriTimeIntervalKeywordRecurringDaily: "Amb recurrència diària",
		esriTimeIntervalKeywordRecurringWeekly: "Amb recurrència setmanal",
		esriTimeIntervalKeywordRecurringMonthly: "Amb recurrència mensual",
		esriTimeIntervalKeywordRecurringQuarterly: "Amb recurrència trimestral",
		aggDefTypeAll: "Tot",
		aggDefTypeIntervalKeyword: "Paraula clau de l'interval",
		aggDefTypeIntervalValue: "Valor de l'interval",
		aggDefTypeIntervalRanges: "Rangs de l'interval",
		latestChange: "Hora de l'últim canvi",
		earliestChange: "Hora del primer canvi",
		largestChange: "Hora del canvi més gran",
		numberOfChanges: "Nombre de canvis",
		longestChange: "Temps de canvi més llarg",
		shortestChange: "Temps de canvi més curt",
		fastestChange: "Temps de canvi més ràpid",
		slowestChange: "Temps de canvi més lent",
		allChanges: "Tot",
		increaseChanges: "Incrementar",
		decreaseChanges: "Redueix",
		segmentBeginning: "Inici de segment",
		segmentEnd: "Fi de segment",
		esriComputeChangeMethodDifference: "Diferència",
		esriComputeChangeMethodRelativeDifference: "Diferència relativa",
		esriComputeChangeMethodCategorical: "Diferència categòrica",
		esriComputeChangeMethodMultispectralEuclideanDistance: "Distància euclidiana espectral",
		esriComputeChangeMethodMultispectralAngularDifference: "Diferència d'angle espectral",
		esriComputeChangeMethodMultispectralAxisWithBiggestChange: "Banda amb més canvis",
		esriComputeChangeKeepAll: "Mantenir tots",
		esriComputeChangeKeepChangedOnly: "Mantenir només píxels canviats",
		esriComputeChangeKeepUnchangedOnly: "Mantenir només píxels no canviats",
		esriComputeChangeUseColorAverage: "Promig Colors des de i fins a",
		esriComputeChangeUseColorFrom: "Utilitza Colors des de",
		esriComputeChangeUseColorTo: "Utilitza Colors ins a",
		factorFunctionBinary: "Binari",
		factorFunctionForward: "Endavant",
		factorFunctionLinear: "Lineal",
		factorFunctionInvLinear: "Lineal invers",
		factorFunctionTable: "Taula",
		factorFunctionSymLinear: "Lineal simètric",
		factorFunctionSymInvLinear: "Lineal simètric invers",
		factorFunctionCos: "Cosinus",
		factorFunctionSec: "Secant",
		factorFunctionCosSec: "Cosinus secant",
		factorFunctionSecCos: "Secant cosinus",
		noSort: "No ho ordenis",
		ascend: "Ascendent",
		descend: "Descendent",
		autoDetect: "Detecta automàticament",
		nearest: "Més proper",
		linear: "Lineal",
		esriMonthJanuary: "Gener",
		esriMonthFebruary: "Febrer",
		esriMonthMarch: "Març",
		esriMonthApril: "Abril",
		esriMonthMay: "Maig",
		esriMonthJune: "Juny",
		esriMonthJuly: "Juliol",
		esriMonthAugust: "Agost",
		esriMonthSeptember: "Setembre",
		esriMonthOctober: "Octubre",
		esriMonthNovember: "Novembre",
		esriMonthDecember: "Desembre",
		dimensionalMovingIgnoreNoData: "Dades",
		dimensionalMovingPropagateNoData: "NoData",
		dimensionalMovingFillOnlyNoData: "Emplena NoData",
		circularMean: "Mitjana circular",
		circularName: "Circular",
		arithmeticName: "Aritmètica",
		slopeName: "Pendent",
		aspectName: "Orientació",
		meanCurvature: "Curvatura mitja",
		profileCurvature: "Curvatura del perfil (línia de pendent normal)",
		tangentialCurvature: "Curvatura tangencial (contorn normal)",
		planCurvature: "Curvatura del pla (contorn projectat)",
		contourGeodesicTorsion: "Torsió geodèsica del contorn",
		gaussianCurvature: "Curvatura gaussiana",
		casoratiCurvature: "Curvatura de Casorati",
		localSurfaceTypeQuadratic: "Quadràtica",
		localSurfaceTypeBiquadratic: "Bioquadràtica",
		thresholdNoThreshold: "Sense llindar",
		thresholdPercentLeastCost: "Percentatge del menor cost",
		thresholdAccumulativeCost: "Cost acumulatiu",
		clrmapTypeHillshade: "Ombreig"
	},
	categoryLabels: {
		sourceCharacteristics: "Característiques d'origen",
		neighborhoodSettings: "Configuració del veïnat",
		statistics: "Estadístiques",
		gamma: "Gamma",
		viewshedParameters: "Paràmetres de conca visual",
		observerParameters: "Paràmetres d'observador",
		irregularDataInterpolation: "Interpolació de dades irregular",
		modelStatistics: "Estadístiques del model",
		aggregationDef: "Definició d'agregació",
		filterByAttributes: "Filtra per atributs",
		percentileName: "Percentil",
		rasterInfo: "Informació de ràster",
		extent: "Extensió",
		spatialReference: "Referència espacial"
	},
	outputRasterHelpTexts: {
		outputName: "<p>Nom de la capa que es crearà i s'afegirà al mapa.</p>",
		resultType: "<p>Tipus de sortida que es crearà. Les sortides poden ser capes d'imatges en mosaic o capes d'imatges dinàmiques.</p>",
		saveResultIn: "<p>Nom de la carpeta a <b>El meu contingut</b> on es desarà el resultat.</p>"
	},
	analysisEnvironmentsHelpTexts: {
		description: "<p>Configuració de l'entorn per a l'anàlisi al Visor de mapes. </p>",
		outSR: "<p>Especifica el sistema de coordenades per a l'anàlisi i la capa de resultats.</p>",
		extent: "<p>Especifica l'àrea que es farà servir per a l'anàlisi.</p>",
		snapRaster: "<p>Ajusta l'extensió de la sortida perquè coincideixi amb l'alineació de cel·les de la capa ràster d'ajust.</p>",
		cellSize: "<p>Especifica la mida o la resolució de cel·la que s'utilitzarà per a l'anàlisi i per crear la capa de ràster de sortida.</p>",
		mask: "<p>Especifica una capa de màscara en la qual només es faran servir per a l'anàlisi les cel·les que es trobin dins de l'àrea de màscara.</p>",
		resamplingMethod: "<p>Especifica com interpolar els valors de píxel quan els ràsters d'entrada i de sortida no estan alineats.</p>"
	},
	mainGenStrings: {
		unsupportedDataType: "Tipus no compatible",
		currentlyUnsupported: " Hi ha un editor predeterminat per a ${missingType}, estarà disponible properament. Quadre de text de marcador de posició temporal per especificar entrades basades en cadena.",
		unsupportedOverrideWarning: "Properament, hi haurà disponible un editor d'invalidació que oferirà una UX millor per treballar amb els paràmetres següents:",
		overrideWidgetMissing: "Falta un component de l'editor d'invalidació.",
		uiIncomplete: "No s'ha pogut enviar el treball. La funció no es pot executar perquè alguns dels camps necessaris no són compatibles o no apareixen a la UI.",
		count: "Recompte",
		selectVariables: "Selecciona les variables",
		selectFeature: "Seleccioneu la capa d'entitats",
		greaterThanErrorMessage: "El valor d'entrada ha de ser major que ${min}.",
		lesserThanErrorMessage: "El valor d'entrada ha de ser menor que ${max}.",
		greaterThanOrEqualErrorMessage: "El valor d'entrada ha de ser major o igual que ${min}.",
		lesserThanOrEqualErrorMessage: "El valor d'entrada ha de ser menor o igual que ${max}.",
		allowScalar: "Seleccioneu una capa o introduïu una constant",
		selectField: "Seleccioneu un camp",
		parameterRequired: "Aquest paràmetre és obligatori.",
		enterAValue: "Introduïu un valor...",
		invalidInput: "El valor que s'ha introduït no és vàlid.",
		itemNotFound: "L'element no existeix o no s'hi pot accedir.",
		itemPermissionDenied: "No teniu permisos per accedir a aquest element.",
		layerNotAvailable: "No s'ha pogut pujar la capa ${layerName}.",
		multipleLayersNotAvailable: "No s'ha pogut pujar la capa ${layerName} ni cap altra.",
		learnMoreLabel: "Més informació",
		fieldNotAvailable: "No s'ha pogut carregar el camp.",
		allowAnalysis: "Anàlisi no permesa al servei d'imatges.",
		allowAnalysisReason: "Una o diverses capes del mapa no figuren en aquesta llista perquè no permeten l'anàlisi.",
		learnMoreText: "Més informació",
		atLeastOneRasterInput: "Com a mínim una capa d'entrada ha de ser una capa ràster.",
		browseAnalysisLayers: "Examineu capes",
		activeMapViewExtent: "Utilitza l'extensió de mapa actual",
		chooseRaster: "Seleccioneu Retalla el ràster",
		chooseGeometry: "Seleccioneu Retalla la geometria",
		resultType: "Tipus de resultat",
		saveInFolder: "Desa-ho a la carpeta",
		outputName: "Nom de sortida",
		outputLayerType: "Tipus de capa de sortida",
		dynamicImageryLayer: "Capa d'imatges dinàmica",
		tiledImageryLayer: "Capa d'imatges en mosaic",
		custom: "Personalitzat",
		loading: "S'està carregant...",
		layerMissing: "Una o diverses capes del mapa no figuren en aquesta llista perquè no permeten l'anàlisi. Obteniu més informació.",
		browseCoordinateSystems: "Examina els sistemes de coordenades",
		unableToRepopulateOutSR: "No es pot emplenar el sistema de coordenades de sortida.",
		defaultTitle: "Veure'n més",
		"ARC (equal arc-second)": "ARC (segon d'arc igual)",
		Africa: "Àfrica",
		Antarctica: "Antàrtida",
		Argentina: "Argentina",
		Asia: "Àsia",
		"Asteroid Belt": "Cinturó d'asteroides",
		"Atlantic Ocean": "Oceà Atlàntic",
		Australia: "Austràlia",
		"Australia and New Zealand": "Austràlia i Nova Zelanda",
		Austria: "Àustria",
		"BLM (US Feet)": "BLM (peus dels EUA)",
		Bangladesh: "Bangla Desh",
		"Beijing 1954": "Pequín 1954",
		Bhutan: "Bhutan",
		CGCS2000: "CGCS2000",
		Canada: "Canadà",
		Caribbean: "Carib",
		"Caribbean Sea": "Mar Carib",
		"Central America": "Amèrica Central",
		"Central and North America": "Amèrica Central i del Nord",
		Colombia: "Colòmbia",
		Continental: "Continental",
		"County Systems": "Sistemes de comtats",
		"Democratic Republic of the Congo": "República Democràtica del Congo",
		"EPSG Arctic": "EPSG Àrtic",
		Earth: "Terra",
		"Ellipsoidal-based": "Basat en un el·lipsoide",
		Europe: "d'Europa",
		Finland: "Finlàndia",
		France: "França",
		"GSK 2011": "GSK 2011",
		"Gauss Kruger": "Gauss-Krüger",
		"Geographic Coordinate Systems": "Sistemes de coordenades geogràfiques",
		Germany: "Alemanya",
		"Gravity-related": "Relacionat amb la gravetat",
		"Greenwich-based": "Basat en Greenwich",
		"Highways England": "Autopistes Anglaterra",
		Illinois: "Illinois",
		"Indian Ocean": "Oceà Índic",
		"Indian Subcontinent": "Subcontinent indi",
		Indiana: "Indiana",
		Indonesia: "Indonèsia",
		Iowa: "Iowa",
		"Ireland and United Kingdom": "Irlanda i el Regne Unit",
		Italy: "Itàlia",
		Japan: "Japó",
		Jupiter: "Júpiter",
		Kansas: "Kansas",
		"Las Vegas": "Las Vegas",
		Libya: "Líbia",
		Malaysia: "Malàisia",
		"Malaysia and Singapore": "Malàisia i Singapur",
		Mars: "Mart",
		Mercury: "Mercuri",
		Minnesota: "Minnesota",
		Montana: "Montana",
		"NAD 1927": "NAD 1927",
		"NAD 1927 (US Feet)": "NAD 1927 (peus dels EUA)",
		"NAD 1983": "NAD 1983",
		"NAD 1983 (2011)": "NAD 1983 (2011)",
		"NAD 1983 (2011) (Intl Feet)": "NAD 1983 (2011) (peus internacionals)",
		"NAD 1983 (2011) (Meters)": "NAD 1983 (2011) (metres)",
		"NAD 1983 (2011) (US Feet)": "NAD 1983 (2011) (peus dels EUA)",
		"NAD 1983 (CORS96) (Intl Feet)": "NAD 1983 (CORS96) (peus internacionals)",
		"NAD 1983 (CORS96) (Meters)": "NAD 1983 (CORS96) (metres)",
		"NAD 1983 (CORS96) (US Feet)": "NAD 1983 (CORS96) (peus dels EUA)",
		"NAD 1983 (Intl Feet)": "NAD 1983 (peus internacionals)",
		"NAD 1983 (Meters)": "NAD 1983 (metres)",
		"NAD 1983 (PA11) (Meters)": "NAD 1983 (PA11) (metres)",
		"NAD 1983 (PA11) (US Feet)": "NAD 1983 (PA11) (peus dels EUA)",
		"NAD 1983 (US Feet)": "NAD 1983 (peus dels EUA)",
		"NAD 1983 HARN (Intl Feet)": "NAD 1983 HARN (peus internacionals)",
		"NAD 1983 HARN (Meters)": "NAD 1983 HARN (metres)",
		"NAD 1983 HARN (US Feet)": "NAD 1983 HARN (peus dels EUA)",
		"NAD 1983 NSRS2007 (Intl Feet)": "NAD 1983 NSRS2007 (peus internacionals)",
		"NAD 1983 NSRS2007 (Meters)": "NAD 1983 NSRS2007 (metres)",
		"NAD 1983 NSRS2007 (US Feet)": "NAD 1983 NSRS2007 (peus dels EUA)",
		"National Grids": "Quadrícules nacionals",
		Navajo: "Navajo",
		Neptune: "Neptú",
		"New Beijing": "Nou Pequín",
		"New Zealand": "Nova Zelanda",
		"North America": "Amèrica del Nord",
		"Northern Hemisphere": "Hemisferi nord",
		Norway: "Noruega",
		Oceans: "Oceans",
		Oregon: "Oregon",
		"Other GCS": "Altres GCS",
		"Pacific Ocean": "Oceà Pacífic",
		Pluto: "Plutó",
		Polar: "Polar",
		Portugal: "Portugal",
		"Projected Coordinate Systems": "Sistemes de coordenades projectades",
		"Pulkovo 1942": "Pulkovo 1942",
		"Pulkovo 1995": "Pulkovo 1995",
		Replaced: "Substituït",
		"SAD 1969": "SAD 1969",
		SIRGAS: "SIRGAS",
		"SIRGAS 2000": "SIRGAS 2000",
		Saturn: "Saturn",
		"Solar System": "Sistema solar",
		"South Africa": "Sud-àfrica",
		"South America": "Amèrica del Sud",
		"South Korea": "Corea del Sud",
		"Southern Hemisphere": "Hemisferi sud",
		"Spheroid-based": "Basat en l'esferoide",
		"State Plane": "State Plane",
		"State Systems": "Sistemes estatals",
		Sweden: "Suècia",
		"Switzerland and Liechtenstein": "Suïssa i Liechtenstein",
		Texas: "Texas",
		Tribal: "Tribal",
		Turkey: "Turquia",
		"US Feet": "Peus dels EUA",
		"USA and territories": "EUA i territoris",
		UTM: "UTM",
		Ukraine: "Ucraïna",
		"Unknown Height Systems": "Sistemes d'alçada desconeguda",
		Uranus: "Urà",
		Venus: "Venus",
		"Vertical Coordinate Systems": "Sistemes de coordenades verticals",
		Vietnam: "Vietnam",
		"WGS 1972": "WGS 1972",
		"WGS 1984": "WGS 1984",
		Wisconsin: "Wisconsin",
		"Wisconsin CRS": "Wisconsin CRS",
		World: "Món",
		"World (Sphere-based)": "Món (basat en una esfera)",
		Wyoming: "Wyoming",
		"Xian 1980": "Xian 1980",
		done: "Fet",
		noResults: "No s'han trobat resultats",
		searchPlaceholder: "Nom o WKID",
		browseTemplate: "Examina les plantilles de funció de ràster",
		saveTemplate: "Desa la plantilla de funció de ràster",
		preview: "Visualització prèvia",
		previewDescription: "Mostra una visualització prèvia del resultat abans d'executar l'anàlisi.",
		showPreview: "Mostra la visualització prèvia",
		previewLayer: "Visualització prèvia de la capa ${number}",
		newPreview: "Visualització prèvia nova",
		previewPopup: "Habiliteu la visualització prèvia dels resultats de l'anàlisi en funció dels paràmetres d'entrada.",
		updatePreviewLayer: "Actualitza la capa de visualització prèvia seleccionada",
		createPreviewLayer: "Crea una capa de visualització prèvia nova",
		maximumPreviewAllowed: "Nombre màxim de capes de visualització prèvia permeses: ${maxCount}",
		previewFailure: "Aquesta capa de visualització prèvia no està disponible. Comproveu els paràmetres d'entada i torneu a actualitzar aquesta capa de visualització prèvia.",
		header: "Selecciona l'element",
		content: "Teniu canvis sense desar a ${rftTitle}. Si torneu a començar amb una plantilla nova, aquests canvis es perdran.",
		dontSave: "No ho desis",
		"continue": "Continua",
		stretch: "Ajusta a la finestra",
		pan: "Desplaça",
		newTemplate: "Crea una plantilla nova",
		openTemplate: "Obre la plantilla",
		addFunction: "Afegeix funcions de ràster",
		addConstant: "Afegeix una constant",
		addRaster: "Afegeix una variable de ràster",
		move: "Mou",
		zoom: "Zoom",
		saveAs: "Anomena i desa",
		clear: "Esborra",
		addRasterFunctionTitle: "Afegeix funcions de ràster",
		templatePropertiesTitle: "Propietats de la plantilla",
		browseRFT: "Examina les plantilles de funció de ràster",
		defaultToolDescription: "Eina d'anàlisi ${toolTitle}.",
		openToolText: "Obre l'eina",
		toolDropdownText: "Menú desplegable d'eines",
		addToMap: "Confirma i afegeix al mapa",
		confirm: "Confirma",
		select: "Selecciona",
		selectTask: "Seleccioneu una tasca",
		unsupportedLayer: "Aquest paràmetre no admet les capes següents: ${layerName}.",
		viewDetails: "Visualitza tots els detalls de l'element",
		rename: "Canvia el nom",
		duplicate: "Duplica",
		launch: "Obre-ho per executar-ho",
		templateEditor: "Editor de plantilles",
		createItem: "Desa la plantilla de funcions de ràster",
		actionLabel: "Filtre",
		filterPopoverHeading: "Filtra les funcions",
		defaultSearchPlaceholder: "Cerca per nom",
		settings: "Configuració",
		summary: "Resum",
		definitionQuery: "Consulta de definició",
		matchVariables: "Variables de coincidència",
		unionDimension: "Dimensió d'unió",
		nameEditorPlaceholder: "Introduïu el títol",
		summaryEditorPlaceholder: "Introduïu una descripció breu.",
		definitionQueryPlaceholder: "Introduïu...",
		upload: "Puja",
		chooseImage: "Feu clic per triar un fitxer",
		update: "Actualitza",
		thumbnailErrors: {
			wrongImageType: "El tipus d'imatge seleccionat és incorrecte",
			notAvailable: "Miniatura no disponible",
			loadError: "No s'ha pogut carregar la imatge",
			chooseFile: "Feu clic per triar el fitxer"
		}
	}
};
const copy = "Copia";
const save = "Desa";
const title = "Títol";
const folder = "Carpeta";
const tags = "Etiquetes";
const savingMessage = "S'està desant l'element a";
const shareWith = "Comparteix-ho amb";
const share = "Comparteix";
const setSharingLevel = "Defineix el nivell d'ús compartit";
const setGroupSharing = "Defineix l'ús compartit del grup";
const owner = "Propietari";
const organization = "Organització";
const everyone = "Tothom (públic)";
const groups = "Grups:";
const type = "Tipus";
const mosaic = "Mosaic";
const itemGroup = "Grup d'elements";
const item = "Element";
const definitionQuery = "Consulta de definició";
const groupItemsBy = "Agrupa els elements per";
const groupFieldName = "Nom del camp de grup";
const tagFieldName = "Nom del camp d'etiqueta";
const noTitleTagErrorMsg = "Heu de proporcionar un títol per a l'element i etiquetes perquè el mapa es pugui trobar mitjançant cerques.";
const noTitleErrorMsg = "Heu de proporcionar un títol per a l'element.";
const noTagErrorMsg = "Heu de proporcionar com a mínim una etiqueta per ajudar les persones a trobar el vostre element mitjançant cerques.";
const error = "Error";
const warning = "Avís";
const success = "Correcte";
const details = "Detalls:";
const tryAgain = "Torna-ho a provar";
const toolModeler = {
	save: "Desa",
	editProperties: "Edita les propietats",
	saveAs: "Anomena i desa",
	savingNotification: "S'estan desant els canvis a l'element...",
	savingTitle: "S'està desant",
	saveFailedMessage: "No s'han pogut desar els canvis.",
	saveWithErrorsMessage: "Els canvis s'han desat amb els errors següents.",
	viewItemMessage: "Visualitzeu l'element desat",
	here: "aquí.",
	itemCreatedMessage: "S'ha creat un element nou.",
	clickToViewItemMessage: "Feu clic a D'acord per visualitzar la pàgina de detalls de l'element; feu clic a Cancel·la per continuar.",
	readingFailed: "No s'ha pogut carregar la plantilla de funció de ràster seleccionada.",
	failedToLoadXML: "No s'ha pogut pujar la plantilla de funció ràster seleccionada en format XML.",
	learnMore: "Més informació",
	overwriteTitle: "Confirma la sobreescriptura",
	overwriteMessage: "Voleu sobreescriure l'element existent?",
	overwriteSuccessMessage: "L'element s'ha actualitzat."
};
const toolEditor = {
	run: "Executa",
	save: "Desa",
	deleteSelected: "Suprimeix els elements seleccionats",
	addRaster: "Afegeix un ràster",
	addScalar: "Afegeix un escalar",
	layout: "Disseny automàtic",
	errorTitle: "Error",
	invalidToolMessage: "La plantilla de funció de ràster no és vàlida.",
	out: "Fora",
	zoomIn: "Amplia",
	zoomOut: "Redueix",
	zoomToFit: "Ajusta a la finestra",
	panOn: "Canvia al mode panoràmic",
	panOff: "Desactiva el mode panoràmic",
	defaultModelName: "Model d'eina",
	defaultRasterName: "Ràster"
};
const toolDetailsEditor = {
	defaultToolName: "Plantilla de funció de ràster",
	defaultToolDescription: "Afegiu un resum breu sobre la funció de ràster.",
	defaultHelpText: "Feu clic a la icona d'ajuda per editar el text d'ajuda",
	editHelpTitle: "Edita l'ajuda",
	saveLabel: "Desa",
	cancelLabel: "Cancel·la",
	thumbnail: {
		wrongImageType: "El tipus d'imatge seleccionat és incorrecte",
		notAvailable: "Miniatura no disponible",
		loadError: "No s'ha pogut carregar la imatge",
		chooseFile: "Feu clic per triar el fitxer"
	}
};
const saveUtils = {
	thumbnail: "Miniatura",
	sharing: "Ús compartit"
};
const close = "Tanca";
const unsavedWarningExisting = "Voleu desar els canvis a l'element <b>${itemTitle}</b> ?";
const unsavedWarningNew = "Voleu desar els canvis?";
const saveAs = "Anomena i desa";
const dontSave = "No ho desis";
const unsavedTitle = "Canvis sense desar";
const invalidRFTMessage = "La plantilla de funció de ràster creada no és vàlida.";
const errorTitle = "Error";
const breadcrumb = "Editor de funcions ràster";
const breadcrumbEditor = "Contingut > Editor de funcions ràster";
const viewerModeTitle = "Només de lectura";
const viewerModeMessage = "L'element de la plantilla de funció de ràster és només de lectura No es poden desar els canvis.";
const userStartDirection = "Seleccioneu una funció per començar a crear una plantilla de funció de ràster.";
const selectFunction = "Afegeix una funció";
const deselectFunction = "Elimina la funció";
const dialogTitle = "Sistema";
const category = "Categories";
const search = "Cerca funcions de ràster";
const categoryNames = {
	analysis: "Anàlisi",
	appearance: "Aparença",
	classification: "Classificació",
	conversion: "Conversió",
	correction: "Correcció",
	dataManagement: "Administració de dades",
	distance: "Distància",
	distanceLegacy: "Distància (heretat)",
	hydrology: "Hidrologia",
	math: "Matemàtiques",
	mathConditional: "Matemàtiques: condicionals",
	mathLogical: "Matemàtiques: lògiques",
	mathTrigonometric: "Matemàtiques: trigonomètriques",
	reclass: "Reclassifica",
	statistical: "Estadística",
	surface: "Superfície"
};
const commonStrings_ca = {
	ok: ok,
	cancel: cancel,
	enterURL: enterURL,
	serviceURL: serviceURL,
	selectRaster: selectRaster,
	failedToLoadLayer: failedToLoadLayer,
	loadingLayer: loadingLayer,
	selectFeature: selectFeature,
	enterFURL: enterFURL,
	addRaster: addRaster,
	addScalar: addScalar,
	raster: raster,
	scalar: scalar,
	defaultModelName: defaultModelName,
	general: general,
	parameters: parameters,
	variables: variables,
	name: name,
	description: description,
	parameter: parameter,
	isPublic: isPublic,
	isDataset: isDataset,
	unknownPixelType: unknownPixelType,
	outputPixelType: outputPixelType,
	u8PixelType: u8PixelType,
	s8PixelType: s8PixelType,
	u16PixelType: u16PixelType,
	s16PixelType: s16PixelType,
	u32PixelType: u32PixelType,
	s32PixelType: s32PixelType,
	f32PixelType: f32PixelType,
	f64PixelType: f64PixelType,
	properties: properties,
	multidimensionalRules: multidimensionalRules,
	matchVariables: matchVariables,
	unionDimensions: unionDimensions,
	rasterFunctionEditor: rasterFunctionEditor,
	rfxLicenseInfo: rfxLicenseInfo,
	rasterFunctions: rasterFunctions,
	copy: copy,
	save: save,
	title: title,
	folder: folder,
	tags: tags,
	savingMessage: savingMessage,
	shareWith: shareWith,
	share: share,
	setSharingLevel: setSharingLevel,
	setGroupSharing: setGroupSharing,
	owner: owner,
	organization: organization,
	everyone: everyone,
	groups: groups,
	type: type,
	mosaic: mosaic,
	itemGroup: itemGroup,
	item: item,
	definitionQuery: definitionQuery,
	groupItemsBy: groupItemsBy,
	groupFieldName: groupFieldName,
	tagFieldName: tagFieldName,
	noTitleTagErrorMsg: noTitleTagErrorMsg,
	noTitleErrorMsg: noTitleErrorMsg,
	noTagErrorMsg: noTagErrorMsg,
	error: error,
	warning: warning,
	success: success,
	details: details,
	tryAgain: tryAgain,
	toolModeler: toolModeler,
	toolEditor: toolEditor,
	toolDetailsEditor: toolDetailsEditor,
	saveUtils: saveUtils,
	close: close,
	unsavedWarningExisting: unsavedWarningExisting,
	unsavedWarningNew: unsavedWarningNew,
	saveAs: saveAs,
	dontSave: dontSave,
	unsavedTitle: unsavedTitle,
	invalidRFTMessage: invalidRFTMessage,
	errorTitle: errorTitle,
	breadcrumb: breadcrumb,
	breadcrumbEditor: breadcrumbEditor,
	viewerModeTitle: viewerModeTitle,
	viewerModeMessage: viewerModeMessage,
	userStartDirection: userStartDirection,
	selectFunction: selectFunction,
	deselectFunction: deselectFunction,
	dialogTitle: dialogTitle,
	category: category,
	search: search,
	categoryNames: categoryNames
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (commonStrings_ca);


//# sourceMappingURL=common-strings.ca-ada3d60c.js.map

/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid2lkZ2V0cy9jaHVua3MvYXJjZ2lzX2FuYWx5c2lzX25vZGVfbW9kdWxlc19hcmNnaXNfYXJjZ2lzLXJhc3Rlci1mdW5jdGlvbi1lZGl0b3JfLTU1ZjExNy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNGdDQUE0Z0MsMENBQTBDO0FBQ3RqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMmFBQTJhLHlJQUF5SSxxRUFBcUU7QUFDem5CO0FBQ0E7QUFDQSx3ZEFBd2Q7QUFDeGQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVJQUF1STtBQUN2STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc01BQXNNO0FBQ3RNO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1a0JBQXVrQjtBQUN2a0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdQQUF3UDtBQUN4UDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdWxHQUF1bEcsT0FBTztBQUM5bEc7QUFDQTtBQUNBLHcxQ0FBdzFDO0FBQ3gxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsZ0VBQWdFLFlBQVk7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQXFFLElBQUk7QUFDekUsb0VBQW9FLElBQUk7QUFDeEUsb0ZBQW9GLElBQUk7QUFDeEYsbUZBQW1GLElBQUk7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsVUFBVTtBQUM5RCw2REFBNkQsV0FBVztBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxPQUFPO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0ZBQW9GLFNBQVM7QUFDN0Y7QUFDQTtBQUNBLHlDQUF5QyxTQUFTO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLFVBQVU7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQXFFLFVBQVU7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0dBQWdHO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RUFBd0UsVUFBVTtBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlFQUFlLGdCQUFnQixFQUFDO0FBQ2lvQzs7QUFFanFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZXhiLWNsaWVudC8uL2V4dGVuc2lvbnMvd2lkZ2V0cy9hcmNnaXMvYW5hbHlzaXMvbm9kZV9tb2R1bGVzL0BhcmNnaXMvYXJjZ2lzLXJhc3Rlci1mdW5jdGlvbi1lZGl0b3IvZGlzdC9lc20vY29tbW9uLXN0cmluZ3MuY2EtYWRhM2Q2MGMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3Qgb2sgPSBcIkQnYWNvcmRcIjtcbmNvbnN0IGNhbmNlbCA9IFwiQ2FuY2VswrdsYVwiO1xuY29uc3QgZW50ZXJVUkwgPSBcIkludHJvZHXDr3UgbGEgVVJMIGRlbCBzZXJ2ZWkgZCdpbWF0Z2VzXCI7XG5jb25zdCBzZXJ2aWNlVVJMID0gXCJVUkwgZGVsIHNlcnZlaVwiO1xuY29uc3Qgc2VsZWN0UmFzdGVyID0gXCJTZWxlY2Npb25ldSB1biByw6BzdGVyXCI7XG5jb25zdCBmYWlsZWRUb0xvYWRMYXllciA9IFwiTm8gcydoYSBwb2d1dCBjYXJyZWdhciBsYSBjYXBhXCI7XG5jb25zdCBsb2FkaW5nTGF5ZXIgPSBcIlMnZXN0w6AgY2FycmVnYW50IGxhIGNhcGFcIjtcbmNvbnN0IHNlbGVjdEZlYXR1cmUgPSBcIlNlbGVjY2lvbmV1IGxhIGNhcGEgZCdlbnRpdGF0c1wiO1xuY29uc3QgZW50ZXJGVVJMID0gXCJJbnRyb2R1w691IGwnVVJMIGRlbCBzZXJ2ZWkgZCdlbnRpdGF0c1wiO1xuY29uc3QgYWRkUmFzdGVyID0gXCJBZmVnZWl4IHVuYSB2YXJpYWJsZSBkZSByw6BzdGVyXCI7XG5jb25zdCBhZGRTY2FsYXIgPSBcIkFmZWdlaXggdW5hIGNvbnN0YW50XCI7XG5jb25zdCByYXN0ZXIgPSBcIlLDoHN0ZXJcIjtcbmNvbnN0IHNjYWxhciA9IFwiRXNjYWxhclwiO1xuY29uc3QgZGVmYXVsdE1vZGVsTmFtZSA9IFwiUGxhbnRpbGxhIGRlIGZ1bmNpw7MgZGUgcsOgc3RlclwiO1xuY29uc3QgZ2VuZXJhbCA9IFwiR2VuZXJhbFwiO1xuY29uc3QgcGFyYW1ldGVycyA9IFwiUGFyw6BtZXRyZXNcIjtcbmNvbnN0IHZhcmlhYmxlcyA9IFwiVmFyaWFibGVzXCI7XG5jb25zdCBuYW1lID0gXCJOb21cIjtcbmNvbnN0IGRlc2NyaXB0aW9uID0gXCJEZXNjcmlwY2nDs1wiO1xuY29uc3QgcGFyYW1ldGVyID0gXCJQYXLDoG1ldHJlXCI7XG5jb25zdCBpc1B1YmxpYyA9IFwiSXNQdWJsaWNcIjtcbmNvbnN0IGlzRGF0YXNldCA9IFwiSXNEYXRhc2V0XCI7XG5jb25zdCB1bmtub3duUGl4ZWxUeXBlID0gXCJEZXNjb25lZ3V0XCI7XG5jb25zdCBvdXRwdXRQaXhlbFR5cGUgPSBcIlRpcHVzIGRlIHDDrXhlbCBkZSBzb3J0aWRhXCI7XG5jb25zdCB1OFBpeGVsVHlwZSA9IFwiOCBiaXRzIHNlbnNlIHNpZ25hclwiO1xuY29uc3QgczhQaXhlbFR5cGUgPSBcIjggYml0cyBzaWduYXRcIjtcbmNvbnN0IHUxNlBpeGVsVHlwZSA9IFwiMTYgYml0cyBzZW5zZSBzaWduYXJcIjtcbmNvbnN0IHMxNlBpeGVsVHlwZSA9IFwiMTYgYml0cyBzaWduYXRcIjtcbmNvbnN0IHUzMlBpeGVsVHlwZSA9IFwiMzIgYml0cyBzZW5zZSBzaWduYXJcIjtcbmNvbnN0IHMzMlBpeGVsVHlwZSA9IFwiMzIgYml0cyBzaWduYXRcIjtcbmNvbnN0IGYzMlBpeGVsVHlwZSA9IFwiMzIgYml0cyBmbG90YW50XCI7XG5jb25zdCBmNjRQaXhlbFR5cGUgPSBcIjY0IGJpdHMgZG9ibGVcIjtcbmNvbnN0IHByb3BlcnRpZXMgPSBcIlByb3BpZXRhdHNcIjtcbmNvbnN0IG11bHRpZGltZW5zaW9uYWxSdWxlcyA9IFwiUmVnbGVzIG11bHRpZGltZW5zaW9uYWxzXCI7XG5jb25zdCBtYXRjaFZhcmlhYmxlcyA9IFwiVmFyaWFibGVzIGRlIGNvaW5jaWTDqG5jaWFcIjtcbmNvbnN0IHVuaW9uRGltZW5zaW9ucyA9IFwiRGltZW5zaW9ucyBkJ3VuacOzXCI7XG5jb25zdCByYXN0ZXJGdW5jdGlvbkVkaXRvciA9IHtcblx0aW52YWxpZFJGVE1lc3NhZ2U6IFwiTGEgcGxhbnRpbGxhIGRlIGZ1bmNpw7MgZGUgcsOgc3RlciBubyDDqXMgdsOgbGlkYS5cIixcblx0cmZ4QXJnc0VkaXRvcjoge1xuXHRcdG91dHB1dFJhc3RlcjogXCJPdXRwdXRSYXN0ZXJcIixcblx0XHRyYXN0ZXI6IFwiUsOgc3RlclwiLFxuXHRcdHVuc3VwcG9ydGVkRGF0YVR5cGVXYXJuaW5nOiBcIkVscyBhcmd1bWVudHMgc2Vnw7xlbnRzIG5vIGVzIG1vc3RyZW4gcGVycXXDqCBhY3R1YWxtZW50IG5vIHPDs24gY29tcGF0aWJsZXMuXCIsXG5cdFx0dW5zdXBwb3J0ZWRGdW5jdGlvbjogXCJDb250w6kgZnVuY2lvbnMgZGUgcsOgc3RlciBubyBhZG1lc2VzIGFjdHVhbG1lbnQuXCJcblx0fSxcblx0cmZ4UmFzdGVySW5wdXQ6IHtcblx0XHRzZWxlY3RMYXllcjogXCJTZWxlY2Npb25ldSBsYSBjYXBhXCIsXG5cdFx0YnJvd3NlTGF5ZXJzOiBcIkV4YW1pbmEgbGVzIGNhcGVzXCIsXG5cdFx0cmZ4VmFyaWFibGU6IFwiUmFzdGVyRnVuY3Rpb25WYXJpYWJsZVwiXG5cdH0sXG5cdHJmeEJhbmRDb21iaW5hdGlvbkVkaXRvcjoge1xuXHRcdG1ldGhvZExhYmVsOiBcIk3DqHRvZGVcIixcblx0XHRiYW5kTGFiZWw6IFwiQmFuZGFcIixcblx0XHRjb21iaW5hdGlvbkxhYmVsOiBcIkNvbWJpbmFjacOzXCJcblx0fSxcblx0cmZ4UmVtYXBHcmlkOiB7XG5cdFx0bWluaW11bTogXCJNw61uaW1cIixcblx0XHRtYXhpbXVtOiBcIk3DoHhpbVwiLFxuXHRcdG91dHB1dDogXCJTb3J0aWRhXCIsXG5cdFx0bm9EYXRhOiBcIk5vRGF0YVwiLFxuXHRcdHJlbWFwVmFsdWVzTGFiZWw6IFwiTm92YSByZXByZXNlbnRhY2nDsyBjYXJ0b2dyw6BmaWNhIGRlIHZhbG9yc1wiXG5cdH0sXG5cdHJmeE5hbWVkUmFzdGVyRWRpdG9yOiB7XG5cdFx0cmFzdGVyVmFyaWFibGVzOiBcIlZhcmlhYmxlcyBkZSByw6BzdGVyXCIsXG5cdFx0ZGVsZXRlU2VsZWN0ZWRWYXJzOiBcIkVsaW1pbmEgbGVzIHZhcmlhYmxlcyBzZWxlY2Npb25hZGVzXCJcblx0fSxcblx0cmZ4Q2xpcHBpbmdHZW9tZXRyeToge1xuXHRcdGNsaXBwaW5nTGF5ZXI6IFwiQ2FwYSBkZSByZXRhbGxzXCIsXG5cdFx0Y2xpcHBpbmdSYXN0ZXI6IFwiUydlc3TDoCByZXRhbGxhbnQgZWwgcsOgc3RlclwiLFxuXHRcdGNsaXBwaW5nR2VvbWV0cnk6IFwiUydlc3TDoCByZXRhbGxhbnQgbGEgZ2VvbWV0cmlhXCIsXG5cdFx0Y3VzdG9tRXh0ZW50OiBcIkV4dGVuc2nDsyBwZXJzb25hbGl0emFkYVwiLFxuXHRcdG91dHB1dEV4dGVudDogXCJFeHRlbnNpw7MgZGUgc29ydGlkYVwiLFxuXHRcdGN1cnJlbnRFeHRlbnQ6IFwiRXh0ZW5zacOzIGRlIG1hcGEgYWN0dWFsXCIsXG5cdFx0ZHJhd0xhYmVsOiBcIkRpYnVpeGFcIlxuXHR9LFxuXHRyZnhDdXN0b21FeHRlbnQ6IHtcblx0XHR0b3A6IFwiU3VwZXJpb3JcIixcblx0XHRyaWdodDogXCJEcmV0XCIsXG5cdFx0Ym90dG9tOiBcIkluZmVyaW9yXCIsXG5cdFx0bGVmdDogXCJFc3F1ZXJyZVwiXG5cdH0sXG5cdHJmeFJhc3RlckFycmF5RWRpdG9yOiB7XG5cdFx0bW92ZVVwOiBcIk1vdSBjYXAgYW11bnRcIixcblx0XHRtb3ZlRG93bjogXCJNb3UgY2FwIGF2YWxsXCIsXG5cdFx0cmVtb3ZlOiBcIkVsaW1pbmFcIlxuXHR9LFxuXHRyZnhTdGF0aXN0aWNzR3JpZDoge1xuXHRcdHN0ZERldjogXCJEZXN2LiBlc3TDoG5kYXJkXCIsXG5cdFx0bWluOiBcIk3DrW4uXCIsXG5cdFx0bWF4OiBcIk3DoHguXCIsXG5cdFx0bWVhbjogXCJNaXRqYVwiXG5cdH0sXG5cdHJmeFdlaWdodGVkU3VtVGFibGVFZGl0b3I6IHtcblx0XHR3ZWlnaHRlZFN1bVRhYmxlOiBcIlRhdWxhIGRlIHN1bWVzIHBvbmRlcmFkZXNcIixcblx0XHRpZDogXCJJRFwiLFxuXHRcdGxheWVyOiBcIkNhcGFcIixcblx0XHRmaWVsZDogXCJDYW1wXCIsXG5cdFx0d2VpZ2h0OiBcIlBlc1wiLFxuXHRcdHZhbHVlOiBcIlZhbG9yXCIsXG5cdFx0c2VsZWN0TGF5ZXI6IFwiU2VsZWNjaW9uZXUgbGEgY2FwYVwiXG5cdH0sXG5cdHJmeFdlaWdodGVkT3ZlcmxheVRhYmxlRWRpdG9yOiB7XG5cdFx0d2VpZ2h0ZWRPdmVybGF5VGFibGU6IFwiVGF1bGEgZGUgc3VwZXJwb3NpY2nDsyBwb25kZXJhZGFcIixcblx0XHRpZDogXCJJRFwiLFxuXHRcdGxheWVyOiBcIkNhcGFcIixcblx0XHRmaWVsZDogXCJDYW1wXCIsXG5cdFx0aW5mbHVlbmNlOiBcIkluZmx1w6huY2lhXCIsXG5cdFx0c3VtT2ZJbmZsdWVuY2U6IFwiU3VtYSBkJ2luZmx1w6huY2lhXCIsXG5cdFx0dmFsdWU6IFwiVmFsb3JcIixcblx0XHRyZW1hcFRhYmxlOiBcIlRhdWxhIGRlIG5vdmEgcmVwcmVzZW50YWNpw7MgZ2VvZ3LDoGZpY2FcIixcblx0XHRzY2FsZTogXCJFc2NhbGFcIixcblx0XHRzY2FsZXM6IFwiRXNjYWxlc1wiLFxuXHRcdHNlbGVjdFJhc3RlcjogXCJTZWxlY2Npb25ldSB1biByw6BzdGVyXCJcblx0fSxcblx0cmZ4RmVhdHVyZVNlbGVjdDoge1xuXHRcdGFkZEZlYXR1cmVMYXllcjogXCJDZXJjYSB1bmEgY2FwYSBkJ2VudGl0YXRzXCIsXG5cdFx0YWRkUG9pbnRMYXllcjogXCJDZXJjYSB1bmEgY2FwYSBkZSBwdW50c1wiXG5cdH0sXG5cdHJmeEZpZWxkU2VsZWN0OiB7XG5cdFx0dmFsdWU6IFwiVmFsb3JcIixcblx0XHRjb3VudDogXCJSZWNvbXB0ZVwiXG5cdH0sXG5cdHJmeEF0dHJpYnV0ZVRhYmxlOiB7XG5cdFx0dGFibGVUeXBlOiBcIlRpcHVzIGRlIHRhdWxhXCIsXG5cdFx0bWFudWFsOiBcIk1hbnVhbFwiLFxuXHRcdGV4dGVybmFsOiBcIkV4dGVyblwiLFxuXHRcdG1pblZhbDogXCJWYWxvciBtw61uaW1cIixcblx0XHRtYXhWYWw6IFwiVmFsb3IgbcOgeGltXCIsXG5cdFx0YmFzZUNsYXNzTmFtZTogXCJOb20gZGUgYmFzZSBkZSBsYSBjbGFzc2VcIixcblx0XHRjb2xvclNjaGVtZTogXCJFc3F1ZW1hIGRlIGNvbG9yc1wiLFxuXHRcdGRlZmF1bHRDbGFzc05hbWU6IFwiTGFiZWxfXCIsXG5cdFx0Z2VuZXJhdGVUYWJsZTogXCJHZW5lcmEgbGEgdGF1bGFcIixcblx0XHRicm93c2VUYWJsZTogXCJOYXZlZ3VldSBwZXIgbGEgdGF1bGFcIixcblx0XHR2YWx1ZTogXCJWYWxvclwiLFxuXHRcdGNsYXNzbmFtZTogXCJDbGFzc05hbWVcIixcblx0XHRjb2xvcjogXCJDb2xvclwiXG5cdH0sXG5cdHJmeEZpZWxkTnVtYmVyU3dpdGNoYWJsZToge1xuXHRcdG51bWJlcjogXCJOdW3DqHJpY1wiLFxuXHRcdGZpZWxkOiBcIkNhbXBcIixcblx0XHRzdHJpbmc6IFwiQ2FkZW5hXCIsXG5cdFx0bGluZWFyVW5pdDogXCJVbml0YXQgbGluZWFsXCJcblx0fSxcblx0cmZ4UHJvcGVydHlTZXQ6IHtcblx0XHRuYW1lOiBcIk5vbVwiLFxuXHRcdHZhbHVlOiBcIlZhbG9yXCJcblx0fSxcblx0cmZ4Q29udmVyc2lvbkdyaWQ6IHtcblx0XHRzaXplOiBcIk1pZGFcIlxuXHR9LFxuXHRyZnhUcmFuc3Bvc2VCaXQ6IHtcblx0XHRiaXRQYXR0ZXJuOiBcIlBhdHLDsyBkZSBiaXRzXCIsXG5cdFx0b3V0cHV0Qml0OiBcIkJpdCBkZSBzb3J0aWRhXCIsXG5cdFx0aW5wdXRCaXQ6IFwiQml0IGQnZW50cmFkYVwiXG5cdH0sXG5cdHJmeFNwYXRpYWxSZWZlcmVuY2U6IHtcblx0XHRwbGFjZUhvbGRlcjogXCJSZWZpbmEgcGVyIHBhcmF1bGEgY2xhdVwiLFxuXHRcdGNvb3JkaW5hdGVTeXN0ZW06IFwiU2lzdGVtYSBkZSBjb29yZGVuYWRlc1wiLFxuXHRcdGdjczogXCJTaXN0ZW1hIGRlIGNvb3JkZW5hZGVzIGdlb2dyw6BmaXF1ZXNcIixcblx0XHRwY3M6IFwiU2lzdGVtYSBkZSBjb29yZGVuYWRlcyBwcm9qZWN0YWRlc1wiLFxuXHRcdHZjczogXCJTaXN0ZW1hIGRlIGNvb3JkZW5hZGVzIHZlcnRpY2Fsc1wiXG5cdH1cbn07XG5jb25zdCByZnhMaWNlbnNlSW5mbyA9IFwiQXF1ZXN0YSBwbGFudGlsbGEgZGUgZnVuY2nDsyBkZSByw6BzdGVyIGVzIHBvdCB1dGlsaXR6YXIgcGVyIHByb2Nlc3NhciBsZXMgaW1hdGdlcyBtaXRqYW7Dp2FudCBsJ0FyY0dJUyBJbWFnZSBTZXJ2ZXIuXCI7XG5jb25zdCByYXN0ZXJGdW5jdGlvbnMgPSB7XG5cdHJmeDoge1xuXHRcdGFDb3NITmFtZTogXCJBcmMgY29zaW51cyBoaXBlcmLDsmxpYyAoQUNvc0gpXCIsXG5cdFx0YUNvc0hTbmlwOiBcIkNhbGN1bGEgZWwgY29zaW51cyBoaXBlcmLDsmxpYyBpbnZlcnMgZGUgbGVzIGNlbMK3bGVzIGQndW4gcsOgc3Rlci5cIixcblx0XHRhQ29zSERlc2M6IFwiTGEgZnVuY2nDsyBjYWxjdWxhIGVsIGNvc2ludXMgaGlwZXJiw7JsaWMgaW52ZXJzIGRlbHMgcMOteGVscyBkJ3VuIHLDoHN0ZXIuXCIsXG5cdFx0YUNvc05hbWU6IFwiQXJjIGNvc2ludXMgKEFDb3MpXCIsXG5cdFx0YUNvc1NuaXA6IFwiQ2FsY3VsYSBlbCBjb3NpbnVzIGludmVycyBkZWxzIHDDrXhlbHMgZCd1biByw6BzdGVyLlwiLFxuXHRcdGFDb3NEZXNjOiBcIkFxdWVzdGEgZnVuY2nDsyBkZSByw6BzdGVyIGNhbGN1bGEgZWwgY29zaW51cyBpbnZlcnMgZGUgbGVzIGNlbMK3bGVzIGQndW4gcsOgc3Rlci4gRW4gbWF0ZW3DoHRpcXVlcywgdG90ZXMgbGVzIGZ1bmNpb25zIHRyaWdvbm9tw6h0cmlxdWVzIHRlbmVuIHVuIGludGVydmFsIGRlZmluaXQgZGUgdmFsb3JzIGQnZW50cmFkYSB2w6BsaWRzLCBxdWUgZXMgY29uZWl4ZW4gY29tIGVsIGRvbWluaS4gRWxzIHZhbG9yIGRlIHNvcnRpZGEgZGUgY2FkYSBmdW5jacOzIHRhbWLDqSB0w6kgdW4gaW50ZXJ2YWwgZGVmaW5pdC4gUGVyIGEgYXF1ZXN0YSBlaW5hLCBlbCBkb21pbmkgw6lzIFstMSwgMV0gaSBsJ2ludGVydmFsIMOpcyBbMCwgcGldLlwiLFxuXHRcdGFTaW5ITmFtZTogXCJBcmMgc2ludXMgaGlwZXJiw7JsaWMgKEFTaW5IKVwiLFxuXHRcdGFTaW5IU25pcDogXCJDYWxjdWxhIGVsIHNpbnVzIGhpcGVyYsOybGljIGludmVycyBkZSBsZXMgY2VswrdsZXMgZCd1biByw6BzdGVyLlwiLFxuXHRcdGFTaW5IRGVzYzogXCJMYSBmdW5jacOzIGNhbGN1bGEgZWwgc2ludXMgaGlwZXJiw7JsaWMgaW52ZXJzIGRlbHMgcMOteGVscyBkJ3VuIHLDoHN0ZXIuXCIsXG5cdFx0YVNpbk5hbWU6IFwiQXJjIHNpbnVzIChBU2luKVwiLFxuXHRcdGFTaW5TbmlwOiBcIkNhbGN1bGEgZWwgc2ludXMgaW52ZXJzIGRlIGxlcyBjZWzCt2xlcyBkJ3VuIHLDoHN0ZXIuXCIsXG5cdFx0YVNpbkRlc2M6IFwiTGEgZnVuY2nDsyBjYWxjdWxhIGVsIHNpbnVzIGludmVycyBkZWxzIHDDrXhlbHMgZCd1biByw6BzdGVyLlwiLFxuXHRcdGFUYW4yTmFtZTogXCJBcmMgdGFuZ2VudCAoQVRhbjIpXCIsXG5cdFx0YVRhbjJTbmlwOiBcIkNhbGN1bGEgbGEgdGFuZ2VudCBpbnZlcnNhIChiYXNhZGEgZW4geCx5KSBkZSBsZXMgY2VswrdsZXMgZCd1biByw6BzdGVyLlwiLFxuXHRcdGFUYW4yRGVzYzogXCJMYSBmdW5jacOzIGNhbGN1bGEgbGEgdGFuZ2VudCBpbnZlcnNhIChiYXNhZGEgZW4geCx5KSBkZWxzIHDDrXhlbHMgZCd1biByw6BzdGVyLlwiLFxuXHRcdGFUYW5ITmFtZTogXCJBcmMgdGFuZ2VudCBoaXBlcmLDsmxpY2EgKEFUYW5IKVwiLFxuXHRcdGFUYW5IU25pcDogXCJDYWxjdWxhIGxhIHRhbmdlbnQgaGlwZXJiw7JsaWNhIGludmVyc2EgZGUgbGVzIGNlbMK3bGVzIGQndW4gcsOgc3Rlci5cIixcblx0XHRhVGFuSERlc2M6IFwiTGEgZnVuY2nDsyBjYWxjdWxhIGxhIHRhbmdlbnQgaGlwZXJiw7JsaWNhIGludmVyc2EgZGVscyBww614ZWxzIGQndW4gcsOgc3Rlci5cIixcblx0XHRhVGFuTmFtZTogXCJBcmMgdGFuZ2VudCAoQVRhbilcIixcblx0XHRhVGFuU25pcDogXCJDYWxjdWxhIGxhIHRhbmdlbnQgaW52ZXJzYSBkZSBsZXMgY2VswrdsZXMgZCd1biByw6BzdGVyLlwiLFxuXHRcdGFUYW5EZXNjOiBcIkxhIGZ1bmNpw7MgY2FsY3VsYSBsYSB0YW5nZW50IGludmVyc2EgZGVscyBww614ZWxzIGQndW4gcsOgc3Rlci5cIixcblx0XHRhYnNOYW1lOiBcIlZhbG9yIGFic29sdXRcIixcblx0XHRhYnNTbmlwOiBcIkNhbGN1bGEgZWwgdmFsb3IgYWJzb2x1dCBkZSBsZXMgY2VswrdsZXMgZCd1biByw6BzdGVyLlwiLFxuXHRcdGFic0Rlc2M6IFwiTGEgZnVuY2nDsyBWYWxvciBhYnNvbHV0IGNhbGN1bGEgZWwgdmFsb3IgYWJzb2x1dCBkZWxzIHDDrXhlbHMgZCd1biByw6BzdGVyLlwiLFxuXHRcdHJlZmxlY3RhbmNlTmFtZTogXCJSZWZsZWN0w6BuY2lhIGFwYXJlbnRcIixcblx0XHRyZWZsZWN0YW5jZVNuaXA6IFwiQ29udmVydGVpeCBsZXMgaW1hdGdlcyBzZW5zZSBwcm9jZXNzYXIgZW4gdmFsb3JzIGRlIHNvc3RyZSBkZSBsJ2F0bW9zZmVyYSAoVE9BKS4gUGVyIGZlci1obywgdMOpIGVuIGNvbXB0ZSBsZXMgY2FyYWN0ZXLDrXN0aXF1ZXMgZGVsIHNlbnNvciwgbGEgcG9zaWNpw7MgZGVsIHNvbCBpIGVsIHRlbXBzIGQnYWRxdWlzaWNpw7MuXCIsXG5cdFx0cmVmbGVjdGFuY2VEZXNjOiBcIkFxdWVzdGEgZnVuY2nDsyBhanVzdGEgZWxzIHZhbG9ycyBkZSBub21icmUgZGlnaXRhbCAoRE4pIGRlIGJyaWxsYW50b3IgZGUgbGEgaW1hdGdlIHBlciBhIGFsZ3VucyBzZW5zb3JzIGRlIHNhdMOobMK3bGl0LiBBcXVlc3RzIGFqdXN0cyBlcyBiYXNlbiBlbiBsZXMgcHJvcGlldGF0cyBkJ2VsZXZhY2nDsyBkZWwgc29sLCBkZSBkYXRhIGQnYWRxdWlzaWNpw7MgaSBkZWwgc2Vuc29yIHBlciBkZWZpbmlyIGVsIGd1YW55IGkgZWwgYmlhaXggZGUgY2FkYSBiYW5kYS4gQXF1ZXN0YSBmdW5jacOzIHMndXRpbGl0emEgcGVyIGFqdXN0YXIgZWxzIHZhbG9ycyBkZSByZWZsZWN0w6BuY2lhLCBvIGJyaWxsYW50b3IsIGQnYWxndW5lcyBpbWF0Z2VzIGRlIHNhdMOobMK3bGl0IGVuIGZ1bmNpw7MgZGUgbGEgaWzCt2x1bWluYWNpw7MgZGUgbCdlc2NlbmEgaSBsYSBjb25maWd1cmFjacOzIGRlIGd1YW55IGRlbCBzZW5zb3IuIExlcyBpbWF0Z2VzIHMnYWp1c3RlbiBhIHVuYSBjb25kaWNpw7MgZCdpbMK3bHVtaW5hY2nDsyB0ZcOycmljYW1lbnQgY29tdW5hIGksIHBlciB0YW50LCBoaSBoYXVyaWEgZCdoYXZlciBtZW55cyB2YXJpYWNpw7MgZW50cmUgbGVzIGVzY2VuZXMgZGUgZGF0ZXMgaSBzZW5zb3JzIGRpZmVyZW50cy4gQWl4w7IgcG90IHJlc3VsdGFyIMO6dGlsIHBlciBhIGxhIGNsYXNzaWZpY2FjacOzIGQnaW1hdGdlcywgbCdhanVzdCBkZWwgY29sb3IgaSBsYSBjcmVhY2nDsyBkZSBtb3NhaWNzLiBBcXVlc3RhIGZ1bmNpw7Mgbm9tw6lzIGVzIHBvdCB1dGlsaXR6YXIgYW1iIGltYXRnZXMgZXNwZWPDrWZpcXVlcy4gRWxzIHNlbnNvcnMgYXBsaWNhYmxlcyBzw7NuIExhbmRzYXQgTVNTLCBMYW5kc2F0IFRNLCBMYW5kc2F0IEVUTSssIExhbmRzYXQgOCwgSUtPTk9TLCBRdWlja0JpcmQsIEdlb0V5ZS0xLCBSYXBpZEV5ZSwgRE1DaWksIFdvcmxkVmlldy0xLCBXb3JsZFZpZXctMiwgU1BPVCA2IGkgUGxlaWFkZXMuPGRpdj48YnIvPkxhIGZ1bmNpw7MgcmVhbGl0emEgZHVlcyBjb3JyZWNjaW9ucy4gTGEgcHJpbWVyYSBlcyBiYXNhIGVuIGxhIGNvbmZpZ3VyYWNpw7MgZGUgZ3VhbnkuIEVscyB2YWxvcnMgZGUgYnJpbGxhbnRvciBvcmlnaW5hbHMgZXMgdG9ybmVuIGEgY3JlYXIgYSBwYXJ0aXIgZGVscyB2YWxvcnMgZCdpbWF0Z2UuIFBlciBmZXItaG8sIHMnaW52ZXJ0ZWl4ZW4gbGVzIGVxdWFjaW9ucyBkZSBndWFueS4gTGEgc2Vnb25hIGNvcnJlY2Npw7MgdMOpIGEgdmV1cmUgYW1iIGxlcyBkaWZlcsOobmNpZXMgZW4gbCdhbmdsZSBpIGxhIGJyaWxsYW50b3IgZGVsIHNvbC4gRWxzIHZhbG9ycyBkZSBicmlsbGFudG9yIG9yaWdpbmFscyBzJ2FqdXN0ZW4gYSB1bmEgY29uZGljacOzIGQnaWzCt2x1bWluYWNpw7MgY29tdW5hIG1pdGphbsOnYW50IGxhIG5vcm1hbGl0emFjacOzIGRlIGxlcyBlc2NlbmVzIGNhcHR1cmFkZXMgZW4gY29uZGljaW9ucyBkJ2lswrdsdW1pbmFjacOzIHZhcmlhYmxlcy4gRW4gZ2VuZXJhbCwgdG90IGkgcXVlIGVsIHRpcHVzIGRlIGRhZGVzIGQnaW1hdGdlIGRlIHNvcnRpZGEgw6lzIGVsIG1hdGVpeCBxdWUgZWwgZCdlbnRyYWRhLCBlbHMgdmFsb3JzIGRlIHNvcnRpZGEgc8OzbiBtw6lzIGJhaXhvcyBxdWUgZWxzIGQnZW50cmFkYSBpIGVzIHJldGFsbGVuIHBlciBhanVzdGFyLWxvcyBhIGwnaW50ZXJ2YWwgZGUgZGFkZXMgdsOgbGlkLjwvZGl2PlwiLFxuXHRcdGFyZ1N0YXRpc3RpY3NOYW1lOiBcIkFyZ1N0YXRpc3RpY3NcIixcblx0XHRhcmdTdGF0aXN0aWNzU25pcDogXCJDYWxjdWxhIGxlcyBlc3RhZMOtc3RpcXVlcyBhcmcsIHF1ZSBpbmNsb3VlbiBBcmcgTWF4LCBBcmcgTWluLCBBcmcgTWVkaWFuIGkgRHVyYXRpb24uXCIsXG5cdFx0YXJnU3RhdGlzdGljc0Rlc2M6IFwiTGEgZnVuY2nDsyBjYWxjdWxhIGxlcyBlc3RhZMOtc3RpcXVlcyBhcmcuIExhIGZ1bmNpw7MgQXJnU3RhdGlzdGljcyBwcmVzZW50YSBxdWF0cmUgbcOodG9kZXM6IEFyZ01heCwgQXJnTWluLCBBcmdNZWRpYW4gaSBEdXJhdGlvbi5cIixcblx0XHRhcml0aG1ldGljTmFtZTogXCJBcml0bcOodGljXCIsXG5cdFx0YXJpdGhtZXRpY1NuaXA6IFwiUmVhbGl0emEgdW5hIG9wZXJhY2nDsyBhcml0bcOodGljYSBlbnRyZSBkb3MgcsOgc3RlcnMgbyB1biByw6BzdGVyIGkgdW4gZXNjYWxhci5cIixcblx0XHRhcml0aG1ldGljRGVzYzogXCJMYSBmdW5jacOzIGFyaXRtw6h0aWNhIHJlYWxpdHphIHVuYSBvcGVyYWNpw7MgYXJpdG3DqHRpY2EgZW50cmUgZG9zIHLDoHN0ZXJzIG8gdW4gcsOgc3RlciBpIHVuIGVzY2FsYXIgaSB2aWNldmVyc2EuXCIsXG5cdFx0YXNwZWN0U2xvcGVOYW1lOiBcIk9yaWVudGFjacOzLXBlbmRlbnRcIixcblx0XHRhc3BlY3RTbG9wZVNuaXA6IFwiQ3JlYSB1biByw6BzdGVyIHF1ZSBtb3N0cmEgc2ltdWx0w6BuaWFtZW50IGwnb3JpZW50YWNpw7MgKGRpcmVjY2nDsykgaSBlbCBwZW5kZW50IChpbmNsaW5hY2nDsykgZCd1bmEgc3VwZXJmw61jaWUgY29udMOtbnVhLCB0YWwgY29tIGVzIHJlcHJlc2VudGEgZW4gdW4gbW9kZWwgZCdlbGV2YWNpw7MgZGlnaXRhbC5cIixcblx0XHRhc3BlY3RTbG9wZURlc2M6IFwiTGEgZnVuY2nDsyBPcmllbnRhY2nDsy1wZW5kZW50IGNyZWEgdW5hIGNhcGEgZGUgcsOgc3RlciBxdWUgbW9zdHJhIHNpbXVsdMOgbmlhbWVudCBsJ29yaWVudGFjacOzIGkgZWwgcGVuZGVudCBkJ3VuYSBzdXBlcmbDrWNpZS4gTCdvcmllbnRhY2nDsyBpZGVudGlmaWNhIGxhIGRpcmVjY2nDsyBkZXNjZW5kZW50IGRlIGxhIHZlbG9jaXRhdCBtw6B4aW1hIGRlIGNhbnZpIGRlbCB2YWxvciBkZXMgZGUgY2FkYSBww614ZWwgYWxzIHDDrXhlbHMgdmXDr25zLiBMJ29yaWVudGFjacOzIGVzIHBvdCBjb25zaWRlcmFyIGxhIGRpcmVjY2nDsyBkZWwgcGVuZGVudC4gRWxzIHZhbG9ycyBkZWwgcsOgc3RlciBkZSBzb3J0aWRhIHNlcmFuIGxhIGRpcmVjY2nDsyBkZSBicsO6aXhvbGEgZGUgbCdvcmllbnRhY2nDsywgcmVwcmVzZW50YWRhIGFtYiB1biB0byAoY29sb3IpLiBFbCBwZW5kZW50IHJlcHJlc2VudGEgbCfDrW5kZXggZGUgY2FudmkgZCdlbGV2YWNpw7MgZGUgY2FkYSBww614ZWwgZGVsIG1vZGVsIGQnZWxldmFjacOzIGRpZ2l0YWwgKERFTSkuIEVsIHBlbmRlbnQgcmVwcmVzZW50YSBsYSBpbmNsaW5hY2nDsyBkZSBsYSBzdXBlcmbDrWNpZSBpIHNlIHNpbWJvbGl0emEgZW4gdHJlcyBjbGFzc2VzIHF1ZSBlcyBtb3N0cmVuIG1pdGphbsOnYW50IGxhIHNhdHVyYWNpw7MgZGVsIGNvbG9yIChicmlsbGFudG9yKS48ZGl2Pjxici8+RWxzIHZhbG9ycyBkZSBww614ZWwgZGVsIHLDoHN0ZXIgZCdvcmllbnRhY2nDsy1wZW5kZW50IGRlIHNvcnRpZGEgcmVmbGVjdGVpeGVuIHVuYSBjb21iaW5hY2nDsyBkJ29yaWVudGFjacOzIGkgcGVuZGVudC4gRWxzIHDDrXhlbHMgYW1iIHZhbG9ycyBpbmZlcmlvcnMgYSAyMCBlcyBjb25zaWRlcmVuIHBsYW5zIGkgZXMgbW9zdHJlbiBncmlzb3MuIEVscyB2YWxvcnMgZCdvcmllbnRhY2nDsy1wZW5kZW50IGRlIDIxIGkgc3VwZXJpb3JzIGVzIG1vc3RyYXJhbiBhbWIgc2F0dXJhY2lvbnMgdmFyaWFibGVzIGRlIGxhIG1hbmVyYSBzZWfDvGVudDogZGUgMjEgYSAzMCwgc2F0dXJhY2nDsyBkZSBwZW5kZW50IGJhaXg7IGRlIDMxIGEgNDAsIHNhdHVyYWNpw7MgZGUgcGVuZGVudCBtb2RlcmF0OyA0MSBpIHN1cGVyaW9ycywgc2F0dXJhY2nDsyBkZSBwZW5kZW50IGFsdDwvZGl2PlwiLFxuXHRcdGFzcGVjdE5hbWU6IFwiT3JpZW50YWNpw7NcIixcblx0XHRhc3BlY3RTbmlwOiBcIk1vc3RyYSBxdWluYSBkaXJlY2Npw7Mgc2VndWVpeCB1biBww614ZWwsIG9uIDAgZmEgcmVmZXLDqG5jaWEgYWwgbm9yZCBpIGVscyBhbmdsZXMgYXVnbWVudGVuIGVuIGVsIHNlbnRpdCBkZSBsZXMgYWd1bGxlcyBkZWwgcmVsbG90Z2UgZmlucyBhIDM2MC5cIixcblx0XHRhc3BlY3REZXNjOiBcIkxhIGZ1bmNpw7MgT3JpZW50YWNpw7MgaWRlbnRpZmljYSBsYSBkaXJlY2Npw7MgZGVzY2VuZGVudCBkZSBsYSB2ZWxvY2l0YXQgbcOgeGltYSBkZSBjYW52aSBkZWwgdmFsb3IgZGVzIGRlIGNhZGEgY2VswrdsYSBhIGxlcyBjZWzCt2xlcyB2ZcOvbmVzLiBMJ29yaWVudGFjacOzIGVzIHBvdCBjb25zaWRlcmFyIGxhIGRpcmVjY2nDsyBkZWwgcGVuZGVudC4gRWxzIHZhbG9ycyBkZWwgcsOgc3RlciBkZSBzb3J0aWRhIHNlcmFuIGxhIGRpcmVjY2nDsyBkZSBicsO6aXhvbGEgZGUgbCdvcmllbnRhY2nDsy48ZGl2Pjxici8+TCdlbnRyYWRhIGQnYXF1ZXN0YSBmdW5jacOzIMOpcyBSw6BzdGVyIGQnZW50cmFkYS4gTGEgZnVuY2nDsyBPcmllbnRhY2nDsyBzJ2FwbGljYSBzb3ZpbnQgYSB1biBtb2RlbCBkJ2VsZXZhY2nDsyBkaWdpdGFsIChERU0pLiBQZXIgZGVmZWN0ZSwgbCdvcmllbnRhY2nDsyBlcyBtb3N0cmEgY29tIHVuYSBpbWF0Z2UgZW4gZXNjYWxhIGRlIGdyaXNvcy4gUG9kZXUgYWZlZ2lyIGxhIGZ1bmNpw7MgTWFwYSBkZSBjb2xvciBwZXIgZXNwZWNpZmljYXIgdW4gZXNxdWVtYSBkZSBjb2xvcnMgZXNwZWPDrWZpYyBvIHBlcm1ldHJlIHF1ZSBsYSBwZXJzb25hIHF1ZSB2aXN1YWxpdHphIGVsIG1vc2FpYyBtb2RpZmlxdWkgbGEgc2ltYm9sb2dpYSBhbWIgZWwgc2V1IHByb3BpIGVzcXVlbWEgZGUgY29sb3JzLjwvZGl2PlwiLFxuXHRcdHRhYmxlTmFtZTogXCJUYXVsYSBkJ2F0cmlidXRzXCIsXG5cdFx0dGFibGVTbmlwOiBcIlV0aWxpdHphIHVuYSB0YXVsYSBwZXIgYW5vbWVuYXIgaSBzaW1ib2xpdHphciBlbHMgdmFsb3JzIGQndW4gZGF0YXNldC4gTGVzIGNvbHVtbmVzIGRlIGxhIHRhdWxhIGVzdGFuIGRlbGltaXRhZGVzIHBlciBjb21lczogUGl4ZWxWYWx1ZSwgQXR0cmlidXRlTmFtZSwgUmVkVmFsdWUsIEdyZWVuVmFsdWUsIEJsdWVWYWx1ZS5cIixcblx0XHR0YWJsZURlc2M6IFwiTGEgZnVuY2nDsyBUYXVsYSBkJ2F0cmlidXRzIHVzIHBlcm1ldCBkZWZpbmlyIHVuYSB0YXVsYSBkJ2F0cmlidXRzIHBlciBzaW1ib2xpdHphciB1biBkYXRhc2V0IHLDoHN0ZXIgbyB1biBkYXRhc2V0IGRlIG1vc2FpYyBkJ3VuYSBiYW5kYS4gPGRpdj48YnIvPlJlc3VsdGEgw7p0aWwgc2kgdm9sZXUgcHJlc2VudGFyIGltYXRnZXMgcXVlIHMnaGFuIHNvdG3DqHMgYSBjbGFzc2lmaWNhY2nDsyBwZXIgYSDDunMgZGVsIHPDsmwsIGNvbSBhcmEgdGVycmVueSBmb3Jlc3RhbCwgem9uZXMgaHVtaWRlcywgdGVycmVzIGRlIGN1bHRpdSBpIHpvbmVzIHVyYmFuZXMuIFRhbm1hdGVpeCwgc2kgbGEgdGF1bGEgY29udMOpIGNhbXBzIGFub21lbmF0cyB2ZXJtZWxsLCB2ZXJkIGkgYmxhdSwgZWxzIHZhbG9ycyBkJ2FxdWVzdHMgY2FtcHMgcyd1dGlsaXR6YXJhbiBjb20gdW4gbWFwYSBkZSBjb2xvciBxdWFuIGVzIHJlcHJlc2VudGkgbGEgaW1hdGdlLjwvZGl2PlwiLFxuXHRcdGJhbmRBcml0aG1ldGljTmFtZTogXCJBcml0bcOodGljYSBkZSBiYW5kYVwiLFxuXHRcdGJhbmRBcml0aG1ldGljU25pcDogXCJDYWxjdWxhIGVscyDDrW5kZXhzIG1pdGphbsOnYW50IGbDs3JtdWxlcyBwcmVkZWZpbmlkZXMgbyB1bmEgZXhwcmVzc2nDsyBkZWZpbmlkYSBwZXIgbCd1c3VhcmkuXCIsXG5cdFx0YmFuZEFyaXRobWV0aWNEZXNjOiBcIkxhIGZ1bmNpw7MgQXJpdG3DqHRpY2EgZGUgYmFuZGEgcmVhbGl0emEgdW5hIG9wZXJhY2nDsyBhcml0bcOodGljYSBzb2JyZSBsZXMgYmFuZGVzIGQndW4gZGF0YXNldCByw6BzdGVyLiBQb2RldSB0cmlhciBhbGdvcml0bWVzIHByZWRlZmluaXRzIG8gaW50cm9kdWlyIGxhIHZvc3RyYSBwcsOycGlhIGbDs3JtdWxhIGQndW5hIGzDrW5pYS4gRWxzIG9wZXJhZG9ycyBhZG1lc29zIHPDs24gLSwgKywgLywgKiBpIC0gdW5hcmkuXCIsXG5cdFx0dGhyZXNob2xkTmFtZTogXCJEZWZpbmljacOzIGRlIGxsaW5kYXIgYmluYXJpXCIsXG5cdFx0dGhyZXNob2xkU25pcDogXCJPcmdhbml0emEgbGVzIGRhZGVzIGNvbnTDrW51ZXMgZW4gcHJpbWVyIHBsYSBpIGVuIHNlZ29uIHRlcm1lLiBQZXIgZmVyLWhvLCBtaW5pbWl0emEgbGEgY292YXJpw6BuY2lhIGVudHJlIGxlcyBkdWVzIGNsYXNzZXMuXCIsXG5cdFx0dGhyZXNob2xkRGVzYzogXCJRdWFuIHVuIGRhdGFzZXQgcsOgc3RlciB0w6kgdW5hIGRpc3RyaWJ1Y2nDsyBiaW1vZGFsLCBhcXVlc3RhIGZ1bmNpw7MgY3JlYSB1biByw6BzdGVyIG5vdSBxdWUgZGl2aWRlaXggbGVzIGRhZGVzIGVuIGR1ZXMgY2xhc3NlcyBkaWZlcmVudHMuIENyZWEgdW5hIGNsYXNzZSBkZSB2YWxvcnMgYmFpeG9zIHF1ZSBlcyBtb3N0cmEgYW1iIHDDrXhlbHMgbmVncmVzIGkgdW5hIGNsYXNzZSBkZSB2YWxvcnMgYWx0cyBxdWUgZXMgbW9zdHJhIGFtYiBww614ZWxzIGJsYW5jcy5cIixcblx0XHRiaXR3aXNlQW5kTmFtZTogXCJCaXR3aXNlIEFuZFwiLFxuXHRcdGJpdHdpc2VBbmRTbmlwOiBcIlJlYWxpdHphIHVuYSBvcGVyYWNpw7MgQml0d2lzZSBBbmQgYWxzIHZhbG9ycyBiaW5hcmlzIGRlbHMgZG9zIHLDoHN0ZXJzIGQnZW50cmFkYS5cIixcblx0XHRiaXR3aXNlQW5kRGVzYzogXCJCaXR3aXNlIEFuZCByZWFsaXR6YSB1bmEgb3BlcmFjacOzIEJpdHdpc2UgQW5kIGFscyB2YWxvcnMgYmluYXJpcyBkZWxzIGRvcyByw6BzdGVycyBkJ2VudHJhZGFcIixcblx0XHRiaXR3aXNlTGVmdFNoaWZ0TmFtZTogXCJCaXR3aXNlIExlZnQgU2hpZnRcIixcblx0XHRiaXR3aXNlTGVmdFNoaWZ0U25pcDogXCJSZWFsaXR6YSB1bmEgb3BlcmFjacOzIEJpdHdpc2UgTGVmdCBTaGlmdCBhbHMgdmFsb3JzIGJpbmFyaXMgZGVscyBkb3MgcsOgc3RlcnMgZCdlbnRyYWRhLlwiLFxuXHRcdGJpdHdpc2VMZWZ0U2hpZnREZXNjOiBcIkJpdHdpc2UgTGVmdCBTaGlmdCByZWFsaXR6YSB1bmEgb3BlcmFjacOzIEJpdHdpc2UgTGVmdCBTaGlmdCBhbHMgdmFsb3JzIGJpbmFyaXMgZGVscyBkb3MgcsOgc3RlcnMgZCdlbnRyYWRhXCIsXG5cdFx0Yml0d2lzZU5vdE5hbWU6IFwiQml0d2lzZSBOb3RcIixcblx0XHRiaXR3aXNlTm90U25pcDogXCJSZWFsaXR6YSB1bmEgb3BlcmFjacOzIEJpdHdpc2UgTm90IChjb21wbGVtZW50KSBhbHMgdmFsb3JzIGJpbmFyaXMgZGVscyBkb3MgcsOgc3RlcnMgZCdlbnRyYWRhLlwiLFxuXHRcdGJpdHdpc2VOb3REZXNjOiBcIkxhIGZ1bmNpw7MgcmVhbGl0emEgdW5hIG9wZXJhY2nDsyBCaXR3aXNlIE5vdCAoY29tcGxlbWVudCkgYWwgdmFsb3IgYmluYXJpIGQndW4gcsOgc3RlciBkJ2VudHJhZGEuXCIsXG5cdFx0Yml0d2lzZU9yTmFtZTogXCJCaXR3aXNlIE9yXCIsXG5cdFx0Yml0d2lzZU9yU25pcDogXCJSZWFsaXR6YSB1bmEgb3BlcmFjacOzIEJpdHdpc2UgT3IgYWxzIHZhbG9ycyBiaW5hcmlzIGRlbHMgZG9zIHLDoHN0ZXJzIGQnZW50cmFkYS5cIixcblx0XHRiaXR3aXNlT3JEZXNjOiBcIkxhIGZ1bmNpw7MgcmVhbGl0emEgdW5hIG9wZXJhY2nDsyBCaXR3aXNlIE9yIGFscyB2YWxvcnMgYmluYXJpcyBkZWxzIGRvcyByw6BzdGVycyBkJ2VudHJhZGEuIFwiLFxuXHRcdGJpdHdpc2VSaWdodFNoaWZ0TmFtZTogXCJCaXR3aXNlIFJpZ2h0IFNoaWZ0XCIsXG5cdFx0Yml0d2lzZVJpZ2h0U2hpZnRTbmlwOiBcIlJlYWxpdHphIHVuYSBvcGVyYWNpw7MgQml0d2lzZSBSaWdodCBTaGlmdCBhbHMgdmFsb3JzIGJpbmFyaXMgZGVscyBkb3MgcsOgc3RlcnMgZCdlbnRyYWRhLlwiLFxuXHRcdGJpdHdpc2VSaWdodFNoaWZ0RGVzYzogXCJMYSBmdW5jacOzIHJlYWxpdHphIHVuYSBvcGVyYWNpw7MgQml0d2lzZSBSaWdodCBTaGlmdCBhbHMgdmFsb3JzIGJpbmFyaXMgZGVscyBkb3MgcsOgc3RlcnMgZCdlbnRyYWRhLlwiLFxuXHRcdGJpdHdpc2VYb3JOYW1lOiBcIkJpdHdpc2UgWG9yXCIsXG5cdFx0Yml0d2lzZVhvclNuaXA6IFwiUmVhbGl0emEgdW5hIG9wZXJhY2nDsyBCaXR3aXNlIGVYY2x1c2l2ZSBPciBhbHMgdmFsb3JzIGJpbmFyaXMgZGVscyBkb3MgcsOgc3RlcnMgZCdlbnRyYWRhLlwiLFxuXHRcdGJpdHdpc2VYb3JEZXNjOiBcIkxhIGZ1bmNpw7MgcmVhbGl0emEgdW5hIG9wZXJhY2nDsyBCaXR3aXNlIGVYY2x1c2l2ZSBPciBhbHMgdmFsb3JzIGJpbmFyaXMgZGVscyBkb3MgcsOgc3RlcnMgZCdlbnRyYWRhXCIsXG5cdFx0Ym9vbGVhbkFuZE5hbWU6IFwiQm9vbGVhbmEgQW5kXCIsXG5cdFx0Ym9vbGVhbkFuZFNuaXA6IFwiUmVhbGl0emEgdW5hIG9wZXJhY2nDsyBCb29sZWFuYSBBbmQgYWxzIHZhbG9ycyBkZSBjZWzCt2xhIGRlbHMgZG9zIHLDoHN0ZXJzIGQnZW50cmFkYS4gU2kgYW1iZMOzcyB2YWxvcnMgZCdlbnRyYWRhIHPDs24gY2VydHMgKG5vIHplcm8pLCBlbCB2YWxvciBkZSBzb3J0aWRhIMOpcyAxLiBTaSB1bmEgZGUgbGVzIGVudHJhZGVzIG8gdG90ZXMgZHVlcyBzw7NuIGZhbHNlcyAoemVybyksIGVsIHZhbG9yIGRlIHNvcnRpZGEgw6lzIDAuXCIsXG5cdFx0Ym9vbGVhbkFuZERlc2M6IFwiTGEgZnVuY2nDsyByZWFsaXR6YSB1bmEgb3BlcmFjacOzIEJvb2xlYW5hIEFuZCBhbHMgdmFsb3JzIGRlIHDDrXhlbCBkZSBsZXMgZHVlcyBlbnRyYWRlcy4gU2kgYW1iZMOzcyB2YWxvcnMgZCdlbnRyYWRhIHPDs24gY2VydHMgKG5vIHplcm8pLCBlbCB2YWxvciBkZSBzb3J0aWRhIMOpcyAxLiBTaSB1biBkZWxzIHZhbG9ycyBkJ2VudHJhZGEgbyB0b3RzIGRvcyBzw7NuIGZhbHNvcyAoemVybyksIGVsIHZhbG9yIGRlIHNvcnRpZGEgw6lzIDAuIFwiLFxuXHRcdGJvb2xlYW5Ob3ROYW1lOiBcIkJvb2xlYW5hIE5vdFwiLFxuXHRcdGJvb2xlYW5Ob3RTbmlwOiBcIlJlYWxpdHphIHVuYSBvcGVyYWNpw7MgQm9vbGVhbmEgTm90IChjb21wbGVtZW50KSBhbHMgdmFsb3JzIGRlIGNlbMK3bGEgZGVsIHLDoHN0ZXIgZCdlbnRyYWRhLiBTaSBlbHMgdmFsb3JzIGQnZW50cmFkYSBzw7NuIGNlcnRzIChubyB6ZXJvKSwgZWwgdmFsb3IgZGUgc29ydGlkYSDDqXMgMC4gU2kgZWxzIHZhbG9ycyBkJ2VudHJhZGEgc8OzbiBmYWxzb3MgKHplcm8pLCBsYSBzb3J0aWRhIMOpcyAxLlwiLFxuXHRcdGJvb2xlYW5Ob3REZXNjOiBcIkxhIGZ1bmNpw7MgcmVhbGl0emEgdW5hIG9wZXJhY2nDsyBCb29sZWFuYSBOb3QgKGNvbXBsZW1lbnQpIGFscyB2YWxvcnMgZGUgcMOteGVsIGRlbCByw6BzdGVyIGQnZW50cmFkYS4gU2kgZWxzIHZhbG9ycyBkJ2VudHJhZGEgc8OzbiBjZXJ0cyAobm8gemVybyksIGVsIHZhbG9yIGRlIHNvcnRpZGEgw6lzIDAuIFNpIGVscyB2YWxvcnMgZCdlbnRyYWRhIHPDs24gZmFsc29zICh6ZXJvKSwgZWwgdmFsb3IgZGUgc29ydGlkYSDDqXMgMS5cIixcblx0XHRib29sZWFuT3JOYW1lOiBcIkJvb2xlYW5hIE9yXCIsXG5cdFx0Ym9vbGVhbk9yU25pcDogXCJSZWFsaXR6YSB1bmEgb3BlcmFjacOzIEJvb2xlYW5hIE9yIGFscyB2YWxvcnMgZGUgY2VswrdsYSBkZWxzIGRvcyByw6BzdGVycyBkJ2VudHJhZGEuIFNpIHVuIGRlbHMgdmFsb3JzIGQnZW50cmFkYSBvIHRvdHMgZG9zIHPDs24gY2VydHMgKG5vIHplcm8pLCBlbCB2YWxvciBkZSBzb3J0aWRhIMOpcyAxLiBTaSBhbWJkw7NzIHZhbG9ycyBkJ2VudHJhZGEgc8OzbiBmYWxzb3MgKHplcm8pLCBsYSBzb3J0aWRhIMOpcyAwLlwiLFxuXHRcdGJvb2xlYW5PckRlc2M6IFwiTGEgZnVuY2nDsyByZWFsaXR6YSB1bmEgb3BlcmFjacOzIEJvb2xlYW5hIE9yIGFscyB2YWxvcnMgZGUgY2VswrdsYSBkZWxzIGRvcyByw6BzdGVycyBkJ2VudHJhZGEuIFNpIHVuIGRlbHMgdmFsb3JzIGQnZW50cmFkYSBvIHRvdHMgZG9zIHPDs24gY2VydHMgKG5vIHplcm8pLCBlbCB2YWxvciBkZSBzb3J0aWRhIMOpcyAxLiBTaSBhbWJkw7NzIHZhbG9ycyBkJ2VudHJhZGEgc8OzbiBmYWxzb3MgKHplcm8pLCBlbCB2YWxvciBkZSBzb3J0aWRhIMOpcyAwLlwiLFxuXHRcdGJvb2xlYW5Yb3JOYW1lOiBcIkJvb2xlYW5hIFhvclwiLFxuXHRcdGJvb2xlYW5Yb3JTbmlwOiBcIlJlYWxpdHphIHVuYSBvcGVyYWNpw7MgQm9vbGVhbmEgZVhjbHVzaXZlIE9yIGFscyB2YWxvcnMgZGUgY2VswrdsYSBkZWxzIGRvcyByw6BzdGVycyBkJ2VudHJhZGEuIFNpIHVuIGRlbHMgdmFsb3JzIGQnZW50cmFkYSDDqXMgY2VydCAobm8gemVybykgaSBsJ2FsdHJlIMOpcyBmYWxzICh6ZXJvKSwgbGEgc29ydGlkYSDDqXMgMS4gU2kgYW1iZMOzcyB2YWxvcnMgZCdlbnRyYWRhIHPDs24gY2VydHMgbyBhbWJkw7NzIHPDs24gZmFsc29zLCBsYSBzb3J0aWRhIMOpcyAwLlwiLFxuXHRcdGJvb2xlYW5Yb3JEZXNjOiBcIkxhIGZ1bmNpw7MgcmVhbGl0emEgdW5hIG9wZXJhY2nDsyBCb29sZWFuYSBlWGNsdXNpdmUgT3IgYWxzIHZhbG9ycyBkZSBjZWzCt2xhIGRlbHMgZG9zIHLDoHN0ZXJzIGQnZW50cmFkYS4gU2kgdW4gZGVscyB2YWxvcnMgZCdlbnRyYWRhIMOpcyBjZXJ0IChubyB6ZXJvKSBpIGwnYWx0cmUgw6lzIGZhbHMgKHplcm8pLCBlbCB2YWxvciBkZSBzb3J0aWRhIMOpcyAxLiBTaSBhbWJkw7NzIHZhbG9ycyBkJ2VudHJhZGEgc8OzbiBjZXJ0cyBvIGFtYmTDs3Mgc8OzbiBmYWxzb3MsIGVsIHZhbG9yIGRlIHNvcnRpZGEgw6lzIDAuXCIsXG5cdFx0YnVmZmVyZWRSYXN0ZXJOYW1lOiBcIkVuIMOgcmVhIGQnaW5mbHXDqG5jaWFcIixcblx0XHRidWZmZXJlZFJhc3RlclNuaXA6IFwiQ3JlYSDDoHJlZXMgZCdpbmZsdcOobmNpYSBkZWxzIMO6bHRpbXMgYmxvY3MgcXVlIHDDrXhlbHMgYWxzIHF1YWxzIHMnaGEgYWNjZWRpdC5cIixcblx0XHRidWZmZXJlZFJhc3RlckRlc2M6IFwiTGEgZnVuY2nDsyBFbiDDoHJlYSBkJ2luZmx1w6huY2lhIHMndXRpbGl0emEgcGVyIG9wdGltaXR6YXIgZWwgcmVuZGltZW50IGRlIGxlcyBjYWRlbmVzIGRlIGZ1bmNpb25zIGNvbXBsZXhlcy4gRW1tYWdhdHplbWEgbGEgc29ydGlkYSBhIGxhIG1lbcOycmlhIGRlIGxhIHBhcnQgZGUgbGEgY2FkZW5hIGRlIGZ1bmNpb25zIHF1ZSBsYSBwcmVjZWRlaXguIDxkaXY+PGJyLz5JbnNlcml1IGFxdWVzdGEgZnVuY2nDsyBhIGwnRWRpdG9yIGRlIGZ1bmNpw7Mgb24gdm9sZXUgZW1tYWdhdHplbWFyIGxhIHNvcnRpZGEuPC9kaXY+XCIsXG5cdFx0cmFzdGVyQ2FsY3VsYXRvck5hbWU6IFwiQ2FsY3VsYWRvcmFcIixcblx0XHRyYXN0ZXJDYWxjdWxhdG9yU25pcDogXCJDYWxjdWxhIHVuIHLDoHN0ZXIgYSBwYXJ0aXIgZCd1bmEgZXhwcmVzc2nDsyBtYXRlbcOgdGljYSBiYXNhZGEgZW4gcsOgc3Rlci5cIixcblx0XHRyYXN0ZXJDYWxjdWxhdG9yRGVzYzogXCJMYSBmdW5jacOzIENhbGN1bGFkb3JhIHVzIHBlcm1ldCBjcmVhciBpIGV4ZWN1dGFyIGV4cHJlc3Npb25zIGkgaW5jb3Jwb3Jhci1sZXMgYSBsZXMgY2FkZW5lcyBkZSBmdW5jaW9ucy5cIixcblx0XHRjZWxsU3RhdGlzdGljc05hbWU6IFwiRXN0YWTDrXN0aXF1ZXMgZGUgbGEgY2VswrdsYVwiLFxuXHRcdGNlbGxTdGF0aXN0aWNzU25pcDogXCJDYWxjdWxhIGVzdGFkw61zdGlxdWVzIHBlciBjZWzCt2xhIGRlIGRpdmVyc29zIHLDoHN0ZXJzLiBMZXMgZXN0YWTDrXN0aXF1ZXMgZGlzcG9uaWJsZXMgc8OzbiBNYWpvcmlhLCBNw6B4aW0sIE1pdGphLCBNaXRqYW5hLCBNw61uaW0sIE1pbm9yaWEsIEludGVydmFsLCBEZXN2aWFjacOzIEVzdMOgbmRhcmQsIFN1bWEgaSBWYXJpZXRhdC5cIixcblx0XHRjZWxsU3RhdGlzdGljc0Rlc2M6IFwiQXF1ZXN0YSBmdW5jacOzIGNhbGN1bGEgbGVzIGVzdGFkw61zdGlxdWVzIGEgcGFydGlyIGRlIGRpdmVyc29zIHLDoHN0ZXJzLCBww614ZWwgcGVyIHDDrXhlbC4gTGVzIGVzdGFkw61zdGlxdWVzIGRpc3BvbmlibGVzIHPDs24gbWFqb3JpYSwgbcOgeGltLCBtaXRqYSwgbWl0amFuYSwgbcOtbmltLCBtaW5vcmlhLCBpbnRlcnZhbCwgZGVzdmlhY2nDsyBlc3TDoG5kYXJkLCBzdW1hIGkgdmFyaWV0YXQuXCIsXG5cdFx0Y2xhc3NpZnlOYW1lOiBcIkNsYXNzaWZpY2FcIixcblx0XHRjbGFzc2lmeVNuaXA6IFwiQXNzaWduYSBjYWRhIHDDrXhlbCBhIHVuYSBjbGFzc2UuIEluY29ycG9yZXUgbGVzIGRhZGVzIGF1eGlsaWFycywgY29tIGFyYSB1bmEgaW1hdGdlIHNlZ21lbnRhZGEuXCIsXG5cdFx0Y2xhc3NpZnlEZXNjOiBcIkFxdWVzdGEgZnVuY2nDsyBkZSByw6BzdGVyIGNsYXNzaWZpY2EgdW4gZGF0YXNldCByw6BzdGVyIGVuIGZ1bmNpw7MgZCd1biBmaXR4ZXIgZGUgZGVmaW5pY2nDsyBkZSBjbGFzc2lmaWNhZG9yIGQnRXNyaSAoLmVjZCkgaSBkZSBsZXMgZW50cmFkZXMgZGUgZGF0YXNldCByw6BzdGVyLiBFbCBmaXR4ZXIgLmVjZCB1dGlsaXR6YXQgYSBsYSBmdW5jacOzIENsYXNzaWZpY2EgY29udMOpIHRvdGEgbGEgaW5mb3JtYWNpw7MgZCd1biBkYXRhc2V0IGkgdW4gY2xhc3NpZmljYWRvciBlc3BlY8OtZmljcywgaSBlcyBnZW5lcmEgbWl0amFuw6dhbnQgZWluZXMgZGUgcHJlcGFyYWNpw7MgZGUgY2xhc3NpZmljYWNpw7MsIGNvbSBhcmEgUHJlcGFyYXIgY2xhc3NpZmljYWRvciBkZSBtw6BxdWluYSBkZSB2ZWN0b3JzIGRlIHN1cG9ydCBvIFByZXBhcmFyIGNsYXNzaWZpY2Fkb3IgZCdhcmJyZXMgYWxlYXRvcmlzLlwiLFxuXHRcdGNsaXBOYW1lOiBcIlJldGFsbGFcIixcblx0XHRjbGlwU25pcDogXCJEZWZpbmVpeCBsJ2V4dGVuc2nDsyBkJ3VuIHLDoHN0ZXIgbWl0amFuw6dhbnQgY29vcmRlbmFkZXMgbyB1biBhbHRyZSBkYXRhc2V0LlwiLFxuXHRcdGNsaXBEZXNjOiBcIkFxdWVzdGEgZnVuY2nDsyByZXRhbGxhIHVuIHLDoHN0ZXIgbWl0amFuw6dhbnQgdW5hIGZvcm1hIHJlY3Rhbmd1bGFyIGQnYWNvcmQgYW1iIGxlcyBleHRlbnNpb25zIGRlZmluaWRlcywgbyBiw6kgZWwgcmV0YWxsYSBhbWIgbGEgZm9ybWEgZCd1bmEgY2xhc3NlIGQnZW50aXRhdCBkZSBwb2zDrWdvbiBkJ2VudHJhZGEuIExhIGZvcm1hIHF1ZSBkZWZpbmVpeCBlbCByZXRhbGwgcG90IHJldGFsbGFyIGwnZXh0ZW5zacOzIGRlbCByw6BzdGVyIG8gYsOpIHJldGFsbGFyIHVuYSDDoHJlYSBkaW5zIGRlbCByw6BzdGVyLlwiLFxuXHRcdGNvbG9yc3BhY2VDb252ZXJzaW9uTmFtZTogXCJDb252ZXJzacOzIGRlbCBtb2RlbCBkZSBjb2xvclwiLFxuXHRcdGNvbG9yc3BhY2VDb252ZXJzaW9uU25pcDogXCJDb252ZXJ0ZWl4IHVuIHLDoHN0ZXIgZCdSR0IgYSBIU1YgaSB2aWNldmVyc2EuXCIsXG5cdFx0Y29sb3JzcGFjZUNvbnZlcnNpb25EZXNjOiBcIkxhIGZ1bmNpw7MgQ29udmVyc2nDsyBkZWwgbW9kZWwgZGUgY29sb3IgY29udmVydGVpeCBlbCBtb2RlbCBkZSBjb2xvciBkJ3VuYSBpbWF0Z2UgZGVzIGRlIGwnZXNwYWkgZGUgY29sb3IgZGUgdG8sIHNhdHVyYWNpw7MgaSB2YWxvciAoSFNWKSBhbCBkZSB2ZXJtZWxsLCB2ZXJkIGkgYmxhdSAoUkdCKSBvIHZpY2V2ZXJzYS48ZGl2Pjxici8+QXF1ZXN0YSBmdW5jacOzIGVzIHBvdCB1dGlsaXR6YXIgZW4gdW4gZGF0YXNldCBkZSBtb3NhaWMuPC9kaXY+XCIsXG5cdFx0Y29sb3JtYXBUb1JHQk5hbWU6IFwiTWFwYSBkZSBjb2xvciBhIFJHQlwiLFxuXHRcdGNvbG9ybWFwVG9SR0JTbmlwOiBcIkNvbnZlcnRlaXggdW4gcsOgc3RlciBkJ3VuYSBiYW5kYSBhbWIgdW4gbWFwYSBkZSBjb2xvciBlbiB1biByw6BzdGVyIGRlIHRyZXMgYmFuZGVzICh2ZXJtZWxsYSwgdmVyZGEgaSBibGF2YSkuXCIsXG5cdFx0Y29sb3JtYXBUb1JHQkRlc2M6IFwiQXF1ZXN0YSBmdW5jacOzIGNvbnZlcnRlaXggdW4gcsOgc3RlciBkJ3VuYSBiYW5kYSBhbWIgdW4gbWFwYSBkZSBjb2xvciBlbiB1biByw6BzdGVyIGRlIHRyZXMgYmFuZGVzICh2ZXJtZWxsYSwgdmVyZGEgaSBibGF2YSkuPGRpdj48YnIvPkFxdWVzdGEgZnVuY2nDsyByZXN1bHRhIMO6dGlsIHNpIG5lY2Vzc2l0ZXUgY3JlYXIgdW4gcsOgc3RlciBkZSB0cmVzIGJhbmRlcyBhIHBhcnRpciBkJ3VuIHLDoHN0ZXIgZCd1bmEgYmFuZGEgYW1iIHVuIG1hcGEgZGUgY29sb3IgYXNzb2NpYXQuIEVscyB2YWxvcnMgZGVsIG1hcGEgZGUgY29sb3Igcyd1dGlsaXR6YXJhbiBwZXIgY3JlYXIgY2FkYXNjdW5hIGRlIGxlcyBiYW5kZXMgdmVybWVsbGEsIHZlcmRhIGkgYmxhdmEuIEFxdWVzdGEgZnVuY2nDsyBlcyBwb3QgdXRpbGl0emFyIGVuIHVuIGRhdGFzZXQgZGUgbW9zYWljLjwvZGl2PlwiLFxuXHRcdGNvbG9ybWFwTmFtZTogXCJNYXBhIGRlIGNvbG9yXCIsXG5cdFx0Y29sb3JtYXBTbmlwOiBcIkNhbnZpYSBlbHMgdmFsb3JzIGRlIHDDrXhlbCBwZXIgbW9zdHJhciBsZXMgZGFkZXMgZGUgcsOgc3RlciBjb20gdW5hIGltYXRnZSBlbiBlc2NhbGEgZGUgZ3Jpc29zIG8gdW5hIGltYXRnZSB2ZXJtZWxsYSwgdmVyZGEgaSBibGF2YSAoUkdCKSwgYmFzYWRhIGVuIHVuIG1hcGEgZGUgY29sb3IgbyB1bmEgcmFtcGEgZGUgY29sb3IuXCIsXG5cdFx0Y29sb3JtYXBEZXNjOiBcIkxhIGZ1bmNpw7MgTWFwYSBkZSBjb2xvciDDqXMgdW4gdGlwdXMgZGUgcmVuZGVyaXR6YWRvciBkZSBkYWRlcyBkZSByw6BzdGVyLiBUcmFuc2Zvcm1hIGVscyB2YWxvcnMgZGUgcMOteGVsIHBlciBtb3N0cmFyIGxlcyBkYWRlcyBkZSByw6BzdGVyIGNvbSB1bmEgaW1hdGdlIGVuIGVzY2FsYSBkZSBncmlzb3MgbyB1bmEgaW1hdGdlIGVuIGNvbG9yIFJHQiBiYXNhZGEgZW4gdW4gZXNxdWVtYSBkZSBjb2xvciBvIGVuIGNvbG9ycyBlc3BlY8OtZmljcyBkJ3VuIGZpdHhlciBkZSBtYXBhIGRlIGNvbG9yLiBQb2RldSB1dGlsaXR6YXIgdW4gbWFwYSBkZSBjb2xvciBwZXIgcmVwcmVzZW50YXIgbGVzIGRhZGVzIGFuYWxpdHphZGVzLCBjb20gYXJhIHVuYSBpbWF0Z2UgY2xhc3NpZmljYWRhIG8gcXVhbiB2aXN1YWxpdHpldSB1biBtYXBhIHRvcG9ncsOgZmljIChvIHVuYSBpbWF0Z2UgZCfDrW5kZXggZXNjYW5lamFkYSBlbiBjb2xvcikuPGRpdj48YnIvPkVscyBtYXBlcyBkZSBjb2xvciBjb250ZW5lbiB1biBjb25qdW50IGRlIHZhbG9ycyBhc3NvY2lhdHMgYWxzIGNvbG9ycyBxdWUgcyd1dGlsaXR6ZW4gcGVyIG1vc3RyYXIgdW4gcsOgc3RlciBkJ3VuYSBiYW5kYSBkZSBtYW5lcmEgY29oZXJlbnQgYW1iIGVscyBtYXRlaXhvcyBjb2xvcnMuIENhZGEgdmFsb3IgZGUgcMOteGVsIGVzdMOgIGFzc29jaWF0IGEgdW4gY29sb3IsIGRlZmluaXQgY29tIHVuIGNvbmp1bnQgZGUgdmFsb3JzIFJHQi4gRWxzIG1hcGVzIGRlIGNvbG9yIHBvZGVuIGFkbWV0cmUgcXVhbHNldm9sIHByb2Z1bmRpdGF0IGRlIGJpdHMsIGV4Y2VwdGUgbGEgZGUgcHVudCBmbG90YW50LiBUYW1iw6kgYWRtZXRlbiB2YWxvcnMgcG9zaXRpdXMgaSBuZWdhdGl1cyBpIHBvZGVuIGNvbnRlbmlyIHZhbG9ycyBhc3NpZ25hdHMgZGUgY29sb3JzIHF1ZSBmYWx0aW4uIEVuIHZpc3VhbGl0emFyIHVuIGRhdGFzZXQgYW1iIHVuIG1hcGEgZGUgY29sb3IgcXVlIGNvbnRpbmd1aSB2YWxvcnMgcXVlIGZhbHRlbiwgZWxzIHDDrXhlbHMgYW1iIGFxdWVzdHMgdmFsb3JzIHF1ZSBmYWx0ZW4gbm8gZXMgbW9zdHJhcmFuLjwvZGl2PlwiLFxuXHRcdGNvbXBsZXhOYW1lOiBcIkNvbXBsZXhcIixcblx0XHRjb21wbGV4U25pcDogXCJFeHRyZXUgbGEgbWFnbml0dWQgZGVscyBub21icmVzIGNvbXBsZXhvcy5cIixcblx0XHRjb21wbGV4RGVzYzogXCJBcXVlc3RhIGZ1bmNpw7MgY2FsY3VsYSBsYSBtYWduaXR1ZCBkZWxzIHZhbG9ycyBjb21wbGV4b3MuPGRpdj48YnIvPkFxdWVzdGEgZnVuY2nDsyBzJ3V0aWxpdHphIGhhYml0dWFsbWVudCBhbWIgaW1hdGdlcyBSQURBUiBxdWUgdGVuZW4gdW4gdGlwdXMgZGUgZGFkZXMgY29tcGxleC4gRXMgcG90IHV0aWxpdHphciBlbiB1biBkYXRhc2V0IGRlIG1vc2FpYy48L2Rpdj5cIixcblx0XHRjb21wb3NpdGVCYW5kTmFtZTogXCJCYW5kZXMgY29tcG9zdGVzXCIsXG5cdFx0Y29tcG9zaXRlQmFuZFNuaXA6IFwiQ29tYmluYSBkaXZlcnNvcyBkYXRhc2V0cyBlbiB1biByw6BzdGVyIG11bHRpYmFuZGEuXCIsXG5cdFx0Y29tcG9zaXRlQmFuZERlc2M6IFwiTGEgZnVuY2nDsyBCYW5kZXMgY29tcG9zdGVzIHVzIHBlcm1ldCBjb21iaW5hciByw6BzdGVycyBwZXIgZm9ybWFyIHVuYSBpbWF0Z2UgbXVsdGliYW5kYS5cIixcblx0XHRjb25OYW1lOiBcIkNvbmRpY2lvbmFsXCIsXG5cdFx0Y29uU25pcDogXCJSZWFsaXR6YSB1bmEgb3BlcmFjacOzIElmLCBUaGVuLCBFbHNlIGNvbmRpY2lvbmFsLiBTaSBzJ3V0aWxpdHphIHVuIG9wZXJhZG9yIENvbmRpY2lvbmFsLCBnZW5lcmFsbWVudCBjYWwgcXVlIGR1ZXMgbyBtw6lzIGZ1bmNpb25zIGVzdGlndWluIGVuY2FkZW5hZGVzLCB1bmEgZGUgbGVzIHF1YWxzIGluZGljYSBlbHMgY3JpdGVyaXMgaSBsJ2FsdHJhIMOpcyBsJ29wZXJhZG9yIENvbmRpY2lvbmFsIHF1ZSB1dGlsaXR6YSBlbHMgY3JpdGVyaXMgaSBkaWN0YSBxdWluZXMgaGFuIGRlIHNlciBsZXMgc29ydGlkZXMgY2VydGVzIGkgZmFsc2VzLlwiLFxuXHRcdGNvbkRlc2M6IFwiTGEgZnVuY2nDsyBDb25kaWNpb25hbCBkZWZpbmVpeCBlbHMgcMOteGVscyBkZWwgcsOgc3RlciBkZSBzb3J0aWRhIHNlZ29ucyB1bmEgYXZhbHVhY2nDsyBpZlxcXFxlbHNlIGRlIGNhZGEgcMOteGVsIGQnZW50cmFkYS4gUmV0b3JuYSBlbHMgdmFsb3JzIGRlIHDDrXhlbCBkZWwgcsOgc3RlciBjZXJ0IHNpIGwnYXZhbHVhY2nDsyBjb25kaWNpb25hbCDDqXMgY2VydGEgKDEpLCBvIGLDqSByZXRvcm5hIGVscyB2YWxvcnMgZGUgcMOteGVsIGRlbCByw6BzdGVyIGZhbHMgc2kgbCdhdmFsdWFjacOzIGNvbmRpY2lvbmFsIMOpcyBmYWxzYSAoMCkuIEFxdWVzdCBjcml0ZXJpIGwnZXNwZWNpZmljYSBsYSBzb3J0aWRhIGQndW5hIGZ1bmNpw7MgbWF0ZW3DoHRpY2EgbMOyZ2ljYSwgcXVlIHNlcsOgIGVsIHLDoHN0ZXIgZCdlbnRyYWRhLlwiLFxuXHRcdGNvbnN0YW50TmFtZTogXCJDb25zdGFudFwiLFxuXHRcdGNvbnN0YW50U25pcDogXCJDcmVhIHVuIHLDoHN0ZXIgdmlydHVhbCBhbWIgdW4gc29sIHZhbG9yIGRlIHDDrXhlbC5cIixcblx0XHRjb25zdGFudERlc2M6IFwiQXF1ZXN0YSBmdW5jacOzIGNyZWEgdW4gcsOgc3RlciB2aXJ0dWFsIGFtYiB1biBzb2wgdmFsb3IgZGUgcMOteGVsIHF1ZSBlcyBwb3QgdXRpbGl0emFyIGVuIHBsYW50aWxsZXMgZGUgZnVuY2nDsyBkZSByw6BzdGVyIGkgcGVyIHByb2Nlc3NhciB1biBkYXRhc2V0IGRlIG1vc2FpYy48ZGl2Pjxici8+RWwgdmFsb3IgY29uc3RhbnQgcyd1dGlsaXR6YSBwZXIgYSBjYWRhIHZhbG9yIGRlIHDDrXhlbCBkZWwgcsOgc3Rlci48L2Rpdj5cIixcblx0XHRjb250b3VyTmFtZTogXCJDb3JiYSBkZSBuaXZlbGxcIixcblx0XHRjb250b3VyU25pcDogXCJDcmVhIGzDrW5pZXMgZGUgY29yYmEgZGUgbml2ZWxsLlwiLFxuXHRcdGNvbnRvdXJEZXNjOiBcIkxhIGZ1bmNpw7MgQ29yYmEgZGUgbml2ZWxsIGdlbmVyYSBsw61uaWVzIGRlIGNvcmJhIGRlIG5pdmVsbCBtaXRqYW7Dp2FudCBsYSB1bmnDsyBkZSBwdW50cyBhbWIgbGEgbWF0ZWl4YSBlbGV2YWNpw7MgZCd1biBkYXRhc2V0IGQnZWxldmFjacOzIGRlIHLDoHN0ZXIuIExlcyBjb3JiZXMgZGUgbml2ZWxsIHPDs24gaXNvbMOtbmllcyBjcmVhZGVzIGNvbSByw6BzdGVycyBwZXIgYSBsYSB2aXN1YWxpdHphY2nDsy4gTGVzIHNlZ8O8ZW50cyBjYXJhY3RlcsOtc3RpcXVlcyBjbGF1IGZhbiBxdWUgYXF1ZXN0YSBmdW5jacOzIHNpZ3VpIG1vbHQgZWZpY2HDpzogbGVzIGNvcmJlcyBkZSBuaXZlbGwgZXMgZ2VuZXJlbiBkZSBtYW5lcmEgcsOgcGlkYSBpIGRpbsOgbWljYSBlbiBkYXRhc2V0cyBtb2x0IGdyYW5zLCBjb20gYXJhIFdvcmxkIEVsZXZhdGlvbjsgbGVzIGNvcmJlcyBkZSBuaXZlbGwgZXMgcG9kZW4gc3Vhdml0emFyIHBlciBwcm9wb3JjaW9uYXIgdW5hIGFwYXJlbsOnYSBjYXJ0b2dyw6BmaWNhbWVudCBtw6lzIGFncmFkYWJsZSBpLCBhbGhvcmEsIG1hbnRlbmlyLW5lIGxhIHByZWNpc2nDszsgZXMgcHJvcG9yY2lvbmEgY29udHJvbCBkaW7DoG1pYyBzb2JyZSBsJ2ludGVydmFsIGRlIGNvcmJlcyBkZSBuaXZlbGw7IGxlcyBvcGNpb25zIGRlIHNvcnRpZGEgaW5jbG91ZW4gbMOtbmllcyBkZSBjb3JiZXMgZGUgbml2ZWxsLCBjb3JiZXMgZGUgbml2ZWxsIG1lc3RyZXMgaSBjb3JiZXMgZGUgbml2ZWxsIHBsZW5lcy48ZGl2Pjxici8+TGEgY3JlYWNpw7MgZCd1bmEgY2FwYSBkZSBjb3JiYSBkZSBuaXZlbGwgY29tIHVuIHByb2R1Y3RlIHLDoHN0ZXIgcmVzdWx0YSDDunRpbCBwZXIgYSB1bmEgZ3JhbiB2YXJpZXRhdCBkJ2FwbGljYWNpb25zLCBqYSBxdWUgbGVzIGNvcmJlcyBkZSBuaXZlbGwgZXMgcG9kZW4gc3VwZXJwb3NhciBlbiB1biBtYXBhIGkgcHJvcG9yY2lvbmVuIGluZm9ybWFjacOzIHNvYnJlIGVsIHRlcnJlbnkgc2Vuc2UgYW1hZ2FyIGxlcyBkYWRlcyBzdWJqYWNlbnRzLiBSZXN1bHRlbiDDunRpbHMgZW4gYXBsaWNhY2lvbnMsIGNvbSBhcmEgZCdlbmdpbnllcmlhLCBhZ3JpY3VsdHVyYSBpIGdlc3Rpw7MgZGUgcmVjdXJzb3MgaMOtZHJpY3MuPC9kaXY+XCIsXG5cdFx0Y29udHJhc3RCcmlnaHRuZXNzTmFtZTogXCJDb250cmFzdCBpIGJyaWxsYW50b3JcIixcblx0XHRjb250cmFzdEJyaWdodG5lc3NTbmlwOiBcIkFqdXN0YSBlbCBjb250cmFzdCBpIGxhIGJyaWxsYW50b3IgZCd1biByw6BzdGVyLlwiLFxuXHRcdGNvbnRyYXN0QnJpZ2h0bmVzc0Rlc2M6IFwiTGEgZnVuY2nDsyBDb250cmFzdCBpIGJyaWxsYW50b3IgbWlsbG9yYSBsJ2FwYXJlbsOnYSBkZSBsZXMgZGFkZXMgZGUgcsOgc3RlciBtaXRqYW7Dp2FudCBsYSBtb2RpZmljYWNpw7MgZGUgbGEgYnJpbGxhbnRvciBpIGVsIGNvbnRyYXN0IGEgbGEgaW1hdGdlLiBMYSBicmlsbGFudG9yIGF1Z21lbnRhIGxhIGlswrdsdW1pbmFjacOzIGdlbmVyYWwgZGUgbGEgaW1hdGdlIChwZXIgZXhlbXBsZSwgYWNsYXJlaXggZWxzIGNvbG9ycyBmb3Njb3MgaSBmYSBxdWUgZWxzIGNvbG9ycyBjbGFycyBzaWd1aW4gbcOpcyBibGFuY3MpLCBtZW50cmUgcXVlIGVsIGNvbnRyYXN0IGFqdXN0YSBsYSBkaWZlcsOobmNpYSBlbnRyZSBlbHMgY29sb3JzIG3DqXMgZm9zY29zIGkgbcOpcyBjbGFycy48ZGl2Pjxici8+TGEgdXRpbGl0emFjacOzIGQnYXF1ZXN0YSBmdW5jacOzIGFsdGVyYSBlbHMgdmFsb3JzIGRlIHDDrXhlbDsgcGVyIHRhbnQsIGFxdWVzdGEgZnVuY2nDsyBzJ2hhIGQndXRpbGl0emFyIHF1YW4gZXMgdm9sIG1pbGxvcmFyIGwnYXBhcmVuw6dhIGRlIGxlcyBkYWRlcywgcGVyw7Igbm8gc2kgbGEgaW50ZW5jacOzIMOpcyB1dGlsaXR6YXIgbGVzIGRhZGVzIGNvbSBhIHBhcnQgZCd1bmEgYW7DoGxpc2kgcXVlIGV4aWdpcmlhIHZhbG9ycyBkZSBww614ZWwgc2Vuc2UgcHJvY2Vzc2FyLiBBcXVlc3RhIGZ1bmNpw7MgcmVzdWx0YSDDunRpbCBxdWFuIGVzIHB1YmxpcXVlbiBsZXMgZGFkZXMgY29tIHVuIHNlcnZlaSBkJ2ltYXRnZXMgcXVlIGVzIHBvdCB1dGlsaXR6YXIgZW4gYXBsaWNhY2lvbnMgc2Vuc2UgbGEgY2FwYWNpdGF0IGQnYWx0ZXJhciBlbCBjb250cmFzdCBpIGxhIGJyaWxsYW50b3IgZGUgbGVzIGltYXRnZXMsIG8gZGUgZ2FyYW50aXIgbGEgdmlzdWFsaXR6YWNpw7MgYW1iIGxhIHZvc3RyYSBjb25maWd1cmFjacOzIHByZWZlcmlkYS48L2Rpdj5cIixcblx0XHRjb252b2x1dGlvbk5hbWU6IFwiQ29udm9sdWNpw7NcIixcblx0XHRjb252b2x1dGlvblNuaXA6IFwiQXBsaWNhIHVuIGZpbHRyZSBwZXIgZW5mb2NhciwgZGlmdW1pbmFyLCBkZXRlY3RhciB2b3JlcyBvIHN1YXZpdHphciBsYSBpbWF0Z2UsIG8gYsOpIHVuIGdyYWRpZW50IGVuIHVuIHLDoHN0ZXIuXCIsXG5cdFx0Y29udm9sdXRpb25EZXNjOiBcIkxhIGZ1bmNpw7MgQ29udm9sdWNpw7MgcmVhbGl0emEgZWwgZmlsdHJhdGdlIGFscyB2YWxvcnMgZGUgcMOteGVsIGQndW5hIGltYXRnZSwgcXVlIGVzIHBvdCB1dGlsaXR6YXIgcGVyIGVuZm9jYXIgbyBkaWZ1bWluYXIgdW5hIGltYXRnZSwgZGV0ZWN0YXIgbGVzIHZvcmVzIGQndW5hIGltYXRnZSBvIGFsdHJlcyBtaWxsb3JlcyBiYXNhZGVzIGVuIGVsIG51Y2xpLiBFbHMgZmlsdHJlcyBzJ3V0aWxpdHplbiBwZXIgbWlsbG9yYXIgbGEgcXVhbGl0YXQgZGUgbGEgaW1hdGdlIGRlIHLDoHN0ZXIuIFBlciBhY29uc2VndWlyLWhvIGVsaW1pbmEgbGVzIGRhZGVzIGZhbHNlcyBvIG1pbGxvcmEgbGVzIGNhcmFjdGVyw61zdGlxdWVzIGRlIGxlcyBkYWRlcy4gQXF1ZXN0cyBmaWx0cmVzIGRlIGNvbnZvbHVjacOzIHMnYXBsaXF1ZW4gZW4gdW4gbnVjbGkgbcOyYmlsIHN1cGVycG9zYXQgKGZpbmVzdHJhIG8gdmXDr25hdCksIGNvbSBhcmEgMyBwZXIgMy4gRWxzIGZpbHRyZXMgZGUgY29udm9sdWNpw7MgZnVuY2lvbmVuIGNhbGN1bGFudCBlbCB2YWxvciBkZSBww614ZWwgZW4gZnVuY2nDsyBkZSBsYSBwb25kZXJhY2nDsyBkZWxzIHNldXMgdmXDr25zLlwiLFxuXHRcdGNvcnJpZG9yTmFtZTogXCJDb3JyZWRvclwiLFxuXHRcdGNvcnJpZG9yU25pcDogXCJDYWxjdWxhIGxhIHN1bWEgZGVscyBjb3N0b3MgYWN1bXVsYXRpdXMgZGUgZG9zIHLDoHN0ZXJzIGFjdW11bGF0aXVzIGQnZW50cmFkYS5cIixcblx0XHRjb3JyaWRvckRlc2M6IFwiTGEgZnVuY2nDsyBDb3JyZWRvciBjYWxjdWxhIGxhIHN1bWEgZGVscyBjb3N0b3MgYWN1bXVsYXRpdXMgZGUgZG9zIHLDoHN0ZXJzIGRlIGNvc3QgYWN1bXVsYXRpdSBkJ2VudHJhZGEuIFRvdCBpIHF1ZSBlcyBwb2RlbiB1dGlsaXR6YXIgZG9zIHLDoHN0ZXJzIHF1YWxzZXZvbCBwZXIgYSBsJ2VudHJhZGEsIHBlciBvYnRlbmlyIHVuIHJlc3VsdGF0IHNpZ25pZmljYXRpdSBoYW4gZGUgc2VyIHLDoHN0ZXJzIGRlIHNvcnRpZGEgZGUgY29zdCBhY3VtdWxhdGl1IHNlbnNlIGFsdGVyYXIuIEwnb3JkcmUgZGUgbGVzIGR1ZXMgZW50cmFkZXMgw6lzIGlycmVsbGV2YW50LlwiLFxuXHRcdGNvc0hOYW1lOiBcIkNvc2ludXMgaGlwZXJiw7JsaWMgKENvc0gpXCIsXG5cdFx0Y29zSFNuaXA6IFwiQ2FsY3VsYSBlbCBjb3NpbnVzIGhpcGVyYsOybGljIGRlIGxlcyBjZWzCt2xlcyBkJ3VuIHLDoHN0ZXIuXCIsXG5cdFx0Y29zSERlc2M6IFwiTGEgZnVuY2nDsyBjYWxjdWxhIGVsIGNvc2ludXMgaGlwZXJiw7JsaWMgZGVscyBww614ZWxzIGQndW4gcsOgc3Rlci5cIixcblx0XHRjb3NOYW1lOiBcIkNvc2ludXMgKENvcylcIixcblx0XHRjb3NTbmlwOiBcIkNhbGN1bGEgZWwgY29zaW51cyBkJ3VuYSBjZWzCt2xhIGRlbCByw6BzdGVyLlwiLFxuXHRcdGNvc0Rlc2M6IFwiTGEgZnVuY2nDsyBjYWxjdWxhIGVsIGNvc2ludXMgZGVscyBww614ZWxzIGQndW4gcsOgc3Rlci5cIixcblx0XHRjb3N0QWxsb2NhdGlvbk5hbWU6IFwiQXNzaWduYWNpw7MgZGUgY29zdG9zXCIsXG5cdFx0Y29zdEFsbG9jYXRpb25TbmlwOiBcIkNhbGN1bGEsIHBlciBhIGNhZGEgY2VswrdsYSwgbCdvcmlnZW4gZGUgbWVub3IgY29zdCBlbiBmdW5jacOzIGRlbCBjb3N0IGFjdW11bGF0aXUgbcOpcyBiYWl4IGVuIHVuYSBzdXBlcmbDrWNpZSBkZSBjb3N0LlwiLFxuXHRcdGNvc3RBbGxvY2F0aW9uRGVzYzogXCJMYSBmdW5jacOzIEFzc2lnbmFjacOzIGRlIGNvc3RvcyBjYWxjdWxhLCBwZXIgYSBjYWRhIGNlbMK3bGEsIGwnb3JpZ2VuIGRlIG1lbm9yIGNvc3QgZW4gZnVuY2nDsyBkZWwgY29zdCBhY3VtdWxhdGl1IG3DqXMgYmFpeCBlbiB1bmEgc3VwZXJmw61jaWUgZGUgY29zdC5cIixcblx0XHRjb3N0QmFja0xpbmtOYW1lOiBcIkVubGxhw6cgZGUgbWVub3IgY29zdFwiLFxuXHRcdGNvc3RCYWNrTGlua1NuaXA6IFwiRGVmaW5laXggZWwgdmXDrSBxdWUgw6lzIGxhIGNlbMK3bGEgc2Vnw7xlbnQgYSBsYSBydXRhIGRlIG1lbm9yIGNvc3QgYWN1bXVsYXRpdSBhIGwnb3JpZ2VuIGRlIG1lbm9yIGNvc3QuXCIsXG5cdFx0Y29zdEJhY2tMaW5rRGVzYzogXCJMYSBmdW5jacOzIEVubGxhw6cgZGUgbWVub3IgY29zdCBkZWZpbmVpeCBlbCB2ZcOtIHF1ZSDDqXMgbGEgY2VswrdsYSBzZWfDvGVudCBhIGxhIHJ1dGEgZGUgbWVub3IgY29zdCBhY3VtdWxhdGl1IGEgbCdvcmlnZW4gZGUgbWVub3IgY29zdC48ZGl2Pjxici8+RWwgcsOgc3RlciBkJ2VubGxhw6cgZGUgbWVub3IgY29zdCBjb250w6kgdmFsb3JzIGRlIHplcm8gYSB2dWl0LCBxdWUgZGVmaW5laXhlbiBsYSBkaXJlY2Npw7MgbyBpZGVudGlmaXF1ZW4gbGEgY2VswrdsYSB2ZcOvbmEgc2Vnw7xlbnQgKGxhIGNlbMK3bGEgcG9zdGVyaW9yKSBhbCBsbGFyZyBkZSBsYSBydXRhIGRlIG1lbm9yIGNvc3QgYWN1bXVsYXRpdSBkZXMgZCd1bmEgY2VswrdsYSBwZXIgYXJyaWJhciBhIGwnb3JpZ2VuIGRlIG1lbm9yIGNvc3QuIFNpIGxhIHJ1dGEgaGEgZGUgcGFzc2FyIGFsIHZlw60gZGUgbGEgZHJldGEsIHMnYXNzaWduYXLDoCBlbCB2YWxvciAxIGEgbGEgY2VswrdsYSwgMiBwZXIgYSBsYSBjZWzCt2xhIGRpYWdvbmFsIGRyZXRhIGluZmVyaW9yLCBpIGFpeMOtIHN1Y2Nlc3NpdmFtZW50IGVuIGVsIHNlbnRpdCBkZSBsZXMgYWd1bGxlcyBkZWwgcmVsbG90Z2UuIEVsIHZhbG9yIDAgZXMgcmVzZXJ2YSBwZXIgYSBsZXMgY2VswrdsZXMgZCdvcmlnZW4uPC9kaXY+XCIsXG5cdFx0Y29zdERpc3RhbmNlTmFtZTogXCJDb3N0IGVuIHBsYVwiLFxuXHRcdGNvc3REaXN0YW5jZVNuaXA6IFwiQ2FsY3VsYSBsYSBkaXN0w6BuY2lhIGRlIG1lbm9yIGNvc3QgYWN1bXVsYXRpdSBkZSBjYWRhIGNlbMK3bGEgZGVzIGRlIG8gY2FwIGEgbCdvcmlnZW4gZGUgbWVub3IgY29zdCBzb2JyZSB1bmEgc3VwZXJmw61jaWUgZGUgY29zdC5cIixcblx0XHRjb3N0RGlzdGFuY2VEZXNjOiBcIkxhIGZ1bmNpw7MgQ29zdCBlbiBwbGEgY2FsY3VsYSBsYSBkaXN0w6BuY2lhIGRlIG1lbm9yIGNvc3QgYWN1bXVsYXRpdSBkZSBjYWRhIGNlbMK3bGEgZGVzIGRlIG8gY2FwIGEgbCdvcmlnZW4gZGUgbWVub3IgY29zdCBzb2JyZSB1bmEgc3VwZXJmw61jaWUgZGUgY29zdC5cIixcblx0XHRjb3N0UGF0aE5hbWU6IFwiUnV0YSBkZSBjb3N0XCIsXG5cdFx0Y29zdFBhdGhTbmlwOiBcIkNhbGN1bGEgbGEgcnV0YSBkZSBtZW5vciBjb3N0IGRlcyBkJ3VuIG9yaWdlbiBmaW5zIGEgdW5hIGRlc3RpbmFjacOzLlwiLFxuXHRcdGNvc3RQYXRoRGVzYzogXCJMYSBmdW5jacOzIFJ1dGEgZGUgY29zdCBnbG9iYWwgY2FsY3VsYSBsYSBydXRhIGRlIG1lbm9yIGNvc3QgZGVzIGQndW4gb3JpZ2VuIGZpbnMgYSB1bmEgZGVzdGluYWNpw7MuPGRpdj48YnIvPkFxdWVzdGEgZnVuY2nDsyBnZW5lcmEgdW4gcsOgc3RlciBkZSBzb3J0aWRhIHF1ZSByZWdpc3RyYSBsYSBydXRhIG8gbGVzIHJ1dGVzIGRlIG1lbm9yIGNvc3QgZGVzIGRlIGxlcyB1YmljYWNpb25zIHNlbGVjY2lvbmFkZXMgZmlucyBhIGxhIGNlbMK3bGEgZCdvcmlnZW4gbcOpcyBwcm9wZXJhIGRlZmluaWRhIGEgbGEgc3VwZXJmw61jaWUgZGUgY29zdCBhY3VtdWxhdGl1LCBlbiB0ZXJtZXMgZGUgY29zdCBlbiBwbGEuPC9kaXY+XCIsXG5cdFx0Y3VydmF0dXJlTmFtZTogXCJDdXJ2YXR1cmFcIixcblx0XHRjdXJ2YXR1cmVTbmlwOiBcIkNhbGN1bGEgbGEgY3VydmF0dXJhIGQndW5hIHN1cGVyZsOtY2llIGRlIHLDoHN0ZXIsIHF1ZSBwb3QgaW5jbG91cmUgbGEgY3VydmF0dXJhIGRlbCBwZXJmaWwgaSBkZWwgcGxhLlwiLFxuXHRcdGN1cnZhdHVyZURlc2M6IFwiTGEgZnVuY2nDsyBDdXJ2YXR1cmEgbW9zdHJhIGxhIGZvcm1hIG8gbGEgY3VydmF0dXJhIGRlbCBwZW5kZW50LiBVbmEgcGFydCBkJ3VuYSBzdXBlcmbDrWNpZSBwb3Qgc2VyIGPDsm5jYXZhIG8gY29udmV4YTsgcGVyIHNhYmVyLWhvLCBvYnNlcnZldSBlbCB2YWxvciBkZSBjdXJ2YXR1cmEuIFBlciBvYnRlbmlyIGxhIGN1cnZhdHVyYSBlcyBjYWxjdWxhIGxhIHNlZ29uYSBkZXJpdmFkYSBkZSBsYSBzdXBlcmbDrWNpZS48ZGl2Pjxici8+TGEgc29ydGlkYSBkZSBsYSBmdW5jacOzIEN1cnZhdHVyYSBlcyBwb3QgdXRpbGl0emFyIHBlciBkZXNjcml1cmUgbGVzIGNhcmFjdGVyw61zdGlxdWVzIGbDrXNpcXVlcyBkJ3VuYSBjb25jYSBkZSBkcmVuYXRnZSBwZXIgaW50ZW50YXIgZW50ZW5kcmUgZWxzIHByb2Nlc3NvcyBkJ2Vyb3Npw7MgaSBlc2NvbGFtZW50LiBFbCB2YWxvciBkZSBjdXJ2YXR1cmEgZXMgcG90IHV0aWxpdHphciBwZXIgY2VyY2FyIHBhdHJvbnMgZCdlcm9zacOzIGRlbCBzw7JsLCBhaXjDrSBjb20gbGEgZGlzdHJpYnVjacOzIGQnYWlndWEgYWwgdGVycmVueS4gTGEgY3VydmF0dXJhIGRlbCBwZXJmaWwgYWZlY3RhIGwnYWNjZWxlcmFjacOzIGkgZGVzYWNjZWxlcmFjacOzIGRlbCBmbHV4IGksIHBlciB0YW50LCBpbmZsdWVpeCBlbiBsJ2Vyb3Npw7MgaSBsYSBkZXBvc2ljacOzLiBMYSBjdXJ2YXR1cmEgZGUgbGEgcGxhbnRhIGluZmx1ZWl4IGVuIGxhIGNvbnZlcmfDqG5jaWEgaSBsYSBkaXZlcmfDqG5jaWEgZGVsIGZsdXguPC9kaXY+XCIsXG5cdFx0ZGl2aWRlTmFtZTogXCJEaXZpc2nDs1wiLFxuXHRcdGRpdmlkZVNuaXA6IFwiRGl2aWRlaXggZWxzIHZhbG9ycyBkZSBkb3MgcsOgc3RlcnMgcMOteGVsIHBlciBww614ZWwuXCIsXG5cdFx0ZGl2aWRlRGVzYzogXCJMYSBmdW5jacOzIERpdmlzacOzIGRpdmlkZWl4IGVscyB2YWxvcnMgZGUgZG9zIHLDoHN0ZXJzIHDDrXhlbCBwZXIgcMOteGVsLlwiLFxuXHRcdGVsZXZhdGlvblZvaWRGaWxsTmFtZTogXCJFbXBsZW5hbWVudCBkZSBidWl0cyBkJ2VsZXZhY2nDs1wiLFxuXHRcdGVsZXZhdGlvblZvaWRGaWxsU25pcDogXCJDcmVhIHDDrXhlbHMgYWxsw6Agb24gbGVzIGRhZGVzIGQnZWxldmFjacOzIHByZXNlbnRlbiBmb3JhdHMuXCIsXG5cdFx0ZWxldmF0aW9uVm9pZEZpbGxEZXNjOiBcIkxhIGZ1bmNpw7MgRW1wbGVuYW1lbnQgZGUgYnVpdHMgZCdlbGV2YWNpw7Mgcyd1dGlsaXR6YSBwZXIgY3JlYXIgcMOteGVscyBhbGzDoCBvbiBsJ2VsZXZhY2nDsyBwcmVzZW50YSBmb3JhdHMuPGRpdj48YnIvPkVscyBidWl0cyBlcyBwcm9kdWVpeGVuIHF1YW4gbm8gcydoYW4gcmVjb3BpbGF0IHB1bnRzIGVuIHVuYSDDoHJlYSByZXByZXNlbnRhZGEgcGVyIHVuIHDDrXhlbCBhbCByw6BzdGVyIHJlc3VsdGFudC4gTGVzIGNhdXNlcyBkZWxzIGJ1aXRzIHNvbGVuIHNlciBsZXMgbWFzc2VzIGQnYWlndWEsIGxhIHNlbGVjY2nDsyBkZWwgdGlwdXMgZGUgY2xhc3NlIG8gbCdleGNsdXNpw7MuIEwnZW1wbGVuYW1lbnQgZGUgYnVpdHMgcyd1dGlsaXR6YSBwcmluY2lwYWxtZW50IHF1YW4gZXMgZ2VuZXJhIHVuYSBzdXBlcmbDrWNpZSBkZSB0ZXJyZW55LjwvZGl2PlwiLFxuXHRcdGVxdWFsVG9OYW1lOiBcIklndWFsIHF1ZVwiLFxuXHRcdGVxdWFsVG9TbmlwOiBcIlJlYWxpdHphIHVuYSBvcGVyYWNpw7MgZCdpZ3VhbHRhdCByZWxhY2lvbmFsIGVuIGR1ZXMgZW50cmFkZXMgY2VswrdsYSBwZXIgY2VswrdsYS4gUmV0b3JuYSBlbCB2YWxvciAxIHBlciBhIGxlcyBjZWzCt2xlcyBvbiBlbCBwcmltZXIgcsOgc3RlciDDqXMgaWd1YWwgcXVlIGVsIHNlZ29uIGkgZWwgdmFsb3IgMCBwZXIgYSBsZXMgY2VswrdsZXMgcXVhbiBlbHMgcsOgc3RlcnMgbm8gc8OzbiBpZ3VhbHMuXCIsXG5cdFx0ZXF1YWxUb0Rlc2M6IFwiTGEgZnVuY2nDsyByZWFsaXR6YSB1bmEgb3BlcmFjacOzIGQnaWd1YWx0YXQgZW4gZG9zIHLDoHN0ZXJzIHDDrXhlbCBwZXIgcMOteGVsLiBSZXRvcm5hIGVsIHZhbG9yIDEgcGVyIGFscyBww614ZWxzIG9uIGVsIHByaW1lciByw6BzdGVyIMOpcyBpZ3VhbCBxdWUgZWwgc2Vnb24gaSBlbCB2YWxvciAwIHBlciBhbHMgcMOteGVscyBvbiBlbHMgcsOgc3RlcnMgbm8gc8OzbiBpZ3VhbHMuXCIsXG5cdFx0ZXVjQWxsb2NhdGlvbk5hbWU6IFwiQXNzaWduYWNpw7MgZXVjbGlkaWFuYVwiLFxuXHRcdGV1Y0FsbG9jYXRpb25TbmlwOiBcIkNhbGN1bGEsIHBlciBhIGNhZGEgY2VswrdsYSwgbCdvcmlnZW4gbcOpcyBwcm9wZXIgYmFzYXQgZW4gbGEgZGlzdMOgbmNpYSBldWNsaWRpYW5hLlwiLFxuXHRcdGV1Y0FsbG9jYXRpb25EZXNjOiBcIkxhIGZ1bmNpw7MgQXNzaWduYWNpw7MgZXVjbGlkaWFuYSBjYWxjdWxhLCBwZXIgYSBjYWRhIGNlbMK3bGEsIGwnb3JpZ2VuIG3DqXMgcHJvcGVyIGJhc2F0IGVuIGxhIGRpc3TDoG5jaWEgZXVjbGlkaWFuYS5cIixcblx0XHRldWNEaXJlY3Rpb25OYW1lOiBcIkRpcmVjY2nDsyBldWNsaWRpYW5hXCIsXG5cdFx0ZXVjRGlyZWN0aW9uU25pcDogXCJDYWxjdWxhLCBwZXIgYSBjYWRhIGNlbMK3bGEsIGxhIGRpcmVjY2nDsywgZW4gZ3JhdXMsIGEgbCdvcmlnZW4gbcOpcyBwcm9wZXIuXCIsXG5cdFx0ZXVjRGlyZWN0aW9uRGVzYzogXCJMYSBmdW5jacOzIERpcmVjY2nDsyBldWNsaWRpYW5hIGNhbGN1bGEsIHBlciBhIGNhZGEgY2VswrdsYSwgbGEgZGlyZWNjacOzLCBlbiBncmF1cywgYSBsJ29yaWdlbiBtw6lzIHByb3Blci4gPGRpdj48YnIvPkxhIGRpcmVjY2nDsyBlcyBjYWxjdWxhIGRlcyBkZWwgY2VudHJlIGRlIGNhZGEgY2VswrdsYSBmaW5zIGFsIGNlbnRyZSBkZSBsYSBjZWzCt2xhIGQnb3JpZ2VuIG3DqXMgcHJvcGVyYS4gTCdpbnRlcnZhbCBkZSB2YWxvcnMgw6lzIGRlIDAgYSAzNjAgZ3JhdXMsIGFtYiBlbCB2YWxvciAwIHJlc2VydmF0IHBlciBhIGxlcyBjZWzCt2xlcyBkJ29yaWdlbi4gQ2FwIGEgbCdlc3QgKGRyZXRhKSDDqXMgOTAgaSBlbHMgdmFsb3JzIGF1Z21lbnRlbiBlbiBlbCBzZW50aXQgZGUgbGVzIGFndWxsZXMgZGVsIHJlbGxvdGdlICgxODAgw6lzIGVsIHN1ZCwgMjcwIMOpcyBsJ29lc3QgaSAzNjAgw6lzIGVsIG5vcmQpLjwvZGl2PlwiLFxuXHRcdGV1Y0Rpc3RhbmNlTmFtZTogXCJEaXN0w6BuY2lhIGV1Y2xpZGlhbmFcIixcblx0XHRldWNEaXN0YW5jZVNuaXA6IFwiQ2FsY3VsYSwgcGVyIGEgY2FkYSBjZWzCt2xhLCBsYSBkaXN0w6BuY2lhIGV1Y2xpZGlhbmEgYSBsJ29yaWdlbiBtw6lzIHByb3Blci5cIixcblx0XHRldWNEaXN0YW5jZURlc2M6IFwiTGEgZnVuY2nDsyBEaXN0w6BuY2lhIGV1Y2xpZGlhbmEgY2FsY3VsYSwgcGVyIGEgY2FkYSBjZWzCt2xhLCBsYSBkaXN0w6BuY2lhIGV1Y2xpZGlhbmEgYSBsJ29yaWdlbiBtw6lzIHByb3Blci5cIixcblx0XHRleHAxME5hbWU6IFwiRXhwb25lbmNpYWwgZW4gYmFzZSAxMCAoRXhwMTApXCIsXG5cdFx0ZXhwMTBTbmlwOiBcIkNhbGN1bGEgbCdleHBvbmVuY2lhbCBlbiBiYXNlIDEwIGRlIGxlcyBjZWzCt2xlcyBkJ3VuIHLDoHN0ZXIuXCIsXG5cdFx0ZXhwMTBEZXNjOiBcIkxhIGZ1bmNpw7MgRXhwb25lbmNpYWwgZW4gYmFzZSAxMCBjYWxjdWxhIGwnZXhwb25lbmNpYWwgZW4gYmFzZSAxMCBkZWxzIHDDrXhlbHMgZCd1biByw6BzdGVyLlwiLFxuXHRcdGV4cDJOYW1lOiBcIkV4cG9uZW5jaWFsIGVuIGJhc2UgMiAoRXhwMilcIixcblx0XHRleHAyU25pcDogXCJDYWxjdWxhIGwnZXhwb25lbmNpYWwgZW4gYmFzZSAyIGRlIGxlcyBjZWzCt2xlcyBkJ3VuIHLDoHN0ZXIuXCIsXG5cdFx0ZXhwMkRlc2M6IFwiQXF1ZXN0YSBmdW5jacOzIGNhbGN1bGEgbCdleHBvbmVuY2lhbCBlbiBiYXNlIDIgZGVscyBww614ZWxzIGQndW4gcsOgc3Rlci5cIixcblx0XHRleHBOYW1lOiBcIkV4cG9uZW5jaWFsIGVuIGJhc2UgZSAoRXhwKVwiLFxuXHRcdGV4cFNuaXA6IFwiQ2FsY3VsYSBsJ2V4cG9uZW5jaWFsIGVuIGJhc2UgZSBkZSBsZXMgY2VswrdsZXMgZCd1biByw6BzdGVyLlwiLFxuXHRcdGV4cERlc2M6IFwiQXF1ZXN0YSBmdW5jacOzIGNhbGN1bGEgbCdleHBvbmVuY2lhbCBlbiBiYXNlIGUgZGVscyBww614ZWxzIGQndW4gcsOgc3Rlci5cIixcblx0XHRleHRyYWN0QmFuZE5hbWU6IFwiRXh0cmV1IGxlcyBiYW5kZXNcIixcblx0XHRleHRyYWN0QmFuZFNuaXA6IFwiRXNwZWNpZmljYSBhbWIgcXVpbmVzIGJhbmRlcyBjYWwgdHJlYmFsbGFyIHF1YW4gcyd1dGlsaXR6ZW4gZGF0YXNldHMgbXVsdGliYW5kYS5cIixcblx0XHRleHRyYWN0QmFuZERlc2M6IFwiIExhIGZ1bmNpw7MgRXh0cmV1IGxlcyBiYW5kZXMgdXMgcGVybWV0IGV4dHJldXJlIHVuYSBvIG3DqXMgYmFuZGVzIGQndW4gZGF0YXNldCByw6BzdGVyIG11bHRpYmFuZGEsIG8gYsOpIHJlb3JkZW5hci1uZSBsZXMgYmFuZGVzLjxkaXY+PGJyLz5Qb2RldSB1dGlsaXR6YXIgbGEgZnVuY2nDsyBFeHRyZXUgbGVzIGJhbmRlcyBhYmFucyBxdWUgYWx0cmVzIGZ1bmNpb25zLCBjb20gYXJhIEFyaXRtw6h0aWNhLCBwZXIgY29udHJvbGFyIHF1aW5lcyBiYW5kZXMgcyd1dGlsaXR6YXJhbiBjb20gYSBlbnRyYWRhIGEgbGEgZnVuY2nDsyBzZWfDvGVudC48L2Rpdj5cIixcblx0XHRmaWxsTmFtZTogXCJFbXBsZW5hXCIsXG5cdFx0ZmlsbFNuaXA6IFwiRW1wbGVuYSBlbHMgZW1ib3JuYWxzIGQndW4gcsOgc3RlciBkZSBzdXBlcmbDrWNpZSBwZXIgZWxpbWluYXIgcGV0aXRlcyBpbXBlcmZlY2Npb25zIGRlIGxlcyBkYWRlcy5cIixcblx0XHRmaWxsRGVzYzogXCJMYSBmdW5jacOzIEVtcGxlbmFtZW50IGdsb2JhbCBsb2NhbGl0emEgaSBlbXBsZW5hIGVtYm9ybmFscyBpIHBpY3MgZW4gdW4gcsOgc3RlciBkZSBzdXBlcmbDrWNpZSBkJ2VsZXZhY2nDsyBwZXIgZWxpbWluYXIgcGV0aXRlcyBpbXBlcmZlY2Npb25zIGRlIGxlcyBkYWRlcy4gTGEgZnVuY2nDsyByZWFsaXR6YXLDoCBsJ2VtcGxlbmFtZW50IGVuIHVuIHByb2PDqXMgaXRlcmF0aXUgZmlucyBxdWUgdG90cyBlbHMgZW1ib3JuYWxzIHMnaGFnaW4gZW1wbGVuYXQgZGlucyBkZWwgbMOtbWl0IFogZXNwZWNpZmljYXQuPGRpdj48YnIvPlF1YW4gZXMgY3JlYSB1bmEgc3VwZXJmw61jaWUgZCdlbGV2YWNpw7MgYW1iIGxlcyBlaW5lcyBkZSByZXByZXNlbnRhY2nDsyBjYXJ0b2dyw6BmaWNhIGQnb3J0b2ZvdG9zIG8gcGVyIGFsdHJlcyBtaXRqYW5zLCBhY29zdHVtZW4gYSBwcm9kdWlyLXNlIGVycm9ycyBtZW5vcnMsIHBlcsOyIHNpZ25pZmljYXRpdXMsIGVuIGxhIGZvcm1hIGRlbHMgZW1ib3JuYWxzIGkgcGljcyBkZSBsZXMgZGFkZXMuIEVuIGwnw6BtYml0IGRlIGxhIGZvdG9ncmFtZXRyaWEsIGVscyBlbWJvcm5hbHMgaSBwaWNzIHMnYWNvc3R1bWVuIGEgYW5vbWVuYXIgXFxcImZvcmF0cyBpIHBpY3NcXFwiLiBBdMOocyBxdWUgbGVzIGRhZGVzIGRlIHN1cGVyZsOtY2llIHMnYWNvc3R1bWVuIGEgdXRpbGl0emFyIHBlciBhIGxhIG1vZGVsaXR6YWNpw7MsIGNvbSBhcmEgbGEgbW9kZWxpdHphY2nDsyBoaWRyb2zDsmdpY2EsIMOpcyBpbXBvcnRhbnQgY29ycmVnaXIgYXF1ZXN0cyBlcnJvcnMgZCdlbWJvcm5hbHMgaSBwaWNzIGRlIG1hbmVyYSBjb2hlcmVudCBhbWIgbGVzIGRhZGVzIGRlIGwnZW50b3JuLjwvZGl2PlwiLFxuXHRcdGZsb2F0TmFtZTogXCJQdW50IGZsb3RhbnRcIixcblx0XHRmbG9hdFNuaXA6IFwiQ29udmVydGVpeCBjYWRhIHZhbG9yIGRlIGNlbMK3bGEgZCd1biByw6BzdGVyIGVuIHVuYSByZXByZXNlbnRhY2nDsyBkZSBwdW50IGZsb3RhbnQuXCIsXG5cdFx0ZmxvYXREZXNjOiBcIkxhIGZ1bmNpw7MgUHVudCBmbG90YW50IGNvbnZlcnRlaXggY2FkYSB2YWxvciBkZSBww614ZWwgZCd1biByw6BzdGVyIGVuIHVuYSByZXByZXNlbnRhY2nDsyBkZSBwdW50IGZsb3RhbnQuXCIsXG5cdFx0Zmxvd0FjY3VtdWxhdGlvbk5hbWU6IFwiQWN1bXVsYWNpw7MgZGUgZmx1eFwiLFxuXHRcdGZsb3dBY2N1bXVsYXRpb25TbmlwOiBcIkNyZWEgdW4gcsOgc3RlciBkZSBmbHV4IGFjdW11bGF0IGEgY2FkYSBjZWzCt2xhLiBEZSBtYW5lcmEgb3BjaW9uYWwsIGVzIHBvdCBhcGxpY2FyIHVuIGZhY3RvciBkZSBwb25kZXJhY2nDsy5cIixcblx0XHRmbG93QWNjdW11bGF0aW9uRGVzYzogXCJMYSBmdW5jacOzIEFjdW11bGFjacOzIGRlIGZsdXggZ2xvYmFsIGNyZWEgdW4gcsOgc3RlciBkZWwgZmx1eCBhY3VtdWxhdCBlbiBjYWRhIHDDrXhlbCwgdGFsIGNvbSBkZXRlcm1pbmEgbCdhY3VtdWxhY2nDsyBkZSBsYSBwb25kZXJhY2nDsyBkZSB0b3RzIGVscyBww614ZWxzIHF1ZSBmbHVlaXhlbiBhIGNhZGEgcMOteGVsIGRlIHBlbmRlbnQgZGVzY2VuZGVudC4gU2kgbm8gZXMgcHJvcG9yY2lvbmEgY2FwIHLDoHN0ZXIgZGUgcG9uZGVyYWNpw7MsIHMnYXBsaWNhcsOgIHVuYSBwb25kZXJhY2nDsyBkJzEgYSBjYWRhIHDDrXhlbCwgaSBlbCB2YWxvciBkZWxzIHDDrXhlbHMgZGVsIHLDoHN0ZXIgZGUgc29ydGlkYSBzZXLDoCBlbCBub21icmUgZGUgcMOteGVscyBxdWUgZmx1ZWl4ZW4gYSBjYWRhIHDDrXhlbC48ZGl2Pjxici8+RWxzIHDDrXhlbHMgZGUgc29ydGlkYSBhbWIgdW5hIGFjdW11bGFjacOzIGRlIGZsdXggYWx0YSBzw7NuIMOgcmVlcyBkZSBmbHV4IGNvbmNlbnRyYXQgaSBlcyBwb2RlbiB1dGlsaXR6YXIgcGVyIGlkZW50aWZpY2FyIGNhbmFscyBkZSBjb3JyZW50LiBFbHMgcMOteGVscyBkZSBzb3J0aWRhIGFtYiB1bmEgYWN1bXVsYWNpw7MgZGUgZmx1eCBhbHRhIHPDs24gw6ByZWVzIGRlIGZsdXggY29uY2VudHJhdCBpIGVzIHBvZGVuIHV0aWxpdHphciBwZXIgaWRlbnRpZmljYXIgY2FuYWxzIGRlIGNvcnJlbnQuPC9kaXY+XCIsXG5cdFx0Zmxvd0RpcmVjdGlvbk5hbWU6IFwiRGlyZWNjacOzIGRlbCBmbHV4XCIsXG5cdFx0Zmxvd0RpcmVjdGlvblNuaXA6IFwiQ3JlYSB1biByw6BzdGVyIGRlIGRpcmVjY2nDsyBkZWwgZmx1eCBkZXMgZGUgY2FkYSBjZWzCt2xhIGZpbnMgYWwgdmXDrSBkZSBwZW5kZW50IGRlc2NlbmRlbnQgbcOpcyBwcm9udW5jaWF0LlwiLFxuXHRcdGZsb3dEaXJlY3Rpb25EZXNjOiBcIlVuYSBkZSBsZXMgY2xhdXMgcGVyIGRlcml2YXIgY2FyYWN0ZXLDrXN0aXF1ZXMgaGlkcm9sw7JnaXF1ZXMgZCd1bmEgc3VwZXJmw61jaWUgw6lzIGxhIHBvc3NpYmlsaXRhdCBkZSBkZXRlcm1pbmEgbGEgZGlyZWNjacOzIGRlbCBmbHV4IGRlcyBkZSBjYWRhIHDDrXhlbCBkZWwgcsOgc3Rlci4gTGEgZnVuY2nDsyBkZSByw6BzdGVyIERpcmVjY2nDsyBkZWwgZmx1eCBwcmVuIHVuYSBzdXBlcmbDrWNpZSBjb20gYSBlbnRyYWRhIGkgY3JlYSB1biByw6BzdGVyIGRlIGRpcmVjY2nDsyBkZWwgZmx1eCBkZXMgZGUgY2FkYSBww614ZWwgZmlucyBhbCB2ZcOtIGRlIHBlbmRlbnQgZGVzY2VuZGVudCBtw6lzIHByb251bmNpYXQuIExhIGZ1bmNpw7MgRGlyZWNjacOzIGRlbCBmbHV4IGFkbWV0IHRyZXMgbcOodG9kZXMgZGUgbW9kZWxpdHphY2nDsyBkZSBmbHV4OiBEOCAodnVpdCBkaXJlY2Npb25zKSwgRGlyZWNjacOzIGRlbCBmbHV4IG3Dumx0aXBsZSAoTUZEKSBpIEQtSW5maW5pdHkgKERJTkYpLiBcIixcblx0XHRmbG93RGlzdGFuY2VOYW1lOiBcIkRpc3TDoG5jaWEgZGVsIGZsdXhcIixcblx0XHRmbG93RGlzdGFuY2VTbmlwOiBcIkNhbGN1bGEsIHBlciBhIGNhZGEgY2VswrdsYSwgbGEgZGlzdMOgbmNpYSBob3JpdHpvbnRhbCBvIHZlcnRpY2FsIG3DrW5pbWEgZGVsIHBlbmRlbnQgZGVzY2VuZGVudCBhIGxlcyBjZWzCt2xlcyBlbiB1biByaXUgbyB1biBjb3JyZW50IGFsIHF1YWwgZmx1ZWl4ZW4uXCIsXG5cdFx0Zmxvd0Rpc3RhbmNlRGVzYzogXCJQZXIgYSBjYWRhIHDDrXhlbCwgbGEgZnVuY2nDsyBjYWxjdWxhcsOgIGxhIGRpc3TDoG5jaWEgaG9yaXR6b250YWwgbyB2ZXJ0aWNhbCBtw61uaW1hIGRlbCBwZW5kZW50IGRlc2NlbmRlbnQgYWxzIHDDrXhlbHMgZW4gdW4gcml1IG8gdW4gY29ycmVudCBhbCBxdWFsIGZsdWVpeGVuLiBTaSBlcyBwcm9wb3JjaW9uYSB1biByw6BzdGVyIGRlIGRpcmVjY2nDsyBkZWwgZmx1eCBvcGNpb25hbCwgbGVzIGRpcmVjY2lvbnMgZGVsIHBlbmRlbnQgZGVzY2VuZGVudCBlcyBsaW1pdGFyYW4gYSBsZXMgZGVmaW5pZGVzIHBlbCByw6BzdGVyIGRlIGRpcmVjY2nDsyBkZWwgZmx1eCBkJ2VudHJhZGEuIExhIHNvcnRpZGEgw6lzIHVuIHLDoHN0ZXIgZGUgZGlzdMOgbmNpYSBkZWwgZmx1eC5cIixcblx0XHRmb2NhbE5hbWU6IFwiRXN0YWTDrXN0aXF1ZXMgZm9jYWxzXCIsXG5cdFx0Zm9jYWxTbmlwOiBcIkNhbGN1bGEgbGVzIGVzdGFkw61zdGlxdWVzIGZvY2FscyBkZSBjYWRhIHDDrXhlbCBkJ3VuYSBpbWF0Z2UgZW4gZnVuY2nDsyBkZWwgdmXDr25hdCBmb2NhbCBkZWZpbml0LlwiLFxuXHRcdGZvY2FsRGVzYzogXCJMYSBmdW5jacOzIEVzdGFkw61zdGlxdWVzIGZvY2FscyBjYWxjdWxhIGxlcyBlc3RhZMOtc3RpcXVlcyBmb2NhbHMgZGUgY2FkYSBww614ZWwgZCd1bmEgaW1hdGdlIGVuIGZ1bmNpw7MgZGVsIHZlw69uYXQgZm9jYWwgZGVmaW5pdC5cIixcblx0XHRnZW9tZXRyaWNOYW1lOiBcIkdlb23DqHRyaWNhXCIsXG5cdFx0Z2VvbWV0cmljU25pcDogXCJBdWdtZW50YSBsYSBwcmVjaXNpw7MgZGUgbGEgcG9zaWNpw7MgZCd1biBkYXRhc2V0IGVuIHRlbmlyIGVuIGNvbXB0ZSBsJ2VsZXZhY2nDsy5cIixcblx0XHRnZW9tZXRyaWNEZXNjOiBcIkxhIGZ1bmNpw7MgR2VvbcOodHJpY2EgZ2VuZXJhIHVuYSBpbWF0Z2Ugb3J0b3JlY3RpZmljYWRhIGJhc2FkYSBlbiB1bmEgZGVmaW5pY2nDsyBkZSBzZW5zb3IgaSB1biBtb2RlbCBkZSB0ZXJyZW55LiBBdWdtZW50YSBsYSBwcmVjaXNpw7MgZGUgbGEgcG9zaWNpw7MgZCd1biBkYXRhc2V0IGVuIHRlbmlyIGVuIGNvbXB0ZSBsJ2VsZXZhY2nDsy5cIixcblx0XHRncmF5c2NhbGVOYW1lOiBcIkVzY2FsYSBkZSBncmlzb3NcIixcblx0XHRncmF5c2NhbGVTbmlwOiBcIkNvbnZlcnRlaXggdW5hIGltYXRnZSBtdWx0aWJhbmRhIGVuIHVuYSBpbWF0Z2UgZW4gZXNjYWxhIGRlIGdyaXNvcyBkJ3VuYSBiYW5kYS5cIixcblx0XHRncmF5c2NhbGVEZXNjOiBcIkFxdWVzdGEgZnVuY2nDsyBjb252ZXJ0ZWl4IHVuYSBpbWF0Z2UgbXVsdGliYW5kYSBlbiB1bmEgaW1hdGdlIGVuIGVzY2FsYSBkZSBncmlzb3MgZCd1bmEgYmFuZGEuPGRpdj48YnIvPkFxdWVzdGEgZnVuY2nDsyBhcGxpY2EgcG9uZGVyYWNpb25zIGVzcGVjaWZpY2FkZXMgYSBjYWRhc2N1bmEgZGUgbGVzIGJhbmRlcyBkJ2VudHJhZGEgaSBub3JtYWxpdHphIGxhIGltYXRnZSBkZSBzb3J0aWRhLiBMZXMgcG9uZGVyYWNpb25zIHMnYWNvc3R1bWVuIGEgYXBsaWNhciBwZXJxdcOoIGFsZ3VuZXMgYmFuZGVzIHRlbmVuIHVuYSBpbXBvcnTDoG5jaWEgdmFyaWFibGUgc2Vnb25zIGwnYXBsaWNhY2nDsy4gUGVyIGV4ZW1wbGUsIGxhIGJhbmRhIGJsYXZhIGFjb3N0dW1hIGEgY29udGVuaXIgbcOpcyBzb3JvbGwgcXVlIGxlcyBhbHRyZXMuPC9kaXY+XCIsXG5cdFx0Z3JlYXRlclRoYW5FcXVhbE5hbWU6IFwiTWFqb3IgbyBpZ3VhbCBxdWVcIixcblx0XHRncmVhdGVyVGhhbkVxdWFsU25pcDogXCJSZWFsaXR6YSB1bmEgb3BlcmFjacOzIGRlIHN1cGVyaW9yaXRhdCBvIGlndWFsdGF0IHJlbGFjaW9uYWwgZW4gZHVlcyBlbnRyYWRlcyBjZWzCt2xhIHBlciBjZWzCt2xhLiBSZXRvcm5hIGVsIHZhbG9yIDEgcGVyIGEgbGVzIGNlbMK3bGVzIG9uIGVsIHByaW1lciByw6BzdGVyIMOpcyBtYWpvciBvIGlndWFsIHF1ZSBlbCBzZWdvbiBpIGVsIHZhbG9yIDAgc2kgbm8gaG8gw6lzLlwiLFxuXHRcdGdyZWF0ZXJUaGFuRXF1YWxEZXNjOiBcIkxhIGZ1bmNpw7MgcmVhbGl0emEgdW5hIG9wZXJhY2nDsyBkZSBzdXBlcmlvcml0YXQgbyBpZ3VhbHRhdCByZWxhY2lvbmFsIGVuIGR1ZXMgZW50cmFkZXMgcMOteGVsIHBlciBww614ZWwuIFJldG9ybmEgdW4gdmFsb3IgZCcxIHBlciBhbHMgcMOteGVscyBvbiBlbCBwcmltZXIgcsOgc3RlciDDqXMgbWFqb3IgbyBpZ3VhbCBxdWUgZWwgc2Vnb24gaSB1biB2YWxvciBkZSAwIHBlciBhbHMgcMOteGVscyBvbiBlbCBwcmltZXIgcsOgc3RlciBubyDDqXMgbWFqb3IgbmkgaWd1YWwgcXVlIGVsIHNlZ29uLlwiLFxuXHRcdGdyZWF0ZXJUaGFuTmFtZTogXCJNYWpvciBxdWVcIixcblx0XHRncmVhdGVyVGhhblNuaXA6IFwiUmVhbGl0emEgdW5hIG9wZXJhY2nDsyBkZSBzdXBlcmlvcml0YXQgcmVsYWNpb25hbCBlbiBkdWVzIGVudHJhZGVzIGNlbMK3bGEgcGVyIGNlbMK3bGEuIFJldG9ybmEgZWwgdmFsb3IgMSBwZXIgYSBsZXMgY2VswrdsZXMgb24gZWwgcHJpbWVyIHLDoHN0ZXIgw6lzIG1ham9yIHF1ZSBlbCBzZWdvbiBpIGVsIHZhbG9yIDAgc2kgbm8gaG8gw6lzLlwiLFxuXHRcdGdyZWF0ZXJUaGFuRGVzYzogXCJMYSBmdW5jacOzIHJlYWxpdHphIHVuYSBvcGVyYWNpw7MgZGUgc3VwZXJpb3JpdGF0IHJlbGFjaW9uYWwgZW4gZHVlcyBlbnRyYWRlcyBww614ZWwgcGVyIHDDrXhlbC4gUmV0b3JuYSB1biB2YWxvciBkJzEgcGVyIGFscyBww614ZWxzIG9uIGVsIHByaW1lciByw6BzdGVyIMOpcyBtYWpvciBxdWUgZWwgc2Vnb24gaSB1biB2YWxvciBkZSAwIHBlciBhbHMgcMOteGVscyBvbiBlbCBwcmltZXIgcsOgc3RlciBubyDDqXMgbWFqb3IgcXVlIGVsIHNlZ29uLlwiLFxuXHRcdGhlYXRJbmRleE5hbWU6IFwiw41uZGV4IGRlIGNhbG9yXCIsXG5cdFx0aGVhdEluZGV4U25pcDogXCJDb21iaW5hIGxhIHRlbXBlcmF0dXJhIGFtYmllbnQgZGUgbCdhaXJlIGkgbGEgaHVtaXRhdCByZWxhdGl2YSBwZXIgcmV0b3JuYXIgbGEgdGVtcGVyYXR1cmEgYXBhcmVudC5cIixcblx0XHRoZWF0SW5kZXhEZXNjOiBcIkFxdWVzdGEgZnVuY2nDsyBjYWxjdWxhIGxhIHRlbXBlcmF0dXJhIGFwYXJlbnQgZW4gZnVuY2nDsyBkZSBsYSB0ZW1wZXJhdHVyYSBhbWJpZW50IGkgbGEgaHVtaXRhdCByZWxhdGl2YS4gTGEgdGVtcGVyYXR1cmEgYXBhcmVudCBzJ2Fjb3N0dW1hIGEgZGVzY3JpdXJlIGNvbSBhIHNlbnNhY2nDsyB0w6hybWljYS48ZGl2Pjxici8+QXF1ZXN0IMOtbmRleCBwb3QgcmVzdWx0YXIgw7p0aWwgcGVyIGNhbGN1bGFyIGVscyBwZXJpbGxzIHJlbGFjaW9uYXRzIGFtYiBwcm9ibGVtZXMgbcOoZGljcywgY29tIGFyYSByYW1wZXMsIGRlc2hpZHJhdGFjacOzLCBpbnNvbGFjaW9ucyBvIGNvcHMgZGUgY2Fsb3IgZ3JldXMgZW4gZGllcyBjw6BsaWRzIGkgaHVtaXRzLiBTaSBsYSBodW1pdGF0IHJlbGF0aXZhIMOpcyBhbHRhLCBjYWRhIGNvcCBlcyBmYSBtw6lzIGRpZsOtY2lsIHBlciBhbCBjb3MgZXZhcG9yYXIgbGEgc3VvciwgaSBsZXMgcGVyc29uZXMgcGVyZGVuIGxhIHNldmEgY2FwYWNpdGF0IG5hdHVyYWwgcGVyIGJhaXhhciBsYSB0ZW1wZXJhdHVyYSBjb3Jwb3JhbCBkZSBtYW5lcmEgZWZpY2HDpy4gRWxzIG1hcGVzIGRlIGNvbnNlbGxzIG8gYXZpc29zIGQnYWx0ZXMgdGVtcGVyYXR1cmVzIGFjb3N0dW1lbiBhIHNlciB1biBtw6h0b2RlIHBlciBvcmdhbml0emFyIGVsIHJlc3VsdGF0IGQnw61uZGV4IGRlIGNhbG9yIGVuIGNsYXNzZXMuIENvbSBtw6lzIGFsdCDDqXMgZWwgdmFsb3IgZCfDrW5kZXgsIG3DqXMgcHJvYmFibGUgw6lzIHF1ZSBlc2RldmluZ3VpIHVuIGF2w61zIHF1ZSBubyBwYXMgdW4gY29uc2VsbC48L2Rpdj5cIixcblx0XHRoaWxsc2hhZGVOYW1lOiBcIk9tYnJlaWdcIixcblx0XHRoaWxsc2hhZGVTbmlwOiBcIkNyZWEgdW5hIHJlcHJlc2VudGFjacOzIDNEIGRlIGxhIHN1cGVyZsOtY2llLCB0ZW5pbnQgZW4gY29tcHRlIGxhIHBvc2ljacOzIHJlbGF0aXZhIGRlbCBzb2wgcGVyIG9tYnJlamFyIGxhIGltYXRnZVwiLFxuXHRcdGhpbGxzaGFkZURlc2M6IFwiTGEgZnVuY2nDsyBPbWJyZWlnIGdlbmVyYSB1bmEgcmVwcmVzZW50YWNpw7MgM0QgZW4gZXNjYWxhIGRlIGdyaXNvcyBkZSBsYSBzdXBlcmbDrWNpZSBkZWwgdGVycmVueSwgdGVuaW50IGVuIGNvbXB0ZSBsYSBwb3NpY2nDsyByZWxhdGl2YSBkZWwgc29sIHBlciBvbWJyZWphciBsYSBpbWF0Z2UuIDxkaXY+PGJyLz5MJ29tYnJlaWcgw6lzIHVuYSB0w6hjbmljYSBwZXIgdmlzdWFsaXR6YXIgdGVycmVueSBkZXRlcm1pbmFkYSBwZXIgdW5hIGZvbnQgZCdpbMK3bHVtaW5hY2nDsyBpIHBlbCBwZW5kZW50IGkgbCdvcmllbnRhY2nDsyBkZSBsYSBzdXBlcmbDrWNpZSBkJ2VsZXZhY2nDsy4gw4lzIHVuIG3DqHRvZGUgcXVhbGl0YXRpdSBwZXIgdmlzdWFsaXR6YXIgdG9wb2dyYWZpYSwgcXVlIG5vIHByb3BvcmNpb25hIHZhbG9ycyBkJ2VsZXZhY2nDsyBhYnNvbHV0cy4gPC9kaXY+XCIsXG5cdFx0aW50TmFtZTogXCJFbnRlclwiLFxuXHRcdGludFNuaXA6IFwiQ29udmVydGVpeCBjYWRhIHZhbG9yIGRlIGNlbMK3bGEgZCd1biByw6BzdGVyIGVuIHVuIGVudGVyIHBlciB0cnVuY2FtZW50LlwiLFxuXHRcdGludERlc2M6IFwiTGEgZnVuY2nDsyBFbnRlciBjb252ZXJ0ZWl4IGNhZGEgdmFsb3IgZGUgcMOteGVsIGQndW4gcsOgc3RlciBlbiB1biBlbnRlciBtaXRqYW7Dp2FudCBlbCB0cnVuY2FtZW50LlwiLFxuXHRcdGludGVycG9sYXRlSXJyZWd1bGFyRGF0YU5hbWU6IFwiSW50ZXJwb2xhIGRhZGVzIGlycmVndWxhcnNcIixcblx0XHRpbnRlcnBvbGF0ZUlycmVndWxhckRhdGFTbmlwOiBcIlJlYWxpdHphIGxhIGludGVycG9sYWNpw7MgZGVzIGRlIG7DunZvbHMgZGUgcHVudHMgbyBxdWFkcsOtY3VsZXMgaXJyZWd1bGFycy5cIixcblx0XHRpbnRlcnBvbGF0ZUlycmVndWxhckRhdGFEZXNjOiBcIkFsZ3VucyBkYXRhc2V0cyBkZSBuZXRDREYgbyBIREYgZW1tYWdhdHplbWVuIGxhIHNldmEgZ2VvbG9jYWxpdHphY2nDsyBjb20gYSBtYXRyaXVzIGRlIHDDrXhlbHMgbyBkYWRlcyBkZSBwdW50cyBhbWIgZXNwYWlzIGlycmVndWxhcnMuIEVuIGFmZWdpciBhcXVlc3RzIGRhdGFzZXRzIGEgdW4gZGF0YXNldCBkZSBtb3NhaWMsIGxhIGZ1bmNpw7MgSW50ZXJwb2xhIGRhZGVzIGlycmVndWxhcnMgcHJlbiBsZXMgZGFkZXMgcXVhZHJpY3VsYWRlcyBpcnJlZ3VsYXJzIGkgbGVzIHRvcm5hIGEgbW9zdHJlamFyIHBlcnF1w6ggY2FkYSBww614ZWwgdGluZ3VpIHVuYSBtaWRhIHVuaWZvcm1lIGkgc2lndWkgcXVhZHJhdC48ZGl2Pjxici8+RW4gYWZlZ2lyIHZhcmlhYmxlcyBkZSBuZXRDREYgbyBIREYgYSB1biBkYXRhc2V0IGRlIG1vc2FpYywgZXMgdmVyaWZpY2Fyw6AgYXV0b23DoHRpY2FtZW50IHNpIGxlcyBkYWRlcyBzJ2hhbiBkaXNwb3NhdCBhIGxhIG1hdHJpdSBjb3JyZWN0YW1lbnQuIEVuIGNhcyBjb250cmFyaSwgbGEgZnVuY2nDsyBJbnRlcnBvbGEgZGFkZXMgaXJyZWd1bGFycyBzJ3V0aWxpdHphcsOgIHBlciBjb252ZXJ0aXIgbGVzIGRhZGVzIGlycmVndWxhcnMgZW4gdW4gcsOgc3RlciBxdWFkcmljdWxhdCByZWd1bGFyLiBQb2RldSBjYW52aWFyIGVsIG3DqHRvZGUgZCdpbnRlcnBvbGFjacOzIGkgbGEgbWlkYSBkZSBsYSBjZWzCt2xhIHF1ZSBzJ3V0aWxpdHplbiBhIGxhIGZ1bmNpw7MgZGUgcsOgc3RlciBJbnRlcnBvbGEgZGFkZXMgaXJyZWd1bGFycy4gRW4gZWwgY2FzIGRlIGxlcyBkYWRlcyBkZSByw6BzdGVyIGFtYiBlc3BhaXMgcmVndWxhcnMsIG5vIHMnYXBsaWNhcsOgIGNhcCBpbnRlcnBvbGFjacOzIGkgbGVzIGRhZGVzIGVzIGxsZWdpcmFuIHRhbCBxdWFsLjwvZGl2PlwiLFxuXHRcdGlzTnVsbE5hbWU6IFwiw4lzIG51bFwiLFxuXHRcdGlzTnVsbFNuaXA6IFwiRGV0ZXJtaW5hIHF1aW5zIHZhbG9ycyBkZWxzIHLDoHN0ZXJzIGQnZW50cmFkYSBzw7NuIE5vRGF0YSBjZWzCt2xhIHBlciBjZWzCt2xhLiBSZXRvcm5hIHVuIHZhbG9yIGQnMSBzaSBlbHMgdmFsb3JzIGQnZW50cmFkYSBzw7NuIE5vRGF0YSBpIGRlIDAgcGVyIGEgbGVzIGNlbMK3bGVzIHF1ZSBubyBwcmVzZW50ZW4gYXF1ZXN0IHZhbG9yLlwiLFxuXHRcdGlzTnVsbERlc2M6IFwiTGEgZnVuY2nDsyDDiXMgbnVsIGRldGVybWluYSBxdWlucyB2YWxvcnMgZGVsIHLDoHN0ZXIgZCdlbnRyYWRhIHPDs24gTm9EYXRhIHDDrXhlbCBwZXIgcMOteGVsLiBSZXRvcm5hIHVuIHZhbG9yIGQnMSBzaSBlbCB2YWxvciBkJ2VudHJhZGEgw6lzIE5vRGF0YSBpIHVuIHZhbG9yIGRlIDAgcGVyIGFscyBww614ZWxzIHF1ZSBubyBzw7NuIE5vRGF0YS5cIixcblx0XHRrZXJuZWxEZW5zaXR5TmFtZTogXCJEZW5zaXRhdCBkZWwgbnVjbGlcIixcblx0XHRrZXJuZWxEZW5zaXR5U25pcDogXCJBcXVlc3RhIGZ1bmNpw7MgY2FsY3VsYSB1bmEgw6ByZWEgZGUgbWFnbml0dWQgcGVyIHVuaXRhdCBkZXMgZGUgbGVzIGVudGl0YXRzIGRlIHB1bnQgbyBwb2xpbMOtbmlhIG1pdGphbsOnYW50IHVuYSBmdW5jacOzIGRlIG51Y2xpIHBlciBhanVzdGFyIHVuYSBzdXBlcmbDrWNpZSBzdWF1bWVudCBlc3RyZXRhIGEgY2FkYSBwdW50IG8gcG9saWzDrW5pYS5cIixcblx0XHRrZXJuZWxEZW5zaXR5RGVzYzogXCJBcXVlc3RhIGZ1bmNpw7MgY2FsY3VsYSB1bmEgw6ByZWEgZGUgbWFnbml0dWQgcGVyIHVuaXRhdCBkZXMgZGUgbGVzIGVudGl0YXRzIGRlIHB1bnQgbyBwb2xpbMOtbmlhIG1pdGphbsOnYW50IHVuYSBmdW5jacOzIGRlIG51Y2xpIHBlciBhanVzdGFyIHVuYSBzdXBlcmbDrWNpZSBzdWF1bWVudCBlc3RyZXRhIGEgY2FkYSBwdW50IG8gcG9saWzDrW5pYS5cIixcblx0XHRrZXlNZXRhZGF0YU5hbWU6IFwiTWV0YWRhZGVzIGNsYXVcIixcblx0XHRrZXlNZXRhZGF0YVNuaXA6IFwiSW52YWxpZGEgbyBpbnNlcmVpeCBtZXRhZGFkZXMgY2xhdSBkJ3VuIHLDoHN0ZXIgZW4gdW5hIGNhZGVuYSBkZSBmdW5jaW9ucy5cIixcblx0XHRrZXlNZXRhZGF0YURlc2M6IFwiQXF1ZXN0YSBmdW5jacOzIHVzIHBlcm1ldCBpbnNlcmlyIG8gaW52YWxpZGFyIG1ldGFkYWRlcyBjbGF1IGQndW4gcsOgc3Rlci48ZGl2Pjxici8+TGEgaW5mb3JtYWNpw7MgZGUgbGVzIG1ldGFkYWRlcyBjbGF1IHMndXRpbGl0emEgcGVyIGFqdWRhciBsJ2FwbGljYWNpw7MgYW1iIGFsZ3VuZXMgdGFzcXVlcyBkZSBwcm9jZXNzYW1lbnQgaSByZXByZXNlbnRhY2nDsywgaW5jbMOycyBlbCBzdWJtaW5pc3RyYW1lbnQgZCdhbGd1bmVzIGRhZGVzIMO6dGlscywgY29tIGFyYSBlbCBub20gZGVsIHNlbnNvciwgZWxzIG5vbXMgZGUgbGVzIGJhbmRlcyBvIGxhIGNvYmVydHVyYSBkZWwgbsO6dm9sLCBhc3NvY2lhZGVzIGEgbGVzIGltYXRnZXMuPC9kaXY+XCIsXG5cdFx0c2hvcnRlc3RQYXRoTmFtZTogXCJSdXRhIGRlIG1lbm9yIGNvc3RcIixcblx0XHRzaG9ydGVzdFBhdGhTbmlwOiBcIlJlYWxpdHphIHVuYSBhbsOgbGlzaSBkZSBjb3N0IGRlIGRpc3TDoG5jaWEgbWl0amFuw6dhbnQgbGVzIGVudHJhZGVzIGQnb3JpZ2VuIGkgZGVzdGluYWNpw7MsIHF1ZSBzJ3V0aWxpdHphcsOgIHBvc3Rlcmlvcm1lbnQgcGVyIGRldGVybWluYXIgbGEgcnV0YSBkZSBtZW5vciBjb3N0IGRlcyBkJ3VuIG9yaWdlbiBmaW5zIGEgdW5hIGRlc3RpbmFjacOzLlwiLFxuXHRcdHNob3J0ZXN0UGF0aERlc2M6IFwiTGEgZnVuY2nDsyBSdXRhIGRlIG1lbm9yIGNvc3QgY2FsY3VsYSBsYSBydXRhIGRlIG1lbm9yIGNvc3QgZGVzIGQndW4gb3JpZ2VuIGZpbnMgYSB1bmEgZGVzdGluYWNpw7MuIExhIGRpc3TDoG5jaWEgZGUgbWVub3IgY29zdCBhY3VtdWxhdGl1IGVzIGNhbGN1bGEgcGVyIGEgY2FkYSBww614ZWwgc29icmUgdW5hIHN1cGVyZsOtY2llIGRlIGNvc3QsIGZpbnMgYSBsJ29yaWdlbiBtw6lzIHByb3Blci4gR2VuZXJhIHVuIHLDoHN0ZXIgZGUgc29ydGlkYSBxdWUgcmVnaXN0cmEgbGEgcnV0YSBvIGxlcyBydXRlcyBkZSBtZW5vciBjb3N0IGRlcyBkZSBsZXMgdWJpY2FjaW9ucyBzZWxlY2Npb25hZGVzIGZpbnMgYWxzIHDDrXhlbHMgZCdvcmlnZW4gbcOpcyBwcm9wZXJzIGRlZmluaXRzIGEgbGEgc3VwZXJmw61jaWUgZGUgY29zdCBhY3VtdWxhdGl1LCBlbiB0ZXJtZXMgZGUgY29zdCBlbiBwbGEuPGRpdj48YnIvPlMnYXNzaWduYSB1biB2YWxvciBhIGNhZGEgcnV0YSBkZSBtZW5vciBjb3N0IHF1YW4gZXMgdHJvYmEgYWwgcHJvY8OpcyBkJ2VzY2FuZWlnLiBFbCBww614ZWwgZmluYWwgZGVsIHLDoHN0ZXIgZCdvcmlnZW4gZCd1bmEgcnV0YSBkZSBjb3N0IHJlcCB1biB2YWxvciBkJzEuIExhIHByaW1lcmEgcnV0YSByZXAgdW4gdmFsb3IgZGUgMywgbGEgc2Vnb25hIHJlcCB1biB2YWxvciBkZSA0IGkgYWl4w60gc3VjY2Vzc2l2YW1lbnQuIFF1YW4gZGl2ZXJzZXMgcnV0ZXMgZXMgZnVzaW9uZW4gaSBzZWd1ZWl4ZW4gbGEgZGlzdMOgbmNpYSByZXN0YW50IGZpbnMgYSB1biBvcmlnZW4gZGUgbGEgbWF0ZWl4YSBydXRhLCBhbCBzZWdtZW50IG9uIGxlcyBkdWVzIHJ1dGVzIHZpYXRnZW4ganVudGVzIHNlIGxpIGFzc2lnbmEgdW4gdmFsb3IgZGUgMi4gQSBsYSBwYXJ0IGZ1c2lvbmFkYSBkZSBsYSBydXRhIG5vIHNlIGxpIHBvdCBhc3NpZ25hciBlbCB2YWxvciBkJ3VuYSBkZSBsZXMgcnV0ZXMgcGVycXXDqCBhcXVlc3RhIHBhcnQgcGVydGFueSBhIGFtYmR1ZXMgcnV0ZXMuPC9kaXY+XCIsXG5cdFx0bGVzc1RoYW5FcXVhbE5hbWU6IFwiTWVub3IgbyBpZ3VhbCBxdWVcIixcblx0XHRsZXNzVGhhbkVxdWFsU25pcDogXCJSZWFsaXR6YSB1bmEgb3BlcmFjacOzIGQnaW5mZXJpb3JpdGF0IG8gaWd1YWx0YXQgcmVsYWNpb25hbCBlbiBkdWVzIGVudHJhZGVzIGNlbMK3bGEgcGVyIGNlbMK3bGEuIFJldG9ybmEgZWwgdmFsb3IgMSBwZXIgYSBsZXMgY2VswrdsZXMgb24gZWwgcHJpbWVyIHLDoHN0ZXIgw6lzIG1lbm9yIG8gaWd1YWwgcXVlIGVsIHNlZ29uIGkgZWwgdmFsb3IgMCBzaSBubyBobyDDqXMuXCIsXG5cdFx0bGVzc1RoYW5FcXVhbERlc2M6IFwiTGEgZnVuY2nDsyByZWFsaXR6YSB1bmEgb3BlcmFjacOzIGQnaW5mZXJpb3JpdGF0IG8gaWd1YWx0YXQgcmVsYWNpb25hbCBlbiBkdWVzIGVudHJhZGVzIHDDrXhlbCBwZXIgcMOteGVsLiBSZXRvcm5hIHVuIHZhbG9yIGQnMSBwZXIgYWxzIHDDrXhlbHMgb24gZWwgcHJpbWVyIHLDoHN0ZXIgw6lzIG1lbm9yIG8gaWd1YWwgcXVlIGVsIHNlZ29uIGkgdW4gdmFsb3IgZGUgMCBwZXIgYWxzIHDDrXhlbHMgb24gZWwgcHJpbWVyIHLDoHN0ZXIgbm8gw6lzIG1lbm9yIG5pIGlndWFsIHF1ZSBlbCBzZWdvbi5cIixcblx0XHRsZXNzVGhhbk5hbWU6IFwiTWVub3IgcXVlXCIsXG5cdFx0bGVzc1RoYW5TbmlwOiBcIlJlYWxpdHphIHVuYSBvcGVyYWNpw7MgZCdpbmZlcmlvcml0YXQgcmVsYWNpb25hbCBlbiBkdWVzIGVudHJhZGVzIGNlbMK3bGEgcGVyIGNlbMK3bGEuIFJldG9ybmEgZWwgdmFsb3IgMSBwZXIgYSBsZXMgY2VswrdsZXMgb24gZWwgcHJpbWVyIHLDoHN0ZXIgw6lzIG1lbm9yIHF1ZSBlbCBzZWdvbiBpIGVsIHZhbG9yIDAgc2kgbm8gaG8gw6lzLlwiLFxuXHRcdGxlc3NUaGFuRGVzYzogXCJMYSBmdW5jacOzIHJlYWxpdHphIHVuYSBvcGVyYWNpw7MgZCdpbmZlcmlvcml0YXQgcmVsYWNpb25hbCBlbiBkdWVzIGVudHJhZGVzIHDDrXhlbCBwZXIgcMOteGVsLiBSZXRvcm5hIHVuIHZhbG9yIGQnMSBwZXIgYWxzIHDDrXhlbHMgb24gZWwgcHJpbWVyIHLDoHN0ZXIgw6lzIG1lbm9yIHF1ZSBlbCBzZWdvbiBpIHVuIHZhbG9yIGRlIDAgcGVyIGFscyBww614ZWxzIG9uIGVsIHByaW1lciByw6BzdGVyIG5vIMOpcyBtZW5vciBxdWUgZWwgc2Vnb24uXCIsXG5cdFx0bG5OYW1lOiBcIkxvZ2FyaXRtZSBuZXBlcmnDoCAoTG4pXCIsXG5cdFx0bG5TbmlwOiBcIkNhbGN1bGEgZWwgbG9nYXJpdG1lIG5hdHVyYWwgKGJhc2UgZSkgZGUgbGVzIGNlbMK3bGVzIGQndW4gcsOgc3Rlci5cIixcblx0XHRsbkRlc2M6IFwiTGEgZnVuY2nDsyBMb2dhcml0bWUgbmVwZXJpw6AgKExuKSBjYWxjdWxhIGVsIGxvZ2FyaXRtZSBuYXR1cmFsIChiYXNlIGUpIGRlIGNhZGEgcMOteGVsIGQndW4gcsOgc3Rlci5cIixcblx0XHRsb2cxME5hbWU6IFwiTG9nYXJpdG1lIGVuIGJhc2UgMTAgKExvZzEwKVwiLFxuXHRcdGxvZzEwU25pcDogXCJDYWxjdWxhIGVsIGxvZ2FyaXRtZSBlbiBiYXNlIDEwIGRlIGxlcyBjZWzCt2xlcyBkJ3VuIHLDoHN0ZXIuXCIsXG5cdFx0bG9nMTBEZXNjOiBcIkxhIGZ1bmNpw7MgTG9nYXJpdG1lIGVuIGJhc2UgMTAgKExvZzEwKSBjYWxjdWxhIGVsIGxvZ2FyaXRtZSBlbiBiYXNlIDEwIGRlIGNhZGEgcMOteGVsIGQndW4gcsOgc3Rlci5cIixcblx0XHRsb2cyTmFtZTogXCJMb2dhcml0bWUgZW4gYmFzZSAyIChsb2cyKVwiLFxuXHRcdGxvZzJTbmlwOiBcIkNhbGN1bGEgZWwgbG9nYXJpdG1lIGVuIGJhc2UgMiBkZSBsZXMgY2VswrdsZXMgZCd1biByw6BzdGVyLlwiLFxuXHRcdGxvZzJEZXNjOiBcIkxhIGZ1bmNpw7MgTG9nYXJpdG1lIGVuIGJhc2UgMiAobG9nMikgY2FsY3VsYSBlbCBsb2dhcml0bWUgZW4gYmFzZSAyIGRlIGNhZGEgcMOteGVsIGQndW4gcsOgc3Rlci5cIixcblx0XHRsb29rdXBOYW1lOiBcIkNlcmNhXCIsXG5cdFx0bG9va3VwU25pcDogXCJDcmVhIHVuIG5vdSByw6BzdGVyIG1pdGphbsOnYW50IGxhIGNlcmNhIGRlbHMgdmFsb3JzIHF1ZSBlcyB0cm9iZW4gZW4gdW4gYWx0cmUgY2FtcCBkZSBsYSB0YXVsYSBkZWwgcsOgc3RlciBkJ2VudHJhZGEuXCIsXG5cdFx0bG9va3VwRGVzYzogXCJMYSBmdW5jacOzIGNyZWEgdW4gbm91IHLDoHN0ZXIgbWl0amFuw6dhbnQgbGEgY2VyY2EgZGVscyB2YWxvcnMgcXVlIGVzIHRyb2JlbiBlbiB1biBhbHRyZSBjYW1wIGRlIGxhIHRhdWxhIGRlbCByw6BzdGVyIGQnZW50cmFkYS5cIixcblx0XHRtbENsYXNzaWZ5TmFtZTogXCJDbGFzc2lmaWNhY2nDsyBNTFwiLFxuXHRcdG1sQ2xhc3NpZnlTbmlwOiBcIkNsYXNzaWZpY2EgbGVzIGltYXRnZXMgbWl0amFuw6dhbnQgdW4gcGxhbnRlamFtZW50IHBlciBww614ZWwuIEVscyBww614ZWxzIGNvbWJpbmF0cyBzJ2Fzc2lnbmVuIGEgbCdlbnRpdGF0IGFtYiBlbCBwZXJjZW50YXRnZSBtw6lzIGFsdCBkZWwgcMOteGVsLlwiLFxuXHRcdG1sQ2xhc3NpZnlEZXNjOiBcIkxhIGZ1bmNpw7MgQ2xhc3NpZmljYWNpw7MgTUwgdXMgcGVybWV0IHJlYWxpdHphciB1bmEgY2xhc3NpZmljYWNpw7Mgc3VwZXJ2aXNhZGEsIG1pdGphbsOnYW50IGwnYWxnb3JpdG1lIGRlIGNsYXNzaWZpY2FjacOzIGRlIG3DoHhpbWEgdmVyc2VtYmxhbsOnYSwgZW4gdW4gZGF0YXNldCBkZSByw6BzdGVyIG8gdW4gZGF0YXNldCBkZSBtb3NhaWMuIEFxdWVzdGEgZnVuY2nDsyBuZWNlc3NpdGEgdW4gZml0eGVyIGRlIHNpZ25hdHVyYSBkZSBjbGFzc2lmaWNhY2nDsy5cIixcblx0XHRtYXNrTmFtZTogXCJNw6BzY2FyYVwiLFxuXHRcdG1hc2tTbmlwOiBcIkRlZmluZWl4IGVscyB2YWxvcnMgcXVlIG5vIHZvbGV1IG1vc3RyYXIuXCIsXG5cdFx0bWFza0Rlc2M6IFwiQXF1ZXN0YSBmdW5jacOzIGRlIHLDoHN0ZXIgZGVmaW5laXggZWxzIHZhbG9ycyBxdWUgbm8gdm9sZXUgbW9zdHJhciBhbCB2b3N0cmUgcsOgc3Rlci4gQW1iIGxhIGZ1bmNpw7MgTcOgc2NhcmEsIGVzcGVjaWZpY2FyZXUgdW4gbyBkaXZlcnNvcyB2YWxvcnMgTm9EYXRhLCBvIGLDqSB1biBpbnRlcnZhbCBkZSB2YWxvcnMgZGUgcMOteGVsIHbDoGxpZHMuIFwiLFxuXHRcdG1pbnVzTmFtZTogXCJSZXN0YVwiLFxuXHRcdG1pbnVzU25pcDogXCJSZXN0YSBlbCB2YWxvciBkZWwgc2Vnb24gcsOgc3RlciBkJ2VudHJhZGEgZGVsIHZhbG9yIGRlbCBwcmltZXIgcsOgc3RlciBkJ2VudHJhZGEgcMOteGVsIHBlciBww614ZWwuXCIsXG5cdFx0bWludXNEZXNjOiBcIkxhIGZ1bmNpw7MgUmVzdGEgc29zdHJldSBlbCB2YWxvciBkZWwgc2Vnb24gcsOgc3RlciBkJ2VudHJhZGEgZGVsIHZhbG9yIGRlbCBwcmltZXIgcsOgc3RlciBkJ2VudHJhZGEgcMOteGVsIHBlciBww614ZWwuXCIsXG5cdFx0bW9kTmFtZTogXCJNw7JkdWxcIixcblx0XHRtb2RTbmlwOiBcIkNlcmNhIGxhIHJlc3RhIChtw7JkdWwpIGRlbCBwcmltZXIgcsOgc3RlciBxdWFuIGVzIGRpdmlkZWl4IHBlbCBzZWdvbiByw6BzdGVyIGNlbMK3bGEgcGVyIGNlbMK3bGEuXCIsXG5cdFx0bW9kRGVzYzogXCJMYSBmdW5jacOzIE3DsmR1bCBjZXJjYSBsYSByZXN0YSAobcOyZHVsKSBkZWwgcHJpbWVyIHLDoHN0ZXIgcXVhbiBlcyBkaXZpZGVpeCBwZWwgc2Vnb24gcsOgc3RlciBww614ZWwgcGVyIHDDrXhlbC4gTCdvcmRyZSBkZSBsZXMgZW50cmFkZXMgw6lzIGltcG9ydGFudCBpIGFmZWN0YSBlbCByZXN1bHRhdCBkZSBzb3J0aWRhLlwiLFxuXHRcdG1vc2FpY1Jhc3RlcnNOYW1lOiBcIlLDoHN0ZXJzIGRlIG1vc2FpY1wiLFxuXHRcdG1vc2FpY1Jhc3RlcnNTbmlwOiBcIlVuZWl4IHVuIGNvbmp1bnQgZGUgZGF0YXNldHMgZGUgcsOgc3RlciBwZXIgY3JlYXIgdW4gZGF0YXNldC5cIixcblx0XHRtb3NhaWNSYXN0ZXJzRGVzYzogXCJMYSBmdW5jacOzIFLDoHN0ZXJzIGRlIG1vc2FpYyBjcmVhIHVuYSBpbWF0Z2UgZGUgbW9zYWljIGEgcGFydGlyIGRlIGRpdmVyc2VzIGltYXRnZXMuIFNpIGhpIGhhIHN1cGVycG9zaWNpw7MgZW50cmUgbGVzIGltYXRnZXMsIHBvZGV1IHRyaWFyIGVudHJlIGRpdmVyc29zIG3DqHRvZGVzIHBlciBkZXRlcm1pbmFyIHF1aW5lcyBlcyBtb3N0cmFyYW4uXCIsXG5cdFx0bmR2aUNvbG9yaXplZE5hbWU6IFwiTkRWSSBlbiBjb2xvclwiLFxuXHRcdG5kdmlDb2xvcml6ZWRTbmlwOiBcIkNyZWEgdW4gZGF0YXNldCBtdWx0aWJhbmRhIHF1ZSByZXByZXNlbnRhIGwnZXN0YXQgZGUgbGEgdmVnZXRhY2nDsyBzZWdvbnMgbGEgZGlmZXLDqG5jaWEgZW50cmUgbGEgYmFuZGEgZCdpbmZyYXJvam9zIHZlcm1lbGxhIGkgbGVzIHByb3BlcmVzLlwiLFxuXHRcdG5kdmlDb2xvcml6ZWREZXNjOiBcIkxhIGZ1bmNpw7MgTkRWSSBlbiBjb2xvciBhcGxpY2EgbGEgZnVuY2nDsyBORFZJIGEgbGEgaW1hdGdlIGQnZW50cmFkYSBpLCBhIGNvbnRpbnVhY2nDsywgdXRpbGl0emEgdW4gbWFwYSBkZSBjb2xvciBvIHVuYSByYW1wYSBkZSBjb2xvciBwZXIgbW9zdHJhciBlbCByZXN1bHRhdC5cIixcblx0XHRuZHZpTmFtZTogXCJORFZJXCIsXG5cdFx0bmR2aVNuaXA6IFwiQ2FsY3VsYSBsJ8OtbmRleCBkZSB2ZWdldGFjacOzIGFtYiBkaWZlcsOobmNpYSBub3JtYWxpdHphZGEgKE5EVkkpLlwiLFxuXHRcdG5kdmlEZXNjOiBcIkxhIGZ1bmNpw7MgTkRWSSBjcmVhIHVuIGRhdGFzZXQgZCd1bmEgYmFuZGEgcXVlIHJlcHJlc2VudGEgbCdlc3RhdCBkZSBsYSB2ZWdldGFjacOzIHNlZ29ucyBsYSBkaWZlcsOobmNpYSBlbnRyZSBsYSBiYW5kYSB2ZXJtZWxsYSBpIGxhIGQnaW5mcmFyb2lnIHByb3Blci48ZGl2Pjxici8+TkRWSSDDqXMgdW4gw61uZGV4IGVzdGFuZGFyZGl0emF0IHF1ZSB1cyBwZXJtZXQgZ2VuZXJhciB1bmEgaW1hdGdlIHF1ZSBtb3N0cmkgbGEgdmVyZG9yLCB0YW1iw6kgY29uZWd1ZGEgY29tIGJpb21hc3NhIHJlbGF0aXZhLiBBcXVlc3Qgw61uZGV4IGFwcm9maXRhIGVsIGNvbnRyYXN0IGRlIGxlcyBjYXJhY3RlcsOtc3RpcXVlcyBlbnRyZSBkdWVzIGJhbmRlcyBkJ3VuIGRhdGFzZXQgcsOgc3RlciBtdWx0aWVzcGVjdHJhbDogbCdhYnNvcmNpw7MgZGUgcGlnbWVudCBkZSBjbG9yb2ZpbMK3bGEgZGUgbGEgYmFuZGEgdmVybWVsbGEgaSBsJ2FsdHJhIHJlZmxlY3Rpdml0YXQgZGVsIG1hdGVyaWFsIGRlIGxlcyBwbGFudGVzIGRlIGxhIGJhbmRhIGQnaW5mcmFyb2lnIHByb3BlciAoTklSKS4gRWxzIHZhbG9ycyBkJ05EVkkgZXh0cmVtYWRhbWVudCBiYWl4b3MgbyBuZWdhdGl1cyByZXByZXNlbnRlbiBsZXMgw6ByZWVzIHNlbnNlIHJlcyBkZSB2ZWdldGFjacOzLCBjb20gYXJhIG7DunZvbHMsIGFpZ3VhIG8gbmV1LiBFbHMgdmFsb3JzIG1vbHQgYmFpeG9zIHJlcHJlc2VudGVuIMOgcmVlcyBzZW5zZSB2ZWdldGFjacOzIG8gYW1iIHZlZ2V0YWNpw7MgZXNjYXNzYSwgY29tIGFyYSBjaW1lbnQsIHJvcXVlcyBvIHPDsmwgbnUuIEVscyB2YWxvcnMgbW9kZXJhdHMgcmVwcmVzZW50ZW4gem9uZXMgZCdhcmJ1c3RvcyBpIHByYXRzLiBFbHMgdmFsb3JzIGFsdHMgcmVwcmVzZW50ZW4gw6ByZWVzIGZvcmVzdGFscyBpIHZlZ2V0YWNpw7MgYWJ1bmRhbnQuPC9kaXY+XCIsXG5cdFx0bmVnYXRlTmFtZTogXCJDYW52aSBkZSBzaWduZVwiLFxuXHRcdG5lZ2F0ZVNuaXA6IFwiQ2FudmlhIGVsIHNpZ25lIChtdWx0aXBsaWNhIHBlciAtMSkgZGVscyB2YWxvcnMgZGUgY2VswrdsYSBkZWwgcsOgc3RlciBkJ2VudHJhZGEgY2VswrdsYSBwZXIgY2VswrdsYS5cIixcblx0XHRuZWdhdGVEZXNjOiBcIkxhIGZ1bmNpw7MgQ2FudmkgZGUgc2lnbmUgY2FudmlhIGVsIHNpZ25lIChtdWx0aXBsaWNhIHBlciAtMSkgZGVscyB2YWxvcnMgZGUgcMOteGVsIGRlbCByw6BzdGVyIGQnZW50cmFkYSBlbiB1biBww614ZWwgXCIsXG5cdFx0bmliYmxlTmFtZTogXCJOaWJibGVcIixcblx0XHRuaWJibGVTbmlwOiBcIlN1YnN0aXR1ZWl4IGxlcyBjZWzCt2xlcyBkJ3VuIHLDoHN0ZXIgY29ycmVzcG9uZW50IGEgdW5hIG3DoHNjYXJhIGFtYiBlbHMgdmFsb3JzIGRlbHMgdmXDr25zIG3DqXMgcHJvcGVycy5cIixcblx0XHRuaWJibGVEZXNjOiBcIkxhIGZ1bmNpw7MgTmliYmxlIGdsb2JhbCBwZXJtZXQgYXNzaWduYXIgYSBsZXMgw6ByZWVzIHNlbGVjY2lvbmFkZXMgZCd1biByw6BzdGVyIGVsIHZhbG9yIGRlbCB2ZcOtIG3DqXMgcHJvcGVyLiBSZXN1bHRhIMO6dGlsIHBlciBlZGl0YXIgbGVzIMOgcmVlcyBkJ3VuIHLDoHN0ZXIgb24gbGVzIGRhZGVzIHBvZGVuIHNlciBlcnLDsm5pZXMuXCIsXG5cdFx0bm90RXF1YWxOYW1lOiBcIk5vIGlndWFsXCIsXG5cdFx0bm90RXF1YWxTbmlwOiBcIlJlYWxpdHphIHVuYSBvcGVyYWNpw7MgZGUgZGVzaWd1YWx0YXQgcmVsYWNpb25hbCBlbiBkdWVzIGVudHJhZGVzIGNlbMK3bGEgcGVyIGNlbMK3bGEuIFJldG9ybmEgZWwgdmFsb3IgMSBwZXIgYSBsZXMgY2VswrdsZXMgb24gZWwgcHJpbWVyIHLDoHN0ZXIgbm8gw6lzIGlndWFsIHF1ZSBlbCBzZWdvbiBpIGVsIHZhbG9yIDAgb24gc8OtIHF1ZSBobyDDqXMuXCIsXG5cdFx0bm90RXF1YWxEZXNjOiBcIkxhIGZ1bmNpw7MgcmVhbGl0emEgdW5hIG9wZXJhY2nDsyBkZSBkZXNpZ3VhbHRhdCByZWxhY2lvbmFsIGVuIGR1ZXMgZW50cmFkZXMgcMOteGVsIHBlciBww614ZWwuIFJldG9ybmEgdW4gdmFsb3IgZCcxIHBlciBhbHMgcMOteGVscyBvbiBlbCBwcmltZXIgcsOgc3RlciBubyDDqXMgaWd1YWwgcXVlIGVsIHNlZ29uIGkgdW4gdmFsb3IgZGUgMCBwZXIgYWxzIHDDrXhlbHMgb24gZWwgcHJpbWVyIHLDoHN0ZXIgw6lzIGlndWFsIHF1ZSBlbCBzZWdvbi5cIixcblx0XHRwYW5zaGFycGVuaW5nTmFtZTogXCJFbmZvY2FtZW50IHBhbmNyb23DoHRpY1wiLFxuXHRcdHBhbnNoYXJwZW5pbmdTbmlwOiBcIk1pbGxvcmEgZGUgbWFuZXJhIGFydGlmaWNpYWwgbGEgcmVzb2x1Y2nDsyBlc3BhY2lhbCBkJ3VuYSBpbWF0Z2UgbXVsdGliYW5kYSBmdXNpb25hbnQtbGEgYW1iIHVuYSBpbWF0Z2UgcGFuY3JvbcOgdGljYSBkZSByZXNvbHVjacOzIHN1cGVyaW9yLlwiLFxuXHRcdHBhbnNoYXJwZW5pbmdEZXNjOiBcIkxhIGZ1bmNpw7MgRW5mb2NhbWVudCBwYW5jcm9tw6B0aWMgdXRpbGl0emEgdW5hIGltYXRnZSBwYW5jcm9tw6B0aWNhIGQnYWx0YSByZXNvbHVjacOzIG8gdW5hIGJhbmRhIGRlIHLDoHN0ZXIgcGVyIGZ1c2lvbmFyLWxhIGFtYiB1biBkYXRhc2V0IHLDoHN0ZXIgbXVsdGliYW5kYSBkZSBiYWl4YSByZXNvbHVjacOzIGEgZmkgZCdhdWdtZW50YXIgbGEgcmVzb2x1Y2nDsyBlc3BhY2lhbCBkZSBsYSBpbWF0Z2UgbXVsdGliYW5kYS48ZGl2Pjxici8+TGEgZmluYWxpdGF0IGRlIGwnZW5mb2NhbWVudCBwYW5jcm9tw6B0aWMgw6lzIGNyZWFyIHVuYSBpbWF0Z2UgdmlzdWFsIGRlIHF1YWxpdGF0IHN1cGVyaW9yLiBBdMOocyBxdWUgbGVzIHTDqGNuaXF1ZXMgYWx0ZXJlbiBsYSByYWRpb21ldHJpYSBpIGxlcyBjYXJhY3RlcsOtc3RpcXVlcyBlc3BlY3RyYWxzIGRlIGxlcyBpbWF0Z2VzIG11bHRpYmFuZGEsIGxlcyBpbWF0Z2VzIGFtYiBlbmZvY2FtZW50IHBhbmNyb23DoHRpYyBzJ2hhbiBkJ3V0aWxpdHphciBhbWIgcHJlY2F1Y2nDsyBwZXIgYSBsZXMgZmluYWxpdGF0cyBkZSB0ZWxlZGV0ZWNjacOzIGFuYWzDrXRpY2EuPC9kaXY+XCIsXG5cdFx0cGF0aEFsbG9jYXRpb25OYW1lOiBcIkFzc2lnbmFjacOzIGRlIGRpc3TDoG5jaWEgZGUgcnV0YVwiLFxuXHRcdHBhdGhBbGxvY2F0aW9uU25pcDogXCJMYSBmdW5jacOzIEFzc2lnbmFjacOzIGRlIGRpc3TDoG5jaWEgZGUgcnV0YSBjYWxjdWxhIGwnb3JpZ2VuIG3DqXMgcHJvcGVyIHBlciBhIGNhZGEgY2VswrdsYSBlbiBmdW5jacOzIGRlbCBtZW5vciBjb3N0IGFjdW11bGF0aXUgc29icmUgdW5hIHN1cGVyZsOtY2llIGRlIGNvc3QsIGFsaG9yYSBxdWUgdMOpIGVuIGNvbXB0ZSBsYSBkaXN0w6BuY2lhIGRlIHN1cGVyZsOtY2llIGkgZWxzIGZhY3RvcnMgZGUgY29zdCBob3JpdHpvbnRhbCBpIHZlcnRpY2FsLlwiLFxuXHRcdHBhdGhBbGxvY2F0aW9uRGVzYzogXCJMYSBmdW5jacOzIEFzc2lnbmFjacOzIGRlIGRpc3TDoG5jaWEgZGUgcnV0YSBjYWxjdWxhIGwnb3JpZ2VuIG3DqXMgcHJvcGVyIHBlciBhIGNhZGEgY2VswrdsYSBlbiBmdW5jacOzIGRlbCBtZW5vciBjb3N0IGFjdW11bGF0aXUgc29icmUgdW5hIHN1cGVyZsOtY2llIGRlIGNvc3QsIGFsaG9yYSBxdWUgdMOpIGVuIGNvbXB0ZSBsYSBkaXN0w6BuY2lhIGRlIHN1cGVyZsOtY2llIGkgZWxzIGZhY3RvcnMgZGUgY29zdCBob3JpdHpvbnRhbCBpIHZlcnRpY2FsLlwiLFxuXHRcdHBhdGhCYWNrTGlua05hbWU6IFwiRW5sbGHDpyBkZSBtZW5vciBkaXN0w6BuY2lhIGRlIHJ1dGFcIixcblx0XHRwYXRoQmFja0xpbmtTbmlwOiBcIkRlZmluZWl4IGVsIHZlw60gcXVlIMOpcyBsYSBjZWzCt2xhIHNlZ8O8ZW50IGEgbGEgcnV0YSBkZSBtZW5vciBjb3N0IGFjdW11bGF0aXUgYSBsJ29yaWdlbiBkZSBtZW5vciBjb3N0LCBhbGhvcmEgcXVlIHTDqSBlbiBjb21wdGUgbGEgZGlzdMOgbmNpYSBkZSBzdXBlcmbDrWNpZSwganVudGFtZW50IGFtYiBlbHMgZmFjdG9ycyBkZSBjb3N0IGhvcml0em9udGFsIGkgdmVydGljYWwuXCIsXG5cdFx0cGF0aEJhY2tMaW5rRGVzYzogXCJMYSBmdW5jacOzIEVubGxhw6cgZGUgbWVub3IgZGlzdMOgbmNpYSBkZSBydXRhIGlkZW50aWZpY2EgbGEgZGlyZWNjaW9uYWxpdGF0IGRlbCB2ZcOtIHF1ZSDDqXMgbGEgY2VswrdsYSBzZWfDvGVudCBhIGxhIHJ1dGEgZGUgbWVub3IgY29zdCBhY3VtdWxhdGl1IGEgbCdvcmlnZW4gbcOpcyBwcm9wZXIsIGFsaG9yYSBxdWUgdMOpIGVuIGNvbXB0ZSBsYSBkaXN0w6BuY2lhIGRlIHN1cGVyZsOtY2llIGkgZWxzIGZhY3RvcnMgZGUgY29zdCBob3JpdHpvbnRhbCBpIHZlcnRpY2FsLlwiLFxuXHRcdHBhdGhEaXN0YW5jZU5hbWU6IFwiRGlzdMOgbmNpYSBkZSBydXRhXCIsXG5cdFx0cGF0aERpc3RhbmNlU25pcDogXCJDYWxjdWxhLCBwZXIgYSBjYWRhIGNlbMK3bGEsIGxhIGRpc3TDoG5jaWEgZGUgbWVub3IgY29zdCBhY3VtdWxhdGl1IGRlcyBkZSBvIGZpbnMgYSBsJ29yaWdlbiBkZSBtZW5vciBjb3N0LCBhbGhvcmEgcXVlIHTDqSBlbiBjb21wdGUgbGEgZGlzdMOgbmNpYSBkZSBzdXBlcmbDrWNpZSwganVudGFtZW50IGFtYiBlbHMgZmFjdG9ycyBkZSBjb3N0IGhvcml0em9udGFsIGkgdmVydGljYWwuXCIsXG5cdFx0cGF0aERpc3RhbmNlRGVzYzogXCJMYSBmdW5jacOzIERpc3TDoG5jaWEgZGUgcnV0YSBjYWxjdWxhLCBwZXIgYSBjYWRhIGNlbMK3bGEsIGxhIGRpc3TDoG5jaWEgZGUgbWVub3IgY29zdCBhY3VtdWxhdGl1IGEgbCdvcmlnZW4gbcOpcyBwcm9wZXIsIGFsaG9yYSBxdWUgdMOpIGVuIGNvbXB0ZSBsYSBkaXN0w6BuY2lhIGRlIHN1cGVyZsOtY2llIGkgZWxzIGZhY3RvcnMgZGUgY29zdCBob3JpdHpvbnRhbCBpIHZlcnRpY2FsLlwiLFxuXHRcdHBsdXNOYW1lOiBcIlBsdXNcIixcblx0XHRwbHVzU25pcDogXCJBZmVnZWl4IChzdW1hKSBlbHMgdmFsb3JzIGRlIGRvcyByw6BzdGVycyBjZWzCt2xhIHBlciBjZWzCt2xhLlwiLFxuXHRcdHBsdXNEZXNjOiBcIkxhIGZ1bmNpw7MgU3VtYSBhZmVnZWl4IGVscyB2YWxvcnMgZGUgZG9zIHLDoHN0ZXJzIHDDrXhlbCBwZXIgcMOteGVsLlwiLFxuXHRcdHBvd2VyTmFtZTogXCJQb3TDqG5jaWFcIixcblx0XHRwb3dlclNuaXA6IFwiRWxldmEgZWxzIHZhbG9ycyBkZSBjZWzCt2xhIGQndW4gcsOgc3RlciBhIGxhIHBvdMOobmNpYSBkZWxzIHZhbG9ycyBxdWUgZXMgdHJvYmVuIGVuIHVuIGFsdHJlIHLDoHN0ZXIuXCIsXG5cdFx0cG93ZXJEZXNjOiBcIkxhIGZ1bmNpw7MgUG90w6huY2lhIGVsZXZhIGVscyB2YWxvcnMgZGUgcMOteGVsIGQndW4gcsOgc3RlciBhIGxhIHBvdMOobmNpYSBkZWxzIHZhbG9ycyBxdWUgZXMgdHJvYmVuIGVuIHVuIGFsdHJlIHLDoHN0ZXIuXCIsXG5cdFx0cmFkYXJDYWxpYnJhdGlvbk5hbWU6IFwiQ2FsaWJyYXRnZSBkZSByYWRhclwiLFxuXHRcdHJhZGFyQ2FsaWJyYXRpb25TbmlwOiBcIkNvbnZlcnRlaXggbGEgcmV0cm9kaXNwZXJzacOzIGRlIFJBREFSU0FULTIuXCIsXG5cdFx0cmFkYXJDYWxpYnJhdGlvbkRlc2M6IFwiQXF1ZXN0YSBmdW5jacOzIGVzIHBvdCB1dGlsaXR6YXIgcGVyIGNhbGlicmFyIGltYXRnZXMgUkFEQVJTREFULTIgZW4gdW4gZGF0YXNldCBkZSBtb3NhaWMgbyBjb20gdW4gcHJvZHVjdGUgcsOgc3Rlci4gRWwgY2FsaWJyYXRnZSBlcyByZWFsaXR6YSBlbiBpbWF0Z2VzIGRlIHJhZGFyIHBlcnF1w6ggZWxzIHZhbG9ycyBkZSBww614ZWwgc2lndWluIHVuYSByZXByZXNlbnRhY2nDsyByZWFsIGRlIGxhIHJldHJvZGlzcGVyc2nDsyBkZSByYWRhci5cIixcblx0XHRyYXN0ZXJJbmZvTmFtZTogXCJJbmZvcm1hY2nDsyBkZWwgcsOgc3RlclwiLFxuXHRcdHJhc3RlckluZm9TbmlwOiBcIk1vZGlmaWNhIGxlcyBwcm9waWV0YXRzIGRlbCByw6BzdGVyLCBjb20gYXJhIGxhIHByb2Z1bmRpdGF0IGRlIGJpdHMsIGVsIHZhbG9yIE5vRGF0YSwgbGEgbWlkYSBkZSBsYSBjZWzCt2xhLCBldGMuXCIsXG5cdFx0cmFzdGVySW5mb0Rlc2M6IFwiTGEgZnVuY2nDsyBJbmZvcm1hY2nDsyBkZWwgcsOgc3RlciBvYnJlIHVuIHF1YWRyZSBkZSBkacOgbGVnIGFtYiBwcm9waWV0YXRzIGRlbCBkYXRhc2V0IHLDoHN0ZXIsIGNvbSBhcmEgZWwgbm9tYnJlIGRlIGNvbHVtbmVzIGkgZmlsZXMsIGVsIG5vbWJyZSBkZSBiYW5kZXMsIGVsIHRpcHVzIGRlIHDDrXhlbCwgbCdleHRlbnNpw7MgaSBsYSByZWZlcsOobmNpYSBlc3BhY2lhbC4gUGVyIGVkaXRhciBhcXVlc3RlcyBwcm9waWV0YXRzLCBwb2RldSBzZWxlY2Npb25hciB1biBkYXRhc2V0IHLDoHN0ZXIgcGVyIHV0aWxpdHphci1sbyBjb20gdW5hIHBsYW50aWxsYS4gXCIsXG5cdFx0cmFzdGVyaXplQXR0cmlidXRlc05hbWU6IFwiUmFzdGVyaXR6YSBhdHJpYnV0c1wiLFxuXHRcdHJhc3Rlcml6ZUF0dHJpYnV0ZXNTbmlwOiBcIkVucmlxdWVpeCB1biByw6BzdGVyIG1pdGphbsOnYW50IGJhbmRlcyBhZGRpY2lvbmFscyBkZXJpdmFkZXMgZGVscyB2YWxvcnMgZGVscyBhdHJpYnV0cyBlc3BlY2lmaWNhdHMgZCd1bmEgdGF1bGEgZXh0ZXJuYSBvIHVuIHNlcnZlaSBkJ2VudGl0YXRzLlwiLFxuXHRcdHJhc3Rlcml6ZUF0dHJpYnV0ZXNEZXNjOiBcIkxhIGZ1bmNpw7MgUmFzdGVyaXR6YSBhdHJpYnV0cyBlbnJpcXVlaXggdW4gcsOgc3RlciBtaXRqYW7Dp2FudCBsJ2FkZGljacOzIGRlIGJhbmRlcyBkZXJpdmFkZXMgZGVscyB2YWxvcnMgZGVscyBhdHJpYnV0cyBlc3BlY2lmaWNhdHMgZCd1bmEgdGF1bGEgZXh0ZXJuYSBvIHVuIHNlcnZlaSBkJ2VudGl0YXRzLiBUYW1iw6kgcG9kZXUgZXNwZWNpZmljYXIgdW4gcsOgc3RlciBkZSB6b25hIGkgbCdhdHJpYnV0IGQnSUQgZGUgem9uYSBhc3NvY2lhdCBwZXIgYWN0aXZhciBsYSBjZXJjYSBiYXNhZGEgZW4gbGEgcmVnacOzLlwiLFxuXHRcdHJhc3Rlcml6ZUZlYXR1cmVDbGFzc05hbWU6IFwiUmFzdGVyaXR6YSBlbnRpdGF0c1wiLFxuXHRcdHJhc3Rlcml6ZUZlYXR1cmVDbGFzc1NuaXA6IFwiQ29udmVydGVpeCBlbnRpdGF0cyBlbiByw6BzdGVycy5cIixcblx0XHRyYXN0ZXJpemVGZWF0dXJlQ2xhc3NEZXNjOiBcIkFxdWVzdGEgZnVuY2nDsyBjb252ZXJ0ZWl4IGxlcyBkYWRlcyBkZSBsZXMgY2xhc3NlcyBkJ2VudGl0YXRzIGRlIHBvbMOtZ29ucywgcG9saWzDrW5pZXMgaSBwdW50cyBlbiB1bmEgY2FwYSBkZSByw6BzdGVyLjxkaXY+PGJyLz5TJ2Fzc2lnbmVuIHZhbG9ycyBkZSBww614ZWwgYSBsZXMgZW50aXRhdHMgYmFzYXRzIGVuIGVsIHZhbG9yIGRlbCBjYW1wIE9CSkVDVElEIGRlIGxlcyBlbnRpdGF0cyAocGVyIGRlZmVjdGUpLiBEZSBtYW5lcmEgb3BjaW9uYWwsIGVscyB2YWxvcnMgZGUgcMOteGVsIGVzIHBvZGVuIGJhc2FyIGVuIHVuIGNhbXAgZGUgdmFsb3IgZGVmaW5pdCBwZXIgbCd1c3VhcmkgZGUgbGEgdGF1bGEgZCdhdHJpYnV0cyBkZSBsJ2VudGl0YXQgZCdlbnRyYWRhLjwvZGl2PlwiLFxuXHRcdHJlY2FzdE5hbWU6IFwiUmVmb3JtdWxhXCIsXG5cdFx0cmVjYXN0U25pcDogXCJNb2RpZmljYSBlbHMgcGFyw6BtZXRyZXMgZCd1bmEgY2FkZW5hIGRlIGZ1bmNpb25zIGVuIHVuIGRhdGFzZXQgZGUgbW9zYWljIG8gdW4gc2VydmVpIGQnaW1hdGdlcy4gUydhY29zdHVtYSBhIHV0aWxpdHphciBhbWIgZGF0YXNldHMgTEFTIHBlciBldml0YXIgaGF2ZXIgZGUgY3JlYXIgdW4gZGF0YXNldCBkZSBtb3NhaWMgaW5kZXBlbmRlbnQgcGVyIGEgbGVzIGRpZmVyZW50cyByZXByZXNlbnRhY2lvbnMgZGVsIHRlcnJlbnkuXCIsXG5cdFx0cmVjYXN0RGVzYzogXCJMYSBmdW5jacOzIFJlZm9ybXVsYSBzJ3V0aWxpdHphIHBlciBtb2RpZmljYXIgZGUgbWFuZXJhIGRpbsOgbWljYSBlbCBwYXLDoG1ldHJlIGRlIGZ1bmNpw7MgdXRpbGl0emF0IGVuIHVuIGRhdGFzZXQgZGUgbW9zYWljIG8gdW4gc2VydmVpIGQnaW1hdGdlcyBzZW5zZSBtYW50ZW5pciBlbHMgY2FudmlzIGbDrXNpY2FtZW50LlwiLFxuXHRcdHJlZ2lvbkdyb3VwTmFtZTogXCJHcnVwIGRlIHJlZ2lvbnNcIixcblx0XHRyZWdpb25Hcm91cFNuaXA6IFwiUGVyIGEgY2FkYSBjZWzCt2xhIGRlIGxhIHNvcnRpZGEsIGVzIHJlZ2lzdHJhIGxhIGlkZW50aXRhdCBkZSBsYSByZWdpw7MgY29ubmVjdGFkYSBhIGxhIHF1YWwgcGVydGFueSBsYSBjZWzCt2xhLiBTJ2Fzc2lnbmEgdW4gbm9tYnJlIMO6bmljIGEgY2FkYSByZWdpw7MuXCIsXG5cdFx0cmVnaW9uR3JvdXBEZXNjOiBcIkxhIGZ1bmNpw7MgR3J1cCBkZSByZWdpb25zIGdsb2JhbCByZWdpc3RyYSwgcGVyIGEgY2FkYSBjZWzCt2xhIGRlIGxhIHNvcnRpZGEsIGxhIGlkZW50aXRhdCBkZSBsYSByZWdpw7MgY29ubmVjdGFkYSBhIGxhIHF1YWwgcGVydGFueSBsYSBjZWzCt2xhLiBTJ2Fzc2lnbmEgdW4gbm9tYnJlIMO6bmljIGEgY2FkYSByZWdpw7MuPGRpdj48YnIvPkxhIHByaW1lcmEgcmVnacOzIGVzY2FuZWphZGEgcmVwIGVsIHZhbG9yIHUsIGxhIHNlZ29uYSByZXAgZWwgZG9zIGkgYWl4w60gc3VjY2Vzc2l2YW1lbnQsIGZpbnMgcXVlIHRvdGVzIGxlcyByZWdpb25zIHRlbmVuIHVuIHZhbG9yIGFzc2lnbmF0LiBMJ2VzY2FuZWlnIGVzIG1vdSBkJ2VzcXVlcnJhIGEgZHJldGEgaSBkZSBkYWx0IGEgYmFpeC4gRWxzIHZhbG9ycyBhc3NpZ25hdHMgYSBsZXMgem9uZXMgZGUgc29ydGlkYSBlcyBiYXNlbiBlbiBlbCBtb21lbnQgZW4gcXXDqCBlcyB0cm9iZW4gYWwgcHJvY8OpcyBkJ2VzY2FuZWlnLjwvZGl2PlwiLFxuXHRcdHJlZ2lvbkdyb3dOYW1lOiBcIkNyZWl4ZW1lbnQgZGUgcmVnacOzXCIsXG5cdFx0cmVnaW9uR3Jvd1NuaXA6IFwiRmEgY3LDqWl4ZXIgbGVzIHJlZ2lvbnMgZGVzIGRlbHMgcHVudHMgZCdvcmlnZW4uXCIsXG5cdFx0cmVnaW9uR3Jvd0Rlc2M6IFwiTGEgZnVuY2nDsyBDcmVpeGVtZW50IGRlIHJlZ2nDsyBhZ3J1cGEgZWxzIHDDrXhlbHMgdmXDr25zIGVuIGZ1bmNpw7MgZGVsIHJhZGkgZXNwZWNpZmljYXQgZGVzIGRlbCBwdW50IGQnb3JpZ2VuLiBTJ2Fzc2lnbmEgdW4gdmFsb3IgZCdlbXBsZW5hbWVudCBlc3BlY2lmaWNhdCBhbCBncnVwIGRlIHDDrXhlbHMgbyBsJ29iamVjdGUuXCIsXG5cdFx0cmVtYXBOYW1lOiBcIk5vdmEgcmVwcmVzZW50YWNpw7MgY2FydG9ncsOgZmljYVwiLFxuXHRcdHJlbWFwU25pcDogXCJDYW52aWEgZWxzIHZhbG9ycyBkZSBww614ZWwgbWl0amFuw6dhbnQgbCdhc3NpZ25hY2nDsyBkZSBub3VzIHZhbG9ycyBhIGludGVydmFscyBkZSB2YWxvcnMgZGUgcMOteGVsIG8gYsOpIGEgdHJhdsOpcyBkJ3VuYSB0YXVsYSBleHRlcm5hLlwiLFxuXHRcdHJlbWFwRGVzYzogXCJMYSBmdW5jacOzIE5vdmEgcmVwcmVzZW50YWNpw7MgY2FydG9ncsOgZmljYSBwZXJtZXQgY2FudmlhciBvIHRvcm5hciBhIGNsYXNzaWZpY2FyIGVscyB2YWxvcnMgZGUgcMOteGVsIGRlIGxlcyBkYWRlcyBkZWwgcsOgc3Rlci4gQXF1ZXN0YSBhY2Npw7MgZXMgcG90IHJlYWxpdHphciBlc3BlY2lmaWNhbnQgdW4gaW50ZXJ2YWwgZGUgdmFsb3JzIGRlIHDDrXhlbCBwZXIgYXNzaWduYXIgYSB1biB2YWxvciBkZSBww614ZWwgZGUgc29ydGlkYSwgbyBiw6kgbWl0amFuw6dhbnQgdW5hIHRhdWxhIHBlciBhc3NpZ25hciBlbHMgdmFsb3JzIGRlIHDDrXhlbCBhIHVuIHZhbG9yIGRlIHDDrXhlbCBkZSBzb3J0aWRhLlwiLFxuXHRcdHJlcHJvamVjdE5hbWU6IFwiUmVwcm9qZWN0YVwiLFxuXHRcdHJlcHJvamVjdFNuaXA6IFwiTW9kaWZpY2EgbGEgcHJvamVjY2nDsyBkJ3VuIGRhdGFzZXQgcsOgc3RlciwgdW4gZGF0YXNldCBkZSBtb3NhaWMgbyB1biBlbGVtZW50IGRlIHLDoHN0ZXIgZCd1biBkYXRhc2V0IGRlIG1vc2FpYy4gVGFtYsOpIHBvdCByZW1vc3RyZWphciBsZXMgZGFkZXMgYSB1bmEgbWlkYSBkZSBjZWzCt2xhIG5vdmEgaSBkZWZpbmlyIHVuIG9yaWdlbi5cIixcblx0XHRyZXByb2plY3REZXNjOiBcIkxhIGZ1bmNpw7MgUmVwcm9qZWN0YSBtb2RpZmljYSBsYSBwcm9qZWNjacOzIGQndW4gZGF0YXNldCByw6BzdGVyLCB1biBkYXRhc2V0IGRlIG1vc2FpYyBvIHVuIGVsZW1lbnQgZGUgcsOgc3RlciBkJ3VuIGRhdGFzZXQgZGUgbW9zYWljLiBUYW1iw6kgcG90IHJlbW9zdHJlamFyIGxlcyBkYWRlcyBhIHVuYSBtaWRhIGRlIGNlbMK3bGEgbm92YSBpIGRlZmluaXIgdW4gb3JpZ2VuLjxkaXY+PGJyLz5MYSBmdW5jacOzIFJlcHJvamVjdGEgZXMgcG90IHV0aWxpdHphciBlbiBjcmVhciB1bmEgbWVtw7JyaWEgY2F1IGEgcGFydGlyIGQndW4gZGF0YXNldCByw6BzdGVyIG8gZGUgbW9zYWljIHF1ZSBubyBlcyB0cm9iYSBhIGxhIHByb2plY2Npw7MgbmVjZXNzw6ByaWEuIFBlciBleGVtcGxlLCBlbiBjcmVhciB1biBzZXJ2ZWkgZCdpbWF0Z2VzIGVtbWFnYXR6ZW1hdCBhIGxhIG1lbcOycmlhIGNhdSBxdWUgcG9kcmlhIGVzdGFyIGludGVncmF0IHBlciBhbHRyZXMgYW1iIGFsdHJlcyBzZXJ2ZWlzIGVtbWFnYXR6ZW1hdHMgYSBsYSBtZW3DsnJpYSBjYXUsIMOpcyBpbXBvcnRhbnQgcXVlIHRvdHMgZXN0aWd1aW4gYSBsYSBtYXRlaXhhIHByb2plY2Npw7MuIEFjb3N0dW1hIGEgc2VyIHVuYSBwcm9qZWNjacOzIGRlbCBXZWIgTWVyY2F0b3IuIEF0w6hzIHF1ZSBlbCBkYXRhc2V0IGRlIG1vc2FpYyBubyBlcyBwb3QgcmVwcm9qZWN0YXIsIHBvZGV1IHJlYWxpdHphciB1bmEgZGUgbGVzIGFjY2lvbnMgc2Vnw7xlbnRzOiBjcmVhciB1biBkYXRhc2V0IGRlIG1vc2FpYyBkZSByZWZlcsOobmNpYSBhIHBhcnRpciBkZWwgdm9zdHJlIGRhdGFzZXQgZGUgbW9zYWljIGRlIGxhIHByb2plY2Npw7MgbmVjZXNzw6ByaWEgbyBhZmVnaXIgbGEgZnVuY2nDsyBSZXByb2plY3RhIGEgbGEgY2FkZW5hIGRlIGZ1bmNpb25zIGRlbCBkYXRhc2V0IGRlIG1vc2FpYy4gVW4gYWx0cmUgZXhlbXBsZSB1dGlsaXR6YSBhcXVlc3RhIGZ1bmNpw7MgYSBsJ2VsZW1lbnQgZGUgcsOgc3RlciBkJ3VuIGRhdGFzZXQgZGUgbW9zYWljLiBRdWFuIHV0aWxpdHpldSBsYSBmdW5jacOzIFLDoHN0ZXIgZW1tYWdhdHplbWF0IGEgbGEgbWVtw7JyaWEgY2F1LCBwb2RldSBpbnNlcmlyIGxhIGZ1bmNpw7MgUmVwcm9qZWN0YSBwZXJxdcOoIGxhIG1lbcOycmlhIGNhdSBlcyBjcmXDryBhIGxhIHByb2plY2Npw7Mgbm92YS4gRWxzIGVsZW1lbnRzIGRlIHLDoHN0ZXIgZCd1biBkYXRhc2V0IGRlIG1vc2FpYyBlcyBwb2RlbiBlbW1hZ2F0emVtYXIgYSBsYSBtZW3DsnJpYSBjYXUgcXVhbiBlbCBwcm9jZXNzYW1lbnQgw6lzIGludGVucyBpIGludGVudGV1IHB1YmxpY2FyIHVuIHNlcnZlaSBkJ2ltYXRnZXMgZCdhbHRhIHZlbG9jaXRhdCwgc2Vuc2UgZW1tYWdhdHplbWFyIHRvdCBlbCBzZXJ2ZWkgZCdpbWF0Z2VzIGEgbGEgbWVtw7JyaWEgY2F1LjwvZGl2PlwiLFxuXHRcdHJlc2FtcGxlTmFtZTogXCJSZW1vc3RyZWphXCIsXG5cdFx0cmVzYW1wbGVTbmlwOiBcIkNhbnZpYSBsYSBtaWRhIGRlIGxhIGNlbMK3bGEgZCd1biByw6BzdGVyLlwiLFxuXHRcdHJlc2FtcGxlRGVzYzogXCJMYSBmdW5jacOzIFJlbW9zdHJlamEgY2FudmlhIGxhIG1pZGEgZGUgbGEgY2VswrdsYSwgZWwgdGlwdXMgZGUgcmVtb3N0cmVpZyBvIGFtYmR1ZXMgY29zZXMuPGRpdj48YnIvPkxhIGZ1bmNpw7MgUmVtb3N0cmVqYSBub23DqXMgcydoYSBkJ3V0aWxpdHphciBwZXIgYSByZXF1aXNpdHMgZGUgY8OgbGN1bCBlc3BlY8OtZmljczsgcGVyIGV4ZW1wbGUsIHF1YW4gY2FsY3VsZXUgbGEgbWFnbml0dWQtZGlyZWNjacOzIGRlbCB2ZW50IG8gZWwgY29ycmVudCBxdWUgcmVxdWVyZWl4IGVsIHJlbW9zdHJlaWcgZGUgbGEgcmVzb2x1Y2nDsyBkJ29yaWdlbi48L2Rpdj5cIixcblx0XHRyb3VuZERvd25OYW1lOiBcIkFycm9kb25pbWVudCBhIGxhIGJhaXhhXCIsXG5cdFx0cm91bmREb3duU25pcDogXCJSZXRvcm5hIGVsIHNlZ8O8ZW50IHZhbG9yIGVudGVyIG3DqXMgYmFpeCwgcmVwcmVzZW50YXQgY29tIHVuIHZhbG9yIGRlIHB1bnQgZmxvdGFudCwgZGUgY2FkYSBjZWzCt2xhIGQndW4gcsOgc3Rlci5cIixcblx0XHRyb3VuZERvd25EZXNjOiBcIkxhIGZ1bmNpw7MgQXJyb2RvbmltZW50IGEgbGEgYmFpeGEgcmV0b3JuYSBlbCBzZWfDvGVudCBlbnRlciBtw6lzIGJhaXgsIGNvbSB1biB2YWxvciBkZSBwdW50IGZsb3RhbnQsIGRlIGNhZGEgcMOteGVsIGQndW4gcsOgc3Rlci5cIixcblx0XHRyb3VuZFVwTmFtZTogXCJBcnJvZG9uaW1lbnQgYSBsJ2Fsw6dhXCIsXG5cdFx0cm91bmRVcFNuaXA6IFwiUmV0b3JuYSBlbCBzZWfDvGVudCB2YWxvciBlbnRlciBtw6lzIGFsdCwgcmVwcmVzZW50YXQgY29tIHVuIHZhbG9yIGRlIHB1bnQgZmxvdGFudCwgZGUgY2FkYSBjZWzCt2xhIGQndW4gcsOgc3Rlci5cIixcblx0XHRyb3VuZFVwRGVzYzogXCJMYSBmdW5jacOzIEFycm9kb25pbWVudCBhIGwnYWzDp2EgcmV0b3JuYSBlbCBzZWfDvGVudCBlbnRlciBtw6lzIGFsdCwgY29tIHVuIHZhbG9yIGRlIHB1bnQgZmxvdGFudCwgZGUgY2FkYSBww614ZWwgZCd1biByw6BzdGVyLlwiLFxuXHRcdHNlZ21lbnRNZWFuU2hpZnROYW1lOiBcIkRlc3BsYcOnYW1lbnQgbWl0asOgIGRlIHNlZ21lbnRcIixcblx0XHRzZWdtZW50TWVhblNoaWZ0U25pcDogXCJBZ3J1cGEgZWxzIHDDrXhlbHMgdmXDr25zIGFtYiBjYXJhY3RlcsOtc3RpcXVlcyBlc3BlY3RyYWxzIHNpbWlsYXJzIGVuIHNlZ21lbnRzLlwiLFxuXHRcdHNlZ21lbnRNZWFuU2hpZnREZXNjOiBcIkFxdWVzdGEgZnVuY2nDsyBpZGVudGlmaWNhIG9iamVjdGVzLCBlbnRpdGF0cyBvIHNlZ21lbnRzIGRlIGxlcyBpbWF0Z2VzIG1pdGphbsOnYW50IGwnYWdydXBhY2nDsyBkZWxzIHDDrXhlbHMgYWRqYWNlbnRzIHF1ZSB0ZW5lbiBjYXJhY3RlcsOtc3RpcXVlcyBlc3BlY3RyYWxzIGkgZXNwYWNpYWxzIHNpbWlsYXJzLiBQb2RldSBjb250cm9sYXIgbGEgcXVhbnRpdGF0IGRlIHN1YXZpdHphY2nDsyBlc3BhY2lhbCBpIGVzcGVjdHJhbCBwZXIgYWp1ZGFyIGEgZGVyaXZhciBlbnRpdGF0cyBkJ2ludGVyw6hzLlwiLFxuXHRcdHMxUmFkaW9tZXRyaWNDYWxpYnJhdGlvbk5hbWU6IFwiQ2FsaWJyYXRnZSByYWRpb23DqHRyaWMgZGUgU2VudGluZWwtMVwiLFxuXHRcdHMxUmFkaW9tZXRyaWNDYWxpYnJhdGlvblNuaXA6IFwiUmVhbGl0emEgZGlmZXJlbnRzIHRpcHVzIGRlIGNhbGlicmF0Z2UgcmFkaW9tw6h0cmljIGEgbGVzIGRhZGVzIGRlIFNlbnRpbmVsLTEuXCIsXG5cdFx0czFSYWRpb21ldHJpY0NhbGlicmF0aW9uRGVzYzogXCJBcXVlc3RhIGZ1bmNpw7MgZGUgcsOgc3RlciByZWFsaXR6YSB0cmVzIGNhbGlicmF0Z2VzIGRpZmVyZW50cyBwZXIgYWxzIGRhdGFzZXRzIGRlIFNlbnRpbmVsIDEsIGluY2xvc29zIGJldGEgemVybyBpIGdhbW1hLCBpIGdlbmVyYSBlbCBkYXRhc2V0IGNhbGlicmF0LiBMJ29iamVjdGl1IGRlbCBjYWxpYnJhdGdlIGRlIFNBUiDDqXMgcHJvcG9yY2lvbmFyIGltYXRnZXMgZW4gcXXDqCBlbHMgdmFsb3JzIGRlIHDDrXhlbCBlcyBwdWd1aSByZWxhY2lvbmFyIGRpcmVjdGFtZW50IGEgbGEgcmV0cm9kaXNwZXJzacOzIGRlbCByYWRhciBkZSBsJ2VzY2VuYS4gTWFsZ3JhdCBxdWUgbGVzIGltYXRnZXMgZGUgU0FSIHNlbnNlIGNhbGlicmFyIHPDs24gc3VmaWNpZW50cyBwZXIgYSB1biDDunMgcXVhbGl0YXRpdSwgbGVzIGltYXRnZXMgZGUgU0FSIGNhbGlicmFkZXMgc8OzbiBlc3NlbmNpYWxzIHBlciBhIGwnw7pzIHF1YW50aXRhdGl1IGRlIGxlcyBkYWRlcyBkZSBTQVIuPGRpdj48YnIvPkVsIHByb2Nlc3NhbWVudCBoYWJpdHVhbCBkZSBsZXMgZGFkZXMgZGUgU0FSLCBxdWUgcHJvZHVlaXggaW1hdGdlcyBkZSBuaXZlbGwgMSwgbm8gaW5jbG91IGNvcnJlY2Npb25zIHJhZGlvbcOodHJpcXVlcyBpIGVzIG1hbnTDqSB1biBiaWFpeCByYWRpb23DqHRyaWMgY29uc2lkZXJhYmxlLiBQZXIgdGFudCwgw6lzIG5lY2Vzc2FyaSBhcGxpY2FyIGxhIGNvcnJlY2Npw7MgcmFkaW9tw6h0cmljYSBhIGxlcyBpbWF0Z2VzIGRlIFNBUiBwZXJxdcOoIGVscyB2YWxvcnMgZGUgcMOteGVsIGRlIGxlcyBpbWF0Z2VzIHJlcHJlc2VudGluIHJlYWxtZW50IGxhIHJldHJvZGlzcGVyc2nDsyBkZWwgcmFkYXIgZGUgbGEgc3VwZXJmw61jaWUgcmVmbGVjdG9yYS4gTGEgY29ycmVjY2nDsyByYWRpb23DqHRyaWNhIHRhbWLDqSDDqXMgbmVjZXNzw6ByaWEgcGVyIGEgbGEgY29tcGFyYWNpw7MgZGUgbGVzIGltYXRnZXMgZGUgU0FSIGFkcXVpcmlkZXMgYW1iIHNlbnNvcnMgZGlmZXJlbnRzIG8gYWRxdWlyaWRlcyBkZXMgZGVsIG1hdGVpeCBzZW5zb3IgZW4gbW9tZW50cyBkaWZlcmVudHMsIGFkcXVpcmlkZXMgZW4gbW9kZXMgZGlmZXJlbnRzIG8gcHJvY2Vzc2FkZXMgcGVyIHByb2Nlc3NhZG9ycyBkaWZlcmVudHMuPC9kaXY+XCIsXG5cdFx0czFUaGVybWFsTm9pc2VSZW1vdmFsTmFtZTogXCJFbGltaW5hY2nDsyBkZSBzb3JvbGwgdMOocm1pYyBkZSBTZW50aW5lbC0xXCIsXG5cdFx0czFUaGVybWFsTm9pc2VSZW1vdmFsU25pcDogXCJFbGltaW5hIGVsIHNvcm9sbCB0w6hybWljIGRlIGxlcyBkYWRlcyBkZSBTZW50aW5lbC0xLlwiLFxuXHRcdHMxVGhlcm1hbE5vaXNlUmVtb3ZhbERlc2M6IFwiTGEgY29ycmVjY2nDsyBkZSBzb3JvbGwgdMOocm1pYyBlcyBwb3QgYXBsaWNhciBhbHMgcHJvZHVjdGVzIFNpbmdsZSBMb29rIENvbXBsZXggKFNMQykgZGUgbml2ZWxsIDEgaSBhbHMgcHJvZHVjdGVzIExldmVsLTEgR3JvdW5kIFJhbmdlIERldGVjdGlvbiAoR1JEKSBkZSBTZW50aW5lbC0xIHF1ZSBlbmNhcmEgbm8gcydoYW4gY29ycmVnaXQuIEwnb3BlcmFkb3IgdGFtYsOpIHBvdCBlbGltaW5hciBhcXVlc3RhIGNvcnJlY2Npw7MgZCdhY29yZCBhbWIgbGVzIGFub3RhY2lvbnMgZGVsIHByb2R1Y3RlIHBlciB0b3JuYXIgYSBpbnRyb2R1aXIgZWwgc2VueWFsIGRlIHNvcm9sbCBxdWUgcydoYSBlbGltaW5hdCBwZXIgcHJvZHVpciBlbCBwcm9kdWN0ZSBvcmlnaW5hbC4gTGVzIGFub3RhY2lvbnMgZGVsIHByb2R1Y3RlIHMnYWN0dWFsaXR6YXJhbiBlbiBjb25zZXHDvMOobmNpYSBwZXIgdG9ybmFyIGEgYXBsaWNhciBsYSBjb3JyZWNjacOzLiBcIixcblx0XHRzZXROdWxsTmFtZTogXCJEZWZpbmVpeCBudWxzXCIsXG5cdFx0c2V0TnVsbFNuaXA6IFwiTGEgZnVuY2nDsyBEZWZpbmVpeCBudWxzIGVzdGFibGVpeCBsZXMgdWJpY2FjaW9ucyBkZSBjZWzCt2xhIGlkZW50aWZpY2FkZXMgZW4gTm9EYXRhIGVuIGZ1bmNpw7MgZCd1bnMgY3JpdGVyaXMgZXNwZWNpZmljYXRzLiBSZXRvcm5hIE5vRGF0YSBzaSB1bmEgYXZhbHVhY2nDsyBjb25kaWNpb25hbCDDqXMgY2VydGEgaSByZXRvcm5hIGVsIHZhbG9yIGVzcGVjaWZpY2F0IHBlciB1biBhbHRyZSByw6BzdGVyIHNpIMOpcyBmYWxzYS5cIixcblx0XHRzZXROdWxsRGVzYzogXCJMYSBmdW5jacOzIERlZmluZWl4IG51bHMgZXN0YWJsZWl4IGVscyBww614ZWxzIGlkZW50aWZpY2F0cyBlbiBOb0RhdGEsIHNlZ29ucyBlbHMgY3JpdGVyaXMgZXNwZWPDrWZpY3MuIFJldG9ybmEgTm9EYXRhIHNpIHVuYSBhdmFsdWFjacOzIGNvbmRpY2lvbmFsIMOpcyBjZXJ0YSAoMSkgaSByZXRvcm5hIGVsIHZhbG9yIGVzcGVjaWZpY2F0IGFsIHLDoHN0ZXIgZmFscyBzaSB1bmEgYXZhbHVhY2nDsyBjb25kaWNpb25hbCDDqXMgZmFsc2EgKDApLiBBcXVlc3QgY3JpdGVyaSBsJ2VzcGVjaWZpY2EgbGEgc29ydGlkYSBkJ3VuYSBmdW5jacOzIG1hdGVtw6B0aWNhIGzDsmdpY2EsIHF1ZSBzZXLDoCBlbCByw6BzdGVyIGQnZW50cmFkYS5cIixcblx0XHRzaGFkZWRSZWxpZWZOYW1lOiBcIlJlbGxldSBvbWJyZWphdFwiLFxuXHRcdHNoYWRlZFJlbGllZlNuaXA6IFwiQ3JlYSB1bmEgcmVwcmVzZW50YWNpw7MgM0QgZGUgbGEgc3VwZXJmw61jaWUgbXVsdGliYW5kYSBhbWIgY29kaWZpY2FjacOzIGRlIGNvbG9yLCB0ZW5pbnQgZW4gY29tcHRlIGxhIHBvc2ljacOzIHJlbGF0aXZhIGRlbCBzb2wgcGVyIG9tYnJlamFyIGxhIGltYXRnZS5cIixcblx0XHRzaGFkZWRSZWxpZWZEZXNjOiBcIkxhIGZ1bmNpw7MgUmVsbGV1IG9tYnJlamF0IGNyZWEgdW5hIHJlcHJlc2VudGFjacOzIDNEIGVuIGNvbG9yIGRlbCB0ZXJyZW55IG1pdGphbsOnYW50IGxhIGZ1c2nDsyBkZSBsZXMgaW1hdGdlcyBhIHBhcnRpciBkZWxzIG3DqHRvZGVzIGRlIGNvZGlmaWNhY2nDsyBkJ2VsZXZhY2nDsyBpIG9tYnJlaWcuIEFxdWVzdGEgZnVuY2nDsyB1dGlsaXR6YSBsZXMgcHJvcGlldGF0cyBkJ2FsdGl0dWQgaSBkJ2F6aW11dCBwZXIgZXNwZWNpZmljYXIgbGEgcG9zaWNpw7MgZGVsIHNvbC48ZGl2Pjxici8+PC9kaXY+XCIsXG5cdFx0c2luSE5hbWU6IFwiU2ludXMgaGlwZXJiw7JsaWMgKFNpbkgpXCIsXG5cdFx0c2luSFNuaXA6IFwiQ2FsY3VsYSBlbCBzaW51cyBoaXBlcmLDsmxpYyBkZSBsZXMgY2VswrdsZXMgZCd1biByw6BzdGVyLlwiLFxuXHRcdHNpbkhEZXNjOiBcIkxhIGZ1bmNpw7MgY2FsY3VsYSBlbCBzaW51cyBoaXBlcmLDsmxpYyBkZWxzIHDDrXhlbHMgZCd1biByw6BzdGVyLlwiLFxuXHRcdHNpbk5hbWU6IFwiU2ludXMgKFNpbilcIixcblx0XHRzaW5TbmlwOiBcIkNhbGN1bGEgZWwgc2ludXMgZGUgbGVzIGNlbMK3bGVzIGQndW4gcsOgc3Rlci5cIixcblx0XHRzaW5EZXNjOiBcIkxhIGZ1bmNpw7MgY2FsY3VsYSBlbCBzaW51cyBkZWxzIHDDrXhlbHMgZCd1biByw6BzdGVyLlwiLFxuXHRcdHNsb3BlTmFtZTogXCJQZW5kZW50XCIsXG5cdFx0c2xvcGVTbmlwOiBcIkNhbGN1bGEgbCfDrW5kZXggZGUgY2FudmkgZCd1biB2YWxvciBkZSBww614ZWwgcmVzcGVjdGUgYWxzIHNldXMgdmXDr25zLlwiLFxuXHRcdHNsb3BlRGVzYzogXCJBcXVlc3RhIGZ1bmNpw7MgZGUgcsOgc3RlciBjYWxjdWxhIGVsIHBlbmRlbnQsIHF1ZSDDqXMgbCfDrW5kZXggZGUgY2FudmkgZCdlbGV2YWNpw7MgZGUgY2FkYSBjZWzCt2xhIGRlbCBtb2RlbCBkJ2VsZXZhY2nDsyBkaWdpdGFsIChERU0pLiDDiXMgbGEgcHJpbWVyYSBkZXJpdmFkYSBkJ3VuIERFTS48ZGl2Pjxici8+QXF1ZXN0YSBmdW5jacOzIHV0aWxpdHphIHVuYSBmdW5jacOzIGF0YW4oKSBhY2NlbGVyYWRhLiDDiXMgc2lzIHZlZ2FkZXMgbcOpcyByw6BwaWRhIGkgbCdlcnJvciBkJ2Fwcm94aW1hY2nDsyBzZW1wcmUgw6lzIGluZmVyaW9yIGEgMCwzIGdyYXVzLjwvZGl2PlwiLFxuXHRcdHNwZWNrbGVOYW1lOiBcIlBpZ2FsbGF0XCIsXG5cdFx0c3BlY2tsZVNuaXA6IFwiUHJvcG9yY2lvbmEgZmlsdHJlcyBwZXIgZWxpbWluYXIgZWwgc29yb2xsIGRlbHMgZGF0YXNldHMgZGUgcmFkYXIgZCdvYmVydHVyYSBzaW50w6h0aWNhLlwiLFxuXHRcdHNwZWNrbGVEZXNjOiBcIkVsIHBpZ2FsbGF0IMOpcyBlbCBzb3JvbGwgZCdhbHRhIGZyZXHDvMOobmNpYSBhIGxlcyBkYWRlcyBkJ3VuIHJhZGFyLiBMZXMgaW1hdGdlcyBxdWUgZ2VuZXJlbiBlbHMgc2lzdGVtZXMgZGUgcmFkYXIgZCdhcGVydHVyYSBzaW50w6h0aWNhIChTQVIpIGVzdGFuIGV4dHJlbWFkYW1lbnQgc290bWVzb3MgYWxzIGVmZWN0ZXMgZGVsIHBpZ2FsbGF0IGEgY2F1c2EgZGVsIHByb2Nlc3NhbWVudCBkZSBzZW55YWxzIGRpc3BlcnNvcyBpIGRlIGxhIGludGVyZmVyw6huY2lhIGQnb25lcyBlbGVjdHJvbWFnbsOodGlxdWVzIGRpc3BlcnNhZGVzIGRlcyBkZSBzdXBlcmbDrWNpZXMgbyBvYmplY3Rlcy4gTGEgZnVuY2nDsyBQaWdhbGxhdCBmaWx0cmEgZWwgZGF0YXNldCBkZSByYWRhciBhbWIgcGlnYWxsYXQgaSBzdWF2aXR6YSBlbCBzb3JvbGwgbWVudHJlIG1hbnTDqSBsZXMgdm9yZXMgbyBsZXMgZW50aXRhdHMgcHJlY2lzZXMgZGUgbGEgaW1hdGdlLlwiLFxuXHRcdHNwZWN0cmFsQ29udmVyc2lvbk5hbWU6IFwiQ29udmVyc2nDsyBlc3BlY3RyYWxcIixcblx0XHRzcGVjdHJhbENvbnZlcnNpb25TbmlwOiBcIkFwbGljYSB1bmEgbWF0cml1IGEgdW5hIGltYXRnZSBtdWx0aWJhbmRhLlwiLFxuXHRcdHNwZWN0cmFsQ29udmVyc2lvbkRlc2M6IFwiTGEgZnVuY2nDsyBDb252ZXJzacOzIGVzcGVjdHJhbCBhcGxpY2EgdW5hIG1hdHJpdSBhIHVuYSBpbWF0Z2UgbXVsdGliYW5kYSBwZXIgYWx0ZXJhciBlbHMgdmFsb3JzIGRlIGNvbG9yIGRlIGxhIHNvcnRpZGEuPGRpdj48YnIvPkFsZ3VucyBzZW5zb3JzIG5vIHJlYmVuIGxlcyBiYW5kZXMgYmxhdmVzIGEgY2F1c2EgZCd1bmEgcmVsYWNpw7Mgc2VueWFsLXNvcm9sbCBiYWl4YS4gUGVyIGV4ZW1wbGUsIGVzIHBvdCB1dGlsaXR6YXIgcGVyIGNvbnZlcnRpciB1bmEgaW1hdGdlIGluZnJhcm9qYSBkZSBjb2xvcnMgZmFsc29zIGVuIHVuYSBpbWF0Z2UgZGUgY29sb3JzIHBzZXVkb25hdHVyYWxzLjwvZGl2PlwiLFxuXHRcdHNxdWFyZVJvb3ROYW1lOiBcIkFycmVsIHF1YWRyYWRhXCIsXG5cdFx0c3F1YXJlUm9vdFNuaXA6IFwiQ2FsY3VsYSBsJ2FycmVsIHF1YWRyYWRhIGRlbHMgdmFsb3JzIGRlIGNlbMK3bGEgZCd1biByw6BzdGVyLlwiLFxuXHRcdHNxdWFyZVJvb3REZXNjOiBcIkxhIGZ1bmNpw7MgQXJyZWwgcXVhZHJhZGEgY2FsY3VsYSBsJ2FycmVsIHF1YWRyYWRhIGRlbHMgdmFsb3JzIGRlIHDDrXhlbCBkJ3VuIHLDoHN0ZXIuXCIsXG5cdFx0c3F1YXJlTmFtZTogXCJRdWFkcmFkYVwiLFxuXHRcdHNxdWFyZVNuaXA6IFwiQ2FsY3VsYSBlbCBxdWFkcmF0IGRlbHMgdmFsb3JzIGRlIGNlbMK3bGEgZCd1biByw6BzdGVyLlwiLFxuXHRcdHNxdWFyZURlc2M6IFwiTGEgZnVuY2nDsyBRdWFkcmF0IGNhbGN1bGEgZWwgcXVhZHJhdCBkZWxzIHZhbG9ycyBkZSBww614ZWwgZCd1biByw6BzdGVyLlwiLFxuXHRcdHN0YXRpc3RpY3NIaXN0b2dyYW1OYW1lOiBcIkVzdGFkw61zdGlxdWVzIGkgaGlzdG9ncmFtYVwiLFxuXHRcdHN0YXRpc3RpY3NIaXN0b2dyYW1TbmlwOiBcIkRlZmluaXUgbyBhc3NvY2lldSBsZXMgZXN0YWTDrXN0aXF1ZXMgaSBsJ2hpc3RvZ3JhbWEuXCIsXG5cdFx0c3RhdGlzdGljc0hpc3RvZ3JhbURlc2M6IFwiTGEgZnVuY2nDsyBFc3RhZMOtc3RpcXVlcyBpIGhpc3RvZ3JhbWEgcyd1dGlsaXR6YSBwZXIgZGVmaW5pciBsZXMgZXN0YWTDrXN0aXF1ZXMgaSBsJ2hpc3RvZ3JhbWEgZCd1biByw6BzdGVyLiBQb2RldSBpbnNlcmlyIGFxdWVzdGEgZnVuY2nDsyBhbCBmaW5hbCBkZSBsYSBjYWRlbmEgZGUgZnVuY2lvbnMgcGVyIGRlc2NyaXVyZSBsZXMgZXN0YWTDrXN0aXF1ZXMgaSBsJ2hpc3RvZ3JhbWEgZCd1bmEgcGxhbnRpbGxhIGRlIGZ1bmNpw7MgZGUgcsOgc3RlciAoUkZUKS4gUG90IHNlciBuZWNlc3NhcmkgcGVyIGNvbnRyb2xhciBsYSB2aXN1YWxpdHphY2nDsyBwZXIgZGVmZWN0ZSBkZWwgcmVzdWx0YXQgZGVsIHByb2Nlc3NhbWVudCwgZXNwZWNpYWxtZW50IGVuIGRlZmluaXIgdW5hIGNhZGVuYSBkZSBmdW5jaW9ucyBxdWUgY29udMOpIG1vbHRlcyBmdW5jaW9ucy48ZGl2Pjxici8+UGVyIGRlZmluaXIgbGVzIGVzdGFkw61zdGlxdWVzLCBwb2RldSBlc2NyaXVyZSBlbHMgdmFsb3JzIG8gaW1wb3J0YXItbG9zIGQndW4gZGF0YXNldCByw6BzdGVyIG8gdW4gZml0eGVyIFhNTC4gRWxzIGhpc3RvZ3JhbWVzIG5vbcOpcyBlcyBwb2RlbiBkZWZpbmlyIGltcG9ydGFudCB1biBmaXR4ZXIuPC9kaXY+XCIsXG5cdFx0c3RhdGlzdGljc05hbWU6IFwiRXN0YWTDrXN0aXF1ZXNcIixcblx0XHRzdGF0aXN0aWNzU25pcDogXCJDYWxjdWxhIGxlcyBlc3RhZMOtc3RpcXVlcyBmb2NhbHMgZGUgY2FkYSBww614ZWwgZCd1bmEgaW1hdGdlIGVuIGZ1bmNpw7MgZGVsIHZlw69uYXQgZm9jYWwgZGVmaW5pdC5cIixcblx0XHRzdGF0aXN0aWNzRGVzYzogXCJMYSBmdW5jacOzIEVzdGFkw61zdGlxdWVzIGNhbGN1bGEgbGVzIGVzdGFkw61zdGlxdWVzIGZvY2FscyBkZSBjYWRhIHDDrXhlbCBkJ3VuYSBpbWF0Z2UgZW4gZnVuY2nDsyBkZWwgdmXDr25hdCBmb2NhbCBkZWZpbml0LjxkaXY+PGJyLz5MYSBmdW5jacOzIEVzdGFkw61zdGlxdWVzIGVzIHBvdCB1dGlsaXR6YXIgcGVyIGVtcGxlbmFyIGzDrW5pZXMgbm8gY29udMOtbnVlcyBlbiB1bmEgaW1hdGdlLiBMZXMgbMOtbmllcyBubyBjb250w61udWVzIGxlcyBhY29zdHVtZW4gYSBjYXVzYXIgcHJvYmxlbWVzIGFsIHNlbnNvciBvbiBubyBlcyByZWNvcGlsZW4gZGFkZXMuIEFpeMOyIGhhIHBhc3NhdCBlbiBzZW5zb3JzIGNvbSBhcmEgbCdFbmhhbmNlZCBUaGVtYXRpYyBNYXBwZXIgUGx1cyAoRVRNKykgZGUgTGFuZHNhdCA3LiBBcXVlc3RlcyBkYWRlcyBxdWUgZmFsdGVuIHByb3ZvcXVlbiBwcm9ibGVtZXMgYSBsJ2Fuw6BsaXNpIGkgdGFtYsOpIGVuIGwnb2JzZXJ2YWNpw7MgZGUgbGVzIGltYXRnZXMuIEhpIGhhIHBvY2EgY29zYSBhIGZlciBxdWFuIHMndXRpbGl0emVuIGxlcyBpbWF0Z2VzIHBlciBhIGwnYW7DoGxpc2k7IGFpeMOyIG5vIG9ic3RhbnQsIHNpIGhpIGhhIHVuYSBpbWF0Z2Ugc3VwZXJwb3NhZGEsIGVzIHBvdCB1dGlsaXR6YXIgZW4gbGxvYyBkZWwgY29udGluZ3V0IHF1ZSBmYWx0YS4gRWwgbWF0ZWl4IGVzIHBvdCBmZXIgc2kgbGVzIGltYXRnZXMgcyd1dGlsaXR6ZW4gcGVyIGEgbGEgdmlzdWFsaXR6YWNpw7MuIFBlcsOyIG5vIHNlbXByZSBoaSBoYSB1bmEgaW1hdGdlIGFkZGljaW9uYWwgcGVyIGVtcGxlbmFyIGVsIGNvbnRpbmd1dCBxdWUgZmFsdGEgaSwgYWxlc2hvcmVzLCBzJ2hhIGRlIGRlcml2YXIgZGUgbGVzIGRhZGVzIGV4aXN0ZW50cy48L2Rpdj5cIixcblx0XHRzdHJlYW1MaW5rTmFtZTogXCJFbmxsYcOnIGRlIGNvcnJlbnRcIixcblx0XHRzdHJlYW1MaW5rU25pcDogXCJBc3NpZ25hIHZhbG9ycyDDum5pY3MgYSBsZXMgc2VjY2lvbnMgZCd1bmEgeGFyeGEgZGUgcsOgc3RlciBsaW5lYWwgZW50cmUgaW50ZXJzZWNjaW9ucy5cIixcblx0XHRzdHJlYW1MaW5rRGVzYzogXCJMYSBmdW5jacOzIEVubGxhw6cgZGUgY29ycmVudCBnbG9iYWwgYXNzaWduYSB2YWxvcnMgw7puaWNzIGEgbGVzIHNlY2Npb25zIGQndW5hIHhhcnhhIGRlIHLDoHN0ZXIgbGluZWFsIGVudHJlIGludGVyc2VjY2lvbnMuPGRpdj48YnIvPkVscyBlbmxsYcOnb3Mgc8OzbiBsZXMgc2VjY2lvbnMgZCd1biBjYW5hbCBkZSBjb3JyZW50IHF1ZSBjb25uZWN0YSBkb3MgZW5jcmV1YW1lbnRzIHN1Y2Nlc3NpdXMsIHVuIGVuY3JldWFtZW50IGkgbGEgc29ydGlkYSBvIHVuIGVuY3JldWFtZW50IGkgbGEgZGl2aXNpw7MgZGUgZHJlbmF0Z2UuIEVuIGVsIGNhbXAgZGUgbGEgaGlkcm9sb2dpYSwgYXF1ZXN0cyBzZWdtZW50cyBkZSBjb3JyZW50IHMnYW5vbWVuZW4gY3Vyc29zLiBVbiBlbmNyZXVhbWVudCBlcyByZWxhY2lvbmEgYW1iIHVuIHB1bnQgZGUgZmx1w69kZXNhIGkgYWp1ZGEgZGUgZGVsaW5lYXIgZWwgbMOtbWl0IGRlIGxhIHN1YmNvbmNhIGRlIGxhIGNvbmNhIGhpZHJvZ3LDoGZpY2EgbyBkZWwgZHJlbmF0Z2UuPC9kaXY+XCIsXG5cdFx0c3RyZXRjaE5hbWU6IFwiRXN0aXJhXCIsXG5cdFx0c3RyZXRjaFNuaXA6IFwiQWp1c3RhIGwnaW50ZXJ2YWwgZGUgdmFsb3JzIHF1ZSBlcyBtb3N0cmEgcGVyIG1pbGxvcmFyIHVuYSBpbWF0Z2UuIEFpeMOyIG5vIGFsdGVyYSBlbHMgdmFsb3JzIGRlIHDDrXhlbCBzdWJqYWNlbnRzLiBTaSBlbCB2YWxvciBkJ3VuIHDDrXhlbCBlcyB0cm9iYSBmb3JhIGRlIGwnaW50ZXJ2YWwgZXNwZWNpZmljYXQsIGVzIG1vc3RyYXLDoCBjb20gZWwgdmFsb3IgbcOtbmltIG8gbcOgeGltLlwiLFxuXHRcdHN0cmV0Y2hEZXNjOiBcIkxhIGZ1bmNpw7MgRXN0aXJhIG1vZGlmaWNhIGxlcyBwcm9waWV0YXRzIGQndW5hIGltYXRnZSBwZXIgbWlsbG9yYXItbGEsIGNvbSBhcmEgbGVzIGRlIGJyaWxsYW50b3IsIGNvbnRyYXN0IGkgZ2FtbWEsIG1pdGphbsOnYW50IGRpdmVyc29zIHRpcHVzIGQnZXh0ZW5zacOzLiBBcXVlc3RhIGZ1bmNpw7MgdXRpbGl0emEgbGVzIGVzdGFkw61zdGlxdWVzIGRlbHMgcsOgc3RlcnMgZGVsIGRhdGFzZXQgZGUgbW9zYWljOyBwZXIgdGFudCwgc2kgbGEgdXRpbGl0emV1LCBoZXUgZCdhc3NlZ3VyYXItdm9zIHF1ZSBzJ2hhZ2luIGNhbGN1bGF0IGxlcyBlc3RhZMOtc3RpcXVlcy48ZGl2Pjxici8+RWwgdGlwdXMgZCdleHRlbnNpw7MgZGVmaW5laXggdW5hIGV4dGVuc2nDsyBkJ2hpc3RvZ3JhbWEgcXVlIHMnYXBsaWNhcsOgIGFscyByw6BzdGVycyBwZXIgbWlsbG9yYXItbmUgbCdhcGFyZW7Dp2EuIEwnZXh0ZW5zacOzIG1pbGxvcmEgbCdhcGFyZW7Dp2EgZGUgbGVzIGRhZGVzLCBqYSBxdWUgZXhwYW5kZWl4IGVscyB2YWxvcnMgZGUgcMOteGVsIGVuIHVuIGhpc3RvZ3JhbWEgYSBwYXJ0aXIgZGVscyB2YWxvcnMgbcOtbmltIGkgbcOgeGltIGRlZmluaXRzIHBlciBsYSBzZXZhIHByb2Z1bmRpdGF0IGRlIGJpdHMuIDwvZGl2PlwiLFxuXHRcdHN3YXRoTmFtZTogXCJEYWxsYWRhXCIsXG5cdFx0c3dhdGhTbmlwOiBcIlJlYWxpdHphIGxhIGludGVycG9sYWNpw7MgZGVzIGRlIHF1YWRyw61jdWxlcyBvIGRhZGVzIGRlIGRhbGxhZGEgaXJyZWd1bGFycy5cIixcblx0XHRzd2F0aERlc2M6IFwiQWxndW5zIGRhdGFzZXRzIGRlIG5ldENERiBvIEhERiBlbW1hZ2F0emVtZW4gbGEgc2V2YSBnZW9sb2NhbGl0emFjacOzIGNvbSBhIG1hdHJpdXMgYW1iIGVzcGFpcyBpcnJlZ3VsYXJzLiBFbiBhZmVnaXIgYXF1ZXN0cyBkYXRhc2V0cyBhIHVuIGRhdGFzZXQgZGUgbW9zYWljLCBsYSBmdW5jacOzIERhbGxhZGEgcHJlbiBsZXMgZGFkZXMgcXVhZHJpY3VsYWRlcyBpcnJlZ3VsYXJzIGkgbGVzIHRvcm5hIGEgbW9zdHJlamFyIHBlcnF1w6ggY2FkYSBww614ZWwgdGluZ3VpIHVuYSBtaWRhIHVuaWZvcm1lIGkgc2lndWkgcXVhZHJhdC48ZGl2Pjxici8+RW4gYWZlZ2lyIHZhcmlhYmxlcyBkZSBuZXRDREYgbyBIREYgYSB1biBkYXRhc2V0IGRlIG1vc2FpYywgZXMgdmVyaWZpY2Fyw6AgYXV0b23DoHRpY2FtZW50IHNpIGxlcyBkYWRlcyBzJ2hhbiBkaXNwb3NhdCBhIGxhIG1hdHJpdSBjb3JyZWN0YW1lbnQuIEVuIGNhcyBjb250cmFyaSwgbGEgZnVuY2nDsyBEYWxsYWRhIHMnYXBsaWNhIGF1dG9tw6B0aWNhbWVudCBwZXIgY29udmVydGlyIGVsIHLDoHN0ZXIgaXJyZWd1bGFyIGVuIHB1bnRzIGksIGEgY29udGludWFjacOzLCBlbiB1biByw6BzdGVyIHF1YWRyaWN1bGF0IHJlZ3VsYXIuIFBvZGV1IGNhbnZpYXIgZWwgbcOodG9kZSBkJ2ludGVycG9sYWNpw7MgaSBsYSBtaWRhIGRlIGxhIGNlbMK3bGEgcXVlIHMndXRpbGl0emVuIGEgbGEgZnVuY2nDsyBkZSByw6BzdGVyIERhbGxhZGEuIEVuIGVsIGNhcyBkZSBsZXMgZGFkZXMgZGUgcsOgc3RlciBhbWIgZXNwYWlzIHJlZ3VsYXJzLCBubyBzJ2FwbGljYXLDoCBjYXAgaW50ZXJwb2xhY2nDsyBpIGxlcyBkYWRlcyBlcyBsbGVnaXJhbiB0YWwgcXVhbC48L2Rpdj5cIixcblx0XHR0YW5ITmFtZTogXCJUYW5nZW50IGhpcGVyYsOybGljYSAoVGFuSClcIixcblx0XHR0YW5IU25pcDogXCJDYWxjdWxhIGxhIHRhbmdlbnQgaGlwZXJiw7JsaWNhIGRlIGxlcyBjZWzCt2xlcyBkJ3VuIHLDoHN0ZXIuXCIsXG5cdFx0dGFuSERlc2M6IFwiTGEgZnVuY2nDsyBjYWxjdWxhIGxhIHRhbmdlbnQgaGlwZXJiw7JsaWNhIGRlbHMgcMOteGVscyBkJ3VuIHLDoHN0ZXIuXCIsXG5cdFx0dGFuTmFtZTogXCJUYW5nZW50IChUYW4pXCIsXG5cdFx0dGFuU25pcDogXCJDYWxjdWxhIGxhIHRhbmdlbnQgZGUgbGVzIGNlbMK3bGVzIGQndW4gcsOgc3Rlci5cIixcblx0XHR0YW5EZXNjOiBcIkxhIGZ1bmNpw7MgY2FsY3VsYSBsYSB0YW5nZW50IGRlbHMgcMOteGVscyBkJ3VuIHLDoHN0ZXIuIFwiLFxuXHRcdHRhc3NlbGVkQ2FwTmFtZTogXCJUYXNzZWxlZCBDYXAgKEthdXRoLVRob21hcylcIixcblx0XHR0YXNzZWxlZENhcFNuaXA6IFwiQ2FsY3VsYSBlbHMgbml2ZWxscyBkZSB2ZWdldGFjacOzLCBodW1pdGF0IGkgYnJpbGxhbnRvci4gQXF1ZXN0YSB0w6hjbmljYSBkZXDDqG4gZGUgY29lZmljaWVudHMgcXVlIHMnaGFuIGRlIGNhbGN1bGFyIGVzcGVjw61maWNhbWVudCBwZXIgYSB1biBzZW5zb3IuXCIsXG5cdFx0dGFzc2VsZWRDYXBEZXNjOiBcIkxhIHRyYW5zZm9ybWFjacOzIFRhc3NlbGVkIENhcCAoS2F1dGgtVGhvbWFzKSBzJ2hhIGRpc3NlbnlhdCBwZXIgYW5hbGl0emFyIGkgYXNzaWduYXIgZmVub21lbm9sb2dpYSBkZSBsYSB2ZWdldGFjacOzIGkgY2FudmlzIGRlIGRlc2Vudm9sdXBhbWVudCB1cmLDoCBhIHRyYXbDqXMgZGUgZGl2ZXJzb3Mgc2lzdGVtZXMgZGUgc2Vuc29ycyBzYXRlbMK3bGl0YWxzLiBFcyBjb25laXggY29tIGEgdHJhbnNmb3JtYWNpw7MgVGFzc2VsZWQgQ2FwIGEgY2F1c2EgZGUgbGEgZm9ybWEgZGUgbGEgZGlzdHJpYnVjacOzIGdyw6BmaWNhIGRlIGxlcyBkYWRlcy4gTGEgdHJhbnNmb3JtYWNpw7MgdmEgcHJvcG9yY2lvbmFyIHVuYSBsw7JnaWNhIHBlciBhbHMgcGF0cm9ucyB0cm9iYXRzIGEgbGVzIGRhZGVzIE1TUyBMYW5kc2F0IGRlIGNhbXBzIGFncsOtY29sZXMgY29tIHVuYSBmdW5jacOzIGRlbCBjaWNsZSBkZSB2aWRhIGRlbCBjdWx0aXUuIEVzc2VuY2lhbG1lbnQsIGEgbWVzdXJhIHF1ZSBlbHMgY3VsdGl1cyBjcmVpeGVuIGRlcyBkZSBsYSBsbGF2b3IgZmlucyBhIGxhIG1hZHVyZXNhLCBoaSBoYSB1biBhdWdtZW50IG5ldCBkZSBsJ2luZnJhcm9pZyB2ZXJtZWxsIGkgdW5hIHJlZHVjY2nDsyBkZSBsYSByZWZsZWN0w6BuY2lhIHZlcm1lbGxhIGVuIGJhc2UgYWwgY29sb3IgZGVsIHPDsmw8ZGl2Pjxici8+TGEgdXRpbGl0YXQgZCdhcXVlc3RhIHRyYW5zZm9ybWFjacOzIHMnaGEgYW1wbGlhdCBkZXMgZGUgbGEgc3VwZXJ2aXNpw7MgZGVscyBjdWx0aXVzIGZpbnMgYSBsJ2Fuw6BsaXNpIGkgbCdhc3NpZ25hY2nDsyBkZSB2ZWdldGFjacOzIHBlciBkb25hciBzdXBvcnQgYSB1bmEgw6BtcGxpYSB2YXJpZXRhdCBkJ2FwbGljYWNpb25zLCBjb20gYXJhIGxhIHNpbHZpY3VsdHVyYSwgbGEgZ2VzdGnDsyBkZSBsYSB2ZWdldGFjacOzIGluZHVzdHJpYWwsIGxhIHJlcHJlc2VudGFjacOzIGNhcnRvZ3LDoGZpY2EgaSBsYSBnZXN0acOzIGRlbHMgZWNvc2lzdGVtZXMsIGwnaW52ZW50YXJpIGkgZWwgY29udHJvbCBkZSBsJ2HDr2xsYW1lbnQgZGVsIGNhcmJvbmkgaSBlbHMgY3LDqGRpdHMsIGVsIGRlc2Vudm9sdXBhbWVudCB1cmLDoCwgZXRjLiBUYW1iw6kgcydoYSBhbXBsaWF0IGRlIGxhIGNvbXBhdGliaWxpdGF0IGFtYiBNU1MgTGFuZHNhdCBwZXIgaW5jbG91cmUgYWx0cmVzIHNpc3RlbWVzIGRlIHNhdMOobMK3bGl0IHBvcHVsYXJzLCBjb20gYXJhIExhbmRzYXQgVE0sIExhbmRzYXQgRVRNKywgTGFuZHNhdCA4LCBJS09OT1MsIFF1aWNrQmlyZCwgV29ybGRWaWV3LTIgaSBlbHMgc2Vuc29ycyBtdWx0aWVzcGVjdHJhbHMgUmFwaWRFeWUuPC9kaXY+XCIsXG5cdFx0dGltZXNOYW1lOiBcIk11bHRpcGxpY2FjacOzXCIsXG5cdFx0dGltZXNTbmlwOiBcIk11bHRpcGxpY2EgZWxzIHZhbG9ycyBkZSBkb3MgcsOgc3RlcnMgY2VswrdsYSBwZXIgY2VswrdsYS5cIixcblx0XHR0aW1lc0Rlc2M6IFwiTGEgZnVuY2nDsyBNdWx0aXBsaWNhY2nDsyBtdWx0aXBsaWNhIGVscyB2YWxvcnMgZGUgZG9zIHLDoHN0ZXJzIHDDrXhlbCBwZXIgcMOteGVsLlwiLFxuXHRcdHRyYW5zcG9zZUJpdHNOYW1lOiBcIlRyYW5zcG9zYSBlbHMgYml0c1wiLFxuXHRcdHRyYW5zcG9zZUJpdHNTbmlwOiBcIkRlc2VtcGFxdWV0YSBlbHMgYml0cyBkZWwgcMOteGVsIGQnZW50cmFkYSBpIGVscyBhc3NpZ25hIGFscyBiaXRzIGVzcGVjaWZpY2F0cyBkZWwgcMOteGVsIGRlIHNvcnRpZGEuIExhIGZpbmFsaXRhdCBkJ2FxdWVzdGEgZnVuY2nDsyDDqXMgbWFuaXB1bGFyIGVscyBiaXRzIGQndW4gcGFyZWxsIGQnZW50cmFkZXMsIGNvbSBhcmEgZWxzIHByb2R1Y3RlcyBkZSBiYW5kYSBkZSBxdWFsaXRhdCBkZSBMYW5kc2F0IDguXCIsXG5cdFx0dHJhbnNwb3NlQml0c0Rlc2M6IFwiTGEgZnVuY2nDsyBUcmFuc3Bvc2EgZWxzIGJpdHMgZGVzZW1wYXF1ZXRhIGVscyBiaXRzIGRlbCBww614ZWwgZCdlbnRyYWRhIGkgZWxzIGFzc2lnbmEgYWxzIGJpdHMgZXNwZWNpZmljYXRzIGRlbCBww614ZWwgZGUgc29ydGlkYS4gTGEgZmluYWxpdGF0IGQnYXF1ZXN0YSBmdW5jacOzIMOpcyBtYW5pcHVsYXIgZWxzIGJpdHMgZCd1biBwYXJlbGwgZCdlbnRyYWRlcywgY29tIGFyYSBlbHMgcHJvZHVjdGVzIGRlIGJhbmRhIGRlIHF1YWxpdGF0IGRlIExhbmRzYXQgOC5cIixcblx0XHR1bml0Q29udmVyc2lvbk5hbWU6IFwiQ29udmVyc2nDsyBkJ3VuaXRhdHNcIixcblx0XHR1bml0Q29udmVyc2lvblNuaXA6IFwiQ2FudmlhIGVscyB2YWxvcnMgZCd1bmEgdW5pdGF0IGRlIG1lc3VyYSBhIHVuYSBhbHRyYS5cIixcblx0XHR1bml0Q29udmVyc2lvbkRlc2M6IFwiQXF1ZXN0YSBmdW5jacOzIGNvbnZlcnRlaXggZWxzIHDDrXhlbHMgZCd1bmEgdW5pdGF0IGEgdW5hIGFsdHJhLiBBZG1ldCBsYSBjb252ZXJzacOzIGRlIGRpc3TDoG5jaWEsIHZlbG9jaXRhdCBpIHRlbXBlcmF0dXJhLlwiLFxuXHRcdHZlY3RvckZpZWxkTmFtZTogXCJDYW1wIHZlY3RvcmlhbFwiLFxuXHRcdHZlY3RvckZpZWxkU25pcDogXCJNb3N0cmEgZWxzIGRhdGFzZXRzIGFtYiBlbHMgdmFsb3JzIGRlIG1hZ25pdHVkICh1KSBpIGRpcmVjY2nDsyAodikgY29tIGZsZXR4ZXMgb24gbGEgbWFnbml0dWQgZXMgcmVwcmVzZW50YSBwZXIgbGEgbWlkYSBkZSBsYSBmbGV0eGEgaSBsYSBkaXJlY2Npw7MsIHBlbCBzZXUgYW5nbGUuXCIsXG5cdFx0dmVjdG9yRmllbGREZXNjOiBcIkxhIGZ1bmNpw7MgQ2FtcCB2ZWN0b3JpYWwgcyd1dGlsaXR6YSBwZXIgY29tcG9uZHJlIGkgY29udmVydGlyIGRvcyByw6BzdGVycyBlbiB1biByw6BzdGVyIGRlIGR1ZXMgYmFuZGVzLCBxdWUgc2lndWkgZGVsIHRpcHVzIGRlIGRhZGVzIG1hZ25pdHVkLWRpcmVjY2nDsyBvIFUtVi48ZGl2Pjxici8+RGUgdmVnYWRlcywgZW5zIHJlZmVyaW0gYWwgdmFsb3IgVSBjb20gYSB2ZWxvY2l0YXQgem9uYWwgaSBhbCB2YWxvciBWLCBjb20gYSB2ZWxvY2l0YXQgbWVyaWRpb25hbC48L2Rpdj5cIixcblx0XHR2aWV3c2hlZDJOYW1lOiBcIkNvbmNhIHZpc3VhbFwiLFxuXHRcdHZpZXdzaGVkMlNuaXA6IFwiRGV0ZXJtaW5hIGxlcyB1YmljYWNpb25zIGVuIHVuYSBzdXBlcmbDrWNpZSBkZSByw6BzdGVyIHF1ZSBzw7NuIHZpc2libGVzIHBlciBhIHVuIGNvbmp1bnQgZCdlbnRpdGF0cyBkJ29ic2VydmFkb3IgbWl0amFuw6dhbnQgbcOodG9kZXMgZ2VvZMOoc2ljcy5cIixcblx0XHR2aWV3c2hlZDJEZXNjOiBcIkxhIGZ1bmNpw7MgQ29uY2EgdmlzdWFsIGRldGVybWluYSBsZXMgdWJpY2FjaW9ucyBlbiB1bmEgc3VwZXJmw61jaWUgZGUgcsOgc3RlciBxdWUgc8OzbiB2aXNpYmxlcyBwZXIgYSB1biBjb25qdW50IGQnZW50aXRhdHMgZCdvYnNlcnZhZG9yIG1pdGphbsOnYW50IG3DqHRvZGVzIGdlb2TDqHNpY3M8ZGl2Pjxici8+TGEgdmlzaWJpbGl0YXQgZGUgY2FkYSBjZW50cmUgZGVsIHDDrXhlbCB2ZSBkZXRlcm1pbmFkYSBwZXIgdW5hIHByb3ZhIGRlIGzDrW5pYSBkZSB2aXNpw7MgZW50cmUgbCdvYmplY3RpdSBpIGNhZGEgb2JzZXJ2YWRvci4gU2kgdW4gb2JzZXJ2YWRvciBwb3QgdmV1cmUgbCdvYmplY3RpdSBhbCBjZW50cmUgZGVsIHDDrXhlbCwgZWwgcMOteGVsIGVzIGNvbnNpZGVyYSB2aXNpYmxlLiBBcXVlc3RhIGVpbmEgc2VtcHJlIGNvbnNpZGVyYSBsYSBjdXJ2YXR1cmEgZGUgbGEgVGVycmEgcXVhbiBlcyBkZXRlcm1pbmEgbGEgdmlzaWJpbGl0YXQuPC9kaXY+XCIsXG5cdFx0d2F0ZXJzaGVkTmFtZTogXCJDb25jYSBoaWRyb2dyw6BmaWNhXCIsXG5cdFx0d2F0ZXJzaGVkU25pcDogXCJEZXRlcm1pbmEgbCfDoHJlYSBkZSBjb250cmlidWNpw7Mgc29icmUgdW4gY29uanVudCBkZSBjZWzCt2xlcyBkJ3VuIHLDoHN0ZXJcIixcblx0XHR3YXRlcnNoZWREZXNjOiBcIkxhIGZ1bmNpw7MgQ29uY2EgaGlkcm9ncsOgZmljYSBnbG9iYWwgZGV0ZXJtaW5hIGwnw6ByZWEgZGUgY29udHJpYnVjacOzIHNvYnJlIHVuIGNvbmp1bnQgZGUgcMOteGVscyBkJ3VuIHLDoHN0ZXIuIExlcyBjb25xdWVzIGhpZHJvZ3LDoGZpcXVlcyBlcyBkZWxpbmVlbiBhIHBhcnRpciBkJ3VuIHLDoHN0ZXIgZGUgZGlyZWNjacOzIGRlbCBmbHV4IHF1ZSBpZGVudGlmaWNhIGxhIGRpcmVjY2nDsyBkZWwgZmx1eCBkZSBjYWRhIHDDrXhlbC5cIixcblx0XHR3ZWlnaHRlZE92ZXJsYXlOYW1lOiBcIlN1cGVycG9zaWNpw7MgcG9uZGVyYWRhXCIsXG5cdFx0d2VpZ2h0ZWRPdmVybGF5U25pcDogXCJTdXBlcnBvc2EgZGl2ZXJzb3MgcsOgc3RlcnMgbWl0amFuw6dhbnQgdW5hIGVzY2FsYSBkZSBtZXN1cmEgY29tdW5hIGkgcG9uZGVyYSBjYWRhc2N1biBzZWdvbnMgbGEgc2V2YSBpbXBvcnTDoG5jaWEuXCIsXG5cdFx0d2VpZ2h0ZWRPdmVybGF5RGVzYzogXCJBcXVlc3RhIGZ1bmNpw7MgdXMgcGVybWV0IHN1cGVycG9zYXIgZGl2ZXJzb3MgcsOgc3RlcnMgbWl0amFuw6dhbnQgdW5hIGVzY2FsYSBkZSBtZXN1cmEgY29tdW5hIGkgcG9uZGVyYSBjYWRhc2N1biBzZWdvbnMgbGEgc2V2YSBpbXBvcnTDoG5jaWEuXCIsXG5cdFx0d2VpZ2h0ZWRTdW1OYW1lOiBcIlN1bWEgcG9uZGVyYWRhXCIsXG5cdFx0d2VpZ2h0ZWRTdW1TbmlwOiBcIlBvbmRlcmEgaSBhZmVnZWl4IHVuYSBtYXRyaXUgZGUgcsOgc3RlcnMgY2VswrdsYSBwZXIgY2VswrdsYS5cIixcblx0XHR3ZWlnaHRlZFN1bURlc2M6IFwiTGEgZnVuY2nDsyBTdW1hIHBvbmRlcmFkYSB1cyBwZXJtZXQgc3VwZXJwb3NhciBkaXZlcnNvcyByw6BzdGVycy4gTXVsdGlwbGljYSBjYWRhc2N1biBkJ2FxdWVzdHMgcsOgc3RlcnMgcGVsIHBlcyBlc3BlY2lmaWNhdCBpIGZhIGxhIHN1bWEgZGUgdG90cyBlbHMgdmFsb3JzLlwiLFxuXHRcdHdpbmRjaGlsbE5hbWU6IFwiU2Vuc2FjacOzIHTDqHJtaWNhXCIsXG5cdFx0d2luZGNoaWxsU25pcDogXCJDb21iaW5hIGxhIHRlbXBlcmF0dXJhIGFtYmllbnQgZGUgbCdhaXJlIGFtYiBsYSB2ZWxvY2l0YXQgZGVsIHZlbnQgcGVyIGNhbGN1bGFyIGVsIGZhY3RvciBkZSBzZW5zYWNpw7MgdMOocm1pY2EuXCIsXG5cdFx0d2luZGNoaWxsRGVzYzogXCJMYSBmdW5jacOzIFNlbnNhY2nDsyB0w6hybWljYSByZXN1bHRhIMO6dGlsIHBlciBpZGVudGlmaWNhciBjb25kaWNpb25zIGhpdmVybmFscyBwZXJpbGxvc2VzIHF1ZSwgZW4gZnVuY2nDsyBkZWwgdGVtcHMgZCdleHBvc2ljacOzIGFscyBlbGVtZW50cywgcG90IHByb2R1aXIgY29uZ2VsYWNpw7MgbyBmaW5zIGkgdG90IGhpcG90w6hybWlhLiBMYSBzZW5zYWNpw7MgdMOocm1pY2Egw6lzIHVuYSBtYW5lcmEgZGUgbWVzdXJhciBlbCBmcmVkIHF1ZSBzZW50IHVuYSBwZXJzb25hIHRlbmludCBlbiBjb21wdGUgZWwgdmVudCBxdWFuIGxlcyB0ZW1wZXJhdHVyZXMgamEgc8OzbiBmcmVkZXMuIENvbSBtw6lzIGFsdGEgc2lndWkgbGEgdmVsb2NpdGF0IGRlbCB2ZW50LCBtw6lzIHLDoHBpZGEgc2Vyw6AgbGEgcMOocmR1YSBkZSBjYWxvciBpIG3DqXMgZnJlZCBzZW50aXLDoCBsYSBwZXJzb25hLlwiLFxuXHRcdHpvbmFsUmVtYXBOYW1lOiBcIk5vdmEgcmVwcmVzZW50YWNpw7MgY2FydG9ncsOgZmljYSB6b25hbFwiLFxuXHRcdHpvbmFsUmVtYXBTbmlwOiBcIkZldSB1bmEgbm92YSByZXByZXNlbnRhY2nDsyBjYXJ0b2dyw6BmaWNhIGRlbHMgcMOteGVscyBkJ3VuIHLDoHN0ZXIgc2Vnb25zIGxlcyB6b25lcyBkZWZpbmlkZXMgZW4gdW4gYWx0cmUgcsOgc3RlciBpIGRlIGwnYXNzaWduYWNpw7MgZGVsIHZhbG9yIGRlcGVuZGVudCBkZSBsYSB6b25hIGRlZmluaXQgZW4gdW5hIHRhdWxhLlwiLFxuXHRcdHpvbmFsUmVtYXBEZXNjOiBcIkFxdWVzdGEgZnVuY2nDsyB1cyBwZXJtZXQgZmVyIHVuYSBub3ZhIHJlcHJlc2VudGFjacOzIGNhcnRvZ3LDoGZpY2EgZGVscyBww614ZWxzIGQndW4gcsOgc3RlciBzZWdvbnMgbGVzIHpvbmVzIGRlZmluaWRlcyBlbiB1biBhbHRyZSByw6BzdGVyIGkgZGUgbCdhc3NpZ25hY2nDsyBkZWwgdmFsb3IgZGVwZW5kZW50IGRlIGxhIHpvbmEgZGVmaW5pdCBlbiB1bmEgdGF1bGEuXCIsXG5cdFx0em9uYWxTdGF0aXN0aWNzTmFtZTogXCJFc3RhZMOtc3RpcXVlcyB6b25hbHNcIixcblx0XHR6b25hbFN0YXRpc3RpY3NTbmlwOiBcIkNhbGN1bGEgZXN0YWTDrXN0aXF1ZXMgc29icmUgZWxzIHZhbG9ycyBkJ3VuIHLDoHN0ZXIgZGlucyBkZSBsZXMgem9uZXMgZCd1biBhbHRyZSBkYXRhc2V0LlwiLFxuXHRcdHpvbmFsU3RhdGlzdGljc0Rlc2M6IFwiTGEgZnVuY2nDsyBjYWxjdWxhIGVzdGFkw61zdGlxdWVzIHNvYnJlIGVscyB2YWxvcnMgZCd1biByw6BzdGVyIGRpbnMgZGUgbGVzIHpvbmVzIGQndW4gYWx0cmUgZGF0YXNldC4gVW5hIHpvbmEgZXMgZGVmaW5laXggY29tIHRvdGVzIGxlcyDDoHJlZXMgZGUgbCdlbnRyYWRhIHF1ZSB0ZW5lbiBlbCBtYXRlaXggdmFsb3IuIE5vIMOpcyBuZWNlc3NhcmkgcXVlIGFxdWVzdGVzIMOgcmVlcyBzaWd1aW4gY29udGlnw7xlcy4gU2kgYW1iZHVlcyBlbnRyYWRlcyBkZSB6b25hIGkgdmFsb3Igc8OzbiByw6BzdGVycyBkZSBsYSBtYXRlaXhhIHJlc29sdWNpw7MsIHMndXRpbGl0emFyYW4gZGlyZWN0YW1lbnQuIFNpIGxlcyByZXNvbHVjaW9ucyBzw7NuIGRpZmVyZW50cywgcydhcGxpY2EgdW4gcmVtb3N0cmVpZyBpbnRlcm4gcGVyIGZlciBxdWUgbGVzIHJlc29sdWNpb25zIGNvaW5jaWRlaXhpbiBhYmFucyBkZSByZWFsaXR6YXIgbCdvcGVyYWNpw7Mgem9uYWwuXCIsXG5cdFx0Zmxvd0xlbmd0aE5hbWU6IFwiTG9uZ2l0dWQgZGVsIGZsdXhcIixcblx0XHRmbG93TGVuZ3RoU25pcDogXCJDYWxjdWxhIGxhIGRpc3TDoG5jaWEgYXNjZW5kZW50IG8gZGVzY2VuZGVudCwgbyBiw6kgbGEgZGlzdMOgbmNpYSBwb25kZXJhZGEsIGp1bnRhbWVudCBhbWIgZWwgcmVjb3JyZWd1dCBkZWwgZmx1eCBkZSBjYWRhIGNlbMK3bGEuXCIsXG5cdFx0Zmxvd0xlbmd0aERlc2M6IFwiQXF1ZXN0YSDDqXMgdW5hIGZ1bmNpw7MgZGUgcsOgc3RlciBnbG9iYWwuIEFxdWVzdGEgZnVuY2nDsyBjcmVhIHVuYSBjYXBhIHLDoHN0ZXIgZGUgZGlzdMOgbmNpYSBhc2NlbmRlbnQgbyBkZXNjZW5kZW50LCBvIGLDqSBkZSBkaXN0w6BuY2lhIHBvbmRlcmFkYSwganVudGFtZW50IGFtYiBlbCByZWNvcnJlZ3V0IGRlbCBmbHV4IGRlIGNhZGEgY2VswrdsYS48ZGl2Pjxici8+VW4gw7pzIHByaW1hcmkgZGUgbGEgZnVuY2nDsyBMb25naXR1ZCBkZWwgZmx1eCDDqXMgZWwgY8OgbGN1bCBkZSBsYSBsb25naXR1ZCBkZWwgcmVjb3JyZWd1dCBkZWwgZmx1eCBtw6lzIGxsYXJnIGVuIHVuYSBjb25jYSBkZXRlcm1pbmFkYS4gTm9ybWFsbWVudCwgYXF1ZXN0YSBtZXN1cmEgcyd1dGlsaXR6YSBwZXIgY2FsY3VsYXIgZWwgdGVtcHMgZGUgY29uY2VudHJhY2nDsyBkJ3VuYSBjb25jYS4gRWwgY8OgbGN1bCBlcyBmYSBhbWIgbCdvcGNpw7MgQXNjZW5kZW50LiBMYSBmdW5jacOzIHRhbWLDqSBlcyBwb3QgdXRpbGl0emFyIHBlciBjcmVhciBkaWFncmFtZXMgZGUgZGlzdMOgbmNpYS3DoHJlYSBkJ2VzZGV2ZW5pbWVudHMgZGUgY2FiYWwgaSBwcmVjaXBpdGFjacOzIGhpcG90w6h0aWNzIG1pdGphbsOnYW50IGVsIHLDoHN0ZXIgZGUgcG9uZGVyYWNpw7MgY29tIGEgaW1wZWTDoG5jaWEgcGVyIGFsIHBlbmRlbnQgZGVzY2VuZGVudCBkZWwgbW92aW1lbnQuPC9kaXY+XCIsXG5cdFx0c3RyZWFtT3JkZXJOYW1lOiBcIk9yZHJlIGRlIHRyYW5zbWlzc2nDs1wiLFxuXHRcdHN0cmVhbU9yZGVyU25pcDogXCJBc3NpZ25hIHVuIG9yZHJlIG51bcOocmljIGFscyBzZWdtZW50cyBkJ3VuIHLDoHN0ZXIgcXVlIHJlcHJlc2VudGEgbGVzIGJpZnVyY2FjaW9ucyBkJ3VuYSB4YXJ4YSBsaW5lYWxcIixcblx0XHRzdHJlYW1PcmRlckRlc2M6IFwiQXF1ZXN0YSDDqXMgdW5hIGZ1bmNpw7MgZGUgcsOgc3RlciBnbG9iYWwuIEFxdWVzdGEgZnVuY2nDsyBjcmVhIHVuYSBjYXBhIHLDoHN0ZXIgcXVlIGFzc2lnbmEgdW4gb3JkcmUgbnVtw6hyaWMgYWxzIHNlZ21lbnRzIGQndW4gcsOgc3RlciBxdWUgcmVwcmVzZW50YSBsZXMgYmlmdXJjYWNpb25zIGQndW5hIHhhcnhhIGxpbmVhbC48ZGl2Pjxici8+TGEgc29ydGlkYSBkZSBsYSBmdW5jacOzIE9yZHJlIGRlIHRyYW5zbWlzc2nDsyB0aW5kcsOgIG3DqXMgcXVhbGl0YXQgc2kgbGEgY2FwYSByw6BzdGVyIGRlIHRyYW5zbWlzc2nDsyBkJ2VudHJhZGEgaSBsYSBjYXBhIHLDoHN0ZXIgZGUgZGlyZWNjacOzIGRlbCBmbHV4IGQnZW50cmFkYSBlcyBkZXJpdmVuIGRlIGxhIG1hdGVpeGEgc3VwZXJmw61jaWUuIFNpIGVsIHLDoHN0ZXIgZGUgdHJhbnNtaXNzacOzIGVzIGRlcml2YSBkJ3VuIGRhdGFzZXQgZGUgdHJhbnNtaXNzaW9ucyByYXN0ZXJpdHphZGVzLCBwb3Qgc2VyIHF1ZSBsYSBzb3J0aWRhIG5vIGVzIHB1Z3VpIHV0aWxpdHphci4gRWwgbW90aXUgc2Vyw6AgcXVlIGxhIGRpcmVjY2nDsyBkZSBsZXMgY2VswrdsZXMgaW5kaXZpZHVhbHMgbm8gZXMgY29ycmVzcG9uZHLDoCBhbWIgbGEgdWJpY2FjacOzIGRlIGxlcyBjZWzCt2xlcyBkZSBsYSB0cmFuc21pc3Npw7MuIEVscyByZXN1bHRhdHMgZGUgbGEgZnVuY2nDsyBBY3VtdWxhY2nDsyBkZSBmbHV4IGVzIHBvZGVuIHV0aWxpdHphciBwZXIgY3JlYXIgdW5hIHhhcnhhIGRlIHRyYW5zbWlzc2nDsyBkZSByw6BzdGVyLiBQZXIgZmVyLWhvLCBjYWxkcsOgIGFwbGljYXIgdW4gbGxpbmRhciBwZXIgc2VsZWNjaW9uYXIgbGVzIGNlbMK3bGVzIGFtYiB1biBmbHV4IGFjdW11bGF0IGFsdC4gUGVyIGV4ZW1wbGUsIGxlcyBjZWzCt2xlcyBxdWUgdGluZ3VpbiBtw6lzIGRlIDEwMCBjZWzCt2xlcyBxdWUgaGkgZmx1ZWl4aW4gcyd1dGlsaXR6YXJhbiBwZXIgZGVmaW5pciBsYSB4YXJ4YSBkZSB0cmFuc21pc3Npw7MuIFV0aWxpdHpldSBsYSBmdW5jacOzIENvbmRpY2lvbmFsIG8gRGVmaW5laXggbnVscyBwZXIgY3JlYXIgdW4gcsOgc3RlciBkZSB4YXJ4YSBkZSB0cmFuc21pc3Npw7Mgb24gZWxzIHZhbG9ycyBkJ2FjdW11bGFjacOzIGRlIGZsdXggZGUgMTAwIG8gbcOpcyBzJ2FkcmVjaW4gYSB1bmEsIGkgbGEgcmVzdGEgZXMgZGVpeGluIGVuIHNlZ29uIHRlcm1lIChOb0RhdGEpLiBMYSB4YXJ4YSBkZSB0cmFuc21pc3Npw7MgcmVzdWx0YW50IGVzIHBvdCB1dGlsaXR6YXIgYSBsYSBmdW5jacOzIE9yZHJlIGRlIHRyYW5zbWlzc2nDsy4gQXF1ZXN0YSBmdW5jacOzIG5vbcOpcyBhZG1ldCB1bmEgY2FwYSByw6BzdGVyIGRlIGRpcmVjY2nDsyBkZWwgZmx1eCBkJ2VudHJhZGEgRDguIExlcyBkaXJlY2Npb25zIGRlbCBmbHV4IGVzIHBvZGVuIGNyZWFyIG1pdGphbsOnYW50IGwnZWluYSBEaXJlY2Npw7MgZGVsIGZsdXggaSBleGVjdXRhci1zZSBtaXRqYW7Dp2FudCBlbCB0aXB1cyBkZSBkaXJlY2Npw7MgZGVsIGZsdXggcGVyIGRlZmVjdGUgRDguPC9kaXY+XCIsXG5cdFx0c25hcFBvdXJQb2ludE5hbWU6IFwiQWp1c3RhIGVsIHB1bnQgZGUgZmx1w69kZXNhXCIsXG5cdFx0c25hcFBvdXJQb2ludFNuaXA6IFwiQWp1c3RhIGVscyBwdW50cyBkZSBmbHXDr2Rlc2EgYSBsYSBjZWzCt2xhIGFtYiBsJ2FjdW11bGFjacOzIGRlIGZsdXggbcOpcyBhbHRhIGRpbnMgZCd1bmEgZGlzdMOgbmNpYSBlc3BlY2lmaWNhZGFcIixcblx0XHRzbmFwUG91clBvaW50RGVzYzogXCJBcXVlc3RhIMOpcyB1bmEgZnVuY2nDsyBkZSByw6BzdGVyIGdsb2JhbC4gQXF1ZXN0YSBmdW5jacOzIGFqdXN0YSBlbHMgcHVudHMgZGUgZmx1w69kZXNhIGEgbGEgY2VswrdsYSBhbWIgdW5hIGFjdW11bGFjacOzIGRlIGZsdXggbcOpcyBhbHRhIGRpbnMgZCd1bmEgZGlzdMOgbmNpYSBlc3BlY2lmaWNhZGEuPGRpdj48YnIvPkxhIGZ1bmNpw7MgQWp1c3RhIGVsIHB1bnQgZGUgZmx1w69kZXNhIHMndXRpbGl0emEgcGVyIGdhcmFudGlyIGxhIHNlbGVjY2nDsyBkZSBwdW50cyBhbWIgdW4gZmx1eCBhY3VtdWxhdCBhbHQgZW4gZGVsaW5lYXIgbGVzIGNvbnF1ZXMgZGUgZHJlbmF0Z2UgbWl0amFuw6dhbnQgbGEgZnVuY2nDsyBDb25jYSBoaWRyb2dyw6BmaWNhLiBMYSBmdW5jacOzIEFqdXN0YSBlbCBwdW50IGRlIGZsdcOvZGVzYSBmYXLDoCB1bmEgY2VyY2EgZGlucyBkJ3VuYSBkaXN0w6BuY2lhIGQnYWxpbmVhY2nDsyBhbCB2b2x0YW50IGRlbHMgcHVudHMgZGUgZmx1w69kZXNhIGVzcGVjaWZpY2F0cyBkZSBsYSBjZWzCt2xhIGFtYiBlbCBmbHV4IGFjdW11bGF0IG3DqXMgYWx0IGkgbW91csOgIGVsIHB1bnQgZGUgZmx1w69kZXNhIGEgYXF1ZXN0YSB1YmljYWNpw7MuIExhIHNvcnRpZGEgw6lzIHVuYSBjYXBhIHLDoHN0ZXIgZCdlbnRlciBzaSBsZXMgdWJpY2FjaW9ucyBkZWxzIHB1bnRzIGRlIGZsdcOvZGVzYSBvcmlnaW5hbHMgcydoYW4gYWp1c3RhdCBhIGxlcyB1YmljYWNpb25zIGFtYiB1biBmbHV4IGFjdW11bGF0IG3DqXMgYWx0LjwvZGl2PlwiLFxuXHRcdHNpbmtOYW1lOiBcIkVtYm9ybmFsXCIsXG5cdFx0c2lua1NuaXA6IFwiQ3JlYSB1biByw6BzdGVyIHF1ZSBpZGVudGlmaWNhIHRvdHMgZWxzIGVtYm9ybmFscyBvIGxlcyDDoHJlZXMgZGUgZHJlbmF0Z2UgaW50ZXJuXCIsXG5cdFx0c2lua0Rlc2M6IFwiQXF1ZXN0YSDDqXMgdW5hIGZ1bmNpw7MgZGUgcsOgc3RlciBnbG9iYWwuIEFxdWVzdGEgZnVuY2nDsyBjcmVhIHVuYSBjYXBhIHLDoHN0ZXIgcXVlIGlkZW50aWZpY2EgdG90cyBlbHMgZW1ib3JuYWxzIG8gbGVzIMOgcmVlcyBkZSBkcmVuYXRnZSBpbnRlcm4uIFVuIGVtYm9ybmFsIMOpcyB1bmEgY2VswrdsYSBvIHVuIGNvbmp1bnQgZGUgY2VswrdsYSBjb25uZWN0YWRlcyBkZSBtYW5lcmEgZXNwYWNpYWwgYW1iIHVuYSBkaXJlY2Npw7MgZGVsIGZsdXggYSBsYSBxdWFsIG5vIGVzIHBvdCBhc3NpZ25hciB1biBkZWxzIHZ1aXQgdmFsb3JzIHbDoGxpZHMgZCd1biByw6BzdGVyIGRlIGRpcmVjY2nDsyBkZWwgZmx1eC4gQWl4w7IgcG90IHBhc3NhciBzaSB0b3RlcyBsZXMgY2VswrdsZXMgdmXDr25lcyBzw7NuIG3DqXMgYWx0ZXMgcXVlIGxhIGNlbMK3bGEgZGUgcHJvY2Vzc2FtZW50IG8gc2kgZHVlcyBjZWzCt2xhIGZsdWVpeGVuIGQndW5hIGEgbCdhbHRyYSBpIGNyZWVuIHVuIGJ1Y2xlIGRlIGR1ZXMgY2VswrdsZXMuPGRpdj48YnIvPkxhIGZ1bmNpw7MgRW1ib3JuYWwgbm9tw6lzIGFkbWV0IHVuYSBjYXBhIHLDoHN0ZXIgZGUgZGlyZWNjacOzIGRlbCBmbHV4IGQnZW50cmFkYSBEOC4gTGVzIGRpcmVjY2lvbnMgZGVsIGZsdXggZXMgcG9kZW4gY3JlYXIgbWl0amFuw6dhbnQgbCdlaW5hIERpcmVjY2nDsyBkZWwgZmx1eCBpIGV4ZWN1dGFyLXNlIG1pdGphbsOnYW50IGVsIHRpcHVzIGRlIGRpcmVjY2nDsyBkZWwgZmx1eCBwZXIgZGVmZWN0ZSBEOC4gTGEgc29ydGlkYSBkZSBsYSBmdW5jacOzIEVtYm9ybmFsIMOpcyB1biByw6BzdGVyIGQnZW50ZXIsIG9uIHMnYXNzaWduYSB1biB2YWxvciDDum5pYyBhIGNhZGEgZW1ib3JuYWwuIEFxdWVzdHMgdmFsb3JzIMO6bmljcyB0ZW5lbiB1biBpbnRlcnZhbCBlbnRyZSB1biBpIGVsIG5vbWJyZSB0b3RhbCBkJ2VtYm9ybmFscy4gUGVyIGV4ZW1wbGUsIHNpIGVsIG5vbWJyZSB0b3RhbCBkJ2VtYm9ybmFscyBmb3MgMTAwMCwgbCdpbnRlcnZhbCBkZSB2YWxvcnMgw7puaWNzIHNlcmlhIGQnMSBhIDEwMDAuPC9kaXY+XCIsXG5cdFx0YWdncmVnYXRlTmFtZTogXCJBZ3JlZ2FcIixcblx0XHRhZ2dyZWdhdGVTbmlwOiBcIkdlbmVyYSB1bmEgdmVyc2nDsyBkZSByZXNvbHVjacOzIHJlZHXDr2RhIGQndW4gcsOgc3Rlci5cIixcblx0XHRhZ2dyZWdhdGVEZXNjOiBcIkxhIGZ1bmNpw7MgQWdyZWdhIHRvcm5hIGEgbW9zdHJlamFyIHVuIHLDoHN0ZXIgZCdlbnRyYWRhIGFtYiB1bmEgcmVzb2x1Y2nDsyBtw6lzIGJhaXhhIGVuIGZ1bmNpw7MgZCd1bmEgZXN0cmF0w6hnaWEgZCdhZ3JlZ2FjacOzIGVzcGVjaWZpY2FkYS4gQ2FkYSBjZWzCt2xhIGRlIHNvcnRpZGEgY29udMOpIGxhIHN1bWEsIGVsIG3DrW5pbSwgZWwgbcOgeGltLCBsYSBtaXRqYW5hIG8gbGEgbWVkaWFuYSBkZSBsZXMgY2VswrdsZXMgZCdlbnRyYWRhIGNvbXByZXNlcyBlbiBsJ2V4dGVuc2nDsyBkJ2FxdWVzdGEgY2VswrdsYS48ZGl2Pjxici8+UG9kZXUgZXNwZWNpZmljYXIgZWwgZmFjdG9yIHBlbCBxdWUgZXMgbXVsdGlwbGljYXLDoCBsYSBtaWRhIGRlIGNlbMK3bGEgZGVsIHLDoHN0ZXIgZCdlbnRyYWRhLiBQZXIgZXhlbXBsZSwgdW4gdmFsb3IgZGUgZmFjdG9yIGRlIGNlbMK3bGEgZGUgMyB0aW5kcsOgIGNvbSBhIHJlc3VsdGF0IHVuYSBtaWRhIGRlIGNlbMK3bGEgZGUgc29ydGlkYSB0cmVzIHZlZ2FkZXMgc3VwZXJpb3IgYSBsYSBkZWwgcsOgc3RlciBkJ2VudHJhZGEuIFBvZGV1IGRlZmluaXIgY29tIGVzIGdlc3Rpb25hIGwnZXh0ZW5zacOzIGRlIGxhIHNvcnRpZGEgc2kgZWwgbm9tYnJlIGRlIGZpbGVzIG8gZGUgY29sdW1uZXMgZGUgbGEgc29ydGlkYSBubyDDqXMgdW4gbcO6bHRpcGxlIGV4YWN0ZSBkZWwgZmFjdG9yIGRlIGNlbMK3bGEuIFBlciBkZWZlY3RlLCBlbHMgbMOtbWl0cyBzdXBlcmlvciBpIGRyZXQgcydleHBhbmRpcmFuIHBlciBjb2JyaXIgdW5hIGV4dGVuc2nDsyBlc3BhY2lhbCBtw6lzIGdyYW4gcXVlIGxhIGRlbCByw6BzdGVyIGQnZW50cmFkYSBwZXIgYXNzZWd1cmFyIHF1ZSBlcyBwcm9jZXNzZW4gdG90ZXMgbGVzIGNlbMK3bGVzIGQnZW50cmFkYS4gVGFtYsOpIGVzIHBvZGVuIHJlZHVpciBlbHMgbMOtbWl0cyBzdXBlcmlvciBpIGRyZXQgcGVyIGNvYnJpciB1bmEgZXh0ZW5zacOzIG3DqXMgcGV0aXRhLCBkZSBtYW5lcmEgcXVlIGVsIG5vbWJyZSBkZSBmaWxlcyBpIGRlIGNvbHVtbmVzIHF1ZSBlcyBwcm9jZXNzaSBzaWd1aSB1biBtw7psdGlwbGUgZXhhY3RlIGRlbCBmYWN0b3IgZGUgY2VswrdsYS4gUG9kZXUgZGVmaW5pciBjb20gcydoYW4gZGUgZ2VzdGlvbmFyIGxlcyBjZWzCt2xlcyBOb0RhdGEgYW1iIGVsIGPDoGxjdWwgZCdhZ3JlZ2FjacOzLiBFbCBtZWNhbmlzbWUgcGVyIGRlZmVjdGUgw6lzIHF1ZSBsZXMgY2VswrdsZXMgTm9EYXRhIGQnZW50cmFkYSBxdWUgZXMgdHJvYmluIGRpbnMgZGUgbCdleHRlbnNpw7MgZXNwYWNpYWwgZCd1bmEgY2VswrdsYSBtw6lzIGdyYW4gZGVsIHLDoHN0ZXIgZGUgc29ydGlkYSBzJ2lnbm9yYXJhbiBlbiBkZXRlcm1pbmFyIGVsIHZhbG9yIGRlIGxhIGNlbMK3bGEgZGUgc29ydGlkYS4gVGFtYsOpIHBvZGV1IGVzcGVjaWZpY2FyIHF1ZSwgc2kgaGkgaGEgYWxndW5hIGNlbMK3bGEgTm9EYXRhIGQnZW50cmFkYSBhIGwnZXh0ZW5zacOzIGVzcGFjaWFsIGQndW5hIGNlbMK3bGEgZGUgc29ydGlkYSwgbGEgY2VswrdsYSBzZXLDoCBOb0RhdGEgYWwgcsOgc3RlciBkZSBzb3J0aWRhLjwvZGl2PlwiLFxuXHRcdGNjZGNOYW1lOiBcIkFuw6BsaXNpIGRlIENDRENcIixcblx0XHRjY2RjU25pcDogXCJBdmFsdWEgZWxzIGNhbnZpcyBlbiBlbHMgdmFsb3JzIGRlIHDDrXhlbCBhbCBsbGFyZyBkZWwgdGVtcHMgbWl0amFuw6dhbnQgbCdhbGdvcml0bWUgRGV0ZWNjacOzIGkgY2xhc3NpZmljYWNpw7MgY29udMOtbnVlcyBkZWxzIGNhbnZpcyAoQ0NEQykgaSBnZW5lcmEgcmVzdWx0YXRzIGRlbHMgbW9kZWxzLlwiLFxuXHRcdGNjZGNEZXNjOiBcIkxhIGZ1bmNpw7MgQW7DoGxpc2kgZGUgQ0NEQyBhdmFsdWEgZWxzIGNhbnZpcyBlbiBlbHMgdmFsb3JzIGRlIHDDrXhlbCBhbCBsbGFyZyBkZWwgdGVtcHMgbWl0amFuw6dhbnQgbCdhbGdvcml0bWUgRGV0ZWNjacOzIGkgY2xhc3NpZmljYWNpw7MgY29udMOtbnVlcyBkZWxzIGNhbnZpcyAoQ0NEQykgaSBnZW5lcmEgdW4gcsOgc3RlciBtdWx0aWRpbWVuc2lvbmFsIGFtYiBlbHMgcmVzdWx0YXRzIGRlbHMgbW9kZWxzLiBOb23DqXMgcydhZG1ldCBqdW50YW1lbnQgYW1iIGxhIGZ1bmNpw7MgRGV0ZWN0YSBlbHMgY2FudmlzIGEgcGFydGlyIGRlIGwnYW7DoGxpc2kgZGUgY2FudmlzIGVuIHVuYSBwbGFudGlsbGEgZGUgZnVuY2nDsyBkZSByw6BzdGVyLiBQZXIgcHJvZHVpciB1biByw6BzdGVyIGRlIHNvcnRpZGEsIGNvbm5lY3RldSBsYSBmdW5jacOzIEFuw6BsaXNpIGRlIENDREMgYW1iIGxhIGZ1bmNpw7MgRGV0ZWN0YSBlbHMgY2FudmlzIGEgcGFydGlyIGRlIGwnYW7DoGxpc2kgZGUgY2FudmlzLCBkZXNldS1obyBjb20gYSBwbGFudGlsbGEgZGUgZnVuY2nDsyBkZSByw6BzdGVyIGkgZXhlY3V0ZXUgbCdhbsOgbGlzaSBkZSByw6BzdGVyIGFtYiBsYSBwbGFudGlsbGEgZGUgZnVuY2nDsy48ZGl2Pjxici8+QXF1ZXN0YSBmdW5jacOzIHV0aWxpdHphIGwnYWxnb3JpdG1lIERldGVjY2nDsyBpIGNsYXNzaWZpY2FjacOzIGNvbnTDrW51ZXMgZGVscyBjYW52aXMgKENDREMpIHBlciBhdmFsdWFyIGVscyBjYW52aXMgZW4gZWxzIHZhbG9ycyBkZSBww614ZWwgYWwgbGxhcmcgZGVsIHRlbXBzIHBlciBhIHVuIGNvbmp1bnQgZCdpbWF0Z2VzLiBFbiB1bmEgc8OocmllIHRlbXBvcmFsIGQnaW1hdGdlcyDDsnB0aXF1ZXMgbyBkZSBkZXJpdmF0cyBkJ2ltYXRnZXMgKHBlciBleGVtcGxlLCB1biBORFZJKSwgZWxzIHZhbG9ycyBkZSBww614ZWwgcG9kZW4gZmx1Y3R1YXIgcGVyIGRpdmVyc29zIG1vdGl1czogMS4gQ2FudmkgZXN0YWNpb25hbDogZWxzIGNhbnZpcyBkZSB2YWxvcnMgZGUgcMOteGVsIHJlZmxlY3RlaXhlbiBlbHMgY2FudmlzIGVuIGxhIHZlZ2V0YWNpw7MgYSBjYXVzYSBkZSBsYSB2YXJpYWJpbGl0YXQgZXN0YWNpb25hbCBkZSBsYSB0ZW1wZXJhdHVyYSBpIGxlcyBwcmVjaXBpdGFjaW9ucy4gUGVyIGV4ZW1wbGUsIGEgbCdoZW1pc2Zlcmkgbm9yZCBzJ2VzcGVyYSB1bmEgbWFqb3IgZGVuc2l0YXQgZGUgdmVnZXRhY2nDsyB2ZXJkYSBhIGwnZXN0aXUgcXVlIGEgbCdoaXZlcm4uIDIuIENhbnZpIGdyYWR1YWw6IGVscyBjYW52aXMgZW4gZWxzIHZhbG9ycyBkZSBww614ZWwgcmVmbGVjdGVpeGVuIGxlcyB0ZW5kw6huY2llcyBlbiBsYSB2ZWdldGFjacOzIG8gbCdhaWd1YSBzdXBlcmZpY2lhbCBhIGNhdXNhIGRlIGxhIHZhcmlhYmlsaXRhdCBjbGltw6B0aWNhIG8gbGVzIHByw6BjdGlxdWVzIGRlIGdlc3Rpw7MgZGVsIHPDsmwgYSBsbGFyZyB0ZXJtaW5pLiBQZXIgZXhlbXBsZSwgZWwgc8OybCBudSBwb3QgYXVnbWVudGFyIGdyYWR1YWxtZW50IGVuIHVuYSB6b25hIGEgY2F1c2EgZCd1bmEgZGF2YWxsYWRhIGEgbGxhcmcgdGVybWluaSBkZSBsZXMgcHJlY2lwaXRhY2lvbnMuIDMuIENhbnZpIGFicnVwdGU6IGVscyBjYW52aXMgZW4gZWxzIHZhbG9ycyBkZSBww614ZWwgcG9kZW4gcmVmbGVjdGlyIGNhbnZpcyBlbiBsYSBjb2JlcnR1cmEgZGVsIHPDsmwgcXVlIHBvZGVuIHByb2R1aXItc2UgZGUgc29idGUgYSBjYXVzYSBkZSBsYSBkZXNmb3Jlc3RhY2nDsywgZWwgZGVzZW52b2x1cGFtZW50IHVyYsOgLCBkZXNhc3RyZXMgbmF0dXJhbHMsIGV0Yy4gTCdhbGdvcml0bWUgQ0NEQyBpZGVudGlmaWNhIHRvdHMgdHJlcyB0aXB1cyBkZSBjYW52aXMgYW1iIGwnb2JqZWN0aXUgcHJpbmNpcGFsIGQnaWRlbnRpZmljYXIgdW4gY2FudmkgYWJydXB0ZS4gTGEgcmVncmVzc2nDsyBoYXJtw7JuaWNhIGkgZWxzIG1vZGVscyBkZSB0ZW5kw6huY2lhIHMnYWp1c3RlbiBhIGxlcyBkYWRlcyBwZXIgZXN0aW1hciB1biBjYW52aSBlc3RhY2lvbmFsIGkgZ3JhZHVhbCwgaSBsZXMgZGVzdmlhY2lvbnMgc29idGFkZXMgZGVscyBtb2RlbHMgZGUgdGVuZMOobmNpYSBzw7NuIGluZGljYWNpb25zIGQndW4gY2FudmkgYWJydXB0ZS48ZGl2Pjxici8+TCdhbGdvcml0bWUgQ0NEQyBlcyB2YSBkaXNzZW55YXIgb3JpZ2luYWxtZW50IHBlciBhIGRhZGVzIGRlbCBMYW5kc2F0IFRNLCBlbCBMYW5kc2F0IEVUTSsgaSBlbCBMYW5kc2F0IE9MSSBkZSByZWZsZWN0w6BuY2lhIGRlIGxhIHN1cGVyZsOtY2llIG8gZGUgdGVtcGVyYXR1cmEgZGUgYnJpbGxhbnRvci4gVGFubWF0ZWl4LCBsYSBmdW5jacOzIERldGVjdGEgZWxzIGNhbnZpcyBhIHBhcnRpciBkZSBsJ2Fuw6BsaXNpIGRlIGNhbnZpcyBqdW50YW1lbnQgYW1iIGFxdWVzdGEgZnVuY2nDsyBkZXRlY3RhcmFuIGVscyBjYW52aXMgZGUgbGVzIGltYXRnZXMgbXVsdGliYW5kYSBkZSBxdWFsc2V2b2wgc2Vuc29yIGNvbXBhdGlibGUsIGFpeMOtIGNvbSBkZWxzIGRlcml2YXRzIGQnaW1hdGdlcyBkJ3VuYSBiYW5kYSBjb20gYXJhIGVscyDDrW5kZXggZGUgYmFuZGEuIFBlciBleGVtcGxlLCBwb2RldSBkdXIgYSB0ZXJtZSB1bmEgZGV0ZWNjacOzIGNvbnTDrW51YSBkZSBjYW52aXMgZW4gdW4gcsOgc3RlciBkJ8OtbmRleCBkZSB2ZWdldGFjacOzIGFtYiBkaWZlcsOobmNpYSBub3JtYWxpdHphZGEgKE5EVkkpLCBqYSBxdWUgZWxzIGNhbnZpcyBhIGwnTkRWSSBwb2RlbiBpbmRpY2FyIHVuYSBkZXNmb3Jlc3RhY2nDsy48L2Rpdj5cIixcblx0XHRjb21wdXRlQ2hhbmdlTmFtZTogXCJDYWxjdWxhIGVsIGNhbnZpXCIsXG5cdFx0Y29tcHV0ZUNoYW5nZVNuaXA6IFwiQ2FsY3VsYSBsYSBkaWZlcsOobmNpYSBlbnRyZSBkb3MgZGF0YXNldHMgcsOgc3RlciBjb250aW51cyBvIGNhdGVnw7JyaWNzLlwiLFxuXHRcdGNvbXB1dGVDaGFuZ2VEZXNjOiBcIkxhIGZ1bmNpw7MgQ2FsY3VsYSBlbCBjYW52aSBlcyBwb3QgdXRpbGl0emFyIHBlciBlbnVtZXJhciBsZXMgZGlmZXLDqG5jaWVzIGVudHJlIGRvcyByw6BzdGVycyBjbGFzc2lmaWNhdHMgcGVyIGEgbCdhbsOgbGlzaSBkZSBjYW52aXMgZW4gbGEgY29iZXJ0dXJhIGRlIHPDsmwsIG8gYsOpIHBlciBleGFtaW5hciBlbHMgY2FudmlzIGVudHJlIGRvcyByw6BzdGVycyBjb250aW51cyBkJ3VuYSBiYW5kYSBjb20gYXJhIGwnZWxldmFjacOzLCBsYSB0ZW1wZXJhdHVyYSwgbGEgY29iZXJ0YSB2ZWdldGFsLCBldGMuXCIsXG5cdFx0ZGV0ZWN0Q2hhbmdlTmFtZTogXCJEZXRlY3RhIGVscyBjYW52aXMgYSBwYXJ0aXIgZGUgbCdhbsOgbGlzaSBkZSBjYW52aXNcIixcblx0XHRkZXRlY3RDaGFuZ2VTbmlwOiBcIkdlbmVyYSB1bmEgY2FwYSByw6BzdGVyIGFtYiBpbmZvcm1hY2nDsyBzb2JyZSBlbHMgY2FudmlzIGRlbHMgcMOteGVscyBtaXRqYW7Dp2FudCBlbCByw6BzdGVyIGQnYW7DoGxpc2kgZGUgY2FudmlzIGRlIHNvcnRpZGEuXCIsXG5cdFx0ZGV0ZWN0Q2hhbmdlRGVzYzogXCI8ZGl2PkxhIGZ1bmNpw7MgRGV0ZWN0YSBlbHMgY2FudmlzIGEgcGFydGlyIGRlIGwnYW7DoGxpc2kgZGUgY2FudmlzIGdlbmVyYSB1bmEgY2FwYSByw6BzdGVyIGFtYiBpbmZvcm1hY2nDsyBkZSBsYSBkYXRhIGRlbHMgY2FudmlzIGRlbHMgcMOteGVscyBtaXRqYW7Dp2FudCBlbCByw6BzdGVyIGQnYW7DoGxpc2kgZGUgY2FudmlzLiBFbCByw6BzdGVyIGQnYW7DoGxpc2kgZGUgY2FudmlzIHMnaGEgZGUgZ2VuZXJhciBhbWIgbCdlaW5hIEFuYWxpdHphIGVscyBjYW52aXMgYW1iIENDREMsIGwnZWluYSBBbmFsaXR6YSBlbHMgY2FudmlzIGFtYiBMYW5kVHJlbmRyLCBsYSBmdW5jacOzIGRlIHLDoHN0ZXIgQW7DoGxpc2kgZGUgQ0NEQyBvIGxhIGZ1bmNpw7MgZGUgcsOgc3RlciBBbsOgbGlzaSBkZSBMYW5kVHJlbmRyLjwvZGl2Pjxicj48ZGl2PkFxdWVzdGEgZnVuY2nDsyBkZSByw6BzdGVyIGVzIHBvdCBjb21iaW5hciBhbWIgbGEgZnVuY2nDsyBkZSByw6BzdGVyIEFuw6BsaXNpIGRlIENDREMgbyBsYSBmdW5jacOzIGRlIHLDoHN0ZXIgQW7DoGxpc2kgZGUgTGFuZFRyZW5kciBlbiB1bmEgcGxhbnRpbGxhIGRlIGZ1bmNpw7MgZGUgcsOgc3Rlci4gUGVyIHByb2R1aXIgdW4gcsOgc3RlciBkZSBzb3J0aWRhIHBlcm1hbmVudCwgY29ubmVjdGV1IGxhIHNvcnRpZGEgZGUgbGVzIGZ1bmNpb25zIEFuw6BsaXNpIGRlIENDREMgbyBBbsOgbGlzaSBkZSBMYW5kVHJlbmRyIGFtYiBsYSBmdW5jacOzIERldGVjdGEgZWxzIGNhbnZpcyBhIHBhcnRpciBkZSBsJ2Fuw6BsaXNpIGRlIGNhbnZpcywgZGVzZXUtaG8gY29tIGEgcGxhbnRpbGxhIGRlIGZ1bmNpw7MgZGUgcsOgc3RlciBpIGV4ZWN1dGV1IGwnYW7DoGxpc2kgZGUgcsOgc3RlciBhbWIgbGEgcGxhbnRpbGxhLjwvZGl2Pjxicj48ZGl2PkVsIHBhcsOgbWV0cmUgPHN0cm9uZz5UaXB1cyBkZSBjYW52aTwvc3Ryb25nPiBpbmRpY2EgbGEgaW5mb3JtYWNpw7MgcXVlIGVzIGdlbmVyYS4gTGEgaW5mb3JtYWNpw7MgcydleHRyZXUgZGVsIHLDoHN0ZXIgZCdhbsOgbGlzaSBkZSBjYW52aXMuIEVuIGV4ZWN1dGFyIGFxdWVzdGEgZnVuY2nDsyBhIGxhIHNvcnRpZGEgZGUgbGEgZnVuY2nDsyBvIGwnZWluYSBkZSBDQ0RDLCBwb2RldSB0cmlhciB1bmEgZCdhcXVlc3RlcyBvcGNpb25zOjwvZGl2Pjx1bD48bGk+PHN0cm9uZz5Ib3JhIGRlIGwnw7psdGltIGNhbnZpPC9zdHJvbmc+OiBkYXRhIGkgaG9yYSBtw6lzIHJlY2VudCBlbiBxdcOoIHVuIHDDrXhlbCBlcyB2YSBtYXJjYXIgY29tIGEgY2FudmlhdC48L2xpPjxsaT48c3Ryb25nPkhvcmEgZGVsIHByaW1lciBjYW52aTwvc3Ryb25nPjogZGF0YSBpIGhvcmEgbcOpcyBhbnRpZ3VlcyBlbiBxdcOoIGVsIHDDrXhlbCBlcyB2YSBtYXJjYXIgY29tIGEgY2FudmlhdC48L2xpPjxsaT48c3Ryb25nPkhvcmEgZGVsIGNhbnZpIG3DqXMgZ3Jhbjwvc3Ryb25nPjogZGF0YSBpIGhvcmEgZW4gcXXDqCBlbCBjYW52aSBjYWxjdWxhdCBlcmEgbcOpcyBzaWduaWZpY2FudCBwZXIgYSB1biBww614ZWwuPC9saT48bGk+IDxzdHJvbmc+Tm9tYnJlIGRlIGNhbnZpczwvc3Ryb25nPjogbm9tYnJlIHRvdGFsIGRlIHZlZ2FkZXMgcXVlIGVsIHDDrXhlbCBoYSBjYW52aWF0LjwvbGk+PC91bD48ZGl2PkVuIGV4ZWN1dGFyIGFxdWVzdGEgZnVuY2nDsyBhIGxhIHNvcnRpZGEgZGUgbGEgZnVuY2nDsyBvIGwnZWluYSBkZSBMYW5kVHJlbmRyLCBoaSBoYSBkaXNwb25pYmxlcyBhcXVlc3RlcyBvcGNpb25zIGFkZGljaW9uYWxzOjwvZGl2Pjx1bD48bGk+PHN0cm9uZz5UZW1wcyBkZWwgY2FudmkgbcOpcyBsbGFyZzwvc3Ryb25nPjogZGF0YSBlbiBxdcOoIHVuIHDDrXhlbCBlcyB2YSBtYXJjYXIgY29tIGEgY2FudmlhdCwgYWwgcHJpbmNpcGkgbyBhbCBmaW5hbCBkZWwgcGVyw61vZGUgZGUgY2FudmkgbcOpcyBsbGFyZy48L2xpPjxsaT48c3Ryb25nPlRlbXBzIGRlbCBjYW52aSBtw6lzIGN1cnQ8L3N0cm9uZz46IGRhdGEgZW4gcXXDqCB1biBww614ZWwgZXMgdmEgbWFyY2FyIGNvbSBhIGNhbnZpYXQsIGFsIHByaW5jaXBpIG8gYWwgZmluYWwgZGVsIHBlcsOtb2RlIGRlIGNhbnZpIG3DqXMgY3VydC48L2xpPjxsaT48c3Ryb25nPlRlbXBzIGRlbCBjYW52aSBtw6lzIHLDoHBpZDwvc3Ryb25nPjogZGF0YSBlbiBxdcOoIHVuIHDDrXhlbCBlcyB2YSBtYXJjYXIgY29tIGEgY2FudmlhdCwgYWwgcHJpbmNpcGkgbyBhbCBmaW5hbCBkZWwgcGVyw61vZGUgZGUgY2FudmkgbcOpcyByw6BwaWQuPC9saT48bGk+PHN0cm9uZz5UZW1wcyBkZWwgY2FudmkgbcOpcyBsZW50PC9zdHJvbmc+OiBkYXRhIGVuIHF1w6ggdW4gcMOteGVsIGVzIHZhIG1hcmNhciBjb20gYSBjYW52aWF0LCBhbCBwcmluY2lwaSBvIGFsIGZpbmFsIGRlbCBwZXLDrW9kZSBkZSBjYW52aSBtw6lzIGxlbnQuPC9saT48L3VsPjxkaXY+RWwgcsOgc3RlciBkZSBzb3J0aWRhIMOpcyB1biByw6BzdGVyIG11bHRpYmFuZGEgZW4gcXXDqCBjYWRhIGJhbmRhIGNvbnTDqSBpbmZvcm1hY2nDsyBzb2JyZSBlbHMgY2FudmlzIGVuIGZ1bmNpw7MgZGVsIHRpcHVzIGRlIGNhbnZpIHNlbGVjY2lvbmF0IGkgZWwgbm9tYnJlIG3DoHhpbSBkZSBjYW52aXMgZXNwZWNpZmljYXQuIFBlciBleGVtcGxlLCBzaSA8c3Ryb25nPlRpcHVzIGRlIGNhbnZpPC9zdHJvbmc+IHMnaGEgZGVmaW5pdCBjb20gYSA8c3Ryb25nPkhvcmEgZGVsIHByaW1lciBjYW52aTwvc3Ryb25nPiBpIDxzdHJvbmc+Tm9tYnJlIG3DoHhpbSBkZSBjYW52aXM8L3N0cm9uZz4gcydoYSBkZWZpbml0IGNvbSBhIDIsIGxhIGZ1bmNpw7MgY2FsY3VsYSBsZXMgZHVlcyBwcmltZXJlcyBkYXRlcyBlbiBxdcOoIHMnaGFuIHByb2R1w690IGNhbnZpcyBhIGxhIHPDqHJpZSB0ZW1wb3JhbCBkZSBjYWRhIHDDrXhlbC4gRWwgcmVzdWx0YXQgw6lzIHVuIHLDoHN0ZXIgZW4gcXXDqCBsYSBwcmltZXJhIGJhbmRhIGNvbnTDqSBsZXMgZGF0ZXMgZGVsIHByaW1lciBjYW52aSBwZXIgcMOteGVsIGkgbGEgc2Vnb25hIGJhbmRhIGNvbnTDqSBsZXMgZGF0ZXMgZGVsIHNlZ29uIGNhbnZpIHBlciBww614ZWwuPC9kaXY+PGJyPjxkaXY+RW4gYXBsaWNhciBhcXVlc3RhIGZ1bmNpw7MgYSBsYSBzb3J0aWRhIGRlIGxlcyBlaW5lcyBkZSBMYW5kVHJlbmRyLCBwb3RzIHRyaWFyIHNpIHZvbHMgZXh0cmV1cmUgbGEgZGF0YSBxdWUgbWFyY2EgZWwgcHJpbmNpcGkgZCd1biBjYW52aSBvIGVsIHNldSBmaW5hbCBhbWIgZWwgcGFyw6BtZXRyZSA8c3Ryb25nPkRhdGEgZGVsIHNlZ21lbnQ8L3N0cm9uZz4uIFBlciBleGVtcGxlLCBwZXIgZW50ZW5kcmUgY29tIHZhIGNvbWVuw6dhciBlbCBjYW52aSBtw6lzIHJlY2VudCBkJ3VuYSBzw6hyaWUgdGVtcG9yYWwsIGRlZmluaXUgPHN0cm9uZz5UaXB1cyBkZSBjYW52aTwvc3Ryb25nPiBjb20gYSA8c3Ryb25nPkhvcmEgZGUgbCfDumx0aW0gY2Fudmk8L3N0cm9uZz4gaSA8c3Ryb25nPkRhdGEgZGVsIHNlZ21lbnQ8L3N0cm9uZz4gY29tIGEgPHN0cm9uZz5JbmljaSBkZWwgc2VnbWVudDwvc3Ryb25nPi48L2Rpdj48YnI+PGRpdj5GZXUgc2VydmlyIGVscyBwYXLDoG1ldHJlcyBkZSBmaWx0cmF0Z2Ugc2Vnw7xlbnRzIHBlciBleHRyZXVyZSBkYXRlcyBkZSBjYW52aSBtw6lzIGNvbmNyZXRlcyBkZWwgcsOgc3RlciBkJ2Fuw6BsaXNpIGRlIGNhbnZpczo8L2Rpdj48dWw+PGxpPjxzdHJvbmc+RmlsdHJhIHBlciBsJ2FueTwvc3Ryb25nPjogaWRlbnRpZmlxdWV1IGNhbnZpcyBxdWUgcydoYW4gcHJvZHXDr3QgZW4gdW4gcGVyw61vZGUgZGUgdGVtcHMgY29uY3JldCwgcGVyIGV4ZW1wbGUgc2kgY2VycXVldSBjYW52aXMgcXVlIHMnaGFuIHByb2R1w690IGVuIHVuIHBhaXNhdGdlIGR1cmFudCBjaW5jIGFueXMgZGUgc2VxdWVyYS48L2xpPjxsaT48c3Ryb25nPkZpbHRyYSBwZXIgbGEgZHVyYWRhPC9zdHJvbmc+OiBpZGVudGlmaXF1ZXUgZWxzIGNhbnZpcyBxdWUgcydoYW4gcHJvZHXDr3QgZHVyYW50IHVuIGludGVydmFsIGQnYW55cyBlc3BlY2lmaWNhdCwgcGVyIGV4ZW1wbGUgc2kgbm9tw6lzIGNlcnF1ZXUgZWxzIGNhbnZpcyBhYnJ1cHRlcyBxdWUgaGFuIHRpbmd1dCBsbG9jIGR1cmFudCAxIG8gMiBhbnlzLiBQb2RldSBjYWxjdWxhciBsYSBkdXJhZGEgcXVlIHVzIGludGVyZXNzaSBhbWIgbGEgZsOzcm11bGEgPHN0cm9uZz5hbnkgZGUgZmluYWxpdHphY2nDsyAtIGFueSBkJ2luaWNpICsgMTwvc3Ryb25nPi4gUydpbmNsb3VyYW4gbGVzIHNlcGFyYWNpb25zIGVuIGxlcyBzw6hyaWVzIHRlbXBvcmFscy48L2xpPjxsaT48c3Ryb25nPkZpbHRyYSBwZXIgbGEgbWFnbml0dWQ8L3N0cm9uZz46IGlkZW50aWZpcXVldSBlbHMgY2FudmlzIGQndW5hIG1hZ25pdHVkIGVzcGVjaWZpY2FkYSwgcGVyIGV4ZW1wbGUgc2kgbm9tw6lzIGNlcnF1ZXUgZ3JhbnMgY2FudmlzIGVuIGwnw61uZGV4IGRlIHZlZ2V0YWNpw7MgTkRWSS4gTGEgbWFnbml0dWQgw6lzIHVuIHZhbG9yIGFic29sdXQsIGRlIG1hbmVyYSBxdWUgZWxzIHZhbG9ycyBtw61uaW1zIGkgbcOgeGltcyBubyBwb2RlbiBzZXIgbmVnYXRpdXMuIFBlciBlc3BlY2lmaWNhciB1biBjYW52aSBkaXJlY2Npb25hbCwgZmV1IHNlcnZpciBlbCBwYXLDoG1ldHJlIDxzdHJvbmc+RGlyZWNjacOzIGRlbCBjYW52aTwvc3Ryb25nPi48L2xpPjwvdWw+XCIsXG5cdFx0ZGlzdGFuY2VBY2N1bXVsYXRpb25OYW1lOiBcIkFjdW11bGFjacOzIGRlIGRpc3TDoG5jaWFcIixcblx0XHRkaXN0YW5jZUFjY3VtdWxhdGlvblNuaXA6IFwiQ2FsY3VsYSBsYSBkaXN0w6BuY2lhIGFjdW11bGFkYSBwZXIgYSBjYWRhIGNlbMK3bGEgYWxzIG9yw61nZW5zLCB0ZW5pbnQgZW4gY29tcHRlIGxhIGRpc3TDoG5jaWEgZW4gbMOtbmlhIHJlY3RhLCBlbCBjb3N0IGVuIHBsYSwgbGEgZGlzdMOgbmNpYSBkZSBzdXBlcmbDrWNpZSByZWFsIGkgZWxzIGZhY3RvcnMgZGUgY29zdCBob3JpdHpvbnRhbCBpIHZlcnRpY2FsLlwiLFxuXHRcdGRpc3RhbmNlQWNjdW11bGF0aW9uRGVzYzogXCJMYSBmdW5jacOzIEFjdW11bGFjacOzIGRlIGRpc3TDoG5jaWEgY2FsY3VsYSBsYSBkaXN0w6BuY2lhIGRlIGNhZGEgdWJpY2FjacOzIGRlIGwnw6ByZWEgZCdlc3R1ZGkgYSBsJ29yaWdlbiBtw6lzIHByb3BlciBvIGRlIG1lbm9yIGNvc3QuIFNpIGEgbCdlbnRyYWRhIG5vbcOpcyBlcyBwcm9wb3JjaW9uZW4gZWxzIG9yw61nZW5zLCBlcyBjYWxjdWxhIHVuYSBkaXN0w6BuY2lhIGVuIGzDrW5pYSByZWN0YSBhIGNhZGEgdWJpY2FjacOzIGRlIGwnw6ByZWEgZCdlc3R1ZGkuIFNpIGNvbSBhIGVudHJhZGEgcyd1dGlsaXR6ZW4gdGFudCBvcsOtZ2VucyBjb20gYmFycmVyZXMsIGxhIGZ1bmNpw7MgQWN1bXVsYWNpw7MgZGUgZGlzdMOgbmNpYSBjYWxjdWxhIGxhIGRpc3TDoG5jaWEgZW4gbMOtbmlhIHJlY3RhIGFsIHZvbHRhbnQgZGUgbGVzIGJhcnJlcmVzLiBUYW50IHBlciBhbCByw6BzdGVyIGQnb3JpZ2VuIGNvbSBwZXIgYWwgcsOgc3RlciBkZSBiYXJyZXJhLCBlbCB2YWxvciBkZSBmb25zIGhhIGRlIHNlciBOb0RhdGEsIG1lbnRyZSBxdWUgZWxzIG9yw61nZW5zIGkgbGVzIGJhcnJlcmVzIGVzIHJlcHJlc2VudGVuIGFtYiB2YWxvcnMgZGUgY2VswrdsYSB2w6BsaWRzLiBFbHMgdmFsb3JzIHbDoGxpZHMgaW5jbG91ZW4gZWwgemVyby4gPGRpdj48YnIvPlF1YW4gZXMgcHJvcG9yY2lvbmEgdW4gcsOgc3RlciBkZSBzdXBlcmbDrWNpZSBjb20gYSBlbnRyYWRhLCBlcyBjYWxjdWxhIGxhIGRpc3TDoG5jaWEgZGUgc3VwZXJmw61jaWUgcmVhbCBlbnRyZSBsZXMgY2VswrdsZXMuIFBlciBmZXIgdW5hIGFuw6BsaXNpIGRlIGNvc3RvcyBhbWIgbGEgZnVuY2nDsyBBY3VtdWxhY2nDsyBkZSBkaXN0w6BuY2lhLCBlcyBuZWNlc3NpdGEgdW5hIHN1cGVyZsOtY2llIGRlIGNvc3QuIFNpIGVzIHByb3BvcmNpb25hIHVuYSBzdXBlcmbDrWNpZSBkZSBjb3N0LCBlbCByZXN1bHRhdCDDqXMgdW4gcsOgc3RlciBkZSBjb3N0IGVuIHBsYSBhY3VtdWxhdC4gUXVhbiBlcyBwcm9wb3JjaW9uZW4gZmFjdG9ycyBob3JpdHpvbnRhbHMgaSB2ZXJ0aWNhbHMsIHMnYWN1bXVsYSBsYSBkaXJlY2Npb25hbGl0YXQgY29uc2lkZXJhZGEgY29tIGEgY29zdC4gRXMgcG9kZW4gdXRpbGl0emFyIHF1YXRyZSBjYXJhY3RlcsOtc3RpcXVlcyBkJ29yaWdlbi4gQXF1ZXN0ZXMgY2FyYWN0ZXLDrXN0aXF1ZXMsIHF1ZSBwb2RlbiBzZXIgZGUgbCdvcmlnZW4gbyBkZWxzIGVsZW1lbnQgZW4gbW92aW1lbnQgZGUgbCdvcmlnZW4sIGVzIGNvbnRyb2xlbiBhbWIgcGFyw6BtZXRyZXMgY29uY3JldHM6IDEuIEFjdW11bGFjacOzIGluaWNpYWw64oCvZGVmaW5laXggZWwgY29zdCBpbmljaWFsIGFiYW5zIHF1ZSBjb21lbmNpIGVsIG1vdmltZW50LiAyLiBBY3VtdWxhY2nDsyBtw6B4aW1hOuKAr2VzcGVjaWZpY2EgcXVpbiBjb3N0IHBvdCBhY3VtdWxhciB1biBvcmlnZW4gYWJhbnMgZCdhcnJpYmFyIGFsIGzDrW1pdC4gMy4gTXVsdGlwbGljYWRvciBwZXIgYXBsaWNhciBhbHMgY29zdG9zOuKAr2VzcGVjaWZpY2EgZWwgbW9kZSBkZSB2aWF0Z2UgbyBsYSBtYWduaXR1ZCBhIGwnb3JpZ2VuLiA0LiBEaXJlY2Npw7MgZGVsIGRlc3BsYcOnYW1lbnQ64oCvaWRlbnRpZmljYSBzaSBsJ2VsZW1lbnQgZW4gbW92aW1lbnQgY29tZW7Dp2EgYSBsJ29yaWdlbiBpIGVzIG1vdSBhIHViaWNhY2lvbnMgcXVlIG5vIHPDs24gbGVzIGQnb3JpZ2VuLCBvIGLDqSBzaSBjb21lbsOnYSBlbiB1YmljYWNpb25zIHF1ZSBubyBzw7NuIGxlcyBkJ29yaWdlbiBpIHRvcm5hIGEgbCdvcmlnZW4uPGRpdj48YnIvPlBlciBkZWZlY3RlLCBlbCByZXN1bHRhdCBkZSBsJ0FjdW11bGFjacOzIGRlIGRpc3TDoG5jaWEgw6lzIHVuYSBiYW5kYSwgcXVlIMOpcyBlbCByw6BzdGVyIGQnYWN1bXVsYWNpw7MgZGUgZGlzdMOgbmNpYS4gVGFubWF0ZWl4LCB0YW1iw6kgZXMgcG90IGNyZWFyIHVuYSBzZWdvbmEgYmFuZGE6IGxhIGJhbmRhIGRlIGRpcmVjY2nDsyBpbnZlcnNhLiBBcXVlc3RhIGJhbmRhIGluZGljYSBjYXAgYSBxdWluYSBkaXJlY2Npw7MgcydoYSBkJ2FuYXIgZGVzIGRlIGNhZGEgdWJpY2FjacOzIGRlIGwnw6ByZWEgZCdlc3R1ZGkgcGVyIG9idGVuaXIgbCdvcmlnZW4gZGUgbWVub3IgY29zdC4gVG90ZXMgZHVlcyBiYW5kZXMgZXMgbmVjZXNzaXRlbiBwZXIgZGV0ZXJtaW5hciBydXRlcyDDsnB0aW1lcyBhIGwnw6ByZWEgZCdlc3R1ZGkuIFBlciBnZW5lcmFyIHVuYSBydXRhLCBwcmltZXIgZmV1IHNlcnZpciBsYSBmdW5jacOzIEV4dHJldSBsZXMgYmFuZGVzIHBlciBleHRyZXVyZSBlbCByw6BzdGVyIGQnYWN1bXVsYWNpw7MgZGUgZGlzdMOgbmNpYSBpIGVsIHLDoHN0ZXIgZGUgZGlyZWNjacOzIGludmVyc2EuIFV0aWxpdHpldSBhcXVlc3RlcyBjYXBlcyBjb20gYSBlbnRyYWRhIGRlIGxhIGZ1bmNpw7MgUnV0YSBkZSBjb3N0LiBFbiBhcXVlc3RhIGZ1bmNpw7MsIHV0aWxpdHpldSBlbCByw6BzdGVyIGQnYWN1bXVsYWNpw7MgZGUgZGlzdMOgbmNpYSBjb20gYSBlbnRyYWRhIGRlbCByw6BzdGVyIGRlIGNvc3QgZW4gcGxhLCBpIGVsIHLDoHN0ZXIgZGUgZGlyZWNjacOzIGludmVyc2EgY29tIGEgZW50cmFkYSBkZSByw6BzdGVyIGQnZW5sbGHDpyBkZSBtZW5vciBjb3N0LjwvZGl2PlwiLFxuXHRcdGRpc3RhbmNlQWxsb2NhdGlvbk5hbWU6IFwiQXNzaWduYWNpw7MgZGUgZGlzdMOgbmNpYVwiLFxuXHRcdGRpc3RhbmNlQWxsb2NhdGlvblNuaXA6IFwiQ2FsY3VsYSBsJ2Fzc2lnbmFjacOzIGRlIGRpc3TDoG5jaWEgcGVyIGEgY2FkYSBjZWzCt2xhIGFscyBvcsOtZ2VucyBwcm9wb3JjaW9uYXRzLCBlbiBmdW5jacOzIGRlIGxhIGRpc3TDoG5jaWEgZW4gbMOtbmlhIHJlY3RhLCBlbCBjb3N0IGVuIHBsYSwgbGEgZGlzdMOgbmNpYSBkZSBzdXBlcmbDrWNpZSByZWFsIGkgZWxzIGZhY3RvcnMgZGUgY29zdCBob3JpdHpvbnRhbCBpIHZlcnRpY2FsLlwiLFxuXHRcdGRpc3RhbmNlQWxsb2NhdGlvbkRlc2M6IFwiTGEgZnVuY2nDsyBBc3NpZ25hY2nDsyBkZSBkaXN0w6BuY2lhIGNhbGN1bGEgYSBxdWluIG9yaWdlbiBlc3TDoCBhc3NpZ25hZGEgY2FkYSB1YmljYWNpw7MgZGUgbCfDoHJlYSBkJ2VzdHVkaS4gU2kgcGVyIGEgbCdlbnRyYWRhIG5vbcOpcyBlcyBwcm9wb3JjaW9uZW4gb3LDrWdlbnMsIGxlcyB1YmljYWNpb25zIHMnYXNzaWduZW4gbWl0amFuw6dhbnQgdW5hIGRpc3TDoG5jaWEgZW4gbMOtbmlhIHJlY3RhIGEgbCdvcmlnZW4gbcOpcyBwcm9wZXIuIFNpIGNvbSBhIGVudHJhZGEgcyd1dGlsaXR6ZW4gdGFudCBvcsOtZ2VucyBjb20gYmFycmVyZXMsIGxhIGZ1bmNpw7MgQXNzaWduYWNpw7MgZGUgZGlzdMOgbmNpYSBjYWxjdWxhIGxhIGRpc3TDoG5jaWEgZW4gbMOtbmlhIHJlY3RhIGFsIHZvbHRhbnQgZGUgbGVzIGJhcnJlcmVzIHBlciBkZXRlcm1pbmFyIGEgcXVpbiBvcmlnZW4gcydhc3NpZ25hIHVuYSB1YmljYWNpw7MuIFRhbnQgcGVyIGFsIHLDoHN0ZXIgZCdvcmlnZW4gY29tIHBlciBhbCByw6BzdGVyIGRlIGJhcnJlcmEsIGVsIHZhbG9yIGRlIGZvbnMgaGEgZGUgc2VyIE5vRGF0YSwgbWVudHJlIHF1ZSBlbHMgb3LDrWdlbnMgaSBsZXMgYmFycmVyZXMgZXMgcmVwcmVzZW50ZW4gYW1iIHZhbG9ycyBkZSBjZWzCt2xhIHbDoGxpZHMuIEVscyB2YWxvcnMgdsOgbGlkcyBpbmNsb3VlbiBlbCB6ZXJvLjxkaXY+PGJyLz5QZXIgZmVyIHVuYSBhbsOgbGlzaSBkZSBjb3N0b3MgYW1iIGxhIGZ1bmNpw7MgQXNzaWduYWNpw7MgZGUgZGlzdMOgbmNpYSwgZXMgbmVjZXNzaXRhIHVuYSBzdXBlcmbDrWNpZSBkZSBjb3N0LiBTaSBlcyBwcm9wb3JjaW9uYSB1bmEgc3VwZXJmw61jaWUgZGUgY29zdCwgZWwgcmVzdWx0YXQgw6lzIHVuIHLDoHN0ZXIgZCdhc3NpZ25hY2nDsyBiYXNhdCBlbiBlbCBjb3N0IGFjdW11bGF0aXUsIG5vIGVuIGxhIGRpc3TDoG5jaWEgZW4gbMOtbmlhIHJlY3RhLiBRdWFuIGVzIHByb3BvcmNpb25lbiBmYWN0b3JzIGhvcml0em9udGFscyBpIHZlcnRpY2FscywgcydhY3VtdWxhIGxhIGRpcmVjY2lvbmFsaXRhdCBjb25zaWRlcmFkYSBjb20gYSBjb3N0LiBRdWFuIGVzIHByb3BvcmNpb25hIHVuIHLDoHN0ZXIgZGUgc3VwZXJmw61jaWUgY29tIGEgZW50cmFkYSwgZXMgY2FsY3VsYSBsYSBkaXN0w6BuY2lhIGRlIHN1cGVyZsOtY2llIHJlYWwgY29iZXJ0YSBlbiBwYXNzYXIgZW50cmUgbGVzIGNlbMK3bGVzIHF1YW4gZXMgZGV0ZXJtaW5hIGwnYXNzaWduYWNpw7MuIEVzIHBvZGVuIHV0aWxpdHphciBxdWF0cmUgY2FyYWN0ZXLDrXN0aXF1ZXMgZCdvcmlnZW4uIEFxdWVzdGVzIGNhcmFjdGVyw61zdGlxdWVzLCBxdWUgcG9kZW4gc2VyIGRlIGwnb3JpZ2VuIG8gZGVscyBlbGVtZW50IGVuIG1vdmltZW50IGRlIGwnb3JpZ2VuLCBlcyBjb250cm9sZW4gYW1iIHBhcsOgbWV0cmVzIGNvbmNyZXRzOiAxLiBBY3VtdWxhY2nDsyBpbmljaWFsOuKAr2RlZmluZWl4IGVsIGNvc3QgaW5pY2lhbCBhYmFucyBxdWUgY29tZW5jaSBlbCBtb3ZpbWVudC4gMi4gQWN1bXVsYWNpw7MgbcOgeGltYTrigK9lc3BlY2lmaWNhIHF1aW4gY29zdCBwb3QgYWN1bXVsYXIgdW4gb3JpZ2VuIGFiYW5zIGQnYXJyaWJhciBhbCBsw61taXQuIDMuIE11bHRpcGxpY2Fkb3IgcGVyIGFwbGljYXIgYWxzIGNvc3RvczrigK9lc3BlY2lmaWNhIGVsIG1vZGUgZGUgdmlhdGdlIG8gbGEgbWFnbml0dWQgYSBsJ29yaWdlbi4gNC4gRGlyZWNjacOzIGRlbCBkZXNwbGHDp2FtZW50OuKAr2lkZW50aWZpY2Egc2kgbCdlbGVtZW50IGVuIG1vdmltZW50IGNvbWVuw6dhIGEgbCdvcmlnZW4gaSBlcyBtb3UgYSB1YmljYWNpb25zIHF1ZSBubyBzw7NuIGxlcyBkJ29yaWdlbiwgbyBiw6kgc2kgY29tZW7Dp2EgZW4gdWJpY2FjaW9ucyBxdWUgbm8gc8OzbiBsZXMgZCdvcmlnZW4gaSB0b3JuYSBhIGwnb3JpZ2VuLjxkaXY+PGJyLz5QZXIgZGVmZWN0ZSwgZWwgcmVzdWx0YXQgZGUgbCdBc3NpZ25hY2nDsyBkZSBkaXN0w6BuY2lhIMOpcyB1bmEgYmFuZGEsIHF1ZSDDqXMgZWwgcsOgc3RlciBkJ2Fzc2lnbmFjacOzIGRlIGRpc3TDoG5jaWEuIFNpIGVzIG1hcmNhIGwnb3BjacOzIGJvb2xlYW5hIEdlbmVyYSB1bmEgZmlsYSBpIHVuYSBjb2x1bW5hIGQnb3JpZ2VuIGNvbSBhIGJhbmRlcyBhZGRpY2lvbmFscyBhIGxhIHNvcnRpZGEsIGVsIHJlc3VsdGF0IHNlcsOgIHVuIHLDoHN0ZXIgbXVsdGliYW5kYSBkZSB0cmVzIGJhbmRlcy4gTGEgcHJpbWVyYSBiYW5kYSDDqXMgZWwgcsOgc3RlciBkJ2Fzc2lnbmFjacOzIGRlIGRpc3TDoG5jaWEsIGxhIHNlZ29uYSBiYW5kYSBjb250w6kgdW4gw61uZGV4IGRlIGZpbGVzIGkgbGEgdGVyY2VyYSBiYW5kYSBjb250w6kgdW4gw61uZGV4IGRlIGNvbHVtbmVzLiBBcXVlc3RzIMOtbmRleCBpZGVudGlmaXF1ZW4gbGEgdWJpY2FjacOzIGRlIGxhIGNlbMK3bGEgZCdvcmlnZW4gYW1iIGxhIG1lbm9yIGRpc3TDoG5jaWEgZGUgY29zdCBhY3VtdWxhdC4gTCfDrW5kZXggZGUgZmlsYSBkJ29yaWdlbiBpIGwnw61uZGV4IGRlIGNvbHVtbmEgZCdvcmlnZW4gZXMgcG9kZW4gdXRpbGl0emFyIGNvbmp1bnRhbWVudCBwZXIgcmVwcmVzZW50YXIgY2FydG9ncsOgZmljYW1lbnQgbGEgaW50ZW5zaXRhdC4gU2kgY29uc3VsdGV1IHF1YWxzZXZvbCB1YmljYWNpw7MgZGUgbCfDoHJlYSBkJ2VzdHVkaSBhIGxlcyBiYW5kZXMgZG9zIGkgdHJlcywgc2FicmV1IGxhIGZpbGEgaSBsYSBjb2x1bW5hIGRlIGwnb3JpZ2VuIGRlIG1lbm9yIGNvc3QgcGVyIGEgbGEgdWJpY2FjacOzLjwvZGl2PlwiLFxuXHRcdGV1Y0JhY2tEaXJlY3Rpb25OYW1lOiBcIkRpcmVjY2nDsyBpbnZlcnNhIGV1Y2xpZGlhbmFcIixcblx0XHRldWNCYWNrRGlyZWN0aW9uU25pcDogXCJDYWxjdWxhIHBlciBhIGNhZGEgY2VswrdsYSBsYSBkaXJlY2Npw7MgZW4gZ3JhdXMgYSBsYSBjZWzCt2xhIHZlw69uYSwgYSBtw6lzIGRlIGxhIHJ1dGEgbcOpcyBjdXJ0YSBkZSB0b3JuYWRhIGEgbCdvcmlnZW4gbcOpcyBwcm9wZXIsIGEgbGEgdmVnYWRhIHF1ZSBldml0YSBsZXMgYmFycmVyZXMuXCIsXG5cdFx0ZXVjQmFja0RpcmVjdGlvbkRlc2M6IFwiTGEgZnVuY2nDsyBEaXJlY2Npw7MgaW52ZXJzYSBldWNsaWRpYW5hIHTDqSBjb20gYSByZXN1bHRhdCB1biByw6BzdGVyIGRlIHB1bnQgZmxvdGFudCBjb250aW51IHF1ZSByZXByZXNlbnRhIGxhIGRpcmVjY2nDsyBlbiBncmF1cyBkZSB0b3JuYWRhIGEgbCdvcmlnZW4gbcOpcyBwcm9wZXIsIGEgbGEgdmVnYWRhIHF1ZSBldml0YSBsZXMgYmFycmVyZXMsIHNpIHNlIG4naGFuIHByb3BvcmNpb25hdC48ZGl2Pjxici8+TGVzIGVudHJhZGVzIGRlIGxhIGZ1bmNpw7MgRGlyZWNjacOzIGludmVyc2EgZXVjbGlkaWFuYSBzw7NuIGwnb3JpZ2VuIGNhcCBhbCBxdWFsIGVzIGNhbGN1bGFyw6AgbGEgZGlyZWNjacOzLiBDb20gYSBlbnRyYWRhIG9wY2lvbmFsLCBlcyBwb3QgcHJvcG9yY2lvbmFyIHVuIHLDoHN0ZXIgcXVlIHJlcHJlc2VudGkgbGVzIGJhcnJlcmVzIGRlIGwnw6ByZWEgZCdlc3R1ZGkuIFRhbnQgcGVyIGFsIHLDoHN0ZXIgZCdvcmlnZW4gY29tIHBlciBhbCByw6BzdGVyIGRlIGJhcnJlcmEsIGVsIHZhbG9yIGRlIGZvbnMgaGEgZGUgc2VyIE5vRGF0YSwgbWVudHJlIHF1ZSBlbHMgb3LDrWdlbnMgaSBsZXMgYmFycmVyZXMgZXMgcmVwcmVzZW50ZW4gYW1iIHZhbG9ycyB2w6BsaWRzLiBFbHMgdmFsb3JzIHbDoGxpZHMgaW5jbG91ZW4gZWwgemVyby4gUGVyIGRlZmVjdGUsIGVsIGPDoGxjdWwgcHJvY2Vzc2Fyw6AgbCdleHRlbnNpw7MgY29tYmluYWRhIGQnb3LDrWdlbnMgaSBiYXJyZXJlcywgYSBtw6lzIGRlIGR1ZXMgZmlsZXMgaSBjb2x1bW5lcy4gU2kgbCdhbsOgbGlzaSBub23DqXMgZXMgbmVjZXNzaXRhIGVuIHVuYSBkaXN0w6BuY2lhIGVzcGVjaWZpY2FkYSBkZWxzIG9yw61nZW5zLCBlcyBwb3QgdXRpbGl0emFyIGVsIHBhcsOgbWV0cmUgRGlzdMOgbmNpYSBtw6B4aW1hLiBMYSBmdW5jacOzIERpcmVjY2nDsyBpbnZlcnNhIGV1Y2xpZGlhbmEgYWRtZXQgdGFudCBlbCBtw6h0b2RlIFBsYSBjb20gZWwgbcOodG9kZSBHZW9kw6hzaWMgYWwgY8OgbGN1bC4gRWwgbcOodG9kZSBkZSBjw6BsY3VsIFBsYSBlcyByZWFsaXR6YXLDoCBlbiB1biB0ZXJyZW55IHBsYSBwcm9qZWN0YXQgbWl0amFuw6dhbnQgdW4gc2lzdGVtYSBkZSBjb29yZGVuYWRlcyBjYXJ0ZXNpYW5lcyAyRC4gRWwgbcOodG9kZSBkZSBjw6BsY3VsIEdlb2TDqHNpYyBlcyByZWFsaXR6YXLDoCBlbiB1biBlbMK3bGlwc29pZGUsIMOpcyBhIGRpciwgcXVlIGluZGVwZW5kZW50bWVudCBkZSBsYSBwcm9qZWNjacOzIGQnZW50cmFkYSBpIGRlIHNvcnRpZGEsIGVscyByZXN1bHRhdHMgbm8gY2FudmlhcmFuLjxkaXY+PGJyLz5FbCByZXN1bHRhdCBkZSBsYSBmdW5jacOzIERpcmVjY2nDsyBpbnZlcnNhIGV1Y2xpZGlhbmEgZXMgcG90IHV0aWxpdHphciBqdW50YW1lbnQgYW1iIGVsIHJlc3VsdGF0IGRlIGxhIGZ1bmNpw7MgRGlzdMOgbmNpYSBldWNsaWRpYW5hIHBlciBkZXRlcm1pbmFyIGxlcyBydXRlcyBtw6lzIGN1cnRlcyBkZXMgZGUgbGVzIHViaWNhY2lvbnMgZGUgbCfDoHJlYSBkJ2VzdHVkaSBmaW5zIGEgbCdvcmlnZW4uIFRhbnQgZWwgcmVzdWx0YXQgZGUgbGEgZnVuY2nDsyBEaXJlY2Npw7MgaW52ZXJzYSBldWNsaWRpYW5hIGNvbSBlbCByZXN1bHRhdCBkZSBsYSBEaXN0w6BuY2lhIGV1Y2xpZGlhbmEgcyd1dGlsaXR6ZW4gYSBsYSBmdW5jacOzIFJ1dGEgZGUgY29zdCBqdW50YW1lbnQgYW1iIGxlcyBkZXN0aW5hY2lvbnMgcGVyIGdlbmVyYXIgbGVzIHJ1dGVzIG3DqXMgY3VydGVzLjwvZGl2PlwiLFxuXHRcdGV4cGFuZE5hbWU6IFwiRXhwYW5kZWl4XCIsXG5cdFx0ZXhwYW5kU25pcDogXCJFeHBhbmRlaXggbGVzIHpvbmVzIHNlbGVjY2lvbmFkZXMgZCd1biByw6BzdGVyIGVuIHVuIG5vbWJyZSBlc3BlY2lmaWNhdCBkZSBjZWzCt2xlcy5cIixcblx0XHRleHBhbmREZXNjOiBcIkFtYiBsYSBmdW5jacOzIGdsb2JhbCBFeHBhbmRlaXgsIHBvZGV1IGdlbmVyYWxpdHphciBvIHNpbXBsaWZpY2FyIHLDoHN0ZXJzIGZlbnQgcXVlIHpvbmVzIGNvbmNyZXRlcyBzaWd1aW4gbcOpcyBncmFucy4gVGFtYsOpIHBvZGV1IGNvbnRyb2xhciBsYSBxdWFudGl0YXQgZGUgZ2VuZXJhbGl0emFjacOzIHF1ZSBlcyBwcm9kdWlyw6AuPGRpdj48YnIvPkxlcyB6b25lcyBxdWUgc2VsZWNjaW9uZXUgYXVnbWVudGFyYW4gZGUgbWlkYSBleHBhbmRpbnQtc2UgYSBhbHRyZXMgem9uZXMuIENvbmNlcHR1YWxtZW50LCBlbHMgdmFsb3JzIGRlIHpvbmEgc2VsZWNjaW9uYXRzIGVzIHBvZGVuIHZldXJlIGNvbSBhIHpvbmVzIGVuIHByaW1lciBwbGEsIG1lbnRyZSBxdWUgZWxzIGFsdHJlcyB2YWxvcnMgY29udGludWFyYW4gc2VudCB6b25lcyBkZSBmb25zLiBMZXMgem9uZXMgZW4gcHJpbWVyIHBsYSBlcyBwb2RlbiBleHBhbmRpciBhIGxlcyB6b25lcyBkZSBmb25zLjxkaXY+PGJyLz5MYSBxdWFudGl0YXQgZGUgZ2VuZXJhbGl0emFjacOzIGVzIHBvdCBjb250cm9sYXIgYW1iIGVsIHBhcsOgbWV0cmUgTm9tYnJlIGRlIGNlbMK3bGVzLiBQZXIgZGVmZWN0ZSwgZWwgdmFsb3Igw6lzIDEsIGNvc2EgcXVlIHZvbCBkaXIgcXVlIGxlcyB6b25lcyBzZWxlY2Npb25hZGVzIHMnZXhwYW5kaXJhbiBsYSBxdWFudGl0YXQgY29ycmVzcG9uZW50IGEgbGEgbWlkYSBkJ3VuYSBjZWzCt2xhLiBQZXIgaW5jcmVtZW50YXIgZWwgZ3JhdSBkZSBnZW5lcmFsaXR6YWNpw7MsIHBvZGV1IGVzcGVjaWZpY2FyIHVuIHZhbG9yIG3DqXMgZ3JhbiBwZXIgYSBhcXVlc3QgcGFyw6BtZXRyZS4gQ29uY2VwdHVhbG1lbnQsIMOpcyBjb20gZXhlY3V0YXIgbCdlaW5hIGxlcyBtYXRlaXhlcyB2ZWdhZGVzIHF1ZSBlbCBub21icmUgZXNwZWNpZmljYXQsIHV0aWxpdHphbnQgZWxzIHZhbG9ycyBkZSBsJ2V4ZWN1Y2nDsyBhbnRlcmlvciBjb20gYSBlbnRyYWRhIGEgbGEgaXRlcmFjacOzIHBvc3Rlcmlvci48L2Rpdj5cIixcblx0XHR0cmVuZEFuYWx5c2lzTmFtZTogXCJHZW5lcmEgbGEgdGVuZMOobmNpYVwiLFxuXHRcdHRyZW5kQW5hbHlzaXNTbmlwOiBcIkVzdGltYSBsYSB0ZW5kw6huY2lhIGRlIGNhZGEgcMOteGVsIGVuIHVuYSBkaW1lbnNpw7MgcGVyIGEgdW5hIG8gZGl2ZXJzZXMgdmFyaWFibGVzIGQndW4gcsOgc3RlciBtdWx0aWRpbWVuc2lvbmFsLlwiLFxuXHRcdHRyZW5kQW5hbHlzaXNEZXNjOiBcIjxkaXY+QXF1ZXN0YSBmdW5jacOzIGVzIHBvdCBmZXIgc2VydmlyIHBlciBhanVzdGFyIGxlcyBkYWRlcyBhbCBsbGFyZyBkJ3VuYSBsw61uaWEgZGUgdGVuZMOobmNpYSBsaW5lYWwsIGhhcm3Dsm5pY2EgbyBwb2xpbsOybWljYSwgbyBiw6kgcGVyIGRldGVjdGFyIGxhIHRlbmTDqG5jaWEgYW1iIGxhIHByb3ZhIGRlIE1hbm4tS2VuZGFsbCBvIGVzdGFjaW9uYWwgZGUgS2VuZGFsbC48L2Rpdj48YnI+PGRpdj5FbCByw6BzdGVyIGRlIHRlbmTDqG5jaWEgZGUgc29ydGlkYSBnZW5lcmF0IGFtYiBhcXVlc3RhIGZ1bmNpw7Mgcyd1dGlsaXR6YSBjb20gYSBlbnRyYWRhIGRlIGxhIGZ1bmNpw7MgPHN0cm9uZz5QcmVkaXUgbWl0amFuw6dhbnQgbGEgdGVuZMOobmNpYTwvc3Ryb25nPi48L2Rpdj48YnI+PGRpdj5MZXMgcHJvdmVzIGRlIE1hbm4tS2VuZGFsbCBpIGVzdGFjaW9uYWwgZGUgS2VuZGFsbCBlcyBmYW4gc2VydmlyIHBlciBkZXRlcm1pbmFyIHNpIGhpIGhhIHVuYSB0ZW5kw6huY2lhIG1vbsOydG9uYSBhIGxlcyBkYWRlcy4gTm8gc8OzbiBwYXJhbcOodHJpcXVlcywgY29zYSBxdWUgc2lnbmlmaWNhIHF1ZSBubyBkb25lbiBwZXIgZmV0IHVuYSBkaXN0cmlidWNpw7MgY29uY3JldGEgZGUgbGVzIGRhZGVzLiBMYSBwcm92YSBkZSBNYW5uLUtlbmRhbGwgbm8gY29uc2lkZXJhIHVuYSBjb3JyZWxhY2nDsyBkZSBzw6hyaWUgbmkgZWZlY3RlcyBlc3RhY2lvbmFscy4gU2kgbGVzIGRhZGVzIHPDs24gZXN0YWNpb25hbHMsIGxhIHByb3ZhIGVzdGFjaW9uYWwgZGUgS2VuZGFsbCDDqXMgbcOpcyBhZGllbnQuPC9kaXY+PGJyPjxkaXY+U2kgbCdlaW5hIGVzIGZhIHNlcnZpciBwZXIgZHVyIGEgdGVybWUgdW5hIHByb3ZhIGRlIE1hbm4tS2VuZGFsbCBvIHVuYSBwcm92YSBlc3RhY2lvbmFsIGRlIEtlbmRhbGwsIGxhIHNvcnRpZGEgw6lzIHVuIHLDoHN0ZXIgZGUgY2luYyBiYW5kZXMsIHRhbCBjb20gcydpbmRpY2EgYSBjb250aW51YWNpw7M6PC9kaXY+PHVsPjxsaT5CYW5kYSAxID0gcGVuZGVudCBkZSBTZW48L2xpPjxsaT5CYW5kYSAyID0gdmFsb3IgcDwvbGk+PGxpPkJhbmRhIDMgPSBwdW50dWFjacOzIGRlIE1hbm4tS2VuZGFsbCAoUyk8L2xpPjxsaT5CYW5kYSA0ID0gdmFyacOgbmNpYSBTPC9saT48bGk+QmFuZGEgNCA9IHZhcmnDoG5jaWEgUzwvbGk+PGxpPkJhbmRhIDUgPSBwdW50dWFjacOzIFo8L2xpPjwvdWw+PGRpdj5TaSBsZXMgc29ydGlkZXMgZGUgbGEgcHJvdmEgZGUgTWFubi1LZW5kYWxsIG8gS2VuZGFsbCBlc3RhY2lvbmFsIGVzIHBvZGVuIGZlciBzZXJ2aXIgcGVyIGRldGVybWluYXIgcXVpbnMgcMOteGVscyBkZSBsYSBzw6hyaWUgdGVtcG9yYWwgbXVsdGlkaW1lbnNpb25hbCB0ZW5lbiB1bmEgdGVuZMOobmNpYSBlc3RhZMOtc3RpY2FtZW50IHNpZ25pZmljYXRpdmEuIFBvZGV1IGZlciBzZXJ2aXIgYXF1ZXN0YSBpbmZvcm1hY2nDsyBqdW50YW1lbnQgYW1iIGwnYW7DoGxpc2kgZGUgdGVuZMOobmNpYSBsaW5lYWwsIGhhcm3Dsm5pY2EgbyBwb2xpbsOybWljYSBwZXIgZXh0cmV1cmUgdGVuZMOobmNpZXMgc2lnbmlmaWNhdGl2ZXMgZGUgbGEgc8OocmllIHRlbXBvcmFsLiBQb2RldSBnZW5lcmFyIHVuYSBtw6BzY2FyYSBxdWUgaW5jbG9ndWkgZWxzIHDDrXhlbHMgYW1iIHZhbG9ycyBwIHNpZ25pZmljYXRpdXMsIGFwbGljYXIgbGEgbcOgc2NhcmEgYWwgcsOgc3RlciBtdWx0aWRpbWVuc2lvbmFsIGkgZmVyIHNlcnZpciBhcXVlc3QgcsOgc3RlciBtdWx0aWRpbWVuc2lvbmFsIGFtYiBtw6BzY2FyYSBjb20gYSBlbnRyYWRhIGRlIGwnZWluYSBwZXIgZmVyIGFuw6BsaXNpcyBkZSB0ZW5kw6huY2lhIGxpbmVhbCwgaGFybcOybmljYSBvIHBvbGluw7JtaWNhLjwvZGl2Pjxicj48ZGl2PkhpIGhhIHRyZXMgb3BjaW9ucyBkZSBsw61uaWEgZGUgdGVuZMOobmNpYSBwZXIgYWp1c3RhciB1bmEgdGVuZMOobmNpYSBhbHMgdmFsb3JzIHZhcmlhYmxlcyBkJ3VuYSBkaW1lbnNpw7M6IGxpbmVhbCwgcG9saW7Dsm1pY2EgaSBoYXJtw7JuaWNhLjwvZGl2Pjxicj48ZGl2PlBlciBhIGwnYW7DoGxpc2kgZGUgdGVuZMOobmNpYSBsaW5lYWwsIGxhIHNvcnRpZGEgw6lzIHVuIHLDoHN0ZXIgZGUgdHJlcyBiYW5kZXMsIHRhbCBjb20gcydpbmRpY2EgYSBjb250aW51YWNpw7M6PC9kaXY+PHVsPjxsaT5CYW5kYSAxID0gcGVuZGVudDwvbGk+PGxpPkJhbmRhIDIgPSBpbnRlcmNlcGNpw7M8L2xpPjxsaT5CYW5kYSAzID0gZXJyb3IgcXVhZHLDoHRpYyBtaXRqw6AgKFJNU0UpIG8gbCdlcnJvciBhbCB2b2x0YW50IGRlIGxhIGzDrW5pYSBkZSBtaWxsb3IgYWp1c3Q8L2xpPjwvdWw+PGRpdj5QZXIgYSBhbsOgbGlzaXMgZGUgdGVuZMOobmNpYSBwb2xpbsOybWljYSwgZWwgbm9tYnJlIGRlIGJhbmRlcyBkZSBsYSBzb3J0aWRhIGRlcMOobiBkZSBsJ29yZHJlIHBvbGluw7JtaWMuIEwnYWp1c3QgcG9saW7Dsm1pYyBkZSBzZWdvbiBvcmRyZSBwcm9kdWVpeCB1biByw6BzdGVyIGRlIHF1YXRyZSBiYW5kZXMsIHRhbCBjb20gcydpbmRpY2EgYSBjb250aW51YWNpw7M6PC9kaXY+PHVsPjxsaT5CYW5kYSAxID0gUG9seW5vbWlhbF8yPC9saT48bGk+QmFuZGEgMiA9IFBvbHlub21pYWxfMTwvbGk+PGxpPkJhbmRhIDMgPSBQb2x5bm9taWFsXzA8L2xpPjxsaT5CYW5kYSA0ID0gUk1TRTwvbGk+PC91bD48ZGl2PkwnYWp1c3QgcG9saW7Dsm1pYyBkZSB0ZXJjZXIgb3JkcmUgcHJvZHVlaXggdW4gcsOgc3RlciBkZSBjaW5jIGJhbmRlcywgdGFsIGNvbSBzJ2luZGljYSBhIGNvbnRpbnVhY2nDszo8L2Rpdj48dWw+PGxpPkJhbmRhIDEgPSBQb2x5bm9taWFsXzM8L2xpPjxsaT5CYW5kYSAyID0gUG9seW5vbWlhbF8yPC9saT48bGk+QmFuZGEgMyA9IFBvbHlub21pYWxfMTwvbGk+PGxpPkJhbmRhIDQgPSBQb2x5bm9taWFsXzA8L2xpPjxsaT5CYW5kYSA1ID0gUk1TRTwvbGk+PC91bD48ZGl2PkVuIGVsIGNhcyBkZSBsZXMgYW7DoGxpc2lzIGRlIHRlbmTDqG5jaWEgaGFybcOybmljYSwgZWwgbm9tYnJlIGRlIGJhbmRlcyBkZSBsYSBzb3J0aWRhIGRlcMOobiBkZSBsYSBmcmVxw7zDqG5jaWEgaGFybcOybmljYS4gUXVhbiBsYSBmcmVxw7zDqG5jaWEgZXMgZGVmaW5laXggY29tIGEgMSwgbGEgc29ydGlkYSDDqXMgdW4gcsOgc3RlciBkZSBjaW5jIGJhbmRlcywgdGFsIGNvbSBzJ2luZGljYSBhIGNvbnRpbnVhY2nDszo8L2Rpdj48dWw+PGxpPkJhbmRhIDEgPSBwZW5kZW50PC9saT48bGk+QmFuZGEgMiA9IGludGVyY2VwY2nDszwvbGk+PGxpPkJhbmRhIDMgPSBIYXJtb25pY19zaW4xPC9saT48bGk+QmFuZGEgNCA9IEhhcm1vbmljX2NvczE8L2xpPjxsaT5CYW5kYSA1ID0gUk1TRTwvbGk+PC91bD48ZGl2PlF1YW4gbGEgZnJlccO8w6huY2lhIGVzIGRlZmluZWl4IGNvbSBhIDIsIGxhIHNvcnRpZGEgw6lzIHVuIHLDoHN0ZXIgZGUgc2V0IGJhbmRlcywgdGFsIGNvbSBzJ2luZGljYSBhIGNvbnRpbnVhY2nDszo8L2Rpdj48dWw+PGxpPkJhbmRhIDEgPSBwZW5kZW50PC9saT48bGk+QmFuZGEgMiA9IGludGVyY2VwY2nDszwvbGk+PGxpPkJhbmRhIDMgPSBIYXJtb25pY19zaW4xPC9saT48bGk+QmFuZGEgNCA9IEhhcm1vbmljX2NvczE8L2xpPjxsaT5CYW5kYSA1ID0gSGFybW9uaWNfc2luMjwvbGk+PGxpPkJhbmRhIDYgPSBIYXJtb25pY19jb3MyPC9saT48bGk+QmFuZGEgNyA9IFJNU0U8L2xpPjwvdWw+PGRpdj5FbCBwYXLDoG1ldHJlIDxzdHJvbmc+RHVyYWRhIGRlbCBjaWNsZTwvc3Ryb25nPiBwZXIgYSBhbsOgbGlzaXMgZGUgdGVuZMOobmNpYSBoYXJtw7JuaWNhIGVzIGZhIHNlcnZpciBwZXIgaW5kaWNhciBlbCBub21icmUgaSBsYSBkdXJhZGEgZGVscyBjaWNsZXMgcXVlIGVzcGVyZXUgdmV1cmUgYSBsZXMgZGFkZXMgYWwgbGxhcmcgZCd1biBkaWEgbyBkJ3VuIGFueS4gUGVyIGV4ZW1wbGUsIHNpIGVzcGVyZXUgcXVlIGxlcyBkYWRlcyBwYXNzaW4gcGVyIGRvcyBjaWNsZXMgZGUgdmFyaWFjacOzIGVuIHVuIGFueSwgbGEgZHVyYWRhIGRlbCBjaWNsZSDDqXMgZGUgMTgyLDUgZGllcyBvIDAsNSBhbnlzLiBTaSBoZXUgcmVjb3BpbGF0IGRhZGVzIGRlIHRlbXBlcmF0dXJhIGNhZGEgdHJlcyBob3JlcyBpIGhpIGhhIHVuIGNpY2xlIGRlIHZhcmlhY2nDsyBwZXIgZGlhLCBsYSBkdXJhZGEgZGVsIGNpY2xlIMOpcyBkJ3VuIGRpYS48L2Rpdj48YnI+PGRpdj5FbCBwYXLDoG1ldHJlIDxzdHJvbmc+RnJlccO8w6huY2lhPC9zdHJvbmc+IHBlciBhIGFuw6BsaXNpcyBkZSB0ZW5kw6huY2lhIGhhcm3Dsm5pY2EgZXMgZmEgc2VydmlyIHBlciBkZXNjcml1cmUgZWwgbW9kZWwgaGFybcOybmljIGEgcXXDqCBzJ2FqdXN0YXJhbiBsZXMgZGFkZXMuIFNpIGxhIGZyZXHDvMOobmNpYSBlcyBkZWZpbmVpeCBjb20gYSAxLCBlcyBmYXLDoCBzZXJ2aXIgdW5hIGNvbWJpbmFjacOzIGRlIGxpbmVhbCBpIGNvcmJhIGhhcm3Dsm5pY2EgZGUgcHJpbWVyIG9yZHJlIHBlciBhanVzdGFyIGVsIG1vZGVsLiBTaSBsYSBmcmVxw7zDqG5jaWEgZXMgZGVmaW5laXggY29tIGEgMiwgZXMgZmFyw6Agc2VydmlyIHVuYSBjb21iaW5hY2nDsyBkZSBsaW5lYWwsIGNvcmJhIGhhcm3Dsm5pY2EgZGUgcHJpbWVyIG9yZHJlIGkgY29yYmEgaGFybcOybmljYSBkZSBzZWdvbiBvcmRyZSBwZXIgYWp1c3RhciBsZXMgZGFkZXMuIFNpIGxhIGZyZXHDvMOobmNpYSDDqXMgMywgYSBtw6lzIGVzIGZhcsOgIHNlcnZpciB1bmEgY29yYmEgaGFybcOybmljYSBkZSB0ZXJjZXIgb3JkcmUgcGVyIG1vZGVsYXIgbGVzIGRhZGVzLCBldGMuPC9kaXY+PGJyPjxkaXY+TGVzIGVzdGFkw61zdGlxdWVzIGRlIGJvbmRhdCBkJ2FqdXN0IGRlbCBtb2RlbCBlcyBwb2RlbiBnZW5lcmFyIGNvbSBhIHNvcnRpZGVzIG9wY2lvbmFscy4gTCdlcnJvciBxdWFkcsOgdGljIG1pdGrDoCAoUk1TRSksIGwnUiBxdWFkcmF0IGkgZWwgdmFsb3IgcCBkZWwgcGVuZGVudCBkZSB0ZW5kw6huY2lhIGVzIHBvZGVuIGNhbGN1bGFyIGkgc2ltYm9saXR6YXIuIFNpbWJvbGl0emV1IGxhIGNhcGEgcsOgc3RlciBkZSB0ZW5kw6huY2lhIGRlIHNvcnRpZGEgYW1iIHNpbWJvbG9naWEgPHN0cm9uZz5SR0I8L3N0cm9uZz4gaSBlc3BlY2lmaXF1ZXUgbGVzIGVzdGFkw61zdGlxdWVzIGNvbSBhIGJhbmRlcyBkZSB2ZXJtZWxsLCB2ZXJkIGkgYmxhdS48L2Rpdj48YnI+XCIsXG5cdFx0c3BlY3RyYWxVbm1peGluZ05hbWU6IFwiQW7DoGxpc2kgbGluZWFsIGRlIG1lc2NsZXMgZXNwZWN0cmFsc1wiLFxuXHRcdHNwZWN0cmFsVW5taXhpbmdTbmlwOiBcIlJlYWxpdHphIHVuYSBjbGFzc2lmaWNhY2nDsyBwZXIgc3VicMOteGVscyBpIGNhbGN1bGEgbCdhYnVuZMOgbmNpYSBmcmFjY2lvbsOgcmlhIGRlIGRpZmVyZW50cyB0aXB1cyBkZSBjb2JlcnR1cmEgZGUgc8OybCBkZSBww614ZWxzIGluZGl2aWR1YWxzLlwiLFxuXHRcdHNwZWN0cmFsVW5taXhpbmdEZXNjOiBcIkxhIGZ1bmNpw7MgQW7DoGxpc2kgbGluZWFsIGRlIG1lc2NsZXMgZXNwZWN0cmFscyBjYWxjdWxhIGxhIGNvYmVydHVyYSBmcmFjY2lvbsOgcmlhIGRlIHDDrXhlbHMgaW5kaXZpZHVhbHMgcXVlIGNvbnRlbmVuIGRpdmVyc29zIHRpcHVzIGRlIGNvYmVydHVyYSBkZSBzw7JsLiBHZW5lcmEgdW5hIGNhcGEgbXVsdGliYW5kYSBlbiBxdcOoIGNhZGEgYmFuZGEgY29ycmVzcG9uIGEgbCdhYnVuZMOgbmNpYSBmcmFjY2lvbsOgcmlhIGRlIGNhZGEgY2xhc3NlIGRlIGNvYmVydHVyYSBkZSBzw7JsLiBQZXIgZXhlbXBsZSwgbGEgcG9kZXUgdXRpbGl0emFyIHBlciBmZXIgdW5hIGNsYXNzaWZpY2FjacOzIGRlIGxhIGNvYmVydHVyYSBkZSBzw7JsIGVuIHVuYSBpbWF0Z2UgbXVsdGllc3BlY3RyYWwgcGVyIGlkZW50aWZpY2FyIGxhIHZlZ2V0YWNpw7MgZm90b3NpbnTDqHRpY2EsIGVsIHPDsmwgbnUgaSBsYSB2ZWdldGFjacOzIG1vcnRhIG8gbm8gZm90b3NpbnTDqHRpY2EuPGRpdj48YnIvPkwnb3JkcmUgZGVsIHLDoHN0ZXIgbXVsdGliYW5kYSBkZSBzb3J0aWRhIHNlZ3VlaXggbCdvcmRyZSBkZWwgcGVyZmlsIGVzcGVjdHJhbCBkJ2VudHJhZGEuIEVsIG5vbWJyZSBkZSBjbGFzc2VzIG5vIHBvdCBzdXBlcmFyIGVsIG5vbWJyZSBkZSBiYW5kZXMgZGVsIHLDoHN0ZXIgZCdlbnRyYWRhLiBQZXIgZXhlbXBsZSwgbm8gcG9kZXUgZXh0cmV1cmUgaW5mb3JtYWNpw7Mgc29icmUgbcOpcyBkZSA4IGNsYXNzZXMgZCd1biByw6BzdGVyIGRlIDggYmFuZGVzLjwvZGl2PlwiLFxuXHRcdG11bHRpZGltZW5zaW9uYWxGaWx0ZXJOYW1lOiBcIkZpbHRyZSBtdWx0aWRpbWVuc2lvbmFsXCIsXG5cdFx0aW50ZXJwb2xhdGVSYXN0ZXJCeURpbWVuc2lvbkZ1bmN0aW9uTmFtZTogXCJJbnRlcnBvbGEgcsOgc3RlciBwZXIgZGltZW5zacOzXCIsXG5cdFx0aW50ZXJwb2xhdGVSYXN0ZXJCeURpbWVuc2lvbkZ1bmN0aW9uU25pcDogXCJJbnRlcnBvbGEgdW4gcsOgc3RlciBtdWx0aWRpbWVuc2lvbmFsIGEgdW5zIHZhbG9ycyBkZSBkaW1lbnNpw7MgZXNwZWNpZmljYXRzIG1pdGphbsOnYW50IHNlY3RvcnMgYWRqYWNlbnRzLlwiLFxuXHRcdGludGVycG9sYXRlUmFzdGVyQnlEaW1lbnNpb25GdW5jdGlvbkRlc2M6IFwiPHA+QXF1ZXN0YSBmdW5jacOzIHBlcm1ldCBjYWxjdWxhciB2YWxvcnMgZGUgcMOteGVscyBwZXIgYSB1biBzZWN0b3IgZGUgZGltZW5zacOzIHNlbnNlIGRlZmluaXIgZCd1biByw6BzdGVyIG11bHRpZGltZW5zaW9uYWwuIFBlciBleGVtcGxlLCBzaSB0ZW5pdSB1biBkYXRhc2V0IHF1ZSBjb250aW5ndWkgbGEgdGVtcGVyYXR1cmEgZGUgbCdvY2XDoCBhbCBuaXZlbGwgZGUgc3VwZXJmw61jaWUgaSBhIDEwMCBtZXRyZXMgcGVyIHNvdGEgZGVsIG5pdmVsbCBkZWwgbWFyIGkgdm9sZXUgY2FsY3VsYXIgbGEgdGVtcGVyYXR1cmEgYSA1MCBtZXRyZXMgcGVyIHNvdGEgZGVsIG5pdmVsbCBkZWwgbWFyLCBwb2RldSBmZXIgc2VydmlyIGFxdWVzdGEgZnVuY2nDsyBwZXIgb2J0ZW5pciB1bmEgZXN0aW1hY2nDsyBhIGFxdWVzdGEgcHJvZnVuZGl0YXQgbWl0amFuw6dhbnQgbGEgZGVmaW5pY2nDsyBkZSBsYSBkaW1lbnNpw7MgUGVyIHZhbG9ycy48L3A+PHA+VGFtYsOpIHBvZGV1IG9idGVuaXIgdW5hIHN1Ym1vc3RyYSBkJ3VuIGRhdGFzZXQgZGlhcmkgYSBwYXJ0aXIgZCd1biBkYXRhc2V0IG1lbnN1YWwgbWl0amFuw6dhbnQgbGEgZGVmaW5pY2nDsyBkZSBsYSBkaW1lbnNpw7MgUGVyIGludGVydmFsIGkgZGVmaW5pbnQgZWwgdmFsb3IgZGVsIHBhcsOgbWV0cmUgUGFzIGVuIDEgaSBlbCB2YWxvciBkZWwgcGFyw6BtZXRyZSBVbml0YXQgZW4gRGllcy48L3A+PHA+RmV1IHNlcnZpciBsYSBkZWZpbmljacOzIGRlIGxhIGRpbWVuc2nDsyBQZXIgcsOgc3RlciBkZSBkZXN0aW5hY2nDsyBwZXIgY2FsY3VsYXIgZWwgdmFsb3IgZGVsIHLDoHN0ZXIgZGUgZGVzdGluYWNpw7MuPC9wPlwiLFxuXHRcdG11bHRpZGltZW5zaW9uYWxGaWx0ZXJTbmlwOiBcIkNyZWEgdW5hIGNhcGEgcsOgc3RlciBhIHBhcnRpciBkJ3VuIGRhdGFzZXQgcsOgc3RlciBtdWx0aWRpbWVuc2lvbmFsIG8gdW5hIGNhcGEgcsOgc3RlciBtdWx0aWRpbWVuc2lvbmFsIHNlZ21lbnRhbnQgbGVzIGRhZGVzIHNlZ29ucyBsZXMgdmFyaWFibGVzIGkgbGVzIGRpbWVuc2lvbnMgZGVmaW5pZGVzLlwiLFxuXHRcdG11bHRpZGltZW5zaW9uYWxGaWx0ZXJEZXNjOiBcIkxhIGZ1bmNpw7MgRmlsdHJlIG11bHRpZGltZW5zaW9uYWwgY3JlYSB1bmEgY2FwYSByw6BzdGVyIG11bHRpZGltZW5zaW9uYWwgZmlsdHJhbnQgaSBleHRyYWllbnQgdW4gc3ViY29uanVudCBkZSB2YXJpYWJsZXMgZCd1biByw6BzdGVyIG11bHRpZGltZW5zaW9uYWwuIFBlciBleGVtcGxlLCB0ZW5pdSB1biBkYXRhc2V0IG11bHRpZGltZW5zaW9uYWwgcXVlIGNvbnTDqSAzMCBhbnlzIGRlIGRhZGVzIGRlIHByZWNpcGl0YWNpb25zIG1lbnN1YWxzIGkgbm9tw6lzIHZvbGV1IGV4dHJldXJlIGxlcyBkYWRlcyBkZSBjYWRhIGdlbmVyIHBlciB2ZXVyZSBjb20gbGVzIHByZWNpcGl0YWNpb25zIGhhbiBjYW52aWF0IGFxdWVzdCBtZXMuPGRpdj48YnIvPlV0aWxpdHpldSBlbCBwYXLDoG1ldHJlIERlZmluaWNpw7MgZGUgbGEgZGltZW5zacOzIHBlciBzZWdtZW50YXIgbGVzIGRpbWVuc2lvbnMgYSBwYXJ0aXIgZCd1biBpbnRlcnZhbCwgdW4gdmFsb3IgbyB1biBpbnRlcnZhbCBkZSB2YWxvcnMuIFBlciBleGVtcGxlLCBzaSB0ZW5pdSAxMCBhbnlzIGRlIGRhZGVzIGRlIHNhbGluaXRhdCBkZSBsJ29jZcOgLCByZWNvcGlsYWRlcyBtZW5zdWFsbWVudCBhIGNhZGEgZG9zIG1ldHJlcyBkZSBwcm9mdW5kaXRhdCBmaW5zIGFscyA1MDAgbWV0cmVzLCBwb2RldSB1dGlsaXR6YXIgZGlmZXJlbnRzIG9wY2lvbnMgZGUgZGVmaW5pY2nDsyBkZSBsYSBkaW1lbnNpw7MgcGVyIGFscyBjYXNvcyBzZWfDvGVudHMuIENhcyAxOiBleHRyYWlldSBsZXMgZGFkZXMgZGUgc2FsaW5pdGF0IGRlbCBtZXMgZGUgZ2VuZXIgZW4gdW4gcGVyw61vZGUgZGUgMTAgYW55cy4gVHJpZXUgUGVyIHZhbG9ycywgZGVmaW5pdSBEaW1lbnNpw7MgZW4gU3RkVGltZSBpIGRlZmluaXUgVmFsb3JzIGVuIEdlbmVyLiBDYXMgMjogc2VnbWVudGV1IGxlcyBkYWRlcyBkZSBzYWxpbml0YXQgZW4gdW4gaW50ZXJ2YWwgZGUgcHJvZnVuZGl0YXQgZGUgMCBhIDE1MCBtZXRyZXMuIFRyaWV1IFBlciBpbnRlcnZhbHMsIGRlZmluaXUgRGltZW5zacOzIGVuIFN0ZFogaSBkZWZpbml1IFZhbG9yIG3DrW5pbSBlbiAtMTUwIGkgVmFsb3IgbcOgeGltIGVuIDAuIENhcyAzOiBleHRyYWlldSBsZXMgZGFkZXMgZGUgc2FsaW5pdGF0IGRlbHMgcHJpbWVycyAxMCBkaWVzIGRlIGNhZGEgZ2VuZXIgZW4gdW4gcGVyw61vZGUgZGUgMTAgYW55cy4gVHJpZXUgUGVyIGl0ZXJhY2nDsywgZGVmaW5pdSBEaW1lbnNpw7MgZW4gU3RkVGltZSwgZGVmaW5pdSBJbmljaSBkZSBsYSBwcmltZXJhIGl0ZXJhY2nDsyBpIEZpbmFsIGRlIGxhIHByaW1lcmEgaXRlcmFjacOzIGVuIGwnaW5pY2kgaSBlbCBmaW5hbCBjb3JyZXNwb25lbnRzIGFsIHBlcsOtb2RlIGQnaXRlcmFjacOzLCBkZWZpbml1IFBhcyBlbiAxIGkgZGVmaW5pdSBVbml0YXQgZW4gQW55cy48L2Rpdj5cIixcblx0XHRtdWx0aWRpbWVuc2lvbmFsUmFzdGVyTmFtZTogXCJSw6FzdGVyIG11bHRpZGltZW5zaW9uYWxcIixcblx0XHRtdWx0aWRpbWVuc2lvbmFsUmFzdGVyU25pcDogXCJBZmVnZWl4IGRhZGVzIG11bHRpZGltZW5zaW9uYWxzIGEgdW4gbWFwYSBjb20gdW5hIGNhcGEgZGUgcsOgc3RlciBtdWx0aWRpbWVuc2lvbmFsLlwiLFxuXHRcdG11bHRpZGltZW5zaW9uYWxSYXN0ZXJEZXNjOiBcIkxhIGZ1bmNpw7MgUsOgc3RlciBtdWx0aWRpbWVuc2lvbmFsIGFmZWdlaXggZGFkZXMgbXVsdGlkaW1lbnNpb25hbHMgYSB1biBtYXBhIGNvbSB1bmEgY2FwYSBkZSByw6BzdGVyIG11bHRpZGltZW5zaW9uYWwuIEFxdWVzdGEgZnVuY2nDsyDDqXMgw7p0aWwgZW4gZXhlY3V0YXIgZmx1eG9zIGRlIHRyZWJhbGwgZCdhbsOgbGlzaSBkZSByw6BzdGVyIGFtYiB1bmEgY2FkZW5hIGRlIGZ1bmNpb25zLjxkaXY+PGJyLz5FbnRyZSBlbHMgZGF0YXNldHMgcsOgc3RlciBtdWx0aWRpbWVuc2lvbmFscyBhZG1lc29zIGhpIGhhIG5ldENERiwgR1JJQiwgSERGIGkgQ1JGIGQnRXNyaS4gRWxzIGRhdGFzZXRzIGRlIG1vc2FpYyBtdWx0aWRpbWVuc2lvbmFscyB0YW1iw6kgcydhZG1ldGVuLjwvZGl2PlwiLFxuXHRcdG9wdGltYWxQYXRoQXNSYXN0ZXJOYW1lOiBcIlJ1dGEgw7JwdGltYSBjb20gYSByw6BzdGVyXCIsXG5cdFx0b3B0aW1hbFBhdGhBc1Jhc3RlclNuaXA6IFwiQ2FsY3VsYSBsYSBydXRhIGRlIG1lbm9yIGNvc3QgZGVzIGQndW4gb3JpZ2VuIGZpbnMgYSB1bmEgZGVzdGluYWNpw7MuXCIsXG5cdFx0b3B0aW1hbFBhdGhBc1Jhc3RlckRlc2M6IFwiQXF1ZXN0YSBmdW5jacOzIGdsb2JhbCBnZW5lcmEgdW4gcsOgc3RlciBkZSBzb3J0aWRhIHF1ZSByZWdpc3RyYSBsYSBydXRhIG8gbGVzIHJ1dGVzIMOycHRpbWVzIGRlcyBkZSBsZXMgdWJpY2FjaW9ucyBzZWxlY2Npb25hZGVzIGZpbnMgYSBsYSBjZWzCt2xhIGQnb3JpZ2VuIG3DqXMgcHJvcGVyYSBkZWZpbmlkYSBhIGxhIHN1cGVyZsOtY2llIGRlIGNvc3QgYWN1bXVsYXRpdSwgZW4gdGVybWVzIGRlIGNvc3QgZW4gcGxhLjxkaXY+PGJyLz5Ob3JtYWxtZW50IHMnaGFuIGQnZXhlY3V0YXIgdW5hIG8gZGl2ZXJzZXMgZGUgbGVzIGZ1bmNpb25zIGRlIGNvc3QgcG9uZGVyYXQgKEFjdW11bGFjacOzIGRlIGRpc3TDoG5jaWEgbyBBc3NpZ25hY2nDsyBkZSBkaXN0w6BuY2lhKSBhYmFucyBkJ2V4ZWN1dGFyIGxhIGZ1bmNpw7MgUnV0YSDDsnB0aW1hIGNvbSBhIHLDoHN0ZXIgcGVyIGNyZWFyIGwnYWN1bXVsYWNpw7MgZGUgZGlzdMOgbmNpYSBkJ2VudHJhZGEgaSBlbHMgcsOgc3RlcnMgZGUgZGlyZWNjacOzIGludmVyc2EuIEFxdWVzdGVzIHPDs24gY2FwZXMgcsOgc3RlciBkJ2VudHJhZGEgb2JsaWdhdMOycmllcyBwZXIgYSBsYSBmdW5jacOzIFJ1dGEgw7JwdGltYS4gRWxzIHZhbG9ycyBkZSBsYSBydXRhIMOycHRpbWEgZGUgc29ydGlkYSByZXByZXNlbnRlbiBlbCBub21icmUgZGUgcnV0ZXMgYSB1bmEgdWJpY2FjacOzIGRldGVybWluYWRhLiBFbiBtb2x0cyBjYXNvcywgbGVzIHJ1dGVzIHNlZ3VlaXhlbiBlbCBtYXRlaXggY2Ftw60sIHN1cnRlbiBkJ3VuIG9yaWdlbiBpIGVzIGRlc3ZpZW4gcGVyIGFuYXIgYSBkaWZlcmVudHMgZGVzdGluYWNpb25zLiBQZXIgZXhlbXBsZSwgdW4gdmFsb3IgZCd1IGluZGljYSBxdWUgbm9tw6lzIGhpIGhhIHVuYSBydXRhIMOycHRpbWEgZW4gdW5hIHViaWNhY2nDsyBkZXRlcm1pbmFkYSwgbWVudHJlIHF1ZSB1biB2YWxvciBkZSBjaW5jIHNpZ25pZmljYSBxdWUgYSBsYSB1YmljYWNpw7MgaGkgaGEgY2luYyBydXRlcyDDsnB0aW1lcyBxdWUgcGFzc2VuIHBlciBhcXVlc3RhIGNlbMK3bGEgZGUgbCfDoHJlYSBkJ2VzdHVkaS48ZGl2Pjxici8+TGVzIGRhZGVzIGRlIGRlc3RpbmFjacOzIGQnZW50cmFkYSBoYW4gZGUgc2VyIHVuYSBjYXBhIHLDoHN0ZXIuIEVsIGNvbmp1bnQgZGUgY2VswrdsZXMgZGUgZGVzdGluYWNpw7MgY29uc2lzdGVpeCBlbiB0b3RlcyBsZXMgY2VswrdsZXMgZGVsIHLDoHN0ZXIgZCdlbnRyYWRhIHF1ZSB0ZW5lbiB2YWxvcnMgdsOgbGlkcy4gTGVzIGNlbMK3bGVzIGFtYiB2YWxvcnMgTm9EYXRhIG5vIHMnaW5jbG91ZW4gYWwgY29uanVudC4gRWwgdmFsb3IgemVybyBlcyBjb25zaWRlcmEgdW5hIGRlc3RpbmFjacOzIGxlZ8OtdGltYS4gVW4gcsOgc3RlciBkZSBkZXN0aW5hY2nDsyBlcyBwb3QgY3JlYXIgYW1iIGVpbmVzIGQnZXh0cmFjY2nDsy4gU2kgdGVuaXUgZW50aXRhdHMgZGUgZGVzdGluYWNpw7MgbyBkJ29yaWdlbiwgcG9kZXUgY29udmVydGlyLWxlcyBlbiByw6BzdGVyIGFtYiBsYSBmdW5jacOzIFJhc3Rlcml0emEgZW50aXRhdHMuIFV0aWxpdHpldSBlbCByw6BzdGVyIGQnYWN1bXVsYWNpw7MgZGUgZGlzdMOgbmNpYSBvIGRlIGRpcmVjY2nDsyBpbnZlcnNhIGNvbSBhIGVudHJhZGEgZGUgcsOgc3RlciBhIGxhIGZ1bmNpw7MgZGUgcmFzdGVyaXR6YWNpw7MuIEQnYXF1ZXN0YSBtYW5lcmEsIGwnZW50aXRhdCBlcyByYXN0ZXJpdHphIGFtYiBsYSBtYXRlaXhhIG1pZGEgZGUgY2VswrdsYSwgbGEgbWF0ZWl4YSBleHRlbnNpw7MgaSBsYSBtYXRlaXhhIHJlZmVyw6huY2lhIGVzcGFjaWFsIHF1ZSBlbHMgYWx0cmVzIHLDoHN0ZXJzIHF1ZSBzJ2luY2xvdXJhbiBhIGxhIGZ1bmNpw7MgUnV0YSDDsnB0aW1hIGNvbSBhIHLDoHN0ZXIuIExhIGZ1bmNpw7MgUnV0YSDDsnB0aW1hIGNvbSBhIHLDoHN0ZXIgdGFtYsOpIGVzIHBvdCB1dGlsaXR6YXIgcGVyIGRlcml2YXIgbGEgcnV0YSBkZSBtZW55cyByZXNpc3TDqG5jaWEgYSB1biBtb2RlbCBkJ2VsZXZhY2nDsyBkaWdpdGFsIChERU0pLiBFbiBhcXVlc3QgY2FzLCB1dGlsaXR6ZXUgZWwgREVNIHBlciBhbCByw6BzdGVyIGQnYWN1bXVsYWNpw7MgZGUgZGlzdMOgbmNpYSBkJ2VudHJhZGEgaSBsYSBzb3J0aWRhIGRlIGxhIGZ1bmNpw7MgRGlyZWNjacOzIGRlbCBmbHV4IHBlciBhbCByw6BzdGVyIGRlIGRpcmVjY2nDsyBpbnZlcnNhLjwvZGl2PlwiLFxuXHRcdHRyZW5kTmFtZTogXCJQcmVkaXUgbWl0amFuw6dhbnQgbGEgdGVuZMOobmNpYVwiLFxuXHRcdHRyZW5kU25pcDogXCJDYWxjdWxhIHVuYSBjYXBhIHLDoHN0ZXIgbXVsdGlkaW1lbnNpb25hbCBwcmV2aXN0YSBtaXRqYW7Dp2FudCBlbCByw6BzdGVyIGRlIHRlbmTDqG5jaWEgZGUgc29ydGlkYSBkZXMgZGUgbGEgZnVuY2nDsyBHZW5lcmEgbGEgdGVuZMOobmNpYSBvIGwnZWluYSBkZSBnZW9wcm9jZXNzYW1lbnQgR2VuZXJhIGVsIHLDoHN0ZXIgZGUgdGVuZMOobmNpYS5cIixcblx0XHR0cmVuZERlc2M6IFwiTGEgZnVuY2nDsyBQcmVkaXUgbWl0amFuw6dhbnQgbGEgdGVuZMOobmNpYSBjYWxjdWxhIHVuYSBjYXBhIHLDoHN0ZXIgbXVsdGlkaW1lbnNpb25hbCBwcmV2aXN0YSBtaXRqYW7Dp2FudCBlbCByw6BzdGVyIGRlIHRlbmTDqG5jaWEgZGUgc29ydGlkYSBkZXMgZGUgbGEgZnVuY2nDsyBHZW5lcmEgbGEgdGVuZMOobmNpYSBvIGwnZWluYSBkZSBnZW9wcm9jZXNzYW1lbnQgR2VuZXJhIGVsIHLDoHN0ZXIgZGUgdGVuZMOobmNpYS5cIixcblx0XHRyYXN0ZXJDb2xsZWN0aW9uTmFtZTogXCJQcm9jZXNzYSBsYSBjb2zCt2xlY2Npw7MgZGUgcsOgc3RlclwiLFxuXHRcdHJhc3RlckNvbGxlY3Rpb25TbmlwOiBcIlByb2Nlc3NhIGNhZGEgc2VjdG9yIGQndW4gcsOgc3RlciBtdWx0aWRpbWVuc2lvbmFsIG8gY2FkYSBlbGVtZW50IGQndW4gcsOgc3RlciBkZSBtb3NhaWMuIEFxdWVzdGEgZnVuY2nDsyB0YW1iw6kgcG90IGFncmVnYXIgZGl2ZXJzb3Mgc2VjdG9ycyBlbiB1biBzb2wgc2VjdG9yLlwiLFxuXHRcdHJhc3RlckNvbGxlY3Rpb25EZXNjOiBcIkxhIGZ1bmNpw7MgUHJvY2Vzc2EgbGEgY29swrdsZWNjacOzIGRlIHLDoHN0ZXIgcHJvY2Vzc2EgY2FkYSBzZWN0b3IgZCd1biByw6BzdGVyIG11bHRpZGltZW5zaW9uYWwgbyBjYWRhIGVsZW1lbnQgZCd1biByw6BzdGVyIGRlIG1vc2FpYy4gQXF1ZXN0YSBmdW5jacOzIHRhbWLDqSBwb3QgYWdyZWdhciBkaXZlcnNvcyBzZWN0b3JzIGVuIHVuIHNvbCBzZWN0b3IuPGRpdj48YnIvPkFxdWVzdGEgZnVuY2nDsyBwcm9jZXNzYSBjYWRhIHNlY3RvciBkJ3VuIHLDoHN0ZXIgbXVsdGlkaW1lbnNpb25hbCBvIHLDoHN0ZXIgZGUgbW9zYWljIGFtYiB1bmEgcGxhbnRpbGxhIGRlIGZ1bmNpw7MgZGUgcsOgc3Rlci4gQXF1ZXN0YSBmdW5jacOzIGFkbWV0IGxlcyBvcGNpb25zIHNlZ8O8ZW50czogMS4gRXNwZWNpZmljYXIgdW5hIHBsYW50aWxsYSBkZSBmdW5jacOzIGRlIHLDoHN0ZXIgcGVyIGEgRnVuY2nDsyBkJ2VsZW1lbnQuIFBlciBleGVtcGxlLCB0ZW5pdSB1biBkYXRhc2V0IGRlIG1vc2FpYyBxdWUgY29udMOpIDIwIGFueXMgZCdpbWF0Z2VzIGRlbCBMYW5kc2F0IGkgdm9sZXUgY2FsY3VsYXIgbCdORFZJIGRlIGNhZGEgZXNjZW5hIGVuIHVuYSBzw6hyaWUgdGVtcG9yYWwuIFBlciBhIEZ1bmNpw7MgZCdlbGVtZW50LCBlc3BlY2lmaXF1ZXUgdW5hIHBsYW50aWxsYSBkZSBmdW5jacOzIGRlIHLDoHN0ZXIgcXVlIGNvbnRpbmd1aSBsYSBmdW5jacOzIGRlIHLDoHN0ZXIgZGUgbCdORFZJLiAyLiBFc3BlY2lmaWNhciB1bmEgcGxhbnRpbGxhIGRlIGZ1bmNpw7MgZGUgcsOgc3RlciBwZXIgYSBGdW5jacOzIGQnYWdyZWdhY2nDsy4gUGVyIGV4ZW1wbGUsIHRlbml1IHVuIHLDoHN0ZXIgbXVsdGlkaW1lbnNpb25hbCBxdWUgY29udMOpIDEwIGFueXMgZGUgZGFkZXMgZGUgdGVtcGVyYXR1cmEgZGnDoHJpZXMgaSB2b2xldSBjYWxjdWxhciBsYSB0ZW1wZXJhdHVyYSBtw6B4aW1hIGRlIGNhZGEgYW55LiBBIEZ1bmNpw7MgZCdhZ3JlZ2FjacOzLCBlc3BlY2lmaXF1ZXUgdW5hIHBsYW50aWxsYSBkZSBmdW5jacOzIGRlIHLDoHN0ZXIgcXVlIGNvbnRpbmd1aSBsYSBmdW5jacOzIEVzdGFkw61zdGlxdWVzIGRlIGxhIGNlbMK3bGEsIGFtYiBsJ29wZXJhY2nDsyBkZWZpbmlkYSBjb20gYSBNw6B4aW0uIEEgRGVmaW5pY2nDsyBkZSBsJ2FncmVnYWNpw7MsIGRlZmluaXUgRGltZW5zacOzIGVuIFN0ZFRpbWUsIGRlZmluaXUgVGlwdXMgZW4gUGFyYXVsYSBjbGF1IGRlIGwnaW50ZXJ2YWwgaSBkZWZpbml1IEludGVydmFsIGRlIHBhcmF1bGVzIGNsYXUgZW4gQW51YWwuIFRpbmd1ZXUgZW4gY29tcHRlIHF1ZSBzaSBlbCBkYXRhc2V0IGRlIG1vc2FpYyBkJ2VudHJhZGEgbm8gw6lzIG11bHRpZGltZW5zaW9uYWwsIGxhIGZ1bmNpw7MgZCdhZ3JlZ2FjacOzIG5vIHJlc3BlY3RhcsOgIGxhIGRlZmluaWNpw7MgZCdhZ3JlZ2FjacOzLiBMYSBmdW5jacOzIGQnYWdyZWdhY2nDsyBhZ3JlZ2Fyw6AgdG90cyBlbHMgZWxlbWVudHMgbyBjYWRhIGdydXAgZW4gdW4gc2kgZXN0YW4gZGVmaW5pdHMgYSBsYSBwbGFudGlsbGEgZGUgZnVuY2nDsyBkJ2FncmVnYWNpw7MuIFBlciBvYnRlbmlyIG3DqXMgaW5mb3JtYWNpw7Mgc29icmUgbCfDunMgZGVscyBncnVwcyBlbiB1biBkYXRhc2V0IGRlIG1vc2FpYywgY29uc3VsdGV1IFV0aWxpdHphciBlbGVtZW50cyBkZSBkYXRhc2V0IGRlIG1vc2FpYyBlbiBwbGFudGlsbGVzIGRlIGZ1bmNpw7MgZGUgcsOgc3Rlci4gMy4gRXNwZWNpZmljYXIgdW5hIHBsYW50aWxsYSBkZSBmdW5jacOzIGRlIHLDoHN0ZXIgcGVyIGEgRnVuY2nDsyBkZSBwcm9jZXNzYW1lbnQuIExhIGZ1bmNpw7MgbyBsYSBjYWRlbmEgZGUgZnVuY2lvbnMgZCdhcXVlc3RhIHBsYW50aWxsYSBzJ3V0aWxpdHphIHBlciBtb3N0cmFyIGVsIG5vdSByw6BzdGVyIHByb2Nlc3NhdC4gUGVyIGV4ZW1wbGUsIGVzcGVjaWZpcXVldSB1bmEgcGxhbnRpbGxhIGRlIGZ1bmNpw7MgcsOgc3RlciBxdWUgY29udGluZ3VpIGxhIGZ1bmNpw7MgTWFwYSBkZSBjb2xvciBwZXIgY2FudmlhciBjb20gZXMgbW9zdHJhIGxhIGNhcGEgcsOgc3RlciBwcm9jZXNzYWRhLiBUaW5ndWV1IGVuIGNvbXB0ZSBxdWUgc2kgbCdlbnRyYWRhIMOpcyB1biByw6BzdGVyIG11bHRpZGltZW5zaW9uYWwsIGxhIGZ1bmNpw7MgZGUgcHJvY2Vzc2FtZW50IHMnYXBsaWNhIGFsIHNlY3RvciBxdWUgZXMgbW9zdHJhIGFjdHVhbG1lbnQuIFNpIGwnZW50cmFkYSDDqXMgdW5hIGNhcGEgZGUgbW9zYWljIG8gdW4gZGF0YXNldCBkZSBtb3NhaWMsIGxhIGZ1bmNpw7MgZGUgcHJvY2Vzc2FtZW50IHMnYXBsaWNhIGFsIHLDoHN0ZXIgZGUgbW9zYWljIGFtYiBlbCBtw6h0b2RlIFByaW1lciBwZXIgcmVzb2xkcmUgbGVzIHN1cGVycG9zaWNpb25zLiAzLiBFc3BlY2lmaWNhciBsZXMgcGxhbnRpbGxlcyBwZXIgYSBxdWFsc2V2b2wgY29tYmluYWNpw7MgZGUgdG90ZXMgdHJlcyBmdW5jaW9ucy4gUGVyIGV4ZW1wbGUsIHRlbml1IHVuIGRhdGFzZXQgZGUgbW9zYWljIHF1ZSBjb250w6kgaW1hdGdlcyBkZWwgTGFuZHNhdCBkZSBzw6hyaWVzIHRlbXBvcmFscyBpIHZvbGV1IGdlbmVyYXIgdW5hIGltYXRnZSBjb21wb3N0YSBhbWIgdW4gTkRWSSBtw6B4aW0uIFBlciBhIEZ1bmNpw7MgZCdlbGVtZW50LCBlc3BlY2lmaXF1ZXUgdW5hIHBsYW50aWxsYSBkZSBmdW5jacOzIGRlIHLDoHN0ZXIgcXVlIGNvbnRpbmd1aSBsYSBmdW5jacOzIGRlIHLDoHN0ZXIgZGUgbCdORFZJLiBQZXIgYSBGdW5jacOzIGQnYWdyZWdhY2nDsywgZXNwZWNpZmlxdWV1IHVuYSBwbGFudGlsbGEgZGUgZnVuY2nDsyBkZSByw6BzdGVyIHF1ZSBjb250aW5ndWkgbGEgZnVuY2nDsyBFc3RhZMOtc3RpcXVlcyBkZSBsYSBjZWzCt2xhLCBhbWIgbCdvcGVyYWNpw7MgZGVmaW5pZGEgY29tIGEgTcOgeGltLiBQZXIgYSBGdW5jacOzIGRlIHByb2Nlc3NhbWVudCwgZXNwZWNpZmlxdWV1IHVuYSBwbGFudGlsbGEgZGUgZnVuY2nDsyBkZSByw6BzdGVyIHF1ZSBjb250aW5ndWkgbGEgZnVuY2nDsyBNYXBhIGRlIGNvbG9yLiBUaW5ndWV1IGVuIGNvbXB0ZSBxdWUgbCdvcmRyZSBkZSBsYSBmdW5jacOzIGRlIHByb2Nlc3NhbWVudCBzZWd1ZWl4IGwnb3JkcmUgZGVscyBwYXLDoG1ldHJlcyBkJ2VudHJhZGEuIFBlciBleGVtcGxlLCBGdW5jacOzIGQnZWxlbWVudCBlcyBwcm9jZXNzYXLDoCBwcmltZXIuPC9kaXY+XCIsXG5cdFx0cmFuZG9tTmFtZTogXCJBbGVhdG9yaVwiLFxuXHRcdHJhbmRvbVNuaXA6IFwiQ3JlYSB1biByw6BzdGVyIGFtYiB2YWxvcnMgZGUgcMOteGVsIGFsZWF0b3JpcyBleHRyZXRzIGQndW5hIGRpc3RyaWJ1Y2nDsyBwc2V1ZG9hbGVhdMOycmlhLiBTJ2FkbWV0ZW4gZGl2ZXJzZXMgZGlzdHJpYnVjaW9ucyBpIGdlbmVyYWRvcnMgZGUgbm9tYnJlcyBhbGVhdG9yaXMuXCIsXG5cdFx0cmFuZG9tRGVzYzogXCJMYSBmdW5jacOzIEFsZWF0b3JpIGNyZWEgdW4gcsOgc3RlciBhbWIgdmFsb3JzIGRlIHDDrXhlbCBhbGVhdG9yaXMgcXVlIGVzIHBvZGVuIHV0aWxpdHphciBhIGxlcyBwbGFudGlsbGVzIGRlIGZ1bmNpw7MgZGUgcsOgc3RlciBvIGFscyBkYXRhc2V0cyBkZSBtb3NhaWMsLjxkaXY+PGJyLz5Ub3QgaSBxdWUgbW9sdGVzIGZ1bmNpb25zIHMnYXBsaXF1ZW4gYSB1biBvIGRpdmVyc29zIHLDoHN0ZXJzIGQnZW50cmFkYSwgbGEgZnVuY2nDsyBBbGVhdG9yaSBubyBlbiBuZWNlc3NpdGEgY2FwLiBBaXjDsiB2b2wgZGlyIHF1ZSBmdW5jaW9uYSBtw6lzIGNvbSB1biBkYXRhc2V0IGRlIHLDoHN0ZXIgcXVlIGNvbSB1bmEgZnVuY2nDsywgYWl4w60gcXVlIGNhbCBhbmFyIGFtYiBjb21wdGUgZW4gYWZlZ2lyLWxhIG8gZWxpbWluYXItbGEgZGUgbGEgY2FkZW5hIGRlIGZ1bmNpb25zLjwvZGl2PlwiLFxuXHRcdHNocmlua05hbWU6IFwiUmVkdWVpeFwiLFxuXHRcdHNocmlua1NuaXA6IFwiUmVkdWVpeCBsZXMgem9uZXMgc2VsZWNjaW9uYWRlcyBlbiB1biBub21icmUgZXNwZWNpZmljYXQgZGUgY2VswrdsZXMgc3Vic3RpdHVpbnQtbGVzIGFtYiBlbCB2YWxvciBkZSBsYSBjZWzCt2xhIHF1ZSDDqXMgbcOpcyBmcmVxw7xlbnQgYWwgdmXDr25hdC5cIixcblx0XHRzaHJpbmtEZXNjOiBcIkFtYiBsYSBmdW5jacOzIGdsb2JhbCBSZWR1ZWl4LCBwb2RldSBnZW5lcmFsaXR6YXIgbyBzaW1wbGlmaWNhciByw6BzdGVycyBmZW50IHF1ZSB6b25lcyBjb25jcmV0ZXMgc2lndWluIG3DqXMgcGV0aXRlcy4gVGFtYsOpIHBvZGV1IGNvbnRyb2xhciBsYSBxdWFudGl0YXQgZGUgZ2VuZXJhbGl0emFjacOzIHF1ZSBlcyBwcm9kdWlyw6AuPGRpdj48YnIvPkxlcyB6b25lcyBxdWUgc2VsZWNjaW9uZXUgZXMgcmVkdWlyYW4sIG8gZW4gZGlzbWludWlyw6AgbGEgbWlkYSwgZW4gZXhwYW5kaXItcydoaSBsZXMgem9uZXMgZGVscyB2b2x0YW50cy4gQ29uY2VwdHVhbG1lbnQsIGVscyB2YWxvcnMgZGUgem9uYSBzZWxlY2Npb25hdHMgZXMgcG9kZW4gdmV1cmUgY29tIGEgem9uZXMgZW4gcHJpbWVyIHBsYSwgbWVudHJlIHF1ZSBlbHMgYWx0cmVzIHZhbG9ycyBjb250aW51YXJhbiBzZW50IHpvbmVzIGRlIGZvbnMuIExlcyBjZWzCt2xlcyBkZSBsZXMgem9uZXMgZW4gcHJpbWVyIHBsYSBlcyBwb2RlbiBzdWJzdGl0dWlyIHBlciBjZWzCt2xlcyBkZSBsZXMgem9uZXMgZGUgZm9ucy4gVGFtYsOpIGVzIHBvZGVuIHN1YnN0aXR1aXIgcGV0aXRlcyBpbGxlcyBkaW5zIGQndW5hIHpvbmEsIHF1ZSBlcyBwb2RlbiB2ZXVyZSBjb20gYSBsw61taXRzIGNvbXBhcnRpdHMgYW1iIGxhIHpvbmEuPGRpdj48YnIvPkxhIHF1YW50aXRhdCBkZSBnZW5lcmFsaXR6YWNpw7MgZXMgcG90IGNvbnRyb2xhciBhbWIgZWwgcGFyw6BtZXRyZSBOb21icmUgZGUgY2VswrdsZXMuIFBlciBkZWZlY3RlLCBlbCB2YWxvciDDqXMgMSwgY29zYSBxdWUgdm9sIGRpciBxdWUgbGVzIHpvbmVzIHNlbGVjY2lvbmFkZXMgZXMgcmVkdWlyYW4gbGEgcXVhbnRpdGF0IGNvcnJlc3BvbmVudCBhIGxhIG1pZGEgZCd1bmEgY2VswrdsYS4gUGVyIGluY3JlbWVudGFyIGVsIGdyYXUgZGUgZ2VuZXJhbGl0emFjacOzLCBwb2RldSBlc3BlY2lmaWNhciB1biB2YWxvciBtw6lzIGdyYW4gcGVyIGEgYXF1ZXN0IHBhcsOgbWV0cmUuIENvbmNlcHR1YWxtZW50LCDDqXMgY29tIGV4ZWN1dGFyIGwnZWluYSBsZXMgbWF0ZWl4ZXMgdmVnYWRlcyBxdWUgZWwgbm9tYnJlIGVzcGVjaWZpY2F0LCB1dGlsaXR6YW50IGVscyB2YWxvcnMgZGUgbCdleGVjdWNpw7MgYW50ZXJpb3IgY29tIGEgZW50cmFkYSBhIGxhIGl0ZXJhY2nDsyBwb3N0ZXJpb3IuPC9kaXY+XCIsXG5cdFx0dHJlbmRUb1JHQk5hbWU6IFwiVGVuZMOobmNpYSBhIFJHQlwiLFxuXHRcdHRyZW5kVG9SR0JTbmlwOiBcIkNvbnZlcnRlaXggdW4gcsOgc3RlciBkZSB0ZW5kw6huY2lhIGVuIHVuIHLDoHN0ZXIgZGUgdHJlcyBiYW5kZXMgKHZlcm1lbGwsIHZlcmQgaSBibGF1KS5cIixcblx0XHR0cmVuZFRvUkdCRGVzYzogXCJMYSBmdW5jacOzIFRlbmTDqG5jaWEgYSBSR0IgY29udmVydGVpeCB1biByw6BzdGVyIGRlIHRlbmTDqG5jaWEgZW4gdW4gcsOgc3RlciBkZSB0cmVzIGJhbmRlcyAodmVybWVsbCwgdmVyZCBpIGJsYXUpLiBFbCByw6BzdGVyIGRlIHRlbmTDqG5jaWEgZXMgZ2VuZXJhIGEgcGFydGlyIGRlIGxhIGZ1bmNpw7MgZGUgcsOgc3RlciBHZW5lcmEgbGEgdGVuZMOobmNpYSBvIGxhIGZ1bmNpw7MgZGUgcsOgc3RlciBBbsOgbGlzaSBkZSBDQ0RDLjxkaXY+PGJyLz5BcXVlc3RhIGZ1bmNpw7Mgw6lzIMO6dGlsIHBlciB2aXN1YWxpdHphciBkYWRlcyBkZSBjb2VmaWNpZW50IGRlbCBtb2RlbCBhIHBhcnRpciBkZSBsYSBmdW5jacOzIEdlbmVyYSBsYSB0ZW5kw6huY2lhIG8gbGEgZnVuY2nDsyBBbsOgbGlzaSBkZSBDQ0RDLiBUb3RlcyBkdWVzIGZ1bmNpb25zIGVzdGltZW4gdGVuZMOobmNpZXMgZW4gdmFsb3JzIGRlIHDDrXhlbCBjYW52aWFudHMsIHBlcsOyIGVscyByZXN1bHRhdHMgZGUgbGVzIGZ1bmNpb25zIHPDs24gZGlmw61jaWxzIGQnaW50ZXJwcmV0YXIgZGlyZWN0YW1lbnQuPGRpdj48YnIvPkNvbSBlbiBlbCBjYXMgZGUgbW9sdGVzIGZ1bmNpb25zIGRlIHLDoHN0ZXIsIMOpcyBwb3NzaWJsZSBxdWUgaMOgZ2l1IGQndXRpbGl0emFyIGwnYWp1c3QgZGUgbWFyZ2UgZGluw6BtaWMgKERSQSkgcGVyIG1vc3RyYXIgbWlsbG9yIGVscyByZXN1bHRhdHMgZCdhcXVlc3RhIGZ1bmNpw7MuPC9kaXY+XCIsXG5cdFx0bGFuZFRyZW5kck5hbWU6IFwiQW7DoGxpc2kgTGFuZFRyZW5kclwiLFxuXHRcdGxhbmRUcmVuZHJTbmlwOiBcIkF2YWx1YSBjYW52aXMgZW4gdmFsb3JzIGRlIHDDrXhlbHMgYWwgbGxhcmcgZGVsIHRlbXBzIHV0aWxpdHphbnQgbGEgZGV0ZWNjacOzIGJhc2FkYSBlbiBMYW5kc2F0IGRlIHRlbmTDqG5jaWVzIGVuIGVsIG3DqHRvZGUgZGUgcGVydG9yYmFjacOzIGkgcmVjdXBlcmFjacOzIChMYW5kVHJlbmRyKSBpIGdlbmVyYSB1biByw6BzdGVyIGTigJlhbsOgbGlzaSBkZSBjYW52aXMgYW1iIGVscyByZXN1bHRhdHMgZGVsIG1vZGVsLlwiLFxuXHRcdGxhbmRUcmVuZHJEZXNjOiBcIkFxdWVzdGEgZnVuY2nDsyBkZSByw6BzdGVyIG5vbcOpcyBwb3QgZXMgdXRpbGl0emFyIGNvbSBhIGVudHJhZGEgYSBsYSBmdW5jacOzIGRlIHLDoHN0ZXIgZGUgRGV0ZWN0YSBjYW52aSBhbWIgYW7DoGxpc2kgZGUgY2FudmkuIFBlciBnZW5lcmFyIHVuIHJlc3VsdGF0IGRlIHLDoHN0ZXIsIGNvbm5lY3RldSBsYSBmdW5jacOzIEFuw6BsaXNpIGRlIExhbmRUcmVuZHIgYSBsYSBmdW5jacOzIERldGVjdGEgY2FudmkgYW1iIGFuw6BsaXNpIGRlIGNhbnZpIGVuIHVuYSBwbGFudGlsbGEgZGUgZnVuY2lvbnMgZGUgcsOgc3RlciwgaSB1dGlsaXR6ZXUgbGEgcGxhbnRpbGxhIGNvbSBhIGVudHJhZGEgZW4gbOKAmWVpbmEgZGUgZ2VvcHJvY2Vzc2FtZW50IEdlbmVyYSByw6BzdGVyIGEgcGFydGlyIGRlIGxhIGZ1bmNpw7MgZGUgcsOgc3Rlci4gRWwgcmVzdWx0YXQgZXMgdW4gcsOgc3RlciBxdWUgY29udMOpIGluZm9ybWFjacOzIHJlc3BlY3RlIGFsIG1vbWVudCBlbiBxdcOoIGhhbiBjYW52aWF0IGVsIHZhbG9ycyBkZWxzIHDDrXhlbHMuPGRpdj48YnI+TGEgZmluYWxpdGF0IGTigJlhcXVlc3RhIGZ1bmNpw7MgZGUgcsOgc3RlciDDqXMgZXh0cmV1cmUgY2FudmlzIGVuIHVuYSBjYXJhY3RlcsOtc3RpY2Egb2JzZXJ2YWRhLCBkZSBmb3JtYSBxdWUgbGVzIGltYXRnZXMgbXVsdGlkaW1lbnNpb25hbHMgZOKAmWVudHJhZGEgaWTDsm5pZXMgaGF1cmllbiBkZSBjYXB0dXJhciB1bmEgb2JzZXJ2YWNpw7MgY29oZXJlbnQgYWwgbGxhcmcgZGVsIHRlbXBzIGkgbm8gaGF1cmllbiBk4oCZaW5jbG91cmUgaW50ZXJmZXLDqG5jaWVzIGF0bW9zZsOocmlxdWVzLCBuw7p2b2xzIG8gbOKAmW9tYnJhIGRlbHMgbsO6dm9scy4gTGEgbWlsbG9yIHByw6BjdGljYSDDqXMgdXRpbGl0emFyIGRhZGVzIHF1ZSBoYWdpbiBlc3RhdCBub3JtYWxpdHphZGVzIGkgcHVndWluIHNlciBlbW1hc2NhcmFkZXMgZmVudCBzZXJ2aXIgdW5hIGJhbmRhIFFBLCBwZXIgZXhlbXBsZSwgcHJvZHVjdGVzIExhbmRzYXQgQ29sbGVjdGlvbiAxIFN1cmZhY2UgUmVmbGVjdGFuY2UgYW1iIHVuYSBtw6BzY2FyYSBkZSBuw7p2b2xzLjxkaXY+PGJyPkxhIGZ1bmNpw7MgZXhlY3V0YSB1bmEgYW7DoGxpc2kgc29icmUgdW5hIGltYXRnZSBwZXIgYW55LCBpIGVsIG5vbWJyZSBkZSBwYXJ0aWNpb25zIGFudWFscyBoYSBkZSBzZXIgaWd1YWwgbyBtw6lzIGdyYW4gcXVlIGVsIHZhbG9yIGVzcGVjaWZpY2F0IGVuIGVsIHBhcsOgbWV0cmUgPHN0cm9uZz5NaW5pbXVtIE51bWJlciBvZiBPYnNlcnZhdGlvbnM8L3N0cm9uZz4uIMOJcyByZWNvbWFuYWJsZSB0ZW5pciwgY29tIGEgbcOtbmltLCBzaXMgYW55cyBkZSBkYWRlcy48ZGl2Pjxicj5TaSB0ZW5pdSBkYWRlcyBtZW5zdWFscywgc2V0bWFuYWxzIG8gZGnDoHJpZXMsIMOpcyByZWNvbWFuYWJsZSBzZWxlY2Npb25hciBkaXZlcnNlcyBpbWF0Z2VzIGRlIGNhZGEgYW55IChwcmVmZXJlbnRtZW50IGRlIGxhIG1hdGVpeGEgZXN0YWNpw7MgZGUgbOKAmWFueSksIGVsaW1pbmV1IGVscyBuw7p2b2xzIGkgbOKAmW9tYnJhIGRlbHMgbsO6dm9scywgaSB1bml1IGxlcyBpbWF0Z2VzIHBlciBnZW5lcmFyIHVuYSDDum5pY2EgaW1hdGdlIHF1ZSBjYXB0dXJpIGLDqSBs4oCZb2JzZXJ2YWNpw7MuIFNpIGVzIGZhY2lsaXRlbiBkYWRlcyBtZW5zdWFscywgc2V0bWFuYWxzIG8gZGnDoHJpZXMgY29tIGEgcsOgc3RlciBtdWx0aWRpbWVuc2lvbmFsIGTigJllbnRyYWRhLCBsYSBmdW5jacOzIGlkZW50aWZpY2Fyw6AgdW5hIHBhcnRpY2nDsyBwZXIgYSBs4oCZYW7DoGxpc2kgYmFzYWRhIGVuIGxhIGRhdGEgbcOpcyBwcm9wZXJhIGEgbGEgcHJvcG9yY2lvbmFkYSBlbiBlbCBwYXLDoG1ldHJlIDxzdHJvbmc+U25hcHBpbmcgRGF0ZTwvc3Ryb25nPi48ZGl2Pjxicj5VbmEgY2FyYWN0ZXLDrXN0aWNhIGVuIHVuIHBhaXNhdGdlIHNvdmludCB0cmlnYXLDoCB0ZW1wcyBhIHJlY3VwZXJhci1zZSBk4oCZdW4gY2Fudmkgbm8gcGVybWFuZW50IGNvbSBwb3Qgc2VyIHVuIGluY2VuZGkgZm9yZXN0YWwgbyB1biBwbGFnYSBk4oCZaW5zZWN0ZXMuIFBlciBjb250cm9sYXIgbOKAmcOtbmRleCBkZSByZWN1cGVyYWNpw7MgcmVjb25lZ3V0IHBlbCBtb2RlbCwgZXN0YWJsaXUgZWwgcGFyw6BtZXRyZSBMw61taXQgZGUgcmVjdXBlcmFjacOzLiBVbiBzZWdtZW50IHNpbmd1bGFyIG5vIHBvdCB0ZW5pciB1biDDrW5kZXggZGUgcmVjdXBlcmFjacOzIG3DqXMgcsOgcGlkIHF1ZSAxIC8gbMOtbWl0IGRlIHJlY3VwZXJhY2nDsy48ZGl2Pjxicj5FbiB1biBwYWlzYXRnZSwgbGEgcmVjdXBlcmFjacOzIGTigJl1biBjYW52aSBlcyBwb3QgZG9uYXIgZGUgbWFuZXJhIHBvc2l0aXZhIG8gbmVnYXRpdmEuIFBlciBleGVtcGxlLCBxdWFuIHVuIHBhaXNhdGdlIGV4cGVyaW1lbnRhIHVuIHDDqHJkdWEgZGUgYm9zY29zLCB1bmEgc8OocmllIHRlbXBvcmFsIGRlIHZhbG9ycyBk4oCZw61uZGV4IGRlIHZlZ2V0YWNpw7MgbW9zdHJhIHVuYSBjYWlndWRhIGVuIGVscyB2YWxvcnMgZOKAmcOtbmRleCwgaSBsYSByZWN1cGVyYWNpw7MgbW9zdHJhIHVuIGluY3JlbWVudCBncmFkdWFsIGVuIHZhbG9ycyBk4oCZw61uZGV4IGRlIHZlZ2V0YWNpw7MsIG8gdW5hIHRlbmTDqG5jaWEgZGUgcmVjdXBlcmFjacOzIHBvc2l0aXZhLiBFc3BlY2lmaXF1ZXUgbGEgZGlyZWNjacOzIGRlIGxhIHRlbmTDqG5jaWEgZGUgcmVjdXBlcmFjacOzIGFtYiBlbCBwYXLDoG1ldHJlIDxzdHJvbmc+UmVjb3ZlcnkgSGFzIEluY3JlYXNpbmcgVHJlbmQ8L3N0cm9uZz4uXCIsXG5cdFx0YWdncmVnYXRlTXVsdGlkaW1lbnNpb25hbE5hbWU6IFwiTXVsdGlkaW1lbnNpb25hbCBhZ3JlZ2F0XCIsXG5cdFx0YWdncmVnYXRlTXVsdGlkaW1lbnNpb25hbFNuaXA6IFwiQ29tYmluYSBkYWRlcyBkZSB2YXJpYWJsZXMgZGUgcsOgc3RlciBtdWx0aWRpbWVuc2lvbmFsIGphIGV4aXN0ZW50cyBqdW50YW1lbnQgYW1iIHVuYSBkaW1lbnNpw7MuXCIsXG5cdFx0YWdncmVnYXRlTXVsdGlkaW1lbnNpb25hbERlc2M6IFwiTGEgZnVuY2nDsyBBZ3JlZ2EgbXVsdGlkaW1lbnNpb25hbCBjcmVhIHVuYSBjYXBhIGRlIHLDoHN0ZXJzIG11bHRpZGltZW5zaW9uYWxzIGNvbWJpbmFudCBkYWRlcyBkZSB2YXJpYWJsZXMgZGUgcsOgc3RlcnMgbXVsdGlkaW1lbnNpb25hbHMgYW1iIHVuYSBkaW1lbnNpw7MuPGRpdj48YnI+VXRpbGl0emV1IGVsIHBhcsOgbWV0cmXCoDxzdHJvbmc+RGVmaW5pY2nDsyBkZSBsYSBkaW1lbnNpw7M8L3N0cm9uZz4gcGVyIGZpbHRyYXIgcHJpbWVyIGxlcyBkYWRlcyBk4oCZZW50cmFkYSBxdWUgdm9sZXUgYWdyZWdhci4gUGVyIGV4ZW1wbGUsIHNpIHRlbml1IDMwIGFueXMgZGUgZGFkZXMgbWVuc3VhbHMsIHBlcsOyIG5vbcOpcyB2b2xldSBjcmVhciB1bmEgY2FwYSBhZ3JlZ2FkYSBwZXIgYWxzIHByaW1lcnMgMTUgYW55cywgcG9kZXUgZmVyIHNlcnZpciBlbCBwYXLDoG1ldHJlwqA8c3Ryb25nPkRlZmluaWNpw7MgZGUgbGEgZGltZW5zacOzPC9zdHJvbmc+IHBlciBlc3BlY2lmaWNhciBlbHMgYW55cyBxdWUgc+KAmWhhbiBk4oCZaW5jbG91cmUgYSBs4oCZYW7DoGxpc2kuPGRpdj48YnI+PHVsPjxsaT5FeHRyZXVyZSBkYWRlcyBkZSBzYWxpbml0YXQgcGVyIGFsIG1lcyBkZSBnZW5lciBhbCBsbGFyZyBk4oCZdW4gcGVyw61vZGUgZGUgMTAgYW55cy4gVHJpZXUgPHN0cm9uZz5QZXIgdmFsb3JzPC9zdHJvbmc+LCBkZWZpbml1IDxzdHJvbmc+RGltZW5zacOzPC9zdHJvbmc+wqBhbWIgZWwgdmFsb3IgPHN0cm9uZz5TdGRUaW1lPC9zdHJvbmc+IGkgPHN0cm9uZz5WYWxvcnM8L3N0cm9uZz7CoGFtYiBlbCB2YWxvciA8c3Ryb25nPkdlbmVyPC9zdHJvbmc+LjwvbGk+PGxpPkZyYWdtZW50IGRlIGRhZGVzIGRlIHNhbGluaXRhdCBhbWIgdW4gaW50ZXJ2YWwgZGUgcHJvZnVuZGl0YXQgZGUgMCBhIDE1IG1ldHJlcy4gVHJpZXUgPHN0cm9uZz5QZXIgcmFuZ3M8L3N0cm9uZz4sIGVzdGFibGl1IDxzdHJvbmc+RGltZW5zacOzPC9zdHJvbmc+wqBhbWIgZWwgdmFsb3LCoDxzdHJvbmc+U3RkWjwvc3Ryb25nPiwgPHN0cm9uZz5WYWxvciBtw61uaW08L3N0cm9uZz7CoGFtYiBlbCB2YWxvciA8c3Ryb25nPi0xNTA8L3N0cm9uZz7CoGkgPHN0cm9uZz5WYWxvciBtw6B4aW08L3N0cm9uZz7CoGFtYiBlbCB2YWxvciA8c3Ryb25nPjA8L3N0cm9uZz4uPC9saT48bGk+RXh0cmV1cmUgZGFkZXMgZGUgc2FsaW5pdGF0IHBlciBhbHMgcHJpbWVycyAxMCBkaWVzIGRlIGNhZGEgbWVzIGRlIGdlbmVyIGR1cmFudCB1biBwZXLDrW9kZSBkZSAxMCBhbnlzLiBUcmlldSA8c3Ryb25nPlBlciBpdGVyYWNpw7M8L3N0cm9uZz4sIGRlZmluaXUgPHN0cm9uZz5EaW1lbnNpw7M8L3N0cm9uZz7CoGFtYiBlbCB2YWxvcsKgPHN0cm9uZz5TdGRUaW1lPC9zdHJvbmc+LCA8c3Ryb25nPkluaWNpIGRlIGxhIHByaW1lcmEgaXRlcmFjacOzPC9zdHJvbmc+wqBpIDxzdHJvbmc+RmluYWwgZGUgbGEgcHJpbWVyYSBpdGVyYWNpw7M8L3N0cm9uZz7CoGFtYiBsJ2luaWNpIGkgZmluYWwgY29ycmVzcG9uZW50cyBkZWwgcGVyw61vZGUgZCdpdGVyYWNpw7MsIDxzdHJvbmc+UGFzPC9zdHJvbmc+wqBhbWIgZWwgdmFsb3IgPHN0cm9uZz4xPC9zdHJvbmc+IGkgPHN0cm9uZz5Vbml0YXQ8L3N0cm9uZz7CoGFtYiBlbCB2YWxvciA8c3Ryb25nPkFueXM8L3N0cm9uZz4uPC9saT48L3VsPjxkaXY+PGJyPlV0aWxpdHpldSBlbHMgcGFyw6BtZXRyZXMgPHN0cm9uZz5EZWZpbmljacOzIGRlIGwnYWdyZWdhY2nDszwvc3Ryb25nPsKgcGVyIHRyaWFyIGxhIGRpbWVuc2nDsyBxdWUgY2FsIGF2YWx1YXIgaSBsJ2ludGVydmFsIGQnYWdyZWdhY2nDsyBtaXRqYW7Dp2FudCB1bmEgcGFyYXVsYSBjbGF1LCB1biB2YWxvciBvIHVuIGludGVydmFsIGRlIHZhbG9ycy4gUGVyIGV4ZW1wbGUsIHNpIHRlbml1IDMwIGFueXMgZGUgZGFkZXMgZGUgdGVtcGVyYXR1cmEgZGVsIG1hciwgcmVjb3BpbGFkZXMgZGnDoHJpYW1lbnQgaSBhIGNhZGEgNSBtZXRyZXMgZGUgcHJvZnVuZGl0YXQgZmlucyBhbHMgMTAwIG1ldHJlcywgcG9kZXUgdXRpbGl0emFyIGxlcyBkaWZlcmVudHMgb3BjaW9ucyBk4oCZaW50ZXJ2YWxzIHBlciBhbHMgc2Vnw7xlbnRzIGVzY2VuYXJpczo8ZGl2Pjxicj48dWw+PGxpPkFncmVnYSBkYWRlcyBkZSB0ZW1wZXJhdHVyYSBkacOgcmlhIGEgbGVzIGRhZGVzIG1lbnN1YWxzLCBvbiBlbCByZXN1bHRhdCDDqXMgdW4gcsOgc3RlciBtdWx0aWRpbWVuc2lvbmFsIGFtYiAxMiBwYXJ0aWNpb25zIGRlIHRlbXBzLCBpIGNhZGEgcGFydGljacOzIMOpcyBs4oCZYWdyZWdhdCBkZSBjYWRhIG1lcyBhbCBsbGFyZyBkZSB0b3RzIGVscyBhbnlzLiBUcmlldSA8c3Ryb25nPlBhcmF1bGEgY2xhdSBkJ2ludGVydmFsPC9zdHJvbmc+IGkgZXN0YWJsaXUgbGEgcGFyYXVsYSBjbGF1IGHCoDxzdHJvbmc+QW1iIHJlY3VycsOobmNpYSBtZW5zdWFsPC9zdHJvbmc+LjwvbGk+PGxpPkFmZWdpdSBkYWRlcyBkZSB0ZW1wZXJhdHVyYSBkacOgcmlhIGVuIGRhZGVzIG1lbnN1YWxzLCBvbiBlbCByZXN1bHRhdCDDqXMgdW4gcsOgc3RlciBtdWx0aWRpbWVuc2lvbmFsIGFtYiAzNjAgcGFydGljaW9ucywgbyAxMiBwYXJ0aWNpb25zIGRlIHRlbXBzIHBlciBhbnkgKDMwIGFueXMgNSDDlyAxMiBtZXNvcyA9IDM2MCBwYXJ0aWNpb25zKS4gVHJpZXUgPHN0cm9uZz5QYXJhdWxhIGNsYXUgZGUgbCdpbnRlcnZhbDwvc3Ryb25nPsKgaSBkZWZpbml1IGxhIHBhcmF1bGEgY2xhdSA8c3Ryb25nPk1lbnN1YWxtZW50PC9zdHJvbmc+LjwvbGk+PGxpPkFmZWdpdSBkYWRlcyBkZSB0ZW1wZXJhdHVyYSBtZW5zdWFscyBlbiBpbnRlcnZhbHMgZGUgNCBtZXNvcy4gVHJpZXUgPHN0cm9uZz5WYWxvciBkZSBsJ2ludGVydmFsPC9zdHJvbmc+LCBkZWZpbml1IDxzdHJvbmc+SW50ZXJ2YWwgZGUgdmFsb3JzPC9zdHJvbmc+wqBlbiA0LCBpIGRlZmluaXUgPHN0cm9uZz5Vbml0YXQ8L3N0cm9uZz7CoGVuIDxzdHJvbmc+TWVzb3M8L3N0cm9uZz4uPC9saT48bGk+QWZlZ2l1IGxlcyBkYWRlcyBkZSB0ZW1wZXJhdHVyYSBkZSAwIGEgMjUgbWV0cmVzLCBkZXNwcsOpcyBkZSAyNSBhIDUwIG1ldHJlcyBpIGRlc3Byw6lzIGRlIDUwIGEgMTAwIG1ldHJlcy4gVHJpZXUgPHN0cm9uZz5SYW5ncyBkZSBsJ2ludGVydmFsPC9zdHJvbmc+wqBpIGVzcGVjaWZpcXVldSBsZXMgcHJvZnVuZGl0YXRzIG3DrW5pbWEgaSBtw6B4aW1hIGNvbSBhIDxzdHJvbmc+MCAyNTsgMjUgNTA7IDUwIDEwMDwvc3Ryb25nPi48L2xpPjwvdWw+XCIsXG5cdFx0bWVyZ2VSYXN0ZXJzTmFtZTogXCJGdXNpb25hciByw6BzdGVyc1wiLFxuXHRcdG1lcmdlUmFzdGVyc1NuaXA6IFwiQ29tYmluYSBtw7psdGlwbGVzIGNvbmp1bnRzIGRlIGRhZGVzIGRlIHLDoHN0ZXJzIGVzcGFjaWFsbWVudCwgbyBlbnRyZSB2YXJpYWJsZXMgaSBkaW1lbnNpb25zLlwiLFxuXHRcdG1lcmdlUmFzdGVyc0Rlc2M6IFwiQXF1ZXN0YSBmdW5jacOzIGNyZWEgdW4gcsOgc3RlciBmdXNpb25hdCBhIHBhcnRpciBk4oCZdW5hIGxsaXN0YSBkZSByw6BzdGVycy4gUGVyIGV4ZW1wbGUsIHNpIHRlbml1IHVuIGNvbmp1bnQgZGUgZGFkZXMgZGUgbW9zYWljIHF1ZSBjb250w6kgMzAgYW55cyBkZSBkYWRlcyBkZSBwcmVjaXBpdGFjacOzIG1lbnN1YWwgaSB1biBhbHRyZSBjb25qdW50IGRlIGRhZGVzIGFtYiAxMCBhbnlzIGRlIGRhZGVzIGRlIHRlbXBlcmF0dXJlcyBtZW5zdWFscywgcG9kZXUgY29tYmluYXItbGVzIGVuIHVuIHLDoHN0ZXIgbXVsdGlkaW1lbnNpb25hbCBhbWIgYW1iZHVlcyB2YXJpYWJsZXMuIDxkaXY+PGJyPlNpIGVscyByw6BzdGVycyBtdWx0aWRpbWVuc2lvbmFscyBk4oCZZW50cmFkYSBjb250ZW5lbiBkaWZlcmVudCB2YXJpYWJsZXMsIGVsIHLDoHN0ZXIgbXVsdGlkaW1lbnNpb25hbCBkZSBzb3J0aWRhIGluY2xvdXLDoCB0b3RlcyBsZXMgdmFyaWFibGVzLiA8ZGl2Pjxicj5TaSBlbHMgcsOgc3RlcnMgbXVsdGlkaW1lbnNpb25hbHMgZOKAmWVudHJhZGEgY29udGVuZW4gZGlmZXJlbnRzIGRpbWVuc2lvbnMgbyB2YWxvcnMgZGUgZGltZW5zaW9ucywgZWwgcsOgc3RlciBtdWx0aWRpbWVuc2lvbmFsIGRlIHNvcnRpZGEgaW5jbG91csOgIHRvdGVzIGxlcyBkaW1lbnNpb25zIGkgdmFsb3JzIGRlIGRpbWVuc2lvbnMuIDxkaXY+PGJyPlNpIGVscyByw6BzdGVycyBtdWx0aWRpbWVuc2lvbmFscyBk4oCZZW50cmFkYSBjb250ZW5lbiBsZXMgbWF0ZWl4ZXMgZGltZW5zaW9ucyBpIHZhcmlhYmxlcyBwZXLDsiBkaWZlcmVudHMgZXh0ZW5zaW9ucyBlc3BhY2lhbHMsIGVsIHLDoHN0ZXIgbXVsdGlkaW1lbnNpb25hbCBkZSBzb3J0aWRhIGluY2xvdXLDoCBsZXMgdmFyaWFibGVzIGkgZGltZW5zaW9ucyBk4oCZZW50cmUgbGVzIGV4dGVuc2lvbnMgZXNwYWNpYWxzIGZ1c2lvbmFkZXMuPGRpdj48YnI+QXF1ZXN0YSBmdW5jacOzIHRhbWLDqSBlcyBwb3QgdXRpbGl0emFyIHF1YW4gdGVuaXUgbcO6bHRpcGxlcyByw6BzdGVycyBxdWUgdm9sZXUgdHJhY3RhciBjb20gYSB1biBlbGVtZW50IMO6bmljLCBjb20gYXJhIGNhbGN1bGFudCBsZXMgbWF0ZWl4ZXMgZXN0YWTDrXN0aXF1ZXMgcGVyIGEgdG90cywgbyBxdWFuIGVzIGZhIGVxdWlsaWJyaSBkZSBjb2xvciwgZGUgbWFuZXJhIHF1ZSBubyBuZWNlc3NpdGV1IGZlciBlcXVpbGlicmkgZGUgY29sb3Igc2VwYXJhZGFtZW50IHBlciBhIGNhZGEgaW1hdGdlLiBBaXjDsiByZXN1bHRhIGTigJl1dGlsaXRhdCBxdWFuIGVzIHRyZWJhbGxhIGFtYiBpbWF0Z2VzIGVtbWFnYXR6ZW1hZGVzIGNvbSBhIGxsb3NlcyBzZXBhcmFkZXMgZGVndXQgYSBsaW1pdGFjaW9ucyBlbiBsYSBtaWRhIGRlbHMgYXJ4aXVzOyBk4oCZYXF1ZXN0YSBtYW5lcmEgZXMgdHJhY3RhcsOgIGxlcyBsbG9zZXMgY29tIGEgcGFydCBkZSBsYSBtYXRlaXhhIGltYXRnZS5cIixcblx0XHRib3VuZGFyeUNsZWFuTmFtZTogXCJSZWZpbmFtZW50IGRlIGzDrW1pdHNcIixcblx0XHRib3VuZGFyeUNsZWFuU25pcDogXCJTdWF2aXR6YSBlbHMgbMOtbWl0cyBlbnRyZSB6b25lcy5cIixcblx0XHRib3VuZGFyeUNsZWFuRGVzYzogXCI8cD5BcXVlc3RhIGZ1bmNpw7MgZ2VuZXJhbGl0emEgbyBzaW1wbGlmaWNhIGVscyByw6BzdGVycyBzdWF2aXR6YW50IGVscyBsw61taXRzIGVudHJlIHpvbmVzLiBBcXVlc3RhIGZ1bmNpw7MgcHJvcG9yY2lvbmEgb3BjaW9ucyBwZXIgY29udHJvbGFyIGNvbSBsZXMgY2VswrdsZXMgZGUgbGVzIHpvbmVzIGRlIGwnZW50cmFkYSBpbmZsdWVuY2llbiBsYSBzdWF2aXR6YWNpw7MgaSBsYSBxdWFudGl0YXQgZGUgc3Vhdml0emFjacOzIHF1ZSBzJ2FwbGljYXLDoC4gQ2FkYSBjZWzCt2xhIGQnZW50cmFkYSBzJ2F2YWx1YSBhIHBhcnRpciBkZWxzIHNldXMgdnVpdCB2ZcOvbnMgaW1tZWRpYXRzLjwvcD48cD5FbCBwcm9jw6lzIGRlIHN1YXZpdHphY2nDsyBwcmltZXIgb3JkZW5hIGxlcyBjZWzCt2xlcyB2ZcOvbmVzIGFtYiB1bmEgcHJpb3JpdGF0IGNvbmNyZXRhLiBMYSBwcmlvcml0YXQgZGV0ZXJtaW5hIHF1aW5hIHpvbmEgZGUgbGVzIGNlbMK3bGVzIHZlw69uZXMgcG90IHN1YnN0aXR1aXIgZWwgdmFsb3IgZGUgbGEgY2VswrdsYSBkZSBwcm9jZXNzYW1lbnQgYSBsYSBzb3J0aWRhLjwvcD48cD5MYSBwcmlvcml0YXQgZXMgcG90IGJhc2FyIGVuIGVsIHZhbG9yIGRlIGxlcyB6b25lcyBvIGVuIGxhIG1pZGEgZGUgbGVzIHpvbmVzLiBFbCBwYXLDoG1ldHJlIDxzdHJvbmc+VGlwdXMgZCdvcmRlbmFjacOzPC9zdHJvbmc+IGRldGVybWluYSBlbCB0aXB1cyBkJ29yZGVuYWNpw7MgcXVlIGVzIGZhcsOgIHNlcnZpci4gPC9wPjxwPkxhIGNvbmZpZ3VyYWNpw7MgcGVyIGRlZmVjdGUgPHN0cm9uZz5ObyBobyBvcmRlbmlzPC9zdHJvbmc+IGF2YWx1YSBsYSBwcmlvcml0YXQgZW4gZnVuY2nDsyBkZWwgdmFsb3IgZGUgbGVzIHpvbmVzLiBMZXMgY2VswrdsZXMgZGUgbGVzIHpvbmVzIGFtYiB2YWxvcnMgbcOpcyBncmFucyB0aW5kcmFuIG3DqXMgcHJpb3JpdGF0IHBlciBleHBhbmRpci1zZSBhIHpvbmVzIGFtYiB2YWxvcnMgbcOpcyBwZXRpdHMuPC9wPjxwPkxhIG1pZGEgbyBsJ8OgcmVhIHRvdGFsIGRlIGxlcyB6b25lcyBlcyBwb3QgZmVyIHNlcnZpciBwZXIgb3JkZW5hciBsYSBwcmlvcml0YXQuIEFtYiBsYSBjb25maWd1cmFjacOzIDxzdHJvbmc+RGVzY2VuZGVudDwvc3Ryb25nPiwgbGVzIHpvbmVzIHMnb3JkZW5lbiBwZXIgbWlkYSBlbiBvcmRyZSBkZXNjZW5kZW50LiBMZXMgem9uZXMgYW1iIMOgcmVlcyB0b3RhbHMgbcOpcyBncmFucyB0aW5kcmFuIHByaW9yaXRhdCBwZXIgZXhwYW5kaXItc2UgYSB6b25lcyBhbWIgw6ByZWVzIG3DqXMgcGV0aXRlcy4gQW1iIGxhIGNvbmZpZ3VyYWNpw7MgPHN0cm9uZz5Bc2NlbmRlbnQ8L3N0cm9uZz4gcGFzc2EgZWwgY29udHJhcmk6IGxlcyB6b25lcyBhbWIgw6ByZWVzIHRvdGFscyBtw6lzIHBldGl0ZXMgdGluZHJhbiBwcmlvcml0YXQgcGVyIGV4cGFuZGlyLXNlIGEgem9uZXMgYW1iIMOgcmVlcyB0b3RhbHMgbcOpcyBncmFucy48L3A+PHA+TGEgcXVhbnRpdGF0IGRlIHN1YXZpdHphY2nDsyBlcyBjb250cm9sYSBhbWIgZWwgcGFyw6BtZXRyZSA8c3Ryb25nPkV4ZWN1dGEgbCdleHBhbnNpw7MgaSBsYSByZWR1Y2Npw7MgZHVlcyB2ZWdhZGVzPC9zdHJvbmc+LCBxdWUgZGV0ZXJtaW5hIGVsIG5vbWJyZSBkZSB2ZWdhZGVzIHF1ZSBlcyBkdXLDoCBhIHRlcm1lIGVsIHByb2PDqXMgZCdleHBhbnNpw7MgaSByZWR1Y2Npw7MuPC9wPjxwPlNpIGFxdWVzdGEgY29uZmlndXJhY2nDsyBlc3TDoCBkZXNhY3RpdmFkYSwgZWwgcHJvY8OpcyBkJ2V4cGFuc2nDsyBpIHJlZHVjY2nDsyBub23DqXMgZXMgZHVyw6AgYSB0ZXJtZSB1bmEgdmVnYWRhLiBTaSBhcXVlc3RhIGNvbmZpZ3VyYWNpw7MgZXN0w6AgYWN0aXZhZGEsIGVsIHByb2PDqXMgZCdleHBhbnNpw7MgaSBkZSByZWR1Y2Npw7MgZXMgcmVhbGl0emFyw6AgZHVlcyB2ZWdhZGVzLCBkZSBtYW5lcmEgcXVlIGVscyBsw61taXRzIGRlIGxlcyB6b25lcyBzZSBzdWF2aXR6YXJhbiBtw6lzLjwvcD48cD5TaSBlbHMgdmFsb3JzIGRlIGxlcyB2dWl0IGNlbMK3bGVzIHZlw69uZXMgc8OzbiBpZ3VhbHMgcXVlIGVscyBkZSBsYSBjZWzCt2xhIHF1ZSBlcyBwcm9jZXNzYSwgbGEgY2VswrdsYSBkZSBzb3J0aWRhIGNvbnNlcnZhcsOgIGVsIHZhbG9yIGRlIGxhIGNlbMK3bGEgZCdlbnRyYWRhLjwvcD5cIixcblx0XHRwcmVkaWN0VXNpbmdSZWdyZXNzaW9uTmFtZTogXCJQcmVkaXUgbWl0amFuw6dhbnQgcmVncmVzc2nDs1wiLFxuXHRcdHByZWRpY3RVc2luZ1JlZ3Jlc3Npb25TbmlwOiBcIkNhbGN1bGEgdW4gcsOgc3RlciBwcmVkaXQgYmFzYXQgZW4gZW50cmFkZXMgZGUgZGFkZXMgZGUgcsOgc3RlcnMgaSB1biBtb2RlbCBkZSByZWdyZXNzacOzLiBFbCBtb2RlbCBkZSByZWdyZXNzacOzIMOpcyBsYSBwcm9kdWNjacOzIGRlIGwnZWluYSBkZSBnZW9wcm9jZXNzYW1lbnQgcsOgc3RlciA8c3Ryb25nPlRyYWluIFJhbmRvbSBUcmVlcyBSZWdyZXNzaW9uIE1vZGVsPC9zdHJvbmc+XCIsXG5cdFx0cHJlZGljdFVzaW5nUmVncmVzc2lvbkRlc2M6IFwiPHA+RWwgbW9kZWwgZGUgcmVncmVzc2nDsyBlcyBkZWZpbmVpeCBlbiB1biBmaXR4ZXIgZGUgZGVmaW5pY2nDsyBkZSByZWdyZXNzacOzIEVzcmkgKC5lY2QpLiBDb250w6kgdG90YSBsYSBpbmZvcm1hY2nDsyBwZXIgYSB1biBjb25qdW50IGRlIGRhZGVzIGVzcGVjw61maWMgbyB1biBjb25qdW50IGRlIGNvbmp1bnRzIGRlIGRhZGVzLCBhIG3DqXMgZGVsIG1vZGVsIGRlIHJlZ3Jlc3Npw7MsIGkgw6lzIGdlbmVyYXQgcGVyIDxzdHJvbmc+PC9zdHJvbmc+bCdlaW5hIGRlIGdlb3Byb2Nlc3NhbWVudCByw6BzdGVyIDwvcD5UcmFpbiBSYW5kb20gVHJlZXMgUmVncmVzc2lvbiBNb2RlbC48cD4gTCdlbnRyYWRhIHBvdCBzZXIgdW5hIHNvbGEgYmFuZGEsIHVuYSBtdWx0aWJhbmRhIG8gdW4gcsOgc3RlciBtdWx0aWRpbWVuc2lvbmFsIG8gdW5hIGxsaXN0YSBkJ2FxdWVzdHMgdGlwdXMuIEVscyB0aXB1cyBkZSByw6BzdGVycyBk4oCZZW50cmFkYSBoYW4gZGUgc2VyIGVsIG1hdGVpeG9zIHF1ZSBlbHMgZW50cmVuYXRzIHBlbCBtb2RlbCBkZSByZWdyZXNzacOzLjwvcD48dWw+PGxpPlF1YW4gbOKAmWVudHJhZGEgw6lzIHVuIHLDoHN0ZXIgbXVsdGliYW5kYSwgY2FkYSBiYW5kYSBlcyB0cmFjdGEgY29tIHVuYSB2YXJpYWJsZSBwcmVkaWN0b3JhLiBMZXMgYmFuZGVzIGhhbiBkJ2VzdGFyIGVuIGVsIG1hdGVpeCBvcmRyZSBxdWUgbCdlbnRyYWRhIG11bHRpYmFuZGEgcGVyIGEgbCdlaW5hIGQnZW50cmVuYW1lbnQgZGVsIG1vZGVsIGRlIHJlZ3Jlc3Npw7MuPC9saT48bGk+UXVhbiBs4oCZZW50cmFkYSDDqXMgdW4gcsOgc3RlciBtdWx0aWRpbWVuc2lvbmFsLCBjYWRhIHZhcmlhYmxlIGVzIHRyYWN0YSBjb20gdW5hIHZhcmlhYmxlIHByZWRpY3RvcmEgaSBsYSB2YXJpYWJsZSBoYSBkZSBzZXIgZGUgYmFuZGEgw7puaWNhIGkgdGVuaXIgdW5hIGRpbWVuc2nDsyBkZSB0ZW1wcy4gTCdvcmRyZSBpIGVscyBub21zIGRlIGxlcyB2YXJpYWJsZXMgaGFuIGRlIHNlciBlbHMgbWF0ZWl4b3MgcXVlIGVscyBkJ2VudHJhZGEgcXVhbiBlcyB2YSBlbnRyZW5hciBlbCBtb2RlbCBkZSByZWdyZXNzacOzLiBMYSBzb3J0aWRhIMOpcyB1biByw6BzdGVyIG11bHRpZGltZW5zaW9uYWwuPC9saT48bGk+TCdlbnRyYWRhIHBvdCBzZXIgdW5hIGxsaXN0YSBkJ2VsZW1lbnRzLiBFbCBub21icmUgaSBsJ29yZHJlIGRlbHMgw610ZW1zIGhhbiBkZSBjb2luY2lkaXIgYW1iIGwnZW50cmFkYSBxdWFuIGVzIHZhIGVudHJlbmFyIGVsIG1vZGVsIGRlIHJlZ3Jlc3Npw7MuPC9saT48L3VsPlwiLFxuXHRcdGRpbWVuc2lvbmFsTW92aW5nU3RhdGlzdGljc05hbWU6IFwiRXN0YWTDrXN0aXF1ZXMgbcOyYmlscyBkaW1lbnNpb25hbHNcIixcblx0XHRkaW1lbnNpb25hbE1vdmluZ1N0YXRpc3RpY3NTbmlwOiBcIkNhbGN1bGEgbGVzIGVzdGFkw61zdGlxdWVzIGVuIHVuYSBmaW5lc3RyYSBtw7JiaWwgc29icmUgZGFkZXMgbXVsdGlkaW1lbnNpb25hbHMgZW4gdW5hIGRpbWVuc2nDsyBlc3BlY2lmaWNhZGEuXCIsXG5cdFx0ZGltZW5zaW9uYWxNb3ZpbmdTdGF0aXN0aWNzRGVzYzogXCI8cD5MYSBmdW5jacOzIEVzdGFkw61zdGlxdWVzIG3DsmJpbHMgZGltZW5zaW9uYWxzIGNhbGN1bGEgZGl2ZXJzZXMgZXN0YWTDrXN0aXF1ZXMgZW4gdW5hIGZpbmVzdHJhIHByZWRlZmluaWRhIHBlciBhIHRvdHMgZWxzIHZhbG9ycyBkJ3VuYSBkaW1lbnNpw7MuIEFxdWVzdGEgZnVuY2nDsyBhZ2FmYSB1bmEgY2FwYSByw6BzdGVyIG11bHRpZGltZW5zaW9uYWwgY29tIGEgZW50cmFkYSBpIGNyZWEgdW5hIGNhcGEgcsOgc3RlciBtdWx0aWRpbWVuc2lvbmFsIGNvbSBhIHNvcnRpZGEgcXVlIHTDqSBsYSBtYXRlaXhhIG1pZGEgZGltZW5zaW9uYWwgcXVlIGxhIGNhcGEgZCdlbnRyYWRhLjwvcD48cD5Qb2RldSBlc3BlY2lmaWNhciB1bmEgZGltZW5zacOzIGVscyB2YWxvcnMgZGUgbGEgcXVhbCBlcyB0aW5kcmFuIGVuIGNvbXB0ZSBkdXJhbnQgZWwgY8OgbGN1bC4gUGVyIGRlZmVjdGUsIGVsIGPDoGxjdWwgZXMgZmEgYSBwYXJ0aXIgZGUgbGEgcHJpbWVyYSBkaW1lbnNpw7Mgbm8gZXNwYWNpYWwuIFRhbWLDqSBwb2RldSBlc3BlY2lmaWNhciB1bmEgbWlkYSBkZSBmaW5lc3RyYSBhbWIgZWxzIHBhcsOgbWV0cmVzIEZpbmVzdHJhIEVucmVyZSBpIEZpbmVzdHJhIEVuZGF2YW50LjwvcD48cD5RdWFuIFRpcHVzIGQnZXN0YWTDrXN0aWNhIHMnZXN0YWJsZWl4IGVuIFBlcmNlbnRpbCwgZWxzIHBhcsOgbWV0cmVzIFZhbG9yIGRlIHBlcmNlbnRpbCBpIFRpcHVzIGQnaW50ZXJwb2xhY2nDsyBkZWwgcGVyY2VudGlsIGVzdGFuIGRpc3BvbmlibGVzLiBQb2RldSBmZXIgc2VydmlyIGFxdWVzdHMgcGFyw6BtZXRyZXMgcGVyIGVzcGVjaWZpY2FyIGVsIHBlcmNlbnRpbCBxdWUgdm9sZXUgY2FsY3VsYXIgaSB0cmlhciBlbCB0aXB1cyBkJ2ludGVycG9sYWNpw7MgcXVlIHZvbGV1IGZlciBzZXJ2aXIsIHJlc3BlY3RpdmFtZW50LiBRdWFuIGVsIHRpcHVzIGQnZXN0YWTDrXN0aXF1ZXMgcydlc3RhYmxlaXggZW4gTWl0amFuYSBjaXJjdWxhciwgZWwgcGFyw6BtZXRyZSBWYWxvciBkJ2FqdXN0IGNpcmN1bGFyIGVzdMOgIGRpc3BvbmlibGUuIEVsIHZhbG9yIGQnYWp1c3QgY2lyY3VsYXIgcyd1dGlsaXR6YSBwZXIgY29udmVydGlyIHVuIHZhbG9yIGxpbmVhbCBlbiBsJ2ludGVydmFsIGQndW5hIG1pdGphbmEgY2lyY3VsYXIgZGV0ZXJtaW5hZGEuPC9wPlwiLFxuXHRcdHRlcnJhaW5GbGF0dGVuRnVuY3Rpb25OYW1lOiBcIkFwbGFuYSB1biB0ZXJyZW55XCIsXG5cdFx0dGVycmFpbkZsYXR0ZW5GdW5jdGlvblNuaXA6IFwiQ29ycmVnZWl4IGxlcyBkYWRlcyBkJ2VudHJhZGEgZGVsIHJhZGFyIGQnb2JlcnR1cmEgc2ludMOodGljYSAoU0FSKSBwZXIgYSBsZXMgZGlzdG9yc2lvbnMgcmFkaW9tw6h0cmlxdWVzIHBlciBjYXVzYSBkZSBsYSB0b3BvZ3JhZmlhLlwiLFxuXHRcdHRlcnJhaW5GbGF0dGVuRnVuY3Rpb25EZXNjOiBcIjxwPkxhIGZ1bmNpw7MgZGUgcsOgc3RlciBBcGxhbmEgZWwgdGVycmVueSBjb3JyZWdlaXggbGVzIGRhZGVzIGQnZW50cmFkYSBkZWwgcmFkYXIgZCdvYmVydHVyYSBzaW50w6h0aWNhIChTQVIpIHBlciBhIGxlcyBkaXN0b3JzaW9ucyByYWRpb23DqHRyaXF1ZXMgcGVyIGNhdXNhIGRlIGxhIHRvcG9ncmFmaWEuPC9wPjxwPkVuIHByaW1lciBsbG9jIGNhbCBjYWxpYnJhciBsZXMgZGFkZXMgZCdlbnRyYWRhIGRlbCByYWRhciBlbiBiZXRhIHplcm8uIFV0aWxpdHpldSBsJ2VpbmEgQXBsaWNhIGNhbGlicmF0Z2UgcmFkaW9tw6h0cmljIHBlciBjYWxpYnJhciBsZXMgZGFkZXMgZGVsIHJhZGFyIGVuIGJldGEgemVyby48L3A+PHA+U2kgZWwgREVNIGQnZW50cmFkYSBubyBhYnJhw6dhIHRvdCBlbCBkYXRhc2V0IGRlIFNBUiwgbCdlaW5hIGdlbmVyYXLDoCB2YWxvcnMgTm9EYXRhIHBlciBhbHMgcMOteGVscyBxdWUgcXVlZGluIGZvcmEgZGUgbCdleHRlbnNpw7MgREVNIHBlciBhIGxlcyBzb3J0aWRlcyBkZSBnYW1tYSB6ZXJvLCBzaWdtYSB6ZXJvLCDDoHJlYSBkZSBkaXNwZXJzacOzIGkgZGlzdG9yc2nDsyBnZW9tw6h0cmljYS4gUGVyIGEgbGEgc29ydGlkYSBkZSBsYSBtw6BzY2FyYSBkZSBkaXN0b3JzacOzIGdlb23DqHRyaWNhLCBsJ2VpbmEgZ2VuZXJhcsOgIHZhbG9ycyBpbmRldGVybWluYXRzIHBlciBhbHMgcMOteGVscyBxdWUgcXVlZGluIGZvcmEgZGUgbCdleHRlbnNpw7MgREVNLjwvcD48cD5FbCBERU0gZCdlbnRyYWRhIGhhIGRlIHNlciBhbCBzaXN0ZW1hIGRlIGNvb3JkZW5hZGVzIGdlb2dyw6BmaXF1ZXMgV0dTIDE5ODQgKEVQU0c6NDMyNikuPC9wPlwiLFxuXHRcdGNyZWF0ZUNvbG9yQ29tcG9zaXRlRnVuY3Rpb25OYW1lOiBcIkNyZWEgdW5hIGNvbXBvc2ljacOzIGRlIGNvbG9yXCIsXG5cdFx0Y3JlYXRlQ29sb3JDb21wb3NpdGVGdW5jdGlvblNuaXA6IFwiQ3JlYSB1biByw6BzdGVyIGRlIHRyZXMgYmFuZGVzIGEgcGFydGlyIGQndW4gZGF0YXNldCByw6BzdGVyIG11bHRpYmFuZGEgZW4gZWwgcXVhbCBjYWRhIGJhbmRhIHBvdCB1dGlsaXR6YXIgdW4gY8OgbGN1bCBhbGdlYnJhaWMgYmFzYXQgZW4gw6BsZ2VicmEgZGUgYmFuZGVzLlwiLFxuXHRcdGNyZWF0ZUNvbG9yQ29tcG9zaXRlRnVuY3Rpb25EZXNjOiBcIjxwPkxhIGZ1bmNpw7MgZGUgcsOgc3RlciBcXFwiQ3JlYSB1bmEgY29tcG9zaWNpw7MgZGUgY29sb3JcXFwiIGNyZWEgdW4gcsOgc3RlciBkZSB0cmVzIGJhbmRlcyBhIHBhcnRpciBkJ3VuIGRhdGFzZXQgcsOgc3RlciBlbiBlbCBxdWFsIGNhZGEgYmFuZGEgcG90IHV0aWxpdHphciB1biBjw6BsY3VsIGFsZ2VicmFpYyBiYXNhdCBlbiDDoGxnZWJyYSBkZSBiYW5kZXMuPC9wPjxwPlF1YW4gZGVmaW5pdSB1biBhbGdvcml0bWUgYXJpdG3DqHRpYyBkZSBiYW5kZXMsIHBvZGV1IGludHJvZHVpciB1bmEgZsOzcm11bGEgYWxnZWJyYWljYSBkJ3VuYSBzb2xhIGzDrW5pYSBwZXIgYSBjYWRhIGV4cHJlc3Npw7MgcGVyIGNyZWFyIHVuYSBzb3J0aWRhIG11bHRpYmFuZGEuIEVscyBvcGVyYWRvcnMgYWRtZXNvcyBzw7NuIHVuYXJpczogc3VtYSAoKyksIHJlc3RhICgtKSwgbXVsdGlwbGljYWNpw7MgKCopIGkgZGl2aXNpw7MgKC8pLjwvcD48cD5TaSB1dGlsaXR6ZXUgdW4gSWQuIGRlIGJhbmRhIGVuIHVuYSBleHByZXNzacOzLCBoZXUgZCdlc3BlY2lmaWNhciBlbCBwcmVmaXggQiBvIGIgY29tIGEgcHJlZml4IGRlbCBuw7ptZXJvIGRlIGJhbmRhIHBlciB0YWwgZCdpZGVudGlmaWNhciBsYSBiYW5kYS48L3A+PHA+VW5hIGRlIGxlcyBjb21iaW5hY2lvbnMgZGUgYmFuZGEgcXVlIHMndXRpbGl0emEgc292aW50IHBlciBhbCByYWRhciBkJ29iZXJ0dXJhIHNpbnTDqHRpY2EgKFNBUikgYSBsZXMgdW5pdGF0cyBsaW5lYWxzIMOpcyBWViBwZXIgYWwgdmVybWVsbCwgVkggcGVyIGFsIHZlcmQgaSBWVi9WSCBwZXIgYWwgYmxhdS4gU2kgbGVzIGRhZGVzIGQnZW50cmFkYSBzw7NuIGVuIGRlY2liZWxzLCBsYSBjb21iaW5hY2nDsyBkZSBiYW5kYSBoYSBkZSBzZXIgVlYgcGVyIGFsIHZlcm1lbGwsIFZIIHBlciBhbCB2ZXJkIGkgVlYtVkggcGVyIGFsIGJsYXUuPC9wPlwiLFxuXHRcdHN1cmZhY2VQYXJhbWV0ZXJzTmFtZTogXCJQYXLDoG1ldHJlcyBkZSBzdXBlcmbDrWNpZVwiLFxuXHRcdHN1cmZhY2VQYXJhbWV0ZXJzU25pcDogXCJEZXRlcm1pbmEgZWxzIHBhcsOgbWV0cmVzIGQndW4gcsOgc3RlciBkZSBzdXBlcmbDrWNpZSBjb20gYXJhIGwnYXNwZWN0ZSwgZWwgcGVuZGVudCBpIGRpdmVyc29zIHRpcHVzIGRlIGN1cnZhdHVyZXMgbWl0amFuw6dhbnQgbcOodG9kZXMgZ2VvZMOoc2ljcy5cIixcblx0XHRzdXJmYWNlUGFyYW1ldGVyc0Rlc2M6IFwiPHA+TGEgZnVuY2nDsyBQYXLDoG1ldHJlcyBkZSBzdXBlcmbDrWNpZSBkZXRlcm1pbmEgZWxzIHBhcsOgbWV0cmVzIGQndW4gcsOgc3RlciBkZSBzdXBlcmbDrWNpZSBjb20gYXJhIGwnYXNwZWN0ZSwgZWwgcGVuZGVudCBpIGRpdmVyc29zIHRpcHVzIGRlIGN1cnZhdHVyZXMgbWl0amFuw6dhbnQgbcOodG9kZXMgZ2VvZMOoc2ljcy48L3A+PHA+QXF1ZXN0YSBmdW5jacOzIHTDqSBsZXMgYXBsaWNhY2lvbnMgc2Vnw7xlbnRzOjwvcD48dWw+PGxpPkNhbGN1bGFyIGwnYXNwZWN0ZSBpIGVsIHBlbmRlbnQgbWl0amFuw6dhbnQgbcOodG9kZXMgZ2VvZMOoc2ljcy48L2xpPjxsaT5DYWxjdWxhciBkaWZlcmVudHMgdGlwdXMgZGUgY3VydmF0dXJlcyBkJ3VuIHLDoHN0ZXIgZGUgc3VwZXJmw61jaWUgZCdlbnRyYWRhLCBwZXIgZXhlbXBsZSwgPHN0cm9uZz5DdXJ2YXR1cmEgdGFuZ2VuY2lhbCAoY29udG9ybiBub3JtYWwpPC9zdHJvbmc+LCBxdWUgY2FyYWN0ZXJpdHphIGxhIGNvbnZlcmfDqG5jaWEgaSBsYSBkaXZlcmfDqG5jaWEgdG9wb2dyw6BmaWNhIGRlbCBmbHV4IHBlciBsYSBzdXBlcmbDrWNpZS48L2xpPjwvdWw+XCIsXG5cdFx0bGVhc3RDb3N0Q29ycmlkb3JOYW1lOiBcIkNvcnJlZG9yIGRlIG1lbm9yIGNvc3RcIixcblx0XHRsZWFzdENvc3RDb3JyaWRvclNuaXA6IFwiQ2FsY3VsYSBsYSBzdW1hIGRlIGRvcyByw6BzdGVycyBkZSBkaXN0w6BuY2lhIGRlIGNvc3QgYWN1bXVsYXRpdSBhbWIgbCdvcGNpw7MgZCdhcGxpY2FyIHVuIGxsaW5kYXIgZW4gZnVuY2nDsyBkJ3VuIHBlcmNlbnRhdGdlIG8gY29zdCBhY3VtdWxhdGl1LlwiLFxuXHRcdGxlYXN0Q29zdENvcnJpZG9yRGVzYzogXCI8cD5FbHMgcsOgc3RlcnMgZCdlbnRyYWRhIGhhbiBkZSBzZXIgbGEgc29ydGlkYSBkZSByw6BzdGVycyBkJ2FjdW11bGFjacOzIGRlIGRpc3TDoG5jaWEgaSBkZSBkaXJlY2Npw7MgaW52ZXJzYSBkZSBsYSBmdW5jacOzIDxzdHJvbmc+QWN1bXVsYWNpw7MgZGUgZGlzdMOgbmNpYTwvc3Ryb25nPiBvIDxzdHJvbmc+QXNzaWduYWNpw7MgZGUgZGlzdMOgbmNpYTwvc3Ryb25nPi4gUydoYW4gZGUgYmFzYXIgZW4gbGEgZGlzdMOgbmNpYSBkZSBjb3N0b3MgaSBjYWwgcXVlIHMndXRpbGl0emkgbGEgbWF0ZWl4YSBjb25maWd1cmFjacOzIGRlIHBhcsOgbWV0cmVzIGVuIGNyZWFyIGxlcyBjYXBlcyBwZXIgYSBjYWRhIGZvbnQuIE5vIHMnaGFuIGQndXRpbGl0emFyIHBhcsOgbWV0cmVzIHF1ZSBkZXBlbmd1aW4gZGUgbGEgZGlyZWNjaW9uYWxpdGF0IChmYWN0b3IgaG9yaXR6b250YWwsIGZhY3RvciB2ZXJ0aWNhbCBpIGRpcmVjY2nDsyBkZWwgdmlhdGdlKSBlbiBjcmVhciBhcXVlc3RzIHLDoHN0ZXJzLjwvcD48cD5FbHMgdmFsb3JzIGRlbCByw6BzdGVyIGRlIGNvcnJlZG9yIGRlIHNvcnRpZGEgc8OzbiBsYSBzdW1hIGRlbCBjb3N0IGFjdW11bGF0aXUgcGVyIGFycmliYXIgYSB1bmEgdWJpY2FjacOzIGRldGVybWluYWRhIGFtYiBsZXMgbWF0ZWl4ZXMgdW5pdGF0cyBxdWUgZWxzIHLDoHN0ZXJzIGRlIGRpc3TDoG5jaWEgZGUgY29zdCBhY3VtdWxhdGl1IGQnZW50cmFkYS48L3A+PHA+U2kgdW4gdmFsb3IgPHN0cm9uZz5MbGluZGFyPC9zdHJvbmc+IGVzcGVjaWZpY2F0IMOpcyBzdXBlcmlvciBhbCBjb3N0IGFjdW11bGF0aXUgbcOgeGltIHF1YW4gc2Ugc3VtZW4gZG9zIHLDoHN0ZXJzIGQnYWN1bXVsYWNpw7MgZGUgZGlzdMOgbmNpYSwgZWwgcsOgc3RlciBkZSBjb3JyZWRvciBkZSBzb3J0aWRhIGNvYnJpcsOgIGxhIG1hdGVpeGEgw6ByZWEgcXVlIGVscyByw6BzdGVycyBhY3VtdWxhdGl1cyBkJ2VudHJhZGEuPC9wPjxwPlNpIHVuIHZhbG9yIGRlIGxsaW5kYXIgZXNwZWNpZmljYXQgw6lzIGluZmVyaW9yIGFsIHZhbG9yIG3DrW5pbSBkZWwgcsOgc3RlciBkZSBjb3JyZWRvciwgZXMgcmV0b3JuYXLDoCB1biBtaXNzYXRnZSBkJ2F2w61zIGkgZWwgcsOgc3RlciBkZSBzb3J0aWRhIGVzdGFyw6AgYnVpdC48L3A+PHA+RWwgcsOgc3RlciBkZSBjb3JyZWRvciBkZSBzb3J0aWRhIHBvdCBjb250ZW5pciBjZWzCt2xlcyBhbWIgY29zdG9zIGFjdW11bGF0aXVzIGxsZXVnZXJhbWVudCBzdXBlcmlvcnMgYWwgdmFsb3IgZGVsIGxsaW5kYXIuIEFpeMOyIGVzIGRldSBhbHMgcsOgc3RlcnMgZGUgZGlyZWNjacOzIGludmVyc2EgcXVlIHV0aWxpdHplbiBjZWzCt2xlcyBxdWUgdGVuZW4gYXNzaWduYXRzIGNvc3RvcyBsbGV1Z2VyYW1lbnQgc3VwZXJpb3JzIGFsIGxsaW5kYXIgcGVyIGNvbm5lY3RhciBjZWzCt2xlcyBkZXNjb25uZWN0YWRlcyBhbCBjb3JyZWRvci48L3A+XCIsXG5cdFx0Z2VvbWV0cmljTWVkaWFuTmFtZTogXCJNaXRqYW5hIGdlb23DqHRyaWNhXCIsXG5cdFx0Z2VvbWV0cmljTWVkaWFuU25pcDogXCJMYSBmdW5jacOzIE1lZGlhbmEgZ2VvbcOodHJpY2EgY2FsY3VsYSBsYSBtZWRpYW5hIGdlb23DqHRyaWNhIGRlbHMgcMOteGVscyBlbiB1bmEgc8OocmllIHRlbXBvcmFsIGQnaW1hdGdlcyBtdWx0aWJhbmRhLlwiLFxuXHRcdGdlb21ldHJpY01lZGlhbkRlc2M6IFwiPHA+QXF1ZXN0YSBmdW5jacOzIHJlZHVlaXggZWwgc29yb2xsIGkgZWxzIHZhbG9ycyBhdMOtcGljcyBlbiBpbWF0Z2VzIGRlIHPDqHJpZSB0ZW1wb3JhbCBjYWxjdWxhbnQgdW4gcMOteGVsIGRlIG1lZGlhbmEgZ2VvbcOodHJpY2EgcGVyIGEgY2FkYSBtYXRyaXUgZGUgcMOteGVscyBkZSBsYSBwaWxhIGQnaW1hdGdlcy4gTCdhbGdvcml0bWUgbWFudMOpIGxlcyByZWxhY2lvbnMgZXNwZWN0cmFscyBlbnRyZSBsZXMgYmFuZGVzIGRlbHMgZXNwZWN0cmVzIGRlIHDDrXhlbHMgcGVyIHBvZGVyIHV0aWxpdHphciBsYSBzb3J0aWRhIGVuIGFuw6BsaXNpcywgY29tIGFyYSDDrW5kZXhzIGRlIHZlZ2V0YWNpw7MuPC9wPjxwPkVscyBuw7p2b2xzIGkgbGVzIG9tYnJlcyBzJ2hhbiBkJ2VtbWFzY2FyYXIgbWl0amFuw6dhbnQgbGEgYmFuZGEgZGUgUUEgZGVsIGRhdGFzZXQgYWJhbnMgZCdhcGxpY2FyIGFxdWVzdGEgZnVuY2nDsy48L3A+PHA+U2kgbGEgaW1hdGdlIGQnZW50cmFkYSDDqXMgdW4gcHVudCBmbG90YW50LCBjb20gYXJhIGxhIHJlZmxlY3TDoG5jaWEgZGUgc3VwZXJmw61jaWUgYW1iIHZhbG9ycyBlbnRyZSAwIGkgMSwgdW4gdmFsb3Igw6hwc2lsb24gZGUgMCwwMDEgaGEgZGUgZ2VuZXJhciByZXN1bHRhdHMgZGUgcXVhbGl0YXQuPC9wPlwiXG5cdH0sXG5cdHJmeEFyZ3M6IHtcblx0XHRyYXN0ZXJOYW1lOiBcIlLDoHN0ZXJcIixcblx0XHRjb2xvclNjaGVtZVR5cGVOYW1lOiBcIlRpcHVzIGQnZXNxdWVtYSBkZSBjb2xvcnNcIixcblx0XHRjb2xvcm1hcE5hbWU6IFwiTWFwYSBkZSBjb2xvclwiLFxuXHRcdGNvbG9ybWFwTmFtZU5hbWU6IFwiTm9tIGRlbCBtYXBhIGRlIGNvbG9yXCIsXG5cdFx0Y29sb3JSYW1wTmFtZTogXCJSYW1wYSBkZSBjb2xvclwiLFxuXHRcdGNvbnRyYXN0T2Zmc2V0TmFtZTogXCJEZXNwbGHDp2FtZW50IGRlbCBjb250cmFzdFwiLFxuXHRcdGJyaWdodG5lc3NPZmZzZXROYW1lOiBcIkRlc3BsYcOnYW1lbnQgZGUgbGEgYnJpbGxhbnRvclwiLFxuXHRcdG1ldGhvZE5hbWU6IFwiTcOodG9kZVwiLFxuXHRcdGJhbmROYW1lc05hbWU6IFwiTm9tcyBkZSBiYW5kYVwiLFxuXHRcdGJhbmRXYXZlbGVuZ3Roc05hbWU6IFwiTG9uZ2l0dWRzIGQnb25hIGRlIGJhbmRlc1wiLFxuXHRcdGJhbmRJZHNOYW1lOiBcIklEIGRlIGJhbmRhXCIsXG5cdFx0bWlzc2luZ0JhbmRBY3Rpb25OYW1lOiBcIkZhbHRhIGwnYWNjacOzIGRlIGJhbmRhXCIsXG5cdFx0Y29udmVyc2lvblBhcmFtZXRlcnNOYW1lOiBcIlBhcsOgbWV0cmVzIGRlIGNvbnZlcnNpw7NcIixcblx0XHRoaWxsc2hhZGVUeXBlTmFtZTogXCJUaXB1cyBkJ29tYnJhXCIsXG5cdFx0YXppbXV0aE5hbWU6IFwiQXppbXV0XCIsXG5cdFx0YWx0aXR1ZGVOYW1lOiBcIkFsdGl0dWRcIixcblx0XHRzbG9wZVR5cGVOYW1lOiBcIkVzY2FsYVwiLFxuXHRcdHpGYWN0b3JOYW1lOiBcIkZhY3RvciBaXCIsXG5cdFx0UFNQb3dlck5hbWU6IFwiUG90w6huY2lhIGRlIG1pZGEgZGUgcMOteGVsXCIsXG5cdFx0UFNaRmFjdG9yTmFtZTogXCJGYWN0b3IgZGUgbWlkYSBkZSBww614ZWxcIixcblx0XHRyZW1vdmVFZGdlRWZmZWN0TmFtZTogXCJEZXNoYWJpbGl0YSBsYSBpbnRlcnBvbGFjacOzIGRlIHDDrXhlbHMgZGUgdm9yYSBwZXIgZGVmZWN0ZVwiLFxuXHRcdGZyb21Vbml0TmFtZTogXCJEZXMgZGUgbGEgdW5pdGF0XCIsXG5cdFx0dG9Vbml0TmFtZTogXCJGaW5zIGEgbGEgdW5pdGF0XCIsXG5cdFx0cmFzdGVyVHlwZU5hbWU6IFwiVGlwdXNcIixcblx0XHRtaW5OYW1lOiBcIlNvcnRpZGEgbcOtbmltYVwiLFxuXHRcdG1heE5hbWU6IFwiU29ydGlkYSBtw6B4aW1hXCIsXG5cdFx0bWluUGVyY2VudE5hbWU6IFwiUGVyY2VudGF0Z2UgZGUgcmV0YWxsIG3DrW5pbVwiLFxuXHRcdG1heFBlcmNlbnROYW1lOiBcIlBlcmNlbnRhdGdlIGRlIHJldGFsbCBtw6B4aW1cIixcblx0XHRudW1iZXJPZlN0YW5kYXJkRGV2aWF0aW9uTmFtZTogXCJOb21icmUgZGUgZGVzdmlhY2lvbnMgZXN0w6BuZGFyZFwiLFxuXHRcdHNpZ21vaWRTdHJlbmd0aExldmVsTmFtZTogXCJOaXZlbGwgZGUgcmVzaXN0w6huY2lhIHNpZ21vaWRlXCIsXG5cdFx0ZXN0aW1hdGVTdGF0c0hpc3RvZ3JhbU5hbWU6IFwiQ2FsY3VsYSBsZXMgZXN0YWTDrXN0aXF1ZXNcIixcblx0XHREUkFOYW1lOiBcIkFqdXN0IGRlIG1hcmdlIGRpbsOgbWljXCIsXG5cdFx0c3RhdGlzdGljc05hbWU6IFwiRXN0YWTDrXN0aXF1ZXNcIixcblx0XHRoaXN0b2dyYW1zTmFtZTogXCJIaXN0b2dyYW1lc1wiLFxuXHRcdHN0YXRpc3RpY3NIaXN0b2dyYW1OYW1lOiBcIkRlZmluZWl4IGxlcyBlc3RhZMOtc3RpcXVlcyBpIGwnaGlzdG9ncmFtYVwiLFxuXHRcdGNvbXB1dGVHYW1tYU5hbWU6IFwiR2FtbWEgYXV0b23DoHRpY1wiLFxuXHRcdHVzZUdhbW1hTmFtZTogXCJVdGlsaXR6YSBlbCBnYW1tYVwiLFxuXHRcdGdhbW1hTmFtZTogXCJHYW1tYVwiLFxuXHRcdGlucHV0TmFtZXNOYW1lOiBcIk5vbXNcIixcblx0XHRleHByZXNzaW9uTmFtZTogXCJFeHByZXNzacOzXCIsXG5cdFx0Y2VsbHNpemVUeXBlTmFtZTogXCJUaXB1cyBkZSBtaWRhIGRlIGNlbMK3bGFcIixcblx0XHRleHRlbnRUeXBlTmFtZTogXCJUaXB1cyBkJ2V4dGVuc2nDs1wiLFxuXHRcdGNsYXNzaWZpZXJEZWZpbml0aW9uRmlsZU5hbWU6IFwiRml0eGVyIGRlIGRlZmluaWNpw7MgZCdlbnRyYWRhXCIsXG5cdFx0cmFzdGVyMU5hbWU6IFwiUsOgc3RlcjFcIixcblx0XHRyYXN0ZXIyTmFtZTogXCJSw6BzdGVyMlwiLFxuXHRcdHJhc3RlcjNOYW1lOiBcIlLDoHN0ZXIzXCIsXG5cdFx0dHJ1ZVJhc3Rlck5hbWU6IFwiUsOgc3RlciBjZXJ0XCIsXG5cdFx0ZmFsc2VSYXN0ZXJOYW1lOiBcIlLDoHN0ZXIgZmFsc1wiLFxuXHRcdG5vRGF0YUludGVycHJldGF0aW9uTmFtZTogXCJJbnRlcnByZXRhY2nDsyBkZSBOb0RhdGFcIixcblx0XHRub0RhdGFWYWx1ZXNOYW1lOiBcIlZhbG9ycyBOb0RhdGFcIixcblx0XHRpbmNsdWRlZFJhbmdlc05hbWU6IFwiSW50ZXJ2YWxzIGluY2xvc29zXCIsXG5cdFx0Y3VydmF0dXJlVHlwZU5hbWU6IFwiVGlwdXMgZGUgY3VydmF0dXJhXCIsXG5cdFx0cmFzdGVyc05hbWU6IFwiUsOgc3RlcnNcIixcblx0XHRhdHRyaWJ1dGVUYWJsZU5hbWU6IFwiVGF1bGFcIixcblx0XHRhdHRyaWJ1dGVUYWJsZVR5cGVOYW1lOiBcIlRpcHVzIGRlIHRhdWxhXCIsXG5cdFx0cm93c05hbWU6IFwiTm9tYnJlIGRlIGZpbGVzXCIsXG5cdFx0Y29sdW1uc05hbWU6IFwiTm9tYnJlIGRlIGNvbHVtbmVzXCIsXG5cdFx0a2VybmVsTmFtZTogXCJOdWNsaVwiLFxuXHRcdG1pcnJvckVkZ2VzTmFtZTogXCJWb3JlcyBtaXJhbGxcIixcblx0XHRpbmZsdWVuY2VzTmFtZTogXCJJbmZsdcOobmNpZXNcIixcblx0XHRmaWVsZHNOYW1lOiBcIkNhbXBzXCIsXG5cdFx0cmVtYXBzTmFtZTogXCJUYXVsYSBkZSBub3ZhIHJlcHJlc2VudGFjacOzIGdlb2dyw6BmaWNhXCIsXG5cdFx0ZXZhbEZyb21OYW1lOiBcIkVzY2FsYSBkJ2F2YWx1YWNpw7MgaW5pY2lhbFwiLFxuXHRcdGV2YWxUb05hbWU6IFwiRXNjYWxhIGQnYXZhbHVhY2nDsyBmaW5hbFwiLFxuXHRcdHdlaWdodHNOYW1lOiBcIlBlc29zXCIsXG5cdFx0REVNTmFtZTogXCJERU1cIixcblx0XHRzaG9ydFJhbmdlSURXUmFkaXVzTmFtZTogXCJSYWRpIElEVyBkJ2ludGVydmFsIGN1cnRcIixcblx0XHRtYXhWb2lkV2lkdGhOYW1lOiBcIkFtcGxhZGEgYnVpZGEgbcOgeGltYVwiLFxuXHRcdHNpZ21hR2F1c3NpYW5OYW1lOiBcIlN1YXZpdHphY2nDsyBhZGFwdGF0aXZhXCIsXG5cdFx0Y29udG91clR5cGVOYW1lOiBcIlRpcHVzIGRlIGNvcmJhIGRlIG5pdmVsbFwiLFxuXHRcdHpCYXNlTmFtZTogXCJCYXNlIFpcIixcblx0XHRudW1iZXJPZkNvbnRvdXJzTmFtZTogXCJOb21icmUgZGUgY29yYmVzIGRlIG5pdmVsbFwiLFxuXHRcdGNvbnRvdXJJbnRlcnZhbE5hbWU6IFwiSW50ZXJ2YWwgZGUgY29yYmVzIGRlIG5pdmVsbFwiLFxuXHRcdG50aENvbnRvdXJMaW5lSW5Cb2xkTmFtZTogXCJMw61uaWEgZGUgY29yYmEgZGUgbml2ZWxsIE4gZW4gbmVncmV0YVwiLFxuXHRcdGZlYXR1cmVDbGFzc05hbWU6IFwiRW50aXRhdHMgZCdlbnRyYWRhXCIsXG5cdFx0Y2xhc3NJbmRleEZpZWxkTmFtZTogXCJDYW1wXCIsXG5cdFx0cmVzb2x2ZU92ZXJsYXBNZXRob2ROYW1lOiBcIk3DqHRvZGUgZGUgcmVzb2x1Y2nDsyBkZSBzdXBlcnBvc2ljacOzXCIsXG5cdFx0cmVzYW1wbGluZ1R5cGVOYW1lOiBcIlRpcHVzIGRlIG1vc3RyZWlnIG5vdVwiLFxuXHRcdGlucHV0Q2VsbHNpemVOYW1lOiBcIk1pZGEgZGUgY2VswrdsYSBkJ2VudHJhZGFcIixcblx0XHRvdXRwdXRDZWxsc2l6ZU5hbWU6IFwiTWlkYSBkZSBjZWzCt2xhIGRlIHNvcnRpZGFcIixcblx0XHRwb2ludEZlYXR1cmVDbGFzc05hbWU6IFwiUHVudCBkJ29yaWdlblwiLFxuXHRcdG1heEdyb3d0aFJhZGl1c0ZpZWxkTmFtZTogXCJDYW1wIGRlbCByYWRpIGRlIGNyZWl4ZW1lbnQgbcOgeGltXCIsXG5cdFx0c2ltaWxhcml0eVRocmVzaG9sZEZpZWxkTmFtZTogXCJDYW1wIGRlbCBsbGluZGFyIGRlIHNpbWlsaXR1ZFwiLFxuXHRcdGZpbGxWYWx1ZUZpZWxkTmFtZTogXCJDYW1wIGRlbCB2YWxvciBkJ2VtcGxlbmFtZW50XCIsXG5cdFx0c3BlY3RyYWxEZXRhaWxOYW1lOiBcIkRldGFsbCBlc3BlY3RyYWwgWzEuLjIwXVwiLFxuXHRcdHNwYXRpYWxEZXRhaWxOYW1lOiBcIkRldGFsbCBlc3BhY2lhbCBbMS4uMjBdXCIsXG5cdFx0bWluTnVtUGl4ZWxzUGVyU2VnbWVudE5hbWU6IFwiTWlkYSBkZSBzZWdtZW50IG3DrW5pbWEgZW4gcMOteGVsc1wiLFxuXHRcdGJvdW5kYXJpZXNPbmx5TmFtZTogXCJOb23DqXMgbMOtbWl0cyBkZSBzZWdtZW50XCIsXG5cdFx0c3RhdGlzdGljc1R5cGVOYW1lOiBcIlRpcHVzIGQnZXN0YWTDrXN0aXF1ZXNcIixcblx0XHRmaWxsTm9EYXRhT25seU5hbWU6IFwiTm9tw6lzIGVtcGxlbmFyIHDDrXhlbHMgTm9EYXRhXCIsXG5cdFx0aW5wdXREYXRhVHlwZU5hbWU6IFwiVGlwdXMgZGUgZGFkZXMgZCdlbnRyYWRhXCIsXG5cdFx0YW5nbGVSZWZlcmVuY2VTeXN0ZW1OYW1lOiBcIlNpc3RlbWEgZGUgcmVmZXLDqG5jaWEgZCdhbmdsZXNcIixcblx0XHRvdXRwdXREYXRhVHlwZU5hbWU6IFwiVGlwdXMgZGUgZGFkZXMgZGUgc29ydGlkYVwiLFxuXHRcdGlucHV0U2FtcGxlUG9pbnRGZWF0dXJlQ2xhc3NOYW1lOiBcIk1vc3RyZXMgZCdlbnRyYWRhXCIsXG5cdFx0dmFsdWVGaWVsZE5hbWU6IFwiQ2FtcCBkZSB2YWxvclwiLFxuXHRcdHJhc3RlckluZm9OYW1lOiBcIkluZm9ybWFjacOzIGRlbCByw6BzdGVyXCIsXG5cdFx0aW50ZXJwb2xhdGlvbk1ldGhvZE5hbWU6IFwiTcOodG9kZSBkJ2ludGVycG9sYWNpw7NcIixcblx0XHRyYWRpdXNOYW1lOiBcIlJhZGlcIixcblx0XHRyYWRpYW5jZUdhaW5WYWx1ZXNOYW1lOiBcIkd1YW55IGRlIHJhZGnDoG5jaWFcIixcblx0XHRyYWRpYW5jZUJpYXNWYWx1ZXNOYW1lOiBcIkJpYWl4IGRlIHJhZGnDoG5jaWFcIixcblx0XHRyZWZsZWN0ZWRHYWluVmFsdWVzTmFtZTogXCJHdWFueSBkZSByZWZsZWN0w6BuY2lhXCIsXG5cdFx0cmVmbGVjdGVkQmlhc1ZhbHVlc05hbWU6IFwiQmlhaXggZGUgcmVmbGVjdMOgbmNpYVwiLFxuXHRcdHN1bkVsZXZhdGlvbk5hbWU6IFwiRWxldmFjacOzIGRlbCBzb2wgKGdyYXVzKVwiLFxuXHRcdGFsYmVkb05hbWU6IFwiQWxiZWRvXCIsXG5cdFx0c2NhbGVGYWN0b3JOYW1lOiBcIkZhY3RvciBkJ2VzY2FsYVwiLFxuXHRcdG9mZnNldE5hbWU6IFwiRGVzcGxhw6dhbWVudFwiLFxuXHRcdHRocmVzaG9sZFR5cGVOYW1lOiBcIlRpcHVzIGRlIGxsaW5kYXJcIixcblx0XHR0aHJlc2hvbGRzTmFtZTogXCJMbGluZGFyc1wiLFxuXHRcdHVuZGVmaW5lZENsYXNzTmFtZTogXCJDbGFzc2Ugc2Vuc2UgZGVmaW5pclwiLFxuXHRcdG1pblZhbHVlTmFtZTogXCJNw61uLlwiLFxuXHRcdG1heFZhbHVlTmFtZTogXCJNw6B4LlwiLFxuXHRcdG9wZXJhdGlvbk5hbWU6IFwiT3BlcmFjacOzXCIsXG5cdFx0Y2xpcHBpbmdUeXBlTmFtZTogXCJUaXB1cyBkZSByZXRhbGxcIixcblx0XHRjbGlwcGluZ0dlb21ldHJ5TmFtZTogXCJHZW9tZXRyaWEvcsOgc3RlciBkZSByZXRhbGxcIixcblx0XHRleHRlbnROYW1lOiBcIkV4dGVuc2nDsyBkZSBzb3J0aWRhXCIsXG5cdFx0dXNlSW5wdXRGZWF0dXJlR2VvbWV0cnlOYW1lOiBcIlV0aWxpdHphIGVudGl0YXRzIGQnZW50cmFkYSBwZXIgcmV0YWxsYXIgbGEgZ2VvbWV0cmlhXCIsXG5cdFx0cmVtYXBEZWZpbml0aW9uVHlwZU5hbWU6IFwiVGlwdXMgZGUgZGVmaW5pY2nDsyBkZSBub3ZhIHJlcHJlc2VudGFjacOzIGdlb2dyw6BmaWNhXCIsXG5cdFx0aW5wdXRSYW5nZU5hbWU6IFwiSW50ZXJ2YWxzIGQnZW50cmFkYVwiLFxuXHRcdG91dHB1dFZhbHVlc05hbWU6IFwiVmFsb3JzIGRlIHNvcnRpZGFcIixcblx0XHRub0RhdGFSYW5nZU5hbWU6IFwiSW50ZXJ2YWxzIE5vRGF0YVwiLFxuXHRcdGlucHV0RmllbGROYW1lOiBcIkNhbXAgZCdlbnRyYWRhXCIsXG5cdFx0b3V0cHV0RmllbGROYW1lOiBcIkNhbXAgZGUgc29ydGlkYVwiLFxuXHRcdGlucHV0TWF4RmllbGROYW1lOiBcIkNhbXAgZCdlbnRyYWRhIG3DoHguIChvcGNpb25hbClcIixcblx0XHRyZW1hcFRhYmxlVHlwZU5hbWU6IFwiVGlwdXMgZGUgdGF1bGEgZGUgbm92YSByZXByZXNlbnRhY2nDsyBnZW9ncsOgZmljYVwiLFxuXHRcdGFsbG93VW5tYXRjaGVkTmFtZTogXCJQZXJtZXQgdmFsb3JzIGRlIHDDrXhlbCBzZW5zZSBjb2luY2lkw6huY2lhXCIsXG5cdFx0Y2hhbmdlTWlzc2luZ1ZhbHVlc1RvTm9EYXRhTmFtZTogXCJDYW52aWEgZWxzIHZhbG9ycyBxdWUgZmFsdGVuIGEgTm9EYXRhXCIsXG5cdFx0dmlzaWJsZUJhbmRJRE5hbWU6IFwiSUQgZGUgYmFuZGEgdmlzaWJsZVwiLFxuXHRcdGluZnJhcmVkQmFuZElETmFtZTogXCJJRCBkZSBiYW5kYSBpbmZyYXJvamFcIixcblx0XHRzY2llbnRpZmljT3V0cHV0TmFtZTogXCJTb3J0aWRhIGNpZW50w61maWNhXCIsXG5cdFx0YmFuZEluZGV4ZXNOYW1lOiBcIsONbmRleHMgZGUgYmFuZGFcIixcblx0XHRjb25zdGFudE5hbWU6IFwiQ29uc3RhbnRcIixcblx0XHR3ZWlnaHROYW1lOiBcIlBlc1wiLFxuXHRcdG1pbmltdW1OYW1lOiBcIk3DrW5pbVwiLFxuXHRcdG1heGltdW1OYW1lOiBcIk3DoHhpbVwiLFxuXHRcdHNvdXJjZURhdGFOYW1lOiBcIlLDoHN0ZXIgZCdvcmlnZW5cIixcblx0XHRzb3VyY2VGaWVsZE5hbWU6IFwiQ2FtcCBkJ29yaWdlblwiLFxuXHRcdGNvc3RSYXN0ZXJOYW1lOiBcIlLDoHN0ZXIgZGUgY29zdG9zXCIsXG5cdFx0bWF4RGlzdGFuY2VOYW1lOiBcIkRpc3TDoG5jaWEgbcOgeGltYVwiLFxuXHRcdHZhbHVlUmFzdGVyTmFtZTogXCJSw6BzdGVyIGRlIHZhbG9yXCIsXG5cdFx0Y29zdE11bHRpcGxpZXJOYW1lOiBcIk11bHRpcGxpY2Fkb3IgcGVyIGFwbGljYXIgYWxzIGNvc3Rvc1wiLFxuXHRcdHN0YXJ0Q29zdE5hbWU6IFwiQ29zdCBpbmljaWFsXCIsXG5cdFx0YWNjdW1Db3N0UmVzaXN0YW5jZVJhdGVOYW1lOiBcIlRheGEgZGUgcmVzaXN0w6huY2lhIGRlbCBjb3N0IGFjdW11bGF0XCIsXG5cdFx0Y2FwYWNpdHlOYW1lOiBcIkNhcGFjaXRhdFwiLFxuXHRcdHRyYXZlbERpcmVjdGlvbk5hbWU6IFwiRGlyZWNjacOzIGRlbCBkZXNwbGHDp2FtZW50XCIsXG5cdFx0Y2VsbFNpemVOYW1lOiBcIk1pZGEgZGUgY2VswrdsYVwiLFxuXHRcdHBvcHVsYXRpb25GaWVsZE5hbWU6IFwiQ2FtcCBkZSBwb2JsYWNpw7NcIixcblx0XHRhcmVhVW5pdHNOYW1lOiBcIlVuaXRhdHMgZCfDoHJlYVwiLFxuXHRcdG91dHB1dFZhbHVlVHlwZU5hbWU6IFwiVmFsb3JzIGRlIGNlbMK3bGEgZGUgc29ydGlkYVwiLFxuXHRcdGJhcnJpZXJzTmFtZTogXCJCYXJyZXJlcyBk4oCZZW50cmFkYVwiLFxuXHRcdGRlc3RpbmF0aW9uRGF0YU5hbWU6IFwiUsOgc3RlciBkZSBkZXN0aW5hY2nDs1wiLFxuXHRcdGRlc3RpbmF0aW9uRmllbGROYW1lOiBcIkNhbXAgZGUgZGVzdGluYWNpw7NcIixcblx0XHRwYXRoVHlwZU5hbWU6IFwiVGlwdXMgZGUgcnV0YVwiLFxuXHRcdG9ic2VydmVyRmVhdHVyZXNOYW1lOiBcIkVudGl0YXRzIGQnb2JzZXJ2YWRvclwiLFxuXHRcdGFuYWx5c2lzTWV0aG9kTmFtZTogXCJNw6h0b2RlIGQnYW7DoGxpc2lcIixcblx0XHRhbmFseXNpc1R5cGVOYW1lOiBcIlRpcHVzIGQnYW7DoGxpc2lcIixcblx0XHR2ZXJ0aWNhbEVycm9yTmFtZTogXCJFcnJvciB2ZXJ0aWNhbFwiLFxuXHRcdHJlZnJhY3Rpdml0eUNvZWZmaWNpZW50TmFtZTogXCJDb2VmaWNpZW50IGRlIHJlZnJhY2Npw7NcIixcblx0XHRzdXJmYWNlT2Zmc2V0TmFtZTogXCJEZXNwbGHDp2FtZW50IGRlIHN1cGVyZsOtY2llXCIsXG5cdFx0b2JzZXJ2ZXJFbGV2YXRpb25OYW1lOiBcIkVsZXZhY2nDsyBkZSBsJ29ic2VydmFkb3JcIixcblx0XHRvYnNlcnZlck9mZnNldE5hbWU6IFwiRGVzcGxhw6dhbWVudCBkZSBsJ29ic2VydmFkb3JcIixcblx0XHRpbm5lclJhZGl1c05hbWU6IFwiUmFkaSBpbnRlcm5cIixcblx0XHRpbm5lclJhZGl1c0lzM0REaXN0YW5jZU5hbWU6IFwiRWwgcmFkaSBpbnRlcm4gw6lzIGxhIGRpc3TDoG5jaWEgM0RcIixcblx0XHRvdXRlclJhZGl1c05hbWU6IFwiUmFkaSBleHRlcm5cIixcblx0XHRvdXRlclJhZGl1c0lzM0REaXN0YW5jZU5hbWU6IFwiRWwgcmFkaSBleHRlcm4gw6lzIGxhIGRpc3TDoG5jaWEgM0RcIixcblx0XHRob3Jpem9udGFsU3RhcnRBbmdsZU5hbWU6IFwiQW5nbGUgZCdpbmljaSBob3JpdHpvbnRhbFwiLFxuXHRcdGhvcml6b250YWxFbmRBbmdsZU5hbWU6IFwiQW5nbGUgZGUgZmluYWxpdHphY2nDsyBob3JpdHpvbnRhbFwiLFxuXHRcdHZlcnRpY2FsVXBwZXJBbmdsZU5hbWU6IFwiQW5nbGUgc3VwZXJpb3IgdmVydGljYWxcIixcblx0XHR2ZXJ0aWNhbExvd2VyQW5nbGVOYW1lOiBcIkFuZ2xlIGluZmVyaW9yIHZlcnRpY2FsXCIsXG5cdFx0em9uZURhdGFOYW1lOiBcIlLDoHN0ZXIgZGUgem9uYVwiLFxuXHRcdHpvbmVGaWVsZE5hbWU6IFwiQ2FtcCBkZSB6b25hXCIsXG5cdFx0aWdub3JlTm9EYXRhTmFtZTogXCJJZ25vcmEgTm9EYXRhIGFscyBjw6BsY3Vsc1wiLFxuXHRcdHRlbXBlcmF0dXJlUmFzdGVyTmFtZTogXCJSw6BzdGVyIGRlIHRlbXBlcmF0dXJhXCIsXG5cdFx0aW5UZW1wZXJhdHVyZVVuaXRzTmFtZTogXCJVbml0YXRzIGRlIHRlbXBlcmF0dXJhXCIsXG5cdFx0b3V0SGVhdEluZGV4VGVtcGVyYXR1cmVVbml0c05hbWU6IFwiVW5pdGF0cyBkJ8OtbmRleCBkZSBjYWxvclwiLFxuXHRcdHJlbGF0aXZlSHVtaWRpdHlSYXN0ZXJOYW1lOiBcIlLDoHN0ZXIgZCdodW1pdGF0IHJlbGF0aXZhXCIsXG5cdFx0b3V0V2luZENoaWxsVGVtcGVyYXR1cmVVbml0c05hbWU6IFwiVW5pdGF0IGRlIHNlbnNhY2nDsyB0w6hybWljYVwiLFxuXHRcdHdpbmRTcGVlZFJhc3Rlck5hbWU6IFwiUsOgc3RlciBkZSB2ZWxvY2l0YXQgZGVsIHZlbnRcIixcblx0XHRpbldpbmRTcGVlZFVuaXRzTmFtZTogXCJVbml0YXRzIGRlIHZlbG9jaXRhdCBkZWwgdmVudFwiLFxuXHRcdHZhbHVlTmFtZTogXCJWYWxvclwiLFxuXHRcdHByb3BlcnR5TmFtZTogXCJOb20gZGUgcHJvcGlldGF0XCIsXG5cdFx0anNvbk5hbWU6IFwiSlNPTiBkZSBtZXRhZGFkZXNcIixcblx0XHR6b25lVGFibGVOYW1lOiBcIlRhdWxhIGQnYXRyaWJ1dHMgem9uYWxcIixcblx0XHRhdHRyaWJ1dGVGaWVsZE5hbWVzOiBcIk5vbXMgZGUgY2FtcCBkJ2F0cmlidXRcIixcblx0XHRiYWNrZ3JvdW5kTmFtZTogXCJWYWxvciBkZSBmb25zXCIsXG5cdFx0d2hlcmVDbGF1c2VOYW1lOiBcIkNsw6B1c3VsYSBXaGVyZVwiLFxuXHRcdG1pbmltdW1WYWx1ZUZpZWxkTmFtZTogXCJOb20gZGUgY2FtcCBkZSB2YWxvciBtw61uaW1cIixcblx0XHRtYXhpbXVtVmFsdWVGaWVsZE5hbWU6IFwiTm9tIGRlIGNhbXAgZGUgdmFsb3IgbcOgeGltXCIsXG5cdFx0b3V0VmFsdWVGaWVsZE5hbWU6IFwiTm9tIGRlIGNhbXAgZGUgdmFsb3IgZGUgc29ydGlkYVwiLFxuXHRcdGRlZmF1bHRWYWx1ZU5hbWU6IFwiVmFsb3IgZGUgc29ydGlkYSBwZXIgZGVmZWN0ZVwiLFxuXHRcdGNvbnZlcnNpb25NYXRyaXhOYW1lOiBcIk1hdHJpdSBkZSBjb252ZXJzacOzXCIsXG5cdFx0SXNQc2V1ZG9Db2xvck91dHB1dE5hbWU6IFwiw4lzIHVuYSBwc2V1ZG9zb3J0aWRhIGRlIGNvbG9yXCIsXG5cdFx0dW5tYXBwZWRBc1JhbmRvbUNvbG9yTmFtZTogXCJBc3NpZ25hIHVuIGNvbG9yIGRlIG1hbmVyYSBhbGVhdMOycmlhIGFscyBww614ZWxzIHNlbnNlIGFzc2lnbmFyXCIsXG5cdFx0ZGlzdGFuY2VNZXRob2ROYW1lOiBcIk3DqHRvZGUgZGUgZGlzdMOgbmNpYVwiLFxuXHRcdGZsb3dEaXJSYXN0ZXJOYW1lOiBcIlLDoHN0ZXIgZGUgZGlyZWNjacOzIGRlbCBmbHV4XCIsXG5cdFx0cG91clBvaW50TmFtZTogXCJSw6BzdGVyIGRlIHB1bnRzIGRlIGZsdcOvZGVzYVwiLFxuXHRcdHBvdXJQb2ludEZpZWxkTmFtZTogXCJDYW1wIGRlIHB1bnQgZGUgZmx1w69kZXNhXCIsXG5cdFx0Y29uc3RhbnRaTmFtZTogXCJaIGNvbnN0YW50XCIsXG5cdFx0ek9mZnNldE5hbWU6IFwiRGVzcGxhw6dhbWVudCBkZSBaXCIsXG5cdFx0Z2VvSWROYW1lOiBcIkdlb2lkZVwiLFxuXHRcdGNhbGlicmF0aW9uVHlwZU5hbWU6IFwiVGlwdXMgZGUgY2FsaWJyYXRnZVwiLFxuXHRcdGZpbHRlclR5cGVOYW1lOiBcIlRpcHVzIGRlIGZpbHRyZVwiLFxuXHRcdGZpbHRlclNpemVOYW1lOiBcIk1pZGEgZGVsIGZpbHRyZVwiLFxuXHRcdG5vaXNlTW9kZWxOYW1lOiBcIk1vZGVsIGRlIHNvcm9sbFwiLFxuXHRcdG5vaXNlVmFyaWFuY2VOYW1lOiBcIlZhcmnDoG5jaWEgZGVsIHNvcm9sbFwiLFxuXHRcdGFkZGl0aXZlTm9pc2VNZWFuTmFtZTogXCJNaXRqYSBkZSBzb3JvbGwgYWRkaXRpdVwiLFxuXHRcdG11bHRpcGxpY2F0aXZlTm9pc2VNZWFuTmFtZTogXCJNaXRqYSBkZSBzb3JvbGwgbXVsdGlwbGljYXRpdVwiLFxuXHRcdG51bWJlcm9mTG9va3NOYW1lOiBcIk5vbWJyZSBkJ29ic2VydmFjaW9uc1wiLFxuXHRcdGRhbXBpbmdGYWN0b3JOYW1lOiBcIkZhY3RvciBkJ2Ftb3J0aW1lbnRcIixcblx0XHRtYXNrUmFzdGVyTmFtZTogXCJSw6BzdGVyIGRlIG3DoHNjYXJhXCIsXG5cdFx0bmliYmxlVmFsdWVzTmFtZTogXCJVdGlsaXR6ZXUgdmFsb3JzIE5vRGF0YSBzaSBzw7NuIGVsIHZlw60gbcOpcyBwcm9wZXJcIixcblx0XHRuaWJibGVOb0RhdGFOYW1lOiBcIkFzc2lnbmEgY2VswrdsZXMgTm9EYXRhXCIsXG5cdFx0ekxpbWl0TmFtZTogXCJMw61taXQgZGUgWlwiLFxuXHRcdGZsb3dEaXJlY3Rpb25UeXBlTmFtZTogXCJUaXB1cyBkZSBkaXJlY2Npw7MgZGVsIGZsdXhcIixcblx0XHR3ZWlnaHRSYXN0ZXJOYW1lOiBcIlLDoHN0ZXIgZGUgcGVzXCIsXG5cdFx0Zm9yY2VFZGdlTmFtZTogXCJGb3LDp2EgcXVlIHRvdGVzIGxlcyBjZWzCt2xlcyBkZSB2b3JlcyBmbHVlaXhpbiBlbmZvcmFcIixcblx0XHRzdHJlYW1SYXN0ZXJOYW1lOiBcIlLDoHN0ZXIgZGUgdHJhbnNtaXNzacOzXCIsXG5cdFx0c3VyZmFjZVJhc3Rlck5hbWU6IFwiUsOgc3RlciBkZSBzdXBlcmbDrWNpZVwiLFxuXHRcdGNvbnZlcnNpb25UeXBlOiBcIlRpcHVzIGRlIGNvbnZlcnNpw7NcIixcblx0XHRkaXN0YW5jZVJhc3RlcjE6IFwiUsOgc3RlciBkZSBkaXN0w6BuY2lhIDFcIixcblx0XHRkaXN0YW5jZVJhc3RlcjI6IFwiUsOgc3RlciBkZSBkaXN0w6BuY2lhIDJcIixcblx0XHRjb3N0RGlzdGFuY2VSYXN0ZXI6IFwiUsOgc3RlciBkZSBjb3N0IGVuIHBsYVwiLFxuXHRcdGNvc3RCYWNrbGlua1Jhc3RlcjogXCJSw6BzdGVyIGQnZW5sbGHDpyBkZSBtZW5vciBjb3N0XCIsXG5cdFx0b3ZlcnJpZGVzTmFtZTogXCJJbnZhbGlkYWNpb25zXCIsXG5cdFx0ZmllbGROYW1lOiBcIkNhbXBcIixcblx0XHRzaWduYXR1cmVGaWxlT3JVcmw6IFwiVVJMIG8gZml0eGVyIGRlIHNpZ25hdHVyYVwiLFxuXHRcdHJlZE5hbWU6IFwiVmVybWVsbFwiLFxuXHRcdGdyZWVuTmFtZTogXCJWZXJkXCIsXG5cdFx0Ymx1ZU5hbWU6IFwiQmxhdVwiLFxuXHRcdGluZnJhcmVkTmFtZTogXCJJbmZyYXJvaWdcIixcblx0XHRwYW5jaHJvbWF0aWNOYW1lOiBcIlBhbmNyb23DoHRpY1wiLFxuXHRcdG11bHRpc3BlY3RyYWxOYW1lOiBcIk11bHRpZXNwZWN0cmFsXCIsXG5cdFx0cGFuc2hhcnBlbmluZ1R5cGU6IFwiVGlwdXMgZCdlbmZvY2FtZW50IHBhbmNyb23DoHRpY1wiLFxuXHRcdHNlbnNvck5hbWU6IFwiU2Vuc29yXCIsXG5cdFx0c3BhdGlhbFJlZmVyZW5jZU5hbWU6IFwiUmVmZXLDqG5jaWEgZXNwYWNpYWxcIixcblx0XHR4Q2VsbHNpemVOYW1lOiBcIk1pZGEgZGUgY2VswrdsYSBYXCIsXG5cdFx0eUNlbGxzaXplTmFtZTogXCJNaWRhIGRlIGNlbMK3bGEgWVwiLFxuXHRcdHhPcmlnaW5OYW1lOiBcIlB1bnQgZGUgcmVnaXN0cmUgWFwiLFxuXHRcdHlPcmlnaW5OYW1lOiBcIlB1bnQgZGUgcmVnaXN0cmUgWVwiLFxuXHRcdHBlcmNlbnRpbGVOYW1lOiBcIlZhbG9yIGRlIHBlcmNlbnRpbFwiLFxuXHRcdG5laWdoYm9yaG9vZFR5cGU6IFwiVGlwdXMgZGUgdmXDr25hdFwiLFxuXHRcdHdpZHRoTmFtZTogXCJBbXBsYWRhXCIsXG5cdFx0aGVpZ2h0TmFtZTogXCJBbHR1cmFcIixcblx0XHRzdGFydEFuZ2xlTmFtZTogXCJBbmdsZSBkJ2luaWNpXCIsXG5cdFx0ZW5kQW5nbGVOYW1lOiBcIkFuZ2xlIGRlIGZpbmFsaXR6YWNpw7NcIixcblx0XHRuZWlnaGJvcmhvb2RWYWx1ZXM6IFwiVmFsb3JzIGRlIHZlw69uYXRcIixcblx0XHRob3Jpem9udGFsUmFzdGVyOiBcIlLDoHN0ZXIgaG9yaXR6b250YWxcIixcblx0XHRob3Jpem9udGFsRmFjdG9yOiBcIkZhY3RvciBob3JpdHpvbnRhbFwiLFxuXHRcdHZlcnRpY2FsUmFzdGVyOiBcIlLDoHN0ZXIgdmVydGljYWxcIixcblx0XHR2ZXJ0aWNhbEZhY3RvcjogXCJGYWN0b3IgdmVydGljYWxcIixcblx0XHRzdHJlYW1SYXN0ZXI6IFwiUsOgc3RlciBkZSB0cmFuc21pc3Npw7NcIixcblx0XHRmbG93RGlyUmFzdGVyOiBcIlLDoHN0ZXIgZGUgZGlyZWNjacOzIGRlbCBmbHV4XCIsXG5cdFx0bnVtYmVyTmVpZ2hib3JDZWxsczogXCJOb21icmUgZGUgY2VswrdsZXMgdmXDr25lc1wiLFxuXHRcdHpvbmVDb25uZWN0aXZpdHk6IFwiQ29ubmVjdGl2aXRhdCBkZSBsYSB6b25hXCIsXG5cdFx0YWRkTGlua0JlaGF2aW9yOiBcIkFmZWdlaXggdW4gZW5sbGHDp1wiLFxuXHRcdGV4Y2x1ZGVkVmFsdWU6IFwiVmFsb3IgZXhjbMOyc1wiLFxuXHRcdGNvbnN0YW50RmlsbENoZWNrOiBcIkdlbmVyYSB1biByw6BzdGVyIGQnZW1wbGVuYW1lbnQgYSBwYXJ0aXIgZGUgbGEgY29uc3RhbnRcIixcblx0XHRmaWxsUmFzdGVyOiBcIlLDoHN0ZXIgZCdlbXBsZW5hbWVudFwiLFxuXHRcdGNvbnN0YW50RmlsbFZhbHVlOiBcIlZhbG9yIGNvbnN0YW50XCIsXG5cdFx0aW5wdXRCaXRQb3NpdGlvbnM6IFwiQml0IGQnZW50cmFkYVwiLFxuXHRcdG91dHB1dEJpdFBvc2l0aW9uczogXCJCaXQgZGUgc29ydGlkYVwiLFxuXHRcdGRpc3RhbmNlVHlwZU5hbWU6IFwiVGlwdXMgZGUgZGlzdMOgbmNpYVwiLFxuXHRcdGJhcnJpZXJEYXRhTmFtZTogXCJCYXJyZXJlcyBkZSByw6BzdGVyXCIsXG5cdFx0cG91clBvaW50RGF0YU5hbWU6IFwiUsOgc3RlciBkZSBwdW50cyBkZSBmbHXDr2Rlc2FcIixcblx0XHRhY2N1bXVsYXRpb25SYXN0ZXJOYW1lOiBcIlLDoHN0ZXIgZCdhY3VtdWxhY2nDsyBkZSBmbHV4XCIsXG5cdFx0c25hcERpc3RhbmNlTmFtZTogXCJEaXN0w6BuY2lhIGQnYWxpbmVhY2nDs1wiLFxuXHRcdG9yZGVyTWV0aG9kTmFtZTogXCJNw6h0b2RlIGQnb3JkZW5hY2nDs1wiLFxuXHRcdGRpcmVjdGlvbk1lYXN1cmVtZW50TmFtZTogXCJEaXJlY2Npw7MgZGUgbWVzdXJhXCIsXG5cdFx0cHJvY2Vzc0FzTXVsdGliYW5kOiBcIlByb2Nlc3NhIGNvbSBhIG11bHRpYmFuZGFcIixcblx0XHRwcm9jZXNzTXVsdGlkaW1lbnNpb25hbDogXCJQcm9jZXNzYSBjb20gYSBtdWx0aWRpbWVuc2lvbmFsXCIsXG5cdFx0Zm9yY2VGbG93RGlyZWN0aW9uQ29udmVudGlvbjogXCJGb3LDp2EgbGEgY29udmVuY2nDsyBkZSBsYSBkaXJlY2Npw7MgZGVsIGZsdXggcGVyIGFsIHLDoHN0ZXIgZCdlbmxsYcOnIGRlIG1lbm9yIGNvc3RcIixcblx0XHRpbml0aWFsQWNjdW11bGF0aW9uOiBcIkFjdW11bGFjacOzIGluaWNpYWxcIixcblx0XHRtYXhpbXVtQWNjdW11bGF0aW9uOiBcIkFjdW11bGFjacOzIG3DoHhpbWFcIixcblx0XHRzb3VyY2VMb2NhdGlvbkJhbmRzOiBcIkdlbmVyYSB1bmEgZmlsYSBpIHVuYSBjb2x1bW5hIGQnb3JpZ2VuIGNvbSBhIGJhbmRlcyBvcmlnaW5hbHMgYSBsYSBzb3J0aWRhXCIsXG5cdFx0YmFja0RpcmVjdGlvbkJhbmQ6IFwiR2VuZXJhIGxhIGRpcmVjY2nDsyBpbnZlcnNhIGNvbSBhIGJhbmRhIG9yaWdpbmFsIGEgbGEgc29ydGlkYVwiLFxuXHRcdG51bWJlck9mQ2VsbHM6IFwiTm9tYnJlIGRlIGNlbMK3bGVzXCIsXG5cdFx0em9uZVZhbHVlczogXCJWYWxvcnMgZGUgem9uYVwiLFxuXHRcdHNocmlua01ldGhvZDogXCJNw6h0b2RlIGRlIHJlZHVjY2nDs1wiLFxuXHRcdGV4cGFuZE1ldGhvZDogXCJNw6h0b2RlIGQnZXhwYW5zacOzXCIsXG5cdFx0aW5wdXRTcGVjdHJhbFByb2ZpbGVUeXBlOiBcIlRpcHVzIGRlIHBlcmZpbCBlc3BlY3RyYWxcIixcblx0XHRzcGVjdHJhbFByb2ZpbGVGaWxlTmFtZTogXCJQZXJmaWwgZXNwZWN0cmFsXCIsXG5cdFx0dHJhaW5pbmdGZWF0dXJlRmlsZU5hbWU6IFwiRW50aXRhdCBkZSBmb3JtYWNpw7NcIixcblx0XHRub25OZWdhdGl2ZTogXCJObyBuZWdhdGl1XCIsXG5cdFx0c3VtVG9PbmU6IFwiU3VtYSB1XCIsXG5cdFx0cmFuZG9tRGlzdHJpYnV0aW9uOiBcIkRpc3RyaWJ1Y2nDs1wiLFxuXHRcdG1lYW5OYW1lOiBcIk1pdGphXCIsXG5cdFx0cHJvYmFiaWxpdHlOYW1lOiBcIlByb2JhYmlsaXRhdFwiLFxuXHRcdGFscGhhTmFtZTogXCJBbGZhXCIsXG5cdFx0YmV0YU5hbWU6IFwiQmV0YVwiLFxuXHRcdHJOYW1lOiBcInJcIixcblx0XHRuTmFtZTogXCJOXCIsXG5cdFx0c2VlZDogXCJPcmlnaW5hXCIsXG5cdFx0cmFuZG9tTnVtYmVyR2VuZXJhdG9yOiBcIkdlbmVyYWRvciBkZSBuw7ptZXJvcyBhbGVhdG9yaW9zXCIsXG5cdFx0Y2VsbEZhY3RvcjogXCJGYWN0b3IgZGUgY2VswrdsYVwiLFxuXHRcdGFnZ3JlZ2F0aW9uVHlwZTogXCJUw6ljbmljYSBkZSBhZ3JlZ2FjacOzblwiLFxuXHRcdGV4dGVudEhhbmRsaW5nOiBcIkFtcGxpYXIgbGEgZXh0ZW5zacOzbiBzaSBlcyBuZWNlc2FyaW9cIixcblx0XHR0cmVuZEFuYWx5c2lzRGltZW5zaW9uTmFtZTogXCJOb20gZGUgbGEgZGltZW5zacOzXCIsXG5cdFx0dHJlbmRBbmFseXNpc1R5cGU6IFwiVGlwdXMgZGUgdGVuZMOobmNpYVwiLFxuXHRcdGhhcm1vbmljRnJlcXVlbmN5OiBcIkZyZXHDvMOobmNpYSBoYXJtw7JuaWNhXCIsXG5cdFx0cG9seW5vbWlhbE9yZGVyOiBcIk9yZHJlIHBvbGluw7JtaWNcIixcblx0XHRjeWNsZUxlbmd0aE5hbWU6IFwiRHVyYWRhIGRlbCBjaWNsZVwiLFxuXHRcdHRyZW5kQW5hbHlzaXNSTVNFOiBcIlJNU0VcIixcblx0XHR0cmVuZEFuYWx5c2lzUjI6IFwiUiBxdWFkcmF0XCIsXG5cdFx0dHJlbmRBbmFseXNpc1Nsb3BlUFZhbHVlOiBcIlZhbG9yIFAgZGVsIGNvZWZpY2llbnQgZGUgcGVuZGVudFwiLFxuXHRcdHRyZW5kQW5hbHlzaXNTZWFzb25hbFBlcmlvZDogXCJQZXLDrW9kZSBlc3RhY2lvbmFsXCIsXG5cdFx0Y3ljbGVVbml0TmFtZTogXCJVbml0YXQgZGVsIGNpY2xlXCIsXG5cdFx0cHJlZGljdERpbWVuc2lvblZhbHVlczogXCJWYWxvcnNcIixcblx0XHRkaW1lbnNpb25EZWZpbml0aW9uVHlwZTogXCJEZWZpbmljacOzIGRlIGxhIGRpbWVuc2nDs1wiLFxuXHRcdHByZWRpY3REaW1lbnNpb25TdGFydDogXCJQcmluY2lwaVwiLFxuXHRcdHByZWRpY3REaW1lbnNpb25FbmQ6IFwiRmluYWxcIixcblx0XHRwcmVkaWN0RGltZW5zaW9uSW50ZXJ2YWw6IFwiSW50ZXJ2YWwgZGUgdmFsb3JzXCIsXG5cdFx0ZGltZW5zaW9uVW5pdDogXCJVbml0YXRcIixcblx0XHRpbnRlcnBvbGF0aW9uQ2VsbHNpemVOYW1lOiBcIk1pZGEgZGUgY2VswrdsYSBkZSBsYSBpbnRlcnBvbGFjacOzXCIsXG5cdFx0dmFyaWFibGVOYW1lOiBcIlZhcmlhYmxlc1wiLFxuXHRcdGRpbWVuc2lvbmxlc3NOYW1lOiBcIkFkaW1lbnNpb25hbFwiLFxuXHRcdG1kaW1EZWZpbml0aW9uOiBcIkRlZmluaWNpw7MgZGUgbGEgZGltZW5zacOzXCIsXG5cdFx0ZGltZW5zaW9uTmFtZTogXCJEaW1lbnNpw7NcIixcblx0XHRpdGVyYXRpb25TdGFydDogXCJJbmljaSBkZSBsYSBwcmltZXJhIGl0ZXJhY2nDs1wiLFxuXHRcdGl0ZXJhdGlvbkVuZDogXCJGaW5hbCBkZSBsYSBwcmltZXJhIGl0ZXJhY2nDs1wiLFxuXHRcdGludGVydmFsU3RhcnQ6IFwiSW5pY2kgZGUgbCdpbnRlcnZhbFwiLFxuXHRcdGludGVydmFsRW5kOiBcIkZpbmFsIGRlIGwnaW50ZXJ2YWxcIixcblx0XHRzdGVwTmFtZTogXCJQYXNcIixcblx0XHRyYW5nZXNOYW1lOiBcIkludGVydmFsc1wiLFxuXHRcdG1pblZhbHVlOiBcIlZhbG9yIG3DrW5pbVwiLFxuXHRcdG1heFZhbHVlOiBcIlZhbG9yIG3DoHhpbVwiLFxuXHRcdGNoYW5nZUFuYWx5c2lzUmFzdGVyTmFtZTogXCJSw6BzdGVyIGTigJlhbsOgbGlzaSBkZSBjYW52aXNcIixcblx0XHRjaGFuZ2VUeXBlTmFtZTogXCJDYW52aWEgZWwgdGlwdXNcIixcblx0XHRzZWdtZW50RGF0ZTogXCJEYXRhIGRlIHNlZ21lbnRcIixcblx0XHRjaGFuZ2VEaXJlY3Rpb25OYW1lOiBcIkRpcmVjY2nDsyBkZSBjYW52aVwiLFxuXHRcdG1heE51bUNoYW5nZXNOYW1lOiBcIk5vbWJyZSBtw6B4aW0gZGUgY2FudmlzXCIsXG5cdFx0ZmlsdGVyQnlZZWFyOiBcIkZpbHRyYSBwZXIgYW55XCIsXG5cdFx0bWluaW11bVllYXI6IFwiVmFsb3IgbcOtbmltXCIsXG5cdFx0bWF4aW11bVllYXI6IFwiVmFsb3IgbcOgeGltXCIsXG5cdFx0ZmlsdGVyQnlEdXJhdGlvbjogXCJGaWx0cmEgcGVyIGR1cmFkYVwiLFxuXHRcdG1pbmltdW1EdXJhdGlvbjogXCJEdXJhZGEgbcOtbmltYVwiLFxuXHRcdG1heGltdW1EdXJhdGlvbjogXCJEdXJhZGEgbcOgeGltYVwiLFxuXHRcdGZpbHRlckJ5TWFnbml0dWRlOiBcIkZpbHRyYSBwZXIgbWFnbml0dWRcIixcblx0XHRtaW5pbXVtTWFnbml0dWRlOiBcIk1hZ25pdHVkIG3DrW5pbWFcIixcblx0XHRtYXhpbXVtTWFnbml0dWRlOiBcIk1hZ25pdHVkIG3DoHhpbWFcIixcblx0XHRmaWx0ZXJCeVN0YXJ0VmFsdWU6IFwiRmlsdHJhIHBlciB2YWxvciBpbmljaWFsXCIsXG5cdFx0bWluaW11bVN0YXJ0VmFsdWU6IFwiVmFsb3IgaW5pY2lhbCBtw61uaW1cIixcblx0XHRtYXhpbXVtU3RhcnRWYWx1ZTogXCJWYWxvciBpbmljaWFsIG3DoHhpbVwiLFxuXHRcdGZpbHRlckJ5RW5kVmFsdWU6IFwiRmlsdHJhIHBlciB2YWxvciBmaW5hbFwiLFxuXHRcdG1pbmltdW1FbmRWYWx1ZTogXCJWYWxvciBmaW5hbCBtw61uaW1cIixcblx0XHRtYXhpbXVtRW5kVmFsdWU6IFwiVmFsb3IgZmluYWwgbcOgeGltXCIsXG5cdFx0bW9kZWxUeXBlTmFtZTogXCJUaXB1cyBkZSBtb2RlbFwiLFxuXHRcdGZyb21SYXN0ZXJOYW1lOiBcIkRlIHLDoXN0ZXJcIixcblx0XHR0b1Jhc3Rlck5hbWU6IFwiQSByw6FzdGVyXCIsXG5cdFx0Y29tcHV0ZUNoYW5nZU1ldGhvZDogXCJDYWxjdWxhIGVsIG3DqHRvZGUgZGUgY2FudmlcIixcblx0XHRmcm9tQ2xhc3NWYWx1ZXM6IFwiRGVzIGRlIHZhbG9ycyBkZSBjbGFzc2UgKEV4ZW1wbGU6IDIgNSlcIixcblx0XHR0b0NsYXNzVmFsdWVzOiBcIkZpbnMgYSB2YWxvcnMgZGUgY2xhc3NlIChFeGFtcGxlOiAyIDUpXCIsXG5cdFx0a2VlcE1ldGhvZDogXCJNw6h0b2RlIGRlIGZpbHRyYXRnZVwiLFxuXHRcdHVzZUNvbG9yTWV0aG9kOiBcIkRlZmluZWl4IGNvbG9ycyBkZSB0cmFuc2ljacOzXCIsXG5cdFx0ZGV0ZWN0Q2hhbmdlQmFuZHM6IFwiQmFuZGVzIHBlciBkZXRlY3RhciBjYW52aXMgKGNvbWVuw6dhIGFsIDApXCIsXG5cdFx0dG1hc2tCYW5kczogXCJCYW5kZXMgZCdlbW1hc2NhcmFtZW50IHRlbXBvcmFsIChjb21lbsOnYSBhbCAwKVwiLFxuXHRcdGNoaVNxdWFyZWRUaHJlc2hvbGQ6IFwiTGxpbmRhciBkZSBraGkgcXVhZHJhdCBwZXIgZGV0ZWN0YXIgY2FudmlzXCIsXG5cdFx0bWluQW5vbWFseTogXCJPYnNlcnZhY2lvbnMgZCdhbm9tYWxpZXMgY29uc2VjdXRpdmVzIG3DrW5pbWVzXCIsXG5cdFx0dXBkYXRpbmdGcmVxdWVuY3k6IFwiQWN0dWFsaXR6YW50IGxhIGZyZXHDvMOobmNpYSBkJ2FqdXN0YW1lbnQgKGVuIGFueXMpXCIsXG5cdFx0ZGlzdGFuY2VBY2N1bXVsYXRpb25SYXN0ZXJOYW1lOiBcIlLDoHN0ZXIgZCdhY3VtdWxhY2nDsyBkZSBkaXN0w6BuY2lhXCIsXG5cdFx0Y29zdEJhY2tkaXJlY3Rpb25SYXN0ZXJOYW1lOiBcIlLDoHN0ZXIgZGUgZGlyZWNjacOzIGRlbCBmbHV4IG8gZGUgZGlyZWNjacOzIGludmVyc2FcIixcblx0XHRyYXN0ZXJDb2xsZWN0aW9uTmFtZTogXCJDYXB0dXJhIGRlIHLDoHN0ZXJzXCIsXG5cdFx0aXRlbUZ1bmN0aW9uTmFtZTogXCJGdW5jacOzIGQnZWxlbWVudFwiLFxuXHRcdGFnZ3JlZ2F0aW9uRnVuY3Rpb25OYW1lOiBcIkZ1bmNpw7MgZCdhZ3JlZ2FjacOzXCIsXG5cdFx0cHJvY2Vzc2luZ0Z1bmN0aW9uTmFtZTogXCJGdW5jacOzIGRlIHByb2Nlc3NhbWVudFwiLFxuXHRcdGFnZ3JlZ2F0aW9uRGVmaW5pdGlvbk5hbWU6IFwiRGVmaW5pY2nDsyBkJ2FncmVnYWNpw7NcIixcblx0XHRxdWVyeUdlb21ldHJ5TmFtZTogXCJDb25zdWx0YSBsYSBnZW9tZXRyaWFcIixcblx0XHRmYWN0b3JGdW5jdGlvblplcm9GYWN0b3I6IFwiRmFjdG9yIHplcm9cIixcblx0XHRmYWN0b3JGdW5jdGlvbkN1dEFuZ2xlOiBcIkFuZ2xlIGRlIHRhbGxcIixcblx0XHRmYWN0b3JGdW5jdGlvblNpZGVGYWN0b3I6IFwiRmFjdG9yIGxhdGVyYWxcIixcblx0XHRmYWN0b3JGdW5jdGlvblNsb3BlOiBcIlBlbmRlbnRcIixcblx0XHRmYWN0b3JGdW5jdGlvbkxvd0N1dEFuZ2xlOiBcIkFuZ2xlIGRlIHRhbGwgYmFpeFwiLFxuXHRcdGZhY3RvckZ1bmN0aW9uSGlnaEN1dEFuZ2xlOiBcIkFuZ2xlIGRlIHRhbGwgYWx0XCIsXG5cdFx0ZmFjdG9yRnVuY3Rpb25Db3NQb3dlcjogXCJQb3TDqG5jaWEgZGVsIGNvc2ludXNcIixcblx0XHRmYWN0b3JGdW5jdGlvblNlY1Bvd2VyOiBcIlBvdMOobmNpYSBkZSBsYSBzZWNhbnRcIixcblx0XHRmYWN0b3JGdW5jdGlvblRhYmxlUGF0aDogXCJSdXRhIGRlIGxhIHRhdWxhXCIsXG5cdFx0cHJvY2Vzc2luZ0JhbmQ6IFwiQmFuZGEgZGUgcHJvY2Vzc2FtZW50XCIsXG5cdFx0cHJvY2Vzc2luZ0JhbmROYW1lOiBcIk5vbSBkZSBsYSBiYW5kYSBkZSBwcm9jZXNzYW1lbnRcIixcblx0XHRzbmFwcGluZ0RhdGU6IFwiRGF0YSBpbnN0YW50w6BuaWFcIixcblx0XHRtYXhOdW1TZWdtZW50czogXCJOb21icmUgbcOgeGltIGRlIHNlZ21lbnRzXCIsXG5cdFx0dmVydGV4Q291bnRPdmVyc2hvb3Q6IFwiT3ZlcnNob290IGRlIHJlY29tcHRlIGRlIHbDqHJ0ZXhcIixcblx0XHRzcGlrZVRocmVzaG9sZDogXCJMw61taXQgZGUgcHVudGFcIixcblx0XHRyZWNvdmVyeVRocmVzaG9sZDogXCJMw61taXQgZGUgcmVjdXBlcmFjacOzXCIsXG5cdFx0bWluTnVtT2JzOiBcIkNhbnRpZGFkIG3DrW5pbWEgZGUgb2JzZXJ2YWNpb25lc1wiLFxuXHRcdHBWYWx1ZVRocmVzaG9sZDogXCJMw61taXQgZGUgUC1WYWx1ZVwiLFxuXHRcdGJlc3RNb2RlbFByb3BvcnRpb246IFwiTWlsbG9yIHByb3BvcmNpw7MgZGUgbW9kZWxcIixcblx0XHRwcmV2ZW50T25lWWVhclJlY292ZXJ5OiBcIkV2aXRhciByZWN1cGVyYWNpw7MgZOKAmXVuIGFueVwiLFxuXHRcdHJlY292ZXJ5SW5jcmVhc2VUcmVuZDogXCJMYSByZWN1cGVyYWNpw7MgdMOpIHRlbmTDqG5jaWEgY3JlaXhlbnRcIixcblx0XHRvdXRwdXRPdGhlckJhbmRzOiBcIlJlc3VsdGF0IGFsdHJlcyBiYW5kZXNcIixcblx0XHRzb3J0VHlwZTogXCJUaXB1cyBkJ29yZGVuYWNpw7NcIixcblx0XHRudW1iZXJPZlJ1bnM6IFwiRXhlY3V0YSBsJ2V4cGFuc2nDsyBpIGxhIHJlZHVjY2nDsyBkdWVzIHZlZ2FkZXNcIixcblx0XHRwZXJjZW50aWxlVmFsdWU6IFwiVmFsb3IgZGUgcGVyY2VudGlsXCIsXG5cdFx0cGVyY2VudGlsZUludGVycG9sYXRpb25UeXBlOiBcIlRpcHVzIGQnaW50ZXJwb2xhY2nDsyBkZWwgcGVyY2VudGlsXCIsXG5cdFx0cmFzdGVySW5mb1Byb3BlcnR5OiBcIlByb3BpZXRhdFwiLFxuXHRcdHJhc3RlckluZm9WYWx1ZTogXCJWYWxvclwiLFxuXHRcdHJhc3RlckluZm9Db2x1bW5zOiBcIkNvbHVtbmVzXCIsXG5cdFx0cmFzdGVySW5mb1Jvd3M6IFwiRmlsZXNcIixcblx0XHRyYXN0ZXJJbmZvQmFuZENvdW50OiBcIk5vbWJyZSBkZSBiYW5kZXNcIixcblx0XHRyYXN0ZXJJbmZvUGl4ZWxTaXplWDogXCJNaWRhIFggZGUgbGEgY2VswrdsYVwiLFxuXHRcdHJhc3RlckluZm9QaXhlbFNpemVZOiBcIk1pZGEgWSBkZSBsYSBjZWzCt2xhXCIsXG5cdFx0cmFzdGVySW5mb1BpeGVsVHlwZTogXCJUaXB1cyBkZSBww614ZWxcIixcblx0XHRyYXN0ZXJFeHRlbnRUb3A6IFwiU3VwZXJpb3JcIixcblx0XHRyYXN0ZXJFeHRlbnRCb3R0b206IFwiSW5mZXJpb3JcIixcblx0XHRyYXN0ZXJFeHRlbnRMZWZ0OiBcIkVzcXVlcnJhXCIsXG5cdFx0cmFzdGVyRXh0ZW50UmlnaHQ6IFwiRHJldGFcIixcblx0XHRyYXN0ZXJTdGF0aXN0aWNzTm90Q2FsY3VsYXRlZDogXCJObyBzJ2hhbiBjYWxjdWxhdCBsZXMgZXN0YWTDrXN0aXF1ZXMuXCIsXG5cdFx0c3BhdGlhbFJlZmVyZW5jZVByb2plY3Rpb246IFwiUHJvamVjY2nDs1wiLFxuXHRcdHNwYXRpYWxSZWZlcmVuY2VXa2lkOiBcIldLSURcIixcblx0XHRzcGF0aWFsUmVmZXJlbmNlTGF0ZXN0V2tpZDogXCJXS0lEIGFudGVyaW9yXCIsXG5cdFx0c3BhdGlhbFJlZmVyZW5jZVdrdDogXCJXS1RcIixcblx0XHRzcGF0aWFsUmVmZXJlbmNlVmNzV2tpZDogXCJWQ1NXS0lEXCIsXG5cdFx0c3BhdGlhbFJlZmVyZW5jZUxhdGVzdFZjc1draWQ6IFwiVkNTV0tJRCBhbnRlcmlvclwiLFxuXHRcdHNwYXRpYWxSZWZlcmVuY2VBdXRob3JpdHk6IFwiQXV0b3JpdGF0XCIsXG5cdFx0c3BhdGlhbFJlZmVyZW5jZUxpbmVhclVuaXQ6IFwiVW5pdGF0IGxpbmVhbFwiLFxuXHRcdHNwYXRpYWxSZWZlcmVuY2VBbmd1bGFyVW5pdDogXCJVbml0YXQgYW5ndWxhclwiLFxuXHRcdHNwYXRpYWxSZWZlcmVuY2VGYWxzZUVhc3Rpbmc6IFwiRmFscyBlc3RcIixcblx0XHRzcGF0aWFsUmVmZXJlbmNlRmFsc2VOb3J0aGluZzogXCJGYWxzIG5vcmRcIixcblx0XHRzcGF0aWFsUmVmZXJlbmNlQ2VudHJhbE1lcmlkaWFuOiBcIk1lcmlkacOgIGNlbnRyYWxcIixcblx0XHRzcGF0aWFsUmVmZXJlbmNlUHJpbWVNZXJpZGlhbjogXCJNZXJpZGnDoCBpbmljaWFsXCIsXG5cdFx0c3BhdGlhbFJlZmVyZW5jZVN0YW5kYXJkUGFyYWxsZWwxOiBcIlBhcmFswrdsZWwgZXN0w6BuZGFyZCAxXCIsXG5cdFx0c3BhdGlhbFJlZmVyZW5jZVN0YW5kYXJkUGFyYWxsZWwyOiBcIlBhcmFswrdsZWwgZXN0w6BuZGFyZCAyXCIsXG5cdFx0c3BhdGlhbFJlZmVyZW5jZUxhdGl0dWRlT2ZPcmlnaW46IFwiTGF0aXR1ZCBkZSBsJ29yaWdlblwiLFxuXHRcdHNwYXRpYWxSZWZlcmVuY2VBdXhpbGlhcnlTcGhlcmVUeXBlOiBcIlRpcHVzIGQnZXNmZXJhIGF1eGlsaWFyXCIsXG5cdFx0c3BhdGlhbFJlZmVyZW5jZURhdHVtOiBcIkRhdHVtXCIsXG5cdFx0c3BhdGlhbFJlZmVyZW5jZVNwaGVyb2lkOiBcIkVzZmVyb2lkZVwiLFxuXHRcdHNwYXRpYWxSZWZlcmVuY2VTZW1pbWFqb3JBeGlzOiBcIlNlbWllaXggbWFqb3JcIixcblx0XHRzcGF0aWFsUmVmZXJlbmNlU2VtaW1pbm9yQXhpczogXCJTZW1pZWl4IG1lbm9yXCIsXG5cdFx0c3BhdGlhbFJlZmVyZW5jZUludmVyc2VGbGF0dGVuaW5nOiBcIkFwbGF0YW1lbnQgaW52ZXJzXCIsXG5cdFx0aW5wdXREZWZpbml0aW9uRmlsZU5hbWU6IFwiRml0eGVyIGRlIGRlZmluaWNpw7MgZCdlbnRyYWRhXCIsXG5cdFx0ZGVsZXRlTmFtZTogXCJTdXByaW1laXhcIixcblx0XHRhZGRWYXJpYWJsZU5hbWU6IFwiQWdyZWdhciB2YXJpYWJsZVwiLFxuXHRcdG1heE51bVBpeGVsc1BlclNlZ21lbnQ6IFwiTWlkYSBkZSBzZWdtZW50IG3DoHhpbWEgZW4gcMOteGVsc1wiLFxuXHRcdGZvcndhcmRXaW5kb3dOYW1lOiBcIkZpbmVzdHJhIEVuZGF2YW50XCIsXG5cdFx0YmFja3dhcmRXaW5kb3dOYW1lOiBcIkZpbmVzdHJhIEVucmVyZVwiLFxuXHRcdG5vRGF0YUhhbmRsaW5nTmFtZTogXCJUcmFjdGFtZW50IGRlIE5vRGF0YVwiLFxuXHRcdGNpcmN1bGFyV3JhcFZhbHVlTmFtZTogXCJWYWxvciBkJ2FqdXN0IGNpcmN1bGFyXCIsXG5cdFx0ZnJvbUNsYXNzTmFtZUZpZWxkTmFtZTogXCJOb20gZGUgY2FtcCBwZXIgYSBub21zIGRlIGNsYXNzZXMgYWwgcsOgc3RlciBkJ29yaWdlblwiLFxuXHRcdHRvQ2xhc3NOYW1lRmllbGROYW1lOiBcIk5vbSBkZSBjYW1wIHBlciBhIG5vbXMgZGUgY2xhc3NlcyBhbCByw6BzdGVyIGRlIGRlc3RpbmFjacOzXCIsXG5cdFx0dGFyZ2V0UmFzdGVyTmFtZTogXCJSw6BzdGVyIGRlIGRlc3RpbmFjacOzXCIsXG5cdFx0Y2lyY3VsYXJXcmFwVmFsdWU6IFwiVmFsb3IgZCdhanVzdCBjaXJjdWxhclwiLFxuXHRcdGJhbmRJbmRleGVzUjogXCJFeHByZXNzacOzIGVuIHZlcm1lbGxcIixcblx0XHRiYW5kSW5kZXhlc0c6IFwiRXhwcmVzc2nDsyBlbiB2ZXJkXCIsXG5cdFx0YmFuZEluZGV4ZXNCOiBcIkV4cHJlc3Npw7MgZW4gYmxhdVwiLFxuXHRcdGV4YW1wbGVOYW1lOiBcIkV4ZW1wbGVcIixcblx0XHRpbnB1dE5hbWU6IFwiRW50cmFkYVwiLFxuXHRcdG91dHB1dE5hbWU6IFwiU29ydGlkYVwiLFxuXHRcdG9wdGlvbmFsTmFtZTogXCJPcGNpb25hbFwiLFxuXHRcdGJyb3dzZURlZmluaXRpb25GaWxlOiBcIk5hdmVnYSBhbCBmaXR4ZXIgZGUgZGVmaW5pY2nDs1wiLFxuXHRcdHNlbGVjdERlZmluaXRpb25GaWxlOiBcIlNlbGVjY2lvbmV1IGVsIGZpdHhlciBkZSBkZWZpbmljacOzIGQnZW50cmFkYVwiLFxuXHRcdGlucHV0RGVmaW5pdGlvblVSTDogXCJVUkwgZGVsIGZpdHhlciBkZSBkZWZpbmljacOzIGQnZW50cmFkYVwiLFxuXHRcdGVudGVyRGVmaW5pdGlvbkZpbGVVUkw6IFwiSW50cm9kdcOvdSBsJ1VSTCBkZWwgZml0eGVyIGRlIGRlZmluaWNpw7NcIixcblx0XHRicm93c2VYTUxGaWxlOiBcIk5hdmVnYSBhbCBmaXR4ZXIgWE1MXCIsXG5cdFx0c2VsZWN0U3RhdHNGaWxlOiBcIlNlbGVjY2lvbmV1IGVsIGZpdHhlciBkJ2VzdGFkw61zdGlxdWVzIGkgZCdoaXN0b2dyYW1lc1wiLFxuXHRcdGVudGVyWE1MRmlsZVVSTDogXCJJbnRyb2R1w691IGwnVVJMIGRlbCBmaXR4ZXIgWE1MXCIsXG5cdFx0eG1sRmlsZVVSTDogXCJVUkwgZGVsIGZpdHhlciBYTUxcIixcblx0XHRjaXJjdWxhckNhbGN1bGF0aW9uOiBcIkNhbGN1bGEgbGVzIGVzdGFkw61zdGlxdWVzIGNpcmN1bGFyc1wiLFxuXHRcdGxvY2FsU3VyZmFjZVR5cGU6IFwiVGlwdXMgZGUgc3VwZXJmw61jaWUgbG9jYWxcIixcblx0XHRzdXJmYWNlUGFyYW1ldGVyVHlwZTogXCJUaXB1cyBkZSBwYXLDoG1ldHJlXCIsXG5cdFx0bmVpZ2hib3Job29kRGlzdGFuY2U6IFwiRGlzdMOgbmNpYSBkZSB2ZcOvbmF0Z2VcIixcblx0XHR1c2VBZGFwdGl2ZU5laWdoYm9yaG9vZDogXCJVdGlsaXR6YSB2ZcOvbmF0Z2UgYWRhcHRhdGl1XCIsXG5cdFx0b3V0cHV0U2xvcGVUeXBlOiBcIk1lc3VyYSBkZWwgcGVuZGVudCBkZSBzb3J0aWRhXCIsXG5cdFx0cHJvamVjdEF6aW11dGhzOiBcIlByb2plY3RlIGQnYXppbXV0cyBnZW9kw6hzaWNzXCIsXG5cdFx0dXNlRXF1YXRvcmlhbEFzcGVjdDogXCJVdGlsaXR6YSBsYSBwcm9qZWNjacOzIGVxdWF0b3JpYWxcIixcblx0XHR6VW5pdDogXCJVbml0YXQgWlwiLFxuXHRcdGFuYWx5c2lzTWFzazogXCJNw6BzY2FyYSBkJ2Fuw6BsaXNpXCIsXG5cdFx0c3RkRGV2aWF0aW9uOiBcIkRlc3ZpYWNpw7MgZXN0w6BuZGFyZFwiLFxuXHRcdFwidHJ1ZVwiOiBcIkNlcnRcIixcblx0XHRcImZhbHNlXCI6IFwiRmFsc1wiLFxuXHRcdGNvc3REaXN0YW5jZVJhc3RlcjE6IFwiUsOgc3RlciBkZSBkaXN0w6BuY2lhIGRlIGNvc3QgYWN1bXVsYXRpdSBkJ2VudHJhZGEgMVwiLFxuXHRcdGNvc3REaXN0YW5jZVJhc3RlcjI6IFwiUsOgc3RlciBkZSBkaXN0w6BuY2lhIGRlIGNvc3QgYWN1bXVsYXRpdSBkJ2VudHJhZGEgMlwiLFxuXHRcdHRocmVzaG9sZDogXCJMbGluZGFyXCIsXG5cdFx0dGhyZXNob2xkTWV0aG9kOiBcIk3DqHRvZGUgZGUgbGxpbmRhclwiLFxuXHRcdGRpcmVjdGlvblJhc3RlcjE6IFwiUsOgc3RlciBkZSBkaXJlY2Npw7MgaW52ZXJzYSBkJ2VudHJhZGEgMVwiLFxuXHRcdGRpcmVjdGlvblJhc3RlcjI6IFwiUsOgc3RlciBkZSBkaXJlY2Npw7MgaW52ZXJzYSBkJ2VudHJhZGEgMlwiLFxuXHRcdG1heEl0ZXJhdGlvbnM6IFwiTm9tYnJlIG3DoHhpbSBkJ2l0ZXJhY2lvbnNcIixcblx0XHRlcHNpbG9uOiBcIsOIcHNpbG9uXCJcblx0fSxcblx0ZW51bUxhYmVsczoge1xuXHRcdGF0dHJpYnV0ZVRhYmxlVHlwZU1hbnVhbDogXCJNYW51YWxcIixcblx0XHRhdHRyaWJ1dGVUYWJsZVR5cGVFeHRlcm5hbDogXCJFeHRlcm5cIixcblx0XHRjbHJTY2hlbWVUeXBlQ29sb3JtYXA6IFwiTWFwYSBkZSBjb2xvclwiLFxuXHRcdGNsclNjaGVtZVR5cGVDb2xvclJhbXA6IFwiUmFtcGEgZGUgY29sb3JcIixcblx0XHRjb2xvcm1hcFR5cGVFbGV2YXRpb246IFwiRWxldmFjacOzXCIsXG5cdFx0Y29sb3JtYXBUeXBlR3JheTogXCJHcmlzXCIsXG5cdFx0Y29sb3JtYXBUeXBlTkRWSTogXCJORFZJXCIsXG5cdFx0Y29sb3JtYXBUeXBlTkRWSTI6IFwiTkRWSTJcIixcblx0XHRjb2xvcm1hcFR5cGVORFZJMzogXCJORFZJM1wiLFxuXHRcdGNvbG9ybWFwVHlwZVJhbmRvbTogXCJBbGVhdG9yaVwiLFxuXHRcdG5vbmU6IFwiQ2FwXCIsXG5cdFx0c2xvcGVUeXBlQWRqdXN0ZWQ6IFwiQWp1c3RhdFwiLFxuXHRcdHNsb3BlVHlwZURlZ3JlZTogXCJHcmF1XCIsXG5cdFx0c2xvcGVUeXBlUGVyY2VudFJpc2U6IFwiUGVyY2VudFJpc2VcIixcblx0XHRzbG9wZVR5cGVTY2FsZWQ6IFwiRXNjYWxhdFwiLFxuXHRcdHN0cmV0Y2hUeXBlTWluTWF4OiBcIk1pbk1heFwiLFxuXHRcdHN0cmV0Y2hUeXBlUGVyY2VudE1pbk1heDogXCJQZXJjZW50TWluTWF4XCIsXG5cdFx0c3RyZXRjaFR5cGVTaWdtb2lkOiBcIlNpZ21vaWRlXCIsXG5cdFx0c3RyZXRjaFR5cGVTdGREZXY6IFwiRGVzdi4gZXN0LlwiLFxuXHRcdGhpbGxzaGFkZVR5cGVTaW1wbGU6IFwiVHJhZGljaW9uYWxcIixcblx0XHRoaWxsc2hhZGVUeXBlTXVsdGlkaXJlY3Rpb25hbDogXCJNdWx0aWRpcmVjY2lvbmFsXCIsXG5cdFx0YmFuZENvbWJvQnlOYW1lczogXCJOb21zIGRlIGJhbmRhXCIsXG5cdFx0YmFuZENvbWJvQnlXYXZlbGVuZ3RoOiBcIkxvbmdpdHVkcyBkJ29uYSBkZSBiYW5kZXNcIixcblx0XHRiYW5kQ29tYm9CeUlEczogXCJJRCBkZSBiYW5kYVwiLFxuXHRcdG1pc3NpbmdCYW5kQWN0aW9uQmVzdE1hdGNoOiBcIk1pbGxvciBjb2luY2lkw6huY2lhXCIsXG5cdFx0bWlzc2luZ0JhbmRBY3Rpb25GYWlsOiBcIkVycm9yXCIsXG5cdFx0dW5pdFR5cGVDZWxzaXVzOiBcIkNlbHNpdXNcIixcblx0XHR1bml0VHlwZUNlbnRpbWV0ZXJzOiBcIkNlbnTDrW1ldHJlc1wiLFxuXHRcdHVuaXRUeXBlRGVjaW1ldGVyczogXCJEZWPDrW1ldHJlc1wiLFxuXHRcdHVuaXRUeXBlRmFocmVuaGVpdDogXCJGYWhyZW5oZWl0XCIsXG5cdFx0dW5pdFR5cGVGZWV0OiBcIlBldXNcIixcblx0XHR1bml0VHlwZUZlZXRQZXJTZWM6IFwiUGV1cyBwZXIgc2Vnb24gKGZ0L3MpXCIsXG5cdFx0dW5pdFR5cGVJbmNoZXM6IFwiUG9semFkZXNcIixcblx0XHR1bml0VHlwZUtlbHZpbjogXCJLZWx2aW5cIixcblx0XHR1bml0VHlwZUtpbG9tZXRlcnM6IFwiUXVpbMOybWV0cmVzXCIsXG5cdFx0dW5pdFR5cGVLbXNQZXJIb3VyOiBcIlF1aWzDsm1ldHJlcyBwZXIgaG9yYSAoa20vaClcIixcblx0XHR1bml0VHlwZUtub3RzOiBcIk51c29zIChrbilcIixcblx0XHR1bml0VHlwZU1ldGVyczogXCJNZXRyZXNcIixcblx0XHR1bml0VHlwZU1ldGVyc1BlclNlYzogXCJNZXRyZXMgcGVyIHNlZ29uIChtL3MpXCIsXG5cdFx0dW5pdFR5cGVNaWxlczogXCJNaWxsZXNcIixcblx0XHR1bml0VHlwZU1pbGVzUGVySG91cjogXCJNaWxsZXMgcGVyIGhvcmEgKG1waClcIixcblx0XHR1bml0VHlwZU1pbGxpbWV0ZXJzOiBcIk1pbMK3bMOtbWV0cmVzXCIsXG5cdFx0dW5pdFR5cGVOYXV0aWNhbE1pbGVzOiBcIk1pbGxlcyBuw6B1dGlxdWVzXCIsXG5cdFx0dW5pdFR5cGVZYXJkczogXCJJYXJkZXNcIixcblx0XHR1bml0VHlwZURlY2ltYWxEZWdyZWVzOiBcIkdyYXVzIGRlY2ltYWxzXCIsXG5cdFx0dW5pdFR5cGVQb2ludHM6IFwiUHVudHNcIixcblx0XHR1bml0VHlwZVVua25vd246IFwiRGVzY29uZWd1dFwiLFxuXHRcdHVuaXRUeXBlU3FNYXBVbml0czogXCJVbml0YXRzIGRlIG1hcGEgcXVhZHJhZGVzXCIsXG5cdFx0dW5pdFR5cGVTcU1pbGVzOiBcIk1pbGxlcyBxdWFkcmFkZXNcIixcblx0XHR1bml0VHlwZVNxS21zOiBcIlF1aWzDsm1ldHJlcyBxdWFkcmF0c1wiLFxuXHRcdHVuaXRUeXBlQWNyZXM6IFwiQWNyZXNcIixcblx0XHR1bml0VHlwZUhlY3RhcmVzOiBcIkhlY3TDoHJlZXNcIixcblx0XHR1bml0VHlwZVNxWWFyZHM6IFwiSWFyZGVzIHF1YWRyYWRlc1wiLFxuXHRcdHVuaXRUeXBlU3FGdDogXCJQZXVzIHF1YWRyYXRzXCIsXG5cdFx0dW5pdFR5cGVTcUluY2hlczogXCJQb2x6YWRlcyBxdWFkcmFkZXNcIixcblx0XHR1bml0VHlwZVNxTXRzOiBcIk1ldHJlcyBxdWFkcmF0c1wiLFxuXHRcdHVuaXRUeXBlU3FDbXM6IFwiQ2VudMOtbWV0cmVzIHF1YWRyYXRzXCIsXG5cdFx0dW5pdFR5cGVTcU1tczogXCJNaWzCt2zDrW1ldHJlcyBxdWFkcmF0c1wiLFxuXHRcdGNlbGxzaXplVHlwZUZpcnN0OiBcIlByaW1lciBkZVwiLFxuXHRcdGNlbGxzaXplVHlwZU1pbjogXCJNw61uaW0gZGVcIixcblx0XHRjZWxsc2l6ZVR5cGVNYXg6IFwiTcOgeGltIGRlXCIsXG5cdFx0Y2VsbHNpemVUeXBlTWVhbjogXCJNaXRqYSBkZVwiLFxuXHRcdGNlbGxzaXplVHlwZUxhc3Q6IFwiw5psdGltIGRlXCIsXG5cdFx0ZXh0ZW50VHlwZUZpcnN0OiBcIlByaW1lciBkZVwiLFxuXHRcdGV4dGVudFR5cGVJbnRlcnNlY3Rpb246IFwiSW50ZXJzZWNjacOzIGRlXCIsXG5cdFx0ZXh0ZW50VHlwZVVuaW9uOiBcIlVuacOzIGRlXCIsXG5cdFx0ZXh0ZW50VHlwZUxhc3Q6IFwiw5psdGltIGRlXCIsXG5cdFx0bm9EYXRhSW50ZXJwcmV0QW55OiBcIkNvaW5jaWRlaXggYW1iIHF1YWxzZXZvbFwiLFxuXHRcdG5vRGF0YUludGVycHJldEFsbDogXCJDb2luY2lkZWl4IGFtYiB0b3RzXCIsXG5cdFx0Y3VydmF0dXJlVHlwZVN0YW5kYXJkOiBcIkVzdMOgbmRhcmRcIixcblx0XHRjdXJ2YXR1cmVUeXBlUHJvZmlsZTogXCJQZXJmaWxcIixcblx0XHRjdXJ2YXR1cmVUeXBlUGxhbmZvcm06IFwiUGxhXCIsXG5cdFx0ZmlsdGVyVHlwZUxpbmVEZXRlY3Rpb25Ib3Jpem9udGFsOiBcIkRldGVjY2nDsyBkZSBsw61uaWEgaG9yaXR6b250YWxcIixcblx0XHRmaWx0ZXJUeXBlTGluZURldGVjdGlvblZlcnRpY2FsOiBcIkRldGVjY2nDsyBkZSBsw61uaWEgdmVydGljYWxcIixcblx0XHRmaWx0ZXJUeXBlTGluZURldGVjdGlvbkxlZnREaWFnb25hbDogXCJEZXRlY2Npw7MgZGUgbMOtbmlhIGRpYWdvbmFsIGNhcCBhIGwnZXNxdWVycmFcIixcblx0XHRmaWx0ZXJUeXBlTGluZURldGVjdGlvblJpZ2h0RGlhZ29uYWw6IFwiRGV0ZWNjacOzIGRlIGzDrW5pYSBkaWFnb25hbCBjYXAgYSBsYSBkcmV0YVwiLFxuXHRcdGZpbHRlclR5cGVHcmFkaWVudE5vcnRoOiBcIkdyYWRpZW50IG5vcmRcIixcblx0XHRmaWx0ZXJUeXBlR3JhZGllbnRXZXN0OiBcIkdyYWRpZW50IG9lc3RcIixcblx0XHRmaWx0ZXJUeXBlR3JhZGllbnRFYXN0OiBcIkdyYWRpZW50IGVzdFwiLFxuXHRcdGZpbHRlclR5cGVHcmFkaWVudFNvdXRoOiBcIkdyYWRpZW50IHN1ZFwiLFxuXHRcdGZpbHRlclR5cGVHcmFkaWVudE5vcnRoRWFzdDogXCJHcmFkaWVudCBub3JkLWVzdFwiLFxuXHRcdGZpbHRlclR5cGVHcmFkaWVudE5vcnRoV2VzdDogXCJHcmFkaWVudCBub3JkLW9lc3RcIixcblx0XHRmaWx0ZXJUeXBlU21vb3RoQXJpdGhtZXRpY01lYW46IFwiTWl0amEgYXJpdG3DqHRpY2EgZGUgc3Vhdml0emFjacOzXCIsXG5cdFx0ZmlsdGVyVHlwZVNtb290aGluZzN4MzogXCJTdWF2aXR6YWNpw7MgM8OXM1wiLFxuXHRcdGZpbHRlclR5cGVTbW9vdGhpbmc1eDU6IFwiU3Vhdml0emFjacOzIDXDlzVcIixcblx0XHRmaWx0ZXJUeXBlU2hhcnBlbmluZzN4MzogXCJFbmZvY2FtZW50IDPDlzNcIixcblx0XHRmaWx0ZXJUeXBlU2hhcnBlbmluZzV4NTogXCJFbmZvY2FtZW50IDXDlzVcIixcblx0XHRmaWx0ZXJUeXBlTGFwbGFjaWFuM3gzOiBcIkxhcGxhY2nDoCAzw5czXCIsXG5cdFx0ZmlsdGVyVHlwZUxhcGxhY2lhbjV4NTogXCJMYXBsYWNpw6AgNcOXNVwiLFxuXHRcdGZpbHRlclR5cGVTb2JlbEhvcml6b250YWw6IFwiU29iZWwgaG9yaXR6b250YWxcIixcblx0XHRmaWx0ZXJUeXBlU29iZWxWZXJ0aWNhbDogXCJTb2JlbCB2ZXJ0aWNhbFwiLFxuXHRcdGZpbHRlclR5cGVTaGFycGVuOiBcIkVuZm9jYVwiLFxuXHRcdGZpbHRlclR5cGVTaGFycGVuMjogXCJFbmZvY2EgbcOpc1wiLFxuXHRcdGZpbHRlclR5cGVQb2ludFNwcmVhZDogXCJEaXNwZXJzacOzIGRlbCBwdW50XCIsXG5cdFx0dXNlckRlZmluZWQ6IFwiRGVmaW5pdCBwZXIgbCd1c3VhcmlcIixcblx0XHRDb250b3VyVHlwZUxpbmVzOiBcIkzDrW5pZXMgZGUgY29yYmEgZGUgbml2ZWxsXCIsXG5cdFx0Q29udG91clR5cGVGaWxsOiBcIkVtcGxlbmFtZW50IGRlIGxhIGNvcmJhIGRlIG5pdmVsbFwiLFxuXHRcdENvbnRvdXJUeXBlU21vb3RoT25seTogXCJTdWF2aXR6YSBub23DqXMgbGEgc3VwZXJmw61jaWVcIixcblx0XHRyYXN0ZXJpemVGaXJzdDogXCJQcmltZXJcIixcblx0XHRyYXN0ZXJpemVMYXN0OiBcIsOabHRpbVwiLFxuXHRcdHJhc3Rlcml6ZVNtYWxsZXN0OiBcIk3DqXMgcGV0aXRcIixcblx0XHRyYXN0ZXJpemVMYXJnZXN0OiBcIk3DqXMgZ3JhblwiLFxuXHRcdHJlc2FtcGxpbmdUeXBlTmVhcmVzdDogXCJWZcOtIG3DqXMgcHJvcGVyXCIsXG5cdFx0cmVzYW1wbGluZ1R5cGVCaWxpbmVhcjogXCJJbnRlcnBvbGFjacOzIGJpbGluZWFsXCIsXG5cdFx0cmVzYW1wbGluZ1R5cGVDdWJpYzogXCJDb252b2x1Y2nDsyBjw7piaWNhXCIsXG5cdFx0cmVzYW1wbGluZ1R5cGVNYWpvcml0eTogXCJNYWpvcmlhXCIsXG5cdFx0cmVzYW1wbGluZ1R5cGVCaWxpbmVhclBsdXM6IFwiU3VtYSBkJ2ludGVycG9sYWNpw7MgYmlsaW5lYWxcIixcblx0XHRyZXNhbXBsaW5nVHlwZUdhdXNzOiBcIkRlc2VuZm9jYW1lbnQgZ2F1c3Npw6BcIixcblx0XHRyZXNhbXBsaW5nVHlwZUdhdXNzUGx1czogXCJTdW1hIGRlIGRlc2VuZm9jYW1lbnQgZ2F1c3Npw6BcIixcblx0XHRyZXNhbXBsaW5nVHlwZUF2ZXJhZ2U6IFwiTWlnXCIsXG5cdFx0cmVzYW1wbGluZ1R5cGVNaW5pbXVtOiBcIk3DrW5pbVwiLFxuXHRcdHJlc2FtcGxpbmdUeXBlTWF4aW11bTogXCJNw6B4aW1cIixcblx0XHRyZXNhbXBsaW5nVHlwZVZlY3RvckF2ZzogXCJNaXRqYW5hIGRlbCB2ZWN0b3JcIixcblx0XHRtaW5pbXVtOiBcIk3DrW5pbVwiLFxuXHRcdG1heGltdW06IFwiTcOgeGltXCIsXG5cdFx0bWVhbjogXCJNaXRqYVwiLFxuXHRcdHN0ZERldmlhdGlvbjogXCJEZXN2aWFjacOzIGVzdMOgbmRhcmRcIixcblx0XHR1dk1hZ0RpclR5cGVVVjogXCJVLVZcIixcblx0XHR1dk1hZ0RpclR5cGVNYWdEaXI6IFwiTWFnbml0dWQtZGlyZWNjacOzXCIsXG5cdFx0dW5rbm93bjogXCJEZXNjb25lZ3V0XCIsXG5cdFx0YW5nbGVSZWZTeXNHZW9ncmFwaGljOiBcIkdlb2dyw6BmaWNcIixcblx0XHRhbmdsZVJlZlN5c0FyaXRobWV0aWM6IFwiQXJpdG3DqHRpY1wiLFxuXHRcdGludGVycG9sYXRlSXJyZWd1bGFyRGF0YU5lYXJlc3Q6IFwiVmXDrSBtw6lzIHByb3BlclwiLFxuXHRcdGludGVycG9sYXRlSXJyZWd1bGFyRGF0YUJpbGluZWFyOiBcIkJpbGluZWFsXCIsXG5cdFx0aW50ZXJwb2xhdGVJcnJlZ3VsYXJEYXRhVGlubmluZ0xpbmVhcjogXCJTaW1wbGlmaWNhY2nDsyBsaW5lYWxcIixcblx0XHRpbnRlcnBvbGF0ZUlycmVndWxhckRhdGFUaW5uaW5nTmF0dXJhbE5laWdoYm9yOiBcIlZlw60gbmF0dXJhbFwiLFxuXHRcdGludGVycG9sYXRlSXJyZWd1bGFyRGF0YVRpbm5pbmdJRFc6IFwiRGlzdMOgbmNpYSBpbnZlcnNhIHBvbmRlcmFkYVwiLFxuXHRcdGVzcmlSYXN0ZXJUaHJlc2hvbGRUeXBlQ29uc3RhbnQ6IFwiQ29uc3RhbnRcIixcblx0XHRlc3JpUmFzdGVyVGhyZXNob2xkVHlwZU90c3U6IFwiT3RzdVwiLFxuXHRcdGVzcmlSYXN0ZXJUaHJlc2hvbGRUeXBlVHNhaTogXCJUc2FpXCIsXG5cdFx0ZXNyaVJhc3RlclRocmVzaG9sZFR5cGVLYXB1cjogXCJLYXB1clwiLFxuXHRcdGVzcmlSYXN0ZXJUaHJlc2hvbGRUeXBlS2l0dGxlcjogXCJLaXR0bGVyXCIsXG5cdFx0ZXNyaVJhc3RlclRocmVzaG9sZFR5cGVSb3NpbjogXCJSb3NpblwiLFxuXHRcdGFyZ1N0YXRzVHlwZU1heDogXCJBcmcgTWF4XCIsXG5cdFx0YXJnU3RhdHNUeXBlTWluOiBcIkFyZyBNaW5cIixcblx0XHRhcmdTdGF0c1R5cGVNZWRpYW46IFwiQXJnIE1lZGlhblwiLFxuXHRcdGFyZ1N0YXRzVHlwZUR1cmF0aW9uOiBcIkR1cmF0aW9uXCIsXG5cdFx0YXJpdGhtZXRpY09wUGx1czogXCJTdW1hXCIsXG5cdFx0YXJpdGhtZXRpY09wTWludXM6IFwiUmVzdGFcIixcblx0XHRhcml0aG1ldGljT3BNdWx0aXBseTogXCJNdWx0aXBsaWNhY2nDs1wiLFxuXHRcdGFyaXRobWV0aWNPcERpdmlkZTogXCJEaXZpc2nDs1wiLFxuXHRcdGFyaXRobWV0aWNPcFBvd2VyOiBcIlBvdMOobmNpYVwiLFxuXHRcdGFyaXRobWV0aWNPcE1vZGU6IFwiTW9kZVwiLFxuXHRcdGNsaXBUeXBlT3V0c2lkZTogXCJSZXRhbGwgZXh0ZXJpb3JcIixcblx0XHRjbGlwVHlwZUluc2lkZTogXCJSZXRhbGwgaW50ZXJpb3JcIixcblx0XHR5ZXM6IFwiU8OtXCIsXG5cdFx0bm86IFwiTm9cIixcblx0XHRkZW5zaXRpZXM6IFwiRGVuc2l0YXRzXCIsXG5cdFx0ZXhwZWN0ZWRDb3VudHM6IFwiUmVjb21wdGVzIGVzcGVyYXRzXCIsXG5cdFx0cGxhbmFyOiBcIlBsYVwiLFxuXHRcdGdlb2Rlc2ljOiBcIkdlb2TDqHNpY1wiLFxuXHRcdGVhY2hDZWxsOiBcIkNhZGEgY2VswrdsYVwiLFxuXHRcdGVhY2hab25lOiBcIkNhZGEgem9uYVwiLFxuXHRcdGJlc3RTaW5nbGU6IFwiTCfDum5pYyBtaWxsb3JcIixcblx0XHRhbGxTaWdodGxpbmVzOiBcIlRvdGVzIGxlcyBsw61uaWVzIGRlIHZpc2nDs1wiLFxuXHRcdHBlcmltZXRlclNpZ2h0bGluZXM6IFwiTMOtbmllcyBkZSB2aXNpw7MgZGUgcGVyw61tZXRyZVwiLFxuXHRcdGZyZXF1ZW5jeTogXCJGcmVxw7zDqG5jaWFcIixcblx0XHRvYnNlcnZlcnM6IFwiT2JzZXJ2YWRvcnNcIixcblx0XHRtYWpvcml0eTogXCJNYWpvcmlhXCIsXG5cdFx0bWVkaWFuOiBcIk1pdGphbmFcIixcblx0XHRtaW5vcml0eTogXCJNaW5vcmlhXCIsXG5cdFx0cGVyY2VudGlsZTogXCJQZXJjZW50aWxcIixcblx0XHRyYW5nZTogXCJJbnRlcnZhbFwiLFxuXHRcdHN1bTogXCJTdW1hXCIsXG5cdFx0dmFyaWV0eTogXCJWYXJpZXRhdFwiLFxuXHRcdG5kdmk6IFwiTkRWSVwiLFxuXHRcdHNhdmk6IFwiU0FWSVwiLFxuXHRcdGJhbmRBcml0aG1ldGljTWV0aG9kVFNBVkk6IFwiU0FWSSB0cmFuc2Zvcm1hdFwiLFxuXHRcdGJhbmRBcml0aG1ldGljTWV0aG9kTVNBVkk6IFwiU0FWSSBtb2RpZmljYXRcIixcblx0XHRiYW5kQXJpdGhtZXRpY01ldGhvZFN1bHRhbjogXCJGw7NybXVsYSBkZSBTdWx0YW5cIixcblx0XHRnZW1pOiBcIkdFTUlcIixcblx0XHRwdmk6IFwiUFZJXCIsXG5cdFx0Z3ZpOiBcIkdWSSAoTGFuZHNhdCBUTSlcIixcblx0XHR2YXJpOiBcIlZBUklcIixcblx0XHRzcjogXCJTUlwiLFxuXHRcdGduZHZpOiBcIkdORFZJXCIsXG5cdFx0bmR2aXJlOiBcIk5EVklyZVwiLFxuXHRcdHNycmU6IFwiU1JyZVwiLFxuXHRcdG10dmkyOiBcIk1UVkkyXCIsXG5cdFx0cnR2aUNvcmU6IFwiUlRWSUNvcmVcIixcblx0XHRjaXJlOiBcIkNJcmVcIixcblx0XHRjaWc6IFwiQ0lnXCIsXG5cdFx0bmR3aTogXCJORFdJXCIsXG5cdFx0ZXZpOiBcIkVWSVwiLFxuXHRcdGlyb25PeGlkZTogXCLDknhpZCBkZSBmZXJyb1wiLFxuXHRcdGZlcnJvdXNNaW5lcmFsczogXCJNaW5lcmFscyBmZXJyb3Nvc1wiLFxuXHRcdGNsYXlNaW5lcmFsczogXCJNaW5lcmFscyBhcmdpbG9zb3NcIixcblx0XHR3bmR3aTogXCJXTkRXSVwiLFxuXHRcdGJhaTogXCJCQUlcIixcblx0XHRtbmR3aTogXCJNTkRXSVwiLFxuXHRcdG5icjogXCJOQlJcIixcblx0XHRuZGJpOiBcIk5EQklcIixcblx0XHRuZG1pOiBcIk5ETUlcIixcblx0XHRuZHNpOiBcIk5EU0lcIixcblx0XHRsb2NhbFNxdWFyZVJvb3Q6IFwiQXJyZWwgcXVhZHJhZGFcIixcblx0XHRsb2NhbEFDb3M6IFwiQXJjIGNvc2ludXMgKEFDb3MpXCIsXG5cdFx0bG9jYWxBU2luOiBcIkFyYyBzaW51cyAoQVNpbilcIixcblx0XHRsb2NhbEFUYW46IFwiQXJjIHRhbmdlbnQgKEFUYW4pXCIsXG5cdFx0bG9jYWxBVGFuSDogXCJBcmMgdGFuZ2VudCBoaXBlcmLDsmxpY2EgKEFUYW5IKVwiLFxuXHRcdGxvY2FsQWJzOiBcIlZhbG9yIGFic29sdXRcIixcblx0XHRsb2NhbEJpdHdpc2VOb3Q6IFwiQml0d2lzZSBOb3RcIixcblx0XHRsb2NhbEJvb2xlYW5Ob3Q6IFwiQm9vbGVhbmEgTm90XCIsXG5cdFx0bG9jYWxDb3M6IFwiQ29zaW51cyAoQ29zKVwiLFxuXHRcdGxvY2FsQ29zSDogXCJDb3NpbnVzIGhpcGVyYsOybGljIChDb3NIKVwiLFxuXHRcdGxvY2FsRXhwOiBcIkV4cG9uZW5jaWFsIGVuIGJhc2UgZSAoRXhwKVwiLFxuXHRcdGxvY2FsRXhwMTA6IFwiRXhwb25lbmNpYWwgZW4gYmFzZSAxMCAoRXhwMTApXCIsXG5cdFx0bG9jYWxFeHAyOiBcIkV4cG9uZW5jaWFsIGVuIGJhc2UgMiAoRXhwMilcIixcblx0XHRsb2NhbEludDogXCJFbnRlclwiLFxuXHRcdGxvY2FsSXNOdWxsOiBcIsOJcyBudWxcIixcblx0XHRsb2NhbEZsb2F0OiBcIlB1bnQgZmxvdGFudFwiLFxuXHRcdGxvY2FsTG46IFwiTG9nYXJpdG1lIG5lcGVyacOgIChMbilcIixcblx0XHRsb2NhbExvZzEwOiBcIkxvZ2FyaXRtZSBlbiBiYXNlIDEwIChMb2cxMClcIixcblx0XHRsb2NhbExvZzI6IFwiTG9nYXJpdG1lIGVuIGJhc2UgMiAobG9nMilcIixcblx0XHRsb2NhbE5lZ2F0ZTogXCJDYW52aSBkZSBzaWduZVwiLFxuXHRcdGxvY2FsUm91bmREb3duOiBcIkFycm9kb25pbWVudCBhIGxhIGJhaXhhXCIsXG5cdFx0bG9jYWxSb3VuZFVwOiBcIkFycm9kb25pbWVudCBhIGwnYWzDp2FcIixcblx0XHRsb2NhbFNpbjogXCJTaW51cyAoU2luKVwiLFxuXHRcdGxvY2FsU2luSDogXCJTaW51cyBoaXBlcmLDsmxpYyAoU2luSClcIixcblx0XHRsb2NhbFRhbjogXCJUYW5nZW50IChUYW4pXCIsXG5cdFx0bG9jYWxUYW5IOiBcIlRhbmdlbnQgaGlwZXJiw7JsaWNhIChUYW5IKVwiLFxuXHRcdGxvY2FsQUNvc0g6IFwiQXJjIGNvc2ludXMgaGlwZXJiw7JsaWMgKEFDb3NIKVwiLFxuXHRcdGxvY2FsQVNpbkg6IFwiQXJjIHNpbnVzIGhpcGVyYsOybGljIChBU2luSClcIixcblx0XHRsb2NhbFBsdXM6IFwiU3VtYVwiLFxuXHRcdGxvY2FsTWludXM6IFwiUmVzdGFcIixcblx0XHRsb2NhbFRpbWVzOiBcIk11bHRpcGxpY2FjacOzXCIsXG5cdFx0bG9jYWxQb3dlcjogXCJQb3TDqG5jaWFcIixcblx0XHRsb2NhbEJpdHdpc2VBbmQ6IFwiQml0d2lzZSBBbmRcIixcblx0XHRsb2NhbEJpdHdpc2VMZWZ0U2hpZnQ6IFwiQml0d2lzZSBMZWZ0IFNoaWZ0XCIsXG5cdFx0bG9jYWxCaXR3aXNlT3I6IFwiQml0d2lzZSBPclwiLFxuXHRcdGxvY2FsQml0d2lzZVJpZ2h0U2hpZnQ6IFwiQml0d2lzZSBSaWdodCBTaGlmdFwiLFxuXHRcdGxvY2FsQml0d2lzZVhvcjogXCJCaXR3aXNlIFhvclwiLFxuXHRcdGxvY2FsQm9vbGVhbkFuZDogXCJCb29sZWFuYSBBbmRcIixcblx0XHRsb2NhbEJvb2xlYW5PcjogXCJCb29sZWFuYSBPclwiLFxuXHRcdGxvY2FsQm9vbGVhblhvcjogXCJCb29sZWFuYSBYb3JcIixcblx0XHRsb2NhbERpdmlkZTogXCJEaXZpc2nDs1wiLFxuXHRcdGxvY2FsRXF1YWxUbzogXCJJZ3VhbCBxdWVcIixcblx0XHRsb2NhbEdyZWF0ZXJUaGFuOiBcIk1ham9yIHF1ZVwiLFxuXHRcdGxvY2FsR3JlYXRlclRoYW5FcXVhbDogXCJNYWpvciBvIGlndWFsIHF1ZVwiLFxuXHRcdGxvY2FsTGVzc1RoYW46IFwiTWVub3IgcXVlXCIsXG5cdFx0bG9jYWxMZXNzVGhhbkVxdWFsOiBcIk1lbm9yIG8gaWd1YWwgcXVlXCIsXG5cdFx0bG9jYWxNb2Q6IFwiTcOyZHVsXCIsXG5cdFx0bG9jYWxOb3RFcXVhbDogXCJObyBpZ3VhbFwiLFxuXHRcdGxvY2FsQVRhbjI6IFwiQXJjIHRhbmdlbnQgKEFUYW4yKVwiLFxuXHRcdGxvY2FsU3F1YXJlOiBcIlF1YWRyYWRhXCIsXG5cdFx0bG9jYWxTZXROdWxsOiBcIkRlZmluZWl4IG51bHNcIixcblx0XHRyZW1hcERlZlR5cGVMaXN0OiBcIkxsaXN0YVwiLFxuXHRcdHJlbWFwRGVmVHlwZVRhYmxlOiBcIlRhdWxhXCIsXG5cdFx0cmVtYXBUYWJsZVR5cGVTaW1wbGU6IFwiU2ltcGxlXCIsXG5cdFx0cmVtYXBUYWJsZVR5cGVEeW5hbWljOiBcIkRpbsOgbWljXCIsXG5cdFx0cmVtYXBUYWJsZVR5cGVSZWFzc2lnbm1lbnQ6IFwiUmVhc3NpZ25hY2nDs1wiLFxuXHRcdGdlb21Db3JyZWN0aW9uQnlDb25zdFo6IFwiVXRpbGl0emEgWiBjb25zdGFudFwiLFxuXHRcdGdlb21Db3JyZWN0aW9uQnlERU06IFwiVXRpbGl0emEgREVNXCIsXG5cdFx0cmFkYXJDYWxpYkJldGFOb3VnaHQ6IFwiQmV0YSB6ZXJvXCIsXG5cdFx0cmFkYXJDYWxpYlNpZ21hTm91Z2h0OiBcIlNpZ21hIHplcm9cIixcblx0XHRyYWRhckNhbGliR2FtbWFOb3VnaHQ6IFwiR2FtbWEgemVyb1wiLFxuXHRcdHNwZWNrbGVGaWx0ZXJUeXBlTGVlOiBcIkZpbHRyZSBkZSBMZWVcIixcblx0XHRzcGVja2xlRmlsdGVyVHlwZUVuaGFuY2VkTGVlOiBcIkZpbHRyZSBkZSBMZWUgbWlsbG9yYXRcIixcblx0XHRzcGVja2xlRmlsdGVyVHlwZUZyb3N0OiBcIkZpbHRyZSBkZSBGcm9zdFwiLFxuXHRcdHNwZWNrbGVGaWx0ZXJUeXBlS3VhbjogXCJGaWx0cmUgZGUgS3VhblwiLFxuXHRcdHNwZWNrbGVOb2lzZU1vZGVsTXVsOiBcIlNvcm9sbCBtdWx0aXBsaWNhdGl1XCIsXG5cdFx0c3BlY2tsZU5vaXNlTW9kZWxBZGQ6IFwiU29yb2xsIGFkZGl0aXVcIixcblx0XHRzcGVja2xlTm9pc2VNb2RlbEFkZG5NdWw6IFwiU29yb2xsIGFkZGl0aXUgaSBtdWx0aXBsaWNhdGl1XCIsXG5cdFx0bW9zYWljT3BUeXBlRmlyc3Q6IFwiUHJpbWVyXCIsXG5cdFx0bW9zYWljT3BUeXBlTGFzdDogXCLDmmx0aW1cIixcblx0XHRtb3NhaWNPcFR5cGVNaW46IFwiTcOtbi5cIixcblx0XHRtb3NhaWNPcFR5cGVNYXg6IFwiTcOgeC5cIixcblx0XHRtb3NhaWNPcFR5cGVNZWFuOiBcIk1pdGphXCIsXG5cdFx0bW9zYWljT3BUeXBlQmxlbmQ6IFwiQ29tYmluYWNpw7NcIixcblx0XHRtb3NhaWNPcFR5cGVTdW06IFwiU3VtYVwiLFxuXHRcdGludGVnZXI6IFwiRW50ZXJcIixcblx0XHRyZnhEODogXCJEOFwiLFxuXHRcdHJmeE1GRDogXCJNRkRcIixcblx0XHRkaW5mOiBcIkRpbmZcIixcblx0XHR2ZXJ0aWNhbDogXCJWZXJ0aWNhbFwiLFxuXHRcdGhvcml6b250YWw6IFwiSG9yaXR6b250YWxcIixcblx0XHRsb2NhbENlbGxTdGF0aXN0aWNzTWFqb3JpdHk6IFwiTWFqb3JpYVwiLFxuXHRcdGxvY2FsQ2VsbFN0YXRpc3RpY3NNYXg6IFwiTcOgeGltXCIsXG5cdFx0bG9jYWxDZWxsU3RhdGlzdGljc01lYW46IFwiTWl0amFcIixcblx0XHRsb2NhbENlbGxTdGF0aXN0aWNzTWVkaWFuOiBcIk1pdGphbmFcIixcblx0XHRsb2NhbENlbGxTdGF0aXN0aWNzTWluOiBcIk3DrW5pbVwiLFxuXHRcdGxvY2FsQ2VsbFN0YXRpc3RpY3NNaW5vcml0eTogXCJNaW5vcmlhXCIsXG5cdFx0bG9jYWxDZWxsU3RhdGlzdGljc1JhbmdlOiBcIkludGVydmFsXCIsXG5cdFx0bG9jYWxDZWxsU3RhdGlzdGljc1N0ZERldjogXCJEZXN2aWFjacOzIGVzdMOgbmRhcmRcIixcblx0XHRsb2NhbENlbGxTdGF0aXN0aWNzU3VtOiBcIlN1bWFcIixcblx0XHRsb2NhbENlbGxTdGF0aXN0aWNzVmFyaWV0eTogXCJWYXJpZXRhdFwiLFxuXHRcdGxvY2FsQ2VsbFN0YXRpc3RpY3NNYWpvcml0eUlnbm9yZU5EOiBcIk1ham9yaWEgKGlnbm9yYSBlbHMgZWxlbWVudHMgTm9EYXRhKVwiLFxuXHRcdGxvY2FsQ2VsbFN0YXRpc3RpY3NNYXhJZ25vcmVORDogXCJNw6B4aW0gKGlnbm9yYSBlbHMgZWxlbWVudHMgTm9EYXRhKVwiLFxuXHRcdGxvY2FsQ2VsbFN0YXRpc3RpY3NNZWFuSWdub3JlTkQ6IFwiTWl0amEgKGlnbm9yYSBlbHMgZWxlbWVudHMgTm9EYXRhKVwiLFxuXHRcdGxvY2FsQ2VsbFN0YXRpc3RpY3NNZWRpYW5JZ25vcmVORDogXCJNaXRqYW5hIChpZ25vcmEgZWxzIGVsZW1lbnRzIE5vRGF0YSlcIixcblx0XHRsb2NhbENlbGxTdGF0aXN0aWNzTWluSWdub3JlTkQ6IFwiTcOtbmltIChpZ25vcmEgZWxzIGVsZW1lbnRzIE5vRGF0YSlcIixcblx0XHRsb2NhbENlbGxTdGF0aXN0aWNzTWlub3JpdHlJZ25vcmVORDogXCJNaW5vcmlhIChpZ25vcmEgZWxzIGVsZW1lbnRzIE5vRGF0YSlcIixcblx0XHRsb2NhbENlbGxTdGF0aXN0aWNzUmFuZ2VJZ25vcmVORDogXCJJbnRlcnZhbCAoaWdub3JhIGVscyBlbGVtZW50cyBOb0RhdGEpXCIsXG5cdFx0bG9jYWxDZWxsU3RhdGlzdGljc1N0ZERldklnbm9yZU5EOiBcIkRlc3ZpYWNpw7MgZXN0w6BuZGFyZCAoaWdub3JhIGVscyBlbGVtZW50cyBOb0RhdGEpXCIsXG5cdFx0bG9jYWxDZWxsU3RhdGlzdGljc1N1bUlnbm9yZU5EOiBcIlN1bWEgKGlnbm9yYSBlbHMgZWxlbWVudHMgTm9EYXRhKVwiLFxuXHRcdGxvY2FsQ2VsbFN0YXRpc3RpY3NWYXJpZXR5SWdub3JlTkQ6IFwiVmFyaWV0YXQgKGlnbm9yYSBlbHMgZWxlbWVudHMgTm9EYXRhKVwiLFxuXHRcdGxvY2FsQ2VsbFN0YXRpc3RpY3NUeXBlUGVyY2VudGlsZUlnbm9yZU5EOiBcIlBlcmNlbnRpbCAoaWdub3JhIGVscyBlbGVtZW50cyBOb0RhdGEpXCIsXG5cdFx0ZnJvbVNvdXJjZTogXCJEZXMgZGUgbCdvcmlnZW5cIixcblx0XHR0b1NvdXJjZTogXCJGaW5zIGEgbCdvcmlnZW5cIixcblx0XHRjb2xvcnNwYWNlQ29udmVyc2lvblJnYlRvSHN2OiBcIlJHQiBhIEhTVlwiLFxuXHRcdGNvbG9yc3BhY2VDb252ZXJzaW9uSHN2VG9SZ2I6IFwiSFNWIGEgUkdCXCIsXG5cdFx0cGFuc2hhcnBlblR5cGVJSFM6IFwiSUhTXCIsXG5cdFx0cGFuc2hhcnBlblR5cGVCcm92ZXk6IFwiQnJvdmV5XCIsXG5cdFx0cGFuc2hhcnBlblR5cGVFc3JpOiBcIkVzcmlcIixcblx0XHRwYW5zaGFycGVuVHlwZU1lYW46IFwiTWl0amFcIixcblx0XHRwYW5zaGFycGVuVHlwZUdyYW1TY2htaWR0OiBcIkdyYW0tU2NobWlkdFwiLFxuXHRcdHJlY3RhbmdsZU5laWdoYm9yaG9vZDogXCJSZWN0YW5nbGVcIixcblx0XHRjaXJjbGVOZWlnaGJvcmhvb2Q6IFwiQ2VyY2xlXCIsXG5cdFx0YW5udWx1c05laWdoYm9yaG9vZDogXCJDb3JvbmEgY2lyY3VsYXJcIixcblx0XHR3ZWRnZU5laWdoYm9yaG9vZDogXCJGYWxjYVwiLFxuXHRcdGlycmVndWxhck5laWdoYm9yaG9vZDogXCJJcnJlZ3VsYXJcIixcblx0XHR3ZWlnaHROZWlnaGJvcmhvb2Q6IFwiUGVzXCIsXG5cdFx0Zm91cjogXCJRdWF0cmVcIixcblx0XHRlaWdodDogXCJWdWl0XCIsXG5cdFx0d2l0aGluOiBcIkRpbnNcIixcblx0XHRjcm9zczogXCJDcmV1XCIsXG5cdFx0YWRkTGluazogXCJBZmVnZWl4IHVuIGVubGxhw6dcIixcblx0XHRub0xpbms6IFwiU2Vuc2UgZW5sbGHDp1wiLFxuXHRcdHdlaWdodGVkTWVhbjogXCJNaXRqYW5hIHBvbmRlcmFkYVwiLFxuXHRcdGxzOFFDQml0UGF0dGVybkNpcnJ1czogXCJMYW5kc2F0IDggQ2lycnVzXCIsXG5cdFx0bHM4UUNCaXRQYXR0ZXJuQ2xvdWQ6IFwiTGFuZHNhdCA4IENsb3VkXCIsXG5cdFx0bHM4UUNCaXRQYXR0ZXJuQ2xvdWRTaGFkb3c6IFwiTGFuZHNhdCA4IENsb3VkIFNoYWRvd1wiLFxuXHRcdGxzOFFDQml0UGF0dGVybkRlc2lnbmF0ZWRGaWxsOiBcIkxhbmRzYXQgOCBEZXNpZ25hdGVkIEZpbGxcIixcblx0XHRsczhRQ0JpdFBhdHRlcm5Ecm9wcGVkRnJhbWU6IFwiTGFuZHNhdCA4IERyb3BwZWQgRnJhbWVcIixcblx0XHRsczhRQ0JpdFBhdHRlcm5Tbm93SWNlOiBcIkxhbmRzYXQgOCBTbm93L0ljZVwiLFxuXHRcdGxzOFFDQml0UGF0dGVyblRlcnJhaW5PY2NsdXNpb246IFwiTGFuZHNhdCA4IFRlcnJhaW4gT2NjbHVzaW9uXCIsXG5cdFx0bHM4UUNCaXRQYXR0ZXJuVmVnZXRhdGlvbjogXCJMYW5kc2F0IDggVmVnZXRhdGlvblwiLFxuXHRcdGxzOFFDQml0UGF0dGVybldhdGVyOiBcIkxhbmRzYXQgOCBXYXRlclwiLFxuXHRcdGRvd25TdHJlYW06IFwiRGVzY2VuZGVudFwiLFxuXHRcdHVwU3RyZWFtOiBcIkFzY2VuZGVudFwiLFxuXHRcdHN0cmFobGVyOiBcIlNUUkFITEVSXCIsXG5cdFx0c2hyZXZlOiBcIlNIUkVWRVwiLFxuXHRcdGN1cnJlbnRTbGljZTogXCJTZWN0b3IgYWN0dWFsXCIsXG5cdFx0YWxsU2xpY2VzOiBcIlRvdHMgZWxzIHNlY3RvcnNcIixcblx0XHRleHBhbmREaXN0YW5jZTogXCJESVNUw4BOQ0lBXCIsXG5cdFx0ZXhwYW5kTW9ycGhvbG9naWNhbDogXCJNT1JGT0zDkkdJQ1wiLFxuXHRcdHNwZWN0cmFsUHJvZmlsZUZpbGU6IFwiUGVyZmlsIGVzcGVjdHJhbFwiLFxuXHRcdHRyYWluaW5nRmVhdHVyZUZpbGU6IFwiRW50aXRhdCBkZSBmb3JtYWNpw7NcIixcblx0XHRyYW5kb21EaXN0cmlidXRpb25UeXBlVW5pZm9ybTogXCJVbmlmb3JtZVwiLFxuXHRcdHJhbmRvbURpc3RyaWJ1dGlvblR5cGVVbmlmb3JtSW50ZWdlcjogXCJFbnRlclwiLFxuXHRcdHJhbmRvbURpc3RyaWJ1dGlvblR5cGVOb3JtYWw6IFwiTm9ybWFsXCIsXG5cdFx0cmFuZG9tRGlzdHJpYnV0aW9uVHlwZUV4cG9uZW50aWFsOiBcIkV4cG9uZW5jaWFsXCIsXG5cdFx0cmFuZG9tRGlzdHJpYnV0aW9uVHlwZVBvaXNzb246IFwiUG9pc3NvblwiLFxuXHRcdHJhbmRvbURpc3RyaWJ1dGlvblR5cGVHYW1tYTogXCJHYW1tYVwiLFxuXHRcdHJhbmRvbURpc3RyaWJ1dGlvblR5cGVCaW5vbWlhbDogXCJCaW5vbWlhbFwiLFxuXHRcdHJhbmRvbURpc3RyaWJ1dGlvblR5cGVHZW9tZXRyaWM6IFwiR2VvbcOodHJpY2FcIixcblx0XHRyYW5kb21EaXN0cmlidXRpb25UeXBlTmVnYXRpdmVCaW5vbWlhbDogXCJCaW5vbWlhbCBuZWdhdGl1XCIsXG5cdFx0cmFuZG9tR2VuZXJhdG9yVHlwZVN0YW5kYXJkQ1JhbmQ6IFwiUmFuZCBDIGVzdMOhbmRhclwiLFxuXHRcdHJhbmRvbUdlbmVyYXRvclR5cGVBbGdvcml0aG1BQ001OTk6IFwiQWxnb3JpdG1vIDU5OSBjYXB0dXJhZG8gcG9yIEFDTVwiLFxuXHRcdHJhbmRvbUdlbmVyYXRvclR5cGVNZXJzZW5uZVR3aXN0ZXI6IFwiTWVyc2VubmUgVHdpc3RlclwiLFxuXHRcdHN1bU5hbWU6IFwiU3VtYVwiLFxuXHRcdG1lZGFpbk5hbWU6IFwiTWl0amFuYVwiLFxuXHRcdHRyZW5kTGluZWFyOiBcIkxpbmVhbFwiLFxuXHRcdHRyZW5kSGFybW9uaWM6IFwiSGFybcOybmljXCIsXG5cdFx0dHJlbmRQb2x5bm9taWFsOiBcIlBvbGlub21pYWxcIixcblx0XHR0cmVuZE1hbm5LZW5kYWxsOiBcIk1hbm4tS2VuZGFsbFwiLFxuXHRcdHRyZW5kU2Vhc29uYWxLZW5kYWxsOiBcIktlbmRhbGwgZXN0YWNpb25hbFwiLFxuXHRcdGRpbWVuc2lvbkJ5VmFsdWU6IFwiUGVyIHZhbG9yXCIsXG5cdFx0ZGltZW5zaW9uQnlJbnRlcnZhbDogXCJQZXIgaW50ZXJ2YWxcIixcblx0XHRtZGltRGVmVHlwZUFsbDogXCJUb3RzXCIsXG5cdFx0bWRpbURlZlR5cGVCeVZhbHVlczogXCJQZXIgdmFsb3JzXCIsXG5cdFx0bWRpbURlZlR5cGVCeVJhbmdlczogXCJQZXIgaW50ZXJ2YWxzXCIsXG5cdFx0bWRpbURlZlR5cGVCeUl0ZXJhdGlvbjogXCJQZXIgaXRlcmFjacOzXCIsXG5cdFx0bWRpbURlZlR5cGVCeUludGVydmFsOiBcIlBlciBpbnRlcnZhbFwiLFxuXHRcdG1kaW1EZWZUeXBlQnlUYXJnZXRSYXN0ZXI6IFwiUGVyIHLDoHN0ZXIgZGUgZGVzdGluYWNpw7NcIixcblx0XHRlc3JpVGltZVVuaXRzSG91cnM6IFwiSG9yZXNcIixcblx0XHRlc3JpVGltZVVuaXRzRGF5czogXCJEaWVzXCIsXG5cdFx0ZXNyaVRpbWVVbml0c1dlZWtzOiBcIlNldG1hbmVzXCIsXG5cdFx0ZXNyaVRpbWVVbml0c01vbnRoczogXCJNZXNvc1wiLFxuXHRcdGVzcmlUaW1lVW5pdHNZZWFyczogXCJBbnlzXCIsXG5cdFx0ZXNyaVRpbWVJbnRlcnZhbEtleXdvcmRIb3VybHk6IFwiQ2FkYSBob3JhXCIsXG5cdFx0ZXNyaVRpbWVJbnRlcnZhbEtleXdvcmREYWlseTogXCJEacOgcmlhXCIsXG5cdFx0ZXNyaVRpbWVJbnRlcnZhbEtleXdvcmRXZWVrbHk6IFwiU2V0bWFuYWxcIixcblx0XHRlc3JpVGltZUludGVydmFsS2V5d29yZERla2FkbHk6IFwiQ2FkYSBkw6hjYWRhXCIsXG5cdFx0ZXNyaVRpbWVJbnRlcnZhbEtleXdvcmRQZW50YWRseTogXCJDYWRhIGNpbmMgYW55c1wiLFxuXHRcdGVzcmlUaW1lSW50ZXJ2YWxLZXl3b3JkTW9udGhseTogXCJNZW5zdWFsbWVudFwiLFxuXHRcdGVzcmlUaW1lSW50ZXJ2YWxLZXl3b3JkUXVhcnRlcmx5OiBcIlRyaW1lc3RyYWxtZW50XCIsXG5cdFx0ZXNyaVRpbWVJbnRlcnZhbEtleXdvcmRZZWFybHk6IFwiQW51YWxtZW50XCIsXG5cdFx0ZXNyaVRpbWVJbnRlcnZhbEtleXdvcmRSZWN1cnJpbmdEYWlseTogXCJBbWIgcmVjdXJyw6huY2lhIGRpw6ByaWFcIixcblx0XHRlc3JpVGltZUludGVydmFsS2V5d29yZFJlY3VycmluZ1dlZWtseTogXCJBbWIgcmVjdXJyw6huY2lhIHNldG1hbmFsXCIsXG5cdFx0ZXNyaVRpbWVJbnRlcnZhbEtleXdvcmRSZWN1cnJpbmdNb250aGx5OiBcIkFtYiByZWN1cnLDqG5jaWEgbWVuc3VhbFwiLFxuXHRcdGVzcmlUaW1lSW50ZXJ2YWxLZXl3b3JkUmVjdXJyaW5nUXVhcnRlcmx5OiBcIkFtYiByZWN1cnLDqG5jaWEgdHJpbWVzdHJhbFwiLFxuXHRcdGFnZ0RlZlR5cGVBbGw6IFwiVG90XCIsXG5cdFx0YWdnRGVmVHlwZUludGVydmFsS2V5d29yZDogXCJQYXJhdWxhIGNsYXUgZGUgbCdpbnRlcnZhbFwiLFxuXHRcdGFnZ0RlZlR5cGVJbnRlcnZhbFZhbHVlOiBcIlZhbG9yIGRlIGwnaW50ZXJ2YWxcIixcblx0XHRhZ2dEZWZUeXBlSW50ZXJ2YWxSYW5nZXM6IFwiUmFuZ3MgZGUgbCdpbnRlcnZhbFwiLFxuXHRcdGxhdGVzdENoYW5nZTogXCJIb3JhIGRlIGwnw7psdGltIGNhbnZpXCIsXG5cdFx0ZWFybGllc3RDaGFuZ2U6IFwiSG9yYSBkZWwgcHJpbWVyIGNhbnZpXCIsXG5cdFx0bGFyZ2VzdENoYW5nZTogXCJIb3JhIGRlbCBjYW52aSBtw6lzIGdyYW5cIixcblx0XHRudW1iZXJPZkNoYW5nZXM6IFwiTm9tYnJlIGRlIGNhbnZpc1wiLFxuXHRcdGxvbmdlc3RDaGFuZ2U6IFwiVGVtcHMgZGUgY2FudmkgbcOpcyBsbGFyZ1wiLFxuXHRcdHNob3J0ZXN0Q2hhbmdlOiBcIlRlbXBzIGRlIGNhbnZpIG3DqXMgY3VydFwiLFxuXHRcdGZhc3Rlc3RDaGFuZ2U6IFwiVGVtcHMgZGUgY2FudmkgbcOpcyByw6BwaWRcIixcblx0XHRzbG93ZXN0Q2hhbmdlOiBcIlRlbXBzIGRlIGNhbnZpIG3DqXMgbGVudFwiLFxuXHRcdGFsbENoYW5nZXM6IFwiVG90XCIsXG5cdFx0aW5jcmVhc2VDaGFuZ2VzOiBcIkluY3JlbWVudGFyXCIsXG5cdFx0ZGVjcmVhc2VDaGFuZ2VzOiBcIlJlZHVlaXhcIixcblx0XHRzZWdtZW50QmVnaW5uaW5nOiBcIkluaWNpIGRlIHNlZ21lbnRcIixcblx0XHRzZWdtZW50RW5kOiBcIkZpIGRlIHNlZ21lbnRcIixcblx0XHRlc3JpQ29tcHV0ZUNoYW5nZU1ldGhvZERpZmZlcmVuY2U6IFwiRGlmZXLDqG5jaWFcIixcblx0XHRlc3JpQ29tcHV0ZUNoYW5nZU1ldGhvZFJlbGF0aXZlRGlmZmVyZW5jZTogXCJEaWZlcsOobmNpYSByZWxhdGl2YVwiLFxuXHRcdGVzcmlDb21wdXRlQ2hhbmdlTWV0aG9kQ2F0ZWdvcmljYWw6IFwiRGlmZXLDqG5jaWEgY2F0ZWfDsnJpY2FcIixcblx0XHRlc3JpQ29tcHV0ZUNoYW5nZU1ldGhvZE11bHRpc3BlY3RyYWxFdWNsaWRlYW5EaXN0YW5jZTogXCJEaXN0w6BuY2lhIGV1Y2xpZGlhbmEgZXNwZWN0cmFsXCIsXG5cdFx0ZXNyaUNvbXB1dGVDaGFuZ2VNZXRob2RNdWx0aXNwZWN0cmFsQW5ndWxhckRpZmZlcmVuY2U6IFwiRGlmZXLDqG5jaWEgZCdhbmdsZSBlc3BlY3RyYWxcIixcblx0XHRlc3JpQ29tcHV0ZUNoYW5nZU1ldGhvZE11bHRpc3BlY3RyYWxBeGlzV2l0aEJpZ2dlc3RDaGFuZ2U6IFwiQmFuZGEgYW1iIG3DqXMgY2FudmlzXCIsXG5cdFx0ZXNyaUNvbXB1dGVDaGFuZ2VLZWVwQWxsOiBcIk1hbnRlbmlyIHRvdHNcIixcblx0XHRlc3JpQ29tcHV0ZUNoYW5nZUtlZXBDaGFuZ2VkT25seTogXCJNYW50ZW5pciBub23DqXMgcMOteGVscyBjYW52aWF0c1wiLFxuXHRcdGVzcmlDb21wdXRlQ2hhbmdlS2VlcFVuY2hhbmdlZE9ubHk6IFwiTWFudGVuaXIgbm9tw6lzIHDDrXhlbHMgbm8gY2FudmlhdHNcIixcblx0XHRlc3JpQ29tcHV0ZUNoYW5nZVVzZUNvbG9yQXZlcmFnZTogXCJQcm9taWcgQ29sb3JzIGRlcyBkZSBpIGZpbnMgYVwiLFxuXHRcdGVzcmlDb21wdXRlQ2hhbmdlVXNlQ29sb3JGcm9tOiBcIlV0aWxpdHphIENvbG9ycyBkZXMgZGVcIixcblx0XHRlc3JpQ29tcHV0ZUNoYW5nZVVzZUNvbG9yVG86IFwiVXRpbGl0emEgQ29sb3JzIGlucyBhXCIsXG5cdFx0ZmFjdG9yRnVuY3Rpb25CaW5hcnk6IFwiQmluYXJpXCIsXG5cdFx0ZmFjdG9yRnVuY3Rpb25Gb3J3YXJkOiBcIkVuZGF2YW50XCIsXG5cdFx0ZmFjdG9yRnVuY3Rpb25MaW5lYXI6IFwiTGluZWFsXCIsXG5cdFx0ZmFjdG9yRnVuY3Rpb25JbnZMaW5lYXI6IFwiTGluZWFsIGludmVyc1wiLFxuXHRcdGZhY3RvckZ1bmN0aW9uVGFibGU6IFwiVGF1bGFcIixcblx0XHRmYWN0b3JGdW5jdGlvblN5bUxpbmVhcjogXCJMaW5lYWwgc2ltw6h0cmljXCIsXG5cdFx0ZmFjdG9yRnVuY3Rpb25TeW1JbnZMaW5lYXI6IFwiTGluZWFsIHNpbcOodHJpYyBpbnZlcnNcIixcblx0XHRmYWN0b3JGdW5jdGlvbkNvczogXCJDb3NpbnVzXCIsXG5cdFx0ZmFjdG9yRnVuY3Rpb25TZWM6IFwiU2VjYW50XCIsXG5cdFx0ZmFjdG9yRnVuY3Rpb25Db3NTZWM6IFwiQ29zaW51cyBzZWNhbnRcIixcblx0XHRmYWN0b3JGdW5jdGlvblNlY0NvczogXCJTZWNhbnQgY29zaW51c1wiLFxuXHRcdG5vU29ydDogXCJObyBobyBvcmRlbmlzXCIsXG5cdFx0YXNjZW5kOiBcIkFzY2VuZGVudFwiLFxuXHRcdGRlc2NlbmQ6IFwiRGVzY2VuZGVudFwiLFxuXHRcdGF1dG9EZXRlY3Q6IFwiRGV0ZWN0YSBhdXRvbcOgdGljYW1lbnRcIixcblx0XHRuZWFyZXN0OiBcIk3DqXMgcHJvcGVyXCIsXG5cdFx0bGluZWFyOiBcIkxpbmVhbFwiLFxuXHRcdGVzcmlNb250aEphbnVhcnk6IFwiR2VuZXJcIixcblx0XHRlc3JpTW9udGhGZWJydWFyeTogXCJGZWJyZXJcIixcblx0XHRlc3JpTW9udGhNYXJjaDogXCJNYXLDp1wiLFxuXHRcdGVzcmlNb250aEFwcmlsOiBcIkFicmlsXCIsXG5cdFx0ZXNyaU1vbnRoTWF5OiBcIk1haWdcIixcblx0XHRlc3JpTW9udGhKdW5lOiBcIkp1bnlcIixcblx0XHRlc3JpTW9udGhKdWx5OiBcIkp1bGlvbFwiLFxuXHRcdGVzcmlNb250aEF1Z3VzdDogXCJBZ29zdFwiLFxuXHRcdGVzcmlNb250aFNlcHRlbWJlcjogXCJTZXRlbWJyZVwiLFxuXHRcdGVzcmlNb250aE9jdG9iZXI6IFwiT2N0dWJyZVwiLFxuXHRcdGVzcmlNb250aE5vdmVtYmVyOiBcIk5vdmVtYnJlXCIsXG5cdFx0ZXNyaU1vbnRoRGVjZW1iZXI6IFwiRGVzZW1icmVcIixcblx0XHRkaW1lbnNpb25hbE1vdmluZ0lnbm9yZU5vRGF0YTogXCJEYWRlc1wiLFxuXHRcdGRpbWVuc2lvbmFsTW92aW5nUHJvcGFnYXRlTm9EYXRhOiBcIk5vRGF0YVwiLFxuXHRcdGRpbWVuc2lvbmFsTW92aW5nRmlsbE9ubHlOb0RhdGE6IFwiRW1wbGVuYSBOb0RhdGFcIixcblx0XHRjaXJjdWxhck1lYW46IFwiTWl0amFuYSBjaXJjdWxhclwiLFxuXHRcdGNpcmN1bGFyTmFtZTogXCJDaXJjdWxhclwiLFxuXHRcdGFyaXRobWV0aWNOYW1lOiBcIkFyaXRtw6h0aWNhXCIsXG5cdFx0c2xvcGVOYW1lOiBcIlBlbmRlbnRcIixcblx0XHRhc3BlY3ROYW1lOiBcIk9yaWVudGFjacOzXCIsXG5cdFx0bWVhbkN1cnZhdHVyZTogXCJDdXJ2YXR1cmEgbWl0amFcIixcblx0XHRwcm9maWxlQ3VydmF0dXJlOiBcIkN1cnZhdHVyYSBkZWwgcGVyZmlsIChsw61uaWEgZGUgcGVuZGVudCBub3JtYWwpXCIsXG5cdFx0dGFuZ2VudGlhbEN1cnZhdHVyZTogXCJDdXJ2YXR1cmEgdGFuZ2VuY2lhbCAoY29udG9ybiBub3JtYWwpXCIsXG5cdFx0cGxhbkN1cnZhdHVyZTogXCJDdXJ2YXR1cmEgZGVsIHBsYSAoY29udG9ybiBwcm9qZWN0YXQpXCIsXG5cdFx0Y29udG91ckdlb2Rlc2ljVG9yc2lvbjogXCJUb3JzacOzIGdlb2TDqHNpY2EgZGVsIGNvbnRvcm5cIixcblx0XHRnYXVzc2lhbkN1cnZhdHVyZTogXCJDdXJ2YXR1cmEgZ2F1c3NpYW5hXCIsXG5cdFx0Y2Fzb3JhdGlDdXJ2YXR1cmU6IFwiQ3VydmF0dXJhIGRlIENhc29yYXRpXCIsXG5cdFx0bG9jYWxTdXJmYWNlVHlwZVF1YWRyYXRpYzogXCJRdWFkcsOgdGljYVwiLFxuXHRcdGxvY2FsU3VyZmFjZVR5cGVCaXF1YWRyYXRpYzogXCJCaW9xdWFkcsOgdGljYVwiLFxuXHRcdHRocmVzaG9sZE5vVGhyZXNob2xkOiBcIlNlbnNlIGxsaW5kYXJcIixcblx0XHR0aHJlc2hvbGRQZXJjZW50TGVhc3RDb3N0OiBcIlBlcmNlbnRhdGdlIGRlbCBtZW5vciBjb3N0XCIsXG5cdFx0dGhyZXNob2xkQWNjdW11bGF0aXZlQ29zdDogXCJDb3N0IGFjdW11bGF0aXVcIixcblx0XHRjbHJtYXBUeXBlSGlsbHNoYWRlOiBcIk9tYnJlaWdcIlxuXHR9LFxuXHRjYXRlZ29yeUxhYmVsczoge1xuXHRcdHNvdXJjZUNoYXJhY3RlcmlzdGljczogXCJDYXJhY3RlcsOtc3RpcXVlcyBkJ29yaWdlblwiLFxuXHRcdG5laWdoYm9yaG9vZFNldHRpbmdzOiBcIkNvbmZpZ3VyYWNpw7MgZGVsIHZlw69uYXRcIixcblx0XHRzdGF0aXN0aWNzOiBcIkVzdGFkw61zdGlxdWVzXCIsXG5cdFx0Z2FtbWE6IFwiR2FtbWFcIixcblx0XHR2aWV3c2hlZFBhcmFtZXRlcnM6IFwiUGFyw6BtZXRyZXMgZGUgY29uY2EgdmlzdWFsXCIsXG5cdFx0b2JzZXJ2ZXJQYXJhbWV0ZXJzOiBcIlBhcsOgbWV0cmVzIGQnb2JzZXJ2YWRvclwiLFxuXHRcdGlycmVndWxhckRhdGFJbnRlcnBvbGF0aW9uOiBcIkludGVycG9sYWNpw7MgZGUgZGFkZXMgaXJyZWd1bGFyXCIsXG5cdFx0bW9kZWxTdGF0aXN0aWNzOiBcIkVzdGFkw61zdGlxdWVzIGRlbCBtb2RlbFwiLFxuXHRcdGFnZ3JlZ2F0aW9uRGVmOiBcIkRlZmluaWNpw7MgZCdhZ3JlZ2FjacOzXCIsXG5cdFx0ZmlsdGVyQnlBdHRyaWJ1dGVzOiBcIkZpbHRyYSBwZXIgYXRyaWJ1dHNcIixcblx0XHRwZXJjZW50aWxlTmFtZTogXCJQZXJjZW50aWxcIixcblx0XHRyYXN0ZXJJbmZvOiBcIkluZm9ybWFjacOzIGRlIHLDoHN0ZXJcIixcblx0XHRleHRlbnQ6IFwiRXh0ZW5zacOzXCIsXG5cdFx0c3BhdGlhbFJlZmVyZW5jZTogXCJSZWZlcsOobmNpYSBlc3BhY2lhbFwiXG5cdH0sXG5cdG91dHB1dFJhc3RlckhlbHBUZXh0czoge1xuXHRcdG91dHB1dE5hbWU6IFwiPHA+Tm9tIGRlIGxhIGNhcGEgcXVlIGVzIGNyZWFyw6AgaSBzJ2FmZWdpcsOgIGFsIG1hcGEuPC9wPlwiLFxuXHRcdHJlc3VsdFR5cGU6IFwiPHA+VGlwdXMgZGUgc29ydGlkYSBxdWUgZXMgY3JlYXLDoC4gTGVzIHNvcnRpZGVzIHBvZGVuIHNlciBjYXBlcyBkJ2ltYXRnZXMgZW4gbW9zYWljIG8gY2FwZXMgZCdpbWF0Z2VzIGRpbsOgbWlxdWVzLjwvcD5cIixcblx0XHRzYXZlUmVzdWx0SW46IFwiPHA+Tm9tIGRlIGxhIGNhcnBldGEgYSA8Yj5FbCBtZXUgY29udGluZ3V0PC9iPiBvbiBlcyBkZXNhcsOgIGVsIHJlc3VsdGF0LjwvcD5cIlxuXHR9LFxuXHRhbmFseXNpc0Vudmlyb25tZW50c0hlbHBUZXh0czoge1xuXHRcdGRlc2NyaXB0aW9uOiBcIjxwPkNvbmZpZ3VyYWNpw7MgZGUgbCdlbnRvcm4gcGVyIGEgbCdhbsOgbGlzaSBhbCBWaXNvciBkZSBtYXBlcy4gPC9wPlwiLFxuXHRcdG91dFNSOiBcIjxwPkVzcGVjaWZpY2EgZWwgc2lzdGVtYSBkZSBjb29yZGVuYWRlcyBwZXIgYSBsJ2Fuw6BsaXNpIGkgbGEgY2FwYSBkZSByZXN1bHRhdHMuPC9wPlwiLFxuXHRcdGV4dGVudDogXCI8cD5Fc3BlY2lmaWNhIGwnw6ByZWEgcXVlIGVzIGZhcsOgIHNlcnZpciBwZXIgYSBsJ2Fuw6BsaXNpLjwvcD5cIixcblx0XHRzbmFwUmFzdGVyOiBcIjxwPkFqdXN0YSBsJ2V4dGVuc2nDsyBkZSBsYSBzb3J0aWRhIHBlcnF1w6ggY29pbmNpZGVpeGkgYW1iIGwnYWxpbmVhY2nDsyBkZSBjZWzCt2xlcyBkZSBsYSBjYXBhIHLDoHN0ZXIgZCdhanVzdC48L3A+XCIsXG5cdFx0Y2VsbFNpemU6IFwiPHA+RXNwZWNpZmljYSBsYSBtaWRhIG8gbGEgcmVzb2x1Y2nDsyBkZSBjZWzCt2xhIHF1ZSBzJ3V0aWxpdHphcsOgIHBlciBhIGwnYW7DoGxpc2kgaSBwZXIgY3JlYXIgbGEgY2FwYSBkZSByw6BzdGVyIGRlIHNvcnRpZGEuPC9wPlwiLFxuXHRcdG1hc2s6IFwiPHA+RXNwZWNpZmljYSB1bmEgY2FwYSBkZSBtw6BzY2FyYSBlbiBsYSBxdWFsIG5vbcOpcyBlcyBmYXJhbiBzZXJ2aXIgcGVyIGEgbCdhbsOgbGlzaSBsZXMgY2VswrdsZXMgcXVlIGVzIHRyb2JpbiBkaW5zIGRlIGwnw6ByZWEgZGUgbcOgc2NhcmEuPC9wPlwiLFxuXHRcdHJlc2FtcGxpbmdNZXRob2Q6IFwiPHA+RXNwZWNpZmljYSBjb20gaW50ZXJwb2xhciBlbHMgdmFsb3JzIGRlIHDDrXhlbCBxdWFuIGVscyByw6BzdGVycyBkJ2VudHJhZGEgaSBkZSBzb3J0aWRhIG5vIGVzdGFuIGFsaW5lYXRzLjwvcD5cIlxuXHR9LFxuXHRtYWluR2VuU3RyaW5nczoge1xuXHRcdHVuc3VwcG9ydGVkRGF0YVR5cGU6IFwiVGlwdXMgbm8gY29tcGF0aWJsZVwiLFxuXHRcdGN1cnJlbnRseVVuc3VwcG9ydGVkOiBcIiBIaSBoYSB1biBlZGl0b3IgcHJlZGV0ZXJtaW5hdCBwZXIgYSAke21pc3NpbmdUeXBlfSwgZXN0YXLDoCBkaXNwb25pYmxlIHByb3BlcmFtZW50LiBRdWFkcmUgZGUgdGV4dCBkZSBtYXJjYWRvciBkZSBwb3NpY2nDsyB0ZW1wb3JhbCBwZXIgZXNwZWNpZmljYXIgZW50cmFkZXMgYmFzYWRlcyBlbiBjYWRlbmEuXCIsXG5cdFx0dW5zdXBwb3J0ZWRPdmVycmlkZVdhcm5pbmc6IFwiUHJvcGVyYW1lbnQsIGhpIGhhdXLDoCBkaXNwb25pYmxlIHVuIGVkaXRvciBkJ2ludmFsaWRhY2nDsyBxdWUgb2Zlcmlyw6AgdW5hIFVYIG1pbGxvciBwZXIgdHJlYmFsbGFyIGFtYiBlbHMgcGFyw6BtZXRyZXMgc2Vnw7xlbnRzOlwiLFxuXHRcdG92ZXJyaWRlV2lkZ2V0TWlzc2luZzogXCJGYWx0YSB1biBjb21wb25lbnQgZGUgbCdlZGl0b3IgZCdpbnZhbGlkYWNpw7MuXCIsXG5cdFx0dWlJbmNvbXBsZXRlOiBcIk5vIHMnaGEgcG9ndXQgZW52aWFyIGVsIHRyZWJhbGwuIExhIGZ1bmNpw7Mgbm8gZXMgcG90IGV4ZWN1dGFyIHBlcnF1w6ggYWxndW5zIGRlbHMgY2FtcHMgbmVjZXNzYXJpcyBubyBzw7NuIGNvbXBhdGlibGVzIG8gbm8gYXBhcmVpeGVuIGEgbGEgVUkuXCIsXG5cdFx0Y291bnQ6IFwiUmVjb21wdGVcIixcblx0XHRzZWxlY3RWYXJpYWJsZXM6IFwiU2VsZWNjaW9uYSBsZXMgdmFyaWFibGVzXCIsXG5cdFx0c2VsZWN0RmVhdHVyZTogXCJTZWxlY2Npb25ldSBsYSBjYXBhIGQnZW50aXRhdHNcIixcblx0XHRncmVhdGVyVGhhbkVycm9yTWVzc2FnZTogXCJFbCB2YWxvciBkJ2VudHJhZGEgaGEgZGUgc2VyIG1ham9yIHF1ZSAke21pbn0uXCIsXG5cdFx0bGVzc2VyVGhhbkVycm9yTWVzc2FnZTogXCJFbCB2YWxvciBkJ2VudHJhZGEgaGEgZGUgc2VyIG1lbm9yIHF1ZSAke21heH0uXCIsXG5cdFx0Z3JlYXRlclRoYW5PckVxdWFsRXJyb3JNZXNzYWdlOiBcIkVsIHZhbG9yIGQnZW50cmFkYSBoYSBkZSBzZXIgbWFqb3IgbyBpZ3VhbCBxdWUgJHttaW59LlwiLFxuXHRcdGxlc3NlclRoYW5PckVxdWFsRXJyb3JNZXNzYWdlOiBcIkVsIHZhbG9yIGQnZW50cmFkYSBoYSBkZSBzZXIgbWVub3IgbyBpZ3VhbCBxdWUgJHttYXh9LlwiLFxuXHRcdGFsbG93U2NhbGFyOiBcIlNlbGVjY2lvbmV1IHVuYSBjYXBhIG8gaW50cm9kdcOvdSB1bmEgY29uc3RhbnRcIixcblx0XHRzZWxlY3RGaWVsZDogXCJTZWxlY2Npb25ldSB1biBjYW1wXCIsXG5cdFx0cGFyYW1ldGVyUmVxdWlyZWQ6IFwiQXF1ZXN0IHBhcsOgbWV0cmUgw6lzIG9ibGlnYXRvcmkuXCIsXG5cdFx0ZW50ZXJBVmFsdWU6IFwiSW50cm9kdcOvdSB1biB2YWxvci4uLlwiLFxuXHRcdGludmFsaWRJbnB1dDogXCJFbCB2YWxvciBxdWUgcydoYSBpbnRyb2R1w690IG5vIMOpcyB2w6BsaWQuXCIsXG5cdFx0aXRlbU5vdEZvdW5kOiBcIkwnZWxlbWVudCBubyBleGlzdGVpeCBvIG5vIHMnaGkgcG90IGFjY2VkaXIuXCIsXG5cdFx0aXRlbVBlcm1pc3Npb25EZW5pZWQ6IFwiTm8gdGVuaXUgcGVybWlzb3MgcGVyIGFjY2VkaXIgYSBhcXVlc3QgZWxlbWVudC5cIixcblx0XHRsYXllck5vdEF2YWlsYWJsZTogXCJObyBzJ2hhIHBvZ3V0IHB1amFyIGxhIGNhcGEgJHtsYXllck5hbWV9LlwiLFxuXHRcdG11bHRpcGxlTGF5ZXJzTm90QXZhaWxhYmxlOiBcIk5vIHMnaGEgcG9ndXQgcHVqYXIgbGEgY2FwYSAke2xheWVyTmFtZX0gbmkgY2FwIGFsdHJhLlwiLFxuXHRcdGxlYXJuTW9yZUxhYmVsOiBcIk3DqXMgaW5mb3JtYWNpw7NcIixcblx0XHRmaWVsZE5vdEF2YWlsYWJsZTogXCJObyBzJ2hhIHBvZ3V0IGNhcnJlZ2FyIGVsIGNhbXAuXCIsXG5cdFx0YWxsb3dBbmFseXNpczogXCJBbsOgbGlzaSBubyBwZXJtZXNhIGFsIHNlcnZlaSBkJ2ltYXRnZXMuXCIsXG5cdFx0YWxsb3dBbmFseXNpc1JlYXNvbjogXCJVbmEgbyBkaXZlcnNlcyBjYXBlcyBkZWwgbWFwYSBubyBmaWd1cmVuIGVuIGFxdWVzdGEgbGxpc3RhIHBlcnF1w6ggbm8gcGVybWV0ZW4gbCdhbsOgbGlzaS5cIixcblx0XHRsZWFybk1vcmVUZXh0OiBcIk3DqXMgaW5mb3JtYWNpw7NcIixcblx0XHRhdExlYXN0T25lUmFzdGVySW5wdXQ6IFwiQ29tIGEgbcOtbmltIHVuYSBjYXBhIGQnZW50cmFkYSBoYSBkZSBzZXIgdW5hIGNhcGEgcsOgc3Rlci5cIixcblx0XHRicm93c2VBbmFseXNpc0xheWVyczogXCJFeGFtaW5ldSBjYXBlc1wiLFxuXHRcdGFjdGl2ZU1hcFZpZXdFeHRlbnQ6IFwiVXRpbGl0emEgbCdleHRlbnNpw7MgZGUgbWFwYSBhY3R1YWxcIixcblx0XHRjaG9vc2VSYXN0ZXI6IFwiU2VsZWNjaW9uZXUgUmV0YWxsYSBlbCByw6BzdGVyXCIsXG5cdFx0Y2hvb3NlR2VvbWV0cnk6IFwiU2VsZWNjaW9uZXUgUmV0YWxsYSBsYSBnZW9tZXRyaWFcIixcblx0XHRyZXN1bHRUeXBlOiBcIlRpcHVzIGRlIHJlc3VsdGF0XCIsXG5cdFx0c2F2ZUluRm9sZGVyOiBcIkRlc2EtaG8gYSBsYSBjYXJwZXRhXCIsXG5cdFx0b3V0cHV0TmFtZTogXCJOb20gZGUgc29ydGlkYVwiLFxuXHRcdG91dHB1dExheWVyVHlwZTogXCJUaXB1cyBkZSBjYXBhIGRlIHNvcnRpZGFcIixcblx0XHRkeW5hbWljSW1hZ2VyeUxheWVyOiBcIkNhcGEgZCdpbWF0Z2VzIGRpbsOgbWljYVwiLFxuXHRcdHRpbGVkSW1hZ2VyeUxheWVyOiBcIkNhcGEgZCdpbWF0Z2VzIGVuIG1vc2FpY1wiLFxuXHRcdGN1c3RvbTogXCJQZXJzb25hbGl0emF0XCIsXG5cdFx0bG9hZGluZzogXCJTJ2VzdMOgIGNhcnJlZ2FudC4uLlwiLFxuXHRcdGxheWVyTWlzc2luZzogXCJVbmEgbyBkaXZlcnNlcyBjYXBlcyBkZWwgbWFwYSBubyBmaWd1cmVuIGVuIGFxdWVzdGEgbGxpc3RhIHBlcnF1w6ggbm8gcGVybWV0ZW4gbCdhbsOgbGlzaS4gT2J0ZW5pdSBtw6lzIGluZm9ybWFjacOzLlwiLFxuXHRcdGJyb3dzZUNvb3JkaW5hdGVTeXN0ZW1zOiBcIkV4YW1pbmEgZWxzIHNpc3RlbWVzIGRlIGNvb3JkZW5hZGVzXCIsXG5cdFx0dW5hYmxlVG9SZXBvcHVsYXRlT3V0U1I6IFwiTm8gZXMgcG90IGVtcGxlbmFyIGVsIHNpc3RlbWEgZGUgY29vcmRlbmFkZXMgZGUgc29ydGlkYS5cIixcblx0XHRkZWZhdWx0VGl0bGU6IFwiVmV1cmUnbiBtw6lzXCIsXG5cdFx0XCJBUkMgKGVxdWFsIGFyYy1zZWNvbmQpXCI6IFwiQVJDIChzZWdvbiBkJ2FyYyBpZ3VhbClcIixcblx0XHRBZnJpY2E6IFwiw4BmcmljYVwiLFxuXHRcdEFudGFyY3RpY2E6IFwiQW50w6BydGlkYVwiLFxuXHRcdEFyZ2VudGluYTogXCJBcmdlbnRpbmFcIixcblx0XHRBc2lhOiBcIsOAc2lhXCIsXG5cdFx0XCJBc3Rlcm9pZCBCZWx0XCI6IFwiQ2ludHVyw7MgZCdhc3Rlcm9pZGVzXCIsXG5cdFx0XCJBdGxhbnRpYyBPY2VhblwiOiBcIk9jZcOgIEF0bMOgbnRpY1wiLFxuXHRcdEF1c3RyYWxpYTogXCJBdXN0csOgbGlhXCIsXG5cdFx0XCJBdXN0cmFsaWEgYW5kIE5ldyBaZWFsYW5kXCI6IFwiQXVzdHLDoGxpYSBpIE5vdmEgWmVsYW5kYVwiLFxuXHRcdEF1c3RyaWE6IFwiw4B1c3RyaWFcIixcblx0XHRcIkJMTSAoVVMgRmVldClcIjogXCJCTE0gKHBldXMgZGVscyBFVUEpXCIsXG5cdFx0QmFuZ2xhZGVzaDogXCJCYW5nbGEgRGVzaFwiLFxuXHRcdFwiQmVpamluZyAxOTU0XCI6IFwiUGVxdcOtbiAxOTU0XCIsXG5cdFx0Qmh1dGFuOiBcIkJodXRhblwiLFxuXHRcdENHQ1MyMDAwOiBcIkNHQ1MyMDAwXCIsXG5cdFx0Q2FuYWRhOiBcIkNhbmFkw6BcIixcblx0XHRDYXJpYmJlYW46IFwiQ2FyaWJcIixcblx0XHRcIkNhcmliYmVhbiBTZWFcIjogXCJNYXIgQ2FyaWJcIixcblx0XHRcIkNlbnRyYWwgQW1lcmljYVwiOiBcIkFtw6hyaWNhIENlbnRyYWxcIixcblx0XHRcIkNlbnRyYWwgYW5kIE5vcnRoIEFtZXJpY2FcIjogXCJBbcOocmljYSBDZW50cmFsIGkgZGVsIE5vcmRcIixcblx0XHRDb2xvbWJpYTogXCJDb2zDsm1iaWFcIixcblx0XHRDb250aW5lbnRhbDogXCJDb250aW5lbnRhbFwiLFxuXHRcdFwiQ291bnR5IFN5c3RlbXNcIjogXCJTaXN0ZW1lcyBkZSBjb210YXRzXCIsXG5cdFx0XCJEZW1vY3JhdGljIFJlcHVibGljIG9mIHRoZSBDb25nb1wiOiBcIlJlcMO6YmxpY2EgRGVtb2Nyw6B0aWNhIGRlbCBDb25nb1wiLFxuXHRcdFwiRVBTRyBBcmN0aWNcIjogXCJFUFNHIMOAcnRpY1wiLFxuXHRcdEVhcnRoOiBcIlRlcnJhXCIsXG5cdFx0XCJFbGxpcHNvaWRhbC1iYXNlZFwiOiBcIkJhc2F0IGVuIHVuIGVswrdsaXBzb2lkZVwiLFxuXHRcdEV1cm9wZTogXCJkJ0V1cm9wYVwiLFxuXHRcdEZpbmxhbmQ6IFwiRmlubMOgbmRpYVwiLFxuXHRcdEZyYW5jZTogXCJGcmFuw6dhXCIsXG5cdFx0XCJHU0sgMjAxMVwiOiBcIkdTSyAyMDExXCIsXG5cdFx0XCJHYXVzcyBLcnVnZXJcIjogXCJHYXVzcy1LcsO8Z2VyXCIsXG5cdFx0XCJHZW9ncmFwaGljIENvb3JkaW5hdGUgU3lzdGVtc1wiOiBcIlNpc3RlbWVzIGRlIGNvb3JkZW5hZGVzIGdlb2dyw6BmaXF1ZXNcIixcblx0XHRHZXJtYW55OiBcIkFsZW1hbnlhXCIsXG5cdFx0XCJHcmF2aXR5LXJlbGF0ZWRcIjogXCJSZWxhY2lvbmF0IGFtYiBsYSBncmF2ZXRhdFwiLFxuXHRcdFwiR3JlZW53aWNoLWJhc2VkXCI6IFwiQmFzYXQgZW4gR3JlZW53aWNoXCIsXG5cdFx0XCJIaWdod2F5cyBFbmdsYW5kXCI6IFwiQXV0b3Bpc3RlcyBBbmdsYXRlcnJhXCIsXG5cdFx0SWxsaW5vaXM6IFwiSWxsaW5vaXNcIixcblx0XHRcIkluZGlhbiBPY2VhblwiOiBcIk9jZcOgIMONbmRpY1wiLFxuXHRcdFwiSW5kaWFuIFN1YmNvbnRpbmVudFwiOiBcIlN1YmNvbnRpbmVudCBpbmRpXCIsXG5cdFx0SW5kaWFuYTogXCJJbmRpYW5hXCIsXG5cdFx0SW5kb25lc2lhOiBcIkluZG9uw6hzaWFcIixcblx0XHRJb3dhOiBcIklvd2FcIixcblx0XHRcIklyZWxhbmQgYW5kIFVuaXRlZCBLaW5nZG9tXCI6IFwiSXJsYW5kYSBpIGVsIFJlZ25lIFVuaXRcIixcblx0XHRJdGFseTogXCJJdMOgbGlhXCIsXG5cdFx0SmFwYW46IFwiSmFww7NcIixcblx0XHRKdXBpdGVyOiBcIkrDunBpdGVyXCIsXG5cdFx0S2Fuc2FzOiBcIkthbnNhc1wiLFxuXHRcdFwiTGFzIFZlZ2FzXCI6IFwiTGFzIFZlZ2FzXCIsXG5cdFx0TGlieWE6IFwiTMOtYmlhXCIsXG5cdFx0TWFsYXlzaWE6IFwiTWFsw6Bpc2lhXCIsXG5cdFx0XCJNYWxheXNpYSBhbmQgU2luZ2Fwb3JlXCI6IFwiTWFsw6Bpc2lhIGkgU2luZ2FwdXJcIixcblx0XHRNYXJzOiBcIk1hcnRcIixcblx0XHRNZXJjdXJ5OiBcIk1lcmN1cmlcIixcblx0XHRNaW5uZXNvdGE6IFwiTWlubmVzb3RhXCIsXG5cdFx0TW9udGFuYTogXCJNb250YW5hXCIsXG5cdFx0XCJOQUQgMTkyN1wiOiBcIk5BRCAxOTI3XCIsXG5cdFx0XCJOQUQgMTkyNyAoVVMgRmVldClcIjogXCJOQUQgMTkyNyAocGV1cyBkZWxzIEVVQSlcIixcblx0XHRcIk5BRCAxOTgzXCI6IFwiTkFEIDE5ODNcIixcblx0XHRcIk5BRCAxOTgzICgyMDExKVwiOiBcIk5BRCAxOTgzICgyMDExKVwiLFxuXHRcdFwiTkFEIDE5ODMgKDIwMTEpIChJbnRsIEZlZXQpXCI6IFwiTkFEIDE5ODMgKDIwMTEpIChwZXVzIGludGVybmFjaW9uYWxzKVwiLFxuXHRcdFwiTkFEIDE5ODMgKDIwMTEpIChNZXRlcnMpXCI6IFwiTkFEIDE5ODMgKDIwMTEpIChtZXRyZXMpXCIsXG5cdFx0XCJOQUQgMTk4MyAoMjAxMSkgKFVTIEZlZXQpXCI6IFwiTkFEIDE5ODMgKDIwMTEpIChwZXVzIGRlbHMgRVVBKVwiLFxuXHRcdFwiTkFEIDE5ODMgKENPUlM5NikgKEludGwgRmVldClcIjogXCJOQUQgMTk4MyAoQ09SUzk2KSAocGV1cyBpbnRlcm5hY2lvbmFscylcIixcblx0XHRcIk5BRCAxOTgzIChDT1JTOTYpIChNZXRlcnMpXCI6IFwiTkFEIDE5ODMgKENPUlM5NikgKG1ldHJlcylcIixcblx0XHRcIk5BRCAxOTgzIChDT1JTOTYpIChVUyBGZWV0KVwiOiBcIk5BRCAxOTgzIChDT1JTOTYpIChwZXVzIGRlbHMgRVVBKVwiLFxuXHRcdFwiTkFEIDE5ODMgKEludGwgRmVldClcIjogXCJOQUQgMTk4MyAocGV1cyBpbnRlcm5hY2lvbmFscylcIixcblx0XHRcIk5BRCAxOTgzIChNZXRlcnMpXCI6IFwiTkFEIDE5ODMgKG1ldHJlcylcIixcblx0XHRcIk5BRCAxOTgzIChQQTExKSAoTWV0ZXJzKVwiOiBcIk5BRCAxOTgzIChQQTExKSAobWV0cmVzKVwiLFxuXHRcdFwiTkFEIDE5ODMgKFBBMTEpIChVUyBGZWV0KVwiOiBcIk5BRCAxOTgzIChQQTExKSAocGV1cyBkZWxzIEVVQSlcIixcblx0XHRcIk5BRCAxOTgzIChVUyBGZWV0KVwiOiBcIk5BRCAxOTgzIChwZXVzIGRlbHMgRVVBKVwiLFxuXHRcdFwiTkFEIDE5ODMgSEFSTiAoSW50bCBGZWV0KVwiOiBcIk5BRCAxOTgzIEhBUk4gKHBldXMgaW50ZXJuYWNpb25hbHMpXCIsXG5cdFx0XCJOQUQgMTk4MyBIQVJOIChNZXRlcnMpXCI6IFwiTkFEIDE5ODMgSEFSTiAobWV0cmVzKVwiLFxuXHRcdFwiTkFEIDE5ODMgSEFSTiAoVVMgRmVldClcIjogXCJOQUQgMTk4MyBIQVJOIChwZXVzIGRlbHMgRVVBKVwiLFxuXHRcdFwiTkFEIDE5ODMgTlNSUzIwMDcgKEludGwgRmVldClcIjogXCJOQUQgMTk4MyBOU1JTMjAwNyAocGV1cyBpbnRlcm5hY2lvbmFscylcIixcblx0XHRcIk5BRCAxOTgzIE5TUlMyMDA3IChNZXRlcnMpXCI6IFwiTkFEIDE5ODMgTlNSUzIwMDcgKG1ldHJlcylcIixcblx0XHRcIk5BRCAxOTgzIE5TUlMyMDA3IChVUyBGZWV0KVwiOiBcIk5BRCAxOTgzIE5TUlMyMDA3IChwZXVzIGRlbHMgRVVBKVwiLFxuXHRcdFwiTmF0aW9uYWwgR3JpZHNcIjogXCJRdWFkcsOtY3VsZXMgbmFjaW9uYWxzXCIsXG5cdFx0TmF2YWpvOiBcIk5hdmFqb1wiLFxuXHRcdE5lcHR1bmU6IFwiTmVwdMO6XCIsXG5cdFx0XCJOZXcgQmVpamluZ1wiOiBcIk5vdSBQZXF1w61uXCIsXG5cdFx0XCJOZXcgWmVhbGFuZFwiOiBcIk5vdmEgWmVsYW5kYVwiLFxuXHRcdFwiTm9ydGggQW1lcmljYVwiOiBcIkFtw6hyaWNhIGRlbCBOb3JkXCIsXG5cdFx0XCJOb3J0aGVybiBIZW1pc3BoZXJlXCI6IFwiSGVtaXNmZXJpIG5vcmRcIixcblx0XHROb3J3YXk6IFwiTm9ydWVnYVwiLFxuXHRcdE9jZWFuczogXCJPY2VhbnNcIixcblx0XHRPcmVnb246IFwiT3JlZ29uXCIsXG5cdFx0XCJPdGhlciBHQ1NcIjogXCJBbHRyZXMgR0NTXCIsXG5cdFx0XCJQYWNpZmljIE9jZWFuXCI6IFwiT2Nlw6AgUGFjw61maWNcIixcblx0XHRQbHV0bzogXCJQbHV0w7NcIixcblx0XHRQb2xhcjogXCJQb2xhclwiLFxuXHRcdFBvcnR1Z2FsOiBcIlBvcnR1Z2FsXCIsXG5cdFx0XCJQcm9qZWN0ZWQgQ29vcmRpbmF0ZSBTeXN0ZW1zXCI6IFwiU2lzdGVtZXMgZGUgY29vcmRlbmFkZXMgcHJvamVjdGFkZXNcIixcblx0XHRcIlB1bGtvdm8gMTk0MlwiOiBcIlB1bGtvdm8gMTk0MlwiLFxuXHRcdFwiUHVsa292byAxOTk1XCI6IFwiUHVsa292byAxOTk1XCIsXG5cdFx0UmVwbGFjZWQ6IFwiU3Vic3RpdHXDr3RcIixcblx0XHRcIlNBRCAxOTY5XCI6IFwiU0FEIDE5NjlcIixcblx0XHRTSVJHQVM6IFwiU0lSR0FTXCIsXG5cdFx0XCJTSVJHQVMgMjAwMFwiOiBcIlNJUkdBUyAyMDAwXCIsXG5cdFx0U2F0dXJuOiBcIlNhdHVyblwiLFxuXHRcdFwiU29sYXIgU3lzdGVtXCI6IFwiU2lzdGVtYSBzb2xhclwiLFxuXHRcdFwiU291dGggQWZyaWNhXCI6IFwiU3VkLcOgZnJpY2FcIixcblx0XHRcIlNvdXRoIEFtZXJpY2FcIjogXCJBbcOocmljYSBkZWwgU3VkXCIsXG5cdFx0XCJTb3V0aCBLb3JlYVwiOiBcIkNvcmVhIGRlbCBTdWRcIixcblx0XHRcIlNvdXRoZXJuIEhlbWlzcGhlcmVcIjogXCJIZW1pc2Zlcmkgc3VkXCIsXG5cdFx0XCJTcGhlcm9pZC1iYXNlZFwiOiBcIkJhc2F0IGVuIGwnZXNmZXJvaWRlXCIsXG5cdFx0XCJTdGF0ZSBQbGFuZVwiOiBcIlN0YXRlIFBsYW5lXCIsXG5cdFx0XCJTdGF0ZSBTeXN0ZW1zXCI6IFwiU2lzdGVtZXMgZXN0YXRhbHNcIixcblx0XHRTd2VkZW46IFwiU3XDqGNpYVwiLFxuXHRcdFwiU3dpdHplcmxhbmQgYW5kIExpZWNodGVuc3RlaW5cIjogXCJTdcOvc3NhIGkgTGllY2h0ZW5zdGVpblwiLFxuXHRcdFRleGFzOiBcIlRleGFzXCIsXG5cdFx0VHJpYmFsOiBcIlRyaWJhbFwiLFxuXHRcdFR1cmtleTogXCJUdXJxdWlhXCIsXG5cdFx0XCJVUyBGZWV0XCI6IFwiUGV1cyBkZWxzIEVVQVwiLFxuXHRcdFwiVVNBIGFuZCB0ZXJyaXRvcmllc1wiOiBcIkVVQSBpIHRlcnJpdG9yaXNcIixcblx0XHRVVE06IFwiVVRNXCIsXG5cdFx0VWtyYWluZTogXCJVY3Jhw69uYVwiLFxuXHRcdFwiVW5rbm93biBIZWlnaHQgU3lzdGVtc1wiOiBcIlNpc3RlbWVzIGQnYWzDp2FkYSBkZXNjb25lZ3VkYVwiLFxuXHRcdFVyYW51czogXCJVcsOgXCIsXG5cdFx0VmVudXM6IFwiVmVudXNcIixcblx0XHRcIlZlcnRpY2FsIENvb3JkaW5hdGUgU3lzdGVtc1wiOiBcIlNpc3RlbWVzIGRlIGNvb3JkZW5hZGVzIHZlcnRpY2Fsc1wiLFxuXHRcdFZpZXRuYW06IFwiVmlldG5hbVwiLFxuXHRcdFwiV0dTIDE5NzJcIjogXCJXR1MgMTk3MlwiLFxuXHRcdFwiV0dTIDE5ODRcIjogXCJXR1MgMTk4NFwiLFxuXHRcdFdpc2NvbnNpbjogXCJXaXNjb25zaW5cIixcblx0XHRcIldpc2NvbnNpbiBDUlNcIjogXCJXaXNjb25zaW4gQ1JTXCIsXG5cdFx0V29ybGQ6IFwiTcOzblwiLFxuXHRcdFwiV29ybGQgKFNwaGVyZS1iYXNlZClcIjogXCJNw7NuIChiYXNhdCBlbiB1bmEgZXNmZXJhKVwiLFxuXHRcdFd5b21pbmc6IFwiV3lvbWluZ1wiLFxuXHRcdFwiWGlhbiAxOTgwXCI6IFwiWGlhbiAxOTgwXCIsXG5cdFx0ZG9uZTogXCJGZXRcIixcblx0XHRub1Jlc3VsdHM6IFwiTm8gcydoYW4gdHJvYmF0IHJlc3VsdGF0c1wiLFxuXHRcdHNlYXJjaFBsYWNlaG9sZGVyOiBcIk5vbSBvIFdLSURcIixcblx0XHRicm93c2VUZW1wbGF0ZTogXCJFeGFtaW5hIGxlcyBwbGFudGlsbGVzIGRlIGZ1bmNpw7MgZGUgcsOgc3RlclwiLFxuXHRcdHNhdmVUZW1wbGF0ZTogXCJEZXNhIGxhIHBsYW50aWxsYSBkZSBmdW5jacOzIGRlIHLDoHN0ZXJcIixcblx0XHRwcmV2aWV3OiBcIlZpc3VhbGl0emFjacOzIHByw6h2aWFcIixcblx0XHRwcmV2aWV3RGVzY3JpcHRpb246IFwiTW9zdHJhIHVuYSB2aXN1YWxpdHphY2nDsyBwcsOodmlhIGRlbCByZXN1bHRhdCBhYmFucyBkJ2V4ZWN1dGFyIGwnYW7DoGxpc2kuXCIsXG5cdFx0c2hvd1ByZXZpZXc6IFwiTW9zdHJhIGxhIHZpc3VhbGl0emFjacOzIHByw6h2aWFcIixcblx0XHRwcmV2aWV3TGF5ZXI6IFwiVmlzdWFsaXR6YWNpw7MgcHLDqHZpYSBkZSBsYSBjYXBhICR7bnVtYmVyfVwiLFxuXHRcdG5ld1ByZXZpZXc6IFwiVmlzdWFsaXR6YWNpw7MgcHLDqHZpYSBub3ZhXCIsXG5cdFx0cHJldmlld1BvcHVwOiBcIkhhYmlsaXRldSBsYSB2aXN1YWxpdHphY2nDsyBwcsOodmlhIGRlbHMgcmVzdWx0YXRzIGRlIGwnYW7DoGxpc2kgZW4gZnVuY2nDsyBkZWxzIHBhcsOgbWV0cmVzIGQnZW50cmFkYS5cIixcblx0XHR1cGRhdGVQcmV2aWV3TGF5ZXI6IFwiQWN0dWFsaXR6YSBsYSBjYXBhIGRlIHZpc3VhbGl0emFjacOzIHByw6h2aWEgc2VsZWNjaW9uYWRhXCIsXG5cdFx0Y3JlYXRlUHJldmlld0xheWVyOiBcIkNyZWEgdW5hIGNhcGEgZGUgdmlzdWFsaXR6YWNpw7MgcHLDqHZpYSBub3ZhXCIsXG5cdFx0bWF4aW11bVByZXZpZXdBbGxvd2VkOiBcIk5vbWJyZSBtw6B4aW0gZGUgY2FwZXMgZGUgdmlzdWFsaXR6YWNpw7MgcHLDqHZpYSBwZXJtZXNlczogJHttYXhDb3VudH1cIixcblx0XHRwcmV2aWV3RmFpbHVyZTogXCJBcXVlc3RhIGNhcGEgZGUgdmlzdWFsaXR6YWNpw7MgcHLDqHZpYSBubyBlc3TDoCBkaXNwb25pYmxlLiBDb21wcm92ZXUgZWxzIHBhcsOgbWV0cmVzIGQnZW50YWRhIGkgdG9ybmV1IGEgYWN0dWFsaXR6YXIgYXF1ZXN0YSBjYXBhIGRlIHZpc3VhbGl0emFjacOzIHByw6h2aWEuXCIsXG5cdFx0aGVhZGVyOiBcIlNlbGVjY2lvbmEgbCdlbGVtZW50XCIsXG5cdFx0Y29udGVudDogXCJUZW5pdSBjYW52aXMgc2Vuc2UgZGVzYXIgYSAke3JmdFRpdGxlfS4gU2kgdG9ybmV1IGEgY29tZW7Dp2FyIGFtYiB1bmEgcGxhbnRpbGxhIG5vdmEsIGFxdWVzdHMgY2FudmlzIGVzIHBlcmRyYW4uXCIsXG5cdFx0ZG9udFNhdmU6IFwiTm8gaG8gZGVzaXNcIixcblx0XHRcImNvbnRpbnVlXCI6IFwiQ29udGludWFcIixcblx0XHRzdHJldGNoOiBcIkFqdXN0YSBhIGxhIGZpbmVzdHJhXCIsXG5cdFx0cGFuOiBcIkRlc3BsYcOnYVwiLFxuXHRcdG5ld1RlbXBsYXRlOiBcIkNyZWEgdW5hIHBsYW50aWxsYSBub3ZhXCIsXG5cdFx0b3BlblRlbXBsYXRlOiBcIk9icmUgbGEgcGxhbnRpbGxhXCIsXG5cdFx0YWRkRnVuY3Rpb246IFwiQWZlZ2VpeCBmdW5jaW9ucyBkZSByw6BzdGVyXCIsXG5cdFx0YWRkQ29uc3RhbnQ6IFwiQWZlZ2VpeCB1bmEgY29uc3RhbnRcIixcblx0XHRhZGRSYXN0ZXI6IFwiQWZlZ2VpeCB1bmEgdmFyaWFibGUgZGUgcsOgc3RlclwiLFxuXHRcdG1vdmU6IFwiTW91XCIsXG5cdFx0em9vbTogXCJab29tXCIsXG5cdFx0c2F2ZUFzOiBcIkFub21lbmEgaSBkZXNhXCIsXG5cdFx0Y2xlYXI6IFwiRXNib3JyYVwiLFxuXHRcdGFkZFJhc3RlckZ1bmN0aW9uVGl0bGU6IFwiQWZlZ2VpeCBmdW5jaW9ucyBkZSByw6BzdGVyXCIsXG5cdFx0dGVtcGxhdGVQcm9wZXJ0aWVzVGl0bGU6IFwiUHJvcGlldGF0cyBkZSBsYSBwbGFudGlsbGFcIixcblx0XHRicm93c2VSRlQ6IFwiRXhhbWluYSBsZXMgcGxhbnRpbGxlcyBkZSBmdW5jacOzIGRlIHLDoHN0ZXJcIixcblx0XHRkZWZhdWx0VG9vbERlc2NyaXB0aW9uOiBcIkVpbmEgZCdhbsOgbGlzaSAke3Rvb2xUaXRsZX0uXCIsXG5cdFx0b3BlblRvb2xUZXh0OiBcIk9icmUgbCdlaW5hXCIsXG5cdFx0dG9vbERyb3Bkb3duVGV4dDogXCJNZW7DuiBkZXNwbGVnYWJsZSBkJ2VpbmVzXCIsXG5cdFx0YWRkVG9NYXA6IFwiQ29uZmlybWEgaSBhZmVnZWl4IGFsIG1hcGFcIixcblx0XHRjb25maXJtOiBcIkNvbmZpcm1hXCIsXG5cdFx0c2VsZWN0OiBcIlNlbGVjY2lvbmFcIixcblx0XHRzZWxlY3RUYXNrOiBcIlNlbGVjY2lvbmV1IHVuYSB0YXNjYVwiLFxuXHRcdHVuc3VwcG9ydGVkTGF5ZXI6IFwiQXF1ZXN0IHBhcsOgbWV0cmUgbm8gYWRtZXQgbGVzIGNhcGVzIHNlZ8O8ZW50czogJHtsYXllck5hbWV9LlwiLFxuXHRcdHZpZXdEZXRhaWxzOiBcIlZpc3VhbGl0emEgdG90cyBlbHMgZGV0YWxscyBkZSBsJ2VsZW1lbnRcIixcblx0XHRyZW5hbWU6IFwiQ2FudmlhIGVsIG5vbVwiLFxuXHRcdGR1cGxpY2F0ZTogXCJEdXBsaWNhXCIsXG5cdFx0bGF1bmNoOiBcIk9icmUtaG8gcGVyIGV4ZWN1dGFyLWhvXCIsXG5cdFx0dGVtcGxhdGVFZGl0b3I6IFwiRWRpdG9yIGRlIHBsYW50aWxsZXNcIixcblx0XHRjcmVhdGVJdGVtOiBcIkRlc2EgbGEgcGxhbnRpbGxhIGRlIGZ1bmNpb25zIGRlIHLDoHN0ZXJcIixcblx0XHRhY3Rpb25MYWJlbDogXCJGaWx0cmVcIixcblx0XHRmaWx0ZXJQb3BvdmVySGVhZGluZzogXCJGaWx0cmEgbGVzIGZ1bmNpb25zXCIsXG5cdFx0ZGVmYXVsdFNlYXJjaFBsYWNlaG9sZGVyOiBcIkNlcmNhIHBlciBub21cIixcblx0XHRzZXR0aW5nczogXCJDb25maWd1cmFjacOzXCIsXG5cdFx0c3VtbWFyeTogXCJSZXN1bVwiLFxuXHRcdGRlZmluaXRpb25RdWVyeTogXCJDb25zdWx0YSBkZSBkZWZpbmljacOzXCIsXG5cdFx0bWF0Y2hWYXJpYWJsZXM6IFwiVmFyaWFibGVzIGRlIGNvaW5jaWTDqG5jaWFcIixcblx0XHR1bmlvbkRpbWVuc2lvbjogXCJEaW1lbnNpw7MgZCd1bmnDs1wiLFxuXHRcdG5hbWVFZGl0b3JQbGFjZWhvbGRlcjogXCJJbnRyb2R1w691IGVsIHTDrXRvbFwiLFxuXHRcdHN1bW1hcnlFZGl0b3JQbGFjZWhvbGRlcjogXCJJbnRyb2R1w691IHVuYSBkZXNjcmlwY2nDsyBicmV1LlwiLFxuXHRcdGRlZmluaXRpb25RdWVyeVBsYWNlaG9sZGVyOiBcIkludHJvZHXDr3UuLi5cIixcblx0XHR1cGxvYWQ6IFwiUHVqYVwiLFxuXHRcdGNob29zZUltYWdlOiBcIkZldSBjbGljIHBlciB0cmlhciB1biBmaXR4ZXJcIixcblx0XHR1cGRhdGU6IFwiQWN0dWFsaXR6YVwiLFxuXHRcdHRodW1ibmFpbEVycm9yczoge1xuXHRcdFx0d3JvbmdJbWFnZVR5cGU6IFwiRWwgdGlwdXMgZCdpbWF0Z2Ugc2VsZWNjaW9uYXQgw6lzIGluY29ycmVjdGVcIixcblx0XHRcdG5vdEF2YWlsYWJsZTogXCJNaW5pYXR1cmEgbm8gZGlzcG9uaWJsZVwiLFxuXHRcdFx0bG9hZEVycm9yOiBcIk5vIHMnaGEgcG9ndXQgY2FycmVnYXIgbGEgaW1hdGdlXCIsXG5cdFx0XHRjaG9vc2VGaWxlOiBcIkZldSBjbGljIHBlciB0cmlhciBlbCBmaXR4ZXJcIlxuXHRcdH1cblx0fVxufTtcbmNvbnN0IGNvcHkgPSBcIkNvcGlhXCI7XG5jb25zdCBzYXZlID0gXCJEZXNhXCI7XG5jb25zdCB0aXRsZSA9IFwiVMOtdG9sXCI7XG5jb25zdCBmb2xkZXIgPSBcIkNhcnBldGFcIjtcbmNvbnN0IHRhZ3MgPSBcIkV0aXF1ZXRlc1wiO1xuY29uc3Qgc2F2aW5nTWVzc2FnZSA9IFwiUydlc3TDoCBkZXNhbnQgbCdlbGVtZW50IGFcIjtcbmNvbnN0IHNoYXJlV2l0aCA9IFwiQ29tcGFydGVpeC1obyBhbWJcIjtcbmNvbnN0IHNoYXJlID0gXCJDb21wYXJ0ZWl4XCI7XG5jb25zdCBzZXRTaGFyaW5nTGV2ZWwgPSBcIkRlZmluZWl4IGVsIG5pdmVsbCBkJ8O6cyBjb21wYXJ0aXRcIjtcbmNvbnN0IHNldEdyb3VwU2hhcmluZyA9IFwiRGVmaW5laXggbCfDunMgY29tcGFydGl0IGRlbCBncnVwXCI7XG5jb25zdCBvd25lciA9IFwiUHJvcGlldGFyaVwiO1xuY29uc3Qgb3JnYW5pemF0aW9uID0gXCJPcmdhbml0emFjacOzXCI7XG5jb25zdCBldmVyeW9uZSA9IFwiVG90aG9tIChww7pibGljKVwiO1xuY29uc3QgZ3JvdXBzID0gXCJHcnVwczpcIjtcbmNvbnN0IHR5cGUgPSBcIlRpcHVzXCI7XG5jb25zdCBtb3NhaWMgPSBcIk1vc2FpY1wiO1xuY29uc3QgaXRlbUdyb3VwID0gXCJHcnVwIGQnZWxlbWVudHNcIjtcbmNvbnN0IGl0ZW0gPSBcIkVsZW1lbnRcIjtcbmNvbnN0IGRlZmluaXRpb25RdWVyeSA9IFwiQ29uc3VsdGEgZGUgZGVmaW5pY2nDs1wiO1xuY29uc3QgZ3JvdXBJdGVtc0J5ID0gXCJBZ3J1cGEgZWxzIGVsZW1lbnRzIHBlclwiO1xuY29uc3QgZ3JvdXBGaWVsZE5hbWUgPSBcIk5vbSBkZWwgY2FtcCBkZSBncnVwXCI7XG5jb25zdCB0YWdGaWVsZE5hbWUgPSBcIk5vbSBkZWwgY2FtcCBkJ2V0aXF1ZXRhXCI7XG5jb25zdCBub1RpdGxlVGFnRXJyb3JNc2cgPSBcIkhldSBkZSBwcm9wb3JjaW9uYXIgdW4gdMOtdG9sIHBlciBhIGwnZWxlbWVudCBpIGV0aXF1ZXRlcyBwZXJxdcOoIGVsIG1hcGEgZXMgcHVndWkgdHJvYmFyIG1pdGphbsOnYW50IGNlcnF1ZXMuXCI7XG5jb25zdCBub1RpdGxlRXJyb3JNc2cgPSBcIkhldSBkZSBwcm9wb3JjaW9uYXIgdW4gdMOtdG9sIHBlciBhIGwnZWxlbWVudC5cIjtcbmNvbnN0IG5vVGFnRXJyb3JNc2cgPSBcIkhldSBkZSBwcm9wb3JjaW9uYXIgY29tIGEgbcOtbmltIHVuYSBldGlxdWV0YSBwZXIgYWp1ZGFyIGxlcyBwZXJzb25lcyBhIHRyb2JhciBlbCB2b3N0cmUgZWxlbWVudCBtaXRqYW7Dp2FudCBjZXJxdWVzLlwiO1xuY29uc3QgZXJyb3IgPSBcIkVycm9yXCI7XG5jb25zdCB3YXJuaW5nID0gXCJBdsOtc1wiO1xuY29uc3Qgc3VjY2VzcyA9IFwiQ29ycmVjdGVcIjtcbmNvbnN0IGRldGFpbHMgPSBcIkRldGFsbHM6XCI7XG5jb25zdCB0cnlBZ2FpbiA9IFwiVG9ybmEtaG8gYSBwcm92YXJcIjtcbmNvbnN0IHRvb2xNb2RlbGVyID0ge1xuXHRzYXZlOiBcIkRlc2FcIixcblx0ZWRpdFByb3BlcnRpZXM6IFwiRWRpdGEgbGVzIHByb3BpZXRhdHNcIixcblx0c2F2ZUFzOiBcIkFub21lbmEgaSBkZXNhXCIsXG5cdHNhdmluZ05vdGlmaWNhdGlvbjogXCJTJ2VzdGFuIGRlc2FudCBlbHMgY2FudmlzIGEgbCdlbGVtZW50Li4uXCIsXG5cdHNhdmluZ1RpdGxlOiBcIlMnZXN0w6AgZGVzYW50XCIsXG5cdHNhdmVGYWlsZWRNZXNzYWdlOiBcIk5vIHMnaGFuIHBvZ3V0IGRlc2FyIGVscyBjYW52aXMuXCIsXG5cdHNhdmVXaXRoRXJyb3JzTWVzc2FnZTogXCJFbHMgY2FudmlzIHMnaGFuIGRlc2F0IGFtYiBlbHMgZXJyb3JzIHNlZ8O8ZW50cy5cIixcblx0dmlld0l0ZW1NZXNzYWdlOiBcIlZpc3VhbGl0emV1IGwnZWxlbWVudCBkZXNhdFwiLFxuXHRoZXJlOiBcImFxdcOtLlwiLFxuXHRpdGVtQ3JlYXRlZE1lc3NhZ2U6IFwiUydoYSBjcmVhdCB1biBlbGVtZW50IG5vdS5cIixcblx0Y2xpY2tUb1ZpZXdJdGVtTWVzc2FnZTogXCJGZXUgY2xpYyBhIEQnYWNvcmQgcGVyIHZpc3VhbGl0emFyIGxhIHDDoGdpbmEgZGUgZGV0YWxscyBkZSBsJ2VsZW1lbnQ7IGZldSBjbGljIGEgQ2FuY2VswrdsYSBwZXIgY29udGludWFyLlwiLFxuXHRyZWFkaW5nRmFpbGVkOiBcIk5vIHMnaGEgcG9ndXQgY2FycmVnYXIgbGEgcGxhbnRpbGxhIGRlIGZ1bmNpw7MgZGUgcsOgc3RlciBzZWxlY2Npb25hZGEuXCIsXG5cdGZhaWxlZFRvTG9hZFhNTDogXCJObyBzJ2hhIHBvZ3V0IHB1amFyIGxhIHBsYW50aWxsYSBkZSBmdW5jacOzIHLDoHN0ZXIgc2VsZWNjaW9uYWRhIGVuIGZvcm1hdCBYTUwuXCIsXG5cdGxlYXJuTW9yZTogXCJNw6lzIGluZm9ybWFjacOzXCIsXG5cdG92ZXJ3cml0ZVRpdGxlOiBcIkNvbmZpcm1hIGxhIHNvYnJlZXNjcmlwdHVyYVwiLFxuXHRvdmVyd3JpdGVNZXNzYWdlOiBcIlZvbGV1IHNvYnJlZXNjcml1cmUgbCdlbGVtZW50IGV4aXN0ZW50P1wiLFxuXHRvdmVyd3JpdGVTdWNjZXNzTWVzc2FnZTogXCJMJ2VsZW1lbnQgcydoYSBhY3R1YWxpdHphdC5cIlxufTtcbmNvbnN0IHRvb2xFZGl0b3IgPSB7XG5cdHJ1bjogXCJFeGVjdXRhXCIsXG5cdHNhdmU6IFwiRGVzYVwiLFxuXHRkZWxldGVTZWxlY3RlZDogXCJTdXByaW1laXggZWxzIGVsZW1lbnRzIHNlbGVjY2lvbmF0c1wiLFxuXHRhZGRSYXN0ZXI6IFwiQWZlZ2VpeCB1biByw6BzdGVyXCIsXG5cdGFkZFNjYWxhcjogXCJBZmVnZWl4IHVuIGVzY2FsYXJcIixcblx0bGF5b3V0OiBcIkRpc3NlbnkgYXV0b23DoHRpY1wiLFxuXHRlcnJvclRpdGxlOiBcIkVycm9yXCIsXG5cdGludmFsaWRUb29sTWVzc2FnZTogXCJMYSBwbGFudGlsbGEgZGUgZnVuY2nDsyBkZSByw6BzdGVyIG5vIMOpcyB2w6BsaWRhLlwiLFxuXHRvdXQ6IFwiRm9yYVwiLFxuXHR6b29tSW46IFwiQW1wbGlhXCIsXG5cdHpvb21PdXQ6IFwiUmVkdWVpeFwiLFxuXHR6b29tVG9GaXQ6IFwiQWp1c3RhIGEgbGEgZmluZXN0cmFcIixcblx0cGFuT246IFwiQ2FudmlhIGFsIG1vZGUgcGFub3LDoG1pY1wiLFxuXHRwYW5PZmY6IFwiRGVzYWN0aXZhIGVsIG1vZGUgcGFub3LDoG1pY1wiLFxuXHRkZWZhdWx0TW9kZWxOYW1lOiBcIk1vZGVsIGQnZWluYVwiLFxuXHRkZWZhdWx0UmFzdGVyTmFtZTogXCJSw6BzdGVyXCJcbn07XG5jb25zdCB0b29sRGV0YWlsc0VkaXRvciA9IHtcblx0ZGVmYXVsdFRvb2xOYW1lOiBcIlBsYW50aWxsYSBkZSBmdW5jacOzIGRlIHLDoHN0ZXJcIixcblx0ZGVmYXVsdFRvb2xEZXNjcmlwdGlvbjogXCJBZmVnaXUgdW4gcmVzdW0gYnJldSBzb2JyZSBsYSBmdW5jacOzIGRlIHLDoHN0ZXIuXCIsXG5cdGRlZmF1bHRIZWxwVGV4dDogXCJGZXUgY2xpYyBhIGxhIGljb25hIGQnYWp1ZGEgcGVyIGVkaXRhciBlbCB0ZXh0IGQnYWp1ZGFcIixcblx0ZWRpdEhlbHBUaXRsZTogXCJFZGl0YSBsJ2FqdWRhXCIsXG5cdHNhdmVMYWJlbDogXCJEZXNhXCIsXG5cdGNhbmNlbExhYmVsOiBcIkNhbmNlbMK3bGFcIixcblx0dGh1bWJuYWlsOiB7XG5cdFx0d3JvbmdJbWFnZVR5cGU6IFwiRWwgdGlwdXMgZCdpbWF0Z2Ugc2VsZWNjaW9uYXQgw6lzIGluY29ycmVjdGVcIixcblx0XHRub3RBdmFpbGFibGU6IFwiTWluaWF0dXJhIG5vIGRpc3BvbmlibGVcIixcblx0XHRsb2FkRXJyb3I6IFwiTm8gcydoYSBwb2d1dCBjYXJyZWdhciBsYSBpbWF0Z2VcIixcblx0XHRjaG9vc2VGaWxlOiBcIkZldSBjbGljIHBlciB0cmlhciBlbCBmaXR4ZXJcIlxuXHR9XG59O1xuY29uc3Qgc2F2ZVV0aWxzID0ge1xuXHR0aHVtYm5haWw6IFwiTWluaWF0dXJhXCIsXG5cdHNoYXJpbmc6IFwiw5pzIGNvbXBhcnRpdFwiXG59O1xuY29uc3QgY2xvc2UgPSBcIlRhbmNhXCI7XG5jb25zdCB1bnNhdmVkV2FybmluZ0V4aXN0aW5nID0gXCJWb2xldSBkZXNhciBlbHMgY2FudmlzIGEgbCdlbGVtZW50IDxiPiR7aXRlbVRpdGxlfTwvYj4gP1wiO1xuY29uc3QgdW5zYXZlZFdhcm5pbmdOZXcgPSBcIlZvbGV1IGRlc2FyIGVscyBjYW52aXM/XCI7XG5jb25zdCBzYXZlQXMgPSBcIkFub21lbmEgaSBkZXNhXCI7XG5jb25zdCBkb250U2F2ZSA9IFwiTm8gaG8gZGVzaXNcIjtcbmNvbnN0IHVuc2F2ZWRUaXRsZSA9IFwiQ2FudmlzIHNlbnNlIGRlc2FyXCI7XG5jb25zdCBpbnZhbGlkUkZUTWVzc2FnZSA9IFwiTGEgcGxhbnRpbGxhIGRlIGZ1bmNpw7MgZGUgcsOgc3RlciBjcmVhZGEgbm8gw6lzIHbDoGxpZGEuXCI7XG5jb25zdCBlcnJvclRpdGxlID0gXCJFcnJvclwiO1xuY29uc3QgYnJlYWRjcnVtYiA9IFwiRWRpdG9yIGRlIGZ1bmNpb25zIHLDoHN0ZXJcIjtcbmNvbnN0IGJyZWFkY3J1bWJFZGl0b3IgPSBcIkNvbnRpbmd1dCA+IEVkaXRvciBkZSBmdW5jaW9ucyByw6BzdGVyXCI7XG5jb25zdCB2aWV3ZXJNb2RlVGl0bGUgPSBcIk5vbcOpcyBkZSBsZWN0dXJhXCI7XG5jb25zdCB2aWV3ZXJNb2RlTWVzc2FnZSA9IFwiTCdlbGVtZW50IGRlIGxhIHBsYW50aWxsYSBkZSBmdW5jacOzIGRlIHLDoHN0ZXIgw6lzIG5vbcOpcyBkZSBsZWN0dXJhIE5vIGVzIHBvZGVuIGRlc2FyIGVscyBjYW52aXMuXCI7XG5jb25zdCB1c2VyU3RhcnREaXJlY3Rpb24gPSBcIlNlbGVjY2lvbmV1IHVuYSBmdW5jacOzIHBlciBjb21lbsOnYXIgYSBjcmVhciB1bmEgcGxhbnRpbGxhIGRlIGZ1bmNpw7MgZGUgcsOgc3Rlci5cIjtcbmNvbnN0IHNlbGVjdEZ1bmN0aW9uID0gXCJBZmVnZWl4IHVuYSBmdW5jacOzXCI7XG5jb25zdCBkZXNlbGVjdEZ1bmN0aW9uID0gXCJFbGltaW5hIGxhIGZ1bmNpw7NcIjtcbmNvbnN0IGRpYWxvZ1RpdGxlID0gXCJTaXN0ZW1hXCI7XG5jb25zdCBjYXRlZ29yeSA9IFwiQ2F0ZWdvcmllc1wiO1xuY29uc3Qgc2VhcmNoID0gXCJDZXJjYSBmdW5jaW9ucyBkZSByw6BzdGVyXCI7XG5jb25zdCBjYXRlZ29yeU5hbWVzID0ge1xuXHRhbmFseXNpczogXCJBbsOgbGlzaVwiLFxuXHRhcHBlYXJhbmNlOiBcIkFwYXJlbsOnYVwiLFxuXHRjbGFzc2lmaWNhdGlvbjogXCJDbGFzc2lmaWNhY2nDs1wiLFxuXHRjb252ZXJzaW9uOiBcIkNvbnZlcnNpw7NcIixcblx0Y29ycmVjdGlvbjogXCJDb3JyZWNjacOzXCIsXG5cdGRhdGFNYW5hZ2VtZW50OiBcIkFkbWluaXN0cmFjacOzIGRlIGRhZGVzXCIsXG5cdGRpc3RhbmNlOiBcIkRpc3TDoG5jaWFcIixcblx0ZGlzdGFuY2VMZWdhY3k6IFwiRGlzdMOgbmNpYSAoaGVyZXRhdClcIixcblx0aHlkcm9sb2d5OiBcIkhpZHJvbG9naWFcIixcblx0bWF0aDogXCJNYXRlbcOgdGlxdWVzXCIsXG5cdG1hdGhDb25kaXRpb25hbDogXCJNYXRlbcOgdGlxdWVzOiBjb25kaWNpb25hbHNcIixcblx0bWF0aExvZ2ljYWw6IFwiTWF0ZW3DoHRpcXVlczogbMOyZ2lxdWVzXCIsXG5cdG1hdGhUcmlnb25vbWV0cmljOiBcIk1hdGVtw6B0aXF1ZXM6IHRyaWdvbm9tw6h0cmlxdWVzXCIsXG5cdHJlY2xhc3M6IFwiUmVjbGFzc2lmaWNhXCIsXG5cdHN0YXRpc3RpY2FsOiBcIkVzdGFkw61zdGljYVwiLFxuXHRzdXJmYWNlOiBcIlN1cGVyZsOtY2llXCJcbn07XG5jb25zdCBjb21tb25TdHJpbmdzX2NhID0ge1xuXHRvazogb2ssXG5cdGNhbmNlbDogY2FuY2VsLFxuXHRlbnRlclVSTDogZW50ZXJVUkwsXG5cdHNlcnZpY2VVUkw6IHNlcnZpY2VVUkwsXG5cdHNlbGVjdFJhc3Rlcjogc2VsZWN0UmFzdGVyLFxuXHRmYWlsZWRUb0xvYWRMYXllcjogZmFpbGVkVG9Mb2FkTGF5ZXIsXG5cdGxvYWRpbmdMYXllcjogbG9hZGluZ0xheWVyLFxuXHRzZWxlY3RGZWF0dXJlOiBzZWxlY3RGZWF0dXJlLFxuXHRlbnRlckZVUkw6IGVudGVyRlVSTCxcblx0YWRkUmFzdGVyOiBhZGRSYXN0ZXIsXG5cdGFkZFNjYWxhcjogYWRkU2NhbGFyLFxuXHRyYXN0ZXI6IHJhc3Rlcixcblx0c2NhbGFyOiBzY2FsYXIsXG5cdGRlZmF1bHRNb2RlbE5hbWU6IGRlZmF1bHRNb2RlbE5hbWUsXG5cdGdlbmVyYWw6IGdlbmVyYWwsXG5cdHBhcmFtZXRlcnM6IHBhcmFtZXRlcnMsXG5cdHZhcmlhYmxlczogdmFyaWFibGVzLFxuXHRuYW1lOiBuYW1lLFxuXHRkZXNjcmlwdGlvbjogZGVzY3JpcHRpb24sXG5cdHBhcmFtZXRlcjogcGFyYW1ldGVyLFxuXHRpc1B1YmxpYzogaXNQdWJsaWMsXG5cdGlzRGF0YXNldDogaXNEYXRhc2V0LFxuXHR1bmtub3duUGl4ZWxUeXBlOiB1bmtub3duUGl4ZWxUeXBlLFxuXHRvdXRwdXRQaXhlbFR5cGU6IG91dHB1dFBpeGVsVHlwZSxcblx0dThQaXhlbFR5cGU6IHU4UGl4ZWxUeXBlLFxuXHRzOFBpeGVsVHlwZTogczhQaXhlbFR5cGUsXG5cdHUxNlBpeGVsVHlwZTogdTE2UGl4ZWxUeXBlLFxuXHRzMTZQaXhlbFR5cGU6IHMxNlBpeGVsVHlwZSxcblx0dTMyUGl4ZWxUeXBlOiB1MzJQaXhlbFR5cGUsXG5cdHMzMlBpeGVsVHlwZTogczMyUGl4ZWxUeXBlLFxuXHRmMzJQaXhlbFR5cGU6IGYzMlBpeGVsVHlwZSxcblx0ZjY0UGl4ZWxUeXBlOiBmNjRQaXhlbFR5cGUsXG5cdHByb3BlcnRpZXM6IHByb3BlcnRpZXMsXG5cdG11bHRpZGltZW5zaW9uYWxSdWxlczogbXVsdGlkaW1lbnNpb25hbFJ1bGVzLFxuXHRtYXRjaFZhcmlhYmxlczogbWF0Y2hWYXJpYWJsZXMsXG5cdHVuaW9uRGltZW5zaW9uczogdW5pb25EaW1lbnNpb25zLFxuXHRyYXN0ZXJGdW5jdGlvbkVkaXRvcjogcmFzdGVyRnVuY3Rpb25FZGl0b3IsXG5cdHJmeExpY2Vuc2VJbmZvOiByZnhMaWNlbnNlSW5mbyxcblx0cmFzdGVyRnVuY3Rpb25zOiByYXN0ZXJGdW5jdGlvbnMsXG5cdGNvcHk6IGNvcHksXG5cdHNhdmU6IHNhdmUsXG5cdHRpdGxlOiB0aXRsZSxcblx0Zm9sZGVyOiBmb2xkZXIsXG5cdHRhZ3M6IHRhZ3MsXG5cdHNhdmluZ01lc3NhZ2U6IHNhdmluZ01lc3NhZ2UsXG5cdHNoYXJlV2l0aDogc2hhcmVXaXRoLFxuXHRzaGFyZTogc2hhcmUsXG5cdHNldFNoYXJpbmdMZXZlbDogc2V0U2hhcmluZ0xldmVsLFxuXHRzZXRHcm91cFNoYXJpbmc6IHNldEdyb3VwU2hhcmluZyxcblx0b3duZXI6IG93bmVyLFxuXHRvcmdhbml6YXRpb246IG9yZ2FuaXphdGlvbixcblx0ZXZlcnlvbmU6IGV2ZXJ5b25lLFxuXHRncm91cHM6IGdyb3Vwcyxcblx0dHlwZTogdHlwZSxcblx0bW9zYWljOiBtb3NhaWMsXG5cdGl0ZW1Hcm91cDogaXRlbUdyb3VwLFxuXHRpdGVtOiBpdGVtLFxuXHRkZWZpbml0aW9uUXVlcnk6IGRlZmluaXRpb25RdWVyeSxcblx0Z3JvdXBJdGVtc0J5OiBncm91cEl0ZW1zQnksXG5cdGdyb3VwRmllbGROYW1lOiBncm91cEZpZWxkTmFtZSxcblx0dGFnRmllbGROYW1lOiB0YWdGaWVsZE5hbWUsXG5cdG5vVGl0bGVUYWdFcnJvck1zZzogbm9UaXRsZVRhZ0Vycm9yTXNnLFxuXHRub1RpdGxlRXJyb3JNc2c6IG5vVGl0bGVFcnJvck1zZyxcblx0bm9UYWdFcnJvck1zZzogbm9UYWdFcnJvck1zZyxcblx0ZXJyb3I6IGVycm9yLFxuXHR3YXJuaW5nOiB3YXJuaW5nLFxuXHRzdWNjZXNzOiBzdWNjZXNzLFxuXHRkZXRhaWxzOiBkZXRhaWxzLFxuXHR0cnlBZ2FpbjogdHJ5QWdhaW4sXG5cdHRvb2xNb2RlbGVyOiB0b29sTW9kZWxlcixcblx0dG9vbEVkaXRvcjogdG9vbEVkaXRvcixcblx0dG9vbERldGFpbHNFZGl0b3I6IHRvb2xEZXRhaWxzRWRpdG9yLFxuXHRzYXZlVXRpbHM6IHNhdmVVdGlscyxcblx0Y2xvc2U6IGNsb3NlLFxuXHR1bnNhdmVkV2FybmluZ0V4aXN0aW5nOiB1bnNhdmVkV2FybmluZ0V4aXN0aW5nLFxuXHR1bnNhdmVkV2FybmluZ05ldzogdW5zYXZlZFdhcm5pbmdOZXcsXG5cdHNhdmVBczogc2F2ZUFzLFxuXHRkb250U2F2ZTogZG9udFNhdmUsXG5cdHVuc2F2ZWRUaXRsZTogdW5zYXZlZFRpdGxlLFxuXHRpbnZhbGlkUkZUTWVzc2FnZTogaW52YWxpZFJGVE1lc3NhZ2UsXG5cdGVycm9yVGl0bGU6IGVycm9yVGl0bGUsXG5cdGJyZWFkY3J1bWI6IGJyZWFkY3J1bWIsXG5cdGJyZWFkY3J1bWJFZGl0b3I6IGJyZWFkY3J1bWJFZGl0b3IsXG5cdHZpZXdlck1vZGVUaXRsZTogdmlld2VyTW9kZVRpdGxlLFxuXHR2aWV3ZXJNb2RlTWVzc2FnZTogdmlld2VyTW9kZU1lc3NhZ2UsXG5cdHVzZXJTdGFydERpcmVjdGlvbjogdXNlclN0YXJ0RGlyZWN0aW9uLFxuXHRzZWxlY3RGdW5jdGlvbjogc2VsZWN0RnVuY3Rpb24sXG5cdGRlc2VsZWN0RnVuY3Rpb246IGRlc2VsZWN0RnVuY3Rpb24sXG5cdGRpYWxvZ1RpdGxlOiBkaWFsb2dUaXRsZSxcblx0Y2F0ZWdvcnk6IGNhdGVnb3J5LFxuXHRzZWFyY2g6IHNlYXJjaCxcblx0Y2F0ZWdvcnlOYW1lczogY2F0ZWdvcnlOYW1lc1xufTtcblxuZXhwb3J0IGRlZmF1bHQgY29tbW9uU3RyaW5nc19jYTtcbmV4cG9ydCB7IGFkZFJhc3RlciwgYWRkU2NhbGFyLCBicmVhZGNydW1iLCBicmVhZGNydW1iRWRpdG9yLCBjYW5jZWwsIGNhdGVnb3J5LCBjYXRlZ29yeU5hbWVzLCBjbG9zZSwgY29weSwgZGVmYXVsdE1vZGVsTmFtZSwgZGVmaW5pdGlvblF1ZXJ5LCBkZXNjcmlwdGlvbiwgZGVzZWxlY3RGdW5jdGlvbiwgZGV0YWlscywgZGlhbG9nVGl0bGUsIGRvbnRTYXZlLCBlbnRlckZVUkwsIGVudGVyVVJMLCBlcnJvciwgZXJyb3JUaXRsZSwgZXZlcnlvbmUsIGYzMlBpeGVsVHlwZSwgZjY0UGl4ZWxUeXBlLCBmYWlsZWRUb0xvYWRMYXllciwgZm9sZGVyLCBnZW5lcmFsLCBncm91cEZpZWxkTmFtZSwgZ3JvdXBJdGVtc0J5LCBncm91cHMsIGludmFsaWRSRlRNZXNzYWdlLCBpc0RhdGFzZXQsIGlzUHVibGljLCBpdGVtLCBpdGVtR3JvdXAsIGxvYWRpbmdMYXllciwgbWF0Y2hWYXJpYWJsZXMsIG1vc2FpYywgbXVsdGlkaW1lbnNpb25hbFJ1bGVzLCBuYW1lLCBub1RhZ0Vycm9yTXNnLCBub1RpdGxlRXJyb3JNc2csIG5vVGl0bGVUYWdFcnJvck1zZywgb2ssIG9yZ2FuaXphdGlvbiwgb3V0cHV0UGl4ZWxUeXBlLCBvd25lciwgcGFyYW1ldGVyLCBwYXJhbWV0ZXJzLCBwcm9wZXJ0aWVzLCByYXN0ZXIsIHJhc3RlckZ1bmN0aW9uRWRpdG9yLCByYXN0ZXJGdW5jdGlvbnMsIHJmeExpY2Vuc2VJbmZvLCBzMTZQaXhlbFR5cGUsIHMzMlBpeGVsVHlwZSwgczhQaXhlbFR5cGUsIHNhdmUsIHNhdmVBcywgc2F2ZVV0aWxzLCBzYXZpbmdNZXNzYWdlLCBzY2FsYXIsIHNlYXJjaCwgc2VsZWN0RmVhdHVyZSwgc2VsZWN0RnVuY3Rpb24sIHNlbGVjdFJhc3Rlciwgc2VydmljZVVSTCwgc2V0R3JvdXBTaGFyaW5nLCBzZXRTaGFyaW5nTGV2ZWwsIHNoYXJlLCBzaGFyZVdpdGgsIHN1Y2Nlc3MsIHRhZ0ZpZWxkTmFtZSwgdGFncywgdGl0bGUsIHRvb2xEZXRhaWxzRWRpdG9yLCB0b29sRWRpdG9yLCB0b29sTW9kZWxlciwgdHJ5QWdhaW4sIHR5cGUsIHUxNlBpeGVsVHlwZSwgdTMyUGl4ZWxUeXBlLCB1OFBpeGVsVHlwZSwgdW5pb25EaW1lbnNpb25zLCB1bmtub3duUGl4ZWxUeXBlLCB1bnNhdmVkVGl0bGUsIHVuc2F2ZWRXYXJuaW5nRXhpc3RpbmcsIHVuc2F2ZWRXYXJuaW5nTmV3LCB1c2VyU3RhcnREaXJlY3Rpb24sIHZhcmlhYmxlcywgdmlld2VyTW9kZU1lc3NhZ2UsIHZpZXdlck1vZGVUaXRsZSwgd2FybmluZyB9O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb21tb24tc3RyaW5ncy5jYS1hZGEzZDYwYy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=