"use strict";
(self["webpackChunkexb_client"] = self["webpackChunkexb_client"] || []).push([["vendors-extensions_widgets_arcgis_analysis_node_modules_arcgis_app-components_dist_esm_arcgis-734c67"],{

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/add-item-dbbe2f57.js":
/*!**************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/add-item-dbbe2f57.js ***!
  \**************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   a: () => (/* binding */ addItemState),
/* harmony export */   b: () => (/* binding */ addItemUrlState),
/* harmony export */   c: () => (/* binding */ addItemRequestState),
/* harmony export */   d: () => (/* binding */ addItemStore)
/* harmony export */ });
/* harmony import */ var _index_05956cab_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index-05956cab.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/index-05956cab.js");
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v4.0.58
 */


const addItemStore = (0,_index_05956cab_js__WEBPACK_IMPORTED_MODULE_0__.c)({
    typeKeywords: [],
    customParameters: [],
    analyzedLocationTypes: [],
    allowStoredAuth: true,
    isSecured: null,
    checkAuth: false
});
// Entire add item state object
const addItemState = addItemStore.state;
// Subsets of add item state
const addItemRequestState = addItemStore.state;
const addItemUrlState = addItemStore.state;



//# sourceMappingURL=add-item-dbbe2f57.js.map

/***/ }),

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/arcgis-new-item-pages-tile-layer-from-url.entry.js":
/*!********************************************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/arcgis-new-item-pages-tile-layer-from-url.entry.js ***!
  \********************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   arcgis_new_item_pages_tile_layer_from_url: () => (/* binding */ ArcgisNewItemPagesTileLayerFromUrl)
/* harmony export */ });
/* harmony import */ var _index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index-e3bf7da7.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/index-e3bf7da7.js");
/* harmony import */ var _add_item_dbbe2f57_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./add-item-dbbe2f57.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/add-item-dbbe2f57.js");
/* harmony import */ var _ui_bca7bcd1_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ui-bca7bcd1.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/ui-bca7bcd1.js");
/* harmony import */ var _functional_81373f6d_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./functional-81373f6d.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/functional-81373f6d.js");
/* harmony import */ var _index_05956cab_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./index-05956cab.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/index-05956cab.js");
/* harmony import */ var _functional_44de8fcf_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./functional-44de8fcf.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/functional-44de8fcf.js");
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v4.0.58
 */







const arcgisNewItemPagesTileLayerFromUrlCss = ".input-container{margin-bottom:1.5rem}.label{display:block;font-size:0.875rem;font-weight:500;color:var(--calcite-color-text-1);margin-top:0px;margin-bottom:0px;line-height:18px}calcite-label{--calcite-label-margin-bottom:0}.subdomain-container{margin-bottom:1.5rem}";

const ArcgisNewItemPagesTileLayerFromUrl = class {
    constructor(hostRef) {
        (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.r)(this, hostRef);
        this.workflowComplete = (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, "workflowComplete", 7);
        this.showSubdomains = false;
        this.handleChange = (event) => {
            const checked = event.target.checked;
            _add_item_dbbe2f57_js__WEBPACK_IMPORTED_MODULE_1__.a.storeAuth = checked;
        };
        this.handleLoaderUpdate = (event) => {
            this.loading = event.detail;
        };
        this.getPlaceholder = (type) => {
            const { i18n } = this;
            switch (type) {
                case "title":
                    return i18n.titlePlaceholder;
                case "attribution":
                    return i18n.attribution;
                case "subdomain":
                    return "https://{subDomain}.domain.com/<path>/{level}/{col}/{row}.png";
            }
        };
        this.assignRef = (ref, type) => {
            if (type === "title") {
                this.titleInputRef = ref;
            }
            else {
                this.attributionInputRef = ref;
            }
        };
        this.handleKeydown = (e) => {
            var _a;
            // If user typed a comma, treat as enter.
            // TODO: remove after calcite enables comma support (https://github.com/Esri/calcite-components/issues/4672)
            if (e.key === ",") {
                const target = e.target;
                const input = (_a = target === null || target === void 0 ? void 0 : target.shadowRoot) === null || _a === void 0 ? void 0 : _a.querySelector("input");
                if (input === null || input === void 0 ? void 0 : input.value) {
                    e.preventDefault();
                    const existing = target.querySelector(`calcite-combobox-item[value="${input.value}"]`);
                    if (existing) {
                        existing.selected = true;
                    }
                    else {
                        const item = document.createElement("calcite-combobox-item");
                        item.value = input.value;
                        item.textLabel = input.value;
                        item.selected = true;
                        target === null || target === void 0 ? void 0 : target.appendChild(item);
                    }
                    input.value = "";
                }
            }
        };
        this.i18n = undefined;
        this.errorMessage = undefined;
        this.loading = false;
        this.title = "";
        this.attribution = null;
        this.subdomains = [];
        this.useCurrentExtent = false;
    }
    async handleNext() {
        const { i18n, title, attribution, subdomains = null, useCurrentExtent } = this;
        const { url, customParameters, addAsBasemap } = _add_item_dbbe2f57_js__WEBPACK_IMPORTED_MODULE_1__.a;
        this.errorMessage = null;
        if (!title) {
            this.errorMessage = i18n.error.title;
            this.titleInputRef.setFocus();
            return;
        }
        if (!attribution) {
            this.errorMessage = i18n.error.attribution;
            this.attributionInputRef.setFocus();
            return;
        }
        this.loading = true;
        if (this.isAddToMapTerminalPage()) {
            this.workflowComplete.emit({
                title,
                attribution,
                subdomain: subdomains.join(","),
                useCurrentExtent,
                url,
                customParameters,
                type: "Tile Layer",
                addAsBasemap
            });
        }
    }
    async componentWillLoad() {
        const i18n = _ui_bca7bcd1_js__WEBPACK_IMPORTED_MODULE_2__.u.i18n;
        this.i18n = i18n.tileLayerFromUrl;
        if (this.isAddToMapTerminalPage()) {
            _ui_bca7bcd1_js__WEBPACK_IMPORTED_MODULE_2__.u.nextText = "addToMap";
        }
        this.showSubdomains = _add_item_dbbe2f57_js__WEBPACK_IMPORTED_MODULE_1__.a.url.toLowerCase().includes("{subdomain}");
        // TODO: assign state from store once this is not a terminal page
    }
    isAddToMapTerminalPage() {
        // ! Note: this page only supports direct mode for now
        return true;
    }
    render() {
        const { loading, errorMessage, i18n, getPlaceholder, assignRef, handleKeydown, showSubdomains } = this;
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)(_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.H, null, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("arcgis-new-item-loader", { active: loading }), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("arcgis-new-item-alert", { active: !!errorMessage, description: errorMessage, onAlertDismiss: () => (this.errorMessage = "") }), ["title", "attribution"].map((type) => ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", null, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("p", { class: "label" }, i18n[type]), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-input", { class: "input-container", placeholder: getPlaceholder(type), ref: (ref) => assignRef(ref, type), value: this[type], required: true, onCalciteInputInput: (e) => (this[type] = e.target.value) })))), showSubdomains && ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "subdomain-container" }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", null, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("p", { class: "label" }, i18n.subdomain), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-combobox", { label: i18n.subdomain, allowCustomValues: true, placeholder: i18n.subDomainPlaceholder, onKeyDown: handleKeydown, onCalciteComboboxChange: (event) => {
                event.stopPropagation();
                const node = event.target;
                this.subdomains = (0,_functional_81373f6d_js__WEBPACK_IMPORTED_MODULE_3__.f)(node.selectedItems.map((item) => item.value));
            } })))), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("arcgis-new-item-switch-card", { header: i18n.setTileExtent, onSwitchChange: (event) => {
                this.useCurrentExtent = event.detail;
            } })));
    }
    get element() { return (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.d)(this); }
};
ArcgisNewItemPagesTileLayerFromUrl.style = arcgisNewItemPagesTileLayerFromUrlCss;



//# sourceMappingURL=arcgis-new-item-pages-tile-layer-from-url.entry.js.map

/***/ }),

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/functional-44de8fcf.js":
/*!****************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/functional-44de8fcf.js ***!
  \****************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   a: () => (/* binding */ arrayToLookupMap),
/* harmony export */   b: () => (/* binding */ unique),
/* harmony export */   c: () => (/* binding */ throttle),
/* harmony export */   d: () => (/* binding */ debounce),
/* harmony export */   e: () => (/* binding */ escapeRegExp),
/* harmony export */   f: () => (/* binding */ arraysAreEquivalent),
/* harmony export */   g: () => (/* binding */ chunk),
/* harmony export */   i: () => (/* binding */ isDefined),
/* harmony export */   m: () => (/* binding */ minDelay),
/* harmony export */   t: () => (/* binding */ timeout),
/* harmony export */   u: () => (/* binding */ uniqueBy)
/* harmony export */ });
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v4.0.58
 */
/**
 * Call a function only after it has not been called for n milliseconds
 * @param fn    - function to call
 * @param delay - delay in milliseconds
 */
const debounce = (fn, delay) => {
    let timeout;
    let status = "idle";
    function flush(...args) {
        status = "flushed";
        return debounced(...args);
    }
    function invoke(...args) {
        status = "invoked";
        return debounced(...args);
    }
    function cancel(...args) {
        status = "cancelled";
        return debounced(...args);
    }
    function getStatus() {
        return status;
    }
    const debounced = (...args) => new Promise((resolve) => {
        switch (status) {
            case "flushed":
                status = "idle";
                if (timeout) {
                    clearTimeout(timeout);
                    resolve(fn(...args));
                }
                else {
                    resolve(null);
                }
                break;
            case "invoked":
                clearTimeout(timeout);
                status = "idle";
                resolve(fn(...args));
                break;
            case "cancelled":
                clearTimeout(timeout);
                status = "idle";
                resolve(null);
                break;
            default:
                if (timeout) {
                    clearTimeout(timeout);
                }
                status = "pending";
                timeout = setTimeout(() => {
                    status = "idle";
                    return resolve(fn(...args));
                }, delay);
                break;
        }
    });
    debounced.flush = flush;
    debounced.invoke = invoke;
    debounced.cancel = cancel;
    debounced.getStatus = getStatus;
    return debounced;
};
/**
 * Call a function only after n milliseconds have elapsed
 * @param fn    - function to call
 * @param delay - delay in milliseconds
 */
const throttle = (fn, delay) => {
    let timeout;
    return (...args) => new Promise((resolve) => {
        if (timeout) {
            return;
        }
        timeout = setTimeout(() => {
            clearTimeout(timeout);
            timeout = undefined;
            resolve(fn(...args));
        }, delay);
    });
};
function escapeRegExp(str) {
    return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"); // $& means the whole matched string
}
function isDefined(value) {
    return value !== undefined && value !== null;
}
/**
 * Set a minimum time for a promise to resolve (useful for preventing flash of loaders)
 */
async function minDelay(promise, minDelay) {
    await Promise.all([promise, timeout(minDelay)]);
    return promise;
}
/**
 * Helper method to inline setTimeout as an await in async functions
 */
function timeout(ms) {
    return new Promise((resolve) => setTimeout(resolve, ms));
}
const arrayToLookupMap = (dataArr, getKeyAndItem) => Object.fromEntries((dataArr || []).map((item) => {
    const { key, data } = getKeyAndItem(item);
    return [key, data];
}));
/**
 * Check whether two arrays have the same number of elements
 * and whether they contain the same elements
 * regardless of order
 */
const arraysAreEquivalent = (arr1, arr2) => arr1.length === arr2.length && arr1.reduce((memo, str) => memo && arr2.indexOf(str) > -1, true);
function uniqueBy(myArr, getItemId) {
    const resultArr = [];
    const lookupMap = {};
    myArr.forEach((item) => {
        const id = getItemId(item);
        if (lookupMap[id] == null) {
            lookupMap[id] = item;
            resultArr.push(item);
        }
    });
    return resultArr;
}
function unique(myArr) {
    const primitives = { boolean: {}, number: {}, string: {} };
    const objs = [];
    return myArr.filter((item) => {
        let type = typeof item;
        if (type in primitives) {
            return primitives[type].hasOwnProperty(item) ? false : (primitives[type][item] = true);
        }
        else {
            return objs.indexOf(item) >= 0 ? false : objs.push(item);
        }
    });
}
const chunk = (arr, size) => [...Array(Math.ceil(arr.length / size))].map((_, i) => arr.slice(size * i, size + size * i));



//# sourceMappingURL=functional-44de8fcf.js.map

/***/ }),

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/functional-81373f6d.js":
/*!****************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/functional-81373f6d.js ***!
  \****************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   a: () => (/* binding */ formatFileName),
/* harmony export */   f: () => (/* binding */ formatTags),
/* harmony export */   s: () => (/* binding */ streamPromises)
/* harmony export */ });
/* harmony import */ var _functional_44de8fcf_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./functional-44de8fcf.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/functional-44de8fcf.js");
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v4.0.58
 */


const formatFileName = (title) => (title === null || title === void 0 ? void 0 : title.replace(/(\s+|:)/g, "_")) || "";
const formatTags = (tags) => {
    const cleanTags = (tagObj) => {
        return tagObj
            .split(",")
            .map((tag) => tag.trim())
            .filter((tag) => tag);
    };
    if (!tags) {
        return [];
    }
    else if (typeof tags === "string") {
        return (0,_functional_44de8fcf_js__WEBPACK_IMPORTED_MODULE_0__.b)(cleanTags(tags));
    }
    else {
        return (0,_functional_44de8fcf_js__WEBPACK_IMPORTED_MODULE_0__.b)(tags.flatMap((tag) => {
            return [...cleanTags(tag)];
        }));
    }
};
const resolveOnFirstPromise = async (promiseList) => {
    return new Promise((resolve, reject) => {
        for (let i = 0; i < promiseList.length; i++) {
            promiseList[i]
                .then((result) => {
                const newArr = [...promiseList];
                newArr.splice(i, 1);
                resolve({ remainingPromises: newArr, result });
            })
                .catch(reject);
        }
    });
};
/**
 * Similar to Promise.all but will resolve on the first promise that resolves then continuously swap out the resolved promise with the next promise in the list
 * @param getNextPromise A function that returns the next promise to resolve
 */
async function streamPromises(getNextPromise, options) {
    var _a, _b;
    const results = [];
    const { getBatchSize, onPromiseCompleted, onPromiseThrow, shouldContinue } = options !== null && options !== void 0 ? options : {};
    let remainingPromises = [];
    for (let i = 0; i < ((_a = getBatchSize === null || getBatchSize === void 0 ? void 0 : getBatchSize()) !== null && _a !== void 0 ? _a : 1); i++) {
        try {
            const nextElement = getNextPromise();
            nextElement && remainingPromises.push(nextElement);
        }
        catch (e) {
            onPromiseThrow === null || onPromiseThrow === void 0 ? void 0 : onPromiseThrow(e);
        }
    }
    let lastResult = null;
    while (remainingPromises.length > 0 && (!shouldContinue || shouldContinue(lastResult))) {
        try {
            const { remainingPromises: _remainingPromises, result } = await resolveOnFirstPromise(remainingPromises);
            remainingPromises = _remainingPromises;
            lastResult = result;
            !!result && results.push(result);
            onPromiseCompleted === null || onPromiseCompleted === void 0 ? void 0 : onPromiseCompleted(result);
            // Update batch size after the new result is bubbled up
            const batchSize = (_b = getBatchSize === null || getBatchSize === void 0 ? void 0 : getBatchSize()) !== null && _b !== void 0 ? _b : 1;
            while (remainingPromises.length < batchSize) {
                const nextElement = getNextPromise();
                nextElement && remainingPromises.push(nextElement);
                if (nextElement == null) {
                    break;
                }
            }
        }
        catch (e) {
            onPromiseThrow === null || onPromiseThrow === void 0 ? void 0 : onPromiseThrow(e);
        }
    }
    return results;
}



//# sourceMappingURL=functional-81373f6d.js.map

/***/ }),

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/index-05956cab.js":
/*!***********************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/index-05956cab.js ***!
  \***********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   c: () => (/* binding */ createStore)
/* harmony export */ });
/* harmony import */ var _index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index-e3bf7da7.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/index-e3bf7da7.js");
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v4.0.58
 */


const appendToMap = (map, propName, value) => {
    const items = map.get(propName);
    if (!items) {
        map.set(propName, [value]);
    }
    else if (!items.includes(value)) {
        items.push(value);
    }
};
const debounce = (fn, ms) => {
    let timeoutId;
    return (...args) => {
        if (timeoutId) {
            clearTimeout(timeoutId);
        }
        timeoutId = setTimeout(() => {
            timeoutId = 0;
            fn(...args);
        }, ms);
    };
};

/**
 * Check if a possible element isConnected.
 * The property might not be there, so we check for it.
 *
 * We want it to return true if isConnected is not a property,
 * otherwise we would remove these elements and would not update.
 *
 * Better leak in Edge than to be useless.
 */
const isConnected = (maybeElement) => !('isConnected' in maybeElement) || maybeElement.isConnected;
const cleanupElements = debounce((map) => {
    for (let key of map.keys()) {
        map.set(key, map.get(key).filter(isConnected));
    }
}, 2000);
const stencilSubscription = () => {
    if (typeof _index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.g !== 'function') {
        // If we are not in a stencil project, we do nothing.
        // This function is not really exported by @stencil/core.
        return {};
    }
    const elmsToUpdate = new Map();
    return {
        dispose: () => elmsToUpdate.clear(),
        get: (propName) => {
            const elm = (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.g)();
            if (elm) {
                appendToMap(elmsToUpdate, propName, elm);
            }
        },
        set: (propName) => {
            const elements = elmsToUpdate.get(propName);
            if (elements) {
                elmsToUpdate.set(propName, elements.filter(_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.f));
            }
            cleanupElements(elmsToUpdate);
        },
        reset: () => {
            elmsToUpdate.forEach((elms) => elms.forEach(_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.f));
            cleanupElements(elmsToUpdate);
        },
    };
};

const unwrap = (val) => (typeof val === 'function' ? val() : val);
const createObservableMap = (defaultState, shouldUpdate = (a, b) => a !== b) => {
    const unwrappedState = unwrap(defaultState);
    let states = new Map(Object.entries(unwrappedState !== null && unwrappedState !== void 0 ? unwrappedState : {}));
    const handlers = {
        dispose: [],
        get: [],
        set: [],
        reset: [],
    };
    const reset = () => {
        var _a;
        // When resetting the state, the default state may be a function - unwrap it to invoke it.
        // otherwise, the state won't be properly reset
        states = new Map(Object.entries((_a = unwrap(defaultState)) !== null && _a !== void 0 ? _a : {}));
        handlers.reset.forEach((cb) => cb());
    };
    const dispose = () => {
        // Call first dispose as resetting the state would
        // cause less updates ;)
        handlers.dispose.forEach((cb) => cb());
        reset();
    };
    const get = (propName) => {
        handlers.get.forEach((cb) => cb(propName));
        return states.get(propName);
    };
    const set = (propName, value) => {
        const oldValue = states.get(propName);
        if (shouldUpdate(value, oldValue, propName)) {
            states.set(propName, value);
            handlers.set.forEach((cb) => cb(propName, value, oldValue));
        }
    };
    const state = (typeof Proxy === 'undefined'
        ? {}
        : new Proxy(unwrappedState, {
            get(_, propName) {
                return get(propName);
            },
            ownKeys(_) {
                return Array.from(states.keys());
            },
            getOwnPropertyDescriptor() {
                return {
                    enumerable: true,
                    configurable: true,
                };
            },
            has(_, propName) {
                return states.has(propName);
            },
            set(_, propName, value) {
                set(propName, value);
                return true;
            },
        }));
    const on = (eventName, callback) => {
        handlers[eventName].push(callback);
        return () => {
            removeFromArray(handlers[eventName], callback);
        };
    };
    const onChange = (propName, cb) => {
        const unSet = on('set', (key, newValue) => {
            if (key === propName) {
                cb(newValue);
            }
        });
        // We need to unwrap the defaultState because it might be a function.
        // Otherwise we might not be sending the right reset value.
        const unReset = on('reset', () => cb(unwrap(defaultState)[propName]));
        return () => {
            unSet();
            unReset();
        };
    };
    const use = (...subscriptions) => {
        const unsubs = subscriptions.reduce((unsubs, subscription) => {
            if (subscription.set) {
                unsubs.push(on('set', subscription.set));
            }
            if (subscription.get) {
                unsubs.push(on('get', subscription.get));
            }
            if (subscription.reset) {
                unsubs.push(on('reset', subscription.reset));
            }
            if (subscription.dispose) {
                unsubs.push(on('dispose', subscription.dispose));
            }
            return unsubs;
        }, []);
        return () => unsubs.forEach((unsub) => unsub());
    };
    const forceUpdate = (key) => {
        const oldValue = states.get(key);
        handlers.set.forEach((cb) => cb(key, oldValue, oldValue));
    };
    return {
        state,
        get,
        set,
        on,
        onChange,
        use,
        dispose,
        reset,
        forceUpdate,
    };
};
const removeFromArray = (array, item) => {
    const index = array.indexOf(item);
    if (index >= 0) {
        array[index] = array[array.length - 1];
        array.length--;
    }
};

const createStore = (defaultState, shouldUpdate) => {
    const map = createObservableMap(defaultState, shouldUpdate);
    map.use(stencilSubscription());
    return map;
};



//# sourceMappingURL=index-05956cab.js.map

/***/ }),

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/ui-bca7bcd1.js":
/*!********************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/ui-bca7bcd1.js ***!
  \********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   a: () => (/* binding */ uiStore),
/* harmony export */   u: () => (/* binding */ uiStoreState)
/* harmony export */ });
/* harmony import */ var _index_05956cab_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index-05956cab.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/index-05956cab.js");
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v4.0.58
 */


const uiStore = (0,_index_05956cab_js__WEBPACK_IMPORTED_MODULE_0__.c)({
    nextText: "next",
    workflow: "content",
    scale: "m",
    disableScroll: false,
    featureFlags: {}
});
const uiStoreState = uiStore.state;



//# sourceMappingURL=ui-bca7bcd1.js.map

/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid2lkZ2V0cy9jaHVua3MvYXJjZ2lzX2FuYWx5c2lzX25vZGVfbW9kdWxlc19hcmNnaXNfYXBwLWNvbXBvbmVudHNfZGlzdF9lc21fYXJjZ2lzLTczNGM2Ny5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ3VEOztBQUV2RCxxQkFBcUIscURBQVc7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWdHOztBQUVoRzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDNkc7QUFDbEQ7QUFDTjtBQUNNO0FBQzlCO0FBQ0s7O0FBRWxDLGdFQUFnRSxxQkFBcUIsT0FBTyxjQUFjLG1CQUFtQixnQkFBZ0Isa0NBQWtDLGVBQWUsa0JBQWtCLGlCQUFpQixjQUFjLGdDQUFnQyxxQkFBcUIscUJBQXFCOztBQUV6VDtBQUNBO0FBQ0EsUUFBUSxxREFBZ0I7QUFDeEIsZ0NBQWdDLHFEQUFXO0FBQzNDO0FBQ0E7QUFDQTtBQUNBLFlBQVksb0RBQVk7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxVQUFVLG9CQUFvQixNQUFNLEVBQUUsSUFBSSxFQUFFLElBQUk7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRkFBMEYsWUFBWTtBQUN0RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGdFQUFnRTtBQUNoRixnQkFB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QUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRTRCOztBQUU1Qjs7Ozs7Ozs7Ozs7Ozs7OztBQ3ZNQTtBQUNBO0FBQ0E7QUFDQTtBQUN1RDs7QUFFdkQsZ0JBQWdCLHFEQUFXO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRTJDOztBQUUzQyIsInNvdXJjZXMiOlsid2VicGFjazovL2V4Yi1jbGllbnQvLi9leHRlbnNpb25zL3dpZGdldHMvYXJjZ2lzL2FuYWx5c2lzL25vZGVfbW9kdWxlcy9AYXJjZ2lzL2FwcC1jb21wb25lbnRzL2Rpc3QvZXNtL2FkZC1pdGVtLWRiYmUyZjU3LmpzIiwid2VicGFjazovL2V4Yi1jbGllbnQvLi9leHRlbnNpb25zL3dpZGdldHMvYXJjZ2lzL2FuYWx5c2lzL25vZGVfbW9kdWxlcy9AYXJjZ2lzL2FwcC1jb21wb25lbnRzL2Rpc3QvZXNtL2FyY2dpcy1uZXctaXRlbS1wYWdlcy10aWxlLWxheWVyLWZyb20tdXJsLmVudHJ5LmpzIiwid2VicGFjazovL2V4Yi1jbGllbnQvLi9leHRlbnNpb25zL3dpZGdldHMvYXJjZ2lzL2FuYWx5c2lzL25vZGVfbW9kdWxlcy9AYXJjZ2lzL2FwcC1jb21wb25lbnRzL2Rpc3QvZXNtL2Z1bmN0aW9uYWwtNDRkZThmY2YuanMiLCJ3ZWJwYWNrOi8vZXhiLWNsaWVudC8uL2V4dGVuc2lvbnMvd2lkZ2V0cy9hcmNnaXMvYW5hbHlzaXMvbm9kZV9tb2R1bGVzL0BhcmNnaXMvYXBwLWNvbXBvbmVudHMvZGlzdC9lc20vZnVuY3Rpb25hbC04MTM3M2Y2ZC5qcyIsIndlYnBhY2s6Ly9leGItY2xpZW50Ly4vZXh0ZW5zaW9ucy93aWRnZXRzL2FyY2dpcy9hbmFseXNpcy9ub2RlX21vZHVsZXMvQGFyY2dpcy9hcHAtY29tcG9uZW50cy9kaXN0L2VzbS9pbmRleC0wNTk1NmNhYi5qcyIsIndlYnBhY2s6Ly9leGItY2xpZW50Ly4vZXh0ZW5zaW9ucy93aWRnZXRzL2FyY2dpcy9hbmFseXNpcy9ub2RlX21vZHVsZXMvQGFyY2dpcy9hcHAtY29tcG9uZW50cy9kaXN0L2VzbS91aS1iY2E3YmNkMS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIEFsbCBtYXRlcmlhbCBjb3B5cmlnaHQgRVNSSSwgQWxsIFJpZ2h0cyBSZXNlcnZlZCwgdW5sZXNzIG90aGVyd2lzZSBzcGVjaWZpZWQuXG4gKiB2NC4wLjU4XG4gKi9cbmltcG9ydCB7IGMgYXMgY3JlYXRlU3RvcmUgfSBmcm9tICcuL2luZGV4LTA1OTU2Y2FiLmpzJztcblxuY29uc3QgYWRkSXRlbVN0b3JlID0gY3JlYXRlU3RvcmUoe1xuICAgIHR5cGVLZXl3b3JkczogW10sXG4gICAgY3VzdG9tUGFyYW1ldGVyczogW10sXG4gICAgYW5hbHl6ZWRMb2NhdGlvblR5cGVzOiBbXSxcbiAgICBhbGxvd1N0b3JlZEF1dGg6IHRydWUsXG4gICAgaXNTZWN1cmVkOiBudWxsLFxuICAgIGNoZWNrQXV0aDogZmFsc2Vcbn0pO1xuLy8gRW50aXJlIGFkZCBpdGVtIHN0YXRlIG9iamVjdFxuY29uc3QgYWRkSXRlbVN0YXRlID0gYWRkSXRlbVN0b3JlLnN0YXRlO1xuLy8gU3Vic2V0cyBvZiBhZGQgaXRlbSBzdGF0ZVxuY29uc3QgYWRkSXRlbVJlcXVlc3RTdGF0ZSA9IGFkZEl0ZW1TdG9yZS5zdGF0ZTtcbmNvbnN0IGFkZEl0ZW1VcmxTdGF0ZSA9IGFkZEl0ZW1TdG9yZS5zdGF0ZTtcblxuZXhwb3J0IHsgYWRkSXRlbVN0YXRlIGFzIGEsIGFkZEl0ZW1VcmxTdGF0ZSBhcyBiLCBhZGRJdGVtUmVxdWVzdFN0YXRlIGFzIGMsIGFkZEl0ZW1TdG9yZSBhcyBkIH07XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFkZC1pdGVtLWRiYmUyZjU3LmpzLm1hcCIsIi8qIVxuICogQWxsIG1hdGVyaWFsIGNvcHlyaWdodCBFU1JJLCBBbGwgUmlnaHRzIFJlc2VydmVkLCB1bmxlc3Mgb3RoZXJ3aXNlIHNwZWNpZmllZC5cbiAqIHY0LjAuNThcbiAqL1xuaW1wb3J0IHsgciBhcyByZWdpc3Rlckluc3RhbmNlLCBjIGFzIGNyZWF0ZUV2ZW50LCBoLCBIIGFzIEhvc3QsIGQgYXMgZ2V0RWxlbWVudCB9IGZyb20gJy4vaW5kZXgtZTNiZjdkYTcuanMnO1xuaW1wb3J0IHsgYSBhcyBhZGRJdGVtU3RhdGUgfSBmcm9tICcuL2FkZC1pdGVtLWRiYmUyZjU3LmpzJztcbmltcG9ydCB7IHUgYXMgdWlTdG9yZVN0YXRlIH0gZnJvbSAnLi91aS1iY2E3YmNkMS5qcyc7XG5pbXBvcnQgeyBmIGFzIGZvcm1hdFRhZ3MgfSBmcm9tICcuL2Z1bmN0aW9uYWwtODEzNzNmNmQuanMnO1xuaW1wb3J0ICcuL2luZGV4LTA1OTU2Y2FiLmpzJztcbmltcG9ydCAnLi9mdW5jdGlvbmFsLTQ0ZGU4ZmNmLmpzJztcblxuY29uc3QgYXJjZ2lzTmV3SXRlbVBhZ2VzVGlsZUxheWVyRnJvbVVybENzcyA9IFwiLmlucHV0LWNvbnRhaW5lcnttYXJnaW4tYm90dG9tOjEuNXJlbX0ubGFiZWx7ZGlzcGxheTpibG9jaztmb250LXNpemU6MC44NzVyZW07Zm9udC13ZWlnaHQ6NTAwO2NvbG9yOnZhcigtLWNhbGNpdGUtY29sb3ItdGV4dC0xKTttYXJnaW4tdG9wOjBweDttYXJnaW4tYm90dG9tOjBweDtsaW5lLWhlaWdodDoxOHB4fWNhbGNpdGUtbGFiZWx7LS1jYWxjaXRlLWxhYmVsLW1hcmdpbi1ib3R0b206MH0uc3ViZG9tYWluLWNvbnRhaW5lcnttYXJnaW4tYm90dG9tOjEuNXJlbX1cIjtcblxuY29uc3QgQXJjZ2lzTmV3SXRlbVBhZ2VzVGlsZUxheWVyRnJvbVVybCA9IGNsYXNzIHtcbiAgICBjb25zdHJ1Y3Rvcihob3N0UmVmKSB7XG4gICAgICAgIHJlZ2lzdGVySW5zdGFuY2UodGhpcywgaG9zdFJlZik7XG4gICAgICAgIHRoaXMud29ya2Zsb3dDb21wbGV0ZSA9IGNyZWF0ZUV2ZW50KHRoaXMsIFwid29ya2Zsb3dDb21wbGV0ZVwiLCA3KTtcbiAgICAgICAgdGhpcy5zaG93U3ViZG9tYWlucyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmhhbmRsZUNoYW5nZSA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgY2hlY2tlZCA9IGV2ZW50LnRhcmdldC5jaGVja2VkO1xuICAgICAgICAgICAgYWRkSXRlbVN0YXRlLnN0b3JlQXV0aCA9IGNoZWNrZWQ7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlTG9hZGVyVXBkYXRlID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICB0aGlzLmxvYWRpbmcgPSBldmVudC5kZXRhaWw7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZ2V0UGxhY2Vob2xkZXIgPSAodHlwZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBpMThuIH0gPSB0aGlzO1xuICAgICAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcInRpdGxlXCI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpMThuLnRpdGxlUGxhY2Vob2xkZXI7XG4gICAgICAgICAgICAgICAgY2FzZSBcImF0dHJpYnV0aW9uXCI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpMThuLmF0dHJpYnV0aW9uO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJzdWJkb21haW5cIjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiaHR0cHM6Ly97c3ViRG9tYWlufS5kb21haW4uY29tLzxwYXRoPi97bGV2ZWx9L3tjb2x9L3tyb3d9LnBuZ1wiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmFzc2lnblJlZiA9IChyZWYsIHR5cGUpID0+IHtcbiAgICAgICAgICAgIGlmICh0eXBlID09PSBcInRpdGxlXCIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRpdGxlSW5wdXRSZWYgPSByZWY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmF0dHJpYnV0aW9uSW5wdXRSZWYgPSByZWY7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlS2V5ZG93biA9IChlKSA9PiB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAvLyBJZiB1c2VyIHR5cGVkIGEgY29tbWEsIHRyZWF0IGFzIGVudGVyLlxuICAgICAgICAgICAgLy8gVE9ETzogcmVtb3ZlIGFmdGVyIGNhbGNpdGUgZW5hYmxlcyBjb21tYSBzdXBwb3J0IChodHRwczovL2dpdGh1Yi5jb20vRXNyaS9jYWxjaXRlLWNvbXBvbmVudHMvaXNzdWVzLzQ2NzIpXG4gICAgICAgICAgICBpZiAoZS5rZXkgPT09IFwiLFwiKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdGFyZ2V0ID0gZS50YXJnZXQ7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5wdXQgPSAoX2EgPSB0YXJnZXQgPT09IG51bGwgfHwgdGFyZ2V0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0YXJnZXQuc2hhZG93Um9vdCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnF1ZXJ5U2VsZWN0b3IoXCJpbnB1dFwiKTtcbiAgICAgICAgICAgICAgICBpZiAoaW5wdXQgPT09IG51bGwgfHwgaW5wdXQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGlucHV0LnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXhpc3RpbmcgPSB0YXJnZXQucXVlcnlTZWxlY3RvcihgY2FsY2l0ZS1jb21ib2JveC1pdGVtW3ZhbHVlPVwiJHtpbnB1dC52YWx1ZX1cIl1gKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV4aXN0aW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBleGlzdGluZy5zZWxlY3RlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpdGVtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbGNpdGUtY29tYm9ib3gtaXRlbVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0udmFsdWUgPSBpbnB1dC52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0udGV4dExhYmVsID0gaW5wdXQudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtLnNlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldCA9PT0gbnVsbCB8fCB0YXJnZXQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHRhcmdldC5hcHBlbmRDaGlsZChpdGVtKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpbnB1dC52YWx1ZSA9IFwiXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmkxOG4gPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuZXJyb3JNZXNzYWdlID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmxvYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy50aXRsZSA9IFwiXCI7XG4gICAgICAgIHRoaXMuYXR0cmlidXRpb24gPSBudWxsO1xuICAgICAgICB0aGlzLnN1YmRvbWFpbnMgPSBbXTtcbiAgICAgICAgdGhpcy51c2VDdXJyZW50RXh0ZW50ID0gZmFsc2U7XG4gICAgfVxuICAgIGFzeW5jIGhhbmRsZU5leHQoKSB7XG4gICAgICAgIGNvbnN0IHsgaTE4biwgdGl0bGUsIGF0dHJpYnV0aW9uLCBzdWJkb21haW5zID0gbnVsbCwgdXNlQ3VycmVudEV4dGVudCB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgeyB1cmwsIGN1c3RvbVBhcmFtZXRlcnMsIGFkZEFzQmFzZW1hcCB9ID0gYWRkSXRlbVN0YXRlO1xuICAgICAgICB0aGlzLmVycm9yTWVzc2FnZSA9IG51bGw7XG4gICAgICAgIGlmICghdGl0bGUpIHtcbiAgICAgICAgICAgIHRoaXMuZXJyb3JNZXNzYWdlID0gaTE4bi5lcnJvci50aXRsZTtcbiAgICAgICAgICAgIHRoaXMudGl0bGVJbnB1dFJlZi5zZXRGb2N1cygpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghYXR0cmlidXRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuZXJyb3JNZXNzYWdlID0gaTE4bi5lcnJvci5hdHRyaWJ1dGlvbjtcbiAgICAgICAgICAgIHRoaXMuYXR0cmlidXRpb25JbnB1dFJlZi5zZXRGb2N1cygpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubG9hZGluZyA9IHRydWU7XG4gICAgICAgIGlmICh0aGlzLmlzQWRkVG9NYXBUZXJtaW5hbFBhZ2UoKSkge1xuICAgICAgICAgICAgdGhpcy53b3JrZmxvd0NvbXBsZXRlLmVtaXQoe1xuICAgICAgICAgICAgICAgIHRpdGxlLFxuICAgICAgICAgICAgICAgIGF0dHJpYnV0aW9uLFxuICAgICAgICAgICAgICAgIHN1YmRvbWFpbjogc3ViZG9tYWlucy5qb2luKFwiLFwiKSxcbiAgICAgICAgICAgICAgICB1c2VDdXJyZW50RXh0ZW50LFxuICAgICAgICAgICAgICAgIHVybCxcbiAgICAgICAgICAgICAgICBjdXN0b21QYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHR5cGU6IFwiVGlsZSBMYXllclwiLFxuICAgICAgICAgICAgICAgIGFkZEFzQmFzZW1hcFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgY29tcG9uZW50V2lsbExvYWQoKSB7XG4gICAgICAgIGNvbnN0IGkxOG4gPSB1aVN0b3JlU3RhdGUuaTE4bjtcbiAgICAgICAgdGhpcy5pMThuID0gaTE4bi50aWxlTGF5ZXJGcm9tVXJsO1xuICAgICAgICBpZiAodGhpcy5pc0FkZFRvTWFwVGVybWluYWxQYWdlKCkpIHtcbiAgICAgICAgICAgIHVpU3RvcmVTdGF0ZS5uZXh0VGV4dCA9IFwiYWRkVG9NYXBcIjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNob3dTdWJkb21haW5zID0gYWRkSXRlbVN0YXRlLnVybC50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKFwie3N1YmRvbWFpbn1cIik7XG4gICAgICAgIC8vIFRPRE86IGFzc2lnbiBzdGF0ZSBmcm9tIHN0b3JlIG9uY2UgdGhpcyBpcyBub3QgYSB0ZXJtaW5hbCBwYWdlXG4gICAgfVxuICAgIGlzQWRkVG9NYXBUZXJtaW5hbFBhZ2UoKSB7XG4gICAgICAgIC8vICEgTm90ZTogdGhpcyBwYWdlIG9ubHkgc3VwcG9ydHMgZGlyZWN0IG1vZGUgZm9yIG5vd1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICBjb25zdCB7IGxvYWRpbmcsIGVycm9yTWVzc2FnZSwgaTE4biwgZ2V0UGxhY2Vob2xkZXIsIGFzc2lnblJlZiwgaGFuZGxlS2V5ZG93biwgc2hvd1N1YmRvbWFpbnMgfSA9IHRoaXM7XG4gICAgICAgIHJldHVybiAoaChIb3N0LCBudWxsLCBoKFwiYXJjZ2lzLW5ldy1pdGVtLWxvYWRlclwiLCB7IGFjdGl2ZTogbG9hZGluZyB9KSwgaChcImFyY2dpcy1uZXctaXRlbS1hbGVydFwiLCB7IGFjdGl2ZTogISFlcnJvck1lc3NhZ2UsIGRlc2NyaXB0aW9uOiBlcnJvck1lc3NhZ2UsIG9uQWxlcnREaXNtaXNzOiAoKSA9PiAodGhpcy5lcnJvck1lc3NhZ2UgPSBcIlwiKSB9KSwgW1widGl0bGVcIiwgXCJhdHRyaWJ1dGlvblwiXS5tYXAoKHR5cGUpID0+IChoKFwiY2FsY2l0ZS1sYWJlbFwiLCBudWxsLCBoKFwicFwiLCB7IGNsYXNzOiBcImxhYmVsXCIgfSwgaTE4blt0eXBlXSksIGgoXCJjYWxjaXRlLWlucHV0XCIsIHsgY2xhc3M6IFwiaW5wdXQtY29udGFpbmVyXCIsIHBsYWNlaG9sZGVyOiBnZXRQbGFjZWhvbGRlcih0eXBlKSwgcmVmOiAocmVmKSA9PiBhc3NpZ25SZWYocmVmLCB0eXBlKSwgdmFsdWU6IHRoaXNbdHlwZV0sIHJlcXVpcmVkOiB0cnVlLCBvbkNhbGNpdGVJbnB1dElucHV0OiAoZSkgPT4gKHRoaXNbdHlwZV0gPSBlLnRhcmdldC52YWx1ZSkgfSkpKSksIHNob3dTdWJkb21haW5zICYmIChoKFwiZGl2XCIsIHsgY2xhc3M6IFwic3ViZG9tYWluLWNvbnRhaW5lclwiIH0sIGgoXCJjYWxjaXRlLWxhYmVsXCIsIG51bGwsIGgoXCJwXCIsIHsgY2xhc3M6IFwibGFiZWxcIiB9LCBpMThuLnN1YmRvbWFpbiksIGgoXCJjYWxjaXRlLWNvbWJvYm94XCIsIHsgbGFiZWw6IGkxOG4uc3ViZG9tYWluLCBhbGxvd0N1c3RvbVZhbHVlczogdHJ1ZSwgcGxhY2Vob2xkZXI6IGkxOG4uc3ViRG9tYWluUGxhY2Vob2xkZXIsIG9uS2V5RG93bjogaGFuZGxlS2V5ZG93biwgb25DYWxjaXRlQ29tYm9ib3hDaGFuZ2U6IChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG5vZGUgPSBldmVudC50YXJnZXQ7XG4gICAgICAgICAgICAgICAgdGhpcy5zdWJkb21haW5zID0gZm9ybWF0VGFncyhub2RlLnNlbGVjdGVkSXRlbXMubWFwKChpdGVtKSA9PiBpdGVtLnZhbHVlKSk7XG4gICAgICAgICAgICB9IH0pKSkpLCBoKFwiYXJjZ2lzLW5ldy1pdGVtLXN3aXRjaC1jYXJkXCIsIHsgaGVhZGVyOiBpMThuLnNldFRpbGVFeHRlbnQsIG9uU3dpdGNoQ2hhbmdlOiAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnVzZUN1cnJlbnRFeHRlbnQgPSBldmVudC5kZXRhaWw7XG4gICAgICAgICAgICB9IH0pKSk7XG4gICAgfVxuICAgIGdldCBlbGVtZW50KCkgeyByZXR1cm4gZ2V0RWxlbWVudCh0aGlzKTsgfVxufTtcbkFyY2dpc05ld0l0ZW1QYWdlc1RpbGVMYXllckZyb21Vcmwuc3R5bGUgPSBhcmNnaXNOZXdJdGVtUGFnZXNUaWxlTGF5ZXJGcm9tVXJsQ3NzO1xuXG5leHBvcnQgeyBBcmNnaXNOZXdJdGVtUGFnZXNUaWxlTGF5ZXJGcm9tVXJsIGFzIGFyY2dpc19uZXdfaXRlbV9wYWdlc190aWxlX2xheWVyX2Zyb21fdXJsIH07XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFyY2dpcy1uZXctaXRlbS1wYWdlcy10aWxlLWxheWVyLWZyb20tdXJsLmVudHJ5LmpzLm1hcCIsIi8qIVxuICogQWxsIG1hdGVyaWFsIGNvcHlyaWdodCBFU1JJLCBBbGwgUmlnaHRzIFJlc2VydmVkLCB1bmxlc3Mgb3RoZXJ3aXNlIHNwZWNpZmllZC5cbiAqIHY0LjAuNThcbiAqL1xuLyoqXG4gKiBDYWxsIGEgZnVuY3Rpb24gb25seSBhZnRlciBpdCBoYXMgbm90IGJlZW4gY2FsbGVkIGZvciBuIG1pbGxpc2Vjb25kc1xuICogQHBhcmFtIGZuICAgIC0gZnVuY3Rpb24gdG8gY2FsbFxuICogQHBhcmFtIGRlbGF5IC0gZGVsYXkgaW4gbWlsbGlzZWNvbmRzXG4gKi9cbmNvbnN0IGRlYm91bmNlID0gKGZuLCBkZWxheSkgPT4ge1xuICAgIGxldCB0aW1lb3V0O1xuICAgIGxldCBzdGF0dXMgPSBcImlkbGVcIjtcbiAgICBmdW5jdGlvbiBmbHVzaCguLi5hcmdzKSB7XG4gICAgICAgIHN0YXR1cyA9IFwiZmx1c2hlZFwiO1xuICAgICAgICByZXR1cm4gZGVib3VuY2VkKC4uLmFyZ3MpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpbnZva2UoLi4uYXJncykge1xuICAgICAgICBzdGF0dXMgPSBcImludm9rZWRcIjtcbiAgICAgICAgcmV0dXJuIGRlYm91bmNlZCguLi5hcmdzKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2FuY2VsKC4uLmFyZ3MpIHtcbiAgICAgICAgc3RhdHVzID0gXCJjYW5jZWxsZWRcIjtcbiAgICAgICAgcmV0dXJuIGRlYm91bmNlZCguLi5hcmdzKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0U3RhdHVzKCkge1xuICAgICAgICByZXR1cm4gc3RhdHVzO1xuICAgIH1cbiAgICBjb25zdCBkZWJvdW5jZWQgPSAoLi4uYXJncykgPT4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgc3dpdGNoIChzdGF0dXMpIHtcbiAgICAgICAgICAgIGNhc2UgXCJmbHVzaGVkXCI6XG4gICAgICAgICAgICAgICAgc3RhdHVzID0gXCJpZGxlXCI7XG4gICAgICAgICAgICAgICAgaWYgKHRpbWVvdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGZuKC4uLmFyZ3MpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUobnVsbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImludm9rZWRcIjpcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgICAgICAgICAgc3RhdHVzID0gXCJpZGxlXCI7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShmbiguLi5hcmdzKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiY2FuY2VsbGVkXCI6XG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICAgICAgICAgIHN0YXR1cyA9IFwiaWRsZVwiO1xuICAgICAgICAgICAgICAgIHJlc29sdmUobnVsbCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGlmICh0aW1lb3V0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3RhdHVzID0gXCJwZW5kaW5nXCI7XG4gICAgICAgICAgICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMgPSBcImlkbGVcIjtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUoZm4oLi4uYXJncykpO1xuICAgICAgICAgICAgICAgIH0sIGRlbGF5KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGRlYm91bmNlZC5mbHVzaCA9IGZsdXNoO1xuICAgIGRlYm91bmNlZC5pbnZva2UgPSBpbnZva2U7XG4gICAgZGVib3VuY2VkLmNhbmNlbCA9IGNhbmNlbDtcbiAgICBkZWJvdW5jZWQuZ2V0U3RhdHVzID0gZ2V0U3RhdHVzO1xuICAgIHJldHVybiBkZWJvdW5jZWQ7XG59O1xuLyoqXG4gKiBDYWxsIGEgZnVuY3Rpb24gb25seSBhZnRlciBuIG1pbGxpc2Vjb25kcyBoYXZlIGVsYXBzZWRcbiAqIEBwYXJhbSBmbiAgICAtIGZ1bmN0aW9uIHRvIGNhbGxcbiAqIEBwYXJhbSBkZWxheSAtIGRlbGF5IGluIG1pbGxpc2Vjb25kc1xuICovXG5jb25zdCB0aHJvdHRsZSA9IChmbiwgZGVsYXkpID0+IHtcbiAgICBsZXQgdGltZW91dDtcbiAgICByZXR1cm4gKC4uLmFyZ3MpID0+IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgIGlmICh0aW1lb3V0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICAgICAgdGltZW91dCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHJlc29sdmUoZm4oLi4uYXJncykpO1xuICAgICAgICB9LCBkZWxheSk7XG4gICAgfSk7XG59O1xuZnVuY3Rpb24gZXNjYXBlUmVnRXhwKHN0cikge1xuICAgIHJldHVybiBzdHIucmVwbGFjZSgvWy4qKz9eJHt9KCl8W1xcXVxcXFxdL2csIFwiXFxcXCQmXCIpOyAvLyAkJiBtZWFucyB0aGUgd2hvbGUgbWF0Y2hlZCBzdHJpbmdcbn1cbmZ1bmN0aW9uIGlzRGVmaW5lZCh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsO1xufVxuLyoqXG4gKiBTZXQgYSBtaW5pbXVtIHRpbWUgZm9yIGEgcHJvbWlzZSB0byByZXNvbHZlICh1c2VmdWwgZm9yIHByZXZlbnRpbmcgZmxhc2ggb2YgbG9hZGVycylcbiAqL1xuYXN5bmMgZnVuY3Rpb24gbWluRGVsYXkocHJvbWlzZSwgbWluRGVsYXkpIHtcbiAgICBhd2FpdCBQcm9taXNlLmFsbChbcHJvbWlzZSwgdGltZW91dChtaW5EZWxheSldKTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbn1cbi8qKlxuICogSGVscGVyIG1ldGhvZCB0byBpbmxpbmUgc2V0VGltZW91dCBhcyBhbiBhd2FpdCBpbiBhc3luYyBmdW5jdGlvbnNcbiAqL1xuZnVuY3Rpb24gdGltZW91dChtcykge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlLCBtcykpO1xufVxuY29uc3QgYXJyYXlUb0xvb2t1cE1hcCA9IChkYXRhQXJyLCBnZXRLZXlBbmRJdGVtKSA9PiBPYmplY3QuZnJvbUVudHJpZXMoKGRhdGFBcnIgfHwgW10pLm1hcCgoaXRlbSkgPT4ge1xuICAgIGNvbnN0IHsga2V5LCBkYXRhIH0gPSBnZXRLZXlBbmRJdGVtKGl0ZW0pO1xuICAgIHJldHVybiBba2V5LCBkYXRhXTtcbn0pKTtcbi8qKlxuICogQ2hlY2sgd2hldGhlciB0d28gYXJyYXlzIGhhdmUgdGhlIHNhbWUgbnVtYmVyIG9mIGVsZW1lbnRzXG4gKiBhbmQgd2hldGhlciB0aGV5IGNvbnRhaW4gdGhlIHNhbWUgZWxlbWVudHNcbiAqIHJlZ2FyZGxlc3Mgb2Ygb3JkZXJcbiAqL1xuY29uc3QgYXJyYXlzQXJlRXF1aXZhbGVudCA9IChhcnIxLCBhcnIyKSA9PiBhcnIxLmxlbmd0aCA9PT0gYXJyMi5sZW5ndGggJiYgYXJyMS5yZWR1Y2UoKG1lbW8sIHN0cikgPT4gbWVtbyAmJiBhcnIyLmluZGV4T2Yoc3RyKSA+IC0xLCB0cnVlKTtcbmZ1bmN0aW9uIHVuaXF1ZUJ5KG15QXJyLCBnZXRJdGVtSWQpIHtcbiAgICBjb25zdCByZXN1bHRBcnIgPSBbXTtcbiAgICBjb25zdCBsb29rdXBNYXAgPSB7fTtcbiAgICBteUFyci5mb3JFYWNoKChpdGVtKSA9PiB7XG4gICAgICAgIGNvbnN0IGlkID0gZ2V0SXRlbUlkKGl0ZW0pO1xuICAgICAgICBpZiAobG9va3VwTWFwW2lkXSA9PSBudWxsKSB7XG4gICAgICAgICAgICBsb29rdXBNYXBbaWRdID0gaXRlbTtcbiAgICAgICAgICAgIHJlc3VsdEFyci5wdXNoKGl0ZW0pO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdEFycjtcbn1cbmZ1bmN0aW9uIHVuaXF1ZShteUFycikge1xuICAgIGNvbnN0IHByaW1pdGl2ZXMgPSB7IGJvb2xlYW46IHt9LCBudW1iZXI6IHt9LCBzdHJpbmc6IHt9IH07XG4gICAgY29uc3Qgb2JqcyA9IFtdO1xuICAgIHJldHVybiBteUFyci5maWx0ZXIoKGl0ZW0pID0+IHtcbiAgICAgICAgbGV0IHR5cGUgPSB0eXBlb2YgaXRlbTtcbiAgICAgICAgaWYgKHR5cGUgaW4gcHJpbWl0aXZlcykge1xuICAgICAgICAgICAgcmV0dXJuIHByaW1pdGl2ZXNbdHlwZV0uaGFzT3duUHJvcGVydHkoaXRlbSkgPyBmYWxzZSA6IChwcmltaXRpdmVzW3R5cGVdW2l0ZW1dID0gdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gb2Jqcy5pbmRleE9mKGl0ZW0pID49IDAgPyBmYWxzZSA6IG9ianMucHVzaChpdGVtKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuY29uc3QgY2h1bmsgPSAoYXJyLCBzaXplKSA9PiBbLi4uQXJyYXkoTWF0aC5jZWlsKGFyci5sZW5ndGggLyBzaXplKSldLm1hcCgoXywgaSkgPT4gYXJyLnNsaWNlKHNpemUgKiBpLCBzaXplICsgc2l6ZSAqIGkpKTtcblxuZXhwb3J0IHsgYXJyYXlUb0xvb2t1cE1hcCBhcyBhLCB1bmlxdWUgYXMgYiwgdGhyb3R0bGUgYXMgYywgZGVib3VuY2UgYXMgZCwgZXNjYXBlUmVnRXhwIGFzIGUsIGFycmF5c0FyZUVxdWl2YWxlbnQgYXMgZiwgY2h1bmsgYXMgZywgaXNEZWZpbmVkIGFzIGksIG1pbkRlbGF5IGFzIG0sIHRpbWVvdXQgYXMgdCwgdW5pcXVlQnkgYXMgdSB9O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1mdW5jdGlvbmFsLTQ0ZGU4ZmNmLmpzLm1hcCIsIi8qIVxuICogQWxsIG1hdGVyaWFsIGNvcHlyaWdodCBFU1JJLCBBbGwgUmlnaHRzIFJlc2VydmVkLCB1bmxlc3Mgb3RoZXJ3aXNlIHNwZWNpZmllZC5cbiAqIHY0LjAuNThcbiAqL1xuaW1wb3J0IHsgYiBhcyB1bmlxdWUgfSBmcm9tICcuL2Z1bmN0aW9uYWwtNDRkZThmY2YuanMnO1xuXG5jb25zdCBmb3JtYXRGaWxlTmFtZSA9ICh0aXRsZSkgPT4gKHRpdGxlID09PSBudWxsIHx8IHRpdGxlID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0aXRsZS5yZXBsYWNlKC8oXFxzK3w6KS9nLCBcIl9cIikpIHx8IFwiXCI7XG5jb25zdCBmb3JtYXRUYWdzID0gKHRhZ3MpID0+IHtcbiAgICBjb25zdCBjbGVhblRhZ3MgPSAodGFnT2JqKSA9PiB7XG4gICAgICAgIHJldHVybiB0YWdPYmpcbiAgICAgICAgICAgIC5zcGxpdChcIixcIilcbiAgICAgICAgICAgIC5tYXAoKHRhZykgPT4gdGFnLnRyaW0oKSlcbiAgICAgICAgICAgIC5maWx0ZXIoKHRhZykgPT4gdGFnKTtcbiAgICB9O1xuICAgIGlmICghdGFncykge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiB0YWdzID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHJldHVybiB1bmlxdWUoY2xlYW5UYWdzKHRhZ3MpKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiB1bmlxdWUodGFncy5mbGF0TWFwKCh0YWcpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBbLi4uY2xlYW5UYWdzKHRhZyldO1xuICAgICAgICB9KSk7XG4gICAgfVxufTtcbmNvbnN0IHJlc29sdmVPbkZpcnN0UHJvbWlzZSA9IGFzeW5jIChwcm9taXNlTGlzdCkgPT4ge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJvbWlzZUxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHByb21pc2VMaXN0W2ldXG4gICAgICAgICAgICAgICAgLnRoZW4oKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5ld0FyciA9IFsuLi5wcm9taXNlTGlzdF07XG4gICAgICAgICAgICAgICAgbmV3QXJyLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICByZXNvbHZlKHsgcmVtYWluaW5nUHJvbWlzZXM6IG5ld0FyciwgcmVzdWx0IH0pO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuY2F0Y2gocmVqZWN0KTtcbiAgICAgICAgfVxuICAgIH0pO1xufTtcbi8qKlxuICogU2ltaWxhciB0byBQcm9taXNlLmFsbCBidXQgd2lsbCByZXNvbHZlIG9uIHRoZSBmaXJzdCBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdGhlbiBjb250aW51b3VzbHkgc3dhcCBvdXQgdGhlIHJlc29sdmVkIHByb21pc2Ugd2l0aCB0aGUgbmV4dCBwcm9taXNlIGluIHRoZSBsaXN0XG4gKiBAcGFyYW0gZ2V0TmV4dFByb21pc2UgQSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIG5leHQgcHJvbWlzZSB0byByZXNvbHZlXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHN0cmVhbVByb21pc2VzKGdldE5leHRQcm9taXNlLCBvcHRpb25zKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICBjb25zdCByZXN1bHRzID0gW107XG4gICAgY29uc3QgeyBnZXRCYXRjaFNpemUsIG9uUHJvbWlzZUNvbXBsZXRlZCwgb25Qcm9taXNlVGhyb3csIHNob3VsZENvbnRpbnVlIH0gPSBvcHRpb25zICE9PSBudWxsICYmIG9wdGlvbnMgIT09IHZvaWQgMCA/IG9wdGlvbnMgOiB7fTtcbiAgICBsZXQgcmVtYWluaW5nUHJvbWlzZXMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8ICgoX2EgPSBnZXRCYXRjaFNpemUgPT09IG51bGwgfHwgZ2V0QmF0Y2hTaXplID09PSB2b2lkIDAgPyB2b2lkIDAgOiBnZXRCYXRjaFNpemUoKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMSk7IGkrKykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgbmV4dEVsZW1lbnQgPSBnZXROZXh0UHJvbWlzZSgpO1xuICAgICAgICAgICAgbmV4dEVsZW1lbnQgJiYgcmVtYWluaW5nUHJvbWlzZXMucHVzaChuZXh0RWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIG9uUHJvbWlzZVRocm93ID09PSBudWxsIHx8IG9uUHJvbWlzZVRocm93ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvblByb21pc2VUaHJvdyhlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBsZXQgbGFzdFJlc3VsdCA9IG51bGw7XG4gICAgd2hpbGUgKHJlbWFpbmluZ1Byb21pc2VzLmxlbmd0aCA+IDAgJiYgKCFzaG91bGRDb250aW51ZSB8fCBzaG91bGRDb250aW51ZShsYXN0UmVzdWx0KSkpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHsgcmVtYWluaW5nUHJvbWlzZXM6IF9yZW1haW5pbmdQcm9taXNlcywgcmVzdWx0IH0gPSBhd2FpdCByZXNvbHZlT25GaXJzdFByb21pc2UocmVtYWluaW5nUHJvbWlzZXMpO1xuICAgICAgICAgICAgcmVtYWluaW5nUHJvbWlzZXMgPSBfcmVtYWluaW5nUHJvbWlzZXM7XG4gICAgICAgICAgICBsYXN0UmVzdWx0ID0gcmVzdWx0O1xuICAgICAgICAgICAgISFyZXN1bHQgJiYgcmVzdWx0cy5wdXNoKHJlc3VsdCk7XG4gICAgICAgICAgICBvblByb21pc2VDb21wbGV0ZWQgPT09IG51bGwgfHwgb25Qcm9taXNlQ29tcGxldGVkID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvblByb21pc2VDb21wbGV0ZWQocmVzdWx0KTtcbiAgICAgICAgICAgIC8vIFVwZGF0ZSBiYXRjaCBzaXplIGFmdGVyIHRoZSBuZXcgcmVzdWx0IGlzIGJ1YmJsZWQgdXBcbiAgICAgICAgICAgIGNvbnN0IGJhdGNoU2l6ZSA9IChfYiA9IGdldEJhdGNoU2l6ZSA9PT0gbnVsbCB8fCBnZXRCYXRjaFNpemUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGdldEJhdGNoU2l6ZSgpKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAxO1xuICAgICAgICAgICAgd2hpbGUgKHJlbWFpbmluZ1Byb21pc2VzLmxlbmd0aCA8IGJhdGNoU2l6ZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5leHRFbGVtZW50ID0gZ2V0TmV4dFByb21pc2UoKTtcbiAgICAgICAgICAgICAgICBuZXh0RWxlbWVudCAmJiByZW1haW5pbmdQcm9taXNlcy5wdXNoKG5leHRFbGVtZW50KTtcbiAgICAgICAgICAgICAgICBpZiAobmV4dEVsZW1lbnQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIG9uUHJvbWlzZVRocm93ID09PSBudWxsIHx8IG9uUHJvbWlzZVRocm93ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvblByb21pc2VUaHJvdyhlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0cztcbn1cblxuZXhwb3J0IHsgZm9ybWF0RmlsZU5hbWUgYXMgYSwgZm9ybWF0VGFncyBhcyBmLCBzdHJlYW1Qcm9taXNlcyBhcyBzIH07XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZ1bmN0aW9uYWwtODEzNzNmNmQuanMubWFwIiwiLyohXG4gKiBBbGwgbWF0ZXJpYWwgY29weXJpZ2h0IEVTUkksIEFsbCBSaWdodHMgUmVzZXJ2ZWQsIHVubGVzcyBvdGhlcndpc2Ugc3BlY2lmaWVkLlxuICogdjQuMC41OFxuICovXG5pbXBvcnQgeyBnIGFzIGdldFJlbmRlcmluZ1JlZiwgZiBhcyBmb3JjZVVwZGF0ZSB9IGZyb20gJy4vaW5kZXgtZTNiZjdkYTcuanMnO1xuXG5jb25zdCBhcHBlbmRUb01hcCA9IChtYXAsIHByb3BOYW1lLCB2YWx1ZSkgPT4ge1xuICAgIGNvbnN0IGl0ZW1zID0gbWFwLmdldChwcm9wTmFtZSk7XG4gICAgaWYgKCFpdGVtcykge1xuICAgICAgICBtYXAuc2V0KHByb3BOYW1lLCBbdmFsdWVdKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoIWl0ZW1zLmluY2x1ZGVzKHZhbHVlKSkge1xuICAgICAgICBpdGVtcy5wdXNoKHZhbHVlKTtcbiAgICB9XG59O1xuY29uc3QgZGVib3VuY2UgPSAoZm4sIG1zKSA9PiB7XG4gICAgbGV0IHRpbWVvdXRJZDtcbiAgICByZXR1cm4gKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgaWYgKHRpbWVvdXRJZCkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgICAgIH1cbiAgICAgICAgdGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICB0aW1lb3V0SWQgPSAwO1xuICAgICAgICAgICAgZm4oLi4uYXJncyk7XG4gICAgICAgIH0sIG1zKTtcbiAgICB9O1xufTtcblxuLyoqXG4gKiBDaGVjayBpZiBhIHBvc3NpYmxlIGVsZW1lbnQgaXNDb25uZWN0ZWQuXG4gKiBUaGUgcHJvcGVydHkgbWlnaHQgbm90IGJlIHRoZXJlLCBzbyB3ZSBjaGVjayBmb3IgaXQuXG4gKlxuICogV2Ugd2FudCBpdCB0byByZXR1cm4gdHJ1ZSBpZiBpc0Nvbm5lY3RlZCBpcyBub3QgYSBwcm9wZXJ0eSxcbiAqIG90aGVyd2lzZSB3ZSB3b3VsZCByZW1vdmUgdGhlc2UgZWxlbWVudHMgYW5kIHdvdWxkIG5vdCB1cGRhdGUuXG4gKlxuICogQmV0dGVyIGxlYWsgaW4gRWRnZSB0aGFuIHRvIGJlIHVzZWxlc3MuXG4gKi9cbmNvbnN0IGlzQ29ubmVjdGVkID0gKG1heWJlRWxlbWVudCkgPT4gISgnaXNDb25uZWN0ZWQnIGluIG1heWJlRWxlbWVudCkgfHwgbWF5YmVFbGVtZW50LmlzQ29ubmVjdGVkO1xuY29uc3QgY2xlYW51cEVsZW1lbnRzID0gZGVib3VuY2UoKG1hcCkgPT4ge1xuICAgIGZvciAobGV0IGtleSBvZiBtYXAua2V5cygpKSB7XG4gICAgICAgIG1hcC5zZXQoa2V5LCBtYXAuZ2V0KGtleSkuZmlsdGVyKGlzQ29ubmVjdGVkKSk7XG4gICAgfVxufSwgMjAwMCk7XG5jb25zdCBzdGVuY2lsU3Vic2NyaXB0aW9uID0gKCkgPT4ge1xuICAgIGlmICh0eXBlb2YgZ2V0UmVuZGVyaW5nUmVmICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIElmIHdlIGFyZSBub3QgaW4gYSBzdGVuY2lsIHByb2plY3QsIHdlIGRvIG5vdGhpbmcuXG4gICAgICAgIC8vIFRoaXMgZnVuY3Rpb24gaXMgbm90IHJlYWxseSBleHBvcnRlZCBieSBAc3RlbmNpbC9jb3JlLlxuICAgICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIGNvbnN0IGVsbXNUb1VwZGF0ZSA9IG5ldyBNYXAoKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBkaXNwb3NlOiAoKSA9PiBlbG1zVG9VcGRhdGUuY2xlYXIoKSxcbiAgICAgICAgZ2V0OiAocHJvcE5hbWUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGVsbSA9IGdldFJlbmRlcmluZ1JlZigpO1xuICAgICAgICAgICAgaWYgKGVsbSkge1xuICAgICAgICAgICAgICAgIGFwcGVuZFRvTWFwKGVsbXNUb1VwZGF0ZSwgcHJvcE5hbWUsIGVsbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogKHByb3BOYW1lKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBlbGVtZW50cyA9IGVsbXNUb1VwZGF0ZS5nZXQocHJvcE5hbWUpO1xuICAgICAgICAgICAgaWYgKGVsZW1lbnRzKSB7XG4gICAgICAgICAgICAgICAgZWxtc1RvVXBkYXRlLnNldChwcm9wTmFtZSwgZWxlbWVudHMuZmlsdGVyKGZvcmNlVXBkYXRlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjbGVhbnVwRWxlbWVudHMoZWxtc1RvVXBkYXRlKTtcbiAgICAgICAgfSxcbiAgICAgICAgcmVzZXQ6ICgpID0+IHtcbiAgICAgICAgICAgIGVsbXNUb1VwZGF0ZS5mb3JFYWNoKChlbG1zKSA9PiBlbG1zLmZvckVhY2goZm9yY2VVcGRhdGUpKTtcbiAgICAgICAgICAgIGNsZWFudXBFbGVtZW50cyhlbG1zVG9VcGRhdGUpO1xuICAgICAgICB9LFxuICAgIH07XG59O1xuXG5jb25zdCB1bndyYXAgPSAodmFsKSA9PiAodHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJyA/IHZhbCgpIDogdmFsKTtcbmNvbnN0IGNyZWF0ZU9ic2VydmFibGVNYXAgPSAoZGVmYXVsdFN0YXRlLCBzaG91bGRVcGRhdGUgPSAoYSwgYikgPT4gYSAhPT0gYikgPT4ge1xuICAgIGNvbnN0IHVud3JhcHBlZFN0YXRlID0gdW53cmFwKGRlZmF1bHRTdGF0ZSk7XG4gICAgbGV0IHN0YXRlcyA9IG5ldyBNYXAoT2JqZWN0LmVudHJpZXModW53cmFwcGVkU3RhdGUgIT09IG51bGwgJiYgdW53cmFwcGVkU3RhdGUgIT09IHZvaWQgMCA/IHVud3JhcHBlZFN0YXRlIDoge30pKTtcbiAgICBjb25zdCBoYW5kbGVycyA9IHtcbiAgICAgICAgZGlzcG9zZTogW10sXG4gICAgICAgIGdldDogW10sXG4gICAgICAgIHNldDogW10sXG4gICAgICAgIHJlc2V0OiBbXSxcbiAgICB9O1xuICAgIGNvbnN0IHJlc2V0ID0gKCkgPT4ge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIC8vIFdoZW4gcmVzZXR0aW5nIHRoZSBzdGF0ZSwgdGhlIGRlZmF1bHQgc3RhdGUgbWF5IGJlIGEgZnVuY3Rpb24gLSB1bndyYXAgaXQgdG8gaW52b2tlIGl0LlxuICAgICAgICAvLyBvdGhlcndpc2UsIHRoZSBzdGF0ZSB3b24ndCBiZSBwcm9wZXJseSByZXNldFxuICAgICAgICBzdGF0ZXMgPSBuZXcgTWFwKE9iamVjdC5lbnRyaWVzKChfYSA9IHVud3JhcChkZWZhdWx0U3RhdGUpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB7fSkpO1xuICAgICAgICBoYW5kbGVycy5yZXNldC5mb3JFYWNoKChjYikgPT4gY2IoKSk7XG4gICAgfTtcbiAgICBjb25zdCBkaXNwb3NlID0gKCkgPT4ge1xuICAgICAgICAvLyBDYWxsIGZpcnN0IGRpc3Bvc2UgYXMgcmVzZXR0aW5nIHRoZSBzdGF0ZSB3b3VsZFxuICAgICAgICAvLyBjYXVzZSBsZXNzIHVwZGF0ZXMgOylcbiAgICAgICAgaGFuZGxlcnMuZGlzcG9zZS5mb3JFYWNoKChjYikgPT4gY2IoKSk7XG4gICAgICAgIHJlc2V0KCk7XG4gICAgfTtcbiAgICBjb25zdCBnZXQgPSAocHJvcE5hbWUpID0+IHtcbiAgICAgICAgaGFuZGxlcnMuZ2V0LmZvckVhY2goKGNiKSA9PiBjYihwcm9wTmFtZSkpO1xuICAgICAgICByZXR1cm4gc3RhdGVzLmdldChwcm9wTmFtZSk7XG4gICAgfTtcbiAgICBjb25zdCBzZXQgPSAocHJvcE5hbWUsIHZhbHVlKSA9PiB7XG4gICAgICAgIGNvbnN0IG9sZFZhbHVlID0gc3RhdGVzLmdldChwcm9wTmFtZSk7XG4gICAgICAgIGlmIChzaG91bGRVcGRhdGUodmFsdWUsIG9sZFZhbHVlLCBwcm9wTmFtZSkpIHtcbiAgICAgICAgICAgIHN0YXRlcy5zZXQocHJvcE5hbWUsIHZhbHVlKTtcbiAgICAgICAgICAgIGhhbmRsZXJzLnNldC5mb3JFYWNoKChjYikgPT4gY2IocHJvcE5hbWUsIHZhbHVlLCBvbGRWYWx1ZSkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBzdGF0ZSA9ICh0eXBlb2YgUHJveHkgPT09ICd1bmRlZmluZWQnXG4gICAgICAgID8ge31cbiAgICAgICAgOiBuZXcgUHJveHkodW53cmFwcGVkU3RhdGUsIHtcbiAgICAgICAgICAgIGdldChfLCBwcm9wTmFtZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBnZXQocHJvcE5hbWUpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG93bktleXMoXykge1xuICAgICAgICAgICAgICAgIHJldHVybiBBcnJheS5mcm9tKHN0YXRlcy5rZXlzKCkpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldE93blByb3BlcnR5RGVzY3JpcHRvcigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBoYXMoXywgcHJvcE5hbWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RhdGVzLmhhcyhwcm9wTmFtZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2V0KF8sIHByb3BOYW1lLCB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHNldChwcm9wTmFtZSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSkpO1xuICAgIGNvbnN0IG9uID0gKGV2ZW50TmFtZSwgY2FsbGJhY2spID0+IHtcbiAgICAgICAgaGFuZGxlcnNbZXZlbnROYW1lXS5wdXNoKGNhbGxiYWNrKTtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIHJlbW92ZUZyb21BcnJheShoYW5kbGVyc1tldmVudE5hbWVdLCBjYWxsYmFjayk7XG4gICAgICAgIH07XG4gICAgfTtcbiAgICBjb25zdCBvbkNoYW5nZSA9IChwcm9wTmFtZSwgY2IpID0+IHtcbiAgICAgICAgY29uc3QgdW5TZXQgPSBvbignc2V0JywgKGtleSwgbmV3VmFsdWUpID0+IHtcbiAgICAgICAgICAgIGlmIChrZXkgPT09IHByb3BOYW1lKSB7XG4gICAgICAgICAgICAgICAgY2IobmV3VmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gV2UgbmVlZCB0byB1bndyYXAgdGhlIGRlZmF1bHRTdGF0ZSBiZWNhdXNlIGl0IG1pZ2h0IGJlIGEgZnVuY3Rpb24uXG4gICAgICAgIC8vIE90aGVyd2lzZSB3ZSBtaWdodCBub3QgYmUgc2VuZGluZyB0aGUgcmlnaHQgcmVzZXQgdmFsdWUuXG4gICAgICAgIGNvbnN0IHVuUmVzZXQgPSBvbigncmVzZXQnLCAoKSA9PiBjYih1bndyYXAoZGVmYXVsdFN0YXRlKVtwcm9wTmFtZV0pKTtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIHVuU2V0KCk7XG4gICAgICAgICAgICB1blJlc2V0KCk7XG4gICAgICAgIH07XG4gICAgfTtcbiAgICBjb25zdCB1c2UgPSAoLi4uc3Vic2NyaXB0aW9ucykgPT4ge1xuICAgICAgICBjb25zdCB1bnN1YnMgPSBzdWJzY3JpcHRpb25zLnJlZHVjZSgodW5zdWJzLCBzdWJzY3JpcHRpb24pID0+IHtcbiAgICAgICAgICAgIGlmIChzdWJzY3JpcHRpb24uc2V0KSB7XG4gICAgICAgICAgICAgICAgdW5zdWJzLnB1c2gob24oJ3NldCcsIHN1YnNjcmlwdGlvbi5zZXQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdWJzY3JpcHRpb24uZ2V0KSB7XG4gICAgICAgICAgICAgICAgdW5zdWJzLnB1c2gob24oJ2dldCcsIHN1YnNjcmlwdGlvbi5nZXQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdWJzY3JpcHRpb24ucmVzZXQpIHtcbiAgICAgICAgICAgICAgICB1bnN1YnMucHVzaChvbigncmVzZXQnLCBzdWJzY3JpcHRpb24ucmVzZXQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdWJzY3JpcHRpb24uZGlzcG9zZSkge1xuICAgICAgICAgICAgICAgIHVuc3Vicy5wdXNoKG9uKCdkaXNwb3NlJywgc3Vic2NyaXB0aW9uLmRpc3Bvc2UpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB1bnN1YnM7XG4gICAgICAgIH0sIFtdKTtcbiAgICAgICAgcmV0dXJuICgpID0+IHVuc3Vicy5mb3JFYWNoKCh1bnN1YikgPT4gdW5zdWIoKSk7XG4gICAgfTtcbiAgICBjb25zdCBmb3JjZVVwZGF0ZSA9IChrZXkpID0+IHtcbiAgICAgICAgY29uc3Qgb2xkVmFsdWUgPSBzdGF0ZXMuZ2V0KGtleSk7XG4gICAgICAgIGhhbmRsZXJzLnNldC5mb3JFYWNoKChjYikgPT4gY2Ioa2V5LCBvbGRWYWx1ZSwgb2xkVmFsdWUpKTtcbiAgICB9O1xuICAgIHJldHVybiB7XG4gICAgICAgIHN0YXRlLFxuICAgICAgICBnZXQsXG4gICAgICAgIHNldCxcbiAgICAgICAgb24sXG4gICAgICAgIG9uQ2hhbmdlLFxuICAgICAgICB1c2UsXG4gICAgICAgIGRpc3Bvc2UsXG4gICAgICAgIHJlc2V0LFxuICAgICAgICBmb3JjZVVwZGF0ZSxcbiAgICB9O1xufTtcbmNvbnN0IHJlbW92ZUZyb21BcnJheSA9IChhcnJheSwgaXRlbSkgPT4ge1xuICAgIGNvbnN0IGluZGV4ID0gYXJyYXkuaW5kZXhPZihpdGVtKTtcbiAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgICBhcnJheVtpbmRleF0gPSBhcnJheVthcnJheS5sZW5ndGggLSAxXTtcbiAgICAgICAgYXJyYXkubGVuZ3RoLS07XG4gICAgfVxufTtcblxuY29uc3QgY3JlYXRlU3RvcmUgPSAoZGVmYXVsdFN0YXRlLCBzaG91bGRVcGRhdGUpID0+IHtcbiAgICBjb25zdCBtYXAgPSBjcmVhdGVPYnNlcnZhYmxlTWFwKGRlZmF1bHRTdGF0ZSwgc2hvdWxkVXBkYXRlKTtcbiAgICBtYXAudXNlKHN0ZW5jaWxTdWJzY3JpcHRpb24oKSk7XG4gICAgcmV0dXJuIG1hcDtcbn07XG5cbmV4cG9ydCB7IGNyZWF0ZVN0b3JlIGFzIGMgfTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgtMDU5NTZjYWIuanMubWFwIiwiLyohXG4gKiBBbGwgbWF0ZXJpYWwgY29weXJpZ2h0IEVTUkksIEFsbCBSaWdodHMgUmVzZXJ2ZWQsIHVubGVzcyBvdGhlcndpc2Ugc3BlY2lmaWVkLlxuICogdjQuMC41OFxuICovXG5pbXBvcnQgeyBjIGFzIGNyZWF0ZVN0b3JlIH0gZnJvbSAnLi9pbmRleC0wNTk1NmNhYi5qcyc7XG5cbmNvbnN0IHVpU3RvcmUgPSBjcmVhdGVTdG9yZSh7XG4gICAgbmV4dFRleHQ6IFwibmV4dFwiLFxuICAgIHdvcmtmbG93OiBcImNvbnRlbnRcIixcbiAgICBzY2FsZTogXCJtXCIsXG4gICAgZGlzYWJsZVNjcm9sbDogZmFsc2UsXG4gICAgZmVhdHVyZUZsYWdzOiB7fVxufSk7XG5jb25zdCB1aVN0b3JlU3RhdGUgPSB1aVN0b3JlLnN0YXRlO1xuXG5leHBvcnQgeyB1aVN0b3JlIGFzIGEsIHVpU3RvcmVTdGF0ZSBhcyB1IH07XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVpLWJjYTdiY2QxLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==