"use strict";
(self["webpackChunkexb_client"] = self["webpackChunkexb_client"] || []).push([["vendors-extensions_widgets_arcgis_analysis_node_modules_arcgis_arcgis-raster-function-editor_-c735ac"],{

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/arcgis-raster-function-editor/dist/esm/localization-helper-4819b67d.js":
/*!****************************************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/arcgis-raster-function-editor/dist/esm/localization-helper-4819b67d.js ***!
  \****************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   D: () => (/* binding */ DefaultLocale),
/* harmony export */   S: () => (/* binding */ SupportedLocales),
/* harmony export */   a: () => (/* binding */ getDirectionBasedOnRTL),
/* harmony export */   b: () => (/* binding */ fetchComponentLocaleStrings),
/* harmony export */   f: () => (/* binding */ formatLocalizedHelpUrl),
/* harmony export */   g: () => (/* binding */ getLocaleInfo)
/* harmony export */ });
/**
 * Locale list reference [JSAPI](https://devtopia.esri.com/WebGIS/arcgis-js-api/tree/master/esri/nls)
 * also has Hindi: "hi"
 */
const SupportedLocales = {
    Arabic: "ar",
    Bosnian: "bs",
    Bulgarian: "bg",
    Catalan: "ca",
    Czech: "cs",
    Danish: "da",
    German: "de",
    Greek: "el",
    English: "en",
    EnglishUSA: "en-US",
    Spanish: "es",
    Estonian: "et",
    Finnish: "fi",
    French: "fr",
    Hebrew: "he",
    Hindi: "hi",
    Croatian: "hr",
    Hungarian: "hu",
    Indonesian: "id",
    Italian: "it",
    Japanese: "ja",
    Korean: "ko",
    Lithuanian: "lt",
    Latvian: "lv",
    NorwegianBokml: "nb",
    Dutch: "nl",
    Polish: "pl",
    PortugueseBrazil: "pt-BR",
    PortuguesePortugal: "pt-PT",
    Romanian: "ro",
    Russian: "ru",
    Serbian: "sr",
    Slovenian: "sl",
    Slovak: "sk",
    Swedish: "sv",
    Thai: "th",
    Turkish: "tr",
    Ukrainian: "uk",
    Vietnamese: "vi",
    ChineseChina: "zh-CN",
    ChineseHongKong: "zh-HK",
    ChineseTaiwan: "zh-TW"
};
const SupportedOnlineHelpLocales = ["ar", "de", "es", "fr", "it", "ja", "ko", "ru", "pl", "pt-br", "zh-cn"];
const LocaleMap = {
    "en-AU": "en",
    "en-CA": "en",
    "en-GB": "en",
    "en-US": "en",
    "es-ES": "es",
    "es-MX": "es",
    "de-CH": "de",
    "de-AT": "de",
    "de-DE": "de",
    "fr-CH": "fr",
    "fr-FR": "fr",
    "it-CH": "it",
    "it-IT": "it",
    ind: "id",
    ukr: "uk"
};
/**
 * List of supported locales that are RTL
 * reference: https://devtopia.esri.com/WebGIS/arcgis-js-api/blob/4master/esri/intl/locale.ts
 */
const RTLLocales = [SupportedLocales.Arabic, SupportedLocales.Hebrew];
const DefaultLocale = SupportedLocales.English;
/**
 * Utility to centralize logic, and return "rtl" or "rtl" depending on rtl boolean
 * @param {boolean} rtl whether locale is in Right to Left direction
 * @returns {"ltr" | "rtl"} codes that can be passed to "dir" prop of a component.
 */
function getDirectionBasedOnRTL(rtl) {
    return rtl === true ? "rtl" : "ltr";
}
/**
 * Helper function to find the closest element crossing multiple (parent) shadowDOM boundaries.
 * The implementation is based on [this](https://stackoverflow.com/questions/54520554/custom-element-getrootnode-closest-function-crossing-multiple-parent-shadowd) solution.
 *
 * @param {string} selector
 * @param {Element} base
 */
function getClosestElement(selector, base) {
    function closestFrom(el) {
        let element;
        if (el === undefined || el === document || el === window)
            element = null;
        else {
            const found = el.closest(selector);
            element = found || closestFrom(el.getRootNode().host);
        }
        return element;
    }
    return closestFrom(base);
}
/**
 * Converts the given locale to a supported locale using the provided locale map.
 *
 * @param {string | undefined} locale - The locale to be converted.
 * @param {object} localeMap - A map of locales to supported locales.
 * @returns {string} - The supported locale.
 */
function convertToSupportedLocale(locale, localeMap) {
    const defaultLocale = DefaultLocale;
    let localeSanitized = locale?.toLowerCase();
    if (localeSanitized !== undefined && localeSanitized.indexOf("-") !== -1) {
        const [lang, region] = localeSanitized.split("-");
        localeSanitized = `${lang}-${region.toUpperCase()}`;
    }
    if (!localeSanitized) {
        return defaultLocale;
    }
    const localeMapKeys = Object.keys(LocaleMap);
    if (localeMapKeys.includes(localeSanitized) === true) {
        return localeMap[localeSanitized];
    }
    return localeSanitized;
}
/**
 * Retrieves locale information; In the case of Regional codes (en-au) it is converted to a supported locale (en).
 *
 * @param {Element} [element=document.documentElement] - The element to search for locale information.
 * @returns {Object} An object containing the locale information.
 * @property {string} locale - The locale code.
 * @property {boolean} rtl - A flag indicating whether the locale is right-to-left.
 */
function getLocaleInfo(element = document.documentElement) {
    // Gets the closest element with a lang attribute and falls back to navigator.language if not found
    const closestElement = getClosestElement("[lang]", element);
    const locale = closestElement?.lang ?? window.navigator.language;
    const supportedLocales = Object.values(SupportedLocales);
    const defaultLocale = DefaultLocale;
    const convertedLocale = convertToSupportedLocale(locale, LocaleMap);
    const isSupportedLocale = supportedLocales.includes(convertedLocale);
    return {
        locale: isSupportedLocale ? convertedLocale : defaultLocale,
        rtl: RTLLocales.includes(locale)
    };
}
/**
 * Fetches the locale file of the given component; defaults to `"en"` locale
 * @param componentName
 * @param props
 * @param locale
 * @param resourcesUrl
 * @param props.path
 * @param props.locale
 * @param props.baseURL
 */
async function fetchLocaleStrings(props) {
    const { path, locale, baseURL } = props;
    // Using the getPublicPath method that leverages `data-resources-url` currently this is not working.
    // const rUrl = getPublicPath(componentName) || resourcesUrl;
    let localeData = {};
    try {
        const response = await fetch(`${baseURL}t9n/${path}.t9n.${locale}.json`);
        localeData = await response.json();
    }
    catch (e) {
        const defaultResponse = await fetch(`${baseURL}t9n/${path}.t9n.${DefaultLocale}.json`);
        localeData = await defaultResponse.json();
    }
    return localeData;
}
async function fetchComponentLocaleStrings(element, baseURL) {
    const componentName = element.tagName.toLowerCase();
    const { locale, rtl } = getLocaleInfo(element);
    const strings = await fetchLocaleStrings({ path: componentName, locale, baseURL });
    return { strings, dir: getDirectionBasedOnRTL(rtl), locale: locale };
}
/**
 * Formats a URL to link to
 * @param {string} url the url string from after the locale
 * @param {string} basePath the base path from the signed in portal object.
 * @param {string} locale the locale abbreviation for the browser.
 * @returns {string} the formatted url.
 */
function formatLocalizedHelpUrl(url, basePath, locale = "en") {
    let localeSanitized = locale;
    const localeMapKeys = Object.keys(LocaleMap);
    if (localeMapKeys.includes(locale) === true) {
        localeSanitized = LocaleMap[locale];
    }
    const localeInLowerCase = localeSanitized.toLocaleLowerCase();
    if (SupportedOnlineHelpLocales.includes(localeInLowerCase) === true) {
        // following regex tests /en/ is present in url and replaces it with the locale
        // https://docdev.arcgis.com/en/arcgis-online/analyze/aggregate-points-mv.htm
        // self Response only provides with `en` locale not as per the user locale or current app locale
        // so we need this replace call.
        basePath = basePath.replace(/^https?:\/\/[^/]+\/en/, (match) => match.replace("en", localeInLowerCase));
    }
    const learnMoreUrl = `${basePath}analyze/${url}`;
    return learnMoreUrl;
}



//# sourceMappingURL=localization-helper-4819b67d.js.map

/***/ }),

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/arcgis-raster-function-editor/dist/esm/rfx-cte-gamma-editor-edc20588.js":
/*!*****************************************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/arcgis-raster-function-editor/dist/esm/rfx-cte-gamma-editor-edc20588.js ***!
  \*****************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   R: () => (/* binding */ RfxGammaEditor),
/* harmony export */   a: () => (/* binding */ computeGamma),
/* harmony export */   c: () => (/* binding */ computeGammaValues)
/* harmony export */ });
/* harmony import */ var _index_da1b7138_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index-da1b7138.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/arcgis-raster-function-editor/dist/esm/index-da1b7138.js");
/* harmony import */ var _localization_helper_4819b67d_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./localization-helper-4819b67d.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/arcgis-raster-function-editor/dist/esm/localization-helper-4819b67d.js");
/* harmony import */ var _arcgis_core_core_lang_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @arcgis/core/core/lang.js */ "@arcgis/core/core/lang.js");
/* harmony import */ var _type_gaurds_1840747f_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./type-gaurds-1840747f.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/arcgis-raster-function-editor/dist/esm/type-gaurds-1840747f.js");
/* harmony import */ var _ui_utils_928a4096_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./ui-utils-928a4096.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/arcgis-raster-function-editor/dist/esm/ui-utils-928a4096.js");
/* harmony import */ var _arcgis_core_identity_IdentityManager_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @arcgis/core/identity/IdentityManager.js */ "@arcgis/core/identity/IdentityManager.js");
/* harmony import */ var _arcgis_core_core_urlUtils_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @arcgis/core/core/urlUtils.js */ "@arcgis/core/core/urlUtils.js");
/* harmony import */ var _arcgis_core_layers_Layer_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @arcgis/core/layers/Layer.js */ "@arcgis/core/layers/Layer.js");
/* harmony import */ var _arcgis_core_layers_ImageryLayer_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @arcgis/core/layers/ImageryLayer.js */ "@arcgis/core/layers/ImageryLayer.js");
/* harmony import */ var _arcgis_core_smartMapping_raster_renderers_stretch_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @arcgis/core/smartMapping/raster/renderers/stretch.js */ "@arcgis/core/smartMapping/raster/renderers/stretch.js");
/* harmony import */ var _arcgis_core_request_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @arcgis/core/request.js */ "@arcgis/core/request.js");
/* harmony import */ var _arcgis_core_rest_support_AlgorithmicColorRamp_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @arcgis/core/rest/support/AlgorithmicColorRamp.js */ "@arcgis/core/rest/support/AlgorithmicColorRamp.js");
/* harmony import */ var _arcgis_core_rest_support_MultipartColorRamp_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @arcgis/core/rest/support/MultipartColorRamp.js */ "@arcgis/core/rest/support/MultipartColorRamp.js");
/* harmony import */ var _arcgis_core_Color_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! @arcgis/core/Color.js */ "@arcgis/core/Color.js");
/* harmony import */ var _colorRampUtils_8bdd46c5_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./colorRampUtils-8bdd46c5.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/arcgis-raster-function-editor/dist/esm/colorRampUtils-8bdd46c5.js");
/* harmony import */ var _sanitize_number_d84114f7_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./sanitize-number-d84114f7.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/arcgis-raster-function-editor/dist/esm/sanitize-number-d84114f7.js");
/* harmony import */ var _arcgis_core_rest_geoprocessor_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! @arcgis/core/rest/geoprocessor.js */ "@arcgis/core/rest/geoprocessor.js");
/* harmony import */ var _arcgis_core_portal_PortalItem_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! @arcgis/core/portal/PortalItem.js */ "@arcgis/core/portal/PortalItem.js");



















// Ported from "esri/layers/support/rasterFunctions/stretchUtils.ts"
// https://devtopia.esri.com/WebGIS/arcgis-js-api/blob/4master/esri/layers/support/rasterFunctions/stretchUtils.ts#L245
const DEFAULT_NOOP_GAMMA = 1.0;
const RGB2LUMA_WT = [0.299, 0.587, 0.114];
function computeGammaValue(meanLumaU8B) {
    if (meanLumaU8B <= 0 || meanLumaU8B >= 255) {
        return DEFAULT_NOOP_GAMMA;
    }
    let offset = 0;
    if (meanLumaU8B !== 150) {
        offset = meanLumaU8B <= 150 ? 45.0 * Math.cos(0.01047 * meanLumaU8B) : 17.0 * Math.sin(0.021 * meanLumaU8B);
    }
    const maxLuma = 255.0;
    const targetMeanLuma = meanLumaU8B + offset;
    const omr = Math.log(meanLumaU8B / maxLuma);
    const tmr = Math.log(targetMeanLuma / maxLuma);
    if (tmr === 0) {
        return DEFAULT_NOOP_GAMMA;
    }
    const gamma = omr / tmr;
    if (isNaN(gamma)) {
        return DEFAULT_NOOP_GAMMA;
    }
    // notes from Pro: we want to force it to be in (0,10) range, experienced based on experiment in 10.1 look good project
    return Math.min(9.9, Math.max(0.01, gamma));
}
function computeGammaValues(pixelType, statistics, applyRGBWeights) {
    // ported from 3.x https://devtopia.esri.com/WebGIS/arcgis-js-api/blob/master/esri/layers/pixelFilters/StretchFilter.js#L542
    // which was based on the fast approx method in Pro Stretch.cpp
    const gammas = [];
    for (let i = 0; i < statistics.length; i++) {
        let min = 0, max = 0, avg = 0;
        if ("min" in statistics[i]) {
            ({ min, max, avg } = statistics[i]);
        }
        else {
            [min, max, avg] = statistics[i];
        }
        let mean = avg;
        if (pixelType !== "u8") {
            mean = (255 * (mean - min)) / (max - min);
        }
        if (applyRGBWeights) {
            mean = mean * RGB2LUMA_WT[i];
        }
        gammas.push(computeGammaValue(mean));
    }
    return gammas;
}
function computeGamma(layer) {
    const layerRasterInfo = layer.rasterInfo;
    const rasterStatistics = layerRasterInfo?.statistics;
    const pixelType = layerRasterInfo?.pixelType;
    if (rasterStatistics?.length === 0 || !pixelType) {
        return undefined;
    }
    const gamma = computeGammaValues(pixelType, rasterStatistics);
    return gamma;
}

const HelpClickHandlerKeys = {
    inputArgHelpClickHandler: "inputArgHelpClickHandler"
};

const RfxGammaEditor = class {
    constructor(hostRef) {
        (0,_index_da1b7138_js__WEBPACK_IMPORTED_MODULE_0__.r)(this, hostRef);
        this.rfxArgumentChange = (0,_index_da1b7138_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, "rfxArgumentChange", 7);
        /**
         * defaultMin value for a gamma slider widget
         */
        this.defaultMin = -1;
        /**
         * defaultMax value for a gamma slider widget
         */
        this.defaultMax = 10;
        this.bandCount = 1;
        /**
         * defaultValue for a gamma slider widget
         */
        this.defaultValue = 1;
        /**
         * Stores event handlers for help action click, stored in connected callback to avoid
         * fetching function on each render ( to avoid common bad practice )
         */
        this.helpActionClickEventHandlers = new Map();
        this.handleSliderChange = (e, bandIndex) => {
            const element = e.target;
            const value = element.value;
            this.value[bandIndex] = value;
            this.rfxArgumentChange.emit({ value: this.value });
        };
        this.value = undefined;
        this.widgetArgs = undefined;
    }
    //--------------------------------------------------------------------------
    //
    //  Lifecycle
    //
    //--------------------------------------------------------------------------
    connectedCallback() {
        this.processWidgetArgs();
    }
    async componentWillLoad() {
        ({ strings: this.strings, dir: this.direction } = await (0,_localization_helper_4819b67d_js__WEBPACK_IMPORTED_MODULE_1__.b)(this.hostElement, (0,_index_da1b7138_js__WEBPACK_IMPORTED_MODULE_0__.g)(`.`)));
        this.setInitialState();
    }
    componentDidLoad() {
        this.attachHelpClickEventHandlers();
    }
    //--------------------------------------------------------------------------
    //
    //  Private Methods
    //
    //--------------------------------------------------------------------------
    /**
     * All validation logic of widgetArgs -> mainly the inputArgs and triggerAttributes
     * goes here
     */
    processWidgetArgs() {
        // should have only one inputArg
        Object.keys(this.widgetArgs.inputArgs).forEach((_inputArg) => {
            const rfxArg = this.widgetArgs.inputArgs[_inputArg];
            this.inputArg = rfxArg;
            rfxArg.input = this.hostElement;
        });
        const { triggerArgs } = this.widgetArgs;
        const rasterRfxArg = triggerArgs?.Raster;
        if (typeof rasterRfxArg === "undefined") {
            console.error("Invalid Schema: Raster is not passed in TriggerArgs");
        }
        this.rasterArg = rasterRfxArg;
        rasterRfxArg?.input?.addEventListener("rfxArgumentChange", () => {
            this.handleRasterChange();
        });
    }
    async setInitialState() {
        const rfxArgValue = this.inputArg.value;
        // if rfxArgValue is set, use that as widget value
        if ((0,_type_gaurds_1840747f_js__WEBPACK_IMPORTED_MODULE_3__.i)(rfxArgValue) !== true) {
            this.value = rfxArgValue;
        }
        const rasterInput = this.rasterArg?.input;
        // if no rasterInput is set, use [] as widget value
        if ((0,_type_gaurds_1840747f_js__WEBPACK_IMPORTED_MODULE_3__.i)(rasterInput?.value)) {
            this.value = [];
            return;
        }
        const layer = await rasterInput?.getSelectedLayer?.();
        const rasterInfo = layer?.rasterInfo;
        this.bandCount = rasterInfo?.bandCount;
        this.value = computeGamma(layer);
    }
    attachHelpClickEventHandlers() {
        const inputArgHelpClickHandler = this.widgetArgs.onHelpActionClick({
            heading: this.inputArg.displayName,
            referenceElement: this.widgetContainer,
            helpTextID: this.inputArg?.helpTextID
        });
        this.helpActionClickEventHandlers.set(HelpClickHandlerKeys.inputArgHelpClickHandler, inputArgHelpClickHandler);
    }
    async handleRasterChange() {
        const rasterInput = this.rasterArg?.input;
        const layer = await rasterInput?.getSelectedLayer?.();
        const rasterInfo = layer?.rasterInfo;
        this.bandCount = rasterInfo.bandCount;
        this.value = computeGamma(layer);
    }
    render() {
        const bandCount = this.bandCount;
        const gammaValues = this.value;
        return ((0,_index_da1b7138_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", null, (0,_index_da1b7138_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", { alignment: "start", scale: _ui_utils_928a4096_js__WEBPACK_IMPORTED_MODULE_4__.U.Scale, layout: "default", ref: (e) => {
                this.widgetContainer = e;
            } }, (0,_index_da1b7138_js__WEBPACK_IMPORTED_MODULE_0__.h)("rfx-label", { label: this.inputArg.displayName, onRfxLabelHelpActionClick: () => this.helpActionClickEventHandlers?.get(HelpClickHandlerKeys.inputArgHelpClickHandler)() }), Array.from({ length: bandCount }).map((_, bandIndex) => ((0,_index_da1b7138_js__WEBPACK_IMPORTED_MODULE_0__.h)("rfx-dtex-arg-slider", { min: this.defaultMin, max: this.defaultMax, value: (0,_sanitize_number_d84114f7_js__WEBPACK_IMPORTED_MODULE_15__.f)(gammaValues?.[bandIndex] ?? this.defaultValue, 3), step: 0.01, onRfxArgumentChange: (e) => {
                this.handleSliderChange(e, bandIndex);
            } }))))));
    }
    static get assetsDirs() { return ["t9n"]; }
    get hostElement() { return (0,_index_da1b7138_js__WEBPACK_IMPORTED_MODULE_0__.a)(this); }
};



//# sourceMappingURL=rfx-cte-gamma-editor-edc20588.js.map

/***/ }),

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/arcgis-raster-function-editor/dist/esm/rfx-cte-gamma-editor.entry.js":
/*!**************************************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/arcgis-raster-function-editor/dist/esm/rfx-cte-gamma-editor.entry.js ***!
  \**************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   rfx_cte_gamma_editor: () => (/* reexport safe */ _rfx_cte_gamma_editor_edc20588_js__WEBPACK_IMPORTED_MODULE_0__.R)
/* harmony export */ });
/* harmony import */ var _rfx_cte_gamma_editor_edc20588_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./rfx-cte-gamma-editor-edc20588.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/arcgis-raster-function-editor/dist/esm/rfx-cte-gamma-editor-edc20588.js");
/* harmony import */ var _index_da1b7138_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index-da1b7138.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/arcgis-raster-function-editor/dist/esm/index-da1b7138.js");
/* harmony import */ var _localization_helper_4819b67d_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./localization-helper-4819b67d.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/arcgis-raster-function-editor/dist/esm/localization-helper-4819b67d.js");
/* harmony import */ var _arcgis_core_core_lang_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @arcgis/core/core/lang.js */ "@arcgis/core/core/lang.js");
/* harmony import */ var _type_gaurds_1840747f_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./type-gaurds-1840747f.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/arcgis-raster-function-editor/dist/esm/type-gaurds-1840747f.js");
/* harmony import */ var _getTag_96af029d_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./_getTag-96af029d.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/arcgis-raster-function-editor/dist/esm/_getTag-96af029d.js");
/* harmony import */ var _ui_utils_928a4096_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./ui-utils-928a4096.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/arcgis-raster-function-editor/dist/esm/ui-utils-928a4096.js");
/* harmony import */ var _arcgis_core_identity_IdentityManager_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @arcgis/core/identity/IdentityManager.js */ "@arcgis/core/identity/IdentityManager.js");
/* harmony import */ var _arcgis_core_core_urlUtils_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @arcgis/core/core/urlUtils.js */ "@arcgis/core/core/urlUtils.js");
/* harmony import */ var _arcgis_core_layers_Layer_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @arcgis/core/layers/Layer.js */ "@arcgis/core/layers/Layer.js");
/* harmony import */ var _arcgis_core_layers_ImageryLayer_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @arcgis/core/layers/ImageryLayer.js */ "@arcgis/core/layers/ImageryLayer.js");
/* harmony import */ var _arcgis_core_smartMapping_raster_renderers_stretch_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @arcgis/core/smartMapping/raster/renderers/stretch.js */ "@arcgis/core/smartMapping/raster/renderers/stretch.js");
/* harmony import */ var _arcgis_core_request_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @arcgis/core/request.js */ "@arcgis/core/request.js");
/* harmony import */ var _arcgis_core_rest_support_AlgorithmicColorRamp_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! @arcgis/core/rest/support/AlgorithmicColorRamp.js */ "@arcgis/core/rest/support/AlgorithmicColorRamp.js");
/* harmony import */ var _arcgis_core_rest_support_MultipartColorRamp_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! @arcgis/core/rest/support/MultipartColorRamp.js */ "@arcgis/core/rest/support/MultipartColorRamp.js");
/* harmony import */ var _arcgis_core_Color_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! @arcgis/core/Color.js */ "@arcgis/core/Color.js");
/* harmony import */ var _colorRampUtils_8bdd46c5_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./colorRampUtils-8bdd46c5.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/arcgis-raster-function-editor/dist/esm/colorRampUtils-8bdd46c5.js");
/* harmony import */ var _sanitize_number_d84114f7_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./sanitize-number-d84114f7.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/arcgis-raster-function-editor/dist/esm/sanitize-number-d84114f7.js");
/* harmony import */ var _arcgis_core_rest_geoprocessor_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! @arcgis/core/rest/geoprocessor.js */ "@arcgis/core/rest/geoprocessor.js");
/* harmony import */ var _arcgis_core_portal_PortalItem_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! @arcgis/core/portal/PortalItem.js */ "@arcgis/core/portal/PortalItem.js");





















//# sourceMappingURL=rfx-cte-gamma-editor.entry.js.map

/***/ }),

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/arcgis-raster-function-editor/dist/esm/sanitize-number-d84114f7.js":
/*!************************************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/arcgis-raster-function-editor/dist/esm/sanitize-number-d84114f7.js ***!
  \************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   a: () => (/* binding */ formatNumberToLocale),
/* harmony export */   f: () => (/* binding */ formatNumber),
/* harmony export */   i: () => (/* binding */ isValidNumber),
/* harmony export */   p: () => (/* binding */ parseNumber),
/* harmony export */   s: () => (/* binding */ sanitizeNumber)
/* harmony export */ });
/* harmony import */ var _localization_helper_4819b67d_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./localization-helper-4819b67d.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/arcgis-raster-function-editor/dist/esm/localization-helper-4819b67d.js");
/* harmony import */ var _type_gaurds_1840747f_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./type-gaurds-1840747f.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/arcgis-raster-function-editor/dist/esm/type-gaurds-1840747f.js");



/**
 * Indicates if a provided number value is valid.
 * An invalid value is: undefined | NaN | Infinite | -Infinite | null
 * See for more details:
 *   - https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isFinite
 *   - https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isNaN
 * @param {number | undefined | null} value value to check
 * @returns {boolean} if valid or not
 */
function isValidNumber(value) {
    return value !== undefined && value !== null && Number.isNaN(value) === false && Number.isFinite(value) === true;
}
/**
 * Returns a string representation of the provided number for use with calcite-input. It also
 * guards against invalid types following this logic:
 *   - If the value is valid (not NaN, finite), the value is returned as a string
 *   - If not and if a valid default value is provided, the default value is returned as a string
 *   - If not, an empty string is returned
 * @param value
 * @param defaultValue
 * @returns a sanitized string
 */
function sanitizeNumber(value, defaultValue) {
    let returnedValue;
    if (value !== null) {
        const testedValue = typeof value === "string" ? Number.parseFloat(value) : value;
        if (isValidNumber(testedValue))
            returnedValue = testedValue;
        else if (isValidNumber(defaultValue))
            returnedValue = defaultValue;
    }
    return returnedValue === undefined ? "" : `${returnedValue}`;
}
/**
 * Parses a value string to a number for use with calcite-input. If the string is empty, it will return undefined.
 * If the string is otherwise invalid, it will return NaN.
 * @param value calcite-input value
 * @returns {number | undefined} the parsed number
 */
function parseNumber(value) {
    if (value === "")
        return undefined;
    return Number.parseFloat(value);
}
/**
 * Formats a number to a specified number of decimal places.
 *
 * @param {number} value - The number to format.
 * @param {number} [fractionDigits=3] - The number of decimal places to include in the formatted number. Defaults to 3.
 * @returns {number|undefined} - The formatted number, or undefined if the input value is empty.
 */
function formatNumber(value, fractionDigits = 3) {
    if ((0,_type_gaurds_1840747f_js__WEBPACK_IMPORTED_MODULE_1__.i)(value))
        return undefined;
    return Number.parseFloat(value.toFixed(fractionDigits));
}
/**
 * Formats a number or string representing a number according to the locale, passing Intl number format options
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/ReferenceGlobal_Objects/Intl/NumberFormat/NumberFormat#options
 * @param {number | string | undefined} value to be formatted and localized
 * @param {Intl.NumberFormatOptions} formatOptions options object matching Intl.NumberFormat
 * @returns {string} localized / rounded string
 */
function formatNumberToLocale(value, formatOptions) {
    let formattedValue = "";
    if (!(0,_type_gaurds_1840747f_js__WEBPACK_IMPORTED_MODULE_1__.i)(value) && !Number.isNaN(value)) {
        const localeCode = (0,_localization_helper_4819b67d_js__WEBPACK_IMPORTED_MODULE_0__.g)().locale;
        formattedValue = Intl.NumberFormat(localeCode, formatOptions).format(Number(value));
    }
    return formattedValue;
}



//# sourceMappingURL=sanitize-number-d84114f7.js.map

/***/ }),

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/arcgis-raster-function-editor/dist/esm/type-gaurds-1840747f.js":
/*!********************************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/arcgis-raster-function-editor/dist/esm/type-gaurds-1840747f.js ***!
  \********************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ ARGS_KEYWORD),
/* harmony export */   F: () => (/* binding */ FUNCTION_KEYWORD),
/* harmony export */   R: () => (/* binding */ RFV_TYPE),
/* harmony export */   T: () => (/* binding */ TYPE_KEYWORD),
/* harmony export */   a: () => (/* binding */ isRFxArg),
/* harmony export */   b: () => (/* binding */ RFT_TYPE),
/* harmony export */   c: () => (/* binding */ isReferencedObject),
/* harmony export */   d: () => (/* binding */ isNumber),
/* harmony export */   e: () => (/* binding */ isWidgetValueBoolean),
/* harmony export */   f: () => (/* binding */ isColorRamp),
/* harmony export */   g: () => (/* binding */ isRecordSet),
/* harmony export */   h: () => (/* binding */ isFeatureLayer),
/* harmony export */   i: () => (/* binding */ isEmptyDataItem),
/* harmony export */   j: () => (/* binding */ isTileLayer),
/* harmony export */   k: () => (/* binding */ isDynamicImageryLayer),
/* harmony export */   l: () => (/* binding */ isImageryLayer),
/* harmony export */   m: () => (/* binding */ isImageryTileLayer)
/* harmony export */ });
/* harmony import */ var _getTag_96af029d_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_getTag-96af029d.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/arcgis-raster-function-editor/dist/esm/_getTag-96af029d.js");


/** `Object#toString` result references. */
var mapTag = '[object Map]',
    setTag = '[object Set]';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Checks if `value` is an empty object, collection, map, or set.
 *
 * Objects are considered empty if they have no own enumerable string keyed
 * properties.
 *
 * Array-like values such as `arguments` objects, arrays, buffers, strings, or
 * jQuery-like collections are considered empty if they have a `length` of `0`.
 * Similarly, maps and sets are considered empty if they have a `size` of `0`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is empty, else `false`.
 * @example
 *
 * _.isEmpty(null);
 * // => true
 *
 * _.isEmpty(true);
 * // => true
 *
 * _.isEmpty(1);
 * // => true
 *
 * _.isEmpty([1, 2, 3]);
 * // => false
 *
 * _.isEmpty({ 'a': 1 });
 * // => false
 */
function isEmpty(value) {
  if (value == null) {
    return true;
  }
  if ((0,_getTag_96af029d_js__WEBPACK_IMPORTED_MODULE_0__.i)(value) &&
      ((0,_getTag_96af029d_js__WEBPACK_IMPORTED_MODULE_0__.a)(value) || typeof value == 'string' || typeof value.splice == 'function' ||
        (0,_getTag_96af029d_js__WEBPACK_IMPORTED_MODULE_0__.b)(value) || (0,_getTag_96af029d_js__WEBPACK_IMPORTED_MODULE_0__.c)(value) || (0,_getTag_96af029d_js__WEBPACK_IMPORTED_MODULE_0__.d)(value))) {
    return !value.length;
  }
  var tag = (0,_getTag_96af029d_js__WEBPACK_IMPORTED_MODULE_0__.g)(value);
  if (tag == mapTag || tag == setTag) {
    return !value.size;
  }
  if ((0,_getTag_96af029d_js__WEBPACK_IMPORTED_MODULE_0__.e)(value)) {
    return !(0,_getTag_96af029d_js__WEBPACK_IMPORTED_MODULE_0__.f)(value).length;
  }
  for (var key in value) {
    if (hasOwnProperty.call(value, key)) {
      return false;
    }
  }
  return true;
}

const RFT_TYPE = "RasterFunctionTemplate";
const TYPE_KEYWORD = "type";
const RFV_TYPE = "RasterFunctionVariable";
const ARGS_KEYWORD = "arguments";
const FUNCTION_KEYWORD = "function";
function isReferencedObject(obj) {
    if (!obj) {
        return false;
    }
    if (obj._object_ref_id != null) {
        return true;
    }
    return false;
}
function isNumber(x) {
    x = String(x).trim();
    if (x === "") {
        return false;
    }
    return /^[+-]?(\d+)?(\.\d+)?$/.test(x);
}
function isWidgetValueBoolean(x) {
    x = String(x).trim();
    return ["true", "false"].indexOf(x) >= 0;
}
function isColorRamp(rfxArg) {
    if (!rfxArg) {
        return false;
    }
    if (rfxArg.type && rfxArg.type.toLowerCase().indexOf("colorramp") >= 0) {
        return true;
    }
    if (rfxArg.value && rfxArg.value.type && rfxArg.value.type.toLowerCase().indexOf("colorramp") >= 0) {
        return true;
    }
    return false;
}
function isRecordSet(rfxArg) {
    return rfxArg.type && rfxArg.type.toLowerCase().indexOf("recordset") >= 0;
}
/**
 * Determines whether the given RFT element is an RFx argument.
 *
 * @param {any} rftElement - The RFT element to check.
 * @returns {boolean} `true` if the given element is RasterFunctionTemplate,
 * RasterFunctionVariable, isColorRamp, isRecordSet; `false` otherwise.
 */
function isRFxArg(rftElement) {
    if (!rftElement) {
        return false;
    }
    const type = rftElement.type;
    return [RFT_TYPE, RFV_TYPE].indexOf(type) >= 0 || isColorRamp(rftElement) || isRecordSet(rftElement);
}
/**
 * Determines if the input is a FeatureLayer
 * @param {__esri.Layer} layer the layer to check the type of
 * @returns {layer is __esri.FeatureLayer} layer is a FeatureLayer
 */
function isFeatureLayer(layer) {
    return layer.type === "feature";
}
/**
 * Determines if the input is a TileLayer
 * @param {__esri.Layer} layer the layer to check the type of
 * @returns {layer is __esri.TileLayer} layer is a TileLayer
 */
function isTileLayer(layer) {
    return layer.type === "tile";
}
/**
 * Determines if the input is a ImageryTileLayer
 * @param {__esri.Layer} layer the layer to check the type of
 * @returns {layer is __esri.ImageryLayer} layer is a ImageryLayer
 */
function isDynamicImageryLayer(layer) {
    return (layer.type === "imagery-tile" &&
        layer.sourceJSON.capabilities.toLowerCase().indexOf("tilesonly") < 0);
}
/**
 * Determines if the input is a ImageryLayer
 * @param {__esri.Layer} layer the layer to check the type of
 * @returns {layer is __esri.ImageryLayer} layer is a ImageryLayer
 */
function isImageryLayer(layer) {
    return layer.type === "imagery" || isDynamicImageryLayer(layer);
}
/**
 * Determines if the input is a ImageryTileLayer
 * @param {__esri.Layer} layer the layer to check the type of
 * @returns {layer is __esri.ImageryTileLayer} layer is a ImageryTileLayer
 */
function isImageryTileLayer(layer) {
    return layer.type === "imagery-tile" && !isDynamicImageryLayer(layer);
}
function isEveryPropertyEmpty(value) {
    let isAllPropsEmpty = true;
    if (typeof value === "object" && (0,_getTag_96af029d_js__WEBPACK_IMPORTED_MODULE_0__.a)(value) === false) {
        // using for-in as it will work with objects with properties that set via accessors as well
        for (const prop in value) {
            // This will tell the TypeScript compiler that the obj object has a string index signature,
            // and will allow to access its properties using a string index without getting the "Element implicitly has an 'any' type" error.
            const propValue = value?.[prop];
            if (value.hasOwnProperty(prop) === true && propValue !== undefined && propValue !== null && propValue !== "") {
                isAllPropsEmpty = false;
                break;
            }
        }
    }
    return isAllPropsEmpty;
}
/**
 * Check for an empty value for data items like GPString and Field.
 * @param value data item value.
 * @returns whether the value is considered empty.
 */
function isEmptyDataItem(value) {
    return (value === undefined ||
        value === null ||
        // single-select, "" is a special case for strings
        (typeof value === "string" && value === "") ||
        // single-select, empty objects are a special case for nested values
        ((0,_getTag_96af029d_js__WEBPACK_IMPORTED_MODULE_0__.h)(value) && isEmpty(value)) ||
        // multi-select
        (Array.isArray(value) && value.length < 1) ||
        // only testing objects which are not arrays
        // TODO: combine isEveryPropertyEmpty and isEmptyDataItem to single function
        (typeof value === "object" && (0,_getTag_96af029d_js__WEBPACK_IMPORTED_MODULE_0__.a)(value) === false && isEveryPropertyEmpty(value)));
}



//# sourceMappingURL=type-gaurds-1840747f.js.map

/***/ }),

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/arcgis-raster-function-editor/dist/esm/ui-utils-928a4096.js":
/*!*****************************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/arcgis-raster-function-editor/dist/esm/ui-utils-928a4096.js ***!
  \*****************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   C: () => (/* binding */ CalciteScale),
/* harmony export */   U: () => (/* binding */ UIDefaults),
/* harmony export */   a: () => (/* binding */ CalciteOverlayPositioning)
/* harmony export */ });
const UIDefaults = {
    Scale: "s",
    PopoverTimer: 60
};
const CalciteScale = {
    s: "s",
    m: "m"
};
const CalciteOverlayPositioning = {
    absolute: "absolute",
    fixed: "fixed"
};



//# sourceMappingURL=ui-utils-928a4096.js.map

/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid2lkZ2V0cy9jaHVua3MvYXJjZ2lzX2FuYWx5c2lzX25vZGVfbW9kdWxlc19hcmNnaXNfYXJjZ2lzLXJhc3Rlci1mdW5jdGlvbi1lZGl0b3JfLWM3MzVhYy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLGFBQWEsZUFBZTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxvQkFBb0I7QUFDL0IsV0FBVyxRQUFRO0FBQ25CLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsS0FBSyxHQUFHLHFCQUFxQjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0EsV0FBVyxTQUFT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ekIsYUFBYSw4QkFBOEI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGNBQWM7QUFDekIsYUFBYSw4QkFBOEI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxjQUFjO0FBQ3pCLGFBQWEsa0NBQWtDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxzREFBTztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLHNEQUFhO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLHNEQUFPO0FBQzdDOztBQUVrVzs7QUFFbFc7Ozs7Ozs7Ozs7Ozs7Ozs7QUN6TUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUU4RTs7QUFFOUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9leGItY2xpZW50Ly4vZXh0ZW5zaW9ucy93aWRnZXRzL2FyY2dpcy9hbmFseXNpcy9ub2RlX21vZHVsZXMvQGFyY2dpcy9hcmNnaXMtcmFzdGVyLWZ1bmN0aW9uLWVkaXRvci9kaXN0L2VzbS9sb2NhbGl6YXRpb24taGVscGVyLTQ4MTliNjdkLmpzIiwid2VicGFjazovL2V4Yi1jbGllbnQvLi9leHRlbnNpb25zL3dpZGdldHMvYXJjZ2lzL2FuYWx5c2lzL25vZGVfbW9kdWxlcy9AYXJjZ2lzL2FyY2dpcy1yYXN0ZXItZnVuY3Rpb24tZWRpdG9yL2Rpc3QvZXNtL3JmeC1jdGUtZ2FtbWEtZWRpdG9yLWVkYzIwNTg4LmpzIiwid2VicGFjazovL2V4Yi1jbGllbnQvLi9leHRlbnNpb25zL3dpZGdldHMvYXJjZ2lzL2FuYWx5c2lzL25vZGVfbW9kdWxlcy9AYXJjZ2lzL2FyY2dpcy1yYXN0ZXItZnVuY3Rpb24tZWRpdG9yL2Rpc3QvZXNtL3JmeC1jdGUtZ2FtbWEtZWRpdG9yLmVudHJ5LmpzIiwid2VicGFjazovL2V4Yi1jbGllbnQvLi9leHRlbnNpb25zL3dpZGdldHMvYXJjZ2lzL2FuYWx5c2lzL25vZGVfbW9kdWxlcy9AYXJjZ2lzL2FyY2dpcy1yYXN0ZXItZnVuY3Rpb24tZWRpdG9yL2Rpc3QvZXNtL3Nhbml0aXplLW51bWJlci1kODQxMTRmNy5qcyIsIndlYnBhY2s6Ly9leGItY2xpZW50Ly4vZXh0ZW5zaW9ucy93aWRnZXRzL2FyY2dpcy9hbmFseXNpcy9ub2RlX21vZHVsZXMvQGFyY2dpcy9hcmNnaXMtcmFzdGVyLWZ1bmN0aW9uLWVkaXRvci9kaXN0L2VzbS90eXBlLWdhdXJkcy0xODQwNzQ3Zi5qcyIsIndlYnBhY2s6Ly9leGItY2xpZW50Ly4vZXh0ZW5zaW9ucy93aWRnZXRzL2FyY2dpcy9hbmFseXNpcy9ub2RlX21vZHVsZXMvQGFyY2dpcy9hcmNnaXMtcmFzdGVyLWZ1bmN0aW9uLWVkaXRvci9kaXN0L2VzbS91aS11dGlscy05MjhhNDA5Ni5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIExvY2FsZSBsaXN0IHJlZmVyZW5jZSBbSlNBUEldKGh0dHBzOi8vZGV2dG9waWEuZXNyaS5jb20vV2ViR0lTL2FyY2dpcy1qcy1hcGkvdHJlZS9tYXN0ZXIvZXNyaS9ubHMpXG4gKiBhbHNvIGhhcyBIaW5kaTogXCJoaVwiXG4gKi9cbmNvbnN0IFN1cHBvcnRlZExvY2FsZXMgPSB7XG4gICAgQXJhYmljOiBcImFyXCIsXG4gICAgQm9zbmlhbjogXCJic1wiLFxuICAgIEJ1bGdhcmlhbjogXCJiZ1wiLFxuICAgIENhdGFsYW46IFwiY2FcIixcbiAgICBDemVjaDogXCJjc1wiLFxuICAgIERhbmlzaDogXCJkYVwiLFxuICAgIEdlcm1hbjogXCJkZVwiLFxuICAgIEdyZWVrOiBcImVsXCIsXG4gICAgRW5nbGlzaDogXCJlblwiLFxuICAgIEVuZ2xpc2hVU0E6IFwiZW4tVVNcIixcbiAgICBTcGFuaXNoOiBcImVzXCIsXG4gICAgRXN0b25pYW46IFwiZXRcIixcbiAgICBGaW5uaXNoOiBcImZpXCIsXG4gICAgRnJlbmNoOiBcImZyXCIsXG4gICAgSGVicmV3OiBcImhlXCIsXG4gICAgSGluZGk6IFwiaGlcIixcbiAgICBDcm9hdGlhbjogXCJoclwiLFxuICAgIEh1bmdhcmlhbjogXCJodVwiLFxuICAgIEluZG9uZXNpYW46IFwiaWRcIixcbiAgICBJdGFsaWFuOiBcIml0XCIsXG4gICAgSmFwYW5lc2U6IFwiamFcIixcbiAgICBLb3JlYW46IFwia29cIixcbiAgICBMaXRodWFuaWFuOiBcImx0XCIsXG4gICAgTGF0dmlhbjogXCJsdlwiLFxuICAgIE5vcndlZ2lhbkJva21sOiBcIm5iXCIsXG4gICAgRHV0Y2g6IFwibmxcIixcbiAgICBQb2xpc2g6IFwicGxcIixcbiAgICBQb3J0dWd1ZXNlQnJhemlsOiBcInB0LUJSXCIsXG4gICAgUG9ydHVndWVzZVBvcnR1Z2FsOiBcInB0LVBUXCIsXG4gICAgUm9tYW5pYW46IFwicm9cIixcbiAgICBSdXNzaWFuOiBcInJ1XCIsXG4gICAgU2VyYmlhbjogXCJzclwiLFxuICAgIFNsb3ZlbmlhbjogXCJzbFwiLFxuICAgIFNsb3ZhazogXCJza1wiLFxuICAgIFN3ZWRpc2g6IFwic3ZcIixcbiAgICBUaGFpOiBcInRoXCIsXG4gICAgVHVya2lzaDogXCJ0clwiLFxuICAgIFVrcmFpbmlhbjogXCJ1a1wiLFxuICAgIFZpZXRuYW1lc2U6IFwidmlcIixcbiAgICBDaGluZXNlQ2hpbmE6IFwiemgtQ05cIixcbiAgICBDaGluZXNlSG9uZ0tvbmc6IFwiemgtSEtcIixcbiAgICBDaGluZXNlVGFpd2FuOiBcInpoLVRXXCJcbn07XG5jb25zdCBTdXBwb3J0ZWRPbmxpbmVIZWxwTG9jYWxlcyA9IFtcImFyXCIsIFwiZGVcIiwgXCJlc1wiLCBcImZyXCIsIFwiaXRcIiwgXCJqYVwiLCBcImtvXCIsIFwicnVcIiwgXCJwbFwiLCBcInB0LWJyXCIsIFwiemgtY25cIl07XG5jb25zdCBMb2NhbGVNYXAgPSB7XG4gICAgXCJlbi1BVVwiOiBcImVuXCIsXG4gICAgXCJlbi1DQVwiOiBcImVuXCIsXG4gICAgXCJlbi1HQlwiOiBcImVuXCIsXG4gICAgXCJlbi1VU1wiOiBcImVuXCIsXG4gICAgXCJlcy1FU1wiOiBcImVzXCIsXG4gICAgXCJlcy1NWFwiOiBcImVzXCIsXG4gICAgXCJkZS1DSFwiOiBcImRlXCIsXG4gICAgXCJkZS1BVFwiOiBcImRlXCIsXG4gICAgXCJkZS1ERVwiOiBcImRlXCIsXG4gICAgXCJmci1DSFwiOiBcImZyXCIsXG4gICAgXCJmci1GUlwiOiBcImZyXCIsXG4gICAgXCJpdC1DSFwiOiBcIml0XCIsXG4gICAgXCJpdC1JVFwiOiBcIml0XCIsXG4gICAgaW5kOiBcImlkXCIsXG4gICAgdWtyOiBcInVrXCJcbn07XG4vKipcbiAqIExpc3Qgb2Ygc3VwcG9ydGVkIGxvY2FsZXMgdGhhdCBhcmUgUlRMXG4gKiByZWZlcmVuY2U6IGh0dHBzOi8vZGV2dG9waWEuZXNyaS5jb20vV2ViR0lTL2FyY2dpcy1qcy1hcGkvYmxvYi80bWFzdGVyL2VzcmkvaW50bC9sb2NhbGUudHNcbiAqL1xuY29uc3QgUlRMTG9jYWxlcyA9IFtTdXBwb3J0ZWRMb2NhbGVzLkFyYWJpYywgU3VwcG9ydGVkTG9jYWxlcy5IZWJyZXddO1xuY29uc3QgRGVmYXVsdExvY2FsZSA9IFN1cHBvcnRlZExvY2FsZXMuRW5nbGlzaDtcbi8qKlxuICogVXRpbGl0eSB0byBjZW50cmFsaXplIGxvZ2ljLCBhbmQgcmV0dXJuIFwicnRsXCIgb3IgXCJydGxcIiBkZXBlbmRpbmcgb24gcnRsIGJvb2xlYW5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gcnRsIHdoZXRoZXIgbG9jYWxlIGlzIGluIFJpZ2h0IHRvIExlZnQgZGlyZWN0aW9uXG4gKiBAcmV0dXJucyB7XCJsdHJcIiB8IFwicnRsXCJ9IGNvZGVzIHRoYXQgY2FuIGJlIHBhc3NlZCB0byBcImRpclwiIHByb3Agb2YgYSBjb21wb25lbnQuXG4gKi9cbmZ1bmN0aW9uIGdldERpcmVjdGlvbkJhc2VkT25SVEwocnRsKSB7XG4gICAgcmV0dXJuIHJ0bCA9PT0gdHJ1ZSA/IFwicnRsXCIgOiBcImx0clwiO1xufVxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdG8gZmluZCB0aGUgY2xvc2VzdCBlbGVtZW50IGNyb3NzaW5nIG11bHRpcGxlIChwYXJlbnQpIHNoYWRvd0RPTSBib3VuZGFyaWVzLlxuICogVGhlIGltcGxlbWVudGF0aW9uIGlzIGJhc2VkIG9uIFt0aGlzXShodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy81NDUyMDU1NC9jdXN0b20tZWxlbWVudC1nZXRyb290bm9kZS1jbG9zZXN0LWZ1bmN0aW9uLWNyb3NzaW5nLW11bHRpcGxlLXBhcmVudC1zaGFkb3dkKSBzb2x1dGlvbi5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc2VsZWN0b3JcbiAqIEBwYXJhbSB7RWxlbWVudH0gYmFzZVxuICovXG5mdW5jdGlvbiBnZXRDbG9zZXN0RWxlbWVudChzZWxlY3RvciwgYmFzZSkge1xuICAgIGZ1bmN0aW9uIGNsb3Nlc3RGcm9tKGVsKSB7XG4gICAgICAgIGxldCBlbGVtZW50O1xuICAgICAgICBpZiAoZWwgPT09IHVuZGVmaW5lZCB8fCBlbCA9PT0gZG9jdW1lbnQgfHwgZWwgPT09IHdpbmRvdylcbiAgICAgICAgICAgIGVsZW1lbnQgPSBudWxsO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGZvdW5kID0gZWwuY2xvc2VzdChzZWxlY3Rvcik7XG4gICAgICAgICAgICBlbGVtZW50ID0gZm91bmQgfHwgY2xvc2VzdEZyb20oZWwuZ2V0Um9vdE5vZGUoKS5ob3N0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZWxlbWVudDtcbiAgICB9XG4gICAgcmV0dXJuIGNsb3Nlc3RGcm9tKGJhc2UpO1xufVxuLyoqXG4gKiBDb252ZXJ0cyB0aGUgZ2l2ZW4gbG9jYWxlIHRvIGEgc3VwcG9ydGVkIGxvY2FsZSB1c2luZyB0aGUgcHJvdmlkZWQgbG9jYWxlIG1hcC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZyB8IHVuZGVmaW5lZH0gbG9jYWxlIC0gVGhlIGxvY2FsZSB0byBiZSBjb252ZXJ0ZWQuXG4gKiBAcGFyYW0ge29iamVjdH0gbG9jYWxlTWFwIC0gQSBtYXAgb2YgbG9jYWxlcyB0byBzdXBwb3J0ZWQgbG9jYWxlcy5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IC0gVGhlIHN1cHBvcnRlZCBsb2NhbGUuXG4gKi9cbmZ1bmN0aW9uIGNvbnZlcnRUb1N1cHBvcnRlZExvY2FsZShsb2NhbGUsIGxvY2FsZU1hcCkge1xuICAgIGNvbnN0IGRlZmF1bHRMb2NhbGUgPSBEZWZhdWx0TG9jYWxlO1xuICAgIGxldCBsb2NhbGVTYW5pdGl6ZWQgPSBsb2NhbGU/LnRvTG93ZXJDYXNlKCk7XG4gICAgaWYgKGxvY2FsZVNhbml0aXplZCAhPT0gdW5kZWZpbmVkICYmIGxvY2FsZVNhbml0aXplZC5pbmRleE9mKFwiLVwiKSAhPT0gLTEpIHtcbiAgICAgICAgY29uc3QgW2xhbmcsIHJlZ2lvbl0gPSBsb2NhbGVTYW5pdGl6ZWQuc3BsaXQoXCItXCIpO1xuICAgICAgICBsb2NhbGVTYW5pdGl6ZWQgPSBgJHtsYW5nfS0ke3JlZ2lvbi50b1VwcGVyQ2FzZSgpfWA7XG4gICAgfVxuICAgIGlmICghbG9jYWxlU2FuaXRpemVkKSB7XG4gICAgICAgIHJldHVybiBkZWZhdWx0TG9jYWxlO1xuICAgIH1cbiAgICBjb25zdCBsb2NhbGVNYXBLZXlzID0gT2JqZWN0LmtleXMoTG9jYWxlTWFwKTtcbiAgICBpZiAobG9jYWxlTWFwS2V5cy5pbmNsdWRlcyhsb2NhbGVTYW5pdGl6ZWQpID09PSB0cnVlKSB7XG4gICAgICAgIHJldHVybiBsb2NhbGVNYXBbbG9jYWxlU2FuaXRpemVkXTtcbiAgICB9XG4gICAgcmV0dXJuIGxvY2FsZVNhbml0aXplZDtcbn1cbi8qKlxuICogUmV0cmlldmVzIGxvY2FsZSBpbmZvcm1hdGlvbjsgSW4gdGhlIGNhc2Ugb2YgUmVnaW9uYWwgY29kZXMgKGVuLWF1KSBpdCBpcyBjb252ZXJ0ZWQgdG8gYSBzdXBwb3J0ZWQgbG9jYWxlIChlbikuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBbZWxlbWVudD1kb2N1bWVudC5kb2N1bWVudEVsZW1lbnRdIC0gVGhlIGVsZW1lbnQgdG8gc2VhcmNoIGZvciBsb2NhbGUgaW5mb3JtYXRpb24uXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBBbiBvYmplY3QgY29udGFpbmluZyB0aGUgbG9jYWxlIGluZm9ybWF0aW9uLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IGxvY2FsZSAtIFRoZSBsb2NhbGUgY29kZS5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gcnRsIC0gQSBmbGFnIGluZGljYXRpbmcgd2hldGhlciB0aGUgbG9jYWxlIGlzIHJpZ2h0LXRvLWxlZnQuXG4gKi9cbmZ1bmN0aW9uIGdldExvY2FsZUluZm8oZWxlbWVudCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkge1xuICAgIC8vIEdldHMgdGhlIGNsb3Nlc3QgZWxlbWVudCB3aXRoIGEgbGFuZyBhdHRyaWJ1dGUgYW5kIGZhbGxzIGJhY2sgdG8gbmF2aWdhdG9yLmxhbmd1YWdlIGlmIG5vdCBmb3VuZFxuICAgIGNvbnN0IGNsb3Nlc3RFbGVtZW50ID0gZ2V0Q2xvc2VzdEVsZW1lbnQoXCJbbGFuZ11cIiwgZWxlbWVudCk7XG4gICAgY29uc3QgbG9jYWxlID0gY2xvc2VzdEVsZW1lbnQ/LmxhbmcgPz8gd2luZG93Lm5hdmlnYXRvci5sYW5ndWFnZTtcbiAgICBjb25zdCBzdXBwb3J0ZWRMb2NhbGVzID0gT2JqZWN0LnZhbHVlcyhTdXBwb3J0ZWRMb2NhbGVzKTtcbiAgICBjb25zdCBkZWZhdWx0TG9jYWxlID0gRGVmYXVsdExvY2FsZTtcbiAgICBjb25zdCBjb252ZXJ0ZWRMb2NhbGUgPSBjb252ZXJ0VG9TdXBwb3J0ZWRMb2NhbGUobG9jYWxlLCBMb2NhbGVNYXApO1xuICAgIGNvbnN0IGlzU3VwcG9ydGVkTG9jYWxlID0gc3VwcG9ydGVkTG9jYWxlcy5pbmNsdWRlcyhjb252ZXJ0ZWRMb2NhbGUpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGxvY2FsZTogaXNTdXBwb3J0ZWRMb2NhbGUgPyBjb252ZXJ0ZWRMb2NhbGUgOiBkZWZhdWx0TG9jYWxlLFxuICAgICAgICBydGw6IFJUTExvY2FsZXMuaW5jbHVkZXMobG9jYWxlKVxuICAgIH07XG59XG4vKipcbiAqIEZldGNoZXMgdGhlIGxvY2FsZSBmaWxlIG9mIHRoZSBnaXZlbiBjb21wb25lbnQ7IGRlZmF1bHRzIHRvIGBcImVuXCJgIGxvY2FsZVxuICogQHBhcmFtIGNvbXBvbmVudE5hbWVcbiAqIEBwYXJhbSBwcm9wc1xuICogQHBhcmFtIGxvY2FsZVxuICogQHBhcmFtIHJlc291cmNlc1VybFxuICogQHBhcmFtIHByb3BzLnBhdGhcbiAqIEBwYXJhbSBwcm9wcy5sb2NhbGVcbiAqIEBwYXJhbSBwcm9wcy5iYXNlVVJMXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGZldGNoTG9jYWxlU3RyaW5ncyhwcm9wcykge1xuICAgIGNvbnN0IHsgcGF0aCwgbG9jYWxlLCBiYXNlVVJMIH0gPSBwcm9wcztcbiAgICAvLyBVc2luZyB0aGUgZ2V0UHVibGljUGF0aCBtZXRob2QgdGhhdCBsZXZlcmFnZXMgYGRhdGEtcmVzb3VyY2VzLXVybGAgY3VycmVudGx5IHRoaXMgaXMgbm90IHdvcmtpbmcuXG4gICAgLy8gY29uc3QgclVybCA9IGdldFB1YmxpY1BhdGgoY29tcG9uZW50TmFtZSkgfHwgcmVzb3VyY2VzVXJsO1xuICAgIGxldCBsb2NhbGVEYXRhID0ge307XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHtiYXNlVVJMfXQ5bi8ke3BhdGh9LnQ5bi4ke2xvY2FsZX0uanNvbmApO1xuICAgICAgICBsb2NhbGVEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICBjb25zdCBkZWZhdWx0UmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHtiYXNlVVJMfXQ5bi8ke3BhdGh9LnQ5bi4ke0RlZmF1bHRMb2NhbGV9Lmpzb25gKTtcbiAgICAgICAgbG9jYWxlRGF0YSA9IGF3YWl0IGRlZmF1bHRSZXNwb25zZS5qc29uKCk7XG4gICAgfVxuICAgIHJldHVybiBsb2NhbGVEYXRhO1xufVxuYXN5bmMgZnVuY3Rpb24gZmV0Y2hDb21wb25lbnRMb2NhbGVTdHJpbmdzKGVsZW1lbnQsIGJhc2VVUkwpIHtcbiAgICBjb25zdCBjb21wb25lbnROYW1lID0gZWxlbWVudC50YWdOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgY29uc3QgeyBsb2NhbGUsIHJ0bCB9ID0gZ2V0TG9jYWxlSW5mbyhlbGVtZW50KTtcbiAgICBjb25zdCBzdHJpbmdzID0gYXdhaXQgZmV0Y2hMb2NhbGVTdHJpbmdzKHsgcGF0aDogY29tcG9uZW50TmFtZSwgbG9jYWxlLCBiYXNlVVJMIH0pO1xuICAgIHJldHVybiB7IHN0cmluZ3MsIGRpcjogZ2V0RGlyZWN0aW9uQmFzZWRPblJUTChydGwpLCBsb2NhbGU6IGxvY2FsZSB9O1xufVxuLyoqXG4gKiBGb3JtYXRzIGEgVVJMIHRvIGxpbmsgdG9cbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgdGhlIHVybCBzdHJpbmcgZnJvbSBhZnRlciB0aGUgbG9jYWxlXG4gKiBAcGFyYW0ge3N0cmluZ30gYmFzZVBhdGggdGhlIGJhc2UgcGF0aCBmcm9tIHRoZSBzaWduZWQgaW4gcG9ydGFsIG9iamVjdC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBsb2NhbGUgdGhlIGxvY2FsZSBhYmJyZXZpYXRpb24gZm9yIHRoZSBicm93c2VyLlxuICogQHJldHVybnMge3N0cmluZ30gdGhlIGZvcm1hdHRlZCB1cmwuXG4gKi9cbmZ1bmN0aW9uIGZvcm1hdExvY2FsaXplZEhlbHBVcmwodXJsLCBiYXNlUGF0aCwgbG9jYWxlID0gXCJlblwiKSB7XG4gICAgbGV0IGxvY2FsZVNhbml0aXplZCA9IGxvY2FsZTtcbiAgICBjb25zdCBsb2NhbGVNYXBLZXlzID0gT2JqZWN0LmtleXMoTG9jYWxlTWFwKTtcbiAgICBpZiAobG9jYWxlTWFwS2V5cy5pbmNsdWRlcyhsb2NhbGUpID09PSB0cnVlKSB7XG4gICAgICAgIGxvY2FsZVNhbml0aXplZCA9IExvY2FsZU1hcFtsb2NhbGVdO1xuICAgIH1cbiAgICBjb25zdCBsb2NhbGVJbkxvd2VyQ2FzZSA9IGxvY2FsZVNhbml0aXplZC50b0xvY2FsZUxvd2VyQ2FzZSgpO1xuICAgIGlmIChTdXBwb3J0ZWRPbmxpbmVIZWxwTG9jYWxlcy5pbmNsdWRlcyhsb2NhbGVJbkxvd2VyQ2FzZSkgPT09IHRydWUpIHtcbiAgICAgICAgLy8gZm9sbG93aW5nIHJlZ2V4IHRlc3RzIC9lbi8gaXMgcHJlc2VudCBpbiB1cmwgYW5kIHJlcGxhY2VzIGl0IHdpdGggdGhlIGxvY2FsZVxuICAgICAgICAvLyBodHRwczovL2RvY2Rldi5hcmNnaXMuY29tL2VuL2FyY2dpcy1vbmxpbmUvYW5hbHl6ZS9hZ2dyZWdhdGUtcG9pbnRzLW12Lmh0bVxuICAgICAgICAvLyBzZWxmIFJlc3BvbnNlIG9ubHkgcHJvdmlkZXMgd2l0aCBgZW5gIGxvY2FsZSBub3QgYXMgcGVyIHRoZSB1c2VyIGxvY2FsZSBvciBjdXJyZW50IGFwcCBsb2NhbGVcbiAgICAgICAgLy8gc28gd2UgbmVlZCB0aGlzIHJlcGxhY2UgY2FsbC5cbiAgICAgICAgYmFzZVBhdGggPSBiYXNlUGF0aC5yZXBsYWNlKC9eaHR0cHM/OlxcL1xcL1teL10rXFwvZW4vLCAobWF0Y2gpID0+IG1hdGNoLnJlcGxhY2UoXCJlblwiLCBsb2NhbGVJbkxvd2VyQ2FzZSkpO1xuICAgIH1cbiAgICBjb25zdCBsZWFybk1vcmVVcmwgPSBgJHtiYXNlUGF0aH1hbmFseXplLyR7dXJsfWA7XG4gICAgcmV0dXJuIGxlYXJuTW9yZVVybDtcbn1cblxuZXhwb3J0IHsgRGVmYXVsdExvY2FsZSBhcyBELCBTdXBwb3J0ZWRMb2NhbGVzIGFzIFMsIGdldERpcmVjdGlvbkJhc2VkT25SVEwgYXMgYSwgZmV0Y2hDb21wb25lbnRMb2NhbGVTdHJpbmdzIGFzIGIsIGZvcm1hdExvY2FsaXplZEhlbHBVcmwgYXMgZiwgZ2V0TG9jYWxlSW5mbyBhcyBnIH07XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxvY2FsaXphdGlvbi1oZWxwZXItNDgxOWI2N2QuanMubWFwIiwiaW1wb3J0IHsgciBhcyByZWdpc3Rlckluc3RhbmNlLCBjIGFzIGNyZWF0ZUV2ZW50LCBnIGFzIGdldEFzc2V0UGF0aCwgaCwgYSBhcyBnZXRFbGVtZW50IH0gZnJvbSAnLi9pbmRleC1kYTFiNzEzOC5qcyc7XG5pbXBvcnQgeyBiIGFzIGZldGNoQ29tcG9uZW50TG9jYWxlU3RyaW5ncyB9IGZyb20gJy4vbG9jYWxpemF0aW9uLWhlbHBlci00ODE5YjY3ZC5qcyc7XG5pbXBvcnQgJ0BhcmNnaXMvY29yZS9jb3JlL2xhbmcuanMnO1xuaW1wb3J0IHsgaSBhcyBpc0VtcHR5RGF0YUl0ZW0gfSBmcm9tICcuL3R5cGUtZ2F1cmRzLTE4NDA3NDdmLmpzJztcbmltcG9ydCB7IFUgYXMgVUlEZWZhdWx0cyB9IGZyb20gJy4vdWktdXRpbHMtOTI4YTQwOTYuanMnO1xuaW1wb3J0ICdAYXJjZ2lzL2NvcmUvaWRlbnRpdHkvSWRlbnRpdHlNYW5hZ2VyLmpzJztcbmltcG9ydCAnQGFyY2dpcy9jb3JlL2NvcmUvdXJsVXRpbHMuanMnO1xuaW1wb3J0ICdAYXJjZ2lzL2NvcmUvbGF5ZXJzL0xheWVyLmpzJztcbmltcG9ydCAnQGFyY2dpcy9jb3JlL2xheWVycy9JbWFnZXJ5TGF5ZXIuanMnO1xuaW1wb3J0ICdAYXJjZ2lzL2NvcmUvc21hcnRNYXBwaW5nL3Jhc3Rlci9yZW5kZXJlcnMvc3RyZXRjaC5qcyc7XG5pbXBvcnQgJ0BhcmNnaXMvY29yZS9yZXF1ZXN0LmpzJztcbmltcG9ydCAnQGFyY2dpcy9jb3JlL3Jlc3Qvc3VwcG9ydC9BbGdvcml0aG1pY0NvbG9yUmFtcC5qcyc7XG5pbXBvcnQgJ0BhcmNnaXMvY29yZS9yZXN0L3N1cHBvcnQvTXVsdGlwYXJ0Q29sb3JSYW1wLmpzJztcbmltcG9ydCAnQGFyY2dpcy9jb3JlL0NvbG9yLmpzJztcbmltcG9ydCAnLi9jb2xvclJhbXBVdGlscy04YmRkNDZjNS5qcyc7XG5pbXBvcnQgeyBmIGFzIGZvcm1hdE51bWJlciB9IGZyb20gJy4vc2FuaXRpemUtbnVtYmVyLWQ4NDExNGY3LmpzJztcbmltcG9ydCAnQGFyY2dpcy9jb3JlL3Jlc3QvZ2VvcHJvY2Vzc29yLmpzJztcbmltcG9ydCAnQGFyY2dpcy9jb3JlL3BvcnRhbC9Qb3J0YWxJdGVtLmpzJztcblxuLy8gUG9ydGVkIGZyb20gXCJlc3JpL2xheWVycy9zdXBwb3J0L3Jhc3RlckZ1bmN0aW9ucy9zdHJldGNoVXRpbHMudHNcIlxuLy8gaHR0cHM6Ly9kZXZ0b3BpYS5lc3JpLmNvbS9XZWJHSVMvYXJjZ2lzLWpzLWFwaS9ibG9iLzRtYXN0ZXIvZXNyaS9sYXllcnMvc3VwcG9ydC9yYXN0ZXJGdW5jdGlvbnMvc3RyZXRjaFV0aWxzLnRzI0wyNDVcbmNvbnN0IERFRkFVTFRfTk9PUF9HQU1NQSA9IDEuMDtcbmNvbnN0IFJHQjJMVU1BX1dUID0gWzAuMjk5LCAwLjU4NywgMC4xMTRdO1xuZnVuY3Rpb24gY29tcHV0ZUdhbW1hVmFsdWUobWVhbkx1bWFVOEIpIHtcbiAgICBpZiAobWVhbkx1bWFVOEIgPD0gMCB8fCBtZWFuTHVtYVU4QiA+PSAyNTUpIHtcbiAgICAgICAgcmV0dXJuIERFRkFVTFRfTk9PUF9HQU1NQTtcbiAgICB9XG4gICAgbGV0IG9mZnNldCA9IDA7XG4gICAgaWYgKG1lYW5MdW1hVThCICE9PSAxNTApIHtcbiAgICAgICAgb2Zmc2V0ID0gbWVhbkx1bWFVOEIgPD0gMTUwID8gNDUuMCAqIE1hdGguY29zKDAuMDEwNDcgKiBtZWFuTHVtYVU4QikgOiAxNy4wICogTWF0aC5zaW4oMC4wMjEgKiBtZWFuTHVtYVU4Qik7XG4gICAgfVxuICAgIGNvbnN0IG1heEx1bWEgPSAyNTUuMDtcbiAgICBjb25zdCB0YXJnZXRNZWFuTHVtYSA9IG1lYW5MdW1hVThCICsgb2Zmc2V0O1xuICAgIGNvbnN0IG9tciA9IE1hdGgubG9nKG1lYW5MdW1hVThCIC8gbWF4THVtYSk7XG4gICAgY29uc3QgdG1yID0gTWF0aC5sb2codGFyZ2V0TWVhbkx1bWEgLyBtYXhMdW1hKTtcbiAgICBpZiAodG1yID09PSAwKSB7XG4gICAgICAgIHJldHVybiBERUZBVUxUX05PT1BfR0FNTUE7XG4gICAgfVxuICAgIGNvbnN0IGdhbW1hID0gb21yIC8gdG1yO1xuICAgIGlmIChpc05hTihnYW1tYSkpIHtcbiAgICAgICAgcmV0dXJuIERFRkFVTFRfTk9PUF9HQU1NQTtcbiAgICB9XG4gICAgLy8gbm90ZXMgZnJvbSBQcm86IHdlIHdhbnQgdG8gZm9yY2UgaXQgdG8gYmUgaW4gKDAsMTApIHJhbmdlLCBleHBlcmllbmNlZCBiYXNlZCBvbiBleHBlcmltZW50IGluIDEwLjEgbG9vayBnb29kIHByb2plY3RcbiAgICByZXR1cm4gTWF0aC5taW4oOS45LCBNYXRoLm1heCgwLjAxLCBnYW1tYSkpO1xufVxuZnVuY3Rpb24gY29tcHV0ZUdhbW1hVmFsdWVzKHBpeGVsVHlwZSwgc3RhdGlzdGljcywgYXBwbHlSR0JXZWlnaHRzKSB7XG4gICAgLy8gcG9ydGVkIGZyb20gMy54IGh0dHBzOi8vZGV2dG9waWEuZXNyaS5jb20vV2ViR0lTL2FyY2dpcy1qcy1hcGkvYmxvYi9tYXN0ZXIvZXNyaS9sYXllcnMvcGl4ZWxGaWx0ZXJzL1N0cmV0Y2hGaWx0ZXIuanMjTDU0MlxuICAgIC8vIHdoaWNoIHdhcyBiYXNlZCBvbiB0aGUgZmFzdCBhcHByb3ggbWV0aG9kIGluIFBybyBTdHJldGNoLmNwcFxuICAgIGNvbnN0IGdhbW1hcyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RhdGlzdGljcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgbWluID0gMCwgbWF4ID0gMCwgYXZnID0gMDtcbiAgICAgICAgaWYgKFwibWluXCIgaW4gc3RhdGlzdGljc1tpXSkge1xuICAgICAgICAgICAgKHsgbWluLCBtYXgsIGF2ZyB9ID0gc3RhdGlzdGljc1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBbbWluLCBtYXgsIGF2Z10gPSBzdGF0aXN0aWNzW2ldO1xuICAgICAgICB9XG4gICAgICAgIGxldCBtZWFuID0gYXZnO1xuICAgICAgICBpZiAocGl4ZWxUeXBlICE9PSBcInU4XCIpIHtcbiAgICAgICAgICAgIG1lYW4gPSAoMjU1ICogKG1lYW4gLSBtaW4pKSAvIChtYXggLSBtaW4pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhcHBseVJHQldlaWdodHMpIHtcbiAgICAgICAgICAgIG1lYW4gPSBtZWFuICogUkdCMkxVTUFfV1RbaV07XG4gICAgICAgIH1cbiAgICAgICAgZ2FtbWFzLnB1c2goY29tcHV0ZUdhbW1hVmFsdWUobWVhbikpO1xuICAgIH1cbiAgICByZXR1cm4gZ2FtbWFzO1xufVxuZnVuY3Rpb24gY29tcHV0ZUdhbW1hKGxheWVyKSB7XG4gICAgY29uc3QgbGF5ZXJSYXN0ZXJJbmZvID0gbGF5ZXIucmFzdGVySW5mbztcbiAgICBjb25zdCByYXN0ZXJTdGF0aXN0aWNzID0gbGF5ZXJSYXN0ZXJJbmZvPy5zdGF0aXN0aWNzO1xuICAgIGNvbnN0IHBpeGVsVHlwZSA9IGxheWVyUmFzdGVySW5mbz8ucGl4ZWxUeXBlO1xuICAgIGlmIChyYXN0ZXJTdGF0aXN0aWNzPy5sZW5ndGggPT09IDAgfHwgIXBpeGVsVHlwZSkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBjb25zdCBnYW1tYSA9IGNvbXB1dGVHYW1tYVZhbHVlcyhwaXhlbFR5cGUsIHJhc3RlclN0YXRpc3RpY3MpO1xuICAgIHJldHVybiBnYW1tYTtcbn1cblxuY29uc3QgSGVscENsaWNrSGFuZGxlcktleXMgPSB7XG4gICAgaW5wdXRBcmdIZWxwQ2xpY2tIYW5kbGVyOiBcImlucHV0QXJnSGVscENsaWNrSGFuZGxlclwiXG59O1xuXG5jb25zdCBSZnhHYW1tYUVkaXRvciA9IGNsYXNzIHtcbiAgICBjb25zdHJ1Y3Rvcihob3N0UmVmKSB7XG4gICAgICAgIHJlZ2lzdGVySW5zdGFuY2UodGhpcywgaG9zdFJlZik7XG4gICAgICAgIHRoaXMucmZ4QXJndW1lbnRDaGFuZ2UgPSBjcmVhdGVFdmVudCh0aGlzLCBcInJmeEFyZ3VtZW50Q2hhbmdlXCIsIDcpO1xuICAgICAgICAvKipcbiAgICAgICAgICogZGVmYXVsdE1pbiB2YWx1ZSBmb3IgYSBnYW1tYSBzbGlkZXIgd2lkZ2V0XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmRlZmF1bHRNaW4gPSAtMTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGRlZmF1bHRNYXggdmFsdWUgZm9yIGEgZ2FtbWEgc2xpZGVyIHdpZGdldFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kZWZhdWx0TWF4ID0gMTA7XG4gICAgICAgIHRoaXMuYmFuZENvdW50ID0gMTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGRlZmF1bHRWYWx1ZSBmb3IgYSBnYW1tYSBzbGlkZXIgd2lkZ2V0XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmRlZmF1bHRWYWx1ZSA9IDE7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTdG9yZXMgZXZlbnQgaGFuZGxlcnMgZm9yIGhlbHAgYWN0aW9uIGNsaWNrLCBzdG9yZWQgaW4gY29ubmVjdGVkIGNhbGxiYWNrIHRvIGF2b2lkXG4gICAgICAgICAqIGZldGNoaW5nIGZ1bmN0aW9uIG9uIGVhY2ggcmVuZGVyICggdG8gYXZvaWQgY29tbW9uIGJhZCBwcmFjdGljZSApXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmhlbHBBY3Rpb25DbGlja0V2ZW50SGFuZGxlcnMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuaGFuZGxlU2xpZGVyQ2hhbmdlID0gKGUsIGJhbmRJbmRleCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZWxlbWVudCA9IGUudGFyZ2V0O1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBlbGVtZW50LnZhbHVlO1xuICAgICAgICAgICAgdGhpcy52YWx1ZVtiYW5kSW5kZXhdID0gdmFsdWU7XG4gICAgICAgICAgICB0aGlzLnJmeEFyZ3VtZW50Q2hhbmdlLmVtaXQoeyB2YWx1ZTogdGhpcy52YWx1ZSB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy53aWRnZXRBcmdzID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy9cbiAgICAvLyAgTGlmZWN5Y2xlXG4gICAgLy9cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgICAgIHRoaXMucHJvY2Vzc1dpZGdldEFyZ3MoKTtcbiAgICB9XG4gICAgYXN5bmMgY29tcG9uZW50V2lsbExvYWQoKSB7XG4gICAgICAgICh7IHN0cmluZ3M6IHRoaXMuc3RyaW5ncywgZGlyOiB0aGlzLmRpcmVjdGlvbiB9ID0gYXdhaXQgZmV0Y2hDb21wb25lbnRMb2NhbGVTdHJpbmdzKHRoaXMuaG9zdEVsZW1lbnQsIGdldEFzc2V0UGF0aChgLmApKSk7XG4gICAgICAgIHRoaXMuc2V0SW5pdGlhbFN0YXRlKCk7XG4gICAgfVxuICAgIGNvbXBvbmVudERpZExvYWQoKSB7XG4gICAgICAgIHRoaXMuYXR0YWNoSGVscENsaWNrRXZlbnRIYW5kbGVycygpO1xuICAgIH1cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy9cbiAgICAvLyAgUHJpdmF0ZSBNZXRob2RzXG4gICAgLy9cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLyoqXG4gICAgICogQWxsIHZhbGlkYXRpb24gbG9naWMgb2Ygd2lkZ2V0QXJncyAtPiBtYWlubHkgdGhlIGlucHV0QXJncyBhbmQgdHJpZ2dlckF0dHJpYnV0ZXNcbiAgICAgKiBnb2VzIGhlcmVcbiAgICAgKi9cbiAgICBwcm9jZXNzV2lkZ2V0QXJncygpIHtcbiAgICAgICAgLy8gc2hvdWxkIGhhdmUgb25seSBvbmUgaW5wdXRBcmdcbiAgICAgICAgT2JqZWN0LmtleXModGhpcy53aWRnZXRBcmdzLmlucHV0QXJncykuZm9yRWFjaCgoX2lucHV0QXJnKSA9PiB7XG4gICAgICAgICAgICBjb25zdCByZnhBcmcgPSB0aGlzLndpZGdldEFyZ3MuaW5wdXRBcmdzW19pbnB1dEFyZ107XG4gICAgICAgICAgICB0aGlzLmlucHV0QXJnID0gcmZ4QXJnO1xuICAgICAgICAgICAgcmZ4QXJnLmlucHV0ID0gdGhpcy5ob3N0RWxlbWVudDtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHsgdHJpZ2dlckFyZ3MgfSA9IHRoaXMud2lkZ2V0QXJncztcbiAgICAgICAgY29uc3QgcmFzdGVyUmZ4QXJnID0gdHJpZ2dlckFyZ3M/LlJhc3RlcjtcbiAgICAgICAgaWYgKHR5cGVvZiByYXN0ZXJSZnhBcmcgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJJbnZhbGlkIFNjaGVtYTogUmFzdGVyIGlzIG5vdCBwYXNzZWQgaW4gVHJpZ2dlckFyZ3NcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yYXN0ZXJBcmcgPSByYXN0ZXJSZnhBcmc7XG4gICAgICAgIHJhc3RlclJmeEFyZz8uaW5wdXQ/LmFkZEV2ZW50TGlzdGVuZXIoXCJyZnhBcmd1bWVudENoYW5nZVwiLCAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZVJhc3RlckNoYW5nZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgc2V0SW5pdGlhbFN0YXRlKCkge1xuICAgICAgICBjb25zdCByZnhBcmdWYWx1ZSA9IHRoaXMuaW5wdXRBcmcudmFsdWU7XG4gICAgICAgIC8vIGlmIHJmeEFyZ1ZhbHVlIGlzIHNldCwgdXNlIHRoYXQgYXMgd2lkZ2V0IHZhbHVlXG4gICAgICAgIGlmIChpc0VtcHR5RGF0YUl0ZW0ocmZ4QXJnVmFsdWUpICE9PSB0cnVlKSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gcmZ4QXJnVmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmFzdGVySW5wdXQgPSB0aGlzLnJhc3RlckFyZz8uaW5wdXQ7XG4gICAgICAgIC8vIGlmIG5vIHJhc3RlcklucHV0IGlzIHNldCwgdXNlIFtdIGFzIHdpZGdldCB2YWx1ZVxuICAgICAgICBpZiAoaXNFbXB0eURhdGFJdGVtKHJhc3RlcklucHV0Py52YWx1ZSkpIHtcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSBbXTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsYXllciA9IGF3YWl0IHJhc3RlcklucHV0Py5nZXRTZWxlY3RlZExheWVyPy4oKTtcbiAgICAgICAgY29uc3QgcmFzdGVySW5mbyA9IGxheWVyPy5yYXN0ZXJJbmZvO1xuICAgICAgICB0aGlzLmJhbmRDb3VudCA9IHJhc3RlckluZm8/LmJhbmRDb3VudDtcbiAgICAgICAgdGhpcy52YWx1ZSA9IGNvbXB1dGVHYW1tYShsYXllcik7XG4gICAgfVxuICAgIGF0dGFjaEhlbHBDbGlja0V2ZW50SGFuZGxlcnMoKSB7XG4gICAgICAgIGNvbnN0IGlucHV0QXJnSGVscENsaWNrSGFuZGxlciA9IHRoaXMud2lkZ2V0QXJncy5vbkhlbHBBY3Rpb25DbGljayh7XG4gICAgICAgICAgICBoZWFkaW5nOiB0aGlzLmlucHV0QXJnLmRpc3BsYXlOYW1lLFxuICAgICAgICAgICAgcmVmZXJlbmNlRWxlbWVudDogdGhpcy53aWRnZXRDb250YWluZXIsXG4gICAgICAgICAgICBoZWxwVGV4dElEOiB0aGlzLmlucHV0QXJnPy5oZWxwVGV4dElEXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmhlbHBBY3Rpb25DbGlja0V2ZW50SGFuZGxlcnMuc2V0KEhlbHBDbGlja0hhbmRsZXJLZXlzLmlucHV0QXJnSGVscENsaWNrSGFuZGxlciwgaW5wdXRBcmdIZWxwQ2xpY2tIYW5kbGVyKTtcbiAgICB9XG4gICAgYXN5bmMgaGFuZGxlUmFzdGVyQ2hhbmdlKCkge1xuICAgICAgICBjb25zdCByYXN0ZXJJbnB1dCA9IHRoaXMucmFzdGVyQXJnPy5pbnB1dDtcbiAgICAgICAgY29uc3QgbGF5ZXIgPSBhd2FpdCByYXN0ZXJJbnB1dD8uZ2V0U2VsZWN0ZWRMYXllcj8uKCk7XG4gICAgICAgIGNvbnN0IHJhc3RlckluZm8gPSBsYXllcj8ucmFzdGVySW5mbztcbiAgICAgICAgdGhpcy5iYW5kQ291bnQgPSByYXN0ZXJJbmZvLmJhbmRDb3VudDtcbiAgICAgICAgdGhpcy52YWx1ZSA9IGNvbXB1dGVHYW1tYShsYXllcik7XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgY29uc3QgYmFuZENvdW50ID0gdGhpcy5iYW5kQ291bnQ7XG4gICAgICAgIGNvbnN0IGdhbW1hVmFsdWVzID0gdGhpcy52YWx1ZTtcbiAgICAgICAgcmV0dXJuIChoKFwiZGl2XCIsIG51bGwsIGgoXCJjYWxjaXRlLWxhYmVsXCIsIHsgYWxpZ25tZW50OiBcInN0YXJ0XCIsIHNjYWxlOiBVSURlZmF1bHRzLlNjYWxlLCBsYXlvdXQ6IFwiZGVmYXVsdFwiLCByZWY6IChlKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy53aWRnZXRDb250YWluZXIgPSBlO1xuICAgICAgICAgICAgfSB9LCBoKFwicmZ4LWxhYmVsXCIsIHsgbGFiZWw6IHRoaXMuaW5wdXRBcmcuZGlzcGxheU5hbWUsIG9uUmZ4TGFiZWxIZWxwQWN0aW9uQ2xpY2s6ICgpID0+IHRoaXMuaGVscEFjdGlvbkNsaWNrRXZlbnRIYW5kbGVycz8uZ2V0KEhlbHBDbGlja0hhbmRsZXJLZXlzLmlucHV0QXJnSGVscENsaWNrSGFuZGxlcikoKSB9KSwgQXJyYXkuZnJvbSh7IGxlbmd0aDogYmFuZENvdW50IH0pLm1hcCgoXywgYmFuZEluZGV4KSA9PiAoaChcInJmeC1kdGV4LWFyZy1zbGlkZXJcIiwgeyBtaW46IHRoaXMuZGVmYXVsdE1pbiwgbWF4OiB0aGlzLmRlZmF1bHRNYXgsIHZhbHVlOiBmb3JtYXROdW1iZXIoZ2FtbWFWYWx1ZXM/LltiYW5kSW5kZXhdID8/IHRoaXMuZGVmYXVsdFZhbHVlLCAzKSwgc3RlcDogMC4wMSwgb25SZnhBcmd1bWVudENoYW5nZTogKGUpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZVNsaWRlckNoYW5nZShlLCBiYW5kSW5kZXgpO1xuICAgICAgICAgICAgfSB9KSkpKSkpO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0IGFzc2V0c0RpcnMoKSB7IHJldHVybiBbXCJ0OW5cIl07IH1cbiAgICBnZXQgaG9zdEVsZW1lbnQoKSB7IHJldHVybiBnZXRFbGVtZW50KHRoaXMpOyB9XG59O1xuXG5leHBvcnQgeyBSZnhHYW1tYUVkaXRvciBhcyBSLCBjb21wdXRlR2FtbWEgYXMgYSwgY29tcHV0ZUdhbW1hVmFsdWVzIGFzIGMgfTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmZ4LWN0ZS1nYW1tYS1lZGl0b3ItZWRjMjA1ODguanMubWFwIiwiZXhwb3J0IHsgUiBhcyByZnhfY3RlX2dhbW1hX2VkaXRvciB9IGZyb20gJy4vcmZ4LWN0ZS1nYW1tYS1lZGl0b3ItZWRjMjA1ODguanMnO1xuaW1wb3J0ICcuL2luZGV4LWRhMWI3MTM4LmpzJztcbmltcG9ydCAnLi9sb2NhbGl6YXRpb24taGVscGVyLTQ4MTliNjdkLmpzJztcbmltcG9ydCAnQGFyY2dpcy9jb3JlL2NvcmUvbGFuZy5qcyc7XG5pbXBvcnQgJy4vdHlwZS1nYXVyZHMtMTg0MDc0N2YuanMnO1xuaW1wb3J0ICcuL19nZXRUYWctOTZhZjAyOWQuanMnO1xuaW1wb3J0ICcuL3VpLXV0aWxzLTkyOGE0MDk2LmpzJztcbmltcG9ydCAnQGFyY2dpcy9jb3JlL2lkZW50aXR5L0lkZW50aXR5TWFuYWdlci5qcyc7XG5pbXBvcnQgJ0BhcmNnaXMvY29yZS9jb3JlL3VybFV0aWxzLmpzJztcbmltcG9ydCAnQGFyY2dpcy9jb3JlL2xheWVycy9MYXllci5qcyc7XG5pbXBvcnQgJ0BhcmNnaXMvY29yZS9sYXllcnMvSW1hZ2VyeUxheWVyLmpzJztcbmltcG9ydCAnQGFyY2dpcy9jb3JlL3NtYXJ0TWFwcGluZy9yYXN0ZXIvcmVuZGVyZXJzL3N0cmV0Y2guanMnO1xuaW1wb3J0ICdAYXJjZ2lzL2NvcmUvcmVxdWVzdC5qcyc7XG5pbXBvcnQgJ0BhcmNnaXMvY29yZS9yZXN0L3N1cHBvcnQvQWxnb3JpdGhtaWNDb2xvclJhbXAuanMnO1xuaW1wb3J0ICdAYXJjZ2lzL2NvcmUvcmVzdC9zdXBwb3J0L011bHRpcGFydENvbG9yUmFtcC5qcyc7XG5pbXBvcnQgJ0BhcmNnaXMvY29yZS9Db2xvci5qcyc7XG5pbXBvcnQgJy4vY29sb3JSYW1wVXRpbHMtOGJkZDQ2YzUuanMnO1xuaW1wb3J0ICcuL3Nhbml0aXplLW51bWJlci1kODQxMTRmNy5qcyc7XG5pbXBvcnQgJ0BhcmNnaXMvY29yZS9yZXN0L2dlb3Byb2Nlc3Nvci5qcyc7XG5pbXBvcnQgJ0BhcmNnaXMvY29yZS9wb3J0YWwvUG9ydGFsSXRlbS5qcyc7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJmeC1jdGUtZ2FtbWEtZWRpdG9yLmVudHJ5LmpzLm1hcCIsImltcG9ydCB7IGcgYXMgZ2V0TG9jYWxlSW5mbyB9IGZyb20gJy4vbG9jYWxpemF0aW9uLWhlbHBlci00ODE5YjY3ZC5qcyc7XG5pbXBvcnQgeyBpIGFzIGlzRW1wdHlEYXRhSXRlbSB9IGZyb20gJy4vdHlwZS1nYXVyZHMtMTg0MDc0N2YuanMnO1xuXG4vKipcbiAqIEluZGljYXRlcyBpZiBhIHByb3ZpZGVkIG51bWJlciB2YWx1ZSBpcyB2YWxpZC5cbiAqIEFuIGludmFsaWQgdmFsdWUgaXM6IHVuZGVmaW5lZCB8IE5hTiB8IEluZmluaXRlIHwgLUluZmluaXRlIHwgbnVsbFxuICogU2VlIGZvciBtb3JlIGRldGFpbHM6XG4gKiAgIC0gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvTnVtYmVyL2lzRmluaXRlXG4gKiAgIC0gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvTnVtYmVyL2lzTmFOXG4gKiBAcGFyYW0ge251bWJlciB8IHVuZGVmaW5lZCB8IG51bGx9IHZhbHVlIHZhbHVlIHRvIGNoZWNrXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gaWYgdmFsaWQgb3Igbm90XG4gKi9cbmZ1bmN0aW9uIGlzVmFsaWROdW1iZXIodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCAmJiBOdW1iZXIuaXNOYU4odmFsdWUpID09PSBmYWxzZSAmJiBOdW1iZXIuaXNGaW5pdGUodmFsdWUpID09PSB0cnVlO1xufVxuLyoqXG4gKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBwcm92aWRlZCBudW1iZXIgZm9yIHVzZSB3aXRoIGNhbGNpdGUtaW5wdXQuIEl0IGFsc29cbiAqIGd1YXJkcyBhZ2FpbnN0IGludmFsaWQgdHlwZXMgZm9sbG93aW5nIHRoaXMgbG9naWM6XG4gKiAgIC0gSWYgdGhlIHZhbHVlIGlzIHZhbGlkIChub3QgTmFOLCBmaW5pdGUpLCB0aGUgdmFsdWUgaXMgcmV0dXJuZWQgYXMgYSBzdHJpbmdcbiAqICAgLSBJZiBub3QgYW5kIGlmIGEgdmFsaWQgZGVmYXVsdCB2YWx1ZSBpcyBwcm92aWRlZCwgdGhlIGRlZmF1bHQgdmFsdWUgaXMgcmV0dXJuZWQgYXMgYSBzdHJpbmdcbiAqICAgLSBJZiBub3QsIGFuIGVtcHR5IHN0cmluZyBpcyByZXR1cm5lZFxuICogQHBhcmFtIHZhbHVlXG4gKiBAcGFyYW0gZGVmYXVsdFZhbHVlXG4gKiBAcmV0dXJucyBhIHNhbml0aXplZCBzdHJpbmdcbiAqL1xuZnVuY3Rpb24gc2FuaXRpemVOdW1iZXIodmFsdWUsIGRlZmF1bHRWYWx1ZSkge1xuICAgIGxldCByZXR1cm5lZFZhbHVlO1xuICAgIGlmICh2YWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICBjb25zdCB0ZXN0ZWRWYWx1ZSA9IHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiA/IE51bWJlci5wYXJzZUZsb2F0KHZhbHVlKSA6IHZhbHVlO1xuICAgICAgICBpZiAoaXNWYWxpZE51bWJlcih0ZXN0ZWRWYWx1ZSkpXG4gICAgICAgICAgICByZXR1cm5lZFZhbHVlID0gdGVzdGVkVmFsdWU7XG4gICAgICAgIGVsc2UgaWYgKGlzVmFsaWROdW1iZXIoZGVmYXVsdFZhbHVlKSlcbiAgICAgICAgICAgIHJldHVybmVkVmFsdWUgPSBkZWZhdWx0VmFsdWU7XG4gICAgfVxuICAgIHJldHVybiByZXR1cm5lZFZhbHVlID09PSB1bmRlZmluZWQgPyBcIlwiIDogYCR7cmV0dXJuZWRWYWx1ZX1gO1xufVxuLyoqXG4gKiBQYXJzZXMgYSB2YWx1ZSBzdHJpbmcgdG8gYSBudW1iZXIgZm9yIHVzZSB3aXRoIGNhbGNpdGUtaW5wdXQuIElmIHRoZSBzdHJpbmcgaXMgZW1wdHksIGl0IHdpbGwgcmV0dXJuIHVuZGVmaW5lZC5cbiAqIElmIHRoZSBzdHJpbmcgaXMgb3RoZXJ3aXNlIGludmFsaWQsIGl0IHdpbGwgcmV0dXJuIE5hTi5cbiAqIEBwYXJhbSB2YWx1ZSBjYWxjaXRlLWlucHV0IHZhbHVlXG4gKiBAcmV0dXJucyB7bnVtYmVyIHwgdW5kZWZpbmVkfSB0aGUgcGFyc2VkIG51bWJlclxuICovXG5mdW5jdGlvbiBwYXJzZU51bWJlcih2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PT0gXCJcIilcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICByZXR1cm4gTnVtYmVyLnBhcnNlRmxvYXQodmFsdWUpO1xufVxuLyoqXG4gKiBGb3JtYXRzIGEgbnVtYmVyIHRvIGEgc3BlY2lmaWVkIG51bWJlciBvZiBkZWNpbWFsIHBsYWNlcy5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgLSBUaGUgbnVtYmVyIHRvIGZvcm1hdC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbZnJhY3Rpb25EaWdpdHM9M10gLSBUaGUgbnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzIHRvIGluY2x1ZGUgaW4gdGhlIGZvcm1hdHRlZCBudW1iZXIuIERlZmF1bHRzIHRvIDMuXG4gKiBAcmV0dXJucyB7bnVtYmVyfHVuZGVmaW5lZH0gLSBUaGUgZm9ybWF0dGVkIG51bWJlciwgb3IgdW5kZWZpbmVkIGlmIHRoZSBpbnB1dCB2YWx1ZSBpcyBlbXB0eS5cbiAqL1xuZnVuY3Rpb24gZm9ybWF0TnVtYmVyKHZhbHVlLCBmcmFjdGlvbkRpZ2l0cyA9IDMpIHtcbiAgICBpZiAoaXNFbXB0eURhdGFJdGVtKHZhbHVlKSlcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICByZXR1cm4gTnVtYmVyLnBhcnNlRmxvYXQodmFsdWUudG9GaXhlZChmcmFjdGlvbkRpZ2l0cykpO1xufVxuLyoqXG4gKiBGb3JtYXRzIGEgbnVtYmVyIG9yIHN0cmluZyByZXByZXNlbnRpbmcgYSBudW1iZXIgYWNjb3JkaW5nIHRvIHRoZSBsb2NhbGUsIHBhc3NpbmcgSW50bCBudW1iZXIgZm9ybWF0IG9wdGlvbnNcbiAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlR2xvYmFsX09iamVjdHMvSW50bC9OdW1iZXJGb3JtYXQvTnVtYmVyRm9ybWF0I29wdGlvbnNcbiAqIEBwYXJhbSB7bnVtYmVyIHwgc3RyaW5nIHwgdW5kZWZpbmVkfSB2YWx1ZSB0byBiZSBmb3JtYXR0ZWQgYW5kIGxvY2FsaXplZFxuICogQHBhcmFtIHtJbnRsLk51bWJlckZvcm1hdE9wdGlvbnN9IGZvcm1hdE9wdGlvbnMgb3B0aW9ucyBvYmplY3QgbWF0Y2hpbmcgSW50bC5OdW1iZXJGb3JtYXRcbiAqIEByZXR1cm5zIHtzdHJpbmd9IGxvY2FsaXplZCAvIHJvdW5kZWQgc3RyaW5nXG4gKi9cbmZ1bmN0aW9uIGZvcm1hdE51bWJlclRvTG9jYWxlKHZhbHVlLCBmb3JtYXRPcHRpb25zKSB7XG4gICAgbGV0IGZvcm1hdHRlZFZhbHVlID0gXCJcIjtcbiAgICBpZiAoIWlzRW1wdHlEYXRhSXRlbSh2YWx1ZSkgJiYgIU51bWJlci5pc05hTih2YWx1ZSkpIHtcbiAgICAgICAgY29uc3QgbG9jYWxlQ29kZSA9IGdldExvY2FsZUluZm8oKS5sb2NhbGU7XG4gICAgICAgIGZvcm1hdHRlZFZhbHVlID0gSW50bC5OdW1iZXJGb3JtYXQobG9jYWxlQ29kZSwgZm9ybWF0T3B0aW9ucykuZm9ybWF0KE51bWJlcih2YWx1ZSkpO1xuICAgIH1cbiAgICByZXR1cm4gZm9ybWF0dGVkVmFsdWU7XG59XG5cbmV4cG9ydCB7IGZvcm1hdE51bWJlclRvTG9jYWxlIGFzIGEsIGZvcm1hdE51bWJlciBhcyBmLCBpc1ZhbGlkTnVtYmVyIGFzIGksIHBhcnNlTnVtYmVyIGFzIHAsIHNhbml0aXplTnVtYmVyIGFzIHMgfTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2FuaXRpemUtbnVtYmVyLWQ4NDExNGY3LmpzLm1hcCIsImltcG9ydCB7IGkgYXMgaXNBcnJheUxpa2UsIGEgYXMgaXNBcnJheSwgYiBhcyBpc0J1ZmZlciwgYyBhcyBpc1R5cGVkQXJyYXksIGQgYXMgaXNBcmd1bWVudHMsIGcgYXMgZ2V0VGFnLCBlIGFzIGlzUHJvdG90eXBlLCBmIGFzIGJhc2VLZXlzLCBoIGFzIGlzUGxhaW5PYmplY3QgfSBmcm9tICcuL19nZXRUYWctOTZhZjAyOWQuanMnO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgbWFwVGFnID0gJ1tvYmplY3QgTWFwXScsXG4gICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XSc7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYW4gZW1wdHkgb2JqZWN0LCBjb2xsZWN0aW9uLCBtYXAsIG9yIHNldC5cbiAqXG4gKiBPYmplY3RzIGFyZSBjb25zaWRlcmVkIGVtcHR5IGlmIHRoZXkgaGF2ZSBubyBvd24gZW51bWVyYWJsZSBzdHJpbmcga2V5ZWRcbiAqIHByb3BlcnRpZXMuXG4gKlxuICogQXJyYXktbGlrZSB2YWx1ZXMgc3VjaCBhcyBgYXJndW1lbnRzYCBvYmplY3RzLCBhcnJheXMsIGJ1ZmZlcnMsIHN0cmluZ3MsIG9yXG4gKiBqUXVlcnktbGlrZSBjb2xsZWN0aW9ucyBhcmUgY29uc2lkZXJlZCBlbXB0eSBpZiB0aGV5IGhhdmUgYSBgbGVuZ3RoYCBvZiBgMGAuXG4gKiBTaW1pbGFybHksIG1hcHMgYW5kIHNldHMgYXJlIGNvbnNpZGVyZWQgZW1wdHkgaWYgdGhleSBoYXZlIGEgYHNpemVgIG9mIGAwYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBlbXB0eSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzRW1wdHkobnVsbCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0VtcHR5KHRydWUpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNFbXB0eSgxKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzRW1wdHkoWzEsIDIsIDNdKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0VtcHR5KHsgJ2EnOiAxIH0pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNFbXB0eSh2YWx1ZSkge1xuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChpc0FycmF5TGlrZSh2YWx1ZSkgJiZcbiAgICAgIChpc0FycmF5KHZhbHVlKSB8fCB0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycgfHwgdHlwZW9mIHZhbHVlLnNwbGljZSA9PSAnZnVuY3Rpb24nIHx8XG4gICAgICAgIGlzQnVmZmVyKHZhbHVlKSB8fCBpc1R5cGVkQXJyYXkodmFsdWUpIHx8IGlzQXJndW1lbnRzKHZhbHVlKSkpIHtcbiAgICByZXR1cm4gIXZhbHVlLmxlbmd0aDtcbiAgfVxuICB2YXIgdGFnID0gZ2V0VGFnKHZhbHVlKTtcbiAgaWYgKHRhZyA9PSBtYXBUYWcgfHwgdGFnID09IHNldFRhZykge1xuICAgIHJldHVybiAhdmFsdWUuc2l6ZTtcbiAgfVxuICBpZiAoaXNQcm90b3R5cGUodmFsdWUpKSB7XG4gICAgcmV0dXJuICFiYXNlS2V5cyh2YWx1ZSkubGVuZ3RoO1xuICB9XG4gIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBrZXkpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG5jb25zdCBSRlRfVFlQRSA9IFwiUmFzdGVyRnVuY3Rpb25UZW1wbGF0ZVwiO1xuY29uc3QgVFlQRV9LRVlXT1JEID0gXCJ0eXBlXCI7XG5jb25zdCBSRlZfVFlQRSA9IFwiUmFzdGVyRnVuY3Rpb25WYXJpYWJsZVwiO1xuY29uc3QgQVJHU19LRVlXT1JEID0gXCJhcmd1bWVudHNcIjtcbmNvbnN0IEZVTkNUSU9OX0tFWVdPUkQgPSBcImZ1bmN0aW9uXCI7XG5mdW5jdGlvbiBpc1JlZmVyZW5jZWRPYmplY3Qob2JqKSB7XG4gICAgaWYgKCFvYmopIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAob2JqLl9vYmplY3RfcmVmX2lkICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGlzTnVtYmVyKHgpIHtcbiAgICB4ID0gU3RyaW5nKHgpLnRyaW0oKTtcbiAgICBpZiAoeCA9PT0gXCJcIikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiAvXlsrLV0/KFxcZCspPyhcXC5cXGQrKT8kLy50ZXN0KHgpO1xufVxuZnVuY3Rpb24gaXNXaWRnZXRWYWx1ZUJvb2xlYW4oeCkge1xuICAgIHggPSBTdHJpbmcoeCkudHJpbSgpO1xuICAgIHJldHVybiBbXCJ0cnVlXCIsIFwiZmFsc2VcIl0uaW5kZXhPZih4KSA+PSAwO1xufVxuZnVuY3Rpb24gaXNDb2xvclJhbXAocmZ4QXJnKSB7XG4gICAgaWYgKCFyZnhBcmcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAocmZ4QXJnLnR5cGUgJiYgcmZ4QXJnLnR5cGUudG9Mb3dlckNhc2UoKS5pbmRleE9mKFwiY29sb3JyYW1wXCIpID49IDApIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChyZnhBcmcudmFsdWUgJiYgcmZ4QXJnLnZhbHVlLnR5cGUgJiYgcmZ4QXJnLnZhbHVlLnR5cGUudG9Mb3dlckNhc2UoKS5pbmRleE9mKFwiY29sb3JyYW1wXCIpID49IDApIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGlzUmVjb3JkU2V0KHJmeEFyZykge1xuICAgIHJldHVybiByZnhBcmcudHlwZSAmJiByZnhBcmcudHlwZS50b0xvd2VyQ2FzZSgpLmluZGV4T2YoXCJyZWNvcmRzZXRcIikgPj0gMDtcbn1cbi8qKlxuICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBnaXZlbiBSRlQgZWxlbWVudCBpcyBhbiBSRnggYXJndW1lbnQuXG4gKlxuICogQHBhcmFtIHthbnl9IHJmdEVsZW1lbnQgLSBUaGUgUkZUIGVsZW1lbnQgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIGlmIHRoZSBnaXZlbiBlbGVtZW50IGlzIFJhc3RlckZ1bmN0aW9uVGVtcGxhdGUsXG4gKiBSYXN0ZXJGdW5jdGlvblZhcmlhYmxlLCBpc0NvbG9yUmFtcCwgaXNSZWNvcmRTZXQ7IGBmYWxzZWAgb3RoZXJ3aXNlLlxuICovXG5mdW5jdGlvbiBpc1JGeEFyZyhyZnRFbGVtZW50KSB7XG4gICAgaWYgKCFyZnRFbGVtZW50KSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgdHlwZSA9IHJmdEVsZW1lbnQudHlwZTtcbiAgICByZXR1cm4gW1JGVF9UWVBFLCBSRlZfVFlQRV0uaW5kZXhPZih0eXBlKSA+PSAwIHx8IGlzQ29sb3JSYW1wKHJmdEVsZW1lbnQpIHx8IGlzUmVjb3JkU2V0KHJmdEVsZW1lbnQpO1xufVxuLyoqXG4gKiBEZXRlcm1pbmVzIGlmIHRoZSBpbnB1dCBpcyBhIEZlYXR1cmVMYXllclxuICogQHBhcmFtIHtfX2VzcmkuTGF5ZXJ9IGxheWVyIHRoZSBsYXllciB0byBjaGVjayB0aGUgdHlwZSBvZlxuICogQHJldHVybnMge2xheWVyIGlzIF9fZXNyaS5GZWF0dXJlTGF5ZXJ9IGxheWVyIGlzIGEgRmVhdHVyZUxheWVyXG4gKi9cbmZ1bmN0aW9uIGlzRmVhdHVyZUxheWVyKGxheWVyKSB7XG4gICAgcmV0dXJuIGxheWVyLnR5cGUgPT09IFwiZmVhdHVyZVwiO1xufVxuLyoqXG4gKiBEZXRlcm1pbmVzIGlmIHRoZSBpbnB1dCBpcyBhIFRpbGVMYXllclxuICogQHBhcmFtIHtfX2VzcmkuTGF5ZXJ9IGxheWVyIHRoZSBsYXllciB0byBjaGVjayB0aGUgdHlwZSBvZlxuICogQHJldHVybnMge2xheWVyIGlzIF9fZXNyaS5UaWxlTGF5ZXJ9IGxheWVyIGlzIGEgVGlsZUxheWVyXG4gKi9cbmZ1bmN0aW9uIGlzVGlsZUxheWVyKGxheWVyKSB7XG4gICAgcmV0dXJuIGxheWVyLnR5cGUgPT09IFwidGlsZVwiO1xufVxuLyoqXG4gKiBEZXRlcm1pbmVzIGlmIHRoZSBpbnB1dCBpcyBhIEltYWdlcnlUaWxlTGF5ZXJcbiAqIEBwYXJhbSB7X19lc3JpLkxheWVyfSBsYXllciB0aGUgbGF5ZXIgdG8gY2hlY2sgdGhlIHR5cGUgb2ZcbiAqIEByZXR1cm5zIHtsYXllciBpcyBfX2VzcmkuSW1hZ2VyeUxheWVyfSBsYXllciBpcyBhIEltYWdlcnlMYXllclxuICovXG5mdW5jdGlvbiBpc0R5bmFtaWNJbWFnZXJ5TGF5ZXIobGF5ZXIpIHtcbiAgICByZXR1cm4gKGxheWVyLnR5cGUgPT09IFwiaW1hZ2VyeS10aWxlXCIgJiZcbiAgICAgICAgbGF5ZXIuc291cmNlSlNPTi5jYXBhYmlsaXRpZXMudG9Mb3dlckNhc2UoKS5pbmRleE9mKFwidGlsZXNvbmx5XCIpIDwgMCk7XG59XG4vKipcbiAqIERldGVybWluZXMgaWYgdGhlIGlucHV0IGlzIGEgSW1hZ2VyeUxheWVyXG4gKiBAcGFyYW0ge19fZXNyaS5MYXllcn0gbGF5ZXIgdGhlIGxheWVyIHRvIGNoZWNrIHRoZSB0eXBlIG9mXG4gKiBAcmV0dXJucyB7bGF5ZXIgaXMgX19lc3JpLkltYWdlcnlMYXllcn0gbGF5ZXIgaXMgYSBJbWFnZXJ5TGF5ZXJcbiAqL1xuZnVuY3Rpb24gaXNJbWFnZXJ5TGF5ZXIobGF5ZXIpIHtcbiAgICByZXR1cm4gbGF5ZXIudHlwZSA9PT0gXCJpbWFnZXJ5XCIgfHwgaXNEeW5hbWljSW1hZ2VyeUxheWVyKGxheWVyKTtcbn1cbi8qKlxuICogRGV0ZXJtaW5lcyBpZiB0aGUgaW5wdXQgaXMgYSBJbWFnZXJ5VGlsZUxheWVyXG4gKiBAcGFyYW0ge19fZXNyaS5MYXllcn0gbGF5ZXIgdGhlIGxheWVyIHRvIGNoZWNrIHRoZSB0eXBlIG9mXG4gKiBAcmV0dXJucyB7bGF5ZXIgaXMgX19lc3JpLkltYWdlcnlUaWxlTGF5ZXJ9IGxheWVyIGlzIGEgSW1hZ2VyeVRpbGVMYXllclxuICovXG5mdW5jdGlvbiBpc0ltYWdlcnlUaWxlTGF5ZXIobGF5ZXIpIHtcbiAgICByZXR1cm4gbGF5ZXIudHlwZSA9PT0gXCJpbWFnZXJ5LXRpbGVcIiAmJiAhaXNEeW5hbWljSW1hZ2VyeUxheWVyKGxheWVyKTtcbn1cbmZ1bmN0aW9uIGlzRXZlcnlQcm9wZXJ0eUVtcHR5KHZhbHVlKSB7XG4gICAgbGV0IGlzQWxsUHJvcHNFbXB0eSA9IHRydWU7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJiBpc0FycmF5KHZhbHVlKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgLy8gdXNpbmcgZm9yLWluIGFzIGl0IHdpbGwgd29yayB3aXRoIG9iamVjdHMgd2l0aCBwcm9wZXJ0aWVzIHRoYXQgc2V0IHZpYSBhY2Nlc3NvcnMgYXMgd2VsbFxuICAgICAgICBmb3IgKGNvbnN0IHByb3AgaW4gdmFsdWUpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgd2lsbCB0ZWxsIHRoZSBUeXBlU2NyaXB0IGNvbXBpbGVyIHRoYXQgdGhlIG9iaiBvYmplY3QgaGFzIGEgc3RyaW5nIGluZGV4IHNpZ25hdHVyZSxcbiAgICAgICAgICAgIC8vIGFuZCB3aWxsIGFsbG93IHRvIGFjY2VzcyBpdHMgcHJvcGVydGllcyB1c2luZyBhIHN0cmluZyBpbmRleCB3aXRob3V0IGdldHRpbmcgdGhlIFwiRWxlbWVudCBpbXBsaWNpdGx5IGhhcyBhbiAnYW55JyB0eXBlXCIgZXJyb3IuXG4gICAgICAgICAgICBjb25zdCBwcm9wVmFsdWUgPSB2YWx1ZT8uW3Byb3BdO1xuICAgICAgICAgICAgaWYgKHZhbHVlLmhhc093blByb3BlcnR5KHByb3ApID09PSB0cnVlICYmIHByb3BWYWx1ZSAhPT0gdW5kZWZpbmVkICYmIHByb3BWYWx1ZSAhPT0gbnVsbCAmJiBwcm9wVmFsdWUgIT09IFwiXCIpIHtcbiAgICAgICAgICAgICAgICBpc0FsbFByb3BzRW1wdHkgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaXNBbGxQcm9wc0VtcHR5O1xufVxuLyoqXG4gKiBDaGVjayBmb3IgYW4gZW1wdHkgdmFsdWUgZm9yIGRhdGEgaXRlbXMgbGlrZSBHUFN0cmluZyBhbmQgRmllbGQuXG4gKiBAcGFyYW0gdmFsdWUgZGF0YSBpdGVtIHZhbHVlLlxuICogQHJldHVybnMgd2hldGhlciB0aGUgdmFsdWUgaXMgY29uc2lkZXJlZCBlbXB0eS5cbiAqL1xuZnVuY3Rpb24gaXNFbXB0eURhdGFJdGVtKHZhbHVlKSB7XG4gICAgcmV0dXJuICh2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgIHZhbHVlID09PSBudWxsIHx8XG4gICAgICAgIC8vIHNpbmdsZS1zZWxlY3QsIFwiXCIgaXMgYSBzcGVjaWFsIGNhc2UgZm9yIHN0cmluZ3NcbiAgICAgICAgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJiB2YWx1ZSA9PT0gXCJcIikgfHxcbiAgICAgICAgLy8gc2luZ2xlLXNlbGVjdCwgZW1wdHkgb2JqZWN0cyBhcmUgYSBzcGVjaWFsIGNhc2UgZm9yIG5lc3RlZCB2YWx1ZXNcbiAgICAgICAgKGlzUGxhaW5PYmplY3QodmFsdWUpICYmIGlzRW1wdHkodmFsdWUpKSB8fFxuICAgICAgICAvLyBtdWx0aS1zZWxlY3RcbiAgICAgICAgKEFycmF5LmlzQXJyYXkodmFsdWUpICYmIHZhbHVlLmxlbmd0aCA8IDEpIHx8XG4gICAgICAgIC8vIG9ubHkgdGVzdGluZyBvYmplY3RzIHdoaWNoIGFyZSBub3QgYXJyYXlzXG4gICAgICAgIC8vIFRPRE86IGNvbWJpbmUgaXNFdmVyeVByb3BlcnR5RW1wdHkgYW5kIGlzRW1wdHlEYXRhSXRlbSB0byBzaW5nbGUgZnVuY3Rpb25cbiAgICAgICAgKHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJiBpc0FycmF5KHZhbHVlKSA9PT0gZmFsc2UgJiYgaXNFdmVyeVByb3BlcnR5RW1wdHkodmFsdWUpKSk7XG59XG5cbmV4cG9ydCB7IEFSR1NfS0VZV09SRCBhcyBBLCBGVU5DVElPTl9LRVlXT1JEIGFzIEYsIFJGVl9UWVBFIGFzIFIsIFRZUEVfS0VZV09SRCBhcyBULCBpc1JGeEFyZyBhcyBhLCBSRlRfVFlQRSBhcyBiLCBpc1JlZmVyZW5jZWRPYmplY3QgYXMgYywgaXNOdW1iZXIgYXMgZCwgaXNXaWRnZXRWYWx1ZUJvb2xlYW4gYXMgZSwgaXNDb2xvclJhbXAgYXMgZiwgaXNSZWNvcmRTZXQgYXMgZywgaXNGZWF0dXJlTGF5ZXIgYXMgaCwgaXNFbXB0eURhdGFJdGVtIGFzIGksIGlzVGlsZUxheWVyIGFzIGosIGlzRHluYW1pY0ltYWdlcnlMYXllciBhcyBrLCBpc0ltYWdlcnlMYXllciBhcyBsLCBpc0ltYWdlcnlUaWxlTGF5ZXIgYXMgbSB9O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD10eXBlLWdhdXJkcy0xODQwNzQ3Zi5qcy5tYXAiLCJjb25zdCBVSURlZmF1bHRzID0ge1xuICAgIFNjYWxlOiBcInNcIixcbiAgICBQb3BvdmVyVGltZXI6IDYwXG59O1xuY29uc3QgQ2FsY2l0ZVNjYWxlID0ge1xuICAgIHM6IFwic1wiLFxuICAgIG06IFwibVwiXG59O1xuY29uc3QgQ2FsY2l0ZU92ZXJsYXlQb3NpdGlvbmluZyA9IHtcbiAgICBhYnNvbHV0ZTogXCJhYnNvbHV0ZVwiLFxuICAgIGZpeGVkOiBcImZpeGVkXCJcbn07XG5cbmV4cG9ydCB7IENhbGNpdGVTY2FsZSBhcyBDLCBVSURlZmF1bHRzIGFzIFUsIENhbGNpdGVPdmVybGF5UG9zaXRpb25pbmcgYXMgYSB9O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD11aS11dGlscy05MjhhNDA5Ni5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=