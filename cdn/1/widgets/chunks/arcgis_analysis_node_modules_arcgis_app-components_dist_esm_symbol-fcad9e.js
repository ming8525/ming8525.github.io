"use strict";
(self["webpackChunkexb_client"] = self["webpackChunkexb_client"] || []).push([["vendors-extensions_widgets_arcgis_analysis_node_modules_arcgis_app-components_dist_esm_symbol-fcad9e"],{

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/location-e26b539f.js":
/*!**************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/location-e26b539f.js ***!
  \**************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   a: () => (/* binding */ buildOutlineVisVar),
/* harmony export */   b: () => (/* binding */ buildSizeAutoVisVar),
/* harmony export */   c: () => (/* binding */ createSimpleRenderer)
/* harmony export */ });
/* harmony import */ var _raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./raster-unique-value-0976ec7f.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/raster-unique-value-0976ec7f.js");
/* harmony import */ var _loadModules_b4ac1247_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./loadModules-b4ac1247.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/loadModules-b4ac1247.js");
/* harmony import */ var _commonFunctions_b0830e9e_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./commonFunctions-b0830e9e.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/commonFunctions-b0830e9e.js");
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v4.0.58
 */




/**
 * Updates the layer with a Simple renderer with default settings
 * @param options: options
 */
function createSimpleRenderer(options) {
    var _a;
    const { layer: smLayer, mapImageSublayer, mapView, modules } = _raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.s;
    const layer = smLayer;
    options = options || {};
    const extras = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.m)((0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.h)(layer));
    return modules.LocationCreator.createRenderer({
        layer,
        view: mapView,
        outlineOptimizationEnabled: mapImageSublayer
            ? false
            : (0,_commonFunctions_b0830e9e_js__WEBPACK_IMPORTED_MODULE_2__.i)(options.outlineOptimizationEnabled)
                ? options.outlineOptimizationEnabled
                : true,
        sizeOptimizationEnabled: mapImageSublayer
            ? false
            : (0,_commonFunctions_b0830e9e_js__WEBPACK_IMPORTED_MODULE_2__.i)(options.sizeOptimizationEnabled)
                ? options.sizeOptimizationEnabled
                : true,
        forBinning: ((_a = layer.featureReduction) === null || _a === void 0 ? void 0 : _a.type) === "binning"
    }).then((result) => {
        (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.l)(extras, result.renderer);
        return Promise.resolve(result);
    }, (error) => Promise.reject(error));
}
function buildOutlineVisVar() {
    var _a;
    // TODO - can we just get the visualVariable without a full renderer?
    const { layer: smLayer, mapView, modules } = _raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.s;
    const layer = smLayer;
    return modules.LocationCreator.createRenderer({
        layer,
        view: mapView,
        outlineOptimizationEnabled: true,
        forBinning: ((_a = layer.featureReduction) === null || _a === void 0 ? void 0 : _a.type) === "binning"
    }).then((result) => {
        const sizeOutlineVisVar = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.a)(result.renderer, "size", "outline");
        return Promise.resolve(sizeOutlineVisVar);
    });
}
function buildSizeAutoVisVar() {
    var _a;
    const { layer: smLayer, mapView, modules } = _raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.s;
    const layer = smLayer;
    return modules.LocationCreator.createRenderer({
        layer,
        view: mapView,
        outlineOptimizationEnabled: false,
        sizeOptimizationEnabled: true,
        forBinning: ((_a = layer.featureReduction) === null || _a === void 0 ? void 0 : _a.type) === "binning"
    }).then((result) => {
        const sizeAutoVisVar = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.a)(result.renderer, "size", "auto");
        return Promise.resolve(sizeAutoVisVar);
    });
}



//# sourceMappingURL=location-e26b539f.js.map

/***/ }),

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/symbolStyler-04635b2b.js":
/*!******************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/symbolStyler-04635b2b.js ***!
  \******************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   a: () => (/* binding */ buildSymbolStylerForChartValue),
/* harmony export */   b: () => (/* binding */ buildSymbolStylerForDotDensityValue),
/* harmony export */   c: () => (/* binding */ createSymbolStylerPopover),
/* harmony export */   d: () => (/* binding */ buildSymbolStylerForPredominanceValue),
/* harmony export */   e: () => (/* binding */ buildSymbolStylerForTypeGroup),
/* harmony export */   f: () => (/* binding */ buildSymbolStylerForTypeValue),
/* harmony export */   g: () => (/* binding */ buildSymbolStylerForClassed),
/* harmony export */   h: () => (/* binding */ getRangeValues),
/* harmony export */   i: () => (/* binding */ buildSymbolStylerForDefault),
/* harmony export */   j: () => (/* binding */ buildSymbolStylerForTypeRamp),
/* harmony export */   k: () => (/* binding */ buildSymbolStylerForChartRamp),
/* harmony export */   l: () => (/* binding */ buildSymbolStylerForColorSizeBelow),
/* harmony export */   m: () => (/* binding */ buildSymbolStylerForColorSizeAbove),
/* harmony export */   n: () => (/* binding */ buildSymbolStylerForPredominanceRamp),
/* harmony export */   o: () => (/* binding */ buildSymbolStylerForBackground),
/* harmony export */   p: () => (/* binding */ buildSymbolStylerForHeatmapRamp),
/* harmony export */   q: () => (/* binding */ buildSymbolStylerForDotDensityBackground),
/* harmony export */   r: () => (/* binding */ removeSymbolStylerPopover),
/* harmony export */   s: () => (/* binding */ setRangeValues),
/* harmony export */   t: () => (/* binding */ buildSymbolStylerForDotDensityRamp),
/* harmony export */   u: () => (/* binding */ buildSymbolStylerForGeoRSS),
/* harmony export */   v: () => (/* binding */ buildSymbolStylerForRelationshipRamp),
/* harmony export */   w: () => (/* binding */ buildSymbolStylerForColorRamp),
/* harmony export */   x: () => (/* binding */ buildSymbolStylerForSize),
/* harmony export */   y: () => (/* binding */ buildSymbolStylerForSimple)
/* harmony export */ });
/* harmony import */ var _raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./raster-unique-value-0976ec7f.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/raster-unique-value-0976ec7f.js");
/* harmony import */ var _loadModules_b4ac1247_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./loadModules-b4ac1247.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/loadModules-b4ac1247.js");
/* harmony import */ var _commonEnums_fcf13661_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./commonEnums-fcf13661.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/commonEnums-fcf13661.js");
/* harmony import */ var _commonFunctions_b0830e9e_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./commonFunctions-b0830e9e.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/commonFunctions-b0830e9e.js");
/* harmony import */ var _location_e26b539f_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./location-e26b539f.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/location-e26b539f.js");
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v4.0.58
 */






/**
 * Get low and high values of size range in current map scale (if applicable)
 */
function getRangeValues() {
    const { mapView, layer } = _raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.s;
    const renderer = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.h)(layer);
    const authInfo = renderer.authoringInfo;
    const infos = renderer.type === "class-breaks" ? renderer.classBreakInfos : renderer.uniqueValueInfos;
    const sizeVisVar = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.a)(renderer, "size");
    const isNull = sizeVisVar ? !(0,_commonFunctions_b0830e9e_js__WEBPACK_IMPORTED_MODULE_3__.i)(sizeVisVar.minSize) : false; // then we have stops (= fixed)
    const isNumber = sizeVisVar ? typeof sizeVisVar.minSize === "number" : false;
    const isAboveAndBelow = (authInfo === null || authInfo === void 0 ? void 0 : authInfo.univariateTheme) === "above-and-below";
    let lowValue = 2, highValue = 20;
    if (sizeVisVar) {
        if (isAboveAndBelow) {
            // 5 stops, center is smallest
            const stops = sizeVisVar.stops;
            [lowValue, highValue] = [stops[2].size, Math.max(stops[0].size, stops[4].size)];
        }
        else if (isNull) {
            const stops = sizeVisVar.stops;
            [lowValue, highValue] = [stops[0].size, stops[stops.length - 1].size];
        }
        else if (isNumber) {
            [lowValue, highValue] = [sizeVisVar.minSize, sizeVisVar.maxSize];
        }
        else {
            const mapScale = mapView.scale;
            const minStops = sizeVisVar.minSize.stops;
            const maxStops = sizeVisVar.maxSize.stops;
            [lowValue, highValue] = [minStops[minStops.length - 1].size, maxStops[maxStops.length - 1].size];
            for (let i = 0; i < minStops.length; i++) {
                const minStop = minStops[i];
                const maxStop = maxStops[i];
                if (mapScale <= minStop.value) {
                    if (i > 0) {
                        // interpolate to get correct sizes
                        let lastMinStop = minStops[i - 1];
                        let lastMaxStop = maxStops[i - 1];
                        const factor = (mapScale - lastMinStop.value) / (minStop.value - lastMinStop.value);
                        [lowValue, highValue] = [
                            lastMinStop.size + (minStop.size - lastMinStop.size) * factor,
                            lastMaxStop.size + (maxStop.size - lastMaxStop.size) * factor
                        ];
                    }
                    else {
                        // don't interpolate; use lowest sizes
                        [lowValue, highValue] = [minStops[0].size, maxStops[0].size];
                    }
                    break;
                }
            }
        }
    }
    else if (infos) {
        const minSym = infos[0].symbol;
        const maxSym = infos[infos.length - 1].symbol;
        [lowValue, highValue] = [(0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.T)(minSym), (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.T)(maxSym)];
        if (lowValue > highValue) {
            [lowValue, highValue] = [highValue, lowValue];
        }
    } // else wrong renderer
    return [lowValue, highValue];
}
/**
 * Set new low and high values of size range in current map scale (if applicable)
 */
function setRangeValues(values) {
    const { mapView, layer, modules } = _raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.s;
    const renderer = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.h)(layer); // or any other renderer with sizeVisVar
    const sizeVisVar = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.a)(renderer, "size");
    let newLowValue = values[0];
    let newHighValue = (0,_commonFunctions_b0830e9e_js__WEBPACK_IMPORTED_MODULE_3__.i)(values[1]) ? values[1] : newLowValue;
    if (sizeVisVar) {
        const authInfo = renderer.authoringInfo;
        const isAboveAndBelow = (authInfo === null || authInfo === void 0 ? void 0 : authInfo.univariateTheme) === "above-and-below";
        const isNull = sizeVisVar ? !(0,_commonFunctions_b0830e9e_js__WEBPACK_IMPORTED_MODULE_3__.i)(sizeVisVar.minSize) : false; // then we have stops (= fixed)
        const isNumber = sizeVisVar ? typeof sizeVisVar.minSize === "number" : false;
        let [lowValue, highValue] = getRangeValues();
        const isInverted = lowValue > highValue;
        if (!isInverted && newLowValue >= highValue) {
            newLowValue = highValue - 0.75;
        }
        else if (isInverted && newLowValue >= lowValue) {
            newLowValue = lowValue - 0.75;
        }
        if (!isInverted && lowValue >= newHighValue) {
            newHighValue = lowValue + 0.75;
        }
        else if (isInverted && highValue >= newHighValue) {
            newHighValue = highValue + 0.75;
        }
        if (isAboveAndBelow) {
            const stops = sizeVisVar.stops;
            /* stops[0].size = newHighValue;
            stops[1].size = Math.round((newHighValue + newLowValue) / 2);
            stops[2].size = newLowValue;
            stops[3].size = Math.round((newHighValue + newLowValue) / 2);
            stops[4].size = newHighValue; */
            const minSize = !isInverted ? values[0] : values[1];
            const maxSize = !isInverted ? values[1] : values[0];
            const maxValue = Math.max(...stops.map((stop) => stop.value));
            const midValue = stops[2].value; // assumes 5 stops
            const minValue = Math.min(...stops.map((stop) => stop.value));
            const upperRange = Math.abs(maxValue - midValue);
            const lowerRange = Math.abs(minValue - midValue);
            const maxRange = upperRange > lowerRange ? upperRange : lowerRange;
            const sizeRange = maxSize - minSize;
            stops.forEach((stop) => {
                const { value } = stop;
                stop.size = (Math.abs(value - midValue) / maxRange) * sizeRange + minSize;
            });
        }
        else if (isNull) {
            // need to remove stops
            const stops = sizeVisVar.stops;
            sizeVisVar.stops = null;
            sizeVisVar.minSize = newLowValue;
            sizeVisVar.maxSize = newHighValue;
            sizeVisVar.minDataValue = stops[0].value;
            sizeVisVar.maxDataValue = stops[stops.length - 1].value;
        }
        else if (isNumber) {
            // fixed
            if (!isInverted) {
                sizeVisVar.minSize = newLowValue;
                sizeVisVar.maxSize = newHighValue;
            }
            else {
                sizeVisVar.maxSize = newLowValue;
                sizeVisVar.minSize = newHighValue;
            }
        }
        else {
            // automatic
            const mapScale = mapView.scale;
            let minStops = modules.esriLang.clone(sizeVisVar.minSize.stops);
            let maxStops = modules.esriLang.clone(sizeVisVar.maxSize.stops);
            if (isInverted) {
                [minStops, maxStops] = [maxStops, minStops];
            }
            let minFactor = newLowValue / minStops[minStops.length - 1].size;
            let maxFactor = newHighValue / maxStops[maxStops.length - 1].size;
            // find factor
            for (let i = 0; i < minStops.length; i++) {
                const minStop = minStops[i];
                const maxStop = maxStops[i];
                if (mapScale <= minStop.value) {
                    if (i > 0) {
                        // interpolate to get correct sizes
                        let lastMinStop = minStops[i - 1];
                        let lastMaxStop = maxStops[i - 1];
                        const factor = (mapScale - lastMinStop.value) / (minStop.value - lastMinStop.value);
                        const [min, max] = [
                            lastMinStop.size + (minStop.size - lastMinStop.size) * factor,
                            lastMaxStop.size + (maxStop.size - lastMaxStop.size) * factor
                        ];
                        minFactor = newLowValue / min;
                        maxFactor = newHighValue / max;
                    }
                    else {
                        // don't interpolate; use lowest sizes
                        minFactor = newLowValue / minStops[0].size;
                        maxFactor = newHighValue / maxStops[0].size;
                    }
                    break;
                }
            }
            // apply to all scale ranges
            minStops.forEach((minStop) => (minStop.size = Math.round(minFactor * minStop.size * 10) / 10));
            maxStops.forEach((maxStop) => (maxStop.size = Math.round(maxFactor * maxStop.size * 10) / 10));
            if (isInverted) {
                [minStops, maxStops] = [maxStops, minStops];
            }
            sizeVisVar.minSize.stops = minStops;
            sizeVisVar.maxSize.stops = maxStops;
        }
    }
    else {
        const minSym = renderer.classBreakInfos[0].symbol;
        const maxSym = renderer.classBreakInfos[renderer.classBreakInfos.length - 1].symbol;
        let lowValue = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.T)(minSym);
        let highValue = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.T)(maxSym);
        let isInverted = false;
        if (lowValue > highValue) {
            [lowValue, highValue] = [highValue, lowValue];
            isInverted = true;
        }
        if (lowValue !== highValue && newLowValue > highValue) {
            newLowValue = highValue - 0.75;
        }
        lowValue = newLowValue;
        if (lowValue !== highValue && lowValue > newHighValue) {
            newHighValue = lowValue + 0.75;
        }
        highValue = newHighValue;
        const unit = renderer.classBreakInfos.length === 1
            ? 1
            : Math.max(highValue - lowValue, 10) / (renderer.classBreakInfos.length - 1);
        renderer.classBreakInfos.forEach((classBreakInfo, idx) => {
            const sym = classBreakInfo.symbol;
            if (isInverted) {
                (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.U)(sym, highValue - unit * idx);
            }
            else {
                (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.U)(sym, lowValue + unit * idx);
            }
        });
    }
}
function getSizeByScale(sizeAutoVisVar, scale) {
    const sizeStops = sizeAutoVisVar.stops;
    const stopsCount = sizeStops.length;
    const finalIndex = stopsCount - 1;
    const scaleMin = sizeStops[0].value;
    const scaleMax = sizeStops[finalIndex].value;
    if (scale <= scaleMin) {
        return sizeStops[0].size;
    }
    if (scale >= scaleMax) {
        return sizeStops[finalIndex].size;
    }
    for (let i = 0; i <= finalIndex; i++) {
        const currentStop = sizeStops[i];
        const nextStop = sizeStops[i + 1];
        if (scale >= currentStop.value && scale < nextStop.value) {
            const scaleRange = nextStop.value - currentStop.value;
            const sizeRange = currentStop.size - nextStop.size;
            const relativePosition = (scale - currentStop.value) / scaleRange;
            const effectiveSize = currentStop.size - sizeRange * relativePosition;
            return Math.round(effectiveSize * 100) / 100;
        }
    }
    return 1; // we really don't come here
}

let lastStylerSourceId;
const defaultGeometry = "polygon";
function getGreyColors() {
    const { modules } = _raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.s;
    return [
        new modules.esriColor([255, 255, 255]),
        new modules.esriColor([178, 178, 178]),
        new modules.esriColor([128, 128, 128]),
        new modules.esriColor([92, 92, 92]),
        new modules.esriColor([77, 77, 77]),
        new modules.esriColor([51, 51, 51]),
        new modules.esriColor([26, 26, 26])
    ];
}
function getAllColors() {
    const { modules } = _raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.s;
    return [
        new modules.esriColor("#ff4040"),
        new modules.esriColor("#ff8200"),
        new modules.esriColor("#faa83f"),
        new modules.esriColor("#ffd159"),
        new modules.esriColor("#74b566"),
        new modules.esriColor("#008977"),
        new modules.esriColor("#33e3c8"),
        new modules.esriColor("#43abeb"),
        new modules.esriColor("#4c64c9"),
        new modules.esriColor("#9868ed"),
        new modules.esriColor("#b155e6"),
        new modules.esriColor("#db5181"),
        new modules.esriColor("#e03b99"),
        new modules.esriColor("#2b2b2b"),
        new modules.esriColor("#bdbdbd"),
        new modules.esriColor("#ffffff")
    ];
}
function getAllColorsReversed() {
    const allColors = getAllColors();
    return allColors.reverse();
}
function createSymbolStylerPopover(props) {
    const { referenceElement, heading } = props;
    const popover = document.createElement("arcgis-smart-mapping-styler-popover");
    popover.referenceElement = referenceElement;
    popover.heading = heading;
    document.body.appendChild(popover);
    popover.open = true;
    popover.reposition();
    return popover;
}
function removeSymbolStylerPopover(popover) {
    var _a;
    if (popover === null || popover === void 0 ? void 0 : popover.parentNode) {
        popover.open = false;
        (_a = popover.parentNode) === null || _a === void 0 ? void 0 : _a.removeChild(popover);
    }
}
async function createSymbolStylerElement(popoverNode) {
    const symbolStyler = document.createElement("arcgis-symbol-styler");
    symbolStyler.initialSourceId = lastStylerSourceId;
    symbolStyler.style = "max-height: max(calc(100vh - 200px), 300px)"; // not the best, but easiest
    symbolStyler.popoverProps = {
        placement: "bottom-end",
        offsetDistance: 10,
        offsetSkidding: _raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.s.isRTL ? 3 : -3,
        pointerDisabled: "true",
        popoverWidth: 315,
        //overlayPositioning: "fixed", -- buggy, offset issue
        refElement: await popoverNode.getPopoverRefElement()
    };
    symbolStyler.addEventListener("arcgisSymbolStylerSourceIdChange", ({ detail: activeSourceId }) => (lastStylerSourceId = activeSourceId));
    return symbolStyler;
}
function symbolStylerEdit(symbolStyler, symbol, props) {
    if (document.URL.indexOf("debug=true") > -1) {
        console.log("symbol", JSON.stringify(symbol, null, 2));
        console.log("props", JSON.stringify(Object.assign(Object.assign({}, props), { portal: "..." })));
    }
    return symbolStyler.edit(symbol, props);
}
function onStylerEditWrapper(onStylerEdit, event) {
    const { symbol, info: { marker, stroke, fill } } = event.detail;
    if (document.URL.indexOf("debug=true") > -1) {
        console.log("onStylerEdit - symbol:", JSON.stringify(symbol === null || symbol === void 0 ? void 0 : symbol.toJSON(), null, 2));
        console.log("onStylerEdit - info.marker:", JSON.stringify(marker));
        console.log("onStylerEdit - info.stroke:", JSON.stringify(stroke));
        console.log("onStylerEdit - info.fill:", JSON.stringify(fill));
    }
    onStylerEdit(event);
}
async function buildSymbolStylerForBackground(options) {
    const { layer, mapImageSublayer, portal, modules } = _raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.s;
    const { onChange, popoverNode } = options;
    const renderer = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.h)(layer);
    const isPolygon = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.q)(layer);
    const isChart = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.h)(layer).type === "pie-chart";
    const sizeVisVar = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.a)(renderer, "size");
    const sizeOutlineVisVar = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.a)(renderer, "size", "outline");
    let symbol = renderer.backgroundFillSymbol;
    if (!symbol) {
        symbol = new modules.SimpleFillSymbol();
        symbol.color = null;
        (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.h)(layer).backgroundFillSymbol = symbol;
        onChange();
    }
    const fillEnabled = !!symbol.color;
    const strokeEnabled = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.a5)(symbol);
    const suggestedFillColors = getGreyColors();
    const suggestedStrokeColors = getGreyColors();
    const onStylerEdit = ({ detail: { symbol, info: { marker, stroke /* , fill */ } } }) => {
        (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.h)(layer).backgroundFillSymbol = symbol;
        updateAutoVisVar(symbol, marker === null || marker === void 0 ? void 0 : marker.autoAdjusted, stroke === null || stroke === void 0 ? void 0 : stroke.autoAdjusted, symbolStyler, options);
    };
    let stroke;
    if (symbol.outline) {
        stroke = {
            color: symbol.outline.color ? symbol.outline.color : new modules.esriColor([0, 0, 0, 0.5]),
            size: symbol.outline.width,
            style: symbol.outline.style,
            autoAdjusted: !!sizeOutlineVisVar
        };
    }
    else {
        stroke = {
            color: new modules.esriColor([0, 0, 0, 0.5]),
            size: 1,
            style: "solid",
            autoAdjusted: !!sizeOutlineVisVar
        };
    }
    if (!symbol.outline) {
        symbol.outline = new modules.SimpleLineSymbol();
        (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.r)(symbol, new modules.esriColor([0, 0, 0, 0]));
    }
    const symbolStyler = await createSymbolStylerElement(popoverNode);
    const edit = symbolStylerEdit(symbolStyler, modules.esriLang.clone(symbol), {
        portal,
        symbolFilter: "simple",
        sections: {
            fill: {
                type: "color",
                optional: true,
                open: true,
                suggestedColorsOpen: true,
                transparencyOpen: true,
                suggestedColors: suggestedFillColors
            },
            stroke: {
                type: "color",
                optional: true,
                suggestedColors: suggestedStrokeColors,
                extraParts: {
                    width: true,
                    autoStrokeAdjust: mapImageSublayer || (isPolygon && isChart && !sizeVisVar) ? false : "editable"
                }
            }
        },
        fill: {
            color: symbol.color ? symbol.color : new modules.esriColor([0, 0, 0, 0.5])
        },
        stroke,
        fillEnabled,
        strokeEnabled
    });
    symbolStyler.addEventListener("arcgisSymbolStylerEdit", onStylerEditWrapper.bind(null, onStylerEdit));
    popoverNode.addStyler(symbolStyler);
    await edit;
    return createWatchScaleHandle(symbol, symbolStyler);
}
async function buildSymbolStylerForDotDensityBackground(options) {
    var _a;
    const { layer, mapImageSublayer, portal, modules } = _raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.s;
    const { /* onChange, */ popoverNode } = options;
    const renderer = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.h)(layer);
    const sizeOutlineVisVar = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.a)(renderer, "size", "outline");
    const fillEnabled = !!renderer.backgroundColor;
    const strokeEnabled = !!((_a = renderer.outline) === null || _a === void 0 ? void 0 : _a.color);
    const suggestedFillColors = getGreyColors();
    const suggestedStrokeColors = getGreyColors();
    const onStylerEdit = ({ detail: { symbol, info: { marker, stroke /* , fill */ } } }) => {
        (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.h)(layer).backgroundColor = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.t)(symbol);
        (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.h)(layer).outline = symbol.outline;
        updateAutoVisVar(symbol, marker === null || marker === void 0 ? void 0 : marker.autoAdjusted, stroke === null || stroke === void 0 ? void 0 : stroke.autoAdjusted, symbolStyler, options);
        //onChange();
    };
    let stroke;
    if (renderer.outline) {
        stroke = {
            color: renderer.outline.color ? renderer.outline.color : new modules.esriColor([0, 0, 0, 0.5]),
            size: renderer.outline.width,
            style: renderer.outline.style,
            autoAdjusted: !!sizeOutlineVisVar
        };
    }
    else {
        stroke = {
            color: new modules.esriColor([0, 0, 0, 0.5]),
            size: 1,
            style: "solid",
            autoAdjusted: !!sizeOutlineVisVar
        };
    }
    const symbol = new modules.SimpleFillSymbol();
    symbol.color = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.h)(layer).backgroundColor;
    symbol.outline = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.h)(layer).outline;
    // TODO no CIMs
    const symbolStyler = await createSymbolStylerElement(popoverNode);
    const edit = symbolStylerEdit(symbolStyler, modules.esriLang.clone(symbol), {
        portal,
        symbolFilter: "simple",
        sections: {
            fill: {
                type: "color",
                open: true,
                optional: true,
                suggestedColorsOpen: true,
                transparencyOpen: true,
                suggestedColors: suggestedFillColors
            },
            stroke: {
                type: "color",
                optional: true,
                suggestedColors: suggestedStrokeColors,
                extraParts: {
                    width: true,
                    autoStrokeAdjust: mapImageSublayer ? false : "editable"
                }
            }
        },
        fill: {
            color: renderer.backgroundColor ? renderer.backgroundColor : new modules.esriColor([0, 0, 0, 0.5])
        },
        stroke,
        fillEnabled,
        strokeEnabled
    });
    symbolStyler.addEventListener("arcgisSymbolStylerEdit", onStylerEditWrapper.bind(null, onStylerEdit));
    popoverNode.addStyler(symbolStyler);
    await edit;
    const sym = new modules.SimpleFillSymbol();
    sym.color = renderer.backgroundColor;
    sym.outline = renderer.outline;
    return createWatchScaleHandle(sym, symbolStyler);
}
async function buildSymbolStylerForDefault(options) {
    const { onChange, popoverNode } = options;
    const { layer, mapView, portal, modules } = _raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.s;
    const isPoint = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.A)(layer);
    const isLine = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.B)(layer);
    const isPolygon = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.q)(layer);
    const renderer = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.h)(layer);
    const rendererType = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.g)();
    const sizeAutoVisVar = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.a)(renderer, "size", "auto");
    const sizeOutlineVisVar = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.a)(renderer, "size", "outline");
    let defaultSymbol = renderer.defaultSymbol;
    if (!isSupportedSymbol(defaultSymbol)) {
        defaultSymbol = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.S)(layer, mapView, rendererType);
    }
    const fillEnabled = defaultSymbol.type === "picture-marker" ? false : !!defaultSymbol.color;
    const strokeEnabled = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.a5)(defaultSymbol);
    const isPointCIM = defaultSymbol.type === "cim" && defaultSymbol.data.symbol.type === "CIMPointSymbol";
    const suggestedFillColors = getGreyColors();
    const suggestedStrokeColors = getGreyColors();
    const onStylerEdit = ({ detail: { symbol /* ,
    info: { marker, stroke, fill } */ } }) => {
        const renderer = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.h)(layer);
        renderer.defaultSymbol = symbol;
        onChange();
    };
    let stroke;
    if (!defaultSymbol) {
        if (isPolygon) {
            defaultSymbol = new modules.SimpleFillSymbol();
        }
        else if (isLine) {
            defaultSymbol = new modules.SimpleLineSymbol();
        }
        else {
            defaultSymbol = new modules.SimpleMarkerSymbol();
        }
    }
    if (defaultSymbol.type === "simple-fill") {
        const symbol = defaultSymbol;
        if (symbol.outline) {
            const sym = symbol.outline;
            stroke = {
                color: sym.color ? sym.color : new modules.esriColor([0, 0, 0, 0.5]),
                size: sym.width,
                style: sym.style,
                autoAdjusted: !!sizeOutlineVisVar
            };
        }
        else {
            stroke = {
                color: new modules.esriColor([0, 0, 0, 0.5]),
                size: 1,
                style: "solid",
                autoAdjusted: !!sizeOutlineVisVar
            };
        }
    }
    else if (defaultSymbol.type === "simple-line") {
        const sym = defaultSymbol;
        stroke = {
            color: sym.color ? sym.color : new modules.esriColor([0, 0, 0, 0.5]),
            size: sym.width,
            style: sym.style,
            marker: sym.marker
        };
    }
    else if (defaultSymbol.type === "simple-marker" && defaultSymbol.outline) {
        const sym = defaultSymbol.outline;
        stroke = {
            color: sym.color ? sym.color : new modules.esriColor([0, 0, 0, 0.5]),
            size: sym.width,
            style: sym.style
        };
    }
    else if (defaultSymbol.type === "cim") {
        stroke = getCimLineProps(defaultSymbol);
    }
    else {
        // picture-marker
        stroke = {
            color: new modules.esriColor([255, 255, 255, 0.5]),
            size: 1
        };
    }
    const symbolStyler = await createSymbolStylerElement(popoverNode);
    let edit;
    if (isLine) {
        edit = symbolStylerEdit(symbolStyler, modules.esriLang.clone(defaultSymbol), {
            portal,
            symbolFilter: !(0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.a8)() ? "simple" : undefined,
            sections: {
                stroke: {
                    type: "color",
                    open: true,
                    suggestedColorsOpen: true,
                    suggestedColors: suggestedStrokeColors,
                    extraParts: {
                        width: !sizeAutoVisVar,
                        autoStrokeAdjust: false
                    }
                }
            },
            stroke
        });
    }
    else {
        edit = symbolStylerEdit(symbolStyler, modules.esriLang.clone(defaultSymbol), {
            portal,
            symbolFilter: isPolygon && !(0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.a8)() ? "simple" : undefined,
            sections: {
                marker: isPointCIM || ["simple-marker", "picture-marker"].indexOf(defaultSymbol.type) > -1
                    ? {
                        open: true,
                        parts: {
                            size: !sizeAutoVisVar
                        },
                        symbolsOpen: true,
                        sizeOpen: true,
                        markerType: (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.a8)() ? "all" : ["simple", "picture"]
                    }
                    : undefined,
                fill: {
                    type: "color",
                    open: true,
                    optional: true,
                    suggestedColorsOpen: true,
                    suggestedColors: suggestedFillColors
                },
                stroke: {
                    type: "color",
                    optional: true,
                    suggestedColors: suggestedStrokeColors,
                    extraParts: {
                        style: ["simple-marker", "picture-marker", "cim"].indexOf(defaultSymbol.type) === -1,
                        width: true,
                        autoStrokeAdjust: false
                    }
                }
            },
            fill: {
                color: (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.t)(defaultSymbol) || new modules.esriColor([128, 128, 128])
            },
            marker: isPoint
                ? {
                    size: (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.T)(defaultSymbol)
                }
                : undefined,
            stroke,
            fillEnabled,
            strokeEnabled
        });
    }
    symbolStyler.addEventListener("arcgisSymbolStylerEdit", onStylerEditWrapper.bind(null, onStylerEdit));
    popoverNode.addStyler(symbolStyler);
    await edit;
}
async function buildSymbolStylerForClassed(options) {
    var _a, _b;
    const { layer, mapImageSublayer, mapView, classedSymbolSelectedIdx, portal, modules } = _raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.s;
    const { onChange, popoverNode } = options;
    const isPoint = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.A)(layer);
    const isLine = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.B)(layer);
    const isPolygon = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.q)(layer);
    const renderer = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.h)(layer);
    const rendererType = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.g)();
    const sizeAutoVisVar = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.a)(renderer, "size", "auto");
    const sizeOutlineVisVar = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.a)(renderer, "size", "outline");
    // it takes the first symbol as a reference
    let symbol = ((_a = renderer.classBreakInfos) === null || _a === void 0 ? void 0 : _a.length)
        ? modules.esriLang.clone(renderer.classBreakInfos[classedSymbolSelectedIdx].symbol)
        : (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.S)(layer, mapView, rendererType);
    if (!isSupportedSymbol(symbol)) {
        symbol = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.S)(layer, mapView, rendererType);
    }
    // ensure initial size is correct on the symbol styler
    if (sizeAutoVisVar) {
        (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.U)(symbol, getSizeByScale(sizeAutoVisVar, mapView.scale));
    }
    const fillEnabled = symbol.type === "picture-marker" ? false : !!symbol.color;
    const strokeEnabled = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.a5)(symbol);
    const isPointCIM = symbol.type === "cim" && symbol.data.symbol.type === "CIMPointSymbol";
    const suggestedFillColors = getAllColors();
    const suggestedStrokeColors = getAllColorsReversed();
    const onStylerEdit = ({ detail: { symbol, info: { marker, stroke /* , fill */ } } }) => {
        const renderer = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.h)(layer);
        const infos = renderer.classBreakInfos.slice();
        const info = infos[classedSymbolSelectedIdx];
        const size = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.T)(info.symbol);
        info.symbol = symbol;
        renderer.classBreakInfos = infos;
        if (rendererType === "size") {
            (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.U)(info.symbol, size);
            onChange();
        }
        else {
            updateAutoVisVar(symbol, marker === null || marker === void 0 ? void 0 : marker.autoAdjusted, stroke === null || stroke === void 0 ? void 0 : stroke.autoAdjusted, symbolStyler, options);
        }
    };
    let stroke;
    if (symbol.type === "simple-fill") {
        const sym = symbol;
        if (sym.outline) {
            stroke = {
                color: sym.outline.color ? sym.outline.color : new modules.esriColor([0, 0, 0, 0.5]),
                size: sym.outline.width,
                style: sym.outline.style,
                autoAdjusted: !!sizeOutlineVisVar
            };
        }
        else {
            stroke = {
                color: new modules.esriColor([0, 0, 0, 0.5]),
                size: 1,
                style: "solid",
                autoAdjusted: !!sizeOutlineVisVar
            };
        }
    }
    else if (symbol.type === "simple-marker") {
        const sym = symbol;
        if (sym.outline) {
            stroke = {
                color: sym.outline.color ? sym.outline.color : new modules.esriColor([0, 0, 0, 0.5]),
                size: sym.outline.width
            };
        }
        else {
            stroke = {
                color: new modules.esriColor([0, 0, 0, 0.5]),
                size: 1
            };
        }
    }
    else if (symbol.type === "cim") {
        stroke = getCimLineProps(symbol);
    }
    else if (symbol.type === "simple-line") {
        const sym = symbol;
        stroke = {
            size: sym.width,
            style: sym.style,
            marker: sym.marker,
            color: sym.color ? sym.color : new modules.esriColor([0, 0, 0, 0.5])
        };
    }
    else {
        stroke = {
            color: new modules.esriColor([255, 255, 255, 0.5]),
            size: 1
        };
    }
    const symbolStyler = await createSymbolStylerElement(popoverNode);
    let edit;
    if (isLine) {
        edit = symbolStylerEdit(symbolStyler, modules.esriLang.clone(symbol), {
            portal,
            symbolFilter: !(0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.a8)() ? "simple" : undefined,
            sections: {
                stroke: {
                    type: "color",
                    open: true,
                    suggestedColorsOpen: true,
                    suggestedColors: suggestedFillColors,
                    extraParts: {
                        style: symbol.type !== "cim",
                        arrow: symbol.type !== "cim",
                        width: rendererType !== "size",
                        autoStrokeAdjust: !mapImageSublayer && rendererType !== "size" ? "editable" : false
                    },
                    parts: {
                        extra: (rendererType !== "size" && !sizeAutoVisVar) || symbol.type !== "cim"
                    }
                }
            },
            stroke
        });
    }
    else {
        edit = symbolStylerEdit(symbolStyler, modules.esriLang.clone(symbol), {
            portal,
            symbolFilter: isPolygon && !(0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.a8)() ? "simple" : undefined,
            sections: {
                marker: isPointCIM || ["simple-marker", "picture-marker"].indexOf(symbol.type) > -1
                    ? {
                        open: true,
                        parts: {
                            size: rendererType !== "size" ? (mapImageSublayer ? true : { autoSizeAdjust: "editable" }) : false
                        },
                        symbolsOpen: true,
                        sizeOpen: rendererType !== "size",
                        markerType: (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.a8)() ? "all" : ["simple", "picture"]
                    }
                    : undefined,
                fill: {
                    type: "color",
                    open: true,
                    optional: true,
                    suggestedColorsOpen: true,
                    transparencyOpen: (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.a6)(symbol),
                    suggestedColors: suggestedFillColors
                },
                stroke: {
                    type: "color",
                    optional: true,
                    suggestedColors: suggestedStrokeColors,
                    extraParts: {
                        style: ["simple-marker", "picture-marker", "cim"].indexOf(symbol.type) === -1,
                        width: true,
                        autoStrokeAdjust: !mapImageSublayer && isPolygon && symbol.type !== "cim" && rendererType !== "size" ? "editable" : false
                    }
                }
            },
            fill: {
                color: (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.t)(symbol) || adjustAlpha(suggestedFillColors[1], 0.85)
            },
            marker: isPoint
                ? {
                    size: (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.T)(symbol),
                    autoAdjusted: !!sizeAutoVisVar
                }
                : undefined,
            stroke,
            fillEnabled,
            strokeEnabled
        });
    }
    symbolStyler.addEventListener("arcgisSymbolStylerEdit", onStylerEditWrapper.bind(null, onStylerEdit));
    popoverNode.addStyler(symbolStyler);
    await edit;
    if (rendererType !== "size") {
        return createWatchScaleHandle(((_b = renderer.classBreakInfos) === null || _b === void 0 ? void 0 : _b.length) ? renderer.classBreakInfos[0].symbol : undefined, symbolStyler);
    }
}
async function buildSymbolStylerForColorSizeAbove(options) {
    await buildSymbolStylerForColorSize(Object.assign(Object.assign({}, options), { type: "above" }));
}
async function buildSymbolStylerForColorSizeBelow(options) {
    await buildSymbolStylerForColorSize(Object.assign(Object.assign({}, options), { type: "below" }));
}
async function buildSymbolStylerForColorSize(options) {
    var _a, _b;
    const { layer, mapView, portal, modules } = _raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.s;
    const { onChange, popoverNode } = options;
    const renderer = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.h)(layer);
    const colorVisVar = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.a)(renderer, "color");
    const isAbove = options.type === "above";
    let symbol = ((_b = (_a = renderer.classBreakInfos) === null || _a === void 0 ? void 0 : _a[isAbove ? 1 : 0]) === null || _b === void 0 ? void 0 : _b.symbol) || (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.S)(layer, mapView, "color-size");
    if (!isSupportedSymbol(symbol)) {
        symbol = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.S)(layer, mapView, "color-size");
    }
    const fillEnabled = symbol.type === "picture-marker" ? false : !!symbol.color;
    const strokeEnabled = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.a5)(symbol);
    // TODO get current scheme
    const suggestedFillColors = getAllColors();
    const suggestedStrokeColors = symbol.type === "simple-line" ? getAllColors() : getAllColorsReversed();
    const onStylerEdit = ({ detail: { symbol /* ,
    info: { marker, stroke, fill } */ } }) => {
        const renderer = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.h)(layer);
        renderer.authoringInfo.univariateSymbolStyle = "custom";
        const infos = renderer.classBreakInfos.slice();
        const info = infos[isAbove ? 1 : 0];
        info.symbol = symbol;
        renderer.classBreakInfos = infos;
        onChange();
    };
    let stroke;
    if (symbol.type === "simple-marker") {
        const sym = symbol;
        if (sym.outline) {
            stroke = {
                color: sym.outline.color ? sym.outline.color : new modules.esriColor([0, 0, 0, 0.5]),
                size: sym.outline.width
            };
        }
        else {
            stroke = {
                color: new modules.esriColor([0, 0, 0, 0.5]),
                size: 1
            };
        }
    }
    else if (symbol.type === "simple-line") {
        const sym = symbol;
        stroke = {
            color: sym.color,
            size: sym.width,
            style: sym.style,
            marker: sym.marker
        };
    }
    else if (symbol.type === "cim") {
        stroke = getCimLineProps(symbol);
    }
    else {
        stroke = {
            color: new modules.esriColor([255, 255, 255, 0.5]),
            size: 1
        };
    }
    const symbolStyler = await createSymbolStylerElement(popoverNode);
    const edit = symbolStylerEdit(symbolStyler, modules.esriLang.clone(symbol), {
        portal,
        sections: {
            marker: colorVisVar && ["simple-marker", "cim"].indexOf(symbol.type) > -1
                ? {
                    open: true,
                    parts: {
                        size: false
                    },
                    symbolsOpen: true,
                    sizeOpen: false,
                    markerType: (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.a8)() ? ["simple", "cim:vector"] : ["simple"]
                }
                : !colorVisVar && ["simple-marker", "picture-marker", "cim"].indexOf(symbol.type) > -1
                    ? {
                        open: true,
                        parts: {
                            size: false
                        },
                        symbolsOpen: true,
                        sizeOpen: false
                    }
                    : undefined,
            fill: !colorVisVar
                ? {
                    type: "color",
                    open: true,
                    optional: true,
                    suggestedColorsOpen: true,
                    transparencyOpen: (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.a6)(symbol),
                    suggestedColors: suggestedFillColors
                }
                : undefined,
            stroke: !colorVisVar
                ? {
                    type: "color",
                    optional: true,
                    suggestedColors: suggestedStrokeColors,
                    extraParts: {
                        style: ["simple-marker", "picture-marker", "cim"].indexOf(symbol.type) === -1,
                        width: true,
                        autoStrokeAdjust: false
                    }
                }
                : undefined
        },
        fill: !colorVisVar
            ? {
                color: (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.t)(symbol) || adjustAlpha(suggestedFillColors[1], 0.85)
            }
            : undefined,
        marker: {
            size: (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.T)(symbol)
        },
        stroke,
        fillEnabled,
        strokeEnabled
    });
    symbolStyler.addEventListener("arcgisSymbolStylerEdit", onStylerEditWrapper.bind(null, onStylerEdit));
    popoverNode.addStyler(symbolStyler);
    await edit;
}
async function buildSymbolStylerForSimple(options) {
    const { layer, mapImageSublayer, mapView, portal, modules } = _raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.s;
    const { /* onChange, */ popoverNode } = options;
    const isOGCLayer = layer.type === "ogc-feature";
    const isPoint = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.A)(layer);
    const isLine = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.B)(layer);
    const isPolygon = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.q)(layer);
    const renderer = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.h)(layer);
    const sizeAutoVisVar = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.a)(renderer, "size", "auto");
    const sizeOutlineVisVar = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.a)(renderer, "size", "outline");
    let symbol = renderer.symbol;
    if (!isSupportedSymbol(symbol)) {
        symbol = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.S)(layer, mapView);
    }
    const fillEnabled = symbol.type === "picture-marker" ? false : !!symbol.color;
    const strokeEnabled = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.a5)(symbol);
    const isPointCIM = symbol.type === "cim" && symbol.data.symbol.type === "CIMPointSymbol";
    const suggestedFillColors = getAllColors();
    const suggestedStrokeColors = symbol.type === "simple-line" ? getAllColors() : getAllColorsReversed();
    const onStylerEdit = ({ detail: { symbol, info: { marker, stroke /* , fill */ } } }) => {
        const renderer = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.h)(layer);
        renderer.symbol = symbol;
        updateAutoVisVar(symbol, marker === null || marker === void 0 ? void 0 : marker.autoAdjusted, stroke === null || stroke === void 0 ? void 0 : stroke.autoAdjusted, symbolStyler, options);
    };
    let stroke;
    if (symbol.type === "simple-fill") {
        const sym = symbol;
        if (sym.outline) {
            stroke = {
                color: sym.outline.color ? sym.outline.color : new modules.esriColor([0, 0, 0, 0.5]),
                size: sym.outline.width,
                style: sym.outline.style,
                autoAdjusted: !!sizeOutlineVisVar
            };
        }
        else {
            stroke = {
                color: new modules.esriColor([0, 0, 0, 0.5]),
                size: 1,
                style: "solid"
            };
        }
    }
    else if (symbol.type === "simple-marker") {
        const sym = symbol;
        if (sym.outline) {
            stroke = {
                color: sym.outline.color ? sym.outline.color : new modules.esriColor([0, 0, 0, 0.5]),
                size: sym.outline.width
            };
        }
        else {
            stroke = {
                color: new modules.esriColor([0, 0, 0, 0.5]),
                size: 1
            };
        }
    }
    else if (symbol.type === "simple-line") {
        const sym = symbol;
        stroke = {
            color: sym.color,
            size: sizeAutoVisVar ? getSizeByScale(sizeAutoVisVar, mapView.scale) : sym.width,
            style: sym.style,
            marker: sym.marker,
            autoAdjusted: !!sizeAutoVisVar
        };
    }
    else if (symbol.type === "cim") {
        stroke = getCimLineProps(symbol);
        if (isLine) {
            (stroke.size = sizeAutoVisVar ? getSizeByScale(sizeAutoVisVar, mapView.scale) : stroke.size),
                (stroke.autoAdjusted = !!sizeAutoVisVar);
            if (sizeAutoVisVar) {
                // adjusts symbol so all symbol layers fit
                (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.U)(symbol, stroke.size);
            }
        }
    }
    else {
        stroke = {
            color: new modules.esriColor([255, 255, 255, 0.5]),
            size: 1
        };
    }
    const symbolStyler = await createSymbolStylerElement(popoverNode);
    let edit;
    if (isLine) {
        edit = symbolStylerEdit(symbolStyler, modules.esriLang.clone(symbol), {
            portal,
            symbolFilter: !(0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.a8)() ? "simple" : undefined,
            sections: {
                stroke: {
                    type: "color",
                    optional: symbol.type === "cim",
                    open: true,
                    suggestedColorsOpen: true,
                    suggestedColors: suggestedStrokeColors,
                    extraParts: {
                        style: symbol.type !== "cim",
                        arrow: symbol.type !== "cim",
                        width: true,
                        autoStrokeAdjust: isOGCLayer || mapImageSublayer ? false : "editable"
                    }
                }
            },
            stroke
        });
    }
    else {
        edit = symbolStylerEdit(symbolStyler, modules.esriLang.clone(symbol), {
            portal,
            symbolFilter: isPolygon && !(0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.a8)() ? "simple" : undefined,
            sections: {
                marker: isPointCIM || ["simple-marker", "picture-marker"].indexOf(symbol.type) > -1
                    ? {
                        open: true,
                        symbolsOpen: true,
                        sizeOpen: true,
                        parts: {
                            size: { autoSizeAdjust: isOGCLayer || mapImageSublayer ? false : "editable" }
                        },
                        markerType: (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.a8)() ? "all" : ["simple", "picture"]
                    }
                    : undefined,
                fill: {
                    type: "color",
                    optional: true,
                    open: true,
                    suggestedColorsOpen: true,
                    transparencyOpen: (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.a6)(symbol),
                    suggestedColors: suggestedFillColors
                },
                stroke: {
                    type: "color",
                    optional: true,
                    suggestedColors: suggestedStrokeColors,
                    extraParts: {
                        style: ["simple-marker", "picture-marker", "cim"].indexOf(symbol.type) === -1,
                        width: true,
                        autoStrokeAdjust: !isOGCLayer && !mapImageSublayer && isPolygon && symbol.type !== "cim" ? "editable" : false
                    }
                }
            },
            fill: {
                color: (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.t)(symbol) || adjustAlpha(suggestedFillColors[1], 0.85)
            },
            marker: isPoint
                ? {
                    size: sizeAutoVisVar ? getSizeByScale(sizeAutoVisVar, mapView.scale) : (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.T)(symbol),
                    autoAdjusted: !mapImageSublayer && !!sizeAutoVisVar
                }
                : undefined,
            stroke,
            fillEnabled,
            strokeEnabled
        });
    }
    symbolStyler.addEventListener("arcgisSymbolStylerEdit", onStylerEditWrapper.bind(null, onStylerEdit));
    popoverNode.addStyler(symbolStyler);
    await edit;
    return createWatchScaleHandle(renderer.symbol, symbolStyler);
}
async function buildSymbolStylerForGeoRSS(type, options) {
    const { layer, mapView, portal, modules } = _raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.s;
    const { onChange, popoverNode } = options;
    const geoRSSLayer = layer;
    const isPoint = type === "point";
    const isLine = type === "line";
    //const isPolygon = type === "polygon";
    let symbol = isPoint ? geoRSSLayer.pointSymbol : isLine ? geoRSSLayer.lineSymbol : geoRSSLayer.polygonSymbol;
    if (!isSupportedSymbol(symbol)) {
        symbol = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.ah)(mapView, type);
    }
    const fillEnabled = symbol.type === "picture-marker" ? false : !!symbol.color;
    const strokeEnabled = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.a5)(symbol);
    const suggestedFillColors = getAllColors();
    const suggestedStrokeColors = symbol.type === "simple-line" ? getAllColors() : getAllColorsReversed();
    const onStylerEdit = ({ detail: { symbol /* ,
    info: { marker, stroke, fill } */ } }) => {
        if (isPoint) {
            geoRSSLayer.pointSymbol = symbol;
        }
        else if (isLine) {
            geoRSSLayer.lineSymbol = symbol;
        }
        else {
            geoRSSLayer.polygonSymbol = symbol;
        }
        onChange();
    };
    let stroke;
    if (symbol.type === "simple-fill") {
        const sym = symbol;
        if (sym.outline) {
            stroke = {
                color: sym.outline.color ? sym.outline.color : new modules.esriColor([0, 0, 0, 0.5]),
                size: sym.outline.width,
                style: sym.outline.style,
                autoAdjusted: false
            };
        }
        else {
            stroke = {
                color: new modules.esriColor([0, 0, 0, 0.5]),
                size: 1,
                style: "solid"
            };
        }
    }
    else if (symbol.type === "simple-marker") {
        const sym = symbol;
        if (sym.outline) {
            stroke = {
                color: sym.outline.color ? sym.outline.color : new modules.esriColor([0, 0, 0, 0.5]),
                size: sym.outline.width
            };
        }
        else {
            stroke = {
                color: new modules.esriColor([0, 0, 0, 0.5]),
                size: 1
            };
        }
    }
    else if (symbol.type === "simple-line") {
        const sym = symbol;
        stroke = {
            color: sym.color,
            size: sym.width,
            style: sym.style,
            marker: sym.marker,
            autoAdjusted: false
        };
        //} else if (symbol.type === "cim") {
        //  stroke = getCimLineProps(symbol);
    }
    else {
        stroke = {
            color: new modules.esriColor([255, 255, 255, 0.5]),
            size: 1
        };
    }
    const symbolStyler = await createSymbolStylerElement(popoverNode);
    let edit;
    if (isLine) {
        edit = symbolStylerEdit(symbolStyler, modules.esriLang.clone(symbol), {
            portal,
            sections: {
                stroke: {
                    type: "color",
                    open: true,
                    suggestedColorsOpen: true,
                    suggestedColors: suggestedStrokeColors,
                    extraParts: {
                        width: true,
                        autoStrokeAdjust: false
                    }
                }
            },
            stroke
        });
    }
    else {
        edit = symbolStylerEdit(symbolStyler, modules.esriLang.clone(symbol), {
            portal,
            sections: {
                marker: ["simple-marker", "picture-marker"].indexOf(symbol.type) > -1
                    ? {
                        open: true,
                        symbolsOpen: true,
                        sizeOpen: true,
                        markerType: ["simple", "picture"]
                    }
                    : undefined,
                fill: {
                    type: "color",
                    optional: true,
                    open: true,
                    suggestedColorsOpen: true,
                    transparencyOpen: (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.a6)(symbol),
                    suggestedColors: suggestedFillColors
                },
                stroke: {
                    type: "color",
                    optional: true,
                    suggestedColors: suggestedStrokeColors,
                    extraParts: {
                        style: ["simple-marker", "picture-marker", "cim"].indexOf(symbol.type) === -1,
                        width: true,
                        autoStrokeAdjust: false
                    }
                }
            },
            fill: {
                color: (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.t)(symbol) || adjustAlpha(suggestedFillColors[1], 0.85)
            },
            marker: isPoint
                ? {
                    size: (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.T)(symbol),
                    autoAdjusted: false
                }
                : undefined,
            stroke,
            fillEnabled,
            strokeEnabled
        });
    }
    symbolStyler.addEventListener("arcgisSymbolStylerEdit", onStylerEditWrapper.bind(null, onStylerEdit));
    popoverNode.addStyler(symbolStyler);
    await edit;
}
async function buildSymbolStylerForSize(options) {
    var _a, _b;
    const { layer, mapView, portal, modules } = _raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.s;
    const { onChange, popoverNode } = options;
    const isLine = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.B)(layer);
    const renderer = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.h)(layer);
    const rendererType = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.g)();
    const colorVisVar = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.a)(renderer, "color");
    const isBivariatRenderer = ["type-size", "type-size-age", "predominance-size", "relationship-size"].indexOf(rendererType) > -1;
    let symbol;
    if (isBivariatRenderer) {
        const uvRenderer = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.h)(layer);
        symbol = ((_a = uvRenderer.uniqueValueInfos) === null || _a === void 0 ? void 0 : _a.length)
            ? uvRenderer.uniqueValueInfos[0].symbol
            : (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.S)(layer, mapView, rendererType);
    }
    else {
        symbol = ((_b = renderer.classBreakInfos) === null || _b === void 0 ? void 0 : _b.length)
            ? renderer.classBreakInfos[0].symbol
            : (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.S)(layer, mapView, rendererType);
    }
    if (!isSupportedSymbol(symbol)) {
        symbol = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.S)(layer, mapView, rendererType);
    }
    const fillEnabled = symbol.type === "picture-marker" ? false : !!symbol.color;
    const strokeEnabled = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.a5)(symbol);
    const isPointCIM = symbol.type === "cim" && symbol.data.symbol.type === "CIMPointSymbol";
    // TODO get current scheme
    const suggestedFillColors = getAllColors();
    const suggestedStrokeColors = symbol.type === "simple-line" ? getAllColors() : getAllColorsReversed();
    const onStylerEdit = ({ detail: { symbol /* ,
    info: { marker, stroke, fill } */ } }) => {
        const renderer = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.h)(layer);
        if (renderer.classBreakInfos) {
            let infos = renderer.classBreakInfos;
            if (!infos || !infos.length) {
                // we have no place to save those changes
                return;
            }
            // make a copy so modules.esriLang.clone() works later
            infos = infos.slice();
            infos.forEach((info) => {
                const size = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.T)(info.symbol);
                const color = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.t)(info.symbol);
                info.symbol = symbol.clone();
                if (colorVisVar) {
                    // we want the only break symbol to always be grey
                    (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.r)(info.symbol, new modules.esriColor([0, 0, 0, 0.5]));
                }
                else if (renderer.uniqueValueInfos) {
                    // we want to keep the old color
                    (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.r)(info.symbol, color);
                }
                (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.U)(info.symbol, size);
            });
            renderer.classBreakInfos = infos;
        }
        else {
            let groups = renderer.uniqueValueGroups;
            if (!groups || !groups.length || !groups[0].classes || !groups[0].classes.length) {
                // we have no place to save those changes
                return;
            }
            // make a copy so modules.esriLang.clone() works later
            groups = groups.slice();
            groups.forEach((group) => {
                group.classes.forEach((uniqueValueClass) => {
                    const size = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.T)(uniqueValueClass.symbol);
                    const color = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.t)(uniqueValueClass.symbol);
                    uniqueValueClass.symbol = symbol.clone();
                    if (colorVisVar) {
                        // we want the only break symbol to always be grey
                        (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.r)(uniqueValueClass.symbol, new modules.esriColor([0, 0, 0, 0.5]));
                    }
                    else {
                        // we want to keep the old color
                        (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.r)(uniqueValueClass.symbol, color);
                    }
                    (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.U)(uniqueValueClass.symbol, size);
                });
            });
            renderer.uniqueValueGroups = groups;
        }
        onChange();
    };
    let stroke;
    if (symbol.type === "simple-fill") {
        const sym = symbol;
        if (sym.outline) {
            stroke = {
                color: sym.outline.color ? sym.outline.color : new modules.esriColor([0, 0, 0, 0.5]),
                size: sym.outline.width,
                style: sym.outline.style
            };
        }
        else {
            stroke = {
                color: new modules.esriColor([0, 0, 0, 0.5]),
                size: 1,
                style: "solid"
            };
        }
    }
    else if (symbol.type === "simple-marker") {
        const sym = symbol;
        if (sym.outline) {
            stroke = {
                color: sym.outline.color ? sym.outline.color : new modules.esriColor([0, 0, 0, 0.5]),
                size: sym.outline.width
            };
        }
        else {
            stroke = {
                color: new modules.esriColor([0, 0, 0, 0.5]),
                size: 1
            };
        }
    }
    else if (symbol.type === "simple-line") {
        const sym = symbol;
        stroke = {
            color: sym.color,
            size: sym.width,
            style: sym.style,
            marker: sym.marker
        };
    }
    else if (symbol.type === "cim") {
        stroke = getCimLineProps(symbol);
    }
    else {
        stroke = {
            color: new modules.esriColor([255, 255, 255, 0.5]),
            size: 1
        };
    }
    const symbolStyler = await createSymbolStylerElement(popoverNode);
    let edit;
    if ([
        "color-size",
        "color-age-size",
        "color-size-age",
        "type-size",
        "type-size-age",
        "predominance-size",
        "relationship-size"
    ].indexOf((0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.g)()) > -1) {
        // no changes to color
        if (isLine) {
            // no changes to line width
            // TODO need to hide 2 color subsections
            edit = symbolStylerEdit(symbolStyler, modules.esriLang.clone(symbol), {
                portal,
                symbolFilter: !(0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.a8)() ? "simple" : undefined,
                sections: {
                    stroke: {
                        type: "color",
                        open: true,
                        extraOpen: true,
                        extraParts: {
                            style: symbol.type !== "cim",
                            arrow: symbol.type !== "cim",
                            width: false,
                            autoStrokeAdjust: false
                        },
                        suggestedColors: suggestedStrokeColors,
                        parts: {
                            suggestedColors: false,
                            customColor: false,
                            transparency: true,
                            extra: symbol.type !== "cim"
                        }
                    }
                },
                stroke
            });
        }
        else {
            edit = symbolStylerEdit(symbolStyler, modules.esriLang.clone(symbol), {
                portal,
                sections: {
                    marker: isPointCIM || ["simple-marker", "picture-marker"].indexOf(symbol.type) > -1
                        ? {
                            open: true,
                            parts: {
                                size: false
                            },
                            symbolsOpen: true,
                            sizeOpen: false,
                            markerType: (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.a8)() ? ["simple", "cim:vector"] : ["simple"]
                        }
                        : undefined,
                    stroke: {
                        type: "color",
                        open: true,
                        optional: true,
                        suggestedColors: suggestedStrokeColors,
                        extraParts: {
                            style: ["simple-marker", "picture-marker", "cim"].indexOf(symbol.type) === -1,
                            width: true,
                            autoStrokeAdjust: false
                        }
                    }
                },
                marker: {
                    size: (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.T)(symbol)
                },
                stroke,
                strokeEnabled
            });
        }
    }
    else {
        if (isLine) {
            edit = symbolStylerEdit(symbolStyler, modules.esriLang.clone(symbol), {
                portal,
                symbolFilter: !(0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.a8)() ? "simple" : undefined,
                sections: {
                    stroke: {
                        type: "color",
                        open: true,
                        extraParts: {
                            style: symbol.type !== "cim",
                            arrow: symbol.type !== "cim",
                            width: false,
                            autoStrokeAdjust: false
                        },
                        suggestedColorsOpen: true,
                        suggestedColors: suggestedStrokeColors,
                        parts: {
                            extra: symbol.type !== "cim"
                        }
                    }
                },
                stroke
            });
        }
        else {
            // rendererType === "size"
            edit = symbolStylerEdit(symbolStyler, modules.esriLang.clone(symbol), {
                portal,
                sections: {
                    marker: isPointCIM || ["simple-marker", "picture-marker"].indexOf(symbol.type) > -1
                        ? {
                            open: true,
                            parts: {
                                size: false
                            },
                            symbolsOpen: true,
                            sizeOpen: false,
                            markerType: (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.a8)() ? "all" : ["simple", "picture"]
                        }
                        : undefined,
                    fill: {
                        type: "color",
                        open: true,
                        optional: true,
                        suggestedColorsOpen: true,
                        transparencyOpen: (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.a6)(symbol),
                        suggestedColors: suggestedFillColors
                    },
                    stroke: {
                        type: "color",
                        optional: true,
                        suggestedColors: suggestedStrokeColors,
                        extraParts: {
                            style: ["simple-marker", "picture-marker", "cim"].indexOf(symbol.type) === -1,
                            width: true,
                            autoStrokeAdjust: false
                        }
                    }
                },
                fill: {
                    color: (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.t)(symbol) || adjustAlpha(suggestedFillColors[1], 0.85)
                },
                marker: {
                    size: (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.T)(symbol)
                },
                stroke,
                fillEnabled,
                strokeEnabled
            });
        }
    }
    symbolStyler.addEventListener("arcgisSymbolStylerEdit", onStylerEditWrapper.bind(null, onStylerEdit));
    popoverNode.addStyler(symbolStyler);
    await edit;
}
async function buildSymbolStylerForColorRamp(options) {
    var _a, _b, _c, _d;
    const { layer, mapImageSublayer, mapView, portal, modules } = _raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.s;
    const { onChange, popoverNode } = options;
    const isPoint = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.A)(layer);
    const isLine = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.B)(layer);
    const isPolygon = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.q)(layer);
    const renderer = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.h)(layer);
    const authInfo = renderer.authoringInfo;
    const rendererType = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.g)();
    const isUnivariate = (authInfo === null || authInfo === void 0 ? void 0 : authInfo.type) === "univariate-color-size";
    const isAboveAndBelow = (authInfo === null || authInfo === void 0 ? void 0 : authInfo.univariateTheme) === "above-and-below";
    // e.g. line layers don't support symbol pairs for univariate above-and-below
    const isAboveAndBelowSingle = isAboveAndBelow && !authInfo.univariateSymbolStyle;
    const colorVisVar = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.a)((0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.h)(layer), "color");
    const sizeAutoVisVar = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.a)(renderer, "size", "auto");
    const sizeOutlineVisVar = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.a)(renderer, "size", "outline");
    const isColorSize = ["color-size", "color-age-size", "color-size-age"].indexOf(rendererType) > -1;
    const authColorVisVar = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.p)((0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.h)(layer), "color");
    let currentColors = colorVisVar
        ? colorVisVar.stops.map((stop) => stop.color)
        : renderer.classBreakInfos.map((classBreakInfo) => { var _a; return ((_a = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.t)(classBreakInfo.symbol)) === null || _a === void 0 ? void 0 : _a.clone()) || new modules.esriColor([0, 0, 0, 0]); });
    if (currentColors.length > 10) {
        // some ramps have only 10 colors
        currentColors = currentColors.slice(0, 10);
    }
    currentColors.reverse();
    let lastSymbol;
    let symbol = ((_a = renderer.classBreakInfos) === null || _a === void 0 ? void 0 : _a.length) ? renderer.classBreakInfos[0].symbol : (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.S)(layer, mapView);
    if (!isSupportedSymbol(symbol) || ((!isAboveAndBelow || isAboveAndBelowSingle) && !isColoredSymbol(symbol))) {
        const size = (_b = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.T)(symbol)) !== null && _b !== void 0 ? _b : symbol.width;
        symbol = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.S)(layer, mapView, rendererType);
        (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.U)(symbol, size);
    }
    const fillEnabled = isAboveAndBelow &&
        !colorVisVar &&
        symbol.type === "picture-marker" &&
        ((_c = renderer.classBreakInfos[1].symbol) === null || _c === void 0 ? void 0 : _c.type) === "picture-marker"
        ? false
        : true;
    const strokeEnabled = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.a5)(symbol);
    const isPointCIM = symbol.type === "cim" && symbol.data.symbol.type === "CIMPointSymbol";
    const basemapTheme = (await modules.colorUtils.getBackgroundColorTheme(mapView));
    const schemes = modules.colorSchemes.getSchemes({
        basemapTheme,
        geometryType: (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.D)(layer) || defaultGeometry,
        theme: (authInfo === null || authInfo === void 0 ? void 0 : authInfo.univariateTheme) || (authColorVisVar === null || authColorVisVar === void 0 ? void 0 : authColorVisVar.theme) || "high-to-low"
    });
    if (!colorVisVar) {
        // classed
        const moreSchemes = modules.colorSchemes.getSchemes({
            basemap: mapView.map.basemap || "topo",
            geometryType: (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.D)(layer) || defaultGeometry,
            theme: "above-and-below"
        });
        schemes.secondarySchemes.push(moreSchemes.primaryScheme);
        schemes.secondarySchemes = schemes.secondarySchemes.concat(moreSchemes.secondarySchemes);
    }
    // TODO get current scheme
    const num = colorVisVar ? 0 : renderer.classBreakInfos.length;
    let colorRampsAndSchemes = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.a9)(schemes, num);
    // might happen for classed ramps
    colorRampsAndSchemes = colorRampsAndSchemes.filter((obj) => { var _a; return (_a = obj.colors) === null || _a === void 0 ? void 0 : _a.length; });
    const colorRamps = colorRampsAndSchemes.map((obj) => {
        // flip ramps
        return {
            stops: obj.colors.reverse(),
            tags: obj.scheme.tags,
            name: obj.scheme.name
        };
    });
    const suggestedStrokeColors = getAllColorsReversed();
    const onStylerEdit = ({ detail: { symbol, info: { marker, stroke, fill } } }) => {
        const renderer = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.h)(layer);
        const colorVisVar = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.a)(renderer, "color");
        let colors = modules.esriLang.clone((fill || stroke).color);
        // currentColors could have more custom colors than the ramp from styler
        const color0 = currentColors[0];
        const hasColorRampChange = currentColors.length !== colors.length ||
            currentColors.some((color, idx) => color.r !== colors[idx].r || color.g !== colors[idx].g || color.b !== colors[idx].b) ||
            color0.r !== colors[0].r ||
            color0.g !== colors[0].g ||
            color0.b !== colors[0].b;
        const hasAlphaChange = color0.a !== colors[0].a;
        const newAlpha = colors[0].a;
        const symbolChangeInfo = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.am)(symbol, lastSymbol);
        if (hasColorRampChange && !symbolChangeInfo.any) {
            symbolChangeInfo.any = true;
            symbolChangeInfo.color = true;
        }
        if (!isUnivariate || !isAboveAndBelow) {
            colors.reverse();
        }
        if (!isAboveAndBelow || isAboveAndBelowSingle) {
            if (symbolChangeInfo.any) {
                const infos = renderer.classBreakInfos.slice();
                infos.forEach((classBreakInfo, idx) => {
                    classBreakInfo.symbol = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.an)(classBreakInfo.symbol, symbol, hasColorRampChange && !colorVisVar
                        ? colors[idx % colors.length]
                        : hasAlphaChange && !colorVisVar
                            ? (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.ao)((0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.t)(classBreakInfo.symbol), newAlpha)
                            : (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.t)(classBreakInfo.symbol) || new modules.esriColor([0, 0, 0, 0]), symbolChangeInfo);
                });
                renderer.classBreakInfos = infos;
            } // else maybe just an auto size change
        }
        else if (!colorVisVar) {
            // styler does not show marker options
            colors.reverse();
            const infos = renderer.classBreakInfos.slice();
            infos.forEach((classBreakInfo, idx) => {
                (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.r)(classBreakInfo.symbol, colors[idx]);
            });
            renderer.classBreakInfos = infos;
        }
        if (colorVisVar) {
            if (currentColors.length !== colors.length && colors.length === 5) {
                // just pick 5 stops
                const len = colorVisVar.stops.length;
                const newStops = [];
                newStops[0] = colorVisVar.stops[0];
                newStops[1] = colorVisVar.stops[Math.floor(len / 4)];
                newStops[2] = colorVisVar.stops[Math.floor(len / 2)];
                newStops[3] = colorVisVar.stops[len - Math.ceil(len / 4)];
                newStops[4] = colorVisVar.stops[len - 1];
                colorVisVar.stops = newStops;
            }
            colorVisVar.stops.forEach((stop, idx) => {
                stop.color = colors[idx];
            });
            const infos = renderer.classBreakInfos.slice();
            // we want the only break symbol to always be grey
            (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.r)(infos[0].symbol, new modules.esriColor([170, 170, 170, 1]));
            renderer.classBreakInfos = infos;
        }
        if (!isColorSize) {
            updateAutoVisVar(symbol, marker === null || marker === void 0 ? void 0 : marker.autoAdjusted, stroke === null || stroke === void 0 ? void 0 : stroke.autoAdjusted, symbolStyler, options);
        }
        else {
            onChange();
        }
        lastSymbol = symbol.clone();
        currentColors = colorVisVar
            ? colorVisVar.stops.map((stop) => stop.color)
            : renderer.classBreakInfos
                .map((classBreakInfo) => (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.t)(classBreakInfo.symbol) || new modules.esriColor([0, 0, 0, 0]))
                .reverse();
    };
    let stroke;
    if (symbol.type === "simple-fill") {
        const sym = symbol;
        if (sym.outline) {
            stroke = {
                color: sym.outline.color ? sym.outline.color : new modules.esriColor([0, 0, 0, 0.5]),
                size: sym.outline.width,
                style: sym.outline.style,
                autoAdjusted: !!sizeOutlineVisVar
            };
        }
        else {
            stroke = {
                color: new modules.esriColor([0, 0, 0, 0.5]),
                size: 1,
                style: "solid",
                autoAdjusted: !!sizeOutlineVisVar
            };
        }
    }
    else if (symbol.type === "simple-marker") {
        const sym = symbol;
        if (sym.outline) {
            stroke = {
                color: sym.outline.color ? sym.outline.color : new modules.esriColor([0, 0, 0, 0.5]),
                size: sym.outline.width
            };
        }
        else {
            stroke = {
                color: new modules.esriColor([0, 0, 0, 0.5]),
                size: 1
            };
        }
    }
    else if (symbol.type === "cim") {
        stroke = getCimLineProps(symbol);
        if (isLine) {
            (stroke.size = sizeAutoVisVar ? getSizeByScale(sizeAutoVisVar, mapView.scale) : stroke.size),
                (stroke.autoAdjusted = !!sizeAutoVisVar);
            if (sizeAutoVisVar) {
                // adjusts symbol so all symbol layers fit
                (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.U)(symbol, stroke.size);
            }
        }
    }
    else if (symbol.type === "simple-line") {
        const sym = symbol;
        stroke = {
            color: new modules.esriColor([255, 255, 255, 0.5]),
            size: sizeAutoVisVar ? getSizeByScale(sizeAutoVisVar, mapView.scale) : sym.width,
            style: sym.style,
            marker: sym.marker,
            autoAdjusted: !!sizeAutoVisVar
        };
    }
    else {
        stroke = {
            color: new modules.esriColor([255, 255, 255, 0.5]),
            size: 1
        };
    }
    const symbolStyler = await createSymbolStylerElement(popoverNode);
    let edit;
    // apply a few settings to the symbol we pass to the styler
    // so when comparing changes it's correct
    (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.r)(symbol, currentColors[currentColors.length - 1]);
    if ((isColorSize || isPoint || isLine) && sizeAutoVisVar) {
        (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.U)(symbol, getSizeByScale(sizeAutoVisVar, mapView.scale));
    }
    else if (isPolygon && sizeAutoVisVar && symbol.outline) {
        symbol.outline.width = getSizeByScale(sizeAutoVisVar, mapView.scale);
    }
    lastSymbol = symbol.clone();
    if (isLine) {
        edit = symbolStylerEdit(symbolStyler, modules.esriLang.clone(symbol), {
            portal,
            symbolFilter: !(0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.a8)() ? "simple" : undefined,
            sections: {
                stroke: {
                    type: "color-ramp",
                    style: colorVisVar ? "continuous" : "discrete",
                    colorRamps: colorRamps,
                    open: true,
                    colorRampsOpen: true,
                    extraParts: {
                        style: symbol.type !== "cim",
                        arrow: symbol.type !== "cim",
                        autoStrokeAdjust: !mapImageSublayer && !isColorSize ? "editable" : false,
                        width: !isColorSize
                    },
                    parts: {
                        extra: !isColorSize || symbol.type !== "cim"
                    }
                }
            },
            stroke: Object.assign(Object.assign({}, stroke), { color: currentColors })
        });
    }
    else {
        edit = symbolStylerEdit(symbolStyler, !isAboveAndBelow || isAboveAndBelowSingle /* && (isColorSize || isPoint) */
            ? modules.esriLang.clone(symbol)
            : (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.S)(layer, mapView), {
            portal,
            symbolFilter: isPolygon && !(0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.a8)() ? "simple" : undefined,
            sections: {
                marker: (!isAboveAndBelow || isAboveAndBelowSingle) &&
                    (isPointCIM || ["simple-marker", "picture-marker"].indexOf(symbol.type) > -1)
                    ? {
                        open: true,
                        parts: {
                            size: !isColorSize ? (mapImageSublayer ? true : { autoSizeAdjust: "editable" }) : false
                        },
                        symbolsOpen: true,
                        sizeOpen: !isColorSize,
                        markerType: (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.a8)() ? ["simple", "cim:vector"] : ["simple"]
                    }
                    : isAboveAndBelow && !isAboveAndBelowSingle
                        ? {
                            parts: {
                                preview: false,
                                rotation: false,
                                size: false
                            }
                        }
                        : undefined,
                fill: {
                    type: "color-ramp",
                    style: colorVisVar ? "continuous" : "discrete",
                    open: (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.ai)(symbol) ? false : true,
                    colorRampsOpen: (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.ai)(symbol) ? false : true,
                    colorRamps
                },
                stroke: !isAboveAndBelow || isAboveAndBelowSingle
                    ? {
                        type: "color",
                        optional: true,
                        open: false,
                        //open: isLineMarker(symbol) ? true : false, we need the ramps there...
                        suggestedColors: suggestedStrokeColors,
                        //suggestedColorsOpen: isLineMarker(symbol) ? true : false, we need the ramps there...
                        extraParts: {
                            style: ["simple-marker", "picture-marker", "cim"].indexOf(symbol.type) === -1,
                            width: true,
                            autoStrokeAdjust: !mapImageSublayer && isPolygon && symbol.type !== "cim" && !isColorSize ? "editable" : false
                        }
                    }
                    : undefined
            },
            fill: {
                color: currentColors
            },
            marker: (!isAboveAndBelow || isAboveAndBelowSingle) && (isColorSize || isPoint)
                ? {
                    size: sizeAutoVisVar ? getSizeByScale(sizeAutoVisVar, mapView.scale) : (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.T)(symbol),
                    autoAdjusted: !!sizeAutoVisVar
                }
                : undefined,
            stroke,
            strokeEnabled,
            fillEnabled // if false it doesn't seem to do anything
        });
    }
    symbolStyler.addEventListener("arcgisSymbolStylerEdit", onStylerEditWrapper.bind(null, onStylerEdit));
    popoverNode.addStyler(symbolStyler);
    await edit;
    return createWatchScaleHandle(((_d = renderer.classBreakInfos) === null || _d === void 0 ? void 0 : _d.length) ? renderer.classBreakInfos[0].symbol : undefined, symbolStyler, (newSize) => {
        isPolygon && symbol.outline ? (symbol.outline.width = newSize) : !isPolygon && (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.U)(symbol, newSize);
        lastSymbol = symbol.clone();
    });
}
async function buildSymbolStylerForTypeRamp(options) {
    var _a, _b, _c, _d, _e;
    const { layer, mapImageSublayer, mapView, portal, modules } = _raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.s;
    const { onChange, popoverNode } = options;
    const isPoint = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.A)(layer);
    const isLine = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.B)(layer);
    const isPolygon = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.q)(layer);
    const renderer = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.h)(layer);
    const rendererType = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.g)();
    const isTypeSize = ["type-size", "type-size-age"].indexOf(rendererType) > -1;
    const sizeAutoVisVar = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.a)(renderer, "size", "auto");
    const sizeOutlineVisVar = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.a)(renderer, "size", "outline");
    const uniqueValueGroups = renderer.uniqueValueGroups;
    let lastSymbol;
    let currentColors = [];
    const lastGroup = uniqueValueGroups.length ? uniqueValueGroups[uniqueValueGroups.length - 1] : undefined;
    let alpha = (((_a = lastGroup === null || lastGroup === void 0 ? void 0 : lastGroup.classes) === null || _a === void 0 ? void 0 : _a.length) && ((_b = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.t)(lastGroup.classes[lastGroup.classes.length - 1].symbol)) === null || _b === void 0 ? void 0 : _b.a)) || 1;
    uniqueValueGroups.forEach((group) => (currentColors = currentColors.concat(group.classes.map((uniqueValueClass) => (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.t)(uniqueValueClass.symbol) || new modules.esriColor([0, 0, 0, alpha]) // TODO panel displays color from default ramp, not black
    ))));
    currentColors.reverse();
    if (currentColors.length > 10) {
        // some ramps have only 10 colors
        currentColors = currentColors.slice(0, 10);
    }
    const schemes = modules.typeSchemes.getSchemes({
        basemap: mapView.map.basemap,
        geometryType: (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.D)(layer) || defaultGeometry
    });
    // it takes the first symbol as a reference
    let symbol = ((_c = renderer.uniqueValueGroups) === null || _c === void 0 ? void 0 : _c.length) && renderer.uniqueValueGroups[0].classes.length
        ? modules.esriLang.clone(renderer.uniqueValueGroups[0].classes[0].symbol)
        : (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.S)(layer, mapView, rendererType);
    if (!isColoredSymbol(symbol)) {
        const size = (_d = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.T)(symbol)) !== null && _d !== void 0 ? _d : symbol.width;
        symbol = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.S)(layer, mapView, rendererType);
        (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.U)(symbol, size);
    }
    const strokeEnabled = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.a5)(symbol);
    const isPointCIM = symbol.type === "cim" && symbol.data.symbol.type === "CIMPointSymbol";
    // TODO get current scheme
    let numClasses = 0;
    uniqueValueGroups.forEach((group) => (numClasses += group.classes.length));
    const colorRampsAndSchemes = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.a9)(schemes, Math.min(numClasses, 10));
    const colorRamps = colorRampsAndSchemes.map((obj) => {
        return {
            stops: obj.colors.reverse(),
            tags: obj.scheme.tags,
            name: obj.scheme.name
        };
    });
    const suggestedStrokeColors = getAllColorsReversed();
    const onStylerEdit = ({ detail: { symbol, info: { marker, stroke, fill } } }) => {
        const colors = modules.esriLang.clone((fill || stroke).color);
        // currentColors could have more custom colors than the ramp from styler
        const color0 = currentColors[0];
        const hasColorRampChange = currentColors.length !== colors.length ||
            currentColors.some((color, idx) => color.r !== colors[idx].r || color.g !== colors[idx].g || color.b !== colors[idx].b) ||
            color0.r !== colors[0].r ||
            color0.g !== colors[0].g ||
            color0.b !== colors[0].b;
        const hasAlphaChange = color0.a !== colors[0].a;
        const newAlpha = colors[0].a;
        colors.reverse();
        const renderer = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.h)(layer);
        const symbolChangeInfo = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.am)(symbol, lastSymbol);
        if (hasColorRampChange && !symbolChangeInfo.any) {
            symbolChangeInfo.any = true;
            symbolChangeInfo.color = true;
        }
        if (symbolChangeInfo.any) {
            const groups = renderer.uniqueValueGroups.slice();
            let countPrevClasses = 0;
            groups.forEach((uniqueValueGroup) => {
                uniqueValueGroup.classes.forEach((uniqueValueClass, classIdx) => {
                    if (uniqueValueClass.symbol.type === "picture-marker" && (hasColorRampChange || hasAlphaChange)) {
                        uniqueValueClass.symbol = modules.esriLang.clone(symbol);
                        (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.r)(uniqueValueClass.symbol, colors[(countPrevClasses + classIdx) % colors.length]);
                    }
                    uniqueValueClass.symbol = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.an)(uniqueValueClass.symbol, symbol, hasColorRampChange
                        ? colors[(countPrevClasses + classIdx) % colors.length]
                        : hasAlphaChange
                            ? (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.ao)((0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.t)(uniqueValueClass.symbol), newAlpha)
                            : (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.t)(uniqueValueClass.symbol) || new modules.esriColor([0, 0, 0, 0]), symbolChangeInfo);
                });
                countPrevClasses += uniqueValueGroup.classes.length;
            });
            renderer.uniqueValueGroups = groups;
        } // else maybe just an auto size change
        if (!isTypeSize) {
            updateAutoVisVar(symbol, marker === null || marker === void 0 ? void 0 : marker.autoAdjusted, stroke === null || stroke === void 0 ? void 0 : stroke.autoAdjusted, symbolStyler, options);
        }
        else {
            onChange();
        }
        lastSymbol = symbol.clone();
        if (hasColorRampChange) {
            currentColors = [];
            renderer.uniqueValueGroups.forEach((group) => (currentColors = currentColors.concat(group.classes.map((uniqueValueClass) => (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.t)(uniqueValueClass.symbol) || new modules.esriColor([0, 0, 0, 0])))));
            currentColors.reverse();
            if (currentColors.length > 10) {
                // some ramps have only 10 colors
                currentColors = currentColors.slice(0, 10);
            }
        }
    };
    let stroke;
    if (symbol.type === "simple-fill") {
        const sym = symbol;
        if (sym.outline) {
            stroke = {
                color: sym.outline.color ? sym.outline.color : new modules.esriColor([0, 0, 0, 0.5]),
                size: sym.outline.width,
                style: sym.outline.style,
                autoAdjusted: !!sizeOutlineVisVar
            };
        }
        else {
            stroke = {
                color: new modules.esriColor([0, 0, 0, 0.5]),
                size: 1,
                style: "solid",
                autoAdjusted: !!sizeOutlineVisVar
            };
        }
    }
    else if (symbol.type === "simple-marker") {
        const sym = symbol;
        if (sym.outline) {
            stroke = {
                color: sym.outline.color ? sym.outline.color : new modules.esriColor([0, 0, 0, 0.5]),
                size: sym.outline.width
            };
        }
        else {
            stroke = {
                color: new modules.esriColor([0, 0, 0, 0.5]),
                size: 1
            };
        }
    }
    else if (symbol.type === "cim") {
        stroke = getCimLineProps(symbol);
        if (isLine) {
            (stroke.size = sizeAutoVisVar ? getSizeByScale(sizeAutoVisVar, mapView.scale) : stroke.size),
                (stroke.autoAdjusted = !!sizeAutoVisVar);
            if (sizeAutoVisVar) {
                // adjusts symbol so all symbol layers fit
                (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.U)(symbol, stroke.size);
            }
        }
    }
    else if (symbol.type === "simple-line") {
        const sym = symbol;
        stroke = {
            color: currentColors[currentColors.length - 1],
            size: sizeAutoVisVar ? getSizeByScale(sizeAutoVisVar, mapView.scale) : sym.width,
            style: sym.style,
            marker: sym.marker,
            autoAdjusted: !!sizeAutoVisVar
        };
    }
    else {
        stroke = {
            color: new modules.esriColor([255, 255, 255, 0.5]),
            size: 1
        };
    }
    const symbolStyler = await createSymbolStylerElement(popoverNode);
    let edit;
    // apply a few settings to the symbol we pass to the styler
    // so when comparing changes it's correct
    (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.r)(symbol, currentColors[currentColors.length - 1]);
    if ((isTypeSize || isPoint || isLine) && sizeAutoVisVar) {
        (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.U)(symbol, getSizeByScale(sizeAutoVisVar, mapView.scale));
    }
    else if (isPolygon && sizeAutoVisVar && symbol.outline) {
        symbol.outline.width = getSizeByScale(sizeAutoVisVar, mapView.scale);
    }
    lastSymbol = symbol.clone();
    if (isLine) {
        edit = symbolStylerEdit(symbolStyler, modules.esriLang.clone(symbol), {
            portal,
            symbolFilter: !(0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.a8)() ? "simple" : undefined,
            sections: {
                stroke: {
                    type: "color-ramp",
                    style: "discrete",
                    open: true,
                    colorRampsOpen: true,
                    colorRamps,
                    //suggestedColors: suggestedStrokeColors,
                    extraParts: {
                        style: symbol.type !== "cim",
                        arrow: symbol.type !== "cim",
                        autoStrokeAdjust: !mapImageSublayer && !isTypeSize ? "editable" : false,
                        width: !isTypeSize
                    },
                    parts: {
                        extra: !isTypeSize || symbol.type !== "cim"
                    }
                }
            },
            stroke: Object.assign(Object.assign({}, stroke), { color: currentColors })
        });
    }
    else {
        edit = symbolStylerEdit(symbolStyler, modules.esriLang.clone(symbol), {
            portal,
            symbolFilter: isPolygon && !(0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.a8)() ? "simple" : undefined,
            sections: {
                marker: isPointCIM || ["simple-marker", "picture-marker"].indexOf(symbol.type) > -1
                    ? {
                        open: (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.ai)(symbol) ? true : false,
                        parts: {
                            size: !isTypeSize ? (mapImageSublayer ? true : { autoSizeAdjust: "editable" }) : false
                        },
                        symbolsOpen: true,
                        sizeOpen: !isTypeSize,
                        markerType: (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.a8)() ? ["simple", "cim:vector"] : ["simple"]
                    }
                    : undefined,
                fill: {
                    type: "color-ramp",
                    style: "discrete",
                    open: (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.ai)(symbol) ? false : true,
                    colorRampsOpen: (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.ai)(symbol) ? false : true,
                    colorRamps
                },
                stroke: {
                    type: "color",
                    optional: true,
                    open: false,
                    suggestedColors: suggestedStrokeColors,
                    extraParts: {
                        style: ["simple-marker", "picture-marker", "cim"].indexOf(symbol.type) === -1,
                        width: true,
                        autoStrokeAdjust: !mapImageSublayer && isPolygon && symbol.type !== "cim" && !isTypeSize ? "editable" : false
                    }
                }
            },
            fill: {
                color: currentColors
            },
            marker: isTypeSize || isPoint
                ? {
                    size: sizeAutoVisVar ? getSizeByScale(sizeAutoVisVar, mapView.scale) : (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.T)(symbol),
                    autoAdjusted: !!sizeAutoVisVar
                }
                : undefined,
            stroke,
            strokeEnabled
        });
    }
    symbolStyler.addEventListener("arcgisSymbolStylerEdit", onStylerEditWrapper.bind(null, onStylerEdit));
    popoverNode.addStyler(symbolStyler);
    await edit;
    return createWatchScaleHandle(((_e = renderer.uniqueValueGroups) === null || _e === void 0 ? void 0 : _e.length) && renderer.uniqueValueGroups[0].classes.length
        ? renderer.uniqueValueGroups[0].classes[0].symbol
        : undefined, symbolStyler, (newSize) => {
        isPolygon && symbol.outline ? (symbol.outline.width = newSize) : !isPolygon && (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.U)(symbol, newSize);
        lastSymbol = symbol.clone();
    });
}
async function buildSymbolStylerForTypeGroup(options) {
    var _a;
    const { layer, mapView, portal, modules } = _raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.s;
    const { groupIdx, onChange, popoverNode } = options;
    const renderer = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.h)(layer);
    const uniqueValueGroups = renderer.uniqueValueGroups;
    const group = uniqueValueGroups[groupIdx];
    let alpha = ((_a = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.t)(group.classes[group.classes.length - 1].symbol)) === null || _a === void 0 ? void 0 : _a.a) || 1;
    let currentColors = group.classes.map((uniqueValueClass) => (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.t)(uniqueValueClass.symbol) || new modules.esriColor([0, 0, 0, alpha]) // TODO panel displays color from default ramp, not black
    );
    currentColors.reverse();
    if (currentColors.length > 10) {
        // some ramps have only 10 colors
        currentColors = currentColors.slice(0, 10);
    }
    const basemapTheme = (await modules.colorUtils.getBackgroundColorTheme(mapView));
    const schemes = modules.typeSchemes.getSchemes({
        basemapTheme,
        geometryType: (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.D)(layer) || defaultGeometry
    });
    const moreSchemes = modules.colorSchemes.getSchemes({
        basemapTheme,
        geometryType: (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.D)(layer) || defaultGeometry,
        theme: "high-to-low"
    });
    // get moreScheme into the types format
    moreSchemes.primaryScheme.colors = moreSchemes.primaryScheme.colorsForClassBreaks[9].colors;
    moreSchemes.primaryScheme.colorsForClassBreaks = undefined;
    moreSchemes.secondarySchemes = moreSchemes.secondarySchemes.filter((scheme) => { var _a; return ((_a = scheme.colorsForClassBreaks) === null || _a === void 0 ? void 0 : _a.length) >= 10; });
    moreSchemes.secondarySchemes.forEach((scheme) => {
        scheme.colors = scheme.colorsForClassBreaks[9].colors;
        scheme.colorsForClassBreaks = undefined;
    });
    schemes.secondarySchemes.push(moreSchemes.primaryScheme);
    schemes.secondarySchemes = schemes.secondarySchemes.concat(moreSchemes.secondarySchemes);
    // TODO get current scheme
    let numClasses = group.classes.length;
    const colorRampsAndSchemes = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.a9)(schemes, Math.min(numClasses, 10));
    const colorRamps = colorRampsAndSchemes.map((obj) => {
        return {
            stops: obj.colors.reverse(),
            tags: obj.scheme.tags,
            name: obj.scheme.name
        };
    });
    const onStylerEdit = ({ detail: { 
    //symbol,
    info: { fill } } }) => {
        const colors = modules.esriLang.clone(fill.color).reverse();
        const renderer = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.h)(layer);
        const rendererType = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.g)();
        const groups = renderer.uniqueValueGroups.slice();
        groups[groupIdx].classes.forEach((uniqueValueClass, classIdx) => {
            if (uniqueValueClass.symbol.type === "picture-marker") {
                // can't keep PMS
                uniqueValueClass.symbol = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.S)(layer, mapView, rendererType);
            }
            (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.r)(uniqueValueClass.symbol, colors[classIdx % colors.length]);
        });
        renderer.uniqueValueGroups = groups;
        onChange();
        currentColors = renderer.uniqueValueGroups[groupIdx].classes.map((uniqueValueClass) => (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.t)(uniqueValueClass.symbol));
        currentColors.reverse();
        if (currentColors.length > 10) {
            // some ramps have only 10 colors
            currentColors = currentColors.slice(0, 10);
        }
    };
    const symbolStyler = await createSymbolStylerElement(popoverNode);
    const edit = symbolStylerEdit(symbolStyler, new modules.SimpleFillSymbol(), {
        portal,
        sections: {
            marker: {
                parts: {
                    preview: false,
                    rotation: false,
                    size: false
                }
            },
            fill: {
                type: "color-ramp",
                style: "discrete",
                open: true,
                colorRampsOpen: true,
                colorRamps,
                parts: {
                    transparency: false
                }
            }
        },
        fill: {
            color: currentColors
        }
    });
    symbolStyler.addEventListener("arcgisSymbolStylerEdit", onStylerEditWrapper.bind(null, onStylerEdit));
    popoverNode.addStyler(symbolStyler);
    await edit;
}
async function buildSymbolStylerForTypeValue(options) {
    var _a, _b;
    const { layer, mapImageSublayer, mapView, lastDefault, portal, modules } = _raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.s;
    const { onChange, popoverNode, selectedValue } = options;
    const [groupIdx, classIdx] = !(0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.i)(layer) && selectedValue.split("/").map((value) => parseInt(value));
    const isPoint = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.A)(layer);
    const isLine = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.B)(layer);
    const isPolygon = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.q)(layer);
    const renderer = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.h)(layer);
    const rendererType = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.g)();
    const isTypeSize = ["type-size", "type-size-age"].indexOf(rendererType) > -1;
    const sizeAutoVisVar = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.a)(renderer, "size", "auto");
    const sizeOutlineVisVar = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.a)(renderer, "size", "outline");
    let symbol;
    if ((!(0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.i)(layer) && groupIdx === -1) || ((0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.i)(layer) && selectedValue === -1)) {
        symbol = renderer.defaultSymbol || lastDefault.defaultSymbol;
    }
    else {
        if ((0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.i)(layer)) {
            symbol = renderer.uniqueValueInfos[selectedValue].symbol;
        }
        else {
            symbol = renderer.uniqueValueGroups[groupIdx].classes[classIdx].symbol;
        }
    }
    if (!isSupportedSymbol(symbol)) {
        symbol = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.i)(layer) ? (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.aj)() : (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.S)(layer, mapView, rendererType);
        if (((!(0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.i)(layer) && groupIdx === -1) || ((0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.i)(layer) && selectedValue === -1)) &&
            !renderer.defaultSymbol) {
            lastDefault.defaultSymbol = symbol;
        }
    }
    const fillEnabled = symbol.type === "picture-marker" ? false : !!symbol.color;
    const strokeEnabled = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.a5)(symbol);
    const isPointCIM = symbol.type === "cim" && symbol.data.symbol.type === "CIMPointSymbol";
    let suggestedFillColors;
    if ((!(0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.i)(layer) && groupIdx === -1) || ((0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.i)(layer) && selectedValue === -1)) {
        suggestedFillColors = getGreyColors();
    }
    else {
        const schemes = modules.typeSchemes.getSchemes({
            basemap: mapView.map.basemap,
            geometryType: (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.D)(layer) || defaultGeometry
        });
        suggestedFillColors = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.a7)(schemes).slice(0, 16);
    }
    const suggestedStrokeColors = getAllColorsReversed();
    const onStylerEdit = ({ detail: { symbol, info: { marker, stroke /* , fill */ } } }) => {
        const renderer = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.h)(layer);
        if ((!(0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.i)(layer) && groupIdx === -1) || ((0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.i)(layer) && selectedValue === -1)) {
            renderer.defaultSymbol = symbol;
        }
        else {
            if ((0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.i)(layer)) {
                const infos = renderer.uniqueValueInfos.slice();
                infos[selectedValue].symbol = symbol;
                renderer.uniqueValueInfos = infos;
            }
            else {
                const groups = renderer.uniqueValueGroups.slice();
                groups[groupIdx].classes[classIdx].symbol = symbol;
                renderer.uniqueValueGroups = groups;
            }
        }
        if (!isTypeSize) {
            updateAutoVisVar(symbol, marker === null || marker === void 0 ? void 0 : marker.autoAdjusted, stroke === null || stroke === void 0 ? void 0 : stroke.autoAdjusted, symbolStyler, options);
        }
        else {
            onChange();
        }
    };
    let stroke;
    if (symbol.type === "simple-fill") {
        const sym = symbol;
        if (sym.outline) {
            stroke = {
                color: sym.outline.color ? sym.outline.color : new modules.esriColor([0, 0, 0, 0.5]),
                size: sym.outline.width,
                style: sym.outline.style,
                autoAdjusted: !!sizeOutlineVisVar
            };
        }
        else {
            stroke = {
                color: new modules.esriColor([0, 0, 0, 0.5]),
                size: 1,
                style: "solid",
                autoAdjusted: !!sizeOutlineVisVar
            };
        }
    }
    else if (symbol.type === "simple-marker") {
        const sym = symbol;
        if (sym.outline) {
            stroke = {
                color: sym.outline.color ? sym.outline.color : new modules.esriColor([0, 0, 0, 0.5]),
                size: sym.outline.width
            };
        }
        else {
            stroke = {
                color: new modules.esriColor([0, 0, 0, 0.5]),
                size: 1
            };
        }
    }
    else if (symbol.type === "cim") {
        stroke = getCimLineProps(symbol);
        if (isLine) {
            (stroke.size = sizeAutoVisVar ? getSizeByScale(sizeAutoVisVar, mapView.scale) : stroke.size),
                (stroke.autoAdjusted = !!sizeAutoVisVar);
            if (sizeAutoVisVar) {
                // adjusts symbol so all symbol layers fit
                (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.U)(symbol, stroke.size);
            }
        }
    }
    else if (symbol.type === "simple-line") {
        const sym = symbol;
        stroke = {
            size: sizeAutoVisVar ? getSizeByScale(sizeAutoVisVar, mapView.scale) : sym.width,
            style: sym.style,
            marker: sym.marker,
            color: sym.color,
            autoAdjusted: !!sizeAutoVisVar
        };
    }
    else {
        stroke = {
            color: new modules.esriColor([255, 255, 255, 0.5]),
            size: 1
        };
    }
    const symbolStyler = await createSymbolStylerElement(popoverNode);
    let edit;
    if (isLine) {
        edit = symbolStylerEdit(symbolStyler, modules.esriLang.clone(symbol), {
            portal,
            symbolFilter: !(0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.a8)() ? "simple" : undefined,
            sections: {
                stroke: {
                    type: "color",
                    open: true,
                    suggestedColorsOpen: true,
                    suggestedColors: suggestedFillColors,
                    extraParts: {
                        style: symbol.type !== "cim",
                        arrow: symbol.type !== "cim",
                        autoStrokeAdjust: !mapImageSublayer && !isTypeSize ? "editable" : false,
                        width: !isTypeSize
                    },
                    parts: {
                        extra: !isTypeSize || symbol.type !== "cim"
                    }
                }
            },
            stroke
        });
    }
    else if ((0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.i)(layer)) {
        // just need the fill option for raster layers. Other options doesnt make sense with the context
        edit = symbolStylerEdit(symbolStyler, modules.esriLang.clone(symbol), {
            portal,
            symbolFilter: "simple",
            sections: {
                marker: {
                    parts: {
                        preview: false,
                        rotation: false,
                        size: false
                    }
                },
                fill: {
                    type: "color",
                    open: true,
                    optional: true,
                    suggestedColorsOpen: true,
                    suggestedColors: suggestedFillColors,
                    parts: {
                        transparency: false
                    }
                }
            },
            fill: {
                color: (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.t)(symbol) ||
                    (selectedValue === -1
                        ? (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.aj)().color
                        : adjustAlpha(suggestedFillColors[selectedValue % suggestedFillColors.length], 0.85))
            },
            stroke,
            fillEnabled
        });
    }
    else {
        edit = symbolStylerEdit(symbolStyler, modules.esriLang.clone(symbol), {
            portal,
            symbolFilter: isPolygon && !(0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.a8)() ? "simple" : undefined,
            sections: {
                marker: isPointCIM || ["simple-marker", "picture-marker"].indexOf(symbol.type) > -1
                    ? {
                        open: true,
                        parts: {
                            size: !isTypeSize ? (mapImageSublayer ? true : { autoSizeAdjust: "editable" }) : false
                        },
                        symbolsOpen: true,
                        sizeOpen: !isTypeSize,
                        markerType: (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.a8)() ? "all" : ["simple", "picture"]
                    }
                    : undefined,
                fill: {
                    type: "color",
                    open: true,
                    optional: true,
                    suggestedColorsOpen: true,
                    transparencyOpen: (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.a6)(symbol),
                    suggestedColors: suggestedFillColors
                },
                stroke: {
                    type: "color",
                    optional: true,
                    suggestedColors: suggestedStrokeColors,
                    extraParts: {
                        style: ["simple-marker", "picture-marker", "cim"].indexOf(symbol.type) === -1,
                        width: true,
                        autoStrokeAdjust: !mapImageSublayer && isPolygon && symbol.type !== "cim" && !isTypeSize ? "editable" : false
                    }
                }
            },
            fill: {
                color: (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.t)(symbol) || adjustAlpha(suggestedFillColors[classIdx % suggestedFillColors.length], 0.85)
            },
            marker: isTypeSize || isPoint
                ? {
                    size: sizeAutoVisVar ? getSizeByScale(sizeAutoVisVar, mapView.scale) : (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.T)(symbol),
                    autoAdjusted: !!sizeAutoVisVar
                }
                : undefined,
            stroke,
            fillEnabled,
            strokeEnabled
        });
    }
    symbolStyler.addEventListener("arcgisSymbolStylerEdit", onStylerEditWrapper.bind(null, onStylerEdit));
    popoverNode.addStyler(symbolStyler);
    await edit;
    return createWatchScaleHandle((0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.i)(layer)
        ? ((_a = renderer.uniqueValueInfos) === null || _a === void 0 ? void 0 : _a.length)
            ? renderer.uniqueValueInfos[0].symbol
            : undefined
        : ((_b = renderer.uniqueValueGroups) === null || _b === void 0 ? void 0 : _b.length) && renderer.uniqueValueGroups[0].classes.length
            ? renderer.uniqueValueGroups[0].classes[0].symbol
            : undefined, symbolStyler);
}
async function buildSymbolStylerForRelationshipRamp(options) {
    var _a, _b, _c;
    const { layer, mapImageSublayer, mapView, portal, modules } = _raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.s;
    const { onChange, popoverNode } = options;
    const isPoint = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.A)(layer);
    const isLine = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.B)(layer);
    const isPolygon = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.q)(layer);
    const renderer = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.h)(layer);
    const rendererType = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.g)();
    const isRelSize = rendererType === "relationship-size";
    const sizeAutoVisVar = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.a)(renderer, "size", "auto");
    const sizeOutlineVisVar = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.a)(renderer, "size", "outline");
    const uniqueValueClasses = renderer.uniqueValueGroups[0].classes;
    const currentColors = uniqueValueClasses.map((uniqueValueClass) => (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.t)(uniqueValueClass.symbol) || new modules.esriColor([0, 0, 0, 0]));
    const schemes = modules.relationshipSchemes.getSchemes({
        basemap: mapView.map.basemap || "topo",
        geometryType: (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.D)(layer)
    });
    // TODO get current scheme
    // it takes the first symbol as a reference
    let symbol = ((_a = renderer.uniqueValueGroups[0].classes) === null || _a === void 0 ? void 0 : _a.length)
        ? modules.esriLang.clone(renderer.uniqueValueGroups[0].classes[0].symbol)
        : (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.S)(layer, mapView, rendererType);
    if (!isColoredSymbol(symbol)) {
        const size = (_b = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.T)(symbol)) !== null && _b !== void 0 ? _b : symbol.width;
        symbol = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.S)(layer, mapView, rendererType);
        (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.U)(symbol, size);
    }
    const strokeEnabled = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.a5)(symbol);
    const isPointCIM = symbol.type === "cim" && symbol.data.symbol.type === "CIMPointSymbol";
    // TODO get current scheme
    const colorRamps = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.a9)(schemes, Math.sqrt(uniqueValueClasses.length)).map(({ colors: stops, scheme: { tags, name } }) => ({
        stops: modules.relationshipSchemes.flatten2DArray(stops),
        tags,
        name
    }));
    const suggestedStrokeColors = getAllColorsReversed();
    const onStylerEdit = ({ detail: { symbol, info: { marker, stroke, fill } } }) => {
        const colors = modules.esriLang.clone((fill || stroke).color);
        const renderer = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.h)(layer);
        const classes = renderer.uniqueValueGroups[0].classes.slice();
        classes.forEach((uniqueValueClass, idx) => {
            uniqueValueClass.symbol = symbol.clone();
            (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.r)(uniqueValueClass.symbol, colors[idx % colors.length]);
        });
        renderer.uniqueValueGroups[0].classes = classes;
        if (!isRelSize) {
            updateAutoVisVar(symbol, marker === null || marker === void 0 ? void 0 : marker.autoAdjusted, stroke === null || stroke === void 0 ? void 0 : stroke.autoAdjusted, symbolStyler, options);
        }
        else {
            onChange();
        }
    };
    let stroke;
    if (symbol.type === "simple-fill") {
        const sym = symbol;
        if (sym.outline) {
            stroke = {
                color: sym.outline.color ? sym.outline.color : new modules.esriColor([0, 0, 0, 0.5]),
                size: sym.outline.width,
                style: sym.outline.style,
                autoAdjusted: !!sizeOutlineVisVar
            };
        }
        else {
            stroke = {
                color: new modules.esriColor([0, 0, 0, 0.5]),
                size: 1,
                style: "solid",
                autoAdjusted: !!sizeOutlineVisVar
            };
        }
    }
    else if (symbol.type === "simple-marker") {
        const sym = symbol;
        if (sym.outline) {
            stroke = {
                color: sym.outline.color ? sym.outline.color : new modules.esriColor([0, 0, 0, 0.5]),
                size: sym.outline.width
            };
        }
        else {
            stroke = {
                color: new modules.esriColor([0, 0, 0, 0.5]),
                size: 1
            };
        }
    }
    else if (symbol.type === "cim") {
        stroke = getCimLineProps(symbol);
        if (isLine) {
            (stroke.size = sizeAutoVisVar ? getSizeByScale(sizeAutoVisVar, mapView.scale) : stroke.size),
                (stroke.autoAdjusted = !!sizeAutoVisVar);
            if (sizeAutoVisVar) {
                // adjusts symbol so all symbol layers fit
                (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.U)(symbol, stroke.size);
            }
        }
    }
    else if (symbol.type === "simple-line") {
        const sym = symbol;
        stroke = {
            color: new modules.esriColor([255, 255, 255, 0.5]),
            size: sizeAutoVisVar ? getSizeByScale(sizeAutoVisVar, mapView.scale) : sym.width,
            style: sym.style,
            marker: sym.marker,
            autoAdjusted: !!sizeAutoVisVar
        };
    }
    else {
        stroke = {
            color: new modules.esriColor([255, 255, 255, 0.5]),
            size: 1
        };
    }
    const symbolStyler = await createSymbolStylerElement(popoverNode);
    let edit;
    if (isLine) {
        edit = symbolStylerEdit(symbolStyler, modules.esriLang.clone(symbol), {
            portal,
            symbolFilter: !(0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.a8)() ? "simple" : undefined,
            sections: {
                stroke: {
                    type: "color-ramp",
                    style: "2d",
                    open: true,
                    colorRampsOpen: true,
                    colorRamps,
                    //suggestedColors: suggestedStrokeColors,
                    extraParts: {
                        style: symbol.type !== "cim",
                        arrow: symbol.type !== "cim",
                        autoStrokeAdjust: !mapImageSublayer && !isRelSize ? "editable" : false,
                        width: !isRelSize
                    },
                    parts: {
                        extra: !isRelSize || symbol.type !== "cim"
                    }
                }
            },
            stroke: Object.assign(Object.assign({}, stroke), { color: currentColors })
        });
    }
    else {
        edit = symbolStylerEdit(symbolStyler, modules.esriLang.clone(symbol), {
            portal,
            symbolFilter: isPolygon && !(0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.a8)() ? "simple" : undefined,
            sections: {
                marker: isPointCIM || ["simple-marker", "picture-marker"].indexOf(symbol.type) > -1
                    ? {
                        open: (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.ai)(symbol) ? true : false,
                        parts: {
                            size: !isRelSize ? (mapImageSublayer ? true : { autoSizeAdjust: "editable" }) : false
                        },
                        symbolsOpen: true,
                        sizeOpen: !isRelSize,
                        markerType: (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.a8)() ? ["simple", "cim:vector"] : ["simple"]
                    }
                    : undefined,
                fill: {
                    type: "color-ramp",
                    style: "2d",
                    open: (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.ai)(symbol) ? false : true,
                    colorRampsOpen: (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.ai)(symbol) ? false : true,
                    colorRamps
                },
                stroke: {
                    type: "color",
                    optional: true,
                    open: false,
                    suggestedColors: suggestedStrokeColors,
                    extraParts: {
                        style: ["simple-marker", "picture-marker", "cim"].indexOf(symbol.type) === -1,
                        width: true,
                        autoStrokeAdjust: !mapImageSublayer && isPolygon && symbol.type !== "cim" && !isRelSize ? "editable" : false
                    }
                }
            },
            fill: {
                color: currentColors
            },
            marker: isRelSize || isPoint
                ? {
                    size: sizeAutoVisVar ? getSizeByScale(sizeAutoVisVar, mapView.scale) : (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.T)(symbol),
                    autoAdjusted: !!sizeAutoVisVar
                }
                : undefined,
            stroke,
            strokeEnabled
        });
    }
    symbolStyler.addEventListener("arcgisSymbolStylerEdit", onStylerEditWrapper.bind(null, onStylerEdit));
    popoverNode.addStyler(symbolStyler);
    await edit;
    return createWatchScaleHandle(((_c = renderer.uniqueValueGroups[0].classes) === null || _c === void 0 ? void 0 : _c.length) ? renderer.uniqueValueGroups[0].classes[0].symbol : undefined, symbolStyler);
}
async function buildSymbolStylerForPredominanceRamp(options) {
    var _a, _b, _c, _d;
    const { layer, mapImageSublayer, mapView, portal, modules } = _raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.s;
    const { onChange, popoverNode } = options;
    const isPoint = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.A)(layer);
    const isLine = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.B)(layer);
    const isPolygon = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.q)(layer);
    const renderer = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.h)(layer);
    const rendererType = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.g)();
    const isPredomSize = rendererType === "predominance-size";
    const sizeAutoVisVar = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.a)(renderer, "size", "auto");
    const sizeOutlineVisVar = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.a)(renderer, "size", "outline");
    const uniqueValueClasses = renderer.uniqueValueGroups[0].classes;
    let lastSymbol;
    let alpha = (uniqueValueClasses.length && ((_a = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.t)(uniqueValueClasses[uniqueValueClasses.length - 1].symbol)) === null || _a === void 0 ? void 0 : _a.a)) || 1;
    let currentColors = uniqueValueClasses.map((uniqueValueClass) => (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.t)(uniqueValueClass.symbol) || new modules.esriColor([0, 0, 0, alpha]));
    currentColors.reverse();
    const schemes = modules.predominanceSchemes.getSchemes({
        basemap: mapView.map.basemap,
        geometryType: (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.D)(layer),
        numColors: uniqueValueClasses.length
    });
    // it takes the first symbol as a reference
    let symbol = ((_b = renderer.uniqueValueGroups[0].classes) === null || _b === void 0 ? void 0 : _b.length)
        ? modules.esriLang.clone(renderer.uniqueValueGroups[0].classes[0].symbol)
        : (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.S)(layer, mapView, rendererType);
    if (!isColoredSymbol(symbol)) {
        const size = (_c = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.T)(symbol)) !== null && _c !== void 0 ? _c : symbol.width;
        symbol = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.S)(layer, mapView, rendererType);
        (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.U)(symbol, size);
    }
    const strokeEnabled = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.a5)(symbol);
    const isPointCIM = symbol.type === "cim" && symbol.data.symbol.type === "CIMPointSymbol";
    // TODO get current scheme
    const colorRampsAndSchemes = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.a9)(schemes, uniqueValueClasses.length);
    const colorRamps = colorRampsAndSchemes.map((obj) => {
        return {
            stops: obj.colors.reverse(),
            tags: obj.scheme.tags,
            name: obj.scheme.name
        };
    });
    const suggestedStrokeColors = getAllColorsReversed();
    const onStylerEdit = ({ detail: { symbol, info: { marker, stroke, fill } } }) => {
        const colors = modules.esriLang.clone((fill || stroke).color);
        const color0 = currentColors[0];
        const hasColorRampChange = currentColors.length !== colors.length ||
            currentColors.some((color, idx) => color.r !== colors[idx].r || color.g !== colors[idx].g || color.b !== colors[idx].b) ||
            color0.r !== colors[0].r ||
            color0.g !== colors[0].g ||
            color0.b !== colors[0].b;
        const hasAlphaChange = color0.a !== colors[0].a;
        const newAlpha = colors[0].a;
        colors.reverse();
        const renderer = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.h)(layer);
        const symbolChangeInfo = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.am)(symbol, lastSymbol);
        if (hasColorRampChange && !symbolChangeInfo.any) {
            symbolChangeInfo.any = true;
            symbolChangeInfo.color = true;
        }
        if (symbolChangeInfo.any) {
            const classes = renderer.uniqueValueGroups[0].classes.slice();
            classes.forEach((uniqueValueClass, idx) => {
                if (uniqueValueClass.symbol.type === "picture-marker" && (hasColorRampChange || hasAlphaChange)) {
                    uniqueValueClass.symbol = modules.esriLang.clone(symbol);
                    (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.r)(uniqueValueClass.symbol, colors[idx % colors.length]);
                }
                uniqueValueClass.symbol = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.an)(uniqueValueClass.symbol, symbol, hasColorRampChange
                    ? colors[idx % colors.length]
                    : hasAlphaChange
                        ? (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.ao)((0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.t)(uniqueValueClass.symbol), newAlpha)
                        : (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.t)(uniqueValueClass.symbol) || new modules.esriColor([0, 0, 0, 0]), symbolChangeInfo);
            });
            renderer.uniqueValueGroups[0].classes = classes;
        } // else maybe just an auto size change
        if (!isPredomSize) {
            updateAutoVisVar(symbol, marker === null || marker === void 0 ? void 0 : marker.autoAdjusted, stroke === null || stroke === void 0 ? void 0 : stroke.autoAdjusted, symbolStyler, options);
        }
        else {
            onChange();
        }
        lastSymbol = symbol.clone();
        if (hasColorRampChange) {
            currentColors = renderer.uniqueValueGroups[0].classes.map((uniqueValueClass) => (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.t)(uniqueValueClass.symbol) || new modules.esriColor([0, 0, 0, 0.5]));
            currentColors.reverse();
        }
    };
    let stroke;
    if (symbol.type === "simple-fill") {
        const sym = symbol;
        if (sym.outline) {
            stroke = {
                color: sym.outline.color ? sym.outline.color : new modules.esriColor([0, 0, 0, 0.5]),
                size: sym.outline.width,
                style: sym.outline.style,
                autoAdjusted: !!sizeOutlineVisVar
            };
        }
        else {
            stroke = {
                color: new modules.esriColor([0, 0, 0, 0.5]),
                size: 1,
                style: "solid",
                autoAdjusted: !!sizeOutlineVisVar
            };
        }
    }
    else if (symbol.type === "simple-marker") {
        const sym = symbol;
        if (sym.outline) {
            stroke = {
                color: sym.outline.color ? sym.outline.color : new modules.esriColor([0, 0, 0, 0.5]),
                size: sym.outline.width
            };
        }
        else {
            stroke = {
                color: new modules.esriColor([0, 0, 0, 0.5]),
                size: 1
            };
        }
    }
    else if (symbol.type === "cim") {
        stroke = getCimLineProps(symbol);
        if (isLine) {
            (stroke.size = sizeAutoVisVar ? getSizeByScale(sizeAutoVisVar, mapView.scale) : stroke.size),
                (stroke.autoAdjusted = !!sizeAutoVisVar);
            if (sizeAutoVisVar) {
                // adjusts symbol so all symbol layers fit
                (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.U)(symbol, stroke.size);
            }
        }
    }
    else if (symbol.type === "simple-line") {
        const sym = symbol;
        stroke = {
            color: new modules.esriColor([255, 255, 255, 0.5]),
            size: sizeAutoVisVar ? getSizeByScale(sizeAutoVisVar, mapView.scale) : sym.width,
            style: sym.style,
            marker: sym.marker,
            autoAdjusted: !!sizeAutoVisVar
        };
    }
    else {
        stroke = {
            color: new modules.esriColor([255, 255, 255, 0.5]),
            size: 1
        };
    }
    const symbolStyler = await createSymbolStylerElement(popoverNode);
    let edit;
    // apply a few settings to the symbol we pass to the styler
    // so when comparing changes it's correct
    (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.r)(symbol, currentColors[currentColors.length - 1]);
    if ((isPredomSize || isPoint || isLine) && sizeAutoVisVar) {
        (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.U)(symbol, getSizeByScale(sizeAutoVisVar, mapView.scale));
    }
    else if (isPolygon && sizeAutoVisVar && symbol.outline) {
        symbol.outline.width = getSizeByScale(sizeAutoVisVar, mapView.scale);
    }
    lastSymbol = symbol.clone();
    if (isLine) {
        edit = symbolStylerEdit(symbolStyler, modules.esriLang.clone(symbol), {
            portal,
            symbolFilter: !(0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.a8)() ? "simple" : undefined,
            sections: {
                stroke: {
                    type: "color-ramp",
                    style: "discrete",
                    open: true,
                    colorRampsOpen: true,
                    colorRamps,
                    //suggestedColors: suggestedStrokeColors,
                    parts: {
                        //suggestedColors: false,
                        //customColor: false,
                        transparency: true,
                        extra: !isPredomSize || symbol.type !== "cim"
                    },
                    extraParts: {
                        style: symbol.type !== "cim",
                        arrow: symbol.type !== "cim",
                        autoStrokeAdjust: !mapImageSublayer && !isPredomSize ? "editable" : false,
                        width: !isPredomSize
                    }
                }
            },
            stroke: Object.assign(Object.assign({}, stroke), { color: currentColors })
        });
    }
    else {
        edit = symbolStylerEdit(symbolStyler, modules.esriLang.clone(symbol), {
            portal,
            symbolFilter: isPolygon && !(0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.a8)() ? "simple" : undefined,
            sections: {
                marker: isPointCIM || ["simple-marker", "picture-marker"].indexOf(symbol.type) > -1
                    ? {
                        open: (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.ai)(symbol) ? true : false,
                        parts: {
                            size: !isPredomSize ? (mapImageSublayer ? true : { autoSizeAdjust: "editable" }) : false
                        },
                        symbolsOpen: true,
                        sizeOpen: !isPredomSize,
                        markerType: (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.a8)() ? ["simple", "cim:vector"] : ["simple"]
                    }
                    : undefined,
                fill: {
                    type: "color-ramp",
                    style: "discrete",
                    open: (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.ai)(symbol) ? false : true,
                    colorRampsOpen: (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.ai)(symbol) ? false : true,
                    colorRamps
                },
                stroke: {
                    type: "color",
                    optional: true,
                    open: false,
                    suggestedColors: suggestedStrokeColors,
                    extraParts: {
                        style: ["simple-marker", "picture-marker", "cim"].indexOf(symbol.type) === -1,
                        width: true,
                        autoStrokeAdjust: !mapImageSublayer && isPolygon && symbol.type !== "cim" && !isPredomSize ? "editable" : false
                    }
                }
            },
            fill: {
                color: currentColors
            },
            marker: isPredomSize || isPoint
                ? {
                    size: sizeAutoVisVar ? getSizeByScale(sizeAutoVisVar, mapView.scale) : (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.T)(symbol),
                    autoAdjusted: !!sizeAutoVisVar
                }
                : undefined,
            stroke,
            strokeEnabled
        });
    }
    symbolStyler.addEventListener("arcgisSymbolStylerEdit", onStylerEditWrapper.bind(null, onStylerEdit));
    popoverNode.addStyler(symbolStyler);
    await edit;
    return createWatchScaleHandle(((_d = renderer.uniqueValueGroups[0].classes) === null || _d === void 0 ? void 0 : _d.length) ? renderer.uniqueValueGroups[0].classes[0].symbol : undefined, symbolStyler, (newSize) => {
        isPolygon && symbol.outline ? (symbol.outline.width = newSize) : !isPolygon && (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.U)(symbol, newSize);
        lastSymbol = symbol.clone();
    });
}
async function buildSymbolStylerForPredominanceValue(options) {
    var _a;
    const { layer, mapImageSublayer, mapView, selectedValue, lastDefault, portal, modules } = _raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.s;
    const { onChange, popoverNode } = options;
    const isPoint = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.A)(layer);
    const isLine = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.B)(layer);
    const isPolygon = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.q)(layer);
    const renderer = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.h)(layer);
    const rendererType = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.g)();
    const isPredomSize = rendererType === "predominance-size";
    const sizeAutoVisVar = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.a)(renderer, "size", "auto");
    const sizeOutlineVisVar = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.a)(renderer, "size", "outline");
    let symbol;
    if (selectedValue === -1) {
        symbol = renderer.defaultSymbol || lastDefault.defaultSymbol;
    }
    else {
        symbol = renderer.uniqueValueGroups[0].classes[selectedValue].symbol;
    }
    if (!isSupportedSymbol(symbol)) {
        symbol = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.S)(layer, mapView, rendererType);
        if (selectedValue === -1 && !renderer.defaultSymbol) {
            lastDefault.defaultSymbol = symbol;
        }
    }
    const fillEnabled = symbol.type === "picture-marker" ? false : !!symbol.color;
    const strokeEnabled = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.a5)(symbol);
    const isPointCIM = symbol.type === "cim" && symbol.data.symbol.type === "CIMPointSymbol";
    let suggestedFillColors;
    if (selectedValue === -1) {
        suggestedFillColors = getGreyColors();
    }
    else {
        const schemes = modules.predominanceSchemes.getSchemes({
            basemap: mapView.map.basemap,
            geometryType: (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.D)(layer),
            numColors: 10
        });
        suggestedFillColors = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.a7)(schemes).slice(0, 16);
    }
    const suggestedStrokeColors = getAllColorsReversed();
    const onStylerEdit = ({ detail: { symbol, info: { marker, stroke /* , fill */ } } }) => {
        const renderer = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.h)(layer);
        if (selectedValue === -1) {
            renderer.defaultSymbol = symbol;
        }
        else {
            const infos = renderer.uniqueValueGroups[0].classes.slice();
            infos[selectedValue].symbol = symbol;
            renderer.uniqueValueGroups[0].classes = infos;
        }
        if (!isPredomSize) {
            updateAutoVisVar(symbol, marker === null || marker === void 0 ? void 0 : marker.autoAdjusted, stroke === null || stroke === void 0 ? void 0 : stroke.autoAdjusted, symbolStyler, options);
        }
        else {
            onChange();
        }
    };
    let stroke;
    if (symbol.type === "simple-fill") {
        const sym = symbol;
        if (sym.outline) {
            stroke = {
                color: sym.outline.color ? sym.outline.color : new modules.esriColor([0, 0, 0, 0.5]),
                size: sym.outline.width,
                style: sym.outline.style,
                autoAdjusted: !!sizeOutlineVisVar
            };
        }
        else {
            stroke = {
                color: new modules.esriColor([0, 0, 0, 0.5]),
                size: 1,
                style: "solid",
                autoAdjusted: !!sizeOutlineVisVar
            };
        }
    }
    else if (symbol.type === "simple-marker") {
        const sym = symbol;
        if (sym.outline) {
            stroke = {
                color: sym.outline.color ? sym.outline.color : new modules.esriColor([0, 0, 0, 0.5]),
                size: sym.outline.width
            };
        }
        else {
            stroke = {
                color: new modules.esriColor([0, 0, 0, 0.5]),
                size: 1
            };
        }
    }
    else if (symbol.type === "cim") {
        stroke = getCimLineProps(symbol);
    }
    else if (symbol.type === "simple-line") {
        const sym = symbol;
        stroke = {
            size: sym.width,
            style: sym.style,
            marker: sym.marker,
            color: sym.color
        };
    }
    else {
        stroke = {
            color: new modules.esriColor([255, 255, 255, 0.5]),
            size: 1
        };
    }
    const symbolStyler = await createSymbolStylerElement(popoverNode);
    let edit;
    if (isLine) {
        edit = symbolStylerEdit(symbolStyler, modules.esriLang.clone(symbol), {
            portal,
            symbolFilter: !(0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.a8)() ? "simple" : undefined,
            sections: {
                stroke: {
                    type: "color",
                    open: true,
                    suggestedColorsOpen: true,
                    suggestedColors: suggestedFillColors,
                    extraParts: {
                        style: symbol.type !== "cim",
                        arrow: symbol.type !== "cim",
                        autoStrokeAdjust: !mapImageSublayer && !isPredomSize ? "editable" : false,
                        width: !isPredomSize
                    },
                    parts: {
                        extra: !isPredomSize || symbol.type !== "cim"
                    }
                }
            },
            stroke
        });
    }
    else {
        edit = symbolStylerEdit(symbolStyler, modules.esriLang.clone(symbol), {
            portal,
            symbolFilter: isPolygon && !(0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.a8)() ? "simple" : undefined,
            sections: {
                marker: isPointCIM || ["simple-marker", "picture-marker"].indexOf(symbol.type) > -1
                    ? {
                        open: true,
                        parts: {
                            size: !isPredomSize ? (mapImageSublayer ? true : { autoSizeAdjust: "editable" }) : false
                        },
                        symbolsOpen: true,
                        sizeOpen: !isPredomSize,
                        markerType: (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.a8)() ? "all" : ["simple", "picture"]
                    }
                    : undefined,
                fill: {
                    type: "color",
                    open: true,
                    optional: true,
                    suggestedColorsOpen: true,
                    transparencyOpen: (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.a6)(symbol),
                    suggestedColors: suggestedFillColors
                },
                stroke: {
                    type: "color",
                    optional: true,
                    suggestedColors: suggestedStrokeColors,
                    extraParts: {
                        style: ["simple-marker", "picture-marker", "cim"].indexOf(symbol.type) === -1,
                        width: true,
                        autoStrokeAdjust: !mapImageSublayer && isPolygon && symbol.type !== "cim" && !isPredomSize ? "editable" : false
                    }
                }
            },
            fill: {
                color: (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.t)(symbol) || adjustAlpha(suggestedFillColors[selectedValue], 0.85)
            },
            marker: isPredomSize || isPoint
                ? {
                    size: sizeAutoVisVar ? getSizeByScale(sizeAutoVisVar, mapView.scale) : (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.T)(symbol),
                    autoAdjusted: !!sizeAutoVisVar
                }
                : undefined,
            stroke,
            fillEnabled,
            strokeEnabled
        });
    }
    symbolStyler.addEventListener("arcgisSymbolStylerEdit", onStylerEditWrapper.bind(null, onStylerEdit));
    popoverNode.addStyler(symbolStyler);
    await edit;
    return createWatchScaleHandle(((_a = renderer.uniqueValueGroups[0].classes) === null || _a === void 0 ? void 0 : _a.length) ? renderer.uniqueValueGroups[0].classes[0].symbol : undefined, symbolStyler);
}
async function buildSymbolStylerForChartRamp(options) {
    const { layer, mapView, portal, strings, modules } = _raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.s;
    const { onChange, popoverNode } = options;
    const renderer = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.h)(layer);
    const attributes = renderer.attributes;
    const currentColors = attributes.map((attribute) => attribute.color);
    const schemes = modules.pieChartSchemes.getSchemes({
        basemap: mapView.map.basemap,
        geometryType: (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.D)(layer) || defaultGeometry,
        numColors: attributes.length
    });
    const suggestedStrokeColors = getGreyColors();
    // TODO get current scheme
    const colorRampsAndSchemes = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.a9)(schemes, attributes.length);
    const colorRamps = colorRampsAndSchemes.map((obj) => {
        return {
            stops: obj.colors.reverse(),
            tags: obj.scheme.tags,
            name: obj.scheme.name
        };
    });
    const onStylerEdit = ({ detail: { symbol, info: { /* marker, stroke, */ fill } } }) => {
        const colors = modules.esriLang.clone(fill.color);
        colors.reverse();
        (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.h)(layer).attributes.forEach((attribute, idx) => (attribute.color = colors[idx]));
        (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.h)(layer).outline = symbol.outline.clone();
        onChange();
    };
    const symbol = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.S)(layer, mapView);
    symbol.outline = renderer.outline;
    let stroke;
    if (symbol.type === "simple-fill") {
        if (symbol.outline) {
            const sym = symbol.outline;
            stroke = {
                color: sym.color ? sym.color : new modules.esriColor([0, 0, 0, 0.5]),
                size: sym.width,
                style: sym.style
            };
        }
        else {
            stroke = {
                color: new modules.esriColor([0, 0, 0, 0.5]),
                size: 1,
                style: "solid"
            };
        }
    }
    else if (symbol.type === "simple-marker" && symbol.outline) {
        const sym = symbol.outline;
        stroke = {
            color: sym.color ? sym.color : new modules.esriColor([0, 0, 0, 0.5]),
            size: sym.width,
            style: sym.style
        };
    }
    const symbolStyler = await createSymbolStylerElement(popoverNode);
    const edit = symbolStylerEdit(symbolStyler, symbol, {
        portal,
        sections: {
            marker: {
                parts: {
                    preview: false,
                    rotation: false,
                    size: false
                }
            },
            fill: {
                type: "color-ramp",
                style: "discrete",
                open: true,
                colorRampsOpen: true,
                colorRamps
            },
            stroke: {
                type: "color",
                optional: true,
                suggestedColors: suggestedStrokeColors,
                extraParts: {
                    style: false,
                    width: true,
                    autoStrokeAdjust: false
                }
            }
        },
        fill: {
            color: currentColors.reverse()
        },
        stroke
    });
    symbolStyler.stringOverrides = {
        fillColor: strings.styler.color,
        fillTransparency: strings.styler.transparency
    };
    symbolStyler.addEventListener("arcgisSymbolStylerEdit", onStylerEditWrapper.bind(null, onStylerEdit));
    popoverNode.addStyler(symbolStyler);
    await edit;
}
async function buildSymbolStylerForChartValue(options) {
    var _a;
    const { layer, mapView, selectedAttribute, lastDefault, portal, strings, modules } = _raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.s;
    const { onChange, popoverNode } = options;
    const renderer = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.h)(layer);
    const attributes = renderer.attributes;
    let color;
    if (selectedAttribute === -1) {
        color = ((_a = renderer.othersCategory) === null || _a === void 0 ? void 0 : _a.color) || (lastDefault === null || lastDefault === void 0 ? void 0 : lastDefault.otherColor) || new modules.esriColor([170, 170, 170, 1]);
    }
    else if (selectedAttribute === -2) {
        color = renderer.defaultColor || (lastDefault === null || lastDefault === void 0 ? void 0 : lastDefault.defaultColor) || new modules.esriColor([170, 170, 170, 1]);
    }
    else {
        color = attributes[selectedAttribute].color;
    }
    const schemes = modules.pieChartSchemes.getSchemes({
        basemap: mapView.map.basemap,
        geometryType: (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.D)(layer) || defaultGeometry,
        numColors: attributes.length
    });
    const suggestedFillColors = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.a7)(schemes).slice(0, 16);
    const onStylerEdit = ({ detail: { symbol /* ,
    info: { marker, stroke, fill } */ } }) => {
        var _a;
        if (selectedAttribute === -1) {
            if (!(0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.h)(layer).othersCategory) {
                (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.h)(layer).othersCategory = {
                    color: (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.t)(symbol),
                    label: (lastDefault === null || lastDefault === void 0 ? void 0 : lastDefault.otherLabel) || strings.styler.other,
                    threshold: (_a = lastDefault === null || lastDefault === void 0 ? void 0 : lastDefault.threshold) !== null && _a !== void 0 ? _a : 0
                };
            }
            else {
                (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.h)(layer).othersCategory.color = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.t)(symbol);
            }
        }
        else if (selectedAttribute === -2) {
            (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.h)(layer).defaultColor = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.t)(symbol);
        }
        else {
            (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.h)(layer).attributes[selectedAttribute].color = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.t)(symbol);
        }
        onChange();
    };
    const symbol = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.S)(layer, mapView);
    symbol.outline = undefined;
    (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.r)(symbol, color);
    const symbolStyler = await createSymbolStylerElement(popoverNode);
    const edit = symbolStylerEdit(symbolStyler, symbol, {
        portal,
        sections: {
            marker: {
                parts: {
                    preview: false,
                    rotation: false,
                    size: false
                }
            },
            fill: {
                type: "color",
                open: true,
                suggestedColorsOpen: true,
                suggestedColors: suggestedFillColors
            }
        },
        fill: {
            color
        }
    });
    symbolStyler.stringOverrides = {
        fillColor: strings.styler.color,
        fillTransparency: strings.styler.transparency
    };
    symbolStyler.addEventListener("arcgisSymbolStylerEdit", onStylerEditWrapper.bind(null, onStylerEdit));
    popoverNode.addStyler(symbolStyler);
    await edit;
}
async function buildSymbolStylerForDotDensityRamp(options) {
    const { layer, mapView, portal, strings, modules } = _raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.s;
    const { onChange, popoverNode } = options;
    const renderer = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.h)(layer);
    const attributes = renderer.attributes;
    const currentColors = attributes.map((attribute) => attribute.color);
    const schemes = modules.dotDensitySchemes.getSchemes({
        basemap: mapView.map.basemap,
        numColors: attributes.length
    });
    // TODO get current scheme
    const colorRampsAndSchemes = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.a9)(schemes, attributes.length);
    const colorRamps = colorRampsAndSchemes.map((obj) => {
        return {
            stops: obj.colors,
            tags: obj.scheme.tags,
            name: obj.scheme.name
        };
    });
    const onStylerEdit = ({ detail: { 
    //symbol,
    info: { /* marker, stroke, */ fill } } }) => {
        (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.h)(layer).attributes.forEach((attribute, idx) => (attribute.color = fill.color[idx]));
        onChange();
    };
    const symbolStyler = await createSymbolStylerElement(popoverNode);
    const edit = symbolStylerEdit(symbolStyler, (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.S)(layer, mapView), {
        portal,
        sections: {
            marker: {
                parts: {
                    preview: false,
                    rotation: false,
                    size: false
                }
            },
            fill: {
                type: "color-ramp",
                style: "discrete",
                open: true,
                colorRampsOpen: true,
                colorRamps
            }
        },
        fill: {
            color: currentColors
        }
    });
    symbolStyler.stringOverrides = {
        fillColor: strings.styler.dotColor,
        fillTransparency: strings.styler.dotTransparency
    };
    symbolStyler.addEventListener("arcgisSymbolStylerEdit", onStylerEditWrapper.bind(null, onStylerEdit));
    popoverNode.addStyler(symbolStyler);
    await edit;
}
async function buildSymbolStylerForDotDensityValue(options) {
    const { layer, mapView, portal, strings, modules } = _raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.s;
    const { onChange, popoverNode, selectedAttribute } = options;
    const renderer = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.h)(layer);
    const attributes = renderer.attributes;
    const schemes = modules.dotDensitySchemes.getSchemes({
        basemap: mapView.map.basemap,
        numColors: attributes.length
    });
    const suggestedFillColors = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.a7)(schemes).slice(0, 16);
    const onStylerEdit = ({ detail: { symbol /* ,
    info: { marker, stroke, fill } */ } }) => {
        (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.h)(layer).attributes[selectedAttribute].color = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.t)(symbol);
        onChange();
    };
    const symbolStyler = await createSymbolStylerElement(popoverNode);
    const edit = symbolStylerEdit(symbolStyler, (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.S)(layer, mapView), {
        portal,
        sections: {
            marker: {
                parts: {
                    preview: false,
                    rotation: false,
                    size: false
                }
            },
            fill: {
                type: "color",
                open: true,
                suggestedColorsOpen: true,
                suggestedColors: suggestedFillColors
            }
        },
        fill: {
            color: attributes[selectedAttribute].color
        }
    });
    symbolStyler.stringOverrides = {
        fillColor: strings.styler.dotColor,
        fillTransparency: strings.styler.dotTransparency
    };
    symbolStyler.addEventListener("arcgisSymbolStylerEdit", onStylerEditWrapper.bind(null, onStylerEdit));
    popoverNode.addStyler(symbolStyler);
    await edit;
}
async function buildSymbolStylerForHeatmapRamp(options) {
    const { layer, mapView, portal, strings, modules } = _raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.s;
    const { onChange, popoverNode } = options;
    const renderer = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.h)(layer);
    const colorStops = renderer.colorStops;
    const currentColors = colorStops
        .filter((__, idx) => idx >= 3)
        .map((colorStop) => colorStop.color);
    const basemapTheme = (await modules.colorUtils.getBackgroundColorTheme(mapView));
    const schemes = modules.heatmapSchemes.getSchemes({
        basemapTheme
    });
    // TODO get current scheme
    const colorRampsAndSchemes = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.a9)(schemes, colorStops.length);
    const colorRamps = colorRampsAndSchemes.map((obj) => {
        return {
            stops: obj.colors.reverse(),
            tags: obj.scheme.tags,
            name: obj.scheme.name
        };
    });
    const onStylerEdit = ({ detail: { 
    //symbol,
    info: { /* marker, stroke, */ fill } } }) => {
        const colors = modules.esriLang.clone(fill.color);
        colors.reverse();
        const buf = Math.max(colorStops.length - colors.length, 0);
        (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.h)(layer).colorStops.forEach((colorStop, idx) => {
            // keep alpha value because of fadeRatio
            const alpha = colorStop.color.a;
            if (idx <= buf - 2) {
                colorStop.color = modules.esriLang.clone(colors[0]);
            }
            else if (idx <= buf) {
                colorStop.color = modules.esriLang.clone(colors[0]);
            }
            else {
                colorStop.color = modules.esriLang.clone(colors[idx - buf]);
            }
            colorStop.color.a = alpha;
        });
        onChange();
    };
    const symbolStyler = await createSymbolStylerElement(popoverNode);
    const edit = symbolStylerEdit(symbolStyler, (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.S)(layer, mapView), {
        portal,
        sections: {
            marker: {
                parts: {
                    preview: false,
                    rotation: false,
                    size: false
                }
            },
            fill: {
                type: "color-ramp",
                style: "continuous",
                open: true,
                colorRampsOpen: true,
                colorRamps,
                parts: {
                    transparency: false // temp /arcgis-js-api/issues/27188
                }
            }
        },
        fill: {
            color: currentColors.reverse()
        }
    });
    symbolStyler.stringOverrides = {
        fillTransparency: strings.styler.transparency
    };
    symbolStyler.addEventListener("arcgisSymbolStylerEdit", onStylerEditWrapper.bind(null, onStylerEdit));
    popoverNode.addStyler(symbolStyler);
    await edit;
}
// --------------------------------------------------------------------------
//
//  utils
//
// --------------------------------------------------------------------------
function updateAutoVisVar(symbol, markerAutoAdjusted, strokeAutoAdjusted, symbolStyler, options) {
    const { layer, modules } = _raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.s;
    const isPoint = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.A)(layer);
    const isLine = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.B)(layer);
    if (isPoint) {
        updateSizeAutoVisVar(markerAutoAdjusted, (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.T)(symbol), symbol, symbolStyler, options);
    }
    else if (isLine) {
        updateSizeAutoVisVar(strokeAutoAdjusted, (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.T)(symbol), symbol, symbolStyler, options);
    }
    else {
        updateOutlineAutoVisVar(strokeAutoAdjusted, symbol.type === "cim"
            ? (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.ap)(symbol)
            : (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.T)(symbol.outline || new modules.SimpleLineSymbol()), symbol, symbolStyler, options);
    }
}
function updateSizeAutoVisVar(autoAdjusted, newSize, symbol, symbolStyler, options) {
    const { layer, mapView } = _raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.s;
    const { onChange } = options;
    const renderer = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.h)(layer);
    newSize = Math.max(newSize, 0.1);
    const sizeAutoVisVar = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.a)(renderer, "size", "auto");
    if (autoAdjusted && !sizeAutoVisVar) {
        // need to create that visualVariable
        (0,_location_e26b539f_js__WEBPACK_IMPORTED_MODULE_4__.b)().then((sizeAutoVisVar) => {
            if (sizeAutoVisVar) {
                const rend = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.h)(layer);
                rend.visualVariables = rend.visualVariables || [];
                rend.visualVariables.push(sizeAutoVisVar);
                if ((0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.ak)(symbol)) {
                    // update sizeAutoVisVar and use current symbol size
                    const oldSize = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.T)(symbol);
                    const newSize = getSizeByScale(sizeAutoVisVar, mapView.scale);
                    const factor = oldSize / newSize;
                    updateAutoSizeStops(sizeAutoVisVar, factor);
                }
                // display new (default) size in SymbolStyler
                updateSymbolStylerWithSize(sizeAutoVisVar, mapView.scale, symbol, symbolStyler);
            }
            onChange();
        });
    }
    else if (!autoAdjusted && sizeAutoVisVar) {
        // remove visualVariable
        const visVars = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.n)(renderer, "size", "auto");
        if (visVars === null || visVars === void 0 ? void 0 : visVars.length) {
            renderer.visualVariables = visVars;
        }
        else {
            renderer.visualVariables = undefined;
        }
        //symbolStyler.setSize(symbolType === "simple-line" ? "stroke" : "marker", newSize);
        onChange();
    }
    else {
        if (autoAdjusted) {
            adjustAutoSizeForSymbol(newSize);
        }
        onChange();
    }
}
function adjustAutoSizeForSymbol(newSize) {
    const { layer, mapView } = _raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.s;
    const scale = mapView.scale;
    const renderer = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.h)(layer);
    const sizeAutoVisVar = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.a)(renderer, "size", "auto");
    const oldSize = getSizeByScale(sizeAutoVisVar, scale);
    const factor = newSize / oldSize;
    updateAutoSizeStops(sizeAutoVisVar, factor);
}
function updateOutlineAutoVisVar(autoAdjusted, newSize, symbol, symbolStyler, options) {
    const { layer, mapView } = _raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.s;
    const { onChange } = options;
    const renderer = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.h)(layer);
    const sizeOutlineVisVar = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.a)(renderer, "size", "outline");
    if (autoAdjusted && !sizeOutlineVisVar) {
        // need to create that visualVariable
        (0,_location_e26b539f_js__WEBPACK_IMPORTED_MODULE_4__.a)().then((sizeOutlineVisVar) => {
            if (sizeOutlineVisVar) {
                const rend = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.h)(layer);
                rend.visualVariables = rend.visualVariables || [];
                rend.visualVariables.push(sizeOutlineVisVar);
                updateSymbolStylerWithSize(sizeOutlineVisVar, mapView.scale, symbol, symbolStyler);
            }
            onChange();
        });
    }
    else if (!autoAdjusted && sizeOutlineVisVar) {
        // remove visualVariable
        renderer.visualVariables = renderer.visualVariables.filter((visVar) => !(visVar.type === "size" && visVar.target === "outline"));
        if (renderer.visualVariables && !renderer.visualVariables.length) {
            renderer.visualVariables = undefined;
        }
        onChange();
    }
    else {
        if (autoAdjusted) {
            adjustAutoOutline(newSize, options);
        }
        onChange();
    }
}
function adjustAutoOutline(newSize, options) {
    const { layer, mapView } = _raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.s;
    const { onChange } = options;
    const scale = mapView.scale;
    let renderer = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.h)(layer);
    const sizeAutoVisVar = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.a)(renderer, "size", "outline");
    /* console.log(
      "sizeAutoVisVar 1",
      sizeAutoVisVar.stops.map((s: any) => {
        return {
          size: s.size,
          sizePx: Math.round((s.size / 0.75) * 100) / 100,
          value: new Intl.NumberFormat().format(s.value)
        };
      })
    ); */
    const stops = sizeAutoVisVar.stops;
    if (newSize !== 0 && stops[stops.length - 2].size === 0) {
        // 2 or more stops have value zero; build new stops
        (0,_location_e26b539f_js__WEBPACK_IMPORTED_MODULE_4__.a)().then((sizeOutlineVisVar) => {
            if (sizeOutlineVisVar) {
                const oldSize = getSizeByScale(sizeOutlineVisVar, scale);
                const factor = (newSize === 0 ? Math.max(0.5, newSize) : newSize) / (oldSize === 0 ? Math.max(0.5, oldSize) : oldSize);
                updateAutoSizeStops(sizeOutlineVisVar, factor);
                const visVars = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.n)((0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.h)(layer), "size", "outline") || [];
                visVars.push(sizeOutlineVisVar);
                (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.h)(layer).visualVariables = visVars; // not renderer.visualVariables = visVars;
                onChange();
                setTimeout(() => { }, 2000);
            }
        });
    }
    else {
        const oldSize = getSizeByScale(sizeAutoVisVar, scale);
        const factor = (newSize === 0 ? Math.max(0.5, newSize) : newSize) / (oldSize === 0 ? Math.max(0.5, oldSize) : oldSize);
        updateAutoSizeStops(sizeAutoVisVar, factor);
        if (newSize === 0 || oldSize === 0) {
            // because we adjusted the factor...
            setSizeByScaleToValue(sizeAutoVisVar, scale, newSize);
            // prevent 2 stops with same size...
            sizeAutoVisVar.stops.forEach((s, idx) => {
                if (idx > 0) {
                    if (s.size === sizeAutoVisVar.stops[idx - 1].size) {
                        // we don't want twice the same size
                        if (idx === sizeAutoVisVar.stops.length - 1) {
                            if (idx > 1) {
                                sizeAutoVisVar.stops[idx - 1].size = (sizeAutoVisVar.stops[idx - 2].size + s.size) / 2;
                            } // else should not happen; then change nothing
                        }
                        else {
                            // take middle size
                            s.size = (sizeAutoVisVar.stops[idx + 1].size + sizeAutoVisVar.stops[idx - 1].size) / 2;
                        }
                    }
                }
            });
        }
    }
}
function setSizeByScaleToValue(sizeAutoVisVar, scale, value) {
    // figure out current stop considering map scale
    // then set that value and all the ones with a larger scale to 0
    const sizeStops = sizeAutoVisVar.stops;
    const stopsCount = sizeStops.length;
    const finalIndex = stopsCount - 1;
    const scaleMin = sizeStops[0].value;
    const scaleMax = sizeStops[finalIndex].value;
    if (scale <= scaleMin) {
        // everything set to value
        for (let i = 0; i <= finalIndex; i++) {
            sizeStops[i].size = value;
        }
        return;
    }
    if (scale >= scaleMax) {
        sizeStops[finalIndex].size = value;
        return;
    }
    for (let i = 0; i < finalIndex; i++) {
        const currentStop = sizeStops[i];
        const nextStop = sizeStops[i + 1];
        if (scale >= currentStop.value && scale < nextStop.value) {
            // set current stop and all with lower scale to value
            for (let k = i + 1; k <= finalIndex; k++) {
                sizeStops[k].size = value;
            }
            break;
        }
    }
}
function updateAutoSizeStops(sizeAutoVisVar, factor) {
    sizeAutoVisVar.stops.forEach((stop) => {
        stop.size *= factor;
    });
}
function createWatchScaleHandle(symbol, symbolStyler, onSizeChangeHandler) {
    const { layer, mapView, modules } = _raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.s;
    let oldScale;
    return modules.reactiveUtils.when(() => mapView.stationary, () => {
        const newScale = mapView.scale;
        if (oldScale !== newScale) {
            const renderer = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.h)(layer);
            const sizeAutoVisVar = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.a)(renderer, "size", symbol.type === "simple-fill" ? "outline" : "auto");
            if (sizeAutoVisVar) {
                /* console.log(
                "scale",
                new Intl.NumberFormat().format(newScale),
                "size",
                getSizeByScale(sizeAutoVisVar, newScale),
                "sizePx",
                Math.round((getSizeByScale(sizeAutoVisVar, newScale) / 0.75) * 100) / 100
              ); */
                updateSymbolStylerWithSize(sizeAutoVisVar, newScale, symbol, symbolStyler, onSizeChangeHandler);
            }
            oldScale = newScale;
        }
    });
}
function updateSymbolStylerWithSize(sizeAutoVisVar, newScale, symbol, symbolStyler, onSizeChangeHandler) {
    const newSize = getSizeByScale(sizeAutoVisVar, newScale);
    const type = ["simple-line", "simple-fill"].indexOf(symbol.type) > -1 || (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.ak)(symbol) ? "stroke" : "marker";
    symbolStyler.setSize(type, newSize);
    onSizeChangeHandler === null || onSizeChangeHandler === void 0 ? void 0 : onSizeChangeHandler(newSize);
}
function adjustAlpha(color, alpha) {
    if (color) {
        color.a = alpha;
    }
    return color;
}
function getCimLineProps(sym) {
    var _a, _b, _c;
    // point: outline
    // line: main line
    // polygon: outline
    const { modules } = _raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.s;
    if ((0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.ak)(sym)) {
        return {
            color: ((_a = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.t)(sym)) === null || _a === void 0 ? void 0 : _a.clone()) || new modules.esriColor([255, 255, 255, 0.5]),
            size: (_b = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.T)(sym)) !== null && _b !== void 0 ? _b : 1
        };
    }
    else {
        const outline = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.al)(sym);
        return {
            color: new modules.esriColor(outline === null || outline === void 0 ? void 0 : outline.color) || new modules.esriColor([255, 255, 255, 0.5]),
            size: (_c = outline === null || outline === void 0 ? void 0 : outline.width) !== null && _c !== void 0 ? _c : 1
        };
    }
}
function isSupportedSymbol(sym) {
    return ["simple-fill", "simple-marker", "simple-line", "picture-marker", "cim"].indexOf(sym === null || sym === void 0 ? void 0 : sym.type) > -1;
}
function isColoredSymbol(sym) {
    return ["simple-fill", "simple-marker", "simple-line", "cim"].indexOf(sym.type) > -1;
}
/* function printSymbolProps(text: string, sym: any) {
  console.log(
    text,
    sym.type,
    sym.type === "cim" ? cimSymbolUtils.getCIMSymbolSize(sym) : sym.size ?? sym.width,
    sym.type === "cim" ? cimSymbolUtils.getCIMSymbolColor(sym).toJSON() : sym.color.toJSON(),
    sym.type === "cim" ? getCimPointOutline(sym)?.color : sym.outline?.color?.toJSON(),
    sym.type === "cim" ? getCimPointOutline(sym)?.width : sym.outline?.width
  );
} */



//# sourceMappingURL=symbolStyler-04635b2b.js.map

/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid2lkZ2V0cy9jaHVua3MvYXJjZ2lzX2FuYWx5c2lzX25vZGVfbW9kdWxlc19hcmNnaXNfYXBwLWNvbXBvbmVudHNfZGlzdF9lc21fc3ltYm9sLWZjYWQ5ZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUM0SjtBQUN6SDtBQUM0Qjs7QUFFL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxxREFBcUQsRUFBRSwrREFBaUI7QUFDcEY7QUFDQTtBQUNBLG1CQUFtQixtRUFBZ0IsQ0FBQyxtRUFBVztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYywrREFBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsK0RBQVM7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLFFBQVEsbUVBQWlCO0FBQ3pCO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxtQ0FBbUMsRUFBRSwrREFBaUI7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLGtDQUFrQyxtRUFBUztBQUMzQztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxZQUFZLG1DQUFtQyxFQUFFLCtEQUFpQjtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCwrQkFBK0IsbUVBQVM7QUFDeEM7QUFDQSxLQUFLO0FBQ0w7O0FBRXdGOztBQUV4Rjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3RFQTtBQUNBO0FBQ0E7QUFDQTtBQUM2c0I7QUFDMXFCO0FBQ0E7QUFDNEI7QUFDNEI7O0FBRTNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxpQkFBaUIsRUFBRSwrREFBaUI7QUFDaEQscUJBQXFCLG1FQUFXO0FBQ2hDO0FBQ0E7QUFDQSx1QkFBdUIsbUVBQVM7QUFDaEMsaUNBQWlDLCtEQUFT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WUFBWSxVQUFVLEVBQUUsK0RBQWlCO0FBQ3pDLFFBQVEsb0VBQWU7QUFDdkI7QUFDQSwwQkFBMEIsbUVBQWM7QUFDeEMsd0JBQXdCLG1FQUFhO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixvRUFBVTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVnNUI7O0FBRWw1QiIsInNvdXJjZXMiOlsid2VicGFjazovL2V4Yi1jbGllbnQvLi9leHRlbnNpb25zL3dpZGdldHMvYXJjZ2lzL2FuYWx5c2lzL25vZGVfbW9kdWxlcy9AYXJjZ2lzL2FwcC1jb21wb25lbnRzL2Rpc3QvZXNtL2xvY2F0aW9uLWUyNmI1MzlmLmpzIiwid2VicGFjazovL2V4Yi1jbGllbnQvLi9leHRlbnNpb25zL3dpZGdldHMvYXJjZ2lzL2FuYWx5c2lzL25vZGVfbW9kdWxlcy9AYXJjZ2lzL2FwcC1jb21wb25lbnRzL2Rpc3QvZXNtL3N5bWJvbFN0eWxlci0wNDYzNWIyYi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIEFsbCBtYXRlcmlhbCBjb3B5cmlnaHQgRVNSSSwgQWxsIFJpZ2h0cyBSZXNlcnZlZCwgdW5sZXNzIG90aGVyd2lzZSBzcGVjaWZpZWQuXG4gKiB2NC4wLjU4XG4gKi9cbmltcG9ydCB7IGwgYXMgYXBwbHlFeHRyYVZpc1ZhcnMsIHMgYXMgc21hcnRNYXBwaW5nU3RhdGUsIG0gYXMgc2F2ZUV4dHJhVmlzVmFycywgaCBhcyBnZXRSZW5kZXJlciwgYSBhcyBnZXRWaXNWYXIgfSBmcm9tICcuL3Jhc3Rlci11bmlxdWUtdmFsdWUtMDk3NmVjN2YuanMnO1xuaW1wb3J0ICcuL2xvYWRNb2R1bGVzLWI0YWMxMjQ3LmpzJztcbmltcG9ydCB7IGkgYXMgaXNEZWZpbmVkIH0gZnJvbSAnLi9jb21tb25GdW5jdGlvbnMtYjA4MzBlOWUuanMnO1xuXG4vKipcbiAqIFVwZGF0ZXMgdGhlIGxheWVyIHdpdGggYSBTaW1wbGUgcmVuZGVyZXIgd2l0aCBkZWZhdWx0IHNldHRpbmdzXG4gKiBAcGFyYW0gb3B0aW9uczogb3B0aW9uc1xuICovXG5mdW5jdGlvbiBjcmVhdGVTaW1wbGVSZW5kZXJlcihvcHRpb25zKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IHsgbGF5ZXI6IHNtTGF5ZXIsIG1hcEltYWdlU3VibGF5ZXIsIG1hcFZpZXcsIG1vZHVsZXMgfSA9IHNtYXJ0TWFwcGluZ1N0YXRlO1xuICAgIGNvbnN0IGxheWVyID0gc21MYXllcjtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBjb25zdCBleHRyYXMgPSBzYXZlRXh0cmFWaXNWYXJzKGdldFJlbmRlcmVyKGxheWVyKSk7XG4gICAgcmV0dXJuIG1vZHVsZXMuTG9jYXRpb25DcmVhdG9yLmNyZWF0ZVJlbmRlcmVyKHtcbiAgICAgICAgbGF5ZXIsXG4gICAgICAgIHZpZXc6IG1hcFZpZXcsXG4gICAgICAgIG91dGxpbmVPcHRpbWl6YXRpb25FbmFibGVkOiBtYXBJbWFnZVN1YmxheWVyXG4gICAgICAgICAgICA/IGZhbHNlXG4gICAgICAgICAgICA6IGlzRGVmaW5lZChvcHRpb25zLm91dGxpbmVPcHRpbWl6YXRpb25FbmFibGVkKVxuICAgICAgICAgICAgICAgID8gb3B0aW9ucy5vdXRsaW5lT3B0aW1pemF0aW9uRW5hYmxlZFxuICAgICAgICAgICAgICAgIDogdHJ1ZSxcbiAgICAgICAgc2l6ZU9wdGltaXphdGlvbkVuYWJsZWQ6IG1hcEltYWdlU3VibGF5ZXJcbiAgICAgICAgICAgID8gZmFsc2VcbiAgICAgICAgICAgIDogaXNEZWZpbmVkKG9wdGlvbnMuc2l6ZU9wdGltaXphdGlvbkVuYWJsZWQpXG4gICAgICAgICAgICAgICAgPyBvcHRpb25zLnNpemVPcHRpbWl6YXRpb25FbmFibGVkXG4gICAgICAgICAgICAgICAgOiB0cnVlLFxuICAgICAgICBmb3JCaW5uaW5nOiAoKF9hID0gbGF5ZXIuZmVhdHVyZVJlZHVjdGlvbikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnR5cGUpID09PSBcImJpbm5pbmdcIlxuICAgIH0pLnRoZW4oKHJlc3VsdCkgPT4ge1xuICAgICAgICBhcHBseUV4dHJhVmlzVmFycyhleHRyYXMsIHJlc3VsdC5yZW5kZXJlcik7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocmVzdWx0KTtcbiAgICB9LCAoZXJyb3IpID0+IFByb21pc2UucmVqZWN0KGVycm9yKSk7XG59XG5mdW5jdGlvbiBidWlsZE91dGxpbmVWaXNWYXIoKSB7XG4gICAgdmFyIF9hO1xuICAgIC8vIFRPRE8gLSBjYW4gd2UganVzdCBnZXQgdGhlIHZpc3VhbFZhcmlhYmxlIHdpdGhvdXQgYSBmdWxsIHJlbmRlcmVyP1xuICAgIGNvbnN0IHsgbGF5ZXI6IHNtTGF5ZXIsIG1hcFZpZXcsIG1vZHVsZXMgfSA9IHNtYXJ0TWFwcGluZ1N0YXRlO1xuICAgIGNvbnN0IGxheWVyID0gc21MYXllcjtcbiAgICByZXR1cm4gbW9kdWxlcy5Mb2NhdGlvbkNyZWF0b3IuY3JlYXRlUmVuZGVyZXIoe1xuICAgICAgICBsYXllcixcbiAgICAgICAgdmlldzogbWFwVmlldyxcbiAgICAgICAgb3V0bGluZU9wdGltaXphdGlvbkVuYWJsZWQ6IHRydWUsXG4gICAgICAgIGZvckJpbm5pbmc6ICgoX2EgPSBsYXllci5mZWF0dXJlUmVkdWN0aW9uKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudHlwZSkgPT09IFwiYmlubmluZ1wiXG4gICAgfSkudGhlbigocmVzdWx0KSA9PiB7XG4gICAgICAgIGNvbnN0IHNpemVPdXRsaW5lVmlzVmFyID0gZ2V0VmlzVmFyKHJlc3VsdC5yZW5kZXJlciwgXCJzaXplXCIsIFwib3V0bGluZVwiKTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShzaXplT3V0bGluZVZpc1Zhcik7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBidWlsZFNpemVBdXRvVmlzVmFyKCkge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCB7IGxheWVyOiBzbUxheWVyLCBtYXBWaWV3LCBtb2R1bGVzIH0gPSBzbWFydE1hcHBpbmdTdGF0ZTtcbiAgICBjb25zdCBsYXllciA9IHNtTGF5ZXI7XG4gICAgcmV0dXJuIG1vZHVsZXMuTG9jYXRpb25DcmVhdG9yLmNyZWF0ZVJlbmRlcmVyKHtcbiAgICAgICAgbGF5ZXIsXG4gICAgICAgIHZpZXc6IG1hcFZpZXcsXG4gICAgICAgIG91dGxpbmVPcHRpbWl6YXRpb25FbmFibGVkOiBmYWxzZSxcbiAgICAgICAgc2l6ZU9wdGltaXphdGlvbkVuYWJsZWQ6IHRydWUsXG4gICAgICAgIGZvckJpbm5pbmc6ICgoX2EgPSBsYXllci5mZWF0dXJlUmVkdWN0aW9uKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudHlwZSkgPT09IFwiYmlubmluZ1wiXG4gICAgfSkudGhlbigocmVzdWx0KSA9PiB7XG4gICAgICAgIGNvbnN0IHNpemVBdXRvVmlzVmFyID0gZ2V0VmlzVmFyKHJlc3VsdC5yZW5kZXJlciwgXCJzaXplXCIsIFwiYXV0b1wiKTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShzaXplQXV0b1Zpc1Zhcik7XG4gICAgfSk7XG59XG5cbmV4cG9ydCB7IGJ1aWxkT3V0bGluZVZpc1ZhciBhcyBhLCBidWlsZFNpemVBdXRvVmlzVmFyIGFzIGIsIGNyZWF0ZVNpbXBsZVJlbmRlcmVyIGFzIGMgfTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bG9jYXRpb24tZTI2YjUzOWYuanMubWFwIiwiLyohXG4gKiBBbGwgbWF0ZXJpYWwgY29weXJpZ2h0IEVTUkksIEFsbCBSaWdodHMgUmVzZXJ2ZWQsIHVubGVzcyBvdGhlcndpc2Ugc3BlY2lmaWVkLlxuICogdjQuMC41OFxuICovXG5pbXBvcnQgeyBoIGFzIGdldFJlbmRlcmVyLCBhIGFzIGdldFZpc1ZhciwgVCBhcyBnZXRTeW1ib2xTaXplLCBVIGFzIGFwcGx5U3ltYm9sU2l6ZSwgcyBhcyBzbWFydE1hcHBpbmdTdGF0ZSwgcSBhcyBpc1BvbHlnb25UeXBlLCBhNSBhcyBoYXNTeW1ib2xPdXRsaW5lLCByIGFzIGFwcGx5U3ltYm9sQ29sb3IsIEEgYXMgaXNQb2ludFR5cGUsIEIgYXMgaXNQb2x5bGluZVR5cGUsIGcgYXMgZ2V0UmVuZGVyZXJUeXBlLCBTIGFzIGdldERlZmF1bHRTeW1ib2wsIGE4IGFzIGxheWVyU3VwcG9ydHNDSU0sIHQgYXMgZ2V0U3ltYm9sQ29sb3IsIGE2IGFzIGlzUGljdHVyZU1hcmtlciwgYWggYXMgZ2V0R2VvUlNTRGVmYXVsdFN5bWJvbCwgcCBhcyBnZXRBdXRoVmlzVmFyLCBEIGFzIGdldEdlb21ldHJ5VHlwZSwgYWkgYXMgaXNMaW5lTWFya2VyLCBpIGFzIGlzUmFzdGVyTGF5ZXIsIGFqIGFzIGdldFJhc3RlckRlZmF1bHRTeW1ib2wsIGE3IGFzIGdldEZpbGxDb2xvcnMsIGE5IGFzIGdldENvbG9yUmFtcHNXaXRoU2NoZW1lcywgYWsgYXMgaXNDaW1MaW5lU3ltYm9sLCBhbCBhcyBnZXRDaW1MaW5lLCBhbSBhcyBnZXRTeW1ib2xDaGFuZ2VzLCBhbiBhcyB1cGRhdGVTeW1ib2wsIGFvIGFzIGFwcGx5QWxwaGEsIGFwIGFzIGdldENJTU91dGxpbmVXaWR0aCwgbiBhcyBnZXRWaXNWYXJzRXhjZXB0IH0gZnJvbSAnLi9yYXN0ZXItdW5pcXVlLXZhbHVlLTA5NzZlYzdmLmpzJztcbmltcG9ydCAnLi9sb2FkTW9kdWxlcy1iNGFjMTI0Ny5qcyc7XG5pbXBvcnQgJy4vY29tbW9uRW51bXMtZmNmMTM2NjEuanMnO1xuaW1wb3J0IHsgaSBhcyBpc0RlZmluZWQgfSBmcm9tICcuL2NvbW1vbkZ1bmN0aW9ucy1iMDgzMGU5ZS5qcyc7XG5pbXBvcnQgeyBiIGFzIGJ1aWxkU2l6ZUF1dG9WaXNWYXIsIGEgYXMgYnVpbGRPdXRsaW5lVmlzVmFyIH0gZnJvbSAnLi9sb2NhdGlvbi1lMjZiNTM5Zi5qcyc7XG5cbi8qKlxuICogR2V0IGxvdyBhbmQgaGlnaCB2YWx1ZXMgb2Ygc2l6ZSByYW5nZSBpbiBjdXJyZW50IG1hcCBzY2FsZSAoaWYgYXBwbGljYWJsZSlcbiAqL1xuZnVuY3Rpb24gZ2V0UmFuZ2VWYWx1ZXMoKSB7XG4gICAgY29uc3QgeyBtYXBWaWV3LCBsYXllciB9ID0gc21hcnRNYXBwaW5nU3RhdGU7XG4gICAgY29uc3QgcmVuZGVyZXIgPSBnZXRSZW5kZXJlcihsYXllcik7XG4gICAgY29uc3QgYXV0aEluZm8gPSByZW5kZXJlci5hdXRob3JpbmdJbmZvO1xuICAgIGNvbnN0IGluZm9zID0gcmVuZGVyZXIudHlwZSA9PT0gXCJjbGFzcy1icmVha3NcIiA/IHJlbmRlcmVyLmNsYXNzQnJlYWtJbmZvcyA6IHJlbmRlcmVyLnVuaXF1ZVZhbHVlSW5mb3M7XG4gICAgY29uc3Qgc2l6ZVZpc1ZhciA9IGdldFZpc1ZhcihyZW5kZXJlciwgXCJzaXplXCIpO1xuICAgIGNvbnN0IGlzTnVsbCA9IHNpemVWaXNWYXIgPyAhaXNEZWZpbmVkKHNpemVWaXNWYXIubWluU2l6ZSkgOiBmYWxzZTsgLy8gdGhlbiB3ZSBoYXZlIHN0b3BzICg9IGZpeGVkKVxuICAgIGNvbnN0IGlzTnVtYmVyID0gc2l6ZVZpc1ZhciA/IHR5cGVvZiBzaXplVmlzVmFyLm1pblNpemUgPT09IFwibnVtYmVyXCIgOiBmYWxzZTtcbiAgICBjb25zdCBpc0Fib3ZlQW5kQmVsb3cgPSAoYXV0aEluZm8gPT09IG51bGwgfHwgYXV0aEluZm8gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGF1dGhJbmZvLnVuaXZhcmlhdGVUaGVtZSkgPT09IFwiYWJvdmUtYW5kLWJlbG93XCI7XG4gICAgbGV0IGxvd1ZhbHVlID0gMiwgaGlnaFZhbHVlID0gMjA7XG4gICAgaWYgKHNpemVWaXNWYXIpIHtcbiAgICAgICAgaWYgKGlzQWJvdmVBbmRCZWxvdykge1xuICAgICAgICAgICAgLy8gNSBzdG9wcywgY2VudGVyIGlzIHNtYWxsZXN0XG4gICAgICAgICAgICBjb25zdCBzdG9wcyA9IHNpemVWaXNWYXIuc3RvcHM7XG4gICAgICAgICAgICBbbG93VmFsdWUsIGhpZ2hWYWx1ZV0gPSBbc3RvcHNbMl0uc2l6ZSwgTWF0aC5tYXgoc3RvcHNbMF0uc2l6ZSwgc3RvcHNbNF0uc2l6ZSldO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzTnVsbCkge1xuICAgICAgICAgICAgY29uc3Qgc3RvcHMgPSBzaXplVmlzVmFyLnN0b3BzO1xuICAgICAgICAgICAgW2xvd1ZhbHVlLCBoaWdoVmFsdWVdID0gW3N0b3BzWzBdLnNpemUsIHN0b3BzW3N0b3BzLmxlbmd0aCAtIDFdLnNpemVdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzTnVtYmVyKSB7XG4gICAgICAgICAgICBbbG93VmFsdWUsIGhpZ2hWYWx1ZV0gPSBbc2l6ZVZpc1Zhci5taW5TaXplLCBzaXplVmlzVmFyLm1heFNpemVdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgbWFwU2NhbGUgPSBtYXBWaWV3LnNjYWxlO1xuICAgICAgICAgICAgY29uc3QgbWluU3RvcHMgPSBzaXplVmlzVmFyLm1pblNpemUuc3RvcHM7XG4gICAgICAgICAgICBjb25zdCBtYXhTdG9wcyA9IHNpemVWaXNWYXIubWF4U2l6ZS5zdG9wcztcbiAgICAgICAgICAgIFtsb3dWYWx1ZSwgaGlnaFZhbHVlXSA9IFttaW5TdG9wc1ttaW5TdG9wcy5sZW5ndGggLSAxXS5zaXplLCBtYXhTdG9wc1ttYXhTdG9wcy5sZW5ndGggLSAxXS5zaXplXTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWluU3RvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtaW5TdG9wID0gbWluU3RvcHNbaV07XG4gICAgICAgICAgICAgICAgY29uc3QgbWF4U3RvcCA9IG1heFN0b3BzW2ldO1xuICAgICAgICAgICAgICAgIGlmIChtYXBTY2FsZSA8PSBtaW5TdG9wLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW50ZXJwb2xhdGUgdG8gZ2V0IGNvcnJlY3Qgc2l6ZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBsYXN0TWluU3RvcCA9IG1pblN0b3BzW2kgLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBsYXN0TWF4U3RvcCA9IG1heFN0b3BzW2kgLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGZhY3RvciA9IChtYXBTY2FsZSAtIGxhc3RNaW5TdG9wLnZhbHVlKSAvIChtaW5TdG9wLnZhbHVlIC0gbGFzdE1pblN0b3AudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgW2xvd1ZhbHVlLCBoaWdoVmFsdWVdID0gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RNaW5TdG9wLnNpemUgKyAobWluU3RvcC5zaXplIC0gbGFzdE1pblN0b3Auc2l6ZSkgKiBmYWN0b3IsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFzdE1heFN0b3Auc2l6ZSArIChtYXhTdG9wLnNpemUgLSBsYXN0TWF4U3RvcC5zaXplKSAqIGZhY3RvclxuICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRvbid0IGludGVycG9sYXRlOyB1c2UgbG93ZXN0IHNpemVzXG4gICAgICAgICAgICAgICAgICAgICAgICBbbG93VmFsdWUsIGhpZ2hWYWx1ZV0gPSBbbWluU3RvcHNbMF0uc2l6ZSwgbWF4U3RvcHNbMF0uc2l6ZV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGluZm9zKSB7XG4gICAgICAgIGNvbnN0IG1pblN5bSA9IGluZm9zWzBdLnN5bWJvbDtcbiAgICAgICAgY29uc3QgbWF4U3ltID0gaW5mb3NbaW5mb3MubGVuZ3RoIC0gMV0uc3ltYm9sO1xuICAgICAgICBbbG93VmFsdWUsIGhpZ2hWYWx1ZV0gPSBbZ2V0U3ltYm9sU2l6ZShtaW5TeW0pLCBnZXRTeW1ib2xTaXplKG1heFN5bSldO1xuICAgICAgICBpZiAobG93VmFsdWUgPiBoaWdoVmFsdWUpIHtcbiAgICAgICAgICAgIFtsb3dWYWx1ZSwgaGlnaFZhbHVlXSA9IFtoaWdoVmFsdWUsIGxvd1ZhbHVlXTtcbiAgICAgICAgfVxuICAgIH0gLy8gZWxzZSB3cm9uZyByZW5kZXJlclxuICAgIHJldHVybiBbbG93VmFsdWUsIGhpZ2hWYWx1ZV07XG59XG4vKipcbiAqIFNldCBuZXcgbG93IGFuZCBoaWdoIHZhbHVlcyBvZiBzaXplIHJhbmdlIGluIGN1cnJlbnQgbWFwIHNjYWxlIChpZiBhcHBsaWNhYmxlKVxuICovXG5mdW5jdGlvbiBzZXRSYW5nZVZhbHVlcyh2YWx1ZXMpIHtcbiAgICBjb25zdCB7IG1hcFZpZXcsIGxheWVyLCBtb2R1bGVzIH0gPSBzbWFydE1hcHBpbmdTdGF0ZTtcbiAgICBjb25zdCByZW5kZXJlciA9IGdldFJlbmRlcmVyKGxheWVyKTsgLy8gb3IgYW55IG90aGVyIHJlbmRlcmVyIHdpdGggc2l6ZVZpc1ZhclxuICAgIGNvbnN0IHNpemVWaXNWYXIgPSBnZXRWaXNWYXIocmVuZGVyZXIsIFwic2l6ZVwiKTtcbiAgICBsZXQgbmV3TG93VmFsdWUgPSB2YWx1ZXNbMF07XG4gICAgbGV0IG5ld0hpZ2hWYWx1ZSA9IGlzRGVmaW5lZCh2YWx1ZXNbMV0pID8gdmFsdWVzWzFdIDogbmV3TG93VmFsdWU7XG4gICAgaWYgKHNpemVWaXNWYXIpIHtcbiAgICAgICAgY29uc3QgYXV0aEluZm8gPSByZW5kZXJlci5hdXRob3JpbmdJbmZvO1xuICAgICAgICBjb25zdCBpc0Fib3ZlQW5kQmVsb3cgPSAoYXV0aEluZm8gPT09IG51bGwgfHwgYXV0aEluZm8gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGF1dGhJbmZvLnVuaXZhcmlhdGVUaGVtZSkgPT09IFwiYWJvdmUtYW5kLWJlbG93XCI7XG4gICAgICAgIGNvbnN0IGlzTnVsbCA9IHNpemVWaXNWYXIgPyAhaXNEZWZpbmVkKHNpemVWaXNWYXIubWluU2l6ZSkgOiBmYWxzZTsgLy8gdGhlbiB3ZSBoYXZlIHN0b3BzICg9IGZpeGVkKVxuICAgICAgICBjb25zdCBpc051bWJlciA9IHNpemVWaXNWYXIgPyB0eXBlb2Ygc2l6ZVZpc1Zhci5taW5TaXplID09PSBcIm51bWJlclwiIDogZmFsc2U7XG4gICAgICAgIGxldCBbbG93VmFsdWUsIGhpZ2hWYWx1ZV0gPSBnZXRSYW5nZVZhbHVlcygpO1xuICAgICAgICBjb25zdCBpc0ludmVydGVkID0gbG93VmFsdWUgPiBoaWdoVmFsdWU7XG4gICAgICAgIGlmICghaXNJbnZlcnRlZCAmJiBuZXdMb3dWYWx1ZSA+PSBoaWdoVmFsdWUpIHtcbiAgICAgICAgICAgIG5ld0xvd1ZhbHVlID0gaGlnaFZhbHVlIC0gMC43NTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc0ludmVydGVkICYmIG5ld0xvd1ZhbHVlID49IGxvd1ZhbHVlKSB7XG4gICAgICAgICAgICBuZXdMb3dWYWx1ZSA9IGxvd1ZhbHVlIC0gMC43NTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzSW52ZXJ0ZWQgJiYgbG93VmFsdWUgPj0gbmV3SGlnaFZhbHVlKSB7XG4gICAgICAgICAgICBuZXdIaWdoVmFsdWUgPSBsb3dWYWx1ZSArIDAuNzU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNJbnZlcnRlZCAmJiBoaWdoVmFsdWUgPj0gbmV3SGlnaFZhbHVlKSB7XG4gICAgICAgICAgICBuZXdIaWdoVmFsdWUgPSBoaWdoVmFsdWUgKyAwLjc1O1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0Fib3ZlQW5kQmVsb3cpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0b3BzID0gc2l6ZVZpc1Zhci5zdG9wcztcbiAgICAgICAgICAgIC8qIHN0b3BzWzBdLnNpemUgPSBuZXdIaWdoVmFsdWU7XG4gICAgICAgICAgICBzdG9wc1sxXS5zaXplID0gTWF0aC5yb3VuZCgobmV3SGlnaFZhbHVlICsgbmV3TG93VmFsdWUpIC8gMik7XG4gICAgICAgICAgICBzdG9wc1syXS5zaXplID0gbmV3TG93VmFsdWU7XG4gICAgICAgICAgICBzdG9wc1szXS5zaXplID0gTWF0aC5yb3VuZCgobmV3SGlnaFZhbHVlICsgbmV3TG93VmFsdWUpIC8gMik7XG4gICAgICAgICAgICBzdG9wc1s0XS5zaXplID0gbmV3SGlnaFZhbHVlOyAqL1xuICAgICAgICAgICAgY29uc3QgbWluU2l6ZSA9ICFpc0ludmVydGVkID8gdmFsdWVzWzBdIDogdmFsdWVzWzFdO1xuICAgICAgICAgICAgY29uc3QgbWF4U2l6ZSA9ICFpc0ludmVydGVkID8gdmFsdWVzWzFdIDogdmFsdWVzWzBdO1xuICAgICAgICAgICAgY29uc3QgbWF4VmFsdWUgPSBNYXRoLm1heCguLi5zdG9wcy5tYXAoKHN0b3ApID0+IHN0b3AudmFsdWUpKTtcbiAgICAgICAgICAgIGNvbnN0IG1pZFZhbHVlID0gc3RvcHNbMl0udmFsdWU7IC8vIGFzc3VtZXMgNSBzdG9wc1xuICAgICAgICAgICAgY29uc3QgbWluVmFsdWUgPSBNYXRoLm1pbiguLi5zdG9wcy5tYXAoKHN0b3ApID0+IHN0b3AudmFsdWUpKTtcbiAgICAgICAgICAgIGNvbnN0IHVwcGVyUmFuZ2UgPSBNYXRoLmFicyhtYXhWYWx1ZSAtIG1pZFZhbHVlKTtcbiAgICAgICAgICAgIGNvbnN0IGxvd2VyUmFuZ2UgPSBNYXRoLmFicyhtaW5WYWx1ZSAtIG1pZFZhbHVlKTtcbiAgICAgICAgICAgIGNvbnN0IG1heFJhbmdlID0gdXBwZXJSYW5nZSA+IGxvd2VyUmFuZ2UgPyB1cHBlclJhbmdlIDogbG93ZXJSYW5nZTtcbiAgICAgICAgICAgIGNvbnN0IHNpemVSYW5nZSA9IG1heFNpemUgLSBtaW5TaXplO1xuICAgICAgICAgICAgc3RvcHMuZm9yRWFjaCgoc3RvcCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgdmFsdWUgfSA9IHN0b3A7XG4gICAgICAgICAgICAgICAgc3RvcC5zaXplID0gKE1hdGguYWJzKHZhbHVlIC0gbWlkVmFsdWUpIC8gbWF4UmFuZ2UpICogc2l6ZVJhbmdlICsgbWluU2l6ZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzTnVsbCkge1xuICAgICAgICAgICAgLy8gbmVlZCB0byByZW1vdmUgc3RvcHNcbiAgICAgICAgICAgIGNvbnN0IHN0b3BzID0gc2l6ZVZpc1Zhci5zdG9wcztcbiAgICAgICAgICAgIHNpemVWaXNWYXIuc3RvcHMgPSBudWxsO1xuICAgICAgICAgICAgc2l6ZVZpc1Zhci5taW5TaXplID0gbmV3TG93VmFsdWU7XG4gICAgICAgICAgICBzaXplVmlzVmFyLm1heFNpemUgPSBuZXdIaWdoVmFsdWU7XG4gICAgICAgICAgICBzaXplVmlzVmFyLm1pbkRhdGFWYWx1ZSA9IHN0b3BzWzBdLnZhbHVlO1xuICAgICAgICAgICAgc2l6ZVZpc1Zhci5tYXhEYXRhVmFsdWUgPSBzdG9wc1tzdG9wcy5sZW5ndGggLSAxXS52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc051bWJlcikge1xuICAgICAgICAgICAgLy8gZml4ZWRcbiAgICAgICAgICAgIGlmICghaXNJbnZlcnRlZCkge1xuICAgICAgICAgICAgICAgIHNpemVWaXNWYXIubWluU2l6ZSA9IG5ld0xvd1ZhbHVlO1xuICAgICAgICAgICAgICAgIHNpemVWaXNWYXIubWF4U2l6ZSA9IG5ld0hpZ2hWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHNpemVWaXNWYXIubWF4U2l6ZSA9IG5ld0xvd1ZhbHVlO1xuICAgICAgICAgICAgICAgIHNpemVWaXNWYXIubWluU2l6ZSA9IG5ld0hpZ2hWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGF1dG9tYXRpY1xuICAgICAgICAgICAgY29uc3QgbWFwU2NhbGUgPSBtYXBWaWV3LnNjYWxlO1xuICAgICAgICAgICAgbGV0IG1pblN0b3BzID0gbW9kdWxlcy5lc3JpTGFuZy5jbG9uZShzaXplVmlzVmFyLm1pblNpemUuc3RvcHMpO1xuICAgICAgICAgICAgbGV0IG1heFN0b3BzID0gbW9kdWxlcy5lc3JpTGFuZy5jbG9uZShzaXplVmlzVmFyLm1heFNpemUuc3RvcHMpO1xuICAgICAgICAgICAgaWYgKGlzSW52ZXJ0ZWQpIHtcbiAgICAgICAgICAgICAgICBbbWluU3RvcHMsIG1heFN0b3BzXSA9IFttYXhTdG9wcywgbWluU3RvcHNdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IG1pbkZhY3RvciA9IG5ld0xvd1ZhbHVlIC8gbWluU3RvcHNbbWluU3RvcHMubGVuZ3RoIC0gMV0uc2l6ZTtcbiAgICAgICAgICAgIGxldCBtYXhGYWN0b3IgPSBuZXdIaWdoVmFsdWUgLyBtYXhTdG9wc1ttYXhTdG9wcy5sZW5ndGggLSAxXS5zaXplO1xuICAgICAgICAgICAgLy8gZmluZCBmYWN0b3JcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWluU3RvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtaW5TdG9wID0gbWluU3RvcHNbaV07XG4gICAgICAgICAgICAgICAgY29uc3QgbWF4U3RvcCA9IG1heFN0b3BzW2ldO1xuICAgICAgICAgICAgICAgIGlmIChtYXBTY2FsZSA8PSBtaW5TdG9wLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW50ZXJwb2xhdGUgdG8gZ2V0IGNvcnJlY3Qgc2l6ZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBsYXN0TWluU3RvcCA9IG1pblN0b3BzW2kgLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBsYXN0TWF4U3RvcCA9IG1heFN0b3BzW2kgLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGZhY3RvciA9IChtYXBTY2FsZSAtIGxhc3RNaW5TdG9wLnZhbHVlKSAvIChtaW5TdG9wLnZhbHVlIC0gbGFzdE1pblN0b3AudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgW21pbiwgbWF4XSA9IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0TWluU3RvcC5zaXplICsgKG1pblN0b3Auc2l6ZSAtIGxhc3RNaW5TdG9wLnNpemUpICogZmFjdG9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RNYXhTdG9wLnNpemUgKyAobWF4U3RvcC5zaXplIC0gbGFzdE1heFN0b3Auc2l6ZSkgKiBmYWN0b3JcbiAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgICAgICBtaW5GYWN0b3IgPSBuZXdMb3dWYWx1ZSAvIG1pbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heEZhY3RvciA9IG5ld0hpZ2hWYWx1ZSAvIG1heDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRvbid0IGludGVycG9sYXRlOyB1c2UgbG93ZXN0IHNpemVzXG4gICAgICAgICAgICAgICAgICAgICAgICBtaW5GYWN0b3IgPSBuZXdMb3dWYWx1ZSAvIG1pblN0b3BzWzBdLnNpemU7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXhGYWN0b3IgPSBuZXdIaWdoVmFsdWUgLyBtYXhTdG9wc1swXS5zaXplO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGFwcGx5IHRvIGFsbCBzY2FsZSByYW5nZXNcbiAgICAgICAgICAgIG1pblN0b3BzLmZvckVhY2goKG1pblN0b3ApID0+IChtaW5TdG9wLnNpemUgPSBNYXRoLnJvdW5kKG1pbkZhY3RvciAqIG1pblN0b3Auc2l6ZSAqIDEwKSAvIDEwKSk7XG4gICAgICAgICAgICBtYXhTdG9wcy5mb3JFYWNoKChtYXhTdG9wKSA9PiAobWF4U3RvcC5zaXplID0gTWF0aC5yb3VuZChtYXhGYWN0b3IgKiBtYXhTdG9wLnNpemUgKiAxMCkgLyAxMCkpO1xuICAgICAgICAgICAgaWYgKGlzSW52ZXJ0ZWQpIHtcbiAgICAgICAgICAgICAgICBbbWluU3RvcHMsIG1heFN0b3BzXSA9IFttYXhTdG9wcywgbWluU3RvcHNdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2l6ZVZpc1Zhci5taW5TaXplLnN0b3BzID0gbWluU3RvcHM7XG4gICAgICAgICAgICBzaXplVmlzVmFyLm1heFNpemUuc3RvcHMgPSBtYXhTdG9wcztcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgbWluU3ltID0gcmVuZGVyZXIuY2xhc3NCcmVha0luZm9zWzBdLnN5bWJvbDtcbiAgICAgICAgY29uc3QgbWF4U3ltID0gcmVuZGVyZXIuY2xhc3NCcmVha0luZm9zW3JlbmRlcmVyLmNsYXNzQnJlYWtJbmZvcy5sZW5ndGggLSAxXS5zeW1ib2w7XG4gICAgICAgIGxldCBsb3dWYWx1ZSA9IGdldFN5bWJvbFNpemUobWluU3ltKTtcbiAgICAgICAgbGV0IGhpZ2hWYWx1ZSA9IGdldFN5bWJvbFNpemUobWF4U3ltKTtcbiAgICAgICAgbGV0IGlzSW52ZXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgaWYgKGxvd1ZhbHVlID4gaGlnaFZhbHVlKSB7XG4gICAgICAgICAgICBbbG93VmFsdWUsIGhpZ2hWYWx1ZV0gPSBbaGlnaFZhbHVlLCBsb3dWYWx1ZV07XG4gICAgICAgICAgICBpc0ludmVydGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobG93VmFsdWUgIT09IGhpZ2hWYWx1ZSAmJiBuZXdMb3dWYWx1ZSA+IGhpZ2hWYWx1ZSkge1xuICAgICAgICAgICAgbmV3TG93VmFsdWUgPSBoaWdoVmFsdWUgLSAwLjc1O1xuICAgICAgICB9XG4gICAgICAgIGxvd1ZhbHVlID0gbmV3TG93VmFsdWU7XG4gICAgICAgIGlmIChsb3dWYWx1ZSAhPT0gaGlnaFZhbHVlICYmIGxvd1ZhbHVlID4gbmV3SGlnaFZhbHVlKSB7XG4gICAgICAgICAgICBuZXdIaWdoVmFsdWUgPSBsb3dWYWx1ZSArIDAuNzU7XG4gICAgICAgIH1cbiAgICAgICAgaGlnaFZhbHVlID0gbmV3SGlnaFZhbHVlO1xuICAgICAgICBjb25zdCB1bml0ID0gcmVuZGVyZXIuY2xhc3NCcmVha0luZm9zLmxlbmd0aCA9PT0gMVxuICAgICAgICAgICAgPyAxXG4gICAgICAgICAgICA6IE1hdGgubWF4KGhpZ2hWYWx1ZSAtIGxvd1ZhbHVlLCAxMCkgLyAocmVuZGVyZXIuY2xhc3NCcmVha0luZm9zLmxlbmd0aCAtIDEpO1xuICAgICAgICByZW5kZXJlci5jbGFzc0JyZWFrSW5mb3MuZm9yRWFjaCgoY2xhc3NCcmVha0luZm8sIGlkeCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc3ltID0gY2xhc3NCcmVha0luZm8uc3ltYm9sO1xuICAgICAgICAgICAgaWYgKGlzSW52ZXJ0ZWQpIHtcbiAgICAgICAgICAgICAgICBhcHBseVN5bWJvbFNpemUoc3ltLCBoaWdoVmFsdWUgLSB1bml0ICogaWR4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGFwcGx5U3ltYm9sU2l6ZShzeW0sIGxvd1ZhbHVlICsgdW5pdCAqIGlkeCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldFNpemVCeVNjYWxlKHNpemVBdXRvVmlzVmFyLCBzY2FsZSkge1xuICAgIGNvbnN0IHNpemVTdG9wcyA9IHNpemVBdXRvVmlzVmFyLnN0b3BzO1xuICAgIGNvbnN0IHN0b3BzQ291bnQgPSBzaXplU3RvcHMubGVuZ3RoO1xuICAgIGNvbnN0IGZpbmFsSW5kZXggPSBzdG9wc0NvdW50IC0gMTtcbiAgICBjb25zdCBzY2FsZU1pbiA9IHNpemVTdG9wc1swXS52YWx1ZTtcbiAgICBjb25zdCBzY2FsZU1heCA9IHNpemVTdG9wc1tmaW5hbEluZGV4XS52YWx1ZTtcbiAgICBpZiAoc2NhbGUgPD0gc2NhbGVNaW4pIHtcbiAgICAgICAgcmV0dXJuIHNpemVTdG9wc1swXS5zaXplO1xuICAgIH1cbiAgICBpZiAoc2NhbGUgPj0gc2NhbGVNYXgpIHtcbiAgICAgICAgcmV0dXJuIHNpemVTdG9wc1tmaW5hbEluZGV4XS5zaXplO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8PSBmaW5hbEluZGV4OyBpKyspIHtcbiAgICAgICAgY29uc3QgY3VycmVudFN0b3AgPSBzaXplU3RvcHNbaV07XG4gICAgICAgIGNvbnN0IG5leHRTdG9wID0gc2l6ZVN0b3BzW2kgKyAxXTtcbiAgICAgICAgaWYgKHNjYWxlID49IGN1cnJlbnRTdG9wLnZhbHVlICYmIHNjYWxlIDwgbmV4dFN0b3AudmFsdWUpIHtcbiAgICAgICAgICAgIGNvbnN0IHNjYWxlUmFuZ2UgPSBuZXh0U3RvcC52YWx1ZSAtIGN1cnJlbnRTdG9wLnZhbHVlO1xuICAgICAgICAgICAgY29uc3Qgc2l6ZVJhbmdlID0gY3VycmVudFN0b3Auc2l6ZSAtIG5leHRTdG9wLnNpemU7XG4gICAgICAgICAgICBjb25zdCByZWxhdGl2ZVBvc2l0aW9uID0gKHNjYWxlIC0gY3VycmVudFN0b3AudmFsdWUpIC8gc2NhbGVSYW5nZTtcbiAgICAgICAgICAgIGNvbnN0IGVmZmVjdGl2ZVNpemUgPSBjdXJyZW50U3RvcC5zaXplIC0gc2l6ZVJhbmdlICogcmVsYXRpdmVQb3NpdGlvbjtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLnJvdW5kKGVmZmVjdGl2ZVNpemUgKiAxMDApIC8gMTAwO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiAxOyAvLyB3ZSByZWFsbHkgZG9uJ3QgY29tZSBoZXJlXG59XG5cbmxldCBsYXN0U3R5bGVyU291cmNlSWQ7XG5jb25zdCBkZWZhdWx0R2VvbWV0cnkgPSBcInBvbHlnb25cIjtcbmZ1bmN0aW9uIGdldEdyZXlDb2xvcnMoKSB7XG4gICAgY29uc3QgeyBtb2R1bGVzIH0gPSBzbWFydE1hcHBpbmdTdGF0ZTtcbiAgICByZXR1cm4gW1xuICAgICAgICBuZXcgbW9kdWxlcy5lc3JpQ29sb3IoWzI1NSwgMjU1LCAyNTVdKSxcbiAgICAgICAgbmV3IG1vZHVsZXMuZXNyaUNvbG9yKFsxNzgsIDE3OCwgMTc4XSksXG4gICAgICAgIG5ldyBtb2R1bGVzLmVzcmlDb2xvcihbMTI4LCAxMjgsIDEyOF0pLFxuICAgICAgICBuZXcgbW9kdWxlcy5lc3JpQ29sb3IoWzkyLCA5MiwgOTJdKSxcbiAgICAgICAgbmV3IG1vZHVsZXMuZXNyaUNvbG9yKFs3NywgNzcsIDc3XSksXG4gICAgICAgIG5ldyBtb2R1bGVzLmVzcmlDb2xvcihbNTEsIDUxLCA1MV0pLFxuICAgICAgICBuZXcgbW9kdWxlcy5lc3JpQ29sb3IoWzI2LCAyNiwgMjZdKVxuICAgIF07XG59XG5mdW5jdGlvbiBnZXRBbGxDb2xvcnMoKSB7XG4gICAgY29uc3QgeyBtb2R1bGVzIH0gPSBzbWFydE1hcHBpbmdTdGF0ZTtcbiAgICByZXR1cm4gW1xuICAgICAgICBuZXcgbW9kdWxlcy5lc3JpQ29sb3IoXCIjZmY0MDQwXCIpLFxuICAgICAgICBuZXcgbW9kdWxlcy5lc3JpQ29sb3IoXCIjZmY4MjAwXCIpLFxuICAgICAgICBuZXcgbW9kdWxlcy5lc3JpQ29sb3IoXCIjZmFhODNmXCIpLFxuICAgICAgICBuZXcgbW9kdWxlcy5lc3JpQ29sb3IoXCIjZmZkMTU5XCIpLFxuICAgICAgICBuZXcgbW9kdWxlcy5lc3JpQ29sb3IoXCIjNzRiNTY2XCIpLFxuICAgICAgICBuZXcgbW9kdWxlcy5lc3JpQ29sb3IoXCIjMDA4OTc3XCIpLFxuICAgICAgICBuZXcgbW9kdWxlcy5lc3JpQ29sb3IoXCIjMzNlM2M4XCIpLFxuICAgICAgICBuZXcgbW9kdWxlcy5lc3JpQ29sb3IoXCIjNDNhYmViXCIpLFxuICAgICAgICBuZXcgbW9kdWxlcy5lc3JpQ29sb3IoXCIjNGM2NGM5XCIpLFxuICAgICAgICBuZXcgbW9kdWxlcy5lc3JpQ29sb3IoXCIjOTg2OGVkXCIpLFxuICAgICAgICBuZXcgbW9kdWxlcy5lc3JpQ29sb3IoXCIjYjE1NWU2XCIpLFxuICAgICAgICBuZXcgbW9kdWxlcy5lc3JpQ29sb3IoXCIjZGI1MTgxXCIpLFxuICAgICAgICBuZXcgbW9kdWxlcy5lc3JpQ29sb3IoXCIjZTAzYjk5XCIpLFxuICAgICAgICBuZXcgbW9kdWxlcy5lc3JpQ29sb3IoXCIjMmIyYjJiXCIpLFxuICAgICAgICBuZXcgbW9kdWxlcy5lc3JpQ29sb3IoXCIjYmRiZGJkXCIpLFxuICAgICAgICBuZXcgbW9kdWxlcy5lc3JpQ29sb3IoXCIjZmZmZmZmXCIpXG4gICAgXTtcbn1cbmZ1bmN0aW9uIGdldEFsbENvbG9yc1JldmVyc2VkKCkge1xuICAgIGNvbnN0IGFsbENvbG9ycyA9IGdldEFsbENvbG9ycygpO1xuICAgIHJldHVybiBhbGxDb2xvcnMucmV2ZXJzZSgpO1xufVxuZnVuY3Rpb24gY3JlYXRlU3ltYm9sU3R5bGVyUG9wb3Zlcihwcm9wcykge1xuICAgIGNvbnN0IHsgcmVmZXJlbmNlRWxlbWVudCwgaGVhZGluZyB9ID0gcHJvcHM7XG4gICAgY29uc3QgcG9wb3ZlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJhcmNnaXMtc21hcnQtbWFwcGluZy1zdHlsZXItcG9wb3ZlclwiKTtcbiAgICBwb3BvdmVyLnJlZmVyZW5jZUVsZW1lbnQgPSByZWZlcmVuY2VFbGVtZW50O1xuICAgIHBvcG92ZXIuaGVhZGluZyA9IGhlYWRpbmc7XG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChwb3BvdmVyKTtcbiAgICBwb3BvdmVyLm9wZW4gPSB0cnVlO1xuICAgIHBvcG92ZXIucmVwb3NpdGlvbigpO1xuICAgIHJldHVybiBwb3BvdmVyO1xufVxuZnVuY3Rpb24gcmVtb3ZlU3ltYm9sU3R5bGVyUG9wb3Zlcihwb3BvdmVyKSB7XG4gICAgdmFyIF9hO1xuICAgIGlmIChwb3BvdmVyID09PSBudWxsIHx8IHBvcG92ZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBvcG92ZXIucGFyZW50Tm9kZSkge1xuICAgICAgICBwb3BvdmVyLm9wZW4gPSBmYWxzZTtcbiAgICAgICAgKF9hID0gcG9wb3Zlci5wYXJlbnROb2RlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVtb3ZlQ2hpbGQocG9wb3Zlcik7XG4gICAgfVxufVxuYXN5bmMgZnVuY3Rpb24gY3JlYXRlU3ltYm9sU3R5bGVyRWxlbWVudChwb3BvdmVyTm9kZSkge1xuICAgIGNvbnN0IHN5bWJvbFN0eWxlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJhcmNnaXMtc3ltYm9sLXN0eWxlclwiKTtcbiAgICBzeW1ib2xTdHlsZXIuaW5pdGlhbFNvdXJjZUlkID0gbGFzdFN0eWxlclNvdXJjZUlkO1xuICAgIHN5bWJvbFN0eWxlci5zdHlsZSA9IFwibWF4LWhlaWdodDogbWF4KGNhbGMoMTAwdmggLSAyMDBweCksIDMwMHB4KVwiOyAvLyBub3QgdGhlIGJlc3QsIGJ1dCBlYXNpZXN0XG4gICAgc3ltYm9sU3R5bGVyLnBvcG92ZXJQcm9wcyA9IHtcbiAgICAgICAgcGxhY2VtZW50OiBcImJvdHRvbS1lbmRcIixcbiAgICAgICAgb2Zmc2V0RGlzdGFuY2U6IDEwLFxuICAgICAgICBvZmZzZXRTa2lkZGluZzogc21hcnRNYXBwaW5nU3RhdGUuaXNSVEwgPyAzIDogLTMsXG4gICAgICAgIHBvaW50ZXJEaXNhYmxlZDogXCJ0cnVlXCIsXG4gICAgICAgIHBvcG92ZXJXaWR0aDogMzE1LFxuICAgICAgICAvL292ZXJsYXlQb3NpdGlvbmluZzogXCJmaXhlZFwiLCAtLSBidWdneSwgb2Zmc2V0IGlzc3VlXG4gICAgICAgIHJlZkVsZW1lbnQ6IGF3YWl0IHBvcG92ZXJOb2RlLmdldFBvcG92ZXJSZWZFbGVtZW50KClcbiAgICB9O1xuICAgIHN5bWJvbFN0eWxlci5hZGRFdmVudExpc3RlbmVyKFwiYXJjZ2lzU3ltYm9sU3R5bGVyU291cmNlSWRDaGFuZ2VcIiwgKHsgZGV0YWlsOiBhY3RpdmVTb3VyY2VJZCB9KSA9PiAobGFzdFN0eWxlclNvdXJjZUlkID0gYWN0aXZlU291cmNlSWQpKTtcbiAgICByZXR1cm4gc3ltYm9sU3R5bGVyO1xufVxuZnVuY3Rpb24gc3ltYm9sU3R5bGVyRWRpdChzeW1ib2xTdHlsZXIsIHN5bWJvbCwgcHJvcHMpIHtcbiAgICBpZiAoZG9jdW1lbnQuVVJMLmluZGV4T2YoXCJkZWJ1Zz10cnVlXCIpID4gLTEpIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJzeW1ib2xcIiwgSlNPTi5zdHJpbmdpZnkoc3ltYm9sLCBudWxsLCAyKSk7XG4gICAgICAgIGNvbnNvbGUubG9nKFwicHJvcHNcIiwgSlNPTi5zdHJpbmdpZnkoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBwcm9wcyksIHsgcG9ydGFsOiBcIi4uLlwiIH0pKSk7XG4gICAgfVxuICAgIHJldHVybiBzeW1ib2xTdHlsZXIuZWRpdChzeW1ib2wsIHByb3BzKTtcbn1cbmZ1bmN0aW9uIG9uU3R5bGVyRWRpdFdyYXBwZXIob25TdHlsZXJFZGl0LCBldmVudCkge1xuICAgIGNvbnN0IHsgc3ltYm9sLCBpbmZvOiB7IG1hcmtlciwgc3Ryb2tlLCBmaWxsIH0gfSA9IGV2ZW50LmRldGFpbDtcbiAgICBpZiAoZG9jdW1lbnQuVVJMLmluZGV4T2YoXCJkZWJ1Zz10cnVlXCIpID4gLTEpIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJvblN0eWxlckVkaXQgLSBzeW1ib2w6XCIsIEpTT04uc3RyaW5naWZ5KHN5bWJvbCA9PT0gbnVsbCB8fCBzeW1ib2wgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHN5bWJvbC50b0pTT04oKSwgbnVsbCwgMikpO1xuICAgICAgICBjb25zb2xlLmxvZyhcIm9uU3R5bGVyRWRpdCAtIGluZm8ubWFya2VyOlwiLCBKU09OLnN0cmluZ2lmeShtYXJrZXIpKTtcbiAgICAgICAgY29uc29sZS5sb2coXCJvblN0eWxlckVkaXQgLSBpbmZvLnN0cm9rZTpcIiwgSlNPTi5zdHJpbmdpZnkoc3Ryb2tlKSk7XG4gICAgICAgIGNvbnNvbGUubG9nKFwib25TdHlsZXJFZGl0IC0gaW5mby5maWxsOlwiLCBKU09OLnN0cmluZ2lmeShmaWxsKSk7XG4gICAgfVxuICAgIG9uU3R5bGVyRWRpdChldmVudCk7XG59XG5hc3luYyBmdW5jdGlvbiBidWlsZFN5bWJvbFN0eWxlckZvckJhY2tncm91bmQob3B0aW9ucykge1xuICAgIGNvbnN0IHsgbGF5ZXIsIG1hcEltYWdlU3VibGF5ZXIsIHBvcnRhbCwgbW9kdWxlcyB9ID0gc21hcnRNYXBwaW5nU3RhdGU7XG4gICAgY29uc3QgeyBvbkNoYW5nZSwgcG9wb3Zlck5vZGUgfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgcmVuZGVyZXIgPSBnZXRSZW5kZXJlcihsYXllcik7XG4gICAgY29uc3QgaXNQb2x5Z29uID0gaXNQb2x5Z29uVHlwZShsYXllcik7XG4gICAgY29uc3QgaXNDaGFydCA9IGdldFJlbmRlcmVyKGxheWVyKS50eXBlID09PSBcInBpZS1jaGFydFwiO1xuICAgIGNvbnN0IHNpemVWaXNWYXIgPSBnZXRWaXNWYXIocmVuZGVyZXIsIFwic2l6ZVwiKTtcbiAgICBjb25zdCBzaXplT3V0bGluZVZpc1ZhciA9IGdldFZpc1ZhcihyZW5kZXJlciwgXCJzaXplXCIsIFwib3V0bGluZVwiKTtcbiAgICBsZXQgc3ltYm9sID0gcmVuZGVyZXIuYmFja2dyb3VuZEZpbGxTeW1ib2w7XG4gICAgaWYgKCFzeW1ib2wpIHtcbiAgICAgICAgc3ltYm9sID0gbmV3IG1vZHVsZXMuU2ltcGxlRmlsbFN5bWJvbCgpO1xuICAgICAgICBzeW1ib2wuY29sb3IgPSBudWxsO1xuICAgICAgICBnZXRSZW5kZXJlcihsYXllcikuYmFja2dyb3VuZEZpbGxTeW1ib2wgPSBzeW1ib2w7XG4gICAgICAgIG9uQ2hhbmdlKCk7XG4gICAgfVxuICAgIGNvbnN0IGZpbGxFbmFibGVkID0gISFzeW1ib2wuY29sb3I7XG4gICAgY29uc3Qgc3Ryb2tlRW5hYmxlZCA9IGhhc1N5bWJvbE91dGxpbmUoc3ltYm9sKTtcbiAgICBjb25zdCBzdWdnZXN0ZWRGaWxsQ29sb3JzID0gZ2V0R3JleUNvbG9ycygpO1xuICAgIGNvbnN0IHN1Z2dlc3RlZFN0cm9rZUNvbG9ycyA9IGdldEdyZXlDb2xvcnMoKTtcbiAgICBjb25zdCBvblN0eWxlckVkaXQgPSAoeyBkZXRhaWw6IHsgc3ltYm9sLCBpbmZvOiB7IG1hcmtlciwgc3Ryb2tlIC8qICwgZmlsbCAqLyB9IH0gfSkgPT4ge1xuICAgICAgICBnZXRSZW5kZXJlcihsYXllcikuYmFja2dyb3VuZEZpbGxTeW1ib2wgPSBzeW1ib2w7XG4gICAgICAgIHVwZGF0ZUF1dG9WaXNWYXIoc3ltYm9sLCBtYXJrZXIgPT09IG51bGwgfHwgbWFya2VyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBtYXJrZXIuYXV0b0FkanVzdGVkLCBzdHJva2UgPT09IG51bGwgfHwgc3Ryb2tlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzdHJva2UuYXV0b0FkanVzdGVkLCBzeW1ib2xTdHlsZXIsIG9wdGlvbnMpO1xuICAgIH07XG4gICAgbGV0IHN0cm9rZTtcbiAgICBpZiAoc3ltYm9sLm91dGxpbmUpIHtcbiAgICAgICAgc3Ryb2tlID0ge1xuICAgICAgICAgICAgY29sb3I6IHN5bWJvbC5vdXRsaW5lLmNvbG9yID8gc3ltYm9sLm91dGxpbmUuY29sb3IgOiBuZXcgbW9kdWxlcy5lc3JpQ29sb3IoWzAsIDAsIDAsIDAuNV0pLFxuICAgICAgICAgICAgc2l6ZTogc3ltYm9sLm91dGxpbmUud2lkdGgsXG4gICAgICAgICAgICBzdHlsZTogc3ltYm9sLm91dGxpbmUuc3R5bGUsXG4gICAgICAgICAgICBhdXRvQWRqdXN0ZWQ6ICEhc2l6ZU91dGxpbmVWaXNWYXJcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHN0cm9rZSA9IHtcbiAgICAgICAgICAgIGNvbG9yOiBuZXcgbW9kdWxlcy5lc3JpQ29sb3IoWzAsIDAsIDAsIDAuNV0pLFxuICAgICAgICAgICAgc2l6ZTogMSxcbiAgICAgICAgICAgIHN0eWxlOiBcInNvbGlkXCIsXG4gICAgICAgICAgICBhdXRvQWRqdXN0ZWQ6ICEhc2l6ZU91dGxpbmVWaXNWYXJcbiAgICAgICAgfTtcbiAgICB9XG4gICAgaWYgKCFzeW1ib2wub3V0bGluZSkge1xuICAgICAgICBzeW1ib2wub3V0bGluZSA9IG5ldyBtb2R1bGVzLlNpbXBsZUxpbmVTeW1ib2woKTtcbiAgICAgICAgYXBwbHlTeW1ib2xDb2xvcihzeW1ib2wsIG5ldyBtb2R1bGVzLmVzcmlDb2xvcihbMCwgMCwgMCwgMF0pKTtcbiAgICB9XG4gICAgY29uc3Qgc3ltYm9sU3R5bGVyID0gYXdhaXQgY3JlYXRlU3ltYm9sU3R5bGVyRWxlbWVudChwb3BvdmVyTm9kZSk7XG4gICAgY29uc3QgZWRpdCA9IHN5bWJvbFN0eWxlckVkaXQoc3ltYm9sU3R5bGVyLCBtb2R1bGVzLmVzcmlMYW5nLmNsb25lKHN5bWJvbCksIHtcbiAgICAgICAgcG9ydGFsLFxuICAgICAgICBzeW1ib2xGaWx0ZXI6IFwic2ltcGxlXCIsXG4gICAgICAgIHNlY3Rpb25zOiB7XG4gICAgICAgICAgICBmaWxsOiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJjb2xvclwiLFxuICAgICAgICAgICAgICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgICAgICAgICAgICAgIG9wZW46IHRydWUsXG4gICAgICAgICAgICAgICAgc3VnZ2VzdGVkQ29sb3JzT3BlbjogdHJ1ZSxcbiAgICAgICAgICAgICAgICB0cmFuc3BhcmVuY3lPcGVuOiB0cnVlLFxuICAgICAgICAgICAgICAgIHN1Z2dlc3RlZENvbG9yczogc3VnZ2VzdGVkRmlsbENvbG9yc1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHN0cm9rZToge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiY29sb3JcIixcbiAgICAgICAgICAgICAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICAgICAgICAgICAgICBzdWdnZXN0ZWRDb2xvcnM6IHN1Z2dlc3RlZFN0cm9rZUNvbG9ycyxcbiAgICAgICAgICAgICAgICBleHRyYVBhcnRzOiB7XG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBhdXRvU3Ryb2tlQWRqdXN0OiBtYXBJbWFnZVN1YmxheWVyIHx8IChpc1BvbHlnb24gJiYgaXNDaGFydCAmJiAhc2l6ZVZpc1ZhcikgPyBmYWxzZSA6IFwiZWRpdGFibGVcIlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZmlsbDoge1xuICAgICAgICAgICAgY29sb3I6IHN5bWJvbC5jb2xvciA/IHN5bWJvbC5jb2xvciA6IG5ldyBtb2R1bGVzLmVzcmlDb2xvcihbMCwgMCwgMCwgMC41XSlcbiAgICAgICAgfSxcbiAgICAgICAgc3Ryb2tlLFxuICAgICAgICBmaWxsRW5hYmxlZCxcbiAgICAgICAgc3Ryb2tlRW5hYmxlZFxuICAgIH0pO1xuICAgIHN5bWJvbFN0eWxlci5hZGRFdmVudExpc3RlbmVyKFwiYXJjZ2lzU3ltYm9sU3R5bGVyRWRpdFwiLCBvblN0eWxlckVkaXRXcmFwcGVyLmJpbmQobnVsbCwgb25TdHlsZXJFZGl0KSk7XG4gICAgcG9wb3Zlck5vZGUuYWRkU3R5bGVyKHN5bWJvbFN0eWxlcik7XG4gICAgYXdhaXQgZWRpdDtcbiAgICByZXR1cm4gY3JlYXRlV2F0Y2hTY2FsZUhhbmRsZShzeW1ib2wsIHN5bWJvbFN0eWxlcik7XG59XG5hc3luYyBmdW5jdGlvbiBidWlsZFN5bWJvbFN0eWxlckZvckRvdERlbnNpdHlCYWNrZ3JvdW5kKG9wdGlvbnMpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgeyBsYXllciwgbWFwSW1hZ2VTdWJsYXllciwgcG9ydGFsLCBtb2R1bGVzIH0gPSBzbWFydE1hcHBpbmdTdGF0ZTtcbiAgICBjb25zdCB7IC8qIG9uQ2hhbmdlLCAqLyBwb3BvdmVyTm9kZSB9ID0gb3B0aW9ucztcbiAgICBjb25zdCByZW5kZXJlciA9IGdldFJlbmRlcmVyKGxheWVyKTtcbiAgICBjb25zdCBzaXplT3V0bGluZVZpc1ZhciA9IGdldFZpc1ZhcihyZW5kZXJlciwgXCJzaXplXCIsIFwib3V0bGluZVwiKTtcbiAgICBjb25zdCBmaWxsRW5hYmxlZCA9ICEhcmVuZGVyZXIuYmFja2dyb3VuZENvbG9yO1xuICAgIGNvbnN0IHN0cm9rZUVuYWJsZWQgPSAhISgoX2EgPSByZW5kZXJlci5vdXRsaW5lKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY29sb3IpO1xuICAgIGNvbnN0IHN1Z2dlc3RlZEZpbGxDb2xvcnMgPSBnZXRHcmV5Q29sb3JzKCk7XG4gICAgY29uc3Qgc3VnZ2VzdGVkU3Ryb2tlQ29sb3JzID0gZ2V0R3JleUNvbG9ycygpO1xuICAgIGNvbnN0IG9uU3R5bGVyRWRpdCA9ICh7IGRldGFpbDogeyBzeW1ib2wsIGluZm86IHsgbWFya2VyLCBzdHJva2UgLyogLCBmaWxsICovIH0gfSB9KSA9PiB7XG4gICAgICAgIGdldFJlbmRlcmVyKGxheWVyKS5iYWNrZ3JvdW5kQ29sb3IgPSBnZXRTeW1ib2xDb2xvcihzeW1ib2wpO1xuICAgICAgICBnZXRSZW5kZXJlcihsYXllcikub3V0bGluZSA9IHN5bWJvbC5vdXRsaW5lO1xuICAgICAgICB1cGRhdGVBdXRvVmlzVmFyKHN5bWJvbCwgbWFya2VyID09PSBudWxsIHx8IG1hcmtlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogbWFya2VyLmF1dG9BZGp1c3RlZCwgc3Ryb2tlID09PSBudWxsIHx8IHN0cm9rZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogc3Ryb2tlLmF1dG9BZGp1c3RlZCwgc3ltYm9sU3R5bGVyLCBvcHRpb25zKTtcbiAgICAgICAgLy9vbkNoYW5nZSgpO1xuICAgIH07XG4gICAgbGV0IHN0cm9rZTtcbiAgICBpZiAocmVuZGVyZXIub3V0bGluZSkge1xuICAgICAgICBzdHJva2UgPSB7XG4gICAgICAgICAgICBjb2xvcjogcmVuZGVyZXIub3V0bGluZS5jb2xvciA/IHJlbmRlcmVyLm91dGxpbmUuY29sb3IgOiBuZXcgbW9kdWxlcy5lc3JpQ29sb3IoWzAsIDAsIDAsIDAuNV0pLFxuICAgICAgICAgICAgc2l6ZTogcmVuZGVyZXIub3V0bGluZS53aWR0aCxcbiAgICAgICAgICAgIHN0eWxlOiByZW5kZXJlci5vdXRsaW5lLnN0eWxlLFxuICAgICAgICAgICAgYXV0b0FkanVzdGVkOiAhIXNpemVPdXRsaW5lVmlzVmFyXG4gICAgICAgIH07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBzdHJva2UgPSB7XG4gICAgICAgICAgICBjb2xvcjogbmV3IG1vZHVsZXMuZXNyaUNvbG9yKFswLCAwLCAwLCAwLjVdKSxcbiAgICAgICAgICAgIHNpemU6IDEsXG4gICAgICAgICAgICBzdHlsZTogXCJzb2xpZFwiLFxuICAgICAgICAgICAgYXV0b0FkanVzdGVkOiAhIXNpemVPdXRsaW5lVmlzVmFyXG4gICAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IHN5bWJvbCA9IG5ldyBtb2R1bGVzLlNpbXBsZUZpbGxTeW1ib2woKTtcbiAgICBzeW1ib2wuY29sb3IgPSBnZXRSZW5kZXJlcihsYXllcikuYmFja2dyb3VuZENvbG9yO1xuICAgIHN5bWJvbC5vdXRsaW5lID0gZ2V0UmVuZGVyZXIobGF5ZXIpLm91dGxpbmU7XG4gICAgLy8gVE9ETyBubyBDSU1zXG4gICAgY29uc3Qgc3ltYm9sU3R5bGVyID0gYXdhaXQgY3JlYXRlU3ltYm9sU3R5bGVyRWxlbWVudChwb3BvdmVyTm9kZSk7XG4gICAgY29uc3QgZWRpdCA9IHN5bWJvbFN0eWxlckVkaXQoc3ltYm9sU3R5bGVyLCBtb2R1bGVzLmVzcmlMYW5nLmNsb25lKHN5bWJvbCksIHtcbiAgICAgICAgcG9ydGFsLFxuICAgICAgICBzeW1ib2xGaWx0ZXI6IFwic2ltcGxlXCIsXG4gICAgICAgIHNlY3Rpb25zOiB7XG4gICAgICAgICAgICBmaWxsOiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJjb2xvclwiLFxuICAgICAgICAgICAgICAgIG9wZW46IHRydWUsXG4gICAgICAgICAgICAgICAgb3B0aW9uYWw6IHRydWUsXG4gICAgICAgICAgICAgICAgc3VnZ2VzdGVkQ29sb3JzT3BlbjogdHJ1ZSxcbiAgICAgICAgICAgICAgICB0cmFuc3BhcmVuY3lPcGVuOiB0cnVlLFxuICAgICAgICAgICAgICAgIHN1Z2dlc3RlZENvbG9yczogc3VnZ2VzdGVkRmlsbENvbG9yc1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHN0cm9rZToge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiY29sb3JcIixcbiAgICAgICAgICAgICAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICAgICAgICAgICAgICBzdWdnZXN0ZWRDb2xvcnM6IHN1Z2dlc3RlZFN0cm9rZUNvbG9ycyxcbiAgICAgICAgICAgICAgICBleHRyYVBhcnRzOiB7XG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBhdXRvU3Ryb2tlQWRqdXN0OiBtYXBJbWFnZVN1YmxheWVyID8gZmFsc2UgOiBcImVkaXRhYmxlXCJcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGZpbGw6IHtcbiAgICAgICAgICAgIGNvbG9yOiByZW5kZXJlci5iYWNrZ3JvdW5kQ29sb3IgPyByZW5kZXJlci5iYWNrZ3JvdW5kQ29sb3IgOiBuZXcgbW9kdWxlcy5lc3JpQ29sb3IoWzAsIDAsIDAsIDAuNV0pXG4gICAgICAgIH0sXG4gICAgICAgIHN0cm9rZSxcbiAgICAgICAgZmlsbEVuYWJsZWQsXG4gICAgICAgIHN0cm9rZUVuYWJsZWRcbiAgICB9KTtcbiAgICBzeW1ib2xTdHlsZXIuYWRkRXZlbnRMaXN0ZW5lcihcImFyY2dpc1N5bWJvbFN0eWxlckVkaXRcIiwgb25TdHlsZXJFZGl0V3JhcHBlci5iaW5kKG51bGwsIG9uU3R5bGVyRWRpdCkpO1xuICAgIHBvcG92ZXJOb2RlLmFkZFN0eWxlcihzeW1ib2xTdHlsZXIpO1xuICAgIGF3YWl0IGVkaXQ7XG4gICAgY29uc3Qgc3ltID0gbmV3IG1vZHVsZXMuU2ltcGxlRmlsbFN5bWJvbCgpO1xuICAgIHN5bS5jb2xvciA9IHJlbmRlcmVyLmJhY2tncm91bmRDb2xvcjtcbiAgICBzeW0ub3V0bGluZSA9IHJlbmRlcmVyLm91dGxpbmU7XG4gICAgcmV0dXJuIGNyZWF0ZVdhdGNoU2NhbGVIYW5kbGUoc3ltLCBzeW1ib2xTdHlsZXIpO1xufVxuYXN5bmMgZnVuY3Rpb24gYnVpbGRTeW1ib2xTdHlsZXJGb3JEZWZhdWx0KG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IG9uQ2hhbmdlLCBwb3BvdmVyTm9kZSB9ID0gb3B0aW9ucztcbiAgICBjb25zdCB7IGxheWVyLCBtYXBWaWV3LCBwb3J0YWwsIG1vZHVsZXMgfSA9IHNtYXJ0TWFwcGluZ1N0YXRlO1xuICAgIGNvbnN0IGlzUG9pbnQgPSBpc1BvaW50VHlwZShsYXllcik7XG4gICAgY29uc3QgaXNMaW5lID0gaXNQb2x5bGluZVR5cGUobGF5ZXIpO1xuICAgIGNvbnN0IGlzUG9seWdvbiA9IGlzUG9seWdvblR5cGUobGF5ZXIpO1xuICAgIGNvbnN0IHJlbmRlcmVyID0gZ2V0UmVuZGVyZXIobGF5ZXIpO1xuICAgIGNvbnN0IHJlbmRlcmVyVHlwZSA9IGdldFJlbmRlcmVyVHlwZSgpO1xuICAgIGNvbnN0IHNpemVBdXRvVmlzVmFyID0gZ2V0VmlzVmFyKHJlbmRlcmVyLCBcInNpemVcIiwgXCJhdXRvXCIpO1xuICAgIGNvbnN0IHNpemVPdXRsaW5lVmlzVmFyID0gZ2V0VmlzVmFyKHJlbmRlcmVyLCBcInNpemVcIiwgXCJvdXRsaW5lXCIpO1xuICAgIGxldCBkZWZhdWx0U3ltYm9sID0gcmVuZGVyZXIuZGVmYXVsdFN5bWJvbDtcbiAgICBpZiAoIWlzU3VwcG9ydGVkU3ltYm9sKGRlZmF1bHRTeW1ib2wpKSB7XG4gICAgICAgIGRlZmF1bHRTeW1ib2wgPSBnZXREZWZhdWx0U3ltYm9sKGxheWVyLCBtYXBWaWV3LCByZW5kZXJlclR5cGUpO1xuICAgIH1cbiAgICBjb25zdCBmaWxsRW5hYmxlZCA9IGRlZmF1bHRTeW1ib2wudHlwZSA9PT0gXCJwaWN0dXJlLW1hcmtlclwiID8gZmFsc2UgOiAhIWRlZmF1bHRTeW1ib2wuY29sb3I7XG4gICAgY29uc3Qgc3Ryb2tlRW5hYmxlZCA9IGhhc1N5bWJvbE91dGxpbmUoZGVmYXVsdFN5bWJvbCk7XG4gICAgY29uc3QgaXNQb2ludENJTSA9IGRlZmF1bHRTeW1ib2wudHlwZSA9PT0gXCJjaW1cIiAmJiBkZWZhdWx0U3ltYm9sLmRhdGEuc3ltYm9sLnR5cGUgPT09IFwiQ0lNUG9pbnRTeW1ib2xcIjtcbiAgICBjb25zdCBzdWdnZXN0ZWRGaWxsQ29sb3JzID0gZ2V0R3JleUNvbG9ycygpO1xuICAgIGNvbnN0IHN1Z2dlc3RlZFN0cm9rZUNvbG9ycyA9IGdldEdyZXlDb2xvcnMoKTtcbiAgICBjb25zdCBvblN0eWxlckVkaXQgPSAoeyBkZXRhaWw6IHsgc3ltYm9sIC8qICxcbiAgICBpbmZvOiB7IG1hcmtlciwgc3Ryb2tlLCBmaWxsIH0gKi8gfSB9KSA9PiB7XG4gICAgICAgIGNvbnN0IHJlbmRlcmVyID0gZ2V0UmVuZGVyZXIobGF5ZXIpO1xuICAgICAgICByZW5kZXJlci5kZWZhdWx0U3ltYm9sID0gc3ltYm9sO1xuICAgICAgICBvbkNoYW5nZSgpO1xuICAgIH07XG4gICAgbGV0IHN0cm9rZTtcbiAgICBpZiAoIWRlZmF1bHRTeW1ib2wpIHtcbiAgICAgICAgaWYgKGlzUG9seWdvbikge1xuICAgICAgICAgICAgZGVmYXVsdFN5bWJvbCA9IG5ldyBtb2R1bGVzLlNpbXBsZUZpbGxTeW1ib2woKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc0xpbmUpIHtcbiAgICAgICAgICAgIGRlZmF1bHRTeW1ib2wgPSBuZXcgbW9kdWxlcy5TaW1wbGVMaW5lU3ltYm9sKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkZWZhdWx0U3ltYm9sID0gbmV3IG1vZHVsZXMuU2ltcGxlTWFya2VyU3ltYm9sKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGRlZmF1bHRTeW1ib2wudHlwZSA9PT0gXCJzaW1wbGUtZmlsbFwiKSB7XG4gICAgICAgIGNvbnN0IHN5bWJvbCA9IGRlZmF1bHRTeW1ib2w7XG4gICAgICAgIGlmIChzeW1ib2wub3V0bGluZSkge1xuICAgICAgICAgICAgY29uc3Qgc3ltID0gc3ltYm9sLm91dGxpbmU7XG4gICAgICAgICAgICBzdHJva2UgPSB7XG4gICAgICAgICAgICAgICAgY29sb3I6IHN5bS5jb2xvciA/IHN5bS5jb2xvciA6IG5ldyBtb2R1bGVzLmVzcmlDb2xvcihbMCwgMCwgMCwgMC41XSksXG4gICAgICAgICAgICAgICAgc2l6ZTogc3ltLndpZHRoLFxuICAgICAgICAgICAgICAgIHN0eWxlOiBzeW0uc3R5bGUsXG4gICAgICAgICAgICAgICAgYXV0b0FkanVzdGVkOiAhIXNpemVPdXRsaW5lVmlzVmFyXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3Ryb2tlID0ge1xuICAgICAgICAgICAgICAgIGNvbG9yOiBuZXcgbW9kdWxlcy5lc3JpQ29sb3IoWzAsIDAsIDAsIDAuNV0pLFxuICAgICAgICAgICAgICAgIHNpemU6IDEsXG4gICAgICAgICAgICAgICAgc3R5bGU6IFwic29saWRcIixcbiAgICAgICAgICAgICAgICBhdXRvQWRqdXN0ZWQ6ICEhc2l6ZU91dGxpbmVWaXNWYXJcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoZGVmYXVsdFN5bWJvbC50eXBlID09PSBcInNpbXBsZS1saW5lXCIpIHtcbiAgICAgICAgY29uc3Qgc3ltID0gZGVmYXVsdFN5bWJvbDtcbiAgICAgICAgc3Ryb2tlID0ge1xuICAgICAgICAgICAgY29sb3I6IHN5bS5jb2xvciA/IHN5bS5jb2xvciA6IG5ldyBtb2R1bGVzLmVzcmlDb2xvcihbMCwgMCwgMCwgMC41XSksXG4gICAgICAgICAgICBzaXplOiBzeW0ud2lkdGgsXG4gICAgICAgICAgICBzdHlsZTogc3ltLnN0eWxlLFxuICAgICAgICAgICAgbWFya2VyOiBzeW0ubWFya2VyXG4gICAgICAgIH07XG4gICAgfVxuICAgIGVsc2UgaWYgKGRlZmF1bHRTeW1ib2wudHlwZSA9PT0gXCJzaW1wbGUtbWFya2VyXCIgJiYgZGVmYXVsdFN5bWJvbC5vdXRsaW5lKSB7XG4gICAgICAgIGNvbnN0IHN5bSA9IGRlZmF1bHRTeW1ib2wub3V0bGluZTtcbiAgICAgICAgc3Ryb2tlID0ge1xuICAgICAgICAgICAgY29sb3I6IHN5bS5jb2xvciA/IHN5bS5jb2xvciA6IG5ldyBtb2R1bGVzLmVzcmlDb2xvcihbMCwgMCwgMCwgMC41XSksXG4gICAgICAgICAgICBzaXplOiBzeW0ud2lkdGgsXG4gICAgICAgICAgICBzdHlsZTogc3ltLnN0eWxlXG4gICAgICAgIH07XG4gICAgfVxuICAgIGVsc2UgaWYgKGRlZmF1bHRTeW1ib2wudHlwZSA9PT0gXCJjaW1cIikge1xuICAgICAgICBzdHJva2UgPSBnZXRDaW1MaW5lUHJvcHMoZGVmYXVsdFN5bWJvbCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBwaWN0dXJlLW1hcmtlclxuICAgICAgICBzdHJva2UgPSB7XG4gICAgICAgICAgICBjb2xvcjogbmV3IG1vZHVsZXMuZXNyaUNvbG9yKFsyNTUsIDI1NSwgMjU1LCAwLjVdKSxcbiAgICAgICAgICAgIHNpemU6IDFcbiAgICAgICAgfTtcbiAgICB9XG4gICAgY29uc3Qgc3ltYm9sU3R5bGVyID0gYXdhaXQgY3JlYXRlU3ltYm9sU3R5bGVyRWxlbWVudChwb3BvdmVyTm9kZSk7XG4gICAgbGV0IGVkaXQ7XG4gICAgaWYgKGlzTGluZSkge1xuICAgICAgICBlZGl0ID0gc3ltYm9sU3R5bGVyRWRpdChzeW1ib2xTdHlsZXIsIG1vZHVsZXMuZXNyaUxhbmcuY2xvbmUoZGVmYXVsdFN5bWJvbCksIHtcbiAgICAgICAgICAgIHBvcnRhbCxcbiAgICAgICAgICAgIHN5bWJvbEZpbHRlcjogIWxheWVyU3VwcG9ydHNDSU0oKSA/IFwic2ltcGxlXCIgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBzZWN0aW9uczoge1xuICAgICAgICAgICAgICAgIHN0cm9rZToge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImNvbG9yXCIsXG4gICAgICAgICAgICAgICAgICAgIG9wZW46IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHN1Z2dlc3RlZENvbG9yc09wZW46IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHN1Z2dlc3RlZENvbG9yczogc3VnZ2VzdGVkU3Ryb2tlQ29sb3JzLFxuICAgICAgICAgICAgICAgICAgICBleHRyYVBhcnRzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogIXNpemVBdXRvVmlzVmFyLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXV0b1N0cm9rZUFkanVzdDogZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzdHJva2VcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBlZGl0ID0gc3ltYm9sU3R5bGVyRWRpdChzeW1ib2xTdHlsZXIsIG1vZHVsZXMuZXNyaUxhbmcuY2xvbmUoZGVmYXVsdFN5bWJvbCksIHtcbiAgICAgICAgICAgIHBvcnRhbCxcbiAgICAgICAgICAgIHN5bWJvbEZpbHRlcjogaXNQb2x5Z29uICYmICFsYXllclN1cHBvcnRzQ0lNKCkgPyBcInNpbXBsZVwiIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgc2VjdGlvbnM6IHtcbiAgICAgICAgICAgICAgICBtYXJrZXI6IGlzUG9pbnRDSU0gfHwgW1wic2ltcGxlLW1hcmtlclwiLCBcInBpY3R1cmUtbWFya2VyXCJdLmluZGV4T2YoZGVmYXVsdFN5bWJvbC50eXBlKSA+IC0xXG4gICAgICAgICAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3BlbjogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnRzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2l6ZTogIXNpemVBdXRvVmlzVmFyXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgc3ltYm9sc09wZW46IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBzaXplT3BlbjogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hcmtlclR5cGU6IGxheWVyU3VwcG9ydHNDSU0oKSA/IFwiYWxsXCIgOiBbXCJzaW1wbGVcIiwgXCJwaWN0dXJlXCJdXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgZmlsbDoge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImNvbG9yXCIsXG4gICAgICAgICAgICAgICAgICAgIG9wZW46IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBzdWdnZXN0ZWRDb2xvcnNPcGVuOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBzdWdnZXN0ZWRDb2xvcnM6IHN1Z2dlc3RlZEZpbGxDb2xvcnNcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHN0cm9rZToge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImNvbG9yXCIsXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBzdWdnZXN0ZWRDb2xvcnM6IHN1Z2dlc3RlZFN0cm9rZUNvbG9ycyxcbiAgICAgICAgICAgICAgICAgICAgZXh0cmFQYXJ0czoge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU6IFtcInNpbXBsZS1tYXJrZXJcIiwgXCJwaWN0dXJlLW1hcmtlclwiLCBcImNpbVwiXS5pbmRleE9mKGRlZmF1bHRTeW1ib2wudHlwZSkgPT09IC0xLFxuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBhdXRvU3Ryb2tlQWRqdXN0OiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZpbGw6IHtcbiAgICAgICAgICAgICAgICBjb2xvcjogZ2V0U3ltYm9sQ29sb3IoZGVmYXVsdFN5bWJvbCkgfHwgbmV3IG1vZHVsZXMuZXNyaUNvbG9yKFsxMjgsIDEyOCwgMTI4XSlcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBtYXJrZXI6IGlzUG9pbnRcbiAgICAgICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICAgICAgc2l6ZTogZ2V0U3ltYm9sU2l6ZShkZWZhdWx0U3ltYm9sKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHN0cm9rZSxcbiAgICAgICAgICAgIGZpbGxFbmFibGVkLFxuICAgICAgICAgICAgc3Ryb2tlRW5hYmxlZFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgc3ltYm9sU3R5bGVyLmFkZEV2ZW50TGlzdGVuZXIoXCJhcmNnaXNTeW1ib2xTdHlsZXJFZGl0XCIsIG9uU3R5bGVyRWRpdFdyYXBwZXIuYmluZChudWxsLCBvblN0eWxlckVkaXQpKTtcbiAgICBwb3BvdmVyTm9kZS5hZGRTdHlsZXIoc3ltYm9sU3R5bGVyKTtcbiAgICBhd2FpdCBlZGl0O1xufVxuYXN5bmMgZnVuY3Rpb24gYnVpbGRTeW1ib2xTdHlsZXJGb3JDbGFzc2VkKG9wdGlvbnMpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIGNvbnN0IHsgbGF5ZXIsIG1hcEltYWdlU3VibGF5ZXIsIG1hcFZpZXcsIGNsYXNzZWRTeW1ib2xTZWxlY3RlZElkeCwgcG9ydGFsLCBtb2R1bGVzIH0gPSBzbWFydE1hcHBpbmdTdGF0ZTtcbiAgICBjb25zdCB7IG9uQ2hhbmdlLCBwb3BvdmVyTm9kZSB9ID0gb3B0aW9ucztcbiAgICBjb25zdCBpc1BvaW50ID0gaXNQb2ludFR5cGUobGF5ZXIpO1xuICAgIGNvbnN0IGlzTGluZSA9IGlzUG9seWxpbmVUeXBlKGxheWVyKTtcbiAgICBjb25zdCBpc1BvbHlnb24gPSBpc1BvbHlnb25UeXBlKGxheWVyKTtcbiAgICBjb25zdCByZW5kZXJlciA9IGdldFJlbmRlcmVyKGxheWVyKTtcbiAgICBjb25zdCByZW5kZXJlclR5cGUgPSBnZXRSZW5kZXJlclR5cGUoKTtcbiAgICBjb25zdCBzaXplQXV0b1Zpc1ZhciA9IGdldFZpc1ZhcihyZW5kZXJlciwgXCJzaXplXCIsIFwiYXV0b1wiKTtcbiAgICBjb25zdCBzaXplT3V0bGluZVZpc1ZhciA9IGdldFZpc1ZhcihyZW5kZXJlciwgXCJzaXplXCIsIFwib3V0bGluZVwiKTtcbiAgICAvLyBpdCB0YWtlcyB0aGUgZmlyc3Qgc3ltYm9sIGFzIGEgcmVmZXJlbmNlXG4gICAgbGV0IHN5bWJvbCA9ICgoX2EgPSByZW5kZXJlci5jbGFzc0JyZWFrSW5mb3MpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5sZW5ndGgpXG4gICAgICAgID8gbW9kdWxlcy5lc3JpTGFuZy5jbG9uZShyZW5kZXJlci5jbGFzc0JyZWFrSW5mb3NbY2xhc3NlZFN5bWJvbFNlbGVjdGVkSWR4XS5zeW1ib2wpXG4gICAgICAgIDogZ2V0RGVmYXVsdFN5bWJvbChsYXllciwgbWFwVmlldywgcmVuZGVyZXJUeXBlKTtcbiAgICBpZiAoIWlzU3VwcG9ydGVkU3ltYm9sKHN5bWJvbCkpIHtcbiAgICAgICAgc3ltYm9sID0gZ2V0RGVmYXVsdFN5bWJvbChsYXllciwgbWFwVmlldywgcmVuZGVyZXJUeXBlKTtcbiAgICB9XG4gICAgLy8gZW5zdXJlIGluaXRpYWwgc2l6ZSBpcyBjb3JyZWN0IG9uIHRoZSBzeW1ib2wgc3R5bGVyXG4gICAgaWYgKHNpemVBdXRvVmlzVmFyKSB7XG4gICAgICAgIGFwcGx5U3ltYm9sU2l6ZShzeW1ib2wsIGdldFNpemVCeVNjYWxlKHNpemVBdXRvVmlzVmFyLCBtYXBWaWV3LnNjYWxlKSk7XG4gICAgfVxuICAgIGNvbnN0IGZpbGxFbmFibGVkID0gc3ltYm9sLnR5cGUgPT09IFwicGljdHVyZS1tYXJrZXJcIiA/IGZhbHNlIDogISFzeW1ib2wuY29sb3I7XG4gICAgY29uc3Qgc3Ryb2tlRW5hYmxlZCA9IGhhc1N5bWJvbE91dGxpbmUoc3ltYm9sKTtcbiAgICBjb25zdCBpc1BvaW50Q0lNID0gc3ltYm9sLnR5cGUgPT09IFwiY2ltXCIgJiYgc3ltYm9sLmRhdGEuc3ltYm9sLnR5cGUgPT09IFwiQ0lNUG9pbnRTeW1ib2xcIjtcbiAgICBjb25zdCBzdWdnZXN0ZWRGaWxsQ29sb3JzID0gZ2V0QWxsQ29sb3JzKCk7XG4gICAgY29uc3Qgc3VnZ2VzdGVkU3Ryb2tlQ29sb3JzID0gZ2V0QWxsQ29sb3JzUmV2ZXJzZWQoKTtcbiAgICBjb25zdCBvblN0eWxlckVkaXQgPSAoeyBkZXRhaWw6IHsgc3ltYm9sLCBpbmZvOiB7IG1hcmtlciwgc3Ryb2tlIC8qICwgZmlsbCAqLyB9IH0gfSkgPT4ge1xuICAgICAgICBjb25zdCByZW5kZXJlciA9IGdldFJlbmRlcmVyKGxheWVyKTtcbiAgICAgICAgY29uc3QgaW5mb3MgPSByZW5kZXJlci5jbGFzc0JyZWFrSW5mb3Muc2xpY2UoKTtcbiAgICAgICAgY29uc3QgaW5mbyA9IGluZm9zW2NsYXNzZWRTeW1ib2xTZWxlY3RlZElkeF07XG4gICAgICAgIGNvbnN0IHNpemUgPSBnZXRTeW1ib2xTaXplKGluZm8uc3ltYm9sKTtcbiAgICAgICAgaW5mby5zeW1ib2wgPSBzeW1ib2w7XG4gICAgICAgIHJlbmRlcmVyLmNsYXNzQnJlYWtJbmZvcyA9IGluZm9zO1xuICAgICAgICBpZiAocmVuZGVyZXJUeXBlID09PSBcInNpemVcIikge1xuICAgICAgICAgICAgYXBwbHlTeW1ib2xTaXplKGluZm8uc3ltYm9sLCBzaXplKTtcbiAgICAgICAgICAgIG9uQ2hhbmdlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB1cGRhdGVBdXRvVmlzVmFyKHN5bWJvbCwgbWFya2VyID09PSBudWxsIHx8IG1hcmtlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogbWFya2VyLmF1dG9BZGp1c3RlZCwgc3Ryb2tlID09PSBudWxsIHx8IHN0cm9rZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogc3Ryb2tlLmF1dG9BZGp1c3RlZCwgc3ltYm9sU3R5bGVyLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgbGV0IHN0cm9rZTtcbiAgICBpZiAoc3ltYm9sLnR5cGUgPT09IFwic2ltcGxlLWZpbGxcIikge1xuICAgICAgICBjb25zdCBzeW0gPSBzeW1ib2w7XG4gICAgICAgIGlmIChzeW0ub3V0bGluZSkge1xuICAgICAgICAgICAgc3Ryb2tlID0ge1xuICAgICAgICAgICAgICAgIGNvbG9yOiBzeW0ub3V0bGluZS5jb2xvciA/IHN5bS5vdXRsaW5lLmNvbG9yIDogbmV3IG1vZHVsZXMuZXNyaUNvbG9yKFswLCAwLCAwLCAwLjVdKSxcbiAgICAgICAgICAgICAgICBzaXplOiBzeW0ub3V0bGluZS53aWR0aCxcbiAgICAgICAgICAgICAgICBzdHlsZTogc3ltLm91dGxpbmUuc3R5bGUsXG4gICAgICAgICAgICAgICAgYXV0b0FkanVzdGVkOiAhIXNpemVPdXRsaW5lVmlzVmFyXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3Ryb2tlID0ge1xuICAgICAgICAgICAgICAgIGNvbG9yOiBuZXcgbW9kdWxlcy5lc3JpQ29sb3IoWzAsIDAsIDAsIDAuNV0pLFxuICAgICAgICAgICAgICAgIHNpemU6IDEsXG4gICAgICAgICAgICAgICAgc3R5bGU6IFwic29saWRcIixcbiAgICAgICAgICAgICAgICBhdXRvQWRqdXN0ZWQ6ICEhc2l6ZU91dGxpbmVWaXNWYXJcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoc3ltYm9sLnR5cGUgPT09IFwic2ltcGxlLW1hcmtlclwiKSB7XG4gICAgICAgIGNvbnN0IHN5bSA9IHN5bWJvbDtcbiAgICAgICAgaWYgKHN5bS5vdXRsaW5lKSB7XG4gICAgICAgICAgICBzdHJva2UgPSB7XG4gICAgICAgICAgICAgICAgY29sb3I6IHN5bS5vdXRsaW5lLmNvbG9yID8gc3ltLm91dGxpbmUuY29sb3IgOiBuZXcgbW9kdWxlcy5lc3JpQ29sb3IoWzAsIDAsIDAsIDAuNV0pLFxuICAgICAgICAgICAgICAgIHNpemU6IHN5bS5vdXRsaW5lLndpZHRoXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3Ryb2tlID0ge1xuICAgICAgICAgICAgICAgIGNvbG9yOiBuZXcgbW9kdWxlcy5lc3JpQ29sb3IoWzAsIDAsIDAsIDAuNV0pLFxuICAgICAgICAgICAgICAgIHNpemU6IDFcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoc3ltYm9sLnR5cGUgPT09IFwiY2ltXCIpIHtcbiAgICAgICAgc3Ryb2tlID0gZ2V0Q2ltTGluZVByb3BzKHN5bWJvbCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHN5bWJvbC50eXBlID09PSBcInNpbXBsZS1saW5lXCIpIHtcbiAgICAgICAgY29uc3Qgc3ltID0gc3ltYm9sO1xuICAgICAgICBzdHJva2UgPSB7XG4gICAgICAgICAgICBzaXplOiBzeW0ud2lkdGgsXG4gICAgICAgICAgICBzdHlsZTogc3ltLnN0eWxlLFxuICAgICAgICAgICAgbWFya2VyOiBzeW0ubWFya2VyLFxuICAgICAgICAgICAgY29sb3I6IHN5bS5jb2xvciA/IHN5bS5jb2xvciA6IG5ldyBtb2R1bGVzLmVzcmlDb2xvcihbMCwgMCwgMCwgMC41XSlcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHN0cm9rZSA9IHtcbiAgICAgICAgICAgIGNvbG9yOiBuZXcgbW9kdWxlcy5lc3JpQ29sb3IoWzI1NSwgMjU1LCAyNTUsIDAuNV0pLFxuICAgICAgICAgICAgc2l6ZTogMVxuICAgICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBzeW1ib2xTdHlsZXIgPSBhd2FpdCBjcmVhdGVTeW1ib2xTdHlsZXJFbGVtZW50KHBvcG92ZXJOb2RlKTtcbiAgICBsZXQgZWRpdDtcbiAgICBpZiAoaXNMaW5lKSB7XG4gICAgICAgIGVkaXQgPSBzeW1ib2xTdHlsZXJFZGl0KHN5bWJvbFN0eWxlciwgbW9kdWxlcy5lc3JpTGFuZy5jbG9uZShzeW1ib2wpLCB7XG4gICAgICAgICAgICBwb3J0YWwsXG4gICAgICAgICAgICBzeW1ib2xGaWx0ZXI6ICFsYXllclN1cHBvcnRzQ0lNKCkgPyBcInNpbXBsZVwiIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgc2VjdGlvbnM6IHtcbiAgICAgICAgICAgICAgICBzdHJva2U6IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJjb2xvclwiLFxuICAgICAgICAgICAgICAgICAgICBvcGVuOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBzdWdnZXN0ZWRDb2xvcnNPcGVuOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBzdWdnZXN0ZWRDb2xvcnM6IHN1Z2dlc3RlZEZpbGxDb2xvcnMsXG4gICAgICAgICAgICAgICAgICAgIGV4dHJhUGFydHM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiBzeW1ib2wudHlwZSAhPT0gXCJjaW1cIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGFycm93OiBzeW1ib2wudHlwZSAhPT0gXCJjaW1cIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiByZW5kZXJlclR5cGUgIT09IFwic2l6ZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXV0b1N0cm9rZUFkanVzdDogIW1hcEltYWdlU3VibGF5ZXIgJiYgcmVuZGVyZXJUeXBlICE9PSBcInNpemVcIiA/IFwiZWRpdGFibGVcIiA6IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHBhcnRzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBleHRyYTogKHJlbmRlcmVyVHlwZSAhPT0gXCJzaXplXCIgJiYgIXNpemVBdXRvVmlzVmFyKSB8fCBzeW1ib2wudHlwZSAhPT0gXCJjaW1cIlxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHN0cm9rZVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGVkaXQgPSBzeW1ib2xTdHlsZXJFZGl0KHN5bWJvbFN0eWxlciwgbW9kdWxlcy5lc3JpTGFuZy5jbG9uZShzeW1ib2wpLCB7XG4gICAgICAgICAgICBwb3J0YWwsXG4gICAgICAgICAgICBzeW1ib2xGaWx0ZXI6IGlzUG9seWdvbiAmJiAhbGF5ZXJTdXBwb3J0c0NJTSgpID8gXCJzaW1wbGVcIiA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHNlY3Rpb25zOiB7XG4gICAgICAgICAgICAgICAgbWFya2VyOiBpc1BvaW50Q0lNIHx8IFtcInNpbXBsZS1tYXJrZXJcIiwgXCJwaWN0dXJlLW1hcmtlclwiXS5pbmRleE9mKHN5bWJvbC50eXBlKSA+IC0xXG4gICAgICAgICAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3BlbjogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnRzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2l6ZTogcmVuZGVyZXJUeXBlICE9PSBcInNpemVcIiA/IChtYXBJbWFnZVN1YmxheWVyID8gdHJ1ZSA6IHsgYXV0b1NpemVBZGp1c3Q6IFwiZWRpdGFibGVcIiB9KSA6IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgc3ltYm9sc09wZW46IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBzaXplT3BlbjogcmVuZGVyZXJUeXBlICE9PSBcInNpemVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hcmtlclR5cGU6IGxheWVyU3VwcG9ydHNDSU0oKSA/IFwiYWxsXCIgOiBbXCJzaW1wbGVcIiwgXCJwaWN0dXJlXCJdXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgZmlsbDoge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImNvbG9yXCIsXG4gICAgICAgICAgICAgICAgICAgIG9wZW46IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBzdWdnZXN0ZWRDb2xvcnNPcGVuOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICB0cmFuc3BhcmVuY3lPcGVuOiBpc1BpY3R1cmVNYXJrZXIoc3ltYm9sKSxcbiAgICAgICAgICAgICAgICAgICAgc3VnZ2VzdGVkQ29sb3JzOiBzdWdnZXN0ZWRGaWxsQ29sb3JzXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzdHJva2U6IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJjb2xvclwiLFxuICAgICAgICAgICAgICAgICAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgc3VnZ2VzdGVkQ29sb3JzOiBzdWdnZXN0ZWRTdHJva2VDb2xvcnMsXG4gICAgICAgICAgICAgICAgICAgIGV4dHJhUGFydHM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiBbXCJzaW1wbGUtbWFya2VyXCIsIFwicGljdHVyZS1tYXJrZXJcIiwgXCJjaW1cIl0uaW5kZXhPZihzeW1ib2wudHlwZSkgPT09IC0xLFxuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBhdXRvU3Ryb2tlQWRqdXN0OiAhbWFwSW1hZ2VTdWJsYXllciAmJiBpc1BvbHlnb24gJiYgc3ltYm9sLnR5cGUgIT09IFwiY2ltXCIgJiYgcmVuZGVyZXJUeXBlICE9PSBcInNpemVcIiA/IFwiZWRpdGFibGVcIiA6IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZmlsbDoge1xuICAgICAgICAgICAgICAgIGNvbG9yOiBnZXRTeW1ib2xDb2xvcihzeW1ib2wpIHx8IGFkanVzdEFscGhhKHN1Z2dlc3RlZEZpbGxDb2xvcnNbMV0sIDAuODUpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbWFya2VyOiBpc1BvaW50XG4gICAgICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgICAgIHNpemU6IGdldFN5bWJvbFNpemUoc3ltYm9sKSxcbiAgICAgICAgICAgICAgICAgICAgYXV0b0FkanVzdGVkOiAhIXNpemVBdXRvVmlzVmFyXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgc3Ryb2tlLFxuICAgICAgICAgICAgZmlsbEVuYWJsZWQsXG4gICAgICAgICAgICBzdHJva2VFbmFibGVkXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzeW1ib2xTdHlsZXIuYWRkRXZlbnRMaXN0ZW5lcihcImFyY2dpc1N5bWJvbFN0eWxlckVkaXRcIiwgb25TdHlsZXJFZGl0V3JhcHBlci5iaW5kKG51bGwsIG9uU3R5bGVyRWRpdCkpO1xuICAgIHBvcG92ZXJOb2RlLmFkZFN0eWxlcihzeW1ib2xTdHlsZXIpO1xuICAgIGF3YWl0IGVkaXQ7XG4gICAgaWYgKHJlbmRlcmVyVHlwZSAhPT0gXCJzaXplXCIpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVdhdGNoU2NhbGVIYW5kbGUoKChfYiA9IHJlbmRlcmVyLmNsYXNzQnJlYWtJbmZvcykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmxlbmd0aCkgPyByZW5kZXJlci5jbGFzc0JyZWFrSW5mb3NbMF0uc3ltYm9sIDogdW5kZWZpbmVkLCBzeW1ib2xTdHlsZXIpO1xuICAgIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIGJ1aWxkU3ltYm9sU3R5bGVyRm9yQ29sb3JTaXplQWJvdmUob3B0aW9ucykge1xuICAgIGF3YWl0IGJ1aWxkU3ltYm9sU3R5bGVyRm9yQ29sb3JTaXplKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucyksIHsgdHlwZTogXCJhYm92ZVwiIH0pKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGJ1aWxkU3ltYm9sU3R5bGVyRm9yQ29sb3JTaXplQmVsb3cob3B0aW9ucykge1xuICAgIGF3YWl0IGJ1aWxkU3ltYm9sU3R5bGVyRm9yQ29sb3JTaXplKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucyksIHsgdHlwZTogXCJiZWxvd1wiIH0pKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGJ1aWxkU3ltYm9sU3R5bGVyRm9yQ29sb3JTaXplKG9wdGlvbnMpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIGNvbnN0IHsgbGF5ZXIsIG1hcFZpZXcsIHBvcnRhbCwgbW9kdWxlcyB9ID0gc21hcnRNYXBwaW5nU3RhdGU7XG4gICAgY29uc3QgeyBvbkNoYW5nZSwgcG9wb3Zlck5vZGUgfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgcmVuZGVyZXIgPSBnZXRSZW5kZXJlcihsYXllcik7XG4gICAgY29uc3QgY29sb3JWaXNWYXIgPSBnZXRWaXNWYXIocmVuZGVyZXIsIFwiY29sb3JcIik7XG4gICAgY29uc3QgaXNBYm92ZSA9IG9wdGlvbnMudHlwZSA9PT0gXCJhYm92ZVwiO1xuICAgIGxldCBzeW1ib2wgPSAoKF9iID0gKF9hID0gcmVuZGVyZXIuY2xhc3NCcmVha0luZm9zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FbaXNBYm92ZSA/IDEgOiAwXSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnN5bWJvbCkgfHwgZ2V0RGVmYXVsdFN5bWJvbChsYXllciwgbWFwVmlldywgXCJjb2xvci1zaXplXCIpO1xuICAgIGlmICghaXNTdXBwb3J0ZWRTeW1ib2woc3ltYm9sKSkge1xuICAgICAgICBzeW1ib2wgPSBnZXREZWZhdWx0U3ltYm9sKGxheWVyLCBtYXBWaWV3LCBcImNvbG9yLXNpemVcIik7XG4gICAgfVxuICAgIGNvbnN0IGZpbGxFbmFibGVkID0gc3ltYm9sLnR5cGUgPT09IFwicGljdHVyZS1tYXJrZXJcIiA/IGZhbHNlIDogISFzeW1ib2wuY29sb3I7XG4gICAgY29uc3Qgc3Ryb2tlRW5hYmxlZCA9IGhhc1N5bWJvbE91dGxpbmUoc3ltYm9sKTtcbiAgICAvLyBUT0RPIGdldCBjdXJyZW50IHNjaGVtZVxuICAgIGNvbnN0IHN1Z2dlc3RlZEZpbGxDb2xvcnMgPSBnZXRBbGxDb2xvcnMoKTtcbiAgICBjb25zdCBzdWdnZXN0ZWRTdHJva2VDb2xvcnMgPSBzeW1ib2wudHlwZSA9PT0gXCJzaW1wbGUtbGluZVwiID8gZ2V0QWxsQ29sb3JzKCkgOiBnZXRBbGxDb2xvcnNSZXZlcnNlZCgpO1xuICAgIGNvbnN0IG9uU3R5bGVyRWRpdCA9ICh7IGRldGFpbDogeyBzeW1ib2wgLyogLFxuICAgIGluZm86IHsgbWFya2VyLCBzdHJva2UsIGZpbGwgfSAqLyB9IH0pID0+IHtcbiAgICAgICAgY29uc3QgcmVuZGVyZXIgPSBnZXRSZW5kZXJlcihsYXllcik7XG4gICAgICAgIHJlbmRlcmVyLmF1dGhvcmluZ0luZm8udW5pdmFyaWF0ZVN5bWJvbFN0eWxlID0gXCJjdXN0b21cIjtcbiAgICAgICAgY29uc3QgaW5mb3MgPSByZW5kZXJlci5jbGFzc0JyZWFrSW5mb3Muc2xpY2UoKTtcbiAgICAgICAgY29uc3QgaW5mbyA9IGluZm9zW2lzQWJvdmUgPyAxIDogMF07XG4gICAgICAgIGluZm8uc3ltYm9sID0gc3ltYm9sO1xuICAgICAgICByZW5kZXJlci5jbGFzc0JyZWFrSW5mb3MgPSBpbmZvcztcbiAgICAgICAgb25DaGFuZ2UoKTtcbiAgICB9O1xuICAgIGxldCBzdHJva2U7XG4gICAgaWYgKHN5bWJvbC50eXBlID09PSBcInNpbXBsZS1tYXJrZXJcIikge1xuICAgICAgICBjb25zdCBzeW0gPSBzeW1ib2w7XG4gICAgICAgIGlmIChzeW0ub3V0bGluZSkge1xuICAgICAgICAgICAgc3Ryb2tlID0ge1xuICAgICAgICAgICAgICAgIGNvbG9yOiBzeW0ub3V0bGluZS5jb2xvciA/IHN5bS5vdXRsaW5lLmNvbG9yIDogbmV3IG1vZHVsZXMuZXNyaUNvbG9yKFswLCAwLCAwLCAwLjVdKSxcbiAgICAgICAgICAgICAgICBzaXplOiBzeW0ub3V0bGluZS53aWR0aFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN0cm9rZSA9IHtcbiAgICAgICAgICAgICAgICBjb2xvcjogbmV3IG1vZHVsZXMuZXNyaUNvbG9yKFswLCAwLCAwLCAwLjVdKSxcbiAgICAgICAgICAgICAgICBzaXplOiAxXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKHN5bWJvbC50eXBlID09PSBcInNpbXBsZS1saW5lXCIpIHtcbiAgICAgICAgY29uc3Qgc3ltID0gc3ltYm9sO1xuICAgICAgICBzdHJva2UgPSB7XG4gICAgICAgICAgICBjb2xvcjogc3ltLmNvbG9yLFxuICAgICAgICAgICAgc2l6ZTogc3ltLndpZHRoLFxuICAgICAgICAgICAgc3R5bGU6IHN5bS5zdHlsZSxcbiAgICAgICAgICAgIG1hcmtlcjogc3ltLm1hcmtlclxuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHNlIGlmIChzeW1ib2wudHlwZSA9PT0gXCJjaW1cIikge1xuICAgICAgICBzdHJva2UgPSBnZXRDaW1MaW5lUHJvcHMoc3ltYm9sKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHN0cm9rZSA9IHtcbiAgICAgICAgICAgIGNvbG9yOiBuZXcgbW9kdWxlcy5lc3JpQ29sb3IoWzI1NSwgMjU1LCAyNTUsIDAuNV0pLFxuICAgICAgICAgICAgc2l6ZTogMVxuICAgICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBzeW1ib2xTdHlsZXIgPSBhd2FpdCBjcmVhdGVTeW1ib2xTdHlsZXJFbGVtZW50KHBvcG92ZXJOb2RlKTtcbiAgICBjb25zdCBlZGl0ID0gc3ltYm9sU3R5bGVyRWRpdChzeW1ib2xTdHlsZXIsIG1vZHVsZXMuZXNyaUxhbmcuY2xvbmUoc3ltYm9sKSwge1xuICAgICAgICBwb3J0YWwsXG4gICAgICAgIHNlY3Rpb25zOiB7XG4gICAgICAgICAgICBtYXJrZXI6IGNvbG9yVmlzVmFyICYmIFtcInNpbXBsZS1tYXJrZXJcIiwgXCJjaW1cIl0uaW5kZXhPZihzeW1ib2wudHlwZSkgPiAtMVxuICAgICAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgICAgICBvcGVuOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBwYXJ0czoge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2l6ZTogZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgc3ltYm9sc09wZW46IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHNpemVPcGVuOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgbWFya2VyVHlwZTogbGF5ZXJTdXBwb3J0c0NJTSgpID8gW1wic2ltcGxlXCIsIFwiY2ltOnZlY3RvclwiXSA6IFtcInNpbXBsZVwiXVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICA6ICFjb2xvclZpc1ZhciAmJiBbXCJzaW1wbGUtbWFya2VyXCIsIFwicGljdHVyZS1tYXJrZXJcIiwgXCJjaW1cIl0uaW5kZXhPZihzeW1ib2wudHlwZSkgPiAtMVxuICAgICAgICAgICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wZW46IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJ0czoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpemU6IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgc3ltYm9sc09wZW46IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBzaXplT3BlbjogZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGZpbGw6ICFjb2xvclZpc1ZhclxuICAgICAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImNvbG9yXCIsXG4gICAgICAgICAgICAgICAgICAgIG9wZW46IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBzdWdnZXN0ZWRDb2xvcnNPcGVuOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICB0cmFuc3BhcmVuY3lPcGVuOiBpc1BpY3R1cmVNYXJrZXIoc3ltYm9sKSxcbiAgICAgICAgICAgICAgICAgICAgc3VnZ2VzdGVkQ29sb3JzOiBzdWdnZXN0ZWRGaWxsQ29sb3JzXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgc3Ryb2tlOiAhY29sb3JWaXNWYXJcbiAgICAgICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJjb2xvclwiLFxuICAgICAgICAgICAgICAgICAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgc3VnZ2VzdGVkQ29sb3JzOiBzdWdnZXN0ZWRTdHJva2VDb2xvcnMsXG4gICAgICAgICAgICAgICAgICAgIGV4dHJhUGFydHM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiBbXCJzaW1wbGUtbWFya2VyXCIsIFwicGljdHVyZS1tYXJrZXJcIiwgXCJjaW1cIl0uaW5kZXhPZihzeW1ib2wudHlwZSkgPT09IC0xLFxuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBhdXRvU3Ryb2tlQWRqdXN0OiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkXG4gICAgICAgIH0sXG4gICAgICAgIGZpbGw6ICFjb2xvclZpc1ZhclxuICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgY29sb3I6IGdldFN5bWJvbENvbG9yKHN5bWJvbCkgfHwgYWRqdXN0QWxwaGEoc3VnZ2VzdGVkRmlsbENvbG9yc1sxXSwgMC44NSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICBtYXJrZXI6IHtcbiAgICAgICAgICAgIHNpemU6IGdldFN5bWJvbFNpemUoc3ltYm9sKVxuICAgICAgICB9LFxuICAgICAgICBzdHJva2UsXG4gICAgICAgIGZpbGxFbmFibGVkLFxuICAgICAgICBzdHJva2VFbmFibGVkXG4gICAgfSk7XG4gICAgc3ltYm9sU3R5bGVyLmFkZEV2ZW50TGlzdGVuZXIoXCJhcmNnaXNTeW1ib2xTdHlsZXJFZGl0XCIsIG9uU3R5bGVyRWRpdFdyYXBwZXIuYmluZChudWxsLCBvblN0eWxlckVkaXQpKTtcbiAgICBwb3BvdmVyTm9kZS5hZGRTdHlsZXIoc3ltYm9sU3R5bGVyKTtcbiAgICBhd2FpdCBlZGl0O1xufVxuYXN5bmMgZnVuY3Rpb24gYnVpbGRTeW1ib2xTdHlsZXJGb3JTaW1wbGUob3B0aW9ucykge1xuICAgIGNvbnN0IHsgbGF5ZXIsIG1hcEltYWdlU3VibGF5ZXIsIG1hcFZpZXcsIHBvcnRhbCwgbW9kdWxlcyB9ID0gc21hcnRNYXBwaW5nU3RhdGU7XG4gICAgY29uc3QgeyAvKiBvbkNoYW5nZSwgKi8gcG9wb3Zlck5vZGUgfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgaXNPR0NMYXllciA9IGxheWVyLnR5cGUgPT09IFwib2djLWZlYXR1cmVcIjtcbiAgICBjb25zdCBpc1BvaW50ID0gaXNQb2ludFR5cGUobGF5ZXIpO1xuICAgIGNvbnN0IGlzTGluZSA9IGlzUG9seWxpbmVUeXBlKGxheWVyKTtcbiAgICBjb25zdCBpc1BvbHlnb24gPSBpc1BvbHlnb25UeXBlKGxheWVyKTtcbiAgICBjb25zdCByZW5kZXJlciA9IGdldFJlbmRlcmVyKGxheWVyKTtcbiAgICBjb25zdCBzaXplQXV0b1Zpc1ZhciA9IGdldFZpc1ZhcihyZW5kZXJlciwgXCJzaXplXCIsIFwiYXV0b1wiKTtcbiAgICBjb25zdCBzaXplT3V0bGluZVZpc1ZhciA9IGdldFZpc1ZhcihyZW5kZXJlciwgXCJzaXplXCIsIFwib3V0bGluZVwiKTtcbiAgICBsZXQgc3ltYm9sID0gcmVuZGVyZXIuc3ltYm9sO1xuICAgIGlmICghaXNTdXBwb3J0ZWRTeW1ib2woc3ltYm9sKSkge1xuICAgICAgICBzeW1ib2wgPSBnZXREZWZhdWx0U3ltYm9sKGxheWVyLCBtYXBWaWV3KTtcbiAgICB9XG4gICAgY29uc3QgZmlsbEVuYWJsZWQgPSBzeW1ib2wudHlwZSA9PT0gXCJwaWN0dXJlLW1hcmtlclwiID8gZmFsc2UgOiAhIXN5bWJvbC5jb2xvcjtcbiAgICBjb25zdCBzdHJva2VFbmFibGVkID0gaGFzU3ltYm9sT3V0bGluZShzeW1ib2wpO1xuICAgIGNvbnN0IGlzUG9pbnRDSU0gPSBzeW1ib2wudHlwZSA9PT0gXCJjaW1cIiAmJiBzeW1ib2wuZGF0YS5zeW1ib2wudHlwZSA9PT0gXCJDSU1Qb2ludFN5bWJvbFwiO1xuICAgIGNvbnN0IHN1Z2dlc3RlZEZpbGxDb2xvcnMgPSBnZXRBbGxDb2xvcnMoKTtcbiAgICBjb25zdCBzdWdnZXN0ZWRTdHJva2VDb2xvcnMgPSBzeW1ib2wudHlwZSA9PT0gXCJzaW1wbGUtbGluZVwiID8gZ2V0QWxsQ29sb3JzKCkgOiBnZXRBbGxDb2xvcnNSZXZlcnNlZCgpO1xuICAgIGNvbnN0IG9uU3R5bGVyRWRpdCA9ICh7IGRldGFpbDogeyBzeW1ib2wsIGluZm86IHsgbWFya2VyLCBzdHJva2UgLyogLCBmaWxsICovIH0gfSB9KSA9PiB7XG4gICAgICAgIGNvbnN0IHJlbmRlcmVyID0gZ2V0UmVuZGVyZXIobGF5ZXIpO1xuICAgICAgICByZW5kZXJlci5zeW1ib2wgPSBzeW1ib2w7XG4gICAgICAgIHVwZGF0ZUF1dG9WaXNWYXIoc3ltYm9sLCBtYXJrZXIgPT09IG51bGwgfHwgbWFya2VyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBtYXJrZXIuYXV0b0FkanVzdGVkLCBzdHJva2UgPT09IG51bGwgfHwgc3Ryb2tlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzdHJva2UuYXV0b0FkanVzdGVkLCBzeW1ib2xTdHlsZXIsIG9wdGlvbnMpO1xuICAgIH07XG4gICAgbGV0IHN0cm9rZTtcbiAgICBpZiAoc3ltYm9sLnR5cGUgPT09IFwic2ltcGxlLWZpbGxcIikge1xuICAgICAgICBjb25zdCBzeW0gPSBzeW1ib2w7XG4gICAgICAgIGlmIChzeW0ub3V0bGluZSkge1xuICAgICAgICAgICAgc3Ryb2tlID0ge1xuICAgICAgICAgICAgICAgIGNvbG9yOiBzeW0ub3V0bGluZS5jb2xvciA/IHN5bS5vdXRsaW5lLmNvbG9yIDogbmV3IG1vZHVsZXMuZXNyaUNvbG9yKFswLCAwLCAwLCAwLjVdKSxcbiAgICAgICAgICAgICAgICBzaXplOiBzeW0ub3V0bGluZS53aWR0aCxcbiAgICAgICAgICAgICAgICBzdHlsZTogc3ltLm91dGxpbmUuc3R5bGUsXG4gICAgICAgICAgICAgICAgYXV0b0FkanVzdGVkOiAhIXNpemVPdXRsaW5lVmlzVmFyXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3Ryb2tlID0ge1xuICAgICAgICAgICAgICAgIGNvbG9yOiBuZXcgbW9kdWxlcy5lc3JpQ29sb3IoWzAsIDAsIDAsIDAuNV0pLFxuICAgICAgICAgICAgICAgIHNpemU6IDEsXG4gICAgICAgICAgICAgICAgc3R5bGU6IFwic29saWRcIlxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChzeW1ib2wudHlwZSA9PT0gXCJzaW1wbGUtbWFya2VyXCIpIHtcbiAgICAgICAgY29uc3Qgc3ltID0gc3ltYm9sO1xuICAgICAgICBpZiAoc3ltLm91dGxpbmUpIHtcbiAgICAgICAgICAgIHN0cm9rZSA9IHtcbiAgICAgICAgICAgICAgICBjb2xvcjogc3ltLm91dGxpbmUuY29sb3IgPyBzeW0ub3V0bGluZS5jb2xvciA6IG5ldyBtb2R1bGVzLmVzcmlDb2xvcihbMCwgMCwgMCwgMC41XSksXG4gICAgICAgICAgICAgICAgc2l6ZTogc3ltLm91dGxpbmUud2lkdGhcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdHJva2UgPSB7XG4gICAgICAgICAgICAgICAgY29sb3I6IG5ldyBtb2R1bGVzLmVzcmlDb2xvcihbMCwgMCwgMCwgMC41XSksXG4gICAgICAgICAgICAgICAgc2l6ZTogMVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChzeW1ib2wudHlwZSA9PT0gXCJzaW1wbGUtbGluZVwiKSB7XG4gICAgICAgIGNvbnN0IHN5bSA9IHN5bWJvbDtcbiAgICAgICAgc3Ryb2tlID0ge1xuICAgICAgICAgICAgY29sb3I6IHN5bS5jb2xvcixcbiAgICAgICAgICAgIHNpemU6IHNpemVBdXRvVmlzVmFyID8gZ2V0U2l6ZUJ5U2NhbGUoc2l6ZUF1dG9WaXNWYXIsIG1hcFZpZXcuc2NhbGUpIDogc3ltLndpZHRoLFxuICAgICAgICAgICAgc3R5bGU6IHN5bS5zdHlsZSxcbiAgICAgICAgICAgIG1hcmtlcjogc3ltLm1hcmtlcixcbiAgICAgICAgICAgIGF1dG9BZGp1c3RlZDogISFzaXplQXV0b1Zpc1ZhclxuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHNlIGlmIChzeW1ib2wudHlwZSA9PT0gXCJjaW1cIikge1xuICAgICAgICBzdHJva2UgPSBnZXRDaW1MaW5lUHJvcHMoc3ltYm9sKTtcbiAgICAgICAgaWYgKGlzTGluZSkge1xuICAgICAgICAgICAgKHN0cm9rZS5zaXplID0gc2l6ZUF1dG9WaXNWYXIgPyBnZXRTaXplQnlTY2FsZShzaXplQXV0b1Zpc1ZhciwgbWFwVmlldy5zY2FsZSkgOiBzdHJva2Uuc2l6ZSksXG4gICAgICAgICAgICAgICAgKHN0cm9rZS5hdXRvQWRqdXN0ZWQgPSAhIXNpemVBdXRvVmlzVmFyKTtcbiAgICAgICAgICAgIGlmIChzaXplQXV0b1Zpc1Zhcikge1xuICAgICAgICAgICAgICAgIC8vIGFkanVzdHMgc3ltYm9sIHNvIGFsbCBzeW1ib2wgbGF5ZXJzIGZpdFxuICAgICAgICAgICAgICAgIGFwcGx5U3ltYm9sU2l6ZShzeW1ib2wsIHN0cm9rZS5zaXplKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgc3Ryb2tlID0ge1xuICAgICAgICAgICAgY29sb3I6IG5ldyBtb2R1bGVzLmVzcmlDb2xvcihbMjU1LCAyNTUsIDI1NSwgMC41XSksXG4gICAgICAgICAgICBzaXplOiAxXG4gICAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IHN5bWJvbFN0eWxlciA9IGF3YWl0IGNyZWF0ZVN5bWJvbFN0eWxlckVsZW1lbnQocG9wb3Zlck5vZGUpO1xuICAgIGxldCBlZGl0O1xuICAgIGlmIChpc0xpbmUpIHtcbiAgICAgICAgZWRpdCA9IHN5bWJvbFN0eWxlckVkaXQoc3ltYm9sU3R5bGVyLCBtb2R1bGVzLmVzcmlMYW5nLmNsb25lKHN5bWJvbCksIHtcbiAgICAgICAgICAgIHBvcnRhbCxcbiAgICAgICAgICAgIHN5bWJvbEZpbHRlcjogIWxheWVyU3VwcG9ydHNDSU0oKSA/IFwic2ltcGxlXCIgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBzZWN0aW9uczoge1xuICAgICAgICAgICAgICAgIHN0cm9rZToge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImNvbG9yXCIsXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbmFsOiBzeW1ib2wudHlwZSA9PT0gXCJjaW1cIixcbiAgICAgICAgICAgICAgICAgICAgb3BlbjogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgc3VnZ2VzdGVkQ29sb3JzT3BlbjogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgc3VnZ2VzdGVkQ29sb3JzOiBzdWdnZXN0ZWRTdHJva2VDb2xvcnMsXG4gICAgICAgICAgICAgICAgICAgIGV4dHJhUGFydHM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiBzeW1ib2wudHlwZSAhPT0gXCJjaW1cIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGFycm93OiBzeW1ib2wudHlwZSAhPT0gXCJjaW1cIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXV0b1N0cm9rZUFkanVzdDogaXNPR0NMYXllciB8fCBtYXBJbWFnZVN1YmxheWVyID8gZmFsc2UgOiBcImVkaXRhYmxlXCJcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzdHJva2VcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBlZGl0ID0gc3ltYm9sU3R5bGVyRWRpdChzeW1ib2xTdHlsZXIsIG1vZHVsZXMuZXNyaUxhbmcuY2xvbmUoc3ltYm9sKSwge1xuICAgICAgICAgICAgcG9ydGFsLFxuICAgICAgICAgICAgc3ltYm9sRmlsdGVyOiBpc1BvbHlnb24gJiYgIWxheWVyU3VwcG9ydHNDSU0oKSA/IFwic2ltcGxlXCIgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBzZWN0aW9uczoge1xuICAgICAgICAgICAgICAgIG1hcmtlcjogaXNQb2ludENJTSB8fCBbXCJzaW1wbGUtbWFya2VyXCIsIFwicGljdHVyZS1tYXJrZXJcIl0uaW5kZXhPZihzeW1ib2wudHlwZSkgPiAtMVxuICAgICAgICAgICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wZW46IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBzeW1ib2xzT3BlbjogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpemVPcGVuOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFydHM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaXplOiB7IGF1dG9TaXplQWRqdXN0OiBpc09HQ0xheWVyIHx8IG1hcEltYWdlU3VibGF5ZXIgPyBmYWxzZSA6IFwiZWRpdGFibGVcIiB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgbWFya2VyVHlwZTogbGF5ZXJTdXBwb3J0c0NJTSgpID8gXCJhbGxcIiA6IFtcInNpbXBsZVwiLCBcInBpY3R1cmVcIl1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBmaWxsOiB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiY29sb3JcIixcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9uYWw6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIG9wZW46IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHN1Z2dlc3RlZENvbG9yc09wZW46IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zcGFyZW5jeU9wZW46IGlzUGljdHVyZU1hcmtlcihzeW1ib2wpLFxuICAgICAgICAgICAgICAgICAgICBzdWdnZXN0ZWRDb2xvcnM6IHN1Z2dlc3RlZEZpbGxDb2xvcnNcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHN0cm9rZToge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImNvbG9yXCIsXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBzdWdnZXN0ZWRDb2xvcnM6IHN1Z2dlc3RlZFN0cm9rZUNvbG9ycyxcbiAgICAgICAgICAgICAgICAgICAgZXh0cmFQYXJ0czoge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU6IFtcInNpbXBsZS1tYXJrZXJcIiwgXCJwaWN0dXJlLW1hcmtlclwiLCBcImNpbVwiXS5pbmRleE9mKHN5bWJvbC50eXBlKSA9PT0gLTEsXG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGF1dG9TdHJva2VBZGp1c3Q6ICFpc09HQ0xheWVyICYmICFtYXBJbWFnZVN1YmxheWVyICYmIGlzUG9seWdvbiAmJiBzeW1ib2wudHlwZSAhPT0gXCJjaW1cIiA/IFwiZWRpdGFibGVcIiA6IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZmlsbDoge1xuICAgICAgICAgICAgICAgIGNvbG9yOiBnZXRTeW1ib2xDb2xvcihzeW1ib2wpIHx8IGFkanVzdEFscGhhKHN1Z2dlc3RlZEZpbGxDb2xvcnNbMV0sIDAuODUpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbWFya2VyOiBpc1BvaW50XG4gICAgICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgICAgIHNpemU6IHNpemVBdXRvVmlzVmFyID8gZ2V0U2l6ZUJ5U2NhbGUoc2l6ZUF1dG9WaXNWYXIsIG1hcFZpZXcuc2NhbGUpIDogZ2V0U3ltYm9sU2l6ZShzeW1ib2wpLFxuICAgICAgICAgICAgICAgICAgICBhdXRvQWRqdXN0ZWQ6ICFtYXBJbWFnZVN1YmxheWVyICYmICEhc2l6ZUF1dG9WaXNWYXJcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBzdHJva2UsXG4gICAgICAgICAgICBmaWxsRW5hYmxlZCxcbiAgICAgICAgICAgIHN0cm9rZUVuYWJsZWRcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHN5bWJvbFN0eWxlci5hZGRFdmVudExpc3RlbmVyKFwiYXJjZ2lzU3ltYm9sU3R5bGVyRWRpdFwiLCBvblN0eWxlckVkaXRXcmFwcGVyLmJpbmQobnVsbCwgb25TdHlsZXJFZGl0KSk7XG4gICAgcG9wb3Zlck5vZGUuYWRkU3R5bGVyKHN5bWJvbFN0eWxlcik7XG4gICAgYXdhaXQgZWRpdDtcbiAgICByZXR1cm4gY3JlYXRlV2F0Y2hTY2FsZUhhbmRsZShyZW5kZXJlci5zeW1ib2wsIHN5bWJvbFN0eWxlcik7XG59XG5hc3luYyBmdW5jdGlvbiBidWlsZFN5bWJvbFN0eWxlckZvckdlb1JTUyh0eXBlLCBvcHRpb25zKSB7XG4gICAgY29uc3QgeyBsYXllciwgbWFwVmlldywgcG9ydGFsLCBtb2R1bGVzIH0gPSBzbWFydE1hcHBpbmdTdGF0ZTtcbiAgICBjb25zdCB7IG9uQ2hhbmdlLCBwb3BvdmVyTm9kZSB9ID0gb3B0aW9ucztcbiAgICBjb25zdCBnZW9SU1NMYXllciA9IGxheWVyO1xuICAgIGNvbnN0IGlzUG9pbnQgPSB0eXBlID09PSBcInBvaW50XCI7XG4gICAgY29uc3QgaXNMaW5lID0gdHlwZSA9PT0gXCJsaW5lXCI7XG4gICAgLy9jb25zdCBpc1BvbHlnb24gPSB0eXBlID09PSBcInBvbHlnb25cIjtcbiAgICBsZXQgc3ltYm9sID0gaXNQb2ludCA/IGdlb1JTU0xheWVyLnBvaW50U3ltYm9sIDogaXNMaW5lID8gZ2VvUlNTTGF5ZXIubGluZVN5bWJvbCA6IGdlb1JTU0xheWVyLnBvbHlnb25TeW1ib2w7XG4gICAgaWYgKCFpc1N1cHBvcnRlZFN5bWJvbChzeW1ib2wpKSB7XG4gICAgICAgIHN5bWJvbCA9IGdldEdlb1JTU0RlZmF1bHRTeW1ib2wobWFwVmlldywgdHlwZSk7XG4gICAgfVxuICAgIGNvbnN0IGZpbGxFbmFibGVkID0gc3ltYm9sLnR5cGUgPT09IFwicGljdHVyZS1tYXJrZXJcIiA/IGZhbHNlIDogISFzeW1ib2wuY29sb3I7XG4gICAgY29uc3Qgc3Ryb2tlRW5hYmxlZCA9IGhhc1N5bWJvbE91dGxpbmUoc3ltYm9sKTtcbiAgICBjb25zdCBzdWdnZXN0ZWRGaWxsQ29sb3JzID0gZ2V0QWxsQ29sb3JzKCk7XG4gICAgY29uc3Qgc3VnZ2VzdGVkU3Ryb2tlQ29sb3JzID0gc3ltYm9sLnR5cGUgPT09IFwic2ltcGxlLWxpbmVcIiA/IGdldEFsbENvbG9ycygpIDogZ2V0QWxsQ29sb3JzUmV2ZXJzZWQoKTtcbiAgICBjb25zdCBvblN0eWxlckVkaXQgPSAoeyBkZXRhaWw6IHsgc3ltYm9sIC8qICxcbiAgICBpbmZvOiB7IG1hcmtlciwgc3Ryb2tlLCBmaWxsIH0gKi8gfSB9KSA9PiB7XG4gICAgICAgIGlmIChpc1BvaW50KSB7XG4gICAgICAgICAgICBnZW9SU1NMYXllci5wb2ludFN5bWJvbCA9IHN5bWJvbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc0xpbmUpIHtcbiAgICAgICAgICAgIGdlb1JTU0xheWVyLmxpbmVTeW1ib2wgPSBzeW1ib2w7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBnZW9SU1NMYXllci5wb2x5Z29uU3ltYm9sID0gc3ltYm9sO1xuICAgICAgICB9XG4gICAgICAgIG9uQ2hhbmdlKCk7XG4gICAgfTtcbiAgICBsZXQgc3Ryb2tlO1xuICAgIGlmIChzeW1ib2wudHlwZSA9PT0gXCJzaW1wbGUtZmlsbFwiKSB7XG4gICAgICAgIGNvbnN0IHN5bSA9IHN5bWJvbDtcbiAgICAgICAgaWYgKHN5bS5vdXRsaW5lKSB7XG4gICAgICAgICAgICBzdHJva2UgPSB7XG4gICAgICAgICAgICAgICAgY29sb3I6IHN5bS5vdXRsaW5lLmNvbG9yID8gc3ltLm91dGxpbmUuY29sb3IgOiBuZXcgbW9kdWxlcy5lc3JpQ29sb3IoWzAsIDAsIDAsIDAuNV0pLFxuICAgICAgICAgICAgICAgIHNpemU6IHN5bS5vdXRsaW5lLndpZHRoLFxuICAgICAgICAgICAgICAgIHN0eWxlOiBzeW0ub3V0bGluZS5zdHlsZSxcbiAgICAgICAgICAgICAgICBhdXRvQWRqdXN0ZWQ6IGZhbHNlXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3Ryb2tlID0ge1xuICAgICAgICAgICAgICAgIGNvbG9yOiBuZXcgbW9kdWxlcy5lc3JpQ29sb3IoWzAsIDAsIDAsIDAuNV0pLFxuICAgICAgICAgICAgICAgIHNpemU6IDEsXG4gICAgICAgICAgICAgICAgc3R5bGU6IFwic29saWRcIlxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChzeW1ib2wudHlwZSA9PT0gXCJzaW1wbGUtbWFya2VyXCIpIHtcbiAgICAgICAgY29uc3Qgc3ltID0gc3ltYm9sO1xuICAgICAgICBpZiAoc3ltLm91dGxpbmUpIHtcbiAgICAgICAgICAgIHN0cm9rZSA9IHtcbiAgICAgICAgICAgICAgICBjb2xvcjogc3ltLm91dGxpbmUuY29sb3IgPyBzeW0ub3V0bGluZS5jb2xvciA6IG5ldyBtb2R1bGVzLmVzcmlDb2xvcihbMCwgMCwgMCwgMC41XSksXG4gICAgICAgICAgICAgICAgc2l6ZTogc3ltLm91dGxpbmUud2lkdGhcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdHJva2UgPSB7XG4gICAgICAgICAgICAgICAgY29sb3I6IG5ldyBtb2R1bGVzLmVzcmlDb2xvcihbMCwgMCwgMCwgMC41XSksXG4gICAgICAgICAgICAgICAgc2l6ZTogMVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChzeW1ib2wudHlwZSA9PT0gXCJzaW1wbGUtbGluZVwiKSB7XG4gICAgICAgIGNvbnN0IHN5bSA9IHN5bWJvbDtcbiAgICAgICAgc3Ryb2tlID0ge1xuICAgICAgICAgICAgY29sb3I6IHN5bS5jb2xvcixcbiAgICAgICAgICAgIHNpemU6IHN5bS53aWR0aCxcbiAgICAgICAgICAgIHN0eWxlOiBzeW0uc3R5bGUsXG4gICAgICAgICAgICBtYXJrZXI6IHN5bS5tYXJrZXIsXG4gICAgICAgICAgICBhdXRvQWRqdXN0ZWQ6IGZhbHNlXG4gICAgICAgIH07XG4gICAgICAgIC8vfSBlbHNlIGlmIChzeW1ib2wudHlwZSA9PT0gXCJjaW1cIikge1xuICAgICAgICAvLyAgc3Ryb2tlID0gZ2V0Q2ltTGluZVByb3BzKHN5bWJvbCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBzdHJva2UgPSB7XG4gICAgICAgICAgICBjb2xvcjogbmV3IG1vZHVsZXMuZXNyaUNvbG9yKFsyNTUsIDI1NSwgMjU1LCAwLjVdKSxcbiAgICAgICAgICAgIHNpemU6IDFcbiAgICAgICAgfTtcbiAgICB9XG4gICAgY29uc3Qgc3ltYm9sU3R5bGVyID0gYXdhaXQgY3JlYXRlU3ltYm9sU3R5bGVyRWxlbWVudChwb3BvdmVyTm9kZSk7XG4gICAgbGV0IGVkaXQ7XG4gICAgaWYgKGlzTGluZSkge1xuICAgICAgICBlZGl0ID0gc3ltYm9sU3R5bGVyRWRpdChzeW1ib2xTdHlsZXIsIG1vZHVsZXMuZXNyaUxhbmcuY2xvbmUoc3ltYm9sKSwge1xuICAgICAgICAgICAgcG9ydGFsLFxuICAgICAgICAgICAgc2VjdGlvbnM6IHtcbiAgICAgICAgICAgICAgICBzdHJva2U6IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJjb2xvclwiLFxuICAgICAgICAgICAgICAgICAgICBvcGVuOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBzdWdnZXN0ZWRDb2xvcnNPcGVuOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBzdWdnZXN0ZWRDb2xvcnM6IHN1Z2dlc3RlZFN0cm9rZUNvbG9ycyxcbiAgICAgICAgICAgICAgICAgICAgZXh0cmFQYXJ0czoge1xuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBhdXRvU3Ryb2tlQWRqdXN0OiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHN0cm9rZVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGVkaXQgPSBzeW1ib2xTdHlsZXJFZGl0KHN5bWJvbFN0eWxlciwgbW9kdWxlcy5lc3JpTGFuZy5jbG9uZShzeW1ib2wpLCB7XG4gICAgICAgICAgICBwb3J0YWwsXG4gICAgICAgICAgICBzZWN0aW9uczoge1xuICAgICAgICAgICAgICAgIG1hcmtlcjogW1wic2ltcGxlLW1hcmtlclwiLCBcInBpY3R1cmUtbWFya2VyXCJdLmluZGV4T2Yoc3ltYm9sLnR5cGUpID4gLTFcbiAgICAgICAgICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcGVuOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3ltYm9sc09wZW46IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBzaXplT3BlbjogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hcmtlclR5cGU6IFtcInNpbXBsZVwiLCBcInBpY3R1cmVcIl1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBmaWxsOiB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiY29sb3JcIixcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9uYWw6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIG9wZW46IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHN1Z2dlc3RlZENvbG9yc09wZW46IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zcGFyZW5jeU9wZW46IGlzUGljdHVyZU1hcmtlcihzeW1ib2wpLFxuICAgICAgICAgICAgICAgICAgICBzdWdnZXN0ZWRDb2xvcnM6IHN1Z2dlc3RlZEZpbGxDb2xvcnNcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHN0cm9rZToge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImNvbG9yXCIsXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBzdWdnZXN0ZWRDb2xvcnM6IHN1Z2dlc3RlZFN0cm9rZUNvbG9ycyxcbiAgICAgICAgICAgICAgICAgICAgZXh0cmFQYXJ0czoge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU6IFtcInNpbXBsZS1tYXJrZXJcIiwgXCJwaWN0dXJlLW1hcmtlclwiLCBcImNpbVwiXS5pbmRleE9mKHN5bWJvbC50eXBlKSA9PT0gLTEsXG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGF1dG9TdHJva2VBZGp1c3Q6IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZmlsbDoge1xuICAgICAgICAgICAgICAgIGNvbG9yOiBnZXRTeW1ib2xDb2xvcihzeW1ib2wpIHx8IGFkanVzdEFscGhhKHN1Z2dlc3RlZEZpbGxDb2xvcnNbMV0sIDAuODUpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbWFya2VyOiBpc1BvaW50XG4gICAgICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgICAgIHNpemU6IGdldFN5bWJvbFNpemUoc3ltYm9sKSxcbiAgICAgICAgICAgICAgICAgICAgYXV0b0FkanVzdGVkOiBmYWxzZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHN0cm9rZSxcbiAgICAgICAgICAgIGZpbGxFbmFibGVkLFxuICAgICAgICAgICAgc3Ryb2tlRW5hYmxlZFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgc3ltYm9sU3R5bGVyLmFkZEV2ZW50TGlzdGVuZXIoXCJhcmNnaXNTeW1ib2xTdHlsZXJFZGl0XCIsIG9uU3R5bGVyRWRpdFdyYXBwZXIuYmluZChudWxsLCBvblN0eWxlckVkaXQpKTtcbiAgICBwb3BvdmVyTm9kZS5hZGRTdHlsZXIoc3ltYm9sU3R5bGVyKTtcbiAgICBhd2FpdCBlZGl0O1xufVxuYXN5bmMgZnVuY3Rpb24gYnVpbGRTeW1ib2xTdHlsZXJGb3JTaXplKG9wdGlvbnMpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIGNvbnN0IHsgbGF5ZXIsIG1hcFZpZXcsIHBvcnRhbCwgbW9kdWxlcyB9ID0gc21hcnRNYXBwaW5nU3RhdGU7XG4gICAgY29uc3QgeyBvbkNoYW5nZSwgcG9wb3Zlck5vZGUgfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgaXNMaW5lID0gaXNQb2x5bGluZVR5cGUobGF5ZXIpO1xuICAgIGNvbnN0IHJlbmRlcmVyID0gZ2V0UmVuZGVyZXIobGF5ZXIpO1xuICAgIGNvbnN0IHJlbmRlcmVyVHlwZSA9IGdldFJlbmRlcmVyVHlwZSgpO1xuICAgIGNvbnN0IGNvbG9yVmlzVmFyID0gZ2V0VmlzVmFyKHJlbmRlcmVyLCBcImNvbG9yXCIpO1xuICAgIGNvbnN0IGlzQml2YXJpYXRSZW5kZXJlciA9IFtcInR5cGUtc2l6ZVwiLCBcInR5cGUtc2l6ZS1hZ2VcIiwgXCJwcmVkb21pbmFuY2Utc2l6ZVwiLCBcInJlbGF0aW9uc2hpcC1zaXplXCJdLmluZGV4T2YocmVuZGVyZXJUeXBlKSA+IC0xO1xuICAgIGxldCBzeW1ib2w7XG4gICAgaWYgKGlzQml2YXJpYXRSZW5kZXJlcikge1xuICAgICAgICBjb25zdCB1dlJlbmRlcmVyID0gZ2V0UmVuZGVyZXIobGF5ZXIpO1xuICAgICAgICBzeW1ib2wgPSAoKF9hID0gdXZSZW5kZXJlci51bmlxdWVWYWx1ZUluZm9zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubGVuZ3RoKVxuICAgICAgICAgICAgPyB1dlJlbmRlcmVyLnVuaXF1ZVZhbHVlSW5mb3NbMF0uc3ltYm9sXG4gICAgICAgICAgICA6IGdldERlZmF1bHRTeW1ib2wobGF5ZXIsIG1hcFZpZXcsIHJlbmRlcmVyVHlwZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBzeW1ib2wgPSAoKF9iID0gcmVuZGVyZXIuY2xhc3NCcmVha0luZm9zKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IubGVuZ3RoKVxuICAgICAgICAgICAgPyByZW5kZXJlci5jbGFzc0JyZWFrSW5mb3NbMF0uc3ltYm9sXG4gICAgICAgICAgICA6IGdldERlZmF1bHRTeW1ib2wobGF5ZXIsIG1hcFZpZXcsIHJlbmRlcmVyVHlwZSk7XG4gICAgfVxuICAgIGlmICghaXNTdXBwb3J0ZWRTeW1ib2woc3ltYm9sKSkge1xuICAgICAgICBzeW1ib2wgPSBnZXREZWZhdWx0U3ltYm9sKGxheWVyLCBtYXBWaWV3LCByZW5kZXJlclR5cGUpO1xuICAgIH1cbiAgICBjb25zdCBmaWxsRW5hYmxlZCA9IHN5bWJvbC50eXBlID09PSBcInBpY3R1cmUtbWFya2VyXCIgPyBmYWxzZSA6ICEhc3ltYm9sLmNvbG9yO1xuICAgIGNvbnN0IHN0cm9rZUVuYWJsZWQgPSBoYXNTeW1ib2xPdXRsaW5lKHN5bWJvbCk7XG4gICAgY29uc3QgaXNQb2ludENJTSA9IHN5bWJvbC50eXBlID09PSBcImNpbVwiICYmIHN5bWJvbC5kYXRhLnN5bWJvbC50eXBlID09PSBcIkNJTVBvaW50U3ltYm9sXCI7XG4gICAgLy8gVE9ETyBnZXQgY3VycmVudCBzY2hlbWVcbiAgICBjb25zdCBzdWdnZXN0ZWRGaWxsQ29sb3JzID0gZ2V0QWxsQ29sb3JzKCk7XG4gICAgY29uc3Qgc3VnZ2VzdGVkU3Ryb2tlQ29sb3JzID0gc3ltYm9sLnR5cGUgPT09IFwic2ltcGxlLWxpbmVcIiA/IGdldEFsbENvbG9ycygpIDogZ2V0QWxsQ29sb3JzUmV2ZXJzZWQoKTtcbiAgICBjb25zdCBvblN0eWxlckVkaXQgPSAoeyBkZXRhaWw6IHsgc3ltYm9sIC8qICxcbiAgICBpbmZvOiB7IG1hcmtlciwgc3Ryb2tlLCBmaWxsIH0gKi8gfSB9KSA9PiB7XG4gICAgICAgIGNvbnN0IHJlbmRlcmVyID0gZ2V0UmVuZGVyZXIobGF5ZXIpO1xuICAgICAgICBpZiAocmVuZGVyZXIuY2xhc3NCcmVha0luZm9zKSB7XG4gICAgICAgICAgICBsZXQgaW5mb3MgPSByZW5kZXJlci5jbGFzc0JyZWFrSW5mb3M7XG4gICAgICAgICAgICBpZiAoIWluZm9zIHx8ICFpbmZvcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAvLyB3ZSBoYXZlIG5vIHBsYWNlIHRvIHNhdmUgdGhvc2UgY2hhbmdlc1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIG1ha2UgYSBjb3B5IHNvIG1vZHVsZXMuZXNyaUxhbmcuY2xvbmUoKSB3b3JrcyBsYXRlclxuICAgICAgICAgICAgaW5mb3MgPSBpbmZvcy5zbGljZSgpO1xuICAgICAgICAgICAgaW5mb3MuZm9yRWFjaCgoaW5mbykgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNpemUgPSBnZXRTeW1ib2xTaXplKGluZm8uc3ltYm9sKTtcbiAgICAgICAgICAgICAgICBjb25zdCBjb2xvciA9IGdldFN5bWJvbENvbG9yKGluZm8uc3ltYm9sKTtcbiAgICAgICAgICAgICAgICBpbmZvLnN5bWJvbCA9IHN5bWJvbC5jbG9uZSgpO1xuICAgICAgICAgICAgICAgIGlmIChjb2xvclZpc1Zhcikge1xuICAgICAgICAgICAgICAgICAgICAvLyB3ZSB3YW50IHRoZSBvbmx5IGJyZWFrIHN5bWJvbCB0byBhbHdheXMgYmUgZ3JleVxuICAgICAgICAgICAgICAgICAgICBhcHBseVN5bWJvbENvbG9yKGluZm8uc3ltYm9sLCBuZXcgbW9kdWxlcy5lc3JpQ29sb3IoWzAsIDAsIDAsIDAuNV0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocmVuZGVyZXIudW5pcXVlVmFsdWVJbmZvcykge1xuICAgICAgICAgICAgICAgICAgICAvLyB3ZSB3YW50IHRvIGtlZXAgdGhlIG9sZCBjb2xvclxuICAgICAgICAgICAgICAgICAgICBhcHBseVN5bWJvbENvbG9yKGluZm8uc3ltYm9sLCBjb2xvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFwcGx5U3ltYm9sU2l6ZShpbmZvLnN5bWJvbCwgc2l6ZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJlbmRlcmVyLmNsYXNzQnJlYWtJbmZvcyA9IGluZm9zO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IGdyb3VwcyA9IHJlbmRlcmVyLnVuaXF1ZVZhbHVlR3JvdXBzO1xuICAgICAgICAgICAgaWYgKCFncm91cHMgfHwgIWdyb3Vwcy5sZW5ndGggfHwgIWdyb3Vwc1swXS5jbGFzc2VzIHx8ICFncm91cHNbMF0uY2xhc3Nlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAvLyB3ZSBoYXZlIG5vIHBsYWNlIHRvIHNhdmUgdGhvc2UgY2hhbmdlc1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIG1ha2UgYSBjb3B5IHNvIG1vZHVsZXMuZXNyaUxhbmcuY2xvbmUoKSB3b3JrcyBsYXRlclxuICAgICAgICAgICAgZ3JvdXBzID0gZ3JvdXBzLnNsaWNlKCk7XG4gICAgICAgICAgICBncm91cHMuZm9yRWFjaCgoZ3JvdXApID0+IHtcbiAgICAgICAgICAgICAgICBncm91cC5jbGFzc2VzLmZvckVhY2goKHVuaXF1ZVZhbHVlQ2xhc3MpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2l6ZSA9IGdldFN5bWJvbFNpemUodW5pcXVlVmFsdWVDbGFzcy5zeW1ib2wpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjb2xvciA9IGdldFN5bWJvbENvbG9yKHVuaXF1ZVZhbHVlQ2xhc3Muc3ltYm9sKTtcbiAgICAgICAgICAgICAgICAgICAgdW5pcXVlVmFsdWVDbGFzcy5zeW1ib2wgPSBzeW1ib2wuY2xvbmUoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbG9yVmlzVmFyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB3ZSB3YW50IHRoZSBvbmx5IGJyZWFrIHN5bWJvbCB0byBhbHdheXMgYmUgZ3JleVxuICAgICAgICAgICAgICAgICAgICAgICAgYXBwbHlTeW1ib2xDb2xvcih1bmlxdWVWYWx1ZUNsYXNzLnN5bWJvbCwgbmV3IG1vZHVsZXMuZXNyaUNvbG9yKFswLCAwLCAwLCAwLjVdKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB3ZSB3YW50IHRvIGtlZXAgdGhlIG9sZCBjb2xvclxuICAgICAgICAgICAgICAgICAgICAgICAgYXBwbHlTeW1ib2xDb2xvcih1bmlxdWVWYWx1ZUNsYXNzLnN5bWJvbCwgY29sb3IpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGFwcGx5U3ltYm9sU2l6ZSh1bmlxdWVWYWx1ZUNsYXNzLnN5bWJvbCwgc2l6ZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJlbmRlcmVyLnVuaXF1ZVZhbHVlR3JvdXBzID0gZ3JvdXBzO1xuICAgICAgICB9XG4gICAgICAgIG9uQ2hhbmdlKCk7XG4gICAgfTtcbiAgICBsZXQgc3Ryb2tlO1xuICAgIGlmIChzeW1ib2wudHlwZSA9PT0gXCJzaW1wbGUtZmlsbFwiKSB7XG4gICAgICAgIGNvbnN0IHN5bSA9IHN5bWJvbDtcbiAgICAgICAgaWYgKHN5bS5vdXRsaW5lKSB7XG4gICAgICAgICAgICBzdHJva2UgPSB7XG4gICAgICAgICAgICAgICAgY29sb3I6IHN5bS5vdXRsaW5lLmNvbG9yID8gc3ltLm91dGxpbmUuY29sb3IgOiBuZXcgbW9kdWxlcy5lc3JpQ29sb3IoWzAsIDAsIDAsIDAuNV0pLFxuICAgICAgICAgICAgICAgIHNpemU6IHN5bS5vdXRsaW5lLndpZHRoLFxuICAgICAgICAgICAgICAgIHN0eWxlOiBzeW0ub3V0bGluZS5zdHlsZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN0cm9rZSA9IHtcbiAgICAgICAgICAgICAgICBjb2xvcjogbmV3IG1vZHVsZXMuZXNyaUNvbG9yKFswLCAwLCAwLCAwLjVdKSxcbiAgICAgICAgICAgICAgICBzaXplOiAxLFxuICAgICAgICAgICAgICAgIHN0eWxlOiBcInNvbGlkXCJcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoc3ltYm9sLnR5cGUgPT09IFwic2ltcGxlLW1hcmtlclwiKSB7XG4gICAgICAgIGNvbnN0IHN5bSA9IHN5bWJvbDtcbiAgICAgICAgaWYgKHN5bS5vdXRsaW5lKSB7XG4gICAgICAgICAgICBzdHJva2UgPSB7XG4gICAgICAgICAgICAgICAgY29sb3I6IHN5bS5vdXRsaW5lLmNvbG9yID8gc3ltLm91dGxpbmUuY29sb3IgOiBuZXcgbW9kdWxlcy5lc3JpQ29sb3IoWzAsIDAsIDAsIDAuNV0pLFxuICAgICAgICAgICAgICAgIHNpemU6IHN5bS5vdXRsaW5lLndpZHRoXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3Ryb2tlID0ge1xuICAgICAgICAgICAgICAgIGNvbG9yOiBuZXcgbW9kdWxlcy5lc3JpQ29sb3IoWzAsIDAsIDAsIDAuNV0pLFxuICAgICAgICAgICAgICAgIHNpemU6IDFcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoc3ltYm9sLnR5cGUgPT09IFwic2ltcGxlLWxpbmVcIikge1xuICAgICAgICBjb25zdCBzeW0gPSBzeW1ib2w7XG4gICAgICAgIHN0cm9rZSA9IHtcbiAgICAgICAgICAgIGNvbG9yOiBzeW0uY29sb3IsXG4gICAgICAgICAgICBzaXplOiBzeW0ud2lkdGgsXG4gICAgICAgICAgICBzdHlsZTogc3ltLnN0eWxlLFxuICAgICAgICAgICAgbWFya2VyOiBzeW0ubWFya2VyXG4gICAgICAgIH07XG4gICAgfVxuICAgIGVsc2UgaWYgKHN5bWJvbC50eXBlID09PSBcImNpbVwiKSB7XG4gICAgICAgIHN0cm9rZSA9IGdldENpbUxpbmVQcm9wcyhzeW1ib2wpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgc3Ryb2tlID0ge1xuICAgICAgICAgICAgY29sb3I6IG5ldyBtb2R1bGVzLmVzcmlDb2xvcihbMjU1LCAyNTUsIDI1NSwgMC41XSksXG4gICAgICAgICAgICBzaXplOiAxXG4gICAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IHN5bWJvbFN0eWxlciA9IGF3YWl0IGNyZWF0ZVN5bWJvbFN0eWxlckVsZW1lbnQocG9wb3Zlck5vZGUpO1xuICAgIGxldCBlZGl0O1xuICAgIGlmIChbXG4gICAgICAgIFwiY29sb3Itc2l6ZVwiLFxuICAgICAgICBcImNvbG9yLWFnZS1zaXplXCIsXG4gICAgICAgIFwiY29sb3Itc2l6ZS1hZ2VcIixcbiAgICAgICAgXCJ0eXBlLXNpemVcIixcbiAgICAgICAgXCJ0eXBlLXNpemUtYWdlXCIsXG4gICAgICAgIFwicHJlZG9taW5hbmNlLXNpemVcIixcbiAgICAgICAgXCJyZWxhdGlvbnNoaXAtc2l6ZVwiXG4gICAgXS5pbmRleE9mKGdldFJlbmRlcmVyVHlwZSgpKSA+IC0xKSB7XG4gICAgICAgIC8vIG5vIGNoYW5nZXMgdG8gY29sb3JcbiAgICAgICAgaWYgKGlzTGluZSkge1xuICAgICAgICAgICAgLy8gbm8gY2hhbmdlcyB0byBsaW5lIHdpZHRoXG4gICAgICAgICAgICAvLyBUT0RPIG5lZWQgdG8gaGlkZSAyIGNvbG9yIHN1YnNlY3Rpb25zXG4gICAgICAgICAgICBlZGl0ID0gc3ltYm9sU3R5bGVyRWRpdChzeW1ib2xTdHlsZXIsIG1vZHVsZXMuZXNyaUxhbmcuY2xvbmUoc3ltYm9sKSwge1xuICAgICAgICAgICAgICAgIHBvcnRhbCxcbiAgICAgICAgICAgICAgICBzeW1ib2xGaWx0ZXI6ICFsYXllclN1cHBvcnRzQ0lNKCkgPyBcInNpbXBsZVwiIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIHNlY3Rpb25zOiB7XG4gICAgICAgICAgICAgICAgICAgIHN0cm9rZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJjb2xvclwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgb3BlbjogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4dHJhT3BlbjogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4dHJhUGFydHM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZTogc3ltYm9sLnR5cGUgIT09IFwiY2ltXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJyb3c6IHN5bWJvbC50eXBlICE9PSBcImNpbVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdXRvU3Ryb2tlQWRqdXN0OiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1Z2dlc3RlZENvbG9yczogc3VnZ2VzdGVkU3Ryb2tlQ29sb3JzLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFydHM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWdnZXN0ZWRDb2xvcnM6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1c3RvbUNvbG9yOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc3BhcmVuY3k6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXh0cmE6IHN5bWJvbC50eXBlICE9PSBcImNpbVwiXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHN0cm9rZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBlZGl0ID0gc3ltYm9sU3R5bGVyRWRpdChzeW1ib2xTdHlsZXIsIG1vZHVsZXMuZXNyaUxhbmcuY2xvbmUoc3ltYm9sKSwge1xuICAgICAgICAgICAgICAgIHBvcnRhbCxcbiAgICAgICAgICAgICAgICBzZWN0aW9uczoge1xuICAgICAgICAgICAgICAgICAgICBtYXJrZXI6IGlzUG9pbnRDSU0gfHwgW1wic2ltcGxlLW1hcmtlclwiLCBcInBpY3R1cmUtbWFya2VyXCJdLmluZGV4T2Yoc3ltYm9sLnR5cGUpID4gLTFcbiAgICAgICAgICAgICAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wZW46IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFydHM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2l6ZTogZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN5bWJvbHNPcGVuOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpemVPcGVuOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXJrZXJUeXBlOiBsYXllclN1cHBvcnRzQ0lNKCkgPyBbXCJzaW1wbGVcIiwgXCJjaW06dmVjdG9yXCJdIDogW1wic2ltcGxlXCJdXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgc3Ryb2tlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImNvbG9yXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBvcGVuOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uYWw6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdWdnZXN0ZWRDb2xvcnM6IHN1Z2dlc3RlZFN0cm9rZUNvbG9ycyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4dHJhUGFydHM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZTogW1wic2ltcGxlLW1hcmtlclwiLCBcInBpY3R1cmUtbWFya2VyXCIsIFwiY2ltXCJdLmluZGV4T2Yoc3ltYm9sLnR5cGUpID09PSAtMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdXRvU3Ryb2tlQWRqdXN0OiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBtYXJrZXI6IHtcbiAgICAgICAgICAgICAgICAgICAgc2l6ZTogZ2V0U3ltYm9sU2l6ZShzeW1ib2wpXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzdHJva2UsXG4gICAgICAgICAgICAgICAgc3Ryb2tlRW5hYmxlZFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmIChpc0xpbmUpIHtcbiAgICAgICAgICAgIGVkaXQgPSBzeW1ib2xTdHlsZXJFZGl0KHN5bWJvbFN0eWxlciwgbW9kdWxlcy5lc3JpTGFuZy5jbG9uZShzeW1ib2wpLCB7XG4gICAgICAgICAgICAgICAgcG9ydGFsLFxuICAgICAgICAgICAgICAgIHN5bWJvbEZpbHRlcjogIWxheWVyU3VwcG9ydHNDSU0oKSA/IFwic2ltcGxlXCIgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgc2VjdGlvbnM6IHtcbiAgICAgICAgICAgICAgICAgICAgc3Ryb2tlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImNvbG9yXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBvcGVuOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXh0cmFQYXJ0czoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiBzeW1ib2wudHlwZSAhPT0gXCJjaW1cIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcnJvdzogc3ltYm9sLnR5cGUgIT09IFwiY2ltXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF1dG9TdHJva2VBZGp1c3Q6IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgc3VnZ2VzdGVkQ29sb3JzT3BlbjogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1Z2dlc3RlZENvbG9yczogc3VnZ2VzdGVkU3Ryb2tlQ29sb3JzLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFydHM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHRyYTogc3ltYm9sLnR5cGUgIT09IFwiY2ltXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc3Ryb2tlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIHJlbmRlcmVyVHlwZSA9PT0gXCJzaXplXCJcbiAgICAgICAgICAgIGVkaXQgPSBzeW1ib2xTdHlsZXJFZGl0KHN5bWJvbFN0eWxlciwgbW9kdWxlcy5lc3JpTGFuZy5jbG9uZShzeW1ib2wpLCB7XG4gICAgICAgICAgICAgICAgcG9ydGFsLFxuICAgICAgICAgICAgICAgIHNlY3Rpb25zOiB7XG4gICAgICAgICAgICAgICAgICAgIG1hcmtlcjogaXNQb2ludENJTSB8fCBbXCJzaW1wbGUtbWFya2VyXCIsIFwicGljdHVyZS1tYXJrZXJcIl0uaW5kZXhPZihzeW1ib2wudHlwZSkgPiAtMVxuICAgICAgICAgICAgICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3BlbjogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJ0czoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaXplOiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ltYm9sc09wZW46IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2l6ZU9wZW46IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcmtlclR5cGU6IGxheWVyU3VwcG9ydHNDSU0oKSA/IFwiYWxsXCIgOiBbXCJzaW1wbGVcIiwgXCJwaWN0dXJlXCJdXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgZmlsbDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJjb2xvclwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgb3BlbjogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3VnZ2VzdGVkQ29sb3JzT3BlbjogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zcGFyZW5jeU9wZW46IGlzUGljdHVyZU1hcmtlcihzeW1ib2wpLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3VnZ2VzdGVkQ29sb3JzOiBzdWdnZXN0ZWRGaWxsQ29sb3JzXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHN0cm9rZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJjb2xvclwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uYWw6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdWdnZXN0ZWRDb2xvcnM6IHN1Z2dlc3RlZFN0cm9rZUNvbG9ycyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4dHJhUGFydHM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZTogW1wic2ltcGxlLW1hcmtlclwiLCBcInBpY3R1cmUtbWFya2VyXCIsIFwiY2ltXCJdLmluZGV4T2Yoc3ltYm9sLnR5cGUpID09PSAtMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdXRvU3Ryb2tlQWRqdXN0OiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBmaWxsOiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbG9yOiBnZXRTeW1ib2xDb2xvcihzeW1ib2wpIHx8IGFkanVzdEFscGhhKHN1Z2dlc3RlZEZpbGxDb2xvcnNbMV0sIDAuODUpXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBtYXJrZXI6IHtcbiAgICAgICAgICAgICAgICAgICAgc2l6ZTogZ2V0U3ltYm9sU2l6ZShzeW1ib2wpXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzdHJva2UsXG4gICAgICAgICAgICAgICAgZmlsbEVuYWJsZWQsXG4gICAgICAgICAgICAgICAgc3Ryb2tlRW5hYmxlZFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3ltYm9sU3R5bGVyLmFkZEV2ZW50TGlzdGVuZXIoXCJhcmNnaXNTeW1ib2xTdHlsZXJFZGl0XCIsIG9uU3R5bGVyRWRpdFdyYXBwZXIuYmluZChudWxsLCBvblN0eWxlckVkaXQpKTtcbiAgICBwb3BvdmVyTm9kZS5hZGRTdHlsZXIoc3ltYm9sU3R5bGVyKTtcbiAgICBhd2FpdCBlZGl0O1xufVxuYXN5bmMgZnVuY3Rpb24gYnVpbGRTeW1ib2xTdHlsZXJGb3JDb2xvclJhbXAob3B0aW9ucykge1xuICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICBjb25zdCB7IGxheWVyLCBtYXBJbWFnZVN1YmxheWVyLCBtYXBWaWV3LCBwb3J0YWwsIG1vZHVsZXMgfSA9IHNtYXJ0TWFwcGluZ1N0YXRlO1xuICAgIGNvbnN0IHsgb25DaGFuZ2UsIHBvcG92ZXJOb2RlIH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IGlzUG9pbnQgPSBpc1BvaW50VHlwZShsYXllcik7XG4gICAgY29uc3QgaXNMaW5lID0gaXNQb2x5bGluZVR5cGUobGF5ZXIpO1xuICAgIGNvbnN0IGlzUG9seWdvbiA9IGlzUG9seWdvblR5cGUobGF5ZXIpO1xuICAgIGNvbnN0IHJlbmRlcmVyID0gZ2V0UmVuZGVyZXIobGF5ZXIpO1xuICAgIGNvbnN0IGF1dGhJbmZvID0gcmVuZGVyZXIuYXV0aG9yaW5nSW5mbztcbiAgICBjb25zdCByZW5kZXJlclR5cGUgPSBnZXRSZW5kZXJlclR5cGUoKTtcbiAgICBjb25zdCBpc1VuaXZhcmlhdGUgPSAoYXV0aEluZm8gPT09IG51bGwgfHwgYXV0aEluZm8gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGF1dGhJbmZvLnR5cGUpID09PSBcInVuaXZhcmlhdGUtY29sb3Itc2l6ZVwiO1xuICAgIGNvbnN0IGlzQWJvdmVBbmRCZWxvdyA9IChhdXRoSW5mbyA9PT0gbnVsbCB8fCBhdXRoSW5mbyA9PT0gdm9pZCAwID8gdm9pZCAwIDogYXV0aEluZm8udW5pdmFyaWF0ZVRoZW1lKSA9PT0gXCJhYm92ZS1hbmQtYmVsb3dcIjtcbiAgICAvLyBlLmcuIGxpbmUgbGF5ZXJzIGRvbid0IHN1cHBvcnQgc3ltYm9sIHBhaXJzIGZvciB1bml2YXJpYXRlIGFib3ZlLWFuZC1iZWxvd1xuICAgIGNvbnN0IGlzQWJvdmVBbmRCZWxvd1NpbmdsZSA9IGlzQWJvdmVBbmRCZWxvdyAmJiAhYXV0aEluZm8udW5pdmFyaWF0ZVN5bWJvbFN0eWxlO1xuICAgIGNvbnN0IGNvbG9yVmlzVmFyID0gZ2V0VmlzVmFyKGdldFJlbmRlcmVyKGxheWVyKSwgXCJjb2xvclwiKTtcbiAgICBjb25zdCBzaXplQXV0b1Zpc1ZhciA9IGdldFZpc1ZhcihyZW5kZXJlciwgXCJzaXplXCIsIFwiYXV0b1wiKTtcbiAgICBjb25zdCBzaXplT3V0bGluZVZpc1ZhciA9IGdldFZpc1ZhcihyZW5kZXJlciwgXCJzaXplXCIsIFwib3V0bGluZVwiKTtcbiAgICBjb25zdCBpc0NvbG9yU2l6ZSA9IFtcImNvbG9yLXNpemVcIiwgXCJjb2xvci1hZ2Utc2l6ZVwiLCBcImNvbG9yLXNpemUtYWdlXCJdLmluZGV4T2YocmVuZGVyZXJUeXBlKSA+IC0xO1xuICAgIGNvbnN0IGF1dGhDb2xvclZpc1ZhciA9IGdldEF1dGhWaXNWYXIoZ2V0UmVuZGVyZXIobGF5ZXIpLCBcImNvbG9yXCIpO1xuICAgIGxldCBjdXJyZW50Q29sb3JzID0gY29sb3JWaXNWYXJcbiAgICAgICAgPyBjb2xvclZpc1Zhci5zdG9wcy5tYXAoKHN0b3ApID0+IHN0b3AuY29sb3IpXG4gICAgICAgIDogcmVuZGVyZXIuY2xhc3NCcmVha0luZm9zLm1hcCgoY2xhc3NCcmVha0luZm8pID0+IHsgdmFyIF9hOyByZXR1cm4gKChfYSA9IGdldFN5bWJvbENvbG9yKGNsYXNzQnJlYWtJbmZvLnN5bWJvbCkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jbG9uZSgpKSB8fCBuZXcgbW9kdWxlcy5lc3JpQ29sb3IoWzAsIDAsIDAsIDBdKTsgfSk7XG4gICAgaWYgKGN1cnJlbnRDb2xvcnMubGVuZ3RoID4gMTApIHtcbiAgICAgICAgLy8gc29tZSByYW1wcyBoYXZlIG9ubHkgMTAgY29sb3JzXG4gICAgICAgIGN1cnJlbnRDb2xvcnMgPSBjdXJyZW50Q29sb3JzLnNsaWNlKDAsIDEwKTtcbiAgICB9XG4gICAgY3VycmVudENvbG9ycy5yZXZlcnNlKCk7XG4gICAgbGV0IGxhc3RTeW1ib2w7XG4gICAgbGV0IHN5bWJvbCA9ICgoX2EgPSByZW5kZXJlci5jbGFzc0JyZWFrSW5mb3MpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5sZW5ndGgpID8gcmVuZGVyZXIuY2xhc3NCcmVha0luZm9zWzBdLnN5bWJvbCA6IGdldERlZmF1bHRTeW1ib2wobGF5ZXIsIG1hcFZpZXcpO1xuICAgIGlmICghaXNTdXBwb3J0ZWRTeW1ib2woc3ltYm9sKSB8fCAoKCFpc0Fib3ZlQW5kQmVsb3cgfHwgaXNBYm92ZUFuZEJlbG93U2luZ2xlKSAmJiAhaXNDb2xvcmVkU3ltYm9sKHN5bWJvbCkpKSB7XG4gICAgICAgIGNvbnN0IHNpemUgPSAoX2IgPSBnZXRTeW1ib2xTaXplKHN5bWJvbCkpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IHN5bWJvbC53aWR0aDtcbiAgICAgICAgc3ltYm9sID0gZ2V0RGVmYXVsdFN5bWJvbChsYXllciwgbWFwVmlldywgcmVuZGVyZXJUeXBlKTtcbiAgICAgICAgYXBwbHlTeW1ib2xTaXplKHN5bWJvbCwgc2l6ZSk7XG4gICAgfVxuICAgIGNvbnN0IGZpbGxFbmFibGVkID0gaXNBYm92ZUFuZEJlbG93ICYmXG4gICAgICAgICFjb2xvclZpc1ZhciAmJlxuICAgICAgICBzeW1ib2wudHlwZSA9PT0gXCJwaWN0dXJlLW1hcmtlclwiICYmXG4gICAgICAgICgoX2MgPSByZW5kZXJlci5jbGFzc0JyZWFrSW5mb3NbMV0uc3ltYm9sKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MudHlwZSkgPT09IFwicGljdHVyZS1tYXJrZXJcIlxuICAgICAgICA/IGZhbHNlXG4gICAgICAgIDogdHJ1ZTtcbiAgICBjb25zdCBzdHJva2VFbmFibGVkID0gaGFzU3ltYm9sT3V0bGluZShzeW1ib2wpO1xuICAgIGNvbnN0IGlzUG9pbnRDSU0gPSBzeW1ib2wudHlwZSA9PT0gXCJjaW1cIiAmJiBzeW1ib2wuZGF0YS5zeW1ib2wudHlwZSA9PT0gXCJDSU1Qb2ludFN5bWJvbFwiO1xuICAgIGNvbnN0IGJhc2VtYXBUaGVtZSA9IChhd2FpdCBtb2R1bGVzLmNvbG9yVXRpbHMuZ2V0QmFja2dyb3VuZENvbG9yVGhlbWUobWFwVmlldykpO1xuICAgIGNvbnN0IHNjaGVtZXMgPSBtb2R1bGVzLmNvbG9yU2NoZW1lcy5nZXRTY2hlbWVzKHtcbiAgICAgICAgYmFzZW1hcFRoZW1lLFxuICAgICAgICBnZW9tZXRyeVR5cGU6IGdldEdlb21ldHJ5VHlwZShsYXllcikgfHwgZGVmYXVsdEdlb21ldHJ5LFxuICAgICAgICB0aGVtZTogKGF1dGhJbmZvID09PSBudWxsIHx8IGF1dGhJbmZvID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhdXRoSW5mby51bml2YXJpYXRlVGhlbWUpIHx8IChhdXRoQ29sb3JWaXNWYXIgPT09IG51bGwgfHwgYXV0aENvbG9yVmlzVmFyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhdXRoQ29sb3JWaXNWYXIudGhlbWUpIHx8IFwiaGlnaC10by1sb3dcIlxuICAgIH0pO1xuICAgIGlmICghY29sb3JWaXNWYXIpIHtcbiAgICAgICAgLy8gY2xhc3NlZFxuICAgICAgICBjb25zdCBtb3JlU2NoZW1lcyA9IG1vZHVsZXMuY29sb3JTY2hlbWVzLmdldFNjaGVtZXMoe1xuICAgICAgICAgICAgYmFzZW1hcDogbWFwVmlldy5tYXAuYmFzZW1hcCB8fCBcInRvcG9cIixcbiAgICAgICAgICAgIGdlb21ldHJ5VHlwZTogZ2V0R2VvbWV0cnlUeXBlKGxheWVyKSB8fCBkZWZhdWx0R2VvbWV0cnksXG4gICAgICAgICAgICB0aGVtZTogXCJhYm92ZS1hbmQtYmVsb3dcIlxuICAgICAgICB9KTtcbiAgICAgICAgc2NoZW1lcy5zZWNvbmRhcnlTY2hlbWVzLnB1c2gobW9yZVNjaGVtZXMucHJpbWFyeVNjaGVtZSk7XG4gICAgICAgIHNjaGVtZXMuc2Vjb25kYXJ5U2NoZW1lcyA9IHNjaGVtZXMuc2Vjb25kYXJ5U2NoZW1lcy5jb25jYXQobW9yZVNjaGVtZXMuc2Vjb25kYXJ5U2NoZW1lcyk7XG4gICAgfVxuICAgIC8vIFRPRE8gZ2V0IGN1cnJlbnQgc2NoZW1lXG4gICAgY29uc3QgbnVtID0gY29sb3JWaXNWYXIgPyAwIDogcmVuZGVyZXIuY2xhc3NCcmVha0luZm9zLmxlbmd0aDtcbiAgICBsZXQgY29sb3JSYW1wc0FuZFNjaGVtZXMgPSBnZXRDb2xvclJhbXBzV2l0aFNjaGVtZXMoc2NoZW1lcywgbnVtKTtcbiAgICAvLyBtaWdodCBoYXBwZW4gZm9yIGNsYXNzZWQgcmFtcHNcbiAgICBjb2xvclJhbXBzQW5kU2NoZW1lcyA9IGNvbG9yUmFtcHNBbmRTY2hlbWVzLmZpbHRlcigob2JqKSA9PiB7IHZhciBfYTsgcmV0dXJuIChfYSA9IG9iai5jb2xvcnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5sZW5ndGg7IH0pO1xuICAgIGNvbnN0IGNvbG9yUmFtcHMgPSBjb2xvclJhbXBzQW5kU2NoZW1lcy5tYXAoKG9iaikgPT4ge1xuICAgICAgICAvLyBmbGlwIHJhbXBzXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdG9wczogb2JqLmNvbG9ycy5yZXZlcnNlKCksXG4gICAgICAgICAgICB0YWdzOiBvYmouc2NoZW1lLnRhZ3MsXG4gICAgICAgICAgICBuYW1lOiBvYmouc2NoZW1lLm5hbWVcbiAgICAgICAgfTtcbiAgICB9KTtcbiAgICBjb25zdCBzdWdnZXN0ZWRTdHJva2VDb2xvcnMgPSBnZXRBbGxDb2xvcnNSZXZlcnNlZCgpO1xuICAgIGNvbnN0IG9uU3R5bGVyRWRpdCA9ICh7IGRldGFpbDogeyBzeW1ib2wsIGluZm86IHsgbWFya2VyLCBzdHJva2UsIGZpbGwgfSB9IH0pID0+IHtcbiAgICAgICAgY29uc3QgcmVuZGVyZXIgPSBnZXRSZW5kZXJlcihsYXllcik7XG4gICAgICAgIGNvbnN0IGNvbG9yVmlzVmFyID0gZ2V0VmlzVmFyKHJlbmRlcmVyLCBcImNvbG9yXCIpO1xuICAgICAgICBsZXQgY29sb3JzID0gbW9kdWxlcy5lc3JpTGFuZy5jbG9uZSgoZmlsbCB8fCBzdHJva2UpLmNvbG9yKTtcbiAgICAgICAgLy8gY3VycmVudENvbG9ycyBjb3VsZCBoYXZlIG1vcmUgY3VzdG9tIGNvbG9ycyB0aGFuIHRoZSByYW1wIGZyb20gc3R5bGVyXG4gICAgICAgIGNvbnN0IGNvbG9yMCA9IGN1cnJlbnRDb2xvcnNbMF07XG4gICAgICAgIGNvbnN0IGhhc0NvbG9yUmFtcENoYW5nZSA9IGN1cnJlbnRDb2xvcnMubGVuZ3RoICE9PSBjb2xvcnMubGVuZ3RoIHx8XG4gICAgICAgICAgICBjdXJyZW50Q29sb3JzLnNvbWUoKGNvbG9yLCBpZHgpID0+IGNvbG9yLnIgIT09IGNvbG9yc1tpZHhdLnIgfHwgY29sb3IuZyAhPT0gY29sb3JzW2lkeF0uZyB8fCBjb2xvci5iICE9PSBjb2xvcnNbaWR4XS5iKSB8fFxuICAgICAgICAgICAgY29sb3IwLnIgIT09IGNvbG9yc1swXS5yIHx8XG4gICAgICAgICAgICBjb2xvcjAuZyAhPT0gY29sb3JzWzBdLmcgfHxcbiAgICAgICAgICAgIGNvbG9yMC5iICE9PSBjb2xvcnNbMF0uYjtcbiAgICAgICAgY29uc3QgaGFzQWxwaGFDaGFuZ2UgPSBjb2xvcjAuYSAhPT0gY29sb3JzWzBdLmE7XG4gICAgICAgIGNvbnN0IG5ld0FscGhhID0gY29sb3JzWzBdLmE7XG4gICAgICAgIGNvbnN0IHN5bWJvbENoYW5nZUluZm8gPSBnZXRTeW1ib2xDaGFuZ2VzKHN5bWJvbCwgbGFzdFN5bWJvbCk7XG4gICAgICAgIGlmIChoYXNDb2xvclJhbXBDaGFuZ2UgJiYgIXN5bWJvbENoYW5nZUluZm8uYW55KSB7XG4gICAgICAgICAgICBzeW1ib2xDaGFuZ2VJbmZvLmFueSA9IHRydWU7XG4gICAgICAgICAgICBzeW1ib2xDaGFuZ2VJbmZvLmNvbG9yID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzVW5pdmFyaWF0ZSB8fCAhaXNBYm92ZUFuZEJlbG93KSB7XG4gICAgICAgICAgICBjb2xvcnMucmV2ZXJzZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNBYm92ZUFuZEJlbG93IHx8IGlzQWJvdmVBbmRCZWxvd1NpbmdsZSkge1xuICAgICAgICAgICAgaWYgKHN5bWJvbENoYW5nZUluZm8uYW55KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5mb3MgPSByZW5kZXJlci5jbGFzc0JyZWFrSW5mb3Muc2xpY2UoKTtcbiAgICAgICAgICAgICAgICBpbmZvcy5mb3JFYWNoKChjbGFzc0JyZWFrSW5mbywgaWR4KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNsYXNzQnJlYWtJbmZvLnN5bWJvbCA9IHVwZGF0ZVN5bWJvbChjbGFzc0JyZWFrSW5mby5zeW1ib2wsIHN5bWJvbCwgaGFzQ29sb3JSYW1wQ2hhbmdlICYmICFjb2xvclZpc1ZhclxuICAgICAgICAgICAgICAgICAgICAgICAgPyBjb2xvcnNbaWR4ICUgY29sb3JzLmxlbmd0aF1cbiAgICAgICAgICAgICAgICAgICAgICAgIDogaGFzQWxwaGFDaGFuZ2UgJiYgIWNvbG9yVmlzVmFyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBhcHBseUFscGhhKGdldFN5bWJvbENvbG9yKGNsYXNzQnJlYWtJbmZvLnN5bWJvbCksIG5ld0FscGhhKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogZ2V0U3ltYm9sQ29sb3IoY2xhc3NCcmVha0luZm8uc3ltYm9sKSB8fCBuZXcgbW9kdWxlcy5lc3JpQ29sb3IoWzAsIDAsIDAsIDBdKSwgc3ltYm9sQ2hhbmdlSW5mbyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmVuZGVyZXIuY2xhc3NCcmVha0luZm9zID0gaW5mb3M7XG4gICAgICAgICAgICB9IC8vIGVsc2UgbWF5YmUganVzdCBhbiBhdXRvIHNpemUgY2hhbmdlXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIWNvbG9yVmlzVmFyKSB7XG4gICAgICAgICAgICAvLyBzdHlsZXIgZG9lcyBub3Qgc2hvdyBtYXJrZXIgb3B0aW9uc1xuICAgICAgICAgICAgY29sb3JzLnJldmVyc2UoKTtcbiAgICAgICAgICAgIGNvbnN0IGluZm9zID0gcmVuZGVyZXIuY2xhc3NCcmVha0luZm9zLnNsaWNlKCk7XG4gICAgICAgICAgICBpbmZvcy5mb3JFYWNoKChjbGFzc0JyZWFrSW5mbywgaWR4KSA9PiB7XG4gICAgICAgICAgICAgICAgYXBwbHlTeW1ib2xDb2xvcihjbGFzc0JyZWFrSW5mby5zeW1ib2wsIGNvbG9yc1tpZHhdKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmVuZGVyZXIuY2xhc3NCcmVha0luZm9zID0gaW5mb3M7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbG9yVmlzVmFyKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudENvbG9ycy5sZW5ndGggIT09IGNvbG9ycy5sZW5ndGggJiYgY29sb3JzLmxlbmd0aCA9PT0gNSkge1xuICAgICAgICAgICAgICAgIC8vIGp1c3QgcGljayA1IHN0b3BzXG4gICAgICAgICAgICAgICAgY29uc3QgbGVuID0gY29sb3JWaXNWYXIuc3RvcHMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGNvbnN0IG5ld1N0b3BzID0gW107XG4gICAgICAgICAgICAgICAgbmV3U3RvcHNbMF0gPSBjb2xvclZpc1Zhci5zdG9wc1swXTtcbiAgICAgICAgICAgICAgICBuZXdTdG9wc1sxXSA9IGNvbG9yVmlzVmFyLnN0b3BzW01hdGguZmxvb3IobGVuIC8gNCldO1xuICAgICAgICAgICAgICAgIG5ld1N0b3BzWzJdID0gY29sb3JWaXNWYXIuc3RvcHNbTWF0aC5mbG9vcihsZW4gLyAyKV07XG4gICAgICAgICAgICAgICAgbmV3U3RvcHNbM10gPSBjb2xvclZpc1Zhci5zdG9wc1tsZW4gLSBNYXRoLmNlaWwobGVuIC8gNCldO1xuICAgICAgICAgICAgICAgIG5ld1N0b3BzWzRdID0gY29sb3JWaXNWYXIuc3RvcHNbbGVuIC0gMV07XG4gICAgICAgICAgICAgICAgY29sb3JWaXNWYXIuc3RvcHMgPSBuZXdTdG9wcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbG9yVmlzVmFyLnN0b3BzLmZvckVhY2goKHN0b3AsIGlkeCkgPT4ge1xuICAgICAgICAgICAgICAgIHN0b3AuY29sb3IgPSBjb2xvcnNbaWR4XTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgaW5mb3MgPSByZW5kZXJlci5jbGFzc0JyZWFrSW5mb3Muc2xpY2UoKTtcbiAgICAgICAgICAgIC8vIHdlIHdhbnQgdGhlIG9ubHkgYnJlYWsgc3ltYm9sIHRvIGFsd2F5cyBiZSBncmV5XG4gICAgICAgICAgICBhcHBseVN5bWJvbENvbG9yKGluZm9zWzBdLnN5bWJvbCwgbmV3IG1vZHVsZXMuZXNyaUNvbG9yKFsxNzAsIDE3MCwgMTcwLCAxXSkpO1xuICAgICAgICAgICAgcmVuZGVyZXIuY2xhc3NCcmVha0luZm9zID0gaW5mb3M7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc0NvbG9yU2l6ZSkge1xuICAgICAgICAgICAgdXBkYXRlQXV0b1Zpc1ZhcihzeW1ib2wsIG1hcmtlciA9PT0gbnVsbCB8fCBtYXJrZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG1hcmtlci5hdXRvQWRqdXN0ZWQsIHN0cm9rZSA9PT0gbnVsbCB8fCBzdHJva2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHN0cm9rZS5hdXRvQWRqdXN0ZWQsIHN5bWJvbFN0eWxlciwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvbkNoYW5nZSgpO1xuICAgICAgICB9XG4gICAgICAgIGxhc3RTeW1ib2wgPSBzeW1ib2wuY2xvbmUoKTtcbiAgICAgICAgY3VycmVudENvbG9ycyA9IGNvbG9yVmlzVmFyXG4gICAgICAgICAgICA/IGNvbG9yVmlzVmFyLnN0b3BzLm1hcCgoc3RvcCkgPT4gc3RvcC5jb2xvcilcbiAgICAgICAgICAgIDogcmVuZGVyZXIuY2xhc3NCcmVha0luZm9zXG4gICAgICAgICAgICAgICAgLm1hcCgoY2xhc3NCcmVha0luZm8pID0+IGdldFN5bWJvbENvbG9yKGNsYXNzQnJlYWtJbmZvLnN5bWJvbCkgfHwgbmV3IG1vZHVsZXMuZXNyaUNvbG9yKFswLCAwLCAwLCAwXSkpXG4gICAgICAgICAgICAgICAgLnJldmVyc2UoKTtcbiAgICB9O1xuICAgIGxldCBzdHJva2U7XG4gICAgaWYgKHN5bWJvbC50eXBlID09PSBcInNpbXBsZS1maWxsXCIpIHtcbiAgICAgICAgY29uc3Qgc3ltID0gc3ltYm9sO1xuICAgICAgICBpZiAoc3ltLm91dGxpbmUpIHtcbiAgICAgICAgICAgIHN0cm9rZSA9IHtcbiAgICAgICAgICAgICAgICBjb2xvcjogc3ltLm91dGxpbmUuY29sb3IgPyBzeW0ub3V0bGluZS5jb2xvciA6IG5ldyBtb2R1bGVzLmVzcmlDb2xvcihbMCwgMCwgMCwgMC41XSksXG4gICAgICAgICAgICAgICAgc2l6ZTogc3ltLm91dGxpbmUud2lkdGgsXG4gICAgICAgICAgICAgICAgc3R5bGU6IHN5bS5vdXRsaW5lLnN0eWxlLFxuICAgICAgICAgICAgICAgIGF1dG9BZGp1c3RlZDogISFzaXplT3V0bGluZVZpc1ZhclxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN0cm9rZSA9IHtcbiAgICAgICAgICAgICAgICBjb2xvcjogbmV3IG1vZHVsZXMuZXNyaUNvbG9yKFswLCAwLCAwLCAwLjVdKSxcbiAgICAgICAgICAgICAgICBzaXplOiAxLFxuICAgICAgICAgICAgICAgIHN0eWxlOiBcInNvbGlkXCIsXG4gICAgICAgICAgICAgICAgYXV0b0FkanVzdGVkOiAhIXNpemVPdXRsaW5lVmlzVmFyXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKHN5bWJvbC50eXBlID09PSBcInNpbXBsZS1tYXJrZXJcIikge1xuICAgICAgICBjb25zdCBzeW0gPSBzeW1ib2w7XG4gICAgICAgIGlmIChzeW0ub3V0bGluZSkge1xuICAgICAgICAgICAgc3Ryb2tlID0ge1xuICAgICAgICAgICAgICAgIGNvbG9yOiBzeW0ub3V0bGluZS5jb2xvciA/IHN5bS5vdXRsaW5lLmNvbG9yIDogbmV3IG1vZHVsZXMuZXNyaUNvbG9yKFswLCAwLCAwLCAwLjVdKSxcbiAgICAgICAgICAgICAgICBzaXplOiBzeW0ub3V0bGluZS53aWR0aFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN0cm9rZSA9IHtcbiAgICAgICAgICAgICAgICBjb2xvcjogbmV3IG1vZHVsZXMuZXNyaUNvbG9yKFswLCAwLCAwLCAwLjVdKSxcbiAgICAgICAgICAgICAgICBzaXplOiAxXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKHN5bWJvbC50eXBlID09PSBcImNpbVwiKSB7XG4gICAgICAgIHN0cm9rZSA9IGdldENpbUxpbmVQcm9wcyhzeW1ib2wpO1xuICAgICAgICBpZiAoaXNMaW5lKSB7XG4gICAgICAgICAgICAoc3Ryb2tlLnNpemUgPSBzaXplQXV0b1Zpc1ZhciA/IGdldFNpemVCeVNjYWxlKHNpemVBdXRvVmlzVmFyLCBtYXBWaWV3LnNjYWxlKSA6IHN0cm9rZS5zaXplKSxcbiAgICAgICAgICAgICAgICAoc3Ryb2tlLmF1dG9BZGp1c3RlZCA9ICEhc2l6ZUF1dG9WaXNWYXIpO1xuICAgICAgICAgICAgaWYgKHNpemVBdXRvVmlzVmFyKSB7XG4gICAgICAgICAgICAgICAgLy8gYWRqdXN0cyBzeW1ib2wgc28gYWxsIHN5bWJvbCBsYXllcnMgZml0XG4gICAgICAgICAgICAgICAgYXBwbHlTeW1ib2xTaXplKHN5bWJvbCwgc3Ryb2tlLnNpemUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKHN5bWJvbC50eXBlID09PSBcInNpbXBsZS1saW5lXCIpIHtcbiAgICAgICAgY29uc3Qgc3ltID0gc3ltYm9sO1xuICAgICAgICBzdHJva2UgPSB7XG4gICAgICAgICAgICBjb2xvcjogbmV3IG1vZHVsZXMuZXNyaUNvbG9yKFsyNTUsIDI1NSwgMjU1LCAwLjVdKSxcbiAgICAgICAgICAgIHNpemU6IHNpemVBdXRvVmlzVmFyID8gZ2V0U2l6ZUJ5U2NhbGUoc2l6ZUF1dG9WaXNWYXIsIG1hcFZpZXcuc2NhbGUpIDogc3ltLndpZHRoLFxuICAgICAgICAgICAgc3R5bGU6IHN5bS5zdHlsZSxcbiAgICAgICAgICAgIG1hcmtlcjogc3ltLm1hcmtlcixcbiAgICAgICAgICAgIGF1dG9BZGp1c3RlZDogISFzaXplQXV0b1Zpc1ZhclxuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgc3Ryb2tlID0ge1xuICAgICAgICAgICAgY29sb3I6IG5ldyBtb2R1bGVzLmVzcmlDb2xvcihbMjU1LCAyNTUsIDI1NSwgMC41XSksXG4gICAgICAgICAgICBzaXplOiAxXG4gICAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IHN5bWJvbFN0eWxlciA9IGF3YWl0IGNyZWF0ZVN5bWJvbFN0eWxlckVsZW1lbnQocG9wb3Zlck5vZGUpO1xuICAgIGxldCBlZGl0O1xuICAgIC8vIGFwcGx5IGEgZmV3IHNldHRpbmdzIHRvIHRoZSBzeW1ib2wgd2UgcGFzcyB0byB0aGUgc3R5bGVyXG4gICAgLy8gc28gd2hlbiBjb21wYXJpbmcgY2hhbmdlcyBpdCdzIGNvcnJlY3RcbiAgICBhcHBseVN5bWJvbENvbG9yKHN5bWJvbCwgY3VycmVudENvbG9yc1tjdXJyZW50Q29sb3JzLmxlbmd0aCAtIDFdKTtcbiAgICBpZiAoKGlzQ29sb3JTaXplIHx8IGlzUG9pbnQgfHwgaXNMaW5lKSAmJiBzaXplQXV0b1Zpc1Zhcikge1xuICAgICAgICBhcHBseVN5bWJvbFNpemUoc3ltYm9sLCBnZXRTaXplQnlTY2FsZShzaXplQXV0b1Zpc1ZhciwgbWFwVmlldy5zY2FsZSkpO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc1BvbHlnb24gJiYgc2l6ZUF1dG9WaXNWYXIgJiYgc3ltYm9sLm91dGxpbmUpIHtcbiAgICAgICAgc3ltYm9sLm91dGxpbmUud2lkdGggPSBnZXRTaXplQnlTY2FsZShzaXplQXV0b1Zpc1ZhciwgbWFwVmlldy5zY2FsZSk7XG4gICAgfVxuICAgIGxhc3RTeW1ib2wgPSBzeW1ib2wuY2xvbmUoKTtcbiAgICBpZiAoaXNMaW5lKSB7XG4gICAgICAgIGVkaXQgPSBzeW1ib2xTdHlsZXJFZGl0KHN5bWJvbFN0eWxlciwgbW9kdWxlcy5lc3JpTGFuZy5jbG9uZShzeW1ib2wpLCB7XG4gICAgICAgICAgICBwb3J0YWwsXG4gICAgICAgICAgICBzeW1ib2xGaWx0ZXI6ICFsYXllclN1cHBvcnRzQ0lNKCkgPyBcInNpbXBsZVwiIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgc2VjdGlvbnM6IHtcbiAgICAgICAgICAgICAgICBzdHJva2U6IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJjb2xvci1yYW1wXCIsXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlOiBjb2xvclZpc1ZhciA/IFwiY29udGludW91c1wiIDogXCJkaXNjcmV0ZVwiLFxuICAgICAgICAgICAgICAgICAgICBjb2xvclJhbXBzOiBjb2xvclJhbXBzLFxuICAgICAgICAgICAgICAgICAgICBvcGVuOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBjb2xvclJhbXBzT3BlbjogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgZXh0cmFQYXJ0czoge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU6IHN5bWJvbC50eXBlICE9PSBcImNpbVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXJyb3c6IHN5bWJvbC50eXBlICE9PSBcImNpbVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXV0b1N0cm9rZUFkanVzdDogIW1hcEltYWdlU3VibGF5ZXIgJiYgIWlzQ29sb3JTaXplID8gXCJlZGl0YWJsZVwiIDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogIWlzQ29sb3JTaXplXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHBhcnRzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBleHRyYTogIWlzQ29sb3JTaXplIHx8IHN5bWJvbC50eXBlICE9PSBcImNpbVwiXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc3Ryb2tlOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHN0cm9rZSksIHsgY29sb3I6IGN1cnJlbnRDb2xvcnMgfSlcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBlZGl0ID0gc3ltYm9sU3R5bGVyRWRpdChzeW1ib2xTdHlsZXIsICFpc0Fib3ZlQW5kQmVsb3cgfHwgaXNBYm92ZUFuZEJlbG93U2luZ2xlIC8qICYmIChpc0NvbG9yU2l6ZSB8fCBpc1BvaW50KSAqL1xuICAgICAgICAgICAgPyBtb2R1bGVzLmVzcmlMYW5nLmNsb25lKHN5bWJvbClcbiAgICAgICAgICAgIDogZ2V0RGVmYXVsdFN5bWJvbChsYXllciwgbWFwVmlldyksIHtcbiAgICAgICAgICAgIHBvcnRhbCxcbiAgICAgICAgICAgIHN5bWJvbEZpbHRlcjogaXNQb2x5Z29uICYmICFsYXllclN1cHBvcnRzQ0lNKCkgPyBcInNpbXBsZVwiIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgc2VjdGlvbnM6IHtcbiAgICAgICAgICAgICAgICBtYXJrZXI6ICghaXNBYm92ZUFuZEJlbG93IHx8IGlzQWJvdmVBbmRCZWxvd1NpbmdsZSkgJiZcbiAgICAgICAgICAgICAgICAgICAgKGlzUG9pbnRDSU0gfHwgW1wic2ltcGxlLW1hcmtlclwiLCBcInBpY3R1cmUtbWFya2VyXCJdLmluZGV4T2Yoc3ltYm9sLnR5cGUpID4gLTEpXG4gICAgICAgICAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3BlbjogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnRzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2l6ZTogIWlzQ29sb3JTaXplID8gKG1hcEltYWdlU3VibGF5ZXIgPyB0cnVlIDogeyBhdXRvU2l6ZUFkanVzdDogXCJlZGl0YWJsZVwiIH0pIDogZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBzeW1ib2xzT3BlbjogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpemVPcGVuOiAhaXNDb2xvclNpemUsXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXJrZXJUeXBlOiBsYXllclN1cHBvcnRzQ0lNKCkgPyBbXCJzaW1wbGVcIiwgXCJjaW06dmVjdG9yXCJdIDogW1wic2ltcGxlXCJdXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgOiBpc0Fib3ZlQW5kQmVsb3cgJiYgIWlzQWJvdmVBbmRCZWxvd1NpbmdsZVxuICAgICAgICAgICAgICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFydHM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJldmlldzogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvdGF0aW9uOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2l6ZTogZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBmaWxsOiB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiY29sb3ItcmFtcFwiLFxuICAgICAgICAgICAgICAgICAgICBzdHlsZTogY29sb3JWaXNWYXIgPyBcImNvbnRpbnVvdXNcIiA6IFwiZGlzY3JldGVcIixcbiAgICAgICAgICAgICAgICAgICAgb3BlbjogaXNMaW5lTWFya2VyKHN5bWJvbCkgPyBmYWxzZSA6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGNvbG9yUmFtcHNPcGVuOiBpc0xpbmVNYXJrZXIoc3ltYm9sKSA/IGZhbHNlIDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgY29sb3JSYW1wc1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc3Ryb2tlOiAhaXNBYm92ZUFuZEJlbG93IHx8IGlzQWJvdmVBbmRCZWxvd1NpbmdsZVxuICAgICAgICAgICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiY29sb3JcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgb3BlbjogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAvL29wZW46IGlzTGluZU1hcmtlcihzeW1ib2wpID8gdHJ1ZSA6IGZhbHNlLCB3ZSBuZWVkIHRoZSByYW1wcyB0aGVyZS4uLlxuICAgICAgICAgICAgICAgICAgICAgICAgc3VnZ2VzdGVkQ29sb3JzOiBzdWdnZXN0ZWRTdHJva2VDb2xvcnMsXG4gICAgICAgICAgICAgICAgICAgICAgICAvL3N1Z2dlc3RlZENvbG9yc09wZW46IGlzTGluZU1hcmtlcihzeW1ib2wpID8gdHJ1ZSA6IGZhbHNlLCB3ZSBuZWVkIHRoZSByYW1wcyB0aGVyZS4uLlxuICAgICAgICAgICAgICAgICAgICAgICAgZXh0cmFQYXJ0czoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiBbXCJzaW1wbGUtbWFya2VyXCIsIFwicGljdHVyZS1tYXJrZXJcIiwgXCJjaW1cIl0uaW5kZXhPZihzeW1ib2wudHlwZSkgPT09IC0xLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF1dG9TdHJva2VBZGp1c3Q6ICFtYXBJbWFnZVN1YmxheWVyICYmIGlzUG9seWdvbiAmJiBzeW1ib2wudHlwZSAhPT0gXCJjaW1cIiAmJiAhaXNDb2xvclNpemUgPyBcImVkaXRhYmxlXCIgOiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZmlsbDoge1xuICAgICAgICAgICAgICAgIGNvbG9yOiBjdXJyZW50Q29sb3JzXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbWFya2VyOiAoIWlzQWJvdmVBbmRCZWxvdyB8fCBpc0Fib3ZlQW5kQmVsb3dTaW5nbGUpICYmIChpc0NvbG9yU2l6ZSB8fCBpc1BvaW50KVxuICAgICAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgICAgICBzaXplOiBzaXplQXV0b1Zpc1ZhciA/IGdldFNpemVCeVNjYWxlKHNpemVBdXRvVmlzVmFyLCBtYXBWaWV3LnNjYWxlKSA6IGdldFN5bWJvbFNpemUoc3ltYm9sKSxcbiAgICAgICAgICAgICAgICAgICAgYXV0b0FkanVzdGVkOiAhIXNpemVBdXRvVmlzVmFyXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgc3Ryb2tlLFxuICAgICAgICAgICAgc3Ryb2tlRW5hYmxlZCxcbiAgICAgICAgICAgIGZpbGxFbmFibGVkIC8vIGlmIGZhbHNlIGl0IGRvZXNuJ3Qgc2VlbSB0byBkbyBhbnl0aGluZ1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgc3ltYm9sU3R5bGVyLmFkZEV2ZW50TGlzdGVuZXIoXCJhcmNnaXNTeW1ib2xTdHlsZXJFZGl0XCIsIG9uU3R5bGVyRWRpdFdyYXBwZXIuYmluZChudWxsLCBvblN0eWxlckVkaXQpKTtcbiAgICBwb3BvdmVyTm9kZS5hZGRTdHlsZXIoc3ltYm9sU3R5bGVyKTtcbiAgICBhd2FpdCBlZGl0O1xuICAgIHJldHVybiBjcmVhdGVXYXRjaFNjYWxlSGFuZGxlKCgoX2QgPSByZW5kZXJlci5jbGFzc0JyZWFrSW5mb3MpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5sZW5ndGgpID8gcmVuZGVyZXIuY2xhc3NCcmVha0luZm9zWzBdLnN5bWJvbCA6IHVuZGVmaW5lZCwgc3ltYm9sU3R5bGVyLCAobmV3U2l6ZSkgPT4ge1xuICAgICAgICBpc1BvbHlnb24gJiYgc3ltYm9sLm91dGxpbmUgPyAoc3ltYm9sLm91dGxpbmUud2lkdGggPSBuZXdTaXplKSA6ICFpc1BvbHlnb24gJiYgYXBwbHlTeW1ib2xTaXplKHN5bWJvbCwgbmV3U2l6ZSk7XG4gICAgICAgIGxhc3RTeW1ib2wgPSBzeW1ib2wuY2xvbmUoKTtcbiAgICB9KTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGJ1aWxkU3ltYm9sU3R5bGVyRm9yVHlwZVJhbXAob3B0aW9ucykge1xuICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2U7XG4gICAgY29uc3QgeyBsYXllciwgbWFwSW1hZ2VTdWJsYXllciwgbWFwVmlldywgcG9ydGFsLCBtb2R1bGVzIH0gPSBzbWFydE1hcHBpbmdTdGF0ZTtcbiAgICBjb25zdCB7IG9uQ2hhbmdlLCBwb3BvdmVyTm9kZSB9ID0gb3B0aW9ucztcbiAgICBjb25zdCBpc1BvaW50ID0gaXNQb2ludFR5cGUobGF5ZXIpO1xuICAgIGNvbnN0IGlzTGluZSA9IGlzUG9seWxpbmVUeXBlKGxheWVyKTtcbiAgICBjb25zdCBpc1BvbHlnb24gPSBpc1BvbHlnb25UeXBlKGxheWVyKTtcbiAgICBjb25zdCByZW5kZXJlciA9IGdldFJlbmRlcmVyKGxheWVyKTtcbiAgICBjb25zdCByZW5kZXJlclR5cGUgPSBnZXRSZW5kZXJlclR5cGUoKTtcbiAgICBjb25zdCBpc1R5cGVTaXplID0gW1widHlwZS1zaXplXCIsIFwidHlwZS1zaXplLWFnZVwiXS5pbmRleE9mKHJlbmRlcmVyVHlwZSkgPiAtMTtcbiAgICBjb25zdCBzaXplQXV0b1Zpc1ZhciA9IGdldFZpc1ZhcihyZW5kZXJlciwgXCJzaXplXCIsIFwiYXV0b1wiKTtcbiAgICBjb25zdCBzaXplT3V0bGluZVZpc1ZhciA9IGdldFZpc1ZhcihyZW5kZXJlciwgXCJzaXplXCIsIFwib3V0bGluZVwiKTtcbiAgICBjb25zdCB1bmlxdWVWYWx1ZUdyb3VwcyA9IHJlbmRlcmVyLnVuaXF1ZVZhbHVlR3JvdXBzO1xuICAgIGxldCBsYXN0U3ltYm9sO1xuICAgIGxldCBjdXJyZW50Q29sb3JzID0gW107XG4gICAgY29uc3QgbGFzdEdyb3VwID0gdW5pcXVlVmFsdWVHcm91cHMubGVuZ3RoID8gdW5pcXVlVmFsdWVHcm91cHNbdW5pcXVlVmFsdWVHcm91cHMubGVuZ3RoIC0gMV0gOiB1bmRlZmluZWQ7XG4gICAgbGV0IGFscGhhID0gKCgoX2EgPSBsYXN0R3JvdXAgPT09IG51bGwgfHwgbGFzdEdyb3VwID09PSB2b2lkIDAgPyB2b2lkIDAgOiBsYXN0R3JvdXAuY2xhc3NlcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmxlbmd0aCkgJiYgKChfYiA9IGdldFN5bWJvbENvbG9yKGxhc3RHcm91cC5jbGFzc2VzW2xhc3RHcm91cC5jbGFzc2VzLmxlbmd0aCAtIDFdLnN5bWJvbCkpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hKSkgfHwgMTtcbiAgICB1bmlxdWVWYWx1ZUdyb3Vwcy5mb3JFYWNoKChncm91cCkgPT4gKGN1cnJlbnRDb2xvcnMgPSBjdXJyZW50Q29sb3JzLmNvbmNhdChncm91cC5jbGFzc2VzLm1hcCgodW5pcXVlVmFsdWVDbGFzcykgPT4gZ2V0U3ltYm9sQ29sb3IodW5pcXVlVmFsdWVDbGFzcy5zeW1ib2wpIHx8IG5ldyBtb2R1bGVzLmVzcmlDb2xvcihbMCwgMCwgMCwgYWxwaGFdKSAvLyBUT0RPIHBhbmVsIGRpc3BsYXlzIGNvbG9yIGZyb20gZGVmYXVsdCByYW1wLCBub3QgYmxhY2tcbiAgICApKSkpO1xuICAgIGN1cnJlbnRDb2xvcnMucmV2ZXJzZSgpO1xuICAgIGlmIChjdXJyZW50Q29sb3JzLmxlbmd0aCA+IDEwKSB7XG4gICAgICAgIC8vIHNvbWUgcmFtcHMgaGF2ZSBvbmx5IDEwIGNvbG9yc1xuICAgICAgICBjdXJyZW50Q29sb3JzID0gY3VycmVudENvbG9ycy5zbGljZSgwLCAxMCk7XG4gICAgfVxuICAgIGNvbnN0IHNjaGVtZXMgPSBtb2R1bGVzLnR5cGVTY2hlbWVzLmdldFNjaGVtZXMoe1xuICAgICAgICBiYXNlbWFwOiBtYXBWaWV3Lm1hcC5iYXNlbWFwLFxuICAgICAgICBnZW9tZXRyeVR5cGU6IGdldEdlb21ldHJ5VHlwZShsYXllcikgfHwgZGVmYXVsdEdlb21ldHJ5XG4gICAgfSk7XG4gICAgLy8gaXQgdGFrZXMgdGhlIGZpcnN0IHN5bWJvbCBhcyBhIHJlZmVyZW5jZVxuICAgIGxldCBzeW1ib2wgPSAoKF9jID0gcmVuZGVyZXIudW5pcXVlVmFsdWVHcm91cHMpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5sZW5ndGgpICYmIHJlbmRlcmVyLnVuaXF1ZVZhbHVlR3JvdXBzWzBdLmNsYXNzZXMubGVuZ3RoXG4gICAgICAgID8gbW9kdWxlcy5lc3JpTGFuZy5jbG9uZShyZW5kZXJlci51bmlxdWVWYWx1ZUdyb3Vwc1swXS5jbGFzc2VzWzBdLnN5bWJvbClcbiAgICAgICAgOiBnZXREZWZhdWx0U3ltYm9sKGxheWVyLCBtYXBWaWV3LCByZW5kZXJlclR5cGUpO1xuICAgIGlmICghaXNDb2xvcmVkU3ltYm9sKHN5bWJvbCkpIHtcbiAgICAgICAgY29uc3Qgc2l6ZSA9IChfZCA9IGdldFN5bWJvbFNpemUoc3ltYm9sKSkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogc3ltYm9sLndpZHRoO1xuICAgICAgICBzeW1ib2wgPSBnZXREZWZhdWx0U3ltYm9sKGxheWVyLCBtYXBWaWV3LCByZW5kZXJlclR5cGUpO1xuICAgICAgICBhcHBseVN5bWJvbFNpemUoc3ltYm9sLCBzaXplKTtcbiAgICB9XG4gICAgY29uc3Qgc3Ryb2tlRW5hYmxlZCA9IGhhc1N5bWJvbE91dGxpbmUoc3ltYm9sKTtcbiAgICBjb25zdCBpc1BvaW50Q0lNID0gc3ltYm9sLnR5cGUgPT09IFwiY2ltXCIgJiYgc3ltYm9sLmRhdGEuc3ltYm9sLnR5cGUgPT09IFwiQ0lNUG9pbnRTeW1ib2xcIjtcbiAgICAvLyBUT0RPIGdldCBjdXJyZW50IHNjaGVtZVxuICAgIGxldCBudW1DbGFzc2VzID0gMDtcbiAgICB1bmlxdWVWYWx1ZUdyb3Vwcy5mb3JFYWNoKChncm91cCkgPT4gKG51bUNsYXNzZXMgKz0gZ3JvdXAuY2xhc3Nlcy5sZW5ndGgpKTtcbiAgICBjb25zdCBjb2xvclJhbXBzQW5kU2NoZW1lcyA9IGdldENvbG9yUmFtcHNXaXRoU2NoZW1lcyhzY2hlbWVzLCBNYXRoLm1pbihudW1DbGFzc2VzLCAxMCkpO1xuICAgIGNvbnN0IGNvbG9yUmFtcHMgPSBjb2xvclJhbXBzQW5kU2NoZW1lcy5tYXAoKG9iaikgPT4ge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3RvcHM6IG9iai5jb2xvcnMucmV2ZXJzZSgpLFxuICAgICAgICAgICAgdGFnczogb2JqLnNjaGVtZS50YWdzLFxuICAgICAgICAgICAgbmFtZTogb2JqLnNjaGVtZS5uYW1lXG4gICAgICAgIH07XG4gICAgfSk7XG4gICAgY29uc3Qgc3VnZ2VzdGVkU3Ryb2tlQ29sb3JzID0gZ2V0QWxsQ29sb3JzUmV2ZXJzZWQoKTtcbiAgICBjb25zdCBvblN0eWxlckVkaXQgPSAoeyBkZXRhaWw6IHsgc3ltYm9sLCBpbmZvOiB7IG1hcmtlciwgc3Ryb2tlLCBmaWxsIH0gfSB9KSA9PiB7XG4gICAgICAgIGNvbnN0IGNvbG9ycyA9IG1vZHVsZXMuZXNyaUxhbmcuY2xvbmUoKGZpbGwgfHwgc3Ryb2tlKS5jb2xvcik7XG4gICAgICAgIC8vIGN1cnJlbnRDb2xvcnMgY291bGQgaGF2ZSBtb3JlIGN1c3RvbSBjb2xvcnMgdGhhbiB0aGUgcmFtcCBmcm9tIHN0eWxlclxuICAgICAgICBjb25zdCBjb2xvcjAgPSBjdXJyZW50Q29sb3JzWzBdO1xuICAgICAgICBjb25zdCBoYXNDb2xvclJhbXBDaGFuZ2UgPSBjdXJyZW50Q29sb3JzLmxlbmd0aCAhPT0gY29sb3JzLmxlbmd0aCB8fFxuICAgICAgICAgICAgY3VycmVudENvbG9ycy5zb21lKChjb2xvciwgaWR4KSA9PiBjb2xvci5yICE9PSBjb2xvcnNbaWR4XS5yIHx8IGNvbG9yLmcgIT09IGNvbG9yc1tpZHhdLmcgfHwgY29sb3IuYiAhPT0gY29sb3JzW2lkeF0uYikgfHxcbiAgICAgICAgICAgIGNvbG9yMC5yICE9PSBjb2xvcnNbMF0uciB8fFxuICAgICAgICAgICAgY29sb3IwLmcgIT09IGNvbG9yc1swXS5nIHx8XG4gICAgICAgICAgICBjb2xvcjAuYiAhPT0gY29sb3JzWzBdLmI7XG4gICAgICAgIGNvbnN0IGhhc0FscGhhQ2hhbmdlID0gY29sb3IwLmEgIT09IGNvbG9yc1swXS5hO1xuICAgICAgICBjb25zdCBuZXdBbHBoYSA9IGNvbG9yc1swXS5hO1xuICAgICAgICBjb2xvcnMucmV2ZXJzZSgpO1xuICAgICAgICBjb25zdCByZW5kZXJlciA9IGdldFJlbmRlcmVyKGxheWVyKTtcbiAgICAgICAgY29uc3Qgc3ltYm9sQ2hhbmdlSW5mbyA9IGdldFN5bWJvbENoYW5nZXMoc3ltYm9sLCBsYXN0U3ltYm9sKTtcbiAgICAgICAgaWYgKGhhc0NvbG9yUmFtcENoYW5nZSAmJiAhc3ltYm9sQ2hhbmdlSW5mby5hbnkpIHtcbiAgICAgICAgICAgIHN5bWJvbENoYW5nZUluZm8uYW55ID0gdHJ1ZTtcbiAgICAgICAgICAgIHN5bWJvbENoYW5nZUluZm8uY29sb3IgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzeW1ib2xDaGFuZ2VJbmZvLmFueSkge1xuICAgICAgICAgICAgY29uc3QgZ3JvdXBzID0gcmVuZGVyZXIudW5pcXVlVmFsdWVHcm91cHMuc2xpY2UoKTtcbiAgICAgICAgICAgIGxldCBjb3VudFByZXZDbGFzc2VzID0gMDtcbiAgICAgICAgICAgIGdyb3Vwcy5mb3JFYWNoKCh1bmlxdWVWYWx1ZUdyb3VwKSA9PiB7XG4gICAgICAgICAgICAgICAgdW5pcXVlVmFsdWVHcm91cC5jbGFzc2VzLmZvckVhY2goKHVuaXF1ZVZhbHVlQ2xhc3MsIGNsYXNzSWR4KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1bmlxdWVWYWx1ZUNsYXNzLnN5bWJvbC50eXBlID09PSBcInBpY3R1cmUtbWFya2VyXCIgJiYgKGhhc0NvbG9yUmFtcENoYW5nZSB8fCBoYXNBbHBoYUNoYW5nZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVuaXF1ZVZhbHVlQ2xhc3Muc3ltYm9sID0gbW9kdWxlcy5lc3JpTGFuZy5jbG9uZShzeW1ib2wpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXBwbHlTeW1ib2xDb2xvcih1bmlxdWVWYWx1ZUNsYXNzLnN5bWJvbCwgY29sb3JzWyhjb3VudFByZXZDbGFzc2VzICsgY2xhc3NJZHgpICUgY29sb3JzLmxlbmd0aF0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHVuaXF1ZVZhbHVlQ2xhc3Muc3ltYm9sID0gdXBkYXRlU3ltYm9sKHVuaXF1ZVZhbHVlQ2xhc3Muc3ltYm9sLCBzeW1ib2wsIGhhc0NvbG9yUmFtcENoYW5nZVxuICAgICAgICAgICAgICAgICAgICAgICAgPyBjb2xvcnNbKGNvdW50UHJldkNsYXNzZXMgKyBjbGFzc0lkeCkgJSBjb2xvcnMubGVuZ3RoXVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBoYXNBbHBoYUNoYW5nZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gYXBwbHlBbHBoYShnZXRTeW1ib2xDb2xvcih1bmlxdWVWYWx1ZUNsYXNzLnN5bWJvbCksIG5ld0FscGhhKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogZ2V0U3ltYm9sQ29sb3IodW5pcXVlVmFsdWVDbGFzcy5zeW1ib2wpIHx8IG5ldyBtb2R1bGVzLmVzcmlDb2xvcihbMCwgMCwgMCwgMF0pLCBzeW1ib2xDaGFuZ2VJbmZvKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjb3VudFByZXZDbGFzc2VzICs9IHVuaXF1ZVZhbHVlR3JvdXAuY2xhc3Nlcy5sZW5ndGg7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJlbmRlcmVyLnVuaXF1ZVZhbHVlR3JvdXBzID0gZ3JvdXBzO1xuICAgICAgICB9IC8vIGVsc2UgbWF5YmUganVzdCBhbiBhdXRvIHNpemUgY2hhbmdlXG4gICAgICAgIGlmICghaXNUeXBlU2l6ZSkge1xuICAgICAgICAgICAgdXBkYXRlQXV0b1Zpc1ZhcihzeW1ib2wsIG1hcmtlciA9PT0gbnVsbCB8fCBtYXJrZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG1hcmtlci5hdXRvQWRqdXN0ZWQsIHN0cm9rZSA9PT0gbnVsbCB8fCBzdHJva2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHN0cm9rZS5hdXRvQWRqdXN0ZWQsIHN5bWJvbFN0eWxlciwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvbkNoYW5nZSgpO1xuICAgICAgICB9XG4gICAgICAgIGxhc3RTeW1ib2wgPSBzeW1ib2wuY2xvbmUoKTtcbiAgICAgICAgaWYgKGhhc0NvbG9yUmFtcENoYW5nZSkge1xuICAgICAgICAgICAgY3VycmVudENvbG9ycyA9IFtdO1xuICAgICAgICAgICAgcmVuZGVyZXIudW5pcXVlVmFsdWVHcm91cHMuZm9yRWFjaCgoZ3JvdXApID0+IChjdXJyZW50Q29sb3JzID0gY3VycmVudENvbG9ycy5jb25jYXQoZ3JvdXAuY2xhc3Nlcy5tYXAoKHVuaXF1ZVZhbHVlQ2xhc3MpID0+IGdldFN5bWJvbENvbG9yKHVuaXF1ZVZhbHVlQ2xhc3Muc3ltYm9sKSB8fCBuZXcgbW9kdWxlcy5lc3JpQ29sb3IoWzAsIDAsIDAsIDBdKSkpKSk7XG4gICAgICAgICAgICBjdXJyZW50Q29sb3JzLnJldmVyc2UoKTtcbiAgICAgICAgICAgIGlmIChjdXJyZW50Q29sb3JzLmxlbmd0aCA+IDEwKSB7XG4gICAgICAgICAgICAgICAgLy8gc29tZSByYW1wcyBoYXZlIG9ubHkgMTAgY29sb3JzXG4gICAgICAgICAgICAgICAgY3VycmVudENvbG9ycyA9IGN1cnJlbnRDb2xvcnMuc2xpY2UoMCwgMTApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBsZXQgc3Ryb2tlO1xuICAgIGlmIChzeW1ib2wudHlwZSA9PT0gXCJzaW1wbGUtZmlsbFwiKSB7XG4gICAgICAgIGNvbnN0IHN5bSA9IHN5bWJvbDtcbiAgICAgICAgaWYgKHN5bS5vdXRsaW5lKSB7XG4gICAgICAgICAgICBzdHJva2UgPSB7XG4gICAgICAgICAgICAgICAgY29sb3I6IHN5bS5vdXRsaW5lLmNvbG9yID8gc3ltLm91dGxpbmUuY29sb3IgOiBuZXcgbW9kdWxlcy5lc3JpQ29sb3IoWzAsIDAsIDAsIDAuNV0pLFxuICAgICAgICAgICAgICAgIHNpemU6IHN5bS5vdXRsaW5lLndpZHRoLFxuICAgICAgICAgICAgICAgIHN0eWxlOiBzeW0ub3V0bGluZS5zdHlsZSxcbiAgICAgICAgICAgICAgICBhdXRvQWRqdXN0ZWQ6ICEhc2l6ZU91dGxpbmVWaXNWYXJcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdHJva2UgPSB7XG4gICAgICAgICAgICAgICAgY29sb3I6IG5ldyBtb2R1bGVzLmVzcmlDb2xvcihbMCwgMCwgMCwgMC41XSksXG4gICAgICAgICAgICAgICAgc2l6ZTogMSxcbiAgICAgICAgICAgICAgICBzdHlsZTogXCJzb2xpZFwiLFxuICAgICAgICAgICAgICAgIGF1dG9BZGp1c3RlZDogISFzaXplT3V0bGluZVZpc1ZhclxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChzeW1ib2wudHlwZSA9PT0gXCJzaW1wbGUtbWFya2VyXCIpIHtcbiAgICAgICAgY29uc3Qgc3ltID0gc3ltYm9sO1xuICAgICAgICBpZiAoc3ltLm91dGxpbmUpIHtcbiAgICAgICAgICAgIHN0cm9rZSA9IHtcbiAgICAgICAgICAgICAgICBjb2xvcjogc3ltLm91dGxpbmUuY29sb3IgPyBzeW0ub3V0bGluZS5jb2xvciA6IG5ldyBtb2R1bGVzLmVzcmlDb2xvcihbMCwgMCwgMCwgMC41XSksXG4gICAgICAgICAgICAgICAgc2l6ZTogc3ltLm91dGxpbmUud2lkdGhcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdHJva2UgPSB7XG4gICAgICAgICAgICAgICAgY29sb3I6IG5ldyBtb2R1bGVzLmVzcmlDb2xvcihbMCwgMCwgMCwgMC41XSksXG4gICAgICAgICAgICAgICAgc2l6ZTogMVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChzeW1ib2wudHlwZSA9PT0gXCJjaW1cIikge1xuICAgICAgICBzdHJva2UgPSBnZXRDaW1MaW5lUHJvcHMoc3ltYm9sKTtcbiAgICAgICAgaWYgKGlzTGluZSkge1xuICAgICAgICAgICAgKHN0cm9rZS5zaXplID0gc2l6ZUF1dG9WaXNWYXIgPyBnZXRTaXplQnlTY2FsZShzaXplQXV0b1Zpc1ZhciwgbWFwVmlldy5zY2FsZSkgOiBzdHJva2Uuc2l6ZSksXG4gICAgICAgICAgICAgICAgKHN0cm9rZS5hdXRvQWRqdXN0ZWQgPSAhIXNpemVBdXRvVmlzVmFyKTtcbiAgICAgICAgICAgIGlmIChzaXplQXV0b1Zpc1Zhcikge1xuICAgICAgICAgICAgICAgIC8vIGFkanVzdHMgc3ltYm9sIHNvIGFsbCBzeW1ib2wgbGF5ZXJzIGZpdFxuICAgICAgICAgICAgICAgIGFwcGx5U3ltYm9sU2l6ZShzeW1ib2wsIHN0cm9rZS5zaXplKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChzeW1ib2wudHlwZSA9PT0gXCJzaW1wbGUtbGluZVwiKSB7XG4gICAgICAgIGNvbnN0IHN5bSA9IHN5bWJvbDtcbiAgICAgICAgc3Ryb2tlID0ge1xuICAgICAgICAgICAgY29sb3I6IGN1cnJlbnRDb2xvcnNbY3VycmVudENvbG9ycy5sZW5ndGggLSAxXSxcbiAgICAgICAgICAgIHNpemU6IHNpemVBdXRvVmlzVmFyID8gZ2V0U2l6ZUJ5U2NhbGUoc2l6ZUF1dG9WaXNWYXIsIG1hcFZpZXcuc2NhbGUpIDogc3ltLndpZHRoLFxuICAgICAgICAgICAgc3R5bGU6IHN5bS5zdHlsZSxcbiAgICAgICAgICAgIG1hcmtlcjogc3ltLm1hcmtlcixcbiAgICAgICAgICAgIGF1dG9BZGp1c3RlZDogISFzaXplQXV0b1Zpc1ZhclxuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgc3Ryb2tlID0ge1xuICAgICAgICAgICAgY29sb3I6IG5ldyBtb2R1bGVzLmVzcmlDb2xvcihbMjU1LCAyNTUsIDI1NSwgMC41XSksXG4gICAgICAgICAgICBzaXplOiAxXG4gICAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IHN5bWJvbFN0eWxlciA9IGF3YWl0IGNyZWF0ZVN5bWJvbFN0eWxlckVsZW1lbnQocG9wb3Zlck5vZGUpO1xuICAgIGxldCBlZGl0O1xuICAgIC8vIGFwcGx5IGEgZmV3IHNldHRpbmdzIHRvIHRoZSBzeW1ib2wgd2UgcGFzcyB0byB0aGUgc3R5bGVyXG4gICAgLy8gc28gd2hlbiBjb21wYXJpbmcgY2hhbmdlcyBpdCdzIGNvcnJlY3RcbiAgICBhcHBseVN5bWJvbENvbG9yKHN5bWJvbCwgY3VycmVudENvbG9yc1tjdXJyZW50Q29sb3JzLmxlbmd0aCAtIDFdKTtcbiAgICBpZiAoKGlzVHlwZVNpemUgfHwgaXNQb2ludCB8fCBpc0xpbmUpICYmIHNpemVBdXRvVmlzVmFyKSB7XG4gICAgICAgIGFwcGx5U3ltYm9sU2l6ZShzeW1ib2wsIGdldFNpemVCeVNjYWxlKHNpemVBdXRvVmlzVmFyLCBtYXBWaWV3LnNjYWxlKSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzUG9seWdvbiAmJiBzaXplQXV0b1Zpc1ZhciAmJiBzeW1ib2wub3V0bGluZSkge1xuICAgICAgICBzeW1ib2wub3V0bGluZS53aWR0aCA9IGdldFNpemVCeVNjYWxlKHNpemVBdXRvVmlzVmFyLCBtYXBWaWV3LnNjYWxlKTtcbiAgICB9XG4gICAgbGFzdFN5bWJvbCA9IHN5bWJvbC5jbG9uZSgpO1xuICAgIGlmIChpc0xpbmUpIHtcbiAgICAgICAgZWRpdCA9IHN5bWJvbFN0eWxlckVkaXQoc3ltYm9sU3R5bGVyLCBtb2R1bGVzLmVzcmlMYW5nLmNsb25lKHN5bWJvbCksIHtcbiAgICAgICAgICAgIHBvcnRhbCxcbiAgICAgICAgICAgIHN5bWJvbEZpbHRlcjogIWxheWVyU3VwcG9ydHNDSU0oKSA/IFwic2ltcGxlXCIgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBzZWN0aW9uczoge1xuICAgICAgICAgICAgICAgIHN0cm9rZToge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImNvbG9yLXJhbXBcIixcbiAgICAgICAgICAgICAgICAgICAgc3R5bGU6IFwiZGlzY3JldGVcIixcbiAgICAgICAgICAgICAgICAgICAgb3BlbjogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgY29sb3JSYW1wc09wZW46IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGNvbG9yUmFtcHMsXG4gICAgICAgICAgICAgICAgICAgIC8vc3VnZ2VzdGVkQ29sb3JzOiBzdWdnZXN0ZWRTdHJva2VDb2xvcnMsXG4gICAgICAgICAgICAgICAgICAgIGV4dHJhUGFydHM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiBzeW1ib2wudHlwZSAhPT0gXCJjaW1cIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGFycm93OiBzeW1ib2wudHlwZSAhPT0gXCJjaW1cIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGF1dG9TdHJva2VBZGp1c3Q6ICFtYXBJbWFnZVN1YmxheWVyICYmICFpc1R5cGVTaXplID8gXCJlZGl0YWJsZVwiIDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogIWlzVHlwZVNpemVcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgcGFydHM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4dHJhOiAhaXNUeXBlU2l6ZSB8fCBzeW1ib2wudHlwZSAhPT0gXCJjaW1cIlxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHN0cm9rZTogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBzdHJva2UpLCB7IGNvbG9yOiBjdXJyZW50Q29sb3JzIH0pXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZWRpdCA9IHN5bWJvbFN0eWxlckVkaXQoc3ltYm9sU3R5bGVyLCBtb2R1bGVzLmVzcmlMYW5nLmNsb25lKHN5bWJvbCksIHtcbiAgICAgICAgICAgIHBvcnRhbCxcbiAgICAgICAgICAgIHN5bWJvbEZpbHRlcjogaXNQb2x5Z29uICYmICFsYXllclN1cHBvcnRzQ0lNKCkgPyBcInNpbXBsZVwiIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgc2VjdGlvbnM6IHtcbiAgICAgICAgICAgICAgICBtYXJrZXI6IGlzUG9pbnRDSU0gfHwgW1wic2ltcGxlLW1hcmtlclwiLCBcInBpY3R1cmUtbWFya2VyXCJdLmluZGV4T2Yoc3ltYm9sLnR5cGUpID4gLTFcbiAgICAgICAgICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcGVuOiBpc0xpbmVNYXJrZXIoc3ltYm9sKSA/IHRydWUgOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnRzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2l6ZTogIWlzVHlwZVNpemUgPyAobWFwSW1hZ2VTdWJsYXllciA/IHRydWUgOiB7IGF1dG9TaXplQWRqdXN0OiBcImVkaXRhYmxlXCIgfSkgOiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN5bWJvbHNPcGVuOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2l6ZU9wZW46ICFpc1R5cGVTaXplLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWFya2VyVHlwZTogbGF5ZXJTdXBwb3J0c0NJTSgpID8gW1wic2ltcGxlXCIsIFwiY2ltOnZlY3RvclwiXSA6IFtcInNpbXBsZVwiXVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIGZpbGw6IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJjb2xvci1yYW1wXCIsXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlOiBcImRpc2NyZXRlXCIsXG4gICAgICAgICAgICAgICAgICAgIG9wZW46IGlzTGluZU1hcmtlcihzeW1ib2wpID8gZmFsc2UgOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBjb2xvclJhbXBzT3BlbjogaXNMaW5lTWFya2VyKHN5bWJvbCkgPyBmYWxzZSA6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGNvbG9yUmFtcHNcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHN0cm9rZToge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImNvbG9yXCIsXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBvcGVuOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgc3VnZ2VzdGVkQ29sb3JzOiBzdWdnZXN0ZWRTdHJva2VDb2xvcnMsXG4gICAgICAgICAgICAgICAgICAgIGV4dHJhUGFydHM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiBbXCJzaW1wbGUtbWFya2VyXCIsIFwicGljdHVyZS1tYXJrZXJcIiwgXCJjaW1cIl0uaW5kZXhPZihzeW1ib2wudHlwZSkgPT09IC0xLFxuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBhdXRvU3Ryb2tlQWRqdXN0OiAhbWFwSW1hZ2VTdWJsYXllciAmJiBpc1BvbHlnb24gJiYgc3ltYm9sLnR5cGUgIT09IFwiY2ltXCIgJiYgIWlzVHlwZVNpemUgPyBcImVkaXRhYmxlXCIgOiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZpbGw6IHtcbiAgICAgICAgICAgICAgICBjb2xvcjogY3VycmVudENvbG9yc1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG1hcmtlcjogaXNUeXBlU2l6ZSB8fCBpc1BvaW50XG4gICAgICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgICAgIHNpemU6IHNpemVBdXRvVmlzVmFyID8gZ2V0U2l6ZUJ5U2NhbGUoc2l6ZUF1dG9WaXNWYXIsIG1hcFZpZXcuc2NhbGUpIDogZ2V0U3ltYm9sU2l6ZShzeW1ib2wpLFxuICAgICAgICAgICAgICAgICAgICBhdXRvQWRqdXN0ZWQ6ICEhc2l6ZUF1dG9WaXNWYXJcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBzdHJva2UsXG4gICAgICAgICAgICBzdHJva2VFbmFibGVkXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzeW1ib2xTdHlsZXIuYWRkRXZlbnRMaXN0ZW5lcihcImFyY2dpc1N5bWJvbFN0eWxlckVkaXRcIiwgb25TdHlsZXJFZGl0V3JhcHBlci5iaW5kKG51bGwsIG9uU3R5bGVyRWRpdCkpO1xuICAgIHBvcG92ZXJOb2RlLmFkZFN0eWxlcihzeW1ib2xTdHlsZXIpO1xuICAgIGF3YWl0IGVkaXQ7XG4gICAgcmV0dXJuIGNyZWF0ZVdhdGNoU2NhbGVIYW5kbGUoKChfZSA9IHJlbmRlcmVyLnVuaXF1ZVZhbHVlR3JvdXBzKSA9PT0gbnVsbCB8fCBfZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2UubGVuZ3RoKSAmJiByZW5kZXJlci51bmlxdWVWYWx1ZUdyb3Vwc1swXS5jbGFzc2VzLmxlbmd0aFxuICAgICAgICA/IHJlbmRlcmVyLnVuaXF1ZVZhbHVlR3JvdXBzWzBdLmNsYXNzZXNbMF0uc3ltYm9sXG4gICAgICAgIDogdW5kZWZpbmVkLCBzeW1ib2xTdHlsZXIsIChuZXdTaXplKSA9PiB7XG4gICAgICAgIGlzUG9seWdvbiAmJiBzeW1ib2wub3V0bGluZSA/IChzeW1ib2wub3V0bGluZS53aWR0aCA9IG5ld1NpemUpIDogIWlzUG9seWdvbiAmJiBhcHBseVN5bWJvbFNpemUoc3ltYm9sLCBuZXdTaXplKTtcbiAgICAgICAgbGFzdFN5bWJvbCA9IHN5bWJvbC5jbG9uZSgpO1xuICAgIH0pO1xufVxuYXN5bmMgZnVuY3Rpb24gYnVpbGRTeW1ib2xTdHlsZXJGb3JUeXBlR3JvdXAob3B0aW9ucykge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCB7IGxheWVyLCBtYXBWaWV3LCBwb3J0YWwsIG1vZHVsZXMgfSA9IHNtYXJ0TWFwcGluZ1N0YXRlO1xuICAgIGNvbnN0IHsgZ3JvdXBJZHgsIG9uQ2hhbmdlLCBwb3BvdmVyTm9kZSB9ID0gb3B0aW9ucztcbiAgICBjb25zdCByZW5kZXJlciA9IGdldFJlbmRlcmVyKGxheWVyKTtcbiAgICBjb25zdCB1bmlxdWVWYWx1ZUdyb3VwcyA9IHJlbmRlcmVyLnVuaXF1ZVZhbHVlR3JvdXBzO1xuICAgIGNvbnN0IGdyb3VwID0gdW5pcXVlVmFsdWVHcm91cHNbZ3JvdXBJZHhdO1xuICAgIGxldCBhbHBoYSA9ICgoX2EgPSBnZXRTeW1ib2xDb2xvcihncm91cC5jbGFzc2VzW2dyb3VwLmNsYXNzZXMubGVuZ3RoIC0gMV0uc3ltYm9sKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmEpIHx8IDE7XG4gICAgbGV0IGN1cnJlbnRDb2xvcnMgPSBncm91cC5jbGFzc2VzLm1hcCgodW5pcXVlVmFsdWVDbGFzcykgPT4gZ2V0U3ltYm9sQ29sb3IodW5pcXVlVmFsdWVDbGFzcy5zeW1ib2wpIHx8IG5ldyBtb2R1bGVzLmVzcmlDb2xvcihbMCwgMCwgMCwgYWxwaGFdKSAvLyBUT0RPIHBhbmVsIGRpc3BsYXlzIGNvbG9yIGZyb20gZGVmYXVsdCByYW1wLCBub3QgYmxhY2tcbiAgICApO1xuICAgIGN1cnJlbnRDb2xvcnMucmV2ZXJzZSgpO1xuICAgIGlmIChjdXJyZW50Q29sb3JzLmxlbmd0aCA+IDEwKSB7XG4gICAgICAgIC8vIHNvbWUgcmFtcHMgaGF2ZSBvbmx5IDEwIGNvbG9yc1xuICAgICAgICBjdXJyZW50Q29sb3JzID0gY3VycmVudENvbG9ycy5zbGljZSgwLCAxMCk7XG4gICAgfVxuICAgIGNvbnN0IGJhc2VtYXBUaGVtZSA9IChhd2FpdCBtb2R1bGVzLmNvbG9yVXRpbHMuZ2V0QmFja2dyb3VuZENvbG9yVGhlbWUobWFwVmlldykpO1xuICAgIGNvbnN0IHNjaGVtZXMgPSBtb2R1bGVzLnR5cGVTY2hlbWVzLmdldFNjaGVtZXMoe1xuICAgICAgICBiYXNlbWFwVGhlbWUsXG4gICAgICAgIGdlb21ldHJ5VHlwZTogZ2V0R2VvbWV0cnlUeXBlKGxheWVyKSB8fCBkZWZhdWx0R2VvbWV0cnlcbiAgICB9KTtcbiAgICBjb25zdCBtb3JlU2NoZW1lcyA9IG1vZHVsZXMuY29sb3JTY2hlbWVzLmdldFNjaGVtZXMoe1xuICAgICAgICBiYXNlbWFwVGhlbWUsXG4gICAgICAgIGdlb21ldHJ5VHlwZTogZ2V0R2VvbWV0cnlUeXBlKGxheWVyKSB8fCBkZWZhdWx0R2VvbWV0cnksXG4gICAgICAgIHRoZW1lOiBcImhpZ2gtdG8tbG93XCJcbiAgICB9KTtcbiAgICAvLyBnZXQgbW9yZVNjaGVtZSBpbnRvIHRoZSB0eXBlcyBmb3JtYXRcbiAgICBtb3JlU2NoZW1lcy5wcmltYXJ5U2NoZW1lLmNvbG9ycyA9IG1vcmVTY2hlbWVzLnByaW1hcnlTY2hlbWUuY29sb3JzRm9yQ2xhc3NCcmVha3NbOV0uY29sb3JzO1xuICAgIG1vcmVTY2hlbWVzLnByaW1hcnlTY2hlbWUuY29sb3JzRm9yQ2xhc3NCcmVha3MgPSB1bmRlZmluZWQ7XG4gICAgbW9yZVNjaGVtZXMuc2Vjb25kYXJ5U2NoZW1lcyA9IG1vcmVTY2hlbWVzLnNlY29uZGFyeVNjaGVtZXMuZmlsdGVyKChzY2hlbWUpID0+IHsgdmFyIF9hOyByZXR1cm4gKChfYSA9IHNjaGVtZS5jb2xvcnNGb3JDbGFzc0JyZWFrcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmxlbmd0aCkgPj0gMTA7IH0pO1xuICAgIG1vcmVTY2hlbWVzLnNlY29uZGFyeVNjaGVtZXMuZm9yRWFjaCgoc2NoZW1lKSA9PiB7XG4gICAgICAgIHNjaGVtZS5jb2xvcnMgPSBzY2hlbWUuY29sb3JzRm9yQ2xhc3NCcmVha3NbOV0uY29sb3JzO1xuICAgICAgICBzY2hlbWUuY29sb3JzRm9yQ2xhc3NCcmVha3MgPSB1bmRlZmluZWQ7XG4gICAgfSk7XG4gICAgc2NoZW1lcy5zZWNvbmRhcnlTY2hlbWVzLnB1c2gobW9yZVNjaGVtZXMucHJpbWFyeVNjaGVtZSk7XG4gICAgc2NoZW1lcy5zZWNvbmRhcnlTY2hlbWVzID0gc2NoZW1lcy5zZWNvbmRhcnlTY2hlbWVzLmNvbmNhdChtb3JlU2NoZW1lcy5zZWNvbmRhcnlTY2hlbWVzKTtcbiAgICAvLyBUT0RPIGdldCBjdXJyZW50IHNjaGVtZVxuICAgIGxldCBudW1DbGFzc2VzID0gZ3JvdXAuY2xhc3Nlcy5sZW5ndGg7XG4gICAgY29uc3QgY29sb3JSYW1wc0FuZFNjaGVtZXMgPSBnZXRDb2xvclJhbXBzV2l0aFNjaGVtZXMoc2NoZW1lcywgTWF0aC5taW4obnVtQ2xhc3NlcywgMTApKTtcbiAgICBjb25zdCBjb2xvclJhbXBzID0gY29sb3JSYW1wc0FuZFNjaGVtZXMubWFwKChvYmopID0+IHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN0b3BzOiBvYmouY29sb3JzLnJldmVyc2UoKSxcbiAgICAgICAgICAgIHRhZ3M6IG9iai5zY2hlbWUudGFncyxcbiAgICAgICAgICAgIG5hbWU6IG9iai5zY2hlbWUubmFtZVxuICAgICAgICB9O1xuICAgIH0pO1xuICAgIGNvbnN0IG9uU3R5bGVyRWRpdCA9ICh7IGRldGFpbDogeyBcbiAgICAvL3N5bWJvbCxcbiAgICBpbmZvOiB7IGZpbGwgfSB9IH0pID0+IHtcbiAgICAgICAgY29uc3QgY29sb3JzID0gbW9kdWxlcy5lc3JpTGFuZy5jbG9uZShmaWxsLmNvbG9yKS5yZXZlcnNlKCk7XG4gICAgICAgIGNvbnN0IHJlbmRlcmVyID0gZ2V0UmVuZGVyZXIobGF5ZXIpO1xuICAgICAgICBjb25zdCByZW5kZXJlclR5cGUgPSBnZXRSZW5kZXJlclR5cGUoKTtcbiAgICAgICAgY29uc3QgZ3JvdXBzID0gcmVuZGVyZXIudW5pcXVlVmFsdWVHcm91cHMuc2xpY2UoKTtcbiAgICAgICAgZ3JvdXBzW2dyb3VwSWR4XS5jbGFzc2VzLmZvckVhY2goKHVuaXF1ZVZhbHVlQ2xhc3MsIGNsYXNzSWR4KSA9PiB7XG4gICAgICAgICAgICBpZiAodW5pcXVlVmFsdWVDbGFzcy5zeW1ib2wudHlwZSA9PT0gXCJwaWN0dXJlLW1hcmtlclwiKSB7XG4gICAgICAgICAgICAgICAgLy8gY2FuJ3Qga2VlcCBQTVNcbiAgICAgICAgICAgICAgICB1bmlxdWVWYWx1ZUNsYXNzLnN5bWJvbCA9IGdldERlZmF1bHRTeW1ib2wobGF5ZXIsIG1hcFZpZXcsIHJlbmRlcmVyVHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhcHBseVN5bWJvbENvbG9yKHVuaXF1ZVZhbHVlQ2xhc3Muc3ltYm9sLCBjb2xvcnNbY2xhc3NJZHggJSBjb2xvcnMubGVuZ3RoXSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZW5kZXJlci51bmlxdWVWYWx1ZUdyb3VwcyA9IGdyb3VwcztcbiAgICAgICAgb25DaGFuZ2UoKTtcbiAgICAgICAgY3VycmVudENvbG9ycyA9IHJlbmRlcmVyLnVuaXF1ZVZhbHVlR3JvdXBzW2dyb3VwSWR4XS5jbGFzc2VzLm1hcCgodW5pcXVlVmFsdWVDbGFzcykgPT4gZ2V0U3ltYm9sQ29sb3IodW5pcXVlVmFsdWVDbGFzcy5zeW1ib2wpKTtcbiAgICAgICAgY3VycmVudENvbG9ycy5yZXZlcnNlKCk7XG4gICAgICAgIGlmIChjdXJyZW50Q29sb3JzLmxlbmd0aCA+IDEwKSB7XG4gICAgICAgICAgICAvLyBzb21lIHJhbXBzIGhhdmUgb25seSAxMCBjb2xvcnNcbiAgICAgICAgICAgIGN1cnJlbnRDb2xvcnMgPSBjdXJyZW50Q29sb3JzLnNsaWNlKDAsIDEwKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgY29uc3Qgc3ltYm9sU3R5bGVyID0gYXdhaXQgY3JlYXRlU3ltYm9sU3R5bGVyRWxlbWVudChwb3BvdmVyTm9kZSk7XG4gICAgY29uc3QgZWRpdCA9IHN5bWJvbFN0eWxlckVkaXQoc3ltYm9sU3R5bGVyLCBuZXcgbW9kdWxlcy5TaW1wbGVGaWxsU3ltYm9sKCksIHtcbiAgICAgICAgcG9ydGFsLFxuICAgICAgICBzZWN0aW9uczoge1xuICAgICAgICAgICAgbWFya2VyOiB7XG4gICAgICAgICAgICAgICAgcGFydHM6IHtcbiAgICAgICAgICAgICAgICAgICAgcHJldmlldzogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIHJvdGF0aW9uOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgc2l6ZTogZmFsc2VcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZmlsbDoge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiY29sb3ItcmFtcFwiLFxuICAgICAgICAgICAgICAgIHN0eWxlOiBcImRpc2NyZXRlXCIsXG4gICAgICAgICAgICAgICAgb3BlbjogdHJ1ZSxcbiAgICAgICAgICAgICAgICBjb2xvclJhbXBzT3BlbjogdHJ1ZSxcbiAgICAgICAgICAgICAgICBjb2xvclJhbXBzLFxuICAgICAgICAgICAgICAgIHBhcnRzOiB7XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zcGFyZW5jeTogZmFsc2VcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGZpbGw6IHtcbiAgICAgICAgICAgIGNvbG9yOiBjdXJyZW50Q29sb3JzXG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBzeW1ib2xTdHlsZXIuYWRkRXZlbnRMaXN0ZW5lcihcImFyY2dpc1N5bWJvbFN0eWxlckVkaXRcIiwgb25TdHlsZXJFZGl0V3JhcHBlci5iaW5kKG51bGwsIG9uU3R5bGVyRWRpdCkpO1xuICAgIHBvcG92ZXJOb2RlLmFkZFN0eWxlcihzeW1ib2xTdHlsZXIpO1xuICAgIGF3YWl0IGVkaXQ7XG59XG5hc3luYyBmdW5jdGlvbiBidWlsZFN5bWJvbFN0eWxlckZvclR5cGVWYWx1ZShvcHRpb25zKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICBjb25zdCB7IGxheWVyLCBtYXBJbWFnZVN1YmxheWVyLCBtYXBWaWV3LCBsYXN0RGVmYXVsdCwgcG9ydGFsLCBtb2R1bGVzIH0gPSBzbWFydE1hcHBpbmdTdGF0ZTtcbiAgICBjb25zdCB7IG9uQ2hhbmdlLCBwb3BvdmVyTm9kZSwgc2VsZWN0ZWRWYWx1ZSB9ID0gb3B0aW9ucztcbiAgICBjb25zdCBbZ3JvdXBJZHgsIGNsYXNzSWR4XSA9ICFpc1Jhc3RlckxheWVyKGxheWVyKSAmJiBzZWxlY3RlZFZhbHVlLnNwbGl0KFwiL1wiKS5tYXAoKHZhbHVlKSA9PiBwYXJzZUludCh2YWx1ZSkpO1xuICAgIGNvbnN0IGlzUG9pbnQgPSBpc1BvaW50VHlwZShsYXllcik7XG4gICAgY29uc3QgaXNMaW5lID0gaXNQb2x5bGluZVR5cGUobGF5ZXIpO1xuICAgIGNvbnN0IGlzUG9seWdvbiA9IGlzUG9seWdvblR5cGUobGF5ZXIpO1xuICAgIGNvbnN0IHJlbmRlcmVyID0gZ2V0UmVuZGVyZXIobGF5ZXIpO1xuICAgIGNvbnN0IHJlbmRlcmVyVHlwZSA9IGdldFJlbmRlcmVyVHlwZSgpO1xuICAgIGNvbnN0IGlzVHlwZVNpemUgPSBbXCJ0eXBlLXNpemVcIiwgXCJ0eXBlLXNpemUtYWdlXCJdLmluZGV4T2YocmVuZGVyZXJUeXBlKSA+IC0xO1xuICAgIGNvbnN0IHNpemVBdXRvVmlzVmFyID0gZ2V0VmlzVmFyKHJlbmRlcmVyLCBcInNpemVcIiwgXCJhdXRvXCIpO1xuICAgIGNvbnN0IHNpemVPdXRsaW5lVmlzVmFyID0gZ2V0VmlzVmFyKHJlbmRlcmVyLCBcInNpemVcIiwgXCJvdXRsaW5lXCIpO1xuICAgIGxldCBzeW1ib2w7XG4gICAgaWYgKCghaXNSYXN0ZXJMYXllcihsYXllcikgJiYgZ3JvdXBJZHggPT09IC0xKSB8fCAoaXNSYXN0ZXJMYXllcihsYXllcikgJiYgc2VsZWN0ZWRWYWx1ZSA9PT0gLTEpKSB7XG4gICAgICAgIHN5bWJvbCA9IHJlbmRlcmVyLmRlZmF1bHRTeW1ib2wgfHwgbGFzdERlZmF1bHQuZGVmYXVsdFN5bWJvbDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmIChpc1Jhc3RlckxheWVyKGxheWVyKSkge1xuICAgICAgICAgICAgc3ltYm9sID0gcmVuZGVyZXIudW5pcXVlVmFsdWVJbmZvc1tzZWxlY3RlZFZhbHVlXS5zeW1ib2w7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzeW1ib2wgPSByZW5kZXJlci51bmlxdWVWYWx1ZUdyb3Vwc1tncm91cElkeF0uY2xhc3Nlc1tjbGFzc0lkeF0uc3ltYm9sO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICghaXNTdXBwb3J0ZWRTeW1ib2woc3ltYm9sKSkge1xuICAgICAgICBzeW1ib2wgPSBpc1Jhc3RlckxheWVyKGxheWVyKSA/IGdldFJhc3RlckRlZmF1bHRTeW1ib2woKSA6IGdldERlZmF1bHRTeW1ib2wobGF5ZXIsIG1hcFZpZXcsIHJlbmRlcmVyVHlwZSk7XG4gICAgICAgIGlmICgoKCFpc1Jhc3RlckxheWVyKGxheWVyKSAmJiBncm91cElkeCA9PT0gLTEpIHx8IChpc1Jhc3RlckxheWVyKGxheWVyKSAmJiBzZWxlY3RlZFZhbHVlID09PSAtMSkpICYmXG4gICAgICAgICAgICAhcmVuZGVyZXIuZGVmYXVsdFN5bWJvbCkge1xuICAgICAgICAgICAgbGFzdERlZmF1bHQuZGVmYXVsdFN5bWJvbCA9IHN5bWJvbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBmaWxsRW5hYmxlZCA9IHN5bWJvbC50eXBlID09PSBcInBpY3R1cmUtbWFya2VyXCIgPyBmYWxzZSA6ICEhc3ltYm9sLmNvbG9yO1xuICAgIGNvbnN0IHN0cm9rZUVuYWJsZWQgPSBoYXNTeW1ib2xPdXRsaW5lKHN5bWJvbCk7XG4gICAgY29uc3QgaXNQb2ludENJTSA9IHN5bWJvbC50eXBlID09PSBcImNpbVwiICYmIHN5bWJvbC5kYXRhLnN5bWJvbC50eXBlID09PSBcIkNJTVBvaW50U3ltYm9sXCI7XG4gICAgbGV0IHN1Z2dlc3RlZEZpbGxDb2xvcnM7XG4gICAgaWYgKCghaXNSYXN0ZXJMYXllcihsYXllcikgJiYgZ3JvdXBJZHggPT09IC0xKSB8fCAoaXNSYXN0ZXJMYXllcihsYXllcikgJiYgc2VsZWN0ZWRWYWx1ZSA9PT0gLTEpKSB7XG4gICAgICAgIHN1Z2dlc3RlZEZpbGxDb2xvcnMgPSBnZXRHcmV5Q29sb3JzKCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBzY2hlbWVzID0gbW9kdWxlcy50eXBlU2NoZW1lcy5nZXRTY2hlbWVzKHtcbiAgICAgICAgICAgIGJhc2VtYXA6IG1hcFZpZXcubWFwLmJhc2VtYXAsXG4gICAgICAgICAgICBnZW9tZXRyeVR5cGU6IGdldEdlb21ldHJ5VHlwZShsYXllcikgfHwgZGVmYXVsdEdlb21ldHJ5XG4gICAgICAgIH0pO1xuICAgICAgICBzdWdnZXN0ZWRGaWxsQ29sb3JzID0gZ2V0RmlsbENvbG9ycyhzY2hlbWVzKS5zbGljZSgwLCAxNik7XG4gICAgfVxuICAgIGNvbnN0IHN1Z2dlc3RlZFN0cm9rZUNvbG9ycyA9IGdldEFsbENvbG9yc1JldmVyc2VkKCk7XG4gICAgY29uc3Qgb25TdHlsZXJFZGl0ID0gKHsgZGV0YWlsOiB7IHN5bWJvbCwgaW5mbzogeyBtYXJrZXIsIHN0cm9rZSAvKiAsIGZpbGwgKi8gfSB9IH0pID0+IHtcbiAgICAgICAgY29uc3QgcmVuZGVyZXIgPSBnZXRSZW5kZXJlcihsYXllcik7XG4gICAgICAgIGlmICgoIWlzUmFzdGVyTGF5ZXIobGF5ZXIpICYmIGdyb3VwSWR4ID09PSAtMSkgfHwgKGlzUmFzdGVyTGF5ZXIobGF5ZXIpICYmIHNlbGVjdGVkVmFsdWUgPT09IC0xKSkge1xuICAgICAgICAgICAgcmVuZGVyZXIuZGVmYXVsdFN5bWJvbCA9IHN5bWJvbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChpc1Jhc3RlckxheWVyKGxheWVyKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGluZm9zID0gcmVuZGVyZXIudW5pcXVlVmFsdWVJbmZvcy5zbGljZSgpO1xuICAgICAgICAgICAgICAgIGluZm9zW3NlbGVjdGVkVmFsdWVdLnN5bWJvbCA9IHN5bWJvbDtcbiAgICAgICAgICAgICAgICByZW5kZXJlci51bmlxdWVWYWx1ZUluZm9zID0gaW5mb3M7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBncm91cHMgPSByZW5kZXJlci51bmlxdWVWYWx1ZUdyb3Vwcy5zbGljZSgpO1xuICAgICAgICAgICAgICAgIGdyb3Vwc1tncm91cElkeF0uY2xhc3Nlc1tjbGFzc0lkeF0uc3ltYm9sID0gc3ltYm9sO1xuICAgICAgICAgICAgICAgIHJlbmRlcmVyLnVuaXF1ZVZhbHVlR3JvdXBzID0gZ3JvdXBzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghaXNUeXBlU2l6ZSkge1xuICAgICAgICAgICAgdXBkYXRlQXV0b1Zpc1ZhcihzeW1ib2wsIG1hcmtlciA9PT0gbnVsbCB8fCBtYXJrZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG1hcmtlci5hdXRvQWRqdXN0ZWQsIHN0cm9rZSA9PT0gbnVsbCB8fCBzdHJva2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHN0cm9rZS5hdXRvQWRqdXN0ZWQsIHN5bWJvbFN0eWxlciwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvbkNoYW5nZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBsZXQgc3Ryb2tlO1xuICAgIGlmIChzeW1ib2wudHlwZSA9PT0gXCJzaW1wbGUtZmlsbFwiKSB7XG4gICAgICAgIGNvbnN0IHN5bSA9IHN5bWJvbDtcbiAgICAgICAgaWYgKHN5bS5vdXRsaW5lKSB7XG4gICAgICAgICAgICBzdHJva2UgPSB7XG4gICAgICAgICAgICAgICAgY29sb3I6IHN5bS5vdXRsaW5lLmNvbG9yID8gc3ltLm91dGxpbmUuY29sb3IgOiBuZXcgbW9kdWxlcy5lc3JpQ29sb3IoWzAsIDAsIDAsIDAuNV0pLFxuICAgICAgICAgICAgICAgIHNpemU6IHN5bS5vdXRsaW5lLndpZHRoLFxuICAgICAgICAgICAgICAgIHN0eWxlOiBzeW0ub3V0bGluZS5zdHlsZSxcbiAgICAgICAgICAgICAgICBhdXRvQWRqdXN0ZWQ6ICEhc2l6ZU91dGxpbmVWaXNWYXJcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdHJva2UgPSB7XG4gICAgICAgICAgICAgICAgY29sb3I6IG5ldyBtb2R1bGVzLmVzcmlDb2xvcihbMCwgMCwgMCwgMC41XSksXG4gICAgICAgICAgICAgICAgc2l6ZTogMSxcbiAgICAgICAgICAgICAgICBzdHlsZTogXCJzb2xpZFwiLFxuICAgICAgICAgICAgICAgIGF1dG9BZGp1c3RlZDogISFzaXplT3V0bGluZVZpc1ZhclxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChzeW1ib2wudHlwZSA9PT0gXCJzaW1wbGUtbWFya2VyXCIpIHtcbiAgICAgICAgY29uc3Qgc3ltID0gc3ltYm9sO1xuICAgICAgICBpZiAoc3ltLm91dGxpbmUpIHtcbiAgICAgICAgICAgIHN0cm9rZSA9IHtcbiAgICAgICAgICAgICAgICBjb2xvcjogc3ltLm91dGxpbmUuY29sb3IgPyBzeW0ub3V0bGluZS5jb2xvciA6IG5ldyBtb2R1bGVzLmVzcmlDb2xvcihbMCwgMCwgMCwgMC41XSksXG4gICAgICAgICAgICAgICAgc2l6ZTogc3ltLm91dGxpbmUud2lkdGhcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdHJva2UgPSB7XG4gICAgICAgICAgICAgICAgY29sb3I6IG5ldyBtb2R1bGVzLmVzcmlDb2xvcihbMCwgMCwgMCwgMC41XSksXG4gICAgICAgICAgICAgICAgc2l6ZTogMVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChzeW1ib2wudHlwZSA9PT0gXCJjaW1cIikge1xuICAgICAgICBzdHJva2UgPSBnZXRDaW1MaW5lUHJvcHMoc3ltYm9sKTtcbiAgICAgICAgaWYgKGlzTGluZSkge1xuICAgICAgICAgICAgKHN0cm9rZS5zaXplID0gc2l6ZUF1dG9WaXNWYXIgPyBnZXRTaXplQnlTY2FsZShzaXplQXV0b1Zpc1ZhciwgbWFwVmlldy5zY2FsZSkgOiBzdHJva2Uuc2l6ZSksXG4gICAgICAgICAgICAgICAgKHN0cm9rZS5hdXRvQWRqdXN0ZWQgPSAhIXNpemVBdXRvVmlzVmFyKTtcbiAgICAgICAgICAgIGlmIChzaXplQXV0b1Zpc1Zhcikge1xuICAgICAgICAgICAgICAgIC8vIGFkanVzdHMgc3ltYm9sIHNvIGFsbCBzeW1ib2wgbGF5ZXJzIGZpdFxuICAgICAgICAgICAgICAgIGFwcGx5U3ltYm9sU2l6ZShzeW1ib2wsIHN0cm9rZS5zaXplKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChzeW1ib2wudHlwZSA9PT0gXCJzaW1wbGUtbGluZVwiKSB7XG4gICAgICAgIGNvbnN0IHN5bSA9IHN5bWJvbDtcbiAgICAgICAgc3Ryb2tlID0ge1xuICAgICAgICAgICAgc2l6ZTogc2l6ZUF1dG9WaXNWYXIgPyBnZXRTaXplQnlTY2FsZShzaXplQXV0b1Zpc1ZhciwgbWFwVmlldy5zY2FsZSkgOiBzeW0ud2lkdGgsXG4gICAgICAgICAgICBzdHlsZTogc3ltLnN0eWxlLFxuICAgICAgICAgICAgbWFya2VyOiBzeW0ubWFya2VyLFxuICAgICAgICAgICAgY29sb3I6IHN5bS5jb2xvcixcbiAgICAgICAgICAgIGF1dG9BZGp1c3RlZDogISFzaXplQXV0b1Zpc1ZhclxuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgc3Ryb2tlID0ge1xuICAgICAgICAgICAgY29sb3I6IG5ldyBtb2R1bGVzLmVzcmlDb2xvcihbMjU1LCAyNTUsIDI1NSwgMC41XSksXG4gICAgICAgICAgICBzaXplOiAxXG4gICAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IHN5bWJvbFN0eWxlciA9IGF3YWl0IGNyZWF0ZVN5bWJvbFN0eWxlckVsZW1lbnQocG9wb3Zlck5vZGUpO1xuICAgIGxldCBlZGl0O1xuICAgIGlmIChpc0xpbmUpIHtcbiAgICAgICAgZWRpdCA9IHN5bWJvbFN0eWxlckVkaXQoc3ltYm9sU3R5bGVyLCBtb2R1bGVzLmVzcmlMYW5nLmNsb25lKHN5bWJvbCksIHtcbiAgICAgICAgICAgIHBvcnRhbCxcbiAgICAgICAgICAgIHN5bWJvbEZpbHRlcjogIWxheWVyU3VwcG9ydHNDSU0oKSA/IFwic2ltcGxlXCIgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBzZWN0aW9uczoge1xuICAgICAgICAgICAgICAgIHN0cm9rZToge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImNvbG9yXCIsXG4gICAgICAgICAgICAgICAgICAgIG9wZW46IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHN1Z2dlc3RlZENvbG9yc09wZW46IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHN1Z2dlc3RlZENvbG9yczogc3VnZ2VzdGVkRmlsbENvbG9ycyxcbiAgICAgICAgICAgICAgICAgICAgZXh0cmFQYXJ0czoge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU6IHN5bWJvbC50eXBlICE9PSBcImNpbVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXJyb3c6IHN5bWJvbC50eXBlICE9PSBcImNpbVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXV0b1N0cm9rZUFkanVzdDogIW1hcEltYWdlU3VibGF5ZXIgJiYgIWlzVHlwZVNpemUgPyBcImVkaXRhYmxlXCIgOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiAhaXNUeXBlU2l6ZVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBwYXJ0czoge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXh0cmE6ICFpc1R5cGVTaXplIHx8IHN5bWJvbC50eXBlICE9PSBcImNpbVwiXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc3Ryb2tlXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc1Jhc3RlckxheWVyKGxheWVyKSkge1xuICAgICAgICAvLyBqdXN0IG5lZWQgdGhlIGZpbGwgb3B0aW9uIGZvciByYXN0ZXIgbGF5ZXJzLiBPdGhlciBvcHRpb25zIGRvZXNudCBtYWtlIHNlbnNlIHdpdGggdGhlIGNvbnRleHRcbiAgICAgICAgZWRpdCA9IHN5bWJvbFN0eWxlckVkaXQoc3ltYm9sU3R5bGVyLCBtb2R1bGVzLmVzcmlMYW5nLmNsb25lKHN5bWJvbCksIHtcbiAgICAgICAgICAgIHBvcnRhbCxcbiAgICAgICAgICAgIHN5bWJvbEZpbHRlcjogXCJzaW1wbGVcIixcbiAgICAgICAgICAgIHNlY3Rpb25zOiB7XG4gICAgICAgICAgICAgICAgbWFya2VyOiB7XG4gICAgICAgICAgICAgICAgICAgIHBhcnRzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcmV2aWV3OiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvdGF0aW9uOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpemU6IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGZpbGw6IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJjb2xvclwiLFxuICAgICAgICAgICAgICAgICAgICBvcGVuOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgc3VnZ2VzdGVkQ29sb3JzT3BlbjogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgc3VnZ2VzdGVkQ29sb3JzOiBzdWdnZXN0ZWRGaWxsQ29sb3JzLFxuICAgICAgICAgICAgICAgICAgICBwYXJ0czoge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNwYXJlbmN5OiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZpbGw6IHtcbiAgICAgICAgICAgICAgICBjb2xvcjogZ2V0U3ltYm9sQ29sb3Ioc3ltYm9sKSB8fFxuICAgICAgICAgICAgICAgICAgICAoc2VsZWN0ZWRWYWx1ZSA9PT0gLTFcbiAgICAgICAgICAgICAgICAgICAgICAgID8gZ2V0UmFzdGVyRGVmYXVsdFN5bWJvbCgpLmNvbG9yXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGFkanVzdEFscGhhKHN1Z2dlc3RlZEZpbGxDb2xvcnNbc2VsZWN0ZWRWYWx1ZSAlIHN1Z2dlc3RlZEZpbGxDb2xvcnMubGVuZ3RoXSwgMC44NSkpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc3Ryb2tlLFxuICAgICAgICAgICAgZmlsbEVuYWJsZWRcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBlZGl0ID0gc3ltYm9sU3R5bGVyRWRpdChzeW1ib2xTdHlsZXIsIG1vZHVsZXMuZXNyaUxhbmcuY2xvbmUoc3ltYm9sKSwge1xuICAgICAgICAgICAgcG9ydGFsLFxuICAgICAgICAgICAgc3ltYm9sRmlsdGVyOiBpc1BvbHlnb24gJiYgIWxheWVyU3VwcG9ydHNDSU0oKSA/IFwic2ltcGxlXCIgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBzZWN0aW9uczoge1xuICAgICAgICAgICAgICAgIG1hcmtlcjogaXNQb2ludENJTSB8fCBbXCJzaW1wbGUtbWFya2VyXCIsIFwicGljdHVyZS1tYXJrZXJcIl0uaW5kZXhPZihzeW1ib2wudHlwZSkgPiAtMVxuICAgICAgICAgICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wZW46IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJ0czoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpemU6ICFpc1R5cGVTaXplID8gKG1hcEltYWdlU3VibGF5ZXIgPyB0cnVlIDogeyBhdXRvU2l6ZUFkanVzdDogXCJlZGl0YWJsZVwiIH0pIDogZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBzeW1ib2xzT3BlbjogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpemVPcGVuOiAhaXNUeXBlU2l6ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hcmtlclR5cGU6IGxheWVyU3VwcG9ydHNDSU0oKSA/IFwiYWxsXCIgOiBbXCJzaW1wbGVcIiwgXCJwaWN0dXJlXCJdXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgZmlsbDoge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImNvbG9yXCIsXG4gICAgICAgICAgICAgICAgICAgIG9wZW46IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBzdWdnZXN0ZWRDb2xvcnNPcGVuOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICB0cmFuc3BhcmVuY3lPcGVuOiBpc1BpY3R1cmVNYXJrZXIoc3ltYm9sKSxcbiAgICAgICAgICAgICAgICAgICAgc3VnZ2VzdGVkQ29sb3JzOiBzdWdnZXN0ZWRGaWxsQ29sb3JzXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzdHJva2U6IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJjb2xvclwiLFxuICAgICAgICAgICAgICAgICAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgc3VnZ2VzdGVkQ29sb3JzOiBzdWdnZXN0ZWRTdHJva2VDb2xvcnMsXG4gICAgICAgICAgICAgICAgICAgIGV4dHJhUGFydHM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiBbXCJzaW1wbGUtbWFya2VyXCIsIFwicGljdHVyZS1tYXJrZXJcIiwgXCJjaW1cIl0uaW5kZXhPZihzeW1ib2wudHlwZSkgPT09IC0xLFxuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBhdXRvU3Ryb2tlQWRqdXN0OiAhbWFwSW1hZ2VTdWJsYXllciAmJiBpc1BvbHlnb24gJiYgc3ltYm9sLnR5cGUgIT09IFwiY2ltXCIgJiYgIWlzVHlwZVNpemUgPyBcImVkaXRhYmxlXCIgOiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZpbGw6IHtcbiAgICAgICAgICAgICAgICBjb2xvcjogZ2V0U3ltYm9sQ29sb3Ioc3ltYm9sKSB8fCBhZGp1c3RBbHBoYShzdWdnZXN0ZWRGaWxsQ29sb3JzW2NsYXNzSWR4ICUgc3VnZ2VzdGVkRmlsbENvbG9ycy5sZW5ndGhdLCAwLjg1KVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG1hcmtlcjogaXNUeXBlU2l6ZSB8fCBpc1BvaW50XG4gICAgICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgICAgIHNpemU6IHNpemVBdXRvVmlzVmFyID8gZ2V0U2l6ZUJ5U2NhbGUoc2l6ZUF1dG9WaXNWYXIsIG1hcFZpZXcuc2NhbGUpIDogZ2V0U3ltYm9sU2l6ZShzeW1ib2wpLFxuICAgICAgICAgICAgICAgICAgICBhdXRvQWRqdXN0ZWQ6ICEhc2l6ZUF1dG9WaXNWYXJcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBzdHJva2UsXG4gICAgICAgICAgICBmaWxsRW5hYmxlZCxcbiAgICAgICAgICAgIHN0cm9rZUVuYWJsZWRcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHN5bWJvbFN0eWxlci5hZGRFdmVudExpc3RlbmVyKFwiYXJjZ2lzU3ltYm9sU3R5bGVyRWRpdFwiLCBvblN0eWxlckVkaXRXcmFwcGVyLmJpbmQobnVsbCwgb25TdHlsZXJFZGl0KSk7XG4gICAgcG9wb3Zlck5vZGUuYWRkU3R5bGVyKHN5bWJvbFN0eWxlcik7XG4gICAgYXdhaXQgZWRpdDtcbiAgICByZXR1cm4gY3JlYXRlV2F0Y2hTY2FsZUhhbmRsZShpc1Jhc3RlckxheWVyKGxheWVyKVxuICAgICAgICA/ICgoX2EgPSByZW5kZXJlci51bmlxdWVWYWx1ZUluZm9zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubGVuZ3RoKVxuICAgICAgICAgICAgPyByZW5kZXJlci51bmlxdWVWYWx1ZUluZm9zWzBdLnN5bWJvbFxuICAgICAgICAgICAgOiB1bmRlZmluZWRcbiAgICAgICAgOiAoKF9iID0gcmVuZGVyZXIudW5pcXVlVmFsdWVHcm91cHMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5sZW5ndGgpICYmIHJlbmRlcmVyLnVuaXF1ZVZhbHVlR3JvdXBzWzBdLmNsYXNzZXMubGVuZ3RoXG4gICAgICAgICAgICA/IHJlbmRlcmVyLnVuaXF1ZVZhbHVlR3JvdXBzWzBdLmNsYXNzZXNbMF0uc3ltYm9sXG4gICAgICAgICAgICA6IHVuZGVmaW5lZCwgc3ltYm9sU3R5bGVyKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGJ1aWxkU3ltYm9sU3R5bGVyRm9yUmVsYXRpb25zaGlwUmFtcChvcHRpb25zKSB7XG4gICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgY29uc3QgeyBsYXllciwgbWFwSW1hZ2VTdWJsYXllciwgbWFwVmlldywgcG9ydGFsLCBtb2R1bGVzIH0gPSBzbWFydE1hcHBpbmdTdGF0ZTtcbiAgICBjb25zdCB7IG9uQ2hhbmdlLCBwb3BvdmVyTm9kZSB9ID0gb3B0aW9ucztcbiAgICBjb25zdCBpc1BvaW50ID0gaXNQb2ludFR5cGUobGF5ZXIpO1xuICAgIGNvbnN0IGlzTGluZSA9IGlzUG9seWxpbmVUeXBlKGxheWVyKTtcbiAgICBjb25zdCBpc1BvbHlnb24gPSBpc1BvbHlnb25UeXBlKGxheWVyKTtcbiAgICBjb25zdCByZW5kZXJlciA9IGdldFJlbmRlcmVyKGxheWVyKTtcbiAgICBjb25zdCByZW5kZXJlclR5cGUgPSBnZXRSZW5kZXJlclR5cGUoKTtcbiAgICBjb25zdCBpc1JlbFNpemUgPSByZW5kZXJlclR5cGUgPT09IFwicmVsYXRpb25zaGlwLXNpemVcIjtcbiAgICBjb25zdCBzaXplQXV0b1Zpc1ZhciA9IGdldFZpc1ZhcihyZW5kZXJlciwgXCJzaXplXCIsIFwiYXV0b1wiKTtcbiAgICBjb25zdCBzaXplT3V0bGluZVZpc1ZhciA9IGdldFZpc1ZhcihyZW5kZXJlciwgXCJzaXplXCIsIFwib3V0bGluZVwiKTtcbiAgICBjb25zdCB1bmlxdWVWYWx1ZUNsYXNzZXMgPSByZW5kZXJlci51bmlxdWVWYWx1ZUdyb3Vwc1swXS5jbGFzc2VzO1xuICAgIGNvbnN0IGN1cnJlbnRDb2xvcnMgPSB1bmlxdWVWYWx1ZUNsYXNzZXMubWFwKCh1bmlxdWVWYWx1ZUNsYXNzKSA9PiBnZXRTeW1ib2xDb2xvcih1bmlxdWVWYWx1ZUNsYXNzLnN5bWJvbCkgfHwgbmV3IG1vZHVsZXMuZXNyaUNvbG9yKFswLCAwLCAwLCAwXSkpO1xuICAgIGNvbnN0IHNjaGVtZXMgPSBtb2R1bGVzLnJlbGF0aW9uc2hpcFNjaGVtZXMuZ2V0U2NoZW1lcyh7XG4gICAgICAgIGJhc2VtYXA6IG1hcFZpZXcubWFwLmJhc2VtYXAgfHwgXCJ0b3BvXCIsXG4gICAgICAgIGdlb21ldHJ5VHlwZTogZ2V0R2VvbWV0cnlUeXBlKGxheWVyKVxuICAgIH0pO1xuICAgIC8vIFRPRE8gZ2V0IGN1cnJlbnQgc2NoZW1lXG4gICAgLy8gaXQgdGFrZXMgdGhlIGZpcnN0IHN5bWJvbCBhcyBhIHJlZmVyZW5jZVxuICAgIGxldCBzeW1ib2wgPSAoKF9hID0gcmVuZGVyZXIudW5pcXVlVmFsdWVHcm91cHNbMF0uY2xhc3NlcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmxlbmd0aClcbiAgICAgICAgPyBtb2R1bGVzLmVzcmlMYW5nLmNsb25lKHJlbmRlcmVyLnVuaXF1ZVZhbHVlR3JvdXBzWzBdLmNsYXNzZXNbMF0uc3ltYm9sKVxuICAgICAgICA6IGdldERlZmF1bHRTeW1ib2wobGF5ZXIsIG1hcFZpZXcsIHJlbmRlcmVyVHlwZSk7XG4gICAgaWYgKCFpc0NvbG9yZWRTeW1ib2woc3ltYm9sKSkge1xuICAgICAgICBjb25zdCBzaXplID0gKF9iID0gZ2V0U3ltYm9sU2l6ZShzeW1ib2wpKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBzeW1ib2wud2lkdGg7XG4gICAgICAgIHN5bWJvbCA9IGdldERlZmF1bHRTeW1ib2wobGF5ZXIsIG1hcFZpZXcsIHJlbmRlcmVyVHlwZSk7XG4gICAgICAgIGFwcGx5U3ltYm9sU2l6ZShzeW1ib2wsIHNpemUpO1xuICAgIH1cbiAgICBjb25zdCBzdHJva2VFbmFibGVkID0gaGFzU3ltYm9sT3V0bGluZShzeW1ib2wpO1xuICAgIGNvbnN0IGlzUG9pbnRDSU0gPSBzeW1ib2wudHlwZSA9PT0gXCJjaW1cIiAmJiBzeW1ib2wuZGF0YS5zeW1ib2wudHlwZSA9PT0gXCJDSU1Qb2ludFN5bWJvbFwiO1xuICAgIC8vIFRPRE8gZ2V0IGN1cnJlbnQgc2NoZW1lXG4gICAgY29uc3QgY29sb3JSYW1wcyA9IGdldENvbG9yUmFtcHNXaXRoU2NoZW1lcyhzY2hlbWVzLCBNYXRoLnNxcnQodW5pcXVlVmFsdWVDbGFzc2VzLmxlbmd0aCkpLm1hcCgoeyBjb2xvcnM6IHN0b3BzLCBzY2hlbWU6IHsgdGFncywgbmFtZSB9IH0pID0+ICh7XG4gICAgICAgIHN0b3BzOiBtb2R1bGVzLnJlbGF0aW9uc2hpcFNjaGVtZXMuZmxhdHRlbjJEQXJyYXkoc3RvcHMpLFxuICAgICAgICB0YWdzLFxuICAgICAgICBuYW1lXG4gICAgfSkpO1xuICAgIGNvbnN0IHN1Z2dlc3RlZFN0cm9rZUNvbG9ycyA9IGdldEFsbENvbG9yc1JldmVyc2VkKCk7XG4gICAgY29uc3Qgb25TdHlsZXJFZGl0ID0gKHsgZGV0YWlsOiB7IHN5bWJvbCwgaW5mbzogeyBtYXJrZXIsIHN0cm9rZSwgZmlsbCB9IH0gfSkgPT4ge1xuICAgICAgICBjb25zdCBjb2xvcnMgPSBtb2R1bGVzLmVzcmlMYW5nLmNsb25lKChmaWxsIHx8IHN0cm9rZSkuY29sb3IpO1xuICAgICAgICBjb25zdCByZW5kZXJlciA9IGdldFJlbmRlcmVyKGxheWVyKTtcbiAgICAgICAgY29uc3QgY2xhc3NlcyA9IHJlbmRlcmVyLnVuaXF1ZVZhbHVlR3JvdXBzWzBdLmNsYXNzZXMuc2xpY2UoKTtcbiAgICAgICAgY2xhc3Nlcy5mb3JFYWNoKCh1bmlxdWVWYWx1ZUNsYXNzLCBpZHgpID0+IHtcbiAgICAgICAgICAgIHVuaXF1ZVZhbHVlQ2xhc3Muc3ltYm9sID0gc3ltYm9sLmNsb25lKCk7XG4gICAgICAgICAgICBhcHBseVN5bWJvbENvbG9yKHVuaXF1ZVZhbHVlQ2xhc3Muc3ltYm9sLCBjb2xvcnNbaWR4ICUgY29sb3JzLmxlbmd0aF0pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmVuZGVyZXIudW5pcXVlVmFsdWVHcm91cHNbMF0uY2xhc3NlcyA9IGNsYXNzZXM7XG4gICAgICAgIGlmICghaXNSZWxTaXplKSB7XG4gICAgICAgICAgICB1cGRhdGVBdXRvVmlzVmFyKHN5bWJvbCwgbWFya2VyID09PSBudWxsIHx8IG1hcmtlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogbWFya2VyLmF1dG9BZGp1c3RlZCwgc3Ryb2tlID09PSBudWxsIHx8IHN0cm9rZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogc3Ryb2tlLmF1dG9BZGp1c3RlZCwgc3ltYm9sU3R5bGVyLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9uQ2hhbmdlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGxldCBzdHJva2U7XG4gICAgaWYgKHN5bWJvbC50eXBlID09PSBcInNpbXBsZS1maWxsXCIpIHtcbiAgICAgICAgY29uc3Qgc3ltID0gc3ltYm9sO1xuICAgICAgICBpZiAoc3ltLm91dGxpbmUpIHtcbiAgICAgICAgICAgIHN0cm9rZSA9IHtcbiAgICAgICAgICAgICAgICBjb2xvcjogc3ltLm91dGxpbmUuY29sb3IgPyBzeW0ub3V0bGluZS5jb2xvciA6IG5ldyBtb2R1bGVzLmVzcmlDb2xvcihbMCwgMCwgMCwgMC41XSksXG4gICAgICAgICAgICAgICAgc2l6ZTogc3ltLm91dGxpbmUud2lkdGgsXG4gICAgICAgICAgICAgICAgc3R5bGU6IHN5bS5vdXRsaW5lLnN0eWxlLFxuICAgICAgICAgICAgICAgIGF1dG9BZGp1c3RlZDogISFzaXplT3V0bGluZVZpc1ZhclxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN0cm9rZSA9IHtcbiAgICAgICAgICAgICAgICBjb2xvcjogbmV3IG1vZHVsZXMuZXNyaUNvbG9yKFswLCAwLCAwLCAwLjVdKSxcbiAgICAgICAgICAgICAgICBzaXplOiAxLFxuICAgICAgICAgICAgICAgIHN0eWxlOiBcInNvbGlkXCIsXG4gICAgICAgICAgICAgICAgYXV0b0FkanVzdGVkOiAhIXNpemVPdXRsaW5lVmlzVmFyXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKHN5bWJvbC50eXBlID09PSBcInNpbXBsZS1tYXJrZXJcIikge1xuICAgICAgICBjb25zdCBzeW0gPSBzeW1ib2w7XG4gICAgICAgIGlmIChzeW0ub3V0bGluZSkge1xuICAgICAgICAgICAgc3Ryb2tlID0ge1xuICAgICAgICAgICAgICAgIGNvbG9yOiBzeW0ub3V0bGluZS5jb2xvciA/IHN5bS5vdXRsaW5lLmNvbG9yIDogbmV3IG1vZHVsZXMuZXNyaUNvbG9yKFswLCAwLCAwLCAwLjVdKSxcbiAgICAgICAgICAgICAgICBzaXplOiBzeW0ub3V0bGluZS53aWR0aFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN0cm9rZSA9IHtcbiAgICAgICAgICAgICAgICBjb2xvcjogbmV3IG1vZHVsZXMuZXNyaUNvbG9yKFswLCAwLCAwLCAwLjVdKSxcbiAgICAgICAgICAgICAgICBzaXplOiAxXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKHN5bWJvbC50eXBlID09PSBcImNpbVwiKSB7XG4gICAgICAgIHN0cm9rZSA9IGdldENpbUxpbmVQcm9wcyhzeW1ib2wpO1xuICAgICAgICBpZiAoaXNMaW5lKSB7XG4gICAgICAgICAgICAoc3Ryb2tlLnNpemUgPSBzaXplQXV0b1Zpc1ZhciA/IGdldFNpemVCeVNjYWxlKHNpemVBdXRvVmlzVmFyLCBtYXBWaWV3LnNjYWxlKSA6IHN0cm9rZS5zaXplKSxcbiAgICAgICAgICAgICAgICAoc3Ryb2tlLmF1dG9BZGp1c3RlZCA9ICEhc2l6ZUF1dG9WaXNWYXIpO1xuICAgICAgICAgICAgaWYgKHNpemVBdXRvVmlzVmFyKSB7XG4gICAgICAgICAgICAgICAgLy8gYWRqdXN0cyBzeW1ib2wgc28gYWxsIHN5bWJvbCBsYXllcnMgZml0XG4gICAgICAgICAgICAgICAgYXBwbHlTeW1ib2xTaXplKHN5bWJvbCwgc3Ryb2tlLnNpemUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKHN5bWJvbC50eXBlID09PSBcInNpbXBsZS1saW5lXCIpIHtcbiAgICAgICAgY29uc3Qgc3ltID0gc3ltYm9sO1xuICAgICAgICBzdHJva2UgPSB7XG4gICAgICAgICAgICBjb2xvcjogbmV3IG1vZHVsZXMuZXNyaUNvbG9yKFsyNTUsIDI1NSwgMjU1LCAwLjVdKSxcbiAgICAgICAgICAgIHNpemU6IHNpemVBdXRvVmlzVmFyID8gZ2V0U2l6ZUJ5U2NhbGUoc2l6ZUF1dG9WaXNWYXIsIG1hcFZpZXcuc2NhbGUpIDogc3ltLndpZHRoLFxuICAgICAgICAgICAgc3R5bGU6IHN5bS5zdHlsZSxcbiAgICAgICAgICAgIG1hcmtlcjogc3ltLm1hcmtlcixcbiAgICAgICAgICAgIGF1dG9BZGp1c3RlZDogISFzaXplQXV0b1Zpc1ZhclxuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgc3Ryb2tlID0ge1xuICAgICAgICAgICAgY29sb3I6IG5ldyBtb2R1bGVzLmVzcmlDb2xvcihbMjU1LCAyNTUsIDI1NSwgMC41XSksXG4gICAgICAgICAgICBzaXplOiAxXG4gICAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IHN5bWJvbFN0eWxlciA9IGF3YWl0IGNyZWF0ZVN5bWJvbFN0eWxlckVsZW1lbnQocG9wb3Zlck5vZGUpO1xuICAgIGxldCBlZGl0O1xuICAgIGlmIChpc0xpbmUpIHtcbiAgICAgICAgZWRpdCA9IHN5bWJvbFN0eWxlckVkaXQoc3ltYm9sU3R5bGVyLCBtb2R1bGVzLmVzcmlMYW5nLmNsb25lKHN5bWJvbCksIHtcbiAgICAgICAgICAgIHBvcnRhbCxcbiAgICAgICAgICAgIHN5bWJvbEZpbHRlcjogIWxheWVyU3VwcG9ydHNDSU0oKSA/IFwic2ltcGxlXCIgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBzZWN0aW9uczoge1xuICAgICAgICAgICAgICAgIHN0cm9rZToge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImNvbG9yLXJhbXBcIixcbiAgICAgICAgICAgICAgICAgICAgc3R5bGU6IFwiMmRcIixcbiAgICAgICAgICAgICAgICAgICAgb3BlbjogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgY29sb3JSYW1wc09wZW46IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGNvbG9yUmFtcHMsXG4gICAgICAgICAgICAgICAgICAgIC8vc3VnZ2VzdGVkQ29sb3JzOiBzdWdnZXN0ZWRTdHJva2VDb2xvcnMsXG4gICAgICAgICAgICAgICAgICAgIGV4dHJhUGFydHM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiBzeW1ib2wudHlwZSAhPT0gXCJjaW1cIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGFycm93OiBzeW1ib2wudHlwZSAhPT0gXCJjaW1cIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGF1dG9TdHJva2VBZGp1c3Q6ICFtYXBJbWFnZVN1YmxheWVyICYmICFpc1JlbFNpemUgPyBcImVkaXRhYmxlXCIgOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiAhaXNSZWxTaXplXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHBhcnRzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBleHRyYTogIWlzUmVsU2l6ZSB8fCBzeW1ib2wudHlwZSAhPT0gXCJjaW1cIlxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHN0cm9rZTogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBzdHJva2UpLCB7IGNvbG9yOiBjdXJyZW50Q29sb3JzIH0pXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZWRpdCA9IHN5bWJvbFN0eWxlckVkaXQoc3ltYm9sU3R5bGVyLCBtb2R1bGVzLmVzcmlMYW5nLmNsb25lKHN5bWJvbCksIHtcbiAgICAgICAgICAgIHBvcnRhbCxcbiAgICAgICAgICAgIHN5bWJvbEZpbHRlcjogaXNQb2x5Z29uICYmICFsYXllclN1cHBvcnRzQ0lNKCkgPyBcInNpbXBsZVwiIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgc2VjdGlvbnM6IHtcbiAgICAgICAgICAgICAgICBtYXJrZXI6IGlzUG9pbnRDSU0gfHwgW1wic2ltcGxlLW1hcmtlclwiLCBcInBpY3R1cmUtbWFya2VyXCJdLmluZGV4T2Yoc3ltYm9sLnR5cGUpID4gLTFcbiAgICAgICAgICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcGVuOiBpc0xpbmVNYXJrZXIoc3ltYm9sKSA/IHRydWUgOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnRzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2l6ZTogIWlzUmVsU2l6ZSA/IChtYXBJbWFnZVN1YmxheWVyID8gdHJ1ZSA6IHsgYXV0b1NpemVBZGp1c3Q6IFwiZWRpdGFibGVcIiB9KSA6IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgc3ltYm9sc09wZW46IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBzaXplT3BlbjogIWlzUmVsU2l6ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hcmtlclR5cGU6IGxheWVyU3VwcG9ydHNDSU0oKSA/IFtcInNpbXBsZVwiLCBcImNpbTp2ZWN0b3JcIl0gOiBbXCJzaW1wbGVcIl1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBmaWxsOiB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiY29sb3ItcmFtcFwiLFxuICAgICAgICAgICAgICAgICAgICBzdHlsZTogXCIyZFwiLFxuICAgICAgICAgICAgICAgICAgICBvcGVuOiBpc0xpbmVNYXJrZXIoc3ltYm9sKSA/IGZhbHNlIDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgY29sb3JSYW1wc09wZW46IGlzTGluZU1hcmtlcihzeW1ib2wpID8gZmFsc2UgOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBjb2xvclJhbXBzXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzdHJva2U6IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJjb2xvclwiLFxuICAgICAgICAgICAgICAgICAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgb3BlbjogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIHN1Z2dlc3RlZENvbG9yczogc3VnZ2VzdGVkU3Ryb2tlQ29sb3JzLFxuICAgICAgICAgICAgICAgICAgICBleHRyYVBhcnRzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZTogW1wic2ltcGxlLW1hcmtlclwiLCBcInBpY3R1cmUtbWFya2VyXCIsIFwiY2ltXCJdLmluZGV4T2Yoc3ltYm9sLnR5cGUpID09PSAtMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXV0b1N0cm9rZUFkanVzdDogIW1hcEltYWdlU3VibGF5ZXIgJiYgaXNQb2x5Z29uICYmIHN5bWJvbC50eXBlICE9PSBcImNpbVwiICYmICFpc1JlbFNpemUgPyBcImVkaXRhYmxlXCIgOiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZpbGw6IHtcbiAgICAgICAgICAgICAgICBjb2xvcjogY3VycmVudENvbG9yc1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG1hcmtlcjogaXNSZWxTaXplIHx8IGlzUG9pbnRcbiAgICAgICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICAgICAgc2l6ZTogc2l6ZUF1dG9WaXNWYXIgPyBnZXRTaXplQnlTY2FsZShzaXplQXV0b1Zpc1ZhciwgbWFwVmlldy5zY2FsZSkgOiBnZXRTeW1ib2xTaXplKHN5bWJvbCksXG4gICAgICAgICAgICAgICAgICAgIGF1dG9BZGp1c3RlZDogISFzaXplQXV0b1Zpc1ZhclxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHN0cm9rZSxcbiAgICAgICAgICAgIHN0cm9rZUVuYWJsZWRcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHN5bWJvbFN0eWxlci5hZGRFdmVudExpc3RlbmVyKFwiYXJjZ2lzU3ltYm9sU3R5bGVyRWRpdFwiLCBvblN0eWxlckVkaXRXcmFwcGVyLmJpbmQobnVsbCwgb25TdHlsZXJFZGl0KSk7XG4gICAgcG9wb3Zlck5vZGUuYWRkU3R5bGVyKHN5bWJvbFN0eWxlcik7XG4gICAgYXdhaXQgZWRpdDtcbiAgICByZXR1cm4gY3JlYXRlV2F0Y2hTY2FsZUhhbmRsZSgoKF9jID0gcmVuZGVyZXIudW5pcXVlVmFsdWVHcm91cHNbMF0uY2xhc3NlcykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmxlbmd0aCkgPyByZW5kZXJlci51bmlxdWVWYWx1ZUdyb3Vwc1swXS5jbGFzc2VzWzBdLnN5bWJvbCA6IHVuZGVmaW5lZCwgc3ltYm9sU3R5bGVyKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGJ1aWxkU3ltYm9sU3R5bGVyRm9yUHJlZG9taW5hbmNlUmFtcChvcHRpb25zKSB7XG4gICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgIGNvbnN0IHsgbGF5ZXIsIG1hcEltYWdlU3VibGF5ZXIsIG1hcFZpZXcsIHBvcnRhbCwgbW9kdWxlcyB9ID0gc21hcnRNYXBwaW5nU3RhdGU7XG4gICAgY29uc3QgeyBvbkNoYW5nZSwgcG9wb3Zlck5vZGUgfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgaXNQb2ludCA9IGlzUG9pbnRUeXBlKGxheWVyKTtcbiAgICBjb25zdCBpc0xpbmUgPSBpc1BvbHlsaW5lVHlwZShsYXllcik7XG4gICAgY29uc3QgaXNQb2x5Z29uID0gaXNQb2x5Z29uVHlwZShsYXllcik7XG4gICAgY29uc3QgcmVuZGVyZXIgPSBnZXRSZW5kZXJlcihsYXllcik7XG4gICAgY29uc3QgcmVuZGVyZXJUeXBlID0gZ2V0UmVuZGVyZXJUeXBlKCk7XG4gICAgY29uc3QgaXNQcmVkb21TaXplID0gcmVuZGVyZXJUeXBlID09PSBcInByZWRvbWluYW5jZS1zaXplXCI7XG4gICAgY29uc3Qgc2l6ZUF1dG9WaXNWYXIgPSBnZXRWaXNWYXIocmVuZGVyZXIsIFwic2l6ZVwiLCBcImF1dG9cIik7XG4gICAgY29uc3Qgc2l6ZU91dGxpbmVWaXNWYXIgPSBnZXRWaXNWYXIocmVuZGVyZXIsIFwic2l6ZVwiLCBcIm91dGxpbmVcIik7XG4gICAgY29uc3QgdW5pcXVlVmFsdWVDbGFzc2VzID0gcmVuZGVyZXIudW5pcXVlVmFsdWVHcm91cHNbMF0uY2xhc3NlcztcbiAgICBsZXQgbGFzdFN5bWJvbDtcbiAgICBsZXQgYWxwaGEgPSAodW5pcXVlVmFsdWVDbGFzc2VzLmxlbmd0aCAmJiAoKF9hID0gZ2V0U3ltYm9sQ29sb3IodW5pcXVlVmFsdWVDbGFzc2VzW3VuaXF1ZVZhbHVlQ2xhc3Nlcy5sZW5ndGggLSAxXS5zeW1ib2wpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYSkpIHx8IDE7XG4gICAgbGV0IGN1cnJlbnRDb2xvcnMgPSB1bmlxdWVWYWx1ZUNsYXNzZXMubWFwKCh1bmlxdWVWYWx1ZUNsYXNzKSA9PiBnZXRTeW1ib2xDb2xvcih1bmlxdWVWYWx1ZUNsYXNzLnN5bWJvbCkgfHwgbmV3IG1vZHVsZXMuZXNyaUNvbG9yKFswLCAwLCAwLCBhbHBoYV0pKTtcbiAgICBjdXJyZW50Q29sb3JzLnJldmVyc2UoKTtcbiAgICBjb25zdCBzY2hlbWVzID0gbW9kdWxlcy5wcmVkb21pbmFuY2VTY2hlbWVzLmdldFNjaGVtZXMoe1xuICAgICAgICBiYXNlbWFwOiBtYXBWaWV3Lm1hcC5iYXNlbWFwLFxuICAgICAgICBnZW9tZXRyeVR5cGU6IGdldEdlb21ldHJ5VHlwZShsYXllciksXG4gICAgICAgIG51bUNvbG9yczogdW5pcXVlVmFsdWVDbGFzc2VzLmxlbmd0aFxuICAgIH0pO1xuICAgIC8vIGl0IHRha2VzIHRoZSBmaXJzdCBzeW1ib2wgYXMgYSByZWZlcmVuY2VcbiAgICBsZXQgc3ltYm9sID0gKChfYiA9IHJlbmRlcmVyLnVuaXF1ZVZhbHVlR3JvdXBzWzBdLmNsYXNzZXMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5sZW5ndGgpXG4gICAgICAgID8gbW9kdWxlcy5lc3JpTGFuZy5jbG9uZShyZW5kZXJlci51bmlxdWVWYWx1ZUdyb3Vwc1swXS5jbGFzc2VzWzBdLnN5bWJvbClcbiAgICAgICAgOiBnZXREZWZhdWx0U3ltYm9sKGxheWVyLCBtYXBWaWV3LCByZW5kZXJlclR5cGUpO1xuICAgIGlmICghaXNDb2xvcmVkU3ltYm9sKHN5bWJvbCkpIHtcbiAgICAgICAgY29uc3Qgc2l6ZSA9IChfYyA9IGdldFN5bWJvbFNpemUoc3ltYm9sKSkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogc3ltYm9sLndpZHRoO1xuICAgICAgICBzeW1ib2wgPSBnZXREZWZhdWx0U3ltYm9sKGxheWVyLCBtYXBWaWV3LCByZW5kZXJlclR5cGUpO1xuICAgICAgICBhcHBseVN5bWJvbFNpemUoc3ltYm9sLCBzaXplKTtcbiAgICB9XG4gICAgY29uc3Qgc3Ryb2tlRW5hYmxlZCA9IGhhc1N5bWJvbE91dGxpbmUoc3ltYm9sKTtcbiAgICBjb25zdCBpc1BvaW50Q0lNID0gc3ltYm9sLnR5cGUgPT09IFwiY2ltXCIgJiYgc3ltYm9sLmRhdGEuc3ltYm9sLnR5cGUgPT09IFwiQ0lNUG9pbnRTeW1ib2xcIjtcbiAgICAvLyBUT0RPIGdldCBjdXJyZW50IHNjaGVtZVxuICAgIGNvbnN0IGNvbG9yUmFtcHNBbmRTY2hlbWVzID0gZ2V0Q29sb3JSYW1wc1dpdGhTY2hlbWVzKHNjaGVtZXMsIHVuaXF1ZVZhbHVlQ2xhc3Nlcy5sZW5ndGgpO1xuICAgIGNvbnN0IGNvbG9yUmFtcHMgPSBjb2xvclJhbXBzQW5kU2NoZW1lcy5tYXAoKG9iaikgPT4ge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3RvcHM6IG9iai5jb2xvcnMucmV2ZXJzZSgpLFxuICAgICAgICAgICAgdGFnczogb2JqLnNjaGVtZS50YWdzLFxuICAgICAgICAgICAgbmFtZTogb2JqLnNjaGVtZS5uYW1lXG4gICAgICAgIH07XG4gICAgfSk7XG4gICAgY29uc3Qgc3VnZ2VzdGVkU3Ryb2tlQ29sb3JzID0gZ2V0QWxsQ29sb3JzUmV2ZXJzZWQoKTtcbiAgICBjb25zdCBvblN0eWxlckVkaXQgPSAoeyBkZXRhaWw6IHsgc3ltYm9sLCBpbmZvOiB7IG1hcmtlciwgc3Ryb2tlLCBmaWxsIH0gfSB9KSA9PiB7XG4gICAgICAgIGNvbnN0IGNvbG9ycyA9IG1vZHVsZXMuZXNyaUxhbmcuY2xvbmUoKGZpbGwgfHwgc3Ryb2tlKS5jb2xvcik7XG4gICAgICAgIGNvbnN0IGNvbG9yMCA9IGN1cnJlbnRDb2xvcnNbMF07XG4gICAgICAgIGNvbnN0IGhhc0NvbG9yUmFtcENoYW5nZSA9IGN1cnJlbnRDb2xvcnMubGVuZ3RoICE9PSBjb2xvcnMubGVuZ3RoIHx8XG4gICAgICAgICAgICBjdXJyZW50Q29sb3JzLnNvbWUoKGNvbG9yLCBpZHgpID0+IGNvbG9yLnIgIT09IGNvbG9yc1tpZHhdLnIgfHwgY29sb3IuZyAhPT0gY29sb3JzW2lkeF0uZyB8fCBjb2xvci5iICE9PSBjb2xvcnNbaWR4XS5iKSB8fFxuICAgICAgICAgICAgY29sb3IwLnIgIT09IGNvbG9yc1swXS5yIHx8XG4gICAgICAgICAgICBjb2xvcjAuZyAhPT0gY29sb3JzWzBdLmcgfHxcbiAgICAgICAgICAgIGNvbG9yMC5iICE9PSBjb2xvcnNbMF0uYjtcbiAgICAgICAgY29uc3QgaGFzQWxwaGFDaGFuZ2UgPSBjb2xvcjAuYSAhPT0gY29sb3JzWzBdLmE7XG4gICAgICAgIGNvbnN0IG5ld0FscGhhID0gY29sb3JzWzBdLmE7XG4gICAgICAgIGNvbG9ycy5yZXZlcnNlKCk7XG4gICAgICAgIGNvbnN0IHJlbmRlcmVyID0gZ2V0UmVuZGVyZXIobGF5ZXIpO1xuICAgICAgICBjb25zdCBzeW1ib2xDaGFuZ2VJbmZvID0gZ2V0U3ltYm9sQ2hhbmdlcyhzeW1ib2wsIGxhc3RTeW1ib2wpO1xuICAgICAgICBpZiAoaGFzQ29sb3JSYW1wQ2hhbmdlICYmICFzeW1ib2xDaGFuZ2VJbmZvLmFueSkge1xuICAgICAgICAgICAgc3ltYm9sQ2hhbmdlSW5mby5hbnkgPSB0cnVlO1xuICAgICAgICAgICAgc3ltYm9sQ2hhbmdlSW5mby5jb2xvciA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN5bWJvbENoYW5nZUluZm8uYW55KSB7XG4gICAgICAgICAgICBjb25zdCBjbGFzc2VzID0gcmVuZGVyZXIudW5pcXVlVmFsdWVHcm91cHNbMF0uY2xhc3Nlcy5zbGljZSgpO1xuICAgICAgICAgICAgY2xhc3Nlcy5mb3JFYWNoKCh1bmlxdWVWYWx1ZUNsYXNzLCBpZHgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodW5pcXVlVmFsdWVDbGFzcy5zeW1ib2wudHlwZSA9PT0gXCJwaWN0dXJlLW1hcmtlclwiICYmIChoYXNDb2xvclJhbXBDaGFuZ2UgfHwgaGFzQWxwaGFDaGFuZ2UpKSB7XG4gICAgICAgICAgICAgICAgICAgIHVuaXF1ZVZhbHVlQ2xhc3Muc3ltYm9sID0gbW9kdWxlcy5lc3JpTGFuZy5jbG9uZShzeW1ib2wpO1xuICAgICAgICAgICAgICAgICAgICBhcHBseVN5bWJvbENvbG9yKHVuaXF1ZVZhbHVlQ2xhc3Muc3ltYm9sLCBjb2xvcnNbaWR4ICUgY29sb3JzLmxlbmd0aF0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB1bmlxdWVWYWx1ZUNsYXNzLnN5bWJvbCA9IHVwZGF0ZVN5bWJvbCh1bmlxdWVWYWx1ZUNsYXNzLnN5bWJvbCwgc3ltYm9sLCBoYXNDb2xvclJhbXBDaGFuZ2VcbiAgICAgICAgICAgICAgICAgICAgPyBjb2xvcnNbaWR4ICUgY29sb3JzLmxlbmd0aF1cbiAgICAgICAgICAgICAgICAgICAgOiBoYXNBbHBoYUNoYW5nZVxuICAgICAgICAgICAgICAgICAgICAgICAgPyBhcHBseUFscGhhKGdldFN5bWJvbENvbG9yKHVuaXF1ZVZhbHVlQ2xhc3Muc3ltYm9sKSwgbmV3QWxwaGEpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGdldFN5bWJvbENvbG9yKHVuaXF1ZVZhbHVlQ2xhc3Muc3ltYm9sKSB8fCBuZXcgbW9kdWxlcy5lc3JpQ29sb3IoWzAsIDAsIDAsIDBdKSwgc3ltYm9sQ2hhbmdlSW5mbyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJlbmRlcmVyLnVuaXF1ZVZhbHVlR3JvdXBzWzBdLmNsYXNzZXMgPSBjbGFzc2VzO1xuICAgICAgICB9IC8vIGVsc2UgbWF5YmUganVzdCBhbiBhdXRvIHNpemUgY2hhbmdlXG4gICAgICAgIGlmICghaXNQcmVkb21TaXplKSB7XG4gICAgICAgICAgICB1cGRhdGVBdXRvVmlzVmFyKHN5bWJvbCwgbWFya2VyID09PSBudWxsIHx8IG1hcmtlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogbWFya2VyLmF1dG9BZGp1c3RlZCwgc3Ryb2tlID09PSBudWxsIHx8IHN0cm9rZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogc3Ryb2tlLmF1dG9BZGp1c3RlZCwgc3ltYm9sU3R5bGVyLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9uQ2hhbmdlKCk7XG4gICAgICAgIH1cbiAgICAgICAgbGFzdFN5bWJvbCA9IHN5bWJvbC5jbG9uZSgpO1xuICAgICAgICBpZiAoaGFzQ29sb3JSYW1wQ2hhbmdlKSB7XG4gICAgICAgICAgICBjdXJyZW50Q29sb3JzID0gcmVuZGVyZXIudW5pcXVlVmFsdWVHcm91cHNbMF0uY2xhc3Nlcy5tYXAoKHVuaXF1ZVZhbHVlQ2xhc3MpID0+IGdldFN5bWJvbENvbG9yKHVuaXF1ZVZhbHVlQ2xhc3Muc3ltYm9sKSB8fCBuZXcgbW9kdWxlcy5lc3JpQ29sb3IoWzAsIDAsIDAsIDAuNV0pKTtcbiAgICAgICAgICAgIGN1cnJlbnRDb2xvcnMucmV2ZXJzZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBsZXQgc3Ryb2tlO1xuICAgIGlmIChzeW1ib2wudHlwZSA9PT0gXCJzaW1wbGUtZmlsbFwiKSB7XG4gICAgICAgIGNvbnN0IHN5bSA9IHN5bWJvbDtcbiAgICAgICAgaWYgKHN5bS5vdXRsaW5lKSB7XG4gICAgICAgICAgICBzdHJva2UgPSB7XG4gICAgICAgICAgICAgICAgY29sb3I6IHN5bS5vdXRsaW5lLmNvbG9yID8gc3ltLm91dGxpbmUuY29sb3IgOiBuZXcgbW9kdWxlcy5lc3JpQ29sb3IoWzAsIDAsIDAsIDAuNV0pLFxuICAgICAgICAgICAgICAgIHNpemU6IHN5bS5vdXRsaW5lLndpZHRoLFxuICAgICAgICAgICAgICAgIHN0eWxlOiBzeW0ub3V0bGluZS5zdHlsZSxcbiAgICAgICAgICAgICAgICBhdXRvQWRqdXN0ZWQ6ICEhc2l6ZU91dGxpbmVWaXNWYXJcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdHJva2UgPSB7XG4gICAgICAgICAgICAgICAgY29sb3I6IG5ldyBtb2R1bGVzLmVzcmlDb2xvcihbMCwgMCwgMCwgMC41XSksXG4gICAgICAgICAgICAgICAgc2l6ZTogMSxcbiAgICAgICAgICAgICAgICBzdHlsZTogXCJzb2xpZFwiLFxuICAgICAgICAgICAgICAgIGF1dG9BZGp1c3RlZDogISFzaXplT3V0bGluZVZpc1ZhclxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChzeW1ib2wudHlwZSA9PT0gXCJzaW1wbGUtbWFya2VyXCIpIHtcbiAgICAgICAgY29uc3Qgc3ltID0gc3ltYm9sO1xuICAgICAgICBpZiAoc3ltLm91dGxpbmUpIHtcbiAgICAgICAgICAgIHN0cm9rZSA9IHtcbiAgICAgICAgICAgICAgICBjb2xvcjogc3ltLm91dGxpbmUuY29sb3IgPyBzeW0ub3V0bGluZS5jb2xvciA6IG5ldyBtb2R1bGVzLmVzcmlDb2xvcihbMCwgMCwgMCwgMC41XSksXG4gICAgICAgICAgICAgICAgc2l6ZTogc3ltLm91dGxpbmUud2lkdGhcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdHJva2UgPSB7XG4gICAgICAgICAgICAgICAgY29sb3I6IG5ldyBtb2R1bGVzLmVzcmlDb2xvcihbMCwgMCwgMCwgMC41XSksXG4gICAgICAgICAgICAgICAgc2l6ZTogMVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChzeW1ib2wudHlwZSA9PT0gXCJjaW1cIikge1xuICAgICAgICBzdHJva2UgPSBnZXRDaW1MaW5lUHJvcHMoc3ltYm9sKTtcbiAgICAgICAgaWYgKGlzTGluZSkge1xuICAgICAgICAgICAgKHN0cm9rZS5zaXplID0gc2l6ZUF1dG9WaXNWYXIgPyBnZXRTaXplQnlTY2FsZShzaXplQXV0b1Zpc1ZhciwgbWFwVmlldy5zY2FsZSkgOiBzdHJva2Uuc2l6ZSksXG4gICAgICAgICAgICAgICAgKHN0cm9rZS5hdXRvQWRqdXN0ZWQgPSAhIXNpemVBdXRvVmlzVmFyKTtcbiAgICAgICAgICAgIGlmIChzaXplQXV0b1Zpc1Zhcikge1xuICAgICAgICAgICAgICAgIC8vIGFkanVzdHMgc3ltYm9sIHNvIGFsbCBzeW1ib2wgbGF5ZXJzIGZpdFxuICAgICAgICAgICAgICAgIGFwcGx5U3ltYm9sU2l6ZShzeW1ib2wsIHN0cm9rZS5zaXplKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChzeW1ib2wudHlwZSA9PT0gXCJzaW1wbGUtbGluZVwiKSB7XG4gICAgICAgIGNvbnN0IHN5bSA9IHN5bWJvbDtcbiAgICAgICAgc3Ryb2tlID0ge1xuICAgICAgICAgICAgY29sb3I6IG5ldyBtb2R1bGVzLmVzcmlDb2xvcihbMjU1LCAyNTUsIDI1NSwgMC41XSksXG4gICAgICAgICAgICBzaXplOiBzaXplQXV0b1Zpc1ZhciA/IGdldFNpemVCeVNjYWxlKHNpemVBdXRvVmlzVmFyLCBtYXBWaWV3LnNjYWxlKSA6IHN5bS53aWR0aCxcbiAgICAgICAgICAgIHN0eWxlOiBzeW0uc3R5bGUsXG4gICAgICAgICAgICBtYXJrZXI6IHN5bS5tYXJrZXIsXG4gICAgICAgICAgICBhdXRvQWRqdXN0ZWQ6ICEhc2l6ZUF1dG9WaXNWYXJcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHN0cm9rZSA9IHtcbiAgICAgICAgICAgIGNvbG9yOiBuZXcgbW9kdWxlcy5lc3JpQ29sb3IoWzI1NSwgMjU1LCAyNTUsIDAuNV0pLFxuICAgICAgICAgICAgc2l6ZTogMVxuICAgICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBzeW1ib2xTdHlsZXIgPSBhd2FpdCBjcmVhdGVTeW1ib2xTdHlsZXJFbGVtZW50KHBvcG92ZXJOb2RlKTtcbiAgICBsZXQgZWRpdDtcbiAgICAvLyBhcHBseSBhIGZldyBzZXR0aW5ncyB0byB0aGUgc3ltYm9sIHdlIHBhc3MgdG8gdGhlIHN0eWxlclxuICAgIC8vIHNvIHdoZW4gY29tcGFyaW5nIGNoYW5nZXMgaXQncyBjb3JyZWN0XG4gICAgYXBwbHlTeW1ib2xDb2xvcihzeW1ib2wsIGN1cnJlbnRDb2xvcnNbY3VycmVudENvbG9ycy5sZW5ndGggLSAxXSk7XG4gICAgaWYgKChpc1ByZWRvbVNpemUgfHwgaXNQb2ludCB8fCBpc0xpbmUpICYmIHNpemVBdXRvVmlzVmFyKSB7XG4gICAgICAgIGFwcGx5U3ltYm9sU2l6ZShzeW1ib2wsIGdldFNpemVCeVNjYWxlKHNpemVBdXRvVmlzVmFyLCBtYXBWaWV3LnNjYWxlKSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzUG9seWdvbiAmJiBzaXplQXV0b1Zpc1ZhciAmJiBzeW1ib2wub3V0bGluZSkge1xuICAgICAgICBzeW1ib2wub3V0bGluZS53aWR0aCA9IGdldFNpemVCeVNjYWxlKHNpemVBdXRvVmlzVmFyLCBtYXBWaWV3LnNjYWxlKTtcbiAgICB9XG4gICAgbGFzdFN5bWJvbCA9IHN5bWJvbC5jbG9uZSgpO1xuICAgIGlmIChpc0xpbmUpIHtcbiAgICAgICAgZWRpdCA9IHN5bWJvbFN0eWxlckVkaXQoc3ltYm9sU3R5bGVyLCBtb2R1bGVzLmVzcmlMYW5nLmNsb25lKHN5bWJvbCksIHtcbiAgICAgICAgICAgIHBvcnRhbCxcbiAgICAgICAgICAgIHN5bWJvbEZpbHRlcjogIWxheWVyU3VwcG9ydHNDSU0oKSA/IFwic2ltcGxlXCIgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBzZWN0aW9uczoge1xuICAgICAgICAgICAgICAgIHN0cm9rZToge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImNvbG9yLXJhbXBcIixcbiAgICAgICAgICAgICAgICAgICAgc3R5bGU6IFwiZGlzY3JldGVcIixcbiAgICAgICAgICAgICAgICAgICAgb3BlbjogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgY29sb3JSYW1wc09wZW46IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGNvbG9yUmFtcHMsXG4gICAgICAgICAgICAgICAgICAgIC8vc3VnZ2VzdGVkQ29sb3JzOiBzdWdnZXN0ZWRTdHJva2VDb2xvcnMsXG4gICAgICAgICAgICAgICAgICAgIHBhcnRzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvL3N1Z2dlc3RlZENvbG9yczogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2N1c3RvbUNvbG9yOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zcGFyZW5jeTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4dHJhOiAhaXNQcmVkb21TaXplIHx8IHN5bWJvbC50eXBlICE9PSBcImNpbVwiXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGV4dHJhUGFydHM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiBzeW1ib2wudHlwZSAhPT0gXCJjaW1cIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGFycm93OiBzeW1ib2wudHlwZSAhPT0gXCJjaW1cIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGF1dG9TdHJva2VBZGp1c3Q6ICFtYXBJbWFnZVN1YmxheWVyICYmICFpc1ByZWRvbVNpemUgPyBcImVkaXRhYmxlXCIgOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiAhaXNQcmVkb21TaXplXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc3Ryb2tlOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHN0cm9rZSksIHsgY29sb3I6IGN1cnJlbnRDb2xvcnMgfSlcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBlZGl0ID0gc3ltYm9sU3R5bGVyRWRpdChzeW1ib2xTdHlsZXIsIG1vZHVsZXMuZXNyaUxhbmcuY2xvbmUoc3ltYm9sKSwge1xuICAgICAgICAgICAgcG9ydGFsLFxuICAgICAgICAgICAgc3ltYm9sRmlsdGVyOiBpc1BvbHlnb24gJiYgIWxheWVyU3VwcG9ydHNDSU0oKSA/IFwic2ltcGxlXCIgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBzZWN0aW9uczoge1xuICAgICAgICAgICAgICAgIG1hcmtlcjogaXNQb2ludENJTSB8fCBbXCJzaW1wbGUtbWFya2VyXCIsIFwicGljdHVyZS1tYXJrZXJcIl0uaW5kZXhPZihzeW1ib2wudHlwZSkgPiAtMVxuICAgICAgICAgICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wZW46IGlzTGluZU1hcmtlcihzeW1ib2wpID8gdHJ1ZSA6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFydHM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaXplOiAhaXNQcmVkb21TaXplID8gKG1hcEltYWdlU3VibGF5ZXIgPyB0cnVlIDogeyBhdXRvU2l6ZUFkanVzdDogXCJlZGl0YWJsZVwiIH0pIDogZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBzeW1ib2xzT3BlbjogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpemVPcGVuOiAhaXNQcmVkb21TaXplLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWFya2VyVHlwZTogbGF5ZXJTdXBwb3J0c0NJTSgpID8gW1wic2ltcGxlXCIsIFwiY2ltOnZlY3RvclwiXSA6IFtcInNpbXBsZVwiXVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIGZpbGw6IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJjb2xvci1yYW1wXCIsXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlOiBcImRpc2NyZXRlXCIsXG4gICAgICAgICAgICAgICAgICAgIG9wZW46IGlzTGluZU1hcmtlcihzeW1ib2wpID8gZmFsc2UgOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBjb2xvclJhbXBzT3BlbjogaXNMaW5lTWFya2VyKHN5bWJvbCkgPyBmYWxzZSA6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGNvbG9yUmFtcHNcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHN0cm9rZToge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImNvbG9yXCIsXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBvcGVuOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgc3VnZ2VzdGVkQ29sb3JzOiBzdWdnZXN0ZWRTdHJva2VDb2xvcnMsXG4gICAgICAgICAgICAgICAgICAgIGV4dHJhUGFydHM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiBbXCJzaW1wbGUtbWFya2VyXCIsIFwicGljdHVyZS1tYXJrZXJcIiwgXCJjaW1cIl0uaW5kZXhPZihzeW1ib2wudHlwZSkgPT09IC0xLFxuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBhdXRvU3Ryb2tlQWRqdXN0OiAhbWFwSW1hZ2VTdWJsYXllciAmJiBpc1BvbHlnb24gJiYgc3ltYm9sLnR5cGUgIT09IFwiY2ltXCIgJiYgIWlzUHJlZG9tU2l6ZSA/IFwiZWRpdGFibGVcIiA6IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZmlsbDoge1xuICAgICAgICAgICAgICAgIGNvbG9yOiBjdXJyZW50Q29sb3JzXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbWFya2VyOiBpc1ByZWRvbVNpemUgfHwgaXNQb2ludFxuICAgICAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgICAgICBzaXplOiBzaXplQXV0b1Zpc1ZhciA/IGdldFNpemVCeVNjYWxlKHNpemVBdXRvVmlzVmFyLCBtYXBWaWV3LnNjYWxlKSA6IGdldFN5bWJvbFNpemUoc3ltYm9sKSxcbiAgICAgICAgICAgICAgICAgICAgYXV0b0FkanVzdGVkOiAhIXNpemVBdXRvVmlzVmFyXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgc3Ryb2tlLFxuICAgICAgICAgICAgc3Ryb2tlRW5hYmxlZFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgc3ltYm9sU3R5bGVyLmFkZEV2ZW50TGlzdGVuZXIoXCJhcmNnaXNTeW1ib2xTdHlsZXJFZGl0XCIsIG9uU3R5bGVyRWRpdFdyYXBwZXIuYmluZChudWxsLCBvblN0eWxlckVkaXQpKTtcbiAgICBwb3BvdmVyTm9kZS5hZGRTdHlsZXIoc3ltYm9sU3R5bGVyKTtcbiAgICBhd2FpdCBlZGl0O1xuICAgIHJldHVybiBjcmVhdGVXYXRjaFNjYWxlSGFuZGxlKCgoX2QgPSByZW5kZXJlci51bmlxdWVWYWx1ZUdyb3Vwc1swXS5jbGFzc2VzKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QubGVuZ3RoKSA/IHJlbmRlcmVyLnVuaXF1ZVZhbHVlR3JvdXBzWzBdLmNsYXNzZXNbMF0uc3ltYm9sIDogdW5kZWZpbmVkLCBzeW1ib2xTdHlsZXIsIChuZXdTaXplKSA9PiB7XG4gICAgICAgIGlzUG9seWdvbiAmJiBzeW1ib2wub3V0bGluZSA/IChzeW1ib2wub3V0bGluZS53aWR0aCA9IG5ld1NpemUpIDogIWlzUG9seWdvbiAmJiBhcHBseVN5bWJvbFNpemUoc3ltYm9sLCBuZXdTaXplKTtcbiAgICAgICAgbGFzdFN5bWJvbCA9IHN5bWJvbC5jbG9uZSgpO1xuICAgIH0pO1xufVxuYXN5bmMgZnVuY3Rpb24gYnVpbGRTeW1ib2xTdHlsZXJGb3JQcmVkb21pbmFuY2VWYWx1ZShvcHRpb25zKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IHsgbGF5ZXIsIG1hcEltYWdlU3VibGF5ZXIsIG1hcFZpZXcsIHNlbGVjdGVkVmFsdWUsIGxhc3REZWZhdWx0LCBwb3J0YWwsIG1vZHVsZXMgfSA9IHNtYXJ0TWFwcGluZ1N0YXRlO1xuICAgIGNvbnN0IHsgb25DaGFuZ2UsIHBvcG92ZXJOb2RlIH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IGlzUG9pbnQgPSBpc1BvaW50VHlwZShsYXllcik7XG4gICAgY29uc3QgaXNMaW5lID0gaXNQb2x5bGluZVR5cGUobGF5ZXIpO1xuICAgIGNvbnN0IGlzUG9seWdvbiA9IGlzUG9seWdvblR5cGUobGF5ZXIpO1xuICAgIGNvbnN0IHJlbmRlcmVyID0gZ2V0UmVuZGVyZXIobGF5ZXIpO1xuICAgIGNvbnN0IHJlbmRlcmVyVHlwZSA9IGdldFJlbmRlcmVyVHlwZSgpO1xuICAgIGNvbnN0IGlzUHJlZG9tU2l6ZSA9IHJlbmRlcmVyVHlwZSA9PT0gXCJwcmVkb21pbmFuY2Utc2l6ZVwiO1xuICAgIGNvbnN0IHNpemVBdXRvVmlzVmFyID0gZ2V0VmlzVmFyKHJlbmRlcmVyLCBcInNpemVcIiwgXCJhdXRvXCIpO1xuICAgIGNvbnN0IHNpemVPdXRsaW5lVmlzVmFyID0gZ2V0VmlzVmFyKHJlbmRlcmVyLCBcInNpemVcIiwgXCJvdXRsaW5lXCIpO1xuICAgIGxldCBzeW1ib2w7XG4gICAgaWYgKHNlbGVjdGVkVmFsdWUgPT09IC0xKSB7XG4gICAgICAgIHN5bWJvbCA9IHJlbmRlcmVyLmRlZmF1bHRTeW1ib2wgfHwgbGFzdERlZmF1bHQuZGVmYXVsdFN5bWJvbDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHN5bWJvbCA9IHJlbmRlcmVyLnVuaXF1ZVZhbHVlR3JvdXBzWzBdLmNsYXNzZXNbc2VsZWN0ZWRWYWx1ZV0uc3ltYm9sO1xuICAgIH1cbiAgICBpZiAoIWlzU3VwcG9ydGVkU3ltYm9sKHN5bWJvbCkpIHtcbiAgICAgICAgc3ltYm9sID0gZ2V0RGVmYXVsdFN5bWJvbChsYXllciwgbWFwVmlldywgcmVuZGVyZXJUeXBlKTtcbiAgICAgICAgaWYgKHNlbGVjdGVkVmFsdWUgPT09IC0xICYmICFyZW5kZXJlci5kZWZhdWx0U3ltYm9sKSB7XG4gICAgICAgICAgICBsYXN0RGVmYXVsdC5kZWZhdWx0U3ltYm9sID0gc3ltYm9sO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGZpbGxFbmFibGVkID0gc3ltYm9sLnR5cGUgPT09IFwicGljdHVyZS1tYXJrZXJcIiA/IGZhbHNlIDogISFzeW1ib2wuY29sb3I7XG4gICAgY29uc3Qgc3Ryb2tlRW5hYmxlZCA9IGhhc1N5bWJvbE91dGxpbmUoc3ltYm9sKTtcbiAgICBjb25zdCBpc1BvaW50Q0lNID0gc3ltYm9sLnR5cGUgPT09IFwiY2ltXCIgJiYgc3ltYm9sLmRhdGEuc3ltYm9sLnR5cGUgPT09IFwiQ0lNUG9pbnRTeW1ib2xcIjtcbiAgICBsZXQgc3VnZ2VzdGVkRmlsbENvbG9ycztcbiAgICBpZiAoc2VsZWN0ZWRWYWx1ZSA9PT0gLTEpIHtcbiAgICAgICAgc3VnZ2VzdGVkRmlsbENvbG9ycyA9IGdldEdyZXlDb2xvcnMoKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IHNjaGVtZXMgPSBtb2R1bGVzLnByZWRvbWluYW5jZVNjaGVtZXMuZ2V0U2NoZW1lcyh7XG4gICAgICAgICAgICBiYXNlbWFwOiBtYXBWaWV3Lm1hcC5iYXNlbWFwLFxuICAgICAgICAgICAgZ2VvbWV0cnlUeXBlOiBnZXRHZW9tZXRyeVR5cGUobGF5ZXIpLFxuICAgICAgICAgICAgbnVtQ29sb3JzOiAxMFxuICAgICAgICB9KTtcbiAgICAgICAgc3VnZ2VzdGVkRmlsbENvbG9ycyA9IGdldEZpbGxDb2xvcnMoc2NoZW1lcykuc2xpY2UoMCwgMTYpO1xuICAgIH1cbiAgICBjb25zdCBzdWdnZXN0ZWRTdHJva2VDb2xvcnMgPSBnZXRBbGxDb2xvcnNSZXZlcnNlZCgpO1xuICAgIGNvbnN0IG9uU3R5bGVyRWRpdCA9ICh7IGRldGFpbDogeyBzeW1ib2wsIGluZm86IHsgbWFya2VyLCBzdHJva2UgLyogLCBmaWxsICovIH0gfSB9KSA9PiB7XG4gICAgICAgIGNvbnN0IHJlbmRlcmVyID0gZ2V0UmVuZGVyZXIobGF5ZXIpO1xuICAgICAgICBpZiAoc2VsZWN0ZWRWYWx1ZSA9PT0gLTEpIHtcbiAgICAgICAgICAgIHJlbmRlcmVyLmRlZmF1bHRTeW1ib2wgPSBzeW1ib2w7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBpbmZvcyA9IHJlbmRlcmVyLnVuaXF1ZVZhbHVlR3JvdXBzWzBdLmNsYXNzZXMuc2xpY2UoKTtcbiAgICAgICAgICAgIGluZm9zW3NlbGVjdGVkVmFsdWVdLnN5bWJvbCA9IHN5bWJvbDtcbiAgICAgICAgICAgIHJlbmRlcmVyLnVuaXF1ZVZhbHVlR3JvdXBzWzBdLmNsYXNzZXMgPSBpbmZvcztcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzUHJlZG9tU2l6ZSkge1xuICAgICAgICAgICAgdXBkYXRlQXV0b1Zpc1ZhcihzeW1ib2wsIG1hcmtlciA9PT0gbnVsbCB8fCBtYXJrZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG1hcmtlci5hdXRvQWRqdXN0ZWQsIHN0cm9rZSA9PT0gbnVsbCB8fCBzdHJva2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHN0cm9rZS5hdXRvQWRqdXN0ZWQsIHN5bWJvbFN0eWxlciwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvbkNoYW5nZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBsZXQgc3Ryb2tlO1xuICAgIGlmIChzeW1ib2wudHlwZSA9PT0gXCJzaW1wbGUtZmlsbFwiKSB7XG4gICAgICAgIGNvbnN0IHN5bSA9IHN5bWJvbDtcbiAgICAgICAgaWYgKHN5bS5vdXRsaW5lKSB7XG4gICAgICAgICAgICBzdHJva2UgPSB7XG4gICAgICAgICAgICAgICAgY29sb3I6IHN5bS5vdXRsaW5lLmNvbG9yID8gc3ltLm91dGxpbmUuY29sb3IgOiBuZXcgbW9kdWxlcy5lc3JpQ29sb3IoWzAsIDAsIDAsIDAuNV0pLFxuICAgICAgICAgICAgICAgIHNpemU6IHN5bS5vdXRsaW5lLndpZHRoLFxuICAgICAgICAgICAgICAgIHN0eWxlOiBzeW0ub3V0bGluZS5zdHlsZSxcbiAgICAgICAgICAgICAgICBhdXRvQWRqdXN0ZWQ6ICEhc2l6ZU91dGxpbmVWaXNWYXJcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdHJva2UgPSB7XG4gICAgICAgICAgICAgICAgY29sb3I6IG5ldyBtb2R1bGVzLmVzcmlDb2xvcihbMCwgMCwgMCwgMC41XSksXG4gICAgICAgICAgICAgICAgc2l6ZTogMSxcbiAgICAgICAgICAgICAgICBzdHlsZTogXCJzb2xpZFwiLFxuICAgICAgICAgICAgICAgIGF1dG9BZGp1c3RlZDogISFzaXplT3V0bGluZVZpc1ZhclxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChzeW1ib2wudHlwZSA9PT0gXCJzaW1wbGUtbWFya2VyXCIpIHtcbiAgICAgICAgY29uc3Qgc3ltID0gc3ltYm9sO1xuICAgICAgICBpZiAoc3ltLm91dGxpbmUpIHtcbiAgICAgICAgICAgIHN0cm9rZSA9IHtcbiAgICAgICAgICAgICAgICBjb2xvcjogc3ltLm91dGxpbmUuY29sb3IgPyBzeW0ub3V0bGluZS5jb2xvciA6IG5ldyBtb2R1bGVzLmVzcmlDb2xvcihbMCwgMCwgMCwgMC41XSksXG4gICAgICAgICAgICAgICAgc2l6ZTogc3ltLm91dGxpbmUud2lkdGhcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdHJva2UgPSB7XG4gICAgICAgICAgICAgICAgY29sb3I6IG5ldyBtb2R1bGVzLmVzcmlDb2xvcihbMCwgMCwgMCwgMC41XSksXG4gICAgICAgICAgICAgICAgc2l6ZTogMVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChzeW1ib2wudHlwZSA9PT0gXCJjaW1cIikge1xuICAgICAgICBzdHJva2UgPSBnZXRDaW1MaW5lUHJvcHMoc3ltYm9sKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoc3ltYm9sLnR5cGUgPT09IFwic2ltcGxlLWxpbmVcIikge1xuICAgICAgICBjb25zdCBzeW0gPSBzeW1ib2w7XG4gICAgICAgIHN0cm9rZSA9IHtcbiAgICAgICAgICAgIHNpemU6IHN5bS53aWR0aCxcbiAgICAgICAgICAgIHN0eWxlOiBzeW0uc3R5bGUsXG4gICAgICAgICAgICBtYXJrZXI6IHN5bS5tYXJrZXIsXG4gICAgICAgICAgICBjb2xvcjogc3ltLmNvbG9yXG4gICAgICAgIH07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBzdHJva2UgPSB7XG4gICAgICAgICAgICBjb2xvcjogbmV3IG1vZHVsZXMuZXNyaUNvbG9yKFsyNTUsIDI1NSwgMjU1LCAwLjVdKSxcbiAgICAgICAgICAgIHNpemU6IDFcbiAgICAgICAgfTtcbiAgICB9XG4gICAgY29uc3Qgc3ltYm9sU3R5bGVyID0gYXdhaXQgY3JlYXRlU3ltYm9sU3R5bGVyRWxlbWVudChwb3BvdmVyTm9kZSk7XG4gICAgbGV0IGVkaXQ7XG4gICAgaWYgKGlzTGluZSkge1xuICAgICAgICBlZGl0ID0gc3ltYm9sU3R5bGVyRWRpdChzeW1ib2xTdHlsZXIsIG1vZHVsZXMuZXNyaUxhbmcuY2xvbmUoc3ltYm9sKSwge1xuICAgICAgICAgICAgcG9ydGFsLFxuICAgICAgICAgICAgc3ltYm9sRmlsdGVyOiAhbGF5ZXJTdXBwb3J0c0NJTSgpID8gXCJzaW1wbGVcIiA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHNlY3Rpb25zOiB7XG4gICAgICAgICAgICAgICAgc3Ryb2tlOiB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiY29sb3JcIixcbiAgICAgICAgICAgICAgICAgICAgb3BlbjogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgc3VnZ2VzdGVkQ29sb3JzT3BlbjogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgc3VnZ2VzdGVkQ29sb3JzOiBzdWdnZXN0ZWRGaWxsQ29sb3JzLFxuICAgICAgICAgICAgICAgICAgICBleHRyYVBhcnRzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZTogc3ltYm9sLnR5cGUgIT09IFwiY2ltXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBhcnJvdzogc3ltYm9sLnR5cGUgIT09IFwiY2ltXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBhdXRvU3Ryb2tlQWRqdXN0OiAhbWFwSW1hZ2VTdWJsYXllciAmJiAhaXNQcmVkb21TaXplID8gXCJlZGl0YWJsZVwiIDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogIWlzUHJlZG9tU2l6ZVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBwYXJ0czoge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXh0cmE6ICFpc1ByZWRvbVNpemUgfHwgc3ltYm9sLnR5cGUgIT09IFwiY2ltXCJcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzdHJva2VcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBlZGl0ID0gc3ltYm9sU3R5bGVyRWRpdChzeW1ib2xTdHlsZXIsIG1vZHVsZXMuZXNyaUxhbmcuY2xvbmUoc3ltYm9sKSwge1xuICAgICAgICAgICAgcG9ydGFsLFxuICAgICAgICAgICAgc3ltYm9sRmlsdGVyOiBpc1BvbHlnb24gJiYgIWxheWVyU3VwcG9ydHNDSU0oKSA/IFwic2ltcGxlXCIgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBzZWN0aW9uczoge1xuICAgICAgICAgICAgICAgIG1hcmtlcjogaXNQb2ludENJTSB8fCBbXCJzaW1wbGUtbWFya2VyXCIsIFwicGljdHVyZS1tYXJrZXJcIl0uaW5kZXhPZihzeW1ib2wudHlwZSkgPiAtMVxuICAgICAgICAgICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wZW46IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJ0czoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpemU6ICFpc1ByZWRvbVNpemUgPyAobWFwSW1hZ2VTdWJsYXllciA/IHRydWUgOiB7IGF1dG9TaXplQWRqdXN0OiBcImVkaXRhYmxlXCIgfSkgOiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN5bWJvbHNPcGVuOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2l6ZU9wZW46ICFpc1ByZWRvbVNpemUsXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXJrZXJUeXBlOiBsYXllclN1cHBvcnRzQ0lNKCkgPyBcImFsbFwiIDogW1wic2ltcGxlXCIsIFwicGljdHVyZVwiXVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIGZpbGw6IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJjb2xvclwiLFxuICAgICAgICAgICAgICAgICAgICBvcGVuOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgc3VnZ2VzdGVkQ29sb3JzT3BlbjogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNwYXJlbmN5T3BlbjogaXNQaWN0dXJlTWFya2VyKHN5bWJvbCksXG4gICAgICAgICAgICAgICAgICAgIHN1Z2dlc3RlZENvbG9yczogc3VnZ2VzdGVkRmlsbENvbG9yc1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc3Ryb2tlOiB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiY29sb3JcIixcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9uYWw6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHN1Z2dlc3RlZENvbG9yczogc3VnZ2VzdGVkU3Ryb2tlQ29sb3JzLFxuICAgICAgICAgICAgICAgICAgICBleHRyYVBhcnRzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZTogW1wic2ltcGxlLW1hcmtlclwiLCBcInBpY3R1cmUtbWFya2VyXCIsIFwiY2ltXCJdLmluZGV4T2Yoc3ltYm9sLnR5cGUpID09PSAtMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXV0b1N0cm9rZUFkanVzdDogIW1hcEltYWdlU3VibGF5ZXIgJiYgaXNQb2x5Z29uICYmIHN5bWJvbC50eXBlICE9PSBcImNpbVwiICYmICFpc1ByZWRvbVNpemUgPyBcImVkaXRhYmxlXCIgOiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZpbGw6IHtcbiAgICAgICAgICAgICAgICBjb2xvcjogZ2V0U3ltYm9sQ29sb3Ioc3ltYm9sKSB8fCBhZGp1c3RBbHBoYShzdWdnZXN0ZWRGaWxsQ29sb3JzW3NlbGVjdGVkVmFsdWVdLCAwLjg1KVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG1hcmtlcjogaXNQcmVkb21TaXplIHx8IGlzUG9pbnRcbiAgICAgICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICAgICAgc2l6ZTogc2l6ZUF1dG9WaXNWYXIgPyBnZXRTaXplQnlTY2FsZShzaXplQXV0b1Zpc1ZhciwgbWFwVmlldy5zY2FsZSkgOiBnZXRTeW1ib2xTaXplKHN5bWJvbCksXG4gICAgICAgICAgICAgICAgICAgIGF1dG9BZGp1c3RlZDogISFzaXplQXV0b1Zpc1ZhclxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHN0cm9rZSxcbiAgICAgICAgICAgIGZpbGxFbmFibGVkLFxuICAgICAgICAgICAgc3Ryb2tlRW5hYmxlZFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgc3ltYm9sU3R5bGVyLmFkZEV2ZW50TGlzdGVuZXIoXCJhcmNnaXNTeW1ib2xTdHlsZXJFZGl0XCIsIG9uU3R5bGVyRWRpdFdyYXBwZXIuYmluZChudWxsLCBvblN0eWxlckVkaXQpKTtcbiAgICBwb3BvdmVyTm9kZS5hZGRTdHlsZXIoc3ltYm9sU3R5bGVyKTtcbiAgICBhd2FpdCBlZGl0O1xuICAgIHJldHVybiBjcmVhdGVXYXRjaFNjYWxlSGFuZGxlKCgoX2EgPSByZW5kZXJlci51bmlxdWVWYWx1ZUdyb3Vwc1swXS5jbGFzc2VzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubGVuZ3RoKSA/IHJlbmRlcmVyLnVuaXF1ZVZhbHVlR3JvdXBzWzBdLmNsYXNzZXNbMF0uc3ltYm9sIDogdW5kZWZpbmVkLCBzeW1ib2xTdHlsZXIpO1xufVxuYXN5bmMgZnVuY3Rpb24gYnVpbGRTeW1ib2xTdHlsZXJGb3JDaGFydFJhbXAob3B0aW9ucykge1xuICAgIGNvbnN0IHsgbGF5ZXIsIG1hcFZpZXcsIHBvcnRhbCwgc3RyaW5ncywgbW9kdWxlcyB9ID0gc21hcnRNYXBwaW5nU3RhdGU7XG4gICAgY29uc3QgeyBvbkNoYW5nZSwgcG9wb3Zlck5vZGUgfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgcmVuZGVyZXIgPSBnZXRSZW5kZXJlcihsYXllcik7XG4gICAgY29uc3QgYXR0cmlidXRlcyA9IHJlbmRlcmVyLmF0dHJpYnV0ZXM7XG4gICAgY29uc3QgY3VycmVudENvbG9ycyA9IGF0dHJpYnV0ZXMubWFwKChhdHRyaWJ1dGUpID0+IGF0dHJpYnV0ZS5jb2xvcik7XG4gICAgY29uc3Qgc2NoZW1lcyA9IG1vZHVsZXMucGllQ2hhcnRTY2hlbWVzLmdldFNjaGVtZXMoe1xuICAgICAgICBiYXNlbWFwOiBtYXBWaWV3Lm1hcC5iYXNlbWFwLFxuICAgICAgICBnZW9tZXRyeVR5cGU6IGdldEdlb21ldHJ5VHlwZShsYXllcikgfHwgZGVmYXVsdEdlb21ldHJ5LFxuICAgICAgICBudW1Db2xvcnM6IGF0dHJpYnV0ZXMubGVuZ3RoXG4gICAgfSk7XG4gICAgY29uc3Qgc3VnZ2VzdGVkU3Ryb2tlQ29sb3JzID0gZ2V0R3JleUNvbG9ycygpO1xuICAgIC8vIFRPRE8gZ2V0IGN1cnJlbnQgc2NoZW1lXG4gICAgY29uc3QgY29sb3JSYW1wc0FuZFNjaGVtZXMgPSBnZXRDb2xvclJhbXBzV2l0aFNjaGVtZXMoc2NoZW1lcywgYXR0cmlidXRlcy5sZW5ndGgpO1xuICAgIGNvbnN0IGNvbG9yUmFtcHMgPSBjb2xvclJhbXBzQW5kU2NoZW1lcy5tYXAoKG9iaikgPT4ge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3RvcHM6IG9iai5jb2xvcnMucmV2ZXJzZSgpLFxuICAgICAgICAgICAgdGFnczogb2JqLnNjaGVtZS50YWdzLFxuICAgICAgICAgICAgbmFtZTogb2JqLnNjaGVtZS5uYW1lXG4gICAgICAgIH07XG4gICAgfSk7XG4gICAgY29uc3Qgb25TdHlsZXJFZGl0ID0gKHsgZGV0YWlsOiB7IHN5bWJvbCwgaW5mbzogeyAvKiBtYXJrZXIsIHN0cm9rZSwgKi8gZmlsbCB9IH0gfSkgPT4ge1xuICAgICAgICBjb25zdCBjb2xvcnMgPSBtb2R1bGVzLmVzcmlMYW5nLmNsb25lKGZpbGwuY29sb3IpO1xuICAgICAgICBjb2xvcnMucmV2ZXJzZSgpO1xuICAgICAgICBnZXRSZW5kZXJlcihsYXllcikuYXR0cmlidXRlcy5mb3JFYWNoKChhdHRyaWJ1dGUsIGlkeCkgPT4gKGF0dHJpYnV0ZS5jb2xvciA9IGNvbG9yc1tpZHhdKSk7XG4gICAgICAgIGdldFJlbmRlcmVyKGxheWVyKS5vdXRsaW5lID0gc3ltYm9sLm91dGxpbmUuY2xvbmUoKTtcbiAgICAgICAgb25DaGFuZ2UoKTtcbiAgICB9O1xuICAgIGNvbnN0IHN5bWJvbCA9IGdldERlZmF1bHRTeW1ib2wobGF5ZXIsIG1hcFZpZXcpO1xuICAgIHN5bWJvbC5vdXRsaW5lID0gcmVuZGVyZXIub3V0bGluZTtcbiAgICBsZXQgc3Ryb2tlO1xuICAgIGlmIChzeW1ib2wudHlwZSA9PT0gXCJzaW1wbGUtZmlsbFwiKSB7XG4gICAgICAgIGlmIChzeW1ib2wub3V0bGluZSkge1xuICAgICAgICAgICAgY29uc3Qgc3ltID0gc3ltYm9sLm91dGxpbmU7XG4gICAgICAgICAgICBzdHJva2UgPSB7XG4gICAgICAgICAgICAgICAgY29sb3I6IHN5bS5jb2xvciA/IHN5bS5jb2xvciA6IG5ldyBtb2R1bGVzLmVzcmlDb2xvcihbMCwgMCwgMCwgMC41XSksXG4gICAgICAgICAgICAgICAgc2l6ZTogc3ltLndpZHRoLFxuICAgICAgICAgICAgICAgIHN0eWxlOiBzeW0uc3R5bGVcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdHJva2UgPSB7XG4gICAgICAgICAgICAgICAgY29sb3I6IG5ldyBtb2R1bGVzLmVzcmlDb2xvcihbMCwgMCwgMCwgMC41XSksXG4gICAgICAgICAgICAgICAgc2l6ZTogMSxcbiAgICAgICAgICAgICAgICBzdHlsZTogXCJzb2xpZFwiXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKHN5bWJvbC50eXBlID09PSBcInNpbXBsZS1tYXJrZXJcIiAmJiBzeW1ib2wub3V0bGluZSkge1xuICAgICAgICBjb25zdCBzeW0gPSBzeW1ib2wub3V0bGluZTtcbiAgICAgICAgc3Ryb2tlID0ge1xuICAgICAgICAgICAgY29sb3I6IHN5bS5jb2xvciA/IHN5bS5jb2xvciA6IG5ldyBtb2R1bGVzLmVzcmlDb2xvcihbMCwgMCwgMCwgMC41XSksXG4gICAgICAgICAgICBzaXplOiBzeW0ud2lkdGgsXG4gICAgICAgICAgICBzdHlsZTogc3ltLnN0eWxlXG4gICAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IHN5bWJvbFN0eWxlciA9IGF3YWl0IGNyZWF0ZVN5bWJvbFN0eWxlckVsZW1lbnQocG9wb3Zlck5vZGUpO1xuICAgIGNvbnN0IGVkaXQgPSBzeW1ib2xTdHlsZXJFZGl0KHN5bWJvbFN0eWxlciwgc3ltYm9sLCB7XG4gICAgICAgIHBvcnRhbCxcbiAgICAgICAgc2VjdGlvbnM6IHtcbiAgICAgICAgICAgIG1hcmtlcjoge1xuICAgICAgICAgICAgICAgIHBhcnRzOiB7XG4gICAgICAgICAgICAgICAgICAgIHByZXZpZXc6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICByb3RhdGlvbjogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIHNpemU6IGZhbHNlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZpbGw6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImNvbG9yLXJhbXBcIixcbiAgICAgICAgICAgICAgICBzdHlsZTogXCJkaXNjcmV0ZVwiLFxuICAgICAgICAgICAgICAgIG9wZW46IHRydWUsXG4gICAgICAgICAgICAgICAgY29sb3JSYW1wc09wZW46IHRydWUsXG4gICAgICAgICAgICAgICAgY29sb3JSYW1wc1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHN0cm9rZToge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiY29sb3JcIixcbiAgICAgICAgICAgICAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICAgICAgICAgICAgICBzdWdnZXN0ZWRDb2xvcnM6IHN1Z2dlc3RlZFN0cm9rZUNvbG9ycyxcbiAgICAgICAgICAgICAgICBleHRyYVBhcnRzOiB7XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGF1dG9TdHJva2VBZGp1c3Q6IGZhbHNlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBmaWxsOiB7XG4gICAgICAgICAgICBjb2xvcjogY3VycmVudENvbG9ycy5yZXZlcnNlKClcbiAgICAgICAgfSxcbiAgICAgICAgc3Ryb2tlXG4gICAgfSk7XG4gICAgc3ltYm9sU3R5bGVyLnN0cmluZ092ZXJyaWRlcyA9IHtcbiAgICAgICAgZmlsbENvbG9yOiBzdHJpbmdzLnN0eWxlci5jb2xvcixcbiAgICAgICAgZmlsbFRyYW5zcGFyZW5jeTogc3RyaW5ncy5zdHlsZXIudHJhbnNwYXJlbmN5XG4gICAgfTtcbiAgICBzeW1ib2xTdHlsZXIuYWRkRXZlbnRMaXN0ZW5lcihcImFyY2dpc1N5bWJvbFN0eWxlckVkaXRcIiwgb25TdHlsZXJFZGl0V3JhcHBlci5iaW5kKG51bGwsIG9uU3R5bGVyRWRpdCkpO1xuICAgIHBvcG92ZXJOb2RlLmFkZFN0eWxlcihzeW1ib2xTdHlsZXIpO1xuICAgIGF3YWl0IGVkaXQ7XG59XG5hc3luYyBmdW5jdGlvbiBidWlsZFN5bWJvbFN0eWxlckZvckNoYXJ0VmFsdWUob3B0aW9ucykge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCB7IGxheWVyLCBtYXBWaWV3LCBzZWxlY3RlZEF0dHJpYnV0ZSwgbGFzdERlZmF1bHQsIHBvcnRhbCwgc3RyaW5ncywgbW9kdWxlcyB9ID0gc21hcnRNYXBwaW5nU3RhdGU7XG4gICAgY29uc3QgeyBvbkNoYW5nZSwgcG9wb3Zlck5vZGUgfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgcmVuZGVyZXIgPSBnZXRSZW5kZXJlcihsYXllcik7XG4gICAgY29uc3QgYXR0cmlidXRlcyA9IHJlbmRlcmVyLmF0dHJpYnV0ZXM7XG4gICAgbGV0IGNvbG9yO1xuICAgIGlmIChzZWxlY3RlZEF0dHJpYnV0ZSA9PT0gLTEpIHtcbiAgICAgICAgY29sb3IgPSAoKF9hID0gcmVuZGVyZXIub3RoZXJzQ2F0ZWdvcnkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jb2xvcikgfHwgKGxhc3REZWZhdWx0ID09PSBudWxsIHx8IGxhc3REZWZhdWx0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBsYXN0RGVmYXVsdC5vdGhlckNvbG9yKSB8fCBuZXcgbW9kdWxlcy5lc3JpQ29sb3IoWzE3MCwgMTcwLCAxNzAsIDFdKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoc2VsZWN0ZWRBdHRyaWJ1dGUgPT09IC0yKSB7XG4gICAgICAgIGNvbG9yID0gcmVuZGVyZXIuZGVmYXVsdENvbG9yIHx8IChsYXN0RGVmYXVsdCA9PT0gbnVsbCB8fCBsYXN0RGVmYXVsdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogbGFzdERlZmF1bHQuZGVmYXVsdENvbG9yKSB8fCBuZXcgbW9kdWxlcy5lc3JpQ29sb3IoWzE3MCwgMTcwLCAxNzAsIDFdKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbG9yID0gYXR0cmlidXRlc1tzZWxlY3RlZEF0dHJpYnV0ZV0uY29sb3I7XG4gICAgfVxuICAgIGNvbnN0IHNjaGVtZXMgPSBtb2R1bGVzLnBpZUNoYXJ0U2NoZW1lcy5nZXRTY2hlbWVzKHtcbiAgICAgICAgYmFzZW1hcDogbWFwVmlldy5tYXAuYmFzZW1hcCxcbiAgICAgICAgZ2VvbWV0cnlUeXBlOiBnZXRHZW9tZXRyeVR5cGUobGF5ZXIpIHx8IGRlZmF1bHRHZW9tZXRyeSxcbiAgICAgICAgbnVtQ29sb3JzOiBhdHRyaWJ1dGVzLmxlbmd0aFxuICAgIH0pO1xuICAgIGNvbnN0IHN1Z2dlc3RlZEZpbGxDb2xvcnMgPSBnZXRGaWxsQ29sb3JzKHNjaGVtZXMpLnNsaWNlKDAsIDE2KTtcbiAgICBjb25zdCBvblN0eWxlckVkaXQgPSAoeyBkZXRhaWw6IHsgc3ltYm9sIC8qICxcbiAgICBpbmZvOiB7IG1hcmtlciwgc3Ryb2tlLCBmaWxsIH0gKi8gfSB9KSA9PiB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKHNlbGVjdGVkQXR0cmlidXRlID09PSAtMSkge1xuICAgICAgICAgICAgaWYgKCFnZXRSZW5kZXJlcihsYXllcikub3RoZXJzQ2F0ZWdvcnkpIHtcbiAgICAgICAgICAgICAgICBnZXRSZW5kZXJlcihsYXllcikub3RoZXJzQ2F0ZWdvcnkgPSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbG9yOiBnZXRTeW1ib2xDb2xvcihzeW1ib2wpLFxuICAgICAgICAgICAgICAgICAgICBsYWJlbDogKGxhc3REZWZhdWx0ID09PSBudWxsIHx8IGxhc3REZWZhdWx0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBsYXN0RGVmYXVsdC5vdGhlckxhYmVsKSB8fCBzdHJpbmdzLnN0eWxlci5vdGhlcixcbiAgICAgICAgICAgICAgICAgICAgdGhyZXNob2xkOiAoX2EgPSBsYXN0RGVmYXVsdCA9PT0gbnVsbCB8fCBsYXN0RGVmYXVsdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogbGFzdERlZmF1bHQudGhyZXNob2xkKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAwXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGdldFJlbmRlcmVyKGxheWVyKS5vdGhlcnNDYXRlZ29yeS5jb2xvciA9IGdldFN5bWJvbENvbG9yKHN5bWJvbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc2VsZWN0ZWRBdHRyaWJ1dGUgPT09IC0yKSB7XG4gICAgICAgICAgICBnZXRSZW5kZXJlcihsYXllcikuZGVmYXVsdENvbG9yID0gZ2V0U3ltYm9sQ29sb3Ioc3ltYm9sKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGdldFJlbmRlcmVyKGxheWVyKS5hdHRyaWJ1dGVzW3NlbGVjdGVkQXR0cmlidXRlXS5jb2xvciA9IGdldFN5bWJvbENvbG9yKHN5bWJvbCk7XG4gICAgICAgIH1cbiAgICAgICAgb25DaGFuZ2UoKTtcbiAgICB9O1xuICAgIGNvbnN0IHN5bWJvbCA9IGdldERlZmF1bHRTeW1ib2wobGF5ZXIsIG1hcFZpZXcpO1xuICAgIHN5bWJvbC5vdXRsaW5lID0gdW5kZWZpbmVkO1xuICAgIGFwcGx5U3ltYm9sQ29sb3Ioc3ltYm9sLCBjb2xvcik7XG4gICAgY29uc3Qgc3ltYm9sU3R5bGVyID0gYXdhaXQgY3JlYXRlU3ltYm9sU3R5bGVyRWxlbWVudChwb3BvdmVyTm9kZSk7XG4gICAgY29uc3QgZWRpdCA9IHN5bWJvbFN0eWxlckVkaXQoc3ltYm9sU3R5bGVyLCBzeW1ib2wsIHtcbiAgICAgICAgcG9ydGFsLFxuICAgICAgICBzZWN0aW9uczoge1xuICAgICAgICAgICAgbWFya2VyOiB7XG4gICAgICAgICAgICAgICAgcGFydHM6IHtcbiAgICAgICAgICAgICAgICAgICAgcHJldmlldzogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIHJvdGF0aW9uOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgc2l6ZTogZmFsc2VcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZmlsbDoge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiY29sb3JcIixcbiAgICAgICAgICAgICAgICBvcGVuOiB0cnVlLFxuICAgICAgICAgICAgICAgIHN1Z2dlc3RlZENvbG9yc09wZW46IHRydWUsXG4gICAgICAgICAgICAgICAgc3VnZ2VzdGVkQ29sb3JzOiBzdWdnZXN0ZWRGaWxsQ29sb3JzXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGZpbGw6IHtcbiAgICAgICAgICAgIGNvbG9yXG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBzeW1ib2xTdHlsZXIuc3RyaW5nT3ZlcnJpZGVzID0ge1xuICAgICAgICBmaWxsQ29sb3I6IHN0cmluZ3Muc3R5bGVyLmNvbG9yLFxuICAgICAgICBmaWxsVHJhbnNwYXJlbmN5OiBzdHJpbmdzLnN0eWxlci50cmFuc3BhcmVuY3lcbiAgICB9O1xuICAgIHN5bWJvbFN0eWxlci5hZGRFdmVudExpc3RlbmVyKFwiYXJjZ2lzU3ltYm9sU3R5bGVyRWRpdFwiLCBvblN0eWxlckVkaXRXcmFwcGVyLmJpbmQobnVsbCwgb25TdHlsZXJFZGl0KSk7XG4gICAgcG9wb3Zlck5vZGUuYWRkU3R5bGVyKHN5bWJvbFN0eWxlcik7XG4gICAgYXdhaXQgZWRpdDtcbn1cbmFzeW5jIGZ1bmN0aW9uIGJ1aWxkU3ltYm9sU3R5bGVyRm9yRG90RGVuc2l0eVJhbXAob3B0aW9ucykge1xuICAgIGNvbnN0IHsgbGF5ZXIsIG1hcFZpZXcsIHBvcnRhbCwgc3RyaW5ncywgbW9kdWxlcyB9ID0gc21hcnRNYXBwaW5nU3RhdGU7XG4gICAgY29uc3QgeyBvbkNoYW5nZSwgcG9wb3Zlck5vZGUgfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgcmVuZGVyZXIgPSBnZXRSZW5kZXJlcihsYXllcik7XG4gICAgY29uc3QgYXR0cmlidXRlcyA9IHJlbmRlcmVyLmF0dHJpYnV0ZXM7XG4gICAgY29uc3QgY3VycmVudENvbG9ycyA9IGF0dHJpYnV0ZXMubWFwKChhdHRyaWJ1dGUpID0+IGF0dHJpYnV0ZS5jb2xvcik7XG4gICAgY29uc3Qgc2NoZW1lcyA9IG1vZHVsZXMuZG90RGVuc2l0eVNjaGVtZXMuZ2V0U2NoZW1lcyh7XG4gICAgICAgIGJhc2VtYXA6IG1hcFZpZXcubWFwLmJhc2VtYXAsXG4gICAgICAgIG51bUNvbG9yczogYXR0cmlidXRlcy5sZW5ndGhcbiAgICB9KTtcbiAgICAvLyBUT0RPIGdldCBjdXJyZW50IHNjaGVtZVxuICAgIGNvbnN0IGNvbG9yUmFtcHNBbmRTY2hlbWVzID0gZ2V0Q29sb3JSYW1wc1dpdGhTY2hlbWVzKHNjaGVtZXMsIGF0dHJpYnV0ZXMubGVuZ3RoKTtcbiAgICBjb25zdCBjb2xvclJhbXBzID0gY29sb3JSYW1wc0FuZFNjaGVtZXMubWFwKChvYmopID0+IHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN0b3BzOiBvYmouY29sb3JzLFxuICAgICAgICAgICAgdGFnczogb2JqLnNjaGVtZS50YWdzLFxuICAgICAgICAgICAgbmFtZTogb2JqLnNjaGVtZS5uYW1lXG4gICAgICAgIH07XG4gICAgfSk7XG4gICAgY29uc3Qgb25TdHlsZXJFZGl0ID0gKHsgZGV0YWlsOiB7IFxuICAgIC8vc3ltYm9sLFxuICAgIGluZm86IHsgLyogbWFya2VyLCBzdHJva2UsICovIGZpbGwgfSB9IH0pID0+IHtcbiAgICAgICAgZ2V0UmVuZGVyZXIobGF5ZXIpLmF0dHJpYnV0ZXMuZm9yRWFjaCgoYXR0cmlidXRlLCBpZHgpID0+IChhdHRyaWJ1dGUuY29sb3IgPSBmaWxsLmNvbG9yW2lkeF0pKTtcbiAgICAgICAgb25DaGFuZ2UoKTtcbiAgICB9O1xuICAgIGNvbnN0IHN5bWJvbFN0eWxlciA9IGF3YWl0IGNyZWF0ZVN5bWJvbFN0eWxlckVsZW1lbnQocG9wb3Zlck5vZGUpO1xuICAgIGNvbnN0IGVkaXQgPSBzeW1ib2xTdHlsZXJFZGl0KHN5bWJvbFN0eWxlciwgZ2V0RGVmYXVsdFN5bWJvbChsYXllciwgbWFwVmlldyksIHtcbiAgICAgICAgcG9ydGFsLFxuICAgICAgICBzZWN0aW9uczoge1xuICAgICAgICAgICAgbWFya2VyOiB7XG4gICAgICAgICAgICAgICAgcGFydHM6IHtcbiAgICAgICAgICAgICAgICAgICAgcHJldmlldzogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIHJvdGF0aW9uOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgc2l6ZTogZmFsc2VcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZmlsbDoge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiY29sb3ItcmFtcFwiLFxuICAgICAgICAgICAgICAgIHN0eWxlOiBcImRpc2NyZXRlXCIsXG4gICAgICAgICAgICAgICAgb3BlbjogdHJ1ZSxcbiAgICAgICAgICAgICAgICBjb2xvclJhbXBzT3BlbjogdHJ1ZSxcbiAgICAgICAgICAgICAgICBjb2xvclJhbXBzXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGZpbGw6IHtcbiAgICAgICAgICAgIGNvbG9yOiBjdXJyZW50Q29sb3JzXG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBzeW1ib2xTdHlsZXIuc3RyaW5nT3ZlcnJpZGVzID0ge1xuICAgICAgICBmaWxsQ29sb3I6IHN0cmluZ3Muc3R5bGVyLmRvdENvbG9yLFxuICAgICAgICBmaWxsVHJhbnNwYXJlbmN5OiBzdHJpbmdzLnN0eWxlci5kb3RUcmFuc3BhcmVuY3lcbiAgICB9O1xuICAgIHN5bWJvbFN0eWxlci5hZGRFdmVudExpc3RlbmVyKFwiYXJjZ2lzU3ltYm9sU3R5bGVyRWRpdFwiLCBvblN0eWxlckVkaXRXcmFwcGVyLmJpbmQobnVsbCwgb25TdHlsZXJFZGl0KSk7XG4gICAgcG9wb3Zlck5vZGUuYWRkU3R5bGVyKHN5bWJvbFN0eWxlcik7XG4gICAgYXdhaXQgZWRpdDtcbn1cbmFzeW5jIGZ1bmN0aW9uIGJ1aWxkU3ltYm9sU3R5bGVyRm9yRG90RGVuc2l0eVZhbHVlKG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IGxheWVyLCBtYXBWaWV3LCBwb3J0YWwsIHN0cmluZ3MsIG1vZHVsZXMgfSA9IHNtYXJ0TWFwcGluZ1N0YXRlO1xuICAgIGNvbnN0IHsgb25DaGFuZ2UsIHBvcG92ZXJOb2RlLCBzZWxlY3RlZEF0dHJpYnV0ZSB9ID0gb3B0aW9ucztcbiAgICBjb25zdCByZW5kZXJlciA9IGdldFJlbmRlcmVyKGxheWVyKTtcbiAgICBjb25zdCBhdHRyaWJ1dGVzID0gcmVuZGVyZXIuYXR0cmlidXRlcztcbiAgICBjb25zdCBzY2hlbWVzID0gbW9kdWxlcy5kb3REZW5zaXR5U2NoZW1lcy5nZXRTY2hlbWVzKHtcbiAgICAgICAgYmFzZW1hcDogbWFwVmlldy5tYXAuYmFzZW1hcCxcbiAgICAgICAgbnVtQ29sb3JzOiBhdHRyaWJ1dGVzLmxlbmd0aFxuICAgIH0pO1xuICAgIGNvbnN0IHN1Z2dlc3RlZEZpbGxDb2xvcnMgPSBnZXRGaWxsQ29sb3JzKHNjaGVtZXMpLnNsaWNlKDAsIDE2KTtcbiAgICBjb25zdCBvblN0eWxlckVkaXQgPSAoeyBkZXRhaWw6IHsgc3ltYm9sIC8qICxcbiAgICBpbmZvOiB7IG1hcmtlciwgc3Ryb2tlLCBmaWxsIH0gKi8gfSB9KSA9PiB7XG4gICAgICAgIGdldFJlbmRlcmVyKGxheWVyKS5hdHRyaWJ1dGVzW3NlbGVjdGVkQXR0cmlidXRlXS5jb2xvciA9IGdldFN5bWJvbENvbG9yKHN5bWJvbCk7XG4gICAgICAgIG9uQ2hhbmdlKCk7XG4gICAgfTtcbiAgICBjb25zdCBzeW1ib2xTdHlsZXIgPSBhd2FpdCBjcmVhdGVTeW1ib2xTdHlsZXJFbGVtZW50KHBvcG92ZXJOb2RlKTtcbiAgICBjb25zdCBlZGl0ID0gc3ltYm9sU3R5bGVyRWRpdChzeW1ib2xTdHlsZXIsIGdldERlZmF1bHRTeW1ib2wobGF5ZXIsIG1hcFZpZXcpLCB7XG4gICAgICAgIHBvcnRhbCxcbiAgICAgICAgc2VjdGlvbnM6IHtcbiAgICAgICAgICAgIG1hcmtlcjoge1xuICAgICAgICAgICAgICAgIHBhcnRzOiB7XG4gICAgICAgICAgICAgICAgICAgIHByZXZpZXc6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICByb3RhdGlvbjogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIHNpemU6IGZhbHNlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZpbGw6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImNvbG9yXCIsXG4gICAgICAgICAgICAgICAgb3BlbjogdHJ1ZSxcbiAgICAgICAgICAgICAgICBzdWdnZXN0ZWRDb2xvcnNPcGVuOiB0cnVlLFxuICAgICAgICAgICAgICAgIHN1Z2dlc3RlZENvbG9yczogc3VnZ2VzdGVkRmlsbENvbG9yc1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBmaWxsOiB7XG4gICAgICAgICAgICBjb2xvcjogYXR0cmlidXRlc1tzZWxlY3RlZEF0dHJpYnV0ZV0uY29sb3JcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHN5bWJvbFN0eWxlci5zdHJpbmdPdmVycmlkZXMgPSB7XG4gICAgICAgIGZpbGxDb2xvcjogc3RyaW5ncy5zdHlsZXIuZG90Q29sb3IsXG4gICAgICAgIGZpbGxUcmFuc3BhcmVuY3k6IHN0cmluZ3Muc3R5bGVyLmRvdFRyYW5zcGFyZW5jeVxuICAgIH07XG4gICAgc3ltYm9sU3R5bGVyLmFkZEV2ZW50TGlzdGVuZXIoXCJhcmNnaXNTeW1ib2xTdHlsZXJFZGl0XCIsIG9uU3R5bGVyRWRpdFdyYXBwZXIuYmluZChudWxsLCBvblN0eWxlckVkaXQpKTtcbiAgICBwb3BvdmVyTm9kZS5hZGRTdHlsZXIoc3ltYm9sU3R5bGVyKTtcbiAgICBhd2FpdCBlZGl0O1xufVxuYXN5bmMgZnVuY3Rpb24gYnVpbGRTeW1ib2xTdHlsZXJGb3JIZWF0bWFwUmFtcChvcHRpb25zKSB7XG4gICAgY29uc3QgeyBsYXllciwgbWFwVmlldywgcG9ydGFsLCBzdHJpbmdzLCBtb2R1bGVzIH0gPSBzbWFydE1hcHBpbmdTdGF0ZTtcbiAgICBjb25zdCB7IG9uQ2hhbmdlLCBwb3BvdmVyTm9kZSB9ID0gb3B0aW9ucztcbiAgICBjb25zdCByZW5kZXJlciA9IGdldFJlbmRlcmVyKGxheWVyKTtcbiAgICBjb25zdCBjb2xvclN0b3BzID0gcmVuZGVyZXIuY29sb3JTdG9wcztcbiAgICBjb25zdCBjdXJyZW50Q29sb3JzID0gY29sb3JTdG9wc1xuICAgICAgICAuZmlsdGVyKChfXywgaWR4KSA9PiBpZHggPj0gMylcbiAgICAgICAgLm1hcCgoY29sb3JTdG9wKSA9PiBjb2xvclN0b3AuY29sb3IpO1xuICAgIGNvbnN0IGJhc2VtYXBUaGVtZSA9IChhd2FpdCBtb2R1bGVzLmNvbG9yVXRpbHMuZ2V0QmFja2dyb3VuZENvbG9yVGhlbWUobWFwVmlldykpO1xuICAgIGNvbnN0IHNjaGVtZXMgPSBtb2R1bGVzLmhlYXRtYXBTY2hlbWVzLmdldFNjaGVtZXMoe1xuICAgICAgICBiYXNlbWFwVGhlbWVcbiAgICB9KTtcbiAgICAvLyBUT0RPIGdldCBjdXJyZW50IHNjaGVtZVxuICAgIGNvbnN0IGNvbG9yUmFtcHNBbmRTY2hlbWVzID0gZ2V0Q29sb3JSYW1wc1dpdGhTY2hlbWVzKHNjaGVtZXMsIGNvbG9yU3RvcHMubGVuZ3RoKTtcbiAgICBjb25zdCBjb2xvclJhbXBzID0gY29sb3JSYW1wc0FuZFNjaGVtZXMubWFwKChvYmopID0+IHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN0b3BzOiBvYmouY29sb3JzLnJldmVyc2UoKSxcbiAgICAgICAgICAgIHRhZ3M6IG9iai5zY2hlbWUudGFncyxcbiAgICAgICAgICAgIG5hbWU6IG9iai5zY2hlbWUubmFtZVxuICAgICAgICB9O1xuICAgIH0pO1xuICAgIGNvbnN0IG9uU3R5bGVyRWRpdCA9ICh7IGRldGFpbDogeyBcbiAgICAvL3N5bWJvbCxcbiAgICBpbmZvOiB7IC8qIG1hcmtlciwgc3Ryb2tlLCAqLyBmaWxsIH0gfSB9KSA9PiB7XG4gICAgICAgIGNvbnN0IGNvbG9ycyA9IG1vZHVsZXMuZXNyaUxhbmcuY2xvbmUoZmlsbC5jb2xvcik7XG4gICAgICAgIGNvbG9ycy5yZXZlcnNlKCk7XG4gICAgICAgIGNvbnN0IGJ1ZiA9IE1hdGgubWF4KGNvbG9yU3RvcHMubGVuZ3RoIC0gY29sb3JzLmxlbmd0aCwgMCk7XG4gICAgICAgIGdldFJlbmRlcmVyKGxheWVyKS5jb2xvclN0b3BzLmZvckVhY2goKGNvbG9yU3RvcCwgaWR4KSA9PiB7XG4gICAgICAgICAgICAvLyBrZWVwIGFscGhhIHZhbHVlIGJlY2F1c2Ugb2YgZmFkZVJhdGlvXG4gICAgICAgICAgICBjb25zdCBhbHBoYSA9IGNvbG9yU3RvcC5jb2xvci5hO1xuICAgICAgICAgICAgaWYgKGlkeCA8PSBidWYgLSAyKSB7XG4gICAgICAgICAgICAgICAgY29sb3JTdG9wLmNvbG9yID0gbW9kdWxlcy5lc3JpTGFuZy5jbG9uZShjb2xvcnNbMF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaWR4IDw9IGJ1Zikge1xuICAgICAgICAgICAgICAgIGNvbG9yU3RvcC5jb2xvciA9IG1vZHVsZXMuZXNyaUxhbmcuY2xvbmUoY29sb3JzWzBdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbG9yU3RvcC5jb2xvciA9IG1vZHVsZXMuZXNyaUxhbmcuY2xvbmUoY29sb3JzW2lkeCAtIGJ1Zl0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29sb3JTdG9wLmNvbG9yLmEgPSBhbHBoYTtcbiAgICAgICAgfSk7XG4gICAgICAgIG9uQ2hhbmdlKCk7XG4gICAgfTtcbiAgICBjb25zdCBzeW1ib2xTdHlsZXIgPSBhd2FpdCBjcmVhdGVTeW1ib2xTdHlsZXJFbGVtZW50KHBvcG92ZXJOb2RlKTtcbiAgICBjb25zdCBlZGl0ID0gc3ltYm9sU3R5bGVyRWRpdChzeW1ib2xTdHlsZXIsIGdldERlZmF1bHRTeW1ib2wobGF5ZXIsIG1hcFZpZXcpLCB7XG4gICAgICAgIHBvcnRhbCxcbiAgICAgICAgc2VjdGlvbnM6IHtcbiAgICAgICAgICAgIG1hcmtlcjoge1xuICAgICAgICAgICAgICAgIHBhcnRzOiB7XG4gICAgICAgICAgICAgICAgICAgIHByZXZpZXc6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICByb3RhdGlvbjogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIHNpemU6IGZhbHNlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZpbGw6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImNvbG9yLXJhbXBcIixcbiAgICAgICAgICAgICAgICBzdHlsZTogXCJjb250aW51b3VzXCIsXG4gICAgICAgICAgICAgICAgb3BlbjogdHJ1ZSxcbiAgICAgICAgICAgICAgICBjb2xvclJhbXBzT3BlbjogdHJ1ZSxcbiAgICAgICAgICAgICAgICBjb2xvclJhbXBzLFxuICAgICAgICAgICAgICAgIHBhcnRzOiB7XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zcGFyZW5jeTogZmFsc2UgLy8gdGVtcCAvYXJjZ2lzLWpzLWFwaS9pc3N1ZXMvMjcxODhcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGZpbGw6IHtcbiAgICAgICAgICAgIGNvbG9yOiBjdXJyZW50Q29sb3JzLnJldmVyc2UoKVxuICAgICAgICB9XG4gICAgfSk7XG4gICAgc3ltYm9sU3R5bGVyLnN0cmluZ092ZXJyaWRlcyA9IHtcbiAgICAgICAgZmlsbFRyYW5zcGFyZW5jeTogc3RyaW5ncy5zdHlsZXIudHJhbnNwYXJlbmN5XG4gICAgfTtcbiAgICBzeW1ib2xTdHlsZXIuYWRkRXZlbnRMaXN0ZW5lcihcImFyY2dpc1N5bWJvbFN0eWxlckVkaXRcIiwgb25TdHlsZXJFZGl0V3JhcHBlci5iaW5kKG51bGwsIG9uU3R5bGVyRWRpdCkpO1xuICAgIHBvcG92ZXJOb2RlLmFkZFN0eWxlcihzeW1ib2xTdHlsZXIpO1xuICAgIGF3YWl0IGVkaXQ7XG59XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy9cbi8vICB1dGlsc1xuLy9cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5mdW5jdGlvbiB1cGRhdGVBdXRvVmlzVmFyKHN5bWJvbCwgbWFya2VyQXV0b0FkanVzdGVkLCBzdHJva2VBdXRvQWRqdXN0ZWQsIHN5bWJvbFN0eWxlciwgb3B0aW9ucykge1xuICAgIGNvbnN0IHsgbGF5ZXIsIG1vZHVsZXMgfSA9IHNtYXJ0TWFwcGluZ1N0YXRlO1xuICAgIGNvbnN0IGlzUG9pbnQgPSBpc1BvaW50VHlwZShsYXllcik7XG4gICAgY29uc3QgaXNMaW5lID0gaXNQb2x5bGluZVR5cGUobGF5ZXIpO1xuICAgIGlmIChpc1BvaW50KSB7XG4gICAgICAgIHVwZGF0ZVNpemVBdXRvVmlzVmFyKG1hcmtlckF1dG9BZGp1c3RlZCwgZ2V0U3ltYm9sU2l6ZShzeW1ib2wpLCBzeW1ib2wsIHN5bWJvbFN0eWxlciwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzTGluZSkge1xuICAgICAgICB1cGRhdGVTaXplQXV0b1Zpc1ZhcihzdHJva2VBdXRvQWRqdXN0ZWQsIGdldFN5bWJvbFNpemUoc3ltYm9sKSwgc3ltYm9sLCBzeW1ib2xTdHlsZXIsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdXBkYXRlT3V0bGluZUF1dG9WaXNWYXIoc3Ryb2tlQXV0b0FkanVzdGVkLCBzeW1ib2wudHlwZSA9PT0gXCJjaW1cIlxuICAgICAgICAgICAgPyBnZXRDSU1PdXRsaW5lV2lkdGgoc3ltYm9sKVxuICAgICAgICAgICAgOiBnZXRTeW1ib2xTaXplKHN5bWJvbC5vdXRsaW5lIHx8IG5ldyBtb2R1bGVzLlNpbXBsZUxpbmVTeW1ib2woKSksIHN5bWJvbCwgc3ltYm9sU3R5bGVyLCBvcHRpb25zKTtcbiAgICB9XG59XG5mdW5jdGlvbiB1cGRhdGVTaXplQXV0b1Zpc1ZhcihhdXRvQWRqdXN0ZWQsIG5ld1NpemUsIHN5bWJvbCwgc3ltYm9sU3R5bGVyLCBvcHRpb25zKSB7XG4gICAgY29uc3QgeyBsYXllciwgbWFwVmlldyB9ID0gc21hcnRNYXBwaW5nU3RhdGU7XG4gICAgY29uc3QgeyBvbkNoYW5nZSB9ID0gb3B0aW9ucztcbiAgICBjb25zdCByZW5kZXJlciA9IGdldFJlbmRlcmVyKGxheWVyKTtcbiAgICBuZXdTaXplID0gTWF0aC5tYXgobmV3U2l6ZSwgMC4xKTtcbiAgICBjb25zdCBzaXplQXV0b1Zpc1ZhciA9IGdldFZpc1ZhcihyZW5kZXJlciwgXCJzaXplXCIsIFwiYXV0b1wiKTtcbiAgICBpZiAoYXV0b0FkanVzdGVkICYmICFzaXplQXV0b1Zpc1Zhcikge1xuICAgICAgICAvLyBuZWVkIHRvIGNyZWF0ZSB0aGF0IHZpc3VhbFZhcmlhYmxlXG4gICAgICAgIGJ1aWxkU2l6ZUF1dG9WaXNWYXIoKS50aGVuKChzaXplQXV0b1Zpc1ZhcikgPT4ge1xuICAgICAgICAgICAgaWYgKHNpemVBdXRvVmlzVmFyKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVuZCA9IGdldFJlbmRlcmVyKGxheWVyKTtcbiAgICAgICAgICAgICAgICByZW5kLnZpc3VhbFZhcmlhYmxlcyA9IHJlbmQudmlzdWFsVmFyaWFibGVzIHx8IFtdO1xuICAgICAgICAgICAgICAgIHJlbmQudmlzdWFsVmFyaWFibGVzLnB1c2goc2l6ZUF1dG9WaXNWYXIpO1xuICAgICAgICAgICAgICAgIGlmIChpc0NpbUxpbmVTeW1ib2woc3ltYm9sKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyB1cGRhdGUgc2l6ZUF1dG9WaXNWYXIgYW5kIHVzZSBjdXJyZW50IHN5bWJvbCBzaXplXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG9sZFNpemUgPSBnZXRTeW1ib2xTaXplKHN5bWJvbCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld1NpemUgPSBnZXRTaXplQnlTY2FsZShzaXplQXV0b1Zpc1ZhciwgbWFwVmlldy5zY2FsZSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZhY3RvciA9IG9sZFNpemUgLyBuZXdTaXplO1xuICAgICAgICAgICAgICAgICAgICB1cGRhdGVBdXRvU2l6ZVN0b3BzKHNpemVBdXRvVmlzVmFyLCBmYWN0b3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBkaXNwbGF5IG5ldyAoZGVmYXVsdCkgc2l6ZSBpbiBTeW1ib2xTdHlsZXJcbiAgICAgICAgICAgICAgICB1cGRhdGVTeW1ib2xTdHlsZXJXaXRoU2l6ZShzaXplQXV0b1Zpc1ZhciwgbWFwVmlldy5zY2FsZSwgc3ltYm9sLCBzeW1ib2xTdHlsZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb25DaGFuZ2UoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKCFhdXRvQWRqdXN0ZWQgJiYgc2l6ZUF1dG9WaXNWYXIpIHtcbiAgICAgICAgLy8gcmVtb3ZlIHZpc3VhbFZhcmlhYmxlXG4gICAgICAgIGNvbnN0IHZpc1ZhcnMgPSBnZXRWaXNWYXJzRXhjZXB0KHJlbmRlcmVyLCBcInNpemVcIiwgXCJhdXRvXCIpO1xuICAgICAgICBpZiAodmlzVmFycyA9PT0gbnVsbCB8fCB2aXNWYXJzID09PSB2b2lkIDAgPyB2b2lkIDAgOiB2aXNWYXJzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmVuZGVyZXIudmlzdWFsVmFyaWFibGVzID0gdmlzVmFycztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlbmRlcmVyLnZpc3VhbFZhcmlhYmxlcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICAvL3N5bWJvbFN0eWxlci5zZXRTaXplKHN5bWJvbFR5cGUgPT09IFwic2ltcGxlLWxpbmVcIiA/IFwic3Ryb2tlXCIgOiBcIm1hcmtlclwiLCBuZXdTaXplKTtcbiAgICAgICAgb25DaGFuZ2UoKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmIChhdXRvQWRqdXN0ZWQpIHtcbiAgICAgICAgICAgIGFkanVzdEF1dG9TaXplRm9yU3ltYm9sKG5ld1NpemUpO1xuICAgICAgICB9XG4gICAgICAgIG9uQ2hhbmdlKCk7XG4gICAgfVxufVxuZnVuY3Rpb24gYWRqdXN0QXV0b1NpemVGb3JTeW1ib2wobmV3U2l6ZSkge1xuICAgIGNvbnN0IHsgbGF5ZXIsIG1hcFZpZXcgfSA9IHNtYXJ0TWFwcGluZ1N0YXRlO1xuICAgIGNvbnN0IHNjYWxlID0gbWFwVmlldy5zY2FsZTtcbiAgICBjb25zdCByZW5kZXJlciA9IGdldFJlbmRlcmVyKGxheWVyKTtcbiAgICBjb25zdCBzaXplQXV0b1Zpc1ZhciA9IGdldFZpc1ZhcihyZW5kZXJlciwgXCJzaXplXCIsIFwiYXV0b1wiKTtcbiAgICBjb25zdCBvbGRTaXplID0gZ2V0U2l6ZUJ5U2NhbGUoc2l6ZUF1dG9WaXNWYXIsIHNjYWxlKTtcbiAgICBjb25zdCBmYWN0b3IgPSBuZXdTaXplIC8gb2xkU2l6ZTtcbiAgICB1cGRhdGVBdXRvU2l6ZVN0b3BzKHNpemVBdXRvVmlzVmFyLCBmYWN0b3IpO1xufVxuZnVuY3Rpb24gdXBkYXRlT3V0bGluZUF1dG9WaXNWYXIoYXV0b0FkanVzdGVkLCBuZXdTaXplLCBzeW1ib2wsIHN5bWJvbFN0eWxlciwgb3B0aW9ucykge1xuICAgIGNvbnN0IHsgbGF5ZXIsIG1hcFZpZXcgfSA9IHNtYXJ0TWFwcGluZ1N0YXRlO1xuICAgIGNvbnN0IHsgb25DaGFuZ2UgfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgcmVuZGVyZXIgPSBnZXRSZW5kZXJlcihsYXllcik7XG4gICAgY29uc3Qgc2l6ZU91dGxpbmVWaXNWYXIgPSBnZXRWaXNWYXIocmVuZGVyZXIsIFwic2l6ZVwiLCBcIm91dGxpbmVcIik7XG4gICAgaWYgKGF1dG9BZGp1c3RlZCAmJiAhc2l6ZU91dGxpbmVWaXNWYXIpIHtcbiAgICAgICAgLy8gbmVlZCB0byBjcmVhdGUgdGhhdCB2aXN1YWxWYXJpYWJsZVxuICAgICAgICBidWlsZE91dGxpbmVWaXNWYXIoKS50aGVuKChzaXplT3V0bGluZVZpc1ZhcikgPT4ge1xuICAgICAgICAgICAgaWYgKHNpemVPdXRsaW5lVmlzVmFyKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVuZCA9IGdldFJlbmRlcmVyKGxheWVyKTtcbiAgICAgICAgICAgICAgICByZW5kLnZpc3VhbFZhcmlhYmxlcyA9IHJlbmQudmlzdWFsVmFyaWFibGVzIHx8IFtdO1xuICAgICAgICAgICAgICAgIHJlbmQudmlzdWFsVmFyaWFibGVzLnB1c2goc2l6ZU91dGxpbmVWaXNWYXIpO1xuICAgICAgICAgICAgICAgIHVwZGF0ZVN5bWJvbFN0eWxlcldpdGhTaXplKHNpemVPdXRsaW5lVmlzVmFyLCBtYXBWaWV3LnNjYWxlLCBzeW1ib2wsIHN5bWJvbFN0eWxlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvbkNoYW5nZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoIWF1dG9BZGp1c3RlZCAmJiBzaXplT3V0bGluZVZpc1Zhcikge1xuICAgICAgICAvLyByZW1vdmUgdmlzdWFsVmFyaWFibGVcbiAgICAgICAgcmVuZGVyZXIudmlzdWFsVmFyaWFibGVzID0gcmVuZGVyZXIudmlzdWFsVmFyaWFibGVzLmZpbHRlcigodmlzVmFyKSA9PiAhKHZpc1Zhci50eXBlID09PSBcInNpemVcIiAmJiB2aXNWYXIudGFyZ2V0ID09PSBcIm91dGxpbmVcIikpO1xuICAgICAgICBpZiAocmVuZGVyZXIudmlzdWFsVmFyaWFibGVzICYmICFyZW5kZXJlci52aXN1YWxWYXJpYWJsZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZW5kZXJlci52aXN1YWxWYXJpYWJsZXMgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgb25DaGFuZ2UoKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmIChhdXRvQWRqdXN0ZWQpIHtcbiAgICAgICAgICAgIGFkanVzdEF1dG9PdXRsaW5lKG5ld1NpemUsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIG9uQ2hhbmdlKCk7XG4gICAgfVxufVxuZnVuY3Rpb24gYWRqdXN0QXV0b091dGxpbmUobmV3U2l6ZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IHsgbGF5ZXIsIG1hcFZpZXcgfSA9IHNtYXJ0TWFwcGluZ1N0YXRlO1xuICAgIGNvbnN0IHsgb25DaGFuZ2UgfSA9IG9wdGlvbnM7XG4gICAgY29uc3Qgc2NhbGUgPSBtYXBWaWV3LnNjYWxlO1xuICAgIGxldCByZW5kZXJlciA9IGdldFJlbmRlcmVyKGxheWVyKTtcbiAgICBjb25zdCBzaXplQXV0b1Zpc1ZhciA9IGdldFZpc1ZhcihyZW5kZXJlciwgXCJzaXplXCIsIFwib3V0bGluZVwiKTtcbiAgICAvKiBjb25zb2xlLmxvZyhcbiAgICAgIFwic2l6ZUF1dG9WaXNWYXIgMVwiLFxuICAgICAgc2l6ZUF1dG9WaXNWYXIuc3RvcHMubWFwKChzOiBhbnkpID0+IHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzaXplOiBzLnNpemUsXG4gICAgICAgICAgc2l6ZVB4OiBNYXRoLnJvdW5kKChzLnNpemUgLyAwLjc1KSAqIDEwMCkgLyAxMDAsXG4gICAgICAgICAgdmFsdWU6IG5ldyBJbnRsLk51bWJlckZvcm1hdCgpLmZvcm1hdChzLnZhbHVlKVxuICAgICAgICB9O1xuICAgICAgfSlcbiAgICApOyAqL1xuICAgIGNvbnN0IHN0b3BzID0gc2l6ZUF1dG9WaXNWYXIuc3RvcHM7XG4gICAgaWYgKG5ld1NpemUgIT09IDAgJiYgc3RvcHNbc3RvcHMubGVuZ3RoIC0gMl0uc2l6ZSA9PT0gMCkge1xuICAgICAgICAvLyAyIG9yIG1vcmUgc3RvcHMgaGF2ZSB2YWx1ZSB6ZXJvOyBidWlsZCBuZXcgc3RvcHNcbiAgICAgICAgYnVpbGRPdXRsaW5lVmlzVmFyKCkudGhlbigoc2l6ZU91dGxpbmVWaXNWYXIpID0+IHtcbiAgICAgICAgICAgIGlmIChzaXplT3V0bGluZVZpc1Zhcikge1xuICAgICAgICAgICAgICAgIGNvbnN0IG9sZFNpemUgPSBnZXRTaXplQnlTY2FsZShzaXplT3V0bGluZVZpc1Zhciwgc2NhbGUpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGZhY3RvciA9IChuZXdTaXplID09PSAwID8gTWF0aC5tYXgoMC41LCBuZXdTaXplKSA6IG5ld1NpemUpIC8gKG9sZFNpemUgPT09IDAgPyBNYXRoLm1heCgwLjUsIG9sZFNpemUpIDogb2xkU2l6ZSk7XG4gICAgICAgICAgICAgICAgdXBkYXRlQXV0b1NpemVTdG9wcyhzaXplT3V0bGluZVZpc1ZhciwgZmFjdG9yKTtcbiAgICAgICAgICAgICAgICBjb25zdCB2aXNWYXJzID0gZ2V0VmlzVmFyc0V4Y2VwdChnZXRSZW5kZXJlcihsYXllciksIFwic2l6ZVwiLCBcIm91dGxpbmVcIikgfHwgW107XG4gICAgICAgICAgICAgICAgdmlzVmFycy5wdXNoKHNpemVPdXRsaW5lVmlzVmFyKTtcbiAgICAgICAgICAgICAgICBnZXRSZW5kZXJlcihsYXllcikudmlzdWFsVmFyaWFibGVzID0gdmlzVmFyczsgLy8gbm90IHJlbmRlcmVyLnZpc3VhbFZhcmlhYmxlcyA9IHZpc1ZhcnM7XG4gICAgICAgICAgICAgICAgb25DaGFuZ2UoKTtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHsgfSwgMjAwMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3Qgb2xkU2l6ZSA9IGdldFNpemVCeVNjYWxlKHNpemVBdXRvVmlzVmFyLCBzY2FsZSk7XG4gICAgICAgIGNvbnN0IGZhY3RvciA9IChuZXdTaXplID09PSAwID8gTWF0aC5tYXgoMC41LCBuZXdTaXplKSA6IG5ld1NpemUpIC8gKG9sZFNpemUgPT09IDAgPyBNYXRoLm1heCgwLjUsIG9sZFNpemUpIDogb2xkU2l6ZSk7XG4gICAgICAgIHVwZGF0ZUF1dG9TaXplU3RvcHMoc2l6ZUF1dG9WaXNWYXIsIGZhY3Rvcik7XG4gICAgICAgIGlmIChuZXdTaXplID09PSAwIHx8IG9sZFNpemUgPT09IDApIHtcbiAgICAgICAgICAgIC8vIGJlY2F1c2Ugd2UgYWRqdXN0ZWQgdGhlIGZhY3Rvci4uLlxuICAgICAgICAgICAgc2V0U2l6ZUJ5U2NhbGVUb1ZhbHVlKHNpemVBdXRvVmlzVmFyLCBzY2FsZSwgbmV3U2l6ZSk7XG4gICAgICAgICAgICAvLyBwcmV2ZW50IDIgc3RvcHMgd2l0aCBzYW1lIHNpemUuLi5cbiAgICAgICAgICAgIHNpemVBdXRvVmlzVmFyLnN0b3BzLmZvckVhY2goKHMsIGlkeCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChpZHggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzLnNpemUgPT09IHNpemVBdXRvVmlzVmFyLnN0b3BzW2lkeCAtIDFdLnNpemUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdlIGRvbid0IHdhbnQgdHdpY2UgdGhlIHNhbWUgc2l6ZVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlkeCA9PT0gc2l6ZUF1dG9WaXNWYXIuc3RvcHMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpZHggPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpemVBdXRvVmlzVmFyLnN0b3BzW2lkeCAtIDFdLnNpemUgPSAoc2l6ZUF1dG9WaXNWYXIuc3RvcHNbaWR4IC0gMl0uc2l6ZSArIHMuc2l6ZSkgLyAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gLy8gZWxzZSBzaG91bGQgbm90IGhhcHBlbjsgdGhlbiBjaGFuZ2Ugbm90aGluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGFrZSBtaWRkbGUgc2l6ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMuc2l6ZSA9IChzaXplQXV0b1Zpc1Zhci5zdG9wc1tpZHggKyAxXS5zaXplICsgc2l6ZUF1dG9WaXNWYXIuc3RvcHNbaWR4IC0gMV0uc2l6ZSkgLyAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBzZXRTaXplQnlTY2FsZVRvVmFsdWUoc2l6ZUF1dG9WaXNWYXIsIHNjYWxlLCB2YWx1ZSkge1xuICAgIC8vIGZpZ3VyZSBvdXQgY3VycmVudCBzdG9wIGNvbnNpZGVyaW5nIG1hcCBzY2FsZVxuICAgIC8vIHRoZW4gc2V0IHRoYXQgdmFsdWUgYW5kIGFsbCB0aGUgb25lcyB3aXRoIGEgbGFyZ2VyIHNjYWxlIHRvIDBcbiAgICBjb25zdCBzaXplU3RvcHMgPSBzaXplQXV0b1Zpc1Zhci5zdG9wcztcbiAgICBjb25zdCBzdG9wc0NvdW50ID0gc2l6ZVN0b3BzLmxlbmd0aDtcbiAgICBjb25zdCBmaW5hbEluZGV4ID0gc3RvcHNDb3VudCAtIDE7XG4gICAgY29uc3Qgc2NhbGVNaW4gPSBzaXplU3RvcHNbMF0udmFsdWU7XG4gICAgY29uc3Qgc2NhbGVNYXggPSBzaXplU3RvcHNbZmluYWxJbmRleF0udmFsdWU7XG4gICAgaWYgKHNjYWxlIDw9IHNjYWxlTWluKSB7XG4gICAgICAgIC8vIGV2ZXJ5dGhpbmcgc2V0IHRvIHZhbHVlXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDw9IGZpbmFsSW5kZXg7IGkrKykge1xuICAgICAgICAgICAgc2l6ZVN0b3BzW2ldLnNpemUgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChzY2FsZSA+PSBzY2FsZU1heCkge1xuICAgICAgICBzaXplU3RvcHNbZmluYWxJbmRleF0uc2l6ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZmluYWxJbmRleDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRTdG9wID0gc2l6ZVN0b3BzW2ldO1xuICAgICAgICBjb25zdCBuZXh0U3RvcCA9IHNpemVTdG9wc1tpICsgMV07XG4gICAgICAgIGlmIChzY2FsZSA+PSBjdXJyZW50U3RvcC52YWx1ZSAmJiBzY2FsZSA8IG5leHRTdG9wLnZhbHVlKSB7XG4gICAgICAgICAgICAvLyBzZXQgY3VycmVudCBzdG9wIGFuZCBhbGwgd2l0aCBsb3dlciBzY2FsZSB0byB2YWx1ZVxuICAgICAgICAgICAgZm9yIChsZXQgayA9IGkgKyAxOyBrIDw9IGZpbmFsSW5kZXg7IGsrKykge1xuICAgICAgICAgICAgICAgIHNpemVTdG9wc1trXS5zaXplID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIHVwZGF0ZUF1dG9TaXplU3RvcHMoc2l6ZUF1dG9WaXNWYXIsIGZhY3Rvcikge1xuICAgIHNpemVBdXRvVmlzVmFyLnN0b3BzLmZvckVhY2goKHN0b3ApID0+IHtcbiAgICAgICAgc3RvcC5zaXplICo9IGZhY3RvcjtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVdhdGNoU2NhbGVIYW5kbGUoc3ltYm9sLCBzeW1ib2xTdHlsZXIsIG9uU2l6ZUNoYW5nZUhhbmRsZXIpIHtcbiAgICBjb25zdCB7IGxheWVyLCBtYXBWaWV3LCBtb2R1bGVzIH0gPSBzbWFydE1hcHBpbmdTdGF0ZTtcbiAgICBsZXQgb2xkU2NhbGU7XG4gICAgcmV0dXJuIG1vZHVsZXMucmVhY3RpdmVVdGlscy53aGVuKCgpID0+IG1hcFZpZXcuc3RhdGlvbmFyeSwgKCkgPT4ge1xuICAgICAgICBjb25zdCBuZXdTY2FsZSA9IG1hcFZpZXcuc2NhbGU7XG4gICAgICAgIGlmIChvbGRTY2FsZSAhPT0gbmV3U2NhbGUpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlbmRlcmVyID0gZ2V0UmVuZGVyZXIobGF5ZXIpO1xuICAgICAgICAgICAgY29uc3Qgc2l6ZUF1dG9WaXNWYXIgPSBnZXRWaXNWYXIocmVuZGVyZXIsIFwic2l6ZVwiLCBzeW1ib2wudHlwZSA9PT0gXCJzaW1wbGUtZmlsbFwiID8gXCJvdXRsaW5lXCIgOiBcImF1dG9cIik7XG4gICAgICAgICAgICBpZiAoc2l6ZUF1dG9WaXNWYXIpIHtcbiAgICAgICAgICAgICAgICAvKiBjb25zb2xlLmxvZyhcbiAgICAgICAgICAgICAgICBcInNjYWxlXCIsXG4gICAgICAgICAgICAgICAgbmV3IEludGwuTnVtYmVyRm9ybWF0KCkuZm9ybWF0KG5ld1NjYWxlKSxcbiAgICAgICAgICAgICAgICBcInNpemVcIixcbiAgICAgICAgICAgICAgICBnZXRTaXplQnlTY2FsZShzaXplQXV0b1Zpc1ZhciwgbmV3U2NhbGUpLFxuICAgICAgICAgICAgICAgIFwic2l6ZVB4XCIsXG4gICAgICAgICAgICAgICAgTWF0aC5yb3VuZCgoZ2V0U2l6ZUJ5U2NhbGUoc2l6ZUF1dG9WaXNWYXIsIG5ld1NjYWxlKSAvIDAuNzUpICogMTAwKSAvIDEwMFxuICAgICAgICAgICAgICApOyAqL1xuICAgICAgICAgICAgICAgIHVwZGF0ZVN5bWJvbFN0eWxlcldpdGhTaXplKHNpemVBdXRvVmlzVmFyLCBuZXdTY2FsZSwgc3ltYm9sLCBzeW1ib2xTdHlsZXIsIG9uU2l6ZUNoYW5nZUhhbmRsZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb2xkU2NhbGUgPSBuZXdTY2FsZTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuZnVuY3Rpb24gdXBkYXRlU3ltYm9sU3R5bGVyV2l0aFNpemUoc2l6ZUF1dG9WaXNWYXIsIG5ld1NjYWxlLCBzeW1ib2wsIHN5bWJvbFN0eWxlciwgb25TaXplQ2hhbmdlSGFuZGxlcikge1xuICAgIGNvbnN0IG5ld1NpemUgPSBnZXRTaXplQnlTY2FsZShzaXplQXV0b1Zpc1ZhciwgbmV3U2NhbGUpO1xuICAgIGNvbnN0IHR5cGUgPSBbXCJzaW1wbGUtbGluZVwiLCBcInNpbXBsZS1maWxsXCJdLmluZGV4T2Yoc3ltYm9sLnR5cGUpID4gLTEgfHwgaXNDaW1MaW5lU3ltYm9sKHN5bWJvbCkgPyBcInN0cm9rZVwiIDogXCJtYXJrZXJcIjtcbiAgICBzeW1ib2xTdHlsZXIuc2V0U2l6ZSh0eXBlLCBuZXdTaXplKTtcbiAgICBvblNpemVDaGFuZ2VIYW5kbGVyID09PSBudWxsIHx8IG9uU2l6ZUNoYW5nZUhhbmRsZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9uU2l6ZUNoYW5nZUhhbmRsZXIobmV3U2l6ZSk7XG59XG5mdW5jdGlvbiBhZGp1c3RBbHBoYShjb2xvciwgYWxwaGEpIHtcbiAgICBpZiAoY29sb3IpIHtcbiAgICAgICAgY29sb3IuYSA9IGFscGhhO1xuICAgIH1cbiAgICByZXR1cm4gY29sb3I7XG59XG5mdW5jdGlvbiBnZXRDaW1MaW5lUHJvcHMoc3ltKSB7XG4gICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgLy8gcG9pbnQ6IG91dGxpbmVcbiAgICAvLyBsaW5lOiBtYWluIGxpbmVcbiAgICAvLyBwb2x5Z29uOiBvdXRsaW5lXG4gICAgY29uc3QgeyBtb2R1bGVzIH0gPSBzbWFydE1hcHBpbmdTdGF0ZTtcbiAgICBpZiAoaXNDaW1MaW5lU3ltYm9sKHN5bSkpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNvbG9yOiAoKF9hID0gZ2V0U3ltYm9sQ29sb3Ioc3ltKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNsb25lKCkpIHx8IG5ldyBtb2R1bGVzLmVzcmlDb2xvcihbMjU1LCAyNTUsIDI1NSwgMC41XSksXG4gICAgICAgICAgICBzaXplOiAoX2IgPSBnZXRTeW1ib2xTaXplKHN5bSkpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IDFcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IG91dGxpbmUgPSBnZXRDaW1MaW5lKHN5bSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjb2xvcjogbmV3IG1vZHVsZXMuZXNyaUNvbG9yKG91dGxpbmUgPT09IG51bGwgfHwgb3V0bGluZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3V0bGluZS5jb2xvcikgfHwgbmV3IG1vZHVsZXMuZXNyaUNvbG9yKFsyNTUsIDI1NSwgMjU1LCAwLjVdKSxcbiAgICAgICAgICAgIHNpemU6IChfYyA9IG91dGxpbmUgPT09IG51bGwgfHwgb3V0bGluZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3V0bGluZS53aWR0aCkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogMVxuICAgICAgICB9O1xuICAgIH1cbn1cbmZ1bmN0aW9uIGlzU3VwcG9ydGVkU3ltYm9sKHN5bSkge1xuICAgIHJldHVybiBbXCJzaW1wbGUtZmlsbFwiLCBcInNpbXBsZS1tYXJrZXJcIiwgXCJzaW1wbGUtbGluZVwiLCBcInBpY3R1cmUtbWFya2VyXCIsIFwiY2ltXCJdLmluZGV4T2Yoc3ltID09PSBudWxsIHx8IHN5bSA9PT0gdm9pZCAwID8gdm9pZCAwIDogc3ltLnR5cGUpID4gLTE7XG59XG5mdW5jdGlvbiBpc0NvbG9yZWRTeW1ib2woc3ltKSB7XG4gICAgcmV0dXJuIFtcInNpbXBsZS1maWxsXCIsIFwic2ltcGxlLW1hcmtlclwiLCBcInNpbXBsZS1saW5lXCIsIFwiY2ltXCJdLmluZGV4T2Yoc3ltLnR5cGUpID4gLTE7XG59XG4vKiBmdW5jdGlvbiBwcmludFN5bWJvbFByb3BzKHRleHQ6IHN0cmluZywgc3ltOiBhbnkpIHtcbiAgY29uc29sZS5sb2coXG4gICAgdGV4dCxcbiAgICBzeW0udHlwZSxcbiAgICBzeW0udHlwZSA9PT0gXCJjaW1cIiA/IGNpbVN5bWJvbFV0aWxzLmdldENJTVN5bWJvbFNpemUoc3ltKSA6IHN5bS5zaXplID8/IHN5bS53aWR0aCxcbiAgICBzeW0udHlwZSA9PT0gXCJjaW1cIiA/IGNpbVN5bWJvbFV0aWxzLmdldENJTVN5bWJvbENvbG9yKHN5bSkudG9KU09OKCkgOiBzeW0uY29sb3IudG9KU09OKCksXG4gICAgc3ltLnR5cGUgPT09IFwiY2ltXCIgPyBnZXRDaW1Qb2ludE91dGxpbmUoc3ltKT8uY29sb3IgOiBzeW0ub3V0bGluZT8uY29sb3I/LnRvSlNPTigpLFxuICAgIHN5bS50eXBlID09PSBcImNpbVwiID8gZ2V0Q2ltUG9pbnRPdXRsaW5lKHN5bSk/LndpZHRoIDogc3ltLm91dGxpbmU/LndpZHRoXG4gICk7XG59ICovXG5cbmV4cG9ydCB7IGJ1aWxkU3ltYm9sU3R5bGVyRm9yQ2hhcnRWYWx1ZSBhcyBhLCBidWlsZFN5bWJvbFN0eWxlckZvckRvdERlbnNpdHlWYWx1ZSBhcyBiLCBjcmVhdGVTeW1ib2xTdHlsZXJQb3BvdmVyIGFzIGMsIGJ1aWxkU3ltYm9sU3R5bGVyRm9yUHJlZG9taW5hbmNlVmFsdWUgYXMgZCwgYnVpbGRTeW1ib2xTdHlsZXJGb3JUeXBlR3JvdXAgYXMgZSwgYnVpbGRTeW1ib2xTdHlsZXJGb3JUeXBlVmFsdWUgYXMgZiwgYnVpbGRTeW1ib2xTdHlsZXJGb3JDbGFzc2VkIGFzIGcsIGdldFJhbmdlVmFsdWVzIGFzIGgsIGJ1aWxkU3ltYm9sU3R5bGVyRm9yRGVmYXVsdCBhcyBpLCBidWlsZFN5bWJvbFN0eWxlckZvclR5cGVSYW1wIGFzIGosIGJ1aWxkU3ltYm9sU3R5bGVyRm9yQ2hhcnRSYW1wIGFzIGssIGJ1aWxkU3ltYm9sU3R5bGVyRm9yQ29sb3JTaXplQmVsb3cgYXMgbCwgYnVpbGRTeW1ib2xTdHlsZXJGb3JDb2xvclNpemVBYm92ZSBhcyBtLCBidWlsZFN5bWJvbFN0eWxlckZvclByZWRvbWluYW5jZVJhbXAgYXMgbiwgYnVpbGRTeW1ib2xTdHlsZXJGb3JCYWNrZ3JvdW5kIGFzIG8sIGJ1aWxkU3ltYm9sU3R5bGVyRm9ySGVhdG1hcFJhbXAgYXMgcCwgYnVpbGRTeW1ib2xTdHlsZXJGb3JEb3REZW5zaXR5QmFja2dyb3VuZCBhcyBxLCByZW1vdmVTeW1ib2xTdHlsZXJQb3BvdmVyIGFzIHIsIHNldFJhbmdlVmFsdWVzIGFzIHMsIGJ1aWxkU3ltYm9sU3R5bGVyRm9yRG90RGVuc2l0eVJhbXAgYXMgdCwgYnVpbGRTeW1ib2xTdHlsZXJGb3JHZW9SU1MgYXMgdSwgYnVpbGRTeW1ib2xTdHlsZXJGb3JSZWxhdGlvbnNoaXBSYW1wIGFzIHYsIGJ1aWxkU3ltYm9sU3R5bGVyRm9yQ29sb3JSYW1wIGFzIHcsIGJ1aWxkU3ltYm9sU3R5bGVyRm9yU2l6ZSBhcyB4LCBidWlsZFN5bWJvbFN0eWxlckZvclNpbXBsZSBhcyB5IH07XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN5bWJvbFN0eWxlci0wNDYzNWIyYi5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=