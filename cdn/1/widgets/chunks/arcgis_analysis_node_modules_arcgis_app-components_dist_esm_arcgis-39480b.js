"use strict";
(self["webpackChunkexb_client"] = self["webpackChunkexb_client"] || []).push([["vendors-extensions_widgets_arcgis_analysis_node_modules_arcgis_app-components_dist_esm_arcgis-39480b"],{

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/arcgis-smart-mapping-color-slider.entry.js":
/*!************************************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/arcgis-smart-mapping-color-slider.entry.js ***!
  \************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   arcgis_smart_mapping_color_slider: () => (/* binding */ ArcgisSmartMappingColorSlider)
/* harmony export */ });
/* harmony import */ var _index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index-e3bf7da7.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/index-e3bf7da7.js");
/* harmony import */ var _raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./raster-unique-value-0976ec7f.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/raster-unique-value-0976ec7f.js");
/* harmony import */ var _date_79c7d93c_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./date-79c7d93c.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/date-79c7d93c.js");
/* harmony import */ var _loading_69139907_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./loading-69139907.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/loading-69139907.js");
/* harmony import */ var _loadModules_b4ac1247_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./loadModules-b4ac1247.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/loadModules-b4ac1247.js");
/* harmony import */ var _precision_06a73672_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./precision-06a73672.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/precision-06a73672.js");
/* harmony import */ var _commonEnums_fcf13661_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./commonEnums-fcf13661.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/commonEnums-fcf13661.js");
/* harmony import */ var _slider_e162e136_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./slider-e162e136.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/slider-e162e136.js");
/* harmony import */ var _color_d6da0a9a_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./color-d6da0a9a.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/color-d6da0a9a.js");
/* harmony import */ var _compare_ba1292fe_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./compare-ba1292fe.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/compare-ba1292fe.js");
/* harmony import */ var _colorSize_ce0ccdeb_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./colorSize-ce0ccdeb.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/colorSize-ce0ccdeb.js");
/* harmony import */ var _languageUtil_ef0e54b2_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./languageUtil-ef0e54b2.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/languageUtil-ef0e54b2.js");
/* harmony import */ var _dom_4d367677_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./dom-4d367677.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/dom-4d367677.js");
/* harmony import */ var _locale_050b6db9_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./locale-050b6db9.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/locale-050b6db9.js");
/* harmony import */ var _index_05956cab_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./index-05956cab.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/index-05956cab.js");
/* harmony import */ var _commonFunctions_b0830e9e_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./commonFunctions-b0830e9e.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/commonFunctions-b0830e9e.js");
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v4.0.58
 */

















const arcgisSmartMappingColorSliderCss = ".slider-box{height:320px}.slider-box .esri-color-slider,.slider-box .esri-classed-color-slider{min-width:200px}.slider-box .esri-color-slider .esri-slider .esri-slider__content,.slider-box .esri-classed-color-slider .esri-slider .esri-slider__content{height:175px}.slider-box .esri-color-slider__histogram-container,.slider-box .esri-classed-color-slider__histogram-container{width:85px}.slider-box .esri-color-slider .esri-slider .esri-slider__label,.slider-box .esri-color-slider .esri-slider .esri-slider__min,.slider-box .esri-color-slider .esri-slider .esri-slider__max,.slider-box .esri-classed-color-slider .esri-slider .esri-slider__label,.slider-box .esri-classed-color-slider .esri-slider .esri-slider__min,.slider-box .esri-classed-color-slider .esri-slider .esri-slider__max{text-decoration:underline}.slider-box .esri-color-slider .esri-slider .esri-slider__label:hover,.slider-box .esri-color-slider .esri-slider .esri-slider__min:hover,.slider-box .esri-color-slider .esri-slider .esri-slider__max:hover,.slider-box .esri-classed-color-slider .esri-slider .esri-slider__label:hover,.slider-box .esri-classed-color-slider .esri-slider .esri-slider__min:hover,.slider-box .esri-classed-color-slider .esri-slider .esri-slider__max:hover{border:1px solid #bbb;background-color:#f3f3f3;text-decoration:none;z-index:1}.slider-box-buttons-front{display:flex}";

const ArcgisSmartMappingColorSlider = class {
    constructor(hostRef) {
        (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.r)(this, hostRef);
        this.arcgisSmartMappingColorSliderChange = (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, "arcgisSmartMappingColorSliderChange", 7);
        this.arcgisSmartMappingColorSliderError = (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, "arcgisSmartMappingColorSliderError", 7);
        /**
         * Necessary for tracking stops for non-classed sliders,
         * whose values are updated immediately even given incorrect inputs.
         * Classed sliders do not have this issue, but we handle them
         * identically for logical parity.
         */
        this.currentStopValues = [];
        this.currentBreakValues = [];
        this.zigzagClick = false;
        this.styleSheetStatus = "not-loaded";
        this.histogramStatus = _raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_1__.b.MISSING;
        this.statisticsStatus = _raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_1__.b.MISSING;
        this.sliderZoomed = false;
        this.cap = undefined;
    }
    //--------------------------------------------------------------------------
    //
    //  Public Calls
    //
    //--------------------------------------------------------------------------
    async updateStatistics() {
        var _a;
        this.statisticsStatus = _raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_1__.b.MISSING;
        this.statistics = null;
        this.histogramStatus = _raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_1__.b.MISSING;
        this.histogram = null;
        (_a = this.colorSlider) === null || _a === void 0 ? void 0 : _a.destroy();
        this.colorSlider = undefined;
        this.sliderZoomed = false;
        this.getStatistics();
    }
    // -------------------------------------------------------------------
    //
    // Lifecycle
    //
    // -------------------------------------------------------------------
    componentWillLoad() {
        this.getStatistics();
    }
    componentDidLoad() {
        this.flowItemNode = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_1__.F)(this.hostElement, "calcite-flow-item");
    }
    // -------------------------------------------------------------------
    //
    //  Render Methods
    //
    // -------------------------------------------------------------------
    render() {
        const { config } = _raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_1__.s;
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)(_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.H, null, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("link", { rel: "stylesheet", href: `${config.jsapiUrl}/themes/light/main.css`, onLoad: () => {
                this.styleSheetStatus = "loaded";
                (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.f)(this.hostElement);
            }, onError: () => {
                this.styleSheetStatus = "failed";
                (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.f)(this.hostElement);
            } }), this.styleSheetStatus === "loaded"
            ? this.renderColorSlider()
            : this.styleSheetStatus === "not-loaded"
                ? this.renderColorSliderLoading()
                : null));
    }
    renderColorSlider() {
        const { statisticsStatus, histogramStatus, sliderZoomed } = this;
        const { layer, strings } = _raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_1__.s;
        const renderer = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_1__.h)(layer);
        const colorVisVar = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_1__.a)(renderer, "color");
        if (statisticsStatus === _raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_1__.b.FAILED ||
            statisticsStatus === _raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_1__.b.MISSING ||
            (colorVisVar && colorVisVar.stops.length === 1) ||
            (!colorVisVar && renderer.classBreakInfos.length === 1)) {
            if (this.colorSlider) {
                this.colorSlider.destroy();
                this.colorSlider = undefined;
            }
        }
        else if (statisticsStatus === _raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_1__.b.IN_PROGRESS ||
            (histogramStatus === _raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_1__.b.IN_PROGRESS && !this.colorSlider)) {
            return this.renderColorSliderLoading();
        }
        else {
            const ok = this.prepareColorSlider();
            let disableZoomButton = false;
            if (colorVisVar && !sliderZoomed) {
                const authColorVisVar = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_1__.p)(renderer, "color");
                const zoomOptions = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_1__.aC)(colorVisVar.stops, authColorVisVar === null || authColorVisVar === void 0 ? void 0 : authColorVisVar.minSliderValue, authColorVisVar === null || authColorVisVar === void 0 ? void 0 : authColorVisVar.maxSliderValue);
                if ((zoomOptions === null || zoomOptions === void 0 ? void 0 : zoomOptions.minMaxSame) ||
                    (!(0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_1__.ac)(zoomOptions === null || zoomOptions === void 0 ? void 0 : zoomOptions.min) && !(0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_1__.ac)(zoomOptions === null || zoomOptions === void 0 ? void 0 : zoomOptions.max))) {
                    disableZoomButton = true;
                    if (this.zoomButtonNode) {
                        this.zoomButtonNode.disabled = true;
                    }
                }
            }
            if (colorVisVar) {
                this.currentStopValues = colorVisVar.stops.map((stop) => stop.value);
            }
            else {
                this.currentBreakValues = renderer.classBreakInfos.map((classBreakInfo) => ({
                    min: classBreakInfo.minValue,
                    max: classBreakInfo.maxValue
                }));
            }
            if (ok || this.colorSlider) {
                return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "slider-box" }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-label", null, strings.panels.color.dataRange), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "slider-box-buttons-front" }, this.renderInvertButton(), colorVisVar && ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)(_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.F, null, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", null, "\u00A0"), this.renderZoomButton(disableZoomButton), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", null, "\u00A0"), this.renderResetButton()))), (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { ref: (node) => {
                        if (node) {
                            this.afterColorSliderCreate(node);
                        }
                    } })));
            }
            else {
                return this.renderColorSliderLoading();
            }
        }
    }
    renderColorSliderLoading() {
        const { strings } = _raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_1__.s;
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { class: "slider-box" }, (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("calcite-loader", { label: strings.loading })));
    }
    renderInvertButton() {
        const { strings } = _raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_1__.s;
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("arcgis-smart-mapping-action", { text: strings.panels.color.invertSlider, icon: "arrowUpDown", onClick: () => this.handleInvertSlider() }));
    }
    renderZoomButton(disableZoomButton) {
        const { strings } = _raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_1__.s;
        const { sliderZoomed } = this;
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("arcgis-smart-mapping-action", { text: strings.panels.color.zoomSlider, icon: sliderZoomed ? "magnifyingGlassMinus" : "magnifyingGlassPlus", disabled: disableZoomButton, onClick: () => this.handleZoomSlider(), ref: (node) => (this.zoomButtonNode = node) }));
    }
    renderResetButton() {
        const { strings } = _raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_1__.s;
        return ((0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.h)("arcgis-smart-mapping-action", { text: strings.panels.color.resetSlider, icon: "undo", onClick: () => this.handleResetSlider() }));
    }
    // -------------------------------------------------------------------
    //
    //  Private methods
    //
    // -------------------------------------------------------------------
    prepareColorSlider() {
        var _a, _b;
        const { statistics, histogram, histogramStatus, sliderZoomed } = this;
        const { layer, mapView, modules } = _raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_1__.s;
        const renderer = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_1__.h)(layer);
        const rendererType = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_1__.g)();
        const isAgeRenderer = ["color-age", "color-age-size"].indexOf(rendererType) > -1;
        const fieldInfo = this.getFieldInfo();
        const isDateField = fieldInfo.simpleFieldType === _raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_1__.w.DATE;
        const colorVisVar = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_1__.a)(renderer, "color");
        const authColorVisVar = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_1__.p)(renderer, "color");
        let handleInfo, min, max;
        if (authColorVisVar) {
            handleInfo = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_1__.aD)(authColorVisVar.theme, colorVisVar.stops);
            min = authColorVisVar.minSliderValue;
            max = authColorVisVar.maxSliderValue;
        }
        else {
            min = renderer.classBreakInfos[0].minValue;
            max = renderer.classBreakInfos[renderer.classBreakInfos.length - 1].maxValue;
        }
        ({ min, max } = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_1__.ad)({ min, max }));
        if (histogramStatus === _raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_1__.b.IN_PROGRESS) {
            return false;
        }
        if (!this.colorSlider ||
            (colorVisVar && this.colorSlider.breaks) ||
            (!colorVisVar && this.colorSlider.stops)) {
            (_a = this.colorSlider) === null || _a === void 0 ? void 0 : _a.destroy();
            this.colorSliderBars = [];
            let config = {
                histogramConfig: {
                    bins: histogram === null || histogram === void 0 ? void 0 : histogram.bins,
                    average: Math.round(statistics.avg * 10) / 10,
                    standardDeviation: statistics.stddev,
                    standardDeviationCount: 1
                },
                min: min !== null && min !== void 0 ? min : statistics.min,
                max: max !== null && max !== void 0 ? max : statistics.max
            };
            if (colorVisVar) {
                config = Object.assign(Object.assign({}, config), handleInfo);
                if (isDateField && !isAgeRenderer) {
                    config.hasTimeData = true;
                    (0,_date_79c7d93c_js__WEBPACK_IMPORTED_MODULE_2__.a)(config, mapView.timeZone);
                }
                config.stops = colorVisVar.stops;
                config.precision = (0,_precision_06a73672_js__WEBPACK_IMPORTED_MODULE_5__.g)(colorVisVar.stops);
                config.histogramConfig.barCreatedFunction =
                    histogram && _slider_e162e136_js__WEBPACK_IMPORTED_MODULE_7__.b.bind(this, colorVisVar, histogram, this.colorSliderBars);
                this.colorSlider = new modules.ColorSlider(config);
            }
            else {
                config.histogramConfig.min = renderer.classBreakInfos[0].minValue;
                config.histogramConfig.max =
                    renderer.classBreakInfos[renderer.classBreakInfos.length - 1].maxValue;
                this.sliderZoomed = false;
                config.breaks = (0,_color_d6da0a9a_js__WEBPACK_IMPORTED_MODULE_8__.g)();
                config.precision = (0,_precision_06a73672_js__WEBPACK_IMPORTED_MODULE_5__.g)(config.breaks);
                config.histogramConfig.barCreatedFunction =
                    histogram &&
                        _slider_e162e136_js__WEBPACK_IMPORTED_MODULE_7__.b.bind(this, config.breaks, histogram, this.colorSliderBars);
                this.colorSlider = new modules.ClassedColorSlider(config);
                (0,_slider_e162e136_js__WEBPACK_IMPORTED_MODULE_7__.u)(this.colorSlider, this.colorSliderBars, config.breaks, histogram);
            }
            this.createColorSliderChangeEvents();
        }
        else {
            const slider = this.colorSlider;
            if (((_b = slider.slider) === null || _b === void 0 ? void 0 : _b.state) === "dragging") {
                return true;
            }
            let config = {
                histogramConfig: {
                    bins: histogram === null || histogram === void 0 ? void 0 : histogram.bins,
                    average: Math.round(statistics.avg * 10) / 10,
                    standardDeviation: statistics.stddev,
                    standardDeviationCount: 1
                },
                min: min !== null && min !== void 0 ? min : statistics.min,
                max: max !== null && max !== void 0 ? max : statistics.max
            };
            if (colorVisVar) {
                config = Object.assign(Object.assign({}, config), handleInfo);
                config.stops = colorVisVar.stops;
                config.precision = (0,_precision_06a73672_js__WEBPACK_IMPORTED_MODULE_5__.g)(colorVisVar.stops);
                config.hasTimeData = isDateField && !isAgeRenderer;
                if (isDateField && !isAgeRenderer) {
                    (0,_date_79c7d93c_js__WEBPACK_IMPORTED_MODULE_2__.a)(config, mapView.timeZone);
                }
                if (sliderZoomed) {
                    /**
                     * clicking a zigzag already updates the internal slider zoomOptions;
                     * setting them here again would incorrectly override a user's decision
                     * to manually zoom out one side of the slider.
                     */
                    if (!this.zigzagClick) {
                        config.zoomOptions = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_1__.aC)(colorVisVar.stops, authColorVisVar === null || authColorVisVar === void 0 ? void 0 : authColorVisVar.minSliderValue, authColorVisVar === null || authColorVisVar === void 0 ? void 0 : authColorVisVar.maxSliderValue);
                    }
                }
                else {
                    config.zoomOptions = null;
                }
                config.histogramConfig.barCreatedFunction =
                    histogram && _slider_e162e136_js__WEBPACK_IMPORTED_MODULE_7__.b.bind(this, colorVisVar, histogram, this.colorSliderBars);
                (0,_slider_e162e136_js__WEBPACK_IMPORTED_MODULE_7__.u)(slider, this.colorSliderBars, colorVisVar, histogram);
            }
            else {
                config.breaks = (0,_color_d6da0a9a_js__WEBPACK_IMPORTED_MODULE_8__.g)();
                config.precision = (0,_precision_06a73672_js__WEBPACK_IMPORTED_MODULE_5__.g)(config.breaks);
                config.histogramConfig.barCreatedFunction =
                    histogram &&
                        _slider_e162e136_js__WEBPACK_IMPORTED_MODULE_7__.b.bind(this, config.breaks, histogram, this.colorSliderBars);
                (0,_slider_e162e136_js__WEBPACK_IMPORTED_MODULE_7__.u)(slider, this.colorSliderBars, config.breaks, histogram);
            }
            if (this.sliderZoomed && this.adjustedZoomOptions && !this.zigzagClick) {
                config.zoomOptions = this.adjustedZoomOptions;
                /**
                 * handles edge cases where the slider is zoomed, handles have been manually modified,
                 * and a user executes a label change. This prevents zoom options from changing and preserves
                 * the histogram display.
                 */
                if (this.zoomAdjustment === "min") {
                    this.colorSlider.slider.min = config.zoomOptions.min;
                    config.zoomOptions.min = null;
                }
                else {
                    this.colorSlider.slider.max = config.zoomOptions.max;
                    config.zoomOptions.max = null;
                }
            }
            this.adjustedZoomOptions = null;
            this.zoomAdjustment = null;
            this.colorSlider.set(config);
            this.zigzagClick = false;
        }
        return (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_1__.ac)(this.colorSlider);
    }
    handleInvertSlider() {
        const { layer, modules } = _raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_1__.s;
        const renderer = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_1__.h)(layer);
        const colorVisVar = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_1__.a)(renderer, "color");
        (0,_slider_e162e136_js__WEBPACK_IMPORTED_MODULE_7__.u)(this.colorSlider, this.colorSliderBars, colorVisVar || (0,_color_d6da0a9a_js__WEBPACK_IMPORTED_MODULE_8__.g)(), this.histogram);
        if (colorVisVar) {
            let colors = colorVisVar.stops.map((stop) => {
                return stop.color;
            });
            colors = colors.reverse();
            colorVisVar.stops.forEach((stop, idx) => {
                stop.color = colors[idx];
            });
        }
        else {
            let colors = renderer.classBreakInfos.map((classBreakInfo) => {
                return ((0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_1__.t)(classBreakInfo.symbol) ||
                    new modules.esriColor({ r: 64, g: 64, b: 64, a: 1 }));
            });
            colors = colors.reverse();
            renderer.classBreakInfos.map((classBreakInfo, idx) => {
                if ((0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_1__.t)(classBreakInfo.symbol)) {
                    (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_1__.r)(classBreakInfo.symbol, colors[idx]);
                }
            });
        }
        (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_1__.ab)();
        (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.f)(this.hostElement);
        this.arcgisSmartMappingColorSliderChange.emit();
    }
    handleZoomSlider(zoomed) {
        var _a, _b, _c, _d;
        this.cap = this.colorSlider.slider.max;
        if (this.histogramStatus === _raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_1__.b.IN_PROGRESS) {
            return;
        }
        const { statistics } = this;
        const { layer } = _raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_1__.s;
        const renderer = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_1__.h)(layer);
        this.sliderZoomed = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_1__.ac)(zoomed) ? zoomed : !this.sliderZoomed;
        const colorVisVar = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_1__.a)(renderer, "color");
        if (!colorVisVar) {
            this.sliderZoomed = false;
        }
        const authColorVisVar = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_1__.p)(renderer, "color");
        const zoomOptions = this.sliderZoomed
            ? (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_1__.aC)(colorVisVar.stops, (_a = authColorVisVar === null || authColorVisVar === void 0 ? void 0 : authColorVisVar.minSliderValue) !== null && _a !== void 0 ? _a : statistics.min, (_b = authColorVisVar === null || authColorVisVar === void 0 ? void 0 : authColorVisVar.maxSliderValue) !== null && _b !== void 0 ? _b : statistics.max)
            : null;
        this.getHistogram({
            field: colorVisVar.field,
            expression: colorVisVar.valueExpression,
            expressionTitle: colorVisVar.valueExpressionTitle,
            simpleFieldType: _raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_1__.w.NUMBER
        }, colorVisVar.normalizationField, statistics, (zoomOptions && zoomOptions.min) || ((_c = authColorVisVar === null || authColorVisVar === void 0 ? void 0 : authColorVisVar.minSliderValue) !== null && _c !== void 0 ? _c : statistics.min), (zoomOptions && zoomOptions.max) || ((_d = authColorVisVar === null || authColorVisVar === void 0 ? void 0 : authColorVisVar.maxSliderValue) !== null && _d !== void 0 ? _d : statistics.max));
    }
    handleResetSlider() {
        const { layer } = _raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_1__.s;
        const renderer = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_1__.h)(layer);
        const rendererType = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_1__.g)();
        this.sliderZoomed = false;
        let colorVisVar = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_1__.a)(renderer, "color");
        const authColorVisVar = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_1__.p)(renderer, "color");
        const theme = authColorVisVar === null || authColorVisVar === void 0 ? void 0 : authColorVisVar.theme;
        const fieldInfo = this.getFieldInfo();
        const normalizationField = colorVisVar
            ? colorVisVar.normalizationField
            : renderer.normalizationField;
        let updateCall;
        if (rendererType === "color") {
            updateCall = _color_d6da0a9a_js__WEBPACK_IMPORTED_MODULE_8__.b;
        }
        else if (rendererType === "color-age") {
            fieldInfo.field = authColorVisVar.field;
            updateCall = _color_d6da0a9a_js__WEBPACK_IMPORTED_MODULE_8__.d;
        }
        else if (rendererType === "color-age-size") {
            fieldInfo.field = authColorVisVar.field;
            updateCall = _colorSize_ce0ccdeb_js__WEBPACK_IMPORTED_MODULE_10__.h;
        }
        else if (rendererType === "color-size-age") {
            updateCall = _colorSize_ce0ccdeb_js__WEBPACK_IMPORTED_MODULE_10__.i;
        }
        else if (rendererType === "color-size") {
            updateCall = _colorSize_ce0ccdeb_js__WEBPACK_IMPORTED_MODULE_10__.j;
        }
        else if (rendererType === "compare") {
            updateCall = _compare_ba1292fe_js__WEBPACK_IMPORTED_MODULE_9__.a;
        }
        (0,_loading_69139907_js__WEBPACK_IMPORTED_MODULE_3__.r)(updateCall({
            fieldInfos: (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_1__.f)(layer),
            normalizationField: normalizationField,
            noReuse: true,
            theme,
            discardMinMax: true
        }, "color"), this.flowItemNode).then((result) => {
            var _a;
            if (((_a = result.statistics) === null || _a === void 0 ? void 0 : _a.count) === 0) {
                const [defaultMin, defaultMax] = this.getDefaultDataRange(fieldInfo);
                const min = (authColorVisVar === null || authColorVisVar === void 0 ? void 0 : authColorVisVar.minSliderValue) || defaultMin;
                const max = (authColorVisVar === null || authColorVisVar === void 0 ? void 0 : authColorVisVar.maxSliderValue) || defaultMax;
                result.statistics.min = min;
                result.statistics.max = max;
                result.statistics.avg = (max + min) / 2;
                this.statistics = result.statistics;
                this.statisticsStatus = _raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_1__.b.SUCCESS;
            }
            else if (result.statistics &&
                (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_1__.ac)(result.statistics.min) &&
                (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_1__.ac)(result.statistics.max) &&
                result.statistics.min <= result.statistics.max) {
                this.statistics = result.statistics;
                this.statisticsStatus = _raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_1__.b.SUCCESS;
                this.getHistogram(fieldInfo, normalizationField, result.statistics, result.statistics.min, result.statistics.max);
            }
            else {
                this.statisticsStatus = _raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_1__.b.FAILED;
            }
            authColorVisVar.minSliderValue = this.statistics.min;
            authColorVisVar.maxSliderValue = this.statistics.max;
            (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_1__.ab)();
        }, (error) => this.arcgisSmartMappingColorSliderError.emit(error));
    }
    afterColorSliderCreate(node) {
        if (!this.colorSlider.container) {
            const divNode = document.createElement("div");
            node.append(divNode);
            this.colorSlider.container = divNode;
        }
    }
    getStatistics() {
        /**
         * Handles the following:
         *  1.) Retrieving statistics on slider load
         *  2.) Retrieving updated statistics after changing age, normalization field, theme, or classify method/number of classes
         */
        var _a;
        const { layer: smLayer, mapView, modules } = _raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_1__.s;
        const layer = smLayer;
        const renderer = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_1__.h)(layer);
        let min;
        let max;
        const fieldInfo = this.getFieldInfo();
        const colorVisVar = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_1__.a)(renderer, "color");
        const normalizationField = colorVisVar
            ? colorVisVar.normalizationField
            : renderer.normalizationField;
        const authColorVisVar = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_1__.p)(renderer, "color") || {};
        min = authColorVisVar.minSliderValue;
        max = authColorVisVar.maxSliderValue;
        // handles equal interval behavior
        const authInfo = renderer.authoringInfo;
        if ((authInfo === null || authInfo === void 0 ? void 0 : authInfo.classificationMethod) === "equal-interval") {
            const classBreaks = renderer.classBreakInfos;
            min = classBreaks[0].minValue;
            max = classBreaks[classBreaks.length - 1].maxValue;
        }
        this.statisticsStatus = _raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_1__.b.IN_PROGRESS;
        if (!this.statistics) {
            modules
                .summaryStatistics({
                layer,
                view: mapView,
                field: fieldInfo.field,
                valueExpression: fieldInfo.expression,
                normalizationField,
                forBinning: "featureReduction" in layer && ((_a = layer.featureReduction) === null || _a === void 0 ? void 0 : _a.type) === "binning"
            })
                .then((statistics) => {
                if (statistics.count === 0) {
                    // field has no values
                    // make up some basic statistics so we can show a slider
                    const [defaultMin, defaultMax] = this.getDefaultDataRange(fieldInfo);
                    const min = authColorVisVar.minSliderValue || defaultMin;
                    const max = authColorVisVar.maxSliderValue || defaultMax;
                    statistics.min = min;
                    statistics.max = max;
                    statistics.avg = (max + min) / 2;
                    if (!(0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_1__.ac)(authColorVisVar.minSliderValue)) {
                        authColorVisVar.minSliderValue = min;
                        authColorVisVar.maxSliderValue = max;
                    }
                }
                else if (!(0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_1__.ac)(statistics.avg) ||
                    !(0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_1__.ac)(statistics.min) ||
                    !(0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_1__.ac)(statistics.max)) {
                    // statistics unusable
                    this.statisticsStatus = _raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_1__.b.FAILED;
                    return;
                }
                statistics = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_1__.ad)(statistics);
                min = min !== null && min !== void 0 ? min : statistics.min;
                max = max !== null && max !== void 0 ? max : statistics.max;
                this.statistics = statistics;
                this.statisticsStatus = _raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_1__.b.SUCCESS;
                this.getHistogram(fieldInfo, normalizationField, statistics, min, max);
            }, (error) => {
                console.log(error);
                this.statisticsStatus = _raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_1__.b.FAILED;
            });
        }
    }
    getHistogram(fieldInfo, normalizationField, statistics, min, max) {
        var _a;
        const { layer: smLayer, mapView, modules } = _raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_1__.s;
        const layer = smLayer;
        statistics = statistics || this.statistics;
        if (!statistics || statistics.count === 0) {
            return;
        }
        this.histogramStatus = _raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_1__.b.IN_PROGRESS;
        modules
            .histogram({
            layer: layer,
            view: mapView,
            field: fieldInfo.field,
            valueExpression: fieldInfo.expression,
            numBins: 50,
            minValue: (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_1__.ac)(min) ? min : statistics.min,
            maxValue: (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_1__.ac)(max) ? max : statistics.max,
            normalizationField,
            forBinning: "featureReduction" in layer && ((_a = layer.featureReduction) === null || _a === void 0 ? void 0 : _a.type) === "binning"
        })
            .then((histogram) => {
            this.histogram = histogram;
            this.histogramStatus = _raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_1__.b.SUCCESS;
        }, (error) => {
            console.log(error);
            this.histogramStatus = _raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_1__.b.FAILED;
        });
    }
    onMinMaxChange(min, max, changing) {
        const { statistics } = this;
        const { layer } = _raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_1__.s;
        const renderer = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_1__.h)(layer);
        const colorVisVar = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_1__.a)(renderer, "color");
        const authColorVisVar = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_1__.p)(renderer, "color") || {};
        if (!colorVisVar) {
            let minClassBreak = renderer.classBreakInfos[0];
            let maxClassBreak = renderer.classBreakInfos[renderer.classBreakInfos.length - 1];
            minClassBreak.minValue = min;
            minClassBreak.label =
                minClassBreak.minValue.toLocaleString() + " - " + minClassBreak.maxValue.toLocaleString();
            maxClassBreak.maxValue = max;
            maxClassBreak.label =
                "> " +
                    maxClassBreak.minValue.toLocaleString() +
                    " - " +
                    maxClassBreak.maxValue.toLocaleString();
        }
        // update only the label that the user is changing
        changing === "min"
            ? (authColorVisVar.minSliderValue = min)
            : (authColorVisVar.maxSliderValue = max);
        // determine if label updates merit zooming or not
        const zoomOptions = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_1__.aC)(colorVisVar === null || colorVisVar === void 0 ? void 0 : colorVisVar.stops, authColorVisVar.minSliderValue, authColorVisVar.maxSliderValue);
        // handles zoom button display for non-classed color sliders
        if (this.zoomButtonNode) {
            if (this.sliderZoomed) {
                this.zoomButtonNode.disabled = false;
            }
            else if (!zoomOptions ||
                zoomOptions.minMaxSame ||
                (!(0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_1__.ac)(zoomOptions.min) && !(0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_1__.ac)(zoomOptions.max))) {
                this.zoomButtonNode.disabled = true;
            }
            else {
                this.zoomButtonNode.disabled = false;
            }
        }
        // zoom adjustment
        if (this.sliderZoomed) {
            this.adjustedZoomOptions = this.colorSlider.zoomOptions;
            if (changing === "min") {
                this.adjustedZoomOptions.min = min;
                this.zoomAdjustment = "min";
            }
            else {
                this.adjustedZoomOptions.max = max;
                this.zoomAdjustment = "max";
            }
        }
        const fieldInfo = this.getFieldInfo();
        const normalizationField = colorVisVar
            ? colorVisVar.normalizationField
            : renderer.normalizationField;
        this.getHistogram(fieldInfo, normalizationField, statistics, min, max);
        (0,_slider_e162e136_js__WEBPACK_IMPORTED_MODULE_7__.u)(this.colorSlider, this.colorSliderBars, colorVisVar || (0,_color_d6da0a9a_js__WEBPACK_IMPORTED_MODULE_8__.g)(), this.histogram);
        if (min === authColorVisVar.minSliderValue && max === authColorVisVar.maxSliderValue) {
            this.sliderZoomed = false;
        }
        renderer.authoringInfo.classificationMethod = "manual";
        this.arcgisSmartMappingColorSliderChange.emit();
    }
    createColorSliderChangeEvents() {
        const { layer } = _raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_1__.s;
        const renderer = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_1__.h)(layer);
        const colorVisVar = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_1__.a)(renderer, "color");
        if (!this.colorSlider) {
            return;
        }
        // handles zigzag click
        this.colorSlider.watch("zoomOptions", (newValue, oldValue) => {
            if (this.sliderZoomed &&
                (((oldValue === null || oldValue === void 0 ? void 0 : oldValue.min) && !(newValue === null || newValue === void 0 ? void 0 : newValue.min)) || ((oldValue === null || oldValue === void 0 ? void 0 : oldValue.max) && !(newValue === null || newValue === void 0 ? void 0 : newValue.max)))) {
                this.zigzagClick = true;
                this.handleZigzagClick(newValue);
            }
        });
        this.colorSlider.on("min-change", (info) => {
            if (colorVisVar) {
                if (info.value > this.currentStopValues[0]) {
                    this.colorSlider.stops.forEach((stop, idx) => {
                        stop.value = this.currentStopValues[idx];
                    });
                    this.onMinMaxChange(this.currentStopValues[0], this.colorSlider.slider.max, "min");
                }
                else {
                    this.onMinMaxChange(info.value, this.colorSlider.slider.max, "min");
                }
            }
            else {
                if (info.value > this.currentBreakValues[0].max) {
                    this.onMinMaxChange(this.currentBreakValues[0].max, this.colorSlider.slider.max, "min");
                }
                else {
                    this.onMinMaxChange(info.value, this.colorSlider.slider.max, "min");
                }
            }
        });
        this.colorSlider.on("max-change", (info) => {
            if (colorVisVar) {
                if (info.value < this.currentStopValues[this.currentStopValues.length - 1]) {
                    this.colorSlider.stops.forEach((stop, idx) => {
                        stop.value = this.currentStopValues[idx];
                    });
                    this.onMinMaxChange(this.colorSlider.slider.min, this.currentStopValues[this.currentStopValues.length - 1], "max");
                }
                else {
                    this.onMinMaxChange(this.colorSlider.slider.min, info.value, "max");
                }
            }
            else {
                if (info.value < this.currentBreakValues[this.currentBreakValues.length - 1].min) {
                    this.onMinMaxChange(this.colorSlider.slider.min, this.currentBreakValues[this.currentBreakValues.length - 1].min, "max");
                }
                else {
                    this.onMinMaxChange(this.colorSlider.slider.min, info.value, "max");
                }
            }
        });
        this.colorSlider.on("thumb-change", (info) => {
            if (colorVisVar) {
                const fieldInfo = this.getFieldInfo();
                const isDateField = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_1__.aH)(fieldInfo);
                if (isDateField && info.value === 0) {
                    (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.f)(this.hostElement);
                    return;
                }
                const stops = this.colorSlider.stops;
                this.updateRendererStops(stops);
            }
            else {
                this.updateRendererBreaks(this.colorSlider.breaks);
            }
            this.arcgisSmartMappingColorSliderChange.emit();
        });
        this.colorSlider.on("thumb-drag", () => {
            if (colorVisVar) {
                const stops = this.colorSlider.stops;
                this.updateRendererStops(stops);
            }
            else {
                this.updateRendererBreaks(this.colorSlider.breaks);
            }
            this.arcgisSmartMappingColorSliderChange.emit();
        });
        this.colorSlider.on("segment-drag", () => {
            if (colorVisVar) {
                const stops = this.colorSlider.stops;
                this.updateRendererStops(stops);
            }
            else {
                this.updateRendererBreaks(this.colorSlider.breaks);
            }
            this.arcgisSmartMappingColorSliderChange.emit();
        });
    }
    updateRendererStops(stops) {
        const { layer } = _raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_1__.s;
        const renderer = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_1__.h)(layer);
        const colorVisVar = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_1__.a)(renderer, "color");
        const authColorVisVar = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_1__.p)(renderer, "color");
        colorVisVar.stops = stops;
        this.currentStopValues = colorVisVar.stops.map((stop) => stop.value);
        const zoomOptions = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_1__.aC)(colorVisVar === null || colorVisVar === void 0 ? void 0 : colorVisVar.stops, authColorVisVar === null || authColorVisVar === void 0 ? void 0 : authColorVisVar.minSliderValue, authColorVisVar === null || authColorVisVar === void 0 ? void 0 : authColorVisVar.maxSliderValue);
        if (this.sliderZoomed) {
            this.zoomButtonNode.disabled = false;
        }
        else if (!zoomOptions ||
            zoomOptions.minMaxSame ||
            (!(0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_1__.ac)(zoomOptions.min) && !(0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_1__.ac)(zoomOptions.max))) {
            this.zoomButtonNode.disabled = true;
        }
        else {
            this.zoomButtonNode.disabled = false;
        }
        (0,_slider_e162e136_js__WEBPACK_IMPORTED_MODULE_7__.u)(this.colorSlider, this.colorSliderBars, colorVisVar, this.histogram);
        (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_1__.ab)();
    }
    updateRendererBreaks(breaks) {
        const { layer } = _raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_1__.s;
        const renderer = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_1__.h)(layer);
        renderer.authoringInfo.classificationMethod = "manual";
        renderer.classBreakInfos.forEach((classBreakInfo, idx) => {
            if (classBreakInfo.minValue !== breaks[idx].min ||
                classBreakInfo.maxValue !== breaks[idx].max) {
                classBreakInfo.minValue = breaks[idx].min;
                classBreakInfo.maxValue = breaks[idx].max;
                const prefix = idx > 0 ? "> " : "";
                classBreakInfo.label = `${prefix} ${classBreakInfo.minValue.toLocaleString()} - ${classBreakInfo.maxValue.toLocaleString()}`;
                this.currentBreakValues[idx].min = breaks[idx].min;
                this.currentBreakValues[idx].max = breaks[idx].max;
            }
        });
        (0,_slider_e162e136_js__WEBPACK_IMPORTED_MODULE_7__.u)(this.colorSlider, this.colorSliderBars, (0,_color_d6da0a9a_js__WEBPACK_IMPORTED_MODULE_8__.g)(), this.histogram);
        (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_1__.ab)();
        this.arcgisSmartMappingColorSliderChange.emit();
    }
    getDefaultDataRange(fieldInfo) {
        if (fieldInfo.simpleFieldType === _raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_1__.w.DATE) {
            const year = new Date().getFullYear();
            return [new Date(`1/1/${year}`).getTime(), new Date(`12/31/${year}`).getTime()];
        }
        else {
            return [0, 100];
        }
    }
    getFieldInfo() {
        const { layer } = _raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_1__.s;
        const renderer = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_1__.h)(layer);
        const colorVisVar = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_1__.a)(renderer, "color");
        const field = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_1__.u)(colorVisVar ? colorVisVar.field : renderer.field);
        const fieldInfo = {
            field: (colorVisVar === null || colorVisVar === void 0 ? void 0 : colorVisVar.field) || renderer.field,
            expression: (colorVisVar === null || colorVisVar === void 0 ? void 0 : colorVisVar.valueExpression) || renderer.valueExpression,
            expressionTitle: (colorVisVar === null || colorVisVar === void 0 ? void 0 : colorVisVar.valueExpressionTitle) || renderer.valueExpressionTitle,
            simpleFieldType: field ? field.simpleFieldType : _raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_1__.w.NUMBER
        };
        return fieldInfo;
    }
    handleZigzagClick(newValue) {
        var _a, _b;
        const { statistics } = this;
        const { layer } = _raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_1__.s;
        const renderer = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_1__.h)(layer);
        const colorVisVar = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_1__.a)(renderer, "color");
        const authColorVisVar = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_1__.p)(renderer, "color");
        const fieldInfo = this.getFieldInfo();
        const normalizationField = colorVisVar
            ? colorVisVar.normalizationField
            : renderer.normalizationField;
        this.getHistogram(fieldInfo, normalizationField, statistics, (_a = newValue === null || newValue === void 0 ? void 0 : newValue.min) !== null && _a !== void 0 ? _a : authColorVisVar.minSliderValue, (_b = newValue === null || newValue === void 0 ? void 0 : newValue.max) !== null && _b !== void 0 ? _b : authColorVisVar.maxSliderValue);
        if (!newValue) {
            this.sliderZoomed = false;
        }
    }
    get hostElement() { return (0,_index_e3bf7da7_js__WEBPACK_IMPORTED_MODULE_0__.d)(this); }
};
ArcgisSmartMappingColorSlider.style = arcgisSmartMappingColorSliderCss;



//# sourceMappingURL=arcgis-smart-mapping-color-slider.entry.js.map

/***/ }),

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/compare-ba1292fe.js":
/*!*************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/compare-ba1292fe.js ***!
  \*************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   a: () => (/* binding */ createCompareRendererFromExisting),
/* harmony export */   c: () => (/* binding */ createCompareRenderer)
/* harmony export */ });
/* harmony import */ var _raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./raster-unique-value-0976ec7f.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/raster-unique-value-0976ec7f.js");
/* harmony import */ var _loadModules_b4ac1247_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./loadModules-b4ac1247.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/loadModules-b4ac1247.js");
/* harmony import */ var _commonFunctions_b0830e9e_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./commonFunctions-b0830e9e.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/commonFunctions-b0830e9e.js");
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v4.0.58
 */




/**
 * Updates the layer with a Compare renderer with default settings
 * @param props: must contain layer, mapView, field
 * @param options: options
 */
function createCompareRenderer(options) {
    var _a;
    const { layer: smLayer, mapImageSublayer, mapView, modules } = _raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.s;
    const layer = smLayer;
    options = options || {};
    const extras = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.m)((0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.h)(layer));
    return modules.ColorCreator.createContinuousRenderer({
        layer,
        view: mapView,
        field: options.fieldInfos[0].field,
        theme: "above-and-below",
        colorScheme: (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.P)("above-and-below"),
        normalizationField: options.fieldInfos[1].field,
        outlineOptimizationEnabled: mapImageSublayer
            ? false
            : (0,_commonFunctions_b0830e9e_js__WEBPACK_IMPORTED_MODULE_2__.i)(options.outlineOptimizationEnabled)
                ? options.outlineOptimizationEnabled
                : (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.q)(layer),
        sizeOptimizationEnabled: mapImageSublayer
            ? false
            : (0,_commonFunctions_b0830e9e_js__WEBPACK_IMPORTED_MODULE_2__.i)(options.sizeOptimizationEnabled)
                ? options.sizeOptimizationEnabled
                : true,
        legendOptions: options.legendOptions,
        defaultSymbolEnabled: false,
        forBinning: ((_a = layer.featureReduction) === null || _a === void 0 ? void 0 : _a.type) === "binning"
    }).then((result) => {
        const colorAuthVisVar = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.p)(result.renderer, "color") || {};
        colorAuthVisVar.style = "ratio"; // "ratio", "percent", "percent-of-total"
        (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.l)(extras, result.renderer);
        return Promise.resolve(result);
    }, (error) => Promise.reject(error));
}
/**
 * Creates a Compare renderer with settings from current renderer
 * @param props: only contains properties that need to be overwritten
 */
function createCompareRendererFromExisting(options) {
    var _a, _b, _c, _d;
    const { layer: smLayer, mapImageSublayer, mapView, modules } = _raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.s;
    const layer = smLayer;
    options = options || {};
    const renderer = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.h)(layer);
    const colorVisVar = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.a)(renderer, "color");
    if (colorVisVar &&
        options.fieldInfo &&
        options.fieldInfo.field == colorVisVar.field &&
        options.normalizationField === colorVisVar.normalizationField) {
        // no changes to fields
        delete options.fieldInfos;
        if ((0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.R)(options)) {
            // nothing really changes
            return Promise.resolve({ renderer: renderer.clone() });
        }
    }
    const authColorVisVar = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.p)(renderer, "color");
    const extras = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.m)(renderer);
    let fieldInfo = options.fieldInfos
        ? options.fieldInfos[0]
        : colorVisVar
            ? {
                field: colorVisVar.field,
                expression: colorVisVar.valueExpression,
                expressionTitle: colorVisVar.valueExpressionTitle,
                simpleFieldType: _raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.w.NUMBER
            }
            : {
                field: renderer.field,
                expression: renderer.valueExpression,
                expressionTitle: renderer.valueExpressionTitle,
                simpleFieldType: _raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.w.NUMBER
            };
    const normalizationField = options.normalizationField
        ? options.normalizationField
        : colorVisVar
            ? colorVisVar.normalizationField
            : renderer.normalizationField;
    const symbol = renderer.classBreakInfos && renderer.classBreakInfos.length ? renderer.classBreakInfos[0].symbol : null;
    const defaultSymbol = renderer.defaultSymbol;
    const defaultLabel = renderer.defaultLabel;
    let needNewStatistics = false;
    if (options.normalizationField === null || options.normalizationField || options.fieldInfo) {
        needNewStatistics = true;
    }
    const minValue = options.discardMinMax
        ? undefined
        : (0,_commonFunctions_b0830e9e_js__WEBPACK_IMPORTED_MODULE_2__.i)(options.min)
            ? options.min
            : needNewStatistics
                ? undefined
                : authColorVisVar
                    ? authColorVisVar.minSliderValue
                    : renderer.classBreakInfos[0].minValue;
    const maxValue = options.discardMinMax
        ? undefined
        : (0,_commonFunctions_b0830e9e_js__WEBPACK_IMPORTED_MODULE_2__.i)(options.max)
            ? options.max
            : needNewStatistics
                ? undefined
                : authColorVisVar
                    ? authColorVisVar.maxSliderValue
                    : renderer.classBreakInfos[renderer.classBreakInfos.length - 1].maxValue;
    return modules.ColorCreator.createContinuousRenderer({
        layer,
        view: mapView,
        field: fieldInfo ? fieldInfo.field : renderer.field,
        theme: "above-and-below",
        colorScheme: (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.P)("above-and-below"),
        normalizationField,
        minValue,
        maxValue,
        outlineOptimizationEnabled: mapImageSublayer
            ? false
            : (0,_commonFunctions_b0830e9e_js__WEBPACK_IMPORTED_MODULE_2__.i)(options.outlineOptimizationEnabled)
                ? options.outlineOptimizationEnabled
                : !!extras.sizeOutlineVisVar,
        sizeOptimizationEnabled: mapImageSublayer
            ? false
            : (0,_commonFunctions_b0830e9e_js__WEBPACK_IMPORTED_MODULE_2__.i)(options.sizeOptimizationEnabled)
                ? options.sizeOptimizationEnabled
                : !!extras.sizeAutoVisVar,
        legendOptions: ((_a = options.legendOptions) === null || _a === void 0 ? void 0 : _a.toJSON()) ||
            ((_b = colorVisVar === null || colorVisVar === void 0 ? void 0 : colorVisVar.legendOptions) === null || _b === void 0 ? void 0 : _b.toJSON()) ||
            ((_c = renderer.legendOptions) === null || _c === void 0 ? void 0 : _c.toJSON()),
        defaultSymbolEnabled: (0,_commonFunctions_b0830e9e_js__WEBPACK_IMPORTED_MODULE_2__.i)(options.defaultSymbolEnabled)
            ? options.defaultSymbolEnabled
            : !!renderer.defaultSymbol,
        forBinning: ((_d = layer.featureReduction) === null || _d === void 0 ? void 0 : _d.type) === "binning"
    }).then((result) => {
        // reset handles if necessary
        if (options.discardMinMax) {
            const colorVisVar = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.a)(renderer, "color");
            const newColorVisVar = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.a)(result.renderer, "color");
            colorVisVar.stops.forEach((stop, idx) => (stop.value = newColorVisVar.stops[idx].value));
        }
        const colorAuthVisVar = (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.p)(result.renderer, "color") || {};
        colorAuthVisVar.style = "ratio";
        //console.log("createContinuousRenderer", result);
        (0,_raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.l)(extras, result.renderer);
        if (symbol && result.renderer.classBreakInfos && result.renderer.classBreakInfos.length) {
            result.renderer.classBreakInfos[0].symbol = symbol;
        }
        if (defaultSymbol) {
            result.renderer.defaultSymbol = defaultSymbol;
            result.renderer.defaultLabel = defaultLabel;
        }
        return Promise.resolve(result);
    }, (error) => Promise.reject(error));
}



//# sourceMappingURL=compare-ba1292fe.js.map

/***/ }),

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/date-79c7d93c.js":
/*!**********************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/date-79c7d93c.js ***!
  \**********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   a: () => (/* binding */ addDateFormatFunctions),
/* harmony export */   b: () => (/* binding */ utcToTimePicker),
/* harmony export */   d: () => (/* binding */ datePickerToUTC),
/* harmony export */   u: () => (/* binding */ utcToDatePicker)
/* harmony export */ });
/* harmony import */ var _raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./raster-unique-value-0976ec7f.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/raster-unique-value-0976ec7f.js");
/* harmony import */ var _loadModules_b4ac1247_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./loadModules-b4ac1247.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/loadModules-b4ac1247.js");
/* harmony import */ var _commonEnums_fcf13661_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./commonEnums-fcf13661.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/commonEnums-fcf13661.js");
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v4.0.58
 */




function addDateFormatFunctions(config, timeZone) {
    config.labelFormatFunction = (value) => {
        return getDateDisplayString(value, timeZone, "short-date");
    };
    config.inputFormatFunction = (value) => {
        return getDateDisplayString(value, timeZone, "short-date");
    };
    config.inputParseFunction = (value) => {
        return mapTZToUTC(Date.parse(value), timeZone);
    };
}
function utcToDatePicker(value, timeZone) {
    // date is in UTC
    // we need a map timezone
    let str;
    if (!timeZone || timeZone === "system") {
        const diff = new Date().getTimezoneOffset();
        str = new Date(value - diff * 60000).toISOString();
    }
    else if (timeZone === "unknown") {
        str = new Date(value).toISOString();
    }
    else {
        const diff = new Date().getTimezoneOffset();
        const mapDateStr = new Date(value).toLocaleString("en-US", { timeZone });
        str = new Date(new Date(mapDateStr).getTime() - diff * 60000).toISOString();
    }
    // console.log("utcToDatePicker", value, " - ", new Date(value).toISOString(), " -> ", str);
    return str;
}
function utcToTimePicker(value, timeZone, addSeconds) {
    // date is in UTC
    // we need a map timezone
    let str;
    if (!timeZone || timeZone === "system") {
        const diff = new Date().getTimezoneOffset();
        str = new Date(value - diff * 60000).toISOString();
    }
    else if (timeZone === "unknown") {
        str = new Date(value).toISOString();
    }
    else {
        const diff = new Date().getTimezoneOffset();
        const mapDateStr = new Date(value).toLocaleString("en-US", { timeZone });
        str = new Date(new Date(mapDateStr).getTime() - diff * 60000).toISOString();
    }
    // str = "2023-09-20T13:06:00.000Z"
    str = addSeconds ? str.substring(11, 19) : str.substring(11, 16);
    // console.log("utcToTimePicker", value, " - ", new Date(value).toISOString(), " -> ", str);
    return str;
}
function datePickerToUTC(dateString, timeZone) {
    // date is in map timezone
    // we need a UTC UNIX timestamp
    let date = new Date(dateString);
    // this is read as current time; toISOString() would reaturn UTC time (e.g. +7 hours from pacific)
    // fix the offset
    date = new Date(date.getTime() - date.getTimezoneOffset() * 60000);
    // date now contains the user's entered time
    let value;
    if (!timeZone || timeZone === "system") {
        // add difference between local time and UTC
        value = date.getTime() + date.getTimezoneOffset() * 60000;
    }
    else if (timeZone === "unknown") {
        // take what you get
        value = date.getTime();
    }
    else {
        // add difference between map time and UTC
        const diff = new Date(date.toLocaleString("en-US", { timeZone: "utc" })).getTime() -
            new Date(date.toLocaleString("en-US", { timeZone })).getTime();
        value = date.getTime() + diff;
    }
    // console.log("datePickerToUTC", date.toISOString(), " -> ", new Date(value).toISOString());
    return value;
}
function mapTZToUTC(value, timeZone) {
    if (!value) {
        return value;
    }
    // value is in map timezone
    // we need a UTC timestamp
    let newValue;
    if (!timeZone || timeZone === "system") {
        // add difference between local time and UTC
        const date = new Date();
        newValue = value + date.getTimezoneOffset() * 60000;
    }
    else if (timeZone === "unknown") {
        // take what you get
        newValue = value;
    }
    else {
        // add difference between map time and UTC
        const date = new Date();
        const diff = new Date(date.toLocaleString("en-US", { timeZone: "utc" })).getTime() -
            new Date(date.toLocaleString("en-US", { timeZone })).getTime();
        newValue = value + diff;
    }
    console.log("mapTZToUTC", value, " - ", new Date(value).toISOString(), " - ", new Date(newValue).toISOString());
    return newValue;
}
function getDateDisplayString(value, timeZone, dateFormat) {
    const { modules } = _raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.s;
    let str;
    if (timeZone === "unknown") {
        str = modules.intl.formatDate(value, Object.assign(Object.assign({}, modules.intl.convertDateFormatToIntlOptions(dateFormat || "short-date-short-time")), { timeZone: "utc", timeZoneName: "shortOffset" }));
    }
    else {
        // known issues with formatting it-CH
        str = modules.intl.formatDate(value, Object.assign(Object.assign({}, modules.intl.convertDateFormatToIntlOptions(dateFormat || "short-date-short-time")), { timeZone }));
    }
    // console.log("getDateDisplayString", value, " - ", new Date(value).toISOString(), " -> ", str);
    return str;
}



//# sourceMappingURL=date-79c7d93c.js.map

/***/ }),

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/loading-69139907.js":
/*!*************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/loading-69139907.js ***!
  \*************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   r: () => (/* binding */ requestWrapper)
/* harmony export */ });
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v4.0.58
 */
let _loadingTimer;
let _requestCancelled;
function startLoading(node) {
    node.loading = true;
    _requestCancelled = false;
    if (_loadingTimer) {
        clearTimeout(_loadingTimer);
    }
    _loadingTimer = setTimeout(() => {
        // took too long
        endLoading(node);
        _requestCancelled = true;
    }, 60000);
}
function endLoading(node) {
    node.loading = false;
}
function requestWrapper(request, node) {
    startLoading(node);
    return request
        .then((result) => {
        endLoading(node);
        if (!_requestCancelled) {
            return Promise.resolve(result);
        }
        else {
            return Promise.reject(new Error("timeout"));
        }
    })
        .catch((error) => {
        endLoading(node);
        return Promise.reject(error);
    });
}



//# sourceMappingURL=loading-69139907.js.map

/***/ }),

/***/ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/slider-e162e136.js":
/*!************************************************************************************************************!*\
  !*** ./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/slider-e162e136.js ***!
  \************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   b: () => (/* binding */ barCreatedFunction),
/* harmony export */   u: () => (/* binding */ updateHistogramColors)
/* harmony export */ });
/* harmony import */ var _raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./raster-unique-value-0976ec7f.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/raster-unique-value-0976ec7f.js");
/* harmony import */ var _loadModules_b4ac1247_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./loadModules-b4ac1247.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/loadModules-b4ac1247.js");
/* harmony import */ var _commonEnums_fcf13661_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./commonEnums-fcf13661.js */ "./extensions/widgets/arcgis/analysis/node_modules/@arcgis/app-components/dist/esm/commonEnums-fcf13661.js");
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * v4.0.58
 */




function barCreatedFunction(colorVisVarOrBreaks, histogram, sliderBars, idx, element) {
    const color = (colorVisVarOrBreaks === null || colorVisVarOrBreaks === void 0 ? void 0 : colorVisVarOrBreaks.length)
        ? getColorForValueClassed(colorVisVarOrBreaks, histogram.bins[idx])
        : getColorForValue(colorVisVarOrBreaks.stops, histogram.bins[idx]);
    color && element.setAttribute("fill", color.toHex());
    color && element.setAttribute("opacity", `${Math.max(color.a, 0.2)}`);
    sliderBars.push(element);
}
function updateHistogramColors(slider, sliderBars, colorVisVarOrBreaks, histogram) {
    sliderBars === null || sliderBars === void 0 ? void 0 : sliderBars.forEach((element, index) => {
        const bin = (histogram || slider.histogramConfig).bins[index];
        const color = slider.breaks
            ? getColorForValueClassed(colorVisVarOrBreaks || slider.breaks, bin)
            : getColorForValue((colorVisVarOrBreaks || slider)
                .stops, bin);
        color && element.setAttribute("fill", color.toHex());
        color && element.setAttribute("opacity", `${Math.max(color.a, 0.2)}`);
    });
}
function getColorForValue(stops, bin) {
    // infers the color for a given value
    // based on the stops from a ColorVariable
    const { modules } = _raster_unique_value_0976ec7f_js__WEBPACK_IMPORTED_MODULE_0__.s;
    if (!bin) {
        return;
    }
    const value = (bin.maxValue - bin.minValue) / 2 + bin.minValue;
    let minStop = stops[0];
    let maxStop = stops[stops.length - 1];
    const minStopValue = minStop.value;
    const maxStopValue = maxStop.value;
    if (value < minStopValue) {
        return minStop.color;
    }
    if (value > maxStopValue) {
        return maxStop.color;
    }
    const exactMatches = stops.filter((stop) => stop.value === value);
    if (exactMatches.length > 0) {
        return exactMatches[0].color;
    }
    minStop = null;
    maxStop = null;
    stops.forEach((stop, i) => {
        if (!minStop && !maxStop && stop.value >= value) {
            minStop = stops[i - 1];
            maxStop = stop;
        }
    });
    const weightedPosition = (value - minStop.value) / (maxStop.value - minStop.value);
    return modules.esriColor.blendColors(minStop.color, maxStop.color, weightedPosition);
}
function getColorForValueClassed(breaks, bin) {
    // infers the color for a given value
    // based on the classBreakInfo
    if (!bin) {
        return;
    }
    const value = (bin.maxValue - bin.minValue) / 2 + bin.minValue;
    let minBreak = breaks[0];
    let maxBreak = breaks[breaks.length - 1];
    if (value < minBreak.min || value > maxBreak.max) {
        return undefined;
    }
    const exactMatches = breaks.filter((b) => b.min === value);
    if (exactMatches.length > 0) {
        return exactMatches[0].color;
    }
    minBreak = breaks[breaks.length - 1];
    maxBreak = null;
    breaks.forEach((b, i) => {
        if (!maxBreak && b.min >= value) {
            minBreak = breaks[i - 1];
            maxBreak = b;
        }
    });
    return minBreak.color;
}



//# sourceMappingURL=slider-e162e136.js.map

/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid2lkZ2V0cy9jaHVua3MvYXJjZ2lzX2FuYWx5c2lzX25vZGVfbW9kdWxlc19hcmNnaXNfYXBwLWNvbXBvbmVudHNfZGlzdF9lc21fYXJjZ2lzLTM5NDgwYi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQzhJO0FBQytRO0FBQzVWO0FBQ0w7QUFDekI7QUFDNkI7QUFDN0I7QUFDd0Q7QUFDb0Q7QUFDaEU7QUFDOEY7QUFDekk7QUFDVDtBQUNHO0FBQ0Q7QUFDVTs7QUFFdkMsc0RBQXNELGFBQWEsc0VBQXNFLGdCQUFnQiw0SUFBNEksYUFBYSxnSEFBZ0gsV0FBVyxnWkFBZ1osMEJBQTBCLG9iQUFvYixzQkFBc0IseUJBQXlCLHFCQUFxQixVQUFVLDBCQUEwQixhQUFhOztBQUVoNEM7QUFDQTtBQUNBLFFBQVEscURBQWdCO0FBQ3hCLG1EQUFtRCxxREFBVztBQUM5RCxrREFBa0QscURBQVc7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsK0RBQU07QUFDckMsZ0NBQWdDLCtEQUFNO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLCtEQUFNO0FBQ3RDO0FBQ0EsK0JBQStCLCtEQUFNO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixtRUFBYztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixTQUFTLEVBQUUsK0RBQWlCO0FBQzVDLGdCQUFnQixxREFBQyxDQUFDLGlEQUFJLFFBQVEscURBQUMsV0FBVyw0QkFBNEIsZ0JBQWdCO0FBQ3RGO0FBQ0EsZ0JBQWdCLHFEQUFXO0FBQzNCLGFBQWE7QUFDYjtBQUNBLGdCQUFnQixxREFBVztBQUMzQixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGtEQUFrRDtBQUNsRSxnQkFBZ0IsaUJBQWlCLEVBQUUsK0RBQWlCO0FBQ3BELHlCQUF5QixtRUFBVztBQUNwQyw0QkFBNEIsbUVBQVM7QUFDckMsaUNBQWlDLCtEQUFNO0FBQ3ZDLGlDQUFpQywrREFBTTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQywrREFBTTtBQUM1QyxpQ0FBaUMsK0RBQU07QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLG1FQUFhO0FBQ3JELG9DQUFvQyxvRUFBYztBQUNsRDtBQUNBLHNCQUFzQixvRUFBUyxnRkFBZ0Ysb0VBQVM7QUFDeEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLHdCQUF3QixxREFBQyxVQUFVLHFCQUFxQixFQUFFLHFEQUFDLHlEQUF5RCxxREFBQyxVQUFVLG1DQUFtQyw2Q0FBNkMscURBQUMsQ0FBQyxpREFBUSxRQUFRLHFEQUFDLG1FQUFtRSxxREFBQyxzREFBc0QscURBQUMsVUFBVTtBQUN2VztBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsVUFBVSxFQUFFLCtEQUFpQjtBQUM3QyxnQkFBZ0IscURBQUMsVUFBVSxxQkFBcUIsRUFBRSxxREFBQyxxQkFBcUIsd0JBQXdCO0FBQ2hHO0FBQ0E7QUFDQSxnQkFBZ0IsVUFBVSxFQUFFLCtEQUFpQjtBQUM3QyxnQkFBZ0IscURBQUMsa0NBQWtDLHdHQUF3RztBQUMzSjtBQUNBO0FBQ0EsZ0JBQWdCLFVBQVUsRUFBRSwrREFBaUI7QUFDN0MsZ0JBQWdCLGVBQWU7QUFDL0IsZ0JBQWdCLHFEQUFDLGtDQUFrQyw4TkFBOE47QUFDalI7QUFDQTtBQUNBLGdCQUFnQixVQUFVLEVBQUUsK0RBQWlCO0FBQzdDLGdCQUFnQixxREFBQyxrQ0FBa0MsK0ZBQStGO0FBQ2xKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsdURBQXVEO0FBQ3ZFLGdCQUFnQiwwQkFBMEIsRUFBRSwrREFBaUI7QUFDN0QseUJBQXlCLG1FQUFXO0FBQ3BDLDZCQUE2QixtRUFBZTtBQUM1QztBQUNBO0FBQ0EsMERBQTBELCtEQUFnQjtBQUMxRSw0QkFBNEIsbUVBQVM7QUFDckMsZ0NBQWdDLG1FQUFhO0FBQzdDO0FBQ0E7QUFDQSx5QkFBeUIsb0VBQWE7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFdBQVcsRUFBRSxvRUFBYyxHQUFHLFVBQVU7QUFDbkQsZ0NBQWdDLCtEQUFNO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVEO0FBQ3ZEO0FBQ0E7QUFDQSxvQkFBb0Isb0RBQXNCO0FBQzFDO0FBQ0E7QUFDQSxtQ0FBbUMseURBQWdCO0FBQ25EO0FBQ0EsaUNBQWlDLGtEQUFrQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxxREFBb0I7QUFDcEQsbUNBQW1DLHlEQUFnQjtBQUNuRDtBQUNBO0FBQ0Esd0JBQXdCLGtEQUFrQjtBQUMxQztBQUNBLGdCQUFnQixzREFBcUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RDtBQUN2RDtBQUNBLG1DQUFtQyx5REFBZ0I7QUFDbkQ7QUFDQTtBQUNBLG9CQUFvQixvREFBc0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxvRUFBYztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsa0RBQWtCO0FBQ25ELGdCQUFnQixzREFBcUI7QUFDckM7QUFDQTtBQUNBLGdDQUFnQyxxREFBb0I7QUFDcEQsbUNBQW1DLHlEQUFnQjtBQUNuRDtBQUNBO0FBQ0Esd0JBQXdCLGtEQUFrQjtBQUMxQyxnQkFBZ0Isc0RBQXFCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvRUFBUztBQUN4QjtBQUNBO0FBQ0EsZ0JBQWdCLGlCQUFpQixFQUFFLCtEQUFpQjtBQUNwRCx5QkFBeUIsbUVBQVc7QUFDcEMsNEJBQTRCLG1FQUFTO0FBQ3JDLFFBQVEsc0RBQXFCLHdEQUF3RCxxREFBb0I7QUFDekc7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsbUVBQWM7QUFDdEMsNENBQTRDLDJCQUEyQjtBQUN2RSxhQUFhO0FBQ2I7QUFDQTtBQUNBLG9CQUFvQixtRUFBYztBQUNsQyxvQkFBb0IsbUVBQWdCO0FBQ3BDO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsUUFBUSxvRUFBYztBQUN0QixRQUFRLHFEQUFXO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsK0RBQU07QUFDM0M7QUFDQTtBQUNBLGdCQUFnQixhQUFhO0FBQzdCLGdCQUFnQixRQUFRLEVBQUUsK0RBQWlCO0FBQzNDLHlCQUF5QixtRUFBVztBQUNwQyw0QkFBNEIsb0VBQVM7QUFDckMsNEJBQTRCLG1FQUFTO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxtRUFBYTtBQUM3QztBQUNBLGNBQWMsb0VBQWM7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QiwrREFBZ0I7QUFDN0MsU0FBUztBQUNUO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUSxFQUFFLCtEQUFpQjtBQUMzQyx5QkFBeUIsbUVBQVc7QUFDcEMsNkJBQTZCLG1FQUFlO0FBQzVDO0FBQ0EsMEJBQTBCLG1FQUFTO0FBQ25DLGdDQUFnQyxtRUFBYTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixpREFBK0I7QUFDeEQ7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGlEQUFrQztBQUMzRDtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsc0RBQXNDO0FBQy9EO0FBQ0E7QUFDQSx5QkFBeUIsc0RBQXNDO0FBQy9EO0FBQ0E7QUFDQSx5QkFBeUIsc0RBQW1DO0FBQzVEO0FBQ0E7QUFDQSx5QkFBeUIsbURBQWlDO0FBQzFEO0FBQ0EsUUFBUSx1REFBYztBQUN0Qix3QkFBd0IsbUVBQXFCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QywrREFBTTtBQUM5QztBQUNBO0FBQ0EsZ0JBQWdCLG9FQUFTO0FBQ3pCLGdCQUFnQixvRUFBUztBQUN6QjtBQUNBO0FBQ0Esd0NBQXdDLCtEQUFNO0FBQzlDO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QywrREFBTTtBQUM5QztBQUNBO0FBQ0E7QUFDQSxZQUFZLG9FQUFjO0FBQzFCLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsbUNBQW1DLEVBQUUsK0RBQWlCO0FBQ3RFO0FBQ0EseUJBQXlCLG1FQUFXO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixtRUFBUztBQUNyQztBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsbUVBQWE7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLCtEQUFNO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixvRUFBUztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixvRUFBUztBQUNuQyxxQkFBcUIsb0VBQVM7QUFDOUIscUJBQXFCLG9FQUFTO0FBQzlCO0FBQ0EsNENBQTRDLCtEQUFNO0FBQ2xEO0FBQ0E7QUFDQSw2QkFBNkIsb0VBQWM7QUFDM0M7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLCtEQUFNO0FBQzlDO0FBQ0EsYUFBYTtBQUNiO0FBQ0Esd0NBQXdDLCtEQUFNO0FBQzlDLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixtQ0FBbUMsRUFBRSwrREFBaUI7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQiwrREFBTTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixvRUFBUztBQUMvQixzQkFBc0Isb0VBQVM7QUFDL0I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsbUNBQW1DLCtEQUFNO0FBQ3pDLFNBQVM7QUFDVDtBQUNBLG1DQUFtQywrREFBTTtBQUN6QyxTQUFTO0FBQ1Q7QUFDQTtBQUNBLGdCQUFnQixhQUFhO0FBQzdCLGdCQUFnQixRQUFRLEVBQUUsK0RBQWlCO0FBQzNDLHlCQUF5QixtRUFBVztBQUNwQyw0QkFBNEIsbUVBQVM7QUFDckMsZ0NBQWdDLG1FQUFhO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixvRUFBYztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixvRUFBUyxzQkFBc0Isb0VBQVM7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsc0RBQXFCLHdEQUF3RCxxREFBb0I7QUFDekc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUSxFQUFFLCtEQUFpQjtBQUMzQyx5QkFBeUIsbUVBQVc7QUFDcEMsNEJBQTRCLG1FQUFTO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLG9FQUFNO0FBQzFDO0FBQ0Esb0JBQW9CLHFEQUFXO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUSxFQUFFLCtEQUFpQjtBQUMzQyx5QkFBeUIsbUVBQVc7QUFDcEMsNEJBQTRCLG1FQUFTO0FBQ3JDLGdDQUFnQyxtRUFBYTtBQUM3QztBQUNBO0FBQ0EsNEJBQTRCLG9FQUFjO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLG9FQUFTLHNCQUFzQixvRUFBUztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxzREFBcUI7QUFDN0IsUUFBUSxvRUFBYztBQUN0QjtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVEsRUFBRSwrREFBaUI7QUFDM0MseUJBQXlCLG1FQUFXO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFFBQVEsRUFBRSwwQ0FBMEMsSUFBSSx5Q0FBeUM7QUFDM0k7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVEsc0RBQXFCLHlDQUF5QyxxREFBb0I7QUFDMUYsUUFBUSxvRUFBYztBQUN0QjtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsK0RBQWdCO0FBQzFEO0FBQ0Esb0NBQW9DLEtBQUssZ0NBQWdDLEtBQUs7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVEsRUFBRSwrREFBaUI7QUFDM0MseUJBQXlCLG1FQUFXO0FBQ3BDLDRCQUE0QixtRUFBUztBQUNyQyxzQkFBc0IsbUVBQVE7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsK0RBQWdCO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsYUFBYTtBQUM3QixnQkFBZ0IsUUFBUSxFQUFFLCtEQUFpQjtBQUMzQyx5QkFBeUIsbUVBQVc7QUFDcEMsNEJBQTRCLG1FQUFTO0FBQ3JDLGdDQUFnQyxtRUFBYTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsT0FBTyxxREFBVTtBQUN6QztBQUNBOztBQUU4RTs7QUFFOUU7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3R3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDK1A7QUFDNU47QUFDNEI7O0FBRS9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxxREFBcUQsRUFBRSwrREFBaUI7QUFDcEY7QUFDQTtBQUNBLG1CQUFtQixtRUFBZ0IsQ0FBQyxtRUFBVztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLG1FQUFlO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLGNBQWMsK0RBQVM7QUFDdkI7QUFDQSxrQkFBa0IsbUVBQWE7QUFDL0I7QUFDQTtBQUNBLGNBQWMsK0RBQVM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxnQ0FBZ0MsbUVBQWE7QUFDN0MseUNBQXlDO0FBQ3pDLFFBQVEsbUVBQWlCO0FBQ3pCO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxxREFBcUQsRUFBRSwrREFBaUI7QUFDcEY7QUFDQTtBQUNBLHFCQUFxQixtRUFBVztBQUNoQyx3QkFBd0IsbUVBQVM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxtRUFBTztBQUNuQjtBQUNBLHFDQUFxQyw0QkFBNEI7QUFDakU7QUFDQTtBQUNBLDRCQUE0QixtRUFBYTtBQUN6QyxtQkFBbUIsbUVBQWdCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLCtEQUFnQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLCtEQUFnQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLCtEQUFTO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLCtEQUFTO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsbUVBQWU7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsK0RBQVM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLCtEQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsK0RBQVM7QUFDdkM7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxnQ0FBZ0MsbUVBQVM7QUFDekMsbUNBQW1DLG1FQUFTO0FBQzVDO0FBQ0E7QUFDQSxnQ0FBZ0MsbUVBQWE7QUFDN0M7QUFDQTtBQUNBLFFBQVEsbUVBQWlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRThFOztBQUU5RTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNyS0E7QUFDQTtBQUNBO0FBQ0E7QUFDMkU7QUFDeEM7QUFDQTs7QUFFbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQXFFLFVBQVU7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQXFFLFVBQVU7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELGlCQUFpQjtBQUM5RSxvREFBb0QsVUFBVTtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsaUJBQWlCO0FBQzlFLG9EQUFvRCxVQUFVO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksVUFBVSxFQUFFLCtEQUFpQjtBQUN6QztBQUNBO0FBQ0EsMkVBQTJFLHlGQUF5Riw4Q0FBOEM7QUFDbE47QUFDQTtBQUNBO0FBQ0EsMkVBQTJFLHlGQUF5RixVQUFVO0FBQzlLO0FBQ0E7QUFDQTtBQUNBOztBQUV5Rzs7QUFFekc7Ozs7Ozs7Ozs7Ozs7O0FDL0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRStCOztBQUUvQjs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDekNBO0FBQ0E7QUFDQTtBQUNBO0FBQzJFO0FBQ3hDO0FBQ0E7O0FBRW5DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsdUJBQXVCO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELHVCQUF1QjtBQUMzRSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFVBQVUsRUFBRSwrREFBaUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUUrRDs7QUFFL0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9leGItY2xpZW50Ly4vZXh0ZW5zaW9ucy93aWRnZXRzL2FyY2dpcy9hbmFseXNpcy9ub2RlX21vZHVsZXMvQGFyY2dpcy9hcHAtY29tcG9uZW50cy9kaXN0L2VzbS9hcmNnaXMtc21hcnQtbWFwcGluZy1jb2xvci1zbGlkZXIuZW50cnkuanMiLCJ3ZWJwYWNrOi8vZXhiLWNsaWVudC8uL2V4dGVuc2lvbnMvd2lkZ2V0cy9hcmNnaXMvYW5hbHlzaXMvbm9kZV9tb2R1bGVzL0BhcmNnaXMvYXBwLWNvbXBvbmVudHMvZGlzdC9lc20vY29tcGFyZS1iYTEyOTJmZS5qcyIsIndlYnBhY2s6Ly9leGItY2xpZW50Ly4vZXh0ZW5zaW9ucy93aWRnZXRzL2FyY2dpcy9hbmFseXNpcy9ub2RlX21vZHVsZXMvQGFyY2dpcy9hcHAtY29tcG9uZW50cy9kaXN0L2VzbS9kYXRlLTc5YzdkOTNjLmpzIiwid2VicGFjazovL2V4Yi1jbGllbnQvLi9leHRlbnNpb25zL3dpZGdldHMvYXJjZ2lzL2FuYWx5c2lzL25vZGVfbW9kdWxlcy9AYXJjZ2lzL2FwcC1jb21wb25lbnRzL2Rpc3QvZXNtL2xvYWRpbmctNjkxMzk5MDcuanMiLCJ3ZWJwYWNrOi8vZXhiLWNsaWVudC8uL2V4dGVuc2lvbnMvd2lkZ2V0cy9hcmNnaXMvYW5hbHlzaXMvbm9kZV9tb2R1bGVzL0BhcmNnaXMvYXBwLWNvbXBvbmVudHMvZGlzdC9lc20vc2xpZGVyLWUxNjJlMTM2LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogQWxsIG1hdGVyaWFsIGNvcHlyaWdodCBFU1JJLCBBbGwgUmlnaHRzIFJlc2VydmVkLCB1bmxlc3Mgb3RoZXJ3aXNlIHNwZWNpZmllZC5cbiAqIHY0LjAuNThcbiAqL1xuaW1wb3J0IHsgciBhcyByZWdpc3Rlckluc3RhbmNlLCBjIGFzIGNyZWF0ZUV2ZW50LCBoLCBmIGFzIGZvcmNlVXBkYXRlLCBIIGFzIEhvc3QsIEYgYXMgRnJhZ21lbnQsIGQgYXMgZ2V0RWxlbWVudCB9IGZyb20gJy4vaW5kZXgtZTNiZjdkYTcuanMnO1xuaW1wb3J0IHsgYiBhcyBzdGF0dXMsIEYgYXMgZmluZFBhcmVudE5vZGUsIGEgYXMgZ2V0VmlzVmFyLCBwIGFzIGdldEF1dGhWaXNWYXIsIGFjIGFzIGlzRGVmaW5lZCwgZyBhcyBnZXRSZW5kZXJlclR5cGUsIGFkIGFzIHZhbGlkYXRlTWluTWF4LCBhQyBhcyBnZXRab29tT3B0aW9ucywgdCBhcyBnZXRTeW1ib2xDb2xvciwgciBhcyBhcHBseVN5bWJvbENvbG9yLCBhYiBhcyB1cGRhdGVSZW5kZXJlciwgdyBhcyBzaW1wbGVGaWVsZFR5cGVzLCBmIGFzIGdldFJlbmRlcmVyRmllbGRJbmZvcywgdSBhcyBnZXRGaWVsZCwgcyBhcyBzbWFydE1hcHBpbmdTdGF0ZSwgaCBhcyBnZXRSZW5kZXJlciwgYUQgYXMgZ2V0SGFuZGxlSW5mbywgYUggYXMgaXNEYXRlIH0gZnJvbSAnLi9yYXN0ZXItdW5pcXVlLXZhbHVlLTA5NzZlYzdmLmpzJztcbmltcG9ydCB7IGEgYXMgYWRkRGF0ZUZvcm1hdEZ1bmN0aW9ucyB9IGZyb20gJy4vZGF0ZS03OWM3ZDkzYy5qcyc7XG5pbXBvcnQgeyByIGFzIHJlcXVlc3RXcmFwcGVyIH0gZnJvbSAnLi9sb2FkaW5nLTY5MTM5OTA3LmpzJztcbmltcG9ydCAnLi9sb2FkTW9kdWxlcy1iNGFjMTI0Ny5qcyc7XG5pbXBvcnQgeyBnIGFzIGdldFN0b3BQcmVjaXNpb24gfSBmcm9tICcuL3ByZWNpc2lvbi0wNmE3MzY3Mi5qcyc7XG5pbXBvcnQgJy4vY29tbW9uRW51bXMtZmNmMTM2NjEuanMnO1xuaW1wb3J0IHsgYiBhcyBiYXJDcmVhdGVkRnVuY3Rpb24sIHUgYXMgdXBkYXRlSGlzdG9ncmFtQ29sb3JzIH0gZnJvbSAnLi9zbGlkZXItZTE2MmUxMzYuanMnO1xuaW1wb3J0IHsgZyBhcyBnZXRDbGFzc0JyZWFrc0NvbG9ycywgYiBhcyBjcmVhdGVDb2xvclJlbmRlcmVyRnJvbUV4aXN0aW5nLCBkIGFzIGNyZWF0ZUNvbG9yQWdlUmVuZGVyZXJGcm9tRXhpc3RpbmcgfSBmcm9tICcuL2NvbG9yLWQ2ZGEwYTlhLmpzJztcbmltcG9ydCB7IGEgYXMgY3JlYXRlQ29tcGFyZVJlbmRlcmVyRnJvbUV4aXN0aW5nIH0gZnJvbSAnLi9jb21wYXJlLWJhMTI5MmZlLmpzJztcbmltcG9ydCB7IGggYXMgY3JlYXRlQ29sb3JBZ2VTaXplUmVuZGVyZXJGcm9tRXhpc3RpbmcsIGkgYXMgY3JlYXRlQ29sb3JTaXplQWdlUmVuZGVyZXJGcm9tRXhpc3RpbmcsIGogYXMgY3JlYXRlQ29sb3JTaXplUmVuZGVyZXJGcm9tRXhpc3RpbmcgfSBmcm9tICcuL2NvbG9yU2l6ZS1jZTBjY2RlYi5qcyc7XG5pbXBvcnQgJy4vbGFuZ3VhZ2VVdGlsLWVmMGU1NGIyLmpzJztcbmltcG9ydCAnLi9kb20tNGQzNjc2NzcuanMnO1xuaW1wb3J0ICcuL2xvY2FsZS0wNTBiNmRiOS5qcyc7XG5pbXBvcnQgJy4vaW5kZXgtMDU5NTZjYWIuanMnO1xuaW1wb3J0ICcuL2NvbW1vbkZ1bmN0aW9ucy1iMDgzMGU5ZS5qcyc7XG5cbmNvbnN0IGFyY2dpc1NtYXJ0TWFwcGluZ0NvbG9yU2xpZGVyQ3NzID0gXCIuc2xpZGVyLWJveHtoZWlnaHQ6MzIwcHh9LnNsaWRlci1ib3ggLmVzcmktY29sb3Itc2xpZGVyLC5zbGlkZXItYm94IC5lc3JpLWNsYXNzZWQtY29sb3Itc2xpZGVye21pbi13aWR0aDoyMDBweH0uc2xpZGVyLWJveCAuZXNyaS1jb2xvci1zbGlkZXIgLmVzcmktc2xpZGVyIC5lc3JpLXNsaWRlcl9fY29udGVudCwuc2xpZGVyLWJveCAuZXNyaS1jbGFzc2VkLWNvbG9yLXNsaWRlciAuZXNyaS1zbGlkZXIgLmVzcmktc2xpZGVyX19jb250ZW50e2hlaWdodDoxNzVweH0uc2xpZGVyLWJveCAuZXNyaS1jb2xvci1zbGlkZXJfX2hpc3RvZ3JhbS1jb250YWluZXIsLnNsaWRlci1ib3ggLmVzcmktY2xhc3NlZC1jb2xvci1zbGlkZXJfX2hpc3RvZ3JhbS1jb250YWluZXJ7d2lkdGg6ODVweH0uc2xpZGVyLWJveCAuZXNyaS1jb2xvci1zbGlkZXIgLmVzcmktc2xpZGVyIC5lc3JpLXNsaWRlcl9fbGFiZWwsLnNsaWRlci1ib3ggLmVzcmktY29sb3Itc2xpZGVyIC5lc3JpLXNsaWRlciAuZXNyaS1zbGlkZXJfX21pbiwuc2xpZGVyLWJveCAuZXNyaS1jb2xvci1zbGlkZXIgLmVzcmktc2xpZGVyIC5lc3JpLXNsaWRlcl9fbWF4LC5zbGlkZXItYm94IC5lc3JpLWNsYXNzZWQtY29sb3Itc2xpZGVyIC5lc3JpLXNsaWRlciAuZXNyaS1zbGlkZXJfX2xhYmVsLC5zbGlkZXItYm94IC5lc3JpLWNsYXNzZWQtY29sb3Itc2xpZGVyIC5lc3JpLXNsaWRlciAuZXNyaS1zbGlkZXJfX21pbiwuc2xpZGVyLWJveCAuZXNyaS1jbGFzc2VkLWNvbG9yLXNsaWRlciAuZXNyaS1zbGlkZXIgLmVzcmktc2xpZGVyX19tYXh7dGV4dC1kZWNvcmF0aW9uOnVuZGVybGluZX0uc2xpZGVyLWJveCAuZXNyaS1jb2xvci1zbGlkZXIgLmVzcmktc2xpZGVyIC5lc3JpLXNsaWRlcl9fbGFiZWw6aG92ZXIsLnNsaWRlci1ib3ggLmVzcmktY29sb3Itc2xpZGVyIC5lc3JpLXNsaWRlciAuZXNyaS1zbGlkZXJfX21pbjpob3Zlciwuc2xpZGVyLWJveCAuZXNyaS1jb2xvci1zbGlkZXIgLmVzcmktc2xpZGVyIC5lc3JpLXNsaWRlcl9fbWF4OmhvdmVyLC5zbGlkZXItYm94IC5lc3JpLWNsYXNzZWQtY29sb3Itc2xpZGVyIC5lc3JpLXNsaWRlciAuZXNyaS1zbGlkZXJfX2xhYmVsOmhvdmVyLC5zbGlkZXItYm94IC5lc3JpLWNsYXNzZWQtY29sb3Itc2xpZGVyIC5lc3JpLXNsaWRlciAuZXNyaS1zbGlkZXJfX21pbjpob3Zlciwuc2xpZGVyLWJveCAuZXNyaS1jbGFzc2VkLWNvbG9yLXNsaWRlciAuZXNyaS1zbGlkZXIgLmVzcmktc2xpZGVyX19tYXg6aG92ZXJ7Ym9yZGVyOjFweCBzb2xpZCAjYmJiO2JhY2tncm91bmQtY29sb3I6I2YzZjNmMzt0ZXh0LWRlY29yYXRpb246bm9uZTt6LWluZGV4OjF9LnNsaWRlci1ib3gtYnV0dG9ucy1mcm9udHtkaXNwbGF5OmZsZXh9XCI7XG5cbmNvbnN0IEFyY2dpc1NtYXJ0TWFwcGluZ0NvbG9yU2xpZGVyID0gY2xhc3Mge1xuICAgIGNvbnN0cnVjdG9yKGhvc3RSZWYpIHtcbiAgICAgICAgcmVnaXN0ZXJJbnN0YW5jZSh0aGlzLCBob3N0UmVmKTtcbiAgICAgICAgdGhpcy5hcmNnaXNTbWFydE1hcHBpbmdDb2xvclNsaWRlckNoYW5nZSA9IGNyZWF0ZUV2ZW50KHRoaXMsIFwiYXJjZ2lzU21hcnRNYXBwaW5nQ29sb3JTbGlkZXJDaGFuZ2VcIiwgNyk7XG4gICAgICAgIHRoaXMuYXJjZ2lzU21hcnRNYXBwaW5nQ29sb3JTbGlkZXJFcnJvciA9IGNyZWF0ZUV2ZW50KHRoaXMsIFwiYXJjZ2lzU21hcnRNYXBwaW5nQ29sb3JTbGlkZXJFcnJvclwiLCA3KTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE5lY2Vzc2FyeSBmb3IgdHJhY2tpbmcgc3RvcHMgZm9yIG5vbi1jbGFzc2VkIHNsaWRlcnMsXG4gICAgICAgICAqIHdob3NlIHZhbHVlcyBhcmUgdXBkYXRlZCBpbW1lZGlhdGVseSBldmVuIGdpdmVuIGluY29ycmVjdCBpbnB1dHMuXG4gICAgICAgICAqIENsYXNzZWQgc2xpZGVycyBkbyBub3QgaGF2ZSB0aGlzIGlzc3VlLCBidXQgd2UgaGFuZGxlIHRoZW1cbiAgICAgICAgICogaWRlbnRpY2FsbHkgZm9yIGxvZ2ljYWwgcGFyaXR5LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jdXJyZW50U3RvcFZhbHVlcyA9IFtdO1xuICAgICAgICB0aGlzLmN1cnJlbnRCcmVha1ZhbHVlcyA9IFtdO1xuICAgICAgICB0aGlzLnppZ3phZ0NsaWNrID0gZmFsc2U7XG4gICAgICAgIHRoaXMuc3R5bGVTaGVldFN0YXR1cyA9IFwibm90LWxvYWRlZFwiO1xuICAgICAgICB0aGlzLmhpc3RvZ3JhbVN0YXR1cyA9IHN0YXR1cy5NSVNTSU5HO1xuICAgICAgICB0aGlzLnN0YXRpc3RpY3NTdGF0dXMgPSBzdGF0dXMuTUlTU0lORztcbiAgICAgICAgdGhpcy5zbGlkZXJab29tZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jYXAgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvL1xuICAgIC8vICBQdWJsaWMgQ2FsbHNcbiAgICAvL1xuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBhc3luYyB1cGRhdGVTdGF0aXN0aWNzKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHRoaXMuc3RhdGlzdGljc1N0YXR1cyA9IHN0YXR1cy5NSVNTSU5HO1xuICAgICAgICB0aGlzLnN0YXRpc3RpY3MgPSBudWxsO1xuICAgICAgICB0aGlzLmhpc3RvZ3JhbVN0YXR1cyA9IHN0YXR1cy5NSVNTSU5HO1xuICAgICAgICB0aGlzLmhpc3RvZ3JhbSA9IG51bGw7XG4gICAgICAgIChfYSA9IHRoaXMuY29sb3JTbGlkZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuY29sb3JTbGlkZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuc2xpZGVyWm9vbWVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZ2V0U3RhdGlzdGljcygpO1xuICAgIH1cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy9cbiAgICAvLyBMaWZlY3ljbGVcbiAgICAvL1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBjb21wb25lbnRXaWxsTG9hZCgpIHtcbiAgICAgICAgdGhpcy5nZXRTdGF0aXN0aWNzKCk7XG4gICAgfVxuICAgIGNvbXBvbmVudERpZExvYWQoKSB7XG4gICAgICAgIHRoaXMuZmxvd0l0ZW1Ob2RlID0gZmluZFBhcmVudE5vZGUodGhpcy5ob3N0RWxlbWVudCwgXCJjYWxjaXRlLWZsb3ctaXRlbVwiKTtcbiAgICB9XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vXG4gICAgLy8gIFJlbmRlciBNZXRob2RzXG4gICAgLy9cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgcmVuZGVyKCkge1xuICAgICAgICBjb25zdCB7IGNvbmZpZyB9ID0gc21hcnRNYXBwaW5nU3RhdGU7XG4gICAgICAgIHJldHVybiAoaChIb3N0LCBudWxsLCBoKFwibGlua1wiLCB7IHJlbDogXCJzdHlsZXNoZWV0XCIsIGhyZWY6IGAke2NvbmZpZy5qc2FwaVVybH0vdGhlbWVzL2xpZ2h0L21haW4uY3NzYCwgb25Mb2FkOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdHlsZVNoZWV0U3RhdHVzID0gXCJsb2FkZWRcIjtcbiAgICAgICAgICAgICAgICBmb3JjZVVwZGF0ZSh0aGlzLmhvc3RFbGVtZW50KTtcbiAgICAgICAgICAgIH0sIG9uRXJyb3I6ICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0eWxlU2hlZXRTdGF0dXMgPSBcImZhaWxlZFwiO1xuICAgICAgICAgICAgICAgIGZvcmNlVXBkYXRlKHRoaXMuaG9zdEVsZW1lbnQpO1xuICAgICAgICAgICAgfSB9KSwgdGhpcy5zdHlsZVNoZWV0U3RhdHVzID09PSBcImxvYWRlZFwiXG4gICAgICAgICAgICA/IHRoaXMucmVuZGVyQ29sb3JTbGlkZXIoKVxuICAgICAgICAgICAgOiB0aGlzLnN0eWxlU2hlZXRTdGF0dXMgPT09IFwibm90LWxvYWRlZFwiXG4gICAgICAgICAgICAgICAgPyB0aGlzLnJlbmRlckNvbG9yU2xpZGVyTG9hZGluZygpXG4gICAgICAgICAgICAgICAgOiBudWxsKSk7XG4gICAgfVxuICAgIHJlbmRlckNvbG9yU2xpZGVyKCkge1xuICAgICAgICBjb25zdCB7IHN0YXRpc3RpY3NTdGF0dXMsIGhpc3RvZ3JhbVN0YXR1cywgc2xpZGVyWm9vbWVkIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCB7IGxheWVyLCBzdHJpbmdzIH0gPSBzbWFydE1hcHBpbmdTdGF0ZTtcbiAgICAgICAgY29uc3QgcmVuZGVyZXIgPSBnZXRSZW5kZXJlcihsYXllcik7XG4gICAgICAgIGNvbnN0IGNvbG9yVmlzVmFyID0gZ2V0VmlzVmFyKHJlbmRlcmVyLCBcImNvbG9yXCIpO1xuICAgICAgICBpZiAoc3RhdGlzdGljc1N0YXR1cyA9PT0gc3RhdHVzLkZBSUxFRCB8fFxuICAgICAgICAgICAgc3RhdGlzdGljc1N0YXR1cyA9PT0gc3RhdHVzLk1JU1NJTkcgfHxcbiAgICAgICAgICAgIChjb2xvclZpc1ZhciAmJiBjb2xvclZpc1Zhci5zdG9wcy5sZW5ndGggPT09IDEpIHx8XG4gICAgICAgICAgICAoIWNvbG9yVmlzVmFyICYmIHJlbmRlcmVyLmNsYXNzQnJlYWtJbmZvcy5sZW5ndGggPT09IDEpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jb2xvclNsaWRlcikge1xuICAgICAgICAgICAgICAgIHRoaXMuY29sb3JTbGlkZXIuZGVzdHJveSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuY29sb3JTbGlkZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc3RhdGlzdGljc1N0YXR1cyA9PT0gc3RhdHVzLklOX1BST0dSRVNTIHx8XG4gICAgICAgICAgICAoaGlzdG9ncmFtU3RhdHVzID09PSBzdGF0dXMuSU5fUFJPR1JFU1MgJiYgIXRoaXMuY29sb3JTbGlkZXIpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZW5kZXJDb2xvclNsaWRlckxvYWRpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IG9rID0gdGhpcy5wcmVwYXJlQ29sb3JTbGlkZXIoKTtcbiAgICAgICAgICAgIGxldCBkaXNhYmxlWm9vbUJ1dHRvbiA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKGNvbG9yVmlzVmFyICYmICFzbGlkZXJab29tZWQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBhdXRoQ29sb3JWaXNWYXIgPSBnZXRBdXRoVmlzVmFyKHJlbmRlcmVyLCBcImNvbG9yXCIpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHpvb21PcHRpb25zID0gZ2V0Wm9vbU9wdGlvbnMoY29sb3JWaXNWYXIuc3RvcHMsIGF1dGhDb2xvclZpc1ZhciA9PT0gbnVsbCB8fCBhdXRoQ29sb3JWaXNWYXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGF1dGhDb2xvclZpc1Zhci5taW5TbGlkZXJWYWx1ZSwgYXV0aENvbG9yVmlzVmFyID09PSBudWxsIHx8IGF1dGhDb2xvclZpc1ZhciA9PT0gdm9pZCAwID8gdm9pZCAwIDogYXV0aENvbG9yVmlzVmFyLm1heFNsaWRlclZhbHVlKTtcbiAgICAgICAgICAgICAgICBpZiAoKHpvb21PcHRpb25zID09PSBudWxsIHx8IHpvb21PcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiB6b29tT3B0aW9ucy5taW5NYXhTYW1lKSB8fFxuICAgICAgICAgICAgICAgICAgICAoIWlzRGVmaW5lZCh6b29tT3B0aW9ucyA9PT0gbnVsbCB8fCB6b29tT3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogem9vbU9wdGlvbnMubWluKSAmJiAhaXNEZWZpbmVkKHpvb21PcHRpb25zID09PSBudWxsIHx8IHpvb21PcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiB6b29tT3B0aW9ucy5tYXgpKSkge1xuICAgICAgICAgICAgICAgICAgICBkaXNhYmxlWm9vbUJ1dHRvbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnpvb21CdXR0b25Ob2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnpvb21CdXR0b25Ob2RlLmRpc2FibGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb2xvclZpc1Zhcikge1xuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudFN0b3BWYWx1ZXMgPSBjb2xvclZpc1Zhci5zdG9wcy5tYXAoKHN0b3ApID0+IHN0b3AudmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50QnJlYWtWYWx1ZXMgPSByZW5kZXJlci5jbGFzc0JyZWFrSW5mb3MubWFwKChjbGFzc0JyZWFrSW5mbykgPT4gKHtcbiAgICAgICAgICAgICAgICAgICAgbWluOiBjbGFzc0JyZWFrSW5mby5taW5WYWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgbWF4OiBjbGFzc0JyZWFrSW5mby5tYXhWYWx1ZVxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvayB8fCB0aGlzLmNvbG9yU2xpZGVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChoKFwiZGl2XCIsIHsgY2xhc3M6IFwic2xpZGVyLWJveFwiIH0sIGgoXCJjYWxjaXRlLWxhYmVsXCIsIG51bGwsIHN0cmluZ3MucGFuZWxzLmNvbG9yLmRhdGFSYW5nZSksIGgoXCJkaXZcIiwgeyBjbGFzczogXCJzbGlkZXItYm94LWJ1dHRvbnMtZnJvbnRcIiB9LCB0aGlzLnJlbmRlckludmVydEJ1dHRvbigpLCBjb2xvclZpc1ZhciAmJiAoaChGcmFnbWVudCwgbnVsbCwgaChcImRpdlwiLCBudWxsLCBcIlxcdTAwQTBcIiksIHRoaXMucmVuZGVyWm9vbUJ1dHRvbihkaXNhYmxlWm9vbUJ1dHRvbiksIGgoXCJkaXZcIiwgbnVsbCwgXCJcXHUwMEEwXCIpLCB0aGlzLnJlbmRlclJlc2V0QnV0dG9uKCkpKSksIGgoXCJkaXZcIiwgeyByZWY6IChub2RlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWZ0ZXJDb2xvclNsaWRlckNyZWF0ZShub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSB9KSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVuZGVyQ29sb3JTbGlkZXJMb2FkaW5nKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVuZGVyQ29sb3JTbGlkZXJMb2FkaW5nKCkge1xuICAgICAgICBjb25zdCB7IHN0cmluZ3MgfSA9IHNtYXJ0TWFwcGluZ1N0YXRlO1xuICAgICAgICByZXR1cm4gKGgoXCJkaXZcIiwgeyBjbGFzczogXCJzbGlkZXItYm94XCIgfSwgaChcImNhbGNpdGUtbG9hZGVyXCIsIHsgbGFiZWw6IHN0cmluZ3MubG9hZGluZyB9KSkpO1xuICAgIH1cbiAgICByZW5kZXJJbnZlcnRCdXR0b24oKSB7XG4gICAgICAgIGNvbnN0IHsgc3RyaW5ncyB9ID0gc21hcnRNYXBwaW5nU3RhdGU7XG4gICAgICAgIHJldHVybiAoaChcImFyY2dpcy1zbWFydC1tYXBwaW5nLWFjdGlvblwiLCB7IHRleHQ6IHN0cmluZ3MucGFuZWxzLmNvbG9yLmludmVydFNsaWRlciwgaWNvbjogXCJhcnJvd1VwRG93blwiLCBvbkNsaWNrOiAoKSA9PiB0aGlzLmhhbmRsZUludmVydFNsaWRlcigpIH0pKTtcbiAgICB9XG4gICAgcmVuZGVyWm9vbUJ1dHRvbihkaXNhYmxlWm9vbUJ1dHRvbikge1xuICAgICAgICBjb25zdCB7IHN0cmluZ3MgfSA9IHNtYXJ0TWFwcGluZ1N0YXRlO1xuICAgICAgICBjb25zdCB7IHNsaWRlclpvb21lZCB9ID0gdGhpcztcbiAgICAgICAgcmV0dXJuIChoKFwiYXJjZ2lzLXNtYXJ0LW1hcHBpbmctYWN0aW9uXCIsIHsgdGV4dDogc3RyaW5ncy5wYW5lbHMuY29sb3Iuem9vbVNsaWRlciwgaWNvbjogc2xpZGVyWm9vbWVkID8gXCJtYWduaWZ5aW5nR2xhc3NNaW51c1wiIDogXCJtYWduaWZ5aW5nR2xhc3NQbHVzXCIsIGRpc2FibGVkOiBkaXNhYmxlWm9vbUJ1dHRvbiwgb25DbGljazogKCkgPT4gdGhpcy5oYW5kbGVab29tU2xpZGVyKCksIHJlZjogKG5vZGUpID0+ICh0aGlzLnpvb21CdXR0b25Ob2RlID0gbm9kZSkgfSkpO1xuICAgIH1cbiAgICByZW5kZXJSZXNldEJ1dHRvbigpIHtcbiAgICAgICAgY29uc3QgeyBzdHJpbmdzIH0gPSBzbWFydE1hcHBpbmdTdGF0ZTtcbiAgICAgICAgcmV0dXJuIChoKFwiYXJjZ2lzLXNtYXJ0LW1hcHBpbmctYWN0aW9uXCIsIHsgdGV4dDogc3RyaW5ncy5wYW5lbHMuY29sb3IucmVzZXRTbGlkZXIsIGljb246IFwidW5kb1wiLCBvbkNsaWNrOiAoKSA9PiB0aGlzLmhhbmRsZVJlc2V0U2xpZGVyKCkgfSkpO1xuICAgIH1cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy9cbiAgICAvLyAgUHJpdmF0ZSBtZXRob2RzXG4gICAgLy9cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgcHJlcGFyZUNvbG9yU2xpZGVyKCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBjb25zdCB7IHN0YXRpc3RpY3MsIGhpc3RvZ3JhbSwgaGlzdG9ncmFtU3RhdHVzLCBzbGlkZXJab29tZWQgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHsgbGF5ZXIsIG1hcFZpZXcsIG1vZHVsZXMgfSA9IHNtYXJ0TWFwcGluZ1N0YXRlO1xuICAgICAgICBjb25zdCByZW5kZXJlciA9IGdldFJlbmRlcmVyKGxheWVyKTtcbiAgICAgICAgY29uc3QgcmVuZGVyZXJUeXBlID0gZ2V0UmVuZGVyZXJUeXBlKCk7XG4gICAgICAgIGNvbnN0IGlzQWdlUmVuZGVyZXIgPSBbXCJjb2xvci1hZ2VcIiwgXCJjb2xvci1hZ2Utc2l6ZVwiXS5pbmRleE9mKHJlbmRlcmVyVHlwZSkgPiAtMTtcbiAgICAgICAgY29uc3QgZmllbGRJbmZvID0gdGhpcy5nZXRGaWVsZEluZm8oKTtcbiAgICAgICAgY29uc3QgaXNEYXRlRmllbGQgPSBmaWVsZEluZm8uc2ltcGxlRmllbGRUeXBlID09PSBzaW1wbGVGaWVsZFR5cGVzLkRBVEU7XG4gICAgICAgIGNvbnN0IGNvbG9yVmlzVmFyID0gZ2V0VmlzVmFyKHJlbmRlcmVyLCBcImNvbG9yXCIpO1xuICAgICAgICBjb25zdCBhdXRoQ29sb3JWaXNWYXIgPSBnZXRBdXRoVmlzVmFyKHJlbmRlcmVyLCBcImNvbG9yXCIpO1xuICAgICAgICBsZXQgaGFuZGxlSW5mbywgbWluLCBtYXg7XG4gICAgICAgIGlmIChhdXRoQ29sb3JWaXNWYXIpIHtcbiAgICAgICAgICAgIGhhbmRsZUluZm8gPSBnZXRIYW5kbGVJbmZvKGF1dGhDb2xvclZpc1Zhci50aGVtZSwgY29sb3JWaXNWYXIuc3RvcHMpO1xuICAgICAgICAgICAgbWluID0gYXV0aENvbG9yVmlzVmFyLm1pblNsaWRlclZhbHVlO1xuICAgICAgICAgICAgbWF4ID0gYXV0aENvbG9yVmlzVmFyLm1heFNsaWRlclZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbWluID0gcmVuZGVyZXIuY2xhc3NCcmVha0luZm9zWzBdLm1pblZhbHVlO1xuICAgICAgICAgICAgbWF4ID0gcmVuZGVyZXIuY2xhc3NCcmVha0luZm9zW3JlbmRlcmVyLmNsYXNzQnJlYWtJbmZvcy5sZW5ndGggLSAxXS5tYXhWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICAoeyBtaW4sIG1heCB9ID0gdmFsaWRhdGVNaW5NYXgoeyBtaW4sIG1heCB9KSk7XG4gICAgICAgIGlmIChoaXN0b2dyYW1TdGF0dXMgPT09IHN0YXR1cy5JTl9QUk9HUkVTUykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5jb2xvclNsaWRlciB8fFxuICAgICAgICAgICAgKGNvbG9yVmlzVmFyICYmIHRoaXMuY29sb3JTbGlkZXIuYnJlYWtzKSB8fFxuICAgICAgICAgICAgKCFjb2xvclZpc1ZhciAmJiB0aGlzLmNvbG9yU2xpZGVyLnN0b3BzKSkge1xuICAgICAgICAgICAgKF9hID0gdGhpcy5jb2xvclNsaWRlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmRlc3Ryb3koKTtcbiAgICAgICAgICAgIHRoaXMuY29sb3JTbGlkZXJCYXJzID0gW107XG4gICAgICAgICAgICBsZXQgY29uZmlnID0ge1xuICAgICAgICAgICAgICAgIGhpc3RvZ3JhbUNvbmZpZzoge1xuICAgICAgICAgICAgICAgICAgICBiaW5zOiBoaXN0b2dyYW0gPT09IG51bGwgfHwgaGlzdG9ncmFtID09PSB2b2lkIDAgPyB2b2lkIDAgOiBoaXN0b2dyYW0uYmlucyxcbiAgICAgICAgICAgICAgICAgICAgYXZlcmFnZTogTWF0aC5yb3VuZChzdGF0aXN0aWNzLmF2ZyAqIDEwKSAvIDEwLFxuICAgICAgICAgICAgICAgICAgICBzdGFuZGFyZERldmlhdGlvbjogc3RhdGlzdGljcy5zdGRkZXYsXG4gICAgICAgICAgICAgICAgICAgIHN0YW5kYXJkRGV2aWF0aW9uQ291bnQ6IDFcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG1pbjogbWluICE9PSBudWxsICYmIG1pbiAhPT0gdm9pZCAwID8gbWluIDogc3RhdGlzdGljcy5taW4sXG4gICAgICAgICAgICAgICAgbWF4OiBtYXggIT09IG51bGwgJiYgbWF4ICE9PSB2b2lkIDAgPyBtYXggOiBzdGF0aXN0aWNzLm1heFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChjb2xvclZpc1Zhcikge1xuICAgICAgICAgICAgICAgIGNvbmZpZyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgY29uZmlnKSwgaGFuZGxlSW5mbyk7XG4gICAgICAgICAgICAgICAgaWYgKGlzRGF0ZUZpZWxkICYmICFpc0FnZVJlbmRlcmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZy5oYXNUaW1lRGF0YSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGFkZERhdGVGb3JtYXRGdW5jdGlvbnMoY29uZmlnLCBtYXBWaWV3LnRpbWVab25lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uZmlnLnN0b3BzID0gY29sb3JWaXNWYXIuc3RvcHM7XG4gICAgICAgICAgICAgICAgY29uZmlnLnByZWNpc2lvbiA9IGdldFN0b3BQcmVjaXNpb24oY29sb3JWaXNWYXIuc3RvcHMpO1xuICAgICAgICAgICAgICAgIGNvbmZpZy5oaXN0b2dyYW1Db25maWcuYmFyQ3JlYXRlZEZ1bmN0aW9uID1cbiAgICAgICAgICAgICAgICAgICAgaGlzdG9ncmFtICYmIGJhckNyZWF0ZWRGdW5jdGlvbi5iaW5kKHRoaXMsIGNvbG9yVmlzVmFyLCBoaXN0b2dyYW0sIHRoaXMuY29sb3JTbGlkZXJCYXJzKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbG9yU2xpZGVyID0gbmV3IG1vZHVsZXMuQ29sb3JTbGlkZXIoY29uZmlnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbmZpZy5oaXN0b2dyYW1Db25maWcubWluID0gcmVuZGVyZXIuY2xhc3NCcmVha0luZm9zWzBdLm1pblZhbHVlO1xuICAgICAgICAgICAgICAgIGNvbmZpZy5oaXN0b2dyYW1Db25maWcubWF4ID1cbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyZXIuY2xhc3NCcmVha0luZm9zW3JlbmRlcmVyLmNsYXNzQnJlYWtJbmZvcy5sZW5ndGggLSAxXS5tYXhWYWx1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLnNsaWRlclpvb21lZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGNvbmZpZy5icmVha3MgPSBnZXRDbGFzc0JyZWFrc0NvbG9ycygpO1xuICAgICAgICAgICAgICAgIGNvbmZpZy5wcmVjaXNpb24gPSBnZXRTdG9wUHJlY2lzaW9uKGNvbmZpZy5icmVha3MpO1xuICAgICAgICAgICAgICAgIGNvbmZpZy5oaXN0b2dyYW1Db25maWcuYmFyQ3JlYXRlZEZ1bmN0aW9uID1cbiAgICAgICAgICAgICAgICAgICAgaGlzdG9ncmFtICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBiYXJDcmVhdGVkRnVuY3Rpb24uYmluZCh0aGlzLCBjb25maWcuYnJlYWtzLCBoaXN0b2dyYW0sIHRoaXMuY29sb3JTbGlkZXJCYXJzKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbG9yU2xpZGVyID0gbmV3IG1vZHVsZXMuQ2xhc3NlZENvbG9yU2xpZGVyKGNvbmZpZyk7XG4gICAgICAgICAgICAgICAgdXBkYXRlSGlzdG9ncmFtQ29sb3JzKHRoaXMuY29sb3JTbGlkZXIsIHRoaXMuY29sb3JTbGlkZXJCYXJzLCBjb25maWcuYnJlYWtzLCBoaXN0b2dyYW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jcmVhdGVDb2xvclNsaWRlckNoYW5nZUV2ZW50cygpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3Qgc2xpZGVyID0gdGhpcy5jb2xvclNsaWRlcjtcbiAgICAgICAgICAgIGlmICgoKF9iID0gc2xpZGVyLnNsaWRlcikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnN0YXRlKSA9PT0gXCJkcmFnZ2luZ1wiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgY29uZmlnID0ge1xuICAgICAgICAgICAgICAgIGhpc3RvZ3JhbUNvbmZpZzoge1xuICAgICAgICAgICAgICAgICAgICBiaW5zOiBoaXN0b2dyYW0gPT09IG51bGwgfHwgaGlzdG9ncmFtID09PSB2b2lkIDAgPyB2b2lkIDAgOiBoaXN0b2dyYW0uYmlucyxcbiAgICAgICAgICAgICAgICAgICAgYXZlcmFnZTogTWF0aC5yb3VuZChzdGF0aXN0aWNzLmF2ZyAqIDEwKSAvIDEwLFxuICAgICAgICAgICAgICAgICAgICBzdGFuZGFyZERldmlhdGlvbjogc3RhdGlzdGljcy5zdGRkZXYsXG4gICAgICAgICAgICAgICAgICAgIHN0YW5kYXJkRGV2aWF0aW9uQ291bnQ6IDFcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG1pbjogbWluICE9PSBudWxsICYmIG1pbiAhPT0gdm9pZCAwID8gbWluIDogc3RhdGlzdGljcy5taW4sXG4gICAgICAgICAgICAgICAgbWF4OiBtYXggIT09IG51bGwgJiYgbWF4ICE9PSB2b2lkIDAgPyBtYXggOiBzdGF0aXN0aWNzLm1heFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChjb2xvclZpc1Zhcikge1xuICAgICAgICAgICAgICAgIGNvbmZpZyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgY29uZmlnKSwgaGFuZGxlSW5mbyk7XG4gICAgICAgICAgICAgICAgY29uZmlnLnN0b3BzID0gY29sb3JWaXNWYXIuc3RvcHM7XG4gICAgICAgICAgICAgICAgY29uZmlnLnByZWNpc2lvbiA9IGdldFN0b3BQcmVjaXNpb24oY29sb3JWaXNWYXIuc3RvcHMpO1xuICAgICAgICAgICAgICAgIGNvbmZpZy5oYXNUaW1lRGF0YSA9IGlzRGF0ZUZpZWxkICYmICFpc0FnZVJlbmRlcmVyO1xuICAgICAgICAgICAgICAgIGlmIChpc0RhdGVGaWVsZCAmJiAhaXNBZ2VSZW5kZXJlcikge1xuICAgICAgICAgICAgICAgICAgICBhZGREYXRlRm9ybWF0RnVuY3Rpb25zKGNvbmZpZywgbWFwVmlldy50aW1lWm9uZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzbGlkZXJab29tZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAqIGNsaWNraW5nIGEgemlnemFnIGFscmVhZHkgdXBkYXRlcyB0aGUgaW50ZXJuYWwgc2xpZGVyIHpvb21PcHRpb25zO1xuICAgICAgICAgICAgICAgICAgICAgKiBzZXR0aW5nIHRoZW0gaGVyZSBhZ2FpbiB3b3VsZCBpbmNvcnJlY3RseSBvdmVycmlkZSBhIHVzZXIncyBkZWNpc2lvblxuICAgICAgICAgICAgICAgICAgICAgKiB0byBtYW51YWxseSB6b29tIG91dCBvbmUgc2lkZSBvZiB0aGUgc2xpZGVyLlxuICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLnppZ3phZ0NsaWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25maWcuem9vbU9wdGlvbnMgPSBnZXRab29tT3B0aW9ucyhjb2xvclZpc1Zhci5zdG9wcywgYXV0aENvbG9yVmlzVmFyID09PSBudWxsIHx8IGF1dGhDb2xvclZpc1ZhciA9PT0gdm9pZCAwID8gdm9pZCAwIDogYXV0aENvbG9yVmlzVmFyLm1pblNsaWRlclZhbHVlLCBhdXRoQ29sb3JWaXNWYXIgPT09IG51bGwgfHwgYXV0aENvbG9yVmlzVmFyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhdXRoQ29sb3JWaXNWYXIubWF4U2xpZGVyVmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25maWcuem9vbU9wdGlvbnMgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25maWcuaGlzdG9ncmFtQ29uZmlnLmJhckNyZWF0ZWRGdW5jdGlvbiA9XG4gICAgICAgICAgICAgICAgICAgIGhpc3RvZ3JhbSAmJiBiYXJDcmVhdGVkRnVuY3Rpb24uYmluZCh0aGlzLCBjb2xvclZpc1ZhciwgaGlzdG9ncmFtLCB0aGlzLmNvbG9yU2xpZGVyQmFycyk7XG4gICAgICAgICAgICAgICAgdXBkYXRlSGlzdG9ncmFtQ29sb3JzKHNsaWRlciwgdGhpcy5jb2xvclNsaWRlckJhcnMsIGNvbG9yVmlzVmFyLCBoaXN0b2dyYW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uZmlnLmJyZWFrcyA9IGdldENsYXNzQnJlYWtzQ29sb3JzKCk7XG4gICAgICAgICAgICAgICAgY29uZmlnLnByZWNpc2lvbiA9IGdldFN0b3BQcmVjaXNpb24oY29uZmlnLmJyZWFrcyk7XG4gICAgICAgICAgICAgICAgY29uZmlnLmhpc3RvZ3JhbUNvbmZpZy5iYXJDcmVhdGVkRnVuY3Rpb24gPVxuICAgICAgICAgICAgICAgICAgICBoaXN0b2dyYW0gJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGJhckNyZWF0ZWRGdW5jdGlvbi5iaW5kKHRoaXMsIGNvbmZpZy5icmVha3MsIGhpc3RvZ3JhbSwgdGhpcy5jb2xvclNsaWRlckJhcnMpO1xuICAgICAgICAgICAgICAgIHVwZGF0ZUhpc3RvZ3JhbUNvbG9ycyhzbGlkZXIsIHRoaXMuY29sb3JTbGlkZXJCYXJzLCBjb25maWcuYnJlYWtzLCBoaXN0b2dyYW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuc2xpZGVyWm9vbWVkICYmIHRoaXMuYWRqdXN0ZWRab29tT3B0aW9ucyAmJiAhdGhpcy56aWd6YWdDbGljaykge1xuICAgICAgICAgICAgICAgIGNvbmZpZy56b29tT3B0aW9ucyA9IHRoaXMuYWRqdXN0ZWRab29tT3B0aW9ucztcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBoYW5kbGVzIGVkZ2UgY2FzZXMgd2hlcmUgdGhlIHNsaWRlciBpcyB6b29tZWQsIGhhbmRsZXMgaGF2ZSBiZWVuIG1hbnVhbGx5IG1vZGlmaWVkLFxuICAgICAgICAgICAgICAgICAqIGFuZCBhIHVzZXIgZXhlY3V0ZXMgYSBsYWJlbCBjaGFuZ2UuIFRoaXMgcHJldmVudHMgem9vbSBvcHRpb25zIGZyb20gY2hhbmdpbmcgYW5kIHByZXNlcnZlc1xuICAgICAgICAgICAgICAgICAqIHRoZSBoaXN0b2dyYW0gZGlzcGxheS5cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBpZiAodGhpcy56b29tQWRqdXN0bWVudCA9PT0gXCJtaW5cIikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbG9yU2xpZGVyLnNsaWRlci5taW4gPSBjb25maWcuem9vbU9wdGlvbnMubWluO1xuICAgICAgICAgICAgICAgICAgICBjb25maWcuem9vbU9wdGlvbnMubWluID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29sb3JTbGlkZXIuc2xpZGVyLm1heCA9IGNvbmZpZy56b29tT3B0aW9ucy5tYXg7XG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZy56b29tT3B0aW9ucy5tYXggPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuYWRqdXN0ZWRab29tT3B0aW9ucyA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLnpvb21BZGp1c3RtZW50ID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuY29sb3JTbGlkZXIuc2V0KGNvbmZpZyk7XG4gICAgICAgICAgICB0aGlzLnppZ3phZ0NsaWNrID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlzRGVmaW5lZCh0aGlzLmNvbG9yU2xpZGVyKTtcbiAgICB9XG4gICAgaGFuZGxlSW52ZXJ0U2xpZGVyKCkge1xuICAgICAgICBjb25zdCB7IGxheWVyLCBtb2R1bGVzIH0gPSBzbWFydE1hcHBpbmdTdGF0ZTtcbiAgICAgICAgY29uc3QgcmVuZGVyZXIgPSBnZXRSZW5kZXJlcihsYXllcik7XG4gICAgICAgIGNvbnN0IGNvbG9yVmlzVmFyID0gZ2V0VmlzVmFyKHJlbmRlcmVyLCBcImNvbG9yXCIpO1xuICAgICAgICB1cGRhdGVIaXN0b2dyYW1Db2xvcnModGhpcy5jb2xvclNsaWRlciwgdGhpcy5jb2xvclNsaWRlckJhcnMsIGNvbG9yVmlzVmFyIHx8IGdldENsYXNzQnJlYWtzQ29sb3JzKCksIHRoaXMuaGlzdG9ncmFtKTtcbiAgICAgICAgaWYgKGNvbG9yVmlzVmFyKSB7XG4gICAgICAgICAgICBsZXQgY29sb3JzID0gY29sb3JWaXNWYXIuc3RvcHMubWFwKChzdG9wKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0b3AuY29sb3I7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbG9ycyA9IGNvbG9ycy5yZXZlcnNlKCk7XG4gICAgICAgICAgICBjb2xvclZpc1Zhci5zdG9wcy5mb3JFYWNoKChzdG9wLCBpZHgpID0+IHtcbiAgICAgICAgICAgICAgICBzdG9wLmNvbG9yID0gY29sb3JzW2lkeF07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBjb2xvcnMgPSByZW5kZXJlci5jbGFzc0JyZWFrSW5mb3MubWFwKChjbGFzc0JyZWFrSW5mbykgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiAoZ2V0U3ltYm9sQ29sb3IoY2xhc3NCcmVha0luZm8uc3ltYm9sKSB8fFxuICAgICAgICAgICAgICAgICAgICBuZXcgbW9kdWxlcy5lc3JpQ29sb3IoeyByOiA2NCwgZzogNjQsIGI6IDY0LCBhOiAxIH0pKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29sb3JzID0gY29sb3JzLnJldmVyc2UoKTtcbiAgICAgICAgICAgIHJlbmRlcmVyLmNsYXNzQnJlYWtJbmZvcy5tYXAoKGNsYXNzQnJlYWtJbmZvLCBpZHgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZ2V0U3ltYm9sQ29sb3IoY2xhc3NCcmVha0luZm8uc3ltYm9sKSkge1xuICAgICAgICAgICAgICAgICAgICBhcHBseVN5bWJvbENvbG9yKGNsYXNzQnJlYWtJbmZvLnN5bWJvbCwgY29sb3JzW2lkeF0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHVwZGF0ZVJlbmRlcmVyKCk7XG4gICAgICAgIGZvcmNlVXBkYXRlKHRoaXMuaG9zdEVsZW1lbnQpO1xuICAgICAgICB0aGlzLmFyY2dpc1NtYXJ0TWFwcGluZ0NvbG9yU2xpZGVyQ2hhbmdlLmVtaXQoKTtcbiAgICB9XG4gICAgaGFuZGxlWm9vbVNsaWRlcih6b29tZWQpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICB0aGlzLmNhcCA9IHRoaXMuY29sb3JTbGlkZXIuc2xpZGVyLm1heDtcbiAgICAgICAgaWYgKHRoaXMuaGlzdG9ncmFtU3RhdHVzID09PSBzdGF0dXMuSU5fUFJPR1JFU1MpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IHN0YXRpc3RpY3MgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHsgbGF5ZXIgfSA9IHNtYXJ0TWFwcGluZ1N0YXRlO1xuICAgICAgICBjb25zdCByZW5kZXJlciA9IGdldFJlbmRlcmVyKGxheWVyKTtcbiAgICAgICAgdGhpcy5zbGlkZXJab29tZWQgPSBpc0RlZmluZWQoem9vbWVkKSA/IHpvb21lZCA6ICF0aGlzLnNsaWRlclpvb21lZDtcbiAgICAgICAgY29uc3QgY29sb3JWaXNWYXIgPSBnZXRWaXNWYXIocmVuZGVyZXIsIFwiY29sb3JcIik7XG4gICAgICAgIGlmICghY29sb3JWaXNWYXIpIHtcbiAgICAgICAgICAgIHRoaXMuc2xpZGVyWm9vbWVkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXV0aENvbG9yVmlzVmFyID0gZ2V0QXV0aFZpc1ZhcihyZW5kZXJlciwgXCJjb2xvclwiKTtcbiAgICAgICAgY29uc3Qgem9vbU9wdGlvbnMgPSB0aGlzLnNsaWRlclpvb21lZFxuICAgICAgICAgICAgPyBnZXRab29tT3B0aW9ucyhjb2xvclZpc1Zhci5zdG9wcywgKF9hID0gYXV0aENvbG9yVmlzVmFyID09PSBudWxsIHx8IGF1dGhDb2xvclZpc1ZhciA9PT0gdm9pZCAwID8gdm9pZCAwIDogYXV0aENvbG9yVmlzVmFyLm1pblNsaWRlclZhbHVlKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBzdGF0aXN0aWNzLm1pbiwgKF9iID0gYXV0aENvbG9yVmlzVmFyID09PSBudWxsIHx8IGF1dGhDb2xvclZpc1ZhciA9PT0gdm9pZCAwID8gdm9pZCAwIDogYXV0aENvbG9yVmlzVmFyLm1heFNsaWRlclZhbHVlKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBzdGF0aXN0aWNzLm1heClcbiAgICAgICAgICAgIDogbnVsbDtcbiAgICAgICAgdGhpcy5nZXRIaXN0b2dyYW0oe1xuICAgICAgICAgICAgZmllbGQ6IGNvbG9yVmlzVmFyLmZpZWxkLFxuICAgICAgICAgICAgZXhwcmVzc2lvbjogY29sb3JWaXNWYXIudmFsdWVFeHByZXNzaW9uLFxuICAgICAgICAgICAgZXhwcmVzc2lvblRpdGxlOiBjb2xvclZpc1Zhci52YWx1ZUV4cHJlc3Npb25UaXRsZSxcbiAgICAgICAgICAgIHNpbXBsZUZpZWxkVHlwZTogc2ltcGxlRmllbGRUeXBlcy5OVU1CRVJcbiAgICAgICAgfSwgY29sb3JWaXNWYXIubm9ybWFsaXphdGlvbkZpZWxkLCBzdGF0aXN0aWNzLCAoem9vbU9wdGlvbnMgJiYgem9vbU9wdGlvbnMubWluKSB8fCAoKF9jID0gYXV0aENvbG9yVmlzVmFyID09PSBudWxsIHx8IGF1dGhDb2xvclZpc1ZhciA9PT0gdm9pZCAwID8gdm9pZCAwIDogYXV0aENvbG9yVmlzVmFyLm1pblNsaWRlclZhbHVlKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBzdGF0aXN0aWNzLm1pbiksICh6b29tT3B0aW9ucyAmJiB6b29tT3B0aW9ucy5tYXgpIHx8ICgoX2QgPSBhdXRoQ29sb3JWaXNWYXIgPT09IG51bGwgfHwgYXV0aENvbG9yVmlzVmFyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhdXRoQ29sb3JWaXNWYXIubWF4U2xpZGVyVmFsdWUpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IHN0YXRpc3RpY3MubWF4KSk7XG4gICAgfVxuICAgIGhhbmRsZVJlc2V0U2xpZGVyKCkge1xuICAgICAgICBjb25zdCB7IGxheWVyIH0gPSBzbWFydE1hcHBpbmdTdGF0ZTtcbiAgICAgICAgY29uc3QgcmVuZGVyZXIgPSBnZXRSZW5kZXJlcihsYXllcik7XG4gICAgICAgIGNvbnN0IHJlbmRlcmVyVHlwZSA9IGdldFJlbmRlcmVyVHlwZSgpO1xuICAgICAgICB0aGlzLnNsaWRlclpvb21lZCA9IGZhbHNlO1xuICAgICAgICBsZXQgY29sb3JWaXNWYXIgPSBnZXRWaXNWYXIocmVuZGVyZXIsIFwiY29sb3JcIik7XG4gICAgICAgIGNvbnN0IGF1dGhDb2xvclZpc1ZhciA9IGdldEF1dGhWaXNWYXIocmVuZGVyZXIsIFwiY29sb3JcIik7XG4gICAgICAgIGNvbnN0IHRoZW1lID0gYXV0aENvbG9yVmlzVmFyID09PSBudWxsIHx8IGF1dGhDb2xvclZpc1ZhciA9PT0gdm9pZCAwID8gdm9pZCAwIDogYXV0aENvbG9yVmlzVmFyLnRoZW1lO1xuICAgICAgICBjb25zdCBmaWVsZEluZm8gPSB0aGlzLmdldEZpZWxkSW5mbygpO1xuICAgICAgICBjb25zdCBub3JtYWxpemF0aW9uRmllbGQgPSBjb2xvclZpc1ZhclxuICAgICAgICAgICAgPyBjb2xvclZpc1Zhci5ub3JtYWxpemF0aW9uRmllbGRcbiAgICAgICAgICAgIDogcmVuZGVyZXIubm9ybWFsaXphdGlvbkZpZWxkO1xuICAgICAgICBsZXQgdXBkYXRlQ2FsbDtcbiAgICAgICAgaWYgKHJlbmRlcmVyVHlwZSA9PT0gXCJjb2xvclwiKSB7XG4gICAgICAgICAgICB1cGRhdGVDYWxsID0gY3JlYXRlQ29sb3JSZW5kZXJlckZyb21FeGlzdGluZztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChyZW5kZXJlclR5cGUgPT09IFwiY29sb3ItYWdlXCIpIHtcbiAgICAgICAgICAgIGZpZWxkSW5mby5maWVsZCA9IGF1dGhDb2xvclZpc1Zhci5maWVsZDtcbiAgICAgICAgICAgIHVwZGF0ZUNhbGwgPSBjcmVhdGVDb2xvckFnZVJlbmRlcmVyRnJvbUV4aXN0aW5nO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHJlbmRlcmVyVHlwZSA9PT0gXCJjb2xvci1hZ2Utc2l6ZVwiKSB7XG4gICAgICAgICAgICBmaWVsZEluZm8uZmllbGQgPSBhdXRoQ29sb3JWaXNWYXIuZmllbGQ7XG4gICAgICAgICAgICB1cGRhdGVDYWxsID0gY3JlYXRlQ29sb3JBZ2VTaXplUmVuZGVyZXJGcm9tRXhpc3Rpbmc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocmVuZGVyZXJUeXBlID09PSBcImNvbG9yLXNpemUtYWdlXCIpIHtcbiAgICAgICAgICAgIHVwZGF0ZUNhbGwgPSBjcmVhdGVDb2xvclNpemVBZ2VSZW5kZXJlckZyb21FeGlzdGluZztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChyZW5kZXJlclR5cGUgPT09IFwiY29sb3Itc2l6ZVwiKSB7XG4gICAgICAgICAgICB1cGRhdGVDYWxsID0gY3JlYXRlQ29sb3JTaXplUmVuZGVyZXJGcm9tRXhpc3Rpbmc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocmVuZGVyZXJUeXBlID09PSBcImNvbXBhcmVcIikge1xuICAgICAgICAgICAgdXBkYXRlQ2FsbCA9IGNyZWF0ZUNvbXBhcmVSZW5kZXJlckZyb21FeGlzdGluZztcbiAgICAgICAgfVxuICAgICAgICByZXF1ZXN0V3JhcHBlcih1cGRhdGVDYWxsKHtcbiAgICAgICAgICAgIGZpZWxkSW5mb3M6IGdldFJlbmRlcmVyRmllbGRJbmZvcyhsYXllciksXG4gICAgICAgICAgICBub3JtYWxpemF0aW9uRmllbGQ6IG5vcm1hbGl6YXRpb25GaWVsZCxcbiAgICAgICAgICAgIG5vUmV1c2U6IHRydWUsXG4gICAgICAgICAgICB0aGVtZSxcbiAgICAgICAgICAgIGRpc2NhcmRNaW5NYXg6IHRydWVcbiAgICAgICAgfSwgXCJjb2xvclwiKSwgdGhpcy5mbG93SXRlbU5vZGUpLnRoZW4oKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgaWYgKCgoX2EgPSByZXN1bHQuc3RhdGlzdGljcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNvdW50KSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IFtkZWZhdWx0TWluLCBkZWZhdWx0TWF4XSA9IHRoaXMuZ2V0RGVmYXVsdERhdGFSYW5nZShmaWVsZEluZm8pO1xuICAgICAgICAgICAgICAgIGNvbnN0IG1pbiA9IChhdXRoQ29sb3JWaXNWYXIgPT09IG51bGwgfHwgYXV0aENvbG9yVmlzVmFyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhdXRoQ29sb3JWaXNWYXIubWluU2xpZGVyVmFsdWUpIHx8IGRlZmF1bHRNaW47XG4gICAgICAgICAgICAgICAgY29uc3QgbWF4ID0gKGF1dGhDb2xvclZpc1ZhciA9PT0gbnVsbCB8fCBhdXRoQ29sb3JWaXNWYXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGF1dGhDb2xvclZpc1Zhci5tYXhTbGlkZXJWYWx1ZSkgfHwgZGVmYXVsdE1heDtcbiAgICAgICAgICAgICAgICByZXN1bHQuc3RhdGlzdGljcy5taW4gPSBtaW47XG4gICAgICAgICAgICAgICAgcmVzdWx0LnN0YXRpc3RpY3MubWF4ID0gbWF4O1xuICAgICAgICAgICAgICAgIHJlc3VsdC5zdGF0aXN0aWNzLmF2ZyA9IChtYXggKyBtaW4pIC8gMjtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRpc3RpY3MgPSByZXN1bHQuc3RhdGlzdGljcztcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRpc3RpY3NTdGF0dXMgPSBzdGF0dXMuU1VDQ0VTUztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHJlc3VsdC5zdGF0aXN0aWNzICYmXG4gICAgICAgICAgICAgICAgaXNEZWZpbmVkKHJlc3VsdC5zdGF0aXN0aWNzLm1pbikgJiZcbiAgICAgICAgICAgICAgICBpc0RlZmluZWQocmVzdWx0LnN0YXRpc3RpY3MubWF4KSAmJlxuICAgICAgICAgICAgICAgIHJlc3VsdC5zdGF0aXN0aWNzLm1pbiA8PSByZXN1bHQuc3RhdGlzdGljcy5tYXgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRpc3RpY3MgPSByZXN1bHQuc3RhdGlzdGljcztcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRpc3RpY3NTdGF0dXMgPSBzdGF0dXMuU1VDQ0VTUztcbiAgICAgICAgICAgICAgICB0aGlzLmdldEhpc3RvZ3JhbShmaWVsZEluZm8sIG5vcm1hbGl6YXRpb25GaWVsZCwgcmVzdWx0LnN0YXRpc3RpY3MsIHJlc3VsdC5zdGF0aXN0aWNzLm1pbiwgcmVzdWx0LnN0YXRpc3RpY3MubWF4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGlzdGljc1N0YXR1cyA9IHN0YXR1cy5GQUlMRUQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhdXRoQ29sb3JWaXNWYXIubWluU2xpZGVyVmFsdWUgPSB0aGlzLnN0YXRpc3RpY3MubWluO1xuICAgICAgICAgICAgYXV0aENvbG9yVmlzVmFyLm1heFNsaWRlclZhbHVlID0gdGhpcy5zdGF0aXN0aWNzLm1heDtcbiAgICAgICAgICAgIHVwZGF0ZVJlbmRlcmVyKCk7XG4gICAgICAgIH0sIChlcnJvcikgPT4gdGhpcy5hcmNnaXNTbWFydE1hcHBpbmdDb2xvclNsaWRlckVycm9yLmVtaXQoZXJyb3IpKTtcbiAgICB9XG4gICAgYWZ0ZXJDb2xvclNsaWRlckNyZWF0ZShub2RlKSB7XG4gICAgICAgIGlmICghdGhpcy5jb2xvclNsaWRlci5jb250YWluZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IGRpdk5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICAgICAgbm9kZS5hcHBlbmQoZGl2Tm9kZSk7XG4gICAgICAgICAgICB0aGlzLmNvbG9yU2xpZGVyLmNvbnRhaW5lciA9IGRpdk5vZGU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0U3RhdGlzdGljcygpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEhhbmRsZXMgdGhlIGZvbGxvd2luZzpcbiAgICAgICAgICogIDEuKSBSZXRyaWV2aW5nIHN0YXRpc3RpY3Mgb24gc2xpZGVyIGxvYWRcbiAgICAgICAgICogIDIuKSBSZXRyaWV2aW5nIHVwZGF0ZWQgc3RhdGlzdGljcyBhZnRlciBjaGFuZ2luZyBhZ2UsIG5vcm1hbGl6YXRpb24gZmllbGQsIHRoZW1lLCBvciBjbGFzc2lmeSBtZXRob2QvbnVtYmVyIG9mIGNsYXNzZXNcbiAgICAgICAgICovXG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgeyBsYXllcjogc21MYXllciwgbWFwVmlldywgbW9kdWxlcyB9ID0gc21hcnRNYXBwaW5nU3RhdGU7XG4gICAgICAgIGNvbnN0IGxheWVyID0gc21MYXllcjtcbiAgICAgICAgY29uc3QgcmVuZGVyZXIgPSBnZXRSZW5kZXJlcihsYXllcik7XG4gICAgICAgIGxldCBtaW47XG4gICAgICAgIGxldCBtYXg7XG4gICAgICAgIGNvbnN0IGZpZWxkSW5mbyA9IHRoaXMuZ2V0RmllbGRJbmZvKCk7XG4gICAgICAgIGNvbnN0IGNvbG9yVmlzVmFyID0gZ2V0VmlzVmFyKHJlbmRlcmVyLCBcImNvbG9yXCIpO1xuICAgICAgICBjb25zdCBub3JtYWxpemF0aW9uRmllbGQgPSBjb2xvclZpc1ZhclxuICAgICAgICAgICAgPyBjb2xvclZpc1Zhci5ub3JtYWxpemF0aW9uRmllbGRcbiAgICAgICAgICAgIDogcmVuZGVyZXIubm9ybWFsaXphdGlvbkZpZWxkO1xuICAgICAgICBjb25zdCBhdXRoQ29sb3JWaXNWYXIgPSBnZXRBdXRoVmlzVmFyKHJlbmRlcmVyLCBcImNvbG9yXCIpIHx8IHt9O1xuICAgICAgICBtaW4gPSBhdXRoQ29sb3JWaXNWYXIubWluU2xpZGVyVmFsdWU7XG4gICAgICAgIG1heCA9IGF1dGhDb2xvclZpc1Zhci5tYXhTbGlkZXJWYWx1ZTtcbiAgICAgICAgLy8gaGFuZGxlcyBlcXVhbCBpbnRlcnZhbCBiZWhhdmlvclxuICAgICAgICBjb25zdCBhdXRoSW5mbyA9IHJlbmRlcmVyLmF1dGhvcmluZ0luZm87XG4gICAgICAgIGlmICgoYXV0aEluZm8gPT09IG51bGwgfHwgYXV0aEluZm8gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGF1dGhJbmZvLmNsYXNzaWZpY2F0aW9uTWV0aG9kKSA9PT0gXCJlcXVhbC1pbnRlcnZhbFwiKSB7XG4gICAgICAgICAgICBjb25zdCBjbGFzc0JyZWFrcyA9IHJlbmRlcmVyLmNsYXNzQnJlYWtJbmZvcztcbiAgICAgICAgICAgIG1pbiA9IGNsYXNzQnJlYWtzWzBdLm1pblZhbHVlO1xuICAgICAgICAgICAgbWF4ID0gY2xhc3NCcmVha3NbY2xhc3NCcmVha3MubGVuZ3RoIC0gMV0ubWF4VmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdGF0aXN0aWNzU3RhdHVzID0gc3RhdHVzLklOX1BST0dSRVNTO1xuICAgICAgICBpZiAoIXRoaXMuc3RhdGlzdGljcykge1xuICAgICAgICAgICAgbW9kdWxlc1xuICAgICAgICAgICAgICAgIC5zdW1tYXJ5U3RhdGlzdGljcyh7XG4gICAgICAgICAgICAgICAgbGF5ZXIsXG4gICAgICAgICAgICAgICAgdmlldzogbWFwVmlldyxcbiAgICAgICAgICAgICAgICBmaWVsZDogZmllbGRJbmZvLmZpZWxkLFxuICAgICAgICAgICAgICAgIHZhbHVlRXhwcmVzc2lvbjogZmllbGRJbmZvLmV4cHJlc3Npb24sXG4gICAgICAgICAgICAgICAgbm9ybWFsaXphdGlvbkZpZWxkLFxuICAgICAgICAgICAgICAgIGZvckJpbm5pbmc6IFwiZmVhdHVyZVJlZHVjdGlvblwiIGluIGxheWVyICYmICgoX2EgPSBsYXllci5mZWF0dXJlUmVkdWN0aW9uKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudHlwZSkgPT09IFwiYmlubmluZ1wiXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChzdGF0aXN0aWNzKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXRpc3RpY3MuY291bnQgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZmllbGQgaGFzIG5vIHZhbHVlc1xuICAgICAgICAgICAgICAgICAgICAvLyBtYWtlIHVwIHNvbWUgYmFzaWMgc3RhdGlzdGljcyBzbyB3ZSBjYW4gc2hvdyBhIHNsaWRlclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBbZGVmYXVsdE1pbiwgZGVmYXVsdE1heF0gPSB0aGlzLmdldERlZmF1bHREYXRhUmFuZ2UoZmllbGRJbmZvKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbWluID0gYXV0aENvbG9yVmlzVmFyLm1pblNsaWRlclZhbHVlIHx8IGRlZmF1bHRNaW47XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1heCA9IGF1dGhDb2xvclZpc1Zhci5tYXhTbGlkZXJWYWx1ZSB8fCBkZWZhdWx0TWF4O1xuICAgICAgICAgICAgICAgICAgICBzdGF0aXN0aWNzLm1pbiA9IG1pbjtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGlzdGljcy5tYXggPSBtYXg7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRpc3RpY3MuYXZnID0gKG1heCArIG1pbikgLyAyO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzRGVmaW5lZChhdXRoQ29sb3JWaXNWYXIubWluU2xpZGVyVmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhdXRoQ29sb3JWaXNWYXIubWluU2xpZGVyVmFsdWUgPSBtaW47XG4gICAgICAgICAgICAgICAgICAgICAgICBhdXRoQ29sb3JWaXNWYXIubWF4U2xpZGVyVmFsdWUgPSBtYXg7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoIWlzRGVmaW5lZChzdGF0aXN0aWNzLmF2ZykgfHxcbiAgICAgICAgICAgICAgICAgICAgIWlzRGVmaW5lZChzdGF0aXN0aWNzLm1pbikgfHxcbiAgICAgICAgICAgICAgICAgICAgIWlzRGVmaW5lZChzdGF0aXN0aWNzLm1heCkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gc3RhdGlzdGljcyB1bnVzYWJsZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRpc3RpY3NTdGF0dXMgPSBzdGF0dXMuRkFJTEVEO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN0YXRpc3RpY3MgPSB2YWxpZGF0ZU1pbk1heChzdGF0aXN0aWNzKTtcbiAgICAgICAgICAgICAgICBtaW4gPSBtaW4gIT09IG51bGwgJiYgbWluICE9PSB2b2lkIDAgPyBtaW4gOiBzdGF0aXN0aWNzLm1pbjtcbiAgICAgICAgICAgICAgICBtYXggPSBtYXggIT09IG51bGwgJiYgbWF4ICE9PSB2b2lkIDAgPyBtYXggOiBzdGF0aXN0aWNzLm1heDtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRpc3RpY3MgPSBzdGF0aXN0aWNzO1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGlzdGljc1N0YXR1cyA9IHN0YXR1cy5TVUNDRVNTO1xuICAgICAgICAgICAgICAgIHRoaXMuZ2V0SGlzdG9ncmFtKGZpZWxkSW5mbywgbm9ybWFsaXphdGlvbkZpZWxkLCBzdGF0aXN0aWNzLCBtaW4sIG1heCk7XG4gICAgICAgICAgICB9LCAoZXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhlcnJvcik7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0aXN0aWNzU3RhdHVzID0gc3RhdHVzLkZBSUxFRDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldEhpc3RvZ3JhbShmaWVsZEluZm8sIG5vcm1hbGl6YXRpb25GaWVsZCwgc3RhdGlzdGljcywgbWluLCBtYXgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCB7IGxheWVyOiBzbUxheWVyLCBtYXBWaWV3LCBtb2R1bGVzIH0gPSBzbWFydE1hcHBpbmdTdGF0ZTtcbiAgICAgICAgY29uc3QgbGF5ZXIgPSBzbUxheWVyO1xuICAgICAgICBzdGF0aXN0aWNzID0gc3RhdGlzdGljcyB8fCB0aGlzLnN0YXRpc3RpY3M7XG4gICAgICAgIGlmICghc3RhdGlzdGljcyB8fCBzdGF0aXN0aWNzLmNvdW50ID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5oaXN0b2dyYW1TdGF0dXMgPSBzdGF0dXMuSU5fUFJPR1JFU1M7XG4gICAgICAgIG1vZHVsZXNcbiAgICAgICAgICAgIC5oaXN0b2dyYW0oe1xuICAgICAgICAgICAgbGF5ZXI6IGxheWVyLFxuICAgICAgICAgICAgdmlldzogbWFwVmlldyxcbiAgICAgICAgICAgIGZpZWxkOiBmaWVsZEluZm8uZmllbGQsXG4gICAgICAgICAgICB2YWx1ZUV4cHJlc3Npb246IGZpZWxkSW5mby5leHByZXNzaW9uLFxuICAgICAgICAgICAgbnVtQmluczogNTAsXG4gICAgICAgICAgICBtaW5WYWx1ZTogaXNEZWZpbmVkKG1pbikgPyBtaW4gOiBzdGF0aXN0aWNzLm1pbixcbiAgICAgICAgICAgIG1heFZhbHVlOiBpc0RlZmluZWQobWF4KSA/IG1heCA6IHN0YXRpc3RpY3MubWF4LFxuICAgICAgICAgICAgbm9ybWFsaXphdGlvbkZpZWxkLFxuICAgICAgICAgICAgZm9yQmlubmluZzogXCJmZWF0dXJlUmVkdWN0aW9uXCIgaW4gbGF5ZXIgJiYgKChfYSA9IGxheWVyLmZlYXR1cmVSZWR1Y3Rpb24pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS50eXBlKSA9PT0gXCJiaW5uaW5nXCJcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC50aGVuKChoaXN0b2dyYW0pID0+IHtcbiAgICAgICAgICAgIHRoaXMuaGlzdG9ncmFtID0gaGlzdG9ncmFtO1xuICAgICAgICAgICAgdGhpcy5oaXN0b2dyYW1TdGF0dXMgPSBzdGF0dXMuU1VDQ0VTUztcbiAgICAgICAgfSwgKGVycm9yKSA9PiB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhlcnJvcik7XG4gICAgICAgICAgICB0aGlzLmhpc3RvZ3JhbVN0YXR1cyA9IHN0YXR1cy5GQUlMRUQ7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBvbk1pbk1heENoYW5nZShtaW4sIG1heCwgY2hhbmdpbmcpIHtcbiAgICAgICAgY29uc3QgeyBzdGF0aXN0aWNzIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCB7IGxheWVyIH0gPSBzbWFydE1hcHBpbmdTdGF0ZTtcbiAgICAgICAgY29uc3QgcmVuZGVyZXIgPSBnZXRSZW5kZXJlcihsYXllcik7XG4gICAgICAgIGNvbnN0IGNvbG9yVmlzVmFyID0gZ2V0VmlzVmFyKHJlbmRlcmVyLCBcImNvbG9yXCIpO1xuICAgICAgICBjb25zdCBhdXRoQ29sb3JWaXNWYXIgPSBnZXRBdXRoVmlzVmFyKHJlbmRlcmVyLCBcImNvbG9yXCIpIHx8IHt9O1xuICAgICAgICBpZiAoIWNvbG9yVmlzVmFyKSB7XG4gICAgICAgICAgICBsZXQgbWluQ2xhc3NCcmVhayA9IHJlbmRlcmVyLmNsYXNzQnJlYWtJbmZvc1swXTtcbiAgICAgICAgICAgIGxldCBtYXhDbGFzc0JyZWFrID0gcmVuZGVyZXIuY2xhc3NCcmVha0luZm9zW3JlbmRlcmVyLmNsYXNzQnJlYWtJbmZvcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIG1pbkNsYXNzQnJlYWsubWluVmFsdWUgPSBtaW47XG4gICAgICAgICAgICBtaW5DbGFzc0JyZWFrLmxhYmVsID1cbiAgICAgICAgICAgICAgICBtaW5DbGFzc0JyZWFrLm1pblZhbHVlLnRvTG9jYWxlU3RyaW5nKCkgKyBcIiAtIFwiICsgbWluQ2xhc3NCcmVhay5tYXhWYWx1ZS50b0xvY2FsZVN0cmluZygpO1xuICAgICAgICAgICAgbWF4Q2xhc3NCcmVhay5tYXhWYWx1ZSA9IG1heDtcbiAgICAgICAgICAgIG1heENsYXNzQnJlYWsubGFiZWwgPVxuICAgICAgICAgICAgICAgIFwiPiBcIiArXG4gICAgICAgICAgICAgICAgICAgIG1heENsYXNzQnJlYWsubWluVmFsdWUudG9Mb2NhbGVTdHJpbmcoKSArXG4gICAgICAgICAgICAgICAgICAgIFwiIC0gXCIgK1xuICAgICAgICAgICAgICAgICAgICBtYXhDbGFzc0JyZWFrLm1heFZhbHVlLnRvTG9jYWxlU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdXBkYXRlIG9ubHkgdGhlIGxhYmVsIHRoYXQgdGhlIHVzZXIgaXMgY2hhbmdpbmdcbiAgICAgICAgY2hhbmdpbmcgPT09IFwibWluXCJcbiAgICAgICAgICAgID8gKGF1dGhDb2xvclZpc1Zhci5taW5TbGlkZXJWYWx1ZSA9IG1pbilcbiAgICAgICAgICAgIDogKGF1dGhDb2xvclZpc1Zhci5tYXhTbGlkZXJWYWx1ZSA9IG1heCk7XG4gICAgICAgIC8vIGRldGVybWluZSBpZiBsYWJlbCB1cGRhdGVzIG1lcml0IHpvb21pbmcgb3Igbm90XG4gICAgICAgIGNvbnN0IHpvb21PcHRpb25zID0gZ2V0Wm9vbU9wdGlvbnMoY29sb3JWaXNWYXIgPT09IG51bGwgfHwgY29sb3JWaXNWYXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbG9yVmlzVmFyLnN0b3BzLCBhdXRoQ29sb3JWaXNWYXIubWluU2xpZGVyVmFsdWUsIGF1dGhDb2xvclZpc1Zhci5tYXhTbGlkZXJWYWx1ZSk7XG4gICAgICAgIC8vIGhhbmRsZXMgem9vbSBidXR0b24gZGlzcGxheSBmb3Igbm9uLWNsYXNzZWQgY29sb3Igc2xpZGVyc1xuICAgICAgICBpZiAodGhpcy56b29tQnV0dG9uTm9kZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuc2xpZGVyWm9vbWVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy56b29tQnV0dG9uTm9kZS5kaXNhYmxlZCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIXpvb21PcHRpb25zIHx8XG4gICAgICAgICAgICAgICAgem9vbU9wdGlvbnMubWluTWF4U2FtZSB8fFxuICAgICAgICAgICAgICAgICghaXNEZWZpbmVkKHpvb21PcHRpb25zLm1pbikgJiYgIWlzRGVmaW5lZCh6b29tT3B0aW9ucy5tYXgpKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuem9vbUJ1dHRvbk5vZGUuZGlzYWJsZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy56b29tQnV0dG9uTm9kZS5kaXNhYmxlZCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIHpvb20gYWRqdXN0bWVudFxuICAgICAgICBpZiAodGhpcy5zbGlkZXJab29tZWQpIHtcbiAgICAgICAgICAgIHRoaXMuYWRqdXN0ZWRab29tT3B0aW9ucyA9IHRoaXMuY29sb3JTbGlkZXIuem9vbU9wdGlvbnM7XG4gICAgICAgICAgICBpZiAoY2hhbmdpbmcgPT09IFwibWluXCIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkanVzdGVkWm9vbU9wdGlvbnMubWluID0gbWluO1xuICAgICAgICAgICAgICAgIHRoaXMuem9vbUFkanVzdG1lbnQgPSBcIm1pblwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGp1c3RlZFpvb21PcHRpb25zLm1heCA9IG1heDtcbiAgICAgICAgICAgICAgICB0aGlzLnpvb21BZGp1c3RtZW50ID0gXCJtYXhcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmaWVsZEluZm8gPSB0aGlzLmdldEZpZWxkSW5mbygpO1xuICAgICAgICBjb25zdCBub3JtYWxpemF0aW9uRmllbGQgPSBjb2xvclZpc1ZhclxuICAgICAgICAgICAgPyBjb2xvclZpc1Zhci5ub3JtYWxpemF0aW9uRmllbGRcbiAgICAgICAgICAgIDogcmVuZGVyZXIubm9ybWFsaXphdGlvbkZpZWxkO1xuICAgICAgICB0aGlzLmdldEhpc3RvZ3JhbShmaWVsZEluZm8sIG5vcm1hbGl6YXRpb25GaWVsZCwgc3RhdGlzdGljcywgbWluLCBtYXgpO1xuICAgICAgICB1cGRhdGVIaXN0b2dyYW1Db2xvcnModGhpcy5jb2xvclNsaWRlciwgdGhpcy5jb2xvclNsaWRlckJhcnMsIGNvbG9yVmlzVmFyIHx8IGdldENsYXNzQnJlYWtzQ29sb3JzKCksIHRoaXMuaGlzdG9ncmFtKTtcbiAgICAgICAgaWYgKG1pbiA9PT0gYXV0aENvbG9yVmlzVmFyLm1pblNsaWRlclZhbHVlICYmIG1heCA9PT0gYXV0aENvbG9yVmlzVmFyLm1heFNsaWRlclZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLnNsaWRlclpvb21lZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJlbmRlcmVyLmF1dGhvcmluZ0luZm8uY2xhc3NpZmljYXRpb25NZXRob2QgPSBcIm1hbnVhbFwiO1xuICAgICAgICB0aGlzLmFyY2dpc1NtYXJ0TWFwcGluZ0NvbG9yU2xpZGVyQ2hhbmdlLmVtaXQoKTtcbiAgICB9XG4gICAgY3JlYXRlQ29sb3JTbGlkZXJDaGFuZ2VFdmVudHMoKSB7XG4gICAgICAgIGNvbnN0IHsgbGF5ZXIgfSA9IHNtYXJ0TWFwcGluZ1N0YXRlO1xuICAgICAgICBjb25zdCByZW5kZXJlciA9IGdldFJlbmRlcmVyKGxheWVyKTtcbiAgICAgICAgY29uc3QgY29sb3JWaXNWYXIgPSBnZXRWaXNWYXIocmVuZGVyZXIsIFwiY29sb3JcIik7XG4gICAgICAgIGlmICghdGhpcy5jb2xvclNsaWRlcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIGhhbmRsZXMgemlnemFnIGNsaWNrXG4gICAgICAgIHRoaXMuY29sb3JTbGlkZXIud2F0Y2goXCJ6b29tT3B0aW9uc1wiLCAobmV3VmFsdWUsIG9sZFZhbHVlKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5zbGlkZXJab29tZWQgJiZcbiAgICAgICAgICAgICAgICAoKChvbGRWYWx1ZSA9PT0gbnVsbCB8fCBvbGRWYWx1ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogb2xkVmFsdWUubWluKSAmJiAhKG5ld1ZhbHVlID09PSBudWxsIHx8IG5ld1ZhbHVlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBuZXdWYWx1ZS5taW4pKSB8fCAoKG9sZFZhbHVlID09PSBudWxsIHx8IG9sZFZhbHVlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvbGRWYWx1ZS5tYXgpICYmICEobmV3VmFsdWUgPT09IG51bGwgfHwgbmV3VmFsdWUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG5ld1ZhbHVlLm1heCkpKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuemlnemFnQ2xpY2sgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlWmlnemFnQ2xpY2sobmV3VmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jb2xvclNsaWRlci5vbihcIm1pbi1jaGFuZ2VcIiwgKGluZm8pID0+IHtcbiAgICAgICAgICAgIGlmIChjb2xvclZpc1Zhcikge1xuICAgICAgICAgICAgICAgIGlmIChpbmZvLnZhbHVlID4gdGhpcy5jdXJyZW50U3RvcFZhbHVlc1swXSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbG9yU2xpZGVyLnN0b3BzLmZvckVhY2goKHN0b3AsIGlkeCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RvcC52YWx1ZSA9IHRoaXMuY3VycmVudFN0b3BWYWx1ZXNbaWR4XTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub25NaW5NYXhDaGFuZ2UodGhpcy5jdXJyZW50U3RvcFZhbHVlc1swXSwgdGhpcy5jb2xvclNsaWRlci5zbGlkZXIubWF4LCBcIm1pblwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub25NaW5NYXhDaGFuZ2UoaW5mby52YWx1ZSwgdGhpcy5jb2xvclNsaWRlci5zbGlkZXIubWF4LCBcIm1pblwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5mby52YWx1ZSA+IHRoaXMuY3VycmVudEJyZWFrVmFsdWVzWzBdLm1heCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9uTWluTWF4Q2hhbmdlKHRoaXMuY3VycmVudEJyZWFrVmFsdWVzWzBdLm1heCwgdGhpcy5jb2xvclNsaWRlci5zbGlkZXIubWF4LCBcIm1pblwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub25NaW5NYXhDaGFuZ2UoaW5mby52YWx1ZSwgdGhpcy5jb2xvclNsaWRlci5zbGlkZXIubWF4LCBcIm1pblwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmNvbG9yU2xpZGVyLm9uKFwibWF4LWNoYW5nZVwiLCAoaW5mbykgPT4ge1xuICAgICAgICAgICAgaWYgKGNvbG9yVmlzVmFyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGluZm8udmFsdWUgPCB0aGlzLmN1cnJlbnRTdG9wVmFsdWVzW3RoaXMuY3VycmVudFN0b3BWYWx1ZXMubGVuZ3RoIC0gMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb2xvclNsaWRlci5zdG9wcy5mb3JFYWNoKChzdG9wLCBpZHgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0b3AudmFsdWUgPSB0aGlzLmN1cnJlbnRTdG9wVmFsdWVzW2lkeF07XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9uTWluTWF4Q2hhbmdlKHRoaXMuY29sb3JTbGlkZXIuc2xpZGVyLm1pbiwgdGhpcy5jdXJyZW50U3RvcFZhbHVlc1t0aGlzLmN1cnJlbnRTdG9wVmFsdWVzLmxlbmd0aCAtIDFdLCBcIm1heFwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub25NaW5NYXhDaGFuZ2UodGhpcy5jb2xvclNsaWRlci5zbGlkZXIubWluLCBpbmZvLnZhbHVlLCBcIm1heFwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5mby52YWx1ZSA8IHRoaXMuY3VycmVudEJyZWFrVmFsdWVzW3RoaXMuY3VycmVudEJyZWFrVmFsdWVzLmxlbmd0aCAtIDFdLm1pbikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9uTWluTWF4Q2hhbmdlKHRoaXMuY29sb3JTbGlkZXIuc2xpZGVyLm1pbiwgdGhpcy5jdXJyZW50QnJlYWtWYWx1ZXNbdGhpcy5jdXJyZW50QnJlYWtWYWx1ZXMubGVuZ3RoIC0gMV0ubWluLCBcIm1heFwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub25NaW5NYXhDaGFuZ2UodGhpcy5jb2xvclNsaWRlci5zbGlkZXIubWluLCBpbmZvLnZhbHVlLCBcIm1heFwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmNvbG9yU2xpZGVyLm9uKFwidGh1bWItY2hhbmdlXCIsIChpbmZvKSA9PiB7XG4gICAgICAgICAgICBpZiAoY29sb3JWaXNWYXIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBmaWVsZEluZm8gPSB0aGlzLmdldEZpZWxkSW5mbygpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGlzRGF0ZUZpZWxkID0gaXNEYXRlKGZpZWxkSW5mbyk7XG4gICAgICAgICAgICAgICAgaWYgKGlzRGF0ZUZpZWxkICYmIGluZm8udmFsdWUgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yY2VVcGRhdGUodGhpcy5ob3N0RWxlbWVudCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RvcHMgPSB0aGlzLmNvbG9yU2xpZGVyLnN0b3BzO1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlUmVuZGVyZXJTdG9wcyhzdG9wcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVJlbmRlcmVyQnJlYWtzKHRoaXMuY29sb3JTbGlkZXIuYnJlYWtzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuYXJjZ2lzU21hcnRNYXBwaW5nQ29sb3JTbGlkZXJDaGFuZ2UuZW1pdCgpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jb2xvclNsaWRlci5vbihcInRodW1iLWRyYWdcIiwgKCkgPT4ge1xuICAgICAgICAgICAgaWYgKGNvbG9yVmlzVmFyKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RvcHMgPSB0aGlzLmNvbG9yU2xpZGVyLnN0b3BzO1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlUmVuZGVyZXJTdG9wcyhzdG9wcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVJlbmRlcmVyQnJlYWtzKHRoaXMuY29sb3JTbGlkZXIuYnJlYWtzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuYXJjZ2lzU21hcnRNYXBwaW5nQ29sb3JTbGlkZXJDaGFuZ2UuZW1pdCgpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jb2xvclNsaWRlci5vbihcInNlZ21lbnQtZHJhZ1wiLCAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoY29sb3JWaXNWYXIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzdG9wcyA9IHRoaXMuY29sb3JTbGlkZXIuc3RvcHM7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVSZW5kZXJlclN0b3BzKHN0b3BzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlUmVuZGVyZXJCcmVha3ModGhpcy5jb2xvclNsaWRlci5icmVha3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5hcmNnaXNTbWFydE1hcHBpbmdDb2xvclNsaWRlckNoYW5nZS5lbWl0KCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB1cGRhdGVSZW5kZXJlclN0b3BzKHN0b3BzKSB7XG4gICAgICAgIGNvbnN0IHsgbGF5ZXIgfSA9IHNtYXJ0TWFwcGluZ1N0YXRlO1xuICAgICAgICBjb25zdCByZW5kZXJlciA9IGdldFJlbmRlcmVyKGxheWVyKTtcbiAgICAgICAgY29uc3QgY29sb3JWaXNWYXIgPSBnZXRWaXNWYXIocmVuZGVyZXIsIFwiY29sb3JcIik7XG4gICAgICAgIGNvbnN0IGF1dGhDb2xvclZpc1ZhciA9IGdldEF1dGhWaXNWYXIocmVuZGVyZXIsIFwiY29sb3JcIik7XG4gICAgICAgIGNvbG9yVmlzVmFyLnN0b3BzID0gc3RvcHM7XG4gICAgICAgIHRoaXMuY3VycmVudFN0b3BWYWx1ZXMgPSBjb2xvclZpc1Zhci5zdG9wcy5tYXAoKHN0b3ApID0+IHN0b3AudmFsdWUpO1xuICAgICAgICBjb25zdCB6b29tT3B0aW9ucyA9IGdldFpvb21PcHRpb25zKGNvbG9yVmlzVmFyID09PSBudWxsIHx8IGNvbG9yVmlzVmFyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb2xvclZpc1Zhci5zdG9wcywgYXV0aENvbG9yVmlzVmFyID09PSBudWxsIHx8IGF1dGhDb2xvclZpc1ZhciA9PT0gdm9pZCAwID8gdm9pZCAwIDogYXV0aENvbG9yVmlzVmFyLm1pblNsaWRlclZhbHVlLCBhdXRoQ29sb3JWaXNWYXIgPT09IG51bGwgfHwgYXV0aENvbG9yVmlzVmFyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhdXRoQ29sb3JWaXNWYXIubWF4U2xpZGVyVmFsdWUpO1xuICAgICAgICBpZiAodGhpcy5zbGlkZXJab29tZWQpIHtcbiAgICAgICAgICAgIHRoaXMuem9vbUJ1dHRvbk5vZGUuZGlzYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghem9vbU9wdGlvbnMgfHxcbiAgICAgICAgICAgIHpvb21PcHRpb25zLm1pbk1heFNhbWUgfHxcbiAgICAgICAgICAgICghaXNEZWZpbmVkKHpvb21PcHRpb25zLm1pbikgJiYgIWlzRGVmaW5lZCh6b29tT3B0aW9ucy5tYXgpKSkge1xuICAgICAgICAgICAgdGhpcy56b29tQnV0dG9uTm9kZS5kaXNhYmxlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnpvb21CdXR0b25Ob2RlLmRpc2FibGVkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdXBkYXRlSGlzdG9ncmFtQ29sb3JzKHRoaXMuY29sb3JTbGlkZXIsIHRoaXMuY29sb3JTbGlkZXJCYXJzLCBjb2xvclZpc1ZhciwgdGhpcy5oaXN0b2dyYW0pO1xuICAgICAgICB1cGRhdGVSZW5kZXJlcigpO1xuICAgIH1cbiAgICB1cGRhdGVSZW5kZXJlckJyZWFrcyhicmVha3MpIHtcbiAgICAgICAgY29uc3QgeyBsYXllciB9ID0gc21hcnRNYXBwaW5nU3RhdGU7XG4gICAgICAgIGNvbnN0IHJlbmRlcmVyID0gZ2V0UmVuZGVyZXIobGF5ZXIpO1xuICAgICAgICByZW5kZXJlci5hdXRob3JpbmdJbmZvLmNsYXNzaWZpY2F0aW9uTWV0aG9kID0gXCJtYW51YWxcIjtcbiAgICAgICAgcmVuZGVyZXIuY2xhc3NCcmVha0luZm9zLmZvckVhY2goKGNsYXNzQnJlYWtJbmZvLCBpZHgpID0+IHtcbiAgICAgICAgICAgIGlmIChjbGFzc0JyZWFrSW5mby5taW5WYWx1ZSAhPT0gYnJlYWtzW2lkeF0ubWluIHx8XG4gICAgICAgICAgICAgICAgY2xhc3NCcmVha0luZm8ubWF4VmFsdWUgIT09IGJyZWFrc1tpZHhdLm1heCkge1xuICAgICAgICAgICAgICAgIGNsYXNzQnJlYWtJbmZvLm1pblZhbHVlID0gYnJlYWtzW2lkeF0ubWluO1xuICAgICAgICAgICAgICAgIGNsYXNzQnJlYWtJbmZvLm1heFZhbHVlID0gYnJlYWtzW2lkeF0ubWF4O1xuICAgICAgICAgICAgICAgIGNvbnN0IHByZWZpeCA9IGlkeCA+IDAgPyBcIj4gXCIgOiBcIlwiO1xuICAgICAgICAgICAgICAgIGNsYXNzQnJlYWtJbmZvLmxhYmVsID0gYCR7cHJlZml4fSAke2NsYXNzQnJlYWtJbmZvLm1pblZhbHVlLnRvTG9jYWxlU3RyaW5nKCl9IC0gJHtjbGFzc0JyZWFrSW5mby5tYXhWYWx1ZS50b0xvY2FsZVN0cmluZygpfWA7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50QnJlYWtWYWx1ZXNbaWR4XS5taW4gPSBicmVha3NbaWR4XS5taW47XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50QnJlYWtWYWx1ZXNbaWR4XS5tYXggPSBicmVha3NbaWR4XS5tYXg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB1cGRhdGVIaXN0b2dyYW1Db2xvcnModGhpcy5jb2xvclNsaWRlciwgdGhpcy5jb2xvclNsaWRlckJhcnMsIGdldENsYXNzQnJlYWtzQ29sb3JzKCksIHRoaXMuaGlzdG9ncmFtKTtcbiAgICAgICAgdXBkYXRlUmVuZGVyZXIoKTtcbiAgICAgICAgdGhpcy5hcmNnaXNTbWFydE1hcHBpbmdDb2xvclNsaWRlckNoYW5nZS5lbWl0KCk7XG4gICAgfVxuICAgIGdldERlZmF1bHREYXRhUmFuZ2UoZmllbGRJbmZvKSB7XG4gICAgICAgIGlmIChmaWVsZEluZm8uc2ltcGxlRmllbGRUeXBlID09PSBzaW1wbGVGaWVsZFR5cGVzLkRBVEUpIHtcbiAgICAgICAgICAgIGNvbnN0IHllYXIgPSBuZXcgRGF0ZSgpLmdldEZ1bGxZZWFyKCk7XG4gICAgICAgICAgICByZXR1cm4gW25ldyBEYXRlKGAxLzEvJHt5ZWFyfWApLmdldFRpbWUoKSwgbmV3IERhdGUoYDEyLzMxLyR7eWVhcn1gKS5nZXRUaW1lKCldO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFswLCAxMDBdO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldEZpZWxkSW5mbygpIHtcbiAgICAgICAgY29uc3QgeyBsYXllciB9ID0gc21hcnRNYXBwaW5nU3RhdGU7XG4gICAgICAgIGNvbnN0IHJlbmRlcmVyID0gZ2V0UmVuZGVyZXIobGF5ZXIpO1xuICAgICAgICBjb25zdCBjb2xvclZpc1ZhciA9IGdldFZpc1ZhcihyZW5kZXJlciwgXCJjb2xvclwiKTtcbiAgICAgICAgY29uc3QgZmllbGQgPSBnZXRGaWVsZChjb2xvclZpc1ZhciA/IGNvbG9yVmlzVmFyLmZpZWxkIDogcmVuZGVyZXIuZmllbGQpO1xuICAgICAgICBjb25zdCBmaWVsZEluZm8gPSB7XG4gICAgICAgICAgICBmaWVsZDogKGNvbG9yVmlzVmFyID09PSBudWxsIHx8IGNvbG9yVmlzVmFyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb2xvclZpc1Zhci5maWVsZCkgfHwgcmVuZGVyZXIuZmllbGQsXG4gICAgICAgICAgICBleHByZXNzaW9uOiAoY29sb3JWaXNWYXIgPT09IG51bGwgfHwgY29sb3JWaXNWYXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbG9yVmlzVmFyLnZhbHVlRXhwcmVzc2lvbikgfHwgcmVuZGVyZXIudmFsdWVFeHByZXNzaW9uLFxuICAgICAgICAgICAgZXhwcmVzc2lvblRpdGxlOiAoY29sb3JWaXNWYXIgPT09IG51bGwgfHwgY29sb3JWaXNWYXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbG9yVmlzVmFyLnZhbHVlRXhwcmVzc2lvblRpdGxlKSB8fCByZW5kZXJlci52YWx1ZUV4cHJlc3Npb25UaXRsZSxcbiAgICAgICAgICAgIHNpbXBsZUZpZWxkVHlwZTogZmllbGQgPyBmaWVsZC5zaW1wbGVGaWVsZFR5cGUgOiBzaW1wbGVGaWVsZFR5cGVzLk5VTUJFUlxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gZmllbGRJbmZvO1xuICAgIH1cbiAgICBoYW5kbGVaaWd6YWdDbGljayhuZXdWYWx1ZSkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBjb25zdCB7IHN0YXRpc3RpY3MgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHsgbGF5ZXIgfSA9IHNtYXJ0TWFwcGluZ1N0YXRlO1xuICAgICAgICBjb25zdCByZW5kZXJlciA9IGdldFJlbmRlcmVyKGxheWVyKTtcbiAgICAgICAgY29uc3QgY29sb3JWaXNWYXIgPSBnZXRWaXNWYXIocmVuZGVyZXIsIFwiY29sb3JcIik7XG4gICAgICAgIGNvbnN0IGF1dGhDb2xvclZpc1ZhciA9IGdldEF1dGhWaXNWYXIocmVuZGVyZXIsIFwiY29sb3JcIik7XG4gICAgICAgIGNvbnN0IGZpZWxkSW5mbyA9IHRoaXMuZ2V0RmllbGRJbmZvKCk7XG4gICAgICAgIGNvbnN0IG5vcm1hbGl6YXRpb25GaWVsZCA9IGNvbG9yVmlzVmFyXG4gICAgICAgICAgICA/IGNvbG9yVmlzVmFyLm5vcm1hbGl6YXRpb25GaWVsZFxuICAgICAgICAgICAgOiByZW5kZXJlci5ub3JtYWxpemF0aW9uRmllbGQ7XG4gICAgICAgIHRoaXMuZ2V0SGlzdG9ncmFtKGZpZWxkSW5mbywgbm9ybWFsaXphdGlvbkZpZWxkLCBzdGF0aXN0aWNzLCAoX2EgPSBuZXdWYWx1ZSA9PT0gbnVsbCB8fCBuZXdWYWx1ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogbmV3VmFsdWUubWluKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBhdXRoQ29sb3JWaXNWYXIubWluU2xpZGVyVmFsdWUsIChfYiA9IG5ld1ZhbHVlID09PSBudWxsIHx8IG5ld1ZhbHVlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBuZXdWYWx1ZS5tYXgpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IGF1dGhDb2xvclZpc1Zhci5tYXhTbGlkZXJWYWx1ZSk7XG4gICAgICAgIGlmICghbmV3VmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuc2xpZGVyWm9vbWVkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGhvc3RFbGVtZW50KCkgeyByZXR1cm4gZ2V0RWxlbWVudCh0aGlzKTsgfVxufTtcbkFyY2dpc1NtYXJ0TWFwcGluZ0NvbG9yU2xpZGVyLnN0eWxlID0gYXJjZ2lzU21hcnRNYXBwaW5nQ29sb3JTbGlkZXJDc3M7XG5cbmV4cG9ydCB7IEFyY2dpc1NtYXJ0TWFwcGluZ0NvbG9yU2xpZGVyIGFzIGFyY2dpc19zbWFydF9tYXBwaW5nX2NvbG9yX3NsaWRlciB9O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1hcmNnaXMtc21hcnQtbWFwcGluZy1jb2xvci1zbGlkZXIuZW50cnkuanMubWFwIiwiLyohXG4gKiBBbGwgbWF0ZXJpYWwgY29weXJpZ2h0IEVTUkksIEFsbCBSaWdodHMgUmVzZXJ2ZWQsIHVubGVzcyBvdGhlcndpc2Ugc3BlY2lmaWVkLlxuICogdjQuMC41OFxuICovXG5pbXBvcnQgeyBQIGFzIGZpbmRDb2xvclNjaGVtZSwgcSBhcyBpc1BvbHlnb25UeXBlLCBwIGFzIGdldEF1dGhWaXNWYXIsIGwgYXMgYXBwbHlFeHRyYVZpc1ZhcnMsIHMgYXMgc21hcnRNYXBwaW5nU3RhdGUsIG0gYXMgc2F2ZUV4dHJhVmlzVmFycywgaCBhcyBnZXRSZW5kZXJlciwgYSBhcyBnZXRWaXNWYXIsIFIgYXMgaXNFbXB0eSwgdyBhcyBzaW1wbGVGaWVsZFR5cGVzIH0gZnJvbSAnLi9yYXN0ZXItdW5pcXVlLXZhbHVlLTA5NzZlYzdmLmpzJztcbmltcG9ydCAnLi9sb2FkTW9kdWxlcy1iNGFjMTI0Ny5qcyc7XG5pbXBvcnQgeyBpIGFzIGlzRGVmaW5lZCB9IGZyb20gJy4vY29tbW9uRnVuY3Rpb25zLWIwODMwZTllLmpzJztcblxuLyoqXG4gKiBVcGRhdGVzIHRoZSBsYXllciB3aXRoIGEgQ29tcGFyZSByZW5kZXJlciB3aXRoIGRlZmF1bHQgc2V0dGluZ3NcbiAqIEBwYXJhbSBwcm9wczogbXVzdCBjb250YWluIGxheWVyLCBtYXBWaWV3LCBmaWVsZFxuICogQHBhcmFtIG9wdGlvbnM6IG9wdGlvbnNcbiAqL1xuZnVuY3Rpb24gY3JlYXRlQ29tcGFyZVJlbmRlcmVyKG9wdGlvbnMpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgeyBsYXllcjogc21MYXllciwgbWFwSW1hZ2VTdWJsYXllciwgbWFwVmlldywgbW9kdWxlcyB9ID0gc21hcnRNYXBwaW5nU3RhdGU7XG4gICAgY29uc3QgbGF5ZXIgPSBzbUxheWVyO1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIGNvbnN0IGV4dHJhcyA9IHNhdmVFeHRyYVZpc1ZhcnMoZ2V0UmVuZGVyZXIobGF5ZXIpKTtcbiAgICByZXR1cm4gbW9kdWxlcy5Db2xvckNyZWF0b3IuY3JlYXRlQ29udGludW91c1JlbmRlcmVyKHtcbiAgICAgICAgbGF5ZXIsXG4gICAgICAgIHZpZXc6IG1hcFZpZXcsXG4gICAgICAgIGZpZWxkOiBvcHRpb25zLmZpZWxkSW5mb3NbMF0uZmllbGQsXG4gICAgICAgIHRoZW1lOiBcImFib3ZlLWFuZC1iZWxvd1wiLFxuICAgICAgICBjb2xvclNjaGVtZTogZmluZENvbG9yU2NoZW1lKFwiYWJvdmUtYW5kLWJlbG93XCIpLFxuICAgICAgICBub3JtYWxpemF0aW9uRmllbGQ6IG9wdGlvbnMuZmllbGRJbmZvc1sxXS5maWVsZCxcbiAgICAgICAgb3V0bGluZU9wdGltaXphdGlvbkVuYWJsZWQ6IG1hcEltYWdlU3VibGF5ZXJcbiAgICAgICAgICAgID8gZmFsc2VcbiAgICAgICAgICAgIDogaXNEZWZpbmVkKG9wdGlvbnMub3V0bGluZU9wdGltaXphdGlvbkVuYWJsZWQpXG4gICAgICAgICAgICAgICAgPyBvcHRpb25zLm91dGxpbmVPcHRpbWl6YXRpb25FbmFibGVkXG4gICAgICAgICAgICAgICAgOiBpc1BvbHlnb25UeXBlKGxheWVyKSxcbiAgICAgICAgc2l6ZU9wdGltaXphdGlvbkVuYWJsZWQ6IG1hcEltYWdlU3VibGF5ZXJcbiAgICAgICAgICAgID8gZmFsc2VcbiAgICAgICAgICAgIDogaXNEZWZpbmVkKG9wdGlvbnMuc2l6ZU9wdGltaXphdGlvbkVuYWJsZWQpXG4gICAgICAgICAgICAgICAgPyBvcHRpb25zLnNpemVPcHRpbWl6YXRpb25FbmFibGVkXG4gICAgICAgICAgICAgICAgOiB0cnVlLFxuICAgICAgICBsZWdlbmRPcHRpb25zOiBvcHRpb25zLmxlZ2VuZE9wdGlvbnMsXG4gICAgICAgIGRlZmF1bHRTeW1ib2xFbmFibGVkOiBmYWxzZSxcbiAgICAgICAgZm9yQmlubmluZzogKChfYSA9IGxheWVyLmZlYXR1cmVSZWR1Y3Rpb24pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS50eXBlKSA9PT0gXCJiaW5uaW5nXCJcbiAgICB9KS50aGVuKChyZXN1bHQpID0+IHtcbiAgICAgICAgY29uc3QgY29sb3JBdXRoVmlzVmFyID0gZ2V0QXV0aFZpc1ZhcihyZXN1bHQucmVuZGVyZXIsIFwiY29sb3JcIikgfHwge307XG4gICAgICAgIGNvbG9yQXV0aFZpc1Zhci5zdHlsZSA9IFwicmF0aW9cIjsgLy8gXCJyYXRpb1wiLCBcInBlcmNlbnRcIiwgXCJwZXJjZW50LW9mLXRvdGFsXCJcbiAgICAgICAgYXBwbHlFeHRyYVZpc1ZhcnMoZXh0cmFzLCByZXN1bHQucmVuZGVyZXIpO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlc3VsdCk7XG4gICAgfSwgKGVycm9yKSA9PiBQcm9taXNlLnJlamVjdChlcnJvcikpO1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgQ29tcGFyZSByZW5kZXJlciB3aXRoIHNldHRpbmdzIGZyb20gY3VycmVudCByZW5kZXJlclxuICogQHBhcmFtIHByb3BzOiBvbmx5IGNvbnRhaW5zIHByb3BlcnRpZXMgdGhhdCBuZWVkIHRvIGJlIG92ZXJ3cml0dGVuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUNvbXBhcmVSZW5kZXJlckZyb21FeGlzdGluZyhvcHRpb25zKSB7XG4gICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgIGNvbnN0IHsgbGF5ZXI6IHNtTGF5ZXIsIG1hcEltYWdlU3VibGF5ZXIsIG1hcFZpZXcsIG1vZHVsZXMgfSA9IHNtYXJ0TWFwcGluZ1N0YXRlO1xuICAgIGNvbnN0IGxheWVyID0gc21MYXllcjtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBjb25zdCByZW5kZXJlciA9IGdldFJlbmRlcmVyKGxheWVyKTtcbiAgICBjb25zdCBjb2xvclZpc1ZhciA9IGdldFZpc1ZhcihyZW5kZXJlciwgXCJjb2xvclwiKTtcbiAgICBpZiAoY29sb3JWaXNWYXIgJiZcbiAgICAgICAgb3B0aW9ucy5maWVsZEluZm8gJiZcbiAgICAgICAgb3B0aW9ucy5maWVsZEluZm8uZmllbGQgPT0gY29sb3JWaXNWYXIuZmllbGQgJiZcbiAgICAgICAgb3B0aW9ucy5ub3JtYWxpemF0aW9uRmllbGQgPT09IGNvbG9yVmlzVmFyLm5vcm1hbGl6YXRpb25GaWVsZCkge1xuICAgICAgICAvLyBubyBjaGFuZ2VzIHRvIGZpZWxkc1xuICAgICAgICBkZWxldGUgb3B0aW9ucy5maWVsZEluZm9zO1xuICAgICAgICBpZiAoaXNFbXB0eShvcHRpb25zKSkge1xuICAgICAgICAgICAgLy8gbm90aGluZyByZWFsbHkgY2hhbmdlc1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7IHJlbmRlcmVyOiByZW5kZXJlci5jbG9uZSgpIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGF1dGhDb2xvclZpc1ZhciA9IGdldEF1dGhWaXNWYXIocmVuZGVyZXIsIFwiY29sb3JcIik7XG4gICAgY29uc3QgZXh0cmFzID0gc2F2ZUV4dHJhVmlzVmFycyhyZW5kZXJlcik7XG4gICAgbGV0IGZpZWxkSW5mbyA9IG9wdGlvbnMuZmllbGRJbmZvc1xuICAgICAgICA/IG9wdGlvbnMuZmllbGRJbmZvc1swXVxuICAgICAgICA6IGNvbG9yVmlzVmFyXG4gICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICBmaWVsZDogY29sb3JWaXNWYXIuZmllbGQsXG4gICAgICAgICAgICAgICAgZXhwcmVzc2lvbjogY29sb3JWaXNWYXIudmFsdWVFeHByZXNzaW9uLFxuICAgICAgICAgICAgICAgIGV4cHJlc3Npb25UaXRsZTogY29sb3JWaXNWYXIudmFsdWVFeHByZXNzaW9uVGl0bGUsXG4gICAgICAgICAgICAgICAgc2ltcGxlRmllbGRUeXBlOiBzaW1wbGVGaWVsZFR5cGVzLk5VTUJFUlxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgOiB7XG4gICAgICAgICAgICAgICAgZmllbGQ6IHJlbmRlcmVyLmZpZWxkLFxuICAgICAgICAgICAgICAgIGV4cHJlc3Npb246IHJlbmRlcmVyLnZhbHVlRXhwcmVzc2lvbixcbiAgICAgICAgICAgICAgICBleHByZXNzaW9uVGl0bGU6IHJlbmRlcmVyLnZhbHVlRXhwcmVzc2lvblRpdGxlLFxuICAgICAgICAgICAgICAgIHNpbXBsZUZpZWxkVHlwZTogc2ltcGxlRmllbGRUeXBlcy5OVU1CRVJcbiAgICAgICAgICAgIH07XG4gICAgY29uc3Qgbm9ybWFsaXphdGlvbkZpZWxkID0gb3B0aW9ucy5ub3JtYWxpemF0aW9uRmllbGRcbiAgICAgICAgPyBvcHRpb25zLm5vcm1hbGl6YXRpb25GaWVsZFxuICAgICAgICA6IGNvbG9yVmlzVmFyXG4gICAgICAgICAgICA/IGNvbG9yVmlzVmFyLm5vcm1hbGl6YXRpb25GaWVsZFxuICAgICAgICAgICAgOiByZW5kZXJlci5ub3JtYWxpemF0aW9uRmllbGQ7XG4gICAgY29uc3Qgc3ltYm9sID0gcmVuZGVyZXIuY2xhc3NCcmVha0luZm9zICYmIHJlbmRlcmVyLmNsYXNzQnJlYWtJbmZvcy5sZW5ndGggPyByZW5kZXJlci5jbGFzc0JyZWFrSW5mb3NbMF0uc3ltYm9sIDogbnVsbDtcbiAgICBjb25zdCBkZWZhdWx0U3ltYm9sID0gcmVuZGVyZXIuZGVmYXVsdFN5bWJvbDtcbiAgICBjb25zdCBkZWZhdWx0TGFiZWwgPSByZW5kZXJlci5kZWZhdWx0TGFiZWw7XG4gICAgbGV0IG5lZWROZXdTdGF0aXN0aWNzID0gZmFsc2U7XG4gICAgaWYgKG9wdGlvbnMubm9ybWFsaXphdGlvbkZpZWxkID09PSBudWxsIHx8IG9wdGlvbnMubm9ybWFsaXphdGlvbkZpZWxkIHx8IG9wdGlvbnMuZmllbGRJbmZvKSB7XG4gICAgICAgIG5lZWROZXdTdGF0aXN0aWNzID0gdHJ1ZTtcbiAgICB9XG4gICAgY29uc3QgbWluVmFsdWUgPSBvcHRpb25zLmRpc2NhcmRNaW5NYXhcbiAgICAgICAgPyB1bmRlZmluZWRcbiAgICAgICAgOiBpc0RlZmluZWQob3B0aW9ucy5taW4pXG4gICAgICAgICAgICA/IG9wdGlvbnMubWluXG4gICAgICAgICAgICA6IG5lZWROZXdTdGF0aXN0aWNzXG4gICAgICAgICAgICAgICAgPyB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICA6IGF1dGhDb2xvclZpc1ZhclxuICAgICAgICAgICAgICAgICAgICA/IGF1dGhDb2xvclZpc1Zhci5taW5TbGlkZXJWYWx1ZVxuICAgICAgICAgICAgICAgICAgICA6IHJlbmRlcmVyLmNsYXNzQnJlYWtJbmZvc1swXS5taW5WYWx1ZTtcbiAgICBjb25zdCBtYXhWYWx1ZSA9IG9wdGlvbnMuZGlzY2FyZE1pbk1heFxuICAgICAgICA/IHVuZGVmaW5lZFxuICAgICAgICA6IGlzRGVmaW5lZChvcHRpb25zLm1heClcbiAgICAgICAgICAgID8gb3B0aW9ucy5tYXhcbiAgICAgICAgICAgIDogbmVlZE5ld1N0YXRpc3RpY3NcbiAgICAgICAgICAgICAgICA/IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgIDogYXV0aENvbG9yVmlzVmFyXG4gICAgICAgICAgICAgICAgICAgID8gYXV0aENvbG9yVmlzVmFyLm1heFNsaWRlclZhbHVlXG4gICAgICAgICAgICAgICAgICAgIDogcmVuZGVyZXIuY2xhc3NCcmVha0luZm9zW3JlbmRlcmVyLmNsYXNzQnJlYWtJbmZvcy5sZW5ndGggLSAxXS5tYXhWYWx1ZTtcbiAgICByZXR1cm4gbW9kdWxlcy5Db2xvckNyZWF0b3IuY3JlYXRlQ29udGludW91c1JlbmRlcmVyKHtcbiAgICAgICAgbGF5ZXIsXG4gICAgICAgIHZpZXc6IG1hcFZpZXcsXG4gICAgICAgIGZpZWxkOiBmaWVsZEluZm8gPyBmaWVsZEluZm8uZmllbGQgOiByZW5kZXJlci5maWVsZCxcbiAgICAgICAgdGhlbWU6IFwiYWJvdmUtYW5kLWJlbG93XCIsXG4gICAgICAgIGNvbG9yU2NoZW1lOiBmaW5kQ29sb3JTY2hlbWUoXCJhYm92ZS1hbmQtYmVsb3dcIiksXG4gICAgICAgIG5vcm1hbGl6YXRpb25GaWVsZCxcbiAgICAgICAgbWluVmFsdWUsXG4gICAgICAgIG1heFZhbHVlLFxuICAgICAgICBvdXRsaW5lT3B0aW1pemF0aW9uRW5hYmxlZDogbWFwSW1hZ2VTdWJsYXllclxuICAgICAgICAgICAgPyBmYWxzZVxuICAgICAgICAgICAgOiBpc0RlZmluZWQob3B0aW9ucy5vdXRsaW5lT3B0aW1pemF0aW9uRW5hYmxlZClcbiAgICAgICAgICAgICAgICA/IG9wdGlvbnMub3V0bGluZU9wdGltaXphdGlvbkVuYWJsZWRcbiAgICAgICAgICAgICAgICA6ICEhZXh0cmFzLnNpemVPdXRsaW5lVmlzVmFyLFxuICAgICAgICBzaXplT3B0aW1pemF0aW9uRW5hYmxlZDogbWFwSW1hZ2VTdWJsYXllclxuICAgICAgICAgICAgPyBmYWxzZVxuICAgICAgICAgICAgOiBpc0RlZmluZWQob3B0aW9ucy5zaXplT3B0aW1pemF0aW9uRW5hYmxlZClcbiAgICAgICAgICAgICAgICA/IG9wdGlvbnMuc2l6ZU9wdGltaXphdGlvbkVuYWJsZWRcbiAgICAgICAgICAgICAgICA6ICEhZXh0cmFzLnNpemVBdXRvVmlzVmFyLFxuICAgICAgICBsZWdlbmRPcHRpb25zOiAoKF9hID0gb3B0aW9ucy5sZWdlbmRPcHRpb25zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudG9KU09OKCkpIHx8XG4gICAgICAgICAgICAoKF9iID0gY29sb3JWaXNWYXIgPT09IG51bGwgfHwgY29sb3JWaXNWYXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbG9yVmlzVmFyLmxlZ2VuZE9wdGlvbnMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi50b0pTT04oKSkgfHxcbiAgICAgICAgICAgICgoX2MgPSByZW5kZXJlci5sZWdlbmRPcHRpb25zKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MudG9KU09OKCkpLFxuICAgICAgICBkZWZhdWx0U3ltYm9sRW5hYmxlZDogaXNEZWZpbmVkKG9wdGlvbnMuZGVmYXVsdFN5bWJvbEVuYWJsZWQpXG4gICAgICAgICAgICA/IG9wdGlvbnMuZGVmYXVsdFN5bWJvbEVuYWJsZWRcbiAgICAgICAgICAgIDogISFyZW5kZXJlci5kZWZhdWx0U3ltYm9sLFxuICAgICAgICBmb3JCaW5uaW5nOiAoKF9kID0gbGF5ZXIuZmVhdHVyZVJlZHVjdGlvbikgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLnR5cGUpID09PSBcImJpbm5pbmdcIlxuICAgIH0pLnRoZW4oKHJlc3VsdCkgPT4ge1xuICAgICAgICAvLyByZXNldCBoYW5kbGVzIGlmIG5lY2Vzc2FyeVxuICAgICAgICBpZiAob3B0aW9ucy5kaXNjYXJkTWluTWF4KSB7XG4gICAgICAgICAgICBjb25zdCBjb2xvclZpc1ZhciA9IGdldFZpc1ZhcihyZW5kZXJlciwgXCJjb2xvclwiKTtcbiAgICAgICAgICAgIGNvbnN0IG5ld0NvbG9yVmlzVmFyID0gZ2V0VmlzVmFyKHJlc3VsdC5yZW5kZXJlciwgXCJjb2xvclwiKTtcbiAgICAgICAgICAgIGNvbG9yVmlzVmFyLnN0b3BzLmZvckVhY2goKHN0b3AsIGlkeCkgPT4gKHN0b3AudmFsdWUgPSBuZXdDb2xvclZpc1Zhci5zdG9wc1tpZHhdLnZhbHVlKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29sb3JBdXRoVmlzVmFyID0gZ2V0QXV0aFZpc1ZhcihyZXN1bHQucmVuZGVyZXIsIFwiY29sb3JcIikgfHwge307XG4gICAgICAgIGNvbG9yQXV0aFZpc1Zhci5zdHlsZSA9IFwicmF0aW9cIjtcbiAgICAgICAgLy9jb25zb2xlLmxvZyhcImNyZWF0ZUNvbnRpbnVvdXNSZW5kZXJlclwiLCByZXN1bHQpO1xuICAgICAgICBhcHBseUV4dHJhVmlzVmFycyhleHRyYXMsIHJlc3VsdC5yZW5kZXJlcik7XG4gICAgICAgIGlmIChzeW1ib2wgJiYgcmVzdWx0LnJlbmRlcmVyLmNsYXNzQnJlYWtJbmZvcyAmJiByZXN1bHQucmVuZGVyZXIuY2xhc3NCcmVha0luZm9zLmxlbmd0aCkge1xuICAgICAgICAgICAgcmVzdWx0LnJlbmRlcmVyLmNsYXNzQnJlYWtJbmZvc1swXS5zeW1ib2wgPSBzeW1ib2w7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRlZmF1bHRTeW1ib2wpIHtcbiAgICAgICAgICAgIHJlc3VsdC5yZW5kZXJlci5kZWZhdWx0U3ltYm9sID0gZGVmYXVsdFN5bWJvbDtcbiAgICAgICAgICAgIHJlc3VsdC5yZW5kZXJlci5kZWZhdWx0TGFiZWwgPSBkZWZhdWx0TGFiZWw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShyZXN1bHQpO1xuICAgIH0sIChlcnJvcikgPT4gUHJvbWlzZS5yZWplY3QoZXJyb3IpKTtcbn1cblxuZXhwb3J0IHsgY3JlYXRlQ29tcGFyZVJlbmRlcmVyRnJvbUV4aXN0aW5nIGFzIGEsIGNyZWF0ZUNvbXBhcmVSZW5kZXJlciBhcyBjIH07XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbXBhcmUtYmExMjkyZmUuanMubWFwIiwiLyohXG4gKiBBbGwgbWF0ZXJpYWwgY29weXJpZ2h0IEVTUkksIEFsbCBSaWdodHMgUmVzZXJ2ZWQsIHVubGVzcyBvdGhlcndpc2Ugc3BlY2lmaWVkLlxuICogdjQuMC41OFxuICovXG5pbXBvcnQgeyBzIGFzIHNtYXJ0TWFwcGluZ1N0YXRlIH0gZnJvbSAnLi9yYXN0ZXItdW5pcXVlLXZhbHVlLTA5NzZlYzdmLmpzJztcbmltcG9ydCAnLi9sb2FkTW9kdWxlcy1iNGFjMTI0Ny5qcyc7XG5pbXBvcnQgJy4vY29tbW9uRW51bXMtZmNmMTM2NjEuanMnO1xuXG5mdW5jdGlvbiBhZGREYXRlRm9ybWF0RnVuY3Rpb25zKGNvbmZpZywgdGltZVpvbmUpIHtcbiAgICBjb25maWcubGFiZWxGb3JtYXRGdW5jdGlvbiA9ICh2YWx1ZSkgPT4ge1xuICAgICAgICByZXR1cm4gZ2V0RGF0ZURpc3BsYXlTdHJpbmcodmFsdWUsIHRpbWVab25lLCBcInNob3J0LWRhdGVcIik7XG4gICAgfTtcbiAgICBjb25maWcuaW5wdXRGb3JtYXRGdW5jdGlvbiA9ICh2YWx1ZSkgPT4ge1xuICAgICAgICByZXR1cm4gZ2V0RGF0ZURpc3BsYXlTdHJpbmcodmFsdWUsIHRpbWVab25lLCBcInNob3J0LWRhdGVcIik7XG4gICAgfTtcbiAgICBjb25maWcuaW5wdXRQYXJzZUZ1bmN0aW9uID0gKHZhbHVlKSA9PiB7XG4gICAgICAgIHJldHVybiBtYXBUWlRvVVRDKERhdGUucGFyc2UodmFsdWUpLCB0aW1lWm9uZSk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIHV0Y1RvRGF0ZVBpY2tlcih2YWx1ZSwgdGltZVpvbmUpIHtcbiAgICAvLyBkYXRlIGlzIGluIFVUQ1xuICAgIC8vIHdlIG5lZWQgYSBtYXAgdGltZXpvbmVcbiAgICBsZXQgc3RyO1xuICAgIGlmICghdGltZVpvbmUgfHwgdGltZVpvbmUgPT09IFwic3lzdGVtXCIpIHtcbiAgICAgICAgY29uc3QgZGlmZiA9IG5ldyBEYXRlKCkuZ2V0VGltZXpvbmVPZmZzZXQoKTtcbiAgICAgICAgc3RyID0gbmV3IERhdGUodmFsdWUgLSBkaWZmICogNjAwMDApLnRvSVNPU3RyaW5nKCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHRpbWVab25lID09PSBcInVua25vd25cIikge1xuICAgICAgICBzdHIgPSBuZXcgRGF0ZSh2YWx1ZSkudG9JU09TdHJpbmcoKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IGRpZmYgPSBuZXcgRGF0ZSgpLmdldFRpbWV6b25lT2Zmc2V0KCk7XG4gICAgICAgIGNvbnN0IG1hcERhdGVTdHIgPSBuZXcgRGF0ZSh2YWx1ZSkudG9Mb2NhbGVTdHJpbmcoXCJlbi1VU1wiLCB7IHRpbWVab25lIH0pO1xuICAgICAgICBzdHIgPSBuZXcgRGF0ZShuZXcgRGF0ZShtYXBEYXRlU3RyKS5nZXRUaW1lKCkgLSBkaWZmICogNjAwMDApLnRvSVNPU3RyaW5nKCk7XG4gICAgfVxuICAgIC8vIGNvbnNvbGUubG9nKFwidXRjVG9EYXRlUGlja2VyXCIsIHZhbHVlLCBcIiAtIFwiLCBuZXcgRGF0ZSh2YWx1ZSkudG9JU09TdHJpbmcoKSwgXCIgLT4gXCIsIHN0cik7XG4gICAgcmV0dXJuIHN0cjtcbn1cbmZ1bmN0aW9uIHV0Y1RvVGltZVBpY2tlcih2YWx1ZSwgdGltZVpvbmUsIGFkZFNlY29uZHMpIHtcbiAgICAvLyBkYXRlIGlzIGluIFVUQ1xuICAgIC8vIHdlIG5lZWQgYSBtYXAgdGltZXpvbmVcbiAgICBsZXQgc3RyO1xuICAgIGlmICghdGltZVpvbmUgfHwgdGltZVpvbmUgPT09IFwic3lzdGVtXCIpIHtcbiAgICAgICAgY29uc3QgZGlmZiA9IG5ldyBEYXRlKCkuZ2V0VGltZXpvbmVPZmZzZXQoKTtcbiAgICAgICAgc3RyID0gbmV3IERhdGUodmFsdWUgLSBkaWZmICogNjAwMDApLnRvSVNPU3RyaW5nKCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHRpbWVab25lID09PSBcInVua25vd25cIikge1xuICAgICAgICBzdHIgPSBuZXcgRGF0ZSh2YWx1ZSkudG9JU09TdHJpbmcoKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IGRpZmYgPSBuZXcgRGF0ZSgpLmdldFRpbWV6b25lT2Zmc2V0KCk7XG4gICAgICAgIGNvbnN0IG1hcERhdGVTdHIgPSBuZXcgRGF0ZSh2YWx1ZSkudG9Mb2NhbGVTdHJpbmcoXCJlbi1VU1wiLCB7IHRpbWVab25lIH0pO1xuICAgICAgICBzdHIgPSBuZXcgRGF0ZShuZXcgRGF0ZShtYXBEYXRlU3RyKS5nZXRUaW1lKCkgLSBkaWZmICogNjAwMDApLnRvSVNPU3RyaW5nKCk7XG4gICAgfVxuICAgIC8vIHN0ciA9IFwiMjAyMy0wOS0yMFQxMzowNjowMC4wMDBaXCJcbiAgICBzdHIgPSBhZGRTZWNvbmRzID8gc3RyLnN1YnN0cmluZygxMSwgMTkpIDogc3RyLnN1YnN0cmluZygxMSwgMTYpO1xuICAgIC8vIGNvbnNvbGUubG9nKFwidXRjVG9UaW1lUGlja2VyXCIsIHZhbHVlLCBcIiAtIFwiLCBuZXcgRGF0ZSh2YWx1ZSkudG9JU09TdHJpbmcoKSwgXCIgLT4gXCIsIHN0cik7XG4gICAgcmV0dXJuIHN0cjtcbn1cbmZ1bmN0aW9uIGRhdGVQaWNrZXJUb1VUQyhkYXRlU3RyaW5nLCB0aW1lWm9uZSkge1xuICAgIC8vIGRhdGUgaXMgaW4gbWFwIHRpbWV6b25lXG4gICAgLy8gd2UgbmVlZCBhIFVUQyBVTklYIHRpbWVzdGFtcFxuICAgIGxldCBkYXRlID0gbmV3IERhdGUoZGF0ZVN0cmluZyk7XG4gICAgLy8gdGhpcyBpcyByZWFkIGFzIGN1cnJlbnQgdGltZTsgdG9JU09TdHJpbmcoKSB3b3VsZCByZWF0dXJuIFVUQyB0aW1lIChlLmcuICs3IGhvdXJzIGZyb20gcGFjaWZpYylcbiAgICAvLyBmaXggdGhlIG9mZnNldFxuICAgIGRhdGUgPSBuZXcgRGF0ZShkYXRlLmdldFRpbWUoKSAtIGRhdGUuZ2V0VGltZXpvbmVPZmZzZXQoKSAqIDYwMDAwKTtcbiAgICAvLyBkYXRlIG5vdyBjb250YWlucyB0aGUgdXNlcidzIGVudGVyZWQgdGltZVxuICAgIGxldCB2YWx1ZTtcbiAgICBpZiAoIXRpbWVab25lIHx8IHRpbWVab25lID09PSBcInN5c3RlbVwiKSB7XG4gICAgICAgIC8vIGFkZCBkaWZmZXJlbmNlIGJldHdlZW4gbG9jYWwgdGltZSBhbmQgVVRDXG4gICAgICAgIHZhbHVlID0gZGF0ZS5nZXRUaW1lKCkgKyBkYXRlLmdldFRpbWV6b25lT2Zmc2V0KCkgKiA2MDAwMDtcbiAgICB9XG4gICAgZWxzZSBpZiAodGltZVpvbmUgPT09IFwidW5rbm93blwiKSB7XG4gICAgICAgIC8vIHRha2Ugd2hhdCB5b3UgZ2V0XG4gICAgICAgIHZhbHVlID0gZGF0ZS5nZXRUaW1lKCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBhZGQgZGlmZmVyZW5jZSBiZXR3ZWVuIG1hcCB0aW1lIGFuZCBVVENcbiAgICAgICAgY29uc3QgZGlmZiA9IG5ldyBEYXRlKGRhdGUudG9Mb2NhbGVTdHJpbmcoXCJlbi1VU1wiLCB7IHRpbWVab25lOiBcInV0Y1wiIH0pKS5nZXRUaW1lKCkgLVxuICAgICAgICAgICAgbmV3IERhdGUoZGF0ZS50b0xvY2FsZVN0cmluZyhcImVuLVVTXCIsIHsgdGltZVpvbmUgfSkpLmdldFRpbWUoKTtcbiAgICAgICAgdmFsdWUgPSBkYXRlLmdldFRpbWUoKSArIGRpZmY7XG4gICAgfVxuICAgIC8vIGNvbnNvbGUubG9nKFwiZGF0ZVBpY2tlclRvVVRDXCIsIGRhdGUudG9JU09TdHJpbmcoKSwgXCIgLT4gXCIsIG5ldyBEYXRlKHZhbHVlKS50b0lTT1N0cmluZygpKTtcbiAgICByZXR1cm4gdmFsdWU7XG59XG5mdW5jdGlvbiBtYXBUWlRvVVRDKHZhbHVlLCB0aW1lWm9uZSkge1xuICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICAvLyB2YWx1ZSBpcyBpbiBtYXAgdGltZXpvbmVcbiAgICAvLyB3ZSBuZWVkIGEgVVRDIHRpbWVzdGFtcFxuICAgIGxldCBuZXdWYWx1ZTtcbiAgICBpZiAoIXRpbWVab25lIHx8IHRpbWVab25lID09PSBcInN5c3RlbVwiKSB7XG4gICAgICAgIC8vIGFkZCBkaWZmZXJlbmNlIGJldHdlZW4gbG9jYWwgdGltZSBhbmQgVVRDXG4gICAgICAgIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZSgpO1xuICAgICAgICBuZXdWYWx1ZSA9IHZhbHVlICsgZGF0ZS5nZXRUaW1lem9uZU9mZnNldCgpICogNjAwMDA7XG4gICAgfVxuICAgIGVsc2UgaWYgKHRpbWVab25lID09PSBcInVua25vd25cIikge1xuICAgICAgICAvLyB0YWtlIHdoYXQgeW91IGdldFxuICAgICAgICBuZXdWYWx1ZSA9IHZhbHVlO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gYWRkIGRpZmZlcmVuY2UgYmV0d2VlbiBtYXAgdGltZSBhbmQgVVRDXG4gICAgICAgIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZSgpO1xuICAgICAgICBjb25zdCBkaWZmID0gbmV3IERhdGUoZGF0ZS50b0xvY2FsZVN0cmluZyhcImVuLVVTXCIsIHsgdGltZVpvbmU6IFwidXRjXCIgfSkpLmdldFRpbWUoKSAtXG4gICAgICAgICAgICBuZXcgRGF0ZShkYXRlLnRvTG9jYWxlU3RyaW5nKFwiZW4tVVNcIiwgeyB0aW1lWm9uZSB9KSkuZ2V0VGltZSgpO1xuICAgICAgICBuZXdWYWx1ZSA9IHZhbHVlICsgZGlmZjtcbiAgICB9XG4gICAgY29uc29sZS5sb2coXCJtYXBUWlRvVVRDXCIsIHZhbHVlLCBcIiAtIFwiLCBuZXcgRGF0ZSh2YWx1ZSkudG9JU09TdHJpbmcoKSwgXCIgLSBcIiwgbmV3IERhdGUobmV3VmFsdWUpLnRvSVNPU3RyaW5nKCkpO1xuICAgIHJldHVybiBuZXdWYWx1ZTtcbn1cbmZ1bmN0aW9uIGdldERhdGVEaXNwbGF5U3RyaW5nKHZhbHVlLCB0aW1lWm9uZSwgZGF0ZUZvcm1hdCkge1xuICAgIGNvbnN0IHsgbW9kdWxlcyB9ID0gc21hcnRNYXBwaW5nU3RhdGU7XG4gICAgbGV0IHN0cjtcbiAgICBpZiAodGltZVpvbmUgPT09IFwidW5rbm93blwiKSB7XG4gICAgICAgIHN0ciA9IG1vZHVsZXMuaW50bC5mb3JtYXREYXRlKHZhbHVlLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG1vZHVsZXMuaW50bC5jb252ZXJ0RGF0ZUZvcm1hdFRvSW50bE9wdGlvbnMoZGF0ZUZvcm1hdCB8fCBcInNob3J0LWRhdGUtc2hvcnQtdGltZVwiKSksIHsgdGltZVpvbmU6IFwidXRjXCIsIHRpbWVab25lTmFtZTogXCJzaG9ydE9mZnNldFwiIH0pKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIGtub3duIGlzc3VlcyB3aXRoIGZvcm1hdHRpbmcgaXQtQ0hcbiAgICAgICAgc3RyID0gbW9kdWxlcy5pbnRsLmZvcm1hdERhdGUodmFsdWUsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbW9kdWxlcy5pbnRsLmNvbnZlcnREYXRlRm9ybWF0VG9JbnRsT3B0aW9ucyhkYXRlRm9ybWF0IHx8IFwic2hvcnQtZGF0ZS1zaG9ydC10aW1lXCIpKSwgeyB0aW1lWm9uZSB9KSk7XG4gICAgfVxuICAgIC8vIGNvbnNvbGUubG9nKFwiZ2V0RGF0ZURpc3BsYXlTdHJpbmdcIiwgdmFsdWUsIFwiIC0gXCIsIG5ldyBEYXRlKHZhbHVlKS50b0lTT1N0cmluZygpLCBcIiAtPiBcIiwgc3RyKTtcbiAgICByZXR1cm4gc3RyO1xufVxuXG5leHBvcnQgeyBhZGREYXRlRm9ybWF0RnVuY3Rpb25zIGFzIGEsIHV0Y1RvVGltZVBpY2tlciBhcyBiLCBkYXRlUGlja2VyVG9VVEMgYXMgZCwgdXRjVG9EYXRlUGlja2VyIGFzIHUgfTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0ZS03OWM3ZDkzYy5qcy5tYXAiLCIvKiFcbiAqIEFsbCBtYXRlcmlhbCBjb3B5cmlnaHQgRVNSSSwgQWxsIFJpZ2h0cyBSZXNlcnZlZCwgdW5sZXNzIG90aGVyd2lzZSBzcGVjaWZpZWQuXG4gKiB2NC4wLjU4XG4gKi9cbmxldCBfbG9hZGluZ1RpbWVyO1xubGV0IF9yZXF1ZXN0Q2FuY2VsbGVkO1xuZnVuY3Rpb24gc3RhcnRMb2FkaW5nKG5vZGUpIHtcbiAgICBub2RlLmxvYWRpbmcgPSB0cnVlO1xuICAgIF9yZXF1ZXN0Q2FuY2VsbGVkID0gZmFsc2U7XG4gICAgaWYgKF9sb2FkaW5nVGltZXIpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KF9sb2FkaW5nVGltZXIpO1xuICAgIH1cbiAgICBfbG9hZGluZ1RpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIC8vIHRvb2sgdG9vIGxvbmdcbiAgICAgICAgZW5kTG9hZGluZyhub2RlKTtcbiAgICAgICAgX3JlcXVlc3RDYW5jZWxsZWQgPSB0cnVlO1xuICAgIH0sIDYwMDAwKTtcbn1cbmZ1bmN0aW9uIGVuZExvYWRpbmcobm9kZSkge1xuICAgIG5vZGUubG9hZGluZyA9IGZhbHNlO1xufVxuZnVuY3Rpb24gcmVxdWVzdFdyYXBwZXIocmVxdWVzdCwgbm9kZSkge1xuICAgIHN0YXJ0TG9hZGluZyhub2RlKTtcbiAgICByZXR1cm4gcmVxdWVzdFxuICAgICAgICAudGhlbigocmVzdWx0KSA9PiB7XG4gICAgICAgIGVuZExvYWRpbmcobm9kZSk7XG4gICAgICAgIGlmICghX3JlcXVlc3RDYW5jZWxsZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJ0aW1lb3V0XCIpKTtcbiAgICAgICAgfVxuICAgIH0pXG4gICAgICAgIC5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgICAgZW5kTG9hZGluZyhub2RlKTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yKTtcbiAgICB9KTtcbn1cblxuZXhwb3J0IHsgcmVxdWVzdFdyYXBwZXIgYXMgciB9O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1sb2FkaW5nLTY5MTM5OTA3LmpzLm1hcCIsIi8qIVxuICogQWxsIG1hdGVyaWFsIGNvcHlyaWdodCBFU1JJLCBBbGwgUmlnaHRzIFJlc2VydmVkLCB1bmxlc3Mgb3RoZXJ3aXNlIHNwZWNpZmllZC5cbiAqIHY0LjAuNThcbiAqL1xuaW1wb3J0IHsgcyBhcyBzbWFydE1hcHBpbmdTdGF0ZSB9IGZyb20gJy4vcmFzdGVyLXVuaXF1ZS12YWx1ZS0wOTc2ZWM3Zi5qcyc7XG5pbXBvcnQgJy4vbG9hZE1vZHVsZXMtYjRhYzEyNDcuanMnO1xuaW1wb3J0ICcuL2NvbW1vbkVudW1zLWZjZjEzNjYxLmpzJztcblxuZnVuY3Rpb24gYmFyQ3JlYXRlZEZ1bmN0aW9uKGNvbG9yVmlzVmFyT3JCcmVha3MsIGhpc3RvZ3JhbSwgc2xpZGVyQmFycywgaWR4LCBlbGVtZW50KSB7XG4gICAgY29uc3QgY29sb3IgPSAoY29sb3JWaXNWYXJPckJyZWFrcyA9PT0gbnVsbCB8fCBjb2xvclZpc1Zhck9yQnJlYWtzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb2xvclZpc1Zhck9yQnJlYWtzLmxlbmd0aClcbiAgICAgICAgPyBnZXRDb2xvckZvclZhbHVlQ2xhc3NlZChjb2xvclZpc1Zhck9yQnJlYWtzLCBoaXN0b2dyYW0uYmluc1tpZHhdKVxuICAgICAgICA6IGdldENvbG9yRm9yVmFsdWUoY29sb3JWaXNWYXJPckJyZWFrcy5zdG9wcywgaGlzdG9ncmFtLmJpbnNbaWR4XSk7XG4gICAgY29sb3IgJiYgZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJmaWxsXCIsIGNvbG9yLnRvSGV4KCkpO1xuICAgIGNvbG9yICYmIGVsZW1lbnQuc2V0QXR0cmlidXRlKFwib3BhY2l0eVwiLCBgJHtNYXRoLm1heChjb2xvci5hLCAwLjIpfWApO1xuICAgIHNsaWRlckJhcnMucHVzaChlbGVtZW50KTtcbn1cbmZ1bmN0aW9uIHVwZGF0ZUhpc3RvZ3JhbUNvbG9ycyhzbGlkZXIsIHNsaWRlckJhcnMsIGNvbG9yVmlzVmFyT3JCcmVha3MsIGhpc3RvZ3JhbSkge1xuICAgIHNsaWRlckJhcnMgPT09IG51bGwgfHwgc2xpZGVyQmFycyA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2xpZGVyQmFycy5mb3JFYWNoKChlbGVtZW50LCBpbmRleCkgPT4ge1xuICAgICAgICBjb25zdCBiaW4gPSAoaGlzdG9ncmFtIHx8IHNsaWRlci5oaXN0b2dyYW1Db25maWcpLmJpbnNbaW5kZXhdO1xuICAgICAgICBjb25zdCBjb2xvciA9IHNsaWRlci5icmVha3NcbiAgICAgICAgICAgID8gZ2V0Q29sb3JGb3JWYWx1ZUNsYXNzZWQoY29sb3JWaXNWYXJPckJyZWFrcyB8fCBzbGlkZXIuYnJlYWtzLCBiaW4pXG4gICAgICAgICAgICA6IGdldENvbG9yRm9yVmFsdWUoKGNvbG9yVmlzVmFyT3JCcmVha3MgfHwgc2xpZGVyKVxuICAgICAgICAgICAgICAgIC5zdG9wcywgYmluKTtcbiAgICAgICAgY29sb3IgJiYgZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJmaWxsXCIsIGNvbG9yLnRvSGV4KCkpO1xuICAgICAgICBjb2xvciAmJiBlbGVtZW50LnNldEF0dHJpYnV0ZShcIm9wYWNpdHlcIiwgYCR7TWF0aC5tYXgoY29sb3IuYSwgMC4yKX1gKTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGdldENvbG9yRm9yVmFsdWUoc3RvcHMsIGJpbikge1xuICAgIC8vIGluZmVycyB0aGUgY29sb3IgZm9yIGEgZ2l2ZW4gdmFsdWVcbiAgICAvLyBiYXNlZCBvbiB0aGUgc3RvcHMgZnJvbSBhIENvbG9yVmFyaWFibGVcbiAgICBjb25zdCB7IG1vZHVsZXMgfSA9IHNtYXJ0TWFwcGluZ1N0YXRlO1xuICAgIGlmICghYmluKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgdmFsdWUgPSAoYmluLm1heFZhbHVlIC0gYmluLm1pblZhbHVlKSAvIDIgKyBiaW4ubWluVmFsdWU7XG4gICAgbGV0IG1pblN0b3AgPSBzdG9wc1swXTtcbiAgICBsZXQgbWF4U3RvcCA9IHN0b3BzW3N0b3BzLmxlbmd0aCAtIDFdO1xuICAgIGNvbnN0IG1pblN0b3BWYWx1ZSA9IG1pblN0b3AudmFsdWU7XG4gICAgY29uc3QgbWF4U3RvcFZhbHVlID0gbWF4U3RvcC52YWx1ZTtcbiAgICBpZiAodmFsdWUgPCBtaW5TdG9wVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIG1pblN0b3AuY29sb3I7XG4gICAgfVxuICAgIGlmICh2YWx1ZSA+IG1heFN0b3BWYWx1ZSkge1xuICAgICAgICByZXR1cm4gbWF4U3RvcC5jb2xvcjtcbiAgICB9XG4gICAgY29uc3QgZXhhY3RNYXRjaGVzID0gc3RvcHMuZmlsdGVyKChzdG9wKSA9PiBzdG9wLnZhbHVlID09PSB2YWx1ZSk7XG4gICAgaWYgKGV4YWN0TWF0Y2hlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHJldHVybiBleGFjdE1hdGNoZXNbMF0uY29sb3I7XG4gICAgfVxuICAgIG1pblN0b3AgPSBudWxsO1xuICAgIG1heFN0b3AgPSBudWxsO1xuICAgIHN0b3BzLmZvckVhY2goKHN0b3AsIGkpID0+IHtcbiAgICAgICAgaWYgKCFtaW5TdG9wICYmICFtYXhTdG9wICYmIHN0b3AudmFsdWUgPj0gdmFsdWUpIHtcbiAgICAgICAgICAgIG1pblN0b3AgPSBzdG9wc1tpIC0gMV07XG4gICAgICAgICAgICBtYXhTdG9wID0gc3RvcDtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGNvbnN0IHdlaWdodGVkUG9zaXRpb24gPSAodmFsdWUgLSBtaW5TdG9wLnZhbHVlKSAvIChtYXhTdG9wLnZhbHVlIC0gbWluU3RvcC52YWx1ZSk7XG4gICAgcmV0dXJuIG1vZHVsZXMuZXNyaUNvbG9yLmJsZW5kQ29sb3JzKG1pblN0b3AuY29sb3IsIG1heFN0b3AuY29sb3IsIHdlaWdodGVkUG9zaXRpb24pO1xufVxuZnVuY3Rpb24gZ2V0Q29sb3JGb3JWYWx1ZUNsYXNzZWQoYnJlYWtzLCBiaW4pIHtcbiAgICAvLyBpbmZlcnMgdGhlIGNvbG9yIGZvciBhIGdpdmVuIHZhbHVlXG4gICAgLy8gYmFzZWQgb24gdGhlIGNsYXNzQnJlYWtJbmZvXG4gICAgaWYgKCFiaW4pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB2YWx1ZSA9IChiaW4ubWF4VmFsdWUgLSBiaW4ubWluVmFsdWUpIC8gMiArIGJpbi5taW5WYWx1ZTtcbiAgICBsZXQgbWluQnJlYWsgPSBicmVha3NbMF07XG4gICAgbGV0IG1heEJyZWFrID0gYnJlYWtzW2JyZWFrcy5sZW5ndGggLSAxXTtcbiAgICBpZiAodmFsdWUgPCBtaW5CcmVhay5taW4gfHwgdmFsdWUgPiBtYXhCcmVhay5tYXgpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgY29uc3QgZXhhY3RNYXRjaGVzID0gYnJlYWtzLmZpbHRlcigoYikgPT4gYi5taW4gPT09IHZhbHVlKTtcbiAgICBpZiAoZXhhY3RNYXRjaGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcmV0dXJuIGV4YWN0TWF0Y2hlc1swXS5jb2xvcjtcbiAgICB9XG4gICAgbWluQnJlYWsgPSBicmVha3NbYnJlYWtzLmxlbmd0aCAtIDFdO1xuICAgIG1heEJyZWFrID0gbnVsbDtcbiAgICBicmVha3MuZm9yRWFjaCgoYiwgaSkgPT4ge1xuICAgICAgICBpZiAoIW1heEJyZWFrICYmIGIubWluID49IHZhbHVlKSB7XG4gICAgICAgICAgICBtaW5CcmVhayA9IGJyZWFrc1tpIC0gMV07XG4gICAgICAgICAgICBtYXhCcmVhayA9IGI7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gbWluQnJlYWsuY29sb3I7XG59XG5cbmV4cG9ydCB7IGJhckNyZWF0ZWRGdW5jdGlvbiBhcyBiLCB1cGRhdGVIaXN0b2dyYW1Db2xvcnMgYXMgdSB9O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1zbGlkZXItZTE2MmUxMzYuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9